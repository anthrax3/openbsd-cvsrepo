head	1.9;
access;
symbols
	OPENBSD_5_5:1.7.0.14
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.10
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.8
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.8
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.6
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.20
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.18
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.16
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.14
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.12
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.10
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.07.23.19.13.25;	author deraadt;	state dead;
branches;
next	1.8;
commitid	EcR8E7r0stjLUV4p;

1.8
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.7;
commitid	lGGuvDWEniklWrQe;

1.7
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.22.04.52.36;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.47;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.38;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.05;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.58;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.58;	author maja;	state Exp;
branches;
next	;


desc
@@


1.9
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTAlert.c,v 1.101 2013/11/28 11:17:04 tom Exp $
 *
 *	Displaying messages and getting input for Lynx Browser
 *	==========================================================
 *
 *	REPLACE THIS MODULE with a GUI version in a GUI environment!
 *
 * History:
 *	   Jun 92 Created May 1992 By C.T. Barker
 *	   Feb 93 Simplified, portablised TBL
 *
 */

#include <HTUtils.h>
#include <HTAlert.h>
#include <LYGlobalDefs.h>
#include <LYCurses.h>
#include <LYStrings.h>
#include <LYUtils.h>
#include <LYClean.h>
#include <GridText.h>
#include <LYCookie.h>
#include <LYHistory.h>		/* store statusline messages */

#include <LYLeaks.h>

#include <HTParse.h>

#undef timezone			/* U/Win defines this in time.h, hides implementation detail */

#if defined(HAVE_FTIME) && defined(HAVE_SYS_TIMEB_H)
#include <sys/timeb.h>
#endif

/*
 * 'napms()' is preferable to 'sleep()' in any case because it does not
 * interfere with output, but also because it can be less than a second.
 */
#ifdef HAVE_NAPMS
#define LYSleep(n) napms(n)
#else
#define LYSleep(n) sleep((unsigned)n)
#endif

/*	Issue a message about a problem.		HTAlert()
 *	--------------------------------
 */
void HTAlert(const char *Msg)
{
    CTRACE((tfp, "\nAlert!: %s\n\n", Msg));
    CTRACE_FLUSH(tfp);
    _user_message(ALERT_FORMAT, Msg);
    LYstore_message2(ALERT_FORMAT, Msg);

    if (dump_output_immediately && dump_to_stderr) {
	fflush(stdout);
	fprintf(stderr, ALERT_FORMAT, Msg);
	fputc('\n', stderr);
	fflush(stderr);
    }

    LYSleepAlert();
}

void HTAlwaysAlert(const char *extra_prefix,
		   const char *Msg)
{
    if (!dump_output_immediately && LYCursesON) {
	HTAlert(Msg);
    } else {
	if (extra_prefix) {
	    fprintf(((TRACE) ? stdout : stderr),
		    "%s %s!\n",
		    extra_prefix, Msg);
	    fflush(stdout);
	    LYstore_message2(ALERT_FORMAT, Msg);
	    LYSleepAlert();
	} else {
	    fprintf(((TRACE) ? stdout : stderr), ALERT_FORMAT, NonNull(Msg));
	    fflush(stdout);
	    LYstore_message2(ALERT_FORMAT, Msg);
	    LYSleepAlert();
	    fprintf(((TRACE) ? stdout : stderr), "\n");
	}
	CTRACE((tfp, "\nAlert!: %s\n\n", Msg));
	CTRACE_FLUSH(tfp);
    }
}

/*	Issue an informational message.			HTInfoMsg()
 *	--------------------------------
 */
void HTInfoMsg(const char *Msg)
{
    _statusline(Msg);
    if (non_empty(Msg)) {
	CTRACE((tfp, "Info message: %s\n", Msg));
	LYstore_message(Msg);
	LYSleepInfo();
    }
}

void HTInfoMsg2(const char *Msg2, const char *Arg)
{
    _user_message(Msg2, Arg);
    if (non_empty(Msg2)) {
	CTRACE((tfp, "Info message: "));
	CTRACE((tfp, Msg2, Arg));
	CTRACE((tfp, "\n"));
	LYstore_message2(Msg2, Arg);
	LYSleepInfo();
    }
}

/*	Issue an important message.			HTUserMsg()
 *	--------------------------------
 */
void HTUserMsg(const char *Msg)
{
    _statusline(Msg);
    if (non_empty(Msg)) {
	CTRACE((tfp, "User message: %s\n", Msg));
	LYstore_message(Msg);
#if !(defined(USE_SLANG) || defined(WIDEC_CURSES))
	if (IS_CJK_TTY) {
	    clearok(curscr, TRUE);
	    LYrefresh();
	}
#endif
	LYSleepMsg();
    }
}

void HTUserMsg2(const char *Msg2, const char *Arg)
{
    _user_message(Msg2, Arg);
    if (non_empty(Msg2)) {
	CTRACE((tfp, "User message: "));
	CTRACE((tfp, Msg2, Arg));
	CTRACE((tfp, "\n"));
	LYstore_message2(Msg2, Arg);
	LYSleepMsg();
    }
}

/*	Issue a progress message.			HTProgress()
 *	-------------------------
 */
void HTProgress(const char *Msg)
{
    statusline(Msg);
    LYstore_message(Msg);
    CTRACE((tfp, "%s\n", Msg));
    LYSleepDelay();
}

const char *HTProgressUnits(int rate)
{
    static const char *bunits = 0;
    static const char *kbunits = 0;

    if (!bunits) {
	bunits = gettext("bytes");
	kbunits = gettext(LYTransferName);
    }
    return ((rate == rateKB)
#ifdef USE_READPROGRESS
	    || (rate == rateEtaKB)
	    || (rate == rateEtaKB2)
#endif
	)? kbunits : bunits;
}

static const char *sprint_bytes(char *s, off_t n, const char *was_units)
{
    static off_t kb_units = 1024;
    const char *u = HTProgressUnits(LYTransferRate);

    if (isRateInKB(LYTransferRate)) {
	if (n >= 10 * kb_units) {
	    sprintf(s, "%" PRI_off_t, CAST_off_t (n / kb_units));
	} else if (n > 999) {	/* Avoid switching between 1016b/s and 1K/s */
	    sprintf(s, "%.2g", ((double) n) / (double) kb_units);
	} else {
	    sprintf(s, "%" PRI_off_t, CAST_off_t (n));

	    u = HTProgressUnits(rateBYTES);
	}
    } else {
	sprintf(s, "%" PRI_off_t, CAST_off_t (n));
    }

    if (!was_units || was_units != u)
	sprintf(s + strlen(s), " %s", u);
    return u;
}

#ifdef USE_READPROGRESS
#define TIME_HMS_LENGTH (36)
static char *sprint_tbuf(char *s, long t)
{
    const char *format = ((LYTransferRate == rateEtaBYTES2 ||
			   LYTransferRate == rateEtaKB2)
			  ? "% 2ld%c"
			  : "%ld%c");
    char *base = s;

    if (t < 0) {
	strcpy(s, "forever");
    } else {
	if (t > (3600 * 24)) {
	    sprintf(s, format, t / (3600 * 24), 'd');
	    s += strlen(s);
	    t %= (3600 * 24);
	}
	if (t > 3600) {
	    sprintf(s, format, t / 3600, 'h');
	    s += strlen(s);
	    t %= 3600;
	}
	if (t > 60) {
	    sprintf(s, format, t / 60, 'm');
	    s += strlen(s);
	    t %= 60;
	}
	if (s == base) {
	    sprintf(s, "% 2ld sec", t);
	} else if (t != 0) {
	    sprintf(s, format, t, 's');
	}
    }
    return base;
}
#endif /* USE_READPROGRESS */

/*	Issue a read-progress message.			HTReadProgress()
 *	------------------------------
 */
void HTReadProgress(off_t bytes, off_t total)
{
    static off_t bytes_last, total_last;
    static off_t transfer_rate = 0;
    static char *line = NULL;
    char bytesp[80], totalp[80], transferp[80];
    int renew = 0;
    const char *was_units;

#ifdef HAVE_GETTIMEOFDAY
    struct timeval tv;
    double now;
    static double first, last, last_active;

    gettimeofday(&tv, (struct timezone *) 0);
    now = (double) tv.tv_sec + (double) tv.tv_usec / 1000000.;
#else
#if defined(HAVE_FTIME) && defined(HAVE_SYS_TIMEB_H)
    static double now, first, last, last_active;
    struct timeb tb;

    ftime(&tb);
    now = tb.time + (double) tb.millitm / 1000;
#else
    time_t now = time((time_t *) 0);	/* once per second */
    static time_t first, last, last_active;
#endif
#endif

    if (!LYShowTransferRate)
	LYTransferRate = rateOFF;

    if (bytes == 0) {
	first = last = last_active = now;
	bytes_last = bytes;
    } else if (bytes < 0) {	/* stalled */
	bytes = bytes_last;
	total = total_last;
    }

    /* 1 sec delay for transfer_rate calculation without g-t-o-d */
    if ((bytes > 0) &&
	(now > first)) {
	if (transfer_rate <= 0) {	/* the very first time */
	    transfer_rate = (off_t) ((double) (bytes) / (now - first));
	    /* bytes/sec */
	}
	total_last = total;

	/*
	 * Optimal refresh time:  every 0.2 sec
	 */
#if defined(HAVE_GETTIMEOFDAY) || (defined(HAVE_FTIME) && defined(HAVE_SYS_TIMEB_H))
	if (now >= last + 0.2)
	    renew = 1;
#else
	/*
	 * Use interpolation.  (The transfer rate may be not constant
	 * when we have partial content in a proxy.  We adjust transfer_rate
	 * once a second to minimize interpolation error below.)
	 */
	if ((now != last) || ((bytes - bytes_last) > (transfer_rate / 5))) {
	    renew = 1;
	    bytes_last += (transfer_rate / 5);	/* until we got next second */
	}
#endif
	if (renew) {
	    if (now > last) {
		last = now;
		if (bytes_last != bytes)
		    last_active = now;
		bytes_last = bytes;
		transfer_rate = (off_t) ((double) bytes / (now - first));	/* more accurate value */
	    }

	    if (total > 0)
		was_units = sprint_bytes(totalp, total, 0);
	    else
		was_units = 0;
	    sprint_bytes(bytesp, bytes, was_units);

	    switch ((TransferRate) LYTransferRate) {
#ifdef USE_PROGRESSBAR
	    case rateBAR:
		/*
		 * If we know the total size of the file, we can compute
		 * a percentage, and show a corresponding progress bar.
		 */
		HTSprintf0(&line, gettext("Read %s of data"), bytesp);

		if (total > 0) {
		    float percent = (float) bytes / (float) total;
		    int meter = (int) (((float) LYcolLimit * percent) - 5);

		    CTRACE((tfp, "rateBAR: bytes: %" PRI_off_t ", total: "
			    "%" PRI_off_t "\n",
			    CAST_off_t (bytes),
			    CAST_off_t (total)));
		    CTRACE((tfp, "meter = %d\n", meter));

		    HTSprintf0(&line, "%d%% ", (int) (percent * 100));
		    while (meter-- > 0)
			StrAllocCat(line, "I");

		    CTRACE((tfp, "%s\n", line));
		    CTRACE_FLUSH(tfp);
		}
		break;
#endif
	    default:
		if (total > 0) {
		    HTSprintf0(&line, gettext("Read %s of %s of data"),
			       bytesp, totalp);
		} else {
		    HTSprintf0(&line, gettext("Read %s of data"), bytesp);
		}

		if (LYTransferRate != rateOFF
		    && transfer_rate > 0) {
		    sprint_bytes(transferp, transfer_rate, 0);
		    HTSprintf(&line, gettext(", %s/sec"), transferp);
		}
		break;
	    }

#ifdef USE_READPROGRESS
	    if (LYTransferRate == rateEtaBYTES
		|| LYTransferRate == rateEtaKB
		|| LYTransferRate == rateEtaBYTES2
		|| LYTransferRate == rateEtaKB2) {
		char tbuf[TIME_HMS_LENGTH];

		if (now - last_active >= 5)
		    HTSprintf(&line,
			      gettext(" (stalled for %s)"),
			      sprint_tbuf(tbuf, (long) (now - last_active)));
		if (total > 0 && transfer_rate)
		    HTSprintf(&line,
			      gettext(", ETA %s"),
			      sprint_tbuf(tbuf, (long) ((total - bytes) / transfer_rate)));
	    }
#endif

	    switch ((TransferRate) LYTransferRate) {
#ifdef USE_PROGRESSBAR
	    case rateBAR:
		/*
		 * If we were not able to show a progress bar, just show
		 * a "." for progress.
		 */
		if (total <= 0)
		    StrAllocCat(line, ".");
		break;
#endif
	    default:
		StrAllocCat(line, ".");
		break;
	    }

	    if (total < -1)
		StrAllocCat(line, gettext(" (Press 'z' to abort)"));

	    /* do not store the message for history page. */
	    statusline(line);
	    CTRACE((tfp, "%s\n", line));
	}
    }
#ifdef LY_FIND_LEAKS
    FREE(line);
#endif
}

static BOOL conf_cancelled = NO;	/* used by HTConfirm only - kw */

BOOL HTLastConfirmCancelled(void)
{
    if (conf_cancelled) {
	conf_cancelled = NO;	/* reset */
	return (YES);
    } else {
	return (NO);
    }
}

/*
 * Prompt for yes/no response, but let a configuration variable override
 * the prompt entirely.
 */
int HTForcedPrompt(int option, const char *msg, int dft)
{
    int result = FALSE;
    const char *show = NULL;
    char *msg2 = NULL;

    if (option == FORCE_PROMPT_DFT) {
	result = HTConfirmDefault(msg, dft);
    } else {
	if (option == FORCE_PROMPT_YES) {
	    show = gettext("yes");
	    result = YES;
	} else if (option == FORCE_PROMPT_NO) {
	    show = gettext("no");
	    result = NO;
	} else {
	    return HTConfirmDefault(msg, dft);	/* bug... */
	}
	HTSprintf(&msg2, "%s %s", msg, show);
	HTUserMsg(msg2);
	free(msg2);
    }
    return result;
}

#define DFT_CONFIRM ~(YES|NO)

/*	Seek confirmation with default answer.		HTConfirmDefault()
 *	--------------------------------------
 */
int HTConfirmDefault(const char *Msg, int Dft)
{
/* Meta-note: don't move the following note from its place right
   in front of the first gettext().  As it is now, it should
   automatically appear in generated lynx.pot files. - kw
 */

/* NOTE TO TRANSLATORS:  If you provide a translation for "yes", lynx
 * will take the first byte of the translation as a positive response
 * to Yes/No questions.  If you provide a translation for "no", lynx
 * will take the first byte of the translation as a negative response
 * to Yes/No questions.  For both, lynx will also try to show the
 * first byte in the prompt as a character, instead of (y) or (n),
 * respectively.  This will not work right for multibyte charsets!
 * Don't translate "yes" and "no" for CJK character sets (or translate
 * them to "yes" and "no").  For a translation using UTF-8, don't
 * translate if the translation would begin with anything but a 7-bit
 * (US_ASCII) character.  That also means do not translate if the
 * translation would begin with anything but a 7-bit character, if
 * you use a single-byte character encoding (a charset like ISO-8859-n)
 * but anticipate that the message catalog may be used re-encoded in
 * UTF-8 form.
 * For translations using other character sets, you may also wish to
 * leave "yes" and "no" untranslated, if using (y) and (n) is the
 * preferred behavior.
 * Lynx will also accept y Y n N as responses unless there is a conflict
 * with the first letter of the "yes" or "no" translation.
 */
    const char *msg_yes = gettext("yes");
    const char *msg_no = gettext("no");
    int result = -1;

    /* If they're not really distinct in the first letter, revert to English */
    if (TOUPPER(*msg_yes) == TOUPPER(*msg_no)) {
	msg_yes = "yes";
	msg_no = "no";
    }

    conf_cancelled = NO;
    if (dump_output_immediately) {	/* Non-interactive, can't respond */
	if (Dft == DFT_CONFIRM) {
	    CTRACE((tfp, "Confirm: %s (%c/%c) ", Msg, *msg_yes, *msg_no));
	} else {
	    CTRACE((tfp, "Confirm: %s (%c) ", Msg, (Dft == YES) ? *msg_yes : *msg_no));
	}
	CTRACE((tfp, "- NO, not interactive.\n"));
	result = NO;
    } else {
	char *msg = NULL;
	char fallback_y = 'y';	/* English letter response as fallback */
	char fallback_n = 'n';	/* English letter response as fallback */

	if (fallback_y == *msg_yes || fallback_y == *msg_no)
	    fallback_y = '\0';	/* conflict or duplication, don't use */
	if (fallback_n == *msg_yes || fallback_n == *msg_no)
	    fallback_n = '\0';	/* conflict or duplication, don't use */

	if (Dft == DFT_CONFIRM)
	    HTSprintf0(&msg, "%s (%c/%c) ", Msg, *msg_yes, *msg_no);
	else
	    HTSprintf0(&msg, "%s (%c) ", Msg, (Dft == YES) ? *msg_yes : *msg_no);
	if (LYTraceLogFP) {
	    CTRACE((tfp, "Confirm: %s", msg));
	}
	_statusline(msg);
	FREE(msg);

	while (result < 0) {
	    int c = LYgetch_single();

#ifdef VMS
	    if (HadVMSInterrupt) {
		HadVMSInterrupt = FALSE;
		c = TOUPPER(*msg_no);
	    }
#endif /* VMS */
	    if (c == TOUPPER(*msg_yes)) {
		result = YES;
	    } else if (c == TOUPPER(*msg_no)) {
		result = NO;
	    } else if (fallback_y && c == fallback_y) {
		result = YES;
	    } else if (fallback_n && c == fallback_n) {
		result = NO;
	    } else if (LYCharIsINTERRUPT(c)) {	/* remember we had ^G or ^C */
		conf_cancelled = YES;
		result = NO;
	    } else if (Dft != DFT_CONFIRM) {
		result = Dft;
		break;
	    }
	}
	CTRACE((tfp, "- %s%s.\n",
		(result != NO) ? "YES" : "NO",
		conf_cancelled ? ", cancelled" : ""));
    }
    return (result);
}

/*	Seek confirmation.				HTConfirm()
 *	------------------
 */
BOOL HTConfirm(const char *Msg)
{
    return (BOOL) HTConfirmDefault(Msg, DFT_CONFIRM);
}

/*
 * Ask a post resubmission prompt with some indication of what would
 * be resubmitted, useful especially for going backward in history.
 * Try to use parts of the address or, if given, the title, depending
 * on how much fits on the statusline.
 * if_imgmap and if_file indicate how to handle an address that is
 * a "LYNXIMGMAP:", or a "file:" URL (presumably the List Page file),
 * respectively:  0:  auto-deny, 1:  auto-confirm, 2:  prompt.
 * - kw
 */

BOOL confirm_post_resub(const char *address,
			const char *title,
			int if_imgmap,
			int if_file)
{
    size_t len1;
    const char *msg = CONFIRM_POST_RESUBMISSION_TO;
    char buf[240];
    char *temp = NULL;
    BOOL res;
    size_t maxlen = (size_t) (LYcolLimit - 5);

    if (!address) {
	return (NO);
    } else if (isLYNXIMGMAP(address)) {
	if (if_imgmap <= 0)
	    return (NO);
	else if (if_imgmap == 1)
	    return (YES);
	else
	    msg = CONFIRM_POST_LIST_RELOAD;
    } else if (isFILE_URL(address)) {
	if (if_file <= 0)
	    return (NO);
	else if (if_file == 1)
	    return (YES);
	else
	    msg = CONFIRM_POST_LIST_RELOAD;
    } else if (dump_output_immediately) {
	return (NO);
    }
    if (maxlen >= sizeof(buf))
	maxlen = sizeof(buf) - 1;
    if ((len1 = strlen(msg)) +
	strlen(address) <= maxlen) {
	sprintf(buf, msg, address);
	return HTConfirm(buf);
    }
    if (len1 + strlen(temp = HTParse(address, "",
				     PARSE_ACCESS + PARSE_HOST + PARSE_PATH
				     + PARSE_PUNCTUATION)) <= maxlen) {
	sprintf(buf, msg, temp);
	res = HTConfirm(buf);
	FREE(temp);
	return (res);
    }
    FREE(temp);
    if (title && (len1 + strlen(title) <= maxlen)) {
	sprintf(buf, msg, title);
	return HTConfirm(buf);
    }
    if (len1 + strlen(temp = HTParse(address, "",
				     PARSE_ACCESS + PARSE_HOST
				     + PARSE_PUNCTUATION)) <= maxlen) {
	sprintf(buf, msg, temp);
	res = HTConfirm(buf);
	FREE(temp);
	return (res);
    }
    FREE(temp);
    if ((temp = HTParse(address, "", PARSE_HOST)) && *temp &&
	len1 + strlen(temp) <= maxlen) {
	sprintf(buf, msg, temp);
	res = HTConfirm(buf);
	FREE(temp);
	return (res);
    }
    FREE(temp);
    return HTConfirm(CONFIRM_POST_RESUBMISSION);
}

/*	Prompt for answer and get text back.		HTPrompt()
 *	------------------------------------
 */
char *HTPrompt(const char *Msg, const char *deflt)
{
    char *rep = NULL;
    bstring *data = NULL;

    _statusline(Msg);
    BStrCopy0(data, deflt ? deflt : "");

    if (!dump_output_immediately)
	(void) LYgetBString(&data, FALSE, 0, NORECALL);

    StrAllocCopy(rep, data->str);

    BStrFree(data);
    return rep;
}

/*
 *	Prompt for password without echoing the reply.	HTPromptPassword()
 *	----------------------------------------------
 */
char *HTPromptPassword(const char *Msg)
{
    char *result = NULL;
    bstring *data = NULL;

    if (!dump_output_immediately) {
	_statusline(Msg ? Msg : PASSWORD_PROMPT);
	BStrCopy0(data, "");
	(void) LYgetBString(&data, TRUE, 0, NORECALL);
	StrAllocCopy(result, data->str);
	BStrFree(data);
    } else {
	printf("\n%s\n", PASSWORD_REQUIRED);
	StrAllocCopy(result, "");
    }
    return result;
}

/*	Prompt both username and password.	 HTPromptUsernameAndPassword()
 *	----------------------------------
 *
 *  On entry,
 *	Msg		is the prompting message.
 *	*username and
 *	*password	are char pointers which contain default
 *			or zero-length strings; they are changed
 *			to point to result strings.
 *	IsProxy 	should be TRUE if this is for
 *			proxy authentication.
 *
 *			If *username is not NULL, it is taken
 *			to point to a default value.
 *			Initial value of *password is
 *			completely discarded.
 *
 *  On exit,
 *	*username and *password point to newly allocated
 *	strings -- original strings pointed to by them
 *	are NOT freed.
 *
 */
void HTPromptUsernameAndPassword(const char *Msg,
				 char **username,
				 char **password,
				 int IsProxy)
{
    if ((IsProxy == FALSE &&
	 authentication_info[0] && authentication_info[1]) ||
	(IsProxy == TRUE &&
	 proxyauth_info[0] && proxyauth_info[1])) {
	/*
	 * The -auth or -pauth parameter gave us both the username
	 * and password to use for the first realm or proxy server,
	 * respectively, so just use them without any prompting.  - FM
	 */
	StrAllocCopy(*username, (IsProxy ?
				 proxyauth_info[0] : authentication_info[0]));
	if (IsProxy) {
	    FREE(proxyauth_info[0]);
	} else {
	    FREE(authentication_info[0]);
	}
	StrAllocCopy(*password, (IsProxy ?
				 proxyauth_info[1] : authentication_info[1]));
	if (IsProxy) {
	    FREE(proxyauth_info[1]);
	} else {
	    FREE(authentication_info[1]);
	}
    } else if (dump_output_immediately) {
	/*
	 * We are not interactive and don't have both the
	 * username and password from the command line,
	 * but might have one or the other.  - FM
	 */
	if ((IsProxy == FALSE && authentication_info[0]) ||
	    (IsProxy == TRUE && proxyauth_info[0])) {
	    /*
	     * Use the command line username.  - FM
	     */
	    StrAllocCopy(*username, (IsProxy ?
				     proxyauth_info[0] : authentication_info[0]));
	    if (IsProxy) {
		FREE(proxyauth_info[0]);
	    } else {
		FREE(authentication_info[0]);
	    }
	} else {
	    /*
	     * Default to "WWWuser".  - FM
	     */
	    StrAllocCopy(*username, "WWWuser");
	}
	if ((IsProxy == FALSE && authentication_info[1]) ||
	    (IsProxy == TRUE && proxyauth_info[1])) {
	    /*
	     * Use the command line password.  - FM
	     */
	    StrAllocCopy(*password, (IsProxy ?
				     proxyauth_info[1] : authentication_info[1]));
	    if (IsProxy) {
		FREE(proxyauth_info[1]);
	    } else {
		FREE(authentication_info[1]);
	    }
	} else {
	    /*
	     * Default to a zero-length string.  - FM
	     */
	    StrAllocCopy(*password, "");
	}
	printf("\n%s\n", USERNAME_PASSWORD_REQUIRED);

    } else {
	/*
	 * We are interactive and don't have both the
	 * username and password from the command line,
	 * but might have one or the other.  - FM
	 */
	if ((IsProxy == FALSE && authentication_info[0]) ||
	    (IsProxy == TRUE && proxyauth_info[0])) {
	    /*
	     * Offer the command line username in the
	     * prompt for the first realm.  - FM
	     */
	    StrAllocCopy(*username, (IsProxy ?
				     proxyauth_info[0] : authentication_info[0]));
	    if (IsProxy) {
		FREE(proxyauth_info[0]);
	    } else {
		FREE(authentication_info[0]);
	    }
	}
	/*
	 * Prompt for confirmation or entry of the username.  - FM
	 */
	if (Msg != NULL) {
	    *username = HTPrompt(Msg, *username);
	} else {
	    *username = HTPrompt(USERNAME_PROMPT, *username);
	}
	if ((IsProxy == FALSE && authentication_info[1]) ||
	    (IsProxy == TRUE && proxyauth_info[1])) {
	    /*
	     * Use the command line password for the first realm.  - FM
	     */
	    StrAllocCopy(*password, (IsProxy ?
				     proxyauth_info[1] : authentication_info[1]));
	    if (IsProxy) {
		FREE(proxyauth_info[1]);
	    } else {
		FREE(authentication_info[1]);
	    }
	} else if (non_empty(*username)) {
	    /*
	     * We have a non-zero length username,
	     * so prompt for the password.  - FM
	     */
	    *password = HTPromptPassword(PASSWORD_PROMPT);
	} else {
	    /*
	     * Return a zero-length password.  - FM
	     */
	    StrAllocCopy(*password, "");
	}
    }
}

/*	Confirm a cookie operation.			HTConfirmCookie()
 *	---------------------------
 *
 *  On entry,
 *	server			is the server sending the Set-Cookie.
 *	domain			is the domain of the cookie.
 *	path			is the path of the cookie.
 *	name			is the name of the cookie.
 *	value			is the value of the cookie.
 *
 *  On exit,
 *	Returns FALSE on cancel,
 *		TRUE if the cookie should be set.
 */
BOOL HTConfirmCookie(domain_entry * de, const char *server,
		     const char *name,
		     const char *value)
{
    int ch;
    const char *prompt = ADVANCED_COOKIE_CONFIRMATION;

    if (de == NULL)
	return FALSE;

    /* If the user has specified a list of domains to allow or deny
     * from the config file, then they'll already have de->bv set to
     * ACCEPT_ALWAYS or REJECT_ALWAYS so we can relax and let the
     * default cookie handling code cope with this fine.
     */

    /*
     * If the user has specified a constant action, don't prompt at all.
     */
    if (de->bv == ACCEPT_ALWAYS)
	return TRUE;
    if (de->bv == REJECT_ALWAYS)
	return FALSE;

    if (dump_output_immediately) {
	/*
	 * Non-interactive, can't respond.  Use the LYSetCookies value
	 * based on its compilation or configuration setting, or on the
	 * command line toggle.  - FM
	 */
	return LYSetCookies;
    }

    /*
     * Estimate how much of the cookie we can show.
     */
    if (!LYAcceptAllCookies) {
	int namelen, valuelen, space_free, percentage;
	char *message = 0;

	space_free = (LYcolLimit
		      - (LYstrCells(prompt)
			 - 10)	/* %s and %.*s and %.*s chars */
		      -(int) strlen(server));
	if (space_free < 0)
	    space_free = 0;
	namelen = (int) strlen(name);
	valuelen = (int) strlen(value);
	if ((namelen + valuelen) > space_free) {
	    /*
	     * Argh...  there isn't enough space on our single line for
	     * the whole cookie.  Reduce them both by a percentage.
	     * This should be smarter.
	     */
	    percentage = (100 * space_free) / (namelen + valuelen);
	    namelen = (percentage * namelen) / 100;
	    valuelen = (percentage * valuelen) / 100;
	}
	HTSprintf(&message, prompt, server, namelen, name, valuelen, value);
	_statusline(message);
	FREE(message);
    }
    for (;;) {
	if (LYAcceptAllCookies) {
	    ch = 'A';
	} else {
	    ch = LYgetch_single();
#if defined(LOCALE) && defined(HAVE_GETTEXT)
	    {
#define L_PAREN '('
#define R_PAREN ')'
		/*
		 * Special-purpose workaround for gettext support (we should do
		 * this in a more general way) -TD
		 *
		 * NOTE TO TRANSLATORS:  If the prompt has been rendered into
		 * another language, and if yes/no are distinct, assume the
		 * translator can make an ordered list in parentheses with one
		 * capital letter for each as we assumed in HTConfirmDefault().
		 * The list has to be in the same order as in the original message,
		 * and the four capital letters chosen to not match those in the
		 * original unless they have the same position.
		 *
		 * Example:
		 * (Y/N/Always/neVer)              - English (original)
		 * (O/N/Toujours/Jamais)           - French
		 */
		char *p = gettext("Y/N/A/V");	/* placeholder for comment */
		const char *s = "YNAV\007\003";		/* see ADVANCED_COOKIE_CONFIRMATION */

		if (StrChr(s, ch) == 0
		    && isalpha(ch)
		    && (p = strrchr(prompt, L_PAREN)) != 0) {

		    CTRACE((tfp, "Looking for %c in %s\n", ch, p));
		    while (*p != R_PAREN && *p != 0 && isalpha(UCH(*s))) {
			if (isalpha(UCH(*p)) && (*p == TOUPPER(*p))) {
			    CTRACE((tfp, "...testing %c/%c\n", *p, *s));
			    if (*p == ch) {
				ch = *s;
				break;
			    }
			    ++s;
			}
			++p;
		    }
		}
	    }
#endif
	}
#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    ch = 'N';
	}
#endif /* VMS */
	switch (ch) {
	case 'A':
	    /*
	     * Set to accept all cookies for this domain.
	     */
	    de->bv = ACCEPT_ALWAYS;
	    HTUserMsg2(ALWAYS_ALLOWING_COOKIES, de->domain);
	    return TRUE;

	case 'N':
	    /*
	     * Reject the cookie.
	     */
	  reject:
	    HTUserMsg(REJECTING_COOKIE);
	    return FALSE;

	case 'V':
	    /*
	     * Set to reject all cookies from this domain.
	     */
	    de->bv = REJECT_ALWAYS;
	    HTUserMsg2(NEVER_ALLOWING_COOKIES, de->domain);
	    return FALSE;

	case 'Y':
	    /*
	     * Accept the cookie.
	     */
	    HTInfoMsg(ALLOWING_COOKIE);
	    return TRUE;

	default:
	    if (LYCharIsINTERRUPT(ch))
		goto reject;
	    continue;
	}
    }
}

/*	Confirm redirection of POST.		HTConfirmPostRedirect()
 *	----------------------------
 *
 *  On entry,
 *	Redirecting_url 	    is the Location.
 *	server_status		    is the server status code.
 *
 *  On exit,
 *	Returns 0 on cancel,
 *	  1 for redirect of POST with content,
 *	303 for redirect as GET without content
 */
int HTConfirmPostRedirect(const char *Redirecting_url, int server_status)
{
    int result = -1;
    char *show_POST_url = NULL;
    char *StatusInfo = 0;
    char *url = 0;
    int on_screen = 0;		/* 0 - show menu

				 * 1 - show url
				 * 2 - menu is already on screen */

    if (server_status == 303 ||
	server_status == 302) {
	/*
	 * HTTP.c should not have called us for either of
	 * these because we're treating 302 as historical,
	 * so just return 303.  - FM
	 */
	return 303;
    }

    if (dump_output_immediately) {
	if (server_status == 301) {
	    /*
	     * Treat 301 as historical, i.e., like 303 (GET
	     * without content), when not interactive.  - FM
	     */
	    return 303;
	} else {
	    /*
	     * Treat anything else (e.g., 305, 306 or 307) as too
	     * dangerous to redirect without confirmation, and thus
	     * cancel when not interactive.  - FM
	     */
	    return 0;
	}
    }

    if (user_mode == NOVICE_MODE) {
	on_screen = 2;
	LYmove(LYlines - 2, 0);
	HTSprintf0(&StatusInfo, SERVER_ASKED_FOR_REDIRECTION, server_status);
	LYaddstr(StatusInfo);
	LYclrtoeol();
	LYmove(LYlines - 1, 0);
	HTSprintf0(&url, "URL: %.*s",
		   (LYcols < 250 ? LYcolLimit - 5 : 250), Redirecting_url);
	LYaddstr(url);
	LYclrtoeol();
	if (server_status == 301) {
	    _statusline(PROCEED_GET_CANCEL);
	} else {
	    _statusline(PROCEED_OR_CANCEL);
	}
    } else {
	HTSprintf0(&StatusInfo, "%d %.*s",
		   server_status,
		   251,
		   ((server_status == 301) ?
		    ADVANCED_POST_GET_REDIRECT :
		    ADVANCED_POST_REDIRECT));
	StrAllocCopy(show_POST_url, LOCATION_HEADER);
	StrAllocCat(show_POST_url, Redirecting_url);
    }
    while (result < 0) {
	int c;

	switch (on_screen) {
	case 0:
	    _statusline(StatusInfo);
	    break;
	case 1:
	    _statusline(show_POST_url);
	}
	c = LYgetch_single();
	switch (c) {
	case 'P':
	    /*
	     * Proceed with 301 or 307 redirect of POST
	     * with same method and POST content.  - FM
	     */
	    FREE(show_POST_url);
	    result = 1;
	    break;

	case 7:
	case 'C':
	    /*
	     * Cancel request.
	     */
	    FREE(show_POST_url);
	    result = 0;
	    break;

	case 'U':
	    /*
	     * Show URL for intermediate or advanced mode.
	     */
	    if (user_mode != NOVICE_MODE) {
		if (on_screen == 1) {
		    on_screen = 0;
		} else {
		    on_screen = 1;
		}
	    }
	    break;

	case 'G':
	    if (server_status == 301) {
		/*
		 * Treat as 303 (GET without content).
		 */
		FREE(show_POST_url);
		result = 303;
		break;
	    }
	    /* fall through to default */

	default:
	    /*
	     * Get another character.
	     */
	    if (on_screen == 1) {
		on_screen = 0;
	    } else {
		on_screen = 2;
	    }
	}
    }
    FREE(StatusInfo);
    FREE(url);
    return (result);
}

#define okToSleep() (!crawl && !traversal && LYCursesON && !no_pause)

/*
 * Sleep for the given message class's time.
 */
void LYSleepAlert(void)
{
    if (okToSleep())
	LYSleep(AlertSecs);
}

void LYSleepDelay(void)
{
    if (okToSleep())
	LYSleep(DelaySecs);
}

void LYSleepInfo(void)
{
    if (okToSleep())
	LYSleep(InfoSecs);
}

void LYSleepMsg(void)
{
    if (okToSleep())
	LYSleep(MessageSecs);
}

#ifdef USE_CMD_LOGGING
void LYSleepReplay(void)
{
    if (okToSleep())
	LYSleep(ReplaySecs);
}
#endif /* USE_CMD_LOGGING */

/*
 * LYstrerror emulates the ANSI strerror() function.
 */
#ifndef LYStrerror
char *LYStrerror(int code)
{
    static char temp[80];

    sprintf(temp, "System errno is %d.\r\n", code);
    return temp;
}
#endif /* HAVE_STRERROR */
@


1.8
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.7
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTAlert.c,v 1.85 2009/04/07 00:09:34 tom Exp $
d43 1
a43 1
#define LYSleep(n) sleep(n)
d155 1
a155 1
    LYSleepDebug();
d170 1
d180 1
a180 1
    if (LYTransferRate == rateKB || LYTransferRate == rateEtaKB_maybe) {
d182 1
a182 1
	    sprintf(s, "%" PRI_off_t, CAST_off_t(n / kb_units));
d184 1
a184 1
	    sprintf(s, "%.2g", ((double) n) / kb_units);
d186 2
a187 1
	    sprintf(s, "%" PRI_off_t, CAST_off_t(n));
d191 1
a191 1
	sprintf(s, "%" PRI_off_t, CAST_off_t(n));
d200 1
a200 1
#define TIME_HMS_LENGTH (16)
d203 31
a233 7
    if (t > 3600)
	sprintf(s, "%ldh%ldm%lds", t / 3600, (t / 60) % 60, t % 60);
    else if (t > 60)
	sprintf(s, "%ldm%lds", t / 60, t % 60);
    else
	sprintf(s, "%ld sec", t);
    return s;
d255 1
a255 1
    now = tv.tv_sec + tv.tv_usec / 1000000.;
d283 4
a286 2
	if (transfer_rate <= 0)	/* the very first time */
	    transfer_rate = (off_t) ((bytes) / (now - first));	/* bytes/sec */
d312 1
a312 1
		transfer_rate = (off_t) (bytes / (now - first));	/* more accurate value */
d331 2
a332 2
		    float percent = bytes / (float) total;
		    int meter = (LYcolLimit * percent) - 5;
d335 3
a337 1
			    "%" PRI_off_t "\n", bytes, total));
d367 3
a369 1
		|| LYTransferRate == rateEtaKB) {
d653 1
a653 4
    char Tmp[200];

    Tmp[0] = '\0';
    Tmp[sizeof(Tmp) - 1] = '\0';
d656 1
a656 2
    if (deflt)
	strncpy(Tmp, deflt, sizeof(Tmp) - 1);
d659 1
a659 1
	LYgetstr(Tmp, VISIBLE, sizeof(Tmp), NORECALL);
d661 1
a661 1
    StrAllocCopy(rep, Tmp);
d663 1
d674 1
a674 3
    char pw[120];

    pw[0] = '\0';
d678 4
a681 2
	LYgetstr(pw, HIDDEN, sizeof(pw), NORECALL);	/* hidden */
	StrAllocCopy(result, pw);
d715 1
a715 1
				 BOOL IsProxy)
d941 1
a941 1
		char *s = "YNAV\007\003";	/* see ADVANCED_COOKIE_CONFIRMATION */
d943 1
a943 1
		if (strchr(s, ch) == 0
d1166 1
a1166 1
void LYSleepDebug(void)
d1169 1
a1169 1
	LYSleep(DebugSecs);
d1184 1
a1184 1
#ifdef EXP_CMD_LOGGING
d1190 1
a1190 1
#endif /* EXP_CMD_LOGGING */
@


1.6
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*	Displaying messages and getting input for Lynx Browser
d104 12
d126 1
a126 1
	if (HTCJK != NOCJK) {
d174 1
a174 1
static const char *sprint_bytes(char *s, long n, const char *was_units)
d176 1
a176 1
    static long kb_units = 1024;
d181 1
a181 1
	    sprintf(s, "%ld", n / kb_units);
d185 1
a185 1
	    sprintf(s, "%ld", n);
d189 1
a189 1
	sprintf(s, "%ld", n);
d214 1
a214 1
void HTReadProgress(long bytes, long total)
d216 2
a217 2
    static long bytes_last, total_last;
    static long transfer_rate = 0;
d253 2
d256 1
a256 2
	(now != first))
	/* 1 sec delay for transfer_rate calculation without g-t-o-d */  {
d258 1
a258 1
	    transfer_rate = (long) ((bytes) / (now - first));	/* bytes/sec */
d279 1
a279 1
	    if (now != last) {
d284 1
a284 1
		transfer_rate = (long) (bytes / (now - first));		/* more accurate value */
d293 7
a299 3
	    if (total > 0)
		HTSprintf0(&line, gettext("Read %s of %s of data"), bytesp, totalp);
	    else
d302 31
a332 4
	    if (LYTransferRate != rateOFF
		&& transfer_rate > 0) {
		sprint_bytes(transferp, transfer_rate, 0);
		HTSprintf(&line, gettext(", %s/sec"), transferp);
d334 1
d351 16
a366 1
	    StrAllocCat(line, ".");
d374 1
a374 1
	}
d554 1
a554 1
    size_t maxlen = LYcolLimit - 5;
d867 1
a867 1
		      -strlen(server));
d870 2
a871 2
	namelen = strlen(name);
	valuelen = strlen(value);
d1126 1
a1126 1
#define okToSleep() (!crawl && !traversal && LYCursesON)
@


1.5
log
@sync with lynx 2.8.5.rel2 which fixes a few minor bugs (null pointer checks,
progress bar with very slow connections)
@
text
@d2 9
a10 9
**	==========================================================
**
**	REPLACE THIS MODULE with a GUI version in a GUI environment!
**
** History:
**	   Jun 92 Created May 1992 By C.T. Barker
**	   Feb 93 Simplified, portablised TBL
**
*/
d21 1
a21 1
#include <LYHistory.h> /* store statusline messages */
d27 1
a27 1
#undef timezone	/* U/Win defines this in time.h, hides implementation detail */
d44 3
a46 4
**	--------------------------------
*/
PUBLIC void HTAlert ARGS1(
	CONST char *,	Msg)
d53 7
d63 2
a64 3
PUBLIC void HTAlwaysAlert ARGS2(
	CONST char *,	extra_prefix,
	CONST char *,	Msg)
d89 3
a91 4
**	--------------------------------
*/
PUBLIC void HTInfoMsg ARGS1(
	CONST char *,	Msg)
d94 1
a94 1
    if (Msg && *Msg) {
d102 3
a104 4
**	--------------------------------
*/
PUBLIC void HTUserMsg ARGS1(
	CONST char *,	Msg)
d107 1
a107 1
    if (Msg && *Msg) {
d120 1
a120 3
PUBLIC void HTUserMsg2 ARGS2(
	CONST char *,	Msg2,
	CONST char *,	Arg)
d123 1
a123 1
    if (Msg2 && *Msg2) {
d133 3
a135 4
**	-------------------------
*/
PUBLIC void HTProgress ARGS1(
	CONST char *,	Msg)
d143 1
a143 2
PUBLIC CONST char *HTProgressUnits ARGS1(
	int,		rate)
d145 2
a146 2
    static CONST char *bunits = 0;
    static CONST char *kbunits = 0;
d154 1
a154 1
    	    || (rate == rateEtaKB)
d156 1
a156 1
	    ) ? kbunits : bunits;
d159 1
a159 4
PRIVATE CONST char *sprint_bytes ARGS3(
	char *,		s,
	long,		n,
	CONST char *, 	was_units)
d162 1
a162 1
    CONST char *u = HTProgressUnits(LYTransferRate);
d166 1
a166 1
	    sprintf(s, "%ld", n/kb_units);
d168 1
a168 1
	    sprintf(s, "%.2g", ((double)n)/kb_units);
d184 1
a184 3
PRIVATE char *sprint_tbuf ARGS2(
	char *,	       s,
	long,	       t)
d187 1
a187 1
	sprintf (s, "%ldh%ldm%lds", t / 3600, (t / 60) % 60, t % 60);
d189 1
a189 1
	sprintf (s, "%ldm%lds", t / 60, t % 60);
d191 1
a191 1
	sprintf (s, "%ld sec", t);
d197 3
a199 5
**	------------------------------
*/
PUBLIC void HTReadProgress ARGS2(
	long,		bytes,
	long,		total)
d206 1
a206 1
    CONST char *was_units;
d212 3
a214 2
    gettimeofday(&tv, (struct timezone *)0);
    now = tv.tv_sec + tv.tv_usec/1000000. ;
d221 1
a221 1
    now = tb.time + (double)tb.millitm / 1000;
d223 1
a223 1
    time_t now = time((time_t *)0);  /* once per second */
d239 4
a242 4
	       (now != first))
		/* 1 sec delay for transfer_rate calculation without g-t-o-d */ {
	if (transfer_rate <= 0)    /* the very first time */
	    transfer_rate = (long)((bytes) / (now - first));   /* bytes/sec */
d268 1
a268 1
		transfer_rate = (long)(bytes / (now - first)); /* more accurate value */
d278 1
a278 1
		HTSprintf0 (&line, gettext("Read %s of %s of data"), bytesp, totalp);
d280 1
a280 1
		HTSprintf0 (&line, gettext("Read %s of data"), bytesp);
d283 1
a283 1
	     && transfer_rate > 0) {
d285 1
a285 1
		HTSprintf (&line, gettext(", %s/sec"), transferp);
a286 1

d289 1
a289 1
	     || LYTransferRate == rateEtaKB) {
d291 1
d293 3
a295 3
		    HTSprintf (&line,
			       gettext(" (stalled for %s)"),
			       sprint_tbuf (tbuf, (long)(now - last_active)));
d297 3
a299 3
		    HTSprintf (&line,
			       gettext(", ETA %s"),
			       sprint_tbuf (tbuf, (long)((total - bytes)/transfer_rate)));
d303 1
a303 1
	    StrAllocCat (line, ".");
d311 1
a311 1
    }
d317 1
a317 1
PRIVATE BOOL conf_cancelled = NO; /* used by HTConfirm only - kw */
d319 1
a319 1
PUBLIC BOOL HTLastConfirmCancelled NOARGS
d323 1
a323 1
	return(YES);
d325 1
a325 1
	return(NO);
d333 1
a333 4
PUBLIC int HTForcedPrompt ARGS3(
	int,		option,
	CONST char *,	msg,
	int,		dft)
d336 1
a336 1
    char *show = NULL;
d361 3
a363 3
**	--------------------------------------
*/
PUBLIC int HTConfirmDefault ARGS2(CONST char *, Msg, int, Dft)
d370 20
a389 20
/*  NOTE TO TRANSLATORS:  If you provide a translation for "yes", lynx
 *  will take the first byte of the translation as a positive response
 *  to Yes/No questions.  If you provide a translation for "no", lynx
 *  will take the first byte of the translation as a negative response
 *  to Yes/No questions.  For both, lynx will also try to show the
 *  first byte in the prompt as a character, instead of (y) or (n),
 *  respectively.  This will not work right for multibyte charsets!
 *  Don't translate "yes" and "no" for CJK character sets (or translate
 *  them to "yes" and "no").  For a translation using UTF-8, don't
 *  translate if the translation would begin with anything but a 7-bit
 *  (US_ASCII) character.  That also means do not translate if the
 *  translation would begin with anything but a 7-bit character, if
 *  you use a single-byte character encoding (a charset like ISO-8859-n)
 *  but anticipate that the message catalog may be used re-encoded in
 *  UTF-8 form.
 *  For translations using other character sets, you may also wish to
 *  leave "yes" and "no" untranslated, if using (y) and (n) is the
 *  preferred behavior.
 *  Lynx will also accept y Y n N as responses unless there is a conflict
 *  with the first letter of the "yes" or "no" translation.
d391 2
a392 2
    char *msg_yes = gettext("yes");
    char *msg_no  = gettext("no");
d402 1
a402 1
    if (dump_output_immediately) { /* Non-interactive, can't respond */
d432 1
d447 1
a447 1
	    } else if (LYCharIsINTERRUPT(c)) { /* remember we had ^G or ^C */
d456 2
a457 2
	       (result != NO) ? "YES" : "NO",
	       conf_cancelled ? ", cancelled" : ""));
d463 3
a465 3
**	------------------
*/
PUBLIC BOOL HTConfirm ARGS1(CONST char *, Msg)
d471 8
a478 8
 *  Ask a post resubmission prompt with some indication of what would
 *  be resubmitted, useful especially for going backward in history.
 *  Try to use parts of the address or, if given, the title, depending
 *  on how much fits on the statusline.
 *  if_imgmap and if_file indicate how to handle an address that is
 *  a "LYNXIMGMAP:", or a "file:" URL (presumably the List Page file),
 *  respectively: 0: auto-deny, 1: auto-confirm, 2: prompt.
 *  - kw
d481 4
a484 5
PUBLIC BOOL confirm_post_resub ARGS4(
    CONST char*,	address,
    CONST char*,	title,
    int,		if_imgmap,
    int,		if_file)
d487 1
a487 1
    CONST char *msg = CONFIRM_POST_RESUBMISSION_TO;
d491 2
a492 1
    size_t maxlen = LYcols - 6;
d494 1
a494 1
	return(NO);
d497 1
a497 1
	    return(NO);
d499 1
a499 1
	    return(YES);
d504 1
a504 1
	    return(NO);
d506 1
a506 1
	    return(YES);
d510 1
a510 1
	return(NO);
d520 2
a521 2
				     PARSE_ACCESS+PARSE_HOST+PARSE_PATH
				     +PARSE_PUNCTUATION)) <= maxlen) {
d525 1
a525 1
	return(res);
d533 2
a534 2
				     PARSE_ACCESS+PARSE_HOST
				     +PARSE_PUNCTUATION)) <= maxlen) {
d538 1
a538 1
	return(res);
d546 1
a546 1
	return(res);
d553 3
a555 5
**	------------------------------------
*/
PUBLIC char * HTPrompt ARGS2(
	CONST char *,	Msg,
	CONST char *,	deflt)
d557 1
a557 1
    char * rep = NULL;
d561 1
a561 1
    Tmp[sizeof(Tmp)-1] = '\0';
d565 1
a565 1
	strncpy(Tmp, deflt, sizeof(Tmp)-1);
d576 4
a579 5
**	Prompt for password without echoing the reply.	HTPromptPassword()
**	----------------------------------------------
*/
PUBLIC char * HTPromptPassword ARGS1(
	CONST char *,	Msg)
d588 1
a588 1
	LYgetstr(pw, HIDDEN, sizeof(pw), NORECALL); /* hidden */
d598 26
a623 27
**	----------------------------------
**
**  On entry,
**	Msg		is the prompting message.
**	*username and
**	*password	are char pointers which contain default
**			or zero-length strings; they are changed
**			to point to result strings.
**	IsProxy 	should be TRUE if this is for
**			proxy authentication.
**
**			If *username is not NULL, it is taken
**			to point to a default value.
**			Initial value of *password is
**			completely discarded.
**
**  On exit,
**	*username and *password point to newly allocated
**	strings -- original strings pointed to by them
**	are NOT freed.
**
*/
PUBLIC void HTPromptUsernameAndPassword ARGS4(
	CONST char *,	Msg,
	char **,	username,
	char **,	password,
	BOOL,		IsProxy)
d630 4
a633 4
	**  The -auth or -pauth parameter gave us both the username
	**  and password to use for the first realm or proxy server,
	**  respectively, so just use them without any prompting. - FM
	*/
d635 1
a635 1
		       proxyauth_info[0] : authentication_info[0]));
d642 1
a642 1
		       proxyauth_info[1] : authentication_info[1]));
d650 3
a652 3
	 *  We are not interactive and don't have both the
	 *  username and password from the command line,
	 *  but might have one or the other. - FM
d657 2
a658 2
	    **	Use the command line username. - FM
	    */
d660 1
a660 1
			   proxyauth_info[0] : authentication_info[0]));
d668 2
a669 2
	    **	Default to "WWWuser". - FM
	    */
d675 2
a676 2
	    **	Use the command line password. - FM
	    */
d678 1
a678 1
			   proxyauth_info[1] : authentication_info[1]));
d686 2
a687 2
	    **	Default to a zero-length string. - FM
	    */
d694 3
a696 3
	 *  We are interactive and don't have both the
	 *  username and password from the command line,
	 *  but might have one or the other. - FM
d701 3
a703 3
	    **	Offer the command line username in the
	    **	prompt for the first realm. - FM
	    */
d705 1
a705 1
			   proxyauth_info[0] : authentication_info[0]));
d713 1
a713 1
	 *  Prompt for confirmation or entry of the username. - FM
d723 2
a724 2
	    **	Use the command line password for the first realm. - FM
	    */
d726 1
a726 1
			   proxyauth_info[1] : authentication_info[1]));
d732 1
a732 1
	} else if (*username != NULL && *username[0] != '\0') {
d734 3
a736 3
	    **	We have a non-zero length username,
	    **	so prompt for the password. - FM
	    */
d740 2
a741 2
	    **	Return a zero-length password. - FM
	    */
d748 16
a763 18
**	---------------------------
**
**  On entry,
**	server			is the server sending the Set-Cookie.
**	domain			is the domain of the cookie.
**	path			is the path of the cookie.
**	name			is the name of the cookie.
**	value			is the value of the cookie.
**
**  On exit,
**	Returns FALSE on cancel,
**		TRUE if the cookie should be set.
*/
PUBLIC BOOL HTConfirmCookie ARGS4(
	domain_entry *, de,
	CONST char *,	server,
	CONST char *,	name,
	CONST char *,	value)
d766 1
a766 1
    char *prompt = ADVANCED_COOKIE_CONFIRMATION;
d771 5
a775 5
    /*	If the user has specified a list of domains to allow or deny
    **	from the config file, then they'll already have de->bv set to
    **	ACCEPT_ALWAYS or REJECT_ALWAYS so we can relax and let the
    **	default cookie handling code cope with this fine.
    */
d778 2
a779 2
    **	If the user has specified a constant action, don't prompt at all.
    */
d787 4
a790 4
	**  Non-interactive, can't respond.  Use the LYSetCookies value
	*   based on its compilation or configuration setting, or on the
	**  command line toggle. - FM
	*/
d795 3
a797 3
    **	Estimate how much of the cookie we can show.
    */
    if(!LYAcceptAllCookies) {
d801 4
a804 4
	space_free = ((LYcols - 1)
		      - (strlen(prompt)
			 - 10)		/* %s and %.*s and %.*s chars */
		      - strlen(server));
d811 4
a814 4
	    **  Argh... there isn't enough space on our single line for
	    **  the whole cookie.  Reduce them both by a percentage.
	    **  This should be smarter.
	    */
d824 1
a824 1
	if(LYAcceptAllCookies) {
d828 1
a828 17
#if defined(LOCALE) && defined(HAVE_GETTEXT) && !defined(gettext)
	    /*
	     * Special-purpose workaround for gettext support (we should do
	     * this in a more general way -- after 2.8.3).
	     *
	     * NOTE TO TRANSLATORS:  If the prompt has been rendered into
	     * another language, and if yes/no are distinct, assume the
	     * translator can make an ordered list in parentheses with one
	     * capital letter for each as we assumed in HTConfirmDefault().
	     * The list has to be in the same order as in the original message,
	     * and the four capital letters chosen to not match those in the
	     * original unless they have the same position.
	     *
	     * Example:
	     *	(Y/N/Always/neVer)		- English (original)
	     *	(O/N/Toujours/Jamais)		- French
	     */
d832 18
a849 2
		char *p;
		char *s = "YNAV\007\003"; /* see ADVANCED_COOKIE_CONFIRMATION */
d852 2
a853 2
		 && isalpha(ch)
		 && (p = strrchr(prompt, L_PAREN)) != 0) {
d877 16
a892 8
	switch(ch) {
	    case 'A':
		/*
		**  Set to accept all cookies for this domain.
		*/
		de->bv = ACCEPT_ALWAYS;
		HTUserMsg2(ALWAYS_ALLOWING_COOKIES, de->domain);
		return TRUE;
d894 7
a900 7
	    case 'N':
		/*
		**  Reject the cookie.
		*/
	      reject:
		HTUserMsg(REJECTING_COOKIE);
		return FALSE;
d902 6
a907 7
	    case 'V':
		/*
		**  Set to reject all cookies from this domain.
		*/
		de->bv = REJECT_ALWAYS;
		HTUserMsg2(NEVER_ALLOWING_COOKIES, de->domain);
		return FALSE;
d909 4
a912 11
	    case 'Y':
		/*
		**  Accept the cookie.
		*/
		HTInfoMsg(ALLOWING_COOKIE);
		return TRUE;

	    default:
		if (LYCharIsINTERRUPT(ch))
		    goto reject;
		continue;
d918 12
a929 14
**	----------------------------
**
**  On entry,
**	Redirecting_url 	    is the Location.
**	server_status		    is the server status code.
**
**  On exit,
**	Returns 0 on cancel,
**	  1 for redirect of POST with content,
**	303 for redirect as GET without content
*/
PUBLIC int HTConfirmPostRedirect ARGS2(
	CONST char *,	Redirecting_url,
	int,		server_status)
d935 4
a938 3
    int on_screen = 0;	/* 0 - show menu
			 * 1 - show url
			 * 2 - menu is already on screen */
d943 3
a945 3
	 *  HTTP.c should not have called us for either of
	 *  these because we're treating 302 as historical,
	 *  so just return 303. - FM
d953 3
a955 3
	    **	Treat 301 as historical, i.e., like 303 (GET
	    **	without content), when not interactive. - FM
	    */
d959 4
a962 4
	    **	Treat anything else (e.g., 305, 306 or 307) as too
	    **	dangerous to redirect without confirmation, and thus
	    **	cancel when not interactive. - FM
	    */
d969 1
a969 1
	LYmove(LYlines-2, 0);
d973 1
a973 1
	LYmove(LYlines-1, 0);
d975 1
a975 1
		    (LYcols < 250 ? LYcols-6 : 250), Redirecting_url);
d985 5
a989 5
			    server_status,
			    251,
			    ((server_status == 301) ?
			 ADVANCED_POST_GET_REDIRECT :
			 ADVANCED_POST_REDIRECT));
d997 5
a1001 5
	    case 0:
		_statusline(StatusInfo);
		break;
	    case 1:
		_statusline(show_POST_url);
d1005 8
a1012 8
	    case 'P':
		/*
		**  Proceed with 301 or 307 redirect of POST
		**  with same method and POST content. - FM
		*/
		FREE(show_POST_url);
		result = 1;
		break;
d1014 8
a1021 8
	    case 7:
	    case 'C':
		/*
		**  Cancel request.
		*/
		FREE(show_POST_url);
		result = 0;
		break;
d1023 5
a1027 28
	    case 'U':
		/*
		**  Show URL for intermediate or advanced mode.
		*/
		if (user_mode != NOVICE_MODE) {
		    if (on_screen == 1) {
			on_screen = 0;
		    } else {
			on_screen = 1;
		    }
		}
		break;

	    case 'G':
		if (server_status == 301) {
		    /*
		    **	Treat as 303 (GET without content).
		    */
		    FREE(show_POST_url);
		    result = 303;
		    break;
		}
		/* fall through to default */

	    default:
		/*
		**  Get another character.
		*/
d1031 1
a1031 1
		    on_screen = 2;
d1033 23
d1068 1
a1068 1
PUBLIC void LYSleepAlert NOARGS
d1074 1
a1074 1
PUBLIC void LYSleepDebug NOARGS
d1080 1
a1080 1
PUBLIC void LYSleepInfo NOARGS
d1086 1
a1086 1
PUBLIC void LYSleepMsg NOARGS
d1093 1
a1093 1
PUBLIC void LYSleepReplay NOARGS
d1101 1
a1101 1
 *  LYstrerror emulates the ANSI strerror() function.
d1103 2
a1104 4
#ifdef LYStrerror
    /* defined as macro in .h file. */
#else
PUBLIC char *LYStrerror ARGS1(int, code)
d1107 1
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d168 10
a177 7
    if ( (LYTransferRate == rateKB || LYTransferRate == rateEtaKB_maybe)
	 && (n >= 10 * kb_units) )
	sprintf(s, "%ld", n/kb_units);
    else if ((LYTransferRate == rateKB || LYTransferRate == rateEtaKB_maybe)
	     && (n > 999))	/* Avoid switching between 1016b/s and 1K/s */
	sprintf(s, "%.2g", ((double)n)/kb_units);
    else {
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d72 1
a72 3
	    fprintf(((TRACE) ? stdout : stderr),
		    ALERT_FORMAT,
		    (Msg == 0) ? "" : Msg);
d93 1
a93 1
	LYSleep(InfoSecs);
d107 6
d140 12
a151 4
#if defined(SH_EX) && defined(WIN_EX)	/* 1997/10/11 (Sat) 12:51:02 */
    {
	if (debug_delay != 0)
	    Sleep(debug_delay);	/* XXX msec */
d153 3
d157 1
d160 1
a160 1
PRIVATE char *sprint_bytes ARGS3(
d163 1
a163 1
	char *, 	was_units)
d166 1
a166 3
    static char *bunits;
    static char *kbunits;
    char *u;
a167 6
    if (!bunits) {
	bunits = gettext("bytes");
	kbunits = gettext("KB");
    }

    u = kbunits;
a175 1
	u = bunits;
d183 16
d211 1
a211 1
    char *was_units;
d250 1
a250 3
	 * Optimal refresh time:  every 0.2 sec, use interpolation.  Transfer
	 * rate is not constant when we have partial content in a proxy, so
	 * interpolation lies - will check every second at least for sure.
d252 1
a252 1
#ifdef HAVE_GETTIMEOFDAY
d256 6
a261 1
	if (((bytes - bytes_last) > (transfer_rate / 5)) || (now != last)) {
d272 1
a272 1
		transfer_rate = (long)(bytes / (now - first)); /* more accurate here */
d292 1
a292 1
#ifdef EXP_READPROGRESS
d295 1
d297 3
a299 1
		    HTSprintf (&line, gettext(" (stalled for %ld sec)"), (long)(now - last_active));
d301 3
a303 1
		    HTSprintf (&line, gettext(", ETA %ld sec"), (long)((total - bytes)/transfer_rate));
d333 32
d501 1
a501 1
    } else if (!strncmp(address, "LYNXIMGMAP:", 11)) {
d508 1
a508 1
    } else if (!strncmp(address, "file:", 5)) {
d835 1
a835 1
    while (1) {
d867 1
d869 7
a875 7
			if (*p == ch) {
			    ch = *s;
			    break;
			} else {
			    if (isalpha(UCH(*p)) && (*p == TOUPPER(*p)))
				s++;
			    p++;
d877 1
d1087 6
d1104 8
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d25 18
d49 1
a49 1
    CTRACE(tfp, "\nAlert!: %s\n\n", Msg);
d54 1
a54 1
    sleep(AlertSecs);
d69 2
a70 1
	    sleep(AlertSecs);
d76 2
a77 1
	    sleep(AlertSecs);
d80 1
a80 1
	CTRACE(tfp, "\nAlert!: %s\n\n", Msg);
d93 1
a93 1
	CTRACE(tfp, "Info message: %s\n", Msg);
d95 1
a95 1
	sleep(InfoSecs);
d107 1
a107 1
	CTRACE(tfp, "User message: %s\n", Msg);
d109 1
a109 1
	sleep(MessageSecs);
d119 3
a121 3
	CTRACE(tfp, "User message: ");
	CTRACE(tfp, Msg2, Arg);
	CTRACE(tfp, "\n");
d123 1
a123 1
	sleep(MessageSecs);
d135 39
a173 1
    CTRACE(tfp, "%s\n", Msg);
d183 1
a183 3
    static long kb_units = 1024;
    static time_t first, last;
    static long bytes_last;
d185 19
a203 2
    long divisor;
    char line[80];
d205 6
a210 1
    static char *units = "bytes";
d213 1
a213 1
	first = last = now;
d215 5
a219 1
    } else if ((bytes > 0) &&
d221 1
a221 1
		/* 1 sec delay for transfer_rate calculation :-( */ {
d223 2
a224 1
	    transfer_rate = (bytes) / (now - first);   /* bytes/sec */
d231 4
d236 1
a236 1

d238 3
a240 1

d243 2
d246 1
a246 1
		transfer_rate = (bytes_last) / (last - first); /* more accurate here */
d249 5
a253 9
	    units = gettext("bytes");
	    divisor = 1;
	    if (LYshow_kb_rate
	      && (total >= kb_units || bytes >= kb_units)) {
		units = gettext("KB");
		divisor = kb_units;
		bytes /= divisor;
		if (total > 0) total /= divisor;
	    }
d255 2
a256 2
	    if (total >  0)
		sprintf (line, gettext("Read %ld of %ld %s of data"), bytes, total, units);
d258 6
a263 9
		sprintf (line, gettext("Read %ld %s of data"), bytes, units);
	    if ((transfer_rate > 0)
		  && (!LYshow_kb_rate || (bytes * divisor >= kb_units)))
		sprintf (line + strlen(line), gettext(", %ld %s/sec."), transfer_rate / divisor, units);
	    else
		sprintf (line + strlen(line), ".");
	    if (total <  0) {
		if (total < -1)
		    strcat(line, gettext(" (Press 'z' to abort)"));
d266 14
d282 1
a282 1
	    CTRACE(tfp, "%s\n", line);
d285 3
d304 2
a305 2
/*	Seek confirmation.				HTConfirm()
**	------------------
d307 1
a307 1
PUBLIC BOOL HTConfirmDefault ARGS2(CONST char *, Msg, int, Dft)
d309 26
d339 6
d347 6
d356 7
d368 3
d375 1
a375 1
	    int c = LYgetch();
d379 1
a379 1
		c = *msg_no;
d382 9
a390 1
	    if (c == 7 || c == 3) { /* remember we had ^G or ^C */
a392 4
	    } else if (TOUPPER(c) == TOUPPER(*msg_yes)) {
		result = YES;
	    } else if (TOUPPER(c) == TOUPPER(*msg_no)) {
		return(NO);
d394 2
a395 1
		return(Dft);
d398 3
d405 3
d410 83
a492 1
    return HTConfirmDefault(Msg, DFT_CONFIRM);
d709 1
a709 1
	void *, 	dp,
d714 2
a715 2
    domain_entry *de;
    int ch, namelen, valuelen, space_free;
d717 1
a717 1
    if ((de = (domain_entry *)dp) == NULL)
a719 1
#ifdef ENHANCED_COOKIES
d723 1
a723 1
    **	default cookie handling code cope with this fine.  I hope.
d725 1
a725 1
#endif
d729 1
a729 1
    if (de->bv == ACCEPT_ALWAYS || de->bv == FROM_FILE)
a745 24
    if (de != NULL) {
	if (de->bv == ACCEPT_ALWAYS)
	    return TRUE;
	if (de->bv == REJECT_ALWAYS)
	    return FALSE;
    }
    space_free = (((LYcols - 1)
	       - strlen(ADVANCED_COOKIE_CONFIRMATION))
	       - strlen(server));
    if (space_free < 0)
	space_free = 0;
    namelen = strlen(name);
    valuelen = strlen(value);
    if ((namelen + valuelen) > space_free) {
	/*
	**  Argh... there isn't enough space on our single line for
	**  the whole cookie.  Reduce them both by a percentage.
	**  This should be smarter.
	*/
        int percentage;  /* no float */
        percentage = (100 * space_free) / (namelen + valuelen);
        namelen = (percentage * namelen) / 100;
        valuelen = (percentage * valuelen) / 100;
    }
d747 1
d749 20
a768 2
	HTSprintf(&message, ADVANCED_COOKIE_CONFIRMATION,
		 server, namelen, name, valuelen, value);
d773 2
a774 2
	if(!LYAcceptAllCookies) {
	    ch = LYgetch();
d776 41
a816 1
	    ch = 'A';
d824 1
a824 1
	switch(TOUPPER(ch)) {
a833 2
	    case 7:	/* Ctrl-G */
	    case 3:	/* Ctrl-C */
d837 1
d857 2
d917 1
a917 1
	move(LYlines-2, 0);
d919 3
a921 3
	addstr(StatusInfo);
	clrtoeol();
	move(LYlines-1, 0);
d924 2
a925 2
	addstr(url);
	clrtoeol();
d951 2
a952 2
	c = LYgetch();
	switch (TOUPPER(c)) {
d1010 37
@


1.1
log
@Initial revision
@
text
@d12 10
a21 14
#include "HTUtils.h"
#include "tcp.h"
#include "HTAlert.h"
#include "LYGlobalDefs.h"
#include "LYCurses.h"
#include "LYStrings.h"
#include "LYUtils.h"
#include "LYSignal.h"
#include "GridText.h"
#include "LYCookie.h"

#include "LYLeaks.h"

#define FREE(x) if (x) {free(x); x = NULL;}
d23 1
d31 4
a34 8
    if (TRACE) {
        fprintf(stderr, "\nAlert!: %s", Msg);
	fflush(stderr);
        _user_message("Alert!: %s", Msg);
        fprintf(stderr, "\n\n");
	fflush(stderr);
    } else
        _user_message("Alert!: %s", Msg);
d39 68
d113 74
a186 4
    if (TRACE)
        fprintf(stderr, "%s\n", Msg);
    else
        statusline(Msg);
d201 2
d206 1
a206 1
PUBLIC BOOL HTConfirm ARGS1(CONST char *, Msg)
d208 4
d214 1
a214 1
	return(NO);
d216 11
a226 9
	int c;
#ifdef VMS
	extern BOOLEAN HadVMSInterrupt;
#endif /* VMS */
	
	_user_message("%s (y/n) ", Msg);
	
	while (1) {
	    c = LYgetch();
d230 1
a230 1
		c = 'N';
d233 1
a233 3
	    if (TOUPPER(c) == 'Y')
		return(YES);
	    if (c == 7 || c == 3) /* remember we had ^G or ^C */
d235 4
a238 1
	    if (TOUPPER(c) == 'N' || c == 7 || c == 3) /* ^G or ^C cancels */
d240 3
d245 6
d264 1
a264 1
    Tmp[199] = '\0';
d267 2
a268 2
    if (deflt) 
        strncpy(Tmp, deflt, 199);
d271 1
a271 1
        LYgetstr(Tmp, VISIBLE, sizeof(Tmp), NORECALL);
d291 3
a293 3
        _statusline(Msg ? Msg : PASSWORD_PROMPT);
        LYgetstr(pw, HIDDEN, sizeof(pw), NORECALL); /* hidden */
        StrAllocCopy(result, pw);
d295 1
a295 1
        printf("\n%s\n", PASSWORD_REQUIRED);
d301 2
a302 2
/*     	Prompt both username and password.       HTPromptUsernameAndPassword()
**      ----------------------------------
d305 3
a307 3
**      Msg             is the prompting message.
**      *username and
**      *password       are char pointers which contain default
d309 2
a310 2
**                      to point to result strings.
**	IsProxy		should be TRUE if this is for
d313 4
a316 4
**                      If *username is not NULL, it is taken
**                      to point to a default value.
**                      Initial value of *password is
**                      completely discarded.
d319 3
a321 3
**      *username and *password point to newly allocated
**      strings -- original strings pointed to by them
**      are NOT freed.
d334 1
a334 1
	/* 
d339 1
a339 1
 	StrAllocCopy(*username, (IsProxy ?
d354 1
a354 1
        /*
d359 1
a359 1
        if ((IsProxy == FALSE && authentication_info[0]) ||
d362 1
a362 1
	    **  Use the command line username. - FM
d373 1
a373 1
	    **  Default to "WWWuser". - FM
d375 1
a375 1
            StrAllocCopy(*username, "WWWuser");
d377 1
a377 1
        if ((IsProxy == FALSE && authentication_info[1]) ||
d380 1
a380 1
	    **  Use the command line password. - FM
d391 1
a391 1
	    **  Default to a zero-length string. - FM
d398 1
a398 1
        /*
d403 1
a403 1
        if ((IsProxy == FALSE && authentication_info[0]) ||
d406 2
a407 2
	    **  Offer the command line username in the
	    **  prompt for the first realm. - FM
d425 1
a425 1
        if ((IsProxy == FALSE && authentication_info[1]) ||
d428 1
a428 1
	    **  Use the command line password for the first realm. - FM
d439 2
a440 2
	    **  We have a non-zero length username,
	    **  so prompt for the password. - FM
d445 1
a445 1
	    **  Return a zero-length password. - FM
d466 2
a467 2
PUBLIC BOOL HTConfirmCookie ARGS6(
	void *,		dp,
a468 2
	CONST char *,	domain,
	CONST char *,	path,
a471 1
    char message[256];
d475 2
a476 3
#ifdef VMS
    extern BOOLEAN HadVMSInterrupt;
#endif /* VMS */
d478 7
a484 3
    if ((de = (domain_entry *)dp) == NULL)
        return FALSE;
  
d486 1
a486 1
    **  If the user has specified a constant action, don't prompt at all.
d488 2
a489 2
    if (de->bv == ACCEPT_ALWAYS)
        return TRUE;
d491 1
a491 1
        return FALSE;
d494 1
a494 1
        /*
d499 1
a499 1
        return LYSetCookies;
d503 1
a503 3
    **  Figure out how much of the cookie we can show.
    **  The '37' is the length of ADVANCED_COOKIE_CONFIRMATION,
    **  minus the length of the %s directives (10 chars)
d506 1
a506 1
        if (de->bv == ACCEPT_ALWAYS) 
d508 1
a508 1
	if (de->bv == REJECT_ALWAYS) 
d511 3
a513 1
    space_free = (((LYcols - 1) - 37) - strlen(server));
d515 1
a515 1
        space_free = 0;
d519 1
a519 1
        /*
d524 12
a535 8
        float percentage;
        percentage = (float)space_free/(float)(namelen + valuelen);
        namelen = (int)(percentage*(float)namelen);
        valuelen = (int)(percentage*(float)valuelen);
    }
    sprintf(message, ADVANCED_COOKIE_CONFIRMATION,
    	    server, namelen, name, valuelen, value);
    _statusline(message);
d537 5
a541 1
	ch = LYgetch();
d550 1
a550 1
	        /*
d554 1
a554 2
		_user_message(ALWAYS_ALLOWING_COOKIES, de->domain);
		sleep(MessageSecs);
d560 1
a560 1
	        /*
d563 1
a563 2
		_statusline(REJECTING_COOKIE);
		sleep(MessageSecs);
d566 2
a567 2
    	    case 'V':
	        /*
d571 1
a571 2
		_user_message(NEVER_ALLOWING_COOKIES, de->domain);
		sleep(MessageSecs);
d575 1
a575 1
	        /*
d578 1
a578 2
		_statusline(ALLOWING_COOKIE);
		sleep(InfoSecs);
d582 1
a582 1
	        continue;
d587 1
a587 1
/*      Confirm redirection of POST.		HTConfirmPostRedirect()
d591 1
a591 1
**      Redirecting_url             is the Location.
d595 1
a595 1
**      Returns 0 on cancel,
d603 1
d605 2
a606 2
    char StatusInfo[256];
    char url[256];
d608 1
a608 1
   			 * 1 - show url
d612 1
a612 1
        server_status == 302) {
d621 2
a622 2
    if (dump_output_immediately)
        if (server_status == 301) {
d624 2
a625 2
	    **  Treat 301 as historical, i.e., like 303 (GET
	    **  without content), when not interactive. - FM
d627 2
a628 2
            return 303;
        } else {
d630 3
a632 3
	    **  Treat anything else (e.g., 305, 306 or 307) as too
	    **  dangerous to redirect without confirmation, and thus
	    **  cancel when not interactive. - FM
d636 1
a637 2
    StatusInfo[254] = StatusInfo[255] = '\0';
    url[254] = url[(LYcols < 250 ? LYcols-1 : 255)] = '\0';
d639 3
a641 3
        on_screen = 2;
        move(LYlines-2, 0);
        sprintf(StatusInfo, SERVER_ASKED_FOR_REDIRECTION, server_status);
d644 2
a645 2
        move(LYlines-1, 0);
	sprintf(url, "URL: %.*s",
d647 1
a647 1
        addstr(url);
d655 1
a655 1
	sprintf(StatusInfo, "%d %.*s",
d664 2
a665 2
    while (1) {
	int c;  
d672 1
a672 1
	        _statusline(show_POST_url);
d681 3
a683 2
	        FREE(show_POST_url);
		return 1;	
d685 3
a687 3
 	    case 7:
 	    case 'C':
	        /*
d690 3
a692 2
	        FREE(show_POST_url);
		return 0;
d695 1
a695 1
	        /*
d698 1
a698 1
	        if (user_mode != NOVICE_MODE) {
d710 1
a710 1
		    **  Treat as 303 (GET without content).
d713 2
a714 1
		    return 303;
d719 1
a719 1
	        /*
d729 3
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
