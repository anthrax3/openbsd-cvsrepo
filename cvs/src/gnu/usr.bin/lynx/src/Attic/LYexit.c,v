head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.50;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.40;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.13;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.53;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.53;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: LYexit.c,v 1.36 2013/10/24 09:16:37 tom Exp $
 *
 *	Copyright (c) 1994, University of Kansas, All Rights Reserved
 *	(most of this file was rewritten in 1996 and 2004).
 */
#include <HTUtils.h>
#include <LYexit.h>
#include <HTAlert.h>
#ifndef VMS
#include <LYGlobalDefs.h>
#include <LYUtils.h>
#include <LYSignal.h>
#include <LYMainLoop.h>
#endif /* !VMS */
#include <LYStrings.h>
#include <LYClean.h>

/*
 * Flag for outofmem macro.  - FM
 */
BOOL LYOutOfMemory = FALSE;

/*
 * Stack of functions to call upon exit.
 */
static void (*callstack[ATEXITSIZE]) (void);
static int topOfStack = 0;

/*
 * Capture "atexit()" calls for our own accounting.
 */
int LYatexit(void (*function) (void))
{
    int result = 0;

    if (topOfStack >= ATEXITSIZE) {
	CTRACE((tfp, "(LY)atexit: Too many functions, ignoring one!\n"));
	result = -1;
    } else {
	int n;
	BOOLEAN found = FALSE;

	for (n = 0; n < topOfStack; ++n) {
	    if (callstack[n] == function) {
		found = TRUE;
		break;
	    }
	}
	if (!found) {
	    callstack[topOfStack++] = function;
	}
    }
    return result;
}

/*
 * Purpose:		Call the functions registered with LYatexit
 * Arguments:		void
 * Return Value:	void
 * Remarks/Portability/Dependencies/Restrictions:
 * Revision History:
 *	06-15-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static void LYCompleteExit(void)
{
    /*
     * Just loop through registered functions.  This is reentrant if more exits
     * occur in the registered functions.
     */
    while (--topOfStack >= 0) {
	callstack[topOfStack] ();
    }
}

/*
 * Purpose:		Terminates program, reports memory not freed.
 * Arguments:		status	Exit code.
 * Return Value:	void
 * Remarks/Portability/Dependencies/Restrictions:
 *	Function calls stdlib.h exit
 * Revision History:
 *	06-15-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
void LYexit(int status)
{
#ifndef VMS			/*  On VMS, the VMSexit() handler does these. - FM */
#ifdef _WINDOWS
    DeleteCriticalSection(&critSec_DNS);
    DeleteCriticalSection(&critSec_READ);

    WSACleanup();
#endif
    if (LYOutOfMemory == TRUE) {
	/*
	 * Ignore further interrupts.  - FM
	 */
#ifndef NOSIGHUP
	(void) signal(SIGHUP, SIG_IGN);
#endif /* NOSIGHUP */
	(void) signal(SIGTERM, SIG_IGN);
	(void) signal(SIGINT, SIG_IGN);
#ifndef __linux__
#ifdef SIGBUS
	(void) signal(SIGBUS, SIG_IGN);
#endif /* SIGBUS */
#endif /* !__linux__ */
	(void) signal(SIGSEGV, SIG_IGN);
	(void) signal(SIGILL, SIG_IGN);

	/*
	 * Flush all messages.  - FM
	 */
	fflush(stderr);
	fflush(stdout);

	/*
	 * Deal with curses, if on, and clean up.  - FM
	 */
	if (LYCursesON) {
	    LYSleepAlert();
	}
	cleanup_sig(0);
#ifndef __linux__
#ifdef SIGBUS
	signal(SIGBUS, SIG_DFL);
#endif /* SIGBUS */
#endif /* !__linux__ */
	signal(SIGSEGV, SIG_DFL);
	signal(SIGILL, SIG_DFL);
    }
#endif /* !VMS */

    /*
     * Close syslog before doing atexit-cleanup, since it may use a string
     * that would be freed there.
     */
#ifdef SYSLOG_REQUESTED_URLS
    LYCloselog();
#endif

    /*
     * Do functions registered with LYatexit.  - GAB
     */
    LYCompleteExit();

    LYCloseCmdLogfile();

#ifdef exit
/*  Make sure we use stdlib exit and not LYexit. - GAB
*/
#undef exit
#endif /* exit */

    cleanup_files();		/* if someone starts with LYNXfoo: page */
#ifndef VMS			/*  On VMS, the VMSexit() handler does these. - FM */
    fflush(stderr);
    if (LYOutOfMemory == TRUE) {
	LYOutOfMemory = FALSE;
	printf("\r\n%s\r\n\r\n", MEMORY_EXHAUSTED_ABORT);
	fflush(stdout);
    }
    LYCloseTracelog();
#endif /* !VMS */
    show_alloc();

#if defined(NCURSES_VERSION) && defined(LY_FIND_LEAKS)
#if defined(HAVE__NC_FREE_AND_EXIT)
    _nc_free_and_exit(status);
#elif defined(HAVE__NC_FREEALL)
    _nc_freeall();
#endif
#endif /* NCURSES_VERSION */

    exit(status);
}

void outofmem(const char *fname,
	      const char *func)
{
    fprintf(stderr, "\n\n\n%s %s: %s\n", fname, func, MEMORY_EXHAUSTED_ABORTING);
    LYOutOfMemory = TRUE;
    LYexit(-1);
}
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: LYexit.c,v 1.35 2009/03/10 00:12:52 tom Exp $
d31 1
a31 7
 * Purpose:		Registers termination function.
 * Arguments:		function	The function to register.
 * Return Value:	int	0	registered
 *				!0	no more space to register
 * Remarks/Portability/Dependencies/Restrictions:
 * Revision History:
 *	06-15-94	created Lynx 2-3-1 Garrett Arch Blythe
a32 1

d35 3
a37 4
    /*
     * Check for available space.
     */
    if (topOfStack == ATEXITSIZE) {
d39 14
a52 1
	return (-1);
d54 1
a54 7

    /*
     * Register the function.
     */
    callstack[topOfStack] = function;
    topOfStack++;
    return (0);
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d2 2
d5 1
a89 3
    extern CRITICAL_SECTION critSec_DNS;	/* 1998/09/03 (Thu) 22:01:56 */
    extern CRITICAL_SECTION critSec_READ;	/* 1998/09/03 (Thu) 22:01:56 */

d105 1
a105 1
#ifndef DOSPATH
d107 1
a107 1
#endif /* DOSPATH */
d126 1
a126 1
#ifndef DOSPATH
d128 1
a128 1
#endif /* DOSPATH */
d167 9
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d17 1
a17 1
 *  Flag for outofmem macro. - FM
d19 1
a19 2
PUBLIC BOOL LYOutOfMemory = FALSE;

d22 1
a22 1
 *  Stack of functions to call upon exit.
d24 2
a25 2
PRIVATE void (*callstack[ATEXITSIZE]) NOPARAMS;
PRIVATE int topOfStack = 0;
d28 3
a30 3
 *  Purpose:		Registers termination function.
 *  Arguments:		function	The function to register.
 *  Return Value:	int	0	registered
d32 2
a33 2
 *  Remarks/Portability/Dependencies/Restrictions:
 *  Revision History:
d37 1
a37 6
#ifdef __STDC__
PUBLIC int LYatexit(void (*function) NOPARAMS)
#else /* Not ANSI, ugh! */
PUBLIC int LYatexit(function)
void (*function) NOPARAMS;
#endif /* __STDC__ */
d40 1
a40 1
     *  Check for available space.
d44 1
a44 1
	return(-1);
d48 1
a48 1
     *  Register the function.
d52 1
a52 1
    return(0);
d56 5
a60 5
 *  Purpose:		Call the functions registered with LYatexit
 *  Arguments:		void
 *  Return Value:	void
 *  Remarks/Portability/Dependencies/Restrictions:
 *  Revision History:
d63 1
a63 1
PRIVATE void LYCompleteExit NOPARAMS
d66 2
a67 2
     *  Just loop through registered functions.
     *  This is reentrant if more exits occur in the registered functions.
d70 1
a70 1
	callstack[topOfStack]();
d75 4
a78 4
 *  Purpose:		Terminates program, reports memory not freed.
 *  Arguments:		status	Exit code.
 *  Return Value:	void
 *  Remarks/Portability/Dependencies/Restrictions:
d80 1
a80 1
 *  Revision History:
d83 1
a83 2
PUBLIC void LYexit ARGS1(
	int,		status)
d85 1
a85 1
#ifndef VMS	/*  On VMS, the VMSexit() handler does these. - FM */
d97 1
a97 1
	 *  Ignore further interrupts. - FM
d102 2
a103 2
	(void) signal (SIGTERM, SIG_IGN);
	(void) signal (SIGINT, SIG_IGN);
d113 1
a113 1
	 *  Flush all messages. - FM
d119 1
a119 1
	 *  Deal with curses, if on, and clean up. - FM
d139 1
a139 1
#if !defined(VMS) && defined(SYSLOG_REQUESTED_URLS)
d141 1
a141 1
#endif /* !VMS && SYSLOG_REQUESTED_URLS */
d144 1
a144 1
     *	Do functions registered with LYatexit. - GAB
d156 2
a157 2
    cleanup_files();	/* if someone starts with LYNXfoo: page */
#ifndef VMS	/*  On VMS, the VMSexit() handler does these. - FM */
d170 2
a171 3
PUBLIC void outofmem ARGS2(
	CONST char *,	fname,
	CONST char *,	func)
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d81 1
a81 1
 *  Purpose:		Terminates program.
d143 2
a144 1
     *	Do functions registered with LYatexit. - GAB
a145 2
    LYCompleteExit();

d150 5
d173 1
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d6 1
a10 1
#include <LYClean.h>
a11 3
#ifdef SYSLOG_REQUESTED_URLS
#include <syslog.h>
#endif /* SYSLOG_REQUESTED_URLS */
d13 2
d39 1
a39 1
PUBLIC int LYatexit(void (*function)(void))
d42 1
a42 1
void (*function)();
d49 1
a49 1
	CTRACE(tfp, "(LY)atexit: Too many functions, ignoring one!\n");
d94 6
d119 5
a123 5
	 /*
	  *  Flush all messages. - FM
	  */
	 fflush(stderr);
	 fflush(stdout);
d129 1
a129 1
	    sleep(AlertSecs);
d147 5
a151 6
#ifndef VMS
#ifdef SYSLOG_REQUESTED_URLS
    syslog(LOG_INFO, "Session over");
    closelog();
#endif /* SYSLOG_REQUESTED_URLS */
#endif /* !VMS */
d159 1
@


1.1
log
@Initial revision
@
text
@d4 2
a5 3
#include "HTUtils.h"
#include "tcp.h"
#include "LYexit.h"
d7 5
a11 4
#include "LYGlobalDefs.h"
#include "LYUtils.h"
#include "LYSignal.h"
#include "LYClean.h"
d17 5
a21 1
#define FREE(x) if (x) {free(x); x = NULL;}
d30 7
a36 1
 *  Flag for outofmem macro. - FM
d38 23
a60 1
PUBLIC BOOL LYOutOfMemory = FALSE;
d63 6
a68 1
 *  Forward declarations.
d70 10
a79 1
PRIVATE void LYCompleteExit NOPARAMS;
d162 1
a162 7
    if (LYTraceLogFP != NULL) {
	fflush(stdout);
	fflush(stderr);
	fclose(LYTraceLogFP);
	LYTraceLogFP = NULL;
	*stderr = LYOrigStderr;
    }
d167 3
a169 42
/*
 *  Purpose:		Registers termination function.
 *  Arguments:		function	The function to register.
 *  Return Value:	int	0	registered
 *				!0	no more space to register
 *  Remarks/Portability/Dependencies/Restrictions:
 *  Revision History:
 *	06-15-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
#ifdef __STDC__
PUBLIC int LYatexit(void (*function)(void))
#else /* Not ANSI, ugh! */
PUBLIC int LYatexit(function)
void (*function)();
#endif /* __STDC__ */
{
    /*
     *  Check for available space.
     */
    if (topOfStack == ATEXITSIZE) {
	if (TRACE)
	    fprintf(stderr, "(LY)atexit: Too many functions, ignoring one!\n");
	return(-1);
    }

    /*
     *  Register the function.
     */
    callstack[topOfStack] = function;
    topOfStack++;
    return(0);
}

/*
 *  Purpose:		Call the functions registered with LYatexit
 *  Arguments:		void
 *  Return Value:	void
 *  Remarks/Portability/Dependencies/Restrictions:
 *  Revision History:
 *	06-15-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
PRIVATE void LYCompleteExit NOPARAMS
d171 3
a173 7
    /*
     *  Just loop through registered functions.
     *  This is reentrant if more exits occur in the registered functions.
     */
    while (--topOfStack >= 0) {
	callstack[topOfStack]();
    }
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
