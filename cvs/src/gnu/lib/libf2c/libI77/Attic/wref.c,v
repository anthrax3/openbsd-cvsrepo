head	1.4;
access;
symbols
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.30
	OPENBSD_5_0:1.3.0.28
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.26
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.24
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.20
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.22
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.18
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.16
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.14
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.12
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.10
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.8
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.6
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.4
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	gcc-3_3_5:1.1.1.2
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2012.04.14.06.01.40;	author jsg;	state dead;
branches;
next	1.3;

1.3
date	2004.12.30.17.35.27;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2004.12.24.22.33.13;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.29.19.27.17;	author drahn;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.02.29.19.27.17;	author drahn;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.24.22.07.31;	author espie;	state Exp;
branches;
next	;


desc
@@


1.4
log
@remove libf2c, hasn't been built since it was moved to ports in 2010.
ok miod@@ espie@@
@
text
@#include "f2c.h"
#include "fio.h"
#ifndef VAX
#include <ctype.h>
#endif

#undef abs
#undef min
#undef max
#include <stdlib.h>
#include <string.h>

#include "fmt.h"
#include "fp.h"

int
wrt_E (ufloat * p, int w, int d, int e, ftnlen len)
{
  char buf[FMAX + EXPMAXDIGS + 4], *s, *se;
  int d1, delta, e1, i, sign, signspace;
  double dd;
#ifdef WANT_LEAD_0
  int insert0 = 0;
#endif
#ifndef VAX
  int e0 = e;
#endif

  if (e <= 0)
    e = 2;
  if (f__scale)
    {
      if (f__scale >= d + 2 || f__scale <= -d)
	goto nogood;
    }
  if (f__scale <= 0)
    --d;
  if (len == sizeof (real))
    dd = p->pf;
  else
    dd = p->pd;
  if (dd < 0.)
    {
      signspace = sign = 1;
      dd = -dd;
    }
  else
    {
      sign = 0;
      signspace = (int) f__cplus;
#ifndef VAX
      if (!dd)
	dd = 0.;		/* avoid -0 */
#endif
    }
  delta = w - (2		/* for the . and the d adjustment above */
	       + 2 /* for the E+ */  + signspace + d + e);
#ifdef WANT_LEAD_0
  if (f__scale <= 0 && delta > 0)
    {
      delta--;
      insert0 = 1;
    }
  else
#endif
  if (delta < 0)
    {
    nogood:
      while (--w >= 0)
	PUT ('*');
      return (0);
    }
  if (f__scale < 0)
    d += f__scale;
  if (d > FMAX)
    {
      d1 = d - FMAX;
      d = FMAX;
    }
  else
    d1 = 0;
  sprintf (buf, "%#.*E", d, dd);
#ifndef VAX
  /* check for NaN, Infinity */
  if (!isdigit ((unsigned char) buf[0]))
    {
      switch (buf[0])
	{
	case 'n':
	case 'N':
	  signspace = 0;	/* no sign for NaNs */
	}
      delta = w - strlen (buf) - signspace;
      if (delta < 0)
	goto nogood;
      while (--delta >= 0)
	PUT (' ');
      if (signspace)
	PUT (sign ? '-' : '+');
      for (s = buf; *s; s++)
	PUT (*s);
      return 0;
    }
#endif
  se = buf + d + 3;
#ifdef GOOD_SPRINTF_EXPONENT	/* When possible, exponent has 2 digits. */
  if (f__scale != 1 && dd)
    sprintf (se, "%+.2d", atoi (se) + 1 - f__scale);
#else
  if (dd)
    sprintf (se, "%+.2d", atoi (se) + 1 - f__scale);
  else
    strcpy (se, "+00");
#endif
  s = ++se;
  if (e < 2)
    {
      if (*s != '0')
	goto nogood;
    }
#ifndef VAX
  /* accommodate 3 significant digits in exponent */
  if (s[2])
    {
#ifdef Pedantic
      if (!e0 && !s[3])
	for (s -= 2, e1 = 2; s[0] = s[1]; s++);

      /* Pedantic gives the behavior that Fortran 77 specifies,       */
      /* i.e., requires that E be specified for exponent fields       */
      /* of more than 3 digits.  With Pedantic undefined, we get      */
      /* the behavior that Cray displays -- you get a bigger          */
      /* exponent field if it fits.   */
#else
      if (!e0)
	{
	  for (s -= 2, e1 = 2; (s[0] = s[1]); s++)
#ifdef CRAY
	    delta--;
	  if ((delta += 4) < 0)
	    goto nogood
#endif
	      ;
	}
#endif
      else if (e0 >= 0)
	goto shift;
      else
	e1 = e;
    }
  else
  shift:
#endif
    for (s += 2, e1 = 2; *s; ++e1, ++s)
      if (e1 >= e)
	goto nogood;
  while (--delta >= 0)
    PUT (' ');
  if (signspace)
    PUT (sign ? '-' : '+');
  s = buf;
  i = f__scale;
  if (f__scale <= 0)
    {
#ifdef WANT_LEAD_0
      if (insert0)
	PUT ('0');
#endif
      PUT ('.');
      for (; i < 0; ++i)
	PUT ('0');
      PUT (*s);
      s += 2;
    }
  else if (f__scale > 1)
    {
      PUT (*s);
      s += 2;
      while (--i > 0)
	PUT (*s++);
      PUT ('.');
    }
  if (d1)
    {
      se -= 2;
      while (s < se)
	PUT (*s++);
      se += 2;
      do
	PUT ('0');
      while (--d1 > 0);
    }
  while (s < se)
    PUT (*s++);
  if (e < 2)
    PUT (s[1]);
  else
    {
      while (++e1 <= e)
	PUT ('0');
      while (*s)
	PUT (*s++);
    }
  return 0;
}

int
wrt_F (ufloat * p, int w, int d, ftnlen len)
{
  int d1, sign, n;
  double x;
  char *b, buf[MAXINTDIGS + MAXFRACDIGS + 4], *s;

  x = (len == sizeof (real) ? p->pf : p->pd);
  if (d < MAXFRACDIGS)
    d1 = 0;
  else
    {
      d1 = d - MAXFRACDIGS;
      d = MAXFRACDIGS;
    }
  if (x < 0.)
    {
      x = -x;
      sign = 1;
    }
  else
    {
      sign = 0;
#ifndef VAX
      if (!x)
	x = 0.;
#endif
    }

  if ((n = f__scale))
    {
      if (n > 0)
	do
	  x *= 10.;
	while (--n > 0);
      else
	do
	  x *= 0.1;
	while (++n < 0);
    }

#ifdef USE_STRLEN
  sprintf (b = buf, "%#.*f", d, x);
  n = strlen (b) + d1;
#else
  n = sprintf (b = buf, "%#.*f", d, x) + d1;
#endif

#ifndef WANT_LEAD_0
  if (buf[0] == '0' && d)
    {
      ++b;
      --n;
    }
#endif
  if (sign)
    {
      /* check for all zeros */
      for (s = b;;)
	{
	  while (*s == '0')
	    s++;
	  switch (*s)
	    {
	    case '.':
	      s++;
	      continue;
	    case 0:
	      sign = 0;
	    }
	  break;
	}
    }
  if (sign || f__cplus)
    ++n;
  if (n > w)
    {
#ifdef WANT_LEAD_0
      if (buf[0] == '0' && --n == w)
	++b;
      else
#endif
	{
	  while (--w >= 0)
	    PUT ('*');
	  return 0;
	}
    }
  for (w -= n; --w >= 0;)
    PUT (' ');
  if (sign)
    PUT ('-');
  else if (f__cplus)
    PUT ('+');
  while ((n = *b++))
    PUT (n);
  while (--d1 >= 0)
    PUT ('0');
  return 0;
}
@


1.3
log
@Actual synch with 3.3.5.

Changes in Makefile.bsd-wrapper to avoid prereq.

Fix in lib*/config.h.in to include the right ones and get the correct
definitions.

Bump of shlib_version accordingly.
@
text
@@


1.2
log
@result from merge... highly weird, since dale mixed things up
and we're going back, as his libf2c 3.3.2 is actually libf2c 3.2.3.
@
text
@a6 1
#ifndef KR_headers
a11 1
#endif
d16 2
a17 5
#ifdef KR_headers
wrt_E(p,w,d,e,len) ufloat *p; ftnlen len;
#else
wrt_E(ufloat *p, int w, int d, int e, ftnlen len)
#endif
d19 3
a21 3
	char buf[FMAX+EXPMAXDIGS+4], *s, *se;
	int d1, delta, e1, i, sign, signspace;
	double dd;
d23 1
a23 1
	int insert0 = 0;
d26 1
a26 1
	int e0 = e;
d29 22
a50 19
	if(e <= 0)
		e = 2;
	if(f__scale) {
		if(f__scale >= d + 2 || f__scale <= -d)
			goto nogood;
		}
	if(f__scale <= 0)
		--d;
	if (len == sizeof(real))
		dd = p->pf;
	else
		dd = p->pd;
	if (dd < 0.) {
		signspace = sign = 1;
		dd = -dd;
		}
	else {
		sign = 0;
		signspace = (int)f__cplus;
d52 2
a53 2
		if (!dd)
			dd = 0.;	/* avoid -0 */
d55 3
a57 3
		}
	delta = w - (2 /* for the . and the d adjustment above */
			+ 2 /* for the E+ */ + signspace + d + e);
d59 24
a82 21
	if (f__scale <= 0 && delta > 0) {
		delta--;
		insert0 = 1;
		}
	else
#endif
	if (delta < 0) {
nogood:
		while(--w >= 0)
			PUT('*');
		return(0);
		}
	if (f__scale < 0)
		d += f__scale;
	if (d > FMAX) {
		d1 = d - FMAX;
		d = FMAX;
		}
	else
		d1 = 0;
	sprintf(buf,"%#.*E", d, dd);
d84 25
a108 23
	/* check for NaN, Infinity */
	if (!isdigit(buf[0])) {
		switch(buf[0]) {
			case 'n':
			case 'N':
				signspace = 0;	/* no sign for NaNs */
			}
		delta = w - strlen(buf) - signspace;
		if (delta < 0)
			goto nogood;
		while(--delta >= 0)
			PUT(' ');
		if (signspace)
			PUT(sign ? '-' : '+');
		for(s = buf; *s; s++)
			PUT(*s);
		return 0;
		}
#endif
	se = buf + d + 3;
#ifdef GOOD_SPRINTF_EXPONENT /* When possible, exponent has 2 digits. */
	if (f__scale != 1 && dd)
		sprintf(se, "%+.2d", atoi(se) + 1 - f__scale);
d110 11
a120 10
	if (dd)
		sprintf(se, "%+.2d", atoi(se) + 1 - f__scale);
	else
		strcpy(se, "+00");
#endif
	s = ++se;
	if (e < 2) {
		if (*s != '0')
			goto nogood;
		}
d122 3
a124 2
	/* accommodate 3 significant digits in exponent */
	if (s[2]) {
d126 2
a127 2
		if (!e0 && !s[3])
			for(s -= 2, e1 = 2; s[0] = s[1]; s++);
d129 5
a133 5
	/* Pedantic gives the behavior that Fortran 77 specifies,	*/
	/* i.e., requires that E be specified for exponent fields	*/
	/* of more than 3 digits.  With Pedantic undefined, we get	*/
	/* the behavior that Cray displays -- you get a bigger		*/
	/* exponent field if it fits.	*/
d135 3
a137 2
		if (!e0) {
			for(s -= 2, e1 = 2; s[0] = s[1]; s++)
d139 26
a164 25
				delta--;
			if ((delta += 4) < 0)
				goto nogood
#endif
				;
			}
#endif
		else if (e0 >= 0)
			goto shift;
		else
			e1 = e;
		}
	else
 shift:
#endif
		for(s += 2, e1 = 2; *s; ++e1, ++s)
			if (e1 >= e)
				goto nogood;
	while(--delta >= 0)
		PUT(' ');
	if (signspace)
		PUT(sign ? '-' : '+');
	s = buf;
	i = f__scale;
	if (f__scale <= 0) {
d166 2
a167 2
		if (insert0)
			PUT('0');
d169 37
a205 31
		PUT('.');
		for(; i < 0; ++i)
			PUT('0');
		PUT(*s);
		s += 2;
		}
	else if (f__scale > 1) {
		PUT(*s);
		s += 2;
		while(--i > 0)
			PUT(*s++);
		PUT('.');
		}
	if (d1) {
		se -= 2;
		while(s < se) PUT(*s++);
		se += 2;
		do PUT('0'); while(--d1 > 0);
		}
	while(s < se)
		PUT(*s++);
	if (e < 2)
		PUT(s[1]);
	else {
		while(++e1 <= e)
			PUT('0');
		while(*s)
			PUT(*s++);
		}
	return 0;
	}
d207 2
a208 5
#ifdef KR_headers
wrt_F(p,w,d,len) ufloat *p; ftnlen len;
#else
wrt_F(ufloat *p, int w, int d, ftnlen len)
#endif
d210 3
a212 3
	int d1, sign, n;
	double x;
	char *b, buf[MAXINTDIGS+MAXFRACDIGS+4], *s;
d214 16
a229 11
	x= (len==sizeof(real)?p->pf:p->pd);
	if (d < MAXFRACDIGS)
		d1 = 0;
	else {
		d1 = d - MAXFRACDIGS;
		d = MAXFRACDIGS;
		}
	if (x < 0.)
		{ x = -x; sign = 1; }
	else {
		sign = 0;
d231 2
a232 2
		if (!x)
			x = 0.;
d234 1
a234 1
		}
d236 11
a246 5
	if (n = f__scale)
		if (n > 0)
			do x *= 10.; while(--n > 0);
		else
			do x *= 0.1; while(++n < 0);
d249 2
a250 2
	sprintf(b = buf, "%#.*f", d, x);
	n = strlen(b) + d1;
d252 1
a252 1
	n = sprintf(b = buf, "%#.*f", d, x) + d1;
d256 28
a283 19
	if (buf[0] == '0' && d)
		{ ++b; --n; }
#endif
	if (sign) {
		/* check for all zeros */
		for(s = b;;) {
			while(*s == '0') s++;
			switch(*s) {
				case '.':
					s++; continue;
				case 0:
					sign = 0;
				}
			break;
			}
		}
	if (sign || f__cplus)
		++n;
	if (n > w) {
d285 8
a292 21
		if (buf[0] == '0' && --n == w)
			++b;
		else
#endif
		{
			while(--w >= 0)
				PUT('*');
			return 0;
			}
		}
	for(w -= n; --w >= 0; )
		PUT(' ');
	if (sign)
		PUT('-');
	else if (f__cplus)
		PUT('+');
	while(n = *b++)
		PUT(n);
	while(--d1 >= 0)
		PUT('0');
	return 0;
d294 13
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of libf2c from gcc3.3.2
@
text
@@


1.1.1.2
log
@gcc 3.3.5 update
@
text
@d7 1
d13 1
d18 5
a22 2
int
wrt_E (ufloat * p, int w, int d, int e, ftnlen len)
d24 3
a26 3
  char buf[FMAX + EXPMAXDIGS + 4], *s, *se;
  int d1, delta, e1, i, sign, signspace;
  double dd;
d28 1
a28 1
  int insert0 = 0;
d31 1
a31 1
  int e0 = e;
d34 19
a52 22
  if (e <= 0)
    e = 2;
  if (f__scale)
    {
      if (f__scale >= d + 2 || f__scale <= -d)
	goto nogood;
    }
  if (f__scale <= 0)
    --d;
  if (len == sizeof (real))
    dd = p->pf;
  else
    dd = p->pd;
  if (dd < 0.)
    {
      signspace = sign = 1;
      dd = -dd;
    }
  else
    {
      sign = 0;
      signspace = (int) f__cplus;
d54 2
a55 2
      if (!dd)
	dd = 0.;		/* avoid -0 */
d57 3
a59 3
    }
  delta = w - (2		/* for the . and the d adjustment above */
	       + 2 /* for the E+ */  + signspace + d + e);
d61 21
a81 24
  if (f__scale <= 0 && delta > 0)
    {
      delta--;
      insert0 = 1;
    }
  else
#endif
  if (delta < 0)
    {
    nogood:
      while (--w >= 0)
	PUT ('*');
      return (0);
    }
  if (f__scale < 0)
    d += f__scale;
  if (d > FMAX)
    {
      d1 = d - FMAX;
      d = FMAX;
    }
  else
    d1 = 0;
  sprintf (buf, "%#.*E", d, dd);
d83 23
a105 25
  /* check for NaN, Infinity */
  if (!isdigit ((unsigned char) buf[0]))
    {
      switch (buf[0])
	{
	case 'n':
	case 'N':
	  signspace = 0;	/* no sign for NaNs */
	}
      delta = w - strlen (buf) - signspace;
      if (delta < 0)
	goto nogood;
      while (--delta >= 0)
	PUT (' ');
      if (signspace)
	PUT (sign ? '-' : '+');
      for (s = buf; *s; s++)
	PUT (*s);
      return 0;
    }
#endif
  se = buf + d + 3;
#ifdef GOOD_SPRINTF_EXPONENT	/* When possible, exponent has 2 digits. */
  if (f__scale != 1 && dd)
    sprintf (se, "%+.2d", atoi (se) + 1 - f__scale);
d107 10
a116 11
  if (dd)
    sprintf (se, "%+.2d", atoi (se) + 1 - f__scale);
  else
    strcpy (se, "+00");
#endif
  s = ++se;
  if (e < 2)
    {
      if (*s != '0')
	goto nogood;
    }
d118 2
a119 3
  /* accommodate 3 significant digits in exponent */
  if (s[2])
    {
d121 2
a122 2
      if (!e0 && !s[3])
	for (s -= 2, e1 = 2; s[0] = s[1]; s++);
d124 5
a128 5
      /* Pedantic gives the behavior that Fortran 77 specifies,       */
      /* i.e., requires that E be specified for exponent fields       */
      /* of more than 3 digits.  With Pedantic undefined, we get      */
      /* the behavior that Cray displays -- you get a bigger          */
      /* exponent field if it fits.   */
d130 2
a131 3
      if (!e0)
	{
	  for (s -= 2, e1 = 2; (s[0] = s[1]); s++)
d133 28
a160 3
	    delta--;
	  if ((delta += 4) < 0)
	    goto nogood
d162 30
a191 1
	      ;
d193 5
a198 63
      else if (e0 >= 0)
	goto shift;
      else
	e1 = e;
    }
  else
  shift:
#endif
    for (s += 2, e1 = 2; *s; ++e1, ++s)
      if (e1 >= e)
	goto nogood;
  while (--delta >= 0)
    PUT (' ');
  if (signspace)
    PUT (sign ? '-' : '+');
  s = buf;
  i = f__scale;
  if (f__scale <= 0)
    {
#ifdef WANT_LEAD_0
      if (insert0)
	PUT ('0');
#endif
      PUT ('.');
      for (; i < 0; ++i)
	PUT ('0');
      PUT (*s);
      s += 2;
    }
  else if (f__scale > 1)
    {
      PUT (*s);
      s += 2;
      while (--i > 0)
	PUT (*s++);
      PUT ('.');
    }
  if (d1)
    {
      se -= 2;
      while (s < se)
	PUT (*s++);
      se += 2;
      do
	PUT ('0');
      while (--d1 > 0);
    }
  while (s < se)
    PUT (*s++);
  if (e < 2)
    PUT (s[1]);
  else
    {
      while (++e1 <= e)
	PUT ('0');
      while (*s)
	PUT (*s++);
    }
  return 0;
}

int
wrt_F (ufloat * p, int w, int d, ftnlen len)
d200 3
a202 3
  int d1, sign, n;
  double x;
  char *b, buf[MAXINTDIGS + MAXFRACDIGS + 4], *s;
d204 11
a214 16
  x = (len == sizeof (real) ? p->pf : p->pd);
  if (d < MAXFRACDIGS)
    d1 = 0;
  else
    {
      d1 = d - MAXFRACDIGS;
      d = MAXFRACDIGS;
    }
  if (x < 0.)
    {
      x = -x;
      sign = 1;
    }
  else
    {
      sign = 0;
d216 2
a217 2
      if (!x)
	x = 0.;
d219 1
a219 1
    }
d221 5
a225 11
  if ((n = f__scale))
    {
      if (n > 0)
	do
	  x *= 10.;
	while (--n > 0);
      else
	do
	  x *= 0.1;
	while (++n < 0);
    }
d228 2
a229 2
  sprintf (b = buf, "%#.*f", d, x);
  n = strlen (b) + d1;
d231 1
a231 1
  n = sprintf (b = buf, "%#.*f", d, x) + d1;
d235 19
a253 28
  if (buf[0] == '0' && d)
    {
      ++b;
      --n;
    }
#endif
  if (sign)
    {
      /* check for all zeros */
      for (s = b;;)
	{
	  while (*s == '0')
	    s++;
	  switch (*s)
	    {
	    case '.':
	      s++;
	      continue;
	    case 0:
	      sign = 0;
	    }
	  break;
	}
    }
  if (sign || f__cplus)
    ++n;
  if (n > w)
    {
d255 21
a275 8
      if (buf[0] == '0' && --n == w)
	++b;
      else
#endif
	{
	  while (--w >= 0)
	    PUT ('*');
	  return 0;
a276 13
    }
  for (w -= n; --w >= 0;)
    PUT (' ');
  if (sign)
    PUT ('-');
  else if (f__cplus)
    PUT ('+');
  while ((n = *b++))
    PUT (n);
  while (--d1 >= 0)
    PUT ('0');
  return 0;
}
@

