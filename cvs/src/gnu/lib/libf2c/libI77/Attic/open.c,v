head	1.4;
access;
symbols
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.30
	OPENBSD_5_0:1.3.0.28
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.26
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.24
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.20
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.22
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.18
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.16
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.14
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.12
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.10
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.8
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.6
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.4
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	gcc-3_3_5:1.1.1.2
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2012.04.14.06.01.40;	author jsg;	state dead;
branches;
next	1.3;

1.3
date	2004.12.30.17.35.27;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2004.12.24.22.33.13;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.29.19.27.16;	author drahn;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.02.29.19.27.16;	author drahn;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.24.22.07.29;	author espie;	state Exp;
branches;
next	;


desc
@@


1.4
log
@remove libf2c, hasn't been built since it was moved to ports in 2010.
ok miod@@ espie@@
@
text
@#include "config.h"
#include "f2c.h"
#include "fio.h"
#include <string.h>
#ifndef NON_POSIX_STDIO
#ifdef MSDOS
#include "io.h"
#else
#include "unistd.h"		/* for access */
#endif
#endif

#undef abs
#undef min
#undef max
#include <stdlib.h>
extern int f__canseek (FILE *);
extern integer f_clos (cllist *);

#ifdef NON_ANSI_RW_MODES
char *f__r_mode[2] = { "r", "r" };
char *f__w_mode[4] = { "w", "w", "r+w", "r+w" };
#else
char *f__r_mode[2] = { "rb", "r" };
char *f__w_mode[4] = { "wb", "w", "r+b", "r+" };
#endif

static char f__buf0[400], *f__buf = f__buf0;
int f__buflen = (int) sizeof (f__buf0);

static void
f__bufadj (int n, int c)
{
  unsigned int len;
  char *nbuf, *s, *t, *te;

  if (f__buf == f__buf0)
    f__buflen = 1024;
  while (f__buflen <= n)
    f__buflen <<= 1;
  len = (unsigned int) f__buflen;
  if (len != f__buflen || !(nbuf = (char *) malloc (len)))
    f__fatal (113, "malloc failure");
  s = nbuf;
  t = f__buf;
  te = t + c;
  while (t < te)
    *s++ = *t++;
  if (f__buf != f__buf0)
    free (f__buf);
  f__buf = nbuf;
}

int
f__putbuf (int c)
{
  char *s, *se;
  int n;

  if (f__hiwater > f__recpos)
    f__recpos = f__hiwater;
  n = f__recpos + 1;
  if (n >= f__buflen)
    f__bufadj (n, f__recpos);
  s = f__buf;
  se = s + f__recpos;
  if (c)
    *se++ = c;
  *se = 0;
  for (;;)
    {
      fputs (s, f__cf);
      s += strlen (s);
      if (s >= se)
	break;			/* normally happens the first time */
      putc (*s++, f__cf);
    }
  return 0;
}

void
x_putc (int c)
{
  if (f__recpos >= f__buflen)
    f__bufadj (f__recpos, f__buflen);
  f__buf[f__recpos++] = c;
}

#define opnerr(f,m,s) \
  do {if(f) {f__init &= ~2; errno= m;} else opn_err(m,s,a); return(m);} while(0)

static void
opn_err (int m, char *s, olist * a)
{
  if (a->ofnm)
    {
      /* supply file name to error message */
      if (a->ofnmlen >= f__buflen)
	f__bufadj ((int) a->ofnmlen, 0);
      g_char (a->ofnm, a->ofnmlen, f__curunit->ufnm = f__buf);
    }
  f__fatal (m, s);
}

integer
f_open (olist * a)
{
  unit *b;
  integer rv;
  char buf[256], *s, *env;
  cllist x;
  int ufmt;
  FILE *tf;
  int fd, len;
#ifndef NON_UNIX_STDIO
  int n;
#endif
  if (f__init != 1)
    f_init ();
  f__external = 1;
  if (a->ounit >= MXUNIT || a->ounit < 0)
    err (a->oerr, 101, "open");
  f__curunit = b = &f__units[a->ounit];
  if (b->ufd)
    {
      if (a->ofnm == 0)
	{
	same:if (a->oblnk)
	    b->ublnk = *a->oblnk == 'z' || *a->oblnk == 'Z';
	  return (0);
	}
#ifdef NON_UNIX_STDIO
      if (b->ufnm
	  && strlen (b->ufnm) == a->ofnmlen
	  && !strncmp (b->ufnm, a->ofnm, (unsigned) a->ofnmlen))
	goto same;
#else
      g_char (a->ofnm, a->ofnmlen, buf);
      if (f__inode (buf, &n) == b->uinode && n == b->udev)
	goto same;
#endif
      x.cunit = a->ounit;
      x.csta = 0;
      x.cerr = a->oerr;
      if ((rv = f_clos (&x)) != 0)
	return rv;
    }
  b->url = (int) a->orl;
  b->ublnk = a->oblnk && (*a->oblnk == 'z' || *a->oblnk == 'Z');
  if (a->ofm == 0)
    if ((a->oacc) && (*a->oacc == 'D' || *a->oacc == 'd'))
      b->ufmt = 0;
    else
      b->ufmt = 1;
  else if (*a->ofm == 'f' || *a->ofm == 'F')
    b->ufmt = 1;
  else
    b->ufmt = 0;
  ufmt = b->ufmt;
#ifdef url_Adjust
  if (b->url && !ufmt)
    url_Adjust (b->url);
#endif
  if (a->ofnm)
    {
      g_char (a->ofnm, a->ofnmlen, buf);
      if (!buf[0])
	opnerr (a->oerr, 107, "open");
    }
  else
    sprintf (buf, "fort.%ld", (long) a->ounit);
  b->uscrtch = 0;
  b->uend = 0;
  b->uwrt = 0;
  b->ufd = 0;
  b->urw = 3;
  switch (a->osta ? *a->osta : 'u')
    {
    case 'o':
    case 'O':
#ifdef NON_POSIX_STDIO
      if (!(tf = fopen (buf, "r")))
	opnerr (a->oerr, errno, "open");
      fclose (tf);
#else
      if (access (buf, 0))
	opnerr (a->oerr, errno, "open");
#endif
      break;
    case 's':
    case 'S':
      b->uscrtch = 1;
#ifdef HAVE_MKSTEMP		/* Allow use of TMPDIR preferentially. */
      env = getenv ("TMPDIR");
      if (!env)
	env = getenv ("TEMP");
      if (!env)
	env = "/tmp";
      len = strlen (env);
      if (len > 256 - (int) sizeof ("/tmp.FXXXXXX"))
	err (a->oerr, 132, "open");
      strcpy (buf, env);
      strcat (buf, "/tmp.FXXXXXX");
      fd = mkstemp (buf);
      if (fd == -1 || close (fd))
	err (a->oerr, 132, "open");
#else /* ! defined (HAVE_MKSTEMP) */
#ifdef HAVE_TEMPNAM		/* Allow use of TMPDIR preferentially. */
      s = tempnam (0, buf);
      if (strlen (s) >= sizeof (buf))
	err (a->oerr, 132, "open");
      (void) strcpy (buf, s);
      free (s);
#else /* ! defined (HAVE_TEMPNAM) */
#ifdef HAVE_TMPNAM
      tmpnam (buf);
#else
      (void) strcpy (buf, "tmp.FXXXXXX");
      (void) mktemp (buf);
#endif
#endif /* ! defined (HAVE_TEMPNAM) */
#endif /* ! defined (HAVE_MKSTEMP) */
      goto replace;
    case 'n':
    case 'N':
#ifdef NON_POSIX_STDIO
      if ((tf = fopen (buf, "r")) || (tf = fopen (buf, "a")))
	{
	  fclose (tf);
	  opnerr (a->oerr, 128, "open");
	}
#else
      if (!access (buf, 0))
	opnerr (a->oerr, 128, "open");
#endif
      /* no break */
    case 'r':			/* Fortran 90 replace option */
    case 'R':
    replace:
      if ((tf = fopen (buf, f__w_mode[0])))
	fclose (tf);
    }

  b->ufnm = (char *) malloc ((unsigned int) (strlen (buf) + 1));
  if (b->ufnm == NULL)
    opnerr (a->oerr, 113, "no space");
  (void) strcpy (b->ufnm, buf);
  if ((s = a->oacc) && b->url)
    ufmt = 0;
  if (!(tf = fopen (buf, f__w_mode[ufmt | 2])))
    {
      if ((tf = fopen (buf, f__r_mode[ufmt])))
	b->urw = 1;
      else if ((tf = fopen (buf, f__w_mode[ufmt])))
	{
	  b->uwrt = 1;
	  b->urw = 2;
	}
      else
	err (a->oerr, errno, "open");
    }
  b->useek = f__canseek (b->ufd = tf);
#ifndef NON_UNIX_STDIO
  if ((b->uinode = f__inode (buf, &b->udev)) == -1)
    opnerr (a->oerr, 108, "open");
#endif
  if (b->useek)
    {
      if (a->orl)
	FSEEK (b->ufd, 0, SEEK_SET);
      else if ((s = a->oacc) && (*s == 'a' || *s == 'A')
	       && FSEEK (b->ufd, 0, SEEK_END))
	opnerr (a->oerr, 129, "open");
    }
  return (0);
}

int
fk_open (int seq, int fmt, ftnint n)
{
  char nbuf[10];
  olist a;
  int rtn;
  int save_init;

  (void) sprintf (nbuf, "fort.%ld", (long) n);
  a.oerr = 1;
  a.ounit = n;
  a.ofnm = nbuf;
  a.ofnmlen = strlen (nbuf);
  a.osta = NULL;
  a.oacc = seq == SEQ ? "s" : "d";
  a.ofm = fmt == FMT ? "f" : "u";
  a.orl = seq == DIR ? 1 : 0;
  a.oblnk = NULL;
  save_init = f__init;
  f__init &= ~2;
  rtn = f_open (&a);
  f__init = save_init | 1;
  return rtn;
}
@


1.3
log
@Actual synch with 3.3.5.

Changes in Makefile.bsd-wrapper to avoid prereq.

Fix in lib*/config.h.in to include the right ones and get the correct
definitions.

Bump of shlib_version accordingly.
@
text
@@


1.2
log
@result from merge... highly weird, since dale mixed things up
and we're going back, as his libf2c 3.3.2 is actually libf2c 3.2.3.
@
text
@a0 3
/* Define _XOPEN_SOURCE to get tempnam prototype with glibc et al --
   more general than _INCLUDE_XOPEN_SOURCE used elsewhere `for HP-UX'.  */
#define _XOPEN_SOURCE 1
d9 1
a9 1
#include "unistd.h"	/* for access */
a12 7
#ifdef KR_headers
extern char *malloc();
#ifdef NON_ANSI_STDIO
extern char *mktemp();
#endif
extern integer f_clos();
#else
d17 2
a18 3
extern int f__canseek(FILE*);
extern integer f_clos(cllist*);
#endif
d21 2
a22 2
char *f__r_mode[2] = {"r", "r"};
char *f__w_mode[4] = {"w", "w", "r+w", "r+w"};
d24 2
a25 2
char *f__r_mode[2] = {"rb", "r"};
char *f__w_mode[4] = {"wb", "w", "r+b", "r+"};
d28 2
a29 2
 static char f__buf0[400], *f__buf = f__buf0;
 int f__buflen = (int)sizeof(f__buf0);
d31 2
a32 6
 static void
#ifdef KR_headers
f__bufadj(n, c) int n, c;
#else
f__bufadj(int n, int c)
#endif
d34 2
a35 2
	unsigned int len;
	char *nbuf, *s, *t, *te;
d37 16
a52 16
	if (f__buf == f__buf0)
		f__buflen = 1024;
	while(f__buflen <= n)
		f__buflen <<= 1;
	len = (unsigned int)f__buflen;
	if (len != f__buflen || !(nbuf = (char*)malloc(len)))
		f__fatal(113, "malloc failure");
	s = nbuf;
	t = f__buf;
	te = t + c;
	while(t < te)
		*s++ = *t++;
	if (f__buf != f__buf0)
		free(f__buf);
	f__buf = nbuf;
	}
d54 2
a55 6
 int
#ifdef KR_headers
f__putbuf(c) int c;
#else
f__putbuf(int c)
#endif
d57 2
a58 2
	char *s, *se;
	int n;
d60 20
a79 19
	if (f__hiwater > f__recpos)
		f__recpos = f__hiwater;
	n = f__recpos + 1;
	if (n >= f__buflen)
		f__bufadj(n, f__recpos);
	s = f__buf;
	se = s + f__recpos;
	if (c)
		*se++ = c;
	*se = 0;
	for(;;) {
		fputs(s, f__cf);
		s += strlen(s);
		if (s >= se)
			break;	/* normally happens the first time */
		putc(*s++, f__cf);
		}
	return 0;
	}
d81 2
a82 6
 void
#ifdef KR_headers
x_putc(c)
#else
x_putc(int c)
#endif
d84 4
a87 4
	if (f__recpos >= f__buflen)
		f__bufadj(f__recpos, f__buflen);
	f__buf[f__recpos++] = c;
	}
d92 2
a93 6
 static void
#ifdef KR_headers
opn_err(m, s, a) int m; char *s; olist *a;
#else
opn_err(int m, char *s, olist *a)
#endif
d95 9
a103 8
	if (a->ofnm) {
		/* supply file name to error message */
		if (a->ofnmlen >= f__buflen)
			f__bufadj((int)a->ofnmlen, 0);
		g_char(a->ofnm, a->ofnmlen, f__curunit->ufnm = f__buf);
		}
	f__fatal(m, s);
	}
d105 10
a114 12
#ifdef KR_headers
integer f_open(a) olist *a;
#else
integer f_open(olist *a)
#endif
{	unit *b;
	integer rv;
	char buf[256], *s, *env;
	cllist x;
	int ufmt;
	FILE *tf;
	int fd, len;
d116 1
a116 1
	int n;
d118 14
a131 12
	if(f__init != 1) f_init();
	f__external = 1;
	if(a->ounit>=MXUNIT || a->ounit<0)
		err(a->oerr,101,"open");
	f__curunit = b = &f__units[a->ounit];
	if(b->ufd) {
		if(a->ofnm==0)
		{
		same:	if (a->oblnk)
				b->ublnk = *a->oblnk == 'z' || *a->oblnk == 'Z';
			return(0);
		}
d133 27
a159 24
		if (b->ufnm
		 && strlen(b->ufnm) == a->ofnmlen
		 && !strncmp(b->ufnm, a->ofnm, (unsigned)a->ofnmlen))
			goto same;
#else
		g_char(a->ofnm,a->ofnmlen,buf);
		if (f__inode(buf,&n) == b->uinode && n == b->udev)
			goto same;
#endif
		x.cunit=a->ounit;
		x.csta=0;
		x.cerr=a->oerr;
		if ((rv = f_clos(&x)) != 0)
			return rv;
		}
	b->url = (int)a->orl;
	b->ublnk = a->oblnk && (*a->oblnk == 'z' || *a->oblnk == 'Z');
	if(a->ofm==0)
	{	if(b->url>0) b->ufmt=0;
		else b->ufmt=1;
	}
	else if(*a->ofm=='f' || *a->ofm == 'F') b->ufmt=1;
	else b->ufmt=0;
	ufmt = b->ufmt;
d161 2
a162 2
	if (b->url && !ufmt)
		url_Adjust(b->url);
d164 17
a180 16
	if (a->ofnm) {
		g_char(a->ofnm,a->ofnmlen,buf);
		if (!buf[0])
			opnerr(a->oerr,107,"open");
		}
	else
		sprintf(buf, "fort.%ld", (long)a->ounit);
	b->uscrtch = 0;
	b->uend=0;
	b->uwrt = 0;
	b->ufd = 0;
	b->urw = 3;
	switch(a->osta ? *a->osta : 'u')
	{
	case 'o':
	case 'O':
d182 25
a206 23
		if (!(tf = fopen(buf,"r")))
			opnerr(a->oerr,errno,"open");
		fclose(tf);
#else
		if (access(buf,0))
			opnerr(a->oerr,errno,"open");
#endif
		break;
	 case 's':
	 case 'S':
		b->uscrtch=1;
#ifdef HAVE_MKSTEMP             /* Allow use of TMPDIR preferentially. */
		env = getenv("TMPDIR");
		if (!env) env = getenv("TEMP");
		if (!env) env = "/tmp";
		len = strlen(env);
		if (len > 256 - sizeof "/tmp.FXXXXXX")
		  err (a->oerr, 132, "open");
		strcpy(buf, env);
		strcat(buf, "/tmp.FXXXXXX");
		fd = mkstemp(buf);
		if (fd == -1 || close(fd))
		  err (a->oerr, 132, "open");
d209 5
a213 5
		s = tempnam (0, buf);
		if (strlen (s) >= sizeof (buf))
		  err (a->oerr, 132, "open");
		(void) strcpy (buf, s);
		free (s);
d216 1
a216 1
		tmpnam(buf);
d218 2
a219 2
		(void) strcpy(buf,"tmp.FXXXXXX");
		(void) mktemp(buf);
d223 3
a225 3
		goto replace;
	case 'n':
	case 'N':
d227 5
a231 4
		if ((tf = fopen(buf,"r")) || (tf = fopen(buf,"a"))) {
			fclose(tf);
			opnerr(a->oerr,128,"open");
			}
d233 2
a234 2
		if (!access(buf,0))
			opnerr(a->oerr,128,"open");
d236 22
a257 6
		/* no break */
	case 'r':	/* Fortran 90 replace option */
	case 'R':
 replace:
		if (tf = fopen(buf,f__w_mode[0]))
			fclose(tf);
d259 4
a262 17

	b->ufnm=(char *) malloc((unsigned int)(strlen(buf)+1));
	if(b->ufnm==NULL) opnerr(a->oerr,113,"no space");
	(void) strcpy(b->ufnm,buf);
	if ((s = a->oacc) && b->url)
		ufmt = 0;
	if(!(tf = fopen(buf, f__w_mode[ufmt|2]))) {
		if (tf = fopen(buf, f__r_mode[ufmt]))
			b->urw = 1;
		else if (tf = fopen(buf, f__w_mode[ufmt])) {
			b->uwrt = 1;
			b->urw = 2;
			}
		else
			err(a->oerr, errno, "open");
		}
	b->useek = f__canseek(b->ufd = tf);
d264 2
a265 2
	if((b->uinode = f__inode(buf,&b->udev)) == -1)
		opnerr(a->oerr,108,"open");
d267 9
a275 7
	if(b->useek)
		if (a->orl)
			FSEEK(b->ufd, 0, SEEK_SET);
		else if ((s = a->oacc) && (*s == 'a' || *s == 'A')
			&& FSEEK(b->ufd, 0, SEEK_END))
				opnerr(a->oerr,129,"open");
	return(0);
d277 24
a300 25
#ifdef KR_headers
fk_open(seq,fmt,n) ftnint n;
#else
fk_open(int seq, int fmt, ftnint n)
#endif
{	char nbuf[10];
	olist a;
	int rtn;
	int save_init;

	(void) sprintf(nbuf,"fort.%ld",(long)n);
	a.oerr=1;
	a.ounit=n;
	a.ofnm=nbuf;
	a.ofnmlen=strlen(nbuf);
	a.osta=NULL;
	a.oacc= seq==SEQ?"s":"d";
	a.ofm = fmt==FMT?"f":"u";
	a.orl = seq==DIR?1:0;
	a.oblnk=NULL;
	save_init = f__init;
	f__init &= ~2;
	rtn = f_open(&a);
	f__init = save_init | 1;
	return rtn;
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of libf2c from gcc3.3.2
@
text
@@


1.1.1.2
log
@gcc 3.3.5 update
@
text
@d1 3
d12 1
a12 1
#include "unistd.h"		/* for access */
d16 7
d27 3
a29 2
extern int f__canseek (FILE *);
extern integer f_clos (cllist *);
d32 2
a33 2
char *f__r_mode[2] = { "r", "r" };
char *f__w_mode[4] = { "w", "w", "r+w", "r+w" };
d35 2
a36 2
char *f__r_mode[2] = { "rb", "r" };
char *f__w_mode[4] = { "wb", "w", "r+b", "r+" };
d39 2
a40 2
static char f__buf0[400], *f__buf = f__buf0;
int f__buflen = (int) sizeof (f__buf0);
d42 6
a47 2
static void
f__bufadj (int n, int c)
d49 2
a50 2
  unsigned int len;
  char *nbuf, *s, *t, *te;
d52 16
a67 16
  if (f__buf == f__buf0)
    f__buflen = 1024;
  while (f__buflen <= n)
    f__buflen <<= 1;
  len = (unsigned int) f__buflen;
  if (len != f__buflen || !(nbuf = (char *) malloc (len)))
    f__fatal (113, "malloc failure");
  s = nbuf;
  t = f__buf;
  te = t + c;
  while (t < te)
    *s++ = *t++;
  if (f__buf != f__buf0)
    free (f__buf);
  f__buf = nbuf;
}
d69 6
a74 2
int
f__putbuf (int c)
d76 2
a77 2
  char *s, *se;
  int n;
d79 19
a97 20
  if (f__hiwater > f__recpos)
    f__recpos = f__hiwater;
  n = f__recpos + 1;
  if (n >= f__buflen)
    f__bufadj (n, f__recpos);
  s = f__buf;
  se = s + f__recpos;
  if (c)
    *se++ = c;
  *se = 0;
  for (;;)
    {
      fputs (s, f__cf);
      s += strlen (s);
      if (s >= se)
	break;			/* normally happens the first time */
      putc (*s++, f__cf);
    }
  return 0;
}
d99 6
a104 2
void
x_putc (int c)
d106 4
a109 4
  if (f__recpos >= f__buflen)
    f__bufadj (f__recpos, f__buflen);
  f__buf[f__recpos++] = c;
}
d114 6
a119 2
static void
opn_err (int m, char *s, olist * a)
d121 8
a128 9
  if (a->ofnm)
    {
      /* supply file name to error message */
      if (a->ofnmlen >= f__buflen)
	f__bufadj ((int) a->ofnmlen, 0);
      g_char (a->ofnm, a->ofnmlen, f__curunit->ufnm = f__buf);
    }
  f__fatal (m, s);
}
d130 12
a141 10
integer
f_open (olist * a)
{
  unit *b;
  integer rv;
  char buf[256], *s, *env;
  cllist x;
  int ufmt;
  FILE *tf;
  int fd, len;
d143 23
a165 1
  int n;
d167 11
a177 13
  if (f__init != 1)
    f_init ();
  f__external = 1;
  if (a->ounit >= MXUNIT || a->ounit < 0)
    err (a->oerr, 101, "open");
  f__curunit = b = &f__units[a->ounit];
  if (b->ufd)
    {
      if (a->ofnm == 0)
	{
	same:if (a->oblnk)
	    b->ublnk = *a->oblnk == 'z' || *a->oblnk == 'Z';
	  return (0);
d179 3
a181 28
#ifdef NON_UNIX_STDIO
      if (b->ufnm
	  && strlen (b->ufnm) == a->ofnmlen
	  && !strncmp (b->ufnm, a->ofnm, (unsigned) a->ofnmlen))
	goto same;
#else
      g_char (a->ofnm, a->ofnmlen, buf);
      if (f__inode (buf, &n) == b->uinode && n == b->udev)
	goto same;
#endif
      x.cunit = a->ounit;
      x.csta = 0;
      x.cerr = a->oerr;
      if ((rv = f_clos (&x)) != 0)
	return rv;
    }
  b->url = (int) a->orl;
  b->ublnk = a->oblnk && (*a->oblnk == 'z' || *a->oblnk == 'Z');
  if (a->ofm == 0)
    if ((a->oacc) && (*a->oacc == 'D' || *a->oacc == 'd'))
      b->ufmt = 0;
    else
      b->ufmt = 1;
  else if (*a->ofm == 'f' || *a->ofm == 'F')
    b->ufmt = 1;
  else
    b->ufmt = 0;
  ufmt = b->ufmt;
d183 2
a184 2
  if (b->url && !ufmt)
    url_Adjust (b->url);
d186 16
a201 17
  if (a->ofnm)
    {
      g_char (a->ofnm, a->ofnmlen, buf);
      if (!buf[0])
	opnerr (a->oerr, 107, "open");
    }
  else
    sprintf (buf, "fort.%ld", (long) a->ounit);
  b->uscrtch = 0;
  b->uend = 0;
  b->uwrt = 0;
  b->ufd = 0;
  b->urw = 3;
  switch (a->osta ? *a->osta : 'u')
    {
    case 'o':
    case 'O':
d203 23
a225 25
      if (!(tf = fopen (buf, "r")))
	opnerr (a->oerr, errno, "open");
      fclose (tf);
#else
      if (access (buf, 0))
	opnerr (a->oerr, errno, "open");
#endif
      break;
    case 's':
    case 'S':
      b->uscrtch = 1;
#ifdef HAVE_MKSTEMP		/* Allow use of TMPDIR preferentially. */
      env = getenv ("TMPDIR");
      if (!env)
	env = getenv ("TEMP");
      if (!env)
	env = "/tmp";
      len = strlen (env);
      if (len > 256 - (int) sizeof ("/tmp.FXXXXXX"))
	err (a->oerr, 132, "open");
      strcpy (buf, env);
      strcat (buf, "/tmp.FXXXXXX");
      fd = mkstemp (buf);
      if (fd == -1 || close (fd))
	err (a->oerr, 132, "open");
d228 5
a232 5
      s = tempnam (0, buf);
      if (strlen (s) >= sizeof (buf))
	err (a->oerr, 132, "open");
      (void) strcpy (buf, s);
      free (s);
d235 1
a235 1
      tmpnam (buf);
d237 2
a238 2
      (void) strcpy (buf, "tmp.FXXXXXX");
      (void) mktemp (buf);
d242 3
a244 3
      goto replace;
    case 'n':
    case 'N':
d246 4
a249 5
      if ((tf = fopen (buf, "r")) || (tf = fopen (buf, "a")))
	{
	  fclose (tf);
	  opnerr (a->oerr, 128, "open");
	}
d251 2
a252 2
      if (!access (buf, 0))
	opnerr (a->oerr, 128, "open");
d254 6
a259 22
      /* no break */
    case 'r':			/* Fortran 90 replace option */
    case 'R':
    replace:
      if ((tf = fopen (buf, f__w_mode[0])))
	fclose (tf);
    }

  b->ufnm = (char *) malloc ((unsigned int) (strlen (buf) + 1));
  if (b->ufnm == NULL)
    opnerr (a->oerr, 113, "no space");
  (void) strcpy (b->ufnm, buf);
  if ((s = a->oacc) && b->url)
    ufmt = 0;
  if (!(tf = fopen (buf, f__w_mode[ufmt | 2])))
    {
      if ((tf = fopen (buf, f__r_mode[ufmt])))
	b->urw = 1;
      else if ((tf = fopen (buf, f__w_mode[ufmt])))
	{
	  b->uwrt = 1;
	  b->urw = 2;
d261 17
a277 4
      else
	err (a->oerr, errno, "open");
    }
  b->useek = f__canseek (b->ufd = tf);
d279 2
a280 2
  if ((b->uinode = f__inode (buf, &b->udev)) == -1)
    opnerr (a->oerr, 108, "open");
d282 7
a288 9
  if (b->useek)
    {
      if (a->orl)
	FSEEK (b->ufd, 0, SEEK_SET);
      else if ((s = a->oacc) && (*s == 'a' || *s == 'A')
	       && FSEEK (b->ufd, 0, SEEK_END))
	opnerr (a->oerr, 129, "open");
    }
  return (0);
d290 25
a314 24

int
fk_open (int seq, int fmt, ftnint n)
{
  char nbuf[10];
  olist a;
  int rtn;
  int save_init;

  (void) sprintf (nbuf, "fort.%ld", (long) n);
  a.oerr = 1;
  a.ounit = n;
  a.ofnm = nbuf;
  a.ofnmlen = strlen (nbuf);
  a.osta = NULL;
  a.oacc = seq == SEQ ? "s" : "d";
  a.ofm = fmt == FMT ? "f" : "u";
  a.orl = seq == DIR ? 1 : 0;
  a.oblnk = NULL;
  save_init = f__init;
  f__init &= ~2;
  rtn = f_open (&a);
  f__init = save_init | 1;
  return rtn;
@

