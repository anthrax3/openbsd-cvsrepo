head	1.4;
access;
symbols
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.30
	OPENBSD_5_0:1.3.0.28
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.26
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.24
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.20
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.22
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.18
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.16
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.14
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.12
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.10
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.8
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.6
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.4
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	gcc-3_3_5:1.1.1.2
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2012.04.14.06.01.40;	author jsg;	state dead;
branches;
next	1.3;

1.3
date	2004.12.30.17.35.27;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2004.12.24.22.33.13;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.29.19.27.17;	author drahn;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.02.29.19.27.17;	author drahn;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.24.22.07.29;	author espie;	state Exp;
branches;
next	;


desc
@@


1.4
log
@remove libf2c, hasn't been built since it was moved to ports in 2010.
ok miod@@ espie@@
@
text
@#include "config.h"
#include "f2c.h"
#include "fio.h"
#include "lio.h"

#define MAX_NL_CACHE 3		/* maximum number of namelist hash tables to cache */
#define MAXDIM 20		/* maximum number of subscripts */

struct dimen
{
  ftnlen extent;
  ftnlen curval;
  ftnlen delta;
  ftnlen stride;
};
typedef struct dimen dimen;

struct hashentry
{
  struct hashentry *next;
  char *name;
  Vardesc *vd;
};
typedef struct hashentry hashentry;

struct hashtab
{
  struct hashtab *next;
  Namelist *nl;
  int htsize;
  hashentry *tab[1];
};
typedef struct hashtab hashtab;

static hashtab *nl_cache;
static int n_nlcache;
static hashentry **zot;
static int colonseen;
extern ftnlen f__typesize[];

extern flag f__lquit;
extern int f__lcount, nml_read;
extern int t_getc (void);

#undef abs
#undef min
#undef max
#include <stdlib.h>
#include <string.h>

#ifdef ungetc
static int
un_getc (int x, FILE * f__cf)
{
  return ungetc (x, f__cf);
}
#else
#define un_getc ungetc
extern int ungetc (int, FILE *);	/* for systems with a buggy stdio.h */
#endif

static Vardesc *
hash (hashtab * ht, register char *s)
{
  register int c, x;
  register hashentry *h;
  char *s0 = s;

  for (x = 0; (c = *s++); x = x & 0x4000 ? ((x << 1) & 0x7fff) + 1 : x << 1)
    x += c;
  for (h = *(zot = ht->tab + x % ht->htsize); h; h = h->next)
    if (!strcmp (s0, h->name))
      return h->vd;
  return 0;
}

hashtab *
mk_hashtab (Namelist * nl)
{
  int nht, nv;
  hashtab *ht;
  Vardesc *v, **vd, **vde;
  hashentry *he;

  hashtab **x, **x0, *y;
  for (x = &nl_cache; (y = *x); x0 = x, x = &y->next)
    if (nl == y->nl)
      return y;
  if (n_nlcache >= MAX_NL_CACHE)
    {
      /* discard least recently used namelist hash table */
      y = *x0;
      free ((char *) y->next);
      y->next = 0;
    }
  else
    n_nlcache++;
  nv = nl->nvars;
  if (nv >= 0x4000)
    nht = 0x7fff;
  else
    {
      for (nht = 1; nht < nv; nht <<= 1);
      nht += nht - 1;
    }
  ht = (hashtab *) malloc (sizeof (hashtab) + (nht - 1) * sizeof (hashentry *)
			   + nv * sizeof (hashentry));
  if (!ht)
    return 0;
  he = (hashentry *) & ht->tab[nht];
  ht->nl = nl;
  ht->htsize = nht;
  ht->next = nl_cache;
  nl_cache = ht;
  memset ((char *) ht->tab, 0, nht * sizeof (hashentry *));
  vd = nl->vars;
  vde = vd + nv;
  while (vd < vde)
    {
      v = *vd++;
      if (!hash (ht, v->name))
	{
	  he->next = *zot;
	  *zot = he;
	  he->name = v->name;
	  he->vd = v;
	  he++;
	}
    }
  return ht;
}

static char Alpha[256], Alphanum[256];

static void
nl_init (void)
{
  register char *s;
  register int c;

  for (s = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; (c = *s++);)
    Alpha[c]
      = Alphanum[c] = Alpha[c + 'a' - 'A'] = Alphanum[c + 'a' - 'A'] = c;
  for (s = "0123456789_"; (c = *s++);)
    Alphanum[c] = c;
}

#define GETC(x) (x=(*l_getc)())
#define Ungetc(x,y) (*l_ungetc)(x,y)

static int
getname (register char *s, int slen)
{
  register char *se = s + slen - 1;
  register int ch;

  GETC (ch);
  if (!(*s++ = Alpha[ch & 0xff]))
    {
      if (ch != EOF)
	ch = 115;
      errfl (f__elist->cierr, ch, "namelist read");
    }
  while ((*s = Alphanum[GETC (ch) & 0xff]))
    if (s < se)
      s++;
  if (ch == EOF)
    err (f__elist->cierr, EOF, "namelist read");
  if (ch > ' ')
    Ungetc (ch, f__cf);
  return *s = 0;
}

static int
getnum (int *chp, ftnlen * val)
{
  register int ch, sign;
  register ftnlen x;

  while (GETC (ch) <= ' ' && ch >= 0);
  if (ch == '-')
    {
      sign = 1;
      GETC (ch);
    }
  else
    {
      sign = 0;
      if (ch == '+')
	GETC (ch);
    }
  x = ch - '0';
  if (x < 0 || x > 9)
    return 115;
  while (GETC (ch) >= '0' && ch <= '9')
    x = 10 * x + ch - '0';
  while (ch <= ' ' && ch >= 0)
    GETC (ch);
  if (ch == EOF)
    return EOF;
  *val = sign ? -x : x;
  *chp = ch;
  return 0;
}

static int
getdimen (int *chp, dimen * d, ftnlen delta, ftnlen extent, ftnlen * x1)
{
  register int k;
  ftnlen x2, x3;

  if ((k = getnum (chp, x1)))
    return k;
  x3 = 1;
  if (*chp == ':')
    {
      if ((k = getnum (chp, &x2)))
	return k;
      x2 -= *x1;
      if (*chp == ':')
	{
	  if ((k = getnum (chp, &x3)))
	    return k;
	  if (!x3)
	    return 123;
	  x2 /= x3;
	  colonseen = 1;
	}
      if (x2 < 0 || x2 >= extent)
	return 123;
      d->extent = x2 + 1;
    }
  else
    d->extent = 1;
  d->curval = 0;
  d->delta = delta;
  d->stride = x3;
  return 0;
}

#ifndef No_Namelist_Questions
static void
print_ne (cilist * a)
{
  flag intext = f__external;
  int rpsave = f__recpos;
  FILE *cfsave = f__cf;
  unit *usave = f__curunit;
  cilist t;
  t = *a;
  t.ciunit = 6;
  s_wsne (&t);
  fflush (f__cf);
  f__external = intext;
  f__reading = 1;
  f__recpos = rpsave;
  f__cf = cfsave;
  f__curunit = usave;
  f__elist = a;
}
#endif

static char where0[] = "namelist read start ";

int
x_rsne (cilist * a)
{
  int ch, got1, k, n, nd, quote, readall;
  Namelist *nl;
  static char where[] = "namelist read";
  char buf[64];
  hashtab *ht;
  Vardesc *v;
  dimen *dn, *dn0, *dn1;
  ftnlen *dims, *dims1;
  ftnlen b, b0, b1, ex, no, nomax, size, span;
  ftnint no1, type;
  char *vaddr;
  long iva, ivae;
  dimen dimens[MAXDIM], substr;

  if (!Alpha['a'])
    nl_init ();
  f__reading = 1;
  f__formatted = 1;
  got1 = 0;
top:
  for (;;)
    switch (GETC (ch))
      {
      case EOF:
      eof:
	err (a->ciend, (EOF), where0);
      case '&':
      case '$':
	goto have_amp;
#ifndef No_Namelist_Questions
      case '?':
	print_ne (a);
	continue;
#endif
      default:
	if (ch <= ' ' && ch >= 0)
	  continue;
#ifndef No_Namelist_Comments
	while (GETC (ch) != '\n')
	  if (ch == EOF)
	    goto eof;
#else
	errfl (a->cierr, 115, where0);
#endif
      }
have_amp:
  if ((ch = getname (buf, sizeof (buf))))
    return ch;
  nl = (Namelist *) a->cifmt;
  if (strcmp (buf, nl->name))
#ifdef No_Bad_Namelist_Skip
    errfl (a->cierr, 118, where0);
#else
    {
      fprintf (stderr,
	       "Skipping namelist \"%s\": seeking namelist \"%s\".\n",
	       buf, nl->name);
      fflush (stderr);
      for (;;)
	switch (GETC (ch))
	  {
	  case EOF:
	    err (a->ciend, EOF, where0);
	  case '/':
	  case '&':
	  case '$':
	    if (f__external)
	      e_rsle ();
	    else
	      z_rnew ();
	    goto top;
	  case '"':
	  case '\'':
	    quote = ch;
	  more_quoted:
	    while (GETC (ch) != quote)
	      if (ch == EOF)
		err (a->ciend, EOF, where0);
	    if (GETC (ch) == quote)
	      goto more_quoted;
	    Ungetc (ch, f__cf);
	  default:
	    continue;
	  }
    }
#endif
  ht = mk_hashtab (nl);
  if (!ht)
    errfl (f__elist->cierr, 113, where0);
  for (;;)
    {
      for (;;)
	switch (GETC (ch))
	  {
	  case EOF:
	    if (got1)
	      return 0;
	    err (a->ciend, EOF, where0);
	  case '/':
	  case '$':
	  case '&':
	    return 0;
	  default:
	    if ((ch <= ' ' && ch >= 0) || ch == ',')
	      continue;
	    Ungetc (ch, f__cf);
	    if ((ch = getname (buf, sizeof (buf))))
	      return ch;
	    goto havename;
	  }
    havename:
      v = hash (ht, buf);
      if (!v)
	errfl (a->cierr, 119, where);
      while (GETC (ch) <= ' ' && ch >= 0);
      vaddr = v->addr;
      type = v->type;
      if (type < 0)
	{
	  size = -type;
	  type = TYCHAR;
	}
      else
	size = f__typesize[type];
      ivae = size;
      iva = readall = 0;
      if (ch == '(' /*) */ )
	{
	  dn = dimens;
	  if (!(dims = v->dims))
	    {
	      if (type != TYCHAR)
		errfl (a->cierr, 122, where);
	      if ((k = getdimen (&ch, dn, (ftnlen) size, (ftnlen) size, &b)))
		errfl (a->cierr, k, where);
	      if (ch != ')')
		errfl (a->cierr, 115, where);
	      b1 = dn->extent;
	      if (--b < 0 || b + b1 > size)
		return 124;
	      iva += b;
	      size = b1;
	      while (GETC (ch) <= ' ' && ch >= 0);
	      goto scalar;
	    }
	  nd = (int) dims[0];
	  nomax = span = dims[1];
	  ivae = iva + size * nomax;
	  colonseen = 0;
	  if ((k = getdimen (&ch, dn, size, nomax, &b)))
	    errfl (a->cierr, k, where);
	  no = dn->extent;
	  b0 = dims[2];
	  dims1 = dims += 3;
	  ex = 1;
	  for (n = 1; n++ < nd; dims++)
	    {
	      if (ch != ',')
		errfl (a->cierr, 115, where);
	      dn1 = dn + 1;
	      span /= *dims;
	      if ((k = getdimen (&ch, dn1, dn->delta ** dims, span, &b1)))
		errfl (a->cierr, k, where);
	      ex *= *dims;
	      b += b1 * ex;
	      no *= dn1->extent;
	      dn = dn1;
	    }
	  if (ch != ')')
	    errfl (a->cierr, 115, where);
	  readall = 1 - colonseen;
	  b -= b0;
	  if (b < 0 || b >= nomax)
	    errfl (a->cierr, 125, where);
	  iva += size * b;
	  dims = dims1;
	  while (GETC (ch) <= ' ' && ch >= 0);
	  no1 = 1;
	  dn0 = dimens;
	  if (type == TYCHAR && ch == '(' /*) */ )
	    {
	      if ((k = getdimen (&ch, &substr, size, size, &b)))
		errfl (a->cierr, k, where);
	      if (ch != ')')
		errfl (a->cierr, 115, where);
	      b1 = substr.extent;
	      if (--b < 0 || b + b1 > size)
		return 124;
	      iva += b;
	      b0 = size;
	      size = b1;
	      while (GETC (ch) <= ' ' && ch >= 0);
	      if (b1 < b0)
		goto delta_adj;
	    }
	  if (readall)
	    goto delta_adj;
	  for (; dn0 < dn; dn0++)
	    {
	      if (dn0->extent != *dims++ || dn0->stride != 1)
		break;
	      no1 *= dn0->extent;
	    }
	  if (dn0 == dimens && dimens[0].stride == 1)
	    {
	      no1 = dimens[0].extent;
	      dn0++;
	    }
	delta_adj:
	  ex = 0;
	  for (dn1 = dn0; dn1 <= dn; dn1++)
	    ex += (dn1->extent - 1) * (dn1->delta *= dn1->stride);
	  for (dn1 = dn; dn1 > dn0; dn1--)
	    {
	      ex -= (dn1->extent - 1) * dn1->delta;
	      dn1->delta -= ex;
	    }
	}
      else if ((dims = v->dims))
	{
	  no = no1 = dims[1];
	  ivae = iva + no * size;
	}
      else
      scalar:
	no = no1 = 1;
      if (ch != '=')
	errfl (a->cierr, 115, where);
      got1 = nml_read = 1;
      f__lcount = 0;
    readloop:
      for (;;)
	{
	  if (iva >= ivae || iva < 0)
	    {
	      f__lquit = 1;
	      goto mustend;
	    }
	  else if (iva + no1 * size > ivae)
	    no1 = (ivae - iva) / size;
	  f__lquit = 0;
	  if ((k = l_read (&no1, vaddr + iva, size, type)))
	    return k;
	  if (f__lquit == 1)
	    return 0;
	  if (readall)
	    {
	      iva += dn0->delta;
	      if (f__lcount > 0)
		{
		  ftnint no2 = (ivae - iva) / size;
		  if (no2 > f__lcount)
		    no2 = f__lcount;
		  if ((k = l_read (&no2, vaddr + iva, size, type)))
		    return k;
		  iva += no2 * dn0->delta;
		}
	    }
	mustend:
	  GETC (ch);
	  if (readall)
	    {
	      if (iva >= ivae)
		readall = 0;
	      else
		for (;;)
		  {
		    switch (ch)
		      {
		      case ' ':
		      case '\t':
		      case '\n':
			GETC (ch);
			continue;
		      }
		    break;
		  }
	    }
	  if (ch == '/' || ch == '$' || ch == '&')
	    {
	      f__lquit = 1;
	      return 0;
	    }
	  else if (f__lquit)
	    {
	      while (ch <= ' ' && ch >= 0)
		GETC (ch);
	      Ungetc (ch, f__cf);
	      if (!Alpha[ch & 0xff] && ch >= 0)
		errfl (a->cierr, 125, where);
	      break;
	    }
	  Ungetc (ch, f__cf);
	  if (readall && !Alpha[ch & 0xff])
	    goto readloop;
	  if ((no -= no1) <= 0)
	    break;
	  for (dn1 = dn0; dn1 <= dn; dn1++)
	    {
	      if (++dn1->curval < dn1->extent)
		{
		  iva += dn1->delta;
		  goto readloop;
		}
	      dn1->curval = 0;
	    }
	  break;
	}
    }
}

integer
s_rsne (cilist * a)
{
  extern int l_eof;
  int n;

  f__external = 1;
  l_eof = 0;
  if ((n = c_le (a)))
    return n;
  if (f__curunit->uwrt && f__nowreading (f__curunit))
    err (a->cierr, errno, where0);
  l_getc = t_getc;
  l_ungetc = un_getc;
  f__doend = xrd_SL;
  n = x_rsne (a);
  nml_read = 0;
  if (n)
    return n;
  return e_rsle ();
}
@


1.3
log
@Actual synch with 3.3.5.

Changes in Makefile.bsd-wrapper to avoid prereq.

Fix in lib*/config.h.in to include the right ones and get the correct
definitions.

Bump of shlib_version accordingly.
@
text
@@


1.2
log
@result from merge... highly weird, since dale mixed things up
and we're going back, as his libf2c 3.3.2 is actually libf2c 3.2.3.
@
text
@d6 2
a7 2
#define MAX_NL_CACHE 3	/* maximum number of namelist hash tables to cache */
#define MAXDIM 20	/* maximum number of subscripts */
d9 8
a16 32
 struct dimen {
	ftnlen extent;
	ftnlen curval;
	ftnlen delta;
	ftnlen stride;
	};
 typedef struct dimen dimen;

 struct hashentry {
	struct hashentry *next;
	char *name;
	Vardesc *vd;
	};
 typedef struct hashentry hashentry;

 struct hashtab {
	struct hashtab *next;
	Namelist *nl;
	int htsize;
	hashentry *tab[1];
	};
 typedef struct hashtab hashtab;

 static hashtab *nl_cache;
 static int n_nlcache;
 static hashentry **zot;
 static int colonseen;
 extern ftnlen f__typesize[];

 extern flag f__lquit;
 extern int f__lcount, nml_read;
 extern t_getc(Void);
d18 7
a24 2
#ifdef KR_headers
 extern char *malloc(), *memset();
d26 18
a43 8
#ifdef ungetc
 static int
un_getc(x,f__cf) int x; FILE *f__cf;
{ return ungetc(x,f__cf); }
#else
#define un_getc ungetc
 extern int ungetc();
#endif
a44 1
#else
d52 5
a56 3
 static int
un_getc(int x, FILE *f__cf)
{ return ungetc(x,f__cf); }
d59 1
a59 2
extern int ungetc(int, FILE*);	/* for systems with a buggy stdio.h */
#endif
d62 2
a63 6
 static Vardesc *
#ifdef KR_headers
hash(ht, s) hashtab *ht; register char *s;
#else
hash(hashtab *ht, register char *s)
#endif
d65 11
a75 11
	register int c, x;
	register hashentry *h;
	char *s0 = s;

	for(x = 0; c = *s++; x = x & 0x4000 ? ((x << 1) & 0x7fff) + 1 : x << 1)
		x += c;
	for(h = *(zot = ht->tab + x % ht->htsize); h; h = h->next)
		if (!strcmp(s0, h->name))
			return h->vd;
	return 0;
	}
d77 2
a78 6
 hashtab *
#ifdef KR_headers
mk_hashtab(nl) Namelist *nl;
#else
mk_hashtab(Namelist *nl)
#endif
d80 48
a127 47
	int nht, nv;
	hashtab *ht;
	Vardesc *v, **vd, **vde;
	hashentry *he;

	hashtab **x, **x0, *y;
	for(x = &nl_cache; y = *x; x0 = x, x = &y->next)
		if (nl == y->nl)
			return y;
	if (n_nlcache >= MAX_NL_CACHE) {
		/* discard least recently used namelist hash table */
		y = *x0;
		free((char *)y->next);
		y->next = 0;
		}
	else
		n_nlcache++;
	nv = nl->nvars;
	if (nv >= 0x4000)
		nht = 0x7fff;
	else {
		for(nht = 1; nht < nv; nht <<= 1);
		nht += nht - 1;
		}
	ht = (hashtab *)malloc(sizeof(hashtab) + (nht-1)*sizeof(hashentry *)
				+ nv*sizeof(hashentry));
	if (!ht)
		return 0;
	he = (hashentry *)&ht->tab[nht];
	ht->nl = nl;
	ht->htsize = nht;
	ht->next = nl_cache;
	nl_cache = ht;
	memset((char *)ht->tab, 0, nht*sizeof(hashentry *));
	vd = nl->vars;
	vde = vd + nv;
	while(vd < vde) {
		v = *vd++;
		if (!hash(ht, v->name)) {
			he->next = *zot;
			*zot = he;
			he->name = v->name;
			he->vd = v;
			he++;
			}
		}
	return ht;
d129 3
d135 12
a146 14
 static VOID
nl_init(Void) {
	register char *s;
	register int c;

	for(s = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; c = *s++; )
		Alpha[c]
		= Alphanum[c]
		= Alpha[c + 'a' - 'A']
		= Alphanum[c + 'a' - 'A']
		= c;
	for(s = "0123456789_"; c = *s++; )
		Alphanum[c] = c;
	}
d151 2
a152 6
 static int
#ifdef KR_headers
getname(s, slen) register char *s; int slen;
#else
getname(register char *s, int slen)
#endif
d154 2
a155 2
	register char *se = s + slen - 1;
	register int ch;
d157 16
a172 15
	GETC(ch);
	if (!(*s++ = Alpha[ch & 0xff])) {
		if (ch != EOF)
			ch = 115;
		errfl(f__elist->cierr, ch, "namelist read");
		}
	while(*s = Alphanum[GETC(ch) & 0xff])
		if (s < se)
			s++;
	if (ch == EOF)
		err(f__elist->cierr, EOF, "namelist read");
	if (ch > ' ')
		Ungetc(ch,f__cf);
	return *s = 0;
	}
d174 2
a175 6
 static int
#ifdef KR_headers
getnum(chp, val) int *chp; ftnlen *val;
#else
getnum(int *chp, ftnlen *val)
#endif
d177 2
a178 2
	register int ch, sign;
	register ftnlen x;
d180 25
a204 23
	while(GETC(ch) <= ' ' && ch >= 0);
	if (ch == '-') {
		sign = 1;
		GETC(ch);
		}
	else {
		sign = 0;
		if (ch == '+')
			GETC(ch);
		}
	x = ch - '0';
	if (x < 0 || x > 9)
		return 115;
	while(GETC(ch) >= '0' && ch <= '9')
		x = 10*x + ch - '0';
	while(ch <= ' ' && ch >= 0)
		GETC(ch);
	if (ch == EOF)
		return EOF;
	*val = sign ? -x : x;
	*chp = ch;
	return 0;
	}
d206 2
a207 7
 static int
#ifdef KR_headers
getdimen(chp, d, delta, extent, x1)
 int *chp; dimen *d; ftnlen delta, extent, *x1;
#else
getdimen(int *chp, dimen *d, ftnlen delta, ftnlen extent, ftnlen *x1)
#endif
d209 2
a210 2
	register int k;
	ftnlen x2, x3;
d212 16
a227 25
	if (k = getnum(chp, x1))
		return k;
	x3 = 1;
	if (*chp == ':') {
		if (k = getnum(chp, &x2))
			return k;
		x2 -= *x1;
		if (*chp == ':') {
			if (k = getnum(chp, &x3))
				return k;
			if (!x3)
				return 123;
			x2 /= x3;
			colonseen = 1;
			}
		if (x2 < 0 || x2 >= extent)
			return 123;
		d->extent = x2 + 1;
		}
	else
		d->extent = 1;
	d->curval = 0;
	d->delta = delta;
	d->stride = x3;
	return 0;
d229 11
d242 2
a243 6
 static Void
#ifdef KR_headers
print_ne(a) cilist *a;
#else
print_ne(cilist *a)
#endif
d245 16
a260 16
	flag intext = f__external;
	int rpsave = f__recpos;
	FILE *cfsave = f__cf;
	unit *usave = f__curunit;
	cilist t;
	t = *a;
	t.ciunit = 6;
	s_wsne(&t);
	fflush(f__cf);
	f__external = intext;
	f__reading = 1;
	f__recpos = rpsave;
	f__cf = cfsave;
	f__curunit = usave;
	f__elist = a;
	}
d263 1
a263 1
 static char where0[] = "namelist read start ";
d265 2
a266 5
#ifdef KR_headers
x_rsne(a) cilist *a;
#else
x_rsne(cilist *a)
#endif
d268 29
a296 27
	int ch, got1, k, n, nd, quote, readall;
	Namelist *nl;
	static char where[] = "namelist read";
	char buf[64];
	hashtab *ht;
	Vardesc *v;
	dimen *dn, *dn0, *dn1;
	ftnlen *dims, *dims1;
	ftnlen b, b0, b1, ex, no, nomax, size, span;
	ftnint no1, type;
	char *vaddr;
	long iva, ivae;
	dimen dimens[MAXDIM], substr;

	if (!Alpha['a'])
		nl_init();
	f__reading=1;
	f__formatted=1;
	got1 = 0;
 top:
	for(;;) switch(GETC(ch)) {
		case EOF:
 eof:
			err(a->ciend,(EOF),where0);
		case '&':
		case '$':
			goto have_amp;
d298 7
a304 7
		case '?':
			print_ne(a);
			continue;
#endif
		default:
			if (ch <= ' ' && ch >= 0)
				continue;
d306 12
a317 12
			while(GETC(ch) != '\n')
				if (ch == EOF)
					goto eof;
#else
			errfl(a->cierr, 115, where0);
#endif
		}
 have_amp:
	if (ch = getname(buf,sizeof(buf)))
		return ch;
	nl = (Namelist *)a->cifmt;
	if (strcmp(buf, nl->name))
d319 1
a319 1
		errfl(a->cierr, 118, where0);
d321 166
d488 36
a523 28
		fprintf(stderr,
			"Skipping namelist \"%s\": seeking namelist \"%s\".\n",
			buf, nl->name);
		fflush(stderr);
		for(;;) switch(GETC(ch)) {
			case EOF:
				err(a->ciend, EOF, where0);
			case '/':
			case '&':
			case '$':
				if (f__external)
					e_rsle();
				else
					z_rnew();
				goto top;
			case '"':
			case '\'':
				quote = ch;
 more_quoted:
				while(GETC(ch) != quote)
					if (ch == EOF)
						err(a->ciend, EOF, where0);
				if (GETC(ch) == quote)
					goto more_quoted;
				Ungetc(ch,f__cf);
			default:
				continue;
			}
d525 46
a570 202
#endif
	ht = mk_hashtab(nl);
	if (!ht)
		errfl(f__elist->cierr, 113, where0);
	for(;;) {
		for(;;) switch(GETC(ch)) {
			case EOF:
				if (got1)
					return 0;
				err(a->ciend, EOF, where0);
			case '/':
			case '$':
			case '&':
				return 0;
			default:
				if (ch <= ' ' && ch >= 0 || ch == ',')
					continue;
				Ungetc(ch,f__cf);
				if (ch = getname(buf,sizeof(buf)))
					return ch;
				goto havename;
			}
 havename:
		v = hash(ht,buf);
		if (!v)
			errfl(a->cierr, 119, where);
		while(GETC(ch) <= ' ' && ch >= 0);
		vaddr = v->addr;
		type = v->type;
		if (type < 0) {
			size = -type;
			type = TYCHAR;
			}
		else
			size = f__typesize[type];
		ivae = size;
		iva = readall = 0;
		if (ch == '(' /*)*/ ) {
			dn = dimens;
			if (!(dims = v->dims)) {
				if (type != TYCHAR)
					errfl(a->cierr, 122, where);
				if (k = getdimen(&ch, dn, (ftnlen)size,
						(ftnlen)size, &b))
					errfl(a->cierr, k, where);
				if (ch != ')')
					errfl(a->cierr, 115, where);
				b1 = dn->extent;
				if (--b < 0 || b + b1 > size)
					return 124;
				iva += b;
				size = b1;
				while(GETC(ch) <= ' ' && ch >= 0);
				goto scalar;
				}
			nd = (int)dims[0];
			nomax = span = dims[1];
			ivae = iva + size*nomax;
			colonseen = 0;
			if (k = getdimen(&ch, dn, size, nomax, &b))
				errfl(a->cierr, k, where);
			no = dn->extent;
			b0 = dims[2];
			dims1 = dims += 3;
			ex = 1;
			for(n = 1; n++ < nd; dims++) {
				if (ch != ',')
					errfl(a->cierr, 115, where);
				dn1 = dn + 1;
				span /= *dims;
				if (k = getdimen(&ch, dn1, dn->delta**dims,
						span, &b1))
					errfl(a->cierr, k, where);
				ex *= *dims;
				b += b1*ex;
				no *= dn1->extent;
				dn = dn1;
				}
			if (ch != ')')
				errfl(a->cierr, 115, where);
			readall = 1 - colonseen;
			b -= b0;
			if (b < 0 || b >= nomax)
				errfl(a->cierr, 125, where);
			iva += size * b;
			dims = dims1;
			while(GETC(ch) <= ' ' && ch >= 0);
			no1 = 1;
			dn0 = dimens;
			if (type == TYCHAR && ch == '(' /*)*/) {
				if (k = getdimen(&ch, &substr, size, size, &b))
					errfl(a->cierr, k, where);
				if (ch != ')')
					errfl(a->cierr, 115, where);
				b1 = substr.extent;
				if (--b < 0 || b + b1 > size)
					return 124;
				iva += b;
				b0 = size;
				size = b1;
				while(GETC(ch) <= ' ' && ch >= 0);
				if (b1 < b0)
					goto delta_adj;
				}
			if (readall)
				goto delta_adj;
			for(; dn0 < dn; dn0++) {
				if (dn0->extent != *dims++ || dn0->stride != 1)
					break;
				no1 *= dn0->extent;
				}
			if (dn0 == dimens && dimens[0].stride == 1) {
				no1 = dimens[0].extent;
				dn0++;
				}
 delta_adj:
			ex = 0;
			for(dn1 = dn0; dn1 <= dn; dn1++)
				ex += (dn1->extent-1)
					* (dn1->delta *= dn1->stride);
			for(dn1 = dn; dn1 > dn0; dn1--) {
				ex -= (dn1->extent - 1) * dn1->delta;
				dn1->delta -= ex;
				}
			}
		else if (dims = v->dims) {
			no = no1 = dims[1];
			ivae = iva + no*size;
			}
		else
 scalar:
			no = no1 = 1;
		if (ch != '=')
			errfl(a->cierr, 115, where);
		got1 = nml_read = 1;
		f__lcount = 0;
	 readloop:
		for(;;) {
			if (iva >= ivae || iva < 0) {
				f__lquit = 1;
				goto mustend;
				}
			else if (iva + no1*size > ivae)
				no1 = (ivae - iva)/size;
			f__lquit = 0;
			if (k = l_read(&no1, vaddr + iva, size, type))
				return k;
			if (f__lquit == 1)
				return 0;
			if (readall) {
				iva += dn0->delta;
				if (f__lcount > 0) {
					no1 = (ivae - iva)/size;
					if (no1 > f__lcount)
						no1 = f__lcount;
					if (k = l_read(&no1, vaddr + iva,
							size, type))
						return k;
					iva += no1 * dn0->delta;
					}
				}
 mustend:
			GETC(ch);
			if (readall)
				if (iva >= ivae)
					readall = 0;
				else for(;;) {
					switch(ch) {
						case ' ':
						case '\t':
						case '\n':
							GETC(ch);
							continue;
						}
					break;
					}
			if (ch == '/' || ch == '$' || ch == '&') {
				f__lquit = 1;
				return 0;
				}
			else if (f__lquit) {
				while(ch <= ' ' && ch >= 0)
					GETC(ch);
				Ungetc(ch,f__cf);
				if (!Alpha[ch & 0xff] && ch >= 0)
					errfl(a->cierr, 125, where);
				break;
				}
			Ungetc(ch,f__cf);
			if (readall && !Alpha[ch & 0xff])
				goto readloop;
			if ((no -= no1) <= 0)
				break;
			for(dn1 = dn0; dn1 <= dn; dn1++) {
				if (++dn1->curval < dn1->extent) {
					iva += dn1->delta;
					goto readloop;
					}
				dn1->curval = 0;
				}
			break;
			}
d572 3
d576 2
d579 2
a580 6
 integer
#ifdef KR_headers
s_rsne(a) cilist *a;
#else
s_rsne(cilist *a)
#endif
d582 2
a583 2
	extern int l_eof;
	int n;
d585 15
a599 15
	f__external=1;
	l_eof = 0;
	if(n = c_le(a))
		return n;
	if(f__curunit->uwrt && f__nowreading(f__curunit))
		err(a->cierr,errno,where0);
	l_getc = t_getc;
	l_ungetc = un_getc;
	f__doend = xrd_SL;
	n = x_rsne(a);
	nml_read = 0;
	if (n)
		return n;
	return e_rsle();
	}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of libf2c from gcc3.3.2
@
text
@@


1.1.1.2
log
@gcc 3.3.5 update
@
text
@d6 2
a7 2
#define MAX_NL_CACHE 3		/* maximum number of namelist hash tables to cache */
#define MAXDIM 20		/* maximum number of subscripts */
d9 32
a40 8
struct dimen
{
  ftnlen extent;
  ftnlen curval;
  ftnlen delta;
  ftnlen stride;
};
typedef struct dimen dimen;
d42 2
a43 7
struct hashentry
{
  struct hashentry *next;
  char *name;
  Vardesc *vd;
};
typedef struct hashentry hashentry;
d45 8
a52 18
struct hashtab
{
  struct hashtab *next;
  Namelist *nl;
  int htsize;
  hashentry *tab[1];
};
typedef struct hashtab hashtab;

static hashtab *nl_cache;
static int n_nlcache;
static hashentry **zot;
static int colonseen;
extern ftnlen f__typesize[];

extern flag f__lquit;
extern int f__lcount, nml_read;
extern int t_getc (void);
d54 1
d62 3
a64 5
static int
un_getc (int x, FILE * f__cf)
{
  return ungetc (x, f__cf);
}
d67 2
a68 1
extern int ungetc (int, FILE *);	/* for systems with a buggy stdio.h */
d71 6
a76 2
static Vardesc *
hash (hashtab * ht, register char *s)
d78 11
a88 11
  register int c, x;
  register hashentry *h;
  char *s0 = s;

  for (x = 0; (c = *s++); x = x & 0x4000 ? ((x << 1) & 0x7fff) + 1 : x << 1)
    x += c;
  for (h = *(zot = ht->tab + x % ht->htsize); h; h = h->next)
    if (!strcmp (s0, h->name))
      return h->vd;
  return 0;
}
d90 6
a95 2
hashtab *
mk_hashtab (Namelist * nl)
d97 47
a143 48
  int nht, nv;
  hashtab *ht;
  Vardesc *v, **vd, **vde;
  hashentry *he;

  hashtab **x, **x0, *y;
  for (x = &nl_cache; (y = *x); x0 = x, x = &y->next)
    if (nl == y->nl)
      return y;
  if (n_nlcache >= MAX_NL_CACHE)
    {
      /* discard least recently used namelist hash table */
      y = *x0;
      free ((char *) y->next);
      y->next = 0;
    }
  else
    n_nlcache++;
  nv = nl->nvars;
  if (nv >= 0x4000)
    nht = 0x7fff;
  else
    {
      for (nht = 1; nht < nv; nht <<= 1);
      nht += nht - 1;
    }
  ht = (hashtab *) malloc (sizeof (hashtab) + (nht - 1) * sizeof (hashentry *)
			   + nv * sizeof (hashentry));
  if (!ht)
    return 0;
  he = (hashentry *) & ht->tab[nht];
  ht->nl = nl;
  ht->htsize = nht;
  ht->next = nl_cache;
  nl_cache = ht;
  memset ((char *) ht->tab, 0, nht * sizeof (hashentry *));
  vd = nl->vars;
  vde = vd + nv;
  while (vd < vde)
    {
      v = *vd++;
      if (!hash (ht, v->name))
	{
	  he->next = *zot;
	  *zot = he;
	  he->name = v->name;
	  he->vd = v;
	  he++;
a144 3
    }
  return ht;
}
d148 14
a161 12
static void
nl_init (void)
{
  register char *s;
  register int c;

  for (s = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; (c = *s++);)
    Alpha[c]
      = Alphanum[c] = Alpha[c + 'a' - 'A'] = Alphanum[c + 'a' - 'A'] = c;
  for (s = "0123456789_"; (c = *s++);)
    Alphanum[c] = c;
}
d166 6
a171 2
static int
getname (register char *s, int slen)
d173 2
a174 2
  register char *se = s + slen - 1;
  register int ch;
d176 15
a190 16
  GETC (ch);
  if (!(*s++ = Alpha[ch & 0xff]))
    {
      if (ch != EOF)
	ch = 115;
      errfl (f__elist->cierr, ch, "namelist read");
    }
  while ((*s = Alphanum[GETC (ch) & 0xff]))
    if (s < se)
      s++;
  if (ch == EOF)
    err (f__elist->cierr, EOF, "namelist read");
  if (ch > ' ')
    Ungetc (ch, f__cf);
  return *s = 0;
}
d192 6
a197 2
static int
getnum (int *chp, ftnlen * val)
d199 2
a200 2
  register int ch, sign;
  register ftnlen x;
d202 23
a224 25
  while (GETC (ch) <= ' ' && ch >= 0);
  if (ch == '-')
    {
      sign = 1;
      GETC (ch);
    }
  else
    {
      sign = 0;
      if (ch == '+')
	GETC (ch);
    }
  x = ch - '0';
  if (x < 0 || x > 9)
    return 115;
  while (GETC (ch) >= '0' && ch <= '9')
    x = 10 * x + ch - '0';
  while (ch <= ' ' && ch >= 0)
    GETC (ch);
  if (ch == EOF)
    return EOF;
  *val = sign ? -x : x;
  *chp = ch;
  return 0;
}
d226 7
a232 2
static int
getdimen (int *chp, dimen * d, ftnlen delta, ftnlen extent, ftnlen * x1)
d234 2
a235 2
  register int k;
  ftnlen x2, x3;
d237 25
a261 16
  if ((k = getnum (chp, x1)))
    return k;
  x3 = 1;
  if (*chp == ':')
    {
      if ((k = getnum (chp, &x2)))
	return k;
      x2 -= *x1;
      if (*chp == ':')
	{
	  if ((k = getnum (chp, &x3)))
	    return k;
	  if (!x3)
	    return 123;
	  x2 /= x3;
	  colonseen = 1;
a262 11
      if (x2 < 0 || x2 >= extent)
	return 123;
      d->extent = x2 + 1;
    }
  else
    d->extent = 1;
  d->curval = 0;
  d->delta = delta;
  d->stride = x3;
  return 0;
}
d265 6
a270 2
static void
print_ne (cilist * a)
d272 16
a287 16
  flag intext = f__external;
  int rpsave = f__recpos;
  FILE *cfsave = f__cf;
  unit *usave = f__curunit;
  cilist t;
  t = *a;
  t.ciunit = 6;
  s_wsne (&t);
  fflush (f__cf);
  f__external = intext;
  f__reading = 1;
  f__recpos = rpsave;
  f__cf = cfsave;
  f__curunit = usave;
  f__elist = a;
}
d290 1
a290 1
static char where0[] = "namelist read start ";
d292 5
a296 2
int
x_rsne (cilist * a)
d298 27
a324 29
  int ch, got1, k, n, nd, quote, readall;
  Namelist *nl;
  static char where[] = "namelist read";
  char buf[64];
  hashtab *ht;
  Vardesc *v;
  dimen *dn, *dn0, *dn1;
  ftnlen *dims, *dims1;
  ftnlen b, b0, b1, ex, no, nomax, size, span;
  ftnint no1, type;
  char *vaddr;
  long iva, ivae;
  dimen dimens[MAXDIM], substr;

  if (!Alpha['a'])
    nl_init ();
  f__reading = 1;
  f__formatted = 1;
  got1 = 0;
top:
  for (;;)
    switch (GETC (ch))
      {
      case EOF:
      eof:
	err (a->ciend, (EOF), where0);
      case '&':
      case '$':
	goto have_amp;
d326 7
a332 7
      case '?':
	print_ne (a);
	continue;
#endif
      default:
	if (ch <= ' ' && ch >= 0)
	  continue;
d334 12
a345 12
	while (GETC (ch) != '\n')
	  if (ch == EOF)
	    goto eof;
#else
	errfl (a->cierr, 115, where0);
#endif
      }
have_amp:
  if ((ch = getname (buf, sizeof (buf))))
    return ch;
  nl = (Namelist *) a->cifmt;
  if (strcmp (buf, nl->name))
d347 1
a347 1
    errfl (a->cierr, 118, where0);
a348 166
    {
      fprintf (stderr,
	       "Skipping namelist \"%s\": seeking namelist \"%s\".\n",
	       buf, nl->name);
      fflush (stderr);
      for (;;)
	switch (GETC (ch))
	  {
	  case EOF:
	    err (a->ciend, EOF, where0);
	  case '/':
	  case '&':
	  case '$':
	    if (f__external)
	      e_rsle ();
	    else
	      z_rnew ();
	    goto top;
	  case '"':
	  case '\'':
	    quote = ch;
	  more_quoted:
	    while (GETC (ch) != quote)
	      if (ch == EOF)
		err (a->ciend, EOF, where0);
	    if (GETC (ch) == quote)
	      goto more_quoted;
	    Ungetc (ch, f__cf);
	  default:
	    continue;
	  }
    }
#endif
  ht = mk_hashtab (nl);
  if (!ht)
    errfl (f__elist->cierr, 113, where0);
  for (;;)
    {
      for (;;)
	switch (GETC (ch))
	  {
	  case EOF:
	    if (got1)
	      return 0;
	    err (a->ciend, EOF, where0);
	  case '/':
	  case '$':
	  case '&':
	    return 0;
	  default:
	    if ((ch <= ' ' && ch >= 0) || ch == ',')
	      continue;
	    Ungetc (ch, f__cf);
	    if ((ch = getname (buf, sizeof (buf))))
	      return ch;
	    goto havename;
	  }
    havename:
      v = hash (ht, buf);
      if (!v)
	errfl (a->cierr, 119, where);
      while (GETC (ch) <= ' ' && ch >= 0);
      vaddr = v->addr;
      type = v->type;
      if (type < 0)
	{
	  size = -type;
	  type = TYCHAR;
	}
      else
	size = f__typesize[type];
      ivae = size;
      iva = readall = 0;
      if (ch == '(' /*) */ )
	{
	  dn = dimens;
	  if (!(dims = v->dims))
	    {
	      if (type != TYCHAR)
		errfl (a->cierr, 122, where);
	      if ((k = getdimen (&ch, dn, (ftnlen) size, (ftnlen) size, &b)))
		errfl (a->cierr, k, where);
	      if (ch != ')')
		errfl (a->cierr, 115, where);
	      b1 = dn->extent;
	      if (--b < 0 || b + b1 > size)
		return 124;
	      iva += b;
	      size = b1;
	      while (GETC (ch) <= ' ' && ch >= 0);
	      goto scalar;
	    }
	  nd = (int) dims[0];
	  nomax = span = dims[1];
	  ivae = iva + size * nomax;
	  colonseen = 0;
	  if ((k = getdimen (&ch, dn, size, nomax, &b)))
	    errfl (a->cierr, k, where);
	  no = dn->extent;
	  b0 = dims[2];
	  dims1 = dims += 3;
	  ex = 1;
	  for (n = 1; n++ < nd; dims++)
	    {
	      if (ch != ',')
		errfl (a->cierr, 115, where);
	      dn1 = dn + 1;
	      span /= *dims;
	      if ((k = getdimen (&ch, dn1, dn->delta ** dims, span, &b1)))
		errfl (a->cierr, k, where);
	      ex *= *dims;
	      b += b1 * ex;
	      no *= dn1->extent;
	      dn = dn1;
	    }
	  if (ch != ')')
	    errfl (a->cierr, 115, where);
	  readall = 1 - colonseen;
	  b -= b0;
	  if (b < 0 || b >= nomax)
	    errfl (a->cierr, 125, where);
	  iva += size * b;
	  dims = dims1;
	  while (GETC (ch) <= ' ' && ch >= 0);
	  no1 = 1;
	  dn0 = dimens;
	  if (type == TYCHAR && ch == '(' /*) */ )
	    {
	      if ((k = getdimen (&ch, &substr, size, size, &b)))
		errfl (a->cierr, k, where);
	      if (ch != ')')
		errfl (a->cierr, 115, where);
	      b1 = substr.extent;
	      if (--b < 0 || b + b1 > size)
		return 124;
	      iva += b;
	      b0 = size;
	      size = b1;
	      while (GETC (ch) <= ' ' && ch >= 0);
	      if (b1 < b0)
		goto delta_adj;
	    }
	  if (readall)
	    goto delta_adj;
	  for (; dn0 < dn; dn0++)
	    {
	      if (dn0->extent != *dims++ || dn0->stride != 1)
		break;
	      no1 *= dn0->extent;
	    }
	  if (dn0 == dimens && dimens[0].stride == 1)
	    {
	      no1 = dimens[0].extent;
	      dn0++;
	    }
	delta_adj:
	  ex = 0;
	  for (dn1 = dn0; dn1 <= dn; dn1++)
	    ex += (dn1->extent - 1) * (dn1->delta *= dn1->stride);
	  for (dn1 = dn; dn1 > dn0; dn1--)
	    {
	      ex -= (dn1->extent - 1) * dn1->delta;
	      dn1->delta -= ex;
	    }
	}
      else if ((dims = v->dims))
d350 28
a377 36
	  no = no1 = dims[1];
	  ivae = iva + no * size;
	}
      else
      scalar:
	no = no1 = 1;
      if (ch != '=')
	errfl (a->cierr, 115, where);
      got1 = nml_read = 1;
      f__lcount = 0;
    readloop:
      for (;;)
	{
	  if (iva >= ivae || iva < 0)
	    {
	      f__lquit = 1;
	      goto mustend;
	    }
	  else if (iva + no1 * size > ivae)
	    no1 = (ivae - iva) / size;
	  f__lquit = 0;
	  if ((k = l_read (&no1, vaddr + iva, size, type)))
	    return k;
	  if (f__lquit == 1)
	    return 0;
	  if (readall)
	    {
	      iva += dn0->delta;
	      if (f__lcount > 0)
		{
		  ftnint no2 = (ivae - iva) / size;
		  if (no2 > f__lcount)
		    no2 = f__lcount;
		  if ((k = l_read (&no2, vaddr + iva, size, type)))
		    return k;
		  iva += no2 * dn0->delta;
d379 202
a580 46
	    }
	mustend:
	  GETC (ch);
	  if (readall)
	    {
	      if (iva >= ivae)
		readall = 0;
	      else
		for (;;)
		  {
		    switch (ch)
		      {
		      case ' ':
		      case '\t':
		      case '\n':
			GETC (ch);
			continue;
		      }
		    break;
		  }
	    }
	  if (ch == '/' || ch == '$' || ch == '&')
	    {
	      f__lquit = 1;
	      return 0;
	    }
	  else if (f__lquit)
	    {
	      while (ch <= ' ' && ch >= 0)
		GETC (ch);
	      Ungetc (ch, f__cf);
	      if (!Alpha[ch & 0xff] && ch >= 0)
		errfl (a->cierr, 125, where);
	      break;
	    }
	  Ungetc (ch, f__cf);
	  if (readall && !Alpha[ch & 0xff])
	    goto readloop;
	  if ((no -= no1) <= 0)
	    break;
	  for (dn1 = dn0; dn1 <= dn; dn1++)
	    {
	      if (++dn1->curval < dn1->extent)
		{
		  iva += dn1->delta;
		  goto readloop;
a581 3
	      dn1->curval = 0;
	    }
	  break;
a582 2
    }
}
d584 6
a589 2
integer
s_rsne (cilist * a)
d591 2
a592 2
  extern int l_eof;
  int n;
d594 15
a608 15
  f__external = 1;
  l_eof = 0;
  if ((n = c_le (a)))
    return n;
  if (f__curunit->uwrt && f__nowreading (f__curunit))
    err (a->cierr, errno, where0);
  l_getc = t_getc;
  l_ungetc = un_getc;
  f__doend = xrd_SL;
  n = x_rsne (a);
  nml_read = 0;
  if (n)
    return n;
  return e_rsle ();
}
@

