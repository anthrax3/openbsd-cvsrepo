head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.1.0.56
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.52
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.48
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.50
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.42
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.46
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.44
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.40
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.38
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.36
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.34
	OPENBSD_5_0:1.1.1.1.0.32
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.30
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.28
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.24
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.26
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.22
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.20
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.18
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.16
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.14
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.12
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	gcc-3_3_5:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2004.01.05.15.43.49;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.01.05.15.43.49;	author espie;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@
The approach I've been using for a given header is to recursively do each
of the "bits" headers which make up the standard header.  So, e.g., while
there are four headers making up <algorithm>, three of them were already
documented in the course of doing other headers.

"Untouched" means I've deliberately skipped it for various reasons, or
haven't gotten to it yet.  It /will/ be done (by somebody, eventually.)

If you document an area and need to skip (for whatever reason) a non-trivial
entity (i.e., one that should be documented), go ahead and add the comment
markup, and use the homegrown @@doctodo tag.  See include/bits/stl_iterator.h
for examples of this.  Doing so will at least cause doxygen to consider the
entitiy as documented and include it in the output.  It will also add the
entity to the generated TODO page.


 Area           Still needs to be doxygen-documented
-----------------------------------------------------------

c17             FINISHED (Nothing in Clause 17 "exists" in terms of code.)
c18             FINISHED, Note A
c19             Note A
c20             Note A
c21             Untouched (top-level class note for basic_string done),
                Note B
c22             Untouched; see docs/html/22_locale/*
c23             See doxygroups.cc and Note B.  Notes on what invalidates
                iterators need to be added.  std::list-specific memfns need
                to be filled out.
c24             stl_iterator.h (__normal_iterator, other small TODO bits)
                stream iterators
c25             stl_algo.h (lots of stuff)
c26             <complex>, <valarray>, stl_numeric.h[26.4], Note A
c27             ios_base callbacks and local storage
                basic_ios::copyfmt()
                std_streambuf.h's __copy_streambufs()
                    " "           _M_* protected memfns (data has been done)
                fstream and sstream protected members

backward/*      Not scanned by doxygen.  Should it be?  Doubtful.

ext/*           Some of the SGI algorithm/functional extensions.
                All of rope/hashing/slist need docs.

__gnu_cxx       Tricky.  Right now ext/* are in this namespace.

-----------------------------------------------------------

NOTES:

A)  So far I have not tried to document any of the <c*> headers.  So entities
such as atexit() are undocumented throughout the library.  Since we usually
do not have the C code (to which the doxygen comments would be attached),
this would need to be done in entirely separate files, a la doxygroups.cc.

B)  Huge chunks of containers and strings are described in common "Tables"
in the standard.  These are pseudo-duplicated in tables.html.  We can
use doxygen hooks like @@pre and @@see to reference the tables.  Then the
individual classes do like the standard does, and only document members for
which additional info is available.


STYLE:
stl_deque.h, stl_pair.h, and stl_algobase.h have good examples of what I've
been using for class, namespace-scope, and function documentation, respectively.
These should serve as starting points.  /Please/ maintain the inter-word and
inter-sentence spacing, as this might be generated and/or scanned in the
future.


vim:ts=4:et:
@


1.1.1.1
log
@standard C++ library for gcc 3.x
@
text
@@
