head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.54
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.52
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.48
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.50
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.42
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.46
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.44
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.40
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.38
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.36
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.34
	OPENBSD_5_0:1.2.0.32
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.30
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.28
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.24
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.26
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.22
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.20
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.18
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.16
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.14
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.12
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.10
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.8
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.6
	OPENBSD_3_7_BASE:1.2
	gcc-3_3_5:1.1.1.1
	OPENBSD_3_6:1.2.0.4
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@// @;


1.2
date	2004.01.31.20.50.28;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.05.15.46.30;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.01.05.15.46.30;	author espie;	state Exp;
branches;
next	;


desc
@@


1.2
log
@fix a few #if MACRO -> #if defined(MACRO) (-Wsystem-headers clean-up)
naddy, sturm, brad: tests, comments, fixes... thanks.
@
text
@// 1999-06-03 bkoz

// Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
// USA.

// 21.1.1 Characher traits requirements

#include <string>
#include <testsuite_hooks.h>

int test01(void)
{
  bool test = true;
  const std::string str_01("zuma beach");
  const std::string str_02("montara and ocean beach");

  // 21.1.1 character traits requirements

  // Key for decoding what function signatures really mean:
  // X 		== char_traits<_CharT>
  // [c,d] 	== _CharT
  // [p,q] 	== const _CharT*
  // s 		== _CharT*
  // [n,i,j] 	== size_t
  // f 		== X::int_type
  // pos 	== X::pos_type
  // state 	== X::state_type

  // void X::assign(char c, char d)
  // assigns c = d;
  char c1 = 'z';
  char c2 = 'u';
  VERIFY( c1 != c2 );
  std::char_traits<char>::assign(c1,c2);
  VERIFY( c1 == 'u' );

  // char* X::move(char* s, const char* p, size_t n)
  // for each i in [0,n) performs X::assign(s[i], p[i]). Copies
  // correctly even where p is in [s, s + n), and yields s.
  char array1[] = {'z', 'u', 'm', 'a', ' ', 'b', 'e', 'a', 'c', 'h',  0};
  const char str_lit1[] = "montara and ocean beach";
  int len = sizeof(str_lit1) + sizeof(array1) - 1; // two terminating chars
  char array2[len];

  VERIFY( str_lit1[0] == 'm' );
  c1 = array2[0];
  c2 = str_lit1[0];
  char c3 = array2[1];
  char c4 = str_lit1[1];
  std::char_traits<char>::move(array2, str_lit1, 0);
  VERIFY( array2[0] == c1 );
  VERIFY( str_lit1[0] == c2 );
  std::char_traits<char>::move(array2, str_lit1, 1);
  VERIFY( array2[0] == c2 );
  VERIFY( str_lit1[0] == c2 );
  VERIFY( array2[1] == c3 );
  VERIFY( str_lit1[1] == c4 );
  std::char_traits<char>::move(array2, str_lit1, 2);
  VERIFY( array2[0] == c2 );
  VERIFY( str_lit1[0] == c2 );
  VERIFY( array2[1] == c4 );
  VERIFY( str_lit1[1] == c4 );

  char* pc1 = array1 + 1;
  c1 = pc1[0];
  c2 = array1[0];
  VERIFY( c1 != c2 );
  char* pc2 = std::char_traits<char>::move(array1, pc1, 0);
  c3 = pc1[0];
  c4 = array1[0];
  VERIFY( c1 == c3 );
  VERIFY( c2 == c4 );
  VERIFY( pc2 == array1 );

  c1 = pc1[0];
  c2 = array1[0];
  char* pc3 = pc1;
  pc2 = std::char_traits<char>::move(array1, pc1, 10);
  c3 = pc1[0];
  c4 = array1[0];
  VERIFY( c1 != c3 ); // underlying char array changed.
  VERIFY( c4 != c3 );
  VERIFY( pc2 == array1 );
  VERIFY( pc3 == pc1 ); // but pointers o-tay
  c1 = *(str_01.data());
  c2 = array1[0];
  VERIFY( c1 != c2 );

#ifdef DEBUG_ASSERT
  assert(test);
#endif
  return test;
}

#if defined(_GLIBCPP_USE_WCHAR_T)
int test02(void)
{
  bool test = true;
  const std::wstring str_01(L"zuma beach");
  const std::wstring str_02(L"montara and ocean beach");
 
  // 21.1.1 character traits requirements

  // Key for decoding what function signatures really mean:
  // X                == char_traits<_CharT>
  // [c,d]    == _CharT
  // [p,q]    == const _CharT*
  // s                == _CharT*
  // [n,i,j]  == size_t
  // f                == X::int_type
  // pos      == X::pos_type
  // state    == X::state_type

  // void X::assign(wchar_t c, wchar_t d)
  // assigns c = d;
  wchar_t c1 = L'z';
  wchar_t c2 = L'u';
  VERIFY( c1 != c2 );
  std::char_traits<wchar_t>::assign(c1,c2);
  VERIFY( c1 == L'u' );

  // char* X::move(char* s, const char* p, size_t n)
  // for each i in [0,n) performs X::assign(s[i], p[i]). Copies
  // correctly even where p is in [s, s + n), and yields s.   
  wchar_t array1[] = {L'z', L'u', L'm', L'a', L' ', L'b', L'e', L'a', L'c', L'h',  0};
  const wchar_t str_lit1[] = L"montara and ocean beach";
  int len = sizeof(str_lit1) + sizeof(array1) - 1; // two terminating chars
  wchar_t array2[len];

  VERIFY( str_lit1[0] == 'm' );
  c1 = array2[0];
  c2 = str_lit1[0];
  wchar_t c3 = array2[1];
  wchar_t c4 = str_lit1[1];
  std::char_traits<wchar_t>::move(array2, str_lit1, 0);
  VERIFY( array2[0] == c1 );
  VERIFY( str_lit1[0] == c2 );
  std::char_traits<wchar_t>::move(array2, str_lit1, 1);
  VERIFY( array2[0] == c2 );
  VERIFY( str_lit1[0] == c2 );
  VERIFY( array2[1] == c3 );
  VERIFY( str_lit1[1] == c4 );
  std::char_traits<wchar_t>::move(array2, str_lit1, 2);
  VERIFY( array2[0] == c2 );
  VERIFY( str_lit1[0] == c2 );
  VERIFY( array2[1] == c4 );
  VERIFY( str_lit1[1] == c4 );
 
  wchar_t* pc1 = array1 + 1;
  c1 = pc1[0];
  c2 = array1[0];
  VERIFY( c1 != c2 );
  wchar_t* pc2 = std::char_traits<wchar_t>::move(array1, pc1, 0);
  c3 = pc1[0];
  c4 = array1[0];
  VERIFY( c1 == c3 );
  VERIFY( c2 == c4 );
  VERIFY( pc2 == array1 );

  c1 = pc1[0];
  c2 = array1[0];
  wchar_t* pc3 = pc1;
  pc2 = std::char_traits<wchar_t>::move(array1, pc1, 10);
  c3 = pc1[0];
  c4 = array1[0];
  VERIFY( c1 != c3 ); // underlying wchar_t array changed.
  VERIFY( c4 != c3 );
  VERIFY( pc2 == array1 );
  VERIFY( pc3 == pc1 ); // but pointers o-tay
  c1 = *(str_01.data());
  c2 = array1[0];
  VERIFY( c1 != c2 );
 
#ifdef DEBUG_ASSERT
  assert(test);
#endif

  return test;
}
#endif  //_GLIBCPP_USE_WCHAR_T

int main()
{ 
  test01();
#if defined(_GLIBCPP_USE_WCHAR_T)
  test02();
#endif
  return 0;
}
@


1.1
log
@Initial revision
@
text
@d110 1
a110 1
#if _GLIBCPP_USE_WCHAR_T
d200 1
a200 1
#if _GLIBCPP_USE_WCHAR_T
@


1.1.1.1
log
@standard C++ library for gcc 3.x
@
text
@@
