head	1.2;
access;
symbols
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.46
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.42
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.44
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.36
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.40
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.38
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.34
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.32
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.30
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.28
	OPENBSD_5_0:1.2.0.26
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.24
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.22
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.18
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.20
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.16
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.14
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.12
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.10
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.8
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.6
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.4
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.1.1.2.0.2
	OPENBSD_3_7_BASE:1.1.1.2
	gcc-3_3_5:1.1.1.2
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2005.06.17.20.40.31;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.05.15.45.20;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.01.05.15.45.20;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.24.22.41.59;	author espie;	state Exp;
branches;
next	;


desc
@@


1.2
log
@
next citrus step.

reviewed by millert, otto, kevlo, naddy, kettenis...
libc+libstdc++ bump
@
text
@// ostream classes -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
// USA.

// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.

//
// ISO C++ 14882: 27.6.2  Output streams
//

#pragma GCC system_header

#include <locale>

namespace std 
{
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_os(__os)
    {
      // XXX MT
      if (__os.tie() && __os.good())
	__os.tie()->flush();

      if (__os.good())
	_M_ok = true;
      else
	{
	  _M_ok = false;
	  __os.setstate(ios_base::failbit);
	}
    }
  
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>& 
    basic_ostream<_CharT, _Traits>::
    operator<<(__ostream_type& (*__pf)(__ostream_type&))
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 60. What is a formatted input function?
      // The inserters for manipulators are *not* formatted output functions.
      return __pf(*this);
    }
  
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>& 
    basic_ostream<_CharT, _Traits>::
    operator<<(__ios_type& (*__pf)(__ios_type&))
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 60. What is a formatted input function?
      // The inserters for manipulators are *not* formatted output functions.
      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>& 
    basic_ostream<_CharT, _Traits>::
    operator<<(ios_base& (*__pf)(ios_base&))
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 60. What is a formatted input function?
      // The inserters for manipulators are *not* formatted output functions.
      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>& 
    basic_ostream<_CharT, _Traits>::
    operator<<(bool __n)
    {
      sentry __cerb(*this);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      _M_check_facet(this->_M_fnumput);
	      const __numput_type& __np = *this->_M_fnumput;
	      if (__np.put(*this, *this, this->fill(), __n).failed())
		__err |= ios_base::badbit;
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>& 
    basic_ostream<_CharT, _Traits>::
    operator<<(long __n)
    {
      sentry __cerb(*this);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      bool __b = false;
	      char_type __c = this->fill();
	      ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
	      _M_check_facet(this->_M_fnumput);
	      const __numput_type& __np = *this->_M_fnumput;
	      if ((__fmt & ios_base::oct) || (__fmt & ios_base::hex))
		{
		  unsigned long __l = static_cast<unsigned long>(__n);
		  __b = __np.put(*this, *this, __c, __l).failed();
		}
	      else
		__b = __np.put(*this, *this, __c, __n).failed();
	      if (__b)  
		__err |= ios_base::badbit;
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>& 
    basic_ostream<_CharT, _Traits>::
    operator<<(unsigned long __n)
    {
      sentry __cerb(*this);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      _M_check_facet(this->_M_fnumput);
	      const __numput_type& __np = *this->_M_fnumput;
	      if (__np.put(*this, *this, this->fill(), __n).failed())
		__err |= ios_base::badbit;
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

#ifdef _GLIBCPP_USE_LONG_LONG
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>& 
    basic_ostream<_CharT, _Traits>::
    operator<<(long long __n)
    {
      sentry __cerb(*this);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      bool __b = false;
	      char_type __c = this->fill();
	      ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
	      _M_check_facet(this->_M_fnumput);
	      const __numput_type& __np = *this->_M_fnumput;
	      if ((__fmt & ios_base::oct) || (__fmt & ios_base::hex))
		{
		  unsigned long long __l;
		  __l = static_cast<unsigned long long>(__n);
		  __b = __np.put(*this, *this, __c, __l).failed();
		}
	      else
		__b = __np.put(*this, *this, __c, __n).failed();
	      if (__b)  
		__err |= ios_base::badbit;
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>& 
    basic_ostream<_CharT, _Traits>::
    operator<<(unsigned long long __n)
    {
      sentry __cerb(*this);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      _M_check_facet(this->_M_fnumput);
	      const __numput_type& __np = *this->_M_fnumput;
	      if (__np.put(*this, *this, this->fill(), __n).failed())
		__err |= ios_base::badbit;
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }
#endif
  
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>& 
    basic_ostream<_CharT, _Traits>::
    operator<<(double __n)
    {
      sentry __cerb(*this);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      _M_check_facet(this->_M_fnumput);
	      const __numput_type& __np = *this->_M_fnumput;
	      if (__np.put(*this, *this, this->fill(), __n).failed())
		__err |= ios_base::badbit;
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }
  
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>& 
    basic_ostream<_CharT, _Traits>::
    operator<<(long double __n)
    {
      sentry __cerb(*this);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      _M_check_facet(this->_M_fnumput);
	      const __numput_type& __np = *this->_M_fnumput;
	      if (__np.put(*this, *this, this->fill(), __n).failed())
		__err |= ios_base::badbit;
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>& 
    basic_ostream<_CharT, _Traits>::
    operator<<(const void* __n)
    {
      sentry __cerb(*this);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      _M_check_facet(this->_M_fnumput);
	      const __numput_type& __np = *this->_M_fnumput;
	      if (__np.put(*this, *this, this->fill(), __n).failed())
		__err |= ios_base::badbit;
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>& 
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this);
      if (__cerb && __sbin)
	{
	  try
	    {
	      if (!__copy_streambufs(*this, __sbin, this->rdbuf()))
		__err |= ios_base::failbit;
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::failbit); }
	}
      else if (!__sbin)
	__err |= ios_base::badbit;
      if (__err)
	this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::put(char_type __c)
    { 
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 60. What is a formatted input function?
      // basic_ostream::put(char_type) is an unformatted output function.
      // DR 63. Exception-handling policy for unformatted output.
      // Unformatted output functions should catch exceptions thrown
      // from streambuf members.
      sentry __cerb(*this);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try
	    {
	      int_type __put = this->rdbuf()->sputc(__c); 
	      if (traits_type::eq_int_type(__put, traits_type::eof()))
		__err |= ios_base::badbit;
	    }
	  catch (...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;     
    }   
      
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::write(const _CharT* __s, streamsize __n)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 60. What is a formatted input function?
      // basic_ostream::write(const char_type*, streamsize) is an
      // unformatted output function.
      // DR 63. Exception-handling policy for unformatted output.
      // Unformatted output functions should catch exceptions thrown
      // from streambuf members.
      sentry __cerb(*this);
      if (__cerb)
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try
	    {
	      streamsize __put = this->rdbuf()->sputn(__s, __n);
	      if (__put != __n)
		__err |= ios_base::badbit;
	    }
 	  catch (...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::flush()
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 60. What is a formatted input function?
      // basic_ostream::flush() is *not* an unformatted output function.
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
	{
	  if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
	    __err |= ios_base::badbit;
	}
      catch(...)
	{ this->_M_setstate(ios_base::badbit); }
      if (__err)
	this->setstate(__err);
      return *this;
    }
  
  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::tellp()
    {
      pos_type __ret = pos_type(-1);
      try
	{
	  if (!this->fail())
	    __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
	}
      catch(...)
	{ this->_M_setstate(ios_base::badbit); }
      return __ret;
    }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
	{
	  if (!this->fail())
	    {
	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 136.  seekp, seekg setting wrong streams?
	      pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::out);
	      
	      // 129. Need error indication from seekp() and seekg()
	      if (__p == pos_type(off_type(-1)))
		__err |= ios_base::failbit;
	    }
	}
      catch(...)
	{ this->_M_setstate(ios_base::badbit); }
      if (__err)
	this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
	{
	  if (!this->fail())
	    {
	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 136.  seekp, seekg setting wrong streams?
	      pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, 
						       ios_base::out);
	      
	      // 129. Need error indication from seekp() and seekg()
	      if (__p == pos_type(off_type(-1)))
		__err |= ios_base::failbit;
	    }
	}
      catch(...)
	{ this->_M_setstate(ios_base::badbit); }
      if (__err)
	this->setstate(__err);
      return *this;
    }

  // 27.6.2.5.4 Character inserters.
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
	{
	  try 
	    {
	      const streamsize __w = __out.width() > 0 ? __out.width() : 0;
	      _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * (__w + 1)));
	      __pads[0] = __c;
	      streamsize __len = 1;
	      if (__w > __len)
		{
		  __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __pads, 
						 &__c, __w, __len, false);
		  __len = __w;
		}
	      __out.write(__pads, __len);
	      __out.width(0);
	    }
	  catch(...)
	    { __out._M_setstate(ios_base::badbit); }
	}
      return __out;
    }
  
  // Specializations.
  template <class _Traits> 
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    {
      typedef basic_ostream<char, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
	{
	  try 
	    {
	      const streamsize __w = __out.width() > 0 ? __out.width() : 0;
	      char* __pads = static_cast<char*>(__builtin_alloca(__w + 1));
	      __pads[0] = __c;
	      streamsize __len = 1;
	      if (__w > __len)
		{
		  __pad<char, _Traits>::_S_pad(__out, __out.fill(), __pads, 
					       &__c, __w, __len, false);
		  __len = __w;
		}
	      __out.write(__pads, __len);
	      __out.width(0);
	    }
	  catch(...)
	    { __out._M_setstate(ios_base::badbit); }
	}
      return __out;
     }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb && __s)
	{
	  try 
	    {
	      const streamsize __w = __out.width() > 0 ? __out.width() : 0;
	      _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __w));
	      streamsize __len = static_cast<streamsize>(_Traits::length(__s));
	      if (__w > __len)
		{
		  __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __pads, 
						 __s, __w, __len, false);
		  __s = __pads;
		  __len = __w;
		}
	      __out.write(__s, __len);
	      __out.width(0);
	    }
	  catch(...)
	    { __out._M_setstate(ios_base::badbit); }
	}
      else if (!__s)
	__out.setstate(ios_base::badbit);
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS
// 167.  Improper use of traits_type::length()
// Note that this is only in 'Review' status.
      typedef char_traits<char>		     __traits_type;
#endif
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb && __s)
	{
	  size_t __clen = __traits_type::length(__s);
	  _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * (__clen + 1)));
	  for (size_t  __i = 0; __i < __clen; ++__i)
	    __ws[__i] = __out.widen(__s[__i]);
	  _CharT* __str = __ws;
	  
	  try 
	    {
	      streamsize __len = static_cast<streamsize>(__clen);
	      const streamsize __w = __out.width() > 0 ? __out.width() : 0;
	      _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __w));
	      
	      if (__w > __len)
		{
		  __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __pads, 
						 __ws, __w, __len, false);
		  __str = __pads;
		  __len = __w;
		}
	      __out.write(__str, __len);
	      __out.width(0);
	    }
	  catch(...)
	    { __out._M_setstate(ios_base::badbit); }
	}
      else if (!__s)
	__out.setstate(ios_base::badbit);
      return __out;
    }

  // Partial specializations.
  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      typedef basic_ostream<char, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb && __s)
	{
	  try 
	    {
	      const streamsize __w = __out.width() > 0 ? __out.width() : 0;
	      char* __pads = static_cast<char*>(__builtin_alloca(__w));
	      streamsize __len = static_cast<streamsize>(_Traits::length(__s));

	      if (__w > __len)
		{
		  __pad<char, _Traits>::_S_pad(__out, __out.fill(), __pads, 
						 __s, __w, __len, false);
		  __s = __pads;
		  __len = __w;
		}
	      __out.write(__s, __len);
	      __out.width(0);
	    }
	  catch(...)
	    { __out._M_setstate(ios_base::badbit); }
	}
      else if (!__s)
	__out.setstate(ios_base::badbit);
      return __out;
    }

  // 21.3.7.9 basic_string::operator<<
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out,
	       const basic_string<_CharT, _Traits, _Alloc>& __str)
    { 
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
	{
	  const _CharT* __s = __str.data();
	  const streamsize __w = __out.width() > 0 ? __out.width() : 0;
	  _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __w));
	  streamsize __len = static_cast<streamsize>(__str.size());
#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS
	  // 25. String operator<< uses width() value wrong
#endif
	  if (__w > __len)
	    {
	      __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __pads, __s, 
					     __w, __len, false);
	      __s = __pads;
	      __len = __w;
	    }
	  streamsize __res = __out.rdbuf()->sputn(__s, __len);
	  __out.width(0);
	  if (__res != __len)
	    __out.setstate(ios_base::failbit);
	}
      return __out;
    }

  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.  
  // NB:  This syntax is a GNU extension.
#if _GLIBCPP_EXTERN_TEMPLATE
  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

#if defined(_GLIBCPP_USE_WCHAR_T) || defined(_GLIBCPP_USE_TYPE_WCHAR_T)
  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);
#endif
#endif
} // namespace std
@


1.1
log
@Initial revision
@
text
@d43 1
a43 1
    sentry(basic_ostream<_CharT,_Traits>& __os)
d64 4
a67 15
      sentry __cerb(*this);
      if (__cerb)
	{ 
	  try 
	    { __pf(*this); }
	  catch(...)
	    {
	      // 27.6.2.5.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
	}
      return *this;
d75 4
a78 14
      sentry __cerb(*this);
      if (__cerb)
	{ 
	  try 
	    { __pf(*this); }
	  catch(...)
	    {
	      // 27.6.2.5.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
	}
d87 4
a90 14
      sentry __cerb(*this);
      if (__cerb)
	{ 
	  try 
	    { __pf(*this); }
	  catch(...)
	    {
	      // 27.6.2.5.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
	}
d96 2
a97 27
    basic_ostream<_CharT, _Traits>::operator<<(__streambuf_type* __sbin)
    {
      sentry __cerb(*this);
      if (__cerb && __sbin)
	{
	  try
	    {
	      if (!__copy_streambufs(*this, __sbin, this->rdbuf()))
		this->setstate(ios_base::failbit);
	    }
	  catch(...)
	    {
	      // 27.6.2.5.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
	}
      else if (!__sbin)
	this->setstate(ios_base::badbit);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>& 
    basic_ostream<_CharT, _Traits>::operator<<(bool __n)
d102 1
d105 4
a108 3
	      if (_M_check_facet(_M_fnumput))
		if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
		  this->setstate(ios_base::badbit);
d111 3
a113 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d120 2
a121 1
    basic_ostream<_CharT, _Traits>::operator<<(long __n)
d126 1
d129 1
d132 3
a134 1
	      if (_M_check_facet(_M_fnumput))
d136 2
a137 10
		  bool __b = false;
		  if ((__fmt & ios_base::oct) || (__fmt & ios_base::hex))
		    {
		      unsigned long __l = static_cast<unsigned long>(__n);
		      __b = _M_fnumput->put(*this, *this, __c, __l).failed();
		    }
		  else
		    __b = _M_fnumput->put(*this, *this, __c, __n).failed();
		  if (__b)  
		    this->setstate(ios_base::badbit);
d139 4
d145 3
a147 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d154 2
a155 1
    basic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)
d160 1
d163 4
a166 3
	      if (_M_check_facet(_M_fnumput))
		if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
		  this->setstate(ios_base::badbit);
d169 3
a171 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d179 2
a180 1
    basic_ostream<_CharT, _Traits>::operator<<(long long __n)
d185 1
d188 1
d191 3
a193 1
	      if (_M_check_facet(_M_fnumput))
d195 3
a197 11
		  bool __b = false;
		  if ((__fmt & ios_base::oct) || (__fmt & ios_base::hex))
		    {
		      unsigned long long __l;
		      __l = static_cast<unsigned long long>(__n);
		      __b = _M_fnumput->put(*this, *this, __c, __l).failed();
		    }
		  else
		    __b = _M_fnumput->put(*this, *this, __c, __n).failed();
		  if (__b)  
		    this->setstate(ios_base::badbit);
d199 4
d205 3
a207 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d214 2
a215 1
    basic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)
d220 1
d223 4
a226 3
	      if (_M_check_facet(_M_fnumput))
		if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
		  this->setstate(ios_base::badbit);
d229 3
a231 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d239 2
a240 1
    basic_ostream<_CharT, _Traits>::operator<<(double __n)
d245 1
d248 4
a251 3
	      if (_M_check_facet(_M_fnumput))
		if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
		  this->setstate(ios_base::badbit);
d254 3
a256 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d263 2
a264 1
    basic_ostream<_CharT, _Traits>::operator<<(long double __n)
d269 1
d272 4
a275 3
	      if (_M_check_facet(_M_fnumput))
		if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
		  this->setstate(ios_base::badbit);
d278 3
a280 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d287 2
a288 1
    basic_ostream<_CharT, _Traits>::operator<<(const void* __n)
d293 1
d296 4
a299 3
	      if (_M_check_facet(_M_fnumput))
		if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
		  this->setstate(ios_base::badbit);
d302 17
d320 2
a321 5
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
d323 2
d326 4
d337 6
d346 15
a360 7
	  int_type __put = rdbuf()->sputc(__c); 
	  if (traits_type::eq_int_type(__put, traits_type::eof()))
	    this->setstate(ios_base::badbit);
	}
      return *this;
    }

d365 7
d375 11
a385 3
	  streamsize __put = this->rdbuf()->sputn(__s, __n);
	  if ( __put != __n)
	    this->setstate(ios_base::badbit);
d394 5
a398 2
      sentry __cerb(*this);
      if (__cerb) 
d401 1
a401 1
	    this->setstate(ios_base::badbit);
d403 4
d415 7
a421 2
      if (!this->fail())
	__ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
d430 2
a431 1
      if (!this->fail())
d433 10
a442 8
#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS
// 136.  seekp, seekg setting wrong streams?
	  pos_type __err = this->rdbuf()->pubseekpos(__pos, ios_base::out);

// 129. Need error indication from seekp() and seekg()
	  if (__err == pos_type(off_type(-1)))
	    this->setstate(ios_base::failbit);
#endif
d444 4
d454 1
a454 1
    seekp(off_type __off, ios_base::seekdir __d)
d456 2
a457 1
      if (!this->fail())
d459 11
a469 9
#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS
// 136.  seekp, seekg setting wrong streams?
	  pos_type __err = this->rdbuf()->pubseekoff(__off, __d, 
						     ios_base::out);

// 129. Need error indication from seekp() and seekg()
	  if (__err == pos_type(off_type(-1)))
	    this->setstate(ios_base::failbit);
#endif
d471 4
d503 1
a503 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      __out._M_setstate(ios_base::badbit);
	      if ((__out.exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d533 1
a533 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      __out._M_setstate(ios_base::badbit);
	      if ((__out.exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d562 1
a562 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      __out._M_setstate(ios_base::badbit);
	      if ((__out.exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d605 1
a605 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      __out._M_setstate(ios_base::badbit);
	      if ((__out.exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d638 1
a638 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      __out._M_setstate(ios_base::badbit);
	      if ((__out.exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d692 1
a692 1
#ifdef _GLIBCPP_USE_WCHAR_T
@


1.1.1.1
log
@standard C++ library for gcc 3.x
@
text
@@


1.1.1.2
log
@gcc 3.3.5
@
text
@d43 1
a43 1
    sentry(basic_ostream<_CharT, _Traits>& __os)
d64 15
a78 4
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 60. What is a formatted input function?
      // The inserters for manipulators are *not* formatted output functions.
      return __pf(*this);
d86 14
a99 4
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 60. What is a formatted input function?
      // The inserters for manipulators are *not* formatted output functions.
      __pf(*this);
d108 14
a121 4
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 60. What is a formatted input function?
      // The inserters for manipulators are *not* formatted output functions.
      __pf(*this);
d127 27
a153 2
    basic_ostream<_CharT, _Traits>::
    operator<<(bool __n)
a157 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d160 3
a162 4
	      _M_check_facet(this->_M_fnumput);
	      const __numput_type& __np = *this->_M_fnumput;
	      if (__np.put(*this, *this, this->fill(), __n).failed())
		__err |= ios_base::badbit;
d165 7
a171 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
d178 1
a178 2
    basic_ostream<_CharT, _Traits>::
    operator<<(long __n)
a182 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
a184 1
	      bool __b = false;
d187 1
a187 3
	      _M_check_facet(this->_M_fnumput);
	      const __numput_type& __np = *this->_M_fnumput;
	      if ((__fmt & ios_base::oct) || (__fmt & ios_base::hex))
d189 10
a198 2
		  unsigned long __l = static_cast<unsigned long>(__n);
		  __b = __np.put(*this, *this, __c, __l).failed();
a199 4
	      else
		__b = __np.put(*this, *this, __c, __n).failed();
	      if (__b)  
		__err |= ios_base::badbit;
d202 7
a208 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
d215 1
a215 2
    basic_ostream<_CharT, _Traits>::
    operator<<(unsigned long __n)
a219 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d222 3
a224 4
	      _M_check_facet(this->_M_fnumput);
	      const __numput_type& __np = *this->_M_fnumput;
	      if (__np.put(*this, *this, this->fill(), __n).failed())
		__err |= ios_base::badbit;
d227 7
a233 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
d241 1
a241 2
    basic_ostream<_CharT, _Traits>::
    operator<<(long long __n)
a245 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
a247 1
	      bool __b = false;
d250 1
a250 3
	      _M_check_facet(this->_M_fnumput);
	      const __numput_type& __np = *this->_M_fnumput;
	      if ((__fmt & ios_base::oct) || (__fmt & ios_base::hex))
d252 11
a262 3
		  unsigned long long __l;
		  __l = static_cast<unsigned long long>(__n);
		  __b = __np.put(*this, *this, __c, __l).failed();
a263 4
	      else
		__b = __np.put(*this, *this, __c, __n).failed();
	      if (__b)  
		__err |= ios_base::badbit;
d266 7
a272 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
d279 1
a279 2
    basic_ostream<_CharT, _Traits>::
    operator<<(unsigned long long __n)
a283 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d286 3
a288 4
	      _M_check_facet(this->_M_fnumput);
	      const __numput_type& __np = *this->_M_fnumput;
	      if (__np.put(*this, *this, this->fill(), __n).failed())
		__err |= ios_base::badbit;
d291 7
a297 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
d305 1
a305 2
    basic_ostream<_CharT, _Traits>::
    operator<<(double __n)
a309 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d312 3
a314 4
	      _M_check_facet(this->_M_fnumput);
	      const __numput_type& __np = *this->_M_fnumput;
	      if (__np.put(*this, *this, this->fill(), __n).failed())
		__err |= ios_base::badbit;
d317 7
a323 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
d330 1
a330 2
    basic_ostream<_CharT, _Traits>::
    operator<<(long double __n)
a334 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d337 3
a339 4
	      _M_check_facet(this->_M_fnumput);
	      const __numput_type& __np = *this->_M_fnumput;
	      if (__np.put(*this, *this, this->fill(), __n).failed())
		__err |= ios_base::badbit;
d342 7
a348 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
d355 1
a355 2
    basic_ostream<_CharT, _Traits>::
    operator<<(const void* __n)
a359 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d362 3
a364 4
	      _M_check_facet(this->_M_fnumput);
	      const __numput_type& __np = *this->_M_fnumput;
	      if (__np.put(*this, *this, this->fill(), __n).failed())
		__err |= ios_base::badbit;
a366 17
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>& 
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this);
      if (__cerb && __sbin)
	{
	  try
d368 5
a372 2
	      if (!__copy_streambufs(*this, __sbin, this->rdbuf()))
		__err |= ios_base::failbit;
a373 2
	  catch(...)
	    { this->_M_setstate(ios_base::failbit); }
a374 4
      else if (!__sbin)
	__err |= ios_base::badbit;
      if (__err)
	this->setstate(__err);
a381 6
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 60. What is a formatted input function?
      // basic_ostream::put(char_type) is an unformatted output function.
      // DR 63. Exception-handling policy for unformatted output.
      // Unformatted output functions should catch exceptions thrown
      // from streambuf members.
d385 7
a391 15
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try
	    {
	      int_type __put = this->rdbuf()->sputc(__c); 
	      if (traits_type::eq_int_type(__put, traits_type::eof()))
		__err |= ios_base::badbit;
	    }
	  catch (...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;     
    }   
      
a395 7
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 60. What is a formatted input function?
      // basic_ostream::write(const char_type*, streamsize) is an
      // unformatted output function.
      // DR 63. Exception-handling policy for unformatted output.
      // Unformatted output functions should catch exceptions thrown
      // from streambuf members.
d399 3
a401 11
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try
	    {
	      streamsize __put = this->rdbuf()->sputn(__s, __n);
	      if (__put != __n)
		__err |= ios_base::badbit;
	    }
 	  catch (...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
d410 2
a411 5
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 60. What is a formatted input function?
      // basic_ostream::flush() is *not* an unformatted output function.
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
d414 1
a414 1
	    __err |= ios_base::badbit;
a415 4
      catch(...)
	{ this->_M_setstate(ios_base::badbit); }
      if (__err)
	this->setstate(__err);
d424 2
a425 7
      try
	{
	  if (!this->fail())
	    __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
	}
      catch(...)
	{ this->_M_setstate(ios_base::badbit); }
d434 1
a434 2
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
d436 8
a443 10
	  if (!this->fail())
	    {
	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 136.  seekp, seekg setting wrong streams?
	      pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::out);
	      
	      // 129. Need error indication from seekp() and seekg()
	      if (__p == pos_type(off_type(-1)))
		__err |= ios_base::failbit;
	    }
a444 4
      catch(...)
	{ this->_M_setstate(ios_base::badbit); }
      if (__err)
	this->setstate(__err);
d451 1
a451 1
    seekp(off_type __off, ios_base::seekdir __dir)
d453 1
a453 2
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
d455 9
a463 11
	  if (!this->fail())
	    {
	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 136.  seekp, seekg setting wrong streams?
	      pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, 
						       ios_base::out);
	      
	      // 129. Need error indication from seekp() and seekg()
	      if (__p == pos_type(off_type(-1)))
		__err |= ios_base::failbit;
	    }
a464 4
      catch(...)
	{ this->_M_setstate(ios_base::badbit); }
      if (__err)
	this->setstate(__err);
d493 7
a499 1
	    { __out._M_setstate(ios_base::badbit); }
d529 7
a535 1
	    { __out._M_setstate(ios_base::badbit); }
d564 7
a570 1
	    { __out._M_setstate(ios_base::badbit); }
d613 7
a619 1
	    { __out._M_setstate(ios_base::badbit); }
d652 7
a658 1
	    { __out._M_setstate(ios_base::badbit); }
@

