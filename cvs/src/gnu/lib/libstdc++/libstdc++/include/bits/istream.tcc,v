head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.48
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.50
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.46
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.42
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.44
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.36
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.40
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.38
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.34
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.32
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.30
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.28
	OPENBSD_5_0:1.4.0.26
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.24
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.22
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.18
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.20
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.16
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.14
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.12
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.10
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.8
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.6
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.4
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	gcc-3_3_5:1.1.1.2
	OPENBSD_3_6:1.2.0.4
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2005.06.17.20.40.31;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.24.23.17.30;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.31.20.50.28;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.05.15.45.13;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.01.05.15.45.13;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.24.22.41.52;	author espie;	state Exp;
branches;
next	;


desc
@@


1.4
log
@
next citrus step.

reviewed by millert, otto, kevlo, naddy, kettenis...
libc+libstdc++ bump
@
text
@// istream classes -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
// USA.

// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.

//
// ISO C++ 14882: 27.6.2  Output streams
//

#pragma GCC system_header

#include <locale>
#include <ostream> // For flush()

namespace std 
{
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskipws)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (__in.good()) 
	{
	  if (__in.tie())
	    __in.tie()->flush();
	  if (!__noskipws && (__in.flags() & ios_base::skipws))
	    {	  
	      const __int_type __eof = traits_type::eof();
	      __streambuf_type* __sb = __in.rdbuf();
	      __int_type __c = __sb->sgetc();

	      __in._M_check_facet(__in._M_fctype);
	      const __ctype_type& __ct = *__in._M_fctype;
	      while (!traits_type::eq_int_type(__c, __eof)
		     && __ct.is(ctype_base::space, 
				traits_type::to_char_type(__c)))
		__c = __sb->snextc();

	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 195. Should basic_istream::sentry's constructor ever
	      // set eofbit?
	      if (traits_type::eq_int_type(__c, __eof))
		__err |= ios_base::eofbit;
	    }
	}

      if (__in.good() && __err == ios_base::goodbit)
	_M_ok = true;
      else
	{
	  _M_ok = false;
	  __err |= ios_base::failbit;
	  __in.setstate(__err);
	}
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>& 
    basic_istream<_CharT, _Traits>::
    operator>>(__istream_type& (*__pf)(__istream_type&))
    { return __pf(*this); }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>& 
    basic_istream<_CharT, _Traits>::
    operator>>(__ios_type& (*__pf)(__ios_type&))
    {
      __pf(*this);
      return *this;
    }
  
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>& 
    basic_istream<_CharT, _Traits>::
    operator>>(ios_base& (*__pf)(ios_base&))
    {
      __pf(*this);
      return *this;
    }
  
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>& 
    basic_istream<_CharT, _Traits>::
    operator>>(bool& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __n);
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>& 
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      long __l;
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __l);
	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 118. basic_istream uses nonexistent num_get member functions.
	      if (!(__err & ios_base::failbit)
		  && (numeric_limits<short>::min() <= __l 
		      && __l <= numeric_limits<short>::max()))
		__n = __l;
	      else
                __err |= ios_base::failbit;
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>& 
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned short& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __n);
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>& 
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      long __l;
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __l);
	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 118. basic_istream uses nonexistent num_get member functions.
	      if (!(__err & ios_base::failbit)
		  && (numeric_limits<int>::min() <= __l 
		      && __l <= numeric_limits<int>::max()))
		__n = __l;
	      else
                __err |= ios_base::failbit;
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>& 
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned int& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __n);
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>& 
    basic_istream<_CharT, _Traits>::
    operator>>(long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __n);
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>& 
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __n);
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

#ifdef _GLIBCPP_USE_LONG_LONG
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>& 
    basic_istream<_CharT, _Traits>::
    operator>>(long long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __n);
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>& 
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned long long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __n);
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }
#endif

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>& 
    basic_istream<_CharT, _Traits>::
    operator>>(float& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __n);
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>& 
    basic_istream<_CharT, _Traits>::
    operator>>(double& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __n);
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>& 
    basic_istream<_CharT, _Traits>::
    operator>>(long double& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __n);
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>& 
    basic_istream<_CharT, _Traits>::
    operator>>(void*& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __n);
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>& 
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
	{
	  try
	    {
	      if (!__copy_streambufs(*this, this->rdbuf(), __sbout))
		__err |= ios_base::failbit;
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::failbit); }
	}
      else if (!__sbout)
	__err |= ios_base::failbit;
      if (__err)
	this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb) 
	{
	  try 
	    {
	      __c = this->rdbuf()->sbumpc();
	      // 27.6.1.1 paragraph 3
	      if (!traits_type::eq_int_type(__c, __eof))
		_M_gcount = 1;
	      else
		__err |= ios_base::eofbit;
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	}
      if (!_M_gcount)
	__err |= ios_base::failbit;
      if (__err)
	this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb) 
	{
 	  try 
	    {
	      int_type __cb = this->rdbuf()->sbumpc();
	      // 27.6.1.1 paragraph 3
	      if (!traits_type::eq_int_type(__cb, traits_type::eof()))
		{
		  _M_gcount = 1;
		  __c = traits_type::to_char_type(__cb);
		}
	      else
		__err |= ios_base::eofbit;
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	}
      if (!_M_gcount)
	__err |= ios_base::failbit;
      if (__err)
	this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb) 
	{
	  try 
	    {
	      const int_type __idelim = traits_type::to_int_type(__delim);
	      const int_type __eof = traits_type::eof();
	      __streambuf_type* __sb = this->rdbuf();
	      int_type __c = __sb->sgetc();	
	      
	      while (_M_gcount + 1 < __n 
		     && !traits_type::eq_int_type(__c, __eof)
		     && !traits_type::eq_int_type(__c, __idelim))
		{
		  *__s++ = traits_type::to_char_type(__c);
		  __c = __sb->snextc();
		  ++_M_gcount;
		}
	      if (traits_type::eq_int_type(__c, __eof))
		__err |= ios_base::eofbit;
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	}
      *__s = char_type();
      if (!_M_gcount)
	__err |= ios_base::failbit;
      if (__err)
	this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb) 
	{
	  try 
	    {
	      const int_type __idelim = traits_type::to_int_type(__delim);
	      const int_type __eof = traits_type::eof();	      
	      __streambuf_type* __this_sb = this->rdbuf();
	      int_type __c = __this_sb->sgetc();
	      char_type __c2 = traits_type::to_char_type(__c);
	      
	      while (!traits_type::eq_int_type(__c, __eof) 
		     && !traits_type::eq_int_type(__c, __idelim) 
		     && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
		{
		  ++_M_gcount;
		  __c = __this_sb->snextc();
		  __c2 = traits_type::to_char_type(__c);
		}
	      if (traits_type::eq_int_type(__c, __eof))
		__err |= ios_base::eofbit;
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	}
      if (!_M_gcount)
	__err |= ios_base::failbit;
      if (__err)
	this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb) 
	{
          try 
	    {
	      const int_type __idelim = traits_type::to_int_type(__delim);
	      const int_type __eof = traits_type::eof();
	      __streambuf_type* __sb = this->rdbuf();
	      int_type __c = __sb->sgetc();
	    
	      while (_M_gcount + 1 < __n 
		     && !traits_type::eq_int_type(__c, __eof)
		     && !traits_type::eq_int_type(__c, __idelim))
		{
		  *__s++ = traits_type::to_char_type(__c);
		  __c = __sb->snextc();
		  ++_M_gcount;
		}
	      if (traits_type::eq_int_type(__c, __eof))
		__err |= ios_base::eofbit;
	      else
		{
		  if (traits_type::eq_int_type(__c, __idelim))
		    {
		      __sb->sbumpc();
		      ++_M_gcount;
		    }
		  else
		    __err |= ios_base::failbit;
		}
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	}
      *__s = char_type();
      if (!_M_gcount)
	__err |= ios_base::failbit;
      if (__err)
	this->setstate(__err);
      return *this;
    }
  
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      const int_type __eof = traits_type::eof();
	      __streambuf_type* __sb = this->rdbuf();
	      int_type __c;
	      
	      __n = min(__n, numeric_limits<streamsize>::max());
	      while (_M_gcount < __n  
		     && !traits_type::eq_int_type(__c = __sb->sbumpc(), __eof))
		{
		  ++_M_gcount;
		  if (traits_type::eq_int_type(__c, __delim))
		    break;
		}
	      if (traits_type::eq_int_type(__c, __eof))
		__err |= ios_base::eofbit;
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }
  
  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      __c = this->rdbuf()->sgetc();
	      if (traits_type::eq_int_type(__c, traits_type::eof()))
		__err |= ios_base::eofbit;
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	} 
       return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      _M_gcount = this->rdbuf()->sgetn(__s, __n);
	      if (_M_gcount != __n)
		__err |= (ios_base::eofbit | ios_base::failbit);
	    }	    
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }
  
  template<typename _CharT, typename _Traits>
    streamsize 
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      // Cannot compare int_type with streamsize generically.
	      streamsize __num = this->rdbuf()->in_avail();
	      if (__num >= 0)
		{
		  __num = min(__num, __n);
		  if (__num)
		    _M_gcount = this->rdbuf()->sgetn(__s, __num);
		}
	      else
		__err |= ios_base::eofbit;
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return _M_gcount;
    }
      
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {
#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS
// 60. What is a formatted input function?
      _M_gcount = 0;
#endif
      sentry __cerb(*this, true);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      const int_type __eof = traits_type::eof();
	      __streambuf_type* __sb = this->rdbuf();
	      if (!__sb 
		  || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
		__err |= ios_base::badbit;
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }
  
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {
#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS
// 60. What is a formatted input function?
      _M_gcount = 0;
#endif
      sentry __cerb(*this, true);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      const int_type __eof = traits_type::eof();
	      __streambuf_type* __sb = this->rdbuf();
	      if (!__sb 
		  || traits_type::eq_int_type(__sb->sungetc(), __eof))
		__err |= ios_base::badbit;
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }
  
  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR60.  Do not change _M_gcount.
      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb) 
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      __streambuf_type* __sb = this->rdbuf();
	      if (__sb)
		{
		  if (__sb->pubsync() == -1)
		    __err |= ios_base::badbit;
		  else 
		    __ret = 0;
		}
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return __ret;
    }
  
  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR60.  Do not change _M_gcount.
      pos_type __ret = pos_type(-1);
      try
	{
	  if (!this->fail())
	    __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
	}
      catch(...)
	{ this->_M_setstate(ios_base::badbit); }
      return __ret;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR60.  Do not change _M_gcount.
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
	{
	  if (!this->fail())
	    {
	      // 136.  seekp, seekg setting wrong streams?
	      pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::in);

	      // 129. Need error indication from seekp() and seekg()
	      if (__p == pos_type(off_type(-1)))
		__err |= ios_base::failbit;
	    }
	}
      catch(...)
	{ this->_M_setstate(ios_base::badbit); }
      if (__err)
	this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR60.  Do not change _M_gcount.
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
	{
	  if (!this->fail())
	    {
	      // 136.  seekp, seekg setting wrong streams?
	      pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, 
						       ios_base::in);
	      
	      // 129. Need error indication from seekp() and seekg()
	      if (__p == pos_type(off_type(-1)))
		__err |= ios_base::failbit;
	    }
	}
      catch(...)
	{ this->_M_setstate(ios_base::badbit); }
      if (__err)
	this->setstate(__err);
      return *this;
    }

  // 27.6.1.2.3 Character extraction templates
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> 		__istream_type;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
	{
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
	    {
	      typename __istream_type::int_type __cb = __in.rdbuf()->sbumpc();
	      if (!_Traits::eq_int_type(__cb, _Traits::eof()))
		__c = _Traits::to_char_type(__cb);
	      else
		__err |= (ios_base::eofbit | ios_base::failbit);
	    }
	  catch(...)
	    { __in._M_setstate(ios_base::badbit); }
	  if (__err)
	    __in.setstate(__err);
	}
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> 		__istream_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename _Traits::int_type 		int_type;
      typedef _CharT                     		char_type;
      typedef ctype<_CharT>     			__ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
	{
	  try 
	    {
	      // Figure out how many characters to extract.
	      streamsize __num = __in.width();
	      if (__num <= 0)
		__num = numeric_limits<streamsize>::max();
	      
	      const __ctype_type& __ctype = use_facet<__ctype_type>(__in.getloc());
	      const int_type __eof = _Traits::eof();
	      __streambuf_type* __sb = __in.rdbuf();
	      int_type __c = __sb->sgetc();
	      
	      while (__extracted < __num - 1 
		     && !_Traits::eq_int_type(__c, __eof)
		     && !__ctype.is(ctype_base::space, _Traits::to_char_type(__c)))
		{
		  *__s++ = _Traits::to_char_type(__c);
		  ++__extracted;
		  __c = __sb->snextc();
		}
	      if (_Traits::eq_int_type(__c, __eof))
		__err |= ios_base::eofbit;

#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS
//68.  Extractors for char* should store null at end
	      *__s = char_type();
#endif
	      __in.width(0);
	    }
	  catch(...)
	    { __in._M_setstate(ios_base::badbit); }
	}
      if (!__extracted)
	__err |= ios_base::failbit;
      if (__err)
	__in.setstate(__err);
      return __in;
    }

  // 27.6.1.4 Standard basic_istream manipulators
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT,_Traits>& 
    ws(basic_istream<_CharT,_Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> 		__istream_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type 	__ctype_type;
      typedef typename __istream_type::int_type 	__int_type;

      const __ctype_type& __ctype = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();	      
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof) 
	     && __ctype.is(ctype_base::space, _Traits::to_char_type(__c)))
	__c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
	 __in.setstate(ios_base::eofbit);
      return __in;
    }

  // 21.3.7.9 basic_string::getline and operators
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
	       basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> 		__istream_type;
      typedef typename __istream_type::int_type 	__int_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type 	__ctype_type;
      typedef basic_string<_CharT, _Traits, _Alloc> 	__string_type;
      typedef typename __string_type::size_type		__size_type;

      __size_type __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb) 
	{
	  try
	    {
	      __str.erase();
	      streamsize __w = __in.width();
	      __size_type __n;
	      __n = __w > 0 ? static_cast<__size_type>(__w) : __str.max_size();
	      
	      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
	      const __int_type __eof = _Traits::eof();
	      __streambuf_type* __sb = __in.rdbuf();
	      __int_type __c = __sb->sgetc();
	      
	      while (__extracted < __n 
		     && !_Traits::eq_int_type(__c, __eof)
		     && !__ct.is(ctype_base::space, _Traits::to_char_type(__c)))
		{
		  __str += _Traits::to_char_type(__c);
		  ++__extracted;
		  __c = __sb->snextc();
		}
	      if (_Traits::eq_int_type(__c, __eof))
		__err |= ios_base::eofbit;
	      __in.width(0);
	    }
	  catch(...)
	    {
	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 91. Description of operator>> and getline() for string<>
	      // might cause endless loop
	      __in._M_setstate(ios_base::badbit);
	    }
	}
      // 211.  operator>>(istream&, string&) doesn't set failbit
      if (!__extracted)
	__err |= ios_base::failbit;
      if (__err)
	__in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> 		__istream_type;
      typedef typename __istream_type::int_type 	__int_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type 	__ctype_type;
      typedef basic_string<_CharT, _Traits, _Alloc> 	__string_type;
      typedef typename __string_type::size_type		__size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      bool __testdelim = false;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb) 
	{
	  try
	    {
	      __str.erase();
	      __int_type __idelim = _Traits::to_int_type(__delim);
	      __streambuf_type* __sb = __in.rdbuf();
	      __int_type __c = __sb->sbumpc();
	      const __int_type __eof = _Traits::eof();
	      __testdelim = _Traits::eq_int_type(__c, __idelim);
	      
	      while (!_Traits::eq_int_type(__c, __eof) && !__testdelim
		     && __extracted < __n)
		{
		  __str += _Traits::to_char_type(__c);
		  ++__extracted;
		  __c = __sb->sbumpc();
		  __testdelim = _Traits::eq_int_type(__c, __idelim);
		}
	      if (_Traits::eq_int_type(__c, __eof))
		__err |= ios_base::eofbit;
	    }
	  catch(...)
	    {
	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 91. Description of operator>> and getline() for string<>
	      // might cause endless loop
	      __in._M_setstate(ios_base::badbit);
	    }
	}
      if ((!__extracted && !__testdelim) || __extracted == __n)
	__err |= ios_base::failbit;
      if (__err)
	__in.setstate(__err);
      return __in;
    }

  template<class _CharT, class _Traits, class _Alloc>
    inline basic_istream<_CharT,_Traits>&
    getline(basic_istream<_CharT, _Traits>& __in, 
	    basic_string<_CharT,_Traits,_Alloc>& __str)
    { return getline(__in, __str, __in.widen('\n')); }

  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.  
  // NB:  This syntax is a GNU extension.
#if defined(_GLIBCPP_EXTERN_TEMPLATE)
  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

#if defined(_GLIBCPP_USE_WCHAR_T) || defined(_GLIBCPP_USE_TYPE_WCHAR_T)
  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);
#endif
#endif
} // namespace std
@


1.3
log
@merge
@
text
@d1152 1
a1152 1
#ifdef _GLIBCPP_USE_WCHAR_T
@


1.2
log
@fix a few #if MACRO -> #if defined(MACRO) (-Wsystem-headers clean-up)
naddy, sturm, brad: tests, comments, fixes... thanks.
@
text
@d46 1
d57 10
a66 8
	      if (__in._M_check_facet(__in._M_fctype))
		while (!traits_type::eq_int_type(__c, __eof)
		       && __in._M_fctype->is(ctype_base::space, 
					     traits_type::to_char_type(__c)))
		  __c = __sb->snextc();

#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS
//195.  Should basic_istream::sentry's constructor ever set eofbit? 
d68 1
a68 2
		__in.setstate(ios_base::eofbit);
#endif
d72 1
a72 1
      if (__in.good())
d77 2
a78 1
	  __in.setstate(ios_base::failbit);
d86 1
a86 4
    {
      __pf(*this);
      return *this;
    }
d114 1
d117 3
a119 4
	      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	      if (_M_check_facet(_M_fnumget))
		_M_fnumget->get(*this, 0, *this, __err, __n);
	      this->setstate(__err);
d122 3
a124 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d137 1
a139 1
	      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d141 4
a144 3
	      if (_M_check_facet(_M_fnumget))
		_M_fnumget->get(*this, 0, *this, __err, __l);
#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS
a151 2
#endif
	      this->setstate(__err);
d154 3
a156 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d169 1
d172 3
a174 4
	      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	      if (_M_check_facet(_M_fnumget))
		_M_fnumget->get(*this, 0, *this, __err, __n);
	      this->setstate(__err);
d177 3
a179 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d192 1
a194 1
	      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d196 4
a199 3
	      if (_M_check_facet(_M_fnumget))
		_M_fnumget->get(*this, 0, *this, __err, __l);
#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS
a206 2
#endif
	      this->setstate(__err);
d209 3
a211 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d224 1
d227 3
a229 4
	      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	      if (_M_check_facet(_M_fnumget))
		_M_fnumget->get(*this, 0, *this, __err, __n);
	      this->setstate(__err);
d232 3
a234 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d247 1
d250 3
a252 4
	      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	      if (_M_check_facet(_M_fnumget))
		_M_fnumget->get(*this, 0, *this, __err, __n);
	      this->setstate(__err);
d255 3
a257 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d270 1
d273 3
a275 4
	      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	      if (_M_check_facet(_M_fnumget))
		_M_fnumget->get(*this, 0, *this, __err, __n);
	      this->setstate(__err);
d278 3
a280 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d294 1
d297 3
a299 4
	      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	      if (_M_check_facet(_M_fnumget))
		_M_fnumget->get(*this, 0, *this, __err, __n);
	      this->setstate(__err);
d302 3
a304 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
	      __throw_exception_again;
	    }
d317 1
d320 3
a322 4
	      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	      if (_M_check_facet(_M_fnumget))
		_M_fnumget->get(*this, 0, *this, __err, __n);
	      this->setstate(__err);
d325 3
a327 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d341 1
d344 3
a346 4
	      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	      if (_M_check_facet(_M_fnumget))
		_M_fnumget->get(*this, 0, *this, __err, __n);
	      this->setstate(__err);
d349 3
a351 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d364 1
d367 3
a369 4
	      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	      if (_M_check_facet(_M_fnumget))
		_M_fnumget->get(*this, 0, *this, __err, __n);
	      this->setstate(__err);
d372 3
a374 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d387 1
d390 3
a392 4
	      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	      if (_M_check_facet(_M_fnumget))
		_M_fnumget->get(*this, 0, *this, __err, __n);
	      this->setstate(__err);
d395 3
a397 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d410 1
d413 3
a415 4
	      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	      if (_M_check_facet(_M_fnumget))
		_M_fnumget->get(*this, 0, *this, __err, __n);
	      this->setstate(__err);
d418 3
a420 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d430 17
a446 24
       sentry __cerb(*this, false);
       if (__cerb)
	 {
	   try
	     {
	       streamsize __xtrct = 0;
	       if (__sbout)
		 {
		   __streambuf_type* __sbin = this->rdbuf();
		   __xtrct = __copy_streambufs(*this, __sbin, __sbout);
		 }
	       if (!__sbout || !__xtrct)
		 this->setstate(ios_base::failbit);
	     }
	   catch(...)
	     {
	       // 27.6.2.5.1 Common requirements.
	       // Turn this on without causing an ios::failure to be thrown.
	       this->_M_setstate(ios_base::badbit);
	       if ((this->exceptions() & ios_base::badbit) != 0)
		 __throw_exception_again;
	     }
	 }
       return *this;
d457 1
d468 1
a468 1
		this->setstate(ios_base::eofbit | ios_base::failbit);
d471 1
a471 7
	    {
	      // 27.6.1.3 paragraph 1
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d473 4
d486 1
d492 1
a492 2
	      const int_type __eof = traits_type::eof();
	      int_type __bufval = this->rdbuf()->sbumpc();
d494 1
a494 1
	      if (!traits_type::eq_int_type(__bufval, __eof))
d497 1
a497 1
		  __c = traits_type::to_char_type(__bufval);
d500 1
a500 1
		this->setstate(ios_base::eofbit | ios_base::failbit);
d503 1
a503 7
	    {
	      // 27.6.1.3 paragraph 1
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d505 4
d518 1
d538 1
a538 1
		this->setstate(ios_base::eofbit);
d541 1
a541 7
	    {
	      // 27.6.1.3 paragraph 1
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d545 3
a547 1
	this->setstate(ios_base::failbit);
d557 1
d578 1
a578 1
		this->setstate(ios_base::eofbit);
d581 1
a581 7
	    {
	      // 27.6.1.3 paragraph 1
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d584 3
a586 1
	this->setstate(ios_base::failbit);
d596 1
d616 1
a616 1
		this->setstate(ios_base::eofbit);
d625 1
a625 1
		    this->setstate(ios_base::failbit);
d629 1
a629 7
	    {
	      // 27.6.1.3 paragraph 1
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d633 3
a635 1
	this->setstate(ios_base::failbit);
d648 1
d664 1
a664 1
		this->setstate(ios_base::eofbit);
d667 3
a669 7
	    {
	      // 27.6.1.3 paragraph 1
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d684 2
a685 1
	  try
d689 1
a689 1
		this->setstate(ios_base::eofbit);
d692 3
a694 7
	    {
	      // 27.6.1.3 paragraph 1
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d696 1
a696 1
      return __c;
d708 1
d713 1
a713 1
		this->setstate(ios_base::eofbit | ios_base::failbit);
d716 3
a718 7
	    {
	      // 27.6.1.3 paragraph 1
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
a719 2
      else
	this->setstate(ios_base::failbit);
d732 1
d744 1
a744 1
		this->setstate(ios_base::eofbit);		    
d747 3
a749 7
	    {
	      // 27.6.1.3 paragraph 1
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
a750 2
      else
	this->setstate(ios_base::failbit);
d766 1
d773 1
a773 1
		this->setstate(ios_base::badbit);		    
d776 3
a778 7
	    {
	      // 27.6.1.3 paragraph 1
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
a779 2
      else
	this->setstate(ios_base::failbit);
d795 1
d802 1
a802 1
		this->setstate(ios_base::badbit);		    
d805 3
a807 7
	    {
	      // 27.6.1.3 paragraph 1
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
a808 2
      else
	this->setstate(ios_base::failbit);
d817 1
d823 1
d830 1
a830 1
		    this->setstate(ios_base::badbit);		    
d836 3
a838 7
	    {
	      // 27.6.1.3 paragraph 1
	      // Turn this on without causing an ios::failure to be thrown.
	      this->_M_setstate(ios_base::badbit);
	      if ((this->exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d848 1
d851 7
a857 2
      if (!this->fail())
	__ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
d867 1
d869 2
a870 1
      if (!this->fail())
d872 4
a875 3
#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS
// 136.  seekp, seekg setting wrong streams?
	  pos_type __err = this->rdbuf()->pubseekpos(__pos, ios_base::in);
d877 4
a880 4
// 129. Need error indication from seekp() and seekg()
	  if (__err == pos_type(off_type(-1)))
	    this->setstate(ios_base::failbit);
#endif
d882 4
d894 1
d896 2
a897 1
      if (!this->fail())
d899 10
a908 9
#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS
// 136.  seekp, seekg setting wrong streams?
	  pos_type __err = this->rdbuf()->pubseekoff(__off, __dir, 
						     ios_base::in);

// 129. Need error indication from seekp() and seekg()
	  if (__err == pos_type(off_type(-1)))
	    this->setstate(ios_base::failbit);
#endif
d910 4
d926 1
a927 2
	    { __in.get(__c); }
	  catch(...)
d929 5
a933 5
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      __in._M_setstate(ios_base::badbit);
	      if ((__in.exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
d935 4
a939 2
      else
	__in.setstate(ios_base::failbit);
d952 1
d954 1
a954 1

d979 1
a979 1
		__in.setstate(ios_base::eofbit);
d988 1
a988 7
	    {
	      // 27.6.1.2.1 Common requirements.
	      // Turn this on without causing an ios::failure to be thrown.
	      __in._M_setstate(ios_base::badbit);
	      if ((__in.exceptions() & ios_base::badbit) != 0)
		__throw_exception_again;
	    }
d991 3
a993 1
	__in.setstate(ios_base::failbit);
d1017 1
a1017 2
	__in.setstate(ios_base::eofbit);

d1033 1
d1035 1
a1035 1

d1039 31
a1069 21
	  __str.erase();
	  streamsize __w = __in.width();
	  __size_type __n;
	  __n = __w > 0 ? static_cast<__size_type>(__w) : __str.max_size();

	  const __ctype_type& __ctype = use_facet<__ctype_type>(__in.getloc());
	  const __int_type __eof = _Traits::eof();
	  __streambuf_type* __sb = __in.rdbuf();
	  __int_type __c = __sb->sgetc();
	  
	  while (__extracted < __n 
		 && !_Traits::eq_int_type(__c, __eof)
		 && !__ctype.is(ctype_base::space, _Traits::to_char_type(__c)))
	    {
	      __str += _Traits::to_char_type(__c);
	      ++__extracted;
	      __c = __sb->snextc();
	    }
	  if (_Traits::eq_int_type(__c, __eof))
	    __in.setstate(ios_base::eofbit);
	  __in.width(0);
d1071 1
a1071 2
#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS
//211.  operator>>(istream&, string&) doesn't set failbit
d1073 3
a1075 2
	__in.setstate (ios_base::failbit);
#endif
d1092 1
d1094 1
d1098 7
a1104 16
	  __str.erase();
	  __size_type __n = __str.max_size();

	  __int_type __idelim = _Traits::to_int_type(__delim);
	  __streambuf_type* __sb = __in.rdbuf();
	  __int_type __c = __sb->sbumpc();
	  const __int_type __eof = _Traits::eof();
	  __testdelim = _Traits::eq_int_type(__c, __idelim);

	  while (__extracted <= __n 
		 && !_Traits::eq_int_type(__c, __eof)
		 && !__testdelim)
	    {
	      __str += _Traits::to_char_type(__c);
	      ++__extracted;
	      __c = __sb->sbumpc();
d1106 18
a1124 2
	  if (_Traits::eq_int_type(__c, __eof))
	    __in.setstate(ios_base::eofbit);
d1126 4
a1129 2
      if (!__extracted && !__testdelim)
	__in.setstate(ios_base::failbit);
@


1.1
log
@Initial revision
@
text
@d1204 1
a1204 1
#if _GLIBCPP_EXTERN_TEMPLATE
@


1.1.1.1
log
@standard C++ library for gcc 3.x
@
text
@@


1.1.1.2
log
@gcc 3.3.5
@
text
@a45 1
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d56 8
a63 10
	      __in._M_check_facet(__in._M_fctype);
	      const __ctype_type& __ct = *__in._M_fctype;
	      while (!traits_type::eq_int_type(__c, __eof)
		     && __ct.is(ctype_base::space, 
				traits_type::to_char_type(__c)))
		__c = __sb->snextc();

	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 195. Should basic_istream::sentry's constructor ever
	      // set eofbit?
d65 2
a66 1
		__err |= ios_base::eofbit;
d70 1
a70 1
      if (__in.good() && __err == ios_base::goodbit)
d75 1
a75 2
	  __err |= ios_base::failbit;
	  __in.setstate(__err);
d83 4
a86 1
    { return __pf(*this); }
a113 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d116 4
a119 3
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __n);
d122 7
a128 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
a140 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d143 1
d145 3
a147 4
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __l);
	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
d155 2
d159 7
a165 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
a177 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d180 4
a183 3
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __n);
d186 7
a192 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
a204 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d207 1
d209 3
a211 4
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __l);
	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
d219 2
d223 7
a229 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
a241 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d244 4
a247 3
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __n);
d250 7
a256 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
a268 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d271 4
a274 3
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __n);
d277 7
a283 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
a295 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d298 4
a301 3
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __n);
d304 7
a310 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
a323 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d326 4
a329 3
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __n);
d332 7
a338 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
a350 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d353 4
a356 3
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __n);
d359 7
a365 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
a378 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d381 4
a384 3
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __n);
d387 7
a393 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
a405 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d408 4
a411 3
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __n);
d414 7
a420 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
a432 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d435 4
a438 3
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __n);
d441 7
a447 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
a459 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d462 4
a465 3
	      _M_check_facet(this->_M_fnumget);
	      const __numget_type& __ng = *this->_M_fnumget;
	      __ng.get(*this, 0, *this, __err, __n);
d468 7
a474 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
d484 24
a507 17
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
	{
	  try
	    {
	      if (!__copy_streambufs(*this, this->rdbuf(), __sbout))
		__err |= ios_base::failbit;
	    }
	  catch(...)
	    { this->_M_setstate(ios_base::failbit); }
	}
      else if (!__sbout)
	__err |= ios_base::failbit;
      if (__err)
	this->setstate(__err);
      return *this;
a517 1
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d528 1
a528 1
		__err |= ios_base::eofbit;
d531 7
a537 1
	    { this->_M_setstate(ios_base::badbit); }
a538 4
      if (!_M_gcount)
	__err |= ios_base::failbit;
      if (__err)
	this->setstate(__err);
a547 1
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d553 2
a554 1
	      int_type __cb = this->rdbuf()->sbumpc();
d556 1
a556 1
	      if (!traits_type::eq_int_type(__cb, traits_type::eof()))
d559 1
a559 1
		  __c = traits_type::to_char_type(__cb);
d562 1
a562 1
		__err |= ios_base::eofbit;
d565 7
a571 1
	    { this->_M_setstate(ios_base::badbit); }
a572 4
      if (!_M_gcount)
	__err |= ios_base::failbit;
      if (__err)
	this->setstate(__err);
a581 1
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d601 1
a601 1
		__err |= ios_base::eofbit;
d604 7
a610 1
	    { this->_M_setstate(ios_base::badbit); }
d614 1
a614 3
	__err |= ios_base::failbit;
      if (__err)
	this->setstate(__err);
a623 1
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d644 1
a644 1
		__err |= ios_base::eofbit;
d647 7
a653 1
	    { this->_M_setstate(ios_base::badbit); }
d656 1
a656 3
	__err |= ios_base::failbit;
      if (__err)
	this->setstate(__err);
a665 1
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d685 1
a685 1
		__err |= ios_base::eofbit;
d694 1
a694 1
		    __err |= ios_base::failbit;
d698 7
a704 1
	    { this->_M_setstate(ios_base::badbit); }
d708 1
a708 3
	__err |= ios_base::failbit;
      if (__err)
	this->setstate(__err);
a720 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d736 1
a736 1
		__err |= ios_base::eofbit;
d739 7
a745 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
d760 1
a760 2
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
	  try 
d764 1
a764 1
		__err |= ios_base::eofbit;
d767 7
a773 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
d775 1
a775 1
       return __c;
a786 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d791 1
a791 1
		__err |= (ios_base::eofbit | ios_base::failbit);
d794 7
a800 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
d802 2
a815 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d827 1
a827 1
		__err |= ios_base::eofbit;
d830 7
a836 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
d838 2
a854 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d861 1
a861 1
		__err |= ios_base::badbit;
d864 7
a870 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
d872 2
a888 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d895 1
a895 1
		__err |= ios_base::badbit;
d898 7
a904 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
d906 2
a915 1
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
a920 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d927 1
a927 1
		    __err |= ios_base::badbit;
d933 7
a939 3
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
a948 1
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
d951 2
a952 7
      try
	{
	  if (!this->fail())
	    __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
	}
      catch(...)
	{ this->_M_setstate(ios_base::badbit); }
a961 1
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
d963 1
a963 2
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
d965 3
a967 4
	  if (!this->fail())
	    {
	      // 136.  seekp, seekg setting wrong streams?
	      pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::in);
d969 4
a972 4
	      // 129. Need error indication from seekp() and seekg()
	      if (__p == pos_type(off_type(-1)))
		__err |= ios_base::failbit;
	    }
a973 4
      catch(...)
	{ this->_M_setstate(ios_base::badbit); }
      if (__err)
	this->setstate(__err);
a981 1
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
d983 1
a983 2
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
d985 9
a993 10
	  if (!this->fail())
	    {
	      // 136.  seekp, seekg setting wrong streams?
	      pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, 
						       ios_base::in);
	      
	      // 129. Need error indication from seekp() and seekg()
	      if (__p == pos_type(off_type(-1)))
		__err |= ios_base::failbit;
	    }
a994 4
      catch(...)
	{ this->_M_setstate(ios_base::badbit); }
      if (__err)
	this->setstate(__err);
a1006 1
	  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d1008 2
d1011 5
a1015 5
	      typename __istream_type::int_type __cb = __in.rdbuf()->sbumpc();
	      if (!_Traits::eq_int_type(__cb, _Traits::eof()))
		__c = _Traits::to_char_type(__cb);
	      else
		__err |= (ios_base::eofbit | ios_base::failbit);
a1016 4
	  catch(...)
	    { __in._M_setstate(ios_base::badbit); }
	  if (__err)
	    __in.setstate(__err);
d1018 2
d1032 1
a1033 2
      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d1058 1
a1058 1
		__err |= ios_base::eofbit;
d1067 7
a1073 1
	    { __in._M_setstate(ios_base::badbit); }
d1076 1
a1076 3
	__err |= ios_base::failbit;
      if (__err)
	__in.setstate(__err);
d1100 2
a1101 1
	 __in.setstate(ios_base::eofbit);
d1117 1
a1118 2
      __size_type __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d1122 21
a1142 31
	  try
	    {
	      __str.erase();
	      streamsize __w = __in.width();
	      __size_type __n;
	      __n = __w > 0 ? static_cast<__size_type>(__w) : __str.max_size();
	      
	      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
	      const __int_type __eof = _Traits::eof();
	      __streambuf_type* __sb = __in.rdbuf();
	      __int_type __c = __sb->sgetc();
	      
	      while (__extracted < __n 
		     && !_Traits::eq_int_type(__c, __eof)
		     && !__ct.is(ctype_base::space, _Traits::to_char_type(__c)))
		{
		  __str += _Traits::to_char_type(__c);
		  ++__extracted;
		  __c = __sb->snextc();
		}
	      if (_Traits::eq_int_type(__c, __eof))
		__err |= ios_base::eofbit;
	      __in.width(0);
	    }
	  catch(...)
	    {
	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 91. Description of operator>> and getline() for string<>
	      // might cause endless loop
	      __in._M_setstate(ios_base::badbit);
	    }
d1144 2
a1145 1
      // 211.  operator>>(istream&, string&) doesn't set failbit
d1147 2
a1148 3
	__err |= ios_base::failbit;
      if (__err)
	__in.setstate(__err);
a1164 1
      const __size_type __n = __str.max_size();
a1165 1
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
d1169 16
a1184 7
	  try
	    {
	      __str.erase();
	      __int_type __idelim = _Traits::to_int_type(__delim);
	      __streambuf_type* __sb = __in.rdbuf();
	      __int_type __c = __sb->sbumpc();
	      const __int_type __eof = _Traits::eof();
a1185 18
	      
	      while (!_Traits::eq_int_type(__c, __eof) && !__testdelim
		     && __extracted < __n)
		{
		  __str += _Traits::to_char_type(__c);
		  ++__extracted;
		  __c = __sb->sbumpc();
		  __testdelim = _Traits::eq_int_type(__c, __idelim);
		}
	      if (_Traits::eq_int_type(__c, __eof))
		__err |= ios_base::eofbit;
	    }
	  catch(...)
	    {
	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 91. Description of operator>> and getline() for string<>
	      // might cause endless loop
	      __in._M_setstate(ios_base::badbit);
d1187 2
d1190 2
a1191 4
      if ((!__extracted && !__testdelim) || __extracted == __n)
	__err |= ios_base::failbit;
      if (__err)
	__in.setstate(__err);
@

