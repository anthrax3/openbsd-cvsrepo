head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.2
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.4
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.9.0.50
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.46
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.48
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.40
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.44
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.42
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.38
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.36
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.34
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.32
	OPENBSD_5_0:1.9.0.30
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.28
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.26
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.22
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.24
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.20
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.18
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.16
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.14
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.12
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.10
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.8
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	READLINE_4_3_PATCH_005:1.1.1.2
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.4.0.10
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.8
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	READLINE_4_1:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2017.01.21.08.25.30;	author krw;	state Exp;
branches;
next	1.10;
commitid	kfWrwuuXWR7ZRgGm;

1.10
date	2016.12.19.18.30.50;	author krw;	state Exp;
branches;
next	1.9;
commitid	6uhw8deuBt1RwfPK;

1.9
date	2004.05.10.19.36.20;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2004.03.03.16.40.46;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.12.04.13.42;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.10.21.40.00;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.08.05.36.50;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.18.17.52.37;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.18.17.45.57;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.18.17.42.26;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.18.17.32.03;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.03.18.17.32.03;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.05.10.18.48.35;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@/* histfile.c - functions to manipulate the history file. */

/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.

   This file contains the GNU History Library (the Library), a set of
   routines for managing the text of previously typed lines.

   The Library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   The Library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   The GNU General Public License is often shipped with GNU software, and
   is generally kept in a file called COPYING or LICENSE.  If you do not
   have a copy of the license, write to the Free Software Foundation,
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */

/* The goal is to make the implementation transparent, so that you
   don't have to know what data types are used, just what functions
   you can call.  I think I have done that. */
#define READLINE_LIBRARY

#if defined (HAVE_CONFIG_H)
#  include <config.h>
#endif

#include <stdio.h>

#include <sys/types.h>
#ifndef _MINIX
#  include <sys/file.h>
#endif
#include "posixstat.h"
#include <fcntl.h>

#if defined (HAVE_STDLIB_H)
#  include <stdlib.h>
#else
#  include "ansi_stdlib.h"
#endif /* HAVE_STDLIB_H */

#if defined (HAVE_UNISTD_H)
#  include <unistd.h>
#endif

#if defined (__EMX__) || defined (__CYGWIN__)
#  undef HAVE_MMAP
#endif

#ifdef HAVE_MMAP
#  include <sys/mman.h>

#  ifdef MAP_FILE
#    define MAP_RFLAGS	(MAP_FILE|MAP_PRIVATE)
#    define MAP_WFLAGS	(MAP_FILE|MAP_SHARED)
#  else
#    define MAP_RFLAGS	MAP_PRIVATE
#    define MAP_WFLAGS	MAP_SHARED
#  endif

#  ifndef MAP_FAILED
#    define MAP_FAILED	((void *)-1)
#  endif

#endif /* HAVE_MMAP */

/* If we're compiling for __EMX__ (OS/2) or __CYGWIN__ (cygwin32 environment
   on win 95/98/nt), we want to open files with O_BINARY mode so that there
   is no \n -> \r\n conversion performed.  On other systems, we don't want to
   mess around with O_BINARY at all, so we ensure that it's defined to 0. */
#if defined (__EMX__) || defined (__CYGWIN__)
#  ifndef O_BINARY
#    define O_BINARY 0
#  endif
#else /* !__EMX__ && !__CYGWIN__ */
#  undef O_BINARY
#  define O_BINARY 0
#endif /* !__EMX__ && !__CYGWIN__ */

#include <errno.h>
#if !defined (errno)
extern int errno;
#endif /* !errno */

#include "history.h"
#include "histlib.h"

#include "rlshell.h"
#include "xmalloc.h"

/* Return the string that should be used in the place of this
   filename.  This only matters when you don't specify the
   filename to read_history (), or write_history (). */
static char *
history_filename (filename)
     const char *filename;
{
  char *return_val;
  const char *home;
  int home_len;
  char dot;

  return_val = filename ? savestring (filename) : (char *)NULL;

  if (return_val)
    return (return_val);

  home = sh_get_env_value ("HOME");

  if (home == 0 || *home == '\0') {
    errno = ENOENT;
    return (NULL);
  }
  home_len = strlen (home);

#if defined (__MSDOS__)
  dot = '_';
#else
  dot = '.';
#endif
  if (asprintf(&return_val, "%s/%c%s", home, dot, "history") == -1)
	  memory_error_and_abort("asprintf");
  return (return_val);
}

/* Add the contents of FILENAME to the history list, a line at a time.
   If FILENAME is NULL, then read from ~/.history.  Returns 0 if
   successful, or errno if not. */
int
read_history (filename)
     const char *filename;
{
  return (read_history_range (filename, 0, -1));
}

/* Read a range of lines from FILENAME, adding them to the history list.
   Start reading at the FROM'th line and end at the TO'th.  If FROM
   is zero, start at the beginning.  If TO is less than FROM, read
   until the end of the file.  If FILENAME is NULL, then read from
   ~/.history.  Returns 0 if successful, or errno if not. */
int
read_history_range (filename, from, to)
     const char *filename;
     int from, to;
{
  register char *line_start, *line_end;
  char *input, *buffer, *bufend;
  int file, current_line, chars_read;
  struct stat finfo;
  size_t file_size;

  buffer = (char *)NULL;
  if ((input = history_filename (filename)))
    file = open (input, O_RDONLY|O_BINARY, 0666);
  else
    file = -1;

  if ((file < 0) || (fstat (file, &finfo) == -1))
    goto error_and_exit;

  file_size = (size_t)finfo.st_size;

  /* check for overflow on very large files */
  if (file_size != finfo.st_size || file_size + 1 < file_size)
    {
#if defined (EFBIG)
      errno = EFBIG;
#elif defined (EOVERFLOW)
      errno = EOVERFLOW;
#endif
      goto error_and_exit;
    }

#ifdef HAVE_MMAP
  /* We map read/write and private so we can change newlines to NULs without
     affecting the underlying object. */
  buffer = (char *)mmap (0, file_size, PROT_READ|PROT_WRITE, MAP_RFLAGS, file, 0);
  if ((void *)buffer == MAP_FAILED)
    goto error_and_exit;
  chars_read = file_size;
#else
  buffer = (char *)malloc (file_size + 1);
  if (buffer == 0)
    goto error_and_exit;

  chars_read = read (file, buffer, file_size);
#endif
  if (chars_read < 0)
    {
  error_and_exit:
      chars_read = errno;
      if (file >= 0)
	close (file);

      FREE (input);
#ifndef HAVE_MMAP
      FREE (buffer);
#endif

      return (chars_read);
    }

  close (file);

  /* Set TO to larger than end of file if negative. */
  if (to < 0)
    to = chars_read;

  /* Start at beginning of file, work to end. */
  bufend = buffer + chars_read;
  current_line = 0;

  /* Skip lines until we are at FROM. */
  for (line_start = line_end = buffer; line_end < bufend && current_line < from; line_end++)
    if (*line_end == '\n')
      {
	current_line++;
	line_start = line_end + 1;
      }

  /* If there are lines left to gobble, then gobble them now. */
  for (line_end = line_start; line_end < bufend; line_end++)
    if (*line_end == '\n')
      {
	*line_end = '\0';

	if (*line_start)
	  add_history (line_start);

	current_line++;

	if (current_line >= to)
	  break;

	line_start = line_end + 1;
      }

  FREE (input);
#ifndef HAVE_MMAP
  FREE (buffer);
#else
  munmap (buffer, file_size);
#endif

  return (0);
}

/* Truncate the history file FNAME, leaving only LINES trailing lines.
   If FNAME is NULL, then use ~/.history.  Returns 0 on success, errno
   on failure. */
int
history_truncate_file (fname, lines)
     const char *fname;
     int lines;
{
  char *buffer, *filename, *bp;
  int file, chars_read, rv;
  struct stat finfo;
  size_t file_size;

  buffer = (char *)NULL;
  if ((filename = history_filename (fname)))
    file = open (filename, O_RDONLY|O_BINARY, 0666);
  else
    file = -1;
  rv = 0;

  /* Don't try to truncate non-regular files. */
  if (file == -1 || fstat (file, &finfo) == -1)
    {
      rv = errno;
      if (file != -1)
	close (file);
      goto truncate_exit;
    }

  if (S_ISREG (finfo.st_mode) == 0)
    {
      close (file);
#ifdef EFTYPE
      rv = EFTYPE;
#else
      rv = EINVAL;
#endif
      goto truncate_exit;
    }

  file_size = (size_t)finfo.st_size;

  /* check for overflow on very large files */
  if (file_size != finfo.st_size || file_size + 1 < file_size)
    {
      close (file);
#if defined (EFBIG)
      rv = errno = EFBIG;
#elif defined (EOVERFLOW)
      rv = errno = EOVERFLOW;
#else
      rv = errno = EINVAL;
#endif
      goto truncate_exit;
    }

  buffer = (char *)malloc (file_size + 1);
  if (buffer == 0)
    {
      close (file);
      goto truncate_exit;
    }

  chars_read = read (file, buffer, file_size);
  close (file);

  if (chars_read <= 0)
    {
      rv = (chars_read < 0) ? errno : 0;
      goto truncate_exit;
    }

  /* Count backwards from the end of buffer until we have passed
     LINES lines. */
  for (bp = buffer + chars_read - 1; lines && bp > buffer; bp--)
    {
      if (*bp == '\n')
	lines--;
    }

  /* If this is the first line, then the file contains exactly the
     number of lines we want to truncate to, so we don't need to do
     anything.  It's the first line if we don't find a newline between
     the current value of i and 0.  Otherwise, write from the start of
     this line until the end of the buffer. */
  for ( ; bp > buffer; bp--)
    if (*bp == '\n')
      {
	bp++;
	break;
      }

  /* Write only if there are more lines in the file than we want to
     truncate to. */
  if (bp > buffer && ((file = open (filename, O_WRONLY|O_TRUNC|O_BINARY, 0600)) != -1))
    {
      write (file, bp, chars_read - (bp - buffer));

#if defined (__BEOS__)
      /* BeOS ignores O_TRUNC. */
      ftruncate (file, chars_read - (bp - buffer));
#endif

      close (file);
    }

 truncate_exit:

  FREE (buffer);

  free (filename);
  return rv;
}

/* Workhorse function for writing history.  Writes NELEMENT entries
   from the history list to FILENAME.  OVERWRITE is non-zero if you
   wish to replace FILENAME with the entries. */
static int
history_do_write (filename, nelements, overwrite)
     const char *filename;
     int nelements, overwrite;
{
  register int i;
  char *output;
  int file, mode, rv;
#ifdef HAVE_MMAP
  size_t cursize;
#endif

#ifdef HAVE_MMAP
  mode = overwrite ? O_RDWR|O_CREAT|O_TRUNC|O_BINARY : O_RDWR|O_APPEND|O_BINARY;
#else
  mode = overwrite ? O_WRONLY|O_CREAT|O_TRUNC|O_BINARY : O_WRONLY|O_APPEND|O_BINARY;
#endif
  output = history_filename (filename);
  rv = 0;

  if (!output || (file = open (output, mode, 0600)) == -1)
    {
      FREE (output);
      return (errno);
    }

#ifdef HAVE_MMAP
  cursize = overwrite ? 0 : lseek (file, 0, SEEK_END);
#endif

  if (nelements > history_length)
    nelements = history_length;

  /* Build a buffer of all the lines to write, and write them in one syscall.
     Suggested by Peter Ho (peter@@robosts.oxford.ac.uk). */
  {
    HIST_ENTRY **the_history;	/* local */
    int buffer_size;
    char *buffer;

    the_history = history_list ();
    /* Calculate the total number of bytes to write. */
    for (buffer_size = 1, i = history_length - nelements; i < history_length; i++)
      buffer_size += 1 + strlen (the_history[i]->line);

    /* Allocate the buffer, and fill it. */
#ifdef HAVE_MMAP
    if (ftruncate (file, buffer_size+cursize) == -1)
      goto mmap_error;
    buffer = (char *)mmap (0, buffer_size, PROT_READ|PROT_WRITE, MAP_WFLAGS, file, cursize);
    if ((void *)buffer == MAP_FAILED)
      {
mmap_error:
	rv = errno;
	FREE (output);
	close (file);
	return rv;
      }
#else
    buffer = (char *)malloc (buffer_size);
    if (buffer == 0)
      {
	rv = errno;
	FREE (output);
	close (file);
	return rv;
      }
#endif
    buffer[0] = '\0';

    for (i = history_length - nelements; i < history_length; i++)
      {
	strlcat (buffer, the_history[i]->line, buffer_size);
	strlcat (buffer, "\n", buffer_size);
      }

#ifdef HAVE_MMAP
    if (msync (buffer, buffer_size, 0) != 0 || munmap (buffer, buffer_size) != 0)
      rv = errno;
#else
    if (write (file, buffer, buffer_size - 1) < 0)
      rv = errno;
    free (buffer);
#endif
  }

  close (file);

  FREE (output);

  return (rv);
}

/* Append NELEMENT entries to FILENAME.  The entries appended are from
   the end of the list minus NELEMENTs up to the end of the list. */
int
append_history (nelements, filename)
     int nelements;
     const char *filename;
{
  return (history_do_write (filename, nelements, HISTORY_APPEND));
}

/* Overwrite FILENAME with the current history.  If FILENAME is NULL,
   then write the history list to ~/.history.  Values returned
   are as in read_history ().*/
int
write_history (filename)
     const char *filename;
{
  return (history_do_write (filename, history_length, HISTORY_OVERWRITE));
}
@


1.10
log
@A couple more unused variables.

tweak & ok kettenis@@
@
text
@d112 1
a112 1
  
d428 1
a428 1
#else    
d432 1
a432 1
      	rv = errno;
@


1.9
log
@Resolve conflicts for GNU readline 4.3p5.
ok deraadt@@, otto@@, pval@@
@
text
@d378 1
d380 1
@


1.8
log
@Do not segfault writing an empty history list to a file. Resolves PR 3690.
ok tdeval@@ markus@@
@
text
@d51 18
a68 5
#if defined (HAVE_STRING_H)
#  include <string.h>
#else
#  include <strings.h>
#endif /* !HAVE_STRING_H */
d70 1
d101 1
a101 1
     char *filename;
d103 2
a104 1
  char *return_val, *home;
d113 1
a113 1
  home = get_env_value ("HOME");
d136 1
a136 1
     char *filename;
d148 1
a148 1
     char *filename;
d151 2
a152 2
  register int line_start, line_end;
  char *input, *buffer;
d173 2
d179 11
a189 1
  buffer = xmalloc (file_size + 1);
d192 1
d196 1
d201 1
d203 1
d205 1
a205 1
      return (errno);
d215 2
a216 1
  line_start = line_end = current_line = 0;
d219 6
a224 11
  while (line_start < chars_read && current_line < from)
    {
      for (line_end = line_start; line_end < chars_read; line_end++)
	if (buffer[line_end] == '\n')
	  {
	    current_line++;
	    line_start = line_end + 1;
	    if (current_line == from)
	      break;
	  }
    }
d227 2
a228 2
  for (line_end = line_start; line_end < chars_read; line_end++)
    if (buffer[line_end] == '\n')
d230 1
a230 1
	buffer[line_end] = '\0';
d232 2
a233 2
	if (buffer[line_start])
	  add_history (buffer + line_start);
d244 1
d246 3
d254 2
a255 1
   If FNAME is NULL, then use ~/.history. */
d258 1
a258 1
     char *fname;
d261 2
a262 3
  register int i;
  int file, chars_read;
  char *buffer, *filename;
d271 1
d273 1
d275 6
a280 1
    goto truncate_exit;
d282 10
a291 3
  /* Don't try to truncate non-regular files. */
  if (S_ISREG(finfo.st_mode) == 0)
    goto truncate_exit;
d300 5
a304 1
      errno = EFBIG;
d309 7
a315 1
  buffer = xmalloc (file_size + 1);
d320 4
a323 1
    goto truncate_exit;
d327 1
a327 1
  for (i = chars_read - 1; lines && i; i--)
d329 1
a329 1
      if (buffer[i] == '\n')
d338 2
a339 2
  for ( ; i; i--)
    if (buffer[i] == '\n')
d341 1
a341 1
	i++;
d347 1
a347 1
  if (i && ((file = open (filename, O_WRONLY|O_TRUNC|O_BINARY, 0600)) != -1))
d349 1
a349 1
      write (file, buffer + i, chars_read - i);
d353 1
a353 1
      ftruncate (file, chars_read - i);
d364 1
a364 1
  return 0;
d372 1
a372 1
     char *filename;
d377 2
a378 1
  int file, mode;
d380 3
d384 1
d386 1
d394 4
d414 22
a435 1
    buffer = xmalloc (buffer_size);
d444 6
a449 1
    write (file, buffer, buffer_size - 1);
d451 1
d458 1
a458 1
  return (0);
d466 1
a466 1
     char *filename;
d476 1
a476 1
     char *filename;
@


1.7
log
@strings in libreadline, again. this time with no abi change,
static builds still seem to work with this. ok deraadt@@ tedu@@
@
text
@d342 1
a342 1
    for (buffer_size = 0, i = history_length - nelements; i < history_length; i++)
d355 1
a355 1
    write (file, buffer, buffer_size);
@


1.6
log
@Back out libreadline changes, this breaks static build (I.E. vax).
changes are nontrivial to fix. Will return when static build works.
@
text
@d91 1
a105 3
  return_val = xmalloc (2 + home_len + 8); /* strlen(".history") == 8 */
  strcpy (return_val, home);
  return_val[home_len] = '/';
d107 1
a107 1
  strcpy (return_val + home_len + 1, "_history");
d109 1
a109 1
  strcpy (return_val + home_len + 1, ".history");
d111 2
a112 1

a336 1
    register int j;
d347 1
d349 1
a349 1
    for (j = 0, i = history_length - nelements; i < history_length; i++)
d351 2
a352 3
	strcpy (buffer + j, the_history[i]->line);
	j += strlen (the_history[i]->line);
	buffer[j++] = '\n';
@


1.5
log
@strings
ok tedu@@, art@@
@
text
@a90 1
  char dot;
d105 3
d109 1
a109 1
  dot = '_';
d111 1
a111 1
  dot = '.';
d113 1
a113 2
  if (asprintf(&return_val, "%s/%c%s", home, dot, "history") == -1)
	  memory_error_and_abort("asprintf");
d338 1
a348 1
    buffer[0] = '\0';
d350 1
a350 1
    for (i = history_length - nelements; i < history_length; i++)
d352 3
a354 2
	strlcat (buffer, the_history[i]->line, buffer_size);
	strlcat (buffer, "\n", buffer_size);
@


1.4
log
@Deal with history_filename() returning NULL.  Missing part if last commit.
@
text
@d91 1
a105 3
  return_val = xmalloc (2 + home_len + 8); /* strlen(".history") == 8 */
  strcpy (return_val, home);
  return_val[home_len] = '/';
d107 1
a107 1
  strcpy (return_val + home_len + 1, "_history");
d109 1
a109 1
  strcpy (return_val + home_len + 1, ".history");
d111 2
a112 1

a336 1
    register int j;
d347 1
d349 1
a349 1
    for (j = 0, i = history_length - nelements; i < history_length; i++)
d351 2
a352 3
	strcpy (buffer + j, the_history[i]->line);
	j += strlen (the_history[i]->line);
	buffer[j++] = '\n';
@


1.3
log
@If $HOME is not set do *not* use '.' for the history file.
@
text
@d99 2
a100 1
  if (home == 0 || *home == '\0')
d102 2
a103 2
  else
    home_len = strlen (home);
d144 4
a147 2
  input = history_filename (filename);
  file = open (input, O_RDONLY|O_BINARY, 0666);
d237 4
a240 2
  filename = history_filename (fname);
  file = open (filename, O_RDONLY|O_BINARY, 0666);
d325 1
a325 1
  if ((file = open (output, mode, 0600)) == -1)
@


1.2
log
@Local patches:
    remove bogus savestring prototype that conflicts with gdb (and is not used)
    fix a typo in sgtty code (not that we use it but...)
    treat empty environment variables as unset
@
text
@d100 1
a100 4
    {
      home = ".";
      home_len = 1;
    }
@


1.1
log
@Initial revision
@
text
@d99 1
a99 1
  if (home == 0)
@


1.1.1.1
log
@GNU readline-4.1
@
text
@@


1.1.1.2
log
@GNU readline 4.3p5
@
text
@d51 5
a55 18
#if defined (__EMX__) || defined (__CYGWIN__)
#  undef HAVE_MMAP
#endif

#ifdef HAVE_MMAP
#  include <sys/mman.h>

#  ifdef MAP_FILE
#    define MAP_RFLAGS	(MAP_FILE|MAP_PRIVATE)
#    define MAP_WFLAGS	(MAP_FILE|MAP_SHARED)
#  else
#    define MAP_RFLAGS	MAP_PRIVATE
#    define MAP_WFLAGS	MAP_SHARED
#  endif

#  ifndef MAP_FAILED
#    define MAP_FAILED	((void *)-1)
#  endif
a56 1
#endif /* HAVE_MMAP */
d87 1
a87 1
     const char *filename;
d89 1
a89 2
  char *return_val;
  const char *home;
d97 1
a97 1
  home = sh_get_env_value ("HOME");
d107 1
a107 1
  return_val = (char *)xmalloc (2 + home_len + 8); /* strlen(".history") == 8 */
d124 1
a124 1
     const char *filename;
d136 1
a136 1
     const char *filename;
d139 2
a140 2
  register char *line_start, *line_end;
  char *input, *buffer, *bufend;
a158 2
#elif defined (EOVERFLOW)
      errno = EOVERFLOW;
d163 1
a163 11
#ifdef HAVE_MMAP
  /* We map read/write and private so we can change newlines to NULs without
     affecting the underlying object. */
  buffer = (char *)mmap (0, file_size, PROT_READ|PROT_WRITE, MAP_RFLAGS, file, 0);
  if ((void *)buffer == MAP_FAILED)
    goto error_and_exit;
  chars_read = file_size;
#else
  buffer = (char *)malloc (file_size + 1);
  if (buffer == 0)
    goto error_and_exit;
a165 1
#endif
a168 1
      chars_read = errno;
a172 1
#ifndef HAVE_MMAP
a173 1
#endif
d175 1
a175 1
      return (chars_read);
d185 1
a185 2
  bufend = buffer + chars_read;
  current_line = 0;
d188 11
a198 6
  for (line_start = line_end = buffer; line_end < bufend && current_line < from; line_end++)
    if (*line_end == '\n')
      {
	current_line++;
	line_start = line_end + 1;
      }
d201 2
a202 2
  for (line_end = line_start; line_end < bufend; line_end++)
    if (*line_end == '\n')
d204 1
a204 1
	*line_end = '\0';
d206 2
a207 2
	if (*line_start)
	  add_history (line_start);
a217 1
#ifndef HAVE_MMAP
a218 3
#else
  munmap (buffer, file_size);
#endif
d224 1
a224 2
   If FNAME is NULL, then use ~/.history.  Returns 0 on success, errno
   on failure. */
d227 1
a227 1
     const char *fname;
d230 3
a232 2
  char *buffer, *filename, *bp;
  int file, chars_read, rv;
a238 1
  rv = 0;
a239 1
  /* Don't try to truncate non-regular files. */
d241 1
a241 6
    {
      rv = errno;
      if (file != -1)
	close (file);
      goto truncate_exit;
    }
d243 3
a245 10
  if (S_ISREG (finfo.st_mode) == 0)
    {
      close (file);
#ifdef EFTYPE
      rv = EFTYPE;
#else
      rv = EINVAL;
#endif
      goto truncate_exit;
    }
d254 1
a254 5
      rv = errno = EFBIG;
#elif defined (EOVERFLOW)
      rv = errno = EOVERFLOW;
#else
      rv = errno = EINVAL;
d259 1
a259 7
  buffer = (char *)malloc (file_size + 1);
  if (buffer == 0)
    {
      close (file);
      goto truncate_exit;
    }

d264 1
a264 4
    {
      rv = (chars_read < 0) ? errno : 0;
      goto truncate_exit;
    }
d268 1
a268 1
  for (bp = buffer + chars_read - 1; lines && bp > buffer; bp--)
d270 1
a270 1
      if (*bp == '\n')
d279 2
a280 2
  for ( ; bp > buffer; bp--)
    if (*bp == '\n')
d282 1
a282 1
	bp++;
d288 1
a288 1
  if (bp > buffer && ((file = open (filename, O_WRONLY|O_TRUNC|O_BINARY, 0600)) != -1))
d290 1
a290 1
      write (file, bp, chars_read - (bp - buffer));
d294 1
a294 1
      ftruncate (file, chars_read - (bp - buffer));
d305 1
a305 1
  return rv;
d313 1
a313 1
     const char *filename;
d318 1
a318 2
  int file, mode, rv;
  size_t cursize;
a319 3
#ifdef HAVE_MMAP
  mode = overwrite ? O_RDWR|O_CREAT|O_TRUNC|O_BINARY : O_RDWR|O_APPEND|O_BINARY;
#else
a320 1
#endif
a321 1
  rv = 0;
a328 4
#ifdef HAVE_MMAP
  cursize = overwrite ? 0 : lseek (file, 0, SEEK_END);
#endif

d346 1
a346 22
#ifdef HAVE_MMAP
    if (ftruncate (file, buffer_size+cursize) == -1)
      goto mmap_error;
    buffer = (char *)mmap (0, buffer_size, PROT_READ|PROT_WRITE, MAP_WFLAGS, file, cursize);
    if ((void *)buffer == MAP_FAILED)
      {
mmap_error:
	rv = errno;
	FREE (output);
	close (file);
	return rv;
      }
#else    
    buffer = (char *)malloc (buffer_size);
    if (buffer == 0)
      {
      	rv = errno;
	FREE (output);
	close (file);
	return rv;
      }
#endif
d355 1
a355 6
#ifdef HAVE_MMAP
    if (msync (buffer, buffer_size, 0) != 0 || munmap (buffer, buffer_size) != 0)
      rv = errno;
#else
    if (write (file, buffer, buffer_size) < 0)
      rv = errno;
a356 1
#endif
d363 1
a363 1
  return (rv);
d371 1
a371 1
     const char *filename;
d381 1
a381 1
     const char *filename;
@

