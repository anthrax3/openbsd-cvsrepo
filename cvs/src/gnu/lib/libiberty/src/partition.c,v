head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.36
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.34
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.30
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.32
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.24
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.28
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.26
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.22
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.20
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.18
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.16
	OPENBSD_5_0:1.5.0.14
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.12
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.10
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.6
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.8
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.4
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5
	BINUTILS_2_17_1:1.1.1.4
	OPENBSD_4_3:1.4.0.18
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.16
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.14
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.12
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.10
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.8
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.6
	OPENBSD_3_7_BASE:1.4
	gcc-3_3_5:1.1.1.3
	OPENBSD_3_6:1.4.0.4
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	binutils-2_14:1.1.1.3
	gcc-3_3_2:1.1.1.3
	binutils-2_11_2:1.1.1.2
	binutils-2_10:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2008.05.27.18.52.44;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.25.21.17.01;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.25.21.06.18;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.24.16.47.34;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2003.11.24.16.31.44;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.24.16.31.44;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.11.24.16.34.20;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.11.25.20.39.16;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.05.27.18.46.01;	author miod;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge OpenBSD specific changes:
- pexecute implementation replaced with the older gcc 2.95 implementation,
  as gcc 2.95's collect2 relies upon an implementation behaviour which has
  been lost in further libiberty updates.
- keep the old hash table interfaces, which are used by gcc 2.95.
- keep the OpenBSD replacement for the md5 interface.
- keep the OpenBSD strl{cat,cpy} and snprinft usage.

Bump libiberty minor version due to the addition of a few new symbols.
@
text
@/* List implementation of a partition of consecutive integers.
   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
   Contributed by CodeSourcery, LLC.

   This file is part of GNU CC.

   GNU CC is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GNU CC is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GNU CC; see the file COPYING.  If not, write to
   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#ifdef HAVE_STRING_H
#include <string.h>
#endif

#include "libiberty.h"
#include "partition.h"

static int elem_compare (const void *, const void *);

/* Creates a partition of NUM_ELEMENTS elements.  Initially each
   element is in a class by itself.  */

partition
partition_new (int num_elements)
{
  int e;
  
  partition part = (partition) 
    xmalloc (sizeof (struct partition_def) + 
	     (num_elements - 1) * sizeof (struct partition_elem));
  part->num_elements = num_elements;
  for (e = 0; e < num_elements; ++e) 
    {
      part->elements[e].class_element = e;
      part->elements[e].next = &(part->elements[e]);
      part->elements[e].class_count = 1;
    }

  return part;
}

/* Freeds a partition.  */

void
partition_delete (partition part)
{
  free (part);
}

/* Unites the classes containing ELEM1 and ELEM2 into a single class
   of partition PART.  If ELEM1 and ELEM2 are already in the same
   class, does nothing.  Returns the canonical element of the
   resulting union class.  */

int
partition_union (partition part, int elem1, int elem2)
{
  struct partition_elem *elements = part->elements;
  struct partition_elem *e1;
  struct partition_elem *e2;
  struct partition_elem *p;
  struct partition_elem *old_next;
  /* The canonical element of the resulting union class.  */
  int class_element = elements[elem1].class_element;

  /* If they're already in the same class, do nothing.  */
  if (class_element == elements[elem2].class_element)
    return class_element;

  /* Make sure ELEM1 is in the larger class of the two.  If not, swap
     them.  This way we always scan the shorter list.  */
  if (elements[elem1].class_count < elements[elem2].class_count) 
    {
      int temp = elem1;
      elem1 = elem2;
      elem2 = temp;
      class_element = elements[elem1].class_element;
    }

  e1 = &(elements[elem1]);
  e2 = &(elements[elem2]);

  /* Keep a count of the number of elements in the list.  */
  elements[class_element].class_count 
    += elements[e2->class_element].class_count;

  /* Update the class fields in elem2's class list.  */
  e2->class_element = class_element;
  for (p = e2->next; p != e2; p = p->next)
    p->class_element = class_element;
  
  /* Splice ELEM2's class list into ELEM1's.  These are circular
     lists.  */
  old_next = e1->next;
  e1->next = e2->next;
  e2->next = old_next;

  return class_element;
}

/* Compare elements ELEM1 and ELEM2 from array of integers, given a
   pointer to each.  Used to qsort such an array.  */

static int 
elem_compare (const void *elem1, const void *elem2)
{
  int e1 = * (const int *) elem1;
  int e2 = * (const int *) elem2;
  if (e1 < e2)
    return -1;
  else if (e1 > e2)
    return 1;
  else
    return 0;
}

/* Prints PART to the file pointer FP.  The elements of each
   class are sorted.  */

void
partition_print (partition part, FILE *fp)
{
  char *done;
  int num_elements = part->num_elements;
  struct partition_elem *elements = part->elements;
  int *class_elements;
  int e;

  /* Flag the elements we've already printed.  */
  done = (char *) xmalloc (num_elements);
  memset (done, 0, num_elements);

  /* A buffer used to sort elements in a class.  */
  class_elements = (int *) xmalloc (num_elements * sizeof (int));

  fputc ('[', fp);
  for (e = 0; e < num_elements; ++e)
    /* If we haven't printed this element, print its entire class.  */
    if (! done[e]) 
      {
	int c = e;
	int count = elements[elements[e].class_element].class_count;
	int i;

      /* Collect the elements in this class.  */
	for (i = 0; i < count; ++i) {
	  class_elements[i] = c;
	  done[c] = 1;
	  c = elements[c].next - elements;
	}
	/* Sort them.  */
	qsort ((void *) class_elements, count, sizeof (int), elem_compare);
	/* Print them.  */
	fputc ('(', fp);
	for (i = 0; i < count; ++i) 
	  fprintf (fp, i == 0 ? "%d" : " %d", class_elements[i]);
	fputc (')', fp);
      }
  fputc (']', fp);

  free (class_elements);
  free (done);
}

@


1.4
log
@fix instances of cvs brain-damage. We want the current FSF version of
these files.
@
text
@d19 2
a20 2
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d37 1
a37 1
static int elem_compare PARAMS ((const void *, const void *));
d43 1
a43 2
partition_new (num_elements)
     int num_elements;
d64 1
a64 2
partition_delete (part)
      partition part;
d75 1
a75 4
partition_union (part, elem1, elem2)
     partition part;
     int elem1;
     int elem2;
d124 1
a124 3
elem_compare (elem1, elem2)
     const void *elem1;
     const void *elem2;
d140 1
a140 3
partition_print (part, fp)
     partition part;
     FILE *fp;
d180 1
@


1.3
log
@fix stupid cvs conflicts.
I think that cvs is a poor lonesome, depressive program.
The only way it has found of getting your attention is to throw
senseless conflicts that shouldn't exist in your way.
@
text
@d30 4
d37 2
d133 2
a134 2
  int e1 = * (int *) elem1;
  int e2 = * (int *) elem2;
d180 1
a180 1
	qsort ((void *) class_elements, count, sizeof (int), &elem_compare);
@


1.2
log
@OpenBSD changes: synch somewhere between binutils-2.10 and 2.11
Support for mkstemps in choose-temp.
@
text
@d1 2
a2 2
/* List implentation of a partition of consecutive integers.
   Copyright (C) 2000 Free Software Foundation, Inc.
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Moving libiberty around, keeping vendor branch.
First: binutils-2.10.
@
text
@@


1.1.1.2
log
@Second import from the vendor branch: binutils-2.11.2
@
text
@a29 4
#ifdef HAVE_STRING_H
#include <string.h>
#endif

a32 2
static int elem_compare PARAMS ((const void *, const void *));

d127 2
a128 2
  int e1 = * (const int *) elem1;
  int e2 = * (const int *) elem2;
d174 1
a174 1
	qsort ((void *) class_elements, count, sizeof (int), elem_compare);
@


1.1.1.3
log
@Synch with gcc-3.3.2 version
@
text
@d1 2
a2 2
/* List implementation of a partition of consecutive integers.
   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
@


1.1.1.4
log
@Update libiberty to the version found in binutils 2.17.1 (which still
identifies itself as the gcc 3 version...)
@
text
@d19 2
a20 2
   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
   Boston, MA 02110-1301, USA.  */
d37 1
a37 1
static int elem_compare (const void *, const void *);
d43 2
a44 1
partition_new (int num_elements)
d65 2
a66 1
partition_delete (partition part)
d77 4
a80 1
partition_union (partition part, int elem1, int elem2)
d129 3
a131 1
elem_compare (const void *elem1, const void *elem2)
d147 3
a149 1
partition_print (partition part, FILE *fp)
a188 1
  free (class_elements);
@


