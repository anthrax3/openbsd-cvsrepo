head	1.4;
access;
symbols
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.34
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.30
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.32
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.24
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.28
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.26
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.22
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.20
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.18
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.16
	OPENBSD_5_0:1.4.0.14
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.12
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.10
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.6
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.8
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.4
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4
	BINUTILS_2_17_1:1.1.1.3
	OPENBSD_4_3:1.2.0.12
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.10
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.8
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.6
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.4
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.1.1.2.0.6
	OPENBSD_3_7_BASE:1.1.1.2
	gcc-3_3_5:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	binutils-2_14:1.1.1.2
	gcc-3_3_2:1.1.1.2
	binutils-2_11_2:1.1.1.1
	binutils-2_10:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2008.06.07.15.49.27;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.27.18.52.44;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.14.09.54.36;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2003.11.24.16.31.46;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.24.16.31.46;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.11.25.20.39.25;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.05.27.18.46.02;	author miod;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Put back sprintf -> snprintf changes which have been lost accidentally in the
last update.
@
text
@/* xstrerror.c -- jacket routine for more robust strerror() usage.
   Fri Jun 16 18:30:00 1995  Pat Rankin  <rankin@@eql.caltech.edu>
   This code is in the public domain.  */

/*

@@deftypefn Replacement char* xstrerror (int @@var{errnum})

Behaves exactly like the standard @@code{strerror} function, but
will never return a @@code{NULL} pointer.

@@end deftypefn

*/

#include <stdio.h>

#include "config.h"
#include "libiberty.h"

#ifdef VMS
#  include <errno.h>
#  if !defined (__STRICT_ANSI__) && !defined (__HIDE_FORBIDDEN_NAMES)
#    ifdef __cplusplus
extern "C" {
#    endif /* __cplusplus */
extern char *strerror (int,...);
#    define DONT_DECLARE_STRERROR
#    ifdef __cplusplus
}
#    endif /* __cplusplus */
#  endif
#endif  /* VMS */


#ifndef DONT_DECLARE_STRERROR
#  ifdef __cplusplus
extern "C" {
#  endif /* __cplusplus */
extern char *strerror (int);
#  ifdef __cplusplus
}
#  endif /* __cplusplus */
#endif

/* If strerror returns NULL, we'll format the number into a static buffer.  */

#define ERRSTR_FMT "undocumented error #%d"
static char xstrerror_buf[sizeof ERRSTR_FMT + 20];

/* Like strerror, but result is never a null pointer.  */

char *
xstrerror (int errnum)
{
  char *errstr;
#ifdef VMS
  char *(*vmslib_strerror) (int,...);

  /* Override any possibly-conflicting declaration from system header.  */
  vmslib_strerror = (char *(*) (int,...)) strerror;
  /* Second argument matters iff first is EVMSERR, but it's simpler to
     pass it unconditionally.  `vaxc$errno' is declared in <errno.h>
     and maintained by the run-time library in parallel to `errno'.
     We assume that `errnum' corresponds to the last value assigned to
     errno by the run-time library, hence vaxc$errno will be relevant.  */
  errstr = (*vmslib_strerror) (errnum, vaxc$errno);
#else
  errstr = strerror (errnum);
#endif

  /* If `errnum' is out of range, result might be NULL.  We'll fix that.  */
  if (!errstr)
    {
      snprintf (xstrerror_buf, sizeof xstrerror_buf, ERRSTR_FMT, errnum);
      errstr = xstrerror_buf;
    }
  return errstr;
}
@


1.3
log
@Merge OpenBSD specific changes:
- pexecute implementation replaced with the older gcc 2.95 implementation,
  as gcc 2.95's collect2 relies upon an implementation behaviour which has
  been lost in further libiberty updates.
- keep the old hash table interfaces, which are used by gcc 2.95.
- keep the OpenBSD replacement for the md5 interface.
- keep the OpenBSD strl{cat,cpy} and snprinft usage.

Bump libiberty minor version due to the addition of a few new symbols.
@
text
@d75 1
a75 1
      sprintf (xstrerror_buf, ERRSTR_FMT, errnum);
@


1.2
log
@use snprintf. okay deraadt@@
@
text
@d18 1
a19 1
#include "config.h"
d22 13
a34 6
#include <errno.h>
#if !defined (__STRICT_ANSI__) && !defined (__HIDE_FORBIDDEN_NAMES)
extern char *strerror PARAMS ((int,...));
#define DONT_DECLARE_STRERROR
#endif
#endif	/* VMS */
d37 7
a43 1
extern char *strerror PARAMS ((int));
d54 1
a54 2
xstrerror (errnum)
     int errnum;
d58 1
a58 1
  char *(*vmslib_strerror) PARAMS ((int,...));
d61 1
a61 1
  vmslib_strerror = (char *(*) PARAMS ((int,...))) strerror;
d75 1
a75 1
      snprintf (xstrerror_buf, sizeof xstrerror_buf, ERRSTR_FMT, errnum);
@


1.1
log
@Initial revision
@
text
@d5 11
d63 1
a63 1
      sprintf (xstrerror_buf, ERRSTR_FMT, errnum);
@


1.1.1.1
log
@Moving libiberty around, keeping vendor branch.
First: binutils-2.10.
@
text
@@


1.1.1.2
log
@Synch with gcc-3.3.2 version
@
text
@a4 11
/*

@@deftypefn Replacement char* xstrerror (int @@var{errnum})

Behaves exactly like the standard @@code{strerror} function, but
will never return a @@code{NULL} pointer.

@@end deftypefn

*/

@


1.1.1.3
log
@Update libiberty to the version found in binutils 2.17.1 (which still
identifies itself as the gcc 3 version...)
@
text
@d18 1
a19 1
#include "libiberty.h"
d22 6
a27 13
#  include <errno.h>
#  if !defined (__STRICT_ANSI__) && !defined (__HIDE_FORBIDDEN_NAMES)
#    ifdef __cplusplus
extern "C" {
#    endif /* __cplusplus */
extern char *strerror (int,...);
#    define DONT_DECLARE_STRERROR
#    ifdef __cplusplus
}
#    endif /* __cplusplus */
#  endif
#endif  /* VMS */

d30 1
a30 7
#  ifdef __cplusplus
extern "C" {
#  endif /* __cplusplus */
extern char *strerror (int);
#  ifdef __cplusplus
}
#  endif /* __cplusplus */
d41 2
a42 1
xstrerror (int errnum)
d46 1
a46 1
  char *(*vmslib_strerror) (int,...);
d49 1
a49 1
  vmslib_strerror = (char *(*) (int,...)) strerror;
@


