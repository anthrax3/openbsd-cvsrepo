head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.3.0.36
	OPENBSD_6_2_BASE:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.38
	OPENBSD_6_1_BASE:1.1.1.3
	OPENBSD_6_0:1.1.1.3.0.34
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.30
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.32
	OPENBSD_5_8_BASE:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.24
	OPENBSD_5_7_BASE:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.28
	OPENBSD_5_6_BASE:1.1.1.3
	OPENBSD_5_5:1.1.1.3.0.26
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.22
	OPENBSD_5_4_BASE:1.1.1.3
	OPENBSD_5_3:1.1.1.3.0.20
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.18
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.16
	OPENBSD_5_0:1.1.1.3.0.14
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.12
	OPENBSD_4_9_BASE:1.1.1.3
	OPENBSD_4_8:1.1.1.3.0.10
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.6
	OPENBSD_4_7_BASE:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.8
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.4
	OPENBSD_4_5_BASE:1.1.1.3
	OPENBSD_4_4:1.1.1.3.0.2
	OPENBSD_4_4_BASE:1.1.1.3
	BINUTILS_2_17_1:1.1.1.3
	OPENBSD_4_3:1.1.1.2.0.18
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.16
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.14
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.12
	OPENBSD_4_0_BASE:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.10
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.8
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.6
	OPENBSD_3_7_BASE:1.1.1.2
	gcc-3_3_5:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	binutils-2_14:1.1.1.2
	gcc-3_3_2:1.1.1.2
	binutils-2_11_2:1.1.1.1
	binutils-2_10:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.11.24.16.31.42;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.24.16.31.42;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.11.25.20.39.14;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.05.27.18.46.01;	author miod;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* getpwd.c - get the working directory */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <sys/types.h>

#include <errno.h>
#ifndef errno
extern int errno;
#endif

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#if HAVE_SYS_STAT_H
#include <sys/stat.h>
#endif

/* Prototype these in case the system headers don't provide them. */
extern char *getpwd ();
extern char *getwd ();

#include "libiberty.h"

/* Virtually every UN*X system now in common use (except for pre-4.3-tahoe
   BSD systems) now provides getcwd as called for by POSIX.  Allow for
   the few exceptions to the general rule here.  */

#if !defined(HAVE_GETCWD) && defined(HAVE_GETWD)
#define getcwd(buf,len) getwd(buf)
#endif

#ifdef MAXPATHLEN
#define GUESSPATHLEN (MAXPATHLEN + 1)
#else
#define GUESSPATHLEN 100
#endif

#if !(defined (VMS) || (defined(_WIN32) && !defined(__CYGWIN__)))

/* Get the working directory.  Use the PWD environment variable if it's
   set correctly, since this is faster and gives more uniform answers
   to the user.  Yield the working directory if successful; otherwise,
   yield 0 and set errno.  */

char *
getpwd ()
{
  static char *pwd;
  static int failure_errno;

  char *p = pwd;
  size_t s;
  struct stat dotstat, pwdstat;

  if (!p && !(errno = failure_errno))
    {
      if (! ((p = getenv ("PWD")) != 0
	     && *p == '/'
	     && stat (p, &pwdstat) == 0
	     && stat (".", &dotstat) == 0
	     && dotstat.st_ino == pwdstat.st_ino
	     && dotstat.st_dev == pwdstat.st_dev))

	/* The shortcut didn't work.  Try the slow, ``sure'' way.  */
	for (s = GUESSPATHLEN;  ! getcwd (p = xmalloc (s), s);  s *= 2)
	  {
	    int e = errno;
	    free (p);
#ifdef ERANGE
	    if (e != ERANGE)
#endif
	      {
		errno = failure_errno = e;
		p = 0;
		break;
	      }
	  }

      /* Cache the result.  This assumes that the program does
	 not invoke chdir between calls to getpwd.  */
      pwd = p;
    }
  return p;
}

#else	/* VMS || _WIN32 && !__CYGWIN__ */

#ifndef MAXPATHLEN
#define MAXPATHLEN 255
#endif

char *
getpwd ()
{
  static char *pwd = 0;

  if (!pwd)
    pwd = getcwd (xmalloc (MAXPATHLEN + 1), MAXPATHLEN + 1
#ifdef VMS
		  , 0
#endif
		  );
  return pwd;
}

#endif	/* VMS || _WIN32 && !__CYGWIN__ */
@


1.1.1.1
log
@Moving libiberty around, keeping vendor branch.
First: binutils-2.10.
@
text
@@


1.1.1.2
log
@Synch with gcc-3.3.2 version
@
text
@a2 12
/*

@@deftypefn Supplemental char* getpwd (void)

Returns the current working directory.  This implementation caches the
result on the assumption that the process will not call @@code{chdir}
between calls to @@code{getpwd}.

@@end deftypefn

*/

@


1.1.1.3
log
@Update libiberty to the version found in binutils 2.17.1 (which still
identifies itself as the gcc 3 version...)
@
text
@d38 4
a41 3
#if HAVE_LIMITS_H
#include <limits.h>
#endif
a49 2
/* Prototype in case the system headers doesn't provide it. */
extern char *getwd ();
d67 1
a67 1
getpwd (void)
d86 1
a86 1
	for (s = GUESSPATHLEN;  !getcwd (p = XNEWVEC (char, s), s);  s *= 2)
d114 1
a114 1
getpwd (void)
d119 1
a119 1
    pwd = getcwd (XNEWVEC (char, MAXPATHLEN + 1), MAXPATHLEN + 1
@


