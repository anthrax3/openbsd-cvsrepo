head	1.5;
access;
symbols
	OPENBSD_6_0:1.5.0.34
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.30
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.32
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.24
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.28
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.26
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.22
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.20
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.18
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.16
	OPENBSD_5_0:1.5.0.14
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.12
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.10
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.6
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.8
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.4
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5
	BINUTILS_2_17_1:1.1.1.4
	OPENBSD_4_3:1.3.0.18
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.16
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.14
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.12
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.10
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.8
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.6
	OPENBSD_3_7_BASE:1.3
	gcc-3_3_5:1.1.1.3
	OPENBSD_3_6:1.3.0.4
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	binutils-2_14:1.1.1.3
	gcc-3_3_2:1.1.1.3
	binutils-2_11_2:1.1.1.2
	binutils-2_10:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2008.06.07.15.29.22;	author chl;	state Exp;
branches;
next	1.4;

1.4
date	2008.05.27.18.52.43;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.25.21.06.18;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.24.16.47.34;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2003.11.24.16.31.38;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.24.16.31.38;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.11.24.16.34.11;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.11.25.20.39.04;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.05.27.18.46.01;	author miod;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Put back the diff made between rev. 1.1.1.3 and 1.3

ok miod@@
@
text
@/* Utility to pick a temporary filename prefix.
   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.

This file is part of the libiberty library.
Libiberty is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

Libiberty is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with libiberty; see the file COPYING.LIB.  If not,
write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,
Boston, MA 02110-1301, USA.  */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>	/* May get P_tmpdir.  */
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#endif

#include "libiberty.h"
extern char *choose_tmpdir (void);

/* Name of temporary file.
   mktemp requires 6 trailing X's.  */
#define TEMP_FILE "ccXXXXXX"
#define TEMP_FILE_LEN (sizeof(TEMP_FILE) - 1)

/*

@@deftypefn Extension char* choose_temp_base (void)

Return a prefix for temporary file names or @@code{NULL} if unable to
find one.  The current directory is chosen if all else fails so the
program is exited if a temporary directory can't be found (@@code{mktemp}
fails).  The buffer for the result is obtained with @@code{xmalloc}.

This function is provided for backwards compatability only.  Its use is
not recommended.

@@end deftypefn

*/

#if defined(__MSDOS__) && !defined(__GO32__)
char *
choose_temp_base (void)
{
  const char *base = choose_tmpdir ();
  char *temp_filename;
  int len;

  len = strlen (base);
  temp_filename = XNEWVEC (char, len + TEMP_FILE_LEN + 1);
  strcpy (temp_filename, base);
  strcpy (temp_filename + len, TEMP_FILE);

  mktemp (temp_filename);
  if (strlen (temp_filename) == 0)
    abort ();
  return temp_filename;
}
#endif
@


1.4
log
@Merge OpenBSD specific changes:
- pexecute implementation replaced with the older gcc 2.95 implementation,
  as gcc 2.95's collect2 relies upon an implementation behaviour which has
  been lost in further libiberty updates.
- keep the old hash table interfaces, which are used by gcc 2.95.
- keep the OpenBSD replacement for the md5 interface.
- keep the OpenBSD strl{cat,cpy} and snprinft usage.

Bump libiberty minor version due to the addition of a few new symbols.
@
text
@d56 1
d74 1
@


1.3
log
@fix stupid cvs conflicts.
I think that cvs is a poor lonesome, depressive program.
The only way it has found of getting your attention is to throw
senseless conflicts that shouldn't exist in your way.
@
text
@d17 2
a18 2
write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */
d33 1
a33 1
extern char *choose_tmpdir PARAMS ((void));
a55 1
#if defined(__MSDOS__) && !defined(__GO32__)
d57 1
a57 1
choose_temp_base ()
d64 1
a64 1
  temp_filename = xmalloc (len + TEMP_FILE_LEN + 1);
a72 1
#endif
@


1.2
log
@OpenBSD changes: synch somewhere between binutils-2.10 and 2.11
Support for mkstemps in choose-temp.
@
text
@a19 2
/* This file exports two functions: choose_temp_base and make_temp_file.  */

a24 4
#include <sys/types.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
a30 9
#ifdef HAVE_SYS_FILE_H
#include <sys/file.h>   /* May get R_OK, etc. on some systems.  */
#endif

#ifndef R_OK
#define R_OK 4
#define W_OK 2
#define X_OK 1
#endif
d33 1
a33 1
extern int mkstemps ();
d35 4
a38 5
#ifndef IN_GCC
#if defined (__MSDOS__) || (defined (_WIN32) && ! defined (__CYGWIN__) && ! defined (_UWIN))
#define DIR_SEPARATOR '\\'
#endif
#endif
d40 1
a40 3
#ifndef DIR_SEPARATOR
#define DIR_SEPARATOR '/'
#endif
d42 1
a42 11
/* On MSDOS, write temp files in current dir
   because there's no place else we can expect to use.  */
/* ??? Although the current directory is tried as a last resort,
   this is left in so that on MSDOS it is preferred to /tmp on the
   off chance that someone requires this, since that was the previous
   behaviour.  */
#ifdef __MSDOS__
#ifndef P_tmpdir
#define P_tmpdir "."
#endif
#endif
d44 4
a47 3
/* Name of temporary file.
   mktemp requires 6 trailing X's.  */
#define TEMP_FILE "ccXXXXXX"
d49 2
a50 17
/* Subroutine of choose_temp_base.
   If BASE is non-NULL, return it.
   Otherwise it checks if DIR is a usable directory.
   If success, DIR is returned.
   Otherwise NULL is returned.  */

static char *
try (dir, base)
     char *dir, *base;
{
  if (base != 0)
    return base;
  if (dir != 0
      && access (dir, R_OK | W_OK | X_OK) == 0)
    return dir;
  return 0;
}
d52 1
a52 5
#if defined(__MSDOS__) && !defined(__GO32__)
/* Return a prefix for temporary file names or NULL if unable to find one.
   The current directory is chosen if all else fails so the program is
   exited if a temporary directory can't be found (mktemp fails).
   The buffer for the result is obtained with xmalloc. 
d54 1
a54 2
   This function is provided for backwards compatability only.  It use
   is not recommended.  */
d56 1
d60 1
a60 1
  char *base = 0;
a62 18
  static char tmp[] = { DIR_SEPARATOR, 't', 'm', 'p', 0 };
  static char usrtmp[] = { DIR_SEPARATOR, 'u', 's', 'r', DIR_SEPARATOR, 't', 'm', 'p', 0 };

  base = try (getenv ("TMPDIR"), base);
  base = try (getenv ("TMP"), base);
  base = try (getenv ("TEMP"), base);

#ifdef P_tmpdir
  base = try (P_tmpdir, base);
#endif

  /* Try /usr/tmp, then /tmp.  */
  base = try (usrtmp, base);
  base = try (tmp, base);
 
  /* If all else fails, use the current directory!  */
  if (base == 0)
    base = ".";
d65 1
a65 2
  temp_filename = xmalloc (len + 1 /*DIR_SEPARATOR*/
			   + strlen (TEMP_FILE) + 1);
a66 5

  if (len != 0
      && temp_filename[len-1] != '/'
      && temp_filename[len-1] != DIR_SEPARATOR)
    temp_filename[len++] = DIR_SEPARATOR;
a74 62

/* Return a temporary file name (as a string) or NULL if unable to create
   one.  */

char *
make_temp_file (suffix)
     const char *suffix;
{
  char *base = 0;
  char *temp_filename;
  int base_len, suffix_len;
  int fd;
  static char tmp[] = { DIR_SEPARATOR, 't', 'm', 'p', 0 };
  static char usrtmp[] = { DIR_SEPARATOR, 'u', 's', 'r', DIR_SEPARATOR, 't', 'm', 'p', 0 };

  base = try (getenv ("TMPDIR"), base);
  base = try (getenv ("TMP"), base);
  base = try (getenv ("TEMP"), base);

#ifdef P_tmpdir
  base = try (P_tmpdir, base);
#endif

  /* Try /usr/tmp, then /tmp.  */
  base = try (usrtmp, base);
  base = try (tmp, base);
 
  /* If all else fails, use the current directory!  */
  if (base == 0)
    base = ".";

  base_len = strlen (base);

  if (suffix)
    suffix_len = strlen (suffix);
  else
    suffix_len = 0;

  temp_filename = xmalloc (base_len + 1 /*DIR_SEPARATOR*/
			   + strlen (TEMP_FILE)
			   + suffix_len + 1);
  strcpy (temp_filename, base);

  if (base_len != 0
      && temp_filename[base_len-1] != '/'
      && temp_filename[base_len-1] != DIR_SEPARATOR)
    temp_filename[base_len++] = DIR_SEPARATOR;
  strcpy (temp_filename + base_len, TEMP_FILE);

  if (suffix)
    strcat (temp_filename, suffix);

  fd = mkstemps (temp_filename, suffix_len);
  /* If mkstemps failed, then something bad is happening.  Maybe we should
     issue a message about a possible security attack in progress?  */
  if (fd == -1)
    abort ();
  /* Similarly if we can not close the file.  */
  if (close (fd))
    abort ();
  return temp_filename;
}
@


1.1
log
@Initial revision
@
text
@d94 1
d144 2
@


1.1.1.1
log
@Moving libiberty around, keeping vendor branch.
First: binutils-2.10.
@
text
@@


1.1.1.2
log
@Second import from the vendor branch: binutils-2.11.2
@
text
@d82 1
a82 3
static const char *try PARAMS ((const char *, const char *));

static const char *
d84 1
a84 1
     const char *dir, *base;
d105 1
a105 1
  const char *base = 0;
d150 1
a150 1
  const char *base = 0;
@


1.1.1.3
log
@Synch with gcc-3.3.2 version
@
text
@d20 2
d27 4
d37 9
d48 23
a70 1
extern char *choose_tmpdir PARAMS ((void));
a74 1
#define TEMP_FILE_LEN (sizeof(TEMP_FILE) - 1)
d76 24
a99 8
/*

@@deftypefn Extension char* choose_temp_base (void)

Return a prefix for temporary file names or @@code{NULL} if unable to
find one.  The current directory is chosen if all else fails so the
program is exited if a temporary directory can't be found (@@code{mktemp}
fails).  The buffer for the result is obtained with @@code{xmalloc}.
d101 2
a102 6
This function is provided for backwards compatability only.  Its use is
not recommended.

@@end deftypefn

*/
d107 1
a107 1
  const char *base = choose_tmpdir ();
d110 18
d130 2
a131 1
  temp_filename = xmalloc (len + TEMP_FILE_LEN + 1);
d133 5
d142 61
@


1.1.1.4
log
@Update libiberty to the version found in binutils 2.17.1 (which still
identifies itself as the gcc 3 version...)
@
text
@d17 2
a18 2
write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,
Boston, MA 02110-1301, USA.  */
d33 1
a33 1
extern char *choose_tmpdir (void);
d57 1
a57 1
choose_temp_base (void)
d64 1
a64 1
  temp_filename = XNEWVEC (char, len + TEMP_FILE_LEN + 1);
@


