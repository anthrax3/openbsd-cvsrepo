head	1.7;
access;
symbols
	OPENBSD_6_0:1.7.0.8
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.4
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.28
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.26
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.22
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.20
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.18
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.16
	OPENBSD_5_0:1.6.0.14
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.12
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.10
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.6
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.8
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.4
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	BINUTILS_2_17_1:1.1.1.6
	OPENBSD_4_3:1.5.0.18
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.16
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.14
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.12
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	gcc-3_3_5:1.1.1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	binutils-2_14:1.1.1.4
	gcc-3_3_2:1.1.1.3
	binutils-2_11_2:1.1.1.2
	binutils-2_10:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.01.19.19.46.55;	author miod;	state Exp;
branches;
next	1.6;
commitid	VWp1VUHKntro1hNc;

1.6
date	2008.05.27.18.52.43;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.25.18.02.31;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.25.21.17.01;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.25.21.06.18;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.24.16.47.34;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2003.11.24.16.31.36;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.24.16.31.36;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.11.24.16.34.11;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.11.25.20.39.04;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.25.17.53.26;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.12.24.21.48.31;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.05.27.18.46.00;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Prefer strdup() to malloc() + strcpy() and ftello() to ftell()
ok deraadt@@ guenther@@ millert@@
@
text
@/* Create and destroy argument vectors (argv's)
   Copyright (C) 1992, 2001 Free Software Foundation, Inc.
   Written by Fred Fish @@ Cygnus Support

This file is part of the libiberty library.
Libiberty is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

Libiberty is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with libiberty; see the file COPYING.LIB.  If
not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,
Boston, MA 02110-1301, USA.  */


/*  Create and destroy argument vectors.  An argument vector is simply an
    array of string pointers, terminated by a NULL pointer. */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
#include "ansidecl.h"
#include "libiberty.h"
#include "safe-ctype.h"

/*  Routines imported from standard C runtime libraries. */

#include <stddef.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#ifndef NULL
#define NULL 0
#endif

#ifndef EOS
#define EOS '\0'
#endif

#define INITIAL_MAXARGC 8	/* Number of args + NULL in initial argv */


/*

@@deftypefn Extension char** dupargv (char **@@var{vector})

Duplicate an argument vector.  Simply scans through @@var{vector},
duplicating each argument until the terminating @@code{NULL} is found.
Returns a pointer to the argument vector if successful.  Returns
@@code{NULL} if there is insufficient memory to complete building the
argument vector.

@@end deftypefn

*/

char **
dupargv (char **argv)
{
  int argc;
  char **copy;
  
  if (argv == NULL)
    return NULL;
  
  /* the vector */
  for (argc = 0; argv[argc] != NULL; argc++);
  copy = (char **) malloc ((argc + 1) * sizeof (char *));
  if (copy == NULL)
    return NULL;
  
  /* the strings */
  for (argc = 0; argv[argc] != NULL; argc++)
    {
      copy[argc] = strdup (argv[argc]);
      if (copy[argc] == NULL)
	{
	  freeargv (copy);
	  return NULL;
	}
    }
  copy[argc] = NULL;
  return copy;
}

/*

@@deftypefn Extension void freeargv (char **@@var{vector})

Free an argument vector that was built using @@code{buildargv}.  Simply
scans through @@var{vector}, freeing the memory for each argument until
the terminating @@code{NULL} is found, and then frees @@var{vector}
itself.

@@end deftypefn

*/

void freeargv (char **vector)
{
  register char **scan;

  if (vector != NULL)
    {
      for (scan = vector; *scan != NULL; scan++)
	{
	  free (*scan);
	}
      free (vector);
    }
}

/*

@@deftypefn Extension char** buildargv (char *@@var{sp})

Given a pointer to a string, parse the string extracting fields
separated by whitespace and optionally enclosed within either single
or double quotes (which are stripped off), and build a vector of
pointers to copies of the string for each field.  The input string
remains unchanged.  The last element of the vector is followed by a
@@code{NULL} element.

All of the memory for the pointer array and copies of the string
is obtained from @@code{malloc}.  All of the memory can be returned to the
system with the single function call @@code{freeargv}, which takes the
returned result of @@code{buildargv}, as it's argument.

Returns a pointer to the argument vector if successful.  Returns
@@code{NULL} if @@var{sp} is @@code{NULL} or if there is insufficient
memory to complete building the argument vector.

If the input is a null string (as opposed to a @@code{NULL} pointer),
then buildarg returns an argument vector that has one arg, a null
string.

@@end deftypefn

The memory for the argv array is dynamically expanded as necessary.

In order to provide a working buffer for extracting arguments into,
with appropriate stripping of quotes and translation of backslash
sequences, we allocate a working buffer at least as long as the input
string.  This ensures that we always have enough space in which to
work, since the extracted arg is never larger than the input string.

The argument vector is always kept terminated with a @@code{NULL} arg
pointer, so it can be passed to @@code{freeargv} at any time, or
returned, as appropriate.

*/

char **buildargv (const char *input)
{
  char *arg;
  char *copybuf;
  int squote = 0;
  int dquote = 0;
  int bsquote = 0;
  int argc = 0;
  int maxargc = 0;
  char **argv = NULL;
  char **nargv;

  if (input != NULL)
    {
      copybuf = (char *) alloca (strlen (input) + 1);
      /* Is a do{}while to always execute the loop once.  Always return an
	 argv, even for null strings.  See NOTES above, test case below. */
      do
	{
	  /* Pick off argv[argc] */
	  while (ISBLANK (*input))
	    {
	      input++;
	    }
	  if ((maxargc == 0) || (argc >= (maxargc - 1)))
	    {
	      /* argv needs initialization, or expansion */
	      if (argv == NULL)
		{
		  maxargc = INITIAL_MAXARGC;
		  nargv = (char **) malloc (maxargc * sizeof (char *));
		}
	      else
		{
		  maxargc *= 2;
		  nargv = (char **) realloc (argv, maxargc * sizeof (char *));
		}
	      if (nargv == NULL)
		{
		  if (argv != NULL)
		    {
		      freeargv (argv);
		      argv = NULL;
		    }
		  break;
		}
	      argv = nargv;
	      argv[argc] = NULL;
	    }
	  /* Begin scanning arg */
	  arg = copybuf;
	  while (*input != EOS)
	    {
	      if (ISSPACE (*input) && !squote && !dquote && !bsquote)
		{
		  break;
		}
	      else
		{
		  if (bsquote)
		    {
		      bsquote = 0;
		      *arg++ = *input;
		    }
		  else if (*input == '\\')
		    {
		      bsquote = 1;
		    }
		  else if (squote)
		    {
		      if (*input == '\'')
			{
			  squote = 0;
			}
		      else
			{
			  *arg++ = *input;
			}
		    }
		  else if (dquote)
		    {
		      if (*input == '"')
			{
			  dquote = 0;
			}
		      else
			{
			  *arg++ = *input;
			}
		    }
		  else
		    {
		      if (*input == '\'')
			{
			  squote = 1;
			}
		      else if (*input == '"')
			{
			  dquote = 1;
			}
		      else
			{
			  *arg++ = *input;
			}
		    }
		  input++;
		}
	    }
	  *arg = EOS;
	  argv[argc] = strdup (copybuf);
	  if (argv[argc] == NULL)
	    {
	      freeargv (argv);
	      argv = NULL;
	      break;
	    }
	  argc++;
	  argv[argc] = NULL;

	  while (ISSPACE (*input))
	    {
	      input++;
	    }
	}
      while (*input != EOS);
    }
  return (argv);
}

/*

@@deftypefn Extension void expandargv (int *@@var{argcp}, char ***@@var{argvp})

The @@var{argcp} and @@code{argvp} arguments are pointers to the usual
@@code{argc} and @@code{argv} arguments to @@code{main}.  This function
looks for arguments that begin with the character @@samp{@@@@}.  Any such
arguments are interpreted as ``response files''.  The contents of the
response file are interpreted as additional command line options.  In
particular, the file is separated into whitespace-separated strings;
each such string is taken as a command-line option.  The new options
are inserted in place of the option naming the response file, and
@@code{*argcp} and @@code{*argvp} will be updated.  If the value of
@@code{*argvp} is modified by this function, then the new value has
been dynamically allocated and can be deallocated by the caller with
@@code{freeargv}.  However, most callers will simply call
@@code{expandargv} near the beginning of @@code{main} and allow the
operating system to free the memory when the program exits.

@@end deftypefn

*/

void
expandargv (argcp, argvp)
     int *argcp;
     char ***argvp;
{
  /* The argument we are currently processing.  */
  int i = 0;
  /* Non-zero if ***argvp has been dynamically allocated.  */
  int argv_dynamic = 0;
  /* Loop over the arguments, handling response files.  We always skip
     ARGVP[0], as that is the name of the program being run.  */
  while (++i < *argcp)
    {
      /* The name of the response file.  */
      const char *filename;
      /* The response file.  */
      FILE *f;
      /* An upper bound on the number of characters in the response
	 file.  */
      off_t pos;
      /* The number of characters in the response file, when actually
	 read.  */
      size_t len;
      /* A dynamically allocated buffer used to hold options read from a
	 response file.  */
      char *buffer;
      /* Dynamically allocated storage for the options read from the
	 response file.  */
      char **file_argv;
      /* The number of options read from the response file, if any.  */
      size_t file_argc;
      /* We are only interested in options of the form "@@file".  */
      filename = (*argvp)[i];
      if (filename[0] != '@@')
	continue;
      /* Read the contents of the file.  */
      f = fopen (++filename, "r");
      if (!f)
	continue;
      if (fseek (f, 0L, SEEK_END) == -1)
	goto error;
      pos = ftello (f);
      if (pos == -1)
	goto error;
      if (fseek (f, 0L, SEEK_SET) == -1)
	goto error;
      buffer = (char *) xmalloc (pos * sizeof (char) + 1);
      len = fread (buffer, sizeof (char), pos, f);
      if (len != (size_t) pos
	  /* On Windows, fread may return a value smaller than POS,
	     due to CR/LF->CR translation when reading text files.
	     That does not in-and-of itself indicate failure.  */
	  && ferror (f))
	goto error;
      /* Add a NUL terminator.  */
      buffer[len] = '\0';
      /* Parse the string.  */
      file_argv = buildargv (buffer);
      /* If *ARGVP is not already dynamically allocated, copy it.  */
      if (!argv_dynamic)
	{
	  *argvp = dupargv (*argvp);
	  if (!*argvp)
	    {
	      fputs ("\nout of memory\n", stderr);
	      xexit (1);
	    }
	}
      /* Count the number of arguments.  */
      file_argc = 0;
      while (file_argv[file_argc] && *file_argv[file_argc])
	++file_argc;
      /* Now, insert FILE_ARGV into ARGV.  The "+1" below handles the
	 NULL terminator at the end of ARGV.  */ 
      *argvp = ((char **) 
		xrealloc (*argvp, 
			  (*argcp + file_argc + 1) * sizeof (char *)));
      memmove (*argvp + i + file_argc, *argvp + i + 1, 
	       (*argcp - i) * sizeof (char *));
      memcpy (*argvp + i, file_argv, file_argc * sizeof (char *));
      /* The original option has been replaced by all the new
	 options.  */
      *argcp += file_argc - 1;
      /* Free up memory allocated to process the response file.  We do
	 not use freeargv because the individual options in FILE_ARGV
	 are now in the main ARGV.  */
      free (file_argv);
      free (buffer);
      /* Rescan all of the arguments just read to support response
	 files that include other response files.  */
      --i;
    error:
      /* We're all done with the file now.  */
      fclose (f);
    }
}

#ifdef MAIN

/* Simple little test driver. */

static const char *const tests[] =
{
  "a simple command line",
  "arg 'foo' is single quoted",
  "arg \"bar\" is double quoted",
  "arg \"foo bar\" has embedded whitespace",
  "arg 'Jack said \\'hi\\'' has single quotes",
  "arg 'Jack said \\\"hi\\\"' has double quotes",
  "a b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9",
  
  /* This should be expanded into only one argument.  */
  "trailing-whitespace ",

  "",
  NULL
};

int
main (void)
{
  char **argv;
  const char *const *test;
  char **targs;

  for (test = tests; *test != NULL; test++)
    {
      printf ("buildargv(\"%s\")\n", *test);
      if ((argv = buildargv (*test)) == NULL)
	{
	  printf ("failed!\n\n");
	}
      else
	{
	  for (targs = argv; *targs != NULL; targs++)
	    {
	      printf ("\t\"%s\"\n", *targs);
	    }
	  printf ("\n");
	}
      freeargv (argv);
    }

  return 0;
}

#endif	/* MAIN */
@


1.6
log
@Merge OpenBSD specific changes:
- pexecute implementation replaced with the older gcc 2.95 implementation,
  as gcc 2.95's collect2 relies upon an implementation behaviour which has
  been lost in further libiberty updates.
- keep the old hash table interfaces, which are used by gcc 2.95.
- keep the OpenBSD replacement for the md5 interface.
- keep the OpenBSD strl{cat,cpy} and snprinft usage.

Bump libiberty minor version due to the addition of a few new symbols.
@
text
@d82 1
a82 2
      int len = strlen (argv[argc]);
      copy[argc] = (char *) malloc (len + 1);
a87 1
      strcpy (copy[argc], argv[argc]);
d331 1
a331 1
      long pos;
d353 1
a353 1
      pos = ftell (f);
@


1.5
log
@Automatic merge
@
text
@d18 2
a19 2
not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */
d25 3
d30 1
a30 2

#define ISBLANK(ch) ((ch) == ' ' || (ch) == '\t')
a33 2
#ifdef ANSI_PROTOTYPES

d37 1
a37 14

#else	/* !ANSI_PROTOTYPES */

#if !defined _WIN32 || defined __GNUC__
extern char *memcpy ();		/* Copy memory region */
extern int strlen ();		/* Count length of string */
extern char *malloc ();		/* Standard memory allocater */
extern char *realloc ();	/* Standard memory reallocator */
extern void free ();		/* Free malloc'd memory */
extern char *strdup ();		/* Duplicate a string */
#endif

#endif	/* ANSI_PROTOTYPES */

d65 1
a65 2
dupargv (argv)
     char **argv;
d83 1
a83 1
      copy[argc] = malloc (sizeof (char *) * (len + 1));
d108 1
a108 2
void freeargv (vector)
char **vector;
d162 1
a162 2
char **buildargv (input)
     const char *input;
d215 1
a215 1
	      if (ISBLANK (*input) && !squote && !dquote && !bsquote)
d281 1
a281 1
	  while (ISBLANK (*input))
d291 120
d432 2
a433 1
int main ()
@


1.4
log
@fix instances of cvs brain-damage. We want the current FSF version of
these files.
@
text
@d32 1
a32 1
#ifdef __STDC__
d38 1
a38 1
#else	/* !__STDC__ */
d49 1
a49 1
#endif	/* __STDC__ */
@


1.3
log
@fix stupid cvs conflicts.
I think that cvs is a poor lonesome, depressive program.
The only way it has found of getting your attention is to throw
senseless conflicts that shouldn't exist in your way.
@
text
@d28 1
a28 4
#ifdef isspace
#undef isspace
#endif
#define isspace(ch) ((ch) == ' ' || (ch) == '\t')
d198 1
a198 1
	  while (isspace (*input))
d231 1
a231 1
	      if (isspace (*input) && !squote && !dquote && !bsquote)
d297 1
a297 1
	  while (isspace (*input))
@


1.2
log
@OpenBSD changes: synch somewhere between binutils-2.10 and 2.11
Support for mkstemps in choose-temp.
@
text
@d2 1
a2 1
   Copyright (C) 1992 Free Software Foundation, Inc.
a53 1
#include "alloca-conf.h"
d68 1
a68 1
NAME
d70 5
a74 1
	dupargv -- duplicate an argument vector
d76 1
a76 16
SYNOPSIS

	char **dupargv (vector)
	char **vector;

DESCRIPTION

	Duplicate an argument vector.  Simply scans through the
	vector, duplicating each argument until the
	terminating NULL is found.

RETURNS

	Returns a pointer to the argument vector if
	successful. Returns NULL if there is insufficient memory to
	complete building the argument vector.
d114 1
a114 3
NAME

	freeargv -- free an argument vector
d116 4
a119 1
SYNOPSIS
d121 1
a121 12
	void freeargv (vector)
	char **vector;

DESCRIPTION

	Free an argument vector that was built using buildargv.  Simply scans
	through the vector, freeing the memory for each argument until the
	terminating NULL is found, and then frees the vector itself.

RETURNS

	No value.
d142 1
a142 37
NAME

	buildargv -- build an argument vector from a string

SYNOPSIS

	char **buildargv (sp)
	char *sp;

DESCRIPTION

	Given a pointer to a string, parse the string extracting fields
	separated by whitespace and optionally enclosed within either single
	or double quotes (which are stripped off), and build a vector of
	pointers to copies of the string for each field.  The input string
	remains unchanged.

	All of the memory for the pointer array and copies of the string
	is obtained from malloc.  All of the memory can be returned to the
	system with the single function call freeargv, which takes the
	returned result of buildargv, as it's argument.

	The memory for the argv array is dynamically expanded as necessary.

RETURNS

	Returns a pointer to the argument vector if successful. Returns NULL
	if the input string pointer is NULL or if there is insufficient
	memory to complete building the argument vector.

NOTES

	In order to provide a working buffer for extracting arguments into,
	with appropriate stripping of quotes and translation of backslash
	sequences, we allocate a working buffer at least as long as the input
	string.  This ensures that we always have enough space in which to
	work, since the extracted arg is never larger than the input string.
d144 33
a176 2
	If the input is a null string (as opposed to a NULL pointer), then
	buildarg returns an argv that has one arg, a null string.
a177 2
	Argv is always kept terminated with a NULL arg pointer, so it can
	be passed to freeargv at any time, or returned, as appropriate.
d181 1
a181 1
char *input;
d314 1
a314 1
static char *tests[] =
d331 1
a331 1
main ()
d334 1
a334 1
  char **test;
d355 1
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Moving libiberty around, keeping vendor branch.
First: binutils-2.10.
@
text
@@


1.1.1.2
log
@Second import from the vendor branch: binutils-2.11.2
@
text
@d28 4
a31 1
#define ISBLANK(ch) ((ch) == ' ' || (ch) == '\t')
d230 1
a230 1
	  while (ISBLANK (*input))
d263 1
a263 1
	      if (ISBLANK (*input) && !squote && !dquote && !bsquote)
d329 1
a329 1
	  while (ISBLANK (*input))
@


1.1.1.3
log
@Synch with gcc-3.3.2 version
@
text
@d2 1
a2 1
   Copyright (C) 1992, 2001 Free Software Foundation, Inc.
d51 1
d66 1
a66 1
@@deftypefn Extension char** dupargv (char **@@var{vector})
d68 1
a68 5
Duplicate an argument vector.  Simply scans through @@var{vector},
duplicating each argument until the terminating @@code{NULL} is found.
Returns a pointer to the argument vector if successful.  Returns
@@code{NULL} if there is insufficient memory to complete building the
argument vector.
d70 16
a85 1
@@end deftypefn
d123 3
a125 1
@@deftypefn Extension void freeargv (char **@@var{vector})
d127 1
a127 4
Free an argument vector that was built using @@code{buildargv}.  Simply
scans through @@var{vector}, freeing the memory for each argument until
the terminating @@code{NULL} is found, and then frees @@var{vector}
itself.
d129 12
a140 1
@@end deftypefn
d161 37
a197 1
@@deftypefn Extension char** buildargv (char *@@var{sp})
d199 2
a200 33
Given a pointer to a string, parse the string extracting fields
separated by whitespace and optionally enclosed within either single
or double quotes (which are stripped off), and build a vector of
pointers to copies of the string for each field.  The input string
remains unchanged.  The last element of the vector is followed by a
@@code{NULL} element.

All of the memory for the pointer array and copies of the string
is obtained from @@code{malloc}.  All of the memory can be returned to the
system with the single function call @@code{freeargv}, which takes the
returned result of @@code{buildargv}, as it's argument.

Returns a pointer to the argument vector if successful.  Returns
@@code{NULL} if @@var{sp} is @@code{NULL} or if there is insufficient
memory to complete building the argument vector.

If the input is a null string (as opposed to a @@code{NULL} pointer),
then buildarg returns an argument vector that has one arg, a null
string.

@@end deftypefn

The memory for the argv array is dynamically expanded as necessary.

In order to provide a working buffer for extracting arguments into,
with appropriate stripping of quotes and translation of backslash
sequences, we allocate a working buffer at least as long as the input
string.  This ensures that we always have enough space in which to
work, since the extracted arg is never larger than the input string.

The argument vector is always kept terminated with a @@code{NULL} arg
pointer, so it can be passed to @@code{freeargv} at any time, or
returned, as appropriate.
d202 2
d207 1
a207 1
     const char *input;
d340 1
a340 1
static const char *const tests[] =
d357 1
a357 1
int main ()
d360 1
a360 1
  const char *const *test;
a380 1
  return 0;
@


1.1.1.4
log
@Update to libiberty from binutils-2.14
@
text
@d32 1
a32 1
#ifdef ANSI_PROTOTYPES
d38 1
a38 1
#else	/* !ANSI_PROTOTYPES */
d49 1
a49 1
#endif	/* ANSI_PROTOTYPES */
@


1.1.1.5
log
@update to gcc 3.3.5
@
text
@d32 1
a32 1
#ifdef __STDC__
d38 1
a38 1
#else	/* !__STDC__ */
d49 1
a49 1
#endif	/* __STDC__ */
@


1.1.1.6
log
@Update libiberty to the version found in binutils 2.17.1 (which still
identifies itself as the gcc 3 version...)
@
text
@d18 2
a19 2
not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,
Boston, MA 02110-1301, USA.  */
a24 3
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
d27 2
a28 1
#include "safe-ctype.h"
d32 2
d37 14
a50 1
#include <stdio.h>
d78 2
a79 1
dupargv (char **argv)
d97 1
a97 1
      copy[argc] = (char *) malloc (len + 1);
d122 2
a123 1
void freeargv (char **vector)
d177 2
a178 1
char **buildargv (const char *input)
d231 1
a231 1
	      if (ISSPACE (*input) && !squote && !dquote && !bsquote)
d297 1
a297 1
	  while (ISSPACE (*input))
a306 120
/*

@@deftypefn Extension void expandargv (int *@@var{argcp}, char ***@@var{argvp})

The @@var{argcp} and @@code{argvp} arguments are pointers to the usual
@@code{argc} and @@code{argv} arguments to @@code{main}.  This function
looks for arguments that begin with the character @@samp{@@@@}.  Any such
arguments are interpreted as ``response files''.  The contents of the
response file are interpreted as additional command line options.  In
particular, the file is separated into whitespace-separated strings;
each such string is taken as a command-line option.  The new options
are inserted in place of the option naming the response file, and
@@code{*argcp} and @@code{*argvp} will be updated.  If the value of
@@code{*argvp} is modified by this function, then the new value has
been dynamically allocated and can be deallocated by the caller with
@@code{freeargv}.  However, most callers will simply call
@@code{expandargv} near the beginning of @@code{main} and allow the
operating system to free the memory when the program exits.

@@end deftypefn

*/

void
expandargv (argcp, argvp)
     int *argcp;
     char ***argvp;
{
  /* The argument we are currently processing.  */
  int i = 0;
  /* Non-zero if ***argvp has been dynamically allocated.  */
  int argv_dynamic = 0;
  /* Loop over the arguments, handling response files.  We always skip
     ARGVP[0], as that is the name of the program being run.  */
  while (++i < *argcp)
    {
      /* The name of the response file.  */
      const char *filename;
      /* The response file.  */
      FILE *f;
      /* An upper bound on the number of characters in the response
	 file.  */
      long pos;
      /* The number of characters in the response file, when actually
	 read.  */
      size_t len;
      /* A dynamically allocated buffer used to hold options read from a
	 response file.  */
      char *buffer;
      /* Dynamically allocated storage for the options read from the
	 response file.  */
      char **file_argv;
      /* The number of options read from the response file, if any.  */
      size_t file_argc;
      /* We are only interested in options of the form "@@file".  */
      filename = (*argvp)[i];
      if (filename[0] != '@@')
	continue;
      /* Read the contents of the file.  */
      f = fopen (++filename, "r");
      if (!f)
	continue;
      if (fseek (f, 0L, SEEK_END) == -1)
	goto error;
      pos = ftell (f);
      if (pos == -1)
	goto error;
      if (fseek (f, 0L, SEEK_SET) == -1)
	goto error;
      buffer = (char *) xmalloc (pos * sizeof (char) + 1);
      len = fread (buffer, sizeof (char), pos, f);
      if (len != (size_t) pos
	  /* On Windows, fread may return a value smaller than POS,
	     due to CR/LF->CR translation when reading text files.
	     That does not in-and-of itself indicate failure.  */
	  && ferror (f))
	goto error;
      /* Add a NUL terminator.  */
      buffer[len] = '\0';
      /* Parse the string.  */
      file_argv = buildargv (buffer);
      /* If *ARGVP is not already dynamically allocated, copy it.  */
      if (!argv_dynamic)
	{
	  *argvp = dupargv (*argvp);
	  if (!*argvp)
	    {
	      fputs ("\nout of memory\n", stderr);
	      xexit (1);
	    }
	}
      /* Count the number of arguments.  */
      file_argc = 0;
      while (file_argv[file_argc] && *file_argv[file_argc])
	++file_argc;
      /* Now, insert FILE_ARGV into ARGV.  The "+1" below handles the
	 NULL terminator at the end of ARGV.  */ 
      *argvp = ((char **) 
		xrealloc (*argvp, 
			  (*argcp + file_argc + 1) * sizeof (char *)));
      memmove (*argvp + i + file_argc, *argvp + i + 1, 
	       (*argcp - i) * sizeof (char *));
      memcpy (*argvp + i, file_argv, file_argc * sizeof (char *));
      /* The original option has been replaced by all the new
	 options.  */
      *argcp += file_argc - 1;
      /* Free up memory allocated to process the response file.  We do
	 not use freeargv because the individual options in FILE_ARGV
	 are now in the main ARGV.  */
      free (file_argv);
      free (buffer);
      /* Rescan all of the arguments just read to support response
	 files that include other response files.  */
      --i;
    error:
      /* We're all done with the file now.  */
      fclose (f);
    }
}

d328 1
a328 2
int
main (void)
@


