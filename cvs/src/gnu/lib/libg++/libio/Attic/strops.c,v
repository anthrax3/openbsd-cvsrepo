head	1.2;
access;
symbols
	OPENBSD_2_5:1.1.1.2.0.6
	OPENBSD_2_5_BASE:1.1.1.2
	OPENBSD_2_4:1.1.1.2.0.4
	OPENBSD_2_4_BASE:1.1.1.2
	OPENBSD_2_3:1.1.1.2.0.2
	OPENBSD_2_3_BASE:1.1.1.2
	FSF_2_8_0:1.1.1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	FSF_2_7_1:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	99.05.26.16.37.29;	author espie;	state dead;
branches;
next	1.1;

1.1
date	96.03.15.22.19.55;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.03.15.22.19.55;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.03.03.20.22.15;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@old libg++, replaced by part of egcs.
@
text
@/* 
Copyright (C) 1993 Free Software Foundation

This file is part of the GNU IO Library.  This library is free
software; you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option)
any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this library; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

As a special exception, if you link this library with files
compiled with a GNU compiler to produce an executable, this does not cause
the resulting executable to be covered by the GNU General Public License.
This exception does not however invalidate any other reasons why
the executable file might be covered by the GNU General Public License. */

#include "strfile.h"
#include "libioP.h"
#include <string.h>

#define LEN(fp) (((_IO_strfile*)(fp))->_s._len)

#ifdef TODO
/* An "unbounded buffer" is when a buffer is supplied, but with no
   specified length.  An example is the buffer argument to sprintf.
   */
#endif

void
DEFUN(_IO_str_init_static, (fp, ptr, size, pstart),
      _IO_FILE *fp AND char *ptr AND int size AND char *pstart)
{
  if (size == 0)
    size = strlen(ptr);
  else if (size < 0)
    {
      /* If size is negative 'the characters are assumed to
	 continue indefinitely.'  This is kind of messy ... */
#if 1
      int s;
      size = 512;
      /* Try increasing powers of 2, as long as we don't wrap around.
	 This can lose in pathological cases (ptr near the end
	 of the address space).  A better solution might be to
	 adjust the size on underflow/overflow.  FIXME. */
      for (s; s = 2*size, s > 0 && ptr + s > ptr && s < 0x4000000L; )
	size = s;
      size = s;
#else
      /* The following semi-portable kludge assumes that
	 sizeof(unsigned long) == sizeof(char*). Hence,
	 (unsigned long)(-1) should be the largest possible address. */
      unsigned long highest = (unsigned long)(-1);
      /* Pointers are signed on some brain-damaged systems, in
	 which case we divide by two to get the maximum signed address. */
      if  ((char*)highest < ptr)
	highest >>= 1;
      size = (char*)highest - ptr;
#endif
    }
  _IO_setb(fp, ptr, ptr+size, 0);

  fp->_IO_write_base = ptr;
  fp->_IO_read_base = ptr;
  fp->_IO_read_ptr = ptr;
  if (pstart)
    {
      fp->_IO_write_ptr = pstart;
      fp->_IO_write_end = ptr+size;
      fp->_IO_read_end = pstart;
    }
  else
    {
      fp->_IO_write_ptr = ptr;
      fp->_IO_write_end = ptr;
      fp->_IO_read_end = ptr+size;
    }
  LEN(fp) = size;
  /* A null _allocate_buffer function flags the strfile as being static. */
  (((_IO_strfile*)(fp))->_s._allocate_buffer) =  (_IO_alloc_type)0;
}

void
DEFUN(_IO_str_init_readonly, (fp, ptr, size),
      _IO_FILE *fp AND const char *ptr AND int size)
{
  _IO_str_init_static (fp, (char*)ptr, size, NULL);
  fp->_IO_file_flags |= _IO_NO_WRITES;
}

int
DEFUN(_IO_str_overflow, (fp, c),
      register _IO_FILE* fp AND int c)
{
  int flush_only = c == EOF;
  _IO_size_t pos = fp->_IO_write_ptr - fp->_IO_write_base;
  _IO_size_t get_pos = fp->_IO_read_ptr - fp->_IO_read_base;
  if (fp->_flags & _IO_NO_WRITES)
      return flush_only ? 0 : EOF;
  if (pos > LEN(fp)) LEN(fp) = pos;
  if ((fp->_flags & _IO_TIED_PUT_GET) && !(fp->_flags & _IO_CURRENTLY_PUTTING))
    {
      pos = get_pos;
      fp->_flags |= _IO_CURRENTLY_PUTTING;
      get_pos = LEN(fp);
    }
  if (pos >= _IO_blen(fp) + flush_only)
    {
      if (fp->_flags & _IO_USER_BUF) /* not allowed to enlarge */
	{
#ifdef TODO
	  if (indefinite size)
	    {
	      fp->_IO_buf_end += 512;
	    }
	  else
#endif
	  return EOF;
	}
      else
	{
	  char *new_buf;
	  _IO_size_t new_size = 2 * _IO_blen(fp);
	  new_buf
	    = (char*)(*((_IO_strfile*)fp)->_s._allocate_buffer)(new_size);
	  if (new_buf == NULL)
	    {
	      /*	  __ferror(fp) = 1; */
	      return EOF;
	    }
	  memcpy(new_buf, fp->_IO_buf_base, _IO_blen(fp));
#if 0
	  if (lenp == &LEN(fp)) /* use '\0'-filling */
	      memset(new_buf + pos, 0, blen() - pos);
#endif
	  if (fp->_IO_buf_base)
	    {
	      (*((_IO_strfile*)fp)->_s._free_buffer)(fp->_IO_buf_base);
	      /* Make sure _IO_setb won't try to delete _IO_buf_base. */
	      fp->_IO_buf_base = NULL;
	    }
	  _IO_setb(fp, new_buf, new_buf + new_size, 1);
	  fp->_IO_write_base = new_buf;
	}
      fp->_IO_write_end = fp->_IO_buf_end;
    }

  fp->_IO_write_ptr = fp->_IO_buf_base + pos;

  fp->_IO_read_base = fp->_IO_buf_base;
  fp->_IO_read_ptr = fp->_IO_buf_base + get_pos;
  fp->_IO_read_end = fp->_IO_buf_base + LEN(fp);

  if (!flush_only)
    *fp->_IO_write_ptr++ = (unsigned char) c;
  return c;
}

int
DEFUN(_IO_str_underflow, (fp),
      register _IO_FILE* fp)
{
  _IO_size_t ppos = fp->_IO_write_ptr - fp->_IO_write_base;
  if (ppos > LEN(fp)) LEN(fp) = ppos;
  if ((fp->_flags & _IO_TIED_PUT_GET) && (fp->_flags & _IO_CURRENTLY_PUTTING))
    {
      fp->_flags &= ~_IO_CURRENTLY_PUTTING;
      fp->_IO_write_ptr = fp->_IO_write_end;
    }
  fp->_IO_read_end = fp->_IO_read_base + LEN(fp);
  if (fp->_IO_read_ptr < fp->_IO_read_end)
    return *fp->_IO_read_ptr;
  else
    return EOF;
}

_IO_ssize_t
DEFUN(_IO_str_count, (fp),
      register _IO_FILE *fp)
{
  _IO_ssize_t put_len = fp->_IO_write_ptr - fp->_IO_write_base;
  if (put_len < LEN(fp))
    put_len = LEN(fp);
  return put_len;
}     

_IO_pos_t
DEFUN(_IO_str_seekoff, (fp, offset, dir, mode),
      register _IO_FILE *fp AND _IO_off_t offset AND int dir AND int mode)
{
  _IO_ssize_t cur_size = _IO_str_count(fp);
  _IO_pos_t new_pos = EOF;

  /* Move the get pointer, if requested. */
  if (mode & _IOS_INPUT)
    {
      switch (dir)
	{
	case _IO_seek_end:
	  offset += cur_size;
	  break;
	case _IO_seek_cur:
	  offset += fp->_IO_read_ptr - fp->_IO_read_base;
	  break;
	default: /* case _IO_seek_set: */
	  break;
	}
      if (offset < 0 || (_IO_size_t)offset > cur_size)
	return EOF;
      fp->_IO_read_ptr = fp->_IO_read_base + offset;
      fp->_IO_read_end = fp->_IO_read_base + cur_size;
      new_pos = offset;
    }

  /* Move the put pointer, if requested. */
  if (mode & _IOS_OUTPUT)
    {
      switch (dir)
	{
	case _IO_seek_end:
	  offset += cur_size;
	  break;
	case _IO_seek_cur:
	  offset += fp->_IO_write_ptr - fp->_IO_write_base;
	  break;
	default: /* case _IO_seek_set: */
	  break;
	}
      if (offset < 0 || (_IO_size_t)offset > cur_size)
	return EOF;
      LEN(fp) = cur_size;
      fp->_IO_write_ptr = fp->_IO_write_base + offset;
      new_pos = offset;
    }
  return new_pos;
}

int
DEFUN(_IO_str_pbackfail, (fp, c),
      register _IO_FILE *fp AND int c)
{
  if ((fp->_flags & _IO_NO_WRITES) && c != EOF)
    return EOF;
  return _IO_default_pbackfail(fp, c);
}

void
DEFUN (_IO_str_finish, (fp),
      register _IO_FILE* fp)
{
  if (fp->_IO_buf_base && !(fp->_flags & _IO_USER_BUF))
    (((_IO_strfile*)fp)->_s._free_buffer)(fp->_IO_buf_base);
  fp->_IO_buf_base = NULL;

  _IO_default_finish(fp);
}

struct _IO_jump_t _IO_str_jumps = {
  JUMP_INIT_DUMMY,
  JUMP_INIT(finish, _IO_str_finish),
  JUMP_INIT(overflow, _IO_str_overflow),
  JUMP_INIT(underflow, _IO_str_underflow),
  JUMP_INIT(uflow, _IO_default_uflow),
  JUMP_INIT(pbackfail, _IO_str_pbackfail),
  JUMP_INIT(xsputn, _IO_default_xsputn),
  JUMP_INIT(xsgetn, _IO_default_xsgetn),
  JUMP_INIT(seekoff, _IO_str_seekoff),
  JUMP_INIT(seekpos, _IO_default_seekpos),
  JUMP_INIT(setbuf, _IO_default_setbuf),
  JUMP_INIT(sync, _IO_default_sync),
  JUMP_INIT(doallocate, _IO_default_doallocate),
  JUMP_INIT(read, _IO_default_read),
  JUMP_INIT(write, _IO_default_write),
  JUMP_INIT(seek, _IO_default_seek),
  JUMP_INIT(close, _IO_default_close),
  JUMP_INIT(stat, _IO_default_stat)
};
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of GNU libg++ 2.7.1 port (prepared by Erik Theisen)
@
text
@@


1.1.1.2
log
@libg++ 2.8.0 baseline import
@
text
@d1 2
a2 2
/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.
   This file is part of the GNU IO Library.
d4 20
a23 21
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2, or (at
   your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,
   MA 02111-1307, USA.

   As a special exception, if you link this library with files
   compiled with a GNU compiler to produce an executable, this does
   not cause the resulting executable to be covered by the GNU General
   Public License.  This exception does not however invalidate any
   other reasons why the executable file might be covered by the GNU
   General Public License.  */
d29 1
a29 25
#if 0
/* The following definitions are for exposition only.
   They map the terminology used in the ANSI/ISO C++ draft standard
   to the implementation. */

/* allocated:  set  when a dynamic array object has been allocated, and
   hence should be freed by the destructor for the strstreambuf object. */
#define ALLOCATED(FP) ((FP)->_f._IO_buf_base && DYNAMIC(FP))

/* constant:  set when the array object has const elements,
   so the output sequence cannot be written. */
#define CONSTANT(FP) ((FP)->_f._IO_file_flags & _IO_NO_WRITES)

/* alsize:  the suggested minimum size for a dynamic array object. */
#define ALSIZE(FP) ??? /* not stored */

/* palloc: points to the function to call to allocate a dynamic array object.*/
#define PALLOC(FP) \
  ((FP)->_s._allocate_buffer == default_alloc ? 0 : (FP)->_s._allocate_buffer)

/* pfree: points  to  the  function  to call to free a dynamic array object. */
#define PFREE(FP) \
  ((FP)->_s._free_buffer == default_free ? 0 : (FP)->_s._free_buffer)

#endif
d38 2
a39 5
_IO_str_init_static (fp, ptr, size, pstart)
     _IO_FILE *fp;
     char *ptr;
     int size;
     char *pstart;
d42 1
a42 1
    size = strlen (ptr);
d47 1
d50 5
a54 2
      /* Try increasing powers of 2, as long as we don't wrap around. */
      for (; s = 2*size, s > 0 && ptr + s > ptr && s < 0x4000000L; )
d56 12
a67 6
      /* Try increasing size as much as we can without wrapping around. */
      for (s = size >> 1; s > 0; s >>= 1)
	{
	  if (ptr + size + s > ptr)
	    size += s;
	}
d69 1
a69 1
  _IO_setb (fp, ptr, ptr + size, 0);
d77 1
a77 1
      fp->_IO_write_end = ptr + size;
d86 1
d88 1
a88 1
  (((_IO_strfile *) fp)->_s._allocate_buffer) =  (_IO_alloc_type)0;
d92 2
a93 4
_IO_str_init_readonly (fp, ptr, size)
     _IO_FILE *fp;
     const char *ptr;
     int size;
d95 1
a95 1
  _IO_str_init_static (fp, (char *) ptr, size, NULL);
d100 2
a101 3
_IO_str_overflow (fp, c)
     _IO_FILE *fp;
     int c;
d104 2
a105 1
  _IO_size_t pos;
d108 1
d111 1
d113 1
a113 2
      fp->_IO_write_ptr = fp->_IO_read_ptr;
      fp->_IO_read_ptr = fp->_IO_read_end;
d115 1
a115 2
  pos =  fp->_IO_write_ptr - fp->_IO_write_base;
  if (pos >= (_IO_size_t) (_IO_blen (fp) + flush_only))
d118 10
a127 1
	return EOF;
d131 1
a131 2
	  char *old_buf = fp->_IO_buf_base;
	  _IO_size_t new_size = 2 * _IO_blen (fp) + 100;
d133 1
a133 1
	    = (char *) (*((_IO_strfile *) fp)->_s._allocate_buffer) (new_size);
d139 5
d146 1
a146 2
	      memcpy (new_buf, old_buf, _IO_blen (fp));
	      (*((_IO_strfile *) fp)->_s._free_buffer) (fp->_IO_buf_base);
d150 1
a150 10
#if 0
	  if (lenp == &LEN(fp)) /* use '\0'-filling */
	      memset (new_buf + pos, 0, blen() - pos);
#endif
	  _IO_setb (fp, new_buf, new_buf + new_size, 1);
	  fp->_IO_read_base = new_buf + (fp->_IO_read_base - old_buf);
	  fp->_IO_read_ptr = new_buf + (fp->_IO_read_ptr - old_buf);
	  fp->_IO_read_end = new_buf + (fp->_IO_read_end - old_buf);
	  fp->_IO_write_ptr = new_buf + (fp->_IO_write_ptr - old_buf);

a151 1
	  fp->_IO_write_end = fp->_IO_buf_end;
d153 1
d156 6
a163 2
  if (fp->_IO_write_ptr > fp->_IO_read_end)
    fp->_IO_read_end = fp->_IO_write_ptr;
d168 2
a169 2
_IO_str_underflow (fp)
     _IO_FILE *fp;
d171 2
a172 2
  if (fp->_IO_write_ptr > fp->_IO_read_end)
    fp->_IO_read_end = fp->_IO_write_ptr;
a175 1
      fp->_IO_read_ptr = fp->_IO_write_ptr;
d178 1
a184 2
/* The size of the valid part of the buffer.  */

d186 2
a187 2
_IO_str_count (fp)
     _IO_FILE *fp;
d189 5
a193 4
  return ((fp->_IO_write_ptr > fp->_IO_read_end
	   ? fp->_IO_write_ptr : fp->_IO_read_end)
	  - fp->_IO_read_base);
}
d196 2
a197 5
_IO_str_seekoff (fp, offset, dir, mode)
     _IO_FILE *fp;
     _IO_off_t offset;
     int dir;
     int mode;
d199 1
a199 1
  _IO_ssize_t cur_size = _IO_str_count (fp);
d216 1
a216 1
      if (offset < 0 || (_IO_ssize_t) offset > cur_size)
d237 1
a237 1
      if (offset < 0 || (_IO_ssize_t) offset > cur_size)
d239 1
d247 2
a248 3
_IO_str_pbackfail (fp, c)
     _IO_FILE *fp;
     int c;
d252 1
a252 1
  return _IO_default_pbackfail (fp, c);
d256 2
a257 3
_IO_str_finish (fp, dummy)
     _IO_FILE *fp;
     int dummy;
d260 1
a260 1
    (((_IO_strfile *) fp)->_s._free_buffer) (fp->_IO_buf_base);
d263 1
a263 1
  _IO_default_finish (fp, 0);
d266 1
a266 2
struct _IO_jump_t _IO_str_jumps =
{
@

