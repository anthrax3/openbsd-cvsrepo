head	1.5;
access;
symbols
	netbsd_1_1:1.1.1.1
	netbsd_1_1:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	96.03.15.06.44.30;	author etheisen;	state dead;
branches;
next	1.4;

1.4
date	96.02.20.09.29.06;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.02.18.00.35.52;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.21.11.01.51;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.38.14;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.38.14;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Removed for 2.7.1 import.
@
text
@//    This is part of the iostream library, providing input/output for C++.
//    Copyright (C) 1992 Per Bothner.
//
//    This library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Library General Public
//    License as published by the Free Software Foundation; either
//    version 2 of the License, or (at your option) any later version.
//
//    This library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Library General Public License for more details.
//
//    You should have received a copy of the GNU Library General Public
//    License along with this library; if not, write to the Free
//    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "ioprivate.h"
#include <stdio.h>

// This file defines the standard streambufs, corresponding to cin, cout, cerr.
// We define two sets:
//
// __std_filebuf_0, __std_filebuf_1, __std_filebuf_2 are filebufs using
// file descriptor 0/1/2.
//
// __stdin_stdiobuf, __stdout_stdiobuf, __stderr_stdiobuf are stdiostreams
// pointing to stdin, stdout, stderr.


// To avoid problems depending on constructor order (and for
// efficiency) the standard streambufs (and streams) are
// constructed statically using C-style '{ ... }' initializers.
// Since you're not allowed to do this for structs that
// have virtuals, we define fake streambuf and stream classes
// that don't have any C++-isms, and initialize those.
// To initialize the vtable field of the standard filebufs,
// we use the expression 'vt_filebuf' which must evaluate to
// (the address of) the virtual function table for the
// filebuf class.

#if _G_NAMES_HAVE_UNDERSCORE
#define UNDERSCORE "_"
#else
#define UNDERSCORE ""
#endif

// First define the filebuf-based objects.

#if !defined(vt_filebuf)
#ifndef __GNUG__
// This works for cfront.
#define vt_filebuf __vtbl__7filebuf
extern char vt_filebuf[1];
#elif _G_DOLLAR_IN_LABEL
#if __GNUC_MAJOR__ > 2 || __GNUC_MINOR__ >= 5 // XXX I'm not sure it was
					      // introduced in 2.5
extern char vt_filebuf[1] asm(UNDERSCORE "_vt$7filebuf");
#else
extern char vt_filebuf[1] asm(UNDERSCORE "_vt$filebuf");
#endif
#else
#if __GNUC_MAJOR__ > 2 || __GNUC_MINOR__ >= 5 // XXX I'm not sure it was
					      // introduced in 2.5
extern char vt_filebuf[1] asm(UNDERSCORE "_vt.7filebuf");
#else
extern char vt_filebuf[1] asm(UNDERSCORE "_vt.filebuf");
#endif
#endif
#endif /* !defined(vt_filebuf) */

struct _fake_filebuf {
    struct __streambuf s;
    char* vtable;
    struct __file_fields f;
};

#define FILEBUF_LITERAL(CHAIN, FLAGS) \
       { _IO_MAGIC+_S_LINKED+_S_IS_FILEBUF+_S_IS_BACKUPBUF+FLAGS, \
	 0, 0, 0, 0, 0, 0, 0, 0, CHAIN, 0, 0, 0, 0, 0}

#define DEF_FILEBUF(NAME, FD, CHAIN, FLAGS) \
  _fake_filebuf NAME = {FILEBUF_LITERAL(CHAIN, FLAGS), vt_filebuf, {FD}};

DEF_FILEBUF(__std_filebuf_0, 0, 0, _S_NO_WRITES);
DEF_FILEBUF(__std_filebuf_1, 1, (streambuf*)&__std_filebuf_0, _S_NO_READS);
DEF_FILEBUF(__std_filebuf_2, 2, (streambuf*)&__std_filebuf_1,
	    _S_NO_READS+_S_UNBUFFERED);

// Nest define the stdiobuf-bases objects.

#if !defined(vt_stdiobuf)
#ifndef __GNUG__
// This works for cfront.
#define vt_stdiobuf __vtbl__8stdiobuf
extern char vt_stdiobuf[1];
#elif _G_DOLLAR_IN_LABEL
#if __GNUC_MAJOR__ > 2 || __GNUC_MINOR__ >= 5 // XXX I'm not sure it was
					      // introduced in 2.5
extern char vt_stdiobuf[1] asm(UNDERSCORE "_vt$8stdiobuf");
#else
extern char vt_stdiobuf[1] asm(UNDERSCORE "_vt$stdiobuf");
#endif
#else
#if __GNUC_MAJOR__ > 2 || __GNUC_MINOR__ >= 5 // XXX I'm not sure it was
					      // introduced in 2.5
extern char vt_stdiobuf[1] asm(UNDERSCORE "_vt.8stdiobuf");
#else
extern char vt_stdiobuf[1] asm(UNDERSCORE "_vt.stdiobuf");
#endif
#endif
#endif /* !defined(vt_stdiobuf) */

struct _fake_stdiobuf {
    struct __streambuf s;
    char* vtable;
    struct __file_fields f;
    FILE *_f;
};

#define DEF_STDIOBUF(NAME, FILE, FD, CHAIN, FLAGS) \
    _fake_stdiobuf NAME[1] = {{ \
	 FILEBUF_LITERAL(CHAIN, (FLAGS)|_S_UNBUFFERED),\
	 vt_stdiobuf, {FD}, FILE}};

DEF_STDIOBUF(__stdin_stdiobuf, stdin, 0, (streambuf*)&__std_filebuf_2,
	     _S_NO_WRITES);
DEF_STDIOBUF(__stdout_stdiobuf, stdout, 1, (streambuf*)__stdin_stdiobuf,
	     _S_NO_READS);
DEF_STDIOBUF(__stderr_stdiobuf, stderr, 2, (streambuf*)__stdout_stdiobuf,
	     _S_NO_READS);

streambuf* streambuf::_list_all = (streambuf*)__stderr_stdiobuf;
@


1.4
log
@Fixed typo introduced in last change
@
text
@@


1.3
log
@Check the for GCC >= 3.X (no it's not even started on yet :-) ) in the
name mangling dependent code.
@
text
@d19 1
a19 2
#include <std
io.h>
@


1.2
log
@Make libg++ compileable with recent GCC versions.  This means:
recognize changed name mangling, correct ambiguous overload resolution
and adhere to new C++ scoping rules.
@
text
@d19 2
a20 1
#include <stdio.h>
d57 2
a58 1
#if __GNUC_MINOR__ >= 5		// XXX I'm not sure it was introduced in 2.5
d64 2
a65 1
#if __GNUC_MINOR__ >= 5		// XXX I'm not sure it was introduced in 2.5
d99 2
a100 1
#if __GNUC_MINOR__ >= 5		// XXX I'm not sure it was introduced in 2.5
d106 2
a107 1
#if __GNUC_MINOR__ >= 5		// XXX I'm not sure it was introduced in 2.5
@


1.1
log
@Initial revision
@
text
@d56 3
d60 4
d67 1
d96 3
d100 4
d106 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
