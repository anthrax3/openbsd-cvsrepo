head	1.2;
access;
symbols
	OPENBSD_2_5:1.1.1.2.0.6
	OPENBSD_2_5_BASE:1.1.1.2
	OPENBSD_2_4:1.1.1.2.0.4
	OPENBSD_2_4_BASE:1.1.1.2
	OPENBSD_2_3:1.1.1.2.0.2
	OPENBSD_2_3_BASE:1.1.1.2
	FSF_2_8_0:1.1.1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	FSF_2_7_1:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	99.05.26.16.38.24;	author espie;	state dead;
branches;
next	1.1;

1.1
date	96.03.15.22.20.27;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.03.15.22.20.27;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.03.03.20.24.18;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@old libg++, replaced by part of egcs.
@
text
@// The -*- C++ -*- float_complex class.
// Copyright (C) 1994 Free Software Foundation

// This file is part of the GNU ANSI C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

// As a special exception, if you link this library with files
// compiled with a GNU compiler to produce an executable, this does not cause
// the resulting executable to be covered by the GNU General Public License.
// This exception does not however invalidate any other reasons why
// the executable file might be covered by the GNU General Public License.

// Written by Jason Merrill based upon the specification in the 27 May 1994
// C++ working paper, ANSI document X3J16/94-0098.

#ifndef __FCOMPLEX__
#define __FCOMPLEX__

#ifdef __GNUG__
#pragma interface "fcomplex"
#endif

extern "C++" {
class complex<float>
{
public:
  complex (float r = 0, float i = 0): re (r), im (i) { }
  explicit complex (const complex<double>& r);
  explicit complex (const complex<long double>& r);

  complex& operator+= (const complex&);
  complex& operator-= (const complex&);
  complex& operator*= (const complex&);
  complex& operator/= (const complex&);

  float real () const { return re; }
  float imag () const { return im; }
private:
  float re, im;

  // These functions are specified as friends for purposes of name injection;
  // they do not actually reference private members.
  friend float real (const complex& x) { return x.real (); }
  friend float imag (const complex& x) { return x.imag (); }
  friend complex operator + (const complex&, const complex&) __attribute__ ((const));
  friend complex operator + (const complex&, float) __attribute__ ((const));
  friend complex operator + (float, const complex&) __attribute__ ((const));
  friend complex operator - (const complex&, const complex&) __attribute__ ((const));
  friend complex operator - (const complex&, float) __attribute__ ((const));
  friend complex operator - (float, const complex&) __attribute__ ((const));
  friend complex operator * (const complex&, const complex&) __attribute__ ((const));
  friend complex operator * (const complex&, float) __attribute__ ((const));
  friend complex operator * (float, const complex&) __attribute__ ((const));
  friend complex operator / (const complex&, const complex&) __attribute__ ((const));
  friend complex operator / (const complex&, float) __attribute__ ((const));
  friend complex operator / (float, const complex&) __attribute__ ((const));
  friend bool operator == (const complex&, const complex&) __attribute__ ((const));
  friend bool operator == (const complex&, float) __attribute__ ((const));
  friend bool operator == (float, const complex&) __attribute__ ((const));
  friend bool operator != (const complex&, const complex&) __attribute__ ((const));
  friend bool operator != (const complex&, float) __attribute__ ((const));
  friend bool operator != (float, const complex&) __attribute__ ((const));
  friend complex polar (float, float) __attribute__ ((const));
  friend complex pow (const complex&, const complex&) __attribute__ ((const));
  friend complex pow (const complex&, float) __attribute__ ((const));
  friend complex pow (const complex&, int) __attribute__ ((const));
  friend complex pow (float, const complex&) __attribute__ ((const));
  friend istream& operator>> (istream&, complex&);
  friend ostream& operator<< (ostream&, const complex&);
};
} // extern "C++"

#endif
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of GNU libg++ 2.7.1 port (prepared by Erik Theisen)
@
text
@@


1.1.1.2
log
@libg++ 2.8.0 baseline import
@
text
@d43 4
a46 4
  complex& operator+= (const complex& r) { return __doapl (this, r); }
  complex& operator-= (const complex& r) { return __doami (this, r); }
  complex& operator*= (const complex& r) { return __doaml (this, r); }
  complex& operator/= (const complex& r) { return __doadv (this, r); }
d53 29
a81 31
  friend complex& __doapl<> (complex *, const complex&);
  friend complex& __doami<> (complex *, const complex&);
  friend complex& __doaml<> (complex *, const complex&);
  friend complex& __doadv<> (complex *, const complex&);

#ifndef __STRICT_ANSI__
  friend inline complex operator + (const complex& x, float y)
    { return operator+<> (x, y); }
  friend inline complex operator + (float x, const complex& y)
    { return operator+<> (x, y); }
  friend inline complex operator - (const complex& x, float y)
    { return operator-<> (x, y); }
  friend inline complex operator - (float x, const complex& y)
    { return operator-<> (x, y); }
  friend inline complex operator * (const complex& x, float y)
    { return operator*<> (x, y); }
  friend inline complex operator * (float x, const complex& y)
    { return operator*<> (x, y); }
  friend inline complex operator / (const complex& x, float y)
    { return operator/<> (x, y); }
  friend inline complex operator / (float x, const complex& y)
    { return operator/<> (x, y); }
  friend inline bool operator == (const complex& x, float y)
    { return operator==<> (x, y); }
  friend inline bool operator == (float x, const complex& y)
    { return operator==<> (x, y); }
  friend inline bool operator != (const complex& x, float y)
    { return operator!=<> (x, y); }
  friend inline bool operator != (float x, const complex& y)
    { return operator!=<> (x, y); }
#endif /* __STRICT_ANSI__ */
@

