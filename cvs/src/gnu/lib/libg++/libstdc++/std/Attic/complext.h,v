head	1.5;
access;
symbols
	OPENBSD_2_5:1.4.0.6
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	FSF_2_8_0:1.1.1.2
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	FSF_2_7_1:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	99.05.26.16.38.23;	author espie;	state dead;
branches;
next	1.4;

1.4
date	98.03.03.21.43.46;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.08.27.10.46.00;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.08.26.12.15.37;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.03.15.22.20.25;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.03.15.22.20.25;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.03.03.20.24.15;	author millert;	state Exp;
branches;
next	;


desc
@@


1.5
log
@old libg++, replaced by part of egcs.
@
text
@// The template and inlines for the -*- C++ -*- complex number classes.
// Copyright (C) 1994 Free Software Foundation

// This file is part of the GNU ANSI C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the terms of
// the GNU General Public License as published by the Free Software
// Foundation; either version 2, or (at your option) any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

// As a special exception, if you link this library with files compiled
// with a GNU compiler to produce an executable, this does not cause the
// resulting executable to be covered by the GNU General Public License.
// This exception does not however invalidate any other reasons why the
// executable file might be covered by the GNU General Public License.

// Written by Jason Merrill based upon the specification in the 27 May 1994
// C++ working paper, ANSI document X3J16/94-0098.

#ifndef __COMPLEXT__
#define __COMPLEXT__

#ifdef __GNUG__
#pragma interface
#endif

#include <cmath>

#if ! defined (__GNUG__) && ! defined (__attribute__)
#define __attribute__(foo) /* Ignore.  */
#endif

class istream;
class ostream;

extern "C++" {
template <class _FLT> class complex;
template <class _FLT> complex<_FLT>&
  __doapl (complex<_FLT>* ths, const complex<_FLT>& r);
template <class _FLT> complex<_FLT>&
  __doami (complex<_FLT>* ths, const complex<_FLT>& r);
template <class _FLT> complex<_FLT>&
  __doaml (complex<_FLT>* ths, const complex<_FLT>& r);
template <class _FLT> complex<_FLT>&
  __doadv (complex<_FLT>* ths, const complex<_FLT>& r);

template <class _FLT>
class complex
{
public:
  complex (_FLT r = 0, _FLT i = 0): re (r), im (i) { }
  complex& operator += (const complex&);
  complex& operator -= (const complex&);
  complex& operator *= (const complex&);
  complex& operator /= (const complex&);
  _FLT real () const { return re; }
  _FLT imag () const { return im; }
private:
  _FLT re, im;

  friend complex& __doapl<> (complex *, const complex&);
  friend complex& __doami<> (complex *, const complex&);
  friend complex& __doaml<> (complex *, const complex&);
  friend complex& __doadv<> (complex *, const complex&);
};

// Declare specializations.
class complex<float>;
class complex<double>;
class complex<long double>;

template <class _FLT>
inline complex<_FLT>&
__doapl (complex<_FLT>* ths, const complex<_FLT>& r)
{
  ths->re += r.re;
  ths->im += r.im;
  return *ths;
}
template <class _FLT>
inline complex<_FLT>&
complex<_FLT>::operator += (const complex<_FLT>& r)
{
  return __doapl (this, r);
}

template <class _FLT>
inline complex<_FLT>&
__doami (complex<_FLT>* ths, const complex<_FLT>& r)
{
  ths->re -= r.re;
  ths->im -= r.im;
  return *ths;
}
template <class _FLT>
inline complex<_FLT>&
complex<_FLT>::operator -= (const complex<_FLT>& r)
{
  return __doami (this, r);
}

template <class _FLT>
inline complex<_FLT>&
__doaml (complex<_FLT>* ths, const complex<_FLT>& r)
{
  _FLT f = ths->re * r.re - ths->im * r.im;
  ths->im = ths->re * r.im + ths->im * r.re;
  ths->re = f;
  return *ths;
}
template <class _FLT>
inline complex<_FLT>&
complex<_FLT>::operator *= (const complex<_FLT>& r)
{
  return __doaml (this, r);
}

template <class _FLT>
inline complex<_FLT>&
complex<_FLT>::operator /= (const complex<_FLT>& r)
{
  return __doadv (this, r);
}

template <class _FLT> inline _FLT
imag (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline _FLT
imag (const complex<_FLT>& x)
{
  return x.imag ();
}

template <class _FLT> inline _FLT
real (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline _FLT
real (const complex<_FLT>& x)
{
  return x.real ();
}

template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x, const complex<_FLT>& y)
{
  return complex<_FLT> (real (x) + real (y), imag (x) + imag (y));
}

template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x, _FLT y)
{
  return complex<_FLT> (real (x) + y, imag (x));
}

template <class _FLT> inline complex<_FLT>
operator + (_FLT x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator + (_FLT x, const complex<_FLT>& y)
{
  return complex<_FLT> (x + real (y), imag (y));
}

template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x, const complex<_FLT>& y)
{
  return complex<_FLT> (real (x) - real (y), imag (x) - imag (y));
}

template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x, _FLT y)
{
  return complex<_FLT> (real (x) - y, imag (x));
}

template <class _FLT> inline complex<_FLT>
operator - (_FLT x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator - (_FLT x, const complex<_FLT>& y)
{
  return complex<_FLT> (x - real (y), - imag (y));
}

template <class _FLT> inline complex<_FLT>
operator * (const complex<_FLT>& x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator * (const complex<_FLT>& x, const complex<_FLT>& y)
{
  return complex<_FLT> (real (x) * real (y) - imag (x) * imag (y),
			   real (x) * imag (y) + imag (x) * real (y));
}

template <class _FLT> inline complex<_FLT>
operator * (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator * (const complex<_FLT>& x, _FLT y)
{
  return complex<_FLT> (real (x) * y, imag (x) * y);
}

template <class _FLT> inline complex<_FLT>
operator * (_FLT x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator * (_FLT x, const complex<_FLT>& y)
{
  return complex<_FLT> (x * real (y), x * imag (y));
}

template <class _FLT> complex<_FLT>
operator / (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> complex<_FLT>
operator / (const complex<_FLT>& x, _FLT y)
{
  return complex<_FLT> (real (x) / y, imag (x) / y);
}

template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x)
{
  return x;
}

template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x)
{
  return complex<_FLT> (-real (x), -imag (x));
}

template <class _FLT> inline bool
operator == (const complex<_FLT>& x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline bool
operator == (const complex<_FLT>& x, const complex<_FLT>& y)
{
  return real (x) == real (y) && imag (x) == imag (y);
}

template <class _FLT> inline bool
operator == (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> inline bool
operator == (const complex<_FLT>& x, _FLT y)
{
  return real (x) == y && imag (x) == 0;
}

template <class _FLT> inline bool
operator == (_FLT x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline bool
operator == (_FLT x, const complex<_FLT>& y)
{
  return x == real (y) && imag (y) == 0;
}

template <class _FLT> inline bool
operator != (const complex<_FLT>& x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline bool
operator != (const complex<_FLT>& x, const complex<_FLT>& y)
{
  return real (x) != real (y) || imag (x) != imag (y);
}

template <class _FLT> inline bool
operator != (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> inline bool
operator != (const complex<_FLT>& x, _FLT y)
{
  return real (x) != y || imag (x) != 0;
}

template <class _FLT> inline bool
operator != (_FLT x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline bool
operator != (_FLT x, const complex<_FLT>& y)
{
  return x != real (y) || imag (y) != 0;
}

// Some targets don't provide a prototype for hypot when -ansi.
extern "C" double hypot (double, double) __attribute__ ((const));

template <class _FLT> inline _FLT
abs (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline _FLT
abs (const complex<_FLT>& x)
{
  return hypot (real (x), imag (x));
}

template <class _FLT> inline _FLT
arg (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline _FLT
arg (const complex<_FLT>& x)
{
  return atan2 (imag (x), real (x));
}

template <class _FLT> inline complex<_FLT>
polar (_FLT r, _FLT t) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
polar (_FLT r, _FLT t)
{
  return complex<_FLT> (r * cos (t), r * sin (t));
}

template <class _FLT> inline complex<_FLT>
conj (const complex<_FLT>& x)  __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
conj (const complex<_FLT>& x) 
{
  return complex<_FLT> (real (x), -imag (x));
}

template <class _FLT> inline _FLT
norm (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline _FLT
norm (const complex<_FLT>& x)
{
  return real (x) * real (x) + imag (x) * imag (x);
}

// Declarations of templates in complext.ccI

template <class _FLT> complex<_FLT>
  operator / (const complex<_FLT>&, const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  operator / (_FLT, const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  cos (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  cosh (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  exp (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  log (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  pow (const complex<_FLT>&, const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  pow (const complex<_FLT>&, _FLT) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  pow (const complex<_FLT>&, int) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  pow (_FLT, const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  sin (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  sinh (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  sqrt (const complex<_FLT>&) __attribute__ ((const));

template <class _FLT> istream& operator >> (istream&, complex<_FLT>&);
template <class _FLT> ostream& operator << (ostream&, const complex<_FLT>&);
} // extern "C++"

// Specializations and such

#include <std/fcomplex.h>
#include <std/dcomplex.h>
#include <std/ldcomplex.h>

#endif
@


1.4
log
@libg++ 2.8.0 from FSF + changes to build in an OpenBSD environment
@
text
@@


1.3
log
@DOH! did I not revert this yesterday? our gcc can't deal with correct
C++ code :-(
@
text
@d34 1
a34 1
#include <std/cmath.h>
d37 1
a37 1
#define __attribute__ (foo) /* Ignore.  */
d40 3
d44 11
a54 1
template <class FLOAT>
d58 1
a58 1
  complex (FLOAT r = 0, FLOAT i = 0): re (r), im (i) { }
d63 2
a64 2
  FLOAT real () const { return re; }
  FLOAT imag () const { return im; }
d66 1
a66 1
  FLOAT re, im;
d68 4
a71 29
  // These functions are specified as friends for purposes of name injection;
  // they do not actually reference private members.
  friend FLOAT real (const complex&) __attribute__ ((const));
  friend FLOAT imag (const complex&) __attribute__ ((const));
  friend complex operator + (const complex&, const complex&) __attribute__ ((const));
  friend complex operator + (const complex&, FLOAT) __attribute__ ((const));
  friend complex operator + (FLOAT, const complex&) __attribute__ ((const));
  friend complex operator - (const complex&, const complex&) __attribute__ ((const));
  friend complex operator - (const complex&, FLOAT) __attribute__ ((const));
  friend complex operator - (FLOAT, const complex&) __attribute__ ((const));
  friend complex operator * (const complex&, const complex&) __attribute__ ((const));
  friend complex operator * (const complex&, FLOAT) __attribute__ ((const));
  friend complex operator * (FLOAT, const complex&) __attribute__ ((const));
  friend complex operator / (const complex&, const complex&) __attribute__ ((const));
  friend complex operator / (const complex&, FLOAT) __attribute__ ((const));
  friend complex operator / (FLOAT, const complex&) __attribute__ ((const));
  friend bool operator == (const complex&, const complex&) __attribute__ ((const));
  friend bool operator == (const complex&, FLOAT) __attribute__ ((const));
  friend bool operator == (FLOAT, const complex&) __attribute__ ((const));
  friend bool operator != (const complex&, const complex&) __attribute__ ((const));
  friend bool operator != (const complex&, FLOAT) __attribute__ ((const));
  friend bool operator != (FLOAT, const complex&) __attribute__ ((const));
  friend complex polar (FLOAT, FLOAT) __attribute__ ((const));
  friend complex pow (const complex&, const complex&) __attribute__ ((const));
  friend complex pow (const complex&, FLOAT) __attribute__ ((const));
  friend complex pow (const complex&, int) __attribute__ ((const));
  friend complex pow (FLOAT, const complex&) __attribute__ ((const));
  friend istream& operator>> (istream&, complex&);
  friend ostream& operator<< (ostream&, const complex&);
d79 11
a89 3
template <class FLOAT>
inline complex<FLOAT>&
complex<FLOAT>::operator += (const complex<FLOAT>& r)
d91 1
a91 3
  re += r.re;
  im += r.im;
  return *this;
d94 3
a96 3
template <class FLOAT>
inline complex<FLOAT>&
complex<FLOAT>::operator -= (const complex<FLOAT>& r)
d98 9
a106 3
  re -= r.re;
  im -= r.im;
  return *this;
d109 3
a111 3
template <class FLOAT>
inline complex<FLOAT>&
complex<FLOAT>::operator *= (const complex<FLOAT>& r)
d113 10
a122 4
  FLOAT f = re * r.re - im * r.im;
  im = re * r.im + im * r.re;
  re = f;
  return *this;
d125 12
a136 2
template <class FLOAT> inline FLOAT
imag (const complex<FLOAT>& x) __attribute__ ((const))
d141 5
a145 2
template <class FLOAT> inline FLOAT
real (const complex<FLOAT>& x) __attribute__ ((const))
d150 5
a154 2
template <class FLOAT> inline complex<FLOAT>
operator + (const complex<FLOAT>& x, const complex<FLOAT>& y) __attribute__ ((const))
d156 1
a156 1
  return complex<FLOAT> (real (x) + real (y), imag (x) + imag (y));
d159 5
a163 2
template <class FLOAT> inline complex<FLOAT>
operator + (const complex<FLOAT>& x, FLOAT y) __attribute__ ((const))
d165 1
a165 1
  return complex<FLOAT> (real (x) + y, imag (x));
d168 5
a172 2
template <class FLOAT> inline complex<FLOAT>
operator + (FLOAT x, const complex<FLOAT>& y) __attribute__ ((const))
d174 1
a174 1
  return complex<FLOAT> (x + real (y), imag (y));
d177 5
a181 2
template <class FLOAT> inline complex<FLOAT>
operator - (const complex<FLOAT>& x, const complex<FLOAT>& y) __attribute__ ((const))
d183 1
a183 1
  return complex<FLOAT> (real (x) - real (y), imag (x) - imag (y));
d186 5
a190 2
template <class FLOAT> inline complex<FLOAT>
operator - (const complex<FLOAT>& x, FLOAT y) __attribute__ ((const))
d192 1
a192 1
  return complex<FLOAT> (real (x) - y, imag (x));
d195 5
a199 2
template <class FLOAT> inline complex<FLOAT>
operator - (FLOAT x, const complex<FLOAT>& y) __attribute__ ((const))
d201 1
a201 1
  return complex<FLOAT> (x - real (y), - imag (y));
d204 5
a208 2
template <class FLOAT> inline complex<FLOAT>
operator * (const complex<FLOAT>& x, const complex<FLOAT>& y) __attribute__ ((const))
d210 1
a210 1
  return complex<FLOAT> (real (x) * real (y) - imag (x) * imag (y),
d214 5
a218 2
template <class FLOAT> inline complex<FLOAT>
operator * (const complex<FLOAT>& x, FLOAT y) __attribute__ ((const))
d220 1
a220 1
  return complex<FLOAT> (real (x) * y, imag (x) * y);
d223 5
a227 2
template <class FLOAT> inline complex<FLOAT>
operator * (FLOAT x, const complex<FLOAT>& y) __attribute__ ((const))
d229 1
a229 1
  return complex<FLOAT> (x * real (y), x * imag (y));
d232 5
a236 2
template <class FLOAT> complex<FLOAT>
operator / (const complex<FLOAT>& x, FLOAT y) __attribute__ ((const))
d238 1
a238 1
  return complex<FLOAT> (real (x) / y, imag (x) / y);
d241 5
a245 2
template <class FLOAT> inline complex<FLOAT>
operator + (const complex<FLOAT>& x) __attribute__ ((const))
d250 5
a254 2
template <class FLOAT> inline complex<FLOAT>
operator - (const complex<FLOAT>& x) __attribute__ ((const))
d256 1
a256 1
  return complex<FLOAT> (-real (x), -imag (x));
d259 5
a263 2
template <class FLOAT> inline bool
operator == (const complex<FLOAT>& x, const complex<FLOAT>& y) __attribute__ ((const))
d268 5
a272 2
template <class FLOAT> inline bool
operator == (const complex<FLOAT>& x, FLOAT y) __attribute__ ((const))
d277 5
a281 2
template <class FLOAT> inline bool
operator == (FLOAT x, const complex<FLOAT>& y) __attribute__ ((const))
d286 5
a290 2
template <class FLOAT> inline bool
operator != (const complex<FLOAT>& x, const complex<FLOAT>& y) __attribute__ ((const))
d295 5
a299 2
template <class FLOAT> inline bool
operator != (const complex<FLOAT>& x, FLOAT y) __attribute__ ((const))
d304 5
a308 2
template <class FLOAT> inline bool
operator != (FLOAT x, const complex<FLOAT>& y) __attribute__ ((const))
d316 5
a320 2
template <class FLOAT> inline FLOAT
abs (const complex<FLOAT>& x) __attribute__ ((const))
d325 5
a329 2
template <class FLOAT> inline FLOAT
arg (const complex<FLOAT>& x) __attribute__ ((const))
d334 5
a338 2
template <class FLOAT> inline complex<FLOAT>
polar (FLOAT r, FLOAT t) __attribute__ ((const))
d340 1
a340 1
  return complex<FLOAT> (r * cos (t), r * sin (t));
d343 5
a347 2
template <class FLOAT> inline complex<FLOAT>
conj (const complex<FLOAT>& x)  __attribute__ ((const))
d349 1
a349 1
  return complex<FLOAT> (real (x), -imag (x));
d352 5
a356 2
template <class FLOAT> inline FLOAT
norm (const complex<FLOAT>& x) __attribute__ ((const))
d363 26
a388 26
template <class FLOAT> complex<FLOAT>
  operator / (const complex<FLOAT>&, const complex<FLOAT>&) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  operator / (FLOAT, const complex<FLOAT>&) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  cos (const complex<FLOAT>&) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  cosh (const complex<FLOAT>&) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  exp (const complex<FLOAT>&) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  log (const complex<FLOAT>&) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  pow (const complex<FLOAT>&, const complex<FLOAT>&) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  pow (const complex<FLOAT>&, FLOAT) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  pow (const complex<FLOAT>&, int) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  pow (FLOAT, const complex<FLOAT>&) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  sin (const complex<FLOAT>&) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  sinh (const complex<FLOAT>&) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  sqrt (const complex<FLOAT>&) __attribute__ ((const));
d390 2
a391 4
class istream;
class ostream;
template <class FLOAT> istream& operator >> (istream&, complex<FLOAT>&);
template <class FLOAT> ostream& operator << (ostream&, const complex<FLOAT>&);
a398 3

// Declare the instantiations.
#include <std/cinst.h>
@


1.2
log
@Updated to Cygnus versions (egcs uncovered many bugs)
@
text
@d34 1
a34 1
#include <cmath>
d37 1
a37 1
#define __attribute__(foo) /* Ignore.  */
a39 3
class istream;
class ostream;

d41 1
a41 1
template <class _FLT>
d45 1
a45 1
  complex (_FLT r = 0, _FLT i = 0): re (r), im (i) { }
d50 2
a51 2
  _FLT real () const { return re; }
  _FLT imag () const { return im; }
d53 1
a53 6
  _FLT re, im;

  friend complex& __doapl (complex *, const complex&);
  friend complex& __doami (complex *, const complex&);
  friend complex& __doaml (complex *, const complex&);
  friend complex& __doadv (complex *, const complex&);
d57 2
a58 2
  friend _FLT real (const complex&) __attribute__ ((const));
  friend _FLT imag (const complex&) __attribute__ ((const));
d60 2
a61 2
  friend complex operator + (const complex&, _FLT) __attribute__ ((const));
  friend complex operator + (_FLT, const complex&) __attribute__ ((const));
d63 2
a64 2
  friend complex operator - (const complex&, _FLT) __attribute__ ((const));
  friend complex operator - (_FLT, const complex&) __attribute__ ((const));
d66 2
a67 2
  friend complex operator * (const complex&, _FLT) __attribute__ ((const));
  friend complex operator * (_FLT, const complex&) __attribute__ ((const));
d69 2
a70 2
  friend complex operator / (const complex&, _FLT) __attribute__ ((const));
  friend complex operator / (_FLT, const complex&) __attribute__ ((const));
d72 2
a73 2
  friend bool operator == (const complex&, _FLT) __attribute__ ((const));
  friend bool operator == (_FLT, const complex&) __attribute__ ((const));
d75 3
a77 3
  friend bool operator != (const complex&, _FLT) __attribute__ ((const));
  friend bool operator != (_FLT, const complex&) __attribute__ ((const));
  friend complex polar (_FLT, _FLT) __attribute__ ((const));
d79 1
a79 1
  friend complex pow (const complex&, _FLT) __attribute__ ((const));
d81 1
a81 1
  friend complex pow (_FLT, const complex&) __attribute__ ((const));
d91 3
a93 11
template <class _FLT>
inline complex<_FLT>&
__doapl (complex<_FLT>* ths, const complex<_FLT>& r)
{
  ths->re += r.re;
  ths->im += r.im;
  return *ths;
}
template <class _FLT>
inline complex<_FLT>&
complex<_FLT>::operator += (const complex<_FLT>& r)
d95 3
a97 1
  return __doapl (this, r);
d100 3
a102 3
template <class _FLT>
inline complex<_FLT>&
__doami (complex<_FLT>* ths, const complex<_FLT>& r)
d104 3
a106 9
  ths->re -= r.re;
  ths->im -= r.im;
  return *ths;
}
template <class _FLT>
inline complex<_FLT>&
complex<_FLT>::operator -= (const complex<_FLT>& r)
{
  return __doami (this, r);
d109 3
a111 3
template <class _FLT>
inline complex<_FLT>&
__doaml (complex<_FLT>* ths, const complex<_FLT>& r)
d113 4
a116 4
  _FLT f = ths->re * r.re - ths->im * r.im;
  ths->im = ths->re * r.im + ths->im * r.re;
  ths->re = f;
  return *ths;
a117 9
template <class _FLT>
inline complex<_FLT>&
complex<_FLT>::operator *= (const complex<_FLT>& r)
{
  return __doaml (this, r);
}

template <class _FLT> complex<_FLT>&
  __doadv (complex<_FLT>* ths, const complex<_FLT>& r);
d119 2
a120 12
template <class _FLT>
inline complex<_FLT>&
complex<_FLT>::operator /= (const complex<_FLT>& r)
{
  return __doadv (this, r);
}

template <class _FLT> inline _FLT
imag (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline _FLT
imag (const complex<_FLT>& x)
d125 2
a126 5
template <class _FLT> inline _FLT
real (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline _FLT
real (const complex<_FLT>& x)
d131 2
a132 5
template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x, const complex<_FLT>& y)
d134 1
a134 1
  return complex<_FLT> (real (x) + real (y), imag (x) + imag (y));
d137 2
a138 5
template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x, _FLT y)
d140 1
a140 1
  return complex<_FLT> (real (x) + y, imag (x));
d143 2
a144 5
template <class _FLT> inline complex<_FLT>
operator + (_FLT x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator + (_FLT x, const complex<_FLT>& y)
d146 1
a146 1
  return complex<_FLT> (x + real (y), imag (y));
d149 2
a150 5
template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x, const complex<_FLT>& y)
d152 1
a152 1
  return complex<_FLT> (real (x) - real (y), imag (x) - imag (y));
d155 2
a156 5
template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x, _FLT y)
d158 1
a158 1
  return complex<_FLT> (real (x) - y, imag (x));
d161 2
a162 5
template <class _FLT> inline complex<_FLT>
operator - (_FLT x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator - (_FLT x, const complex<_FLT>& y)
d164 1
a164 1
  return complex<_FLT> (x - real (y), - imag (y));
d167 2
a168 5
template <class _FLT> inline complex<_FLT>
operator * (const complex<_FLT>& x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator * (const complex<_FLT>& x, const complex<_FLT>& y)
d170 1
a170 1
  return complex<_FLT> (real (x) * real (y) - imag (x) * imag (y),
d174 2
a175 5
template <class _FLT> inline complex<_FLT>
operator * (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator * (const complex<_FLT>& x, _FLT y)
d177 1
a177 1
  return complex<_FLT> (real (x) * y, imag (x) * y);
d180 2
a181 5
template <class _FLT> inline complex<_FLT>
operator * (_FLT x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator * (_FLT x, const complex<_FLT>& y)
d183 1
a183 1
  return complex<_FLT> (x * real (y), x * imag (y));
d186 2
a187 5
template <class _FLT> complex<_FLT>
operator / (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> complex<_FLT>
operator / (const complex<_FLT>& x, _FLT y)
d189 1
a189 1
  return complex<_FLT> (real (x) / y, imag (x) / y);
d192 2
a193 5
template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x)
d198 2
a199 5
template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x)
d201 1
a201 1
  return complex<_FLT> (-real (x), -imag (x));
d204 2
a205 5
template <class _FLT> inline bool
operator == (const complex<_FLT>& x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline bool
operator == (const complex<_FLT>& x, const complex<_FLT>& y)
d210 2
a211 5
template <class _FLT> inline bool
operator == (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> inline bool
operator == (const complex<_FLT>& x, _FLT y)
d216 2
a217 5
template <class _FLT> inline bool
operator == (_FLT x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline bool
operator == (_FLT x, const complex<_FLT>& y)
d222 2
a223 5
template <class _FLT> inline bool
operator != (const complex<_FLT>& x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline bool
operator != (const complex<_FLT>& x, const complex<_FLT>& y)
d228 2
a229 5
template <class _FLT> inline bool
operator != (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> inline bool
operator != (const complex<_FLT>& x, _FLT y)
d234 2
a235 5
template <class _FLT> inline bool
operator != (_FLT x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline bool
operator != (_FLT x, const complex<_FLT>& y)
d243 2
a244 5
template <class _FLT> inline _FLT
abs (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline _FLT
abs (const complex<_FLT>& x)
d249 2
a250 5
template <class _FLT> inline _FLT
arg (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline _FLT
arg (const complex<_FLT>& x)
d255 2
a256 5
template <class _FLT> inline complex<_FLT>
polar (_FLT r, _FLT t) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
polar (_FLT r, _FLT t)
d258 1
a258 1
  return complex<_FLT> (r * cos (t), r * sin (t));
d261 2
a262 5
template <class _FLT> inline complex<_FLT>
conj (const complex<_FLT>& x)  __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
conj (const complex<_FLT>& x) 
d264 1
a264 1
  return complex<_FLT> (real (x), -imag (x));
d267 2
a268 5
template <class _FLT> inline _FLT
norm (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline _FLT
norm (const complex<_FLT>& x)
d275 26
a300 26
template <class _FLT> complex<_FLT>
  operator / (const complex<_FLT>&, const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  operator / (_FLT, const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  cos (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  cosh (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  exp (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  log (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  pow (const complex<_FLT>&, const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  pow (const complex<_FLT>&, _FLT) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  pow (const complex<_FLT>&, int) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  pow (_FLT, const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  sin (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  sinh (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  sqrt (const complex<_FLT>&) __attribute__ ((const));
d302 4
a305 2
template <class _FLT> istream& operator >> (istream&, complex<_FLT>&);
template <class _FLT> ostream& operator << (ostream&, const complex<_FLT>&);
d313 3
@


1.1
log
@Initial revision
@
text
@d34 1
a34 1
#include <std/cmath.h>
d37 1
a37 1
#define __attribute__ (foo) /* Ignore.  */
d40 3
d44 1
a44 1
template <class FLOAT>
d48 1
a48 1
  complex (FLOAT r = 0, FLOAT i = 0): re (r), im (i) { }
d53 2
a54 2
  FLOAT real () const { return re; }
  FLOAT imag () const { return im; }
d56 6
a61 1
  FLOAT re, im;
d65 2
a66 2
  friend FLOAT real (const complex&) __attribute__ ((const));
  friend FLOAT imag (const complex&) __attribute__ ((const));
d68 2
a69 2
  friend complex operator + (const complex&, FLOAT) __attribute__ ((const));
  friend complex operator + (FLOAT, const complex&) __attribute__ ((const));
d71 2
a72 2
  friend complex operator - (const complex&, FLOAT) __attribute__ ((const));
  friend complex operator - (FLOAT, const complex&) __attribute__ ((const));
d74 2
a75 2
  friend complex operator * (const complex&, FLOAT) __attribute__ ((const));
  friend complex operator * (FLOAT, const complex&) __attribute__ ((const));
d77 2
a78 2
  friend complex operator / (const complex&, FLOAT) __attribute__ ((const));
  friend complex operator / (FLOAT, const complex&) __attribute__ ((const));
d80 2
a81 2
  friend bool operator == (const complex&, FLOAT) __attribute__ ((const));
  friend bool operator == (FLOAT, const complex&) __attribute__ ((const));
d83 3
a85 3
  friend bool operator != (const complex&, FLOAT) __attribute__ ((const));
  friend bool operator != (FLOAT, const complex&) __attribute__ ((const));
  friend complex polar (FLOAT, FLOAT) __attribute__ ((const));
d87 1
a87 1
  friend complex pow (const complex&, FLOAT) __attribute__ ((const));
d89 1
a89 1
  friend complex pow (FLOAT, const complex&) __attribute__ ((const));
d99 11
a109 3
template <class FLOAT>
inline complex<FLOAT>&
complex<FLOAT>::operator += (const complex<FLOAT>& r)
d111 1
a111 3
  re += r.re;
  im += r.im;
  return *this;
d114 3
a116 3
template <class FLOAT>
inline complex<FLOAT>&
complex<FLOAT>::operator -= (const complex<FLOAT>& r)
d118 9
a126 3
  re -= r.re;
  im -= r.im;
  return *this;
d129 3
a131 3
template <class FLOAT>
inline complex<FLOAT>&
complex<FLOAT>::operator *= (const complex<FLOAT>& r)
d133 4
a136 4
  FLOAT f = re * r.re - im * r.im;
  im = re * r.im + im * r.re;
  re = f;
  return *this;
d138 9
d148 12
a159 2
template <class FLOAT> inline FLOAT
imag (const complex<FLOAT>& x) __attribute__ ((const))
d164 5
a168 2
template <class FLOAT> inline FLOAT
real (const complex<FLOAT>& x) __attribute__ ((const))
d173 5
a177 2
template <class FLOAT> inline complex<FLOAT>
operator + (const complex<FLOAT>& x, const complex<FLOAT>& y) __attribute__ ((const))
d179 1
a179 1
  return complex<FLOAT> (real (x) + real (y), imag (x) + imag (y));
d182 5
a186 2
template <class FLOAT> inline complex<FLOAT>
operator + (const complex<FLOAT>& x, FLOAT y) __attribute__ ((const))
d188 1
a188 1
  return complex<FLOAT> (real (x) + y, imag (x));
d191 5
a195 2
template <class FLOAT> inline complex<FLOAT>
operator + (FLOAT x, const complex<FLOAT>& y) __attribute__ ((const))
d197 1
a197 1
  return complex<FLOAT> (x + real (y), imag (y));
d200 5
a204 2
template <class FLOAT> inline complex<FLOAT>
operator - (const complex<FLOAT>& x, const complex<FLOAT>& y) __attribute__ ((const))
d206 1
a206 1
  return complex<FLOAT> (real (x) - real (y), imag (x) - imag (y));
d209 5
a213 2
template <class FLOAT> inline complex<FLOAT>
operator - (const complex<FLOAT>& x, FLOAT y) __attribute__ ((const))
d215 1
a215 1
  return complex<FLOAT> (real (x) - y, imag (x));
d218 5
a222 2
template <class FLOAT> inline complex<FLOAT>
operator - (FLOAT x, const complex<FLOAT>& y) __attribute__ ((const))
d224 1
a224 1
  return complex<FLOAT> (x - real (y), - imag (y));
d227 5
a231 2
template <class FLOAT> inline complex<FLOAT>
operator * (const complex<FLOAT>& x, const complex<FLOAT>& y) __attribute__ ((const))
d233 1
a233 1
  return complex<FLOAT> (real (x) * real (y) - imag (x) * imag (y),
d237 5
a241 2
template <class FLOAT> inline complex<FLOAT>
operator * (const complex<FLOAT>& x, FLOAT y) __attribute__ ((const))
d243 1
a243 1
  return complex<FLOAT> (real (x) * y, imag (x) * y);
d246 5
a250 2
template <class FLOAT> inline complex<FLOAT>
operator * (FLOAT x, const complex<FLOAT>& y) __attribute__ ((const))
d252 1
a252 1
  return complex<FLOAT> (x * real (y), x * imag (y));
d255 5
a259 2
template <class FLOAT> complex<FLOAT>
operator / (const complex<FLOAT>& x, FLOAT y) __attribute__ ((const))
d261 1
a261 1
  return complex<FLOAT> (real (x) / y, imag (x) / y);
d264 5
a268 2
template <class FLOAT> inline complex<FLOAT>
operator + (const complex<FLOAT>& x) __attribute__ ((const))
d273 5
a277 2
template <class FLOAT> inline complex<FLOAT>
operator - (const complex<FLOAT>& x) __attribute__ ((const))
d279 1
a279 1
  return complex<FLOAT> (-real (x), -imag (x));
d282 5
a286 2
template <class FLOAT> inline bool
operator == (const complex<FLOAT>& x, const complex<FLOAT>& y) __attribute__ ((const))
d291 5
a295 2
template <class FLOAT> inline bool
operator == (const complex<FLOAT>& x, FLOAT y) __attribute__ ((const))
d300 5
a304 2
template <class FLOAT> inline bool
operator == (FLOAT x, const complex<FLOAT>& y) __attribute__ ((const))
d309 5
a313 2
template <class FLOAT> inline bool
operator != (const complex<FLOAT>& x, const complex<FLOAT>& y) __attribute__ ((const))
d318 5
a322 2
template <class FLOAT> inline bool
operator != (const complex<FLOAT>& x, FLOAT y) __attribute__ ((const))
d327 5
a331 2
template <class FLOAT> inline bool
operator != (FLOAT x, const complex<FLOAT>& y) __attribute__ ((const))
d339 5
a343 2
template <class FLOAT> inline FLOAT
abs (const complex<FLOAT>& x) __attribute__ ((const))
d348 5
a352 2
template <class FLOAT> inline FLOAT
arg (const complex<FLOAT>& x) __attribute__ ((const))
d357 5
a361 2
template <class FLOAT> inline complex<FLOAT>
polar (FLOAT r, FLOAT t) __attribute__ ((const))
d363 1
a363 1
  return complex<FLOAT> (r * cos (t), r * sin (t));
d366 5
a370 2
template <class FLOAT> inline complex<FLOAT>
conj (const complex<FLOAT>& x)  __attribute__ ((const))
d372 1
a372 1
  return complex<FLOAT> (real (x), -imag (x));
d375 5
a379 2
template <class FLOAT> inline FLOAT
norm (const complex<FLOAT>& x) __attribute__ ((const))
d386 26
a411 26
template <class FLOAT> complex<FLOAT>
  operator / (const complex<FLOAT>&, const complex<FLOAT>&) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  operator / (FLOAT, const complex<FLOAT>&) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  cos (const complex<FLOAT>&) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  cosh (const complex<FLOAT>&) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  exp (const complex<FLOAT>&) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  log (const complex<FLOAT>&) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  pow (const complex<FLOAT>&, const complex<FLOAT>&) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  pow (const complex<FLOAT>&, FLOAT) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  pow (const complex<FLOAT>&, int) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  pow (FLOAT, const complex<FLOAT>&) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  sin (const complex<FLOAT>&) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  sinh (const complex<FLOAT>&) __attribute__ ((const));
template <class FLOAT> complex<FLOAT>
  sqrt (const complex<FLOAT>&) __attribute__ ((const));
d413 2
a414 4
class istream;
class ostream;
template <class FLOAT> istream& operator >> (istream&, complex<FLOAT>&);
template <class FLOAT> ostream& operator << (ostream&, const complex<FLOAT>&);
a421 3

// Declare the instantiations.
#include <std/cinst.h>
@


1.1.1.1
log
@Import of GNU libg++ 2.7.1 port (prepared by Erik Theisen)
@
text
@@


1.1.1.2
log
@libg++ 2.8.0 baseline import
@
text
@d34 1
a34 1
#include <cmath>
d37 1
a37 1
#define __attribute__(foo) /* Ignore.  */
a39 3
class istream;
class ostream;

d41 1
a41 11
template <class _FLT> class complex;
template <class _FLT> complex<_FLT>&
  __doapl (complex<_FLT>* ths, const complex<_FLT>& r);
template <class _FLT> complex<_FLT>&
  __doami (complex<_FLT>* ths, const complex<_FLT>& r);
template <class _FLT> complex<_FLT>&
  __doaml (complex<_FLT>* ths, const complex<_FLT>& r);
template <class _FLT> complex<_FLT>&
  __doadv (complex<_FLT>* ths, const complex<_FLT>& r);

template <class _FLT>
d45 1
a45 1
  complex (_FLT r = 0, _FLT i = 0): re (r), im (i) { }
d50 2
a51 2
  _FLT real () const { return re; }
  _FLT imag () const { return im; }
d53 1
a53 1
  _FLT re, im;
d55 29
a83 4
  friend complex& __doapl<> (complex *, const complex&);
  friend complex& __doami<> (complex *, const complex&);
  friend complex& __doaml<> (complex *, const complex&);
  friend complex& __doadv<> (complex *, const complex&);
d91 3
a93 11
template <class _FLT>
inline complex<_FLT>&
__doapl (complex<_FLT>* ths, const complex<_FLT>& r)
{
  ths->re += r.re;
  ths->im += r.im;
  return *ths;
}
template <class _FLT>
inline complex<_FLT>&
complex<_FLT>::operator += (const complex<_FLT>& r)
d95 3
a97 1
  return __doapl (this, r);
d100 3
a102 3
template <class _FLT>
inline complex<_FLT>&
__doami (complex<_FLT>* ths, const complex<_FLT>& r)
d104 3
a106 9
  ths->re -= r.re;
  ths->im -= r.im;
  return *ths;
}
template <class _FLT>
inline complex<_FLT>&
complex<_FLT>::operator -= (const complex<_FLT>& r)
{
  return __doami (this, r);
d109 3
a111 3
template <class _FLT>
inline complex<_FLT>&
__doaml (complex<_FLT>* ths, const complex<_FLT>& r)
d113 4
a116 10
  _FLT f = ths->re * r.re - ths->im * r.im;
  ths->im = ths->re * r.im + ths->im * r.re;
  ths->re = f;
  return *ths;
}
template <class _FLT>
inline complex<_FLT>&
complex<_FLT>::operator *= (const complex<_FLT>& r)
{
  return __doaml (this, r);
d119 2
a120 12
template <class _FLT>
inline complex<_FLT>&
complex<_FLT>::operator /= (const complex<_FLT>& r)
{
  return __doadv (this, r);
}

template <class _FLT> inline _FLT
imag (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline _FLT
imag (const complex<_FLT>& x)
d125 2
a126 5
template <class _FLT> inline _FLT
real (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline _FLT
real (const complex<_FLT>& x)
d131 2
a132 5
template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x, const complex<_FLT>& y)
d134 1
a134 1
  return complex<_FLT> (real (x) + real (y), imag (x) + imag (y));
d137 2
a138 5
template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x, _FLT y)
d140 1
a140 1
  return complex<_FLT> (real (x) + y, imag (x));
d143 2
a144 5
template <class _FLT> inline complex<_FLT>
operator + (_FLT x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator + (_FLT x, const complex<_FLT>& y)
d146 1
a146 1
  return complex<_FLT> (x + real (y), imag (y));
d149 2
a150 5
template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x, const complex<_FLT>& y)
d152 1
a152 1
  return complex<_FLT> (real (x) - real (y), imag (x) - imag (y));
d155 2
a156 5
template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x, _FLT y)
d158 1
a158 1
  return complex<_FLT> (real (x) - y, imag (x));
d161 2
a162 5
template <class _FLT> inline complex<_FLT>
operator - (_FLT x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator - (_FLT x, const complex<_FLT>& y)
d164 1
a164 1
  return complex<_FLT> (x - real (y), - imag (y));
d167 2
a168 5
template <class _FLT> inline complex<_FLT>
operator * (const complex<_FLT>& x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator * (const complex<_FLT>& x, const complex<_FLT>& y)
d170 1
a170 1
  return complex<_FLT> (real (x) * real (y) - imag (x) * imag (y),
d174 2
a175 5
template <class _FLT> inline complex<_FLT>
operator * (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator * (const complex<_FLT>& x, _FLT y)
d177 1
a177 1
  return complex<_FLT> (real (x) * y, imag (x) * y);
d180 2
a181 5
template <class _FLT> inline complex<_FLT>
operator * (_FLT x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator * (_FLT x, const complex<_FLT>& y)
d183 1
a183 1
  return complex<_FLT> (x * real (y), x * imag (y));
d186 2
a187 5
template <class _FLT> complex<_FLT>
operator / (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> complex<_FLT>
operator / (const complex<_FLT>& x, _FLT y)
d189 1
a189 1
  return complex<_FLT> (real (x) / y, imag (x) / y);
d192 2
a193 5
template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x)
d198 2
a199 5
template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x)
d201 1
a201 1
  return complex<_FLT> (-real (x), -imag (x));
d204 2
a205 5
template <class _FLT> inline bool
operator == (const complex<_FLT>& x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline bool
operator == (const complex<_FLT>& x, const complex<_FLT>& y)
d210 2
a211 5
template <class _FLT> inline bool
operator == (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> inline bool
operator == (const complex<_FLT>& x, _FLT y)
d216 2
a217 5
template <class _FLT> inline bool
operator == (_FLT x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline bool
operator == (_FLT x, const complex<_FLT>& y)
d222 2
a223 5
template <class _FLT> inline bool
operator != (const complex<_FLT>& x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline bool
operator != (const complex<_FLT>& x, const complex<_FLT>& y)
d228 2
a229 5
template <class _FLT> inline bool
operator != (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> inline bool
operator != (const complex<_FLT>& x, _FLT y)
d234 2
a235 5
template <class _FLT> inline bool
operator != (_FLT x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline bool
operator != (_FLT x, const complex<_FLT>& y)
d243 2
a244 5
template <class _FLT> inline _FLT
abs (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline _FLT
abs (const complex<_FLT>& x)
d249 2
a250 5
template <class _FLT> inline _FLT
arg (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline _FLT
arg (const complex<_FLT>& x)
d255 2
a256 5
template <class _FLT> inline complex<_FLT>
polar (_FLT r, _FLT t) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
polar (_FLT r, _FLT t)
d258 1
a258 1
  return complex<_FLT> (r * cos (t), r * sin (t));
d261 2
a262 5
template <class _FLT> inline complex<_FLT>
conj (const complex<_FLT>& x)  __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
conj (const complex<_FLT>& x) 
d264 1
a264 1
  return complex<_FLT> (real (x), -imag (x));
d267 2
a268 5
template <class _FLT> inline _FLT
norm (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline _FLT
norm (const complex<_FLT>& x)
d275 26
a300 26
template <class _FLT> complex<_FLT>
  operator / (const complex<_FLT>&, const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  operator / (_FLT, const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  cos (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  cosh (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  exp (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  log (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  pow (const complex<_FLT>&, const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  pow (const complex<_FLT>&, _FLT) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  pow (const complex<_FLT>&, int) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  pow (_FLT, const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  sin (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  sinh (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  sqrt (const complex<_FLT>&) __attribute__ ((const));
d302 4
a305 2
template <class _FLT> istream& operator >> (istream&, complex<_FLT>&);
template <class _FLT> ostream& operator << (ostream&, const complex<_FLT>&);
d313 3
@

