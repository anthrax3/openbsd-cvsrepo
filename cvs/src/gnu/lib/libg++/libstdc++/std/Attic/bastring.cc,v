head	1.2;
access;
symbols
	OPENBSD_2_5:1.1.1.2.0.6
	OPENBSD_2_5_BASE:1.1.1.2
	OPENBSD_2_4:1.1.1.2.0.4
	OPENBSD_2_4_BASE:1.1.1.2
	OPENBSD_2_3:1.1.1.2.0.2
	OPENBSD_2_3_BASE:1.1.1.2
	FSF_2_8_0:1.1.1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	FSF_2_7_1:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@// @;


1.2
date	99.05.26.16.38.22;	author espie;	state dead;
branches;
next	1.1;

1.1
date	96.03.15.22.20.23;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.03.15.22.20.23;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.03.03.20.24.11;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@old libg++, replaced by part of egcs.
@
text
@// Member templates for the -*- C++ -*- string classes.
// Copyright (C) 1994 Free Software Foundation

// This file is part of the GNU ANSI C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

// As a special exception, if you link this library with files
// compiled with a GNU compiler to produce an executable, this does not cause
// the resulting executable to be covered by the GNU General Public License.
// This exception does not however invalidate any other reasons why
// the executable file might be covered by the GNU General Public License.

// Written by Jason Merrill based upon the specification by Takanori Adachi
// in ANSI X3J16/94-0013R2.

#include <std/stddef.h>
#include <std/bastring.h>

extern "C++" {
template <class charT, class traits>
inline void * __bsrep <charT, traits>::
operator new (size_t s, size_t extra)
{
  return ::operator new (s + extra * sizeof (charT));
}

template <class charT, class traits>
inline size_t __bsrep <charT, traits>::
#if _G_ALLOC_CONTROL
default_frob (size_t s)
#else
frob_size (size_t s)
#endif
{
  size_t i = 16;
  while (i < s) i *= 2;
  return i;
}

template <class charT, class traits>
inline __bsrep <charT, traits> * __bsrep <charT, traits>::
create (size_t extra)
{
  extra = frob_size (extra + 1);
  Rep *p = new (extra) Rep;
  p->res = extra;
  p->ref = 1;
  p->selfish = false;
  return p;
}

template <class charT, class traits>
charT * __bsrep <charT, traits>::
clone ()
{
  Rep *p = Rep::create (len);
  p->copy (0, data (), len);
  p->len = len;
  return p->data ();
}

template <class charT, class traits>
inline bool __bsrep <charT, traits>::
#ifdef _G_ALLOC_CONTROL
default_excess (size_t s, size_t r)
#else
excess_slop (size_t s, size_t r)
#endif
{
  return 2 * (s <= 16 ? 16 : s) < r;
}

template <class charT, class traits>
inline bool basic_string <charT, traits>::
check_realloc (size_t s) const
{
  ++s;
  return (rep ()->ref > 1
	  || s > capacity ()
	  || Rep::excess_slop (s, capacity ()));
}

template <class charT, class traits>
void basic_string <charT, traits>::
alloc (size_t size, bool save)
{
  if (! check_realloc (size))
    return;

  Rep *p = Rep::create (size);

  if (save)
    {
      p->copy (0, data (), length ());
      p->len = length ();
    }
  else
    p->len = 0;

  repup (p);
}

template <class charT, class traits>
basic_string <charT, traits>& basic_string <charT, traits>::
replace (size_t pos1, size_t n1,
	 const basic_string& str, size_t pos2, size_t n2)
{
  const size_t len2 = str.length ();

  if (pos1 == 0 && n1 >= length () && pos2 == 0 && n2 >= len2)
    return operator= (str);

  OUTOFRANGE (pos2 > len2);

  if (n2 > len2 - pos2)
    n2 = len2 - pos2;

  return replace (pos1, n1, str.data () + pos2, n2);
}

template <class charT, class traits>
inline void __bsrep <charT, traits>::
copy (size_t pos, const charT *s, size_t n)
{
  if (n)
    traits::copy (data () + pos, s, n);
}

template <class charT, class traits>
inline void __bsrep <charT, traits>::
move (size_t pos, const charT *s, size_t n)
{
  if (n)
    traits::move (data () + pos, s, n);
}

template <class charT, class traits>
basic_string <charT, traits>& basic_string <charT, traits>::
replace (size_t pos, size_t n1, const charT* s, size_t n2)
{
  const size_t len = length ();
  OUTOFRANGE (pos > len);
  if (n1 > len - pos)
    n1 = len - pos;
  LENGTHERROR (len - n1 >= npos - n2);
  size_t newlen = len - n1 + n2;

  if (check_realloc (newlen))
    {
      Rep *p = Rep::create (newlen);
      p->copy (0, data (), pos);
      p->copy (pos + n2, data () + pos + n1, len - (pos + n1));
      p->copy (pos, s, n2);
      repup (p);
    }
  else
    {
      rep ()->move (pos + n2, data () + pos + n1, len - (pos + n1));
      rep ()->copy (pos, s, n2);
    }
  rep ()->len = newlen;

  return *this;
}

template <class charT, class traits>
inline void __bsrep <charT, traits>::
set (size_t pos, const charT c, size_t n)
{
  traits::set  (data () + pos, c, n);
}

template <class charT, class traits>
basic_string <charT, traits>& basic_string <charT, traits>::
replace (size_t pos, size_t n1, size_t n2, charT c)
{
  const size_t len = length ();
  OUTOFRANGE (pos > len);
  if (n1 > len - pos)
    n1 = len - pos;
  LENGTHERROR (len - n1 >= npos - n2);
  size_t newlen = len - n1 + n2;

  if (check_realloc (newlen))
    {
      Rep *p = Rep::create (newlen);
      p->copy (0, data (), pos);
      p->copy (pos + n2, data () + pos + n1, len - (pos + n1));
      p->set  (pos, c, n2);
      repup (p);
    }
  else
    {
      rep ()->move (pos + n2, data () + pos + n1, len - (pos + n1));
      rep ()->set  (pos, c, n2);
    }
  rep ()->len = newlen;

  return *this;
}

template <class charT, class traits>
void basic_string <charT, traits>::
resize (size_t n, charT c)
{
  LENGTHERROR (n == npos);

  if (n > length ())
    append (n - length (), c);
  else
    remove (n);
}

template <class charT, class traits>
size_t basic_string <charT, traits>::
copy (charT* s, size_t n, size_t pos)
{
  OUTOFRANGE (pos > length ());

  if (n > length () - pos)
    n = length () - pos;

  traits::copy (s, data () + pos, n);
  return n;
}

template <class charT, class traits>
size_t basic_string <charT, traits>::
find (const charT* s, size_t pos, size_t n) const
{
  size_t xpos = pos;
  for (; xpos + n <= length (); ++xpos)
    if (traits::eq (data () [xpos], *s)
	&& traits::compare (data () + xpos, s, n) == 0)
      return xpos;
  return npos;
}

template <class charT, class traits>
inline size_t basic_string <charT, traits>::
_find (const charT* ptr, charT c, size_t xpos, size_t len)
{
  for (; xpos < len; ++xpos)
    if (traits::eq (ptr [xpos], c))
      return xpos;
  return npos;
}

template <class charT, class traits>
size_t basic_string <charT, traits>::
find (charT c, size_t pos) const
{
  return _find (data (), c, pos, length ());
}

template <class charT, class traits>
size_t basic_string <charT, traits>::
rfind (const charT* s, size_t pos, size_t n) const
{
  size_t xpos = length () - n;
  if (xpos > pos)
    xpos = pos;

  for (++xpos; xpos-- > 0; )
    if (traits::eq (data () [xpos], *s)
	&& traits::compare (data () + xpos, s, n) == 0)
      return xpos;
  return npos;
}

template <class charT, class traits>
size_t basic_string <charT, traits>::
rfind (charT c, size_t pos) const
{
  size_t xpos = length () - 1;
  if (xpos > pos)
    xpos = pos;

  for (++xpos; xpos-- > 0; )
    if (traits::eq (data () [xpos], c))
      return xpos;
  return npos;
}

template <class charT, class traits>
size_t basic_string <charT, traits>::
find_first_of (const charT* s, size_t pos, size_t n) const
{
  size_t xpos = pos;
  for (; xpos < length (); ++xpos)
    if (_find (s, data () [xpos], 0, n) != npos)
      return xpos;
  return npos;
}

template <class charT, class traits>
size_t basic_string <charT, traits>::
find_last_of (const charT* s, size_t pos, size_t n) const
{
  size_t xpos = length ();
  for (; xpos-- > pos; )
    if (_find (s, data () [xpos], 0, n) != npos)
      return xpos;
  return npos;
}

template <class charT, class traits>
size_t basic_string <charT, traits>::
find_first_not_of (const charT* s, size_t pos, size_t n) const
{
  size_t xpos = pos;
  for (; xpos < length (); ++xpos)
    if (_find (s, data () [xpos], 0, n) == npos)
      return xpos;
  return npos;
}

template <class charT, class traits>
size_t basic_string <charT, traits>::
find_first_not_of (charT c, size_t pos) const
{
  size_t xpos = pos;
  for (; xpos < length (); ++xpos)
    if (traits::ne (data () [xpos], c))
      return xpos;
  return npos;
}

template <class charT, class traits>
size_t basic_string <charT, traits>::
find_last_not_of (const charT* s, size_t pos, size_t n) const
{
  size_t xpos = length ();
  for (; xpos-- > pos; )
    if (_find (s, data () [xpos], 0, n) == npos)
      return xpos;
  return npos;
}

template <class charT, class traits>
size_t basic_string <charT, traits>::
find_last_not_of (charT c, size_t pos) const
{
  size_t xpos = length ();
  for (; xpos-- > pos; )
    if (traits::ne (data () [xpos], c))
      return xpos;
  return npos;
}

template <class charT, class traits>
int basic_string <charT, traits>::
compare (const basic_string& str, size_t pos, size_t n) const
{
  OUTOFRANGE (pos > length ());

  size_t rlen = length () - pos;
  if (rlen > n)
    rlen = n;
  if (rlen > str.length ())
    rlen = str.length ();
  int r = traits::compare (data () + pos, str.data (), rlen);
  if (r != 0)
    return r;
  if (rlen == n)
    return 0;
  return (length () - pos) - str.length ();
}

template <class charT, class traits>
int basic_string <charT, traits>::
compare (const charT* s, size_t pos, size_t n) const
{
  OUTOFRANGE (pos > length ());

  size_t rlen = length () - pos;
  if (rlen > n)
    rlen = n;
  int r = traits::compare (data () + pos, s, rlen);
  if (r != 0)
    return r;
  return (length () - pos) - n;
}

#include <iostream.h>

template <class charT, class traits>
istream &
operator>> (istream &is, basic_string <charT, traits> &s)
{
  int w = is.width (0);
  if (is.ipfx0 ())
    {
      register streambuf *sb = is.rdbuf ();
      s.resize (0);
      while (1)
	{
	  int ch = sb->sbumpc ();
	  if (ch == EOF)
	    {
	      is.setstate (ios::eofbit);
	      break;
	    }
	  else if (traits::is_del (ch))
	    {
	      sb->sungetc ();
	      break;
	    }
	  s += ch;
	  if (--w == 1)
	    break;
	}
    }

  is.isfx ();
  if (s.length () == 0)
    is.setstate (ios::failbit);

  return is;
}

template <class charT, class traits>
ostream &
operator<< (ostream &o, const basic_string <charT, traits>& s)
{
  return o.write (s.data (), s.length ());
}

template <class charT, class traits>
istream&
getline (istream &is, basic_string <charT, traits>& s, charT delim)
{
  if (is.ipfx1 ())
    {
      _IO_size_t count = 0;
      streambuf *sb = is.rdbuf ();
      s.resize (0);

      while (1)
	{
	  int ch = sb->sbumpc ();
	  if (ch == EOF)
	    {
	      is.setstate (count == 0
			   ? (ios::failbit|ios::eofbit)
			   : ios::eofbit);
	      break;
	    }

	  ++count;

	  if (ch == delim)
	    break;

	  s += ch;

	  if (s.length () == s.npos - 1)
	    {
	      is.setstate (ios::failbit);
	      break;
	    }
	}
    }

  // We need to be friends with istream to do this.
  // is._gcount = count;
  is.isfx ();

  return is;
}
} // extern "C++"
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of GNU libg++ 2.7.1 port (prepared by Erik Theisen)
@
text
@@


1.1.1.2
log
@libg++ 2.8.0 baseline import
@
text
@d28 1
a28 1
#include <cstddef>
d32 2
a33 2
template <class charT, class traits, class Allocator>
inline void * basic_string <charT, traits, Allocator>::Rep::
d36 1
a36 1
  return Allocator::allocate(s + extra * sizeof (charT));
d39 2
a40 11
template <class charT, class traits, class Allocator>
inline void basic_string <charT, traits, Allocator>::Rep::
operator delete (void * ptr)
{
  return Allocator::deallocate(ptr, sizeof(Rep) +
			       reinterpret_cast<Rep *>(ptr)->res *
			       sizeof (charT)); 
}

template <class charT, class traits, class Allocator>
inline size_t basic_string <charT, traits, Allocator>::Rep::
d52 2
a53 3
template <class charT, class traits, class Allocator>
inline basic_string <charT, traits, Allocator>::Rep *
basic_string <charT, traits, Allocator>::Rep::
d64 2
a65 2
template <class charT, class traits, class Allocator>
charT * basic_string <charT, traits, Allocator>::Rep::
d74 2
a75 2
template <class charT, class traits, class Allocator>
inline bool basic_string <charT, traits, Allocator>::Rep::
d85 3
a87 3
template <class charT, class traits, class Allocator>
inline bool basic_string <charT, traits, Allocator>::
check_realloc (basic_string::size_type s) const
d89 1
a89 2
  s += sizeof (charT);
  rep ()->selfish = false;
d95 3
a97 3
template <class charT, class traits, class Allocator>
void basic_string <charT, traits, Allocator>::
alloc (basic_string::size_type size, bool save)
d115 4
a118 5
template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>&
basic_string <charT, traits, Allocator>::
replace (size_type pos1, size_type n1,
	 const basic_string& str, size_type pos2, size_type n2)
d133 2
a134 2
template <class charT, class traits, class Allocator>
inline void basic_string <charT, traits, Allocator>::Rep::
d141 2
a142 2
template <class charT, class traits, class Allocator>
inline void basic_string <charT, traits, Allocator>::Rep::
d149 3
a151 4
template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>&
basic_string <charT, traits, Allocator>::
replace (size_type pos, size_type n1, const charT* s, size_type n2)
d153 1
a153 1
  const size_type len = length ();
d157 1
a157 1
  LENGTHERROR (len - n1 > max_size () - n2);
d178 2
a179 2
template <class charT, class traits, class Allocator>
inline void basic_string <charT, traits, Allocator>::Rep::
d185 3
a187 3
template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>& basic_string <charT, traits, Allocator>::
replace (size_type pos, size_type n1, size_type n2, charT c)
d193 1
a193 1
  LENGTHERROR (len - n1 > max_size () - n2);
d214 3
a216 3
template <class charT, class traits, class Allocator>
void basic_string <charT, traits, Allocator>::
resize (size_type n, charT c)
d218 1
a218 1
  LENGTHERROR (n > max_size ());
d223 1
a223 1
    erase (n);
d226 3
a228 4
template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
copy (charT* s, size_type n, size_type pos)
d239 3
a241 4
template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find (const charT* s, size_type pos, size_type n) const
d251 3
a253 4
template <class charT, class traits, class Allocator>
inline basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
_find (const charT* ptr, charT c, size_type xpos, size_type len)
d261 3
a263 4
template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find (charT c, size_type pos) const
d268 3
a270 4
template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
rfind (const charT* s, size_type pos, size_type n) const
a271 3
  if (n > length ())
    return npos;

d283 3
a285 4
template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
rfind (charT c, size_type pos) const
a286 3
  if (1 > length ())
    return npos;

d297 3
a299 4
template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find_first_of (const charT* s, size_type pos, size_type n) const
d308 3
a310 4
template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find_last_of (const charT* s, size_type pos, size_type n) const
d312 2
a313 4
  size_t xpos = length () - 1;
  if (xpos > pos)
    xpos = pos;
  for (; xpos; --xpos)
d319 3
a321 4
template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find_first_not_of (const charT* s, size_type pos, size_type n) const
d330 3
a332 4
template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find_first_not_of (charT c, size_type pos) const
d341 3
a343 4
template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find_last_not_of (const charT* s, size_type pos, size_type n) const
d345 2
a346 4
  size_t xpos = length () - 1;
  if (xpos > pos)
    xpos = pos;
  for (; xpos; --xpos)
d352 3
a354 4
template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find_last_not_of (charT c, size_type pos) const
d356 2
a357 4
  size_t xpos = length () - 1;
  if (xpos > pos)
    xpos = pos;
  for (; xpos; --xpos)
d363 3
a365 3
template <class charT, class traits, class Allocator>
int basic_string <charT, traits, Allocator>::
compare (const basic_string& str, size_type pos, size_type n) const
d382 3
a384 3
template <class charT, class traits, class Allocator>
int basic_string <charT, traits, Allocator>::
compare (const charT* s, size_type pos, size_type n) const
d399 1
a399 1
template <class charT, class traits, class Allocator>
d401 1
a401 1
operator>> (istream &is, basic_string <charT, traits, Allocator> &s)
d434 1
a434 1
template <class charT, class traits, class Allocator>
d436 1
a436 1
operator<< (ostream &o, const basic_string <charT, traits, Allocator>& s)
d441 1
a441 1
template <class charT, class traits, class Allocator>
d443 1
a443 1
getline (istream &is, basic_string <charT, traits, Allocator>& s, charT delim)
a482 19

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::Rep
basic_string<charT, traits, Allocator>::nilRep = { 0, 0, 1 };

template <class charT, class traits, class Allocator>
const basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::npos;

#ifdef _G_ALLOC_CONTROL
template <class charT, class traits, class Allocator>
bool (*basic_string <charT, traits, Allocator>::Rep::excess_slop) (size_t, size_t)
     = basic_string <charT, traits, Allocator>::Rep::default_excess;

template <class charT, class traits, class Allocator>
size_t (*basic_string <charT, traits, Allocator>::Rep::frob_size) (size_t)
     = basic_string <charT, traits, Allocator>::Rep::default_frob;
#endif

@

