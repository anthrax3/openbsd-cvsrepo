head	1.2;
access;
symbols
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	FSF_2_8_0:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	FSF_2_7_1:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.2
date	99.05.26.16.34.49;	author espie;	state dead;
branches;
next	1.1;

1.1
date	96.03.15.22.18.17;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.03.15.22.18.17;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.2
log
@old libg++, replaced by part of egcs.
@
text
@/* C code produced by gperf version 2.5 (GNU C++ version) */
/* Command-line: ../src/gperf -n -k1-8 -l  */

#define TOTAL_KEYWORDS 40
#define MIN_WORD_LENGTH 2
#define MAX_WORD_LENGTH 14
#define MIN_HASH_VALUE 1
#define MAX_HASH_VALUE 256
/* maximum key range = 256, duplicates = 0 */

static unsigned int
hash (str, len)
     register char *str;
     register int unsigned len;
{
  static unsigned short asso_values[] =
    {
     257, 257, 257, 257, 257, 257, 257, 257, 257, 257,
     257, 257, 257, 257, 257, 257, 257, 257, 257, 257,
     257, 257, 257, 257, 257, 257, 257, 257, 257, 257,
     257, 257, 257, 257, 257, 257, 257, 257, 257, 257,
     257, 257, 257, 257, 257, 257, 257, 257, 257, 257,
     257, 257, 257, 257, 257, 257, 257, 257, 257, 257,
     257, 257, 257, 257, 257,  25,  30,  35,  21,   0,
      30,  15,  30,  45, 257, 257,   0,   5,  45,   0,
      10,   0,   1,  20,  25,  15,  30,  40,  15,   5,
     257, 257, 257, 257, 257, 257, 257, 257, 257, 257,
     257, 257, 257, 257, 257, 257, 257, 257, 257, 257,
     257, 257, 257, 257, 257, 257, 257, 257, 257, 257,
     257, 257, 257, 257, 257, 257, 257, 257,
    };
  register int hval = 0;

  switch (len)
    {
      default:
      case 8:
        hval += asso_values[str[7]];
      case 7:
        hval += asso_values[str[6]];
      case 6:
        hval += asso_values[str[5]];
      case 5:
        hval += asso_values[str[4]];
      case 4:
        hval += asso_values[str[3]];
      case 3:
        hval += asso_values[str[2]];
      case 2:
        hval += asso_values[str[1]];
      case 1:
        hval += asso_values[str[0]];
        break;
    }
  return hval;
}

char *
in_word_set (str, len)
     register char *str;
     register unsigned int len;
{

  static unsigned char lengthtable[] =
    {
      0,  2,  0,  0,  0,  0,  0,  0,  0,  0,  4,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  4,  2,  0,  0,  0,  2,  3,  0,
      0,  0,  2,  3,  0,  0,  0,  2,  4,  0,  0,  0,  4,  6,
      0,  0,  0,  3,  0,  0,  0,  0,  0,  6,  0,  0,  0,  0,
      3,  5,  6,  0,  0,  6,  0,  0,  0,  0,  3,  0,  0,  0,
      3,  0,  0,  0,  0,  2,  0,  0,  0,  0,  4,  0,  0,  9,
      0,  4,  6,  6,  0,  0,  2,  3,  0,  0,  0,  5,  3,  0,
      0,  0,  4,  0,  0,  0,  0,  0,  0,  0,  0,  0, 14,  0,
      0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,
      7,  0,  0,  0,  5,  0,  0,  0,  0,  5,  0,  0,  0,  0,
      4,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  9,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0, 10,
    };
  static char *wordlist[] =
    {
      "", 
      "OR", 
      "", "", "", "", "", "", "", "", 
      "LOOP", 
      "", "", "", "", "", "", "", "", "", 
      "ELSE", 
      "DO", 
      "", "", "", 
      "TO", 
      "MOD", 
      "", "", "", 
      "OF", 
      "FOR", 
      "", "", "", 
      "BY", 
      "FROM", 
      "", "", "", 
      "TYPE", 
      "MODULE", 
      "", "", "", 
      "SET", 
      "", "", "", "", "", 
      "EXPORT", 
      "", "", "", "", 
      "VAR", 
      "ARRAY", 
      "RECORD", 
      "", "", 
      "REPEAT", 
      "", "", "", "", 
      "END", 
      "", "", "", 
      "NOT", 
      "", "", "", "", 
      "IF", 
      "", "", "", "", 
      "CASE", 
      "", "", 
      "PROCEDURE", 
      "", 
      "EXIT", 
      "IMPORT", 
      "RETURN", 
      "", "", 
      "IN", 
      "AND", 
      "", "", "", 
      "ELSIF", 
      "DIV", 
      "", "", "", 
      "THEN", 
      "", "", "", "", "", "", "", "", "", 
      "IMPLEMENTATION", 
      "", "", "", "", 
      "WHILE", 
      "", "", "", "", "", "", "", "", "", 
      "CONST", 
      "POINTER", 
      "", "", "", 
      "UNTIL", 
      "", "", "", "", 
      "BEGIN", 
      "", "", "", "", 
      "WITH", 
      "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", 
      "", "QUALIFIED", 
      "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", 
      "DEFINITION", 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      register int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= 0)
        {
          register char *s = wordlist[key];

          if (len == lengthtable[key]
              && *s == *str && !strcmp (str + 1, s + 1))
            return s;
        }
    }
  return 0;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of GNU libg++ 2.7.1 port (prepared by Erik Theisen)
@
text
@@

