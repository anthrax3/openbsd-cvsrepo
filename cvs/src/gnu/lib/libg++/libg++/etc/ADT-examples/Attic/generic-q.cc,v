head	1.2;
access;
symbols
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	FSF_2_8_0:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	FSF_2_7_1:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@// @;


1.2
date	99.05.26.16.34.13;	author espie;	state dead;
branches;
next	1.1;

1.1
date	96.03.15.22.17.53;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.03.15.22.17.53;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.2
log
@old libg++, replaced by part of egcs.
@
text
@// From: "Douglas C. Schmidt" <schmidt@@glacier.ics.uci.edu>
// Date: Sun, 25 Sep 88 16:19:35 -0700

#include <stream.h>
#include <ctype.h>
#include <String.h>
#include <generic.h>
#include <stdlib.h>

#define queue(type) name2(type,queue)
#define list(type) name2(type,list)
#define queuedeclare(type)                     \
class queue(type) {                            \
   struct list(type) {                         \
      type item;                               \
      list(type) *next;                        \
   } *head;                                    \
   int sz;                                     \
public:                                        \
   queue(type)(void) {head = 0;sz = 0;}        \
   ~queue(type)(void) {                        \
      list(type) *temp;                        \
      while (head) {                           \
         temp = head;                          \
         head = head->next;                    \
         delete temp;                          \
      }                                        \
   }                                           \
   int  empty(void) {return(!head);}           \
   int  size(void) {return(sz);}               \
   void enqueue(type new_item);                \
   type front(void) {                          \
      return(head->next->item);                \
   }                                           \
   type dequeue(void);                         \
};

#define queueimplement(type)                   \
type queue(type)::dequeue(void) {              \
   if (!head)                                  \
      abort();                                 \
   type temp = head->next->item;               \
   list(type) *temp_ptr;                       \
   if ((temp_ptr = head->next) == head) {      \
      head = 0;                                \
   }                                           \
   else {                                      \
      head->next = temp_ptr->next;             \
   }                                           \
   delete temp_ptr;                            \
   sz--;                                       \
   return(temp);                               \
}                                              \
void queue(type)::enqueue(type new_item) {     \
   if (!head) {                                \
      head       = new list(type);             \
      head->item = new_item;                   \
      head->next = head;                       \
   }                                           \
   else {                                      \
      list(type) *temp_node  = new list(type); \
      temp_node->item  = new_item;             \
      temp_node->next  = head->next;           \
      head->next       = temp_node;            \
      head             = temp_node;            \
   }                                           \
   sz++;                                       \
}


queuedeclare(String);
queueimplement(String);
queuedeclare(double);
queueimplement(double);

main() {
   String Buf;
   queue(String) Q_String;
   queue(double) Q_double;

   while (cin >> Buf) {
      if (Buf.matches(RXalpha)) {
         Q_String.enqueue(String(Buf));
      }
      else if (Buf.matches(RXdouble)) {
         Q_double.enqueue(atof(Buf));
      }   
   }

   while (!Q_String.empty()) {
      cout << "Size = " << Q_String.size() << ",Item = " 
           << Q_String.front() << "\n";
      void(Q_String.dequeue());
   }

   while (!Q_double.empty()) {
      cout << "Size = " << Q_double.size() << ",Item = " 
           << Q_double.front() << "\n";
      void(Q_double.dequeue());
   }
   return (0);
}

@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of GNU libg++ 2.7.1 port (prepared by Erik Theisen)
@
text
@@

