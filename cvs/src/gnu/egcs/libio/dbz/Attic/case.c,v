head	1.2;
access;
symbols
	OPENBSD_5_4:1.1.1.1.0.58
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.56
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.54
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.52
	OPENBSD_5_0:1.1.1.1.0.50
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.48
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.46
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.42
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.44
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.40
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.38
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.36
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.34
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.32
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.30
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.28
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.26
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.24
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.22
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.20
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.18
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.16
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.14
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.12
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.10
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.8
	OPENBSD_2_9_BASE:1.1.1.1
	GCC-2_95_pre3_test3:1.1.1.1
	GCC-2_95_pre3_test2:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.6
	OPENBSD_2_8_BASE:1.1.1.1
	GCC-2_95_pre3_20000527:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.4
	OPENBSD_2_7_BASE:1.1.1.1
	GCC-2_95_2:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	GCC-2_95_1:1.1.1.1
	CYGNUS-990718:1.1.1.1
	CYGNUS-990629:1.1.1.1
	CYGNUS-990608:1.1.1.1
	CYGNUS-19990517:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2013.08.06.19.17.12;	author miod;	state dead;
branches;
next	1.1;

1.1
date	99.05.26.13.38.39;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.26.13.38.39;	author espie;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove gcc 2.95 from the tree. One of the least bogus compiler we had (although
it had required some generous bandaid), but unfortunately not able to compile
most of the Real World (tm) software.
@
text
@/*
 * case-mapping stuff
 *
 * We exploit the fact that we are dealing only with headers here, and
 * headers are limited to the ASCII characters by RFC822.  It is barely
 * possible that we might be dealing with a translation into another
 * character set, but in particular it's very unlikely for a header
 * character to be outside -128..255.
 *
 * Life would be a whole lot simpler if tolower() could safely and portably
 * be applied to any char.
 */
#include <stdio.h>
#include "string.h"
#include "case.h"

/* note that case.h knows the value of OFFSET */
#define	OFFSET	128		/* avoid trouble with negative chars */
#define	MAPSIZE	(256+OFFSET)
char casemap[MAPSIZE];		/* relies on init to '\0' */
static int primed = 0;		/* has casemap been set up? */

/*
 - prime - set up case-mapping stuff
 */
static void
prime()
{
	register char *lp;
	register char *up;
	register int c;
	register int i;
	static char lower[] = "abcdefghijklmnopqrstuvwxyz";
	static char upper[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

	for (lp = lower, up = upper; *lp != '\0'; lp++, up++) {
		c = *lp;
		casemap[c+OFFSET] = c;
		casemap[*up+OFFSET] = c;
	}
	for (i = 0; i < MAPSIZE; i++)
		if (casemap[i] == '\0')
			casemap[i] = (char)(i-OFFSET);
	primed = 1;
}

/*
 - cistrncmp - case-independent strncmp
 */
int				/* < == > 0 */
cistrncmp(s1, s2, len)
char *s1;
char *s2;
int len;
{
	register char *p1;
	register char *p2;
	register int n;

	if (!primed)
		prime();

	p1 = s1;
	p2 = s2;
	n = len;
	while (--n >= 0 && *p1 != '\0' && TOLOW(*p1) == TOLOW(*p2)) {
		p1++;
		p2++;
	}
	if (n < 0)
		return(0);

	/*
	 * The following case analysis is necessary so that characters
	 * which look negative collate low against normal characters but
	 * high against the end-of-string NUL.
	 */
	if (*p1 == '\0' && *p2 == '\0')
		return(0);
	else if (*p1 == '\0')
		return(-1);
	else if (*p2 == '\0')
		return(1);
	else
		return(TOLOW(*p1) - TOLOW(*p2));
}

/*
 - rfc822ize - do the bizarre case conversion needed for rfc822 message-ids
 *
 * Actually, this is not quite complete.  Absolute, total, full RFC822
 * compliance requires a horrible parsing job, because of the arcane
 * quoting conventions -- abc"def"ghi is not equivalent to abc"DEF"ghi,
 * for example.  There are three or four things that might occur in the
 * domain part of a message-id that are case-sensitive.  They don't seem
 * to ever occur in real news, thank Cthulhu.  (What?  You were expecting
 * a merciful and forgiving deity to be invoked in connection with RFC822?
 * Forget it; none of them would come near it.)
 */
char *				/* returns the argument */
rfc822ize(s)
char *s;
{
	register char *p;
	static char post[] = "postmaster";
	static int postlen = sizeof(post)-1;

	if (!primed)
		prime();

	p = strrchr(s, '@@');
	if (p == NULL)			/* no local/domain split */
		p = "";			/* assume all local */
	else if	(p - (s+1) == postlen && CISTREQN(s+1, post, postlen)) {
		/* crazy special case -- "postmaster" is case-insensitive */
		p = s;
	}
#ifdef NONSTANDARD
#ifdef RFCVIOLATION
#ifdef B_2_11_MISTAKE
	p = s;				/* all case-insensitive */
#endif
#endif
#endif
	for (; *p != '\0'; p++)
		*p = TOLOW(*p);

	return(s);
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@egcs projects compiler system
Exact copy of the snapshot, except for the removal of
	texinfo/
	gcc/ch/
	libchill/

@
text
@@
