head	1.2;
access;
symbols
	OPENBSD_5_4:1.1.1.1.0.58
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.56
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.54
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.52
	OPENBSD_5_0:1.1.1.1.0.50
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.48
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.46
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.42
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.44
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.40
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.38
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.36
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.34
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.32
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.30
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.28
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.26
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.24
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.22
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.20
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.18
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.16
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.14
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.12
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.10
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.8
	OPENBSD_2_9_BASE:1.1.1.1
	GCC-2_95_pre3_test2:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.6
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.4
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	CYGNUS-990629:1.1.1.1
	CYGNUS-990608:1.1.1.1
	CYGNUS-19990517:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2013.08.06.19.17.04;	author miod;	state dead;
branches;
next	1.1;

1.1
date	99.05.26.13.37.43;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.26.13.37.43;	author espie;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove gcc 2.95 from the tree. One of the least bogus compiler we had (although
it had required some generous bandaid), but unfortunately not able to compile
most of the Real World (tm) software.
@
text
@// Special g++ Options: -W -Wall -O

//This is the source code from FAQ-259, found in chapter 20 of "C++ FAQs."
//Copyright (C) 1994, Addison-Wesley Publishers, Inc.; All rights reserved.
//
//The book, "C++ FAQs" is by Marshall P. Cline and Greg A. Lomow,
//Copyright (C) 1994, Addison-Wesley Publishers, Inc.; All rights reserved.
//
//This code is presented for its instructional value.  It has been tested with
//care, but it is not guaranteed for any particular purpose.  Neither the
//publisher nor the authors offer any warranties or representations, nor do
//they accept any liabilities with respect to this code.

#include <string.h>
#include <iostream.h>

class BadIndex { };

class String {
public:

  String()
    : len_(0), data_(new char[1])
    { data_[0] = '\0'; }

  String(const char* s)
    : len_(strlen(s)), data_(new char[len_ + 1])
    { memcpy(data_, s, len_ + 1); }

 ~String()
    { delete [] data_; }

  String(const String& s)
    : len_(s.len_), data_(new char[s.len_ + 1])
    { memcpy(data_, s.data_, len_ + 1); }

  String& operator= (const String& s)
    {
      if (len_ != s.len_) { //makes self-assignment harmless
        char* newData = new char[s.len_ + 1];
        delete [] data_;
        data_ = newData;
        len_ = s.len_;
      }
      memcpy(data_, s.data_, len_ + 1);
      return *this;
    }

  unsigned len() const
    { return len_; }

  char& operator[] (unsigned i)
    { indexTest(i); return data_[i]; }
  char  operator[] (unsigned i) const
    { indexTest(i); return data_[i]; }

  friend ostream& operator<< (ostream& o, const String& s)
    { return o.write(s.data_, s.len_); }

  friend int operator== (const String& a, const String& b)
    { return a.len_ == b.len_ &&
             memcmp(a.data_, b.data_, a.len_) == 0; }
  friend int operator!= (const String& a, const String& b)
    { return ! (a == b); }

private:
  void indexTest(unsigned i) const
    { if (i >= len_) throw BadIndex(); }
  unsigned len_;  //ORDER DEPENDENCY; see FAQ-190
  char* data_;    //ORDER DEPENDENCY; see FAQ-190
};

class AccessViolation { };
class BadFileName     { };

class File {
public:
  File(const String& filename)
    throw(AccessViolation, BadFileName)
    {
      cout << "Open " << filename << "\n";
      if (filename == "badAccess.txt")
        throw AccessViolation();
      if (filename == "badName.txt")
        throw BadFileName();
    }
};

class UserClass {
public:
  void f(const String& filename) throw(BadFileName);
};

void
UserClass::f(const String& filename) throw(BadFileName)
{
  try {
    File f(filename);		// WARNING - unused
  }
  catch (const AccessViolation& e) {
    cout << "  FULLY recover from access-violation\n";
  }
  catch (const BadFileName& e) {
    cout << "  PARTIALLY recover from bad-file-name\n";
    throw;
  }
}

void
tryIt(const String& filename)
{
  try {
    UserClass u;
    u.f(filename);
    cout << "  OK\n";
  }
  catch (const BadFileName& e) {
    cout << "  Finish recovering from bad-file-name\n";
  }
}

int
main()
{
  tryIt("goodFile.txt");
  tryIt("badAccess.txt");
  tryIt("badName.txt");
}

// g++ -O -o warn warn.C -W -Wall
// warn.C: In method `void UserClass::f(const class String &)':
// warn.C:96: warning: unused variable `class File f'
// warn.C:101: warning: `struct cp_eh_info * __exception_info' might 
// be used uninitialized in this function


@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@egcs projects compiler system
Exact copy of the snapshot, except for the removal of
	texinfo/
	gcc/ch/
	libchill/

@
text
@@
