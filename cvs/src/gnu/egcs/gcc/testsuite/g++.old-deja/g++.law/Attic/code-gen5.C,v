head	1.2;
access;
symbols
	OPENBSD_5_4:1.1.1.1.0.58
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.56
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.54
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.52
	OPENBSD_5_0:1.1.1.1.0.50
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.48
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.46
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.42
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.44
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.40
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.38
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.36
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.34
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.32
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.30
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.28
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.26
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.24
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.22
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.20
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.18
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.16
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.14
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.12
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.10
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.8
	OPENBSD_2_9_BASE:1.1.1.1
	GCC-2_95_pre3_test2:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.6
	OPENBSD_2_8_BASE:1.1.1.1
	GCC-2_95_pre3_20000916:1.1.1.1
	GCC-2_95_pre3_20000527:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.4
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	CYGNUS-990629:1.1.1.1
	CYGNUS-990608:1.1.1.1
	CYGNUS-19990517:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2013.08.06.19.16.55;	author miod;	state dead;
branches;
next	1.1;

1.1
date	99.05.26.13.36.58;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.26.13.36.58;	author espie;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove gcc 2.95 from the tree. One of the least bogus compiler we had (although
it had required some generous bandaid), but unfortunately not able to compile
most of the Real World (tm) software.
@
text
@// GROUPS passed code-generation
// code-gen file
// From: "David" <norman@@pi14.arc.umn.edu>
// Date:     Mon, 15 Nov 1993 20:59:14 -0600 (CST)
// Subject:  An error!
// Message-ID: <9311160259.AA03353@@pi14.arc.umn.edu>

#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <fstream.h>
#include <iostream.h>
#include <math.h>

#define ANSI_C

typedef double VEC ;

class Vector;

class VectorInt 
{
	public:

	/* Nothing public!! Only Vector can use this class */

	private:

	VectorInt( int );
	VectorInt( int, double *, int = 0 );
	VectorInt( const VectorInt & );
	~VectorInt();

	VectorInt *refer();
	void unrefer();
	int count;				/* Number of Vector's refering to me */

	VEC *vec;

	friend class Vector;
	friend class VecElem;
};

class VecElem 
{
	public:
	
	operator double();
	double operator=( double );

	private:

	VecElem( Vector &, int );
	VecElem( const VecElem & );

	Vector &v;
	int row;						/* Row element refers to */

	friend class Vector;
};

class Vector 
{
	public:

	Vector();					// Must be assigned to before used
	Vector( VectorInt * );
	Vector( int );
	Vector( int, double *, int beg = 0 );
	Vector( const Vector & );
	Vector &operator=( const Vector & );
	~Vector() { if(r) r->unrefer(); };

	int row() const { return 19; }
	int dim() const { return 10; }

	double operator()( int ) const;
	VecElem operator()( int );

	double assign( int, double );

	friend ostream& operator<<( ostream&, const Vector& m );
	
	private:

	VectorInt *r;			/* Reference to real data */

	friend class VecElem;
	friend class LUDecom;
	friend class SVD;
};


Vector::
Vector()
	: r(0)
{}

Vector::
Vector( VectorInt *vi )
	: r(vi)
{
	r->refer();
}

Vector::
Vector( int row )
{
	assert( row > 0 );

	r = new VectorInt( row );

	r->refer();
}

Vector::
Vector( int row, double *d, int beg )
{
	assert( row > 0 );

	r = new VectorInt( row, d, beg );

	r->refer();
}

Vector::
Vector( const Vector &A )
	: r( A.r->refer() )
{}

Vector& Vector::
operator=( const Vector &A )
{
	if( r )
		r->unrefer();

	r = A.r->refer();

	return *this;
}

double Vector::
operator()( int row ) const
{
	assert( r );

	return *r->vec;
}

VecElem Vector::
operator()( int r )
{
	assert(r);

	return VecElem( *this, r );
}

	/* assign changes the matrix, it does not create a new one! */
double Vector::
assign( int rownum, double d )
{
	assert(r);

	if( rownum > row() || rownum <= 0 ) {
		cerr << "Warning: trying to assign out of bounds" << endl;
		cerr << "row " << rownum << endl;
		cerr << "Vector size " << row() << endl;
		abort();
	}

	if( r->count == 1 ) {
			/* Don't need to create a new matrix, since we are the only */
			/*  one pointing to ours 									*/
	}
	else {
		VectorInt *vi = new VectorInt( *r );
		r->unrefer();
		r = vi->refer();
	}

	return d;
}


VectorInt::
VectorInt( int sx )
	: vec( new double[sx] ), count(0)
{ }

VectorInt::
VectorInt( int sx, double *, int )
	: vec( new double[sx] ), count(0)
{
}

VectorInt::
VectorInt( const VectorInt & )
	: vec( new double[10] ), count(0)
{
}

VectorInt * VectorInt::
refer()
{
	count ++;
	return this;

	// cout << "Refering vec" << endl;
}

void VectorInt::
unrefer()
{
	count--;

	if( count == 0 ) {
		delete this;
	}

	// cout << "Unrefering vec" << endl;
}

VectorInt::
~VectorInt()
{
	delete vec;
	vec = 0;
}

VecElem::
VecElem( Vector &vec, int r )
	: v(vec), row(r)
{
	if( r < 1 || r > vec.row() ) {
		cerr << "Trying to access vector element out of bounds" << endl;
		abort();
	}
}

VecElem::
VecElem( const VecElem &elem )
	: v(elem.v), row(elem.row)
{}

VecElem::
operator double()
{
	assert( v.r->vec );
	return *v.r->vec;
};

double VecElem::
operator=( double d )
{
	return v.assign( row, d );
}





int makeforms( Vector cen, Vector **a, Vector **b );

int main()
{
	Vector *a[8], *b[8], disp(3);
	Vector cen(3), cen2(3);
	int i, j;

	if (makeforms (cen,a,b) != 10)
	  printf ("FAIL\n");
	else
	  printf ("PASS\n");


}

int
makeforms( Vector cen, Vector **a, Vector **b)
{
	return 10;
}

@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@egcs projects compiler system
Exact copy of the snapshot, except for the removal of
	texinfo/
	gcc/ch/
	libchill/

@
text
@@
