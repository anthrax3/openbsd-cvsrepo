head	1.2;
access;
symbols
	OPENBSD_5_4:1.1.1.1.0.58
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.56
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.54
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.52
	OPENBSD_5_0:1.1.1.1.0.50
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.48
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.46
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.42
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.44
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.40
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.38
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.36
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.34
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.32
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.30
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.28
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.26
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.24
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.22
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.20
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.18
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.16
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.14
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.12
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.10
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.8
	OPENBSD_2_9_BASE:1.1.1.1
	GCC-2_95_pre3_test2:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.6
	OPENBSD_2_8_BASE:1.1.1.1
	GCC-2_95_pre3_20000916:1.1.1.1
	GCC-2_95_pre3_20000527:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.4
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	CYGNUS-990629:1.1.1.1
	CYGNUS-990608:1.1.1.1
	CYGNUS-19990517:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2013.08.06.19.17.09;	author miod;	state dead;
branches;
next	1.1;

1.1
date	99.05.26.13.38.05;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.26.13.38.05;	author espie;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove gcc 2.95 from the tree. One of the least bogus compiler we had (although
it had required some generous bandaid), but unfortunately not able to compile
most of the Real World (tm) software.
@
text
@typedef BYTE unsigned char;typedef int item_n;typedef int perm_set;struct
PENT{caddr_t v_addr;};typedef struct PENT prec;typedef struct PENT*
prec_t;prec_t mem_hash;BYTE*mem_base;struct PTE{BYTE*p_page;perm_set
p_perms;};typedef struct PTE pte;struct PTP{union{struct*PTP
p_tablep;struct*PTE p_entry;}u;int valid;};typedef struct PTP
(u.p_tablep);int pfree=0;int pcount=0;void mmu_walk_find(va)caddr_t va;{
BYTE*page_addr;if(mmu_base[Level1(va)]->valid==0x0){l1_base=
mmu_base[Level1(va)]->(u.p_tablep)=p_alloc();mmu_base[Level1(va)]->valid=
0x3;for(idx=0;idx<LEVEL1_ENTRIES;idx++)l1_base[idx]->valid=0x0;goto
build_level2;}else l1_base=mmu_base[Level1(va)]->(u.p_tablep);if
(l1_base[Level2(va)]->valid==0x0){build_level2:l2_base=
l1_base[Level2(va)]->(u.p_tablep)=p_alloc();l1_base[Level2(va)]->valid=
0x3;for(idx=0;idx<LEVEL2_ENTRIES;idx++)l2_base[idx]->valid=0x0;goto
build_page;}else l2_base=mmu_base[Level2(va)]->(u.p_tablep);
page_addr=l2_base[Level2(va)]->valid;}void*a_translate(va_op,v_addr)int
va_op;caddr_t v_addr;{register prec_t bucket;register caddr_t p_addr;
bucket=mem_hash+((((v_addr)>>ITEMBITS))&hash_mask);do{if
(bucket->v_addr==((v_addr)>>ITEMBITS){if(!(bucket->perm_set&va_op))
goto prot_fault;return mem_base+v_addr;}}while((bucket++)->v_addr!=
((caddr_t)0));page_miss:p_addr=(--bucket)->p_addr;page_type:switch
(p_addr){case BUCKET_FULL:enlarge_hash_table(mem_hash);case((caddr_t)0):
p_addr=fill_item_entry(va_op,v_addr);goto page_type;case((caddr_t)1):
default:((void)(((0))?0:(__eprintf("Failed assertion`%s'at line%d
of`%s'.\n","FALSE",327,"b.c"),0)));}}void flush_hash(hasht,
hash_size)prec_t hasht;int hash_size;{register prec_t bucket;register int
idx;bucket=hasht;for(idx=(hash_size*3)-1;idx>=0;idx--){
bucket->v_addr=((caddr_t)0);bucket->p_addr=((caddr_t)0);
bucket->perm_set=VA_EMPTY;}}void init_mem(){mem_base=(BYTE*)calloc(1024
,(1<<13));((void)((mem_base!=(BYTE*)0)?0:(__eprintf("Failed
assertion`%s'at line%d of`%s'.\n","mem_base!=(BYTE*)0",366,"b.c"),
0)));hash_num=INIT_NUM_ENTRIES*3;mem_hash=(prec_t)calloc(hash_num,
sizeof(prec));((void)((mem_hash!=(prec_t)0)?0:(__eprintf("Failed
assertion`%s'at line%d of`%s'.\n","mem_hash!=(prec_t)0",370,"b.c"),
0)));flush_hash(mem_hash,32);build_ptables(mem_base,1024*(1<<13));}
struct tm{int tm_sec;int tm_min;int tm_hour;int tm_mday;int tm_mon;int
tm_year;int tm_wday;int tm_yday;int tm_isdst;char*tm_zone;long tm_gmtoff;};
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@egcs projects compiler system
Exact copy of the snapshot, except for the removal of
	texinfo/
	gcc/ch/
	libchill/

@
text
@@
