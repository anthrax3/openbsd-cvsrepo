head	1.2;
access;
symbols
	OPENBSD_5_4:1.1.1.1.0.58
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.56
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.54
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.52
	OPENBSD_5_0:1.1.1.1.0.50
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.48
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.46
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.42
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.44
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.40
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.38
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.36
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.34
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.32
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.30
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.28
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.26
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.24
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.22
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.20
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.18
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.16
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.14
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.12
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.10
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.8
	OPENBSD_2_9_BASE:1.1.1.1
	GCC-2_95_pre3_test2:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.6
	OPENBSD_2_8_BASE:1.1.1.1
	GCC-2_95_pre3_20000916:1.1.1.1
	GCC-2_95_pre3_20000527:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.4
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	CYGNUS-990629:1.1.1.1
	CYGNUS-990608:1.1.1.1
	CYGNUS-19990517:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2013.08.06.19.17.06;	author miod;	state dead;
branches;
next	1.1;

1.1
date	99.05.26.13.37.52;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.26.13.37.52;	author espie;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove gcc 2.95 from the tree. One of the least bogus compiler we had (although
it had required some generous bandaid), but unfortunately not able to compile
most of the Real World (tm) software.
@
text
@struct sw {
  const void *x;
  int r;
};
struct sq {
  struct sw *q_w;
  int t;
  int z;
};

int
f (int ch, char *fp, char *ap)
{
  register int n;
  register char *cp;
  register struct sw *p;
  register int f;
  int prec;
  double _double;
  int expt;
  int ndig;
  char expstr[7];
  unsigned long long _uquad;
  struct sq q;
  struct sw w[8];
  static char zeroes[16];

  for (;;) {
    switch (ch) {
    case 'd':
      _double = (double) (ap += 8, *((double *) (ap - 8)));
      break;
    case 'o':
      goto nosign;
    case 'u':
      _uquad = (f & 0x020 ? (ap += 8, *((long long *) (ap - 8))) : f & 0x010 ? (ap += 4, *((long *) (ap - 4))) : f & 0x040 ? (long)(short)(ap += 4, *((int *) (ap - 4))) : (long)(ap += 4, *((int *) (ap - 4))));
      goto nosign;
    case 'x':
      _uquad = (f & 0x020 ? (ap += 8, *((long long *) (ap - 8))) : f & 0x010 ? (ap += 4, *((long *) (ap - 4))) : f & 0x040 ? (long)(unsigned short)(ap += 4, *((int *) (ap - 4))) : (long)(ap += 4, *((int *) (ap - 4))));
    nosign:
      if (_uquad != 0 || prec != 0);
      break;
    default:
    }
    if ((f & 0x100) == 0) {
    } else {
      if (ch >= 'f') {
	if (_double == 0) {
	  if (expt < ndig || (f & 0x001) != 0) {
	    { if ((n = (ndig - 1)) > 0) { while (n > 16) {{ p->x = (zeroes); p->r = 16; q.z += 16; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }} n -= 16; }{ p->x = (zeroes); p->r = n; q.z += n; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }}}}
	  }
	} else if (expt <= 0) {
	  { p->x = ("0"); p->r = 1; q.z += 1; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }}
	  { p->x = 0; p->r = 1; q.z += 1; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }}
	  { if ((n = (-expt)) > 0) { while (n > 16) {{ p->x = (zeroes); p->r = 16; q.z += 16; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }} n -= 16; }{ p->x = (zeroes); p->r = n; q.z += n; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }} }}
	  { p->x = cp; p->r = ndig; q.z += ndig; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }}
	} else {
	  { p->x = cp; p->r = expt; q.z += expt; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }}
	  cp += expt;
	  { p->x = ("."); p->r = 1; q.z += 1; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }}
	  { p->x = cp; p->r = (ndig-expt); q.z += (ndig-expt); p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }}
	}
      }
    }
  }

 error:
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@egcs projects compiler system
Exact copy of the snapshot, except for the removal of
	texinfo/
	gcc/ch/
	libchill/

@
text
@@
