head	1.2;
access;
symbols
	OPENBSD_5_4:1.1.1.1.0.58
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.56
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.54
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.52
	OPENBSD_5_0:1.1.1.1.0.50
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.48
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.46
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.42
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.44
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.40
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.38
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.36
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.34
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.32
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.30
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.28
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.26
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.24
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.22
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.20
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.18
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.16
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.14
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.12
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.10
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.8
	OPENBSD_2_9_BASE:1.1.1.1
	GCC-2_95_pre3_test2:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.6
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.4
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	CYGNUS-990629:1.1.1.1
	CYGNUS-990608:1.1.1.1
	CYGNUS-19990517:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2013.08.06.19.17.10;	author miod;	state dead;
branches;
next	1.1;

1.1
date	99.05.26.13.38.14;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.26.13.38.14;	author espie;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove gcc 2.95 from the tree. One of the least bogus compiler we had (although
it had required some generous bandaid), but unfortunately not able to compile
most of the Real World (tm) software.
@
text
@void *malloc ();
struct timeval {
	long	tv_sec;
	long	tv_usec;
};
struct timezone {
	int	tz_minuteswest;
	int	tz_dsttime;
};
struct	itimerval {
	struct	timeval it_interval;
	struct	timeval it_value;
};
typedef	int		sigset_t;
typedef	unsigned int	speed_t;
typedef	unsigned long	tcflag_t;
typedef	unsigned char	cc_t;
typedef	int		pid_t;
typedef	unsigned short	mode_t;
typedef	short		nlink_t;
typedef	long		clock_t;
typedef	long		time_t;
typedef	int		size_t;
typedef int		ptrdiff_t;
typedef	unsigned short	wchar_t;
struct	tm {
	int	tm_sec;
	int	tm_min;
	int	tm_hour;
	int	tm_mday;
	int	tm_mon;
	int	tm_year;
	int	tm_wday;
	int	tm_yday;
	int	tm_isdst;
	char	*tm_zone;
	long	tm_gmtoff;
};
extern	struct tm *gmtime(), *localtime();
extern	char *asctime(), *ctime();
extern	void tzset(), tzsetwall();
extern  int dysize();
extern  time_t timelocal(), timegm();
struct	rusage {
	struct timeval ru_utime;
	struct timeval ru_stime;
	long	ru_maxrss;
	long	ru_ixrss;
	long	ru_idrss;
	long	ru_isrss;
	long	ru_minflt;
	long	ru_majflt;
	long	ru_nswap;
	long	ru_inblock;
	long	ru_oublock;
	long	ru_msgsnd;
	long	ru_msgrcv;
	long	ru_nsignals;
	long	ru_nvcsw;
	long	ru_nivcsw;
};
struct rlimit {
	int	rlim_cur;
	int	rlim_max;
};
unsigned long
cputime ()
{
    struct rusage rus;
    getrusage (0, &rus);
    return (((rus.ru_utime.tv_sec + rus.ru_stime.tv_sec) * 1000000) +
	    rus.ru_utime.tv_usec + rus.ru_stime.tv_usec) / 1000;
}
int
do_assoc_test (mem, start, cc)
     register char *mem;
     register int start;
     register int cc;
{
  register int j;
  register int ind = start;
  register int x;
  for (j = 0x100000; --j >= 0; )
    {
      int x = ((volatile char *) mem)[ind];
      ind -= cc;
      if (ind < 0)
	ind = start;
    }
  return x;
}
int
determine_assoc (size)
{
  register char *mem = malloc (size * (1 << 5 ));
  int cc = size;
  int lbsets;
  int times[5  + 1];
  for (lbsets = 0; lbsets <= 5; lbsets++)
    {
      int t = cputime ();
      do_assoc_test (mem, (cc << lbsets) - cc, cc);
      t = cputime () - t;
      times[lbsets] = t;
      printf ("sets = %2u: %u ms\n", 1 << lbsets, t);
    }
  free (mem);
  {
    int max = 1000 * times[1] / times[0];
    int maxindex = 0;
    int min = 1000 * times[1] / times[0];
    int minindex = 0;
    for (lbsets = 1; lbsets < 4; lbsets++)
      {
	int x = 1000 * times[lbsets + 1] / times[lbsets];
	if (x > max)
	  {
	    max = x;
	    maxindex = lbsets;
	  }
	if (x < min)
	  {
	    min = x;
	    minindex = lbsets;
	  }
      }
    if (min * 100 > max * 75)
      return 0;
    return 1 << maxindex;
  }
}
do_size_test(mem, size, reps)
     register int *mem;
     register int size;
     register int reps;
{
  register int j, i, x;
  mem += size;
  for (j = reps; --j >= 0;)
    for (i = -size; i < 0; i++)
      x = ((volatile int *) mem)[i];
}
int
determine_size()
{
  register int *mem = malloc (1 << 20 );
  int lbsize;
  int times[20 ];
  for (lbsize = 12; lbsize < 20; lbsize++)
    {
      int t = cputime ();
      do_size_test (mem, (1 << lbsize) / sizeof (int) - 64,
		    0x1000000  >> lbsize);
      t = cputime () - t;
      times[lbsize] = t;
      printf ("size = %2u: %u ms\n", 1 << lbsize, t);
    }
  free (mem);
  {
    int max = 1000 * times[12  + 1] / times[12 ];
    int maxindex = 0;
    int min = 1000 * times[12  + 1] / times[12 ];
    int minindex = 0;
    for (lbsize = 12; lbsize < 20  - 1; lbsize++)
      {
	int x = 1000 * times[lbsize + 1] / times[lbsize];
	if (x > max)
	  {
	    max = x;
	    maxindex = lbsize;
	  }
	if (x < min)
	  {
	    min = x;
	    minindex = lbsize;
	  }
      }
    if (min * 100 > max * 75)
      return 0;
    return 1 << maxindex;
  }
}
int
main()
{
  int size, assoc;
  size = determine_size();
  if (size)
    printf ("I guess this cache is %d bytes.\n", size);
  else
    printf ("I can't determine the size from this run.\n");
  if (size == 0)
    size = 65536;
  assoc = determine_assoc(size);
  if (assoc > 1)
    printf ("I guess this cache is %d-way set associative.\n", assoc);
  else if (assoc == 1)
    printf ("I guess this cache is direct mapped.\n");
  else
    printf ("I can't determine the associativity from this run.\n");
  return 0;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@egcs projects compiler system
Exact copy of the snapshot, except for the removal of
	texinfo/
	gcc/ch/
	libchill/

@
text
@@
