head	1.2;
access;
symbols
	OPENBSD_5_4:1.1.1.1.0.58
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.56
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.54
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.52
	OPENBSD_5_0:1.1.1.1.0.50
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.48
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.46
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.42
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.44
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.40
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.38
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.36
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.34
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.32
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.30
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.28
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.26
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.24
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.22
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.20
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.18
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.16
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.14
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.12
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.10
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.8
	OPENBSD_2_9_BASE:1.1.1.1
	GCC-2_95_pre3_test3:1.1.1.1
	GCC-2_95_pre3_test2:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.6
	OPENBSD_2_8_BASE:1.1.1.1
	GCC-2_95_pre3_20000916:1.1.1.1
	GCC-2_95_pre3_20000527:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.4
	OPENBSD_2_7_BASE:1.1.1.1
	GCC-2_95_2:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	GCC-2_95_1:1.1.1.1
	CYGNUS-990718:1.1.1.1
	CYGNUS-990629:1.1.1.1
	CYGNUS-990608:1.1.1.1
	CYGNUS-19990517:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2013.08.06.19.16.39;	author miod;	state dead;
branches;
next	1.1;

1.1
date	99.05.26.13.34.21;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.26.13.34.21;	author espie;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove gcc 2.95 from the tree. One of the least bogus compiler we had (although
it had required some generous bandaid), but unfortunately not able to compile
most of the Real World (tm) software.
@
text
@/* getpwd.c - get the working directory */

#include "config.h"
#include "system.h"

/* Virtually every UN*X system now in common use (except for pre-4.3-tahoe
   BSD systems) now provides getcwd as called for by POSIX.  Allow for
   the few exceptions to the general rule here.  */

#if !(defined (POSIX) || defined (USG) || defined (VMS)) || defined (HAVE_GETWD)
#define getcwd(buf,len) getwd(buf)
#ifdef MAXPATHLEN
#define GUESSPATHLEN (MAXPATHLEN + 1)
#else
#define GUESSPATHLEN 100
#endif
#else /* (defined (USG) || defined (VMS)) */
/* We actually use this as a starting point, not a limit.  */
#define GUESSPATHLEN 100
#endif /* (defined (USG) || defined (VMS)) */

#if !(defined (VMS) || (defined(_WIN32) && !defined(__CYGWIN__)))

/* Get the working directory.  Use the PWD environment variable if it's
   set correctly, since this is faster and gives more uniform answers
   to the user.  Yield the working directory if successful; otherwise,
   yield 0 and set errno.  */

char *
getpwd ()
{
  static char *pwd;
  static int failure_errno;

  char *p = pwd;
  size_t s;
  struct stat dotstat, pwdstat;

  if (!p && !(errno = failure_errno))
    {
      if (! ((p = getenv ("PWD")) != 0
	     && *p == '/'
	     && stat (p, &pwdstat) == 0
	     && stat (".", &dotstat) == 0
	     && dotstat.st_ino == pwdstat.st_ino
	     && dotstat.st_dev == pwdstat.st_dev))

	/* The shortcut didn't work.  Try the slow, ``sure'' way.  */
	for (s = GUESSPATHLEN;  ! getcwd (p = xmalloc (s), s);  s *= 2)
	  {
	    int e = errno;
	    free (p);
#ifdef ERANGE
	    if (e != ERANGE)
#endif
	      {
		errno = failure_errno = e;
		p = 0;
		break;
	      }
	  }

      /* Cache the result.  This assumes that the program does
	 not invoke chdir between calls to getpwd.  */
      pwd = p;
    }
  return p;
}

#else	/* VMS || _WIN32 && !__CYGWIN__ */

#ifndef MAXPATHLEN
#define MAXPATHLEN 255
#endif

char *
getpwd ()
{
  static char *pwd = 0;

  if (!pwd)
    pwd = getcwd (xmalloc (MAXPATHLEN + 1), MAXPATHLEN + 1
#ifdef VMS
		  , 0
#endif
		  );
  return pwd;
}

#endif	/* VMS || _WIN32 && !__CYGWIN__ */
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@egcs projects compiler system
Exact copy of the snapshot, except for the removal of
	texinfo/
	gcc/ch/
	libchill/

@
text
@@
