head	1.2;
access;
symbols
	OPENBSD_5_4:1.1.1.1.0.58
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.56
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.54
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.52
	OPENBSD_5_0:1.1.1.1.0.50
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.48
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.46
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.42
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.44
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.40
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.38
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.36
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.34
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.32
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.30
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.28
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.26
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.24
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.22
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.20
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.18
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.16
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.14
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.12
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.10
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.8
	OPENBSD_2_9_BASE:1.1.1.1
	GCC-2_95_pre3_test3:1.1.1.1
	GCC-2_95_pre3_test2:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.6
	OPENBSD_2_8_BASE:1.1.1.1
	GCC-2_95_pre3_20000916:1.1.1.1
	GCC-2_95_pre3_20000527:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.4
	OPENBSD_2_7_BASE:1.1.1.1
	GCC-2_95_2:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	GCC-2_95_1:1.1.1.1
	CYGNUS-990718:1.1.1.1
	CYGNUS-990629:1.1.1.1
	CYGNUS-990608:1.1.1.1
	CYGNUS-19990517:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2013.08.06.19.16.38;	author miod;	state dead;
branches;
next	1.1;

1.1
date	99.05.26.13.34.09;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.26.13.34.09;	author espie;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove gcc 2.95 from the tree. One of the least bogus compiler we had (although
it had required some generous bandaid), but unfortunately not able to compile
most of the Real World (tm) software.
@
text
@/*
**  DosFCheck - check file names for DOS consistency
**
**  Distribute freely, it only encourages DOS compatibility!
**  - DJ Delorie
*/

/* This file is not part of GCC.  */

#include <stdio.h>
#ifdef __MSDOS__
#include <alloc.h>
#else
#include <malloc.h>
#endif
#include <ctype.h>
#include <string.h>

typedef struct ENT
{
  struct ENT *next;
  char *dos_name;
  char *full_name;
  char *path;
  int tagged;
} ENT;

ENT *eroot = 0;

int first_inv = 1;
int first_msg = 1;

/****************************************************************\
 *  Utility routines						*
\****************************************************************/

void
invalid_msg ()
{
  if (first_inv)
    {
      if (first_msg)
	first_msg = 0;
      else
	putchar ('\n');
      printf ("The following files are not valid DOS file names:\n");
      first_inv = 0;
    }
}

ENT *
alloc_ent ()
{
  ENT *rv = (ENT *)malloc (sizeof (ENT));
  if (rv == 0)
    {
      fprintf (stderr, "Unable to allocate memory for an ENT\n");
      exit (1);
    }
  memset (rv, 0, sizeof (ENT));
  return rv;
}

void
fill_ent (ent, path)
ENT *ent;
char *path;
{
  char *first = path;
  char *null = path+strlen (path);
  char *last_slash = strrchr (path, '/');
  char *cp, *dp;
  int dots_seen, chars_seen;
  
  if (last_slash+1 == null)
    {
      * --null = '\0';
      last_slash = strrchr (path, '/');
    }
  
  if (!last_slash)
    {
      last_slash = first-1;
    }

  if (null-last_slash < 13)
    ent->dos_name = (char *)malloc (null-last_slash);
  else
    ent->dos_name = (char *)malloc (13);
  ent->full_name = (char *)malloc (null-last_slash);
  ent->path = (char *)malloc (last_slash-first+1);

  strcpy (ent->full_name, last_slash+1);
  if (last_slash > first)
    {
      strncpy (ent->path, first, last_slash-first);
      ent->path[last_slash-first] = '\0';
    }
  else
    *ent->path = '\0';

  cp = last_slash+1;
  dp = ent->dos_name;
  dots_seen = 0;
  chars_seen = 0;
  while (1)
    {
      if (! *cp)
	break;
      switch (*cp)
	{
	case '.':
	  if (cp == last_slash+1 && strcmp (last_slash+1, "."))
	    {
	      invalid_msg ();
	      printf ("%s - file name cannot start with dot\n", path);
	      *dp = 0;
	      break;
	    }
	  if (dots_seen == 1)
	    {
	      invalid_msg ();
	      printf ("%s - too many dots\n", path);
	      *dp = '\0';
	      break;
	    }
	  *dp++ = '.';
	  chars_seen = 0;
	  dots_seen++;
	  break;
	case '"':
	case '*':
	case '+':
	case ',':
	case ';':
	case '<':
	case '=':
	case '>':
	case '?':
	case '[':
	case '\\':
	case ']':
	case '|':
	  invalid_msg ();
	  printf ("%s - invalid character `%c'\n", path, *cp);
	  *dp++ = '?';
	  chars_seen++;
	  break;
	default:
	  if (dots_seen)
	    {
	      if (chars_seen >= 3)
		break;
	    }
	  else
	    if (chars_seen >= 8)
	      break;
	  if ((*cp <= ' ') || (*cp >= 0x7f))
	    {
	      invalid_msg ();
	      printf ("%s - invalid character `%c'\n", path, *cp);
	      *dp++ = '?';
	      chars_seen++;
	      break;
	    }
	  if (islower (*cp))
	    *dp++ = toupper (*cp);
	  else
	    *dp++ = *cp;
	  chars_seen++;
	  break;
	}
      cp++;
    }
  *dp++ = '\0';
}

int
compare_ent_dosname (e1, e2)
ENT **e1;
ENT **e2;
{
  int r = strcmp ((*e1)->dos_name, (*e2)->dos_name);
  if (r == 0)
    r = strcmp ((*e1)->path, (*e2)->path);
  if (r == 0)
    r = strcmp ((*e1)->full_name, (*e2)->full_name);
  return r;
}

int
compare_ent_fullname (e1, e2)
ENT **e1;
ENT **e2;
{
  int r = strncmp ((*e1)->full_name, (*e2)->full_name, 14);
  if (r == 0)
    r = strcmp ((*e1)->path, (*e2)->path);
  if (r == 0)
    r = strcmp ((*e1)->full_name, (*e2)->full_name);
  return r;
}

char *
mpath (ent)
ENT *ent;
{
  static char buf[500];
  if (ent->path && ent->path[0])
    sprintf (buf, "%s/%s", ent->path, ent->full_name);
  else
    return ent->full_name;
  return buf;
}

/****************************************************************\
 *  List handling routines					*
\****************************************************************/

void
add_ent (ent)
ENT *ent;
{
  ent->next = eroot;
  eroot = ent;
}

void
handle_input (line)
char *line;
{
  ENT *ent = alloc_ent ();
  fill_ent (ent, line);
  add_ent (ent);
}

void
display_problems ()
{
  ENT **elist, *ent;
  int ecount, i, first, first_err;
  
  for (ecount=0, ent=eroot; ent; ent=ent->next, ecount++);
  elist = (ENT **)malloc (sizeof (ENT *) * ecount);
  for (ecount=0, ent=eroot; ent; ent=ent->next, ecount++)
    elist[ecount] = ent;

  qsort (elist, ecount, sizeof (ENT *), compare_ent_dosname);

  first = 1;
  first_err = 1;
  for (i=0; i<ecount-1; i++)
    {
      if ((strcmp (elist[i]->dos_name, elist[i+1]->dos_name) == 0)
	  && (strcmp (elist[i]->path, elist[i+1]->path) == 0))
	{
	  if (first_err)
	    {
	      if (first_msg)
		first_msg = 0;
	      else
		putchar ('\n');
	      printf ("The following resolve to the same DOS file names:\n");
	      first_err = 0;
	    }
	  if (first)
	    {
	      printf ("%14s : %s\n", elist[i]->dos_name, mpath (elist[i]));
	      first = 0;
	    }
	  printf ("\t\t %s\n", mpath (elist[i+1]));
	}
      else
	first = 1;
    }

  qsort (elist, ecount, sizeof (ENT *), compare_ent_fullname);

  first = 1;
  first_err = 1;
  for (i=0; i<ecount-1; i++)
    {
      if ((strncmp (elist[i]->full_name, elist[i+1]->full_name, 14) == 0)
	  && (strcmp (elist[i]->path, elist[i+1]->path) == 0))
	{
	  if (first_err)
	    {
	      if (first_msg)
		first_msg = 0;
	      else
		putchar ('\n');
	      printf ("The following resolve to the same SysV file names:\n");
	      first_err = 0;
	    }
	  if (first)
	    {
	      printf ("%.14s : %s\n", elist[i]->full_name, mpath (elist[i]));
	      first = 0;
	      elist[i]->tagged = 1;
	    }
	  printf ("\t\t %s\n", mpath (elist[i+1]));
	  elist[i+1]->tagged = 1;
	}
      else
	first = 1;
    }

  first_err = 1;
  for (i=0; i<ecount; i++)
    {
      if ((strlen (elist[i]->full_name) > 14) && !elist[i]->tagged)
	{
	  if (first_err)
	    {
	      if (first_msg)
		first_msg = 0;
	      else
		putchar ('\n');
	      printf ("The following file names are too long for SysV:\n");
	      first_err = 0;
	    }
	  printf ("%.14s : %s\n", elist[i]->full_name, mpath (elist[i]));
	}
    }
}

/****************************************************************\
 *  Main entry point						*
\****************************************************************/

main (argc, argv)
int argc;
char **argv;
{
  FILE *input = stdin;
  if (argc > 1)
    {
      input = fopen (argv[1], "r");
      if (!input)
	{
	  perror (argv[1]);
	  exit (1);
	}
    }
  while (1)
    {
      char line[500];
      char *lp;
      fgets (line, 500, input);
      if (feof (input))
	break;
      lp = line+strlen (line);
      while ((lp != line) && (*lp <= ' '))
	lp--;
      lp[1] = 0;
      handle_input (line);
    }
  display_problems ();
}

@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@egcs projects compiler system
Exact copy of the snapshot, except for the removal of
	texinfo/
	gcc/ch/
	libchill/

@
text
@@
