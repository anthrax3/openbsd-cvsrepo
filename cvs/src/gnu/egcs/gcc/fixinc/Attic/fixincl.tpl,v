head	1.2;
access;
symbols
	OPENBSD_5_4:1.1.1.2.0.58
	OPENBSD_5_4_BASE:1.1.1.2
	OPENBSD_5_3:1.1.1.2.0.56
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.54
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.52
	OPENBSD_5_0:1.1.1.2.0.50
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.48
	OPENBSD_4_9_BASE:1.1.1.2
	OPENBSD_4_8:1.1.1.2.0.46
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.42
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.44
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.40
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.38
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.36
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.34
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.32
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.30
	OPENBSD_4_0_BASE:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.28
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.26
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.24
	OPENBSD_3_7_BASE:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.22
	OPENBSD_3_6_BASE:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.20
	OPENBSD_3_5_BASE:1.1.1.2
	OPENBSD_3_4:1.1.1.2.0.18
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.16
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.14
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.12
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.10
	OPENBSD_3_0_BASE:1.1.1.2
	OPENBSD_2_9:1.1.1.2.0.8
	OPENBSD_2_9_BASE:1.1.1.2
	GCC-2_95_pre3_test3:1.1.1.2
	GCC-2_95_pre3_test2:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.6
	OPENBSD_2_8_BASE:1.1.1.2
	GCC-2_95_pre3_20000916:1.1.1.2
	GCC-2_95_pre3_20000527:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.4
	OPENBSD_2_7_BASE:1.1.1.2
	GCC-2_95_2:1.1.1.2
	OPENBSD_2_6:1.1.1.2.0.2
	OPENBSD_2_6_BASE:1.1.1.2
	GCC-2_95_1:1.1.1.2
	CYGNUS-990718:1.1.1.2
	CYGNUS-990629:1.1.1.2
	CYGNUS-990608:1.1.1.2
	CYGNUS-19990517:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2013.08.06.19.16.48;	author miod;	state dead;
branches;
next	1.1;

1.1
date	99.05.26.13.36.12;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.26.13.36.12;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.06.17.21.25.38;	author espie;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove gcc 2.95 from the tree. One of the least bogus compiler we had (although
it had required some generous bandaid), but unfortunately not able to compile
most of the Real World (tm) software.
@
text
@[= autogen template -*- Mode: C -*-
x =]
/*
 *  DO NOT EDIT THIS FILE - it has been generated
 *
 * Install modified versions of certain ANSI-incompatible system header
 * files which are fixed to work correctly with ANSI C and placed in a
 * directory that GNU C will search.
 *
 * This file contains [=_eval fix _count =] fixup descriptions.
 *
 * See README-fixinc for more information.
 *
 *  inclhack copyright (c) [=_eval "date +%Y" _shell
                                =] The Free Software Foundation, Inc.
 *
[=_eval inclhack "# *  " _gpl=]
 *[=_EVAL "re_ct=0" _shell=][=

_FOR fix =]
 *
 *  Description [=_eval _index 1 + "#%3d -" _printf=] [=hackname _Cap=] fix
 */
tSCC z[=hackname _cap=]Name[] =
     [=hackname _cap _str=];
/*
 *  File name selection pattern
 */[=

  _IF files _exist=]
tSCC z[=hackname _cap=]List[] =[=
    _FOR files=]
        "|" [=files _str=][=
    /files=] "|";[=

  _ELSE =]
#define z[=hackname _cap=]List (char*)NULL[=
  _ENDIF "files _exist" =]
/*
 *  Machine/OS name selection pattern
 */[=

  _IF mach _exist=]
tSCC* apz[=hackname _cap=]Machs[] = {[=
    _FOR mach =]
        [=mach _str=],[=
    /mach=]
        (const char*)NULL };[=

  _ELSE =]
#define apz[=hackname _cap=]Machs (const char**)NULL[=
  _ENDIF "files _exist" =][=

  _IF exesel _exist=]

/*
 *  content selection pattern - do fix if pattern found
 *  This is a special pattern that not all egrep commands
 *  are capable of coping with.  We use the GNU library, tho :)
 */[=
    _FOR exesel =]
tSCC z[=hackname _cap=]Select[=_eval _index=][] =
       [=exesel _str=];[=
    /exesel =][=

  _ELIF select _exist=]

/*
 *  content selection pattern - do fix if pattern found
 */[=
    _FOR select =]
tSCC z[=hackname _cap=]Select[=_eval _index=][] =
       [=select _str=];[=
    /select =][=
  _ENDIF =][=

  _IF bypass _exist=]

/*
 *  content bypass pattern - skip fix if pattern found
 */[=
    _FOR bypass =]
tSCC z[=hackname _cap=]Bypass[=_eval _index=][] =
       [=bypass _str=];[=
    /bypass =][=
  _ENDIF =][=

  _IF test _exist=]

/*
 *  perform the 'test' shell command - do fix on success
 */[=
    _FOR test =]
tSCC z[=hackname _cap=]Test[=_eval _index=][] =
       [=test _str=];[=
    /test =][=
  _ENDIF =][=


#  Build the array of test descriptions for this fix: =][=

  _IF exesel       _exist
      select       _exist |
      bypass       _exist |
      test         _exist |
=]

#define    [=hackname _up =]_TEST_CT  [=
    _IF exesel _exist =][=
       _eval exesel       _count
      	     bypass       _count +
      	     test         _count + =][=
    _ELSE =][=
       _eval select       _count
      	     bypass       _count +
      	     test         _count + =][=
    _ENDIF =]
#define    [=hackname _up =]_RE_CT    [=
    _IF exesel _exist =][=
       _eval exesel _count bypass _count
             "#2$ct=`expr %d + %d` ; re_ct=`expr $ct + $re_ct` ; echo $ct"
             _printf _shell =][=
    _ELSE =][=
       _eval select _count bypass _count
             "#2$ct=`expr %d + %d` ; re_ct=`expr $ct + $re_ct` ; echo $ct"
             _printf _shell =][=
    _ENDIF =]
tTestDesc a[=hackname _cap=]Tests[] = {[=

    _FOR test =]
  { TT_TEST,   z[=hackname _cap=]Test[=_eval _index=],     0 /* unused */ },[=
    /test =][=

    _FOR bypass =]
  { TT_NEGREP, z[=hackname _cap=]Bypass[=_eval _index=],   (regex_t*)NULL },[=
    /bypass =][=

    #  IF there is an exesel, then use that (those) selection
          expressions, instead of the regular select expressions
    =][=
    _IF exesel _exist =][=
      _FOR exesel =]
  { TT_EGREP,  z[=hackname _cap=]Select[=_eval _index=],   (regex_t*)NULL },[=
      /exesel =][=

    _ELSE =][=
      _FOR select =]
  { TT_EGREP,  z[=hackname _cap=]Select[=_eval _index=],   (regex_t*)NULL },[=
      /select =][=
    _ENDIF =] };[=
  _ELSE =]
#define [=hackname _up=]_TEST_CT  0
#define [=hackname _up=]_RE_CT    0
#define a[=hackname _cap=]Tests   (tTestDesc*)NULL[=
  _ENDIF =]

/*
 *  Fix Command Arguments for [=hackname _cap=]
 */
const char* apz[=hackname _cap=]Patch[] = {[=
    _IF   sed         _exist =] "sed"[=_FOR sed=],
    "-e", [=sed _str=][=/sed=][=
    _ELIF shell       _exist =] "sh", "-c",
    [=shell _str=][=
    _ENDIF=],
    (char*)NULL };

/* * * * * * * * * * * * * * * * * * * * * * * * * *[=
/fix=]
 *
 *  List of all fixes
 */
#define  REGEX_COUNT  [=_eval "echo $re_ct" _shell =]
#define  FIX_COUNT    [=_eval fix _count =]
tFixDesc fixDescList[ FIX_COUNT ] = {[=


_FOR fix ",\n" =]
  {  z[=hackname _cap=]Name,    z[=hackname _cap=]List,
     apz[=hackname _cap=]Machs, (regex_t*)NULL,
     [=hackname  _up=]_TEST_CT, [=
       _IF not_machine _exist =]FD_MACH_IFNOT[=
       _ELSE                  =]FD_MACH_ONLY[=
       _ENDIF =],
     a[=hackname _cap=]Tests,   apz[=hackname _cap=]Patch }[=

/fix=]
};
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@egcs projects compiler system
Exact copy of the snapshot, except for the removal of
	texinfo/
	gcc/ch/
	libchill/

@
text
@@


1.1.1.2
log
@Update to 990608 snapshot.
Highlights:
- official fix for an alpha bug,
- cpp changes semantic slightly,
- valarray in libstdc++.
@
text
@d25 1
a25 1
     [=hackname _cap _krstr=];
d31 4
a34 2
tSCC z[=hackname _cap=]List[] =
  "[=_FOR files =]|[=files=][=/files=]|";[=
d46 1
a46 1
        [=mach _krstr=],[=
d63 1
a63 1
       [=exesel _krstr=];[=
d73 1
a73 1
       [=select _krstr=];[=
d84 1
a84 1
       [=bypass _krstr=];[=
d95 1
a95 1
       [=test _krstr=];[=
d162 1
a162 1
    "-e", [=sed _krstr=][=/sed=][=
d164 1
a164 1
    [=shell _krstr=][=
a183 2
       _ENDIF =][=
       _IF shell       _exist =] | FD_SHELL_SCRIPT[=
@

