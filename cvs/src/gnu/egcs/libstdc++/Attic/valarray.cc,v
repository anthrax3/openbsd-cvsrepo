head	1.2;
access;
symbols
	OPENBSD_5_4:1.1.1.1.0.58
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.56
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.54
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.52
	OPENBSD_5_0:1.1.1.1.0.50
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.48
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.46
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.42
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.44
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.40
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.38
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.36
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.34
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.32
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.30
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.28
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.26
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.24
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.22
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.20
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.18
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.16
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.14
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.12
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.10
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.8
	OPENBSD_2_9_BASE:1.1.1.1
	GCC-2_95_pre3_test3:1.1.1.1
	GCC-2_95_pre3_test2:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.6
	OPENBSD_2_8_BASE:1.1.1.1
	GCC-2_95_pre3_20000527:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.4
	OPENBSD_2_7_BASE:1.1.1.1
	GCC-2_95_2:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	GCC-2_95_1:1.1.1.1
	CYGNUS-990718:1.1.1.1
	CYGNUS-990629:1.1.1.1
	CYGNUS-990608:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@// @;


1.2
date	2013.08.06.19.17.14;	author miod;	state dead;
branches;
next	1.1;

1.1
date	99.06.17.22.18.51;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.06.17.22.18.51;	author espie;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove gcc 2.95 from the tree. One of the least bogus compiler we had (although
it had required some generous bandaid), but unfortunately not able to compile
most of the Real World (tm) software.
@
text
@#include <std/std_valarray.h>

// Some Explicit Instanciations.
template class multiplies<size_t>;
template size_t accumulate(size_t*, size_t*, size_t, multiplies<size_t>);

template void
   __valarray_fill(size_t* __restrict__, size_t, const size_t&);

template void
   __valarray_copy(const size_t* __restrict__, size_t, size_t* __restrict__);

template valarray<size_t>::valarray(size_t);
template valarray<size_t>::~valarray();
template valarray<size_t>::valarray(const valarray<size_t>&);
template size_t valarray<size_t>::size() const;
template size_t& valarray<size_t>::operator[](size_t);
template size_t valarray<size_t>::product() const;


void __gslice_to_index(size_t __o, const valarray<size_t>& __l,
                       const valarray<size_t>& __s,
                       valarray<size_t>& __i)
{
    const size_t __n = __l.size();
    size_t* const __t = static_cast<size_t*>(alloca(__n*sizeof(size_t)));
    __valarray_fill(__t, __n, size_t(0));
    const size_t __z = __i.size();
    __valarray_fill(&__i[0], __z, __o);
    for (size_t __j=0; __j<__z; ++__j) {
        for (size_t __k=0; __k<__n; ++__k)
            __i[__j] += __s[__k]*__t[__k];
        ++__t[__n-1];
        for (size_t __k=__n-1; __k; --__k) {
            if (__t[__k] >= __l[__k]) {
                __t[__k] = 0;
                ++__t[__k-1];
            }
        }
    }
}

_Indexer::_Indexer(size_t __o, const valarray<size_t>& __l,
                   const valarray<size_t>& __s)
        : _M_count(1), _M_start(__o), _M_size(__l), _M_stride(__s),
          _M_index(__l.size() ? __l.product() : 0)
{ __gslice_to_index(__o, __l, __s, _M_index); }



@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Update to 990608 snapshot.
Highlights:
- official fix for an alpha bug,
- cpp changes semantic slightly,
- valarray in libstdc++.
@
text
@@
