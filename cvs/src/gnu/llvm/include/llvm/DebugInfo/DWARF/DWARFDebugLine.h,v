head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.3
	OPENBSD_6_2:1.1.1.2.0.2
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.24.08.33.18;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	so2WA7LCP6wbxtYl;

1.1.1.3
date	2017.10.04.20.27.54;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- DWARFDebugLine.h ----------------------------------------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_LIB_DEBUGINFO_DWARFDEBUGLINE_H
#define LLVM_LIB_DEBUGINFO_DWARFDEBUGLINE_H

#include "llvm/DebugInfo/DIContext.h"
#include "llvm/DebugInfo/DWARF/DWARFRelocMap.h"
#include "llvm/Support/DataExtractor.h"
#include <map>
#include <string>
#include <vector>

namespace llvm {

class raw_ostream;

class DWARFDebugLine {
public:
  DWARFDebugLine(const RelocAddrMap* LineInfoRelocMap) : RelocMap(LineInfoRelocMap) {}
  struct FileNameEntry {
    FileNameEntry() : Name(nullptr), DirIdx(0), ModTime(0), Length(0) {}

    const char *Name;
    uint64_t DirIdx;
    uint64_t ModTime;
    uint64_t Length;
  };

  struct Prologue {
    Prologue();

    // The size in bytes of the statement information for this compilation unit
    // (not including the total_length field itself).
    uint64_t TotalLength;
    // Version identifier for the statement information format.
    uint16_t Version;
    // The number of bytes following the prologue_length field to the beginning
    // of the first byte of the statement program itself.
    uint64_t PrologueLength;
    // The size in bytes of the smallest target machine instruction. Statement
    // program opcodes that alter the address register first multiply their
    // operands by this value.
    uint8_t MinInstLength;
    // The maximum number of individual operations that may be encoded in an
    // instruction.
    uint8_t MaxOpsPerInst;
    // The initial value of theis_stmtregister.
    uint8_t DefaultIsStmt;
    // This parameter affects the meaning of the special opcodes. See below.
    int8_t LineBase;
    // This parameter affects the meaning of the special opcodes. See below.
    uint8_t LineRange;
    // The number assigned to the first special opcode.
    uint8_t OpcodeBase;
    std::vector<uint8_t> StandardOpcodeLengths;
    std::vector<const char*> IncludeDirectories;
    std::vector<FileNameEntry> FileNames;

    bool IsDWARF64;
    uint32_t sizeofTotalLength() const {
      return IsDWARF64 ? 12 : 4;
    }
    uint32_t sizeofPrologueLength() const {
      return IsDWARF64 ? 8 : 4;
    }

    // Length of the prologue in bytes.
    uint32_t getLength() const {
      return PrologueLength + sizeofTotalLength() + sizeof(Version) +
             sizeofPrologueLength();
    }
    // Length of the line table data in bytes (not including the prologue).
    uint32_t getStatementTableLength() const {
      return TotalLength + sizeofTotalLength() - getLength();
    }
    int32_t getMaxLineIncrementForSpecialOpcode() const {
      return LineBase + (int8_t)LineRange - 1;
    }

    void clear();
    void dump(raw_ostream &OS) const;
    bool parse(DataExtractor debug_line_data, uint32_t *offset_ptr);
  };

  // Standard .debug_line state machine structure.
  struct Row {
    explicit Row(bool default_is_stmt = false);

    /// Called after a row is appended to the matrix.
    void postAppend();
    void reset(bool default_is_stmt);
    void dump(raw_ostream &OS) const;

    static bool orderByAddress(const Row& LHS, const Row& RHS) {
      return LHS.Address < RHS.Address;
    }

    // The program-counter value corresponding to a machine instruction
    // generated by the compiler.
    uint64_t Address;
    // An unsigned integer indicating a source line number. Lines are numbered
    // beginning at 1. The compiler may emit the value 0 in cases where an
    // instruction cannot be attributed to any source line.
    uint32_t Line;
    // An unsigned integer indicating a column number within a source line.
    // Columns are numbered beginning at 1. The value 0 is reserved to indicate
    // that a statement begins at the 'left edge' of the line.
    uint16_t Column;
    // An unsigned integer indicating the identity of the source file
    // corresponding to a machine instruction.
    uint16_t File;
    // An unsigned integer whose value encodes the applicable instruction set
    // architecture for the current instruction.
    uint8_t Isa;
    // An unsigned integer representing the DWARF path discriminator value
    // for this location.
    uint32_t Discriminator;
    // A boolean indicating that the current instruction is the beginning of a
    // statement.
    uint8_t IsStmt:1,
            // A boolean indicating that the current instruction is the
            // beginning of a basic block.
            BasicBlock:1,
            // A boolean indicating that the current address is that of the
            // first byte after the end of a sequence of target machine
            // instructions.
            EndSequence:1,
            // A boolean indicating that the current address is one (of possibly
            // many) where execution should be suspended for an entry breakpoint
            // of a function.
            PrologueEnd:1,
            // A boolean indicating that the current address is one (of possibly
            // many) where execution should be suspended for an exit breakpoint
            // of a function.
            EpilogueBegin:1;
  };

  // Represents a series of contiguous machine instructions. Line table for each
  // compilation unit may consist of multiple sequences, which are not
  // guaranteed to be in the order of ascending instruction address.
  struct Sequence {
    // Sequence describes instructions at address range [LowPC, HighPC)
    // and is described by line table rows [FirstRowIndex, LastRowIndex).
    uint64_t LowPC;
    uint64_t HighPC;
    unsigned FirstRowIndex;
    unsigned LastRowIndex;
    bool Empty;

    Sequence();
    void reset();

    static bool orderByLowPC(const Sequence& LHS, const Sequence& RHS) {
      return LHS.LowPC < RHS.LowPC;
    }
    bool isValid() const {
      return !Empty && (LowPC < HighPC) && (FirstRowIndex < LastRowIndex);
    }
    bool containsPC(uint64_t pc) const {
      return (LowPC <= pc && pc < HighPC);
    }
  };

  struct LineTable {
    LineTable();

    // Represents an invalid row
    const uint32_t UnknownRowIndex = UINT32_MAX;

    void appendRow(const DWARFDebugLine::Row &R) {
      Rows.push_back(R);
    }
    void appendSequence(const DWARFDebugLine::Sequence &S) {
      Sequences.push_back(S);
    }

    // Returns the index of the row with file/line info for a given address,
    // or UnknownRowIndex if there is no such row.
    uint32_t lookupAddress(uint64_t address) const;

    bool lookupAddressRange(uint64_t address, uint64_t size,
                            std::vector<uint32_t> &result) const;

    // Extracts filename by its index in filename table in prologue.
    // Returns true on success.
    bool getFileNameByIndex(uint64_t FileIndex, const char *CompDir,
                            DILineInfoSpecifier::FileLineInfoKind Kind,
                            std::string &Result) const;

    // Fills the Result argument with the file and line information
    // corresponding to Address. Returns true on success.
    bool getFileLineInfoForAddress(uint64_t Address, const char *CompDir,
                                   DILineInfoSpecifier::FileLineInfoKind Kind,
                                   DILineInfo &Result) const;

    void dump(raw_ostream &OS) const;
    void clear();

    /// Parse prologue and all rows.
    bool parse(DataExtractor debug_line_data, const RelocAddrMap *RMap,
               uint32_t *offset_ptr);

    struct Prologue Prologue;
    typedef std::vector<Row> RowVector;
    typedef RowVector::const_iterator RowIter;
    typedef std::vector<Sequence> SequenceVector;
    typedef SequenceVector::const_iterator SequenceIter;
    RowVector Rows;
    SequenceVector Sequences;

  private:
    uint32_t findRowInSeq(const DWARFDebugLine::Sequence &seq,
                          uint64_t address) const;
  };

  const LineTable *getLineTable(uint32_t offset) const;
  const LineTable *getOrParseLineTable(DataExtractor debug_line_data,
                                       uint32_t offset);

private:
  struct ParsingState {
    ParsingState(struct LineTable *LT);

    void resetRowAndSequence();
    void appendRowToMatrix(uint32_t offset);

    // Line table we're currently parsing.
    struct LineTable *LineTable;
    // The row number that starts at zero for the prologue, and increases for
    // each row added to the matrix.
    unsigned RowNumber;
    struct Row Row;
    struct Sequence Sequence;
  };

  typedef std::map<uint32_t, LineTable> LineTableMapTy;
  typedef LineTableMapTy::iterator LineTableIter;
  typedef LineTableMapTy::const_iterator LineTableConstIter;

  const RelocAddrMap *RelocMap;
  LineTableMapTy LineTableMap;
};
}

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d119 3
a124 3
    // An unsigned integer whose value encodes the applicable instruction set
    // architecture for the current instruction.
    uint8_t Isa;
a189 2

    bool hasFileAtIndex(uint64_t FileIndex) const;
@


1.1.1.3
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@d1 1
a1 1
//===- DWARFDebugLine.h -----------------------------------------*- C++ -*-===//
d10 2
a11 2
#ifndef LLVM_DEBUGINFO_DWARFDEBUGLINE_H
#define LLVM_DEBUGINFO_DWARFDEBUGLINE_H
a12 1
#include "llvm/ADT/StringRef.h"
a13 2
#include "llvm/DebugInfo/DWARF/DWARFDataExtractor.h"
#include "llvm/DebugInfo/DWARF/DWARFFormValue.h"
d15 1
a15 1
#include <cstdint>
d26 1
d28 1
a28 1
    FileNameEntry() = default;
d30 4
a33 4
    StringRef Name;
    uint64_t DirIdx = 0;
    uint64_t ModTime = 0;
    uint64_t Length = 0;
d39 2
a40 2
    /// The size in bytes of the statement information for this compilation unit
    /// (not including the total_length field itself).
d42 4
a45 8
    /// Version, address size (starting in v5), and DWARF32/64 format; these
    /// parameters affect interpretation of forms (used in the directory and
    /// file tables starting with v5).
    DWARFFormParams FormParams;
    /// In v5, size in bytes of a segment selector.
    uint8_t SegSelectorSize;
    /// The number of bytes following the prologue_length field to the beginning
    /// of the first byte of the statement program itself.
d47 3
a49 3
    /// The size in bytes of the smallest target machine instruction. Statement
    /// program opcodes that alter the address register first multiply their
    /// operands by this value.
d51 2
a52 2
    /// The maximum number of individual operations that may be encoded in an
    /// instruction.
d54 1
a54 1
    /// The initial value of theis_stmtregister.
d56 1
a56 1
    /// This parameter affects the meaning of the special opcodes. See below.
d58 1
a58 1
    /// This parameter affects the meaning of the special opcodes. See below.
d60 1
a60 1
    /// The number assigned to the first special opcode.
d63 1
a63 1
    std::vector<StringRef> IncludeDirectories;
d66 7
a72 6
    const DWARFFormParams getFormParams() const { return FormParams; }
    uint16_t getVersion() const { return FormParams.Version; }
    uint8_t getAddressSize() const { return FormParams.AddrSize; }
    bool isDWARF64() const { return FormParams.Format == dwarf::DWARF64; }

    uint32_t sizeofTotalLength() const { return isDWARF64() ? 12 : 4; }
d74 1
a74 3
    uint32_t sizeofPrologueLength() const { return isDWARF64() ? 8 : 4; }

    /// Length of the prologue in bytes.
d76 1
a76 1
      return PrologueLength + sizeofTotalLength() + sizeof(getVersion()) +
d79 1
a79 2

    /// Length of the line table data in bytes (not including the prologue).
a82 1

d89 1
a89 1
    bool parse(const DWARFDataExtractor &DebugLineData, uint32_t *OffsetPtr);
d92 1
a92 1
  /// Standard .debug_line state machine structure.
d94 1
a94 1
    explicit Row(bool DefaultIsStmt = false);
d98 1
a98 1
    void reset(bool DefaultIsStmt);
d101 1
a101 3
    static void dumpTableHeader(raw_ostream &OS);

    static bool orderByAddress(const Row &LHS, const Row &RHS) {
d105 2
a106 2
    /// The program-counter value corresponding to a machine instruction
    /// generated by the compiler.
d108 3
a110 3
    /// An unsigned integer indicating a source line number. Lines are numbered
    /// beginning at 1. The compiler may emit the value 0 in cases where an
    /// instruction cannot be attributed to any source line.
d112 3
a114 3
    /// An unsigned integer indicating a column number within a source line.
    /// Columns are numbered beginning at 1. The value 0 is reserved to indicate
    /// that a statement begins at the 'left edge' of the line.
d116 2
a117 2
    /// An unsigned integer indicating the identity of the source file
    /// corresponding to a machine instruction.
d119 2
a120 2
    /// An unsigned integer representing the DWARF path discriminator value
    /// for this location.
d122 2
a123 2
    /// An unsigned integer whose value encodes the applicable instruction set
    /// architecture for the current instruction.
d125 23
a147 23
    /// A boolean indicating that the current instruction is the beginning of a
    /// statement.
    uint8_t IsStmt : 1,
        /// A boolean indicating that the current instruction is the
        /// beginning of a basic block.
        BasicBlock : 1,
        /// A boolean indicating that the current address is that of the
        /// first byte after the end of a sequence of target machine
        /// instructions.
        EndSequence : 1,
        /// A boolean indicating that the current address is one (of possibly
        /// many) where execution should be suspended for an entry breakpoint
        /// of a function.
        PrologueEnd : 1,
        /// A boolean indicating that the current address is one (of possibly
        /// many) where execution should be suspended for an exit breakpoint
        /// of a function.
        EpilogueBegin : 1;
  };

  /// Represents a series of contiguous machine instructions. Line table for
  /// each compilation unit may consist of multiple sequences, which are not
  /// guaranteed to be in the order of ascending instruction address.
d149 2
a150 4
    Sequence();

    /// Sequence describes instructions at address range [LowPC, HighPC)
    /// and is described by line table rows [FirstRowIndex, LastRowIndex).
d157 1
d160 1
a160 1
    static bool orderByLowPC(const Sequence &LHS, const Sequence &RHS) {
a162 1

d166 3
a168 2

    bool containsPC(uint64_t PC) const { return (LowPC <= PC && PC < HighPC); }
d174 1
a174 1
    /// Represents an invalid row
d177 3
a179 2
    void appendRow(const DWARFDebugLine::Row &R) { Rows.push_back(R); }

d184 3
a186 3
    /// Returns the index of the row with file/line info for a given address,
    /// or UnknownRowIndex if there is no such row.
    uint32_t lookupAddress(uint64_t Address) const;
d188 2
a189 2
    bool lookupAddressRange(uint64_t Address, uint64_t Size,
                            std::vector<uint32_t> &Result) const;
d193 2
a194 2
    /// Extracts filename by its index in filename table in prologue.
    /// Returns true on success.
d199 2
a200 2
    /// Fills the Result argument with the file and line information
    /// corresponding to Address. Returns true on success.
d209 2
a210 6
    bool parse(const DWARFDataExtractor &DebugLineData, uint32_t *OffsetPtr);

    using RowVector = std::vector<Row>;
    using RowIter = RowVector::const_iterator;
    using SequenceVector = std::vector<Sequence>;
    using SequenceIter = SequenceVector::const_iterator;
d213 4
d221 2
a222 2
    uint32_t findRowInSeq(const DWARFDebugLine::Sequence &Seq,
                          uint64_t Address) const;
d225 3
a227 3
  const LineTable *getLineTable(uint32_t Offset) const;
  const LineTable *getOrParseLineTable(const DWARFDataExtractor &DebugLineData,
                                       uint32_t Offset);
d234 1
a234 1
    void appendRowToMatrix(uint32_t Offset);
d236 1
a236 1
    /// Line table we're currently parsing.
d238 3
a240 3
    /// The row number that starts at zero for the prologue, and increases for
    /// each row added to the matrix.
    unsigned RowNumber = 0;
d245 3
a247 3
  using LineTableMapTy = std::map<uint32_t, LineTable>;
  using LineTableIter = LineTableMapTy::iterator;
  using LineTableConstIter = LineTableMapTy::const_iterator;
d249 1
d252 1
d254 1
a254 3
} // end namespace llvm

#endif // LLVM_DEBUGINFO_DWARFDEBUGLINE_H
@


