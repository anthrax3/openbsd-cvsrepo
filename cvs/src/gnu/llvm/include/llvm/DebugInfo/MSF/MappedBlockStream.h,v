head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.2
	OPENBSD_6_2:1.1.1.1.0.2
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.4
	OPENBSD_6_1_BASE:1.1.1.1
	LLVM_4_0_0:1.1.1.1
	LLVM_4_0_0_RC1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.1
date	2017.01.24.08.33.18;	author patrick;	state Exp;
branches
	1.1.1.1;
next	;
commitid	so2WA7LCP6wbxtYl;

1.1.1.1
date	2017.01.24.08.33.18;	author patrick;	state Exp;
branches;
next	1.1.1.2;
commitid	so2WA7LCP6wbxtYl;

1.1.1.2
date	2017.10.04.20.27.54;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===- MappedBlockStream.h - Discontiguous stream data in an MSF -*- C++
//-*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_DEBUGINFO_MSF_MAPPEDBLOCKSTREAM_H
#define LLVM_DEBUGINFO_MSF_MAPPEDBLOCKSTREAM_H

#include "llvm/ADT/ArrayRef.h"
#include "llvm/ADT/DenseMap.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/DebugInfo/MSF/MSFStreamLayout.h"
#include "llvm/DebugInfo/MSF/StreamInterface.h"
#include "llvm/Support/Allocator.h"
#include "llvm/Support/Endian.h"
#include "llvm/Support/Error.h"
#include <cstdint>
#include <vector>

namespace llvm {
namespace msf {

struct MSFLayout;

/// MappedBlockStream represents data stored in an MSF file into chunks of a
/// particular size (called the Block Size), and whose chunks may not be
/// necessarily contiguous.  The arrangement of these chunks MSF the file
/// is described by some other metadata contained within the MSF file.  In
/// the case of a standard MSF Stream, the layout of the stream's blocks
/// is described by the MSF "directory", but in the case of the directory
/// itself, the layout is described by an array at a fixed location within
/// the MSF.  MappedBlockStream provides methods for reading from and writing
/// to one of these streams transparently, as if it were a contiguous sequence
/// of bytes.
class MappedBlockStream : public ReadableStream {
  friend class WritableMappedBlockStream;
public:
  static std::unique_ptr<MappedBlockStream>
  createStream(uint32_t BlockSize, uint32_t NumBlocks,
               const MSFStreamLayout &Layout, const ReadableStream &MsfData);

  static std::unique_ptr<MappedBlockStream>
  createIndexedStream(const MSFLayout &Layout, const ReadableStream &MsfData,
                      uint32_t StreamIndex);

  static std::unique_ptr<MappedBlockStream>
  createFpmStream(const MSFLayout &Layout, const ReadableStream &MsfData);

  static std::unique_ptr<MappedBlockStream>
  createDirectoryStream(const MSFLayout &Layout, const ReadableStream &MsfData);

  Error readBytes(uint32_t Offset, uint32_t Size,
                  ArrayRef<uint8_t> &Buffer) const override;
  Error readLongestContiguousChunk(uint32_t Offset,
                                   ArrayRef<uint8_t> &Buffer) const override;

  uint32_t getLength() const override;

  uint32_t getNumBytesCopied() const;

  llvm::BumpPtrAllocator &getAllocator() { return Pool; }

  void invalidateCache();

  uint32_t getBlockSize() const { return BlockSize; }
  uint32_t getNumBlocks() const { return NumBlocks; }
  uint32_t getStreamLength() const { return StreamLayout.Length; }

protected:
  MappedBlockStream(uint32_t BlockSize, uint32_t NumBlocks,
                    const MSFStreamLayout &StreamLayout,
                    const ReadableStream &MsfData);

private:
  const MSFStreamLayout &getStreamLayout() const { return StreamLayout; }
  void fixCacheAfterWrite(uint32_t Offset, ArrayRef<uint8_t> Data) const;

  Error readBytes(uint32_t Offset, MutableArrayRef<uint8_t> Buffer) const;
  bool tryReadContiguously(uint32_t Offset, uint32_t Size,
                           ArrayRef<uint8_t> &Buffer) const;

  const uint32_t BlockSize;
  const uint32_t NumBlocks;
  const MSFStreamLayout StreamLayout;
  const ReadableStream &MsfData;

  typedef MutableArrayRef<uint8_t> CacheEntry;
  mutable llvm::BumpPtrAllocator Pool;
  mutable DenseMap<uint32_t, std::vector<CacheEntry>> CacheMap;
};

class WritableMappedBlockStream : public WritableStream {
public:
  static std::unique_ptr<WritableMappedBlockStream>
  createStream(uint32_t BlockSize, uint32_t NumBlocks,
               const MSFStreamLayout &Layout, const WritableStream &MsfData);

  static std::unique_ptr<WritableMappedBlockStream>
  createIndexedStream(const MSFLayout &Layout, const WritableStream &MsfData,
                      uint32_t StreamIndex);

  static std::unique_ptr<WritableMappedBlockStream>
  createDirectoryStream(const MSFLayout &Layout, const WritableStream &MsfData);

  static std::unique_ptr<WritableMappedBlockStream>
  createFpmStream(const MSFLayout &Layout, const WritableStream &MsfData);

  Error readBytes(uint32_t Offset, uint32_t Size,
                  ArrayRef<uint8_t> &Buffer) const override;
  Error readLongestContiguousChunk(uint32_t Offset,
                                   ArrayRef<uint8_t> &Buffer) const override;
  uint32_t getLength() const override;

  Error writeBytes(uint32_t Offset, ArrayRef<uint8_t> Buffer) const override;

  Error commit() const override;

  const MSFStreamLayout &getStreamLayout() const {
    return ReadInterface.getStreamLayout();
  }
  uint32_t getBlockSize() const { return ReadInterface.getBlockSize(); }
  uint32_t getNumBlocks() const { return ReadInterface.getNumBlocks(); }
  uint32_t getStreamLength() const { return ReadInterface.getStreamLength(); }

protected:
  WritableMappedBlockStream(uint32_t BlockSize, uint32_t NumBlocks,
                            const MSFStreamLayout &StreamLayout,
                            const WritableStream &MsfData);

private:
  MappedBlockStream ReadInterface;

  const WritableStream &WriteInterface;
};

} // end namespace pdb
} // end namespace llvm

#endif // LLVM_DEBUGINFO_MSF_MAPPEDBLOCKSTREAM_H
@


1.1.1.1
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@@


1.1.1.2
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@d1 2
a2 1
//==- MappedBlockStream.h - Discontiguous stream data in an MSF --*- C++ -*-==//
d16 1
d18 1
a19 2
#include "llvm/Support/BinaryStream.h"
#include "llvm/Support/BinaryStreamRef.h"
a22 1
#include <memory>
d40 1
a40 1
class MappedBlockStream : public BinaryStream {
a41 1

d44 2
a45 2
  createStream(uint32_t BlockSize, const MSFStreamLayout &Layout,
               BinaryStreamRef MsfData, BumpPtrAllocator &Allocator);
d48 2
a49 2
  createIndexedStream(const MSFLayout &Layout, BinaryStreamRef MsfData,
                      uint32_t StreamIndex, BumpPtrAllocator &Allocator);
d52 1
a52 2
  createFpmStream(const MSFLayout &Layout, BinaryStreamRef MsfData,
                  BumpPtrAllocator &Allocator);
d55 1
a55 6
  createDirectoryStream(const MSFLayout &Layout, BinaryStreamRef MsfData,
                        BumpPtrAllocator &Allocator);

  support::endianness getEndian() const override {
    return support::little;
  }
d58 1
a58 1
                  ArrayRef<uint8_t> &Buffer) override;
d60 1
a60 1
                                   ArrayRef<uint8_t> &Buffer) override;
d62 1
a62 1
  uint32_t getLength() override;
d64 3
a66 1
  BumpPtrAllocator &getAllocator() { return Allocator; }
d71 1
a71 1
  uint32_t getNumBlocks() const { return StreamLayout.Blocks.size(); }
d75 3
a77 2
  MappedBlockStream(uint32_t BlockSize, const MSFStreamLayout &StreamLayout,
                    BinaryStreamRef MsfData, BumpPtrAllocator &Allocator);
d83 1
a83 1
  Error readBytes(uint32_t Offset, MutableArrayRef<uint8_t> Buffer);
d85 1
a85 1
                           ArrayRef<uint8_t> &Buffer);
d88 1
d90 1
a90 3
  BinaryStreamRef MsfData;

  using CacheEntry = MutableArrayRef<uint8_t>;
d92 3
a94 9
  // We just store the allocator by reference.  We use this to allocate
  // contiguous memory for things like arrays or strings that cross a block
  // boundary, and this memory is expected to outlive the stream.  For example,
  // someone could create a stream, read some stuff, then close the stream, and
  // we would like outstanding references to fields to remain valid since the
  // entire file is mapped anyway.  Because of that, the user must supply the
  // allocator to allocate broken records from.
  BumpPtrAllocator &Allocator;
  DenseMap<uint32_t, std::vector<CacheEntry>> CacheMap;
d97 1
a97 1
class WritableMappedBlockStream : public WritableBinaryStream {
d100 2
a101 2
  createStream(uint32_t BlockSize, const MSFStreamLayout &Layout,
               WritableBinaryStreamRef MsfData, BumpPtrAllocator &Allocator);
d104 2
a105 2
  createIndexedStream(const MSFLayout &Layout, WritableBinaryStreamRef MsfData,
                      uint32_t StreamIndex, BumpPtrAllocator &Allocator);
d108 1
a108 3
  createDirectoryStream(const MSFLayout &Layout,
                        WritableBinaryStreamRef MsfData,
                        BumpPtrAllocator &Allocator);
d111 1
a111 6
  createFpmStream(const MSFLayout &Layout, WritableBinaryStreamRef MsfData,
                  BumpPtrAllocator &Allocator);

  support::endianness getEndian() const override {
    return support::little;
  }
d114 1
a114 1
                  ArrayRef<uint8_t> &Buffer) override;
d116 2
a117 2
                                   ArrayRef<uint8_t> &Buffer) override;
  uint32_t getLength() override;
d119 1
a119 1
  Error writeBytes(uint32_t Offset, ArrayRef<uint8_t> Buffer) override;
d121 1
a121 1
  Error commit() override;
a125 1

d131 1
a131 1
  WritableMappedBlockStream(uint32_t BlockSize,
d133 1
a133 2
                            WritableBinaryStreamRef MsfData,
                            BumpPtrAllocator &Allocator);
d137 2
a138 1
  WritableBinaryStreamRef WriteInterface;
@

