head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.1
date	2017.01.14.19.55.56;	author patrick;	state Exp;
branches
	1.1.1.1;
next	;
commitid	qMUxATnKgqN83Oct;

1.1.1.1
date	2017.01.14.19.55.56;	author patrick;	state Exp;
branches;
next	1.1.1.2;
commitid	qMUxATnKgqN83Oct;

1.1.1.2
date	2017.01.24.08.33.18;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===- RecordSerialization.h ------------------------------------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_DEBUGINFO_CODEVIEW_RECORDSERIALIZATION_H
#define LLVM_DEBUGINFO_CODEVIEW_RECORDSERIALIZATION_H

#include "llvm/ADT/APSInt.h"
#include "llvm/ADT/ArrayRef.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/Support/Endian.h"
#include "llvm/DebugInfo/CodeView/CodeView.h"
#include <cinttypes>
#include <tuple>

namespace llvm {
namespace codeview {
using llvm::support::little32_t;
using llvm::support::ulittle16_t;
using llvm::support::ulittle32_t;

struct RecordPrefix {
  ulittle16_t RecordLen;  // Record length, starting from &Leaf.
  ulittle16_t RecordKind; // Record kind enum (SymRecordKind or TypeRecordKind)
};

/// Reinterpret a byte array as an array of characters. Does not interpret as
/// a C string, as StringRef has several helpers (split) that make that easy.
StringRef getBytesAsCharacters(ArrayRef<uint8_t> LeafData);
StringRef getBytesAsCString(ArrayRef<uint8_t> LeafData);

/// Consumes sizeof(T) bytes from the given byte sequence. Returns an error if
/// there are not enough bytes remaining. Reinterprets the consumed bytes as a
/// T object and points 'Res' at them.
template <typename T, typename U>
inline std::error_code consumeObject(U &Data, const T *&Res) {
  if (Data.size() < sizeof(*Res))
    return std::make_error_code(std::errc::illegal_byte_sequence);
  Res = reinterpret_cast<const T *>(Data.data());
  Data = Data.drop_front(sizeof(*Res));
  return std::error_code();
}

inline std::error_code consume(ArrayRef<uint8_t> &Data) {
  return std::error_code();
}

/// Decodes a numeric "leaf" value. These are integer literals encountered in
/// the type stream. If the value is positive and less than LF_NUMERIC (1 <<
/// 15), it is emitted directly in Data. Otherwise, it has a tag like LF_CHAR
/// that indicates the bitwidth and sign of the numeric data.
std::error_code consume(ArrayRef<uint8_t> &Data, APSInt &Num);
std::error_code consume(StringRef &Data, APSInt &Num);

/// Decodes a numeric leaf value that is known to be a particular type.
std::error_code consume_numeric(ArrayRef<uint8_t> &Data, uint64_t &Value);

/// Decodes signed and unsigned fixed-length integers.
std::error_code consume(ArrayRef<uint8_t> &Data, uint32_t &Item);
std::error_code consume(StringRef &Data, uint32_t &Item);
std::error_code consume(ArrayRef<uint8_t> &Data, int32_t &Item);

/// Decodes a null terminated string.
std::error_code consume(ArrayRef<uint8_t> &Data, StringRef &Item);

/// Decodes an arbitrary object whose layout matches that of the underlying
/// byte sequence, and returns a pointer to the object.
template <typename T>
std::error_code consume(ArrayRef<uint8_t> &Data, T *&Item) {
  return consumeObject(Data, Item);
}

template <typename T, typename U> struct serialize_conditional_impl {
  serialize_conditional_impl(T &Item, U Func) : Item(Item), Func(Func) {}

  std::error_code deserialize(ArrayRef<uint8_t> &Data) const {
    if (!Func())
      return std::error_code();
    return consume(Data, Item);
  }

  T &Item;
  U Func;
};

template <typename T, typename U>
serialize_conditional_impl<T, U> serialize_conditional(T &Item, U Func) {
  return serialize_conditional_impl<T, U>(Item, Func);
}

template <typename T, typename U> struct serialize_array_impl {
  serialize_array_impl(ArrayRef<T> &Item, U Func) : Item(Item), Func(Func) {}

  std::error_code deserialize(ArrayRef<uint8_t> &Data) const {
    uint32_t N = Func();
    if (N == 0)
      return std::error_code();

    uint32_t Size = sizeof(T) * N;

    if (Size / sizeof(T) != N)
      return std::make_error_code(std::errc::illegal_byte_sequence);

    if (Data.size() < Size)
      return std::make_error_code(std::errc::illegal_byte_sequence);

    Item = ArrayRef<T>(reinterpret_cast<const T *>(Data.data()), N);
    Data = Data.drop_front(Size);
    return std::error_code();
  }

  ArrayRef<T> &Item;
  U Func;
};

template <typename T> struct serialize_vector_tail_impl {
  serialize_vector_tail_impl(std::vector<T> &Item) : Item(Item) {}

  std::error_code deserialize(ArrayRef<uint8_t> &Data) const {
    T Field;
    // Stop when we run out of bytes or we hit record padding bytes.
    while (!Data.empty() && Data.front() < LF_PAD0) {
      if (auto EC = consume(Data, Field))
        return EC;
      Item.push_back(Field);
    }
    return std::error_code();
  }

  std::vector<T> &Item;
};

struct serialize_null_term_string_array_impl {
  serialize_null_term_string_array_impl(std::vector<StringRef> &Item)
      : Item(Item) {}

  std::error_code deserialize(ArrayRef<uint8_t> &Data) const {
    if (Data.empty())
      return std::make_error_code(std::errc::illegal_byte_sequence);

    StringRef Field;
    // Stop when we run out of bytes or we hit record padding bytes.
    while (Data.front() != 0) {
      if (auto EC = consume(Data, Field))
        return EC;
      Item.push_back(Field);
      if (Data.empty())
        return std::make_error_code(std::errc::illegal_byte_sequence);
    }
    Data = Data.drop_front(1);
    return std::error_code();
  }

  std::vector<StringRef> &Item;
};

template <typename T> struct serialize_arrayref_tail_impl {
  serialize_arrayref_tail_impl(ArrayRef<T> &Item) : Item(Item) {}

  std::error_code deserialize(ArrayRef<uint8_t> &Data) const {
    uint32_t Count = Data.size() / sizeof(T);
    Item = ArrayRef<T>(reinterpret_cast<const T *>(Data.begin()), Count);
    return std::error_code();
  }

  ArrayRef<T> &Item;
};

template <typename T> struct serialize_numeric_impl {
  serialize_numeric_impl(T &Item) : Item(Item) {}

  std::error_code deserialize(ArrayRef<uint8_t> &Data) const {
    return consume_numeric(Data, Item);
  }

  T &Item;
};

template <typename T, typename U>
serialize_array_impl<T, U> serialize_array(ArrayRef<T> &Item, U Func) {
  return serialize_array_impl<T, U>(Item, Func);
}

inline serialize_null_term_string_array_impl
serialize_null_term_string_array(std::vector<StringRef> &Item) {
  return serialize_null_term_string_array_impl(Item);
}

template <typename T>
serialize_vector_tail_impl<T> serialize_array_tail(std::vector<T> &Item) {
  return serialize_vector_tail_impl<T>(Item);
}

template <typename T>
serialize_arrayref_tail_impl<T> serialize_array_tail(ArrayRef<T> &Item) {
  return serialize_arrayref_tail_impl<T>(Item);
}

template <typename T> serialize_numeric_impl<T> serialize_numeric(T &Item) {
  return serialize_numeric_impl<T>(Item);
}

// This field is only present in the byte record if the condition is true.  The
// condition is evaluated lazily, so it can depend on items that were
// deserialized
// earlier.
#define CV_CONDITIONAL_FIELD(I, C)                                             \
  serialize_conditional(I, [&]() { return !!(C); })

// This is an array of N items, where N is evaluated lazily, so it can refer
// to a field deserialized earlier.
#define CV_ARRAY_FIELD_N(I, N) serialize_array(I, [&]() { return N; })

// This is an array that exhausts the remainder of the input buffer.
#define CV_ARRAY_FIELD_TAIL(I) serialize_array_tail(I)

// This is an array that consumes null terminated strings until a double null
// is encountered.
#define CV_STRING_ARRAY_NULL_TERM(I) serialize_null_term_string_array(I)

#define CV_NUMERIC_FIELD(I) serialize_numeric(I)

template <typename T, typename U>
std::error_code consume(ArrayRef<uint8_t> &Data,
                        const serialize_conditional_impl<T, U> &Item) {
  return Item.deserialize(Data);
}

template <typename T, typename U>
std::error_code consume(ArrayRef<uint8_t> &Data,
                        const serialize_array_impl<T, U> &Item) {
  return Item.deserialize(Data);
}

inline std::error_code
consume(ArrayRef<uint8_t> &Data,
        const serialize_null_term_string_array_impl &Item) {
  return Item.deserialize(Data);
}

template <typename T>
std::error_code consume(ArrayRef<uint8_t> &Data,
                        const serialize_vector_tail_impl<T> &Item) {
  return Item.deserialize(Data);
}

template <typename T>
std::error_code consume(ArrayRef<uint8_t> &Data,
                        const serialize_arrayref_tail_impl<T> &Item) {
  return Item.deserialize(Data);
}

template <typename T>
std::error_code consume(ArrayRef<uint8_t> &Data,
                        const serialize_numeric_impl<T> &Item) {
  return Item.deserialize(Data);
}

template <typename T, typename U, typename... Args>
std::error_code consume(ArrayRef<uint8_t> &Data, T &&X, U &&Y,
                        Args &&... Rest) {
  if (auto EC = consume(Data, X))
    return EC;
  return consume(Data, Y, std::forward<Args>(Rest)...);
}

#define CV_DESERIALIZE(...)                                                    \
  if (auto EC = consume(__VA_ARGS__))                                          \
    return EC;
}
}

#endif
@


1.1.1.1
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d16 1
a17 4
#include "llvm/DebugInfo/CodeView/CodeViewError.h"
#include "llvm/DebugInfo/MSF/StreamReader.h"
#include "llvm/Support/Endian.h"
#include "llvm/Support/Error.h"
a26 4
/// Limit on the size of all codeview symbol and type records, including the
/// RecordPrefix. MSVC does not emit any records larger than this.
enum : unsigned { MaxRecordLength = 0xFF00 };

d28 1
a28 1
  ulittle16_t RecordLen;  // Record length, starting from &RecordKind.
d37 15
a51 1
inline Error consume(msf::StreamReader &Reader) { return Error::success(); }
d57 2
a58 1
Error consume(msf::StreamReader &Reader, APSInt &Num);
d61 1
a61 1
Error consume_numeric(msf::StreamReader &Reader, uint64_t &Value);
d64 3
a66 2
Error consume(msf::StreamReader &Reader, uint32_t &Item);
Error consume(msf::StreamReader &Reader, int32_t &Item);
d69 1
a69 4
Error consume(msf::StreamReader &Reader, StringRef &Item);

Error consume(StringRef &Data, APSInt &Num);
Error consume(StringRef &Data, uint32_t &Item);
d73 3
a75 2
template <typename T> Error consume(msf::StreamReader &Reader, T *&Item) {
  return Reader.readObject(Item);
d81 1
a81 1
  Error deserialize(msf::StreamReader &Reader) const {
d83 2
a84 2
      return Error::success();
    return consume(Reader, Item);
d99 16
a114 2
  Error deserialize(msf::StreamReader &Reader) const {
    return Reader.readArray(Item, Func());
d124 1
a124 1
  Error deserialize(msf::StreamReader &Reader) const {
d127 2
a128 2
    while (!Reader.empty() && Reader.peek() < LF_PAD0) {
      if (auto EC = consume(Reader, Field))
d132 1
a132 1
    return Error::success();
d142 8
a149 8
  Error deserialize(msf::StreamReader &Reader) const {
    if (Reader.empty())
      return make_error<CodeViewError>(cv_error_code::insufficient_buffer,
                                       "Null terminated string is empty!");

    while (Reader.peek() != 0) {
      StringRef Field;
      if (auto EC = Reader.readZeroString(Field))
d152 2
d155 2
a156 1
    return Reader.skip(1);
d165 4
a168 3
  Error deserialize(msf::StreamReader &Reader) const {
    uint32_t Count = Reader.bytesRemaining() / sizeof(T);
    return Reader.readArray(Item, Count);
d177 2
a178 2
  Error deserialize(msf::StreamReader &Reader) const {
    return consume_numeric(Reader, Item);
d229 3
a231 3
Error consume(msf::StreamReader &Reader,
              const serialize_conditional_impl<T, U> &Item) {
  return Item.deserialize(Reader);
d235 3
a237 3
Error consume(msf::StreamReader &Reader,
              const serialize_array_impl<T, U> &Item) {
  return Item.deserialize(Reader);
d240 4
a243 3
inline Error consume(msf::StreamReader &Reader,
                     const serialize_null_term_string_array_impl &Item) {
  return Item.deserialize(Reader);
d247 3
a249 3
Error consume(msf::StreamReader &Reader,
              const serialize_vector_tail_impl<T> &Item) {
  return Item.deserialize(Reader);
d253 3
a255 3
Error consume(msf::StreamReader &Reader,
              const serialize_arrayref_tail_impl<T> &Item) {
  return Item.deserialize(Reader);
d259 3
a261 3
Error consume(msf::StreamReader &Reader,
              const serialize_numeric_impl<T> &Item) {
  return Item.deserialize(Reader);
d265 3
a267 2
Error consume(msf::StreamReader &Reader, T &&X, U &&Y, Args &&... Rest) {
  if (auto EC = consume(Reader, X))
d269 1
a269 1
  return consume(Reader, Y, std::forward<Args>(Rest)...);
d274 1
a274 1
    return std::move(EC);
@

