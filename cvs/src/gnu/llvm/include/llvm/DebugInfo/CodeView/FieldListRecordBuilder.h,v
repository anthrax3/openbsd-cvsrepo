head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.56;	author patrick;	state Exp;
branches;
next	;
commitid	qMUxATnKgqN83Oct;


desc
@@


1.1
log
@Initial revision
@
text
@//===- FieldListRecordBuilder.h ---------------------------------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_DEBUGINFO_CODEVIEW_FIELDLISTRECORDBUILDER_H
#define LLVM_DEBUGINFO_CODEVIEW_FIELDLISTRECORDBUILDER_H

#include "llvm/DebugInfo/CodeView/ListRecordBuilder.h"

namespace llvm {
namespace codeview {

class MethodInfo {
public:
  MethodInfo() : Access(), Kind(), Options(), Type(), VTableSlotOffset(-1) {}

  MethodInfo(MemberAccess Access, MethodKind Kind, MethodOptions Options,
             TypeIndex Type, int32_t VTableSlotOffset)
      : Access(Access), Kind(Kind), Options(Options), Type(Type),
        VTableSlotOffset(VTableSlotOffset) {}

  MemberAccess getAccess() const { return Access; }
  MethodKind getKind() const { return Kind; }
  MethodOptions getOptions() const { return Options; }
  TypeIndex getType() const { return Type; }
  int32_t getVTableSlotOffset() const { return VTableSlotOffset; }

private:
  MemberAccess Access;
  MethodKind Kind;
  MethodOptions Options;
  TypeIndex Type;
  int32_t VTableSlotOffset;
};

class FieldListRecordBuilder : public ListRecordBuilder {
private:
  FieldListRecordBuilder(const FieldListRecordBuilder &) = delete;
  void operator=(const FieldListRecordBuilder &) = delete;

public:
  FieldListRecordBuilder();

  void writeBaseClass(MemberAccess Access, TypeIndex Type, uint64_t Offset);
  void writeEnumerate(MemberAccess Access, uint64_t Value, StringRef Name);
  void writeIndirectVirtualBaseClass(MemberAccess Access, TypeIndex Type,
                                     TypeIndex VirtualBasePointerType,
                                     int64_t VirtualBasePointerOffset,
                                     uint64_t SlotIndex);
  void writeMember(MemberAccess Access, TypeIndex Type, uint64_t Offset,
                   StringRef Name);
  void writeOneMethod(MemberAccess Access, MethodKind Kind,
                      MethodOptions Options, TypeIndex Type,
                      int32_t VTableSlotOffset, StringRef Name);
  void writeOneMethod(const MethodInfo &Method, StringRef Name);
  void writeMethod(uint16_t OverloadCount, TypeIndex MethodList,
                   StringRef Name);
  void writeNestedType(TypeIndex Type, StringRef Name);
  void writeStaticMember(MemberAccess Access, TypeIndex Type, StringRef Name);
  void writeVirtualBaseClass(MemberAccess Access, TypeIndex Type,
                             TypeIndex VirtualBasePointerType,
                             int64_t VirtualBasePointerOffset,
                             uint64_t SlotIndex);
  void writeVirtualBaseClass(TypeRecordKind Kind, MemberAccess Access,
                             TypeIndex Type, TypeIndex VirtualBasePointerType,
                             int64_t VirtualBasePointerOffset,
                             uint64_t SlotIndex);
  void writeVirtualFunctionTablePointer(TypeIndex Type);
};
}
}

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@a13 1
#include "llvm/DebugInfo/CodeView/TypeRecord.h"
d49 25
a73 11
  void reset() { ListRecordBuilder::reset(); }

  void writeBaseClass(const BaseClassRecord &Record);
  void writeEnumerator(const EnumeratorRecord &Record);
  void writeDataMember(const DataMemberRecord &Record);
  void writeOneMethod(const OneMethodRecord &Record);
  void writeOverloadedMethod(const OverloadedMethodRecord &Record);
  void writeNestedType(const NestedTypeRecord &Record);
  void writeStaticDataMember(const StaticDataMemberRecord &Record);
  void writeVirtualBaseClass(const VirtualBaseClassRecord &Record);
  void writeVFPtr(const VFPtrRecord &Type);
@

