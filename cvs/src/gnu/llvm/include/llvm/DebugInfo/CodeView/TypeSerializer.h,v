head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.2
	OPENBSD_6_2:1.1.1.1.0.2
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.4
	OPENBSD_6_1_BASE:1.1.1.1
	LLVM_4_0_0:1.1.1.1
	LLVM_4_0_0_RC1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.1
date	2017.01.24.08.33.18;	author patrick;	state Exp;
branches
	1.1.1.1;
next	;
commitid	so2WA7LCP6wbxtYl;

1.1.1.1
date	2017.01.24.08.33.18;	author patrick;	state Exp;
branches;
next	1.1.1.2;
commitid	so2WA7LCP6wbxtYl;

1.1.1.2
date	2017.10.04.20.27.54;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===- TypeSerializer.h -----------------------------------------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_DEBUGINFO_CODEVIEW_TYPESERIALIZER_H
#define LLVM_DEBUGINFO_CODEVIEW_TYPESERIALIZER_H

#include "llvm/DebugInfo/CodeView/TypeRecordMapping.h"
#include "llvm/DebugInfo/CodeView/TypeVisitorCallbacks.h"
#include "llvm/DebugInfo/MSF/ByteStream.h"
#include "llvm/DebugInfo/MSF/StreamWriter.h"

#include "llvm/ADT/Optional.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/ADT/StringMap.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/Support/Allocator.h"
#include "llvm/Support/Error.h"

namespace llvm {

namespace codeview {

class TypeSerializer : public TypeVisitorCallbacks {
  struct SubRecord {
    SubRecord(TypeLeafKind K, uint32_t S) : Kind(K), Size(S) {}

    TypeLeafKind Kind;
    uint32_t Size = 0;
  };
  struct RecordSegment {
    SmallVector<SubRecord, 16> SubRecords;

    uint32_t length() const {
      uint32_t L = sizeof(RecordPrefix);
      for (const auto &R : SubRecords) {
        L += R.Size;
      }
      return L;
    }
  };

  typedef SmallVector<MutableArrayRef<uint8_t>, 2> RecordList;

  static constexpr uint8_t ContinuationLength = 8;
  BumpPtrAllocator &RecordStorage;
  RecordSegment CurrentSegment;
  RecordList FieldListSegments;

  TypeIndex LastTypeIndex;
  Optional<TypeLeafKind> TypeKind;
  Optional<TypeLeafKind> MemberKind;
  std::vector<uint8_t> RecordBuffer;
  msf::MutableByteStream Stream;
  msf::StreamWriter Writer;
  TypeRecordMapping Mapping;

  RecordList SeenRecords;
  StringMap<TypeIndex> HashedRecords;

  bool isInFieldList() const;
  TypeIndex calcNextTypeIndex() const;
  TypeIndex incrementTypeIndex();
  MutableArrayRef<uint8_t> getCurrentSubRecordData();
  MutableArrayRef<uint8_t> getCurrentRecordData();
  Error writeRecordPrefix(TypeLeafKind Kind);
  TypeIndex insertRecordBytesPrivate(MutableArrayRef<uint8_t> Record);

  Expected<MutableArrayRef<uint8_t>>
  addPadding(MutableArrayRef<uint8_t> Record);

public:
  explicit TypeSerializer(BumpPtrAllocator &Storage);

  ArrayRef<MutableArrayRef<uint8_t>> records() const;
  TypeIndex getLastTypeIndex() const;
  TypeIndex insertRecordBytes(MutableArrayRef<uint8_t> Record);
  Expected<TypeIndex> visitTypeEndGetIndex(CVType &Record);

  Error visitTypeBegin(CVType &Record) override;
  Error visitTypeEnd(CVType &Record) override;
  Error visitMemberBegin(CVMemberRecord &Record) override;
  Error visitMemberEnd(CVMemberRecord &Record) override;

#define TYPE_RECORD(EnumName, EnumVal, Name)                                   \
  virtual Error visitKnownRecord(CVType &CVR, Name##Record &Record) override { \
    return visitKnownRecordImpl(CVR, Record);                                  \
  }
#define TYPE_RECORD_ALIAS(EnumName, EnumVal, Name, AliasName)
#define MEMBER_RECORD(EnumName, EnumVal, Name)                                 \
  Error visitKnownMember(CVMemberRecord &CVR, Name##Record &Record) override { \
    return visitKnownMemberImpl<Name##Record>(CVR, Record);                    \
  }
#define MEMBER_RECORD_ALIAS(EnumName, EnumVal, Name, AliasName)
#include "llvm/DebugInfo/CodeView/TypeRecords.def"

private:
  template <typename RecordKind>
  Error visitKnownRecordImpl(CVType &CVR, RecordKind &Record) {
    return Mapping.visitKnownRecord(CVR, Record);
  }

  template <typename RecordType>
  Error visitKnownMemberImpl(CVMemberRecord &CVR, RecordType &Record) {
    assert(CVR.Kind == static_cast<TypeLeafKind>(Record.getKind()));

    if (auto EC = Writer.writeEnum(CVR.Kind))
      return EC;

    if (auto EC = Mapping.visitKnownMember(CVR, Record))
      return EC;

    // Get all the data that was just written and is yet to be committed to
    // the current segment.  Then pad it to 4 bytes.
    MutableArrayRef<uint8_t> ThisRecord = getCurrentSubRecordData();
    auto ExpectedRecord = addPadding(ThisRecord);
    if (!ExpectedRecord)
      return ExpectedRecord.takeError();
    ThisRecord = *ExpectedRecord;

    CurrentSegment.SubRecords.emplace_back(CVR.Kind, ThisRecord.size());
    CVR.Data = ThisRecord;

    // Both the last subrecord and the total length of this segment should be
    // multiples of 4.
    assert(ThisRecord.size() % 4 == 0);
    assert(CurrentSegment.length() % 4 == 0);

    return Error::success();
  }
};
}
}

#endif
@


1.1.1.1
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@@


1.1.1.2
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@d13 5
a17 1
#include "llvm/ADT/ArrayRef.h"
d20 2
a21 6
#include "llvm/DebugInfo/CodeView/CodeView.h"
#include "llvm/DebugInfo/CodeView/RecordSerialization.h"
#include "llvm/DebugInfo/CodeView/TypeIndex.h"
#include "llvm/DebugInfo/CodeView/TypeRecord.h"
#include "llvm/DebugInfo/CodeView/TypeRecordMapping.h"
#include "llvm/DebugInfo/CodeView/TypeVisitorCallbacks.h"
a22 2
#include "llvm/Support/BinaryByteStream.h"
#include "llvm/Support/BinaryStreamWriter.h"
a23 4
#include <cassert>
#include <cstdint>
#include <memory>
#include <vector>
d26 1
a28 2
class TypeHasher;

d48 1
a48 1
  using MutableRecordList = SmallVector<MutableArrayRef<uint8_t>, 2>;
d53 1
a53 1
  MutableRecordList FieldListSegments;
d55 1
d59 2
a60 2
  MutableBinaryByteStream Stream;
  BinaryStreamWriter Writer;
d63 2
a64 11
  /// Private type record hashing implementation details are handled here.
  std::unique_ptr<TypeHasher> Hasher;

  /// Contains a list of all records indexed by TypeIndex.toArrayIndex().
  SmallVector<ArrayRef<uint8_t>, 2> SeenRecords;

  /// Temporary storage that we use to copy a record's data while re-writing
  /// its type indices.
  SmallVector<uint8_t, 256> RemapStorage;

  TypeIndex nextTypeIndex() const;
d67 2
d72 1
d78 1
a78 2
  explicit TypeSerializer(BumpPtrAllocator &Storage, bool Hash = true);
  ~TypeSerializer() override;
d80 3
a82 7
  void reset();

  BumpPtrAllocator &getAllocator() { return RecordStorage; }

  ArrayRef<ArrayRef<uint8_t>> records() const;
  TypeIndex insertRecordBytes(ArrayRef<uint8_t> &Record);
  TypeIndex insertRecord(const RemappedType &Record);
a84 1
  using TypeVisitorCallbacks::visitTypeBegin;
d100 1
a100 1
#include "llvm/DebugInfo/CodeView/CodeViewTypes.def"
d137 2
d140 1
a140 4
} // end namespace codeview
} // end namespace llvm

#endif // LLVM_DEBUGINFO_CODEVIEW_TYPESERIALIZER_H
@

