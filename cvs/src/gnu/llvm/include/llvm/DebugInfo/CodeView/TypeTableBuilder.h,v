head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.4
	OPENBSD_6_2:1.1.1.3.0.2
	OPENBSD_6_2_BASE:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.4
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.56;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.18;	author patrick;	state Exp;
branches;
next	1.1.1.4;
commitid	so2WA7LCP6wbxtYl;

1.1.1.4
date	2017.10.04.20.27.54;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===- TypeTableBuilder.h ---------------------------------------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_DEBUGINFO_CODEVIEW_TYPETABLEBUILDER_H
#define LLVM_DEBUGINFO_CODEVIEW_TYPETABLEBUILDER_H

#include "llvm/ADT/StringRef.h"
#include "llvm/DebugInfo/CodeView/CodeView.h"
#include "llvm/DebugInfo/CodeView/TypeIndex.h"
#include "llvm/DebugInfo/CodeView/TypeRecord.h"
#include "llvm/Support/Compiler.h"

namespace llvm {
namespace codeview {

class FieldListRecordBuilder;
class MethodListRecordBuilder;
class TypeRecordBuilder;

class TypeTableBuilder {
private:
  TypeTableBuilder(const TypeTableBuilder &) = delete;
  TypeTableBuilder &operator=(const TypeTableBuilder &) = delete;

protected:
  TypeTableBuilder();

public:
  virtual ~TypeTableBuilder();

public:
  TypeIndex writeModifier(const ModifierRecord &Record);
  TypeIndex writeProcedure(const ProcedureRecord &Record);
  TypeIndex writeMemberFunction(const MemberFunctionRecord &Record);
  TypeIndex writeArgumentList(const ArgumentListRecord &Record);
  TypeIndex writeRecord(TypeRecordBuilder &builder);
  TypeIndex writePointer(const PointerRecord &Record);
  TypeIndex writePointerToMember(const PointerToMemberRecord &Record);
  TypeIndex writeArray(const ArrayRecord &Record);
  TypeIndex writeAggregate(const AggregateRecord &Record);
  TypeIndex writeEnum(const EnumRecord &Record);
  TypeIndex writeBitField(const BitFieldRecord &Record);
  TypeIndex writeVirtualTableShape(const VirtualTableShapeRecord &Record);

  TypeIndex writeFieldList(FieldListRecordBuilder &FieldList);
  TypeIndex writeMethodList(MethodListRecordBuilder &MethodList);

private:
  virtual TypeIndex writeRecord(llvm::StringRef record) = 0;
};
}
}

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d13 1
a19 3

class StringRef;

d41 2
a42 1
  TypeIndex writeArgList(const ArgListRecord &Record);
d44 1
d46 1
a46 2
  TypeIndex writeClass(const ClassRecord &Record);
  TypeIndex writeUnion(const UnionRecord &Record);
d49 1
a49 10
  TypeIndex writeVFTableShape(const VFTableShapeRecord &Record);
  TypeIndex writeStringId(const StringIdRecord &Record);
  TypeIndex writeVFTable(const VFTableRecord &Record);
  TypeIndex writeUdtSourceLine(const UdtSourceLineRecord &Record);
  TypeIndex writeUdtModSourceLine(const UdtModSourceLineRecord &Record);
  TypeIndex writeFuncId(const FuncIdRecord &Record);
  TypeIndex writeMemberFuncId(const MemberFuncIdRecord &Record);
  TypeIndex writeBuildInfo(const BuildInfoRecord &Record);
  TypeIndex writeMethodOverloadList(const MethodOverloadListRecord &Record);
  TypeIndex writeTypeServer2(const TypeServer2Record &Record);
d52 1
d54 1
a54 2
  TypeIndex writeRecord(TypeRecordBuilder &builder);

@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a12 1
#include "llvm/ADT/ArrayRef.h"
a14 1
#include "llvm/DebugInfo/CodeView/TypeSerializer.h"
d16 1
a16 6
#include "llvm/Support/Allocator.h"
#include "llvm/Support/Error.h"
#include <algorithm>
#include <cassert>
#include <cstdint>
#include <type_traits>
d19 3
d24 4
d30 2
a31 5
  TypeIndex handleError(Error EC) const {
    assert(false && "Couldn't write Type!");
    consumeError(std::move(EC));
    return TypeIndex();
  }
d33 2
a34 2
  BumpPtrAllocator &Allocator;
  TypeSerializer Serializer;
d37 1
a37 4
  explicit TypeTableBuilder(BumpPtrAllocator &Allocator)
      : Allocator(Allocator), Serializer(Allocator) {}
  TypeTableBuilder(const TypeTableBuilder &) = delete;
  TypeTableBuilder &operator=(const TypeTableBuilder &) = delete;
d39 21
a59 3
  bool empty() const { return Serializer.records().empty(); }

  BumpPtrAllocator &getAllocator() const { return Allocator; }
d61 1
a61 35
  template <typename T> TypeIndex writeKnownType(T &Record) {
    static_assert(!std::is_same<T, FieldListRecord>::value,
                  "Can't serialize FieldList!");

    CVType Type;
    Type.Type = static_cast<TypeLeafKind>(Record.getKind());
    if (auto EC = Serializer.visitTypeBegin(Type))
      return handleError(std::move(EC));
    if (auto EC = Serializer.visitKnownRecord(Type, Record))
      return handleError(std::move(EC));

    auto ExpectedIndex = Serializer.visitTypeEndGetIndex(Type);
    if (!ExpectedIndex)
      return handleError(ExpectedIndex.takeError());

    return *ExpectedIndex;
  }

  TypeIndex writeSerializedRecord(MutableArrayRef<uint8_t> Record) {
    return Serializer.insertRecordBytes(Record);
  }

  template <typename TFunc> void ForEachRecord(TFunc Func) {
    uint32_t Index = TypeIndex::FirstNonSimpleIndex;

    for (auto Record : Serializer.records()) {
      Func(TypeIndex(Index), Record);
      ++Index;
    }
  }

  ArrayRef<MutableArrayRef<uint8_t>> records() const {
    return Serializer.records();
  }
};
d63 1
a63 4
class FieldListRecordBuilder {
  TypeTableBuilder &TypeTable;
  TypeSerializer TempSerializer;
  CVType Type;
d65 1
a65 34
public:
  explicit FieldListRecordBuilder(TypeTableBuilder &TypeTable)
      : TypeTable(TypeTable), TempSerializer(TypeTable.getAllocator()) {
    Type.Type = TypeLeafKind::LF_FIELDLIST;
  }

  void begin() {
    if (auto EC = TempSerializer.visitTypeBegin(Type))
      consumeError(std::move(EC));
  }

  template <typename T> void writeMemberType(T &Record) {
    CVMemberRecord CVMR;
    CVMR.Kind = static_cast<TypeLeafKind>(Record.getKind());
    if (auto EC = TempSerializer.visitMemberBegin(CVMR))
      consumeError(std::move(EC));
    if (auto EC = TempSerializer.visitKnownMember(CVMR, Record))
      consumeError(std::move(EC));
    if (auto EC = TempSerializer.visitMemberEnd(CVMR))
      consumeError(std::move(EC));
  }

  TypeIndex end() {
    if (auto EC = TempSerializer.visitTypeEnd(Type)) {
      consumeError(std::move(EC));
      return TypeIndex();
    }

    TypeIndex Index;
    for (auto Record : TempSerializer.records()) {
      Index = TypeTable.writeSerializedRecord(Record);
    }
    return Index;
  }
d67 2
d70 1
a70 4
} // end namespace codeview
} // end namespace llvm

#endif // LLVM_DEBUGINFO_CODEVIEW_TYPETABLEBUILDER_H
@


1.1.1.4
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@d16 1
a17 1
#include "llvm/DebugInfo/CodeView/TypeSerializer.h"
d40 2
a41 3
  explicit TypeTableBuilder(BumpPtrAllocator &Allocator,
                            bool WriteUnique = true)
      : Allocator(Allocator), Serializer(Allocator, WriteUnique) {}
d67 1
a67 1
  TypeIndex writeSerializedRecord(ArrayRef<uint8_t> Record) {
a70 4
  TypeIndex writeSerializedRecord(const RemappedType &Record) {
    return Serializer.insertRecord(Record);
  }

d80 3
a82 1
  ArrayRef<ArrayRef<uint8_t>> records() const { return Serializer.records(); }
a86 1
  BumpPtrAllocator Allocator;
d92 1
a92 1
      : TypeTable(TypeTable), TempSerializer(Allocator, false) {
a96 2
    TempSerializer.reset();

d112 1
a112 2
  TypeIndex end(bool Write) {
    TypeIndex Index;
d118 3
a120 3
    if (Write) {
      for (auto Record : TempSerializer.records())
        Index = TypeTable.writeSerializedRecord(Record);
a121 1

@


