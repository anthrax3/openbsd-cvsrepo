head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.57;	author patrick;	state Exp;
branches;
next	;
commitid	qMUxATnKgqN83Oct;


desc
@@


1.1
log
@Initial revision
@
text
@//===------ JITSymbolFlags.h - Flags for symbols in the JIT -----*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// Symbol flags for symbols in the JIT (e.g. weak, exported).
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_EXECUTIONENGINE_JITSYMBOLFLAGS_H
#define LLVM_EXECUTIONENGINE_JITSYMBOLFLAGS_H

#include "llvm/IR/GlobalValue.h"

namespace llvm {

/// @@brief Flags for symbols in the JIT.
enum class JITSymbolFlags : char {
  None = 0,
  Weak = 1U << 0,
  Exported = 1U << 1
};

inline JITSymbolFlags operator|(JITSymbolFlags LHS, JITSymbolFlags RHS) {
  typedef std::underlying_type<JITSymbolFlags>::type UT;
  return static_cast<JITSymbolFlags>(
           static_cast<UT>(LHS) | static_cast<UT>(RHS));
}

inline JITSymbolFlags& operator |=(JITSymbolFlags &LHS, JITSymbolFlags RHS) {
  LHS = LHS | RHS;
  return LHS;
}

inline JITSymbolFlags operator&(JITSymbolFlags LHS, JITSymbolFlags RHS) {
  typedef std::underlying_type<JITSymbolFlags>::type UT;
  return static_cast<JITSymbolFlags>(
           static_cast<UT>(LHS) & static_cast<UT>(RHS));
}

inline JITSymbolFlags& operator &=(JITSymbolFlags &LHS, JITSymbolFlags RHS) {
  LHS = LHS & RHS;
  return LHS;
}

/// @@brief Base class for symbols in the JIT.
class JITSymbolBase {
public:
  JITSymbolBase(JITSymbolFlags Flags) : Flags(Flags) {}

  JITSymbolFlags getFlags() const { return Flags; }

  bool isWeak() const {
    return (Flags & JITSymbolFlags::Weak) == JITSymbolFlags::Weak;
  }

  bool isExported() const {
    return (Flags & JITSymbolFlags::Exported) == JITSymbolFlags::Exported;
  }

  static JITSymbolFlags flagsFromGlobalValue(const GlobalValue &GV) {
    JITSymbolFlags Flags = JITSymbolFlags::None;
    if (GV.hasWeakLinkage())
      Flags |= JITSymbolFlags::Weak;
    if (!GV.hasLocalLinkage() && !GV.hasHiddenVisibility())
      Flags |= JITSymbolFlags::Exported;
    return Flags;

  }

private:
  JITSymbolFlags Flags;
};

} // end namespace llvm

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@a17 1
#include "llvm/Object/SymbolicFile.h"
a71 1
  }
a72 8
  static JITSymbolFlags
  flagsFromObjectSymbol(const object::BasicSymbolRef &Symbol) {
    JITSymbolFlags Flags = JITSymbolFlags::None;
    if (Symbol.getFlags() & object::BasicSymbolRef::SF_Weak)
      Flags |= JITSymbolFlags::Weak;
    if (Symbol.getFlags() & object::BasicSymbolRef::SF_Exported)
      Flags |= JITSymbolFlags::Exported;
    return Flags;
@

