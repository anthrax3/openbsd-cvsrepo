head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.3.0.2
	OPENBSD_6_2_BASE:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.4
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.57;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.17;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===---- OrcRemoteTargetClient.h - Orc Remote-target Client ----*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines the OrcRemoteTargetClient class and helpers. This class
// can be used to communicate over an RPCChannel with an OrcRemoteTargetServer
// instance to support remote-JITing.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_EXECUTIONENGINE_ORC_ORCREMOTETARGETCLIENT_H
#define LLVM_EXECUTIONENGINE_ORC_ORCREMOTETARGETCLIENT_H

#include "IndirectionUtils.h"
#include "OrcRemoteTargetRPCAPI.h"
#include <system_error>

#define DEBUG_TYPE "orc-remote"

namespace llvm {
namespace orc {
namespace remote {

/// This class provides utilities (including memory manager, indirect stubs
/// manager, and compile callback manager types) that support remote JITing
/// in ORC.
///
/// Each of the utility classes talks to a JIT server (an instance of the
/// OrcRemoteTargetServer class) via an RPC system (see RPCUtils.h) to carry out
/// its actions.
template <typename ChannelT>
class OrcRemoteTargetClient : public OrcRemoteTargetRPCAPI {
public:
  /// Remote memory manager.
  class RCMemoryManager : public RuntimeDyld::MemoryManager {
  public:
    RCMemoryManager(OrcRemoteTargetClient &Client, ResourceIdMgr::ResourceId Id)
        : Client(Client), Id(Id) {
      DEBUG(dbgs() << "Created remote allocator " << Id << "\n");
    }

    RCMemoryManager(RCMemoryManager &&Other)
        : Client(std::move(Other.Client)), Id(std::move(Other.Id)),
          Unmapped(std::move(Other.Unmapped)),
          Unfinalized(std::move(Other.Unfinalized)) {}

    RCMemoryManager operator=(RCMemoryManager &&Other) {
      Client = std::move(Other.Client);
      Id = std::move(Other.Id);
      Unmapped = std::move(Other.Unmapped);
      Unfinalized = std::move(Other.Unfinalized);
      return *this;
    }

    ~RCMemoryManager() {
      Client.destroyRemoteAllocator(Id);
      DEBUG(dbgs() << "Destroyed remote allocator " << Id << "\n");
    }

    uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,
                                 unsigned SectionID,
                                 StringRef SectionName) override {
      Unmapped.back().CodeAllocs.emplace_back(Size, Alignment);
      uint8_t *Alloc = reinterpret_cast<uint8_t *>(
          Unmapped.back().CodeAllocs.back().getLocalAddress());
      DEBUG(dbgs() << "Allocator " << Id << " allocated code for "
                   << SectionName << ": " << Alloc << " (" << Size
                   << " bytes, alignment " << Alignment << ")\n");
      return Alloc;
    }

    uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,
                                 unsigned SectionID, StringRef SectionName,
                                 bool IsReadOnly) override {
      if (IsReadOnly) {
        Unmapped.back().RODataAllocs.emplace_back(Size, Alignment);
        uint8_t *Alloc = reinterpret_cast<uint8_t *>(
            Unmapped.back().RODataAllocs.back().getLocalAddress());
        DEBUG(dbgs() << "Allocator " << Id << " allocated ro-data for "
                     << SectionName << ": " << Alloc << " (" << Size
                     << " bytes, alignment " << Alignment << ")\n");
        return Alloc;
      } // else...

      Unmapped.back().RWDataAllocs.emplace_back(Size, Alignment);
      uint8_t *Alloc = reinterpret_cast<uint8_t *>(
          Unmapped.back().RWDataAllocs.back().getLocalAddress());
      DEBUG(dbgs() << "Allocator " << Id << " allocated rw-data for "
                   << SectionName << ": " << Alloc << " (" << Size
                   << " bytes, alignment " << Alignment << ")\n");
      return Alloc;
    }

    void reserveAllocationSpace(uintptr_t CodeSize, uint32_t CodeAlign,
                                uintptr_t RODataSize, uint32_t RODataAlign,
                                uintptr_t RWDataSize,
                                uint32_t RWDataAlign) override {
      Unmapped.push_back(ObjectAllocs());

      DEBUG(dbgs() << "Allocator " << Id << " reserved:\n");

      if (CodeSize != 0) {
        std::error_code EC = Client.reserveMem(Unmapped.back().RemoteCodeAddr,
                                               Id, CodeSize, CodeAlign);
        // FIXME; Add error to poll.
        assert(!EC && "Failed reserving remote memory.");
        (void)EC;
        DEBUG(dbgs() << "  code: "
                     << format("0x%016x", Unmapped.back().RemoteCodeAddr)
                     << " (" << CodeSize << " bytes, alignment " << CodeAlign
                     << ")\n");
      }

      if (RODataSize != 0) {
        std::error_code EC = Client.reserveMem(Unmapped.back().RemoteRODataAddr,
                                               Id, RODataSize, RODataAlign);
        // FIXME; Add error to poll.
        assert(!EC && "Failed reserving remote memory.");
        (void)EC;
        DEBUG(dbgs() << "  ro-data: "
                     << format("0x%016x", Unmapped.back().RemoteRODataAddr)
                     << " (" << RODataSize << " bytes, alignment "
                     << RODataAlign << ")\n");
      }

      if (RWDataSize != 0) {
        std::error_code EC = Client.reserveMem(Unmapped.back().RemoteRWDataAddr,
                                               Id, RWDataSize, RWDataAlign);
        // FIXME; Add error to poll.
        assert(!EC && "Failed reserving remote memory.");
        (void)EC;
        DEBUG(dbgs() << "  rw-data: "
                     << format("0x%016x", Unmapped.back().RemoteRWDataAddr)
                     << " (" << RWDataSize << " bytes, alignment "
                     << RWDataAlign << ")\n");
      }
    }

    bool needsToReserveAllocationSpace() override { return true; }

    void registerEHFrames(uint8_t *Addr, uint64_t LoadAddr,
                          size_t Size) override {}

    void deregisterEHFrames(uint8_t *addr, uint64_t LoadAddr,
                            size_t Size) override {}

    void notifyObjectLoaded(RuntimeDyld &Dyld,
                            const object::ObjectFile &Obj) override {
      DEBUG(dbgs() << "Allocator " << Id << " applied mappings:\n");
      for (auto &ObjAllocs : Unmapped) {
        {
          TargetAddress NextCodeAddr = ObjAllocs.RemoteCodeAddr;
          for (auto &Alloc : ObjAllocs.CodeAllocs) {
            NextCodeAddr = RoundUpToAlignment(NextCodeAddr, Alloc.getAlign());
            Dyld.mapSectionAddress(Alloc.getLocalAddress(), NextCodeAddr);
            DEBUG(dbgs() << "     code: "
                         << static_cast<void *>(Alloc.getLocalAddress())
                         << " -> " << format("0x%016x", NextCodeAddr) << "\n");
            Alloc.setRemoteAddress(NextCodeAddr);
            NextCodeAddr += Alloc.getSize();
          }
        }
        {
          TargetAddress NextRODataAddr = ObjAllocs.RemoteRODataAddr;
          for (auto &Alloc : ObjAllocs.RODataAllocs) {
            NextRODataAddr =
                RoundUpToAlignment(NextRODataAddr, Alloc.getAlign());
            Dyld.mapSectionAddress(Alloc.getLocalAddress(), NextRODataAddr);
            DEBUG(dbgs() << "  ro-data: "
                         << static_cast<void *>(Alloc.getLocalAddress())
                         << " -> " << format("0x%016x", NextRODataAddr)
                         << "\n");
            Alloc.setRemoteAddress(NextRODataAddr);
            NextRODataAddr += Alloc.getSize();
          }
        }
        {
          TargetAddress NextRWDataAddr = ObjAllocs.RemoteRWDataAddr;
          for (auto &Alloc : ObjAllocs.RWDataAllocs) {
            NextRWDataAddr =
                RoundUpToAlignment(NextRWDataAddr, Alloc.getAlign());
            Dyld.mapSectionAddress(Alloc.getLocalAddress(), NextRWDataAddr);
            DEBUG(dbgs() << "  rw-data: "
                         << static_cast<void *>(Alloc.getLocalAddress())
                         << " -> " << format("0x%016x", NextRWDataAddr)
                         << "\n");
            Alloc.setRemoteAddress(NextRWDataAddr);
            NextRWDataAddr += Alloc.getSize();
          }
        }
        Unfinalized.push_back(std::move(ObjAllocs));
      }
      Unmapped.clear();
    }

    bool finalizeMemory(std::string *ErrMsg = nullptr) override {
      DEBUG(dbgs() << "Allocator " << Id << " finalizing:\n");

      for (auto &ObjAllocs : Unfinalized) {

        for (auto &Alloc : ObjAllocs.CodeAllocs) {
          DEBUG(dbgs() << "  copying code: "
                       << static_cast<void *>(Alloc.getLocalAddress()) << " -> "
                       << format("0x%016x", Alloc.getRemoteAddress()) << " ("
                       << Alloc.getSize() << " bytes)\n");
          Client.writeMem(Alloc.getRemoteAddress(), Alloc.getLocalAddress(),
                          Alloc.getSize());
        }

        if (ObjAllocs.RemoteCodeAddr) {
          DEBUG(dbgs() << "  setting R-X permissions on code block: "
                       << format("0x%016x", ObjAllocs.RemoteCodeAddr) << "\n");
          Client.setProtections(Id, ObjAllocs.RemoteCodeAddr,
                                sys::Memory::MF_READ | sys::Memory::MF_EXEC);
        }

        for (auto &Alloc : ObjAllocs.RODataAllocs) {
          DEBUG(dbgs() << "  copying ro-data: "
                       << static_cast<void *>(Alloc.getLocalAddress()) << " -> "
                       << format("0x%016x", Alloc.getRemoteAddress()) << " ("
                       << Alloc.getSize() << " bytes)\n");
          Client.writeMem(Alloc.getRemoteAddress(), Alloc.getLocalAddress(),
                          Alloc.getSize());
        }

        if (ObjAllocs.RemoteRODataAddr) {
          DEBUG(dbgs() << "  setting R-- permissions on ro-data block: "
                       << format("0x%016x", ObjAllocs.RemoteRODataAddr)
                       << "\n");
          Client.setProtections(Id, ObjAllocs.RemoteRODataAddr,
                                sys::Memory::MF_READ);
        }

        for (auto &Alloc : ObjAllocs.RWDataAllocs) {
          DEBUG(dbgs() << "  copying rw-data: "
                       << static_cast<void *>(Alloc.getLocalAddress()) << " -> "
                       << format("0x%016x", Alloc.getRemoteAddress()) << " ("
                       << Alloc.getSize() << " bytes)\n");
          Client.writeMem(Alloc.getRemoteAddress(), Alloc.getLocalAddress(),
                          Alloc.getSize());
        }

        if (ObjAllocs.RemoteRWDataAddr) {
          DEBUG(dbgs() << "  setting RW- permissions on rw-data block: "
                       << format("0x%016x", ObjAllocs.RemoteRWDataAddr)
                       << "\n");
          Client.setProtections(Id, ObjAllocs.RemoteRWDataAddr,
                                sys::Memory::MF_READ | sys::Memory::MF_WRITE);
        }
      }
      Unfinalized.clear();

      return false;
    }

  private:
    class Alloc {
    public:
      Alloc(uint64_t Size, unsigned Align)
          : Size(Size), Align(Align), Contents(new char[Size + Align - 1]),
            RemoteAddr(0) {}

      Alloc(Alloc &&Other)
          : Size(std::move(Other.Size)), Align(std::move(Other.Align)),
            Contents(std::move(Other.Contents)),
            RemoteAddr(std::move(Other.RemoteAddr)) {}

      Alloc &operator=(Alloc &&Other) {
        Size = std::move(Other.Size);
        Align = std::move(Other.Align);
        Contents = std::move(Other.Contents);
        RemoteAddr = std::move(Other.RemoteAddr);
        return *this;
      }

      uint64_t getSize() const { return Size; }

      unsigned getAlign() const { return Align; }

      char *getLocalAddress() const {
        uintptr_t LocalAddr = reinterpret_cast<uintptr_t>(Contents.get());
        LocalAddr = RoundUpToAlignment(LocalAddr, Align);
        return reinterpret_cast<char *>(LocalAddr);
      }

      void setRemoteAddress(TargetAddress RemoteAddr) {
        this->RemoteAddr = RemoteAddr;
      }

      TargetAddress getRemoteAddress() const { return RemoteAddr; }

    private:
      uint64_t Size;
      unsigned Align;
      std::unique_ptr<char[]> Contents;
      TargetAddress RemoteAddr;
    };

    struct ObjectAllocs {
      ObjectAllocs()
          : RemoteCodeAddr(0), RemoteRODataAddr(0), RemoteRWDataAddr(0) {}

      ObjectAllocs(ObjectAllocs &&Other)
          : RemoteCodeAddr(std::move(Other.RemoteCodeAddr)),
            RemoteRODataAddr(std::move(Other.RemoteRODataAddr)),
            RemoteRWDataAddr(std::move(Other.RemoteRWDataAddr)),
            CodeAllocs(std::move(Other.CodeAllocs)),
            RODataAllocs(std::move(Other.RODataAllocs)),
            RWDataAllocs(std::move(Other.RWDataAllocs)) {}

      ObjectAllocs &operator=(ObjectAllocs &&Other) {
        RemoteCodeAddr = std::move(Other.RemoteCodeAddr);
        RemoteRODataAddr = std::move(Other.RemoteRODataAddr);
        RemoteRWDataAddr = std::move(Other.RemoteRWDataAddr);
        CodeAllocs = std::move(Other.CodeAllocs);
        RODataAllocs = std::move(Other.RODataAllocs);
        RWDataAllocs = std::move(Other.RWDataAllocs);
        return *this;
      }

      TargetAddress RemoteCodeAddr;
      TargetAddress RemoteRODataAddr;
      TargetAddress RemoteRWDataAddr;
      std::vector<Alloc> CodeAllocs, RODataAllocs, RWDataAllocs;
    };

    OrcRemoteTargetClient &Client;
    ResourceIdMgr::ResourceId Id;
    std::vector<ObjectAllocs> Unmapped;
    std::vector<ObjectAllocs> Unfinalized;
  };

  /// Remote indirect stubs manager.
  class RCIndirectStubsManager : public IndirectStubsManager {
  public:
    RCIndirectStubsManager(OrcRemoteTargetClient &Remote,
                           ResourceIdMgr::ResourceId Id)
        : Remote(Remote), Id(Id) {}

    ~RCIndirectStubsManager() { Remote.destroyIndirectStubsManager(Id); }

    std::error_code createStub(StringRef StubName, TargetAddress StubAddr,
                               JITSymbolFlags StubFlags) override {
      if (auto EC = reserveStubs(1))
        return EC;

      return createStubInternal(StubName, StubAddr, StubFlags);
    }

    std::error_code createStubs(const StubInitsMap &StubInits) override {
      if (auto EC = reserveStubs(StubInits.size()))
        return EC;

      for (auto &Entry : StubInits)
        if (auto EC = createStubInternal(Entry.first(), Entry.second.first,
                                         Entry.second.second))
          return EC;

      return std::error_code();
    }

    JITSymbol findStub(StringRef Name, bool ExportedStubsOnly) override {
      auto I = StubIndexes.find(Name);
      if (I == StubIndexes.end())
        return nullptr;
      auto Key = I->second.first;
      auto Flags = I->second.second;
      auto StubSymbol = JITSymbol(getStubAddr(Key), Flags);
      if (ExportedStubsOnly && !StubSymbol.isExported())
        return nullptr;
      return StubSymbol;
    }

    JITSymbol findPointer(StringRef Name) override {
      auto I = StubIndexes.find(Name);
      if (I == StubIndexes.end())
        return nullptr;
      auto Key = I->second.first;
      auto Flags = I->second.second;
      return JITSymbol(getPtrAddr(Key), Flags);
    }

    std::error_code updatePointer(StringRef Name,
                                  TargetAddress NewAddr) override {
      auto I = StubIndexes.find(Name);
      assert(I != StubIndexes.end() && "No stub pointer for symbol");
      auto Key = I->second.first;
      return Remote.writePointer(getPtrAddr(Key), NewAddr);
    }

  private:
    struct RemoteIndirectStubsInfo {
      RemoteIndirectStubsInfo(TargetAddress StubBase, TargetAddress PtrBase,
                              unsigned NumStubs)
          : StubBase(StubBase), PtrBase(PtrBase), NumStubs(NumStubs) {}
      TargetAddress StubBase;
      TargetAddress PtrBase;
      unsigned NumStubs;
    };

    OrcRemoteTargetClient &Remote;
    ResourceIdMgr::ResourceId Id;
    std::vector<RemoteIndirectStubsInfo> RemoteIndirectStubsInfos;
    typedef std::pair<uint16_t, uint16_t> StubKey;
    std::vector<StubKey> FreeStubs;
    StringMap<std::pair<StubKey, JITSymbolFlags>> StubIndexes;

    std::error_code reserveStubs(unsigned NumStubs) {
      if (NumStubs <= FreeStubs.size())
        return std::error_code();

      unsigned NewStubsRequired = NumStubs - FreeStubs.size();
      TargetAddress StubBase;
      TargetAddress PtrBase;
      unsigned NumStubsEmitted;

      Remote.emitIndirectStubs(StubBase, PtrBase, NumStubsEmitted, Id,
                               NewStubsRequired);

      unsigned NewBlockId = RemoteIndirectStubsInfos.size();
      RemoteIndirectStubsInfos.push_back(
          RemoteIndirectStubsInfo(StubBase, PtrBase, NumStubsEmitted));

      for (unsigned I = 0; I < NumStubsEmitted; ++I)
        FreeStubs.push_back(std::make_pair(NewBlockId, I));

      return std::error_code();
    }

    std::error_code createStubInternal(StringRef StubName,
                                       TargetAddress InitAddr,
                                       JITSymbolFlags StubFlags) {
      auto Key = FreeStubs.back();
      FreeStubs.pop_back();
      StubIndexes[StubName] = std::make_pair(Key, StubFlags);
      return Remote.writePointer(getPtrAddr(Key), InitAddr);
    }

    TargetAddress getStubAddr(StubKey K) {
      assert(RemoteIndirectStubsInfos[K.first].StubBase != 0 &&
             "Missing stub address");
      return RemoteIndirectStubsInfos[K.first].StubBase +
             K.second * Remote.getIndirectStubSize();
    }

    TargetAddress getPtrAddr(StubKey K) {
      assert(RemoteIndirectStubsInfos[K.first].PtrBase != 0 &&
             "Missing pointer address");
      return RemoteIndirectStubsInfos[K.first].PtrBase +
             K.second * Remote.getPointerSize();
    }
  };

  /// Remote compile callback manager.
  class RCCompileCallbackManager : public JITCompileCallbackManager {
  public:
    RCCompileCallbackManager(TargetAddress ErrorHandlerAddress,
                             OrcRemoteTargetClient &Remote)
        : JITCompileCallbackManager(ErrorHandlerAddress), Remote(Remote) {
      assert(!Remote.CompileCallback && "Compile callback already set");
      Remote.CompileCallback = [this](TargetAddress TrampolineAddr) {
        return executeCompileCallback(TrampolineAddr);
      };
      Remote.emitResolverBlock();
    }

  private:
    void grow() {
      TargetAddress BlockAddr = 0;
      uint32_t NumTrampolines = 0;
      auto EC = Remote.emitTrampolineBlock(BlockAddr, NumTrampolines);
      assert(!EC && "Failed to create trampolines");

      uint32_t TrampolineSize = Remote.getTrampolineSize();
      for (unsigned I = 0; I < NumTrampolines; ++I)
        this->AvailableTrampolines.push_back(BlockAddr + (I * TrampolineSize));
    }

    OrcRemoteTargetClient &Remote;
  };

  /// Create an OrcRemoteTargetClient.
  /// Channel is the ChannelT instance to communicate on. It is assumed that
  /// the channel is ready to be read from and written to.
  static ErrorOr<OrcRemoteTargetClient> Create(ChannelT &Channel) {
    std::error_code EC;
    OrcRemoteTargetClient H(Channel, EC);
    if (EC)
      return EC;
    return H;
  }

  /// Call the int(void) function at the given address in the target and return
  /// its result.
  std::error_code callIntVoid(int &Result, TargetAddress Addr) {
    DEBUG(dbgs() << "Calling int(*)(void) " << format("0x%016x", Addr) << "\n");

    if (auto EC = call<CallIntVoid>(Channel, Addr))
      return EC;

    unsigned NextProcId;
    if (auto EC = listenForCompileRequests(NextProcId))
      return EC;

    if (NextProcId != CallIntVoidResponseId)
      return orcError(OrcErrorCode::UnexpectedRPCCall);

    return handle<CallIntVoidResponse>(Channel, [&](int R) {
      Result = R;
      DEBUG(dbgs() << "Result: " << R << "\n");
      return std::error_code();
    });
  }

  /// Call the int(int, char*[]) function at the given address in the target and
  /// return its result.
  std::error_code callMain(int &Result, TargetAddress Addr,
                           const std::vector<std::string> &Args) {
    DEBUG(dbgs() << "Calling int(*)(int, char*[]) " << format("0x%016x", Addr)
                 << "\n");

    if (auto EC = call<CallMain>(Channel, Addr, Args))
      return EC;

    unsigned NextProcId;
    if (auto EC = listenForCompileRequests(NextProcId))
      return EC;

    if (NextProcId != CallMainResponseId)
      return orcError(OrcErrorCode::UnexpectedRPCCall);

    return handle<CallMainResponse>(Channel, [&](int R) {
      Result = R;
      DEBUG(dbgs() << "Result: " << R << "\n");
      return std::error_code();
    });
  }

  /// Call the void() function at the given address in the target and wait for
  /// it to finish.
  std::error_code callVoidVoid(TargetAddress Addr) {
    DEBUG(dbgs() << "Calling void(*)(void) " << format("0x%016x", Addr)
                 << "\n");

    if (auto EC = call<CallVoidVoid>(Channel, Addr))
      return EC;

    unsigned NextProcId;
    if (auto EC = listenForCompileRequests(NextProcId))
      return EC;

    if (NextProcId != CallVoidVoidResponseId)
      return orcError(OrcErrorCode::UnexpectedRPCCall);

    return handle<CallVoidVoidResponse>(Channel, doNothing);
  }

  /// Create an RCMemoryManager which will allocate its memory on the remote
  /// target.
  std::error_code
  createRemoteMemoryManager(std::unique_ptr<RCMemoryManager> &MM) {
    assert(!MM && "MemoryManager should be null before creation.");

    auto Id = AllocatorIds.getNext();
    if (auto EC = call<CreateRemoteAllocator>(Channel, Id))
      return EC;
    MM = llvm::make_unique<RCMemoryManager>(*this, Id);
    return std::error_code();
  }

  /// Create an RCIndirectStubsManager that will allocate stubs on the remote
  /// target.
  std::error_code
  createIndirectStubsManager(std::unique_ptr<RCIndirectStubsManager> &I) {
    assert(!I && "Indirect stubs manager should be null before creation.");
    auto Id = IndirectStubOwnerIds.getNext();
    if (auto EC = call<CreateIndirectStubsOwner>(Channel, Id))
      return EC;
    I = llvm::make_unique<RCIndirectStubsManager>(*this, Id);
    return std::error_code();
  }

  /// Search for symbols in the remote process. Note: This should be used by
  /// symbol resolvers *after* they've searched the local symbol table in the
  /// JIT stack.
  std::error_code getSymbolAddress(TargetAddress &Addr, StringRef Name) {
    // Check for an 'out-of-band' error, e.g. from an MM destructor.
    if (ExistingError)
      return ExistingError;

    // Request remote symbol address.
    if (auto EC = call<GetSymbolAddress>(Channel, Name))
      return EC;

    return expect<GetSymbolAddressResponse>(Channel, [&](TargetAddress &A) {
      Addr = A;
      DEBUG(dbgs() << "Remote address lookup " << Name << " = "
                   << format("0x%016x", Addr) << "\n");
      return std::error_code();
    });
  }

  /// Get the triple for the remote target.
  const std::string &getTargetTriple() const { return RemoteTargetTriple; }

  std::error_code terminateSession() { return call<TerminateSession>(Channel); }

private:
  OrcRemoteTargetClient(ChannelT &Channel, std::error_code &EC)
      : Channel(Channel), RemotePointerSize(0), RemotePageSize(0),
        RemoteTrampolineSize(0), RemoteIndirectStubSize(0) {
    if ((EC = call<GetRemoteInfo>(Channel)))
      return;

    EC = expect<GetRemoteInfoResponse>(
        Channel, readArgs(RemoteTargetTriple, RemotePointerSize, RemotePageSize,
                          RemoteTrampolineSize, RemoteIndirectStubSize));
  }

  void destroyRemoteAllocator(ResourceIdMgr::ResourceId Id) {
    if (auto EC = call<DestroyRemoteAllocator>(Channel, Id)) {
      // FIXME: This will be triggered by a removeModuleSet call: Propagate
      //        error return up through that.
      llvm_unreachable("Failed to destroy remote allocator.");
      AllocatorIds.release(Id);
    }
  }

  std::error_code destroyIndirectStubsManager(ResourceIdMgr::ResourceId Id) {
    IndirectStubOwnerIds.release(Id);
    return call<DestroyIndirectStubsOwner>(Channel, Id);
  }

  std::error_code emitIndirectStubs(TargetAddress &StubBase,
                                    TargetAddress &PtrBase,
                                    uint32_t &NumStubsEmitted,
                                    ResourceIdMgr::ResourceId Id,
                                    uint32_t NumStubsRequired) {
    if (auto EC = call<EmitIndirectStubs>(Channel, Id, NumStubsRequired))
      return EC;

    return expect<EmitIndirectStubsResponse>(
        Channel, readArgs(StubBase, PtrBase, NumStubsEmitted));
  }

  std::error_code emitResolverBlock() {
    // Check for an 'out-of-band' error, e.g. from an MM destructor.
    if (ExistingError)
      return ExistingError;

    return call<EmitResolverBlock>(Channel);
  }

  std::error_code emitTrampolineBlock(TargetAddress &BlockAddr,
                                      uint32_t &NumTrampolines) {
    // Check for an 'out-of-band' error, e.g. from an MM destructor.
    if (ExistingError)
      return ExistingError;

    if (auto EC = call<EmitTrampolineBlock>(Channel))
      return EC;

    return expect<EmitTrampolineBlockResponse>(
        Channel, [&](TargetAddress BAddr, uint32_t NTrampolines) {
          BlockAddr = BAddr;
          NumTrampolines = NTrampolines;
          return std::error_code();
        });
  }

  uint32_t getIndirectStubSize() const { return RemoteIndirectStubSize; }
  uint32_t getPageSize() const { return RemotePageSize; }
  uint32_t getPointerSize() const { return RemotePointerSize; }

  uint32_t getTrampolineSize() const { return RemoteTrampolineSize; }

  std::error_code listenForCompileRequests(uint32_t &NextId) {
    // Check for an 'out-of-band' error, e.g. from an MM destructor.
    if (ExistingError)
      return ExistingError;

    if (auto EC = getNextProcId(Channel, NextId))
      return EC;

    while (NextId == RequestCompileId) {
      TargetAddress TrampolineAddr = 0;
      if (auto EC = handle<RequestCompile>(Channel, readArgs(TrampolineAddr)))
        return EC;

      TargetAddress ImplAddr = CompileCallback(TrampolineAddr);
      if (auto EC = call<RequestCompileResponse>(Channel, ImplAddr))
        return EC;

      if (auto EC = getNextProcId(Channel, NextId))
        return EC;
    }

    return std::error_code();
  }

  std::error_code readMem(char *Dst, TargetAddress Src, uint64_t Size) {
    // Check for an 'out-of-band' error, e.g. from an MM destructor.
    if (ExistingError)
      return ExistingError;

    if (auto EC = call<ReadMem>(Channel, Src, Size))
      return EC;

    if (auto EC = expect<ReadMemResponse>(
            Channel, [&]() { return Channel.readBytes(Dst, Size); }))
      return EC;

    return std::error_code();
  }

  std::error_code reserveMem(TargetAddress &RemoteAddr,
                             ResourceIdMgr::ResourceId Id, uint64_t Size,
                             uint32_t Align) {

    // Check for an 'out-of-band' error, e.g. from an MM destructor.
    if (ExistingError)
      return ExistingError;

    if (std::error_code EC = call<ReserveMem>(Channel, Id, Size, Align))
      return EC;

    return expect<ReserveMemResponse>(Channel, readArgs(RemoteAddr));
  }

  std::error_code setProtections(ResourceIdMgr::ResourceId Id,
                                 TargetAddress RemoteSegAddr,
                                 unsigned ProtFlags) {
    return call<SetProtections>(Channel, Id, RemoteSegAddr, ProtFlags);
  }

  std::error_code writeMem(TargetAddress Addr, const char *Src, uint64_t Size) {
    // Check for an 'out-of-band' error, e.g. from an MM destructor.
    if (ExistingError)
      return ExistingError;

    // Make the send call.
    if (auto EC = call<WriteMem>(Channel, Addr, Size))
      return EC;

    // Follow this up with the section contents.
    if (auto EC = Channel.appendBytes(Src, Size))
      return EC;

    return Channel.send();
  }

  std::error_code writePointer(TargetAddress Addr, TargetAddress PtrVal) {
    // Check for an 'out-of-band' error, e.g. from an MM destructor.
    if (ExistingError)
      return ExistingError;

    return call<WritePtr>(Channel, Addr, PtrVal);
  }

  static std::error_code doNothing() { return std::error_code(); }

  ChannelT &Channel;
  std::error_code ExistingError;
  std::string RemoteTargetTriple;
  uint32_t RemotePointerSize;
  uint32_t RemotePageSize;
  uint32_t RemoteTrampolineSize;
  uint32_t RemoteIndirectStubSize;
  ResourceIdMgr AllocatorIds, IndirectStubOwnerIds;
  std::function<TargetAddress(TargetAddress)> CompileCallback;
};

} // end namespace remote
} // end namespace orc
} // end namespace llvm

#undef DEBUG_TYPE

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@a38 17
  // FIXME: Remove move/copy ops once MSVC supports synthesizing move ops.

  OrcRemoteTargetClient(const OrcRemoteTargetClient &) = delete;
  OrcRemoteTargetClient &operator=(const OrcRemoteTargetClient &) = delete;

  OrcRemoteTargetClient(OrcRemoteTargetClient &&Other)
      : Channel(Other.Channel), ExistingError(std::move(Other.ExistingError)),
        RemoteTargetTriple(std::move(Other.RemoteTargetTriple)),
        RemotePointerSize(std::move(Other.RemotePointerSize)),
        RemotePageSize(std::move(Other.RemotePageSize)),
        RemoteTrampolineSize(std::move(Other.RemoteTrampolineSize)),
        RemoteIndirectStubSize(std::move(Other.RemoteIndirectStubSize)),
        AllocatorIds(std::move(Other.AllocatorIds)),
        IndirectStubOwnerIds(std::move(Other.IndirectStubOwnerIds)) {}

  OrcRemoteTargetClient &operator=(OrcRemoteTargetClient &&) = delete;

d60 1
a60 1
    ~RCMemoryManager() override {
d108 5
a112 7
        if (auto AddrOrErr = Client.reserveMem(Id, CodeSize, CodeAlign))
          Unmapped.back().RemoteCodeAddr = *AddrOrErr;
        else {
          // FIXME; Add error to poll.
          assert(!AddrOrErr.takeError() && "Failed reserving remote memory.");
        }

d120 5
a124 7
        if (auto AddrOrErr = Client.reserveMem(Id, RODataSize, RODataAlign))
          Unmapped.back().RemoteRODataAddr = *AddrOrErr;
        else {
          // FIXME; Add error to poll.
          assert(!AddrOrErr.takeError() && "Failed reserving remote memory.");
        }

d132 5
a136 7
        if (auto AddrOrErr = Client.reserveMem(Id, RWDataSize, RWDataAlign))
          Unmapped.back().RemoteRWDataAddr = *AddrOrErr;
        else {
          // FIXME; Add error to poll.
          assert(!AddrOrErr.takeError() && "Failed reserving remote memory.");
        }

d147 1
a147 4
                          size_t Size) override {
      UnfinalizedEHFrames.push_back(
          std::make_pair(LoadAddr, static_cast<uint32_t>(Size)));
    }
d149 2
a150 7
    void deregisterEHFrames(uint8_t *Addr, uint64_t LoadAddr,
                            size_t Size) override {
      auto Err = Client.deregisterEHFrames(LoadAddr, Size);
      // FIXME: Add error poll.
      assert(!Err && "Failed to register remote EH frames.");
      (void)Err;
    }
d159 1
a159 1
            NextCodeAddr = alignTo(NextCodeAddr, Alloc.getAlign());
d171 2
a172 1
            NextRODataAddr = alignTo(NextRODataAddr, Alloc.getAlign());
d185 2
a186 1
            NextRWDataAddr = alignTo(NextRWDataAddr, Alloc.getAlign());
d211 2
a212 12
          if (auto Err =
                  Client.writeMem(Alloc.getRemoteAddress(),
                                  Alloc.getLocalAddress(), Alloc.getSize())) {
            // FIXME: Replace this once finalizeMemory can return an Error.
            handleAllErrors(std::move(Err), [&](ErrorInfoBase &EIB) {
              if (ErrMsg) {
                raw_string_ostream ErrOut(*ErrMsg);
                EIB.log(ErrOut);
              }
            });
            return true;
          }
d218 2
a219 12
          if (auto Err = Client.setProtections(Id, ObjAllocs.RemoteCodeAddr,
                                               sys::Memory::MF_READ |
                                                   sys::Memory::MF_EXEC)) {
            // FIXME: Replace this once finalizeMemory can return an Error.
            handleAllErrors(std::move(Err), [&](ErrorInfoBase &EIB) {
              if (ErrMsg) {
                raw_string_ostream ErrOut(*ErrMsg);
                EIB.log(ErrOut);
              }
            });
            return true;
          }
d227 2
a228 12
          if (auto Err =
                  Client.writeMem(Alloc.getRemoteAddress(),
                                  Alloc.getLocalAddress(), Alloc.getSize())) {
            // FIXME: Replace this once finalizeMemory can return an Error.
            handleAllErrors(std::move(Err), [&](ErrorInfoBase &EIB) {
              if (ErrMsg) {
                raw_string_ostream ErrOut(*ErrMsg);
                EIB.log(ErrOut);
              }
            });
            return true;
          }
d235 2
a236 11
          if (auto Err = Client.setProtections(Id, ObjAllocs.RemoteRODataAddr,
                                               sys::Memory::MF_READ)) {
            // FIXME: Replace this once finalizeMemory can return an Error.
            handleAllErrors(std::move(Err), [&](ErrorInfoBase &EIB) {
              if (ErrMsg) {
                raw_string_ostream ErrOut(*ErrMsg);
                EIB.log(ErrOut);
              }
            });
            return false;
          }
d244 2
a245 12
          if (auto Err =
                  Client.writeMem(Alloc.getRemoteAddress(),
                                  Alloc.getLocalAddress(), Alloc.getSize())) {
            // FIXME: Replace this once finalizeMemory can return an Error.
            handleAllErrors(std::move(Err), [&](ErrorInfoBase &EIB) {
              if (ErrMsg) {
                raw_string_ostream ErrOut(*ErrMsg);
                EIB.log(ErrOut);
              }
            });
            return false;
          }
d252 2
a253 12
          if (auto Err = Client.setProtections(Id, ObjAllocs.RemoteRWDataAddr,
                                               sys::Memory::MF_READ |
                                                   sys::Memory::MF_WRITE)) {
            // FIXME: Replace this once finalizeMemory can return an Error.
            handleAllErrors(std::move(Err), [&](ErrorInfoBase &EIB) {
              if (ErrMsg) {
                raw_string_ostream ErrOut(*ErrMsg);
                EIB.log(ErrOut);
              }
            });
            return false;
          }
a257 14
      for (auto &EHFrame : UnfinalizedEHFrames) {
        if (auto Err = Client.registerEHFrames(EHFrame.first, EHFrame.second)) {
          // FIXME: Replace this once finalizeMemory can return an Error.
          handleAllErrors(std::move(Err), [&](ErrorInfoBase &EIB) {
            if (ErrMsg) {
              raw_string_ostream ErrOut(*ErrMsg);
              EIB.log(ErrOut);
            }
          });
          return false;
        }
      }
      UnfinalizedEHFrames.clear();

d265 2
a266 1
          : Size(Size), Align(Align), Contents(new char[Size + Align - 1]) {}
d287 1
a287 1
        LocalAddr = alignTo(LocalAddr, Align);
d301 1
a301 1
      TargetAddress RemoteAddr = 0;
d305 2
a306 1
      ObjectAllocs() = default;
d326 3
a328 3
      TargetAddress RemoteCodeAddr = 0;
      TargetAddress RemoteRODataAddr = 0;
      TargetAddress RemoteRWDataAddr = 0;
a335 1
    std::vector<std::pair<uint64_t, uint32_t>> UnfinalizedEHFrames;
d345 1
a345 6
    ~RCIndirectStubsManager() override {
      if (auto Err = Remote.destroyIndirectStubsManager(Id)) {
        // FIXME: Thread this error back to clients.
        consumeError(std::move(Err));
      }
    }
d347 4
a350 4
    Error createStub(StringRef StubName, TargetAddress StubAddr,
                     JITSymbolFlags StubFlags) override {
      if (auto Err = reserveStubs(1))
        return Err;
d355 3
a357 3
    Error createStubs(const StubInitsMap &StubInits) override {
      if (auto Err = reserveStubs(StubInits.size()))
        return Err;
d360 3
a362 3
        if (auto Err = createStubInternal(Entry.first(), Entry.second.first,
                                          Entry.second.second))
          return Err;
d364 1
a364 1
      return Error::success();
d388 2
a389 1
    Error updatePointer(StringRef Name, TargetAddress NewAddr) override {
d398 3
d413 1
a413 1
    Error reserveStubs(unsigned NumStubs) {
d415 1
a415 1
        return Error::success();
d422 2
a423 4
      if (auto StubInfoOrErr = Remote.emitIndirectStubs(Id, NewStubsRequired))
        std::tie(StubBase, PtrBase, NumStubsEmitted) = *StubInfoOrErr;
      else
        return StubInfoOrErr.takeError();
d426 2
a427 1
      RemoteIndirectStubsInfos.push_back({StubBase, PtrBase, NumStubsEmitted});
d432 1
a432 1
      return Error::success();
d435 3
a437 2
    Error createStubInternal(StringRef StubName, TargetAddress InitAddr,
                             JITSymbolFlags StubFlags) {
d464 7
a470 1
        : JITCompileCallbackManager(ErrorHandlerAddress), Remote(Remote) {}
d473 1
a473 1
    void grow() override {
d476 2
a477 6
      if (auto TrampolineInfoOrErr = Remote.emitTrampolineBlock())
        std::tie(BlockAddr, NumTrampolines) = *TrampolineInfoOrErr;
      else {
        // FIXME: Return error.
        llvm_unreachable("Failed to create trampolines");
      }
d490 6
a495 6
  static Expected<OrcRemoteTargetClient> Create(ChannelT &Channel) {
    Error Err;
    OrcRemoteTargetClient H(Channel, Err);
    if (Err)
      return std::move(Err);
    return Expected<OrcRemoteTargetClient>(std::move(H));
d500 1
a500 1
  Expected<int> callIntVoid(TargetAddress Addr) {
d503 15
a517 4
    auto Listen = [&](RPCChannel &C, uint32_t Id) {
      return listenForCompileRequests(C, Id);
    };
    return callSTHandling<CallIntVoid>(Channel, Listen, Addr);
d522 2
a523 2
  Expected<int> callMain(TargetAddress Addr,
                         const std::vector<std::string> &Args) {
d527 15
a541 4
    auto Listen = [&](RPCChannel &C, uint32_t Id) {
      return listenForCompileRequests(C, Id);
    };
    return callSTHandling<CallMain>(Channel, Listen, Addr, Args);
d546 1
a546 1
  Error callVoidVoid(TargetAddress Addr) {
d550 11
a560 4
    auto Listen = [&](RPCChannel &C, uint32_t Id) {
      return listenForCompileRequests(C, Id);
    };
    return callSTHandling<CallVoidVoid>(Channel, Listen, Addr);
d565 2
a566 1
  Error createRemoteMemoryManager(std::unique_ptr<RCMemoryManager> &MM) {
d570 2
a571 2
    if (auto Err = callST<CreateRemoteAllocator>(Channel, Id))
      return Err;
d573 1
a573 1
    return Error::success();
d578 2
a579 1
  Error createIndirectStubsManager(std::unique_ptr<RCIndirectStubsManager> &I) {
d582 2
a583 2
    if (auto Err = callST<CreateIndirectStubsOwner>(Channel, Id))
      return Err;
d585 1
a585 17
    return Error::success();
  }

  Expected<RCCompileCallbackManager &>
  enableCompileCallbacks(TargetAddress ErrorHandlerAddress) {
    // Check for an 'out-of-band' error, e.g. from an MM destructor.
    if (ExistingError)
      return std::move(ExistingError);

    // Emit the resolver block on the JIT server.
    if (auto Err = callST<EmitResolverBlock>(Channel))
      return std::move(Err);

    // Create the callback manager.
    CallbackManager.emplace(ErrorHandlerAddress, *this);
    RCCompileCallbackManager &Mgr = *CallbackManager;
    return Mgr;
d591 1
a591 1
  Expected<TargetAddress> getSymbolAddress(StringRef Name) {
d594 1
a594 1
      return std::move(ExistingError);
d596 10
a605 1
    return callST<GetSymbolAddress>(Channel, Name);
d611 1
a611 1
  Error terminateSession() { return callST<TerminateSession>(Channel); }
d614 9
a622 13
  OrcRemoteTargetClient(ChannelT &Channel, Error &Err) : Channel(Channel) {
    ErrorAsOutParameter EAO(Err);
    if (auto RIOrErr = callST<GetRemoteInfo>(Channel)) {
      std::tie(RemoteTargetTriple, RemotePointerSize, RemotePageSize,
               RemoteTrampolineSize, RemoteIndirectStubSize) = *RIOrErr;
      Err = Error::success();
    } else {
      Err = joinErrors(RIOrErr.takeError(), std::move(ExistingError));
    }
  }

  Error deregisterEHFrames(TargetAddress Addr, uint32_t Size) {
    return callST<RegisterEHFrames>(Channel, Addr, Size);
d626 1
a626 1
    if (auto Err = callST<DestroyRemoteAllocator>(Channel, Id)) {
d634 1
a634 1
  Error destroyIndirectStubsManager(ResourceIdMgr::ResourceId Id) {
d636 1
a636 1
    return callST<DestroyIndirectStubsOwner>(Channel, Id);
d639 10
a648 3
  Expected<std::tuple<TargetAddress, TargetAddress, uint32_t>>
  emitIndirectStubs(ResourceIdMgr::ResourceId Id, uint32_t NumStubsRequired) {
    return callST<EmitIndirectStubs>(Channel, Id, NumStubsRequired);
d651 1
a651 1
  Expected<std::tuple<TargetAddress, uint32_t>> emitTrampolineBlock() {
d654 1
a654 1
      return std::move(ExistingError);
d656 18
a673 1
    return callST<EmitTrampolineBlock>(Channel);
d682 1
a682 4
  Error listenForCompileRequests(RPCChannel &C, uint32_t &Id) {
    assert(CallbackManager &&
           "No calback manager. enableCompileCallbacks must be called first");

d685 9
a693 1
      return std::move(ExistingError);
d695 3
a697 7
    // FIXME: CompileCallback could be an anonymous lambda defined at the use
    //        site below, but that triggers a GCC 4.7 ICE. When we move off
    //        GCC 4.7, tidy this up.
    auto CompileCallback =
      [this](TargetAddress Addr) -> Expected<TargetAddress> {
        return this->CallbackManager->executeCompileCallback(Addr);
      };
d699 2
a700 4
    if (Id == RequestCompileId) {
      if (auto Err = handle<RequestCompile>(C, CompileCallback))
        return Err;
      return Error::success();
d702 2
a703 2
    // else
    return orcError(OrcErrorCode::UnexpectedRPCCall);
d706 1
a706 2
  Expected<std::vector<char>> readMem(char *Dst, TargetAddress Src,
                                      uint64_t Size) {
d709 1
a709 1
      return std::move(ExistingError);
d711 6
a716 2
    return callST<ReadMem>(Channel, Src, Size);
  }
d718 1
a718 2
  Error registerEHFrames(TargetAddress &RAddr, uint32_t Size) {
    return callST<RegisterEHFrames>(Channel, RAddr, Size);
d721 3
a723 2
  Expected<TargetAddress> reserveMem(ResourceIdMgr::ResourceId Id,
                                     uint64_t Size, uint32_t Align) {
d727 1
a727 1
      return std::move(ExistingError);
d729 4
a732 1
    return callST<ReserveMem>(Channel, Id, Size, Align);
d735 4
a738 3
  Error setProtections(ResourceIdMgr::ResourceId Id,
                       TargetAddress RemoteSegAddr, unsigned ProtFlags) {
    return callST<SetProtections>(Channel, Id, RemoteSegAddr, ProtFlags);
d741 1
a741 1
  Error writeMem(TargetAddress Addr, const char *Src, uint64_t Size) {
d744 9
a752 1
      return std::move(ExistingError);
d754 1
a754 1
    return callST<WriteMem>(Channel, DirectBufferWriter(Src, Addr, Size));
d757 1
a757 1
  Error writePointer(TargetAddress Addr, TargetAddress PtrVal) {
d760 1
a760 1
      return std::move(ExistingError);
d762 1
a762 1
    return callST<WritePtr>(Channel, Addr, PtrVal);
d765 1
a765 1
  static Error doNothing() { return Error::success(); }
d768 1
a768 1
  Error ExistingError;
d770 4
a773 4
  uint32_t RemotePointerSize = 0;
  uint32_t RemotePageSize = 0;
  uint32_t RemoteTrampolineSize = 0;
  uint32_t RemoteIndirectStubSize = 0;
d775 1
a775 1
  Optional<RCCompileCallbackManager> CallbackManager;
d784 1
a784 1
#endif // LLVM_EXECUTIONENGINE_ORC_ORCREMOTETARGETCLIENT_H
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d11 2
a12 2
// can be used to communicate over an RawByteChannel with an
// OrcRemoteTargetServer instance to support remote-JITing.
d39 17
d64 12
a75 4
    RCMemoryManager(const RCMemoryManager &) = delete;
    RCMemoryManager &operator=(const RCMemoryManager &) = delete;
    RCMemoryManager(RCMemoryManager &&) = default;
    RCMemoryManager &operator=(RCMemoryManager &&) = default;
d188 1
a188 1
          JITTargetAddress NextCodeAddr = ObjAllocs.RemoteCodeAddr;
d200 1
a200 1
          JITTargetAddress NextRODataAddr = ObjAllocs.RemoteRODataAddr;
d213 1
a213 1
          JITTargetAddress NextRWDataAddr = ObjAllocs.RemoteRWDataAddr;
d369 12
a380 4
      Alloc(const Alloc &) = delete;
      Alloc &operator=(const Alloc &) = delete;
      Alloc(Alloc &&) = default;
      Alloc &operator=(Alloc &&) = default;
d392 1
a392 1
      void setRemoteAddress(JITTargetAddress RemoteAddr) {
d396 1
a396 1
      JITTargetAddress getRemoteAddress() const { return RemoteAddr; }
d402 1
a402 1
      JITTargetAddress RemoteAddr = 0;
d407 22
a428 8
      ObjectAllocs(const ObjectAllocs &) = delete;
      ObjectAllocs &operator=(const ObjectAllocs &) = delete;
      ObjectAllocs(ObjectAllocs &&) = default;
      ObjectAllocs &operator=(ObjectAllocs &&) = default;

      JITTargetAddress RemoteCodeAddr = 0;
      JITTargetAddress RemoteRODataAddr = 0;
      JITTargetAddress RemoteRWDataAddr = 0;
d453 1
a453 1
    Error createStub(StringRef StubName, JITTargetAddress StubAddr,
d480 1
a480 1
      if (ExportedStubsOnly && !StubSymbol.getFlags().isExported())
d494 1
a494 1
    Error updatePointer(StringRef Name, JITTargetAddress NewAddr) override {
d503 2
a504 2
      JITTargetAddress StubBase;
      JITTargetAddress PtrBase;
d520 2
a521 2
      JITTargetAddress StubBase;
      JITTargetAddress PtrBase;
d538 1
a538 1
    Error createStubInternal(StringRef StubName, JITTargetAddress InitAddr,
d546 1
a546 1
    JITTargetAddress getStubAddr(StubKey K) {
d553 1
a553 1
    JITTargetAddress getPtrAddr(StubKey K) {
d564 1
a564 1
    RCCompileCallbackManager(JITTargetAddress ErrorHandlerAddress,
d570 1
a570 1
      JITTargetAddress BlockAddr = 0;
d590 3
a592 5
  static Expected<std::unique_ptr<OrcRemoteTargetClient>>
  Create(ChannelT &Channel) {
    Error Err = Error::success();
    std::unique_ptr<OrcRemoteTargetClient> Client(
        new OrcRemoteTargetClient(Channel, Err));
d595 1
a595 1
    return std::move(Client);
d600 1
a600 1
  Expected<int> callIntVoid(JITTargetAddress Addr) {
d602 5
a606 1
    return callB<CallIntVoid>(Addr);
d611 1
a611 1
  Expected<int> callMain(JITTargetAddress Addr,
d615 5
a619 1
    return callB<CallMain>(Addr, Args);
d624 1
a624 1
  Error callVoidVoid(JITTargetAddress Addr) {
d627 5
a631 1
    return callB<CallVoidVoid>(Addr);
d640 1
a640 1
    if (auto Err = callB<CreateRemoteAllocator>(Id))
d651 1
a651 1
    if (auto Err = callB<CreateIndirectStubsOwner>(Id))
d658 1
a658 1
  enableCompileCallbacks(JITTargetAddress ErrorHandlerAddress) {
d664 1
a664 1
    if (auto Err = callB<EmitResolverBlock>())
d676 1
a676 1
  Expected<JITTargetAddress> getSymbolAddress(StringRef Name) {
d681 1
a681 1
    return callB<GetSymbolAddress>(Name);
d687 1
a687 1
  Error terminateSession() { return callB<TerminateSession>(); }
d690 3
a692 12
  OrcRemoteTargetClient(ChannelT &Channel, Error &Err)
      : OrcRemoteTargetRPCAPI(Channel) {
    ErrorAsOutParameter EAO(&Err);

    addHandler<RequestCompile>(
        [this](JITTargetAddress Addr) -> JITTargetAddress {
          if (CallbackManager)
            return CallbackManager->executeCompileCallback(Addr);
          return 0;
        });

    if (auto RIOrErr = callB<GetRemoteInfo>()) {
d701 2
a702 2
  Error deregisterEHFrames(JITTargetAddress Addr, uint32_t Size) {
    return callB<RegisterEHFrames>(Addr, Size);
d706 1
a706 1
    if (auto Err = callB<DestroyRemoteAllocator>(Id)) {
d716 1
a716 1
    return callB<DestroyIndirectStubsOwner>(Id);
d719 1
a719 1
  Expected<std::tuple<JITTargetAddress, JITTargetAddress, uint32_t>>
d721 1
a721 1
    return callB<EmitIndirectStubs>(Id, NumStubsRequired);
d724 1
a724 1
  Expected<std::tuple<JITTargetAddress, uint32_t>> emitTrampolineBlock() {
d729 1
a729 1
    return callB<EmitTrampolineBlock>();
d738 26
a763 1
  Expected<std::vector<char>> readMem(char *Dst, JITTargetAddress Src,
d769 1
a769 1
    return callB<ReadMem>(Src, Size);
d772 2
a773 2
  Error registerEHFrames(JITTargetAddress &RAddr, uint32_t Size) {
    return callB<RegisterEHFrames>(RAddr, Size);
d776 2
a777 2
  Expected<JITTargetAddress> reserveMem(ResourceIdMgr::ResourceId Id,
                                        uint64_t Size, uint32_t Align) {
d783 1
a783 1
    return callB<ReserveMem>(Id, Size, Align);
d787 2
a788 2
                       JITTargetAddress RemoteSegAddr, unsigned ProtFlags) {
    return callB<SetProtections>(Id, RemoteSegAddr, ProtFlags);
d791 1
a791 1
  Error writeMem(JITTargetAddress Addr, const char *Src, uint64_t Size) {
d796 1
a796 1
    return callB<WriteMem>(DirectBufferWriter(Src, Addr, Size));
d799 1
a799 1
  Error writePointer(JITTargetAddress Addr, JITTargetAddress PtrVal) {
d804 1
a804 1
    return callB<WritePtr>(Addr, PtrVal);
d809 2
a810 1
  Error ExistingError = Error::success();
@


