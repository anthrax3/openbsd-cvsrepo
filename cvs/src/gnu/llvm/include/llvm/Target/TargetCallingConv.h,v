head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.4
	OPENBSD_6_2:1.1.1.3.0.2
	OPENBSD_6_2_BASE:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.4
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.57;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.17;	author patrick;	state Exp;
branches;
next	1.1.1.4;
commitid	so2WA7LCP6wbxtYl;

1.1.1.4
date	2017.10.04.20.27.53;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- llvm/Target/TargetCallingConv.h - Calling Convention ----*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines types for working with calling-convention information.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_TARGET_TARGETCALLINGCONV_H
#define LLVM_TARGET_TARGETCALLINGCONV_H

#include "llvm/CodeGen/ValueTypes.h"
#include "llvm/Support/DataTypes.h"
#include "llvm/Support/MathExtras.h"
#include <string>
#include <limits.h>

namespace llvm {

namespace ISD {
  struct ArgFlagsTy {
  private:
    static const uint64_t NoFlagSet      = 0ULL;
    static const uint64_t ZExt           = 1ULL<<0;  ///< Zero extended
    static const uint64_t ZExtOffs       = 0;
    static const uint64_t SExt           = 1ULL<<1;  ///< Sign extended
    static const uint64_t SExtOffs       = 1;
    static const uint64_t InReg          = 1ULL<<2;  ///< Passed in register
    static const uint64_t InRegOffs      = 2;
    static const uint64_t SRet           = 1ULL<<3;  ///< Hidden struct-ret ptr
    static const uint64_t SRetOffs       = 3;
    static const uint64_t ByVal          = 1ULL<<4;  ///< Struct passed by value
    static const uint64_t ByValOffs      = 4;
    static const uint64_t Nest           = 1ULL<<5;  ///< Nested fn static chain
    static const uint64_t NestOffs       = 5;
    static const uint64_t Returned       = 1ULL<<6;  ///< Always returned
    static const uint64_t ReturnedOffs   = 6;
    static const uint64_t ByValAlign     = 0xFULL<<7; ///< Struct alignment
    static const uint64_t ByValAlignOffs = 7;
    static const uint64_t Split          = 1ULL<<11;
    static const uint64_t SplitOffs      = 11;
    static const uint64_t InAlloca       = 1ULL<<12; ///< Passed with inalloca
    static const uint64_t InAllocaOffs   = 12;
    static const uint64_t SplitEnd       = 1ULL<<13; ///< Last part of a split
    static const uint64_t SplitEndOffs   = 13;
    static const uint64_t OrigAlign      = 0x1FULL<<27;
    static const uint64_t OrigAlignOffs  = 27;
    static const uint64_t ByValSize      = 0x3fffffffULL<<32; ///< Struct size
    static const uint64_t ByValSizeOffs  = 32;
    static const uint64_t InConsecutiveRegsLast      = 0x1ULL<<62; ///< Struct size
    static const uint64_t InConsecutiveRegsLastOffs  = 62;
    static const uint64_t InConsecutiveRegs      = 0x1ULL<<63; ///< Struct size
    static const uint64_t InConsecutiveRegsOffs  = 63;

    static const uint64_t One            = 1ULL; ///< 1 of this type, for shifts

    uint64_t Flags;
  public:
    ArgFlagsTy() : Flags(0) { }

    bool isZExt()      const { return Flags & ZExt; }
    void setZExt()     { Flags |= One << ZExtOffs; }

    bool isSExt()      const { return Flags & SExt; }
    void setSExt()     { Flags |= One << SExtOffs; }

    bool isInReg()     const { return Flags & InReg; }
    void setInReg()    { Flags |= One << InRegOffs; }

    bool isSRet()      const { return Flags & SRet; }
    void setSRet()     { Flags |= One << SRetOffs; }

    bool isByVal()     const { return Flags & ByVal; }
    void setByVal()    { Flags |= One << ByValOffs; }

    bool isInAlloca()  const { return Flags & InAlloca; }
    void setInAlloca() { Flags |= One << InAllocaOffs; }

    bool isNest()      const { return Flags & Nest; }
    void setNest()     { Flags |= One << NestOffs; }

    bool isReturned()  const { return Flags & Returned; }
    void setReturned() { Flags |= One << ReturnedOffs; }

    bool isInConsecutiveRegs()  const { return Flags & InConsecutiveRegs; }
    void setInConsecutiveRegs() { Flags |= One << InConsecutiveRegsOffs; }

    bool isInConsecutiveRegsLast()  const { return Flags & InConsecutiveRegsLast; }
    void setInConsecutiveRegsLast() { Flags |= One << InConsecutiveRegsLastOffs; }

    unsigned getByValAlign() const {
      return (unsigned)
        ((One << ((Flags & ByValAlign) >> ByValAlignOffs)) / 2);
    }
    void setByValAlign(unsigned A) {
      Flags = (Flags & ~ByValAlign) |
        (uint64_t(Log2_32(A) + 1) << ByValAlignOffs);
    }

    bool isSplit()   const { return Flags & Split; }
    void setSplit()  { Flags |= One << SplitOffs; }

    bool isSplitEnd()   const { return Flags & SplitEnd; }
    void setSplitEnd()  { Flags |= One << SplitEndOffs; }

    unsigned getOrigAlign() const {
      return (unsigned)
        ((One << ((Flags & OrigAlign) >> OrigAlignOffs)) / 2);
    }
    void setOrigAlign(unsigned A) {
      Flags = (Flags & ~OrigAlign) |
        (uint64_t(Log2_32(A) + 1) << OrigAlignOffs);
    }

    unsigned getByValSize() const {
      return (unsigned)((Flags & ByValSize) >> ByValSizeOffs);
    }
    void setByValSize(unsigned S) {
      Flags = (Flags & ~ByValSize) | (uint64_t(S) << ByValSizeOffs);
    }

    /// getRawBits - Represent the flags as a bunch of bits.
    uint64_t getRawBits() const { return Flags; }
  };

  /// InputArg - This struct carries flags and type information about a
  /// single incoming (formal) argument or incoming (from the perspective
  /// of the caller) return value virtual register.
  ///
  struct InputArg {
    ArgFlagsTy Flags;
    MVT VT;
    EVT ArgVT;
    bool Used;

    /// Index original Function's argument.
    unsigned OrigArgIndex;
    /// Sentinel value for implicit machine-level input arguments.
    static const unsigned NoArgIndex = UINT_MAX;

    /// Offset in bytes of current input value relative to the beginning of
    /// original argument. E.g. if argument was splitted into four 32 bit
    /// registers, we got 4 InputArgs with PartOffsets 0, 4, 8 and 12.
    unsigned PartOffset;

    InputArg() : VT(MVT::Other), Used(false) {}
    InputArg(ArgFlagsTy flags, EVT vt, EVT argvt, bool used,
             unsigned origIdx, unsigned partOffs)
      : Flags(flags), Used(used), OrigArgIndex(origIdx), PartOffset(partOffs) {
      VT = vt.getSimpleVT();
      ArgVT = argvt;
    }

    bool isOrigArg() const {
      return OrigArgIndex != NoArgIndex;
    }

    unsigned getOrigArgIndex() const {
      assert(OrigArgIndex != NoArgIndex && "Implicit machine-level argument");
      return OrigArgIndex;
    }
  };

  /// OutputArg - This struct carries flags and a value for a
  /// single outgoing (actual) argument or outgoing (from the perspective
  /// of the caller) return value virtual register.
  ///
  struct OutputArg {
    ArgFlagsTy Flags;
    MVT VT;
    EVT ArgVT;

    /// IsFixed - Is this a "fixed" value, ie not passed through a vararg "...".
    bool IsFixed;

    /// Index original Function's argument.
    unsigned OrigArgIndex;

    /// Offset in bytes of current output value relative to the beginning of
    /// original argument. E.g. if argument was splitted into four 32 bit
    /// registers, we got 4 OutputArgs with PartOffsets 0, 4, 8 and 12.
    unsigned PartOffset;

    OutputArg() : IsFixed(false) {}
    OutputArg(ArgFlagsTy flags, EVT vt, EVT argvt, bool isfixed,
              unsigned origIdx, unsigned partOffs)
      : Flags(flags), IsFixed(isfixed), OrigArgIndex(origIdx),
        PartOffset(partOffs) {
      VT = vt.getSimpleVT();
      ArgVT = argvt;
    }
  };
}

} // end llvm namespace

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d20 2
a21 1
#include <climits>
a50 4
    static const uint64_t SwiftSelf      = 1ULL<<14; ///< Swift self parameter
    static const uint64_t SwiftSelfOffs  = 14;
    static const uint64_t SwiftError     = 1ULL<<15; ///< Swift error parameter
    static const uint64_t SwiftErrorOffs = 15;
a62 1

a83 6
    bool isSwiftSelf() const { return Flags & SwiftSelf; }
    void setSwiftSelf() { Flags |= One << SwiftSelfOffs; }

    bool isSwiftError() const { return Flags & SwiftError; }
    void setSwiftError() { Flags |= One << SwiftErrorOffs; }

d198 1
a198 1
} // end namespace ISD
d202 1
a202 1
#endif // LLVM_TARGET_TARGETCALLINGCONV_H
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a53 9
    static const uint64_t Hva            = 1ULL << 16; ///< HVA field for
                                                       ///< vectorcall
    static const uint64_t HvaOffs        = 16;
    static const uint64_t HvaStart       = 1ULL << 17; ///< HVA structure start
                                                       ///< for vectorcall
    static const uint64_t HvaStartOffs   = 17;
    static const uint64_t SecArgPass     = 1ULL << 18; ///< Second argument
                                                       ///< pass for vectorcall
    static const uint64_t SecArgPassOffs = 18;
a92 9

    bool isHva() const { return Flags & Hva; }
    void setHva() { Flags |= One << HvaOffs; }

    bool isHvaStart() const { return Flags & HvaStart; }
    void setHvaStart() { Flags |= One << HvaStartOffs; }

    bool isSecArgPass() const { return Flags & SecArgPass; }
    void setSecArgPass() { Flags |= One << SecArgPassOffs; }
@


1.1.1.4
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@a16 1
#include "llvm/CodeGen/MachineValueType.h"
d18 1
a19 1
#include <cassert>
a20 1
#include <cstdint>
d23 1
a24 1

d27 44
a70 20
    unsigned IsZExt : 1;     ///< Zero extended
    unsigned IsSExt : 1;     ///< Sign extended
    unsigned IsInReg : 1;    ///< Passed in register
    unsigned IsSRet : 1;     ///< Hidden struct-ret ptr
    unsigned IsByVal : 1;    ///< Struct passed by value
    unsigned IsNest : 1;     ///< Nested fn static chain
    unsigned IsReturned : 1; ///< Always returned
    unsigned IsSplit : 1;
    unsigned IsInAlloca : 1;   ///< Passed with inalloca
    unsigned IsSplitEnd : 1;   ///< Last part of a split
    unsigned IsSwiftSelf : 1;  ///< Swift self parameter
    unsigned IsSwiftError : 1; ///< Swift error parameter
    unsigned IsHva : 1;        ///< HVA field for
    unsigned IsHvaStart : 1;   ///< HVA structure start
    unsigned IsSecArgPass : 1; ///< Second argument
    unsigned ByValAlign : 4;   ///< Log 2 of byval alignment
    unsigned OrigAlign : 5;    ///< Log 2 of original alignment
    unsigned IsInConsecutiveRegsLast : 1;
    unsigned IsInConsecutiveRegs : 1;
    unsigned IsCopyElisionCandidate : 1; ///< Argument copy elision candidate
d72 3
a74 1
    unsigned ByValSize; ///< Byval struct size
d77 1
a77 9
    ArgFlagsTy()
        : IsZExt(0), IsSExt(0), IsInReg(0), IsSRet(0), IsByVal(0), IsNest(0),
          IsReturned(0), IsSplit(0), IsInAlloca(0), IsSplitEnd(0),
          IsSwiftSelf(0), IsSwiftError(0), IsHva(0), IsHvaStart(0),
          IsSecArgPass(0), ByValAlign(0), OrigAlign(0),
          IsInConsecutiveRegsLast(0), IsInConsecutiveRegs(0),
          IsCopyElisionCandidate(0), ByValSize(0) {
      static_assert(sizeof(*this) == 2 * sizeof(unsigned), "flags are too big");
    }
d79 2
a80 2
    bool isZExt() const { return IsZExt; }
    void setZExt() { IsZExt = 1; }
d82 2
a83 2
    bool isSExt() const { return IsSExt; }
    void setSExt() { IsSExt = 1; }
d85 2
a86 2
    bool isInReg() const { return IsInReg; }
    void setInReg() { IsInReg = 1; }
d88 2
a89 2
    bool isSRet() const { return IsSRet; }
    void setSRet() { IsSRet = 1; }
d91 2
a92 2
    bool isByVal() const { return IsByVal; }
    void setByVal() { IsByVal = 1; }
d94 2
a95 2
    bool isInAlloca() const { return IsInAlloca; }
    void setInAlloca() { IsInAlloca = 1; }
d97 2
a98 2
    bool isSwiftSelf() const { return IsSwiftSelf; }
    void setSwiftSelf() { IsSwiftSelf = 1; }
d100 2
a101 2
    bool isSwiftError() const { return IsSwiftError; }
    void setSwiftError() { IsSwiftError = 1; }
d103 2
a104 2
    bool isHva() const { return IsHva; }
    void setHva() { IsHva = 1; }
d106 2
a107 2
    bool isHvaStart() const { return IsHvaStart; }
    void setHvaStart() { IsHvaStart = 1; }
d109 2
a110 2
    bool isSecArgPass() const { return IsSecArgPass; }
    void setSecArgPass() { IsSecArgPass = 1; }
d112 2
a113 2
    bool isNest() const { return IsNest; }
    void setNest() { IsNest = 1; }
d115 2
a116 2
    bool isReturned() const { return IsReturned; }
    void setReturned() { IsReturned = 1; }
d118 2
a119 2
    bool isInConsecutiveRegs()  const { return IsInConsecutiveRegs; }
    void setInConsecutiveRegs() { IsInConsecutiveRegs = 1; }
d121 2
a122 2
    bool isInConsecutiveRegsLast() const { return IsInConsecutiveRegsLast; }
    void setInConsecutiveRegsLast() { IsInConsecutiveRegsLast = 1; }
d124 8
a131 2
    bool isSplit()   const { return IsSplit; }
    void setSplit()  { IsSplit = 1; }
d133 2
a134 2
    bool isSplitEnd()   const { return IsSplitEnd; }
    void setSplitEnd()  { IsSplitEnd = 1; }
d136 2
a137 2
    bool isCopyElisionCandidate()  const { return IsCopyElisionCandidate; }
    void setCopyElisionCandidate() { IsCopyElisionCandidate = 1; }
d139 7
a145 4
    unsigned getByValAlign() const { return (1U << ByValAlign) / 2; }
    void setByValAlign(unsigned A) {
      ByValAlign = Log2_32(A) + 1;
      assert(getByValAlign() == A && "bitfield overflow");
d148 5
a152 4
    unsigned getOrigAlign() const { return (1U << OrigAlign) / 2; }
    void setOrigAlign(unsigned A) {
      OrigAlign = Log2_32(A) + 1;
      assert(getOrigAlign() == A && "bitfield overflow");
d155 2
a156 2
    unsigned getByValSize() const { return ByValSize; }
    void setByValSize(unsigned S) { ByValSize = S; }
d165 1
a165 1
    MVT VT = MVT::Other;
d167 1
a167 1
    bool Used = false;
d179 1
a179 1
    InputArg() = default;
d207 1
a207 1
    bool IsFixed = false;
d217 1
a217 1
    OutputArg() = default;
d226 1
d228 1
a228 2
} // end namespace ISD
} // end namespace llvm
@


