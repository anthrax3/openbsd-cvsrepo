head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.4
	OPENBSD_6_2:1.1.1.3.0.2
	OPENBSD_6_2_BASE:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.4
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.57;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.17;	author patrick;	state Exp;
branches;
next	1.1.1.4;
commitid	so2WA7LCP6wbxtYl;

1.1.1.4
date	2017.10.04.20.27.53;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- llvm/Target/TargetOptions.h - Target Options ------------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines command line option flags that are shared across various
// targets.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_TARGET_TARGETOPTIONS_H
#define LLVM_TARGET_TARGETOPTIONS_H

#include "llvm/Target/TargetRecip.h"
#include "llvm/MC/MCTargetOptions.h"
#include <string>

namespace llvm {
  class MachineFunction;
  class Module;
  class StringRef;

  namespace FloatABI {
    enum ABIType {
      Default, // Target-specific (either soft or hard depending on triple, etc).
      Soft,    // Soft float.
      Hard     // Hard float.
    };
  }

  namespace FPOpFusion {
    enum FPOpFusionMode {
      Fast,     // Enable fusion of FP ops wherever it's profitable.
      Standard, // Only allow fusion of 'blessed' ops (currently just fmuladd).
      Strict    // Never fuse FP-ops.
    };
  }

  namespace JumpTable {
    enum JumpTableType {
      Single,          // Use a single table for all indirect jumptable calls.
      Arity,           // Use one table per number of function parameters.
      Simplified,      // Use one table per function type, with types projected
                       // into 4 types: pointer to non-function, struct,
                       // primitive, and function pointer.
      Full             // Use one table per unique function type
    };
  }

  namespace ThreadModel {
    enum Model {
      POSIX,  // POSIX Threads
      Single  // Single Threaded Environment
    };
  }

  enum class EABI {
    Unknown,
    Default, // Default means not specified
    EABI4,   // Target-specific (either 4, 5 or gnu depending on triple).
    EABI5,
    GNU
  };

  /// Identify a debugger for "tuning" the debug info.
  ///
  /// The "debugger tuning" concept allows us to present a more intuitive
  /// interface that unpacks into different sets of defaults for the various
  /// individual feature-flag settings, that suit the preferences of the
  /// various debuggers.  However, it's worth remembering that debuggers are
  /// not the only consumers of debug info, and some variations in DWARF might
  /// better be treated as target/platform issues. Fundamentally,
  /// o if the feature is useful (or not) to a particular debugger, regardless
  ///   of the target, that's a tuning decision;
  /// o if the feature is useful (or not) on a particular platform, regardless
  ///   of the debugger, that's a target decision.
  /// It's not impossible to see both factors in some specific case.
  ///
  /// The "tuning" should be used to set defaults for individual feature flags
  /// in DwarfDebug; if a given feature has a more specific command-line option,
  /// that option should take precedence over the tuning.
  enum class DebuggerKind {
    Default,  // No specific tuning requested.
    GDB,      // Tune debug info for gdb.
    LLDB,     // Tune debug info for lldb.
    SCE       // Tune debug info for SCE targets (e.g. PS4).
  };

  class TargetOptions {
  public:
    TargetOptions()
        : PrintMachineCode(false), LessPreciseFPMADOption(false),
          UnsafeFPMath(false), NoInfsFPMath(false), NoNaNsFPMath(false),
          HonorSignDependentRoundingFPMathOption(false), NoZerosInBSS(false),
          GuaranteedTailCallOpt(false), StackAlignmentOverride(0),
          EnableFastISel(false), PositionIndependentExecutable(false),
          UseInitArray(false), DisableIntegratedAS(false),
          CompressDebugSections(false), FunctionSections(false),
          DataSections(false), UniqueSectionNames(true), TrapUnreachable(false),
          EmulatedTLS(false), FloatABIType(FloatABI::Default),
          AllowFPOpFusion(FPOpFusion::Standard), Reciprocals(TargetRecip()),
          JTType(JumpTable::Single), ThreadModel(ThreadModel::POSIX),
          EABIVersion(EABI::Default), DebuggerTuning(DebuggerKind::Default) {}

    /// PrintMachineCode - This flag is enabled when the -print-machineinstrs
    /// option is specified on the command line, and should enable debugging
    /// output from the code generator.
    unsigned PrintMachineCode : 1;

    /// DisableFramePointerElim - This returns true if frame pointer elimination
    /// optimization should be disabled for the given machine function.
    bool DisableFramePointerElim(const MachineFunction &MF) const;

    /// LessPreciseFPMAD - This flag is enabled when the
    /// -enable-fp-mad is specified on the command line.  When this flag is off
    /// (the default), the code generator is not allowed to generate mad
    /// (multiply add) if the result is "less precise" than doing those
    /// operations individually.
    unsigned LessPreciseFPMADOption : 1;
    bool LessPreciseFPMAD() const;

    /// UnsafeFPMath - This flag is enabled when the
    /// -enable-unsafe-fp-math flag is specified on the command line.  When
    /// this flag is off (the default), the code generator is not allowed to
    /// produce results that are "less precise" than IEEE allows.  This includes
    /// use of X86 instructions like FSIN and FCOS instead of libcalls.
    /// UnsafeFPMath implies LessPreciseFPMAD.
    unsigned UnsafeFPMath : 1;

    /// NoInfsFPMath - This flag is enabled when the
    /// -enable-no-infs-fp-math flag is specified on the command line. When
    /// this flag is off (the default), the code generator is not allowed to
    /// assume the FP arithmetic arguments and results are never +-Infs.
    unsigned NoInfsFPMath : 1;

    /// NoNaNsFPMath - This flag is enabled when the
    /// -enable-no-nans-fp-math flag is specified on the command line. When
    /// this flag is off (the default), the code generator is not allowed to
    /// assume the FP arithmetic arguments and results are never NaNs.
    unsigned NoNaNsFPMath : 1;

    /// HonorSignDependentRoundingFPMath - This returns true when the
    /// -enable-sign-dependent-rounding-fp-math is specified.  If this returns
    /// false (the default), the code generator is allowed to assume that the
    /// rounding behavior is the default (round-to-zero for all floating point
    /// to integer conversions, and round-to-nearest for all other arithmetic
    /// truncations).  If this is enabled (set to true), the code generator must
    /// assume that the rounding mode may dynamically change.
    unsigned HonorSignDependentRoundingFPMathOption : 1;
    bool HonorSignDependentRoundingFPMath() const;

    /// NoZerosInBSS - By default some codegens place zero-initialized data to
    /// .bss section. This flag disables such behaviour (necessary, e.g. for
    /// crt*.o compiling).
    unsigned NoZerosInBSS : 1;

    /// GuaranteedTailCallOpt - This flag is enabled when -tailcallopt is
    /// specified on the commandline. When the flag is on, participating targets
    /// will perform tail call optimization on all calls which use the fastcc
    /// calling convention and which satisfy certain target-independent
    /// criteria (being at the end of a function, having the same return type
    /// as their parent function, etc.), using an alternate ABI if necessary.
    unsigned GuaranteedTailCallOpt : 1;

    /// StackAlignmentOverride - Override default stack alignment for target.
    unsigned StackAlignmentOverride;

    /// EnableFastISel - This flag enables fast-path instruction selection
    /// which trades away generated code quality in favor of reducing
    /// compile time.
    unsigned EnableFastISel : 1;

    /// PositionIndependentExecutable - This flag indicates whether the code
    /// will eventually be linked into a single executable, despite the PIC
    /// relocation model being in use. It's value is undefined (and irrelevant)
    /// if the relocation model is anything other than PIC.
    unsigned PositionIndependentExecutable : 1;

    /// UseInitArray - Use .init_array instead of .ctors for static
    /// constructors.
    unsigned UseInitArray : 1;

    /// Disable the integrated assembler.
    unsigned DisableIntegratedAS : 1;

    /// Compress DWARF debug sections.
    unsigned CompressDebugSections : 1;

    /// Emit functions into separate sections.
    unsigned FunctionSections : 1;

    /// Emit data into separate sections.
    unsigned DataSections : 1;

    unsigned UniqueSectionNames : 1;

    /// Emit target-specific trap instruction for 'unreachable' IR instructions.
    unsigned TrapUnreachable : 1;

    /// EmulatedTLS - This flag enables emulated TLS model, using emutls
    /// function in the runtime library..
    unsigned EmulatedTLS : 1;

    /// FloatABIType - This setting is set by -float-abi=xxx option is specfied
    /// on the command line. This setting may either be Default, Soft, or Hard.
    /// Default selects the target's default behavior. Soft selects the ABI for
    /// software floating point, but does not indicate that FP hardware may not
    /// be used. Such a combination is unfortunately popular (e.g.
    /// arm-apple-darwin). Hard presumes that the normal FP ABI is used.
    FloatABI::ABIType FloatABIType;

    /// AllowFPOpFusion - This flag is set by the -fuse-fp-ops=xxx option.
    /// This controls the creation of fused FP ops that store intermediate
    /// results in higher precision than IEEE allows (E.g. FMAs).
    ///
    /// Fast mode - allows formation of fused FP ops whenever they're
    /// profitable.
    /// Standard mode - allow fusion only for 'blessed' FP ops. At present the
    /// only blessed op is the fmuladd intrinsic. In the future more blessed ops
    /// may be added.
    /// Strict mode - allow fusion only if/when it can be proven that the excess
    /// precision won't effect the result.
    ///
    /// Note: This option only controls formation of fused ops by the
    /// optimizers.  Fused operations that are explicitly specified (e.g. FMA
    /// via the llvm.fma.* intrinsic) will always be honored, regardless of
    /// the value of this option.
    FPOpFusion::FPOpFusionMode AllowFPOpFusion;

    /// This class encapsulates options for reciprocal-estimate code generation.
    TargetRecip Reciprocals;

    /// JTType - This flag specifies the type of jump-instruction table to
    /// create for functions that have the jumptable attribute.
    JumpTable::JumpTableType JTType;

    /// ThreadModel - This flag specifies the type of threading model to assume
    /// for things like atomics
    ThreadModel::Model ThreadModel;

    /// EABIVersion - This flag specifies the EABI version
    EABI EABIVersion;

    /// Which debugger to tune for.
    DebuggerKind DebuggerTuning;

    /// Machine level options.
    MCTargetOptions MCOptions;
  };

// Comparison operators:


inline bool operator==(const TargetOptions &LHS,
                       const TargetOptions &RHS) {
#define ARE_EQUAL(X) LHS.X == RHS.X
  return
    ARE_EQUAL(UnsafeFPMath) &&
    ARE_EQUAL(NoInfsFPMath) &&
    ARE_EQUAL(NoNaNsFPMath) &&
    ARE_EQUAL(HonorSignDependentRoundingFPMathOption) &&
    ARE_EQUAL(NoZerosInBSS) &&
    ARE_EQUAL(GuaranteedTailCallOpt) &&
    ARE_EQUAL(StackAlignmentOverride) &&
    ARE_EQUAL(EnableFastISel) &&
    ARE_EQUAL(PositionIndependentExecutable) &&
    ARE_EQUAL(UseInitArray) &&
    ARE_EQUAL(TrapUnreachable) &&
    ARE_EQUAL(EmulatedTLS) &&
    ARE_EQUAL(FloatABIType) &&
    ARE_EQUAL(AllowFPOpFusion) &&
    ARE_EQUAL(Reciprocals) &&
    ARE_EQUAL(JTType) &&
    ARE_EQUAL(ThreadModel) &&
    ARE_EQUAL(EABIVersion) &&
    ARE_EQUAL(DebuggerTuning) &&
    ARE_EQUAL(MCOptions);
#undef ARE_EQUAL
}

inline bool operator!=(const TargetOptions &LHS,
                       const TargetOptions &RHS) {
  return !(LHS == RHS);
}

} // End llvm namespace

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d20 1
a20 1
#include "llvm/MC/MCAsmInfo.h"
d25 1
d100 3
a102 3
          StackSymbolOrdering(true), EnableFastISel(false), UseInitArray(false),
          DisableIntegratedAS(false), CompressDebugSections(false),
          RelaxELFRelocations(false), FunctionSections(false),
d104 1
a104 2
          EmulatedTLS(false), EnableIPRA(false),
          FloatABIType(FloatABI::Default),
d107 1
a107 2
          EABIVersion(EABI::Default), DebuggerTuning(DebuggerKind::Default),
          ExceptionModel(ExceptionHandling::None) {}
a171 6
    /// StackSymbolOrdering - When true, this will allow CodeGen to order
    /// the local stack symbols (for code size, code locality, or any other
    /// heuristics). When false, the local symbols are left in whatever order
    /// they were generated. Default is true.
    unsigned StackSymbolOrdering : 1;

d177 6
a192 2
    unsigned RelaxELFRelocations : 1;

a207 3
    /// This flag enables InterProcedural Register Allocation (IPRA).
    unsigned EnableIPRA : 1;

a250 3
    /// What exception model to use
    ExceptionHandling ExceptionModel;

d270 1
d281 1
a281 3
    ARE_EQUAL(ExceptionModel) &&
    ARE_EQUAL(MCOptions) &&
    ARE_EQUAL(EnableIPRA);
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d18 1
d20 1
a59 9
  namespace FPDenormal {
    enum DenormalMode {
      IEEE,           // IEEE 754 denormal numbers
      PreserveSign,   // the sign of a flushed-to-zero number is preserved in
                      // the sign of 0
      PositiveZero    // denormals are flushed to positive zero
    };
  }

a96 1
          NoTrappingFPMath(false),
d105 2
a106 2
          AllowFPOpFusion(FPOpFusion::Standard),
          ThreadModel(ThreadModel::POSIX),
a107 1
          FPDenormalMode(FPDenormal::IEEE),
a146 5
    /// NoTrappingFPMath - This flag is enabled when the 
    /// -enable-no-trapping-fp-math is specified on the command line. This 
    /// specifies that there are no trap handlers to handle exceptions.
    unsigned NoTrappingFPMath : 1;

d240 7
a256 4
    /// FPDenormalMode - This flags specificies which denormal numbers the code
    /// is permitted to require.
    FPDenormal::DenormalMode FPDenormalMode;

a273 1
    ARE_EQUAL(NoTrappingFPMath) &&
d284 2
a288 1
    ARE_EQUAL(FPDenormalMode) &&
@


1.1.1.4
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@d102 3
a104 3
        : PrintMachineCode(false), UnsafeFPMath(false), NoInfsFPMath(false),
          NoNaNsFPMath(false), NoTrappingFPMath(false),
          NoSignedZerosFPMath(false),
d106 12
a117 6
          GuaranteedTailCallOpt(false), StackSymbolOrdering(true),
          EnableFastISel(false), UseInitArray(false),
          DisableIntegratedAS(false), RelaxELFRelocations(false),
          FunctionSections(false), DataSections(false),
          UniqueSectionNames(true), TrapUnreachable(false), EmulatedTLS(false),
          EnableIPRA(false) {}
d128 8
d141 1
d156 2
a157 2
    /// NoTrappingFPMath - This flag is enabled when the
    /// -enable-no-trapping-fp-math is specified on the command line. This
a160 6
    /// NoSignedZerosFPMath - This flag is enabled when the
    /// -enable-no-signed-zeros-fp-math is specified on the command line. This
    /// specifies that optimizations are allowed to treat the sign of a zero
    /// argument or result as insignificant.
    unsigned NoSignedZerosFPMath : 1;

d185 1
a185 1
    unsigned StackAlignmentOverride = 0;
d206 1
a206 1
    DebugCompressionType CompressDebugSections = DebugCompressionType::None;
d234 1
a234 1
    FloatABI::ABIType FloatABIType = FloatABI::Default;
d252 1
a252 1
    FPOpFusion::FPOpFusionMode AllowFPOpFusion = FPOpFusion::Standard;
d256 1
a256 1
    ThreadModel::Model ThreadModel = ThreadModel::POSIX;
d259 1
a259 1
    EABI EABIVersion = EABI::Default;
d262 1
a262 1
    DebuggerKind DebuggerTuning = DebuggerKind::Default;
d266 1
a266 1
    FPDenormal::DenormalMode FPDenormalMode = FPDenormal::IEEE;
d269 1
a269 1
    ExceptionHandling ExceptionModel = ExceptionHandling::None;
d274 36
@


