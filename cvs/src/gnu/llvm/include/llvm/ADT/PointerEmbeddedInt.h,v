head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.55;	author patrick;	state Exp;
branches;
next	;
commitid	qMUxATnKgqN83Oct;


desc
@@


1.1
log
@Initial revision
@
text
@//===- llvm/ADT/PointerEmbeddedInt.h ----------------------------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_ADT_POINTEREMBEDDEDINT_H
#define LLVM_ADT_POINTEREMBEDDEDINT_H

#include "llvm/ADT/DenseMapInfo.h"
#include "llvm/Support/PointerLikeTypeTraits.h"
#include <climits>

namespace llvm {

/// Utility to embed an integer into a pointer-like type. This is specifically
/// intended to allow embedding integers where fewer bits are required than
/// exist in a pointer, and the integer can participate in abstractions along
/// side other pointer-like types. For example it can be placed into a \c
/// PointerSumType or \c PointerUnion.
///
/// Note that much like pointers, an integer value of zero has special utility
/// due to boolean conversions. For example, a non-null value can be tested for
/// in the above abstractions without testing the particular active member.
/// Also, the default constructed value zero initializes the integer.
template <typename IntT, int Bits = sizeof(IntT) * CHAR_BIT>
class PointerEmbeddedInt {
  uintptr_t Value;

  static_assert(Bits < sizeof(uintptr_t) * CHAR_BIT,
                "Cannot embed more bits than we have in a pointer!");

  enum : uintptr_t {
    // We shift as many zeros into the value as we can while preserving the
    // number of bits desired for the integer.
    Shift = sizeof(uintptr_t) * CHAR_BIT - Bits,

    // We also want to be able to mask out the preserved bits for asserts.
    Mask = static_cast<uintptr_t>(-1) << Bits
  };

  friend class PointerLikeTypeTraits<PointerEmbeddedInt>;

  explicit PointerEmbeddedInt(uintptr_t Value) : Value(Value) {}

public:
  PointerEmbeddedInt() : Value(0) {}

  PointerEmbeddedInt(IntT I) : Value(static_cast<uintptr_t>(I) << Shift) {
    assert((I & Mask) == 0 && "Integer has bits outside those preserved!");
  }

  PointerEmbeddedInt &operator=(IntT I) {
    assert((I & Mask) == 0 && "Integer has bits outside those preserved!");
    Value = static_cast<uintptr_t>(I) << Shift;
  }

  // Note that this imilict conversion additionally allows all of the basic
  // comparison operators to work transparently, etc.
  operator IntT() const { return static_cast<IntT>(Value >> Shift); }
};

// Provide pointer like traits to support use with pointer unions and sum
// types.
template <typename IntT, int Bits>
class PointerLikeTypeTraits<PointerEmbeddedInt<IntT, Bits>> {
  typedef PointerEmbeddedInt<IntT, Bits> T;

public:
  static inline void *getAsVoidPointer(const T &P) {
    return reinterpret_cast<void *>(P.Value);
  }
  static inline T getFromVoidPointer(void *P) {
    return T(reinterpret_cast<uintptr_t>(P));
  }
  static inline T getFromVoidPointer(const void *P) {
    return T(reinterpret_cast<uintptr_t>(P));
  }

  enum { NumLowBitsAvailable = T::Shift };
};

// Teach DenseMap how to use PointerEmbeddedInt objects as keys if the Int type
// itself can be a key.
template <typename IntT, int Bits>
struct DenseMapInfo<PointerEmbeddedInt<IntT, Bits>> {
  typedef PointerEmbeddedInt<IntT, Bits> T;

  typedef DenseMapInfo<IntT> IntInfo;

  static inline T getEmptyKey() { return IntInfo::getEmptyKey(); }
  static inline T getTombstoneKey() { return IntInfo::getTombstoneKey(); }
  static unsigned getHashValue(const T &Arg) {
    return IntInfo::getHashValue(Arg);
  }
  static bool isEqual(const T &LHS, const T &RHS) { return LHS == RHS; }
};
}

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@a13 1
#include "llvm/Support/MathExtras.h"
a32 2
  // Note: This '<' is correct; using '<=' would result in some shifts
  // overflowing their storage types.
a44 4
  struct RawValueTag {
    explicit RawValueTag() = default;
  };

d47 1
a47 1
  explicit PointerEmbeddedInt(uintptr_t Value, RawValueTag) : Value(Value) {}
d52 2
a53 2
  PointerEmbeddedInt(IntT I) {
    *this = I;
d57 1
a57 3
    assert((std::is_signed<IntT>::value ? llvm::isInt<Bits>(I)
                                        : llvm::isUInt<Bits>(I)) &&
           "Integer has bits outside those preserved!");
a58 1
    return *this;
d61 1
a61 1
  // Note that this implicit conversion additionally allows all of the basic
d63 1
a63 5
  operator IntT() const {
    if (std::is_signed<IntT>::value)
      return static_cast<IntT>(static_cast<intptr_t>(Value) >> Shift);
    return static_cast<IntT>(Value >> Shift);
  }
d77 1
a77 1
    return T(reinterpret_cast<uintptr_t>(P), typename T::RawValueTag());
d80 1
a80 1
    return T(reinterpret_cast<uintptr_t>(P), typename T::RawValueTag());
@

