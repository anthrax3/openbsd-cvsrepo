head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.3.0.2
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.55;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.20;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- llvm/ADT/Statistic.h - Easy way to expose stats ---------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines the 'Statistic' class, which is designed to be an easy way
// to expose various metrics from passes.  These statistics are printed at the
// end of a run (from llvm_shutdown), when the -stats command line option is
// passed on the command line.
//
// This is useful for reporting information like the number of instructions
// simplified, optimized or removed by various transformations, like this:
//
// static Statistic NumInstsKilled("gcse", "Number of instructions killed");
//
// Later, in the code: ++NumInstsKilled;
//
// NOTE: Statistics *must* be declared as global variables.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_ADT_STATISTIC_H
#define LLVM_ADT_STATISTIC_H

#include "llvm/Support/Atomic.h"
#include "llvm/Support/Valgrind.h"
#include <memory>

namespace llvm {
class raw_ostream;
class raw_fd_ostream;

class Statistic {
public:
  const char *Name;
  const char *Desc;
  volatile llvm::sys::cas_flag Value;
  bool Initialized;

  llvm::sys::cas_flag getValue() const { return Value; }
  const char *getName() const { return Name; }
  const char *getDesc() const { return Desc; }

  /// construct - This should only be called for non-global statistics.
  void construct(const char *name, const char *desc) {
    Name = name; Desc = desc;
    Value = 0; Initialized = false;
  }

  // Allow use of this class as the value itself.
  operator unsigned() const { return Value; }

#if !defined(NDEBUG) || defined(LLVM_ENABLE_STATS)
   const Statistic &operator=(unsigned Val) {
    Value = Val;
    return init();
  }

  const Statistic &operator++() {
    // FIXME: This function and all those that follow carefully use an
    // atomic operation to update the value safely in the presence of
    // concurrent accesses, but not to read the return value, so the
    // return value is not thread safe.
    sys::AtomicIncrement(&Value);
    return init();
  }

  unsigned operator++(int) {
    init();
    unsigned OldValue = Value;
    sys::AtomicIncrement(&Value);
    return OldValue;
  }

  const Statistic &operator--() {
    sys::AtomicDecrement(&Value);
    return init();
  }

  unsigned operator--(int) {
    init();
    unsigned OldValue = Value;
    sys::AtomicDecrement(&Value);
    return OldValue;
  }

  const Statistic &operator+=(const unsigned &V) {
    if (!V) return *this;
    sys::AtomicAdd(&Value, V);
    return init();
  }

  const Statistic &operator-=(const unsigned &V) {
    if (!V) return *this;
    sys::AtomicAdd(&Value, -V);
    return init();
  }

  const Statistic &operator*=(const unsigned &V) {
    sys::AtomicMul(&Value, V);
    return init();
  }

  const Statistic &operator/=(const unsigned &V) {
    sys::AtomicDiv(&Value, V);
    return init();
  }

#else  // Statistics are disabled in release builds.

  const Statistic &operator=(unsigned Val) {
    return *this;
  }

  const Statistic &operator++() {
    return *this;
  }

  unsigned operator++(int) {
    return 0;
  }

  const Statistic &operator--() {
    return *this;
  }

  unsigned operator--(int) {
    return 0;
  }

  const Statistic &operator+=(const unsigned &V) {
    return *this;
  }

  const Statistic &operator-=(const unsigned &V) {
    return *this;
  }

  const Statistic &operator*=(const unsigned &V) {
    return *this;
  }

  const Statistic &operator/=(const unsigned &V) {
    return *this;
  }

#endif  // !defined(NDEBUG) || defined(LLVM_ENABLE_STATS)

protected:
  Statistic &init() {
    bool tmp = Initialized;
    sys::MemoryFence();
    if (!tmp) RegisterStatistic();
    TsanHappensAfter(this);
    return *this;
  }
  void RegisterStatistic();
};

// STATISTIC - A macro to make definition of statistics really simple.  This
// automatically passes the DEBUG_TYPE of the file into the statistic.
#define STATISTIC(VARNAME, DESC) \
  static llvm::Statistic VARNAME = { DEBUG_TYPE, DESC, 0, 0 }

/// \brief Enable the collection and printing of statistics.
void EnableStatistics();

/// \brief Check if statistics are enabled.
bool AreStatisticsEnabled();

/// \brief Return a file stream to print our output on.
std::unique_ptr<raw_fd_ostream> CreateInfoOutputFile();

/// \brief Print statistics to the file returned by CreateInfoOutputFile().
void PrintStatistics();

/// \brief Print statistics to the given output stream.
void PrintStatistics(raw_ostream &OS);

} // End llvm namespace

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d30 1
a30 2
#include "llvm/Support/Compiler.h"
#include <atomic>
a38 1
  const char *DebugType;
d41 1
a41 1
  std::atomic<unsigned> Value;
d44 1
a44 2
  unsigned getValue() const { return Value.load(std::memory_order_relaxed); }
  const char *getDebugType() const { return DebugType; }
d49 3
a51 6
  void construct(const char *debugtype, const char *name, const char *desc) {
    DebugType = debugtype;
    Name = name;
    Desc = desc;
    Value = 0;
    Initialized = false;
d55 1
a55 1
  operator unsigned() const { return getValue(); }
d59 1
a59 1
    Value.store(Val, std::memory_order_relaxed);
d64 5
a68 1
    Value.fetch_add(1, std::memory_order_relaxed);
d74 3
a76 1
    return Value.fetch_add(1, std::memory_order_relaxed);
d80 1
a80 1
    Value.fetch_sub(1, std::memory_order_relaxed);
d86 3
a88 1
    return Value.fetch_sub(1, std::memory_order_relaxed);
d91 14
a104 4
  const Statistic &operator+=(unsigned V) {
    if (V == 0)
      return *this;
    Value.fetch_add(V, std::memory_order_relaxed);
d108 2
a109 4
  const Statistic &operator-=(unsigned V) {
    if (V == 0)
      return *this;
    Value.fetch_sub(V, std::memory_order_relaxed);
d143 8
d166 2
a167 2
#define STATISTIC(VARNAME, DESC)                                               \
  static llvm::Statistic VARNAME = {DEBUG_TYPE, #VARNAME, DESC, {0}, 0}
d184 1
a184 4
/// Print statistics in JSON format.
void PrintStatisticsJSON(raw_ostream &OS);

} // end llvm namespace
d186 1
a186 1
#endif // LLVM_ADT_STATISTIC_H
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a34 1

a142 1

d149 1
a149 1
  static llvm::Statistic VARNAME = {DEBUG_TYPE, #VARNAME, DESC, {0}, false}
d152 1
a152 1
void EnableStatistics(bool PrintOnExit = true);
d166 1
a166 4
/// Print statistics in JSON format. This does include all global timers (\see
/// Timer, TimerGroup). Note that the timers are cleared after printing and will
/// not be printed in human readable form or in a second call of
/// PrintStatisticsJSON().
d169 1
a169 1
} // end namespace llvm
@


