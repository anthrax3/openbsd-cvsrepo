head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.2.0.6
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.24.08.33.20;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===--- StringSwitch.h - Switch-on-literal-string Construct --------------===/
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//===----------------------------------------------------------------------===/
//
//  This file implements the StringSwitch template, which mimics a switch()
//  statement whose cases are string literals.
//
//===----------------------------------------------------------------------===/
#ifndef LLVM_ADT_STRINGSWITCH_H
#define LLVM_ADT_STRINGSWITCH_H

#include "llvm/ADT/StringRef.h"
#include "llvm/Support/Compiler.h"
#include <cassert>
#include <cstring>

namespace llvm {

/// \brief A switch()-like statement whose cases are string literals.
///
/// The StringSwitch class is a simple form of a switch() statement that
/// determines whether the given string matches one of the given string
/// literals. The template type parameter \p T is the type of the value that
/// will be returned from the string-switch expression. For example,
/// the following code switches on the name of a color in \c argv[i]:
///
/// \code
/// Color color = StringSwitch<Color>(argv[i])
///   .Case("red", Red)
///   .Case("orange", Orange)
///   .Case("yellow", Yellow)
///   .Case("green", Green)
///   .Case("blue", Blue)
///   .Case("indigo", Indigo)
///   .Cases("violet", "purple", Violet)
///   .Default(UnknownColor);
/// \endcode
template<typename T, typename R = T>
class StringSwitch {
  /// \brief The string we are matching.
  StringRef Str;

  /// \brief The pointer to the result of this switch statement, once known,
  /// null before that.
  const T *Result;

public:
  LLVM_ATTRIBUTE_ALWAYS_INLINE
  explicit StringSwitch(StringRef S)
  : Str(S), Result(nullptr) { }

  template<unsigned N>
  LLVM_ATTRIBUTE_ALWAYS_INLINE
  StringSwitch& Case(const char (&S)[N], const T& Value) {
    if (!Result && N-1 == Str.size() &&
        (std::memcmp(S, Str.data(), N-1) == 0)) {
      Result = &Value;
    }

    return *this;
  }

  template<unsigned N>
  LLVM_ATTRIBUTE_ALWAYS_INLINE
  StringSwitch& EndsWith(const char (&S)[N], const T &Value) {
    if (!Result && Str.size() >= N-1 &&
        std::memcmp(S, Str.data() + Str.size() + 1 - N, N-1) == 0) {
      Result = &Value;
    }

    return *this;
  }

  template<unsigned N>
  LLVM_ATTRIBUTE_ALWAYS_INLINE
  StringSwitch& StartsWith(const char (&S)[N], const T &Value) {
    if (!Result && Str.size() >= N-1 &&
        std::memcmp(S, Str.data(), N-1) == 0) {
      Result = &Value;
    }

    return *this;
  }

  template<unsigned N0, unsigned N1>
  LLVM_ATTRIBUTE_ALWAYS_INLINE
  StringSwitch& Cases(const char (&S0)[N0], const char (&S1)[N1],
                      const T& Value) {
    if (!Result && (
        (N0-1 == Str.size() && std::memcmp(S0, Str.data(), N0-1) == 0) ||
        (N1-1 == Str.size() && std::memcmp(S1, Str.data(), N1-1) == 0))) {
      Result = &Value;
    }

    return *this;
  }

  template<unsigned N0, unsigned N1, unsigned N2>
  LLVM_ATTRIBUTE_ALWAYS_INLINE
  StringSwitch& Cases(const char (&S0)[N0], const char (&S1)[N1],
                      const char (&S2)[N2], const T& Value) {
    if (!Result && (
        (N0-1 == Str.size() && std::memcmp(S0, Str.data(), N0-1) == 0) ||
        (N1-1 == Str.size() && std::memcmp(S1, Str.data(), N1-1) == 0) ||
        (N2-1 == Str.size() && std::memcmp(S2, Str.data(), N2-1) == 0))) {
      Result = &Value;
    }

    return *this;
  }

  template<unsigned N0, unsigned N1, unsigned N2, unsigned N3>
  LLVM_ATTRIBUTE_ALWAYS_INLINE
  StringSwitch& Cases(const char (&S0)[N0], const char (&S1)[N1],
                      const char (&S2)[N2], const char (&S3)[N3],
                      const T& Value) {
    if (!Result && (
        (N0-1 == Str.size() && std::memcmp(S0, Str.data(), N0-1) == 0) ||
        (N1-1 == Str.size() && std::memcmp(S1, Str.data(), N1-1) == 0) ||
        (N2-1 == Str.size() && std::memcmp(S2, Str.data(), N2-1) == 0) ||
        (N3-1 == Str.size() && std::memcmp(S3, Str.data(), N3-1) == 0))) {
      Result = &Value;
    }

    return *this;
  }

  template<unsigned N0, unsigned N1, unsigned N2, unsigned N3, unsigned N4>
  LLVM_ATTRIBUTE_ALWAYS_INLINE
  StringSwitch& Cases(const char (&S0)[N0], const char (&S1)[N1],
                      const char (&S2)[N2], const char (&S3)[N3],
                      const char (&S4)[N4], const T& Value) {
    if (!Result && (
        (N0-1 == Str.size() && std::memcmp(S0, Str.data(), N0-1) == 0) ||
        (N1-1 == Str.size() && std::memcmp(S1, Str.data(), N1-1) == 0) ||
        (N2-1 == Str.size() && std::memcmp(S2, Str.data(), N2-1) == 0) ||
        (N3-1 == Str.size() && std::memcmp(S3, Str.data(), N3-1) == 0) ||
        (N4-1 == Str.size() && std::memcmp(S4, Str.data(), N4-1) == 0))) {
      Result = &Value;
    }

    return *this;
  }

  LLVM_ATTRIBUTE_ALWAYS_INLINE
  R Default(const T& Value) const {
    if (Result)
      return *Result;

    return Value;
  }

  LLVM_ATTRIBUTE_ALWAYS_INLINE
  operator R() const {
    assert(Result && "Fell off the end of a string-switch");
    return *Result;
  }
};

} // end namespace llvm

#endif // LLVM_ADT_STRINGSWITCH_H
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a55 16
  // StringSwitch is not copyable.
  StringSwitch(const StringSwitch &) = delete;
  void operator=(const StringSwitch &) = delete;

  StringSwitch(StringSwitch &&other) {
    *this = std::move(other);
  }
  StringSwitch &operator=(StringSwitch &&other) {
    Str = other.Str;
    Result = other.Result;
    return *this;
  }

  ~StringSwitch() = default;

  // Case-sensitive case matchers
a58 1
    assert(N);
d60 1
a60 1
        (N == 1 || std::memcmp(S, Str.data(), N-1) == 0)) {
d63 1
a69 1
    assert(N);
d71 1
a71 1
        (N == 1 || std::memcmp(S, Str.data() + Str.size() + 1 - N, N-1) == 0)) {
d74 1
a80 1
    assert(N);
d82 1
a82 1
        (N == 1 || std::memcmp(S, Str.data(), N-1) == 0)) {
d85 1
d91 1
a91 1
  StringSwitch &Cases(const char (&S0)[N0], const char (&S1)[N1],
d93 7
a99 1
    return Case(S0, Value).Case(S1, Value);
d104 1
a104 1
  StringSwitch &Cases(const char (&S0)[N0], const char (&S1)[N1],
d106 8
a113 1
    return Case(S0, Value).Cases(S1, S2, Value);
d118 1
a118 1
  StringSwitch &Cases(const char (&S0)[N0], const char (&S1)[N1],
d121 9
a129 1
    return Case(S0, Value).Cases(S1, S2, S3, Value);
d134 1
a134 1
  StringSwitch &Cases(const char (&S0)[N0], const char (&S1)[N1],
d137 6
a142 62
    return Case(S0, Value).Cases(S1, S2, S3, S4, Value);
  }

  template <unsigned N0, unsigned N1, unsigned N2, unsigned N3, unsigned N4,
            unsigned N5>
  LLVM_ATTRIBUTE_ALWAYS_INLINE
  StringSwitch &Cases(const char (&S0)[N0], const char (&S1)[N1],
                      const char (&S2)[N2], const char (&S3)[N3],
                      const char (&S4)[N4], const char (&S5)[N5],
                      const T &Value) {
    return Case(S0, Value).Cases(S1, S2, S3, S4, S5, Value);
  }

  template <unsigned N0, unsigned N1, unsigned N2, unsigned N3, unsigned N4,
            unsigned N5, unsigned N6>
  LLVM_ATTRIBUTE_ALWAYS_INLINE
  StringSwitch &Cases(const char (&S0)[N0], const char (&S1)[N1],
                      const char (&S2)[N2], const char (&S3)[N3],
                      const char (&S4)[N4], const char (&S5)[N5],
                      const char (&S6)[N6], const T &Value) {
    return Case(S0, Value).Cases(S1, S2, S3, S4, S5, S6, Value);
  }

  template <unsigned N0, unsigned N1, unsigned N2, unsigned N3, unsigned N4,
            unsigned N5, unsigned N6, unsigned N7>
  LLVM_ATTRIBUTE_ALWAYS_INLINE
  StringSwitch &Cases(const char (&S0)[N0], const char (&S1)[N1],
                      const char (&S2)[N2], const char (&S3)[N3],
                      const char (&S4)[N4], const char (&S5)[N5],
                      const char (&S6)[N6], const char (&S7)[N7],
                      const T &Value) {
    return Case(S0, Value).Cases(S1, S2, S3, S4, S5, S6, S7, Value);
  }

  template <unsigned N0, unsigned N1, unsigned N2, unsigned N3, unsigned N4,
            unsigned N5, unsigned N6, unsigned N7, unsigned N8>
  LLVM_ATTRIBUTE_ALWAYS_INLINE
  StringSwitch &Cases(const char (&S0)[N0], const char (&S1)[N1],
                      const char (&S2)[N2], const char (&S3)[N3],
                      const char (&S4)[N4], const char (&S5)[N5],
                      const char (&S6)[N6], const char (&S7)[N7],
                      const char (&S8)[N8], const T &Value) {
    return Case(S0, Value).Cases(S1, S2, S3, S4, S5, S6, S7, S8, Value);
  }

  template <unsigned N0, unsigned N1, unsigned N2, unsigned N3, unsigned N4,
            unsigned N5, unsigned N6, unsigned N7, unsigned N8, unsigned N9>
  LLVM_ATTRIBUTE_ALWAYS_INLINE
  StringSwitch &Cases(const char (&S0)[N0], const char (&S1)[N1],
                      const char (&S2)[N2], const char (&S3)[N3],
                      const char (&S4)[N4], const char (&S5)[N5],
                      const char (&S6)[N6], const char (&S7)[N7],
                      const char (&S8)[N8], const char (&S9)[N9],
                      const T &Value) {
    return Case(S0, Value).Cases(S1, S2, S3, S4, S5, S6, S7, S8, S9, Value);
  }

  // Case-insensitive case matchers.
  template <unsigned N>
  LLVM_ATTRIBUTE_ALWAYS_INLINE StringSwitch &CaseLower(const char (&S)[N],
                                                       const T &Value) {
    if (!Result && Str.equals_lower(StringRef(S, N - 1)))
d144 1
a148 44
  template <unsigned N>
  LLVM_ATTRIBUTE_ALWAYS_INLINE StringSwitch &EndsWithLower(const char (&S)[N],
                                                           const T &Value) {
    if (!Result && Str.endswith_lower(StringRef(S, N - 1)))
      Result = &Value;

    return *this;
  }

  template <unsigned N>
  LLVM_ATTRIBUTE_ALWAYS_INLINE StringSwitch &StartsWithLower(const char (&S)[N],
                                                             const T &Value) {
    if (!Result && Str.startswith_lower(StringRef(S, N - 1)))
      Result = &Value;

    return *this;
  }
  template <unsigned N0, unsigned N1>
  LLVM_ATTRIBUTE_ALWAYS_INLINE StringSwitch &
  CasesLower(const char (&S0)[N0], const char (&S1)[N1], const T &Value) {
    return CaseLower(S0, Value).CaseLower(S1, Value);
  }

  template <unsigned N0, unsigned N1, unsigned N2>
  LLVM_ATTRIBUTE_ALWAYS_INLINE StringSwitch &
  CasesLower(const char (&S0)[N0], const char (&S1)[N1], const char (&S2)[N2],
             const T &Value) {
    return CaseLower(S0, Value).CasesLower(S1, S2, Value);
  }

  template <unsigned N0, unsigned N1, unsigned N2, unsigned N3>
  LLVM_ATTRIBUTE_ALWAYS_INLINE StringSwitch &
  CasesLower(const char (&S0)[N0], const char (&S1)[N1], const char (&S2)[N2],
             const char (&S3)[N3], const T &Value) {
    return CaseLower(S0, Value).CasesLower(S1, S2, S3, Value);
  }

  template <unsigned N0, unsigned N1, unsigned N2, unsigned N3, unsigned N4>
  LLVM_ATTRIBUTE_ALWAYS_INLINE StringSwitch &
  CasesLower(const char (&S0)[N0], const char (&S1)[N1], const char (&S2)[N2],
             const char (&S3)[N3], const char (&S4)[N4], const T &Value) {
    return CaseLower(S0, Value).CasesLower(S1, S2, S3, S4, Value);
  }

d150 1
a150 1
  R Default(const T &Value) const {
d153 1
@

