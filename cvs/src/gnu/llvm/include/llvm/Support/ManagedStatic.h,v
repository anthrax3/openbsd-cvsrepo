head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.57;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.19;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- llvm/Support/ManagedStatic.h - Static Global wrapper ----*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines the ManagedStatic class and the llvm_shutdown() function.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_SUPPORT_MANAGEDSTATIC_H
#define LLVM_SUPPORT_MANAGEDSTATIC_H

#include "llvm/Support/Atomic.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/Threading.h"

namespace llvm {

/// object_creator - Helper method for ManagedStatic.
template<class C>
void* object_creator() {
  return new C();
}

/// object_deleter - Helper method for ManagedStatic.
///
template<typename T> struct object_deleter {
  static void call(void * Ptr) { delete (T*)Ptr; }
};
template<typename T, size_t N> struct object_deleter<T[N]> {
  static void call(void * Ptr) { delete[] (T*)Ptr; }
};

/// ManagedStaticBase - Common base class for ManagedStatic instances.
class ManagedStaticBase {
protected:
  // This should only be used as a static variable, which guarantees that this
  // will be zero initialized.
  mutable void *Ptr;
  mutable void (*DeleterFn)(void*);
  mutable const ManagedStaticBase *Next;

  void RegisterManagedStatic(void *(*creator)(), void (*deleter)(void*)) const;
public:
  /// isConstructed - Return true if this object has not been created yet.
  bool isConstructed() const { return Ptr != nullptr; }

  void destroy() const;
};

/// ManagedStatic - This transparently changes the behavior of global statics to
/// be lazily constructed on demand (good for reducing startup times of dynamic
/// libraries that link in LLVM components) and for making destruction be
/// explicit through the llvm_shutdown() function call.
///
template<class C>
class ManagedStatic : public ManagedStaticBase {
public:

  // Accessors.
  C &operator*() {
    void* tmp = Ptr;
    if (llvm_is_multithreaded()) sys::MemoryFence();
    if (!tmp) RegisterManagedStatic(object_creator<C>, object_deleter<C>::call);
    TsanHappensAfter(this);

    return *static_cast<C*>(Ptr);
  }
  C *operator->() {
    void* tmp = Ptr;
    if (llvm_is_multithreaded()) sys::MemoryFence();
    if (!tmp) RegisterManagedStatic(object_creator<C>, object_deleter<C>::call);
    TsanHappensAfter(this);

    return static_cast<C*>(Ptr);
  }
  const C &operator*() const {
    void* tmp = Ptr;
    if (llvm_is_multithreaded()) sys::MemoryFence();
    if (!tmp) RegisterManagedStatic(object_creator<C>, object_deleter<C>::call);
    TsanHappensAfter(this);

    return *static_cast<C*>(Ptr);
  }
  const C *operator->() const {
    void* tmp = Ptr;
    if (llvm_is_multithreaded()) sys::MemoryFence();
    if (!tmp) RegisterManagedStatic(object_creator<C>, object_deleter<C>::call);
    TsanHappensAfter(this);

    return static_cast<C*>(Ptr);
  }
};

/// llvm_shutdown - Deallocate and destroy all ManagedStatic variables.
void llvm_shutdown();

/// llvm_shutdown_obj - This is a simple helper class that calls
/// llvm_shutdown() when it is destroyed.
struct llvm_shutdown_obj {
  llvm_shutdown_obj() { }
  ~llvm_shutdown_obj() { llvm_shutdown(); }
};

}

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d17 1
d19 1
a19 2
#include <atomic>
#include <cstddef>
d25 1
a25 1
LLVM_LIBRARY_VISIBILITY void* object_creator() {
d31 2
a32 2
template <typename T> struct LLVM_LIBRARY_VISIBILITY object_deleter {
  static void call(void *Ptr) { delete (T *)Ptr; }
d34 2
a35 3
template <typename T, size_t N>
struct LLVM_LIBRARY_VISIBILITY object_deleter<T[N]> {
  static void call(void *Ptr) { delete[](T *)Ptr; }
d43 1
a43 1
  mutable std::atomic<void *> Ptr;
d63 1
d66 4
a69 3
    void *Tmp = Ptr.load(std::memory_order_acquire);
    if (!Tmp)
      RegisterManagedStatic(object_creator<C>, object_deleter<C>::call);
d71 1
a71 1
    return *static_cast<C *>(Ptr.load(std::memory_order_relaxed));
d73 5
d79 2
a80 2
  C *operator->() { return &**this; }

d82 4
a85 3
    void *Tmp = Ptr.load(std::memory_order_acquire);
    if (!Tmp)
      RegisterManagedStatic(object_creator<C>, object_deleter<C>::call);
d87 1
a87 1
    return *static_cast<C *>(Ptr.load(std::memory_order_relaxed));
d89 5
d95 2
a96 1
  const C *operator->() const { return &**this; }
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a48 1

d92 1
a92 1
  llvm_shutdown_obj() = default;
d96 1
a96 1
} // end namespace llvm
d98 1
a98 1
#endif // LLVM_SUPPORT_MANAGEDSTATIC_H
@


