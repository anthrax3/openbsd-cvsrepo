head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.4
	OPENBSD_6_2:1.1.1.3.0.2
	OPENBSD_6_2_BASE:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.4
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.56;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.17;	author patrick;	state Exp;
branches;
next	1.1.1.4;
commitid	so2WA7LCP6wbxtYl;

1.1.1.4
date	2017.10.04.20.27.53;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- RelocVisitor.h - Visitor for object file relocations -*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file provides a wrapper around all the different types of relocations
// in different file formats, such that a client can handle them in a unified
// manner by only implementing a minimal number of functions.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_OBJECT_RELOCVISITOR_H
#define LLVM_OBJECT_RELOCVISITOR_H

#include "llvm/ADT/StringRef.h"
#include "llvm/Object/COFF.h"
#include "llvm/Object/ELFObjectFile.h"
#include "llvm/Object/MachO.h"
#include "llvm/Object/ObjectFile.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ELF.h"
#include "llvm/Support/MachO.h"
#include "llvm/Support/raw_ostream.h"

namespace llvm {
namespace object {

struct RelocToApply {
  // The computed value after applying the relevant relocations.
  int64_t Value;

  // The width of the value; how many bytes to touch when applying the
  // relocation.
  char Width;
  RelocToApply(int64_t Value, char Width) : Value(Value), Width(Width) {}
  RelocToApply() : Value(0), Width(0) {}
};

/// @@brief Base class for object file relocation visitors.
class RelocVisitor {
public:
  explicit RelocVisitor(const ObjectFile &Obj)
    : ObjToVisit(Obj), HasError(false) {}

  // TODO: Should handle multiple applied relocations via either passing in the
  // previously computed value or just count paired relocations as a single
  // visit.
  RelocToApply visit(uint32_t RelocType, RelocationRef R, uint64_t Value = 0) {
    if (isa<ELFObjectFileBase>(ObjToVisit))
      return visitELF(RelocType, R, Value);
    if (isa<COFFObjectFile>(ObjToVisit))
      return visitCOFF(RelocType, R, Value);
    if (isa<MachOObjectFile>(ObjToVisit))
      return visitMachO(RelocType, R, Value);

    HasError = true;
    return RelocToApply();
  }

  bool error() { return HasError; }

private:
  const ObjectFile &ObjToVisit;
  bool HasError;

  RelocToApply visitELF(uint32_t RelocType, RelocationRef R, uint64_t Value) {
    if (ObjToVisit.getBytesInAddress() == 8) { // 64-bit object file
      switch (ObjToVisit.getArch()) {
      case Triple::x86_64:
        switch (RelocType) {
        case llvm::ELF::R_X86_64_NONE:
          return visitELF_X86_64_NONE(R);
        case llvm::ELF::R_X86_64_64:
          return visitELF_X86_64_64(R, Value);
        case llvm::ELF::R_X86_64_PC32:
          return visitELF_X86_64_PC32(R, Value);
        case llvm::ELF::R_X86_64_32:
          return visitELF_X86_64_32(R, Value);
        case llvm::ELF::R_X86_64_32S:
          return visitELF_X86_64_32S(R, Value);
        default:
          HasError = true;
          return RelocToApply();
        }
      case Triple::aarch64:
        switch (RelocType) {
        case llvm::ELF::R_AARCH64_ABS32:
          return visitELF_AARCH64_ABS32(R, Value);
        case llvm::ELF::R_AARCH64_ABS64:
          return visitELF_AARCH64_ABS64(R, Value);
        default:
          HasError = true;
          return RelocToApply();
        }
      case Triple::mips64el:
      case Triple::mips64:
        switch (RelocType) {
        case llvm::ELF::R_MIPS_32:
          return visitELF_MIPS64_32(R, Value);
        case llvm::ELF::R_MIPS_64:
          return visitELF_MIPS64_64(R, Value);
        default:
          HasError = true;
          return RelocToApply();
        }
      case Triple::ppc64le:
      case Triple::ppc64:
        switch (RelocType) {
        case llvm::ELF::R_PPC64_ADDR32:
          return visitELF_PPC64_ADDR32(R, Value);
        case llvm::ELF::R_PPC64_ADDR64:
          return visitELF_PPC64_ADDR64(R, Value);
        default:
          HasError = true;
          return RelocToApply();
        }
      case Triple::systemz:
        switch (RelocType) {
        case llvm::ELF::R_390_32:
          return visitELF_390_32(R, Value);
        case llvm::ELF::R_390_64:
          return visitELF_390_64(R, Value);
        default:
          HasError = true;
          return RelocToApply();
        }
      case Triple::sparcv9:
        switch (RelocType) {
        case llvm::ELF::R_SPARC_32:
        case llvm::ELF::R_SPARC_UA32:
          return visitELF_SPARCV9_32(R, Value);
        case llvm::ELF::R_SPARC_64:
        case llvm::ELF::R_SPARC_UA64:
          return visitELF_SPARCV9_64(R, Value);
        default:
          HasError = true;
          return RelocToApply();
        }
      default:
        HasError = true;
        return RelocToApply();
      }
    } else if (ObjToVisit.getBytesInAddress() == 4) { // 32-bit object file
      switch (ObjToVisit.getArch()) {
      case Triple::x86:
        switch (RelocType) {
        case llvm::ELF::R_386_NONE:
          return visitELF_386_NONE(R);
        case llvm::ELF::R_386_32:
          return visitELF_386_32(R, Value);
        case llvm::ELF::R_386_PC32:
          return visitELF_386_PC32(R, Value);
        default:
          HasError = true;
          return RelocToApply();
        }
      case Triple::ppc:
        switch (RelocType) {
        case llvm::ELF::R_PPC_ADDR32:
          return visitELF_PPC_ADDR32(R, Value);
        default:
          HasError = true;
          return RelocToApply();
        }
      case Triple::arm:
      case Triple::armeb:
        switch (RelocType) {
        default:
          HasError = true;
          return RelocToApply();
        case llvm::ELF::R_ARM_ABS32:
          return visitELF_ARM_ABS32(R, Value);
        }
      case Triple::mipsel:
      case Triple::mips:
        switch (RelocType) {
        case llvm::ELF::R_MIPS_32:
          return visitELF_MIPS_32(R, Value);
        default:
          HasError = true;
          return RelocToApply();
        }
      case Triple::sparc:
        switch (RelocType) {
        case llvm::ELF::R_SPARC_32:
        case llvm::ELF::R_SPARC_UA32:
          return visitELF_SPARC_32(R, Value);
        default:
          HasError = true;
          return RelocToApply();
        }
      default:
        HasError = true;
        return RelocToApply();
      }
    } else {
      report_fatal_error("Invalid word size in object file");
    }
  }

  RelocToApply visitCOFF(uint32_t RelocType, RelocationRef R, uint64_t Value) {
    switch (ObjToVisit.getArch()) {
    case Triple::x86:
      switch (RelocType) {
      case COFF::IMAGE_REL_I386_SECREL:
        return visitCOFF_I386_SECREL(R, Value);
      case COFF::IMAGE_REL_I386_DIR32:
        return visitCOFF_I386_DIR32(R, Value);
      }
      break;
    case Triple::x86_64:
      switch (RelocType) {
      case COFF::IMAGE_REL_AMD64_SECREL:
        return visitCOFF_AMD64_SECREL(R, Value);
      case COFF::IMAGE_REL_AMD64_ADDR64:
        return visitCOFF_AMD64_ADDR64(R, Value);
      }
      break;
    }
    HasError = true;
    return RelocToApply();
  }

  RelocToApply visitMachO(uint32_t RelocType, RelocationRef R, uint64_t Value) {
    switch (ObjToVisit.getArch()) {
    default: break;
    case Triple::x86_64:
      switch (RelocType) {
        default: break;
        case MachO::X86_64_RELOC_UNSIGNED:
          return visitMACHO_X86_64_UNSIGNED(R, Value);
      }
    }
    HasError = true;
    return RelocToApply();
  }

  int64_t getELFAddend(RelocationRef R) {
    ErrorOr<int64_t> AddendOrErr = ELFRelocationRef(R).getAddend();
    if (std::error_code EC = AddendOrErr.getError())
      report_fatal_error(EC.message());
    return *AddendOrErr;
  }

  uint8_t getLengthMachO64(RelocationRef R) {
    const MachOObjectFile *Obj = cast<MachOObjectFile>(R.getObject());
    return Obj->getRelocationLength(R.getRawDataRefImpl());
  }

  /// Operations

  /// 386-ELF
  RelocToApply visitELF_386_NONE(RelocationRef R) {
    return RelocToApply(0, 0);
  }

  // Ideally the Addend here will be the addend in the data for
  // the relocation. It's not actually the case for Rel relocations.
  RelocToApply visitELF_386_32(RelocationRef R, uint64_t Value) {
    return RelocToApply(Value, 4);
  }

  RelocToApply visitELF_386_PC32(RelocationRef R, uint64_t Value) {
    uint64_t Address = R.getOffset();
    return RelocToApply(Value - Address, 4);
  }

  /// X86-64 ELF
  RelocToApply visitELF_X86_64_NONE(RelocationRef R) {
    return RelocToApply(0, 0);
  }
  RelocToApply visitELF_X86_64_64(RelocationRef R, uint64_t Value) {
    int64_t Addend = getELFAddend(R);
    return RelocToApply(Value + Addend, 8);
  }
  RelocToApply visitELF_X86_64_PC32(RelocationRef R, uint64_t Value) {
    int64_t Addend = getELFAddend(R);
    uint64_t Address = R.getOffset();
    return RelocToApply(Value + Addend - Address, 4);
  }
  RelocToApply visitELF_X86_64_32(RelocationRef R, uint64_t Value) {
    int64_t Addend = getELFAddend(R);
    uint32_t Res = (Value + Addend) & 0xFFFFFFFF;
    return RelocToApply(Res, 4);
  }
  RelocToApply visitELF_X86_64_32S(RelocationRef R, uint64_t Value) {
    int64_t Addend = getELFAddend(R);
    int32_t Res = (Value + Addend) & 0xFFFFFFFF;
    return RelocToApply(Res, 4);
  }

  /// PPC64 ELF
  RelocToApply visitELF_PPC64_ADDR32(RelocationRef R, uint64_t Value) {
    int64_t Addend = getELFAddend(R);
    uint32_t Res = (Value + Addend) & 0xFFFFFFFF;
    return RelocToApply(Res, 4);
  }
  RelocToApply visitELF_PPC64_ADDR64(RelocationRef R, uint64_t Value) {
    int64_t Addend = getELFAddend(R);
    return RelocToApply(Value + Addend, 8);
  }

  /// PPC32 ELF
  RelocToApply visitELF_PPC_ADDR32(RelocationRef R, uint64_t Value) {
    int64_t Addend = getELFAddend(R);
    uint32_t Res = (Value + Addend) & 0xFFFFFFFF;
    return RelocToApply(Res, 4);
  }

  /// MIPS ELF
  RelocToApply visitELF_MIPS_32(RelocationRef R, uint64_t Value) {
    uint32_t Res = Value & 0xFFFFFFFF;
    return RelocToApply(Res, 4);
  }

  /// MIPS64 ELF
  RelocToApply visitELF_MIPS64_32(RelocationRef R, uint64_t Value) {
    int64_t Addend = getELFAddend(R);
    uint32_t Res = (Value + Addend) & 0xFFFFFFFF;
    return RelocToApply(Res, 4);
  }

  RelocToApply visitELF_MIPS64_64(RelocationRef R, uint64_t Value) {
    int64_t Addend = getELFAddend(R);
    uint64_t Res = (Value + Addend);
    return RelocToApply(Res, 8);
  }

  // AArch64 ELF
  RelocToApply visitELF_AARCH64_ABS32(RelocationRef R, uint64_t Value) {
    int64_t Addend = getELFAddend(R);
    int64_t Res =  Value + Addend;

    // Overflow check allows for both signed and unsigned interpretation.
    if (Res < INT32_MIN || Res > UINT32_MAX)
      HasError = true;

    return RelocToApply(static_cast<uint32_t>(Res), 4);
  }

  RelocToApply visitELF_AARCH64_ABS64(RelocationRef R, uint64_t Value) {
    int64_t Addend = getELFAddend(R);
    return RelocToApply(Value + Addend, 8);
  }

  // SystemZ ELF
  RelocToApply visitELF_390_32(RelocationRef R, uint64_t Value) {
    int64_t Addend = getELFAddend(R);
    int64_t Res = Value + Addend;

    // Overflow check allows for both signed and unsigned interpretation.
    if (Res < INT32_MIN || Res > UINT32_MAX)
      HasError = true;

    return RelocToApply(static_cast<uint32_t>(Res), 4);
  }

  RelocToApply visitELF_390_64(RelocationRef R, uint64_t Value) {
    int64_t Addend = getELFAddend(R);
    return RelocToApply(Value + Addend, 8);
  }

  RelocToApply visitELF_SPARC_32(RelocationRef R, uint32_t Value) {
    int32_t Addend = getELFAddend(R);
    return RelocToApply(Value + Addend, 4);
  }

  RelocToApply visitELF_SPARCV9_32(RelocationRef R, uint64_t Value) {
    int32_t Addend = getELFAddend(R);
    return RelocToApply(Value + Addend, 4);
  }

  RelocToApply visitELF_SPARCV9_64(RelocationRef R, uint64_t Value) {
    int64_t Addend = getELFAddend(R);
    return RelocToApply(Value + Addend, 8);
  }

  RelocToApply visitELF_ARM_ABS32(RelocationRef R, uint64_t Value) {
    int64_t Res = Value;

    // Overflow check allows for both signed and unsigned interpretation.
    if (Res < INT32_MIN || Res > UINT32_MAX)
      HasError = true;

    return RelocToApply(static_cast<uint32_t>(Res), 4);
  }

  /// I386 COFF
  RelocToApply visitCOFF_I386_SECREL(RelocationRef R, uint64_t Value) {
    return RelocToApply(static_cast<uint32_t>(Value), /*Width=*/4);
  }

  RelocToApply visitCOFF_I386_DIR32(RelocationRef R, uint64_t Value) {
    return RelocToApply(static_cast<uint32_t>(Value), /*Width=*/4);
  }

  /// AMD64 COFF
  RelocToApply visitCOFF_AMD64_SECREL(RelocationRef R, uint64_t Value) {
    return RelocToApply(static_cast<uint32_t>(Value), /*Width=*/4);
  }

  RelocToApply visitCOFF_AMD64_ADDR64(RelocationRef R, uint64_t Value) {
    return RelocToApply(Value, /*Width=*/8);
  }

  // X86_64 MachO
  RelocToApply visitMACHO_X86_64_UNSIGNED(RelocationRef R, uint64_t Value) {
    uint8_t Length = getLengthMachO64(R);
    Length = 1<<Length;
    return RelocToApply(Value, Length);
  }
};

}
}
#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d19 1
a177 8
      case Triple::lanai:
        switch (RelocType) {
        case llvm::ELF::R_LANAI_32:
          return visitELF_Lanai_32(R, Value);
        default:
          HasError = true;
          return RelocToApply();
        }
a308 7
    int64_t Addend = getELFAddend(R);
    uint32_t Res = (Value + Addend) & 0xFFFFFFFF;
    return RelocToApply(Res, 4);
  }

  /// Lanai ELF
  RelocToApply visitELF_Lanai_32(RelocationRef R, uint64_t Value) {
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a88 1
      case Triple::aarch64_be:
a97 11
      case Triple::bpfel:
      case Triple::bpfeb:
        switch (RelocType) {
        case llvm::ELF::R_BPF_64_64:
          return visitELF_BPF_64_64(R, Value);
        case llvm::ELF::R_BPF_64_32:
          return visitELF_BPF_64_32(R, Value);
        default:
          HasError = true;
          return RelocToApply();
        }
a141 8
      case Triple::amdgcn:
        switch (RelocType) {
        case llvm::ELF::R_AMDGPU_ABS32:
          return visitELF_AMDGPU_ABS32(R, Value);
        default:
          HasError = true;
          return RelocToApply();
        }
a202 8
      case Triple::hexagon:
        switch (RelocType) {
        case llvm::ELF::R_HEX_32:
          return visitELF_HEX_32(R, Value);
        default:
          HasError = true;
          return RelocToApply();
        }
a302 9
  /// BPF ELF
  RelocToApply visitELF_BPF_64_32(RelocationRef R, uint64_t Value) {
    uint32_t Res = Value & 0xFFFFFFFF;
    return RelocToApply(Res, 4);
  }
  RelocToApply visitELF_BPF_64_64(RelocationRef R, uint64_t Value) {
    return RelocToApply(Value, 8);
  }

a403 10
  }

  RelocToApply visitELF_HEX_32(RelocationRef R, uint64_t Value) {
    int64_t Addend = getELFAddend(R);
    return RelocToApply(Value + Addend, 4);
  }

  RelocToApply visitELF_AMDGPU_ABS32(RelocationRef R, uint64_t Value) {
    int64_t Addend = getELFAddend(R);
    return RelocToApply(Value + Addend, 4);
@


1.1.1.4
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@d1 1
a1 1
//===- RelocVisitor.h - Visitor for object file relocations -----*- C++ -*-===//
a18 3
#include "llvm/ADT/Triple.h"
#include "llvm/BinaryFormat/ELF.h"
#include "llvm/BinaryFormat/MachO.h"
d23 4
a26 5
#include "llvm/Support/Casting.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/ErrorOr.h"
#include <cstdint>
#include <system_error>
d31 11
d45 2
a46 1
  explicit RelocVisitor(const ObjectFile &Obj) : ObjToVisit(Obj) {}
d51 1
a51 1
  uint64_t visit(uint32_t Rel, RelocationRef R, uint64_t Value = 0) {
d53 1
a53 1
      return visitELF(Rel, R, Value);
d55 1
a55 1
      return visitCOFF(Rel, R, Value);
d57 1
a57 1
      return visitMachO(Rel, R, Value);
d60 1
a60 1
    return 0;
d67 1
a67 1
  bool HasError = false;
d69 1
a69 1
  uint64_t visitELF(uint32_t Rel, RelocationRef R, uint64_t Value) {
d73 15
a87 1
        return visitX86_64(Rel, R, Value);
d90 9
a98 1
        return visitAarch64(Rel, R, Value);
d101 9
a109 1
        return visitBpf(Rel, R, Value);
d112 9
a120 1
        return visitMips64(Rel, R, Value);
d123 9
a131 1
        return visitPPC64(Rel, R, Value);
d133 9
a141 1
        return visitSystemz(Rel, R, Value);
d143 11
a153 1
        return visitSparc64(Rel, R, Value);
d155 7
a161 1
        return visitAmdgpu(Rel, R, Value);
d164 1
a164 1
        return 0;
d166 71
d238 1
d240 22
a261 3
    // 32-bit object file
    assert(ObjToVisit.getBytesInAddress() == 4 &&
           "Invalid word size in object file");
d263 1
d265 7
a271 19
    case Triple::x86:
      return visitX86(Rel, R, Value);
    case Triple::ppc:
      return visitPPC32(Rel, R, Value);
    case Triple::arm:
    case Triple::armeb:
      return visitARM(Rel, R, Value);
    case Triple::lanai:
      return visitLanai(Rel, R, Value);
    case Triple::mipsel:
    case Triple::mips:
      return visitMips32(Rel, R, Value);
    case Triple::sparc:
      return visitSparc32(Rel, R, Value);
    case Triple::hexagon:
      return visitHexagon(Rel, R, Value);
    default:
      HasError = true;
      return 0;
d273 2
d284 92
a375 14
  uint64_t visitX86_64(uint32_t Rel, RelocationRef R, uint64_t Value) {
    switch (Rel) {
    case ELF::R_X86_64_NONE:
      return 0;
    case ELF::R_X86_64_64:
      return Value + getELFAddend(R);
    case ELF::R_X86_64_PC32:
      return Value + getELFAddend(R) - R.getOffset();
    case ELF::R_X86_64_32:
    case ELF::R_X86_64_32S:
      return (Value + getELFAddend(R)) & 0xFFFFFFFF;
    }
    HasError = true;
    return 0;
d378 4
a381 13
  uint64_t visitAarch64(uint32_t Rel, RelocationRef R, uint64_t Value) {
    switch (Rel) {
    case ELF::R_AARCH64_ABS32: {
      int64_t Res = Value + getELFAddend(R);
      if (Res < INT32_MIN || Res > UINT32_MAX)
        HasError = true;
      return static_cast<uint32_t>(Res);
    }
    case ELF::R_AARCH64_ABS64:
      return Value + getELFAddend(R);
    }
    HasError = true;
    return 0;
d384 10
a393 9
  uint64_t visitBpf(uint32_t Rel, RelocationRef R, uint64_t Value) {
    switch (Rel) {
    case ELF::R_BPF_64_32:
      return Value & 0xFFFFFFFF;
    case ELF::R_BPF_64_64:
      return Value;
    }
    HasError = true;
    return 0;
d396 3
a398 9
  uint64_t visitMips64(uint32_t Rel, RelocationRef R, uint64_t Value) {
    switch (Rel) {
    case ELF::R_MIPS_32:
      return (Value + getELFAddend(R)) & 0xFFFFFFFF;
    case ELF::R_MIPS_64:
      return Value + getELFAddend(R);
    }
    HasError = true;
    return 0;
d401 10
a410 9
  uint64_t visitPPC64(uint32_t Rel, RelocationRef R, uint64_t Value) {
    switch (Rel) {
    case ELF::R_PPC64_ADDR32:
      return (Value + getELFAddend(R)) & 0xFFFFFFFF;
    case ELF::R_PPC64_ADDR64:
      return Value + getELFAddend(R);
    }
    HasError = true;
    return 0;
d413 3
a415 13
  uint64_t visitSystemz(uint32_t Rel, RelocationRef R, uint64_t Value) {
    switch (Rel) {
    case ELF::R_390_32: {
      int64_t Res = Value + getELFAddend(R);
      if (Res < INT32_MIN || Res > UINT32_MAX)
        HasError = true;
      return static_cast<uint32_t>(Res);
    }
    case ELF::R_390_64:
      return Value + getELFAddend(R);
    }
    HasError = true;
    return 0;
d418 3
a420 10
  uint64_t visitSparc64(uint32_t Rel, RelocationRef R, uint64_t Value) {
    switch (Rel) {
    case ELF::R_SPARC_32:
    case ELF::R_SPARC_64:
    case ELF::R_SPARC_UA32:
    case ELF::R_SPARC_UA64:
      return Value + getELFAddend(R);
    }
    HasError = true;
    return 0;
d423 3
a425 8
  uint64_t visitAmdgpu(uint32_t Rel, RelocationRef R, uint64_t Value) {
    switch (Rel) {
    case ELF::R_AMDGPU_ABS32:
    case ELF::R_AMDGPU_ABS64:
      return Value + getELFAddend(R);
    }
    HasError = true;
    return 0;
d428 3
a430 11
  uint64_t visitX86(uint32_t Rel, RelocationRef R, uint64_t Value) {
    switch (Rel) {
    case ELF::R_386_NONE:
      return 0;
    case ELF::R_386_32:
      return Value;
    case ELF::R_386_PC32:
      return Value - R.getOffset();
    }
    HasError = true;
    return 0;
d433 8
a440 5
  uint64_t visitPPC32(uint32_t Rel, RelocationRef R, uint64_t Value) {
    if (Rel == ELF::R_PPC_ADDR32)
      return (Value + getELFAddend(R)) & 0xFFFFFFFF;
    HasError = true;
    return 0;
d443 3
a445 8
  uint64_t visitARM(uint32_t Rel, RelocationRef R, uint64_t Value) {
    if (Rel == ELF::R_ARM_ABS32) {
      if ((int64_t)Value < INT32_MIN || (int64_t)Value > UINT32_MAX)
        HasError = true;
      return static_cast<uint32_t>(Value);
    }
    HasError = true;
    return 0;
d448 3
a450 5
  uint64_t visitLanai(uint32_t Rel, RelocationRef R, uint64_t Value) {
    if (Rel == ELF::R_LANAI_32)
      return (Value + getELFAddend(R)) & 0xFFFFFFFF;
    HasError = true;
    return 0;
d453 3
a455 5
  uint64_t visitMips32(uint32_t Rel, RelocationRef R, uint64_t Value) {
    if (Rel == ELF::R_MIPS_32)
      return Value & 0xFFFFFFFF;
    HasError = true;
    return 0;
d458 2
a459 5
  uint64_t visitSparc32(uint32_t Rel, RelocationRef R, uint64_t Value) {
    if (Rel == ELF::R_SPARC_32 || Rel == ELF::R_SPARC_UA32)
      return Value + getELFAddend(R);
    HasError = true;
    return 0;
d462 3
a464 5
  uint64_t visitHexagon(uint32_t Rel, RelocationRef R, uint64_t Value) {
    if (Rel == ELF::R_HEX_32)
      return Value + getELFAddend(R);
    HasError = true;
    return 0;
d467 2
a468 20
  uint64_t visitCOFF(uint32_t Rel, RelocationRef R, uint64_t Value) {
    switch (ObjToVisit.getArch()) {
    case Triple::x86:
      switch (Rel) {
      case COFF::IMAGE_REL_I386_SECREL:
      case COFF::IMAGE_REL_I386_DIR32:
        return static_cast<uint32_t>(Value);
      }
      break;
    case Triple::x86_64:
      switch (Rel) {
      case COFF::IMAGE_REL_AMD64_SECREL:
        return static_cast<uint32_t>(Value);
      case COFF::IMAGE_REL_AMD64_ADDR64:
        return Value;
      }
      break;
    }
    HasError = true;
    return 0;
d471 5
a475 6
  uint64_t visitMachO(uint32_t Rel, RelocationRef R, uint64_t Value) {
    if (ObjToVisit.getArch() == Triple::x86_64 &&
        Rel == MachO::X86_64_RELOC_UNSIGNED)
      return Value;
    HasError = true;
    return 0;
d479 3
a481 4
} // end namespace object
} // end namespace llvm

#endif // LLVM_OBJECT_RELOCVISITOR_H
@


