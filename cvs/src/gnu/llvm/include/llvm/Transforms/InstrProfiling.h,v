head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.3
	OPENBSD_6_2:1.1.1.2.0.2
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.1
date	2017.01.14.19.55.56;	author patrick;	state Exp;
branches
	1.1.1.1;
next	;
commitid	qMUxATnKgqN83Oct;

1.1.1.1
date	2017.01.14.19.55.56;	author patrick;	state Exp;
branches;
next	1.1.1.2;
commitid	qMUxATnKgqN83Oct;

1.1.1.2
date	2017.01.24.08.33.16;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	so2WA7LCP6wbxtYl;

1.1.1.3
date	2017.10.04.20.27.53;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===- Transforms/InstrProfiling.h - Instrumentation passes ---*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
/// \file
/// This file provides the interface for LLVM's PGO Instrumentation lowering
/// pass.
//===----------------------------------------------------------------------===//

#ifndef LLVM_TRANSFORMS_INSTRPROFILING_H
#define LLVM_TRANSFORMS_INSTRPROFILING_H

#include "llvm/IR/IntrinsicInst.h"
#include "llvm/IR/PassManager.h"
#include "llvm/ProfileData/InstrProf.h"
#include "llvm/Transforms/Instrumentation.h"

namespace llvm {

/// Instrumenation based profiling lowering pass. This pass lowers
/// the profile instrumented code generated by FE or the IR based
/// instrumentation pass.
class InstrProfiling : public PassInfoMixin<InstrProfiling> {
public:
  InstrProfiling() {}
  InstrProfiling(const InstrProfOptions &Options) : Options(Options) {}

  PreservedAnalyses run(Module &M, AnalysisManager<Module> &AM);
  bool run(Module &M);

private:
  InstrProfOptions Options;
  Module *M;
  struct PerFunctionProfileData {
    uint32_t NumValueSites[IPVK_Last + 1];
    GlobalVariable *RegionCounters;
    GlobalVariable *DataVar;
    PerFunctionProfileData() : RegionCounters(nullptr), DataVar(nullptr) {
      memset(NumValueSites, 0, sizeof(uint32_t) * (IPVK_Last + 1));
    }
  };
  DenseMap<GlobalVariable *, PerFunctionProfileData> ProfileDataMap;
  std::vector<Value *> UsedVars;
  std::vector<GlobalVariable *> ReferencedNames;
  GlobalVariable *NamesVar;
  size_t NamesSize;

  bool isMachO() const;

  /// Get the section name for the counter variables.
  StringRef getCountersSection() const;

  /// Get the section name for the name variables.
  StringRef getNameSection() const;

  /// Get the section name for the profile data variables.
  StringRef getDataSection() const;

  /// Get the section name for the coverage mapping data.
  StringRef getCoverageSection() const;

  /// Count the number of instrumented value sites for the function.
  void computeNumValueSiteCounts(InstrProfValueProfileInst *Ins);

  /// Replace instrprof_value_profile with a call to runtime library.
  void lowerValueProfileInst(InstrProfValueProfileInst *Ins);

  /// Replace instrprof_increment with an increment of the appropriate value.
  void lowerIncrement(InstrProfIncrementInst *Inc);

  /// Force emitting of name vars for unused functions.
  void lowerCoverageData(GlobalVariable *CoverageNamesVar);

  /// Get the region counters for an increment, creating them if necessary.
  ///
  /// If the counter array doesn't yet exist, the profile data variables
  /// referring to them will also be created.
  GlobalVariable *getOrCreateRegionCounters(InstrProfIncrementInst *Inc);

  /// Emit the section with compressed function names.
  void emitNameData();

  /// Emit value nodes section for value profiling.
  void emitVNodes();

  /// Emit runtime registration functions for each profile data variable.
  void emitRegistration();

  /// Emit the necessary plumbing to pull in the runtime initialization.
  void emitRuntimeHook();

  /// Add uses of our data variables and runtime hook.
  void emitUses();

  /// Create a static initializer for our data, on platforms that need it,
  /// and for any profile output file that was specified.
  void emitInitialization();
};

} // End llvm namespace
#endif
@


1.1.1.1
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d24 1
a24 3
class TargetLibraryInfo;

/// Instrumentation based profiling lowering pass. This pass lowers
d32 2
a33 2
  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);
  bool run(Module &M, const TargetLibraryInfo &TLI);
a37 1
  const TargetLibraryInfo *TLI;
d47 1
a47 1
  std::vector<GlobalValue *> UsedVars;
@


1.1.1.3
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@d1 1
a1 1
//===- Transforms/InstrProfiling.h - Instrumentation passes -----*- C++ -*-===//
a16 2
#include "llvm/ADT/DenseMap.h"
#include "llvm/ADT/StringRef.h"
a20 4
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <vector>
a24 1
using LoadStorePair = std::pair<Instruction *, Instruction *>;
d31 1
a31 1
  InstrProfiling() = default;
a39 1
  Triple TT;
d43 3
a45 4
    GlobalVariable *RegionCounters = nullptr;
    GlobalVariable *DataVar = nullptr;

    PerFunctionProfileData() {
d55 1
a55 7
  // vector of counter load/store pairs to be register promoted.
  std::vector<LoadStorePair> PromotionCandidates;

  // The start value of precise value profile range for memory intrinsic sizes.
  int64_t MemOPSizeRangeStart;
  // The end value of precise value profile range for memory intrinsic sizes.
  int64_t MemOPSizeRangeLast;
d57 2
a58 1
  int64_t TotalCountersPromoted = 0;
d60 2
a61 3
  /// Lower instrumentation intrinsics in the function. Returns true if there
  /// any lowering.
  bool lowerIntrinsics(Function *F);
d63 2
a64 2
  /// Register-promote counter loads and stores in loops.
  void promoteCounterLoadStores(Function *F);
d66 2
a67 2
  /// Returns true if profile counter update register promotion is enabled.
  bool isCounterPromotionEnabled() const;
d107 2
a108 3
} // end namespace llvm

#endif // LLVM_TRANSFORMS_INSTRPROFILING_H
@


