head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.3
	OPENBSD_6_2:1.1.1.2.0.2
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.55;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.10.04.20.27.55;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===- ValueTypes.td - ValueType definitions ---------------*- tablegen -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// Value types - These values correspond to the register types defined in the
// ValueTypes.h file.  If you update anything here, you must update it there as
// well!
//
//===----------------------------------------------------------------------===//

class ValueType<int size, int value> {
  string Namespace = "MVT";
  int Size = size;
  int Value = value;
}

def OtherVT: ValueType<0  ,  0>;   // "Other" value
def i1     : ValueType<1  ,  1>;   // One bit boolean value
def i8     : ValueType<8  ,  2>;   // 8-bit integer value
def i16    : ValueType<16 ,  3>;   // 16-bit integer value
def i32    : ValueType<32 ,  4>;   // 32-bit integer value
def i64    : ValueType<64 ,  5>;   // 64-bit integer value
def i128   : ValueType<128,  6>;   // 128-bit integer value
def f16    : ValueType<16 ,  7>;   // 16-bit floating point value
def f32    : ValueType<32 ,  8>;   // 32-bit floating point value
def f64    : ValueType<64 ,  9>;   // 64-bit floating point value
def f80    : ValueType<80 , 10>;   // 80-bit floating point value
def f128   : ValueType<128, 11>;   // 128-bit floating point value
def ppcf128: ValueType<128, 12>;   // PPC 128-bit floating point value

def v2i1   : ValueType<2 ,  13>;   //   2 x i1 vector value
def v4i1   : ValueType<4 ,  14>;   //   4 x i1 vector value
def v8i1   : ValueType<8 ,  15>;   //   8 x i1 vector value
def v16i1  : ValueType<16,  16>;   //  16 x i1 vector value
def v32i1  : ValueType<32 , 17>;   //  32 x i1 vector value
def v64i1  : ValueType<64 , 18>;   //  64 x i1 vector value
def v512i1 : ValueType<512, 19>;   // 512 x i8 vector value
def v1024i1: ValueType<1024,20>;   //1024 x i8 vector value

def v1i8   : ValueType<16,  21>;   //  1 x i8  vector value
def v2i8   : ValueType<16 , 22>;   //  2 x i8  vector value
def v4i8   : ValueType<32 , 23>;   //  4 x i8  vector value
def v8i8   : ValueType<64 , 24>;   //  8 x i8  vector value
def v16i8  : ValueType<128, 25>;   // 16 x i8  vector value
def v32i8  : ValueType<256, 26>;   // 32 x i8  vector value
def v64i8  : ValueType<512, 27>;   // 64 x i8  vector value
def v128i8 : ValueType<1024,28>;   //128 x i8  vector value
def v256i8 : ValueType<2048,29>;   //256 x i8  vector value

def v1i16  : ValueType<16 , 30>;   //  1 x i16 vector value
def v2i16  : ValueType<32 , 31>;   //  2 x i16 vector value
def v4i16  : ValueType<64 , 32>;   //  4 x i16 vector value
def v8i16  : ValueType<128, 33>;   //  8 x i16 vector value
def v16i16 : ValueType<256, 34>;   // 16 x i16 vector value
def v32i16 : ValueType<512, 35>;   // 32 x i16 vector value
def v64i16 : ValueType<1024,36>;   // 64 x i16 vector value
def v128i16: ValueType<2048,37>;   //128 x i16 vector value

def v1i32  : ValueType<32 , 38>;   //  1 x i32 vector value
def v2i32  : ValueType<64 , 39>;   //  2 x i32 vector value
def v4i32  : ValueType<128, 40>;   //  4 x i32 vector value
def v8i32  : ValueType<256, 41>;   //  8 x i32 vector value
def v16i32 : ValueType<512, 42>;   // 16 x i32 vector value
def v32i32 : ValueType<1024,43>;   // 32 x i32 vector value
def v64i32 : ValueType<2048,44>;   // 32 x i32 vector value

def v1i64  : ValueType<64 , 45>;   //  1 x i64 vector value
def v2i64  : ValueType<128, 46>;   //  2 x i64 vector value
def v4i64  : ValueType<256, 47>;   //  4 x i64 vector value
def v8i64  : ValueType<512, 48>;   //  8 x i64 vector value
def v16i64 : ValueType<1024,49>;   // 16 x i64 vector value
def v32i64 : ValueType<2048,50>;   // 32 x i64 vector value

def v1i128 : ValueType<128, 51>;   //  1 x i128 vector value

def v2f16  : ValueType<32 , 52>;   //  2 x f16 vector value
def v4f16  : ValueType<64 , 53>;   //  4 x f16 vector value
def v8f16  : ValueType<128, 54>;   //  8 x f16 vector value
def v1f32  : ValueType<32 , 55>;   //  1 x f32 vector value
def v2f32  : ValueType<64 , 56>;   //  2 x f32 vector value
def v4f32  : ValueType<128, 57>;   //  4 x f32 vector value
def v8f32  : ValueType<256, 58>;   //  8 x f32 vector value
def v16f32 : ValueType<512, 59>;   // 16 x f32 vector value
def v1f64  : ValueType<64,  60>;   //  1 x f64 vector value
def v2f64  : ValueType<128, 61>;   //  2 x f64 vector value
def v4f64  : ValueType<256, 62>;   //  4 x f64 vector value
def v8f64  : ValueType<512, 63>;   //  8 x f64 vector value


def x86mmx : ValueType<64 , 64>;   // X86 MMX value
def FlagVT : ValueType<0  , 65>;   // Pre-RA sched glue
def isVoid : ValueType<0  , 66>;   // Produces no value
def untyped: ValueType<8  , 67>;   // Produces an untyped value
def token  : ValueType<0  , 249>;  // TokenTy
def MetadataVT: ValueType<0, 250>; // Metadata

// Pseudo valuetype mapped to the current pointer size to any address space.
// Should only be used in TableGen.
def iPTRAny   : ValueType<0, 251>;

// Pseudo valuetype to represent "vector of any size"
def vAny   : ValueType<0  , 252>;

// Pseudo valuetype to represent "float of any format"
def fAny   : ValueType<0  , 253>;

// Pseudo valuetype to represent "integer of any bit width"
def iAny   : ValueType<0  , 254>;

// Pseudo valuetype mapped to the current pointer size.
def iPTR   : ValueType<0  , 255>;

// Pseudo valuetype to represent "any type of any size".
def Any    : ValueType<0  , 256>;
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d42 2
a43 2
def v512i1 : ValueType<512, 19>;   // 512 x i1 vector value
def v1024i1: ValueType<1024,20>;   //1024 x i1 vector value
d99 2
a100 2
def token  : ValueType<0  , 120>;  // TokenTy
def MetadataVT: ValueType<0, 121>; // Metadata
d104 1
a104 1
def iPTRAny   : ValueType<0, 122>;
d107 1
a107 1
def vAny   : ValueType<0  , 123>;
d110 1
a110 1
def fAny   : ValueType<0  , 124>;
d113 1
a113 1
def iAny   : ValueType<0  , 125>;
d116 1
a116 1
def iPTR   : ValueType<0  , 126>;
d119 1
a119 1
def Any    : ValueType<0  , 127>;
@


1.1.1.3
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@d22 79
a100 127
def OtherVT: ValueType<0  ,  1>;   // "Other" value
def i1     : ValueType<1  ,  2>;   // One bit boolean value
def i8     : ValueType<8  ,  3>;   // 8-bit integer value
def i16    : ValueType<16 ,  4>;   // 16-bit integer value
def i32    : ValueType<32 ,  5>;   // 32-bit integer value
def i64    : ValueType<64 ,  6>;   // 64-bit integer value
def i128   : ValueType<128,  7>;   // 128-bit integer value
def f16    : ValueType<16 ,  8>;   // 16-bit floating point value
def f32    : ValueType<32 ,  9>;   // 32-bit floating point value
def f64    : ValueType<64 , 10>;   // 64-bit floating point value
def f80    : ValueType<80 , 11>;   // 80-bit floating point value
def f128   : ValueType<128, 12>;   // 128-bit floating point value
def ppcf128: ValueType<128, 13>;   // PPC 128-bit floating point value

def v1i1   : ValueType<1 ,  14>;   //   1 x i1 vector value
def v2i1   : ValueType<2 ,  15>;   //   2 x i1 vector value
def v4i1   : ValueType<4 ,  16>;   //   4 x i1 vector value
def v8i1   : ValueType<8 ,  17>;   //   8 x i1 vector value
def v16i1  : ValueType<16,  18>;   //  16 x i1 vector value
def v32i1  : ValueType<32 , 19>;   //  32 x i1 vector value
def v64i1  : ValueType<64 , 20>;   //  64 x i1 vector value
def v512i1 : ValueType<512, 21>;   // 512 x i1 vector value
def v1024i1: ValueType<1024,22>;   //1024 x i1 vector value

def v1i8   : ValueType<8,  23>;   //  1 x i8  vector value
def v2i8   : ValueType<16 , 24>;   //  2 x i8  vector value
def v4i8   : ValueType<32 , 25>;   //  4 x i8  vector value
def v8i8   : ValueType<64 , 26>;   //  8 x i8  vector value
def v16i8  : ValueType<128, 27>;   // 16 x i8  vector value
def v32i8  : ValueType<256, 28>;   // 32 x i8  vector value
def v64i8  : ValueType<512, 29>;   // 64 x i8  vector value
def v128i8 : ValueType<1024,30>;   //128 x i8  vector value
def v256i8 : ValueType<2048,31>;   //256 x i8  vector value

def v1i16  : ValueType<16 , 32>;   //  1 x i16 vector value
def v2i16  : ValueType<32 , 33>;   //  2 x i16 vector value
def v4i16  : ValueType<64 , 34>;   //  4 x i16 vector value
def v8i16  : ValueType<128, 35>;   //  8 x i16 vector value
def v16i16 : ValueType<256, 36>;   // 16 x i16 vector value
def v32i16 : ValueType<512, 37>;   // 32 x i16 vector value
def v64i16 : ValueType<1024,38>;   // 64 x i16 vector value
def v128i16: ValueType<2048,39>;   //128 x i16 vector value

def v1i32  : ValueType<32 , 40>;   //  1 x i32 vector value
def v2i32  : ValueType<64 , 41>;   //  2 x i32 vector value
def v4i32  : ValueType<128, 42>;   //  4 x i32 vector value
def v8i32  : ValueType<256, 43>;   //  8 x i32 vector value
def v16i32 : ValueType<512, 44>;   // 16 x i32 vector value
def v32i32 : ValueType<1024,45>;   // 32 x i32 vector value
def v64i32 : ValueType<2048,46>;   // 32 x i32 vector value

def v1i64  : ValueType<64 , 47>;   //  1 x i64 vector value
def v2i64  : ValueType<128, 48>;   //  2 x i64 vector value
def v4i64  : ValueType<256, 49>;   //  4 x i64 vector value
def v8i64  : ValueType<512, 50>;   //  8 x i64 vector value
def v16i64 : ValueType<1024,51>;   // 16 x i64 vector value
def v32i64 : ValueType<2048,52>;   // 32 x i64 vector value

def v1i128 : ValueType<128, 53>;   //  1 x i128 vector value

def nxv1i1  : ValueType<1,   54>;  // n x  1 x i1  vector value
def nxv2i1  : ValueType<2,   55>;  // n x  2 x i1  vector value
def nxv4i1  : ValueType<4,   56>;  // n x  4 x i1  vector value
def nxv8i1  : ValueType<8,   57>;  // n x  8 x i1  vector value
def nxv16i1 : ValueType<16,  58>;  // n x 16 x i1  vector value
def nxv32i1 : ValueType<32,  59>;  // n x 32 x i1  vector value

def nxv1i8  : ValueType<8,   60>;  // n x  1 x i8  vector value
def nxv2i8  : ValueType<16,  61>;  // n x  2 x i8  vector value
def nxv4i8  : ValueType<32,  62>;  // n x  4 x i8  vector value
def nxv8i8  : ValueType<64,  63>;  // n x  8 x i8  vector value
def nxv16i8 : ValueType<128, 64>;  // n x 16 x i8  vector value
def nxv32i8 : ValueType<256, 65>;  // n x 32 x i8  vector value

def nxv1i16 : ValueType<16,  66>;  // n x  1 x i16 vector value
def nxv2i16 : ValueType<32,  67>;  // n x  2 x i16 vector value
def nxv4i16 : ValueType<64,  68>;  // n x  4 x i16 vector value
def nxv8i16 : ValueType<128, 69>;  // n x  8 x i16 vector value
def nxv16i16: ValueType<256, 70>;  // n x 16 x i16 vector value
def nxv32i16: ValueType<512, 71>;  // n x 32 x i16 vector value

def nxv1i32 : ValueType<32,  72>;  // n x  1 x i32 vector value
def nxv2i32 : ValueType<64,  73>;  // n x  2 x i32 vector value
def nxv4i32 : ValueType<128, 74>;  // n x  4 x i32 vector value
def nxv8i32 : ValueType<256, 75>;  // n x  8 x i32 vector value
def nxv16i32: ValueType<512, 76>;  // n x 16 x i32 vector value
def nxv32i32: ValueType<1024,77>;  // n x 32 x i32 vector value

def nxv1i64 : ValueType<64,  78>;  // n x  1 x i64 vector value
def nxv2i64 : ValueType<128, 79>;  // n x  2 x i64 vector value
def nxv4i64 : ValueType<256, 80>;  // n x  4 x i64 vector value
def nxv8i64 : ValueType<512, 81>;  // n x  8 x i64 vector value
def nxv16i64: ValueType<1024,82>;  // n x 16 x i64 vector value
def nxv32i64: ValueType<2048,83>;  // n x 32 x i64 vector value

def v2f16  : ValueType<32 , 84>;   //  2 x f16 vector value
def v4f16  : ValueType<64 , 85>;   //  4 x f16 vector value
def v8f16  : ValueType<128, 86>;   //  8 x f16 vector value
def v1f32  : ValueType<32 , 87>;   //  1 x f32 vector value
def v2f32  : ValueType<64 , 88>;   //  2 x f32 vector value
def v4f32  : ValueType<128, 89>;   //  4 x f32 vector value
def v8f32  : ValueType<256, 90>;   //  8 x f32 vector value
def v16f32 : ValueType<512, 91>;   // 16 x f32 vector value
def v1f64  : ValueType<64,  92>;   //  1 x f64 vector value
def v2f64  : ValueType<128, 93>;   //  2 x f64 vector value
def v4f64  : ValueType<256, 94>;   //  4 x f64 vector value
def v8f64  : ValueType<512, 95>;   //  8 x f64 vector value

def nxv2f16  : ValueType<32 ,  96>; // n x  2 x f16 vector value
def nxv4f16  : ValueType<64 ,  97>; // n x  4 x f16 vector value
def nxv8f16  : ValueType<128,  98>; // n x  8 x f16 vector value
def nxv1f32  : ValueType<32 ,  99>; // n x  1 x f32 vector value
def nxv2f32  : ValueType<64 , 100>; // n x  2 x f32 vector value
def nxv4f32  : ValueType<128, 101>; // n x  4 x f32 vector value
def nxv8f32  : ValueType<256, 102>; // n x  8 x f32 vector value
def nxv16f32 : ValueType<512, 103>; // n x 16 x f32 vector value
def nxv1f64  : ValueType<64,  104>; // n x  1 x f64 vector value
def nxv2f64  : ValueType<128, 105>; // n x  2 x f64 vector value
def nxv4f64  : ValueType<256, 106>; // n x  4 x f64 vector value
def nxv8f64  : ValueType<512, 107>; // n x  8 x f64 vector value

def x86mmx : ValueType<64 , 108>;   // X86 MMX value
def FlagVT : ValueType<0  , 109>;   // Pre-RA sched glue
def isVoid : ValueType<0  , 110>;   // Produces no value
def untyped: ValueType<8  , 111>;   // Produces an untyped value
def token  : ValueType<0  , 248>;   // TokenTy
def MetadataVT: ValueType<0, 249>;  // Metadata
d104 1
a104 1
def iPTRAny   : ValueType<0, 250>;
d107 1
a107 1
def vAny   : ValueType<0  , 251>;
d110 1
a110 1
def fAny   : ValueType<0  , 252>;
d113 1
a113 1
def iAny   : ValueType<0  , 253>;
d116 1
a116 1
def iPTR   : ValueType<0  , 254>;
d119 1
a119 1
def Any    : ValueType<0  , 255>;
@


