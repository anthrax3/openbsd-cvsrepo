head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.4
	OPENBSD_6_2:1.1.1.3.0.2
	OPENBSD_6_2_BASE:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.4
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.55;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.20;	author patrick;	state Exp;
branches;
next	1.1.1.4;
commitid	so2WA7LCP6wbxtYl;

1.1.1.4
date	2017.10.04.20.27.55;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===- CodeGen/MachineValueType.h - Machine-Level types ---------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines the set of machine-level target independent types which
// legal values in the code generator use.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_CODEGEN_MACHINEVALUETYPE_H
#define LLVM_CODEGEN_MACHINEVALUETYPE_H

#include "llvm/ADT/iterator_range.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/MathExtras.h"

namespace llvm {

  class Type;

  /// MVT - Machine Value Type. Every type that is supported natively by some
  /// processor targeted by LLVM occurs here. This means that any legal value
  /// type can be represented by an MVT.
class MVT {
  public:
    enum SimpleValueType {
      // INVALID_SIMPLE_VALUE_TYPE - Simple value types less than zero are
      // considered extended value types.
      INVALID_SIMPLE_VALUE_TYPE = -1,

      // If you change this numbering, you must change the values in
      // ValueTypes.td as well!
      Other          =   0,   // This is a non-standard value
      i1             =   1,   // This is a 1 bit integer value
      i8             =   2,   // This is an 8 bit integer value
      i16            =   3,   // This is a 16 bit integer value
      i32            =   4,   // This is a 32 bit integer value
      i64            =   5,   // This is a 64 bit integer value
      i128           =   6,   // This is a 128 bit integer value

      FIRST_INTEGER_VALUETYPE = i1,
      LAST_INTEGER_VALUETYPE  = i128,

      f16            =   7,   // This is a 16 bit floating point value
      f32            =   8,   // This is a 32 bit floating point value
      f64            =   9,   // This is a 64 bit floating point value
      f80            =  10,   // This is a 80 bit floating point value
      f128           =  11,   // This is a 128 bit floating point value
      ppcf128        =  12,   // This is a PPC 128-bit floating point value

      FIRST_FP_VALUETYPE = f16,
      LAST_FP_VALUETYPE  = ppcf128,

      v2i1           =  13,   //    2 x i1
      v4i1           =  14,   //    4 x i1
      v8i1           =  15,   //    8 x i1
      v16i1          =  16,   //   16 x i1
      v32i1          =  17,   //   32 x i1
      v64i1          =  18,   //   64 x i1
      v512i1         =  19,   //  512 x i1
      v1024i1        =  20,   // 1024 x i1

      v1i8           =  21,   //  1 x i8
      v2i8           =  22,   //  2 x i8
      v4i8           =  23,   //  4 x i8
      v8i8           =  24,   //  8 x i8
      v16i8          =  25,   // 16 x i8
      v32i8          =  26,   // 32 x i8
      v64i8          =  27,   // 64 x i8
      v128i8         =  28,   //128 x i8
      v256i8         =  29,   //256 x i8

      v1i16          =  30,   //  1 x i16
      v2i16          =  31,   //  2 x i16
      v4i16          =  32,   //  4 x i16
      v8i16          =  33,   //  8 x i16
      v16i16         =  34,   // 16 x i16
      v32i16         =  35,   // 32 x i16
      v64i16         =  36,   // 64 x i16
      v128i16        =  37,   //128 x i16

      v1i32          =  38,   //  1 x i32
      v2i32          =  39,   //  2 x i32
      v4i32          =  40,   //  4 x i32
      v8i32          =  41,   //  8 x i32
      v16i32         =  42,   // 16 x i32
      v32i32         =  43,   // 32 x i32
      v64i32         =  44,   // 64 x i32

      v1i64          =  45,   //  1 x i64
      v2i64          =  46,   //  2 x i64
      v4i64          =  47,   //  4 x i64
      v8i64          =  48,   //  8 x i64
      v16i64         =  49,   // 16 x i64
      v32i64         =  50,   // 32 x i64

      v1i128         =  51,   //  1 x i128

      FIRST_INTEGER_VECTOR_VALUETYPE = v2i1,
      LAST_INTEGER_VECTOR_VALUETYPE = v1i128,

      v2f16          =  52,   //  2 x f16
      v4f16          =  53,   //  4 x f16
      v8f16          =  54,   //  8 x f16
      v1f32          =  55,   //  1 x f32
      v2f32          =  56,   //  2 x f32
      v4f32          =  57,   //  4 x f32
      v8f32          =  58,   //  8 x f32
      v16f32         =  59,   // 16 x f32
      v1f64          =  60,   //  1 x f64
      v2f64          =  61,   //  2 x f64
      v4f64          =  62,   //  4 x f64
      v8f64          =  63,   //  8 x f64

      FIRST_FP_VECTOR_VALUETYPE = v2f16,
      LAST_FP_VECTOR_VALUETYPE = v8f64,

      FIRST_VECTOR_VALUETYPE = v2i1,
      LAST_VECTOR_VALUETYPE  = v8f64,

      x86mmx         =  64,   // This is an X86 MMX value

      Glue           =  65,   // This glues nodes together during pre-RA sched

      isVoid         =  66,   // This has no value

      Untyped        =  67,   // This value takes a register, but has
                              // unspecified type.  The register class
                              // will be determined by the opcode.

      FIRST_VALUETYPE = 0,    // This is always the beginning of the list.
      LAST_VALUETYPE =  68,   // This always remains at the end of the list.

      // This is the current maximum for LAST_VALUETYPE.
      // MVT::MAX_ALLOWED_VALUETYPE is used for asserts and to size bit vectors
      // This value must be a multiple of 32.
      MAX_ALLOWED_VALUETYPE = 96,

      // Token - A value of type llvm::TokenTy
      token          = 249,

      // Metadata - This is MDNode or MDString.
      Metadata       = 250,

      // iPTRAny - An int value the size of the pointer of the current
      // target to any address space. This must only be used internal to
      // tblgen. Other than for overloading, we treat iPTRAny the same as iPTR.
      iPTRAny        = 251,

      // vAny - A vector with any length and element size. This is used
      // for intrinsics that have overloadings based on vector types.
      // This is only for tblgen's consumption!
      vAny           = 252,

      // fAny - Any floating-point or vector floating-point value. This is used
      // for intrinsics that have overloadings based on floating-point types.
      // This is only for tblgen's consumption!
      fAny           = 253,

      // iAny - An integer or vector integer value of any bit width. This is
      // used for intrinsics that have overloadings based on integer bit widths.
      // This is only for tblgen's consumption!
      iAny           = 254,

      // iPTR - An int value the size of the pointer of the current
      // target.  This should only be used internal to tblgen!
      iPTR           = 255,

      // Any - Any type. This is used for intrinsics that have overloadings.
      // This is only for tblgen's consumption!
      Any            = 256
    };

    SimpleValueType SimpleTy;

    LLVM_CONSTEXPR MVT() : SimpleTy(INVALID_SIMPLE_VALUE_TYPE) {}
    LLVM_CONSTEXPR MVT(SimpleValueType SVT) : SimpleTy(SVT) { }

    bool operator>(const MVT& S)  const { return SimpleTy >  S.SimpleTy; }
    bool operator<(const MVT& S)  const { return SimpleTy <  S.SimpleTy; }
    bool operator==(const MVT& S) const { return SimpleTy == S.SimpleTy; }
    bool operator!=(const MVT& S) const { return SimpleTy != S.SimpleTy; }
    bool operator>=(const MVT& S) const { return SimpleTy >= S.SimpleTy; }
    bool operator<=(const MVT& S) const { return SimpleTy <= S.SimpleTy; }

    /// isValid - Return true if this is a valid simple valuetype.
    bool isValid() const {
      return (SimpleTy >= MVT::FIRST_VALUETYPE &&
              SimpleTy < MVT::LAST_VALUETYPE);
    }

    /// isFloatingPoint - Return true if this is a FP, or a vector FP type.
    bool isFloatingPoint() const {
      return ((SimpleTy >= MVT::FIRST_FP_VALUETYPE &&
               SimpleTy <= MVT::LAST_FP_VALUETYPE) ||
              (SimpleTy >= MVT::FIRST_FP_VECTOR_VALUETYPE &&
               SimpleTy <= MVT::LAST_FP_VECTOR_VALUETYPE));
    }

    /// isInteger - Return true if this is an integer, or a vector integer type.
    bool isInteger() const {
      return ((SimpleTy >= MVT::FIRST_INTEGER_VALUETYPE &&
               SimpleTy <= MVT::LAST_INTEGER_VALUETYPE) ||
              (SimpleTy >= MVT::FIRST_INTEGER_VECTOR_VALUETYPE &&
               SimpleTy <= MVT::LAST_INTEGER_VECTOR_VALUETYPE));
    }

    /// isVector - Return true if this is a vector value type.
    bool isVector() const {
      return (SimpleTy >= MVT::FIRST_VECTOR_VALUETYPE &&
              SimpleTy <= MVT::LAST_VECTOR_VALUETYPE);
    }

    /// is16BitVector - Return true if this is a 16-bit vector type.
    bool is16BitVector() const {
      return (SimpleTy == MVT::v2i8  || SimpleTy == MVT::v1i16 ||
              SimpleTy == MVT::v16i1);
    }

    /// is32BitVector - Return true if this is a 32-bit vector type.
    bool is32BitVector() const {
      return (SimpleTy == MVT::v4i8  || SimpleTy == MVT::v2i16 ||
              SimpleTy == MVT::v1i32 || SimpleTy == MVT::v2f16 ||
              SimpleTy == MVT::v1f32);
    }

    /// is64BitVector - Return true if this is a 64-bit vector type.
    bool is64BitVector() const {
      return (SimpleTy == MVT::v8i8  || SimpleTy == MVT::v4i16 ||
              SimpleTy == MVT::v2i32 || SimpleTy == MVT::v1i64 ||
              SimpleTy == MVT::v4f16 || SimpleTy == MVT::v2f32 ||
              SimpleTy == MVT::v1f64);
    }

    /// is128BitVector - Return true if this is a 128-bit vector type.
    bool is128BitVector() const {
      return (SimpleTy == MVT::v16i8  || SimpleTy == MVT::v8i16 ||
              SimpleTy == MVT::v4i32  || SimpleTy == MVT::v2i64 ||
              SimpleTy == MVT::v1i128 || SimpleTy == MVT::v8f16 ||
              SimpleTy == MVT::v4f32  || SimpleTy == MVT::v2f64);
    }

    /// is256BitVector - Return true if this is a 256-bit vector type.
    bool is256BitVector() const {
      return (SimpleTy == MVT::v8f32 || SimpleTy == MVT::v4f64  ||
              SimpleTy == MVT::v32i8 || SimpleTy == MVT::v16i16 ||
              SimpleTy == MVT::v8i32 || SimpleTy == MVT::v4i64);
    }

    /// is512BitVector - Return true if this is a 512-bit vector type.
    bool is512BitVector() const {
      return (SimpleTy == MVT::v16f32 || SimpleTy == MVT::v8f64  ||
              SimpleTy == MVT::v512i1 || SimpleTy == MVT::v64i8  ||
              SimpleTy == MVT::v32i16 || SimpleTy == MVT::v16i32 ||
              SimpleTy == MVT::v8i64);
    }

    /// is1024BitVector - Return true if this is a 1024-bit vector type.
    bool is1024BitVector() const {
      return (SimpleTy == MVT::v1024i1 || SimpleTy == MVT::v128i8 ||
              SimpleTy == MVT::v64i16  || SimpleTy == MVT::v32i32 ||
              SimpleTy == MVT::v16i64);
    }

    /// is2048BitVector - Return true if this is a 1024-bit vector type.
    bool is2048BitVector() const {
      return (SimpleTy == MVT::v256i8 || SimpleTy == MVT::v128i16 ||
              SimpleTy == MVT::v64i32 || SimpleTy == MVT::v32i64);
    }

    /// isOverloaded - Return true if this is an overloaded type for TableGen.
    bool isOverloaded() const {
      return (SimpleTy==MVT::Any  ||
              SimpleTy==MVT::iAny || SimpleTy==MVT::fAny ||
              SimpleTy==MVT::vAny || SimpleTy==MVT::iPTRAny);
    }

    /// isPow2VectorType - Returns true if the given vector is a power of 2.
    bool isPow2VectorType() const {
      unsigned NElts = getVectorNumElements();
      return !(NElts & (NElts - 1));
    }

    /// getPow2VectorType - Widens the length of the given vector MVT up to
    /// the nearest power of 2 and returns that type.
    MVT getPow2VectorType() const {
      if (isPow2VectorType())
        return *this;

      unsigned NElts = getVectorNumElements();
      unsigned Pow2NElts = 1 << Log2_32_Ceil(NElts);
      return MVT::getVectorVT(getVectorElementType(), Pow2NElts);
    }

    /// getScalarType - If this is a vector type, return the element type,
    /// otherwise return this.
    MVT getScalarType() const {
      return isVector() ? getVectorElementType() : *this;
    }

    MVT getVectorElementType() const {
      switch (SimpleTy) {
      default:
        llvm_unreachable("Not a vector MVT!");
      case v2i1:
      case v4i1:
      case v8i1:
      case v16i1:
      case v32i1:
      case v64i1:
      case v512i1:
      case v1024i1: return i1;
      case v1i8:
      case v2i8:
      case v4i8:
      case v8i8:
      case v16i8:
      case v32i8:
      case v64i8:
      case v128i8:
      case v256i8: return i8;
      case v1i16:
      case v2i16:
      case v4i16:
      case v8i16:
      case v16i16:
      case v32i16:
      case v64i16:
      case v128i16: return i16;
      case v1i32:
      case v2i32:
      case v4i32:
      case v8i32:
      case v16i32:
      case v32i32:
      case v64i32: return i32;
      case v1i64:
      case v2i64:
      case v4i64:
      case v8i64:
      case v16i64:
      case v32i64: return i64;
      case v1i128: return i128;
      case v2f16:
      case v4f16:
      case v8f16: return f16;
      case v1f32:
      case v2f32:
      case v4f32:
      case v8f32:
      case v16f32: return f32;
      case v1f64:
      case v2f64:
      case v4f64:
      case v8f64: return f64;
      }
    }

    unsigned getVectorNumElements() const {
      switch (SimpleTy) {
      default:
        llvm_unreachable("Not a vector MVT!");
      case v1024i1: return 1024;
      case v512i1: return 512;
      case v256i8: return 256;
      case v128i8:
      case v128i16: return 128;
      case v64i1:
      case v64i8:
      case v64i16:
      case v64i32: return 64;
      case v32i1:
      case v32i8:
      case v32i16:
      case v32i32:
      case v32i64: return 32;
      case v16i1:
      case v16i8:
      case v16i16:
      case v16i32:
      case v16i64:
      case v16f32: return 16;
      case v8i1:
      case v8i8:
      case v8i16:
      case v8i32:
      case v8i64:
      case v8f16:
      case v8f32:
      case v8f64: return 8;
      case v4i1:
      case v4i8:
      case v4i16:
      case v4i32:
      case v4i64:
      case v4f16:
      case v4f32:
      case v4f64: return 4;
      case v2i1:
      case v2i8:
      case v2i16:
      case v2i32:
      case v2i64:
      case v2f16:
      case v2f32:
      case v2f64: return 2;
      case v1i8:
      case v1i16:
      case v1i32:
      case v1i64:
      case v1i128:
      case v1f32:
      case v1f64: return 1;
      }
    }

    unsigned getSizeInBits() const {
      switch (SimpleTy) {
      default:
        llvm_unreachable("getSizeInBits called on extended MVT.");
      case Other:
        llvm_unreachable("Value type is non-standard value, Other.");
      case iPTR:
        llvm_unreachable("Value type size is target-dependent. Ask TLI.");
      case iPTRAny:
      case iAny:
      case fAny:
      case vAny:
      case Any:
        llvm_unreachable("Value type is overloaded.");
      case token:
        llvm_unreachable("Token type is a sentinel that cannot be used "
                         "in codegen and has no size");
      case Metadata:
        llvm_unreachable("Value type is metadata.");
      case i1  :  return 1;
      case v2i1:  return 2;
      case v4i1:  return 4;
      case i8  :
      case v1i8:
      case v8i1: return 8;
      case i16 :
      case f16:
      case v16i1:
      case v2i8:
      case v1i16: return 16;
      case f32 :
      case i32 :
      case v32i1:
      case v4i8:
      case v2i16:
      case v2f16:
      case v1f32:
      case v1i32: return 32;
      case x86mmx:
      case f64 :
      case i64 :
      case v64i1:
      case v8i8:
      case v4i16:
      case v2i32:
      case v1i64:
      case v4f16:
      case v2f32:
      case v1f64: return 64;
      case f80 :  return 80;
      case f128:
      case ppcf128:
      case i128:
      case v16i8:
      case v8i16:
      case v4i32:
      case v2i64:
      case v1i128:
      case v8f16:
      case v4f32:
      case v2f64: return 128;
      case v32i8:
      case v16i16:
      case v8i32:
      case v4i64:
      case v8f32:
      case v4f64: return 256;
      case v512i1:
      case v64i8:
      case v32i16:
      case v16i32:
      case v8i64:
      case v16f32:
      case v8f64: return 512;
      case v1024i1:
      case v128i8:
      case v64i16:
      case v32i32:
      case v16i64: return 1024;
      case v256i8:
      case v128i16:
      case v64i32:
      case v32i64: return 2048;
      }
    }

    unsigned getScalarSizeInBits() const {
      return getScalarType().getSizeInBits();
    }

    /// getStoreSize - Return the number of bytes overwritten by a store
    /// of the specified value type.
    unsigned getStoreSize() const {
      return (getSizeInBits() + 7) / 8;
    }

    /// getStoreSizeInBits - Return the number of bits overwritten by a store
    /// of the specified value type.
    unsigned getStoreSizeInBits() const {
      return getStoreSize() * 8;
    }

    /// Return true if this has more bits than VT.
    bool bitsGT(MVT VT) const {
      return getSizeInBits() > VT.getSizeInBits();
    }

    /// Return true if this has no less bits than VT.
    bool bitsGE(MVT VT) const {
      return getSizeInBits() >= VT.getSizeInBits();
    }

    /// Return true if this has less bits than VT.
    bool bitsLT(MVT VT) const {
      return getSizeInBits() < VT.getSizeInBits();
    }

    /// Return true if this has no more bits than VT.
    bool bitsLE(MVT VT) const {
      return getSizeInBits() <= VT.getSizeInBits();
    }


    static MVT getFloatingPointVT(unsigned BitWidth) {
      switch (BitWidth) {
      default:
        llvm_unreachable("Bad bit width!");
      case 16:
        return MVT::f16;
      case 32:
        return MVT::f32;
      case 64:
        return MVT::f64;
      case 80:
        return MVT::f80;
      case 128:
        return MVT::f128;
      }
    }

    static MVT getIntegerVT(unsigned BitWidth) {
      switch (BitWidth) {
      default:
        return (MVT::SimpleValueType)(MVT::INVALID_SIMPLE_VALUE_TYPE);
      case 1:
        return MVT::i1;
      case 8:
        return MVT::i8;
      case 16:
        return MVT::i16;
      case 32:
        return MVT::i32;
      case 64:
        return MVT::i64;
      case 128:
        return MVT::i128;
      }
    }

    static MVT getVectorVT(MVT VT, unsigned NumElements) {
      switch (VT.SimpleTy) {
      default:
        break;
      case MVT::i1:
        if (NumElements == 2)    return MVT::v2i1;
        if (NumElements == 4)    return MVT::v4i1;
        if (NumElements == 8)    return MVT::v8i1;
        if (NumElements == 16)   return MVT::v16i1;
        if (NumElements == 32)   return MVT::v32i1;
        if (NumElements == 64)   return MVT::v64i1;
        if (NumElements == 512)  return MVT::v512i1;
        if (NumElements == 1024) return MVT::v1024i1;
        break;
      case MVT::i8:
        if (NumElements == 1)   return MVT::v1i8;
        if (NumElements == 2)   return MVT::v2i8;
        if (NumElements == 4)   return MVT::v4i8;
        if (NumElements == 8)   return MVT::v8i8;
        if (NumElements == 16)  return MVT::v16i8;
        if (NumElements == 32)  return MVT::v32i8;
        if (NumElements == 64)  return MVT::v64i8;
        if (NumElements == 128) return MVT::v128i8;
        if (NumElements == 256) return MVT::v256i8;
        break;
      case MVT::i16:
        if (NumElements == 1)   return MVT::v1i16;
        if (NumElements == 2)   return MVT::v2i16;
        if (NumElements == 4)   return MVT::v4i16;
        if (NumElements == 8)   return MVT::v8i16;
        if (NumElements == 16)  return MVT::v16i16;
        if (NumElements == 32)  return MVT::v32i16;
        if (NumElements == 64)  return MVT::v64i16;
        if (NumElements == 128) return MVT::v128i16;
        break;
      case MVT::i32:
        if (NumElements == 1)  return MVT::v1i32;
        if (NumElements == 2)  return MVT::v2i32;
        if (NumElements == 4)  return MVT::v4i32;
        if (NumElements == 8)  return MVT::v8i32;
        if (NumElements == 16) return MVT::v16i32;
        if (NumElements == 32) return MVT::v32i32;
        if (NumElements == 64) return MVT::v64i32;
        break;
      case MVT::i64:
        if (NumElements == 1)  return MVT::v1i64;
        if (NumElements == 2)  return MVT::v2i64;
        if (NumElements == 4)  return MVT::v4i64;
        if (NumElements == 8)  return MVT::v8i64;
        if (NumElements == 16) return MVT::v16i64;
        if (NumElements == 32) return MVT::v32i64;
        break;
      case MVT::i128:
        if (NumElements == 1)  return MVT::v1i128;
        break;
      case MVT::f16:
        if (NumElements == 2)  return MVT::v2f16;
        if (NumElements == 4)  return MVT::v4f16;
        if (NumElements == 8)  return MVT::v8f16;
        break;
      case MVT::f32:
        if (NumElements == 1)  return MVT::v1f32;
        if (NumElements == 2)  return MVT::v2f32;
        if (NumElements == 4)  return MVT::v4f32;
        if (NumElements == 8)  return MVT::v8f32;
        if (NumElements == 16) return MVT::v16f32;
        break;
      case MVT::f64:
        if (NumElements == 1)  return MVT::v1f64;
        if (NumElements == 2)  return MVT::v2f64;
        if (NumElements == 4)  return MVT::v4f64;
        if (NumElements == 8)  return MVT::v8f64;
        break;
      }
      return (MVT::SimpleValueType)(MVT::INVALID_SIMPLE_VALUE_TYPE);
    }

    /// Return the value type corresponding to the specified type.  This returns
    /// all pointers as iPTR.  If HandleUnknown is true, unknown types are
    /// returned as Other, otherwise they are invalid.
    static MVT getVT(Type *Ty, bool HandleUnknown = false);

  private:
    /// A simple iterator over the MVT::SimpleValueType enum.
    struct mvt_iterator {
      SimpleValueType VT;
      mvt_iterator(SimpleValueType VT) : VT(VT) {}
      MVT operator*() const { return VT; }
      bool operator!=(const mvt_iterator &LHS) const { return VT != LHS.VT; }
      mvt_iterator& operator++() {
        VT = (MVT::SimpleValueType)((int)VT + 1);
        assert((int)VT <= MVT::MAX_ALLOWED_VALUETYPE &&
               "MVT iterator overflowed.");
        return *this;
      }
    };
    /// A range of the MVT::SimpleValueType enum.
    typedef iterator_range<mvt_iterator> mvt_range;

  public:
    /// SimpleValueType Iteration
    /// @@{
    static mvt_range all_valuetypes() {
      return mvt_range(MVT::FIRST_VALUETYPE, MVT::LAST_VALUETYPE);
    }
    static mvt_range integer_valuetypes() {
      return mvt_range(MVT::FIRST_INTEGER_VALUETYPE,
                       (MVT::SimpleValueType)(MVT::LAST_INTEGER_VALUETYPE + 1));
    }
    static mvt_range fp_valuetypes() {
      return mvt_range(MVT::FIRST_FP_VALUETYPE,
                       (MVT::SimpleValueType)(MVT::LAST_FP_VALUETYPE + 1));
    }
    static mvt_range vector_valuetypes() {
      return mvt_range(MVT::FIRST_VECTOR_VALUETYPE,
                       (MVT::SimpleValueType)(MVT::LAST_VECTOR_VALUETYPE + 1));
    }
    static mvt_range integer_vector_valuetypes() {
      return mvt_range(
          MVT::FIRST_INTEGER_VECTOR_VALUETYPE,
          (MVT::SimpleValueType)(MVT::LAST_INTEGER_VECTOR_VALUETYPE + 1));
    }
    static mvt_range fp_vector_valuetypes() {
      return mvt_range(
          MVT::FIRST_FP_VECTOR_VALUETYPE,
          (MVT::SimpleValueType)(MVT::LAST_FP_VECTOR_VALUETYPE + 1));
    }
    /// @@}
  };

} // End llvm namespace

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d31 1
a31 1
    enum SimpleValueType : int8_t {
d145 1
a145 1
      token          = 120,
d148 1
a148 1
      Metadata       = 121,
d153 1
a153 1
      iPTRAny        = 122,
d158 1
a158 1
      vAny           = 123,
d163 1
a163 1
      fAny           = 124,
d168 1
a168 1
      iAny           = 125,
d172 1
a172 1
      iPTR           = 126,
d176 1
a176 1
      Any            = 127
a210 7
    }

    /// isScalarInteger - Return true if this is an integer, not including
    /// vectors.
    bool isScalarInteger() const {
      return (SimpleTy >= MVT::FIRST_INTEGER_VALUETYPE &&
              SimpleTy <= MVT::LAST_INTEGER_VALUETYPE);
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d181 2
a182 2
    constexpr MVT() : SimpleTy(INVALID_SIMPLE_VALUE_TYPE) {}
    constexpr MVT(SimpleValueType SVT) : SimpleTy(SVT) {}
@


1.1.1.4
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@a20 1
#include <cassert>
d26 1
a26 1
  /// Machine Value Type. Every type that is supported natively by some
d29 1
a29 1
  class MVT {
d31 4
a34 4
    enum SimpleValueType : uint8_t {
      // Simple value types that aren't explicitly part of this enumeration
      // are considered extended value types.
      INVALID_SIMPLE_VALUE_TYPE = 0,
d38 7
a44 7
      Other          =   1,   // This is a non-standard value
      i1             =   2,   // This is a 1 bit integer value
      i8             =   3,   // This is an 8 bit integer value
      i16            =   4,   // This is a 16 bit integer value
      i32            =   5,   // This is a 32 bit integer value
      i64            =   6,   // This is a 64 bit integer value
      i128           =   7,   // This is a 128 bit integer value
d49 6
a54 6
      f16            =   8,   // This is a 16 bit floating point value
      f32            =   9,   // This is a 32 bit floating point value
      f64            =  10,   // This is a 64 bit floating point value
      f80            =  11,   // This is a 80 bit floating point value
      f128           =  12,   // This is a 128 bit floating point value
      ppcf128        =  13,   // This is a PPC 128-bit floating point value
d59 60
a118 113
      v1i1           =  14,   //    1 x i1
      v2i1           =  15,   //    2 x i1
      v4i1           =  16,   //    4 x i1
      v8i1           =  17,   //    8 x i1
      v16i1          =  18,   //   16 x i1
      v32i1          =  19,   //   32 x i1
      v64i1          =  20,   //   64 x i1
      v512i1         =  21,   //  512 x i1
      v1024i1        =  22,   // 1024 x i1

      v1i8           =  23,   //  1 x i8
      v2i8           =  24,   //  2 x i8
      v4i8           =  25,   //  4 x i8
      v8i8           =  26,   //  8 x i8
      v16i8          =  27,   // 16 x i8
      v32i8          =  28,   // 32 x i8
      v64i8          =  29,   // 64 x i8
      v128i8         =  30,   //128 x i8
      v256i8         =  31,   //256 x i8

      v1i16          =  32,   //  1 x i16
      v2i16          =  33,   //  2 x i16
      v4i16          =  34,   //  4 x i16
      v8i16          =  35,   //  8 x i16
      v16i16         =  36,   // 16 x i16
      v32i16         =  37,   // 32 x i16
      v64i16         =  38,   // 64 x i16
      v128i16        =  39,   //128 x i16

      v1i32          =  40,   //  1 x i32
      v2i32          =  41,   //  2 x i32
      v4i32          =  42,   //  4 x i32
      v8i32          =  43,   //  8 x i32
      v16i32         =  44,   // 16 x i32
      v32i32         =  45,   // 32 x i32
      v64i32         =  46,   // 64 x i32

      v1i64          =  47,   //  1 x i64
      v2i64          =  48,   //  2 x i64
      v4i64          =  49,   //  4 x i64
      v8i64          =  50,   //  8 x i64
      v16i64         =  51,   // 16 x i64
      v32i64         =  52,   // 32 x i64

      v1i128         =  53,   //  1 x i128

      // Scalable integer types
      nxv1i1         =  54,   // n x  1 x i1
      nxv2i1         =  55,   // n x  2 x i1
      nxv4i1         =  56,   // n x  4 x i1
      nxv8i1         =  57,   // n x  8 x i1
      nxv16i1        =  58,   // n x 16 x i1
      nxv32i1        =  59,   // n x 32 x i1

      nxv1i8         =  60,   // n x  1 x i8
      nxv2i8         =  61,   // n x  2 x i8
      nxv4i8         =  62,   // n x  4 x i8
      nxv8i8         =  63,   // n x  8 x i8
      nxv16i8        =  64,   // n x 16 x i8
      nxv32i8        =  65,   // n x 32 x i8

      nxv1i16        =  66,   // n x  1 x i16
      nxv2i16        =  67,   // n x  2 x i16
      nxv4i16        =  68,   // n x  4 x i16
      nxv8i16        =  69,   // n x  8 x i16
      nxv16i16       =  70,   // n x 16 x i16
      nxv32i16       =  71,   // n x 32 x i16

      nxv1i32        =  72,   // n x  1 x i32
      nxv2i32        =  73,   // n x  2 x i32
      nxv4i32        =  74,   // n x  4 x i32
      nxv8i32        =  75,   // n x  8 x i32
      nxv16i32       =  76,   // n x 16 x i32
      nxv32i32       =  77,   // n x 32 x i32

      nxv1i64        =  78,   // n x  1 x i64
      nxv2i64        =  79,   // n x  2 x i64
      nxv4i64        =  80,   // n x  4 x i64
      nxv8i64        =  81,   // n x  8 x i64
      nxv16i64       =  82,   // n x 16 x i64
      nxv32i64       =  83,   // n x 32 x i64

      FIRST_INTEGER_VECTOR_VALUETYPE = v1i1,
      LAST_INTEGER_VECTOR_VALUETYPE = nxv32i64,

      FIRST_INTEGER_SCALABLE_VALUETYPE = nxv1i1,
      LAST_INTEGER_SCALABLE_VALUETYPE = nxv32i64,

      v2f16          =  84,   //  2 x f16
      v4f16          =  85,   //  4 x f16
      v8f16          =  86,   //  8 x f16
      v1f32          =  87,   //  1 x f32
      v2f32          =  88,   //  2 x f32
      v4f32          =  89,   //  4 x f32
      v8f32          =  90,   //  8 x f32
      v16f32         =  91,   // 16 x f32
      v1f64          =  92,   //  1 x f64
      v2f64          =  93,   //  2 x f64
      v4f64          =  94,   //  4 x f64
      v8f64          =  95,   //  8 x f64

      nxv2f16        =  96,   // n x  2 x f16
      nxv4f16        =  97,   // n x  4 x f16
      nxv8f16        =  98,   // n x  8 x f16
      nxv1f32        =  99,   // n x  1 x f32
      nxv2f32        = 100,   // n x  2 x f32
      nxv4f32        = 101,   // n x  4 x f32
      nxv8f32        = 102,   // n x  8 x f32
      nxv16f32       = 103,   // n x 16 x f32
      nxv1f64        = 104,   // n x  1 x f64
      nxv2f64        = 105,   // n x  2 x f64
      nxv4f64        = 106,   // n x  4 x f64
      nxv8f64        = 107,   // n x  8 x f64
d121 1
a121 1
      LAST_FP_VECTOR_VALUETYPE = nxv8f64,
d123 2
a124 2
      FIRST_FP_SCALABLE_VALUETYPE = nxv2f16,
      LAST_FP_SCALABLE_VALUETYPE = nxv8f64,
d126 1
a126 2
      FIRST_VECTOR_VALUETYPE = v1i1,
      LAST_VECTOR_VALUETYPE  = nxv8f64,
d128 1
a128 1
      x86mmx         =  108,   // This is an X86 MMX value
d130 1
a130 1
      Glue           =  109,   // This glues nodes together during pre-RA sched
d132 3
a134 1
      isVoid         =  110,   // This has no value
d136 2
a137 6
      Untyped        =  111,   // This value takes a register, but has
                               // unspecified type.  The register class
                               // will be determined by the opcode.

      FIRST_VALUETYPE = 1,     // This is always the beginning of the list.
      LAST_VALUETYPE =  112,   // This always remains at the end of the list.
d142 1
a142 1
      MAX_ALLOWED_VALUETYPE = 128,
d144 2
a145 2
      // A value of type llvm::TokenTy
      token          = 248,
d147 2
a148 2
      // This is MDNode or MDString.
      Metadata       = 249,
d150 1
a150 1
      // An int value the size of the pointer of the current
d153 1
a153 1
      iPTRAny        = 250,
d155 1
a155 1
      // A vector with any length and element size. This is used
d158 1
a158 1
      vAny           = 251,
d160 1
a160 1
      // Any floating-point or vector floating-point value. This is used
d163 1
a163 1
      fAny           = 252,
d165 1
a165 1
      // An integer or vector integer value of any bit width. This is
d168 1
a168 1
      iAny           = 253,
d170 1
a170 1
      // An int value the size of the pointer of the current
d172 1
a172 1
      iPTR           = 254,
d174 1
a174 1
      // Any type. This is used for intrinsics that have overloadings.
d176 1
a176 1
      Any            = 255
d179 1
a179 36
    SimpleValueType SimpleTy = INVALID_SIMPLE_VALUE_TYPE;

    // A class to represent the number of elements in a vector
    //
    // For fixed-length vectors, the total number of elements is equal to 'Min'
    // For scalable vectors, the total number of elements is a multiple of 'Min'
    class ElementCount {
    public:
      unsigned Min;
      bool Scalable;

      ElementCount(unsigned Min, bool Scalable)
      : Min(Min), Scalable(Scalable) {}

      ElementCount operator*(unsigned RHS) {
        return { Min * RHS, Scalable };
      }

      ElementCount& operator*=(unsigned RHS) {
        Min *= RHS;
        return *this;
      }

      ElementCount operator/(unsigned RHS) {
        return { Min / RHS, Scalable };
      }

      ElementCount& operator/=(unsigned RHS) {
        Min /= RHS;
        return *this;
      }

      bool operator==(const ElementCount& RHS) {
        return Min == RHS.Min && Scalable == RHS.Scalable;
      }
    };
d181 1
a181 1
    constexpr MVT() = default;
d191 1
a191 1
    /// Return true if this is a valid simple valuetype.
d197 1
a197 1
    /// Return true if this is a FP or a vector FP type.
d205 1
a205 1
    /// Return true if this is an integer or a vector integer type.
d213 2
a214 1
    /// Return true if this is an integer, not including vectors.
d220 1
a220 1
    /// Return true if this is a vector value type.
d226 1
a226 10
    /// Return true if this is a vector value type where the
    /// runtime length is machine dependent
    bool isScalableVector() const {
      return ((SimpleTy >= MVT::FIRST_INTEGER_SCALABLE_VALUETYPE &&
               SimpleTy <= MVT::LAST_INTEGER_SCALABLE_VALUETYPE) ||
              (SimpleTy >= MVT::FIRST_FP_SCALABLE_VALUETYPE &&
               SimpleTy <= MVT::LAST_FP_SCALABLE_VALUETYPE));
    }

    /// Return true if this is a 16-bit vector type.
d232 1
a232 1
    /// Return true if this is a 32-bit vector type.
d234 3
a236 3
      return (SimpleTy == MVT::v32i1 || SimpleTy == MVT::v4i8  ||
              SimpleTy == MVT::v2i16 || SimpleTy == MVT::v1i32 ||
              SimpleTy == MVT::v2f16 || SimpleTy == MVT::v1f32);
d239 1
a239 1
    /// Return true if this is a 64-bit vector type.
d241 4
a244 4
      return (SimpleTy == MVT::v64i1 || SimpleTy == MVT::v8i8  ||
              SimpleTy == MVT::v4i16 || SimpleTy == MVT::v2i32 ||
              SimpleTy == MVT::v1i64 || SimpleTy == MVT::v4f16 ||
              SimpleTy == MVT::v2f32 || SimpleTy == MVT::v1f64);
d247 1
a247 1
    /// Return true if this is a 128-bit vector type.
d255 1
a255 1
    /// Return true if this is a 256-bit vector type.
d262 1
a262 1
    /// Return true if this is a 512-bit vector type.
d270 1
a270 1
    /// Return true if this is a 1024-bit vector type.
d277 1
a277 1
    /// Return true if this is a 1024-bit vector type.
d283 1
a283 1
    /// Return true if this is an overloaded type for TableGen.
d290 1
a290 1
    /// Returns true if the given vector is a power of 2.
d296 2
a297 2
    /// Widens the length of the given vector MVT up to the nearest power of 2
    /// and returns that type.
d307 2
a308 1
    /// If this is a vector, return the element type, otherwise return this.
a316 1
      case v1i1:
d324 1
a324 7
      case v1024i1:
      case nxv1i1:
      case nxv2i1:
      case nxv4i1:
      case nxv8i1:
      case nxv16i1:
      case nxv32i1: return i1;
d333 1
a333 7
      case v256i8:
      case nxv1i8:
      case nxv2i8:
      case nxv4i8:
      case nxv8i8:
      case nxv16i8:
      case nxv32i8: return i8;
d341 1
a341 7
      case v128i16:
      case nxv1i16:
      case nxv2i16:
      case nxv4i16:
      case nxv8i16:
      case nxv16i16:
      case nxv32i16: return i16;
d348 1
a348 7
      case v64i32:
      case nxv1i32:
      case nxv2i32:
      case nxv4i32:
      case nxv8i32:
      case nxv16i32:
      case nxv32i32: return i32;
d354 1
a354 7
      case v32i64:
      case nxv1i64:
      case nxv2i64:
      case nxv4i64:
      case nxv8i64:
      case nxv16i64:
      case nxv32i64: return i64;
d358 1
a358 4
      case v8f16:
      case nxv2f16:
      case nxv4f16:
      case nxv8f16: return f16;
d363 1
a363 6
      case v16f32:
      case nxv1f32:
      case nxv2f32:
      case nxv4f32:
      case nxv8f32:
      case nxv16f32: return f32;
d367 1
a367 5
      case v8f64:
      case nxv1f64:
      case nxv2f64:
      case nxv4f64:
      case nxv8f64: return f64;
d388 1
a388 6
      case v32i64:
      case nxv32i1:
      case nxv32i8:
      case nxv32i16:
      case nxv32i32:
      case nxv32i64: return 32;
d394 1
a394 7
      case v16f32:
      case nxv16i1:
      case nxv16i8:
      case nxv16i16:
      case nxv16i32:
      case nxv16i64:
      case nxv16f32: return 16;
d402 1
a402 9
      case v8f64:
      case nxv8i1:
      case nxv8i8:
      case nxv8i16:
      case nxv8i32:
      case nxv8i64:
      case nxv8f16:
      case nxv8f32:
      case nxv8f64: return 8;
d410 1
a410 9
      case v4f64:
      case nxv4i1:
      case nxv4i8:
      case nxv4i16:
      case nxv4i32:
      case nxv4i64:
      case nxv4f16:
      case nxv4f32:
      case nxv4f64: return 4;
d418 1
a418 10
      case v2f64:
      case nxv2i1:
      case nxv2i8:
      case nxv2i16:
      case nxv2i32:
      case nxv2i64:
      case nxv2f16:
      case nxv2f32:
      case nxv2f64: return 2;
      case v1i1:
d425 1
a425 8
      case v1f64:
      case nxv1i1:
      case nxv1i8:
      case nxv1i16:
      case nxv1i32:
      case nxv1i64:
      case nxv1f32:
      case nxv1f64: return 1;
a428 4
    MVT::ElementCount getVectorElementCount() const {
      return { getVectorNumElements(), isScalableVector() };
    }

d448 3
a450 7
      case i1:
      case v1i1:
      case nxv1i1: return 1;
      case v2i1:
      case nxv2i1: return 2;
      case v4i1:
      case nxv4i1: return 4;
d453 1
a453 3
      case v8i1:
      case nxv1i8:
      case nxv8i1: return 8;
d458 1
a458 4
      case v1i16:
      case nxv16i1:
      case nxv2i8:
      case nxv1i16: return 16;
d466 1
a466 7
      case v1i32:
      case nxv32i1:
      case nxv4i8:
      case nxv2i16:
      case nxv1i32:
      case nxv2f16:
      case nxv1f32: return 32;
d477 1
a477 8
      case v1f64:
      case nxv8i8:
      case nxv4i16:
      case nxv2i32:
      case nxv1i64:
      case nxv4f16:
      case nxv2f32:
      case nxv1f64: return 64;
d489 1
a489 8
      case v2f64:
      case nxv16i8:
      case nxv8i16:
      case nxv4i32:
      case nxv2i64:
      case nxv8f16:
      case nxv4f32:
      case nxv2f64: return 128;
d495 1
a495 7
      case v4f64:
      case nxv32i8:
      case nxv16i16:
      case nxv8i32:
      case nxv4i64:
      case nxv8f32:
      case nxv4f64: return 256;
d502 1
a502 6
      case v8f64:
      case nxv32i16:
      case nxv16i32:
      case nxv8i64:
      case nxv16f32:
      case nxv8f64: return 512;
d507 1
a507 3
      case v16i64:
      case nxv32i32:
      case nxv16i64: return 1024;
d511 1
a511 2
      case v32i64:
      case nxv32i64: return 2048;
d519 2
a520 2
    /// Return the number of bytes overwritten by a store of the specified value
    /// type.
d525 2
a526 2
    /// Return the number of bits overwritten by a store of the specified value
    /// type.
d551 1
a592 1
        if (NumElements == 1)    return MVT::v1i1;
a664 78
    static MVT getScalableVectorVT(MVT VT, unsigned NumElements) {
      switch(VT.SimpleTy) {
        default:
          break;
        case MVT::i1:
          if (NumElements == 1)  return MVT::nxv1i1;
          if (NumElements == 2)  return MVT::nxv2i1;
          if (NumElements == 4)  return MVT::nxv4i1;
          if (NumElements == 8)  return MVT::nxv8i1;
          if (NumElements == 16) return MVT::nxv16i1;
          if (NumElements == 32) return MVT::nxv32i1;
          break;
        case MVT::i8:
          if (NumElements == 1)  return MVT::nxv1i8;
          if (NumElements == 2)  return MVT::nxv2i8;
          if (NumElements == 4)  return MVT::nxv4i8;
          if (NumElements == 8)  return MVT::nxv8i8;
          if (NumElements == 16) return MVT::nxv16i8;
          if (NumElements == 32) return MVT::nxv32i8;
          break;
        case MVT::i16:
          if (NumElements == 1)  return MVT::nxv1i16;
          if (NumElements == 2)  return MVT::nxv2i16;
          if (NumElements == 4)  return MVT::nxv4i16;
          if (NumElements == 8)  return MVT::nxv8i16;
          if (NumElements == 16) return MVT::nxv16i16;
          if (NumElements == 32) return MVT::nxv32i16;
          break;
        case MVT::i32:
          if (NumElements == 1)  return MVT::nxv1i32;
          if (NumElements == 2)  return MVT::nxv2i32;
          if (NumElements == 4)  return MVT::nxv4i32;
          if (NumElements == 8)  return MVT::nxv8i32;
          if (NumElements == 16) return MVT::nxv16i32;
          if (NumElements == 32) return MVT::nxv32i32;
          break;
        case MVT::i64:
          if (NumElements == 1)  return MVT::nxv1i64;
          if (NumElements == 2)  return MVT::nxv2i64;
          if (NumElements == 4)  return MVT::nxv4i64;
          if (NumElements == 8)  return MVT::nxv8i64;
          if (NumElements == 16) return MVT::nxv16i64;
          if (NumElements == 32) return MVT::nxv32i64;
          break;
        case MVT::f16:
          if (NumElements == 2)  return MVT::nxv2f16;
          if (NumElements == 4)  return MVT::nxv4f16;
          if (NumElements == 8)  return MVT::nxv8f16;
          break;
        case MVT::f32:
          if (NumElements == 1)  return MVT::nxv1f32;
          if (NumElements == 2)  return MVT::nxv2f32;
          if (NumElements == 4)  return MVT::nxv4f32;
          if (NumElements == 8)  return MVT::nxv8f32;
          if (NumElements == 16) return MVT::nxv16f32;
          break;
        case MVT::f64:
          if (NumElements == 1)  return MVT::nxv1f64;
          if (NumElements == 2)  return MVT::nxv2f64;
          if (NumElements == 4)  return MVT::nxv4f64;
          if (NumElements == 8)  return MVT::nxv8f64;
          break;
      }
      return (MVT::SimpleValueType)(MVT::INVALID_SIMPLE_VALUE_TYPE);
    }

    static MVT getVectorVT(MVT VT, unsigned NumElements, bool IsScalable) {
      if (IsScalable)
        return getScalableVectorVT(VT, NumElements);
      return getVectorVT(VT, NumElements);
    }

    static MVT getVectorVT(MVT VT, MVT::ElementCount EC) {
      if (EC.Scalable)
        return getScalableVectorVT(VT, EC.Min);
      return getVectorVT(VT, EC.Min);
    }

a673 1

a674 1

a676 1

a683 1

d685 1
a685 1
    using mvt_range = iterator_range<mvt_iterator>;
a692 1

a696 1

a700 1

a704 1

a709 1

a714 10

    static mvt_range integer_scalable_vector_valuetypes() {
      return mvt_range(MVT::FIRST_INTEGER_SCALABLE_VALUETYPE,
              (MVT::SimpleValueType)(MVT::LAST_INTEGER_SCALABLE_VALUETYPE + 1));
    }

    static mvt_range fp_scalable_vector_valuetypes() {
      return mvt_range(MVT::FIRST_FP_SCALABLE_VALUETYPE,
                   (MVT::SimpleValueType)(MVT::LAST_FP_SCALABLE_VALUETYPE + 1));
    }
d718 1
a718 1
} // end namespace llvm
d720 1
a720 1
#endif // LLVM_CODEGEN_MACHINEVALUETYPE_H
@


