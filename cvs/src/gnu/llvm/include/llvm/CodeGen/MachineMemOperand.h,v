head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.4
	OPENBSD_6_2:1.1.1.3.0.2
	OPENBSD_6_2_BASE:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.4
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.55;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.20;	author patrick;	state Exp;
branches;
next	1.1.1.4;
commitid	so2WA7LCP6wbxtYl;

1.1.1.4
date	2017.10.04.20.27.55;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//==- llvm/CodeGen/MachineMemOperand.h - MachineMemOperand class -*- C++ -*-==//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file contains the declaration of the MachineMemOperand class, which is a
// description of a memory reference. It is used to help track dependencies
// in the backend.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_CODEGEN_MACHINEMEMOPERAND_H
#define LLVM_CODEGEN_MACHINEMEMOPERAND_H

#include "llvm/ADT/PointerUnion.h"
#include "llvm/CodeGen/PseudoSourceValue.h"
#include "llvm/IR/Metadata.h"
#include "llvm/IR/Value.h"  // PointerLikeTypeTraits<Value*>
#include "llvm/Support/DataTypes.h"

namespace llvm {

class FoldingSetNodeID;
class MDNode;
class raw_ostream;
class MachineFunction;
class ModuleSlotTracker;

/// MachinePointerInfo - This class contains a discriminated union of
/// information about pointers in memory operands, relating them back to LLVM IR
/// or to virtual locations (such as frame indices) that are exposed during
/// codegen.
struct MachinePointerInfo {
  /// V - This is the IR pointer value for the access, or it is null if unknown.
  /// If this is null, then the access is to a pointer in the default address
  /// space.
  PointerUnion<const Value *, const PseudoSourceValue *> V;

  /// Offset - This is an offset from the base Value*.
  int64_t Offset;

  explicit MachinePointerInfo(const Value *v = nullptr, int64_t offset = 0)
    : V(v), Offset(offset) {}

  explicit MachinePointerInfo(const PseudoSourceValue *v,
                              int64_t offset = 0)
    : V(v), Offset(offset) {}

  MachinePointerInfo getWithOffset(int64_t O) const {
    if (V.isNull()) return MachinePointerInfo();
    if (V.is<const Value*>())
      return MachinePointerInfo(V.get<const Value*>(), Offset+O);
    return MachinePointerInfo(V.get<const PseudoSourceValue*>(), Offset+O);
  }

  /// getAddrSpace - Return the LLVM IR address space number that this pointer
  /// points into.
  unsigned getAddrSpace() const;

  /// getConstantPool - Return a MachinePointerInfo record that refers to the
  /// constant pool.
  static MachinePointerInfo getConstantPool(MachineFunction &MF);

  /// getFixedStack - Return a MachinePointerInfo record that refers to the
  /// the specified FrameIndex.
  static MachinePointerInfo getFixedStack(MachineFunction &MF, int FI,
                                          int64_t Offset = 0);

  /// getJumpTable - Return a MachinePointerInfo record that refers to a
  /// jump table entry.
  static MachinePointerInfo getJumpTable(MachineFunction &MF);

  /// getGOT - Return a MachinePointerInfo record that refers to a
  /// GOT entry.
  static MachinePointerInfo getGOT(MachineFunction &MF);

  /// getStack - stack pointer relative access.
  static MachinePointerInfo getStack(MachineFunction &MF, int64_t Offset);
};


//===----------------------------------------------------------------------===//
/// MachineMemOperand - A description of a memory reference used in the backend.
/// Instead of holding a StoreInst or LoadInst, this class holds the address
/// Value of the reference along with a byte size and offset. This allows it
/// to describe lowered loads and stores. Also, the special PseudoSourceValue
/// objects can be used to represent loads and stores to memory locations
/// that aren't explicit in the regular LLVM IR.
///
class MachineMemOperand {
  MachinePointerInfo PtrInfo;
  uint64_t Size;
  unsigned Flags;
  AAMDNodes AAInfo;
  const MDNode *Ranges;

public:
  /// Flags values. These may be or'd together.
  enum MemOperandFlags {
    /// The memory access reads data.
    MOLoad = 1,
    /// The memory access writes data.
    MOStore = 2,
    /// The memory access is volatile.
    MOVolatile = 4,
    /// The memory access is non-temporal.
    MONonTemporal = 8,
    /// The memory access is invariant.
    MOInvariant = 16,
    // Target hints allow target passes to annotate memory operations.
    MOTargetStartBit = 5,
    MOTargetNumBits = 3,
    // This is the number of bits we need to represent flags.
    MOMaxBits = 8
  };

  /// MachineMemOperand - Construct an MachineMemOperand object with the
  /// specified PtrInfo, flags, size, and base alignment.
  MachineMemOperand(MachinePointerInfo PtrInfo, unsigned flags, uint64_t s,
                    unsigned base_alignment,
                    const AAMDNodes &AAInfo = AAMDNodes(),
                    const MDNode *Ranges = nullptr);

  const MachinePointerInfo &getPointerInfo() const { return PtrInfo; }

  /// getValue - Return the base address of the memory access. This may either
  /// be a normal LLVM IR Value, or one of the special values used in CodeGen.
  /// Special values are those obtained via
  /// PseudoSourceValue::getFixedStack(int), PseudoSourceValue::getStack, and
  /// other PseudoSourceValue member functions which return objects which stand
  /// for frame/stack pointer relative references and other special references
  /// which are not representable in the high-level IR.
  const Value *getValue() const { return PtrInfo.V.dyn_cast<const Value*>(); }

  const PseudoSourceValue *getPseudoValue() const {
    return PtrInfo.V.dyn_cast<const PseudoSourceValue*>();
  }

  const void *getOpaqueValue() const { return PtrInfo.V.getOpaqueValue(); }

  /// getFlags - Return the raw flags of the source value, \see MemOperandFlags.
  unsigned int getFlags() const { return Flags & ((1 << MOMaxBits) - 1); }

  /// Bitwise OR the current flags with the given flags.
  void setFlags(unsigned f) { Flags |= (f & ((1 << MOMaxBits) - 1)); }

  /// getOffset - For normal values, this is a byte offset added to the base
  /// address. For PseudoSourceValue::FPRel values, this is the FrameIndex
  /// number.
  int64_t getOffset() const { return PtrInfo.Offset; }

  unsigned getAddrSpace() const { return PtrInfo.getAddrSpace(); }

  /// getSize - Return the size in bytes of the memory reference.
  uint64_t getSize() const { return Size; }

  /// getAlignment - Return the minimum known alignment in bytes of the
  /// actual memory reference.
  uint64_t getAlignment() const;

  /// getBaseAlignment - Return the minimum known alignment in bytes of the
  /// base address, without the offset.
  uint64_t getBaseAlignment() const { return (1u << (Flags >> MOMaxBits)) >> 1; }

  /// getAAInfo - Return the AA tags for the memory reference.
  AAMDNodes getAAInfo() const { return AAInfo; }

  /// getRanges - Return the range tag for the memory reference.
  const MDNode *getRanges() const { return Ranges; }

  bool isLoad() const { return Flags & MOLoad; }
  bool isStore() const { return Flags & MOStore; }
  bool isVolatile() const { return Flags & MOVolatile; }
  bool isNonTemporal() const { return Flags & MONonTemporal; }
  bool isInvariant() const { return Flags & MOInvariant; }

  /// isUnordered - Returns true if this memory operation doesn't have any
  /// ordering constraints other than normal aliasing. Volatile and atomic
  /// memory operations can't be reordered.
  ///
  /// Currently, we don't model the difference between volatile and atomic
  /// operations. They should retain their ordering relative to all memory
  /// operations.
  bool isUnordered() const { return !isVolatile(); }

  /// refineAlignment - Update this MachineMemOperand to reflect the alignment
  /// of MMO, if it has a greater alignment. This must only be used when the
  /// new alignment applies to all users of this MachineMemOperand.
  void refineAlignment(const MachineMemOperand *MMO);

  /// setValue - Change the SourceValue for this MachineMemOperand. This
  /// should only be used when an object is being relocated and all references
  /// to it are being updated.
  void setValue(const Value *NewSV) { PtrInfo.V = NewSV; }
  void setValue(const PseudoSourceValue *NewSV) { PtrInfo.V = NewSV; }
  void setOffset(int64_t NewOffset) { PtrInfo.Offset = NewOffset; }

  /// Profile - Gather unique data for the object.
  ///
  void Profile(FoldingSetNodeID &ID) const;

  /// Support for operator<<.
  /// @@{
  void print(raw_ostream &OS) const;
  void print(raw_ostream &OS, ModuleSlotTracker &MST) const;
  /// @@}

  friend bool operator==(const MachineMemOperand &LHS,
                         const MachineMemOperand &RHS) {
    return LHS.getValue() == RHS.getValue() &&
           LHS.getPseudoValue() == RHS.getPseudoValue() &&
           LHS.getSize() == RHS.getSize() &&
           LHS.getOffset() == RHS.getOffset() &&
           LHS.getFlags() == RHS.getFlags() &&
           LHS.getAAInfo() == RHS.getAAInfo() &&
           LHS.getRanges() == RHS.getRanges() &&
           LHS.getAlignment() == RHS.getAlignment() &&
           LHS.getAddrSpace() == RHS.getAddrSpace();
  }

  friend bool operator!=(const MachineMemOperand &LHS,
                         const MachineMemOperand &RHS) {
    return !(LHS == RHS);
  }
};

inline raw_ostream &operator<<(raw_ostream &OS, const MachineMemOperand &MRO) {
  MRO.print(OS);
  return OS;
}

} // End llvm namespace

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@a18 1
#include "llvm/ADT/BitmaskEnum.h"
d33 4
a36 3
/// This class contains a discriminated union of information about pointers in
/// memory operands, relating them back to LLVM IR or to virtual locations (such
/// as frame indices) that are exposed during codegen.
d38 1
a38 1
  /// This is the IR pointer value for the access, or it is null if unknown.
d60 2
a61 1
  /// Return the LLVM IR address space number that this pointer points into.
d64 2
a65 1
  /// Return a MachinePointerInfo record that refers to the constant pool.
d68 2
a69 2
  /// Return a MachinePointerInfo record that refers to the specified
  /// FrameIndex.
d73 2
a74 1
  /// Return a MachinePointerInfo record that refers to a jump table entry.
d77 2
a78 1
  /// Return a MachinePointerInfo record that refers to a GOT entry.
d81 1
a81 1
  /// Stack pointer relative access.
d87 1
a87 1
/// A description of a memory reference used in the backend.
d95 6
d103 1
a103 3
  enum Flags : uint16_t {
    // No flags set.
    MONone = 0,
d105 1
a105 1
    MOLoad = 1u << 0,
d107 1
a107 1
    MOStore = 1u << 1,
d109 1
a109 1
    MOVolatile = 1u << 2,
d111 1
a111 1
    MONonTemporal = 1u << 3,
d113 6
a118 8
    MOInvariant = 1u << 4,

    // Reserved for use by target-specific passes.
    MOTargetFlag1 = 1u << 5,
    MOTargetFlag2 = 1u << 6,
    MOTargetFlag3 = 1u << 7,

    LLVM_MARK_AS_BITMASK_ENUM(/* LargestFlag = */ MOTargetFlag3)
d121 3
a123 12
private:
  MachinePointerInfo PtrInfo;
  uint64_t Size;
  Flags FlagVals;
  uint16_t BaseAlignLog2; // log_2(base_alignment) + 1
  AAMDNodes AAInfo;
  const MDNode *Ranges;

public:
  /// Construct a MachineMemOperand object with the specified PtrInfo, flags,
  /// size, and base alignment.
  MachineMemOperand(MachinePointerInfo PtrInfo, Flags flags, uint64_t s,
d130 2
a131 2
  /// Return the base address of the memory access. This may either be a normal
  /// LLVM IR Value, or one of the special values used in CodeGen.
d145 2
a146 2
  /// Return the raw flags of the source value, \see Flags.
  Flags getFlags() const { return FlagVals; }
d149 1
a149 1
  void setFlags(Flags f) { FlagVals |= f; }
d151 3
a153 2
  /// For normal values, this is a byte offset added to the base address.
  /// For PseudoSourceValue::FPRel values, this is the FrameIndex number.
d158 1
a158 1
  /// Return the size in bytes of the memory reference.
d161 2
a162 2
  /// Return the minimum known alignment in bytes of the actual memory
  /// reference.
d165 3
a167 3
  /// Return the minimum known alignment in bytes of the base address, without
  /// the offset.
  uint64_t getBaseAlignment() const { return (1u << BaseAlignLog2) >> 1; }
d169 1
a169 1
  /// Return the AA tags for the memory reference.
d172 1
a172 1
  /// Return the range tag for the memory reference.
d175 9
a183 9
  bool isLoad() const { return FlagVals & MOLoad; }
  bool isStore() const { return FlagVals & MOStore; }
  bool isVolatile() const { return FlagVals & MOVolatile; }
  bool isNonTemporal() const { return FlagVals & MONonTemporal; }
  bool isInvariant() const { return FlagVals & MOInvariant; }

  /// Returns true if this memory operation doesn't have any ordering
  /// constraints other than normal aliasing. Volatile and atomic memory
  /// operations can't be reordered.
d190 3
a192 3
  /// Update this MachineMemOperand to reflect the alignment of MMO, if it has a
  /// greater alignment. This must only be used when the new alignment applies
  /// to all users of this MachineMemOperand.
d195 3
a197 3
  /// Change the SourceValue for this MachineMemOperand. This should only be
  /// used when an object is being relocated and all references to it are being
  /// updated.
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a21 1
#include "llvm/IR/Instructions.h"
a23 1
#include "llvm/Support/AtomicOrdering.h"
d104 2
a105 4
    /// The memory access is dereferenceable (i.e., doesn't trap).
    MODereferenceable = 1u << 4,
    /// The memory access always returns the same value (or traps).
    MOInvariant = 1u << 5,
d108 3
a110 3
    MOTargetFlag1 = 1u << 6,
    MOTargetFlag2 = 1u << 7,
    MOTargetFlag3 = 1u << 8,
a115 12
  /// Atomic information for this memory operation.
  struct MachineAtomicInfo {
    /// Synchronization scope for this memory operation.
    unsigned SynchScope : 1;      // enum SynchronizationScope
    /// Atomic ordering requirements for this memory operation. For cmpxchg
    /// atomic operations, atomic ordering requirements when store occurs.
    unsigned Ordering : 4;        // enum AtomicOrdering
    /// For cmpxchg atomic operations, atomic ordering requirements when store
    /// does not occur.
    unsigned FailureOrdering : 4; // enum AtomicOrdering
  };

a119 1
  MachineAtomicInfo AtomicInfo;
d125 1
a125 4
  /// size, and base alignment. For atomic operations the synchronization scope
  /// and atomic ordering requirements must also be specified. For cmpxchg
  /// atomic operations the atomic ordering requirements when store does not
  /// occur must also be specified.
d129 1
a129 4
                    const MDNode *Ranges = nullptr,
                    SynchronizationScope SynchScope = CrossThread,
                    AtomicOrdering Ordering = AtomicOrdering::NotAtomic,
                    AtomicOrdering FailureOrdering = AtomicOrdering::NotAtomic);
a176 18
  /// Return the synchronization scope for this memory operation.
  SynchronizationScope getSynchScope() const {
    return static_cast<SynchronizationScope>(AtomicInfo.SynchScope);
  }

  /// Return the atomic ordering requirements for this memory operation. For
  /// cmpxchg atomic operations, return the atomic ordering requirements when
  /// store occurs.
  AtomicOrdering getOrdering() const {
    return static_cast<AtomicOrdering>(AtomicInfo.Ordering);
  }

  /// For cmpxchg atomic operations, return the atomic ordering requirements
  /// when store does not occur.
  AtomicOrdering getFailureOrdering() const {
    return static_cast<AtomicOrdering>(AtomicInfo.FailureOrdering);
  }

a180 1
  bool isDereferenceable() const { return FlagVals & MODereferenceable; }
a181 4

  /// Returns true if this operation has an atomic ordering requirement of
  /// unordered or higher, false otherwise.
  bool isAtomic() const { return getOrdering() != AtomicOrdering::NotAtomic; }
@


1.1.1.4
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@d24 1
a24 1
#include "llvm/IR/Value.h" // PointerLikeTypeTraits<Value*>
a61 5
  /// Return true if memory region [V, V+Offset+Size) is known to be
  /// dereferenceable.
  bool isDereferenceable(unsigned Size, LLVMContext &C,
                         const DataLayout &DL) const;

a111 3
    // Targets may override getSerializableMachineMemOperandTargetFlags() to
    // enable MIR serialization/parsing of these flags.  If more of these flags
    // are added, the MIR printing/parsing code will need to be updated as well.
d122 2
a123 2
    /// Synchronization scope ID for this memory operation.
    unsigned SSID : 8;            // SyncScope::ID
d150 1
a150 1
                    SyncScope::ID SSID = SyncScope::System,
d200 3
a202 3
  /// Returns the synchronization scope ID for this memory operation.
  SyncScope::ID getSyncScopeID() const {
    return static_cast<SyncScope::ID>(AtomicInfo.SSID);
@


