head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.3
	OPENBSD_6_2:1.1.1.2.0.2
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.55;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.10.04.20.27.54;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- llvm/ValueSymbolTable.h - Implement a Value Symtab ------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file implements the name/Value symbol table for LLVM.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_IR_VALUESYMBOLTABLE_H
#define LLVM_IR_VALUESYMBOLTABLE_H

#include "llvm/ADT/SmallString.h"
#include "llvm/ADT/StringMap.h"
#include "llvm/IR/Value.h"
#include "llvm/Support/DataTypes.h"

namespace llvm {
  template <typename ValueSubClass> class SymbolTableListTraits;
  class BasicBlock;
  class Function;
  class NamedMDNode;
  class Module;
  class StringRef;

/// This class provides a symbol table of name/value pairs. It is essentially
/// a std::map<std::string,Value*> but has a controlled interface provided by
/// LLVM as well as ensuring uniqueness of names.
///
class ValueSymbolTable {
  friend class Value;
  friend class SymbolTableListTraits<Argument>;
  friend class SymbolTableListTraits<BasicBlock>;
  friend class SymbolTableListTraits<Instruction>;
  friend class SymbolTableListTraits<Function>;
  friend class SymbolTableListTraits<GlobalVariable>;
  friend class SymbolTableListTraits<GlobalAlias>;
/// @@name Types
/// @@{
public:
  /// @@brief A mapping of names to values.
  typedef StringMap<Value*> ValueMap;

  /// @@brief An iterator over a ValueMap.
  typedef ValueMap::iterator iterator;

  /// @@brief A const_iterator over a ValueMap.
  typedef ValueMap::const_iterator const_iterator;

/// @@}
/// @@name Constructors
/// @@{
public:
  ValueSymbolTable() : vmap(0), LastUnique(0) {}
  ~ValueSymbolTable();

/// @@}
/// @@name Accessors
/// @@{
public:
  /// This method finds the value with the given \p Name in the
  /// the symbol table.
  /// @@returns the value associated with the \p Name
  /// @@brief Lookup a named Value.
  Value *lookup(StringRef Name) const { return vmap.lookup(Name); }

  /// @@returns true iff the symbol table is empty
  /// @@brief Determine if the symbol table is empty
  inline bool empty() const { return vmap.empty(); }

  /// @@brief The number of name/type pairs is returned.
  inline unsigned size() const { return unsigned(vmap.size()); }

  /// This function can be used from the debugger to display the
  /// content of the symbol table while debugging.
  /// @@brief Print out symbol table on stderr
  void dump() const;

/// @@}
/// @@name Iteration
/// @@{
public:
  /// @@brief Get an iterator that from the beginning of the symbol table.
  inline iterator begin() { return vmap.begin(); }

  /// @@brief Get a const_iterator that from the beginning of the symbol table.
  inline const_iterator begin() const { return vmap.begin(); }

  /// @@brief Get an iterator to the end of the symbol table.
  inline iterator end() { return vmap.end(); }

  /// @@brief Get a const_iterator to the end of the symbol table.
  inline const_iterator end() const { return vmap.end(); }

  /// @@}
  /// @@name Mutators
  /// @@{
private:
  ValueName *makeUniqueName(Value *V, SmallString<256> &UniqueName);

  /// This method adds the provided value \p N to the symbol table.  The Value
  /// must have a name which is used to place the value in the symbol table.
  /// If the inserted name conflicts, this renames the value.
  /// @@brief Add a named value to the symbol table
  void reinsertValue(Value *V);

  /// createValueName - This method attempts to create a value name and insert
  /// it into the symbol table with the specified name.  If it conflicts, it
  /// auto-renames the name and returns that instead.
  ValueName *createValueName(StringRef Name, Value *V);

  /// This method removes a value from the symbol table.  It leaves the
  /// ValueName attached to the value, but it is no longer inserted in the
  /// symtab.
  void removeValueName(ValueName *V);

  /// @@}
  /// @@name Internal Data
  /// @@{
private:
  ValueMap vmap;                    ///< The map that holds the symbol table.
  mutable uint32_t LastUnique; ///< Counter for tracking unique names

/// @@}
};

} // End llvm namespace

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d17 1
a23 1
  template <unsigned InternalLen> class SmallString;
a41 1
  friend class SymbolTableListTraits<GlobalIFunc>;
@


1.1.1.3
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@d1 1
a1 1
//===- llvm/ValueSymbolTable.h - Implement a Value Symtab -------*- C++ -*-===//
a17 1
#include "llvm/ADT/StringRef.h"
d19 1
a19 1
#include <cstdint>
d22 7
a28 10

class Argument;
class BasicBlock;
class Function;
class GlobalAlias;
class GlobalIFunc;
class GlobalVariable;
class Instruction;
template <unsigned InternalLen> class SmallString;
template <typename ValueSubClass> class SymbolTableListTraits;
d35 1
d38 1
d40 1
a42 4
  friend class SymbolTableListTraits<GlobalVariable>;
  friend class SymbolTableListTraits<Instruction>;
  friend class Value;

d47 1
a47 1
  using ValueMap = StringMap<Value*>;
d50 1
a50 1
  using iterator = ValueMap::iterator;
d53 1
a53 1
  using const_iterator = ValueMap::const_iterator;
d58 2
a59 2

  ValueSymbolTable() : vmap(0) {}
d65 1
a65 1

d87 1
a87 1

d125 1
a125 1

d127 1
a127 1
  mutable uint32_t LastUnique = 0;  ///< Counter for tracking unique names
d132 1
a132 1
} // end namespace llvm
d134 1
a134 1
#endif // LLVM_IR_VALUESYMBOLTABLE_H
@


