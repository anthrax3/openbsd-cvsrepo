head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.3
	OPENBSD_6_2:1.1.1.2.0.2
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.1
date	2017.01.14.19.55.56;	author patrick;	state Exp;
branches
	1.1.1.1;
next	;
commitid	qMUxATnKgqN83Oct;

1.1.1.1
date	2017.01.14.19.55.56;	author patrick;	state Exp;
branches;
next	1.1.1.2;
commitid	qMUxATnKgqN83Oct;

1.1.1.2
date	2017.01.24.08.33.18;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	so2WA7LCP6wbxtYl;

1.1.1.3
date	2017.10.04.20.27.54;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===-------- llvm/GlobalIFunc.h - GlobalIFunc class ------------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
///
/// \brief
/// This file contains the declaration of the GlobalIFunc class, which
/// represents a single indirect function in the IR. Indirect function uses
/// ELF symbol type extension to mark that the address of a declaration should
/// be resolved at runtime by calling a resolver function.
///
//===----------------------------------------------------------------------===//

#ifndef LLVM_IR_GLOBALIFUNC_H
#define LLVM_IR_GLOBALIFUNC_H

#include "llvm/ADT/ilist_node.h"
#include "llvm/IR/GlobalIndirectSymbol.h"

namespace llvm {

class Twine;
class Module;

// Traits class for using GlobalIFunc in symbol table in Module.
template <typename ValueSubClass> class SymbolTableListTraits;

class GlobalIFunc final : public GlobalIndirectSymbol,
                          public ilist_node<GlobalIFunc> {
  friend class SymbolTableListTraits<GlobalIFunc>;
  void operator=(const GlobalIFunc &) = delete;
  GlobalIFunc(const GlobalIFunc &) = delete;

  void setParent(Module *parent);

  GlobalIFunc(Type *Ty, unsigned AddressSpace, LinkageTypes Linkage,
              const Twine &Name, Constant *Resolver, Module *Parent);

public:
  /// If a parent module is specified, the ifunc is automatically inserted into
  /// the end of the specified module's ifunc list.
  static GlobalIFunc *create(Type *Ty, unsigned AddressSpace,
                             LinkageTypes Linkage, const Twine &Name,
                             Constant *Resolver, Module *Parent);

  /// This method unlinks 'this' from the containing module, but does not
  /// delete it.
  void removeFromParent() final;

  /// This method unlinks 'this' from the containing module and deletes it.
  void eraseFromParent() final;

  /// These methods retrieve and set ifunc resolver function.
  void setResolver(Constant *Resolver) {
    setIndirectSymbol(Resolver);
  }
  const Constant *getResolver() const {
    return getIndirectSymbol();
  }
  Constant *getResolver() {
    return getIndirectSymbol();
  }

  // Methods for support type inquiry through isa, cast, and dyn_cast:
  static inline bool classof(const Value *V) {
    return V->getValueID() == Value::GlobalIFuncVal;
  }
};

} // End llvm namespace

#endif
@


1.1.1.1
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a22 1
#include "llvm/IR/Value.h"
d35 4
a43 3
  GlobalIFunc(const GlobalIFunc &) = delete;
  GlobalIFunc &operator=(const GlobalIFunc &) = delete;

d74 1
a74 1
} // end namespace llvm
d76 1
a76 1
#endif // LLVM_IR_GLOBALIFUNC_H
@


1.1.1.3
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@a49 4
  void copyAttributesFrom(const GlobalIFunc *Src) {
    GlobalValue::copyAttributesFrom(Src);
  }

d52 1
a52 1
  void removeFromParent();
d55 1
a55 1
  void eraseFromParent();
d69 1
a69 1
  static bool classof(const Value *V) {
@


