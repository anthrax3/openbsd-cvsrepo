head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.58;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.58;	author patrick;	state Exp;
branches;
next	;
commitid	qMUxATnKgqN83Oct;


desc
@@


1.1
log
@Initial revision
@
text
@//===- Linker.h - Module Linker Interface -----------------------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_LINKER_LINKER_H
#define LLVM_LINKER_LINKER_H

#include "llvm/IR/FunctionInfo.h"
#include "llvm/Linker/IRMover.h"

namespace llvm {
class Module;
class StructType;
class Type;

/// This class provides the core functionality of linking in LLVM. It keeps a
/// pointer to the merged module so far. It doesn't take ownership of the
/// module since it is assumed that the user of this class will want to do
/// something with it after the linking.
class Linker {
  IRMover Mover;

public:
  enum Flags {
    None = 0,
    OverrideFromSrc = (1 << 0),
    LinkOnlyNeeded = (1 << 1),
    InternalizeLinkedSymbols = (1 << 2)
  };

  Linker(Module &M);

  /// \brief Link \p Src into the composite.
  ///
  /// Passing OverrideSymbols as true will have symbols from Src
  /// shadow those in the Dest.
  /// For ThinLTO function importing/exporting the \p FunctionInfoIndex
  /// is passed. If \p FunctionsToImport is provided, only the functions that
  /// are part of the set will be imported from the source module.
  /// The \p ValIDToTempMDMap is populated by the linker when function
  /// importing is performed.
  ///
  /// Returns true on error.
  bool linkInModule(std::unique_ptr<Module> Src, unsigned Flags = Flags::None,
                    const FunctionInfoIndex *Index = nullptr,
                    DenseSet<const GlobalValue *> *FunctionsToImport = nullptr,
                    DenseMap<unsigned, MDNode *> *ValIDToTempMDMap = nullptr);

  /// This exists to implement the deprecated LLVMLinkModules C api. Don't use
  /// for anything else.
  bool linkInModuleForCAPI(Module &Src);

  static bool linkModules(Module &Dest, std::unique_ptr<Module> Src,
                          unsigned Flags = Flags::None);

  /// \brief Link metadata from \p Src into the composite. The source is
  /// destroyed.
  ///
  /// The \p ValIDToTempMDMap sound have been populated earlier during function
  /// importing from \p Src.
  bool linkInMetadata(Module &Src,
                      DenseMap<unsigned, MDNode *> *ValIDToTempMDMap);
};

/// Perform in-place global value handling on the given Module for
/// exported local functions renamed and promoted for ThinLTO.
bool renameModuleForThinLTO(Module &M, const FunctionInfoIndex *Index);

} // End llvm namespace

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d13 1
d33 1
a33 4
    InternalizeLinkedSymbols = (1 << 2),
    /// Don't force link referenced linkonce definitions, import declaration.
    DontForceLinkLinkonceODR = (1 << 3)

d42 2
a43 2
  /// For ThinLTO function importing/exporting the \p ModuleSummaryIndex
  /// is passed. If \p GlobalsToImport is provided, only the globals that
d45 2
d50 7
a56 1
                    DenseSet<const GlobalValue *> *GlobalsToImport = nullptr);
d60 8
d69 4
@

