head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.2
	OPENBSD_6_2:1.1.1.1.0.2
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.4
	OPENBSD_6_1_BASE:1.1.1.1
	LLVM_4_0_0:1.1.1.1
	LLVM_4_0_0_RC1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.1
date	2017.01.24.08.33.38;	author patrick;	state Exp;
branches
	1.1.1.1;
next	;
commitid	so2WA7LCP6wbxtYl;

1.1.1.1
date	2017.01.24.08.33.38;	author patrick;	state Exp;
branches;
next	1.1.1.2;
commitid	so2WA7LCP6wbxtYl;

1.1.1.2
date	2017.10.04.20.28.11;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===-Caching.cpp - LLVM Link Time Optimizer Cache Handling ---------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file implements the Caching for ThinLTO.
//
//===----------------------------------------------------------------------===//

#include "llvm/LTO/Caching.h"
#include "llvm/ADT/StringExtras.h"
#include "llvm/Support/FileSystem.h"
#include "llvm/Support/MemoryBuffer.h"
#include "llvm/Support/Path.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;
using namespace llvm::lto;

static void commitEntry(StringRef TempFilename, StringRef EntryPath) {
  // Rename to final destination (hopefully race condition won't matter here)
  auto EC = sys::fs::rename(TempFilename, EntryPath);
  if (EC) {
    // Renaming failed, probably not the same filesystem, copy and delete.
    // FIXME: Avoid needing to do this by creating the temporary file in the
    // cache directory.
    {
      auto ReloadedBufferOrErr = MemoryBuffer::getFile(TempFilename);
      if (auto EC = ReloadedBufferOrErr.getError())
        report_fatal_error(Twine("Failed to open temp file '") + TempFilename +
                           "': " + EC.message() + "\n");

      raw_fd_ostream OS(EntryPath, EC, sys::fs::F_None);
      if (EC)
        report_fatal_error(Twine("Failed to open ") + EntryPath +
                           " to save cached entry\n");
      // I'm not sure what are the guarantee if two processes are doing this
      // at the same time.
      OS << (*ReloadedBufferOrErr)->getBuffer();
    }
    sys::fs::remove(TempFilename);
  }
}

NativeObjectCache lto::localCache(std::string CacheDirectoryPath,
                                  AddFileFn AddFile) {
  return [=](unsigned Task, StringRef Key) -> AddStreamFn {
    // First, see if we have a cache hit.
    SmallString<64> EntryPath;
    sys::path::append(EntryPath, CacheDirectoryPath, Key);
    if (sys::fs::exists(EntryPath)) {
      AddFile(Task, EntryPath);
      return AddStreamFn();
    }

    // This native object stream is responsible for commiting the resulting
    // file to the cache and calling AddFile to add it to the link.
    struct CacheStream : NativeObjectStream {
      AddFileFn AddFile;
      std::string TempFilename;
      std::string EntryPath;
      unsigned Task;

      CacheStream(std::unique_ptr<raw_pwrite_stream> OS, AddFileFn AddFile,
                  std::string TempFilename, std::string EntryPath,
                  unsigned Task)
          : NativeObjectStream(std::move(OS)), AddFile(AddFile),
            TempFilename(TempFilename), EntryPath(EntryPath), Task(Task) {}

      ~CacheStream() {
        // Make sure the file is closed before committing it.
        OS.reset();
        commitEntry(TempFilename, EntryPath);
        AddFile(Task, EntryPath);
      }
    };

    return [=](size_t Task) -> std::unique_ptr<NativeObjectStream> {
      // Write to a temporary to avoid race condition
      int TempFD;
      SmallString<64> TempFilename;
      std::error_code EC =
          sys::fs::createTemporaryFile("Thin", "tmp.o", TempFD, TempFilename);
      if (EC) {
        errs() << "Error: " << EC.message() << "\n";
        report_fatal_error("ThinLTO: Can't get a temporary file");
      }

      // This CacheStream will move the temporary file into the cache when done.
      return llvm::make_unique<CacheStream>(
          llvm::make_unique<raw_fd_ostream>(TempFD, /* ShouldClose */ true),
          AddFile, TempFilename.str(), EntryPath.str(), Task);
    };
  };
}
@


1.1.1.1
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@@


1.1.1.2
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@a15 1
#include "llvm/Support/Errc.h"
d24 24
a47 4
Expected<NativeObjectCache> lto::localCache(StringRef CacheDirectoryPath,
                                            AddBufferFn AddBuffer) {
  if (std::error_code EC = sys::fs::create_directories(CacheDirectoryPath))
    return errorCodeToError(EC);
d49 2
d52 1
a52 2
    // This choice of file name allows the cache to be pruned (see pruneCache()
    // in include/llvm/Support/CachePruning.h).
d54 3
a56 6
    sys::path::append(EntryPath, CacheDirectoryPath, "llvmcache-" + Key);
    // First, see if we have a cache hit.
    ErrorOr<std::unique_ptr<MemoryBuffer>> MBOrErr =
        MemoryBuffer::getFile(EntryPath);
    if (MBOrErr) {
      AddBuffer(Task, std::move(*MBOrErr));
a59 4
    if (MBOrErr.getError() != errc::no_such_file_or_directory)
      report_fatal_error(Twine("Failed to open cache file ") + EntryPath +
                         ": " + MBOrErr.getError().message() + "\n");

d61 1
a61 1
    // file to the cache and calling AddBuffer to add it to the link.
d63 1
a63 1
      AddBufferFn AddBuffer;
d68 1
a68 1
      CacheStream(std::unique_ptr<raw_pwrite_stream> OS, AddBufferFn AddBuffer,
d71 2
a72 3
          : NativeObjectStream(std::move(OS)), AddBuffer(std::move(AddBuffer)),
            TempFilename(std::move(TempFilename)),
            EntryPath(std::move(EntryPath)), Task(Task) {}
a74 3
        // FIXME: This code could race with the cache pruner, but it is unlikely
        // that the cache pruner will choose to remove a newly created file.

d77 2
a78 11
        // This is atomic on POSIX systems.
        if (auto EC = sys::fs::rename(TempFilename, EntryPath))
          report_fatal_error(Twine("Failed to rename temporary file ") +
                             TempFilename + ": " + EC.message() + "\n");

        ErrorOr<std::unique_ptr<MemoryBuffer>> MBOrErr =
            MemoryBuffer::getFile(EntryPath);
        if (!MBOrErr)
          report_fatal_error(Twine("Failed to open cache file ") + EntryPath +
                             ": " + MBOrErr.getError().message() + "\n");
        AddBuffer(Task, std::move(*MBOrErr));
d85 1
a85 2
      SmallString<64> TempFilenameModel, TempFilename;
      sys::path::append(TempFilenameModel, CacheDirectoryPath, "Thin-%%%%%%.tmp.o");
d87 1
a87 2
          sys::fs::createUniqueFile(TempFilenameModel, TempFD, TempFilename,
                                    sys::fs::owner_read | sys::fs::owner_write);
d96 1
a96 1
          AddBuffer, TempFilename.str(), EntryPath.str(), Task);
@

