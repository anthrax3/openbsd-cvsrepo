head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.2.0.2
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.47.02;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.02;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.24.08.33.35;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===- FileOutputBuffer.cpp - File Output Buffer ----------------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// Utility for creating a in-memory buffer that will be written to a file.
//
//===----------------------------------------------------------------------===//

#include "llvm/Support/FileOutputBuffer.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/ADT/SmallString.h"
#include "llvm/Support/Errc.h"
#include "llvm/Support/Signals.h"
#include <system_error>

#if !defined(_MSC_VER) && !defined(__MINGW32__)
#include <unistd.h>
#else
#include <io.h>
#endif

using llvm::sys::fs::mapped_file_region;

namespace llvm {
FileOutputBuffer::FileOutputBuffer(std::unique_ptr<mapped_file_region> R,
                                   StringRef Path, StringRef TmpPath)
    : Region(std::move(R)), FinalPath(Path), TempPath(TmpPath) {}

FileOutputBuffer::~FileOutputBuffer() {
  sys::fs::remove(Twine(TempPath));
}

ErrorOr<std::unique_ptr<FileOutputBuffer>>
FileOutputBuffer::create(StringRef FilePath, size_t Size, unsigned Flags) {
  // If file already exists, it must be a regular file (to be mappable).
  sys::fs::file_status Stat;
  std::error_code EC = sys::fs::status(FilePath, Stat);
  switch (Stat.type()) {
    case sys::fs::file_type::file_not_found:
      // If file does not exist, we'll create one.
      break;
    case sys::fs::file_type::regular_file: {
        // If file is not currently writable, error out.
        // FIXME: There is no sys::fs:: api for checking this.
        // FIXME: In posix, you use the access() call to check this.
      }
      break;
    default:
      if (EC)
        return EC;
      else
        return make_error_code(errc::operation_not_permitted);
  }

  // Delete target file.
  EC = sys::fs::remove(FilePath);
  if (EC)
    return EC;

  unsigned Mode = sys::fs::all_read | sys::fs::all_write;
  // If requested, make the output file executable.
  if (Flags & F_executable)
    Mode |= sys::fs::all_exe;

  // Create new file in same directory but with random name.
  SmallString<128> TempFilePath;
  int FD;
  EC = sys::fs::createUniqueFile(Twine(FilePath) + ".tmp%%%%%%%", FD,
                                 TempFilePath, Mode);
  if (EC)
    return EC;

  sys::RemoveFileOnSignal(TempFilePath);

#ifndef LLVM_ON_WIN32
  // On Windows, CreateFileMapping (the mmap function on Windows)
  // automatically extends the underlying file. We don't need to
  // extend the file beforehand. _chsize (ftruncate on Windows) is
  // pretty slow just like it writes specified amount of bytes,
  // so we should avoid calling that.
  EC = sys::fs::resize_file(FD, Size);
  if (EC)
    return EC;
#endif

  auto MappedFile = llvm::make_unique<mapped_file_region>(
      FD, mapped_file_region::readwrite, Size, 0, EC);
  int Ret = close(FD);
  if (EC)
    return EC;
  if (Ret)
    return std::error_code(errno, std::generic_category());

  std::unique_ptr<FileOutputBuffer> Buf(
      new FileOutputBuffer(std::move(MappedFile), FilePath, TempFilePath));
  return std::move(Buf);
}

std::error_code FileOutputBuffer::commit() {
  // Unmap buffer, letting OS flush dirty pages to file on disk.
  Region.reset();


  // Rename file to final name.
  std::error_code EC = sys::fs::rename(Twine(TempPath), Twine(FinalPath));
  sys::DontRemoveFileOnSignal(TempPath);
  return EC;
}
} // namespace
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a17 1
#include "llvm/Support/Path.h"
d31 2
a32 4
                                   StringRef Path, StringRef TmpPath,
                                   bool IsRegular)
    : Region(std::move(R)), FinalPath(Path), TempPath(TmpPath),
      IsRegular(IsRegular) {}
a34 3
  // Close the mapping before deleting the temp file, so that the removal
  // succeeds.
  Region.reset();
d40 1
a40 1
  // Check file is not a regular file, in which case we cannot remove it.
a42 1
  bool IsRegular = true;
d56 2
a57 1
      IsRegular = false;
d60 9
a68 6
  if (IsRegular) {
    // Delete target file.
    EC = sys::fs::remove(FilePath);
    if (EC)
      return EC;
  }
d70 1
d73 2
a74 16
  if (IsRegular) {
    unsigned Mode = sys::fs::all_read | sys::fs::all_write;
    // If requested, make the output file executable.
    if (Flags & F_executable)
      Mode |= sys::fs::all_exe;
    // Create new file in same directory but with random name.
    EC = sys::fs::createUniqueFile(Twine(FilePath) + ".tmp%%%%%%%", FD,
                                   TempFilePath, Mode);
  } else {
    // Create a temporary file. Since this is a special file, we will not move
    // it and the new file can be in another filesystem. This avoids trying to
    // create a temporary file in /dev when outputting to /dev/null for example.
    EC = sys::fs::createTemporaryFile(sys::path::filename(FilePath), "", FD,
                                      TempFilePath);
  }

d99 2
a100 2
  std::unique_ptr<FileOutputBuffer> Buf(new FileOutputBuffer(
      std::move(MappedFile), FilePath, TempFilePath, IsRegular));
a107 12
  std::error_code EC;
  if (IsRegular) {
    // Rename file to final name.
    EC = sys::fs::rename(Twine(TempPath), Twine(FinalPath));
    sys::DontRemoveFileOnSignal(TempPath);
  } else {
    EC = sys::fs::copy_file(TempPath, FinalPath);
    std::error_code RMEC = sys::fs::remove(TempPath);
    sys::DontRemoveFileOnSignal(TempPath);
    if (RMEC)
      return RMEC;
  }
d109 3
@

