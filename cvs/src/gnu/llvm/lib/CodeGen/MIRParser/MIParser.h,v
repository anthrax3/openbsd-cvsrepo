head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.3.0.4
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.59;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.59;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.00;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.38;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===- MIParser.h - Machine Instructions Parser ---------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file declares the function that parses the machine instructions.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_LIB_CODEGEN_MIRPARSER_MIPARSER_H
#define LLVM_LIB_CODEGEN_MIRPARSER_MIPARSER_H

#include "llvm/ADT/DenseMap.h"
#include "llvm/ADT/StringRef.h"

namespace llvm {

class BasicBlock;
class MachineBasicBlock;
class MachineInstr;
class MachineFunction;
class MDNode;
struct SlotMapping;
class SMDiagnostic;
class SourceMgr;

struct PerFunctionMIParsingState {
  DenseMap<unsigned, MachineBasicBlock *> MBBSlots;
  DenseMap<unsigned, unsigned> VirtualRegisterSlots;
  DenseMap<unsigned, int> FixedStackObjectSlots;
  DenseMap<unsigned, int> StackObjectSlots;
  DenseMap<unsigned, unsigned> ConstantPoolSlots;
  DenseMap<unsigned, unsigned> JumpTableSlots;
};

/// Parse the machine basic block definitions, and skip the machine
/// instructions.
///
/// This function runs the first parsing pass on the machine function's body.
/// It parses only the machine basic block definitions and creates the machine
/// basic blocks in the given machine function.
///
/// The machine instructions aren't parsed during the first pass because all
/// the machine basic blocks aren't defined yet - this makes it impossible to
/// resolve the machine basic block references.
///
/// Return true if an error occurred.
bool parseMachineBasicBlockDefinitions(MachineFunction &MF, StringRef Src,
                                       PerFunctionMIParsingState &PFS,
                                       const SlotMapping &IRSlots,
                                       SMDiagnostic &Error);

/// Parse the machine instructions.
///
/// This function runs the second parsing pass on the machine function's body.
/// It skips the machine basic block definitions and parses only the machine
/// instructions and basic block attributes like liveins and successors.
///
/// The second parsing pass assumes that the first parsing pass already ran
/// on the given source string.
///
/// Return true if an error occurred.
bool parseMachineInstructions(MachineFunction &MF, StringRef Src,
                              const PerFunctionMIParsingState &PFS,
                              const SlotMapping &IRSlots, SMDiagnostic &Error);

bool parseMBBReference(MachineBasicBlock *&MBB, SourceMgr &SM,
                       MachineFunction &MF, StringRef Src,
                       const PerFunctionMIParsingState &PFS,
                       const SlotMapping &IRSlots, SMDiagnostic &Error);

bool parseNamedRegisterReference(unsigned &Reg, SourceMgr &SM,
                                 MachineFunction &MF, StringRef Src,
                                 const PerFunctionMIParsingState &PFS,
                                 const SlotMapping &IRSlots,
                                 SMDiagnostic &Error);

bool parseVirtualRegisterReference(unsigned &Reg, SourceMgr &SM,
                                   MachineFunction &MF, StringRef Src,
                                   const PerFunctionMIParsingState &PFS,
                                   const SlotMapping &IRSlots,
                                   SMDiagnostic &Error);

bool parseStackObjectReference(int &FI, SourceMgr &SM, MachineFunction &MF,
                               StringRef Src,
                               const PerFunctionMIParsingState &PFS,
                               const SlotMapping &IRSlots, SMDiagnostic &Error);

bool parseMDNode(MDNode *&Node, SourceMgr &SM, MachineFunction &MF,
                 StringRef Src, const PerFunctionMIParsingState &PFS,
                 const SlotMapping &IRSlots, SMDiagnostic &Error);

} // end namespace llvm

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d18 1
a18 1
#include "llvm/ADT/SmallSet.h"
a21 1
class StringRef;
d24 1
a25 2
class MachineInstr;
class MachineRegisterInfo;
a31 4
  MachineFunction &MF;
  SourceMgr *SM;
  const SlotMapping &IRSlots;

a37 5
  /// Hold the generic virtual registers.
  SmallSet<unsigned, 8> GenericVRegs;

  PerFunctionMIParsingState(MachineFunction &MF, SourceMgr &SM,
                            const SlotMapping &IRSlots);
d52 4
a55 2
bool parseMachineBasicBlockDefinitions(PerFunctionMIParsingState &PFS,
                                       StringRef Src, SMDiagnostic &Error);
d67 13
a79 9
bool parseMachineInstructions(const PerFunctionMIParsingState &PFS,
                              StringRef Src, SMDiagnostic &Error);

bool parseMBBReference(const PerFunctionMIParsingState &PFS,
                       MachineBasicBlock *&MBB, StringRef Src,
                       SMDiagnostic &Error);

bool parseNamedRegisterReference(const PerFunctionMIParsingState &PFS,
                                 unsigned &Reg, StringRef Src,
d82 4
a85 2
bool parseVirtualRegisterReference(const PerFunctionMIParsingState &PFS,
                                   unsigned &Reg, StringRef Src,
d88 8
a95 5
bool parseStackObjectReference(const PerFunctionMIParsingState &PFS,
                               int &FI, StringRef Src, SMDiagnostic &Error);

bool parseMDNode(const PerFunctionMIParsingState &PFS, MDNode *&Node,
                 StringRef Src, SMDiagnostic &Error);
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a28 1
class RegisterBank;
a31 14
class TargetRegisterClass;

struct VRegInfo {
  enum uint8_t {
    UNKNOWN, NORMAL, GENERIC, REGBANK
  } Kind = UNKNOWN;
  bool Explicit = false; ///< VReg was explicitly specified in the .mir file.
  union {
    const TargetRegisterClass *RC;
    const RegisterBank *RegBank;
  } D;
  unsigned VReg;
  unsigned PreferredReg = 0;
};
a33 1
  BumpPtrAllocator Allocator;
d39 1
a39 1
  DenseMap<unsigned, VRegInfo*> VRegInfos;
d44 2
a48 2

  VRegInfo &getVRegInfo(unsigned VReg);
d76 2
a77 2
bool parseMachineInstructions(PerFunctionMIParsingState &PFS, StringRef Src,
                              SMDiagnostic &Error);
d79 1
a79 1
bool parseMBBReference(PerFunctionMIParsingState &PFS,
d83 3
a85 6
bool parseRegisterReference(PerFunctionMIParsingState &PFS,
                            unsigned &Reg, StringRef Src,
                            SMDiagnostic &Error);

bool parseNamedRegisterReference(PerFunctionMIParsingState &PFS, unsigned &Reg,
                                 StringRef Src, SMDiagnostic &Error);
d87 2
a88 2
bool parseVirtualRegisterReference(PerFunctionMIParsingState &PFS,
                                   VRegInfo *&Info, StringRef Src,
d91 2
a92 2
bool parseStackObjectReference(PerFunctionMIParsingState &PFS, int &FI,
                               StringRef Src, SMDiagnostic &Error);
d94 2
a95 2
bool parseMDNode(PerFunctionMIParsingState &PFS, MDNode *&Node, StringRef Src,
                 SMDiagnostic &Error);
@


