head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.01;	author patrick;	state Exp;
branches;
next	;
commitid	qMUxATnKgqN83Oct;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- IR/Statepoint.cpp -- gc.statepoint utilities ---  -----------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// 
//===----------------------------------------------------------------------===//

#include "llvm/IR/Function.h"
#include "llvm/IR/Constant.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/Statepoint.h"
#include "llvm/Support/CommandLine.h"

using namespace std;
using namespace llvm;

bool llvm::isStatepoint(const ImmutableCallSite &CS) {
  if (!CS.getInstruction()) {
    // This is not a call site
    return false;
  }

  const Function *F = CS.getCalledFunction();
  return (F && F->getIntrinsicID() == Intrinsic::experimental_gc_statepoint);
}
bool llvm::isStatepoint(const Value *inst) {
  if (isa<InvokeInst>(inst) || isa<CallInst>(inst)) {
    ImmutableCallSite CS(inst);
    return isStatepoint(CS);
  }
  return false;
}
bool llvm::isStatepoint(const Value &inst) {
  return isStatepoint(&inst);
}

bool llvm::isGCRelocate(const ImmutableCallSite &CS) {
  return CS.getInstruction() && isa<GCRelocateInst>(CS.getInstruction());
}

bool llvm::isGCResult(const ImmutableCallSite &CS) {
  if (!CS.getInstruction()) {
    // This is not a call site
    return false;
  }

  return isGCResult(CS.getInstruction());
}
bool llvm::isGCResult(const Value *inst) {
  if (const CallInst *call = dyn_cast<CallInst>(inst)) {
    if (Function *F = call->getCalledFunction()) {
      return F->getIntrinsicID() == Intrinsic::experimental_gc_result;
    }
  }
  return false;
}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d10 1
a10 3
// This file contains some utility functions to help recognize gc.statepoint
// intrinsics.
//
d13 3
d17 1
d19 1
a19 2
#include "llvm/IR/Function.h"

d22 12
a33 14
static const Function *getCalledFunction(ImmutableCallSite CS) {
  if (!CS.getInstruction())
    return nullptr;
  return CS.getCalledFunction();
}

bool llvm::isStatepoint(ImmutableCallSite CS) {
  if (auto *F = getCalledFunction(CS))
    return F->getIntrinsicID() == Intrinsic::experimental_gc_statepoint;
  return false;
}

bool llvm::isStatepoint(const Value *V) {
  if (auto CS = ImmutableCallSite(V))
d35 1
d38 2
a39 3

bool llvm::isStatepoint(const Value &V) {
  return isStatepoint(&V);
d42 1
a42 1
bool llvm::isGCRelocate(ImmutableCallSite CS) {
d46 15
a60 27
bool llvm::isGCResult(ImmutableCallSite CS) {
  return CS.getInstruction() && isa<GCResultInst>(CS.getInstruction());
}

bool llvm::isStatepointDirectiveAttr(Attribute Attr) {
  return Attr.hasAttribute("statepoint-id") ||
         Attr.hasAttribute("statepoint-num-patch-bytes");
}

StatepointDirectives llvm::parseStatepointDirectivesFromAttrs(AttributeSet AS) {
  StatepointDirectives Result;

  Attribute AttrID =
      AS.getAttribute(AttributeSet::FunctionIndex, "statepoint-id");
  uint64_t StatepointID;
  if (AttrID.isStringAttribute())
    if (!AttrID.getValueAsString().getAsInteger(10, StatepointID))
      Result.StatepointID = StatepointID;

  uint32_t NumPatchBytes;
  Attribute AttrNumPatchBytes = AS.getAttribute(AttributeSet::FunctionIndex,
                                                "statepoint-num-patch-bytes");
  if (AttrNumPatchBytes.isStringAttribute())
    if (!AttrNumPatchBytes.getValueAsString().getAsInteger(10, NumPatchBytes))
      Result.NumPatchBytes = NumPatchBytes;

  return Result;
@

