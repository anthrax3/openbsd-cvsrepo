head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.01;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.33;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===- MachOUniversal.cpp - Mach-O universal binary -------------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines the MachOUniversalBinary class.
//
//===----------------------------------------------------------------------===//

#include "llvm/Object/MachOUniversal.h"
#include "llvm/Object/Archive.h"
#include "llvm/Object/MachO.h"
#include "llvm/Object/ObjectFile.h"
#include "llvm/Support/Casting.h"
#include "llvm/Support/Host.h"
#include "llvm/Support/MemoryBuffer.h"

using namespace llvm;
using namespace object;

template<typename T>
static void SwapStruct(T &Value);

template<>
void SwapStruct(MachO::fat_header &H) {
  sys::swapByteOrder(H.magic);
  sys::swapByteOrder(H.nfat_arch);
}

template<>
void SwapStruct(MachO::fat_arch &H) {
  sys::swapByteOrder(H.cputype);
  sys::swapByteOrder(H.cpusubtype);
  sys::swapByteOrder(H.offset);
  sys::swapByteOrder(H.size);
  sys::swapByteOrder(H.align);
}

template<typename T>
static T getUniversalBinaryStruct(const char *Ptr) {
  T Res;
  memcpy(&Res, Ptr, sizeof(T));
  // Universal binary headers have big-endian byte order.
  if (sys::IsLittleEndianHost)
    SwapStruct(Res);
  return Res;
}

MachOUniversalBinary::ObjectForArch::ObjectForArch(
    const MachOUniversalBinary *Parent, uint32_t Index)
    : Parent(Parent), Index(Index) {
  if (!Parent || Index >= Parent->getNumberOfObjects()) {
    clear();
  } else {
    // Parse object header.
    StringRef ParentData = Parent->getData();
    const char *HeaderPos = ParentData.begin() + sizeof(MachO::fat_header) +
                            Index * sizeof(MachO::fat_arch);
    Header = getUniversalBinaryStruct<MachO::fat_arch>(HeaderPos);
    if (ParentData.size() < Header.offset + Header.size) {
      clear();
    }
  }
}

ErrorOr<std::unique_ptr<MachOObjectFile>>
MachOUniversalBinary::ObjectForArch::getAsObjectFile() const {
  if (!Parent)
    return object_error::parse_failed;

  StringRef ParentData = Parent->getData();
  StringRef ObjectData = ParentData.substr(Header.offset, Header.size);
  StringRef ObjectName = Parent->getFileName();
  MemoryBufferRef ObjBuffer(ObjectData, ObjectName);
  return ObjectFile::createMachOObjectFile(ObjBuffer);
}

ErrorOr<std::unique_ptr<Archive>>
MachOUniversalBinary::ObjectForArch::getAsArchive() const {
  if (!Parent)
    return object_error::parse_failed;

  StringRef ParentData = Parent->getData();
  StringRef ObjectData = ParentData.substr(Header.offset, Header.size);
  StringRef ObjectName = Parent->getFileName();
  MemoryBufferRef ObjBuffer(ObjectData, ObjectName);
  return Archive::create(ObjBuffer);
}

void MachOUniversalBinary::anchor() { }

ErrorOr<std::unique_ptr<MachOUniversalBinary>>
MachOUniversalBinary::create(MemoryBufferRef Source) {
  std::error_code EC;
  std::unique_ptr<MachOUniversalBinary> Ret(
      new MachOUniversalBinary(Source, EC));
  if (EC)
    return EC;
  return std::move(Ret);
}

MachOUniversalBinary::MachOUniversalBinary(MemoryBufferRef Source,
                                           std::error_code &ec)
    : Binary(Binary::ID_MachOUniversalBinary, Source), NumberOfObjects(0) {
  if (Data.getBufferSize() < sizeof(MachO::fat_header)) {
    ec = object_error::invalid_file_type;
    return;
  }
  // Check for magic value and sufficient header size.
  StringRef Buf = getData();
  MachO::fat_header H= getUniversalBinaryStruct<MachO::fat_header>(Buf.begin());
  NumberOfObjects = H.nfat_arch;
  uint32_t MinSize = sizeof(MachO::fat_header) +
                     sizeof(MachO::fat_arch) * NumberOfObjects;
  if (H.magic != MachO::FAT_MAGIC || Buf.size() < MinSize) {
    ec = object_error::parse_failed;
    return;
  }
  ec = std::error_code();
}

ErrorOr<std::unique_ptr<MachOObjectFile>>
MachOUniversalBinary::getObjectForArch(StringRef ArchName) const {
  if (Triple(ArchName).getArch() == Triple::ArchType::UnknownArch)
    return object_error::arch_not_found;

  for (object_iterator I = begin_objects(), E = end_objects(); I != E; ++I) {
    if (I->getArchTypeName() == ArchName)
      return I->getAsObjectFile();
  }
  return object_error::arch_not_found;
}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d25 16
a40 5
static Error
malformedError(Twine Msg) {
  std::string StringMsg = "truncated or malformed fat file (" + Msg.str() + ")";
  return make_error<GenericBinaryError>(std::move(StringMsg),
                                        object_error::parse_failed);
d49 1
a49 1
    swapStruct(Res);
d61 5
a65 14
    if (Parent->getMagic() == MachO::FAT_MAGIC) {
      const char *HeaderPos = ParentData.begin() + sizeof(MachO::fat_header) +
                              Index * sizeof(MachO::fat_arch);
      Header = getUniversalBinaryStruct<MachO::fat_arch>(HeaderPos);
      if (ParentData.size() < Header.offset + Header.size) {
        clear();
      }
    } else { // Parent->getMagic() == MachO::FAT_MAGIC_64
      const char *HeaderPos = ParentData.begin() + sizeof(MachO::fat_header) +
                              Index * sizeof(MachO::fat_arch_64);
      Header64 = getUniversalBinaryStruct<MachO::fat_arch_64>(HeaderPos);
      if (ParentData.size() < Header64.offset + Header64.size) {
        clear();
      }
d70 1
a70 1
Expected<std::unique_ptr<MachOObjectFile>>
d73 1
a73 2
    report_fatal_error("MachOUniversalBinary::ObjectForArch::getAsObjectFile() "
                       "called when Parent is a nullptr");
d76 1
a76 5
  StringRef ObjectData;
  if (Parent->getMagic() == MachO::FAT_MAGIC)
    ObjectData = ParentData.substr(Header.offset, Header.size);
  else // Parent->getMagic() == MachO::FAT_MAGIC_64
    ObjectData = ParentData.substr(Header64.offset, Header64.size);
d82 1
a82 1
Expected<std::unique_ptr<Archive>>
d85 1
a85 2
    report_fatal_error("MachOUniversalBinary::ObjectForArch::getAsArchive() "
                       "called when Parent is a nullptr");
d88 1
a88 5
  StringRef ObjectData;
  if (Parent->getMagic() == MachO::FAT_MAGIC)
    ObjectData = ParentData.substr(Header.offset, Header.size);
  else // Parent->getMagic() == MachO::FAT_MAGIC_64
    ObjectData = ParentData.substr(Header64.offset, Header64.size);
d96 1
a96 1
Expected<std::unique_ptr<MachOUniversalBinary>>
d98 1
a98 1
  Error Err;
d100 3
a102 3
      new MachOUniversalBinary(Source, Err));
  if (Err)
    return std::move(Err);
d106 3
a108 4
MachOUniversalBinary::MachOUniversalBinary(MemoryBufferRef Source, Error &Err)
    : Binary(Binary::ID_MachOUniversalBinary, Source), Magic(0),
      NumberOfObjects(0) {
  ErrorAsOutParameter ErrAsOutParam(Err);
d110 1
a110 3
    Err = make_error<GenericBinaryError>("File too small to be a Mach-O "
                                         "universal file",
                                         object_error::invalid_file_type);
d115 1
a115 3
  MachO::fat_header H =
      getUniversalBinaryStruct<MachO::fat_header>(Buf.begin());
  Magic = H.magic;
d117 4
a120 13
  uint32_t MinSize = sizeof(MachO::fat_header);
  if (Magic == MachO::FAT_MAGIC)
    MinSize += sizeof(MachO::fat_arch) * NumberOfObjects;
  else if (Magic == MachO::FAT_MAGIC_64)
    MinSize += sizeof(MachO::fat_arch_64) * NumberOfObjects;
  else {
    Err = malformedError("bad magic number");
    return;
  }
  if (Buf.size() < MinSize) {
    Err = malformedError("fat_arch" +
                         Twine(Magic == MachO::FAT_MAGIC ? "" : "_64") +
                         " structs would extend past the end of the file");
d123 1
a123 1
  Err = Error::success();
d126 1
a126 1
Expected<std::unique_ptr<MachOObjectFile>>
d129 1
a129 4
    return make_error<GenericBinaryError>("Unknown architecture "
                                          "named: " +
                                              ArchName,
                                          object_error::arch_not_found);
d135 1
a135 4
  return make_error<GenericBinaryError>("fat file does not "
                                        "contain " +
                                            ArchName,
                                        object_error::arch_not_found);
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a44 1
  // The iterators use Parent as a nullptr and an Index+1 == NumberOfObjects.
d54 3
d61 3
d76 1
a76 2
  uint32_t cputype;
  if (Parent->getMagic() == MachO::FAT_MAGIC) {
d78 1
a78 2
    cputype = Header.cputype;
  } else { // Parent->getMagic() == MachO::FAT_MAGIC_64
a79 2
    cputype = Header64.cputype;
  }
d82 1
a82 1
  return ObjectFile::createMachOObjectFile(ObjBuffer, cputype, Index);
d106 1
a106 1
  Error Err = Error::success();
d117 1
a117 1
  ErrorAsOutParameter ErrAsOutParam(&Err);
a129 4
  if (NumberOfObjects == 0) {
    Err = malformedError("contains zero architecture types");
    return;
  }
a144 62
  for (uint32_t i = 0; i < NumberOfObjects; i++) {
    ObjectForArch A(this, i);
    uint64_t bigSize = A.getOffset();
    bigSize += A.getSize();
    if (bigSize > Buf.size()) {
      Err = malformedError("offset plus size of cputype (" +
        Twine(A.getCPUType()) + ") cpusubtype (" +
        Twine(A.getCPUSubType() & ~MachO::CPU_SUBTYPE_MASK) +
        ") extends past the end of the file");
      return;
    }
#define MAXSECTALIGN 15 /* 2**15 or 0x8000 */
    if (A.getAlign() > MAXSECTALIGN) {
      Err = malformedError("align (2^" + Twine(A.getAlign()) + ") too large "
        "for cputype (" + Twine(A.getCPUType()) + ") cpusubtype (" +
        Twine(A.getCPUSubType() & ~MachO::CPU_SUBTYPE_MASK) +
        ") (maximum 2^" + Twine(MAXSECTALIGN) + ")");
      return;
    }
    if(A.getOffset() % (1 << A.getAlign()) != 0){
      Err = malformedError("offset: " + Twine(A.getOffset()) +
        " for cputype (" + Twine(A.getCPUType()) + ") cpusubtype (" +
        Twine(A.getCPUSubType() & ~MachO::CPU_SUBTYPE_MASK) +
        ") not aligned on it's alignment (2^" + Twine(A.getAlign()) + ")");
      return;
    }
    if (A.getOffset() < MinSize) {
      Err =  malformedError("cputype (" + Twine(A.getCPUType()) + ") "
        "cpusubtype (" + Twine(A.getCPUSubType() & ~MachO::CPU_SUBTYPE_MASK) +
        ") offset " + Twine(A.getOffset()) + " overlaps universal headers");
      return;
    }
  }
  for (uint32_t i = 0; i < NumberOfObjects; i++) {
    ObjectForArch A(this, i);
    for (uint32_t j = i + 1; j < NumberOfObjects; j++) {
      ObjectForArch B(this, j);
      if (A.getCPUType() == B.getCPUType() &&
          (A.getCPUSubType() & ~MachO::CPU_SUBTYPE_MASK) ==
          (B.getCPUSubType() & ~MachO::CPU_SUBTYPE_MASK)) {
        Err = malformedError("contains two of the same architecture (cputype "
          "(" + Twine(A.getCPUType()) + ") cpusubtype (" +
          Twine(A.getCPUSubType() & ~MachO::CPU_SUBTYPE_MASK) + "))");
        return;
      }
      if ((A.getOffset() >= B.getOffset() &&
           A.getOffset() < B.getOffset() + B.getSize()) ||
          (A.getOffset() + A.getSize() > B.getOffset() &&
           A.getOffset() + A.getSize() < B.getOffset() + B.getSize()) ||
          (A.getOffset() <= B.getOffset() &&
           A.getOffset() + A.getSize() >= B.getOffset() + B.getSize())) {
        Err =  malformedError("cputype (" + Twine(A.getCPUType()) + ") "
          "cpusubtype (" + Twine(A.getCPUSubType() & ~MachO::CPU_SUBTYPE_MASK) +
          ") at offset " + Twine(A.getOffset()) + " with a size of " +
          Twine(A.getSize()) + ", overlaps cputype (" + Twine(B.getCPUType()) +
          ") cpusubtype (" + Twine(B.getCPUSubType() & ~MachO::CPU_SUBTYPE_MASK)
          + ") at offset " + Twine(B.getOffset()) + " with a size of "
          + Twine(B.getSize()));
        return;
      }
    }
  }
d156 4
a159 3
  for (auto &Obj : objects())
    if (Obj.getArchFlagName() == ArchName)
      return Obj.getAsObjectFile();
@


