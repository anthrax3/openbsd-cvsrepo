head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.47.02;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.02;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.09;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.34;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@// Simple test for a fuzzer. The fuzzer must find several narrow ranges.
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <cstdio>

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
  if (Size < 14) return 0;
  uint64_t x = 0;
  int64_t  y = 0;
  int z = 0;
  unsigned short a = 0;
  memcpy(&x, Data, 8);
  memcpy(&y, Data + Size - 8, 8);
  memcpy(&z, Data + Size / 2, sizeof(z));
  memcpy(&a, Data + Size / 2 + 4, sizeof(a));

  if (x > 1234567890 &&
      x < 1234567895 &&
      y >= 987654321 &&
      y <= 987654325 &&
      z < -10000 &&
      z >= -10005 &&
      z != -10003 &&
      a == 4242) {
    fprintf(stderr, "BINGO; Found the target: size %zd (%zd, %zd, %d, %d), exiting.\n",
            Size, x, y, z, a);
    exit(1);
  }
  return 0;
}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@a0 3
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.

@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a9 9
extern int AllLines[];

bool PrintOnce(int Line) {
  if (!AllLines[Line])
    fprintf(stderr, "Seen line %d\n", Line);
  AllLines[Line] = 1;
  return true;
}

d11 1
a11 1
  if (Size != 22) return 0;
d14 6
a19 6
  int32_t z = 0;
  uint16_t a = 0;
  memcpy(&x, Data, 8);  // 8
  memcpy(&y, Data + 8, 8);  // 16
  memcpy(&z, Data + 16, sizeof(z));  // 20
  memcpy(&a, Data + 20, sizeof(a));  // 22
d21 8
a28 9
  if (x > 1234567890 && PrintOnce(__LINE__) &&
      x < 1234567895 && PrintOnce(__LINE__) &&
      a == 0x4242 && PrintOnce(__LINE__) &&
      y >= 987654321 && PrintOnce(__LINE__) &&
      y <= 987654325 && PrintOnce(__LINE__) &&
      z < -10000 && PrintOnce(__LINE__) &&
      z >= -10005 && PrintOnce(__LINE__) &&
      z != -10003 && PrintOnce(__LINE__) &&
      true) {
a34 2

int AllLines[__LINE__ + 1];  // Must be the last line.
@


