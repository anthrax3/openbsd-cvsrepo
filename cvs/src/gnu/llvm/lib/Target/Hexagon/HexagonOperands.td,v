head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.4
	OPENBSD_6_2:1.1.1.3.0.2
	OPENBSD_6_2_BASE:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.4
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.03;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.25;	author patrick;	state Exp;
branches;
next	1.1.1.4;
commitid	so2WA7LCP6wbxtYl;

1.1.1.4
date	2017.10.04.20.28.00;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===- HexagonImmediates.td - Hexagon immediate processing -*- tablegen -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illnois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

def s32ImmOperand : AsmOperandClass { let Name = "s32Imm"; }
def s8ImmOperand : AsmOperandClass { let Name = "s8Imm"; }
def s8Imm64Operand : AsmOperandClass { let Name = "s8Imm64"; }
def s6ImmOperand : AsmOperandClass { let Name = "s6Imm"; }
def s4ImmOperand : AsmOperandClass { let Name = "s4Imm"; }
def s4_0ImmOperand : AsmOperandClass { let Name = "s4_0Imm"; }
def s4_1ImmOperand : AsmOperandClass { let Name = "s4_1Imm"; }
def s4_2ImmOperand : AsmOperandClass { let Name = "s4_2Imm"; }
def s4_3ImmOperand : AsmOperandClass { let Name = "s4_3Imm"; }
def s4_6ImmOperand : AsmOperandClass { let Name = "s4_6Imm"; }
def s3_6ImmOperand : AsmOperandClass { let Name = "s3_6Imm"; }
def u64ImmOperand : AsmOperandClass { let Name = "u64Imm"; }
def u32ImmOperand : AsmOperandClass { let Name = "u32Imm"; }
def u26_6ImmOperand : AsmOperandClass { let Name = "u26_6Imm"; }
def u16ImmOperand : AsmOperandClass { let Name = "u16Imm"; }
def u16_0ImmOperand : AsmOperandClass { let Name = "u16_0Imm"; }
def u16_1ImmOperand : AsmOperandClass { let Name = "u16_1Imm"; }
def u16_2ImmOperand : AsmOperandClass { let Name = "u16_2Imm"; }
def u16_3ImmOperand : AsmOperandClass { let Name = "u16_3Imm"; }
def u11_3ImmOperand : AsmOperandClass { let Name = "u11_3Imm"; }
def u10ImmOperand : AsmOperandClass { let Name = "u10Imm"; }
def u9ImmOperand : AsmOperandClass { let Name = "u9Imm"; }
def u8ImmOperand : AsmOperandClass { let Name = "u8Imm"; }
def u7ImmOperand : AsmOperandClass { let Name = "u7Imm"; }
def u6ImmOperand : AsmOperandClass { let Name = "u6Imm"; }
def u6_0ImmOperand : AsmOperandClass { let Name = "u6_0Imm"; }
def u6_1ImmOperand : AsmOperandClass { let Name = "u6_1Imm"; }
def u6_2ImmOperand : AsmOperandClass { let Name = "u6_2Imm"; }
def u6_3ImmOperand : AsmOperandClass { let Name = "u6_3Imm"; }
def u5ImmOperand : AsmOperandClass { let Name = "u5Imm"; }
def u4ImmOperand : AsmOperandClass { let Name = "u4Imm"; }
def u3ImmOperand : AsmOperandClass { let Name = "u3Imm"; }
def u2ImmOperand : AsmOperandClass { let Name = "u2Imm"; }
def u1ImmOperand : AsmOperandClass { let Name = "u1Imm"; }
def n8ImmOperand : AsmOperandClass { let Name = "n8Imm"; }
// Immediate operands.

let OperandType = "OPERAND_IMMEDIATE",
    DecoderMethod = "unsignedImmDecoder" in {
  def s32Imm : Operand<i32> { let ParserMatchClass = s32ImmOperand;
                              let DecoderMethod = "s32ImmDecoder"; }
  def s8Imm : Operand<i32> { let ParserMatchClass = s8ImmOperand;
                             let DecoderMethod = "s8ImmDecoder"; }
  def s8Imm64 : Operand<i64>  { let ParserMatchClass = s8Imm64Operand;
                                let DecoderMethod = "s8ImmDecoder"; }
  def s6Imm : Operand<i32> { let ParserMatchClass = s6ImmOperand;
                             let DecoderMethod = "s6_0ImmDecoder"; }
  def s6_3Imm : Operand<i32>;
  def s4Imm : Operand<i32> { let ParserMatchClass = s4ImmOperand;
                             let DecoderMethod = "s4_0ImmDecoder"; }
  def s4_0Imm : Operand<i32> { let ParserMatchClass = s4_0ImmOperand;
                               let DecoderMethod = "s4_0ImmDecoder"; }
  def s4_1Imm : Operand<i32> { let ParserMatchClass = s4_1ImmOperand;
                               let DecoderMethod = "s4_1ImmDecoder"; }
  def s4_2Imm : Operand<i32> { let ParserMatchClass = s4_2ImmOperand;
                               let DecoderMethod = "s4_2ImmDecoder"; }
  def s4_3Imm : Operand<i32> { let ParserMatchClass = s4_3ImmOperand;
                               let DecoderMethod = "s4_3ImmDecoder"; }
  def u64Imm : Operand<i64> { let ParserMatchClass = u64ImmOperand; }
  def u32Imm : Operand<i32> { let ParserMatchClass = u32ImmOperand; }
  def u26_6Imm : Operand<i32> { let ParserMatchClass = u26_6ImmOperand; }
  def u16Imm : Operand<i32> { let ParserMatchClass = u16ImmOperand; }
  def u16_0Imm : Operand<i32> { let ParserMatchClass = u16_0ImmOperand; }
  def u16_1Imm : Operand<i32> { let ParserMatchClass = u16_1ImmOperand; }
  def u16_2Imm : Operand<i32> { let ParserMatchClass = u16_2ImmOperand; }
  def u16_3Imm : Operand<i32> { let ParserMatchClass = u16_3ImmOperand; }
  def u11_3Imm : Operand<i32> { let ParserMatchClass = u11_3ImmOperand; }
  def u10Imm : Operand<i32> { let ParserMatchClass = u10ImmOperand; }
  def u9Imm : Operand<i32> { let ParserMatchClass = u9ImmOperand; }
  def u8Imm : Operand<i32> { let ParserMatchClass = u8ImmOperand; }
  def u7Imm : Operand<i32> { let ParserMatchClass = u7ImmOperand; }
  def u6Imm : Operand<i32> { let ParserMatchClass = u6ImmOperand; }
  def u6_0Imm : Operand<i32> { let ParserMatchClass = u6_0ImmOperand; }
  def u6_1Imm : Operand<i32> { let ParserMatchClass = u6_1ImmOperand; }
  def u6_2Imm : Operand<i32> { let ParserMatchClass = u6_2ImmOperand; }
  def u6_3Imm : Operand<i32> { let ParserMatchClass = u6_3ImmOperand; }
  def u5Imm : Operand<i32> { let ParserMatchClass = u5ImmOperand; }
  def u5_0Imm : Operand<i32>;
  def u5_1Imm : Operand<i32>;
  def u5_2Imm : Operand<i32>;
  def u5_3Imm : Operand<i32>;
  def u4Imm : Operand<i32> { let ParserMatchClass = u4ImmOperand; }
  def u4_0Imm : Operand<i32>;
  def u4_1Imm : Operand<i32>;
  def u4_2Imm : Operand<i32>;
  def u4_3Imm : Operand<i32>;
  def u3Imm : Operand<i32> { let ParserMatchClass = u3ImmOperand; }
  def u3_0Imm : Operand<i32>;
  def u3_1Imm : Operand<i32>;
  def u3_2Imm : Operand<i32>;
  def u3_3Imm : Operand<i32>;
  def u2Imm : Operand<i32> { let ParserMatchClass = u2ImmOperand; }
  def u1Imm : Operand<i32> { let ParserMatchClass = u1ImmOperand; }
  def n8Imm : Operand<i32> { let ParserMatchClass = n8ImmOperand; }
}

let OperandType = "OPERAND_IMMEDIATE" in {
  def s4_6Imm : Operand<i32> { let ParserMatchClass = s4_6ImmOperand;
                               let PrintMethod = "prints4_6ImmOperand";
                               let DecoderMethod = "s4_6ImmDecoder";}
  def s4_7Imm : Operand<i32> { let PrintMethod = "prints4_7ImmOperand";
                               let DecoderMethod = "s4_6ImmDecoder";}
  def s3_6Imm : Operand<i32> { let ParserMatchClass = s3_6ImmOperand;
                               let PrintMethod = "prints3_6ImmOperand";
                               let DecoderMethod = "s3_6ImmDecoder";}
  def s3_7Imm : Operand<i32> { let PrintMethod = "prints3_7ImmOperand";
                               let DecoderMethod = "s3_6ImmDecoder";}
}

//
// Immediate predicates
//
def s32ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isInt<32>(v);
}]>;

def s32_0ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isInt<32>(v);
}]>;

def s31_1ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isShiftedInt<31,1>(v);
}]>;

def s30_2ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isShiftedInt<30,2>(v);
}]>;

def s29_3ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isShiftedInt<29,3>(v);
}]>;

def s16ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isInt<16>(v);
}]>;

def s11_0ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isInt<11>(v);
}]>;

def s11_1ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isShiftedInt<11,1>(v);
}]>;

def s11_2ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isShiftedInt<11,2>(v);
}]>;

def s11_3ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isShiftedInt<11,3>(v);
}]>;

def s10ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isInt<10>(v);
}]>;

def s8ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isInt<8>(v);
}]>;

def s8Imm64Pred  : PatLeaf<(i64 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isInt<8>(v);
}]>;

def s6ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isInt<6>(v);
}]>;

def s4_0ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isInt<4>(v);
}]>;

def s4_1ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isShiftedInt<4,1>(v);
}]>;

def s4_2ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isShiftedInt<4,2>(v);
}]>;

def s4_3ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isShiftedInt<4,3>(v);
}]>;

def u64ImmPred  : PatLeaf<(i64 imm), [{
  // Adding "N ||" to suppress gcc unused warning.
  return (N || true);
}]>;

def u32ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isUInt<32>(v);
}]>;

def u32_0ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isUInt<32>(v);
}]>;

def u31_1ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isShiftedUInt<31,1>(v);
}]>;

def u30_2ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isShiftedUInt<30,2>(v);
}]>;

def u29_3ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isShiftedUInt<29,3>(v);
}]>;

def u26_6ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isShiftedUInt<26,6>(v);
}]>;

def u16_0ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isUInt<16>(v);
}]>;

def u16_1ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isShiftedUInt<16,1>(v);
}]>;

def u16_2ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isShiftedUInt<16,2>(v);
}]>;

def u11_3ImmPred : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isShiftedUInt<11,3>(v);
}]>;

def u10ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isUInt<10>(v);
}]>;

def u9ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isUInt<9>(v);
}]>;

def u8ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isUInt<8>(v);
}]>;

def u7StrictPosImmPred : ImmLeaf<i32, [{
  // u7StrictPosImmPred predicate - True if the immediate fits in an 7-bit
  // unsigned field and is strictly greater than 0.
  return isUInt<7>(Imm) && Imm > 0;
}]>;

def u7ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isUInt<7>(v);
}]>;

def u6ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isUInt<6>(v);
}]>;

def u6_0ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isUInt<6>(v);
}]>;

def u6_1ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isShiftedUInt<6,1>(v);
}]>;

def u6_2ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isShiftedUInt<6,2>(v);
}]>;

def u6_3ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isShiftedUInt<6,3>(v);
}]>;

def u5ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isUInt<5>(v);
}]>;

def u4ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isUInt<4>(v);
}]>;

def u3ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isUInt<3>(v);
}]>;

def u2ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isUInt<2>(v);
}]>;

def u1ImmPred  : PatLeaf<(i1 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isUInt<1>(v);
}]>;

def u1ImmPred32  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  return isUInt<1>(v);
}]>;

def m5BImmPred  : PatLeaf<(i32 imm), [{
  // m5BImmPred predicate - True if the (char) number is in range -1 .. -31
  // and will fit in a 5 bit field when made positive, for use in memops.
  // this is specific to the zero extending of a negative by CombineInstr
  int8_t v = (int8_t)N->getSExtValue();
  return (-31 <= v && v <= -1);
}]>;

def m5HImmPred  : PatLeaf<(i32 imm), [{
  // m5HImmPred predicate - True if the (short) number is in range -1 .. -31
  // and will fit in a 5 bit field when made positive, for use in memops.
  // this is specific to the zero extending of a negative by CombineInstr
  int16_t v = (int16_t)N->getSExtValue();
  return (-31 <= v && v <= -1);
}]>;

def m5ImmPred  : PatLeaf<(i32 imm), [{
  // m5ImmPred predicate - True if the number is in range -1 .. -31
  // and will fit in a 5 bit field when made positive, for use in memops.
  int64_t v = (int64_t)N->getSExtValue();
  return (-31 <= v && v <= -1);
}]>;

//InN means negative integers in [-(2^N - 1), 0]
def n8ImmPred  : PatLeaf<(i32 imm), [{
  // n8ImmPred predicate - True if the immediate fits in a 8-bit signed
  // field.
  int64_t v = (int64_t)N->getSExtValue();
  return (-255 <= v && v <= 0);
}]>;

def nOneImmPred  : PatLeaf<(i32 imm), [{
  // nOneImmPred predicate - True if the immediate is -1.
  int64_t v = (int64_t)N->getSExtValue();
  return (-1 == v);
}]>;

def Set5ImmPred : PatLeaf<(i32 imm), [{
  // Set5ImmPred predicate - True if the number is in the series of values.
  // [ 2^0, 2^1, ... 2^31 ]
  // For use in setbit immediate.
  uint32_t v = (int32_t)N->getSExtValue();
  // Constrain to 32 bits, and then check for single bit.
  return ImmIsSingleBit(v);
}]>;

def Clr5ImmPred : PatLeaf<(i32 imm), [{
  // Clr5ImmPred predicate - True if the number is in the series of
  // bit negated values.
  // [ 2^0, 2^1, ... 2^31 ]
  // For use in clrbit immediate.
  // Note: we are bit NOTing the value.
  uint32_t v = ~ (int32_t)N->getSExtValue();
  // Constrain to 32 bits, and then check for single bit.
  return ImmIsSingleBit(v);
}]>;

def SetClr5ImmPred : PatLeaf<(i32 imm), [{
  // True if the immediate is in range 0..31.
  int32_t v = (int32_t)N->getSExtValue();
  return (v >= 0 && v <= 31);
}]>;

def Set4ImmPred : PatLeaf<(i32 imm), [{
  // Set4ImmPred predicate - True if the number is in the series of values:
  // [ 2^0, 2^1, ... 2^15 ].
  // For use in setbit immediate.
  uint16_t v = (int16_t)N->getSExtValue();
  // Constrain to 16 bits, and then check for single bit.
  return ImmIsSingleBit(v);
}]>;

def Clr4ImmPred : PatLeaf<(i32 imm), [{
  // Clr4ImmPred predicate - True if the number is in the series of
  // bit negated values:
  // [ 2^0, 2^1, ... 2^15 ].
  // For use in setbit and clrbit immediate.
  uint16_t v = ~ (int16_t)N->getSExtValue();
  // Constrain to 16 bits, and then check for single bit.
  return ImmIsSingleBit(v);
}]>;

def SetClr4ImmPred : PatLeaf<(i32 imm), [{
  // True if the immediate is in the range 0..15.
  int16_t v = (int16_t)N->getSExtValue();
  return (v >= 0 && v <= 15);
}]>;

def Set3ImmPred : PatLeaf<(i32 imm), [{
  // True if the number is in the series of values: [ 2^0, 2^1, ... 2^7 ].
  // For use in setbit immediate.
  uint8_t v = (int8_t)N->getSExtValue();
  // Constrain to 8 bits, and then check for single bit.
  return ImmIsSingleBit(v);
}]>;

def Clr3ImmPred : PatLeaf<(i32 imm), [{
  // True if the number is in the series of bit negated values: [ 2^0, 2^1, ... 2^7 ].
  // For use in setbit and clrbit immediate.
  uint8_t v = ~ (int8_t)N->getSExtValue();
  // Constrain to 8 bits, and then check for single bit.
  return ImmIsSingleBit(v);
}]>;

def SetClr3ImmPred : PatLeaf<(i32 imm), [{
  // True if the immediate is in the range  0..7.
  int8_t v = (int8_t)N->getSExtValue();
  return (v >= 0 && v <= 7);
}]>;


// Extendable immediate operands.
def f32ExtOperand : AsmOperandClass { let Name = "f32Ext"; }
def s16ExtOperand : AsmOperandClass { let Name = "s16Ext"; }
def s12ExtOperand : AsmOperandClass { let Name = "s12Ext"; }
def s10ExtOperand : AsmOperandClass { let Name = "s10Ext"; }
def s9ExtOperand : AsmOperandClass { let Name = "s9Ext"; }
def s8ExtOperand : AsmOperandClass { let Name = "s8Ext"; }
def s7ExtOperand : AsmOperandClass { let Name = "s7Ext"; }
def s6ExtOperand : AsmOperandClass { let Name = "s6Ext"; }
def s11_0ExtOperand : AsmOperandClass { let Name = "s11_0Ext"; }
def s11_1ExtOperand : AsmOperandClass { let Name = "s11_1Ext"; }
def s11_2ExtOperand : AsmOperandClass { let Name = "s11_2Ext"; }
def s11_3ExtOperand : AsmOperandClass { let Name = "s11_3Ext"; }
def u6ExtOperand : AsmOperandClass { let Name = "u6Ext"; }
def u7ExtOperand : AsmOperandClass { let Name = "u7Ext"; }
def u8ExtOperand : AsmOperandClass { let Name = "u8Ext"; }
def u9ExtOperand : AsmOperandClass { let Name = "u9Ext"; }
def u10ExtOperand : AsmOperandClass { let Name = "u10Ext"; }
def u6_0ExtOperand : AsmOperandClass { let Name = "u6_0Ext"; }
def u6_1ExtOperand : AsmOperandClass { let Name = "u6_1Ext"; }
def u6_2ExtOperand : AsmOperandClass { let Name = "u6_2Ext"; }
def u6_3ExtOperand : AsmOperandClass { let Name = "u6_3Ext"; }
def u32MustExtOperand : AsmOperandClass { let Name = "u32MustExt"; }



let OperandType = "OPERAND_IMMEDIATE", PrintMethod = "printExtOperand",
    DecoderMethod = "unsignedImmDecoder" in {
  def f32Ext : Operand<f32> { let ParserMatchClass = f32ExtOperand; }
  def s16Ext : Operand<i32> { let ParserMatchClass = s16ExtOperand;
                              let DecoderMethod = "s16ImmDecoder"; }
  def s12Ext : Operand<i32> { let ParserMatchClass = s12ExtOperand;
                              let DecoderMethod = "s12ImmDecoder"; }
  def s11_0Ext : Operand<i32> { let ParserMatchClass = s11_0ExtOperand;
                              let DecoderMethod = "s11_0ImmDecoder"; }
  def s11_1Ext : Operand<i32> { let ParserMatchClass = s11_1ExtOperand;
                              let DecoderMethod = "s11_1ImmDecoder"; }
  def s11_2Ext : Operand<i32> { let ParserMatchClass = s11_2ExtOperand;
                              let DecoderMethod = "s11_2ImmDecoder"; }
  def s11_3Ext : Operand<i32> { let ParserMatchClass = s11_3ExtOperand;
                              let DecoderMethod = "s11_3ImmDecoder"; }
  def s10Ext : Operand<i32> { let ParserMatchClass = s10ExtOperand;
                              let DecoderMethod = "s10ImmDecoder"; }
  def s9Ext : Operand<i32> { let ParserMatchClass = s9ExtOperand;
                              let DecoderMethod = "s90ImmDecoder"; }
  def s8Ext : Operand<i32> { let ParserMatchClass = s8ExtOperand;
                              let DecoderMethod = "s8ImmDecoder"; }
  def s7Ext : Operand<i32> { let ParserMatchClass = s7ExtOperand; }
  def s6Ext : Operand<i32> { let ParserMatchClass = s6ExtOperand;
                              let DecoderMethod = "s6_0ImmDecoder"; }
  def u6Ext : Operand<i32> { let ParserMatchClass = u6ExtOperand; }
  def u7Ext : Operand<i32> { let ParserMatchClass = u7ExtOperand; }
  def u8Ext : Operand<i32> { let ParserMatchClass = u8ExtOperand; }
  def u9Ext : Operand<i32> { let ParserMatchClass = u9ExtOperand; }
  def u10Ext : Operand<i32> { let ParserMatchClass = u10ExtOperand; }
  def u6_0Ext : Operand<i32> { let ParserMatchClass = u6_0ExtOperand; }
  def u6_1Ext : Operand<i32> { let ParserMatchClass = u6_1ExtOperand; }
  def u6_2Ext : Operand<i32> { let ParserMatchClass = u6_2ExtOperand; }
  def u6_3Ext : Operand<i32> { let ParserMatchClass = u6_3ExtOperand; }
  def u32MustExt : Operand<i32> { let ParserMatchClass = u32MustExtOperand; }
}


def s4_7ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  if (HST->hasV60TOps())
    // Return true if the immediate can fit in a 10-bit sign extended field and
    // is 128-byte aligned.
    return isShiftedInt<4,7>(v);
  return false;
}]>;

def s3_7ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  if (HST->hasV60TOps())
    // Return true if the immediate can fit in a 9-bit sign extended field and
    // is 128-byte aligned.
    return isShiftedInt<3,7>(v);
  return false;
}]>;

def s4_6ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  if (HST->hasV60TOps())
    // Return true if the immediate can fit in a 10-bit sign extended field and
    // is 64-byte aligned.
    return isShiftedInt<4,6>(v);
  return false;
}]>;

def s3_6ImmPred  : PatLeaf<(i32 imm), [{
  int64_t v = (int64_t)N->getSExtValue();
  if (HST->hasV60TOps())
    // Return true if the immediate can fit in a 9-bit sign extended field and
    // is 64-byte aligned.
    return isShiftedInt<3,6>(v);
  return false;
}]>;


// This complex pattern exists only to create a machine instruction operand
// of type "frame index". There doesn't seem to be a way to do that directly
// in the patterns.
def AddrFI : ComplexPattern<i32, 1, "SelectAddrFI", [frameindex], []>;

// These complex patterns are not strictly necessary, since global address
// folding will happen during DAG combining. For distinguishing between GA
// and GP, pat frags with HexagonCONST32 and HexagonCONST32_GP can be used.
def AddrGA : ComplexPattern<i32, 1, "SelectAddrGA", [], []>;
def AddrGP : ComplexPattern<i32, 1, "SelectAddrGP", [], []>;

// Address operands.

let PrintMethod = "printGlobalOperand" in {
  def globaladdress : Operand<i32>;
  def globaladdressExt : Operand<i32>;
}

let PrintMethod = "printJumpTable" in
def jumptablebase : Operand<i32>;

def brtarget : Operand<OtherVT> {
  let DecoderMethod = "brtargetDecoder";
  let PrintMethod = "printBrtarget";
}
def brtargetExt : Operand<OtherVT> {
  let DecoderMethod = "brtargetDecoder";
  let PrintMethod = "printBrtarget";
}
def calltarget : Operand<i32> {
  let DecoderMethod = "brtargetDecoder";
  let PrintMethod = "printBrtarget";
}

def bblabel : Operand<i32>;
def bbl     : SDNode<"ISD::BasicBlock", SDTPtrLeaf, [], "BasicBlockSDNode">;

// Return true if for a 32 to 64-bit sign-extended load.
def is_sext_i32 : PatLeaf<(i64 DoubleRegs:$src1), [{
  LoadSDNode *LD = dyn_cast<LoadSDNode>(N);
  if (!LD)
    return false;
  return LD->getExtensionType() == ISD::SEXTLOAD &&
         LD->getMemoryVT().getScalarType() == MVT::i32;
}]>;
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@a10 1
def s23_2ImmOperand : AsmOperandClass { let Name = "s23_2Imm"; }
a50 1
  def s23_2Imm : Operand<i32> { let ParserMatchClass = s23_2ImmOperand; }
d348 16
d404 54
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d10 1
a10 1
def s32_0ImmOperand : AsmOperandClass { let Name = "s32_0Imm"; }
d12 4
a15 3
def s8_0ImmOperand : AsmOperandClass { let Name = "s8_0Imm"; }
def s8_0Imm64Operand : AsmOperandClass { let Name = "s8_0Imm64"; }
def s6_0ImmOperand : AsmOperandClass { let Name = "s6_0Imm"; }
d22 2
a23 2
def u64_0ImmOperand : AsmOperandClass { let Name = "u64_0Imm"; }
def u32_0ImmOperand : AsmOperandClass { let Name = "u32_0Imm"; }
d25 1
d31 5
a35 4
def u10_0ImmOperand : AsmOperandClass { let Name = "u10_0Imm"; }
def u9_0ImmOperand : AsmOperandClass { let Name = "u9_0Imm"; }
def u8_0ImmOperand : AsmOperandClass { let Name = "u8_0Imm"; }
def u7_0ImmOperand : AsmOperandClass { let Name = "u7_0Imm"; }
d40 6
a45 6
def u5_0ImmOperand : AsmOperandClass { let Name = "u5_0Imm"; }
def u4_0ImmOperand : AsmOperandClass { let Name = "u4_0Imm"; }
def u3_0ImmOperand : AsmOperandClass { let Name = "u3_0Imm"; }
def u2_0ImmOperand : AsmOperandClass { let Name = "u2_0Imm"; }
def u1_0ImmOperand : AsmOperandClass { let Name = "u1_0Imm"; }
def n8_0ImmOperand : AsmOperandClass { let Name = "n8_0Imm"; }
d50 2
a51 2
  def s32_0Imm : Operand<i32> { let ParserMatchClass = s32_0ImmOperand;
                                let DecoderMethod = "s32_0ImmDecoder"; }
d53 5
a57 5
  def s8_0Imm : Operand<i32> { let ParserMatchClass = s8_0ImmOperand;
                               let DecoderMethod = "s8_0ImmDecoder"; }
  def s8_0Imm64 : Operand<i64>  { let ParserMatchClass = s8_0Imm64Operand;
                                  let DecoderMethod = "s8_0ImmDecoder"; }
  def s6_0Imm : Operand<i32> { let ParserMatchClass = s6_0ImmOperand;
d60 2
d70 2
a71 2
  def u64_0Imm : Operand<i64> { let ParserMatchClass = u64_0ImmOperand; }
  def u32_0Imm : Operand<i32> { let ParserMatchClass = u32_0ImmOperand; }
d73 1
d79 5
a83 4
  def u10_0Imm : Operand<i32> { let ParserMatchClass = u10_0ImmOperand; }
  def u9_0Imm : Operand<i32> { let ParserMatchClass = u9_0ImmOperand; }
  def u8_0Imm : Operand<i32> { let ParserMatchClass = u8_0ImmOperand; }
  def u7_0Imm : Operand<i32> { let ParserMatchClass = u7_0ImmOperand; }
d88 2
a89 1
  def u5_0Imm : Operand<i32> { let ParserMatchClass = u5_0ImmOperand; }
d93 2
a94 1
  def u4_0Imm : Operand<i32> { let ParserMatchClass = u4_0ImmOperand; }
d98 2
a99 1
  def u3_0Imm : Operand<i32> { let ParserMatchClass = u3_0ImmOperand; }
d103 3
a105 3
  def u2_0Imm : Operand<i32> { let ParserMatchClass = u2_0ImmOperand; }
  def u1_0Imm : Operand<i32> { let ParserMatchClass = u1_0ImmOperand; }
  def n8_0Imm : Operand<i32> { let ParserMatchClass = n8_0ImmOperand; }
a119 2
def n1ConstOperand : AsmOperandClass { let Name = "n1Const"; }
def n1Const : Operand<i32> { let ParserMatchClass = n1ConstOperand; }
d124 5
d149 26
a174 1
def s10_0ImmPred  : PatLeaf<(i32 imm), [{
d179 1
a179 1
def s8_0ImmPred  : PatLeaf<(i32 imm), [{
d184 1
a184 1
def s8_0Imm64Pred  : PatLeaf<(i64 imm), [{
d189 1
a189 1
def s6_0ImmPred  : PatLeaf<(i32 imm), [{
d214 10
d229 20
d254 10
d269 6
a274 1
def u9_0ImmPred  : PatLeaf<(i32 imm), [{
d279 1
a279 1
def u8_0ImmPred  : PatLeaf<(i32 imm), [{
d284 16
d315 6
a320 1
def u5_0ImmPred  : PatLeaf<(i32 imm), [{
d325 1
a325 1
def u4_0ImmPred  : PatLeaf<(i32 imm), [{
d330 1
a330 1
def u3_0ImmPred  : PatLeaf<(i32 imm), [{
d335 1
a335 1
def u2_0ImmPred  : PatLeaf<(i32 imm), [{
d340 51
d393 7
a399 7
def s16_0ExtOperand : AsmOperandClass { let Name = "s16_0Ext"; }
def s12_0ExtOperand : AsmOperandClass { let Name = "s12_0Ext"; }
def s10_0ExtOperand : AsmOperandClass { let Name = "s10_0Ext"; }
def s9_0ExtOperand : AsmOperandClass { let Name = "s9_0Ext"; }
def s8_0ExtOperand : AsmOperandClass { let Name = "s8_0Ext"; }
def s7_0ExtOperand : AsmOperandClass { let Name = "s7_0Ext"; }
def s6_0ExtOperand : AsmOperandClass { let Name = "s6_0Ext"; }
d404 5
a409 4
def u7_0ExtOperand : AsmOperandClass { let Name = "u7_0Ext"; }
def u8_0ExtOperand : AsmOperandClass { let Name = "u8_0Ext"; }
def u9_0ExtOperand : AsmOperandClass { let Name = "u9_0Ext"; }
def u10_0ExtOperand : AsmOperandClass { let Name = "u10_0Ext"; }
d413 1
a413 1
def u32_0MustExtOperand : AsmOperandClass { let Name = "u32_0MustExt"; }
d420 4
a423 4
  def s16_0Ext : Operand<i32> { let ParserMatchClass = s16_0ExtOperand;
                                let DecoderMethod = "s16_0ImmDecoder"; }
  def s12_0Ext : Operand<i32> { let ParserMatchClass = s12_0ExtOperand;
                                let DecoderMethod = "s12_0ImmDecoder"; }
d425 1
a425 1
                                let DecoderMethod = "s11_0ImmDecoder"; }
d427 1
a427 1
                                let DecoderMethod = "s11_1ImmDecoder"; }
d429 1
a429 1
                                let DecoderMethod = "s11_2ImmDecoder"; }
d431 15
a445 14
                                let DecoderMethod = "s11_3ImmDecoder"; }
  def s10_0Ext : Operand<i32> { let ParserMatchClass = s10_0ExtOperand;
                                let DecoderMethod = "s10_0ImmDecoder"; }
  def s9_0Ext : Operand<i32> { let ParserMatchClass = s9_0ExtOperand;
                               let DecoderMethod = "s9_0ImmDecoder"; }
  def s8_0Ext : Operand<i32> { let ParserMatchClass = s8_0ExtOperand;
                               let DecoderMethod = "s8_0ImmDecoder"; }
  def s7_0Ext : Operand<i32> { let ParserMatchClass = s7_0ExtOperand; }
  def s6_0Ext : Operand<i32> { let ParserMatchClass = s6_0ExtOperand;
                               let DecoderMethod = "s6_0ImmDecoder"; }
  def u7_0Ext : Operand<i32> { let ParserMatchClass = u7_0ExtOperand; }
  def u8_0Ext : Operand<i32> { let ParserMatchClass = u8_0ExtOperand; }
  def u9_0Ext : Operand<i32> { let ParserMatchClass = u9_0ExtOperand; }
  def u10_0Ext : Operand<i32> { let ParserMatchClass = u10_0ExtOperand; }
d450 1
a450 1
  def u32_0MustExt : Operand<i32> { let ParserMatchClass = u32_0MustExtOperand; }
d454 37
d527 9
@


1.1.1.4
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@d1 1
a1 1
//===--- HexagonOperands.td -----------------------------------------------===//
d5 1
a5 1
// This file is distributed under the University of Illinois Open Source
d10 107
a116 10
def f32ImmOperand : AsmOperandClass { let Name = "f32Imm"; }
def f32Imm : Operand<f32> { let ParserMatchClass = f32ImmOperand; }
def f64ImmOperand : AsmOperandClass { let Name = "f64Imm"; }
def f64Imm : Operand<f64> { let ParserMatchClass = f64ImmOperand; }
def s8_0Imm64Pred  : PatLeaf<(i64 imm), [{ return isInt<8>(N->getSExtValue()); }]>;
def s9_0ImmOperand : AsmOperandClass { let Name = "s9_0Imm"; }
def s9_0Imm : Operand<i32> { let ParserMatchClass = s9_0ImmOperand; }
def s27_2ImmOperand : AsmOperandClass { let Name = "s27_2Imm"; let RenderMethod = "addSignedImmOperands"; }
def s27_2Imm : Operand<i32> { let ParserMatchClass = s27_2ImmOperand; }
def r32_0ImmPred  : PatLeaf<(i32 imm), [{
d120 71
d195 101
a295 4
def u64_0ImmOperand : AsmOperandClass { let Name = "u64_0Imm"; let RenderMethod = "addImmOperands"; }
def u64_0Imm : Operand<i64> { let ParserMatchClass = u64_0ImmOperand; }
def n1ConstOperand : AsmOperandClass { let Name = "n1Const"; }
def n1Const : Operand<i32> { let ParserMatchClass = n1ConstOperand; }
d308 22
@


