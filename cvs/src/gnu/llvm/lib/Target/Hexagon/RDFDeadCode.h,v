head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.2.0.2
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.04;	author patrick;	state Exp;
branches;
next	;
commitid	qMUxATnKgqN83Oct;


desc
@@


1.1
log
@Initial revision
@
text
@//===--- RDFDeadCode.h ----------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// RDF-based generic dead code elimination.
//
// The main interface of this class are functions "collect" and "erase".
// This allows custom processing of the function being optimized by a
// particular consumer. The simplest way to use this class would be to
// instantiate an object, and then simply call "collect" and "erase",
// passing the result of "getDeadInstrs()" to it.
// A more complex scenario would be to call "collect" first, then visit
// all post-increment instructions to see if the address update is dead
// or not, and if it is, convert the instruction to a non-updating form.
// After that "erase" can be called with the set of nodes including both,
// dead defs from the updating instructions and the nodes corresponding
// to the dead instructions.

#ifndef RDF_DEADCODE_H
#define RDF_DEADCODE_H

#include "RDFGraph.h"
#include "RDFLiveness.h"
#include "llvm/ADT/SetVector.h"

namespace llvm {
  class MachineRegisterInfo;
}

namespace rdf {
  struct DeadCodeElimination {
    DeadCodeElimination(DataFlowGraph &dfg, MachineRegisterInfo &mri)
      : Trace(false), DFG(dfg), MRI(mri), LV(mri, dfg) {}

    bool collect();
    bool erase(const SetVector<NodeId> &Nodes);
    void trace(bool On) { Trace = On; }
    bool trace() const { return Trace; }

    SetVector<NodeId> getDeadNodes() { return DeadNodes; }
    SetVector<NodeId> getDeadInstrs() { return DeadInstrs; }
    DataFlowGraph &getDFG() { return DFG; }

  private:
    bool Trace;
    SetVector<NodeId> LiveNodes;
    SetVector<NodeId> DeadNodes;
    SetVector<NodeId> DeadInstrs;
    DataFlowGraph &DFG;
    MachineRegisterInfo &MRI;
    Liveness LV;

    bool isLiveInstr(const MachineInstr *MI) const;
    void scanInstr(NodeAddr<InstrNode*> IA, SetVector<NodeId> &WorkQ);
    void processDef(NodeAddr<DefNode*> DA, SetVector<NodeId> &WorkQ);
    void processUse(NodeAddr<UseNode*> UA, SetVector<NodeId> &WorkQ);
  };
}

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d33 1
a57 2
    template<typename T> struct SetQueue;

d59 3
a61 3
    void scanInstr(NodeAddr<InstrNode*> IA, SetQueue<NodeId> &WorkQ);
    void processDef(NodeAddr<DefNode*> DA, SetQueue<NodeId> &WorkQ);
    void processUse(NodeAddr<UseNode*> UA, SetQueue<NodeId> &WorkQ);
d63 1
a63 2
} // namespace rdf
} // namespace llvm
@

