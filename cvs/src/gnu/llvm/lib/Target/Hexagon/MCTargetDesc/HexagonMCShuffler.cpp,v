head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.3
	OPENBSD_6_2:1.1.1.2.0.2
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.04;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.10.04.20.28.01;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===----- HexagonMCShuffler.cpp - MC bundle shuffling --------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This implements the shuffling of insns inside a bundle according to the
// packet formation rules of the Hexagon ISA.
//
//===----------------------------------------------------------------------===//

#define DEBUG_TYPE "hexagon-shuffle"

#include "Hexagon.h"
#include "MCTargetDesc/HexagonMCInstrInfo.h"
#include "MCTargetDesc/HexagonMCShuffler.h"
#include "MCTargetDesc/HexagonMCTargetDesc.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

static cl::opt<bool>
    DisableShuffle("disable-hexagon-shuffle", cl::Hidden, cl::init(false),
                   cl::desc("Disable Hexagon instruction shuffling"));

void HexagonMCShuffler::init(MCInst &MCB) {
  if (HexagonMCInstrInfo::isBundle(MCB)) {
    MCInst const *Extender = nullptr;
    // Copy the bundle for the shuffling.
    for (const auto &I : HexagonMCInstrInfo::bundleInstructions(MCB)) {
      assert(!HexagonMCInstrInfo::getDesc(MCII, *I.getInst()).isPseudo());
      MCInst *MI = const_cast<MCInst *>(I.getInst());

      if (!HexagonMCInstrInfo::isImmext(*MI)) {
        append(MI, Extender, HexagonMCInstrInfo::getUnits(MCII, STI, *MI),
               false);
        Extender = nullptr;
      } else
        Extender = MI;
    }
  }

  BundleFlags = MCB.getOperand(0).getImm();
}

void HexagonMCShuffler::init(MCInst &MCB, MCInst const *AddMI,
                             bool bInsertAtFront) {
  if (HexagonMCInstrInfo::isBundle(MCB)) {
    if (bInsertAtFront && AddMI)
      append(AddMI, nullptr, HexagonMCInstrInfo::getUnits(MCII, STI, *AddMI),
             false);
    MCInst const *Extender = nullptr;
    // Copy the bundle for the shuffling.
    for (auto const &I : HexagonMCInstrInfo::bundleInstructions(MCB)) {
      assert(!HexagonMCInstrInfo::getDesc(MCII, *I.getInst()).isPseudo());
      MCInst *MI = const_cast<MCInst *>(I.getInst());
      if (!HexagonMCInstrInfo::isImmext(*MI)) {
        append(MI, Extender, HexagonMCInstrInfo::getUnits(MCII, STI, *MI),
               false);
        Extender = nullptr;
      } else
        Extender = MI;
    }
    if (!bInsertAtFront && AddMI)
      append(AddMI, nullptr, HexagonMCInstrInfo::getUnits(MCII, STI, *AddMI),
             false);
  }

  BundleFlags = MCB.getOperand(0).getImm();
}

void HexagonMCShuffler::copyTo(MCInst &MCB) {
  MCB.clear();
  MCB.addOperand(MCOperand::createImm(BundleFlags));
  // Copy the results into the bundle.
  for (HexagonShuffler::iterator I = begin(); I != end(); ++I) {

    MCInst const *MI = I->getDesc();
    MCInst const *Extender = I->getExtender();
    if (Extender)
      MCB.addOperand(MCOperand::createInst(Extender));
    MCB.addOperand(MCOperand::createInst(MI));
  }
}

bool HexagonMCShuffler::reshuffleTo(MCInst &MCB) {
  if (shuffle()) {
    // Copy the results into the bundle.
    copyTo(MCB);
  } else
    DEBUG(MCB.dump());

  return (!getError());
}

bool llvm::HexagonMCShuffle(MCInstrInfo const &MCII, MCSubtargetInfo const &STI,
                            MCInst &MCB) {
  HexagonMCShuffler MCS(MCII, STI, MCB);

  if (DisableShuffle)
    // Ignore if user chose so.
    return false;

  if (!HexagonMCInstrInfo::bundleSize(MCB)) {
    // There once was a bundle:
    //    BUNDLE %D2<imp-def>, %R4<imp-def>, %R5<imp-def>, %D7<imp-def>, ...
    //      * %D2<def> = IMPLICIT_DEF; flags:
    //      * %D7<def> = IMPLICIT_DEF; flags:
    // After the IMPLICIT_DEFs were removed by the asm printer, the bundle
    // became empty.
    DEBUG(dbgs() << "Skipping empty bundle");
    return false;
  } else if (!HexagonMCInstrInfo::isBundle(MCB)) {
    DEBUG(dbgs() << "Skipping stand-alone insn");
    return false;
  }

  // Reorder the bundle and copy the result.
  if (!MCS.reshuffleTo(MCB)) {
    // Unless there is any error, which should not happen at this point.
    unsigned shuffleError = MCS.getError();
    switch (shuffleError) {
    default:
      llvm_unreachable("unknown error");
    case HexagonShuffler::SHUFFLE_ERROR_INVALID:
      llvm_unreachable("invalid packet");
    case HexagonShuffler::SHUFFLE_ERROR_STORES:
      llvm_unreachable("too many stores");
    case HexagonShuffler::SHUFFLE_ERROR_LOADS:
      llvm_unreachable("too many loads");
    case HexagonShuffler::SHUFFLE_ERROR_BRANCHES:
      llvm_unreachable("too many branches");
    case HexagonShuffler::SHUFFLE_ERROR_NOSLOTS:
      llvm_unreachable("no suitable slot");
    case HexagonShuffler::SHUFFLE_ERROR_SLOTS:
      llvm_unreachable("over-subscribed slots");
    case HexagonShuffler::SHUFFLE_SUCCESS: // Single instruction case.
      return true;
    }
  }

  return true;
}

unsigned
llvm::HexagonMCShuffle(MCInstrInfo const &MCII, MCSubtargetInfo const &STI,
                       MCContext &Context, MCInst &MCB,
                       SmallVector<DuplexCandidate, 8> possibleDuplexes) {

  if (DisableShuffle)
    return HexagonShuffler::SHUFFLE_SUCCESS;

  if (!HexagonMCInstrInfo::bundleSize(MCB)) {
    // There once was a bundle:
    //    BUNDLE %D2<imp-def>, %R4<imp-def>, %R5<imp-def>, %D7<imp-def>, ...
    //      * %D2<def> = IMPLICIT_DEF; flags:
    //      * %D7<def> = IMPLICIT_DEF; flags:
    // After the IMPLICIT_DEFs were removed by the asm printer, the bundle
    // became empty.
    DEBUG(dbgs() << "Skipping empty bundle");
    return HexagonShuffler::SHUFFLE_SUCCESS;
  } else if (!HexagonMCInstrInfo::isBundle(MCB)) {
    DEBUG(dbgs() << "Skipping stand-alone insn");
    return HexagonShuffler::SHUFFLE_SUCCESS;
  }

  bool doneShuffling = false;
  unsigned shuffleError;
  while (possibleDuplexes.size() > 0 && (!doneShuffling)) {
    // case of Duplex Found
    DuplexCandidate duplexToTry = possibleDuplexes.pop_back_val();
    MCInst Attempt(MCB);
    HexagonMCInstrInfo::replaceDuplex(Context, Attempt, duplexToTry);
    HexagonMCShuffler MCS(MCII, STI, Attempt); // copy packet to the shuffler
    if (MCS.size() == 1) {                     // case of one duplex
      // copy the created duplex in the shuffler to the bundle
      MCS.copyTo(MCB);
      doneShuffling = true;
      return HexagonShuffler::SHUFFLE_SUCCESS;
    }
    // try shuffle with this duplex
    doneShuffling = MCS.reshuffleTo(MCB);
    shuffleError = MCS.getError();

    if (doneShuffling)
      break;
  }

  if (doneShuffling == false) {
    HexagonMCShuffler MCS(MCII, STI, MCB);
    doneShuffling = MCS.reshuffleTo(MCB); // shuffle
    shuffleError = MCS.getError();
  }
  if (!doneShuffling)
    return shuffleError;

  return HexagonShuffler::SHUFFLE_SUCCESS;
}

bool llvm::HexagonMCShuffle(MCInstrInfo const &MCII, MCSubtargetInfo const &STI,
                            MCInst &MCB, MCInst const *AddMI, int fixupCount) {
  if (!HexagonMCInstrInfo::isBundle(MCB) || !AddMI)
    return false;

  // if fixups present, make sure we don't insert too many nops that would
  // later prevent an extender from being inserted.
  unsigned int bundleSize = HexagonMCInstrInfo::bundleSize(MCB);
  if (bundleSize >= HEXAGON_PACKET_SIZE)
    return false;
  if (fixupCount >= 2) {
    return false;
  } else {
    if (bundleSize == HEXAGON_PACKET_SIZE - 1 && fixupCount)
      return false;
  }

  if (DisableShuffle)
    return false;

  HexagonMCShuffler MCS(MCII, STI, MCB, AddMI);
  if (!MCS.reshuffleTo(MCB)) {
    unsigned shuffleError = MCS.getError();
    switch (shuffleError) {
    default:
      return false;
    case HexagonShuffler::SHUFFLE_SUCCESS: // single instruction case
      return true;
    }
  }

  return true;
}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d183 1
@


1.1.1.3
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@a16 1
#include "MCTargetDesc/HexagonMCShuffler.h"
d19 1
d36 2
a37 3
      MCInst &MI = *const_cast<MCInst *>(I.getInst());
      DEBUG(dbgs() << "Shuffling: " << MCII.getName(MI.getOpcode()) << '\n');
      assert(!HexagonMCInstrInfo::getDesc(MCII, MI).isPseudo());
d39 3
a41 2
      if (!HexagonMCInstrInfo::isImmext(MI)) {
        append(MI, Extender, HexagonMCInstrInfo::getUnits(MCII, STI, MI));
d44 1
a44 1
        Extender = &MI;
a47 1
  Loc = MCB.getLoc();
d51 1
a51 1
void HexagonMCShuffler::init(MCInst &MCB, MCInst const &AddMI,
d54 3
a56 2
    if (bInsertAtFront)
      append(AddMI, nullptr, HexagonMCInstrInfo::getUnits(MCII, STI, AddMI));
d61 4
a64 3
      MCInst &MI = *const_cast<MCInst *>(I.getInst());
      if (!HexagonMCInstrInfo::isImmext(MI)) {
        append(MI, Extender, HexagonMCInstrInfo::getUnits(MCII, STI, MI));
d67 1
a67 1
        Extender = &MI;
d69 3
a71 2
    if (!bInsertAtFront)
      append(AddMI, nullptr, HexagonMCInstrInfo::getUnits(MCII, STI, AddMI));
a73 1
  Loc = MCB.getLoc();
a79 1
  MCB.setLoc(Loc);
d83 1
a83 1
    MCInst const &MI = I->getDesc();
d87 1
a87 1
    MCB.addOperand(MCOperand::createInst(&MI));
d95 4
a98 4
    return true;
  }
  DEBUG(MCB.dump());
  return false;
d101 1
a101 2
bool llvm::HexagonMCShuffle(MCContext &Context, bool Fatal,
                            MCInstrInfo const &MCII, MCSubtargetInfo const &STI,
d103 1
a103 1
  HexagonMCShuffler MCS(Context, Fatal, MCII, STI, MCB);
d123 25
a147 1
  return MCS.reshuffleTo(MCB);
d150 3
a152 3
bool
llvm::HexagonMCShuffle(MCContext &Context, MCInstrInfo const &MCII,
                       MCSubtargetInfo const &STI, MCInst &MCB,
d156 1
a156 1
    return false;
d166 1
a166 1
    return false;
d169 1
a169 1
    return false;
d173 1
d179 1
a179 1
    HexagonMCShuffler MCS(Context, false, MCII, STI, Attempt); // copy packet to the shuffler
d183 1
a183 1
      return false;
d187 1
d194 1
a194 1
    HexagonMCShuffler MCS(Context, false, MCII, STI, MCB);
d196 1
d199 1
a199 1
    return true;
d201 1
a201 1
  return false;
d204 3
a206 4
bool llvm::HexagonMCShuffle(MCContext &Context, MCInstrInfo const &MCII,
                            MCSubtargetInfo const &STI, MCInst &MCB,
                            MCInst const &AddMI, int fixupCount) {
  if (!HexagonMCInstrInfo::isBundle(MCB))
a213 1
  bool bhasDuplex = HexagonMCInstrInfo::hasDuplex(MCII, MCB);
d215 1
a215 7
    if (bhasDuplex) {
      if (bundleSize >= HEXAGON_PACKET_SIZE - 1) {
        return false;
      }
    } else {
      return false;
    }
d224 10
a233 8
  // mgl: temporary code (shuffler doesn't take into account the fact that
  // a duplex takes up two slots.  for example, 3 nops can be put into a packet
  // containing a duplex oversubscribing slots by 1).
  unsigned maxBundleSize = (HexagonMCInstrInfo::hasImmExt(MCB))
                               ? HEXAGON_PACKET_SIZE
                               : HEXAGON_PACKET_SIZE - 1;
  if (bhasDuplex && bundleSize >= maxBundleSize)
    return false;
d235 1
a235 2
  HexagonMCShuffler MCS(Context, false, MCII, STI, MCB, AddMI, false);
  return MCS.reshuffleTo(MCB);
@


