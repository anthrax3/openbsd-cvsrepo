head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.47.01;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.01;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.08;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.31;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- AArch64ELFObjectWriter.cpp - AArch64 ELF Writer -------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file handles ELF-specific object emission, converting LLVM's internal
// fixups into the appropriate relocations.
//
//===----------------------------------------------------------------------===//

#include "MCTargetDesc/AArch64FixupKinds.h"
#include "MCTargetDesc/AArch64MCExpr.h"
#include "MCTargetDesc/AArch64MCTargetDesc.h"
#include "llvm/MC/MCELFObjectWriter.h"
#include "llvm/MC/MCValue.h"
#include "llvm/Support/ErrorHandling.h"

using namespace llvm;

namespace {
class AArch64ELFObjectWriter : public MCELFObjectTargetWriter {
public:
  AArch64ELFObjectWriter(uint8_t OSABI, bool IsLittleEndian);

  ~AArch64ELFObjectWriter() override;

protected:
  unsigned GetRelocType(const MCValue &Target, const MCFixup &Fixup,
                        bool IsPCRel) const override;

private:
};
}

AArch64ELFObjectWriter::AArch64ELFObjectWriter(uint8_t OSABI,
                                               bool IsLittleEndian)
    : MCELFObjectTargetWriter(/*Is64Bit*/ true, OSABI, ELF::EM_AARCH64,
                              /*HasRelocationAddend*/ true) {}

AArch64ELFObjectWriter::~AArch64ELFObjectWriter() {}

unsigned AArch64ELFObjectWriter::GetRelocType(const MCValue &Target,
                                            const MCFixup &Fixup,
                                            bool IsPCRel) const {
  AArch64MCExpr::VariantKind RefKind =
      static_cast<AArch64MCExpr::VariantKind>(Target.getRefKind());
  AArch64MCExpr::VariantKind SymLoc = AArch64MCExpr::getSymbolLoc(RefKind);
  bool IsNC = AArch64MCExpr::isNotChecked(RefKind);

  assert((!Target.getSymA() ||
          Target.getSymA()->getKind() == MCSymbolRefExpr::VK_None) &&
         "Should only be expression-level modifiers here");

  assert((!Target.getSymB() ||
          Target.getSymB()->getKind() == MCSymbolRefExpr::VK_None) &&
         "Should only be expression-level modifiers here");

  if (IsPCRel) {
    switch ((unsigned)Fixup.getKind()) {
    case FK_Data_2:
      return ELF::R_AARCH64_PREL16;
    case FK_Data_4:
      return ELF::R_AARCH64_PREL32;
    case FK_Data_8:
      return ELF::R_AARCH64_PREL64;
    case AArch64::fixup_aarch64_pcrel_adr_imm21:
      assert(SymLoc == AArch64MCExpr::VK_NONE && "unexpected ADR relocation");
      return ELF::R_AARCH64_ADR_PREL_LO21;
    case AArch64::fixup_aarch64_pcrel_adrp_imm21:
      if (SymLoc == AArch64MCExpr::VK_ABS && !IsNC)
        return ELF::R_AARCH64_ADR_PREL_PG_HI21;
      if (SymLoc == AArch64MCExpr::VK_GOT && !IsNC)
        return ELF::R_AARCH64_ADR_GOT_PAGE;
      if (SymLoc == AArch64MCExpr::VK_GOTTPREL && !IsNC)
        return ELF::R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21;
      if (SymLoc == AArch64MCExpr::VK_TLSDESC && !IsNC)
        return ELF::R_AARCH64_TLSDESC_ADR_PAGE21;
      llvm_unreachable("invalid symbol kind for ADRP relocation");
    case AArch64::fixup_aarch64_pcrel_branch26:
      return ELF::R_AARCH64_JUMP26;
    case AArch64::fixup_aarch64_pcrel_call26:
      return ELF::R_AARCH64_CALL26;
    case AArch64::fixup_aarch64_ldr_pcrel_imm19:
      if (SymLoc == AArch64MCExpr::VK_GOTTPREL)
        return ELF::R_AARCH64_TLSIE_LD_GOTTPREL_PREL19;
      return ELF::R_AARCH64_LD_PREL_LO19;
    case AArch64::fixup_aarch64_pcrel_branch14:
      return ELF::R_AARCH64_TSTBR14;
    case AArch64::fixup_aarch64_pcrel_branch19:
      return ELF::R_AARCH64_CONDBR19;
    default:
      llvm_unreachable("Unsupported pc-relative fixup kind");
    }
  } else {
    switch ((unsigned)Fixup.getKind()) {
    case FK_Data_2:
      return ELF::R_AARCH64_ABS16;
    case FK_Data_4:
      return ELF::R_AARCH64_ABS32;
    case FK_Data_8:
      return ELF::R_AARCH64_ABS64;
    case AArch64::fixup_aarch64_add_imm12:
      if (RefKind == AArch64MCExpr::VK_DTPREL_HI12)
        return ELF::R_AARCH64_TLSLD_ADD_DTPREL_HI12;
      if (RefKind == AArch64MCExpr::VK_TPREL_HI12)
        return ELF::R_AARCH64_TLSLE_ADD_TPREL_HI12;
      if (RefKind == AArch64MCExpr::VK_DTPREL_LO12_NC)
        return ELF::R_AARCH64_TLSLD_ADD_DTPREL_LO12_NC;
      if (RefKind == AArch64MCExpr::VK_DTPREL_LO12)
        return ELF::R_AARCH64_TLSLD_ADD_DTPREL_LO12;
      if (RefKind == AArch64MCExpr::VK_TPREL_LO12_NC)
        return ELF::R_AARCH64_TLSLE_ADD_TPREL_LO12_NC;
      if (RefKind == AArch64MCExpr::VK_TPREL_LO12)
        return ELF::R_AARCH64_TLSLE_ADD_TPREL_LO12;
      if (RefKind == AArch64MCExpr::VK_TLSDESC_LO12)
        return ELF::R_AARCH64_TLSDESC_ADD_LO12_NC;
      if (SymLoc == AArch64MCExpr::VK_ABS && IsNC)
        return ELF::R_AARCH64_ADD_ABS_LO12_NC;

      report_fatal_error("invalid fixup for add (uimm12) instruction");
      return 0;
    case AArch64::fixup_aarch64_ldst_imm12_scale1:
      if (SymLoc == AArch64MCExpr::VK_ABS && IsNC)
        return ELF::R_AARCH64_LDST8_ABS_LO12_NC;
      if (SymLoc == AArch64MCExpr::VK_DTPREL && !IsNC)
        return ELF::R_AARCH64_TLSLD_LDST8_DTPREL_LO12;
      if (SymLoc == AArch64MCExpr::VK_DTPREL && IsNC)
        return ELF::R_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC;
      if (SymLoc == AArch64MCExpr::VK_TPREL && !IsNC)
        return ELF::R_AARCH64_TLSLE_LDST8_TPREL_LO12;
      if (SymLoc == AArch64MCExpr::VK_TPREL && IsNC)
        return ELF::R_AARCH64_TLSLE_LDST8_TPREL_LO12_NC;

      report_fatal_error("invalid fixup for 8-bit load/store instruction");
      return 0;
    case AArch64::fixup_aarch64_ldst_imm12_scale2:
      if (SymLoc == AArch64MCExpr::VK_ABS && IsNC)
        return ELF::R_AARCH64_LDST16_ABS_LO12_NC;
      if (SymLoc == AArch64MCExpr::VK_DTPREL && !IsNC)
        return ELF::R_AARCH64_TLSLD_LDST16_DTPREL_LO12;
      if (SymLoc == AArch64MCExpr::VK_DTPREL && IsNC)
        return ELF::R_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC;
      if (SymLoc == AArch64MCExpr::VK_TPREL && !IsNC)
        return ELF::R_AARCH64_TLSLE_LDST16_TPREL_LO12;
      if (SymLoc == AArch64MCExpr::VK_TPREL && IsNC)
        return ELF::R_AARCH64_TLSLE_LDST16_TPREL_LO12_NC;

      report_fatal_error("invalid fixup for 16-bit load/store instruction");
      return 0;
    case AArch64::fixup_aarch64_ldst_imm12_scale4:
      if (SymLoc == AArch64MCExpr::VK_ABS && IsNC)
        return ELF::R_AARCH64_LDST32_ABS_LO12_NC;
      if (SymLoc == AArch64MCExpr::VK_DTPREL && !IsNC)
        return ELF::R_AARCH64_TLSLD_LDST32_DTPREL_LO12;
      if (SymLoc == AArch64MCExpr::VK_DTPREL && IsNC)
        return ELF::R_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC;
      if (SymLoc == AArch64MCExpr::VK_TPREL && !IsNC)
        return ELF::R_AARCH64_TLSLE_LDST32_TPREL_LO12;
      if (SymLoc == AArch64MCExpr::VK_TPREL && IsNC)
        return ELF::R_AARCH64_TLSLE_LDST32_TPREL_LO12_NC;

      report_fatal_error("invalid fixup for 32-bit load/store instruction");
      return 0;
    case AArch64::fixup_aarch64_ldst_imm12_scale8:
      if (SymLoc == AArch64MCExpr::VK_ABS && IsNC)
        return ELF::R_AARCH64_LDST64_ABS_LO12_NC;
      if (SymLoc == AArch64MCExpr::VK_GOT && IsNC)
        return ELF::R_AARCH64_LD64_GOT_LO12_NC;
      if (SymLoc == AArch64MCExpr::VK_DTPREL && !IsNC)
        return ELF::R_AARCH64_TLSLD_LDST64_DTPREL_LO12;
      if (SymLoc == AArch64MCExpr::VK_DTPREL && IsNC)
        return ELF::R_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC;
      if (SymLoc == AArch64MCExpr::VK_TPREL && !IsNC)
        return ELF::R_AARCH64_TLSLE_LDST64_TPREL_LO12;
      if (SymLoc == AArch64MCExpr::VK_TPREL && IsNC)
        return ELF::R_AARCH64_TLSLE_LDST64_TPREL_LO12_NC;
      if (SymLoc == AArch64MCExpr::VK_GOTTPREL && IsNC)
        return ELF::R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC;
      if (SymLoc == AArch64MCExpr::VK_TLSDESC && IsNC)
        return ELF::R_AARCH64_TLSDESC_LD64_LO12_NC;

      report_fatal_error("invalid fixup for 64-bit load/store instruction");
      return 0;
    case AArch64::fixup_aarch64_ldst_imm12_scale16:
      if (SymLoc == AArch64MCExpr::VK_ABS && IsNC)
        return ELF::R_AARCH64_LDST128_ABS_LO12_NC;

      report_fatal_error("invalid fixup for 128-bit load/store instruction");
      return 0;
    case AArch64::fixup_aarch64_movw:
      if (RefKind == AArch64MCExpr::VK_ABS_G3)
        return ELF::R_AARCH64_MOVW_UABS_G3;
      if (RefKind == AArch64MCExpr::VK_ABS_G2)
        return ELF::R_AARCH64_MOVW_UABS_G2;
      if (RefKind == AArch64MCExpr::VK_ABS_G2_S)
        return ELF::R_AARCH64_MOVW_SABS_G2;
      if (RefKind == AArch64MCExpr::VK_ABS_G2_NC)
        return ELF::R_AARCH64_MOVW_UABS_G2_NC;
      if (RefKind == AArch64MCExpr::VK_ABS_G1)
        return ELF::R_AARCH64_MOVW_UABS_G1;
      if (RefKind == AArch64MCExpr::VK_ABS_G1_S)
        return ELF::R_AARCH64_MOVW_SABS_G1;
      if (RefKind == AArch64MCExpr::VK_ABS_G1_NC)
        return ELF::R_AARCH64_MOVW_UABS_G1_NC;
      if (RefKind == AArch64MCExpr::VK_ABS_G0)
        return ELF::R_AARCH64_MOVW_UABS_G0;
      if (RefKind == AArch64MCExpr::VK_ABS_G0_S)
        return ELF::R_AARCH64_MOVW_SABS_G0;
      if (RefKind == AArch64MCExpr::VK_ABS_G0_NC)
        return ELF::R_AARCH64_MOVW_UABS_G0_NC;
      if (RefKind == AArch64MCExpr::VK_DTPREL_G2)
        return ELF::R_AARCH64_TLSLD_MOVW_DTPREL_G2;
      if (RefKind == AArch64MCExpr::VK_DTPREL_G1)
        return ELF::R_AARCH64_TLSLD_MOVW_DTPREL_G1;
      if (RefKind == AArch64MCExpr::VK_DTPREL_G1_NC)
        return ELF::R_AARCH64_TLSLD_MOVW_DTPREL_G1_NC;
      if (RefKind == AArch64MCExpr::VK_DTPREL_G0)
        return ELF::R_AARCH64_TLSLD_MOVW_DTPREL_G0;
      if (RefKind == AArch64MCExpr::VK_DTPREL_G0_NC)
        return ELF::R_AARCH64_TLSLD_MOVW_DTPREL_G0_NC;
      if (RefKind == AArch64MCExpr::VK_TPREL_G2)
        return ELF::R_AARCH64_TLSLE_MOVW_TPREL_G2;
      if (RefKind == AArch64MCExpr::VK_TPREL_G1)
        return ELF::R_AARCH64_TLSLE_MOVW_TPREL_G1;
      if (RefKind == AArch64MCExpr::VK_TPREL_G1_NC)
        return ELF::R_AARCH64_TLSLE_MOVW_TPREL_G1_NC;
      if (RefKind == AArch64MCExpr::VK_TPREL_G0)
        return ELF::R_AARCH64_TLSLE_MOVW_TPREL_G0;
      if (RefKind == AArch64MCExpr::VK_TPREL_G0_NC)
        return ELF::R_AARCH64_TLSLE_MOVW_TPREL_G0_NC;
      if (RefKind == AArch64MCExpr::VK_GOTTPREL_G1)
        return ELF::R_AARCH64_TLSIE_MOVW_GOTTPREL_G1;
      if (RefKind == AArch64MCExpr::VK_GOTTPREL_G0_NC)
        return ELF::R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC;
      report_fatal_error("invalid fixup for movz/movk instruction");
      return 0;
    case AArch64::fixup_aarch64_tlsdesc_call:
      return ELF::R_AARCH64_TLSDESC_CALL;
    default:
      llvm_unreachable("Unknown ELF relocation type");
    }
  }

  llvm_unreachable("Unimplemented fixup -> relocation");
}

MCObjectWriter *llvm::createAArch64ELFObjectWriter(raw_pwrite_stream &OS,
                                                   uint8_t OSABI,
                                                   bool IsLittleEndian) {
  MCELFObjectTargetWriter *MOTW =
      new AArch64ELFObjectWriter(OSABI, IsLittleEndian);
  return createELFObjectWriter(MOTW, OS, IsLittleEndian);
}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@a17 1
#include "llvm/MC/MCContext.h"
d32 2
a33 2
  unsigned getRelocType(MCContext &Ctx, const MCValue &Target,
                        const MCFixup &Fixup, bool IsPCRel) const override;
d46 3
a48 4
unsigned AArch64ELFObjectWriter::getRelocType(MCContext &Ctx,
                                              const MCValue &Target,
                                              const MCFixup &Fixup,
                                              bool IsPCRel) const {
a63 3
    case FK_Data_1:
      Ctx.reportError(Fixup.getLoc(), "1-byte data relocations not supported");
      return ELF::R_AARCH64_NONE;
d82 1
a82 3
      Ctx.reportError(Fixup.getLoc(),
                      "invalid symbol kind for ADRP relocation");
      return ELF::R_AARCH64_NONE;
d96 1
a96 2
      Ctx.reportError(Fixup.getLoc(), "Unsupported pc-relative fixup kind");
      return ELF::R_AARCH64_NONE;
a99 3
    case FK_Data_1:
      Ctx.reportError(Fixup.getLoc(), "1-byte data relocations not supported");
      return ELF::R_AARCH64_NONE;
d124 2
a125 3
      Ctx.reportError(Fixup.getLoc(),
                      "invalid fixup for add (uimm12) instruction");
      return ELF::R_AARCH64_NONE;
d138 2
a139 3
      Ctx.reportError(Fixup.getLoc(),
                      "invalid fixup for 8-bit load/store instruction");
      return ELF::R_AARCH64_NONE;
d152 2
a153 3
      Ctx.reportError(Fixup.getLoc(),
                      "invalid fixup for 16-bit load/store instruction");
      return ELF::R_AARCH64_NONE;
d166 2
a167 3
      Ctx.reportError(Fixup.getLoc(),
                      "invalid fixup for 32-bit load/store instruction");
      return ELF::R_AARCH64_NONE;
d186 2
a187 3
      Ctx.reportError(Fixup.getLoc(),
                      "invalid fixup for 64-bit load/store instruction");
      return ELF::R_AARCH64_NONE;
d192 2
a193 3
      Ctx.reportError(Fixup.getLoc(),
                      "invalid fixup for 128-bit load/store instruction");
      return ELF::R_AARCH64_NONE;
d239 2
a240 3
      Ctx.reportError(Fixup.getLoc(),
                      "invalid fixup for movz/movk instruction");
      return ELF::R_AARCH64_NONE;
d244 1
a244 2
      Ctx.reportError(Fixup.getLoc(), "Unknown ELF relocation type");
      return ELF::R_AARCH64_NONE;
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a19 1
#include "llvm/MC/MCFixup.h"
a20 1
#include "llvm/Support/ELF.h"
a21 2
#include <cassert>
#include <cstdint>
a25 1

d28 1
a28 1
  AArch64ELFObjectWriter(uint8_t OSABI, bool IsLittleEndian, bool IsILP32);
d30 1
a30 1
  ~AArch64ELFObjectWriter() override = default;
d35 2
a36 1
  bool IsILP32;
d38 1
a38 2

} // end anonymous namespace
d41 1
a41 2
                                               bool IsLittleEndian,
                                               bool IsILP32)
d43 1
a43 2
                              /*HasRelocationAddend*/ true),
      IsILP32(IsILP32) {}
d45 1
a45 52
#define R_CLS(rtype) \
        IsILP32 ? ELF::R_AARCH64_P32_##rtype : ELF::R_AARCH64_##rtype
#define BAD_ILP32_MOV(lp64rtype) "ILP32 absolute MOV relocation not "\
        "supported (LP64 eqv: " #lp64rtype ")"

// assumes IsILP32 is true
static bool isNonILP32reloc(const MCFixup &Fixup,
                            AArch64MCExpr::VariantKind RefKind,
                            MCContext &Ctx) {
  if ((unsigned)Fixup.getKind() != AArch64::fixup_aarch64_movw)
    return false;
  switch(RefKind) {
    case AArch64MCExpr::VK_ABS_G3:
      Ctx.reportError(Fixup.getLoc(), BAD_ILP32_MOV(MOVW_UABS_G3));
      return true;
    case AArch64MCExpr::VK_ABS_G2:
      Ctx.reportError(Fixup.getLoc(), BAD_ILP32_MOV(MOVW_UABS_G2));
      return true;
    case AArch64MCExpr::VK_ABS_G2_S:
      Ctx.reportError(Fixup.getLoc(), BAD_ILP32_MOV(MOVW_SABS_G2));
      return ELF::R_AARCH64_NONE;
    case AArch64MCExpr::VK_ABS_G2_NC:
      Ctx.reportError(Fixup.getLoc(), BAD_ILP32_MOV(MOVW_UABS_G2_NC));
      return ELF::R_AARCH64_NONE;
    case AArch64MCExpr::VK_ABS_G1_S:
      Ctx.reportError(Fixup.getLoc(), BAD_ILP32_MOV(MOVW_SABS_G1));
      return ELF::R_AARCH64_NONE;
    case AArch64MCExpr::VK_ABS_G1_NC:
      Ctx.reportError(Fixup.getLoc(), BAD_ILP32_MOV(MOVW_UABS_G1_NC));
      return ELF::R_AARCH64_NONE;
    case AArch64MCExpr::VK_DTPREL_G2:
      Ctx.reportError(Fixup.getLoc(), BAD_ILP32_MOV(TLSLD_MOVW_DTPREL_G2));
      return ELF::R_AARCH64_NONE;
    case AArch64MCExpr::VK_DTPREL_G1_NC:
      Ctx.reportError(Fixup.getLoc(), BAD_ILP32_MOV(TLSLD_MOVW_DTPREL_G1_NC));
      return ELF::R_AARCH64_NONE;
    case AArch64MCExpr::VK_TPREL_G2:
      Ctx.reportError(Fixup.getLoc(), BAD_ILP32_MOV(TLSLE_MOVW_TPREL_G2));
      return ELF::R_AARCH64_NONE;
    case AArch64MCExpr::VK_TPREL_G1_NC:
      Ctx.reportError(Fixup.getLoc(), BAD_ILP32_MOV(TLSLE_MOVW_TPREL_G1_NC));
      return ELF::R_AARCH64_NONE;
    case AArch64MCExpr::VK_GOTTPREL_G1:
      Ctx.reportError(Fixup.getLoc(), BAD_ILP32_MOV(TLSIE_MOVW_GOTTPREL_G1));
      return ELF::R_AARCH64_NONE;
    case AArch64MCExpr::VK_GOTTPREL_G0_NC:
      Ctx.reportError(Fixup.getLoc(), BAD_ILP32_MOV(TLSIE_MOVW_GOTTPREL_G0_NC));
      return ELF::R_AARCH64_NONE;
    default: return false;
  }
  return false;
}
d70 1
a70 1
      return R_CLS(PREL16);
d72 1
a72 1
      return R_CLS(PREL32);
d74 1
a74 6
      if (IsILP32) {
        Ctx.reportError(Fixup.getLoc(), "ILP32 8 byte PC relative data "
                        "relocation not supported (LP64 eqv: PREL64)");
        return ELF::R_AARCH64_NONE;
      } else
        return ELF::R_AARCH64_PREL64;
d77 1
a77 1
      return R_CLS(ADR_PREL_LO21);
d80 1
a80 1
        return R_CLS(ADR_PREL_PG_HI21);
d82 1
a82 1
        return R_CLS(ADR_GOT_PAGE);
d84 1
a84 1
        return R_CLS(TLSIE_ADR_GOTTPREL_PAGE21);
d86 1
a86 1
        return R_CLS(TLSDESC_ADR_PAGE21);
d91 1
a91 1
      return R_CLS(JUMP26);
d93 1
a93 1
      return R_CLS(CALL26);
d96 2
a97 2
        return R_CLS(TLSIE_LD_GOTTPREL_PREL19);
      return R_CLS(LD_PREL_LO19);
d99 1
a99 1
      return R_CLS(TSTBR14);
d101 1
a101 1
      return R_CLS(CONDBR19);
a106 2
    if (IsILP32 && isNonILP32reloc(Fixup, RefKind, Ctx))
        return ELF::R_AARCH64_NONE;
d112 1
a112 1
      return R_CLS(ABS16);
d114 1
a114 1
      return R_CLS(ABS32);
d116 1
a116 5
      if (IsILP32) {
        Ctx.reportError(Fixup.getLoc(), BAD_ILP32_MOV(ABS64));
        return ELF::R_AARCH64_NONE;
      } else
        return ELF::R_AARCH64_ABS64;
d119 1
a119 1
        return R_CLS(TLSLD_ADD_DTPREL_HI12);
d121 1
a121 1
        return R_CLS(TLSLE_ADD_TPREL_HI12);
d123 1
a123 1
        return R_CLS(TLSLD_ADD_DTPREL_LO12_NC);
d125 1
a125 1
        return R_CLS(TLSLD_ADD_DTPREL_LO12);
d127 1
a127 1
        return R_CLS(TLSLE_ADD_TPREL_LO12_NC);
d129 1
a129 1
        return R_CLS(TLSLE_ADD_TPREL_LO12);
d131 1
a131 1
        return R_CLS(TLSDESC_ADD_LO12_NC);
d133 1
a133 1
        return R_CLS(ADD_ABS_LO12_NC);
d140 1
a140 1
        return R_CLS(LDST8_ABS_LO12_NC);
d142 1
a142 1
        return R_CLS(TLSLD_LDST8_DTPREL_LO12);
d144 1
a144 1
        return R_CLS(TLSLD_LDST8_DTPREL_LO12_NC);
d146 1
a146 1
        return R_CLS(TLSLE_LDST8_TPREL_LO12);
d148 1
a148 1
        return R_CLS(TLSLE_LDST8_TPREL_LO12_NC);
d155 1
a155 1
        return R_CLS(LDST16_ABS_LO12_NC);
d157 1
a157 1
        return R_CLS(TLSLD_LDST16_DTPREL_LO12);
d159 1
a159 1
        return R_CLS(TLSLD_LDST16_DTPREL_LO12_NC);
d161 1
a161 1
        return R_CLS(TLSLE_LDST16_TPREL_LO12);
d163 1
a163 1
        return R_CLS(TLSLE_LDST16_TPREL_LO12_NC);
d170 1
a170 1
        return R_CLS(LDST32_ABS_LO12_NC);
d172 1
a172 1
        return R_CLS(TLSLD_LDST32_DTPREL_LO12);
d174 1
a174 1
        return R_CLS(TLSLD_LDST32_DTPREL_LO12_NC);
d176 1
a176 1
        return R_CLS(TLSLE_LDST32_TPREL_LO12);
d178 1
a178 1
        return R_CLS(TLSLE_LDST32_TPREL_LO12_NC);
d185 1
a185 1
        return R_CLS(LDST64_ABS_LO12_NC);
d187 1
a187 1
        return R_CLS(LD64_GOT_LO12_NC);
d189 1
a189 1
        return R_CLS(TLSLD_LDST64_DTPREL_LO12);
d191 1
a191 1
        return R_CLS(TLSLD_LDST64_DTPREL_LO12_NC);
d193 1
a193 1
        return R_CLS(TLSLE_LDST64_TPREL_LO12);
d195 1
a195 1
        return R_CLS(TLSLE_LDST64_TPREL_LO12_NC);
d197 1
a197 2
        return IsILP32 ? ELF::R_AARCH64_P32_TLSIE_LD32_GOTTPREL_LO12_NC
                       : ELF::R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC;
d199 1
a199 2
        return IsILP32 ? ELF::R_AARCH64_P32_TLSDESC_LD32_LO12_NC
                       : ELF::R_AARCH64_TLSDESC_LD64_LO12_NC;
d206 1
a206 1
        return R_CLS(LDST128_ABS_LO12_NC);
a210 1
    // ILP32 case not reached here, tested with isNonILP32reloc
d221 1
a221 1
        return R_CLS(MOVW_UABS_G1);
d227 1
a227 1
        return R_CLS(MOVW_UABS_G0);
d229 1
a229 1
        return R_CLS(MOVW_SABS_G0);
d231 1
a231 1
        return R_CLS(MOVW_UABS_G0_NC);
d235 1
a235 1
        return R_CLS(TLSLD_MOVW_DTPREL_G1);
d239 1
a239 1
        return R_CLS(TLSLD_MOVW_DTPREL_G0);
d241 1
a241 1
        return R_CLS(TLSLD_MOVW_DTPREL_G0_NC);
d245 1
a245 1
        return R_CLS(TLSLE_MOVW_TPREL_G1);
d249 1
a249 1
        return R_CLS(TLSLE_MOVW_TPREL_G0);
d251 1
a251 1
        return R_CLS(TLSLE_MOVW_TPREL_G0_NC);
d260 1
a260 1
      return R_CLS(TLSDESC_CALL);
d272 1
a272 2
                                                   bool IsLittleEndian,
                                                   bool IsILP32) {
d274 1
a274 1
      new AArch64ELFObjectWriter(OSABI, IsLittleEndian, IsILP32);
@


