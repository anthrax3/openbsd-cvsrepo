head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.2
	OPENBSD_6_2:1.1.1.2.0.2
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2016.09.03.22.47.01;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.01;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.07;	author patrick;	state Exp;
branches;
next	;
commitid	qMUxATnKgqN83Oct;


desc
@@


1.1
log
@Initial revision
@
text
@//==-- AArch64Schedule.td - AArch64 Scheduling Definitions -*- tablegen -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

// Define TII for use in SchedVariant Predicates.
// const MachineInstr *MI and const TargetSchedModel *SchedModel
// are defined by default.
def : PredicateProlog<[{
  const AArch64InstrInfo *TII =
    static_cast<const AArch64InstrInfo*>(SchedModel->getInstrInfo());
  (void)TII;
}]>;

// AArch64 Scheduler Definitions

def WriteImm       : SchedWrite; // MOVN, MOVZ
// TODO: Provide variants for MOV32/64imm Pseudos that dynamically
// select the correct sequence of WriteImms.

def WriteI         : SchedWrite; // ALU
def WriteISReg     : SchedWrite; // ALU of Shifted-Reg
def WriteIEReg     : SchedWrite; // ALU of Extended-Reg
def ReadI          : SchedRead;  // ALU
def ReadISReg      : SchedRead;  // ALU of Shifted-Reg
def ReadIEReg      : SchedRead;  // ALU of Extended-Reg
def WriteExtr      : SchedWrite; // EXTR shifts a reg pair
def ReadExtrHi     : SchedRead;  // Read the high reg of the EXTR pair
def WriteIS        : SchedWrite; // Shift/Scale
def WriteID32      : SchedWrite; // 32-bit Divide
def WriteID64      : SchedWrite; // 64-bit Divide
def ReadID         : SchedRead;  // 32/64-bit Divide
def WriteIM32      : SchedWrite; // 32-bit Multiply
def WriteIM64      : SchedWrite; // 64-bit Multiply
def ReadIM         : SchedRead;  // 32/64-bit Multiply
def ReadIMA        : SchedRead;  // 32/64-bit Multiply Accumulate
def WriteBr        : SchedWrite; // Branch
def WriteBrReg     : SchedWrite; // Indirect Branch

def WriteLD        : SchedWrite; // Load from base addr plus immediate offset
def WriteST        : SchedWrite; // Store to base addr plus immediate offset
def WriteSTP       : SchedWrite; // Store a register pair.
def WriteAdr       : SchedWrite; // Address pre/post increment.

def WriteLDIdx : SchedWrite; // Load from a register index (maybe scaled).
def WriteSTIdx : SchedWrite; // Store to a register index (maybe scaled).
def ReadAdrBase : SchedRead; // Read the base resister of a reg-offset LD/ST.

// Predicate for determining when a shiftable register is shifted.
def RegShiftedPred : SchedPredicate<[{TII->hasShiftedReg(MI)}]>;

// Predicate for determining when a extendedable register is extended.
def RegExtendedPred : SchedPredicate<[{TII->hasExtendedReg(MI)}]>;

// ScaledIdxPred is true if a WriteLDIdx operand will be
// scaled. Subtargets can use this to dynamically select resources and
// latency for WriteLDIdx and ReadAdrBase.
def ScaledIdxPred : SchedPredicate<[{TII->isScaledAddr(MI)}]>;

// Serialized two-level address load.
// EXAMPLE: LOADGot
def WriteLDAdr : WriteSequence<[WriteAdr, WriteLD]>;

// Serialized two-level address lookup.
// EXAMPLE: MOVaddr...
def WriteAdrAdr : WriteSequence<[WriteAdr, WriteAdr]>;

// The second register of a load-pair.
// LDP,LDPSW,LDNP,LDXP,LDAXP
def WriteLDHi : SchedWrite;

// Store-exclusive is a store followed by a dependent load.
def WriteSTX : WriteSequence<[WriteST, WriteLD]>;

def WriteSys     : SchedWrite; // Long, variable latency system ops.
def WriteBarrier : SchedWrite; // Memory barrier.
def WriteHint    : SchedWrite; // Hint instruction.

def WriteF       : SchedWrite; // General floating-point ops.
def WriteFCmp    : SchedWrite; // Floating-point compare.
def WriteFCvt    : SchedWrite; // Float conversion.
def WriteFCopy   : SchedWrite; // Float-int register copy.
def WriteFImm    : SchedWrite; // Floating-point immediate.
def WriteFMul    : SchedWrite; // Floating-point multiply.
def WriteFDiv    : SchedWrite; // Floating-point division.

def WriteV   : SchedWrite; // Vector ops.
def WriteVLD : SchedWrite; // Vector loads.
def WriteVST : SchedWrite; // Vector stores.

// Read the unwritten lanes of the VLD's destination registers.
def ReadVLD : SchedRead;

// Sequential vector load and shuffle.
def WriteVLDShuffle     : WriteSequence<[WriteVLD, WriteV]>;
def WriteVLDPairShuffle : WriteSequence<[WriteVLD, WriteV, WriteV]>;

// Store a shuffled vector.
def WriteVSTShuffle : WriteSequence<[WriteV, WriteVST]>;
def WriteVSTPairShuffle : WriteSequence<[WriteV, WriteV, WriteVST]>;
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d54 1
a54 1
def RegShiftedPred : SchedPredicate<[{TII->hasShiftedReg(*MI)}]>;
d57 1
a57 1
def RegExtendedPred : SchedPredicate<[{TII->hasExtendedReg(*MI)}]>;
d62 1
a62 1
def ScaledIdxPred : SchedPredicate<[{TII->isScaledAddr(*MI)}]>;
a93 2

def WriteAtomic : SchedWrite; // Atomic memory operations (CAS, Swap, LDOP)
@

