head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.5
	OPENBSD_6_2:1.1.1.4.0.2
	OPENBSD_6_2_BASE:1.1.1.4
	OPENBSD_6_1:1.1.1.4.0.4
	OPENBSD_6_1_BASE:1.1.1.4
	LLVM_4_0_0:1.1.1.4
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.47.01;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.01;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.08;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.30;	author patrick;	state Exp;
branches;
next	1.1.1.4;
commitid	so2WA7LCP6wbxtYl;

1.1.1.4
date	2017.03.14.08.08.09;	author patrick;	state Exp;
branches;
next	1.1.1.5;
commitid	aUi5NxOzBSLCN5eN;

1.1.1.5
date	2017.10.04.20.28.05;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//=- AArch64LoadStoreOptimizer.cpp - AArch64 load/store opt. pass -*- C++ -*-=//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file contains a pass that performs load / store related peephole
// optimizations. This pass should be run after register allocation.
//
//===----------------------------------------------------------------------===//

#include "AArch64InstrInfo.h"
#include "AArch64Subtarget.h"
#include "MCTargetDesc/AArch64AddressingModes.h"
#include "llvm/ADT/BitVector.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/ADT/Statistic.h"
#include "llvm/CodeGen/MachineBasicBlock.h"
#include "llvm/CodeGen/MachineFunctionPass.h"
#include "llvm/CodeGen/MachineInstr.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Target/TargetInstrInfo.h"
#include "llvm/Target/TargetMachine.h"
#include "llvm/Target/TargetRegisterInfo.h"
using namespace llvm;

#define DEBUG_TYPE "aarch64-ldst-opt"

/// AArch64AllocLoadStoreOpt - Post-register allocation pass to combine
/// load / store instructions to form ldp / stp instructions.

STATISTIC(NumPairCreated, "Number of load/store pair instructions generated");
STATISTIC(NumPostFolded, "Number of post-index updates folded");
STATISTIC(NumPreFolded, "Number of pre-index updates folded");
STATISTIC(NumUnscaledPairCreated,
          "Number of load/store from unscaled generated");
STATISTIC(NumNarrowLoadsPromoted, "Number of narrow loads promoted");
STATISTIC(NumZeroStoresPromoted, "Number of narrow zero stores promoted");
STATISTIC(NumLoadsFromStoresPromoted, "Number of loads from stores promoted");

static cl::opt<unsigned> ScanLimit("aarch64-load-store-scan-limit",
                                   cl::init(20), cl::Hidden);

namespace llvm {
void initializeAArch64LoadStoreOptPass(PassRegistry &);
}

#define AARCH64_LOAD_STORE_OPT_NAME "AArch64 load / store optimization pass"

namespace {

typedef struct LdStPairFlags {
  // If a matching instruction is found, MergeForward is set to true if the
  // merge is to remove the first instruction and replace the second with
  // a pair-wise insn, and false if the reverse is true.
  bool MergeForward;

  // SExtIdx gives the index of the result of the load pair that must be
  // extended. The value of SExtIdx assumes that the paired load produces the
  // value in this order: (I, returned iterator), i.e., -1 means no value has
  // to be extended, 0 means I, and 1 means the returned iterator.
  int SExtIdx;

  LdStPairFlags() : MergeForward(false), SExtIdx(-1) {}

  void setMergeForward(bool V = true) { MergeForward = V; }
  bool getMergeForward() const { return MergeForward; }

  void setSExtIdx(int V) { SExtIdx = V; }
  int getSExtIdx() const { return SExtIdx; }

} LdStPairFlags;

struct AArch64LoadStoreOpt : public MachineFunctionPass {
  static char ID;
  AArch64LoadStoreOpt() : MachineFunctionPass(ID) {
    initializeAArch64LoadStoreOptPass(*PassRegistry::getPassRegistry());
  }

  const AArch64InstrInfo *TII;
  const TargetRegisterInfo *TRI;
  const AArch64Subtarget *Subtarget;

  // Scan the instructions looking for a load/store that can be combined
  // with the current instruction into a load/store pair.
  // Return the matching instruction if one is found, else MBB->end().
  MachineBasicBlock::iterator findMatchingInsn(MachineBasicBlock::iterator I,
                                               LdStPairFlags &Flags,
                                               unsigned Limit);

  // Scan the instructions looking for a store that writes to the address from
  // which the current load instruction reads. Return true if one is found.
  bool findMatchingStore(MachineBasicBlock::iterator I, unsigned Limit,
                         MachineBasicBlock::iterator &StoreI);

  // Merge the two instructions indicated into a single pair-wise instruction.
  // If MergeForward is true, erase the first instruction and fold its
  // operation into the second. If false, the reverse. Return the instruction
  // following the first instruction (which may change during processing).
  MachineBasicBlock::iterator
  mergePairedInsns(MachineBasicBlock::iterator I,
                   MachineBasicBlock::iterator Paired,
                   const LdStPairFlags &Flags);

  // Promote the load that reads directly from the address stored to.
  MachineBasicBlock::iterator
  promoteLoadFromStore(MachineBasicBlock::iterator LoadI,
                       MachineBasicBlock::iterator StoreI);

  // Scan the instruction list to find a base register update that can
  // be combined with the current instruction (a load or store) using
  // pre or post indexed addressing with writeback. Scan forwards.
  MachineBasicBlock::iterator
  findMatchingUpdateInsnForward(MachineBasicBlock::iterator I, unsigned Limit,
                                int UnscaledOffset);

  // Scan the instruction list to find a base register update that can
  // be combined with the current instruction (a load or store) using
  // pre or post indexed addressing with writeback. Scan backwards.
  MachineBasicBlock::iterator
  findMatchingUpdateInsnBackward(MachineBasicBlock::iterator I, unsigned Limit);

  // Find an instruction that updates the base register of the ld/st
  // instruction.
  bool isMatchingUpdateInsn(MachineInstr *MemMI, MachineInstr *MI,
                            unsigned BaseReg, int Offset);

  // Merge a pre- or post-index base register update into a ld/st instruction.
  MachineBasicBlock::iterator
  mergeUpdateInsn(MachineBasicBlock::iterator I,
                  MachineBasicBlock::iterator Update, bool IsPreIdx);

  // Find and merge foldable ldr/str instructions.
  bool tryToMergeLdStInst(MachineBasicBlock::iterator &MBBI);

  // Find and promote load instructions which read directly from store.
  bool tryToPromoteLoadFromStore(MachineBasicBlock::iterator &MBBI);

  // Check if converting two narrow loads into a single wider load with
  // bitfield extracts could be enabled.
  bool enableNarrowLdMerge(MachineFunction &Fn);

  bool optimizeBlock(MachineBasicBlock &MBB, bool enableNarrowLdOpt);

  bool runOnMachineFunction(MachineFunction &Fn) override;

  const char *getPassName() const override {
    return AARCH64_LOAD_STORE_OPT_NAME;
  }
};
char AArch64LoadStoreOpt::ID = 0;
} // namespace

INITIALIZE_PASS(AArch64LoadStoreOpt, "aarch64-ldst-opt",
                AARCH64_LOAD_STORE_OPT_NAME, false, false)

static bool isUnscaledLdSt(unsigned Opc) {
  switch (Opc) {
  default:
    return false;
  case AArch64::STURSi:
  case AArch64::STURDi:
  case AArch64::STURQi:
  case AArch64::STURBBi:
  case AArch64::STURHHi:
  case AArch64::STURWi:
  case AArch64::STURXi:
  case AArch64::LDURSi:
  case AArch64::LDURDi:
  case AArch64::LDURQi:
  case AArch64::LDURWi:
  case AArch64::LDURXi:
  case AArch64::LDURSWi:
  case AArch64::LDURHHi:
  case AArch64::LDURBBi:
  case AArch64::LDURSBWi:
  case AArch64::LDURSHWi:
    return true;
  }
}

static bool isUnscaledLdSt(MachineInstr *MI) {
  return isUnscaledLdSt(MI->getOpcode());
}

static unsigned getBitExtrOpcode(MachineInstr *MI) {
  switch (MI->getOpcode()) {
  default:
    llvm_unreachable("Unexpected opcode.");
  case AArch64::LDRBBui:
  case AArch64::LDURBBi:
  case AArch64::LDRHHui:
  case AArch64::LDURHHi:
    return AArch64::UBFMWri;
  case AArch64::LDRSBWui:
  case AArch64::LDURSBWi:
  case AArch64::LDRSHWui:
  case AArch64::LDURSHWi:
    return AArch64::SBFMWri;
  }
}

static bool isNarrowStore(unsigned Opc) {
  switch (Opc) {
  default:
    return false;
  case AArch64::STRBBui:
  case AArch64::STURBBi:
  case AArch64::STRHHui:
  case AArch64::STURHHi:
    return true;
  }
}

static bool isNarrowStore(MachineInstr *MI) {
  return isNarrowStore(MI->getOpcode());
}

static bool isNarrowLoad(unsigned Opc) {
  switch (Opc) {
  default:
    return false;
  case AArch64::LDRHHui:
  case AArch64::LDURHHi:
  case AArch64::LDRBBui:
  case AArch64::LDURBBi:
  case AArch64::LDRSHWui:
  case AArch64::LDURSHWi:
  case AArch64::LDRSBWui:
  case AArch64::LDURSBWi:
    return true;
  }
}

static bool isNarrowLoad(MachineInstr *MI) {
  return isNarrowLoad(MI->getOpcode());
}

// Scaling factor for unscaled load or store.
static int getMemScale(MachineInstr *MI) {
  switch (MI->getOpcode()) {
  default:
    llvm_unreachable("Opcode has unknown scale!");
  case AArch64::LDRBBui:
  case AArch64::LDURBBi:
  case AArch64::LDRSBWui:
  case AArch64::LDURSBWi:
  case AArch64::STRBBui:
  case AArch64::STURBBi:
    return 1;
  case AArch64::LDRHHui:
  case AArch64::LDURHHi:
  case AArch64::LDRSHWui:
  case AArch64::LDURSHWi:
  case AArch64::STRHHui:
  case AArch64::STURHHi:
    return 2;
  case AArch64::LDRSui:
  case AArch64::LDURSi:
  case AArch64::LDRSWui:
  case AArch64::LDURSWi:
  case AArch64::LDRWui:
  case AArch64::LDURWi:
  case AArch64::STRSui:
  case AArch64::STURSi:
  case AArch64::STRWui:
  case AArch64::STURWi:
  case AArch64::LDPSi:
  case AArch64::LDPSWi:
  case AArch64::LDPWi:
  case AArch64::STPSi:
  case AArch64::STPWi:
    return 4;
  case AArch64::LDRDui:
  case AArch64::LDURDi:
  case AArch64::LDRXui:
  case AArch64::LDURXi:
  case AArch64::STRDui:
  case AArch64::STURDi:
  case AArch64::STRXui:
  case AArch64::STURXi:
  case AArch64::LDPDi:
  case AArch64::LDPXi:
  case AArch64::STPDi:
  case AArch64::STPXi:
    return 8;
  case AArch64::LDRQui:
  case AArch64::LDURQi:
  case AArch64::STRQui:
  case AArch64::STURQi:
  case AArch64::LDPQi:
  case AArch64::STPQi:
    return 16;
  }
}

static unsigned getMatchingNonSExtOpcode(unsigned Opc,
                                         bool *IsValidLdStrOpc = nullptr) {
  if (IsValidLdStrOpc)
    *IsValidLdStrOpc = true;
  switch (Opc) {
  default:
    if (IsValidLdStrOpc)
      *IsValidLdStrOpc = false;
    return UINT_MAX;
  case AArch64::STRDui:
  case AArch64::STURDi:
  case AArch64::STRQui:
  case AArch64::STURQi:
  case AArch64::STRBBui:
  case AArch64::STURBBi:
  case AArch64::STRHHui:
  case AArch64::STURHHi:
  case AArch64::STRWui:
  case AArch64::STURWi:
  case AArch64::STRXui:
  case AArch64::STURXi:
  case AArch64::LDRDui:
  case AArch64::LDURDi:
  case AArch64::LDRQui:
  case AArch64::LDURQi:
  case AArch64::LDRWui:
  case AArch64::LDURWi:
  case AArch64::LDRXui:
  case AArch64::LDURXi:
  case AArch64::STRSui:
  case AArch64::STURSi:
  case AArch64::LDRSui:
  case AArch64::LDURSi:
  case AArch64::LDRHHui:
  case AArch64::LDURHHi:
  case AArch64::LDRBBui:
  case AArch64::LDURBBi:
    return Opc;
  case AArch64::LDRSWui:
    return AArch64::LDRWui;
  case AArch64::LDURSWi:
    return AArch64::LDURWi;
  case AArch64::LDRSBWui:
    return AArch64::LDRBBui;
  case AArch64::LDRSHWui:
    return AArch64::LDRHHui;
  case AArch64::LDURSBWi:
    return AArch64::LDURBBi;
  case AArch64::LDURSHWi:
    return AArch64::LDURHHi;
  }
}

static unsigned getMatchingPairOpcode(unsigned Opc) {
  switch (Opc) {
  default:
    llvm_unreachable("Opcode has no pairwise equivalent!");
  case AArch64::STRSui:
  case AArch64::STURSi:
    return AArch64::STPSi;
  case AArch64::STRDui:
  case AArch64::STURDi:
    return AArch64::STPDi;
  case AArch64::STRQui:
  case AArch64::STURQi:
    return AArch64::STPQi;
  case AArch64::STRBBui:
    return AArch64::STRHHui;
  case AArch64::STRHHui:
    return AArch64::STRWui;
  case AArch64::STURBBi:
    return AArch64::STURHHi;
  case AArch64::STURHHi:
    return AArch64::STURWi;
  case AArch64::STRWui:
  case AArch64::STURWi:
    return AArch64::STPWi;
  case AArch64::STRXui:
  case AArch64::STURXi:
    return AArch64::STPXi;
  case AArch64::LDRSui:
  case AArch64::LDURSi:
    return AArch64::LDPSi;
  case AArch64::LDRDui:
  case AArch64::LDURDi:
    return AArch64::LDPDi;
  case AArch64::LDRQui:
  case AArch64::LDURQi:
    return AArch64::LDPQi;
  case AArch64::LDRWui:
  case AArch64::LDURWi:
    return AArch64::LDPWi;
  case AArch64::LDRXui:
  case AArch64::LDURXi:
    return AArch64::LDPXi;
  case AArch64::LDRSWui:
  case AArch64::LDURSWi:
    return AArch64::LDPSWi;
  case AArch64::LDRHHui:
  case AArch64::LDRSHWui:
    return AArch64::LDRWui;
  case AArch64::LDURHHi:
  case AArch64::LDURSHWi:
    return AArch64::LDURWi;
  case AArch64::LDRBBui:
  case AArch64::LDRSBWui:
    return AArch64::LDRHHui;
  case AArch64::LDURBBi:
  case AArch64::LDURSBWi:
    return AArch64::LDURHHi;
  }
}

static unsigned isMatchingStore(MachineInstr *LoadInst,
                                MachineInstr *StoreInst) {
  unsigned LdOpc = LoadInst->getOpcode();
  unsigned StOpc = StoreInst->getOpcode();
  switch (LdOpc) {
  default:
    llvm_unreachable("Unsupported load instruction!");
  case AArch64::LDRBBui:
    return StOpc == AArch64::STRBBui || StOpc == AArch64::STRHHui ||
           StOpc == AArch64::STRWui || StOpc == AArch64::STRXui;
  case AArch64::LDURBBi:
    return StOpc == AArch64::STURBBi || StOpc == AArch64::STURHHi ||
           StOpc == AArch64::STURWi || StOpc == AArch64::STURXi;
  case AArch64::LDRHHui:
    return StOpc == AArch64::STRHHui || StOpc == AArch64::STRWui ||
           StOpc == AArch64::STRXui;
  case AArch64::LDURHHi:
    return StOpc == AArch64::STURHHi || StOpc == AArch64::STURWi ||
           StOpc == AArch64::STURXi;
  case AArch64::LDRWui:
    return StOpc == AArch64::STRWui || StOpc == AArch64::STRXui;
  case AArch64::LDURWi:
    return StOpc == AArch64::STURWi || StOpc == AArch64::STURXi;
  case AArch64::LDRXui:
    return StOpc == AArch64::STRXui;
  case AArch64::LDURXi:
    return StOpc == AArch64::STURXi;
  }
}

static unsigned getPreIndexedOpcode(unsigned Opc) {
  switch (Opc) {
  default:
    llvm_unreachable("Opcode has no pre-indexed equivalent!");
  case AArch64::STRSui:
    return AArch64::STRSpre;
  case AArch64::STRDui:
    return AArch64::STRDpre;
  case AArch64::STRQui:
    return AArch64::STRQpre;
  case AArch64::STRBBui:
    return AArch64::STRBBpre;
  case AArch64::STRHHui:
    return AArch64::STRHHpre;
  case AArch64::STRWui:
    return AArch64::STRWpre;
  case AArch64::STRXui:
    return AArch64::STRXpre;
  case AArch64::LDRSui:
    return AArch64::LDRSpre;
  case AArch64::LDRDui:
    return AArch64::LDRDpre;
  case AArch64::LDRQui:
    return AArch64::LDRQpre;
  case AArch64::LDRBBui:
    return AArch64::LDRBBpre;
  case AArch64::LDRHHui:
    return AArch64::LDRHHpre;
  case AArch64::LDRWui:
    return AArch64::LDRWpre;
  case AArch64::LDRXui:
    return AArch64::LDRXpre;
  case AArch64::LDRSWui:
    return AArch64::LDRSWpre;
  case AArch64::LDPSi:
    return AArch64::LDPSpre;
  case AArch64::LDPSWi:
    return AArch64::LDPSWpre;
  case AArch64::LDPDi:
    return AArch64::LDPDpre;
  case AArch64::LDPQi:
    return AArch64::LDPQpre;
  case AArch64::LDPWi:
    return AArch64::LDPWpre;
  case AArch64::LDPXi:
    return AArch64::LDPXpre;
  case AArch64::STPSi:
    return AArch64::STPSpre;
  case AArch64::STPDi:
    return AArch64::STPDpre;
  case AArch64::STPQi:
    return AArch64::STPQpre;
  case AArch64::STPWi:
    return AArch64::STPWpre;
  case AArch64::STPXi:
    return AArch64::STPXpre;
  }
}

static unsigned getPostIndexedOpcode(unsigned Opc) {
  switch (Opc) {
  default:
    llvm_unreachable("Opcode has no post-indexed wise equivalent!");
  case AArch64::STRSui:
    return AArch64::STRSpost;
  case AArch64::STRDui:
    return AArch64::STRDpost;
  case AArch64::STRQui:
    return AArch64::STRQpost;
  case AArch64::STRBBui:
    return AArch64::STRBBpost;
  case AArch64::STRHHui:
    return AArch64::STRHHpost;
  case AArch64::STRWui:
    return AArch64::STRWpost;
  case AArch64::STRXui:
    return AArch64::STRXpost;
  case AArch64::LDRSui:
    return AArch64::LDRSpost;
  case AArch64::LDRDui:
    return AArch64::LDRDpost;
  case AArch64::LDRQui:
    return AArch64::LDRQpost;
  case AArch64::LDRBBui:
    return AArch64::LDRBBpost;
  case AArch64::LDRHHui:
    return AArch64::LDRHHpost;
  case AArch64::LDRWui:
    return AArch64::LDRWpost;
  case AArch64::LDRXui:
    return AArch64::LDRXpost;
  case AArch64::LDRSWui:
    return AArch64::LDRSWpost;
  case AArch64::LDPSi:
    return AArch64::LDPSpost;
  case AArch64::LDPSWi:
    return AArch64::LDPSWpost;
  case AArch64::LDPDi:
    return AArch64::LDPDpost;
  case AArch64::LDPQi:
    return AArch64::LDPQpost;
  case AArch64::LDPWi:
    return AArch64::LDPWpost;
  case AArch64::LDPXi:
    return AArch64::LDPXpost;
  case AArch64::STPSi:
    return AArch64::STPSpost;
  case AArch64::STPDi:
    return AArch64::STPDpost;
  case AArch64::STPQi:
    return AArch64::STPQpost;
  case AArch64::STPWi:
    return AArch64::STPWpost;
  case AArch64::STPXi:
    return AArch64::STPXpost;
  }
}

static bool isPairedLdSt(const MachineInstr *MI) {
  switch (MI->getOpcode()) {
  default:
    return false;
  case AArch64::LDPSi:
  case AArch64::LDPSWi:
  case AArch64::LDPDi:
  case AArch64::LDPQi:
  case AArch64::LDPWi:
  case AArch64::LDPXi:
  case AArch64::STPSi:
  case AArch64::STPDi:
  case AArch64::STPQi:
  case AArch64::STPWi:
  case AArch64::STPXi:
    return true;
  }
}

static const MachineOperand &getLdStRegOp(const MachineInstr *MI,
                                          unsigned PairedRegOp = 0) {
  assert(PairedRegOp < 2 && "Unexpected register operand idx.");
  unsigned Idx = isPairedLdSt(MI) ? PairedRegOp : 0;
  return MI->getOperand(Idx);
}

static const MachineOperand &getLdStBaseOp(const MachineInstr *MI) {
  unsigned Idx = isPairedLdSt(MI) ? 2 : 1;
  return MI->getOperand(Idx);
}

static const MachineOperand &getLdStOffsetOp(const MachineInstr *MI) {
  unsigned Idx = isPairedLdSt(MI) ? 3 : 2;
  return MI->getOperand(Idx);
}

static bool isLdOffsetInRangeOfSt(MachineInstr *LoadInst,
                                  MachineInstr *StoreInst) {
  assert(isMatchingStore(LoadInst, StoreInst) && "Expect only matched ld/st.");
  int LoadSize = getMemScale(LoadInst);
  int StoreSize = getMemScale(StoreInst);
  int UnscaledStOffset = isUnscaledLdSt(StoreInst)
                             ? getLdStOffsetOp(StoreInst).getImm()
                             : getLdStOffsetOp(StoreInst).getImm() * StoreSize;
  int UnscaledLdOffset = isUnscaledLdSt(LoadInst)
                             ? getLdStOffsetOp(LoadInst).getImm()
                             : getLdStOffsetOp(LoadInst).getImm() * LoadSize;
  return (UnscaledStOffset <= UnscaledLdOffset) &&
         (UnscaledLdOffset + LoadSize <= (UnscaledStOffset + StoreSize));
}

MachineBasicBlock::iterator
AArch64LoadStoreOpt::mergePairedInsns(MachineBasicBlock::iterator I,
                                      MachineBasicBlock::iterator Paired,
                                      const LdStPairFlags &Flags) {
  MachineBasicBlock::iterator NextI = I;
  ++NextI;
  // If NextI is the second of the two instructions to be merged, we need
  // to skip one further. Either way we merge will invalidate the iterator,
  // and we don't need to scan the new instruction, as it's a pairwise
  // instruction, which we're not considering for further action anyway.
  if (NextI == Paired)
    ++NextI;

  int SExtIdx = Flags.getSExtIdx();
  unsigned Opc =
      SExtIdx == -1 ? I->getOpcode() : getMatchingNonSExtOpcode(I->getOpcode());
  bool IsUnscaled = isUnscaledLdSt(Opc);
  int OffsetStride = IsUnscaled ? getMemScale(I) : 1;

  bool MergeForward = Flags.getMergeForward();
  unsigned NewOpc = getMatchingPairOpcode(Opc);
  // Insert our new paired instruction after whichever of the paired
  // instructions MergeForward indicates.
  MachineBasicBlock::iterator InsertionPoint = MergeForward ? Paired : I;
  // Also based on MergeForward is from where we copy the base register operand
  // so we get the flags compatible with the input code.
  const MachineOperand &BaseRegOp =
      MergeForward ? getLdStBaseOp(Paired) : getLdStBaseOp(I);

  // Which register is Rt and which is Rt2 depends on the offset order.
  MachineInstr *RtMI, *Rt2MI;
  if (getLdStOffsetOp(I).getImm() ==
      getLdStOffsetOp(Paired).getImm() + OffsetStride) {
    RtMI = Paired;
    Rt2MI = I;
    // Here we swapped the assumption made for SExtIdx.
    // I.e., we turn ldp I, Paired into ldp Paired, I.
    // Update the index accordingly.
    if (SExtIdx != -1)
      SExtIdx = (SExtIdx + 1) % 2;
  } else {
    RtMI = I;
    Rt2MI = Paired;
  }

  int OffsetImm = getLdStOffsetOp(RtMI).getImm();

  if (isNarrowLoad(Opc)) {
    // Change the scaled offset from small to large type.
    if (!IsUnscaled) {
      assert(((OffsetImm & 1) == 0) && "Unexpected offset to merge");
      OffsetImm /= 2;
    }
    MachineInstr *RtNewDest = MergeForward ? I : Paired;
    // When merging small (< 32 bit) loads for big-endian targets, the order of
    // the component parts gets swapped.
    if (!Subtarget->isLittleEndian())
      std::swap(RtMI, Rt2MI);
    // Construct the new load instruction.
    MachineInstr *NewMemMI, *BitExtMI1, *BitExtMI2;
    NewMemMI = BuildMI(*I->getParent(), InsertionPoint, I->getDebugLoc(),
                       TII->get(NewOpc))
                   .addOperand(getLdStRegOp(RtNewDest))
                   .addOperand(BaseRegOp)
                   .addImm(OffsetImm)
                   .setMemRefs(I->mergeMemRefsWith(*Paired));

    DEBUG(
        dbgs()
        << "Creating the new load and extract. Replacing instructions:\n    ");
    DEBUG(I->print(dbgs()));
    DEBUG(dbgs() << "    ");
    DEBUG(Paired->print(dbgs()));
    DEBUG(dbgs() << "  with instructions:\n    ");
    DEBUG((NewMemMI)->print(dbgs()));

    int Width = getMemScale(I) == 1 ? 8 : 16;
    int LSBLow = 0;
    int LSBHigh = Width;
    int ImmsLow = LSBLow + Width - 1;
    int ImmsHigh = LSBHigh + Width - 1;
    MachineInstr *ExtDestMI = MergeForward ? Paired : I;
    if ((ExtDestMI == Rt2MI) == Subtarget->isLittleEndian()) {
      // Create the bitfield extract for high bits.
      BitExtMI1 = BuildMI(*I->getParent(), InsertionPoint, I->getDebugLoc(),
                          TII->get(getBitExtrOpcode(Rt2MI)))
                      .addOperand(getLdStRegOp(Rt2MI))
                      .addReg(getLdStRegOp(RtNewDest).getReg())
                      .addImm(LSBHigh)
                      .addImm(ImmsHigh);
      // Create the bitfield extract for low bits.
      if (RtMI->getOpcode() == getMatchingNonSExtOpcode(RtMI->getOpcode())) {
        // For unsigned, prefer to use AND for low bits.
        BitExtMI2 = BuildMI(*I->getParent(), InsertionPoint, I->getDebugLoc(),
                            TII->get(AArch64::ANDWri))
                        .addOperand(getLdStRegOp(RtMI))
                        .addReg(getLdStRegOp(RtNewDest).getReg())
                        .addImm(ImmsLow);
      } else {
        BitExtMI2 = BuildMI(*I->getParent(), InsertionPoint, I->getDebugLoc(),
                            TII->get(getBitExtrOpcode(RtMI)))
                        .addOperand(getLdStRegOp(RtMI))
                        .addReg(getLdStRegOp(RtNewDest).getReg())
                        .addImm(LSBLow)
                        .addImm(ImmsLow);
      }
    } else {
      // Create the bitfield extract for low bits.
      if (RtMI->getOpcode() == getMatchingNonSExtOpcode(RtMI->getOpcode())) {
        // For unsigned, prefer to use AND for low bits.
        BitExtMI1 = BuildMI(*I->getParent(), InsertionPoint, I->getDebugLoc(),
                            TII->get(AArch64::ANDWri))
                        .addOperand(getLdStRegOp(RtMI))
                        .addReg(getLdStRegOp(RtNewDest).getReg())
                        .addImm(ImmsLow);
      } else {
        BitExtMI1 = BuildMI(*I->getParent(), InsertionPoint, I->getDebugLoc(),
                            TII->get(getBitExtrOpcode(RtMI)))
                        .addOperand(getLdStRegOp(RtMI))
                        .addReg(getLdStRegOp(RtNewDest).getReg())
                        .addImm(LSBLow)
                        .addImm(ImmsLow);
      }

      // Create the bitfield extract for high bits.
      BitExtMI2 = BuildMI(*I->getParent(), InsertionPoint, I->getDebugLoc(),
                          TII->get(getBitExtrOpcode(Rt2MI)))
                      .addOperand(getLdStRegOp(Rt2MI))
                      .addReg(getLdStRegOp(RtNewDest).getReg())
                      .addImm(LSBHigh)
                      .addImm(ImmsHigh);
    }
    DEBUG(dbgs() << "    ");
    DEBUG((BitExtMI1)->print(dbgs()));
    DEBUG(dbgs() << "    ");
    DEBUG((BitExtMI2)->print(dbgs()));
    DEBUG(dbgs() << "\n");

    // Erase the old instructions.
    I->eraseFromParent();
    Paired->eraseFromParent();
    return NextI;
  }

  // Construct the new instruction.
  MachineInstrBuilder MIB;
  if (isNarrowStore(Opc)) {
    // Change the scaled offset from small to large type.
    if (!IsUnscaled) {
      assert(((OffsetImm & 1) == 0) && "Unexpected offset to merge");
      OffsetImm /= 2;
    }
    MIB = BuildMI(*I->getParent(), InsertionPoint, I->getDebugLoc(),
                  TII->get(NewOpc))
              .addOperand(getLdStRegOp(I))
              .addOperand(BaseRegOp)
              .addImm(OffsetImm)
              .setMemRefs(I->mergeMemRefsWith(*Paired));
  } else {
    // Handle Unscaled
    if (IsUnscaled)
      OffsetImm /= OffsetStride;
    MIB = BuildMI(*I->getParent(), InsertionPoint, I->getDebugLoc(),
                  TII->get(NewOpc))
              .addOperand(getLdStRegOp(RtMI))
              .addOperand(getLdStRegOp(Rt2MI))
              .addOperand(BaseRegOp)
              .addImm(OffsetImm);
  }

  (void)MIB;

  // FIXME: Do we need/want to copy the mem operands from the source
  //        instructions? Probably. What uses them after this?

  DEBUG(dbgs() << "Creating pair load/store. Replacing instructions:\n    ");
  DEBUG(I->print(dbgs()));
  DEBUG(dbgs() << "    ");
  DEBUG(Paired->print(dbgs()));
  DEBUG(dbgs() << "  with instruction:\n    ");

  if (SExtIdx != -1) {
    // Generate the sign extension for the proper result of the ldp.
    // I.e., with X1, that would be:
    // %W1<def> = KILL %W1, %X1<imp-def>
    // %X1<def> = SBFMXri %X1<kill>, 0, 31
    MachineOperand &DstMO = MIB->getOperand(SExtIdx);
    // Right now, DstMO has the extended register, since it comes from an
    // extended opcode.
    unsigned DstRegX = DstMO.getReg();
    // Get the W variant of that register.
    unsigned DstRegW = TRI->getSubReg(DstRegX, AArch64::sub_32);
    // Update the result of LDP to use the W instead of the X variant.
    DstMO.setReg(DstRegW);
    DEBUG(((MachineInstr *)MIB)->print(dbgs()));
    DEBUG(dbgs() << "\n");
    // Make the machine verifier happy by providing a definition for
    // the X register.
    // Insert this definition right after the generated LDP, i.e., before
    // InsertionPoint.
    MachineInstrBuilder MIBKill =
        BuildMI(*I->getParent(), InsertionPoint, I->getDebugLoc(),
                TII->get(TargetOpcode::KILL), DstRegW)
            .addReg(DstRegW)
            .addReg(DstRegX, RegState::Define);
    MIBKill->getOperand(2).setImplicit();
    // Create the sign extension.
    MachineInstrBuilder MIBSXTW =
        BuildMI(*I->getParent(), InsertionPoint, I->getDebugLoc(),
                TII->get(AArch64::SBFMXri), DstRegX)
            .addReg(DstRegX)
            .addImm(0)
            .addImm(31);
    (void)MIBSXTW;
    DEBUG(dbgs() << "  Extend operand:\n    ");
    DEBUG(((MachineInstr *)MIBSXTW)->print(dbgs()));
    DEBUG(dbgs() << "\n");
  } else {
    DEBUG(((MachineInstr *)MIB)->print(dbgs()));
    DEBUG(dbgs() << "\n");
  }

  // Erase the old instructions.
  I->eraseFromParent();
  Paired->eraseFromParent();

  return NextI;
}

MachineBasicBlock::iterator
AArch64LoadStoreOpt::promoteLoadFromStore(MachineBasicBlock::iterator LoadI,
                                          MachineBasicBlock::iterator StoreI) {
  MachineBasicBlock::iterator NextI = LoadI;
  ++NextI;

  int LoadSize = getMemScale(LoadI);
  int StoreSize = getMemScale(StoreI);
  unsigned LdRt = getLdStRegOp(LoadI).getReg();
  unsigned StRt = getLdStRegOp(StoreI).getReg();
  bool IsStoreXReg = TRI->getRegClass(AArch64::GPR64RegClassID)->contains(StRt);

  assert((IsStoreXReg ||
          TRI->getRegClass(AArch64::GPR32RegClassID)->contains(StRt)) &&
         "Unexpected RegClass");

  MachineInstr *BitExtMI;
  if (LoadSize == StoreSize && (LoadSize == 4 || LoadSize == 8)) {
    // Remove the load, if the destination register of the loads is the same
    // register for stored value.
    if (StRt == LdRt && LoadSize == 8) {
      DEBUG(dbgs() << "Remove load instruction:\n    ");
      DEBUG(LoadI->print(dbgs()));
      DEBUG(dbgs() << "\n");
      LoadI->eraseFromParent();
      return NextI;
    }
    // Replace the load with a mov if the load and store are in the same size.
    BitExtMI =
        BuildMI(*LoadI->getParent(), LoadI, LoadI->getDebugLoc(),
                TII->get(IsStoreXReg ? AArch64::ORRXrs : AArch64::ORRWrs), LdRt)
            .addReg(IsStoreXReg ? AArch64::XZR : AArch64::WZR)
            .addReg(StRt)
            .addImm(AArch64_AM::getShifterImm(AArch64_AM::LSL, 0));
  } else {
    // FIXME: Currently we disable this transformation in big-endian targets as
    // performance and correctness are verified only in little-endian.
    if (!Subtarget->isLittleEndian())
      return NextI;
    bool IsUnscaled = isUnscaledLdSt(LoadI);
    assert(IsUnscaled == isUnscaledLdSt(StoreI) && "Unsupported ld/st match");
    assert(LoadSize <= StoreSize && "Invalid load size");
    int UnscaledLdOffset = IsUnscaled
                               ? getLdStOffsetOp(LoadI).getImm()
                               : getLdStOffsetOp(LoadI).getImm() * LoadSize;
    int UnscaledStOffset = IsUnscaled
                               ? getLdStOffsetOp(StoreI).getImm()
                               : getLdStOffsetOp(StoreI).getImm() * StoreSize;
    int Width = LoadSize * 8;
    int Immr = 8 * (UnscaledLdOffset - UnscaledStOffset);
    int Imms = Immr + Width - 1;
    unsigned DestReg = IsStoreXReg
                           ? TRI->getMatchingSuperReg(LdRt, AArch64::sub_32,
                                                      &AArch64::GPR64RegClass)
                           : LdRt;

    assert((UnscaledLdOffset >= UnscaledStOffset &&
            (UnscaledLdOffset + LoadSize) <= UnscaledStOffset + StoreSize) &&
           "Invalid offset");

    Immr = 8 * (UnscaledLdOffset - UnscaledStOffset);
    Imms = Immr + Width - 1;
    if (UnscaledLdOffset == UnscaledStOffset) {
      uint32_t AndMaskEncoded = ((IsStoreXReg ? 1 : 0) << 12) // N
                                | ((Immr) << 6)               // immr
                                | ((Imms) << 0)               // imms
          ;

      BitExtMI =
          BuildMI(*LoadI->getParent(), LoadI, LoadI->getDebugLoc(),
                  TII->get(IsStoreXReg ? AArch64::ANDXri : AArch64::ANDWri),
                  DestReg)
              .addReg(StRt)
              .addImm(AndMaskEncoded);
    } else {
      BitExtMI =
          BuildMI(*LoadI->getParent(), LoadI, LoadI->getDebugLoc(),
                  TII->get(IsStoreXReg ? AArch64::UBFMXri : AArch64::UBFMWri),
                  DestReg)
              .addReg(StRt)
              .addImm(Immr)
              .addImm(Imms);
    }
  }

  DEBUG(dbgs() << "Promoting load by replacing :\n    ");
  DEBUG(StoreI->print(dbgs()));
  DEBUG(dbgs() << "    ");
  DEBUG(LoadI->print(dbgs()));
  DEBUG(dbgs() << "  with instructions:\n    ");
  DEBUG(StoreI->print(dbgs()));
  DEBUG(dbgs() << "    ");
  DEBUG((BitExtMI)->print(dbgs()));
  DEBUG(dbgs() << "\n");

  // Erase the old instructions.
  LoadI->eraseFromParent();
  return NextI;
}

/// trackRegDefsUses - Remember what registers the specified instruction uses
/// and modifies.
static void trackRegDefsUses(const MachineInstr *MI, BitVector &ModifiedRegs,
                             BitVector &UsedRegs,
                             const TargetRegisterInfo *TRI) {
  for (const MachineOperand &MO : MI->operands()) {
    if (MO.isRegMask())
      ModifiedRegs.setBitsNotInMask(MO.getRegMask());

    if (!MO.isReg())
      continue;
    unsigned Reg = MO.getReg();
    if (MO.isDef()) {
      for (MCRegAliasIterator AI(Reg, TRI, true); AI.isValid(); ++AI)
        ModifiedRegs.set(*AI);
    } else {
      assert(MO.isUse() && "Reg operand not a def and not a use?!?");
      for (MCRegAliasIterator AI(Reg, TRI, true); AI.isValid(); ++AI)
        UsedRegs.set(*AI);
    }
  }
}

static bool inBoundsForPair(bool IsUnscaled, int Offset, int OffsetStride) {
  // Convert the byte-offset used by unscaled into an "element" offset used
  // by the scaled pair load/store instructions.
  if (IsUnscaled)
    Offset /= OffsetStride;

  return Offset <= 63 && Offset >= -64;
}

// Do alignment, specialized to power of 2 and for signed ints,
// avoiding having to do a C-style cast from uint_64t to int when
// using RoundUpToAlignment from include/llvm/Support/MathExtras.h.
// FIXME: Move this function to include/MathExtras.h?
static int alignTo(int Num, int PowOf2) {
  return (Num + PowOf2 - 1) & ~(PowOf2 - 1);
}

static bool mayAlias(MachineInstr *MIa, MachineInstr *MIb,
                     const AArch64InstrInfo *TII) {
  // One of the instructions must modify memory.
  if (!MIa->mayStore() && !MIb->mayStore())
    return false;

  // Both instructions must be memory operations.
  if (!MIa->mayLoadOrStore() && !MIb->mayLoadOrStore())
    return false;

  return !TII->areMemAccessesTriviallyDisjoint(MIa, MIb);
}

static bool mayAlias(MachineInstr *MIa,
                     SmallVectorImpl<MachineInstr *> &MemInsns,
                     const AArch64InstrInfo *TII) {
  for (auto &MIb : MemInsns)
    if (mayAlias(MIa, MIb, TII))
      return true;

  return false;
}

bool AArch64LoadStoreOpt::findMatchingStore(
    MachineBasicBlock::iterator I, unsigned Limit,
    MachineBasicBlock::iterator &StoreI) {
  MachineBasicBlock::iterator E = I->getParent()->begin();
  MachineBasicBlock::iterator MBBI = I;
  MachineInstr *FirstMI = I;
  unsigned BaseReg = getLdStBaseOp(FirstMI).getReg();

  // Track which registers have been modified and used between the first insn
  // and the second insn.
  BitVector ModifiedRegs, UsedRegs;
  ModifiedRegs.resize(TRI->getNumRegs());
  UsedRegs.resize(TRI->getNumRegs());

  for (unsigned Count = 0; MBBI != E && Count < Limit;) {
    --MBBI;
    MachineInstr *MI = MBBI;
    // Skip DBG_VALUE instructions. Otherwise debug info can affect the
    // optimization by changing how far we scan.
    if (MI->isDebugValue())
      continue;
    // Now that we know this is a real instruction, count it.
    ++Count;

    // If the load instruction reads directly from the address to which the
    // store instruction writes and the stored value is not modified, we can
    // promote the load. Since we do not handle stores with pre-/post-index,
    // it's unnecessary to check if BaseReg is modified by the store itself.
    if (MI->mayStore() && isMatchingStore(FirstMI, MI) &&
        BaseReg == getLdStBaseOp(MI).getReg() &&
        isLdOffsetInRangeOfSt(FirstMI, MI) &&
        !ModifiedRegs[getLdStRegOp(MI).getReg()]) {
      StoreI = MBBI;
      return true;
    }

    if (MI->isCall())
      return false;

    // Update modified / uses register lists.
    trackRegDefsUses(MI, ModifiedRegs, UsedRegs, TRI);

    // Otherwise, if the base register is modified, we have no match, so
    // return early.
    if (ModifiedRegs[BaseReg])
      return false;

    // If we encounter a store aliased with the load, return early.
    if (MI->mayStore() && mayAlias(FirstMI, MI, TII))
      return false;
  }
  return false;
}

/// findMatchingInsn - Scan the instructions looking for a load/store that can
/// be combined with the current instruction into a load/store pair.
MachineBasicBlock::iterator
AArch64LoadStoreOpt::findMatchingInsn(MachineBasicBlock::iterator I,
                                      LdStPairFlags &Flags, unsigned Limit) {
  MachineBasicBlock::iterator E = I->getParent()->end();
  MachineBasicBlock::iterator MBBI = I;
  MachineInstr *FirstMI = I;
  ++MBBI;

  unsigned Opc = FirstMI->getOpcode();
  bool MayLoad = FirstMI->mayLoad();
  bool IsUnscaled = isUnscaledLdSt(FirstMI);
  unsigned Reg = getLdStRegOp(FirstMI).getReg();
  unsigned BaseReg = getLdStBaseOp(FirstMI).getReg();
  int Offset = getLdStOffsetOp(FirstMI).getImm();
  bool IsNarrowStore = isNarrowStore(Opc);

  // For narrow stores, find only the case where the stored value is WZR.
  if (IsNarrowStore && Reg != AArch64::WZR)
    return E;

  // Early exit if the first instruction modifies the base register.
  // e.g., ldr x0, [x0]
  if (FirstMI->modifiesRegister(BaseReg, TRI))
    return E;

  // Early exit if the offset if not possible to match. (6 bits of positive
  // range, plus allow an extra one in case we find a later insn that matches
  // with Offset-1)
  int OffsetStride = IsUnscaled ? getMemScale(FirstMI) : 1;
  if (!(isNarrowLoad(Opc) || IsNarrowStore) &&
      !inBoundsForPair(IsUnscaled, Offset, OffsetStride))
    return E;

  // Track which registers have been modified and used between the first insn
  // (inclusive) and the second insn.
  BitVector ModifiedRegs, UsedRegs;
  ModifiedRegs.resize(TRI->getNumRegs());
  UsedRegs.resize(TRI->getNumRegs());

  // Remember any instructions that read/write memory between FirstMI and MI.
  SmallVector<MachineInstr *, 4> MemInsns;

  for (unsigned Count = 0; MBBI != E && Count < Limit; ++MBBI) {
    MachineInstr *MI = MBBI;
    // Skip DBG_VALUE instructions. Otherwise debug info can affect the
    // optimization by changing how far we scan.
    if (MI->isDebugValue())
      continue;

    // Now that we know this is a real instruction, count it.
    ++Count;

    bool CanMergeOpc = Opc == MI->getOpcode();
    Flags.setSExtIdx(-1);
    if (!CanMergeOpc) {
      bool IsValidLdStrOpc;
      unsigned NonSExtOpc = getMatchingNonSExtOpcode(Opc, &IsValidLdStrOpc);
      assert(IsValidLdStrOpc &&
             "Given Opc should be a Load or Store with an immediate");
      // Opc will be the first instruction in the pair.
      Flags.setSExtIdx(NonSExtOpc == (unsigned)Opc ? 1 : 0);
      CanMergeOpc = NonSExtOpc == getMatchingNonSExtOpcode(MI->getOpcode());
    }

    if (CanMergeOpc && getLdStOffsetOp(MI).isImm()) {
      assert(MI->mayLoadOrStore() && "Expected memory operation.");
      // If we've found another instruction with the same opcode, check to see
      // if the base and offset are compatible with our starting instruction.
      // These instructions all have scaled immediate operands, so we just
      // check for +1/-1. Make sure to check the new instruction offset is
      // actually an immediate and not a symbolic reference destined for
      // a relocation.
      //
      // Pairwise instructions have a 7-bit signed offset field. Single insns
      // have a 12-bit unsigned offset field. To be a valid combine, the
      // final offset must be in range.
      unsigned MIBaseReg = getLdStBaseOp(MI).getReg();
      int MIOffset = getLdStOffsetOp(MI).getImm();
      if (BaseReg == MIBaseReg && ((Offset == MIOffset + OffsetStride) ||
                                   (Offset + OffsetStride == MIOffset))) {
        int MinOffset = Offset < MIOffset ? Offset : MIOffset;
        // If this is a volatile load/store that otherwise matched, stop looking
        // as something is going on that we don't have enough information to
        // safely transform. Similarly, stop if we see a hint to avoid pairs.
        if (MI->hasOrderedMemoryRef() || TII->isLdStPairSuppressed(MI))
          return E;
        // If the resultant immediate offset of merging these instructions
        // is out of range for a pairwise instruction, bail and keep looking.
        bool MIIsUnscaled = isUnscaledLdSt(MI);
        bool IsNarrowLoad = isNarrowLoad(MI->getOpcode());
        if (!IsNarrowLoad &&
            !inBoundsForPair(MIIsUnscaled, MinOffset, OffsetStride)) {
          trackRegDefsUses(MI, ModifiedRegs, UsedRegs, TRI);
          MemInsns.push_back(MI);
          continue;
        }

        if (IsNarrowLoad || IsNarrowStore) {
          // If the alignment requirements of the scaled wide load/store
          // instruction can't express the offset of the scaled narrow
          // input, bail and keep looking.
          if (!IsUnscaled && alignTo(MinOffset, 2) != MinOffset) {
            trackRegDefsUses(MI, ModifiedRegs, UsedRegs, TRI);
            MemInsns.push_back(MI);
            continue;
          }
        } else {
          // If the alignment requirements of the paired (scaled) instruction
          // can't express the offset of the unscaled input, bail and keep
          // looking.
          if (IsUnscaled && (alignTo(MinOffset, OffsetStride) != MinOffset)) {
            trackRegDefsUses(MI, ModifiedRegs, UsedRegs, TRI);
            MemInsns.push_back(MI);
            continue;
          }
        }
        // If the destination register of the loads is the same register, bail
        // and keep looking. A load-pair instruction with both destination
        // registers the same is UNPREDICTABLE and will result in an exception.
        // For narrow stores, allow only when the stored value is the same
        // (i.e., WZR).
        if ((MayLoad && Reg == getLdStRegOp(MI).getReg()) ||
            (IsNarrowStore && Reg != getLdStRegOp(MI).getReg())) {
          trackRegDefsUses(MI, ModifiedRegs, UsedRegs, TRI);
          MemInsns.push_back(MI);
          continue;
        }

        // If the Rt of the second instruction was not modified or used between
        // the two instructions and none of the instructions between the second
        // and first alias with the second, we can combine the second into the
        // first.
        if (!ModifiedRegs[getLdStRegOp(MI).getReg()] &&
            !(MI->mayLoad() && UsedRegs[getLdStRegOp(MI).getReg()]) &&
            !mayAlias(MI, MemInsns, TII)) {
          Flags.setMergeForward(false);
          return MBBI;
        }

        // Likewise, if the Rt of the first instruction is not modified or used
        // between the two instructions and none of the instructions between the
        // first and the second alias with the first, we can combine the first
        // into the second.
        if (!ModifiedRegs[getLdStRegOp(FirstMI).getReg()] &&
            !(MayLoad && UsedRegs[getLdStRegOp(FirstMI).getReg()]) &&
            !mayAlias(FirstMI, MemInsns, TII)) {
          Flags.setMergeForward(true);
          return MBBI;
        }
        // Unable to combine these instructions due to interference in between.
        // Keep looking.
      }
    }

    // If the instruction wasn't a matching load or store.  Stop searching if we
    // encounter a call instruction that might modify memory.
    if (MI->isCall())
      return E;

    // Update modified / uses register lists.
    trackRegDefsUses(MI, ModifiedRegs, UsedRegs, TRI);

    // Otherwise, if the base register is modified, we have no match, so
    // return early.
    if (ModifiedRegs[BaseReg])
      return E;

    // Update list of instructions that read/write memory.
    if (MI->mayLoadOrStore())
      MemInsns.push_back(MI);
  }
  return E;
}

MachineBasicBlock::iterator
AArch64LoadStoreOpt::mergeUpdateInsn(MachineBasicBlock::iterator I,
                                     MachineBasicBlock::iterator Update,
                                     bool IsPreIdx) {
  assert((Update->getOpcode() == AArch64::ADDXri ||
          Update->getOpcode() == AArch64::SUBXri) &&
         "Unexpected base register update instruction to merge!");
  MachineBasicBlock::iterator NextI = I;
  // Return the instruction following the merged instruction, which is
  // the instruction following our unmerged load. Unless that's the add/sub
  // instruction we're merging, in which case it's the one after that.
  if (++NextI == Update)
    ++NextI;

  int Value = Update->getOperand(2).getImm();
  assert(AArch64_AM::getShiftValue(Update->getOperand(3).getImm()) == 0 &&
         "Can't merge 1 << 12 offset into pre-/post-indexed load / store");
  if (Update->getOpcode() == AArch64::SUBXri)
    Value = -Value;

  unsigned NewOpc = IsPreIdx ? getPreIndexedOpcode(I->getOpcode())
                             : getPostIndexedOpcode(I->getOpcode());
  MachineInstrBuilder MIB;
  if (!isPairedLdSt(I)) {
    // Non-paired instruction.
    MIB = BuildMI(*I->getParent(), I, I->getDebugLoc(), TII->get(NewOpc))
              .addOperand(getLdStRegOp(Update))
              .addOperand(getLdStRegOp(I))
              .addOperand(getLdStBaseOp(I))
              .addImm(Value);
  } else {
    // Paired instruction.
    int Scale = getMemScale(I);
    MIB = BuildMI(*I->getParent(), I, I->getDebugLoc(), TII->get(NewOpc))
              .addOperand(getLdStRegOp(Update))
              .addOperand(getLdStRegOp(I, 0))
              .addOperand(getLdStRegOp(I, 1))
              .addOperand(getLdStBaseOp(I))
              .addImm(Value / Scale);
  }
  (void)MIB;

  if (IsPreIdx)
    DEBUG(dbgs() << "Creating pre-indexed load/store.");
  else
    DEBUG(dbgs() << "Creating post-indexed load/store.");
  DEBUG(dbgs() << "    Replacing instructions:\n    ");
  DEBUG(I->print(dbgs()));
  DEBUG(dbgs() << "    ");
  DEBUG(Update->print(dbgs()));
  DEBUG(dbgs() << "  with instruction:\n    ");
  DEBUG(((MachineInstr *)MIB)->print(dbgs()));
  DEBUG(dbgs() << "\n");

  // Erase the old instructions for the block.
  I->eraseFromParent();
  Update->eraseFromParent();

  return NextI;
}

bool AArch64LoadStoreOpt::isMatchingUpdateInsn(MachineInstr *MemMI,
                                               MachineInstr *MI,
                                               unsigned BaseReg, int Offset) {
  switch (MI->getOpcode()) {
  default:
    break;
  case AArch64::SUBXri:
    // Negate the offset for a SUB instruction.
    Offset *= -1;
  // FALLTHROUGH
  case AArch64::ADDXri:
    // Make sure it's a vanilla immediate operand, not a relocation or
    // anything else we can't handle.
    if (!MI->getOperand(2).isImm())
      break;
    // Watch out for 1 << 12 shifted value.
    if (AArch64_AM::getShiftValue(MI->getOperand(3).getImm()))
      break;

    // The update instruction source and destination register must be the
    // same as the load/store base register.
    if (MI->getOperand(0).getReg() != BaseReg ||
        MI->getOperand(1).getReg() != BaseReg)
      break;

    bool IsPairedInsn = isPairedLdSt(MemMI);
    int UpdateOffset = MI->getOperand(2).getImm();
    // For non-paired load/store instructions, the immediate must fit in a
    // signed 9-bit integer.
    if (!IsPairedInsn && (UpdateOffset > 255 || UpdateOffset < -256))
      break;

    // For paired load/store instructions, the immediate must be a multiple of
    // the scaling factor.  The scaled offset must also fit into a signed 7-bit
    // integer.
    if (IsPairedInsn) {
      int Scale = getMemScale(MemMI);
      if (UpdateOffset % Scale != 0)
        break;

      int ScaledOffset = UpdateOffset / Scale;
      if (ScaledOffset > 64 || ScaledOffset < -64)
        break;
    }

    // If we have a non-zero Offset, we check that it matches the amount
    // we're adding to the register.
    if (!Offset || Offset == MI->getOperand(2).getImm())
      return true;
    break;
  }
  return false;
}

MachineBasicBlock::iterator AArch64LoadStoreOpt::findMatchingUpdateInsnForward(
    MachineBasicBlock::iterator I, unsigned Limit, int UnscaledOffset) {
  MachineBasicBlock::iterator E = I->getParent()->end();
  MachineInstr *MemMI = I;
  MachineBasicBlock::iterator MBBI = I;

  unsigned BaseReg = getLdStBaseOp(MemMI).getReg();
  int MIUnscaledOffset = getLdStOffsetOp(MemMI).getImm() * getMemScale(MemMI);

  // Scan forward looking for post-index opportunities.  Updating instructions
  // can't be formed if the memory instruction doesn't have the offset we're
  // looking for.
  if (MIUnscaledOffset != UnscaledOffset)
    return E;

  // If the base register overlaps a destination register, we can't
  // merge the update.
  bool IsPairedInsn = isPairedLdSt(MemMI);
  for (unsigned i = 0, e = IsPairedInsn ? 2 : 1; i != e; ++i) {
    unsigned DestReg = getLdStRegOp(MemMI, i).getReg();
    if (DestReg == BaseReg || TRI->isSubRegister(BaseReg, DestReg))
      return E;
  }

  // Track which registers have been modified and used between the first insn
  // (inclusive) and the second insn.
  BitVector ModifiedRegs, UsedRegs;
  ModifiedRegs.resize(TRI->getNumRegs());
  UsedRegs.resize(TRI->getNumRegs());
  ++MBBI;
  for (unsigned Count = 0; MBBI != E; ++MBBI) {
    MachineInstr *MI = MBBI;
    // Skip DBG_VALUE instructions. Otherwise debug info can affect the
    // optimization by changing how far we scan.
    if (MI->isDebugValue())
      continue;

    // Now that we know this is a real instruction, count it.
    ++Count;

    // If we found a match, return it.
    if (isMatchingUpdateInsn(I, MI, BaseReg, UnscaledOffset))
      return MBBI;

    // Update the status of what the instruction clobbered and used.
    trackRegDefsUses(MI, ModifiedRegs, UsedRegs, TRI);

    // Otherwise, if the base register is used or modified, we have no match, so
    // return early.
    if (ModifiedRegs[BaseReg] || UsedRegs[BaseReg])
      return E;
  }
  return E;
}

MachineBasicBlock::iterator AArch64LoadStoreOpt::findMatchingUpdateInsnBackward(
    MachineBasicBlock::iterator I, unsigned Limit) {
  MachineBasicBlock::iterator B = I->getParent()->begin();
  MachineBasicBlock::iterator E = I->getParent()->end();
  MachineInstr *MemMI = I;
  MachineBasicBlock::iterator MBBI = I;

  unsigned BaseReg = getLdStBaseOp(MemMI).getReg();
  int Offset = getLdStOffsetOp(MemMI).getImm();

  // If the load/store is the first instruction in the block, there's obviously
  // not any matching update. Ditto if the memory offset isn't zero.
  if (MBBI == B || Offset != 0)
    return E;
  // If the base register overlaps a destination register, we can't
  // merge the update.
  bool IsPairedInsn = isPairedLdSt(MemMI);
  for (unsigned i = 0, e = IsPairedInsn ? 2 : 1; i != e; ++i) {
    unsigned DestReg = getLdStRegOp(MemMI, i).getReg();
    if (DestReg == BaseReg || TRI->isSubRegister(BaseReg, DestReg))
      return E;
  }

  // Track which registers have been modified and used between the first insn
  // (inclusive) and the second insn.
  BitVector ModifiedRegs, UsedRegs;
  ModifiedRegs.resize(TRI->getNumRegs());
  UsedRegs.resize(TRI->getNumRegs());
  --MBBI;
  for (unsigned Count = 0; MBBI != B; --MBBI) {
    MachineInstr *MI = MBBI;
    // Skip DBG_VALUE instructions. Otherwise debug info can affect the
    // optimization by changing how far we scan.
    if (MI->isDebugValue())
      continue;

    // Now that we know this is a real instruction, count it.
    ++Count;

    // If we found a match, return it.
    if (isMatchingUpdateInsn(I, MI, BaseReg, Offset))
      return MBBI;

    // Update the status of what the instruction clobbered and used.
    trackRegDefsUses(MI, ModifiedRegs, UsedRegs, TRI);

    // Otherwise, if the base register is used or modified, we have no match, so
    // return early.
    if (ModifiedRegs[BaseReg] || UsedRegs[BaseReg])
      return E;
  }
  return E;
}

bool AArch64LoadStoreOpt::tryToPromoteLoadFromStore(
    MachineBasicBlock::iterator &MBBI) {
  MachineInstr *MI = MBBI;
  // If this is a volatile load, don't mess with it.
  if (MI->hasOrderedMemoryRef())
    return false;

  // Make sure this is a reg+imm.
  // FIXME: It is possible to extend it to handle reg+reg cases.
  if (!getLdStOffsetOp(MI).isImm())
    return false;

  // Look backward up to ScanLimit instructions.
  MachineBasicBlock::iterator StoreI;
  if (findMatchingStore(MBBI, ScanLimit, StoreI)) {
    ++NumLoadsFromStoresPromoted;
    // Promote the load. Keeping the iterator straight is a
    // pain, so we let the merge routine tell us what the next instruction
    // is after it's done mucking about.
    MBBI = promoteLoadFromStore(MBBI, StoreI);
    return true;
  }
  return false;
}

bool AArch64LoadStoreOpt::tryToMergeLdStInst(
    MachineBasicBlock::iterator &MBBI) {
  MachineInstr *MI = MBBI;
  MachineBasicBlock::iterator E = MI->getParent()->end();
  // If this is a volatile load/store, don't mess with it.
  if (MI->hasOrderedMemoryRef())
    return false;

  // Make sure this is a reg+imm (as opposed to an address reloc).
  if (!getLdStOffsetOp(MI).isImm())
    return false;

  // Check if this load/store has a hint to avoid pair formation.
  // MachineMemOperands hints are set by the AArch64StorePairSuppress pass.
  if (TII->isLdStPairSuppressed(MI))
    return false;

  // Look ahead up to ScanLimit instructions for a pairable instruction.
  LdStPairFlags Flags;
  MachineBasicBlock::iterator Paired = findMatchingInsn(MBBI, Flags, ScanLimit);
  if (Paired != E) {
    if (isNarrowLoad(MI)) {
      ++NumNarrowLoadsPromoted;
    } else if (isNarrowStore(MI)) {
      ++NumZeroStoresPromoted;
    } else {
      ++NumPairCreated;
      if (isUnscaledLdSt(MI))
        ++NumUnscaledPairCreated;
    }

    // Merge the loads into a pair. Keeping the iterator straight is a
    // pain, so we let the merge routine tell us what the next instruction
    // is after it's done mucking about.
    MBBI = mergePairedInsns(MBBI, Paired, Flags);
    return true;
  }
  return false;
}

bool AArch64LoadStoreOpt::optimizeBlock(MachineBasicBlock &MBB,
                                        bool enableNarrowLdOpt) {
  bool Modified = false;
  // Three tranformations to do here:
  // 1) Find loads that directly read from stores and promote them by
  //    replacing with mov instructions. If the store is wider than the load,
  //    the load will be replaced with a bitfield extract.
  //      e.g.,
  //        str w1, [x0, #4]
  //        ldrh w2, [x0, #6]
  //        ; becomes
  //        str w1, [x0, #4]
  //        lsr	w2, w1, #16
  // 2) Find narrow loads that can be converted into a single wider load
  //    with bitfield extract instructions.
  //      e.g.,
  //        ldrh w0, [x2]
  //        ldrh w1, [x2, #2]
  //        ; becomes
  //        ldr w0, [x2]
  //        ubfx w1, w0, #16, #16
  //        and w0, w0, #ffff
  // 3) Find loads and stores that can be merged into a single load or store
  //    pair instruction.
  //      e.g.,
  //        ldr x0, [x2]
  //        ldr x1, [x2, #8]
  //        ; becomes
  //        ldp x0, x1, [x2]
  // 4) Find base register updates that can be merged into the load or store
  //    as a base-reg writeback.
  //      e.g.,
  //        ldr x0, [x2]
  //        add x2, x2, #4
  //        ; becomes
  //        ldr x0, [x2], #4

  for (MachineBasicBlock::iterator MBBI = MBB.begin(), E = MBB.end();
       MBBI != E;) {
    MachineInstr *MI = MBBI;
    switch (MI->getOpcode()) {
    default:
      // Just move on to the next instruction.
      ++MBBI;
      break;
    // Scaled instructions.
    case AArch64::LDRBBui:
    case AArch64::LDRHHui:
    case AArch64::LDRWui:
    case AArch64::LDRXui:
    // Unscaled instructions.
    case AArch64::LDURBBi:
    case AArch64::LDURHHi:
    case AArch64::LDURWi:
    case AArch64::LDURXi: {
      if (tryToPromoteLoadFromStore(MBBI)) {
        Modified = true;
        break;
      }
      ++MBBI;
      break;
    }
      // FIXME: Do the other instructions.
    }
  }

  for (MachineBasicBlock::iterator MBBI = MBB.begin(), E = MBB.end();
       enableNarrowLdOpt && MBBI != E;) {
    MachineInstr *MI = MBBI;
    switch (MI->getOpcode()) {
    default:
      // Just move on to the next instruction.
      ++MBBI;
      break;
    // Scaled instructions.
    case AArch64::LDRBBui:
    case AArch64::LDRHHui:
    case AArch64::LDRSBWui:
    case AArch64::LDRSHWui:
    case AArch64::STRBBui:
    case AArch64::STRHHui:
    // Unscaled instructions.
    case AArch64::LDURBBi:
    case AArch64::LDURHHi:
    case AArch64::LDURSBWi:
    case AArch64::LDURSHWi:
    case AArch64::STURBBi:
    case AArch64::STURHHi: {
      if (tryToMergeLdStInst(MBBI)) {
        Modified = true;
        break;
      }
      ++MBBI;
      break;
    }
      // FIXME: Do the other instructions.
    }
  }

  for (MachineBasicBlock::iterator MBBI = MBB.begin(), E = MBB.end();
       MBBI != E;) {
    MachineInstr *MI = MBBI;
    switch (MI->getOpcode()) {
    default:
      // Just move on to the next instruction.
      ++MBBI;
      break;
    // Scaled instructions.
    case AArch64::STRSui:
    case AArch64::STRDui:
    case AArch64::STRQui:
    case AArch64::STRXui:
    case AArch64::STRWui:
    case AArch64::LDRSui:
    case AArch64::LDRDui:
    case AArch64::LDRQui:
    case AArch64::LDRXui:
    case AArch64::LDRWui:
    case AArch64::LDRSWui:
    // Unscaled instructions.
    case AArch64::STURSi:
    case AArch64::STURDi:
    case AArch64::STURQi:
    case AArch64::STURWi:
    case AArch64::STURXi:
    case AArch64::LDURSi:
    case AArch64::LDURDi:
    case AArch64::LDURQi:
    case AArch64::LDURWi:
    case AArch64::LDURXi:
    case AArch64::LDURSWi: {
      if (tryToMergeLdStInst(MBBI)) {
        Modified = true;
        break;
      }
      ++MBBI;
      break;
    }
      // FIXME: Do the other instructions.
    }
  }

  for (MachineBasicBlock::iterator MBBI = MBB.begin(), E = MBB.end();
       MBBI != E;) {
    MachineInstr *MI = MBBI;
    // Do update merging. It's simpler to keep this separate from the above
    // switch, though not strictly necessary.
    unsigned Opc = MI->getOpcode();
    switch (Opc) {
    default:
      // Just move on to the next instruction.
      ++MBBI;
      break;
    // Scaled instructions.
    case AArch64::STRSui:
    case AArch64::STRDui:
    case AArch64::STRQui:
    case AArch64::STRXui:
    case AArch64::STRWui:
    case AArch64::STRHHui:
    case AArch64::STRBBui:
    case AArch64::LDRSui:
    case AArch64::LDRDui:
    case AArch64::LDRQui:
    case AArch64::LDRXui:
    case AArch64::LDRWui:
    case AArch64::LDRHHui:
    case AArch64::LDRBBui:
    // Unscaled instructions.
    case AArch64::STURSi:
    case AArch64::STURDi:
    case AArch64::STURQi:
    case AArch64::STURWi:
    case AArch64::STURXi:
    case AArch64::LDURSi:
    case AArch64::LDURDi:
    case AArch64::LDURQi:
    case AArch64::LDURWi:
    case AArch64::LDURXi:
    // Paired instructions.
    case AArch64::LDPSi:
    case AArch64::LDPSWi:
    case AArch64::LDPDi:
    case AArch64::LDPQi:
    case AArch64::LDPWi:
    case AArch64::LDPXi:
    case AArch64::STPSi:
    case AArch64::STPDi:
    case AArch64::STPQi:
    case AArch64::STPWi:
    case AArch64::STPXi: {
      // Make sure this is a reg+imm (as opposed to an address reloc).
      if (!getLdStOffsetOp(MI).isImm()) {
        ++MBBI;
        break;
      }
      // Look forward to try to form a post-index instruction. For example,
      // ldr x0, [x20]
      // add x20, x20, #32
      //   merged into:
      // ldr x0, [x20], #32
      MachineBasicBlock::iterator Update =
          findMatchingUpdateInsnForward(MBBI, ScanLimit, 0);
      if (Update != E) {
        // Merge the update into the ld/st.
        MBBI = mergeUpdateInsn(MBBI, Update, /*IsPreIdx=*/false);
        Modified = true;
        ++NumPostFolded;
        break;
      }
      // Don't know how to handle pre/post-index versions, so move to the next
      // instruction.
      if (isUnscaledLdSt(Opc)) {
        ++MBBI;
        break;
      }

      // Look back to try to find a pre-index instruction. For example,
      // add x0, x0, #8
      // ldr x1, [x0]
      //   merged into:
      // ldr x1, [x0, #8]!
      Update = findMatchingUpdateInsnBackward(MBBI, ScanLimit);
      if (Update != E) {
        // Merge the update into the ld/st.
        MBBI = mergeUpdateInsn(MBBI, Update, /*IsPreIdx=*/true);
        Modified = true;
        ++NumPreFolded;
        break;
      }
      // The immediate in the load/store is scaled by the size of the memory
      // operation. The immediate in the add we're looking for,
      // however, is not, so adjust here.
      int UnscaledOffset = getLdStOffsetOp(MI).getImm() * getMemScale(MI);

      // Look forward to try to find a post-index instruction. For example,
      // ldr x1, [x0, #64]
      // add x0, x0, #64
      //   merged into:
      // ldr x1, [x0, #64]!
      Update = findMatchingUpdateInsnForward(MBBI, ScanLimit, UnscaledOffset);
      if (Update != E) {
        // Merge the update into the ld/st.
        MBBI = mergeUpdateInsn(MBBI, Update, /*IsPreIdx=*/true);
        Modified = true;
        ++NumPreFolded;
        break;
      }

      // Nothing found. Just move to the next instruction.
      ++MBBI;
      break;
    }
      // FIXME: Do the other instructions.
    }
  }

  return Modified;
}

bool AArch64LoadStoreOpt::enableNarrowLdMerge(MachineFunction &Fn) {
  bool ProfitableArch = Subtarget->isCortexA57();
  // FIXME: The benefit from converting narrow loads into a wider load could be
  // microarchitectural as it assumes that a single load with two bitfield
  // extracts is cheaper than two narrow loads. Currently, this conversion is
  // enabled only in cortex-a57 on which performance benefits were verified.
  return ProfitableArch && !Subtarget->requiresStrictAlign();
}

bool AArch64LoadStoreOpt::runOnMachineFunction(MachineFunction &Fn) {
  Subtarget = &static_cast<const AArch64Subtarget &>(Fn.getSubtarget());
  TII = static_cast<const AArch64InstrInfo *>(Subtarget->getInstrInfo());
  TRI = Subtarget->getRegisterInfo();

  bool Modified = false;
  bool enableNarrowLdOpt = enableNarrowLdMerge(Fn);
  for (auto &MBB : Fn)
    Modified |= optimizeBlock(MBB, enableNarrowLdOpt);

  return Modified;
}

// FIXME: Do we need/want a pre-alloc pass like ARM has to try to keep
// loads and stores near one another?

/// createAArch64LoadStoreOptimizationPass - returns an instance of the
/// load / store optimization pass.
FunctionPass *llvm::createAArch64LoadStoreOptimizationPass() {
  return new AArch64LoadStoreOpt();
}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d36 3
d48 1
a48 2
// The LdStLimit limits how far we search for load/store pairs.
static cl::opt<unsigned> LdStLimit("aarch64-load-store-scan-limit",
a50 9
// The UpdateLimit limits how far we search for update instructions when we form
// pre-/post-index instructions.
static cl::opt<unsigned> UpdateLimit("aarch64-update-scan-limit", cl::init(100),
                                     cl::Hidden);

static cl::opt<bool> EnableNarrowLdMerge("enable-narrow-ld-merge", cl::Hidden,
                                         cl::init(false),
                                         cl::desc("Enable narrow load merge"));

a90 3
  // Track which registers have been modified and used.
  BitVector ModifiedRegs, UsedRegs;

d96 1
a96 2
                                               unsigned Limit,
                                               bool FindNarrowMerge);
a102 6
  // Merge the two instructions indicated into a wider instruction.
  MachineBasicBlock::iterator
  mergeNarrowInsns(MachineBasicBlock::iterator I,
                   MachineBasicBlock::iterator MergeMI,
                   const LdStPairFlags &Flags);

d104 3
d121 2
a122 2
  findMatchingUpdateInsnForward(MachineBasicBlock::iterator I,
                                int UnscaledOffset, unsigned Limit);
d132 1
a132 1
  bool isMatchingUpdateInsn(MachineInstr &MemMI, MachineInstr &MI,
a142 3
  // Find and pair ldr/str instructions.
  bool tryToPairLdStInst(MachineBasicBlock::iterator &MBBI);

d146 4
a153 5
  MachineFunctionProperties getRequiredProperties() const override {
    return MachineFunctionProperties().set(
        MachineFunctionProperties::Property::AllVRegsAllocated);
  }

d164 31
a194 2
static unsigned getBitExtrOpcode(MachineInstr &MI) {
  switch (MI.getOpcode()) {
d222 4
d242 2
a243 6
static bool isNarrowLoad(MachineInstr &MI) {
  return isNarrowLoad(MI.getOpcode());
}

static bool isNarrowLoadOrStore(unsigned Opc) {
  return isNarrowLoad(Opc) || isNarrowStore(Opc);
d247 2
a248 2
static int getMemScale(MachineInstr &MI) {
  switch (MI.getOpcode()) {
a356 31
static unsigned getMatchingWideOpcode(unsigned Opc) {
  switch (Opc) {
  default:
    llvm_unreachable("Opcode has no wide equivalent!");
  case AArch64::STRBBui:
    return AArch64::STRHHui;
  case AArch64::STRHHui:
    return AArch64::STRWui;
  case AArch64::STURBBi:
    return AArch64::STURHHi;
  case AArch64::STURHHi:
    return AArch64::STURWi;
  case AArch64::STURWi:
    return AArch64::STURXi;
  case AArch64::STRWui:
    return AArch64::STRXui;
  case AArch64::LDRHHui:
  case AArch64::LDRSHWui:
    return AArch64::LDRWui;
  case AArch64::LDURHHi:
  case AArch64::LDURSHWi:
    return AArch64::LDURWi;
  case AArch64::LDRBBui:
  case AArch64::LDRSBWui:
    return AArch64::LDRHHui;
  case AArch64::LDURBBi:
  case AArch64::LDURSBWi:
    return AArch64::LDURHHi;
  }
}

d370 8
d402 12
d417 4
a420 4
static unsigned isMatchingStore(MachineInstr &LoadInst,
                                MachineInstr &StoreInst) {
  unsigned LdOpc = LoadInst.getOpcode();
  unsigned StOpc = StoreInst.getOpcode();
d565 2
a566 2
static bool isPairedLdSt(const MachineInstr &MI) {
  switch (MI.getOpcode()) {
d584 1
a584 1
static const MachineOperand &getLdStRegOp(const MachineInstr &MI,
d588 1
a588 1
  return MI.getOperand(Idx);
d591 1
a591 1
static const MachineOperand &getLdStBaseOp(const MachineInstr &MI) {
d593 1
a593 1
  return MI.getOperand(Idx);
d596 1
a596 1
static const MachineOperand &getLdStOffsetOp(const MachineInstr &MI) {
d598 1
a598 1
  return MI.getOperand(Idx);
d601 2
a602 3
static bool isLdOffsetInRangeOfSt(MachineInstr &LoadInst,
                                  MachineInstr &StoreInst,
                                  const AArch64InstrInfo *TII) {
d606 1
a606 1
  int UnscaledStOffset = TII->isUnscaledLdSt(StoreInst)
d609 1
a609 1
  int UnscaledLdOffset = TII->isUnscaledLdSt(LoadInst)
a615 13
static bool isPromotableZeroStoreOpcode(unsigned Opc) {
  return isNarrowStore(Opc) || Opc == AArch64::STRWui || Opc == AArch64::STURWi;
}

static bool isPromotableZeroStoreOpcode(MachineInstr &MI) {
  return isPromotableZeroStoreOpcode(MI.getOpcode());
}

static bool isPromotableZeroStoreInst(MachineInstr &MI) {
  return (isPromotableZeroStoreOpcode(MI)) &&
         getLdStRegOp(MI).getReg() == AArch64::WZR;
}

d617 2
a618 2
AArch64LoadStoreOpt::mergeNarrowInsns(MachineBasicBlock::iterator I,
                                      MachineBasicBlock::iterator MergeMI,
d626 1
a626 1
  if (NextI == MergeMI)
d629 5
a633 3
  unsigned Opc = I->getOpcode();
  bool IsScaled = !TII->isUnscaledLdSt(Opc);
  int OffsetStride = IsScaled ? 1 : getMemScale(*I);
d636 1
d639 1
a639 1
  MachineBasicBlock::iterator InsertionPoint = MergeForward ? MergeMI : I;
d643 1
a643 1
      MergeForward ? getLdStBaseOp(*MergeMI) : getLdStBaseOp(*I);
d647 9
a655 4
  if (getLdStOffsetOp(*I).getImm() ==
      getLdStOffsetOp(*MergeMI).getImm() + OffsetStride) {
    RtMI = &*MergeMI;
    Rt2MI = &*I;
d657 2
a658 2
    RtMI = &*I;
    Rt2MI = &*MergeMI;
d661 1
a661 6
  int OffsetImm = getLdStOffsetOp(*RtMI).getImm();
  // Change the scaled offset from small to large type.
  if (IsScaled) {
    assert(((OffsetImm & 1) == 0) && "Unexpected offset to merge");
    OffsetImm /= 2;
  }
a662 2
  DebugLoc DL = I->getDebugLoc();
  MachineBasicBlock *MBB = I->getParent();
d664 6
a669 1
    MachineInstr *RtNewDest = &*(MergeForward ? I : MergeMI);
d676 6
a681 7
    NewMemMI =
        BuildMI(*MBB, InsertionPoint, DL, TII->get(getMatchingWideOpcode(Opc)))
            .addOperand(getLdStRegOp(*RtNewDest))
            .addOperand(BaseRegOp)
            .addImm(OffsetImm)
            .setMemRefs(I->mergeMemRefsWith(*MergeMI));
    (void)NewMemMI;
d688 1
a688 1
    DEBUG(MergeMI->print(dbgs()));
d692 1
a692 1
    int Width = getMemScale(*I) == 1 ? 8 : 16;
d697 1
a697 1
    MachineInstr *ExtDestMI = &*(MergeForward ? MergeMI : I);
d700 6
a705 6
      BitExtMI1 =
          BuildMI(*MBB, InsertionPoint, DL, TII->get(getBitExtrOpcode(*Rt2MI)))
              .addOperand(getLdStRegOp(*Rt2MI))
              .addReg(getLdStRegOp(*RtNewDest).getReg())
              .addImm(LSBHigh)
              .addImm(ImmsHigh);
d709 4
a712 3
        BitExtMI2 = BuildMI(*MBB, InsertionPoint, DL, TII->get(AArch64::ANDWri))
                        .addOperand(getLdStRegOp(*RtMI))
                        .addReg(getLdStRegOp(*RtNewDest).getReg())
d715 6
a720 6
        BitExtMI2 =
            BuildMI(*MBB, InsertionPoint, DL, TII->get(getBitExtrOpcode(*RtMI)))
                .addOperand(getLdStRegOp(*RtMI))
                .addReg(getLdStRegOp(*RtNewDest).getReg())
                .addImm(LSBLow)
                .addImm(ImmsLow);
d726 4
a729 3
        BitExtMI1 = BuildMI(*MBB, InsertionPoint, DL, TII->get(AArch64::ANDWri))
                        .addOperand(getLdStRegOp(*RtMI))
                        .addReg(getLdStRegOp(*RtNewDest).getReg())
d732 6
a737 6
        BitExtMI1 =
            BuildMI(*MBB, InsertionPoint, DL, TII->get(getBitExtrOpcode(*RtMI)))
                .addOperand(getLdStRegOp(*RtMI))
                .addReg(getLdStRegOp(*RtNewDest).getReg())
                .addImm(LSBLow)
                .addImm(ImmsLow);
d741 6
a746 6
      BitExtMI2 =
          BuildMI(*MBB, InsertionPoint, DL, TII->get(getBitExtrOpcode(*Rt2MI)))
              .addOperand(getLdStRegOp(*Rt2MI))
              .addReg(getLdStRegOp(*RtNewDest).getReg())
              .addImm(LSBHigh)
              .addImm(ImmsHigh);
a747 3
    (void)BitExtMI1;
    (void)BitExtMI2;

d756 1
a756 1
    MergeMI->eraseFromParent();
a758 2
  assert(isPromotableZeroStoreInst(*I) && isPromotableZeroStoreInst(*MergeMI) &&
         "Expected promotable zero store");
d762 5
a766 65
  MIB = BuildMI(*MBB, InsertionPoint, DL, TII->get(getMatchingWideOpcode(Opc)))
            .addReg(isNarrowStore(Opc) ? AArch64::WZR : AArch64::XZR)
            .addOperand(BaseRegOp)
            .addImm(OffsetImm)
            .setMemRefs(I->mergeMemRefsWith(*MergeMI));
  (void)MIB;

  DEBUG(dbgs() << "Creating wider load/store. Replacing instructions:\n    ");
  DEBUG(I->print(dbgs()));
  DEBUG(dbgs() << "    ");
  DEBUG(MergeMI->print(dbgs()));
  DEBUG(dbgs() << "  with instruction:\n    ");
  DEBUG(((MachineInstr *)MIB)->print(dbgs()));
  DEBUG(dbgs() << "\n");

  // Erase the old instructions.
  I->eraseFromParent();
  MergeMI->eraseFromParent();
  return NextI;
}

MachineBasicBlock::iterator
AArch64LoadStoreOpt::mergePairedInsns(MachineBasicBlock::iterator I,
                                      MachineBasicBlock::iterator Paired,
                                      const LdStPairFlags &Flags) {
  MachineBasicBlock::iterator NextI = I;
  ++NextI;
  // If NextI is the second of the two instructions to be merged, we need
  // to skip one further. Either way we merge will invalidate the iterator,
  // and we don't need to scan the new instruction, as it's a pairwise
  // instruction, which we're not considering for further action anyway.
  if (NextI == Paired)
    ++NextI;

  int SExtIdx = Flags.getSExtIdx();
  unsigned Opc =
      SExtIdx == -1 ? I->getOpcode() : getMatchingNonSExtOpcode(I->getOpcode());
  bool IsUnscaled = TII->isUnscaledLdSt(Opc);
  int OffsetStride = IsUnscaled ? getMemScale(*I) : 1;

  bool MergeForward = Flags.getMergeForward();
  // Insert our new paired instruction after whichever of the paired
  // instructions MergeForward indicates.
  MachineBasicBlock::iterator InsertionPoint = MergeForward ? Paired : I;
  // Also based on MergeForward is from where we copy the base register operand
  // so we get the flags compatible with the input code.
  const MachineOperand &BaseRegOp =
      MergeForward ? getLdStBaseOp(*Paired) : getLdStBaseOp(*I);

  int Offset = getLdStOffsetOp(*I).getImm();
  int PairedOffset = getLdStOffsetOp(*Paired).getImm();
  bool PairedIsUnscaled = TII->isUnscaledLdSt(Paired->getOpcode());
  if (IsUnscaled != PairedIsUnscaled) {
    // We're trying to pair instructions that differ in how they are scaled.  If
    // I is scaled then scale the offset of Paired accordingly.  Otherwise, do
    // the opposite (i.e., make Paired's offset unscaled).
    int MemSize = getMemScale(*Paired);
    if (PairedIsUnscaled) {
      // If the unscaled offset isn't a multiple of the MemSize, we can't
      // pair the operations together.
      assert(!(PairedOffset % getMemScale(*Paired)) &&
             "Offset should be a multiple of the stride!");
      PairedOffset /= MemSize;
    } else {
      PairedOffset *= MemSize;
d768 6
a773 12
  }

  // Which register is Rt and which is Rt2 depends on the offset order.
  MachineInstr *RtMI, *Rt2MI;
  if (Offset == PairedOffset + OffsetStride) {
    RtMI = &*Paired;
    Rt2MI = &*I;
    // Here we swapped the assumption made for SExtIdx.
    // I.e., we turn ldp I, Paired into ldp Paired, I.
    // Update the index accordingly.
    if (SExtIdx != -1)
      SExtIdx = (SExtIdx + 1) % 2;
d775 9
a783 9
    RtMI = &*I;
    Rt2MI = &*Paired;
  }
  int OffsetImm = getLdStOffsetOp(*RtMI).getImm();
  // Scale the immediate offset, if necessary.
  if (TII->isUnscaledLdSt(RtMI->getOpcode())) {
    assert(!(OffsetImm % getMemScale(*RtMI)) &&
           "Unscaled offset cannot be scaled.");
    OffsetImm /= getMemScale(*RtMI);
d786 1
a786 10
  // Construct the new instruction.
  MachineInstrBuilder MIB;
  DebugLoc DL = I->getDebugLoc();
  MachineBasicBlock *MBB = I->getParent();
  MIB = BuildMI(*MBB, InsertionPoint, DL, TII->get(getMatchingPairOpcode(Opc)))
            .addOperand(getLdStRegOp(*RtMI))
            .addOperand(getLdStRegOp(*Rt2MI))
            .addOperand(BaseRegOp)
            .addImm(OffsetImm)
            .setMemRefs(I->mergeMemRefsWith(*Paired));
d788 2
a789 1
  (void)MIB;
d796 1
d817 2
a818 1
        BuildMI(*MBB, InsertionPoint, DL, TII->get(TargetOpcode::KILL), DstRegW)
d824 2
a825 1
        BuildMI(*MBB, InsertionPoint, DL, TII->get(AArch64::SBFMXri), DstRegX)
d832 1
d835 1
a836 1
  DEBUG(dbgs() << "\n");
d851 4
a854 4
  int LoadSize = getMemScale(*LoadI);
  int StoreSize = getMemScale(*StoreI);
  unsigned LdRt = getLdStRegOp(*LoadI).getReg();
  unsigned StRt = getLdStRegOp(*StoreI).getReg();
d884 2
a885 3
    bool IsUnscaled = TII->isUnscaledLdSt(*LoadI);
    assert(IsUnscaled == TII->isUnscaledLdSt(*StoreI) &&
           "Unsupported ld/st match");
d888 2
a889 2
                               ? getLdStOffsetOp(*LoadI).getImm()
                               : getLdStOffsetOp(*LoadI).getImm() * LoadSize;
d891 2
a892 2
                               ? getLdStOffsetOp(*StoreI).getImm()
                               : getLdStOffsetOp(*StoreI).getImm() * StoreSize;
a928 1
  (void)BitExtMI;
d947 1
a947 1
static void trackRegDefsUses(const MachineInstr &MI, BitVector &ModifiedRegs,
d950 1
a950 1
  for (const MachineOperand &MO : MI.operands()) {
a956 2
    if (!Reg)
      continue;
d971 1
a971 5
  if (IsUnscaled) {
    // If the byte-offset isn't a multiple of the stride, there's no point
    // trying to match it.
    if (Offset % OffsetStride)
      return false;
d973 1
a973 1
  }
d979 1
a979 1
// using alignTo from include/llvm/Support/MathExtras.h.
d985 1
a985 1
static bool mayAlias(MachineInstr &MIa, MachineInstr &MIb,
d988 1
a988 1
  if (!MIa.mayStore() && !MIb.mayStore())
d992 1
a992 1
  if (!MIa.mayLoadOrStore() && !MIb.mayLoadOrStore())
d998 1
a998 1
static bool mayAlias(MachineInstr &MIa,
d1001 2
a1002 2
  for (MachineInstr *MIb : MemInsns)
    if (mayAlias(MIa, *MIb, TII))
d1011 1
a1011 1
  MachineBasicBlock::iterator B = I->getParent()->begin();
d1013 2
a1014 7
  MachineInstr &LoadMI = *I;
  unsigned BaseReg = getLdStBaseOp(LoadMI).getReg();

  // If the load is the first instruction in the block, there's obviously
  // not any matching store.
  if (MBBI == B)
    return false;
d1018 3
a1020 2
  ModifiedRegs.reset();
  UsedRegs.reset();
d1022 1
a1022 2
  unsigned Count = 0;
  do {
d1024 7
a1030 5
    MachineInstr &MI = *MBBI;

    // Don't count DBG_VALUE instructions towards the search limit.
    if (!MI.isDebugValue())
      ++Count;
d1036 1
a1036 1
    if (MI.mayStore() && isMatchingStore(LoadMI, MI) &&
d1038 1
a1038 1
        isLdOffsetInRangeOfSt(LoadMI, MI, TII) &&
d1044 1
a1044 1
    if (MI.isCall())
d1056 1
a1056 1
    if (MI.mayStore() && mayAlias(LoadMI, MI, TII))
d1058 1
a1058 1
  } while (MBBI != B && Count < Limit);
d1062 2
a1063 50
// Returns true if FirstMI and MI are candidates for merging or pairing.
// Otherwise, returns false.
static bool areCandidatesToMergeOrPair(MachineInstr &FirstMI, MachineInstr &MI,
                                       LdStPairFlags &Flags,
                                       const AArch64InstrInfo *TII) {
  // If this is volatile or if pairing is suppressed, not a candidate.
  if (MI.hasOrderedMemoryRef() || TII->isLdStPairSuppressed(MI))
    return false;

  // We should have already checked FirstMI for pair suppression and volatility.
  assert(!FirstMI.hasOrderedMemoryRef() &&
         !TII->isLdStPairSuppressed(FirstMI) &&
         "FirstMI shouldn't get here if either of these checks are true.");

  unsigned OpcA = FirstMI.getOpcode();
  unsigned OpcB = MI.getOpcode();

  // Opcodes match: nothing more to check.
  if (OpcA == OpcB)
    return true;

  // Try to match a sign-extended load/store with a zero-extended load/store.
  bool IsValidLdStrOpc, PairIsValidLdStrOpc;
  unsigned NonSExtOpc = getMatchingNonSExtOpcode(OpcA, &IsValidLdStrOpc);
  assert(IsValidLdStrOpc &&
         "Given Opc should be a Load or Store with an immediate");
  // OpcA will be the first instruction in the pair.
  if (NonSExtOpc == getMatchingNonSExtOpcode(OpcB, &PairIsValidLdStrOpc)) {
    Flags.setSExtIdx(NonSExtOpc == (unsigned)OpcA ? 1 : 0);
    return true;
  }

  // If the second instruction isn't even a load/store, bail out.
  if (!PairIsValidLdStrOpc)
    return false;

  // FIXME: We don't support merging narrow loads/stores with mixed
  // scaled/unscaled offsets.
  if (isNarrowLoadOrStore(OpcA) || isNarrowLoadOrStore(OpcB))
    return false;

  // Try to match an unscaled load/store with a scaled load/store.
  return TII->isUnscaledLdSt(OpcA) != TII->isUnscaledLdSt(OpcB) &&
         getMatchingPairOpcode(OpcA) == getMatchingPairOpcode(OpcB);

  // FIXME: Can we also match a mixed sext/zext unscaled/scaled pair?
}

/// Scan the instructions looking for a load/store that can be combined with the
/// current instruction into a wider equivalent or a load/store pair.
d1066 1
a1066 2
                                      LdStPairFlags &Flags, unsigned Limit,
                                      bool FindNarrowMerge) {
d1069 1
a1069 1
  MachineInstr &FirstMI = *I;
d1072 3
a1074 2
  bool MayLoad = FirstMI.mayLoad();
  bool IsUnscaled = TII->isUnscaledLdSt(FirstMI);
d1078 14
d1093 3
a1095 1
  bool IsPromotableZeroStore = isPromotableZeroStoreInst(FirstMI);
d1099 3
a1101 2
  ModifiedRegs.reset();
  UsedRegs.reset();
d1107 1
a1107 1
    MachineInstr &MI = *MBBI;
d1110 1
a1110 1
    if (MI.isDebugValue())
d1116 1
d1118 12
a1129 3
    if (areCandidatesToMergeOrPair(FirstMI, MI, Flags, TII) &&
        getLdStOffsetOp(MI).isImm()) {
      assert(MI.mayLoadOrStore() && "Expected memory operation.");
d1136 4
a1141 20
      bool MIIsUnscaled = TII->isUnscaledLdSt(MI);
      if (IsUnscaled != MIIsUnscaled) {
        // We're trying to pair instructions that differ in how they are scaled.
        // If FirstMI is scaled then scale the offset of MI accordingly.
        // Otherwise, do the opposite (i.e., make MI's offset unscaled).
        int MemSize = getMemScale(MI);
        if (MIIsUnscaled) {
          // If the unscaled offset isn't a multiple of the MemSize, we can't
          // pair the operations together: bail and keep looking.
          if (MIOffset % MemSize) {
            trackRegDefsUses(MI, ModifiedRegs, UsedRegs, TRI);
            MemInsns.push_back(&MI);
            continue;
          }
          MIOffset /= MemSize;
        } else {
          MIOffset *= MemSize;
        }
      }

d1145 17
a1161 1
        if (FindNarrowMerge) {
d1163 3
a1165 5
          // instruction can't express the offset of the scaled narrow input,
          // bail and keep looking. For promotable zero stores, allow only when
          // the stored value is the same (i.e., WZR).
          if ((!IsUnscaled && alignTo(MinOffset, 2) != MinOffset) ||
              (IsPromotableZeroStore && Reg != getLdStRegOp(MI).getReg())) {
d1167 1
a1167 1
            MemInsns.push_back(&MI);
a1170 9
          // Pairwise instructions have a 7-bit signed offset field. Single
          // insns have a 12-bit unsigned offset field.  If the resultant
          // immediate offset of merging these instructions is out of range for
          // a pairwise instruction, bail and keep looking.
          if (!inBoundsForPair(IsUnscaled, MinOffset, OffsetStride)) {
            trackRegDefsUses(MI, ModifiedRegs, UsedRegs, TRI);
            MemInsns.push_back(&MI);
            continue;
          }
d1176 1
a1176 1
            MemInsns.push_back(&MI);
d1183 4
a1186 1
        if (MayLoad && Reg == getLdStRegOp(MI).getReg()) {
d1188 1
a1188 1
          MemInsns.push_back(&MI);
d1197 1
a1197 1
            !(MI.mayLoad() && UsedRegs[getLdStRegOp(MI).getReg()]) &&
d1220 1
a1220 1
    if (MI.isCall())
d1232 2
a1233 2
    if (MI.mayLoadOrStore())
      MemInsns.push_back(&MI);
d1261 1
a1261 1
  if (!isPairedLdSt(*I)) {
d1264 4
a1267 5
              .addOperand(getLdStRegOp(*Update))
              .addOperand(getLdStRegOp(*I))
              .addOperand(getLdStBaseOp(*I))
              .addImm(Value)
              .setMemRefs(I->memoperands_begin(), I->memoperands_end());
d1270 1
a1270 1
    int Scale = getMemScale(*I);
d1272 5
a1276 6
              .addOperand(getLdStRegOp(*Update))
              .addOperand(getLdStRegOp(*I, 0))
              .addOperand(getLdStRegOp(*I, 1))
              .addOperand(getLdStBaseOp(*I))
              .addImm(Value / Scale)
              .setMemRefs(I->memoperands_begin(), I->memoperands_end());
d1299 2
a1300 2
bool AArch64LoadStoreOpt::isMatchingUpdateInsn(MachineInstr &MemMI,
                                               MachineInstr &MI,
d1302 1
a1302 1
  switch (MI.getOpcode()) {
d1306 3
d1312 1
a1312 1
    if (!MI.getOperand(2).isImm())
d1315 1
a1315 1
    if (AArch64_AM::getShiftValue(MI.getOperand(3).getImm()))
d1320 2
a1321 2
    if (MI.getOperand(0).getReg() != BaseReg ||
        MI.getOperand(1).getReg() != BaseReg)
d1325 1
a1325 4
    int UpdateOffset = MI.getOperand(2).getImm();
    if (MI.getOpcode() == AArch64::SUBXri)
      UpdateOffset = -UpdateOffset;

d1340 1
a1340 1
      if (ScaledOffset > 63 || ScaledOffset < -64)
d1346 1
a1346 1
    if (!Offset || Offset == UpdateOffset)
d1354 1
a1354 1
    MachineBasicBlock::iterator I, int UnscaledOffset, unsigned Limit) {
d1356 1
a1356 1
  MachineInstr &MemMI = *I;
d1379 3
a1381 2
  ModifiedRegs.reset();
  UsedRegs.reset();
d1383 5
a1387 4
  for (unsigned Count = 0; MBBI != E && Count < Limit; ++MBBI) {
    MachineInstr &MI = *MBBI;
    // Skip DBG_VALUE instructions.
    if (MI.isDebugValue())
d1394 1
a1394 1
    if (isMatchingUpdateInsn(*I, MI, BaseReg, UnscaledOffset))
d1412 1
a1412 1
  MachineInstr &MemMI = *I;
d1433 10
a1442 6
  ModifiedRegs.reset();
  UsedRegs.reset();
  unsigned Count = 0;
  do {
    --MBBI;
    MachineInstr &MI = *MBBI;
d1444 2
a1445 3
    // Don't count DBG_VALUE instructions towards the search limit.
    if (!MI.isDebugValue())
      ++Count;
d1448 1
a1448 1
    if (isMatchingUpdateInsn(*I, MI, BaseReg, Offset))
d1458 1
a1458 1
  } while (MBBI != B && Count < Limit);
d1464 1
a1464 1
  MachineInstr &MI = *MBBI;
d1466 1
a1466 1
  if (MI.hasOrderedMemoryRef())
d1474 1
a1474 1
  // Look backward up to LdStLimit instructions.
d1476 1
a1476 1
  if (findMatchingStore(MBBI, LdStLimit, StoreI)) {
a1486 3
// Find narrow loads that can be converted into a single wider load with
// bitfield extract instructions.  Also merge adjacent zero stores into a wider
// store.
d1489 5
a1493 4
  assert((isNarrowLoad(*MBBI) || isPromotableZeroStoreOpcode(*MBBI)) &&
         "Expected narrow op.");
  MachineInstr &MI = *MBBI;
  MachineBasicBlock::iterator E = MI.getParent()->end();
d1495 2
a1496 1
  if (!TII->isCandidateToMergeOrPair(MI))
d1499 3
a1501 3
  // For promotable zero stores, the stored value should be WZR.
  if (isPromotableZeroStoreOpcode(MI) &&
      getLdStRegOp(MI).getReg() != AArch64::WZR)
d1504 1
a1504 1
  // Look ahead up to LdStLimit instructions for a mergable instruction.
d1506 2
a1507 3
  MachineBasicBlock::iterator MergeMI =
      findMatchingInsn(MBBI, Flags, LdStLimit, /* FindNarrowMerge = */ true);
  if (MergeMI != E) {
d1510 1
a1510 1
    } else if (isPromotableZeroStoreInst(MI)) {
d1512 4
a1516 7
    // Keeping the iterator straight is a pain, so we let the merge routine tell
    // us what the next instruction is after it's done mucking about.
    MBBI = mergeNarrowInsns(MBBI, MergeMI, Flags);
    return true;
  }
  return false;
}
d1518 3
a1520 28
// Find loads and stores that can be merged into a single load or store pair
// instruction.
bool AArch64LoadStoreOpt::tryToPairLdStInst(MachineBasicBlock::iterator &MBBI) {
  MachineInstr &MI = *MBBI;
  MachineBasicBlock::iterator E = MI.getParent()->end();

  if (!TII->isCandidateToMergeOrPair(MI))
    return false;

  // Early exit if the offset is not possible to match. (6 bits of positive
  // range, plus allow an extra one in case we find a later insn that matches
  // with Offset-1)
  bool IsUnscaled = TII->isUnscaledLdSt(MI);
  int Offset = getLdStOffsetOp(MI).getImm();
  int OffsetStride = IsUnscaled ? getMemScale(MI) : 1;
  if (!inBoundsForPair(IsUnscaled, Offset, OffsetStride))
    return false;

  // Look ahead up to LdStLimit instructions for a pairable instruction.
  LdStPairFlags Flags;
  MachineBasicBlock::iterator Paired =
      findMatchingInsn(MBBI, Flags, LdStLimit, /* FindNarrowMerge = */ false);
  if (Paired != E) {
    ++NumPairCreated;
    if (TII->isUnscaledLdSt(MI))
      ++NumUnscaledPairCreated;
    // Keeping the iterator straight is a pain, so we let the merge routine tell
    // us what the next instruction is after it's done mucking about.
d1530 1
a1530 1
  // Four tranformations to do here:
d1539 25
a1563 1
  //        lsr w2, w1, #16
d1566 2
a1567 2
    MachineInstr &MI = *MBBI;
    switch (MI.getOpcode()) {
d1589 1
d1592 1
a1592 16
  // 2) Find narrow loads that can be converted into a single wider load
  //    with bitfield extract instructions.
  //      e.g.,
  //        ldrh w0, [x2]
  //        ldrh w1, [x2, #2]
  //        ; becomes
  //        ldr w0, [x2]
  //        ubfx w1, w0, #16, #16
  //        and w0, w0, #ffff
  //
  //    Also merge adjacent zero stores into a wider store.
  //      e.g.,
  //        strh wzr, [x0]
  //        strh wzr, [x0, #2]
  //        ; becomes
  //        str wzr, [x0]
d1595 20
a1614 4
    MachineInstr &MI = *MBBI;
    unsigned Opc = MI.getOpcode();
    if (isPromotableZeroStoreOpcode(Opc) ||
        (EnableNarrowLdMerge && isNarrowLoad(Opc))) {
d1617 2
a1618 3
      } else
        ++MBBI;
    } else
d1620 4
a1625 7
  // 3) Find loads and stores that can be merged into a single load or store
  //    pair instruction.
  //      e.g.,
  //        ldr x0, [x2]
  //        ldr x1, [x2, #8]
  //        ; becomes
  //        ldp x0, x1, [x2]
d1628 2
a1629 2
    MachineInstr &MI = *MBBI;
    switch (MI.getOpcode()) {
d1658 1
a1658 1
      if (tryToPairLdStInst(MBBI)) {
d1665 1
d1668 1
a1668 7
  // 4) Find base register updates that can be merged into the load or store
  //    as a base-reg writeback.
  //      e.g.,
  //        ldr x0, [x2]
  //        add x2, x2, #4
  //        ; becomes
  //        ldr x0, [x2], #4
d1671 1
a1671 1
    MachineInstr &MI = *MBBI;
d1673 2
a1674 2
    // switchs, though not strictly necessary.
    unsigned Opc = MI.getOpcode();
d1729 1
a1729 1
          findMatchingUpdateInsnForward(MBBI, 0, UpdateLimit);
d1739 1
a1739 1
      if (TII->isUnscaledLdSt(Opc)) {
d1749 1
a1749 1
      Update = findMatchingUpdateInsnBackward(MBBI, UpdateLimit);
d1767 1
a1767 1
      Update = findMatchingUpdateInsnForward(MBBI, UnscaledOffset, UpdateLimit);
d1780 1
d1787 9
a1796 3
  if (skipFunction(*Fn.getFunction()))
    return false;

a1800 6
  // Resize the modified and used register bitfield trackers.  We do this once
  // per function and then clear the bitfield each time we optimize a load or
  // store.
  ModifiedRegs.resize(TRI->getNumRegs());
  UsedRegs.resize(TRI->getNumRegs());

d1802 1
a1802 2
  bool enableNarrowLdOpt =
    Subtarget->mergeNarrowLoads() && !Subtarget->requiresStrictAlign();
a1810 5

// FIXME: When pairing store instructions it's very possible for this pass to
// hoist a store with a KILL marker above another use (without a KILL marker).
// The resulting IR is invalid, but nothing uses the KILL markers after this
// pass, so it's never caused a problem in practice.
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d41 1
d54 8
d114 1
a114 1
  // Merge the two instructions indicated into a wider narrow store instruction.
d116 3
a118 3
  mergeNarrowZeroStores(MachineBasicBlock::iterator I,
                        MachineBasicBlock::iterator MergeMI,
                        const LdStPairFlags &Flags);
d154 2
a155 2
  // Find and merge zero store instructions.
  bool tryToMergeZeroStInst(MachineBasicBlock::iterator &MBBI);
d163 1
a163 1
  bool optimizeBlock(MachineBasicBlock &MBB, bool EnableNarrowZeroStOpt);
d169 1
a169 1
        MachineFunctionProperties::Property::NoVRegs);
d172 3
a174 1
  StringRef getPassName() const override { return AARCH64_LOAD_STORE_OPT_NAME; }
d182 17
d211 24
d326 4
d335 8
d362 12
d617 8
d626 1
a626 3
  unsigned Opc = MI.getOpcode();
  return (Opc == AArch64::STRWui || Opc == AArch64::STURWi ||
          isNarrowStore(Opc)) &&
d631 3
a633 6
AArch64LoadStoreOpt::mergeNarrowZeroStores(MachineBasicBlock::iterator I,
                                           MachineBasicBlock::iterator MergeMI,
                                           const LdStPairFlags &Flags) {
  assert(isPromotableZeroStoreInst(*I) && isPromotableZeroStoreInst(*MergeMI) &&
         "Expected promotable zero stores.");

d657 1
a657 1
  MachineInstr *RtMI;
d659 1
a659 1
      getLdStOffsetOp(*MergeMI).getImm() + OffsetStride)
d661 2
a662 1
  else
d664 2
a673 1
  // Construct the new instruction.
d676 97
d781 1
a781 1
  DEBUG(dbgs() << "Creating wider store. Replacing instructions:\n    ");
a947 1
      StoreI->clearRegisterKills(StRt, TRI);
a1011 2
  StoreI->clearRegisterKills(StRt, TRI);

d1044 2
a1045 4
      // WZR/XZR are not modified even when used as a destination register.
      if (Reg != AArch64::WZR && Reg != AArch64::XZR)
        for (MCRegAliasIterator AI(Reg, TRI, true); AI.isValid(); ++AI)
          ModifiedRegs.set(*AI);
d1121 2
a1122 3
    // Don't count transient instructions towards the search limit since there
    // may be different numbers of them if e.g. debug information is present.
    if (!MI.isTransient())
d1187 1
a1187 2
  // If the second instruction isn't even a mergable/pairable load/store, bail
  // out.
d1191 3
a1193 3
  // FIXME: We don't support merging narrow stores with mixed scaled/unscaled
  // offsets.
  if (isNarrowStore(OpcA) || isNarrowStore(OpcB))
d1232 4
d1237 2
a1238 4
    // Don't count transient instructions towards the search limit since there
    // may be different numbers of them if e.g. debug information is present.
    if (!MI.isTransient())
      ++Count;
d1508 3
d1512 2
a1513 4
    // Don't count transient instructions towards the search limit since there
    // may be different numbers of them if e.g. debug information is present.
    if (!MI.isTransient())
      ++Count;
d1562 2
a1563 3
    // Don't count transient instructions towards the search limit since there
    // may be different numbers of them if e.g. debug information is present.
    if (!MI.isTransient())
d1606 4
a1609 2
// Merge adjacent zero stores into a wider store.
bool AArch64LoadStoreOpt::tryToMergeZeroStInst(
d1611 2
a1612 1
  assert(isPromotableZeroStoreInst(*MBBI) && "Expected narrow store.");
d1619 5
d1629 5
a1633 2
    ++NumZeroStoresPromoted;

d1636 1
a1636 1
    MBBI = mergeNarrowZeroStores(MBBI, MergeMI, Flags);
a1656 3
  // Allow one more for offset.
  if (Offset > 0)
    Offset -= OffsetStride;
d1677 1
a1677 1
                                        bool EnableNarrowZeroStOpt) {
d1716 11
a1726 1
  // 2) Merge adjacent zero stores into a wider store.
a1731 5
  //      e.g.,
  //        str wzr, [x0]
  //        str wzr, [x0, #4]
  //        ; becomes
  //        str xzr, [x0]
d1733 6
a1738 3
       EnableNarrowZeroStOpt && MBBI != E;) {
    if (isPromotableZeroStoreInst(*MBBI)) {
      if (tryToMergeZeroStInst(MBBI)) {
d1755 34
a1788 3
    if (TII->isPairableLdStInst(*MBBI) && tryToPairLdStInst(MBBI))
      Modified = true;
    else
d1790 3
d1933 2
a1934 1
  bool enableNarrowZeroStOpt = !Subtarget->requiresStrictAlign();
d1936 1
a1936 1
    Modified |= optimizeBlock(MBB, enableNarrowZeroStOpt);
d1941 2
a1942 4
// FIXME: Do we need/want a pre-alloc pass like ARM has to try to keep loads and
// stores near one another?  Note: The pre-RA instruction scheduler already has
// hooks to try and schedule pairable loads/stores together to improve pairing
// opportunities.  Thus, pre-RA pairing pass may not be worth the effort.
@


1.1.1.4
log
@Import LLVM 4.0.0 release including clang and lld.
@
text
@a689 21
  MachineOperand RegOp0 = getLdStRegOp(*RtMI);
  MachineOperand RegOp1 = getLdStRegOp(*Rt2MI);
  // Kill flags may become invalid when moving stores for pairing.
  if (RegOp0.isUse()) {
    if (!MergeForward) {
      // Clear kill flags on store if moving upwards. Example:
      //   STRWui %w0, ...
      //   USE %w1
      //   STRWui kill %w1  ; need to clear kill flag when moving STRWui upwards
      RegOp0.setIsKill(false);
      RegOp1.setIsKill(false);
    } else {
      // Clear kill flags of the first stores register. Example:
      //   STRWui %w1, ...
      //   USE kill %w1   ; need to clear kill flag when moving STRWui downwards
      //   STRW %w0
      unsigned Reg = getLdStRegOp(*I).getReg();
      for (MachineInstr &MI : make_range(std::next(I), Paired))
        MI.clearRegisterKills(Reg, TRI);
    }
  }
d691 2
a692 2
            .addOperand(RegOp0)
            .addOperand(RegOp1)
d835 1
d837 1
a837 4
  // Clear kill flags between store and load.
  for (MachineInstr &MI : make_range(StoreI->getIterator(),
                                     BitExtMI->getIterator()))
    MI.clearRegisterKills(StRt, TRI);
@


1.1.1.5
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@a20 2
#include "llvm/ADT/StringRef.h"
#include "llvm/ADT/iterator_range.h"
a21 1
#include "llvm/CodeGen/MachineFunction.h"
a24 4
#include "llvm/CodeGen/MachineOperand.h"
#include "llvm/IR/DebugLoc.h"
#include "llvm/MC/MCRegisterInfo.h"
#include "llvm/Pass.h"
d29 2
a31 5
#include <cassert>
#include <cstdint>
#include <iterator>
#include <limits>

d61 1
a61 1
  bool MergeForward = false;
d67 1
a67 1
  int SExtIdx = -1;
d69 1
a69 1
  LdStPairFlags() = default;
a80 1

a84 1
  AliasAnalysis *AA;
a91 5
  virtual void getAnalysisUsage(AnalysisUsage &AU) const override {
    AU.addRequired<AAResultsWrapperPass>();
    MachineFunctionPass::getAnalysisUsage(AU);
  }

a164 1

d166 1
a166 2

} // end anonymous namespace
d249 1
a249 1
    return std::numeric_limits<unsigned>::max();
a371 4
  // FIXME: We don't currently support creating pre-indexed loads/stores when
  // the load or store is the unscaled version.  If we decide to perform such an
  // optimization in the future the cases for the unscaled loads/stores will
  // need to be added here.
a434 1
  case AArch64::STURSi:
a436 1
  case AArch64::STURDi:
a438 1
  case AArch64::STURQi:
a444 1
  case AArch64::STURWi:
a446 1
  case AArch64::STURXi:
a448 1
  case AArch64::LDURSi:
a450 1
  case AArch64::LDURDi:
a452 1
  case AArch64::LDURQi:
a458 1
  case AArch64::LDURWi:
a460 1
  case AArch64::LDURXi:
d598 1
a598 1
            .add(BaseRegOp)
d712 3
a714 3
            .add(RegOp0)
            .add(RegOp1)
            .add(BaseRegOp)
a778 1
  const MachineOperand &StMO = getLdStRegOp(*StoreI);
d791 1
a791 7
      for (MachineInstr &MI : make_range(StoreI->getIterator(),
                                         LoadI->getIterator())) {
        if (MI.killsRegister(StRt, TRI)) {
          MI.clearRegisterKills(StRt, TRI);
          break;
        }
      }
d803 1
a803 1
            .add(StMO)
d844 1
a844 1
              .add(StMO)
d851 1
a851 1
              .add(StMO)
d860 1
a860 4
    if (MI.killsRegister(StRt, TRI)) {
      MI.clearRegisterKills(StRt, TRI);
      break;
    }
d926 1
a926 1
                     AliasAnalysis *AA) {
d935 1
a935 1
  return MIa.mayAlias(AA, MIb, /*UseTBAA*/false);
d940 1
a940 1
                     AliasAnalysis *AA) {
d942 1
a942 1
    if (mayAlias(MIa, *MIb, AA))
d1000 1
a1000 1
    if (MI.mayStore() && mayAlias(LoadMI, MI, AA))
d1170 1
a1170 1
            !mayAlias(MI, MemInsns, AA)) {
d1181 1
a1181 1
            !mayAlias(FirstMI, MemInsns, AA)) {
d1236 3
a1238 3
              .add(getLdStRegOp(*Update))
              .add(getLdStRegOp(*I))
              .add(getLdStBaseOp(*I))
d1245 4
a1248 4
              .add(getLdStRegOp(*Update))
              .add(getLdStRegOp(*I, 0))
              .add(getLdStRegOp(*I, 1))
              .add(getLdStBaseOp(*I))
d1548 1
a1548 1
    case AArch64::LDURXi:
d1556 1
d1669 2
a1670 3

      // Don't know how to handle unscaled pre/post-index versions below, so
      // move to the next instruction.
a1724 1
  AA = &getAnalysis<AAResultsWrapperPass>().getAAResults();
@


