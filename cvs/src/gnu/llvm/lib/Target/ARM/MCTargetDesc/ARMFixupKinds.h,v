head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.3
	OPENBSD_6_2:1.1.1.2.0.2
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.47.01;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.01;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.07;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.10.04.20.28.02;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- ARMFixupKinds.h - ARM Specific Fixup Entries ------------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_LIB_TARGET_ARM_MCTARGETDESC_ARMFIXUPKINDS_H
#define LLVM_LIB_TARGET_ARM_MCTARGETDESC_ARMFIXUPKINDS_H

#include "llvm/MC/MCFixup.h"

namespace llvm {
namespace ARM {
enum Fixups {
  // fixup_arm_ldst_pcrel_12 - 12-bit PC relative relocation for symbol
  // addresses
  fixup_arm_ldst_pcrel_12 = FirstTargetFixupKind,

  // fixup_t2_ldst_pcrel_12 - Equivalent to fixup_arm_ldst_pcrel_12, with
  // the 16-bit halfwords reordered.
  fixup_t2_ldst_pcrel_12,

  // fixup_arm_pcrel_10_unscaled - 10-bit PC relative relocation for symbol
  // addresses used in LDRD/LDRH/LDRB/etc. instructions. All bits are encoded.
  fixup_arm_pcrel_10_unscaled,
  // fixup_arm_pcrel_10 - 10-bit PC relative relocation for symbol addresses
  // used in VFP instructions where the lower 2 bits are not encoded
  // (so it's encoded as an 8-bit immediate).
  fixup_arm_pcrel_10,
  // fixup_t2_pcrel_10 - Equivalent to fixup_arm_pcrel_10, accounting for
  // the short-swapped encoding of Thumb2 instructions.
  fixup_t2_pcrel_10,
  // fixup_thumb_adr_pcrel_10 - 10-bit PC relative relocation for symbol
  // addresses where the lower 2 bits are not encoded (so it's encoded as an
  // 8-bit immediate).
  fixup_thumb_adr_pcrel_10,
  // fixup_arm_adr_pcrel_12 - 12-bit PC relative relocation for the ADR
  // instruction.
  fixup_arm_adr_pcrel_12,
  // fixup_t2_adr_pcrel_12 - 12-bit PC relative relocation for the ADR
  // instruction.
  fixup_t2_adr_pcrel_12,
  // fixup_arm_condbranch - 24-bit PC relative relocation for conditional branch
  // instructions. 
  fixup_arm_condbranch,
  // fixup_arm_uncondbranch - 24-bit PC relative relocation for 
  // branch instructions. (unconditional)
  fixup_arm_uncondbranch,
  // fixup_t2_condbranch - 20-bit PC relative relocation for Thumb2 direct
  // uconditional branch instructions.
  fixup_t2_condbranch,
  // fixup_t2_uncondbranch - 20-bit PC relative relocation for Thumb2 direct
  // branch unconditional branch instructions.
  fixup_t2_uncondbranch,

  // fixup_arm_thumb_br - 12-bit fixup for Thumb B instructions.
  fixup_arm_thumb_br,

  // The following fixups handle the ARM BL instructions. These can be
  // conditionalised; however, the ARM ELF ABI requires a different relocation
  // in that case: R_ARM_JUMP24 instead of R_ARM_CALL. The difference is that
  // R_ARM_CALL is allowed to change the instruction to a BLX inline, which has
  // no conditional version; R_ARM_JUMP24 would have to insert a veneer.
  //
  // MachO does not draw a distinction between the two cases, so it will treat
  // fixup_arm_uncondbl and fixup_arm_condbl as identical fixups.

  // fixup_arm_uncondbl - Fixup for unconditional ARM BL instructions.
  fixup_arm_uncondbl,

  // fixup_arm_condbl - Fixup for ARM BL instructions with nontrivial
  // conditionalisation.
  fixup_arm_condbl,

  // fixup_arm_blx - Fixup for ARM BLX instructions.
  fixup_arm_blx,

  // fixup_arm_thumb_bl - Fixup for Thumb BL instructions.
  fixup_arm_thumb_bl,

  // fixup_arm_thumb_blx - Fixup for Thumb BLX instructions.
  fixup_arm_thumb_blx,

  // fixup_arm_thumb_cb - Fixup for Thumb branch instructions.
  fixup_arm_thumb_cb,

  // fixup_arm_thumb_cp - Fixup for Thumb load/store from constant pool instrs.
  fixup_arm_thumb_cp,

  // fixup_arm_thumb_bcc - Fixup for Thumb conditional branching instructions.
  fixup_arm_thumb_bcc,

  // The next two are for the movt/movw pair
  // the 16bit imm field are split into imm{15-12} and imm{11-0}
  fixup_arm_movt_hi16, // :upper16:
  fixup_arm_movw_lo16, // :lower16:
  fixup_t2_movt_hi16, // :upper16:
  fixup_t2_movw_lo16, // :lower16:

  // Marker
  LastTargetFixupKind,
  NumTargetFixupKinds = LastTargetFixupKind - FirstTargetFixupKind
};
}
}

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@a35 7
  // fixup_arm_pcrel_9 - 9-bit PC relative relocation for symbol addresses
  // used in VFP instructions where bit 0 not encoded (so it's encoded as an
  // 8-bit immediate).
  fixup_arm_pcrel_9,
  // fixup_t2_pcrel_9 - Equivalent to fixup_arm_pcrel_9, accounting for
  // the short-swapped encoding of Thumb2 instructions.
  fixup_t2_pcrel_9,
a101 3

  // fixup_arm_mod_imm - Fixup for mod_imm
  fixup_arm_mod_imm,
@


1.1.1.3
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@d18 2
a19 1
  // 12-bit PC relative relocation for symbol addresses
d22 2
a23 1
  // Equivalent to fixup_arm_ldst_pcrel_12, with the 16-bit halfwords reordered.
d26 2
a27 2
  // 10-bit PC relative relocation for symbol addresses used in
  // LDRD/LDRH/LDRB/etc. instructions. All bits are encoded.
d29 3
a31 3
  // 10-bit PC relative relocation for symbol addresses used in VFP instructions
  // where the lower 2 bits are not encoded (so it's encoded as an 8-bit
  // immediate).
d33 2
a34 2
  // Equivalent to fixup_arm_pcrel_10, accounting for the short-swapped encoding
  // of Thumb2 instructions.
d36 3
a38 2
  // 9-bit PC relative relocation for symbol addresses used in VFP instructions
  // where bit 0 not encoded (so it's encoded as an 8-bit immediate).
d40 2
a41 2
  // Equivalent to fixup_arm_pcrel_9, accounting for the short-swapped encoding
  // of Thumb2 instructions.
d43 3
a45 2
  // 10-bit PC relative relocation for symbol addresses where the lower 2 bits
  // are not encoded (so it's encoded as an 8-bit immediate).
d47 2
a48 1
  // 12-bit PC relative relocation for the ADR instruction.
d50 2
a51 1
  // 12-bit PC relative relocation for the ADR instruction.
d53 2
a54 1
  // 24-bit PC relative relocation for conditional branch instructions.
d56 2
a57 1
  // 24-bit PC relative relocation for branch instructions. (unconditional)
d59 2
a60 2
  // 20-bit PC relative relocation for Thumb2 direct uconditional branch
  // instructions.
d62 2
a63 2
  // 20-bit PC relative relocation for Thumb2 direct branch unconditional branch
  // instructions.
d66 1
a66 1
  // 12-bit fixup for Thumb B instructions.
d78 1
a78 1
  // Fixup for unconditional ARM BL instructions.
d81 2
a82 1
  // Fixup for ARM BL instructions with nontrivial conditionalisation.
d85 1
a85 1
  // Fixup for ARM BLX instructions.
d88 1
a88 1
  // Fixup for Thumb BL instructions.
d91 1
a91 1
  // Fixup for Thumb BLX instructions.
d94 1
a94 1
  // Fixup for Thumb branch instructions.
d97 1
a97 1
  // Fixup for Thumb load/store from constant pool instrs.
d100 1
a100 1
  // Fixup for Thumb conditional branching instructions.
d107 2
a108 2
  fixup_t2_movt_hi16,  // :upper16:
  fixup_t2_movw_lo16,  // :lower16:
d110 1
a110 1
  // Fixup for mod_imm
a112 3
  // Fixup for Thumb2 8-bit rotated operand
  fixup_t2_so_imm,

d118 1
a118 1
} // namespace llvm
@


