head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.3.0.2
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.03;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.29;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- WebAssemblyArgumentMove.cpp - Argument instruction moving ---------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
///
/// \file
/// \brief This file moves ARGUMENT instructions after ScheduleDAG scheduling.
///
/// Arguments are really live-in registers, however, since we use virtual
/// registers and LLVM doesn't support live-in virtual registers, we're
/// currently making do with ARGUMENT instructions which are placed at the top
/// of the entry block. The trick is to get them to *stay* at the top of the
/// entry block.
///
/// The ARGUMENTS physical register keeps these instructions pinned in place
/// during liveness-aware CodeGen passes, however one thing which does not
/// respect this is the ScheduleDAG scheduler. This pass is therefore run
/// immediately after that.
///
/// This is all hopefully a temporary solution until we find a better solution
/// for describing the live-in nature of arguments.
///
//===----------------------------------------------------------------------===//

#include "WebAssembly.h"
#include "MCTargetDesc/WebAssemblyMCTargetDesc.h"
#include "WebAssemblyMachineFunctionInfo.h"
#include "llvm/CodeGen/MachineBlockFrequencyInfo.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/Passes.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/raw_ostream.h"
using namespace llvm;

#define DEBUG_TYPE "wasm-argument-move"

namespace {
class WebAssemblyArgumentMove final : public MachineFunctionPass {
public:
  static char ID; // Pass identification, replacement for typeid
  WebAssemblyArgumentMove() : MachineFunctionPass(ID) {}

  const char *getPassName() const override {
    return "WebAssembly Argument Move";
  }

  void getAnalysisUsage(AnalysisUsage &AU) const override {
    AU.setPreservesCFG();
    AU.addPreserved<MachineBlockFrequencyInfo>();
    AU.addPreservedID(MachineDominatorsID);
    MachineFunctionPass::getAnalysisUsage(AU);
  }

  bool runOnMachineFunction(MachineFunction &MF) override;
};
} // end anonymous namespace

char WebAssemblyArgumentMove::ID = 0;
FunctionPass *llvm::createWebAssemblyArgumentMove() {
  return new WebAssemblyArgumentMove();
}

/// Test whether the given instruction is an ARGUMENT.
static bool IsArgument(const MachineInstr *MI) {
  switch (MI->getOpcode()) {
  case WebAssembly::ARGUMENT_I32:
  case WebAssembly::ARGUMENT_I64:
  case WebAssembly::ARGUMENT_F32:
  case WebAssembly::ARGUMENT_F64:
    return true;
  default:
    return false;
  }
}

bool WebAssemblyArgumentMove::runOnMachineFunction(MachineFunction &MF) {
  DEBUG({
    dbgs() << "********** Argument Move **********\n"
           << "********** Function: " << MF.getName() << '\n';
  });

  bool Changed = false;
  MachineBasicBlock &EntryMBB = MF.front();
  MachineBasicBlock::iterator InsertPt = EntryMBB.end();

  // Look for the first NonArg instruction.
  for (auto MII = EntryMBB.begin(), MIE = EntryMBB.end(); MII != MIE; ++MII) {
    MachineInstr *MI = MII;
    if (!IsArgument(MI)) {
      InsertPt = MII;
      break;
    }
  }

  // Now move any argument instructions later in the block
  // to before our first NonArg instruction.
  for (auto I = InsertPt, E = EntryMBB.end(); I != E; ++I) {
    MachineInstr *MI = I;
    if (IsArgument(MI)) {
      EntryMBB.insert(InsertPt, MI->removeFromParent());
      Changed = true;
    }
  }

  return Changed;
}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d68 2
a69 2
static bool IsArgument(const MachineInstr &MI) {
  switch (MI.getOpcode()) {
d91 2
a92 1
  for (MachineInstr &MI : EntryMBB) {
d94 1
a94 1
      InsertPt = MI;
d101 2
a102 1
  for (MachineInstr &MI : llvm::make_range(InsertPt, EntryMBB.end())) {
d104 1
a104 1
      EntryMBB.insert(InsertPt, MI.removeFromParent());
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d29 1
a30 1
#include "WebAssembly.h"
a31 2
#include "WebAssemblySubtarget.h"
#include "WebAssemblyUtilities.h"
d47 3
a49 1
  StringRef getPassName() const override { return "WebAssembly Argument Move"; }
d67 13
d92 1
a92 1
    if (!WebAssembly::isArgument(MI)) {
d101 1
a101 1
    if (WebAssembly::isArgument(MI)) {
@


