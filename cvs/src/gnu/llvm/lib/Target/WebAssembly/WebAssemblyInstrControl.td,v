head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.3.0.2
	OPENBSD_6_2_BASE:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.4
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.03;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.29;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===- WebAssemblyInstrControl.td-WebAssembly control-flow ------*- tablegen -*-
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
///
/// \file
/// \brief WebAssembly control-flow code-gen constructs.
///
//===----------------------------------------------------------------------===//

let Defs = [ARGUMENTS] in {

let isBranch = 1, isTerminator = 1, hasCtrlDep = 1 in {
// The condition operand is a boolean value which WebAssembly represents as i32.
def BR_IF : I<(outs), (ins I32:$cond, bb_op:$dst),
              [(brcond I32:$cond, bb:$dst)],
               "br_if   \t$cond, $dst">;
let isCodeGenOnly = 1 in
def BR_UNLESS : I<(outs), (ins I32:$cond, bb_op:$dst), [],
                   "br_unless\t$cond, $dst">;
let isBarrier = 1 in {
def BR   : I<(outs), (ins bb_op:$dst),
             [(br bb:$dst)],
             "br      \t$dst">;
} // isBarrier = 1
} // isBranch = 1, isTerminator = 1, hasCtrlDep = 1

} // Defs = [ARGUMENTS]

def : Pat<(brcond (i32 (setne I32:$cond, 0)), bb:$dst),
          (BR_IF I32:$cond, bb_op:$dst)>;
def : Pat<(brcond (i32 (seteq I32:$cond, 0)), bb:$dst),
          (BR_UNLESS I32:$cond, bb_op:$dst)>;

let Defs = [ARGUMENTS] in {

// TODO: SelectionDAG's lowering insists on using a pointer as the index for
// jump tables, so in practice we don't ever use TABLESWITCH_I64 in wasm32 mode
// currently.
// Set TSFlags{0} to 1 to indicate that the variable_ops are immediates.
// Set TSFlags{1} to 1 to indicate that the immediates represent labels.
let isTerminator = 1, hasCtrlDep = 1, isBarrier = 1 in {
def TABLESWITCH_I32 : I<(outs), (ins I32:$index, bb_op:$default, variable_ops),
                        [(WebAssemblytableswitch I32:$index, bb:$default)],
                        "tableswitch\t$index, $default"> {
  let TSFlags{0} = 1;
  let TSFlags{1} = 1;
}
def TABLESWITCH_I64 : I<(outs), (ins I64:$index, bb_op:$default, variable_ops),
                        [(WebAssemblytableswitch I64:$index, bb:$default)],
                        "tableswitch\t$index, $default"> {
  let TSFlags{0} = 1;
  let TSFlags{1} = 1;
}
} // isTerminator = 1, hasCtrlDep = 1, isBarrier = 1

// Placemarkers to indicate the start or end of a block or loop scope. These
// use/clobber EXPR_STACK to prevent them from being moved into the middle of
// an expression tree.
let Uses = [EXPR_STACK], Defs = [EXPR_STACK] in {
def BLOCK     : I<(outs), (ins), [], "block">;
def LOOP      : I<(outs), (ins), [], "loop">;
def END_BLOCK : I<(outs), (ins), [], "end_block">;
def END_LOOP  : I<(outs), (ins), [], "end_loop">;
} // Uses = [EXPR_STACK], Defs = [EXPR_STACK]

multiclass RETURN<WebAssemblyRegClass vt> {
  def RETURN_#vt : I<(outs), (ins vt:$val), [(WebAssemblyreturn vt:$val)],
                     "return  \t$val">;
}

let isTerminator = 1, hasCtrlDep = 1, isBarrier = 1 in {
let isReturn = 1 in {
  defm : RETURN<I32>;
  defm : RETURN<I64>;
  defm : RETURN<F32>;
  defm : RETURN<F64>;
  def RETURN_VOID : I<(outs), (ins), [(WebAssemblyreturn)], "return">;
} // isReturn = 1
  def UNREACHABLE : I<(outs), (ins), [(trap)], "unreachable">;
} // isTerminator = 1, hasCtrlDep = 1, isBarrier = 1

} // Defs = [ARGUMENTS]
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d19 1
a19 1
def BR_IF : I<(outs), (ins bb_op:$dst, I32:$cond),
d21 1
a21 1
               "br_if   \t$dst, $cond">;
d23 2
a24 2
def BR_UNLESS : I<(outs), (ins bb_op:$dst, I32:$cond), [],
                   "br_unless\t$dst, $cond">;
d35 1
a35 1
          (BR_IF bb_op:$dst, I32:$cond)>;
d37 1
a37 1
          (BR_UNLESS bb_op:$dst, I32:$cond)>;
d42 1
a42 1
// jump tables, so in practice we don't ever use BR_TABLE_I64 in wasm32 mode
d47 3
a49 3
def BR_TABLE_I32 : I<(outs), (ins I32:$index, variable_ops),
                     [(WebAssemblybr_table I32:$index)],
                     "br_table \t$index"> {
d53 3
a55 3
def BR_TABLE_I64 : I<(outs), (ins I64:$index, variable_ops),
                     [(WebAssemblybr_table I64:$index)],
                     "br_table \t$index"> {
a73 4
  // Equivalent to RETURN_#vt, for use at the end of a function when wasm
  // semantics return by falling off the end of the block.
  let isCodeGenOnly = 1 in
  def FALLTHROUGH_RETURN_#vt : I<(outs), (ins vt:$val), []>;
a82 4

  // This is to RETURN_VOID what FALLTHROUGH_RETURN_#vt is to RETURN_#vt.
  let isCodeGenOnly = 1 in
  def FALLTHROUGH_RETURN_VOID : I<(outs), (ins), []>;
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d21 1
a21 1
               "br_if   \t$dst, $cond", 0x0d>;
d23 2
a24 1
def BR_UNLESS : I<(outs), (ins bb_op:$dst, I32:$cond), []>;
d28 1
a28 1
             "br      \t$dst", 0x0c>;
d49 1
a49 1
                     "br_table \t$index", 0x0e> {
d62 1
a62 1
// use/clobber VALUE_STACK to prevent them from being moved into the middle of
d64 6
a69 8
let Uses = [VALUE_STACK], Defs = [VALUE_STACK] in {
def BLOCK     : I<(outs), (ins Signature:$sig), [], "block   \t$sig", 0x02>;
def LOOP      : I<(outs), (ins Signature:$sig), [], "loop    \t$sig", 0x03>;

// END_BLOCK and END_LOOP are represented with the same opcode in wasm.
def END_BLOCK : I<(outs), (ins), [], "end_block", 0x0b>;
def END_LOOP  : I<(outs), (ins), [], "end_loop", 0x0b>;
} // Uses = [VALUE_STACK], Defs = [VALUE_STACK]
d73 1
a73 1
                     "return  \t$val", 0x0f>;
a79 10
multiclass SIMD_RETURN<ValueType vt> {
  def RETURN_#vt : SIMD_I<(outs), (ins V128:$val),
                          [(WebAssemblyreturn (vt V128:$val))],
                          "return  \t$val", 0x0f>;
  // Equivalent to RETURN_#vt, for use at the end of a function when wasm
  // semantics return by falling off the end of the block.
  let isCodeGenOnly = 1 in
  def FALLTHROUGH_RETURN_#vt : SIMD_I<(outs), (ins V128:$val), []>;
}

a80 1

d86 1
a86 6
  defm : SIMD_RETURN<v16i8>;
  defm : SIMD_RETURN<v8i16>;
  defm : SIMD_RETURN<v4i32>;
  defm : SIMD_RETURN<v4f32>;

  def RETURN_VOID : I<(outs), (ins), [(WebAssemblyreturn)], "return", 0x0f>;
d92 1
a92 3

def UNREACHABLE : I<(outs), (ins), [(trap)], "unreachable", 0x00>;

@


