head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.2.0.2
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.24.08.33.29;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- WebAssemblyInstrConv.td-WebAssembly Conversion support -*- tablegen -*-=
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
///
/// \file
/// \brief WebAssembly datatype conversions, truncations, reinterpretations,
/// promotions, and demotions operand code-gen constructs.
///
//===----------------------------------------------------------------------===//

let Defs = [ARGUMENTS] in {

def I32_WRAP_I64 : I<(outs I32:$dst), (ins I64:$src),
                      [(set I32:$dst, (trunc I64:$src))],
                      "i32.wrap/i64\t$dst, $src">;

def I64_EXTEND_S_I32 : I<(outs I64:$dst), (ins I32:$src),
                          [(set I64:$dst, (sext I32:$src))],
                          "i64.extend_s/i32\t$dst, $src">;
def I64_EXTEND_U_I32 : I<(outs I64:$dst), (ins I32:$src),
                         [(set I64:$dst, (zext I32:$src))],
                         "i64.extend_u/i32\t$dst, $src">;

} // defs = [ARGUMENTS]

// Expand a "don't care" extend into zero-extend (chosen over sign-extend
// somewhat arbitrarily, although it favors popular hardware architectures
// and is conceptually a simpler operation).
def : Pat<(i64 (anyext I32:$src)), (I64_EXTEND_U_I32 I32:$src)>;

let Defs = [ARGUMENTS] in {

// Conversion from floating point to integer traps on overflow and invalid.
let hasSideEffects = 1 in {
def I32_TRUNC_S_F32 : I<(outs I32:$dst), (ins F32:$src),
                        [(set I32:$dst, (fp_to_sint F32:$src))],
                        "i32.trunc_s/f32\t$dst, $src">;
def I32_TRUNC_U_F32 : I<(outs I32:$dst), (ins F32:$src),
                        [(set I32:$dst, (fp_to_uint F32:$src))],
                        "i32.trunc_u/f32\t$dst, $src">;
def I64_TRUNC_S_F32 : I<(outs I64:$dst), (ins F32:$src),
                        [(set I64:$dst, (fp_to_sint F32:$src))],
                        "i64.trunc_s/f32\t$dst, $src">;
def I64_TRUNC_U_F32 : I<(outs I64:$dst), (ins F32:$src),
                        [(set I64:$dst, (fp_to_uint F32:$src))],
                        "i64.trunc_u/f32\t$dst, $src">;
def I32_TRUNC_S_F64 : I<(outs I32:$dst), (ins F64:$src),
                        [(set I32:$dst, (fp_to_sint F64:$src))],
                        "i32.trunc_s/f64\t$dst, $src">;
def I32_TRUNC_U_F64 : I<(outs I32:$dst), (ins F64:$src),
                        [(set I32:$dst, (fp_to_uint F64:$src))],
                        "i32.trunc_u/f64\t$dst, $src">;
def I64_TRUNC_S_F64 : I<(outs I64:$dst), (ins F64:$src),
                        [(set I64:$dst, (fp_to_sint F64:$src))],
                        "i64.trunc_s/f64\t$dst, $src">;
def I64_TRUNC_U_F64 : I<(outs I64:$dst), (ins F64:$src),
                        [(set I64:$dst, (fp_to_uint F64:$src))],
                        "i64.trunc_u/f64\t$dst, $src">;
} // hasSideEffects = 1

def F32_CONVERT_S_I32 : I<(outs F32:$dst), (ins I32:$src),
                          [(set F32:$dst, (sint_to_fp I32:$src))],
                          "f32.convert_s/i32\t$dst, $src">;
def F32_CONVERT_U_I32 : I<(outs F32:$dst), (ins I32:$src),
                          [(set F32:$dst, (uint_to_fp I32:$src))],
                          "f32.convert_u/i32\t$dst, $src">;
def F64_CONVERT_S_I32 : I<(outs F64:$dst), (ins I32:$src),
                          [(set F64:$dst, (sint_to_fp I32:$src))],
                          "f64.convert_s/i32\t$dst, $src">;
def F64_CONVERT_U_I32 : I<(outs F64:$dst), (ins I32:$src),
                          [(set F64:$dst, (uint_to_fp I32:$src))],
                          "f64.convert_u/i32\t$dst, $src">;
def F32_CONVERT_S_I64 : I<(outs F32:$dst), (ins I64:$src),
                          [(set F32:$dst, (sint_to_fp I64:$src))],
                          "f32.convert_s/i64\t$dst, $src">;
def F32_CONVERT_U_I64 : I<(outs F32:$dst), (ins I64:$src),
                          [(set F32:$dst, (uint_to_fp I64:$src))],
                          "f32.convert_u/i64\t$dst, $src">;
def F64_CONVERT_S_I64 : I<(outs F64:$dst), (ins I64:$src),
                          [(set F64:$dst, (sint_to_fp I64:$src))],
                          "f64.convert_s/i64\t$dst, $src">;
def F64_CONVERT_U_I64 : I<(outs F64:$dst), (ins I64:$src),
                          [(set F64:$dst, (uint_to_fp I64:$src))],
                          "f64.convert_u/i64\t$dst, $src">;

def F64_PROMOTE_F32 : I<(outs F64:$dst), (ins F32:$src),
                        [(set F64:$dst, (fextend F32:$src))],
                        "f64.promote/f32\t$dst, $src">;
def F32_DEMOTE_F64 : I<(outs F32:$dst), (ins F64:$src),
                       [(set F32:$dst, (fround F64:$src))],
                       "f32.demote/f64\t$dst, $src">;

def I32_REINTERPRET_F32 : I<(outs I32:$dst), (ins F32:$src),
                            [(set I32:$dst, (bitconvert F32:$src))],
                            "i32.reinterpret/f32\t$dst, $src">;
def F32_REINTERPRET_I32 : I<(outs F32:$dst), (ins I32:$src),
                            [(set F32:$dst, (bitconvert I32:$src))],
                            "f32.reinterpret/i32\t$dst, $src">;
def I64_REINTERPRET_F64 : I<(outs I64:$dst), (ins F64:$src),
                            [(set I64:$dst, (bitconvert F64:$src))],
                            "i64.reinterpret/f64\t$dst, $src">;
def F64_REINTERPRET_I64 : I<(outs F64:$dst), (ins I64:$src),
                            [(set F64:$dst, (bitconvert I64:$src))],
                            "f64.reinterpret/i64\t$dst, $src">;

} // Defs = [ARGUMENTS]
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d20 1
a20 1
                      "i32.wrap/i64\t$dst, $src", 0xa7>;
d24 1
a24 1
                          "i64.extend_s/i32\t$dst, $src", 0xac>;
d27 1
a27 1
                         "i64.extend_u/i32\t$dst, $src", 0xad>;
d42 1
a42 1
                        "i32.trunc_s/f32\t$dst, $src", 0xa8>;
d45 1
a45 1
                        "i32.trunc_u/f32\t$dst, $src", 0xa9>;
d48 1
a48 1
                        "i64.trunc_s/f32\t$dst, $src", 0xae>;
d51 1
a51 1
                        "i64.trunc_u/f32\t$dst, $src", 0xaf>;
d54 1
a54 1
                        "i32.trunc_s/f64\t$dst, $src", 0xaa>;
d57 1
a57 1
                        "i32.trunc_u/f64\t$dst, $src", 0xab>;
d60 1
a60 1
                        "i64.trunc_s/f64\t$dst, $src", 0xb0>;
d63 1
a63 1
                        "i64.trunc_u/f64\t$dst, $src", 0xb1>;
d68 1
a68 1
                          "f32.convert_s/i32\t$dst, $src", 0xb2>;
d71 1
a71 1
                          "f32.convert_u/i32\t$dst, $src", 0xb3>;
d74 1
a74 1
                          "f64.convert_s/i32\t$dst, $src", 0xb7>;
d77 1
a77 1
                          "f64.convert_u/i32\t$dst, $src", 0xb8>;
d80 1
a80 1
                          "f32.convert_s/i64\t$dst, $src", 0xb4>;
d83 1
a83 1
                          "f32.convert_u/i64\t$dst, $src", 0xb5>;
d86 1
a86 1
                          "f64.convert_s/i64\t$dst, $src", 0xb9>;
d89 1
a89 1
                          "f64.convert_u/i64\t$dst, $src", 0xba>;
d92 2
a93 2
                        [(set F64:$dst, (fpextend F32:$src))],
                        "f64.promote/f32\t$dst, $src", 0xbb>;
d95 2
a96 2
                       [(set F32:$dst, (fpround F64:$src))],
                       "f32.demote/f64\t$dst, $src", 0xb6>;
d100 1
a100 1
                            "i32.reinterpret/f32\t$dst, $src", 0xbc>;
d103 1
a103 1
                            "f32.reinterpret/i32\t$dst, $src", 0xbe>;
d106 1
a106 1
                            "i64.reinterpret/f64\t$dst, $src", 0xbd>;
d109 1
a109 1
                            "f64.reinterpret/i64\t$dst, $src", 0xbf>;
@

