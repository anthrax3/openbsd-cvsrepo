head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.3
	OPENBSD_6_2:1.1.1.2.0.2
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.47.01;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.01;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.24.08.33.31;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	so2WA7LCP6wbxtYl;

1.1.1.3
date	2017.10.04.20.28.06;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- XCoreMachineFunctionInfo.cpp - XCore machine function info --------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "XCoreMachineFunctionInfo.h"
#include "XCoreInstrInfo.h"
#include "llvm/IR/Function.h"

using namespace llvm;

void XCoreFunctionInfo::anchor() { }

bool XCoreFunctionInfo::isLargeFrame(const MachineFunction &MF) const {
  if (CachedEStackSize == -1) {
    CachedEStackSize = MF.getFrameInfo()->estimateStackSize(MF);
  }
  // isLargeFrame() is used when deciding if spill slots should be added to
  // allow eliminateFrameIndex() to scavenge registers.
  // This is only required when there is no FP and offsets are greater than
  // ~256KB (~64Kwords). Thus only for code run on the emulator!
  //
  // The arbitrary value of 0xf000 allows frames of up to ~240KB before spill
  // slots are added for the use of eliminateFrameIndex() register scavenging.
  // For frames less than 240KB, it is assumed that there will be less than
  // 16KB of function arguments.
  return CachedEStackSize > 0xf000;
}

int XCoreFunctionInfo::createLRSpillSlot(MachineFunction &MF) {
  if (LRSpillSlotSet) {
    return LRSpillSlot;
  }
  const TargetRegisterClass *RC = &XCore::GRRegsRegClass;
  MachineFrameInfo *MFI = MF.getFrameInfo();
  if (! MF.getFunction()->isVarArg()) {
    // A fixed offset of 0 allows us to save / restore LR using entsp / retsp.
    LRSpillSlot = MFI->CreateFixedObject(RC->getSize(), 0, true);
  } else {
    LRSpillSlot = MFI->CreateStackObject(RC->getSize(), RC->getAlignment(), true);
  }
  LRSpillSlotSet = true;
  return LRSpillSlot;
}

int XCoreFunctionInfo::createFPSpillSlot(MachineFunction &MF) {
  if (FPSpillSlotSet) {
    return FPSpillSlot;
  }
  const TargetRegisterClass *RC = &XCore::GRRegsRegClass;
  MachineFrameInfo *MFI = MF.getFrameInfo();
  FPSpillSlot = MFI->CreateStackObject(RC->getSize(), RC->getAlignment(), true);
  FPSpillSlotSet = true;
  return FPSpillSlot;
}

const int* XCoreFunctionInfo::createEHSpillSlot(MachineFunction &MF) {
  if (EHSpillSlotSet) {
    return EHSpillSlot;
  }
  const TargetRegisterClass *RC = &XCore::GRRegsRegClass;
  MachineFrameInfo *MFI = MF.getFrameInfo();
  EHSpillSlot[0] = MFI->CreateStackObject(RC->getSize(), RC->getAlignment(), true);
  EHSpillSlot[1] = MFI->CreateStackObject(RC->getSize(), RC->getAlignment(), true);
  EHSpillSlotSet = true;
  return EHSpillSlot;
}

@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d20 1
a20 1
    CachedEStackSize = MF.getFrameInfo().estimateStackSize(MF);
d39 1
a39 1
  MachineFrameInfo &MFI = MF.getFrameInfo();
d42 1
a42 1
    LRSpillSlot = MFI.CreateFixedObject(RC->getSize(), 0, true);
d44 1
a44 1
    LRSpillSlot = MFI.CreateStackObject(RC->getSize(), RC->getAlignment(), true);
d55 2
a56 2
  MachineFrameInfo &MFI = MF.getFrameInfo();
  FPSpillSlot = MFI.CreateStackObject(RC->getSize(), RC->getAlignment(), true);
d66 3
a68 3
  MachineFrameInfo &MFI = MF.getFrameInfo();
  EHSpillSlot[0] = MFI.CreateStackObject(RC->getSize(), RC->getAlignment(), true);
  EHSpillSlot[1] = MFI.CreateStackObject(RC->getSize(), RC->getAlignment(), true);
@


1.1.1.3
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@a12 1
#include "llvm/Target/TargetSubtargetInfo.h"
d38 1
a38 2
  const TargetRegisterClass &RC = XCore::GRRegsRegClass;
  const TargetRegisterInfo &TRI = *MF.getSubtarget().getRegisterInfo();
d42 1
a42 1
    LRSpillSlot = MFI.CreateFixedObject(TRI.getSpillSize(RC), 0, true);
d44 1
a44 2
    LRSpillSlot = MFI.CreateStackObject(TRI.getSpillSize(RC),
                                        TRI.getSpillAlignment(RC), true);
d54 1
a54 2
  const TargetRegisterClass &RC = XCore::GRRegsRegClass;
  const TargetRegisterInfo &TRI = *MF.getSubtarget().getRegisterInfo();
d56 1
a56 2
  FPSpillSlot = MFI.CreateStackObject(TRI.getSpillSize(RC),
                                      TRI.getSpillAlignment(RC), true);
d65 1
a65 2
  const TargetRegisterClass &RC = XCore::GRRegsRegClass;
  const TargetRegisterInfo &TRI = *MF.getSubtarget().getRegisterInfo();
d67 2
a68 4
  unsigned Size = TRI.getSpillSize(RC);
  unsigned Align = TRI.getSpillAlignment(RC);
  EHSpillSlot[0] = MFI.CreateStackObject(Size, Align, true);
  EHSpillSlot[1] = MFI.CreateStackObject(Size, Align, true);
@


