head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.3.0.6
	OPENBSD_6_2_BASE:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.4
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.04;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.33;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- SIInstrInfo.td - SI Instruction Infos -------------*- tablegen -*--===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
def isCI : Predicate<"Subtarget->getGeneration() "
                      ">= AMDGPUSubtarget::SEA_ISLANDS">;
def isCIOnly : Predicate<"Subtarget->getGeneration() =="
                         "AMDGPUSubtarget::SEA_ISLANDS">,
  AssemblerPredicate <"FeatureSeaIslands">;

def DisableInst : Predicate <"false">, AssemblerPredicate<"FeatureDisable">;

class vop {
  field bits<9> SI3;
  field bits<10> VI3;
}

class vopc <bits<8> si, bits<8> vi = !add(0x40, si)> : vop {
  field bits<8> SI = si;
  field bits<8> VI = vi;

  field bits<9>  SI3 = {0, si{7-0}};
  field bits<10> VI3 = {0, 0, vi{7-0}};
}

class vop1 <bits<8> si, bits<8> vi = si> : vop {
  field bits<8> SI = si;
  field bits<8> VI = vi;

  field bits<9>  SI3 = {1, 1, si{6-0}};
  field bits<10> VI3 = !add(0x140, vi);
}

class vop2 <bits<6> si, bits<6> vi = si> : vop {
  field bits<6> SI = si;
  field bits<6> VI = vi;

  field bits<9>  SI3 = {1, 0, 0, si{5-0}};
  field bits<10> VI3 = {0, 1, 0, 0, vi{5-0}};
}

// Specify a VOP2 opcode for SI and VOP3 opcode for VI
// that doesn't have VOP2 encoding on VI
class vop23 <bits<6> si, bits<10> vi> : vop2 <si> {
  let VI3 = vi;
}

class vop3 <bits<9> si, bits<10> vi = {0, si}> : vop {
  let SI3 = si;
  let VI3 = vi;
}

class sop1 <bits<8> si, bits<8> vi = si> {
  field bits<8> SI = si;
  field bits<8> VI = vi;
}

class sop2 <bits<7> si, bits<7> vi = si> {
  field bits<7> SI = si;
  field bits<7> VI = vi;
}

class sopk <bits<5> si, bits<5> vi = si> {
  field bits<5> SI = si;
  field bits<5> VI = vi;
}

// Specify an SMRD opcode for SI and SMEM opcode for VI

// FIXME: This should really be bits<5> si, Tablegen crashes if
// parameter default value is other parameter with different bit size
class smrd<bits<8> si, bits<8> vi = si> {
  field bits<5> SI = si{4-0};
  field bits<8> VI = vi;
}

// Execpt for the NONE field, this must be kept in sync with the SISubtarget enum
// in AMDGPUInstrInfo.cpp
def SISubtarget {
  int NONE = -1;
  int SI = 0;
  int VI = 1;
}

//===----------------------------------------------------------------------===//
// SI DAG Nodes
//===----------------------------------------------------------------------===//

def SIload_constant : SDNode<"AMDGPUISD::LOAD_CONSTANT",
  SDTypeProfile<1, 2, [SDTCisVT<0, f32>, SDTCisVT<1, v4i32>, SDTCisVT<2, i32>]>,
                      [SDNPMayLoad, SDNPMemOperand]
>;

def SItbuffer_store : SDNode<"AMDGPUISD::TBUFFER_STORE_FORMAT",
  SDTypeProfile<0, 13,
    [SDTCisVT<0, v4i32>,   // rsrc(SGPR)
     SDTCisVT<1, iAny>,   // vdata(VGPR)
     SDTCisVT<2, i32>,    // num_channels(imm)
     SDTCisVT<3, i32>,    // vaddr(VGPR)
     SDTCisVT<4, i32>,    // soffset(SGPR)
     SDTCisVT<5, i32>,    // inst_offset(imm)
     SDTCisVT<6, i32>,    // dfmt(imm)
     SDTCisVT<7, i32>,    // nfmt(imm)
     SDTCisVT<8, i32>,    // offen(imm)
     SDTCisVT<9, i32>,    // idxen(imm)
     SDTCisVT<10, i32>,   // glc(imm)
     SDTCisVT<11, i32>,   // slc(imm)
     SDTCisVT<12, i32>    // tfe(imm)
    ]>,
  [SDNPMayStore, SDNPMemOperand, SDNPHasChain]
>;

def SIload_input : SDNode<"AMDGPUISD::LOAD_INPUT",
  SDTypeProfile<1, 3, [SDTCisVT<0, v4f32>, SDTCisVT<1, v4i32>, SDTCisVT<2, i16>,
                       SDTCisVT<3, i32>]>
>;

class SDSample<string opcode> : SDNode <opcode,
  SDTypeProfile<1, 4, [SDTCisVT<0, v4f32>, SDTCisVT<2, v32i8>,
                       SDTCisVT<3, v4i32>, SDTCisVT<4, i32>]>
>;

def SIsample : SDSample<"AMDGPUISD::SAMPLE">;
def SIsampleb : SDSample<"AMDGPUISD::SAMPLEB">;
def SIsampled : SDSample<"AMDGPUISD::SAMPLED">;
def SIsamplel : SDSample<"AMDGPUISD::SAMPLEL">;

def SIconstdata_ptr : SDNode<
  "AMDGPUISD::CONST_DATA_PTR", SDTypeProfile <1, 1, [SDTCisVT<0, i64>,
                                                     SDTCisVT<0, i64>]>
>;

//===----------------------------------------------------------------------===//
// PatFrags for FLAT instructions
//===----------------------------------------------------------------------===//

class flat_ld <SDPatternOperator ld> : PatFrag<(ops node:$ptr),
                                               (ld node:$ptr), [{
  return isFlatLoad(dyn_cast<LoadSDNode>(N)) ||
         isGlobalLoad(dyn_cast<LoadSDNode>(N)) ||
         isConstantLoad(cast<LoadSDNode>(N), -1);
}]>;

def flat_load : flat_ld <load>;
def flat_az_extloadi8 : flat_ld <az_extloadi8>;
def flat_sextloadi8 : flat_ld <sextloadi8>;
def flat_az_extloadi16 : flat_ld <az_extloadi16>;
def flat_sextloadi16 : flat_ld <sextloadi16>;

class flat_st <SDPatternOperator st> : PatFrag<(ops node:$val, node:$ptr),
                                               (st node:$val, node:$ptr), [{
  return isFlatStore(dyn_cast<StoreSDNode>(N)) ||
         isGlobalStore(dyn_cast<StoreSDNode>(N));
}]>;

def flat_store: flat_st <store>;
def flat_truncstorei8 : flat_st <truncstorei8>;
def flat_truncstorei16 : flat_st <truncstorei16>;


def mubuf_load : PatFrag <(ops node:$ptr), (load node:$ptr), [{
	return isGlobalLoad(cast<LoadSDNode>(N)) ||
         isConstantLoad(cast<LoadSDNode>(N), -1);
}]>;

def smrd_load : PatFrag <(ops node:$ptr), (load node:$ptr), [{
  return isConstantLoad(cast<LoadSDNode>(N), -1) &&
  static_cast<const SITargetLowering *>(getTargetLowering())->isMemOpUniform(N);
}]>;

//===----------------------------------------------------------------------===//
// SDNodes and PatFrag for local loads and stores to enable s_mov_b32 m0, -1
// to be glued to the memory instructions.
//===----------------------------------------------------------------------===//

def SIld_local : SDNode <"ISD::LOAD", SDTLoad,
  [SDNPHasChain, SDNPMayLoad, SDNPMemOperand, SDNPInGlue]
>;

def si_ld_local : PatFrag <(ops node:$ptr), (SIld_local node:$ptr), [{
  return isLocalLoad(cast<LoadSDNode>(N));
}]>;

def si_load_local : PatFrag <(ops node:$ptr), (si_ld_local node:$ptr), [{
  return cast<LoadSDNode>(N)->getAddressingMode() == ISD::UNINDEXED &&
         cast<LoadSDNode>(N)->getExtensionType() == ISD::NON_EXTLOAD;
}]>;

def si_load_local_align8 : Aligned8Bytes <
  (ops node:$ptr), (si_load_local node:$ptr)
>;

def si_sextload_local : PatFrag <(ops node:$ptr), (si_ld_local node:$ptr), [{
  return cast<LoadSDNode>(N)->getExtensionType() == ISD::SEXTLOAD;
}]>;
def si_az_extload_local : AZExtLoadBase <si_ld_local>;

multiclass SIExtLoadLocal <PatFrag ld_node> {

  def _i8 : PatFrag <(ops node:$ptr), (ld_node node:$ptr),
                     [{return cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;}]
  >;

  def _i16 : PatFrag <(ops node:$ptr), (ld_node node:$ptr),
                     [{return cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;}]
  >;
}

defm si_sextload_local : SIExtLoadLocal <si_sextload_local>;
defm si_az_extload_local : SIExtLoadLocal <si_az_extload_local>;

def SIst_local : SDNode <"ISD::STORE", SDTStore,
  [SDNPHasChain, SDNPMayStore, SDNPMemOperand, SDNPInGlue]
>;

def si_st_local : PatFrag <
  (ops node:$val, node:$ptr), (SIst_local node:$val, node:$ptr), [{
  return isLocalStore(cast<StoreSDNode>(N));
}]>;

def si_store_local : PatFrag <
  (ops node:$val, node:$ptr), (si_st_local node:$val, node:$ptr), [{
  return cast<StoreSDNode>(N)->getAddressingMode() == ISD::UNINDEXED &&
         !cast<StoreSDNode>(N)->isTruncatingStore();
}]>;

def si_store_local_align8 : Aligned8Bytes <
  (ops node:$val, node:$ptr), (si_store_local node:$val, node:$ptr)
>;

def si_truncstore_local : PatFrag <
  (ops node:$val, node:$ptr), (si_st_local node:$val, node:$ptr), [{
  return cast<StoreSDNode>(N)->isTruncatingStore();
}]>;

def si_truncstore_local_i8 : PatFrag <
  (ops node:$val, node:$ptr), (si_truncstore_local node:$val, node:$ptr), [{
  return cast<StoreSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;

def si_truncstore_local_i16 : PatFrag <
  (ops node:$val, node:$ptr), (si_truncstore_local node:$val, node:$ptr), [{
  return cast<StoreSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;

multiclass SIAtomicM0Glue2 <string op_name> {

  def _glue : SDNode <"ISD::ATOMIC_"#op_name, SDTAtomic2,
    [SDNPHasChain, SDNPMayStore, SDNPMayLoad, SDNPMemOperand, SDNPInGlue]
  >;

  def _local : local_binary_atomic_op <!cast<SDNode>(NAME#"_glue")>;
}

defm si_atomic_load_add : SIAtomicM0Glue2 <"LOAD_ADD">;
defm si_atomic_load_and : SIAtomicM0Glue2 <"LOAD_AND">;
defm si_atomic_load_min : SIAtomicM0Glue2 <"LOAD_MIN">;
defm si_atomic_load_max : SIAtomicM0Glue2 <"LOAD_MAX">;
defm si_atomic_load_or : SIAtomicM0Glue2 <"LOAD_OR">;
defm si_atomic_load_sub : SIAtomicM0Glue2 <"LOAD_SUB">;
defm si_atomic_load_xor : SIAtomicM0Glue2 <"LOAD_XOR">;
defm si_atomic_load_umin : SIAtomicM0Glue2 <"LOAD_UMIN">;
defm si_atomic_load_umax : SIAtomicM0Glue2 <"LOAD_UMAX">;
defm si_atomic_swap : SIAtomicM0Glue2 <"SWAP">;

def si_atomic_cmp_swap_glue : SDNode <"ISD::ATOMIC_CMP_SWAP", SDTAtomic3,
  [SDNPHasChain, SDNPMayStore, SDNPMayLoad, SDNPMemOperand, SDNPInGlue]
>;

defm si_atomic_cmp_swap : AtomicCmpSwapLocal <si_atomic_cmp_swap_glue>;

// Transformation function, extract the lower 32bit of a 64bit immediate
def LO32 : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(N->getZExtValue() & 0xffffffff, SDLoc(N),
                                   MVT::i32);
}]>;

def LO32f : SDNodeXForm<fpimm, [{
  APInt V = N->getValueAPF().bitcastToAPInt().trunc(32);
  return CurDAG->getTargetConstantFP(APFloat(APFloat::IEEEsingle, V), MVT::f32);
}]>;

// Transformation function, extract the upper 32bit of a 64bit immediate
def HI32 : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(N->getZExtValue() >> 32, SDLoc(N), MVT::i32);
}]>;

def HI32f : SDNodeXForm<fpimm, [{
  APInt V = N->getValueAPF().bitcastToAPInt().lshr(32).trunc(32);
  return CurDAG->getTargetConstantFP(APFloat(APFloat::IEEEsingle, V), SDLoc(N),
                                     MVT::f32);
}]>;

def IMM8bitDWORD : PatLeaf <(imm),
  [{return (N->getZExtValue() & ~0x3FC) == 0;}]
>;

def as_dword_i32imm : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(N->getZExtValue() >> 2, SDLoc(N), MVT::i32);
}]>;

def as_i1imm : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(N->getZExtValue(), SDLoc(N), MVT::i1);
}]>;

def as_i8imm : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(N->getZExtValue(), SDLoc(N), MVT::i8);
}]>;

def as_i16imm : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(N->getSExtValue(), SDLoc(N), MVT::i16);
}]>;

def as_i32imm: SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(N->getSExtValue(), SDLoc(N), MVT::i32);
}]>;

def as_i64imm: SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(N->getSExtValue(), SDLoc(N), MVT::i64);
}]>;

// Copied from the AArch64 backend:
def bitcast_fpimm_to_i32 : SDNodeXForm<fpimm, [{
return CurDAG->getTargetConstant(
  N->getValueAPF().bitcastToAPInt().getZExtValue(), SDLoc(N), MVT::i32);
}]>;

// Copied from the AArch64 backend:
def bitcast_fpimm_to_i64 : SDNodeXForm<fpimm, [{
return CurDAG->getTargetConstant(
  N->getValueAPF().bitcastToAPInt().getZExtValue(), SDLoc(N), MVT::i64);
}]>;

def IMM8bit : PatLeaf <(imm),
  [{return isUInt<8>(N->getZExtValue());}]
>;

def IMM12bit : PatLeaf <(imm),
  [{return isUInt<12>(N->getZExtValue());}]
>;

def IMM16bit : PatLeaf <(imm),
  [{return isUInt<16>(N->getZExtValue());}]
>;

def IMM20bit : PatLeaf <(imm),
  [{return isUInt<20>(N->getZExtValue());}]
>;

def IMM32bit : PatLeaf <(imm),
  [{return isUInt<32>(N->getZExtValue());}]
>;

def mubuf_vaddr_offset : PatFrag<
  (ops node:$ptr, node:$offset, node:$imm_offset),
  (add (add node:$ptr, node:$offset), node:$imm_offset)
>;

class InlineImm <ValueType vt> : PatLeaf <(vt imm), [{
  return isInlineImmediate(N);
}]>;

class InlineFPImm <ValueType vt> : PatLeaf <(vt fpimm), [{
  return isInlineImmediate(N);
}]>;

class SGPRImm <dag frag> : PatLeaf<frag, [{
  if (Subtarget->getGeneration() < AMDGPUSubtarget::SOUTHERN_ISLANDS) {
    return false;
  }
  const SIRegisterInfo *SIRI =
      static_cast<const SIRegisterInfo *>(Subtarget->getRegisterInfo());
  for (SDNode::use_iterator U = N->use_begin(), E = SDNode::use_end();
                                                U != E; ++U) {
    const TargetRegisterClass *RC = getOperandRegClass(*U, U.getOperandNo());
    if (RC && SIRI->isSGPRClass(RC))
      return true;
  }
  return false;
}]>;

//===----------------------------------------------------------------------===//
// Custom Operands
//===----------------------------------------------------------------------===//

def FRAMEri32 : Operand<iPTR> {
  let MIOperandInfo = (ops i32:$ptr, i32imm:$index);
}

def SoppBrTarget : AsmOperandClass {
  let Name = "SoppBrTarget";
  let ParserMethod = "parseSOppBrTarget";
}

def sopp_brtarget : Operand<OtherVT> {
  let EncoderMethod = "getSOPPBrEncoding";
  let OperandType = "OPERAND_PCREL";
  let ParserMatchClass = SoppBrTarget;
}

def const_ga : Operand<iPTR>;

include "SIInstrFormats.td"
include "VIInstrFormats.td"

def MubufOffsetMatchClass : AsmOperandClass {
  let Name = "MubufOffset";
  let ParserMethod = "parseMubufOptionalOps";
  let RenderMethod = "addImmOperands";
}

class DSOffsetBaseMatchClass <string parser> : AsmOperandClass {
  let Name = "DSOffset"#parser;
  let ParserMethod = parser;
  let RenderMethod = "addImmOperands";
  let PredicateMethod = "isDSOffset";
}

def DSOffsetMatchClass : DSOffsetBaseMatchClass <"parseDSOptionalOps">;
def DSOffsetGDSMatchClass : DSOffsetBaseMatchClass <"parseDSOffsetOptional">;

def DSOffset01MatchClass : AsmOperandClass {
  let Name = "DSOffset1";
  let ParserMethod = "parseDSOff01OptionalOps";
  let RenderMethod = "addImmOperands";
  let PredicateMethod = "isDSOffset01";
}

class GDSBaseMatchClass <string parser> : AsmOperandClass {
  let Name = "GDS"#parser;
  let PredicateMethod = "isImm";
  let ParserMethod = parser;
  let RenderMethod = "addImmOperands";
}

def GDSMatchClass : GDSBaseMatchClass <"parseDSOptionalOps">;
def GDS01MatchClass : GDSBaseMatchClass <"parseDSOff01OptionalOps">;

class GLCBaseMatchClass <string parser> : AsmOperandClass {
  let Name = "GLC"#parser;
  let PredicateMethod = "isImm";
  let ParserMethod = parser;
  let RenderMethod = "addImmOperands";
}

def GLCMubufMatchClass : GLCBaseMatchClass <"parseMubufOptionalOps">;
def GLCFlatMatchClass : GLCBaseMatchClass <"parseFlatOptionalOps">;

class SLCBaseMatchClass <string parser> : AsmOperandClass {
  let Name = "SLC"#parser;
  let PredicateMethod = "isImm";
  let ParserMethod = parser;
  let RenderMethod = "addImmOperands";
}

def SLCMubufMatchClass : SLCBaseMatchClass <"parseMubufOptionalOps">;
def SLCFlatMatchClass : SLCBaseMatchClass <"parseFlatOptionalOps">;
def SLCFlatAtomicMatchClass : SLCBaseMatchClass <"parseFlatAtomicOptionalOps">;

class TFEBaseMatchClass <string parser> : AsmOperandClass {
  let Name = "TFE"#parser;
  let PredicateMethod = "isImm";
  let ParserMethod = parser;
  let RenderMethod = "addImmOperands";
}

def TFEMubufMatchClass : TFEBaseMatchClass <"parseMubufOptionalOps">;
def TFEFlatMatchClass : TFEBaseMatchClass <"parseFlatOptionalOps">;
def TFEFlatAtomicMatchClass : TFEBaseMatchClass <"parseFlatAtomicOptionalOps">;

def OModMatchClass : AsmOperandClass {
  let Name = "OMod";
  let PredicateMethod = "isImm";
  let ParserMethod = "parseVOP3OptionalOps";
  let RenderMethod = "addImmOperands";
}

def ClampMatchClass : AsmOperandClass {
  let Name = "Clamp";
  let PredicateMethod = "isImm";
  let ParserMethod = "parseVOP3OptionalOps";
  let RenderMethod = "addImmOperands";
}

class SMRDOffsetBaseMatchClass <string predicate> : AsmOperandClass {
  let Name = "SMRDOffset"#predicate;
  let PredicateMethod = predicate;
  let RenderMethod = "addImmOperands";
}

def SMRDOffsetMatchClass : SMRDOffsetBaseMatchClass <"isSMRDOffset">;
def SMRDLiteralOffsetMatchClass : SMRDOffsetBaseMatchClass <
  "isSMRDLiteralOffset"
>;

let OperandType = "OPERAND_IMMEDIATE" in {

def offen : Operand<i1> {
  let PrintMethod = "printOffen";
}
def idxen : Operand<i1> {
  let PrintMethod = "printIdxen";
}
def addr64 : Operand<i1> {
  let PrintMethod = "printAddr64";
}
def mbuf_offset : Operand<i16> {
  let PrintMethod = "printMBUFOffset";
  let ParserMatchClass = MubufOffsetMatchClass;
}
class ds_offset_base <AsmOperandClass mc> : Operand<i16> {
  let PrintMethod = "printDSOffset";
  let ParserMatchClass = mc;
}
def ds_offset : ds_offset_base <DSOffsetMatchClass>;
def ds_offset_gds : ds_offset_base <DSOffsetGDSMatchClass>;

def ds_offset0 : Operand<i8> {
  let PrintMethod = "printDSOffset0";
  let ParserMatchClass = DSOffset01MatchClass;
}
def ds_offset1 : Operand<i8> {
  let PrintMethod = "printDSOffset1";
  let ParserMatchClass = DSOffset01MatchClass;
}
class gds_base <AsmOperandClass mc> : Operand <i1> {
  let PrintMethod = "printGDS";
  let ParserMatchClass = mc;
}
def gds : gds_base <GDSMatchClass>;

def gds01 : gds_base <GDS01MatchClass>;

class glc_base <AsmOperandClass mc> : Operand <i1> {
  let PrintMethod = "printGLC";
  let ParserMatchClass = mc;
}

def glc : glc_base <GLCMubufMatchClass>;
def glc_flat : glc_base <GLCFlatMatchClass>;

class slc_base <AsmOperandClass mc> : Operand <i1> {
  let PrintMethod = "printSLC";
  let ParserMatchClass = mc;
}

def slc : slc_base <SLCMubufMatchClass>;
def slc_flat : slc_base <SLCFlatMatchClass>;
def slc_flat_atomic : slc_base <SLCFlatAtomicMatchClass>;

class tfe_base <AsmOperandClass mc> : Operand <i1> {
  let PrintMethod = "printTFE";
  let ParserMatchClass = mc;
}

def tfe : tfe_base <TFEMubufMatchClass>;
def tfe_flat : tfe_base <TFEFlatMatchClass>;
def tfe_flat_atomic : tfe_base <TFEFlatAtomicMatchClass>;

def omod : Operand <i32> {
  let PrintMethod = "printOModSI";
  let ParserMatchClass = OModMatchClass;
}

def ClampMod : Operand <i1> {
  let PrintMethod = "printClampSI";
  let ParserMatchClass = ClampMatchClass;
}

def smrd_offset : Operand <i32> {
  let PrintMethod = "printU32ImmOperand";
  let ParserMatchClass = SMRDOffsetMatchClass;
}

def smrd_literal_offset : Operand <i32> {
  let PrintMethod = "printU32ImmOperand";
  let ParserMatchClass = SMRDLiteralOffsetMatchClass;
}

} // End OperandType = "OPERAND_IMMEDIATE"

def VOPDstS64 : VOPDstOperand <SReg_64>;

//===----------------------------------------------------------------------===//
// Complex patterns
//===----------------------------------------------------------------------===//

def DS1Addr1Offset : ComplexPattern<i32, 2, "SelectDS1Addr1Offset">;
def DS64Bit4ByteAligned : ComplexPattern<i32, 3, "SelectDS64Bit4ByteAligned">;

def MUBUFAddr32 : ComplexPattern<i64, 9, "SelectMUBUFAddr32">;
def MUBUFAddr64 : ComplexPattern<i64, 7, "SelectMUBUFAddr64">;
def MUBUFAddr64Atomic : ComplexPattern<i64, 5, "SelectMUBUFAddr64">;
def MUBUFScratch : ComplexPattern<i64, 4, "SelectMUBUFScratch">;
def MUBUFOffset : ComplexPattern<i64, 6, "SelectMUBUFOffset">;
def MUBUFOffsetAtomic : ComplexPattern<i64, 4, "SelectMUBUFOffset">;

def SMRDImm   : ComplexPattern<i64, 2, "SelectSMRDImm">;
def SMRDImm32 : ComplexPattern<i64, 2, "SelectSMRDImm32">;
def SMRDSgpr  : ComplexPattern<i64, 2, "SelectSMRDSgpr">;
def SMRDBufferImm   : ComplexPattern<i32, 1, "SelectSMRDBufferImm">;
def SMRDBufferImm32 : ComplexPattern<i32, 1, "SelectSMRDBufferImm32">;
def SMRDBufferSgpr  : ComplexPattern<i32, 1, "SelectSMRDBufferSgpr">;

def VOP3Mods0 : ComplexPattern<untyped, 4, "SelectVOP3Mods0">;
def VOP3NoMods0 : ComplexPattern<untyped, 4, "SelectVOP3NoMods0">;
def VOP3Mods0Clamp : ComplexPattern<untyped, 3, "SelectVOP3Mods0Clamp">;
def VOP3Mods0Clamp0OMod : ComplexPattern<untyped, 4, "SelectVOP3Mods0Clamp0OMod">;
def VOP3Mods  : ComplexPattern<untyped, 2, "SelectVOP3Mods">;
def VOP3NoMods : ComplexPattern<untyped, 2, "SelectVOP3NoMods">;

//===----------------------------------------------------------------------===//
// SI assembler operands
//===----------------------------------------------------------------------===//

def SIOperand {
  int ZERO = 0x80;
  int VCC = 0x6A;
  int FLAT_SCR = 0x68;
}

def SRCMODS {
  int NONE = 0;
  int NEG = 1;
}

def DSTCLAMP {
  int NONE = 0;
}

def DSTOMOD {
  int NONE = 0;
}

//===----------------------------------------------------------------------===//
//
// SI Instruction multiclass helpers.
//
// Instructions with _32 take 32-bit operands.
// Instructions with _64 take 64-bit operands.
//
// VOP_* instructions can use either a 32-bit or 64-bit encoding.  The 32-bit
// encoding is the standard encoding, but instruction that make use of
// any of the instruction modifiers must use the 64-bit encoding.
//
// Instructions with _e32 use the 32-bit encoding.
// Instructions with _e64 use the 64-bit encoding.
//
//===----------------------------------------------------------------------===//

class SIMCInstr <string pseudo, int subtarget> {
  string PseudoInstr = pseudo;
  int Subtarget = subtarget;
}

//===----------------------------------------------------------------------===//
// EXP classes
//===----------------------------------------------------------------------===//

class EXPCommon : InstSI<
  (outs),
  (ins i32imm:$en, i32imm:$tgt, i32imm:$compr, i32imm:$done, i32imm:$vm,
       VGPR_32:$src0, VGPR_32:$src1, VGPR_32:$src2, VGPR_32:$src3),
  "exp $en, $tgt, $compr, $done, $vm, $src0, $src1, $src2, $src3",
  [] > {

  let EXP_CNT = 1;
  let Uses = [EXEC];
}

multiclass EXP_m {

  let isPseudo = 1, isCodeGenOnly = 1 in {
    def "" : EXPCommon, SIMCInstr <"exp", SISubtarget.NONE> ;
  }

  def _si : EXPCommon, SIMCInstr <"exp", SISubtarget.SI>, EXPe;

  def _vi : EXPCommon, SIMCInstr <"exp", SISubtarget.VI>, EXPe_vi;
}

//===----------------------------------------------------------------------===//
// Scalar classes
//===----------------------------------------------------------------------===//

class SOP1_Pseudo <string opName, dag outs, dag ins, list<dag> pattern> :
  SOP1 <outs, ins, "", pattern>,
  SIMCInstr<opName, SISubtarget.NONE> {
  let isPseudo = 1;
  let isCodeGenOnly = 1;
}

class SOP1_Real_si <sop1 op, string opName, dag outs, dag ins, string asm> :
  SOP1 <outs, ins, asm, []>,
  SOP1e <op.SI>,
  SIMCInstr<opName, SISubtarget.SI> {
  let isCodeGenOnly = 0;
  let AssemblerPredicates = [isSICI];
}

class SOP1_Real_vi <sop1 op, string opName, dag outs, dag ins, string asm> :
  SOP1 <outs, ins, asm, []>,
  SOP1e <op.VI>,
  SIMCInstr<opName, SISubtarget.VI> {
  let isCodeGenOnly = 0;
  let AssemblerPredicates = [isVI];
}

multiclass SOP1_m <sop1 op, string opName, dag outs, dag ins, string asm,
                   list<dag> pattern> {

  def "" : SOP1_Pseudo <opName, outs, ins, pattern>;

  def _si : SOP1_Real_si <op, opName, outs, ins, asm>;

  def _vi : SOP1_Real_vi <op, opName, outs, ins, asm>;

}

multiclass SOP1_32 <sop1 op, string opName, list<dag> pattern> : SOP1_m <
    op, opName, (outs SReg_32:$dst), (ins SSrc_32:$src0),
    opName#" $dst, $src0", pattern
>;

multiclass SOP1_64 <sop1 op, string opName, list<dag> pattern> : SOP1_m <
    op, opName, (outs SReg_64:$dst), (ins SSrc_64:$src0),
    opName#" $dst, $src0", pattern
>;

// no input, 64-bit output.
multiclass SOP1_64_0 <sop1 op, string opName, list<dag> pattern> {
  def "" : SOP1_Pseudo <opName, (outs SReg_64:$dst), (ins), pattern>;

  def _si : SOP1_Real_si <op, opName, (outs SReg_64:$dst), (ins),
    opName#" $dst"> {
    let ssrc0 = 0;
  }

  def _vi : SOP1_Real_vi <op, opName, (outs SReg_64:$dst), (ins),
    opName#" $dst"> {
    let ssrc0 = 0;
  }
}

// 64-bit input, no output
multiclass SOP1_1 <sop1 op, string opName, list<dag> pattern> {
  def "" : SOP1_Pseudo <opName, (outs), (ins SReg_64:$src0), pattern>;

  def _si : SOP1_Real_si <op, opName, (outs), (ins SReg_64:$src0),
    opName#" $src0"> {
    let sdst = 0;
  }

  def _vi : SOP1_Real_vi <op, opName, (outs), (ins SReg_64:$src0),
    opName#" $src0"> {
    let sdst = 0;
  }
}

// 64-bit input, 32-bit output.
multiclass SOP1_32_64 <sop1 op, string opName, list<dag> pattern> : SOP1_m <
    op, opName, (outs SReg_32:$dst), (ins SSrc_64:$src0),
    opName#" $dst, $src0", pattern
>;

class SOP2_Pseudo<string opName, dag outs, dag ins, list<dag> pattern> :
  SOP2<outs, ins, "", pattern>,
  SIMCInstr<opName, SISubtarget.NONE> {
  let isPseudo = 1;
  let isCodeGenOnly = 1;
  let Size = 4;

  // Pseudo instructions have no encodings, but adding this field here allows
  // us to do:
  // let sdst = xxx in {
  // for multiclasses that include both real and pseudo instructions.
  field bits<7> sdst = 0;
}

class SOP2_Real_si<sop2 op, string opName, dag outs, dag ins, string asm> :
  SOP2<outs, ins, asm, []>,
  SOP2e<op.SI>,
  SIMCInstr<opName, SISubtarget.SI> {
  let AssemblerPredicates = [isSICI];
}

class SOP2_Real_vi<sop2 op, string opName, dag outs, dag ins, string asm> :
  SOP2<outs, ins, asm, []>,
  SOP2e<op.VI>,
  SIMCInstr<opName, SISubtarget.VI> {
  let AssemblerPredicates = [isVI];
}

multiclass SOP2_m <sop2 op, string opName, dag outs, dag ins, string asm,
                   list<dag> pattern> {

  def "" : SOP2_Pseudo <opName, outs, ins, pattern>;

  def _si : SOP2_Real_si <op, opName, outs, ins, asm>;

  def _vi : SOP2_Real_vi <op, opName, outs, ins, asm>;

}

multiclass SOP2_32 <sop2 op, string opName, list<dag> pattern> : SOP2_m <
    op, opName, (outs SReg_32:$dst), (ins SSrc_32:$src0, SSrc_32:$src1),
    opName#" $dst, $src0, $src1", pattern
>;

multiclass SOP2_64 <sop2 op, string opName, list<dag> pattern> : SOP2_m <
    op, opName, (outs SReg_64:$dst), (ins SSrc_64:$src0, SSrc_64:$src1),
    opName#" $dst, $src0, $src1", pattern
>;

multiclass SOP2_64_32 <sop2 op, string opName, list<dag> pattern> : SOP2_m <
    op, opName, (outs SReg_64:$dst), (ins SSrc_64:$src0, SSrc_32:$src1),
    opName#" $dst, $src0, $src1", pattern
>;

class SOPC_Helper <bits<7> op, RegisterOperand rc, ValueType vt,
                    string opName, PatLeaf cond> : SOPC <
  op, (outs), (ins rc:$src0, rc:$src1),
  opName#" $src0, $src1", []> {
  let Defs = [SCC];
}

class SOPC_32<bits<7> op, string opName, PatLeaf cond = COND_NULL>
  : SOPC_Helper<op, SSrc_32, i32, opName, cond>;

class SOPC_64<bits<7> op, string opName, PatLeaf cond = COND_NULL>
  : SOPC_Helper<op, SSrc_64, i64, opName, cond>;

class SOPK_Pseudo <string opName, dag outs, dag ins, list<dag> pattern> :
  SOPK <outs, ins, "", pattern>,
  SIMCInstr<opName, SISubtarget.NONE> {
  let isPseudo = 1;
  let isCodeGenOnly = 1;
}

class SOPK_Real_si <sopk op, string opName, dag outs, dag ins, string asm> :
  SOPK <outs, ins, asm, []>,
  SOPKe <op.SI>,
  SIMCInstr<opName, SISubtarget.SI> {
  let AssemblerPredicates = [isSICI];
  let isCodeGenOnly = 0;
}

class SOPK_Real_vi <sopk op, string opName, dag outs, dag ins, string asm> :
  SOPK <outs, ins, asm, []>,
  SOPKe <op.VI>,
  SIMCInstr<opName, SISubtarget.VI> {
  let AssemblerPredicates = [isVI];
  let isCodeGenOnly = 0;
}

multiclass SOPK_m <sopk op, string opName, dag outs, dag ins, string opAsm,
                   string asm = opName#opAsm> {
  def "" : SOPK_Pseudo <opName, outs, ins, []>;

  def _si : SOPK_Real_si <op, opName, outs, ins, asm>;

  def _vi : SOPK_Real_vi <op, opName, outs, ins, asm>;

}

multiclass SOPK_32 <sopk op, string opName, list<dag> pattern> {
  def "" : SOPK_Pseudo <opName, (outs SReg_32:$dst), (ins u16imm:$src0),
    pattern>;

  def _si : SOPK_Real_si <op, opName, (outs SReg_32:$dst), (ins u16imm:$src0),
    opName#" $dst, $src0">;

  def _vi : SOPK_Real_vi <op, opName, (outs SReg_32:$dst), (ins u16imm:$src0),
    opName#" $dst, $src0">;
}

multiclass SOPK_SCC <sopk op, string opName, list<dag> pattern> {
  def "" : SOPK_Pseudo <opName, (outs),
    (ins SReg_32:$src0, u16imm:$src1), pattern> {
    let Defs = [SCC];
  }


  def _si : SOPK_Real_si <op, opName, (outs),
    (ins SReg_32:$sdst, u16imm:$simm16), opName#" $sdst, $simm16"> {
    let Defs = [SCC];
  }

  def _vi : SOPK_Real_vi <op, opName, (outs),
    (ins SReg_32:$sdst, u16imm:$simm16), opName#" $sdst, $simm16"> {
    let Defs = [SCC];
  }
}

multiclass SOPK_32TIE <sopk op, string opName, list<dag> pattern> : SOPK_m <
  op, opName, (outs SReg_32:$sdst), (ins SReg_32:$src0, u16imm:$simm16),
  " $sdst, $simm16"
>;

multiclass SOPK_IMM32 <sopk op, string opName, dag outs, dag ins,
                       string argAsm, string asm = opName#argAsm> {

  def "" : SOPK_Pseudo <opName, outs, ins, []>;

  def _si : SOPK <outs, ins, asm, []>,
            SOPK64e <op.SI>,
            SIMCInstr<opName, SISubtarget.SI> {
              let AssemblerPredicates = [isSICI];
              let isCodeGenOnly = 0;
            }

  def _vi : SOPK <outs, ins, asm, []>,
            SOPK64e <op.VI>,
            SIMCInstr<opName, SISubtarget.VI> {
              let AssemblerPredicates = [isVI];
              let isCodeGenOnly = 0;
            }
}
//===----------------------------------------------------------------------===//
// SMRD classes
//===----------------------------------------------------------------------===//

class SMRD_Pseudo <string opName, dag outs, dag ins, list<dag> pattern> :
  SMRD <outs, ins, "", pattern>,
  SIMCInstr<opName, SISubtarget.NONE> {
  let isPseudo = 1;
  let isCodeGenOnly = 1;
}

class SMRD_Real_si <bits<5> op, string opName, bit imm, dag outs, dag ins,
                    string asm> :
  SMRD <outs, ins, asm, []>,
  SMRDe <op, imm>,
  SIMCInstr<opName, SISubtarget.SI> {
  let AssemblerPredicates = [isSICI];
}

class SMRD_Real_vi <bits<8> op, string opName, bit imm, dag outs, dag ins,
                    string asm, list<dag> pattern = []> :
  SMRD <outs, ins, asm, pattern>,
  SMEMe_vi <op, imm>,
  SIMCInstr<opName, SISubtarget.VI> {
  let AssemblerPredicates = [isVI];
}

multiclass SMRD_m <smrd op, string opName, bit imm, dag outs, dag ins,
                   string asm, list<dag> pattern> {

  def "" : SMRD_Pseudo <opName, outs, ins, pattern>;

  def _si : SMRD_Real_si <op.SI, opName, imm, outs, ins, asm>;

  // glc is only applicable to scalar stores, which are not yet
  // implemented.
  let glc = 0 in {
    def _vi : SMRD_Real_vi <op.VI, opName, imm, outs, ins, asm>;
  }
}

multiclass SMRD_Inval <smrd op, string opName,
                       SDPatternOperator node> {
  let hasSideEffects = 1, mayStore = 1 in {
    def "" : SMRD_Pseudo <opName, (outs), (ins), [(node)]>;

    let sbase = 0, offset = 0 in {
      let sdst = 0 in {
        def _si : SMRD_Real_si <op.SI, opName, 0, (outs), (ins), opName>;
      }

      let glc = 0, sdata = 0 in {
        def _vi : SMRD_Real_vi <op.VI, opName, 0, (outs), (ins), opName>;
      }
    }
  }
}

class SMEM_Inval <bits<8> op, string opName, SDPatternOperator node> :
  SMRD_Real_vi<op, opName, 0, (outs), (ins), opName, [(node)]> {
  let hasSideEffects = 1;
  let mayStore = 1;
  let sbase = 0;
  let sdata = 0;
  let glc = 0;
  let offset = 0;
}

multiclass SMRD_Helper <smrd op, string opName, RegisterClass baseClass,
                        RegisterClass dstClass> {
  defm _IMM : SMRD_m <
    op, opName#"_IMM", 1, (outs dstClass:$dst),
    (ins baseClass:$sbase, smrd_offset:$offset),
    opName#" $dst, $sbase, $offset", []
  >;

  def _IMM_ci : SMRD <
    (outs dstClass:$dst), (ins baseClass:$sbase, smrd_literal_offset:$offset),
    opName#" $dst, $sbase, $offset", []>, SMRD_IMMe_ci <op.SI> {
    let AssemblerPredicates = [isCIOnly];
  }

  defm _SGPR : SMRD_m <
    op, opName#"_SGPR", 0, (outs dstClass:$dst),
    (ins baseClass:$sbase, SReg_32:$soff),
    opName#" $dst, $sbase, $soff", []
  >;
}

//===----------------------------------------------------------------------===//
// Vector ALU classes
//===----------------------------------------------------------------------===//

// This must always be right before the operand being input modified.
def InputMods : OperandWithDefaultOps <i32, (ops (i32 0))> {
  let PrintMethod = "printOperandAndMods";
}

def InputModsMatchClass : AsmOperandClass {
  let Name = "RegWithInputMods";
}

def InputModsNoDefault : Operand <i32> {
  let PrintMethod = "printOperandAndMods";
  let ParserMatchClass = InputModsMatchClass;
}

class getNumSrcArgs<ValueType Src0, ValueType Src1, ValueType Src2> {
  int ret =
    !if (!eq(Src0.Value, untyped.Value),      0,
      !if (!eq(Src1.Value, untyped.Value),    1,   // VOP1
         !if (!eq(Src2.Value, untyped.Value), 2,   // VOP2
                                              3))); // VOP3
}

// Returns the register class to use for the destination of VOP[123C]
// instructions for the given VT.
class getVALUDstForVT<ValueType VT> {
  RegisterOperand ret = !if(!eq(VT.Size, 32), VOPDstOperand<VGPR_32>,
                          !if(!eq(VT.Size, 64), VOPDstOperand<VReg_64>,
                            !if(!eq(VT.Size, 16), VOPDstOperand<VGPR_32>,
                            VOPDstOperand<SReg_64>))); // else VT == i1
}

// Returns the register class to use for source 0 of VOP[12C]
// instructions for the given VT.
class getVOPSrc0ForVT<ValueType VT> {
  RegisterOperand ret = !if(!eq(VT.Size, 64), VSrc_64, VSrc_32);
}

// Returns the register class to use for source 1 of VOP[12C] for the
// given VT.
class getVOPSrc1ForVT<ValueType VT> {
  RegisterClass ret = !if(!eq(VT.Size, 64), VReg_64, VGPR_32);
}

// Returns the register class to use for sources of VOP3 instructions for the
// given VT.
class getVOP3SrcForVT<ValueType VT> {
  RegisterOperand ret =
  !if(!eq(VT.Size, 64),
      VCSrc_64,
      !if(!eq(VT.Value, i1.Value),
          SCSrc_64,
          VCSrc_32
       )
    );
}

// Returns 1 if the source arguments have modifiers, 0 if they do not.
// XXX - do f16 instructions?
class hasModifiers<ValueType SrcVT> {
  bit ret = !if(!eq(SrcVT.Value, f32.Value), 1,
            !if(!eq(SrcVT.Value, f64.Value), 1, 0));
}

// Returns the input arguments for VOP[12C] instructions for the given SrcVT.
class getIns32 <RegisterOperand Src0RC, RegisterClass Src1RC, int NumSrcArgs> {
  dag ret = !if(!eq(NumSrcArgs, 1), (ins Src0RC:$src0),               // VOP1
            !if(!eq(NumSrcArgs, 2), (ins Src0RC:$src0, Src1RC:$src1), // VOP2
                                    (ins)));
}

// Returns the input arguments for VOP3 instructions for the given SrcVT.
class getIns64 <RegisterOperand Src0RC, RegisterOperand Src1RC,
                RegisterOperand Src2RC, int NumSrcArgs,
                bit HasModifiers> {

  dag ret =
    !if (!eq(NumSrcArgs, 1),
      !if (!eq(HasModifiers, 1),
        // VOP1 with modifiers
        (ins InputModsNoDefault:$src0_modifiers, Src0RC:$src0,
             ClampMod:$clamp, omod:$omod)
      /* else */,
        // VOP1 without modifiers
        (ins Src0RC:$src0)
      /* endif */ ),
    !if (!eq(NumSrcArgs, 2),
      !if (!eq(HasModifiers, 1),
        // VOP 2 with modifiers
        (ins InputModsNoDefault:$src0_modifiers, Src0RC:$src0,
             InputModsNoDefault:$src1_modifiers, Src1RC:$src1,
             ClampMod:$clamp, omod:$omod)
      /* else */,
        // VOP2 without modifiers
        (ins Src0RC:$src0, Src1RC:$src1)
      /* endif */ )
    /* NumSrcArgs == 3 */,
      !if (!eq(HasModifiers, 1),
        // VOP3 with modifiers
        (ins InputModsNoDefault:$src0_modifiers, Src0RC:$src0,
             InputModsNoDefault:$src1_modifiers, Src1RC:$src1,
             InputModsNoDefault:$src2_modifiers, Src2RC:$src2,
             ClampMod:$clamp, omod:$omod)
      /* else */,
        // VOP3 without modifiers
        (ins Src0RC:$src0, Src1RC:$src1, Src2RC:$src2)
      /* endif */ )));
}

// Returns the assembly string for the inputs and outputs of a VOP[12C]
// instruction.  This does not add the _e32 suffix, so it can be reused
// by getAsm64.
class getAsm32 <bit HasDst, int NumSrcArgs> {
  string dst = "$dst";
  string src0 = ", $src0";
  string src1 = ", $src1";
  string src2 = ", $src2";
  string ret = !if(HasDst, dst, "") #
               !if(!eq(NumSrcArgs, 1), src0, "") #
               !if(!eq(NumSrcArgs, 2), src0#src1, "") #
               !if(!eq(NumSrcArgs, 3), src0#src1#src2, "");
}

// Returns the assembly string for the inputs and outputs of a VOP3
// instruction.
class getAsm64 <bit HasDst, int NumSrcArgs, bit HasModifiers> {
  string src0 = !if(!eq(NumSrcArgs, 1), "$src0_modifiers", "$src0_modifiers,");
  string src1 = !if(!eq(NumSrcArgs, 1), "",
                   !if(!eq(NumSrcArgs, 2), " $src1_modifiers",
                                           " $src1_modifiers,"));
  string src2 = !if(!eq(NumSrcArgs, 3), " $src2_modifiers", "");
  string ret =
  !if(!eq(HasModifiers, 0),
      getAsm32<HasDst, NumSrcArgs>.ret,
      "$dst, "#src0#src1#src2#"$clamp"#"$omod");
}

class VOPProfile <list<ValueType> _ArgVT> {

  field list<ValueType> ArgVT = _ArgVT;

  field ValueType DstVT = ArgVT[0];
  field ValueType Src0VT = ArgVT[1];
  field ValueType Src1VT = ArgVT[2];
  field ValueType Src2VT = ArgVT[3];
  field RegisterOperand DstRC = getVALUDstForVT<DstVT>.ret;
  field RegisterOperand Src0RC32 = getVOPSrc0ForVT<Src0VT>.ret;
  field RegisterClass Src1RC32 = getVOPSrc1ForVT<Src1VT>.ret;
  field RegisterOperand Src0RC64 = getVOP3SrcForVT<Src0VT>.ret;
  field RegisterOperand Src1RC64 = getVOP3SrcForVT<Src1VT>.ret;
  field RegisterOperand Src2RC64 = getVOP3SrcForVT<Src2VT>.ret;

  field bit HasDst = !if(!eq(DstVT.Value, untyped.Value), 0, 1);
  field bit HasDst32 = HasDst;
  field int NumSrcArgs = getNumSrcArgs<Src0VT, Src1VT, Src2VT>.ret;
  field bit HasModifiers = hasModifiers<Src0VT>.ret;

  field dag Outs = !if(HasDst,(outs DstRC:$dst),(outs));

  // VOP3b instructions are a special case with a second explicit
  // output. This is manually overridden for them.
  field dag Outs32 = Outs;
  field dag Outs64 = Outs;

  field dag Ins32 = getIns32<Src0RC32, Src1RC32, NumSrcArgs>.ret;
  field dag Ins64 = getIns64<Src0RC64, Src1RC64, Src2RC64, NumSrcArgs,
                             HasModifiers>.ret;

  field string Asm32 = getAsm32<HasDst, NumSrcArgs>.ret;
  field string Asm64 = getAsm64<HasDst, NumSrcArgs, HasModifiers>.ret;
}

// FIXME: I think these F16/I16 profiles will need to use f16/i16 types in order
//        for the instruction patterns to work.
def VOP_F16_F16 : VOPProfile <[f16, f16, untyped, untyped]>;
def VOP_F16_I16 : VOPProfile <[f16, i32, untyped, untyped]>;
def VOP_I16_F16 : VOPProfile <[i32, f16, untyped, untyped]>;

def VOP_F16_F16_F16 : VOPProfile <[f16, f16, f16, untyped]>;
def VOP_F16_F16_I16 : VOPProfile <[f16, f16, i32, untyped]>;
def VOP_I16_I16_I16 : VOPProfile <[i32, i32, i32, untyped]>;

def VOP_NONE : VOPProfile <[untyped, untyped, untyped, untyped]>;

def VOP_F32_F32 : VOPProfile <[f32, f32, untyped, untyped]>;
def VOP_F32_F64 : VOPProfile <[f32, f64, untyped, untyped]>;
def VOP_F32_I32 : VOPProfile <[f32, i32, untyped, untyped]>;
def VOP_F64_F32 : VOPProfile <[f64, f32, untyped, untyped]>;
def VOP_F64_F64 : VOPProfile <[f64, f64, untyped, untyped]>;
def VOP_F64_I32 : VOPProfile <[f64, i32, untyped, untyped]>;
def VOP_I32_F32 : VOPProfile <[i32, f32, untyped, untyped]>;
def VOP_I32_F64 : VOPProfile <[i32, f64, untyped, untyped]>;
def VOP_I32_I32 : VOPProfile <[i32, i32, untyped, untyped]>;

def VOP_F32_F32_F32 : VOPProfile <[f32, f32, f32, untyped]>;
def VOP_F32_F32_I32 : VOPProfile <[f32, f32, i32, untyped]>;
def VOP_F64_F64_F64 : VOPProfile <[f64, f64, f64, untyped]>;
def VOP_F64_F64_I32 : VOPProfile <[f64, f64, i32, untyped]>;
def VOP_I32_F32_F32 : VOPProfile <[i32, f32, f32, untyped]>;
def VOP_I32_F32_I32 : VOPProfile <[i32, f32, i32, untyped]>;
def VOP_I32_I32_I32 : VOPProfile <[i32, i32, i32, untyped]>;

// Write out to vcc or arbitrary SGPR.
def VOP2b_I32_I1_I32_I32 : VOPProfile<[i32, i32, i32, untyped]> {
  let Asm32 = "$dst, vcc, $src0, $src1";
  let Asm64 = "$dst, $sdst, $src0, $src1";
  let Outs32 = (outs DstRC:$dst);
  let Outs64 = (outs DstRC:$dst, SReg_64:$sdst);
}

// Write out to vcc or arbitrary SGPR and read in from vcc or
// arbitrary SGPR.
def VOP2b_I32_I1_I32_I32_I1 : VOPProfile<[i32, i32, i32, i1]> {
  // We use VCSrc_32 to exclude literal constants, even though the
  // encoding normally allows them since the implicit VCC use means
  // using one would always violate the constant bus
  // restriction. SGPRs are still allowed because it should
  // technically be possible to use VCC again as src0.
  let Src0RC32 = VCSrc_32;
  let Asm32 = "$dst, vcc, $src0, $src1, vcc";
  let Asm64 = "$dst, $sdst, $src0, $src1, $src2";
  let Outs32 = (outs DstRC:$dst);
  let Outs64 = (outs DstRC:$dst, SReg_64:$sdst);

  // Suppress src2 implied by type since the 32-bit encoding uses an
  // implicit VCC use.
  let Ins32 = (ins Src0RC32:$src0, Src1RC32:$src1);
}

class VOP3b_Profile<ValueType vt> : VOPProfile<[vt, vt, vt, vt]> {
  let Outs64 = (outs DstRC:$vdst, SReg_64:$sdst);
  let Asm64 = "$vdst, $sdst, $src0_modifiers, $src1_modifiers, $src2_modifiers"#"$clamp"#"$omod";
}

def VOP3b_F32_I1_F32_F32_F32 : VOP3b_Profile<f32> {
  // FIXME: Hack to stop printing _e64
  let DstRC = RegisterOperand<VGPR_32>;
}

def VOP3b_F64_I1_F64_F64_F64 : VOP3b_Profile<f64> {
  // FIXME: Hack to stop printing _e64
  let DstRC = RegisterOperand<VReg_64>;
}

// VOPC instructions are a special case because for the 32-bit
// encoding, we want to display the implicit vcc write as if it were
// an explicit $dst.
class VOPC_Profile<ValueType vt0, ValueType vt1 = vt0> : VOPProfile <[i1, vt0, vt1, untyped]> {
  let Asm32 = "vcc, $src0, $src1";
  // The destination for 32-bit encoding is implicit.
  let HasDst32 = 0;
}

class VOPC_Class_Profile<ValueType vt> : VOPC_Profile<vt, i32> {
  let Ins64 = (ins InputModsNoDefault:$src0_modifiers, Src0RC64:$src0, Src1RC64:$src1);
  let Asm64 = "$dst, $src0_modifiers, $src1";
}

def VOPC_I1_F32_F32 : VOPC_Profile<f32>;
def VOPC_I1_F64_F64 : VOPC_Profile<f64>;
def VOPC_I1_I32_I32 : VOPC_Profile<i32>;
def VOPC_I1_I64_I64 : VOPC_Profile<i64>;

def VOPC_I1_F32_I32 : VOPC_Class_Profile<f32>;
def VOPC_I1_F64_I32 : VOPC_Class_Profile<f64>;

def VOP_I64_I64_I32 : VOPProfile <[i64, i64, i32, untyped]>;
def VOP_I64_I32_I64 : VOPProfile <[i64, i32, i64, untyped]>;
def VOP_I64_I64_I64 : VOPProfile <[i64, i64, i64, untyped]>;
def VOP_CNDMASK : VOPProfile <[i32, i32, i32, untyped]> {
  let Ins32 = (ins Src0RC32:$src0, Src1RC32:$src1);
  let Ins64 = (ins Src0RC64:$src0, Src1RC64:$src1, SSrc_64:$src2);
  let Asm64 = "$dst, $src0, $src1, $src2";
}

def VOP_F32_F32_F32_F32 : VOPProfile <[f32, f32, f32, f32]>;
def VOP_MADK : VOPProfile <[f32, f32, f32, f32]> {
  field dag Ins = (ins VCSrc_32:$src0, VGPR_32:$vsrc1, u32imm:$src2);
  field string Asm = "$dst, $src0, $vsrc1, $src2";
}
def VOP_MAC : VOPProfile <[f32, f32, f32, f32]> {
  let Ins32 = (ins Src0RC32:$src0, Src1RC32:$src1, VGPR_32:$src2);
  let Ins64 = getIns64<Src0RC64, Src1RC64, RegisterOperand<VGPR_32>, 3,
                             HasModifiers>.ret;
  let Asm32 = getAsm32<1, 2>.ret;
  let Asm64 = getAsm64<1, 2, HasModifiers>.ret;
}
def VOP_F64_F64_F64_F64 : VOPProfile <[f64, f64, f64, f64]>;
def VOP_I32_I32_I32_I32 : VOPProfile <[i32, i32, i32, i32]>;
def VOP_I64_I32_I32_I64 : VOPProfile <[i64, i32, i32, i64]>;

class SIInstAlias <string asm, Instruction inst, VOPProfile p> :
    InstAlias <asm, (inst)>, PredicateControl {

  field bit isCompare;
  field bit isCommutable;

  let ResultInst =
    !if (p.HasDst32,
      !if (!eq(p.NumSrcArgs, 0),
        // 1 dst, 0 src
        (inst p.DstRC:$dst),
      !if (!eq(p.NumSrcArgs, 1),
        // 1 dst, 1 src
        (inst p.DstRC:$dst, p.Src0RC32:$src0),
      !if (!eq(p.NumSrcArgs, 2),
        // 1 dst, 2 src
        (inst p.DstRC:$dst, p.Src0RC32:$src0, p.Src1RC32:$src1),
      // else - unreachable
        (inst)))),
    // else
      !if (!eq(p.NumSrcArgs, 2),
        // 0 dst, 2 src
        (inst p.Src0RC32:$src0, p.Src1RC32:$src1),
      !if (!eq(p.NumSrcArgs, 1),
        // 0 dst, 1 src
        (inst p.Src0RC32:$src1),
      // else
        // 0 dst, 0 src
        (inst))));
}

class SIInstAliasSI <string asm, string op_name, VOPProfile p> :
  SIInstAlias <asm, !cast<Instruction>(op_name#"_e32_si"), p> {
  let AssemblerPredicate = SIAssemblerPredicate;
}

class SIInstAliasVI <string asm, string op_name, VOPProfile p> :
  SIInstAlias <asm, !cast<Instruction>(op_name#"_e32_vi"), p> {
  let AssemblerPredicates = [isVI];
}

multiclass SIInstAliasBuilder <string asm, VOPProfile p> {

  def : SIInstAliasSI <asm, NAME, p>;

  def : SIInstAliasVI <asm, NAME, p>;
}

class VOP <string opName> {
  string OpName = opName;
}

class VOP2_REV <string revOp, bit isOrig> {
  string RevOp = revOp;
  bit IsOrig = isOrig;
}

class AtomicNoRet <string noRetOp, bit isRet> {
  string NoRetOp = noRetOp;
  bit IsRet = isRet;
}

class VOP1_Pseudo <dag outs, dag ins, list<dag> pattern, string opName> :
  VOP1Common <outs, ins, "", pattern>,
  VOP <opName>,
  SIMCInstr <opName#"_e32", SISubtarget.NONE>,
  MnemonicAlias<opName#"_e32", opName> {
  let isPseudo = 1;
  let isCodeGenOnly = 1;

  field bits<8> vdst;
  field bits<9> src0;
}

class VOP1_Real_si <string opName, vop1 op, dag outs, dag ins, string asm> :
  VOP1<op.SI, outs, ins, asm, []>,
  SIMCInstr <opName#"_e32", SISubtarget.SI> {
  let AssemblerPredicate = SIAssemblerPredicate;
}

class VOP1_Real_vi <string opName, vop1 op, dag outs, dag ins, string asm> :
  VOP1<op.VI, outs, ins, asm, []>,
  SIMCInstr <opName#"_e32", SISubtarget.VI> {
  let AssemblerPredicates = [isVI];
}

multiclass VOP1_m <vop1 op, string opName, VOPProfile p, list<dag> pattern,
                   string asm = opName#p.Asm32> {
  def "" : VOP1_Pseudo <p.Outs, p.Ins32, pattern, opName>;

  def _si : VOP1_Real_si <opName, op, p.Outs, p.Ins32, asm>;

  def _vi : VOP1_Real_vi <opName, op, p.Outs, p.Ins32, asm>;

}

multiclass VOP1SI_m <vop1 op, string opName, VOPProfile p, list<dag> pattern,
                     string asm = opName#p.Asm32> {

  def "" : VOP1_Pseudo <p.Outs, p.Ins32, pattern, opName>;

  def _si : VOP1_Real_si <opName, op, p.Outs, p.Ins32, asm>;
}

class VOP2_Pseudo <dag outs, dag ins, list<dag> pattern, string opName> :
  VOP2Common <outs, ins, "", pattern>,
  VOP <opName>,
  SIMCInstr<opName#"_e32", SISubtarget.NONE>,
  MnemonicAlias<opName#"_e32", opName> {
  let isPseudo = 1;
  let isCodeGenOnly = 1;
}

class VOP2_Real_si <string opName, vop2 op, dag outs, dag ins, string asm> :
  VOP2 <op.SI, outs, ins, opName#asm, []>,
  SIMCInstr <opName#"_e32", SISubtarget.SI> {
  let AssemblerPredicates = [isSICI];
}

class VOP2_Real_vi <string opName, vop2 op, dag outs, dag ins, string asm> :
  VOP2 <op.VI, outs, ins, opName#asm, []>,
  SIMCInstr <opName#"_e32", SISubtarget.VI> {
  let AssemblerPredicates = [isVI];
}

multiclass VOP2SI_m <vop2 op, string opName, VOPProfile p, list<dag> pattern,
                     string revOp> {

  def "" : VOP2_Pseudo <p.Outs32, p.Ins32, pattern, opName>,
           VOP2_REV<revOp#"_e32", !eq(revOp, opName)>;

  def _si : VOP2_Real_si <opName, op, p.Outs32, p.Ins32, p.Asm32>;
}

multiclass VOP2_m <vop2 op, string opName, VOPProfile p, list <dag> pattern,
                   string revOp> {

  def "" : VOP2_Pseudo <p.Outs32, p.Ins32, pattern, opName>,
           VOP2_REV<revOp#"_e32", !eq(revOp, opName)>;

  def _si : VOP2_Real_si <opName, op, p.Outs32, p.Ins32, p.Asm32>;

  def _vi : VOP2_Real_vi <opName, op, p.Outs32, p.Ins32, p.Asm32>;

}

class VOP3DisableFields <bit HasSrc1, bit HasSrc2, bit HasModifiers> {

  bits<2> src0_modifiers = !if(HasModifiers, ?, 0);
  bits<2> src1_modifiers = !if(HasModifiers, !if(HasSrc1, ?, 0), 0);
  bits<2> src2_modifiers = !if(HasModifiers, !if(HasSrc2, ?, 0), 0);
  bits<2> omod = !if(HasModifiers, ?, 0);
  bits<1> clamp = !if(HasModifiers, ?, 0);
  bits<9> src1 = !if(HasSrc1, ?, 0);
  bits<9> src2 = !if(HasSrc2, ?, 0);
}

class VOP3DisableModFields <bit HasSrc0Mods,
                            bit HasSrc1Mods = 0,
                            bit HasSrc2Mods = 0,
                            bit HasOutputMods = 0> {
  bits<2> src0_modifiers = !if(HasSrc0Mods, ?, 0);
  bits<2> src1_modifiers = !if(HasSrc1Mods, ?, 0);
  bits<2> src2_modifiers = !if(HasSrc2Mods, ?, 0);
  bits<2> omod = !if(HasOutputMods, ?, 0);
  bits<1> clamp = !if(HasOutputMods, ?, 0);
}

class VOP3_Pseudo <dag outs, dag ins, list<dag> pattern, string opName> :
  VOP3Common <outs, ins, "", pattern>,
  VOP <opName>,
  SIMCInstr<opName#"_e64", SISubtarget.NONE>,
  MnemonicAlias<opName#"_e64", opName> {
  let isPseudo = 1;
  let isCodeGenOnly = 1;

  field bit vdst;
  field bit src0;
}

class VOP3_Real_si <bits<9> op, dag outs, dag ins, string asm, string opName> :
  VOP3Common <outs, ins, asm, []>,
  VOP3e <op>,
  SIMCInstr<opName#"_e64", SISubtarget.SI> {
  let AssemblerPredicates = [isSICI];
}

class VOP3_Real_vi <bits<10> op, dag outs, dag ins, string asm, string opName> :
  VOP3Common <outs, ins, asm, []>,
  VOP3e_vi <op>,
  SIMCInstr <opName#"_e64", SISubtarget.VI> {
  let AssemblerPredicates = [isVI];
}

class VOP3b_Real_si <bits<9> op, dag outs, dag ins, string asm, string opName> :
  VOP3Common <outs, ins, asm, []>,
  VOP3be <op>,
  SIMCInstr<opName#"_e64", SISubtarget.SI> {
  let AssemblerPredicates = [isSICI];
}

class VOP3b_Real_vi <bits<10> op, dag outs, dag ins, string asm, string opName> :
  VOP3Common <outs, ins, asm, []>,
  VOP3be_vi <op>,
  SIMCInstr <opName#"_e64", SISubtarget.VI> {
  let AssemblerPredicates = [isVI];
}

multiclass VOP3_m <vop op, dag outs, dag ins, string asm, list<dag> pattern,
                   string opName, int NumSrcArgs, bit HasMods = 1> {

  def "" : VOP3_Pseudo <outs, ins, pattern, opName>;

  def _si : VOP3_Real_si <op.SI3, outs, ins, asm, opName>,
            VOP3DisableFields<!if(!eq(NumSrcArgs, 1), 0, 1),
                              !if(!eq(NumSrcArgs, 2), 0, 1),
                              HasMods>;
  def _vi : VOP3_Real_vi <op.VI3, outs, ins, asm, opName>,
            VOP3DisableFields<!if(!eq(NumSrcArgs, 1), 0, 1),
                              !if(!eq(NumSrcArgs, 2), 0, 1),
                              HasMods>;
}

multiclass VOP3_1_m <vop op, dag outs, dag ins, string asm,
                     list<dag> pattern, string opName, bit HasMods = 1> {

  def "" : VOP3_Pseudo <outs, ins, pattern, opName>;

  def _si : VOP3_Real_si <op.SI3, outs, ins, asm, opName>,
            VOP3DisableFields<0, 0, HasMods>;

  def _vi : VOP3_Real_vi <op.VI3, outs, ins, asm, opName>,
            VOP3DisableFields<0, 0, HasMods>;
}

multiclass VOP3SI_1_m <vop op, dag outs, dag ins, string asm,
                     list<dag> pattern, string opName, bit HasMods = 1> {

  def "" : VOP3_Pseudo <outs, ins, pattern, opName>;

  def _si : VOP3_Real_si <op.SI3, outs, ins, asm, opName>,
            VOP3DisableFields<0, 0, HasMods>;
  // No VI instruction. This class is for SI only.
}

multiclass VOP3_2_m <vop op, dag outs, dag ins, string asm,
                     list<dag> pattern, string opName, string revOp,
                     bit HasMods = 1> {

  def "" : VOP3_Pseudo <outs, ins, pattern, opName>,
           VOP2_REV<revOp#"_e64", !eq(revOp, opName)>;

  def _si : VOP3_Real_si <op.SI3, outs, ins, asm, opName>,
            VOP3DisableFields<1, 0, HasMods>;

  def _vi : VOP3_Real_vi <op.VI3, outs, ins, asm, opName>,
            VOP3DisableFields<1, 0, HasMods>;
}

multiclass VOP3SI_2_m <vop op, dag outs, dag ins, string asm,
                     list<dag> pattern, string opName, string revOp,
                     bit HasMods = 1> {

  def "" : VOP3_Pseudo <outs, ins, pattern, opName>,
           VOP2_REV<revOp#"_e64", !eq(revOp, opName)>;

  def _si : VOP3_Real_si <op.SI3, outs, ins, asm, opName>,
            VOP3DisableFields<1, 0, HasMods>;

  // No VI instruction. This class is for SI only.
}

// Two operand VOP3b instruction that may have a 3rd SGPR bool operand
// instead of an implicit VCC as in the VOP2b format.
multiclass VOP3b_2_3_m <vop op, dag outs, dag ins, string asm,
                        list<dag> pattern, string opName, string revOp,
                        bit HasMods = 1, bit useSrc2Input = 0> {
  def "" : VOP3_Pseudo <outs, ins, pattern, opName>;

  def _si : VOP3b_Real_si <op.SI3, outs, ins, asm, opName>,
            VOP3DisableFields<1, useSrc2Input, HasMods>;

  def _vi : VOP3b_Real_vi <op.VI3, outs, ins, asm, opName>,
            VOP3DisableFields<1, useSrc2Input, HasMods>;
}

multiclass VOP3_C_m <vop op, dag outs, dag ins, string asm,
                     list<dag> pattern, string opName,
                     bit HasMods, bit defExec,
                     string revOp, list<SchedReadWrite> sched> {

  def "" : VOP3_Pseudo <outs, ins, pattern, opName>,
           VOP2_REV<revOp#"_e64", !eq(revOp, opName)> {
    let Defs = !if(defExec, [EXEC], []);
    let SchedRW = sched;
  }

  def _si : VOP3_Real_si <op.SI3, outs, ins, asm, opName>,
            VOP3DisableFields<1, 0, HasMods> {
    let Defs = !if(defExec, [EXEC], []);
    let SchedRW = sched;
  }

  def _vi : VOP3_Real_vi <op.VI3, outs, ins, asm, opName>,
            VOP3DisableFields<1, 0, HasMods> {
    let Defs = !if(defExec, [EXEC], []);
    let SchedRW = sched;
  }
}

// An instruction that is VOP2 on SI and VOP3 on VI, no modifiers.
multiclass VOP2SI_3VI_m <vop3 op, string opName, dag outs, dag ins,
                         string asm, list<dag> pattern = []> {
  let isPseudo = 1, isCodeGenOnly = 1 in {
    def "" : VOPAnyCommon <outs, ins, "", pattern>,
             SIMCInstr<opName, SISubtarget.NONE>;
  }

  def _si : VOP2 <op.SI3{5-0}, outs, ins, asm, []>,
            SIMCInstr <opName, SISubtarget.SI> {
            let AssemblerPredicates = [isSICI];
  }

  def _vi : VOP3Common <outs, ins, asm, []>,
            VOP3e_vi <op.VI3>,
            VOP3DisableFields <1, 0, 0>,
            SIMCInstr <opName, SISubtarget.VI> {
            let AssemblerPredicates = [isVI];
  }
}

multiclass VOP1_Helper <vop1 op, string opName, VOPProfile p, list<dag> pat32,
                        list<dag> pat64> {

  defm _e32 : VOP1_m <op, opName, p, pat32>;

  defm _e64 : VOP3_1_m <op, p.Outs, p.Ins64, opName#p.Asm64, pat64, opName,
                        p.HasModifiers>;
}

multiclass VOP1Inst <vop1 op, string opName, VOPProfile P,
                     SDPatternOperator node = null_frag> : VOP1_Helper <
  op, opName, P, [],
  !if(P.HasModifiers,
      [(set P.DstVT:$dst, (node (P.Src0VT (VOP3Mods0 P.Src0VT:$src0,
                                i32:$src0_modifiers, i1:$clamp, i32:$omod))))],
      [(set P.DstVT:$dst, (node P.Src0VT:$src0))])
>;

multiclass VOP1InstSI <vop1 op, string opName, VOPProfile P,
                       SDPatternOperator node = null_frag> {

  defm _e32 : VOP1SI_m <op, opName, P, []>;

  defm _e64 : VOP3SI_1_m <op, P.Outs, P.Ins64, opName#P.Asm64,
    !if(P.HasModifiers,
      [(set P.DstVT:$dst, (node (P.Src0VT (VOP3Mods0 P.Src0VT:$src0,
                                i32:$src0_modifiers, i1:$clamp, i32:$omod))))],
      [(set P.DstVT:$dst, (node P.Src0VT:$src0))]),
    opName, P.HasModifiers>;
}

multiclass VOP2_Helper <vop2 op, string opName, VOPProfile p, list<dag> pat32,
                        list<dag> pat64, string revOp> {

  defm _e32 : VOP2_m <op, opName, p, pat32, revOp>;

  defm _e64 : VOP3_2_m <op, p.Outs, p.Ins64, opName#p.Asm64, pat64, opName,
                        revOp, p.HasModifiers>;
}

multiclass VOP2Inst <vop2 op, string opName, VOPProfile P,
                     SDPatternOperator node = null_frag,
                     string revOp = opName> : VOP2_Helper <
  op, opName, P, [],
  !if(P.HasModifiers,
      [(set P.DstVT:$dst,
           (node (P.Src0VT (VOP3Mods0 P.Src0VT:$src0, i32:$src0_modifiers,
                                      i1:$clamp, i32:$omod)),
                 (P.Src1VT (VOP3Mods P.Src1VT:$src1, i32:$src1_modifiers))))],
      [(set P.DstVT:$dst, (node P.Src0VT:$src0, P.Src1VT:$src1))]),
  revOp
>;

multiclass VOP2InstSI <vop2 op, string opName, VOPProfile P,
                       SDPatternOperator node = null_frag,
                       string revOp = opName> {

  defm _e32 : VOP2SI_m <op, opName, P, [], revOp>;

  defm _e64 : VOP3SI_2_m <op, P.Outs, P.Ins64, opName#P.Asm64,
    !if(P.HasModifiers,
        [(set P.DstVT:$dst,
             (node (P.Src0VT (VOP3Mods0 P.Src0VT:$src0, i32:$src0_modifiers,
                                        i1:$clamp, i32:$omod)),
                   (P.Src1VT (VOP3Mods P.Src1VT:$src1, i32:$src1_modifiers))))],
        [(set P.DstVT:$dst, (node P.Src0VT:$src0, P.Src1VT:$src1))]),
    opName, revOp, P.HasModifiers>;
}

multiclass VOP2b_Helper <vop2 op, string opName, VOPProfile p,
                         list<dag> pat32, list<dag> pat64,
                         string revOp, bit useSGPRInput> {

  let SchedRW = [Write32Bit, WriteSALU] in {
    let Uses = !if(useSGPRInput, [VCC, EXEC], [EXEC]), Defs = [VCC] in {
      defm _e32 : VOP2_m <op, opName, p, pat32, revOp>;
    }

    defm _e64 : VOP3b_2_3_m <op, p.Outs64, p.Ins64, opName#p.Asm64, pat64,
                             opName, revOp, p.HasModifiers, useSGPRInput>;
  }
}

multiclass VOP2bInst <vop2 op, string opName, VOPProfile P,
                      SDPatternOperator node = null_frag,
                      string revOp = opName> : VOP2b_Helper <
  op, opName, P, [],
  !if(P.HasModifiers,
      [(set P.DstVT:$dst,
           (node (P.Src0VT (VOP3Mods0 P.Src0VT:$src0, i32:$src0_modifiers,
                                      i1:$clamp, i32:$omod)),
                 (P.Src1VT (VOP3Mods P.Src1VT:$src1, i32:$src1_modifiers))))],
      [(set P.DstVT:$dst, (node P.Src0VT:$src0, P.Src1VT:$src1))]),
  revOp, !eq(P.NumSrcArgs, 3)
>;

// A VOP2 instruction that is VOP3-only on VI.
multiclass VOP2_VI3_Helper <vop23 op, string opName, VOPProfile p,
                            list<dag> pat32, list<dag> pat64, string revOp> {

  defm _e32 : VOP2SI_m <op, opName, p, pat32, revOp>;

  defm _e64 : VOP3_2_m <op, p.Outs, p.Ins64, opName#p.Asm64, pat64, opName,
                        revOp, p.HasModifiers>;
}

multiclass VOP2_VI3_Inst <vop23 op, string opName, VOPProfile P,
                          SDPatternOperator node = null_frag,
                          string revOp = opName>
                          : VOP2_VI3_Helper <
  op, opName, P, [],
  !if(P.HasModifiers,
      [(set P.DstVT:$dst,
           (node (P.Src0VT (VOP3Mods0 P.Src0VT:$src0, i32:$src0_modifiers,
                                      i1:$clamp, i32:$omod)),
                 (P.Src1VT (VOP3Mods P.Src1VT:$src1, i32:$src1_modifiers))))],
      [(set P.DstVT:$dst, (node P.Src0VT:$src0, P.Src1VT:$src1))]),
  revOp
>;

multiclass VOP2MADK <vop2 op, string opName, list<dag> pattern = []> {

  def "" : VOP2_Pseudo <VOP_MADK.Outs, VOP_MADK.Ins, pattern, opName>;

let isCodeGenOnly = 0 in {
  def _si : VOP2Common <VOP_MADK.Outs, VOP_MADK.Ins,
                        !strconcat(opName, VOP_MADK.Asm), []>,
            SIMCInstr <opName#"_e32", SISubtarget.SI>,
            VOP2_MADKe <op.SI> {
            let AssemblerPredicates = [isSICI];
            }

  def _vi : VOP2Common <VOP_MADK.Outs, VOP_MADK.Ins,
                        !strconcat(opName, VOP_MADK.Asm), []>,
            SIMCInstr <opName#"_e32", SISubtarget.VI>,
            VOP2_MADKe <op.VI> {
            let AssemblerPredicates = [isVI];
            }
} // End isCodeGenOnly = 0
}

class VOPC_Pseudo <dag ins, list<dag> pattern, string opName> :
  VOPCCommon <ins, "", pattern>,
  VOP <opName>,
  SIMCInstr<opName#"_e32", SISubtarget.NONE> {
  let isPseudo = 1;
  let isCodeGenOnly = 1;
}

multiclass VOPC_m <vopc op, dag ins, string op_asm, list<dag> pattern,
                   string opName, bit DefExec, VOPProfile p,
                   list<SchedReadWrite> sched,
                   string revOpName = "", string asm = opName#"_e32 "#op_asm,
                   string alias_asm = opName#" "#op_asm> {
  def "" : VOPC_Pseudo <ins, pattern, opName>,
           VOP2_REV<revOpName#"_e32", !eq(revOpName, opName)> {
    let Defs = !if(DefExec, [VCC, EXEC], [VCC]);
    let SchedRW = sched;
  }

  let AssemblerPredicates = [isSICI] in {
    def _si : VOPC<op.SI, ins, asm, []>,
              SIMCInstr <opName#"_e32", SISubtarget.SI> {
      let Defs = !if(DefExec, [VCC, EXEC], [VCC]);
      let hasSideEffects = DefExec;
      let SchedRW = sched;
    }

  } // End AssemblerPredicates = [isSICI]

  let AssemblerPredicates = [isVI] in {
    def _vi : VOPC<op.VI, ins, asm, []>,
              SIMCInstr <opName#"_e32", SISubtarget.VI> {
      let Defs = !if(DefExec, [VCC, EXEC], [VCC]);
      let hasSideEffects = DefExec;
      let SchedRW = sched;
    }

  } // End AssemblerPredicates = [isVI]

  defm : SIInstAliasBuilder<alias_asm, p>;
}

multiclass VOPC_Helper <vopc op, string opName, list<dag> pat32,
                        list<dag> pat64, bit DefExec, string revOp,
                        VOPProfile p, list<SchedReadWrite> sched> {
  defm _e32 : VOPC_m <op, p.Ins32, p.Asm32, pat32, opName, DefExec, p, sched,
                      revOp>;

  defm _e64 : VOP3_C_m <op, (outs VOPDstS64:$dst), p.Ins64, opName#p.Asm64, pat64,
                        opName, p.HasModifiers, DefExec, revOp, sched>;
}

// Special case for class instructions which only have modifiers on
// the 1st source operand.
multiclass VOPC_Class_Helper <vopc op, string opName, list<dag> pat32,
                              list<dag> pat64, bit DefExec, string revOp,
                              VOPProfile p, list<SchedReadWrite> sched> {
  defm _e32 : VOPC_m <op, p.Ins32, p.Asm32, pat32, opName, DefExec, p, sched>;

  defm _e64 : VOP3_C_m <op, (outs VOPDstS64:$dst), p.Ins64, opName#p.Asm64, pat64,
                        opName, p.HasModifiers, DefExec, revOp, sched>,
                        VOP3DisableModFields<1, 0, 0>;
}

multiclass VOPCInst <vopc op, string opName,
                     VOPProfile P, PatLeaf cond = COND_NULL,
                     string revOp = opName,
                     bit DefExec = 0,
                     list<SchedReadWrite> sched = [Write32Bit]> :
                     VOPC_Helper <
  op, opName, [],
  !if(P.HasModifiers,
      [(set i1:$dst,
          (setcc (P.Src0VT (VOP3Mods0 P.Src0VT:$src0, i32:$src0_modifiers,
                                      i1:$clamp, i32:$omod)),
                 (P.Src1VT (VOP3Mods P.Src1VT:$src1, i32:$src1_modifiers)),
                 cond))],
      [(set i1:$dst, (setcc P.Src0VT:$src0, P.Src1VT:$src1, cond))]),
  DefExec, revOp, P, sched
>;

multiclass VOPCClassInst <vopc op, string opName, VOPProfile P,
                     bit DefExec = 0,
                     list<SchedReadWrite> sched> : VOPC_Class_Helper <
  op, opName, [],
  !if(P.HasModifiers,
      [(set i1:$dst,
          (AMDGPUfp_class (P.Src0VT (VOP3Mods0Clamp0OMod P.Src0VT:$src0, i32:$src0_modifiers)), P.Src1VT:$src1))],
      [(set i1:$dst, (AMDGPUfp_class P.Src0VT:$src0, P.Src1VT:$src1))]),
  DefExec, opName, P, sched
>;


multiclass VOPC_F32 <vopc op, string opName, PatLeaf cond = COND_NULL, string revOp = opName> :
  VOPCInst <op, opName, VOPC_I1_F32_F32, cond, revOp>;

multiclass VOPC_F64 <vopc op, string opName, PatLeaf cond = COND_NULL, string revOp = opName> :
  VOPCInst <op, opName, VOPC_I1_F64_F64, cond, revOp, 0, [WriteDoubleAdd]>;

multiclass VOPC_I32 <vopc op, string opName, PatLeaf cond = COND_NULL, string revOp = opName> :
  VOPCInst <op, opName, VOPC_I1_I32_I32, cond, revOp>;

multiclass VOPC_I64 <vopc op, string opName, PatLeaf cond = COND_NULL, string revOp = opName> :
  VOPCInst <op, opName, VOPC_I1_I64_I64, cond, revOp, 0, [Write64Bit]>;


multiclass VOPCX <vopc op, string opName, VOPProfile P,
                  PatLeaf cond = COND_NULL,
                  list<SchedReadWrite> sched,
                  string revOp = "">
  : VOPCInst <op, opName, P, cond, revOp, 1, sched>;

multiclass VOPCX_F32 <vopc op, string opName, string revOp = opName> :
  VOPCX <op, opName, VOPC_I1_F32_F32, COND_NULL, [Write32Bit], revOp>;

multiclass VOPCX_F64 <vopc op, string opName, string revOp = opName> :
  VOPCX <op, opName, VOPC_I1_F64_F64, COND_NULL, [WriteDoubleAdd], revOp>;

multiclass VOPCX_I32 <vopc op, string opName, string revOp = opName> :
  VOPCX <op, opName, VOPC_I1_I32_I32, COND_NULL, [Write32Bit], revOp>;

multiclass VOPCX_I64 <vopc op, string opName, string revOp = opName> :
  VOPCX <op, opName, VOPC_I1_I64_I64, COND_NULL, [Write64Bit], revOp>;

multiclass VOP3_Helper <vop3 op, string opName, dag outs, dag ins, string asm,
                        list<dag> pat, int NumSrcArgs, bit HasMods> : VOP3_m <
    op, outs, ins, opName#" "#asm, pat, opName, NumSrcArgs, HasMods
>;

multiclass VOPC_CLASS_F32 <vopc op, string opName> :
  VOPCClassInst <op, opName, VOPC_I1_F32_I32, 0, [Write32Bit]>;

multiclass VOPCX_CLASS_F32 <vopc op, string opName> :
  VOPCClassInst <op, opName, VOPC_I1_F32_I32, 1, [Write32Bit]>;

multiclass VOPC_CLASS_F64 <vopc op, string opName> :
  VOPCClassInst <op, opName, VOPC_I1_F64_I32, 0, [WriteDoubleAdd]>;

multiclass VOPCX_CLASS_F64 <vopc op, string opName> :
  VOPCClassInst <op, opName, VOPC_I1_F64_I32, 1, [WriteDoubleAdd]>;

multiclass VOP3Inst <vop3 op, string opName, VOPProfile P,
                     SDPatternOperator node = null_frag> : VOP3_Helper <
  op, opName, (outs P.DstRC.RegClass:$dst), P.Ins64, P.Asm64,
  !if(!eq(P.NumSrcArgs, 3),
    !if(P.HasModifiers,
        [(set P.DstVT:$dst,
            (node (P.Src0VT (VOP3Mods0 P.Src0VT:$src0, i32:$src0_modifiers,
                                       i1:$clamp, i32:$omod)),
                  (P.Src1VT (VOP3Mods P.Src1VT:$src1, i32:$src1_modifiers)),
                  (P.Src2VT (VOP3Mods P.Src2VT:$src2, i32:$src2_modifiers))))],
        [(set P.DstVT:$dst, (node P.Src0VT:$src0, P.Src1VT:$src1,
                                  P.Src2VT:$src2))]),
  !if(!eq(P.NumSrcArgs, 2),
    !if(P.HasModifiers,
        [(set P.DstVT:$dst,
            (node (P.Src0VT (VOP3Mods0 P.Src0VT:$src0, i32:$src0_modifiers,
                                       i1:$clamp, i32:$omod)),
                  (P.Src1VT (VOP3Mods P.Src1VT:$src1, i32:$src1_modifiers))))],
        [(set P.DstVT:$dst, (node P.Src0VT:$src0, P.Src1VT:$src1))])
  /* P.NumSrcArgs == 1 */,
    !if(P.HasModifiers,
        [(set P.DstVT:$dst,
            (node (P.Src0VT (VOP3Mods0 P.Src0VT:$src0, i32:$src0_modifiers,
                                       i1:$clamp, i32:$omod))))],
        [(set P.DstVT:$dst, (node P.Src0VT:$src0))]))),
  P.NumSrcArgs, P.HasModifiers
>;

// Special case for v_div_fmas_{f32|f64}, since it seems to be the
// only VOP instruction that implicitly reads VCC.
multiclass VOP3_VCC_Inst <vop3 op, string opName,
                          VOPProfile P,
                          SDPatternOperator node = null_frag> : VOP3_Helper <
  op, opName,
  (outs P.DstRC.RegClass:$dst),
  (ins InputModsNoDefault:$src0_modifiers, P.Src0RC64:$src0,
       InputModsNoDefault:$src1_modifiers, P.Src1RC64:$src1,
       InputModsNoDefault:$src2_modifiers, P.Src2RC64:$src2,
       ClampMod:$clamp,
       omod:$omod),
  "$dst, $src0_modifiers, $src1_modifiers, $src2_modifiers"#"$clamp"#"$omod",
  [(set P.DstVT:$dst,
            (node (P.Src0VT (VOP3Mods0 P.Src0VT:$src0, i32:$src0_modifiers,
                                       i1:$clamp, i32:$omod)),
                  (P.Src1VT (VOP3Mods P.Src1VT:$src1, i32:$src1_modifiers)),
                  (P.Src2VT (VOP3Mods P.Src2VT:$src2, i32:$src2_modifiers)),
                  (i1 VCC)))],
  3, 1
>;

multiclass VOP3bInst <vop op, string opName, VOPProfile P, list<dag> pattern = []> :
  VOP3b_2_3_m <
  op, P.Outs64, P.Ins64,
  opName#" "#P.Asm64, pattern,
  opName, "", 1, 1
>;

class Vop3ModPat<Instruction Inst, VOPProfile P, SDPatternOperator node> : Pat<
  (node (P.Src0VT (VOP3Mods0 P.Src0VT:$src0, i32:$src0_modifiers, i1:$clamp, i32:$omod)),
        (P.Src1VT (VOP3Mods P.Src1VT:$src1, i32:$src1_modifiers)),
        (P.Src2VT (VOP3Mods P.Src2VT:$src2, i32:$src2_modifiers))),
  (Inst i32:$src0_modifiers, P.Src0VT:$src0,
        i32:$src1_modifiers, P.Src1VT:$src1,
        i32:$src2_modifiers, P.Src2VT:$src2,
        i1:$clamp,
        i32:$omod)>;

//===----------------------------------------------------------------------===//
// Interpolation opcodes
//===----------------------------------------------------------------------===//

class VINTRP_Pseudo <string opName, dag outs, dag ins, list<dag> pattern> :
  VINTRPCommon <outs, ins, "", pattern>,
  SIMCInstr<opName, SISubtarget.NONE> {
  let isPseudo = 1;
  let isCodeGenOnly = 1;
}

class VINTRP_Real_si <bits <2> op, string opName, dag outs, dag ins,
                      string asm> :
  VINTRPCommon <outs, ins, asm, []>,
  VINTRPe <op>,
  SIMCInstr<opName, SISubtarget.SI>;

class VINTRP_Real_vi <bits <2> op, string opName, dag outs, dag ins,
                      string asm> :
  VINTRPCommon <outs, ins, asm, []>,
  VINTRPe_vi <op>,
  SIMCInstr<opName, SISubtarget.VI>;

multiclass VINTRP_m <bits <2> op, dag outs, dag ins, string asm,
                     list<dag> pattern = []> {
  def "" : VINTRP_Pseudo <NAME, outs, ins, pattern>;

  def _si : VINTRP_Real_si <op, NAME, outs, ins, asm>;

  def _vi : VINTRP_Real_vi <op, NAME, outs, ins, asm>;
}

//===----------------------------------------------------------------------===//
// Vector I/O classes
//===----------------------------------------------------------------------===//

class DS_Pseudo <string opName, dag outs, dag ins, list<dag> pattern> :
  DS <outs, ins, "", pattern>,
  SIMCInstr <opName, SISubtarget.NONE> {
  let isPseudo = 1;
  let isCodeGenOnly = 1;
}

class DS_Real_si <bits<8> op, string opName, dag outs, dag ins, string asm> :
  DS <outs, ins, asm, []>,
  DSe <op>,
  SIMCInstr <opName, SISubtarget.SI> {
  let isCodeGenOnly = 0;
}

class DS_Real_vi <bits<8> op, string opName, dag outs, dag ins, string asm> :
  DS <outs, ins, asm, []>,
  DSe_vi <op>,
  SIMCInstr <opName, SISubtarget.VI>;

class DS_Off16_Real_si <bits<8> op, string opName, dag outs, dag ins, string asm> :
  DS_Real_si <op,opName, outs, ins, asm> {

  // Single load interpret the 2 i8imm operands as a single i16 offset.
  bits<16> offset;
  let offset0 = offset{7-0};
  let offset1 = offset{15-8};
  let isCodeGenOnly = 0;
}

class DS_Off16_Real_vi <bits<8> op, string opName, dag outs, dag ins, string asm> :
  DS_Real_vi <op, opName, outs, ins, asm> {

  // Single load interpret the 2 i8imm operands as a single i16 offset.
  bits<16> offset;
  let offset0 = offset{7-0};
  let offset1 = offset{15-8};
}

multiclass DS_1A_RET <bits<8> op, string opName, RegisterClass rc,
  dag outs = (outs rc:$vdst),
  dag ins = (ins VGPR_32:$addr, ds_offset:$offset, gds:$gds),
  string asm = opName#" $vdst, $addr"#"$offset$gds"> {

  def "" : DS_Pseudo <opName, outs, ins, []>;

  let data0 = 0, data1 = 0 in {
    def _si : DS_Off16_Real_si <op, opName, outs, ins, asm>;
    def _vi : DS_Off16_Real_vi <op, opName, outs, ins, asm>;
  }
}

multiclass DS_1A_Off8_RET <bits<8> op, string opName, RegisterClass rc,
  dag outs = (outs rc:$vdst),
  dag ins = (ins VGPR_32:$addr, ds_offset0:$offset0, ds_offset1:$offset1,
                 gds01:$gds),
  string asm = opName#" $vdst, $addr"#"$offset0"#"$offset1$gds"> {

  def "" : DS_Pseudo <opName, outs, ins, []>;

  let data0 = 0, data1 = 0, AsmMatchConverter = "cvtDSOffset01" in {
    def _si : DS_Real_si <op, opName, outs, ins, asm>;
    def _vi : DS_Real_vi <op, opName, outs, ins, asm>;
  }
}

multiclass DS_1A1D_NORET <bits<8> op, string opName, RegisterClass rc,
  dag outs = (outs),
  dag ins = (ins VGPR_32:$addr, rc:$data0, ds_offset:$offset, gds:$gds),
  string asm = opName#" $addr, $data0"#"$offset$gds"> {

  def "" : DS_Pseudo <opName, outs, ins, []>,
           AtomicNoRet<opName, 0>;

  let data1 = 0, vdst = 0 in {
    def _si : DS_Off16_Real_si <op, opName, outs, ins, asm>;
    def _vi : DS_Off16_Real_vi <op, opName, outs, ins, asm>;
  }
}

multiclass DS_1A1D_Off8_NORET <bits<8> op, string opName, RegisterClass rc,
  dag outs = (outs),
  dag ins = (ins VGPR_32:$addr, rc:$data0, rc:$data1,
              ds_offset0:$offset0, ds_offset1:$offset1, gds01:$gds),
  string asm = opName#" $addr, $data0, $data1"#"$offset0"#"$offset1"#"$gds"> {

  def "" : DS_Pseudo <opName, outs, ins, []>;

  let vdst = 0, AsmMatchConverter = "cvtDSOffset01" in {
    def _si : DS_Real_si <op, opName, outs, ins, asm>;
    def _vi : DS_Real_vi <op, opName, outs, ins, asm>;
  }
}

multiclass DS_1A1D_RET <bits<8> op, string opName, RegisterClass rc,
                        string noRetOp = "",
  dag outs = (outs rc:$vdst),
  dag ins = (ins VGPR_32:$addr, rc:$data0, ds_offset:$offset, gds:$gds),
  string asm = opName#" $vdst, $addr, $data0"#"$offset$gds"> {

  let hasPostISelHook = 1 in {
    def "" : DS_Pseudo <opName, outs, ins, []>,
             AtomicNoRet<noRetOp, 1>;

    let data1 = 0 in {
      def _si : DS_Off16_Real_si <op, opName, outs, ins, asm>;
      def _vi : DS_Off16_Real_vi <op, opName, outs, ins, asm>;
    }
  }
}

multiclass DS_1A2D_RET_m <bits<8> op, string opName, RegisterClass rc,
                          string noRetOp = "", dag ins,
  dag outs = (outs rc:$vdst),
  string asm = opName#" $vdst, $addr, $data0, $data1"#"$offset"#"$gds"> {

  let hasPostISelHook = 1 in {
    def "" : DS_Pseudo <opName, outs, ins, []>,
             AtomicNoRet<noRetOp, 1>;

    def _si : DS_Off16_Real_si <op, opName, outs, ins, asm>;
    def _vi : DS_Off16_Real_vi <op, opName, outs, ins, asm>;
  }
}

multiclass DS_1A2D_RET <bits<8> op, string asm, RegisterClass rc,
                        string noRetOp = "", RegisterClass src = rc> :
  DS_1A2D_RET_m <op, asm, rc, noRetOp,
                 (ins VGPR_32:$addr, src:$data0, src:$data1,
                      ds_offset:$offset, gds:$gds)
>;

multiclass DS_1A2D_NORET <bits<8> op, string opName, RegisterClass rc,
                          string noRetOp = opName,
  dag outs = (outs),
  dag ins = (ins VGPR_32:$addr, rc:$data0, rc:$data1,
                 ds_offset:$offset, gds:$gds),
  string asm = opName#" $addr, $data0, $data1"#"$offset"#"$gds"> {

  def "" : DS_Pseudo <opName, outs, ins, []>,
           AtomicNoRet<noRetOp, 0>;

  let vdst = 0 in {
    def _si : DS_Off16_Real_si <op, opName, outs, ins, asm>;
    def _vi : DS_Off16_Real_vi <op, opName, outs, ins, asm>;
  }
}

multiclass DS_0A_RET <bits<8> op, string opName,
  dag outs = (outs VGPR_32:$vdst),
  dag ins = (ins ds_offset:$offset, gds:$gds),
  string asm = opName#" $vdst"#"$offset"#"$gds"> {

  let mayLoad = 1, mayStore = 1 in {
    def "" : DS_Pseudo <opName, outs, ins, []>;

    let addr = 0, data0 = 0, data1 = 0 in {
      def _si : DS_Off16_Real_si <op, opName, outs, ins, asm>;
      def _vi : DS_Off16_Real_vi <op, opName, outs, ins, asm>;
    } // end addr = 0, data0 = 0, data1 = 0
  } // end mayLoad = 1, mayStore = 1
}

multiclass DS_1A_RET_GDS <bits<8> op, string opName,
  dag outs = (outs VGPR_32:$vdst),
  dag ins = (ins VGPR_32:$addr, ds_offset_gds:$offset),
  string asm = opName#" $vdst, $addr"#"$offset gds"> {

  def "" : DS_Pseudo <opName, outs, ins, []>;

  let data0 = 0, data1 = 0, gds = 1 in {
    def _si : DS_Off16_Real_si <op, opName, outs, ins, asm>;
    def _vi : DS_Off16_Real_vi <op, opName, outs, ins, asm>;
  } // end data0 = 0, data1 = 0, gds = 1
}

multiclass DS_1A_GDS <bits<8> op, string opName,
  dag outs = (outs),
  dag ins = (ins VGPR_32:$addr),
  string asm = opName#" $addr gds"> {

  def "" : DS_Pseudo <opName, outs, ins, []>;

  let vdst = 0, data0 = 0, data1 = 0, offset0 = 0, offset1 = 0, gds = 1 in {
    def _si : DS_Real_si <op, opName, outs, ins, asm>;
    def _vi : DS_Real_vi <op, opName, outs, ins, asm>;
  } // end vdst = 0, data = 0, data1 = 0, gds = 1
}

multiclass DS_1A <bits<8> op, string opName,
  dag outs = (outs),
  dag ins = (ins VGPR_32:$addr, ds_offset:$offset, gds:$gds),
  string asm = opName#" $addr"#"$offset"#"$gds"> {

  let mayLoad = 1, mayStore = 1 in {
    def "" : DS_Pseudo <opName, outs, ins, []>;

    let vdst = 0, data0 = 0, data1 = 0 in {
      def _si : DS_Off16_Real_si <op, opName, outs, ins, asm>;
      def _vi : DS_Off16_Real_vi <op, opName, outs, ins, asm>;
    } // let vdst = 0, data0 = 0, data1 = 0
  } // end mayLoad = 1, mayStore = 1
}

//===----------------------------------------------------------------------===//
// MTBUF classes
//===----------------------------------------------------------------------===//

class MTBUF_Pseudo <string opName, dag outs, dag ins, list<dag> pattern> :
  MTBUF <outs, ins, "", pattern>,
  SIMCInstr<opName, SISubtarget.NONE> {
  let isPseudo = 1;
  let isCodeGenOnly = 1;
}

class MTBUF_Real_si <bits<3> op, string opName, dag outs, dag ins,
                    string asm> :
  MTBUF <outs, ins, asm, []>,
  MTBUFe <op>,
  SIMCInstr<opName, SISubtarget.SI>;

class MTBUF_Real_vi <bits<4> op, string opName, dag outs, dag ins, string asm> :
  MTBUF <outs, ins, asm, []>,
  MTBUFe_vi <op>,
  SIMCInstr <opName, SISubtarget.VI>;

multiclass MTBUF_m <bits<3> op, string opName, dag outs, dag ins, string asm,
                    list<dag> pattern> {

  def "" : MTBUF_Pseudo <opName, outs, ins, pattern>;

  def _si : MTBUF_Real_si <op, opName, outs, ins, asm>;

  def _vi : MTBUF_Real_vi <{0, op{2}, op{1}, op{0}}, opName, outs, ins, asm>;

}

let mayStore = 1, mayLoad = 0 in {

multiclass MTBUF_Store_Helper <bits<3> op, string opName,
                               RegisterClass regClass> : MTBUF_m <
  op, opName, (outs),
  (ins regClass:$vdata, u16imm:$offset, i1imm:$offen, i1imm:$idxen, i1imm:$glc,
   i1imm:$addr64, i8imm:$dfmt, i8imm:$nfmt, VGPR_32:$vaddr,
   SReg_128:$srsrc, i1imm:$slc, i1imm:$tfe, SCSrc_32:$soffset),
  opName#" $vdata, $offset, $offen, $idxen, $glc, $addr64, $dfmt,"
        #" $nfmt, $vaddr, $srsrc, $slc, $tfe, $soffset", []
>;

} // mayStore = 1, mayLoad = 0

let mayLoad = 1, mayStore = 0 in {

multiclass MTBUF_Load_Helper <bits<3> op, string opName,
                              RegisterClass regClass> : MTBUF_m <
  op, opName, (outs regClass:$dst),
  (ins u16imm:$offset, i1imm:$offen, i1imm:$idxen, i1imm:$glc, i1imm:$addr64,
       i8imm:$dfmt, i8imm:$nfmt, VGPR_32:$vaddr, SReg_128:$srsrc,
       i1imm:$slc, i1imm:$tfe, SCSrc_32:$soffset),
  opName#" $dst, $offset, $offen, $idxen, $glc, $addr64, $dfmt,"
        #" $nfmt, $vaddr, $srsrc, $slc, $tfe, $soffset", []
>;

} // mayLoad = 1, mayStore = 0

//===----------------------------------------------------------------------===//
// MUBUF classes
//===----------------------------------------------------------------------===//

class mubuf <bits<7> si, bits<7> vi = si> {
  field bits<7> SI = si;
  field bits<7> VI = vi;
}

let isCodeGenOnly = 0 in {

class MUBUF_si <bits<7> op, dag outs, dag ins, string asm, list<dag> pattern> :
  MUBUF <outs, ins, asm, pattern>, MUBUFe <op> {
  let lds  = 0;
}

} // End let isCodeGenOnly = 0

class MUBUF_vi <bits<7> op, dag outs, dag ins, string asm, list<dag> pattern> :
  MUBUF <outs, ins, asm, pattern>, MUBUFe_vi <op> {
  let lds = 0;
}

class MUBUFAddr64Table <bit is_addr64, string suffix = ""> {
  bit IsAddr64 = is_addr64;
  string OpName = NAME # suffix;
}

class MUBUF_Pseudo <string opName, dag outs, dag ins, list<dag> pattern> :
  MUBUF <outs, ins, "", pattern>,
  SIMCInstr<opName, SISubtarget.NONE> {
  let isPseudo = 1;
  let isCodeGenOnly = 1;

  // dummy fields, so that we can use let statements around multiclasses
  bits<1> offen;
  bits<1> idxen;
  bits<8> vaddr;
  bits<1> glc;
  bits<1> slc;
  bits<1> tfe;
  bits<8> soffset;
}

class MUBUF_Real_si <mubuf op, string opName, dag outs, dag ins,
                     string asm> :
  MUBUF <outs, ins, asm, []>,
  MUBUFe <op.SI>,
  SIMCInstr<opName, SISubtarget.SI> {
  let lds = 0;
}

class MUBUF_Real_vi <mubuf op, string opName, dag outs, dag ins,
                     string asm> :
  MUBUF <outs, ins, asm, []>,
  MUBUFe_vi <op.VI>,
  SIMCInstr<opName, SISubtarget.VI> {
  let lds = 0;
}

multiclass MUBUF_m <mubuf op, string opName, dag outs, dag ins, string asm,
                    list<dag> pattern> {

  def "" : MUBUF_Pseudo <opName, outs, ins, pattern>,
           MUBUFAddr64Table <0>;

  let addr64 = 0, isCodeGenOnly = 0 in {
    def _si : MUBUF_Real_si <op, opName, outs, ins, asm>;
  }

  def _vi : MUBUF_Real_vi <op, opName, outs, ins, asm>;
}

multiclass MUBUFAddr64_m <mubuf op, string opName, dag outs,
                          dag ins, string asm, list<dag> pattern> {

  def "" : MUBUF_Pseudo <opName, outs, ins, pattern>,
           MUBUFAddr64Table <1>;

  let addr64 = 1, isCodeGenOnly = 0 in {
    def _si : MUBUF_Real_si <op, opName, outs, ins, asm>;
  }

  // There is no VI version. If the pseudo is selected, it should be lowered
  // for VI appropriately.
}

multiclass MUBUFAtomicOffset_m <mubuf op, string opName, dag outs, dag ins,
                                string asm, list<dag> pattern, bit is_return> {

  def "" : MUBUF_Pseudo <opName, outs, ins, pattern>,
           MUBUFAddr64Table <0, !if(is_return, "_RTN", "")>,
           AtomicNoRet<NAME#"_OFFSET", is_return>;

  let offen = 0, idxen = 0, tfe = 0, vaddr = 0 in {
    let addr64 = 0 in {
      def _si : MUBUF_Real_si <op, opName, outs, ins, asm>;
    }

    def _vi : MUBUF_Real_vi <op, opName, outs, ins, asm>;
  }
}

multiclass MUBUFAtomicAddr64_m <mubuf op, string opName, dag outs, dag ins,
                                string asm, list<dag> pattern, bit is_return> {

  def "" : MUBUF_Pseudo <opName, outs, ins, pattern>,
           MUBUFAddr64Table <1, !if(is_return, "_RTN", "")>,
           AtomicNoRet<NAME#"_ADDR64", is_return>;

  let offen = 0, idxen = 0, addr64 = 1, tfe = 0 in {
    def _si : MUBUF_Real_si <op, opName, outs, ins, asm>;
  }

  // There is no VI version. If the pseudo is selected, it should be lowered
  // for VI appropriately.
}

multiclass MUBUF_Atomic <mubuf op, string name, RegisterClass rc,
                         ValueType vt, SDPatternOperator atomic> {

  let mayStore = 1, mayLoad = 1, hasPostISelHook = 1 in {

    // No return variants
    let glc = 0 in {

      defm _ADDR64 : MUBUFAtomicAddr64_m <
        op, name#"_addr64", (outs),
        (ins rc:$vdata, VReg_64:$vaddr, SReg_128:$srsrc,
             SCSrc_32:$soffset, mbuf_offset:$offset, slc:$slc),
        name#" $vdata, $vaddr, $srsrc, $soffset addr64"#"$offset"#"$slc", [], 0
      >;

      defm _OFFSET : MUBUFAtomicOffset_m <
        op, name#"_offset", (outs),
        (ins rc:$vdata, SReg_128:$srsrc, SCSrc_32:$soffset, mbuf_offset:$offset,
             slc:$slc),
        name#" $vdata, $srsrc, $soffset"#"$offset"#"$slc", [], 0
      >;
    } // glc = 0

    // Variant that return values
    let glc = 1, Constraints = "$vdata = $vdata_in",
        DisableEncoding = "$vdata_in"  in {

      defm _RTN_ADDR64 : MUBUFAtomicAddr64_m <
        op, name#"_rtn_addr64", (outs rc:$vdata),
        (ins rc:$vdata_in, VReg_64:$vaddr, SReg_128:$srsrc,
             SCSrc_32:$soffset, mbuf_offset:$offset, slc:$slc),
        name#" $vdata, $vaddr, $srsrc, $soffset addr64"#"$offset"#" glc"#"$slc",
        [(set vt:$vdata,
         (atomic (MUBUFAddr64Atomic v4i32:$srsrc, i64:$vaddr, i32:$soffset,
	                            i16:$offset, i1:$slc), vt:$vdata_in))], 1
      >;

      defm _RTN_OFFSET : MUBUFAtomicOffset_m <
        op, name#"_rtn_offset", (outs rc:$vdata),
        (ins rc:$vdata_in, SReg_128:$srsrc, SCSrc_32:$soffset,
             mbuf_offset:$offset, slc:$slc),
        name#" $vdata, $srsrc, $soffset"#"$offset"#" glc$slc",
        [(set vt:$vdata,
         (atomic (MUBUFOffsetAtomic v4i32:$srsrc, i32:$soffset, i16:$offset,
                                    i1:$slc), vt:$vdata_in))], 1
      >;

    } // glc = 1

  } // mayStore = 1, mayLoad = 1, hasPostISelHook = 1
}

// FIXME: tfe can't be an operand because it requires a separate
// opcode because it needs an N+1 register class dest register.
multiclass MUBUF_Load_Helper <mubuf op, string name, RegisterClass regClass,
                              ValueType load_vt = i32,
                              SDPatternOperator ld = null_frag> {

  let mayLoad = 1, mayStore = 0 in {
    let offen = 0, idxen = 0, vaddr = 0 in {
      defm _OFFSET : MUBUF_m <op, name#"_offset", (outs regClass:$vdata),
                           (ins SReg_128:$srsrc, SCSrc_32:$soffset,
                           mbuf_offset:$offset, glc:$glc, slc:$slc, tfe:$tfe),
                           name#" $vdata, $srsrc, $soffset"#"$offset"#"$glc"#"$slc"#"$tfe",
                           [(set load_vt:$vdata, (ld (MUBUFOffset v4i32:$srsrc,
                                                     i32:$soffset, i16:$offset,
                                                     i1:$glc, i1:$slc, i1:$tfe)))]>;
    }

    let offen = 1, idxen = 0  in {
      defm _OFFEN  : MUBUF_m <op, name#"_offen", (outs regClass:$vdata),
                           (ins VGPR_32:$vaddr, SReg_128:$srsrc,
                           SCSrc_32:$soffset, mbuf_offset:$offset, glc:$glc, slc:$slc,
                           tfe:$tfe),
                           name#" $vdata, $vaddr, $srsrc, $soffset offen"#"$offset"#"$glc"#"$slc"#"$tfe", []>;
    }

    let offen = 0, idxen = 1 in {
      defm _IDXEN  : MUBUF_m <op, name#"_idxen", (outs regClass:$vdata),
                           (ins VGPR_32:$vaddr, SReg_128:$srsrc,
                           SCSrc_32:$soffset, mbuf_offset:$offset, glc:$glc,
                           slc:$slc, tfe:$tfe),
                           name#" $vdata, $vaddr, $srsrc, $soffset idxen"#"$offset"#"$glc"#"$slc"#"$tfe", []>;
    }

    let offen = 1, idxen = 1 in {
      defm _BOTHEN : MUBUF_m <op, name#"_bothen", (outs regClass:$vdata),
                           (ins VReg_64:$vaddr, SReg_128:$srsrc, SCSrc_32:$soffset,
                           mbuf_offset:$offset, glc:$glc, slc:$slc, tfe:$tfe),
                           name#" $vdata, $vaddr, $srsrc, $soffset idxen offen"#"$offset"#"$glc"#"$slc"#"$tfe", []>;
    }

    let offen = 0, idxen = 0 in {
      defm _ADDR64 : MUBUFAddr64_m <op, name#"_addr64", (outs regClass:$vdata),
                           (ins VReg_64:$vaddr, SReg_128:$srsrc,
                                SCSrc_32:$soffset, mbuf_offset:$offset,
				glc:$glc, slc:$slc, tfe:$tfe),
                           name#" $vdata, $vaddr, $srsrc, $soffset addr64"#"$offset"#
                                "$glc"#"$slc"#"$tfe",
                           [(set load_vt:$vdata, (ld (MUBUFAddr64 v4i32:$srsrc,
                                                  i64:$vaddr, i32:$soffset,
                                                  i16:$offset, i1:$glc, i1:$slc,
						  i1:$tfe)))]>;
    }
  }
}

multiclass MUBUF_Store_Helper <mubuf op, string name, RegisterClass vdataClass,
                          ValueType store_vt = i32, SDPatternOperator st = null_frag> {
  let mayLoad = 0, mayStore = 1 in {
    defm : MUBUF_m <op, name, (outs),
                    (ins vdataClass:$vdata, VGPR_32:$vaddr, SReg_128:$srsrc, SCSrc_32:$soffset,
                    mbuf_offset:$offset, offen:$offen, idxen:$idxen, glc:$glc, slc:$slc,
                    tfe:$tfe),
                    name#" $vdata, $vaddr, $srsrc, $soffset"#"$offen"#"$idxen"#"$offset"#
                         "$glc"#"$slc"#"$tfe", []>;

    let offen = 0, idxen = 0, vaddr = 0 in {
      defm _OFFSET : MUBUF_m <op, name#"_offset",(outs),
                              (ins vdataClass:$vdata, SReg_128:$srsrc, SCSrc_32:$soffset,
                              mbuf_offset:$offset, glc:$glc, slc:$slc, tfe:$tfe),
                              name#" $vdata, $srsrc, $soffset"#"$offset"#"$glc"#"$slc"#"$tfe",
                              [(st store_vt:$vdata, (MUBUFOffset v4i32:$srsrc, i32:$soffset,
                                   i16:$offset, i1:$glc, i1:$slc, i1:$tfe))]>;
    } // offen = 0, idxen = 0, vaddr = 0

    let offen = 1, idxen = 0  in {
      defm _OFFEN : MUBUF_m <op, name#"_offen", (outs),
                             (ins vdataClass:$vdata, VGPR_32:$vaddr, SReg_128:$srsrc,
                              SCSrc_32:$soffset, mbuf_offset:$offset, glc:$glc,
                              slc:$slc, tfe:$tfe),
                             name#" $vdata, $vaddr, $srsrc, $soffset offen"#"$offset"#
                             "$glc"#"$slc"#"$tfe", []>;
    } // end offen = 1, idxen = 0

    let offen = 0, idxen = 1 in {
      defm _IDXEN  : MUBUF_m <op, name#"_idxen", (outs),
                           (ins vdataClass:$vdata, VGPR_32:$vaddr, SReg_128:$srsrc,
                           SCSrc_32:$soffset, mbuf_offset:$offset, glc:$glc,
                           slc:$slc, tfe:$tfe),
                           name#" $vdata, $vaddr, $srsrc, $soffset idxen"#"$offset"#"$glc"#"$slc"#"$tfe", []>;
    }

    let offen = 1, idxen = 1 in {
      defm _BOTHEN : MUBUF_m <op, name#"_bothen", (outs),
                           (ins vdataClass:$vdata, VReg_64:$vaddr, SReg_128:$srsrc, SCSrc_32:$soffset,
                           mbuf_offset:$offset, glc:$glc, slc:$slc, tfe:$tfe),
                           name#" $vdata, $vaddr, $srsrc, $soffset idxen offen"#"$offset"#"$glc"#"$slc"#"$tfe", []>;
    }

    let offen = 0, idxen = 0 in {
      defm _ADDR64 : MUBUFAddr64_m <op, name#"_addr64", (outs),
                                    (ins vdataClass:$vdata, VReg_64:$vaddr, SReg_128:$srsrc,
                                         SCSrc_32:$soffset,
                                         mbuf_offset:$offset, glc:$glc, slc:$slc,
                                         tfe:$tfe),
                                    name#" $vdata, $vaddr, $srsrc, $soffset addr64"#
                                         "$offset"#"$glc"#"$slc"#"$tfe",
                                    [(st store_vt:$vdata,
                                      (MUBUFAddr64 v4i32:$srsrc, i64:$vaddr,
                                                   i32:$soffset, i16:$offset,
                                                   i1:$glc, i1:$slc, i1:$tfe))]>;
    }
  } // End mayLoad = 0, mayStore = 1
}

// For cache invalidation instructions.
multiclass MUBUF_Invalidate <mubuf op, string opName, SDPatternOperator node> {
  let hasSideEffects = 1, mayStore = 1, AsmMatchConverter = "" in {
    def "" : MUBUF_Pseudo <opName, (outs), (ins), [(node)]>;

    // Set everything to 0.
    let offset = 0, offen = 0, idxen = 0, glc = 0, vaddr = 0,
        vdata = 0, srsrc = 0, slc = 0, tfe = 0, soffset = 0 in {
      let addr64 = 0 in {
        def _si : MUBUF_Real_si <op, opName, (outs), (ins), opName>;
      }

      def _vi : MUBUF_Real_vi <op, opName, (outs), (ins), opName>;
    }
  } // End hasSideEffects = 1, mayStore = 1, AsmMatchConverter = ""
}

//===----------------------------------------------------------------------===//
// FLAT classes
//===----------------------------------------------------------------------===//

class flat <bits<7> ci, bits<7> vi = ci> {
  field bits<7> CI = ci;
  field bits<7> VI = vi;
}

class FLAT_Pseudo <string opName, dag outs, dag ins, list<dag> pattern> :
     FLAT <0, outs, ins, "", pattern>,
      SIMCInstr<opName, SISubtarget.NONE> {
  let isPseudo = 1;
  let isCodeGenOnly = 1;
}

class FLAT_Real_ci <bits<7> op, string opName, dag outs, dag ins, string asm> :
    FLAT <op, outs, ins, asm, []>,
    SIMCInstr<opName, SISubtarget.SI> {
  let AssemblerPredicate = isCIOnly;
}

class FLAT_Real_vi <bits<7> op, string opName, dag outs, dag ins, string asm> :
    FLAT <op, outs, ins, asm, []>,
    SIMCInstr<opName, SISubtarget.VI> {
  let AssemblerPredicate = VIAssemblerPredicate;
}

multiclass FLAT_AtomicRet_m <flat op, dag outs, dag ins, string asm,
                   list<dag> pattern> {
  def "" : FLAT_Pseudo <NAME#"_RTN", outs, ins, pattern>,
               AtomicNoRet <NAME, 1>;

  def _ci : FLAT_Real_ci <op.CI, NAME#"_RTN", outs, ins, asm>;

  def _vi : FLAT_Real_vi <op.VI, NAME#"_RTN", outs, ins, asm>;
}

multiclass FLAT_Load_Helper <flat op, string asm_name,
    RegisterClass regClass,
    dag outs = (outs regClass:$vdst),
    dag ins = (ins VReg_64:$addr, glc_flat:$glc, slc_flat:$slc, tfe_flat:$tfe),
    string asm = asm_name#" $vdst, $addr"#"$glc"#"$slc"#"$tfe"> {

  let data = 0, mayLoad = 1 in {

    def "" : FLAT_Pseudo <NAME, outs, ins, []>;

    def _ci : FLAT_Real_ci <op.CI, NAME, outs, ins, asm>;

    def _vi : FLAT_Real_vi <op.VI, NAME, outs, ins, asm>;
  }
}

multiclass FLAT_Store_Helper <flat op, string asm_name,
    RegisterClass vdataClass,
    dag outs = (outs),
    dag ins = (ins vdataClass:$data, VReg_64:$addr, glc_flat:$glc,
                   slc_flat:$slc, tfe_flat:$tfe),
    string asm = asm_name#" $data, $addr"#"$glc"#"$slc"#"$tfe"> {

  let mayLoad = 0, mayStore = 1, vdst = 0 in {

    def "" : FLAT_Pseudo <NAME, outs, ins, []>;

    def _ci : FLAT_Real_ci <op.CI, NAME, outs, ins, asm>;

    def _vi : FLAT_Real_vi <op.VI, NAME, outs, ins, asm>;
  }
}

multiclass FLAT_ATOMIC <flat op, string asm_name, RegisterClass vdst_rc,
    RegisterClass data_rc = vdst_rc,
    dag outs_noret = (outs),
    string asm_noret = asm_name#" $addr, $data"#"$slc"#"$tfe"> {

  let mayLoad = 1, mayStore = 1, glc = 0, vdst = 0 in {
    def "" : FLAT_Pseudo <NAME, outs_noret,
                          (ins VReg_64:$addr, data_rc:$data,
                               slc_flat_atomic:$slc, tfe_flat_atomic:$tfe), []>,
             AtomicNoRet <NAME, 0>;

    def _ci : FLAT_Real_ci <op.CI, NAME, outs_noret,
                            (ins VReg_64:$addr, data_rc:$data,
                                 slc_flat_atomic:$slc, tfe_flat_atomic:$tfe),
                            asm_noret>;

    def _vi : FLAT_Real_vi <op.VI, NAME, outs_noret,
                            (ins VReg_64:$addr, data_rc:$data,
                                 slc_flat_atomic:$slc, tfe_flat_atomic:$tfe),
                            asm_noret>;
  }

  let glc = 1, hasPostISelHook = 1 in {
    defm _RTN : FLAT_AtomicRet_m <op, (outs vdst_rc:$vdst),
                        (ins VReg_64:$addr, data_rc:$data, slc_flat_atomic:$slc,
                             tfe_flat_atomic:$tfe),
                        asm_name#" $vdst, $addr, $data glc"#"$slc"#"$tfe", []>;
  }
}

class MIMG_Mask <string op, int channels> {
  string Op = op;
  int Channels = channels;
}

class MIMG_NoSampler_Helper <bits<7> op, string asm,
                             RegisterClass dst_rc,
                             RegisterClass src_rc> : MIMG <
  op,
  (outs dst_rc:$vdata),
  (ins i32imm:$dmask, i1imm:$unorm, i1imm:$glc, i1imm:$da, i1imm:$r128,
       i1imm:$tfe, i1imm:$lwe, i1imm:$slc, src_rc:$vaddr,
       SReg_256:$srsrc),
  asm#" $vdata, $dmask, $unorm, $glc, $da, $r128,"
     #" $tfe, $lwe, $slc, $vaddr, $srsrc",
  []> {
  let ssamp = 0;
  let mayLoad = 1;
  let mayStore = 0;
  let hasPostISelHook = 1;
}

multiclass MIMG_NoSampler_Src_Helper <bits<7> op, string asm,
                                      RegisterClass dst_rc,
                                      int channels> {
  def _V1 : MIMG_NoSampler_Helper <op, asm, dst_rc, VGPR_32>,
            MIMG_Mask<asm#"_V1", channels>;
  def _V2 : MIMG_NoSampler_Helper <op, asm, dst_rc, VReg_64>,
            MIMG_Mask<asm#"_V2", channels>;
  def _V4 : MIMG_NoSampler_Helper <op, asm, dst_rc, VReg_128>,
            MIMG_Mask<asm#"_V4", channels>;
}

multiclass MIMG_NoSampler <bits<7> op, string asm> {
  defm _V1 : MIMG_NoSampler_Src_Helper <op, asm, VGPR_32, 1>;
  defm _V2 : MIMG_NoSampler_Src_Helper <op, asm, VReg_64, 2>;
  defm _V3 : MIMG_NoSampler_Src_Helper <op, asm, VReg_96, 3>;
  defm _V4 : MIMG_NoSampler_Src_Helper <op, asm, VReg_128, 4>;
}

class MIMG_Sampler_Helper <bits<7> op, string asm,
                           RegisterClass dst_rc,
                           RegisterClass src_rc, int wqm> : MIMG <
  op,
  (outs dst_rc:$vdata),
  (ins i32imm:$dmask, i1imm:$unorm, i1imm:$glc, i1imm:$da, i1imm:$r128,
       i1imm:$tfe, i1imm:$lwe, i1imm:$slc, src_rc:$vaddr,
       SReg_256:$srsrc, SReg_128:$ssamp),
  asm#" $vdata, $dmask, $unorm, $glc, $da, $r128,"
     #" $tfe, $lwe, $slc, $vaddr, $srsrc, $ssamp",
  []> {
  let mayLoad = 1;
  let mayStore = 0;
  let hasPostISelHook = 1;
  let WQM = wqm;
}

multiclass MIMG_Sampler_Src_Helper <bits<7> op, string asm,
                                    RegisterClass dst_rc,
                                    int channels, int wqm> {
  def _V1 : MIMG_Sampler_Helper <op, asm, dst_rc, VGPR_32, wqm>,
            MIMG_Mask<asm#"_V1", channels>;
  def _V2 : MIMG_Sampler_Helper <op, asm, dst_rc, VReg_64, wqm>,
            MIMG_Mask<asm#"_V2", channels>;
  def _V4 : MIMG_Sampler_Helper <op, asm, dst_rc, VReg_128, wqm>,
            MIMG_Mask<asm#"_V4", channels>;
  def _V8 : MIMG_Sampler_Helper <op, asm, dst_rc, VReg_256, wqm>,
            MIMG_Mask<asm#"_V8", channels>;
  def _V16 : MIMG_Sampler_Helper <op, asm, dst_rc, VReg_512, wqm>,
            MIMG_Mask<asm#"_V16", channels>;
}

multiclass MIMG_Sampler <bits<7> op, string asm> {
  defm _V1 : MIMG_Sampler_Src_Helper<op, asm, VGPR_32, 1, 0>;
  defm _V2 : MIMG_Sampler_Src_Helper<op, asm, VReg_64, 2, 0>;
  defm _V3 : MIMG_Sampler_Src_Helper<op, asm, VReg_96, 3, 0>;
  defm _V4 : MIMG_Sampler_Src_Helper<op, asm, VReg_128, 4, 0>;
}

multiclass MIMG_Sampler_WQM <bits<7> op, string asm> {
  defm _V1 : MIMG_Sampler_Src_Helper<op, asm, VGPR_32, 1, 1>;
  defm _V2 : MIMG_Sampler_Src_Helper<op, asm, VReg_64, 2, 1>;
  defm _V3 : MIMG_Sampler_Src_Helper<op, asm, VReg_96, 3, 1>;
  defm _V4 : MIMG_Sampler_Src_Helper<op, asm, VReg_128, 4, 1>;
}

class MIMG_Gather_Helper <bits<7> op, string asm,
                          RegisterClass dst_rc,
                          RegisterClass src_rc, int wqm> : MIMG <
  op,
  (outs dst_rc:$vdata),
  (ins i32imm:$dmask, i1imm:$unorm, i1imm:$glc, i1imm:$da, i1imm:$r128,
       i1imm:$tfe, i1imm:$lwe, i1imm:$slc, src_rc:$vaddr,
       SReg_256:$srsrc, SReg_128:$ssamp),
  asm#" $vdata, $dmask, $unorm, $glc, $da, $r128,"
     #" $tfe, $lwe, $slc, $vaddr, $srsrc, $ssamp",
  []> {
  let mayLoad = 1;
  let mayStore = 0;

  // DMASK was repurposed for GATHER4. 4 components are always
  // returned and DMASK works like a swizzle - it selects
  // the component to fetch. The only useful DMASK values are
  // 1=red, 2=green, 4=blue, 8=alpha. (e.g. 1 returns
  // (red,red,red,red) etc.) The ISA document doesn't mention
  // this.
  // Therefore, disable all code which updates DMASK by setting these two:
  let MIMG = 0;
  let hasPostISelHook = 0;
  let WQM = wqm;
}

multiclass MIMG_Gather_Src_Helper <bits<7> op, string asm,
                                    RegisterClass dst_rc,
                                    int channels, int wqm> {
  def _V1 : MIMG_Gather_Helper <op, asm, dst_rc, VGPR_32, wqm>,
            MIMG_Mask<asm#"_V1", channels>;
  def _V2 : MIMG_Gather_Helper <op, asm, dst_rc, VReg_64, wqm>,
            MIMG_Mask<asm#"_V2", channels>;
  def _V4 : MIMG_Gather_Helper <op, asm, dst_rc, VReg_128, wqm>,
            MIMG_Mask<asm#"_V4", channels>;
  def _V8 : MIMG_Gather_Helper <op, asm, dst_rc, VReg_256, wqm>,
            MIMG_Mask<asm#"_V8", channels>;
  def _V16 : MIMG_Gather_Helper <op, asm, dst_rc, VReg_512, wqm>,
            MIMG_Mask<asm#"_V16", channels>;
}

multiclass MIMG_Gather <bits<7> op, string asm> {
  defm _V1 : MIMG_Gather_Src_Helper<op, asm, VGPR_32, 1, 0>;
  defm _V2 : MIMG_Gather_Src_Helper<op, asm, VReg_64, 2, 0>;
  defm _V3 : MIMG_Gather_Src_Helper<op, asm, VReg_96, 3, 0>;
  defm _V4 : MIMG_Gather_Src_Helper<op, asm, VReg_128, 4, 0>;
}

multiclass MIMG_Gather_WQM <bits<7> op, string asm> {
  defm _V1 : MIMG_Gather_Src_Helper<op, asm, VGPR_32, 1, 1>;
  defm _V2 : MIMG_Gather_Src_Helper<op, asm, VReg_64, 2, 1>;
  defm _V3 : MIMG_Gather_Src_Helper<op, asm, VReg_96, 3, 1>;
  defm _V4 : MIMG_Gather_Src_Helper<op, asm, VReg_128, 4, 1>;
}

//===----------------------------------------------------------------------===//
// Vector instruction mappings
//===----------------------------------------------------------------------===//

// Maps an opcode in e32 form to its e64 equivalent
def getVOPe64 : InstrMapping {
  let FilterClass = "VOP";
  let RowFields = ["OpName"];
  let ColFields = ["Size"];
  let KeyCol = ["4"];
  let ValueCols = [["8"]];
}

// Maps an opcode in e64 form to its e32 equivalent
def getVOPe32 : InstrMapping {
  let FilterClass = "VOP";
  let RowFields = ["OpName"];
  let ColFields = ["Size"];
  let KeyCol = ["8"];
  let ValueCols = [["4"]];
}

def getMaskedMIMGOp : InstrMapping {
  let FilterClass = "MIMG_Mask";
  let RowFields = ["Op"];
  let ColFields = ["Channels"];
  let KeyCol = ["4"];
  let ValueCols = [["1"], ["2"], ["3"] ];
}

// Maps an commuted opcode to its original version
def getCommuteOrig : InstrMapping {
  let FilterClass = "VOP2_REV";
  let RowFields = ["RevOp"];
  let ColFields = ["IsOrig"];
  let KeyCol = ["0"];
  let ValueCols = [["1"]];
}

// Maps an original opcode to its commuted version
def getCommuteRev : InstrMapping {
  let FilterClass = "VOP2_REV";
  let RowFields = ["RevOp"];
  let ColFields = ["IsOrig"];
  let KeyCol = ["1"];
  let ValueCols = [["0"]];
}

def getCommuteCmpOrig : InstrMapping {
  let FilterClass = "VOP2_REV";
  let RowFields = ["RevOp"];
  let ColFields = ["IsOrig"];
  let KeyCol = ["0"];
  let ValueCols = [["1"]];
}

// Maps an original opcode to its commuted version
def getCommuteCmpRev : InstrMapping {
  let FilterClass = "VOP2_REV";
  let RowFields = ["RevOp"];
  let ColFields = ["IsOrig"];
  let KeyCol = ["1"];
  let ValueCols = [["0"]];
}


def getMCOpcodeGen : InstrMapping {
  let FilterClass = "SIMCInstr";
  let RowFields = ["PseudoInstr"];
  let ColFields = ["Subtarget"];
  let KeyCol = [!cast<string>(SISubtarget.NONE)];
  let ValueCols = [[!cast<string>(SISubtarget.SI)],[!cast<string>(SISubtarget.VI)]];
}

def getAddr64Inst : InstrMapping {
  let FilterClass = "MUBUFAddr64Table";
  let RowFields = ["OpName"];
  let ColFields = ["IsAddr64"];
  let KeyCol = ["0"];
  let ValueCols = [["1"]];
}

// Maps an atomic opcode to its version with a return value.
def getAtomicRetOp : InstrMapping {
  let FilterClass = "AtomicNoRet";
  let RowFields = ["NoRetOp"];
  let ColFields = ["IsRet"];
  let KeyCol = ["0"];
  let ValueCols = [["1"]];
}

// Maps an atomic opcode to its returnless version.
def getAtomicNoRetOp : InstrMapping {
  let FilterClass = "AtomicNoRet";
  let RowFields = ["NoRetOp"];
  let ColFields = ["IsRet"];
  let KeyCol = ["1"];
  let ValueCols = [["0"]];
}

include "SIInstructions.td"
include "CIInstructions.td"
include "VIInstructions.td"
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d10 1
a10 1
                      ">= SISubtarget::SEA_ISLANDS">;
d12 1
a12 1
                         "SISubtarget::SEA_ISLANDS">,
a71 5
class dsop <bits<8> si, bits<8> vi = si> {
  field bits<8> SI = si;
  field bits<8> VI = vi;
}

d81 3
a83 3
// Execpt for the NONE field, this must be kept in sync with the
// SIEncodingFamily enum in AMDGPUInstrInfo.cpp
def SIEncodingFamily {
a97 8
def SIatomic_inc : SDNode<"AMDGPUISD::ATOMIC_INC", SDTAtomic2,
  [SDNPMayLoad, SDNPMayStore, SDNPMemOperand, SDNPHasChain]
>;

def SIatomic_dec : SDNode<"AMDGPUISD::ATOMIC_DEC", SDTAtomic2,
  [SDNPMayLoad, SDNPMayStore, SDNPMemOperand, SDNPHasChain]
>;

d123 1
a123 1
  SDTypeProfile<1, 4, [SDTCisVT<0, v4f32>, SDTCisVT<2, v8i32>,
d132 3
a134 2
def SIpc_add_rel_offset : SDNode<"AMDGPUISD::PC_ADD_REL_OFFSET",
  SDTypeProfile<1, 1, [SDTCisVT<0, iPTR>, SDTCisSameAs<0,1>]>
d143 3
a145 4
  const MemSDNode *LD = cast<MemSDNode>(N);
  return LD->getAddressSpace() == AMDGPUAS::FLAT_ADDRESS ||
         LD->getAddressSpace() == AMDGPUAS::GLOBAL_ADDRESS ||
         LD->getAddressSpace() == AMDGPUAS::CONSTANT_ADDRESS;
a148 1
def atomic_flat_load : flat_ld<atomic_load>;
d156 2
a157 3
  const MemSDNode *ST = cast<MemSDNode>(N);
  return ST->getAddressSpace() == AMDGPUAS::FLAT_ADDRESS ||
         ST->getAddressSpace() == AMDGPUAS::GLOBAL_ADDRESS;
a160 1
def atomic_flat_store: flat_st <atomic_store>;
a163 2
class MubufLoad <SDPatternOperator op> : PatFrag <
  (ops node:$ptr), (op node:$ptr), [{
d165 3
a167 3
  const MemSDNode *LD = cast<MemSDNode>(N);
  return LD->getAddressSpace() == AMDGPUAS::GLOBAL_ADDRESS ||
         LD->getAddressSpace() == AMDGPUAS::CONSTANT_ADDRESS;
a169 8
def mubuf_load : MubufLoad <load>;
def mubuf_az_extloadi8 : MubufLoad <az_extloadi8>;
def mubuf_sextloadi8 : MubufLoad <sextloadi8>;
def mubuf_az_extloadi16 : MubufLoad <az_extloadi16>;
def mubuf_sextloadi16 : MubufLoad <sextloadi16>;

def mubuf_load_atomic : MubufLoad <atomic_load>;

d171 2
a172 4
  auto Ld = cast<LoadSDNode>(N);
  return Ld->getAlignment() >= 4  &&
    Ld->getAddressSpace() == AMDGPUAS::CONSTANT_ADDRESS &&
    static_cast<const SITargetLowering *>(getTargetLowering())->isMemOpUniform(N);
a175 10
// PatFrags for global memory operations
//===----------------------------------------------------------------------===//

def atomic_inc_global : global_binary_atomic_op<SIatomic_inc>;
def atomic_dec_global : global_binary_atomic_op<SIatomic_dec>;

def atomic_inc_flat : flat_binary_atomic_op<SIatomic_inc>;
def atomic_dec_flat : flat_binary_atomic_op<SIatomic_dec>;

//===----------------------------------------------------------------------===//
d185 1
a185 1
  return cast<LoadSDNode>(N)->getAddressSpace() == AMDGPUAS::LOCAL_ADDRESS;
d222 1
a222 1
  return cast<StoreSDNode>(N)->getAddressSpace() == AMDGPUAS::LOCAL_ADDRESS;
d250 1
a250 25
def si_setcc_uniform : PatFrag <
  (ops node:$lhs, node:$rhs, node:$cond),
  (setcc node:$lhs, node:$rhs, node:$cond), [{
  for (SDNode *Use : N->uses()) {
    if (Use->isMachineOpcode() || Use->getOpcode() != ISD::CopyToReg)
      return false;

    unsigned Reg = cast<RegisterSDNode>(Use->getOperand(1))->getReg();
    if (Reg != AMDGPU::SCC)
      return false;
  }
  return true;
}]>;

def si_uniform_br : PatFrag <
  (ops node:$cond, node:$bb), (brcond node:$cond, node:$bb), [{
  return isUniformBr(N);
}]>;

def si_uniform_br_scc : PatFrag <
  (ops node:$cond, node:$bb), (si_uniform_br node:$cond, node:$bb), [{
  return isCBranchSCC(N);
}]>;

multiclass SIAtomicM0Glue2 <string op_name, bit is_amdgpu = 0> {
d252 1
a252 2
  def _glue : SDNode <
    !if(is_amdgpu, "AMDGPUISD", "ISD")#"::ATOMIC_"#op_name, SDTAtomic2,
a259 3
defm si_atomic_load_sub : SIAtomicM0Glue2 <"LOAD_SUB">;
defm si_atomic_inc : SIAtomicM0Glue2 <"INC", 1>;
defm si_atomic_dec : SIAtomicM0Glue2 <"DEC", 1>;
d264 1
a349 4
def SIMM16bit : PatLeaf <(imm),
  [{return isInt<16>(N->getSExtValue());}]
>;

d372 1
a372 1
  if (Subtarget->getGeneration() < SISubtarget::SOUTHERN_ISLANDS) {
d405 4
a408 1
def si_ga : Operand<iPTR>;
d410 4
a413 2
def InterpSlot : Operand<i32> {
  let PrintMethod = "printInterpSlot";
d416 3
a418 4
def SendMsgMatchClass : AsmOperandClass {
  let Name = "SendMsg";
  let PredicateMethod = "isSendMsg";
  let ParserMethod = "parseSendMsgOp";
d420 1
d423 8
a430 3
def SendMsgImm : Operand<i32> {
  let PrintMethod = "printSendMsg";
  let ParserMatchClass = SendMsgMatchClass;
d433 4
a436 2
def SWaitMatchClass : AsmOperandClass {
  let Name = "SWaitCnt";
a437 1
  let ParserMethod = "parseSWaitCntOps";
d440 8
a447 3
def WAIT_FLAG : Operand <i32> {
  let ParserMatchClass = SWaitMatchClass;
  let PrintMethod = "printWaitFlag";
d450 2
a451 2
include "SIInstrFormats.td"
include "VIInstrFormats.td"
d453 4
a456 4
class NamedMatchClass<string CName, bit Optional = 1> : AsmOperandClass {
  let Name = "Imm"#CName;
  let PredicateMethod = "is"#CName;
  let ParserMethod = !if(Optional, "parseOptionalOperand", "parse"#CName);
a457 2
  let IsOptional = Optional;
  let DefaultMethod = !if(Optional, "default"#CName, ?);
d460 9
a468 3
class NamedOperandBit<string Name, AsmOperandClass MatchClass> : Operand<i1> {
  let PrintMethod = "print"#Name;
  let ParserMatchClass = MatchClass;
d471 9
a479 3
class NamedOperandU8<string Name, AsmOperandClass MatchClass> : Operand<i8> {
  let PrintMethod = "print"#Name;
  let ParserMatchClass = MatchClass;
d482 5
a486 3
class NamedOperandU16<string Name, AsmOperandClass MatchClass> : Operand<i16> {
  let PrintMethod = "print"#Name;
  let ParserMatchClass = MatchClass;
d489 4
a492 3
class NamedOperandU32<string Name, AsmOperandClass MatchClass> : Operand<i32> {
  let PrintMethod = "print"#Name;
  let ParserMatchClass = MatchClass;
d495 5
d502 43
a544 35
def offen : NamedOperandBit<"Offen", NamedMatchClass<"Offen">>;
def idxen : NamedOperandBit<"Idxen", NamedMatchClass<"Idxen">>;
def addr64 : NamedOperandBit<"Addr64", NamedMatchClass<"Addr64">>;

def offset : NamedOperandU16<"Offset", NamedMatchClass<"Offset">>;
def offset0 : NamedOperandU8<"Offset0", NamedMatchClass<"Offset0">>;
def offset1 : NamedOperandU8<"Offset1", NamedMatchClass<"Offset1">>;

def gds : NamedOperandBit<"GDS", NamedMatchClass<"GDS">>;

def omod : NamedOperandU32<"OModSI", NamedMatchClass<"OModSI">>;
def clampmod : NamedOperandBit<"ClampSI", NamedMatchClass<"ClampSI">>;

def smrd_offset : NamedOperandU32<"SMRDOffset", NamedMatchClass<"SMRDOffset">>;
def smrd_literal_offset : NamedOperandU32<"SMRDLiteralOffset", NamedMatchClass<"SMRDLiteralOffset">>;

def glc : NamedOperandBit<"GLC", NamedMatchClass<"GLC">>;
def slc : NamedOperandBit<"SLC", NamedMatchClass<"SLC">>;
def tfe : NamedOperandBit<"TFE", NamedMatchClass<"TFE">>;
def unorm : NamedOperandBit<"UNorm", NamedMatchClass<"UNorm">>;
def da : NamedOperandBit<"DA", NamedMatchClass<"DA">>;
def r128 : NamedOperandBit<"R128", NamedMatchClass<"R128">>;
def lwe : NamedOperandBit<"LWE", NamedMatchClass<"LWE">>;

def dmask : NamedOperandU16<"DMask", NamedMatchClass<"DMask">>;

def dpp_ctrl : NamedOperandU32<"DPPCtrl", NamedMatchClass<"DPPCtrl", 0>>;
def row_mask : NamedOperandU32<"RowMask", NamedMatchClass<"RowMask">>;
def bank_mask : NamedOperandU32<"BankMask", NamedMatchClass<"BankMask">>;
def bound_ctrl : NamedOperandBit<"BoundCtrl", NamedMatchClass<"BoundCtrl">>;

def dst_sel : NamedOperandU32<"SDWADstSel", NamedMatchClass<"SDWADstSel">>;
def src0_sel : NamedOperandU32<"SDWASrc0Sel", NamedMatchClass<"SDWASrc0Sel">>;
def src1_sel : NamedOperandU32<"SDWASrc1Sel", NamedMatchClass<"SDWASrc1Sel">>;
def dst_unused : NamedOperandU32<"SDWADstUnused", NamedMatchClass<"SDWADstUnused">>;
d546 4
a549 1
def hwreg : NamedOperandU16<"Hwreg", NamedMatchClass<"Hwreg", 0>>;
d551 3
a553 1
} // End OperandType = "OPERAND_IMMEDIATE"
d555 4
d560 3
a562 1
def VOPDstS64 : VOPDstOperand <SReg_64>;
d564 3
a566 4
def FPInputModsMatchClass : AsmOperandClass {
  let Name = "RegOrImmWithFPInputMods";
  let ParserMethod = "parseRegOrImmWithFPInputMods";
  let PredicateMethod = "isRegOrImmWithInputMods";
d569 3
a571 3
def FPInputMods : Operand <i32> {
  let PrintMethod = "printOperandAndFPInputMods";
  let ParserMatchClass = FPInputModsMatchClass;
d574 3
a576 4
def IntInputModsMatchClass : AsmOperandClass {
  let Name = "RegOrImmWithIntInputMods";
  let ParserMethod = "parseRegOrImmWithIntInputMods";
  let PredicateMethod = "isRegOrImmWithInputMods";
d579 3
a581 3
def IntInputMods: Operand <i32> {
  let PrintMethod = "printOperandAndIntInputMods";
  let ParserMatchClass = IntInputModsMatchClass;
d584 4
a597 1
def FLATAtomic : ComplexPattern<i64, 3, "SelectFlat">;
a599 1
def MUBUFOffsetNoGLC : ComplexPattern<i64, 3, "SelectMUBUFOffset">;
a600 2
def MUBUFIntrinsicOffset : ComplexPattern<i32, 2, "SelectMUBUFIntrinsicOffset">;
def MUBUFIntrinsicVOffset : ComplexPattern<i32, 3, "SelectMUBUFIntrinsicVOffset">;
a608 2
def MOVRELOffset : ComplexPattern<i32, 2, "SelectMOVRELOffset">;

a672 1
  let SchedRW = [WriteExport];
d678 1
a678 1
    def "" : EXPCommon, SIMCInstr <"exp", SIEncodingFamily.NONE> ;
d681 1
a681 4
  def _si : EXPCommon, SIMCInstr <"exp", SIEncodingFamily.SI>, EXPe {
    let DecoderNamespace="SICI";
    let DisableDecoder = DisableSIDecoder;
  }
d683 1
a683 4
  def _vi : EXPCommon, SIMCInstr <"exp", SIEncodingFamily.VI>, EXPe_vi {
    let DecoderNamespace="VI";
    let DisableDecoder = DisableVIDecoder;
  }
d692 1
a692 1
  SIMCInstr<opName, SIEncodingFamily.NONE> {
d700 1
a700 1
  SIMCInstr<opName, SIEncodingFamily.SI> {
a702 2
  let DecoderNamespace = "SICI";
  let DisableDecoder = DisableSIDecoder;
d708 1
a708 1
  SIMCInstr<opName, SIEncodingFamily.VI> {
a710 2
  let DecoderNamespace = "VI";
  let DisableDecoder = DisableVIDecoder;
d725 2
a726 2
    op, opName, (outs SReg_32:$sdst), (ins SSrc_32:$src0),
    opName#" $sdst, $src0", pattern
d730 2
a731 2
    op, opName, (outs SReg_64:$sdst), (ins SSrc_64:$src0),
    opName#" $sdst, $src0", pattern
d736 1
a736 1
  def "" : SOP1_Pseudo <opName, (outs SReg_64:$sdst), (ins), pattern>;
d738 3
a740 3
  def _si : SOP1_Real_si <op, opName, (outs SReg_64:$sdst), (ins),
    opName#" $sdst"> {
    let src0 = 0;
d743 3
a745 3
  def _vi : SOP1_Real_vi <op, opName, (outs SReg_64:$sdst), (ins),
    opName#" $sdst"> {
    let src0 = 0;
d766 2
a767 8
    op, opName, (outs SReg_32:$sdst), (ins SSrc_64:$src0),
    opName#" $sdst, $src0", pattern
>;

// 32-bit input, 64-bit output.
multiclass SOP1_64_32 <sop1 op, string opName, list<dag> pattern> : SOP1_m <
    op, opName, (outs SReg_64:$sdst), (ins SSrc_32:$src0),
    opName#" $sdst, $src0", pattern
d772 1
a772 1
  SIMCInstr<opName, SIEncodingFamily.NONE> {
d787 1
a787 1
  SIMCInstr<opName, SIEncodingFamily.SI> {
a788 2
  let DecoderNamespace = "SICI";
  let DisableDecoder = DisableSIDecoder;
d794 1
a794 1
  SIMCInstr<opName, SIEncodingFamily.VI> {
a795 2
  let DecoderNamespace = "VI";
  let DisableDecoder = DisableVIDecoder;
d810 2
a811 2
    op, opName, (outs SReg_32:$sdst), (ins SSrc_32:$src0, SSrc_32:$src1),
    opName#" $sdst, $src0, $src1", pattern
d815 2
a816 2
    op, opName, (outs SReg_64:$sdst), (ins SSrc_64:$src0, SSrc_64:$src1),
    opName#" $sdst, $src0, $src1", pattern
d820 2
a821 2
    op, opName, (outs SReg_64:$sdst), (ins SSrc_64:$src0, SSrc_32:$src1),
    opName#" $sdst, $src0, $src1", pattern
d824 4
a827 9
multiclass SOP2_64_32_32 <sop2 op, string opName, list<dag> pattern> : SOP2_m <
    op, opName, (outs SReg_64:$sdst), (ins SSrc_32:$src0, SSrc_32:$src1),
    opName#" $sdst, $src0, $src1", pattern
>;

class SOPC_Base <bits<7> op, RegisterOperand rc0, RegisterOperand rc1,
                 string opName, list<dag> pattern = []> : SOPC <
  op, (outs), (ins rc0:$src0, rc1:$src1),
  opName#" $src0, $src1", pattern > {
a829 5
class SOPC_Helper <bits<7> op, RegisterOperand rc, ValueType vt,
                    string opName, PatLeaf cond> : SOPC_Base <
  op, rc, rc, opName,
  [(set SCC, (si_setcc_uniform vt:$src0, vt:$src1, cond))] > {
}
d831 1
a831 1
class SOPC_CMP_32<bits<7> op, string opName, PatLeaf cond = COND_NULL>
d834 2
a835 5
class SOPC_32<bits<7> op, string opName, list<dag> pattern = []>
  : SOPC_Base<op, SSrc_32, SSrc_32, opName, pattern>;

class SOPC_64_32<bits<7> op, string opName, list<dag> pattern = []>
  : SOPC_Base<op, SSrc_64, SSrc_32, opName, pattern>;
d839 1
a839 1
  SIMCInstr<opName, SIEncodingFamily.NONE> {
d847 1
a847 1
  SIMCInstr<opName, SIEncodingFamily.SI> {
a848 2
  let DecoderNamespace = "SICI";
  let DisableDecoder = DisableSIDecoder;
d855 1
a855 1
  SIMCInstr<opName, SIEncodingFamily.VI> {
a856 2
  let DecoderNamespace = "VI";
  let DisableDecoder = DisableVIDecoder;
d871 1
a871 1
  def "" : SOPK_Pseudo <opName, (outs SReg_32:$sdst), (ins u16imm:$simm16),
d874 2
a875 2
  def _si : SOPK_Real_si <op, opName, (outs SReg_32:$sdst), (ins u16imm:$simm16),
    opName#" $sdst, $simm16">;
d877 2
a878 2
  def _vi : SOPK_Real_vi <op, opName, (outs SReg_32:$sdst), (ins u16imm:$simm16),
    opName#" $sdst, $simm16">;
d911 1
a911 1
            SIMCInstr<opName, SIEncodingFamily.SI> {
a912 2
              let DecoderNamespace = "SICI";
              let DisableDecoder = DisableSIDecoder;
d918 1
a918 1
            SIMCInstr<opName, SIEncodingFamily.VI> {
a919 2
              let DecoderNamespace = "VI";
              let DisableDecoder = DisableVIDecoder;
d929 1
a929 1
  SIMCInstr<opName, SIEncodingFamily.NONE> {
d934 2
a935 12
class SMRD_IMM_Real_si <bits<5> op, string opName, dag outs, dag ins,
                        string asm> :
  SMRD <outs, ins, asm, []>,
  SMRD_IMMe <op>,
  SIMCInstr<opName, SIEncodingFamily.SI> {
  let AssemblerPredicates = [isSICI];
  let DecoderNamespace = "SICI";
  let DisableDecoder = DisableSIDecoder;
}

class SMRD_SOFF_Real_si <bits<5> op, string opName, dag outs, dag ins,
                         string asm> :
d937 2
a938 2
  SMRD_SOFFe <op>,
  SIMCInstr<opName, SIEncodingFamily.SI> {
a939 2
  let DecoderNamespace = "SICI";
  let DisableDecoder = DisableSIDecoder;
d942 2
a943 13

class SMRD_IMM_Real_vi <bits<8> op, string opName, dag outs, dag ins,
                        string asm, list<dag> pattern = []> :
  SMRD <outs, ins, asm, pattern>,
  SMEM_IMMe_vi <op>,
  SIMCInstr<opName, SIEncodingFamily.VI> {
  let AssemblerPredicates = [isVI];
  let DecoderNamespace = "VI";
  let DisableDecoder = DisableVIDecoder;
}

class SMRD_SOFF_Real_vi <bits<8> op, string opName, dag outs, dag ins,
                         string asm, list<dag> pattern = []> :
d945 2
a946 2
  SMEM_SOFFe_vi <op>,
  SIMCInstr<opName, SIEncodingFamily.VI> {
a947 2
  let DecoderNamespace = "VI";
  let DisableDecoder = DisableVIDecoder;
d950 1
a950 2

multiclass SMRD_IMM_m <smrd op, string opName, dag outs, dag ins,
d955 1
a955 1
  def _si : SMRD_IMM_Real_si <op.SI, opName, outs, ins, asm>;
d960 1
a960 1
    def _vi : SMRD_IMM_Real_vi <op.VI, opName, outs, ins, asm>;
d964 9
a972 4
multiclass SMRD_SOFF_m <smrd op, string opName, dag outs, dag ins,
                        string asm, list<dag> pattern> {

  def "" : SMRD_Pseudo <opName, outs, ins, pattern>;
d974 2
a975 21
  def _si : SMRD_SOFF_Real_si <op.SI, opName, outs, ins, asm>;

  // glc is only applicable to scalar stores, which are not yet
  // implemented.
  let glc = 0 in {
    def _vi : SMRD_SOFF_Real_vi <op.VI, opName, outs, ins, asm>;
  }
}

multiclass SMRD_Special <smrd op, string opName, dag outs,
                       int sdst_ = ?,
                       string opStr = "",
                       list<dag> pattern = []> {
  let hasSideEffects = 1 in {
    def "" : SMRD_Pseudo <opName, outs, (ins), pattern>;

    let sbase = 0, soff = 0, sdst = sdst_ in {
      def _si : SMRD_SOFF_Real_si <op.SI, opName, outs, (ins), opName#opStr>;

      let glc = 0 in {
        def _vi : SMRD_SOFF_Real_vi <op.VI, opName, outs, (ins), opName#opStr>;
a980 7
multiclass SMRD_Inval <smrd op, string opName,
                     SDPatternOperator node> {
  let mayStore = 1 in {
    defm : SMRD_Special<op, opName, (outs), 0, "", [(node)]>;
  }
}

d982 1
a982 1
  SMRD_SOFF_Real_vi<op, opName, (outs), (ins), opName, [(node)]> {
d986 1
a986 12
  let sdst = 0;
  let glc = 0;
  let soff = 0;
}

class SMEM_Ret <bits<8> op, string opName, SDPatternOperator node> :
  SMRD_SOFF_Real_vi<op, opName, (outs SReg_64:$sdst), (ins),
  opName#" $sdst", [(set i64:$sdst, (node))]> {
  let hasSideEffects = 1;
  let mayStore = ?;
  let mayLoad = ?;
  let sbase = 0;
d988 1
a988 1
  let soff = 0;
d993 2
a994 2
  defm _IMM : SMRD_IMM_m <
    op, opName#"_IMM", (outs dstClass:$sdst),
d996 1
a996 1
    opName#" $sdst, $sbase, $offset", []
d1000 2
a1001 2
    (outs dstClass:$sdst), (ins baseClass:$sbase, smrd_literal_offset:$offset),
    opName#" $sdst, $sbase, $offset", []>, SMRD_IMMe_ci <op.SI> {
a1002 1
    let DecoderNamespace = "CI";
d1005 2
a1006 2
  defm _SGPR : SMRD_SOFF_m <
    op, opName#"_SGPR", (outs dstClass:$sdst),
d1008 1
a1008 1
    opName#" $sdst, $sbase, $soff", []
d1016 14
d1053 3
a1055 2
// Returns the vreg register class to use for source operand given VT
class getVregSrcForVT<ValueType VT> {
a1058 1

d1075 2
a1076 4
  bit ret =
    !if(!eq(SrcVT.Value, f32.Value), 1,
    !if(!eq(SrcVT.Value, f64.Value), 1,
    0));
a1091 4
    !if (!eq(NumSrcArgs, 0),
      // VOP1 without input operands (V_NOP, V_CLREXCP)
      (ins),
      /* else */
d1095 2
a1096 2
        (ins FPInputMods:$src0_modifiers, Src0RC:$src0,
             clampmod:$clamp, omod:$omod)
d1104 3
a1106 3
        (ins FPInputMods:$src0_modifiers, Src0RC:$src0,
             FPInputMods:$src1_modifiers, Src1RC:$src1,
             clampmod:$clamp, omod:$omod)
d1114 4
a1117 4
        (ins FPInputMods:$src0_modifiers, Src0RC:$src0,
             FPInputMods:$src1_modifiers, Src1RC:$src1,
             FPInputMods:$src2_modifiers, Src2RC:$src2,
             clampmod:$clamp, omod:$omod)
d1121 1
a1121 89
      /* endif */ ))));
}

class getInsDPP <RegisterClass Src0RC, RegisterClass Src1RC, int NumSrcArgs,
                                                             bit HasModifiers> {

  dag ret = !if (!eq(NumSrcArgs, 0),
                // VOP1 without input operands (V_NOP)
                (ins dpp_ctrl:$dpp_ctrl, row_mask:$row_mask,
                     bank_mask:$bank_mask, bound_ctrl:$bound_ctrl),
            !if (!eq(NumSrcArgs, 1),
              !if (!eq(HasModifiers, 1),
                // VOP1_DPP with modifiers
                (ins FPInputMods:$src0_modifiers, Src0RC:$src0,
                     dpp_ctrl:$dpp_ctrl, row_mask:$row_mask,
                     bank_mask:$bank_mask, bound_ctrl:$bound_ctrl)
              /* else */,
                // VOP1_DPP without modifiers
                (ins Src0RC:$src0, dpp_ctrl:$dpp_ctrl, row_mask:$row_mask,
                bank_mask:$bank_mask, bound_ctrl:$bound_ctrl)
              /* endif */)
              /* NumSrcArgs == 2 */,
              !if (!eq(HasModifiers, 1),
                // VOP2_DPP with modifiers
                (ins FPInputMods:$src0_modifiers, Src0RC:$src0,
                     FPInputMods:$src1_modifiers, Src1RC:$src1,
                     dpp_ctrl:$dpp_ctrl, row_mask:$row_mask,
                     bank_mask:$bank_mask, bound_ctrl:$bound_ctrl)
              /* else */,
                // VOP2_DPP without modifiers
                (ins Src0RC:$src0, Src1RC:$src1, dpp_ctrl:$dpp_ctrl,
                row_mask:$row_mask, bank_mask:$bank_mask,
                bound_ctrl:$bound_ctrl)
             /* endif */)));
}

class getInsSDWA <RegisterClass Src0RC, RegisterClass Src1RC, int NumSrcArgs,
                  bit HasFloatModifiers, ValueType DstVT> {

  dag ret = !if(!eq(NumSrcArgs, 0),
               // VOP1 without input operands (V_NOP)
               (ins),
            !if(!eq(NumSrcArgs, 1),
                !if(HasFloatModifiers,
                    // VOP1_SDWA with float modifiers
                    (ins FPInputMods:$src0_fmodifiers, Src0RC:$src0,
                         clampmod:$clamp, dst_sel:$dst_sel, dst_unused:$dst_unused,
                         src0_sel:$src0_sel)
                /* else */,
                    // VOP1_SDWA with sext modifier
                    (ins IntInputMods:$src0_imodifiers, Src0RC:$src0,
                         clampmod:$clamp, dst_sel:$dst_sel, dst_unused:$dst_unused,
                         src0_sel:$src0_sel)
                /* endif */)
              /* NumSrcArgs == 2 */,
              !if(HasFloatModifiers,
                  !if(!eq(DstVT.Size, 1),
                      // VOPC_SDWA with float modifiers
                      (ins FPInputMods:$src0_fmodifiers, Src0RC:$src0,
                           FPInputMods:$src1_fmodifiers, Src1RC:$src1,
                           clampmod:$clamp, src0_sel:$src0_sel, src1_sel:$src1_sel),
                      // VOP2_SDWA or VOPC_SDWA with float modifiers
                      (ins FPInputMods:$src0_fmodifiers, Src0RC:$src0,
                           FPInputMods:$src1_fmodifiers, Src1RC:$src1,
                           clampmod:$clamp, dst_sel:$dst_sel, dst_unused:$dst_unused,
                           src0_sel:$src0_sel, src1_sel:$src1_sel)
                  ),
              /* else */
                !if(!eq(DstVT.Size, 1),
                    // VOPC_SDWA with sext modifiers
                    (ins IntInputMods:$src0_imodifiers, Src0RC:$src0,
                         IntInputMods:$src1_imodifiers, Src1RC:$src1,
                         clampmod:$clamp, src0_sel:$src0_sel, src1_sel:$src1_sel),
                    // VOP2_SDWA or VOPC_SDWA with sext modifier
                    (ins IntInputMods:$src0_imodifiers, Src0RC:$src0,
                         IntInputMods:$src1_imodifiers, Src1RC:$src1,
                         clampmod:$clamp, dst_sel:$dst_sel, dst_unused:$dst_unused,
                         src0_sel:$src0_sel, src1_sel:$src1_sel)
                )
             /* endif */)));
}

// Outs for DPP and SDWA
class getOutsExt <bit HasDst, ValueType DstVT, RegisterOperand DstRCDPP> {
  dag ret = !if(HasDst,
                !if(!eq(DstVT.Size, 1),
                    (outs), // no dst for VOPC, we use "vcc"-token as dst in SDWA VOPC instructions
                    (outs DstRCDPP:$vdst)),
                (outs)); // V_NOP
d1127 2
a1128 2
class getAsm32 <bit HasDst, int NumSrcArgs, ValueType DstVT = i32> {
  string dst = !if(!eq(DstVT.Size, 1), "$sdst", "$vdst"); // use $sdst for VOPC
d1140 1
a1140 2
class getAsm64 <bit HasDst, int NumSrcArgs, bit HasModifiers, ValueType DstVT = i32> {
  string dst = !if(!eq(DstVT.Size, 1), "$sdst", "$vdst"); // use $sdst for VOPC
d1148 2
a1149 65
      getAsm32<HasDst, NumSrcArgs, DstVT>.ret,
      dst#", "#src0#src1#src2#"$clamp"#"$omod");
}

class getAsmDPP <bit HasDst, int NumSrcArgs, bit HasModifiers, ValueType DstVT = i32> {
  string dst = !if(HasDst,
                   !if(!eq(DstVT.Size, 1),
                       "$sdst",
                       "$vdst"),
                    ""); // use $sdst for VOPC
  string src0 = !if(!eq(NumSrcArgs, 1), "$src0_modifiers", "$src0_modifiers,");
  string src1 = !if(!eq(NumSrcArgs, 1), "",
                   !if(!eq(NumSrcArgs, 2), " $src1_modifiers",
                                           " $src1_modifiers,"));
  string args = !if(!eq(HasModifiers, 0),
                     getAsm32<0, NumSrcArgs, DstVT>.ret,
                     ", "#src0#src1);
  string ret = dst#args#" $dpp_ctrl$row_mask$bank_mask$bound_ctrl";
}

class getAsmSDWA <bit HasDst, int NumSrcArgs, bit HasFloatModifiers,
                  ValueType DstVT = i32> {
  string dst = !if(HasDst,
                   !if(!eq(DstVT.Size, 1),
                       " vcc", // use vcc token as dst for VOPC instructioins
                       "$vdst"),
                    "");
  string src0 = !if(HasFloatModifiers, "$src0_fmodifiers", "$src0_imodifiers");
  string src1 = !if(HasFloatModifiers, "$src1_fmodifiers", "$src1_imodifiers");
  string args = !if(!eq(NumSrcArgs, 0),
                    "",
                    !if(!eq(NumSrcArgs, 1),
                        ", "#src0#"$clamp",
                        ", "#src0#", "#src1#"$clamp"
                     )
                );
  string sdwa = !if(!eq(NumSrcArgs, 0),
                    "",
                    !if(!eq(NumSrcArgs, 1),
                        " $dst_sel $dst_unused $src0_sel",
                        !if(!eq(DstVT.Size, 1),
                            " $src0_sel $src1_sel", // No dst_sel and dst_unused for VOPC
                            " $dst_sel $dst_unused $src0_sel $src1_sel"
                        )
                    )
                );
  string ret = dst#args#sdwa;
}

// Function that checks if instruction supports DPP and SDWA
class getHasExt <int NumSrcArgs, ValueType DstVT = i32, ValueType Src0VT = i32,
                 ValueType Src1VT = i32> {
  bit ret = !if(!eq(NumSrcArgs, 3),
                0, // NumSrcArgs == 3 - No DPP or SDWA for VOP3
                !if(!eq(DstVT.Size, 64),
                    0, // 64-bit dst - No DPP or SDWA for 64-bit operands
                    !if(!eq(Src0VT.Size, 64),
                        0, // 64-bit src0
                        !if(!eq(Src0VT.Size, 64),
                            0, // 64-bit src2
                            1
                        )
                    )
                )
            );
a1160 2
  field RegisterOperand DstRCDPP = getVALUDstForVT<DstVT>.ret;
  field RegisterOperand DstRCSDWA = getVALUDstForVT<DstVT>.ret;
d1162 1
a1162 1
  field RegisterClass Src1RC32 = getVregSrcForVT<Src1VT>.ret;
a1165 4
  field RegisterClass Src0DPP = getVregSrcForVT<Src0VT>.ret;
  field RegisterClass Src1DPP = getVregSrcForVT<Src1VT>.ret;
  field RegisterClass Src0SDWA = getVregSrcForVT<Src0VT>.ret;
  field RegisterClass Src1SDWA = getVregSrcForVT<Src1VT>.ret;
d1172 1
a1172 3
  field bit HasExt = getHasExt<NumSrcArgs, DstVT, Src0VT, Src1VT>.ret;

  field dag Outs = !if(HasDst,(outs DstRC:$vdst),(outs));
a1177 2
  field dag OutsDPP = getOutsExt<HasDst, DstVT, DstRCDPP>.ret;
  field dag OutsSDWA = getOutsExt<HasDst, DstVT, DstRCDPP>.ret;
a1181 8
  field dag InsDPP = getInsDPP<Src0DPP, Src1DPP, NumSrcArgs, HasModifiers>.ret;
  field dag InsSDWA = getInsSDWA<Src0SDWA, Src1SDWA, NumSrcArgs, HasModifiers, DstVT>.ret;

  field string Asm32 = getAsm32<HasDst, NumSrcArgs, DstVT>.ret;
  field string Asm64 = getAsm64<HasDst, NumSrcArgs, HasModifiers, DstVT>.ret;
  field string AsmDPP = getAsmDPP<HasDst, NumSrcArgs, HasModifiers, DstVT>.ret;
  field string AsmSDWA = getAsmSDWA<HasDst, NumSrcArgs, HasModifiers, DstVT>.ret;
}
d1183 2
a1184 2
class VOP_NO_EXT <VOPProfile p> : VOPProfile <p.ArgVT> {
  let HasExt = 0;
a1196 3
def VOP_I16_I16_I16_I16 : VOPProfile <[i32, i32, i32, i32, untyped]>;
def VOP_F16_F16_F16_F16 : VOPProfile <[f16, f16, f16, f16, untyped]>;

d1219 4
a1222 4
  let Asm32 = "$vdst, vcc, $src0, $src1";
  let Asm64 = "$vdst, $sdst, $src0, $src1";
  let Outs32 = (outs DstRC:$vdst);
  let Outs64 = (outs DstRC:$vdst, SReg_64:$sdst);
d1234 4
a1237 17
  let Asm32 = "$vdst, vcc, $src0, $src1, vcc";
  let Asm64 = "$vdst, $sdst, $src0, $src1, $src2";
  let Outs32 = (outs DstRC:$vdst);
  let Outs64 = (outs DstRC:$vdst, SReg_64:$sdst);

  // Suppress src2 implied by type since the 32-bit encoding uses an
  // implicit VCC use.
  let Ins32 = (ins Src0RC32:$src0, Src1RC32:$src1);
}

// Read in from vcc or arbitrary SGPR
def VOP2e_I32_I32_I32_I1 : VOPProfile<[i32, i32, i32, i1]> {
  let Src0RC32 = VCSrc_32; // See comment in def VOP2b_I32_I1_I32_I32_I1 above.
  let Asm32 = "$vdst, $src0, $src1, vcc";
  let Asm64 = "$vdst, $src0, $src1, $src2";
  let Outs32 = (outs DstRC:$vdst);
  let Outs64 = (outs DstRC:$vdst);
a1265 1
  let Outs64 = (outs DstRC:$sdst);
d1269 2
a1270 7
  let Ins64 = (ins FPInputMods:$src0_modifiers, Src0RC64:$src0, Src1RC64:$src1);
  let Asm64 = "$sdst, $src0_modifiers, $src1";
  let InsSDWA = (ins FPInputMods:$src0_fmodifiers, Src0RC64:$src0,
                     IntInputMods:$src1_imodifiers, Src1RC64:$src1,
                     clampmod:$clamp, src0_sel:$src0_sel, src1_sel:$src1_sel);
  let AsmSDWA = " vcc, $src0_fmodifiers, $src1_imodifiers$clamp $src0_sel $src1_sel";

d1284 5
d1291 3
a1293 9
def VOP_MADAK : VOPProfile <[f32, f32, f32, f32]> {
  field dag Ins32 = (ins VCSrc_32:$src0, VGPR_32:$src1, u32kimm:$imm);
  field string Asm32 = "$vdst, $src0, $src1, $imm";
  field bit HasExt = 0;
}
def VOP_MADMK : VOPProfile <[f32, f32, f32, f32]> {
  field dag Ins32 = (ins VCSrc_32:$src0, u32kimm:$imm, VGPR_32:$src1);
  field string Asm32 = "$vdst, $src0, $imm, $src1";
  field bit HasExt = 0;
d1299 2
a1300 14
  let InsDPP = (ins FPInputMods:$src0_modifiers, Src0RC32:$src0,
                    FPInputMods:$src1_modifiers, Src1RC32:$src1,
                    VGPR_32:$src2, // stub argument
                    dpp_ctrl:$dpp_ctrl, row_mask:$row_mask,
                    bank_mask:$bank_mask, bound_ctrl:$bound_ctrl);
  let InsSDWA = (ins FPInputMods:$src0_fmodifiers, Src0RC32:$src0,
                     FPInputMods:$src1_fmodifiers, Src1RC32:$src1,
                     VGPR_32:$src2, // stub argument
                     clampmod:$clamp, dst_sel:$dst_sel, dst_unused:$dst_unused,
                     src0_sel:$src0_sel, src1_sel:$src1_sel);
  let Asm32 = getAsm32<1, 2, f32>.ret;
  let Asm64 = getAsm64<1, 2, HasModifiers, f32>.ret;
  let AsmDPP = getAsmDPP<1, 2, HasModifiers, f32>.ret;
  let AsmSDWA = getAsmSDWA<1, 2, HasModifiers, f32>.ret;
a1305 1
// This class is used only with VOPC instructions. Use $sdst for out operand
d1316 1
a1316 1
        (inst p.DstRC:$sdst),
d1319 1
a1319 1
        (inst p.DstRC:$sdst, p.Src0RC32:$src0),
d1322 1
a1322 1
        (inst p.DstRC:$sdst, p.Src0RC32:$src0, p.Src1RC32:$src1),
d1371 1
a1371 1
  SIMCInstr <opName#"_e32", SIEncodingFamily.NONE>,
d1382 1
a1382 1
  SIMCInstr <opName#"_e32", SIEncodingFamily.SI> {
a1383 2
  let DecoderNamespace = "SICI";
  let DisableDecoder = DisableSIDecoder;
d1388 1
a1388 1
  SIMCInstr <opName#"_e32", SIEncodingFamily.VI> {
a1389 2
  let DecoderNamespace = "VI";
  let DisableDecoder = DisableVIDecoder;
a1401 43
class VOP1_DPP <vop1 op, string opName, VOPProfile p> :
  VOP1_DPPe <op.VI>,
  VOP_DPP <p.OutsDPP, p.InsDPP, opName#p.AsmDPP, [], p.HasModifiers> {
  let AssemblerPredicates = !if(p.HasExt, [isVI], [DisableInst]);
  let DecoderNamespace = "DPP";
  let DisableDecoder = DisableVIDecoder;
  let src0_modifiers = !if(p.HasModifiers, ?, 0);
  let src1_modifiers = 0;
}

class SDWADisableFields <VOPProfile p> {
  bits<8> src0 = !if(!eq(p.NumSrcArgs, 0), 0, ?);
  bits<3> src0_sel = !if(!eq(p.NumSrcArgs, 0), 6, ?);
  bits<2> src0_fmodifiers = !if(!eq(p.NumSrcArgs, 0),
                                0,
                                !if(p.HasModifiers, ?, 0));
  bits<1> src0_imodifiers = !if(!eq(p.NumSrcArgs, 0),
                                0,
                                !if(p.HasModifiers, 0, ?));
  bits<3> src1_sel = !if(!eq(p.NumSrcArgs, 0), 6,
                         !if(!eq(p.NumSrcArgs, 1), 6,
                             ?));
  bits<2> src1_fmodifiers = !if(!eq(p.NumSrcArgs, 0), 0,
                                !if(!eq(p.NumSrcArgs, 1), 0,
                                    !if(p.HasModifiers, ?, 0)));
  bits<1> src1_imodifiers = !if(!eq(p.NumSrcArgs, 0), 0,
                                !if(!eq(p.NumSrcArgs, 1), 0,
                                    !if(p.HasModifiers, 0, ?)));
  bits<3> dst_sel = !if(p.HasDst, ?, 6);
  bits<2> dst_unused = !if(p.HasDst, ?, 2);
  bits<1> clamp = !if(!eq(p.NumSrcArgs, 0), 0, ?);
}

class VOP1_SDWA <vop1 op, string opName, VOPProfile p> :
  VOP1_SDWAe <op.VI>,
  VOP_SDWA <p.OutsSDWA, p.InsSDWA, opName#p.AsmSDWA, [], p.HasModifiers>,
  SDWADisableFields <p> {
  let AsmMatchConverter = "cvtSdwaVOP1";
  let AssemblerPredicates = !if(p.HasExt, [isVI], [DisableInst]);
  let DecoderNamespace = "SDWA";
  let DisableDecoder = DisableVIDecoder;
}

d1413 1
a1413 1
  SIMCInstr<opName#"_e32", SIEncodingFamily.NONE>,
d1421 1
a1421 1
  SIMCInstr <opName#"_e32", SIEncodingFamily.SI> {
a1422 2
  let DecoderNamespace = "SICI";
  let DisableDecoder = DisableSIDecoder;
d1427 1
a1427 1
  SIMCInstr <opName#"_e32", SIEncodingFamily.VI> {
a1428 2
  let DecoderNamespace = "VI";
  let DisableDecoder = DisableVIDecoder;
a1451 20
class VOP2_DPP <vop2 op, string opName, VOPProfile p> :
  VOP2_DPPe <op.VI>,
  VOP_DPP <p.OutsDPP, p.InsDPP, opName#p.AsmDPP, [], p.HasModifiers> {
  let AssemblerPredicates = !if(p.HasExt, [isVI], [DisableInst]);
  let DecoderNamespace = "DPP";
  let DisableDecoder = DisableVIDecoder;
  let src0_modifiers = !if(p.HasModifiers, ?, 0);
  let src1_modifiers = !if(p.HasModifiers, ?, 0);
}

class VOP2_SDWA <vop2 op, string opName, VOPProfile p> :
  VOP2_SDWAe <op.VI>,
  VOP_SDWA <p.OutsSDWA, p.InsSDWA, opName#p.AsmSDWA, [], p.HasModifiers>,
  SDWADisableFields <p> {
  let AsmMatchConverter = "cvtSdwaVOP2";
  let AssemblerPredicates = !if(p.HasExt, [isVI], [DisableInst]);
  let DecoderNamespace = "SDWA";
  let DisableDecoder = DisableVIDecoder;
}

d1474 2
a1475 3
class VOP3_Pseudo <dag outs, dag ins, list<dag> pattern, string opName,
                   bit HasMods = 0, bit VOP3Only = 0> :
  VOP3Common <outs, ins, "", pattern, HasMods, VOP3Only>,
d1477 1
a1477 1
  SIMCInstr<opName#"_e64", SIEncodingFamily.NONE>,
d1486 2
a1487 3
class VOP3_Real_si <bits<9> op, dag outs, dag ins, string asm, string opName,
                    bit HasMods = 0, bit VOP3Only = 0> :
  VOP3Common <outs, ins, asm, [], HasMods, VOP3Only>,
d1489 1
a1489 1
  SIMCInstr<opName#"_e64", SIEncodingFamily.SI> {
a1490 2
  let DecoderNamespace = "SICI";
  let DisableDecoder = DisableSIDecoder;
d1493 2
a1494 3
class VOP3_Real_vi <bits<10> op, dag outs, dag ins, string asm, string opName,
                    bit HasMods = 0, bit VOP3Only = 0> :
  VOP3Common <outs, ins, asm, [], HasMods, VOP3Only>,
d1496 1
a1496 21
  SIMCInstr <opName#"_e64", SIEncodingFamily.VI> {
  let AssemblerPredicates = [isVI];
  let DecoderNamespace = "VI";
  let DisableDecoder = DisableVIDecoder;
}

class VOP3_C_Real_si <bits<9> op, dag outs, dag ins, string asm, string opName,
                     bit HasMods = 0, bit VOP3Only = 0> :
  VOP3Common <outs, ins, asm, [], HasMods, VOP3Only>,
  VOP3ce <op>,
  SIMCInstr<opName#"_e64", SIEncodingFamily.SI> {
  let AssemblerPredicates = [isSICI];
  let DecoderNamespace = "SICI";
  let DisableDecoder = DisableSIDecoder;
}

class VOP3_C_Real_vi <bits<10> op, dag outs, dag ins, string asm, string opName,
                      bit HasMods = 0, bit VOP3Only = 0> :
  VOP3Common <outs, ins, asm, [], HasMods, VOP3Only>,
  VOP3ce_vi <op>,
  SIMCInstr <opName#"_e64", SIEncodingFamily.VI> {
a1497 2
  let DecoderNamespace = "VI";
  let DisableDecoder = DisableVIDecoder;
d1500 2
a1501 3
class VOP3b_Real_si <bits<9> op, dag outs, dag ins, string asm, string opName,
                     bit HasMods = 0, bit VOP3Only = 0> :
  VOP3Common <outs, ins, asm, [], HasMods, VOP3Only>,
d1503 1
a1503 1
  SIMCInstr<opName#"_e64", SIEncodingFamily.SI> {
a1504 2
  let DecoderNamespace = "SICI";
  let DisableDecoder = DisableSIDecoder;
d1507 2
a1508 3
class VOP3b_Real_vi <bits<10> op, dag outs, dag ins, string asm, string opName,
                     bit HasMods = 0, bit VOP3Only = 0> :
  VOP3Common <outs, ins, asm, [], HasMods, VOP3Only>,
d1510 1
a1510 1
  SIMCInstr <opName#"_e64", SIEncodingFamily.VI> {
a1511 22
  let DecoderNamespace = "VI";
  let DisableDecoder = DisableVIDecoder;
}

class VOP3e_Real_si <bits<9> op, dag outs, dag ins, string asm, string opName,
                     bit HasMods = 0, bit VOP3Only = 0> :
  VOP3Common <outs, ins, asm, [], HasMods, VOP3Only>,
  VOP3e <op>,
  SIMCInstr<opName#"_e64", SIEncodingFamily.SI> {
  let AssemblerPredicates = [isSICI];
  let DecoderNamespace = "SICI";
  let DisableDecoder = DisableSIDecoder;
}

class VOP3e_Real_vi <bits<10> op, dag outs, dag ins, string asm, string opName,
                     bit HasMods = 0, bit VOP3Only = 0> :
  VOP3Common <outs, ins, asm, [], HasMods, VOP3Only>,
  VOP3e_vi <op>,
  SIMCInstr <opName#"_e64", SIEncodingFamily.VI> {
  let AssemblerPredicates = [isVI];
  let DecoderNamespace = "VI";
  let DisableDecoder = DisableVIDecoder;
d1515 1
a1515 1
                   string opName, int NumSrcArgs, bit HasMods = 1, bit VOP3Only = 0> {
d1519 1
a1519 1
  def _si : VOP3_Real_si <op.SI3, outs, ins, asm, opName, HasMods, VOP3Only>,
d1523 1
a1523 1
  def _vi : VOP3_Real_vi <op.VI3, outs, ins, asm, opName, HasMods, VOP3Only>,
d1532 1
a1532 1
  def "" : VOP3_Pseudo <outs, ins, pattern, opName, HasMods>;
d1534 1
a1534 1
  def _si : VOP3_Real_si <op.SI3, outs, ins, asm, opName, HasMods>,
d1537 1
a1537 1
  def _vi : VOP3_Real_vi <op.VI3, outs, ins, asm, opName, HasMods>,
d1544 1
a1544 1
  def "" : VOP3_Pseudo <outs, ins, pattern, opName, HasMods>;
d1546 1
a1546 1
  def _si : VOP3_Real_si <op.SI3, outs, ins, asm, opName, HasMods>,
d1555 1
a1555 1
  def "" : VOP3_Pseudo <outs, ins, pattern, opName, HasMods>,
d1558 1
a1558 1
  def _si : VOP3_Real_si <op.SI3, outs, ins, asm, opName, HasMods>,
d1561 1
a1561 1
  def _vi : VOP3_Real_vi <op.VI3, outs, ins, asm, opName, HasMods>,
d1569 1
a1569 1
  def "" : VOP3_Pseudo <outs, ins, pattern, opName, HasMods>,
d1572 1
a1572 1
  def _si : VOP3_Real_si <op.SI3, outs, ins, asm, opName, HasMods>,
d1582 2
a1583 15
                        bit HasMods = 1, bit useSrc2Input = 0, bit VOP3Only = 0> {
  def "" : VOP3_Pseudo <outs, ins, pattern, opName, HasMods, VOP3Only>;

  def _si : VOP3b_Real_si <op.SI3, outs, ins, asm, opName, HasMods, VOP3Only>,
            VOP3DisableFields<1, useSrc2Input, HasMods>;

  def _vi : VOP3b_Real_vi <op.VI3, outs, ins, asm, opName, HasMods, VOP3Only>,
            VOP3DisableFields<1, useSrc2Input, HasMods>;
}

// Same as VOP3b_2_3_m but no 2nd destination (sdst), e.g. v_cndmask_b32.
multiclass VOP3e_2_3_m <vop op, dag outs, dag ins, string asm,
                        list<dag> pattern, string opName, string revOp,
                        bit HasMods = 1, bit useSrc2Input = 0, bit VOP3Only = 0> {
  def "" : VOP3_Pseudo <outs, ins, pattern, opName, HasMods, VOP3Only>;
d1585 1
a1585 1
  def _si : VOP3e_Real_si <op.SI3, outs, ins, asm, opName, HasMods, VOP3Only>,
d1588 1
a1588 1
  def _vi : VOP3e_Real_vi <op.VI3, outs, ins, asm, opName, HasMods, VOP3Only>,
d1597 1
a1597 1
  def "" : VOP3_Pseudo <outs, ins, pattern, opName, HasMods>,
d1603 1
a1603 1
  def _si : VOP3_C_Real_si <op.SI3, outs, ins, asm, opName, HasMods>,
d1609 1
a1609 1
  def _vi : VOP3_C_Real_vi <op.VI3, outs, ins, asm, opName, HasMods>,
d1621 1
a1621 1
             SIMCInstr<opName, SIEncodingFamily.NONE>;
d1625 1
a1625 1
            SIMCInstr <opName, SIEncodingFamily.SI> {
a1626 2
            let DecoderNamespace = "SICI";
            let DisableDecoder = DisableSIDecoder;
d1632 1
a1632 1
            SIMCInstr <opName, SIEncodingFamily.VI> {
a1633 2
            let DecoderNamespace = "VI";
            let DisableDecoder = DisableVIDecoder;
a1643 4

  def _dpp : VOP1_DPP <op, opName, p>;

  def _sdwa : VOP1_SDWA <op, opName, p>;
d1650 1
a1650 1
      [(set P.DstVT:$vdst, (node (P.Src0VT (VOP3Mods0 P.Src0VT:$src0,
d1652 1
a1652 1
      [(set P.DstVT:$vdst, (node P.Src0VT:$src0))])
d1662 1
a1662 1
      [(set P.DstVT:$vdst, (node (P.Src0VT (VOP3Mods0 P.Src0VT:$src0,
d1664 1
a1664 1
      [(set P.DstVT:$vdst, (node P.Src0VT:$src0))]),
a1674 4

  def _dpp : VOP2_DPP <op, opName, p>;

  def _sdwa : VOP2_SDWA <op, opName, p>;
d1682 1
a1682 1
      [(set P.DstVT:$vdst,
d1686 1
a1686 1
      [(set P.DstVT:$vdst, (node P.Src0VT:$src0, P.Src1VT:$src1))]),
d1698 1
a1698 1
        [(set P.DstVT:$vdst,
d1702 1
a1702 1
        [(set P.DstVT:$vdst, (node P.Src0VT:$src0, P.Src1VT:$src1))]),
a1705 27
multiclass VOP2e_Helper <vop2 op, string opName, VOPProfile p,
                         list<dag> pat32, list<dag> pat64,
                         string revOp, bit useSGPRInput> {

  let SchedRW = [Write32Bit] in {
    let Uses = !if(useSGPRInput, [VCC, EXEC], [EXEC]) in {
      defm _e32 : VOP2_m <op, opName, p, pat32, revOp>;
    }

    defm _e64 : VOP3e_2_3_m <op, p.Outs64, p.Ins64, opName#p.Asm64, pat64,
                             opName, revOp, p.HasModifiers, useSGPRInput>;
  }
}

multiclass VOP2eInst <vop2 op, string opName, VOPProfile P,
                      SDPatternOperator node = null_frag,
                      string revOp = opName> : VOP2e_Helper <
  op, opName, P, [],
  !if(P.HasModifiers,
      [(set P.DstVT:$vdst,
           (node (P.Src0VT (VOP3Mods0 P.Src0VT:$src0, i32:$src0_modifiers,
                                      i1:$clamp, i32:$omod)),
                 (P.Src1VT (VOP3Mods P.Src1VT:$src1, i32:$src1_modifiers))))],
      [(set P.DstVT:$vdst, (node P.Src0VT:$src0, P.Src1VT:$src1))]),
  revOp, !eq(P.NumSrcArgs, 3)
>;

d1725 1
a1725 1
      [(set P.DstVT:$vdst,
d1729 1
a1729 1
      [(set P.DstVT:$vdst, (node P.Src0VT:$src0, P.Src1VT:$src1))]),
d1749 1
a1749 1
      [(set P.DstVT:$vdst,
d1753 1
a1753 1
      [(set P.DstVT:$vdst, (node P.Src0VT:$src0, P.Src1VT:$src1))]),
d1757 1
a1757 1
multiclass VOP2MADK <vop2 op, string opName, VOPProfile P, list<dag> pattern = []> {
d1759 1
a1759 1
  def "" : VOP2_Pseudo <P.Outs, P.Ins32, pattern, opName>;
d1762 3
a1764 3
  def _si : VOP2Common <P.Outs, P.Ins32,
                        !strconcat(opName, P.Asm32), []>,
            SIMCInstr <opName#"_e32", SIEncodingFamily.SI>,
a1766 2
            let DecoderNamespace = "SICI";
            let DisableDecoder = DisableSIDecoder;
d1769 3
a1771 3
  def _vi : VOP2Common <P.Outs, P.Ins32,
                        !strconcat(opName, P.Asm32), []>,
            SIMCInstr <opName#"_e32", SIEncodingFamily.VI>,
a1773 2
            let DecoderNamespace = "VI";
            let DisableDecoder = DisableVIDecoder;
d1781 1
a1781 1
  SIMCInstr<opName#"_e32", SIEncodingFamily.NONE> {
a1785 12
class VOPC_SDWA <vopc op, string opName, bit DefExec, VOPProfile p> :
    VOPC_SDWAe <op.VI>,
    VOP_SDWA <p.OutsSDWA, p.InsSDWA, opName#p.AsmSDWA, [], p.HasModifiers>,
    SDWADisableFields <p> {
  let Defs = !if(DefExec, [VCC, EXEC], [VCC]);
  let hasSideEffects = DefExec;
  let AsmMatchConverter = "cvtSdwaVOPC";
  let AssemblerPredicates = !if(p.HasExt, [isVI], [DisableInst]);
  let DecoderNamespace = "SDWA";
  let DisableDecoder = DisableVIDecoder;
}

a1794 1
    let isConvergent = DefExec;
d1799 1
a1799 1
              SIMCInstr <opName#"_e32", SIEncodingFamily.SI> {
d1801 1
a1801 1
      let isConvergent = DefExec;
a1802 2
      let DecoderNamespace = "SICI";
      let DisableDecoder = DisableSIDecoder;
d1809 1
a1809 1
              SIMCInstr <opName#"_e32", SIEncodingFamily.VI> {
d1811 1
a1811 1
      let isConvergent = DefExec;
a1812 2
      let DecoderNamespace = "VI";
      let DisableDecoder = DisableVIDecoder;
d1826 1
a1826 1
  defm _e64 : VOP3_C_m <op, (outs VOPDstS64:$sdst), p.Ins64, opName#p.Asm64, pat64,
a1827 2

  def _sdwa : VOPC_SDWA <op, opName, DefExec, p>;
d1837 1
a1837 1
  defm _e64 : VOP3_C_m <op, (outs VOPDstS64:$sdst), p.Ins64, opName#p.Asm64, pat64,
a1839 5

  def _sdwa : VOPC_SDWA <op, opName, DefExec, p> {
    let src1_fmodifiers = 0;
    let src1_imodifiers = ?;
  }
d1850 1
a1850 1
      [(set i1:$sdst,
d1855 1
a1855 1
      [(set i1:$sdst, (setcc P.Src0VT:$src0, P.Src1VT:$src1, cond))]),
d1864 1
a1864 1
      [(set i1:$sdst,
d1866 1
a1866 1
      [(set i1:$sdst, (AMDGPUfp_class P.Src0VT:$src0, P.Src1VT:$src1))]),
d1902 4
a1918 7

multiclass VOP3_Helper <vop3 op, string opName, dag outs, dag ins, string asm,
                        list<dag> pat, int NumSrcArgs, bit HasMods,
                        bit VOP3Only = 0> : VOP3_m <
    op, outs, ins, opName#" "#asm, pat, opName, NumSrcArgs, HasMods, VOP3Only
>;

d1920 2
a1921 3
                     SDPatternOperator node = null_frag, bit VOP3Only = 0> :
  VOP3_Helper <
  op, opName, (outs P.DstRC.RegClass:$vdst), P.Ins64, P.Asm64,
d1924 1
a1924 1
        [(set P.DstVT:$vdst,
d1929 1
a1929 1
        [(set P.DstVT:$vdst, (node P.Src0VT:$src0, P.Src1VT:$src1,
d1933 1
a1933 1
        [(set P.DstVT:$vdst,
d1937 1
a1937 1
        [(set P.DstVT:$vdst, (node P.Src0VT:$src0, P.Src1VT:$src1))])
d1940 1
a1940 1
        [(set P.DstVT:$vdst,
d1943 2
a1944 2
        [(set P.DstVT:$vdst, (node P.Src0VT:$src0))]))),
  P.NumSrcArgs, P.HasModifiers, VOP3Only
d1953 5
a1957 5
  (outs P.DstRC.RegClass:$vdst),
  (ins FPInputMods:$src0_modifiers, P.Src0RC64:$src0,
       FPInputMods:$src1_modifiers, P.Src1RC64:$src1,
       FPInputMods:$src2_modifiers, P.Src2RC64:$src2,
       clampmod:$clamp,
d1959 2
a1960 2
  "$vdst, $src0_modifiers, $src1_modifiers, $src2_modifiers"#"$clamp"#"$omod",
  [(set P.DstVT:$vdst,
d1969 1
a1969 1
multiclass VOP3bInst <vop op, string opName, VOPProfile P, list<dag> pattern = [], bit VOP3Only = 0> :
d1973 1
a1973 1
  opName, "", 1, 1, VOP3Only
d1992 1
a1992 1
  SIMCInstr<opName, SIEncodingFamily.NONE> {
d2001 1
a2001 5
  SIMCInstr<opName, SIEncodingFamily.SI> {
  let AssemblerPredicate = SIAssemblerPredicate;
  let DecoderNamespace = "SICI";
  let DisableDecoder = DisableSIDecoder;
}
d2007 1
a2007 5
  SIMCInstr<opName, SIEncodingFamily.VI> {
  let AssemblerPredicate = VIAssemblerPredicate;
  let DecoderNamespace = "VI";
  let DisableDecoder = DisableVIDecoder;
}
d2024 1
a2024 1
  SIMCInstr <opName, SIEncodingFamily.NONE> {
d2032 1
a2032 1
  SIMCInstr <opName, SIEncodingFamily.SI> {
a2033 3
  let AssemblerPredicates = [isSICI];
  let DecoderNamespace="SICI";
  let DisableDecoder = DisableSIDecoder;
d2039 1
a2039 6
  SIMCInstr <opName, SIEncodingFamily.VI> {
  let isCodeGenOnly = 0;
  let AssemblerPredicates = [isVI];
  let DecoderNamespace="VI";
  let DisableDecoder = DisableVIDecoder;
}
d2048 1
a2059 15
multiclass DS_1A_RET_ <dsop op, string opName, RegisterClass rc,
  dag outs = (outs rc:$vdst),
  dag ins = (ins VGPR_32:$addr, offset:$offset, gds:$gds),
  string asm = opName#" $vdst, $addr"#"$offset$gds"> {

  def "" : DS_Pseudo <opName, outs, ins, []>;

  let data0 = 0, data1 = 0 in {
    def _si : DS_Off16_Real_si <op.SI, opName, outs, ins, asm>;
    def _vi : DS_Off16_Real_vi <op.VI, opName, outs, ins, asm>;
  }
}

// TODO: DS_1A_RET can be inherited from DS_1A_RET_ but its not working
// for some reason. In fact we can remove this class if use dsop everywhere
d2062 1
a2062 1
  dag ins = (ins VGPR_32:$addr, offset:$offset, gds:$gds),
d2075 2
a2076 2
  dag ins = (ins VGPR_32:$addr, offset0:$offset0, offset1:$offset1,
                 gds:$gds),
d2089 1
a2089 1
  dag ins = (ins VGPR_32:$addr, rc:$data0, offset:$offset, gds:$gds),
d2101 1
a2101 15
multiclass DS_1A_Off8_NORET <bits<8> op, string opName,
  dag outs = (outs),
  dag ins = (ins VGPR_32:$addr,
              offset0:$offset0, offset1:$offset1, gds:$gds),
  string asm = opName#" $addr $offset0"#"$offset1$gds"> {

  def "" : DS_Pseudo <opName, outs, ins, []>;

  let data0 = 0, data1 = 0, vdst = 0, AsmMatchConverter = "cvtDSOffset01" in {
    def _si : DS_Real_si <op, opName, outs, ins, asm>;
    def _vi : DS_Real_vi <op, opName, outs, ins, asm>;
  }
}

multiclass DS_1A2D_Off8_NORET <bits<8> op, string opName, RegisterClass rc,
d2104 2
a2105 2
              offset0:$offset0, offset1:$offset1, gds:$gds),
  string asm = opName#" $addr, $data0, $data1$offset0$offset1$gds"> {
d2118 1
a2118 1
  dag ins = (ins VGPR_32:$addr, rc:$data0, offset:$offset, gds:$gds),
a2131 17
multiclass DS_1A1D_PERMUTE <bits<8> op, string opName, RegisterClass rc,
                            SDPatternOperator node = null_frag,
  dag outs = (outs rc:$vdst),
  dag ins = (ins VGPR_32:$addr, rc:$data0, offset:$offset),
  string asm = opName#" $vdst, $addr, $data0"#"$offset"> {

  let mayLoad = 0, mayStore = 0, isConvergent = 1 in {
    def "" : DS_Pseudo <opName, outs, ins,
     [(set i32:$vdst,
         (node (DS1Addr1Offset i32:$addr, i16:$offset), i32:$data0))]>;

    let data1 = 0, gds = 0  in {
      def "_vi" : DS_Off16_Real_vi <op, opName, outs, ins, asm>;
    }
  }
}

d2150 1
a2150 1
                      offset:$offset, gds:$gds)
d2157 1
a2157 1
                 offset:$offset, gds:$gds),
d2171 1
a2171 1
  dag ins = (ins offset:$offset, gds:$gds),
d2186 1
a2186 1
  dag ins = (ins VGPR_32:$addr, offset:$offset),
d2212 1
a2212 1
  dag ins = (ins VGPR_32:$addr, offset:$offset, gds:$gds),
d2231 1
a2231 1
  SIMCInstr<opName, SIEncodingFamily.NONE> {
d2240 1
a2240 4
  SIMCInstr<opName, SIEncodingFamily.SI> {
  let DecoderNamespace="SICI";
  let DisableDecoder = DisableSIDecoder;
}
d2245 1
a2245 4
  SIMCInstr <opName, SIEncodingFamily.VI> {
  let DecoderNamespace="VI";
  let DisableDecoder = DisableVIDecoder;
}
d2316 1
a2316 1
  SIMCInstr<opName, SIEncodingFamily.NONE> {
d2334 1
a2334 1
  SIMCInstr<opName, SIEncodingFamily.SI> {
a2335 3
  let AssemblerPredicate = SIAssemblerPredicate;
  let DecoderNamespace="SICI";
  let DisableDecoder = DisableSIDecoder;
d2342 1
a2342 1
  SIMCInstr<opName, SIEncodingFamily.VI> {
a2343 3
  let AssemblerPredicate = VIAssemblerPredicate;
  let DecoderNamespace="VI";
  let DisableDecoder = DisableVIDecoder;
a2351 4
  let DisableWQM = 1 in {
    def "_exact" : MUBUF_Pseudo <opName, outs, ins, []>;
  }

a2403 15
multiclass MUBUFAtomicOther_m <mubuf op, string opName, dag outs, dag ins,
                               string asm, list<dag> pattern, bit is_return> {

  def "" : MUBUF_Pseudo <opName, outs, ins, pattern>,
           AtomicNoRet<opName, is_return>;

  let tfe = 0 in {
    let addr64 = 0 in {
      def _si : MUBUF_Real_si <op, opName, outs, ins, asm>;
    }

    def _vi : MUBUF_Real_vi <op, opName, outs, ins, asm>;
  }
}

d2407 1
a2407 2
  let mayStore = 1, mayLoad = 1, hasPostISelHook = 1, hasSideEffects = 1,
      DisableWQM = 1 in {
d2410 1
a2410 1
    let glc = 0, AsmMatchConverter = "cvtMubufAtomic" in {
d2415 2
a2416 2
             SCSrc_32:$soffset, offset:$offset, slc:$slc),
        name#" $vdata, $vaddr, $srsrc, $soffset addr64$offset$slc", [], 0
d2421 1
a2421 1
        (ins rc:$vdata, SReg_128:$srsrc, SCSrc_32:$soffset, offset:$offset,
d2423 1
a2423 1
        name#" $vdata, off, $srsrc, $soffset$offset$slc", [], 0
a2424 28

      let offen = 1, idxen = 0 in {
        defm _OFFEN : MUBUFAtomicOther_m <
          op, name#"_offen", (outs),
          (ins rc:$vdata, VGPR_32:$vaddr, SReg_128:$srsrc, SCSrc_32:$soffset,
                offset:$offset, slc:$slc),
          name#" $vdata, $vaddr, $srsrc, $soffset offen$offset$slc", [], 0
        >;
      }

      let offen = 0, idxen = 1 in {
        defm _IDXEN : MUBUFAtomicOther_m <
          op, name#"_idxen", (outs),
          (ins rc:$vdata, VGPR_32:$vaddr, SReg_128:$srsrc, SCSrc_32:$soffset,
                offset:$offset, slc:$slc),
          name#" $vdata, $vaddr, $srsrc, $soffset idxen$offset$slc", [], 0
        >;
      }

      let offen = 1, idxen = 1 in {
        defm _BOTHEN : MUBUFAtomicOther_m <
          op, name#"_bothen", (outs),
          (ins rc:$vdata, VReg_64:$vaddr, SReg_128:$srsrc, SCSrc_32:$soffset,
                offset:$offset, slc:$slc),
          name#" $vdata, $vaddr, $srsrc, $soffset idxen offen$offset$slc",
          [], 0
        >;
      }
a2428 1
        AsmMatchConverter = "cvtMubufAtomicReturn",
d2434 2
a2435 2
             SCSrc_32:$soffset, offset:$offset, slc:$slc),
        name#" $vdata, $vaddr, $srsrc, $soffset addr64$offset glc$slc",
d2444 2
a2445 2
             offset:$offset, slc:$slc),
        name#" $vdata, off, $srsrc, $soffset$offset glc$slc",
a2450 29
      let offen = 1, idxen = 0 in {
        defm _RTN_OFFEN : MUBUFAtomicOther_m <
          op, name#"_rtn_offen", (outs rc:$vdata),
          (ins rc:$vdata_in, VGPR_32:$vaddr, SReg_128:$srsrc, SCSrc_32:$soffset,
                offset:$offset, slc:$slc),
          name#" $vdata, $vaddr, $srsrc, $soffset offen$offset glc$slc",
          [], 1
        >;
      }

      let offen = 0, idxen = 1 in {
        defm _RTN_IDXEN : MUBUFAtomicOther_m <
          op, name#"_rtn_idxen", (outs rc:$vdata),
          (ins rc:$vdata_in, VGPR_32:$vaddr, SReg_128:$srsrc, SCSrc_32:$soffset,
                offset:$offset, slc:$slc),
          name#" $vdata, $vaddr, $srsrc, $soffset idxen$offset glc$slc",
          [], 1
        >;
      }

      let offen = 1, idxen = 1 in {
        defm _RTN_BOTHEN : MUBUFAtomicOther_m <
          op, name#"_rtn_bothen", (outs rc:$vdata),
          (ins rc:$vdata_in, VReg_64:$vaddr, SReg_128:$srsrc, SCSrc_32:$soffset,
                offset:$offset, slc:$slc),
          name#" $vdata, $vaddr, $srsrc, $soffset idxen offen$offset glc$slc",
          [], 1
        >;
      }
d2466 2
a2467 2
                           offset:$offset, glc:$glc, slc:$slc, tfe:$tfe),
                           name#" $vdata, off, $srsrc, $soffset$offset$glc$slc$tfe",
d2476 1
a2476 1
                           SCSrc_32:$soffset, offset:$offset, glc:$glc, slc:$slc,
d2478 1
a2478 1
                           name#" $vdata, $vaddr, $srsrc, $soffset offen$offset$glc$slc$tfe", []>;
d2484 1
a2484 1
                           SCSrc_32:$soffset, offset:$offset, glc:$glc,
d2486 1
a2486 1
                           name#" $vdata, $vaddr, $srsrc, $soffset idxen$offset$glc$slc$tfe", []>;
d2492 2
a2493 2
                           offset:$offset, glc:$glc, slc:$slc, tfe:$tfe),
                           name#" $vdata, $vaddr, $srsrc, $soffset idxen offen$offset$glc$slc$tfe", []>;
d2499 1
a2499 1
                                SCSrc_32:$soffset, offset:$offset,
d2501 2
a2502 1
                           name#" $vdata, $vaddr, $srsrc, $soffset addr64$offset$glc$slc$tfe",
d2514 7
d2524 2
a2525 2
                              offset:$offset, glc:$glc, slc:$slc, tfe:$tfe),
                              name#" $vdata, off, $srsrc, $soffset$offset$glc$slc$tfe",
d2533 1
a2533 1
                              SCSrc_32:$soffset, offset:$offset, glc:$glc,
d2535 2
a2536 2
                             name#" $vdata, $vaddr, $srsrc, $soffset offen"#
                             "$offset$glc$slc$tfe", []>;
d2542 1
a2542 1
                           SCSrc_32:$soffset, offset:$offset, glc:$glc,
d2544 1
a2544 1
                           name#" $vdata, $vaddr, $srsrc, $soffset idxen$offset$glc$slc$tfe", []>;
d2550 2
a2551 2
                           offset:$offset, glc:$glc, slc:$slc, tfe:$tfe),
                           name#" $vdata, $vaddr, $srsrc, $soffset idxen offen$offset$glc$slc$tfe", []>;
d2558 1
a2558 1
                                         offset:$offset, glc:$glc, slc:$slc,
d2561 1
a2561 1
                                         "$offset$glc$slc$tfe",
d2598 1
a2598 1
      SIMCInstr<opName, SIEncodingFamily.NONE> {
d2605 1
a2605 1
    SIMCInstr<opName, SIEncodingFamily.SI> {
a2606 1
  let DecoderNamespace="CI";
d2611 1
a2611 1
    SIMCInstr<opName, SIEncodingFamily.VI> {
a2612 2
  let DecoderNamespace="VI";
  let DisableDecoder = DisableVIDecoder;
d2628 2
a2629 2
    dag ins = (ins VReg_64:$addr, glc:$glc, slc:$slc, tfe:$tfe),
    string asm = asm_name#" $vdst, $addr$glc$slc$tfe"> {
d2644 3
a2646 3
    dag ins = (ins VReg_64:$addr, vdataClass:$data, glc:$glc,
                   slc:$slc, tfe:$tfe),
    string asm = asm_name#" $addr, $data$glc$slc$tfe"> {
a2658 2
    ValueType vt, SDPatternOperator atomic = null_frag,
    ValueType data_vt = vt,
d2660 1
d2664 1
a2664 1
    def "" : FLAT_Pseudo <NAME, (outs),
d2666 1
a2666 1
                               slc:$slc, tfe:$tfe), []>,
d2669 1
a2669 1
    def _ci : FLAT_Real_ci <op.CI, NAME, (outs),
d2671 1
a2671 1
                                 slc:$slc, tfe:$tfe),
d2674 1
a2674 1
    def _vi : FLAT_Real_vi <op.VI, NAME, (outs),
d2676 1
a2676 1
                                 slc:$slc, tfe:$tfe),
d2681 4
a2684 7
    defm _RTN : FLAT_AtomicRet_m <
      op, (outs vdst_rc:$vdst),
      (ins VReg_64:$addr, data_rc:$data, slc:$slc, tfe:$tfe),
      asm_name#" $vdst, $addr, $data glc$slc$tfe",
      [(set vt:$vdst,
         (atomic (FLATAtomic i64:$addr, i1:$slc, i1:$tfe), data_vt:$data))]
    >;
a2692 15
class mimg <bits<7> si, bits<7> vi = si> {
  field bits<7> SI = si;
  field bits<7> VI = vi;
}

class MIMG_Helper <dag outs, dag ins, string asm,
                   string dns=""> : MIMG<outs, ins, asm,[]> {
  let mayLoad = 1;
  let mayStore = 0;
  let hasPostISelHook = 1;
  let DecoderNamespace = dns;
  let isAsmParserOnly = !if(!eq(dns,""), 1, 0);
  let AsmMatchConverter = "cvtMIMG";
}

d2695 2
a2696 2
                             RegisterClass addr_rc,
                             string dns=""> : MIMG_Helper <
d2698 6
a2703 5
  (ins addr_rc:$vaddr, SReg_256:$srsrc,
       dmask:$dmask, unorm:$unorm, glc:$glc, slc:$slc,
       r128:$r128, tfe:$tfe, lwe:$lwe, da:$da),
  asm#" $vdata, $vaddr, $srsrc$dmask$unorm$glc$slc$r128$tfe$lwe$da",
  dns>, MIMGe<op> {
d2705 3
d2713 1
a2713 2
  def _V1 : MIMG_NoSampler_Helper <op, asm, dst_rc, VGPR_32,
                                   !if(!eq(channels, 1), "AMDGPU", "")>,
a2727 93
class MIMG_Store_Helper <bits<7> op, string asm,
                         RegisterClass data_rc,
                         RegisterClass addr_rc> : MIMG_Helper <
  (outs),
  (ins data_rc:$vdata, addr_rc:$vaddr, SReg_256:$srsrc,
       dmask:$dmask, unorm:$unorm, glc:$glc, slc:$slc,
       r128:$r128, tfe:$tfe, lwe:$lwe, da:$da),
  asm#" $vdata, $vaddr, $srsrc$dmask$unorm$glc$slc$r128$tfe$lwe$da"
     >, MIMGe<op> {
  let ssamp = 0;
  let mayLoad = 1; // TableGen requires this for matching with the intrinsics
  let mayStore = 1;
  let hasSideEffects = 1;
  let hasPostISelHook = 0;
  let DisableWQM = 1;
}

multiclass MIMG_Store_Addr_Helper <bits<7> op, string asm,
                                  RegisterClass data_rc,
                                  int channels> {
  def _V1 : MIMG_Store_Helper <op, asm, data_rc, VGPR_32>,
            MIMG_Mask<asm#"_V1", channels>;
  def _V2 : MIMG_Store_Helper <op, asm, data_rc, VReg_64>,
            MIMG_Mask<asm#"_V2", channels>;
  def _V4 : MIMG_Store_Helper <op, asm, data_rc, VReg_128>,
            MIMG_Mask<asm#"_V4", channels>;
}

multiclass MIMG_Store <bits<7> op, string asm> {
  defm _V1 : MIMG_Store_Addr_Helper <op, asm, VGPR_32, 1>;
  defm _V2 : MIMG_Store_Addr_Helper <op, asm, VReg_64, 2>;
  defm _V3 : MIMG_Store_Addr_Helper <op, asm, VReg_96, 3>;
  defm _V4 : MIMG_Store_Addr_Helper <op, asm, VReg_128, 4>;
}

class MIMG_Atomic_Helper <string asm, RegisterClass data_rc,
                          RegisterClass addr_rc> : MIMG_Helper <
    (outs data_rc:$vdst),
    (ins data_rc:$vdata, addr_rc:$vaddr, SReg_256:$srsrc,
         dmask:$dmask, unorm:$unorm, glc:$glc, slc:$slc,
         r128:$r128, tfe:$tfe, lwe:$lwe, da:$da),
    asm#" $vdst, $vaddr, $srsrc$dmask$unorm$glc$slc$r128$tfe$lwe$da"
  > {
  let mayStore = 1;
  let hasSideEffects = 1;
  let hasPostISelHook = 0;
  let DisableWQM = 1;
  let Constraints = "$vdst = $vdata";
  let AsmMatchConverter = "cvtMIMGAtomic";
}

class MIMG_Atomic_Real_si<mimg op, string name, string asm,
  RegisterClass data_rc, RegisterClass addr_rc> :
  MIMG_Atomic_Helper<asm, data_rc, addr_rc>,
  SIMCInstr<name, SIEncodingFamily.SI>,
  MIMGe<op.SI> {
  let isCodeGenOnly = 0;
  let AssemblerPredicates = [isSICI];
  let DecoderNamespace = "SICI";
  let DisableDecoder = DisableSIDecoder;
}

class MIMG_Atomic_Real_vi<mimg op, string name, string asm,
  RegisterClass data_rc, RegisterClass addr_rc> :
  MIMG_Atomic_Helper<asm, data_rc, addr_rc>,
  SIMCInstr<name, SIEncodingFamily.VI>,
  MIMGe<op.VI> {
  let isCodeGenOnly = 0;
  let AssemblerPredicates = [isVI];
  let DecoderNamespace = "VI";
  let DisableDecoder = DisableVIDecoder;
}

multiclass MIMG_Atomic_Helper_m <mimg op, string name, string asm,
                                 RegisterClass data_rc, RegisterClass addr_rc> {
  let isPseudo = 1, isCodeGenOnly = 1 in {
    def "" : MIMG_Atomic_Helper<asm, data_rc, addr_rc>,
             SIMCInstr<name, SIEncodingFamily.NONE>;
  }

  let ssamp = 0 in {
    def _si : MIMG_Atomic_Real_si<op, name, asm, data_rc, addr_rc>;

    def _vi : MIMG_Atomic_Real_vi<op, name, asm, data_rc, addr_rc>;
  }
}

multiclass MIMG_Atomic <mimg op, string asm, RegisterClass data_rc = VGPR_32> {
  defm _V1 : MIMG_Atomic_Helper_m <op, asm # "_V1", asm, data_rc, VGPR_32>;
  defm _V2 : MIMG_Atomic_Helper_m <op, asm # "_V2", asm, data_rc, VReg_64>;
  defm _V4 : MIMG_Atomic_Helper_m <op, asm # "_V3", asm, data_rc, VReg_128>;
}

d2730 2
a2731 3
                           RegisterClass src_rc,
                           int wqm,
                           string dns=""> : MIMG_Helper <
d2733 9
a2741 5
  (ins src_rc:$vaddr, SReg_256:$srsrc, SReg_128:$ssamp,
       dmask:$dmask, unorm:$unorm, glc:$glc, slc:$slc,
       r128:$r128, tfe:$tfe, lwe:$lwe, da:$da),
  asm#" $vdata, $vaddr, $srsrc, $ssamp$dmask$unorm$glc$slc$r128$tfe$lwe$da",
  dns>, MIMGe<op> {
d2748 1
a2748 2
  def _V1 : MIMG_Sampler_Helper <op, asm, dst_rc, VGPR_32, wqm,
                                 !if(!eq(channels, 1), "AMDGPU", "")>,
d2760 5
a2764 5
multiclass MIMG_Sampler <bits<7> op, string asm, int wqm=0> {
  defm _V1 : MIMG_Sampler_Src_Helper<op, asm, VGPR_32, 1, wqm>;
  defm _V2 : MIMG_Sampler_Src_Helper<op, asm, VReg_64, 2, wqm>;
  defm _V3 : MIMG_Sampler_Src_Helper<op, asm, VReg_96, 3, wqm>;
  defm _V4 : MIMG_Sampler_Src_Helper<op, asm, VReg_128, 4, wqm>;
d2767 6
a2772 1
multiclass MIMG_Sampler_WQM <bits<7> op, string asm> : MIMG_Sampler<op, asm, 1>;
d2777 1
d2779 6
a2784 5
  (ins src_rc:$vaddr, SReg_256:$srsrc, SReg_128:$ssamp,
       dmask:$dmask, unorm:$unorm, glc:$glc, slc:$slc,
       r128:$r128, tfe:$tfe, lwe:$lwe, da:$da),
  asm#" $vdata, $vaddr, $srsrc, $ssamp$dmask$unorm$glc$slc$r128$tfe$lwe$da",
  []>, MIMGe<op> {
d2794 2
a2795 2
  // Therefore, disable all code which updates DMASK by setting this:
  let Gather4 = 1;
a2797 2

  let isAsmParserOnly = 1; // TBD: fix it later
d2815 5
a2819 5
multiclass MIMG_Gather <bits<7> op, string asm, int wqm=0> {
  defm _V1 : MIMG_Gather_Src_Helper<op, asm, VGPR_32, 1, wqm>;
  defm _V2 : MIMG_Gather_Src_Helper<op, asm, VReg_64, 2, wqm>;
  defm _V3 : MIMG_Gather_Src_Helper<op, asm, VReg_96, 3, wqm>;
  defm _V4 : MIMG_Gather_Src_Helper<op, asm, VReg_128, 4, wqm>;
d2822 6
a2827 1
multiclass MIMG_Gather_WQM <bits<7> op, string asm> : MIMG_Gather<op, asm, 1>;
d2899 2
a2900 3
  let KeyCol = [!cast<string>(SIEncodingFamily.NONE)];
  let ValueCols = [[!cast<string>(SIEncodingFamily.SI)],
                   [!cast<string>(SIEncodingFamily.VI)]];
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d17 69
a129 13
def SDTBufferLoad : SDTypeProfile<1, 5,
    [                    // vdata
     SDTCisVT<1, v4i32>, // rsrc
     SDTCisVT<2, i32>,   // vindex
     SDTCisVT<3, i32>,   // offset
     SDTCisVT<4, i1>,    // glc
     SDTCisVT<5, i1>]>;  // slc

def SIbuffer_load : SDNode <"AMDGPUISD::BUFFER_LOAD", SDTBufferLoad,
                            [SDNPMemOperand, SDNPHasChain, SDNPMayLoad]>;
def SIbuffer_load_format : SDNode <"AMDGPUISD::BUFFER_LOAD_FORMAT", SDTBufferLoad,
                            [SDNPMemOperand, SDNPHasChain, SDNPMayLoad]>;

d146 1
a146 1
  SDTypeProfile<1, 2, [SDTCisVT<0, iPTR>, SDTCisSameAs<0,1>, SDTCisSameAs<0,2>]>
d150 54
d207 5
a211 2
defm atomic_inc_global : global_binary_atomic_op<SIatomic_inc>;
defm atomic_dec_global : global_binary_atomic_op<SIatomic_dec>;
d341 30
a396 5
def frameindex_to_targetframeindex : SDNodeXForm<frameindex, [{
  auto FI = cast<FrameIndexSDNode>(N);
  return CurDAG->getTargetFrameIndex(FI->getIndex(), MVT::i32);
}]>;

d403 12
d423 9
d440 1
a440 1
class VGPRImm <dag frag> : PatLeaf<frag, [{
a445 1
  unsigned Limit = 0;
d447 1
a447 1
         Limit < 10 && U != E; ++U, ++Limit) {
d449 2
a450 6

    // If the register class is unknown, it could be an unknown
    // register class that needs to be an SGPR, e.g. an inline asm
    // constraint
    if (!RC || SIRI->isSGPRClass(RC))
      return false;
d452 1
a452 2

  return Limit < 10;
d459 4
a469 1
  let DecoderMethod = "decodeSoppBrTarget";
a475 7
def InterpSlotMatchClass : AsmOperandClass {
  let Name = "InterpSlot";
  let PredicateMethod = "isInterpSlot";
  let ParserMethod = "parseInterpSlot";
  let RenderMethod = "addImmOperands";
}

a477 29
  let ParserMatchClass = InterpSlotMatchClass;
  let OperandType = "OPERAND_IMMEDIATE";
}

def AttrMatchClass : AsmOperandClass {
  let Name = "Attr";
  let PredicateMethod = "isInterpAttr";
  let ParserMethod = "parseInterpAttr";
  let RenderMethod = "addImmOperands";
}

// It appears to be necessary to create a separate operand for this to
// be able to parse attr<num> with no space.
def Attr : Operand<i32> {
  let PrintMethod = "printInterpAttr";
  let ParserMatchClass = AttrMatchClass;
  let OperandType = "OPERAND_IMMEDIATE";
}

def AttrChanMatchClass : AsmOperandClass {
  let Name = "AttrChan";
  let PredicateMethod = "isAttrChan";
  let RenderMethod = "addImmOperands";
}

def AttrChan : Operand<i32> {
  let PrintMethod = "printInterpAttrChan";
  let ParserMatchClass = AttrChanMatchClass;
  let OperandType = "OPERAND_IMMEDIATE";
a486 7
def ExpTgtMatchClass : AsmOperandClass {
  let Name = "ExpTgt";
  let PredicateMethod = "isExpTgt";
  let ParserMethod = "parseExpTgt";
  let RenderMethod = "printExpTgt";
}

a497 5
def VReg32OrOffClass : AsmOperandClass {
  let Name = "VReg32OrOff";
  let ParserMethod = "parseVReg32OrOff";
}

a505 25
// ===----------------------------------------------------------------------===//
// ExpSrc* Special cases for exp src operands which are printed as
// "off" depending on en operand.
// ===----------------------------------------------------------------------===//

def ExpSrc0 : RegisterOperand<VGPR_32> {
  let PrintMethod = "printExpSrc0";
  let ParserMatchClass = VReg32OrOffClass;
}

def ExpSrc1 : RegisterOperand<VGPR_32> {
  let PrintMethod = "printExpSrc1";
  let ParserMatchClass = VReg32OrOffClass;
}

def ExpSrc2 : RegisterOperand<VGPR_32> {
  let PrintMethod = "printExpSrc2";
  let ParserMatchClass = VReg32OrOffClass;
}

def ExpSrc3 : RegisterOperand<VGPR_32> {
  let PrintMethod = "printExpSrc3";
  let ParserMatchClass = VReg32OrOffClass;
}

d550 4
a553 1
def GLC : NamedOperandBit<"GLC", NamedMatchClass<"GLC">>;
a559 2
def exp_compr : NamedOperandBit<"ExpCompr", NamedMatchClass<"ExpCompr">>;
def exp_vm : NamedOperandBit<"ExpVM", NamedMatchClass<"ExpVM">>;
a574 4
def exp_tgt : NamedOperandU8<"ExpTgt", NamedMatchClass<"ExpTgt", 0>> {

}

a576 23
class KImmMatchClass<int size> : AsmOperandClass {
  let Name = "KImmFP"#size;
  let PredicateMethod = "isKImmFP"#size;
  let ParserMethod = "parseImm";
  let RenderMethod = "addKImmFP"#size#"Operands";
}

class kimmOperand<ValueType vt> : Operand<vt> {
  let OperandNamespace = "AMDGPU";
  let OperandType = "OPERAND_KIMM"#vt.Size;
  let PrintMethod = "printU"#vt.Size#"ImmOperand";
  let ParserMatchClass = !cast<AsmOperandClass>("KImmFP"#vt.Size#"MatchClass");
}

// 32-bit VALU immediate operand that uses the constant bus.
def KImmFP32MatchClass : KImmMatchClass<32>;
def f32kimm : kimmOperand<i32>;

// 32-bit VALU immediate operand with a 16-bit value that uses the
// constant bus.
def KImmFP16MatchClass : KImmMatchClass<16>;
def f16kimm : kimmOperand<i16>;

d580 2
a581 2
class FPInputModsMatchClass <int opSize> : AsmOperandClass {
  let Name = "RegOrImmWithFP"#opSize#"InputMods";
d583 1
a583 1
  let PredicateMethod = "isRegOrImmWithFP"#opSize#"InputMods";
a584 3
def FP16InputModsMatchClass : FPInputModsMatchClass<16>;
def FP32InputModsMatchClass : FPInputModsMatchClass<32>;
def FP64InputModsMatchClass : FPInputModsMatchClass<64>;
d586 1
a586 7
class InputMods <AsmOperandClass matchClass> : Operand <i32> {
  let OperandNamespace = "AMDGPU";
  let OperandType = "OPERAND_INPUT_MODS";
  let ParserMatchClass = matchClass;
}

class FPInputMods <FPInputModsMatchClass matchClass> : InputMods <matchClass> {
d588 1
d591 2
a592 6
def FP16InputMods : FPInputMods<FP16InputModsMatchClass>;
def FP32InputMods : FPInputMods<FP32InputModsMatchClass>;
def FP64InputMods : FPInputMods<FP64InputModsMatchClass>;

class IntInputModsMatchClass <int opSize> : AsmOperandClass {
  let Name = "RegOrImmWithInt"#opSize#"InputMods";
d594 1
a594 15
  let PredicateMethod = "isRegOrImmWithInt"#opSize#"InputMods";
}
def Int32InputModsMatchClass : IntInputModsMatchClass<32>;
def Int64InputModsMatchClass : IntInputModsMatchClass<64>;

class IntInputMods <IntInputModsMatchClass matchClass> : InputMods <matchClass> {
  let PrintMethod = "printOperandAndIntInputMods";
}
def Int32InputMods : IntInputMods<Int32InputModsMatchClass>;
def Int64InputMods : IntInputMods<Int64InputModsMatchClass>;

def FPVRegInputModsMatchClass : AsmOperandClass {
  let Name = "VRegWithFPInputMods";
  let ParserMethod = "parseRegWithFPInputMods";
  let PredicateMethod = "isVReg";
d597 1
a597 11
def FPVRegInputMods : InputMods <FPVRegInputModsMatchClass> {
  let PrintMethod = "printOperandAndFPInputMods";
}

def IntVRegInputModsMatchClass : AsmOperandClass {
  let Name = "VRegWithIntInputMods";
  let ParserMethod = "parseRegWithIntInputMods";
  let PredicateMethod = "isVReg";
}

def IntVRegInputMods : InputMods <IntVRegInputModsMatchClass> {
d599 1
a601 1

d609 18
d684 1
a684 1
class EXP_Helper<bit done, SDPatternOperator node = null_frag> : EXPCommon<
d686 15
a700 17
  (ins exp_tgt:$tgt,
       ExpSrc0:$src0, ExpSrc1:$src1, ExpSrc2:$src2, ExpSrc3:$src3,
       exp_vm:$vm, exp_compr:$compr, i8imm:$en),
  "exp$tgt $src0, $src1, $src2, $src3"#!if(done, " done", "")#"$compr$vm",
  [(node (i8 timm:$en), (i1 timm:$vm), (i8 timm:$tgt), (i1 timm:$compr),
         f32:$src0, f32:$src1, f32:$src2, f32:$src3)]> {
  let AsmMatchConverter = "cvtExp";
}

// Split EXP instruction into EXP and EXP_DONE so we can set
// mayLoad for done=1.
multiclass EXP_m<bit done, SDPatternOperator node> {
  let mayLoad = done in {
    let isPseudo = 1, isCodeGenOnly = 1 in {
      def "" : EXP_Helper<done, node>,
               SIMCInstr <"exp"#!if(done, "_done", ""), SIEncodingFamily.NONE>;
    }
d702 4
a705 7
    let done = done in {
      def _si : EXP_Helper<done>,
                SIMCInstr <"exp"#!if(done, "_done", ""), SIEncodingFamily.SI>,
                EXPe {
        let DecoderNamespace = "SICI";
        let DisableDecoder = DisableSIDecoder;
      }
d707 3
a709 7
      def _vi : EXP_Helper<done>,
                SIMCInstr <"exp"#!if(done, "_done", ""), SIEncodingFamily.VI>,
                EXPe_vi {
        let DecoderNamespace = "VI";
        let DisableDecoder = DisableVIDecoder;
      }
    }
d714 1
a714 1
// Vector ALU classes
d717 25
a741 6
class getNumSrcArgs<ValueType Src0, ValueType Src1, ValueType Src2> {
  int ret =
    !if (!eq(Src0.Value, untyped.Value),      0,
      !if (!eq(Src1.Value, untyped.Value),    1,   // VOP1
         !if (!eq(Src2.Value, untyped.Value), 2,   // VOP2
                                              3))); // VOP3
d744 9
a752 8
// Returns the register class to use for the destination of VOP[123C]
// instructions for the given VT.
class getVALUDstForVT<ValueType VT> {
  RegisterOperand ret = !if(!eq(VT.Size, 32), VOPDstOperand<VGPR_32>,
                          !if(!eq(VT.Size, 128), VOPDstOperand<VReg_128>,
                            !if(!eq(VT.Size, 64), VOPDstOperand<VReg_64>,
                              !if(!eq(VT.Size, 16), VOPDstOperand<VGPR_32>,
                              VOPDstOperand<SReg_64>)))); // else VT == i1
d755 23
a777 10
// Returns the register class to use for source 0 of VOP[12C]
// instructions for the given VT.
class getVOPSrc0ForVT<ValueType VT> {
  bit isFP = !if(!eq(VT.Value, f16.Value), 1,
             !if(!eq(VT.Value, f32.Value), 1,
             !if(!eq(VT.Value, f64.Value), 1,
             0)));
  RegisterOperand ret = !if(isFP,
                            !if(!eq(VT.Size, 64), VSrc_f64, !if(!eq(VT.Size, 16), VSrc_f16, VSrc_f32)),
                            !if(!eq(VT.Size, 64), VSrc_b64, !if(!eq(VT.Size, 16), VSrc_b16, VSrc_b32)));
d780 13
a792 4
// Returns the vreg register class to use for source operand given VT
class getVregSrcForVT<ValueType VT> {
  RegisterClass ret = !if(!eq(VT.Size, 128), VReg_128,
                        !if(!eq(VT.Size, 64), VReg_64, VGPR_32));
d795 18
d814 5
a818 23
// Returns the register class to use for sources of VOP3 instructions for the
// given VT.
class getVOP3SrcForVT<ValueType VT> {
  bit isFP = !if(!eq(VT.Value, f16.Value), 1,
             !if(!eq(VT.Value, f32.Value), 1,
             !if(!eq(VT.Value, f64.Value), 1,
             0)));
  RegisterOperand ret =
  !if(!eq(VT.Size, 128),
      VSrc_128,
    !if(!eq(VT.Size, 64),
        !if(isFP,
            VCSrc_f64,
            VCSrc_b64),
        !if(!eq(VT.Value, i1.Value),
            SCSrc_b64,
            !if(isFP,
                !if(!eq(VT.Size, 16), VCSrc_f16, VCSrc_f32),
                !if(!eq(VT.Size, 16), VCSrc_b16, VCSrc_b32)
            )
         )
	   )
     );
d821 7
a827 8
// Returns 1 if the source arguments have modifiers, 0 if they do not.
// XXX - do f16 instructions?
class isFloatType<ValueType SrcVT> {
  bit ret =
    !if(!eq(SrcVT.Value, f16.Value), 1,
    !if(!eq(SrcVT.Value, f32.Value), 1,
    !if(!eq(SrcVT.Value, f64.Value), 1,
    0)));
d830 7
a836 6
class isIntType<ValueType SrcVT> {
  bit ret =
    !if(!eq(SrcVT.Value, i16.Value), 1,
    !if(!eq(SrcVT.Value, i32.Value), 1,
    !if(!eq(SrcVT.Value, i64.Value), 1,
    0)));
d839 8
a847 24
// Return type of input modifiers operand for specified input operand
class getSrcMod <ValueType VT> {
  bit isFP = !if(!eq(VT.Value, f16.Value), 1,
               !if(!eq(VT.Value, f32.Value), 1,
               !if(!eq(VT.Value, f64.Value), 1,
               0)));
  Operand ret =  !if(!eq(VT.Size, 64),
                     !if(isFP, FP64InputMods, Int64InputMods),
                       !if(isFP,
                         !if(!eq(VT.Value, f16.Value),
                            FP16InputMods,
                            FP32InputMods
                          ),
                         Int32InputMods)
                     );
}

// Return type of input modifiers operand specified input operand for SDWA/DPP
class getSrcModExt <ValueType VT> {
    bit isFP = !if(!eq(VT.Value, f16.Value), 1,
               !if(!eq(VT.Value, f32.Value), 1,
               !if(!eq(VT.Value, f64.Value), 1,
               0)));
  Operand ret = !if(isFP, FPVRegInputMods, IntVRegInputMods);
d850 30
a879 5
// Returns the input arguments for VOP[12C] instructions for the given SrcVT.
class getIns32 <RegisterOperand Src0RC, RegisterClass Src1RC, int NumSrcArgs> {
  dag ret = !if(!eq(NumSrcArgs, 1), (ins Src0RC:$src0),               // VOP1
            !if(!eq(NumSrcArgs, 2), (ins Src0RC:$src0, Src1RC:$src1), // VOP2
                                    (ins)));
d882 8
a889 5
// Returns the input arguments for VOP3 instructions for the given SrcVT.
class getIns64 <RegisterOperand Src0RC, RegisterOperand Src1RC,
                RegisterOperand Src2RC, int NumSrcArgs,
                bit HasModifiers, Operand Src0Mod, Operand Src1Mod,
                Operand Src2Mod> {
d891 5
a895 35
  dag ret =
    !if (!eq(NumSrcArgs, 0),
      // VOP1 without input operands (V_NOP, V_CLREXCP)
      (ins),
      /* else */
    !if (!eq(NumSrcArgs, 1),
      !if (!eq(HasModifiers, 1),
        // VOP1 with modifiers
        (ins Src0Mod:$src0_modifiers, Src0RC:$src0,
             clampmod:$clamp, omod:$omod)
      /* else */,
        // VOP1 without modifiers
        (ins Src0RC:$src0)
      /* endif */ ),
    !if (!eq(NumSrcArgs, 2),
      !if (!eq(HasModifiers, 1),
        // VOP 2 with modifiers
        (ins Src0Mod:$src0_modifiers, Src0RC:$src0,
             Src1Mod:$src1_modifiers, Src1RC:$src1,
             clampmod:$clamp, omod:$omod)
      /* else */,
        // VOP2 without modifiers
        (ins Src0RC:$src0, Src1RC:$src1)
      /* endif */ )
    /* NumSrcArgs == 3 */,
      !if (!eq(HasModifiers, 1),
        // VOP3 with modifiers
        (ins Src0Mod:$src0_modifiers, Src0RC:$src0,
             Src1Mod:$src1_modifiers, Src1RC:$src1,
             Src2Mod:$src2_modifiers, Src2RC:$src2,
             clampmod:$clamp, omod:$omod)
      /* else */,
        // VOP3 without modifiers
        (ins Src0RC:$src0, Src1RC:$src1, Src2RC:$src2)
      /* endif */ ))));
d898 341
a1238 2
class getInsDPP <RegisterClass Src0RC, RegisterClass Src1RC, int NumSrcArgs,
                 bit HasModifiers, Operand Src0Mod, Operand Src1Mod> {
d1247 1
a1247 1
                (ins Src0Mod:$src0_modifiers, Src0RC:$src0,
d1258 2
a1259 2
                (ins Src0Mod:$src0_modifiers, Src0RC:$src0,
                     Src1Mod:$src1_modifiers, Src1RC:$src1,
d1271 1
a1271 2
                  bit HasFloatModifiers, Operand Src0Mod, Operand Src1Mod,
                  ValueType DstVT> {
d1277 37
a1313 15
               (ins Src0Mod:$src0_modifiers, Src0RC:$src0,
                    clampmod:$clamp, dst_sel:$dst_sel, dst_unused:$dst_unused,
                    src0_sel:$src0_sel),
            !if(!eq(NumSrcArgs, 2),
               !if(!eq(DstVT.Size, 1),
                  // VOPC_SDWA with modifiers
                  (ins Src0Mod:$src0_modifiers, Src0RC:$src0,
                       Src1Mod:$src1_modifiers, Src1RC:$src1,
                       clampmod:$clamp, src0_sel:$src0_sel, src1_sel:$src1_sel),
                  // VOP2_SDWA or VOPC_SDWA with modifiers
                  (ins Src0Mod:$src0_modifiers, Src0RC:$src0,
                       Src1Mod:$src1_modifiers, Src1RC:$src1,
                       clampmod:$clamp, dst_sel:$dst_sel, dst_unused:$dst_unused,
                       src0_sel:$src0_sel, src1_sel:$src1_sel)),
            (ins)/* endif */)));
d1377 2
a1378 2
  string src0 = "$src0_modifiers";
  string src1 = "$src1_modifiers";
a1416 8
class BitOr<bit a, bit b> {
  bit ret = !if(a, 1, !if(b, 1, 0));
}

class BitAnd<bit a, bit b> {
  bit ret = !if(a, !if(b, 1, 0), 0);
}

a1436 8
  field Operand Src0Mod = getSrcMod<Src0VT>.ret;
  field Operand Src1Mod = getSrcMod<Src1VT>.ret;
  field Operand Src2Mod = getSrcMod<Src2VT>.ret;
  field Operand Src0ModDPP = getSrcModExt<Src0VT>.ret;
  field Operand Src1ModDPP = getSrcModExt<Src1VT>.ret;
  field Operand Src0ModSDWA = getSrcModExt<Src0VT>.ret;
  field Operand Src1ModSDWA = getSrcModExt<Src1VT>.ret;
  
a1439 1
  field bit EmitDst = HasDst; // force dst encoding, see v_movreld_b32 special case
d1441 1
a1441 22
  field bit HasSrc0 = !if(!eq(Src0VT.Value, untyped.Value), 0, 1);
  field bit HasSrc1 = !if(!eq(Src1VT.Value, untyped.Value), 0, 1);
  field bit HasSrc2 = !if(!eq(Src2VT.Value, untyped.Value), 0, 1);

  // TODO: Modifiers logic is somewhat adhoc here, to be refined later
  field bit HasModifiers = isFloatType<Src0VT>.ret;

  field bit HasSrc0FloatMods = isFloatType<Src0VT>.ret;
  field bit HasSrc1FloatMods = isFloatType<Src1VT>.ret;
  field bit HasSrc2FloatMods = isFloatType<Src2VT>.ret;

  field bit HasSrc0IntMods = isIntType<Src0VT>.ret;
  field bit HasSrc1IntMods = isIntType<Src1VT>.ret;
  field bit HasSrc2IntMods = isIntType<Src2VT>.ret;

  field bit HasSrc0Mods = HasModifiers;
  field bit HasSrc1Mods = !if(HasModifiers, BitOr<HasSrc1FloatMods, HasSrc1IntMods>.ret, 0);
  field bit HasSrc2Mods = !if(HasModifiers, BitOr<HasSrc2FloatMods, HasSrc2IntMods>.ret, 0);

  field bit HasOMod = HasModifiers;
  field bit HasClamp = HasModifiers;
  field bit HasSDWAClamp = HasSrc0;
d1452 1
a1452 1
  field dag OutsSDWA = getOutsExt<HasDst, DstVT, DstRCSDWA>.ret;
d1456 3
a1458 6
                             HasModifiers, Src0Mod, Src1Mod, Src2Mod>.ret;
  field dag InsDPP = getInsDPP<Src0DPP, Src1DPP, NumSrcArgs,
                               HasModifiers, Src0ModDPP, Src1ModDPP>.ret;
  field dag InsSDWA = getInsSDWA<Src0SDWA, Src1SDWA, NumSrcArgs,
                                 HasModifiers, Src0ModSDWA, Src1ModSDWA,
                                 DstVT>.ret;
d1470 2
d1473 2
a1474 2
def VOP_F16_I16 : VOPProfile <[f16, i16, untyped, untyped]>;
def VOP_I16_F16 : VOPProfile <[i16, f16, untyped, untyped]>;
d1477 1
a1477 2
def VOP_F16_F16_I16 : VOPProfile <[f16, f16, i16, untyped]>;
def VOP_F16_F16_I32 : VOPProfile <[f16, f16, i32, untyped]>;
a1494 1
def VOP_F32_F32_F16 : VOPProfile <[f32, f32, f16, untyped]>;
d1503 83
a1589 2
def VOP_F16_F32_F16_F32 : VOPProfile <[f16, f32, f16, f32]>;
def VOP_F32_F32_F16_F16 : VOPProfile <[f32, f32, f16, f16]>;
d1591 29
a1622 3
def VOP_I32_F32_I32_I32 : VOPProfile <[i32, f32, i32, i32]>;
def VOP_I64_I64_I32_I64 : VOPProfile <[i64, i64, i32, i64]>;
def VOP_V4I32_I64_I32_V4I32 : VOPProfile <[v4i32, i64, i32, v4i32]>;
d1624 54
a1677 1
class Commutable_REV <string revOp, bit isOrig> {
d1687 5
a1691 7
//===----------------------------------------------------------------------===//
// Interpolation opcodes
//===----------------------------------------------------------------------===//

class VINTRP_Pseudo <string opName, dag outs, dag ins, list<dag> pattern> :
  VINTRPCommon <outs, ins, "", pattern>,
  SIMCInstr<opName, SIEncodingFamily.NONE> {
d1694 3
d1699 3
a1701 5
class VINTRP_Real_si <bits <2> op, string opName, dag outs, dag ins,
                      string asm> :
  VINTRPCommon <outs, ins, asm, []>,
  VINTRPe <op>,
  SIMCInstr<opName, SIEncodingFamily.SI> {
d1707 4
a1710 6
class VINTRP_Real_vi <bits <2> op, string opName, dag outs, dag ins,
                      string asm> :
  VINTRPCommon <outs, ins, asm, []>,
  VINTRPe_vi <op>,
  SIMCInstr<opName, SIEncodingFamily.VI> {
  let AssemblerPredicate = VIAssemblerPredicate;
d1715 5
a1719 3
multiclass VINTRP_m <bits <2> op, dag outs, dag ins, string asm,
                     list<dag> pattern = []> {
  def "" : VINTRP_Pseudo <NAME, outs, ins, pattern>;
d1721 1
a1721 1
  def _si : VINTRP_Real_si <op, NAME, outs, ins, asm>;
a1722 1
  def _vi : VINTRP_Real_vi <op, NAME, outs, ins, asm>;
d1725 9
a1733 3
//===----------------------------------------------------------------------===//
// Vector instruction mappings
//===----------------------------------------------------------------------===//
d1735 31
a1765 7
// Maps an opcode in e32 form to its e64 equivalent
def getVOPe64 : InstrMapping {
  let FilterClass = "VOP";
  let RowFields = ["OpName"];
  let ColFields = ["Size", "VOP3"];
  let KeyCol = ["4", "0"];
  let ValueCols = [["8", "1"]];
d1768 4
a1771 8
// Maps an opcode in e64 form to its e32 equivalent
def getVOPe32 : InstrMapping {
  let FilterClass = "VOP";
  let RowFields = ["OpName"];
  let ColFields = ["Size", "VOP3"];
  let KeyCol = ["8", "1"];
  let ValueCols = [["4", "0"]];
}
d1773 1
a1773 6
def getMaskedMIMGOp : InstrMapping {
  let FilterClass = "MIMG_Mask";
  let RowFields = ["Op"];
  let ColFields = ["Channels"];
  let KeyCol = ["4"];
  let ValueCols = [["1"], ["2"], ["3"] ];
d1776 7
a1782 7
// Maps an commuted opcode to its original version
def getCommuteOrig : InstrMapping {
  let FilterClass = "Commutable_REV";
  let RowFields = ["RevOp"];
  let ColFields = ["IsOrig"];
  let KeyCol = ["0"];
  let ValueCols = [["1"]];
d1785 6
a1790 7
// Maps an original opcode to its commuted version
def getCommuteRev : InstrMapping {
  let FilterClass = "Commutable_REV";
  let RowFields = ["RevOp"];
  let ColFields = ["IsOrig"];
  let KeyCol = ["1"];
  let ValueCols = [["0"]];
d1793 1872
a3673 9
// Get equivalent SOPK instruction.
def getSOPKOp : InstrMapping {
  let FilterClass = "SOPKInstTable";
  let RowFields = ["BaseCmpOp"];
  let ColFields = ["IsSOPK"];
  let KeyCol = ["0"];
  let ValueCols = [["1"]];
}

d3702 1
a3702 3

include "DSInstructions.td"
include "MIMGInstructions.td"
@


