head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.04;	author patrick;	state Exp;
branches;
next	;
commitid	qMUxATnKgqN83Oct;


desc
@@


1.1
log
@Initial revision
@
text
@//===- AMDGPUIntrinsicInfo.cpp - AMDGPU Intrinsic Information ---*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//==-----------------------------------------------------------------------===//
//
/// \file
/// \brief AMDGPU Implementation of the IntrinsicInfo class.
//
//===-----------------------------------------------------------------------===//

#include "AMDGPUIntrinsicInfo.h"
#include "AMDGPUSubtarget.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/IR/Module.h"

using namespace llvm;

#define GET_LLVM_INTRINSIC_FOR_GCC_BUILTIN
#include "AMDGPUGenIntrinsics.inc"
#undef GET_LLVM_INTRINSIC_FOR_GCC_BUILTIN

AMDGPUIntrinsicInfo::AMDGPUIntrinsicInfo()
    : TargetIntrinsicInfo() {}

std::string AMDGPUIntrinsicInfo::getName(unsigned IntrID, Type **Tys,
                                         unsigned numTys) const {
  static const char *const names[] = {
#define GET_INTRINSIC_NAME_TABLE
#include "AMDGPUGenIntrinsics.inc"
#undef GET_INTRINSIC_NAME_TABLE
  };

  if (IntrID < Intrinsic::num_intrinsics) {
    return nullptr;
  }
  assert(IntrID < AMDGPUIntrinsic::num_AMDGPU_intrinsics &&
         "Invalid intrinsic ID");

  std::string Result(names[IntrID - Intrinsic::num_intrinsics]);
  return Result;
}

unsigned AMDGPUIntrinsicInfo::lookupName(const char *Name,
                                         unsigned Len) const {
  if (!StringRef(Name, Len).startswith("llvm."))
    return 0; // All intrinsics start with 'llvm.'

#define GET_FUNCTION_RECOGNIZER
#include "AMDGPUGenIntrinsics.inc"
#undef GET_FUNCTION_RECOGNIZER
  AMDGPUIntrinsic::ID IntrinsicID =
      (AMDGPUIntrinsic::ID)Intrinsic::not_intrinsic;
  IntrinsicID = getIntrinsicForGCCBuiltin("AMDGPU", Name);

  if (IntrinsicID != (AMDGPUIntrinsic::ID)Intrinsic::not_intrinsic) {
    return IntrinsicID;
  }
  return 0;
}

bool AMDGPUIntrinsicInfo::isOverloaded(unsigned id) const {
// Overload Table
#define GET_INTRINSIC_OVERLOAD_TABLE
#include "AMDGPUGenIntrinsics.inc"
#undef GET_INTRINSIC_OVERLOAD_TABLE
}

Function *AMDGPUIntrinsicInfo::getDeclaration(Module *M, unsigned IntrID,
                                              Type **Tys,
                                              unsigned numTys) const {
  llvm_unreachable("Not implemented");
}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d23 4
d30 3
a32 1
static const char *const IntrinsicNameTable[] = {
d36 1
a36 12
};

namespace {
#define GET_INTRINSIC_ATTRIBUTES
#include "AMDGPUGenIntrinsics.inc"
#undef GET_INTRINSIC_ATTRIBUTES
}

StringRef AMDGPUIntrinsicInfo::getName(unsigned IntrID,
                                       ArrayRef<Type *> Tys) const {
  if (IntrID < Intrinsic::num_intrinsics)
    return StringRef();
d38 3
d44 2
a45 6
  return IntrinsicNameTable[IntrID - Intrinsic::num_intrinsics];
}

std::string AMDGPUIntrinsicInfo::getName(unsigned IntrID, Type **Tys,
                                         unsigned NumTys) const {
  return getName(IntrID, makeArrayRef(Tys, NumTys)).str();
d48 1
a48 14
FunctionType *AMDGPUIntrinsicInfo::getType(LLVMContext &Context, unsigned ID,
                                           ArrayRef<Type*> Tys) const {
  // FIXME: Re-use Intrinsic::getType machinery
  switch (ID) {
  case AMDGPUIntrinsic::amdgcn_fdiv_fast: {
    Type *F32Ty = Type::getFloatTy(Context);
    return FunctionType::get(F32Ty, { F32Ty, F32Ty }, false);
  }
  default:
    llvm_unreachable("unhandled intrinsic");
  }
}

unsigned AMDGPUIntrinsicInfo::lookupName(const char *NameData,
d50 1
a50 2
  StringRef Name(NameData, Len);
  if (!Name.startswith("llvm."))
d53 9
a61 9
  // Look for a name match in our table.  If the intrinsic is not overloaded,
  // require an exact match. If it is overloaded, require a prefix match. The
  // AMDGPU enum enum starts at Intrinsic::num_intrinsics.
  int Idx = Intrinsic::lookupLLVMIntrinsicByName(IntrinsicNameTable, Name);
  if (Idx >= 0) {
    bool IsPrefixMatch = Name.size() > strlen(IntrinsicNameTable[Idx]);
    return IsPrefixMatch == isOverloaded(Idx + 1)
               ? Intrinsic::num_intrinsics + Idx
               : 0;
a62 1

a73 12
                                              ArrayRef<Type *> Tys) const {
  FunctionType *FTy = getType(M->getContext(), IntrID, Tys);
  Function *F
    = cast<Function>(M->getOrInsertFunction(getName(IntrID, Tys), FTy));

  AttributeSet AS = getAttributes(M->getContext(),
                                  static_cast<AMDGPUIntrinsic::ID>(IntrID));
  F->setAttributes(AS);
  return F;
}

Function *AMDGPUIntrinsicInfo::getDeclaration(Module *M, unsigned IntrID,
d75 2
a76 2
                                              unsigned NumTys) const {
  return getDeclaration(M, IntrID, makeArrayRef(Tys, NumTys));
@

