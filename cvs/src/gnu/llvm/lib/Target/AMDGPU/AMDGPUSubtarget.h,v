head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.4.0.4
	OPENBSD_6_1_BASE:1.1.1.4
	LLVM_4_0_0:1.1.1.4
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.04;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.33;	author patrick;	state Exp;
branches;
next	1.1.1.4;
commitid	so2WA7LCP6wbxtYl;

1.1.1.4
date	2017.03.14.08.08.11;	author patrick;	state Exp;
branches;
next	;
commitid	aUi5NxOzBSLCN5eN;


desc
@@


1.1
log
@Initial revision
@
text
@//=====-- AMDGPUSubtarget.h - Define Subtarget for AMDGPU ------*- C++ -*-====//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//==-----------------------------------------------------------------------===//
//
/// \file
/// \brief AMDGPU specific subclass of TargetSubtarget.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_LIB_TARGET_AMDGPU_AMDGPUSUBTARGET_H
#define LLVM_LIB_TARGET_AMDGPU_AMDGPUSUBTARGET_H

#include "AMDGPU.h"
#include "AMDGPUFrameLowering.h"
#include "AMDGPUInstrInfo.h"
#include "AMDGPUISelLowering.h"
#include "AMDGPUSubtarget.h"
#include "Utils/AMDGPUBaseInfo.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/Target/TargetSubtargetInfo.h"

#define GET_SUBTARGETINFO_HEADER
#include "AMDGPUGenSubtargetInfo.inc"

namespace llvm {

class SIMachineFunctionInfo;

class AMDGPUSubtarget : public AMDGPUGenSubtargetInfo {

public:
  enum Generation {
    R600 = 0,
    R700,
    EVERGREEN,
    NORTHERN_ISLANDS,
    SOUTHERN_ISLANDS,
    SEA_ISLANDS,
    VOLCANIC_ISLANDS,
  };

  enum {
    FIXED_SGPR_COUNT_FOR_INIT_BUG = 80
  };

  enum {
    ISAVersion0_0_0,
    ISAVersion7_0_0,
    ISAVersion7_0_1,
    ISAVersion8_0_0,
    ISAVersion8_0_1,
    ISAVersion8_0_3
  };

private:
  bool DumpCode;
  bool R600ALUInst;
  bool HasVertexCache;
  short TexVTXClauseSize;
  Generation Gen;
  bool FP64;
  bool FP64Denormals;
  bool FP32Denormals;
  bool FastFMAF32;
  bool CaymanISA;
  bool FlatAddressSpace;
  bool FlatForGlobal;
  bool EnableIRStructurizer;
  bool EnablePromoteAlloca;
  bool EnableIfCvt;
  bool EnableLoadStoreOpt;
  bool EnableUnsafeDSOffsetFolding;
  bool EnableXNACK;
  unsigned WavefrontSize;
  bool CFALUBug;
  int LocalMemorySize;
  unsigned MaxPrivateElementSize;
  bool EnableVGPRSpilling;
  bool SGPRInitBug;
  bool IsGCN;
  bool GCN1Encoding;
  bool GCN3Encoding;
  bool CIInsts;
  bool FeatureDisable;
  int LDSBankCount;
  unsigned IsaVersion;
  bool EnableHugeScratchBuffer;
  bool EnableSIScheduler;

  std::unique_ptr<AMDGPUFrameLowering> FrameLowering;
  std::unique_ptr<AMDGPUTargetLowering> TLInfo;
  std::unique_ptr<AMDGPUInstrInfo> InstrInfo;
  InstrItineraryData InstrItins;
  Triple TargetTriple;

public:
  AMDGPUSubtarget(const Triple &TT, StringRef CPU, StringRef FS,
                  TargetMachine &TM);
  AMDGPUSubtarget &initializeSubtargetDependencies(const Triple &TT,
                                                   StringRef GPU, StringRef FS);

  const AMDGPUFrameLowering *getFrameLowering() const override {
    return FrameLowering.get();
  }
  const AMDGPUInstrInfo *getInstrInfo() const override {
    return InstrInfo.get();
  }
  const AMDGPURegisterInfo *getRegisterInfo() const override {
    return &InstrInfo->getRegisterInfo();
  }
  AMDGPUTargetLowering *getTargetLowering() const override {
    return TLInfo.get();
  }
  const InstrItineraryData *getInstrItineraryData() const override {
    return &InstrItins;
  }

  void ParseSubtargetFeatures(StringRef CPU, StringRef FS);

  bool hasVertexCache() const {
    return HasVertexCache;
  }

  short getTexVTXClauseSize() const {
    return TexVTXClauseSize;
  }

  Generation getGeneration() const {
    return Gen;
  }

  bool hasHWFP64() const {
    return FP64;
  }

  bool hasCaymanISA() const {
    return CaymanISA;
  }

  bool hasFP32Denormals() const {
    return FP32Denormals;
  }

  bool hasFP64Denormals() const {
    return FP64Denormals;
  }

  bool hasFastFMAF32() const {
    return FastFMAF32;
  }

  bool hasFlatAddressSpace() const {
    return FlatAddressSpace;
  }

  bool useFlatForGlobal() const {
    return FlatForGlobal;
  }

  bool hasBFE() const {
    return (getGeneration() >= EVERGREEN);
  }

  bool hasBFI() const {
    return (getGeneration() >= EVERGREEN);
  }

  bool hasBFM() const {
    return hasBFE();
  }

  bool hasBCNT(unsigned Size) const {
    if (Size == 32)
      return (getGeneration() >= EVERGREEN);

    if (Size == 64)
      return (getGeneration() >= SOUTHERN_ISLANDS);

    return false;
  }

  bool hasMulU24() const {
    return (getGeneration() >= EVERGREEN);
  }

  bool hasMulI24() const {
    return (getGeneration() >= SOUTHERN_ISLANDS ||
            hasCaymanISA());
  }

  bool hasFFBL() const {
    return (getGeneration() >= EVERGREEN);
  }

  bool hasFFBH() const {
    return (getGeneration() >= EVERGREEN);
  }

  bool hasCARRY() const {
    return (getGeneration() >= EVERGREEN);
  }

  bool hasBORROW() const {
    return (getGeneration() >= EVERGREEN);
  }

  bool IsIRStructurizerEnabled() const {
    return EnableIRStructurizer;
  }

  bool isPromoteAllocaEnabled() const {
    return EnablePromoteAlloca;
  }

  bool isIfCvtEnabled() const {
    return EnableIfCvt;
  }

  bool loadStoreOptEnabled() const {
    return EnableLoadStoreOpt;
  }

  bool unsafeDSOffsetFoldingEnabled() const {
    return EnableUnsafeDSOffsetFolding;
  }

  unsigned getWavefrontSize() const {
    return WavefrontSize;
  }

  unsigned getStackEntrySize() const;

  bool hasCFAluBug() const {
    assert(getGeneration() <= NORTHERN_ISLANDS);
    return CFALUBug;
  }

  int getLocalMemorySize() const {
    return LocalMemorySize;
  }

  unsigned getMaxPrivateElementSize() const {
    return MaxPrivateElementSize;
  }

  bool hasSGPRInitBug() const {
    return SGPRInitBug;
  }

  int getLDSBankCount() const {
    return LDSBankCount;
  }

  unsigned getAmdKernelCodeChipID() const;

  AMDGPU::IsaVersion getIsaVersion() const;

  bool enableMachineScheduler() const override {
    return true;
  }

  void overrideSchedPolicy(MachineSchedPolicy &Policy,
                           MachineInstr *begin, MachineInstr *end,
                           unsigned NumRegionInstrs) const override;

  // Helper functions to simplify if statements
  bool isTargetELF() const {
    return false;
  }

  bool enableHugeScratchBuffer() const {
    return EnableHugeScratchBuffer;
  }

  bool enableSIScheduler() const {
    return EnableSIScheduler;
  }

  bool dumpCode() const {
    return DumpCode;
  }
  bool r600ALUEncoding() const {
    return R600ALUInst;
  }
  bool isAmdHsaOS() const {
    return TargetTriple.getOS() == Triple::AMDHSA;
  }
  bool isVGPRSpillingEnabled(const SIMachineFunctionInfo *MFI) const;

  bool isXNACKEnabled() const {
    return EnableXNACK;
  }

  unsigned getMaxWavesPerCU() const {
    if (getGeneration() >= AMDGPUSubtarget::SOUTHERN_ISLANDS)
      return 10;

    // FIXME: Not sure what this is for other subtagets.
    llvm_unreachable("do not know max waves per CU for this subtarget.");
  }

  bool enableSubRegLiveness() const override {
    return true;
  }

  /// \brief Returns the offset in bytes from the start of the input buffer
  ///        of the first explicit kernel argument.
  unsigned getExplicitKernelArgOffset() const {
    return isAmdHsaOS() ? 0 : 36;
  }

  unsigned getMaxNumUserSGPRs() const {
    return 16;
  }
};

} // End namespace llvm

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d19 4
a22 6
#include "R600InstrInfo.h"
#include "R600ISelLowering.h"
#include "R600FrameLowering.h"
#include "SIInstrInfo.h"
#include "SIISelLowering.h"
#include "SIFrameLowering.h"
d24 1
a24 1
#include "llvm/CodeGen/GlobalISel/GISelAccessor.h"
a32 1
class StringRef;
d35 1
d48 4
d60 5
a64 3
protected:
  // Basic subtarget description.
  Triple TargetTriple;
d66 3
a68 7
  unsigned IsaVersion;
  unsigned WavefrontSize;
  int LocalMemorySize;
  int LDSBankCount;
  unsigned MaxPrivateElementSize;

  // Possibly statically set by tablegen, but may want to be overridden.
d70 2
a71 6
  bool HalfRate64Ops;

  // Dynamially set bits that enable features.
  bool FP32Denormals;
  bool FP64Denormals;
  bool FPExceptions;
d73 1
a73 8
  bool UnalignedBufferAccess;
  bool EnableXNACK;
  bool DebuggerInsertNops;
  bool DebuggerReserveRegs;
  bool DebuggerEmitPrologue;

  // Used as options.
  bool EnableVGPRSpilling;
d75 1
d78 7
a84 5
  bool EnableSIScheduler;
  bool DumpCode;

  // Subtarget statically properties set by tablegen
  bool FP64;
a88 11
  bool SGPRInitBug;
  bool HasSMemRealTime;
  bool Has16BitInsts;
  bool FlatAddressSpace;
  bool R600ALUInst;
  bool CaymanISA;
  bool CFALUBug;
  bool HasVertexCache;
  short TexVTXClauseSize;

  // Dummy feature to use for assembler in tablegen.
d90 4
d95 3
d99 1
d102 2
a103 3
  AMDGPUSubtarget(const Triple &TT, StringRef GPU, StringRef FS,
                  const TargetMachine &TM);
  virtual ~AMDGPUSubtarget();
d107 12
a118 5
  const AMDGPUInstrInfo *getInstrInfo() const override;
  const AMDGPUFrameLowering *getFrameLowering() const override;
  const AMDGPUTargetLowering *getTargetLowering() const override;
  const AMDGPURegisterInfo *getRegisterInfo() const override;

d125 6
a130 2
  bool isAmdHsaOS() const {
    return TargetTriple.getOS() == Triple::AMDHSA;
d137 2
a138 2
  unsigned getWavefrontSize() const {
    return WavefrontSize;
d141 2
a142 2
  int getLocalMemorySize() const {
    return LocalMemorySize;
d145 2
a146 2
  int getLDSBankCount() const {
    return LDSBankCount;
d149 2
a150 6
  unsigned getMaxPrivateElementSize() const {
    return MaxPrivateElementSize;
  }

  bool hasHWFP64() const {
    return FP64;
d157 2
a158 2
  bool hasHalfRate64Ops() const {
    return HalfRate64Ops;
d161 2
a162 2
  bool hasAddr64() const {
    return (getGeneration() < VOLCANIC_ISLANDS);
d212 2
a213 2
  bool hasCaymanISA() const {
    return CaymanISA;
d220 2
a221 2
  bool unsafeDSOffsetFoldingEnabled() const {
    return EnableUnsafeDSOffsetFolding;
d224 2
a225 2
  bool dumpCode() const {
    return DumpCode;
d228 3
a230 7
  /// Return the amount of LDS that can be used that will not restrict the
  /// occupancy lower than WaveCount.
  unsigned getMaxLocalMemSizeWithWaveCount(unsigned WaveCount) const;

  /// Inverse of getMaxLocalMemWithWaveCount. Return the maximum wavecount if
  /// the given LDS memory size is the only constraint.
  unsigned getOccupancyWithLocalMemSize(uint32_t Bytes) const;
d232 2
a233 3

  bool hasFP32Denormals() const {
    return FP32Denormals;
d236 1
a236 3
  bool hasFP64Denormals() const {
    return FP64Denormals;
  }
d238 3
a240 2
  bool hasFPExceptions() const {
    return FPExceptions;
d243 2
a244 2
  bool useFlatForGlobal() const {
    return FlatForGlobal;
d247 2
a248 2
  bool hasUnalignedBufferAccess() const {
    return UnalignedBufferAccess;
d251 2
a252 2
  bool isXNACKEnabled() const {
    return EnableXNACK;
d255 2
a256 6
  unsigned getMaxWavesPerCU() const {
    if (getGeneration() >= AMDGPUSubtarget::SOUTHERN_ISLANDS)
      return 10;

    // FIXME: Not sure what this is for other subtagets.
    return 8;
d259 1
a259 5
  /// \brief Returns the offset in bytes from the start of the input buffer
  ///        of the first explicit kernel argument.
  unsigned getExplicitKernelArgOffset() const {
    return isAmdHsaOS() ? 0 : 36;
  }
d261 1
a261 4
  unsigned getStackAlignment() const {
    // Scratch is allocated in 256 dword per wave blocks.
    return 4 * 256 / getWavefrontSize();
  }
d267 3
a269 4
  bool enableSubRegLiveness() const override {
    return true;
  }
};
d271 3
a273 12
class R600Subtarget final : public AMDGPUSubtarget {
private:
  R600InstrInfo InstrInfo;
  R600FrameLowering FrameLowering;
  R600TargetLowering TLInfo;

public:
  R600Subtarget(const Triple &TT, StringRef CPU, StringRef FS,
                const TargetMachine &TM);

  const R600InstrInfo *getInstrInfo() const override {
    return &InstrInfo;
d276 2
a277 2
  const R600FrameLowering *getFrameLowering() const override {
    return &FrameLowering;
d280 2
a281 2
  const R600TargetLowering *getTargetLowering() const override {
    return &TLInfo;
d284 2
a285 2
  const R600RegisterInfo *getRegisterInfo() const override {
    return &InstrInfo.getRegisterInfo();
d287 2
a288 3

  bool hasCFAluBug() const {
    return CFALUBug;
d290 2
a291 3

  bool hasVertexCache() const {
    return HasVertexCache;
d293 1
d295 2
a296 2
  short getTexVTXClauseSize() const {
    return TexVTXClauseSize;
d299 3
a301 2
  unsigned getStackEntrySize() const;
};
d303 2
a304 18
class SISubtarget final : public AMDGPUSubtarget {
public:
  enum {
    FIXED_SGPR_COUNT_FOR_INIT_BUG = 80
  };

private:
  SIInstrInfo InstrInfo;
  SIFrameLowering FrameLowering;
  SITargetLowering TLInfo;
  std::unique_ptr<GISelAccessor> GISel;

public:
  SISubtarget(const Triple &TT, StringRef CPU, StringRef FS,
              const TargetMachine &TM);

  const SIInstrInfo *getInstrInfo() const override {
    return &InstrInfo;
d307 2
a308 2
  const SIFrameLowering *getFrameLowering() const override {
    return &FrameLowering;
d311 4
a314 2
  const SITargetLowering *getTargetLowering() const override {
    return &TLInfo;
a316 22
  const CallLowering *getCallLowering() const override {
    assert(GISel && "Access to GlobalISel APIs not set");
    return GISel->getCallLowering();
  }

  const SIRegisterInfo *getRegisterInfo() const override {
    return &InstrInfo.getRegisterInfo();
  }

  void setGISelAccessor(GISelAccessor &GISel) {
    this->GISel.reset(&GISel);
  }

  void overrideSchedPolicy(MachineSchedPolicy &Policy,
                           unsigned NumRegionInstrs) const override;

  bool isVGPRSpillingEnabled(const Function& F) const;

  unsigned getAmdKernelCodeChipID() const;

  AMDGPU::IsaVersion getIsaVersion() const;

a319 41

  bool hasFlatAddressSpace() const {
    return FlatAddressSpace;
  }

  bool hasSMemRealTime() const {
    return HasSMemRealTime;
  }

  bool has16BitInsts() const {
    return Has16BitInsts;
  }

  bool enableSIScheduler() const {
    return EnableSIScheduler;
  }

  bool debuggerSupported() const {
    return debuggerInsertNops() && debuggerReserveRegs() &&
      debuggerEmitPrologue();
  }

  bool debuggerInsertNops() const {
    return DebuggerInsertNops;
  }

  bool debuggerReserveRegs() const {
    return DebuggerReserveRegs;
  }

  bool debuggerEmitPrologue() const {
    return DebuggerEmitPrologue;
  }

  bool loadStoreOptEnabled() const {
    return EnableLoadStoreOpt;
  }

  bool hasSGPRInitBug() const {
    return SGPRInitBug;
  }
a320 29


inline const AMDGPUInstrInfo *AMDGPUSubtarget::getInstrInfo() const {
  if (getGeneration() >= SOUTHERN_ISLANDS)
    return static_cast<const SISubtarget *>(this)->getInstrInfo();

  return static_cast<const R600Subtarget *>(this)->getInstrInfo();
}

inline const AMDGPUFrameLowering *AMDGPUSubtarget::getFrameLowering() const  {
  if (getGeneration() >= SOUTHERN_ISLANDS)
    return static_cast<const SISubtarget *>(this)->getFrameLowering();

  return static_cast<const R600Subtarget *>(this)->getFrameLowering();
}

inline const AMDGPUTargetLowering *AMDGPUSubtarget::getTargetLowering() const  {
  if (getGeneration() >= SOUTHERN_ISLANDS)
    return static_cast<const SISubtarget *>(this)->getTargetLowering();

  return static_cast<const R600Subtarget *>(this)->getTargetLowering();
}

inline const AMDGPURegisterInfo *AMDGPUSubtarget::getRegisterInfo() const  {
  if (getGeneration() >= SOUTHERN_ISLANDS)
    return static_cast<const SISubtarget *>(this)->getRegisterInfo();

  return static_cast<const R600Subtarget *>(this)->getRegisterInfo();
}
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a25 1
#include "llvm/ADT/Triple.h"
d27 1
a27 8
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/SelectionDAGTargetInfo.h"
#include "llvm/MC/MCInstrItineraries.h"
#include "llvm/Support/MathExtras.h"
#include <cassert>
#include <cstdint>
#include <memory>
#include <utility>
d34 1
a52 1
    ISAVersion7_0_2,
d55 1
a55 4
    ISAVersion8_0_2,
    ISAVersion8_0_3,
    ISAVersion8_0_4,
    ISAVersion8_1_0,
a72 1
  bool FP16Denormals;
a76 1
  bool UnalignedScratchAccess;
a99 4
  bool HasMovrel;
  bool HasVGPRIndexMode;
  bool HasScalarStores;
  bool HasInv2PiInlineImm;
a105 1
  bool ScalarizeGlobal;
a110 1
  SelectionDAGTargetInfo TSInfo;
d115 1
a115 2
  ~AMDGPUSubtarget() override;

d119 4
a122 4
  const AMDGPUInstrInfo *getInstrInfo() const override = 0;
  const AMDGPUFrameLowering *getFrameLowering() const override = 0;
  const AMDGPUTargetLowering *getTargetLowering() const override = 0;
  const AMDGPURegisterInfo *getRegisterInfo() const override = 0;
a127 5
  // Nothing implemented, just prevent crashes on use.
  const SelectionDAGTargetInfo *getSelectionDAGInfo() const override {
    return &TSInfo;
  }

a133 8
  bool isMesa3DOS() const {
    return TargetTriple.getOS() == Triple::Mesa3D;
  }

  bool isOpenCLEnv() const {
    return TargetTriple.getEnvironment() == Triple::OpenCL;
  }

a153 4
  bool has16BitInsts() const {
    return Has16BitInsts;
  }

a232 4
  bool enableIEEEBit(const MachineFunction &MF) const {
    return AMDGPU::isCompute(MF.getFunction()->getCallingConv());
  }

a240 3
  bool hasFP16Denormals() const {
    return FP16Denormals;
  }
a261 4
  bool hasUnalignedScratchAccess() const {
    return UnalignedScratchAccess;
  }

d266 6
a271 2
  bool isAmdCodeObjectV2() const {
    return isAmdHsaOS() || isMesa3DOS();
d277 1
a277 13
    return isAmdCodeObjectV2() ? 0 : 36;
  }

  unsigned getAlignmentForImplicitArgPtr() const {
    return isAmdHsaOS() ? 8 : 4;
  }

  unsigned getImplicitArgNumBytes() const {
    if (isMesa3DOS())
      return 16;
    if (isAmdHsaOS() && isOpenCLEnv())
      return 32;
    return 0;
a291 86

  /// \returns Number of execution units per compute unit supported by the
  /// subtarget.
  unsigned getEUsPerCU() const {
    return 4;
  }

  /// \returns Maximum number of work groups per compute unit supported by the
  /// subtarget and limited by given flat work group size.
  unsigned getMaxWorkGroupsPerCU(unsigned FlatWorkGroupSize) const {
    if (getGeneration() < AMDGPUSubtarget::SOUTHERN_ISLANDS)
      return 8;
    return getWavesPerWorkGroup(FlatWorkGroupSize) == 1 ? 40 : 16;
  }

  /// \returns Maximum number of waves per compute unit supported by the
  /// subtarget without any kind of limitation.
  unsigned getMaxWavesPerCU() const {
    return getMaxWavesPerEU() * getEUsPerCU();
  }

  /// \returns Maximum number of waves per compute unit supported by the
  /// subtarget and limited by given flat work group size.
  unsigned getMaxWavesPerCU(unsigned FlatWorkGroupSize) const {
    return getWavesPerWorkGroup(FlatWorkGroupSize);
  }

  /// \returns Minimum number of waves per execution unit supported by the
  /// subtarget.
  unsigned getMinWavesPerEU() const {
    return 1;
  }

  /// \returns Maximum number of waves per execution unit supported by the
  /// subtarget without any kind of limitation.
  unsigned getMaxWavesPerEU() const {
    if (getGeneration() < AMDGPUSubtarget::SOUTHERN_ISLANDS)
      return 8;
    // FIXME: Need to take scratch memory into account.
    return 10;
  }

  /// \returns Maximum number of waves per execution unit supported by the
  /// subtarget and limited by given flat work group size.
  unsigned getMaxWavesPerEU(unsigned FlatWorkGroupSize) const {
    return alignTo(getMaxWavesPerCU(FlatWorkGroupSize), getEUsPerCU()) /
      getEUsPerCU();
  }

  /// \returns Minimum flat work group size supported by the subtarget.
  unsigned getMinFlatWorkGroupSize() const {
    return 1;
  }

  /// \returns Maximum flat work group size supported by the subtarget.
  unsigned getMaxFlatWorkGroupSize() const {
    return 2048;
  }

  /// \returns Number of waves per work group given the flat work group size.
  unsigned getWavesPerWorkGroup(unsigned FlatWorkGroupSize) const {
    return alignTo(FlatWorkGroupSize, getWavefrontSize()) / getWavefrontSize();
  }

  void setScalarizeGlobalBehavior(bool b) { ScalarizeGlobal = b;}
  bool getScalarizeGlobalBehavior() const { return ScalarizeGlobal;}

  /// \returns Subtarget's default pair of minimum/maximum flat work group sizes
  /// for function \p F, or minimum/maximum flat work group sizes explicitly
  /// requested using "amdgpu-flat-work-group-size" attribute attached to
  /// function \p F.
  ///
  /// \returns Subtarget's default values if explicitly requested values cannot
  /// be converted to integer, or violate subtarget's specifications.
  std::pair<unsigned, unsigned> getFlatWorkGroupSizes(const Function &F) const;

  /// \returns Subtarget's default pair of minimum/maximum number of waves per
  /// execution unit for function \p F, or minimum/maximum number of waves per
  /// execution unit explicitly requested using "amdgpu-waves-per-eu" attribute
  /// attached to function \p F.
  ///
  /// \returns Subtarget's default values if explicitly requested values cannot
  /// be converted to integer, violate subtarget's specifications, or are not
  /// compatible with minimum/maximum number of waves limited by flat work group
  /// size, register usage, and/or lds usage.
  std::pair<unsigned, unsigned> getWavesPerEU(const Function &F) const;
d331 2
d338 1
a338 3
    // The closed Vulkan driver sets 96, which limits the wave count to 8 but
    // doesn't spill SGPRs as much as when 80 is set.
    FIXED_SGPR_COUNT_FOR_INIT_BUG = 96
d381 4
d397 2
a398 18
  bool hasMovrel() const {
    return HasMovrel;
  }

  bool hasVGPRIndexMode() const {
    return HasVGPRIndexMode;
  }

  bool hasScalarCompareEq64() const {
    return getGeneration() >= VOLCANIC_ISLANDS;
  }

  bool hasScalarStores() const {
    return HasScalarStores;
  }

  bool hasInv2PiInlineImm() const {
    return HasInv2PiInlineImm;
d429 9
d439 3
a441 3
  bool has12DWordStoreHazard() const {
    return getGeneration() != AMDGPUSubtarget::SOUTHERN_ISLANDS;
  }
d443 2
a444 1
  unsigned getKernArgSegmentSize(unsigned ExplictArgBytes) const;
d446 3
a448 2
  /// Return the maximum number of waves per SIMD for kernels using \p SGPRs SGPRs
  unsigned getOccupancyWithNumSGPRs(unsigned SGPRs) const;
d450 2
a451 2
  /// Return the maximum number of waves per SIMD for kernels using \p VGPRs VGPRs
  unsigned getOccupancyWithNumVGPRs(unsigned VGPRs) const;
d453 3
a455 5
  /// \returns True if waitcnt instruction is needed before barrier instruction,
  /// false otherwise.
  bool needWaitcntBeforeBarrier() const {
    return true;
  }
d457 2
a458 2
  unsigned getMaxNumSGPRs() const;
};
d460 1
a460 1
} // end namespace llvm
d462 1
a462 1
#endif // LLVM_LIB_TARGET_AMDGPU_AMDGPUSUBTARGET_H
@


1.1.1.4
log
@Import LLVM 4.0.0 release including clang and lld.
@
text
@d314 2
a315 11
  bool isMesaKernel(const MachineFunction &MF) const {
    return isMesa3DOS() && !AMDGPU::isShader(MF.getFunction()->getCallingConv());
  }

  // Covers VS/PS/CS graphics shaders
  bool isMesaGfxShader(const MachineFunction &MF) const {
    return isMesa3DOS() && AMDGPU::isShader(MF.getFunction()->getCallingConv());
  }

  bool isAmdCodeObjectV2(const MachineFunction &MF) const {
    return isAmdHsaOS() || isMesaKernel(MF);
d320 2
a321 2
  unsigned getExplicitKernelArgOffset(const MachineFunction &MF) const {
    return isAmdCodeObjectV2(MF) ? 0 : 36;
d328 2
a329 2
  unsigned getImplicitArgNumBytes(const MachineFunction &MF) const {
    if (isMesaKernel(MF))
d588 1
a588 1
  unsigned getKernArgSegmentSize(const MachineFunction &MF, unsigned ExplictArgBytes) const;
@


