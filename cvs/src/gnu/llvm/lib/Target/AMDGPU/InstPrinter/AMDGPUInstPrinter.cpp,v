head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.04;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.33;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- AMDGPUInstPrinter.cpp - AMDGPU MC Inst -> ASM ---------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
// \file
//===----------------------------------------------------------------------===//

#include "AMDGPUInstPrinter.h"
#include "MCTargetDesc/AMDGPUMCTargetDesc.h"
#include "SIDefines.h"
#include "llvm/MC/MCExpr.h"
#include "llvm/MC/MCInst.h"
#include "llvm/MC/MCInstrInfo.h"
#include "llvm/MC/MCRegisterInfo.h"
#include "llvm/Support/MathExtras.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

void AMDGPUInstPrinter::printInst(const MCInst *MI, raw_ostream &OS,
                                  StringRef Annot, const MCSubtargetInfo &STI) {
  OS.flush();
  printInstruction(MI, OS);

  printAnnotation(OS, Annot);
}

void AMDGPUInstPrinter::printU8ImmOperand(const MCInst *MI, unsigned OpNo,
                                           raw_ostream &O) {
  O << formatHex(MI->getOperand(OpNo).getImm() & 0xff);
}

void AMDGPUInstPrinter::printU16ImmOperand(const MCInst *MI, unsigned OpNo,
                                           raw_ostream &O) {
  O << formatHex(MI->getOperand(OpNo).getImm() & 0xffff);
}

void AMDGPUInstPrinter::printU32ImmOperand(const MCInst *MI, unsigned OpNo,
                                           raw_ostream &O) {
  O << formatHex(MI->getOperand(OpNo).getImm() & 0xffffffff);
}

void AMDGPUInstPrinter::printU8ImmDecOperand(const MCInst *MI, unsigned OpNo,
                                             raw_ostream &O) {
  O << formatDec(MI->getOperand(OpNo).getImm() & 0xff);
}

void AMDGPUInstPrinter::printU16ImmDecOperand(const MCInst *MI, unsigned OpNo,
                                              raw_ostream &O) {
  O << formatDec(MI->getOperand(OpNo).getImm() & 0xffff);
}

void AMDGPUInstPrinter::printOffen(const MCInst *MI, unsigned OpNo,
                                   raw_ostream &O) {
  if (MI->getOperand(OpNo).getImm())
    O << " offen";
}

void AMDGPUInstPrinter::printIdxen(const MCInst *MI, unsigned OpNo,
                                   raw_ostream &O) {
  if (MI->getOperand(OpNo).getImm())
    O << " idxen";
}

void AMDGPUInstPrinter::printAddr64(const MCInst *MI, unsigned OpNo,
                                    raw_ostream &O) {
  if (MI->getOperand(OpNo).getImm())
    O << " addr64";
}

void AMDGPUInstPrinter::printMBUFOffset(const MCInst *MI, unsigned OpNo,
                                        raw_ostream &O) {
  if (MI->getOperand(OpNo).getImm()) {
    O << " offset:";
    printU16ImmDecOperand(MI, OpNo, O);
  }
}

void AMDGPUInstPrinter::printDSOffset(const MCInst *MI, unsigned OpNo,
                                      raw_ostream &O) {
  uint16_t Imm = MI->getOperand(OpNo).getImm();
  if (Imm != 0) {
    O << " offset:";
    printU16ImmDecOperand(MI, OpNo, O);
  }
}

void AMDGPUInstPrinter::printDSOffset0(const MCInst *MI, unsigned OpNo,
                                        raw_ostream &O) {
  if (MI->getOperand(OpNo).getImm()) {
    O << " offset0:";
    printU8ImmDecOperand(MI, OpNo, O);
  }
}

void AMDGPUInstPrinter::printDSOffset1(const MCInst *MI, unsigned OpNo,
                                        raw_ostream &O) {
  if (MI->getOperand(OpNo).getImm()) {
    O << " offset1:";
    printU8ImmDecOperand(MI, OpNo, O);
  }
}

void AMDGPUInstPrinter::printGDS(const MCInst *MI, unsigned OpNo,
                                 raw_ostream &O) {
  if (MI->getOperand(OpNo).getImm())
    O << " gds";
}

void AMDGPUInstPrinter::printGLC(const MCInst *MI, unsigned OpNo,
                                 raw_ostream &O) {
  if (MI->getOperand(OpNo).getImm())
    O << " glc";
}

void AMDGPUInstPrinter::printSLC(const MCInst *MI, unsigned OpNo,
                                 raw_ostream &O) {
  if (MI->getOperand(OpNo).getImm())
    O << " slc";
}

void AMDGPUInstPrinter::printTFE(const MCInst *MI, unsigned OpNo,
                                 raw_ostream &O) {
  if (MI->getOperand(OpNo).getImm())
    O << " tfe";
}

void AMDGPUInstPrinter::printRegOperand(unsigned reg, raw_ostream &O,
                                        const MCRegisterInfo &MRI) {
  switch (reg) {
  case AMDGPU::VCC:
    O << "vcc";
    return;
  case AMDGPU::SCC:
    O << "scc";
    return;
  case AMDGPU::EXEC:
    O << "exec";
    return;
  case AMDGPU::M0:
    O << "m0";
    return;
  case AMDGPU::FLAT_SCR:
    O << "flat_scratch";
    return;
  case AMDGPU::VCC_LO:
    O << "vcc_lo";
    return;
  case AMDGPU::VCC_HI:
    O << "vcc_hi";
    return;
  case AMDGPU::EXEC_LO:
    O << "exec_lo";
    return;
  case AMDGPU::EXEC_HI:
    O << "exec_hi";
    return;
  case AMDGPU::FLAT_SCR_LO:
    O << "flat_scratch_lo";
    return;
  case AMDGPU::FLAT_SCR_HI:
    O << "flat_scratch_hi";
    return;
  default:
    break;
  }

  char Type;
  unsigned NumRegs;

  if (MRI.getRegClass(AMDGPU::VGPR_32RegClassID).contains(reg)) {
    Type = 'v';
    NumRegs = 1;
  } else  if (MRI.getRegClass(AMDGPU::SGPR_32RegClassID).contains(reg)) {
    Type = 's';
    NumRegs = 1;
  } else if (MRI.getRegClass(AMDGPU::VReg_64RegClassID).contains(reg)) {
    Type = 'v';
    NumRegs = 2;
  } else  if (MRI.getRegClass(AMDGPU::SReg_64RegClassID).contains(reg)) {
    Type = 's';
    NumRegs = 2;
  } else if (MRI.getRegClass(AMDGPU::VReg_128RegClassID).contains(reg)) {
    Type = 'v';
    NumRegs = 4;
  } else  if (MRI.getRegClass(AMDGPU::SReg_128RegClassID).contains(reg)) {
    Type = 's';
    NumRegs = 4;
  } else if (MRI.getRegClass(AMDGPU::VReg_96RegClassID).contains(reg)) {
    Type = 'v';
    NumRegs = 3;
  } else if (MRI.getRegClass(AMDGPU::VReg_256RegClassID).contains(reg)) {
    Type = 'v';
    NumRegs = 8;
  } else if (MRI.getRegClass(AMDGPU::SReg_256RegClassID).contains(reg)) {
    Type = 's';
    NumRegs = 8;
  } else if (MRI.getRegClass(AMDGPU::VReg_512RegClassID).contains(reg)) {
    Type = 'v';
    NumRegs = 16;
  } else if (MRI.getRegClass(AMDGPU::SReg_512RegClassID).contains(reg)) {
    Type = 's';
    NumRegs = 16;
  } else {
    O << getRegisterName(reg);
    return;
  }

  // The low 8 bits of the encoding value is the register index, for both VGPRs
  // and SGPRs.
  unsigned RegIdx = MRI.getEncodingValue(reg) & ((1 << 8) - 1);
  if (NumRegs == 1) {
    O << Type << RegIdx;
    return;
  }

  O << Type << '[' << RegIdx << ':' << (RegIdx + NumRegs - 1) << ']';
}

void AMDGPUInstPrinter::printVOPDst(const MCInst *MI, unsigned OpNo,
                                    raw_ostream &O) {
  if (MII.get(MI->getOpcode()).TSFlags & SIInstrFlags::VOP3)
    O << "_e64 ";
  else
    O << "_e32 ";

  printOperand(MI, OpNo, O);
}

void AMDGPUInstPrinter::printImmediate32(uint32_t Imm, raw_ostream &O) {
  int32_t SImm = static_cast<int32_t>(Imm);
  if (SImm >= -16 && SImm <= 64) {
    O << SImm;
    return;
  }

  if (Imm == FloatToBits(0.0f))
    O << "0.0";
  else if (Imm == FloatToBits(1.0f))
    O << "1.0";
  else if (Imm == FloatToBits(-1.0f))
    O << "-1.0";
  else if (Imm == FloatToBits(0.5f))
    O << "0.5";
  else if (Imm == FloatToBits(-0.5f))
    O << "-0.5";
  else if (Imm == FloatToBits(2.0f))
    O << "2.0";
  else if (Imm == FloatToBits(-2.0f))
    O << "-2.0";
  else if (Imm == FloatToBits(4.0f))
    O << "4.0";
  else if (Imm == FloatToBits(-4.0f))
    O << "-4.0";
  else
    O << formatHex(static_cast<uint64_t>(Imm));
}

void AMDGPUInstPrinter::printImmediate64(uint64_t Imm, raw_ostream &O) {
  int64_t SImm = static_cast<int64_t>(Imm);
  if (SImm >= -16 && SImm <= 64) {
    O << SImm;
    return;
  }

  if (Imm == DoubleToBits(0.0))
    O << "0.0";
  else if (Imm == DoubleToBits(1.0))
    O << "1.0";
  else if (Imm == DoubleToBits(-1.0))
    O << "-1.0";
  else if (Imm == DoubleToBits(0.5))
    O << "0.5";
  else if (Imm == DoubleToBits(-0.5))
    O << "-0.5";
  else if (Imm == DoubleToBits(2.0))
    O << "2.0";
  else if (Imm == DoubleToBits(-2.0))
    O << "-2.0";
  else if (Imm == DoubleToBits(4.0))
    O << "4.0";
  else if (Imm == DoubleToBits(-4.0))
    O << "-4.0";
  else {
    assert(isUInt<32>(Imm));

    // In rare situations, we will have a 32-bit literal in a 64-bit
    // operand. This is technically allowed for the encoding of s_mov_b64.
    O << formatHex(static_cast<uint64_t>(Imm));
  }
}

void AMDGPUInstPrinter::printOperand(const MCInst *MI, unsigned OpNo,
                                     raw_ostream &O) {

  const MCOperand &Op = MI->getOperand(OpNo);
  if (Op.isReg()) {
    switch (Op.getReg()) {
    // This is the default predicate state, so we don't need to print it.
    case AMDGPU::PRED_SEL_OFF:
      break;

    default:
      printRegOperand(Op.getReg(), O, MRI);
      break;
    }
  } else if (Op.isImm()) {
    const MCInstrDesc &Desc = MII.get(MI->getOpcode());
    int RCID = Desc.OpInfo[OpNo].RegClass;
    if (RCID != -1) {
      const MCRegisterClass &ImmRC = MRI.getRegClass(RCID);
      if (ImmRC.getSize() == 4)
        printImmediate32(Op.getImm(), O);
      else if (ImmRC.getSize() == 8)
        printImmediate64(Op.getImm(), O);
      else
        llvm_unreachable("Invalid register class size");
    } else if (Desc.OpInfo[OpNo].OperandType == MCOI::OPERAND_IMMEDIATE) {
      printImmediate32(Op.getImm(), O);
    } else {
      // We hit this for the immediate instruction bits that don't yet have a
      // custom printer.
      // TODO: Eventually this should be unnecessary.
      O << formatDec(Op.getImm());
    }
  } else if (Op.isFPImm()) {
    // We special case 0.0 because otherwise it will be printed as an integer.
    if (Op.getFPImm() == 0.0)
      O << "0.0";
    else {
      const MCInstrDesc &Desc = MII.get(MI->getOpcode());
      const MCRegisterClass &ImmRC = MRI.getRegClass(Desc.OpInfo[OpNo].RegClass);

      if (ImmRC.getSize() == 4)
        printImmediate32(FloatToBits(Op.getFPImm()), O);
      else if (ImmRC.getSize() == 8)
        printImmediate64(DoubleToBits(Op.getFPImm()), O);
      else
        llvm_unreachable("Invalid register class size");
    }
  } else if (Op.isExpr()) {
    const MCExpr *Exp = Op.getExpr();
    Exp->print(O, &MAI);
  } else {
    llvm_unreachable("unknown operand type in printOperand");
  }
}

void AMDGPUInstPrinter::printOperandAndMods(const MCInst *MI, unsigned OpNo,
                                            raw_ostream &O) {
  unsigned InputModifiers = MI->getOperand(OpNo).getImm();
  if (InputModifiers & SISrcMods::NEG)
    O << '-';
  if (InputModifiers & SISrcMods::ABS)
    O << '|';
  printOperand(MI, OpNo + 1, O);
  if (InputModifiers & SISrcMods::ABS)
    O << '|';
}

void AMDGPUInstPrinter::printInterpSlot(const MCInst *MI, unsigned OpNum,
                                        raw_ostream &O) {
  unsigned Imm = MI->getOperand(OpNum).getImm();

  if (Imm == 2) {
    O << "P0";
  } else if (Imm == 1) {
    O << "P20";
  } else if (Imm == 0) {
    O << "P10";
  } else {
    llvm_unreachable("Invalid interpolation parameter slot");
  }
}

void AMDGPUInstPrinter::printMemOperand(const MCInst *MI, unsigned OpNo,
                                        raw_ostream &O) {
  printOperand(MI, OpNo, O);
  O  << ", ";
  printOperand(MI, OpNo + 1, O);
}

void AMDGPUInstPrinter::printIfSet(const MCInst *MI, unsigned OpNo,
                                   raw_ostream &O, StringRef Asm,
                                   StringRef Default) {
  const MCOperand &Op = MI->getOperand(OpNo);
  assert(Op.isImm());
  if (Op.getImm() == 1) {
    O << Asm;
  } else {
    O << Default;
  }
}

void AMDGPUInstPrinter::printAbs(const MCInst *MI, unsigned OpNo,
                                 raw_ostream &O) {
  printIfSet(MI, OpNo, O, "|");
}

void AMDGPUInstPrinter::printClamp(const MCInst *MI, unsigned OpNo,
                                   raw_ostream &O) {
  printIfSet(MI, OpNo, O, "_SAT");
}

void AMDGPUInstPrinter::printClampSI(const MCInst *MI, unsigned OpNo,
                                     raw_ostream &O) {
  if (MI->getOperand(OpNo).getImm())
    O << " clamp";
}

void AMDGPUInstPrinter::printOModSI(const MCInst *MI, unsigned OpNo,
                                     raw_ostream &O) {
  int Imm = MI->getOperand(OpNo).getImm();
  if (Imm == SIOutMods::MUL2)
    O << " mul:2";
  else if (Imm == SIOutMods::MUL4)
    O << " mul:4";
  else if (Imm == SIOutMods::DIV2)
    O << " div:2";
}

void AMDGPUInstPrinter::printLiteral(const MCInst *MI, unsigned OpNo,
                                     raw_ostream &O) {
  int32_t Imm = MI->getOperand(OpNo).getImm();
  O << Imm << '(' << BitsToFloat(Imm) << ')';
}

void AMDGPUInstPrinter::printLast(const MCInst *MI, unsigned OpNo,
                                  raw_ostream &O) {
  printIfSet(MI, OpNo, O, "*", " ");
}

void AMDGPUInstPrinter::printNeg(const MCInst *MI, unsigned OpNo,
                                 raw_ostream &O) {
  printIfSet(MI, OpNo, O, "-");
}

void AMDGPUInstPrinter::printOMOD(const MCInst *MI, unsigned OpNo,
                                  raw_ostream &O) {
  switch (MI->getOperand(OpNo).getImm()) {
  default: break;
  case 1:
    O << " * 2.0";
    break;
  case 2:
    O << " * 4.0";
    break;
  case 3:
    O << " / 2.0";
    break;
  }
}

void AMDGPUInstPrinter::printRel(const MCInst *MI, unsigned OpNo,
                                 raw_ostream &O) {
  printIfSet(MI, OpNo, O, "+");
}

void AMDGPUInstPrinter::printUpdateExecMask(const MCInst *MI, unsigned OpNo,
                                            raw_ostream &O) {
  printIfSet(MI, OpNo, O, "ExecMask,");
}

void AMDGPUInstPrinter::printUpdatePred(const MCInst *MI, unsigned OpNo,
                                        raw_ostream &O) {
  printIfSet(MI, OpNo, O, "Pred,");
}

void AMDGPUInstPrinter::printWrite(const MCInst *MI, unsigned OpNo,
                                       raw_ostream &O) {
  const MCOperand &Op = MI->getOperand(OpNo);
  if (Op.getImm() == 0) {
    O << " (MASKED)";
  }
}

void AMDGPUInstPrinter::printSel(const MCInst *MI, unsigned OpNo,
                                  raw_ostream &O) {
  const char * chans = "XYZW";
  int sel = MI->getOperand(OpNo).getImm();

  int chan = sel & 3;
  sel >>= 2;

  if (sel >= 512) {
    sel -= 512;
    int cb = sel >> 12;
    sel &= 4095;
    O << cb << '[' << sel << ']';
  } else if (sel >= 448) {
    sel -= 448;
    O << sel;
  } else if (sel >= 0){
    O << sel;
  }

  if (sel >= 0)
    O << '.' << chans[chan];
}

void AMDGPUInstPrinter::printBankSwizzle(const MCInst *MI, unsigned OpNo,
                                         raw_ostream &O) {
  int BankSwizzle = MI->getOperand(OpNo).getImm();
  switch (BankSwizzle) {
  case 1:
    O << "BS:VEC_021/SCL_122";
    break;
  case 2:
    O << "BS:VEC_120/SCL_212";
    break;
  case 3:
    O << "BS:VEC_102/SCL_221";
    break;
  case 4:
    O << "BS:VEC_201";
    break;
  case 5:
    O << "BS:VEC_210";
    break;
  default:
    break;
  }
  return;
}

void AMDGPUInstPrinter::printRSel(const MCInst *MI, unsigned OpNo,
                                  raw_ostream &O) {
  unsigned Sel = MI->getOperand(OpNo).getImm();
  switch (Sel) {
  case 0:
    O << 'X';
    break;
  case 1:
    O << 'Y';
    break;
  case 2:
    O << 'Z';
    break;
  case 3:
    O << 'W';
    break;
  case 4:
    O << '0';
    break;
  case 5:
    O << '1';
    break;
  case 7:
    O << '_';
    break;
  default:
    break;
  }
}

void AMDGPUInstPrinter::printCT(const MCInst *MI, unsigned OpNo,
                                  raw_ostream &O) {
  unsigned CT = MI->getOperand(OpNo).getImm();
  switch (CT) {
  case 0:
    O << 'U';
    break;
  case 1:
    O << 'N';
    break;
  default:
    break;
  }
}

void AMDGPUInstPrinter::printKCache(const MCInst *MI, unsigned OpNo,
                                    raw_ostream &O) {
  int KCacheMode = MI->getOperand(OpNo).getImm();
  if (KCacheMode > 0) {
    int KCacheBank = MI->getOperand(OpNo - 2).getImm();
    O << "CB" << KCacheBank << ':';
    int KCacheAddr = MI->getOperand(OpNo + 2).getImm();
    int LineSize = (KCacheMode == 1) ? 16 : 32;
    O << KCacheAddr * 16 << '-' << KCacheAddr * 16 + LineSize;
  }
}

void AMDGPUInstPrinter::printSendMsg(const MCInst *MI, unsigned OpNo,
                                     raw_ostream &O) {
  unsigned SImm16 = MI->getOperand(OpNo).getImm();
  unsigned Msg = SImm16 & 0xF;
  if (Msg == 2 || Msg == 3) {
    unsigned Op = (SImm16 >> 4) & 0xF;
    if (Msg == 3)
      O << "Gs_done(";
    else
      O << "Gs(";
    if (Op == 0) {
      O << "nop";
    } else {
      unsigned Stream = (SImm16 >> 8) & 0x3;
      if (Op == 1)
        O << "cut";
      else if (Op == 2)
        O << "emit";
      else if (Op == 3)
        O << "emit-cut";
      O << " stream " << Stream;
    }
    O << "), [m0] ";
  } else if (Msg == 1)
    O << "interrupt ";
  else if (Msg == 15)
    O << "system ";
  else
    O << "unknown(" << Msg << ") ";
}

void AMDGPUInstPrinter::printWaitFlag(const MCInst *MI, unsigned OpNo,
                                      raw_ostream &O) {
  unsigned SImm16 = MI->getOperand(OpNo).getImm();
  unsigned Vmcnt = SImm16 & 0xF;
  unsigned Expcnt = (SImm16 >> 4) & 0x7;
  unsigned Lgkmcnt = (SImm16 >> 8) & 0xF;

  bool NeedSpace = false;

  if (Vmcnt != 0xF) {
    O << "vmcnt(" << Vmcnt << ')';
    NeedSpace = true;
  }

  if (Expcnt != 0x7) {
    if (NeedSpace)
      O << ' ';
    O << "expcnt(" << Expcnt << ')';
    NeedSpace = true;
  }

  if (Lgkmcnt != 0xF) {
    if (NeedSpace)
      O << ' ';
    O << "lgkmcnt(" << Lgkmcnt << ')';
  }
}

#include "AMDGPUGenAsmWriter.inc"
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@a13 1
#include "Utils/AMDGPUAsmUtils.h"
a20 2
#include <string>

a30 5
void AMDGPUInstPrinter::printU4ImmOperand(const MCInst *MI, unsigned OpNo,
                                           raw_ostream &O) {
  O << formatHex(MI->getOperand(OpNo).getImm() & 0xf);
}

a45 5
void AMDGPUInstPrinter::printU4ImmDecOperand(const MCInst *MI, unsigned OpNo,
                                             raw_ostream &O) {
  O << formatDec(MI->getOperand(OpNo).getImm() & 0xf);
}

a55 7
void AMDGPUInstPrinter::printNamedBit(const MCInst* MI, unsigned OpNo,
                                      raw_ostream& O, StringRef BitName) {
  if (MI->getOperand(OpNo).getImm()) {
    O << ' ' << BitName;
  }
}

d58 2
a59 1
  printNamedBit(MI, OpNo, O, "offen");
d64 2
a65 1
  printNamedBit(MI, OpNo, O, "idxen");
d70 2
a71 1
  printNamedBit(MI, OpNo, O, "addr64");
d82 1
a82 1
void AMDGPUInstPrinter::printOffset(const MCInst *MI, unsigned OpNo,
d91 1
a91 1
void AMDGPUInstPrinter::printOffset0(const MCInst *MI, unsigned OpNo,
d99 1
a99 1
void AMDGPUInstPrinter::printOffset1(const MCInst *MI, unsigned OpNo,
a106 10
void AMDGPUInstPrinter::printSMRDOffset(const MCInst *MI, unsigned OpNo,
                                        raw_ostream &O) {
  printU32ImmOperand(MI, OpNo, O);
}

void AMDGPUInstPrinter::printSMRDLiteralOffset(const MCInst *MI, unsigned OpNo,
                                               raw_ostream &O) {
  printU32ImmOperand(MI, OpNo, O);
}

d109 2
a110 1
  printNamedBit(MI, OpNo, O, "gds");
d115 2
a116 1
  printNamedBit(MI, OpNo, O, "glc");
d121 2
a122 1
  printNamedBit(MI, OpNo, O, "slc");
d127 2
a128 29
  printNamedBit(MI, OpNo, O, "tfe");
}

void AMDGPUInstPrinter::printDMask(const MCInst *MI, unsigned OpNo,
                                   raw_ostream &O) {
  if (MI->getOperand(OpNo).getImm()) {
    O << " dmask:";
    printU16ImmOperand(MI, OpNo, O);
  }
}

void AMDGPUInstPrinter::printUNorm(const MCInst *MI, unsigned OpNo,
                                   raw_ostream &O) {
  printNamedBit(MI, OpNo, O, "unorm");
}

void AMDGPUInstPrinter::printDA(const MCInst *MI, unsigned OpNo,
                                raw_ostream &O) {
  printNamedBit(MI, OpNo, O, "da");
}

void AMDGPUInstPrinter::printR128(const MCInst *MI, unsigned OpNo,
                                  raw_ostream &O) {
  printNamedBit(MI, OpNo, O, "r128");
}

void AMDGPUInstPrinter::printLWE(const MCInst *MI, unsigned OpNo,
                                   raw_ostream &O) {
  printNamedBit(MI, OpNo, O, "lwe");
a154 12
  case AMDGPU::TBA_LO:
    O << "tba_lo";
    return;
  case AMDGPU::TBA_HI:
    O << "tba_hi";
    return;
  case AMDGPU::TMA_LO:
    O << "tma_lo";
    return;
  case AMDGPU::TMA_HI:
    O << "tma_hi";
    return;
d171 2
a172 3
  // The low 8 bits of the encoding value is the register index, for both VGPRs
  // and SGPRs.
  unsigned RegIdx = MRI.getEncodingValue(reg) & ((1 << 8) - 1);
a173 1
  unsigned NumRegs;
d175 1
a175 1
    O << 'v';
d178 1
a178 1
    O << 's';
d181 1
a181 1
    O <<'v';
d183 2
a184 2
  } else  if (MRI.getRegClass(AMDGPU::SGPR_64RegClassID).contains(reg)) {
    O << 's';
d187 1
a187 1
    O << 'v';
d189 2
a190 2
  } else  if (MRI.getRegClass(AMDGPU::SGPR_128RegClassID).contains(reg)) {
    O << 's';
d193 1
a193 1
    O << 'v';
d196 1
a196 1
    O << 'v';
d199 1
a199 1
    O << 's';
d202 1
a202 1
    O << 'v';
d205 1
a205 1
    O << 's';
a206 8
  } else if (MRI.getRegClass(AMDGPU::TTMP_64RegClassID).contains(reg)) {
    O << "ttmp";
    NumRegs = 2;
    RegIdx -= 112; // Trap temps start at offset 112. TODO: Get this from tablegen.
  } else if (MRI.getRegClass(AMDGPU::TTMP_128RegClassID).contains(reg)) {
    O << "ttmp";
    NumRegs = 4;
    RegIdx -= 112; // Trap temps start at offset 112. TODO: Get this from tablegen.
d212 3
d216 1
a216 1
    O << RegIdx;
d220 1
a220 1
  O << '[' << RegIdx << ':' << (RegIdx + NumRegs - 1) << ']';
a226 4
  else if (MII.get(MI->getOpcode()).TSFlags & SIInstrFlags::DPP)
    O << "_dpp ";
  else if (MII.get(MI->getOpcode()).TSFlags & SIInstrFlags::SDWA)
    O << "_sdwa ";
d348 1
a348 1
    O << "/*INV_OP*/";
d352 2
a353 3
void AMDGPUInstPrinter::printOperandAndFPInputMods(const MCInst *MI,
                                                      unsigned OpNo,
                                                      raw_ostream &O) {
a363 116
void AMDGPUInstPrinter::printOperandAndIntInputMods(const MCInst *MI,
                                                     unsigned OpNo,
                                                     raw_ostream &O) {
  unsigned InputModifiers = MI->getOperand(OpNo).getImm();
  if (InputModifiers & SISrcMods::SEXT)
    O << "sext(";
  printOperand(MI, OpNo + 1, O);
  if (InputModifiers & SISrcMods::SEXT)
    O << ')';
}


void AMDGPUInstPrinter::printDPPCtrl(const MCInst *MI, unsigned OpNo,
                                             raw_ostream &O) {
  unsigned Imm = MI->getOperand(OpNo).getImm();
  if (Imm <= 0x0ff) {
    O << " quad_perm:[";
    O << formatDec(Imm & 0x3)         << ',';
    O << formatDec((Imm & 0xc)  >> 2) << ',';
    O << formatDec((Imm & 0x30) >> 4) << ',';
    O << formatDec((Imm & 0xc0) >> 6) << ']';
  } else if ((Imm >= 0x101) && (Imm <= 0x10f)) {
    O << " row_shl:";
    printU4ImmDecOperand(MI, OpNo, O);
  } else if ((Imm >= 0x111) && (Imm <= 0x11f)) {
    O << " row_shr:";
    printU4ImmDecOperand(MI, OpNo, O);
  } else if ((Imm >= 0x121) && (Imm <= 0x12f)) {
    O << " row_ror:";
    printU4ImmDecOperand(MI, OpNo, O);
  } else if (Imm == 0x130) {
    O << " wave_shl:1";
  } else if (Imm == 0x134) {
    O << " wave_rol:1";
  } else if (Imm == 0x138) {
    O << " wave_shr:1";
  } else if (Imm == 0x13c) {
    O << " wave_ror:1";
  } else if (Imm == 0x140) {
    O << " row_mirror";
  } else if (Imm == 0x141) {
    O << " row_half_mirror";
  } else if (Imm == 0x142) {
    O << " row_bcast:15";
  } else if (Imm == 0x143) {
    O << " row_bcast:31";
  } else {
    llvm_unreachable("Invalid dpp_ctrl value");
  }
}

void AMDGPUInstPrinter::printRowMask(const MCInst *MI, unsigned OpNo,
                                            raw_ostream &O) {
  O << " row_mask:";
  printU4ImmOperand(MI, OpNo, O);
}

void AMDGPUInstPrinter::printBankMask(const MCInst *MI, unsigned OpNo,
                                             raw_ostream &O) {
  O << " bank_mask:";
  printU4ImmOperand(MI, OpNo, O);
}

void AMDGPUInstPrinter::printBoundCtrl(const MCInst *MI, unsigned OpNo,
                                              raw_ostream &O) {
  unsigned Imm = MI->getOperand(OpNo).getImm();
  if (Imm) {
    O << " bound_ctrl:0"; // XXX - this syntax is used in sp3
  }
}

void AMDGPUInstPrinter::printSDWASel(const MCInst *MI, unsigned OpNo,
                                     raw_ostream &O) {
  unsigned Imm = MI->getOperand(OpNo).getImm();
  switch (Imm) {
  case 0: O << "BYTE_0"; break;
  case 1: O << "BYTE_1"; break;
  case 2: O << "BYTE_2"; break;
  case 3: O << "BYTE_3"; break;
  case 4: O << "WORD_0"; break;
  case 5: O << "WORD_1"; break;
  case 6: O << "DWORD"; break;
  default: llvm_unreachable("Invalid SDWA data select operand");
  }
}

void AMDGPUInstPrinter::printSDWADstSel(const MCInst *MI, unsigned OpNo,
                                        raw_ostream &O) {
  O << "dst_sel:";
  printSDWASel(MI, OpNo, O);
}

void AMDGPUInstPrinter::printSDWASrc0Sel(const MCInst *MI, unsigned OpNo,
                                         raw_ostream &O) {
  O << "src0_sel:";
  printSDWASel(MI, OpNo, O);
}

void AMDGPUInstPrinter::printSDWASrc1Sel(const MCInst *MI, unsigned OpNo,
                                         raw_ostream &O) {
  O << "src1_sel:";
  printSDWASel(MI, OpNo, O);
}

void AMDGPUInstPrinter::printSDWADstUnused(const MCInst *MI, unsigned OpNo,
                                           raw_ostream &O) {
  O << "dst_unused:";
  unsigned Imm = MI->getOperand(OpNo).getImm();
  switch (Imm) {
  case 0: O << "UNUSED_PAD"; break;
  case 1: O << "UNUSED_SEXT"; break;
  case 2: O << "UNUSED_PRESERVE"; break;
  default: llvm_unreachable("Invalid SDWA dest_unused operand");
  }
}

a397 8
void AMDGPUInstPrinter::printIfSet(const MCInst *MI, unsigned OpNo,
                                   raw_ostream &O, char Asm) {
  const MCOperand &Op = MI->getOperand(OpNo);
  assert(Op.isImm());
  if (Op.getImm() == 1)
    O << Asm;
}

d400 1
a400 1
  printIfSet(MI, OpNo, O, '|');
d427 2
a428 9
  const MCOperand &Op = MI->getOperand(OpNo);
  assert(Op.isImm() || Op.isExpr());
  if (Op.isImm()) {
    int64_t Imm = Op.getImm();
    O << Imm << '(' << BitsToFloat(Imm) << ')';
  }
  if (Op.isExpr()) {
    Op.getExpr()->print(O << '@@', &MAI);
  }
d438 1
a438 1
  printIfSet(MI, OpNo, O, '-');
d459 1
a459 1
  printIfSet(MI, OpNo, O, '+');
d588 19
a606 10
  using namespace llvm::AMDGPU::SendMsg;

  const unsigned SImm16 = MI->getOperand(OpNo).getImm();
  const unsigned Id = SImm16 & ID_MASK_;
  do {
    if (Id == ID_INTERRUPT) {
      if ((SImm16 & ~ID_MASK_) != 0) // Unused/unknown bits must be 0.
        break;
      O << "sendmsg(" << IdSymbolic[Id] << ')';
      return;
d608 7
a614 25
    if (Id == ID_GS || Id == ID_GS_DONE) {
      if ((SImm16 & ~(ID_MASK_|OP_GS_MASK_|STREAM_ID_MASK_)) != 0) // Unused/unknown bits must be 0.
        break;
      const unsigned OpGs = (SImm16 & OP_GS_MASK_) >> OP_SHIFT_;
      const unsigned StreamId = (SImm16 & STREAM_ID_MASK_) >> STREAM_ID_SHIFT_;
      if (OpGs == OP_GS_NOP && Id != ID_GS_DONE) // NOP to be used for GS_DONE only.
        break;
      if (OpGs == OP_GS_NOP && StreamId != 0) // NOP does not use/define stream id bits.
        break;
      O << "sendmsg(" << IdSymbolic[Id] << ", " << OpGsSymbolic[OpGs];
      if (OpGs != OP_GS_NOP) {  O << ", " << StreamId; }
      O << ')';
      return;
    }
    if (Id == ID_SYSMSG) {
      if ((SImm16 & ~(ID_MASK_|OP_SYS_MASK_)) != 0) // Unused/unknown bits must be 0.
        break;
      const unsigned OpSys = (SImm16 & OP_SYS_MASK_) >> OP_SHIFT_;
      if (! (OP_SYS_FIRST_ <= OpSys && OpSys < OP_SYS_LAST_)) // Unused/unknown.
        break;
      O << "sendmsg(" << IdSymbolic[Id] << ", " << OpSysSymbolic[OpSys] << ')';
      return;
    }
  } while (0);
  O << SImm16; // Unknown simm16 code.
a642 21
}

void AMDGPUInstPrinter::printHwreg(const MCInst *MI, unsigned OpNo,
                                   raw_ostream &O) {
  using namespace llvm::AMDGPU::Hwreg;

  unsigned SImm16 = MI->getOperand(OpNo).getImm();
  const unsigned Id = (SImm16 & ID_MASK_) >> ID_SHIFT_;
  const unsigned Offset = (SImm16 & OFFSET_MASK_) >> OFFSET_SHIFT_;
  const unsigned Width = ((SImm16 & WIDTH_M1_MASK_) >> WIDTH_M1_SHIFT_) + 1;

  O << "hwreg(";
  if (ID_SYMBOLIC_FIRST_ <= Id && Id < ID_SYMBOLIC_LAST_) {
    O << IdSymbolic[Id];
  } else {
    O << Id;
  }
  if (Width != WIDTH_M1_DEFAULT_ + 1 || Offset != OFFSET_DEFAULT_) {
    O << ", " << Offset << ", " << Width;
  }
  O << ')';
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d12 1
a13 1
#include "MCTargetDesc/AMDGPUMCTargetDesc.h"
a14 1
#include "Utils/AMDGPUBaseInfo.h"
a16 1
#include "llvm/MC/MCInstrDesc.h"
a18 2
#include "llvm/MC/MCSubtargetInfo.h"
#include "llvm/Support/ErrorHandling.h"
d21 2
a22 1
#include <cassert>
a24 1
using namespace llvm::AMDGPU;
d29 2
a30 1
  printInstruction(MI, STI, OS);
d35 1
a35 2
                                          const MCSubtargetInfo &STI,
                                          raw_ostream &O) {
d40 1
a40 1
                                          raw_ostream &O) {
a44 1
                                           const MCSubtargetInfo &STI,
d46 6
a51 7
  // It's possible to end up with a 32-bit literal used with a 16-bit operand
  // with ignored high bits. Print as 32-bit anyway in that case.
  int64_t Imm = MI->getOperand(OpNo).getImm();
  if (isInt<16>(Imm) || isUInt<16>(Imm))
    O << formatHex(static_cast<uint64_t>(Imm & 0xffff));
  else
    printU32ImmOperand(MI, OpNo, STI, O);
d69 2
a70 8
void AMDGPUInstPrinter::printU32ImmOperand(const MCInst *MI, unsigned OpNo,
                                           const MCSubtargetInfo &STI,
                                           raw_ostream &O) {
  O << formatHex(MI->getOperand(OpNo).getImm() & 0xffffffff);
}

void AMDGPUInstPrinter::printNamedBit(const MCInst *MI, unsigned OpNo,
                                      raw_ostream &O, StringRef BitName) {
d100 1
a100 2
                                    const MCSubtargetInfo &STI,
                                    raw_ostream &O) {
d109 1
a109 2
                                     const MCSubtargetInfo &STI,
                                     raw_ostream &O) {
d117 1
a117 2
                                     const MCSubtargetInfo &STI,
                                     raw_ostream &O) {
d124 1
a124 8
void AMDGPUInstPrinter::printSMRDOffset8(const MCInst *MI, unsigned OpNo,
                                        const MCSubtargetInfo &STI,
                                        raw_ostream &O) {
  printU32ImmOperand(MI, OpNo, STI, O);
}

void AMDGPUInstPrinter::printSMRDOffset20(const MCInst *MI, unsigned OpNo,
                                        const MCSubtargetInfo &STI,
d126 1
a126 1
  printU32ImmOperand(MI, OpNo, STI, O);
a129 1
                                               const MCSubtargetInfo &STI,
d131 1
a131 1
  printU32ImmOperand(MI, OpNo, STI, O);
d135 1
a135 1
                                 const MCSubtargetInfo &STI, raw_ostream &O) {
d140 1
a140 1
                                 const MCSubtargetInfo &STI, raw_ostream &O) {
d145 1
a145 1
                                 const MCSubtargetInfo &STI, raw_ostream &O) {
d150 1
a150 1
                                 const MCSubtargetInfo &STI, raw_ostream &O) {
d155 1
a155 1
                                   const MCSubtargetInfo &STI, raw_ostream &O) {
d158 1
a158 1
    printU16ImmOperand(MI, OpNo, STI, O);
d163 1
a163 1
                                   const MCSubtargetInfo &STI, raw_ostream &O) {
d168 1
a168 1
                                const MCSubtargetInfo &STI, raw_ostream &O) {
d173 1
a173 1
                                  const MCSubtargetInfo &STI, raw_ostream &O) {
d178 1
a178 1
                                 const MCSubtargetInfo &STI, raw_ostream &O) {
d182 1
a182 15
void AMDGPUInstPrinter::printExpCompr(const MCInst *MI, unsigned OpNo,
                                      const MCSubtargetInfo &STI,
                                      raw_ostream &O) {
  if (MI->getOperand(OpNo).getImm())
    O << " compr";
}

void AMDGPUInstPrinter::printExpVM(const MCInst *MI, unsigned OpNo,
                                   const MCSubtargetInfo &STI,
                                   raw_ostream &O) {
  if (MI->getOperand(OpNo).getImm())
    O << " vm";
}

void AMDGPUInstPrinter::printRegOperand(unsigned RegNo, raw_ostream &O,
d184 1
a184 1
  switch (RegNo) {
d236 1
a236 1
  unsigned RegIdx = MRI.getEncodingValue(RegNo) & ((1 << 8) - 1);
d239 1
a239 1
  if (MRI.getRegClass(AMDGPU::VGPR_32RegClassID).contains(RegNo)) {
d242 1
a242 1
  } else  if (MRI.getRegClass(AMDGPU::SGPR_32RegClassID).contains(RegNo)) {
d245 1
a245 1
  } else if (MRI.getRegClass(AMDGPU::VReg_64RegClassID).contains(RegNo)) {
d248 1
a248 1
  } else  if (MRI.getRegClass(AMDGPU::SGPR_64RegClassID).contains(RegNo)) {
d251 1
a251 1
  } else if (MRI.getRegClass(AMDGPU::VReg_128RegClassID).contains(RegNo)) {
d254 1
a254 1
  } else  if (MRI.getRegClass(AMDGPU::SGPR_128RegClassID).contains(RegNo)) {
d257 1
a257 1
  } else if (MRI.getRegClass(AMDGPU::VReg_96RegClassID).contains(RegNo)) {
d260 1
a260 1
  } else if (MRI.getRegClass(AMDGPU::VReg_256RegClassID).contains(RegNo)) {
d263 1
a263 1
  } else if (MRI.getRegClass(AMDGPU::SReg_256RegClassID).contains(RegNo)) {
d266 1
a266 1
  } else if (MRI.getRegClass(AMDGPU::VReg_512RegClassID).contains(RegNo)) {
d269 1
a269 1
  } else if (MRI.getRegClass(AMDGPU::SReg_512RegClassID).contains(RegNo)) {
d272 1
a272 1
  } else if (MRI.getRegClass(AMDGPU::TTMP_64RegClassID).contains(RegNo)) {
d275 2
a276 3
    // Trap temps start at offset 112. TODO: Get this from tablegen.
    RegIdx -= 112;
  } else if (MRI.getRegClass(AMDGPU::TTMP_128RegClassID).contains(RegNo)) {
d279 1
a279 2
    // Trap temps start at offset 112. TODO: Get this from tablegen.
    RegIdx -= 112;
d281 1
a281 1
    O << getRegisterName(RegNo);
d294 1
a294 1
                                    const MCSubtargetInfo &STI, raw_ostream &O) {
d304 1
a304 33
  printOperand(MI, OpNo, STI, O);
}

void AMDGPUInstPrinter::printImmediate16(uint32_t Imm,
                                         const MCSubtargetInfo &STI,
                                         raw_ostream &O) {
  int16_t SImm = static_cast<int16_t>(Imm);
  if (SImm >= -16 && SImm <= 64) {
    O << SImm;
    return;
  }

  if (Imm == 0x3C00)
    O<< "1.0";
  else if (Imm == 0xBC00)
    O<< "-1.0";
  else if (Imm == 0x3800)
    O<< "0.5";
  else if (Imm == 0xB800)
    O<< "-0.5";
  else if (Imm == 0x4000)
    O<< "2.0";
  else if (Imm == 0xC000)
    O<< "-2.0";
  else if (Imm == 0x4400)
    O<< "4.0";
  else if (Imm == 0xC400)
    O<< "-4.0";
  else if (Imm == 0x3118) {
    assert(STI.getFeatureBits()[AMDGPU::FeatureInv2PiInlineImm]);
    O << "0.15915494";
  } else
    O << formatHex(static_cast<uint64_t>(Imm));
d307 1
a307 3
void AMDGPUInstPrinter::printImmediate32(uint32_t Imm,
                                         const MCSubtargetInfo &STI,
                                         raw_ostream &O) {
a331 3
  else if (Imm == 0x3e22f983 &&
           STI.getFeatureBits()[AMDGPU::FeatureInv2PiInlineImm])
    O << "0.15915494";
d336 1
a336 3
void AMDGPUInstPrinter::printImmediate64(uint64_t Imm,
                                         const MCSubtargetInfo &STI,
                                         raw_ostream &O) {
a360 3
  else if (Imm == 0x3fc45f306dc9c882 &&
           STI.getFeatureBits()[AMDGPU::FeatureInv2PiInlineImm])
  O << "0.15915494";
d362 1
a362 1
    assert(isUInt<32>(Imm) || Imm == 0x3fc45f306dc9c882);
a370 1
                                     const MCSubtargetInfo &STI,
a371 4
  if (OpNo >= MI->getNumOperands()) {
    O << "/*Missing OP" << OpNo << "*/";
    return;
  }
d386 12
a397 30
    switch (Desc.OpInfo[OpNo].OperandType) {
    case AMDGPU::OPERAND_REG_IMM_INT32:
    case AMDGPU::OPERAND_REG_IMM_FP32:
    case AMDGPU::OPERAND_REG_INLINE_C_INT32:
    case AMDGPU::OPERAND_REG_INLINE_C_FP32:
    case MCOI::OPERAND_IMMEDIATE:
      printImmediate32(Op.getImm(), STI, O);
      break;
    case AMDGPU::OPERAND_REG_IMM_INT64:
    case AMDGPU::OPERAND_REG_IMM_FP64:
    case AMDGPU::OPERAND_REG_INLINE_C_INT64:
    case AMDGPU::OPERAND_REG_INLINE_C_FP64:
      printImmediate64(Op.getImm(), STI, O);
      break;
    case AMDGPU::OPERAND_REG_INLINE_C_INT16:
    case AMDGPU::OPERAND_REG_INLINE_C_FP16:
    case AMDGPU::OPERAND_REG_IMM_INT16:
    case AMDGPU::OPERAND_REG_IMM_FP16:
      printImmediate16(Op.getImm(), STI, O);
      break;
    case MCOI::OPERAND_UNKNOWN:
    case MCOI::OPERAND_PCREL:
      O << formatDec(Op.getImm());
      break;
    case MCOI::OPERAND_REGISTER:
      // FIXME: This should be removed and handled somewhere else. Seems to come
      // from a disassembler bug.
      O << "/*invalid immediate*/";
      break;
    default:
d400 2
a401 1
      llvm_unreachable("unexpected immediate operand type");
d409 6
a414 6
      int RCID = Desc.OpInfo[OpNo].RegClass;
      unsigned RCBits = AMDGPU::getRegBitWidth(MRI.getRegClass(RCID));
      if (RCBits == 32)
        printImmediate32(FloatToBits(Op.getFPImm()), STI, O);
      else if (RCBits == 64)
        printImmediate64(DoubleToBits(Op.getFPImm()), STI, O);
d427 2
a428 3
                                                   unsigned OpNo,
                                                   const MCSubtargetInfo &STI,
                                                   raw_ostream &O) {
d434 1
a434 1
  printOperand(MI, OpNo + 1, STI, O);
d440 2
a441 3
                                                    unsigned OpNo,
                                                    const MCSubtargetInfo &STI,
                                                    raw_ostream &O) {
d445 1
a445 1
  printOperand(MI, OpNo + 1, STI, O);
d450 1
d452 1
a452 2
                                     const MCSubtargetInfo &STI,
                                     raw_ostream &O) {
d491 1
a491 2
                                     const MCSubtargetInfo &STI,
                                     raw_ostream &O) {
d493 1
a493 1
  printU4ImmOperand(MI, OpNo, STI, O);
d497 1
a497 2
                                      const MCSubtargetInfo &STI,
                                      raw_ostream &O) {
d499 1
a499 1
  printU4ImmOperand(MI, OpNo, STI, O);
d503 1
a503 2
                                       const MCSubtargetInfo &STI,
                                       raw_ostream &O) {
a511 2
  using namespace llvm::AMDGPU::SDWA;

d514 7
a520 7
  case SdwaSel::BYTE_0: O << "BYTE_0"; break;
  case SdwaSel::BYTE_1: O << "BYTE_1"; break;
  case SdwaSel::BYTE_2: O << "BYTE_2"; break;
  case SdwaSel::BYTE_3: O << "BYTE_3"; break;
  case SdwaSel::WORD_0: O << "WORD_0"; break;
  case SdwaSel::WORD_1: O << "WORD_1"; break;
  case SdwaSel::DWORD: O << "DWORD"; break;
a525 1
                                        const MCSubtargetInfo &STI,
a531 1
                                         const MCSubtargetInfo &STI,
a537 1
                                         const MCSubtargetInfo &STI,
a543 1
                                           const MCSubtargetInfo &STI,
a544 2
  using namespace llvm::AMDGPU::SDWA;

d548 3
a550 3
  case DstUnused::UNUSED_PAD: O << "UNUSED_PAD"; break;
  case DstUnused::UNUSED_SEXT: O << "UNUSED_SEXT"; break;
  case DstUnused::UNUSED_PRESERVE: O << "UNUSED_PRESERVE"; break;
a554 62
template <unsigned N>
void AMDGPUInstPrinter::printExpSrcN(const MCInst *MI, unsigned OpNo,
                                     const MCSubtargetInfo &STI,
                                     raw_ostream &O) {
  int EnIdx = AMDGPU::getNamedOperandIdx(MI->getOpcode(), AMDGPU::OpName::en);
  unsigned En = MI->getOperand(EnIdx).getImm();

  // FIXME: What do we do with compr? The meaning of en changes depending on if
  // compr is set.

  if (En & (1 << N))
    printRegOperand(MI->getOperand(OpNo).getReg(), O, MRI);
  else
    O << "off";
}

void AMDGPUInstPrinter::printExpSrc0(const MCInst *MI, unsigned OpNo,
                                     const MCSubtargetInfo &STI,
                                     raw_ostream &O) {
  printExpSrcN<0>(MI, OpNo, STI, O);
}

void AMDGPUInstPrinter::printExpSrc1(const MCInst *MI, unsigned OpNo,
                                     const MCSubtargetInfo &STI,
                                     raw_ostream &O) {
  printExpSrcN<1>(MI, OpNo, STI, O);
}

void AMDGPUInstPrinter::printExpSrc2(const MCInst *MI, unsigned OpNo,
                                     const MCSubtargetInfo &STI,
                                     raw_ostream &O) {
  printExpSrcN<2>(MI, OpNo, STI, O);
}

void AMDGPUInstPrinter::printExpSrc3(const MCInst *MI, unsigned OpNo,
                                     const MCSubtargetInfo &STI,
                                     raw_ostream &O) {
  printExpSrcN<3>(MI, OpNo, STI, O);
}

void AMDGPUInstPrinter::printExpTgt(const MCInst *MI, unsigned OpNo,
                                    const MCSubtargetInfo &STI,
                                    raw_ostream &O) {
  // This is really a 6 bit field.
  uint32_t Tgt = MI->getOperand(OpNo).getImm() & ((1 << 6) - 1);

  if (Tgt <= 7)
    O << " mrt" << Tgt;
  else if (Tgt == 8)
    O << " mrtz";
  else if (Tgt == 9)
    O << " null";
  else if (Tgt >= 12 && Tgt <= 15)
    O << " pos" << Tgt - 12;
  else if (Tgt >= 32 && Tgt <= 63)
    O << " param" << Tgt - 32;
  else {
    // Reserved values 10, 11
    O << " invalid_target_" << Tgt;
  }
}

a555 1
                                        const MCSubtargetInfo &STI,
a557 14
  switch (Imm) {
  case 0:
    O << "p10";
    break;
  case 1:
    O << "p20";
    break;
  case 2:
    O << "p0";
    break;
  default:
    O << "invalid_param_" << Imm;
  }
}
d559 8
a566 21
void AMDGPUInstPrinter::printInterpAttr(const MCInst *MI, unsigned OpNum,
                                        const MCSubtargetInfo &STI,
                                        raw_ostream &O) {
  unsigned Attr = MI->getOperand(OpNum).getImm();
  O << "attr" << Attr;
}

void AMDGPUInstPrinter::printInterpAttrChan(const MCInst *MI, unsigned OpNum,
                                        const MCSubtargetInfo &STI,
                                        raw_ostream &O) {
  unsigned Chan = MI->getOperand(OpNum).getImm();
  O << '.' << "xyzw"[Chan & 0x3];
}

void AMDGPUInstPrinter::printVGPRIndexMode(const MCInst *MI, unsigned OpNo,
                                           const MCSubtargetInfo &STI,
                                           raw_ostream &O) {
  unsigned Val = MI->getOperand(OpNo).getImm();
  if (Val == 0) {
    O << " 0";
    return;
a567 12

  if (Val & VGPRIndexMode::DST_ENABLE)
    O << " dst";

  if (Val & VGPRIndexMode::SRC0_ENABLE)
    O << " src0";

  if (Val & VGPRIndexMode::SRC1_ENABLE)
    O << " src1";

  if (Val & VGPRIndexMode::SRC2_ENABLE)
    O << " src2";
a570 1
                                        const MCSubtargetInfo &STI,
d572 1
a572 1
  printOperand(MI, OpNo, STI, O);
d574 1
a574 1
  printOperand(MI, OpNo + 1, STI, O);
d598 1
a598 1
                                 const MCSubtargetInfo &STI, raw_ostream &O) {
d603 1
a603 1
                                   const MCSubtargetInfo &STI, raw_ostream &O) {
a607 1
                                     const MCSubtargetInfo &STI,
d614 1
a614 2
                                    const MCSubtargetInfo &STI,
                                    raw_ostream &O) {
a624 1
                                     const MCSubtargetInfo &STI,
d638 1
a638 1
                                  const MCSubtargetInfo &STI, raw_ostream &O) {
d643 1
a643 1
                                 const MCSubtargetInfo &STI, raw_ostream &O) {
d648 1
a648 1
                                  const MCSubtargetInfo &STI, raw_ostream &O) {
d664 1
a664 1
                                 const MCSubtargetInfo &STI, raw_ostream &O) {
a668 1
                                            const MCSubtargetInfo &STI,
a673 1
                                        const MCSubtargetInfo &STI,
d679 1
a679 1
                                   const MCSubtargetInfo &STI, raw_ostream &O) {
d687 1
a687 1
                                 raw_ostream &O) {
a710 1
                                         const MCSubtargetInfo &STI,
d732 1
d736 1
a736 1
                                  const MCSubtargetInfo &STI, raw_ostream &O) {
d766 1
a766 1
                                const MCSubtargetInfo &STI, raw_ostream &O) {
d781 1
a781 1
                                    const MCSubtargetInfo &STI, raw_ostream &O) {
a792 1
                                     const MCSubtargetInfo &STI,
d828 1
a828 1
  } while (false);
a832 1
                                      const MCSubtargetInfo &STI,
a833 2
  IsaVersion IV = getIsaVersion(STI.getFeatureBits());

d835 3
a837 2
  unsigned Vmcnt, Expcnt, Lgkmcnt;
  decodeWaitcnt(IV, SImm16, Vmcnt, Expcnt, Lgkmcnt);
d841 1
a841 1
  if (Vmcnt != getVmcntBitMask(IV)) {
d846 1
a846 1
  if (Expcnt != getExpcntBitMask(IV)) {
d853 1
a853 1
  if (Lgkmcnt != getLgkmcntBitMask(IV)) {
d861 1
a861 1
                                   const MCSubtargetInfo &STI, raw_ostream &O) {
@


