head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.04;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.32;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- SIInstrFormats.td - SI Instruction Encodings ----------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// SI Instruction format definitions.
//
//===----------------------------------------------------------------------===//

class InstSI <dag outs, dag ins, string asm, list<dag> pattern> :
    AMDGPUInst<outs, ins, asm, pattern>, PredicateControl {

  field bits<1> VM_CNT = 0;
  field bits<1> EXP_CNT = 0;
  field bits<1> LGKM_CNT = 0;

  field bits<1> SALU = 0;
  field bits<1> VALU = 0;

  field bits<1> SOP1 = 0;
  field bits<1> SOP2 = 0;
  field bits<1> SOPC = 0;
  field bits<1> SOPK = 0;
  field bits<1> SOPP = 0;

  field bits<1> VOP1 = 0;
  field bits<1> VOP2 = 0;
  field bits<1> VOP3 = 0;
  field bits<1> VOPC = 0;

  field bits<1> MUBUF = 0;
  field bits<1> MTBUF = 0;
  field bits<1> SMRD = 0;
  field bits<1> DS = 0;
  field bits<1> MIMG = 0;
  field bits<1> FLAT = 0;
  field bits<1> WQM = 0;
  field bits<1> VGPRSpill = 0;

  // This bit tells the assembler to use the 32-bit encoding in case it
  // is unable to infer the encoding from the operands.
  field bits<1> VOPAsmPrefer32Bit = 0;

  // These need to be kept in sync with the enum in SIInstrFlags.
  let TSFlags{0} = VM_CNT;
  let TSFlags{1} = EXP_CNT;
  let TSFlags{2} = LGKM_CNT;

  let TSFlags{3} = SALU;
  let TSFlags{4} = VALU;

  let TSFlags{5} = SOP1;
  let TSFlags{6} = SOP2;
  let TSFlags{7} = SOPC;
  let TSFlags{8} = SOPK;
  let TSFlags{9} = SOPP;

  let TSFlags{10} = VOP1;
  let TSFlags{11} = VOP2;
  let TSFlags{12} = VOP3;
  let TSFlags{13} = VOPC;

  let TSFlags{14} = MUBUF;
  let TSFlags{15} = MTBUF;
  let TSFlags{16} = SMRD;
  let TSFlags{17} = DS;
  let TSFlags{18} = MIMG;
  let TSFlags{19} = FLAT;
  let TSFlags{20} = WQM;
  let TSFlags{21} = VGPRSpill;
  let TSFlags{22} = VOPAsmPrefer32Bit;

  let SchedRW = [Write32Bit];
}

class Enc32 {
  field bits<32> Inst;
  int Size = 4;
}

class Enc64 {
  field bits<64> Inst;
  int Size = 8;
}

class VOPDstOperand <RegisterClass rc> : RegisterOperand <rc, "printVOPDst">;

let Uses = [EXEC] in {

class VOPAnyCommon <dag outs, dag ins, string asm, list<dag> pattern> :
    InstSI <outs, ins, asm, pattern> {

  let mayLoad = 0;
  let mayStore = 0;
  let hasSideEffects = 0;
  let UseNamedOperandTable = 1;
  let VALU = 1;
}

class VOPCCommon <dag ins, string asm, list<dag> pattern> :
    VOPAnyCommon <(outs), ins, asm, pattern> {

  let VOPC = 1;
  let Size = 4;
  let Defs = [VCC];
}

class VOP1Common <dag outs, dag ins, string asm, list<dag> pattern> :
    VOPAnyCommon <outs, ins, asm, pattern> {

  let VOP1 = 1;
  let Size = 4;
}

class VOP2Common <dag outs, dag ins, string asm, list<dag> pattern> :
    VOPAnyCommon <outs, ins, asm, pattern> {

  let VOP2 = 1;
  let Size = 4;
}

class VOP3Common <dag outs, dag ins, string asm, list<dag> pattern> :
    VOPAnyCommon <outs, ins, asm, pattern> {

  // Using complex patterns gives VOP3 patterns a very high complexity rating,
  // but standalone patterns are almost always prefered, so we need to adjust the
  // priority lower.  The goal is to use a high number to reduce complexity to
  // zero (or less than zero).
  let AddedComplexity = -1000;

  let VOP3 = 1;
  let VALU = 1;

  let AsmMatchConverter = "cvtVOP3";
  let isCodeGenOnly = 0;

  int Size = 8;

  // Because SGPRs may be allowed if there are multiple operands, we
  // need a post-isel hook to insert copies in order to avoid
  // violating constant bus requirements.
  let hasPostISelHook = 1;
}

} // End Uses = [EXEC]

//===----------------------------------------------------------------------===//
// Scalar operations
//===----------------------------------------------------------------------===//

class SOP1e <bits<8> op> : Enc32 {
  bits<7> sdst;
  bits<8> ssrc0;

  let Inst{7-0} = ssrc0;
  let Inst{15-8} = op;
  let Inst{22-16} = sdst;
  let Inst{31-23} = 0x17d; //encoding;
}

class SOP2e <bits<7> op> : Enc32 {
  bits<7> sdst;
  bits<8> ssrc0;
  bits<8> ssrc1;

  let Inst{7-0} = ssrc0;
  let Inst{15-8} = ssrc1;
  let Inst{22-16} = sdst;
  let Inst{29-23} = op;
  let Inst{31-30} = 0x2; // encoding
}

class SOPCe <bits<7> op> : Enc32 {
  bits<8> ssrc0;
  bits<8> ssrc1;

  let Inst{7-0} = ssrc0;
  let Inst{15-8} = ssrc1;
  let Inst{22-16} = op;
  let Inst{31-23} = 0x17e;
}

class SOPKe <bits<5> op> : Enc32 {
  bits <7> sdst;
  bits <16> simm16;

  let Inst{15-0} = simm16;
  let Inst{22-16} = sdst;
  let Inst{27-23} = op;
  let Inst{31-28} = 0xb; //encoding
}

class SOPK64e <bits<5> op> : Enc64 {
  bits <7> sdst = 0;
  bits <16> simm16;
  bits <32> imm;

  let Inst{15-0} = simm16;
  let Inst{22-16} = sdst;
  let Inst{27-23} = op;
  let Inst{31-28} = 0xb;

  let Inst{63-32} = imm;
}

class SOPPe <bits<7> op> : Enc32 {
  bits <16> simm16;

  let Inst{15-0} = simm16;
  let Inst{22-16} = op;
  let Inst{31-23} = 0x17f; // encoding
}

class SMRDe <bits<5> op, bits<1> imm> : Enc32 {
  bits<7> sdst;
  bits<7> sbase;
  bits<8> offset;

  let Inst{7-0} = offset;
  let Inst{8} = imm;
  let Inst{14-9} = sbase{6-1};
  let Inst{21-15} = sdst;
  let Inst{26-22} = op;
  let Inst{31-27} = 0x18; //encoding
}

class SMRD_IMMe_ci <bits<5> op> : Enc64 {
  bits<7> sdst;
  bits<7> sbase;
  bits<32> offset;

  let Inst{7-0}   = 0xff;
  let Inst{8}     = 0;
  let Inst{14-9}  = sbase{6-1};
  let Inst{21-15} = sdst;
  let Inst{26-22} = op;
  let Inst{31-27} = 0x18; //encoding
  let Inst{63-32} = offset;
}

let SchedRW = [WriteSALU] in {
class SOP1 <dag outs, dag ins, string asm, list<dag> pattern> :
    InstSI<outs, ins, asm, pattern> {
  let mayLoad = 0;
  let mayStore = 0;
  let hasSideEffects = 0;
  let isCodeGenOnly = 0;
  let SALU = 1;
  let SOP1 = 1;
}

class SOP2 <dag outs, dag ins, string asm, list<dag> pattern> :
    InstSI <outs, ins, asm, pattern> {

  let mayLoad = 0;
  let mayStore = 0;
  let hasSideEffects = 0;
  let isCodeGenOnly = 0;
  let SALU = 1;
  let SOP2 = 1;

  let UseNamedOperandTable = 1;
}

class SOPC <bits<7> op, dag outs, dag ins, string asm, list<dag> pattern> :
  InstSI<outs, ins, asm, pattern>, SOPCe <op> {

  let mayLoad = 0;
  let mayStore = 0;
  let hasSideEffects = 0;
  let SALU = 1;
  let SOPC = 1;
  let isCodeGenOnly = 0;
  let Defs = [SCC];

  let UseNamedOperandTable = 1;
}

class SOPK <dag outs, dag ins, string asm, list<dag> pattern> :
   InstSI <outs, ins , asm, pattern> {

  let mayLoad = 0;
  let mayStore = 0;
  let hasSideEffects = 0;
  let SALU = 1;
  let SOPK = 1;

  let UseNamedOperandTable = 1;
}

class SOPP <bits<7> op, dag ins, string asm, list<dag> pattern = []> :
		InstSI <(outs), ins, asm, pattern >, SOPPe <op> {

  let mayLoad = 0;
  let mayStore = 0;
  let hasSideEffects = 0;
  let SALU = 1;
  let SOPP = 1;

  let UseNamedOperandTable = 1;
}

} // let SchedRW = [WriteSALU]

class SMRD <dag outs, dag ins, string asm, list<dag> pattern> :
    InstSI<outs, ins, asm, pattern> {

  let LGKM_CNT = 1;
  let SMRD = 1;
  let mayStore = 0;
  let mayLoad = 1;
  let hasSideEffects = 0;
  let UseNamedOperandTable = 1;
  let SchedRW = [WriteSMEM];
}

//===----------------------------------------------------------------------===//
// Vector ALU operations
//===----------------------------------------------------------------------===//

class VOP1e <bits<8> op> : Enc32 {
  bits<8> vdst;
  bits<9> src0;

  let Inst{8-0} = src0;
  let Inst{16-9} = op;
  let Inst{24-17} = vdst;
  let Inst{31-25} = 0x3f; //encoding
}

class VOP2e <bits<6> op> : Enc32 {
  bits<8> vdst;
  bits<9> src0;
  bits<8> src1;

  let Inst{8-0} = src0;
  let Inst{16-9} = src1;
  let Inst{24-17} = vdst;
  let Inst{30-25} = op;
  let Inst{31} = 0x0; //encoding
}

class VOP2_MADKe <bits<6> op> : Enc64 {

  bits<8>  vdst;
  bits<9>  src0;
  bits<8>  vsrc1;
  bits<32> src2;

  let Inst{8-0} = src0;
  let Inst{16-9} = vsrc1;
  let Inst{24-17} = vdst;
  let Inst{30-25} = op;
  let Inst{31} = 0x0; // encoding
  let Inst{63-32} = src2;
}

class VOP3e <bits<9> op> : Enc64 {
  bits<8> vdst;
  bits<2> src0_modifiers;
  bits<9> src0;
  bits<2> src1_modifiers;
  bits<9> src1;
  bits<2> src2_modifiers;
  bits<9> src2;
  bits<1> clamp;
  bits<2> omod;

  let Inst{7-0} = vdst;
  let Inst{8} = src0_modifiers{1};
  let Inst{9} = src1_modifiers{1};
  let Inst{10} = src2_modifiers{1};
  let Inst{11} = clamp;
  let Inst{25-17} = op;
  let Inst{31-26} = 0x34; //encoding
  let Inst{40-32} = src0;
  let Inst{49-41} = src1;
  let Inst{58-50} = src2;
  let Inst{60-59} = omod;
  let Inst{61} = src0_modifiers{0};
  let Inst{62} = src1_modifiers{0};
  let Inst{63} = src2_modifiers{0};
}

class VOP3be <bits<9> op> : Enc64 {
  bits<8> vdst;
  bits<2> src0_modifiers;
  bits<9> src0;
  bits<2> src1_modifiers;
  bits<9> src1;
  bits<2> src2_modifiers;
  bits<9> src2;
  bits<7> sdst;
  bits<2> omod;

  let Inst{7-0} = vdst;
  let Inst{14-8} = sdst;
  let Inst{25-17} = op;
  let Inst{31-26} = 0x34; //encoding
  let Inst{40-32} = src0;
  let Inst{49-41} = src1;
  let Inst{58-50} = src2;
  let Inst{60-59} = omod;
  let Inst{61} = src0_modifiers{0};
  let Inst{62} = src1_modifiers{0};
  let Inst{63} = src2_modifiers{0};
}

class VOPCe <bits<8> op> : Enc32 {
  bits<9> src0;
  bits<8> vsrc1;

  let Inst{8-0} = src0;
  let Inst{16-9} = vsrc1;
  let Inst{24-17} = op;
  let Inst{31-25} = 0x3e;
}

class VINTRPe <bits<2> op> : Enc32 {
  bits<8> vdst;
  bits<8> vsrc;
  bits<2> attrchan;
  bits<6> attr;

  let Inst{7-0} = vsrc;
  let Inst{9-8} = attrchan;
  let Inst{15-10} = attr;
  let Inst{17-16} = op;
  let Inst{25-18} = vdst;
  let Inst{31-26} = 0x32; // encoding
}

class DSe <bits<8> op> : Enc64 {
  bits<8> vdst;
  bits<1> gds;
  bits<8> addr;
  bits<8> data0;
  bits<8> data1;
  bits<8> offset0;
  bits<8> offset1;

  let Inst{7-0} = offset0;
  let Inst{15-8} = offset1;
  let Inst{17} = gds;
  let Inst{25-18} = op;
  let Inst{31-26} = 0x36; //encoding
  let Inst{39-32} = addr;
  let Inst{47-40} = data0;
  let Inst{55-48} = data1;
  let Inst{63-56} = vdst;
}

class MUBUFe <bits<7> op> : Enc64 {
  bits<12> offset;
  bits<1> offen;
  bits<1> idxen;
  bits<1> glc;
  bits<1> addr64;
  bits<1> lds;
  bits<8> vaddr;
  bits<8> vdata;
  bits<7> srsrc;
  bits<1> slc;
  bits<1> tfe;
  bits<8> soffset;

  let Inst{11-0} = offset;
  let Inst{12} = offen;
  let Inst{13} = idxen;
  let Inst{14} = glc;
  let Inst{15} = addr64;
  let Inst{16} = lds;
  let Inst{24-18} = op;
  let Inst{31-26} = 0x38; //encoding
  let Inst{39-32} = vaddr;
  let Inst{47-40} = vdata;
  let Inst{52-48} = srsrc{6-2};
  let Inst{54} = slc;
  let Inst{55} = tfe;
  let Inst{63-56} = soffset;
}

class MTBUFe <bits<3> op> : Enc64 {
  bits<8> vdata;
  bits<12> offset;
  bits<1> offen;
  bits<1> idxen;
  bits<1> glc;
  bits<1> addr64;
  bits<4> dfmt;
  bits<3> nfmt;
  bits<8> vaddr;
  bits<7> srsrc;
  bits<1> slc;
  bits<1> tfe;
  bits<8> soffset;

  let Inst{11-0} = offset;
  let Inst{12} = offen;
  let Inst{13} = idxen;
  let Inst{14} = glc;
  let Inst{15} = addr64;
  let Inst{18-16} = op;
  let Inst{22-19} = dfmt;
  let Inst{25-23} = nfmt;
  let Inst{31-26} = 0x3a; //encoding
  let Inst{39-32} = vaddr;
  let Inst{47-40} = vdata;
  let Inst{52-48} = srsrc{6-2};
  let Inst{54} = slc;
  let Inst{55} = tfe;
  let Inst{63-56} = soffset;
}

class MIMGe <bits<7> op> : Enc64 {
  bits<8> vdata;
  bits<4> dmask;
  bits<1> unorm;
  bits<1> glc;
  bits<1> da;
  bits<1> r128;
  bits<1> tfe;
  bits<1> lwe;
  bits<1> slc;
  bits<8> vaddr;
  bits<7> srsrc;
  bits<7> ssamp;

  let Inst{11-8} = dmask;
  let Inst{12} = unorm;
  let Inst{13} = glc;
  let Inst{14} = da;
  let Inst{15} = r128;
  let Inst{16} = tfe;
  let Inst{17} = lwe;
  let Inst{24-18} = op;
  let Inst{25} = slc;
  let Inst{31-26} = 0x3c;
  let Inst{39-32} = vaddr;
  let Inst{47-40} = vdata;
  let Inst{52-48} = srsrc{6-2};
  let Inst{57-53} = ssamp{6-2};
}

class FLATe<bits<7> op> : Enc64 {
  bits<8> addr;
  bits<8> data;
  bits<8> vdst;
  bits<1> slc;
  bits<1> glc;
  bits<1> tfe;

  // 15-0 is reserved.
  let Inst{16} = glc;
  let Inst{17} = slc;
  let Inst{24-18} = op;
  let Inst{31-26} = 0x37; // Encoding.
  let Inst{39-32} = addr;
  let Inst{47-40} = data;
  // 54-48 is reserved.
  let Inst{55} = tfe;
  let Inst{63-56} = vdst;
}

class EXPe : Enc64 {
  bits<4> en;
  bits<6> tgt;
  bits<1> compr;
  bits<1> done;
  bits<1> vm;
  bits<8> vsrc0;
  bits<8> vsrc1;
  bits<8> vsrc2;
  bits<8> vsrc3;

  let Inst{3-0} = en;
  let Inst{9-4} = tgt;
  let Inst{10} = compr;
  let Inst{11} = done;
  let Inst{12} = vm;
  let Inst{31-26} = 0x3e;
  let Inst{39-32} = vsrc0;
  let Inst{47-40} = vsrc1;
  let Inst{55-48} = vsrc2;
  let Inst{63-56} = vsrc3;
}

let Uses = [EXEC] in {

class VOP1 <bits<8> op, dag outs, dag ins, string asm, list<dag> pattern> :
    VOP1Common <outs, ins, asm, pattern>,
    VOP1e<op> {
  let isCodeGenOnly = 0;
}

class VOP2 <bits<6> op, dag outs, dag ins, string asm, list<dag> pattern> :
    VOP2Common <outs, ins, asm, pattern>, VOP2e<op> {
  let isCodeGenOnly = 0;
}

class VOPC <bits<8> op, dag ins, string asm, list<dag> pattern> :
    VOPCCommon <ins, asm, pattern>, VOPCe <op>;

class VINTRPCommon <dag outs, dag ins, string asm, list<dag> pattern> :
    InstSI <outs, ins, asm, pattern> {
  let mayLoad = 1;
  let mayStore = 0;
  let hasSideEffects = 0;
}

} // End Uses = [EXEC]

//===----------------------------------------------------------------------===//
// Vector I/O operations
//===----------------------------------------------------------------------===//

class DS <dag outs, dag ins, string asm, list<dag> pattern> :
    InstSI <outs, ins, asm, pattern> {

  let LGKM_CNT = 1;
  let DS = 1;
  let UseNamedOperandTable = 1;
  let Uses = [M0, EXEC];

  // Most instruction load and store data, so set this as the default.
  let mayLoad = 1;
  let mayStore = 1;

  let hasSideEffects = 0;
  let AsmMatchConverter = "cvtDS";
  let SchedRW = [WriteLDS];
}

class MUBUF <dag outs, dag ins, string asm, list<dag> pattern> :
    InstSI<outs, ins, asm, pattern> {

  let VM_CNT = 1;
  let EXP_CNT = 1;
  let MUBUF = 1;
  let Uses = [EXEC];

  let hasSideEffects = 0;
  let UseNamedOperandTable = 1;
  let AsmMatchConverter = "cvtMubuf";
  let SchedRW = [WriteVMEM];
}

class MTBUF <dag outs, dag ins, string asm, list<dag> pattern> :
    InstSI<outs, ins, asm, pattern> {

  let VM_CNT = 1;
  let EXP_CNT = 1;
  let MTBUF = 1;
  let Uses = [EXEC];

  let hasSideEffects = 0;
  let UseNamedOperandTable = 1;
  let SchedRW = [WriteVMEM];
}

class FLAT <bits<7> op, dag outs, dag ins, string asm, list<dag> pattern> :
    InstSI<outs, ins, asm, pattern>, FLATe <op> {
  let FLAT = 1;
  // Internally, FLAT instruction are executed as both an LDS and a
  // Buffer instruction; so, they increment both VM_CNT and LGKM_CNT
  // and are not considered done until both have been decremented.
  let VM_CNT = 1;
  let LGKM_CNT = 1;

  let Uses = [EXEC, FLAT_SCR]; // M0

  let UseNamedOperandTable = 1;
  let hasSideEffects = 0;
  let AsmMatchConverter = "cvtFlat";
  let SchedRW = [WriteVMEM];
}

class MIMG <bits<7> op, dag outs, dag ins, string asm, list<dag> pattern> :
    InstSI <outs, ins, asm, pattern>, MIMGe <op> {

  let VM_CNT = 1;
  let EXP_CNT = 1;
  let MIMG = 1;
  let Uses = [EXEC];

  let UseNamedOperandTable = 1;
  let hasSideEffects = 0; // XXX ????
}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d14 2
a15 3
class InstSI <dag outs, dag ins, string asm = "",
              list<dag> pattern = []> :
  AMDGPUInst<outs, ins, asm, pattern>, PredicateControl {
a33 2
  field bits<1> SDWA = 0;
  field bits<1> DPP = 0;
a40 2

  // Whether WQM _must_ be enabled for this instruction.
a47 5
  field bits<1> Gather4 = 0;

  // Whether WQM _must_ be disabled for this instruction.
  field bits<1> DisableWQM = 0;

a65 2
  let TSFlags{14} = SDWA;
  let TSFlags{15} = DPP;
d67 9
a75 11
  let TSFlags{16} = MUBUF;
  let TSFlags{17} = MTBUF;
  let TSFlags{18} = SMRD;
  let TSFlags{19} = DS;
  let TSFlags{20} = MIMG;
  let TSFlags{21} = FLAT;
  let TSFlags{22} = WQM;
  let TSFlags{23} = VGPRSpill;
  let TSFlags{24} = VOPAsmPrefer32Bit;
  let TSFlags{25} = Gather4;
  let TSFlags{26} = DisableWQM;
a77 12

  field bits<1> DisableSIDecoder = 0;
  field bits<1> DisableVIDecoder = 0;
  field bits<1> DisableDecoder = 0;

  let isAsmParserOnly = !if(!eq(DisableDecoder{0}, {0}), 0, 1);
}

class PseudoInstSI<dag outs, dag ins, list<dag> pattern = []>
  : InstSI<outs, ins, "", pattern> {
  let isPseudo = 1;
  let isCodeGenOnly = 1;
d126 2
a127 4
class VOP3Common <dag outs, dag ins, string asm = "",
                  list<dag> pattern = [], bit HasMods = 0,
                  bit VOP3Only = 0> :
  VOPAnyCommon <outs, ins, asm, pattern> {
d138 1
a138 5
  let AsmMatchConverter =
    !if(!eq(VOP3Only,1),
        "cvtVOP3",
        !if(!eq(HasMods,1), "cvtVOP3_2_mod", ""));

d157 1
a157 1
  bits<8> src0;
d159 1
a159 1
  let Inst{7-0} = src0;
d167 2
a168 2
  bits<8> src0;
  bits<8> src1;
d170 2
a171 2
  let Inst{7-0} = src0;
  let Inst{15-8} = src1;
d178 2
a179 2
  bits<8> src0;
  bits<8> src1;
d181 2
a182 2
  let Inst{7-0} = src0;
  let Inst{15-8} = src1;
d221 1
d223 1
a230 12
class SMRD_IMMe <bits<5> op> : SMRDe<op, 1> {
  bits<8> offset;
  let Inst{7-0} = offset;
}

class SMRD_SOFFe <bits<5> op> : SMRDe<op, 0> {
  bits<8> soff;
  let Inst{7-0} = soff;
}



d351 2
a352 2
  bits<8>  src1;
  bits<32> imm;
d355 1
a355 1
  let Inst{16-9} = src1;
d359 1
a359 1
  let Inst{63-32} = imm;
d362 2
a363 1
class VOP3a <bits<9> op> : Enc64 {
d373 1
a388 14
class VOP3e <bits<9> op> : VOP3a <op> {
  bits<8> vdst;

  let Inst{7-0} = vdst;
}

// Encoding used for VOPC instructions encoded as VOP3
// Differs from VOP3e by destination name (sdst) as VOPC doesn't have vector dst
class VOP3ce <bits<9> op> : VOP3a <op> {
  bits<8> sdst;

  let Inst{7-0} = sdst;
}

d415 1
a415 1
  bits<8> src1;
d418 1
a418 1
  let Inst{16-9} = src1;
d678 1
d682 2
a683 2
class MIMG <dag outs, dag ins, string asm, list<dag> pattern> :
    InstSI <outs, ins, asm, pattern> {
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d18 26
a43 37
  // Low bits - basic encoding information.
  field bit SALU = 0;
  field bit VALU = 0;

  // SALU instruction formats.
  field bit SOP1 = 0;
  field bit SOP2 = 0;
  field bit SOPC = 0;
  field bit SOPK = 0;
  field bit SOPP = 0;

  // VALU instruction formats.
  field bit VOP1 = 0;
  field bit VOP2 = 0;
  field bit VOPC = 0;
  field bit VOP3 = 0;
  field bit VINTRP = 0;
  field bit SDWA = 0;
  field bit DPP = 0;

  // Memory instruction formats.
  field bit MUBUF = 0;
  field bit MTBUF = 0;
  field bit SMRD = 0;
  field bit MIMG = 0;
  field bit EXP = 0;
  field bit FLAT = 0;
  field bit DS = 0;

   // Pseudo instruction formats.
  field bit VGPRSpill = 0;
  field bit SGPRSpill = 0;

  // High bits - other information.
  field bit VM_CNT = 0;
  field bit EXP_CNT = 0;
  field bit LGKM_CNT = 0;
d46 2
a47 19
  field bit WQM = 0;

  // Whether WQM _must_ be disabled for this instruction.
  field bit DisableWQM = 0;

  field bit Gather4 = 0;

  // Most sopk treat the immediate as a signed 16-bit, however some
  // use it as unsigned.
  field bit SOPKZext = 0;

  // This is an s_store_dword* instruction that requires a cache flush
  // on wave termination. It is necessary to distinguish from mayStore
  // SMEM instructions like the cache flush ones.
  field bit ScalarStore = 0;

  // Whether the operands can be ignored when computing the
  // instruction size.
  field bit FixedSize = 0;
d51 1
a51 1
  field bit VOPAsmPrefer32Bit = 0;
d53 1
a53 3
  // These need to be kept in sync with the enum in SIInstrFlags.
  let TSFlags{0} = SALU;
  let TSFlags{1} = VALU;
d55 2
a56 10
  let TSFlags{2} = SOP1;
  let TSFlags{3} = SOP2;
  let TSFlags{4} = SOPC;
  let TSFlags{5} = SOPK;
  let TSFlags{6} = SOPP;

  let TSFlags{7} = VOP1;
  let TSFlags{8} = VOP2;
  let TSFlags{9} = VOPC;
  let TSFlags{10} = VOP3;
d58 18
a75 1
  let TSFlags{13} = VINTRP;
d82 2
a83 2
  let TSFlags{19} = MIMG;
  let TSFlags{20} = EXP;
d85 1
a85 2
  let TSFlags{22} = DS;

d87 3
a89 14
  let TSFlags{24} = SGPRSpill;

  let TSFlags{32} = VM_CNT;
  let TSFlags{33} = EXP_CNT;
  let TSFlags{34} = LGKM_CNT;

  let TSFlags{35} = WQM;
  let TSFlags{36} = DisableWQM;
  let TSFlags{37} = Gather4;

  let TSFlags{38} = SOPKZext;
  let TSFlags{39} = ScalarStore;
  let TSFlags{40} = FixedSize;
  let TSFlags{41} = VOPAsmPrefer32Bit;
a97 1
  let AsmVariantName = AMDGPUAsmVariants.Default;
d106 188
a293 2
class SPseudoInstSI<dag outs, dag ins, list<dag> pattern = []>
  : PseudoInstSI<outs, ins, pattern> {
d295 1
d298 37
a334 4
class VPseudoInstSI<dag outs, dag ins, list<dag> pattern = []>
  : PseudoInstSI<outs, ins, pattern> {
  let VALU = 1;
  let Uses = [EXEC];
d337 2
a338 3
class CFPseudoInstSI<dag outs, dag ins, list<dag> pattern = [],
  bit UseExec = 0, bit DefExec = 0> :
  SPseudoInstSI<outs, ins, pattern> {
a339 2
  let Uses = !if(UseExec, [EXEC], []);
  let Defs = !if(DefExec, [EXEC, SCC], [SCC]);
d343 4
d349 84
a432 3
class Enc32 {
  field bits<32> Inst;
  int Size = 4;
d435 6
a440 3
class Enc64 {
  field bits<64> Inst;
  int Size = 8;
d443 33
a475 1
class VOPDstOperand <RegisterClass rc> : RegisterOperand <rc, "printVOPDst">;
d491 82
d603 20
d648 14
d664 1
a664 13
  let VINTRP = 1;
  // VINTRP instructions read parameter values from LDS, but these parameter
  // values are stored outside of the LDS memory that is allocated to the
  // shader for general purpose use.
  //
  // While it may be possible for ds_read/ds_write instructions to access
  // the parameter values in LDS, this would essentially be an out-of-bounds
  // memory access which we consider to be undefined behavior.
  //
  // So even though these instructions read memory, this memory is outside the
  // addressable memory space for the shader, and we consider these instructions
  // to be readnone.
  let mayLoad = 0;
d669 27
a695 3
class EXPCommon<dag outs, dag ins, string asm, list<dag> pattern> :
  InstSI<outs, ins, asm, pattern> {
  let EXP = 1;
d697 4
a700 2
  let mayLoad = 0; // Set to 1 if done bit is set.
  let mayStore = 1;
d702 10
d713 4
a716 1
  let SchedRW = [WriteExport];
d719 15
a733 1
} // End Uses = [EXEC]
@


