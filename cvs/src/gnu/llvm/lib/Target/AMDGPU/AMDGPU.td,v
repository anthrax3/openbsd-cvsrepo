head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.4.0.2
	OPENBSD_6_1_BASE:1.1.1.4
	LLVM_4_0_0:1.1.1.4
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.04;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.33;	author patrick;	state Exp;
branches;
next	1.1.1.4;
commitid	so2WA7LCP6wbxtYl;

1.1.1.4
date	2017.03.14.08.08.10;	author patrick;	state Exp;
branches;
next	;
commitid	aUi5NxOzBSLCN5eN;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- AMDGPU.td - AMDGPU Tablegen files ------------------*- tablegen -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

include "llvm/Target/Target.td"

//===----------------------------------------------------------------------===//
// Subtarget Features
//===----------------------------------------------------------------------===//

// Debugging Features

def FeatureDumpCode : SubtargetFeature <"DumpCode",
        "DumpCode",
        "true",
        "Dump MachineInstrs in the CodeEmitter">;

def FeatureDumpCodeLower : SubtargetFeature <"dumpcode",
        "DumpCode",
        "true",
        "Dump MachineInstrs in the CodeEmitter">;

def FeatureIRStructurizer : SubtargetFeature <"disable-irstructurizer",
        "EnableIRStructurizer",
        "false",
        "Disable IR Structurizer">;

def FeaturePromoteAlloca : SubtargetFeature <"promote-alloca",
        "EnablePromoteAlloca",
        "true",
        "Enable promote alloca pass">;

// Target features

def FeatureIfCvt : SubtargetFeature <"disable-ifcvt",
        "EnableIfCvt",
        "false",
        "Disable the if conversion pass">;

def FeatureFP64 : SubtargetFeature<"fp64",
        "FP64",
        "true",
        "Enable double precision operations">;

def FeatureFP64Denormals : SubtargetFeature<"fp64-denormals",
        "FP64Denormals",
        "true",
        "Enable double precision denormal handling",
        [FeatureFP64]>;

def FeatureFastFMAF32 : SubtargetFeature<"fast-fmaf",
        "FastFMAF32",
        "true",
        "Assuming f32 fma is at least as fast as mul + add",
        []>;

// Some instructions do not support denormals despite this flag. Using
// fp32 denormals also causes instructions to run at the double
// precision rate for the device.
def FeatureFP32Denormals : SubtargetFeature<"fp32-denormals",
        "FP32Denormals",
        "true",
        "Enable single precision denormal handling">;

def FeatureR600ALUInst : SubtargetFeature<"R600ALUInst",
        "R600ALUInst",
        "false",
        "Older version of ALU instructions encoding">;

def FeatureVertexCache : SubtargetFeature<"HasVertexCache",
        "HasVertexCache",
        "true",
        "Specify use of dedicated vertex cache">;

def FeatureCaymanISA : SubtargetFeature<"caymanISA",
        "CaymanISA",
        "true",
        "Use Cayman ISA">;

def FeatureCFALUBug : SubtargetFeature<"cfalubug",
        "CFALUBug",
        "true",
        "GPU has CF_ALU bug">;

// XXX - This should probably be removed once enabled by default
def FeatureEnableLoadStoreOpt : SubtargetFeature <"load-store-opt",
        "EnableLoadStoreOpt",
        "true",
        "Enable SI load/store optimizer pass">;

// Performance debugging feature. Allow using DS instruction immediate
// offsets even if the base pointer can't be proven to be base. On SI,
// base pointer values that won't give the same result as a 16-bit add
// are not safe to fold, but this will override the conservative test
// for the base pointer.
def FeatureEnableUnsafeDSOffsetFolding : SubtargetFeature <"unsafe-ds-offset-folding",
        "EnableUnsafeDSOffsetFolding",
        "true",
        "Force using DS instruction immediate offsets on SI">;

def FeatureFlatForGlobal : SubtargetFeature<"flat-for-global",
        "FlatForGlobal",
        "true",
        "Force to generate flat instruction for global">;

def FeatureFlatAddressSpace : SubtargetFeature<"flat-address-space",
        "FlatAddressSpace",
        "true",
        "Support flat address space">;

def FeatureXNACK : SubtargetFeature<"xnack",
        "EnableXNACK",
        "true",
        "Enable XNACK support">;

def FeatureVGPRSpilling : SubtargetFeature<"vgpr-spilling",
        "EnableVGPRSpilling",
        "true",
        "Enable spilling of VGPRs to scratch memory">;

def FeatureSGPRInitBug : SubtargetFeature<"sgpr-init-bug",
        "SGPRInitBug",
        "true",
        "VI SGPR initilization bug requiring a fixed SGPR allocation size">;

def FeatureEnableHugeScratchBuffer : SubtargetFeature<"huge-scratch-buffer",
        "EnableHugeScratchBuffer",
        "true",
        "Enable scratch buffer sizes greater than 128 GB">;

def FeatureEnableSIScheduler : SubtargetFeature<"si-scheduler",
        "EnableSIScheduler",
        "true",
        "Enable SI Machine Scheduler">;

class SubtargetFeatureFetchLimit <string Value> :
                          SubtargetFeature <"fetch"#Value,
        "TexVTXClauseSize",
        Value,
        "Limit the maximum number of fetches in a clause to "#Value>;

def FeatureFetchLimit8 : SubtargetFeatureFetchLimit <"8">;
def FeatureFetchLimit16 : SubtargetFeatureFetchLimit <"16">;

class SubtargetFeatureWavefrontSize <int Value> : SubtargetFeature<
        "wavefrontsize"#Value,
        "WavefrontSize",
        !cast<string>(Value),
        "The number of threads per wavefront">;

def FeatureWavefrontSize16 : SubtargetFeatureWavefrontSize<16>;
def FeatureWavefrontSize32 : SubtargetFeatureWavefrontSize<32>;
def FeatureWavefrontSize64 : SubtargetFeatureWavefrontSize<64>;

class SubtargetFeatureLDSBankCount <int Value> : SubtargetFeature <
      "ldsbankcount"#Value,
      "LDSBankCount",
      !cast<string>(Value),
      "The number of LDS banks per compute unit.">;

def FeatureLDSBankCount16 : SubtargetFeatureLDSBankCount<16>;
def FeatureLDSBankCount32 : SubtargetFeatureLDSBankCount<32>;

class SubtargetFeatureISAVersion <int Major, int Minor, int Stepping>
                                 : SubtargetFeature <
      "isaver"#Major#"."#Minor#"."#Stepping,
      "IsaVersion",
      "ISAVersion"#Major#"_"#Minor#"_"#Stepping,
      "Instruction set version number"
>;

def FeatureISAVersion7_0_0 : SubtargetFeatureISAVersion <7,0,0>;
def FeatureISAVersion7_0_1 : SubtargetFeatureISAVersion <7,0,1>;
def FeatureISAVersion8_0_0 : SubtargetFeatureISAVersion <8,0,0>;
def FeatureISAVersion8_0_1 : SubtargetFeatureISAVersion <8,0,1>;
def FeatureISAVersion8_0_3 : SubtargetFeatureISAVersion <8,0,3>;

class SubtargetFeatureLocalMemorySize <int Value> : SubtargetFeature<
        "localmemorysize"#Value,
        "LocalMemorySize",
        !cast<string>(Value),
        "The size of local memory in bytes">;

def FeatureGCN : SubtargetFeature<"gcn",
        "IsGCN",
        "true",
        "GCN or newer GPU">;

def FeatureGCN1Encoding : SubtargetFeature<"gcn1-encoding",
        "GCN1Encoding",
        "true",
        "Encoding format for SI and CI">;

def FeatureGCN3Encoding : SubtargetFeature<"gcn3-encoding",
        "GCN3Encoding",
        "true",
        "Encoding format for VI">;

def FeatureCIInsts : SubtargetFeature<"ci-insts",
        "CIInsts",
        "true",
        "Additional intstructions for CI+">;

class FeatureMaxPrivateElementSize<int size> : SubtargetFeature<
  "max-private-element-size-"#size,
  "MaxPrivateElementSize",
  !cast<string>(size),
  "Maximum private access size may be "#size
>;

def FeatureMaxPrivateElementSize4 : FeatureMaxPrivateElementSize<4>;
def FeatureMaxPrivateElementSize8 : FeatureMaxPrivateElementSize<8>;
def FeatureMaxPrivateElementSize16 : FeatureMaxPrivateElementSize<16>;

// Dummy feature used to disable assembler instructions.
def FeatureDisable : SubtargetFeature<"",
                                      "FeatureDisable","true",
                                      "Dummy feature to disable assembler"
                                      " instructions">;

class SubtargetFeatureGeneration <string Value,
                                  list<SubtargetFeature> Implies> :
        SubtargetFeature <Value, "Gen", "AMDGPUSubtarget::"#Value,
                          Value#" GPU generation", Implies>;

def FeatureLocalMemorySize0 : SubtargetFeatureLocalMemorySize<0>;
def FeatureLocalMemorySize32768 : SubtargetFeatureLocalMemorySize<32768>;
def FeatureLocalMemorySize65536 : SubtargetFeatureLocalMemorySize<65536>;

def FeatureR600 : SubtargetFeatureGeneration<"R600",
        [FeatureR600ALUInst, FeatureFetchLimit8, FeatureLocalMemorySize0]>;

def FeatureR700 : SubtargetFeatureGeneration<"R700",
        [FeatureFetchLimit16, FeatureLocalMemorySize0]>;

def FeatureEvergreen : SubtargetFeatureGeneration<"EVERGREEN",
        [FeatureFetchLimit16, FeatureLocalMemorySize32768]>;

def FeatureNorthernIslands : SubtargetFeatureGeneration<"NORTHERN_ISLANDS",
        [FeatureFetchLimit16, FeatureWavefrontSize64,
         FeatureLocalMemorySize32768]
>;

def FeatureSouthernIslands : SubtargetFeatureGeneration<"SOUTHERN_ISLANDS",
        [FeatureFP64, FeatureLocalMemorySize32768,
         FeatureWavefrontSize64, FeatureGCN, FeatureGCN1Encoding,
         FeatureLDSBankCount32]>;

def FeatureSeaIslands : SubtargetFeatureGeneration<"SEA_ISLANDS",
        [FeatureFP64, FeatureLocalMemorySize65536,
         FeatureWavefrontSize64, FeatureGCN, FeatureFlatAddressSpace,
         FeatureGCN1Encoding, FeatureCIInsts]>;

def FeatureVolcanicIslands : SubtargetFeatureGeneration<"VOLCANIC_ISLANDS",
        [FeatureFP64, FeatureLocalMemorySize65536,
         FeatureWavefrontSize64, FeatureFlatAddressSpace, FeatureGCN,
         FeatureGCN3Encoding, FeatureCIInsts]>;

//===----------------------------------------------------------------------===//

def AMDGPUInstrInfo : InstrInfo {
  let guessInstructionProperties = 1;
  let noNamedPositionallyEncodedOperands = 1;
}

def AMDGPUAsmParser : AsmParser {
  // Some of the R600 registers have the same name, so this crashes.
  // For example T0_XYZW and T0_XY both have the asm name T0.
  let ShouldEmitMatchRegisterName = 0;
}

def AMDGPU : Target {
  // Pull in Instruction Info:
  let InstructionSet = AMDGPUInstrInfo;
  let AssemblyParsers = [AMDGPUAsmParser];
}

// Dummy Instruction itineraries for pseudo instructions
def ALU_NULL : FuncUnit;
def NullALU : InstrItinClass;

//===----------------------------------------------------------------------===//
// Predicate helper class
//===----------------------------------------------------------------------===//

def TruePredicate : Predicate<"true">;
def isSICI : Predicate<
  "Subtarget->getGeneration() == AMDGPUSubtarget::SOUTHERN_ISLANDS ||"
  "Subtarget->getGeneration() == AMDGPUSubtarget::SEA_ISLANDS"
>, AssemblerPredicate<"FeatureGCN1Encoding">;

def isVI : Predicate <
  "Subtarget->getGeneration() >= AMDGPUSubtarget::VOLCANIC_ISLANDS">,
  AssemblerPredicate<"FeatureGCN3Encoding">;

class PredicateControl {
  Predicate SubtargetPredicate;
  Predicate SIAssemblerPredicate = isSICI;
  Predicate VIAssemblerPredicate = isVI;
  list<Predicate> AssemblerPredicates = [];
  Predicate AssemblerPredicate = TruePredicate;
  list<Predicate> OtherPredicates = [];
  list<Predicate> Predicates = !listconcat([SubtargetPredicate, AssemblerPredicate],
                                            AssemblerPredicates,
                                            OtherPredicates);
}

// Include AMDGPU TD files
include "R600Schedule.td"
include "SISchedule.td"
include "Processors.td"
include "AMDGPUInstrInfo.td"
include "AMDGPUIntrinsics.td"
include "AMDGPURegisterInfo.td"
include "AMDGPUInstructions.td"
include "AMDGPUCallingConv.td"
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d1 1
a1 1
//===-- AMDGPU.td - AMDGPU Tablegen files --------*- tablegen -*-===//
d8 1
a8 1
//===------------------------------------------------------------===//
d12 32
a43 3
//===------------------------------------------------------------===//
// Subtarget Features (device properties)
//===------------------------------------------------------------===//
d46 9
a54 4
  "FP64",
  "true",
  "Enable double precision operations"
>;
d57 4
a60 4
  "FastFMAF32",
  "true",
  "Assuming f32 fma is at least as fast as mul + add"
>;
d62 7
a68 5
def HalfRate64Ops : SubtargetFeature<"half-rate-64-ops",
  "HalfRate64Ops",
  "true",
  "Most fp64 instructions are half rate instead of quarter"
>;
d71 3
a73 4
  "R600ALUInst",
  "false",
  "Older version of ALU instructions encoding"
>;
d76 3
a78 4
  "HasVertexCache",
  "true",
  "Specify use of dedicated vertex cache"
>;
d81 3
a83 4
  "CaymanISA",
  "true",
  "Use Cayman ISA"
>;
d86 24
a109 4
  "CFALUBug",
  "true",
  "GPU has CF_ALU bug"
>;
d112 3
a114 4
  "FlatAddressSpace",
  "true",
  "Support flat address space"
>;
d116 4
a119 5
def FeatureUnalignedBufferAccess : SubtargetFeature<"unaligned-buffer-access",
  "UnalignedBufferAccess",
  "true",
  "Support unaligned global loads and stores"
>;
d121 4
a124 5
def FeatureXNACK : SubtargetFeature<"xnack",
  "EnableXNACK",
  "true",
  "Enable XNACK support"
>;
d127 13
a139 4
  "SGPRInitBug",
  "true",
  "VI SGPR initilization bug requiring a fixed SGPR allocation size"
>;
d143 3
a145 4
  "TexVTXClauseSize",
  Value,
  "Limit the maximum number of fetches in a clause to "#Value
>;
d151 4
a154 5
  "wavefrontsize"#Value,
  "WavefrontSize",
  !cast<string>(Value),
  "The number of threads per wavefront"
>;
d161 4
a164 5
  "ldsbankcount"#Value,
  "LDSBankCount",
  !cast<string>(Value),
  "The number of LDS banks per compute unit."
>;
d171 4
a174 4
  "isaver"#Major#"."#Minor#"."#Stepping,
  "IsaVersion",
  "ISAVersion"#Major#"_"#Minor#"_"#Stepping,
  "Instruction set version number"
d184 4
a187 5
  "localmemorysize"#Value,
  "LocalMemorySize",
  !cast<string>(Value),
  "The size of local memory in bytes"
>;
d190 3
a192 4
  "IsGCN",
  "true",
  "GCN or newer GPU"
>;
d195 3
a197 4
  "GCN1Encoding",
  "true",
  "Encoding format for SI and CI"
>;
d200 3
a202 4
  "GCN3Encoding",
  "true",
  "Encoding format for VI"
>;
d205 3
a207 42
  "CIInsts",
  "true",
  "Additional intstructions for CI+"
>;

def FeatureSMemRealTime : SubtargetFeature<"s-memrealtime",
  "HasSMemRealTime",
  "true",
  "Has s_memrealtime instruction"
>;

def Feature16BitInsts : SubtargetFeature<"16-bit-insts",
  "Has16BitInsts",
  "true",
  "Has i16/f16 instructions"
>;

//===------------------------------------------------------------===//
// Subtarget Features (options and debugging)
//===------------------------------------------------------------===//

// Some instructions do not support denormals despite this flag. Using
// fp32 denormals also causes instructions to run at the double
// precision rate for the device.
def FeatureFP32Denormals : SubtargetFeature<"fp32-denormals",
  "FP32Denormals",
  "true",
  "Enable single precision denormal handling"
>;

def FeatureFP64Denormals : SubtargetFeature<"fp64-denormals",
  "FP64Denormals",
  "true",
  "Enable double precision denormal handling",
  [FeatureFP64]
>;

def FeatureFPExceptions : SubtargetFeature<"fp-exceptions",
  "FPExceptions",
  "true",
  "Enable floating point exceptions"
>;
a219 55
def FeatureVGPRSpilling : SubtargetFeature<"vgpr-spilling",
  "EnableVGPRSpilling",
  "true",
  "Enable spilling of VGPRs to scratch memory"
>;

def FeatureDumpCode : SubtargetFeature <"DumpCode",
  "DumpCode",
  "true",
  "Dump MachineInstrs in the CodeEmitter"
>;

def FeatureDumpCodeLower : SubtargetFeature <"dumpcode",
  "DumpCode",
  "true",
  "Dump MachineInstrs in the CodeEmitter"
>;

def FeaturePromoteAlloca : SubtargetFeature <"promote-alloca",
  "EnablePromoteAlloca",
  "true",
  "Enable promote alloca pass"
>;

// XXX - This should probably be removed once enabled by default
def FeatureEnableLoadStoreOpt : SubtargetFeature <"load-store-opt",
  "EnableLoadStoreOpt",
  "true",
  "Enable SI load/store optimizer pass"
>;

// Performance debugging feature. Allow using DS instruction immediate
// offsets even if the base pointer can't be proven to be base. On SI,
// base pointer values that won't give the same result as a 16-bit add
// are not safe to fold, but this will override the conservative test
// for the base pointer.
def FeatureEnableUnsafeDSOffsetFolding : SubtargetFeature <
  "unsafe-ds-offset-folding",
  "EnableUnsafeDSOffsetFolding",
  "true",
  "Force using DS instruction immediate offsets on SI"
>;

def FeatureEnableSIScheduler : SubtargetFeature<"si-scheduler",
  "EnableSIScheduler",
  "true",
  "Enable SI Machine Scheduler"
>;

def FeatureFlatForGlobal : SubtargetFeature<"flat-for-global",
  "FlatForGlobal",
  "true",
  "Force to generate flat instruction for global"
>;

d222 3
a224 3
  "FeatureDisable","true",
  "Dummy feature to disable assembler instructions"
>;
d236 1
a236 2
  [FeatureR600ALUInst, FeatureFetchLimit8, FeatureLocalMemorySize0]
>;
d239 1
a239 2
  [FeatureFetchLimit16, FeatureLocalMemorySize0]
>;
d242 1
a242 2
  [FeatureFetchLimit16, FeatureLocalMemorySize32768]
>;
d245 2
a246 2
  [FeatureFetchLimit16, FeatureWavefrontSize64,
   FeatureLocalMemorySize32768]
d250 3
a252 4
  [FeatureFP64, FeatureLocalMemorySize32768,
  FeatureWavefrontSize64, FeatureGCN, FeatureGCN1Encoding,
  FeatureLDSBankCount32]
>;
d255 3
a257 4
  [FeatureFP64, FeatureLocalMemorySize65536,
  FeatureWavefrontSize64, FeatureGCN, FeatureFlatAddressSpace,
  FeatureGCN1Encoding, FeatureCIInsts]
>;
d260 3
a262 31
  [FeatureFP64, FeatureLocalMemorySize65536,
   FeatureWavefrontSize64, FeatureFlatAddressSpace, FeatureGCN,
   FeatureGCN3Encoding, FeatureCIInsts, Feature16BitInsts,
   FeatureSMemRealTime
  ]
>;

//===----------------------------------------------------------------------===//
// Debugger related subtarget features.
//===----------------------------------------------------------------------===//

def FeatureDebuggerInsertNops : SubtargetFeature<
  "amdgpu-debugger-insert-nops",
  "DebuggerInsertNops",
  "true",
  "Insert one nop instruction for each high level source statement"
>;

def FeatureDebuggerReserveRegs : SubtargetFeature<
  "amdgpu-debugger-reserve-regs",
  "DebuggerReserveRegs",
  "true",
  "Reserve registers for debugger usage"
>;

def FeatureDebuggerEmitPrologue : SubtargetFeature<
  "amdgpu-debugger-emit-prologue",
  "DebuggerEmitPrologue",
  "true",
  "Emit debugger prologue"
>;
a291 1

a299 7

def isCIVI : Predicate <
  "Subtarget->getGeneration() == AMDGPUSubtarget::SEA_ISLANDS || "
  "Subtarget->getGeneration() == AMDGPUSubtarget::VOLCANIC_ISLANDS"
>, AssemblerPredicate<"FeatureCIInsts">;

def HasFlatAddressSpace : Predicate<"Subtarget->hasFlatAddressSpace()">;
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a69 13
def FeatureUnalignedScratchAccess : SubtargetFeature<"unaligned-scratch-access",
  "UnalignedScratchAccess",
  "true",
  "Support unaligned scratch loads and stores"
>;

// XNACK is disabled if SH_MEM_CONFIG.ADDRESS_MODE = GPUVM on chips that support
// XNACK. The current default kernel driver setting is:
// - graphics ring: XNACK disabled
// - compute ring: XNACK enabled
//
// If XNACK is enabled, the VMEM latency can be worse.
// If XNACK is disabled, the 2 SGPRs can be used for general purposes.
d113 14
a163 6
def FeatureInv2PiInlineImm : SubtargetFeature<"inv-2pi-inline-imm",
  "HasInv2PiInlineImm",
  "true",
  "Has 1 / (2 * pi) as inline immediate"
>;

a169 18
def FeatureMovrel : SubtargetFeature<"movrel",
  "HasMovrel",
  "true",
  "Has v_movrel*_b32 instructions"
>;

def FeatureVGPRIndexMode : SubtargetFeature<"vgpr-index-mode",
  "HasVGPRIndexMode",
  "true",
  "Has VGPR mode register indexing"
>;

def FeatureScalarStores : SubtargetFeature<"scalar-stores",
  "HasScalarStores",
  "true",
  "Has store scalar memory instructions"
>;

a173 6
def FeatureFP16Denormals : SubtargetFeature<"fp16-denormals",
  "FP16Denormals",
  "true",
  "Enable half precision denormal handling"
>;

d297 1
a297 1
  FeatureLDSBankCount32, FeatureMovrel]
d303 1
a303 1
  FeatureGCN1Encoding, FeatureCIInsts, FeatureMovrel]
d310 1
a310 2
   FeatureSMemRealTime, FeatureVGPRIndexMode, FeatureMovrel,
   FeatureScalarStores, FeatureInv2PiInlineImm
a313 52
class SubtargetFeatureISAVersion <int Major, int Minor, int Stepping,
                                  list<SubtargetFeature> Implies>
                                 : SubtargetFeature <
  "isaver"#Major#"."#Minor#"."#Stepping,
  "IsaVersion",
  "ISAVersion"#Major#"_"#Minor#"_"#Stepping,
  "Instruction set version number",
  Implies
>;

def FeatureISAVersion7_0_0 : SubtargetFeatureISAVersion <7,0,0,
  [FeatureSeaIslands,
   FeatureLDSBankCount32]>;

def FeatureISAVersion7_0_1 : SubtargetFeatureISAVersion <7,0,1,
  [FeatureSeaIslands,
   HalfRate64Ops,
   FeatureLDSBankCount32,
   FeatureFastFMAF32]>;

def FeatureISAVersion7_0_2 : SubtargetFeatureISAVersion <7,0,2,
  [FeatureSeaIslands,
   FeatureLDSBankCount16]>;

def FeatureISAVersion8_0_0 : SubtargetFeatureISAVersion <8,0,0,
  [FeatureVolcanicIslands,
   FeatureLDSBankCount32,
   FeatureSGPRInitBug]>;

def FeatureISAVersion8_0_1 : SubtargetFeatureISAVersion <8,0,1,
  [FeatureVolcanicIslands,
   FeatureLDSBankCount32,
   FeatureXNACK]>;

def FeatureISAVersion8_0_2 : SubtargetFeatureISAVersion <8,0,2,
  [FeatureVolcanicIslands,
   FeatureLDSBankCount32,
   FeatureSGPRInitBug]>;

def FeatureISAVersion8_0_3 : SubtargetFeatureISAVersion <8,0,3,
  [FeatureVolcanicIslands,
   FeatureLDSBankCount32]>;

def FeatureISAVersion8_0_4 : SubtargetFeatureISAVersion <8,0,4,
  [FeatureVolcanicIslands,
   FeatureLDSBankCount32]>;

def FeatureISAVersion8_1_0 : SubtargetFeatureISAVersion <8,1,0,
  [FeatureVolcanicIslands,
   FeatureLDSBankCount16,
   FeatureXNACK]>;

a351 37
def AMDGPUAsmWriter : AsmWriter {
  int PassSubtarget = 1;
}

def AMDGPUAsmVariants {
  string Default = "Default";
  int Default_ID = 0;
  string VOP3 = "VOP3";
  int VOP3_ID = 1;
  string SDWA = "SDWA";
  int SDWA_ID = 2;
  string DPP = "DPP";
  int DPP_ID = 3;
  string Disable = "Disable";
  int Disable_ID = 4;
}

def DefaultAMDGPUAsmParserVariant : AsmParserVariant {
  let Variant = AMDGPUAsmVariants.Default_ID;
  let Name = AMDGPUAsmVariants.Default;
}

def VOP3AsmParserVariant : AsmParserVariant {
  let Variant = AMDGPUAsmVariants.VOP3_ID;
  let Name = AMDGPUAsmVariants.VOP3;
}

def SDWAAsmParserVariant : AsmParserVariant {
  let Variant = AMDGPUAsmVariants.SDWA_ID;
  let Name = AMDGPUAsmVariants.SDWA;
}

def DPPAsmParserVariant : AsmParserVariant {
  let Variant = AMDGPUAsmVariants.DPP_ID;
  let Name = AMDGPUAsmVariants.DPP;
}

a355 5
  let AssemblyParserVariants = [DefaultAMDGPUAsmParserVariant,
                                VOP3AsmParserVariant,
                                SDWAAsmParserVariant,
                                DPPAsmParserVariant];
  let AssemblyWriters = [AMDGPUAsmWriter];
a382 2

def Has16BitInsts : Predicate<"Subtarget->has16BitInsts()">;
@


1.1.1.4
log
@Import LLVM 4.0.0 release including clang and lld.
@
text
@a284 6
// Unless +-flat-for-global is specified, turn on FlatForGlobal for
// all OS-es on VI and newer hardware to avoid assertion failures due
// to missing ADDR64 variants of MUBUF instructions.
// FIXME: moveToVALU should be able to handle converting addr64 MUBUF
// instructions.

@


