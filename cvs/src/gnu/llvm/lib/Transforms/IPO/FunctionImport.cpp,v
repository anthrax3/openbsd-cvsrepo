head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.3.0.6
	OPENBSD_6_2_BASE:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.4
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.02;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.23;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===- FunctionImport.cpp - ThinLTO Summary-based Function Import ---------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file implements Function import based on summaries.
//
//===----------------------------------------------------------------------===//

#include "llvm/Transforms/IPO/FunctionImport.h"

#include "llvm/ADT/StringSet.h"
#include "llvm/IR/AutoUpgrade.h"
#include "llvm/IR/DiagnosticPrinter.h"
#include "llvm/IR/IntrinsicInst.h"
#include "llvm/IR/Module.h"
#include "llvm/IRReader/IRReader.h"
#include "llvm/Linker/Linker.h"
#include "llvm/Object/FunctionIndexObjectFile.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/SourceMgr.h"

#include <map>

using namespace llvm;

#define DEBUG_TYPE "function-import"

/// Limit on instruction count of imported functions.
static cl::opt<unsigned> ImportInstrLimit(
    "import-instr-limit", cl::init(100), cl::Hidden, cl::value_desc("N"),
    cl::desc("Only import functions with less than N instructions"));

// Load lazily a module from \p FileName in \p Context.
static std::unique_ptr<Module> loadFile(const std::string &FileName,
                                        LLVMContext &Context) {
  SMDiagnostic Err;
  DEBUG(dbgs() << "Loading '" << FileName << "'\n");
  // Metadata isn't loaded or linked until after all functions are
  // imported, after which it will be materialized and linked.
  std::unique_ptr<Module> Result =
      getLazyIRFileModule(FileName, Err, Context,
                          /* ShouldLazyLoadMetadata = */ true);
  if (!Result) {
    Err.print("function-import", errs());
    return nullptr;
  }

  return Result;
}

namespace {
/// Helper to load on demand a Module from file and cache it for subsequent
/// queries. It can be used with the FunctionImporter.
class ModuleLazyLoaderCache {
  /// Cache of lazily loaded module for import.
  StringMap<std::unique_ptr<Module>> ModuleMap;

  /// Retrieve a Module from the cache or lazily load it on demand.
  std::function<std::unique_ptr<Module>(StringRef FileName)> createLazyModule;

public:
  /// Create the loader, Module will be initialized in \p Context.
  ModuleLazyLoaderCache(std::function<
      std::unique_ptr<Module>(StringRef FileName)> createLazyModule)
      : createLazyModule(createLazyModule) {}

  /// Retrieve a Module from the cache or lazily load it on demand.
  Module &operator()(StringRef FileName);

  std::unique_ptr<Module> takeModule(StringRef FileName) {
    auto I = ModuleMap.find(FileName);
    assert(I != ModuleMap.end());
    std::unique_ptr<Module> Ret = std::move(I->second);
    ModuleMap.erase(I);
    return Ret;
  }
};

// Get a Module for \p FileName from the cache, or load it lazily.
Module &ModuleLazyLoaderCache::operator()(StringRef Identifier) {
  auto &Module = ModuleMap[Identifier];
  if (!Module)
    Module = createLazyModule(Identifier);
  return *Module;
}
} // anonymous namespace

/// Walk through the instructions in \p F looking for external
/// calls not already in the \p CalledFunctions set. If any are
/// found they are added to the \p Worklist for importing.
static void findExternalCalls(const Module &DestModule, Function &F,
                              const FunctionInfoIndex &Index,
                              StringSet<> &CalledFunctions,
                              SmallVector<StringRef, 64> &Worklist) {
  // We need to suffix internal function calls imported from other modules,
  // prepare the suffix ahead of time.
  std::string Suffix;
  if (F.getParent() != &DestModule)
    Suffix =
        (Twine(".llvm.") +
         Twine(Index.getModuleId(F.getParent()->getModuleIdentifier()))).str();

  for (auto &BB : F) {
    for (auto &I : BB) {
      if (isa<CallInst>(I)) {
        auto CalledFunction = cast<CallInst>(I).getCalledFunction();
        // Insert any new external calls that have not already been
        // added to set/worklist.
        if (!CalledFunction || !CalledFunction->hasName())
          continue;
        // Ignore intrinsics early
        if (CalledFunction->isIntrinsic()) {
          assert(CalledFunction->getIntrinsicID() != 0);
          continue;
        }
        auto ImportedName = CalledFunction->getName();
        auto Renamed = (ImportedName + Suffix).str();
        // Rename internal functions
        if (CalledFunction->hasInternalLinkage()) {
          ImportedName = Renamed;
        }
        auto It = CalledFunctions.insert(ImportedName);
        if (!It.second) {
          // This is a call to a function we already considered, skip.
          continue;
        }
        // Ignore functions already present in the destination module
        auto *SrcGV = DestModule.getNamedValue(ImportedName);
        if (SrcGV) {
          if (GlobalAlias *SGA = dyn_cast<GlobalAlias>(SrcGV))
            SrcGV = SGA->getBaseObject();
          assert(isa<Function>(SrcGV) && "Name collision during import");
          if (!cast<Function>(SrcGV)->isDeclaration()) {
            DEBUG(dbgs() << DestModule.getModuleIdentifier() << ": Ignoring "
                         << ImportedName << " already in DestinationModule\n");
            continue;
          }
        }

        Worklist.push_back(It.first->getKey());
        DEBUG(dbgs() << DestModule.getModuleIdentifier()
                     << ": Adding callee for : " << ImportedName << " : "
                     << F.getName() << "\n");
      }
    }
  }
}

// Helper function: given a worklist and an index, will process all the worklist
// and decide what to import based on the summary information.
//
// Nothing is actually imported, functions are materialized in their source
// module and analyzed there.
//
// \p ModuleToFunctionsToImportMap is filled with the set of Function to import
// per Module.
static void GetImportList(Module &DestModule,
                          SmallVector<StringRef, 64> &Worklist,
                          StringSet<> &CalledFunctions,
                          std::map<StringRef, DenseSet<const GlobalValue *>>
                              &ModuleToFunctionsToImportMap,
                          const FunctionInfoIndex &Index,
                          ModuleLazyLoaderCache &ModuleLoaderCache) {
  while (!Worklist.empty()) {
    auto CalledFunctionName = Worklist.pop_back_val();
    DEBUG(dbgs() << DestModule.getModuleIdentifier() << ": Process import for "
                 << CalledFunctionName << "\n");

    // Try to get a summary for this function call.
    auto InfoList = Index.findFunctionInfoList(CalledFunctionName);
    if (InfoList == Index.end()) {
      DEBUG(dbgs() << DestModule.getModuleIdentifier() << ": No summary for "
                   << CalledFunctionName << " Ignoring.\n");
      continue;
    }
    assert(!InfoList->second.empty() && "No summary, error at import?");

    // Comdat can have multiple entries, FIXME: what do we do with them?
    auto &Info = InfoList->second[0];
    assert(Info && "Nullptr in list, error importing summaries?\n");

    auto *Summary = Info->functionSummary();
    if (!Summary) {
      // FIXME: in case we are lazyloading summaries, we can do it now.
      DEBUG(dbgs() << DestModule.getModuleIdentifier()
                   << ": Missing summary for  " << CalledFunctionName
                   << ", error at import?\n");
      llvm_unreachable("Missing summary");
    }

    if (Summary->instCount() > ImportInstrLimit) {
      DEBUG(dbgs() << DestModule.getModuleIdentifier() << ": Skip import of "
                   << CalledFunctionName << " with " << Summary->instCount()
                   << " instructions (limit " << ImportInstrLimit << ")\n");
      continue;
    }

    // Get the module path from the summary.
    auto ModuleIdentifier = Summary->modulePath();
    DEBUG(dbgs() << DestModule.getModuleIdentifier() << ": Importing "
                 << CalledFunctionName << " from " << ModuleIdentifier << "\n");

    auto &SrcModule = ModuleLoaderCache(ModuleIdentifier);

    // The function that we will import!
    GlobalValue *SGV = SrcModule.getNamedValue(CalledFunctionName);

    if (!SGV) {
      // The destination module is referencing function using their renamed name
      // when importing a function that was originally local in the source
      // module. The source module we have might not have been renamed so we try
      // to remove the suffix added during the renaming to recover the original
      // name in the source module.
      std::pair<StringRef, StringRef> Split =
          CalledFunctionName.split(".llvm.");
      SGV = SrcModule.getNamedValue(Split.first);
      assert(SGV && "Can't find function to import in source module");
    }
    if (!SGV) {
      report_fatal_error(Twine("Can't load function '") + CalledFunctionName +
                         "' in Module '" + SrcModule.getModuleIdentifier() +
                         "', error in the summary?\n");
    }

    Function *F = dyn_cast<Function>(SGV);
    if (!F && isa<GlobalAlias>(SGV)) {
      auto *SGA = dyn_cast<GlobalAlias>(SGV);
      F = dyn_cast<Function>(SGA->getBaseObject());
      CalledFunctionName = F->getName();
    }
    assert(F && "Imported Function is ... not a Function");

    // We cannot import weak_any functions/aliases without possibly affecting
    // the order they are seen and selected by the linker, changing program
    // semantics.
    if (SGV->hasWeakAnyLinkage()) {
      DEBUG(dbgs() << DestModule.getModuleIdentifier()
                   << ": Ignoring import request for weak-any "
                   << (isa<Function>(SGV) ? "function " : "alias ")
                   << CalledFunctionName << " from "
                   << SrcModule.getModuleIdentifier() << "\n");
      continue;
    }

    // Add the function to the import list
    auto &Entry = ModuleToFunctionsToImportMap[SrcModule.getModuleIdentifier()];
    Entry.insert(F);

    // Process the newly imported functions and add callees to the worklist.
    F->materialize();
    findExternalCalls(DestModule, *F, Index, CalledFunctions, Worklist);
  }
}

// Automatically import functions in Module \p DestModule based on the summaries
// index.
//
// The current implementation imports every called functions that exists in the
// summaries index.
bool FunctionImporter::importFunctions(Module &DestModule) {
  DEBUG(dbgs() << "Starting import for Module "
               << DestModule.getModuleIdentifier() << "\n");
  unsigned ImportedCount = 0;

  /// First step is collecting the called external functions.
  StringSet<> CalledFunctions;
  SmallVector<StringRef, 64> Worklist;
  for (auto &F : DestModule) {
    if (F.isDeclaration() || F.hasFnAttribute(Attribute::OptimizeNone))
      continue;
    findExternalCalls(DestModule, F, Index, CalledFunctions, Worklist);
  }
  if (Worklist.empty())
    return false;

  /// Second step: for every call to an external function, try to import it.

  // Linker that will be used for importing function
  Linker TheLinker(DestModule);

  // Map of Module -> List of Function to import from the Module
  std::map<StringRef, DenseSet<const GlobalValue *>>
      ModuleToFunctionsToImportMap;

  // Analyze the summaries and get the list of functions to import by
  // populating ModuleToFunctionsToImportMap
  ModuleLazyLoaderCache ModuleLoaderCache(ModuleLoader);
  GetImportList(DestModule, Worklist, CalledFunctions,
                ModuleToFunctionsToImportMap, Index, ModuleLoaderCache);
  assert(Worklist.empty() && "Worklist hasn't been flushed in GetImportList");

  StringMap<std::unique_ptr<DenseMap<unsigned, MDNode *>>>
      ModuleToTempMDValsMap;

  // Do the actual import of functions now, one Module at a time
  for (auto &FunctionsToImportPerModule : ModuleToFunctionsToImportMap) {
    // Get the module for the import
    auto &FunctionsToImport = FunctionsToImportPerModule.second;
    std::unique_ptr<Module> SrcModule =
        ModuleLoaderCache.takeModule(FunctionsToImportPerModule.first);
    assert(&DestModule.getContext() == &SrcModule->getContext() &&
           "Context mismatch");

    // Save the mapping of value ids to temporary metadata created when
    // importing this function. If we have already imported from this module,
    // add new temporary metadata to the existing mapping.
    auto &TempMDVals = ModuleToTempMDValsMap[SrcModule->getModuleIdentifier()];
    if (!TempMDVals)
      TempMDVals = llvm::make_unique<DenseMap<unsigned, MDNode *>>();

    // Link in the specified functions.
    if (TheLinker.linkInModule(std::move(SrcModule), Linker::Flags::None,
                               &Index, &FunctionsToImport, TempMDVals.get()))
      report_fatal_error("Function Import: link error");

    ImportedCount += FunctionsToImport.size();
  }

  // Now link in metadata for all modules from which we imported functions.
  for (StringMapEntry<std::unique_ptr<DenseMap<unsigned, MDNode *>>> &SME :
       ModuleToTempMDValsMap) {
    // Load the specified source module.
    auto &SrcModule = ModuleLoaderCache(SME.getKey());
    // The modules were created with lazy metadata loading. Materialize it
    // now, before linking it.
    SrcModule.materializeMetadata();
    UpgradeDebugInfo(SrcModule);

    // Link in all necessary metadata from this module.
    if (TheLinker.linkInMetadata(SrcModule, SME.getValue().get()))
      return false;
  }

  DEBUG(dbgs() << "Imported " << ImportedCount << " functions for Module "
               << DestModule.getModuleIdentifier() << "\n");
  return ImportedCount;
}

/// Summary file to use for function importing when using -function-import from
/// the command line.
static cl::opt<std::string>
    SummaryFile("summary-file",
                cl::desc("The summary file to use for function importing."));

static void diagnosticHandler(const DiagnosticInfo &DI) {
  raw_ostream &OS = errs();
  DiagnosticPrinterRawOStream DP(OS);
  DI.print(DP);
  OS << '\n';
}

/// Parse the function index out of an IR file and return the function
/// index object if found, or nullptr if not.
static std::unique_ptr<FunctionInfoIndex>
getFunctionIndexForFile(StringRef Path, std::string &Error,
                        DiagnosticHandlerFunction DiagnosticHandler) {
  std::unique_ptr<MemoryBuffer> Buffer;
  ErrorOr<std::unique_ptr<MemoryBuffer>> BufferOrErr =
      MemoryBuffer::getFile(Path);
  if (std::error_code EC = BufferOrErr.getError()) {
    Error = EC.message();
    return nullptr;
  }
  Buffer = std::move(BufferOrErr.get());
  ErrorOr<std::unique_ptr<object::FunctionIndexObjectFile>> ObjOrErr =
      object::FunctionIndexObjectFile::create(Buffer->getMemBufferRef(),
                                              DiagnosticHandler);
  if (std::error_code EC = ObjOrErr.getError()) {
    Error = EC.message();
    return nullptr;
  }
  return (*ObjOrErr)->takeIndex();
}

namespace {
/// Pass that performs cross-module function import provided a summary file.
class FunctionImportPass : public ModulePass {
  /// Optional function summary index to use for importing, otherwise
  /// the summary-file option must be specified.
  const FunctionInfoIndex *Index;

public:
  /// Pass identification, replacement for typeid
  static char ID;

  /// Specify pass name for debug output
  const char *getPassName() const override {
    return "Function Importing";
  }

  explicit FunctionImportPass(const FunctionInfoIndex *Index = nullptr)
      : ModulePass(ID), Index(Index) {}

  bool runOnModule(Module &M) override {
    if (SummaryFile.empty() && !Index)
      report_fatal_error("error: -function-import requires -summary-file or "
                         "file from frontend\n");
    std::unique_ptr<FunctionInfoIndex> IndexPtr;
    if (!SummaryFile.empty()) {
      if (Index)
        report_fatal_error("error: -summary-file and index from frontend\n");
      std::string Error;
      IndexPtr = getFunctionIndexForFile(SummaryFile, Error, diagnosticHandler);
      if (!IndexPtr) {
        errs() << "Error loading file '" << SummaryFile << "': " << Error
               << "\n";
        return false;
      }
      Index = IndexPtr.get();
    }

    // First we need to promote to global scope and rename any local values that
    // are potentially exported to other modules.
    if (renameModuleForThinLTO(M, Index)) {
      errs() << "Error renaming module\n";
      return false;
    }

    // Perform the import now.
    auto ModuleLoader = [&M](StringRef Identifier) {
      return loadFile(Identifier, M.getContext());
    };
    FunctionImporter Importer(*Index, ModuleLoader);
    return Importer.importFunctions(M);
  }
};
} // anonymous namespace

char FunctionImportPass::ID = 0;
INITIALIZE_PASS_BEGIN(FunctionImportPass, "function-import",
                      "Summary Based Function Import", false, false)
INITIALIZE_PASS_END(FunctionImportPass, "function-import",
                    "Summary Based Function Import", false, false)

namespace llvm {
Pass *createFunctionImportPass(const FunctionInfoIndex *Index = nullptr) {
  return new FunctionImportPass(Index);
}
}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@a15 2
#include "llvm/ADT/SmallVector.h"
#include "llvm/ADT/Statistic.h"
a16 1
#include "llvm/ADT/Triple.h"
d23 1
a23 2
#include "llvm/Object/IRObjectFile.h"
#include "llvm/Object/ModuleSummaryIndexObjectFile.h"
a26 2
#include "llvm/Transforms/IPO/Internalize.h"
#include "llvm/Transforms/Utils/FunctionImportUtils.h"
d28 1
a28 1
#define DEBUG_TYPE "function-import"
d32 1
a32 1
STATISTIC(NumImported, "Number of functions imported");
a38 26
static cl::opt<float>
    ImportInstrFactor("import-instr-evolution-factor", cl::init(0.7),
                      cl::Hidden, cl::value_desc("x"),
                      cl::desc("As we import functions, multiply the "
                               "`import-instr-limit` threshold by this factor "
                               "before processing newly imported functions"));

static cl::opt<bool> PrintImports("print-imports", cl::init(false), cl::Hidden,
                                  cl::desc("Print imported functions"));

// Temporary allows the function import pass to disable always linking
// referenced discardable symbols.
static cl::opt<bool>
    DontForceImportReferencedDiscardableSymbols("disable-force-link-odr",
                                                cl::init(false), cl::Hidden);

static cl::opt<bool> EnableImportMetadata(
    "enable-import-metadata", cl::init(
#if !defined(NDEBUG)
                                  true /*Enabled with asserts.*/
#else
                                  false
#endif
                                  ),
    cl::Hidden, cl::desc("Enable import metadata like 'thinlto_src_module'"));

d44 2
a45 2
  // Metadata isn't loaded until functions are imported, to minimize
  // the memory overhead.
d51 1
a51 1
    report_fatal_error("Abort");
d58 5
d64 2
a65 6
// Return true if the Summary describes a GlobalValue that can be externally
// referenced, i.e. it does not need renaming (linkage is not local) or renaming
// is possible (does not have a section for instance).
static bool canBeExternallyReferenced(const GlobalValueSummary &Summary) {
  if (!Summary.needsRenaming())
    return true;
d67 17
a83 3
  if (Summary.hasSection())
    // Can't rename a global that needs renaming if has a section.
    return false;
d85 6
a90 1
  return true;
d92 1
d94 50
a143 79
// Return true if \p GUID describes a GlobalValue that can be externally
// referenced, i.e. it does not need renaming (linkage is not local) or
// renaming is possible (does not have a section for instance).
static bool canBeExternallyReferenced(const ModuleSummaryIndex &Index,
                                      GlobalValue::GUID GUID) {
  auto Summaries = Index.findGlobalValueSummaryList(GUID);
  if (Summaries == Index.end())
    return true;
  if (Summaries->second.size() != 1)
    // If there are multiple globals with this GUID, then we know it is
    // not a local symbol, and it is necessarily externally referenced.
    return true;

  // We don't need to check for the module path, because if it can't be
  // externally referenced and we call it, it is necessarilly in the same
  // module
  return canBeExternallyReferenced(**Summaries->second.begin());
}

// Return true if the global described by \p Summary can be imported in another
// module.
static bool eligibleForImport(const ModuleSummaryIndex &Index,
                              const GlobalValueSummary &Summary) {
  if (!canBeExternallyReferenced(Summary))
    // Can't import a global that needs renaming if has a section for instance.
    // FIXME: we may be able to import it by copying it without promotion.
    return false;

  // Check references (and potential calls) in the same module. If the current
  // value references a global that can't be externally referenced it is not
  // eligible for import.
  bool AllRefsCanBeExternallyReferenced =
      llvm::all_of(Summary.refs(), [&](const ValueInfo &VI) {
        return canBeExternallyReferenced(Index, VI.getGUID());
      });
  if (!AllRefsCanBeExternallyReferenced)
    return false;

  if (auto *FuncSummary = dyn_cast<FunctionSummary>(&Summary)) {
    bool AllCallsCanBeExternallyReferenced = llvm::all_of(
        FuncSummary->calls(), [&](const FunctionSummary::EdgeTy &Edge) {
          return canBeExternallyReferenced(Index, Edge.first.getGUID());
        });
    if (!AllCallsCanBeExternallyReferenced)
      return false;
  }
  return true;
}

/// Given a list of possible callee implementation for a call site, select one
/// that fits the \p Threshold.
///
/// FIXME: select "best" instead of first that fits. But what is "best"?
/// - The smallest: more likely to be inlined.
/// - The one with the least outgoing edges (already well optimized).
/// - One from a module already being imported from in order to reduce the
///   number of source modules parsed/linked.
/// - One that has PGO data attached.
/// - [insert you fancy metric here]
static const GlobalValueSummary *
selectCallee(const ModuleSummaryIndex &Index,
             const GlobalValueSummaryList &CalleeSummaryList,
             unsigned Threshold) {
  auto It = llvm::find_if(
      CalleeSummaryList,
      [&](const std::unique_ptr<GlobalValueSummary> &SummaryPtr) {
        auto *GVSummary = SummaryPtr.get();
        if (GlobalValue::isInterposableLinkage(GVSummary->linkage()))
          // There is no point in importing these, we can't inline them
          return false;
        if (auto *AS = dyn_cast<AliasSummary>(GVSummary)) {
          GVSummary = &AS->getAliasee();
          // Alias can't point to "available_externally". However when we import
          // linkOnceODR the linkage does not change. So we import the alias
          // and aliasee only in this case.
          // FIXME: we should import alias as available_externally *function*,
          // the destination module does need to know it is an alias.
          if (!GlobalValue::isLinkOnceODRLinkage(GVSummary->linkage()))
            return false;
d146 6
a151 71
        auto *Summary = cast<FunctionSummary>(GVSummary);

        if (Summary->instCount() > Threshold)
          return false;

        if (!eligibleForImport(Index, *Summary))
          return false;

        return true;
      });
  if (It == CalleeSummaryList.end())
    return nullptr;

  return cast<GlobalValueSummary>(It->get());
}

/// Return the summary for the function \p GUID that fits the \p Threshold, or
/// null if there's no match.
static const GlobalValueSummary *selectCallee(GlobalValue::GUID GUID,
                                              unsigned Threshold,
                                              const ModuleSummaryIndex &Index) {
  auto CalleeSummaryList = Index.findGlobalValueSummaryList(GUID);
  if (CalleeSummaryList == Index.end())
    return nullptr; // This function does not have a summary
  return selectCallee(Index, CalleeSummaryList->second, Threshold);
}

/// Mark the global \p GUID as export by module \p ExportModulePath if found in
/// this module. If it is a GlobalVariable, we also mark any referenced global
/// in the current module as exported.
static void exportGlobalInModule(const ModuleSummaryIndex &Index,
                                 StringRef ExportModulePath,
                                 GlobalValue::GUID GUID,
                                 FunctionImporter::ExportSetTy &ExportList) {
  auto FindGlobalSummaryInModule =
      [&](GlobalValue::GUID GUID) -> GlobalValueSummary *{
        auto SummaryList = Index.findGlobalValueSummaryList(GUID);
        if (SummaryList == Index.end())
          // This global does not have a summary, it is not part of the ThinLTO
          // process
          return nullptr;
        auto SummaryIter = llvm::find_if(
            SummaryList->second,
            [&](const std::unique_ptr<GlobalValueSummary> &Summary) {
              return Summary->modulePath() == ExportModulePath;
            });
        if (SummaryIter == SummaryList->second.end())
          return nullptr;
        return SummaryIter->get();
      };

  auto *Summary = FindGlobalSummaryInModule(GUID);
  if (!Summary)
    return;
  // We found it in the current module, mark as exported
  ExportList.insert(GUID);

  auto GVS = dyn_cast<GlobalVarSummary>(Summary);
  if (!GVS)
    return;
  // FunctionImportGlobalProcessing::doPromoteLocalToGlobal() will always
  // trigger importing  the initializer for `constant unnamed addr` globals that
  // are referenced. We conservatively export all the referenced symbols for
  // every global to workaround this, so that the ExportList is accurate.
  // FIXME: with a "isConstant" flag in the summary we could be more targetted.
  for (auto &Ref : GVS->refs()) {
    auto GUID = Ref.getGUID();
    auto *RefSummary = FindGlobalSummaryInModule(GUID);
    if (RefSummary)
      // Found a ref in the current module, mark it as exported
      ExportList.insert(GUID);
d155 25
a179 17
using EdgeInfo = std::pair<const FunctionSummary *, unsigned /* Threshold */>;

/// Compute the list of functions to import for a given caller. Mark these
/// imported functions and the symbols they reference in their source module as
/// exported from their source module.
static void computeImportForFunction(
    const FunctionSummary &Summary, const ModuleSummaryIndex &Index,
    unsigned Threshold, const GVSummaryMapTy &DefinedGVSummaries,
    SmallVectorImpl<EdgeInfo> &Worklist,
    FunctionImporter::ImportMapTy &ImportsForModule,
    StringMap<FunctionImporter::ExportSetTy> *ExportLists = nullptr) {
  for (auto &Edge : Summary.calls()) {
    auto GUID = Edge.first.getGUID();
    DEBUG(dbgs() << " edge -> " << GUID << " Threshold:" << Threshold << "\n");

    if (DefinedGVSummaries.count(GUID)) {
      DEBUG(dbgs() << "ignored! Target already in destination module.\n");
d182 1
d184 17
a200 3
    auto *CalleeSummary = selectCallee(GUID, Threshold, Index);
    if (!CalleeSummary) {
      DEBUG(dbgs() << "ignored! No qualifying callee with summary found.\n");
d203 45
a247 22
    // "Resolve" the summary, traversing alias,
    const FunctionSummary *ResolvedCalleeSummary;
    if (isa<AliasSummary>(CalleeSummary)) {
      ResolvedCalleeSummary = cast<FunctionSummary>(
          &cast<AliasSummary>(CalleeSummary)->getAliasee());
      assert(
          GlobalValue::isLinkOnceODRLinkage(ResolvedCalleeSummary->linkage()) &&
          "Unexpected alias to a non-linkonceODR in import list");
    } else
      ResolvedCalleeSummary = cast<FunctionSummary>(CalleeSummary);

    assert(ResolvedCalleeSummary->instCount() <= Threshold &&
           "selectCallee() didn't honor the threshold");

    auto ExportModulePath = ResolvedCalleeSummary->modulePath();
    auto &ProcessedThreshold = ImportsForModule[ExportModulePath][GUID];
    /// Since the traversal of the call graph is DFS, we can revisit a function
    /// a second time with a higher threshold. In this case, it is added back to
    /// the worklist with the new threshold.
    if (ProcessedThreshold && ProcessedThreshold >= Threshold) {
      DEBUG(dbgs() << "ignored! Target was already seen with Threshold "
                   << ProcessedThreshold << "\n");
a249 50
    // Mark this function as imported in this module, with the current Threshold
    ProcessedThreshold = Threshold;

    // Make exports in the source module.
    if (ExportLists) {
      auto &ExportList = (*ExportLists)[ExportModulePath];
      ExportList.insert(GUID);
      // Mark all functions and globals referenced by this function as exported
      // to the outside if they are defined in the same source module.
      for (auto &Edge : ResolvedCalleeSummary->calls()) {
        auto CalleeGUID = Edge.first.getGUID();
        exportGlobalInModule(Index, ExportModulePath, CalleeGUID, ExportList);
      }
      for (auto &Ref : ResolvedCalleeSummary->refs()) {
        auto GUID = Ref.getGUID();
        exportGlobalInModule(Index, ExportModulePath, GUID, ExportList);
      }
    }

    // Insert the newly imported function to the worklist.
    Worklist.push_back(std::make_pair(ResolvedCalleeSummary, Threshold));
  }
}

/// Given the list of globals defined in a module, compute the list of imports
/// as well as the list of "exports", i.e. the list of symbols referenced from
/// another module (that may require promotion).
static void ComputeImportForModule(
    const GVSummaryMapTy &DefinedGVSummaries, const ModuleSummaryIndex &Index,
    FunctionImporter::ImportMapTy &ImportsForModule,
    StringMap<FunctionImporter::ExportSetTy> *ExportLists = nullptr) {
  // Worklist contains the list of function imported in this module, for which
  // we will analyse the callees and may import further down the callgraph.
  SmallVector<EdgeInfo, 128> Worklist;

  // Populate the worklist with the import for the functions in the current
  // module
  for (auto &GVSummary : DefinedGVSummaries) {
    auto *Summary = GVSummary.second;
    if (auto *AS = dyn_cast<AliasSummary>(Summary))
      Summary = &AS->getAliasee();
    auto *FuncSummary = dyn_cast<FunctionSummary>(Summary);
    if (!FuncSummary)
      // Skip import for global variables
      continue;
    DEBUG(dbgs() << "Initalize import for " << GVSummary.first << "\n");
    computeImportForFunction(*FuncSummary, Index, ImportInstrLimit,
                             DefinedGVSummaries, Worklist, ImportsForModule,
                             ExportLists);
  }
d251 3
a253 4
  while (!Worklist.empty()) {
    auto FuncInfo = Worklist.pop_back_val();
    auto *Summary = FuncInfo.first;
    auto Threshold = FuncInfo.second;
d256 2
a257 39
    // Adjust the threshold
    Threshold = Threshold * ImportInstrFactor;

    computeImportForFunction(*Summary, Index, Threshold, DefinedGVSummaries,
                             Worklist, ImportsForModule, ExportLists);
  }
}

} // anonymous namespace

/// Compute all the import and export for every module using the Index.
void llvm::ComputeCrossModuleImport(
    const ModuleSummaryIndex &Index,
    const StringMap<GVSummaryMapTy> &ModuleToDefinedGVSummaries,
    StringMap<FunctionImporter::ImportMapTy> &ImportLists,
    StringMap<FunctionImporter::ExportSetTy> &ExportLists) {
  // For each module that has function defined, compute the import/export lists.
  for (auto &DefinedGVSummaries : ModuleToDefinedGVSummaries) {
    auto &ImportsForModule = ImportLists[DefinedGVSummaries.first()];
    DEBUG(dbgs() << "Computing import for Module '"
                 << DefinedGVSummaries.first() << "'\n");
    ComputeImportForModule(DefinedGVSummaries.second, Index, ImportsForModule,
                           &ExportLists);
  }

#ifndef NDEBUG
  DEBUG(dbgs() << "Import/Export lists for " << ImportLists.size()
               << " modules:\n");
  for (auto &ModuleImports : ImportLists) {
    auto ModName = ModuleImports.first();
    auto &Exports = ExportLists[ModName];
    DEBUG(dbgs() << "* Module " << ModName << " exports " << Exports.size()
                 << " functions. Imports from " << ModuleImports.second.size()
                 << " modules.\n");
    for (auto &Src : ModuleImports.second) {
      auto SrcModName = Src.first();
      DEBUG(dbgs() << " - " << Src.second.size() << " functions imported from "
                   << SrcModName << "\n");
    }
a258 153
#endif
}

/// Compute all the imports for the given module in the Index.
void llvm::ComputeCrossModuleImportForModule(
    StringRef ModulePath, const ModuleSummaryIndex &Index,
    FunctionImporter::ImportMapTy &ImportList) {

  // Collect the list of functions this module defines.
  // GUID -> Summary
  GVSummaryMapTy FunctionSummaryMap;
  Index.collectDefinedFunctionsForModule(ModulePath, FunctionSummaryMap);

  // Compute the import list for this module.
  DEBUG(dbgs() << "Computing import for Module '" << ModulePath << "'\n");
  ComputeImportForModule(FunctionSummaryMap, Index, ImportList);

#ifndef NDEBUG
  DEBUG(dbgs() << "* Module " << ModulePath << " imports from "
               << ImportList.size() << " modules.\n");
  for (auto &Src : ImportList) {
    auto SrcModName = Src.first();
    DEBUG(dbgs() << " - " << Src.second.size() << " functions imported from "
                 << SrcModName << "\n");
  }
#endif
}

/// Compute the set of summaries needed for a ThinLTO backend compilation of
/// \p ModulePath.
void llvm::gatherImportedSummariesForModule(
    StringRef ModulePath,
    const StringMap<GVSummaryMapTy> &ModuleToDefinedGVSummaries,
    const StringMap<FunctionImporter::ImportMapTy> &ImportLists,
    std::map<std::string, GVSummaryMapTy> &ModuleToSummariesForIndex) {
  // Include all summaries from the importing module.
  ModuleToSummariesForIndex[ModulePath] =
      ModuleToDefinedGVSummaries.lookup(ModulePath);
  auto ModuleImports = ImportLists.find(ModulePath);
  if (ModuleImports != ImportLists.end()) {
    // Include summaries for imports.
    for (auto &ILI : ModuleImports->second) {
      auto &SummariesForIndex = ModuleToSummariesForIndex[ILI.first()];
      const auto &DefinedGVSummaries =
          ModuleToDefinedGVSummaries.lookup(ILI.first());
      for (auto &GI : ILI.second) {
        const auto &DS = DefinedGVSummaries.find(GI.first);
        assert(DS != DefinedGVSummaries.end() &&
               "Expected a defined summary for imported global value");
        SummariesForIndex[GI.first] = DS->second;
      }
    }
  }
}

/// Emit the files \p ModulePath will import from into \p OutputFilename.
std::error_code llvm::EmitImportsFiles(
    StringRef ModulePath, StringRef OutputFilename,
    const StringMap<FunctionImporter::ImportMapTy> &ImportLists) {
  auto ModuleImports = ImportLists.find(ModulePath);
  std::error_code EC;
  raw_fd_ostream ImportsOS(OutputFilename, EC, sys::fs::OpenFlags::F_None);
  if (EC)
    return EC;
  if (ModuleImports != ImportLists.end())
    for (auto &ILI : ModuleImports->second)
      ImportsOS << ILI.first() << "\n";
  return std::error_code();
}

/// Fixup WeakForLinker linkages in \p TheModule based on summary analysis.
void llvm::thinLTOResolveWeakForLinkerModule(
    Module &TheModule, const GVSummaryMapTy &DefinedGlobals) {
  auto updateLinkage = [&](GlobalValue &GV) {
    if (!GlobalValue::isWeakForLinker(GV.getLinkage()))
      return;
    // See if the global summary analysis computed a new resolved linkage.
    const auto &GS = DefinedGlobals.find(GV.getGUID());
    if (GS == DefinedGlobals.end())
      return;
    auto NewLinkage = GS->second->linkage();
    if (NewLinkage == GV.getLinkage())
      return;
    DEBUG(dbgs() << "ODR fixing up linkage for `" << GV.getName() << "` from "
                 << GV.getLinkage() << " to " << NewLinkage << "\n");
    GV.setLinkage(NewLinkage);
  };

  // Process functions and global now
  for (auto &GV : TheModule)
    updateLinkage(GV);
  for (auto &GV : TheModule.globals())
    updateLinkage(GV);
  for (auto &GV : TheModule.aliases())
    updateLinkage(GV);
}

/// Run internalization on \p TheModule based on symmary analysis.
void llvm::thinLTOInternalizeModule(Module &TheModule,
                                    const GVSummaryMapTy &DefinedGlobals) {
  // Parse inline ASM and collect the list of symbols that are not defined in
  // the current module.
  StringSet<> AsmUndefinedRefs;
  object::IRObjectFile::CollectAsmUndefinedRefs(
      Triple(TheModule.getTargetTriple()), TheModule.getModuleInlineAsm(),
      [&AsmUndefinedRefs](StringRef Name, object::BasicSymbolRef::Flags Flags) {
        if (Flags & object::BasicSymbolRef::SF_Undefined)
          AsmUndefinedRefs.insert(Name);
      });

  // Declare a callback for the internalize pass that will ask for every
  // candidate GlobalValue if it can be internalized or not.
  auto MustPreserveGV = [&](const GlobalValue &GV) -> bool {
    // Can't be internalized if referenced in inline asm.
    if (AsmUndefinedRefs.count(GV.getName()))
      return true;

    // Lookup the linkage recorded in the summaries during global analysis.
    const auto &GS = DefinedGlobals.find(GV.getGUID());
    GlobalValue::LinkageTypes Linkage;
    if (GS == DefinedGlobals.end()) {
      // Must have been promoted (possibly conservatively). Find original
      // name so that we can access the correct summary and see if it can
      // be internalized again.
      // FIXME: Eventually we should control promotion instead of promoting
      // and internalizing again.
      StringRef OrigName =
          ModuleSummaryIndex::getOriginalNameBeforePromote(GV.getName());
      std::string OrigId = GlobalValue::getGlobalIdentifier(
          OrigName, GlobalValue::InternalLinkage,
          TheModule.getSourceFileName());
      const auto &GS = DefinedGlobals.find(GlobalValue::getGUID(OrigId));
      if (GS == DefinedGlobals.end()) {
        // Also check the original non-promoted non-globalized name. In some
        // cases a preempted weak value is linked in as a local copy because
        // it is referenced by an alias (IRLinker::linkGlobalValueProto).
        // In that case, since it was originally not a local value, it was
        // recorded in the index using the original name.
        // FIXME: This may not be needed once PR27866 is fixed.
        const auto &GS = DefinedGlobals.find(GlobalValue::getGUID(OrigName));
        assert(GS != DefinedGlobals.end());
        Linkage = GS->second->linkage();
      } else {
        Linkage = GS->second->linkage();
      }
    } else
      Linkage = GS->second->linkage();
    return !GlobalValue::isLocalLinkage(Linkage);
  };

  // FIXME: See if we can just internalize directly here via linkage changes
  // based on the index, rather than invoking internalizeModule.
  llvm::internalizeModule(TheModule, MustPreserveGV);
d264 3
a266 3
bool FunctionImporter::importFunctions(
    Module &DestModule, const FunctionImporter::ImportMapTy &ImportList,
    bool ForceImportReferencedDiscardableSymbols) {
d271 13
d286 15
d302 1
a302 5
  std::set<StringRef> ModuleNameOrderedList;
  for (auto &FunctionsToImportPerModule : ImportList) {
    ModuleNameOrderedList.insert(FunctionsToImportPerModule.first());
  }
  for (auto &Name : ModuleNameOrderedList) {
d304 3
a306 3
    const auto &FunctionsToImportPerModule = ImportList.find(Name);
    assert(FunctionsToImportPerModule != ImportList.end());
    std::unique_ptr<Module> SrcModule = ModuleLoader(Name);
d310 6
a315 71
    // If modules were created with lazy metadata loading, materialize it
    // now, before linking it (otherwise this will be a noop).
    SrcModule->materializeMetadata();
    UpgradeDebugInfo(*SrcModule);

    auto &ImportGUIDs = FunctionsToImportPerModule->second;
    // Find the globals to import
    DenseSet<const GlobalValue *> GlobalsToImport;
    for (Function &F : *SrcModule) {
      if (!F.hasName())
        continue;
      auto GUID = F.getGUID();
      auto Import = ImportGUIDs.count(GUID);
      DEBUG(dbgs() << (Import ? "Is" : "Not") << " importing function " << GUID
                   << " " << F.getName() << " from "
                   << SrcModule->getSourceFileName() << "\n");
      if (Import) {
        F.materialize();
        if (EnableImportMetadata) {
          // Add 'thinlto_src_module' metadata for statistics and debugging.
          F.setMetadata(
              "thinlto_src_module",
              llvm::MDNode::get(
                  DestModule.getContext(),
                  {llvm::MDString::get(DestModule.getContext(),
                                       SrcModule->getSourceFileName())}));
        }
        GlobalsToImport.insert(&F);
      }
    }
    for (GlobalVariable &GV : SrcModule->globals()) {
      if (!GV.hasName())
        continue;
      auto GUID = GV.getGUID();
      auto Import = ImportGUIDs.count(GUID);
      DEBUG(dbgs() << (Import ? "Is" : "Not") << " importing global " << GUID
                   << " " << GV.getName() << " from "
                   << SrcModule->getSourceFileName() << "\n");
      if (Import) {
        GV.materialize();
        GlobalsToImport.insert(&GV);
      }
    }
    for (GlobalAlias &GA : SrcModule->aliases()) {
      if (!GA.hasName())
        continue;
      auto GUID = GA.getGUID();
      auto Import = ImportGUIDs.count(GUID);
      DEBUG(dbgs() << (Import ? "Is" : "Not") << " importing alias " << GUID
                   << " " << GA.getName() << " from "
                   << SrcModule->getSourceFileName() << "\n");
      if (Import) {
        // Alias can't point to "available_externally". However when we import
        // linkOnceODR the linkage does not change. So we import the alias
        // and aliasee only in this case. This has been handled by
        // computeImportForFunction()
        GlobalObject *GO = GA.getBaseObject();
        assert(GO->hasLinkOnceODRLinkage() &&
               "Unexpected alias to a non-linkonceODR in import list");
#ifndef NDEBUG
        if (!GlobalsToImport.count(GO))
          DEBUG(dbgs() << " alias triggers importing aliasee " << GO->getGUID()
                       << " " << GO->getName() << " from "
                       << SrcModule->getSourceFileName() << "\n");
#endif
        GO->materialize();
        GlobalsToImport.insert(GO);
        GA.materialize();
        GlobalsToImport.insert(&GA);
      }
    }
d318 3
a320 2
    if (renameModuleForThinLTO(*SrcModule, Index, &GlobalsToImport))
      return true;
d322 2
a323 5
    if (PrintImports) {
      for (const auto *GV : GlobalsToImport)
        dbgs() << DestModule.getSourceFileName() << ": Import " << GV->getName()
               << " from " << SrcModule->getSourceFileName() << "\n";
    }
d325 9
a333 4
    // Instruct the linker that the client will take care of linkonce resolution
    unsigned Flags = Linker::Flags::None;
    if (!ForceImportReferencedDiscardableSymbols)
      Flags |= Linker::Flags::DontForceLinkLinkonceODR;
d335 3
a337 4
    if (TheLinker.linkInModule(std::move(SrcModule), Flags, &GlobalsToImport))
      report_fatal_error("Function Import: link error");

    ImportedCount += GlobalsToImport.size();
a339 2
  NumImported += ImportedCount;

d358 1
a358 1
/// Parse the summary index out of an IR file and return the summary
d360 3
a362 3
static std::unique_ptr<ModuleSummaryIndex> getModuleSummaryIndexForFile(
    StringRef Path, std::string &Error,
    const DiagnosticHandlerFunction &DiagnosticHandler) {
d371 3
a373 3
  ErrorOr<std::unique_ptr<object::ModuleSummaryIndexObjectFile>> ObjOrErr =
      object::ModuleSummaryIndexObjectFile::create(Buffer->getMemBufferRef(),
                                                   DiagnosticHandler);
d384 1
a384 1
  /// Optional module summary index to use for importing, otherwise
d386 1
a386 1
  const ModuleSummaryIndex *Index;
d393 3
a395 1
  const char *getPassName() const override { return "Function Importing"; }
d397 1
a397 1
  explicit FunctionImportPass(const ModuleSummaryIndex *Index = nullptr)
a400 3
    if (skipModule(M))
      return false;

d404 1
a404 1
    std::unique_ptr<ModuleSummaryIndex> IndexPtr;
d409 1
a409 2
      IndexPtr =
          getModuleSummaryIndexForFile(SummaryFile, Error, diagnosticHandler);
d418 1
a418 6
    // First step is collecting the import list.
    FunctionImporter::ImportMapTy ImportList;
    ComputeCrossModuleImportForModule(M.getModuleIdentifier(), *Index,
                                      ImportList);

    // Next we need to promote to global scope and rename any local values that
d420 1
a420 1
    if (renameModuleForThinLTO(M, *Index, nullptr)) {
d430 1
a430 2
    return Importer.importFunctions(
        M, ImportList, !DontForceImportReferencedDiscardableSymbols);
d442 1
a442 1
Pass *createFunctionImportPass(const ModuleSummaryIndex *Index = nullptr) {
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a23 1
#include "llvm/IR/Verifier.h"
d38 1
a38 4
STATISTIC(NumImportedFunctions, "Number of functions imported");
STATISTIC(NumImportedModules, "Number of modules imported from");
STATISTIC(NumDeadSymbols, "Number of dead stripped symbols in index");
STATISTIC(NumLiveSymbols, "Number of live symbols in index");
a51 16
static cl::opt<float> ImportHotInstrFactor(
    "import-hot-evolution-factor", cl::init(1.0), cl::Hidden,
    cl::value_desc("x"),
    cl::desc("As we import functions called from hot callsite, multiply the "
             "`import-instr-limit` threshold by this factor "
             "before processing newly imported functions"));

static cl::opt<float> ImportHotMultiplier(
    "import-hot-multiplier", cl::init(3.0), cl::Hidden, cl::value_desc("x"),
    cl::desc("Multiply the `import-instr-limit` threshold for hot callsites"));

// FIXME: This multiplier was not really tuned up.
static cl::opt<float> ImportColdMultiplier(
    "import-cold-multiplier", cl::init(0), cl::Hidden, cl::value_desc("N"),
    cl::desc("Multiply the `import-instr-limit` threshold for cold callsites"));

a54 3
static cl::opt<bool> ComputeDead("compute-dead", cl::init(true), cl::Hidden,
                                 cl::desc("Compute dead symbols"));

d91 63
d191 1
a191 1
        if (Summary->notEligibleToImport())
d213 48
a260 2
using EdgeInfo = std::tuple<const FunctionSummary *, unsigned /* Threshold */,
                            GlobalValue::GUID>;
d267 1
a267 1
    const unsigned Threshold, const GVSummaryMapTy &DefinedGVSummaries,
d269 1
a269 1
    FunctionImporter::ImportMapTy &ImportList,
d280 1
a280 12
    auto GetBonusMultiplier = [](CalleeInfo::HotnessType Hotness) -> float {
      if (Hotness == CalleeInfo::HotnessType::Hot)
        return ImportHotMultiplier;
      if (Hotness == CalleeInfo::HotnessType::Cold)
        return ImportColdMultiplier;
      return 1.0;
    };

    const auto NewThreshold =
        Threshold * GetBonusMultiplier(Edge.second.Hotness);

    auto *CalleeSummary = selectCallee(GUID, NewThreshold, Index);
d296 1
a296 1
    assert(ResolvedCalleeSummary->instCount() <= NewThreshold &&
a298 12
    auto GetAdjustedThreshold = [](unsigned Threshold, bool IsHotCallsite) {
      // Adjust the threshold for next level of imported functions.
      // The threshold is different for hot callsites because we can then
      // inline chains of hot calls.
      if (IsHotCallsite)
        return Threshold * ImportHotInstrFactor;
      return Threshold * ImportInstrFactor;
    };

    bool IsHotCallsite = Edge.second.Hotness == CalleeInfo::HotnessType::Hot;
    const auto AdjThreshold = GetAdjustedThreshold(Threshold, IsHotCallsite);

d300 1
a300 1
    auto &ProcessedThreshold = ImportList[ExportModulePath][GUID];
d304 1
a304 1
    if (ProcessedThreshold && ProcessedThreshold >= AdjThreshold) {
a308 1
    bool PreviouslyImported = ProcessedThreshold != 0;
d310 1
a310 1
    ProcessedThreshold = AdjThreshold;
d316 9
a324 15
      if (!PreviouslyImported) {
        // This is the first time this function was exported from its source
        // module, so mark all functions and globals it references as exported
        // to the outside if they are defined in the same source module.
        // For efficiency, we unconditionally add all the referenced GUIDs
        // to the ExportList for this module, and will prune out any not
        // defined in the module later in a single pass.
        for (auto &Edge : ResolvedCalleeSummary->calls()) {
          auto CalleeGUID = Edge.first.getGUID();
          ExportList.insert(CalleeGUID);
        }
        for (auto &Ref : ResolvedCalleeSummary->refs()) {
          auto GUID = Ref.getGUID();
          ExportList.insert(GUID);
        }
d329 1
a329 1
    Worklist.emplace_back(ResolvedCalleeSummary, AdjThreshold, GUID);
d338 2
a339 3
    FunctionImporter::ImportMapTy &ImportList,
    StringMap<FunctionImporter::ExportSetTy> *ExportLists = nullptr,
    const DenseSet<GlobalValue::GUID> *DeadSymbols = nullptr) {
a346 4
    if (DeadSymbols && DeadSymbols->count(GVSummary.first)) {
      DEBUG(dbgs() << "Ignores Dead GUID: " << GVSummary.first << "\n");
      continue;
    }
d356 1
a356 1
                             DefinedGVSummaries, Worklist, ImportList,
a359 1
  // Process the newly imported functions and add callees to the worklist.
d362 6
a367 10
    auto *Summary = std::get<0>(FuncInfo);
    auto Threshold = std::get<1>(FuncInfo);
    auto GUID = std::get<2>(FuncInfo);

    // Check if we later added this summary with a higher threshold.
    // If so, skip this entry.
    auto ExportModulePath = Summary->modulePath();
    auto &LatestProcessedThreshold = ImportList[ExportModulePath][GUID];
    if (LatestProcessedThreshold > Threshold)
      continue;
d370 1
a370 1
                             Worklist, ImportList, ExportLists);
d381 1
a381 2
    StringMap<FunctionImporter::ExportSetTy> &ExportLists,
    const DenseSet<GlobalValue::GUID> *DeadSymbols) {
d384 1
a384 1
    auto &ImportList = ImportLists[DefinedGVSummaries.first()];
d387 2
a388 18
    ComputeImportForModule(DefinedGVSummaries.second, Index, ImportList,
                           &ExportLists, DeadSymbols);
  }

  // When computing imports we added all GUIDs referenced by anything
  // imported from the module to its ExportList. Now we prune each ExportList
  // of any not defined in that module. This is more efficient than checking
  // while computing imports because some of the summary lists may be long
  // due to linkonce (comdat) copies.
  for (auto &ELI : ExportLists) {
    const auto &DefinedGVSummaries =
        ModuleToDefinedGVSummaries.lookup(ELI.first());
    for (auto EI = ELI.second.begin(); EI != ELI.second.end();) {
      if (!DefinedGVSummaries.count(*EI))
        EI = ELI.second.erase(EI);
      else
        ++EI;
    }
a433 80
DenseSet<GlobalValue::GUID> llvm::computeDeadSymbols(
    const ModuleSummaryIndex &Index,
    const DenseSet<GlobalValue::GUID> &GUIDPreservedSymbols) {
  if (!ComputeDead)
    return DenseSet<GlobalValue::GUID>();
  if (GUIDPreservedSymbols.empty())
    // Don't do anything when nothing is live, this is friendly with tests.
    return DenseSet<GlobalValue::GUID>();
  DenseSet<GlobalValue::GUID> LiveSymbols = GUIDPreservedSymbols;
  SmallVector<GlobalValue::GUID, 128> Worklist;
  Worklist.reserve(LiveSymbols.size() * 2);
  for (auto GUID : LiveSymbols) {
    DEBUG(dbgs() << "Live root: " << GUID << "\n");
    Worklist.push_back(GUID);
  }
  // Add values flagged in the index as live roots to the worklist.
  for (const auto &Entry : Index) {
    bool IsLiveRoot = llvm::any_of(
        Entry.second,
        [&](const std::unique_ptr<llvm::GlobalValueSummary> &Summary) {
          return Summary->liveRoot();
        });
    if (!IsLiveRoot)
      continue;
    DEBUG(dbgs() << "Live root (summary): " << Entry.first << "\n");
    Worklist.push_back(Entry.first);
  }

  while (!Worklist.empty()) {
    auto GUID = Worklist.pop_back_val();
    auto It = Index.findGlobalValueSummaryList(GUID);
    if (It == Index.end()) {
      DEBUG(dbgs() << "Not in index: " << GUID << "\n");
      continue;
    }

    // FIXME: we should only make the prevailing copy live here
    for (auto &Summary : It->second) {
      for (auto Ref : Summary->refs()) {
        auto RefGUID = Ref.getGUID();
        if (LiveSymbols.insert(RefGUID).second) {
          DEBUG(dbgs() << "Marking live (ref): " << RefGUID << "\n");
          Worklist.push_back(RefGUID);
        }
      }
      if (auto *FS = dyn_cast<FunctionSummary>(Summary.get())) {
        for (auto Call : FS->calls()) {
          auto CallGUID = Call.first.getGUID();
          if (LiveSymbols.insert(CallGUID).second) {
            DEBUG(dbgs() << "Marking live (call): " << CallGUID << "\n");
            Worklist.push_back(CallGUID);
          }
        }
      }
      if (auto *AS = dyn_cast<AliasSummary>(Summary.get())) {
        auto AliaseeGUID = AS->getAliasee().getOriginalName();
        if (LiveSymbols.insert(AliaseeGUID).second) {
          DEBUG(dbgs() << "Marking live (alias): " << AliaseeGUID << "\n");
          Worklist.push_back(AliaseeGUID);
        }
      }
    }
  }
  DenseSet<GlobalValue::GUID> DeadSymbols;
  DeadSymbols.reserve(
      std::min(Index.size(), Index.size() - LiveSymbols.size()));
  for (auto &Entry : Index) {
    auto GUID = Entry.first;
    if (!LiveSymbols.count(GUID)) {
      DEBUG(dbgs() << "Marking dead: " << GUID << "\n");
      DeadSymbols.insert(GUID);
    }
  }
  DEBUG(dbgs() << LiveSymbols.size() << " symbols Live, and "
               << DeadSymbols.size() << " symbols Dead \n");
  NumDeadSymbols += DeadSymbols.size();
  NumLiveSymbols += LiveSymbols.size();
  return DeadSymbols;
}

d439 1
a439 1
    const FunctionImporter::ImportMapTy &ImportList,
d444 13
a456 10
  // Include summaries for imports.
  for (auto &ILI : ImportList) {
    auto &SummariesForIndex = ModuleToSummariesForIndex[ILI.first()];
    const auto &DefinedGVSummaries =
        ModuleToDefinedGVSummaries.lookup(ILI.first());
    for (auto &GI : ILI.second) {
      const auto &DS = DefinedGVSummaries.find(GI.first);
      assert(DS != DefinedGVSummaries.end() &&
             "Expected a defined summary for imported global value");
      SummariesForIndex[GI.first] = DS->second;
d462 4
a465 3
std::error_code
llvm::EmitImportsFiles(StringRef ModulePath, StringRef OutputFilename,
                       const FunctionImporter::ImportMapTy &ModuleImports) {
d470 3
a472 2
  for (auto &ILI : ModuleImports)
    ImportsOS << ILI.first() << "\n";
a491 9
    // Remove functions converted to available_externally from comdats,
    // as this is a declaration for the linker, and will be dropped eventually.
    // It is illegal for comdats to contain declarations.
    auto *GO = dyn_cast_or_null<GlobalObject>(&GV);
    if (GO && GO->isDeclarationForLinker() && GO->hasComdat()) {
      assert(GO->hasAvailableExternallyLinkage() &&
             "Expected comdat on definition (possibly available external)");
      GO->setComdat(nullptr);
    }
d509 1
a509 1
  ModuleSymbolTable::CollectAsmSymbols(
d564 1
a564 1
Expected<bool> FunctionImporter::importFunctions(
d582 1
a582 4
    Expected<std::unique_ptr<Module>> SrcModuleOrErr = ModuleLoader(Name);
    if (!SrcModuleOrErr)
      return SrcModuleOrErr.takeError();
    std::unique_ptr<Module> SrcModule = std::move(*SrcModuleOrErr);
d588 2
a589 2
    if (Error Err = SrcModule->materializeMetadata())
      return std::move(Err);
d603 1
a603 2
        if (Error Err = F.materialize())
          return std::move(Err);
d625 1
a625 2
        if (Error Err = GV.materialize())
          return std::move(Err);
d651 1
a651 2
        if (Error Err = GO->materialize())
          return std::move(Err);
d653 1
a653 2
        if (Error Err = GA.materialize())
          return std::move(Err);
a657 4
    // Upgrade debug info after we're done materializing all the globals and we
    // have loaded all the required metadata!
    UpgradeDebugInfo(*SrcModule);

a676 1
    NumImportedModules++;
d679 1
a679 1
  NumImportedFunctions += ImportedCount;
d692 18
a709 9
static bool doImportingForModule(Module &M) {
  if (SummaryFile.empty())
    report_fatal_error("error: -function-import requires -summary-file\n");
  Expected<std::unique_ptr<ModuleSummaryIndex>> IndexPtrOrErr =
      getModuleSummaryIndexForFile(SummaryFile);
  if (!IndexPtrOrErr) {
    logAllUnhandledErrors(IndexPtrOrErr.takeError(), errs(),
                          "Error loading file '" + SummaryFile + "': ");
    return false;
d711 7
a717 38
  std::unique_ptr<ModuleSummaryIndex> Index = std::move(*IndexPtrOrErr);

  // First step is collecting the import list.
  FunctionImporter::ImportMapTy ImportList;
  ComputeCrossModuleImportForModule(M.getModuleIdentifier(), *Index,
                                    ImportList);

  // Conservatively mark all internal values as promoted. This interface is
  // only used when doing importing via the function importing pass. The pass
  // is only enabled when testing importing via the 'opt' tool, which does
  // not do the ThinLink that would normally determine what values to promote.
  for (auto &I : *Index) {
    for (auto &S : I.second) {
      if (GlobalValue::isLocalLinkage(S->linkage()))
        S->setLinkage(GlobalValue::ExternalLinkage);
    }
  }

  // Next we need to promote to global scope and rename any local values that
  // are potentially exported to other modules.
  if (renameModuleForThinLTO(M, *Index, nullptr)) {
    errs() << "Error renaming module\n";
    return false;
  }

  // Perform the import now.
  auto ModuleLoader = [&M](StringRef Identifier) {
    return loadFile(Identifier, M.getContext());
  };
  FunctionImporter Importer(*Index, ModuleLoader);
  Expected<bool> Result = Importer.importFunctions(
      M, ImportList, !DontForceImportReferencedDiscardableSymbols);

  // FIXME: Probably need to propagate Errors through the pass manager.
  if (!Result) {
    logAllUnhandledErrors(Result.takeError(), errs(),
                          "Error importing module: ");
    return false;
d719 1
a719 2

  return *Result;
d724 5
a728 1
class FunctionImportLegacyPass : public ModulePass {
d734 1
a734 1
  StringRef getPassName() const override { return "Function Importing"; }
d736 2
a737 1
  explicit FunctionImportLegacyPass() : ModulePass(ID) {}
d743 37
a779 1
    return doImportingForModule(M);
d784 5
a788 11
PreservedAnalyses FunctionImportPass::run(Module &M,
                                          ModuleAnalysisManager &AM) {
  if (!doImportingForModule(M))
    return PreservedAnalyses::all();

  return PreservedAnalyses::none();
}

char FunctionImportLegacyPass::ID = 0;
INITIALIZE_PASS(FunctionImportLegacyPass, "function-import",
                "Summary Based Function Import", false, false)
d791 2
a792 2
Pass *createFunctionImportPass() {
  return new FunctionImportLegacyPass();
@


