head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.2
	OPENBSD_6_2:1.1.1.1.0.2
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.4
	OPENBSD_6_1_BASE:1.1.1.1
	LLVM_4_0_0:1.1.1.1
	LLVM_4_0_0_RC1:1.1.1.1
	LLVM_3_9_1:1.1.1.1
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.10.04.20.27.59;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===- MetaRenamer.cpp - Rename everything with metasyntatic names --------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This pass renames everything with metasyntatic names. The intent is to use
// this pass after bugpoint reduction to conceal the nature of the original
// program.
//
//===----------------------------------------------------------------------===//

#include "llvm/Transforms/IPO.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/ADT/SmallString.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Type.h"
#include "llvm/IR/TypeFinder.h"
#include "llvm/Pass.h"
using namespace llvm;

namespace {

  // This PRNG is from the ISO C spec. It is intentionally simple and
  // unsuitable for cryptographic use. We're just looking for enough
  // variety to surprise and delight users.
  struct PRNG {
    unsigned long next;

    void srand(unsigned int seed) {
      next = seed;
    }

    int rand() {
      next = next * 1103515245 + 12345;
      return (unsigned int)(next / 65536) % 32768;
    }
  };

  static const char *const metaNames[] = {
    // See http://en.wikipedia.org/wiki/Metasyntactic_variable
    "foo", "bar", "baz", "quux", "barney", "snork", "zot", "blam", "hoge",
    "wibble", "wobble", "widget", "wombat", "ham", "eggs", "pluto", "spam"
  };

  struct Renamer {
    Renamer(unsigned int seed) {
      prng.srand(seed);
    }

    const char *newName() {
      return metaNames[prng.rand() % array_lengthof(metaNames)];
    }

    PRNG prng;
  };
  
  struct MetaRenamer : public ModulePass {
    static char ID; // Pass identification, replacement for typeid
    MetaRenamer() : ModulePass(ID) {
      initializeMetaRenamerPass(*PassRegistry::getPassRegistry());
    }

    void getAnalysisUsage(AnalysisUsage &AU) const override {
      AU.setPreservesAll();
    }

    bool runOnModule(Module &M) override {
      // Seed our PRNG with simple additive sum of ModuleID. We're looking to
      // simply avoid always having the same function names, and we need to
      // remain deterministic.
      unsigned int randSeed = 0;
      for (auto C : M.getModuleIdentifier())
        randSeed += C;

      Renamer renamer(randSeed);

      // Rename all aliases
      for (auto AI = M.alias_begin(), AE = M.alias_end(); AI != AE; ++AI) {
        StringRef Name = AI->getName();
        if (Name.startswith("llvm.") || (!Name.empty() && Name[0] == 1))
          continue;

        AI->setName("alias");
      }

      // Rename all global variables
      for (auto GI = M.global_begin(), GE = M.global_end(); GI != GE; ++GI) {
        StringRef Name = GI->getName();
        if (Name.startswith("llvm.") || (!Name.empty() && Name[0] == 1))
          continue;

        GI->setName("global");
      }

      // Rename all struct types
      TypeFinder StructTypes;
      StructTypes.run(M, true);
      for (StructType *STy : StructTypes) {
        if (STy->isLiteral() || STy->getName().empty()) continue;

        SmallString<128> NameStorage;
        STy->setName((Twine("struct.") +
          renamer.newName()).toStringRef(NameStorage));
      }

      // Rename all functions
      for (auto &F : M) {
        StringRef Name = F.getName();
        if (Name.startswith("llvm.") || (!Name.empty() && Name[0] == 1))
          continue;

        F.setName(renamer.newName());
        runOnFunction(F);
      }
      return true;
    }

    bool runOnFunction(Function &F) {
      for (auto AI = F.arg_begin(), AE = F.arg_end(); AI != AE; ++AI)
        if (!AI->getType()->isVoidTy())
          AI->setName("arg");

      for (auto &BB : F) {
        BB.setName("bb");

        for (auto &I : BB)
          if (!I.getType()->isVoidTy())
            I.setName("tmp");
      }
      return true;
    }
  };
}

char MetaRenamer::ID = 0;
INITIALIZE_PASS(MetaRenamer, "metarenamer", 
                "Assign new names to everything", false, false)
//===----------------------------------------------------------------------===//
//
// MetaRenamer - Rename everything with metasyntactic names.
//
ModulePass *llvm::createMetaRenamerPass() {
  return new MetaRenamer();
}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@d16 1
a18 1
#include "llvm/Analysis/TargetLibraryInfo.h"
a24 1
#include "llvm/Transforms/IPO.h"
a69 1
      AU.addRequired<TargetLibraryInfoWrapperPass>();
a112 2
      const TargetLibraryInfo &TLI =
          getAnalysis<TargetLibraryInfoWrapperPass>().getTLI();
d115 1
a115 5
        LibFunc Tmp;
        // Leave library functions alone because their presence or absence could
        // affect the behavior of other passes.
        if (Name.startswith("llvm.") || (!Name.empty() && Name[0] == 1) ||
            TLI.getLibFunc(F, Tmp))
d142 2
a143 5
INITIALIZE_PASS_BEGIN(MetaRenamer, "metarenamer",
                      "Assign new names to everything", false, false)
INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)
INITIALIZE_PASS_END(MetaRenamer, "metarenamer",
                    "Assign new names to everything", false, false)
@

