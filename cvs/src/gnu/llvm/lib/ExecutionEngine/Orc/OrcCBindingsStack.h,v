head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.47.02;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.02;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.09;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.34;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===--- OrcCBindingsStack.h - Orc JIT stack for C bindings ---*- C++ -*---===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_LIB_EXECUTIONENGINE_ORC_ORCCBINDINGSSTACK_H
#define LLVM_LIB_EXECUTIONENGINE_ORC_ORCCBINDINGSSTACK_H

#include "llvm/ADT/Triple.h"
#include "llvm/ExecutionEngine/Orc/CompileOnDemandLayer.h"
#include "llvm/ExecutionEngine/Orc/CompileUtils.h"
#include "llvm/ExecutionEngine/Orc/ExecutionUtils.h"
#include "llvm/ExecutionEngine/Orc/IRCompileLayer.h"
#include "llvm/ExecutionEngine/Orc/ObjectLinkingLayer.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm-c/OrcBindings.h"

namespace llvm {

class OrcCBindingsStack;

DEFINE_SIMPLE_CONVERSION_FUNCTIONS(OrcCBindingsStack, LLVMOrcJITStackRef)
DEFINE_SIMPLE_CONVERSION_FUNCTIONS(TargetMachine, LLVMTargetMachineRef)

class OrcCBindingsStack {
public:

  typedef orc::JITCompileCallbackManager CompileCallbackMgr;
  typedef orc::ObjectLinkingLayer<> ObjLayerT;
  typedef orc::IRCompileLayer<ObjLayerT> CompileLayerT;
  typedef orc::CompileOnDemandLayer<CompileLayerT, CompileCallbackMgr> CODLayerT;

  typedef std::function<std::unique_ptr<CompileCallbackMgr>()>
    CallbackManagerBuilder;

  typedef CODLayerT::IndirectStubsManagerBuilderT IndirectStubsManagerBuilder;

private:

  class GenericHandle {
  public:
    virtual ~GenericHandle() {}
    virtual orc::JITSymbol findSymbolIn(const std::string &Name,
                                        bool ExportedSymbolsOnly) = 0;
    virtual void removeModule() = 0;
  };

  template <typename LayerT>
  class GenericHandleImpl : public GenericHandle {
  public:
    GenericHandleImpl(LayerT &Layer, typename LayerT::ModuleSetHandleT Handle)
      : Layer(Layer), Handle(std::move(Handle)) {}

    orc::JITSymbol findSymbolIn(const std::string &Name,
                                bool ExportedSymbolsOnly) override {
      return Layer.findSymbolIn(Handle, Name, ExportedSymbolsOnly);
    }

    void removeModule() override {
      return Layer.removeModuleSet(Handle);
    }

  private:
    LayerT &Layer;
    typename LayerT::ModuleSetHandleT Handle;
  };

  template <typename LayerT>
  std::unique_ptr<GenericHandleImpl<LayerT>>
  createGenericHandle(LayerT &Layer, typename LayerT::ModuleSetHandleT Handle) {
    return llvm::make_unique<GenericHandleImpl<LayerT>>(Layer,
                                                        std::move(Handle));
  }

public:

  // We need a 'ModuleSetHandleT' to conform to the layer concept.
  typedef unsigned ModuleSetHandleT;

  typedef unsigned ModuleHandleT;

  static std::unique_ptr<CompileCallbackMgr> createCompileCallbackMgr(Triple T);
  static IndirectStubsManagerBuilder createIndirectStubsMgrBuilder(Triple T);

  OrcCBindingsStack(TargetMachine &TM,
		    std::unique_ptr<CompileCallbackMgr> CCMgr, 
                    IndirectStubsManagerBuilder IndirectStubsMgrBuilder)
    : DL(TM.createDataLayout()), CCMgr(std::move(CCMgr)),
      ObjectLayer(),
      CompileLayer(ObjectLayer, orc::SimpleCompiler(TM)),
      CODLayer(CompileLayer,
               [](Function &F) { std::set<Function*> S; S.insert(&F); return S; },
               *this->CCMgr, std::move(IndirectStubsMgrBuilder), false),
      IndirectStubsMgr(IndirectStubsMgrBuilder()),
      CXXRuntimeOverrides([this](const std::string &S) { return mangle(S); }) {}

  ~OrcCBindingsStack() {
    // Run any destructors registered with __cxa_atexit.
    CXXRuntimeOverrides.runDestructors();
    // Run any IR destructors.
    for (auto &DtorRunner : IRStaticDestructorRunners)
      DtorRunner.runViaLayer(*this);
  }

  std::string mangle(StringRef Name) {
    std::string MangledName;
    {
      raw_string_ostream MangledNameStream(MangledName);
      Mangler::getNameWithPrefix(MangledNameStream, Name, DL);
    }
    return MangledName;
  }

  template <typename PtrTy>
  static PtrTy fromTargetAddress(orc::TargetAddress Addr) {
    return reinterpret_cast<PtrTy>(static_cast<uintptr_t>(Addr));
  }

  orc::TargetAddress
  createLazyCompileCallback(LLVMOrcLazyCompileCallbackFn Callback,
                            void *CallbackCtx) {
    auto CCInfo = CCMgr->getCompileCallback();
    CCInfo.setCompileAction(
      [=]() -> orc::TargetAddress {
        return Callback(wrap(this), CallbackCtx);
      });
    return CCInfo.getAddress();
  }

  void createIndirectStub(StringRef StubName, orc::TargetAddress Addr) {
    IndirectStubsMgr->createStub(StubName, Addr, JITSymbolFlags::Exported);
  }

  void setIndirectStubPointer(StringRef Name, orc::TargetAddress Addr) {
    IndirectStubsMgr->updatePointer(Name, Addr);
  }

  std::shared_ptr<RuntimeDyld::SymbolResolver>
  createResolver(LLVMOrcSymbolResolverFn ExternalResolver,
                 void *ExternalResolverCtx) {
    auto Resolver = orc::createLambdaResolver(
      [this, ExternalResolver, ExternalResolverCtx](const std::string &Name) {
        // Search order:
        // 1. JIT'd symbols.
        // 2. Runtime overrides.
        // 3. External resolver (if present).

        if (auto Sym = CODLayer.findSymbol(Name, true))
          return RuntimeDyld::SymbolInfo(Sym.getAddress(),
                                         Sym.getFlags());
        if (auto Sym = CXXRuntimeOverrides.searchOverrides(Name))
          return Sym;

        if (ExternalResolver)
          return RuntimeDyld::SymbolInfo(ExternalResolver(Name.c_str(),
                                                          ExternalResolverCtx),
                                         llvm::JITSymbolFlags::Exported);

        return RuntimeDyld::SymbolInfo(nullptr);
      },
      [](const std::string &Name) {
        return RuntimeDyld::SymbolInfo(nullptr);
      }
    );

    return std::shared_ptr<RuntimeDyld::SymbolResolver>(std::move(Resolver));
  }

  template <typename LayerT>
  ModuleHandleT addIRModule(LayerT &Layer,
                            Module *M,
                            std::unique_ptr<RuntimeDyld::MemoryManager> MemMgr,
                            LLVMOrcSymbolResolverFn ExternalResolver,
                            void *ExternalResolverCtx) {

    // Attach a data-layout if one isn't already present.
    if (M->getDataLayout().isDefault())
      M->setDataLayout(DL);

    // Record the static constructors and destructors. We have to do this before
    // we hand over ownership of the module to the JIT.
    std::vector<std::string> CtorNames, DtorNames;
    for (auto Ctor : orc::getConstructors(*M))
      CtorNames.push_back(mangle(Ctor.Func->getName()));
    for (auto Dtor : orc::getDestructors(*M))
      DtorNames.push_back(mangle(Dtor.Func->getName()));

    // Create the resolver.
    auto Resolver = createResolver(ExternalResolver, ExternalResolverCtx);

    // Add the module to the JIT.
    std::vector<Module*> S;
    S.push_back(std::move(M));

    auto LH = Layer.addModuleSet(std::move(S), std::move(MemMgr),
                                 std::move(Resolver));
    ModuleHandleT H = createHandle(Layer, LH);

    // Run the static constructors, and save the static destructor runner for
    // execution when the JIT is torn down.
    orc::CtorDtorRunner<OrcCBindingsStack> CtorRunner(std::move(CtorNames), H);
    CtorRunner.runViaLayer(*this);

    IRStaticDestructorRunners.emplace_back(std::move(DtorNames), H);

    return H;
  }

  ModuleHandleT addIRModuleEager(Module* M,
                                 LLVMOrcSymbolResolverFn ExternalResolver,
                                 void *ExternalResolverCtx) {
    return addIRModule(CompileLayer, std::move(M),
                       llvm::make_unique<SectionMemoryManager>(),
                       std::move(ExternalResolver), ExternalResolverCtx);
  }

  ModuleHandleT addIRModuleLazy(Module* M,
                                LLVMOrcSymbolResolverFn ExternalResolver,
                                void *ExternalResolverCtx) {
    return addIRModule(CODLayer, std::move(M),
		       llvm::make_unique<SectionMemoryManager>(),
                       std::move(ExternalResolver), ExternalResolverCtx);
  }

  void removeModule(ModuleHandleT H) {
    GenericHandles[H]->removeModule();
    GenericHandles[H] = nullptr;
    FreeHandleIndexes.push_back(H);
  }

  orc::JITSymbol findSymbol(const std::string &Name, bool ExportedSymbolsOnly) {
    if (auto Sym = IndirectStubsMgr->findStub(Name, ExportedSymbolsOnly))
      return Sym;
    return CODLayer.findSymbol(mangle(Name), ExportedSymbolsOnly);
  }

  orc::JITSymbol findSymbolIn(ModuleHandleT H, const std::string &Name,
                              bool ExportedSymbolsOnly) {
    return GenericHandles[H]->findSymbolIn(Name, ExportedSymbolsOnly);
  }

private:

  template <typename LayerT>
  unsigned createHandle(LayerT &Layer,
                        typename LayerT::ModuleSetHandleT Handle) {
    unsigned NewHandle;
    if (!FreeHandleIndexes.empty()) {
      NewHandle = FreeHandleIndexes.back();
      FreeHandleIndexes.pop_back();
      GenericHandles[NewHandle] = createGenericHandle(Layer, std::move(Handle));
      return NewHandle;
    } else {
      NewHandle = GenericHandles.size();
      GenericHandles.push_back(createGenericHandle(Layer, std::move(Handle)));
    }
    return NewHandle;
  }

  DataLayout DL;
  SectionMemoryManager CCMgrMemMgr;

  std::unique_ptr<CompileCallbackMgr> CCMgr;
  ObjLayerT ObjectLayer;
  CompileLayerT CompileLayer;
  CODLayerT CODLayer;

  std::unique_ptr<orc::IndirectStubsManager> IndirectStubsMgr;

  std::vector<std::unique_ptr<GenericHandle>> GenericHandles;
  std::vector<unsigned> FreeHandleIndexes;

  orc::LocalCXXRuntimeOverrides CXXRuntimeOverrides;
  std::vector<orc::CtorDtorRunner<OrcCBindingsStack>> IRStaticDestructorRunners;
};

} // end namespace llvm

#endif // LLVM_LIB_EXECUTIONENGINE_ORC_ORCCBINDINGSSTACK_H
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@a12 1
#include "llvm-c/OrcBindings.h"
d20 1
a20 1
#include "llvm/Support/Error.h"
d31 1
d35 1
a35 2
  typedef orc::CompileOnDemandLayer<CompileLayerT, CompileCallbackMgr>
      CODLayerT;
d38 1
a38 1
      CallbackManagerBuilder;
d43 1
d52 2
a53 1
  template <typename LayerT> class GenericHandleImpl : public GenericHandle {
d56 1
a56 1
        : Layer(Layer), Handle(std::move(Handle)) {}
d63 3
a65 1
    void removeModule() override { return Layer.removeModuleSet(Handle); }
d80 1
d86 3
d90 1
a90 1
                    std::unique_ptr<CompileCallbackMgr> CCMgr,
d92 8
a99 8
      : DL(TM.createDataLayout()), IndirectStubsMgr(IndirectStubsMgrBuilder()),
        CCMgr(std::move(CCMgr)), ObjectLayer(),
        CompileLayer(ObjectLayer, orc::SimpleCompiler(TM)),
        CODLayer(CompileLayer,
                 [](Function &F) { return std::set<Function *>({&F}); },
                 *this->CCMgr, std::move(IndirectStubsMgrBuilder), false),
        CXXRuntimeOverrides(
            [this](const std::string &S) { return mangle(S); }) {}
d127 4
a130 3
    CCInfo.setCompileAction([=]() -> orc::TargetAddress {
      return Callback(wrap(this), CallbackCtx);
    });
d134 2
a135 4
  LLVMOrcErrorCode createIndirectStub(StringRef StubName,
                                      orc::TargetAddress Addr) {
    return mapError(
        IndirectStubsMgr->createStub(StubName, Addr, JITSymbolFlags::Exported));
d138 2
a139 3
  LLVMOrcErrorCode setIndirectStubPointer(StringRef Name,
                                          orc::TargetAddress Addr) {
    return mapError(IndirectStubsMgr->updatePointer(Name, Addr));
d142 1
a142 1
  std::unique_ptr<RuntimeDyld::SymbolResolver>
d145 26
a170 22
    return orc::createLambdaResolver(
        [this, ExternalResolver, ExternalResolverCtx](const std::string &Name) {
          // Search order:
          // 1. JIT'd symbols.
          // 2. Runtime overrides.
          // 3. External resolver (if present).

          if (auto Sym = CODLayer.findSymbol(Name, true))
            return Sym.toRuntimeDyldSymbol();
          if (auto Sym = CXXRuntimeOverrides.searchOverrides(Name))
            return Sym;

          if (ExternalResolver)
            return RuntimeDyld::SymbolInfo(
                ExternalResolver(Name.c_str(), ExternalResolverCtx),
                llvm::JITSymbolFlags::Exported);

          return RuntimeDyld::SymbolInfo(nullptr);
        },
        [](const std::string &Name) {
          return RuntimeDyld::SymbolInfo(nullptr);
        });
d174 2
a175 1
  ModuleHandleT addIRModule(LayerT &Layer, Module *M,
d196 1
a196 1
    std::vector<Module *> S;
d213 1
a213 1
  ModuleHandleT addIRModuleEager(Module *M,
d221 1
a221 1
  ModuleHandleT addIRModuleLazy(Module *M,
d225 1
a225 1
                       llvm::make_unique<SectionMemoryManager>(),
d246 1
a246 1
  const std::string &getErrorMessage() const { return ErrMsg; }
a247 1
private:
a263 12
  LLVMOrcErrorCode mapError(Error Err) {
    LLVMOrcErrorCode Result = LLVMOrcErrSuccess;
    handleAllErrors(std::move(Err), [&](ErrorInfoBase &EIB) {
      // Handler of last resort.
      Result = LLVMOrcErrGeneric;
      ErrMsg = "";
      raw_string_ostream ErrStream(ErrMsg);
      EIB.log(ErrStream);
    });
    return Result;
  }

a266 2
  std::unique_ptr<orc::IndirectStubsManager> IndirectStubsMgr;

d272 2
a278 1
  std::string ErrMsg;
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d47 2
a48 2
    virtual JITSymbol findSymbolIn(const std::string &Name,
                                   bool ExportedSymbolsOnly) = 0;
d57 2
a58 2
    JITSymbol findSymbolIn(const std::string &Name,
                           bool ExportedSymbolsOnly) override {
d112 1
a112 1
  static PtrTy fromTargetAddress(JITTargetAddress Addr) {
d116 1
a116 1
  JITTargetAddress
d120 1
a120 1
    CCInfo.setCompileAction([=]() -> JITTargetAddress {
d127 1
a127 1
                                      JITTargetAddress Addr) {
d133 1
a133 1
                                          JITTargetAddress Addr) {
d137 1
a137 1
  std::unique_ptr<JITSymbolResolver>
d141 1
a141 2
        [this, ExternalResolver, ExternalResolverCtx](const std::string &Name)
            -> JITSymbol {
d148 1
a148 1
            return Sym;
d153 1
a153 1
            return JITSymbol(
d157 1
a157 1
          return JITSymbol(nullptr);
d160 1
a160 1
          return JITSymbol(nullptr);
d225 1
a225 1
  JITSymbol findSymbol(const std::string &Name, bool ExportedSymbolsOnly) {
d231 2
a232 2
  JITSymbol findSymbolIn(ModuleHandleT H, const std::string &Name,
                         bool ExportedSymbolsOnly) {
@


