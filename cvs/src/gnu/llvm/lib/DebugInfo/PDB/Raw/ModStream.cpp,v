head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.2.0.6
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.1
date	2017.01.14.19.56.03;	author patrick;	state Exp;
branches
	1.1.1.1;
next	;
commitid	qMUxATnKgqN83Oct;

1.1.1.1
date	2017.01.14.19.56.03;	author patrick;	state Exp;
branches;
next	1.1.1.2;
commitid	qMUxATnKgqN83Oct;

1.1.1.2
date	2017.01.24.08.33.35;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===- ModStream.cpp - PDB Module Info Stream Access ----------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "llvm/DebugInfo/PDB/Raw/ModStream.h"

#include "llvm/DebugInfo/CodeView/StreamReader.h"
#include "llvm/DebugInfo/PDB/Raw/IndexedStreamData.h"
#include "llvm/DebugInfo/PDB/Raw/ModInfo.h"
#include "llvm/DebugInfo/PDB/Raw/PDBFile.h"
#include "llvm/DebugInfo/PDB/Raw/RawError.h"
#include "llvm/DebugInfo/PDB/Raw/RawTypes.h"

using namespace llvm;
using namespace llvm::pdb;

ModStream::ModStream(const ModInfo &Module,
                     std::unique_ptr<MappedBlockStream> Stream)
    : Mod(Module), Stream(std::move(Stream)) {}

ModStream::~ModStream() {}

Error ModStream::reload() {
  codeview::StreamReader Reader(*Stream);

  uint32_t SymbolSize = Mod.getSymbolDebugInfoByteSize();
  uint32_t C11Size = Mod.getLineInfoByteSize();
  uint32_t C13Size = Mod.getC13LineInfoByteSize();

  if (C11Size > 0 && C13Size > 0)
    return llvm::make_error<RawError>(raw_error_code::corrupt_file,
                                      "Module has both C11 and C13 line info");

  codeview::StreamRef S;

  uint32_t SymbolSubstreamSig = 0;
  if (auto EC = Reader.readInteger(SymbolSubstreamSig))
    return EC;
  if (auto EC = Reader.readArray(SymbolsSubstream, SymbolSize - 4))
    return EC;

  if (auto EC = Reader.readStreamRef(LinesSubstream, C11Size))
    return EC;
  if (auto EC = Reader.readStreamRef(C13LinesSubstream, C13Size))
    return EC;

  codeview::StreamReader LineReader(C13LinesSubstream);
  if (auto EC = LineReader.readArray(LineInfo, LineReader.bytesRemaining()))
    return EC;

  uint32_t GlobalRefsSize;
  if (auto EC = Reader.readInteger(GlobalRefsSize))
    return EC;
  if (auto EC = Reader.readStreamRef(GlobalRefsSubstream, GlobalRefsSize))
    return EC;
  if (Reader.bytesRemaining() > 0)
    return llvm::make_error<RawError>(raw_error_code::corrupt_file,
                                      "Unexpected bytes in module stream.");

  return Error::success();
}

iterator_range<codeview::CVSymbolArray::Iterator>
ModStream::symbols(bool *HadError) const {
  // It's OK if the stream is empty.
  if (SymbolsSubstream.getUnderlyingStream().getLength() == 0)
    return llvm::make_range(SymbolsSubstream.end(), SymbolsSubstream.end());
  return llvm::make_range(SymbolsSubstream.begin(HadError),
                          SymbolsSubstream.end());
}

iterator_range<codeview::ModuleSubstreamArray::Iterator>
ModStream::lines(bool *HadError) const {
  return llvm::make_range(LineInfo.begin(HadError), LineInfo.end());
}

Error ModStream::commit() { return Error::success(); }
@


1.1.1.1
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d10 4
a13 4
#include "llvm/ADT/iterator_range.h"
#include "llvm/DebugInfo/CodeView/SymbolRecord.h"
#include "llvm/DebugInfo/MSF/StreamReader.h"
#include "llvm/DebugInfo/MSF/StreamRef.h"
a14 1
#include "llvm/DebugInfo/PDB/Raw/ModStream.h"
a17 3
#include "llvm/Support/Error.h"
#include <algorithm>
#include <cstdint>
a19 1
using namespace llvm::msf;
d26 1
a26 1
ModStream::~ModStream() = default;
d29 1
a29 1
  StreamReader Reader(*Stream);
d36 2
a37 2
    return make_error<RawError>(raw_error_code::corrupt_file,
                                "Module has both C11 and C13 line info");
d39 1
a39 1
  ReadableStreamRef S;
d41 2
a42 1
  if (auto EC = Reader.readInteger(Signature))
d52 1
a52 1
  StreamReader LineReader(C13LinesSubstream);
d62 2
a63 2
    return make_error<RawError>(raw_error_code::corrupt_file,
                                "Unexpected bytes in module stream.");
d72 3
a74 2
    return make_range(SymbolsSubstream.end(), SymbolsSubstream.end());
  return make_range(SymbolsSubstream.begin(HadError), SymbolsSubstream.end());
d79 1
a79 1
  return make_range(LineInfo.begin(HadError), LineInfo.end());
@

