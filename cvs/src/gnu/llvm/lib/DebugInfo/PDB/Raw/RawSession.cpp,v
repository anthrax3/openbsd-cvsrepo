head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.1
date	2017.01.14.19.56.03;	author patrick;	state Exp;
branches
	1.1.1.1;
next	;
commitid	qMUxATnKgqN83Oct;

1.1.1.1
date	2017.01.14.19.56.03;	author patrick;	state Exp;
branches;
next	1.1.1.2;
commitid	qMUxATnKgqN83Oct;

1.1.1.2
date	2017.01.24.08.33.35;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===- RawSession.cpp - Raw implementation of IPDBSession -------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "llvm/DebugInfo/PDB/Raw/RawSession.h"

#include "llvm/DebugInfo/CodeView/ByteStream.h"
#include "llvm/DebugInfo/CodeView/StreamInterface.h"
#include "llvm/DebugInfo/PDB/GenericError.h"
#include "llvm/DebugInfo/PDB/IPDBEnumChildren.h"
#include "llvm/DebugInfo/PDB/IPDBSourceFile.h"
#include "llvm/DebugInfo/PDB/PDBSymbolCompiland.h"
#include "llvm/DebugInfo/PDB/PDBSymbolExe.h"
#include "llvm/DebugInfo/PDB/Raw/PDBFile.h"
#include "llvm/DebugInfo/PDB/Raw/RawError.h"

#include "llvm/Support/ErrorOr.h"
#include "llvm/Support/MemoryBuffer.h"

using namespace llvm;
using namespace llvm::pdb;

namespace {
// We need a class which behaves like an immutable ByteStream, but whose data
// is backed by an llvm::MemoryBuffer.  It also needs to own the underlying
// MemoryBuffer, so this simple adapter is a good way to achieve that.
class InputByteStream : public codeview::ByteStream<false> {
public:
  explicit InputByteStream(std::unique_ptr<MemoryBuffer> Buffer)
      : ByteStream(ArrayRef<uint8_t>(Buffer->getBuffer().bytes_begin(),
                                     Buffer->getBuffer().bytes_end())),
        MemBuffer(std::move(Buffer)) {}

  std::unique_ptr<MemoryBuffer> MemBuffer;
};
}

RawSession::RawSession(std::unique_ptr<PDBFile> PdbFile)
    : Pdb(std::move(PdbFile)) {}

RawSession::~RawSession() {}

Error RawSession::createFromPdb(StringRef Path,
                                std::unique_ptr<IPDBSession> &Session) {

  ErrorOr<std::unique_ptr<MemoryBuffer>> ErrorOrBuffer =
      MemoryBuffer::getFileOrSTDIN(Path, /*FileSize=*/-1,
                                   /*RequiresNullTerminator=*/false);
  if (!ErrorOrBuffer)
    return llvm::make_error<GenericError>(generic_error_code::invalid_path);

  std::unique_ptr<MemoryBuffer> Buffer = std::move(*ErrorOrBuffer);
  auto Stream = llvm::make_unique<InputByteStream>(std::move(Buffer));

  std::unique_ptr<PDBFile> File(new PDBFile(std::move(Stream)));
  if (auto EC = File->parseFileHeaders())
    return EC;
  if (auto EC = File->parseStreamData())
    return EC;

  Session.reset(new RawSession(std::move(File)));

  return Error::success();
}

Error RawSession::createFromExe(StringRef Path,
                                std::unique_ptr<IPDBSession> &Session) {
  return llvm::make_error<RawError>(raw_error_code::feature_unsupported);
}

uint64_t RawSession::getLoadAddress() const { return 0; }

void RawSession::setLoadAddress(uint64_t Address) {}

std::unique_ptr<PDBSymbolExe> RawSession::getGlobalScope() const {
  return nullptr;
}

std::unique_ptr<PDBSymbol> RawSession::getSymbolById(uint32_t SymbolId) const {
  return nullptr;
}

std::unique_ptr<PDBSymbol>
RawSession::findSymbolByAddress(uint64_t Address, PDB_SymType Type) const {
  return nullptr;
}

std::unique_ptr<IPDBEnumLineNumbers>
RawSession::findLineNumbers(const PDBSymbolCompiland &Compiland,
                            const IPDBSourceFile &File) const {
  return nullptr;
}

std::unique_ptr<IPDBEnumLineNumbers>
RawSession::findLineNumbersByAddress(uint64_t Address, uint32_t Length) const {
  return nullptr;
}

std::unique_ptr<IPDBEnumSourceFiles>
RawSession::findSourceFiles(const PDBSymbolCompiland *Compiland,
                            llvm::StringRef Pattern,
                            PDB_NameSearchFlags Flags) const {
  return nullptr;
}

std::unique_ptr<IPDBSourceFile>
RawSession::findOneSourceFile(const PDBSymbolCompiland *Compiland,
                              llvm::StringRef Pattern,
                              PDB_NameSearchFlags Flags) const {
  return nullptr;
}

std::unique_ptr<IPDBEnumChildren<PDBSymbolCompiland>>
RawSession::findCompilandsForSourceFile(llvm::StringRef Pattern,
                                        PDB_NameSearchFlags Flags) const {
  return nullptr;
}

std::unique_ptr<PDBSymbolCompiland>
RawSession::findOneCompilandForSourceFile(llvm::StringRef Pattern,
                                          PDB_NameSearchFlags Flags) const {
  return nullptr;
}

std::unique_ptr<IPDBEnumSourceFiles> RawSession::getAllSourceFiles() const {
  return nullptr;
}

std::unique_ptr<IPDBEnumSourceFiles> RawSession::getSourceFilesForCompiland(
    const PDBSymbolCompiland &Compiland) const {
  return nullptr;
}

std::unique_ptr<IPDBSourceFile>
RawSession::getSourceFileById(uint32_t FileId) const {
  return nullptr;
}

std::unique_ptr<IPDBEnumDataStreams> RawSession::getDebugStreams() const {
  return nullptr;
}
@


1.1.1.1
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d10 4
a13 2
#include "llvm/ADT/STLExtras.h"
#include "llvm/DebugInfo/MSF/ByteStream.h"
d21 1
a21 3
#include "llvm/DebugInfo/PDB/Raw/RawSession.h"
#include "llvm/Support/Allocator.h"
#include "llvm/Support/Error.h"
a23 2
#include <algorithm>
#include <memory>
a25 1
using namespace llvm::msf;
d28 10
a37 3
RawSession::RawSession(std::unique_ptr<PDBFile> PdbFile,
                       std::unique_ptr<BumpPtrAllocator> Allocator)
    : Pdb(std::move(PdbFile)), Allocator(std::move(Allocator)) {}
d39 8
a46 1
RawSession::~RawSession() = default;
d50 1
d55 1
a55 1
    return make_error<GenericError>(generic_error_code::invalid_path);
d58 1
a58 1
  auto Stream = llvm::make_unique<MemoryBufferByteStream>(std::move(Buffer));
d60 1
a60 2
  auto Allocator = llvm::make_unique<BumpPtrAllocator>();
  auto File = llvm::make_unique<PDBFile>(std::move(Stream), *Allocator);
d66 1
a66 2
  Session =
      llvm::make_unique<RawSession>(std::move(File), std::move(Allocator));
d73 1
a73 1
  return make_error<RawError>(raw_error_code::feature_unsupported);
d106 1
a106 1
                            StringRef Pattern,
d113 1
a113 1
                              StringRef Pattern,
d119 1
a119 1
RawSession::findCompilandsForSourceFile(StringRef Pattern,
d125 1
a125 1
RawSession::findOneCompilandForSourceFile(StringRef Pattern,
@

