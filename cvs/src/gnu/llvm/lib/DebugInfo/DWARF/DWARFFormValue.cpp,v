head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.3
	OPENBSD_6_2:1.1.1.2.0.2
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.24.08.33.35;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	so2WA7LCP6wbxtYl;

1.1.1.3
date	2017.10.04.20.28.09;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- DWARFFormValue.cpp ------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "SyntaxHighlighting.h"
#include "llvm/ADT/ArrayRef.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/DebugInfo/DWARF/DWARFCompileUnit.h"
#include "llvm/DebugInfo/DWARF/DWARFContext.h"
#include "llvm/DebugInfo/DWARF/DWARFFormValue.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/Dwarf.h"
#include "llvm/Support/Format.h"
#include "llvm/Support/raw_ostream.h"
#include <cassert>
#include <limits>
using namespace llvm;
using namespace dwarf;
using namespace syntax;

namespace {
uint8_t getRefAddrSize(uint8_t AddrSize, uint16_t Version) {
  // FIXME: Support DWARF64.
  return (Version == 2) ? AddrSize : 4;
}

template <uint8_t AddrSize, uint8_t RefAddrSize>
ArrayRef<uint8_t> makeFixedFormSizesArrayRef() {
  static const uint8_t sizes[] = {
    0,           // 0x00 unused
    AddrSize,    // 0x01 DW_FORM_addr
    0,           // 0x02 unused
    0,           // 0x03 DW_FORM_block2
    0,           // 0x04 DW_FORM_block4
    2,           // 0x05 DW_FORM_data2
    4,           // 0x06 DW_FORM_data4
    8,           // 0x07 DW_FORM_data8
    0,           // 0x08 DW_FORM_string
    0,           // 0x09 DW_FORM_block
    0,           // 0x0a DW_FORM_block1
    1,           // 0x0b DW_FORM_data1
    1,           // 0x0c DW_FORM_flag
    0,           // 0x0d DW_FORM_sdata
    4,           // 0x0e DW_FORM_strp
    0,           // 0x0f DW_FORM_udata
    RefAddrSize, // 0x10 DW_FORM_ref_addr
    1,           // 0x11 DW_FORM_ref1
    2,           // 0x12 DW_FORM_ref2
    4,           // 0x13 DW_FORM_ref4
    8,           // 0x14 DW_FORM_ref8
    0,           // 0x15 DW_FORM_ref_udata
    0,           // 0x16 DW_FORM_indirect
    4,           // 0x17 DW_FORM_sec_offset
    0,           // 0x18 DW_FORM_exprloc
    0,           // 0x19 DW_FORM_flag_present
  };
  return makeArrayRef(sizes);
}
}

ArrayRef<uint8_t> DWARFFormValue::getFixedFormSizes(uint8_t AddrSize,
                                                    uint16_t Version) {
  uint8_t RefAddrSize = getRefAddrSize(AddrSize, Version);
  if (AddrSize == 4 && RefAddrSize == 4)
    return makeFixedFormSizesArrayRef<4, 4>();
  if (AddrSize == 4 && RefAddrSize == 8)
    return makeFixedFormSizesArrayRef<4, 8>();
  if (AddrSize == 8 && RefAddrSize == 4)
    return makeFixedFormSizesArrayRef<8, 4>();
  if (AddrSize == 8 && RefAddrSize == 8)
    return makeFixedFormSizesArrayRef<8, 8>();
  return None;
}

static const DWARFFormValue::FormClass DWARF4FormClasses[] = {
  DWARFFormValue::FC_Unknown,       // 0x0
  DWARFFormValue::FC_Address,       // 0x01 DW_FORM_addr
  DWARFFormValue::FC_Unknown,       // 0x02 unused
  DWARFFormValue::FC_Block,         // 0x03 DW_FORM_block2
  DWARFFormValue::FC_Block,         // 0x04 DW_FORM_block4
  DWARFFormValue::FC_Constant,      // 0x05 DW_FORM_data2
  // --- These can be FC_SectionOffset in DWARF3 and below:
  DWARFFormValue::FC_Constant,      // 0x06 DW_FORM_data4
  DWARFFormValue::FC_Constant,      // 0x07 DW_FORM_data8
  // ---
  DWARFFormValue::FC_String,        // 0x08 DW_FORM_string
  DWARFFormValue::FC_Block,         // 0x09 DW_FORM_block
  DWARFFormValue::FC_Block,         // 0x0a DW_FORM_block1
  DWARFFormValue::FC_Constant,      // 0x0b DW_FORM_data1
  DWARFFormValue::FC_Flag,          // 0x0c DW_FORM_flag
  DWARFFormValue::FC_Constant,      // 0x0d DW_FORM_sdata
  DWARFFormValue::FC_String,        // 0x0e DW_FORM_strp
  DWARFFormValue::FC_Constant,      // 0x0f DW_FORM_udata
  DWARFFormValue::FC_Reference,     // 0x10 DW_FORM_ref_addr
  DWARFFormValue::FC_Reference,     // 0x11 DW_FORM_ref1
  DWARFFormValue::FC_Reference,     // 0x12 DW_FORM_ref2
  DWARFFormValue::FC_Reference,     // 0x13 DW_FORM_ref4
  DWARFFormValue::FC_Reference,     // 0x14 DW_FORM_ref8
  DWARFFormValue::FC_Reference,     // 0x15 DW_FORM_ref_udata
  DWARFFormValue::FC_Indirect,      // 0x16 DW_FORM_indirect
  DWARFFormValue::FC_SectionOffset, // 0x17 DW_FORM_sec_offset
  DWARFFormValue::FC_Exprloc,       // 0x18 DW_FORM_exprloc
  DWARFFormValue::FC_Flag,          // 0x19 DW_FORM_flag_present
};

bool DWARFFormValue::isFormClass(DWARFFormValue::FormClass FC) const {
  // First, check DWARF4 form classes.
  if (Form < makeArrayRef(DWARF4FormClasses).size() &&
      DWARF4FormClasses[Form] == FC)
    return true;
  // Check more forms from DWARF4 and DWARF5 proposals.
  switch (Form) {
  case DW_FORM_ref_sig8:
  case DW_FORM_GNU_ref_alt:
    return (FC == FC_Reference);
  case DW_FORM_GNU_addr_index:
    return (FC == FC_Address);
  case DW_FORM_GNU_str_index:
  case DW_FORM_GNU_strp_alt:
    return (FC == FC_String);
  }
  // In DWARF3 DW_FORM_data4 and DW_FORM_data8 served also as a section offset.
  // Don't check for DWARF version here, as some producers may still do this
  // by mistake.
  return (Form == DW_FORM_data4 || Form == DW_FORM_data8) &&
         FC == FC_SectionOffset;
}

bool DWARFFormValue::extractValue(DataExtractor data, uint32_t *offset_ptr,
                                  const DWARFUnit *cu) {
  bool indirect = false;
  bool is_block = false;
  Value.data = nullptr;
  // Read the value for the form into value and follow and DW_FORM_indirect
  // instances we run into
  do {
    indirect = false;
    switch (Form) {
    case DW_FORM_addr:
    case DW_FORM_ref_addr: {
      if (!cu)
        return false;
      uint16_t AddrSize =
          (Form == DW_FORM_addr)
              ? cu->getAddressByteSize()
              : getRefAddrSize(cu->getAddressByteSize(), cu->getVersion());
      RelocAddrMap::const_iterator AI = cu->getRelocMap()->find(*offset_ptr);
      if (AI != cu->getRelocMap()->end()) {
        const std::pair<uint8_t, int64_t> &R = AI->second;
        Value.uval = data.getUnsigned(offset_ptr, AddrSize) + R.second;
      } else
        Value.uval = data.getUnsigned(offset_ptr, AddrSize);
      break;
    }
    case DW_FORM_exprloc:
    case DW_FORM_block:
      Value.uval = data.getULEB128(offset_ptr);
      is_block = true;
      break;
    case DW_FORM_block1:
      Value.uval = data.getU8(offset_ptr);
      is_block = true;
      break;
    case DW_FORM_block2:
      Value.uval = data.getU16(offset_ptr);
      is_block = true;
      break;
    case DW_FORM_block4:
      Value.uval = data.getU32(offset_ptr);
      is_block = true;
      break;
    case DW_FORM_data1:
    case DW_FORM_ref1:
    case DW_FORM_flag:
      Value.uval = data.getU8(offset_ptr);
      break;
    case DW_FORM_data2:
    case DW_FORM_ref2:
      Value.uval = data.getU16(offset_ptr);
      break;
    case DW_FORM_data4:
    case DW_FORM_ref4: {
      Value.uval = data.getU32(offset_ptr);
      if (!cu)
        break;
      RelocAddrMap::const_iterator AI = cu->getRelocMap()->find(*offset_ptr-4);
      if (AI != cu->getRelocMap()->end())
        Value.uval += AI->second.second;
      break;
    }
    case DW_FORM_data8:
    case DW_FORM_ref8:
      Value.uval = data.getU64(offset_ptr);
      break;
    case DW_FORM_sdata:
      Value.sval = data.getSLEB128(offset_ptr);
      break;
    case DW_FORM_udata:
    case DW_FORM_ref_udata:
      Value.uval = data.getULEB128(offset_ptr);
      break;
    case DW_FORM_string:
      Value.cstr = data.getCStr(offset_ptr);
      break;
    case DW_FORM_indirect:
      Form = data.getULEB128(offset_ptr);
      indirect = true;
      break;
    case DW_FORM_sec_offset:
    case DW_FORM_strp:
    case DW_FORM_GNU_ref_alt:
    case DW_FORM_GNU_strp_alt: {
      // FIXME: This is 64-bit for DWARF64.
      Value.uval = data.getU32(offset_ptr);
      if (!cu)
        break;
      RelocAddrMap::const_iterator AI =
          cu->getRelocMap()->find(*offset_ptr - 4);
      if (AI != cu->getRelocMap()->end())
        Value.uval += AI->second.second;
      break;
    }
    case DW_FORM_flag_present:
      Value.uval = 1;
      break;
    case DW_FORM_ref_sig8:
      Value.uval = data.getU64(offset_ptr);
      break;
    case DW_FORM_GNU_addr_index:
    case DW_FORM_GNU_str_index:
      Value.uval = data.getULEB128(offset_ptr);
      break;
    default:
      return false;
    }
  } while (indirect);

  if (is_block) {
    StringRef str = data.getData().substr(*offset_ptr, Value.uval);
    Value.data = nullptr;
    if (!str.empty()) {
      Value.data = reinterpret_cast<const uint8_t *>(str.data());
      *offset_ptr += Value.uval;
    }
  }

  return true;
}

bool
DWARFFormValue::skipValue(DataExtractor debug_info_data, uint32_t* offset_ptr,
                          const DWARFUnit *cu) const {
  return DWARFFormValue::skipValue(Form, debug_info_data, offset_ptr, cu);
}

bool
DWARFFormValue::skipValue(uint16_t form, DataExtractor debug_info_data,
                          uint32_t *offset_ptr, const DWARFUnit *cu) {
  return skipValue(form, debug_info_data, offset_ptr, cu->getVersion(),
                   cu->getAddressByteSize());
}
bool DWARFFormValue::skipValue(uint16_t form, DataExtractor debug_info_data,
                               uint32_t *offset_ptr, uint16_t Version,
                               uint8_t AddrSize) {
  bool indirect = false;
  do {
    switch (form) {
    // Blocks if inlined data that have a length field and the data bytes
    // inlined in the .debug_info
    case DW_FORM_exprloc:
    case DW_FORM_block: {
      uint64_t size = debug_info_data.getULEB128(offset_ptr);
      *offset_ptr += size;
      return true;
    }
    case DW_FORM_block1: {
      uint8_t size = debug_info_data.getU8(offset_ptr);
      *offset_ptr += size;
      return true;
    }
    case DW_FORM_block2: {
      uint16_t size = debug_info_data.getU16(offset_ptr);
      *offset_ptr += size;
      return true;
    }
    case DW_FORM_block4: {
      uint32_t size = debug_info_data.getU32(offset_ptr);
      *offset_ptr += size;
      return true;
    }

    // Inlined NULL terminated C-strings
    case DW_FORM_string:
      debug_info_data.getCStr(offset_ptr);
      return true;

    // Compile unit address sized values
    case DW_FORM_addr:
      *offset_ptr += AddrSize;
      return true;
    case DW_FORM_ref_addr:
      *offset_ptr += getRefAddrSize(AddrSize, Version);
      return true;

    // 0 byte values - implied from the form.
    case DW_FORM_flag_present:
      return true;

    // 1 byte values
    case DW_FORM_data1:
    case DW_FORM_flag:
    case DW_FORM_ref1:
      *offset_ptr += 1;
      return true;

    // 2 byte values
    case DW_FORM_data2:
    case DW_FORM_ref2:
      *offset_ptr += 2;
      return true;

    // 4 byte values
    case DW_FORM_data4:
    case DW_FORM_ref4:
      *offset_ptr += 4;
      return true;

    // 8 byte values
    case DW_FORM_data8:
    case DW_FORM_ref8:
    case DW_FORM_ref_sig8:
      *offset_ptr += 8;
      return true;

    // signed or unsigned LEB 128 values
    //  case DW_FORM_APPLE_db_str:
    case DW_FORM_sdata:
    case DW_FORM_udata:
    case DW_FORM_ref_udata:
    case DW_FORM_GNU_str_index:
    case DW_FORM_GNU_addr_index:
      debug_info_data.getULEB128(offset_ptr);
      return true;

    case DW_FORM_indirect:
      indirect = true;
      form = debug_info_data.getULEB128(offset_ptr);
      break;

    // FIXME: 4 for DWARF32, 8 for DWARF64.
    case DW_FORM_sec_offset:
    case DW_FORM_strp:
    case DW_FORM_GNU_ref_alt:
    case DW_FORM_GNU_strp_alt:
      *offset_ptr += 4;
      return true;

    default:
      return false;
    }
  } while (indirect);
  return true;
}

void
DWARFFormValue::dump(raw_ostream &OS, const DWARFUnit *cu) const {
  uint64_t uvalue = Value.uval;
  bool cu_relative_offset = false;

  switch (Form) {
  case DW_FORM_addr:      OS << format("0x%016" PRIx64, uvalue); break;
  case DW_FORM_GNU_addr_index: {
    OS << format(" indexed (%8.8x) address = ", (uint32_t)uvalue);
    uint64_t Address;
    if (cu->getAddrOffsetSectionItem(uvalue, Address))
      OS << format("0x%016" PRIx64, Address);
    else
      OS << "<no .debug_addr section>";
    break;
  }
  case DW_FORM_flag_present: OS << "true"; break;
  case DW_FORM_flag:
  case DW_FORM_data1:     OS << format("0x%02x", (uint8_t)uvalue); break;
  case DW_FORM_data2:     OS << format("0x%04x", (uint16_t)uvalue); break;
  case DW_FORM_data4:     OS << format("0x%08x", (uint32_t)uvalue); break;
  case DW_FORM_ref_sig8:
  case DW_FORM_data8:     OS << format("0x%016" PRIx64, uvalue); break;
  case DW_FORM_string:
    OS << '"';
    OS.write_escaped(Value.cstr);
    OS << '"';
    break;
  case DW_FORM_exprloc:
  case DW_FORM_block:
  case DW_FORM_block1:
  case DW_FORM_block2:
  case DW_FORM_block4:
    if (uvalue > 0) {
      switch (Form) {
      case DW_FORM_exprloc:
      case DW_FORM_block:  OS << format("<0x%" PRIx64 "> ", uvalue);     break;
      case DW_FORM_block1: OS << format("<0x%2.2x> ", (uint8_t)uvalue);  break;
      case DW_FORM_block2: OS << format("<0x%4.4x> ", (uint16_t)uvalue); break;
      case DW_FORM_block4: OS << format("<0x%8.8x> ", (uint32_t)uvalue); break;
      default: break;
      }

      const uint8_t* data_ptr = Value.data;
      if (data_ptr) {
        // uvalue contains size of block
        const uint8_t* end_data_ptr = data_ptr + uvalue;
        while (data_ptr < end_data_ptr) {
          OS << format("%2.2x ", *data_ptr);
          ++data_ptr;
        }
      }
      else
        OS << "NULL";
    }
    break;

  case DW_FORM_sdata:     OS << Value.sval; break;
  case DW_FORM_udata:     OS << Value.uval; break;
  case DW_FORM_strp: {
    OS << format(" .debug_str[0x%8.8x] = ", (uint32_t)uvalue);
    dumpString(OS, cu);
    break;
  }
  case DW_FORM_GNU_str_index: {
    OS << format(" indexed (%8.8x) string = ", (uint32_t)uvalue);
    dumpString(OS, cu);
    break;
  }
  case DW_FORM_GNU_strp_alt: {
    OS << format("alt indirect string, offset: 0x%" PRIx64 "", uvalue);
    dumpString(OS, cu);
    break;
  }
  case DW_FORM_ref_addr:
    OS << format("0x%016" PRIx64, uvalue);
    break;
  case DW_FORM_ref1:
    cu_relative_offset = true;
    OS << format("cu + 0x%2.2x", (uint8_t)uvalue);
    break;
  case DW_FORM_ref2:
    cu_relative_offset = true;
    OS << format("cu + 0x%4.4x", (uint16_t)uvalue);
    break;
  case DW_FORM_ref4:
    cu_relative_offset = true;
    OS << format("cu + 0x%4.4x", (uint32_t)uvalue);
    break;
  case DW_FORM_ref8:
    cu_relative_offset = true;
    OS << format("cu + 0x%8.8" PRIx64, uvalue);
    break;
  case DW_FORM_ref_udata:
    cu_relative_offset = true;
    OS << format("cu + 0x%" PRIx64, uvalue);
    break;
  case DW_FORM_GNU_ref_alt:
    OS << format("<alt 0x%" PRIx64 ">", uvalue);
    break;

    // All DW_FORM_indirect attributes should be resolved prior to calling
    // this function
  case DW_FORM_indirect:
    OS << "DW_FORM_indirect";
    break;

    // Should be formatted to 64-bit for DWARF64.
  case DW_FORM_sec_offset:
    OS << format("0x%08x", (uint32_t)uvalue);
    break;

  default:
    OS << format("DW_FORM(0x%4.4x)", Form);
    break;
  }

  if (cu_relative_offset) {
    OS << " => {";
    WithColor(OS, syntax::Address).get()
      << format("0x%8.8" PRIx64, uvalue + (cu ? cu->getOffset() : 0));
    OS << "}";
  }
}

void DWARFFormValue::dumpString(raw_ostream &OS, const DWARFUnit *U) const {
  Optional<const char *> DbgStr = getAsCString(U);
  if (DbgStr.hasValue()) {
    raw_ostream &COS = WithColor(OS, syntax::String);
    COS << '"';
    COS.write_escaped(DbgStr.getValue());
    COS << '"';
  }
}

Optional<const char *> DWARFFormValue::getAsCString(const DWARFUnit *U) const {
  if (!isFormClass(FC_String))
    return None;
  if (Form == DW_FORM_string)
    return Value.cstr;
  // FIXME: Add support for DW_FORM_GNU_strp_alt
  if (Form == DW_FORM_GNU_strp_alt || U == nullptr)
    return None;
  uint32_t Offset = Value.uval;
  if (Form == DW_FORM_GNU_str_index) {
    uint32_t StrOffset;
    if (!U->getStringOffsetSectionItem(Offset, StrOffset))
      return None;
    Offset = StrOffset;
  }
  if (const char *Str = U->getStringExtractor().getCStr(&Offset)) {
    return Str;
  }
  return None;
}

Optional<uint64_t> DWARFFormValue::getAsAddress(const DWARFUnit *U) const {
  if (!isFormClass(FC_Address))
    return None;
  if (Form == DW_FORM_GNU_addr_index) {
    uint32_t Index = Value.uval;
    uint64_t Result;
    if (!U || !U->getAddrOffsetSectionItem(Index, Result))
      return None;
    return Result;
  }
  return Value.uval;
}

Optional<uint64_t> DWARFFormValue::getAsReference(const DWARFUnit *U) const {
  if (!isFormClass(FC_Reference))
    return None;
  switch (Form) {
  case DW_FORM_ref1:
  case DW_FORM_ref2:
  case DW_FORM_ref4:
  case DW_FORM_ref8:
  case DW_FORM_ref_udata:
    if (!U)
      return None;
    return Value.uval + U->getOffset();
  case DW_FORM_ref_addr:
    return Value.uval;
  // FIXME: Add proper support for DW_FORM_ref_sig8 and DW_FORM_GNU_ref_alt.
  default:
    return None;
  }
}

Optional<uint64_t> DWARFFormValue::getAsSectionOffset() const {
  if (!isFormClass(FC_SectionOffset))
    return None;
  return Value.uval;
}

Optional<uint64_t> DWARFFormValue::getAsUnsignedConstant() const {
  if ((!isFormClass(FC_Constant) && !isFormClass(FC_Flag))
      || Form == DW_FORM_sdata)
    return None;
  return Value.uval;
}

Optional<int64_t> DWARFFormValue::getAsSignedConstant() const {
  if ((!isFormClass(FC_Constant) && !isFormClass(FC_Flag)) ||
      (Form == DW_FORM_udata && uint64_t(std::numeric_limits<int64_t>::max()) < Value.uval))
    return None;
  switch (Form) {
  case DW_FORM_data4:
    return int32_t(Value.uval);
  case DW_FORM_data2:
    return int16_t(Value.uval);
  case DW_FORM_data1:
    return int8_t(Value.uval);
  case DW_FORM_sdata:
  case DW_FORM_data8:
  default:
    return Value.sval;
  }
}

Optional<ArrayRef<uint8_t>> DWARFFormValue::getAsBlock() const {
  if (!isFormClass(FC_Block) && !isFormClass(FC_Exprloc))
    return None;
  return makeArrayRef(Value.data, Value.uval);
}

@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d26 54
a110 211
namespace {

/// A helper class that can be used in DWARFFormValue.cpp functions that need
/// to know the byte size of DW_FORM values that vary in size depending on the
/// DWARF version, address byte size, or DWARF32 or DWARF64.
class FormSizeHelper {
  uint16_t Version;
  uint8_t AddrSize;
  llvm::dwarf::DwarfFormat Format;

public:
  FormSizeHelper(uint16_t V, uint8_t A, llvm::dwarf::DwarfFormat F)
  : Version(V), AddrSize(A), Format(F) {}
  uint8_t getAddressByteSize() const { return AddrSize; }
  uint8_t getRefAddrByteSize() const {
    if (Version == 2)
      return AddrSize;
    return getDwarfOffsetByteSize();
  }
  uint8_t getDwarfOffsetByteSize() const {
    switch (Format) {
      case dwarf::DwarfFormat::DWARF32:
        return 4;
      case dwarf::DwarfFormat::DWARF64:
        return 8;
    }
    llvm_unreachable("Invalid Format value");
  }
};

} // end anonymous namespace

template <class T>
static Optional<uint8_t> getFixedByteSize(dwarf::Form Form, const T *U) {
  switch (Form) {
    case DW_FORM_addr:
      if (U)
        return U->getAddressByteSize();
      return None;

    case DW_FORM_block:          // ULEB128 length L followed by L bytes.
    case DW_FORM_block1:         // 1 byte length L followed by L bytes.
    case DW_FORM_block2:         // 2 byte length L followed by L bytes.
    case DW_FORM_block4:         // 4 byte length L followed by L bytes.
    case DW_FORM_string:         // C-string with null terminator.
    case DW_FORM_sdata:          // SLEB128.
    case DW_FORM_udata:          // ULEB128.
    case DW_FORM_ref_udata:      // ULEB128.
    case DW_FORM_indirect:       // ULEB128.
    case DW_FORM_exprloc:        // ULEB128 length L followed by L bytes.
    case DW_FORM_strx:           // ULEB128.
    case DW_FORM_addrx:          // ULEB128.
    case DW_FORM_loclistx:       // ULEB128.
    case DW_FORM_rnglistx:       // ULEB128.
    case DW_FORM_GNU_addr_index: // ULEB128.
    case DW_FORM_GNU_str_index:  // ULEB128.
      return None;

    case DW_FORM_ref_addr:
      if (U)
        return U->getRefAddrByteSize();
      return None;

    case DW_FORM_flag:
    case DW_FORM_data1:
    case DW_FORM_ref1:
      return 1;

    case DW_FORM_data2:
    case DW_FORM_ref2:
      return 2;

    case DW_FORM_data4:
    case DW_FORM_ref4:
      return 4;

    case DW_FORM_strp:
    case DW_FORM_GNU_ref_alt:
    case DW_FORM_GNU_strp_alt:
    case DW_FORM_line_strp:
    case DW_FORM_sec_offset:
    case DW_FORM_strp_sup:
    case DW_FORM_ref_sup:
      if (U)
        return U->getDwarfOffsetByteSize();
      return None;

    case DW_FORM_data8:
    case DW_FORM_ref8:
    case DW_FORM_ref_sig8:
      return 8;

    case DW_FORM_flag_present:
      return 0;

    case DW_FORM_data16:
      return 16;

    case DW_FORM_implicit_const:
      // The implicit value is stored in the abbreviation as a SLEB128, and
      // there no data in debug info.
      return 0;

    default:
      llvm_unreachable("Handle this form in this switch statement");
  }
  return None;
}

template <class T>
static bool skipFormValue(dwarf::Form Form, const DataExtractor &DebugInfoData,
                          uint32_t *OffsetPtr, const T *U) {
  bool Indirect = false;
  do {
    switch (Form) {
        // Blocks of inlined data that have a length field and the data bytes
        // inlined in the .debug_info.
      case DW_FORM_exprloc:
      case DW_FORM_block: {
        uint64_t size = DebugInfoData.getULEB128(OffsetPtr);
        *OffsetPtr += size;
        return true;
      }
      case DW_FORM_block1: {
        uint8_t size = DebugInfoData.getU8(OffsetPtr);
        *OffsetPtr += size;
        return true;
      }
      case DW_FORM_block2: {
        uint16_t size = DebugInfoData.getU16(OffsetPtr);
        *OffsetPtr += size;
        return true;
      }
      case DW_FORM_block4: {
        uint32_t size = DebugInfoData.getU32(OffsetPtr);
        *OffsetPtr += size;
        return true;
      }

        // Inlined NULL terminated C-strings.
      case DW_FORM_string:
        DebugInfoData.getCStr(OffsetPtr);
        return true;

      case DW_FORM_addr:
      case DW_FORM_ref_addr:
      case DW_FORM_flag_present:
      case DW_FORM_data1:
      case DW_FORM_data2:
      case DW_FORM_data4:
      case DW_FORM_data8:
      case DW_FORM_flag:
      case DW_FORM_ref1:
      case DW_FORM_ref2:
      case DW_FORM_ref4:
      case DW_FORM_ref8:
      case DW_FORM_ref_sig8:
      case DW_FORM_ref_sup:
      case DW_FORM_sec_offset:
      case DW_FORM_strp:
      case DW_FORM_strp_sup:
      case DW_FORM_line_strp:
      case DW_FORM_GNU_ref_alt:
      case DW_FORM_GNU_strp_alt:
        if (Optional<uint8_t> FixedSize = ::getFixedByteSize(Form, U)) {
          *OffsetPtr += *FixedSize;
          return true;
        }
        return false;

        // signed or unsigned LEB 128 values.
      case DW_FORM_sdata:
        DebugInfoData.getSLEB128(OffsetPtr);
        return true;

      case DW_FORM_udata:
      case DW_FORM_ref_udata:
      case DW_FORM_strx:
      case DW_FORM_addrx:
      case DW_FORM_loclistx:
      case DW_FORM_rnglistx:
      case DW_FORM_GNU_addr_index:
      case DW_FORM_GNU_str_index:
        DebugInfoData.getULEB128(OffsetPtr);
        return true;
        
      case DW_FORM_indirect:
        Indirect = true;
        Form = static_cast<dwarf::Form>(DebugInfoData.getULEB128(OffsetPtr));
        break;
        
      default:
        return false;
    }
  } while (Indirect);
  return true;
}

Optional<uint8_t> DWARFFormValue::getFixedByteSize(dwarf::Form Form,
                                                   const DWARFUnit *U) {
  return ::getFixedByteSize(Form, U);
}

Optional<uint8_t>
DWARFFormValue::getFixedByteSize(dwarf::Form Form, uint16_t Version,
                                 uint8_t AddrSize,
                                 llvm::dwarf::DwarfFormat Format) {
  FormSizeHelper FSH(Version, AddrSize, Format);
  return ::getFixedByteSize(Form, &FSH);
}

a125 4
  case DW_FORM_implicit_const:
    return (FC == FC_Constant);
  default:
    break;
d134 1
a134 2
bool DWARFFormValue::extractValue(const DataExtractor &data, 
                                  uint32_t *offset_ptr,
a135 1
  U = cu;
d146 1
a146 1
      if (!U)
d150 6
a155 5
              ? U->getAddressByteSize()
              : U->getRefAddrByteSize();
      RelocAddrMap::const_iterator AI = U->getRelocMap()->find(*offset_ptr);
      if (AI != U->getRelocMap()->end()) {
        Value.uval = data.getUnsigned(offset_ptr, AddrSize) + AI->second.second;
d189 1
a189 1
      if (!U)
d191 2
a192 2
      RelocAddrMap::const_iterator AI = U->getRelocMap()->find(*offset_ptr-4);
      if (AI != U->getRelocMap()->end())
d211 1
a211 1
      Form = static_cast<dwarf::Form>(data.getULEB128(offset_ptr));
d214 1
a215 1
    case DW_FORM_sec_offset:
d217 8
a224 10
    case DW_FORM_GNU_strp_alt:
    case DW_FORM_line_strp:
    case DW_FORM_strp_sup:
    case DW_FORM_ref_sup: {
      if (!U)
        return false;
      RelocAddrMap::const_iterator AI = U->getRelocMap()->find(*offset_ptr);
      uint8_t Size = U->getDwarfOffsetByteSize();
      Value.uval = data.getUnsigned(offset_ptr, Size);
      if (AI != U->getRelocMap()->end())
d255 4
a258 3
bool DWARFFormValue::skipValue(DataExtractor DebugInfoData,
                               uint32_t *offset_ptr, const DWARFUnit *U) const {
  return DWARFFormValue::skipValue(Form, DebugInfoData, offset_ptr, U);
d261 5
a265 3
bool DWARFFormValue::skipValue(dwarf::Form form, DataExtractor DebugInfoData,
                               uint32_t *offset_ptr, const DWARFUnit *U) {
  return skipFormValue(form, DebugInfoData, offset_ptr, U);
d267 29
d297 71
a367 6
bool DWARFFormValue::skipValue(dwarf::Form form, DataExtractor DebugInfoData,
                               uint32_t *offset_ptr, uint16_t Version,
                               uint8_t AddrSize,
                               llvm::dwarf::DwarfFormat Format) {
  FormSizeHelper FSH(Version, AddrSize, Format);
  return skipFormValue(form, DebugInfoData, offset_ptr, &FSH);
d371 1
a371 1
DWARFFormValue::dump(raw_ostream &OS) const {
d380 1
a380 3
    if (U == nullptr)
      OS << "<invalid dwarf unit>";
    else if (U->getAddrOffsetSectionItem(uvalue, Address))
d431 1
a431 1
    dumpString(OS);
d436 1
a436 1
    dumpString(OS);
d441 1
a441 1
    dumpString(OS);
d490 1
a490 1
      << format("0x%8.8" PRIx64, uvalue + (U ? U->getOffset() : 0));
d495 2
a496 2
void DWARFFormValue::dumpString(raw_ostream &OS) const {
  Optional<const char *> DbgStr = getAsCString();
d505 1
a505 1
Optional<const char *> DWARFFormValue::getAsCString() const {
d526 1
a526 1
Optional<uint64_t> DWARFFormValue::getAsAddress() const {
d539 1
a539 1
Optional<uint64_t> DWARFFormValue::getAsReference() const {
a551 2
  case DW_FORM_ref_sig8:
  case DW_FORM_GNU_ref_alt:
d553 1
a593 12
}

Optional<uint64_t> DWARFFormValue::getAsCStringOffset() const {
  if (!isFormClass(FC_String) && Form == DW_FORM_string)
    return None;
  return Value.uval;
}

Optional<uint64_t> DWARFFormValue::getAsReferenceUVal() const {
  if (!isFormClass(FC_Reference))
    return None;
  return Value.uval;
@


1.1.1.3
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@d1 1
a1 1
//===- DWARFFormValue.cpp -------------------------------------------------===//
a9 1
#include "llvm/DebugInfo/DWARF/DWARFFormValue.h"
a11 2
#include "llvm/ADT/None.h"
#include "llvm/ADT/Optional.h"
d13 1
a13 1
#include "llvm/BinaryFormat/Dwarf.h"
d15 3
a17 3
#include "llvm/DebugInfo/DWARF/DWARFRelocMap.h"
#include "llvm/DebugInfo/DWARF/DWARFUnit.h"
#include "llvm/Support/ErrorHandling.h"
d20 1
a20 2
#include <cinttypes>
#include <cstdint>
a21 1

d27 58
a84 28
    DWARFFormValue::FC_Unknown,  // 0x0
    DWARFFormValue::FC_Address,  // 0x01 DW_FORM_addr
    DWARFFormValue::FC_Unknown,  // 0x02 unused
    DWARFFormValue::FC_Block,    // 0x03 DW_FORM_block2
    DWARFFormValue::FC_Block,    // 0x04 DW_FORM_block4
    DWARFFormValue::FC_Constant, // 0x05 DW_FORM_data2
    // --- These can be FC_SectionOffset in DWARF3 and below:
    DWARFFormValue::FC_Constant, // 0x06 DW_FORM_data4
    DWARFFormValue::FC_Constant, // 0x07 DW_FORM_data8
    // ---
    DWARFFormValue::FC_String,        // 0x08 DW_FORM_string
    DWARFFormValue::FC_Block,         // 0x09 DW_FORM_block
    DWARFFormValue::FC_Block,         // 0x0a DW_FORM_block1
    DWARFFormValue::FC_Constant,      // 0x0b DW_FORM_data1
    DWARFFormValue::FC_Flag,          // 0x0c DW_FORM_flag
    DWARFFormValue::FC_Constant,      // 0x0d DW_FORM_sdata
    DWARFFormValue::FC_String,        // 0x0e DW_FORM_strp
    DWARFFormValue::FC_Constant,      // 0x0f DW_FORM_udata
    DWARFFormValue::FC_Reference,     // 0x10 DW_FORM_ref_addr
    DWARFFormValue::FC_Reference,     // 0x11 DW_FORM_ref1
    DWARFFormValue::FC_Reference,     // 0x12 DW_FORM_ref2
    DWARFFormValue::FC_Reference,     // 0x13 DW_FORM_ref4
    DWARFFormValue::FC_Reference,     // 0x14 DW_FORM_ref8
    DWARFFormValue::FC_Reference,     // 0x15 DW_FORM_ref_udata
    DWARFFormValue::FC_Indirect,      // 0x16 DW_FORM_indirect
    DWARFFormValue::FC_SectionOffset, // 0x17 DW_FORM_sec_offset
    DWARFFormValue::FC_Exprloc,       // 0x18 DW_FORM_exprloc
    DWARFFormValue::FC_Flag,          // 0x19 DW_FORM_flag_present
d87 4
a90 3
Optional<uint8_t>
DWARFFormValue::getFixedByteSize(dwarf::Form Form,
                                 const DWARFFormParams Params) {
d92 4
a95 21
  case DW_FORM_addr:
    assert(Params.Version && Params.AddrSize && "Invalid Params for form");
    return Params.AddrSize;

  case DW_FORM_block:          // ULEB128 length L followed by L bytes.
  case DW_FORM_block1:         // 1 byte length L followed by L bytes.
  case DW_FORM_block2:         // 2 byte length L followed by L bytes.
  case DW_FORM_block4:         // 4 byte length L followed by L bytes.
  case DW_FORM_string:         // C-string with null terminator.
  case DW_FORM_sdata:          // SLEB128.
  case DW_FORM_udata:          // ULEB128.
  case DW_FORM_ref_udata:      // ULEB128.
  case DW_FORM_indirect:       // ULEB128.
  case DW_FORM_exprloc:        // ULEB128 length L followed by L bytes.
  case DW_FORM_strx:           // ULEB128.
  case DW_FORM_addrx:          // ULEB128.
  case DW_FORM_loclistx:       // ULEB128.
  case DW_FORM_rnglistx:       // ULEB128.
  case DW_FORM_GNU_addr_index: // ULEB128.
  case DW_FORM_GNU_str_index:  // ULEB128.
    return None;
d97 17
a113 3
  case DW_FORM_ref_addr:
    assert(Params.Version && Params.AddrSize && "Invalid Params for form");
    return Params.getRefAddrByteSize();
d115 4
a118 6
  case DW_FORM_flag:
  case DW_FORM_data1:
  case DW_FORM_ref1:
  case DW_FORM_strx1:
  case DW_FORM_addrx1:
    return 1;
d120 4
a123 5
  case DW_FORM_data2:
  case DW_FORM_ref2:
  case DW_FORM_strx2:
  case DW_FORM_addrx2:
    return 2;
d125 3
a127 2
  case DW_FORM_strx3:
    return 3;
d129 3
a131 6
  case DW_FORM_data4:
  case DW_FORM_ref4:
  case DW_FORM_ref_sup4:
  case DW_FORM_strx4:
  case DW_FORM_addrx4:
    return 4;
d133 10
a142 8
  case DW_FORM_strp:
  case DW_FORM_GNU_ref_alt:
  case DW_FORM_GNU_strp_alt:
  case DW_FORM_line_strp:
  case DW_FORM_sec_offset:
  case DW_FORM_strp_sup:
    assert(Params.Version && Params.AddrSize && "Invalid Params for form");
    return Params.getDwarfOffsetByteSize();
d144 4
a147 5
  case DW_FORM_data8:
  case DW_FORM_ref8:
  case DW_FORM_ref_sig8:
  case DW_FORM_ref_sup8:
    return 8;
d149 2
a150 2
  case DW_FORM_flag_present:
    return 0;
d152 2
a153 2
  case DW_FORM_data16:
    return 16;
d155 4
a158 4
  case DW_FORM_implicit_const:
    // The implicit value is stored in the abbreviation as a SLEB128, and
    // there no data in debug info.
    return 0;
d160 2
a161 2
  default:
    llvm_unreachable("Handle this form in this switch statement");
d166 3
a168 3
bool DWARFFormValue::skipValue(dwarf::Form Form, DataExtractor DebugInfoData,
                               uint32_t *OffsetPtr,
                               const DWARFFormParams Params) {
d172 21
a192 59
    // Blocks of inlined data that have a length field and the data bytes
    // inlined in the .debug_info.
    case DW_FORM_exprloc:
    case DW_FORM_block: {
      uint64_t size = DebugInfoData.getULEB128(OffsetPtr);
      *OffsetPtr += size;
      return true;
    }
    case DW_FORM_block1: {
      uint8_t size = DebugInfoData.getU8(OffsetPtr);
      *OffsetPtr += size;
      return true;
    }
    case DW_FORM_block2: {
      uint16_t size = DebugInfoData.getU16(OffsetPtr);
      *OffsetPtr += size;
      return true;
    }
    case DW_FORM_block4: {
      uint32_t size = DebugInfoData.getU32(OffsetPtr);
      *OffsetPtr += size;
      return true;
    }

    // Inlined NULL terminated C-strings.
    case DW_FORM_string:
      DebugInfoData.getCStr(OffsetPtr);
      return true;

    case DW_FORM_addr:
    case DW_FORM_ref_addr:
    case DW_FORM_flag_present:
    case DW_FORM_data1:
    case DW_FORM_data2:
    case DW_FORM_data4:
    case DW_FORM_data8:
    case DW_FORM_flag:
    case DW_FORM_ref1:
    case DW_FORM_ref2:
    case DW_FORM_ref4:
    case DW_FORM_ref8:
    case DW_FORM_ref_sig8:
    case DW_FORM_ref_sup4:
    case DW_FORM_ref_sup8:
    case DW_FORM_strx1:
    case DW_FORM_strx2:
    case DW_FORM_strx4:
    case DW_FORM_addrx1:
    case DW_FORM_addrx2:
    case DW_FORM_addrx4:
    case DW_FORM_sec_offset:
    case DW_FORM_strp:
    case DW_FORM_strp_sup:
    case DW_FORM_line_strp:
    case DW_FORM_GNU_ref_alt:
    case DW_FORM_GNU_strp_alt:
      if (Optional<uint8_t> FixedSize =
              DWARFFormValue::getFixedByteSize(Form, Params)) {
        *OffsetPtr += *FixedSize;
a194 1
      return false;
d196 4
a199 4
    // signed or unsigned LEB 128 values.
    case DW_FORM_sdata:
      DebugInfoData.getSLEB128(OffsetPtr);
      return true;
d201 25
a225 10
    case DW_FORM_udata:
    case DW_FORM_ref_udata:
    case DW_FORM_strx:
    case DW_FORM_addrx:
    case DW_FORM_loclistx:
    case DW_FORM_rnglistx:
    case DW_FORM_GNU_addr_index:
    case DW_FORM_GNU_str_index:
      DebugInfoData.getULEB128(OffsetPtr);
      return true;
d227 4
a230 4
    case DW_FORM_indirect:
      Indirect = true;
      Form = static_cast<dwarf::Form>(DebugInfoData.getULEB128(OffsetPtr));
      break;
d232 18
a249 2
    default:
      return false;
d255 13
a281 5
  case DW_FORM_strx:
  case DW_FORM_strx1:
  case DW_FORM_strx2:
  case DW_FORM_strx3:
  case DW_FORM_strx4:
d290 2
a291 4
  // by mistake. Also accept DW_FORM_strp since this is .debug_str section
  // offset.
  return (Form == DW_FORM_data4 || Form == DW_FORM_data8 ||
          Form == DW_FORM_strp) &&
d295 6
a300 5
bool DWARFFormValue::extractValue(const DWARFDataExtractor &Data,
                                  uint32_t *OffsetPtr, const DWARFUnit *CU) {
  U = CU;
  bool Indirect = false;
  bool IsBlock = false;
d305 1
a305 1
    Indirect = false;
d311 9
a319 3
      uint16_t Size = (Form == DW_FORM_addr) ? U->getAddressByteSize()
                                             : U->getRefAddrByteSize();
      Value.uval = Data.getRelocatedValue(Size, OffsetPtr, &Value.SectionIndex);
d324 2
a325 2
      Value.uval = Data.getULEB128(OffsetPtr);
      IsBlock = true;
d328 2
a329 2
      Value.uval = Data.getU8(OffsetPtr);
      IsBlock = true;
d332 2
a333 2
      Value.uval = Data.getU16(OffsetPtr);
      IsBlock = true;
d336 2
a337 2
      Value.uval = Data.getU32(OffsetPtr);
      IsBlock = true;
d342 1
a342 3
    case DW_FORM_strx1:
    case DW_FORM_addrx1:
      Value.uval = Data.getU8(OffsetPtr);
d346 1
a346 6
    case DW_FORM_strx2:
    case DW_FORM_addrx2:
      Value.uval = Data.getU16(OffsetPtr);
      break;
    case DW_FORM_strx3:
      Value.uval = Data.getU24(OffsetPtr);
d349 7
a355 5
    case DW_FORM_ref4:
    case DW_FORM_ref_sup4:
    case DW_FORM_strx4:
    case DW_FORM_addrx4:
      Value.uval = Data.getRelocatedValue(4, OffsetPtr);
d357 1
d360 1
a360 2
    case DW_FORM_ref_sup8:
      Value.uval = Data.getU64(OffsetPtr);
d363 1
a363 1
      Value.sval = Data.getSLEB128(OffsetPtr);
d367 1
a367 1
      Value.uval = Data.getULEB128(OffsetPtr);
d370 1
a370 1
      Value.cstr = Data.getCStr(OffsetPtr);
d373 2
a374 2
      Form = static_cast<dwarf::Form>(Data.getULEB128(OffsetPtr));
      Indirect = true;
d381 2
a382 1
    case DW_FORM_strp_sup: {
d385 5
a389 2
      Value.uval =
          Data.getRelocatedValue(U->getDwarfOffsetByteSize(), OffsetPtr);
d396 1
a396 1
      Value.uval = Data.getU64(OffsetPtr);
d400 1
a400 2
    case DW_FORM_strx:
      Value.uval = Data.getULEB128(OffsetPtr);
d403 1
a403 3
      // DWARFFormValue::skipValue() will have caught this and caused all
      // DWARF DIEs to fail to be parsed, so this code is not be reachable.
      llvm_unreachable("unsupported form");
d405 1
a405 1
  } while (Indirect);
d407 2
a408 2
  if (IsBlock) {
    StringRef Str = Data.getData().substr(*OffsetPtr, Value.uval);
d410 3
a412 3
    if (!Str.empty()) {
      Value.data = reinterpret_cast<const uint8_t *>(Str.data());
      *OffsetPtr += Value.uval;
d419 22
a440 3
void DWARFFormValue::dump(raw_ostream &OS) const {
  uint64_t UValue = Value.uval;
  bool CURelativeOffset = false;
d443 1
a443 3
  case DW_FORM_addr:
    OS << format("0x%016" PRIx64, UValue);
    break;
d445 1
a445 1
    OS << format(" indexed (%8.8x) address = ", (uint32_t)UValue);
d449 1
a449 1
    else if (U->getAddrOffsetSectionItem(UValue, Address))
d455 1
a455 3
  case DW_FORM_flag_present:
    OS << "true";
    break;
d457 3
a459 9
  case DW_FORM_data1:
    OS << format("0x%02x", (uint8_t)UValue);
    break;
  case DW_FORM_data2:
    OS << format("0x%04x", (uint16_t)UValue);
    break;
  case DW_FORM_data4:
    OS << format("0x%08x", (uint32_t)UValue);
    break;
d461 1
a461 3
  case DW_FORM_data8:
    OS << format("0x%016" PRIx64, UValue);
    break;
d472 1
a472 1
    if (UValue > 0) {
d475 5
a479 14
      case DW_FORM_block:
        OS << format("<0x%" PRIx64 "> ", UValue);
        break;
      case DW_FORM_block1:
        OS << format("<0x%2.2x> ", (uint8_t)UValue);
        break;
      case DW_FORM_block2:
        OS << format("<0x%4.4x> ", (uint16_t)UValue);
        break;
      case DW_FORM_block4:
        OS << format("<0x%8.8x> ", (uint32_t)UValue);
        break;
      default:
        break;
d482 7
a488 7
      const uint8_t *DataPtr = Value.data;
      if (DataPtr) {
        // UValue contains size of block
        const uint8_t *EndDataPtr = DataPtr + UValue;
        while (DataPtr < EndDataPtr) {
          OS << format("%2.2x ", *DataPtr);
          ++DataPtr;
d490 2
a491 1
      } else
d496 4
a499 8
  case DW_FORM_sdata:
    OS << Value.sval;
    break;
  case DW_FORM_udata:
    OS << Value.uval;
    break;
  case DW_FORM_strp:
    OS << format(" .debug_str[0x%8.8x] = ", (uint32_t)UValue);
d502 3
a504 7
  case DW_FORM_strx:
  case DW_FORM_strx1:
  case DW_FORM_strx2:
  case DW_FORM_strx3:
  case DW_FORM_strx4:
  case DW_FORM_GNU_str_index:
    OS << format(" indexed (%8.8x) string = ", (uint32_t)UValue);
d507 3
a509 2
  case DW_FORM_GNU_strp_alt:
    OS << format("alt indirect string, offset: 0x%" PRIx64 "", UValue);
d512 1
d514 1
a514 1
    OS << format("0x%016" PRIx64, UValue);
d517 2
a518 2
    CURelativeOffset = true;
    OS << format("cu + 0x%2.2x", (uint8_t)UValue);
d521 2
a522 2
    CURelativeOffset = true;
    OS << format("cu + 0x%4.4x", (uint16_t)UValue);
d525 2
a526 2
    CURelativeOffset = true;
    OS << format("cu + 0x%4.4x", (uint32_t)UValue);
d529 2
a530 2
    CURelativeOffset = true;
    OS << format("cu + 0x%8.8" PRIx64, UValue);
d533 2
a534 2
    CURelativeOffset = true;
    OS << format("cu + 0x%" PRIx64, UValue);
d537 1
a537 1
    OS << format("<alt 0x%" PRIx64 ">", UValue);
d540 2
a541 2
  // All DW_FORM_indirect attributes should be resolved prior to calling
  // this function
d546 1
a546 1
  // Should be formatted to 64-bit for DWARF64.
d548 1
a548 1
    OS << format("0x%08x", (uint32_t)UValue);
d556 1
a556 1
  if (CURelativeOffset) {
d559 1
a559 1
        << format("0x%8.8" PRIx64, UValue + (U ? U->getOffset() : 0));
d583 2
a584 4
  if (Form == DW_FORM_GNU_str_index || Form == DW_FORM_strx ||
      Form == DW_FORM_strx1 || Form == DW_FORM_strx2 || Form == DW_FORM_strx3 ||
      Form == DW_FORM_strx4) {
    uint64_t StrOffset;
d636 2
a637 2
  if ((!isFormClass(FC_Constant) && !isFormClass(FC_Flag)) ||
      Form == DW_FORM_sdata)
d644 1
a644 2
      (Form == DW_FORM_udata &&
       uint64_t(std::numeric_limits<int64_t>::max()) < Value.uval))
d677 1
@


