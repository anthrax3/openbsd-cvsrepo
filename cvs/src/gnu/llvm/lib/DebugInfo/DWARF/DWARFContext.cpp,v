head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.4
	OPENBSD_6_2:1.1.1.3.0.2
	OPENBSD_6_2_BASE:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.4
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.03;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.35;	author patrick;	state Exp;
branches;
next	1.1.1.4;
commitid	so2WA7LCP6wbxtYl;

1.1.1.4
date	2017.10.04.20.28.09;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- DWARFContext.cpp --------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "llvm/DebugInfo/DWARF/DWARFContext.h"
#include "llvm/ADT/SmallString.h"
#include "llvm/ADT/StringSwitch.h"
#include "llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h"
#include "llvm/DebugInfo/DWARF/DWARFDebugArangeSet.h"
#include "llvm/DebugInfo/DWARF/DWARFUnitIndex.h"
#include "llvm/Support/Compression.h"
#include "llvm/Support/Dwarf.h"
#include "llvm/Support/Format.h"
#include "llvm/Support/Path.h"
#include "llvm/Support/raw_ostream.h"
#include <algorithm>
using namespace llvm;
using namespace dwarf;
using namespace object;

#define DEBUG_TYPE "dwarf"

typedef DWARFDebugLine::LineTable DWARFLineTable;
typedef DILineInfoSpecifier::FileLineInfoKind FileLineInfoKind;
typedef DILineInfoSpecifier::FunctionNameKind FunctionNameKind;

static void dumpPubSection(raw_ostream &OS, StringRef Name, StringRef Data,
                           bool LittleEndian, bool GnuStyle) {
  OS << "\n." << Name << " contents:\n";
  DataExtractor pubNames(Data, LittleEndian, 0);
  uint32_t offset = 0;
  while (pubNames.isValidOffset(offset)) {
    OS << "length = " << format("0x%08x", pubNames.getU32(&offset));
    OS << " version = " << format("0x%04x", pubNames.getU16(&offset));
    OS << " unit_offset = " << format("0x%08x", pubNames.getU32(&offset));
    OS << " unit_size = " << format("0x%08x", pubNames.getU32(&offset)) << '\n';
    if (GnuStyle)
      OS << "Offset     Linkage  Kind     Name\n";
    else
      OS << "Offset     Name\n";

    while (offset < Data.size()) {
      uint32_t dieRef = pubNames.getU32(&offset);
      if (dieRef == 0)
        break;
      OS << format("0x%8.8x ", dieRef);
      if (GnuStyle) {
        PubIndexEntryDescriptor desc(pubNames.getU8(&offset));
        OS << format("%-8s", dwarf::GDBIndexEntryLinkageString(desc.Linkage))
           << ' ' << format("%-8s", dwarf::GDBIndexEntryKindString(desc.Kind))
           << ' ';
      }
      OS << '\"' << pubNames.getCStr(&offset) << "\"\n";
    }
  }
}

static void dumpAccelSection(raw_ostream &OS, StringRef Name,
                             const DWARFSection& Section, StringRef StringSection,
                             bool LittleEndian) {
  DataExtractor AccelSection(Section.Data, LittleEndian, 0);
  DataExtractor StrData(StringSection, LittleEndian, 0);
  OS << "\n." << Name << " contents:\n";
  DWARFAcceleratorTable Accel(AccelSection, StrData, Section.Relocs);
  if (!Accel.extract())
    return;
  Accel.dump(OS);
}

void DWARFContext::dump(raw_ostream &OS, DIDumpType DumpType) {
  if (DumpType == DIDT_All || DumpType == DIDT_Abbrev) {
    OS << ".debug_abbrev contents:\n";
    getDebugAbbrev()->dump(OS);
  }

  if (DumpType == DIDT_All || DumpType == DIDT_AbbrevDwo)
    if (const DWARFDebugAbbrev *D = getDebugAbbrevDWO()) {
      OS << "\n.debug_abbrev.dwo contents:\n";
      D->dump(OS);
    }

  if (DumpType == DIDT_All || DumpType == DIDT_Info) {
    OS << "\n.debug_info contents:\n";
    for (const auto &CU : compile_units())
      CU->dump(OS);
  }

  if ((DumpType == DIDT_All || DumpType == DIDT_InfoDwo) &&
      getNumDWOCompileUnits()) {
    OS << "\n.debug_info.dwo contents:\n";
    for (const auto &DWOCU : dwo_compile_units())
      DWOCU->dump(OS);
  }

  if ((DumpType == DIDT_All || DumpType == DIDT_Types) && getNumTypeUnits()) {
    OS << "\n.debug_types contents:\n";
    for (const auto &TUS : type_unit_sections())
      for (const auto &TU : TUS)
        TU->dump(OS);
  }

  if ((DumpType == DIDT_All || DumpType == DIDT_TypesDwo) &&
      getNumDWOTypeUnits()) {
    OS << "\n.debug_types.dwo contents:\n";
    for (const auto &DWOTUS : dwo_type_unit_sections())
      for (const auto &DWOTU : DWOTUS)
        DWOTU->dump(OS);
  }

  if (DumpType == DIDT_All || DumpType == DIDT_Loc) {
    OS << "\n.debug_loc contents:\n";
    getDebugLoc()->dump(OS);
  }

  if (DumpType == DIDT_All || DumpType == DIDT_LocDwo) {
    OS << "\n.debug_loc.dwo contents:\n";
    getDebugLocDWO()->dump(OS);
  }

  if (DumpType == DIDT_All || DumpType == DIDT_Frames) {
    OS << "\n.debug_frame contents:\n";
    getDebugFrame()->dump(OS);
  }

  if (DumpType == DIDT_All || DumpType == DIDT_Macro) {
    OS << "\n.debug_macinfo contents:\n";
    getDebugMacro()->dump(OS);
  }

  uint32_t offset = 0;
  if (DumpType == DIDT_All || DumpType == DIDT_Aranges) {
    OS << "\n.debug_aranges contents:\n";
    DataExtractor arangesData(getARangeSection(), isLittleEndian(), 0);
    DWARFDebugArangeSet set;
    while (set.extract(arangesData, &offset))
      set.dump(OS);
  }

  uint8_t savedAddressByteSize = 0;
  if (DumpType == DIDT_All || DumpType == DIDT_Line) {
    OS << "\n.debug_line contents:\n";
    for (const auto &CU : compile_units()) {
      savedAddressByteSize = CU->getAddressByteSize();
      const auto *CUDIE = CU->getUnitDIE();
      if (CUDIE == nullptr)
        continue;
      unsigned stmtOffset = CUDIE->getAttributeValueAsSectionOffset(
          CU.get(), DW_AT_stmt_list, -1U);
      if (stmtOffset != -1U) {
        DataExtractor lineData(getLineSection().Data, isLittleEndian(),
                               savedAddressByteSize);
        DWARFDebugLine::LineTable LineTable;
        LineTable.parse(lineData, &getLineSection().Relocs, &stmtOffset);
        LineTable.dump(OS);
      }
    }
  }

  if (DumpType == DIDT_All || DumpType == DIDT_CUIndex) {
    OS << "\n.debug_cu_index contents:\n";
    getCUIndex().dump(OS);
  }

  if (DumpType == DIDT_All || DumpType == DIDT_TUIndex) {
    OS << "\n.debug_tu_index contents:\n";
    getTUIndex().dump(OS);
  }

  if (DumpType == DIDT_All || DumpType == DIDT_LineDwo) {
    OS << "\n.debug_line.dwo contents:\n";
    unsigned stmtOffset = 0;
    DataExtractor lineData(getLineDWOSection().Data, isLittleEndian(),
                           savedAddressByteSize);
    DWARFDebugLine::LineTable LineTable;
    while (LineTable.Prologue.parse(lineData, &stmtOffset)) {
      LineTable.dump(OS);
      LineTable.clear();
    }
  }

  if (DumpType == DIDT_All || DumpType == DIDT_Str) {
    OS << "\n.debug_str contents:\n";
    DataExtractor strData(getStringSection(), isLittleEndian(), 0);
    offset = 0;
    uint32_t strOffset = 0;
    while (const char *s = strData.getCStr(&offset)) {
      OS << format("0x%8.8x: \"%s\"\n", strOffset, s);
      strOffset = offset;
    }
  }

  if ((DumpType == DIDT_All || DumpType == DIDT_StrDwo) &&
      !getStringDWOSection().empty()) {
    OS << "\n.debug_str.dwo contents:\n";
    DataExtractor strDWOData(getStringDWOSection(), isLittleEndian(), 0);
    offset = 0;
    uint32_t strDWOOffset = 0;
    while (const char *s = strDWOData.getCStr(&offset)) {
      OS << format("0x%8.8x: \"%s\"\n", strDWOOffset, s);
      strDWOOffset = offset;
    }
  }

  if (DumpType == DIDT_All || DumpType == DIDT_Ranges) {
    OS << "\n.debug_ranges contents:\n";
    // In fact, different compile units may have different address byte
    // sizes, but for simplicity we just use the address byte size of the last
    // compile unit (there is no easy and fast way to associate address range
    // list and the compile unit it describes).
    DataExtractor rangesData(getRangeSection(), isLittleEndian(),
                             savedAddressByteSize);
    offset = 0;
    DWARFDebugRangeList rangeList;
    while (rangeList.extract(rangesData, &offset))
      rangeList.dump(OS);
  }

  if (DumpType == DIDT_All || DumpType == DIDT_Pubnames)
    dumpPubSection(OS, "debug_pubnames", getPubNamesSection(),
                   isLittleEndian(), false);

  if (DumpType == DIDT_All || DumpType == DIDT_Pubtypes)
    dumpPubSection(OS, "debug_pubtypes", getPubTypesSection(),
                   isLittleEndian(), false);

  if (DumpType == DIDT_All || DumpType == DIDT_GnuPubnames)
    dumpPubSection(OS, "debug_gnu_pubnames", getGnuPubNamesSection(),
                   isLittleEndian(), true /* GnuStyle */);

  if (DumpType == DIDT_All || DumpType == DIDT_GnuPubtypes)
    dumpPubSection(OS, "debug_gnu_pubtypes", getGnuPubTypesSection(),
                   isLittleEndian(), true /* GnuStyle */);

  if ((DumpType == DIDT_All || DumpType == DIDT_StrOffsetsDwo) &&
      !getStringOffsetDWOSection().empty()) {
    OS << "\n.debug_str_offsets.dwo contents:\n";
    DataExtractor strOffsetExt(getStringOffsetDWOSection(), isLittleEndian(),
                               0);
    offset = 0;
    uint64_t size = getStringOffsetDWOSection().size();
    while (offset < size) {
      OS << format("0x%8.8x: ", offset);
      OS << format("%8.8x\n", strOffsetExt.getU32(&offset));
    }
  }

  if (DumpType == DIDT_All || DumpType == DIDT_AppleNames)
    dumpAccelSection(OS, "apple_names", getAppleNamesSection(),
                     getStringSection(), isLittleEndian());

  if (DumpType == DIDT_All || DumpType == DIDT_AppleTypes)
    dumpAccelSection(OS, "apple_types", getAppleTypesSection(),
                     getStringSection(), isLittleEndian());

  if (DumpType == DIDT_All || DumpType == DIDT_AppleNamespaces)
    dumpAccelSection(OS, "apple_namespaces", getAppleNamespacesSection(),
                     getStringSection(), isLittleEndian());

  if (DumpType == DIDT_All || DumpType == DIDT_AppleObjC)
    dumpAccelSection(OS, "apple_objc", getAppleObjCSection(),
                     getStringSection(), isLittleEndian());
}

const DWARFUnitIndex &DWARFContext::getCUIndex() {
  if (CUIndex)
    return *CUIndex;

  DataExtractor CUIndexData(getCUIndexSection(), isLittleEndian(), 0);

  CUIndex = llvm::make_unique<DWARFUnitIndex>(DW_SECT_INFO);
  CUIndex->parse(CUIndexData);
  return *CUIndex;
}

const DWARFUnitIndex &DWARFContext::getTUIndex() {
  if (TUIndex)
    return *TUIndex;

  DataExtractor TUIndexData(getTUIndexSection(), isLittleEndian(), 0);

  TUIndex = llvm::make_unique<DWARFUnitIndex>(DW_SECT_TYPES);
  TUIndex->parse(TUIndexData);
  return *TUIndex;
}

const DWARFDebugAbbrev *DWARFContext::getDebugAbbrev() {
  if (Abbrev)
    return Abbrev.get();

  DataExtractor abbrData(getAbbrevSection(), isLittleEndian(), 0);

  Abbrev.reset(new DWARFDebugAbbrev());
  Abbrev->extract(abbrData);
  return Abbrev.get();
}

const DWARFDebugAbbrev *DWARFContext::getDebugAbbrevDWO() {
  if (AbbrevDWO)
    return AbbrevDWO.get();

  DataExtractor abbrData(getAbbrevDWOSection(), isLittleEndian(), 0);
  AbbrevDWO.reset(new DWARFDebugAbbrev());
  AbbrevDWO->extract(abbrData);
  return AbbrevDWO.get();
}

const DWARFDebugLoc *DWARFContext::getDebugLoc() {
  if (Loc)
    return Loc.get();

  DataExtractor LocData(getLocSection().Data, isLittleEndian(), 0);
  Loc.reset(new DWARFDebugLoc(getLocSection().Relocs));
  // assume all compile units have the same address byte size
  if (getNumCompileUnits())
    Loc->parse(LocData, getCompileUnitAtIndex(0)->getAddressByteSize());
  return Loc.get();
}

const DWARFDebugLocDWO *DWARFContext::getDebugLocDWO() {
  if (LocDWO)
    return LocDWO.get();

  DataExtractor LocData(getLocDWOSection().Data, isLittleEndian(), 0);
  LocDWO.reset(new DWARFDebugLocDWO());
  LocDWO->parse(LocData);
  return LocDWO.get();
}

const DWARFDebugAranges *DWARFContext::getDebugAranges() {
  if (Aranges)
    return Aranges.get();

  Aranges.reset(new DWARFDebugAranges());
  Aranges->generate(this);
  return Aranges.get();
}

const DWARFDebugFrame *DWARFContext::getDebugFrame() {
  if (DebugFrame)
    return DebugFrame.get();

  // There's a "bug" in the DWARFv3 standard with respect to the target address
  // size within debug frame sections. While DWARF is supposed to be independent
  // of its container, FDEs have fields with size being "target address size",
  // which isn't specified in DWARF in general. It's only specified for CUs, but
  // .eh_frame can appear without a .debug_info section. Follow the example of
  // other tools (libdwarf) and extract this from the container (ObjectFile
  // provides this information). This problem is fixed in DWARFv4
  // See this dwarf-discuss discussion for more details:
  // http://lists.dwarfstd.org/htdig.cgi/dwarf-discuss-dwarfstd.org/2011-December/001173.html
  DataExtractor debugFrameData(getDebugFrameSection(), isLittleEndian(),
                               getAddressSize());
  DebugFrame.reset(new DWARFDebugFrame());
  DebugFrame->parse(debugFrameData);
  return DebugFrame.get();
}

const DWARFDebugMacro *DWARFContext::getDebugMacro() {
  if (Macro)
    return Macro.get();

  DataExtractor MacinfoData(getMacinfoSection(), isLittleEndian(), 0);
  Macro.reset(new DWARFDebugMacro());
  Macro->parse(MacinfoData);
  return Macro.get();
}

const DWARFLineTable *
DWARFContext::getLineTableForUnit(DWARFUnit *U) {
  if (!Line)
    Line.reset(new DWARFDebugLine(&getLineSection().Relocs));

  const auto *UnitDIE = U->getUnitDIE();
  if (UnitDIE == nullptr)
    return nullptr;

  unsigned stmtOffset =
      UnitDIE->getAttributeValueAsSectionOffset(U, DW_AT_stmt_list, -1U);
  if (stmtOffset == -1U)
    return nullptr; // No line table for this compile unit.

  stmtOffset += U->getLineTableOffset();
  // See if the line table is cached.
  if (const DWARFLineTable *lt = Line->getLineTable(stmtOffset))
    return lt;

  // We have to parse it first.
  DataExtractor lineData(U->getLineSection(), isLittleEndian(),
                         U->getAddressByteSize());
  return Line->getOrParseLineTable(lineData, stmtOffset);
}

void DWARFContext::parseCompileUnits() {
  CUs.parse(*this, getInfoSection());
}

void DWARFContext::parseTypeUnits() {
  if (!TUs.empty())
    return;
  for (const auto &I : getTypesSections()) {
    TUs.emplace_back();
    TUs.back().parse(*this, I.second);
  }
}

void DWARFContext::parseDWOCompileUnits() {
  DWOCUs.parseDWO(*this, getInfoDWOSection());
}

void DWARFContext::parseDWOTypeUnits() {
  if (!DWOTUs.empty())
    return;
  for (const auto &I : getTypesDWOSections()) {
    DWOTUs.emplace_back();
    DWOTUs.back().parseDWO(*this, I.second);
  }
}

DWARFCompileUnit *DWARFContext::getCompileUnitForOffset(uint32_t Offset) {
  parseCompileUnits();
  return CUs.getUnitForOffset(Offset);
}

DWARFCompileUnit *DWARFContext::getCompileUnitForAddress(uint64_t Address) {
  // First, get the offset of the compile unit.
  uint32_t CUOffset = getDebugAranges()->findAddress(Address);
  // Retrieve the compile unit.
  return getCompileUnitForOffset(CUOffset);
}

static bool getFunctionNameForAddress(DWARFCompileUnit *CU, uint64_t Address,
                                      FunctionNameKind Kind,
                                      std::string &FunctionName) {
  if (Kind == FunctionNameKind::None)
    return false;
  // The address may correspond to instruction in some inlined function,
  // so we have to build the chain of inlined functions and take the
  // name of the topmost function in it.
  const DWARFDebugInfoEntryInlinedChain &InlinedChain =
      CU->getInlinedChainForAddress(Address);
  if (InlinedChain.DIEs.size() == 0)
    return false;
  const DWARFDebugInfoEntryMinimal &TopFunctionDIE = InlinedChain.DIEs[0];
  if (const char *Name =
          TopFunctionDIE.getSubroutineName(InlinedChain.U, Kind)) {
    FunctionName = Name;
    return true;
  }
  return false;
}

DILineInfo DWARFContext::getLineInfoForAddress(uint64_t Address,
                                               DILineInfoSpecifier Spec) {
  DILineInfo Result;

  DWARFCompileUnit *CU = getCompileUnitForAddress(Address);
  if (!CU)
    return Result;
  getFunctionNameForAddress(CU, Address, Spec.FNKind, Result.FunctionName);
  if (Spec.FLIKind != FileLineInfoKind::None) {
    if (const DWARFLineTable *LineTable = getLineTableForUnit(CU))
      LineTable->getFileLineInfoForAddress(Address, CU->getCompilationDir(),
                                           Spec.FLIKind, Result);
  }
  return Result;
}

DILineInfoTable
DWARFContext::getLineInfoForAddressRange(uint64_t Address, uint64_t Size,
                                         DILineInfoSpecifier Spec) {
  DILineInfoTable  Lines;
  DWARFCompileUnit *CU = getCompileUnitForAddress(Address);
  if (!CU)
    return Lines;

  std::string FunctionName = "<invalid>";
  getFunctionNameForAddress(CU, Address, Spec.FNKind, FunctionName);

  // If the Specifier says we don't need FileLineInfo, just
  // return the top-most function at the starting address.
  if (Spec.FLIKind == FileLineInfoKind::None) {
    DILineInfo Result;
    Result.FunctionName = FunctionName;
    Lines.push_back(std::make_pair(Address, Result));
    return Lines;
  }

  const DWARFLineTable *LineTable = getLineTableForUnit(CU);

  // Get the index of row we're looking for in the line table.
  std::vector<uint32_t> RowVector;
  if (!LineTable->lookupAddressRange(Address, Size, RowVector))
    return Lines;

  for (uint32_t RowIndex : RowVector) {
    // Take file number and line/column from the row.
    const DWARFDebugLine::Row &Row = LineTable->Rows[RowIndex];
    DILineInfo Result;
    LineTable->getFileNameByIndex(Row.File, CU->getCompilationDir(),
                                  Spec.FLIKind, Result.FileName);
    Result.FunctionName = FunctionName;
    Result.Line = Row.Line;
    Result.Column = Row.Column;
    Lines.push_back(std::make_pair(Row.Address, Result));
  }

  return Lines;
}

DIInliningInfo
DWARFContext::getInliningInfoForAddress(uint64_t Address,
                                        DILineInfoSpecifier Spec) {
  DIInliningInfo InliningInfo;

  DWARFCompileUnit *CU = getCompileUnitForAddress(Address);
  if (!CU)
    return InliningInfo;

  const DWARFLineTable *LineTable = nullptr;
  const DWARFDebugInfoEntryInlinedChain &InlinedChain =
      CU->getInlinedChainForAddress(Address);
  if (InlinedChain.DIEs.size() == 0) {
    // If there is no DIE for address (e.g. it is in unavailable .dwo file),
    // try to at least get file/line info from symbol table.
    if (Spec.FLIKind != FileLineInfoKind::None) {
      DILineInfo Frame;
      LineTable = getLineTableForUnit(CU);
      if (LineTable &&
          LineTable->getFileLineInfoForAddress(Address, CU->getCompilationDir(),
                                               Spec.FLIKind, Frame))
        InliningInfo.addFrame(Frame);
    }
    return InliningInfo;
  }

  uint32_t CallFile = 0, CallLine = 0, CallColumn = 0;
  for (uint32_t i = 0, n = InlinedChain.DIEs.size(); i != n; i++) {
    const DWARFDebugInfoEntryMinimal &FunctionDIE = InlinedChain.DIEs[i];
    DILineInfo Frame;
    // Get function name if necessary.
    if (const char *Name =
            FunctionDIE.getSubroutineName(InlinedChain.U, Spec.FNKind))
      Frame.FunctionName = Name;
    if (Spec.FLIKind != FileLineInfoKind::None) {
      if (i == 0) {
        // For the topmost frame, initialize the line table of this
        // compile unit and fetch file/line info from it.
        LineTable = getLineTableForUnit(CU);
        // For the topmost routine, get file/line info from line table.
        if (LineTable)
          LineTable->getFileLineInfoForAddress(Address, CU->getCompilationDir(),
                                               Spec.FLIKind, Frame);
      } else {
        // Otherwise, use call file, call line and call column from
        // previous DIE in inlined chain.
        if (LineTable)
          LineTable->getFileNameByIndex(CallFile, CU->getCompilationDir(),
                                        Spec.FLIKind, Frame.FileName);
        Frame.Line = CallLine;
        Frame.Column = CallColumn;
      }
      // Get call file/line/column of a current DIE.
      if (i + 1 < n) {
        FunctionDIE.getCallerFrame(InlinedChain.U, CallFile, CallLine,
                                   CallColumn);
      }
    }
    InliningInfo.addFrame(Frame);
  }
  return InliningInfo;
}

static bool consumeCompressedDebugSectionHeader(StringRef &data,
                                                uint64_t &OriginalSize) {
  // Consume "ZLIB" prefix.
  if (!data.startswith("ZLIB"))
    return false;
  data = data.substr(4);
  // Consume uncompressed section size (big-endian 8 bytes).
  DataExtractor extractor(data, false, 8);
  uint32_t Offset = 0;
  OriginalSize = extractor.getU64(&Offset);
  if (Offset == 0)
    return false;
  data = data.substr(Offset);
  return true;
}

DWARFContextInMemory::DWARFContextInMemory(const object::ObjectFile &Obj,
    const LoadedObjectInfo *L)
    : IsLittleEndian(Obj.isLittleEndian()),
      AddressSize(Obj.getBytesInAddress()) {
  for (const SectionRef &Section : Obj.sections()) {
    StringRef name;
    Section.getName(name);
    // Skip BSS and Virtual sections, they aren't interesting.
    bool IsBSS = Section.isBSS();
    if (IsBSS)
      continue;
    bool IsVirtual = Section.isVirtual();
    if (IsVirtual)
      continue;
    StringRef data;

    section_iterator RelocatedSection = Section.getRelocatedSection();
    // Try to obtain an already relocated version of this section.
    // Else use the unrelocated section from the object file. We'll have to
    // apply relocations ourselves later.
    if (!L || !L->getLoadedSectionContents(*RelocatedSection,data))
      Section.getContents(data);

    name = name.substr(name.find_first_not_of("._")); // Skip . and _ prefixes.

    // Check if debug info section is compressed with zlib.
    if (name.startswith("zdebug_")) {
      uint64_t OriginalSize;
      if (!zlib::isAvailable() ||
          !consumeCompressedDebugSectionHeader(data, OriginalSize))
        continue;
      UncompressedSections.resize(UncompressedSections.size() + 1);
      if (zlib::uncompress(data, UncompressedSections.back(), OriginalSize) !=
          zlib::StatusOK) {
        UncompressedSections.pop_back();
        continue;
      }
      // Make data point to uncompressed section contents and save its contents.
      name = name.substr(1);
      data = UncompressedSections.back();
    }

    StringRef *SectionData =
        StringSwitch<StringRef *>(name)
            .Case("debug_info", &InfoSection.Data)
            .Case("debug_abbrev", &AbbrevSection)
            .Case("debug_loc", &LocSection.Data)
            .Case("debug_line", &LineSection.Data)
            .Case("debug_aranges", &ARangeSection)
            .Case("debug_frame", &DebugFrameSection)
            .Case("debug_str", &StringSection)
            .Case("debug_ranges", &RangeSection)
            .Case("debug_macinfo", &MacinfoSection)
            .Case("debug_pubnames", &PubNamesSection)
            .Case("debug_pubtypes", &PubTypesSection)
            .Case("debug_gnu_pubnames", &GnuPubNamesSection)
            .Case("debug_gnu_pubtypes", &GnuPubTypesSection)
            .Case("debug_info.dwo", &InfoDWOSection.Data)
            .Case("debug_abbrev.dwo", &AbbrevDWOSection)
            .Case("debug_loc.dwo", &LocDWOSection.Data)
            .Case("debug_line.dwo", &LineDWOSection.Data)
            .Case("debug_str.dwo", &StringDWOSection)
            .Case("debug_str_offsets.dwo", &StringOffsetDWOSection)
            .Case("debug_addr", &AddrSection)
            .Case("apple_names", &AppleNamesSection.Data)
            .Case("apple_types", &AppleTypesSection.Data)
            .Case("apple_namespaces", &AppleNamespacesSection.Data)
            .Case("apple_namespac", &AppleNamespacesSection.Data)
            .Case("apple_objc", &AppleObjCSection.Data)
            .Case("debug_cu_index", &CUIndexSection)
            .Case("debug_tu_index", &TUIndexSection)
            // Any more debug info sections go here.
            .Default(nullptr);
    if (SectionData) {
      *SectionData = data;
      if (name == "debug_ranges") {
        // FIXME: Use the other dwo range section when we emit it.
        RangeDWOSection = data;
      }
    } else if (name == "debug_types") {
      // Find debug_types data by section rather than name as there are
      // multiple, comdat grouped, debug_types sections.
      TypesSections[Section].Data = data;
    } else if (name == "debug_types.dwo") {
      TypesDWOSections[Section].Data = data;
    }

    if (RelocatedSection == Obj.section_end())
      continue;

    StringRef RelSecName;
    StringRef RelSecData;
    RelocatedSection->getName(RelSecName);

    // If the section we're relocating was relocated already by the JIT,
    // then we used the relocated version above, so we do not need to process
    // relocations for it now.
    if (L && L->getLoadedSectionContents(*RelocatedSection,RelSecData))
      continue;

    // In Mach-o files, the relocations do not need to be applied if
    // there is no load offset to apply. The value read at the
    // relocation point already factors in the section address
    // (actually applying the relocations will produce wrong results
    // as the section address will be added twice).
    if (!L && isa<MachOObjectFile>(&Obj))
      continue;

    RelSecName = RelSecName.substr(
        RelSecName.find_first_not_of("._")); // Skip . and _ prefixes.

    // TODO: Add support for relocations in other sections as needed.
    // Record relocations for the debug_info and debug_line sections.
    RelocAddrMap *Map = StringSwitch<RelocAddrMap*>(RelSecName)
        .Case("debug_info", &InfoSection.Relocs)
        .Case("debug_loc", &LocSection.Relocs)
        .Case("debug_info.dwo", &InfoDWOSection.Relocs)
        .Case("debug_line", &LineSection.Relocs)
        .Case("apple_names", &AppleNamesSection.Relocs)
        .Case("apple_types", &AppleTypesSection.Relocs)
        .Case("apple_namespaces", &AppleNamespacesSection.Relocs)
        .Case("apple_namespac", &AppleNamespacesSection.Relocs)
        .Case("apple_objc", &AppleObjCSection.Relocs)
        .Default(nullptr);
    if (!Map) {
      // Find debug_types relocs by section rather than name as there are
      // multiple, comdat grouped, debug_types sections.
      if (RelSecName == "debug_types")
        Map = &TypesSections[*RelocatedSection].Relocs;
      else if (RelSecName == "debug_types.dwo")
        Map = &TypesDWOSections[*RelocatedSection].Relocs;
      else
        continue;
    }

    if (Section.relocation_begin() != Section.relocation_end()) {
      uint64_t SectionSize = RelocatedSection->getSize();
      for (const RelocationRef &Reloc : Section.relocations()) {
        uint64_t Address = Reloc.getOffset();
        uint64_t Type = Reloc.getType();
        uint64_t SymAddr = 0;
        uint64_t SectionLoadAddress = 0;
        object::symbol_iterator Sym = Reloc.getSymbol();
        object::section_iterator RSec = Obj.section_end();

        // First calculate the address of the symbol or section as it appears
        // in the objct file
        if (Sym != Obj.symbol_end()) {
          ErrorOr<uint64_t> SymAddrOrErr = Sym->getAddress();
          if (std::error_code EC = SymAddrOrErr.getError()) {
            errs() << "error: failed to compute symbol address: "
                   << EC.message() << '\n';
            continue;
          }
          SymAddr = *SymAddrOrErr;
          // Also remember what section this symbol is in for later
          RSec = *Sym->getSection();
        } else if (auto *MObj = dyn_cast<MachOObjectFile>(&Obj)) {
          // MachO also has relocations that point to sections and
          // scattered relocations.
          auto RelocInfo = MObj->getRelocation(Reloc.getRawDataRefImpl());
          if (MObj->isRelocationScattered(RelocInfo)) {
            // FIXME: it's not clear how to correctly handle scattered
            // relocations.
            continue;
          } else {
            RSec = MObj->getRelocationSection(Reloc.getRawDataRefImpl());
            SymAddr = RSec->getAddress();
          }
        }

        // If we are given load addresses for the sections, we need to adjust:
        // SymAddr = (Address of Symbol Or Section in File) -
        //           (Address of Section in File) +
        //           (Load Address of Section)
        if (L != nullptr && RSec != Obj.section_end()) {
          // RSec is now either the section being targeted or the section
          // containing the symbol being targeted. In either case,
          // we need to perform the same computation.
          StringRef SecName;
          RSec->getName(SecName);
//           llvm::dbgs() << "Name: '" << SecName
//                        << "', RSec: " << RSec->getRawDataRefImpl()
//                        << ", Section: " << Section.getRawDataRefImpl() << "\n";
          SectionLoadAddress = L->getSectionLoadAddress(*RSec);
          if (SectionLoadAddress != 0)
            SymAddr += SectionLoadAddress - RSec->getAddress();
        }

        object::RelocVisitor V(Obj);
        object::RelocToApply R(V.visit(Type, Reloc, SymAddr));
        if (V.error()) {
          SmallString<32> Name;
          Reloc.getTypeName(Name);
          errs() << "error: failed to compute relocation: "
                 << Name << "\n";
          continue;
        }

        if (Address + R.Width > SectionSize) {
          errs() << "error: " << R.Width << "-byte relocation starting "
                 << Address << " bytes into section " << name << " which is "
                 << SectionSize << " bytes long.\n";
          continue;
        }
        if (R.Width > 8) {
          errs() << "error: can't handle a relocation of more than 8 bytes at "
                    "a time.\n";
          continue;
        }
        DEBUG(dbgs() << "Writing " << format("%p", R.Value)
                     << " at " << format("%p", Address)
                     << " with width " << format("%d", R.Width)
                     << "\n");
        Map->insert(std::make_pair(Address, std::make_pair(R.Width, R.Value)));
      }
    }
  }
}

void DWARFContextInMemory::anchor() { }
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@a15 2
#include "llvm/Object/MachO.h"
#include "llvm/Object/RelocVisitor.h"
a17 1
#include "llvm/Support/ELF.h"
d75 1
a75 1
void DWARFContext::dump(raw_ostream &OS, DIDumpType DumpType, bool DumpEH) {
a127 4
    if (DumpEH) {
      OS << "\n.eh_frame contents:\n";
      getEHFrame()->dump(OS);
    }
d358 1
a358 12
  DebugFrame.reset(new DWARFDebugFrame(false /* IsEH */));
  DebugFrame->parse(debugFrameData);
  return DebugFrame.get();
}

const DWARFDebugFrame *DWARFContext::getEHFrame() {
  if (EHFrame)
    return EHFrame.get();

  DataExtractor debugFrameData(getEHFrameSection(), isLittleEndian(),
                               getAddressSize());
  DebugFrame.reset(new DWARFDebugFrame(true /* IsEH */));
d578 2
a579 2
static bool consumeCompressedGnuHeader(StringRef &data,
                                       uint64_t &OriginalSize) {
a593 44
static bool consumeCompressedZLibHeader(StringRef &Data, uint64_t &OriginalSize,
                                        bool IsLE, bool Is64Bit) {
  using namespace ELF;
  uint64_t HdrSize = Is64Bit ? sizeof(Elf64_Chdr) : sizeof(Elf32_Chdr);
  if (Data.size() < HdrSize)
    return false;

  DataExtractor Extractor(Data, IsLE, 0);
  uint32_t Offset = 0;
  if (Extractor.getUnsigned(&Offset, Is64Bit ? sizeof(Elf64_Word)
                                             : sizeof(Elf32_Word)) !=
      ELFCOMPRESS_ZLIB)
    return false;

  // Skip Elf64_Chdr::ch_reserved field.
  if (Is64Bit)
    Offset += sizeof(Elf64_Word);

  OriginalSize = Extractor.getUnsigned(&Offset, Is64Bit ? sizeof(Elf64_Xword)
                                                        : sizeof(Elf32_Word));
  Data = Data.substr(HdrSize);
  return true;
}

static bool tryDecompress(StringRef &Name, StringRef &Data,
                          SmallString<32> &Out, bool ZLibStyle, bool IsLE,
                          bool Is64Bit) {
  if (!zlib::isAvailable())
    return false;

  uint64_t OriginalSize;
  bool Result =
      ZLibStyle ? consumeCompressedZLibHeader(Data, OriginalSize, IsLE, Is64Bit)
                : consumeCompressedGnuHeader(Data, OriginalSize);

  if (!Result || zlib::uncompress(Data, Out, OriginalSize) != zlib::StatusOK)
    return false;

  // gnu-style names are started from "z", consume that.
  if (!ZLibStyle)
    Name = Name.substr(1);
  return true;
}

d619 10
a628 5
    bool ZLibStyleCompressed = Section.isCompressed();
    if (ZLibStyleCompressed || name.startswith("zdebug_")) {
      SmallString<32> Out;
      if (!tryDecompress(name, data, Out, ZLibStyleCompressed, IsLittleEndian,
                         AddressSize == 8))
d630 3
a632 1
      UncompressedSections.emplace_back(std::move(Out));
a643 1
            .Case("eh_frame", &EHFrameSection)
d742 2
a743 6
          Expected<uint64_t> SymAddrOrErr = Sym->getAddress();
          if (!SymAddrOrErr) {
            std::string Buf;
            raw_string_ostream OS(Buf);
            logAllUnhandledErrors(SymAddrOrErr.takeError(), OS, "");
            OS.flush();
d745 1
a745 1
                   << Buf << '\n';
d750 1
a750 11
          auto SectOrErr = Sym->getSection();
          if (!SectOrErr) {
            std::string Buf;
            raw_string_ostream OS(Buf);
            logAllUnhandledErrors(SectOrErr.takeError(), OS, "");
            OS.flush();
            errs() << "error: failed to get symbol section: "
                   << Buf << '\n';
            continue;
          }
          RSec = *SectOrErr;
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a14 1
#include "llvm/DebugInfo/DWARF/DWARFDebugPubTable.h"
a15 1
#include "llvm/Object/Decompressor.h"
d35 31
d78 1
a78 2
void DWARFContext::dump(raw_ostream &OS, DIDumpType DumpType, bool DumpEH,
                        bool SummarizeTypes) {
d107 1
a107 1
        TU->dump(OS, SummarizeTypes);
d115 1
a115 1
        DWOTU->dump(OS, SummarizeTypes);
d156 2
a157 2
      auto CUDIE = CU->getUnitDIE();
      if (!CUDIE)
d159 3
a161 2
      if (auto StmtOffset =
              CUDIE.getAttributeValueAsSectionOffset(DW_AT_stmt_list)) {
d165 1
a165 2
        uint32_t Offset = *StmtOffset;
        LineTable.parse(lineData, &getLineSection().Relocs, &Offset);
d231 2
a232 2
    DWARFDebugPubTable(getPubNamesSection(), isLittleEndian(), false)
        .dump("debug_pubnames", OS);
d235 2
a236 2
    DWARFDebugPubTable(getPubTypesSection(), isLittleEndian(), false)
        .dump("debug_pubtypes", OS);
d239 2
a240 3
    DWARFDebugPubTable(getGnuPubNamesSection(), isLittleEndian(),
                       true /* GnuStyle */)
        .dump("debug_gnu_pubnames", OS);
d243 2
a244 3
    DWARFDebugPubTable(getGnuPubTypesSection(), isLittleEndian(),
                       true /* GnuStyle */)
        .dump("debug_gnu_pubtypes", OS);
a258 6
  if ((DumpType == DIDT_All || DumpType == DIDT_GdbIndex) &&
      !getGdbIndexSection().empty()) {
    OS << "\n.gnu_index contents:\n";
    getGdbIndex().dump(OS);
  }

a297 10
DWARFGdbIndex &DWARFContext::getGdbIndex() {
  if (GdbIndex)
    return *GdbIndex;

  DataExtractor GdbIndexData(getGdbIndexSection(), true /*LE*/, 0);
  GdbIndex = llvm::make_unique<DWARFGdbIndex>();
  GdbIndex->parse(GdbIndexData);
  return *GdbIndex;
}

d396 2
a397 2
  auto UnitDIE = U->getUnitDIE();
  if (!UnitDIE)
d400 3
a402 2
  auto Offset = UnitDIE.getAttributeValueAsSectionOffset(DW_AT_stmt_list);
  if (!Offset)
d405 1
a405 1
  uint32_t stmtOffset = *Offset + U->getLineTableOffset();
d461 4
a464 4
  // name of the topmost function in it.SmallVectorImpl<DWARFDie> &InlinedChain
  SmallVector<DWARFDie, 4> InlinedChain;
  CU->getInlinedChainForAddress(Address, InlinedChain);
  if (InlinedChain.size() == 0)
d466 3
a468 1
  if (const char *Name = InlinedChain[0].getSubroutineName(Kind)) {
d543 3
a545 3
  SmallVector<DWARFDie, 4> InlinedChain;
  CU->getInlinedChainForAddress(Address, InlinedChain);
  if (InlinedChain.size() == 0) {
d560 2
a561 2
  for (uint32_t i = 0, n = InlinedChain.size(); i != n; i++) {
    DWARFDie &FunctionDIE = InlinedChain[i];
d564 2
a565 1
    if (const char *Name = FunctionDIE.getSubroutineName(Spec.FNKind))
d587 2
a588 1
        FunctionDIE.getCallerFrame(CallFile, CallLine, CallColumn);
d596 60
d679 4
a682 5
    if (Decompressor::isCompressed(Section)) {
      Expected<Decompressor> Decompressor =
          Decompressor::create(name, data, IsLittleEndian, AddressSize == 8);
      if (!Decompressor)
        continue;
d684 2
a685 1
      if (auto Err = Decompressor->decompress(Out))
a690 5
    // Compressed sections names in GNU style starts from ".z",
    // at this point section is decompressed and we drop compression prefix.
    name = name.substr(
        name.find_first_not_of("._z")); // Skip ".", "z" and "_" prefixes.

a720 1
            .Case("gdb_index", &GdbIndexSection)
@


1.1.1.4
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@d1 1
a1 1
//===- DWARFContext.cpp ---------------------------------------------------===//
a10 1
#include "llvm/ADT/STLExtras.h"
a11 2
#include "llvm/ADT/SmallVector.h"
#include "llvm/ADT/StringRef.h"
a12 1
#include "llvm/BinaryFormat/Dwarf.h"
a13 2
#include "llvm/DebugInfo/DWARF/DWARFCompileUnit.h"
#include "llvm/DebugInfo/DWARF/DWARFDebugAbbrev.h"
a14 5
#include "llvm/DebugInfo/DWARF/DWARFDebugAranges.h"
#include "llvm/DebugInfo/DWARF/DWARFDebugFrame.h"
#include "llvm/DebugInfo/DWARF/DWARFDebugLine.h"
#include "llvm/DebugInfo/DWARF/DWARFDebugLoc.h"
#include "llvm/DebugInfo/DWARF/DWARFDebugMacro.h"
a15 5
#include "llvm/DebugInfo/DWARF/DWARFDebugRangeList.h"
#include "llvm/DebugInfo/DWARF/DWARFDie.h"
#include "llvm/DebugInfo/DWARF/DWARFFormValue.h"
#include "llvm/DebugInfo/DWARF/DWARFGdbIndex.h"
#include "llvm/DebugInfo/DWARF/DWARFSection.h"
a16 1
#include "llvm/DebugInfo/DWARF/DWARFVerifier.h"
a18 1
#include "llvm/Object/ObjectFile.h"
d20 3
a22 3
#include "llvm/Support/Casting.h"
#include "llvm/Support/DataExtractor.h"
#include "llvm/Support/Error.h"
d24 1
a24 1
#include "llvm/Support/MemoryBuffer.h"
a26 7
#include <cstdint>
#include <map>
#include <string>
#include <tuple>
#include <utility>
#include <vector>

d33 3
a35 3
using DWARFLineTable = DWARFDebugLine::LineTable;
using FileLineInfoKind = DILineInfoSpecifier::FileLineInfoKind;
using FunctionNameKind = DILineInfoSpecifier::FunctionNameKind;
d40 1
a40 1
  DWARFDataExtractor AccelSection(Section, LittleEndian, 0);
d43 1
a43 1
  DWARFAcceleratorTable Accel(AccelSection, StrData);
d49 2
a50 122
static void
dumpDWARFv5StringOffsetsSection(raw_ostream &OS, StringRef SectionName,
                                const DWARFSection &StringOffsetsSection,
                                StringRef StringSection, bool LittleEndian) {
  DWARFDataExtractor StrOffsetExt(StringOffsetsSection, LittleEndian, 0);
  uint32_t Offset = 0;
  uint64_t SectionSize = StringOffsetsSection.Data.size();

  while (Offset < SectionSize) {
    unsigned Version = 0;
    DwarfFormat Format = DWARF32;
    unsigned EntrySize = 4;
    // Perform validation and extract the segment size from the header.
    if (!StrOffsetExt.isValidOffsetForDataOfSize(Offset, 4)) {
      OS << "error: invalid contribution to string offsets table in section ."
         << SectionName << ".\n";
      return;
    }
    uint32_t ContributionStart = Offset;
    uint64_t ContributionSize = StrOffsetExt.getU32(&Offset);
    // A contribution size of 0xffffffff indicates DWARF64, with the actual size
    // in the following 8 bytes. Otherwise, the DWARF standard mandates that
    // the contribution size must be at most 0xfffffff0.
    if (ContributionSize == 0xffffffff) {
      if (!StrOffsetExt.isValidOffsetForDataOfSize(Offset, 8)) {
        OS << "error: invalid contribution to string offsets table in section ."
           << SectionName << ".\n";
        return;
      }
      Format = DWARF64;
      EntrySize = 8;
      ContributionSize = StrOffsetExt.getU64(&Offset);
    } else if (ContributionSize > 0xfffffff0) {
      OS << "error: invalid contribution to string offsets table in section ."
         << SectionName << ".\n";
      return;
    }

    // We must ensure that we don't read a partial record at the end, so we
    // validate for a multiple of EntrySize. Also, we're expecting a version
    // number and padding, which adds an additional 4 bytes.
    uint64_t ValidationSize =
        4 + ((ContributionSize + EntrySize - 1) & (-(uint64_t)EntrySize));
    if (!StrOffsetExt.isValidOffsetForDataOfSize(Offset, ValidationSize)) {
      OS << "error: contribution to string offsets table in section ."
         << SectionName << " has invalid length.\n";
      return;
    }

    Version = StrOffsetExt.getU16(&Offset);
    Offset += 2;
    OS << format("0x%8.8x: ", ContributionStart);
    OS << "Contribution size = " << ContributionSize
       << ", Version = " << Version << "\n";

    uint32_t ContributionBase = Offset;
    DataExtractor StrData(StringSection, LittleEndian, 0);
    while (Offset - ContributionBase < ContributionSize) {
      OS << format("0x%8.8x: ", Offset);
      // FIXME: We can only extract strings in DWARF32 format at the moment.
      uint64_t StringOffset =
          StrOffsetExt.getRelocatedValue(EntrySize, &Offset);
      if (Format == DWARF32) {
        uint32_t StringOffset32 = (uint32_t)StringOffset;
        OS << format("%8.8x ", StringOffset32);
        const char *S = StrData.getCStr(&StringOffset32);
        if (S)
          OS << format("\"%s\"", S);
      } else
        OS << format("%16.16" PRIx64 " ", StringOffset);
      OS << "\n";
    }
  }
}

// Dump a DWARF string offsets section. This may be a DWARF v5 formatted
// string offsets section, where each compile or type unit contributes a
// number of entries (string offsets), with each contribution preceded by
// a header containing size and version number. Alternatively, it may be a
// monolithic series of string offsets, as generated by the pre-DWARF v5
// implementation of split DWARF.
static void dumpStringOffsetsSection(raw_ostream &OS, StringRef SectionName,
                                     const DWARFSection &StringOffsetsSection,
                                     StringRef StringSection, bool LittleEndian,
                                     unsigned MaxVersion) {
  if (StringOffsetsSection.Data.empty())
    return;
  OS << "\n." << SectionName << " contents:\n";
  // If we have at least one (compile or type) unit with DWARF v5 or greater,
  // we assume that the section is formatted like a DWARF v5 string offsets
  // section.
  if (MaxVersion >= 5)
    dumpDWARFv5StringOffsetsSection(OS, SectionName, StringOffsetsSection,
                                    StringSection, LittleEndian);
  else {
    DataExtractor strOffsetExt(StringOffsetsSection.Data, LittleEndian, 0);
    uint32_t offset = 0;
    uint64_t size = StringOffsetsSection.Data.size();
    // Ensure that size is a multiple of the size of an entry.
    if (size & ((uint64_t)(sizeof(uint32_t) - 1))) {
      OS << "error: size of ." << SectionName << " is not a multiple of "
         << sizeof(uint32_t) << ".\n";
      size &= -(uint64_t)sizeof(uint32_t);
    }
    DataExtractor StrData(StringSection, LittleEndian, 0);
    while (offset < size) {
      OS << format("0x%8.8x: ", offset);
      uint32_t StringOffset = strOffsetExt.getU32(&offset);
      OS << format("%8.8x  ", StringOffset);
      const char *S = StrData.getCStr(&StringOffset);
      if (S)
        OS << format("\"%s\"", S);
      OS << "\n";
    }
  }
}

void DWARFContext::dump(raw_ostream &OS, DIDumpOptions DumpOpts) {
  DIDumpType DumpType = DumpOpts.DumpType;
  bool DumpEH = DumpOpts.DumpEH;
  bool SummarizeTypes = DumpOpts.SummarizeTypes;

d65 1
a65 1
      CU->dump(OS, DumpOpts);
d72 1
a72 1
      DWOCU->dump(OS, DumpOpts);
d131 4
a134 3
      if (auto StmtOffset = toSectionOffset(CUDIE.find(DW_AT_stmt_list))) {
        DWARFDataExtractor lineData(getLineSection(), isLittleEndian(),
                                    savedAddressByteSize);
d137 1
a137 1
        LineTable.parse(lineData, &Offset);
d156 2
a157 2
    DWARFDataExtractor lineData(getLineDWOSection(), isLittleEndian(),
                                savedAddressByteSize);
d194 2
a195 2
    DWARFDataExtractor rangesData(getRangeSection(), isLittleEndian(),
                                  savedAddressByteSize);
d220 11
a230 9
  if (DumpType == DIDT_All || DumpType == DIDT_StrOffsets)
    dumpStringOffsetsSection(OS, "debug_str_offsets", getStringOffsetSection(),
                             getStringSection(), isLittleEndian(),
                             getMaxVersion());

  if (DumpType == DIDT_All || DumpType == DIDT_StrOffsetsDwo) {
    dumpStringOffsetsSection(OS, "debug_str_offsets.dwo",
                             getStringOffsetDWOSection(), getStringDWOSection(),
                             isLittleEndian(), getMaxVersion());
a255 34
DWARFCompileUnit *DWARFContext::getDWOCompileUnitForHash(uint64_t Hash) {
  // FIXME: Improve this for the case where this DWO file is really a DWP file
  // with an index - use the index for lookup instead of a linear search.
  for (const auto &DWOCU : dwo_compile_units())
    if (DWOCU->getDWOId() == Hash)
      return DWOCU.get();
  return nullptr;
}

DWARFDie DWARFContext::getDIEForOffset(uint32_t Offset) {
  parseCompileUnits();
  if (auto *CU = CUs.getUnitForOffset(Offset))
    return CU->getDIEForOffset(Offset);
  return DWARFDie();
}

bool DWARFContext::verify(raw_ostream &OS, DIDumpType DumpType) {
  bool Success = true;
  DWARFVerifier verifier(OS, *this);
  if (DumpType == DIDT_All || DumpType == DIDT_Info) {
    if (!verifier.handleDebugInfo())
      Success = false;
  }
  if (DumpType == DIDT_All || DumpType == DIDT_Line) {
    if (!verifier.handleDebugLine())
      Success = false;
  }
  if (DumpType == DIDT_All || DumpType == DIDT_AppleNames) {
    if (!verifier.handleAppleNames())
      Success = false;
  }
  return Success;
}

d313 2
a314 1
  Loc.reset(new DWARFDebugLoc);
d316 2
a317 5
  if (getNumCompileUnits()) {
    DWARFDataExtractor LocData(getLocSection(), isLittleEndian(),
                               getCompileUnitAtIndex(0)->getAddressByteSize());
    Loc->parse(LocData);
  }
d384 1
a384 1
    Line.reset(new DWARFDebugLine);
d390 1
a390 1
  auto Offset = toSectionOffset(UnitDIE.find(DW_AT_stmt_list));
a398 4
  // Make sure the offset is good before we try to parse.
  if (stmtOffset >= U->getLineSection().Data.size())
    return nullptr;  

d400 2
a401 2
  DWARFDataExtractor lineData(U->getLineSection(), isLittleEndian(),
                              U->getAddressByteSize());
d412 1
a412 1
  forEachTypesSections([&](const DWARFSection &S) {
d414 2
a415 2
    TUs.back().parse(*this, S);
  });
d425 1
a425 1
  forEachTypesDWOSections([&](const DWARFSection &S) {
d427 2
a428 2
    DWOTUs.back().parseDWO(*this, S);
  });
d443 5
a447 5
static bool getFunctionNameAndStartLineForAddress(DWARFCompileUnit *CU,
                                                  uint64_t Address,
                                                  FunctionNameKind Kind,
                                                  std::string &FunctionName,
                                                  uint32_t &StartLine) {
d450 1
a450 1
  // name of the topmost function in it.
d453 1
a453 1
  if (InlinedChain.empty())
d455 1
a455 5

  const DWARFDie &DIE = InlinedChain[0];
  bool FoundResult = false;
  const char *Name = nullptr;
  if (Kind != FunctionNameKind::None && (Name = DIE.getSubroutineName(Kind))) {
d457 1
a457 5
    FoundResult = true;
  }
  if (auto DeclLineResult = DIE.getDeclLine()) {
    StartLine = DeclLineResult;
    FoundResult = true;
d459 1
a459 2

  return FoundResult;
d469 1
a469 3
  getFunctionNameAndStartLineForAddress(CU, Address, Spec.FNKind,
                                        Result.FunctionName,
                                        Result.StartLine);
d487 1
a487 3
  uint32_t StartLine = 0;
  getFunctionNameAndStartLineForAddress(CU, Address, Spec.FNKind, FunctionName,
                                        StartLine);
a493 1
    Result.StartLine = StartLine;
a513 1
    Result.StartLine = StartLine;
d546 1
a546 1
  uint32_t CallFile = 0, CallLine = 0, CallColumn = 0, CallDiscriminator = 0;
a552 2
    if (auto DeclLineResult = FunctionDIE.getDeclLine())
      Frame.StartLine = DeclLineResult;
a569 1
        Frame.Discriminator = CallDiscriminator;
d573 1
a573 2
        FunctionDIE.getCallerFrame(CallFile, CallLine, CallColumn,
                                   CallDiscriminator);
d581 3
a583 156
std::shared_ptr<DWARFContext>
DWARFContext::getDWOContext(StringRef AbsolutePath) {
  if (auto S = DWP.lock()) {
    DWARFContext *Ctxt = S->Context.get();
    return std::shared_ptr<DWARFContext>(std::move(S), Ctxt);
  }

  std::weak_ptr<DWOFile> *Entry = &DWOFiles[AbsolutePath];

  if (auto S = Entry->lock()) {
    DWARFContext *Ctxt = S->Context.get();
    return std::shared_ptr<DWARFContext>(std::move(S), Ctxt);
  }

  SmallString<128> DWPName;
  Expected<OwningBinary<ObjectFile>> Obj = [&] {
    if (!CheckedForDWP) {
      (getFileName() + ".dwp").toVector(DWPName);
      auto Obj = object::ObjectFile::createObjectFile(DWPName);
      if (Obj) {
        Entry = &DWP;
        return Obj;
      } else {
        CheckedForDWP = true;
        // TODO: Should this error be handled (maybe in a high verbosity mode)
        // before falling back to .dwo files?
        consumeError(Obj.takeError());
      }
    }

    return object::ObjectFile::createObjectFile(AbsolutePath);
  }();

  if (!Obj) {
    // TODO: Actually report errors helpfully.
    consumeError(Obj.takeError());
    return nullptr;
  }

  auto S = std::make_shared<DWOFile>();
  S->File = std::move(Obj.get());
  S->Context = llvm::make_unique<DWARFContextInMemory>(*S->File.getBinary());
  *Entry = S;
  auto *Ctxt = S->Context.get();
  return std::shared_ptr<DWARFContext>(std::move(S), Ctxt);
}

static Error createError(const Twine &Reason, llvm::Error E) {
  return make_error<StringError>(Reason + toString(std::move(E)),
                                 inconvertibleErrorCode());
}

/// SymInfo contains information about symbol: it's address
/// and section index which is -1LL for absolute symbols.
struct SymInfo {
  uint64_t Address;
  uint64_t SectionIndex;
};

/// Returns the address of symbol relocation used against and a section index.
/// Used for futher relocations computation. Symbol's section load address is
static Expected<SymInfo> getSymbolInfo(const object::ObjectFile &Obj,
                                       const RelocationRef &Reloc,
                                       const LoadedObjectInfo *L,
                                       std::map<SymbolRef, SymInfo> &Cache) {
  SymInfo Ret = {0, (uint64_t)-1LL};
  object::section_iterator RSec = Obj.section_end();
  object::symbol_iterator Sym = Reloc.getSymbol();

  std::map<SymbolRef, SymInfo>::iterator CacheIt = Cache.end();
  // First calculate the address of the symbol or section as it appears
  // in the object file
  if (Sym != Obj.symbol_end()) {
    bool New;
    std::tie(CacheIt, New) = Cache.insert({*Sym, {0, 0}});
    if (!New)
      return CacheIt->second;

    Expected<uint64_t> SymAddrOrErr = Sym->getAddress();
    if (!SymAddrOrErr)
      return createError("failed to compute symbol address: ",
                         SymAddrOrErr.takeError());

    // Also remember what section this symbol is in for later
    auto SectOrErr = Sym->getSection();
    if (!SectOrErr)
      return createError("failed to get symbol section: ",
                         SectOrErr.takeError());

    RSec = *SectOrErr;
    Ret.Address = *SymAddrOrErr;
  } else if (auto *MObj = dyn_cast<MachOObjectFile>(&Obj)) {
    RSec = MObj->getRelocationSection(Reloc.getRawDataRefImpl());
    Ret.Address = RSec->getAddress();
  }

  if (RSec != Obj.section_end())
    Ret.SectionIndex = RSec->getIndex();

  // If we are given load addresses for the sections, we need to adjust:
  // SymAddr = (Address of Symbol Or Section in File) -
  //           (Address of Section in File) +
  //           (Load Address of Section)
  // RSec is now either the section being targeted or the section
  // containing the symbol being targeted. In either case,
  // we need to perform the same computation.
  if (L && RSec != Obj.section_end())
    if (uint64_t SectionLoadAddress = L->getSectionLoadAddress(*RSec))
      Ret.Address += SectionLoadAddress - RSec->getAddress();

  if (CacheIt != Cache.end())
    CacheIt->second = Ret;

  return Ret;
}

static bool isRelocScattered(const object::ObjectFile &Obj,
                             const RelocationRef &Reloc) {
  const MachOObjectFile *MachObj = dyn_cast<MachOObjectFile>(&Obj);
  if (!MachObj)
    return false;
  // MachO also has relocations that point to sections and
  // scattered relocations.
  auto RelocInfo = MachObj->getRelocation(Reloc.getRawDataRefImpl());
  return MachObj->isRelocationScattered(RelocInfo);
}

Error DWARFContextInMemory::maybeDecompress(const SectionRef &Sec,
                                            StringRef Name, StringRef &Data) {
  if (!Decompressor::isCompressed(Sec))
    return Error::success();

  Expected<Decompressor> Decompressor =
      Decompressor::create(Name, Data, IsLittleEndian, AddressSize == 8);
  if (!Decompressor)
    return Decompressor.takeError();

  SmallString<32> Out;
  if (auto Err = Decompressor->resizeAndDecompress(Out))
    return Err;

  UncompressedSections.emplace_back(std::move(Out));
  Data = UncompressedSections.back();

  return Error::success();
}

ErrorPolicy DWARFContextInMemory::defaultErrorHandler(Error E) {
  errs() << "error: " + toString(std::move(E)) << '\n';
  return ErrorPolicy::Continue;
}

DWARFContextInMemory::DWARFContextInMemory(
    const object::ObjectFile &Obj, const LoadedObjectInfo *L,
    function_ref<ErrorPolicy(Error)> HandleError)
    : FileName(Obj.getFileName()), IsLittleEndian(Obj.isLittleEndian()),
d586 2
a587 2
    StringRef Name;
    Section.getName(Name);
d589 2
a590 1
    if (Section.isBSS() || Section.isVirtual())
d592 4
a596 1
    StringRef Data;
d601 2
a602 2
    if (!L || !L->getLoadedSectionContents(*RelocatedSection, Data))
      Section.getContents(Data);
d604 10
a613 6
    if (auto Err = maybeDecompress(Section, Name, Data)) {
      ErrorPolicy EP = HandleError(
          createError("failed to decompress '" + Name + "', ", std::move(Err)));
      if (EP == ErrorPolicy::Halt)
        return;
      continue;
d618 2
a619 2
    Name = Name.substr(
        Name.find_first_not_of("._z")); // Skip ".", "z" and "_" prefixes.
d621 36
a656 7
    // Map platform specific debug section names to DWARF standard section
    // names.
    Name = Obj.mapDebugSectionName(Name);

    if (StringRef *SectionData = mapSectionToMember(Name)) {
      *SectionData = Data;
      if (Name == "debug_ranges") {
d658 1
a658 1
        RangeDWOSection.Data = Data;
d660 1
a660 1
    } else if (Name == "debug_types") {
d663 3
a665 3
      TypesSections[Section].Data = Data;
    } else if (Name == "debug_types.dwo") {
      TypesDWOSections[Section].Data = Data;
d678 1
a678 1
    if (L && L->getLoadedSectionContents(*RelocatedSection, RelSecData))
d690 1
a690 1
        RelSecName.find_first_not_of("._z")); // Skip . and _ prefixes.
d694 11
a704 2
    DWARFSection *Sec = mapNameToDWARFSection(RelSecName);
    RelocAddrMap *Map = Sec ? &Sec->Relocs : nullptr;
d716 94
a809 29
    if (Section.relocation_begin() == Section.relocation_end())
      continue;

    // Symbol to [address, section index] cache mapping.
    std::map<SymbolRef, SymInfo> AddrCache;
    for (const RelocationRef &Reloc : Section.relocations()) {
      // FIXME: it's not clear how to correctly handle scattered
      // relocations.
      if (isRelocScattered(Obj, Reloc))
        continue;

      Expected<SymInfo> SymInfoOrErr = getSymbolInfo(Obj, Reloc, L, AddrCache);
      if (!SymInfoOrErr) {
        if (HandleError(SymInfoOrErr.takeError()) == ErrorPolicy::Halt)
          return;
        continue;
      }

      object::RelocVisitor V(Obj);
      uint64_t Val = V.visit(Reloc.getType(), Reloc, SymInfoOrErr->Address);
      if (V.error()) {
        SmallString<32> Type;
        Reloc.getTypeName(Type);
        ErrorPolicy EP = HandleError(
            createError("failed to compute relocation: " + Type + ", ",
                        errorCodeToError(object_error::parse_failed)));
        if (EP == ErrorPolicy::Halt)
          return;
        continue;
a810 2
      RelocAddrEntry Rel = {SymInfoOrErr->SectionIndex, Val};
      Map->insert({Reloc.getOffset(), Rel});
d815 1
a815 54
DWARFContextInMemory::DWARFContextInMemory(
    const StringMap<std::unique_ptr<MemoryBuffer>> &Sections, uint8_t AddrSize,
    bool isLittleEndian)
    : IsLittleEndian(isLittleEndian), AddressSize(AddrSize) {
  for (const auto &SecIt : Sections) {
    if (StringRef *SectionData = mapSectionToMember(SecIt.first()))
      *SectionData = SecIt.second->getBuffer();
  }
}

DWARFSection *DWARFContextInMemory::mapNameToDWARFSection(StringRef Name) {
  return StringSwitch<DWARFSection *>(Name)
      .Case("debug_info", &InfoSection)
      .Case("debug_loc", &LocSection)
      .Case("debug_line", &LineSection)
      .Case("debug_str_offsets", &StringOffsetSection)
      .Case("debug_ranges", &RangeSection)
      .Case("debug_info.dwo", &InfoDWOSection)
      .Case("debug_loc.dwo", &LocDWOSection)
      .Case("debug_line.dwo", &LineDWOSection)
      .Case("debug_str_offsets.dwo", &StringOffsetDWOSection)
      .Case("debug_addr", &AddrSection)
      .Case("apple_names", &AppleNamesSection)
      .Case("apple_types", &AppleTypesSection)
      .Case("apple_namespaces", &AppleNamespacesSection)
      .Case("apple_namespac", &AppleNamespacesSection)
      .Case("apple_objc", &AppleObjCSection)
      .Default(nullptr);
}

StringRef *DWARFContextInMemory::mapSectionToMember(StringRef Name) {
  if (DWARFSection *Sec = mapNameToDWARFSection(Name))
    return &Sec->Data;
  return StringSwitch<StringRef *>(Name)
      .Case("debug_abbrev", &AbbrevSection)
      .Case("debug_aranges", &ARangeSection)
      .Case("debug_frame", &DebugFrameSection)
      .Case("eh_frame", &EHFrameSection)
      .Case("debug_str", &StringSection)
      .Case("debug_macinfo", &MacinfoSection)
      .Case("debug_pubnames", &PubNamesSection)
      .Case("debug_pubtypes", &PubTypesSection)
      .Case("debug_gnu_pubnames", &GnuPubNamesSection)
      .Case("debug_gnu_pubtypes", &GnuPubTypesSection)
      .Case("debug_abbrev.dwo", &AbbrevDWOSection)
      .Case("debug_str.dwo", &StringDWOSection)
      .Case("debug_cu_index", &CUIndexSection)
      .Case("debug_tu_index", &TUIndexSection)
      .Case("gdb_index", &GdbIndexSection)
      // Any more debug info sections go here.
      .Default(nullptr);
}

void DWARFContextInMemory::anchor() {}
@


