head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.03;	author patrick;	state Exp;
branches;
next	;
commitid	qMUxATnKgqN83Oct;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- FieldListRecordBuilder.cpp ----------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "llvm/DebugInfo/CodeView/FieldListRecordBuilder.h"

using namespace llvm;
using namespace codeview;

FieldListRecordBuilder::FieldListRecordBuilder()
    : ListRecordBuilder(TypeRecordKind::FieldList) {}

void FieldListRecordBuilder::writeBaseClass(MemberAccess Access, TypeIndex Type,
                                            uint64_t Offset) {
  TypeRecordBuilder &Builder = getBuilder();

  Builder.writeTypeRecordKind(TypeRecordKind::BaseClass);
  Builder.writeUInt16(static_cast<uint16_t>(Access));
  Builder.writeTypeIndex(Type);
  Builder.writeEncodedUnsignedInteger(Offset);

  finishSubRecord();
}

void FieldListRecordBuilder::writeEnumerate(MemberAccess Access, uint64_t Value,
                                            StringRef Name) {
  TypeRecordBuilder &Builder = getBuilder();

  Builder.writeTypeRecordKind(TypeRecordKind::Enumerate);
  Builder.writeUInt16(static_cast<uint16_t>(Access));
  Builder.writeEncodedUnsignedInteger(Value);
  Builder.writeNullTerminatedString(Name);

  finishSubRecord();
}

void FieldListRecordBuilder::writeMember(MemberAccess Access, TypeIndex Type,
                                         uint64_t Offset, StringRef Name) {
  TypeRecordBuilder &Builder = getBuilder();

  Builder.writeTypeRecordKind(TypeRecordKind::Member);
  Builder.writeUInt16(static_cast<uint16_t>(Access));
  Builder.writeTypeIndex(Type);
  Builder.writeEncodedUnsignedInteger(Offset);
  Builder.writeNullTerminatedString(Name);

  finishSubRecord();
}

void FieldListRecordBuilder::writeMethod(uint16_t OverloadCount,
                                         TypeIndex MethodList, StringRef Name) {
  TypeRecordBuilder &Builder = getBuilder();

  Builder.writeTypeRecordKind(TypeRecordKind::Method);
  Builder.writeUInt16(OverloadCount);
  Builder.writeTypeIndex(MethodList);
  Builder.writeNullTerminatedString(Name);

  finishSubRecord();
}

void FieldListRecordBuilder::writeOneMethod(
    MemberAccess Access, MethodKind Kind, MethodOptions Options, TypeIndex Type,
    int32_t VTableSlotOffset, StringRef Name) {
  TypeRecordBuilder &Builder = getBuilder();

  uint16_t Flags = static_cast<uint16_t>(Access);
  Flags |= static_cast<uint16_t>(Kind) << MethodKindShift;
  Flags |= static_cast<uint16_t>(Options);

  Builder.writeTypeRecordKind(TypeRecordKind::OneMethod);
  Builder.writeUInt16(Flags);
  Builder.writeTypeIndex(Type);
  switch (Kind) {
  case MethodKind::IntroducingVirtual:
  case MethodKind::PureIntroducingVirtual:
    assert(VTableSlotOffset >= 0);
    Builder.writeInt32(VTableSlotOffset);
    break;

  default:
    assert(VTableSlotOffset == -1);
    break;
  }

  Builder.writeNullTerminatedString(Name);

  finishSubRecord();
}

void FieldListRecordBuilder::writeOneMethod(const MethodInfo &Method,
                                            StringRef Name) {
  writeOneMethod(Method.getAccess(), Method.getKind(), Method.getOptions(),
                 Method.getType(), Method.getVTableSlotOffset(), Name);
}

void FieldListRecordBuilder::writeNestedType(TypeIndex Type, StringRef Name) {
  TypeRecordBuilder &Builder = getBuilder();

  Builder.writeTypeRecordKind(TypeRecordKind::NestedType);
  Builder.writeUInt16(0);
  Builder.writeTypeIndex(Type);
  Builder.writeNullTerminatedString(Name);

  finishSubRecord();
}

void FieldListRecordBuilder::writeStaticMember(MemberAccess Access,
                                               TypeIndex Type, StringRef Name) {
  TypeRecordBuilder &Builder = getBuilder();

  Builder.writeTypeRecordKind(TypeRecordKind::StaticMember);
  Builder.writeUInt16(static_cast<uint16_t>(Access));
  Builder.writeTypeIndex(Type);
  Builder.writeNullTerminatedString(Name);

  finishSubRecord();
}

void FieldListRecordBuilder::writeIndirectVirtualBaseClass(
    MemberAccess Access, TypeIndex Type, TypeIndex VirtualBasePointerType,
    int64_t VirtualBasePointerOffset, uint64_t SlotIndex) {
  writeVirtualBaseClass(TypeRecordKind::IndirectVirtualBaseClass, Access, Type,
                        VirtualBasePointerType, VirtualBasePointerOffset,
                        SlotIndex);
}

void FieldListRecordBuilder::writeVirtualBaseClass(
    MemberAccess Access, TypeIndex Type, TypeIndex VirtualBasePointerType,
    int64_t VirtualBasePointerOffset, uint64_t SlotIndex) {
  writeVirtualBaseClass(TypeRecordKind::VirtualBaseClass, Access, Type,
                        VirtualBasePointerType, VirtualBasePointerOffset,
                        SlotIndex);
}

void FieldListRecordBuilder::writeVirtualBaseClass(
    TypeRecordKind Kind, MemberAccess Access, TypeIndex Type,
    TypeIndex VirtualBasePointerType, int64_t VirtualBasePointerOffset,
    uint64_t SlotIndex) {
  TypeRecordBuilder &Builder = getBuilder();

  Builder.writeTypeRecordKind(Kind);
  Builder.writeUInt16(static_cast<uint16_t>(Access));
  Builder.writeTypeIndex(Type);
  Builder.writeTypeIndex(VirtualBasePointerType);
  Builder.writeEncodedInteger(VirtualBasePointerOffset);
  Builder.writeEncodedUnsignedInteger(SlotIndex);

  finishSubRecord();
}

void FieldListRecordBuilder::writeVirtualFunctionTablePointer(TypeIndex Type) {
  TypeRecordBuilder &Builder = getBuilder();

  Builder.writeTypeRecordKind(TypeRecordKind::VirtualFunctionTablePointer);
  Builder.writeUInt16(0);
  Builder.writeTypeIndex(Type);

  finishSubRecord();
}@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d18 2
a19 1
void FieldListRecordBuilder::writeBaseClass(const BaseClassRecord &Record) {
d23 3
a25 3
  Builder.writeUInt16(static_cast<uint16_t>(Record.getAccess()));
  Builder.writeTypeIndex(Record.getBaseType());
  Builder.writeEncodedUnsignedInteger(Record.getBaseOffset());
d30 2
a31 1
void FieldListRecordBuilder::writeEnumerator(const EnumeratorRecord &Record) {
d34 4
a37 5
  Builder.writeTypeRecordKind(TypeRecordKind::Enumerator);
  Builder.writeUInt16(static_cast<uint16_t>(Record.getAccess()));
  // FIXME: Handle full APInt such as __int128.
  Builder.writeEncodedUnsignedInteger(Record.getValue().getZExtValue());
  Builder.writeNullTerminatedString(Record.getName());
d42 2
a43 1
void FieldListRecordBuilder::writeDataMember(const DataMemberRecord &Record) {
d46 5
a50 5
  Builder.writeTypeRecordKind(Record.getKind());
  Builder.writeUInt16(static_cast<uint16_t>(Record.getAccess()));
  Builder.writeTypeIndex(Record.getType());
  Builder.writeEncodedUnsignedInteger(Record.getFieldOffset());
  Builder.writeNullTerminatedString(Record.getName());
d55 2
a56 2
void FieldListRecordBuilder::writeOverloadedMethod(
    const OverloadedMethodRecord &Record) {
d59 4
a62 4
  Builder.writeTypeRecordKind(TypeRecordKind::OverloadedMethod);
  Builder.writeUInt16(Record.getNumOverloads());
  Builder.writeTypeIndex(Record.getMethodList());
  Builder.writeNullTerminatedString(Record.getName());
d67 3
a69 1
void FieldListRecordBuilder::writeOneMethod(const OneMethodRecord &Record) {
d72 3
a74 3
  uint16_t Flags = static_cast<uint16_t>(Record.getAccess());
  Flags |= static_cast<uint16_t>(Record.getKind()) << MethodKindShift;
  Flags |= static_cast<uint16_t>(Record.getOptions());
d78 11
a88 6
  Builder.writeTypeIndex(Record.getType());
  if (Record.isIntroducingVirtual()) {
    assert(Record.getVFTableOffset() >= 0);
    Builder.writeInt32(Record.getVFTableOffset());
  } else {
    assert(Record.getVFTableOffset() == -1);
d91 1
a91 1
  Builder.writeNullTerminatedString(Record.getName());
d96 7
a102 1
void FieldListRecordBuilder::writeNestedType(const NestedTypeRecord &Record) {
d105 1
a105 1
  Builder.writeTypeRecordKind(Record.getKind());
d107 2
a108 2
  Builder.writeTypeIndex(Record.getNestedType());
  Builder.writeNullTerminatedString(Record.getName());
d113 2
a114 2
void FieldListRecordBuilder::writeStaticDataMember(
    const StaticDataMemberRecord &Record) {
d117 4
a120 4
  Builder.writeTypeRecordKind(Record.getKind());
  Builder.writeUInt16(static_cast<uint16_t>(Record.getAccess()));
  Builder.writeTypeIndex(Record.getType());
  Builder.writeNullTerminatedString(Record.getName());
d125 8
d134 11
a144 1
    const VirtualBaseClassRecord &Record) {
d147 6
a152 6
  Builder.writeTypeRecordKind(Record.getKind());
  Builder.writeUInt16(static_cast<uint16_t>(Record.getAccess()));
  Builder.writeTypeIndex(Record.getBaseType());
  Builder.writeTypeIndex(Record.getVBPtrType());
  Builder.writeEncodedInteger(Record.getVBPtrOffset());
  Builder.writeEncodedUnsignedInteger(Record.getVTableIndex());
d157 1
a157 1
void FieldListRecordBuilder::writeVFPtr(const VFPtrRecord &Record) {
d160 1
a160 1
  Builder.writeTypeRecordKind(TypeRecordKind::VFPtr);
d162 1
a162 1
  Builder.writeTypeIndex(Record.getType());
d165 1
a165 1
}
@

