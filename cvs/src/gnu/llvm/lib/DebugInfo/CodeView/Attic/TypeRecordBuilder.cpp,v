head	1.2;
access;
symbols
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.2
date	2017.01.24.08.39.07;	author patrick;	state dead;
branches;
next	1.1;
commitid	wUhrDWmTVlrk8aou;

1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.03;	author patrick;	state Exp;
branches;
next	;
commitid	qMUxATnKgqN83Oct;


desc
@@


1.2
log
@Merge LLVM 4.0.0 rc1
@
text
@//===-- TypeRecordBuilder.cpp ---------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "llvm/DebugInfo/CodeView/TypeRecordBuilder.h"

using namespace llvm;
using namespace codeview;

TypeRecordBuilder::TypeRecordBuilder(TypeRecordKind Kind) : Stream(Buffer),
  Writer(Stream) {
  writeTypeRecordKind(Kind);
}

StringRef TypeRecordBuilder::str() {
  return StringRef(Buffer.data(), Buffer.size());
}

void TypeRecordBuilder::writeUInt8(uint8_t Value) {
  Writer.write(Value);
}

void TypeRecordBuilder::writeInt16(int16_t Value) {
  Writer.write(Value);
}

void TypeRecordBuilder::writeUInt16(uint16_t Value) {
  Writer.write(Value);
}

void TypeRecordBuilder::writeInt32(int32_t Value) {
  Writer.write(Value);
}

void TypeRecordBuilder::writeUInt32(uint32_t Value) {
  Writer.write(Value);
}

void TypeRecordBuilder::writeInt64(int64_t Value) {
  Writer.write(Value);
}

void TypeRecordBuilder::writeUInt64(uint64_t Value) {
  Writer.write(Value);
}

void TypeRecordBuilder::writeEncodedInteger(int64_t Value) {
  if (Value >= 0) {
    writeEncodedUnsignedInteger(static_cast<uint64_t>(Value));
  } else {
    writeEncodedSignedInteger(Value);
  }
}

void TypeRecordBuilder::writeEncodedSignedInteger(int64_t Value) {
  if (Value >= std::numeric_limits<int8_t>::min() &&
      Value <= std::numeric_limits<int8_t>::max()) {
    writeUInt16(static_cast<uint16_t>(TypeRecordKind::SByte));
    writeInt16(static_cast<int8_t>(Value));
  } else if (Value >= std::numeric_limits<int16_t>::min() &&
             Value <= std::numeric_limits<int16_t>::max()) {
    writeUInt16(static_cast<uint16_t>(TypeRecordKind::Int16));
    writeInt16(static_cast<int16_t>(Value));
  } else if (Value >= std::numeric_limits<int32_t>::min() &&
             Value <= std::numeric_limits<int32_t>::max()) {
    writeUInt16(static_cast<uint32_t>(TypeRecordKind::Int32));
    writeInt32(static_cast<int32_t>(Value));
  } else {
    writeUInt16(static_cast<uint16_t>(TypeRecordKind::Int64));
    writeInt64(Value);
  }
}

void TypeRecordBuilder::writeEncodedUnsignedInteger(uint64_t Value) {
  if (Value < static_cast<uint16_t>(TypeRecordKind::SByte)) {
    writeUInt16(static_cast<uint16_t>(Value));
  } else if (Value <= std::numeric_limits<uint16_t>::max()) {
    writeUInt16(static_cast<uint16_t>(TypeRecordKind::UInt16));
    writeUInt16(static_cast<uint16_t>(Value));
  } else if (Value <= std::numeric_limits<uint32_t>::max()) {
    writeUInt16(static_cast<uint16_t>(TypeRecordKind::UInt32));
    writeUInt32(static_cast<uint32_t>(Value));
  } else {
    writeUInt16(static_cast<uint16_t>(TypeRecordKind::UInt64));
    writeUInt64(Value);
  }
}

void TypeRecordBuilder::writeNullTerminatedString(const char *Value) {
  assert(Value != nullptr);

  size_t Length = strlen(Value);
  Stream.write(Value, Length);
  writeUInt8(0);
}

void TypeRecordBuilder::writeNullTerminatedString(StringRef Value) {
  Stream.write(Value.data(), Value.size());
  writeUInt8(0);
}

void TypeRecordBuilder::writeTypeIndex(TypeIndex TypeInd) {
  writeUInt32(TypeInd.getIndex());
}

void TypeRecordBuilder::writeTypeRecordKind(TypeRecordKind Kind) {
  writeUInt16(static_cast<uint16_t>(Kind));
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d15 2
a16 2
TypeRecordBuilder::TypeRecordBuilder(TypeRecordKind Kind)
    : Stream(Buffer), Writer(Stream) {
d63 1
a63 1
    writeUInt16(LF_CHAR);
d67 1
a67 1
    writeUInt16(LF_SHORT);
d71 1
a71 1
    writeUInt16(LF_LONG);
d74 1
a74 1
    writeUInt16(LF_QUADWORD);
d80 1
a80 1
  if (Value < LF_CHAR) {
d83 1
a83 1
    writeUInt16(LF_USHORT);
d86 1
a86 1
    writeUInt16(LF_ULONG);
d89 1
a89 1
    writeUInt16(LF_UQUADWORD);
d94 8
a102 3
  // Microsoft's linker seems to have trouble with symbol names longer than
  // 0xffd8 bytes.
  Value = Value.substr(0, 0xffd8);
a104 5
}

void TypeRecordBuilder::writeGuid(StringRef Guid) {
  assert(Guid.size() == 16);
  Stream.write(Guid.data(), 16);
@

