head	1.2;
access;
symbols
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.2
date	2017.01.24.08.39.07;	author patrick;	state dead;
branches;
next	1.1;
commitid	wUhrDWmTVlrk8aou;

1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.47.00;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.56.03;	author patrick;	state Exp;
branches;
next	;
commitid	qMUxATnKgqN83Oct;


desc
@@


1.2
log
@Merge LLVM 4.0.0 rc1
@
text
@//===-- MemoryTypeTableBuilder.cpp ----------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "llvm/DebugInfo/CodeView/MemoryTypeTableBuilder.h"
#include "llvm/DebugInfo/CodeView/TypeIndex.h"

using namespace llvm;
using namespace codeview;

MemoryTypeTableBuilder::Record::Record(StringRef RData)
    : Size(RData.size()), Data(new char[RData.size()]) {
  memcpy(Data.get(), RData.data(), RData.size());
}

TypeIndex MemoryTypeTableBuilder::writeRecord(StringRef Data) {
  auto I = HashedRecords.find(Data);
  if (I != HashedRecords.end()) {
    return I->second;
  }

  std::unique_ptr<Record> R(new Record(Data));

  TypeIndex TI(static_cast<uint32_t>(Records.size()) +
               TypeIndex::FirstNonSimpleIndex);
  HashedRecords.insert(std::make_pair(StringRef(R->data(), R->size()), TI));
  Records.push_back(std::move(R));

  return TI;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d16 5
a21 1
  assert(Data.size() <= UINT16_MAX);
d27 1
a27 13
  // The record provided by the user lacks the 2 byte size field prefix and is
  // not padded to 4 bytes. Ultimately, that is what gets emitted in the object
  // file, so pad it out now.
  const int SizeOfRecLen = 2;
  const int Align = 4;
  int TotalSize = alignTo(Data.size() + SizeOfRecLen, Align);
  assert(TotalSize - SizeOfRecLen <= UINT16_MAX);
  char *Mem =
      reinterpret_cast<char *>(RecordStorage.Allocate(TotalSize, Align));
  *reinterpret_cast<ulittle16_t *>(Mem) = uint16_t(TotalSize - SizeOfRecLen);
  memcpy(Mem + SizeOfRecLen, Data.data(), Data.size());
  for (int I = Data.size() + SizeOfRecLen; I < TotalSize; ++I)
    Mem[I] = LF_PAD0 + (TotalSize - I);
d31 2
a32 5

  // Use only the data supplied by the user as a key to the hash table, so that
  // future lookups will succeed.
  HashedRecords.insert(std::make_pair(StringRef(Mem + SizeOfRecLen, Data.size()), TI));
  Records.push_back(StringRef(Mem, TotalSize));
@

