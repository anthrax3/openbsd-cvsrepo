head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.2.0.2
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.1
date	2017.01.14.19.56.03;	author patrick;	state Exp;
branches
	1.1.1.1;
next	;
commitid	qMUxATnKgqN83Oct;

1.1.1.1
date	2017.01.14.19.56.03;	author patrick;	state Exp;
branches;
next	1.1.1.2;
commitid	qMUxATnKgqN83Oct;

1.1.1.2
date	2017.01.24.08.33.35;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- RecordSerialization.cpp -------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// Utilities for serializing and deserializing CodeView records.
//
//===----------------------------------------------------------------------===//

#include "llvm/DebugInfo/CodeView/RecordSerialization.h"
#include "llvm/ADT/APInt.h"
#include "llvm/ADT/APSInt.h"
#include "llvm/DebugInfo/CodeView/TypeRecord.h"

using namespace llvm;
using namespace llvm::codeview;
using namespace llvm::support;

/// Reinterpret a byte array as an array of characters. Does not interpret as
/// a C string, as StringRef has several helpers (split) that make that easy.
StringRef llvm::codeview::getBytesAsCharacters(ArrayRef<uint8_t> LeafData) {
  return StringRef(reinterpret_cast<const char *>(LeafData.data()),
                   LeafData.size());
}

StringRef llvm::codeview::getBytesAsCString(ArrayRef<uint8_t> LeafData) {
  return getBytesAsCharacters(LeafData).split('\0').first;
}

std::error_code llvm::codeview::consume(ArrayRef<uint8_t> &Data, APSInt &Num) {
  // Used to avoid overload ambiguity on APInt construtor.
  bool FalseVal = false;
  if (Data.size() < 2)
    return std::make_error_code(std::errc::illegal_byte_sequence);
  uint16_t Short = *reinterpret_cast<const ulittle16_t *>(Data.data());
  Data = Data.drop_front(2);
  if (Short < LF_NUMERIC) {
    Num = APSInt(APInt(/*numBits=*/16, Short, /*isSigned=*/false),
                 /*isUnsigned=*/true);
    return std::error_code();
  }
  switch (Short) {
  case LF_CHAR:
    if (Data.size() < 1)
      return std::make_error_code(std::errc::illegal_byte_sequence);
    Num = APSInt(APInt(/*numBits=*/8,
                       *reinterpret_cast<const int8_t *>(Data.data()),
                       /*isSigned=*/true),
                 /*isUnsigned=*/false);
    Data = Data.drop_front(1);
    return std::error_code();
  case LF_SHORT:
    if (Data.size() < 2)
      return std::make_error_code(std::errc::illegal_byte_sequence);
    Num = APSInt(APInt(/*numBits=*/16,
                       *reinterpret_cast<const little16_t *>(Data.data()),
                       /*isSigned=*/true),
                 /*isUnsigned=*/false);
    Data = Data.drop_front(2);
    return std::error_code();
  case LF_USHORT:
    if (Data.size() < 2)
      return std::make_error_code(std::errc::illegal_byte_sequence);
    Num = APSInt(APInt(/*numBits=*/16,
                       *reinterpret_cast<const ulittle16_t *>(Data.data()),
                       /*isSigned=*/false),
                 /*isUnsigned=*/true);
    Data = Data.drop_front(2);
    return std::error_code();
  case LF_LONG:
    if (Data.size() < 4)
      return std::make_error_code(std::errc::illegal_byte_sequence);
    Num = APSInt(APInt(/*numBits=*/32,
                       *reinterpret_cast<const little32_t *>(Data.data()),
                       /*isSigned=*/true),
                 /*isUnsigned=*/false);
    Data = Data.drop_front(4);
    return std::error_code();
  case LF_ULONG:
    if (Data.size() < 4)
      return std::make_error_code(std::errc::illegal_byte_sequence);
    Num = APSInt(APInt(/*numBits=*/32,
                       *reinterpret_cast<const ulittle32_t *>(Data.data()),
                       /*isSigned=*/FalseVal),
                 /*isUnsigned=*/true);
    Data = Data.drop_front(4);
    return std::error_code();
  case LF_QUADWORD:
    if (Data.size() < 8)
      return std::make_error_code(std::errc::illegal_byte_sequence);
    Num = APSInt(APInt(/*numBits=*/64,
                       *reinterpret_cast<const little64_t *>(Data.data()),
                       /*isSigned=*/true),
                 /*isUnsigned=*/false);
    Data = Data.drop_front(8);
    return std::error_code();
  case LF_UQUADWORD:
    if (Data.size() < 8)
      return std::make_error_code(std::errc::illegal_byte_sequence);
    Num = APSInt(APInt(/*numBits=*/64,
                       *reinterpret_cast<const ulittle64_t *>(Data.data()),
                       /*isSigned=*/false),
                 /*isUnsigned=*/true);
    Data = Data.drop_front(8);
    return std::error_code();
  }
  return std::make_error_code(std::errc::illegal_byte_sequence);
}

std::error_code llvm::codeview::consume(StringRef &Data, APSInt &Num) {
  ArrayRef<uint8_t> Bytes(Data.bytes_begin(), Data.bytes_end());
  auto EC = consume(Bytes, Num);
  Data = StringRef(reinterpret_cast<const char *>(Bytes.data()), Bytes.size());
  return EC;
}

/// Decode a numeric leaf value that is known to be a uint64_t.
std::error_code llvm::codeview::consume_numeric(ArrayRef<uint8_t> &Data,
                                                uint64_t &Num) {
  APSInt N;
  if (auto EC = consume(Data, N))
    return EC;
  if (N.isSigned() || !N.isIntN(64))
    return std::make_error_code(std::errc::illegal_byte_sequence);
  Num = N.getLimitedValue();
  return std::error_code();
}

std::error_code llvm::codeview::consume(ArrayRef<uint8_t> &Data,
                                        uint32_t &Item) {
  const support::ulittle32_t *IntPtr;
  if (auto EC = consumeObject(Data, IntPtr))
    return EC;
  Item = *IntPtr;
  return std::error_code();
}

std::error_code llvm::codeview::consume(StringRef &Data, uint32_t &Item) {
  ArrayRef<uint8_t> Bytes(Data.bytes_begin(), Data.bytes_end());
  auto EC = consume(Bytes, Item);
  Data = StringRef(reinterpret_cast<const char *>(Bytes.data()), Bytes.size());
  return EC;
}

std::error_code llvm::codeview::consume(ArrayRef<uint8_t> &Data,
                                        int32_t &Item) {
  const support::little32_t *IntPtr;
  if (auto EC = consumeObject(Data, IntPtr))
    return EC;
  Item = *IntPtr;
  return std::error_code();
}

std::error_code llvm::codeview::consume(ArrayRef<uint8_t> &Data,
                                        StringRef &Item) {
  if (Data.empty())
    return std::make_error_code(std::errc::illegal_byte_sequence);

  StringRef Rest;
  std::tie(Item, Rest) = getBytesAsCharacters(Data).split('\0');
  // We expect this to be null terminated.  If it was not, it is an error.
  if (Data.size() == Item.size())
    return std::make_error_code(std::errc::illegal_byte_sequence);

  Data = ArrayRef<uint8_t>(Rest.bytes_begin(), Rest.bytes_end());
  return std::error_code();
}
@


1.1.1.1
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a16 1
#include "llvm/DebugInfo/CodeView/CodeViewError.h"
a17 1
#include "llvm/DebugInfo/MSF/ByteStream.h"
d34 1
a34 1
Error llvm::codeview::consume(msf::StreamReader &Reader, APSInt &Num) {
d37 4
a40 4
  uint16_t Short;
  if (auto EC = Reader.readInteger(Short))
    return EC;

d44 1
a44 1
    return Error::success();
a45 1

d47 63
a109 20
  case LF_CHAR: {
    int8_t N;
    if (auto EC = Reader.readInteger(N))
      return EC;
    Num = APSInt(APInt(8, N, true), false);
    return Error::success();
  }
  case LF_SHORT: {
    int16_t N;
    if (auto EC = Reader.readInteger(N))
      return EC;
    Num = APSInt(APInt(16, N, true), false);
    return Error::success();
  }
  case LF_USHORT: {
    uint16_t N;
    if (auto EC = Reader.readInteger(N))
      return EC;
    Num = APSInt(APInt(16, N, false), true);
    return Error::success();
d111 1
a111 31
  case LF_LONG: {
    int32_t N;
    if (auto EC = Reader.readInteger(N))
      return EC;
    Num = APSInt(APInt(32, N, true), false);
    return Error::success();
  }
  case LF_ULONG: {
    uint32_t N;
    if (auto EC = Reader.readInteger(N))
      return EC;
    Num = APSInt(APInt(32, N, FalseVal), true);
    return Error::success();
  }
  case LF_QUADWORD: {
    int64_t N;
    if (auto EC = Reader.readInteger(N))
      return EC;
    Num = APSInt(APInt(64, N, true), false);
    return Error::success();
  }
  case LF_UQUADWORD: {
    uint64_t N;
    if (auto EC = Reader.readInteger(N))
      return EC;
    Num = APSInt(APInt(64, N, false), true);
    return Error::success();
  }
  }
  return make_error<CodeViewError>(cv_error_code::corrupt_record,
                                   "Buffer contains invalid APSInt type");
d114 1
a114 1
Error llvm::codeview::consume(StringRef &Data, APSInt &Num) {
d116 2
a117 4
  msf::ByteStream S(Bytes);
  msf::StreamReader SR(S);
  auto EC = consume(SR, Num);
  Data = Data.take_back(SR.bytesRemaining());
d122 2
a123 2
Error llvm::codeview::consume_numeric(msf::StreamReader &Reader,
                                      uint64_t &Num) {
d125 1
a125 1
  if (auto EC = consume(Reader, N))
d128 1
a128 2
    return make_error<CodeViewError>(cv_error_code::corrupt_record,
                                     "Data is not a numeric value!");
d130 1
a130 1
  return Error::success();
d133 7
a139 2
Error llvm::codeview::consume(msf::StreamReader &Reader, uint32_t &Item) {
  return Reader.readInteger(Item);
d142 1
a142 1
Error llvm::codeview::consume(StringRef &Data, uint32_t &Item) {
d144 2
a145 4
  msf::ByteStream S(Bytes);
  msf::StreamReader SR(S);
  auto EC = consume(SR, Item);
  Data = Data.take_back(SR.bytesRemaining());
d149 7
a155 2
Error llvm::codeview::consume(msf::StreamReader &Reader, int32_t &Item) {
  return Reader.readInteger(Item);
d158 10
a167 4
Error llvm::codeview::consume(msf::StreamReader &Reader, StringRef &Item) {
  if (Reader.empty())
    return make_error<CodeViewError>(cv_error_code::corrupt_record,
                                     "Null terminated string buffer is empty!");
d169 2
a170 1
  return Reader.readZeroString(Item);
@

