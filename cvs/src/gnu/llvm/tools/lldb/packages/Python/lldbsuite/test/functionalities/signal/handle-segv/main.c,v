head     1.1;
branch   1.1.1;
access   ;
symbols  LLVM_5_0_0:1.1.1.1 LLVM:1.1.1;
locks    ; strict;
comment  @ * @;
expand   @o@;


1.1
date     2017.10.04.20.27.41;  author patrick;  state Exp;
branches 1.1.1.1;
next     ;
commitid        ufzi3t8MqoilCPqO;

1.1.1.1
date     2017.10.04.20.27.41;  author patrick;  state Exp;
branches ;
next     ;
commitid        ufzi3t8MqoilCPqO;


desc
@@



1.1
log
@Initial revision
@
text
@#include <sys/mman.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

enum {
    kMmapSize = 0x1000,
    kMagicValue = 47,
};

void *address;
volatile sig_atomic_t signaled = 0;

void handler(int sig)
{
    signaled = 1;
    if (munmap(address, kMmapSize) != 0)
    {
        perror("munmap");
        _exit(5);
    }

    void* newaddr = mmap(address, kMmapSize, PROT_READ | PROT_WRITE,
            MAP_ANON | MAP_FIXED | MAP_PRIVATE, -1, 0);
    if (newaddr != address)
    {
        fprintf(stderr, "Newly mmaped address (%p) does not equal old address (%p).\n",
                newaddr, address);
        _exit(6);
    }
    *(int*)newaddr = kMagicValue;
}

int main()
{
    if (signal(SIGSEGV, handler) == SIG_ERR)
    {
        perror("signal");
        return 1;
    }

    address = mmap(NULL, kMmapSize, PROT_NONE, MAP_ANON | MAP_PRIVATE, -1, 0);
    if (address == MAP_FAILED)
    {
        perror("mmap");
        return 2;
    }

    // This should first trigger a segfault. Our handler will make the memory readable and write
    // the magic value into memory.
    if (*(int*)address != kMagicValue)
        return 3;

    if (! signaled)
        return 4;

    return 0;
}
@


1.1.1.1
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@@
