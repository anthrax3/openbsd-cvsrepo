head     1.1;
branch   1.1.1;
access   ;
symbols  LLVM_5_0_0:1.1.1.1 LLVM:1.1.1;
locks    ; strict;
comment  @# @;
expand   @o@;


1.1
date     2017.10.04.20.27.40;  author patrick;  state Exp;
branches 1.1.1.1;
next     ;
commitid        ufzi3t8MqoilCPqO;

1.1.1.1
date     2017.10.04.20.27.40;  author patrick;  state Exp;
branches ;
next     ;
commitid        ufzi3t8MqoilCPqO;


desc
@@



1.1
log
@Initial revision
@
text
@"""
Base class for lldb-mi test cases.
"""

from __future__ import print_function


from lldbsuite.test.lldbtest import *


class MiTestCaseBase(Base):

    mydir = None
    myexe = "a.out"
    mylog = "child.log"

    def getCategories(self):
        return ['lldb-mi']

    @@classmethod
    def classCleanup(cls):
        TestBase.RemoveTempFile(cls.myexe)
        TestBase.RemoveTempFile(cls.mylog)

    def setUp(self):
        Base.setUp(self)
        self.buildDefault()
        self.child_prompt = "(gdb)"

    def tearDown(self):
        if self.TraceOn():
            print("\n\nContents of %s:" % self.mylog)
            try:
                print(open(self.mylog, "r").read())
            except IOError:
                pass
        Base.tearDown(self)

    def spawnLldbMi(self, args=None):
        import pexpect
        self.child = pexpect.spawn("%s --interpreter %s" % (
            self.lldbMiExec, args if args else ""))
        self.child.setecho(True)
        self.child.logfile_read = open(self.mylog, "w")
        # wait until lldb-mi has started up and is ready to go
        self.expect(self.child_prompt, exactly=True)

    def runCmd(self, cmd):
        self.child.sendline(cmd)

    def expect(self, pattern, exactly=False, *args, **kwargs):
        if exactly:
            return self.child.expect_exact(pattern, *args, **kwargs)
        return self.child.expect(pattern, *args, **kwargs)
@


1.1.1.1
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@@
