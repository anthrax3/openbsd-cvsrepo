head     1.1;
branch   1.1.1;
access   ;
symbols  LLVM_5_0_0:1.1.1.1 LLVM:1.1.1;
locks    ; strict;
comment  @# @;
expand   @o@;


1.1
date     2017.10.04.20.27.42;  author patrick;  state Exp;
branches 1.1.1.1;
next     ;
commitid        ufzi3t8MqoilCPqO;

1.1.1.1
date     2017.10.04.20.27.42;  author patrick;  state Exp;
branches ;
next     ;
commitid        ufzi3t8MqoilCPqO;


desc
@@



1.1
log
@Initial revision
@
text
@"""
Test SBTarget APIs.
"""

from __future__ import print_function


import unittest2
import os
import time
import re
import lldb
from lldbsuite.test.decorators import *
from lldbsuite.test.lldbtest import *
from lldbsuite.test import lldbutil


class TestNameLookup(TestBase):

    mydir = TestBase.compute_mydir(__file__)

    @@add_test_categories(['pyapi'])
    def test_target(self):
        """Exercise SBTarget.FindFunctions() with various name masks.
        
        A previous regression caused mangled names to not be able to be looked up.
        This test verifies that using a mangled name with eFunctionNameTypeFull works
        and that using a function basename with eFunctionNameTypeFull works for all
        C++ functions that are at the global namespace level."""
        self.build();
        exe = os.path.join(os.getcwd(), 'a.out')

        # Create a target by the debugger.
        target = self.dbg.CreateTarget(exe)
        self.assertTrue(target, VALID_TARGET)

        exe_module = target.FindModule(target.GetExecutable())
        
        c_name_to_symbol = {}
        cpp_name_to_symbol = {}
        mangled_to_symbol = {}
        num_symbols = exe_module.GetNumSymbols();
        for i in range(num_symbols):
            symbol = exe_module.GetSymbolAtIndex(i);
            name = symbol.GetName()
            if name and 'unique_function_name' in name and '__PRETTY_FUNCTION__' not in name:
                mangled = symbol.GetMangledName()
                if mangled:
                    mangled_to_symbol[mangled] = symbol
                    if name:
                        cpp_name_to_symbol[name] = symbol
                elif name:
                    c_name_to_symbol[name] = symbol

        # Make sure each mangled name turns up exactly one match when looking up
        # functions by full name and using the mangled name as the name in the 
        # lookup
        self.assertGreaterEqual(len(mangled_to_symbol), 6)
        for mangled in mangled_to_symbol.keys():
            symbol_contexts = target.FindFunctions(mangled, lldb.eFunctionNameTypeFull)
            self.assertTrue(symbol_contexts.GetSize() == 1)
            for symbol_context in symbol_contexts:
                self.assertTrue(symbol_context.GetFunction().IsValid())
                self.assertTrue(symbol_context.GetSymbol().IsValid())
            
            
@


1.1.1.1
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@@
