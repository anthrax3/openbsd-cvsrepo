head     1.1;
branch   1.1.1;
access   ;
symbols  LLVM_5_0_0:1.1.1.1 LLVM:1.1.1;
locks    ; strict;
comment  @// @;
expand   @o@;


1.1
date     2017.10.04.20.27.38;  author patrick;  state Exp;
branches 1.1.1.1;
next     ;
commitid        ufzi3t8MqoilCPqO;

1.1.1.1
date     2017.10.04.20.27.38;  author patrick;  state Exp;
branches ;
next     ;
commitid        ufzi3t8MqoilCPqO;


desc
@@



1.1
log
@Initial revision
@
text
@//===-- StringConvert.cpp ---------------------------------------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

// C Includes
#include <stdlib.h>

// C++ Includes
// Other libraries and framework includes
// Project includes
#include "lldb/Host/StringConvert.h"

namespace lldb_private {
namespace StringConvert {

int32_t ToSInt32(const char *s, int32_t fail_value, int base,
                 bool *success_ptr) {
  if (s && s[0]) {
    char *end = nullptr;
    const long sval = ::strtol(s, &end, base);
    if (*end == '\0') {
      if (success_ptr)
        *success_ptr = ((sval <= INT32_MAX) && (sval >= INT32_MIN));
      return (int32_t)sval; // All characters were used, return the result
    }
  }
  if (success_ptr)
    *success_ptr = false;
  return fail_value;
}

uint32_t ToUInt32(const char *s, uint32_t fail_value, int base,
                  bool *success_ptr) {
  if (s && s[0]) {
    char *end = nullptr;
    const unsigned long uval = ::strtoul(s, &end, base);
    if (*end == '\0') {
      if (success_ptr)
        *success_ptr = (uval <= UINT32_MAX);
      return (uint32_t)uval; // All characters were used, return the result
    }
  }
  if (success_ptr)
    *success_ptr = false;
  return fail_value;
}

int64_t ToSInt64(const char *s, int64_t fail_value, int base,
                 bool *success_ptr) {
  if (s && s[0]) {
    char *end = nullptr;
    int64_t uval = ::strtoll(s, &end, base);
    if (*end == '\0') {
      if (success_ptr)
        *success_ptr = true;
      return uval; // All characters were used, return the result
    }
  }
  if (success_ptr)
    *success_ptr = false;
  return fail_value;
}

uint64_t ToUInt64(const char *s, uint64_t fail_value, int base,
                  bool *success_ptr) {
  if (s && s[0]) {
    char *end = nullptr;
    uint64_t uval = ::strtoull(s, &end, base);
    if (*end == '\0') {
      if (success_ptr)
        *success_ptr = true;
      return uval; // All characters were used, return the result
    }
  }
  if (success_ptr)
    *success_ptr = false;
  return fail_value;
}

double ToDouble(const char *s, double fail_value, bool *success_ptr) {
  if (s && s[0]) {
    char *end = nullptr;
    double val = strtod(s, &end);
    if (*end == '\0') {
      if (success_ptr)
        *success_ptr = true;
      return val; // All characters were used, return the result
    }
  }
  if (success_ptr)
    *success_ptr = false;
  return fail_value;
}
}
}
@


1.1.1.1
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@@
