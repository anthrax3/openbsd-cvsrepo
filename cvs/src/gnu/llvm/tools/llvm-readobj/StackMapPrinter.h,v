head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.2.0.2
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.24.08.33.00;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===-------- StackMapPrinter.h - Pretty-print stackmaps --------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_TOOLS_LLVM_READOBJ_STACKMAPPRINTER_H
#define LLVM_TOOLS_LLVM_READOBJ_STACKMAPPRINTER_H

#include "llvm/Object/StackMapParser.h"

namespace llvm {

// Pretty print a stackmap to the given ostream.
template <typename OStreamT, typename StackMapParserT>
void prettyPrintStackMap(OStreamT &OS, const StackMapParserT &SMP) {

  OS << "LLVM StackMap Version: " << SMP.getVersion()
     << "\nNum Functions: " << SMP.getNumFunctions();

  // Functions:
  for (const auto &F : SMP.functions())
    OS << "\n  Function address: " << F.getFunctionAddress()
       << ", stack size: " << F.getStackSize();

  // Constants:
  OS << "\nNum Constants: " << SMP.getNumConstants();
  unsigned ConstantIndex = 0;
  for (const auto &C : SMP.constants())
    OS << "\n  #" << ++ConstantIndex << ": " << C.getValue();

  // Records:
  OS << "\nNum Records: " << SMP.getNumRecords();
  for (const auto &R : SMP.records()) {
    OS << "\n  Record ID: " << R.getID()
       << ", instruction offset: " << R.getInstructionOffset()
       << "\n    " << R.getNumLocations() << " locations:";

    unsigned LocationIndex = 0;
    for (const auto &Loc : R.locations()) {
      OS << "\n      #" << ++LocationIndex << ": ";
      switch (Loc.getKind()) {
      case StackMapParserT::LocationKind::Register:
        OS << "Register R#" << Loc.getDwarfRegNum();
        break;
      case StackMapParserT::LocationKind::Direct:
        OS << "Direct R#" << Loc.getDwarfRegNum() << " + "
           << Loc.getOffset();
        break;
      case StackMapParserT::LocationKind::Indirect:
        OS << "Indirect [R#" << Loc.getDwarfRegNum() << " + "
           << Loc.getOffset() << "]";
        break;
      case StackMapParserT::LocationKind::Constant:
        OS << "Constant " << Loc.getSmallConstant();
        break;
      case StackMapParserT::LocationKind::ConstantIndex:
        OS << "ConstantIndex #" << Loc.getConstantIndex() << " ("
           << SMP.getConstant(Loc.getConstantIndex()).getValue() << ")";
        break;
      }
    }

    OS << "\n    " << R.getNumLiveOuts() << " live-outs: [ ";
    for (const auto &LO : R.liveouts())
      OS << "R#" << LO.getDwarfRegNum() << " ("
         << LO.getSizeInBytes() << "-bytes) ";
    OS << "]\n";
  }

 OS << "\n";

}

}

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d27 1
a27 2
       << ", stack size: " << F.getStackSize()
       << ", callsite record count: " << F.getRecordCount();
@

