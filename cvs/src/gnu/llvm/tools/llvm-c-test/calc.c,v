head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.2.0.2
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.45;	author patrick;	state Exp;
branches;
next	;
commitid	qMUxATnKgqN83Oct;


desc
@@


1.1
log
@Initial revision
@
text
@/*===-- calc.c - tool for testing libLLVM and llvm-c API ------------------===*\
|*                                                                            *|
|*                     The LLVM Compiler Infrastructure                       *|
|*                                                                            *|
|* This file is distributed under the University of Illinois Open Source      *|
|* License. See LICENSE.TXT for details.                                      *|
|*                                                                            *|
|*===----------------------------------------------------------------------===*|
|*                                                                            *|
|* This file implements the --calc command in llvm-c-test. --calc reads lines *|
|* from stdin, parses them as a name and an expression in reverse polish      *|
|* notation and prints a module with a function with the expression.          *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#include "llvm-c-test.h"
#include "llvm-c/Core.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

typedef LLVMValueRef (*binop_func_t)(LLVMBuilderRef, LLVMValueRef LHS,
                                     LLVMValueRef RHS, const char *Name);

static LLVMOpcode op_to_opcode(char op) {
  switch (op) {
  case '+': return LLVMAdd;
  case '-': return LLVMSub;
  case '*': return LLVMMul;
  case '/': return LLVMSDiv;
  case '&': return LLVMAnd;
  case '|': return LLVMOr;
  case '^': return LLVMXor;
  }
  assert(0 && "unknown operation");
  return 0;
}

#define MAX_DEPTH 32

static LLVMValueRef build_from_tokens(char **tokens, int ntokens,
                                      LLVMBuilderRef builder,
                                      LLVMValueRef param) {
  LLVMValueRef stack[MAX_DEPTH];
  int depth = 0;
  int i;

  for (i = 0; i < ntokens; i++) {
    char tok = tokens[i][0];
    switch (tok) {
    case '+':
    case '-':
    case '*':
    case '/':
    case '&':
    case '|':
    case '^':
      if (depth < 2) {
        printf("stack underflow\n");
        return NULL;
      }

      stack[depth - 2] = LLVMBuildBinOp(builder, op_to_opcode(tok),
                                        stack[depth - 1], stack[depth - 2], "");
      depth--;

      break;

    case '@@': {
      LLVMValueRef off;

      if (depth < 1) {
        printf("stack underflow\n");
        return NULL;
      }

      off = LLVMBuildGEP(builder, param, &stack[depth - 1], 1, "");
      stack[depth - 1] = LLVMBuildLoad(builder, off, "");

      break;
    }

    default: {
      char *end;
      long val = strtol(tokens[i], &end, 0);
      if (end[0] != '\0') {
        printf("error parsing number\n");
        return NULL;
      }

      if (depth >= MAX_DEPTH) {
        printf("stack overflow\n");
        return NULL;
      }

      stack[depth++] = LLVMConstInt(LLVMInt64Type(), val, 1);
      break;
    }
    }
  }

  if (depth < 1) {
    printf("stack underflow at return\n");
    return NULL;
  }

  LLVMBuildRet(builder, stack[depth - 1]);

  return stack[depth - 1];
}

static void handle_line(char **tokens, int ntokens) {
  char *name = tokens[0];
  LLVMValueRef param;
  LLVMValueRef res;

  LLVMModuleRef M = LLVMModuleCreateWithName(name);

  LLVMTypeRef I64ty = LLVMInt64Type();
  LLVMTypeRef I64Ptrty = LLVMPointerType(I64ty, 0);
  LLVMTypeRef Fty = LLVMFunctionType(I64ty, &I64Ptrty, 1, 0);

  LLVMValueRef F = LLVMAddFunction(M, name, Fty);
  LLVMBuilderRef builder = LLVMCreateBuilder();
  LLVMPositionBuilderAtEnd(builder, LLVMAppendBasicBlock(F, "entry"));

  LLVMGetParams(F, &param);
  LLVMSetValueName(param, "in");

  res = build_from_tokens(tokens + 1, ntokens - 1, builder, param);
  if (res) {
    char *irstr = LLVMPrintModuleToString(M);
    puts(irstr);
    LLVMDisposeMessage(irstr);
  }

  LLVMDisposeBuilder(builder);

  LLVMDisposeModule(M);
}

int calc(void) {

  tokenize_stdin(handle_line);

  return 0;
}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d17 1
d143 1
a143 1
int llvm_calc(void) {
d145 1
a145 1
  llvm_tokenize_stdin(handle_line);
@

