head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.3.0.4
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.45;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.32.59;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- sancov.cc --------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file is a command-line tool for reading and analyzing sanitizer
// coverage.
//===----------------------------------------------------------------------===//
#include "llvm/ADT/STLExtras.h"
#include "llvm/DebugInfo/Symbolize/Symbolize.h"
#include "llvm/MC/MCAsmInfo.h"
#include "llvm/MC/MCContext.h"
#include "llvm/MC/MCDisassembler.h"
#include "llvm/MC/MCInst.h"
#include "llvm/MC/MCInstPrinter.h"
#include "llvm/MC/MCInstrAnalysis.h"
#include "llvm/MC/MCInstrInfo.h"
#include "llvm/MC/MCObjectFileInfo.h"
#include "llvm/MC/MCRegisterInfo.h"
#include "llvm/MC/MCSubtargetInfo.h"
#include "llvm/Object/Archive.h"
#include "llvm/Object/Binary.h"
#include "llvm/Object/ObjectFile.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/Errc.h"
#include "llvm/Support/ErrorOr.h"
#include "llvm/Support/FileSystem.h"
#include "llvm/Support/LineIterator.h"
#include "llvm/Support/ManagedStatic.h"
#include "llvm/Support/MemoryBuffer.h"
#include "llvm/Support/Path.h"
#include "llvm/Support/PrettyStackTrace.h"
#include "llvm/Support/Signals.h"
#include "llvm/Support/SpecialCaseList.h"
#include "llvm/Support/TargetRegistry.h"
#include "llvm/Support/TargetSelect.h"
#include "llvm/Support/ToolOutputFile.h"
#include "llvm/Support/raw_ostream.h"

#include <set>
#include <stdio.h>
#include <string>
#include <vector>

using namespace llvm;

namespace {

// --------- COMMAND LINE FLAGS ---------

enum ActionType {
  PrintAction,
  CoveredFunctionsAction,
  NotCoveredFunctionsAction
};

cl::opt<ActionType> Action(
    cl::desc("Action (required)"), cl::Required,
    cl::values(clEnumValN(PrintAction, "print", "Print coverage addresses"),
               clEnumValN(CoveredFunctionsAction, "covered-functions",
                          "Print all covered funcions."),
               clEnumValN(NotCoveredFunctionsAction, "not-covered-functions",
                          "Print all not covered funcions."),
               clEnumValEnd));

static cl::list<std::string> ClInputFiles(cl::Positional, cl::OneOrMore,
                                          cl::desc("<filenames...>"));

static cl::opt<std::string>
    ClBinaryName("obj", cl::Required,
                 cl::desc("Path to object file to be symbolized"));

static cl::opt<bool>
    ClDemangle("demangle", cl::init(true),
        cl::desc("Print demangled function name."));

static cl::opt<std::string> ClStripPathPrefix(
    "strip_path_prefix", cl::init(""),
    cl::desc("Strip this prefix from file paths in reports."));

static cl::opt<std::string>
    ClBlacklist("blacklist", cl::init(""),
                cl::desc("Blacklist file (sanitizer blacklist format)."));

static cl::opt<bool> ClUseDefaultBlacklist(
    "use_default_blacklist", cl::init(true), cl::Hidden,
    cl::desc("Controls if default blacklist should be used."));

static const char *const DefaultBlacklist = "fun:__sanitizer_*";

// --------- FORMAT SPECIFICATION ---------

struct FileHeader {
  uint32_t Bitness;
  uint32_t Magic;
};

static const uint32_t BinCoverageMagic = 0xC0BFFFFF;
static const uint32_t Bitness32 = 0xFFFFFF32;
static const uint32_t Bitness64 = 0xFFFFFF64;

// ---------

static void FailIfError(std::error_code Error) {
  if (!Error)
    return;
  errs() << "Error: " << Error.message() << "(" << Error.value() << ")\n";
  exit(1);
}

template <typename T> static void FailIfError(const ErrorOr<T> &E) {
  FailIfError(E.getError());
}

static void FailIfNotEmpty(const std::string &E) {
  if (E.empty())
    return;
  errs() << "Error: " << E << "\n";
  exit(1);
}

template <typename T>
static void FailIfEmpty(const std::unique_ptr<T> &Ptr,
                        const std::string &Message) {
  if (Ptr.get())
    return;
  errs() << "Error: " << Message << "\n";
  exit(1);
}

template <typename T>
static void readInts(const char *Start, const char *End,
                     std::set<uint64_t> *Ints) {
  const T *S = reinterpret_cast<const T *>(Start);
  const T *E = reinterpret_cast<const T *>(End);
  std::copy(S, E, std::inserter(*Ints, Ints->end()));
}

struct FileLoc {
  bool operator<(const FileLoc &RHS) const {
    return std::tie(FileName, Line) < std::tie(RHS.FileName, RHS.Line);
  }

  std::string FileName;
  uint32_t Line;
};

struct FunctionLoc {
  bool operator<(const FunctionLoc &RHS) const {
    return std::tie(Loc, FunctionName) < std::tie(RHS.Loc, RHS.FunctionName);
  }

  FileLoc Loc;
  std::string FunctionName;
};

std::string stripPathPrefix(std::string Path) {
  if (ClStripPathPrefix.empty())
    return Path;
  size_t Pos = Path.find(ClStripPathPrefix);
  if (Pos == std::string::npos)
    return Path;
  return Path.substr(Pos + ClStripPathPrefix.size());
}

// Compute [FileLoc -> FunctionName] map for given addresses.
static std::map<FileLoc, std::string>
computeFunctionsMap(const std::set<uint64_t> &Addrs) {
  std::map<FileLoc, std::string> Fns;

  symbolize::LLVMSymbolizer::Options SymbolizerOptions;
  SymbolizerOptions.Demangle = ClDemangle;
  SymbolizerOptions.UseSymbolTable = true;
  symbolize::LLVMSymbolizer Symbolizer(SymbolizerOptions);

  // Fill in Fns map.
  for (auto Addr : Addrs) {
    auto InliningInfo = Symbolizer.symbolizeInlinedCode(ClBinaryName, Addr);
    FailIfError(InliningInfo);
    for (uint32_t I = 0; I < InliningInfo->getNumberOfFrames(); ++I) {
      auto FrameInfo = InliningInfo->getFrame(I);
      SmallString<256> FileName(FrameInfo.FileName);
      sys::path::remove_dots(FileName, /* remove_dot_dot */ true);
      FileLoc Loc = {FileName.str(), FrameInfo.Line};
      Fns[Loc] = FrameInfo.FunctionName;
    }
  }

  return Fns;
}

// Compute functions for given addresses. It keeps only the first
// occurence of a function within a file.
std::set<FunctionLoc> computeFunctionLocs(const std::set<uint64_t> &Addrs) {
  std::map<FileLoc, std::string> Fns = computeFunctionsMap(Addrs);

  std::set<FunctionLoc> Result;
  std::string LastFileName;
  std::set<std::string> ProcessedFunctions;

  for (const auto &P : Fns) {
    std::string FileName = P.first.FileName;
    std::string FunctionName = P.second;

    if (LastFileName != FileName)
      ProcessedFunctions.clear();
    LastFileName = FileName;

    if (!ProcessedFunctions.insert(FunctionName).second)
      continue;

    Result.insert(FunctionLoc{P.first, P.second});
  }

  return Result;
}

// Locate __sanitizer_cov* function addresses that are used for coverage
// reporting.
static std::set<uint64_t>
findSanitizerCovFunctions(const object::ObjectFile &O) {
  std::set<uint64_t> Result;

  for (const object::SymbolRef &Symbol : O.symbols()) {
    ErrorOr<uint64_t> AddressOrErr = Symbol.getAddress();
    FailIfError(AddressOrErr);

    ErrorOr<StringRef> NameOrErr = Symbol.getName();
    FailIfError(NameOrErr);
    StringRef Name = NameOrErr.get();

    if (Name == "__sanitizer_cov" || Name == "__sanitizer_cov_with_check" ||
        Name == "__sanitizer_cov_trace_func_enter") {
      Result.insert(AddressOrErr.get());
    }
  }

  if (Result.empty())
    FailIfNotEmpty("__sanitizer_cov* functions not found");

  return Result;
}

// Locate addresses of all coverage points in a file. Coverage point
// is defined as the 'address of instruction following __sanitizer_cov
// call - 1'.
static void getObjectCoveragePoints(const object::ObjectFile &O,
                                    std::set<uint64_t> *Addrs) {
  Triple TheTriple("unknown-unknown-unknown");
  TheTriple.setArch(Triple::ArchType(O.getArch()));
  auto TripleName = TheTriple.getTriple();

  std::string Error;
  const Target *TheTarget = TargetRegistry::lookupTarget(TripleName, Error);
  FailIfNotEmpty(Error);

  std::unique_ptr<const MCSubtargetInfo> STI(
      TheTarget->createMCSubtargetInfo(TripleName, "", ""));
  FailIfEmpty(STI, "no subtarget info for target " + TripleName);

  std::unique_ptr<const MCRegisterInfo> MRI(
      TheTarget->createMCRegInfo(TripleName));
  FailIfEmpty(MRI, "no register info for target " + TripleName);

  std::unique_ptr<const MCAsmInfo> AsmInfo(
      TheTarget->createMCAsmInfo(*MRI, TripleName));
  FailIfEmpty(AsmInfo, "no asm info for target " + TripleName);

  std::unique_ptr<const MCObjectFileInfo> MOFI(new MCObjectFileInfo);
  MCContext Ctx(AsmInfo.get(), MRI.get(), MOFI.get());
  std::unique_ptr<MCDisassembler> DisAsm(
      TheTarget->createMCDisassembler(*STI, Ctx));
  FailIfEmpty(DisAsm, "no disassembler info for target " + TripleName);

  std::unique_ptr<const MCInstrInfo> MII(TheTarget->createMCInstrInfo());
  FailIfEmpty(MII, "no instruction info for target " + TripleName);

  std::unique_ptr<const MCInstrAnalysis> MIA(
      TheTarget->createMCInstrAnalysis(MII.get()));
  FailIfEmpty(MIA, "no instruction analysis info for target " + TripleName);

  auto SanCovAddrs = findSanitizerCovFunctions(O);

  for (const auto Section : O.sections()) {
    if (Section.isVirtual() || !Section.isText()) // llvm-objdump does the same.
      continue;
    uint64_t SectionAddr = Section.getAddress();
    uint64_t SectSize = Section.getSize();
    if (!SectSize)
      continue;

    StringRef SectionName;
    FailIfError(Section.getName(SectionName));

    StringRef BytesStr;
    FailIfError(Section.getContents(BytesStr));
    ArrayRef<uint8_t> Bytes(reinterpret_cast<const uint8_t *>(BytesStr.data()),
                            BytesStr.size());

    for (uint64_t Index = 0, Size = 0; Index < Section.getSize();
         Index += Size) {
      MCInst Inst;
      if (!DisAsm->getInstruction(Inst, Size, Bytes.slice(Index),
                                  SectionAddr + Index, nulls(), nulls())) {
        if (Size == 0)
          Size = 1;
        continue;
      }
      uint64_t Target;
      if (MIA->isCall(Inst) &&
          MIA->evaluateBranch(Inst, SectionAddr + Index, Size, Target)) {
        if (SanCovAddrs.find(Target) != SanCovAddrs.end()) {
          // Sanitizer coverage uses the address of the next instruction - 1.
          Addrs->insert(Index + SectionAddr + Size - 1);
        }
      }
    }
  }
}

static void getArchiveCoveragePoints(const object::Archive &A,
                                     std::set<uint64_t> *Addrs) {
  for (auto &ErrorOrChild : A.children()) {
    FailIfError(ErrorOrChild);
    const object::Archive::Child &C = *ErrorOrChild;
    ErrorOr<std::unique_ptr<object::Binary>> ChildOrErr = C.getAsBinary();
    FailIfError(ChildOrErr);
    if (object::ObjectFile *O =
            dyn_cast<object::ObjectFile>(&*ChildOrErr.get()))
      getObjectCoveragePoints(*O, Addrs);
    else
      FailIfError(object::object_error::invalid_file_type);
  }
}

// Locate addresses of all coverage points in a file. Coverage point
// is defined as the 'address of instruction following __sanitizer_cov
// call - 1'.
std::set<uint64_t> getCoveragePoints(std::string FileName) {
  std::set<uint64_t> Result;

  ErrorOr<object::OwningBinary<object::Binary>> BinaryOrErr =
      object::createBinary(FileName);
  FailIfError(BinaryOrErr);

  object::Binary &Binary = *BinaryOrErr.get().getBinary();
  if (object::Archive *A = dyn_cast<object::Archive>(&Binary))
    getArchiveCoveragePoints(*A, &Result);
  else if (object::ObjectFile *O = dyn_cast<object::ObjectFile>(&Binary))
    getObjectCoveragePoints(*O, &Result);
  else
    FailIfError(object::object_error::invalid_file_type);

  return Result;
}

static std::unique_ptr<SpecialCaseList> createDefaultBlacklist() {
  if (!ClUseDefaultBlacklist) 
    return std::unique_ptr<SpecialCaseList>();
  std::unique_ptr<MemoryBuffer> MB =
      MemoryBuffer::getMemBuffer(DefaultBlacklist);
  std::string Error;
  auto Blacklist = SpecialCaseList::create(MB.get(), Error);
  FailIfNotEmpty(Error);
  return Blacklist;
}

static std::unique_ptr<SpecialCaseList> createUserBlacklist() {
  if (ClBlacklist.empty())
    return std::unique_ptr<SpecialCaseList>();

  return SpecialCaseList::createOrDie({{ClBlacklist}});
}

static void printFunctionLocs(const std::set<FunctionLoc> &FnLocs,
                              raw_ostream &OS) {
  std::unique_ptr<SpecialCaseList> DefaultBlacklist = createDefaultBlacklist();
  std::unique_ptr<SpecialCaseList> UserBlacklist = createUserBlacklist();

  for (const FunctionLoc &FnLoc : FnLocs) {
    if (DefaultBlacklist &&
        DefaultBlacklist->inSection("fun", FnLoc.FunctionName))
      continue;
    if (DefaultBlacklist &&
        DefaultBlacklist->inSection("src", FnLoc.Loc.FileName))
      continue;
    if (UserBlacklist && UserBlacklist->inSection("fun", FnLoc.FunctionName))
      continue;
    if (UserBlacklist && UserBlacklist->inSection("src", FnLoc.Loc.FileName))
      continue;

    OS << stripPathPrefix(FnLoc.Loc.FileName) << ":" << FnLoc.Loc.Line << " "
       << FnLoc.FunctionName << "\n";
  }
}

class CoverageData {
 public:
  // Read single file coverage data.
  static ErrorOr<std::unique_ptr<CoverageData>> read(std::string FileName) {
    ErrorOr<std::unique_ptr<MemoryBuffer>> BufOrErr =
        MemoryBuffer::getFile(FileName);
    if (!BufOrErr)
      return BufOrErr.getError();
    std::unique_ptr<MemoryBuffer> Buf = std::move(BufOrErr.get());
    if (Buf->getBufferSize() < 8) {
      errs() << "File too small (<8): " << Buf->getBufferSize();
      return make_error_code(errc::illegal_byte_sequence);
    }
    const FileHeader *Header =
        reinterpret_cast<const FileHeader *>(Buf->getBufferStart());

    if (Header->Magic != BinCoverageMagic) {
      errs() << "Wrong magic: " << Header->Magic;
      return make_error_code(errc::illegal_byte_sequence);
    }

    auto Addrs = llvm::make_unique<std::set<uint64_t>>();

    switch (Header->Bitness) {
    case Bitness64:
      readInts<uint64_t>(Buf->getBufferStart() + 8, Buf->getBufferEnd(),
                         Addrs.get());
      break;
    case Bitness32:
      readInts<uint32_t>(Buf->getBufferStart() + 8, Buf->getBufferEnd(),
                         Addrs.get());
      break;
    default:
      errs() << "Unsupported bitness: " << Header->Bitness;
      return make_error_code(errc::illegal_byte_sequence);
    }

    return std::unique_ptr<CoverageData>(new CoverageData(std::move(Addrs)));
  }

  // Merge multiple coverage data together.
  static std::unique_ptr<CoverageData>
  merge(const std::vector<std::unique_ptr<CoverageData>> &Covs) {
    auto Addrs = llvm::make_unique<std::set<uint64_t>>();

    for (const auto &Cov : Covs)
      Addrs->insert(Cov->Addrs->begin(), Cov->Addrs->end());

    return std::unique_ptr<CoverageData>(new CoverageData(std::move(Addrs)));
  }

  // Read list of files and merges their coverage info.
  static ErrorOr<std::unique_ptr<CoverageData>>
  readAndMerge(const std::vector<std::string> &FileNames) {
    std::vector<std::unique_ptr<CoverageData>> Covs;
    for (const auto &FileName : FileNames) {
      auto Cov = read(FileName);
      if (!Cov)
        return Cov.getError();
      Covs.push_back(std::move(Cov.get()));
    }
    return merge(Covs);
  }

  // Print coverage addresses.
  void printAddrs(raw_ostream &OS) {
    for (auto Addr : *Addrs) {
      OS << "0x";
      OS.write_hex(Addr);
      OS << "\n";
    }
  }

  // Print list of covered functions.
  // Line format: <file_name>:<line> <function_name>
  void printCoveredFunctions(raw_ostream &OS) {
    printFunctionLocs(computeFunctionLocs(*Addrs), OS);
  }

  // Print list of not covered functions.
  // Line format: <file_name>:<line> <function_name>
  void printNotCoveredFunctions(raw_ostream &OS) {
    std::set<FunctionLoc> AllFns =
        computeFunctionLocs(getCoveragePoints(ClBinaryName));
    std::set<FunctionLoc> CoveredFns = computeFunctionLocs(*Addrs);

    std::set<FunctionLoc> NotCoveredFns;
    std::set_difference(AllFns.begin(), AllFns.end(), CoveredFns.begin(),
                        CoveredFns.end(),
                        std::inserter(NotCoveredFns, NotCoveredFns.end()));
    printFunctionLocs(NotCoveredFns, OS);
  }

private:
  explicit CoverageData(std::unique_ptr<std::set<uint64_t>> Addrs)
      : Addrs(std::move(Addrs)) {}

  std::unique_ptr<std::set<uint64_t>> Addrs;
};
} // namespace

int main(int argc, char **argv) {
  // Print stack trace if we signal out.
  sys::PrintStackTraceOnErrorSignal();
  PrettyStackTraceProgram X(argc, argv);
  llvm_shutdown_obj Y; // Call llvm_shutdown() on exit.

  llvm::InitializeAllTargetInfos();
  llvm::InitializeAllTargetMCs();
  llvm::InitializeAllDisassemblers();

  cl::ParseCommandLineOptions(argc, argv, "Sanitizer Coverage Processing Tool");

  auto CovData = CoverageData::readAndMerge(ClInputFiles);
  FailIfError(CovData);

  switch (Action) {
  case PrintAction: {
    CovData.get()->printAddrs(outs());
    return 0;
  }
  case CoveredFunctionsAction: {
    CovData.get()->printCoveredFunctions(outs());
    return 0;
  }
  case NotCoveredFunctionsAction: {
    CovData.get()->printNotCoveredFunctions(outs());
    return 0;
  }
  }

  llvm_unreachable("unsupported action");
}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@a13 1
#include "llvm/ADT/Twine.h"
d17 1
a17 1
#include "llvm/MC/MCDisassembler/MCDisassembler.h"
a26 1
#include "llvm/Object/ELFObjectFile.h"
a27 1
#include "llvm/Support/Casting.h"
a32 1
#include "llvm/Support/MD5.h"
a36 1
#include "llvm/Support/Regex.h"
a43 1
#include <algorithm>
a46 1
#include <utility>
a56 1
  PrintCovPointsAction,
d58 1
a58 3
  NotCoveredFunctionsAction,
  HtmlReportAction,
  StatsAction
a63 2
               clEnumValN(PrintCovPointsAction, "print-coverage-pcs",
                          "Print coverage instrumentation points addresses."),
a67 4
               clEnumValN(HtmlReportAction, "html-report",
                          "Print HTML coverage report."),
               clEnumValN(StatsAction, "print-coverage-stats",
                          "Print coverage statistics."),
d70 2
a71 3
static cl::list<std::string>
    ClInputFiles(cl::Positional, cl::OneOrMore,
                 cl::desc("(<binary file>|<.sancov file>)..."));
d73 7
a79 2
static cl::opt<bool> ClDemangle("demangle", cl::init(true),
                                cl::desc("Print demangled function name."));
d93 1
a93 3
static const char *const DefaultBlacklistStr = "fun:__sanitizer_.*\n"
                                               "src:/usr/include/.*\n"
                                               "src:.*/libc\\+\\+/.*\n";
d106 1
a106 6
// --------- ERROR HANDLING ---------

static void Fail(const llvm::Twine &E) {
  errs() << "Error: " << E << "\n";
  exit(1);
}
d119 2
a120 13
static void FailIfError(Error Err) {
  if (Err) {
    logAllUnhandledErrors(std::move(Err), errs(), "Error: ");
    exit(1);
  }
}

template <typename T> static void FailIfError(Expected<T> &E) {
  FailIfError(E.takeError());
}

static void FailIfNotEmpty(const llvm::Twine &E) {
  if (E.str().empty())
d122 2
a123 1
  Fail(E);
d131 2
a132 18
  Fail(Message);
}

// ---------

// Produces std::map<K, std::vector<E>> grouping input
// elements by FuncTy result.
template <class RangeTy, class FuncTy>
static inline auto group_by(const RangeTy &R, FuncTy F)
    -> std::map<typename std::decay<decltype(F(*R.begin()))>::type,
                std::vector<typename std::decay<decltype(*R.begin())>::type>> {
  std::map<typename std::decay<decltype(F(*R.begin()))>::type,
           std::vector<typename std::decay<decltype(*R.begin())>::type>>
      Result;
  for (const auto &E : R) {
    Result[F(E)].push_back(E);
  }
  return Result;
d152 2
a153 12
struct FileFn {
  bool operator<(const FileFn &RHS) const {
    return std::tie(FileName, FunctionName) <
           std::tie(RHS.FileName, RHS.FunctionName);
  }

  std::string FileName;
  std::string FunctionName;
};

struct FnLoc {
  bool operator<(const FnLoc &RHS) const {
d170 5
a174 1
static std::unique_ptr<symbolize::LLVMSymbolizer> createSymbolizer() {
d178 1
a178 3
  return std::unique_ptr<symbolize::LLVMSymbolizer>(
      new symbolize::LLVMSymbolizer(SymbolizerOptions));
}
d180 11
a190 6
// A DILineInfo with address.
struct AddrInfo : public DILineInfo {
  uint64_t Addr;

  AddrInfo(const DILineInfo &DI, uint64_t Addr) : DILineInfo(DI), Addr(Addr) {
    FileName = normalizeFilename(FileName);
d193 2
a194 7
private:
  static std::string normalizeFilename(const std::string &FileName) {
    SmallString<256> S(FileName);
    sys::path::remove_dots(S, /* remove_dot_dot */ true);
    return S.str().str();
  }
};
d196 4
a199 19
class Blacklists {
public:
  Blacklists()
      : DefaultBlacklist(createDefaultBlacklist()),
        UserBlacklist(createUserBlacklist()) {}

  // AddrInfo contains normalized filename. It is important to check it rather
  // than DILineInfo.
  bool isBlacklisted(const AddrInfo &AI) {
    if (DefaultBlacklist && DefaultBlacklist->inSection("fun", AI.FunctionName))
      return true;
    if (DefaultBlacklist && DefaultBlacklist->inSection("src", AI.FileName))
      return true;
    if (UserBlacklist && UserBlacklist->inSection("fun", AI.FunctionName))
      return true;
    if (UserBlacklist && UserBlacklist->inSection("src", AI.FileName))
      return true;
    return false;
  }
d201 3
a203 11
private:
  static std::unique_ptr<SpecialCaseList> createDefaultBlacklist() {
    if (!ClUseDefaultBlacklist)
      return std::unique_ptr<SpecialCaseList>();
    std::unique_ptr<MemoryBuffer> MB =
        MemoryBuffer::getMemBuffer(DefaultBlacklistStr);
    std::string Error;
    auto Blacklist = SpecialCaseList::create(MB.get(), Error);
    FailIfNotEmpty(Error);
    return Blacklist;
  }
d205 3
a207 3
  static std::unique_ptr<SpecialCaseList> createUserBlacklist() {
    if (ClBlacklist.empty())
      return std::unique_ptr<SpecialCaseList>();
d209 3
a211 5
    return SpecialCaseList::createOrDie({{ClBlacklist}});
  }
  std::unique_ptr<SpecialCaseList> DefaultBlacklist;
  std::unique_ptr<SpecialCaseList> UserBlacklist;
};
d213 2
a214 7
// Collect all debug info for given addresses.
static std::vector<AddrInfo> getAddrInfo(const std::string &ObjectFile,
                                         const std::set<uint64_t> &Addrs,
                                         bool InlinedCode) {
  std::vector<AddrInfo> Result;
  auto Symbolizer(createSymbolizer());
  Blacklists B;
d216 1
a216 18
  for (auto Addr : Addrs) {
    auto LineInfo = Symbolizer->symbolizeCode(ObjectFile, Addr);
    FailIfError(LineInfo);
    auto LineAddrInfo = AddrInfo(*LineInfo, Addr);
    if (B.isBlacklisted(LineAddrInfo))
      continue;
    Result.push_back(LineAddrInfo);
    if (InlinedCode) {
      auto InliningInfo = Symbolizer->symbolizeInlinedCode(ObjectFile, Addr);
      FailIfError(InliningInfo);
      for (uint32_t I = 0; I < InliningInfo->getNumberOfFrames(); ++I) {
        auto FrameInfo = InliningInfo->getFrame(I);
        auto FrameAddrInfo = AddrInfo(FrameInfo, Addr);
        if (B.isBlacklisted(FrameAddrInfo))
          continue;
        Result.push_back(FrameAddrInfo);
      }
    }
d229 2
a230 2
    Expected<uint64_t> AddressOrErr = Symbol.getAddress();
    FailIfError(errorToErrorCode(AddressOrErr.takeError()));
d232 2
a233 2
    Expected<StringRef> NameOrErr = Symbol.getName();
    FailIfError(errorToErrorCode(NameOrErr.takeError()));
d238 1
a238 2
      if (!(Symbol.getFlags() & object::BasicSymbolRef::SF_Undefined))
        Result.insert(AddressOrErr.get());
d242 3
a286 2
  if (SanCovAddrs.empty())
    Fail("__sanitizer_cov* functions not found");
d288 1
a288 1
  for (object::SectionRef Section : O.sections()) {
d296 3
a312 3
      uint64_t Addr = Index + SectionAddr;
      // Sanitizer coverage uses the address of the next instruction - 1.
      uint64_t CovPoint = Addr + Size - 1;
d315 6
a320 3
          MIA->evaluateBranch(Inst, SectionAddr + Index, Size, Target) &&
          SanCovAddrs.find(Target) != SanCovAddrs.end())
        Addrs->insert(CovPoint);
d325 10
a334 9
static void
visitObjectFiles(const object::Archive &A,
                 function_ref<void(const object::ObjectFile &)> Fn) {
  Error Err;
  for (auto &C : A.children(Err)) {
    Expected<std::unique_ptr<object::Binary>> ChildOrErr = C.getAsBinary();
    FailIfError(errorToErrorCode(ChildOrErr.takeError()));
    if (auto *O = dyn_cast<object::ObjectFile>(&*ChildOrErr.get()))
      Fn(*O);
a337 1
  FailIfError(std::move(Err));
d340 7
a346 4
static void
visitObjectFiles(const std::string &FileName,
                 function_ref<void(const object::ObjectFile &)> Fn) {
  Expected<object::OwningBinary<object::Binary>> BinaryOrErr =
d348 1
a348 2
  if (!BinaryOrErr)
    FailIfError(errorToErrorCode(BinaryOrErr.takeError()));
d352 1
a352 1
    visitObjectFiles(*A, Fn);
d354 1
a354 1
    Fn(*O);
a356 1
}
a357 6
std::set<uint64_t> findSanitizerCovFunctions(const std::string &FileName) {
  std::set<uint64_t> Result;
  visitObjectFiles(FileName, [&](const object::ObjectFile &O) {
    auto Addrs = findSanitizerCovFunctions(O);
    Result.insert(Addrs.begin(), Addrs.end());
  });
d361 9
a369 9
// Locate addresses of all coverage points in a file. Coverage point
// is defined as the 'address of instruction following __sanitizer_cov
// call - 1'.
std::set<uint64_t> getCoveragePoints(const std::string &FileName) {
  std::set<uint64_t> Result;
  visitObjectFiles(FileName, [&](const object::ObjectFile &O) {
    getObjectCoveragePoints(O, &Result);
  });
  return Result;
d372 3
a374 7
static void printCovPoints(const std::string &ObjFile, raw_ostream &OS) {
  for (uint64_t Addr : getCoveragePoints(ObjFile)) {
    OS << "0x";
    OS.write_hex(Addr);
    OS << "\n";
  }
}
d376 1
a376 26
static std::string escapeHtml(const std::string &S) {
  std::string Result;
  Result.reserve(S.size());
  for (char Ch : S) {
    switch (Ch) {
    case '&':
      Result.append("&amp;");
      break;
    case '\'':
      Result.append("&apos;");
      break;
    case '"':
      Result.append("&quot;");
      break;
    case '<':
      Result.append("&lt;");
      break;
    case '>':
      Result.append("&gt;");
      break;
    default:
      Result.push_back(Ch);
      break;
    }
  }
  return Result;
d379 4
a382 9
// Adds leading zeroes wrapped in 'lz' style.
// Leading zeroes help locate 000% coverage.
static std::string formatHtmlPct(size_t Pct) {
  Pct = std::max(std::size_t{0}, std::min(std::size_t{100}, Pct));

  std::string Num = std::to_string(Pct);
  std::string Zeroes(3 - Num.size(), '0');
  if (!Zeroes.empty())
    Zeroes = "<span class='lz'>" + Zeroes + "</span>";
d384 11
a394 2
  return Zeroes + Num;
}
d396 2
a397 23
static std::string anchorName(const std::string &Anchor) {
  llvm::MD5 Hasher;
  llvm::MD5::MD5Result Hash;
  Hasher.update(Anchor);
  Hasher.final(Hash);

  SmallString<32> HexString;
  llvm::MD5::stringifyResult(Hash, HexString);
  return HexString.str().str();
}

static ErrorOr<bool> isCoverageFile(const std::string &FileName) {
  ErrorOr<std::unique_ptr<MemoryBuffer>> BufOrErr =
      MemoryBuffer::getFile(FileName);
  if (!BufOrErr) {
    errs() << "Warning: " << BufOrErr.getError().message() << "("
           << BufOrErr.getError().value()
           << "), filename: " << llvm::sys::path::filename(FileName) << "\n";
    return BufOrErr.getError();
  }
  std::unique_ptr<MemoryBuffer> Buf = std::move(BufOrErr.get());
  if (Buf->getBufferSize() < 8) {
    return false;
a398 20
  const FileHeader *Header =
      reinterpret_cast<const FileHeader *>(Buf->getBufferStart());
  return Header->Magic == BinCoverageMagic;
}

struct CoverageStats {
  CoverageStats() : AllPoints(0), CovPoints(0), AllFns(0), CovFns(0) {}

  size_t AllPoints;
  size_t CovPoints;
  size_t AllFns;
  size_t CovFns;
};

static raw_ostream &operator<<(raw_ostream &OS, const CoverageStats &Stats) {
  OS << "all-edges: " << Stats.AllPoints << "\n";
  OS << "cov-edges: " << Stats.CovPoints << "\n";
  OS << "all-functions: " << Stats.AllFns << "\n";
  OS << "cov-functions: " << Stats.CovFns << "\n";
  return OS;
d402 1
a402 1
public:
d404 1
a404 2
  static ErrorOr<std::unique_ptr<CoverageData>>
  read(const std::string &FileName) {
a473 225
protected:
  explicit CoverageData(std::unique_ptr<std::set<uint64_t>> Addrs)
      : Addrs(std::move(Addrs)) {}

  friend class CoverageDataWithObjectFile;

  std::unique_ptr<std::set<uint64_t>> Addrs;
};

// Coverage data translated into source code line-level information.
// Fetches debug info in constructor and calculates various information per
// request.
class SourceCoverageData {
public:
  enum LineStatus {
    // coverage information for the line is not available.
    // default value in maps.
    UNKNOWN = 0,
    // the line is fully covered.
    COVERED = 1,
    // the line is fully uncovered.
    NOT_COVERED = 2,
    // some points in the line a covered, some are not.
    MIXED = 3
  };

  SourceCoverageData(std::string ObjectFile, const std::set<uint64_t> &Addrs)
      : AllCovPoints(getCoveragePoints(ObjectFile)) {
    if (!std::includes(AllCovPoints.begin(), AllCovPoints.end(), Addrs.begin(),
                       Addrs.end())) {
      Fail("Coverage points in binary and .sancov file do not match.");
    }

    AllAddrInfo = getAddrInfo(ObjectFile, AllCovPoints, true);
    CovAddrInfo = getAddrInfo(ObjectFile, Addrs, true);
  }

  // Compute number of coverage points hit/total in a file.
  // file_name -> <coverage, all_coverage>
  std::map<std::string, std::pair<size_t, size_t>> computeFileCoverage() {
    std::map<std::string, std::pair<size_t, size_t>> FileCoverage;
    auto AllCovPointsByFile =
        group_by(AllAddrInfo, [](const AddrInfo &AI) { return AI.FileName; });
    auto CovPointsByFile =
        group_by(CovAddrInfo, [](const AddrInfo &AI) { return AI.FileName; });

    for (const auto &P : AllCovPointsByFile) {
      const std::string &FileName = P.first;

      FileCoverage[FileName] =
          std::make_pair(CovPointsByFile[FileName].size(),
                         AllCovPointsByFile[FileName].size());
    }
    return FileCoverage;
  }

  // line_number -> line_status.
  typedef std::map<int, LineStatus> LineStatusMap;
  // file_name -> LineStatusMap
  typedef std::map<std::string, LineStatusMap> FileLineStatusMap;

  // fills in the {file_name -> {line_no -> status}} map.
  FileLineStatusMap computeLineStatusMap() {
    FileLineStatusMap StatusMap;

    auto AllLocs = group_by(AllAddrInfo, [](const AddrInfo &AI) {
      return FileLoc{AI.FileName, AI.Line};
    });
    auto CovLocs = group_by(CovAddrInfo, [](const AddrInfo &AI) {
      return FileLoc{AI.FileName, AI.Line};
    });

    for (const auto &P : AllLocs) {
      const FileLoc &Loc = P.first;
      auto I = CovLocs.find(Loc);

      if (I == CovLocs.end()) {
        StatusMap[Loc.FileName][Loc.Line] = NOT_COVERED;
      } else {
        StatusMap[Loc.FileName][Loc.Line] =
            (I->second.size() == P.second.size()) ? COVERED : MIXED;
      }
    }
    return StatusMap;
  }

  std::set<FileFn> computeAllFunctions() const {
    std::set<FileFn> Fns;
    for (const auto &AI : AllAddrInfo) {
      Fns.insert(FileFn{AI.FileName, AI.FunctionName});
    }
    return Fns;
  }

  std::set<FileFn> computeCoveredFunctions() const {
    std::set<FileFn> Fns;
    auto CovFns = group_by(CovAddrInfo, [](const AddrInfo &AI) {
      return FileFn{AI.FileName, AI.FunctionName};
    });

    for (const auto &P : CovFns) {
      Fns.insert(P.first);
    }
    return Fns;
  }

  std::set<FileFn> computeNotCoveredFunctions() const {
    std::set<FileFn> Fns;

    auto AllFns = group_by(AllAddrInfo, [](const AddrInfo &AI) {
      return FileFn{AI.FileName, AI.FunctionName};
    });
    auto CovFns = group_by(CovAddrInfo, [](const AddrInfo &AI) {
      return FileFn{AI.FileName, AI.FunctionName};
    });

    for (const auto &P : AllFns) {
      if (CovFns.find(P.first) == CovFns.end()) {
        Fns.insert(P.first);
      }
    }
    return Fns;
  }

  // Compute % coverage for each function.
  std::map<FileFn, int> computeFunctionsCoverage() const {
    std::map<FileFn, int> FnCoverage;
    auto AllFns = group_by(AllAddrInfo, [](const AddrInfo &AI) {
      return FileFn{AI.FileName, AI.FunctionName};
    });

    auto CovFns = group_by(CovAddrInfo, [](const AddrInfo &AI) {
      return FileFn{AI.FileName, AI.FunctionName};
    });

    for (const auto &P : AllFns) {
      FileFn F = P.first;
      FnCoverage[F] = CovFns[F].size() * 100 / P.second.size();
    }

    return FnCoverage;
  }

  typedef std::map<FileLoc, std::set<std::string>> FunctionLocs;
  // finds first line number in a file for each function.
  FunctionLocs resolveFunctions(const std::set<FileFn> &Fns) const {
    std::vector<AddrInfo> FnAddrs;
    for (const auto &AI : AllAddrInfo) {
      if (Fns.find(FileFn{AI.FileName, AI.FunctionName}) != Fns.end())
        FnAddrs.push_back(AI);
    }

    auto GroupedAddrs = group_by(FnAddrs, [](const AddrInfo &AI) {
      return FnLoc{FileLoc{AI.FileName, AI.Line}, AI.FunctionName};
    });

    FunctionLocs Result;
    std::string LastFileName;
    std::set<std::string> ProcessedFunctions;

    for (const auto &P : GroupedAddrs) {
      const FnLoc &Loc = P.first;
      std::string FileName = Loc.Loc.FileName;
      std::string FunctionName = Loc.FunctionName;

      if (LastFileName != FileName)
        ProcessedFunctions.clear();
      LastFileName = FileName;

      if (!ProcessedFunctions.insert(FunctionName).second)
        continue;

      auto FLoc = FileLoc{FileName, Loc.Loc.Line};
      Result[FLoc].insert(FunctionName);
    }
    return Result;
  }

  std::set<std::string> files() const {
    std::set<std::string> Files;
    for (const auto &AI : AllAddrInfo) {
      Files.insert(AI.FileName);
    }
    return Files;
  }

  void collectStats(CoverageStats *Stats) const {
    Stats->AllPoints += AllCovPoints.size();
    Stats->AllFns += computeAllFunctions().size();
    Stats->CovFns += computeCoveredFunctions().size();
  }

private:
  const std::set<uint64_t> AllCovPoints;

  std::vector<AddrInfo> AllAddrInfo;
  std::vector<AddrInfo> CovAddrInfo;
};

static void printFunctionLocs(const SourceCoverageData::FunctionLocs &FnLocs,
                              raw_ostream &OS) {
  for (const auto &Fns : FnLocs) {
    for (const auto &Fn : Fns.second) {
      OS << stripPathPrefix(Fns.first.FileName) << ":" << Fns.first.Line << " "
         << Fn << "\n";
    }
  }
}

// Holder for coverage data + filename of corresponding object file.
class CoverageDataWithObjectFile : public CoverageData {
public:
  static ErrorOr<std::unique_ptr<CoverageDataWithObjectFile>>
  readAndMerge(const std::string &ObjectFile,
               const std::vector<std::string> &FileNames) {
    auto MergedDataOrError = CoverageData::readAndMerge(FileNames);
    if (!MergedDataOrError)
      return MergedDataOrError.getError();
    return std::unique_ptr<CoverageDataWithObjectFile>(
        new CoverageDataWithObjectFile(ObjectFile,
                                       std::move(MergedDataOrError.get())));
  }

  std::string object_file() const { return ObjectFile; }

d476 2
a477 4
  void printCoveredFunctions(raw_ostream &OS) const {
    SourceCoverageData SCovData(ObjectFile, *Addrs);
    auto CoveredFns = SCovData.computeCoveredFunctions();
    printFunctionLocs(SCovData.resolveFunctions(CoveredFns), OS);
d482 10
a491 143
  void printNotCoveredFunctions(raw_ostream &OS) const {
    SourceCoverageData SCovData(ObjectFile, *Addrs);
    auto NotCoveredFns = SCovData.computeNotCoveredFunctions();
    printFunctionLocs(SCovData.resolveFunctions(NotCoveredFns), OS);
  }

  void printReport(raw_ostream &OS) const {
    SourceCoverageData SCovData(ObjectFile, *Addrs);
    auto LineStatusMap = SCovData.computeLineStatusMap();

    std::set<FileFn> AllFns = SCovData.computeAllFunctions();
    // file_loc -> set[function_name]
    auto AllFnsByLoc = SCovData.resolveFunctions(AllFns);
    auto FileCoverage = SCovData.computeFileCoverage();

    auto FnCoverage = SCovData.computeFunctionsCoverage();
    auto FnCoverageByFile =
        group_by(FnCoverage, [](const std::pair<FileFn, int> &FileFn) {
          return FileFn.first.FileName;
        });

    // TOC

    size_t NotCoveredFilesCount = 0;
    std::set<std::string> Files = SCovData.files();

    // Covered Files.
    OS << "<details open><summary>Touched Files</summary>\n";
    OS << "<table>\n";
    OS << "<tr><th>File</th><th>Coverage %</th>";
    OS << "<th>Hit (Total) Fns</th></tr>\n";
    for (const auto &FileName : Files) {
      std::pair<size_t, size_t> FC = FileCoverage[FileName];
      if (FC.first == 0) {
        NotCoveredFilesCount++;
        continue;
      }
      size_t CovPct = FC.second == 0 ? 100 : 100 * FC.first / FC.second;

      OS << "<tr><td><a href=\"#" << anchorName(FileName) << "\">"
         << stripPathPrefix(FileName) << "</a></td>"
         << "<td>" << formatHtmlPct(CovPct) << "%</td>"
         << "<td>" << FC.first << " (" << FC.second << ")"
         << "</tr>\n";
    }
    OS << "</table>\n";
    OS << "</details>\n";

    // Not covered files.
    if (NotCoveredFilesCount) {
      OS << "<details><summary>Not Touched Files</summary>\n";
      OS << "<table>\n";
      for (const auto &FileName : Files) {
        std::pair<size_t, size_t> FC = FileCoverage[FileName];
        if (FC.first == 0)
          OS << "<tr><td>" << stripPathPrefix(FileName) << "</td>\n";
      }
      OS << "</table>\n";
      OS << "</details>\n";
    } else {
      OS << "<p>Congratulations! All source files are touched.</p>\n";
    }

    // Source
    for (const auto &FileName : Files) {
      std::pair<size_t, size_t> FC = FileCoverage[FileName];
      if (FC.first == 0)
        continue;
      OS << "<a name=\"" << anchorName(FileName) << "\"></a>\n";
      OS << "<h2>" << stripPathPrefix(FileName) << "</h2>\n";
      OS << "<details open><summary>Function Coverage</summary>";
      OS << "<div class='fnlist'>\n";

      auto &FileFnCoverage = FnCoverageByFile[FileName];

      for (const auto &P : FileFnCoverage) {
        std::string FunctionName = P.first.FunctionName;

        OS << "<div class='fn' style='order: " << P.second << "'>";
        OS << "<span class='pct'>" << formatHtmlPct(P.second)
           << "%</span>&nbsp;";
        OS << "<span class='name'><a href=\"#"
           << anchorName(FileName + "::" + FunctionName) << "\">";
        OS << escapeHtml(FunctionName) << "</a></span>";
        OS << "</div>\n";
      }
      OS << "</div></details>\n";

      ErrorOr<std::unique_ptr<MemoryBuffer>> BufOrErr =
          MemoryBuffer::getFile(FileName);
      if (!BufOrErr) {
        OS << "Error reading file: " << FileName << " : "
           << BufOrErr.getError().message() << "("
           << BufOrErr.getError().value() << ")\n";
        continue;
      }

      OS << "<pre>\n";
      const auto &LineStatuses = LineStatusMap[FileName];
      for (line_iterator I = line_iterator(*BufOrErr.get(), false);
           !I.is_at_eof(); ++I) {
        uint32_t Line = I.line_number();
        { // generate anchors (if any);
          FileLoc Loc = FileLoc{FileName, Line};
          auto It = AllFnsByLoc.find(Loc);
          if (It != AllFnsByLoc.end()) {
            for (const std::string &Fn : It->second) {
              OS << "<a name=\"" << anchorName(FileName + "::" + Fn)
                 << "\"></a>";
            };
          }
        }

        OS << "<span ";
        auto LIT = LineStatuses.find(I.line_number());
        auto Status = (LIT != LineStatuses.end()) ? LIT->second
                                                  : SourceCoverageData::UNKNOWN;
        switch (Status) {
        case SourceCoverageData::UNKNOWN:
          OS << "class=unknown";
          break;
        case SourceCoverageData::COVERED:
          OS << "class=covered";
          break;
        case SourceCoverageData::NOT_COVERED:
          OS << "class=notcovered";
          break;
        case SourceCoverageData::MIXED:
          OS << "class=mixed";
          break;
        }
        OS << ">";
        OS << escapeHtml(*I) << "</span>\n";
      }
      OS << "</pre>\n";
    }
  }

  void collectStats(CoverageStats *Stats) const {
    Stats->CovPoints += Addrs->size();

    SourceCoverageData SCovData(ObjectFile, *Addrs);
    SCovData.collectStats(Stats);
d495 2
a496 6
  CoverageDataWithObjectFile(std::string ObjectFile,
                             std::unique_ptr<CoverageData> Coverage)
      : CoverageData(std::move(Coverage->Addrs)),
        ObjectFile(std::move(ObjectFile)) {}
  const std::string ObjectFile;
};
d498 1
a498 169
// Multiple coverage files data organized by object file.
class CoverageDataSet {
public:
  static ErrorOr<std::unique_ptr<CoverageDataSet>>
  readCmdArguments(std::vector<std::string> FileNames) {
    // Short name => file name.
    std::map<std::string, std::string> ObjFiles;
    std::string FirstObjFile;
    std::set<std::string> CovFiles;

    // Partition input values into coverage/object files.
    for (const auto &FileName : FileNames) {
      auto ErrorOrIsCoverage = isCoverageFile(FileName);
      if (!ErrorOrIsCoverage)
        continue;
      if (ErrorOrIsCoverage.get()) {
        CovFiles.insert(FileName);
      } else {
        auto ShortFileName = llvm::sys::path::filename(FileName);
        if (ObjFiles.find(ShortFileName) != ObjFiles.end()) {
          Fail("Duplicate binary file with a short name: " + ShortFileName);
        }

        ObjFiles[ShortFileName] = FileName;
        if (FirstObjFile.empty())
          FirstObjFile = FileName;
      }
    }

    Regex SancovRegex("(.*)\\.[0-9]+\\.sancov");
    SmallVector<StringRef, 2> Components;

    // Object file => list of corresponding coverage file names.
    auto CoverageByObjFile = group_by(CovFiles, [&](std::string FileName) {
      auto ShortFileName = llvm::sys::path::filename(FileName);
      auto Ok = SancovRegex.match(ShortFileName, &Components);
      if (!Ok) {
        Fail("Can't match coverage file name against "
             "<module_name>.<pid>.sancov pattern: " +
             FileName);
      }

      auto Iter = ObjFiles.find(Components[1]);
      if (Iter == ObjFiles.end()) {
        Fail("Object file for coverage not found: " + FileName);
      }
      return Iter->second;
    });

    // Read coverage.
    std::vector<std::unique_ptr<CoverageDataWithObjectFile>> MergedCoverage;
    for (const auto &Pair : CoverageByObjFile) {
      if (findSanitizerCovFunctions(Pair.first).empty()) {
        for (const auto &FileName : Pair.second) {
          CovFiles.erase(FileName);
        }

        errs()
            << "Ignoring " << Pair.first
            << " and its coverage because  __sanitizer_cov* functions were not "
               "found.\n";
        continue;
      }

      auto DataOrError =
          CoverageDataWithObjectFile::readAndMerge(Pair.first, Pair.second);
      FailIfError(DataOrError);
      MergedCoverage.push_back(std::move(DataOrError.get()));
    }

    return std::unique_ptr<CoverageDataSet>(
        new CoverageDataSet(FirstObjFile, &MergedCoverage, CovFiles));
  }

  void printCoveredFunctions(raw_ostream &OS) const {
    for (const auto &Cov : Coverage) {
      Cov->printCoveredFunctions(OS);
    }
  }

  void printNotCoveredFunctions(raw_ostream &OS) const {
    for (const auto &Cov : Coverage) {
      Cov->printNotCoveredFunctions(OS);
    }
  }

  void printStats(raw_ostream &OS) const {
    CoverageStats Stats;
    for (const auto &Cov : Coverage) {
      Cov->collectStats(&Stats);
    }
    OS << Stats;
  }

  void printReport(raw_ostream &OS) const {
    auto Title =
        (llvm::sys::path::filename(MainObjFile) + " Coverage Report").str();

    OS << "<html>\n";
    OS << "<head>\n";

    // Stylesheet
    OS << "<style>\n";
    OS << ".covered { background: #7F7; }\n";
    OS << ".notcovered { background: #F77; }\n";
    OS << ".mixed { background: #FF7; }\n";
    OS << "summary { font-weight: bold; }\n";
    OS << "details > summary + * { margin-left: 1em; }\n";
    OS << ".fnlist { display: flex; flex-flow: column nowrap; }\n";
    OS << ".fn { display: flex; flex-flow: row nowrap; }\n";
    OS << ".pct { width: 3em; text-align: right; margin-right: 1em; }\n";
    OS << ".name { flex: 2; }\n";
    OS << ".lz { color: lightgray; }\n";
    OS << "</style>\n";
    OS << "<title>" << Title << "</title>\n";
    OS << "</head>\n";
    OS << "<body>\n";

    // Title
    OS << "<h1>" << Title << "</h1>\n";

    // Modules TOC.
    if (Coverage.size() > 1) {
      for (const auto &CovData : Coverage) {
        OS << "<li><a href=\"#module_" << anchorName(CovData->object_file())
           << "\">" << llvm::sys::path::filename(CovData->object_file())
           << "</a></li>\n";
      }
    }

    for (const auto &CovData : Coverage) {
      if (Coverage.size() > 1) {
        OS << "<h2>" << llvm::sys::path::filename(CovData->object_file())
           << "</h2>\n";
      }
      OS << "<a name=\"module_" << anchorName(CovData->object_file())
         << "\"></a>\n";
      CovData->printReport(OS);
    }

    // About
    OS << "<details><summary>About</summary>\n";
    OS << "Coverage files:<ul>";
    for (const auto &InputFile : CoverageFiles) {
      llvm::sys::fs::file_status Status;
      llvm::sys::fs::status(InputFile, Status);
      OS << "<li>" << stripPathPrefix(InputFile) << " ("
         << Status.getLastModificationTime().str() << ")</li>\n";
    }
    OS << "</ul></details>\n";

    OS << "</body>\n";
    OS << "</html>\n";
  }

  bool empty() const { return Coverage.empty(); }

private:
  explicit CoverageDataSet(
      const std::string &MainObjFile,
      std::vector<std::unique_ptr<CoverageDataWithObjectFile>> *Data,
      const std::set<std::string> &CoverageFiles)
      : MainObjFile(MainObjFile), CoverageFiles(CoverageFiles) {
    Data->swap(this->Coverage);
  }

  const std::string MainObjFile;
  std::vector<std::unique_ptr<CoverageDataWithObjectFile>> Coverage;
  const std::set<std::string> CoverageFiles;
a499 1

d504 1
a504 1
  sys::PrintStackTraceOnErrorSignal(argv[0]);
d514 5
a518 4
  // -print doesn't need object files.
  if (Action == PrintAction) {
    auto CovData = CoverageData::readAndMerge(ClInputFiles);
    FailIfError(CovData);
a520 13
  } else if (Action == PrintCovPointsAction) {
    // -print-coverage-points doesn't need coverage files.
    for (const std::string &ObjFile : ClInputFiles) {
      printCovPoints(ObjFile, outs());
    }
    return 0;
  }

  auto CovDataSet = CoverageDataSet::readCmdArguments(ClInputFiles);
  FailIfError(CovDataSet);

  if (CovDataSet.get()->empty()) {
    Fail("No coverage files specified.");
a521 2

  switch (Action) {
d523 1
a523 1
    CovDataSet.get()->printCoveredFunctions(outs());
d527 1
a527 1
    CovDataSet.get()->printNotCoveredFunctions(outs());
a529 11
  case HtmlReportAction: {
    CovDataSet.get()->printReport(outs());
    return 0;
  }
  case StatsAction: {
    CovDataSet.get()->printStats(outs());
    return 0;
  }
  case PrintAction:
  case PrintCovPointsAction:
    llvm_unreachable("unsupported action");
d531 2
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a13 1
#include "llvm/ADT/StringExtras.h"
a27 1
#include "llvm/Object/COFF.h"
a28 1
#include "llvm/Object/MachO.h"
a41 1
#include "llvm/Support/SHA1.h"
a42 1
#include "llvm/Support/SourceMgr.h"
a46 1
#include "llvm/Support/YAMLParser.h"
d63 2
d66 1
d68 1
a68 6
  MergeAction,
  NotCoveredFunctionsAction,
  PrintAction,
  PrintCovPointsAction,
  StatsAction,
  SymbolizeAction
d73 12
a84 15
    cl::values(
        clEnumValN(PrintAction, "print", "Print coverage addresses"),
        clEnumValN(PrintCovPointsAction, "print-coverage-pcs",
                   "Print coverage instrumentation points addresses."),
        clEnumValN(CoveredFunctionsAction, "covered-functions",
                   "Print all covered funcions."),
        clEnumValN(NotCoveredFunctionsAction, "not-covered-functions",
                   "Print all not covered funcions."),
        clEnumValN(StatsAction, "print-coverage-stats",
                   "Print coverage statistics."),
        clEnumValN(HtmlReportAction, "html-report",
                   "REMOVED. Use -symbolize & coverage-report-server.py."),
        clEnumValN(SymbolizeAction, "symbolize",
                   "Produces a symbolized JSON report from binary report."),
        clEnumValN(MergeAction, "merge", "Merges reports.")));
a92 4
static cl::opt<bool>
    ClSkipDeadFiles("skip-dead-files", cl::init(true),
                    cl::desc("Do not list dead source files in reports."));

a119 44
static Regex SancovFileRegex("(.*)\\.[0-9]+\\.sancov");
static Regex SymcovFileRegex(".*\\.symcov");

// --------- MAIN DATASTRUCTURES ----------

// Contents of .sancov file: list of coverage point addresses that were
// executed.
struct RawCoverage {
  explicit RawCoverage(std::unique_ptr<std::set<uint64_t>> Addrs)
      : Addrs(std::move(Addrs)) {}

  // Read binary .sancov file.
  static ErrorOr<std::unique_ptr<RawCoverage>>
  read(const std::string &FileName);

  std::unique_ptr<std::set<uint64_t>> Addrs;
};

// Coverage point has an opaque Id and corresponds to multiple source locations.
struct CoveragePoint {
  explicit CoveragePoint(const std::string &Id) : Id(Id) {}

  std::string Id;
  SmallVector<DILineInfo, 1> Locs;
};

// Symcov file content: set of covered Ids plus information about all available
// coverage points.
struct SymbolizedCoverage {
  // Read json .symcov file.
  static std::unique_ptr<SymbolizedCoverage> read(const std::string &InputFile);

  std::set<std::string> CoveredIds;
  std::string BinaryHash;
  std::vector<CoveragePoint> Points;
};

struct CoverageStats {
  size_t AllPoints;
  size_t CovPoints;
  size_t AllFns;
  size_t CovFns;
};

d122 1
a122 1
static void fail(const llvm::Twine &E) {
d127 1
a127 6
static void failIf(bool B, const llvm::Twine &E) {
  if (B)
    fail(E);
}

static void failIfError(std::error_code Error) {
d134 2
a135 2
template <typename T> static void failIfError(const ErrorOr<T> &E) {
  failIfError(E.getError());
d138 1
a138 1
static void failIfError(Error Err) {
d145 2
a146 2
template <typename T> static void failIfError(Expected<T> &E) {
  failIfError(E.takeError());
d149 1
a149 1
static void failIfNotEmpty(const llvm::Twine &E) {
d152 1
a152 1
  fail(E);
d156 1
a156 1
static void failIfEmpty(const std::unique_ptr<T> &Ptr,
d160 18
a177 1
  fail(Message);
a179 1
// ----------- Coverage I/O ----------
d188 3
a190 17
ErrorOr<std::unique_ptr<RawCoverage>>
RawCoverage::read(const std::string &FileName) {
  ErrorOr<std::unique_ptr<MemoryBuffer>> BufOrErr =
      MemoryBuffer::getFile(FileName);
  if (!BufOrErr)
    return BufOrErr.getError();
  std::unique_ptr<MemoryBuffer> Buf = std::move(BufOrErr.get());
  if (Buf->getBufferSize() < 8) {
    errs() << "File too small (<8): " << Buf->getBufferSize() << '\n';
    return make_error_code(errc::illegal_byte_sequence);
  }
  const FileHeader *Header =
      reinterpret_cast<const FileHeader *>(Buf->getBufferStart());

  if (Header->Magic != BinCoverageMagic) {
    errs() << "Wrong magic: " << Header->Magic << '\n';
    return make_error_code(errc::illegal_byte_sequence);
d193 3
a195 1
  auto Addrs = llvm::make_unique<std::set<uint64_t>>();
d197 4
a200 12
  switch (Header->Bitness) {
  case Bitness64:
    readInts<uint64_t>(Buf->getBufferStart() + 8, Buf->getBufferEnd(),
                       Addrs.get());
    break;
  case Bitness32:
    readInts<uint32_t>(Buf->getBufferStart() + 8, Buf->getBufferEnd(),
                       Addrs.get());
    break;
  default:
    errs() << "Unsupported bitness: " << Header->Bitness << '\n';
    return make_error_code(errc::illegal_byte_sequence);
d203 3
a205 2
  return std::unique_ptr<RawCoverage>(new RawCoverage(std::move(Addrs)));
}
d207 3
a209 6
// Print coverage addresses.
raw_ostream &operator<<(raw_ostream &OS, const RawCoverage &CoverageData) {
  for (auto Addr : *CoverageData.Addrs) {
    OS << "0x";
    OS.write_hex(Addr);
    OS << "\n";
a210 2
  return OS;
}
d212 2
a213 89
static raw_ostream &operator<<(raw_ostream &OS, const CoverageStats &Stats) {
  OS << "all-edges: " << Stats.AllPoints << "\n";
  OS << "cov-edges: " << Stats.CovPoints << "\n";
  OS << "all-functions: " << Stats.AllFns << "\n";
  OS << "cov-functions: " << Stats.CovFns << "\n";
  return OS;
}

// Helper for writing out JSON. Handles indents and commas using
// scope variables for objects and arrays.
class JSONWriter {
public:
  JSONWriter(raw_ostream &Out) : OS(Out) {}
  JSONWriter(const JSONWriter &) = delete;
  ~JSONWriter() { OS << "\n"; }

  void operator<<(StringRef S) { printJSONStringLiteral(S, OS); }

  // Helper RAII class to output JSON objects.
  class Object {
  public:
    Object(JSONWriter *W, raw_ostream &OS) : W(W), OS(OS) {
      OS << "{";
      W->Indent++;
    }
    Object(const Object &) = delete;
    ~Object() {
      W->Indent--;
      OS << "\n";
      W->indent();
      OS << "}";
    }

    void key(StringRef Key) {
      Index++;
      if (Index > 0)
        OS << ",";
      OS << "\n";
      W->indent();
      printJSONStringLiteral(Key, OS);
      OS << " : ";
    }

  private:
    JSONWriter *W;
    raw_ostream &OS;
    int Index = -1;
  };

  std::unique_ptr<Object> object() { return make_unique<Object>(this, OS); }

  // Helper RAII class to output JSON arrays.
  class Array {
  public:
    Array(raw_ostream &OS) : OS(OS) { OS << "["; }
    Array(const Array &) = delete;
    ~Array() { OS << "]"; }
    void next() {
      Index++;
      if (Index > 0)
        OS << ", ";
    }

  private:
    raw_ostream &OS;
    int Index = -1;
  };

  std::unique_ptr<Array> array() { return make_unique<Array>(OS); }

private:
  void indent() { OS.indent(Indent * 2); }

  static void printJSONStringLiteral(StringRef S, raw_ostream &OS) {
    if (S.find('"') == std::string::npos) {
      OS << "\"" << S << "\"";
      return;
    }
    OS << "\"";
    for (char Ch : S.bytes()) {
      if (Ch == '"')
        OS << "\\";
      OS << Ch;
    }
    OS << "\"";
  }

  raw_ostream &OS;
  int Indent = 0;
a215 181
// Output symbolized information for coverage points in JSON.
// Format:
// {
//   '<file_name>' : {
//     '<function_name>' : {
//       '<point_id'> : '<line_number>:'<column_number'.
//          ....
//       }
//    }
// }
static void operator<<(JSONWriter &W,
                       const std::vector<CoveragePoint> &Points) {
  // Group points by file.
  auto ByFile(W.object());
  std::map<std::string, std::vector<const CoveragePoint *>> PointsByFile;
  for (const auto &Point : Points) {
    for (const DILineInfo &Loc : Point.Locs) {
      PointsByFile[Loc.FileName].push_back(&Point);
    }
  }

  for (const auto &P : PointsByFile) {
    std::string FileName = P.first;
    ByFile->key(FileName);

    // Group points by function.
    auto ByFn(W.object());
    std::map<std::string, std::vector<const CoveragePoint *>> PointsByFn;
    for (auto PointPtr : P.second) {
      for (const DILineInfo &Loc : PointPtr->Locs) {
        PointsByFn[Loc.FunctionName].push_back(PointPtr);
      }
    }

    for (const auto &P : PointsByFn) {
      std::string FunctionName = P.first;
      std::set<std::string> WrittenIds;

      ByFn->key(FunctionName);

      // Output <point_id> : "<line>:<col>".
      auto ById(W.object());
      for (const CoveragePoint *Point : P.second) {
        for (const auto &Loc : Point->Locs) {
          if (Loc.FileName != FileName || Loc.FunctionName != FunctionName)
            continue;
          if (WrittenIds.find(Point->Id) != WrittenIds.end())
            continue;

          WrittenIds.insert(Point->Id);
          ById->key(Point->Id);
          W << (utostr(Loc.Line) + ":" + utostr(Loc.Column));
        }
      }
    }
  }
}

static void operator<<(JSONWriter &W, const SymbolizedCoverage &C) {
  auto O(W.object());

  {
    O->key("covered-points");
    auto PointsArray(W.array());

    for (const auto &P : C.CoveredIds) {
      PointsArray->next();
      W << P;
    }
  }

  {
    if (!C.BinaryHash.empty()) {
      O->key("binary-hash");
      W << C.BinaryHash;
    }
  }

  {
    O->key("point-symbol-info");
    W << C.Points;
  }
}

static std::string parseScalarString(yaml::Node *N) {
  SmallString<64> StringStorage;
  yaml::ScalarNode *S = dyn_cast<yaml::ScalarNode>(N);
  failIf(!S, "expected string");
  return S->getValue(StringStorage);
}

std::unique_ptr<SymbolizedCoverage>
SymbolizedCoverage::read(const std::string &InputFile) {
  auto Coverage(make_unique<SymbolizedCoverage>());

  std::map<std::string, CoveragePoint> Points;
  ErrorOr<std::unique_ptr<MemoryBuffer>> BufOrErr =
      MemoryBuffer::getFile(InputFile);
  failIfError(BufOrErr);

  SourceMgr SM;
  yaml::Stream S(**BufOrErr, SM);

  yaml::document_iterator DI = S.begin();
  failIf(DI == S.end(), "empty document: " + InputFile);
  yaml::Node *Root = DI->getRoot();
  failIf(!Root, "expecting root node: " + InputFile);
  yaml::MappingNode *Top = dyn_cast<yaml::MappingNode>(Root);
  failIf(!Top, "expecting mapping node: " + InputFile);

  for (auto &KVNode : *Top) {
    auto Key = parseScalarString(KVNode.getKey());

    if (Key == "covered-points") {
      yaml::SequenceNode *Points =
          dyn_cast<yaml::SequenceNode>(KVNode.getValue());
      failIf(!Points, "expected array: " + InputFile);

      for (auto I = Points->begin(), E = Points->end(); I != E; ++I) {
        Coverage->CoveredIds.insert(parseScalarString(&*I));
      }
    } else if (Key == "binary-hash") {
      Coverage->BinaryHash = parseScalarString(KVNode.getValue());
    } else if (Key == "point-symbol-info") {
      yaml::MappingNode *PointSymbolInfo =
          dyn_cast<yaml::MappingNode>(KVNode.getValue());
      failIf(!PointSymbolInfo, "expected mapping node: " + InputFile);

      for (auto &FileKVNode : *PointSymbolInfo) {
        auto Filename = parseScalarString(FileKVNode.getKey());

        yaml::MappingNode *FileInfo =
            dyn_cast<yaml::MappingNode>(FileKVNode.getValue());
        failIf(!FileInfo, "expected mapping node: " + InputFile);

        for (auto &FunctionKVNode : *FileInfo) {
          auto FunctionName = parseScalarString(FunctionKVNode.getKey());

          yaml::MappingNode *FunctionInfo =
              dyn_cast<yaml::MappingNode>(FunctionKVNode.getValue());
          failIf(!FunctionInfo, "expected mapping node: " + InputFile);

          for (auto &PointKVNode : *FunctionInfo) {
            auto PointId = parseScalarString(PointKVNode.getKey());
            auto Loc = parseScalarString(PointKVNode.getValue());

            size_t ColonPos = Loc.find(':');
            failIf(ColonPos == std::string::npos, "expected ':': " + InputFile);

            auto LineStr = Loc.substr(0, ColonPos);
            auto ColStr = Loc.substr(ColonPos + 1, Loc.size());

            if (Points.find(PointId) == Points.end())
              Points.insert(std::make_pair(PointId, CoveragePoint(PointId)));

            DILineInfo LineInfo;
            LineInfo.FileName = Filename;
            LineInfo.FunctionName = FunctionName;
            char *End;
            LineInfo.Line = std::strtoul(LineStr.c_str(), &End, 10);
            LineInfo.Column = std::strtoul(ColStr.c_str(), &End, 10);

            CoveragePoint *CoveragePoint = &Points.find(PointId)->second;
            CoveragePoint->Locs.push_back(LineInfo);
          }
        }
      }
    } else {
      errs() << "Ignoring unknown key: " << Key << "\n";
    }
  }

  for (auto &KV : Points) {
    Coverage->Points.push_back(KV.second);
  }

  return Coverage;
}

// ---------- MAIN FUNCTIONALITY ----------

d233 15
a247 5
static std::string normalizeFilename(const std::string &FileName) {
  SmallString<256> S(FileName);
  sys::path::remove_dots(S, /* remove_dot_dot */ true);
  return stripPathPrefix(S.str().str());
}
d255 4
a258 2
  bool isBlacklisted(const DILineInfo &I) {
    if (DefaultBlacklist && DefaultBlacklist->inSection("fun", I.FunctionName))
d260 1
a260 1
    if (DefaultBlacklist && DefaultBlacklist->inSection("src", I.FileName))
d262 1
a262 1
    if (UserBlacklist && UserBlacklist->inSection("fun", I.FunctionName))
d264 1
a264 1
    if (UserBlacklist && UserBlacklist->inSection("src", I.FileName))
d277 1
a277 1
    failIfNotEmpty(Error);
d291 5
a295 5
static std::vector<CoveragePoint>
getCoveragePoints(const std::string &ObjectFile,
                  const std::set<uint64_t> &Addrs,
                  const std::set<uint64_t> &CoveredAddrs) {
  std::vector<CoveragePoint> Result;
d299 8
a306 6
  std::set<std::string> CoveredFiles;
  if (ClSkipDeadFiles) {
    for (auto Addr : CoveredAddrs) {
      auto LineInfo = Symbolizer->symbolizeCode(ObjectFile, Addr);
      failIfError(LineInfo);
      CoveredFiles.insert(LineInfo->FileName);
d308 1
a308 1
      failIfError(InliningInfo);
d311 4
a314 1
        CoveredFiles.insert(FrameInfo.FileName);
a318 36
  for (auto Addr : Addrs) {
    std::set<DILineInfo> Infos; // deduplicate debug info.

    auto LineInfo = Symbolizer->symbolizeCode(ObjectFile, Addr);
    failIfError(LineInfo);
    if (ClSkipDeadFiles &&
        CoveredFiles.find(LineInfo->FileName) == CoveredFiles.end())
      continue;
    LineInfo->FileName = normalizeFilename(LineInfo->FileName);
    if (B.isBlacklisted(*LineInfo))
      continue;

    auto Id = utohexstr(Addr, true);
    auto Point = CoveragePoint(Id);
    Infos.insert(*LineInfo);
    Point.Locs.push_back(*LineInfo);

    auto InliningInfo = Symbolizer->symbolizeInlinedCode(ObjectFile, Addr);
    failIfError(InliningInfo);
    for (uint32_t I = 0; I < InliningInfo->getNumberOfFrames(); ++I) {
      auto FrameInfo = InliningInfo->getFrame(I);
      if (ClSkipDeadFiles &&
          CoveredFiles.find(FrameInfo.FileName) == CoveredFiles.end())
        continue;
      FrameInfo.FileName = normalizeFilename(FrameInfo.FileName);
      if (B.isBlacklisted(FrameInfo))
        continue;
      if (Infos.find(FrameInfo) == Infos.end()) {
        Infos.insert(FrameInfo);
        Point.Locs.push_back(FrameInfo);
      }
    }

    Result.push_back(Point);
  }

a321 49
static bool isCoveragePointSymbol(StringRef Name) {
  return Name == "__sanitizer_cov" || Name == "__sanitizer_cov_with_check" ||
         Name == "__sanitizer_cov_trace_func_enter" ||
         Name == "__sanitizer_cov_trace_pc_guard" ||
         // Mac has '___' prefix
         Name == "___sanitizer_cov" || Name == "___sanitizer_cov_with_check" ||
         Name == "___sanitizer_cov_trace_func_enter" ||
         Name == "___sanitizer_cov_trace_pc_guard";
}

// Locate __sanitizer_cov* function addresses inside the stubs table on MachO.
static void findMachOIndirectCovFunctions(const object::MachOObjectFile &O,
                                          std::set<uint64_t> *Result) {
  MachO::dysymtab_command Dysymtab = O.getDysymtabLoadCommand();
  MachO::symtab_command Symtab = O.getSymtabLoadCommand();

  for (const auto &Load : O.load_commands()) {
    if (Load.C.cmd == MachO::LC_SEGMENT_64) {
      MachO::segment_command_64 Seg = O.getSegment64LoadCommand(Load);
      for (unsigned J = 0; J < Seg.nsects; ++J) {
        MachO::section_64 Sec = O.getSection64(Load, J);

        uint32_t SectionType = Sec.flags & MachO::SECTION_TYPE;
        if (SectionType == MachO::S_SYMBOL_STUBS) {
          uint32_t Stride = Sec.reserved2;
          uint32_t Cnt = Sec.size / Stride;
          uint32_t N = Sec.reserved1;
          for (uint32_t J = 0; J < Cnt && N + J < Dysymtab.nindirectsyms; J++) {
            uint32_t IndirectSymbol =
                O.getIndirectSymbolTableEntry(Dysymtab, N + J);
            uint64_t Addr = Sec.addr + J * Stride;
            if (IndirectSymbol < Symtab.nsyms) {
              object::SymbolRef Symbol = *(O.getSymbolByIndex(IndirectSymbol));
              Expected<StringRef> Name = Symbol.getName();
              failIfError(Name);
              if (isCoveragePointSymbol(Name.get())) {
                Result->insert(Addr);
              }
            }
          }
        }
      }
    }
    if (Load.C.cmd == MachO::LC_SEGMENT) {
      errs() << "ERROR: 32 bit MachO binaries not supported\n";
    }
  }
}

d330 1
a330 2
    failIfError(AddressOrErr);
    uint64_t Address = AddressOrErr.get();
d333 1
a333 1
    failIfError(NameOrErr);
d336 4
a339 19
    if (!(Symbol.getFlags() & object::BasicSymbolRef::SF_Undefined) &&
        isCoveragePointSymbol(Name)) {
      Result.insert(Address);
    }
  }

  if (const auto *CO = dyn_cast<object::COFFObjectFile>(&O)) {
    for (const object::ExportDirectoryEntryRef &Export :
         CO->export_directories()) {
      uint32_t RVA;
      std::error_code EC = Export.getExportRVA(RVA);
      failIfError(EC);

      StringRef Name;
      EC = Export.getSymbolName(Name);
      failIfError(EC);

      if (isCoveragePointSymbol(Name))
        Result.insert(CO->getImageBase() + RVA);
a342 4
  if (const auto *MO = dyn_cast<object::MachOObjectFile>(&O)) {
    findMachOIndirectCovFunctions(*MO, &Result);
  }

d357 1
a357 1
  failIfNotEmpty(Error);
d361 1
a361 1
  failIfEmpty(STI, "no subtarget info for target " + TripleName);
d365 1
a365 1
  failIfEmpty(MRI, "no register info for target " + TripleName);
d369 1
a369 1
  failIfEmpty(AsmInfo, "no asm info for target " + TripleName);
d375 1
a375 1
  failIfEmpty(DisAsm, "no disassembler info for target " + TripleName);
d378 1
a378 1
  failIfEmpty(MII, "no instruction info for target " + TripleName);
d382 1
a382 1
  failIfEmpty(MIA, "no instruction analysis info for target " + TripleName);
d386 1
a386 1
    fail("__sanitizer_cov* functions not found");
d397 1
a397 1
    failIfError(Section.getContents(BytesStr));
d425 1
a425 1
  Error Err = Error::success();
d428 1
a428 1
    failIfError(ChildOrErr);
d432 1
a432 1
      failIfError(object::object_error::invalid_file_type);
d434 1
a434 1
  failIfError(std::move(Err));
d443 1
a443 1
    failIfError(BinaryOrErr);
d451 1
a451 1
    failIfError(object::object_error::invalid_file_type);
d454 1
a454 2
static std::set<uint64_t>
findSanitizerCovFunctions(const std::string &FileName) {
d466 1
a466 1
static std::set<uint64_t> findCoveragePointAddrs(const std::string &FileName) {
d475 1
a475 1
  for (uint64_t Addr : findCoveragePointAddrs(ObjFile)) {
d482 52
a534 4
  auto ShortFileName = llvm::sys::path::filename(FileName);
  if (!SancovFileRegex.match(ShortFileName))
    return false;

d552 15
a566 3
static bool isSymbolizedCoverageFile(const std::string &FileName) {
  auto ShortFileName = llvm::sys::path::filename(FileName);
  return SymcovFileRegex.match(ShortFileName);
d569 64
a632 3
static std::unique_ptr<SymbolizedCoverage>
symbolize(const RawCoverage &Data, const std::string ObjectFile) {
  auto Coverage = make_unique<SymbolizedCoverage>();
d634 7
a640 15
  ErrorOr<std::unique_ptr<MemoryBuffer>> BufOrErr =
      MemoryBuffer::getFile(ObjectFile);
  failIfError(BufOrErr);
  SHA1 Hasher;
  Hasher.update((*BufOrErr)->getBuffer());
  Coverage->BinaryHash = toHex(Hasher.final());

  for (uint64_t Addr : *Data.Addrs) {
    Coverage->CoveredIds.insert(utohexstr(Addr, true));
  }

  std::set<uint64_t> AllAddrs = findCoveragePointAddrs(ObjectFile);
  if (!std::includes(AllAddrs.begin(), AllAddrs.end(), Data.Addrs->begin(),
                     Data.Addrs->end())) {
    fail("Coverage points in binary and .sancov file do not match.");
a641 3
  Coverage->Points = getCoveragePoints(ObjectFile, AllAddrs, *Data.Addrs);
  return Coverage;
}
d643 5
a647 5
struct FileFn {
  bool operator<(const FileFn &RHS) const {
    return std::tie(FileName, FunctionName) <
           std::tie(RHS.FileName, RHS.FunctionName);
  }
d649 1
a649 2
  std::string FileName;
  std::string FunctionName;
d652 73
a724 6
static std::set<FileFn>
computeFunctions(const std::vector<CoveragePoint> &Points) {
  std::set<FileFn> Fns;
  for (const auto &Point : Points) {
    for (const auto &Loc : Point.Locs) {
      Fns.insert(FileFn{Loc.FileName, Loc.FunctionName});
d726 1
a727 2
  return Fns;
}
d729 7
a735 3
static std::set<FileFn>
computeNotCoveredFunctions(const SymbolizedCoverage &Coverage) {
  auto Fns = computeFunctions(Coverage.Points);
d737 5
a741 3
  for (const auto &Point : Coverage.Points) {
    if (Coverage.CoveredIds.find(Point.Id) == Coverage.CoveredIds.end())
      continue;
d743 2
a744 2
    for (const auto &Loc : Point.Locs) {
      Fns.erase(FileFn{Loc.FileName, Loc.FunctionName});
d746 1
d749 17
a765 2
  return Fns;
}
d767 6
a772 4
static std::set<FileFn>
computeCoveredFunctions(const SymbolizedCoverage &Coverage) {
  auto AllFns = computeFunctions(Coverage.Points);
  std::set<FileFn> Result;
d774 3
a776 3
  for (const auto &Point : Coverage.Points) {
    if (Coverage.CoveredIds.find(Point.Id) == Coverage.CoveredIds.end())
      continue;
d778 3
a780 2
    for (const auto &Loc : Point.Locs) {
      Result.insert(FileFn{Loc.FileName, Loc.FunctionName});
d782 2
d786 25
a810 2
  return Result;
}
d812 1
a812 9
typedef std::map<FileFn, std::pair<uint32_t, uint32_t>> FunctionLocs;
// finds first location in a file for each function.
static FunctionLocs resolveFunctions(const SymbolizedCoverage &Coverage,
                                     const std::set<FileFn> &Fns) {
  FunctionLocs Result;
  for (const auto &Point : Coverage.Points) {
    for (const auto &Loc : Point.Locs) {
      FileFn Fn = FileFn{Loc.FileName, Loc.FunctionName};
      if (Fns.find(Fn) == Fns.end())
d815 10
a824 5
      auto P = std::make_pair(Loc.Line, Loc.Column);
      auto I = Result.find(Fn);
      if (I == Result.end() || I->second > P) {
        Result[Fn] = P;
      }
d826 7
a833 2
  return Result;
}
d835 14
a848 38
static void printFunctionLocs(const FunctionLocs &FnLocs, raw_ostream &OS) {
  for (const auto &P : FnLocs) {
    OS << stripPathPrefix(P.first.FileName) << ":" << P.second.first << " "
       << P.first.FunctionName << "\n";
  }
}
CoverageStats computeStats(const SymbolizedCoverage &Coverage) {
  CoverageStats Stats = {Coverage.Points.size(), Coverage.CoveredIds.size(),
                         computeFunctions(Coverage.Points).size(),
                         computeCoveredFunctions(Coverage).size()};
  return Stats;
}

// Print list of covered functions.
// Line format: <file_name>:<line> <function_name>
static void printCoveredFunctions(const SymbolizedCoverage &CovData,
                                  raw_ostream &OS) {
  auto CoveredFns = computeCoveredFunctions(CovData);
  printFunctionLocs(resolveFunctions(CovData, CoveredFns), OS);
}

// Print list of not covered functions.
// Line format: <file_name>:<line> <function_name>
static void printNotCoveredFunctions(const SymbolizedCoverage &CovData,
                                     raw_ostream &OS) {
  auto NotCoveredFns = computeNotCoveredFunctions(CovData);
  printFunctionLocs(resolveFunctions(CovData, NotCoveredFns), OS);
}

// Read list of files and merges their coverage info.
static void readAndPrintRawCoverage(const std::vector<std::string> &FileNames,
                                    raw_ostream &OS) {
  std::vector<std::unique_ptr<RawCoverage>> Covs;
  for (const auto &FileName : FileNames) {
    auto Cov = RawCoverage::read(FileName);
    if (!Cov)
      continue;
    OS << *Cov.get();
d852 64
a915 3
static std::unique_ptr<SymbolizedCoverage>
merge(const std::vector<std::unique_ptr<SymbolizedCoverage>> &Coverages) {
  auto Result = make_unique<SymbolizedCoverage>();
d917 22
a938 6
  for (size_t I = 0; I < Coverages.size(); ++I) {
    const SymbolizedCoverage &Coverage = *Coverages[I];
    std::string Prefix;
    if (Coverages.size() > 1) {
      // prefix is not needed when there's only one file.
      Prefix = utostr(I);
d941 49
a989 3
    for (const auto &Id : Coverage.CoveredIds) {
      Result->CoveredIds.insert(Prefix + Id);
    }
d991 22
a1012 4
    for (const auto &CovPoint : Coverage.Points) {
      CoveragePoint NewPoint(CovPoint);
      NewPoint.Id = Prefix + CovPoint.Id;
      Result->Points.push_back(NewPoint);
d1016 5
a1020 2
  if (Coverages.size() == 1) {
    Result->BinaryHash = Coverages[0]->BinaryHash;
d1023 7
a1029 2
  return Result;
}
d1031 5
a1035 5
static std::unique_ptr<SymbolizedCoverage>
readSymbolizeAndMergeCmdArguments(std::vector<std::string> FileNames) {
  std::vector<std::unique_ptr<SymbolizedCoverage>> Coverages;

  {
a1042 4
      if (isSymbolizedCoverageFile(FileName)) {
        Coverages.push_back(SymbolizedCoverage::read(FileName));
      }

d1051 1
a1051 1
          fail("Duplicate binary file with a short name: " + ShortFileName);
d1060 1
d1064 1
a1064 2
    std::map<std::string, std::vector<std::string>> CoverageByObjFile;
    for (const auto &FileName : CovFiles) {
d1066 1
a1066 1
      auto Ok = SancovFileRegex.match(ShortFileName, &Components);
d1068 1
a1068 1
        fail("Can't match coverage file name against "
d1075 1
a1075 1
        fail("Object file for coverage not found: " + FileName);
d1077 2
d1080 2
a1081 4
      CoverageByObjFile[Iter->second].push_back(FileName);
    };

    // Read raw coverage and symbolize it.
d1084 4
d1095 70
a1164 4
      for (const std::string &CoverageFile : Pair.second) {
        auto DataOrError = RawCoverage::read(CoverageFile);
        failIfError(DataOrError);
        Coverages.push_back(symbolize(*DataOrError.get(), Pair.first));
d1166 13
d1180 4
d1186 15
a1200 2
  return merge(Coverages);
}
d1204 1
a1204 1
int main(int Argc, char **Argv) {
d1206 2
a1207 2
  sys::PrintStackTraceOnErrorSignal(Argv[0]);
  PrettyStackTraceProgram X(Argc, Argv);
d1214 1
a1214 1
  cl::ParseCommandLineOptions(Argc, Argv, "Sanitizer Coverage Processing Tool");
d1218 3
a1220 1
    readAndPrintRawCoverage(ClInputFiles, outs());
d1230 6
a1235 2
  auto Coverage = readSymbolizeAndMergeCmdArguments(ClInputFiles);
  failIf(!Coverage, "No valid coverage files given.");
d1239 1
a1239 1
    printCoveredFunctions(*Coverage, outs());
d1243 1
a1243 1
    printNotCoveredFunctions(*Coverage, outs());
d1246 2
a1247 2
  case StatsAction: {
    outs() << computeStats(*Coverage);
d1250 2
a1251 4
  case MergeAction:
  case SymbolizeAction: { // merge & symbolize are synonims.
    JSONWriter W(outs());
    W << *Coverage;
a1253 4
  case HtmlReportAction:
    errs() << "-html-report option is removed: "
              "use -symbolize & coverage-report-server.py instead\n";
    return 1;
@


