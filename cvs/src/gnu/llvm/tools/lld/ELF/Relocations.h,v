head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.3
	OPENBSD_6_2:1.1.1.2.0.2
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.1
date	2017.01.14.19.55.45;	author patrick;	state Exp;
branches
	1.1.1.1;
next	;
commitid	qMUxATnKgqN83Oct;

1.1.1.1
date	2017.01.14.19.55.45;	author patrick;	state Exp;
branches;
next	1.1.1.2;
commitid	qMUxATnKgqN83Oct;

1.1.1.2
date	2017.01.24.08.33.12;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	so2WA7LCP6wbxtYl;

1.1.1.3
date	2017.10.04.20.27.35;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===- Relocations.h -------------------------------------------*- C++ -*-===//
//
//                             The LLVM Linker
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef LLD_ELF_RELOCATIONS_H
#define LLD_ELF_RELOCATIONS_H

#include "lld/Core/LLVM.h"

namespace lld {
namespace elf {
class SymbolBody;
template <class ELFT> class InputSection;
template <class ELFT> class InputSectionBase;

enum RelExpr {
  R_ABS,
  R_GOT,
  R_GOTONLY_PC,
  R_GOTREL,
  R_GOT_FROM_END,
  R_GOT_OFF,
  R_GOT_PAGE_PC,
  R_GOT_PC,
  R_HINT,
  R_MIPS_GOT_LOCAL_PAGE,
  R_MIPS_GOT_OFF,
  R_MIPS_TLSGD,
  R_MIPS_TLSLD,
  R_NEG_TLS,
  R_PAGE_PC,
  R_PC,
  R_PLT,
  R_PLT_PC,
  R_PLT_PAGE_PC,
  R_PPC_OPD,
  R_PPC_PLT_OPD,
  R_PPC_TOC,
  R_RELAX_GOT_PC,
  R_RELAX_GOT_PC_NOPIC,
  R_RELAX_TLS_GD_TO_IE,
  R_RELAX_TLS_GD_TO_IE_END,
  R_RELAX_TLS_GD_TO_IE_ABS,
  R_RELAX_TLS_GD_TO_IE_PAGE_PC,
  R_RELAX_TLS_GD_TO_LE,
  R_RELAX_TLS_GD_TO_LE_NEG,
  R_RELAX_TLS_IE_TO_LE,
  R_RELAX_TLS_LD_TO_LE,
  R_SIZE,
  R_THUNK_ABS,
  R_THUNK_PC,
  R_THUNK_PLT_PC,
  R_TLS,
  R_TLSDESC,
  R_TLSDESC_PAGE,
  R_TLSGD,
  R_TLSGD_PC,
  R_TLSLD,
  R_TLSLD_PC
};

template <class ELFT> struct Relocation {
  RelExpr Expr;
  uint32_t Type;
  InputSectionBase<ELFT> *InputSec;
  uint64_t Offset;
  uint64_t Addend;
  SymbolBody *Sym;
};

template <class ELFT> void scanRelocations(InputSection<ELFT> &);

template <class ELFT>
void scanRelocations(InputSectionBase<ELFT> &, const typename ELFT::Shdr &);

template <class ELFT>
static inline typename ELFT::uint getAddend(const typename ELFT::Rel &Rel) {
  return 0;
}

template <class ELFT>
static inline typename ELFT::uint getAddend(const typename ELFT::Rela &Rel) {
  return Rel.r_addend;
}
}
}

#endif
@


1.1.1.1
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a17 1
class InputSectionData;
a20 3
// List of target-independent relocation types. Relocations read
// from files are converted to these types so that the main code
// doesn't have to know about architecture-specific details.
a24 1
  R_GOTONLY_PC_FROM_END,
a25 1
  R_GOTREL_FROM_END,
a32 2
  R_MIPS_GOT_OFF32,
  R_MIPS_GOTREL,
a60 1
  R_TLSDESC_CALL,
d64 1
a64 1
  R_TLSLD_PC,
d67 1
a67 31
// Build a bitmask with one bit set for each RelExpr.
//
// Constexpr function arguments can't be used in static asserts, so we
// use template arguments to build the mask.
// But function template partial specializations don't exist (needed
// for base case of the recursion), so we need a dummy struct.
template <RelExpr... Exprs> struct RelExprMaskBuilder {
  static inline uint64_t build() { return 0; }
};

// Specialization for recursive case.
template <RelExpr Head, RelExpr... Tail>
struct RelExprMaskBuilder<Head, Tail...> {
  static inline uint64_t build() {
    static_assert(0 <= Head && Head < 64,
                  "RelExpr is too large for 64-bit mask!");
    return (uint64_t(1) << Head) | RelExprMaskBuilder<Tail...>::build();
  }
};

// Return true if `Expr` is one of `Exprs`.
// There are fewer than 64 RelExpr's, so we can represent any set of
// RelExpr's as a constant bit mask and test for membership with a
// couple cheap bitwise operations.
template <RelExpr... Exprs> bool isRelExprOneOf(RelExpr Expr) {
  assert(0 <= Expr && (int)Expr < 64 && "RelExpr is too large for 64-bit mask!");
  return (uint64_t(1) << Expr) & RelExprMaskBuilder<Exprs...>::build();
}

// Architecture-neutral representation of relocation.
struct Relocation {
d70 1
d76 1
a76 1
template <class ELFT> void scanRelocations(InputSectionBase<ELFT> &);
d78 2
a79 1
template <class ELFT> void createThunks(InputSectionBase<ELFT> &);
@


1.1.1.3
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@a13 3
#include "llvm/ADT/DenseMap.h"
#include <map>
#include <vector>
d18 3
a20 4
class InputSection;
class InputSectionBase;
class OutputSection;
struct OutputSectionCommand;
a26 1
  R_ARM_SBREL,
a36 3
  R_MIPS_GOTREL,
  R_MIPS_GOT_GP,
  R_MIPS_GOT_GP_PC,
d40 1
a43 1
  R_NONE,
d47 1
a48 1
  R_PLT_PC,
d55 1
a56 1
  R_RELAX_TLS_GD_TO_IE_END,
d63 3
d68 1
a69 1
  R_TLSDESC_PAGE,
d101 1
a101 2
  assert(0 <= Expr && (int)Expr < 64 &&
         "RelExpr is too large for 64-bit mask!");
d110 1
a110 1
  int64_t Addend;
d114 1
a114 4
template <class ELFT> void scanRelocations(InputSectionBase &);

class ThunkSection;
class Thunk;
d116 1
a116 46
class ThunkCreator {
public:
  // Return true if Thunks have been added to OutputSections
  bool createThunks(ArrayRef<OutputSectionCommand *> OutputSections);

  // The number of completed passes of createThunks this permits us
  // to do one time initialization on Pass 0 and put a limit on the
  // number of times it can be called to prevent infinite loops.
  uint32_t Pass = 0;

private:
  void mergeThunks();
  ThunkSection *getOSThunkSec(OutputSectionCommand *Cmd,
                              std::vector<InputSection *> *ISR);
  ThunkSection *getISThunkSec(InputSection *IS, OutputSection *OS);
  void forEachExecInputSection(
      ArrayRef<OutputSectionCommand *> OutputSections,
      std::function<void(OutputSectionCommand *, std::vector<InputSection *> *,
                         InputSection *)>
          Fn);
  std::pair<Thunk *, bool> getThunk(SymbolBody &Body, uint32_t Type);
  ThunkSection *addThunkSection(OutputSection *OS,
                                std::vector<InputSection *> *, uint64_t Off);
  // Record all the available Thunks for a Symbol
  llvm::DenseMap<SymbolBody *, std::vector<Thunk *>> ThunkedSymbols;

  // Find a Thunk from the Thunks symbol definition, we can use this to find
  // the Thunk from a relocation to the Thunks symbol definition.
  llvm::DenseMap<SymbolBody *, Thunk *> Thunks;

  // Track InputSections that have an inline ThunkSection placed in front
  // an inline ThunkSection may have control fall through to the section below
  // so we need to make sure that there is only one of them.
  // The Mips LA25 Thunk is an example of an inline ThunkSection.
  llvm::DenseMap<InputSection *, ThunkSection *> ThunkedSections;

  // All the ThunkSections that we have created, organised by OutputSection
  // will contain a mix of ThunkSections that have been created this pass, and
  // ThunkSections that have been merged into the OutputSection on previous
  // passes
  std::map<std::vector<InputSection *> *, std::vector<ThunkSection *>>
      ThunkSections;

  // The ThunkSection for this vector of InputSections
  ThunkSection *CurTS;
};
a117 2
// Return a int64_t to make sure we get the sign extension out of the way as
// early as possible.
d119 1
a119 1
static inline int64_t getAddend(const typename ELFT::Rel &Rel) {
d122 1
d124 1
a124 1
static inline int64_t getAddend(const typename ELFT::Rela &Rel) {
d127 2
a128 2
} // namespace elf
} // namespace lld
@


