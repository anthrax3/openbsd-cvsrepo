head	1.4;
access;
symbols
	LLVM_5_0_0:1.1.1.4
	OPENBSD_6_2:1.3.0.2
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.4
date	2017.10.04.20.51.29;	author patrick;	state Exp;
branches;
next	1.3;
commitid	s9g4O09EGmKo3yXv;

1.3
date	2017.03.14.08.11.34;	author patrick;	state Exp;
branches;
next	1.2;
commitid	oOpCIdWEDcALI0Ip;

1.2
date	2017.01.24.10.20.27;	author kettenis;	state Exp;
branches;
next	1.1;
commitid	YS60l1RXyA50G9MH;

1.1
date	2017.01.14.19.55.45;	author patrick;	state Exp;
branches
	1.1.1.1;
next	;
commitid	qMUxATnKgqN83Oct;

1.1.1.1
date	2017.01.14.19.55.45;	author patrick;	state Exp;
branches;
next	1.1.1.2;
commitid	qMUxATnKgqN83Oct;

1.1.1.2
date	2017.01.24.08.33.12;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	so2WA7LCP6wbxtYl;

1.1.1.3
date	2017.03.14.08.07.53;	author patrick;	state Exp;
branches;
next	1.1.1.4;
commitid	aUi5NxOzBSLCN5eN;

1.1.1.4
date	2017.10.04.20.27.35;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.4
log
@Merge LLVM 5.0.0 release.
@
text
@//===- Symbols.cpp --------------------------------------------------------===//
//
//                             The LLVM Linker
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "Symbols.h"
#include "Error.h"
#include "InputFiles.h"
#include "InputSection.h"
#include "OutputSections.h"
#include "Strings.h"
#include "SyntheticSections.h"
#include "Target.h"
#include "Writer.h"

#include "llvm/ADT/STLExtras.h"
#include "llvm/Support/Path.h"
#include <cstring>

using namespace llvm;
using namespace llvm::object;
using namespace llvm::ELF;

using namespace lld;
using namespace lld::elf;

DefinedRegular *ElfSym::Bss;
DefinedRegular *ElfSym::Etext1;
DefinedRegular *ElfSym::Etext2;
DefinedRegular *ElfSym::Edata1;
DefinedRegular *ElfSym::Edata2;
DefinedRegular *ElfSym::End1;
DefinedRegular *ElfSym::End2;
DefinedRegular *ElfSym::GlobalOffsetTable;
DefinedRegular *ElfSym::MipsGp;
DefinedRegular *ElfSym::MipsGpDisp;
DefinedRegular *ElfSym::MipsLocalGp;

static uint64_t getSymVA(const SymbolBody &Body, int64_t &Addend) {
  switch (Body.kind()) {
  case SymbolBody::DefinedRegularKind: {
    auto &D = cast<DefinedRegular>(Body);
    SectionBase *IS = D.Section;
    if (auto *ISB = dyn_cast_or_null<InputSectionBase>(IS))
      IS = ISB->Repl;

    // According to the ELF spec reference to a local symbol from outside
    // the group are not allowed. Unfortunately .eh_frame breaks that rule
    // and must be treated specially. For now we just replace the symbol with
    // 0.
    if (IS == &InputSection::Discarded)
      return 0;

    // This is an absolute symbol.
    if (!IS)
      return D.Value;

    uint64_t Offset = D.Value;

    // An object in an SHF_MERGE section might be referenced via a
    // section symbol (as a hack for reducing the number of local
    // symbols).
    // Depending on the addend, the reference via a section symbol
    // refers to a different object in the merge section.
    // Since the objects in the merge section are not necessarily
    // contiguous in the output, the addend can thus affect the final
    // VA in a non-linear way.
    // To make this work, we incorporate the addend into the section
    // offset (and zero out the addend for later processing) so that
    // we find the right object in the section.
    if (D.isSection()) {
      Offset += Addend;
      Addend = 0;
    }

    const OutputSection *OutSec = IS->getOutputSection();

    // In the typical case, this is actually very simple and boils
    // down to adding together 3 numbers:
    // 1. The address of the output section.
    // 2. The offset of the input section within the output section.
    // 3. The offset within the input section (this addition happens
    //    inside InputSection::getOffset).
    //
    // If you understand the data structures involved with this next
    // line (and how they get built), then you have a pretty good
    // understanding of the linker.
    uint64_t VA = (OutSec ? OutSec->Addr : 0) + IS->getOffset(Offset);

    if (D.isTls() && !Config->Relocatable) {
      if (!Out::TlsPhdr)
        fatal(toString(D.File) +
              " has an STT_TLS symbol but doesn't have an SHF_TLS section");
      return VA - Out::TlsPhdr->p_vaddr;
    }
    return VA;
  }
  case SymbolBody::DefinedCommonKind:
    if (!Config->DefineCommon)
      return 0;
    return InX::Common->getParent()->Addr + InX::Common->OutSecOff +
           cast<DefinedCommon>(Body).Offset;
  case SymbolBody::SharedKind: {
    auto &SS = cast<SharedSymbol>(Body);
    if (SS.NeedsCopy)
      return SS.CopyRelSec->getParent()->Addr + SS.CopyRelSec->OutSecOff +
             SS.CopyRelSecOff;
    if (SS.NeedsPltAddr)
      return Body.getPltVA();
    return 0;
  }
  case SymbolBody::UndefinedKind:
    return 0;
  case SymbolBody::LazyArchiveKind:
  case SymbolBody::LazyObjectKind:
    assert(Body.symbol()->IsUsedInRegularObj && "lazy symbol reached writer");
    return 0;
  }
  llvm_unreachable("invalid symbol kind");
}

SymbolBody::SymbolBody(Kind K, StringRefZ Name, bool IsLocal, uint8_t StOther,
                       uint8_t Type)
    : SymbolKind(K), NeedsCopy(false), NeedsPltAddr(false), IsLocal(IsLocal),
      IsInGlobalMipsGot(false), Is32BitMipsGot(false), IsInIplt(false),
      IsInIgot(false), Type(Type), StOther(StOther), Name(Name) {}

// Returns true if a symbol can be replaced at load-time by a symbol
// with the same name defined in other ELF executable or DSO.
bool SymbolBody::isPreemptible() const {
  if (isLocal())
    return false;

  // Shared symbols resolve to the definition in the DSO. The exceptions are
  // symbols with copy relocations (which resolve to .bss) or preempt plt
  // entries (which resolve to that plt entry).
  if (isShared())
    return !NeedsCopy && !NeedsPltAddr;

  // That's all that can be preempted in a non-DSO.
  if (!Config->Shared)
    return false;

  // Only symbols that appear in dynsym can be preempted.
  if (!symbol()->includeInDynsym())
    return false;

  // Only default visibility symbols can be preempted.
  if (symbol()->Visibility != STV_DEFAULT)
    return false;

  // -Bsymbolic means that definitions are not preempted.
  if (Config->Bsymbolic || (Config->BsymbolicFunctions && isFunc()))
    return !isDefined();
  return true;
}

// Overwrites all attributes with Other's so that this symbol becomes
// an alias to Other. This is useful for handling some options such as
// --wrap.
void SymbolBody::copy(SymbolBody *Other) {
  memcpy(symbol()->Body.buffer, Other->symbol()->Body.buffer,
         sizeof(Symbol::Body));
}

uint64_t SymbolBody::getVA(int64_t Addend) const {
  uint64_t OutVA = getSymVA(*this, Addend);
  return OutVA + Addend;
}

uint64_t SymbolBody::getGotVA() const {
  return InX::Got->getVA() + getGotOffset();
}

uint64_t SymbolBody::getGotOffset() const {
  return GotIndex * Target->GotEntrySize;
}

uint64_t SymbolBody::getGotPltVA() const {
  if (this->IsInIgot)
    return InX::IgotPlt->getVA() + getGotPltOffset();
  return InX::GotPlt->getVA() + getGotPltOffset();
}

uint64_t SymbolBody::getGotPltOffset() const {
  return GotPltIndex * Target->GotPltEntrySize;
}

uint64_t SymbolBody::getPltVA() const {
  if (this->IsInIplt)
    return InX::Iplt->getVA() + PltIndex * Target->PltEntrySize;
  return InX::Plt->getVA() + Target->PltHeaderSize +
         PltIndex * Target->PltEntrySize;
}

template <class ELFT> typename ELFT::uint SymbolBody::getSize() const {
  if (const auto *C = dyn_cast<DefinedCommon>(this))
    return C->Size;
  if (const auto *DR = dyn_cast<DefinedRegular>(this))
    return DR->Size;
  if (const auto *S = dyn_cast<SharedSymbol>(this))
    return S->getSize<ELFT>();
  return 0;
}

OutputSection *SymbolBody::getOutputSection() const {
  if (auto *S = dyn_cast<DefinedRegular>(this)) {
    if (S->Section)
      return S->Section->getOutputSection();
    return nullptr;
  }

  if (auto *S = dyn_cast<SharedSymbol>(this)) {
    if (S->NeedsCopy)
      return S->CopyRelSec->getParent();
    return nullptr;
  }

  if (isa<DefinedCommon>(this)) {
    if (Config->DefineCommon)
      return InX::Common->getParent();
    return nullptr;
  }

  return nullptr;
}

// If a symbol name contains '@@', the characters after that is
// a symbol version name. This function parses that.
void SymbolBody::parseSymbolVersion() {
  StringRef S = getName();
  size_t Pos = S.find('@@');
  if (Pos == 0 || Pos == StringRef::npos)
    return;
  StringRef Verstr = S.substr(Pos + 1);
  if (Verstr.empty())
    return;

  // Truncate the symbol name so that it doesn't include the version string.
  Name = {S.data(), Pos};

  // If this is not in this DSO, it is not a definition.
  if (!isInCurrentDSO())
    return;

  // '@@@@' in a symbol name means the default version.
  // It is usually the most recent one.
  bool IsDefault = (Verstr[0] == '@@');
  if (IsDefault)
    Verstr = Verstr.substr(1);

  for (VersionDefinition &Ver : Config->VersionDefinitions) {
    if (Ver.Name != Verstr)
      continue;

    if (IsDefault)
      symbol()->VersionId = Ver.Id;
    else
      symbol()->VersionId = Ver.Id | VERSYM_HIDDEN;
    return;
  }

  // It is an error if the specified version is not defined.
  // Usually version script is not provided when linking executable,
  // but we may still want to override a versioned symbol from DSO,
  // so we do not report error in this case.
  if (Config->Shared)
    error(toString(File) + ": symbol " + S + " has undefined version " +
          Verstr);
}

Defined::Defined(Kind K, StringRefZ Name, bool IsLocal, uint8_t StOther,
                 uint8_t Type)
    : SymbolBody(K, Name, IsLocal, StOther, Type) {}

template <class ELFT> bool DefinedRegular::isMipsPIC() const {
  typedef typename ELFT::Ehdr Elf_Ehdr;
  if (!Section || !isFunc())
    return false;

  auto *Sec = cast<InputSectionBase>(Section);
  const Elf_Ehdr *Hdr = Sec->template getFile<ELFT>()->getObj().getHeader();
  return (this->StOther & STO_MIPS_MIPS16) == STO_MIPS_PIC ||
         (Hdr->e_flags & EF_MIPS_PIC);
}

Undefined::Undefined(StringRefZ Name, bool IsLocal, uint8_t StOther,
                     uint8_t Type, InputFile *File)
    : SymbolBody(SymbolBody::UndefinedKind, Name, IsLocal, StOther, Type) {
  this->File = File;
}

DefinedCommon::DefinedCommon(StringRef Name, uint64_t Size, uint32_t Alignment,
                             uint8_t StOther, uint8_t Type, InputFile *File)
    : Defined(SymbolBody::DefinedCommonKind, Name, /*IsLocal=*/false, StOther,
              Type),
      Alignment(Alignment), Size(Size) {
  this->File = File;
}

// If a shared symbol is referred via a copy relocation, its alignment
// becomes part of the ABI. This function returns a symbol alignment.
// Because symbols don't have alignment attributes, we need to infer that.
template <class ELFT> uint32_t SharedSymbol::getAlignment() const {
  auto *File = cast<SharedFile<ELFT>>(this->File);
  uint32_t SecAlign = File->getSection(getSym<ELFT>())->sh_addralign;
  uint64_t SymValue = getSym<ELFT>().st_value;
  uint32_t SymAlign = uint32_t(1) << countTrailingZeros(SymValue);
  return std::min(SecAlign, SymAlign);
}

InputFile *Lazy::fetch() {
  if (auto *S = dyn_cast<LazyArchive>(this))
    return S->fetch();
  return cast<LazyObject>(this)->fetch();
}

LazyArchive::LazyArchive(ArchiveFile &File,
                         const llvm::object::Archive::Symbol S, uint8_t Type)
    : Lazy(LazyArchiveKind, S.getName(), Type), Sym(S) {
  this->File = &File;
}

LazyObject::LazyObject(StringRef Name, LazyObjectFile &File, uint8_t Type)
    : Lazy(LazyObjectKind, Name, Type) {
  this->File = &File;
}

InputFile *LazyArchive::fetch() {
  std::pair<MemoryBufferRef, uint64_t> MBInfo = file()->getMember(&Sym);

  // getMember returns an empty buffer if the member was already
  // read from the library.
  if (MBInfo.first.getBuffer().empty())
    return nullptr;
  return createObjectFile(MBInfo.first, file()->getName(), MBInfo.second);
}

InputFile *LazyObject::fetch() { return file()->fetch(); }

uint8_t Symbol::computeBinding() const {
  if (Config->Relocatable)
    return Binding;
  if (Visibility != STV_DEFAULT && Visibility != STV_PROTECTED)
    return STB_LOCAL;
  if (VersionId == VER_NDX_LOCAL && body()->isInCurrentDSO())
    return STB_LOCAL;
  if (Config->NoGnuUnique && Binding == STB_GNU_UNIQUE)
    return STB_GLOBAL;
  return Binding;
}

bool Symbol::includeInDynsym() const {
  if (computeBinding() == STB_LOCAL)
    return false;
  return ExportDynamic || body()->isShared() ||
         (body()->isUndefined() && Config->Shared);
}

// Print out a log message for --trace-symbol.
void elf::printTraceSymbol(Symbol *Sym) {
  SymbolBody *B = Sym->body();
  std::string S;
  if (B->isUndefined())
    S = ": reference to ";
  else if (B->isCommon())
    S = ": common definition of ";
  else
    S = ": definition of ";

  message(toString(B->File) + S + B->getName());
}

// Returns a symbol for an error message.
std::string lld::toString(const SymbolBody &B) {
  if (Config->Demangle)
    if (Optional<std::string> S = demangle(B.getName()))
      return *S;
  return B.getName();
}

template uint32_t SymbolBody::template getSize<ELF32LE>() const;
template uint32_t SymbolBody::template getSize<ELF32BE>() const;
template uint64_t SymbolBody::template getSize<ELF64LE>() const;
template uint64_t SymbolBody::template getSize<ELF64BE>() const;

template bool DefinedRegular::template isMipsPIC<ELF32LE>() const;
template bool DefinedRegular::template isMipsPIC<ELF32BE>() const;
template bool DefinedRegular::template isMipsPIC<ELF64LE>() const;
template bool DefinedRegular::template isMipsPIC<ELF64BE>() const;

template uint32_t SharedSymbol::template getAlignment<ELF32LE>() const;
template uint32_t SharedSymbol::template getAlignment<ELF32BE>() const;
template uint32_t SharedSymbol::template getAlignment<ELF64LE>() const;
template uint32_t SharedSymbol::template getAlignment<ELF64BE>() const;
@


1.3
log
@Merge LLVM 4.0.0 release.
@
text
@d31 11
a41 4
template <class ELFT>
static typename ELFT::uint getSymVA(const SymbolBody &Body,
                                    typename ELFT::uint &Addend) {
  typedef typename ELFT::uint uintX_t;
d43 1
a44 9
  case SymbolBody::DefinedSyntheticKind: {
    auto &D = cast<DefinedSynthetic>(Body);
    const OutputSectionBase *Sec = D.Section;
    if (!Sec)
      return D.Value;
    if (D.Value == uintX_t(-1))
      return Sec->Addr + Sec->Size;
    return Sec->Addr + D.Value;
  }
d46 4
a49 2
    auto &D = cast<DefinedRegular<ELFT>>(Body);
    InputSectionBase<ELFT> *IS = D.Section;
d55 1
a55 1
    if (IS == &InputSection<ELFT>::Discarded)
d62 13
a74 1
    uintX_t Offset = D.Value;
d79 15
a93 1
    uintX_t VA = (IS->OutSec ? IS->OutSec->Addr : 0) + IS->getOffset(Offset);
d95 1
a95 1
      if (!Out<ELFT>::TlsPhdr)
d97 2
a98 2
              " has a STT_TLS symbol but doesn't have a PT_TLS section");
      return VA - Out<ELFT>::TlsPhdr->p_vaddr;
d105 1
a105 1
    return In<ELFT>::Common->OutSec->Addr + In<ELFT>::Common->OutSecOff +
d108 7
a114 6
    auto &SS = cast<SharedSymbol<ELFT>>(Body);
    if (!SS.NeedsCopyOrPltAddr)
      return 0;
    if (SS.isFunc())
      return Body.getPltVA<ELFT>();
    return SS.getBssSectionForCopy()->Addr + SS.CopyOffset;
d128 1
a128 1
    : SymbolKind(K), NeedsCopyOrPltAddr(false), IsLocal(IsLocal),
d130 1
a130 2
      IsInIgot(false), CopyIsInBssRelRo(false), Type(Type), StOther(StOther),
      Name(Name) {}
d142 1
a142 1
    return !NeedsCopyOrPltAddr;
d162 6
a167 6
template <class ELFT> bool SymbolBody::hasThunk() const {
  if (auto *DR = dyn_cast<DefinedRegular<ELFT>>(this))
    return DR->ThunkData != nullptr;
  if (auto *S = dyn_cast<SharedSymbol<ELFT>>(this))
    return S->ThunkData != nullptr;
  return false;
d170 2
a171 3
template <class ELFT>
typename ELFT::uint SymbolBody::getVA(typename ELFT::uint Addend) const {
  typename ELFT::uint OutVA = getSymVA<ELFT>(*this, Addend);
d175 2
a176 2
template <class ELFT> typename ELFT::uint SymbolBody::getGotVA() const {
  return In<ELFT>::Got->getVA() + getGotOffset<ELFT>();
d179 1
a179 1
template <class ELFT> typename ELFT::uint SymbolBody::getGotOffset() const {
d183 1
a183 1
template <class ELFT> typename ELFT::uint SymbolBody::getGotPltVA() const {
d185 2
a186 2
    return In<ELFT>::IgotPlt->getVA() + getGotPltOffset<ELFT>();
  return In<ELFT>::GotPlt->getVA() + getGotPltOffset<ELFT>();
d189 1
a189 1
template <class ELFT> typename ELFT::uint SymbolBody::getGotPltOffset() const {
d193 1
a193 1
template <class ELFT> typename ELFT::uint SymbolBody::getPltVA() const {
d195 2
a196 2
    return In<ELFT>::Iplt->getVA() + PltIndex * Target->PltEntrySize;
  return In<ELFT>::Plt->getVA() + Target->PltHeaderSize +
a199 10
template <class ELFT> typename ELFT::uint SymbolBody::getThunkVA() const {
  if (const auto *DR = dyn_cast<DefinedRegular<ELFT>>(this))
    return DR->ThunkData->getVA();
  if (const auto *S = dyn_cast<SharedSymbol<ELFT>>(this))
    return S->ThunkData->getVA();
  if (const auto *S = dyn_cast<Undefined<ELFT>>(this))
    return S->ThunkData->getVA();
  fatal("getThunkVA() not supported for Symbol class\n");
}

d203 1
a203 1
  if (const auto *DR = dyn_cast<DefinedRegular<ELFT>>(this))
d205 2
a206 2
  if (const auto *S = dyn_cast<SharedSymbol<ELFT>>(this))
    return S->Sym.st_size;
d210 22
d268 6
a273 1
  error(toString(File) + ": symbol " + S + " has undefined version " + Verstr);
d280 2
a281 1
template <class ELFT> bool DefinedRegular<ELFT>::isMipsPIC() const {
d284 3
d288 1
a288 1
         (Section->getFile()->getObj().getHeader()->e_flags & EF_MIPS_PIC);
d291 2
a292 3
template <typename ELFT>
Undefined<ELFT>::Undefined(StringRefZ Name, bool IsLocal, uint8_t StOther,
                           uint8_t Type, InputFile *File)
d297 1
a297 7
template <typename ELFT>
OutputSection<ELFT> *SharedSymbol<ELFT>::getBssSectionForCopy() const {
  assert(needsCopy());
  return CopyIsInBssRelRo ? Out<ELFT>::BssRelRo : Out<ELFT>::Bss;
}

DefinedCommon::DefinedCommon(StringRef Name, uint64_t Size, uint64_t Alignment,
d305 11
d343 1
a343 6
InputFile *LazyObject::fetch() {
  MemoryBufferRef MBRef = file()->getBuffer();
  if (MBRef.getBuffer().empty())
    return nullptr;
  return createObjectFile(MBRef);
}
d350 1
a350 2
  const SymbolBody *Body = body();
  if (VersionId == VER_NDX_LOCAL && Body->isInCurrentDSO())
d367 1
a367 2
  outs() << toString(B->File);

d369 1
a369 1
    outs() << ": reference to ";
d371 1
a371 1
    outs() << ": common definition of ";
d373 3
a375 2
    outs() << ": definition of ";
  outs() << B->getName() << "\n";
a385 40
template bool SymbolBody::hasThunk<ELF32LE>() const;
template bool SymbolBody::hasThunk<ELF32BE>() const;
template bool SymbolBody::hasThunk<ELF64LE>() const;
template bool SymbolBody::hasThunk<ELF64BE>() const;

template uint32_t SymbolBody::template getVA<ELF32LE>(uint32_t) const;
template uint32_t SymbolBody::template getVA<ELF32BE>(uint32_t) const;
template uint64_t SymbolBody::template getVA<ELF64LE>(uint64_t) const;
template uint64_t SymbolBody::template getVA<ELF64BE>(uint64_t) const;

template uint32_t SymbolBody::template getGotVA<ELF32LE>() const;
template uint32_t SymbolBody::template getGotVA<ELF32BE>() const;
template uint64_t SymbolBody::template getGotVA<ELF64LE>() const;
template uint64_t SymbolBody::template getGotVA<ELF64BE>() const;

template uint32_t SymbolBody::template getGotOffset<ELF32LE>() const;
template uint32_t SymbolBody::template getGotOffset<ELF32BE>() const;
template uint64_t SymbolBody::template getGotOffset<ELF64LE>() const;
template uint64_t SymbolBody::template getGotOffset<ELF64BE>() const;

template uint32_t SymbolBody::template getGotPltVA<ELF32LE>() const;
template uint32_t SymbolBody::template getGotPltVA<ELF32BE>() const;
template uint64_t SymbolBody::template getGotPltVA<ELF64LE>() const;
template uint64_t SymbolBody::template getGotPltVA<ELF64BE>() const;

template uint32_t SymbolBody::template getThunkVA<ELF32LE>() const;
template uint32_t SymbolBody::template getThunkVA<ELF32BE>() const;
template uint64_t SymbolBody::template getThunkVA<ELF64LE>() const;
template uint64_t SymbolBody::template getThunkVA<ELF64BE>() const;

template uint32_t SymbolBody::template getGotPltOffset<ELF32LE>() const;
template uint32_t SymbolBody::template getGotPltOffset<ELF32BE>() const;
template uint64_t SymbolBody::template getGotPltOffset<ELF64LE>() const;
template uint64_t SymbolBody::template getGotPltOffset<ELF64BE>() const;

template uint32_t SymbolBody::template getPltVA<ELF32LE>() const;
template uint32_t SymbolBody::template getPltVA<ELF32BE>() const;
template uint64_t SymbolBody::template getPltVA<ELF64LE>() const;
template uint64_t SymbolBody::template getPltVA<ELF64BE>() const;

d391 9
a399 14
template class elf::Undefined<ELF32LE>;
template class elf::Undefined<ELF32BE>;
template class elf::Undefined<ELF64LE>;
template class elf::Undefined<ELF64BE>;

template class elf::SharedSymbol<ELF32LE>;
template class elf::SharedSymbol<ELF32BE>;
template class elf::SharedSymbol<ELF64LE>;
template class elf::SharedSymbol<ELF64BE>;

template class elf::DefinedRegular<ELF32LE>;
template class elf::DefinedRegular<ELF32BE>;
template class elf::DefinedRegular<ELF64LE>;
template class elf::DefinedRegular<ELF64BE>;
@


1.2
log
@Avoid allocating space for commons with ld -r.  Already pushed upstream.
@
text
@d208 2
a209 2
  // If this is an undefined or shared symbol it is not a definition.
  if (isUndefined() || isShared())
d305 1
a305 1
  if (VersionId == VER_NDX_LOCAL && !Body->isUndefined() && !Body->isShared())
@


1.1
log
@Initial revision
@
text
@d15 2
d18 1
d21 2
d38 2
a39 2
    auto &D = cast<DefinedSynthetic<ELFT>>(Body);
    const OutputSectionBase<ELFT> *Sec = D.Section;
d42 3
a44 3
    if (D.Value == DefinedSynthetic<ELFT>::SectionEnd)
      return Sec->getVA() + Sec->getSize();
    return Sec->getVA() + D.Value;
d48 1
a48 1
    InputSectionBase<ELFT> *SC = D.Section;
d54 1
a54 1
    if (SC == &InputSection<ELFT>::Discarded)
d58 1
a58 1
    if (!SC)
d66 5
a70 2
    uintX_t VA = SC->OutSec->getVA() + SC->getOffset(Offset);
    if (D.isTls())
d72 1
d76 4
a79 1
    return Out<ELFT>::Bss->getVA() + cast<DefinedCommon>(Body).OffsetInBss;
d86 1
a86 1
    return Out<ELFT>::Bss->getVA() + SS.OffsetInBss;
a93 2
  case SymbolBody::DefinedBitcodeKind:
    llvm_unreachable("should have been replaced");
d98 1
a98 1
SymbolBody::SymbolBody(Kind K, uint32_t NameOffset, uint8_t StOther,
d100 4
a103 18
    : SymbolKind(K), NeedsCopyOrPltAddr(false), IsLocal(true),
      IsInGlobalMipsGot(false), Type(Type), StOther(StOther),
      NameOffset(NameOffset) {}

SymbolBody::SymbolBody(Kind K, StringRef Name, uint8_t StOther, uint8_t Type)
    : SymbolKind(K), NeedsCopyOrPltAddr(false), IsLocal(false),
      IsInGlobalMipsGot(false), Type(Type), StOther(StOther),
      Name({Name.data(), Name.size()}) {}

StringRef SymbolBody::getName() const {
  assert(!isLocal());
  return StringRef(Name.S, Name.Len);
}

void SymbolBody::setName(StringRef S) {
  Name.S = S.data();
  Name.Len = S.size();
}
d150 1
a150 1
  return Out<ELFT>::Got->getVA() + getGotOffset<ELFT>();
d158 3
a160 1
  return Out<ELFT>::GotPlt->getVA() + getGotPltOffset<ELFT>();
d168 3
a170 1
  return Out<ELFT>::Plt->getVA() + Target->PltHeaderSize +
d179 2
d194 34
a227 2
Defined::Defined(Kind K, StringRef Name, uint8_t StOther, uint8_t Type)
    : SymbolBody(K, Name, StOther, Type) {}
d229 2
a230 7
Defined::Defined(Kind K, uint32_t NameOffset, uint8_t StOther, uint8_t Type)
    : SymbolBody(K, NameOffset, StOther, Type) {}

DefinedBitcode::DefinedBitcode(StringRef Name, uint8_t StOther, uint8_t Type,
                               BitcodeFile *F)
    : Defined(DefinedBitcodeKind, Name, StOther, Type) {
  this->File = F;
d233 3
a235 3
bool DefinedBitcode::classof(const SymbolBody *S) {
  return S->kind() == DefinedBitcodeKind;
}
d237 5
a241 4
Undefined::Undefined(StringRef Name, uint8_t StOther, uint8_t Type,
                     InputFile *File)
    : SymbolBody(SymbolBody::UndefinedKind, Name, StOther, Type) {
  this->File = File;
d244 4
a247 3
Undefined::Undefined(uint32_t NameOffset, uint8_t StOther, uint8_t Type,
                     InputFile *File)
    : SymbolBody(SymbolBody::UndefinedKind, NameOffset, StOther, Type) {
d252 4
a255 4
DefinedSynthetic<ELFT>::DefinedSynthetic(StringRef N, uintX_t Value,
                                         OutputSectionBase<ELFT> *Section)
    : Defined(SymbolBody::DefinedSyntheticKind, N, STV_HIDDEN, 0 /* Type */),
      Value(Value), Section(Section) {}
d257 1
a257 1
DefinedCommon::DefinedCommon(StringRef N, uint64_t Size, uint64_t Alignment,
d259 2
a260 1
    : Defined(SymbolBody::DefinedCommonKind, N, StOther, Type),
d265 1
a265 1
std::unique_ptr<InputFile> Lazy::fetch() {
d282 2
a283 2
std::unique_ptr<InputFile> LazyArchive::fetch() {
  MemoryBufferRef MBRef = file()->getMember(&Sym);
d287 3
a289 3
  if (MBRef.getBuffer().empty())
    return std::unique_ptr<InputFile>(nullptr);
  return createObjectFile(MBRef, file()->getName());
d292 1
a292 1
std::unique_ptr<InputFile> LazyObject::fetch() {
d295 1
a295 1
    return std::unique_ptr<InputFile>(nullptr);
d299 13
d313 1
a313 1
  if (Visibility != STV_DEFAULT && Visibility != STV_PROTECTED)
d315 1
a315 1
  return (ExportDynamic && VersionId != VER_NDX_LOCAL) || body()->isShared() ||
d322 1
a322 1
  outs() << getFilename(B->File);
d333 8
d386 14
a399 4
template class elf::DefinedSynthetic<ELF32LE>;
template class elf::DefinedSynthetic<ELF32BE>;
template class elf::DefinedSynthetic<ELF64LE>;
template class elf::DefinedSynthetic<ELF64BE>;
@


1.1.1.1
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a14 2
#include "Strings.h"
#include "SyntheticSections.h"
a15 1
#include "Writer.h"
a17 2
#include "llvm/Support/Path.h"
#include <cstring>
d33 2
a34 2
    auto &D = cast<DefinedSynthetic>(Body);
    const OutputSectionBase *Sec = D.Section;
d37 3
a39 3
    if (D.Value == uintX_t(-1))
      return Sec->Addr + Sec->Size;
    return Sec->Addr + D.Value;
d43 1
a43 1
    InputSectionBase<ELFT> *IS = D.Section;
d49 1
a49 1
    if (IS == &InputSection<ELFT>::Discarded)
d53 1
a53 1
    if (!IS)
d61 2
a62 5
    uintX_t VA = (IS->OutSec ? IS->OutSec->Addr : 0) + IS->getOffset(Offset);
    if (D.isTls() && !Config->Relocatable) {
      if (!Out<ELFT>::TlsPhdr)
        fatal(toString(D.File) +
              " has a STT_TLS symbol but doesn't have a PT_TLS section");
a63 1
    }
d67 1
a67 2
    return In<ELFT>::Common->OutSec->Addr + In<ELFT>::Common->OutSecOff +
           cast<DefinedCommon>(Body).Offset;
d74 1
a74 1
    return SS.getBssSectionForCopy()->Addr + SS.CopyOffset;
d82 2
d88 1
a88 1
SymbolBody::SymbolBody(Kind K, StringRefZ Name, bool IsLocal, uint8_t StOther,
d90 18
a107 4
    : SymbolKind(K), NeedsCopyOrPltAddr(false), IsLocal(IsLocal),
      IsInGlobalMipsGot(false), Is32BitMipsGot(false), IsInIplt(false),
      IsInIgot(false), CopyIsInBssRelRo(false), Type(Type), StOther(StOther),
      Name(Name) {}
d154 1
a154 1
  return In<ELFT>::Got->getVA() + getGotOffset<ELFT>();
d162 1
a162 3
  if (this->IsInIgot)
    return In<ELFT>::IgotPlt->getVA() + getGotPltOffset<ELFT>();
  return In<ELFT>::GotPlt->getVA() + getGotPltOffset<ELFT>();
d170 1
a170 3
  if (this->IsInIplt)
    return In<ELFT>::Iplt->getVA() + PltIndex * Target->PltEntrySize;
  return In<ELFT>::Plt->getVA() + Target->PltHeaderSize +
a178 2
  if (const auto *S = dyn_cast<Undefined<ELFT>>(this))
    return S->ThunkData->getVA();
d192 5
a196 34
// If a symbol name contains '@@', the characters after that is
// a symbol version name. This function parses that.
void SymbolBody::parseSymbolVersion() {
  StringRef S = getName();
  size_t Pos = S.find('@@');
  if (Pos == 0 || Pos == StringRef::npos)
    return;
  StringRef Verstr = S.substr(Pos + 1);
  if (Verstr.empty())
    return;

  // Truncate the symbol name so that it doesn't include the version string.
  Name = {S.data(), Pos};

  // If this is an undefined or shared symbol it is not a definition.
  if (isUndefined() || isShared())
    return;

  // '@@@@' in a symbol name means the default version.
  // It is usually the most recent one.
  bool IsDefault = (Verstr[0] == '@@');
  if (IsDefault)
    Verstr = Verstr.substr(1);

  for (VersionDefinition &Ver : Config->VersionDefinitions) {
    if (Ver.Name != Verstr)
      continue;

    if (IsDefault)
      symbol()->VersionId = Ver.Id;
    else
      symbol()->VersionId = Ver.Id | VERSYM_HIDDEN;
    return;
  }
d198 4
a201 2
  // It is an error if the specified version is not defined.
  error(toString(File) + ": symbol " + S + " has undefined version " + Verstr);
d204 3
a206 3
Defined::Defined(Kind K, StringRefZ Name, bool IsLocal, uint8_t StOther,
                 uint8_t Type)
    : SymbolBody(K, Name, IsLocal, StOther, Type) {}
d208 4
a211 5
template <class ELFT> bool DefinedRegular<ELFT>::isMipsPIC() const {
  if (!Section || !isFunc())
    return false;
  return (this->StOther & STO_MIPS_MIPS16) == STO_MIPS_PIC ||
         (Section->getFile()->getObj().getHeader()->e_flags & EF_MIPS_PIC);
d214 3
a216 4
template <typename ELFT>
Undefined<ELFT>::Undefined(StringRefZ Name, bool IsLocal, uint8_t StOther,
                           uint8_t Type, InputFile *File)
    : SymbolBody(SymbolBody::UndefinedKind, Name, IsLocal, StOther, Type) {
d221 4
a224 4
OutputSection<ELFT> *SharedSymbol<ELFT>::getBssSectionForCopy() const {
  assert(needsCopy());
  return CopyIsInBssRelRo ? Out<ELFT>::BssRelRo : Out<ELFT>::Bss;
}
d226 1
a226 1
DefinedCommon::DefinedCommon(StringRef Name, uint64_t Size, uint64_t Alignment,
d228 1
a228 2
    : Defined(SymbolBody::DefinedCommonKind, Name, /*IsLocal=*/false, StOther,
              Type),
d233 1
a233 1
InputFile *Lazy::fetch() {
d250 2
a251 2
InputFile *LazyArchive::fetch() {
  std::pair<MemoryBufferRef, uint64_t> MBInfo = file()->getMember(&Sym);
d255 3
a257 3
  if (MBInfo.first.getBuffer().empty())
    return nullptr;
  return createObjectFile(MBInfo.first, file()->getName(), MBInfo.second);
d260 1
a260 1
InputFile *LazyObject::fetch() {
d263 1
a263 1
    return nullptr;
d267 1
a267 3
uint8_t Symbol::computeBinding() const {
  if (Config->Relocatable)
    return Binding;
a268 11
    return STB_LOCAL;
  const SymbolBody *Body = body();
  if (VersionId == VER_NDX_LOCAL && !Body->isUndefined() && !Body->isShared())
    return STB_LOCAL;
  if (Config->NoGnuUnique && Binding == STB_GNU_UNIQUE)
    return STB_GLOBAL;
  return Binding;
}

bool Symbol::includeInDynsym() const {
  if (computeBinding() == STB_LOCAL)
d270 1
a270 1
  return ExportDynamic || body()->isShared() ||
d277 1
a277 1
  outs() << toString(B->File);
a287 8
// Returns a symbol for an error message.
std::string lld::toString(const SymbolBody &B) {
  if (Config->Demangle)
    if (Optional<std::string> S = demangle(B.getName()))
      return *S;
  return B.getName();
}

d333 4
a336 14
template class elf::Undefined<ELF32LE>;
template class elf::Undefined<ELF32BE>;
template class elf::Undefined<ELF64LE>;
template class elf::Undefined<ELF64BE>;

template class elf::SharedSymbol<ELF32LE>;
template class elf::SharedSymbol<ELF32BE>;
template class elf::SharedSymbol<ELF64LE>;
template class elf::SharedSymbol<ELF64BE>;

template class elf::DefinedRegular<ELF32LE>;
template class elf::DefinedRegular<ELF32BE>;
template class elf::DefinedRegular<ELF64LE>;
template class elf::DefinedRegular<ELF64BE>;
@


1.1.1.3
log
@Import LLVM 4.0.0 release including clang and lld.
@
text
@a75 2
    if (!Config->DefineCommon)
      return 0;
d206 2
a207 2
  // If this is not in this DSO, it is not a definition.
  if (!isInCurrentDSO())
d303 1
a303 1
  if (VersionId == VER_NDX_LOCAL && Body->isInCurrentDSO())
@


1.1.1.4
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@d31 4
a34 11
DefinedRegular *ElfSym::Bss;
DefinedRegular *ElfSym::Etext1;
DefinedRegular *ElfSym::Etext2;
DefinedRegular *ElfSym::Edata1;
DefinedRegular *ElfSym::Edata2;
DefinedRegular *ElfSym::End1;
DefinedRegular *ElfSym::End2;
DefinedRegular *ElfSym::GlobalOffsetTable;
DefinedRegular *ElfSym::MipsGp;
DefinedRegular *ElfSym::MipsGpDisp;
DefinedRegular *ElfSym::MipsLocalGp;
a35 1
static uint64_t getSymVA(const SymbolBody &Body, int64_t &Addend) {
d37 9
d47 2
a48 4
    auto &D = cast<DefinedRegular>(Body);
    SectionBase *IS = D.Section;
    if (auto *ISB = dyn_cast_or_null<InputSectionBase>(IS))
      IS = ISB->Repl;
d54 1
a54 1
    if (IS == &InputSection::Discarded)
d61 1
a61 13
    uint64_t Offset = D.Value;

    // An object in an SHF_MERGE section might be referenced via a
    // section symbol (as a hack for reducing the number of local
    // symbols).
    // Depending on the addend, the reference via a section symbol
    // refers to a different object in the merge section.
    // Since the objects in the merge section are not necessarily
    // contiguous in the output, the addend can thus affect the final
    // VA in a non-linear way.
    // To make this work, we incorporate the addend into the section
    // offset (and zero out the addend for later processing) so that
    // we find the right object in the section.
d66 1
a66 15

    const OutputSection *OutSec = IS->getOutputSection();

    // In the typical case, this is actually very simple and boils
    // down to adding together 3 numbers:
    // 1. The address of the output section.
    // 2. The offset of the input section within the output section.
    // 3. The offset within the input section (this addition happens
    //    inside InputSection::getOffset).
    //
    // If you understand the data structures involved with this next
    // line (and how they get built), then you have a pretty good
    // understanding of the linker.
    uint64_t VA = (OutSec ? OutSec->Addr : 0) + IS->getOffset(Offset);

d68 1
a68 1
      if (!Out::TlsPhdr)
d70 2
a71 2
              " has an STT_TLS symbol but doesn't have an SHF_TLS section");
      return VA - Out::TlsPhdr->p_vaddr;
d78 1
a78 1
    return InX::Common->getParent()->Addr + InX::Common->OutSecOff +
d81 6
a86 7
    auto &SS = cast<SharedSymbol>(Body);
    if (SS.NeedsCopy)
      return SS.CopyRelSec->getParent()->Addr + SS.CopyRelSec->OutSecOff +
             SS.CopyRelSecOff;
    if (SS.NeedsPltAddr)
      return Body.getPltVA();
    return 0;
d100 1
a100 1
    : SymbolKind(K), NeedsCopy(false), NeedsPltAddr(false), IsLocal(IsLocal),
d102 2
a103 1
      IsInIgot(false), Type(Type), StOther(StOther), Name(Name) {}
d115 1
a115 1
    return !NeedsCopy && !NeedsPltAddr;
d135 6
a140 6
// Overwrites all attributes with Other's so that this symbol becomes
// an alias to Other. This is useful for handling some options such as
// --wrap.
void SymbolBody::copy(SymbolBody *Other) {
  memcpy(symbol()->Body.buffer, Other->symbol()->Body.buffer,
         sizeof(Symbol::Body));
d143 3
a145 2
uint64_t SymbolBody::getVA(int64_t Addend) const {
  uint64_t OutVA = getSymVA(*this, Addend);
d149 2
a150 2
uint64_t SymbolBody::getGotVA() const {
  return InX::Got->getVA() + getGotOffset();
d153 1
a153 1
uint64_t SymbolBody::getGotOffset() const {
d157 1
a157 1
uint64_t SymbolBody::getGotPltVA() const {
d159 2
a160 2
    return InX::IgotPlt->getVA() + getGotPltOffset();
  return InX::GotPlt->getVA() + getGotPltOffset();
d163 1
a163 1
uint64_t SymbolBody::getGotPltOffset() const {
d167 1
a167 1
uint64_t SymbolBody::getPltVA() const {
d169 2
a170 2
    return InX::Iplt->getVA() + PltIndex * Target->PltEntrySize;
  return InX::Plt->getVA() + Target->PltHeaderSize +
d174 10
d187 1
a187 1
  if (const auto *DR = dyn_cast<DefinedRegular>(this))
d189 2
a190 2
  if (const auto *S = dyn_cast<SharedSymbol>(this))
    return S->getSize<ELFT>();
a193 22
OutputSection *SymbolBody::getOutputSection() const {
  if (auto *S = dyn_cast<DefinedRegular>(this)) {
    if (S->Section)
      return S->Section->getOutputSection();
    return nullptr;
  }

  if (auto *S = dyn_cast<SharedSymbol>(this)) {
    if (S->NeedsCopy)
      return S->CopyRelSec->getParent();
    return nullptr;
  }

  if (isa<DefinedCommon>(this)) {
    if (Config->DefineCommon)
      return InX::Common->getParent();
    return nullptr;
  }

  return nullptr;
}

d230 1
a230 6
  // Usually version script is not provided when linking executable,
  // but we may still want to override a versioned symbol from DSO,
  // so we do not report error in this case.
  if (Config->Shared)
    error(toString(File) + ": symbol " + S + " has undefined version " +
          Verstr);
d237 1
a237 2
template <class ELFT> bool DefinedRegular::isMipsPIC() const {
  typedef typename ELFT::Ehdr Elf_Ehdr;
a239 3

  auto *Sec = cast<InputSectionBase>(Section);
  const Elf_Ehdr *Hdr = Sec->template getFile<ELFT>()->getObj().getHeader();
d241 1
a241 1
         (Hdr->e_flags & EF_MIPS_PIC);
d244 3
a246 2
Undefined::Undefined(StringRefZ Name, bool IsLocal, uint8_t StOther,
                     uint8_t Type, InputFile *File)
d251 7
a257 1
DefinedCommon::DefinedCommon(StringRef Name, uint64_t Size, uint32_t Alignment,
a264 11
// If a shared symbol is referred via a copy relocation, its alignment
// becomes part of the ABI. This function returns a symbol alignment.
// Because symbols don't have alignment attributes, we need to infer that.
template <class ELFT> uint32_t SharedSymbol::getAlignment() const {
  auto *File = cast<SharedFile<ELFT>>(this->File);
  uint32_t SecAlign = File->getSection(getSym<ELFT>())->sh_addralign;
  uint64_t SymValue = getSym<ELFT>().st_value;
  uint32_t SymAlign = uint32_t(1) << countTrailingZeros(SymValue);
  return std::min(SecAlign, SymAlign);
}

d292 6
a297 1
InputFile *LazyObject::fetch() { return file()->fetch(); }
d304 2
a305 1
  if (VersionId == VER_NDX_LOCAL && body()->isInCurrentDSO())
d322 2
a323 1
  std::string S;
d325 1
a325 1
    S = ": reference to ";
d327 1
a327 1
    S = ": common definition of ";
d329 2
a330 3
    S = ": definition of ";

  message(toString(B->File) + S + B->getName());
d341 40
d386 14
a399 9
template bool DefinedRegular::template isMipsPIC<ELF32LE>() const;
template bool DefinedRegular::template isMipsPIC<ELF32BE>() const;
template bool DefinedRegular::template isMipsPIC<ELF64LE>() const;
template bool DefinedRegular::template isMipsPIC<ELF64BE>() const;

template uint32_t SharedSymbol::template getAlignment<ELF32LE>() const;
template uint32_t SharedSymbol::template getAlignment<ELF32BE>() const;
template uint32_t SharedSymbol::template getAlignment<ELF64LE>() const;
template uint32_t SharedSymbol::template getAlignment<ELF64BE>() const;
@


