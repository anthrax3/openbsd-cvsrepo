head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.4
	OPENBSD_6_2:1.1.1.3.0.2
	OPENBSD_6_2_BASE:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.4
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.1
date	2017.01.14.19.55.45;	author patrick;	state Exp;
branches
	1.1.1.1;
next	;
commitid	qMUxATnKgqN83Oct;

1.1.1.1
date	2017.01.14.19.55.45;	author patrick;	state Exp;
branches;
next	1.1.1.2;
commitid	qMUxATnKgqN83Oct;

1.1.1.2
date	2017.01.24.08.33.12;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	so2WA7LCP6wbxtYl;

1.1.1.3
date	2017.03.14.08.07.53;	author patrick;	state Exp;
branches;
next	1.1.1.4;
commitid	aUi5NxOzBSLCN5eN;

1.1.1.4
date	2017.10.04.20.27.35;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===- InputSection.cpp ---------------------------------------------------===//
//
//                             The LLVM Linker
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "InputSection.h"
#include "Config.h"
#include "EhFrame.h"
#include "Error.h"
#include "InputFiles.h"
#include "LinkerScript.h"
#include "OutputSections.h"
#include "Target.h"
#include "Thunks.h"

#include "llvm/Support/Compression.h"
#include "llvm/Support/Endian.h"

using namespace llvm;
using namespace llvm::ELF;
using namespace llvm::object;
using namespace llvm::support::endian;

using namespace lld;
using namespace lld::elf;

template <class ELFT> bool elf::isDiscarded(InputSectionBase<ELFT> *S) {
  return !S || S == &InputSection<ELFT>::Discarded || !S->Live ||
         Script<ELFT>::X->isDiscarded(S);
}

template <class ELFT>
InputSectionBase<ELFT>::InputSectionBase(elf::ObjectFile<ELFT> *File,
                                         const Elf_Shdr *Header,
                                         Kind SectionKind)
    : Header(Header), File(File), SectionKind(SectionKind), Repl(this),
      Compressed(Header->sh_flags & SHF_COMPRESSED) {
  // The garbage collector sets sections' Live bits.
  // If GC is disabled, all sections are considered live by default.
  Live = !Config->GcSections;

  // The ELF spec states that a value of 0 means the section has
  // no alignment constraits.
  Alignment = std::max<uintX_t>(Header->sh_addralign, 1);
}

template <class ELFT> size_t InputSectionBase<ELFT>::getSize() const {
  if (auto *D = dyn_cast<InputSection<ELFT>>(this))
    if (D->getThunksSize() > 0)
      return D->getThunkOff() + D->getThunksSize();
  return Header->sh_size;
}

template <class ELFT> StringRef InputSectionBase<ELFT>::getSectionName() const {
  return check(File->getObj().getSectionName(this->Header));
}

template <class ELFT>
ArrayRef<uint8_t> InputSectionBase<ELFT>::getSectionData() const {
  if (Compressed)
    return ArrayRef<uint8_t>((const uint8_t *)Uncompressed.data(),
                             Uncompressed.size());
  return check(this->File->getObj().getSectionContents(this->Header));
}

template <class ELFT>
typename ELFT::uint InputSectionBase<ELFT>::getOffset(uintX_t Offset) const {
  switch (SectionKind) {
  case Regular:
    return cast<InputSection<ELFT>>(this)->OutSecOff + Offset;
  case EHFrame:
    return cast<EhInputSection<ELFT>>(this)->getOffset(Offset);
  case Merge:
    return cast<MergeInputSection<ELFT>>(this)->getOffset(Offset);
  case MipsReginfo:
  case MipsOptions:
    // MIPS .reginfo and .MIPS.options sections are consumed by the linker,
    // and the linker produces a single output section. It is possible that
    // input files contain section symbol points to the corresponding input
    // section. Redirect it to the produced output section.
    if (Offset != 0)
      fatal("Unsupported reference to the middle of '" + getSectionName() +
            "' section");
    return this->OutSec->getVA();
  }
  llvm_unreachable("invalid section kind");
}

template <class ELFT> void InputSectionBase<ELFT>::uncompress() {
  if (!zlib::isAvailable())
    fatal("build lld with zlib to enable compressed sections support");

  // A compressed section consists of a header of Elf_Chdr type
  // followed by compressed data.
  ArrayRef<uint8_t> Data =
      check(this->File->getObj().getSectionContents(this->Header));
  if (Data.size() < sizeof(Elf_Chdr))
    fatal("corrupt compressed section");

  auto *Hdr = reinterpret_cast<const Elf_Chdr *>(Data.data());
  Data = Data.slice(sizeof(Elf_Chdr));

  if (Hdr->ch_type != ELFCOMPRESS_ZLIB)
    fatal("unsupported compression type");

  StringRef Buf((const char *)Data.data(), Data.size());
  if (zlib::uncompress(Buf, Uncompressed, Hdr->ch_size) != zlib::StatusOK)
    fatal("error uncompressing section");
}

template <class ELFT>
typename ELFT::uint
InputSectionBase<ELFT>::getOffset(const DefinedRegular<ELFT> &Sym) const {
  return getOffset(Sym.Value);
}

template <class ELFT>
InputSection<ELFT>::InputSection(elf::ObjectFile<ELFT> *F,
                                 const Elf_Shdr *Header)
    : InputSectionBase<ELFT>(F, Header, Base::Regular) {}

template <class ELFT>
bool InputSection<ELFT>::classof(const InputSectionBase<ELFT> *S) {
  return S->SectionKind == Base::Regular;
}

template <class ELFT>
InputSectionBase<ELFT> *InputSection<ELFT>::getRelocatedSection() {
  assert(this->Header->sh_type == SHT_RELA || this->Header->sh_type == SHT_REL);
  ArrayRef<InputSectionBase<ELFT> *> Sections = this->File->getSections();
  return Sections[this->Header->sh_info];
}

template <class ELFT>
void InputSection<ELFT>::addThunk(const Thunk<ELFT> *T) {
  Thunks.push_back(T);
}

template <class ELFT> uint64_t InputSection<ELFT>::getThunkOff() const {
  return this->Header->sh_size;
}

template <class ELFT> uint64_t InputSection<ELFT>::getThunksSize() const {
  uint64_t Total = 0;
  for (const Thunk<ELFT> *T : Thunks)
    Total += T->size();
  return Total;
}

// This is used for -r. We can't use memcpy to copy relocations because we need
// to update symbol table offset and section index for each relocation. So we
// copy relocations one by one.
template <class ELFT>
template <class RelTy>
void InputSection<ELFT>::copyRelocations(uint8_t *Buf, ArrayRef<RelTy> Rels) {
  InputSectionBase<ELFT> *RelocatedSection = getRelocatedSection();

  for (const RelTy &Rel : Rels) {
    uint32_t Type = Rel.getType(Config->Mips64EL);
    SymbolBody &Body = this->File->getRelocTargetSym(Rel);

    RelTy *P = reinterpret_cast<RelTy *>(Buf);
    Buf += sizeof(RelTy);

    P->r_offset = RelocatedSection->getOffset(Rel.r_offset);
    P->setSymbolAndType(Body.DynsymIndex, Type, Config->Mips64EL);
  }
}

// Page(Expr) is the page address of the expression Expr, defined
// as (Expr & ~0xFFF). (This applies even if the machine page size
// supported by the platform has a different value.)
static uint64_t getAArch64Page(uint64_t Expr) {
  return Expr & (~static_cast<uint64_t>(0xFFF));
}

template <class ELFT>
static typename ELFT::uint getSymVA(uint32_t Type, typename ELFT::uint A,
                                    typename ELFT::uint P,
                                    const SymbolBody &Body, RelExpr Expr) {
  typedef typename ELFT::uint uintX_t;

  switch (Expr) {
  case R_HINT:
    llvm_unreachable("cannot relocate hint relocs");
  case R_TLSLD:
    return Out<ELFT>::Got->getTlsIndexOff() + A -
           Out<ELFT>::Got->getNumEntries() * sizeof(uintX_t);
  case R_TLSLD_PC:
    return Out<ELFT>::Got->getTlsIndexVA() + A - P;
  case R_THUNK_ABS:
    return Body.getThunkVA<ELFT>() + A;
  case R_THUNK_PC:
  case R_THUNK_PLT_PC:
    return Body.getThunkVA<ELFT>() + A - P;
  case R_PPC_TOC:
    return getPPC64TocBase() + A;
  case R_TLSGD:
    return Out<ELFT>::Got->getGlobalDynOffset(Body) + A -
           Out<ELFT>::Got->getNumEntries() * sizeof(uintX_t);
  case R_TLSGD_PC:
    return Out<ELFT>::Got->getGlobalDynAddr(Body) + A - P;
  case R_TLSDESC:
    return Out<ELFT>::Got->getGlobalDynAddr(Body) + A;
  case R_TLSDESC_PAGE:
    return getAArch64Page(Out<ELFT>::Got->getGlobalDynAddr(Body) + A) -
           getAArch64Page(P);
  case R_PLT:
    return Body.getPltVA<ELFT>() + A;
  case R_PLT_PC:
  case R_PPC_PLT_OPD:
    return Body.getPltVA<ELFT>() + A - P;
  case R_SIZE:
    return Body.getSize<ELFT>() + A;
  case R_GOTREL:
    return Body.getVA<ELFT>(A) - Out<ELFT>::Got->getVA();
  case R_RELAX_TLS_GD_TO_IE_END:
  case R_GOT_FROM_END:
    return Body.getGotOffset<ELFT>() + A -
           Out<ELFT>::Got->getNumEntries() * sizeof(uintX_t);
  case R_RELAX_TLS_GD_TO_IE_ABS:
  case R_GOT:
    return Body.getGotVA<ELFT>() + A;
  case R_RELAX_TLS_GD_TO_IE_PAGE_PC:
  case R_GOT_PAGE_PC:
    return getAArch64Page(Body.getGotVA<ELFT>() + A) - getAArch64Page(P);
  case R_RELAX_TLS_GD_TO_IE:
  case R_GOT_PC:
    return Body.getGotVA<ELFT>() + A - P;
  case R_GOTONLY_PC:
    return Out<ELFT>::Got->getVA() + A - P;
  case R_RELAX_TLS_LD_TO_LE:
  case R_RELAX_TLS_IE_TO_LE:
  case R_RELAX_TLS_GD_TO_LE:
  case R_TLS:
    if (Target->TcbSize)
      return Body.getVA<ELFT>(A) +
             alignTo(Target->TcbSize, Out<ELFT>::TlsPhdr->p_align);
    return Body.getVA<ELFT>(A) - Out<ELFT>::TlsPhdr->p_memsz;
  case R_RELAX_TLS_GD_TO_LE_NEG:
  case R_NEG_TLS:
    return Out<ELF32LE>::TlsPhdr->p_memsz - Body.getVA<ELFT>(A);
  case R_ABS:
  case R_RELAX_GOT_PC_NOPIC:
    return Body.getVA<ELFT>(A);
  case R_GOT_OFF:
    return Body.getGotOffset<ELFT>() + A;
  case R_MIPS_GOT_LOCAL_PAGE:
    // If relocation against MIPS local symbol requires GOT entry, this entry
    // should be initialized by 'page address'. This address is high 16-bits
    // of sum the symbol's value and the addend.
    return Out<ELFT>::Got->getMipsLocalPageOffset(Body.getVA<ELFT>(A));
  case R_MIPS_GOT_OFF:
    // In case of MIPS if a GOT relocation has non-zero addend this addend
    // should be applied to the GOT entry content not to the GOT entry offset.
    // That is why we use separate expression type.
    return Out<ELFT>::Got->getMipsGotOffset(Body, A);
  case R_MIPS_TLSGD:
    return Out<ELFT>::Got->getGlobalDynOffset(Body) +
           Out<ELFT>::Got->getMipsTlsOffset() - MipsGPOffset;
  case R_MIPS_TLSLD:
    return Out<ELFT>::Got->getTlsIndexOff() +
           Out<ELFT>::Got->getMipsTlsOffset() - MipsGPOffset;
  case R_PPC_OPD: {
    uint64_t SymVA = Body.getVA<ELFT>(A);
    // If we have an undefined weak symbol, we might get here with a symbol
    // address of zero. That could overflow, but the code must be unreachable,
    // so don't bother doing anything at all.
    if (!SymVA)
      return 0;
    if (Out<ELF64BE>::Opd) {
      // If this is a local call, and we currently have the address of a
      // function-descriptor, get the underlying code address instead.
      uint64_t OpdStart = Out<ELF64BE>::Opd->getVA();
      uint64_t OpdEnd = OpdStart + Out<ELF64BE>::Opd->getSize();
      bool InOpd = OpdStart <= SymVA && SymVA < OpdEnd;
      if (InOpd)
        SymVA = read64be(&Out<ELF64BE>::OpdBuf[SymVA - OpdStart]);
    }
    return SymVA - P;
  }
  case R_PC:
  case R_RELAX_GOT_PC:
    return Body.getVA<ELFT>(A) - P;
  case R_PLT_PAGE_PC:
  case R_PAGE_PC:
    return getAArch64Page(Body.getVA<ELFT>(A)) - getAArch64Page(P);
  }
  llvm_unreachable("Invalid expression");
}

// This function applies relocations to sections without SHF_ALLOC bit.
// Such sections are never mapped to memory at runtime. Debug sections are
// an example. Relocations in non-alloc sections are much easier to
// handle than in allocated sections because it will never need complex
// treatement such as GOT or PLT (because at runtime no one refers them).
// So, we handle relocations for non-alloc sections directly in this
// function as a performance optimization.
template <class ELFT>
template <class RelTy>
void InputSection<ELFT>::relocateNonAlloc(uint8_t *Buf, ArrayRef<RelTy> Rels) {
  const unsigned Bits = sizeof(uintX_t) * 8;
  for (const RelTy &Rel : Rels) {
    uint32_t Type = Rel.getType(Config->Mips64EL);
    uintX_t Offset = this->getOffset(Rel.r_offset);
    uint8_t *BufLoc = Buf + Offset;
    uintX_t Addend = getAddend<ELFT>(Rel);
    if (!RelTy::IsRela)
      Addend += Target->getImplicitAddend(BufLoc, Type);

    SymbolBody &Sym = this->File->getRelocTargetSym(Rel);
    if (Target->getRelExpr(Type, Sym) != R_ABS) {
      error(this->getSectionName() + " has non-ABS reloc");
      return;
    }

    uintX_t AddrLoc = this->OutSec->getVA() + Offset;
    uint64_t SymVA =
        SignExtend64<Bits>(getSymVA<ELFT>(Type, Addend, AddrLoc, Sym, R_ABS));
    Target->relocateOne(BufLoc, Type, SymVA);
  }
}

template <class ELFT>
void InputSectionBase<ELFT>::relocate(uint8_t *Buf, uint8_t *BufEnd) {
  // scanReloc function in Writer.cpp constructs Relocations
  // vector only for SHF_ALLOC'ed sections. For other sections,
  // we handle relocations directly here.
  auto *IS = dyn_cast<InputSection<ELFT>>(this);
  if (IS && !(IS->Header->sh_flags & SHF_ALLOC)) {
    for (const Elf_Shdr *RelSec : IS->RelocSections) {
      if (RelSec->sh_type == SHT_RELA)
        IS->relocateNonAlloc(Buf, IS->File->getObj().relas(RelSec));
      else
        IS->relocateNonAlloc(Buf, IS->File->getObj().rels(RelSec));
    }
    return;
  }

  const unsigned Bits = sizeof(uintX_t) * 8;
  for (const Relocation<ELFT> &Rel : Relocations) {
    uintX_t Offset = Rel.InputSec->getOffset(Rel.Offset);
    uint8_t *BufLoc = Buf + Offset;
    uint32_t Type = Rel.Type;
    uintX_t A = Rel.Addend;

    uintX_t AddrLoc = OutSec->getVA() + Offset;
    RelExpr Expr = Rel.Expr;
    uint64_t SymVA =
        SignExtend64<Bits>(getSymVA<ELFT>(Type, A, AddrLoc, *Rel.Sym, Expr));

    switch (Expr) {
    case R_RELAX_GOT_PC:
    case R_RELAX_GOT_PC_NOPIC:
      Target->relaxGot(BufLoc, SymVA);
      break;
    case R_RELAX_TLS_IE_TO_LE:
      Target->relaxTlsIeToLe(BufLoc, Type, SymVA);
      break;
    case R_RELAX_TLS_LD_TO_LE:
      Target->relaxTlsLdToLe(BufLoc, Type, SymVA);
      break;
    case R_RELAX_TLS_GD_TO_LE:
    case R_RELAX_TLS_GD_TO_LE_NEG:
      Target->relaxTlsGdToLe(BufLoc, Type, SymVA);
      break;
    case R_RELAX_TLS_GD_TO_IE:
    case R_RELAX_TLS_GD_TO_IE_ABS:
    case R_RELAX_TLS_GD_TO_IE_PAGE_PC:
    case R_RELAX_TLS_GD_TO_IE_END:
      Target->relaxTlsGdToIe(BufLoc, Type, SymVA);
      break;
    case R_PPC_PLT_OPD:
      // Patch a nop (0x60000000) to a ld.
      if (BufLoc + 8 <= BufEnd && read32be(BufLoc + 4) == 0x60000000)
        write32be(BufLoc + 4, 0xe8410028); // ld %r2, 40(%r1)
      // fallthrough
    default:
      Target->relocateOne(BufLoc, Type, SymVA);
      break;
    }
  }
}

template <class ELFT> void InputSection<ELFT>::writeTo(uint8_t *Buf) {
  if (this->Header->sh_type == SHT_NOBITS)
    return;
  ELFFile<ELFT> &EObj = this->File->getObj();

  // If -r is given, then an InputSection may be a relocation section.
  if (this->Header->sh_type == SHT_RELA) {
    copyRelocations(Buf + OutSecOff, EObj.relas(this->Header));
    return;
  }
  if (this->Header->sh_type == SHT_REL) {
    copyRelocations(Buf + OutSecOff, EObj.rels(this->Header));
    return;
  }

  // Copy section contents from source object file to output file.
  ArrayRef<uint8_t> Data = this->getSectionData();
  memcpy(Buf + OutSecOff, Data.data(), Data.size());

  // Iterate over all relocation sections that apply to this section.
  uint8_t *BufEnd = Buf + OutSecOff + Data.size();
  this->relocate(Buf, BufEnd);

  // The section might have a data/code generated by the linker and need
  // to be written after the section. Usually these are thunks - small piece
  // of code used to jump between "incompatible" functions like PIC and non-PIC
  // or if the jump target too far and its address does not fit to the short
  // jump istruction.
  if (!Thunks.empty()) {
    Buf += OutSecOff + getThunkOff();
    for (const Thunk<ELFT> *T : Thunks) {
      T->writeTo(Buf);
      Buf += T->size();
    }
  }
}

template <class ELFT>
void InputSection<ELFT>::replace(InputSection<ELFT> *Other) {
  this->Alignment = std::max(this->Alignment, Other->Alignment);
  Other->Repl = this->Repl;
  Other->Live = false;
}

template <class ELFT>
SplitInputSection<ELFT>::SplitInputSection(
    elf::ObjectFile<ELFT> *File, const Elf_Shdr *Header,
    typename InputSectionBase<ELFT>::Kind SectionKind)
    : InputSectionBase<ELFT>(File, Header, SectionKind) {}

template <class ELFT>
EhInputSection<ELFT>::EhInputSection(elf::ObjectFile<ELFT> *F,
                                     const Elf_Shdr *Header)
    : SplitInputSection<ELFT>(F, Header, InputSectionBase<ELFT>::EHFrame) {
  // Mark .eh_frame sections as live by default because there are
  // usually no relocations that point to .eh_frames. Otherwise,
  // the garbage collector would drop all .eh_frame sections.
  this->Live = true;
}

template <class ELFT>
bool EhInputSection<ELFT>::classof(const InputSectionBase<ELFT> *S) {
  return S->SectionKind == InputSectionBase<ELFT>::EHFrame;
}

// .eh_frame is a sequence of CIE or FDE records.
// This function splits an input section into records and returns them.
template <class ELFT>
void EhInputSection<ELFT>::split() {
  ArrayRef<uint8_t> Data = this->getSectionData();
  for (size_t Off = 0, End = Data.size(); Off != End;) {
    size_t Size = readEhRecordSize<ELFT>(Data.slice(Off));
    this->Pieces.emplace_back(Off, Data.slice(Off, Size));
    // The empty record is the end marker.
    if (Size == 4)
      break;
    Off += Size;
  }
}

template <class ELFT>
typename ELFT::uint EhInputSection<ELFT>::getOffset(uintX_t Offset) const {
  // The file crtbeginT.o has relocations pointing to the start of an empty
  // .eh_frame that is known to be the first in the link. It does that to
  // identify the start of the output .eh_frame. Handle this special case.
  if (this->getSectionHdr()->sh_size == 0)
    return Offset;
  const SectionPiece *Piece = this->getSectionPiece(Offset);
  if (Piece->OutputOff == size_t(-1))
    return -1; // Not in the output

  uintX_t Addend = Offset - Piece->InputOff;
  return Piece->OutputOff + Addend;
}

static size_t findNull(ArrayRef<uint8_t> A, size_t EntSize) {
  // Optimize the common case.
  StringRef S((const char *)A.data(), A.size());
  if (EntSize == 1)
    return S.find(0);

  for (unsigned I = 0, N = S.size(); I != N; I += EntSize) {
    const char *B = S.begin() + I;
    if (std::all_of(B, B + EntSize, [](char C) { return C == 0; }))
      return I;
  }
  return StringRef::npos;
}

// Split SHF_STRINGS section. Such section is a sequence of
// null-terminated strings.
static std::vector<SectionPiece> splitStrings(ArrayRef<uint8_t> Data,
                                              size_t EntSize) {
  std::vector<SectionPiece> V;
  size_t Off = 0;
  while (!Data.empty()) {
    size_t End = findNull(Data, EntSize);
    if (End == StringRef::npos)
      fatal("string is not null terminated");
    size_t Size = End + EntSize;
    V.emplace_back(Off, Data.slice(0, Size));
    Data = Data.slice(Size);
    Off += Size;
  }
  return V;
}

// Split non-SHF_STRINGS section. Such section is a sequence of
// fixed size records.
static std::vector<SectionPiece> splitNonStrings(ArrayRef<uint8_t> Data,
                                                 size_t EntSize) {
  std::vector<SectionPiece> V;
  size_t Size = Data.size();
  assert((Size % EntSize) == 0);
  for (unsigned I = 0, N = Size; I != N; I += EntSize)
    V.emplace_back(I, Data.slice(I, EntSize));
  return V;
}

template <class ELFT>
MergeInputSection<ELFT>::MergeInputSection(elf::ObjectFile<ELFT> *F,
                                           const Elf_Shdr *Header)
    : SplitInputSection<ELFT>(F, Header, InputSectionBase<ELFT>::Merge) {}

template <class ELFT> void MergeInputSection<ELFT>::splitIntoPieces() {
  ArrayRef<uint8_t> Data = this->getSectionData();
  uintX_t EntSize = this->Header->sh_entsize;
  if (this->Header->sh_flags & SHF_STRINGS)
    this->Pieces = splitStrings(Data, EntSize);
  else
    this->Pieces = splitNonStrings(Data, EntSize);

  if (Config->GcSections)
    for (uintX_t Off : LiveOffsets)
      this->getSectionPiece(Off)->Live = true;
}

template <class ELFT>
bool MergeInputSection<ELFT>::classof(const InputSectionBase<ELFT> *S) {
  return S->SectionKind == InputSectionBase<ELFT>::Merge;
}

// Do binary search to get a section piece at a given input offset.
template <class ELFT>
SectionPiece *SplitInputSection<ELFT>::getSectionPiece(uintX_t Offset) {
  auto *This = static_cast<const SplitInputSection<ELFT> *>(this);
  return const_cast<SectionPiece *>(This->getSectionPiece(Offset));
}

template <class ELFT>
const SectionPiece *
SplitInputSection<ELFT>::getSectionPiece(uintX_t Offset) const {
  ArrayRef<uint8_t> D = this->getSectionData();
  StringRef Data((const char *)D.data(), D.size());
  uintX_t Size = Data.size();
  if (Offset >= Size)
    fatal("entry is past the end of the section");

  // Find the element this offset points to.
  auto I = std::upper_bound(
      Pieces.begin(), Pieces.end(), Offset,
      [](const uintX_t &A, const SectionPiece &B) { return A < B.InputOff; });
  --I;
  return &*I;
}

// Returns the offset in an output section for a given input offset.
// Because contents of a mergeable section is not contiguous in output,
// it is not just an addition to a base output offset.
template <class ELFT>
typename ELFT::uint MergeInputSection<ELFT>::getOffset(uintX_t Offset) const {
  auto It = OffsetMap.find(Offset);
  if (It != OffsetMap.end())
    return It->second;

  // If Offset is not at beginning of a section piece, it is not in the map.
  // In that case we need to search from the original section piece vector.
  const SectionPiece &Piece = *this->getSectionPiece(Offset);
  assert(Piece.Live);
  uintX_t Addend = Offset - Piece.InputOff;
  return Piece.OutputOff + Addend;
}

// Create a map from input offsets to output offsets for all section pieces.
// It is called after finalize().
template <class ELFT> void  MergeInputSection<ELFT>::finalizePieces() {
  OffsetMap.grow(this->Pieces.size());
  for (SectionPiece &Piece : this->Pieces) {
    if (!Piece.Live)
      continue;
    if (Piece.OutputOff == size_t(-1)) {
      // Offsets of tail-merged strings are computed lazily.
      auto *OutSec = static_cast<MergeOutputSection<ELFT> *>(this->OutSec);
      ArrayRef<uint8_t> D = Piece.data();
      StringRef S((const char *)D.data(), D.size());
      Piece.OutputOff = OutSec->getOffset(S);
    }
    OffsetMap[Piece.InputOff] = Piece.OutputOff;
  }
}

template <class ELFT>
MipsReginfoInputSection<ELFT>::MipsReginfoInputSection(elf::ObjectFile<ELFT> *F,
                                                       const Elf_Shdr *Hdr)
    : InputSectionBase<ELFT>(F, Hdr, InputSectionBase<ELFT>::MipsReginfo) {
  // Initialize this->Reginfo.
  ArrayRef<uint8_t> D = this->getSectionData();
  if (D.size() != sizeof(Elf_Mips_RegInfo<ELFT>)) {
    error("invalid size of .reginfo section");
    return;
  }
  Reginfo = reinterpret_cast<const Elf_Mips_RegInfo<ELFT> *>(D.data());
}

template <class ELFT>
bool MipsReginfoInputSection<ELFT>::classof(const InputSectionBase<ELFT> *S) {
  return S->SectionKind == InputSectionBase<ELFT>::MipsReginfo;
}

template <class ELFT>
MipsOptionsInputSection<ELFT>::MipsOptionsInputSection(elf::ObjectFile<ELFT> *F,
                                                       const Elf_Shdr *Hdr)
    : InputSectionBase<ELFT>(F, Hdr, InputSectionBase<ELFT>::MipsOptions) {
  // Find ODK_REGINFO option in the section's content.
  ArrayRef<uint8_t> D = this->getSectionData();
  while (!D.empty()) {
    if (D.size() < sizeof(Elf_Mips_Options<ELFT>)) {
      error("invalid size of .MIPS.options section");
      break;
    }
    auto *O = reinterpret_cast<const Elf_Mips_Options<ELFT> *>(D.data());
    if (O->kind == ODK_REGINFO) {
      Reginfo = &O->getRegInfo();
      break;
    }
    D = D.slice(O->size);
  }
}

template <class ELFT>
bool MipsOptionsInputSection<ELFT>::classof(const InputSectionBase<ELFT> *S) {
  return S->SectionKind == InputSectionBase<ELFT>::MipsOptions;
}

template bool elf::isDiscarded<ELF32LE>(InputSectionBase<ELF32LE> *);
template bool elf::isDiscarded<ELF32BE>(InputSectionBase<ELF32BE> *);
template bool elf::isDiscarded<ELF64LE>(InputSectionBase<ELF64LE> *);
template bool elf::isDiscarded<ELF64BE>(InputSectionBase<ELF64BE> *);

template class elf::InputSectionBase<ELF32LE>;
template class elf::InputSectionBase<ELF32BE>;
template class elf::InputSectionBase<ELF64LE>;
template class elf::InputSectionBase<ELF64BE>;

template class elf::InputSection<ELF32LE>;
template class elf::InputSection<ELF32BE>;
template class elf::InputSection<ELF64LE>;
template class elf::InputSection<ELF64BE>;

template class elf::SplitInputSection<ELF32LE>;
template class elf::SplitInputSection<ELF32BE>;
template class elf::SplitInputSection<ELF64LE>;
template class elf::SplitInputSection<ELF64BE>;

template class elf::EhInputSection<ELF32LE>;
template class elf::EhInputSection<ELF32BE>;
template class elf::EhInputSection<ELF64LE>;
template class elf::EhInputSection<ELF64BE>;

template class elf::MergeInputSection<ELF32LE>;
template class elf::MergeInputSection<ELF32BE>;
template class elf::MergeInputSection<ELF64LE>;
template class elf::MergeInputSection<ELF64BE>;

template class elf::MipsReginfoInputSection<ELF32LE>;
template class elf::MipsReginfoInputSection<ELF32BE>;
template class elf::MipsReginfoInputSection<ELF64LE>;
template class elf::MipsReginfoInputSection<ELF64BE>;

template class elf::MipsOptionsInputSection<ELF32LE>;
template class elf::MipsOptionsInputSection<ELF32BE>;
template class elf::MipsOptionsInputSection<ELF64LE>;
template class elf::MipsOptionsInputSection<ELF64BE>;
@


1.1.1.1
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a15 1
#include "Memory.h"
a16 2
#include "Relocations.h"
#include "SyntheticSections.h"
d19 1
a19 1
#include "llvm/Object/Decompressor.h"
a21 1
#include <mutex>
a25 1
using namespace llvm::support;
d31 3
a33 15
// Returns a string to construct an error message.
template <class ELFT>
std::string lld::toString(const InputSectionBase<ELFT> *Sec) {
  // File can be absent if section is synthetic.
  std::string FileName =
      Sec->getFile() ? Sec->getFile()->getName() : "<internal>";
  return (FileName + ":(" + Sec->Name + ")").str();
}

template <class ELFT>
static ArrayRef<uint8_t> getSectionContents(elf::ObjectFile<ELFT> *File,
                                            const typename ELFT::Shdr *Hdr) {
  if (!File || Hdr->sh_type == SHT_NOBITS)
    return makeArrayRef<uint8_t>(nullptr, Hdr->sh_size);
  return check(File->getObj().getSectionContents(Hdr));
d38 1
a38 4
                                         uintX_t Flags, uint32_t Type,
                                         uintX_t Entsize, uint32_t Link,
                                         uint32_t Info, uintX_t Addralign,
                                         ArrayRef<uint8_t> Data, StringRef Name,
d40 5
a44 6
    : InputSectionData(SectionKind, Name, Data,
                       !Config->GcSections || !(Flags & SHF_ALLOC)),
      File(File), Flags(Flags), Entsize(Entsize), Type(Type), Link(Link),
      Info(Info), Repl(this) {
  NumRelocations = 0;
  AreRelocsRela = false;
d48 1
a48 27
  uint64_t V = std::max<uint64_t>(Addralign, 1);
  if (!isPowerOf2_64(V))
    fatal(toString(File) + ": section sh_addralign is not a power of 2");

  // We reject object files having insanely large alignments even though
  // they are allowed by the spec. I think 4GB is a reasonable limitation.
  // We might want to relax this in the future.
  if (V > UINT32_MAX)
    fatal(toString(File) + ": section sh_addralign is too large");
  Alignment = V;

  // If it is not a mergeable section, overwrite the flag so that the flag
  // is consistent with the class. This inconsistency could occur when
  // string merging is disabled using -O0 flag.
  if (!Config->Relocatable && !isa<MergeInputSection<ELFT>>(this))
    this->Flags &= ~(SHF_MERGE | SHF_STRINGS);
}

template <class ELFT>
InputSectionBase<ELFT>::InputSectionBase(elf::ObjectFile<ELFT> *File,
                                         const Elf_Shdr *Hdr, StringRef Name,
                                         Kind SectionKind)
    : InputSectionBase(File, Hdr->sh_flags & ~SHF_INFO_LINK, Hdr->sh_type,
                       Hdr->sh_entsize, Hdr->sh_link, Hdr->sh_info,
                       Hdr->sh_addralign, getSectionContents(File, Hdr), Name,
                       SectionKind) {
  this->Offset = Hdr->sh_offset;
a51 3
  if (auto *S = dyn_cast<SyntheticSection<ELFT>>(this))
    return S->getSize();

d55 2
d58 10
a67 1
  return Data.size();
d72 1
a72 1
  switch (kind()) {
a74 5
  case Synthetic:
    // For synthetic sections we treat offset -1 as the end of the section.
    // The same approach is used for synthetic symbols (DefinedSynthetic).
    return cast<InputSection<ELFT>>(this)->OutSecOff +
           (Offset == uintX_t(-1) ? getSize() : Offset);
d76 1
a76 4
    // The file crtbeginT.o has relocations pointing to the start of an empty
    // .eh_frame that is known to be the first in the link. It does that to
    // identify the start of the output .eh_frame.
    return Offset;
d79 10
a92 2
// Uncompress section contents. Note that this function is called
// from parallel_for_each, so it must be thread-safe.
d94 2
a95 11
  Decompressor Decompressor = check(Decompressor::create(
      Name, toStringRef(Data), ELFT::TargetEndianness == llvm::support::little,
      ELFT::Is64Bits));

  size_t Size = Decompressor.getDecompressedSize();
  char *OutputBuf;
  {
    static std::mutex Mu;
    std::lock_guard<std::mutex> Lock(Mu);
    OutputBuf = BAlloc.Allocate<char>(Size);
  }
d97 16
a112 3
  if (Error E = Decompressor.decompress({OutputBuf, Size}))
    fatal(E, toString(this));
  Data = ArrayRef<uint8_t>((uint8_t *)OutputBuf, Size);
a121 43
InputSectionBase<ELFT> *InputSectionBase<ELFT>::getLinkOrderDep() const {
  if ((Flags & SHF_LINK_ORDER) && Link != 0)
    return getFile()->getSections()[Link];
  return nullptr;
}

// Returns a source location string. Used to construct an error message.
template <class ELFT>
std::string InputSectionBase<ELFT>::getLocation(typename ELFT::uint Offset) {
  // First check if we can get desired values from debugging information.
  std::string LineInfo = File->getLineInfo(this, Offset);
  if (!LineInfo.empty())
    return LineInfo;

  // File->SourceFile contains STT_FILE symbol that contains a
  // source file name. If it's missing, we use an object file name.
  std::string SrcFile = File->SourceFile;
  if (SrcFile.empty())
    SrcFile = toString(File);

  // Find a function symbol that encloses a given location.
  for (SymbolBody *B : File->getSymbols())
    if (auto *D = dyn_cast<DefinedRegular<ELFT>>(B))
      if (D->Section == this && D->Type == STT_FUNC)
        if (D->Value <= Offset && Offset < D->Value + D->Size)
          return SrcFile + ":(function " + toString(*D) + ")";

  // If there's no symbol, print out the offset in the section.
  return (SrcFile + ":(" + Name + "+0x" + utohexstr(Offset) + ")").str();
}

template <class ELFT>
InputSection<ELFT>::InputSection() : InputSectionBase<ELFT>() {}

template <class ELFT>
InputSection<ELFT>::InputSection(uintX_t Flags, uint32_t Type,
                                 uintX_t Addralign, ArrayRef<uint8_t> Data,
                                 StringRef Name, Kind K)
    : InputSectionBase<ELFT>(nullptr, Flags, Type,
                             /*Entsize*/ 0, /*Link*/ 0, /*Info*/ 0, Addralign,
                             Data, Name, K) {}

template <class ELFT>
d123 2
a124 2
                                 const Elf_Shdr *Header, StringRef Name)
    : InputSectionBase<ELFT>(F, Header, Name, Base::Regular) {}
d127 2
a128 2
bool InputSection<ELFT>::classof(const InputSectionData *S) {
  return S->kind() == Base::Regular || S->kind() == Base::Synthetic;
d133 1
a133 1
  assert(this->Type == SHT_RELA || this->Type == SHT_REL);
d135 1
a135 1
  return Sections[this->Info];
d138 2
a139 1
template <class ELFT> void InputSection<ELFT>::addThunk(const Thunk<ELFT> *T) {
d144 1
a144 1
  return this->Data.size();
d166 1
a166 1
    Elf_Rela *P = reinterpret_cast<Elf_Rela *>(Buf);
a168 2
    if (Config->Rela)
      P->r_addend = getAddend<ELFT>(Rel);
d174 5
a178 19
static uint32_t getARMUndefinedRelativeWeakVA(uint32_t Type, uint32_t A,
                                              uint32_t P) {
  switch (Type) {
  case R_ARM_THM_JUMP11:
    return P + 2;
  case R_ARM_CALL:
  case R_ARM_JUMP24:
  case R_ARM_PC24:
  case R_ARM_PLT32:
  case R_ARM_PREL31:
  case R_ARM_THM_JUMP19:
  case R_ARM_THM_JUMP24:
    return P + 4;
  case R_ARM_THM_CALL:
    // We don't want an interworking BLX to ARM
    return P + 5;
  default:
    return A;
  }
d181 5
a185 12
static uint64_t getAArch64UndefinedRelativeWeakVA(uint64_t Type, uint64_t A,
                                                  uint64_t P) {
  switch (Type) {
  case R_AARCH64_CALL26:
  case R_AARCH64_CONDBR19:
  case R_AARCH64_JUMP26:
  case R_AARCH64_TSTBR14:
    return P + 4;
  default:
    return A;
  }
}
a186 4
template <class ELFT>
static typename ELFT::uint
getRelocTargetVA(uint32_t Type, typename ELFT::uint A, typename ELFT::uint P,
                 const SymbolBody &Body, RelExpr Expr) {
a188 1
  case R_TLSDESC_CALL:
d191 2
a192 1
    return In<ELFT>::Got->getTlsIndexOff() + A - In<ELFT>::Got->getSize();
d194 1
a194 1
    return In<ELFT>::Got->getTlsIndexVA() + A - P;
d203 2
a204 2
    return In<ELFT>::Got->getGlobalDynOffset(Body) + A -
           In<ELFT>::Got->getSize();
d206 1
a206 1
    return In<ELFT>::Got->getGlobalDynAddr(Body) + A - P;
d208 1
a208 1
    return In<ELFT>::Got->getGlobalDynAddr(Body) + A;
d210 1
a210 1
    return getAArch64Page(In<ELFT>::Got->getGlobalDynAddr(Body) + A) -
d220 1
a220 4
    return Body.getVA<ELFT>(A) - In<ELFT>::Got->getVA();
  case R_GOTREL_FROM_END:
    return Body.getVA<ELFT>(A) - In<ELFT>::Got->getVA() -
           In<ELFT>::Got->getSize();
d223 2
a224 1
    return Body.getGotOffset<ELFT>() + A - In<ELFT>::Got->getSize();
d235 1
a235 3
    return In<ELFT>::Got->getVA() + A - P;
  case R_GOTONLY_PC_FROM_END:
    return In<ELFT>::Got->getVA() + A - P + In<ELFT>::Got->getSize();
a239 8
    // A weak undefined TLS symbol resolves to the base of the TLS
    // block, i.e. gets a value of zero. If we pass --gc-sections to
    // lld and .tbss is not referenced, it gets reclaimed and we don't
    // create a TLS program header. Therefore, we resolve this
    // statically to zero.
    if (Body.isTls() && (Body.isLazy() || Body.isUndefined()) &&
        Body.symbol()->isWeak())
      return 0;
d256 1
a256 3
    return In<ELFT>::MipsGot->getVA() +
           In<ELFT>::MipsGot->getPageEntryOffset(Body, A) -
           In<ELFT>::MipsGot->getGp();
a257 1
  case R_MIPS_GOT_OFF32:
d261 1
a261 5
    return In<ELFT>::MipsGot->getVA() +
           In<ELFT>::MipsGot->getBodyEntryOffset(Body, A) -
           In<ELFT>::MipsGot->getGp();
  case R_MIPS_GOTREL:
    return Body.getVA<ELFT>(A) - In<ELFT>::MipsGot->getGp();
d263 2
a264 3
    return In<ELFT>::MipsGot->getVA() + In<ELFT>::MipsGot->getTlsOffset() +
           In<ELFT>::MipsGot->getGlobalDynOffset(Body) -
           In<ELFT>::MipsGot->getGp();
d266 2
a267 2
    return In<ELFT>::MipsGot->getVA() + In<ELFT>::MipsGot->getTlsOffset() +
           In<ELFT>::MipsGot->getTlsIndexOff() - In<ELFT>::MipsGot->getGp();
d278 2
a279 2
      uint64_t OpdStart = Out<ELF64BE>::Opd->Addr;
      uint64_t OpdEnd = OpdStart + Out<ELF64BE>::Opd->Size;
a286 8
    if (Body.isUndefined() && !Body.isLocal() && Body.symbol()->isWeak()) {
      // On ARM and AArch64 a branch to an undefined weak resolves to the
      // next instruction, otherwise the place.
      if (Config->EMachine == EM_ARM)
        return getARMUndefinedRelativeWeakVA(Type, A, P);
      if (Config->EMachine == EM_AARCH64)
        return getAArch64UndefinedRelativeWeakVA(Type, A, P);
    }
a290 2
    if (Body.isUndefined() && !Body.isLocal() && Body.symbol()->isWeak())
      return getAArch64Page(A);
d306 1
d317 1
a317 1
      error(this->getLocation(Offset) + ": has non-ABS reloc");
d321 3
a323 5
    uintX_t AddrLoc = this->OutSec->Addr + Offset;
    uint64_t SymVA = 0;
    if (!Sym.isTls() || Out<ELFT>::TlsPhdr)
      SymVA = SignExtend64<sizeof(uintX_t) * 8>(
          getRelocTargetVA<ELFT>(Type, Addend, AddrLoc, Sym, R_ABS));
d334 7
a340 5
  if (IS && !(IS->Flags & SHF_ALLOC)) {
    if (IS->AreRelocsRela)
      IS->relocateNonAlloc(Buf, IS->relas());
    else
      IS->relocateNonAlloc(Buf, IS->rels());
d345 2
a346 2
  for (const Relocation &Rel : Relocations) {
    uintX_t Offset = getOffset(Rel.Offset);
d351 1
a351 1
    uintX_t AddrLoc = OutSec->Addr + Offset;
d353 2
a354 2
    uint64_t TargetVA = SignExtend64<Bits>(
        getRelocTargetVA<ELFT>(Type, A, AddrLoc, *Rel.Sym, Expr));
d359 1
a359 1
      Target->relaxGot(BufLoc, TargetVA);
d362 1
a362 1
      Target->relaxTlsIeToLe(BufLoc, Type, TargetVA);
d365 1
a365 1
      Target->relaxTlsLdToLe(BufLoc, Type, TargetVA);
d369 1
a369 1
      Target->relaxTlsGdToLe(BufLoc, Type, TargetVA);
d375 1
a375 1
      Target->relaxTlsGdToIe(BufLoc, Type, TargetVA);
d381 1
a381 1
    // fallthrough
d383 1
a383 1
      Target->relocateOne(BufLoc, Type, TargetVA);
d390 1
a390 5
  if (this->Type == SHT_NOBITS)
    return;

  if (auto *S = dyn_cast<SyntheticSection<ELFT>>(this)) {
    S->writeTo(Buf + OutSecOff);
d392 1
a392 1
  }
d395 2
a396 2
  if (this->Type == SHT_RELA) {
    copyRelocations(Buf + OutSecOff, this->template getDataAs<Elf_Rela>());
d399 2
a400 2
  if (this->Type == SHT_REL) {
    copyRelocations(Buf + OutSecOff, this->template getDataAs<Elf_Rel>());
d405 1
a405 1
  ArrayRef<uint8_t> Data = this->Data;
d434 6
d441 2
a442 2
                                     const Elf_Shdr *Header, StringRef Name)
    : InputSectionBase<ELFT>(F, Header, Name, InputSectionBase<ELFT>::EHFrame) {
d450 2
a451 21
bool EhInputSection<ELFT>::classof(const InputSectionData *S) {
  return S->kind() == InputSectionBase<ELFT>::EHFrame;
}

// Returns the index of the first relocation that points to a region between
// Begin and Begin+Size.
template <class IntTy, class RelTy>
static unsigned getReloc(IntTy Begin, IntTy Size, const ArrayRef<RelTy> &Rels,
                         unsigned &RelocI) {
  // Start search from RelocI for fast access. That works because the
  // relocations are sorted in .eh_frame.
  for (unsigned N = Rels.size(); RelocI < N; ++RelocI) {
    const RelTy &Rel = Rels[RelocI];
    if (Rel.r_offset < Begin)
      continue;

    if (Rel.r_offset < Begin + Size)
      return RelocI;
    return -1;
  }
  return -1;
a455 15
template <class ELFT> void EhInputSection<ELFT>::split() {
  // Early exit if already split.
  if (!this->Pieces.empty())
    return;

  if (this->NumRelocations) {
    if (this->AreRelocsRela)
      split(this->relas());
    else
      split(this->rels());
    return;
  }
  split(makeArrayRef<typename ELFT::Rela>(nullptr, nullptr));
}

d457 2
a458 4
template <class RelTy>
void EhInputSection<ELFT>::split(ArrayRef<RelTy> Rels) {
  ArrayRef<uint8_t> Data = this->Data;
  unsigned RelI = 0;
d460 2
a461 2
    size_t Size = readEhRecordSize<ELFT>(this, Off);
    this->Pieces.emplace_back(Off, this, Size, getReloc(Off, Size, Rels, RelI));
d469 15
d500 3
a502 3
template <class ELFT>
void MergeInputSection<ELFT>::splitStrings(ArrayRef<uint8_t> Data,
                                           size_t EntSize) {
a503 1
  bool IsAlloc = this->Flags & SHF_ALLOC;
d507 1
a507 1
      fatal(toString(this) + ": string is not null terminated");
d509 1
a509 2
    Pieces.emplace_back(Off, !IsAlloc);
    Hashes.push_back(hash_value(toStringRef(Data.slice(0, Size))));
d513 1
d518 3
a520 3
template <class ELFT>
void MergeInputSection<ELFT>::splitNonStrings(ArrayRef<uint8_t> Data,
                                              size_t EntSize) {
d523 3
a525 5
  bool IsAlloc = this->Flags & SHF_ALLOC;
  for (unsigned I = 0, N = Size; I != N; I += EntSize) {
    Hashes.push_back(hash_value(toStringRef(Data.slice(I, EntSize))));
    Pieces.emplace_back(I, !IsAlloc);
  }
d530 3
a532 10
                                           const Elf_Shdr *Header,
                                           StringRef Name)
    : InputSectionBase<ELFT>(F, Header, Name, InputSectionBase<ELFT>::Merge) {}

// This function is called after we obtain a complete list of input sections
// that need to be linked. This is responsible to split section contents
// into small chunks for further processing.
//
// Note that this function is called from parallel_for_each. This must be
// thread-safe (i.e. no memory allocation from the pools).
d534 4
a537 4
  ArrayRef<uint8_t> Data = this->Data;
  uintX_t EntSize = this->Entsize;
  if (this->Flags & SHF_STRINGS)
    splitStrings(Data, EntSize);
d539 1
a539 1
    splitNonStrings(Data, EntSize);
d541 1
a541 1
  if (Config->GcSections && (this->Flags & SHF_ALLOC))
d547 2
a548 2
bool MergeInputSection<ELFT>::classof(const InputSectionData *S) {
  return S->kind() == InputSectionBase<ELFT>::Merge;
d553 2
a554 2
SectionPiece *MergeInputSection<ELFT>::getSectionPiece(uintX_t Offset) {
  auto *This = static_cast<const MergeInputSection<ELFT> *>(this);
a557 13
template <class It, class T, class Compare>
static It fastUpperBound(It First, It Last, const T &Value, Compare Comp) {
  size_t Size = std::distance(First, Last);
  assert(Size != 0);
  while (Size != 1) {
    size_t H = Size / 2;
    const It MI = First + H;
    Size -= H;
    First = Comp(Value, *MI) ? First : First + H;
  }
  return Comp(Value, *First) ? First : First + 1;
}

d560 4
a563 2
MergeInputSection<ELFT>::getSectionPiece(uintX_t Offset) const {
  uintX_t Size = this->Data.size();
d565 1
a565 1
    fatal(toString(this) + ": entry is past the end of the section");
d568 1
a568 1
  auto I = fastUpperBound(
a579 8
  // Initialize OffsetMap lazily.
  std::call_once(InitOffsetMap, [&] {
    OffsetMap.reserve(Pieces.size());
    for (const SectionPiece &Piece : Pieces)
      OffsetMap[Piece.InputOff] = Piece.OutputOff;
  });

  // Find a string starting at a given offset.
a583 3
  if (!this->Live)
    return 0;

d587 1
a587 3
  if (!Piece.Live)
    return 0;

d592 66
d668 5
d683 9
a691 4
template std::string lld::toString(const InputSectionBase<ELF32LE> *);
template std::string lld::toString(const InputSectionBase<ELF32BE> *);
template std::string lld::toString(const InputSectionBase<ELF64LE> *);
template std::string lld::toString(const InputSectionBase<ELF64BE> *);
@


1.1.1.3
log
@Import LLVM 4.0.0 release including clang and lld.
@
text
@d249 1
a249 2
    P->setSymbolAndType(In<ELFT>::SymTab->getSymbolIndex(&Body), Type,
                        Config->Mips64EL);
@


1.1.1.4
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@a22 1
#include "llvm/Support/Compiler.h"
a24 2
#include "llvm/Support/Path.h"
#include "llvm/Support/Threading.h"
a31 1
using namespace llvm::sys;
a35 2
std::vector<InputSectionBase *> elf::InputSections;

d37 6
a42 2
std::string lld::toString(const InputSectionBase *Sec) {
  return (toString(Sec->File) + ":(" + Sec->Name + ")").str();
d53 11
a63 10
InputSectionBase::InputSectionBase(InputFile *File, uint64_t Flags,
                                   uint32_t Type, uint64_t Entsize,
                                   uint32_t Link, uint32_t Info,
                                   uint32_t Alignment, ArrayRef<uint8_t> Data,
                                   StringRef Name, Kind SectionKind)
    : SectionBase(SectionKind, Name, Flags, Entsize, Alignment, Type, Info,
                  Link),
      File(File), Data(Data), Repl(this) {
  Live = !Config->GcSections || !(Flags & SHF_ALLOC);
  Assigned = false;
d69 1
a69 1
  uint32_t V = std::max<uint64_t>(Alignment, 1);
a71 30
  this->Alignment = V;
}

// Drop SHF_GROUP bit unless we are producing a re-linkable object file.
// SHF_GROUP is a marker that a section belongs to some comdat group.
// That flag doesn't make sense in an executable.
static uint64_t getFlags(uint64_t Flags) {
  Flags &= ~(uint64_t)SHF_INFO_LINK;
  if (!Config->Relocatable)
    Flags &= ~(uint64_t)SHF_GROUP;
  return Flags;
}

// GNU assembler 2.24 and LLVM 4.0.0's MC (the newest release as of
// March 2017) fail to infer section types for sections starting with
// ".init_array." or ".fini_array.". They set SHT_PROGBITS instead of
// SHF_INIT_ARRAY. As a result, the following assembler directive
// creates ".init_array.100" with SHT_PROGBITS, for example.
//
//   .section .init_array.100, "aw"
//
// This function forces SHT_{INIT,FINI}_ARRAY so that we can handle
// incorrect inputs as if they were correct from the beginning.
static uint64_t getType(uint64_t Type, StringRef Name) {
  if (Type == SHT_PROGBITS && Name.startswith(".init_array."))
    return SHT_INIT_ARRAY;
  if (Type == SHT_PROGBITS && Name.startswith(".fini_array."))
    return SHT_FINI_ARRAY;
  return Type;
}
a72 8
template <class ELFT>
InputSectionBase::InputSectionBase(elf::ObjectFile<ELFT> *File,
                                   const typename ELFT::Shdr *Hdr,
                                   StringRef Name, Kind SectionKind)
    : InputSectionBase(File, getFlags(Hdr->sh_flags),
                       getType(Hdr->sh_type, Name), Hdr->sh_entsize,
                       Hdr->sh_link, Hdr->sh_info, Hdr->sh_addralign,
                       getSectionContents(File, Hdr), Name, SectionKind) {
d76 1
a76 1
  if (Hdr->sh_addralign > UINT32_MAX)
d78 18
d98 2
a99 2
size_t InputSectionBase::getSize() const {
  if (auto *S = dyn_cast<SyntheticSection>(this))
d102 4
d109 2
a110 7
uint64_t InputSectionBase::getOffsetInFile() const {
  const uint8_t *FileStart = (const uint8_t *)File->MB.getBufferStart();
  const uint8_t *SecStart = Data.begin();
  return SecStart - FileStart;
}

uint64_t SectionBase::getOffset(uint64_t Offset) const {
a111 5
  case Output: {
    auto *OS = cast<OutputSection>(this);
    // For output sections we treat offset -1 as the end of the section.
    return Offset == uint64_t(-1) ? OS->Size : Offset;
  }
d113 2
a114 3
    return cast<InputSection>(this)->OutSecOff + Offset;
  case Synthetic: {
    auto *IS = cast<InputSection>(this);
d116 3
a118 2
    return IS->OutSecOff + (Offset == uint64_t(-1) ? IS->getSize() : Offset);
  }
d125 1
a125 4
    const MergeInputSection *MS = cast<MergeInputSection>(this);
    if (InputSection *IS = MS->getParent())
      return IS->OutSecOff + MS->getOffset(Offset);
    return MS->getOffset(Offset);
a129 13
OutputSection *SectionBase::getOutputSection() {
  InputSection *Sec;
  if (auto *IS = dyn_cast<InputSection>(this))
    Sec = IS;
  else if (auto *MS = dyn_cast<MergeInputSection>(this))
    Sec = MS->getParent();
  else if (auto *EH = dyn_cast<EhInputSection>(this))
    Sec = EH->getParent();
  else
    return cast<OutputSection>(this);
  return Sec ? Sec->getParent() : nullptr;
}

d132 4
a135 3
void InputSectionBase::uncompress() {
  Decompressor Dec = check(Decompressor::create(Name, toStringRef(Data),
                                                Config->IsLE, Config->Is64));
d137 1
a137 1
  size_t Size = Dec.getDecompressedSize();
d145 3
a147 5
  if (Error E = Dec.decompress({OutputBuf, Size}))
    fatal(toString(this) +
          ": decompress failed: " + llvm::toString(std::move(E)));
  this->Data = ArrayRef<uint8_t>((uint8_t *)OutputBuf, Size);
  this->Flags &= ~(uint64_t)SHF_COMPRESSED;
d150 3
a152 1
uint64_t SectionBase::getOffset(const DefinedRegular &Sym) const {
d156 4
a159 9
InputSection *InputSectionBase::getLinkOrderDep() const {
  if ((Flags & SHF_LINK_ORDER) && Link != 0) {
    InputSectionBase *L = File->getSections()[Link];
    if (auto *IS = dyn_cast<InputSection>(L))
      return IS;
    error(
        "Merge and .eh_frame sections are not supported with SHF_LINK_ORDER " +
        toString(L));
  }
d165 1
a165 6
std::string InputSectionBase::getLocation(uint64_t Offset) {
  // We don't have file for synthetic sections.
  if (getFile<ELFT>() == nullptr)
    return (Config->OutputFile + ":(" + Name + "+0x" + utohexstr(Offset) + ")")
        .str();

d167 1
a167 1
  std::string LineInfo = getFile<ELFT>()->getLineInfo(this, Offset);
d173 1
a173 1
  std::string SrcFile = getFile<ELFT>()->SourceFile;
d178 2
a179 2
  for (SymbolBody *B : getFile<ELFT>()->getSymbols())
    if (auto *D = dyn_cast<DefinedRegular>(B))
d188 2
a189 52
// Returns a source location string. This function is intended to be
// used for constructing an error message. The returned message looks
// like this:
//
//   foo.c:42 (/home/alice/possibly/very/long/path/foo.c:42)
//
// Returns an empty string if there's no way to get line info.
template <class ELFT> std::string InputSectionBase::getSrcMsg(uint64_t Offset) {
  // Synthetic sections don't have input files.
  elf::ObjectFile<ELFT> *File = getFile<ELFT>();
  if (!File)
    return "";

  Optional<DILineInfo> Info = File->getDILineInfo(this, Offset);

  // File->SourceFile contains STT_FILE symbol, and that is a last resort.
  if (!Info)
    return File->SourceFile;

  std::string Path = Info->FileName;
  std::string Filename = path::filename(Path);
  std::string Lineno = ":" + std::to_string(Info->Line);
  if (Filename == Path)
    return Filename + Lineno;
  return Filename + Lineno + " (" + Path + Lineno + ")";
}

// Returns a filename string along with an optional section name. This
// function is intended to be used for constructing an error
// message. The returned message looks like this:
//
//   path/to/foo.o:(function bar)
//
// or
//
//   path/to/foo.o:(function bar) in archive path/to/bar.a
template <class ELFT> std::string InputSectionBase::getObjMsg(uint64_t Off) {
  // Synthetic sections don't have input files.
  elf::ObjectFile<ELFT> *File = getFile<ELFT>();
  if (!File)
    return ("(internal):(" + Name + "+0x" + utohexstr(Off) + ")").str();
  std::string Filename = File->getName();

  std::string Archive;
  if (!File->ArchiveName.empty())
    Archive = (" in archive " + File->ArchiveName).str();

  // Find a symbol that encloses a given location.
  for (SymbolBody *B : getFile<ELFT>()->getSymbols())
    if (auto *D = dyn_cast<DefinedRegular>(B))
      if (D->Section == this && D->Value <= Off && Off < D->Value + D->Size)
        return Filename + ":(" + toString(*D) + ")" + Archive;
d191 7
a197 4
  // If there's no symbol, print out the offset in the section.
  return (Filename + ":(" + Name + "+0x" + utohexstr(Off) + ")" + Archive)
      .str();
}
d199 4
a202 1
InputSectionBase InputSectionBase::Discarded;
d204 4
a207 5
InputSection::InputSection(uint64_t Flags, uint32_t Type, uint32_t Alignment,
                           ArrayRef<uint8_t> Data, StringRef Name, Kind K)
    : InputSectionBase(nullptr, Flags, Type,
                       /*Entsize*/ 0, /*Link*/ 0, /*Info*/ 0, Alignment, Data,
                       Name, K) {}
d210 4
a213 7
InputSection::InputSection(elf::ObjectFile<ELFT> *F,
                           const typename ELFT::Shdr *Header, StringRef Name)
    : InputSectionBase(F, Header, Name, InputSectionBase::Regular) {}

bool InputSection::classof(const SectionBase *S) {
  return S->kind() == SectionBase::Regular ||
         S->kind() == SectionBase::Synthetic;
d216 2
a217 2
bool InputSectionBase::classof(const SectionBase *S) {
  return S->kind() != Output;
d220 2
a221 2
OutputSection *InputSection::getParent() const {
  return cast_or_null<OutputSection>(Parent);
d224 5
a228 15
// Copy SHT_GROUP section contents. Used only for the -r option.
template <class ELFT> void InputSection::copyShtGroup(uint8_t *Buf) {
  // ELFT::Word is the 32-bit integral type in the target endianness.
  typedef typename ELFT::Word u32;
  ArrayRef<u32> From = getDataAs<u32>();
  auto *To = reinterpret_cast<u32 *>(Buf);

  // The first entry is not a section number but a flag.
  *To++ = From[0];

  // Adjust section numbers because section numbers in an input object
  // files are different in the output.
  ArrayRef<InputSectionBase *> Sections = this->File->getSections();
  for (uint32_t Idx : From.slice(1))
    *To++ = Sections[Idx]->getOutputSection()->SectionIndex;
d231 7
a237 5
InputSectionBase *InputSection::getRelocatedSection() {
  assert(this->Type == SHT_RELA || this->Type == SHT_REL);
  ArrayRef<InputSectionBase *> Sections = this->File->getSections();
  return Sections[this->Info];
}
a238 11
// This is used for -r and --emit-relocs. We can't use memcpy to copy
// relocations because we need to update symbol table offset and section index
// for each relocation. So we copy relocations one by one.
template <class ELFT, class RelTy>
void InputSection::copyRelocations(uint8_t *Buf, ArrayRef<RelTy> Rels) {
  InputSectionBase *RelocatedSection = getRelocatedSection();

  // Loop is slow and have complexity O(N*M), where N - amount of
  // relocations and M - amount of symbols in symbol table.
  // That happens because getSymbolIndex(...) call below performs
  // simple linear search.
d240 2
a241 2
    uint32_t Type = Rel.getType(Config->IsMips64EL);
    SymbolBody &Body = this->getFile<ELFT>()->getRelocTargetSym(Rel);
d243 1
a243 1
    auto *P = reinterpret_cast<typename ELFT::Rela *>(Buf);
d246 1
a246 1
    if (Config->IsRela)
d248 3
a250 34

    // Output section VA is zero for -r, so r_offset is an offset within the
    // section, but for --emit-relocs it is an virtual address.
    P->r_offset = RelocatedSection->getOutputSection()->Addr +
                  RelocatedSection->getOffset(Rel.r_offset);
    P->setSymbolAndType(InX::SymTab->getSymbolIndex(&Body), Type,
                        Config->IsMips64EL);

    if (Body.Type == STT_SECTION) {
      // We combine multiple section symbols into only one per
      // section. This means we have to update the addend. That is
      // trivial for Elf_Rela, but for Elf_Rel we have to write to the
      // section data. We do that by adding to the Relocation vector.

      // .eh_frame is horribly special and can reference discarded sections. To
      // avoid having to parse and recreate .eh_frame, we just replace any
      // relocation in it pointing to discarded sections with R_*_NONE, which
      // hopefully creates a frame that is ignored at runtime.
      SectionBase *Section = cast<DefinedRegular>(Body).Section;
      if (Section == &InputSection::Discarded) {
        P->setSymbolAndType(0, 0, false);
        continue;
      }

      if (Config->IsRela) {
        P->r_addend += Body.getVA() - Section->getOutputSection()->Addr;
      } else if (Config->Relocatable) {
        const uint8_t *BufLoc = RelocatedSection->Data.begin() + Rel.r_offset;
        RelocatedSection->Relocations.push_back(
            {R_ABS, Type, Rel.r_offset, Target->getImplicitAddend(BufLoc, Type),
             &Body});
      }
    }

a253 5
// The ARM and AArch64 ABI handle pc-relative relocations to undefined weak
// references specially. The general rule is that the value of the symbol in
// this context is the address of the place P. A further special case is that
// branch relocations to an undefined weak reference resolve to the next
// instruction.
a256 2
  // Unresolved branch relocations to weak references resolve to next
  // instruction, this will be either 2 or 4 bytes on from P.
d258 1
a258 1
    return P + 2 + A;
d266 1
a266 1
    return P + 4 + A;
d269 3
a271 10
    return P + 5 + A;
  // Unresolved non branch pc-relative relocations
  // R_ARM_TARGET2 which can be resolved relatively is not present as it never
  // targets a weak-reference.
  case R_ARM_MOVW_PREL_NC:
  case R_ARM_MOVT_PREL:
  case R_ARM_REL32:
  case R_ARM_THM_MOVW_PREL_NC:
  case R_ARM_THM_MOVT_PREL:
    return P + A;
a272 1
  llvm_unreachable("ARM pc-relative relocation expected\n");
a274 1
// The comment above getARMUndefinedRelativeWeakVA applies to this function.
a277 2
  // Unresolved branch relocations to weak references resolve to next
  // instruction, this is 4 bytes on from P.
d282 4
a285 23
    return P + 4 + A;
  // Unresolved non branch pc-relative relocations
  case R_AARCH64_PREL16:
  case R_AARCH64_PREL32:
  case R_AARCH64_PREL64:
  case R_AARCH64_ADR_PREL_LO21:
    return P + A;
  }
  llvm_unreachable("AArch64 pc-relative relocation expected\n");
}

// ARM SBREL relocations are of the form S + A - B where B is the static base
// The ARM ABI defines base to be "addressing origin of the output segment
// defining the symbol S". We defined the "addressing origin"/static base to be
// the base of the PT_LOAD segment containing the Body.
// The procedure call standard only defines a Read Write Position Independent
// RWPI variant so in practice we should expect the static base to be the base
// of the RW segment.
static uint64_t getARMStaticBase(const SymbolBody &Body) {
  OutputSection *OS = Body.getOutputSection();
  if (!OS || !OS->FirstInPtLoad)
    fatal("SBREL relocation to " + Body.getName() + " without static base");
  return OS->FirstInPtLoad->Addr;
d288 4
a291 2
static uint64_t getRelocTargetVA(uint32_t Type, int64_t A, uint64_t P,
                                 const SymbolBody &Body, RelExpr Expr) {
d293 31
a323 12
  case R_ABS:
  case R_RELAX_GOT_PC_NOPIC:
    return Body.getVA(A);
  case R_ARM_SBREL:
    return Body.getVA(A) - getARMStaticBase(Body);
  case R_GOT:
  case R_RELAX_TLS_GD_TO_IE_ABS:
    return Body.getGotVA() + A;
  case R_GOTONLY_PC:
    return InX::Got->getVA() + A - P;
  case R_GOTONLY_PC_FROM_END:
    return InX::Got->getVA() + A - P + InX::Got->getSize();
d325 1
a325 1
    return Body.getVA(A) - InX::Got->getVA();
d327 3
a329 1
    return Body.getVA(A) - InX::Got->getVA() - InX::Got->getSize();
d331 5
a335 4
  case R_RELAX_TLS_GD_TO_IE_END:
    return Body.getGotOffset() + A - InX::Got->getSize();
  case R_GOT_OFF:
    return Body.getGotOffset() + A;
d337 2
a338 2
  case R_RELAX_TLS_GD_TO_IE_PAGE_PC:
    return getAArch64Page(Body.getGotVA() + A) - getAArch64Page(P);
d340 29
a368 20
  case R_RELAX_TLS_GD_TO_IE:
    return Body.getGotVA() + A - P;
  case R_HINT:
  case R_NONE:
  case R_TLSDESC_CALL:
    llvm_unreachable("cannot relocate hint relocs");
  case R_MIPS_GOTREL:
    return Body.getVA(A) - InX::MipsGot->getGp();
  case R_MIPS_GOT_GP:
    return InX::MipsGot->getGp() + A;
  case R_MIPS_GOT_GP_PC: {
    // R_MIPS_LO16 expression has R_MIPS_GOT_GP_PC type iif the target
    // is _gp_disp symbol. In that case we should use the following
    // formula for calculation "AHL + GP - P + 4". For details see p. 4-19 at
    // ftp://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf
    uint64_t V = InX::MipsGot->getGp() + A - P;
    if (Type == R_MIPS_LO16)
      V += 4;
    return V;
  }
d373 3
a375 2
    return InX::MipsGot->getVA() + InX::MipsGot->getPageEntryOffset(Body, A) -
           InX::MipsGot->getGp();
d381 5
a385 2
    return InX::MipsGot->getVA() + InX::MipsGot->getBodyEntryOffset(Body, A) -
           InX::MipsGot->getGp();
d387 3
a389 2
    return InX::MipsGot->getVA() + InX::MipsGot->getTlsOffset() +
           InX::MipsGot->getGlobalDynOffset(Body) - InX::MipsGot->getGp();
d391 2
a392 32
    return InX::MipsGot->getVA() + InX::MipsGot->getTlsOffset() +
           InX::MipsGot->getTlsIndexOff() - InX::MipsGot->getGp();
  case R_PAGE_PC:
  case R_PLT_PAGE_PC: {
    uint64_t Dest;
    if (Body.isUndefined() && !Body.isLocal() && Body.symbol()->isWeak())
      Dest = getAArch64Page(A);
    else
      Dest = getAArch64Page(Body.getVA(A));
    return Dest - getAArch64Page(P);
  }
  case R_PC: {
    uint64_t Dest;
    if (Body.isUndefined() && !Body.isLocal() && Body.symbol()->isWeak()) {
      // On ARM and AArch64 a branch to an undefined weak resolves to the
      // next instruction, otherwise the place.
      if (Config->EMachine == EM_ARM)
        Dest = getARMUndefinedRelativeWeakVA(Type, A, P);
      else if (Config->EMachine == EM_AARCH64)
        Dest = getAArch64UndefinedRelativeWeakVA(Type, A, P);
      else
        Dest = Body.getVA(A);
    } else {
      Dest = Body.getVA(A);
    }
    return Dest - P;
  }
  case R_PLT:
    return Body.getPltVA() + A;
  case R_PLT_PC:
  case R_PPC_PLT_OPD:
    return Body.getPltVA() + A - P;
d394 1
a394 1
    uint64_t SymVA = Body.getVA(A);
d400 1
a400 1
    if (Out::Opd) {
d403 2
a404 2
      uint64_t OpdStart = Out::Opd->Addr;
      uint64_t OpdEnd = OpdStart + Out::Opd->Size;
d407 1
a407 1
        SymVA = read64be(&Out::OpdBuf[SymVA - OpdStart]);
d411 9
a419 2
  case R_PPC_TOC:
    return getPPC64TocBase() + A;
d421 6
a426 34
    return Body.getVA(A) - P;
  case R_RELAX_TLS_GD_TO_LE:
  case R_RELAX_TLS_IE_TO_LE:
  case R_RELAX_TLS_LD_TO_LE:
  case R_TLS:
    // A weak undefined TLS symbol resolves to the base of the TLS
    // block, i.e. gets a value of zero. If we pass --gc-sections to
    // lld and .tbss is not referenced, it gets reclaimed and we don't
    // create a TLS program header. Therefore, we resolve this
    // statically to zero.
    if (Body.isTls() && (Body.isLazy() || Body.isUndefined()) &&
        Body.symbol()->isWeak())
      return 0;
    if (Target->TcbSize)
      return Body.getVA(A) + alignTo(Target->TcbSize, Out::TlsPhdr->p_align);
    return Body.getVA(A) - Out::TlsPhdr->p_memsz;
  case R_RELAX_TLS_GD_TO_LE_NEG:
  case R_NEG_TLS:
    return Out::TlsPhdr->p_memsz - Body.getVA(A);
  case R_SIZE:
    return A; // Body.getSize was already folded into the addend.
  case R_TLSDESC:
    return InX::Got->getGlobalDynAddr(Body) + A;
  case R_TLSDESC_PAGE:
    return getAArch64Page(InX::Got->getGlobalDynAddr(Body) + A) -
           getAArch64Page(P);
  case R_TLSGD:
    return InX::Got->getGlobalDynOffset(Body) + A - InX::Got->getSize();
  case R_TLSGD_PC:
    return InX::Got->getGlobalDynAddr(Body) + A - P;
  case R_TLSLD:
    return InX::Got->getTlsIndexOff() + A - InX::Got->getSize();
  case R_TLSLD_PC:
    return InX::Got->getTlsIndexVA() + A - P;
d438 3
a440 2
template <class ELFT, class RelTy>
void InputSection::relocateNonAlloc(uint8_t *Buf, ArrayRef<RelTy> Rels) {
d442 2
a443 2
    uint32_t Type = Rel.getType(Config->IsMips64EL);
    uint64_t Offset = getOffset(Rel.r_offset);
d445 1
a445 1
    int64_t Addend = getAddend<ELFT>(Rel);
d449 3
a451 6
    SymbolBody &Sym = this->getFile<ELFT>()->getRelocTargetSym(Rel);
    RelExpr Expr = Target->getRelExpr(Type, Sym, BufLoc);
    if (Expr == R_NONE)
      continue;
    if (Expr != R_ABS) {
      error(this->getLocation<ELFT>(Offset) + ": has non-ABS reloc");
d455 1
a455 1
    uint64_t AddrLoc = getParent()->Addr + Offset;
d457 3
a459 3
    if (!Sym.isTls() || Out::TlsPhdr)
      SymVA = SignExtend64<sizeof(typename ELFT::uint) * 8>(
          getRelocTargetVA(Type, Addend, AddrLoc, Sym, R_ABS));
a463 12
template <class ELFT> elf::ObjectFile<ELFT> *InputSectionBase::getFile() const {
  return cast_or_null<elf::ObjectFile<ELFT>>(File);
}

template <class ELFT>
void InputSectionBase::relocate(uint8_t *Buf, uint8_t *BufEnd) {
  if (Flags & SHF_ALLOC)
    relocateAlloc(Buf, BufEnd);
  else
    relocateNonAlloc<ELFT>(Buf, BufEnd);
}

d465 1
a465 1
void InputSectionBase::relocateNonAlloc(uint8_t *Buf, uint8_t *BufEnd) {
d469 8
a476 7
  auto *IS = cast<InputSection>(this);
  assert(!(IS->Flags & SHF_ALLOC));
  if (IS->AreRelocsRela)
    IS->relocateNonAlloc<ELFT>(Buf, IS->template relas<ELFT>());
  else
    IS->relocateNonAlloc<ELFT>(Buf, IS->template rels<ELFT>());
}
d478 1
a478 3
void InputSectionBase::relocateAlloc(uint8_t *Buf, uint8_t *BufEnd) {
  assert(Flags & SHF_ALLOC);
  const unsigned Bits = Config->Wordsize * 8;
d480 1
a480 1
    uint64_t Offset = getOffset(Rel.Offset);
d483 1
d485 1
a485 1
    uint64_t AddrLoc = getOutputSection()->Addr + Offset;
d487 2
a488 2
    uint64_t TargetVA = SignExtend64(
        getRelocTargetVA(Type, Rel.Addend, AddrLoc, *Rel.Sym, Expr), Bits);
d515 1
a515 1
      LLVM_FALLTHROUGH;
d523 1
a523 1
template <class ELFT> void InputSection::writeTo(uint8_t *Buf) {
d527 1
a527 1
  if (auto *S = dyn_cast<SyntheticSection>(this)) {
d532 1
a532 2
  // If -r or --emit-relocs is given, then an InputSection
  // may be a relocation section.
d534 1
a534 2
    copyRelocations<ELFT>(Buf + OutSecOff,
                          this->template getDataAs<typename ELFT::Rela>());
d538 1
a538 2
    copyRelocations<ELFT>(Buf + OutSecOff,
                          this->template getDataAs<typename ELFT::Rel>());
d542 3
a544 5
  // If -r is given, we may have a SHT_GROUP section.
  if (this->Type == SHT_GROUP) {
    copyShtGroup<ELFT>(Buf + OutSecOff);
    return;
  }
d546 1
a546 3
  // Copy section contents from source object file to output file
  // and then apply relocations.
  memcpy(Buf + OutSecOff, Data.data(), Data.size());
d548 14
a561 1
  this->relocate<ELFT>(Buf, BufEnd);
d564 2
a565 1
void InputSection::replace(InputSection *Other) {
d572 3
a574 4
EhInputSection::EhInputSection(elf::ObjectFile<ELFT> *F,
                               const typename ELFT::Shdr *Header,
                               StringRef Name)
    : InputSectionBase(F, Header, Name, InputSectionBase::EHFrame) {
d581 3
a583 6
SyntheticSection *EhInputSection::getParent() const {
  return cast_or_null<SyntheticSection>(Parent);
}

bool EhInputSection::classof(const SectionBase *S) {
  return S->kind() == InputSectionBase::EHFrame;
d607 1
a607 1
template <class ELFT> void EhInputSection::split() {
d614 1
a614 1
      split<ELFT>(this->relas<ELFT>());
d616 1
a616 1
      split<ELFT>(this->rels<ELFT>());
d619 1
a619 1
  split<ELFT>(makeArrayRef<typename ELFT::Rela>(nullptr, nullptr));
d622 3
a624 2
template <class ELFT, class RelTy>
void EhInputSection::split(ArrayRef<RelTy> Rels) {
a650 4
SyntheticSection *MergeInputSection::getParent() const {
  return cast_or_null<SyntheticSection>(Parent);
}

d653 3
a655 1
void MergeInputSection::splitStrings(ArrayRef<uint8_t> Data, size_t EntSize) {
d672 3
a674 2
void MergeInputSection::splitNonStrings(ArrayRef<uint8_t> Data,
                                        size_t EntSize) {
d685 4
a688 4
MergeInputSection::MergeInputSection(elf::ObjectFile<ELFT> *F,
                                     const typename ELFT::Shdr *Header,
                                     StringRef Name)
    : InputSectionBase(F, Header, Name, InputSectionBase::Merge) {}
d696 1
a696 1
void MergeInputSection::splitIntoPieces() {
d698 1
a698 1
  uint64_t EntSize = this->Entsize;
d705 1
a705 1
    for (uint64_t Off : LiveOffsets)
d709 3
a711 2
bool MergeInputSection::classof(const SectionBase *S) {
  return S->kind() == InputSectionBase::Merge;
d715 3
a717 2
SectionPiece *MergeInputSection::getSectionPiece(uint64_t Offset) {
  auto *This = static_cast<const MergeInputSection *>(this);
d734 4
a737 2
const SectionPiece *MergeInputSection::getSectionPiece(uint64_t Offset) const {
  uint64_t Size = this->Data.size();
d744 1
a744 1
      [](const uint64_t &A, const SectionPiece &B) { return A < B.InputOff; });
d752 2
a753 1
uint64_t MergeInputSection::getOffset(uint64_t Offset) const {
d755 1
a755 1
  llvm::call_once(InitOffsetMap, [&] {
d775 1
a775 1
  uint64_t Addend = Offset - Piece.InputOff;
d779 24
a802 56
template InputSection::InputSection(elf::ObjectFile<ELF32LE> *,
                                    const ELF32LE::Shdr *, StringRef);
template InputSection::InputSection(elf::ObjectFile<ELF32BE> *,
                                    const ELF32BE::Shdr *, StringRef);
template InputSection::InputSection(elf::ObjectFile<ELF64LE> *,
                                    const ELF64LE::Shdr *, StringRef);
template InputSection::InputSection(elf::ObjectFile<ELF64BE> *,
                                    const ELF64BE::Shdr *, StringRef);

template std::string InputSectionBase::getLocation<ELF32LE>(uint64_t);
template std::string InputSectionBase::getLocation<ELF32BE>(uint64_t);
template std::string InputSectionBase::getLocation<ELF64LE>(uint64_t);
template std::string InputSectionBase::getLocation<ELF64BE>(uint64_t);

template std::string InputSectionBase::getSrcMsg<ELF32LE>(uint64_t);
template std::string InputSectionBase::getSrcMsg<ELF32BE>(uint64_t);
template std::string InputSectionBase::getSrcMsg<ELF64LE>(uint64_t);
template std::string InputSectionBase::getSrcMsg<ELF64BE>(uint64_t);

template std::string InputSectionBase::getObjMsg<ELF32LE>(uint64_t);
template std::string InputSectionBase::getObjMsg<ELF32BE>(uint64_t);
template std::string InputSectionBase::getObjMsg<ELF64LE>(uint64_t);
template std::string InputSectionBase::getObjMsg<ELF64BE>(uint64_t);

template void InputSection::writeTo<ELF32LE>(uint8_t *);
template void InputSection::writeTo<ELF32BE>(uint8_t *);
template void InputSection::writeTo<ELF64LE>(uint8_t *);
template void InputSection::writeTo<ELF64BE>(uint8_t *);

template elf::ObjectFile<ELF32LE> *InputSectionBase::getFile<ELF32LE>() const;
template elf::ObjectFile<ELF32BE> *InputSectionBase::getFile<ELF32BE>() const;
template elf::ObjectFile<ELF64LE> *InputSectionBase::getFile<ELF64LE>() const;
template elf::ObjectFile<ELF64BE> *InputSectionBase::getFile<ELF64BE>() const;

template MergeInputSection::MergeInputSection(elf::ObjectFile<ELF32LE> *,
                                              const ELF32LE::Shdr *, StringRef);
template MergeInputSection::MergeInputSection(elf::ObjectFile<ELF32BE> *,
                                              const ELF32BE::Shdr *, StringRef);
template MergeInputSection::MergeInputSection(elf::ObjectFile<ELF64LE> *,
                                              const ELF64LE::Shdr *, StringRef);
template MergeInputSection::MergeInputSection(elf::ObjectFile<ELF64BE> *,
                                              const ELF64BE::Shdr *, StringRef);

template EhInputSection::EhInputSection(elf::ObjectFile<ELF32LE> *,
                                        const ELF32LE::Shdr *, StringRef);
template EhInputSection::EhInputSection(elf::ObjectFile<ELF32BE> *,
                                        const ELF32BE::Shdr *, StringRef);
template EhInputSection::EhInputSection(elf::ObjectFile<ELF64LE> *,
                                        const ELF64LE::Shdr *, StringRef);
template EhInputSection::EhInputSection(elf::ObjectFile<ELF64BE> *,
                                        const ELF64BE::Shdr *, StringRef);

template void EhInputSection::split<ELF32LE>();
template void EhInputSection::split<ELF32BE>();
template void EhInputSection::split<ELF64LE>();
template void EhInputSection::split<ELF64BE>();
@


