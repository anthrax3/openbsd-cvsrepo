head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.1
date	2017.01.14.19.55.45;	author patrick;	state Exp;
branches
	1.1.1.1;
next	;
commitid	qMUxATnKgqN83Oct;

1.1.1.1
date	2017.01.14.19.55.45;	author patrick;	state Exp;
branches;
next	1.1.1.2;
commitid	qMUxATnKgqN83Oct;

1.1.1.2
date	2017.01.24.08.33.12;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===- ScriptParser.cpp ---------------------------------------------------===//
//
//                             The LLVM Linker
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file contains the base parser class for linker script and dynamic
// list.
//
//===----------------------------------------------------------------------===//

#include "ScriptParser.h"
#include "Error.h"
#include "llvm/ADT/Twine.h"

using namespace llvm;
using namespace lld;
using namespace lld::elf;

// Returns the line that the character S[Pos] is in.
static StringRef getLine(StringRef S, size_t Pos) {
  size_t Begin = S.rfind('\n', Pos);
  size_t End = S.find('\n', Pos);
  Begin = (Begin == StringRef::npos) ? 0 : Begin + 1;
  if (End == StringRef::npos)
    End = S.size();
  // rtrim for DOS-style newlines.
  return S.substr(Begin, End - Begin).rtrim();
}

void ScriptParserBase::printErrorPos() {
  StringRef Tok = Tokens[Pos == 0 ? 0 : Pos - 1];
  StringRef Line = getLine(Input, Tok.data() - Input.data());
  size_t Col = Tok.data() - Line.data();
  error(Line);
  error(std::string(Col, ' ') + "^");
}

// We don't want to record cascading errors. Keep only the first one.
void ScriptParserBase::setError(const Twine &Msg) {
  if (Error)
    return;
  if (Input.empty() || Tokens.empty()) {
    error(Msg);
  } else {
    error("line " + Twine(getPos()) + ": " + Msg);
    printErrorPos();
  }
  Error = true;
}

// Split S into linker script tokens.
std::vector<StringRef> ScriptParserBase::tokenize(StringRef S) {
  std::vector<StringRef> Ret;
  for (;;) {
    S = skipSpace(S);
    if (S.empty())
      return Ret;

    // Quoted token
    if (S.startswith("\"")) {
      size_t E = S.find("\"", 1);
      if (E == StringRef::npos) {
        error("unclosed quote");
        return {};
      }
      Ret.push_back(S.substr(1, E - 1));
      S = S.substr(E + 1);
      continue;
    }

    // Unquoted token
    size_t Pos = S.find_first_not_of(
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
        "0123456789_.$/\\~=+[]*?-:!<>");
    // A character that cannot start a word (which is usually a
    // punctuation) forms a single character token.
    if (Pos == 0)
      Pos = 1;
    Ret.push_back(S.substr(0, Pos));
    S = S.substr(Pos);
  }
}

// Skip leading whitespace characters or comments.
StringRef ScriptParserBase::skipSpace(StringRef S) {
  for (;;) {
    if (S.startswith("/*")) {
      size_t E = S.find("*/", 2);
      if (E == StringRef::npos) {
        error("unclosed comment in a linker script");
        return "";
      }
      S = S.substr(E + 2);
      continue;
    }
    if (S.startswith("#")) {
      size_t E = S.find('\n', 1);
      if (E == StringRef::npos)
        E = S.size() - 1;
      S = S.substr(E + 1);
      continue;
    }
    size_t Size = S.size();
    S = S.ltrim();
    if (S.size() == Size)
      return S;
  }
}

// An erroneous token is handled as if it were the last token before EOF.
bool ScriptParserBase::atEOF() { return Error || Tokens.size() == Pos; }

StringRef ScriptParserBase::next() {
  if (Error)
    return "";
  if (atEOF()) {
    setError("unexpected EOF");
    return "";
  }
  return Tokens[Pos++];
}

StringRef ScriptParserBase::peek() {
  StringRef Tok = next();
  if (Error)
    return "";
  --Pos;
  return Tok;
}

bool ScriptParserBase::skip(StringRef Tok) {
  if (Error)
    return false;
  if (atEOF()) {
    setError("unexpected EOF");
    return false;
  }
  if (Tokens[Pos] != Tok)
    return false;
  ++Pos;
  return true;
}

void ScriptParserBase::expect(StringRef Expect) {
  if (Error)
    return;
  StringRef Tok = next();
  if (Tok != Expect)
    setError(Expect + " expected, but got " + Tok);
}

// Returns the current line number.
size_t ScriptParserBase::getPos() {
  if (Pos == 0)
    return 1;
  const char *Begin = Input.data();
  const char *Tok = Tokens[Pos - 1].data();
  return StringRef(Begin, Tok - Begin).count('\n') + 1;
}
@


1.1.1.1
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d23 17
a39 29
// Returns a whole line containing the current token.
StringRef ScriptParserBase::getLine() {
  StringRef S = getCurrentMB().getBuffer();
  StringRef Tok = Tokens[Pos - 1];

  size_t Pos = S.rfind('\n', Tok.data() - S.data());
  if (Pos != StringRef::npos)
    S = S.substr(Pos + 1);
  return S.substr(0, S.find_first_of("\r\n"));
}

// Returns 1-based line number of the current token.
size_t ScriptParserBase::getLineNumber() {
  StringRef S = getCurrentMB().getBuffer();
  StringRef Tok = Tokens[Pos - 1];
  return S.substr(0, Tok.data() - S.data()).count('\n') + 1;
}

// Returns 0-based column number of the current token.
size_t ScriptParserBase::getColumnNumber() {
  StringRef Tok = Tokens[Pos - 1];
  return Tok.data() - getLine().data();
}

std::string ScriptParserBase::getCurrentLocation() {
  std::string Filename = getCurrentMB().getBufferIdentifier();
  if (!Pos)
    return Filename;
  return (Filename + ":" + Twine(getLineNumber())).str();
a41 2
ScriptParserBase::ScriptParserBase(MemoryBufferRef MB) { tokenize(MB); }

d46 6
a52 10

  if (!Pos) {
    error(getCurrentLocation() + ": " + Msg);
    return;
  }

  std::string S = getCurrentLocation() + ": ";
  error(S + Msg);
  error(S + getLine());
  error(S + std::string(getColumnNumber(), ' ') + "^");
d56 2
a57 6
void ScriptParserBase::tokenize(MemoryBufferRef MB) {
  std::vector<StringRef> Vec;
  MBs.push_back(MB);
  StringRef S = MB.getBuffer();
  StringRef Begin = S;

d61 1
a61 1
      break;
d63 1
a63 4
    // Quoted token. Note that double-quote characters are parts of a token
    // because, in a glob match context, only unquoted tokens are interpreted
    // as glob patterns. Double-quoted tokens are literal patterns in that
    // context.
d67 2
a68 4
        StringRef Filename = MB.getBufferIdentifier();
        size_t Lineno = Begin.substr(0, S.data() - Begin.data()).count('\n');
        error(Filename + ":" + Twine(Lineno + 1) + ": unclosed quote");
        return;
d70 1
a70 2

      Vec.push_back(S.take_front(E + 1));
d75 1
a75 2
    // Unquoted token. This is more relaxed than tokens in C-like language,
    // so that you can write "file-name.cpp" as one bare token, for example.
d78 1
a78 2
        "0123456789_.$/\\~=+[]*?-:!<>^");

d83 1
a83 1
    Vec.push_back(S.substr(0, Pos));
a85 2

  Tokens.insert(Tokens.begin() + Pos, Vec.begin(), Vec.end());
d135 6
a140 4
bool ScriptParserBase::consume(StringRef Tok) {
  if (peek() == Tok) {
    skip();
    return true;
d142 4
a145 1
  return false;
a147 2
void ScriptParserBase::skip() { (void)next(); }

d156 7
a162 15
// Returns true if S encloses T.
static bool encloses(StringRef S, StringRef T) {
  return S.bytes_begin() <= T.bytes_begin() && T.bytes_end() <= S.bytes_end();
}

MemoryBufferRef ScriptParserBase::getCurrentMB() {
  // Find input buffer containing the current token.
  assert(!MBs.empty());
  if (!Pos)
    return MBs[0];

  for (MemoryBufferRef MB : MBs)
    if (encloses(MB.getBuffer(), Tokens[Pos - 1]))
      return MB;
  llvm_unreachable("getCurrentMB: failed to find a token");
@

