head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.1
date	2017.01.14.19.55.45;	author patrick;	state Exp;
branches
	1.1.1.1;
next	;
commitid	qMUxATnKgqN83Oct;

1.1.1.1
date	2017.01.14.19.55.45;	author patrick;	state Exp;
branches;
next	1.1.1.2;
commitid	qMUxATnKgqN83Oct;

1.1.1.2
date	2017.01.24.08.33.12;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	so2WA7LCP6wbxtYl;

1.1.1.3
date	2017.03.14.08.07.53;	author patrick;	state Exp;
branches;
next	;
commitid	aUi5NxOzBSLCN5eN;


desc
@@


1.1
log
@Initial revision
@
text
@//===- InputFiles.h ---------------------------------------------*- C++ -*-===//
//
//                             The LLVM Linker
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef LLD_ELF_INPUT_FILES_H
#define LLD_ELF_INPUT_FILES_H

#include "Config.h"
#include "InputSection.h"
#include "Error.h"
#include "Symbols.h"

#include "lld/Core/LLVM.h"
#include "llvm/ADT/DenseSet.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/IR/Comdat.h"
#include "llvm/Object/Archive.h"
#include "llvm/Object/ELF.h"
#include "llvm/Object/IRObjectFile.h"
#include "llvm/Support/StringSaver.h"

#include <map>

namespace lld {
namespace elf {

using llvm::object::Archive;

class InputFile;
class Lazy;
class SymbolBody;

// The root class of input files.
class InputFile {
public:
  enum Kind {
    ObjectKind,
    SharedKind,
    LazyObjectKind,
    ArchiveKind,
    BitcodeKind,
  };

  Kind kind() const { return FileKind; }

  StringRef getName() const { return MB.getBufferIdentifier(); }
  MemoryBufferRef MB;

  // Filename of .a which contained this file. If this file was
  // not in an archive file, it is the empty string. We use this
  // string for creating error messages.
  StringRef ArchiveName;

  // If this is an architecture-specific file, the following members
  // have ELF type (i.e. ELF{32,64}{LE,BE}) and target machine type.
  ELFKind EKind = ELFNoneKind;
  uint16_t EMachine = llvm::ELF::EM_NONE;

protected:
  InputFile(Kind K, MemoryBufferRef M) : MB(M), FileKind(K) {}

private:
  const Kind FileKind;
};

// Returns "(internal)", "foo.a(bar.o)" or "baz.o".
std::string getFilename(const InputFile *F);

template <typename ELFT> class ELFFileBase : public InputFile {
public:
  typedef typename ELFT::Shdr Elf_Shdr;
  typedef typename ELFT::Sym Elf_Sym;
  typedef typename ELFT::Word Elf_Word;
  typedef typename ELFT::SymRange Elf_Sym_Range;

  ELFFileBase(Kind K, MemoryBufferRef M);
  static bool classof(const InputFile *F) {
    Kind K = F->kind();
    return K == ObjectKind || K == SharedKind;
  }

  const llvm::object::ELFFile<ELFT> &getObj() const { return ELFObj; }
  llvm::object::ELFFile<ELFT> &getObj() { return ELFObj; }

  uint8_t getOSABI() const {
    return getObj().getHeader()->e_ident[llvm::ELF::EI_OSABI];
  }

  StringRef getStringTable() const { return StringTable; }

  uint32_t getSectionIndex(const Elf_Sym &Sym) const;

  Elf_Sym_Range getElfSymbols(bool OnlyGlobals);

protected:
  llvm::object::ELFFile<ELFT> ELFObj;
  const Elf_Shdr *Symtab = nullptr;
  ArrayRef<Elf_Word> SymtabSHNDX;
  StringRef StringTable;
  void initStringTable();
};

// .o file.
template <class ELFT> class ObjectFile : public ELFFileBase<ELFT> {
  typedef ELFFileBase<ELFT> Base;
  typedef typename ELFT::Sym Elf_Sym;
  typedef typename ELFT::Shdr Elf_Shdr;
  typedef typename ELFT::SymRange Elf_Sym_Range;
  typedef typename ELFT::Word Elf_Word;
  typedef typename ELFT::uint uintX_t;

  StringRef getShtGroupSignature(const Elf_Shdr &Sec);
  ArrayRef<Elf_Word> getShtGroupEntries(const Elf_Shdr &Sec);

public:
  static bool classof(const InputFile *F) {
    return F->kind() == Base::ObjectKind;
  }

  ArrayRef<SymbolBody *> getSymbols();
  ArrayRef<SymbolBody *> getLocalSymbols();
  ArrayRef<SymbolBody *> getNonLocalSymbols();

  explicit ObjectFile(MemoryBufferRef M);
  void parse(llvm::DenseSet<StringRef> &ComdatGroups);

  ArrayRef<InputSectionBase<ELFT> *> getSections() const { return Sections; }
  InputSectionBase<ELFT> *getSection(const Elf_Sym &Sym) const;

  SymbolBody &getSymbolBody(uint32_t SymbolIndex) const {
    return *SymbolBodies[SymbolIndex];
  }

  template <typename RelT> SymbolBody &getRelocTargetSym(const RelT &Rel) const {
    uint32_t SymIndex = Rel.getSymbol(Config->Mips64EL);
    return getSymbolBody(SymIndex);
  }

  const Elf_Shdr *getSymbolTable() const { return this->Symtab; };

  // Get MIPS GP0 value defined by this file. This value represents the gp value
  // used to create the relocatable object and required to support
  // R_MIPS_GPREL16 / R_MIPS_GPREL32 relocations.
  uint32_t getMipsGp0() const;

  // The number is the offset in the string table. It will be used as the
  // st_name of the symbol.
  std::vector<std::pair<const DefinedRegular<ELFT> *, unsigned>> KeptLocalSyms;

  // SymbolBodies and Thunks for sections in this file are allocated
  // using this buffer.
  llvm::BumpPtrAllocator Alloc;

private:
  void initializeSections(llvm::DenseSet<StringRef> &ComdatGroups);
  void initializeSymbols();
  InputSectionBase<ELFT> *getRelocTarget(const Elf_Shdr &Sec);
  InputSectionBase<ELFT> *createInputSection(const Elf_Shdr &Sec);

  bool shouldMerge(const Elf_Shdr &Sec);
  SymbolBody *createSymbolBody(const Elf_Sym *Sym);

  // List of all sections defined by this file.
  std::vector<InputSectionBase<ELFT> *> Sections;

  // List of all symbols referenced or defined by this file.
  std::vector<SymbolBody *> SymbolBodies;

  // MIPS .reginfo section defined by this file.
  std::unique_ptr<MipsReginfoInputSection<ELFT>> MipsReginfo;
  // MIPS .MIPS.options section defined by this file.
  std::unique_ptr<MipsOptionsInputSection<ELFT>> MipsOptions;

  llvm::SpecificBumpPtrAllocator<InputSection<ELFT>> IAlloc;
  llvm::SpecificBumpPtrAllocator<MergeInputSection<ELFT>> MAlloc;
  llvm::SpecificBumpPtrAllocator<EhInputSection<ELFT>> EHAlloc;
};

// LazyObjectFile is analogous to ArchiveFile in the sense that
// the file contains lazy symbols. The difference is that
// LazyObjectFile wraps a single file instead of multiple files.
//
// This class is used for --start-lib and --end-lib options which
// instruct the linker to link object files between them with the
// archive file semantics.
class LazyObjectFile : public InputFile {
public:
  explicit LazyObjectFile(MemoryBufferRef M) : InputFile(LazyObjectKind, M) {}

  static bool classof(const InputFile *F) {
    return F->kind() == LazyObjectKind;
  }

  template <class ELFT> void parse();
  MemoryBufferRef getBuffer();

private:
  std::vector<StringRef> getSymbols();
  template <class ELFT> std::vector<StringRef> getElfSymbols();
  std::vector<StringRef> getBitcodeSymbols();

  llvm::BumpPtrAllocator Alloc;
  llvm::StringSaver Saver{Alloc};
  bool Seen = false;
};

// An ArchiveFile object represents a .a file.
class ArchiveFile : public InputFile {
public:
  explicit ArchiveFile(MemoryBufferRef M) : InputFile(ArchiveKind, M) {}
  static bool classof(const InputFile *F) { return F->kind() == ArchiveKind; }
  template <class ELFT> void parse();

  // Returns a memory buffer for a given symbol. An empty memory buffer
  // is returned if we have already returned the same memory buffer.
  // (So that we don't instantiate same members more than once.)
  MemoryBufferRef getMember(const Archive::Symbol *Sym);

private:
  std::unique_ptr<Archive> File;
  llvm::DenseSet<uint64_t> Seen;
};

class BitcodeFile : public InputFile {
public:
  explicit BitcodeFile(MemoryBufferRef M);
  static bool classof(const InputFile *F) { return F->kind() == BitcodeKind; }
  template <class ELFT>
  void parse(llvm::DenseSet<StringRef> &ComdatGroups);
  ArrayRef<Symbol *> getSymbols() { return Symbols; }
  static bool shouldSkip(uint32_t Flags);
  std::unique_ptr<llvm::object::IRObjectFile> Obj;

private:
  std::vector<Symbol *> Symbols;
  llvm::BumpPtrAllocator Alloc;
  llvm::StringSaver Saver{Alloc};
  template <class ELFT>
  Symbol *createSymbol(const llvm::DenseSet<const llvm::Comdat *> &KeptComdats,
                       const llvm::object::IRObjectFile &Obj,
                       const llvm::object::BasicSymbolRef &Sym);
};

// .so file.
template <class ELFT> class SharedFile : public ELFFileBase<ELFT> {
  typedef ELFFileBase<ELFT> Base;
  typedef typename ELFT::Shdr Elf_Shdr;
  typedef typename ELFT::Sym Elf_Sym;
  typedef typename ELFT::Word Elf_Word;
  typedef typename ELFT::SymRange Elf_Sym_Range;
  typedef typename ELFT::Versym Elf_Versym;
  typedef typename ELFT::Verdef Elf_Verdef;

  std::vector<StringRef> Undefs;
  StringRef SoName;
  const Elf_Shdr *VersymSec = nullptr;
  const Elf_Shdr *VerdefSec = nullptr;

public:
  StringRef getSoName() const { return SoName; }
  const Elf_Shdr *getSection(const Elf_Sym &Sym) const;
  llvm::ArrayRef<StringRef> getUndefinedSymbols() { return Undefs; }

  static bool classof(const InputFile *F) {
    return F->kind() == Base::SharedKind;
  }

  explicit SharedFile(MemoryBufferRef M);

  void parseSoName();
  void parseRest();
  std::vector<const Elf_Verdef *> parseVerdefs(const Elf_Versym *&Versym);

  struct NeededVer {
    // The string table offset of the version name in the output file.
    size_t StrTab;

    // The version identifier for this version name.
    uint16_t Index;
  };

  // Mapping from Elf_Verdef data structures to information about Elf_Vernaux
  // data structures in the output file.
  std::map<const Elf_Verdef *, NeededVer> VerdefMap;

  // Used for --as-needed
  bool AsNeeded = false;
  bool IsUsed = false;
  bool isNeeded() const { return !AsNeeded || IsUsed; }
};

std::unique_ptr<InputFile> createObjectFile(MemoryBufferRef MB,
                                            StringRef ArchiveName = "");
std::unique_ptr<InputFile> createSharedFile(MemoryBufferRef MB);

} // namespace elf
} // namespace lld

#endif
@


1.1.1.1
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a18 2
#include "lld/Core/Reproduce.h"
#include "llvm/ADT/CachedHashString.h"
d25 1
a28 8
namespace llvm {
class DWARFDebugLine;
class TarWriter;
namespace lto {
class InputFile;
}
}

a30 7
class InputFile;
}

// Returns "(internal)", "foo.a(bar.o)" or "baz.o".
std::string toString(const elf::InputFile *F);

namespace elf {
d34 1
a37 7
// If -reproduce option is given, all input files are written
// to this tar archive.
extern llvm::TarWriter *Tar;

// Opens a given file.
llvm::Optional<MemoryBufferRef> readFile(StringRef Path);

a46 1
    BinaryKind,
a58 6
  // If this file is in an archive, the member contains the offset of
  // the file in the archive. Otherwise, it's just zero. We store this
  // field so that we can pass it to lib/LTO in order to disambiguate
  // between objects.
  uint64_t OffsetInArchive;

a62 1
  uint8_t OSABI = 0;
d71 3
d87 5
a91 2
  llvm::object::ELFFile<ELFT> getObj() const {
    return llvm::object::ELFFile<ELFT>(MB.getBuffer());
d98 1
a98 1
  Elf_Sym_Range getGlobalSymbols();
d101 2
a102 2
  ArrayRef<Elf_Sym> Symbols;
  uint32_t FirstNonLocal = 0;
d105 1
a105 1
  void initSymtab(ArrayRef<Elf_Shdr> Sections, const Elf_Shdr *Symtab);
a110 2
  typedef typename ELFT::Rel Elf_Rel;
  typedef typename ELFT::Rela Elf_Rela;
d117 1
a117 2
  StringRef getShtGroupSignature(ArrayRef<Elf_Shdr> Sections,
                                 const Elf_Shdr &Sec);
d130 1
a130 1
  void parse(llvm::DenseSet<llvm::CachedHashStringRef> &ComdatGroups);
a135 2
    if (SymbolIndex >= SymbolBodies.size())
      fatal(toString(this) + ": invalid symbol index");
d139 1
a139 2
  template <typename RelT>
  SymbolBody &getRelocTargetSym(const RelT &Rel) const {
d144 1
a144 3
  // Returns source line information for a given offset.
  // If no information is available, returns "".
  std::string getLineInfo(InputSectionBase<ELFT> *S, uintX_t Offset);
d146 1
a146 1
  // MIPS GP0 value defined by this file. This value represents the gp value
d149 1
a149 1
  uint32_t MipsGp0 = 0;
d155 3
a157 4
  // Name of source file obtained from STT_FILE symbol value,
  // or empty string if there is no such symbol in object file
  // symbol table.
  StringRef SourceFile;
d160 1
a160 2
  void
  initializeSections(llvm::DenseSet<llvm::CachedHashStringRef> &ComdatGroups);
a161 1
  void initializeDwarfLine();
d163 1
a163 2
  InputSectionBase<ELFT> *createInputSection(const Elf_Shdr &Sec,
                                             StringRef SectionStringTable);
d174 8
a181 5
  // Debugging information to retrieve source file and line for error
  // reporting. Linker may find reasonable number of errors in a
  // single object file, so we cache debugging information in order to
  // parse it only once for each object file we link.
  std::unique_ptr<llvm::DWARFDebugLine> DwarfLine;
d207 2
d219 1
a219 2
  // Returns a memory buffer for a given symbol and the offset in the archive
  // for the member. An empty memory buffer and an offset of zero
d222 1
a222 1
  std::pair<MemoryBufferRef, uint64_t> getMember(const Archive::Symbol *Sym);
d234 1
a234 1
  void parse(llvm::DenseSet<llvm::CachedHashStringRef> &ComdatGroups);
d236 2
a237 1
  std::unique_ptr<llvm::lto::InputFile> Obj;
d241 6
a251 1
  typedef typename ELFT::Dyn Elf_Dyn;
d254 1
d256 1
a257 3
  typedef typename ELFT::Versym Elf_Versym;
  typedef typename ELFT::Word Elf_Word;
  typedef typename ELFT::uint uintX_t;
d297 3
a299 14
class BinaryFile : public InputFile {
public:
  explicit BinaryFile(MemoryBufferRef M) : InputFile(BinaryKind, M) {}
  static bool classof(const InputFile *F) { return F->kind() == BinaryKind; }
  template <class ELFT> void parse();
  ArrayRef<InputSectionData *> getSections() const { return Sections; }

private:
  std::vector<InputSectionData *> Sections;
};

InputFile *createObjectFile(MemoryBufferRef MB, StringRef ArchiveName = "",
                            uint64_t OffsetInArchive = 0);
InputFile *createSharedFile(MemoryBufferRef MB);
@


1.1.1.3
log
@Import LLVM 4.0.0 release including clang and lld.
@
text
@d183 4
@


