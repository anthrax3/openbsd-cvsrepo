head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.3
	OPENBSD_6_2:1.1.1.2.0.2
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.1
date	2017.01.14.19.55.45;	author patrick;	state Exp;
branches
	1.1.1.1;
next	;
commitid	qMUxATnKgqN83Oct;

1.1.1.1
date	2017.01.14.19.55.45;	author patrick;	state Exp;
branches;
next	1.1.1.2;
commitid	qMUxATnKgqN83Oct;

1.1.1.2
date	2017.01.24.08.33.12;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	so2WA7LCP6wbxtYl;

1.1.1.3
date	2017.10.04.20.27.35;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===- LinkerScript.h -------------------------------------------*- C++ -*-===//
//
//                             The LLVM Linker
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef LLD_ELF_LINKER_SCRIPT_H
#define LLD_ELF_LINKER_SCRIPT_H

#include "lld/Core/LLVM.h"
#include "llvm/ADT/DenseMap.h"
#include "llvm/ADT/MapVector.h"
#include "llvm/Support/Allocator.h"
#include "llvm/Support/MemoryBuffer.h"

namespace lld {
namespace elf {

// Parses a linker script. Calling this function updates
// Config and ScriptConfig.
void readLinkerScript(MemoryBufferRef MB);

class ScriptParser;
template <class ELFT> class InputSectionBase;
template <class ELFT> class OutputSectionBase;

// This class represents each rule in SECTIONS command.
struct SectionRule {
  SectionRule(StringRef D, StringRef S)
      : Dest(D), SectionPattern(S) {}

  StringRef Dest;

  StringRef SectionPattern;
};

// This enum represents what we can observe in SECTIONS tag of script:
// ExprKind is a location counter change, like ". = . + 0x1000"
// SectionKind is a description of output section, like ".data :..."
enum SectionsCommandKind { SectionKind, AssignmentKind };

struct SectionsCommand {
  SectionsCommandKind Kind;
  std::vector<StringRef> Expr;
  StringRef Name;
};

// ScriptConfiguration holds linker script parse results.
struct ScriptConfiguration {
  // SECTIONS commands.
  std::vector<SectionRule> Sections;

  // Section fill attribute for each section.
  llvm::StringMap<std::vector<uint8_t>> Filler;

  // Used to assign addresses to sections.
  std::vector<SectionsCommand> Commands;

  bool DoLayout = false;

  llvm::BumpPtrAllocator Alloc;

  // List of section patterns specified with KEEP commands. They will
  // be kept even if they are unused and --gc-sections is specified.
  std::vector<StringRef> KeptSections;
};

extern ScriptConfiguration *ScriptConfig;

// This is a runner of the linker script.
template <class ELFT> class LinkerScript {
  typedef typename ELFT::uint uintX_t;

public:
  StringRef getOutputSection(InputSectionBase<ELFT> *S);
  ArrayRef<uint8_t> getFiller(StringRef Name);
  bool isDiscarded(InputSectionBase<ELFT> *S);
  bool shouldKeep(InputSectionBase<ELFT> *S);
  void assignAddresses(ArrayRef<OutputSectionBase<ELFT> *> S);
  int compareSections(StringRef A, StringRef B);
  void addScriptedSymbols();

private:
  // "ScriptConfig" is a bit too long, so define a short name for it.
  ScriptConfiguration &Opt = *ScriptConfig;

  int getSectionIndex(StringRef Name);

  uintX_t Dot;
};

// Variable template is a C++14 feature, so we can't template
// a global variable. Use a struct to workaround.
template <class ELFT> struct Script { static LinkerScript<ELFT> *X; };
template <class ELFT> LinkerScript<ELFT> *Script<ELFT>::X;

} // namespace elf
} // namespace lld

#endif
@


1.1.1.1
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a12 3
#include "Config.h"
#include "Strings.h"
#include "Writer.h"
d14 3
a16 3
#include "llvm/ADT/ArrayRef.h"
#include "llvm/ADT/DenseSet.h"
#include "llvm/ADT/StringRef.h"
a17 5
#include <cstddef>
#include <cstdint>
#include <functional>
#include <memory>
#include <vector>
a21 32
class DefinedCommon;
class ScriptParser;
class SymbolBody;
template <class ELFT> class InputSectionBase;
template <class ELFT> class InputSection;
class OutputSectionBase;
template <class ELFT> class OutputSectionFactory;
class InputSectionData;

// This represents an expression in the linker script.
// ScriptParser::readExpr reads an expression and returns an Expr.
// Later, we evaluate the expression by calling the function
// with the value of special context variable ".".
struct Expr {
  std::function<uint64_t(uint64_t)> Val;
  std::function<bool()> IsAbsolute;

  // If expression is section-relative the function below is used
  // to get the output section pointer.
  std::function<const OutputSectionBase *()> Section;

  uint64_t operator()(uint64_t Dot) const { return Val(Dot); }
  operator bool() const { return (bool)Val; }

  Expr(std::function<uint64_t(uint64_t)> Val, std::function<bool()> IsAbsolute,
       std::function<const OutputSectionBase *()> Section)
      : Val(Val), IsAbsolute(IsAbsolute), Section(Section) {}
  template <typename T>
  Expr(T V) : Expr(V, [] { return true; }, [] { return nullptr; }) {}
  Expr() : Expr(nullptr) {}
};

d26 3
a28 2
// Parses a version script.
void readVersionScript(MemoryBufferRef MB);
d30 4
a33 1
void readDynamicList(MemoryBufferRef MB);
d35 1
a35 9
// This enum is used to implement linker script SECTIONS command.
// https://sourceware.org/binutils/docs/ld/SECTIONS.html#SECTIONS
enum SectionsCommandKind {
  AssignmentKind, // . = expr or <sym> = expr
  OutputSectionKind,
  InputSectionKind,
  AssertKind,   // ASSERT(expr)
  BytesDataKind // BYTE(expr), SHORT(expr), LONG(expr) or QUAD(expr)
};
d37 1
a37 6
struct BaseCommand {
  BaseCommand(int K) : Kind(K) {}

  virtual ~BaseCommand() = default;

  int Kind;
d40 4
a43 6
// This represents ". = <expr>" or "<symbol> = <expr>".
struct SymbolAssignment : BaseCommand {
  SymbolAssignment(StringRef Name, Expr E)
      : BaseCommand(AssignmentKind), Name(Name), Expression(E) {}

  static bool classof(const BaseCommand *C);
d45 3
a47 1
  // The LHS of an expression. Name is either a symbol name or ".".
a48 8
  SymbolBody *Sym = nullptr;

  // The RHS of an expression.
  Expr Expression;

  // Command attributes for PROVIDE, HIDDEN and PROVIDE_HIDDEN.
  bool Provide = false;
  bool Hidden = false;
d51 4
a54 42
// Linker scripts allow additional constraints to be put on ouput sections.
// If an output section is marked as ONLY_IF_RO, the section is created
// only if its input sections are read-only. Likewise, an output section
// with ONLY_IF_RW is created if all input sections are RW.
enum class ConstraintKind { NoConstraint, ReadOnly, ReadWrite };

struct OutputSectionCommand : BaseCommand {
  OutputSectionCommand(StringRef Name)
      : BaseCommand(OutputSectionKind), Name(Name) {}

  static bool classof(const BaseCommand *C);

  StringRef Name;
  Expr AddrExpr;
  Expr AlignExpr;
  Expr LMAExpr;
  Expr SubalignExpr;
  std::vector<std::unique_ptr<BaseCommand>> Commands;
  std::vector<StringRef> Phdrs;
  uint32_t Filler = 0;
  ConstraintKind Constraint = ConstraintKind::NoConstraint;
  std::string Location;
};

// This struct represents one section match pattern in SECTIONS() command.
// It can optionally have negative match pattern for EXCLUDED_FILE command.
// Also it may be surrounded with SORT() command, so contains sorting rules.
struct SectionPattern {
  SectionPattern(StringMatcher &&Pat1, StringMatcher &&Pat2)
      : ExcludedFilePat(Pat1), SectionPat(Pat2) {}

  StringMatcher ExcludedFilePat;
  StringMatcher SectionPat;
  SortSectionPolicy SortOuter;
  SortSectionPolicy SortInner;
};

struct InputSectionDescription : BaseCommand {
  InputSectionDescription(StringRef FilePattern)
      : BaseCommand(InputSectionKind), FilePat(FilePattern) {}

  static bool classof(const BaseCommand *C);
d56 2
a57 8
  StringMatcher FilePat;

  // Input sections that matches at least one of SectionPatterns
  // will be associated with this InputSectionDescription.
  std::vector<SectionPattern> SectionPatterns;

  std::vector<InputSectionData *> Sections;
};
a58 47
// Represents an ASSERT().
struct AssertCommand : BaseCommand {
  AssertCommand(Expr E) : BaseCommand(AssertKind), Expression(E) {}

  static bool classof(const BaseCommand *C);

  Expr Expression;
};

// Represents BYTE(), SHORT(), LONG(), or QUAD().
struct BytesDataCommand : BaseCommand {
  BytesDataCommand(Expr E, unsigned Size)
      : BaseCommand(BytesDataKind), Expression(E), Size(Size) {}

  static bool classof(const BaseCommand *C);

  Expr Expression;
  unsigned Offset;
  unsigned Size;
};

struct PhdrsCommand {
  StringRef Name;
  unsigned Type;
  bool HasFilehdr;
  bool HasPhdrs;
  unsigned Flags;
  Expr LMAExpr;
};

class LinkerScriptBase {
protected:
  ~LinkerScriptBase() = default;

public:
  virtual uint64_t getHeaderSize() = 0;
  virtual uint64_t getSymbolValue(const Twine &Loc, StringRef S) = 0;
  virtual bool isDefined(StringRef S) = 0;
  virtual bool isAbsolute(StringRef S) = 0;
  virtual const OutputSectionBase *getSymbolSection(StringRef S) = 0;
  virtual const OutputSectionBase *getOutputSection(const Twine &Loc,
                                                    StringRef S) = 0;
  virtual uint64_t getOutputSectionSize(StringRef S) = 0;
};

// ScriptConfiguration holds linker script parse results.
struct ScriptConfiguration {
d60 1
a60 1
  std::vector<std::unique_ptr<BaseCommand>> Commands;
d62 1
a62 2
  // Used to assign sections to headers.
  std::vector<PhdrsCommand> PhdrsCommands;
d64 1
a64 1
  bool HasSections = false;
d68 1
a68 1
  std::vector<InputSectionDescription *> KeptSections;
d74 1
a74 1
template <class ELFT> class LinkerScript final : public LinkerScriptBase {
d78 3
a80 15
  LinkerScript();
  ~LinkerScript();

  void processCommands(OutputSectionFactory<ELFT> &Factory);
  void addOrphanSections(OutputSectionFactory<ELFT> &Factory);
  void removeEmptyCommands();
  void adjustSectionsBeforeSorting();
  void adjustSectionsAfterSorting();

  std::vector<PhdrEntry> createPhdrs();
  bool ignoreInterpSection();

  uint32_t getFiller(StringRef Name);
  void writeDataBytes(StringRef Name, uint8_t *Buf);
  bool hasLMA(StringRef Name);
d82 3
a84 16
  void assignOffsets(OutputSectionCommand *Cmd);
  void placeOrphanSections();
  void assignAddresses(std::vector<PhdrEntry> &Phdrs);
  bool hasPhdrsCommands();
  uint64_t getHeaderSize() override;
  uint64_t getSymbolValue(const Twine &Loc, StringRef S) override;
  bool isDefined(StringRef S) override;
  bool isAbsolute(StringRef S) override;
  const OutputSectionBase *getSymbolSection(StringRef S) override;
  const OutputSectionBase *getOutputSection(const Twine &Loc,
                                            StringRef S) override;
  uint64_t getOutputSectionSize(StringRef S) override;

  std::vector<OutputSectionBase *> *OutputSections;

  int getSectionIndex(StringRef Name);
a86 9
  void computeInputSections(InputSectionDescription *);

  void addSection(OutputSectionFactory<ELFT> &Factory,
                  InputSectionBase<ELFT> *Sec, StringRef Name);
  void discard(ArrayRef<InputSectionBase<ELFT> *> V);

  std::vector<InputSectionBase<ELFT> *>
  createInputSectionList(OutputSectionCommand &Cmd);

d90 1
a90 2
  std::vector<size_t> getPhdrIndices(StringRef SectionName);
  size_t getPhdrIndex(const Twine &Loc, StringRef PhdrName);
a92 9
  uintX_t LMAOffset = 0;
  OutputSectionBase *CurOutSec = nullptr;
  uintX_t ThreadBssOffset = 0;
  void switchTo(OutputSectionBase *Sec);
  void flush();
  void output(InputSection<ELFT> *Sec);
  void process(BaseCommand &Base);
  llvm::DenseSet<OutputSectionBase *> AlreadyOutputOS;
  llvm::DenseSet<InputSectionData *> AlreadyOutputIS;
d100 2
a101 4
extern LinkerScriptBase *ScriptBase;

} // end namespace elf
} // end namespace lld
d103 1
a103 1
#endif // LLD_ELF_LINKER_SCRIPT_H
@


1.1.1.3
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@a17 1
#include "llvm/ADT/DenseMap.h"
d31 1
d33 5
a37 24
class InputSectionBase;
class InputSection;
class OutputSection;
class OutputSectionFactory;
class InputSectionBase;
class SectionBase;

struct ExprValue {
  SectionBase *Sec;
  uint64_t Val;
  bool ForceAbsolute;
  uint64_t Alignment = 1;
  std::string Loc;

  ExprValue(SectionBase *Sec, bool ForceAbsolute, uint64_t Val,
            const Twine &Loc)
      : Sec(Sec), Val(Val), ForceAbsolute(ForceAbsolute), Loc(Loc.str()) {}
  ExprValue(SectionBase *Sec, uint64_t Val, const Twine &Loc)
      : ExprValue(Sec, false, Val, Loc) {}
  ExprValue(uint64_t Val) : ExprValue(nullptr, Val, "") {}
  bool isAbsolute() const { return ForceAbsolute || Sec == nullptr; }
  uint64_t getValue() const;
  uint64_t getSecAddr() const;
};
d41 29
a69 2
// Later, we evaluate the expression by calling the function.
typedef std::function<ExprValue()> Expr;
d83 3
d91 2
a92 2
  SymbolAssignment(StringRef Name, Expr E, std::string Loc)
      : BaseCommand(AssignmentKind), Name(Name), Expression(E), Location(Loc) {}
a105 3

  // Holds file name and line number for error reporting.
  std::string Location;
a113 11
// This struct is used to represent the location and size of regions of
// target memory. Instances of the struct are created by parsing the
// MEMORY command.
struct MemoryRegion {
  std::string Name;
  uint64_t Origin;
  uint64_t Length;
  uint32_t Flags;
  uint32_t NegFlags;
};

a119 2
  OutputSection *Sec = nullptr;
  MemoryRegion *MemRegion = nullptr;
d125 1
a125 1
  std::vector<BaseCommand *> Commands;
d127 1
a127 1
  llvm::Optional<uint32_t> Filler;
a129 11
  std::string MemoryRegionName;
  bool Noload = false;

  template <class ELFT> void finalize();
  template <class ELFT> void writeTo(uint8_t *Buf);
  template <class ELFT> void maybeCompress();
  uint32_t getFiller();

  void sort(std::function<int(InputSectionBase *S)> Order);
  void sortInitFini();
  void sortCtorsDtors();
d157 1
a157 1
  std::vector<InputSection *> Sections;
d190 15
d208 1
a208 1
  std::vector<BaseCommand *> Commands;
a217 6

  // A map from memory region name to a memory region descriptor.
  llvm::DenseMap<llvm::StringRef, MemoryRegion> MemoryRegions;

  // A list of symbols referenced by the script.
  std::vector<llvm::StringRef> ReferencedSymbols;
d220 1
a220 17
class LinkerScript final {
  // Temporary state used in processCommands() and assignAddresses()
  // that must be reinitialized for each call to the above functions, and must
  // not be used outside of the scope of a call to the above functions.
  struct AddressState {
    uint64_t ThreadBssOffset = 0;
    OutputSection *OutSec = nullptr;
    MemoryRegion *MemRegion = nullptr;
    llvm::DenseMap<const MemoryRegion *, uint64_t> MemRegionOffset;
    std::function<uint64_t()> LMAOffset;
    AddressState(const ScriptConfiguration &Opt);
  };
  llvm::DenseMap<OutputSection *, OutputSectionCommand *> SecToCommand;
  llvm::DenseMap<StringRef, OutputSectionCommand *> NameToOutputSectionCommand;

  void assignSymbol(SymbolAssignment *Cmd, bool InSec);
  void setDot(Expr E, const Twine &Loc, bool InSec);
d222 3
a224 20
  std::vector<InputSection *>
  computeInputSections(const InputSectionDescription *);

  std::vector<InputSectionBase *>
  createInputSectionList(OutputSectionCommand &Cmd);

  std::vector<size_t> getPhdrIndices(OutputSectionCommand *Cmd);
  size_t getPhdrIndex(const Twine &Loc, StringRef PhdrName);

  MemoryRegion *findMemoryRegion(OutputSectionCommand *Cmd);

  void switchTo(OutputSection *Sec);
  uint64_t advance(uint64_t Size, unsigned Align);
  void output(InputSection *Sec);
  void process(BaseCommand &Base);

  AddressState *CurAddressState = nullptr;
  OutputSection *Aether;

  uint64_t Dot;
d227 2
a228 9
  bool ErrorOnMissingSection = false;
  OutputSectionCommand *createOutputSectionCommand(StringRef Name,
                                                   StringRef Location);
  OutputSectionCommand *getOrCreateOutputSectionCommand(StringRef Name);

  OutputSectionCommand *getCmd(OutputSection *Sec) const;
  bool hasPhdrsCommands() { return !Opt.PhdrsCommands.empty(); }
  uint64_t getDot() { return Dot; }
  void discard(ArrayRef<InputSectionBase *> V);
d230 2
a231 5
  ExprValue getSymbolValue(const Twine &Loc, StringRef S);
  bool isDefined(StringRef S);

  void fabricateDefaultCommands();
  void addOrphanSections(OutputSectionFactory &Factory);
d239 4
a242 1
  bool shouldKeep(InputSectionBase *S);
d244 28
a271 5
  void processNonSectionCommands();
  void assignAddresses();
  void allocateHeaders(std::vector<PhdrEntry> &Phdrs);
  void addSymbol(SymbolAssignment *Cmd);
  void processCommands(OutputSectionFactory &Factory);
d273 13
a285 2
  // Parsed linker script configurations are set to this struct.
  ScriptConfiguration Opt;
d288 6
a293 1
extern LinkerScript *Script;
@


