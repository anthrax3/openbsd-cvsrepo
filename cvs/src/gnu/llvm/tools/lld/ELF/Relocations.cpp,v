head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.3
	OPENBSD_6_2:1.1.1.2.0.2
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.1
date	2017.01.14.19.55.45;	author patrick;	state Exp;
branches
	1.1.1.1;
next	;
commitid	qMUxATnKgqN83Oct;

1.1.1.1
date	2017.01.14.19.55.45;	author patrick;	state Exp;
branches;
next	1.1.1.2;
commitid	qMUxATnKgqN83Oct;

1.1.1.2
date	2017.01.24.08.33.12;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	so2WA7LCP6wbxtYl;

1.1.1.3
date	2017.10.04.20.27.35;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===- Relocations.cpp ----------------------------------------------------===//
//
//                             The LLVM Linker
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file contains platform-independent functions to process relocations.
// I'll describe the overview of this file here.
//
// Simple relocations are easy to handle for the linker. For example,
// for R_X86_64_PC64 relocs, the linker just has to fix up locations
// with the relative offsets to the target symbols. It would just be
// reading records from relocation sections and applying them to output.
//
// But not all relocations are that easy to handle. For example, for
// R_386_GOTOFF relocs, the linker has to create new GOT entries for
// symbols if they don't exist, and fix up locations with GOT entry
// offsets from the beginning of GOT section. So there is more than
// fixing addresses in relocation processing.
//
// ELF defines a large number of complex relocations.
//
// The functions in this file analyze relocations and do whatever needs
// to be done. It includes, but not limited to, the following.
//
//  - create GOT/PLT entries
//  - create new relocations in .dynsym to let the dynamic linker resolve
//    them at runtime (since ELF supports dynamic linking, not all
//    relocations can be resolved at link-time)
//  - create COPY relocs and reserve space in .bss
//  - replace expensive relocs (in terms of runtime cost) with cheap ones
//  - error out infeasible combinations such as PIC and non-relative relocs
//
// Note that the functions in this file don't actually apply relocations
// because it doesn't know about the output file nor the output file buffer.
// It instead stores Relocation objects to InputSection's Relocations
// vector to let it apply later in InputSection::writeTo.
//
//===----------------------------------------------------------------------===//

#include "Relocations.h"
#include "Config.h"
#include "OutputSections.h"
#include "SymbolTable.h"
#include "Target.h"
#include "Thunks.h"

#include "llvm/Support/Endian.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;
using namespace llvm::ELF;
using namespace llvm::object;
using namespace llvm::support::endian;

namespace lld {
namespace elf {

static bool refersToGotEntry(RelExpr Expr) {
  return Expr == R_GOT || Expr == R_GOT_OFF || Expr == R_MIPS_GOT_LOCAL_PAGE ||
         Expr == R_MIPS_GOT_OFF || Expr == R_MIPS_TLSGD ||
         Expr == R_MIPS_TLSLD || Expr == R_GOT_PAGE_PC || Expr == R_GOT_PC ||
         Expr == R_GOT_FROM_END || Expr == R_TLSGD || Expr == R_TLSGD_PC ||
         Expr == R_TLSDESC || Expr == R_TLSDESC_PAGE;
}

static bool isPreemptible(const SymbolBody &Body, uint32_t Type) {
  // In case of MIPS GP-relative relocations always resolve to a definition
  // in a regular input file, ignoring the one-definition rule. So we,
  // for example, should not attempt to create a dynamic relocation even
  // if the target symbol is preemptible. There are two two MIPS GP-relative
  // relocations R_MIPS_GPREL16 and R_MIPS_GPREL32. But only R_MIPS_GPREL16
  // can be against a preemptible symbol.
  // To get MIPS relocation type we apply 0xff mask. In case of O32 ABI all
  // relocation types occupy eight bit. In case of N64 ABI we extract first
  // relocation from 3-in-1 packet because only the first relocation can
  // be against a real symbol.
  if (Config->EMachine == EM_MIPS && (Type & 0xff) == R_MIPS_GPREL16)
    return false;
  return Body.isPreemptible();
}

// This function is similar to the `handleTlsRelocation`. MIPS does not support
// any relaxations for TLS relocations so by factoring out MIPS handling into
// the separate function we can simplify the code and does not pollute
// `handleTlsRelocation` by MIPS `ifs` statements.
template <class ELFT>
static unsigned
handleMipsTlsRelocation(uint32_t Type, SymbolBody &Body,
                        InputSectionBase<ELFT> &C, typename ELFT::uint Offset,
                        typename ELFT::uint Addend, RelExpr Expr) {
  if (Expr == R_MIPS_TLSLD) {
    if (Out<ELFT>::Got->addTlsIndex())
      Out<ELFT>::RelaDyn->addReloc({Target->TlsModuleIndexRel, Out<ELFT>::Got,
                                    Out<ELFT>::Got->getTlsIndexOff(), false,
                                    nullptr, 0});
    C.Relocations.push_back({Expr, Type, &C, Offset, Addend, &Body});
    return 1;
  }
  if (Target->isTlsGlobalDynamicRel(Type)) {
    if (Out<ELFT>::Got->addDynTlsEntry(Body)) {
      typedef typename ELFT::uint uintX_t;
      uintX_t Off = Out<ELFT>::Got->getGlobalDynOffset(Body);
      Out<ELFT>::RelaDyn->addReloc(
          {Target->TlsModuleIndexRel, Out<ELFT>::Got, Off, false, &Body, 0});
      Out<ELFT>::RelaDyn->addReloc({Target->TlsOffsetRel, Out<ELFT>::Got,
                                    Off + (uintX_t)sizeof(uintX_t), false,
                                    &Body, 0});
    }
    C.Relocations.push_back({Expr, Type, &C, Offset, Addend, &Body});
    return 1;
  }
  return 0;
}

// Returns the number of relocations processed.
template <class ELFT>
static unsigned handleTlsRelocation(uint32_t Type, SymbolBody &Body,
                                    InputSectionBase<ELFT> &C,
                                    typename ELFT::uint Offset,
                                    typename ELFT::uint Addend, RelExpr Expr) {
  if (!(C.getSectionHdr()->sh_flags & SHF_ALLOC))
    return 0;

  if (!Body.isTls())
    return 0;

  typedef typename ELFT::uint uintX_t;

  if (Config->EMachine == EM_MIPS)
    return handleMipsTlsRelocation<ELFT>(Type, Body, C, Offset, Addend, Expr);

  if ((Expr == R_TLSDESC || Expr == R_TLSDESC_PAGE || Expr == R_HINT) &&
      Config->Shared) {
    if (Out<ELFT>::Got->addDynTlsEntry(Body)) {
      uintX_t Off = Out<ELFT>::Got->getGlobalDynOffset(Body);
      Out<ELFT>::RelaDyn->addReloc(
          {Target->TlsDescRel, Out<ELFT>::Got, Off, false, &Body, 0});
    }
    if (Expr != R_HINT)
      C.Relocations.push_back({Expr, Type, &C, Offset, Addend, &Body});
    return 1;
  }

  if (Expr == R_TLSLD_PC || Expr == R_TLSLD) {
    // Local-Dynamic relocs can be relaxed to Local-Exec.
    if (!Config->Shared) {
      C.Relocations.push_back(
          {R_RELAX_TLS_LD_TO_LE, Type, &C, Offset, Addend, &Body});
      return 2;
    }
    if (Out<ELFT>::Got->addTlsIndex())
      Out<ELFT>::RelaDyn->addReloc({Target->TlsModuleIndexRel, Out<ELFT>::Got,
                                    Out<ELFT>::Got->getTlsIndexOff(), false,
                                    nullptr, 0});
    C.Relocations.push_back({Expr, Type, &C, Offset, Addend, &Body});
    return 1;
  }

  // Local-Dynamic relocs can be relaxed to Local-Exec.
  if (Target->isTlsLocalDynamicRel(Type) && !Config->Shared) {
    C.Relocations.push_back(
        {R_RELAX_TLS_LD_TO_LE, Type, &C, Offset, Addend, &Body});
    return 1;
  }

  if (Expr == R_TLSDESC_PAGE || Expr == R_TLSDESC || Expr == R_HINT ||
      Target->isTlsGlobalDynamicRel(Type)) {
    if (Config->Shared) {
      if (Out<ELFT>::Got->addDynTlsEntry(Body)) {
        uintX_t Off = Out<ELFT>::Got->getGlobalDynOffset(Body);
        Out<ELFT>::RelaDyn->addReloc(
            {Target->TlsModuleIndexRel, Out<ELFT>::Got, Off, false, &Body, 0});

        // If the symbol is preemptible we need the dynamic linker to write
        // the offset too.
        if (isPreemptible(Body, Type))
          Out<ELFT>::RelaDyn->addReloc({Target->TlsOffsetRel, Out<ELFT>::Got,
                                        Off + (uintX_t)sizeof(uintX_t), false,
                                        &Body, 0});
      }
      C.Relocations.push_back({Expr, Type, &C, Offset, Addend, &Body});
      return 1;
    }

    // Global-Dynamic relocs can be relaxed to Initial-Exec or Local-Exec
    // depending on the symbol being locally defined or not.
    if (isPreemptible(Body, Type)) {
      C.Relocations.push_back(
          {Target->adjustRelaxExpr(Type, nullptr, R_RELAX_TLS_GD_TO_IE), Type,
           &C, Offset, Addend, &Body});
      if (!Body.isInGot()) {
        Out<ELFT>::Got->addEntry(Body);
        Out<ELFT>::RelaDyn->addReloc({Target->TlsGotRel, Out<ELFT>::Got,
                                      Body.getGotOffset<ELFT>(), false, &Body,
                                      0});
      }
      return Target->TlsGdRelaxSkip;
    }
    C.Relocations.push_back(
        {Target->adjustRelaxExpr(Type, nullptr, R_RELAX_TLS_GD_TO_LE), Type, &C,
         Offset, Addend, &Body});
    return Target->TlsGdRelaxSkip;
  }

  // Initial-Exec relocs can be relaxed to Local-Exec if the symbol is locally
  // defined.
  if (Target->isTlsInitialExecRel(Type) && !Config->Shared &&
      !isPreemptible(Body, Type)) {
    C.Relocations.push_back(
        {R_RELAX_TLS_IE_TO_LE, Type, &C, Offset, Addend, &Body});
    return 1;
  }
  return 0;
}

template <endianness E> static int16_t readSignedLo16(const uint8_t *Loc) {
  return read32<E>(Loc) & 0xffff;
}

template <class RelTy>
static uint32_t getMipsPairType(const RelTy *Rel, const SymbolBody &Sym) {
  switch (Rel->getType(Config->Mips64EL)) {
  case R_MIPS_HI16:
    return R_MIPS_LO16;
  case R_MIPS_GOT16:
    return Sym.isLocal() ? R_MIPS_LO16 : R_MIPS_NONE;
  case R_MIPS_PCHI16:
    return R_MIPS_PCLO16;
  case R_MICROMIPS_HI16:
    return R_MICROMIPS_LO16;
  default:
    return R_MIPS_NONE;
  }
}

template <class ELFT, class RelTy>
static int32_t findMipsPairedAddend(const uint8_t *Buf, const uint8_t *BufLoc,
                                    SymbolBody &Sym, const RelTy *Rel,
                                    const RelTy *End) {
  uint32_t SymIndex = Rel->getSymbol(Config->Mips64EL);
  uint32_t Type = getMipsPairType(Rel, Sym);

  // Some MIPS relocations use addend calculated from addend of the relocation
  // itself and addend of paired relocation. ABI requires to compute such
  // combined addend in case of REL relocation record format only.
  // See p. 4-17 at ftp://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf
  if (RelTy::IsRela || Type == R_MIPS_NONE)
    return 0;

  for (const RelTy *RI = Rel; RI != End; ++RI) {
    if (RI->getType(Config->Mips64EL) != Type)
      continue;
    if (RI->getSymbol(Config->Mips64EL) != SymIndex)
      continue;
    const endianness E = ELFT::TargetEndianness;
    return ((read32<E>(BufLoc) & 0xffff) << 16) +
           readSignedLo16<E>(Buf + RI->r_offset);
  }
  warning("can't find matching " + getRelName(Type) + " relocation for " +
          getRelName(Rel->getType(Config->Mips64EL)));
  return 0;
}

// True if non-preemptable symbol always has the same value regardless of where
// the DSO is loaded.
template <class ELFT> static bool isAbsolute(const SymbolBody &Body) {
  if (Body.isUndefined())
    return !Body.isLocal() && Body.symbol()->isWeak();
  if (const auto *DR = dyn_cast<DefinedRegular<ELFT>>(&Body))
    return DR->Section == nullptr; // Absolute symbol.
  return false;
}

static bool needsPlt(RelExpr Expr) {
  return Expr == R_PLT_PC || Expr == R_PPC_PLT_OPD || Expr == R_PLT ||
         Expr == R_PLT_PAGE_PC || Expr == R_THUNK_PLT_PC;
}

// True if this expression is of the form Sym - X, where X is a position in the
// file (PC, or GOT for example).
static bool isRelExpr(RelExpr Expr) {
  return Expr == R_PC || Expr == R_GOTREL || Expr == R_PAGE_PC ||
         Expr == R_RELAX_GOT_PC || Expr == R_THUNK_PC || Expr == R_THUNK_PLT_PC;
}

template <class ELFT>
static bool isStaticLinkTimeConstant(RelExpr E, uint32_t Type,
                                     const SymbolBody &Body) {
  // These expressions always compute a constant
  if (E == R_SIZE || E == R_GOT_FROM_END || E == R_GOT_OFF ||
      E == R_MIPS_GOT_LOCAL_PAGE || E == R_MIPS_GOT_OFF || E == R_MIPS_TLSGD ||
      E == R_GOT_PAGE_PC || E == R_GOT_PC || E == R_PLT_PC || E == R_TLSGD_PC ||
      E == R_TLSGD || E == R_PPC_PLT_OPD || E == R_TLSDESC_PAGE ||
      E == R_HINT || E == R_THUNK_PC || E == R_THUNK_PLT_PC)
    return true;

  // These never do, except if the entire file is position dependent or if
  // only the low bits are used.
  if (E == R_GOT || E == R_PLT || E == R_TLSDESC)
    return Target->usesOnlyLowPageBits(Type) || !Config->Pic;

  if (isPreemptible(Body, Type))
    return false;

  if (!Config->Pic)
    return true;

  bool AbsVal = isAbsolute<ELFT>(Body) || Body.isTls();
  bool RelE = isRelExpr(E);
  if (AbsVal && !RelE)
    return true;
  if (!AbsVal && RelE)
    return true;

  // Relative relocation to an absolute value. This is normally unrepresentable,
  // but if the relocation refers to a weak undefined symbol, we allow it to
  // resolve to the image base. This is a little strange, but it allows us to
  // link function calls to such symbols. Normally such a call will be guarded
  // with a comparison, which will load a zero from the GOT.
  if (AbsVal && RelE) {
    if (Body.isUndefined() && !Body.isLocal() && Body.symbol()->isWeak())
      return true;
    error("relocation " + getRelName(Type) +
          " cannot refer to absolute symbol " + Body.getName());
    return true;
  }

  return Target->usesOnlyLowPageBits(Type);
}

static RelExpr toPlt(RelExpr Expr) {
  if (Expr == R_PPC_OPD)
    return R_PPC_PLT_OPD;
  if (Expr == R_PC)
    return R_PLT_PC;
  if (Expr == R_PAGE_PC)
    return R_PLT_PAGE_PC;
  if (Expr == R_ABS)
    return R_PLT;
  return Expr;
}

static RelExpr fromPlt(RelExpr Expr) {
  // We decided not to use a plt. Optimize a reference to the plt to a
  // reference to the symbol itself.
  if (Expr == R_PLT_PC)
    return R_PC;
  if (Expr == R_PPC_PLT_OPD)
    return R_PPC_OPD;
  if (Expr == R_PLT)
    return R_ABS;
  return Expr;
}

template <class ELFT> static uint32_t getAlignment(SharedSymbol<ELFT> *SS) {
  typedef typename ELFT::uint uintX_t;

  uintX_t SecAlign = SS->file()->getSection(SS->Sym)->sh_addralign;
  uintX_t SymValue = SS->Sym.st_value;
  int TrailingZeros =
      std::min(countTrailingZeros(SecAlign), countTrailingZeros(SymValue));
  return 1 << TrailingZeros;
}

// Reserve space in .bss for copy relocation.
template <class ELFT> static void addCopyRelSymbol(SharedSymbol<ELFT> *SS) {
  typedef typename ELFT::uint uintX_t;
  typedef typename ELFT::Sym Elf_Sym;

  // Copy relocation against zero-sized symbol doesn't make sense.
  uintX_t SymSize = SS->template getSize<ELFT>();
  if (SymSize == 0)
    fatal("cannot create a copy relocation for " + SS->getName());

  uintX_t Alignment = getAlignment(SS);
  uintX_t Off = alignTo(Out<ELFT>::Bss->getSize(), Alignment);
  Out<ELFT>::Bss->setSize(Off + SymSize);
  Out<ELFT>::Bss->updateAlignment(Alignment);
  uintX_t Shndx = SS->Sym.st_shndx;
  uintX_t Value = SS->Sym.st_value;
  // Look through the DSO's dynamic symbol table for aliases and create a
  // dynamic symbol for each one. This causes the copy relocation to correctly
  // interpose any aliases.
  for (const Elf_Sym &S : SS->file()->getElfSymbols(true)) {
    if (S.st_shndx != Shndx || S.st_value != Value)
      continue;
    auto *Alias = dyn_cast_or_null<SharedSymbol<ELFT>>(
        Symtab<ELFT>::X->find(check(S.getName(SS->file()->getStringTable()))));
    if (!Alias)
      continue;
    Alias->OffsetInBss = Off;
    Alias->NeedsCopyOrPltAddr = true;
    Alias->symbol()->IsUsedInRegularObj = true;
  }
  Out<ELFT>::RelaDyn->addReloc(
      {Target->CopyRel, Out<ELFT>::Bss, SS->OffsetInBss, false, SS, 0});
}

template <class ELFT>
static RelExpr adjustExpr(const elf::ObjectFile<ELFT> &File, SymbolBody &Body,
                          bool IsWrite, RelExpr Expr, uint32_t Type,
                          const uint8_t *Data) {
  bool Preemptible = isPreemptible(Body, Type);
  if (Body.isGnuIFunc()) {
    Expr = toPlt(Expr);
  } else if (!Preemptible) {
    if (needsPlt(Expr))
      Expr = fromPlt(Expr);
    if (Expr == R_GOT_PC)
      Expr = Target->adjustRelaxExpr(Type, Data, Expr);
  }
  Expr = Target->getThunkExpr(Expr, Type, File, Body);

  if (IsWrite || isStaticLinkTimeConstant<ELFT>(Expr, Type, Body))
    return Expr;

  // This relocation would require the dynamic linker to write a value to read
  // only memory. We can hack around it if we are producing an executable and
  // the refered symbol can be preemepted to refer to the executable.
  if (Config->Shared || (Config->Pic && !isRelExpr(Expr))) {
    error("can't create dynamic relocation " + getRelName(Type) +
          " against readonly segment");
    return Expr;
  }
  if (Body.getVisibility() != STV_DEFAULT) {
    error("cannot preempt symbol");
    return Expr;
  }
  if (Body.isObject()) {
    // Produce a copy relocation.
    auto *B = cast<SharedSymbol<ELFT>>(&Body);
    if (!B->needsCopy())
      addCopyRelSymbol(B);
    return Expr;
  }
  if (Body.isFunc()) {
    // This handles a non PIC program call to function in a shared library. In
    // an ideal world, we could just report an error saying the relocation can
    // overflow at runtime. In the real world with glibc, crt1.o has a
    // R_X86_64_PC32 pointing to libc.so.
    //
    // The general idea on how to handle such cases is to create a PLT entry and
    // use that as the function value.
    //
    // For the static linking part, we just return a plt expr and everything
    // else will use the the PLT entry as the address.
    //
    // The remaining problem is making sure pointer equality still works. We
    // need the help of the dynamic linker for that. We let it know that we have
    // a direct reference to a so symbol by creating an undefined symbol with a
    // non zero st_value. Seeing that, the dynamic linker resolves the symbol to
    // the value of the symbol we created. This is true even for got entries, so
    // pointer equality is maintained. To avoid an infinite loop, the only entry
    // that points to the real function is a dedicated got entry used by the
    // plt. That is identified by special relocation types (R_X86_64_JUMP_SLOT,
    // R_386_JMP_SLOT, etc).
    Body.NeedsCopyOrPltAddr = true;
    return toPlt(Expr);
  }
  error("symbol is missing type");

  return Expr;
}

template <class ELFT, class RelTy>
static typename ELFT::uint computeAddend(const elf::ObjectFile<ELFT> &File,
                                         const uint8_t *SectionData,
                                         const RelTy *End, const RelTy &RI,
                                         RelExpr Expr, SymbolBody &Body) {
  typedef typename ELFT::uint uintX_t;

  uint32_t Type = RI.getType(Config->Mips64EL);
  uintX_t Addend = getAddend<ELFT>(RI);
  const uint8_t *BufLoc = SectionData + RI.r_offset;
  if (!RelTy::IsRela)
    Addend += Target->getImplicitAddend(BufLoc, Type);
  if (Config->EMachine == EM_MIPS) {
    Addend += findMipsPairedAddend<ELFT>(SectionData, BufLoc, Body, &RI, End);
    if (Type == R_MIPS_LO16 && Expr == R_PC)
      // R_MIPS_LO16 expression has R_PC type iif the target is _gp_disp
      // symbol. In that case we should use the following formula for
      // calculation "AHL + GP - P + 4". Let's add 4 right here.
      // For details see p. 4-19 at
      // ftp://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf
      Addend += 4;
    if (Expr == R_GOTREL) {
      Addend -= MipsGPOffset;
      if (Body.isLocal())
        Addend += File.getMipsGp0();
    }
  }
  if (Config->Pic && Config->EMachine == EM_PPC64 && Type == R_PPC64_TOC)
    Addend += getPPC64TocBase();
  return Addend;
}

// The reason we have to do this early scan is as follows
// * To mmap the output file, we need to know the size
// * For that, we need to know how many dynamic relocs we will have.
// It might be possible to avoid this by outputting the file with write:
// * Write the allocated output sections, computing addresses.
// * Apply relocations, recording which ones require a dynamic reloc.
// * Write the dynamic relocations.
// * Write the rest of the file.
// This would have some drawbacks. For example, we would only know if .rela.dyn
// is needed after applying relocations. If it is, it will go after rw and rx
// sections. Given that it is ro, we will need an extra PT_LOAD. This
// complicates things for the dynamic linker and means we would have to reserve
// space for the extra PT_LOAD even if we end up not using it.
template <class ELFT, class RelTy>
static void scanRelocs(InputSectionBase<ELFT> &C, ArrayRef<RelTy> Rels) {
  typedef typename ELFT::uint uintX_t;

  bool IsWrite = C.getSectionHdr()->sh_flags & SHF_WRITE;

  auto AddDyn = [=](const DynamicReloc<ELFT> &Reloc) {
    Out<ELFT>::RelaDyn->addReloc(Reloc);
  };

  const elf::ObjectFile<ELFT> &File = *C.getFile();
  ArrayRef<uint8_t> SectionData = C.getSectionData();
  const uint8_t *Buf = SectionData.begin();
  for (auto I = Rels.begin(), E = Rels.end(); I != E; ++I) {
    const RelTy &RI = *I;
    SymbolBody &Body = File.getRelocTargetSym(RI);
    uint32_t Type = RI.getType(Config->Mips64EL);

    RelExpr Expr = Target->getRelExpr(Type, Body);
    bool Preemptible = isPreemptible(Body, Type);
    Expr = adjustExpr(File, Body, IsWrite, Expr, Type, Buf + RI.r_offset);
    if (HasError)
      continue;

    // Skip a relocation that points to a dead piece
    // in a mergeable section.
    if (C.getOffset(RI.r_offset) == (uintX_t)-1)
      continue;

    // This relocation does not require got entry, but it is relative to got and
    // needs it to be created. Here we request for that.
    if (Expr == R_GOTONLY_PC || Expr == R_GOTREL || Expr == R_PPC_TOC)
      Out<ELFT>::Got->HasGotOffRel = true;

    uintX_t Addend = computeAddend(File, Buf, E, RI, Expr, Body);

    if (unsigned Processed = handleTlsRelocation<ELFT>(
            Type, Body, C, RI.r_offset, Addend, Expr)) {
      I += (Processed - 1);
      continue;
    }

    // Ignore "hint" relocation because it is for optional code optimization.
    if (Expr == R_HINT)
      continue;

    if (needsPlt(Expr) || Expr == R_THUNK_ABS || Expr == R_THUNK_PC ||
        Expr == R_THUNK_PLT_PC || refersToGotEntry(Expr) ||
        !isPreemptible(Body, Type)) {
      // If the relocation points to something in the file, we can process it.
      bool Constant = isStaticLinkTimeConstant<ELFT>(Expr, Type, Body);

      // If the output being produced is position independent, the final value
      // is still not known. In that case we still need some help from the
      // dynamic linker. We can however do better than just copying the incoming
      // relocation. We can process some of it and and just ask the dynamic
      // linker to add the load address.
      if (!Constant)
        AddDyn({Target->RelativeRel, &C, RI.r_offset, true, &Body, Addend});

      // If the produced value is a constant, we just remember to write it
      // when outputting this section. We also have to do it if the format
      // uses Elf_Rel, since in that case the written value is the addend.
      if (Constant || !RelTy::IsRela)
        C.Relocations.push_back({Expr, Type, &C, RI.r_offset, Addend, &Body});
    } else {
      // We don't know anything about the finaly symbol. Just ask the dynamic
      // linker to handle the relocation for us.
      AddDyn({Target->getDynRel(Type), &C, RI.r_offset, false, &Body, Addend});
      // MIPS ABI turns using of GOT and dynamic relocations inside out.
      // While regular ABI uses dynamic relocations to fill up GOT entries
      // MIPS ABI requires dynamic linker to fills up GOT entries using
      // specially sorted dynamic symbol table. This affects even dynamic
      // relocations against symbols which do not require GOT entries
      // creation explicitly, i.e. do not have any GOT-relocations. So if
      // a preemptible symbol has a dynamic relocation we anyway have
      // to create a GOT entry for it.
      // If a non-preemptible symbol has a dynamic relocation against it,
      // dynamic linker takes it st_value, adds offset and writes down
      // result of the dynamic relocation. In case of preemptible symbol
      // dynamic linker performs symbol resolution, writes the symbol value
      // to the GOT entry and reads the GOT entry when it needs to perform
      // a dynamic relocation.
      // ftp://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf p.4-19
      if (Config->EMachine == EM_MIPS)
        Out<ELFT>::Got->addMipsEntry(Body, Addend, Expr);
      continue;
    }

    // Some targets might require creation of thunks for relocations.
    // Now we support only MIPS which requires LA25 thunk to call PIC
    // code from non-PIC one, and ARM which requires interworking.
    if (Expr == R_THUNK_ABS || Expr == R_THUNK_PC || Expr == R_THUNK_PLT_PC) {
      auto *Sec = cast<InputSection<ELFT>>(&C);
      addThunk<ELFT>(Type, Body, *Sec);
    }

    // At this point we are done with the relocated position. Some relocations
    // also require us to create a got or plt entry.

    // If a relocation needs PLT, we create a PLT and a GOT slot for the symbol.
    if (needsPlt(Expr)) {
      if (Body.isInPlt())
        continue;
      Out<ELFT>::Plt->addEntry(Body);

      uint32_t Rel;
      if (Body.isGnuIFunc() && !Preemptible)
        Rel = Target->IRelativeRel;
      else
        Rel = Target->PltRel;

      Out<ELFT>::GotPlt->addEntry(Body);
      Out<ELFT>::RelaPlt->addReloc({Rel, Out<ELFT>::GotPlt,
                                    Body.getGotPltOffset<ELFT>(), !Preemptible,
                                    &Body, 0});
      continue;
    }

    if (refersToGotEntry(Expr)) {
      if (Config->EMachine == EM_MIPS) {
        // MIPS ABI has special rules to process GOT entries
        // and doesn't require relocation entries for them.
        // See "Global Offset Table" in Chapter 5 in the following document
        // for detailed description:
        // ftp://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf
        Out<ELFT>::Got->addMipsEntry(Body, Addend, Expr);
        if (Body.isTls())
          AddDyn({Target->TlsGotRel, Out<ELFT>::Got, Body.getGotOffset<ELFT>(),
                  !Preemptible, &Body, 0});
        continue;
      }

      if (Body.isInGot())
        continue;

      Out<ELFT>::Got->addEntry(Body);
      if (Preemptible || (Config->Pic && !isAbsolute<ELFT>(Body))) {
        uint32_t DynType;
        if (Body.isTls())
          DynType = Target->TlsGotRel;
        else if (Preemptible)
          DynType = Target->GotRel;
        else
          DynType = Target->RelativeRel;
        AddDyn({DynType, Out<ELFT>::Got, Body.getGotOffset<ELFT>(),
                !Preemptible, &Body, 0});
      }
      continue;
    }
  }
}

template <class ELFT> void scanRelocations(InputSection<ELFT> &C) {
  typedef typename ELFT::Shdr Elf_Shdr;

  // Scan all relocations. Each relocation goes through a series
  // of tests to determine if it needs special treatment, such as
  // creating GOT, PLT, copy relocations, etc.
  // Note that relocations for non-alloc sections are directly
  // processed by InputSection::relocateNonAlloc.
  if (C.getSectionHdr()->sh_flags & SHF_ALLOC)
    for (const Elf_Shdr *RelSec : C.RelocSections)
      scanRelocations(C, *RelSec);
}

template <class ELFT>
void scanRelocations(InputSectionBase<ELFT> &S,
                     const typename ELFT::Shdr &RelSec) {
  ELFFile<ELFT> &EObj = S.getFile()->getObj();
  if (RelSec.sh_type == SHT_RELA)
    scanRelocs(S, EObj.relas(&RelSec));
  else
    scanRelocs(S, EObj.rels(&RelSec));
}

template void scanRelocations<ELF32LE>(InputSection<ELF32LE> &);
template void scanRelocations<ELF32BE>(InputSection<ELF32BE> &);
template void scanRelocations<ELF64LE>(InputSection<ELF64LE> &);
template void scanRelocations<ELF64BE>(InputSection<ELF64BE> &);

template void scanRelocations<ELF32LE>(InputSectionBase<ELF32LE> &,
                                       const ELF32LE::Shdr &);
template void scanRelocations<ELF32BE>(InputSectionBase<ELF32BE> &,
                                       const ELF32BE::Shdr &);
template void scanRelocations<ELF64LE>(InputSectionBase<ELF64LE> &,
                                       const ELF64LE::Shdr &);
template void scanRelocations<ELF64BE>(InputSectionBase<ELF64BE> &,
                                       const ELF64BE::Shdr &);
}
}
@


1.1.1.1
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a46 1
#include "Strings.h"
a47 1
#include "SyntheticSections.h"
d63 5
a67 4
  return isRelExprOneOf<R_GOT, R_GOT_OFF, R_MIPS_GOT_LOCAL_PAGE, R_MIPS_GOT_OFF,
                        R_MIPS_GOT_OFF32, R_MIPS_TLSGD, R_MIPS_TLSLD,
                        R_GOT_PAGE_PC, R_GOT_PC, R_GOT_FROM_END, R_TLSGD,
                        R_TLSGD_PC, R_TLSDESC, R_TLSDESC_PAGE>(Expr);
d86 15
a100 27
// This function is similar to the `handleTlsRelocation`. ARM and MIPS do not
// support any relaxations for TLS relocations so by factoring out ARM and MIPS
// handling in to the separate function we can simplify the code and do not
// pollute `handleTlsRelocation` by ARM and MIPS `ifs` statements.
template <class ELFT, class GOT>
static unsigned handleNoRelaxTlsRelocation(
    GOT *Got, uint32_t Type, SymbolBody &Body, InputSectionBase<ELFT> &C,
    typename ELFT::uint Offset, typename ELFT::uint Addend, RelExpr Expr) {
  typedef typename ELFT::uint uintX_t;
  auto addModuleReloc = [](SymbolBody &Body, GOT *Got, uintX_t Off, bool LD) {
    // The Dynamic TLS Module Index Relocation can be statically resolved to 1
    // if we know that we are linking an executable. For ARM we resolve the
    // relocation when writing the Got. MIPS has a custom Got implementation
    // that writes the Module index in directly.
    if (!Body.isPreemptible() && !Config->Pic && Config->EMachine == EM_ARM)
      Got->Relocations.push_back(
          {R_ABS, Target->TlsModuleIndexRel, Off, 0, &Body});
    else {
      SymbolBody *Dest = LD ? nullptr : &Body;
      In<ELFT>::RelaDyn->addReloc(
          {Target->TlsModuleIndexRel, Got, Off, false, Dest, 0});
    }
  };
  if (Expr == R_MIPS_TLSLD || Expr == R_TLSLD_PC) {
    if (Got->addTlsIndex() && (Config->Pic || Config->EMachine == EM_ARM))
      addModuleReloc(Body, Got, Got->getTlsIndexOff(), true);
    C.Relocations.push_back({Expr, Type, Offset, Addend, &Body});
d104 8
a111 8
    if (Got->addDynTlsEntry(Body) &&
        (Body.isPreemptible() || Config->EMachine == EM_ARM)) {
      uintX_t Off = Got->getGlobalDynOffset(Body);
      addModuleReloc(Body, Got, Off, false);
      if (Body.isPreemptible())
        In<ELFT>::RelaDyn->addReloc({Target->TlsOffsetRel, Got,
                                     Off + (uintX_t)sizeof(uintX_t), false,
                                     &Body, 0});
d113 1
a113 1
    C.Relocations.push_back({Expr, Type, Offset, Addend, &Body});
d125 1
a125 1
  if (!(C.Flags & SHF_ALLOC))
a132 3
  if (Config->EMachine == EM_ARM)
    return handleNoRelaxTlsRelocation<ELFT>(In<ELFT>::Got, Type, Body, C,
                                            Offset, Addend, Expr);
d134 1
a134 2
    return handleNoRelaxTlsRelocation<ELFT>(In<ELFT>::MipsGot, Type, Body, C,
                                            Offset, Addend, Expr);
d136 1
a136 2
  bool IsPreemptible = isPreemptible(Body, Type);
  if ((Expr == R_TLSDESC || Expr == R_TLSDESC_PAGE || Expr == R_TLSDESC_CALL) &&
d138 4
a141 4
    if (In<ELFT>::Got->addDynTlsEntry(Body)) {
      uintX_t Off = In<ELFT>::Got->getGlobalDynOffset(Body);
      In<ELFT>::RelaDyn->addReloc({Target->TlsDescRel, In<ELFT>::Got, Off,
                                   !IsPreemptible, &Body, 0});
d143 2
a144 2
    if (Expr != R_TLSDESC_CALL)
      C.Relocations.push_back({Expr, Type, Offset, Addend, &Body});
d152 1
a152 1
          {R_RELAX_TLS_LD_TO_LE, Type, Offset, Addend, &Body});
d155 5
a159 5
    if (In<ELFT>::Got->addTlsIndex())
      In<ELFT>::RelaDyn->addReloc({Target->TlsModuleIndexRel, In<ELFT>::Got,
                                   In<ELFT>::Got->getTlsIndexOff(), false,
                                   nullptr, 0});
    C.Relocations.push_back({Expr, Type, Offset, Addend, &Body});
d166 1
a166 1
        {R_RELAX_TLS_LD_TO_LE, Type, Offset, Addend, &Body});
d170 1
a170 1
  if (Expr == R_TLSDESC_PAGE || Expr == R_TLSDESC || Expr == R_TLSDESC_CALL ||
d173 4
a176 4
      if (In<ELFT>::Got->addDynTlsEntry(Body)) {
        uintX_t Off = In<ELFT>::Got->getGlobalDynOffset(Body);
        In<ELFT>::RelaDyn->addReloc(
            {Target->TlsModuleIndexRel, In<ELFT>::Got, Off, false, &Body, 0});
d180 4
a183 7
        uintX_t OffsetOff = Off + (uintX_t)sizeof(uintX_t);
        if (IsPreemptible)
          In<ELFT>::RelaDyn->addReloc({Target->TlsOffsetRel, In<ELFT>::Got,
                                       OffsetOff, false, &Body, 0});
        else
          In<ELFT>::Got->Relocations.push_back(
              {R_ABS, Target->TlsOffsetRel, OffsetOff, 0, &Body});
d185 1
a185 1
      C.Relocations.push_back({Expr, Type, Offset, Addend, &Body});
d191 1
a191 1
    if (IsPreemptible) {
d194 1
a194 1
           Offset, Addend, &Body});
d196 4
a199 4
        In<ELFT>::Got->addEntry(Body);
        In<ELFT>::RelaDyn->addReloc({Target->TlsGotRel, In<ELFT>::Got,
                                     Body.getGotOffset<ELFT>(), false, &Body,
                                     0});
d204 1
a204 1
        {Target->adjustRelaxExpr(Type, nullptr, R_RELAX_TLS_GD_TO_LE), Type,
d211 2
a212 1
  if (Target->isTlsInitialExecRel(Type) && !Config->Shared && !IsPreemptible) {
d214 1
a214 1
        {R_RELAX_TLS_IE_TO_LE, Type, Offset, Addend, &Body});
d263 2
a264 2
  warn("can't find matching " + toString(Type) + " relocation for " +
       toString(Rel->getType(Config->Mips64EL)));
a277 4
template <class ELFT> static bool isAbsoluteValue(const SymbolBody &Body) {
  return isAbsolute<ELFT>(Body) || Body.isTls();
}

d279 2
a280 2
  return isRelExprOneOf<R_PLT_PC, R_PPC_PLT_OPD, R_PLT, R_PLT_PAGE_PC,
                        R_THUNK_PLT_PC>(Expr);
d286 2
a287 3
  return isRelExprOneOf<R_PC, R_GOTREL, R_GOTREL_FROM_END, R_MIPS_GOTREL,
                        R_PAGE_PC, R_RELAX_GOT_PC, R_THUNK_PC, R_THUNK_PLT_PC>(
      Expr);
d292 1
a292 3
                                     const SymbolBody &Body,
                                     InputSectionBase<ELFT> &S,
                                     typename ELFT::uint RelOff) {
d294 5
a298 5
  if (isRelExprOneOf<R_SIZE, R_GOT_FROM_END, R_GOT_OFF, R_MIPS_GOT_LOCAL_PAGE,
                     R_MIPS_GOT_OFF, R_MIPS_GOT_OFF32, R_MIPS_TLSGD,
                     R_GOT_PAGE_PC, R_GOT_PC, R_PLT_PC, R_TLSGD_PC, R_TLSGD,
                     R_PPC_PLT_OPD, R_TLSDESC_CALL, R_TLSDESC_PAGE, R_HINT,
                     R_THUNK_PC, R_THUNK_PLT_PC>(E))
d312 1
a312 1
  bool AbsVal = isAbsoluteValue<ELFT>(Body);
a323 3
  // Another special case is MIPS _gp_disp symbol which represents offset
  // between start of a function and '_gp' value and defined as absolute just
  // to simplify the code.
d327 2
a328 5
    if (&Body == ElfSym<ELFT>::MipsGpDisp)
      return true;
    error(S.getLocation(RelOff) + ": relocation " + toString(Type) +
          " cannot refer to absolute symbol '" + toString(Body) +
          "' defined in " + toString(Body.File));
d369 1
a369 15
template <class ELFT> static bool isReadOnly(SharedSymbol<ELFT> *SS) {
  typedef typename ELFT::uint uintX_t;
  typedef typename ELFT::Phdr Elf_Phdr;

  // Determine if the symbol is read-only by scanning the DSO's program headers.
  uintX_t Value = SS->Sym.st_value;
  for (const Elf_Phdr &Phdr : check(SS->file()->getObj().program_headers()))
    if ((Phdr.p_type == ELF::PT_LOAD || Phdr.p_type == ELF::PT_GNU_RELRO) &&
        !(Phdr.p_flags & ELF::PF_W) && Value >= Phdr.p_vaddr &&
        Value < Phdr.p_vaddr + Phdr.p_memsz)
      return true;
  return false;
}

// Reserve space in .bss or .bss.rel.ro for copy relocation.
d377 1
a377 7
    fatal("cannot create a copy relocation for symbol " + toString(*SS));

  // See if this symbol is in a read-only segment. If so, preserve the symbol's
  // memory protection by reserving space in the .bss.rel.ro section.
  bool IsReadOnly = isReadOnly(SS);
  OutputSection<ELFT> *CopySec =
      IsReadOnly ? Out<ELFT>::BssRelRo : Out<ELFT>::Bss;
d380 3
a382 3
  uintX_t Off = alignTo(CopySec->Size, Alignment);
  CopySec->Size = Off + SymSize;
  CopySec->updateAlignment(Alignment);
d388 1
a388 1
  for (const Elf_Sym &S : SS->file()->getGlobalSymbols()) {
d395 1
a395 2
    Alias->CopyIsInBssRelRo = IsReadOnly;
    Alias->CopyOffset = Off;
d399 2
a400 1
  In<ELFT>::RelaDyn->addReloc({Target->CopyRel, CopySec, Off, false, SS, 0});
d406 1
a406 2
                          const uint8_t *Data, InputSectionBase<ELFT> &S,
                          typename ELFT::uint RelOff) {
d413 1
a413 1
    if (Expr == R_GOT_PC && !isAbsoluteValue<ELFT>(Body))
d418 1
a418 1
  if (IsWrite || isStaticLinkTimeConstant<ELFT>(Expr, Type, Body, S, RelOff))
d425 2
a426 5
    error(S.getLocation(RelOff) + ": can't create dynamic relocation " +
          toString(Type) + " against " +
          (Body.getName().empty() ? "local symbol in readonly segment"
                                  : "symbol '" + toString(Body) + "'") +
          " defined in " + toString(Body.File));
d430 1
a430 2
    error(S.getLocation(RelOff) + ": cannot preempt symbol '" + toString(Body) +
          "' defined in " + toString(Body.File));
d464 1
a464 2
  error("symbol '" + toString(Body) + "' defined in " + toString(Body.File) +
        " is missing type");
d490 5
a494 2
    if (Expr == R_MIPS_GOTREL && Body.isLocal())
      Addend += File.MipsGp0;
a500 35
template <class ELFT>
static void reportUndefined(SymbolBody &Sym, InputSectionBase<ELFT> &S,
                            typename ELFT::uint Offset) {
  if (Config->UnresolvedSymbols == UnresolvedPolicy::Ignore)
    return;

  if (Config->Shared && Sym.symbol()->Visibility == STV_DEFAULT &&
      Config->UnresolvedSymbols != UnresolvedPolicy::NoUndef)
    return;

  std::string Msg =
      S.getLocation(Offset) + ": undefined symbol '" + toString(Sym) + "'";

  if (Config->UnresolvedSymbols == UnresolvedPolicy::Warn)
    warn(Msg);
  else
    error(Msg);
}

template <class RelTy>
static std::pair<uint32_t, uint32_t>
mergeMipsN32RelTypes(uint32_t Type, uint32_t Offset, RelTy *I, RelTy *E) {
  // MIPS N32 ABI treats series of successive relocations with the same offset
  // as a single relocation. The similar approach used by N64 ABI, but this ABI
  // packs all relocations into the single relocation record. Here we emulate
  // this for the N32 ABI. Iterate over relocation with the same offset and put
  // theirs types into the single bit-set.
  uint32_t Processed = 0;
  for (; I != E && Offset == I->r_offset; ++I) {
    ++Processed;
    Type |= I->getType(Config->Mips64EL) << (8 * Processed);
  }
  return std::make_pair(Type, Processed);
}

d518 1
a518 1
  bool IsWrite = C.Flags & SHF_WRITE;
d521 1
a521 1
    In<ELFT>::RelaDyn->addReloc(Reloc);
d524 2
a525 2
  const elf::ObjectFile<ELFT> *File = C.getFile();
  ArrayRef<uint8_t> SectionData = C.Data;
a526 8

  ArrayRef<EhSectionPiece> Pieces;
  if (auto *Eh = dyn_cast<EhInputSection<ELFT>>(&C))
    Pieces = Eh->Pieces;

  ArrayRef<EhSectionPiece>::iterator PieceI = Pieces.begin();
  ArrayRef<EhSectionPiece>::iterator PieceE = Pieces.end();

d529 1
a529 1
    SymbolBody &Body = File->getRelocTargetSym(RI);
a531 12
    if (Config->MipsN32Abi) {
      uint32_t Processed;
      std::tie(Type, Processed) =
          mergeMipsN32RelTypes(Type, RI.r_offset, I + 1, E);
      I += Processed;
    }

    // We only report undefined symbols if they are referenced somewhere in the
    // code.
    if (!Body.isLocal() && Body.isUndefined() && !Body.symbol()->isWeak())
      reportUndefined(Body, C, RI.r_offset);

d534 2
a535 3
    Expr = adjustExpr(*File, Body, IsWrite, Expr, Type, Buf + RI.r_offset, C,
                      RI.r_offset);
    if (ErrorCount)
d539 3
a541 16
    // in a eh_frame section.
    while (PieceI != PieceE &&
           (PieceI->InputOff + PieceI->size() <= RI.r_offset))
      ++PieceI;

    // Compute the offset of this section in the output section. We do it here
    // to try to compute it only once.
    uintX_t Offset;
    if (PieceI != PieceE) {
      assert(PieceI->InputOff <= RI.r_offset && "Relocation not in any piece");
      if (PieceI->OutputOff == -1)
        continue;
      Offset = PieceI->OutputOff + RI.r_offset - PieceI->InputOff;
    } else {
      Offset = RI.r_offset;
    }
d545 2
a546 3
    if (Expr == R_GOTONLY_PC || Expr == R_GOTONLY_PC_FROM_END ||
        Expr == R_GOTREL || Expr == R_GOTREL_FROM_END || Expr == R_PPC_TOC)
      In<ELFT>::Got->HasGotOffRel = true;
d548 1
a548 1
    uintX_t Addend = computeAddend(*File, Buf, E, RI, Expr, Body);
d550 2
a551 2
    if (unsigned Processed =
            handleTlsRelocation<ELFT>(Type, Body, C, Offset, Addend, Expr)) {
d556 2
a557 3
    // Ignore "hint" and TLS Descriptor call relocation because they are
    // only markers for relaxation.
    if (isRelExprOneOf<R_HINT, R_TLSDESC_CALL>(Expr))
d560 3
a562 3
    if (needsPlt(Expr) ||
        isRelExprOneOf<R_THUNK_ABS, R_THUNK_PC, R_THUNK_PLT_PC>(Expr) ||
        refersToGotEntry(Expr) || !isPreemptible(Body, Type)) {
d564 1
a564 2
      bool Constant =
          isStaticLinkTimeConstant<ELFT>(Expr, Type, Body, C, RI.r_offset);
d572 1
a572 1
        AddDyn({Target->RelativeRel, &C, Offset, true, &Body, Addend});
d578 1
a578 1
        C.Relocations.push_back({Expr, Type, Offset, Addend, &Body});
d582 1
a582 5
      if (!Target->isPicRel(Type))
        error(C.getLocation(Offset) + ": relocation " + toString(Type) +
              " cannot be used against shared object; recompile with -fPIC.");
      AddDyn({Target->getDynRel(Type), &C, Offset, false, &Body, Addend});

d599 1
a599 1
        In<ELFT>::MipsGot->addEntry(Body, Addend, Expr);
d603 8
d618 7
d626 4
a629 13
      if (Body.isGnuIFunc() && !Preemptible) {
        In<ELFT>::Iplt->addEntry(Body);
        In<ELFT>::IgotPlt->addEntry(Body);
        In<ELFT>::RelaIplt->addReloc({Target->IRelativeRel, In<ELFT>::IgotPlt,
                                      Body.getGotPltOffset<ELFT>(),
                                      !Preemptible, &Body, 0});
      } else {
        In<ELFT>::Plt->addEntry(Body);
        In<ELFT>::GotPlt->addEntry(Body);
        In<ELFT>::RelaPlt->addReloc({Target->PltRel, In<ELFT>::GotPlt,
                                     Body.getGotPltOffset<ELFT>(), !Preemptible,
                                     &Body, 0});
      }
d635 2
a636 4
        // MIPS ABI has special rules to process GOT entries and doesn't
        // require relocation entries for them. A special case is TLS
        // relocations. In that case dynamic loader applies dynamic
        // relocations to initialize TLS GOT entries.
d640 4
a643 4
        In<ELFT>::MipsGot->addEntry(Body, Addend, Expr);
        if (Body.isTls() && Body.isPreemptible())
          AddDyn({Target->TlsGotRel, In<ELFT>::MipsGot,
                  Body.getGotOffset<ELFT>(), false, &Body, 0});
d650 12
a661 18
      In<ELFT>::Got->addEntry(Body);
      uintX_t Off = Body.getGotOffset<ELFT>();
      uint32_t DynType;
      RelExpr GotRE = R_ABS;
      if (Body.isTls()) {
        DynType = Target->TlsGotRel;
        GotRE = R_TLS;
      } else if (!Preemptible && Config->Pic && !isAbsolute<ELFT>(Body))
        DynType = Target->RelativeRel;
      else
        DynType = Target->GotRel;

      // FIXME: this logic is almost duplicated above.
      bool Constant = !Preemptible && !(Config->Pic && !isAbsolute<ELFT>(Body));
      if (!Constant)
        AddDyn({DynType, In<ELFT>::Got, Off, !Preemptible, &Body, 0});
      if (Constant || (!RelTy::IsRela && !Preemptible))
        In<ELFT>::Got->Relocations.push_back({GotRE, DynType, Off, 0, &Body});
d667 2
a668 6
template <class ELFT> void scanRelocations(InputSectionBase<ELFT> &S) {
  if (S.AreRelocsRela)
    scanRelocs(S, S.relas());
  else
    scanRelocs(S, S.rels());
}
d670 8
a677 18
template <class ELFT, class RelTy>
static void createThunks(InputSectionBase<ELFT> &C, ArrayRef<RelTy> Rels) {
  const elf::ObjectFile<ELFT> *File = C.getFile();
  for (const RelTy &Rel : Rels) {
    SymbolBody &Body = File->getRelocTargetSym(Rel);
    uint32_t Type = Rel.getType(Config->Mips64EL);
    RelExpr Expr = Target->getRelExpr(Type, Body);
    if (!isPreemptible(Body, Type) && needsPlt(Expr))
      Expr = fromPlt(Expr);
    Expr = Target->getThunkExpr(Expr, Type, *File, Body);
    // Some targets might require creation of thunks for relocations.
    // Now we support only MIPS which requires LA25 thunk to call PIC
    // code from non-PIC one, and ARM which requires interworking.
    if (Expr == R_THUNK_ABS || Expr == R_THUNK_PC || Expr == R_THUNK_PLT_PC) {
      auto *Sec = cast<InputSection<ELFT>>(&C);
      addThunk<ELFT>(Type, Body, *Sec);
    }
  }
d680 6
a685 3
template <class ELFT> void createThunks(InputSectionBase<ELFT> &S) {
  if (S.AreRelocsRela)
    createThunks(S, S.relas());
d687 1
a687 1
    createThunks(S, S.rels());
d690 13
a702 9
template void scanRelocations<ELF32LE>(InputSectionBase<ELF32LE> &);
template void scanRelocations<ELF32BE>(InputSectionBase<ELF32BE> &);
template void scanRelocations<ELF64LE>(InputSectionBase<ELF64LE> &);
template void scanRelocations<ELF64BE>(InputSectionBase<ELF64BE> &);

template void createThunks<ELF32LE>(InputSectionBase<ELF32LE> &);
template void createThunks<ELF32BE>(InputSectionBase<ELF32BE> &);
template void createThunks<ELF64LE>(InputSectionBase<ELF64LE> &);
template void createThunks<ELF64BE>(InputSectionBase<ELF64BE> &);
@


1.1.1.3
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@a45 2
#include "LinkerScript.h"
#include "Memory.h"
a54 1
#include <algorithm>
d61 2
a62 2
using namespace lld;
using namespace lld::elf;
d64 5
a68 14
// Construct a message in the following format.
//
// >>> defined in /home/alice/src/foo.o
// >>> referenced by bar.c:12 (/home/alice/src/bar.c:12)
// >>>               /home/alice/src/bar.o:(.text+0x1)
template <class ELFT>
static std::string getLocation(InputSectionBase &S, const SymbolBody &Sym,
                               uint64_t Off) {
  std::string Msg =
      "\n>>> defined in " + toString(Sym.File) + "\n>>> referenced by ";
  std::string Src = S.getSrcMsg<ELFT>(Off);
  if (!Src.empty())
    Msg += Src + "\n>>>               ";
  return Msg + S.getObjMsg<ELFT>(Off);
d87 2
a88 2
// This function is similar to the `handleTlsRelocation`. MIPS does not
// support any relaxations for TLS relocations so by factoring out MIPS
d90 16
a105 19
// pollute other `handleTlsRelocation` by MIPS `ifs` statements.
// Mips has a custom MipsGotSection that handles the writing of GOT entries
// without dynamic relocations.
template <class ELFT>
static unsigned handleMipsTlsRelocation(uint32_t Type, SymbolBody &Body,
                                        InputSectionBase &C, uint64_t Offset,
                                        int64_t Addend, RelExpr Expr) {
  if (Expr == R_MIPS_TLSLD) {
    if (InX::MipsGot->addTlsIndex() && Config->Pic)
      In<ELFT>::RelaDyn->addReloc({Target->TlsModuleIndexRel, InX::MipsGot,
                                   InX::MipsGot->getTlsIndexOff(), false,
                                   nullptr, 0});
    C.Relocations.push_back({Expr, Type, Offset, Addend, &Body});
    return 1;
  }

  if (Expr == R_MIPS_TLSGD) {
    if (InX::MipsGot->addDynTlsEntry(Body) && Body.isPreemptible()) {
      uint64_t Off = InX::MipsGot->getGlobalDynOffset(Body);
d107 1
a107 4
          {Target->TlsModuleIndexRel, InX::MipsGot, Off, false, &Body, 0});
      if (Body.isPreemptible())
        In<ELFT>::RelaDyn->addReloc({Target->TlsOffsetRel, InX::MipsGot,
                                     Off + Config->Wordsize, false, &Body, 0});
a108 36
    C.Relocations.push_back({Expr, Type, Offset, Addend, &Body});
    return 1;
  }
  return 0;
}

// This function is similar to the `handleMipsTlsRelocation`. ARM also does not
// support any relaxations for TLS relocations. ARM is logically similar to Mips
// in how it handles TLS, but Mips uses its own custom GOT which handles some
// of the cases that ARM uses GOT relocations for.
//
// We look for TLS global dynamic and local dynamic relocations, these may
// require the generation of a pair of GOT entries that have associated
// dynamic relocations. When the results of the dynamic relocations can be
// resolved at static link time we do so. This is necessary for static linking
// as there will be no dynamic loader to resolve them at load-time.
//
// The pair of GOT entries created are of the form
// GOT[e0] Module Index (Used to find pointer to TLS block at run-time)
// GOT[e1] Offset of symbol in TLS block
template <class ELFT>
static unsigned handleARMTlsRelocation(uint32_t Type, SymbolBody &Body,
                                       InputSectionBase &C, uint64_t Offset,
                                       int64_t Addend, RelExpr Expr) {
  // The Dynamic TLS Module Index Relocation for a symbol defined in an
  // executable is always 1. If the target Symbol is not preemtible then
  // we know the offset into the TLS block at static link time.
  bool NeedDynId = Body.isPreemptible() || Config->Shared;
  bool NeedDynOff = Body.isPreemptible();

  auto AddTlsReloc = [&](uint64_t Off, uint32_t Type, SymbolBody *Dest,
                         bool Dyn) {
    if (Dyn)
      In<ELFT>::RelaDyn->addReloc({Type, InX::Got, Off, false, Dest, 0});
    else
      InX::Got->Relocations.push_back({R_ABS, Type, Off, 0, Dest});
d110 3
a112 8

  // Local Dynamic is for access to module local TLS variables, while still
  // being suitable for being dynamically loaded via dlopen.
  // GOT[e0] is the module index, with a special value of 0 for the current
  // module. GOT[e1] is unused. There only needs to be one module index entry.
  if (Expr == R_TLSLD_PC && InX::Got->addTlsIndex()) {
    AddTlsReloc(InX::Got->getTlsIndexOff(), Target->TlsModuleIndexRel,
                NeedDynId ? nullptr : &Body, NeedDynId);
d116 9
a124 10

  // Global Dynamic is the most general purpose access model. When we know
  // the module index and offset of symbol in TLS block we can fill these in
  // using static GOT relocations.
  if (Expr == R_TLSGD_PC) {
    if (InX::Got->addDynTlsEntry(Body)) {
      uint64_t Off = InX::Got->getGlobalDynOffset(Body);
      AddTlsReloc(Off, Target->TlsModuleIndexRel, &Body, NeedDynId);
      AddTlsReloc(Off + Config->Wordsize, Target->TlsOffsetRel, &Body,
                  NeedDynOff);
d134 4
a137 3
static unsigned
handleTlsRelocation(uint32_t Type, SymbolBody &Body, InputSectionBase &C,
                    typename ELFT::uint Offset, int64_t Addend, RelExpr Expr) {
d144 2
d147 2
a148 1
    return handleARMTlsRelocation<ELFT>(Type, Body, C, Offset, Addend, Expr);
d150 2
a151 1
    return handleMipsTlsRelocation<ELFT>(Type, Body, C, Offset, Addend, Expr);
d154 1
a154 1
  if (isRelExprOneOf<R_TLSDESC, R_TLSDESC_PAGE, R_TLSDESC_CALL>(Expr) &&
d156 4
a159 4
    if (InX::Got->addDynTlsEntry(Body)) {
      uint64_t Off = InX::Got->getGlobalDynOffset(Body);
      In<ELFT>::RelaDyn->addReloc(
          {Target->TlsDescRel, InX::Got, Off, !IsPreemptible, &Body, 0});
d166 1
a166 1
  if (isRelExprOneOf<R_TLSLD_PC, R_TLSLD>(Expr)) {
d173 4
a176 4
    if (InX::Got->addTlsIndex())
      In<ELFT>::RelaDyn->addReloc({Target->TlsModuleIndexRel, InX::Got,
                                   InX::Got->getTlsIndexOff(), false, nullptr,
                                   0});
d182 1
a182 1
  if (isRelExprOneOf<R_ABS, R_TLSLD, R_TLSLD_PC>(Expr) && !Config->Shared) {
d188 2
a189 2
  if (isRelExprOneOf<R_TLSDESC, R_TLSDESC_PAGE, R_TLSDESC_CALL, R_TLSGD,
                     R_TLSGD_PC>(Expr)) {
d191 2
a192 2
      if (InX::Got->addDynTlsEntry(Body)) {
        uint64_t Off = InX::Got->getGlobalDynOffset(Body);
d194 1
a194 1
            {Target->TlsModuleIndexRel, InX::Got, Off, false, &Body, 0});
d198 1
a198 1
        uint64_t OffsetOff = Off + Config->Wordsize;
d200 2
a201 2
          In<ELFT>::RelaDyn->addReloc(
              {Target->TlsOffsetRel, InX::Got, OffsetOff, false, &Body, 0});
d203 1
a203 1
          InX::Got->Relocations.push_back(
d217 4
a220 3
        InX::Got->addEntry(Body);
        In<ELFT>::RelaDyn->addReloc({Target->TlsGotRel, InX::Got,
                                     Body.getGotOffset(), false, &Body, 0});
d222 1
a222 4
    } else {
      C.Relocations.push_back(
          {Target->adjustRelaxExpr(Type, nullptr, R_RELAX_TLS_GD_TO_LE), Type,
           Offset, Addend, &Body});
d224 3
d232 1
a232 2
  if (isRelExprOneOf<R_GOT, R_GOT_FROM_END, R_GOT_PC, R_GOT_PAGE_PC>(Expr) &&
      !Config->Shared && !IsPreemptible) {
d237 2
d240 2
a241 3
  if (Expr == R_TLSDESC_CALL)
    return 1;
  return 0;
d244 3
a246 2
static uint32_t getMipsPairType(uint32_t Type, const SymbolBody &Sym) {
  switch (Type) {
d260 28
d290 1
a290 1
static bool isAbsolute(const SymbolBody &Body) {
d293 1
a293 1
  if (const auto *DR = dyn_cast<DefinedRegular>(&Body))
d298 2
a299 2
static bool isAbsoluteValue(const SymbolBody &Body) {
  return isAbsolute(Body) || Body.isTls();
a301 1
// Returns true if Expr refers a PLT entry.
d303 2
a304 10
  return isRelExprOneOf<R_PLT_PC, R_PPC_PLT_OPD, R_PLT, R_PLT_PAGE_PC>(Expr);
}

// Returns true if Expr refers a GOT entry. Note that this function
// returns false for TLS variables even though they need GOT, because
// TLS variables uses GOT differently than the regular variables.
static bool needsGot(RelExpr Expr) {
  return isRelExprOneOf<R_GOT, R_GOT_OFF, R_MIPS_GOT_LOCAL_PAGE, R_MIPS_GOT_OFF,
                        R_MIPS_GOT_OFF32, R_GOT_PAGE_PC, R_GOT_PC,
                        R_GOT_FROM_END>(Expr);
d311 2
a312 1
                        R_PAGE_PC, R_RELAX_GOT_PC>(Expr);
a314 9
// Returns true if a given relocation can be computed at link-time.
//
// For instance, we know the offset from a relocation to its target at
// link-time if the relocation is PC-relative and refers a
// non-interposable function in the same executable. This function
// will return true for such relocation.
//
// If this function returns false, that means we need to emit a
// dynamic relocation so that the relocation will be fixed at load-time.
d318 2
a319 1
                                     InputSectionBase &S, uint64_t RelOff) {
d322 4
a325 4
                     R_MIPS_GOT_OFF, R_MIPS_GOT_OFF32, R_MIPS_GOT_GP_PC,
                     R_MIPS_TLSGD, R_GOT_PAGE_PC, R_GOT_PC, R_GOTONLY_PC,
                     R_GOTONLY_PC_FROM_END, R_PLT_PC, R_TLSGD_PC, R_TLSGD,
                     R_PPC_PLT_OPD, R_TLSDESC_CALL, R_TLSDESC_PAGE, R_HINT>(E))
d335 1
d339 1
a339 3
  // For the target and the relocation, we want to know if they are
  // absolute or relative.
  bool AbsVal = isAbsoluteValue(Body);
a344 2
  if (!AbsVal && !RelE)
    return Target->usesOnlyLowPageBits(Type);
d354 8
a361 2
  assert(AbsVal && RelE);
  if (Body.isUndefined() && !Body.isLocal() && Body.symbol()->isWeak())
d363 1
d365 1
a365 3
  error("relocation " + toString(Type) + " cannot refer to absolute symbol: " +
        toString(Body) + getLocation<ELFT>(S, Body, RelOff));
  return true;
d392 12
a403 2
// Returns true if a given shared symbol is in a read-only segment in a DSO.
template <class ELFT> static bool isReadOnly(SharedSymbol *SS) {
a404 1
  uint64_t Value = SS->getValue<ELFT>();
d407 2
a408 2
  auto *File = cast<SharedFile<ELFT>>(SS->File);
  for (const Elf_Phdr &Phdr : check(File->getObj().program_headers()))
d416 3
a418 7
// Returns symbols at the same offset as a given symbol, including SS itself.
//
// If two or more symbols are at the same offset, and at least one of
// them are copied by a copy relocation, all of them need to be copied.
// Otherwise, they would refer different places at runtime.
template <class ELFT>
static std::vector<SharedSymbol *> getSymbolsAt(SharedSymbol *SS) {
a420 59
  auto *File = cast<SharedFile<ELFT>>(SS->File);
  uint64_t Shndx = SS->getShndx<ELFT>();
  uint64_t Value = SS->getValue<ELFT>();

  std::vector<SharedSymbol *> Ret;
  for (const Elf_Sym &S : File->getGlobalSymbols()) {
    if (S.st_shndx != Shndx || S.st_value != Value)
      continue;
    StringRef Name = check(S.getName(File->getStringTable()));
    SymbolBody *Sym = Symtab<ELFT>::X->find(Name);
    if (auto *Alias = dyn_cast_or_null<SharedSymbol>(Sym))
      Ret.push_back(Alias);
  }
  return Ret;
}

// Reserve space in .bss or .bss.rel.ro for copy relocation.
//
// The copy relocation is pretty much a hack. If you use a copy relocation
// in your program, not only the symbol name but the symbol's size, RW/RO
// bit and alignment become part of the ABI. In addition to that, if the
// symbol has aliases, the aliases become part of the ABI. That's subtle,
// but if you violate that implicit ABI, that can cause very counter-
// intuitive consequences.
//
// So, what is the copy relocation? It's for linking non-position
// independent code to DSOs. In an ideal world, all references to data
// exported by DSOs should go indirectly through GOT. But if object files
// are compiled as non-PIC, all data references are direct. There is no
// way for the linker to transform the code to use GOT, as machine
// instructions are already set in stone in object files. This is where
// the copy relocation takes a role.
//
// A copy relocation instructs the dynamic linker to copy data from a DSO
// to a specified address (which is usually in .bss) at load-time. If the
// static linker (that's us) finds a direct data reference to a DSO
// symbol, it creates a copy relocation, so that the symbol can be
// resolved as if it were in .bss rather than in a DSO.
//
// As you can see in this function, we create a copy relocation for the
// dynamic linker, and the relocation contains not only symbol name but
// various other informtion about the symbol. So, such attributes become a
// part of the ABI.
//
// Note for application developers: I can give you a piece of advice if
// you are writing a shared library. You probably should export only
// functions from your library. You shouldn't export variables.
//
// As an example what can happen when you export variables without knowing
// the semantics of copy relocations, assume that you have an exported
// variable of type T. It is an ABI-breaking change to add new members at
// end of T even though doing that doesn't change the layout of the
// existing members. That's because the space for the new members are not
// reserved in .bss unless you recompile the main program. That means they
// are likely to overlap with other data that happens to be laid out next
// to the variable in .bss. This kind of issue is sometimes very hard to
// debug. What's a solution? Instead of exporting a varaible V from a DSO,
// define an accessor getV().
template <class ELFT> static void addCopyRelSymbol(SharedSymbol *SS) {
d422 1
a422 1
  uint64_t SymSize = SS->template getSize<ELFT>();
d428 10
a437 4
  bool IsReadOnly = isReadOnly<ELFT>(SS);
  BssSection *Sec = IsReadOnly ? InX::BssRelRo : InX::Bss;
  uint64_t Off = Sec->reserveSpace(SymSize, SS->getAlignment<ELFT>());

d441 11
a451 5
  for (SharedSymbol *Sym : getSymbolsAt<ELFT>(SS)) {
    Sym->NeedsCopy = true;
    Sym->CopyRelSec = Sec;
    Sym->CopyRelSecOff = Off;
    Sym->symbol()->IsUsedInRegularObj = true;
d453 1
a453 2

  In<ELFT>::RelaDyn->addReloc({Target->CopyRel, Sec, Off, false, SS, 0});
d457 3
a459 2
static RelExpr adjustExpr(SymbolBody &Body, RelExpr Expr, uint32_t Type,
                          const uint8_t *Data, InputSectionBase &S,
d461 1
d464 1
a464 1
  } else if (!isPreemptible(Body, Type)) {
d467 1
a467 1
    if (Expr == R_GOT_PC && !isAbsoluteValue(Body))
d470 1
a471 1
  bool IsWrite = !Config->ZText || (S.Flags & SHF_WRITE);
d479 5
a483 4
    error("can't create dynamic relocation " + toString(Type) + " against " +
          (Body.getName().empty() ? "local symbol"
                                  : "symbol: " + toString(Body)) +
          " in readonly segment" + getLocation<ELFT>(S, Body, RelOff));
a485 1

d487 2
a488 2
    error("cannot preempt symbol: " + toString(Body) +
          getLocation<ELFT>(S, Body, RelOff));
a490 1

d493 3
a495 10
    auto *B = cast<SharedSymbol>(&Body);
    if (!B->NeedsCopy) {
      if (Config->ZNocopyreloc)
        error("unresolvable relocation " + toString(Type) +
              " against symbol '" + toString(*B) +
              "'; recompile with -fPIC or remove '-z nocopyreloc'" +
              getLocation<ELFT>(S, Body, RelOff));

      addCopyRelSymbol<ELFT>(B);
    }
a497 1

d519 1
a519 1
    Body.NeedsPltAddr = true;
d522 2
a524 2
  error("symbol '" + toString(Body) + "' defined in " + toString(Body.File) +
        " has no type");
a527 3
// Returns an addend of a given relocation. If it is RELA, an addend
// is in a relocation itself. If it is REL, we need to read it from an
// input section.
d529 26
a554 52
static int64_t computeAddend(const RelTy &Rel, const uint8_t *Buf) {
  uint32_t Type = Rel.getType(Config->IsMips64EL);
  int64_t A = RelTy::IsRela
                  ? getAddend<ELFT>(Rel)
                  : Target->getImplicitAddend(Buf + Rel.r_offset, Type);

  if (Config->EMachine == EM_PPC64 && Config->Pic && Type == R_PPC64_TOC)
    A += getPPC64TocBase();
  return A;
}

// MIPS has an odd notion of "paired" relocations to calculate addends.
// For example, if a relocation is of R_MIPS_HI16, there must be a
// R_MIPS_LO16 relocation after that, and an addend is calculated using
// the two relocations.
template <class ELFT, class RelTy>
static int64_t computeMipsAddend(const RelTy &Rel, InputSectionBase &Sec,
                                 RelExpr Expr, SymbolBody &Body,
                                 const RelTy *End) {
  if (Expr == R_MIPS_GOTREL && Body.isLocal())
    return Sec.getFile<ELFT>()->MipsGp0;

  // The ABI says that the paired relocation is used only for REL.
  // See p. 4-17 at ftp://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf
  if (RelTy::IsRela)
    return 0;

  uint32_t Type = Rel.getType(Config->IsMips64EL);
  uint32_t PairTy = getMipsPairType(Type, Body);
  if (PairTy == R_MIPS_NONE)
    return 0;

  const uint8_t *Buf = Sec.Data.data();
  uint32_t SymIndex = Rel.getSymbol(Config->IsMips64EL);

  // To make things worse, paired relocations might not be contiguous in
  // the relocation table, so we need to do linear search. *sigh*
  for (const RelTy *RI = &Rel; RI != End; ++RI) {
    if (RI->getType(Config->IsMips64EL) != PairTy)
      continue;
    if (RI->getSymbol(Config->IsMips64EL) != SymIndex)
      continue;

    endianness E = Config->Endianness;
    int32_t Hi = (read32(Buf + Rel.r_offset, E) & 0xffff) << 16;
    int32_t Lo = SignExtend32<16>(read32(Buf + RI->r_offset, E));
    return Hi + Lo;
  }

  warn("can't find matching " + toString(PairTy) + " relocation for " +
       toString(Type));
  return 0;
d558 3
a560 3
static void reportUndefined(SymbolBody &Sym, InputSectionBase &S,
                            uint64_t Offset) {
  if (Config->UnresolvedSymbols == UnresolvedPolicy::IgnoreAll)
d563 2
a564 3
  bool CanBeExternal = Sym.symbol()->computeBinding() != STB_LOCAL &&
                       Sym.getVisibility() == STV_DEFAULT;
  if (Config->UnresolvedSymbols == UnresolvedPolicy::Ignore && CanBeExternal)
d568 1
a568 6
      "undefined symbol: " + toString(Sym) + "\n>>> referenced by ";

  std::string Src = S.getSrcMsg<ELFT>(Offset);
  if (!Src.empty())
    Msg += Src + "\n>>>               ";
  Msg += S.getObjMsg<ELFT>(Offset);
d570 1
a570 2
  if (Config->UnresolvedSymbols == UnresolvedPolicy::WarnAll ||
      (Config->UnresolvedSymbols == UnresolvedPolicy::Warn && CanBeExternal)) {
d572 1
a572 1
  } else {
a573 1
  }
d587 1
a587 1
    Type |= I->getType(Config->IsMips64EL) << (8 * Processed);
a591 84
// .eh_frame sections are mergeable input sections, so their input
// offsets are not linearly mapped to output section. For each input
// offset, we need to find a section piece containing the offset and
// add the piece's base address to the input offset to compute the
// output offset. That isn't cheap.
//
// This class is to speed up the offset computation. When we process
// relocations, we access offsets in the monotonically increasing
// order. So we can optimize for that access pattern.
//
// For sections other than .eh_frame, this class doesn't do anything.
namespace {
class OffsetGetter {
public:
  explicit OffsetGetter(InputSectionBase &Sec) {
    if (auto *Eh = dyn_cast<EhInputSection>(&Sec)) {
      P = Eh->Pieces;
      Size = Eh->Pieces.size();
    }
  }

  // Translates offsets in input sections to offsets in output sections.
  // Given offset must increase monotonically. We assume that P is
  // sorted by InputOff.
  uint64_t get(uint64_t Off) {
    if (P.empty())
      return Off;

    while (I != Size && P[I].InputOff + P[I].size() <= Off)
      ++I;
    if (I == Size)
      return Off;

    // P must be contiguous, so there must be no holes in between.
    assert(P[I].InputOff <= Off && "Relocation not in any piece");

    // Offset -1 means that the piece is dead (i.e. garbage collected).
    if (P[I].OutputOff == -1)
      return -1;
    return P[I].OutputOff + Off - P[I].InputOff;
  }

private:
  ArrayRef<EhSectionPiece> P;
  size_t I = 0;
  size_t Size;
};
} // namespace

template <class ELFT, class GotPltSection>
static void addPltEntry(PltSection *Plt, GotPltSection *GotPlt,
                        RelocationSection<ELFT> *Rel, uint32_t Type,
                        SymbolBody &Sym, bool UseSymVA) {
  Plt->addEntry<ELFT>(Sym);
  GotPlt->addEntry(Sym);
  Rel->addReloc({Type, GotPlt, Sym.getGotPltOffset(), UseSymVA, &Sym, 0});
}

template <class ELFT>
static void addGotEntry(SymbolBody &Sym, bool Preemptible) {
  InX::Got->addEntry(Sym);

  uint64_t Off = Sym.getGotOffset();
  uint32_t DynType;
  RelExpr Expr = R_ABS;

  if (Sym.isTls()) {
    DynType = Target->TlsGotRel;
    Expr = R_TLS;
  } else if (!Preemptible && Config->Pic && !isAbsolute(Sym)) {
    DynType = Target->RelativeRel;
  } else {
    DynType = Target->GotRel;
  }

  bool Constant = !Preemptible && !(Config->Pic && !isAbsolute(Sym));
  if (!Constant)
    In<ELFT>::RelaDyn->addReloc(
        {DynType, InX::Got, Off, !Preemptible, &Sym, 0});

  if (Constant || (!Config->IsRela && !Preemptible))
    InX::Got->Relocations.push_back({Expr, DynType, Off, 0, &Sym});
}

d606 4
a609 2
static void scanRelocs(InputSectionBase &Sec, ArrayRef<RelTy> Rels) {
  OffsetGetter GetOffset(Sec);
d611 19
a629 4
  for (auto I = Rels.begin(), End = Rels.end(); I != End; ++I) {
    const RelTy &Rel = *I;
    SymbolBody &Body = Sec.getFile<ELFT>()->getRelocTargetSym(Rel);
    uint32_t Type = Rel.getType(Config->IsMips64EL);
d634 1
a634 1
          mergeMipsN32RelTypes(Type, Rel.r_offset, I + 1, End);
d638 2
a639 9
    // Compute the offset of this section in the output section.
    uint64_t Offset = GetOffset.get(Rel.r_offset);
    if (Offset == uint64_t(-1))
      continue;

    // Report undefined symbols. The fact that we report undefined
    // symbols here means that we report undefined symbols only when
    // they have relocations pointing to them. We don't care about
    // undefined symbols that are in dead-stripped sections.
d641 1
a641 8
      reportUndefined<ELFT>(Body, Sec, Rel.r_offset);

    RelExpr Expr =
        Target->getRelExpr(Type, Body, Sec.Data.begin() + Rel.r_offset);

    // Ignore "hint" relocations because they are only markers for relaxation.
    if (isRelExprOneOf<R_HINT, R_NONE>(Expr))
      continue;
d643 1
d645 2
a646 2
    Expr = adjustExpr<ELFT>(Body, Expr, Type, Sec.Data.data() + Rel.r_offset,
                            Sec, Rel.r_offset);
d650 18
d670 5
a674 8
    if (isRelExprOneOf<R_GOTONLY_PC, R_GOTONLY_PC_FROM_END, R_GOTREL,
                       R_GOTREL_FROM_END, R_PPC_TOC>(Expr))
      InX::Got->HasGotOffRel = true;

    // Read an addend.
    int64_t Addend = computeAddend<ELFT>(Rel, Sec.Data.data());
    if (Config->EMachine == EM_MIPS)
      Addend += computeMipsAddend<ELFT>(Rel, Sec, Expr, Body, End);
a675 2
    // Process some TLS relocations, including relaxing TLS relocations.
    // Note that this function does not handle all TLS relocations.
d677 1
a677 1
            handleTlsRelocation<ELFT>(Type, Body, Sec, Offset, Addend, Expr)) {
d682 4
a685 9
    // If a relocation needs PLT, we create PLT and GOTPLT slots for the symbol.
    if (needsPlt(Expr) && !Body.isInPlt()) {
      if (Body.isGnuIFunc() && !Preemptible)
        addPltEntry(InX::Iplt, InX::IgotPlt, In<ELFT>::RelaIplt,
                    Target->IRelativeRel, Body, true);
      else
        addPltEntry(InX::Plt, InX::GotPlt, In<ELFT>::RelaPlt, Target->PltRel,
                    Body, !Preemptible);
    }
d687 21
a707 20
    // Create a GOT slot if a relocation needs GOT.
    if (needsGot(Expr)) {
      if (Config->EMachine == EM_MIPS) {
        // MIPS ABI has special rules to process GOT entries and doesn't
        // require relocation entries for them. A special case is TLS
        // relocations. In that case dynamic loader applies dynamic
        // relocations to initialize TLS GOT entries.
        // See "Global Offset Table" in Chapter 5 in the following document
        // for detailed description:
        // ftp://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf
        InX::MipsGot->addEntry(Body, Addend, Expr);
        if (Body.isTls() && Body.isPreemptible())
          In<ELFT>::RelaDyn->addReloc({Target->TlsGotRel, InX::MipsGot,
                                       Body.getGotOffset(), false, &Body, 0});
      } else if (!Body.isInGot()) {
        addGotEntry<ELFT>(Body, Preemptible);
      }
    }

    if (!needsPlt(Expr) && !needsGot(Expr) && isPreemptible(Body, Type)) {
d711 3
a713 6
        error("relocation " + toString(Type) +
              " cannot be used against shared object; recompile with -fPIC" +
              getLocation<ELFT>(Sec, Body, Offset));

      In<ELFT>::RelaDyn->addReloc(
          {Target->getDynRel(Type), &Sec, Offset, false, &Body, Addend});
d731 1
a731 1
        InX::MipsGot->addEntry(Body, Addend, Expr);
d735 54
a788 16
    // If the relocation points to something in the file, we can process it.
    bool IsConstant =
        isStaticLinkTimeConstant<ELFT>(Expr, Type, Body, Sec, Rel.r_offset);

    // The size is not going to change, so we fold it in here.
    if (Expr == R_SIZE)
      Addend += Body.getSize<ELFT>();

    // If the output being produced is position independent, the final value
    // is still not known. In that case we still need some help from the
    // dynamic linker. We can however do better than just copying the incoming
    // relocation. We can process some of it and and just ask the dynamic
    // linker to add the load address.
    if (!IsConstant)
      In<ELFT>::RelaDyn->addReloc(
          {Target->RelativeRel, &Sec, Offset, true, &Body, Addend});
d790 8
a797 5
    // If the produced value is a constant, we just remember to write it
    // when outputting this section. We also have to do it if the format
    // uses Elf_Rel, since in that case the written value is the addend.
    if (IsConstant || !RelTy::IsRela)
      Sec.Relocations.push_back({Expr, Type, Offset, Addend, &Body});
d801 1
a801 1
template <class ELFT> void elf::scanRelocations(InputSectionBase &S) {
d803 1
a803 1
    scanRelocs<ELFT>(S, S.relas<ELFT>());
d805 1
a805 1
    scanRelocs<ELFT>(S, S.rels<ELFT>());
d808 17
a824 33
// Insert the Thunks for OutputSection OS into their designated place
// in the Sections vector, and recalculate the InputSection output section
// offsets.
// This may invalidate any output section offsets stored outside of InputSection
void ThunkCreator::mergeThunks() {
  for (auto &KV : ThunkSections) {
    std::vector<InputSection *> *ISR = KV.first;
    std::vector<ThunkSection *> &Thunks = KV.second;

    // Order Thunks in ascending OutSecOff
    auto ThunkCmp = [](const ThunkSection *A, const ThunkSection *B) {
      return A->OutSecOff < B->OutSecOff;
    };
    std::stable_sort(Thunks.begin(), Thunks.end(), ThunkCmp);

    // Merge sorted vectors of Thunks and InputSections by OutSecOff
    std::vector<InputSection *> Tmp;
    Tmp.reserve(ISR->size() + Thunks.size());
    auto MergeCmp = [](const InputSection *A, const InputSection *B) {
      // std::merge requires a strict weak ordering.
      if (A->OutSecOff < B->OutSecOff)
        return true;
      if (A->OutSecOff == B->OutSecOff)
        // Check if Thunk is immediately before any specific Target InputSection
        // for example Mips LA25 Thunks.
        if (auto *TA = dyn_cast<ThunkSection>(A))
          if (TA && TA->getTargetInputSection() == B)
            return true;
      return false;
    };
    std::merge(ISR->begin(), ISR->end(), Thunks.begin(), Thunks.end(),
               std::back_inserter(Tmp), MergeCmp);
    *ISR = std::move(Tmp);
d828 5
a832 7
static uint32_t findEndOfFirstNonExec(OutputSectionCommand &Cmd) {
  for (BaseCommand *Base : Cmd.Commands)
    if (auto *ISD = dyn_cast<InputSectionDescription>(Base))
      for (auto *IS : ISD->Sections)
        if ((IS->Flags & SHF_EXECINSTR) == 0)
          return IS->OutSecOff + IS->getSize();
  return 0;
d835 9
a843 74
ThunkSection *ThunkCreator::getOSThunkSec(OutputSectionCommand *Cmd,
                                          std::vector<InputSection *> *ISR) {
  if (CurTS == nullptr) {
    uint32_t Off = findEndOfFirstNonExec(*Cmd);
    CurTS = addThunkSection(Cmd->Sec, ISR, Off);
  }
  return CurTS;
}

ThunkSection *ThunkCreator::getISThunkSec(InputSection *IS, OutputSection *OS) {
  ThunkSection *TS = ThunkedSections.lookup(IS);
  if (TS)
    return TS;
  auto *TOS = IS->getParent();

  // Find InputSectionRange within TOS that IS is in
  OutputSectionCommand *C = Script->getCmd(TOS);
  std::vector<InputSection *> *Range = nullptr;
  for (BaseCommand *BC : C->Commands)
    if (auto *ISD = dyn_cast<InputSectionDescription>(BC)) {
      InputSection *first = ISD->Sections.front();
      InputSection *last = ISD->Sections.back();
      if (IS->OutSecOff >= first->OutSecOff &&
          IS->OutSecOff <= last->OutSecOff) {
        Range = &ISD->Sections;
        break;
      }
    }
  TS = addThunkSection(TOS, Range, IS->OutSecOff);
  ThunkedSections[IS] = TS;
  return TS;
}

ThunkSection *ThunkCreator::addThunkSection(OutputSection *OS,
                                            std::vector<InputSection *> *ISR,
                                            uint64_t Off) {
  auto *TS = make<ThunkSection>(OS, Off);
  ThunkSections[ISR].push_back(TS);
  return TS;
}

std::pair<Thunk *, bool> ThunkCreator::getThunk(SymbolBody &Body,
                                                uint32_t Type) {
  auto Res = ThunkedSymbols.insert({&Body, std::vector<Thunk *>()});
  if (!Res.second) {
    // Check existing Thunks for Body to see if they can be reused
    for (Thunk *ET : Res.first->second)
      if (ET->isCompatibleWith(Type))
        return std::make_pair(ET, false);
  }
  // No existing compatible Thunk in range, create a new one
  Thunk *T = addThunk(Type, Body);
  Res.first->second.push_back(T);
  return std::make_pair(T, true);
}

// Call Fn on every executable InputSection accessed via the linker script
// InputSectionDescription::Sections.
void ThunkCreator::forEachExecInputSection(
    ArrayRef<OutputSectionCommand *> OutputSections,
    std::function<void(OutputSectionCommand *, std::vector<InputSection *> *,
                       InputSection *)>
        Fn) {
  for (OutputSectionCommand *Cmd : OutputSections) {
    OutputSection *OS = Cmd->Sec;
    if (!(OS->Flags & SHF_ALLOC) || !(OS->Flags & SHF_EXECINSTR))
      continue;
    for (BaseCommand *BC : Cmd->Commands)
      if (auto *ISD = dyn_cast<InputSectionDescription>(BC)) {
        CurTS = nullptr;
        for (InputSection *IS : ISD->Sections)
          Fn(Cmd, &ISD->Sections, IS);
      }
  }
a844 52

// Process all relocations from the InputSections that have been assigned
// to OutputSections and redirect through Thunks if needed.
//
// createThunks must be called after scanRelocs has created the Relocations for
// each InputSection. It must be called before the static symbol table is
// finalized. If any Thunks are added to an OutputSection the output section
// offsets of the InputSections will change.
//
// FIXME: All Thunks are assumed to be in range of the relocation. Range
// extension Thunks are not yet supported.
bool ThunkCreator::createThunks(
    ArrayRef<OutputSectionCommand *> OutputSections) {
  if (Pass > 0)
    ThunkSections.clear();

  // Create all the Thunks and insert them into synthetic ThunkSections. The
  // ThunkSections are later inserted back into the OutputSection.

  // We separate the creation of ThunkSections from the insertion of the
  // ThunkSections back into the OutputSection as ThunkSections are not always
  // inserted into the same OutputSection as the caller.
  forEachExecInputSection(OutputSections, [&](OutputSectionCommand *Cmd,
                                              std::vector<InputSection *> *ISR,
                                              InputSection *IS) {
    for (Relocation &Rel : IS->Relocations) {
      SymbolBody &Body = *Rel.Sym;
      if (Thunks.find(&Body) != Thunks.end() ||
          !Target->needsThunk(Rel.Expr, Rel.Type, IS->File, Body))
        continue;
      Thunk *T;
      bool IsNew;
      std::tie(T, IsNew) = getThunk(Body, Rel.Type);
      if (IsNew) {
        // Find or create a ThunkSection for the new Thunk
        ThunkSection *TS;
        if (auto *TIS = T->getTargetInputSection())
          TS = getISThunkSec(TIS, Cmd->Sec);
        else
          TS = getOSThunkSec(Cmd, ISR);
        TS->addThunk(T);
        Thunks[T->ThunkSym] = T;
      }
      // Redirect relocation to Thunk, we never go via the PLT to a Thunk
      Rel.Sym = T->ThunkSym;
      Rel.Expr = fromPlt(Rel.Expr);
    }
  });
  // Merge all created synthetic ThunkSections back into OutputSection
  mergeThunks();
  ++Pass;
  return !ThunkSections.empty();
a845 5

template void elf::scanRelocations<ELF32LE>(InputSectionBase &);
template void elf::scanRelocations<ELF32BE>(InputSectionBase &);
template void elf::scanRelocations<ELF64LE>(InputSectionBase &);
template void elf::scanRelocations<ELF64BE>(InputSectionBase &);
@


