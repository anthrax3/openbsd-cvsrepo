head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.1
date	2017.01.14.19.55.45;	author patrick;	state Exp;
branches
	1.1.1.1;
next	;
commitid	qMUxATnKgqN83Oct;

1.1.1.1
date	2017.01.14.19.55.45;	author patrick;	state Exp;
branches;
next	1.1.1.2;
commitid	qMUxATnKgqN83Oct;

1.1.1.2
date	2017.01.24.08.33.12;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===- EhFrame.cpp -------------------------------------------------------===//
//
//                             The LLVM Linker
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// .eh_frame section contains information on how to unwind the stack when
// an exception is thrown. The section consists of sequence of CIE and FDE
// records. The linker needs to merge CIEs and associate FDEs to CIEs.
// That means the linker has to understand the format of the section.
//
// This file contains a few utility functions to read .eh_frame contents.
//
//===----------------------------------------------------------------------===//

#include "EhFrame.h"
#include "Error.h"

#include "llvm/Object/ELF.h"
#include "llvm/Support/Dwarf.h"
#include "llvm/Support/Endian.h"

using namespace llvm;
using namespace llvm::ELF;
using namespace llvm::dwarf;
using namespace llvm::object;
using namespace llvm::support::endian;

namespace lld {
namespace elf {

// .eh_frame section is a sequence of records. Each record starts with
// a 4 byte length field. This function reads the length.
template <class ELFT> size_t readEhRecordSize(ArrayRef<uint8_t> D) {
  const endianness E = ELFT::TargetEndianness;
  if (D.size() < 4)
    fatal("CIE/FDE too small");

  // First 4 bytes of CIE/FDE is the size of the record.
  // If it is 0xFFFFFFFF, the next 8 bytes contain the size instead,
  // but we do not support that format yet.
  uint64_t V = read32<E>(D.data());
  if (V == UINT32_MAX)
    fatal("CIE/FDE too large");
  uint64_t Size = V + 4;
  if (Size > D.size())
    fatal("CIE/FIE ends past the end of the section");
  return Size;
}

// Read a byte and advance D by one byte.
static uint8_t readByte(ArrayRef<uint8_t> &D) {
  if (D.empty())
    fatal("corrupted or unsupported CIE information");
  uint8_t B = D.front();
  D = D.slice(1);
  return B;
}

// Skip an integer encoded in the LEB128 format.
// Actual number is not of interest because only the runtime needs it.
// But we need to be at least able to skip it so that we can read
// the field that follows a LEB128 number.
static void skipLeb128(ArrayRef<uint8_t> &D) {
  while (!D.empty()) {
    uint8_t Val = D.front();
    D = D.slice(1);
    if ((Val & 0x80) == 0)
      return;
  }
  fatal("corrupted or unsupported CIE information");
}

template <class ELFT> static size_t getAugPSize(unsigned Enc) {
  switch (Enc & 0x0f) {
  case DW_EH_PE_absptr:
  case DW_EH_PE_signed:
    return ELFT::Is64Bits ? 8 : 4;
  case DW_EH_PE_udata2:
  case DW_EH_PE_sdata2:
    return 2;
  case DW_EH_PE_udata4:
  case DW_EH_PE_sdata4:
    return 4;
  case DW_EH_PE_udata8:
  case DW_EH_PE_sdata8:
    return 8;
  }
  fatal("unknown FDE encoding");
}

template <class ELFT> static void skipAugP(ArrayRef<uint8_t> &D) {
  uint8_t Enc = readByte(D);
  if ((Enc & 0xf0) == DW_EH_PE_aligned)
    fatal("DW_EH_PE_aligned encoding is not supported");
  size_t Size = getAugPSize<ELFT>(Enc);
  if (Size >= D.size())
    fatal("corrupted CIE");
  D = D.slice(Size);
}

template <class ELFT> uint8_t getFdeEncoding(ArrayRef<uint8_t> D) {
  if (D.size() < 8)
    fatal("CIE too small");
  D = D.slice(8);

  uint8_t Version = readByte(D);
  if (Version != 1 && Version != 3)
    fatal("FDE version 1 or 3 expected, but got " + Twine((unsigned)Version));

  const unsigned char *AugEnd = std::find(D.begin(), D.end(), '\0');
  if (AugEnd == D.end())
    fatal("corrupted CIE");
  StringRef Aug(reinterpret_cast<const char *>(D.begin()), AugEnd - D.begin());
  D = D.slice(Aug.size() + 1);

  // Code alignment factor should always be 1 for .eh_frame.
  if (readByte(D) != 1)
    fatal("CIE code alignment must be 1");

  // Skip data alignment factor.
  skipLeb128(D);

  // Skip the return address register. In CIE version 1 this is a single
  // byte. In CIE version 3 this is an unsigned LEB128.
  if (Version == 1)
    readByte(D);
  else
    skipLeb128(D);

  // We only care about an 'R' value, but other records may precede an 'R'
  // record. Unfortunately records are not in TLV (type-length-value) format,
  // so we need to teach the linker how to skip records for each type.
  for (char C : Aug) {
    if (C == 'R')
      return readByte(D);
    if (C == 'z') {
      skipLeb128(D);
      continue;
    }
    if (C == 'P') {
      skipAugP<ELFT>(D);
      continue;
    }
    if (C == 'L') {
      readByte(D);
      continue;
    }
    fatal("unknown .eh_frame augmentation string: " + Aug);
  }
  return DW_EH_PE_absptr;
}

template size_t readEhRecordSize<ELF32LE>(ArrayRef<uint8_t>);
template size_t readEhRecordSize<ELF32BE>(ArrayRef<uint8_t>);
template size_t readEhRecordSize<ELF64LE>(ArrayRef<uint8_t>);
template size_t readEhRecordSize<ELF64BE>(ArrayRef<uint8_t>);

template uint8_t getFdeEncoding<ELF32LE>(ArrayRef<uint8_t>);
template uint8_t getFdeEncoding<ELF32BE>(ArrayRef<uint8_t>);
template uint8_t getFdeEncoding<ELF64LE>(ArrayRef<uint8_t>);
template uint8_t getFdeEncoding<ELF64BE>(ArrayRef<uint8_t>);
}
}
@


1.1.1.1
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a20 3
#include "InputSection.h"
#include "Relocations.h"
#include "Strings.h"
d32 2
a33 2
using namespace lld;
using namespace lld::elf;
a34 27
namespace {
template <class ELFT> class EhReader {
public:
  EhReader(InputSectionBase<ELFT> *S, ArrayRef<uint8_t> D) : IS(S), D(D) {}
  size_t readEhRecordSize();
  uint8_t getFdeEncoding();

private:
  template <class P> void failOn(const P *Loc, const Twine &Msg) {
    fatal(IS->getLocation((const uint8_t *)Loc - IS->Data.data()) + ": " + Msg);
  }

  uint8_t readByte();
  void skipBytes(size_t Count);
  StringRef readString();
  void skipLeb128();
  void skipAugP();

  InputSectionBase<ELFT> *IS;
  ArrayRef<uint8_t> D;
};
}

template <class ELFT>
size_t elf::readEhRecordSize(InputSectionBase<ELFT> *S, size_t Off) {
  return EhReader<ELFT>(S, S->Data.slice(Off)).readEhRecordSize();
}
d37 1
a37 1
template <class ELFT> size_t EhReader<ELFT>::readEhRecordSize() {
d40 1
a40 1
    failOn(D.data(), "CIE/FDE too small");
d47 1
a47 1
    failOn(D.data(), "CIE/FDE too large");
d50 1
a50 1
    failOn(D.data(), "CIE/FDE ends past the end of the section");
d55 1
a55 1
template <class ELFT> uint8_t EhReader<ELFT>::readByte() {
d57 1
a57 1
    failOn(D.data(), "unexpected end of CIE");
a62 16
template <class ELFT> void EhReader<ELFT>::skipBytes(size_t Count) {
  if (D.size() < Count)
    failOn(D.data(), "CIE is too small");
  D = D.slice(Count);
}

// Read a null-terminated string.
template <class ELFT> StringRef EhReader<ELFT>::readString() {
  const uint8_t *End = std::find(D.begin(), D.end(), '\0');
  if (End == D.end())
    failOn(D.data(), "corrupted CIE (failed to read string)");
  StringRef S = toStringRef(D.slice(0, End - D.begin()));
  D = D.slice(S.size() + 1);
  return S;
}

d67 1
a67 2
template <class ELFT> void EhReader<ELFT>::skipLeb128() {
  const uint8_t *ErrPos = D.data();
d74 1
a74 1
  failOn(ErrPos, "corrupted CIE (failed to read LEB128)");
d92 1
a92 1
  return 0;
d95 2
a96 2
template <class ELFT> void EhReader<ELFT>::skipAugP() {
  uint8_t Enc = readByte();
d98 1
a98 1
    failOn(D.data() - 1, "DW_EH_PE_aligned encoding is not supported");
a99 2
  if (Size == 0)
    failOn(D.data() - 1, "unknown FDE encoding");
d101 1
a101 1
    failOn(D.data() - 1, "corrupted CIE");
d105 4
a108 4
template <class ELFT> uint8_t elf::getFdeEncoding(EhSectionPiece *P) {
  auto *IS = static_cast<InputSectionBase<ELFT> *>(P->ID);
  return EhReader<ELFT>(IS, P->data()).getFdeEncoding();
}
d110 1
a110 3
template <class ELFT> uint8_t EhReader<ELFT>::getFdeEncoding() {
  skipBytes(8);
  int Version = readByte();
d112 1
a112 2
    failOn(D.data() - 1,
           "FDE version 1 or 3 expected, but got " + Twine(Version));
d114 9
a122 1
  StringRef Aug = readString();
d124 2
a125 3
  // Skip code and data alignment factors.
  skipLeb128();
  skipLeb128();
d130 1
a130 1
    readByte();
d132 1
a132 1
    skipLeb128();
d139 1
a139 1
      return readByte();
d141 1
a141 1
      skipLeb128();
d145 1
a145 1
      skipAugP();
d149 1
a149 1
      readByte();
d152 1
a152 1
    failOn(Aug.data(), "unknown .eh_frame augmentation string: " + Aug);
d157 11
a167 13
template size_t elf::readEhRecordSize<ELF32LE>(InputSectionBase<ELF32LE> *S,
                                               size_t Off);
template size_t elf::readEhRecordSize<ELF32BE>(InputSectionBase<ELF32BE> *S,
                                               size_t Off);
template size_t elf::readEhRecordSize<ELF64LE>(InputSectionBase<ELF64LE> *S,
                                               size_t Off);
template size_t elf::readEhRecordSize<ELF64BE>(InputSectionBase<ELF64BE> *S,
                                               size_t Off);

template uint8_t elf::getFdeEncoding<ELF32LE>(EhSectionPiece *P);
template uint8_t elf::getFdeEncoding<ELF32BE>(EhSectionPiece *P);
template uint8_t elf::getFdeEncoding<ELF64LE>(EhSectionPiece *P);
template uint8_t elf::getFdeEncoding<ELF64BE>(EhSectionPiece *P);
@

