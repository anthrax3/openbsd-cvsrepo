head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.2
date	2017.03.19.11.13.23;	author kettenis;	state Exp;
branches;
next	1.1;
commitid	oKb3ISZtkr5to5BK;

1.1
date	2017.01.14.19.55.45;	author patrick;	state Exp;
branches
	1.1.1.1;
next	;
commitid	qMUxATnKgqN83Oct;

1.1.1.1
date	2017.01.14.19.55.45;	author patrick;	state Exp;
branches;
next	1.1.1.2;
commitid	qMUxATnKgqN83Oct;

1.1.1.2
date	2017.01.24.08.33.12;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	so2WA7LCP6wbxtYl;

1.1.1.3
date	2017.03.14.08.07.53;	author patrick;	state Exp;
branches;
next	;
commitid	aUi5NxOzBSLCN5eN;


desc
@@


1.2
log
@Work around a problem where linker-generated symbols are not properly
versioned and end up as local symbols despite being explicitly listed as
global in the version script.  This breaks out brk()/sbrk() implementation.

The diff is only a partial solution and unlikely to be accepted as-is
upstream.  We'll keep it as a local diff until a better solution is found.

ok guenther@@
@
text
@//===- SymbolTable.cpp ----------------------------------------------------===//
//
//                             The LLVM Linker
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// Symbol table is a bag of all known symbols. We put all symbols of
// all input files to the symbol table. The symbol table is basically
// a hash table with the logic to resolve symbol name conflicts using
// the symbol types.
//
//===----------------------------------------------------------------------===//

#include "SymbolTable.h"
#include "Config.h"
#include "Error.h"
#include "LinkerScript.h"
#include "Memory.h"
#include "Symbols.h"
#include "llvm/ADT/STLExtras.h"

using namespace llvm;
using namespace llvm::object;
using namespace llvm::ELF;

using namespace lld;
using namespace lld::elf;

// All input object files must be for the same architecture
// (e.g. it does not make sense to link x86 object files with
// MIPS object files.) This function checks for that error.
template <class ELFT> static bool isCompatible(InputFile *F) {
  if (!isa<ELFFileBase<ELFT>>(F) && !isa<BitcodeFile>(F))
    return true;

  if (F->EKind == Config->EKind && F->EMachine == Config->EMachine) {
    if (Config->EMachine != EM_MIPS)
      return true;
    if (isMipsN32Abi(F) == Config->MipsN32Abi)
      return true;
  }

  if (!Config->Emulation.empty())
    error(toString(F) + " is incompatible with " + Config->Emulation);
  else
    error(toString(F) + " is incompatible with " + toString(Config->FirstElf));
  return false;
}

// Add symbols in File to the symbol table.
template <class ELFT> void SymbolTable<ELFT>::addFile(InputFile *File) {
  if (!isCompatible<ELFT>(File))
    return;

  // Binary file
  if (auto *F = dyn_cast<BinaryFile>(File)) {
    BinaryFiles.push_back(F);
    F->parse<ELFT>();
    return;
  }

  // .a file
  if (auto *F = dyn_cast<ArchiveFile>(File)) {
    F->parse<ELFT>();
    return;
  }

  // Lazy object file
  if (auto *F = dyn_cast<LazyObjectFile>(File)) {
    F->parse<ELFT>();
    return;
  }

  if (Config->Trace)
    outs() << toString(File) << "\n";

  // .so file
  if (auto *F = dyn_cast<SharedFile<ELFT>>(File)) {
    // DSOs are uniquified not by filename but by soname.
    F->parseSoName();
    if (ErrorCount || !SoNames.insert(F->getSoName()).second)
      return;
    SharedFiles.push_back(F);
    F->parseRest();
    return;
  }

  // LLVM bitcode file
  if (auto *F = dyn_cast<BitcodeFile>(File)) {
    BitcodeFiles.push_back(F);
    F->parse<ELFT>(ComdatGroups);
    return;
  }

  // Regular object file
  auto *F = cast<ObjectFile<ELFT>>(File);
  ObjectFiles.push_back(F);
  F->parse(ComdatGroups);
}

// This function is where all the optimizations of link-time
// optimization happens. When LTO is in use, some input files are
// not in native object file format but in the LLVM bitcode format.
// This function compiles bitcode files into a few big native files
// using LLVM functions and replaces bitcode symbols with the results.
// Because all bitcode files that consist of a program are passed
// to the compiler at once, it can do whole-program optimization.
template <class ELFT> void SymbolTable<ELFT>::addCombinedLTOObject() {
  if (BitcodeFiles.empty())
    return;

  // Compile bitcode files and replace bitcode symbols.
  LTO.reset(new BitcodeCompiler);
  for (BitcodeFile *F : BitcodeFiles)
    LTO->add<ELFT>(*F);

  for (InputFile *File : LTO->compile()) {
    ObjectFile<ELFT> *Obj = cast<ObjectFile<ELFT>>(File);
    DenseSet<CachedHashStringRef> DummyGroups;
    Obj->parse(DummyGroups);
    ObjectFiles.push_back(Obj);
  }
}

template <class ELFT>
DefinedRegular<ELFT> *SymbolTable<ELFT>::addAbsolute(StringRef Name,
                                                     uint8_t Visibility,
                                                     uint8_t Binding) {
  Symbol *Sym =
      addRegular(Name, Visibility, STT_NOTYPE, 0, 0, Binding, nullptr, nullptr);
  return cast<DefinedRegular<ELFT>>(Sym->body());
}

// Add Name as an "ignored" symbol. An ignored symbol is a regular
// linker-synthesized defined symbol, but is only defined if needed.
template <class ELFT>
DefinedRegular<ELFT> *SymbolTable<ELFT>::addIgnored(StringRef Name,
                                                    uint8_t Visibility) {
  SymbolBody *S = find(Name);
  if (!S || S->isInCurrentDSO())
    return nullptr;
  if (Visibility == STV_DEFAULT) {
    for (SymbolVersion &Ver : Config->VersionScriptGlobals) {
      if (!Ver.HasWildcard && Ver.Name == S->getName())
        S->symbol()->VersionId = VER_NDX_GLOBAL;
    }
  }
  return addAbsolute(Name, Visibility);
}

// Set a flag for --trace-symbol so that we can print out a log message
// if a new symbol with the same name is inserted into the symbol table.
template <class ELFT> void SymbolTable<ELFT>::trace(StringRef Name) {
  Symtab.insert({CachedHashStringRef(Name), {-1, true}});
}

// Rename SYM as __wrap_SYM. The original symbol is preserved as __real_SYM.
// Used to implement --wrap.
template <class ELFT> void SymbolTable<ELFT>::wrap(StringRef Name) {
  SymbolBody *B = find(Name);
  if (!B)
    return;
  Symbol *Sym = B->symbol();
  Symbol *Real = addUndefined(Saver.save("__real_" + Name));
  Symbol *Wrap = addUndefined(Saver.save("__wrap_" + Name));

  // We rename symbols by replacing the old symbol's SymbolBody with the new
  // symbol's SymbolBody. This causes all SymbolBody pointers referring to the
  // old symbol to instead refer to the new symbol.
  memcpy(Real->Body.buffer, Sym->Body.buffer, sizeof(Sym->Body));
  memcpy(Sym->Body.buffer, Wrap->Body.buffer, sizeof(Wrap->Body));
}

static uint8_t getMinVisibility(uint8_t VA, uint8_t VB) {
  if (VA == STV_DEFAULT)
    return VB;
  if (VB == STV_DEFAULT)
    return VA;
  return std::min(VA, VB);
}

// Find an existing symbol or create and insert a new one.
template <class ELFT>
std::pair<Symbol *, bool> SymbolTable<ELFT>::insert(StringRef Name) {
  auto P = Symtab.insert(
      {CachedHashStringRef(Name), SymIndex((int)SymVector.size(), false)});
  SymIndex &V = P.first->second;
  bool IsNew = P.second;

  if (V.Idx == -1) {
    IsNew = true;
    V = SymIndex((int)SymVector.size(), true);
  }

  Symbol *Sym;
  if (IsNew) {
    Sym = new (BAlloc) Symbol;
    Sym->InVersionScript = false;
    Sym->Binding = STB_WEAK;
    Sym->Visibility = STV_DEFAULT;
    Sym->IsUsedInRegularObj = false;
    Sym->ExportDynamic = false;
    Sym->Traced = V.Traced;
    Sym->VersionId = Config->DefaultSymbolVersion;
    SymVector.push_back(Sym);
  } else {
    Sym = SymVector[V.Idx];
  }
  return {Sym, IsNew};
}

// Construct a string in the form of "Sym in File1 and File2".
// Used to construct an error message.
static std::string conflictMsg(SymbolBody *Existing, InputFile *NewFile) {
  return "'" + toString(*Existing) + "' in " + toString(Existing->File) +
         " and " + toString(NewFile);
}

// Find an existing symbol or create and insert a new one, then apply the given
// attributes.
template <class ELFT>
std::pair<Symbol *, bool>
SymbolTable<ELFT>::insert(StringRef Name, uint8_t Type, uint8_t Visibility,
                          bool CanOmitFromDynSym, InputFile *File) {
  bool IsUsedInRegularObj = !File || File->kind() == InputFile::ObjectKind;
  Symbol *S;
  bool WasInserted;
  std::tie(S, WasInserted) = insert(Name);

  // Merge in the new symbol's visibility.
  S->Visibility = getMinVisibility(S->Visibility, Visibility);
  if (!CanOmitFromDynSym && (Config->Shared || Config->ExportDynamic))
    S->ExportDynamic = true;
  if (IsUsedInRegularObj)
    S->IsUsedInRegularObj = true;
  if (!WasInserted && S->body()->Type != SymbolBody::UnknownType &&
      ((Type == STT_TLS) != S->body()->isTls()))
    error("TLS attribute mismatch for symbol " + conflictMsg(S->body(), File));

  return {S, WasInserted};
}

template <class ELFT> Symbol *SymbolTable<ELFT>::addUndefined(StringRef Name) {
  return addUndefined(Name, /*IsLocal=*/false, STB_GLOBAL, STV_DEFAULT,
                      /*Type*/ 0,
                      /*CanOmitFromDynSym*/ false, /*File*/ nullptr);
}

static uint8_t getVisibility(uint8_t StOther) { return StOther & 3; }

template <class ELFT>
Symbol *SymbolTable<ELFT>::addUndefined(StringRef Name, bool IsLocal,
                                        uint8_t Binding, uint8_t StOther,
                                        uint8_t Type, bool CanOmitFromDynSym,
                                        InputFile *File) {
  Symbol *S;
  bool WasInserted;
  std::tie(S, WasInserted) =
      insert(Name, Type, getVisibility(StOther), CanOmitFromDynSym, File);
  if (WasInserted) {
    S->Binding = Binding;
    replaceBody<Undefined<ELFT>>(S, Name, IsLocal, StOther, Type, File);
    return S;
  }
  if (Binding != STB_WEAK) {
    if (S->body()->isShared() || S->body()->isLazy())
      S->Binding = Binding;
    if (auto *SS = dyn_cast<SharedSymbol<ELFT>>(S->body()))
      SS->file()->IsUsed = true;
  }
  if (auto *L = dyn_cast<Lazy>(S->body())) {
    // An undefined weak will not fetch archive members, but we have to remember
    // its type. See also comment in addLazyArchive.
    if (S->isWeak())
      L->Type = Type;
    else if (InputFile *F = L->fetch())
      addFile(F);
  }
  return S;
}

// We have a new defined symbol with the specified binding. Return 1 if the new
// symbol should win, -1 if the new symbol should lose, or 0 if both symbols are
// strong defined symbols.
static int compareDefined(Symbol *S, bool WasInserted, uint8_t Binding) {
  if (WasInserted)
    return 1;
  SymbolBody *Body = S->body();
  if (Body->isLazy() || !Body->isInCurrentDSO())
    return 1;
  if (Binding == STB_WEAK)
    return -1;
  if (S->isWeak())
    return 1;
  return 0;
}

// We have a new non-common defined symbol with the specified binding. Return 1
// if the new symbol should win, -1 if the new symbol should lose, or 0 if there
// is a conflict. If the new symbol wins, also update the binding.
template <typename ELFT>
static int compareDefinedNonCommon(Symbol *S, bool WasInserted, uint8_t Binding,
                                   bool IsAbsolute, typename ELFT::uint Value) {
  if (int Cmp = compareDefined(S, WasInserted, Binding)) {
    if (Cmp > 0)
      S->Binding = Binding;
    return Cmp;
  }
  SymbolBody *B = S->body();
  if (isa<DefinedCommon>(B)) {
    // Non-common symbols take precedence over common symbols.
    if (Config->WarnCommon)
      warn("common " + S->body()->getName() + " is overridden");
    return 1;
  } else if (auto *R = dyn_cast<DefinedRegular<ELFT>>(B)) {
    if (R->Section == nullptr && Binding == STB_GLOBAL && IsAbsolute &&
        R->Value == Value)
      return -1;
  }
  return 0;
}

template <class ELFT>
Symbol *SymbolTable<ELFT>::addCommon(StringRef N, uint64_t Size,
                                     uint64_t Alignment, uint8_t Binding,
                                     uint8_t StOther, uint8_t Type,
                                     InputFile *File) {
  Symbol *S;
  bool WasInserted;
  std::tie(S, WasInserted) = insert(N, Type, getVisibility(StOther),
                                    /*CanOmitFromDynSym*/ false, File);
  int Cmp = compareDefined(S, WasInserted, Binding);
  if (Cmp > 0) {
    S->Binding = Binding;
    replaceBody<DefinedCommon>(S, N, Size, Alignment, StOther, Type, File);
  } else if (Cmp == 0) {
    auto *C = dyn_cast<DefinedCommon>(S->body());
    if (!C) {
      // Non-common symbols take precedence over common symbols.
      if (Config->WarnCommon)
        warn("common " + S->body()->getName() + " is overridden");
      return S;
    }

    if (Config->WarnCommon)
      warn("multiple common of " + S->body()->getName());

    Alignment = C->Alignment = std::max(C->Alignment, Alignment);
    if (Size > C->Size)
      replaceBody<DefinedCommon>(S, N, Size, Alignment, StOther, Type, File);
  }
  return S;
}

static void print(const Twine &Msg) {
  if (Config->AllowMultipleDefinition)
    warn(Msg);
  else
    error(Msg);
}

static void reportDuplicate(SymbolBody *Existing, InputFile *NewFile) {
  print("duplicate symbol " + conflictMsg(Existing, NewFile));
}

template <class ELFT>
static void reportDuplicate(SymbolBody *Existing,
                            InputSectionBase<ELFT> *ErrSec,
                            typename ELFT::uint ErrOffset) {
  DefinedRegular<ELFT> *D = dyn_cast<DefinedRegular<ELFT>>(Existing);
  if (!D || !D->Section || !ErrSec) {
    reportDuplicate(Existing, ErrSec ? ErrSec->getFile() : nullptr);
    return;
  }

  std::string OldLoc = D->Section->getLocation(D->Value);
  std::string NewLoc = ErrSec->getLocation(ErrOffset);

  print(NewLoc + ": duplicate symbol '" + toString(*Existing) + "'");
  print(OldLoc + ": previous definition was here");
}

template <typename ELFT>
Symbol *SymbolTable<ELFT>::addRegular(StringRef Name, uint8_t StOther,
                                      uint8_t Type, uintX_t Value, uintX_t Size,
                                      uint8_t Binding,
                                      InputSectionBase<ELFT> *Section,
                                      InputFile *File) {
  Symbol *S;
  bool WasInserted;
  std::tie(S, WasInserted) = insert(Name, Type, getVisibility(StOther),
                                    /*CanOmitFromDynSym*/ false, File);
  int Cmp = compareDefinedNonCommon<ELFT>(S, WasInserted, Binding,
                                          Section == nullptr, Value);
  if (Cmp > 0)
    replaceBody<DefinedRegular<ELFT>>(S, Name, /*IsLocal=*/false, StOther, Type,
                                      Value, Size, Section, File);
  else if (Cmp == 0)
    reportDuplicate(S->body(), Section, Value);
  return S;
}

template <typename ELFT>
Symbol *SymbolTable<ELFT>::addSynthetic(StringRef N,
                                        const OutputSectionBase *Section,
                                        uintX_t Value, uint8_t StOther) {
  Symbol *S;
  bool WasInserted;
  std::tie(S, WasInserted) = insert(N, STT_NOTYPE, getVisibility(StOther),
                                    /*CanOmitFromDynSym*/ false, nullptr);
  int Cmp = compareDefinedNonCommon<ELFT>(S, WasInserted, STB_GLOBAL,
                                          /*IsAbsolute*/ false, /*Value*/ 0);
  if (Cmp > 0)
    replaceBody<DefinedSynthetic>(S, N, Value, Section);
  else if (Cmp == 0)
    reportDuplicate(S->body(), nullptr);
  return S;
}

template <typename ELFT>
void SymbolTable<ELFT>::addShared(SharedFile<ELFT> *F, StringRef Name,
                                  const Elf_Sym &Sym,
                                  const typename ELFT::Verdef *Verdef) {
  // DSO symbols do not affect visibility in the output, so we pass STV_DEFAULT
  // as the visibility, which will leave the visibility in the symbol table
  // unchanged.
  Symbol *S;
  bool WasInserted;
  std::tie(S, WasInserted) =
      insert(Name, Sym.getType(), STV_DEFAULT, /*CanOmitFromDynSym*/ true, F);
  // Make sure we preempt DSO symbols with default visibility.
  if (Sym.getVisibility() == STV_DEFAULT)
    S->ExportDynamic = true;
  if (WasInserted || isa<Undefined<ELFT>>(S->body())) {
    replaceBody<SharedSymbol<ELFT>>(S, F, Name, Sym, Verdef);
    if (!S->isWeak())
      F->IsUsed = true;
  }
}

template <class ELFT>
Symbol *SymbolTable<ELFT>::addBitcode(StringRef Name, uint8_t Binding,
                                      uint8_t StOther, uint8_t Type,
                                      bool CanOmitFromDynSym, BitcodeFile *F) {
  Symbol *S;
  bool WasInserted;
  std::tie(S, WasInserted) =
      insert(Name, Type, getVisibility(StOther), CanOmitFromDynSym, F);
  int Cmp = compareDefinedNonCommon<ELFT>(S, WasInserted, Binding,
                                          /*IsAbs*/ false, /*Value*/ 0);
  if (Cmp > 0)
    replaceBody<DefinedRegular<ELFT>>(S, Name, /*IsLocal=*/false, StOther, Type,
                                      0, 0, nullptr, F);
  else if (Cmp == 0)
    reportDuplicate(S->body(), F);
  return S;
}

template <class ELFT> SymbolBody *SymbolTable<ELFT>::find(StringRef Name) {
  auto It = Symtab.find(CachedHashStringRef(Name));
  if (It == Symtab.end())
    return nullptr;
  SymIndex V = It->second;
  if (V.Idx == -1)
    return nullptr;
  return SymVector[V.Idx]->body();
}

template <class ELFT>
SymbolBody *SymbolTable<ELFT>::findInCurrentDSO(StringRef Name) {
  if (SymbolBody *S = find(Name))
    if (S->isInCurrentDSO())
      return S;
  return nullptr;
}

template <class ELFT>
void SymbolTable<ELFT>::addLazyArchive(ArchiveFile *F,
                                       const object::Archive::Symbol Sym) {
  Symbol *S;
  bool WasInserted;
  StringRef Name = Sym.getName();
  std::tie(S, WasInserted) = insert(Name);
  if (WasInserted) {
    replaceBody<LazyArchive>(S, *F, Sym, SymbolBody::UnknownType);
    return;
  }
  if (!S->body()->isUndefined())
    return;

  // Weak undefined symbols should not fetch members from archives. If we were
  // to keep old symbol we would not know that an archive member was available
  // if a strong undefined symbol shows up afterwards in the link. If a strong
  // undefined symbol never shows up, this lazy symbol will get to the end of
  // the link and must be treated as the weak undefined one. We already marked
  // this symbol as used when we added it to the symbol table, but we also need
  // to preserve its type. FIXME: Move the Type field to Symbol.
  if (S->isWeak()) {
    replaceBody<LazyArchive>(S, *F, Sym, S->body()->Type);
    return;
  }
  std::pair<MemoryBufferRef, uint64_t> MBInfo = F->getMember(&Sym);
  if (!MBInfo.first.getBuffer().empty())
    addFile(createObjectFile(MBInfo.first, F->getName(), MBInfo.second));
}

template <class ELFT>
void SymbolTable<ELFT>::addLazyObject(StringRef Name, LazyObjectFile &Obj) {
  Symbol *S;
  bool WasInserted;
  std::tie(S, WasInserted) = insert(Name);
  if (WasInserted) {
    replaceBody<LazyObject>(S, Name, Obj, SymbolBody::UnknownType);
    return;
  }
  if (!S->body()->isUndefined())
    return;

  // See comment for addLazyArchive above.
  if (S->isWeak()) {
    replaceBody<LazyObject>(S, Name, Obj, S->body()->Type);
  } else {
    MemoryBufferRef MBRef = Obj.getBuffer();
    if (!MBRef.getBuffer().empty())
      addFile(createObjectFile(MBRef));
  }
}

// Process undefined (-u) flags by loading lazy symbols named by those flags.
template <class ELFT> void SymbolTable<ELFT>::scanUndefinedFlags() {
  for (StringRef S : Config->Undefined)
    if (auto *L = dyn_cast_or_null<Lazy>(find(S)))
      if (InputFile *File = L->fetch())
        addFile(File);
}

// This function takes care of the case in which shared libraries depend on
// the user program (not the other way, which is usual). Shared libraries
// may have undefined symbols, expecting that the user program provides
// the definitions for them. An example is BSD's __progname symbol.
// We need to put such symbols to the main program's .dynsym so that
// shared libraries can find them.
// Except this, we ignore undefined symbols in DSOs.
template <class ELFT> void SymbolTable<ELFT>::scanShlibUndefined() {
  for (SharedFile<ELFT> *File : SharedFiles)
    for (StringRef U : File->getUndefinedSymbols())
      if (SymbolBody *Sym = find(U))
        if (Sym->isDefined())
          Sym->symbol()->ExportDynamic = true;
}

// Initialize DemangledSyms with a map from demangled symbols to symbol
// objects. Used to handle "extern C++" directive in version scripts.
//
// The map will contain all demangled symbols. That can be very large,
// and in LLD we generally want to avoid do anything for each symbol.
// Then, why are we doing this? Here's why.
//
// Users can use "extern C++ {}" directive to match against demangled
// C++ symbols. For example, you can write a pattern such as
// "llvm::*::foo(int, ?)". Obviously, there's no way to handle this
// other than trying to match a pattern against all demangled symbols.
// So, if "extern C++" feature is used, we need to demangle all known
// symbols.
template <class ELFT>
StringMap<std::vector<SymbolBody *>> &SymbolTable<ELFT>::getDemangledSyms() {
  if (!DemangledSyms) {
    DemangledSyms.emplace();
    for (Symbol *Sym : SymVector) {
      SymbolBody *B = Sym->body();
      if (B->isUndefined())
        continue;
      if (Optional<std::string> S = demangle(B->getName()))
        (*DemangledSyms)[*S].push_back(B);
      else
        (*DemangledSyms)[B->getName()].push_back(B);
    }
  }
  return *DemangledSyms;
}

template <class ELFT>
std::vector<SymbolBody *> SymbolTable<ELFT>::findByVersion(SymbolVersion Ver) {
  if (Ver.IsExternCpp)
    return getDemangledSyms().lookup(Ver.Name);
  if (SymbolBody *B = find(Ver.Name))
    if (!B->isUndefined())
      return {B};
  return {};
}

template <class ELFT>
std::vector<SymbolBody *>
SymbolTable<ELFT>::findAllByVersion(SymbolVersion Ver) {
  std::vector<SymbolBody *> Res;
  StringMatcher M(Ver.Name);

  if (Ver.IsExternCpp) {
    for (auto &P : getDemangledSyms())
      if (M.match(P.first()))
        Res.insert(Res.end(), P.second.begin(), P.second.end());
    return Res;
  }

  for (Symbol *Sym : SymVector) {
    SymbolBody *B = Sym->body();
    if (!B->isUndefined() && M.match(B->getName()))
      Res.push_back(B);
  }
  return Res;
}

// If there's only one anonymous version definition in a version
// script file, the script does not actually define any symbol version,
// but just specifies symbols visibilities.
template <class ELFT> void SymbolTable<ELFT>::handleAnonymousVersion() {
  for (SymbolVersion &Ver : Config->VersionScriptGlobals)
    assignExactVersion(Ver, VER_NDX_GLOBAL, "global");
  for (SymbolVersion &Ver : Config->VersionScriptGlobals)
    assignWildcardVersion(Ver, VER_NDX_GLOBAL);
  for (SymbolVersion &Ver : Config->VersionScriptLocals)
    assignExactVersion(Ver, VER_NDX_LOCAL, "local");
  for (SymbolVersion &Ver : Config->VersionScriptLocals)
    assignWildcardVersion(Ver, VER_NDX_LOCAL);
}

// Set symbol versions to symbols. This function handles patterns
// containing no wildcard characters.
template <class ELFT>
void SymbolTable<ELFT>::assignExactVersion(SymbolVersion Ver, uint16_t VersionId,
                                           StringRef VersionName) {
  if (Ver.HasWildcard)
    return;

  // Get a list of symbols which we need to assign the version to.
  std::vector<SymbolBody *> Syms = findByVersion(Ver);
  if (Syms.empty()) {
    if (Config->NoUndefinedVersion)
      error("version script assignment of '" + VersionName + "' to symbol '" +
            Ver.Name + "' failed: symbol not defined");
    return;
  }

  // Assign the version.
  for (SymbolBody *B : Syms) {
    Symbol *Sym = B->symbol();
    if (Sym->InVersionScript)
      warn("duplicate symbol '" + Ver.Name + "' in version script");
    Sym->VersionId = VersionId;
    Sym->InVersionScript = true;
  }
}

template <class ELFT>
void SymbolTable<ELFT>::assignWildcardVersion(SymbolVersion Ver,
                                              uint16_t VersionId) {
  if (!Ver.HasWildcard)
    return;
  std::vector<SymbolBody *> Syms = findAllByVersion(Ver);

  // Exact matching takes precendence over fuzzy matching,
  // so we set a version to a symbol only if no version has been assigned
  // to the symbol. This behavior is compatible with GNU.
  for (SymbolBody *B : Syms)
    if (B->symbol()->VersionId == Config->DefaultSymbolVersion)
      B->symbol()->VersionId = VersionId;
}

// This function processes version scripts by updating VersionId
// member of symbols.
template <class ELFT> void SymbolTable<ELFT>::scanVersionScript() {
  // Symbol themselves might know their versions because symbols
  // can contain versions in the form of <name>@@<version>.
  // Let them parse their names.
  if (!Config->VersionDefinitions.empty())
    for (Symbol *Sym : SymVector)
      Sym->body()->parseSymbolVersion();

  // Handle edge cases first.
  handleAnonymousVersion();

  if (Config->VersionDefinitions.empty())
    return;

  // Now we have version definitions, so we need to set version ids to symbols.
  // Each version definition has a glob pattern, and all symbols that match
  // with the pattern get that version.

  // First, we assign versions to exact matching symbols,
  // i.e. version definitions not containing any glob meta-characters.
  for (VersionDefinition &V : Config->VersionDefinitions)
    for (SymbolVersion &Ver : V.Globals)
      assignExactVersion(Ver, V.Id, V.Name);

  // Next, we assign versions to fuzzy matching symbols,
  // i.e. version definitions containing glob meta-characters.
  // Note that because the last match takes precedence over previous matches,
  // we iterate over the definitions in the reverse order.
  for (VersionDefinition &V : llvm::reverse(Config->VersionDefinitions))
    for (SymbolVersion &Ver : V.Globals)
      assignWildcardVersion(Ver, V.Id);
}

template class elf::SymbolTable<ELF32LE>;
template class elf::SymbolTable<ELF32BE>;
template class elf::SymbolTable<ELF64LE>;
template class elf::SymbolTable<ELF64BE>;
@


1.1
log
@Initial revision
@
text
@d21 1
a21 2
#include "Strings.h"
#include "SymbolListFile.h"
d23 1
a23 2
#include "llvm/Bitcode/ReaderWriter.h"
#include "llvm/Support/StringSaver.h"
d38 12
a49 7
  if (F->EKind == Config->EKind && F->EMachine == Config->EMachine)
    return true;
  StringRef A = F->getName();
  StringRef B = Config->Emulation;
  if (B.empty())
    B = Config->FirstElf->getName();
  error(A + " is incompatible with " + B);
d54 8
a61 4
template <class ELFT>
void SymbolTable<ELFT>::addFile(std::unique_ptr<InputFile> File) {
  InputFile *FileP = File.get();
  if (!isCompatible<ELFT>(FileP))
d63 1
d66 1
a66 2
  if (auto *F = dyn_cast<ArchiveFile>(FileP)) {
    ArchiveFiles.emplace_back(cast<ArchiveFile>(File.release()));
d72 1
a72 2
  if (auto *F = dyn_cast<LazyObjectFile>(FileP)) {
    LazyObjectFiles.emplace_back(cast<LazyObjectFile>(File.release()));
d78 1
a78 1
    outs() << getFilename(FileP) << "\n";
d81 1
a81 1
  if (auto *F = dyn_cast<SharedFile<ELFT>>(FileP)) {
d84 1
a84 1
    if (!SoNames.insert(F->getSoName()).second)
d86 1
a86 2

    SharedFiles.emplace_back(cast<SharedFile<ELFT>>(File.release()));
d92 2
a93 2
  if (auto *F = dyn_cast<BitcodeFile>(FileP)) {
    BitcodeFiles.emplace_back(cast<BitcodeFile>(File.release()));
d99 2
a100 2
  auto *F = cast<ObjectFile<ELFT>>(FileP);
  ObjectFiles.emplace_back(cast<ObjectFile<ELFT>>(File.release()));
d111 1
a111 1
template <class ELFT> void SymbolTable<ELFT>::addCombinedLtoObject() {
d115 8
a122 11
  // Compile bitcode files.
  Lto.reset(new BitcodeCompiler);
  for (const std::unique_ptr<BitcodeFile> &F : BitcodeFiles)
    Lto->add(*F);
  std::vector<std::unique_ptr<InputFile>> IFs = Lto->compile();

  // Replace bitcode symbols.
  for (auto &IF : IFs) {
    ObjectFile<ELFT> *Obj = cast<ObjectFile<ELFT>>(IF.release());

    DenseSet<StringRef> DummyGroups;
d124 1
a124 1
    ObjectFiles.emplace_back(Obj);
d130 5
a134 3
                                                     uint8_t Visibility) {
  return cast<DefinedRegular<ELFT>>(
      addRegular(Name, STB_GLOBAL, Visibility)->body());
d142 2
a143 1
  if (!find(Name))
d145 6
d157 1
a157 1
  Symtab.insert({Name, {-1, true}});
a165 1
  StringSaver Saver(Alloc);
d169 1
d188 2
a189 1
  auto P = Symtab.insert({Name, {(int)SymVector.size(), false}});
d195 1
a195 1
    V = {(int)SymVector.size(), true};
d200 2
a201 1
    Sym = new (Alloc) Symbol;
d206 1
a207 1
    Sym->Traced = V.Traced;
d215 7
d227 2
a228 2
                          bool CanOmitFromDynSym, bool IsUsedInRegularObj,
                          InputFile *File) {
d241 1
a241 2
    error("TLS attribute mismatch for symbol: " +
          conflictMsg(S->body(), File));
a245 12
// Construct a string in the form of "Sym in File1 and File2".
// Used to construct an error message.
template <typename ELFT>
std::string SymbolTable<ELFT>::conflictMsg(SymbolBody *Existing,
                                           InputFile *NewFile) {
  std::string Sym = Existing->getName();
  if (Config->Demangle)
    Sym = demangle(Sym);
  return Sym + " in " + getFilename(Existing->File) + " and " +
         getFilename(NewFile);
}

d247 2
a248 1
  return addUndefined(Name, STB_GLOBAL, STV_DEFAULT, /*Type*/ 0,
d252 2
d255 3
a257 3
Symbol *SymbolTable<ELFT>::addUndefined(StringRef Name, uint8_t Binding,
                                        uint8_t StOther, uint8_t Type,
                                        bool CanOmitFromDynSym,
d262 1
a262 2
      insert(Name, Type, StOther & 3, CanOmitFromDynSym,
             /*IsUsedInRegularObj*/ !File || !isa<BitcodeFile>(File), File);
d265 1
a265 1
    replaceBody<Undefined>(S, Name, StOther, Type, File);
d279 2
a280 2
    else if (auto F = L->fetch())
      addFile(std::move(F));
d292 1
a292 1
  if (Body->isLazy() || Body->isUndefined() || Body->isShared())
d304 3
a306 1
static int compareDefinedNonCommon(Symbol *S, bool WasInserted, uint8_t Binding) {
d312 2
a313 1
  if (isa<DefinedCommon>(S->body())) {
d316 1
a316 1
      warning("common " + S->body()->getName() + " is overridden");
d318 4
d333 2
a334 3
  std::tie(S, WasInserted) =
      insert(N, Type, StOther & 3, /*CanOmitFromDynSym*/ false,
             /*IsUsedInRegularObj*/ true, File);
d344 1
a344 1
        warning("common " + S->body()->getName() + " is overridden");
d349 1
a349 1
      warning("multiple common of " + S->body()->getName());
d351 3
a353 2
    C->Size = std::max(C->Size, Size);
    C->Alignment = std::max(C->Alignment, Alignment);
d358 1
a358 4
template <class ELFT>
void SymbolTable<ELFT>::reportDuplicate(SymbolBody *Existing,
                                        InputFile *NewFile) {
  std::string Msg = "duplicate symbol: " + conflictMsg(Existing, NewFile);
d360 1
a360 1
    warning(Msg);
d365 19
a383 15
template <typename ELFT>
Symbol *SymbolTable<ELFT>::addRegular(StringRef Name, const Elf_Sym &Sym,
                                      InputSectionBase<ELFT> *Section) {
  Symbol *S;
  bool WasInserted;
  std::tie(S, WasInserted) =
      insert(Name, Sym.getType(), Sym.getVisibility(),
             /*CanOmitFromDynSym*/ false, /*IsUsedInRegularObj*/ true,
             Section ? Section->getFile() : nullptr);
  int Cmp = compareDefinedNonCommon(S, WasInserted, Sym.getBinding());
  if (Cmp > 0)
    replaceBody<DefinedRegular<ELFT>>(S, Name, Sym, Section);
  else if (Cmp == 0)
    reportDuplicate(S->body(), Section->getFile());
  return S;
d387 5
a391 2
Symbol *SymbolTable<ELFT>::addRegular(StringRef Name, uint8_t Binding,
                                      uint8_t StOther) {
d394 4
a397 4
  std::tie(S, WasInserted) =
      insert(Name, STT_NOTYPE, StOther & 3, /*CanOmitFromDynSym*/ false,
             /*IsUsedInRegularObj*/ true, nullptr);
  int Cmp = compareDefinedNonCommon(S, WasInserted, Binding);
d399 2
a400 1
    replaceBody<DefinedRegular<ELFT>>(S, Name, StOther);
d402 1
a402 1
    reportDuplicate(S->body(), nullptr);
d408 2
a409 2
                                        OutputSectionBase<ELFT> *Section,
                                        uintX_t Value) {
d412 4
a415 4
  std::tie(S, WasInserted) =
      insert(N, STT_NOTYPE, STV_HIDDEN, /*CanOmitFromDynSym*/ false,
             /*IsUsedInRegularObj*/ true, nullptr);
  int Cmp = compareDefinedNonCommon(S, WasInserted, STB_GLOBAL);
d417 1
a417 1
    replaceBody<DefinedSynthetic<ELFT>>(S, N, Value, Section);
d433 1
a433 2
      insert(Name, Sym.getType(), STV_DEFAULT, /*CanOmitFromDynSym*/ true,
             /*IsUsedInRegularObj*/ false, F);
d437 1
a437 1
  if (WasInserted || isa<Undefined>(S->body())) {
d445 1
a445 1
Symbol *SymbolTable<ELFT>::addBitcode(StringRef Name, bool IsWeak,
d450 4
a453 4
  std::tie(S, WasInserted) = insert(Name, Type, StOther & 3, CanOmitFromDynSym,
                                    /*IsUsedInRegularObj*/ false, F);
  int Cmp =
      compareDefinedNonCommon(S, WasInserted, IsWeak ? STB_WEAK : STB_GLOBAL);
d455 2
a456 1
    replaceBody<DefinedBitcode>(S, Name, StOther, Type, F);
d463 1
a463 1
  auto It = Symtab.find(Name);
a471 1
// Returns a list of defined symbols that match with a given glob pattern.
d473 5
a477 8
std::vector<SymbolBody *> SymbolTable<ELFT>::findAll(StringRef Pattern) {
  std::vector<SymbolBody *> Res;
  for (Symbol *Sym : SymVector) {
    SymbolBody *B = Sym->body();
    if (!B->isUndefined() && globMatch(Pattern, B->getName()))
      Res.push_back(B);
  }
  return Res;
d485 2
a486 1
  std::tie(S, WasInserted) = insert(Sym.getName());
d505 3
a507 3
  MemoryBufferRef MBRef = F->getMember(&Sym);
  if (!MBRef.getBuffer().empty())
    addFile(createObjectFile(MBRef, F->getName()));
d536 2
a537 2
      if (std::unique_ptr<InputFile> File = L->fetch())
        addFile(std::move(File));
d548 1
a548 1
  for (std::unique_ptr<SharedFile<ELFT>> &File : SharedFiles)
d555 28
a582 6
// This function process the dynamic list option by marking all the symbols
// to be exported in the dynamic table.
template <class ELFT> void SymbolTable<ELFT>::scanDynamicList() {
  for (StringRef S : Config->DynamicList)
    if (SymbolBody *B = find(S))
      B->symbol()->ExportDynamic = true;
d585 8
a592 2
static bool hasWildcard(StringRef S) {
  return S.find_first_of("?*") != StringRef::npos;
d595 11
a605 7
static void setVersionId(SymbolBody *Body, StringRef VersionName,
                         StringRef Name, uint16_t Version) {
  if (!Body || Body->isUndefined()) {
    if (Config->NoUndefinedVersion)
      error("version script assignment of " + VersionName + " to symbol " +
            Name + " failed: symbol not defined");
    return;
a607 9
  Symbol *Sym = Body->symbol();
  if (Sym->VersionId != Config->DefaultSymbolVersion)
    warning("duplicate symbol " + Name + " in version script");
  Sym->VersionId = Version;
}

template <class ELFT>
std::map<std::string, SymbolBody *> SymbolTable<ELFT>::getDemangledSyms() {
  std::map<std::string, SymbolBody *> Result;
d610 2
a611 1
    Result[demangle(B->getName())] = B;
d613 1
a613 1
  return Result;
d616 30
a645 7
static bool hasExternCpp() {
  for (VersionDefinition &V : Config->VersionDefinitions)
    for (SymbolVersion Sym : V.Globals)
      if (Sym.IsExternCpp)
        return true;
  return false;
}
d647 7
a653 11
// This function processes the --version-script option by marking all global
// symbols with the VersionScriptGlobal flag, which acts as a filter on the
// dynamic symbol table.
template <class ELFT> void SymbolTable<ELFT>::scanVersionScript() {
  // If version script does not contain versions declarations,
  // we just should mark global symbols.
  if (!Config->VersionScriptGlobals.empty()) {
    for (SymbolVersion &Sym : Config->VersionScriptGlobals)
      if (SymbolBody *B = find(Sym.Name))
        B->symbol()->VersionId = VER_NDX_GLOBAL;
    return;
d655 1
d657 4
a660 1
  if (Config->VersionDefinitions.empty())
d662 1
d664 7
a670 22
  // If we have symbols version declarations, we should
  // assign version references for each symbol.
  // Current rules are:
  // * If there is an exact match for the mangled name or we have extern C++
  //   exact match, then we use it.
  // * Otherwise, we look through the wildcard patterns. We look through the
  //   version tags in reverse order. We use the first match we find (the last
  //   matching version tag in the file).
  // Handle exact matches and build a map of demangled externs for
  // quick search during next step.
  std::map<std::string, SymbolBody *> Demangled;
  if (hasExternCpp())
    Demangled = getDemangledSyms();

  for (VersionDefinition &V : Config->VersionDefinitions) {
    for (SymbolVersion Sym : V.Globals) {
      if (hasWildcard(Sym.Name))
        continue;
      SymbolBody *B = Sym.IsExternCpp ? Demangled[Sym.Name] : find(Sym.Name);
      setVersionId(B, V.Name, Sym.Name, V.Id);
    }
  }
d672 9
a680 10
  // Handle wildcards.
  for (size_t I = Config->VersionDefinitions.size() - 1; I != (size_t)-1; --I) {
    VersionDefinition &V = Config->VersionDefinitions[I];
    for (SymbolVersion &Sym : V.Globals)
      if (hasWildcard(Sym.Name))
        for (SymbolBody *B : findAll(Sym.Name))
          if (B->symbol()->VersionId == Config->DefaultSymbolVersion)
            B->symbol()->VersionId = V.Id;
  }
}
d682 2
a683 7
// Returns the size of the longest version name.
static int getMaxVersionLen() {
  size_t Len = 0;
  for (VersionDefinition &V : Config->VersionDefinitions)
    Len = std::max(Len, V.Name.size());
  return Len;
}
a684 39
// Parses a symbol name in the form of <name>@@<version> or <name>@@@@<version>.
static std::pair<StringRef, uint16_t>
getSymbolVersion(SymbolBody *B, int MaxVersionLen) {
  StringRef S = B->getName();

  // MaxVersionLen was passed so that we don't need to scan
  // all characters in a symbol name. It is effective because
  // versions are usually short and symbol names can be very long.
  size_t Pos = S.find('@@', std::max(0, int(S.size()) - MaxVersionLen - 2));
  if (Pos == 0 || Pos == StringRef::npos)
    return {"", 0};

  StringRef Name = S.substr(0, Pos);
  StringRef Verstr = S.substr(Pos + 1);
  if (Verstr.empty())
    return {"", 0};

  // '@@@@' in a symbol name means the default version.
  // It is usually the most recent one.
  bool IsDefault = (Verstr[0] == '@@');
  if (IsDefault)
    Verstr = Verstr.substr(1);

  for (VersionDefinition &V : Config->VersionDefinitions) {
    if (V.Name == Verstr)
      return {Name, IsDefault ? V.Id : (V.Id | VERSYM_HIDDEN)};
  }

  // It is an error if the specified version was not defined.
  error("symbol " + S + " has undefined version " + Verstr);
  return {"", 0};
}

// Versions are usually assigned to symbols using version scripts,
// but there's another way to assign versions to symbols.
// If a symbol name contains '@@', the string after it is not
// actually a part of the symbol name but specifies a version.
// This function takes care of it.
template <class ELFT> void SymbolTable<ELFT>::scanSymbolVersions() {
d688 3
a690 1
  int MaxVersionLen = getMaxVersionLen();
d692 5
a696 20
  // Unfortunately there's no way other than iterating over all
  // symbols to look for '@@' characters in symbol names.
  // So this is inherently slow. A good news is that we do this
  // only when versions have been defined.
  for (Symbol *Sym : SymVector) {
    // Symbol versions for exported symbols are by nature
    // only for defined global symbols.
    SymbolBody *B = Sym->body();
    if (!B->isDefined())
      continue;
    uint8_t Visibility = B->getVisibility();
    if (Visibility != STV_DEFAULT && Visibility != STV_PROTECTED)
      continue;

    // Look for '@@' in the symbol name.
    StringRef Name;
    uint16_t Version;
    std::tie(Name, Version) = getSymbolVersion(B, MaxVersionLen);
    if (Name.empty())
      continue;
d698 7
a704 3
    B->setName(Name);
    Sym->VersionId = Version;
  }
@


1.1.1.1
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d21 2
a22 1
#include "Memory.h"
d24 2
a25 1
#include "llvm/ADT/STLExtras.h"
d40 7
a46 12

  if (F->EKind == Config->EKind && F->EMachine == Config->EMachine) {
    if (Config->EMachine != EM_MIPS)
      return true;
    if (isMipsN32Abi(F) == Config->MipsN32Abi)
      return true;
  }

  if (!Config->Emulation.empty())
    error(toString(F) + " is incompatible with " + Config->Emulation);
  else
    error(toString(F) + " is incompatible with " + toString(Config->FirstElf));
d51 4
a54 2
template <class ELFT> void SymbolTable<ELFT>::addFile(InputFile *File) {
  if (!isCompatible<ELFT>(File))
a56 7
  // Binary file
  if (auto *F = dyn_cast<BinaryFile>(File)) {
    BinaryFiles.push_back(F);
    F->parse<ELFT>();
    return;
  }

d58 2
a59 1
  if (auto *F = dyn_cast<ArchiveFile>(File)) {
d65 2
a66 1
  if (auto *F = dyn_cast<LazyObjectFile>(File)) {
d72 1
a72 1
    outs() << toString(File) << "\n";
d75 1
a75 1
  if (auto *F = dyn_cast<SharedFile<ELFT>>(File)) {
d78 1
a78 1
    if (ErrorCount || !SoNames.insert(F->getSoName()).second)
d80 2
a81 1
    SharedFiles.push_back(F);
d87 2
a88 2
  if (auto *F = dyn_cast<BitcodeFile>(File)) {
    BitcodeFiles.push_back(F);
d94 2
a95 2
  auto *F = cast<ObjectFile<ELFT>>(File);
  ObjectFiles.push_back(F);
d106 1
a106 1
template <class ELFT> void SymbolTable<ELFT>::addCombinedLTOObject() {
d110 11
a120 8
  // Compile bitcode files and replace bitcode symbols.
  LTO.reset(new BitcodeCompiler);
  for (BitcodeFile *F : BitcodeFiles)
    LTO->add<ELFT>(*F);

  for (InputFile *File : LTO->compile()) {
    ObjectFile<ELFT> *Obj = cast<ObjectFile<ELFT>>(File);
    DenseSet<CachedHashStringRef> DummyGroups;
d122 1
a122 1
    ObjectFiles.push_back(Obj);
d128 3
a130 5
                                                     uint8_t Visibility,
                                                     uint8_t Binding) {
  Symbol *Sym =
      addRegular(Name, Visibility, STT_NOTYPE, 0, 0, Binding, nullptr, nullptr);
  return cast<DefinedRegular<ELFT>>(Sym->body());
d138 1
a138 2
  SymbolBody *S = find(Name);
  if (!S || !S->isUndefined())
d146 1
a146 1
  Symtab.insert({CachedHashStringRef(Name), {-1, true}});
d155 1
a158 1

d177 1
a177 2
  auto P = Symtab.insert(
      {CachedHashStringRef(Name), SymIndex((int)SymVector.size(), false)});
d183 1
a183 1
    V = SymIndex((int)SymVector.size(), true);
d188 1
a188 2
    Sym = new (BAlloc) Symbol;
    Sym->InVersionScript = false;
d193 1
a194 1
    Sym->VersionId = Config->DefaultSymbolVersion;
a201 7
// Construct a string in the form of "Sym in File1 and File2".
// Used to construct an error message.
static std::string conflictMsg(SymbolBody *Existing, InputFile *NewFile) {
  return "'" + toString(*Existing) + "' in " + toString(Existing->File) +
         " and " + toString(NewFile);
}

d207 2
a208 2
                          bool CanOmitFromDynSym, InputFile *File) {
  bool IsUsedInRegularObj = !File || File->kind() == InputFile::ObjectKind;
d221 2
a222 1
    error("TLS attribute mismatch for symbol " + conflictMsg(S->body(), File));
d227 12
d240 1
a240 2
  return addUndefined(Name, /*IsLocal=*/false, STB_GLOBAL, STV_DEFAULT,
                      /*Type*/ 0,
a243 2
static uint8_t getVisibility(uint8_t StOther) { return StOther & 3; }

d245 3
a247 3
Symbol *SymbolTable<ELFT>::addUndefined(StringRef Name, bool IsLocal,
                                        uint8_t Binding, uint8_t StOther,
                                        uint8_t Type, bool CanOmitFromDynSym,
d252 2
a253 1
      insert(Name, Type, getVisibility(StOther), CanOmitFromDynSym, File);
d256 1
a256 1
    replaceBody<Undefined<ELFT>>(S, Name, IsLocal, StOther, Type, File);
d270 2
a271 2
    else if (InputFile *F = L->fetch())
      addFile(F);
d295 1
a295 3
template <typename ELFT>
static int compareDefinedNonCommon(Symbol *S, bool WasInserted, uint8_t Binding,
                                   bool IsAbsolute, typename ELFT::uint Value) {
d301 1
a301 2
  SymbolBody *B = S->body();
  if (isa<DefinedCommon>(B)) {
d304 1
a304 1
      warn("common " + S->body()->getName() + " is overridden");
a305 4
  } else if (auto *R = dyn_cast<DefinedRegular<ELFT>>(B)) {
    if (R->Section == nullptr && Binding == STB_GLOBAL && IsAbsolute &&
        R->Value == Value)
      return -1;
d317 3
a319 2
  std::tie(S, WasInserted) = insert(N, Type, getVisibility(StOther),
                                    /*CanOmitFromDynSym*/ false, File);
d329 1
a329 1
        warn("common " + S->body()->getName() + " is overridden");
d334 1
a334 1
      warn("multiple common of " + S->body()->getName());
d336 2
a337 3
    Alignment = C->Alignment = std::max(C->Alignment, Alignment);
    if (Size > C->Size)
      replaceBody<DefinedCommon>(S, N, Size, Alignment, StOther, Type, File);
d342 4
a345 1
static void print(const Twine &Msg) {
d347 1
a347 1
    warn(Msg);
d352 15
a366 19
static void reportDuplicate(SymbolBody *Existing, InputFile *NewFile) {
  print("duplicate symbol " + conflictMsg(Existing, NewFile));
}

template <class ELFT>
static void reportDuplicate(SymbolBody *Existing,
                            InputSectionBase<ELFT> *ErrSec,
                            typename ELFT::uint ErrOffset) {
  DefinedRegular<ELFT> *D = dyn_cast<DefinedRegular<ELFT>>(Existing);
  if (!D || !D->Section || !ErrSec) {
    reportDuplicate(Existing, ErrSec ? ErrSec->getFile() : nullptr);
    return;
  }

  std::string OldLoc = D->Section->getLocation(D->Value);
  std::string NewLoc = ErrSec->getLocation(ErrOffset);

  print(NewLoc + ": duplicate symbol '" + toString(*Existing) + "'");
  print(OldLoc + ": previous definition was here");
d370 2
a371 5
Symbol *SymbolTable<ELFT>::addRegular(StringRef Name, uint8_t StOther,
                                      uint8_t Type, uintX_t Value, uintX_t Size,
                                      uint8_t Binding,
                                      InputSectionBase<ELFT> *Section,
                                      InputFile *File) {
d374 4
a377 4
  std::tie(S, WasInserted) = insert(Name, Type, getVisibility(StOther),
                                    /*CanOmitFromDynSym*/ false, File);
  int Cmp = compareDefinedNonCommon<ELFT>(S, WasInserted, Binding,
                                          Section == nullptr, Value);
d379 1
a379 2
    replaceBody<DefinedRegular<ELFT>>(S, Name, /*IsLocal=*/false, StOther, Type,
                                      Value, Size, Section, File);
d381 1
a381 1
    reportDuplicate(S->body(), Section, Value);
d387 2
a388 2
                                        const OutputSectionBase *Section,
                                        uintX_t Value, uint8_t StOther) {
d391 4
a394 4
  std::tie(S, WasInserted) = insert(N, STT_NOTYPE, getVisibility(StOther),
                                    /*CanOmitFromDynSym*/ false, nullptr);
  int Cmp = compareDefinedNonCommon<ELFT>(S, WasInserted, STB_GLOBAL,
                                          /*IsAbsolute*/ false, /*Value*/ 0);
d396 1
a396 1
    replaceBody<DefinedSynthetic>(S, N, Value, Section);
d412 2
a413 1
      insert(Name, Sym.getType(), STV_DEFAULT, /*CanOmitFromDynSym*/ true, F);
d417 1
a417 1
  if (WasInserted || isa<Undefined<ELFT>>(S->body())) {
d425 1
a425 1
Symbol *SymbolTable<ELFT>::addBitcode(StringRef Name, uint8_t Binding,
d430 4
a433 4
  std::tie(S, WasInserted) =
      insert(Name, Type, getVisibility(StOther), CanOmitFromDynSym, F);
  int Cmp = compareDefinedNonCommon<ELFT>(S, WasInserted, Binding,
                                          /*IsAbs*/ false, /*Value*/ 0);
d435 1
a435 2
    replaceBody<DefinedRegular<ELFT>>(S, Name, /*IsLocal=*/false, StOther, Type,
                                      0, 0, nullptr, F);
d442 1
a442 1
  auto It = Symtab.find(CachedHashStringRef(Name));
d451 12
d468 1
a468 2
  StringRef Name = Sym.getName();
  std::tie(S, WasInserted) = insert(Name);
d487 3
a489 3
  std::pair<MemoryBufferRef, uint64_t> MBInfo = F->getMember(&Sym);
  if (!MBInfo.first.getBuffer().empty())
    addFile(createObjectFile(MBInfo.first, F->getName(), MBInfo.second));
d518 2
a519 2
      if (InputFile *File = L->fetch())
        addFile(File);
d530 1
a530 1
  for (SharedFile<ELFT> *File : SharedFiles)
d537 6
a542 28
// Initialize DemangledSyms with a map from demangled symbols to symbol
// objects. Used to handle "extern C++" directive in version scripts.
//
// The map will contain all demangled symbols. That can be very large,
// and in LLD we generally want to avoid do anything for each symbol.
// Then, why are we doing this? Here's why.
//
// Users can use "extern C++ {}" directive to match against demangled
// C++ symbols. For example, you can write a pattern such as
// "llvm::*::foo(int, ?)". Obviously, there's no way to handle this
// other than trying to match a pattern against all demangled symbols.
// So, if "extern C++" feature is used, we need to demangle all known
// symbols.
template <class ELFT>
StringMap<std::vector<SymbolBody *>> &SymbolTable<ELFT>::getDemangledSyms() {
  if (!DemangledSyms) {
    DemangledSyms.emplace();
    for (Symbol *Sym : SymVector) {
      SymbolBody *B = Sym->body();
      if (B->isUndefined())
        continue;
      if (Optional<std::string> S = demangle(B->getName()))
        (*DemangledSyms)[*S].push_back(B);
      else
        (*DemangledSyms)[B->getName()].push_back(B);
    }
  }
  return *DemangledSyms;
d545 2
a546 8
template <class ELFT>
std::vector<SymbolBody *> SymbolTable<ELFT>::findByVersion(SymbolVersion Ver) {
  if (Ver.IsExternCpp)
    return getDemangledSyms().lookup(Ver.Name);
  if (SymbolBody *B = find(Ver.Name))
    if (!B->isUndefined())
      return {B};
  return {};
d549 8
a556 5
template <class ELFT>
std::vector<SymbolBody *>
SymbolTable<ELFT>::findAllByVersion(SymbolVersion Ver) {
  std::vector<SymbolBody *> Res;
  StringMatcher M(Ver.Name);
d558 5
a562 6
  if (Ver.IsExternCpp) {
    for (auto &P : getDemangledSyms())
      if (M.match(P.first()))
        Res.insert(Res.end(), P.second.begin(), P.second.end());
    return Res;
  }
d564 3
d569 1
a569 2
    if (!B->isUndefined() && M.match(B->getName()))
      Res.push_back(B);
d571 9
a579 1
  return Res;
d582 14
a595 28
// If there's only one anonymous version definition in a version
// script file, the script does not actually define any symbol version,
// but just specifies symbols visibilities.
template <class ELFT> void SymbolTable<ELFT>::handleAnonymousVersion() {
  for (SymbolVersion &Ver : Config->VersionScriptGlobals)
    assignExactVersion(Ver, VER_NDX_GLOBAL, "global");
  for (SymbolVersion &Ver : Config->VersionScriptGlobals)
    assignWildcardVersion(Ver, VER_NDX_GLOBAL);
  for (SymbolVersion &Ver : Config->VersionScriptLocals)
    assignExactVersion(Ver, VER_NDX_LOCAL, "local");
  for (SymbolVersion &Ver : Config->VersionScriptLocals)
    assignWildcardVersion(Ver, VER_NDX_LOCAL);
}

// Set symbol versions to symbols. This function handles patterns
// containing no wildcard characters.
template <class ELFT>
void SymbolTable<ELFT>::assignExactVersion(SymbolVersion Ver, uint16_t VersionId,
                                           StringRef VersionName) {
  if (Ver.HasWildcard)
    return;

  // Get a list of symbols which we need to assign the version to.
  std::vector<SymbolBody *> Syms = findByVersion(Ver);
  if (Syms.empty()) {
    if (Config->NoUndefinedVersion)
      error("version script assignment of '" + VersionName + "' to symbol '" +
            Ver.Name + "' failed: symbol not defined");
d597 22
d621 8
a628 7
  // Assign the version.
  for (SymbolBody *B : Syms) {
    Symbol *Sym = B->symbol();
    if (Sym->InVersionScript)
      warn("duplicate symbol '" + Ver.Name + "' in version script");
    Sym->VersionId = VersionId;
    Sym->InVersionScript = true;
d632 6
a637 13
template <class ELFT>
void SymbolTable<ELFT>::assignWildcardVersion(SymbolVersion Ver,
                                              uint16_t VersionId) {
  if (!Ver.HasWildcard)
    return;
  std::vector<SymbolBody *> Syms = findAllByVersion(Ver);

  // Exact matching takes precendence over fuzzy matching,
  // so we set a version to a symbol only if no version has been assigned
  // to the symbol. This behavior is compatible with GNU.
  for (SymbolBody *B : Syms)
    if (B->symbol()->VersionId == Config->DefaultSymbolVersion)
      B->symbol()->VersionId = VersionId;
d640 39
a678 13
// This function processes version scripts by updating VersionId
// member of symbols.
template <class ELFT> void SymbolTable<ELFT>::scanVersionScript() {
  // Symbol themselves might know their versions because symbols
  // can contain versions in the form of <name>@@<version>.
  // Let them parse their names.
  if (!Config->VersionDefinitions.empty())
    for (Symbol *Sym : SymVector)
      Sym->body()->parseSymbolVersion();

  // Handle edge cases first.
  handleAnonymousVersion();

d682 1
a682 3
  // Now we have version definitions, so we need to set version ids to symbols.
  // Each version definition has a glob pattern, and all symbols that match
  // with the pattern get that version.
d684 20
a703 5
  // First, we assign versions to exact matching symbols,
  // i.e. version definitions not containing any glob meta-characters.
  for (VersionDefinition &V : Config->VersionDefinitions)
    for (SymbolVersion &Ver : V.Globals)
      assignExactVersion(Ver, V.Id, V.Name);
d705 3
a707 7
  // Next, we assign versions to fuzzy matching symbols,
  // i.e. version definitions containing glob meta-characters.
  // Note that because the last match takes precedence over previous matches,
  // we iterate over the definitions in the reverse order.
  for (VersionDefinition &V : llvm::reverse(Config->VersionDefinitions))
    for (SymbolVersion &Ver : V.Globals)
      assignWildcardVersion(Ver, V.Id);
@


1.1.1.3
log
@Import LLVM 4.0.0 release including clang and lld.
@
text
@d143 1
a143 1
  if (!S || S->isInCurrentDSO())
d286 1
a286 1
  if (Body->isLazy() || !Body->isInCurrentDSO())
a463 8
}

template <class ELFT>
SymbolBody *SymbolTable<ELFT>::findInCurrentDSO(StringRef Name) {
  if (SymbolBody *S = find(Name))
    if (S->isInCurrentDSO())
      return S;
  return nullptr;
@


