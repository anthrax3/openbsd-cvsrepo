head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.3.0.2
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.1
date	2017.01.14.19.55.45;	author patrick;	state Exp;
branches
	1.1.1.1;
next	;
commitid	qMUxATnKgqN83Oct;

1.1.1.1
date	2017.01.14.19.55.45;	author patrick;	state Exp;
branches;
next	1.1.1.2;
commitid	qMUxATnKgqN83Oct;

1.1.1.2
date	2017.01.24.08.33.12;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	so2WA7LCP6wbxtYl;

1.1.1.3
date	2017.03.14.08.07.53;	author patrick;	state Exp;
branches;
next	;
commitid	aUi5NxOzBSLCN5eN;


desc
@@


1.1
log
@Initial revision
@
text
@//===- SymbolTable.h --------------------------------------------*- C++ -*-===//
//
//                             The LLVM Linker
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef LLD_ELF_SYMBOL_TABLE_H
#define LLD_ELF_SYMBOL_TABLE_H

#include "InputFiles.h"
#include "LTO.h"
#include "llvm/ADT/DenseMap.h"

namespace lld {
namespace elf {
class Lazy;
template <class ELFT> class OutputSectionBase;
struct Symbol;

typedef llvm::CachedHash<StringRef> SymName;

// SymbolTable is a bucket of all known symbols, including defined,
// undefined, or lazy symbols (the last one is symbols in archive
// files whose archive members are not yet loaded).
//
// We put all symbols of all files to a SymbolTable, and the
// SymbolTable selects the "best" symbols if there are name
// conflicts. For example, obviously, a defined symbol is better than
// an undefined symbol. Or, if there's a conflict between a lazy and a
// undefined, it'll read an archive member to read a real definition
// to replace the lazy symbol. The logic is implemented in the
// add*() functions, which are called by input files as they are parsed. There
// is one add* function per symbol type.
template <class ELFT> class SymbolTable {
  typedef typename ELFT::Sym Elf_Sym;
  typedef typename ELFT::uint uintX_t;

public:
  void addFile(std::unique_ptr<InputFile> File);
  void addCombinedLtoObject();

  llvm::ArrayRef<Symbol *> getSymbols() const { return SymVector; }

  const std::vector<std::unique_ptr<ObjectFile<ELFT>>> &getObjectFiles() const {
    return ObjectFiles;
  }

  const std::vector<std::unique_ptr<SharedFile<ELFT>>> &getSharedFiles() const {
    return SharedFiles;
  }

  DefinedRegular<ELFT> *addAbsolute(StringRef Name,
                                    uint8_t Visibility = llvm::ELF::STV_HIDDEN);
  DefinedRegular<ELFT> *addIgnored(StringRef Name,
                                   uint8_t Visibility = llvm::ELF::STV_HIDDEN);

  Symbol *addUndefined(StringRef Name);
  Symbol *addUndefined(StringRef Name, uint8_t Binding, uint8_t StOther,
                       uint8_t Type, bool CanOmitFromDynSym, InputFile *File);

  Symbol *addRegular(StringRef Name, const Elf_Sym &Sym,
                     InputSectionBase<ELFT> *Section);
  Symbol *addRegular(StringRef Name, uint8_t Binding, uint8_t StOther);
  Symbol *addSynthetic(StringRef N, OutputSectionBase<ELFT> *Section,
                       uintX_t Value);
  void addShared(SharedFile<ELFT> *F, StringRef Name, const Elf_Sym &Sym,
                 const typename ELFT::Verdef *Verdef);

  void addLazyArchive(ArchiveFile *F, const llvm::object::Archive::Symbol S);
  void addLazyObject(StringRef Name, LazyObjectFile &Obj);
  Symbol *addBitcode(StringRef Name, bool IsWeak, uint8_t StOther, uint8_t Type,
                     bool CanOmitFromDynSym, BitcodeFile *File);

  Symbol *addCommon(StringRef N, uint64_t Size, uint64_t Alignment,
                    uint8_t Binding, uint8_t StOther, uint8_t Type,
                    InputFile *File);

  void scanUndefinedFlags();
  void scanShlibUndefined();
  void scanDynamicList();
  void scanVersionScript();
  void scanSymbolVersions();

  SymbolBody *find(StringRef Name);

  void trace(StringRef Name);
  void wrap(StringRef Name);

private:
  std::vector<SymbolBody *> findAll(StringRef Pattern);
  std::pair<Symbol *, bool> insert(StringRef Name);
  std::pair<Symbol *, bool> insert(StringRef Name, uint8_t Type,
                                   uint8_t Visibility, bool CanOmitFromDynSym,
                                   bool IsUsedInRegularObj, InputFile *File);

  std::string conflictMsg(SymbolBody *Existing, InputFile *NewFile);
  void reportDuplicate(SymbolBody *Existing, InputFile *NewFile);

  std::map<std::string, SymbolBody *> getDemangledSyms();

  struct SymIndex {
    int Idx : 31;
    unsigned Traced : 1;
  };

  // The order the global symbols are in is not defined. We can use an arbitrary
  // order, but it has to be reproducible. That is true even when cross linking.
  // The default hashing of StringRef produces different results on 32 and 64
  // bit systems so we use a map to a vector. That is arbitrary, deterministic
  // but a bit inefficient.
  // FIXME: Experiment with passing in a custom hashing or sorting the symbols
  // once symbol resolution is finished.
  llvm::DenseMap<SymName, SymIndex> Symtab;
  std::vector<Symbol *> SymVector;
  llvm::BumpPtrAllocator Alloc;

  // Comdat groups define "link once" sections. If two comdat groups have the
  // same name, only one of them is linked, and the other is ignored. This set
  // is used to uniquify them.
  llvm::DenseSet<StringRef> ComdatGroups;

  // The symbol table owns all file objects.
  std::vector<std::unique_ptr<ArchiveFile>> ArchiveFiles;
  std::vector<std::unique_ptr<ObjectFile<ELFT>>> ObjectFiles;
  std::vector<std::unique_ptr<LazyObjectFile>> LazyObjectFiles;
  std::vector<std::unique_ptr<SharedFile<ELFT>>> SharedFiles;
  std::vector<std::unique_ptr<BitcodeFile>> BitcodeFiles;

  // Set of .so files to not link the same shared object file more than once.
  llvm::DenseSet<StringRef> SoNames;

  std::unique_ptr<BitcodeCompiler> Lto;
};

template <class ELFT> struct Symtab { static SymbolTable<ELFT> *X; };
template <class ELFT> SymbolTable<ELFT> *Symtab<ELFT>::X;

} // namespace elf
} // namespace lld

#endif
@


1.1.1.1
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a14 2
#include "Strings.h"
#include "llvm/ADT/CachedHashString.h"
d20 1
a20 1
class OutputSectionBase;
d23 2
d42 4
a45 2
  void addFile(InputFile *File);
  void addCombinedLTOObject();
d47 7
a53 4
  ArrayRef<Symbol *> getSymbols() const { return SymVector; }
  ArrayRef<ObjectFile<ELFT> *> getObjectFiles() const { return ObjectFiles; }
  ArrayRef<BinaryFile *> getBinaryFiles() const { return BinaryFiles; }
  ArrayRef<SharedFile<ELFT> *> getSharedFiles() const { return SharedFiles; }
d56 1
a56 2
                                    uint8_t Visibility = llvm::ELF::STV_HIDDEN,
                                    uint8_t Binding = llvm::ELF::STB_GLOBAL);
d61 2
a62 10
  Symbol *addUndefined(StringRef Name, bool IsLocal, uint8_t Binding,
                       uint8_t StOther, uint8_t Type, bool CanOmitFromDynSym,
                       InputFile *File);

  Symbol *addRegular(StringRef Name, uint8_t StOther, uint8_t Type,
                     uintX_t Value, uintX_t Size, uint8_t Binding,
                     InputSectionBase<ELFT> *Section, InputFile *File);

  Symbol *addSynthetic(StringRef N, const OutputSectionBase *Section,
                       uintX_t Value, uint8_t StOther);
d64 5
d74 2
a75 2
  Symbol *addBitcode(StringRef Name, uint8_t Binding, uint8_t StOther,
                     uint8_t Type, bool CanOmitFromDynSym, BitcodeFile *File);
d83 1
d85 1
a91 2
  std::vector<InputSectionBase<ELFT> *> Sections;

d93 1
d97 1
a97 1
                                   InputFile *File);
d99 2
a100 2
  std::vector<SymbolBody *> findByVersion(SymbolVersion Ver);
  std::vector<SymbolBody *> findAllByVersion(SymbolVersion Ver);
d102 1
a102 5
  llvm::StringMap<std::vector<SymbolBody *>> &getDemangledSyms();
  void handleAnonymousVersion();
  void assignExactVersion(SymbolVersion Ver, uint16_t VersionId,
                          StringRef VersionName);
  void assignWildcardVersion(SymbolVersion Ver, uint16_t VersionId);
a104 1
    SymIndex(int Idx, bool Traced) : Idx(Idx), Traced(Traced) {}
d116 1
a116 1
  llvm::DenseMap<llvm::CachedHashStringRef, SymIndex> Symtab;
d118 1
d123 1
a123 1
  llvm::DenseSet<llvm::CachedHashStringRef> ComdatGroups;
d125 6
a130 4
  std::vector<ObjectFile<ELFT> *> ObjectFiles;
  std::vector<SharedFile<ELFT> *> SharedFiles;
  std::vector<BitcodeFile *> BitcodeFiles;
  std::vector<BinaryFile *> BinaryFiles;
d135 1
a135 8
  // A map from demangled symbol names to their symbol objects.
  // This mapping is 1:N because two symbols with different versions
  // can have the same name. We use this map to handle "extern C++ {}"
  // directive in version scripts.
  llvm::Optional<llvm::StringMap<std::vector<SymbolBody *>>> DemangledSyms;

  // For LTO.
  std::unique_ptr<BitcodeCompiler> LTO;
@


1.1.1.3
log
@Import LLVM 4.0.0 release including clang and lld.
@
text
@a84 1
  SymbolBody *findInCurrentDSO(StringRef Name);
@


