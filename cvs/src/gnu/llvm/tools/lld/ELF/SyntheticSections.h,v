head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.3
	OPENBSD_6_2:1.1.1.2.0.2
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.1
date	2017.01.24.08.33.12;	author patrick;	state Exp;
branches
	1.1.1.1;
next	;
commitid	so2WA7LCP6wbxtYl;

1.1.1.1
date	2017.01.24.08.33.12;	author patrick;	state Exp;
branches;
next	1.1.1.2;
commitid	so2WA7LCP6wbxtYl;

1.1.1.2
date	2017.03.14.08.07.53;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	aUi5NxOzBSLCN5eN;

1.1.1.3
date	2017.10.04.20.27.35;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===- SyntheticSection.h ---------------------------------------*- C++ -*-===//
//
//                             The LLVM Linker
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef LLD_ELF_SYNTHETIC_SECTION_H
#define LLD_ELF_SYNTHETIC_SECTION_H

#include "GdbIndex.h"
#include "InputSection.h"
#include "llvm/ADT/MapVector.h"
#include "llvm/MC/StringTableBuilder.h"

namespace lld {
namespace elf {

template <class ELFT> class SyntheticSection : public InputSection<ELFT> {
  typedef typename ELFT::uint uintX_t;

public:
  SyntheticSection(uintX_t Flags, uint32_t Type, uintX_t Addralign,
                   StringRef Name)
      : InputSection<ELFT>(Flags, Type, Addralign, ArrayRef<uint8_t>(), Name,
                           InputSectionData::Synthetic) {
    this->Live = true;
  }

  virtual ~SyntheticSection() = default;
  virtual void writeTo(uint8_t *Buf) = 0;
  virtual size_t getSize() const = 0;
  virtual void finalize() {}
  virtual bool empty() const { return false; }

  uintX_t getVA() const {
    return this->OutSec ? this->OutSec->Addr + this->OutSecOff : 0;
  }

  static bool classof(const InputSectionData *D) {
    return D->kind() == InputSectionData::Synthetic;
  }
};

template <class ELFT> class GotSection final : public SyntheticSection<ELFT> {
  typedef typename ELFT::uint uintX_t;

public:
  GotSection();
  void writeTo(uint8_t *Buf) override;
  size_t getSize() const override { return Size; }
  void finalize() override;
  bool empty() const override;

  void addEntry(SymbolBody &Sym);
  bool addDynTlsEntry(SymbolBody &Sym);
  bool addTlsIndex();
  uintX_t getGlobalDynAddr(const SymbolBody &B) const;
  uintX_t getGlobalDynOffset(const SymbolBody &B) const;

  uintX_t getTlsIndexVA() { return this->getVA() + TlsIndexOff; }
  uint32_t getTlsIndexOff() const { return TlsIndexOff; }

  // Flag to force GOT to be in output if we have relocations
  // that relies on its address.
  bool HasGotOffRel = false;

private:
  size_t NumEntries = 0;
  uint32_t TlsIndexOff = -1;
  uintX_t Size = 0;
};

// .note.gnu.build-id section.
template <class ELFT> class BuildIdSection : public SyntheticSection<ELFT> {
  // First 16 bytes are a header.
  static const unsigned HeaderSize = 16;

public:
  BuildIdSection();
  void writeTo(uint8_t *Buf) override;
  size_t getSize() const override { return HeaderSize + HashSize; }
  void writeBuildId(llvm::ArrayRef<uint8_t> Buf);

private:
  void computeHash(llvm::ArrayRef<uint8_t> Buf,
                   std::function<void(uint8_t *, ArrayRef<uint8_t>)> Hash);

  size_t HashSize;
  uint8_t *HashBuf;
};

template <class ELFT>
class MipsGotSection final : public SyntheticSection<ELFT> {
  typedef typename ELFT::uint uintX_t;

public:
  MipsGotSection();
  void writeTo(uint8_t *Buf) override;
  size_t getSize() const override { return Size; }
  void finalize() override;
  bool empty() const override;
  void addEntry(SymbolBody &Sym, uintX_t Addend, RelExpr Expr);
  bool addDynTlsEntry(SymbolBody &Sym);
  bool addTlsIndex();
  uintX_t getPageEntryOffset(const SymbolBody &B, uintX_t Addend) const;
  uintX_t getBodyEntryOffset(const SymbolBody &B, uintX_t Addend) const;
  uintX_t getGlobalDynOffset(const SymbolBody &B) const;

  // Returns the symbol which corresponds to the first entry of the global part
  // of GOT on MIPS platform. It is required to fill up MIPS-specific dynamic
  // table properties.
  // Returns nullptr if the global part is empty.
  const SymbolBody *getFirstGlobalEntry() const;

  // Returns the number of entries in the local part of GOT including
  // the number of reserved entries.
  unsigned getLocalEntriesNum() const;

  // Returns offset of TLS part of the MIPS GOT table. This part goes
  // after 'local' and 'global' entries.
  uintX_t getTlsOffset() const;

  uint32_t getTlsIndexOff() const { return TlsIndexOff; }

  uintX_t getGp() const;

private:
  // MIPS GOT consists of three parts: local, global and tls. Each part
  // contains different types of entries. Here is a layout of GOT:
  // - Header entries                |
  // - Page entries                  |   Local part
  // - Local entries (16-bit access) |
  // - Local entries (32-bit access) |
  // - Normal global entries         ||  Global part
  // - Reloc-only global entries     ||
  // - TLS entries                   ||| TLS part
  //
  // Header:
  //   Two entries hold predefined value 0x0 and 0x80000000.
  // Page entries:
  //   These entries created by R_MIPS_GOT_PAGE relocation and R_MIPS_GOT16
  //   relocation against local symbols. They are initialized by higher 16-bit
  //   of the corresponding symbol's value. So each 64kb of address space
  //   requires a single GOT entry.
  // Local entries (16-bit access):
  //   These entries created by GOT relocations against global non-preemptible
  //   symbols so dynamic linker is not necessary to resolve the symbol's
  //   values. "16-bit access" means that corresponding relocations address
  //   GOT using 16-bit index. Each unique Symbol-Addend pair has its own
  //   GOT entry.
  // Local entries (32-bit access):
  //   These entries are the same as above but created by relocations which
  //   address GOT using 32-bit index (R_MIPS_GOT_HI16/LO16 etc).
  // Normal global entries:
  //   These entries created by GOT relocations against preemptible global
  //   symbols. They need to be initialized by dynamic linker and they ordered
  //   exactly as the corresponding entries in the dynamic symbols table.
  // Reloc-only global entries:
  //   These entries created for symbols that are referenced by dynamic
  //   relocations R_MIPS_REL32. These entries are not accessed with gp-relative
  //   addressing, but MIPS ABI requires that these entries be present in GOT.
  // TLS entries:
  //   Entries created by TLS relocations.

  // Number of "Header" entries.
  static const unsigned HeaderEntriesNum = 2;
  // Number of allocated "Page" entries.
  uint32_t PageEntriesNum = 0;
  // Map output sections referenced by MIPS GOT relocations
  // to the first index of "Page" entries allocated for this section.
  llvm::SmallMapVector<const OutputSectionBase *, size_t, 16> PageIndexMap;

  typedef std::pair<const SymbolBody *, uintX_t> GotEntry;
  typedef std::vector<GotEntry> GotEntries;
  // Map from Symbol-Addend pair to the GOT index.
  llvm::DenseMap<GotEntry, size_t> EntryIndexMap;
  // Local entries (16-bit access).
  GotEntries LocalEntries;
  // Local entries (32-bit access).
  GotEntries LocalEntries32;

  // Normal and reloc-only global entries.
  GotEntries GlobalEntries;

  // TLS entries.
  std::vector<const SymbolBody *> TlsEntries;

  uint32_t TlsIndexOff = -1;
  uintX_t Size = 0;
};

template <class ELFT>
class GotPltSection final : public SyntheticSection<ELFT> {
  typedef typename ELFT::uint uintX_t;

public:
  GotPltSection();
  void addEntry(SymbolBody &Sym);
  size_t getSize() const override;
  void writeTo(uint8_t *Buf) override;
  bool empty() const override { return Entries.empty(); }

private:
  std::vector<const SymbolBody *> Entries;
};

// The IgotPltSection is a Got associated with the IpltSection for GNU Ifunc
// Symbols that will be relocated by Target->IRelativeRel.
// On most Targets the IgotPltSection will immediately follow the GotPltSection
// on ARM the IgotPltSection will immediately follow the GotSection.
template <class ELFT>
class IgotPltSection final : public SyntheticSection<ELFT> {
  typedef typename ELFT::uint uintX_t;

public:
  IgotPltSection();
  void addEntry(SymbolBody &Sym);
  size_t getSize() const override;
  void writeTo(uint8_t *Buf) override;
  bool empty() const override { return Entries.empty(); }

private:
  std::vector<const SymbolBody *> Entries;
};

template <class ELFT>
class StringTableSection final : public SyntheticSection<ELFT> {
public:
  typedef typename ELFT::uint uintX_t;
  StringTableSection(StringRef Name, bool Dynamic);
  unsigned addString(StringRef S, bool HashIt = true);
  void writeTo(uint8_t *Buf) override;
  size_t getSize() const override { return Size; }
  bool isDynamic() const { return Dynamic; }

private:
  const bool Dynamic;

  // ELF string tables start with a NUL byte, so 1.
  uintX_t Size = 1;

  llvm::DenseMap<StringRef, unsigned> StringMap;
  std::vector<StringRef> Strings;
};

template <class ELFT> class DynamicReloc {
  typedef typename ELFT::uint uintX_t;

public:
  DynamicReloc(uint32_t Type, const InputSectionBase<ELFT> *InputSec,
               uintX_t OffsetInSec, bool UseSymVA, SymbolBody *Sym,
               uintX_t Addend)
      : Type(Type), Sym(Sym), InputSec(InputSec), OffsetInSec(OffsetInSec),
        UseSymVA(UseSymVA), Addend(Addend) {}

  DynamicReloc(uint32_t Type, const OutputSectionBase *OutputSec,
               uintX_t OffsetInSec, bool UseSymVA, SymbolBody *Sym,
               uintX_t Addend)
      : Type(Type), Sym(Sym), OutputSec(OutputSec), OffsetInSec(OffsetInSec),
        UseSymVA(UseSymVA), Addend(Addend) {}

  uintX_t getOffset() const;
  uintX_t getAddend() const;
  uint32_t getSymIndex() const;
  const OutputSectionBase *getOutputSec() const { return OutputSec; }
  const InputSectionBase<ELFT> *getInputSec() const { return InputSec; }

  uint32_t Type;

private:
  SymbolBody *Sym;
  const InputSectionBase<ELFT> *InputSec = nullptr;
  const OutputSectionBase *OutputSec = nullptr;
  uintX_t OffsetInSec;
  bool UseSymVA;
  uintX_t Addend;
};

template <class ELFT>
class DynamicSection final : public SyntheticSection<ELFT> {
  typedef typename ELFT::Dyn Elf_Dyn;
  typedef typename ELFT::Rel Elf_Rel;
  typedef typename ELFT::Rela Elf_Rela;
  typedef typename ELFT::Shdr Elf_Shdr;
  typedef typename ELFT::Sym Elf_Sym;
  typedef typename ELFT::uint uintX_t;

  // The .dynamic section contains information for the dynamic linker.
  // The section consists of fixed size entries, which consist of
  // type and value fields. Value are one of plain integers, symbol
  // addresses, or section addresses. This struct represents the entry.
  struct Entry {
    int32_t Tag;
    union {
      OutputSectionBase *OutSec;
      InputSection<ELFT> *InSec;
      uint64_t Val;
      const SymbolBody *Sym;
    };
    enum KindT { SecAddr, SecSize, SymAddr, PlainInt, InSecAddr } Kind;
    Entry(int32_t Tag, OutputSectionBase *OutSec, KindT Kind = SecAddr)
        : Tag(Tag), OutSec(OutSec), Kind(Kind) {}
    Entry(int32_t Tag, InputSection<ELFT> *Sec)
        : Tag(Tag), InSec(Sec), Kind(InSecAddr) {}
    Entry(int32_t Tag, uint64_t Val) : Tag(Tag), Val(Val), Kind(PlainInt) {}
    Entry(int32_t Tag, const SymbolBody *Sym)
        : Tag(Tag), Sym(Sym), Kind(SymAddr) {}
  };

  // finalize() fills this vector with the section contents. finalize()
  // cannot directly create final section contents because when the
  // function is called, symbol or section addresses are not fixed yet.
  std::vector<Entry> Entries;

public:
  DynamicSection();
  void finalize() override;
  void writeTo(uint8_t *Buf) override;
  size_t getSize() const override { return Size; }

private:
  void addEntries();
  void add(Entry E) { Entries.push_back(E); }
  uintX_t Size = 0;
};

template <class ELFT>
class RelocationSection final : public SyntheticSection<ELFT> {
  typedef typename ELFT::Rel Elf_Rel;
  typedef typename ELFT::Rela Elf_Rela;
  typedef typename ELFT::uint uintX_t;

public:
  RelocationSection(StringRef Name, bool Sort);
  void addReloc(const DynamicReloc<ELFT> &Reloc);
  unsigned getRelocOffset();
  void finalize() override;
  void writeTo(uint8_t *Buf) override;
  bool empty() const override { return Relocs.empty(); }
  size_t getSize() const override { return Relocs.size() * this->Entsize; }
  size_t getRelativeRelocCount() const { return NumRelativeRelocs; }

private:
  bool Sort;
  size_t NumRelativeRelocs = 0;
  std::vector<DynamicReloc<ELFT>> Relocs;
};

struct SymbolTableEntry {
  SymbolBody *Symbol;
  size_t StrTabOffset;
};

template <class ELFT>
class SymbolTableSection final : public SyntheticSection<ELFT> {
public:
  typedef typename ELFT::Shdr Elf_Shdr;
  typedef typename ELFT::Sym Elf_Sym;
  typedef typename ELFT::SymRange Elf_Sym_Range;
  typedef typename ELFT::uint uintX_t;
  SymbolTableSection(StringTableSection<ELFT> &StrTabSec);

  void finalize() override;
  void writeTo(uint8_t *Buf) override;
  size_t getSize() const override { return getNumSymbols() * sizeof(Elf_Sym); }
  void addSymbol(SymbolBody *Body);
  StringTableSection<ELFT> &getStrTabSec() const { return StrTabSec; }
  unsigned getNumSymbols() const { return NumLocals + Symbols.size() + 1; }

  ArrayRef<SymbolTableEntry> getSymbols() const { return Symbols; }

  unsigned NumLocals = 0;
  StringTableSection<ELFT> &StrTabSec;

private:
  void writeLocalSymbols(uint8_t *&Buf);
  void writeGlobalSymbols(uint8_t *Buf);

  const OutputSectionBase *getOutputSection(SymbolBody *Sym);

  // A vector of symbols and their string table offsets.
  std::vector<SymbolTableEntry> Symbols;
};

// Outputs GNU Hash section. For detailed explanation see:
// https://blogs.oracle.com/ali/entry/gnu_hash_elf_sections
template <class ELFT>
class GnuHashTableSection final : public SyntheticSection<ELFT> {
  typedef typename ELFT::Off Elf_Off;
  typedef typename ELFT::Word Elf_Word;
  typedef typename ELFT::uint uintX_t;

public:
  GnuHashTableSection();
  void finalize() override;
  void writeTo(uint8_t *Buf) override;
  size_t getSize() const override { return this->Size; }

  // Adds symbols to the hash table.
  // Sorts the input to satisfy GNU hash section requirements.
  void addSymbols(std::vector<SymbolTableEntry> &Symbols);

private:
  static unsigned calcNBuckets(unsigned NumHashed);
  static unsigned calcMaskWords(unsigned NumHashed);

  void writeHeader(uint8_t *&Buf);
  void writeBloomFilter(uint8_t *&Buf);
  void writeHashTable(uint8_t *Buf);

  struct SymbolData {
    SymbolBody *Body;
    size_t STName;
    uint32_t Hash;
  };

  std::vector<SymbolData> Symbols;

  unsigned MaskWords;
  unsigned NBuckets;
  unsigned Shift2;
  uintX_t Size = 0;
};

template <class ELFT>
class HashTableSection final : public SyntheticSection<ELFT> {
  typedef typename ELFT::Word Elf_Word;

public:
  HashTableSection();
  void finalize() override;
  void writeTo(uint8_t *Buf) override;
  size_t getSize() const override { return this->Size; }

private:
  size_t Size = 0;
};

template <class ELFT> class PltSection final : public SyntheticSection<ELFT> {
public:
  PltSection();
  void writeTo(uint8_t *Buf) override;
  size_t getSize() const override;
  void addEntry(SymbolBody &Sym);
  bool empty() const override { return Entries.empty(); }

private:
  std::vector<std::pair<const SymbolBody *, unsigned>> Entries;
};

// The IpltSection is a variant of Plt for recording entries for GNU Ifunc
// symbols that will be subject to a Target->IRelativeRel
// The IpltSection immediately follows the Plt section in the Output Section
template <class ELFT> class IpltSection final : public SyntheticSection<ELFT> {
public:
  IpltSection();
  void writeTo(uint8_t *Buf) override;
  size_t getSize() const override;
  void addEntry(SymbolBody &Sym);
  bool empty() const override { return Entries.empty(); }

private:
  std::vector<std::pair<const SymbolBody *, unsigned>> Entries;
};

template <class ELFT>
class GdbIndexSection final : public SyntheticSection<ELFT> {
  typedef typename ELFT::uint uintX_t;

  const unsigned OffsetTypeSize = 4;
  const unsigned CuListOffset = 6 * OffsetTypeSize;
  const unsigned CompilationUnitSize = 16;
  const unsigned AddressEntrySize = 16 + OffsetTypeSize;
  const unsigned SymTabEntrySize = 2 * OffsetTypeSize;

public:
  GdbIndexSection();
  void finalize() override;
  void writeTo(uint8_t *Buf) override;
  size_t getSize() const override;
  bool empty() const override;

  // Pairs of [CU Offset, CU length].
  std::vector<std::pair<uintX_t, uintX_t>> CompilationUnits;

  llvm::StringTableBuilder StringPool;

  GdbHashTab SymbolTable;

  // The CU vector portion of the constant pool.
  std::vector<std::vector<std::pair<uint32_t, uint8_t>>> CuVectors;

  std::vector<AddressEntry<ELFT>> AddressArea;

private:
  void parseDebugSections();
  void readDwarf(InputSection<ELFT> *I);

  uint32_t CuTypesOffset;
  uint32_t SymTabOffset;
  uint32_t ConstantPoolOffset;
  uint32_t StringPoolOffset;

  size_t CuVectorsSize = 0;
  std::vector<size_t> CuVectorsOffset;

  bool Finalized = false;
};

// --eh-frame-hdr option tells linker to construct a header for all the
// .eh_frame sections. This header is placed to a section named .eh_frame_hdr
// and also to a PT_GNU_EH_FRAME segment.
// At runtime the unwinder then can find all the PT_GNU_EH_FRAME segments by
// calling dl_iterate_phdr.
// This section contains a lookup table for quick binary search of FDEs.
// Detailed info about internals can be found in Ian Lance Taylor's blog:
// http://www.airs.com/blog/archives/460 (".eh_frame")
// http://www.airs.com/blog/archives/462 (".eh_frame_hdr")
template <class ELFT>
class EhFrameHeader final : public SyntheticSection<ELFT> {
  typedef typename ELFT::uint uintX_t;

public:
  EhFrameHeader();
  void writeTo(uint8_t *Buf) override;
  size_t getSize() const override;
  void addFde(uint32_t Pc, uint32_t FdeVA);
  bool empty() const override;

private:
  struct FdeData {
    uint32_t Pc;
    uint32_t FdeVA;
  };

  std::vector<FdeData> Fdes;
};

// For more information about .gnu.version and .gnu.version_r see:
// https://www.akkadia.org/drepper/symbol-versioning

// The .gnu.version_d section which has a section type of SHT_GNU_verdef shall
// contain symbol version definitions. The number of entries in this section
// shall be contained in the DT_VERDEFNUM entry of the .dynamic section.
// The section shall contain an array of Elf_Verdef structures, optionally
// followed by an array of Elf_Verdaux structures.
template <class ELFT>
class VersionDefinitionSection final : public SyntheticSection<ELFT> {
  typedef typename ELFT::Verdef Elf_Verdef;
  typedef typename ELFT::Verdaux Elf_Verdaux;

public:
  VersionDefinitionSection();
  void finalize() override;
  size_t getSize() const override;
  void writeTo(uint8_t *Buf) override;

private:
  void writeOne(uint8_t *Buf, uint32_t Index, StringRef Name, size_t NameOff);

  unsigned FileDefNameOff;
};

// The .gnu.version section specifies the required version of each symbol in the
// dynamic symbol table. It contains one Elf_Versym for each dynamic symbol
// table entry. An Elf_Versym is just a 16-bit integer that refers to a version
// identifier defined in the either .gnu.version_r or .gnu.version_d section.
// The values 0 and 1 are reserved. All other values are used for versions in
// the own object or in any of the dependencies.
template <class ELFT>
class VersionTableSection final : public SyntheticSection<ELFT> {
  typedef typename ELFT::Versym Elf_Versym;

public:
  VersionTableSection();
  void finalize() override;
  size_t getSize() const override;
  void writeTo(uint8_t *Buf) override;
  bool empty() const override;
};

// The .gnu.version_r section defines the version identifiers used by
// .gnu.version. It contains a linked list of Elf_Verneed data structures. Each
// Elf_Verneed specifies the version requirements for a single DSO, and contains
// a reference to a linked list of Elf_Vernaux data structures which define the
// mapping from version identifiers to version names.
template <class ELFT>
class VersionNeedSection final : public SyntheticSection<ELFT> {
  typedef typename ELFT::Verneed Elf_Verneed;
  typedef typename ELFT::Vernaux Elf_Vernaux;

  // A vector of shared files that need Elf_Verneed data structures and the
  // string table offsets of their sonames.
  std::vector<std::pair<SharedFile<ELFT> *, size_t>> Needed;

  // The next available version identifier.
  unsigned NextIndex;

public:
  VersionNeedSection();
  void addSymbol(SharedSymbol<ELFT> *SS);
  void finalize() override;
  void writeTo(uint8_t *Buf) override;
  size_t getSize() const override;
  size_t getNeedNum() const { return Needed.size(); }
  bool empty() const override;
};

// .MIPS.abiflags section.
template <class ELFT>
class MipsAbiFlagsSection final : public SyntheticSection<ELFT> {
  typedef llvm::object::Elf_Mips_ABIFlags<ELFT> Elf_Mips_ABIFlags;

public:
  static MipsAbiFlagsSection *create();

  MipsAbiFlagsSection(Elf_Mips_ABIFlags Flags);
  size_t getSize() const override { return sizeof(Elf_Mips_ABIFlags); }
  void writeTo(uint8_t *Buf) override;

private:
  Elf_Mips_ABIFlags Flags;
};

// .MIPS.options section.
template <class ELFT>
class MipsOptionsSection final : public SyntheticSection<ELFT> {
  typedef llvm::object::Elf_Mips_Options<ELFT> Elf_Mips_Options;
  typedef llvm::object::Elf_Mips_RegInfo<ELFT> Elf_Mips_RegInfo;

public:
  static MipsOptionsSection *create();

  MipsOptionsSection(Elf_Mips_RegInfo Reginfo);
  void writeTo(uint8_t *Buf) override;

  size_t getSize() const override {
    return sizeof(Elf_Mips_Options) + sizeof(Elf_Mips_RegInfo);
  }

private:
  Elf_Mips_RegInfo Reginfo;
};

// MIPS .reginfo section.
template <class ELFT>
class MipsReginfoSection final : public SyntheticSection<ELFT> {
  typedef llvm::object::Elf_Mips_RegInfo<ELFT> Elf_Mips_RegInfo;

public:
  static MipsReginfoSection *create();

  MipsReginfoSection(Elf_Mips_RegInfo Reginfo);
  size_t getSize() const override { return sizeof(Elf_Mips_RegInfo); }
  void writeTo(uint8_t *Buf) override;

private:
  Elf_Mips_RegInfo Reginfo;
};

// This is a MIPS specific section to hold a space within the data segment
// of executable file which is pointed to by the DT_MIPS_RLD_MAP entry.
// See "Dynamic section" in Chapter 5 in the following document:
// ftp://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf
template <class ELFT> class MipsRldMapSection : public SyntheticSection<ELFT> {
public:
  MipsRldMapSection();
  size_t getSize() const override { return sizeof(typename ELFT::uint); }
  void writeTo(uint8_t *Buf) override;
};

template <class ELFT> class ARMExidxSentinelSection : public SyntheticSection<ELFT> {
public:
  ARMExidxSentinelSection();
  size_t getSize() const override { return 8; }
  void writeTo(uint8_t *Buf) override;
};

template <class ELFT> InputSection<ELFT> *createCommonSection();
template <class ELFT> InputSection<ELFT> *createInterpSection();
template <class ELFT> MergeInputSection<ELFT> *createCommentSection();

// Linker generated sections which can be used as inputs.
template <class ELFT> struct In {
  static InputSection<ELFT> *ARMAttributes;
  static BuildIdSection<ELFT> *BuildId;
  static InputSection<ELFT> *Common;
  static DynamicSection<ELFT> *Dynamic;
  static StringTableSection<ELFT> *DynStrTab;
  static SymbolTableSection<ELFT> *DynSymTab;
  static EhFrameHeader<ELFT> *EhFrameHdr;
  static GnuHashTableSection<ELFT> *GnuHashTab;
  static GdbIndexSection<ELFT> *GdbIndex;
  static GotSection<ELFT> *Got;
  static MipsGotSection<ELFT> *MipsGot;
  static GotPltSection<ELFT> *GotPlt;
  static IgotPltSection<ELFT> *IgotPlt;
  static HashTableSection<ELFT> *HashTab;
  static InputSection<ELFT> *Interp;
  static MipsRldMapSection<ELFT> *MipsRldMap;
  static PltSection<ELFT> *Plt;
  static IpltSection<ELFT> *Iplt;
  static RelocationSection<ELFT> *RelaDyn;
  static RelocationSection<ELFT> *RelaPlt;
  static RelocationSection<ELFT> *RelaIplt;
  static StringTableSection<ELFT> *ShStrTab;
  static StringTableSection<ELFT> *StrTab;
  static SymbolTableSection<ELFT> *SymTab;
  static VersionDefinitionSection<ELFT> *VerDef;
  static VersionTableSection<ELFT> *VerSym;
  static VersionNeedSection<ELFT> *VerNeed;
};

template <class ELFT> InputSection<ELFT> *In<ELFT>::ARMAttributes;
template <class ELFT> BuildIdSection<ELFT> *In<ELFT>::BuildId;
template <class ELFT> InputSection<ELFT> *In<ELFT>::Common;
template <class ELFT> DynamicSection<ELFT> *In<ELFT>::Dynamic;
template <class ELFT> StringTableSection<ELFT> *In<ELFT>::DynStrTab;
template <class ELFT> SymbolTableSection<ELFT> *In<ELFT>::DynSymTab;
template <class ELFT> EhFrameHeader<ELFT> *In<ELFT>::EhFrameHdr;
template <class ELFT> GdbIndexSection<ELFT> *In<ELFT>::GdbIndex;
template <class ELFT> GnuHashTableSection<ELFT> *In<ELFT>::GnuHashTab;
template <class ELFT> GotSection<ELFT> *In<ELFT>::Got;
template <class ELFT> MipsGotSection<ELFT> *In<ELFT>::MipsGot;
template <class ELFT> GotPltSection<ELFT> *In<ELFT>::GotPlt;
template <class ELFT> IgotPltSection<ELFT> *In<ELFT>::IgotPlt;
template <class ELFT> HashTableSection<ELFT> *In<ELFT>::HashTab;
template <class ELFT> InputSection<ELFT> *In<ELFT>::Interp;
template <class ELFT> MipsRldMapSection<ELFT> *In<ELFT>::MipsRldMap;
template <class ELFT> PltSection<ELFT> *In<ELFT>::Plt;
template <class ELFT> IpltSection<ELFT> *In<ELFT>::Iplt;
template <class ELFT> RelocationSection<ELFT> *In<ELFT>::RelaDyn;
template <class ELFT> RelocationSection<ELFT> *In<ELFT>::RelaPlt;
template <class ELFT> RelocationSection<ELFT> *In<ELFT>::RelaIplt;
template <class ELFT> StringTableSection<ELFT> *In<ELFT>::ShStrTab;
template <class ELFT> StringTableSection<ELFT> *In<ELFT>::StrTab;
template <class ELFT> SymbolTableSection<ELFT> *In<ELFT>::SymTab;
template <class ELFT> VersionDefinitionSection<ELFT> *In<ELFT>::VerDef;
template <class ELFT> VersionTableSection<ELFT> *In<ELFT>::VerSym;
template <class ELFT> VersionNeedSection<ELFT> *In<ELFT>::VerNeed;
} // namespace elf
} // namespace lld

#endif
@


1.1.1.1
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 release including clang and lld.
@
text
@d369 1
a369 2
  void addGlobal(SymbolBody *Body);
  void addLocal(SymbolBody *Body);
d371 1
a371 2
  unsigned getNumSymbols() const { return Symbols.size() + 1; }
  size_t getSymbolIndex(SymbolBody *Body);
d375 2
a376 1
  static const OutputSectionBase *getOutputSection(SymbolBody *Sym);
d382 2
a385 4

  StringTableSection<ELFT> &StrTabSec;

  unsigned NumLocals = 0;
@


1.1.1.3
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@a8 11
//
// Synthetic sections represent chunks of linker-created data. If you
// need to create a chunk of data that to be included in some section
// in the result, you probably want to create that as a synthetic section.
//
// Synthetic sections are designed as input sections as opposed to
// output sections because we want to allow them to be manipulated
// using linker scripts just like other input sections from regular
// files.
//
//===----------------------------------------------------------------------===//
a12 1
#include "EhFrame.h"
a17 2
#include <set>

d21 3
a23 1
class SyntheticSection : public InputSection {
d25 1
a25 1
  SyntheticSection(uint64_t Flags, uint32_t Type, uint32_t Alignment,
d27 2
a28 2
      : InputSection(Flags, Type, Alignment, {}, Name,
                     InputSectionBase::Synthetic) {
d35 1
a35 6
  virtual void finalizeContents() {}
  // If the section has the SHF_ALLOC flag and the size may be changed if
  // thunks are added, update the section size.
  virtual void updateAllocSize() {}
  // If any additional finalization of contents are needed post thunk creation.
  virtual void postThunkContents() {}
a36 1
  uint64_t getVA() const;
d38 2
a39 2
  static bool classof(const SectionBase *D) {
    return D->kind() == InputSectionBase::Synthetic;
a40 1
};
d42 3
a44 3
struct CieRecord {
  EhSectionPiece *Piece = nullptr;
  std::vector<EhSectionPiece *> FdePieces;
d47 2
a48 10
// Section for .eh_frame.
template <class ELFT> class EhFrameSection final : public SyntheticSection {
  typedef typename ELFT::Shdr Elf_Shdr;
  typedef typename ELFT::Rel Elf_Rel;
  typedef typename ELFT::Rela Elf_Rela;

  void updateAlignment(uint64_t Val) {
    if (Val > this->Alignment)
      this->Alignment = Val;
  }
d51 1
a51 1
  EhFrameSection();
a52 2
  void finalizeContents() override;
  bool empty() const override { return Sections.empty(); }
d54 1
a54 31

  void addSection(InputSectionBase *S);

  size_t NumFdes = 0;

  std::vector<EhInputSection *> Sections;

private:
  uint64_t Size = 0;
  template <class RelTy>
  void addSectionAux(EhInputSection *S, llvm::ArrayRef<RelTy> Rels);

  template <class RelTy>
  CieRecord *addCie(EhSectionPiece &Piece, ArrayRef<RelTy> Rels);

  template <class RelTy>
  bool isFdeLive(EhSectionPiece &Piece, ArrayRef<RelTy> Rels);

  uint64_t getFdePc(uint8_t *Buf, size_t Off, uint8_t Enc);

  std::vector<CieRecord *> Cies;

  // CIE records are uniquified by their contents and personality functions.
  llvm::DenseMap<std::pair<ArrayRef<uint8_t>, SymbolBody *>, CieRecord> CieMap;
};

class GotSection : public SyntheticSection {
public:
  GotSection();
  size_t getSize() const override { return Size; }
  void finalizeContents() override;
a55 1
  void writeTo(uint8_t *Buf) override;
d60 2
a61 2
  uint64_t getGlobalDynAddr(const SymbolBody &B) const;
  uint64_t getGlobalDynOffset(const SymbolBody &B) const;
d63 1
a63 1
  uint64_t getTlsIndexVA() { return this->getVA() + TlsIndexOff; }
d70 1
a70 1
protected:
d73 1
a73 1
  uint64_t Size = 0;
d77 1
a77 1
class BuildIdSection : public SyntheticSection {
d95 3
a97 11
// BssSection is used to reserve space for copy relocations and common symbols.
// We create three instances of this class for .bss, .bss.rel.ro and "COMMON",
// that are used for writable symbols, read-only symbols and common symbols,
// respectively.
class BssSection final : public SyntheticSection {
public:
  BssSection(StringRef Name);
  void writeTo(uint8_t *) override {}
  bool empty() const override { return getSize() == 0; }
  size_t reserveSpace(uint64_t Size, uint32_t Alignment);
  size_t getSize() const override { return Size; }
a98 5
private:
  uint64_t Size = 0;
};

class MipsGotSection final : public SyntheticSection {
d103 1
a103 2
  void updateAllocSize() override;
  void finalizeContents() override;
d105 1
a105 1
  void addEntry(SymbolBody &Sym, int64_t Addend, RelExpr Expr);
d108 3
a110 3
  uint64_t getPageEntryOffset(const SymbolBody &B, int64_t Addend) const;
  uint64_t getBodyEntryOffset(const SymbolBody &B, int64_t Addend) const;
  uint64_t getGlobalDynOffset(const SymbolBody &B) const;
d124 1
a124 1
  uint64_t getTlsOffset() const;
d128 1
a128 1
  uint64_t getGp() const;
d174 1
a174 1
  llvm::SmallMapVector<const OutputSection *, size_t, 16> PageIndexMap;
d176 1
a176 1
  typedef std::pair<const SymbolBody *, uint64_t> GotEntry;
d192 1
a192 1
  uint64_t Size = 0;
d195 4
a198 1
class GotPltSection final : public SyntheticSection {
d210 1
a210 1
// The IgotPltSection is a Got associated with the PltSection for GNU Ifunc
d214 4
a217 1
class IgotPltSection final : public SyntheticSection {
d229 2
a230 1
class StringTableSection final : public SyntheticSection {
d232 1
d242 2
a243 1
  uint64_t Size = 0;
d249 3
a251 1
class DynamicReloc {
d253 3
a255 3
  DynamicReloc(uint32_t Type, const InputSectionBase *InputSec,
               uint64_t OffsetInSec, bool UseSymVA, SymbolBody *Sym,
               int64_t Addend)
d259 8
a266 2
  uint64_t getOffset() const;
  int64_t getAddend() const;
d268 2
a269 1
  const InputSectionBase *getInputSec() const { return InputSec; }
d275 3
a277 2
  const InputSectionBase *InputSec = nullptr;
  uint64_t OffsetInSec;
d279 1
a279 1
  int64_t Addend;
d282 2
a283 1
template <class ELFT> class DynamicSection final : public SyntheticSection {
d289 1
d298 2
a299 2
      OutputSection *OutSec;
      InputSection *InSec;
d304 1
a304 1
    Entry(int32_t Tag, OutputSection *OutSec, KindT Kind = SecAddr)
d306 1
a306 1
    Entry(int32_t Tag, InputSection *Sec)
d313 3
a315 1
  // finalizeContents() fills this vector with the section contents.
d320 1
a320 1
  void finalizeContents() override;
d327 1
a327 1
  uint64_t Size = 0;
d330 2
a331 1
template <class ELFT> class RelocationSection final : public SyntheticSection {
d334 1
d338 1
a338 1
  void addReloc(const DynamicReloc &Reloc);
d340 1
a340 1
  void finalizeContents() override;
d349 1
a349 1
  std::vector<DynamicReloc> Relocs;
d357 2
a358 1
class SymbolTableBaseSection : public SyntheticSection {
d360 12
a371 5
  SymbolTableBaseSection(StringTableSection &StrTabSec);
  void finalizeContents() override;
  void postThunkContents() override;
  size_t getSize() const override { return getNumSymbols() * Entsize; }
  void addSymbol(SymbolBody *Body);
d374 1
d377 6
a382 1
protected:
d386 1
a386 6
  StringTableSection &StrTabSec;
};

template <class ELFT>
class SymbolTableSection final : public SymbolTableBaseSection {
  typedef typename ELFT::Sym Elf_Sym;
d388 1
a388 3
public:
  SymbolTableSection(StringTableSection &StrTabSec);
  void writeTo(uint8_t *Buf) override;
d393 6
a398 1
class GnuHashTableSection final : public SyntheticSection {
d401 1
a401 1
  void finalizeContents() override;
d403 1
a403 1
  size_t getSize() const override { return Size; }
d410 2
a411 1
  size_t getShift2() const { return Config->Is64 ? 6 : 5; }
d413 2
a414 1
  void writeBloomFilter(uint8_t *Buf);
d417 1
a417 1
  struct Entry {
d419 1
a419 1
    size_t StrTabOffset;
d423 6
a428 4
  std::vector<Entry> Symbols;
  size_t MaskWords;
  size_t NBuckets = 0;
  size_t Size = 0;
d431 4
a434 1
template <class ELFT> class HashTableSection final : public SyntheticSection {
d437 1
a437 1
  void finalizeContents() override;
d439 1
a439 1
  size_t getSize() const override { return Size; }
d445 1
a445 5
// The PltSection is used for both the Plt and Iplt. The former always has a
// header as its first entry that is used at run-time to resolve lazy binding.
// The latter is used for GNU Ifunc symbols, that will be subject to a
// Target->IRelativeRel.
class PltSection : public SyntheticSection {
d447 1
a447 1
  PltSection(size_t HeaderSize);
d450 1
a451 1
  void addSymbols();
d453 14
a466 1
  template <class ELFT> void addEntry(SymbolBody &Sym);
a468 3
  void writeHeader(uint8_t *Buf){};
  void addHeaderSymbols(){};
  unsigned getPltRelocOff() const;
a469 2
  // Iplt always has HeaderSize of 0, the Plt HeaderSize is always non-zero
  size_t HeaderSize;
d472 4
a475 1
class GdbIndexSection final : public SyntheticSection {
d483 2
a484 2
  GdbIndexSection(std::vector<GdbIndexChunk> &&Chunks);
  void finalizeContents() override;
d489 5
a493 2
  // Symbol table is a hash table for types and names.
  // It is the area of gdb index.
d496 2
a497 2
  // CU vector is a part of constant pool area of section.
  std::vector<std::set<uint32_t>> CuVectors;
d499 1
a499 6
  // String pool is also a part of constant pool, it follows CU vectors.
  llvm::StringTableBuilder StringPool;

  // Each chunk contains information gathered from a debug sections of single
  // object and used to build different areas of gdb index.
  std::vector<GdbIndexChunk> Chunks;
d502 2
a503 1
  void buildIndex();
a515 2
template <class ELFT> GdbIndexSection *createGdbIndex();

d525 4
a528 1
template <class ELFT> class EhFrameHeader final : public SyntheticSection {
d554 1
a554 1
class VersionDefinitionSection final : public SyntheticSection {
d560 1
a560 1
  void finalizeContents() override;
d577 1
a577 1
class VersionTableSection final : public SyntheticSection {
d582 1
a582 1
  void finalizeContents() override;
d593 2
a594 1
template <class ELFT> class VersionNeedSection final : public SyntheticSection {
d607 2
a608 2
  void addSymbol(SharedSymbol *SS);
  void finalizeContents() override;
a614 22
// MergeSyntheticSection is a class that allows us to put mergeable sections
// with different attributes in a single output sections. To do that
// we put them into MergeSyntheticSection synthetic input sections which are
// attached to regular output sections.
class MergeSyntheticSection final : public SyntheticSection {
public:
  MergeSyntheticSection(StringRef Name, uint32_t Type, uint64_t Flags,
                        uint32_t Alignment);
  void addSection(MergeInputSection *MS);
  void writeTo(uint8_t *Buf) override;
  void finalizeContents() override;
  bool shouldTailMerge() const;
  size_t getSize() const override;

private:
  void finalizeTailMerge();
  void finalizeNoTailMerge();

  llvm::StringTableBuilder Builder;
  std::vector<MergeInputSection *> Sections;
};

d617 1
a617 1
class MipsAbiFlagsSection final : public SyntheticSection {
d632 2
a633 1
template <class ELFT> class MipsOptionsSection final : public SyntheticSection {
d652 2
a653 1
template <class ELFT> class MipsReginfoSection final : public SyntheticSection {
d671 1
a671 1
class MipsRldMapSection : public SyntheticSection {
d674 2
a675 2
  size_t getSize() const override { return Config->Wordsize; }
  void writeTo(uint8_t *Buf) override {}
d678 1
a678 1
class ARMExidxSentinelSection : public SyntheticSection {
d685 3
a687 28
// A container for one or more linker generated thunks. Instances of these
// thunks including ARM interworking and Mips LA25 PI to non-PI thunks.
class ThunkSection : public SyntheticSection {
public:
  // ThunkSection in OS, with desired OutSecOff of Off
  ThunkSection(OutputSection *OS, uint64_t Off);

  // Add a newly created Thunk to this container:
  // Thunk is given offset from start of this InputSection
  // Thunk defines a symbol in this InputSection that can be used as target
  // of a relocation
  void addThunk(Thunk *T);
  size_t getSize() const override { return Size; }
  void writeTo(uint8_t *Buf) override;
  InputSection *getTargetInputSection() const;

private:
  std::vector<const Thunk *> Thunks;
  size_t Size = 0;
};

template <class ELFT> InputSection *createCommonSection();
InputSection *createInterpSection();
template <class ELFT> MergeInputSection *createCommentSection();
void decompressAndMergeSections();

SymbolBody *addSyntheticLocal(StringRef Name, uint8_t Type, uint64_t Value,
                              uint64_t Size, InputSectionBase *Section);
d690 7
a696 25
struct InX {
  static InputSection *ARMAttributes;
  static BssSection *Bss;
  static BssSection *BssRelRo;
  static BuildIdSection *BuildId;
  static InputSection *Common;
  static SyntheticSection *Dynamic;
  static StringTableSection *DynStrTab;
  static SymbolTableBaseSection *DynSymTab;
  static GnuHashTableSection *GnuHashTab;
  static InputSection *Interp;
  static GdbIndexSection *GdbIndex;
  static GotSection *Got;
  static GotPltSection *GotPlt;
  static IgotPltSection *IgotPlt;
  static MipsGotSection *MipsGot;
  static MipsRldMapSection *MipsRldMap;
  static PltSection *Plt;
  static PltSection *Iplt;
  static StringTableSection *ShStrTab;
  static StringTableSection *StrTab;
  static SymbolTableBaseSection *SymTab;
};

template <class ELFT> struct In : public InX {
d698 6
a703 1
  static EhFrameSection<ELFT> *EhFrame;
d705 4
d712 3
d720 6
d727 6
a732 1
template <class ELFT> EhFrameSection<ELFT> *In<ELFT>::EhFrame;
d734 4
d741 3
@


