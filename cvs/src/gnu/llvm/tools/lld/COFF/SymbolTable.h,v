head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.2.0.2
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.1
date	2017.01.14.19.55.46;	author patrick;	state Exp;
branches
	1.1.1.1;
next	;
commitid	qMUxATnKgqN83Oct;

1.1.1.1
date	2017.01.14.19.55.46;	author patrick;	state Exp;
branches;
next	1.1.1.2;
commitid	qMUxATnKgqN83Oct;

1.1.1.2
date	2017.01.24.08.33.12;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===- SymbolTable.h --------------------------------------------*- C++ -*-===//
//
//                             The LLVM Linker
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef LLD_COFF_SYMBOL_TABLE_H
#define LLD_COFF_SYMBOL_TABLE_H

#include "InputFiles.h"
#include "llvm/ADT/DenseMap.h"
#include "llvm/ADT/DenseMapInfo.h"
#include "llvm/Support/Allocator.h"
#include "llvm/Support/raw_ostream.h"

#ifdef _MSC_VER
// <future> depends on <eh.h> for __uncaught_exception.
#include <eh.h>
#endif

#include <future>

namespace llvm {
struct LTOCodeGenerator;
}

namespace lld {
namespace coff {

class Chunk;
class Defined;
class Lazy;
class SymbolBody;
struct Symbol;

// SymbolTable is a bucket of all known symbols, including defined,
// undefined, or lazy symbols (the last one is symbols in archive
// files whose archive members are not yet loaded).
//
// We put all symbols of all files to a SymbolTable, and the
// SymbolTable selects the "best" symbols if there are name
// conflicts. For example, obviously, a defined symbol is better than
// an undefined symbol. Or, if there's a conflict between a lazy and a
// undefined, it'll read an archive member to read a real definition
// to replace the lazy symbol. The logic is implemented in resolve().
class SymbolTable {
public:
  void addFile(std::unique_ptr<InputFile> File);
  std::vector<std::unique_ptr<InputFile>> &getFiles() { return Files; }
  void step();
  void run();
  bool queueEmpty();

  // Print an error message on undefined symbols. If Resolve is true, try to
  // resolve any undefined symbols and update the symbol table accordingly.
  void reportRemainingUndefines(bool Resolve);

  // Returns a list of chunks of selected symbols.
  std::vector<Chunk *> getChunks();

  // Returns a symbol for a given name. Returns a nullptr if not found.
  Symbol *find(StringRef Name);
  Symbol *findUnderscore(StringRef Name);

  // Occasionally we have to resolve an undefined symbol to its
  // mangled symbol. This function tries to find a mangled name
  // for U from the symbol table, and if found, set the symbol as
  // a weak alias for U.
  void mangleMaybe(Undefined *U);
  StringRef findMangle(StringRef Name);

  // Print a layout map to OS.
  void printMap(llvm::raw_ostream &OS);

  // Build a set of COFF objects representing the combined contents of
  // BitcodeFiles and add them to the symbol table. Called after all files are
  // added and before the writer writes results to a file.
  void addCombinedLTOObjects();

  // The writer needs to handle DLL import libraries specially in
  // order to create the import descriptor table.
  std::vector<ImportFile *> ImportFiles;

  // The writer needs to infer the machine type from the object files.
  std::vector<ObjectFile *> ObjectFiles;

  // Creates an Undefined symbol for a given name.
  Undefined *addUndefined(StringRef Name);
  DefinedRelative *addRelative(StringRef Name, uint64_t VA);
  DefinedAbsolute *addAbsolute(StringRef Name, uint64_t VA);

  // A list of chunks which to be added to .rdata.
  std::vector<Chunk *> LocalImportChunks;

private:
  void readArchives();
  void readObjects();

  void addSymbol(SymbolBody *New);
  void addLazy(Lazy *New, std::vector<Symbol *> *Accum);
  Symbol *insert(SymbolBody *New);
  StringRef findByPrefix(StringRef Prefix);

  void addMemberFile(Lazy *Body);
  void addCombinedLTOObject(ObjectFile *Obj);
  std::vector<ObjectFile *> createLTOObjects(llvm::LTOCodeGenerator *CG);

  llvm::DenseMap<StringRef, Symbol *> Symtab;

  std::vector<std::unique_ptr<InputFile>> Files;
  std::vector<std::future<ArchiveFile *>> ArchiveQueue;
  std::vector<std::future<InputFile *>> ObjectQueue;

  std::vector<BitcodeFile *> BitcodeFiles;
  std::vector<SmallString<0>> Objs;
  llvm::BumpPtrAllocator Alloc;
};

} // namespace coff
} // namespace lld

#endif
@


1.1.1.1
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a13 1
#include "llvm/ADT/CachedHashString.h"
d19 7
a33 1
class CommonChunk;
a34 2
class DefinedAbsolute;
class DefinedRelative;
a35 1
class SectionChunk;
d48 1
a48 3
// to replace the lazy symbol. The logic is implemented in the
// add*() functions, which are called by input files as they are parsed.
// There is one add* function per symbol type.
d51 9
a59 6
  void addFile(InputFile *File);

  // Try to resolve any undefined symbols and update the symbol table
  // accordingly, then print an error message for any remaining undefined
  // symbols.
  void reportRemainingUndefines();
d72 1
a72 1
  void mangleMaybe(SymbolBody *B);
d91 3
a93 16
  SymbolBody *addUndefined(StringRef Name);

  Symbol *addRelative(StringRef N, uint64_t VA);
  Symbol *addAbsolute(StringRef N, uint64_t VA);

  Symbol *addUndefined(StringRef Name, InputFile *F, bool IsWeakAlias);
  void addLazy(ArchiveFile *F, const Archive::Symbol Sym);
  Symbol *addAbsolute(StringRef N, COFFSymbolRef S);
  Symbol *addRegular(ObjectFile *F, COFFSymbolRef S, SectionChunk *C);
  Symbol *addBitcode(BitcodeFile *F, StringRef N, bool IsReplaceable);
  Symbol *addCommon(ObjectFile *F, COFFSymbolRef S, CommonChunk *C);
  Symbol *addImportData(StringRef N, ImportFile *F);
  Symbol *addImportThunk(StringRef Name, DefinedImportData *S,
                         uint16_t Machine);

  void reportDuplicate(Symbol *Existing, InputFile *NewFile);
d99 1
a99 1
  void readArchive();
d102 3
a104 1
  std::pair<Symbol *, bool> insert(StringRef Name);
d107 1
d111 5
a115 1
  llvm::DenseMap<llvm::CachedHashStringRef, Symbol *> Symtab;
d119 1
a120 2

extern SymbolTable *Symtab;
@

