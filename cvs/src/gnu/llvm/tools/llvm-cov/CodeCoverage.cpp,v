head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.44;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.00;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===- CodeCoverage.cpp - Coverage tool based on profiling instrumentation-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// The 'CodeCoverageTool' class implements a command line tool to analyze and
// report coverage information using the profiling instrumentation and code
// coverage mapping.
//
//===----------------------------------------------------------------------===//

#include "RenderingSupport.h"
#include "CoverageFilters.h"
#include "CoverageReport.h"
#include "CoverageViewOptions.h"
#include "SourceCoverageView.h"
#include "llvm/ADT/SmallString.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/ADT/Triple.h"
#include "llvm/ProfileData/CoverageMapping.h"
#include "llvm/ProfileData/InstrProfReader.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/FileSystem.h"
#include "llvm/Support/Format.h"
#include "llvm/Support/ManagedStatic.h"
#include "llvm/Support/Path.h"
#include "llvm/Support/PrettyStackTrace.h"
#include "llvm/Support/Process.h"
#include "llvm/Support/Signals.h"
#include <functional>
#include <system_error>

using namespace llvm;
using namespace coverage;

namespace {
/// \brief The implementation of the coverage tool.
class CodeCoverageTool {
public:
  enum Command {
    /// \brief The show command.
    Show,
    /// \brief The report command.
    Report
  };

  /// \brief Print the error message to the error output stream.
  void error(const Twine &Message, StringRef Whence = "");

  /// \brief Return a memory buffer for the given source file.
  ErrorOr<const MemoryBuffer &> getSourceFile(StringRef SourceFile);

  /// \brief Create source views for the expansions of the view.
  void attachExpansionSubViews(SourceCoverageView &View,
                               ArrayRef<ExpansionRecord> Expansions,
                               CoverageMapping &Coverage);

  /// \brief Create the source view of a particular function.
  std::unique_ptr<SourceCoverageView>
  createFunctionView(const FunctionRecord &Function, CoverageMapping &Coverage);

  /// \brief Create the main source view of a particular source file.
  std::unique_ptr<SourceCoverageView>
  createSourceFileView(StringRef SourceFile, CoverageMapping &Coverage);

  /// \brief Load the coverage mapping data. Return true if an error occured.
  std::unique_ptr<CoverageMapping> load();

  int run(Command Cmd, int argc, const char **argv);

  typedef std::function<int(int, const char **)> CommandLineParserType;

  int show(int argc, const char **argv,
           CommandLineParserType commandLineParser);

  int report(int argc, const char **argv,
             CommandLineParserType commandLineParser);

  std::string ObjectFilename;
  CoverageViewOptions ViewOpts;
  std::string PGOFilename;
  CoverageFiltersMatchAll Filters;
  std::vector<std::string> SourceFiles;
  std::vector<std::pair<std::string, std::unique_ptr<MemoryBuffer>>>
      LoadedSourceFiles;
  bool CompareFilenamesOnly;
  StringMap<std::string> RemappedFilenames;
  std::string CoverageArch;
};
}

void CodeCoverageTool::error(const Twine &Message, StringRef Whence) {
  errs() << "error: ";
  if (!Whence.empty())
    errs() << Whence << ": ";
  errs() << Message << "\n";
}

ErrorOr<const MemoryBuffer &>
CodeCoverageTool::getSourceFile(StringRef SourceFile) {
  // If we've remapped filenames, look up the real location for this file.
  if (!RemappedFilenames.empty()) {
    auto Loc = RemappedFilenames.find(SourceFile);
    if (Loc != RemappedFilenames.end())
      SourceFile = Loc->second;
  }
  for (const auto &Files : LoadedSourceFiles)
    if (sys::fs::equivalent(SourceFile, Files.first))
      return *Files.second;
  auto Buffer = MemoryBuffer::getFile(SourceFile);
  if (auto EC = Buffer.getError()) {
    error(EC.message(), SourceFile);
    return EC;
  }
  LoadedSourceFiles.emplace_back(SourceFile, std::move(Buffer.get()));
  return *LoadedSourceFiles.back().second;
}

void
CodeCoverageTool::attachExpansionSubViews(SourceCoverageView &View,
                                          ArrayRef<ExpansionRecord> Expansions,
                                          CoverageMapping &Coverage) {
  if (!ViewOpts.ShowExpandedRegions)
    return;
  for (const auto &Expansion : Expansions) {
    auto ExpansionCoverage = Coverage.getCoverageForExpansion(Expansion);
    if (ExpansionCoverage.empty())
      continue;
    auto SourceBuffer = getSourceFile(ExpansionCoverage.getFilename());
    if (!SourceBuffer)
      continue;

    auto SubViewExpansions = ExpansionCoverage.getExpansions();
    auto SubView = llvm::make_unique<SourceCoverageView>(
        SourceBuffer.get(), ViewOpts, std::move(ExpansionCoverage));
    attachExpansionSubViews(*SubView, SubViewExpansions, Coverage);
    View.addExpansion(Expansion.Region, std::move(SubView));
  }
}

std::unique_ptr<SourceCoverageView>
CodeCoverageTool::createFunctionView(const FunctionRecord &Function,
                                     CoverageMapping &Coverage) {
  auto FunctionCoverage = Coverage.getCoverageForFunction(Function);
  if (FunctionCoverage.empty())
    return nullptr;
  auto SourceBuffer = getSourceFile(FunctionCoverage.getFilename());
  if (!SourceBuffer)
    return nullptr;

  auto Expansions = FunctionCoverage.getExpansions();
  auto View = llvm::make_unique<SourceCoverageView>(
      SourceBuffer.get(), ViewOpts, std::move(FunctionCoverage));
  attachExpansionSubViews(*View, Expansions, Coverage);

  return View;
}

std::unique_ptr<SourceCoverageView>
CodeCoverageTool::createSourceFileView(StringRef SourceFile,
                                       CoverageMapping &Coverage) {
  auto SourceBuffer = getSourceFile(SourceFile);
  if (!SourceBuffer)
    return nullptr;
  auto FileCoverage = Coverage.getCoverageForFile(SourceFile);
  if (FileCoverage.empty())
    return nullptr;

  auto Expansions = FileCoverage.getExpansions();
  auto View = llvm::make_unique<SourceCoverageView>(
      SourceBuffer.get(), ViewOpts, std::move(FileCoverage));
  attachExpansionSubViews(*View, Expansions, Coverage);

  for (auto Function : Coverage.getInstantiations(SourceFile)) {
    auto SubViewCoverage = Coverage.getCoverageForFunction(*Function);
    auto SubViewExpansions = SubViewCoverage.getExpansions();
    auto SubView = llvm::make_unique<SourceCoverageView>(
        SourceBuffer.get(), ViewOpts, std::move(SubViewCoverage));
    attachExpansionSubViews(*SubView, SubViewExpansions, Coverage);

    if (SubView) {
      unsigned FileID = Function->CountedRegions.front().FileID;
      unsigned Line = 0;
      for (const auto &CR : Function->CountedRegions)
        if (CR.FileID == FileID)
          Line = std::max(CR.LineEnd, Line);
      View->addInstantiation(Function->Name, Line, std::move(SubView));
    }
  }
  return View;
}

static bool modifiedTimeGT(StringRef LHS, StringRef RHS) {
  sys::fs::file_status Status;
  if (sys::fs::status(LHS, Status))
    return false;
  auto LHSTime = Status.getLastModificationTime();
  if (sys::fs::status(RHS, Status))
    return false;
  auto RHSTime = Status.getLastModificationTime();
  return LHSTime > RHSTime;
}

std::unique_ptr<CoverageMapping> CodeCoverageTool::load() {
  if (modifiedTimeGT(ObjectFilename, PGOFilename))
    errs() << "warning: profile data may be out of date - object is newer\n";
  auto CoverageOrErr = CoverageMapping::load(ObjectFilename, PGOFilename,
                                             CoverageArch);
  if (std::error_code EC = CoverageOrErr.getError()) {
    colored_ostream(errs(), raw_ostream::RED)
        << "error: Failed to load coverage: " << EC.message();
    errs() << "\n";
    return nullptr;
  }
  auto Coverage = std::move(CoverageOrErr.get());
  unsigned Mismatched = Coverage->getMismatchedCount();
  if (Mismatched) {
    colored_ostream(errs(), raw_ostream::RED)
        << "warning: " << Mismatched << " functions have mismatched data. ";
    errs() << "\n";
  }

  if (CompareFilenamesOnly) {
    auto CoveredFiles = Coverage.get()->getUniqueSourceFiles();
    for (auto &SF : SourceFiles) {
      StringRef SFBase = sys::path::filename(SF);
      for (const auto &CF : CoveredFiles)
        if (SFBase == sys::path::filename(CF)) {
          RemappedFilenames[CF] = SF;
          SF = CF;
          break;
        }
    }
  }

  return Coverage;
}

int CodeCoverageTool::run(Command Cmd, int argc, const char **argv) {
  // Print a stack trace if we signal out.
  sys::PrintStackTraceOnErrorSignal();
  PrettyStackTraceProgram X(argc, argv);
  llvm_shutdown_obj Y; // Call llvm_shutdown() on exit.

  cl::opt<std::string, true> ObjectFilename(
      cl::Positional, cl::Required, cl::location(this->ObjectFilename),
      cl::desc("Covered executable or object file."));

  cl::list<std::string> InputSourceFiles(
      cl::Positional, cl::desc("<Source files>"), cl::ZeroOrMore);

  cl::opt<std::string, true> PGOFilename(
      "instr-profile", cl::Required, cl::location(this->PGOFilename),
      cl::desc(
          "File with the profile data obtained after an instrumented run"));

  cl::opt<std::string> Arch(
      "arch", cl::desc("architecture of the coverage mapping binary"));

  cl::opt<bool> DebugDump("dump", cl::Optional,
                          cl::desc("Show internal debug dump"));

  cl::opt<bool> FilenameEquivalence(
      "filename-equivalence", cl::Optional,
      cl::desc("Treat source files as equivalent to paths in the coverage data "
               "when the file names match, even if the full paths do not"));

  cl::OptionCategory FilteringCategory("Function filtering options");

  cl::list<std::string> NameFilters(
      "name", cl::Optional,
      cl::desc("Show code coverage only for functions with the given name"),
      cl::ZeroOrMore, cl::cat(FilteringCategory));

  cl::list<std::string> NameRegexFilters(
      "name-regex", cl::Optional,
      cl::desc("Show code coverage only for functions that match the given "
               "regular expression"),
      cl::ZeroOrMore, cl::cat(FilteringCategory));

  cl::opt<double> RegionCoverageLtFilter(
      "region-coverage-lt", cl::Optional,
      cl::desc("Show code coverage only for functions with region coverage "
               "less than the given threshold"),
      cl::cat(FilteringCategory));

  cl::opt<double> RegionCoverageGtFilter(
      "region-coverage-gt", cl::Optional,
      cl::desc("Show code coverage only for functions with region coverage "
               "greater than the given threshold"),
      cl::cat(FilteringCategory));

  cl::opt<double> LineCoverageLtFilter(
      "line-coverage-lt", cl::Optional,
      cl::desc("Show code coverage only for functions with line coverage less "
               "than the given threshold"),
      cl::cat(FilteringCategory));

  cl::opt<double> LineCoverageGtFilter(
      "line-coverage-gt", cl::Optional,
      cl::desc("Show code coverage only for functions with line coverage "
               "greater than the given threshold"),
      cl::cat(FilteringCategory));

  cl::opt<cl::boolOrDefault> UseColor(
      "use-color", cl::desc("Emit colored output (default=autodetect)"),
      cl::init(cl::BOU_UNSET));

  auto commandLineParser = [&, this](int argc, const char **argv) -> int {
    cl::ParseCommandLineOptions(argc, argv, "LLVM code coverage tool\n");
    ViewOpts.Debug = DebugDump;
    CompareFilenamesOnly = FilenameEquivalence;

    ViewOpts.Colors = UseColor == cl::BOU_UNSET
                          ? sys::Process::StandardOutHasColors()
                          : UseColor == cl::BOU_TRUE;

    // Create the function filters
    if (!NameFilters.empty() || !NameRegexFilters.empty()) {
      auto NameFilterer = new CoverageFilters;
      for (const auto &Name : NameFilters)
        NameFilterer->push_back(llvm::make_unique<NameCoverageFilter>(Name));
      for (const auto &Regex : NameRegexFilters)
        NameFilterer->push_back(
            llvm::make_unique<NameRegexCoverageFilter>(Regex));
      Filters.push_back(std::unique_ptr<CoverageFilter>(NameFilterer));
    }
    if (RegionCoverageLtFilter.getNumOccurrences() ||
        RegionCoverageGtFilter.getNumOccurrences() ||
        LineCoverageLtFilter.getNumOccurrences() ||
        LineCoverageGtFilter.getNumOccurrences()) {
      auto StatFilterer = new CoverageFilters;
      if (RegionCoverageLtFilter.getNumOccurrences())
        StatFilterer->push_back(llvm::make_unique<RegionCoverageFilter>(
            RegionCoverageFilter::LessThan, RegionCoverageLtFilter));
      if (RegionCoverageGtFilter.getNumOccurrences())
        StatFilterer->push_back(llvm::make_unique<RegionCoverageFilter>(
            RegionCoverageFilter::GreaterThan, RegionCoverageGtFilter));
      if (LineCoverageLtFilter.getNumOccurrences())
        StatFilterer->push_back(llvm::make_unique<LineCoverageFilter>(
            LineCoverageFilter::LessThan, LineCoverageLtFilter));
      if (LineCoverageGtFilter.getNumOccurrences())
        StatFilterer->push_back(llvm::make_unique<LineCoverageFilter>(
            RegionCoverageFilter::GreaterThan, LineCoverageGtFilter));
      Filters.push_back(std::unique_ptr<CoverageFilter>(StatFilterer));
    }

    if (!Arch.empty() &&
        Triple(Arch).getArch() == llvm::Triple::ArchType::UnknownArch) {
      errs() << "error: Unknown architecture: " << Arch << "\n";
      return 1;
    }
    CoverageArch = Arch;

    for (const auto &File : InputSourceFiles) {
      SmallString<128> Path(File);
      if (!CompareFilenamesOnly)
        if (std::error_code EC = sys::fs::make_absolute(Path)) {
          errs() << "error: " << File << ": " << EC.message();
          return 1;
        }
      SourceFiles.push_back(Path.str());
    }
    return 0;
  };

  switch (Cmd) {
  case Show:
    return show(argc, argv, commandLineParser);
  case Report:
    return report(argc, argv, commandLineParser);
  }
  return 0;
}

int CodeCoverageTool::show(int argc, const char **argv,
                           CommandLineParserType commandLineParser) {

  cl::OptionCategory ViewCategory("Viewing options");

  cl::opt<bool> ShowLineExecutionCounts(
      "show-line-counts", cl::Optional,
      cl::desc("Show the execution counts for each line"), cl::init(true),
      cl::cat(ViewCategory));

  cl::opt<bool> ShowRegions(
      "show-regions", cl::Optional,
      cl::desc("Show the execution counts for each region"),
      cl::cat(ViewCategory));

  cl::opt<bool> ShowBestLineRegionsCounts(
      "show-line-counts-or-regions", cl::Optional,
      cl::desc("Show the execution counts for each line, or the execution "
               "counts for each region on lines that have multiple regions"),
      cl::cat(ViewCategory));

  cl::opt<bool> ShowExpansions("show-expansions", cl::Optional,
                               cl::desc("Show expanded source regions"),
                               cl::cat(ViewCategory));

  cl::opt<bool> ShowInstantiations("show-instantiations", cl::Optional,
                                   cl::desc("Show function instantiations"),
                                   cl::cat(ViewCategory));

  auto Err = commandLineParser(argc, argv);
  if (Err)
    return Err;

  ViewOpts.ShowLineNumbers = true;
  ViewOpts.ShowLineStats = ShowLineExecutionCounts.getNumOccurrences() != 0 ||
                           !ShowRegions || ShowBestLineRegionsCounts;
  ViewOpts.ShowRegionMarkers = ShowRegions || ShowBestLineRegionsCounts;
  ViewOpts.ShowLineStatsOrRegionMarkers = ShowBestLineRegionsCounts;
  ViewOpts.ShowExpandedRegions = ShowExpansions;
  ViewOpts.ShowFunctionInstantiations = ShowInstantiations;

  auto Coverage = load();
  if (!Coverage)
    return 1;

  if (!Filters.empty()) {
    // Show functions
    for (const auto &Function : Coverage->getCoveredFunctions()) {
      if (!Filters.matches(Function))
        continue;

      auto mainView = createFunctionView(Function, *Coverage);
      if (!mainView) {
        ViewOpts.colored_ostream(outs(), raw_ostream::RED)
            << "warning: Could not read coverage for '" << Function.Name;
        outs() << "\n";
        continue;
      }
      ViewOpts.colored_ostream(outs(), raw_ostream::CYAN) << Function.Name
                                                          << ":";
      outs() << "\n";
      mainView->render(outs(), /*WholeFile=*/false);
      outs() << "\n";
    }
    return 0;
  }

  // Show files
  bool ShowFilenames = SourceFiles.size() != 1;

  if (SourceFiles.empty())
    // Get the source files from the function coverage mapping
    for (StringRef Filename : Coverage->getUniqueSourceFiles())
      SourceFiles.push_back(Filename);

  for (const auto &SourceFile : SourceFiles) {
    auto mainView = createSourceFileView(SourceFile, *Coverage);
    if (!mainView) {
      ViewOpts.colored_ostream(outs(), raw_ostream::RED)
          << "warning: The file '" << SourceFile << "' isn't covered.";
      outs() << "\n";
      continue;
    }

    if (ShowFilenames) {
      ViewOpts.colored_ostream(outs(), raw_ostream::CYAN) << SourceFile << ":";
      outs() << "\n";
    }
    mainView->render(outs(), /*Wholefile=*/true);
    if (SourceFiles.size() > 1)
      outs() << "\n";
  }

  return 0;
}

int CodeCoverageTool::report(int argc, const char **argv,
                             CommandLineParserType commandLineParser) {
  auto Err = commandLineParser(argc, argv);
  if (Err)
    return Err;

  auto Coverage = load();
  if (!Coverage)
    return 1;

  CoverageReport Report(ViewOpts, std::move(Coverage));
  if (SourceFiles.empty())
    Report.renderFileReports(llvm::outs());
  else
    Report.renderFunctionReports(SourceFiles, llvm::outs());
  return 0;
}

int showMain(int argc, const char *argv[]) {
  CodeCoverageTool Tool;
  return Tool.run(CodeCoverageTool::Show, argc, argv);
}

int reportMain(int argc, const char *argv[]) {
  CodeCoverageTool Tool;
  return Tool.run(CodeCoverageTool::Report, argc, argv);
}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d16 1
a19 1
#include "RenderingSupport.h"
d24 1
a24 1
#include "llvm/ProfileData/Coverage/CoverageMapping.h"
d29 1
a29 1
#include "llvm/Support/MemoryBuffer.h"
d31 1
d33 1
a33 3
#include "llvm/Support/Program.h"
#include "llvm/Support/ThreadPool.h"
#include "llvm/Support/ToolOutputFile.h"
a53 12
  /// \brief Record (but do not print) an error message in a thread-safe way.
  void deferError(const Twine &Message, StringRef Whence = "");

  /// \brief Record (but do not print) a warning message in a thread-safe way.
  void deferWarning(const Twine &Message, StringRef Whence = "");

  /// \brief Print (and then clear) all deferred error and warning messages.
  void consumeDeferredMessages();

  /// \brief Append a reference to a private copy of \p Path into SourceFiles.
  void addCollectedPath(const std::string &Path);

d60 1
a60 1
                               const CoverageMapping &Coverage);
d64 1
a64 2
  createFunctionView(const FunctionRecord &Function,
                     const CoverageMapping &Coverage);
d68 1
a68 1
  createSourceFileView(StringRef SourceFile, const CoverageMapping &Coverage);
d70 1
a70 1
  /// \brief Load the coverage mapping data. Return nullptr if an error occured.
a72 6
  /// \brief If a demangler is available, demangle all symbol names.
  void demangleSymbols(const CoverageMapping &Coverage);

  /// \brief Demangle \p Sym if possible. Otherwise, just return \p Sym.
  StringRef getSymbolForHumans(StringRef Sym) const;

d75 1
a75 1
  typedef llvm::function_ref<int(int, const char **)> CommandLineParserType;
d87 3
a89 1
  std::vector<StringRef> SourceFiles;
a92 16

private:
  /// A cache for demangled symbol names.
  StringMap<std::string> DemangledNames;

  /// File paths (absolute, or otherwise) to input source files.
  std::vector<std::string> CollectedPaths;

  /// Errors and warnings which have not been printed.
  std::mutex DeferredMessagesLock;
  std::vector<std::string> DeferredMessages;

  /// A container for input source file buffers.
  std::mutex LoadedSourceFilesLock;
  std::vector<std::pair<std::string, std::unique_ptr<MemoryBuffer>>>
      LoadedSourceFiles;
d96 2
a97 4
static std::string getErrorString(const Twine &Message, StringRef Whence,
                                  bool Warning) {
  std::string Str = (Warning ? "warning" : "error");
  Str += ": ";
d99 2
a100 29
    Str += Whence.str() + ": ";
  Str += Message.str() + "\n";
  return Str;
}

void CodeCoverageTool::error(const Twine &Message, StringRef Whence) {
  errs() << getErrorString(Message, Whence, false);
}

void CodeCoverageTool::deferError(const Twine &Message, StringRef Whence) {
  std::unique_lock<std::mutex> Guard{DeferredMessagesLock};
  DeferredMessages.emplace_back(getErrorString(Message, Whence, false));
}

void CodeCoverageTool::deferWarning(const Twine &Message, StringRef Whence) {
  std::unique_lock<std::mutex> Guard{DeferredMessagesLock};
  DeferredMessages.emplace_back(getErrorString(Message, Whence, true));
}

void CodeCoverageTool::consumeDeferredMessages() {
  std::unique_lock<std::mutex> Guard{DeferredMessagesLock};
  for (const std::string &Message : DeferredMessages)
    ViewOpts.colored_ostream(errs(), raw_ostream::RED) << Message;
  DeferredMessages.clear();
}

void CodeCoverageTool::addCollectedPath(const std::string &Path) {
  CollectedPaths.push_back(Path);
  SourceFiles.emplace_back(CollectedPaths.back());
a105 1
  std::unique_lock<std::mutex> Guard{LoadedSourceFilesLock};
d116 1
a116 1
    deferError(EC.message(), SourceFile);
d123 4
a126 3
void CodeCoverageTool::attachExpansionSubViews(
    SourceCoverageView &View, ArrayRef<ExpansionRecord> Expansions,
    const CoverageMapping &Coverage) {
d138 2
a139 3
    auto SubView =
        SourceCoverageView::create(Expansion.Function.Name, SourceBuffer.get(),
                                   ViewOpts, std::move(ExpansionCoverage));
d147 1
a147 1
                                     const CoverageMapping &Coverage) {
d156 2
a157 3
  auto View = SourceCoverageView::create(getSymbolForHumans(Function.Name),
                                         SourceBuffer.get(), ViewOpts,
                                         std::move(FunctionCoverage));
d165 1
a165 1
                                       const CoverageMapping &Coverage) {
d174 2
a175 2
  auto View = SourceCoverageView::create(SourceFile, SourceBuffer.get(),
                                         ViewOpts, std::move(FileCoverage));
d178 1
a178 1
  for (const auto *Function : Coverage.getInstantiations(SourceFile)) {
d181 2
a182 3
    auto SubView = SourceCoverageView::create(
        getSymbolForHumans(Function->Name), SourceBuffer.get(), ViewOpts,
        std::move(SubViewCoverage));
d213 1
a213 1
  if (Error E = CoverageOrErr.takeError()) {
d215 2
a216 1
        << "error: Failed to load coverage: " << toString(std::move(E)) << "\n";
a239 2
  demangleSymbols(*Coverage);

d243 5
a247 75
void CodeCoverageTool::demangleSymbols(const CoverageMapping &Coverage) {
  if (!ViewOpts.hasDemangler())
    return;

  // Pass function names to the demangler in a temporary file.
  int InputFD;
  SmallString<256> InputPath;
  std::error_code EC =
      sys::fs::createTemporaryFile("demangle-in", "list", InputFD, InputPath);
  if (EC) {
    error(InputPath, EC.message());
    return;
  }
  tool_output_file InputTOF{InputPath, InputFD};

  unsigned NumSymbols = 0;
  for (const auto &Function : Coverage.getCoveredFunctions()) {
    InputTOF.os() << Function.Name << '\n';
    ++NumSymbols;
  }
  InputTOF.os().close();

  // Use another temporary file to store the demangler's output.
  int OutputFD;
  SmallString<256> OutputPath;
  EC = sys::fs::createTemporaryFile("demangle-out", "list", OutputFD,
                                    OutputPath);
  if (EC) {
    error(OutputPath, EC.message());
    return;
  }
  tool_output_file OutputTOF{OutputPath, OutputFD};
  OutputTOF.os().close();

  // Invoke the demangler.
  std::vector<const char *> ArgsV;
  for (const std::string &Arg : ViewOpts.DemanglerOpts)
    ArgsV.push_back(Arg.c_str());
  ArgsV.push_back(nullptr);
  StringRef InputPathRef = InputPath.str();
  StringRef OutputPathRef = OutputPath.str();
  StringRef StderrRef;
  const StringRef *Redirects[] = {&InputPathRef, &OutputPathRef, &StderrRef};
  std::string ErrMsg;
  int RC = sys::ExecuteAndWait(ViewOpts.DemanglerOpts[0], ArgsV.data(),
                               /*env=*/nullptr, Redirects, /*secondsToWait=*/0,
                               /*memoryLimit=*/0, &ErrMsg);
  if (RC) {
    error(ErrMsg, ViewOpts.DemanglerOpts[0]);
    return;
  }

  // Parse the demangler's output.
  auto BufOrError = MemoryBuffer::getFile(OutputPath);
  if (!BufOrError) {
    error(OutputPath, BufOrError.getError().message());
    return;
  }

  std::unique_ptr<MemoryBuffer> DemanglerBuf = std::move(*BufOrError);

  SmallVector<StringRef, 8> Symbols;
  StringRef DemanglerData = DemanglerBuf->getBuffer();
  DemanglerData.split(Symbols, '\n', /*MaxSplit=*/NumSymbols,
                      /*KeepEmpty=*/false);
  if (Symbols.size() != NumSymbols) {
    error("Demangler did not provide expected number of symbols");
    return;
  }

  // Cache the demangled names.
  unsigned I = 0;
  for (const auto &Function : Coverage.getCoveredFunctions())
    DemangledNames[Function.Name] = Symbols[I++];
}
a248 8
StringRef CodeCoverageTool::getSymbolForHumans(StringRef Sym) const {
  const auto DemangledName = DemangledNames.find(Sym);
  if (DemangledName == DemangledNames.end())
    return Sym;
  return DemangledName->getValue();
}

int CodeCoverageTool::run(Command Cmd, int argc, const char **argv) {
a266 9
  cl::opt<CoverageViewOptions::OutputFormat> Format(
      "format", cl::desc("Output format for line-based coverage reports"),
      cl::values(clEnumValN(CoverageViewOptions::OutputFormat::Text, "text",
                            "Text output"),
                 clEnumValN(CoverageViewOptions::OutputFormat::HTML, "html",
                            "HTML output"),
                 clEnumValEnd),
      cl::init(CoverageViewOptions::OutputFormat::Text));

a312 3
  cl::list<std::string> DemanglerOpts(
      "Xdemangler", cl::desc("<demangler-path>|<demangler-option>"));

d318 3
a320 25
    ViewOpts.Format = Format;
    switch (ViewOpts.Format) {
    case CoverageViewOptions::OutputFormat::Text:
      ViewOpts.Colors = UseColor == cl::BOU_UNSET
                            ? sys::Process::StandardOutHasColors()
                            : UseColor == cl::BOU_TRUE;
      break;
    case CoverageViewOptions::OutputFormat::HTML:
      if (UseColor == cl::BOU_FALSE)
        error("Color output cannot be disabled when generating html.");
      ViewOpts.Colors = true;
      break;
    }

    // If a demangler is supplied, check if it exists and register it.
    if (DemanglerOpts.size()) {
      auto DemanglerPathOrErr = sys::findProgramByName(DemanglerOpts[0]);
      if (!DemanglerPathOrErr) {
        error("Could not find the demangler!",
              DemanglerPathOrErr.getError().message());
        return 1;
      }
      DemanglerOpts[0] = *DemanglerPathOrErr;
      ViewOpts.DemanglerOpts.swap(DemanglerOpts);
    }
d366 1
a366 1
      addCollectedPath(Path.str());
a408 6
  cl::opt<std::string> ShowOutputDirectory(
      "output-dir", cl::init(""),
      cl::desc("Directory in which coverage information is written out"));
  cl::alias ShowOutputDirectoryA("o", cl::desc("Alias for --output-dir"),
                                 cl::aliasopt(ShowOutputDirectory));

a419 8
  ViewOpts.ShowOutputDirectory = ShowOutputDirectory;

  if (ViewOpts.hasOutputDirectory()) {
    if (auto E = sys::fs::create_directories(ViewOpts.ShowOutputDirectory)) {
      error("Could not create output directory!", E.message());
      return 1;
    }
  }
a424 2
  auto Printer = CoveragePrinter::create(ViewOpts);

d426 1
a426 8
    auto OSOrErr = Printer->createViewFile("functions", /*InToplevel=*/true);
    if (Error E = OSOrErr.takeError()) {
      error("Could not create view file!", toString(std::move(E)));
      return 1;
    }
    auto OS = std::move(OSOrErr.get());

    // Show functions.
d433 3
a435 3
        ViewOpts.colored_ostream(errs(), raw_ostream::RED)
            << "warning: Could not read coverage for '" << Function.Name << "'."
            << "\n";
d438 5
a442 2

      mainView->print(*OS.get(), /*WholeFile=*/false, /*ShowSourceName=*/true);
a443 2

    Printer->closeViewFile(std::move(OS));
d451 1
a451 1
    // Get the source files from the function coverage mapping.
d455 7
a461 5
  // Create an index out of the source files.
  if (ViewOpts.hasOutputDirectory()) {
    if (Error E = Printer->createIndexFile(SourceFiles)) {
      error("Could not create index file!", toString(std::move(E)));
      return 1;
a462 15
  }

  // In -output-dir mode, it's safe to use multiple threads to print files.
  unsigned ThreadCount = 1;
  if (ViewOpts.hasOutputDirectory())
    ThreadCount = std::thread::hardware_concurrency();
  ThreadPool Pool(ThreadCount);

  for (StringRef SourceFile : SourceFiles) {
    Pool.async([this, SourceFile, &Coverage, &Printer, ShowFilenames] {
      auto View = createSourceFileView(SourceFile, *Coverage);
      if (!View) {
        deferWarning("The file '" + SourceFile.str() + "' isn't covered.");
        return;
      }
d464 7
a470 11
      auto OSOrErr = Printer->createViewFile(SourceFile, /*InToplevel=*/false);
      if (Error E = OSOrErr.takeError()) {
        deferError("Could not create view file!", toString(std::move(E)));
        return;
      }
      auto OS = std::move(OSOrErr.get());

      View->print(*OS.get(), /*Wholefile=*/true,
                  /*ShowSourceName=*/ShowFilenames);
      Printer->closeViewFile(std::move(OS));
    });
a472 4
  Pool.wait();

  consumeDeferredMessages();

a480 3

  if (ViewOpts.Format == CoverageViewOptions::OutputFormat::HTML)
    error("HTML output for summary reports is not yet supported.");
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a32 1
#include "llvm/Support/ScopedPrinter.h"
a40 3
void exportCoverageDataToJson(const coverage::CoverageMapping &CoverageMapping,
                              raw_ostream &OS);

d49 1
a49 3
    Report,
    /// \brief The export command.
    Export
a51 3
  int run(Command Cmd, int argc, const char **argv);

private:
d55 8
a62 2
  /// \brief Print the warning message to the error output stream.
  void warning(const Twine &Message, StringRef Whence = "");
d64 1
a64 2
  /// \brief Convert \p Path into an absolute path and append it to the list
  /// of collected paths.
a66 4
  /// \brief If \p Path is a regular file, collect the path. If it's a
  /// directory, recursively collect all of the paths within the directory.
  void collectPaths(const std::string &Path);

d84 1
a84 1
  /// \brief Load the coverage mapping data. Return nullptr if an error occurred.
a86 3
  /// \brief Remove input source files which aren't mapped by \p Coverage.
  void removeUnmappedInputs(const CoverageMapping &Coverage);

d93 1
a93 3
  /// \brief Write out a source file view to the filesystem.
  void writeSourceFileView(StringRef SourceFile, CoverageMapping *Coverage,
                           CoveragePrinter *Printer, bool ShowFilenames);
d103 1
a103 4
  int export_(int argc, const char **argv,
              CommandLineParserType commandLineParser);

  std::vector<StringRef> ObjectFilenames;
d105 1
d107 1
a107 8

  /// The path to the indexed profile.
  std::string PGOFilename;

  /// A list of input source files.
  std::vector<std::string> SourceFiles;

  /// Whether or not we're in -filename-equivalence mode.
a108 3

  /// In -filename-equivalence mode, this maps absolute paths from the
  /// coverage mapping data to input source files.
a109 2

  /// The architecture the coverage mapping data targets.
d112 1
d116 3
d120 2
a121 1
  std::mutex ErrsLock;
d141 1
a141 3
  std::unique_lock<std::mutex> Guard{ErrsLock};
  ViewOpts.colored_ostream(errs(), raw_ostream::RED)
      << getErrorString(Message, Whence, false);
d144 3
a146 4
void CodeCoverageTool::warning(const Twine &Message, StringRef Whence) {
  std::unique_lock<std::mutex> Guard{ErrsLock};
  ViewOpts.colored_ostream(errs(), raw_ostream::RED)
      << getErrorString(Message, Whence, true);
d149 3
a151 12
void CodeCoverageTool::addCollectedPath(const std::string &Path) {
  if (CompareFilenamesOnly) {
    SourceFiles.emplace_back(Path);
  } else {
    SmallString<128> EffectivePath(Path);
    if (std::error_code EC = sys::fs::make_absolute(EffectivePath)) {
      error(EC.message(), Path);
      return;
    }
    sys::path::remove_dots(EffectivePath, /*remove_dot_dots=*/true);
    SourceFiles.emplace_back(EffectivePath.str());
  }
d154 6
a159 10
void CodeCoverageTool::collectPaths(const std::string &Path) {
  llvm::sys::fs::file_status Status;
  llvm::sys::fs::status(Path, Status);
  if (!llvm::sys::fs::exists(Status)) {
    if (CompareFilenamesOnly)
      addCollectedPath(Path);
    else
      error("Missing source file", Path);
    return;
  }
d161 3
a163 15
  if (llvm::sys::fs::is_regular_file(Status)) {
    addCollectedPath(Path);
    return;
  }

  if (llvm::sys::fs::is_directory(Status)) {
    std::error_code EC;
    for (llvm::sys::fs::recursive_directory_iterator F(Path, EC), E;
         F != E && !EC; F.increment(EC)) {
      if (llvm::sys::fs::is_regular_file(F->path()))
        addCollectedPath(F->path());
    }
    if (EC)
      warning(EC.message(), Path);
  }
d180 1
a180 1
    error(EC.message(), SourceFile);
d244 6
a249 1
    std::unique_ptr<SourceCoverageView> SubView{nullptr};
d251 8
a258 16
    StringRef Funcname = getSymbolForHumans(Function->Name);

    if (Function->ExecutionCount > 0) {
      auto SubViewCoverage = Coverage.getCoverageForFunction(*Function);
      auto SubViewExpansions = SubViewCoverage.getExpansions();
      SubView = SourceCoverageView::create(
          Funcname, SourceBuffer.get(), ViewOpts, std::move(SubViewCoverage));
      attachExpansionSubViews(*SubView, SubViewExpansions, Coverage);
    }

    unsigned FileID = Function->CountedRegions.front().FileID;
    unsigned Line = 0;
    for (const auto &CR : Function->CountedRegions)
      if (CR.FileID == FileID)
        Line = std::max(CR.LineEnd, Line);
    View->addInstantiation(Funcname, Line, std::move(SubView));
d275 4
a278 6
  for (StringRef ObjectFilename : ObjectFilenames)
    if (modifiedTimeGT(ObjectFilename, PGOFilename))
      warning("profile data may be out of date - object is newer",
              ObjectFilename);
  auto CoverageOrErr =
      CoverageMapping::load(ObjectFilenames, PGOFilename, CoverageArch);
d280 2
a281 2
    error("Failed to load coverage: " + toString(std::move(E)),
          join(ObjectFilenames.begin(), ObjectFilenames.end(), ", "));
d286 5
a290 2
  if (Mismatched)
    warning(utostr(Mismatched) + " functions have mismatched data");
d292 2
a293 21
  if (!SourceFiles.empty())
    removeUnmappedInputs(*Coverage);

  demangleSymbols(*Coverage);

  return Coverage;
}

void CodeCoverageTool::removeUnmappedInputs(const CoverageMapping &Coverage) {
  std::vector<StringRef> CoveredFiles = Coverage.getUniqueSourceFiles();

  auto UncoveredFilesIt = SourceFiles.end();
  if (!CompareFilenamesOnly) {
    // The user may have specified source files which aren't in the coverage
    // mapping. Filter these files away.
    UncoveredFilesIt = std::remove_if(
        SourceFiles.begin(), SourceFiles.end(), [&](const std::string &SF) {
          return !std::binary_search(CoveredFiles.begin(), CoveredFiles.end(),
                                     SF);
        });
  } else {
d296 1
a296 1
      for (const auto &CF : CoveredFiles) {
a301 1
      }
a302 3
    UncoveredFilesIt = std::remove_if(
        SourceFiles.begin(), SourceFiles.end(),
        [&](const std::string &SF) { return !RemappedFilenames.count(SF); });
d305 3
a307 1
  SourceFiles.erase(UncoveredFilesIt, SourceFiles.end());
a392 22
void CodeCoverageTool::writeSourceFileView(StringRef SourceFile,
                                           CoverageMapping *Coverage,
                                           CoveragePrinter *Printer,
                                           bool ShowFilenames) {
  auto View = createSourceFileView(SourceFile, *Coverage);
  if (!View) {
    warning("The file '" + SourceFile + "' isn't covered.");
    return;
  }

  auto OSOrErr = Printer->createViewFile(SourceFile, /*InToplevel=*/false);
  if (Error E = OSOrErr.takeError()) {
    error("Could not create view file!", toString(std::move(E)));
    return;
  }
  auto OS = std::move(OSOrErr.get());

  View->print(*OS.get(), /*Wholefile=*/true,
              /*ShowSourceName=*/ShowFilenames);
  Printer->closeViewFile(std::move(OS));
}

d394 3
a396 6
  cl::opt<std::string> CovFilename(
      cl::Positional, cl::desc("Covered executable or object file."));

  cl::list<std::string> CovFilenames(
      "object", cl::desc("Coverage executable or object file"), cl::ZeroOrMore,
      cl::CommaSeparated);
a400 4
  cl::opt<bool> DebugDumpCollectedPaths(
      "dump-collected-paths", cl::Optional, cl::Hidden,
      cl::desc("Show the collected paths to source files"));

d417 2
a418 1
                            "HTML output")),
a474 9
    if (!CovFilename.empty())
      ObjectFilenames.emplace_back(CovFilename);
    for (const std::string &Filename : CovFilenames)
      ObjectFilenames.emplace_back(Filename);
    if (ObjectFilenames.empty()) {
      errs() << "No filenames specified!\n";
      ::exit(1);
    }

d484 1
a484 1
        errs() << "Color output cannot be disabled when generating html.\n";
d533 1
a533 1
      error("Unknown architecture: " + Arch);
d538 8
a545 7
    for (const std::string &File : InputSourceFiles)
      collectPaths(File);

    if (DebugDumpCollectedPaths) {
      for (const std::string &SF : SourceFiles)
        outs() << SF << '\n';
      ::exit(0);
a546 1

a554 2
  case Export:
    return export_(argc, argv, commandLineParser);
a593 9
  cl::opt<uint32_t> TabSize(
      "tab-size", cl::init(2),
      cl::desc(
          "Set tab expansion size for html coverage reports (default = 2)"));

  cl::opt<std::string> ProjectTitle(
      "project-title", cl::Optional,
      cl::desc("Set project title for the coverage report"));

a605 2
  ViewOpts.TabSize = TabSize;
  ViewOpts.ProjectTitle = ProjectTitle;
a613 13
  sys::fs::file_status Status;
  if (sys::fs::status(PGOFilename, Status)) {
    error("profdata file error: can not get the file status. \n");
    return 1;
  }

  auto ModifiedTime = Status.getLastModificationTime();
  std::string ModifiedTimeStr = to_string(ModifiedTime);
  size_t found = ModifiedTimeStr.rfind(':');
  ViewOpts.CreatedTimeStr = (found != std::string::npos)
                                ? "Created: " + ModifiedTimeStr.substr(0, found)
                                : "Created: " + ModifiedTimeStr;

d635 3
a637 1
        warning("Could not read coverage for '" + Function.Name + "'.");
d649 1
a649 3
  bool ShowFilenames =
      (SourceFiles.size() != 1) || ViewOpts.hasOutputDirectory() ||
      (ViewOpts.Format == CoverageViewOptions::OutputFormat::HTML);
d658 1
a658 1
    if (Error E = Printer->createIndexFile(SourceFiles, *Coverage)) {
d664 25
a688 13
  // FIXME: Sink the hardware_concurrency() == 1 check into ThreadPool.
  if (!ViewOpts.hasOutputDirectory() ||
      std::thread::hardware_concurrency() == 1) {
    for (const std::string &SourceFile : SourceFiles)
      writeSourceFileView(SourceFile, Coverage.get(), Printer.get(),
                          ShowFilenames);
  } else {
    // In -output-dir mode, it's safe to use multiple threads to print files.
    ThreadPool Pool;
    for (const std::string &SourceFile : SourceFiles)
      Pool.async(&CodeCoverageTool::writeSourceFileView, this, SourceFile,
                 Coverage.get(), Printer.get(), ShowFilenames);
    Pool.wait();
d691 4
d711 1
a711 1
  CoverageReport Report(ViewOpts, *Coverage.get());
a718 18
int CodeCoverageTool::export_(int argc, const char **argv,
                              CommandLineParserType commandLineParser) {

  auto Err = commandLineParser(argc, argv);
  if (Err)
    return Err;

  auto Coverage = load();
  if (!Coverage) {
    error("Could not load coverage information");
    return 1;
  }

  exportCoverageDataToJson(*Coverage.get(), outs());

  return 0;
}

a726 5
}

int exportMain(int argc, const char *argv[]) {
  CodeCoverageTool Tool;
  return Tool.run(CodeCoverageTool::Export, argc, argv);
@


