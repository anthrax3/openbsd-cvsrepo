head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.3.0.2
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.44;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.00;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===- CoverageSummaryInfo.h - Coverage summary for function/file ---------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// These structures are used to represent code coverage metrics
// for functions/files.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_COV_COVERAGESUMMARYINFO_H
#define LLVM_COV_COVERAGESUMMARYINFO_H

#include "llvm/ProfileData/CoverageMapping.h"
#include "llvm/Support/raw_ostream.h"

namespace llvm {

/// \brief Provides information about region coverage for a function/file.
struct RegionCoverageInfo {
  /// \brief The number of regions that were executed at least once.
  size_t Covered;

  /// \brief The number of regions that weren't executed.
  size_t NotCovered;

  /// \brief The total number of regions in a function/file.
  size_t NumRegions;

  RegionCoverageInfo() : Covered(0), NotCovered(0), NumRegions(0) {}

  RegionCoverageInfo(size_t Covered, size_t NumRegions)
      : Covered(Covered), NotCovered(NumRegions - Covered),
        NumRegions(NumRegions) {}

  RegionCoverageInfo &operator+=(const RegionCoverageInfo &RHS) {
    Covered += RHS.Covered;
    NotCovered += RHS.NotCovered;
    NumRegions += RHS.NumRegions;
    return *this;
  }

  bool isFullyCovered() const { return Covered == NumRegions; }

  double getPercentCovered() const {
    return double(Covered) / double(NumRegions) * 100.0;
  }
};

/// \brief Provides information about line coverage for a function/file.
struct LineCoverageInfo {
  /// \brief The number of lines that were executed at least once.
  size_t Covered;

  /// \brief The number of lines that weren't executed.
  size_t NotCovered;

  /// \brief The number of lines that aren't code.
  size_t NonCodeLines;

  /// \brief The total number of lines in a function/file.
  size_t NumLines;

  LineCoverageInfo()
      : Covered(0), NotCovered(0), NonCodeLines(0), NumLines(0) {}

  LineCoverageInfo(size_t Covered, size_t NumNonCodeLines, size_t NumLines)
      : Covered(Covered), NotCovered(NumLines - NumNonCodeLines - Covered),
        NonCodeLines(NumNonCodeLines), NumLines(NumLines) {}

  LineCoverageInfo &operator+=(const LineCoverageInfo &RHS) {
    Covered += RHS.Covered;
    NotCovered += RHS.NotCovered;
    NonCodeLines += RHS.NonCodeLines;
    NumLines += RHS.NumLines;
    return *this;
  }

  bool isFullyCovered() const { return Covered == (NumLines - NonCodeLines); }

  double getPercentCovered() const {
    return double(Covered) / double(NumLines - NonCodeLines) * 100.0;
  }
};

/// \brief Provides information about function coverage for a file.
struct FunctionCoverageInfo {
  /// \brief The number of functions that were executed.
  size_t Executed;

  /// \brief The total number of functions in this file.
  size_t NumFunctions;

  FunctionCoverageInfo() : Executed(0), NumFunctions(0) {}

  FunctionCoverageInfo(size_t Executed, size_t NumFunctions)
      : Executed(Executed), NumFunctions(NumFunctions) {}

  void addFunction(bool Covered) {
    if (Covered)
      ++Executed;
    ++NumFunctions;
  }

  bool isFullyCovered() const { return Executed == NumFunctions; }

  double getPercentCovered() const {
    return double(Executed) / double(NumFunctions) * 100.0;
  }
};

/// \brief A summary of function's code coverage.
struct FunctionCoverageSummary {
  StringRef Name;
  uint64_t ExecutionCount;
  RegionCoverageInfo RegionCoverage;
  LineCoverageInfo LineCoverage;

  FunctionCoverageSummary(StringRef Name) : Name(Name), ExecutionCount(0) {}

  FunctionCoverageSummary(StringRef Name, uint64_t ExecutionCount,
                          const RegionCoverageInfo &RegionCoverage,
                          const LineCoverageInfo &LineCoverage)
      : Name(Name), ExecutionCount(ExecutionCount),
        RegionCoverage(RegionCoverage), LineCoverage(LineCoverage) {
  }

  /// \brief Compute the code coverage summary for the given function coverage
  /// mapping record.
  static FunctionCoverageSummary
  get(const coverage::FunctionRecord &Function);
};

/// \brief A summary of file's code coverage.
struct FileCoverageSummary {
  StringRef Name;
  RegionCoverageInfo RegionCoverage;
  LineCoverageInfo LineCoverage;
  FunctionCoverageInfo FunctionCoverage;

  FileCoverageSummary(StringRef Name) : Name(Name) {}

  void addFunction(const FunctionCoverageSummary &Function) {
    RegionCoverage += Function.RegionCoverage;
    LineCoverage += Function.LineCoverage;
    FunctionCoverage.addFunction(/*Covered=*/Function.ExecutionCount > 0);
  }
};

} // namespace llvm

#endif // LLVM_COV_COVERAGESUMMARYINFO_H
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d18 1
a18 1
#include "llvm/ProfileData/Coverage/CoverageMapping.h"
a49 2
    if (NumRegions == 0)
      return 0.0;
a85 2
    if (NumLines - NonCodeLines == 0)
      return 0.0;
a111 2
    if (NumFunctions == 0)
      return 0.0;
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d64 3
d70 2
a71 1
  LineCoverageInfo() : Covered(0), NotCovered(0), NumLines(0) {}
d73 3
a75 2
  LineCoverageInfo(size_t Covered, size_t NumLines)
      : Covered(Covered), NotCovered(NumLines - Covered), NumLines(NumLines) {}
d80 1
d85 1
a85 1
  bool isFullyCovered() const { return Covered == NumLines; }
d88 1
a88 1
    if (NumLines == 0)
d90 1
a90 1
    return double(Covered) / double(NumLines) * 100.0;
a141 4

  /// \brief Update the summary with information from another instantiation
  /// of this function.
  void update(const FunctionCoverageSummary &Summary);
a149 1
  FunctionCoverageInfo InstantiationCoverage;
a156 4
  }

  void addInstantiation(const FunctionCoverageSummary &Function) {
    InstantiationCoverage.addFunction(/*Covered=*/Function.ExecutionCount > 0);
@


