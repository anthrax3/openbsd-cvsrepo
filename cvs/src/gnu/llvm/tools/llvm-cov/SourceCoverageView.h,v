head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.44;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.00;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===- SourceCoverageView.h - Code coverage view for source code ----------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This class implements rendering for code coverage of source code.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_COV_SOURCECOVERAGEVIEW_H
#define LLVM_COV_SOURCECOVERAGEVIEW_H

#include "CoverageViewOptions.h"
#include "llvm/ProfileData/CoverageMapping.h"
#include "llvm/Support/MemoryBuffer.h"
#include <vector>

namespace llvm {

class SourceCoverageView;

/// \brief A view that represents a macro or include expansion
struct ExpansionView {
  coverage::CounterMappingRegion Region;
  std::unique_ptr<SourceCoverageView> View;

  ExpansionView(const coverage::CounterMappingRegion &Region,
                std::unique_ptr<SourceCoverageView> View)
      : Region(Region), View(std::move(View)) {}
  ExpansionView(ExpansionView &&RHS)
      : Region(std::move(RHS.Region)), View(std::move(RHS.View)) {}
  ExpansionView &operator=(ExpansionView &&RHS) {
    Region = std::move(RHS.Region);
    View = std::move(RHS.View);
    return *this;
  }

  unsigned getLine() const { return Region.LineStart; }
  unsigned getStartCol() const { return Region.ColumnStart; }
  unsigned getEndCol() const { return Region.ColumnEnd; }

  friend bool operator<(const ExpansionView &LHS, const ExpansionView &RHS) {
    return LHS.Region.startLoc() < RHS.Region.startLoc();
  }
};

/// \brief A view that represents a function instantiation
struct InstantiationView {
  StringRef FunctionName;
  unsigned Line;
  std::unique_ptr<SourceCoverageView> View;

  InstantiationView(StringRef FunctionName, unsigned Line,
                    std::unique_ptr<SourceCoverageView> View)
      : FunctionName(FunctionName), Line(Line), View(std::move(View)) {}
  InstantiationView(InstantiationView &&RHS)
      : FunctionName(std::move(RHS.FunctionName)), Line(std::move(RHS.Line)),
        View(std::move(RHS.View)) {}
  InstantiationView &operator=(InstantiationView &&RHS) {
    FunctionName = std::move(RHS.FunctionName);
    Line = std::move(RHS.Line);
    View = std::move(RHS.View);
    return *this;
  }

  friend bool operator<(const InstantiationView &LHS,
                        const InstantiationView &RHS) {
    return LHS.Line < RHS.Line;
  }
};

/// \brief A code coverage view of a specific source file.
/// It can have embedded coverage views.
class SourceCoverageView {
private:
  /// \brief Coverage information for a single line.
  struct LineCoverageInfo {
    uint64_t ExecutionCount;
    unsigned RegionCount;
    bool Mapped;

    LineCoverageInfo() : ExecutionCount(0), RegionCount(0), Mapped(false) {}

    bool isMapped() const { return Mapped; }

    bool hasMultipleRegions() const { return RegionCount > 1; }

    void addRegionStartCount(uint64_t Count) {
      // The max of all region starts is the most interesting value.
      addRegionCount(RegionCount ? std::max(ExecutionCount, Count) : Count);
      ++RegionCount;
    }

    void addRegionCount(uint64_t Count) {
      Mapped = true;
      ExecutionCount = Count;
    }
  };

  const MemoryBuffer &File;
  const CoverageViewOptions &Options;
  coverage::CoverageData CoverageInfo;
  std::vector<ExpansionView> ExpansionSubViews;
  std::vector<InstantiationView> InstantiationSubViews;

  /// \brief Render a source line with highlighting.
  void renderLine(raw_ostream &OS, StringRef Line, int64_t LineNumber,
                  const coverage::CoverageSegment *WrappedSegment,
                  ArrayRef<const coverage::CoverageSegment *> Segments,
                  unsigned ExpansionCol);

  void renderIndent(raw_ostream &OS, unsigned Level);

  void renderViewDivider(unsigned Offset, unsigned Length, raw_ostream &OS);

  /// \brief Render the line's execution count column.
  void renderLineCoverageColumn(raw_ostream &OS, const LineCoverageInfo &Line);

  /// \brief Render the line number column.
  void renderLineNumberColumn(raw_ostream &OS, unsigned LineNo);

  /// \brief Render all the region's execution counts on a line.
  void
  renderRegionMarkers(raw_ostream &OS,
                      ArrayRef<const coverage::CoverageSegment *> Segments);

  static const unsigned LineCoverageColumnWidth = 7;
  static const unsigned LineNumberColumnWidth = 5;

public:
  SourceCoverageView(const MemoryBuffer &File,
                     const CoverageViewOptions &Options,
                     coverage::CoverageData &&CoverageInfo)
      : File(File), Options(Options), CoverageInfo(std::move(CoverageInfo)) {}

  const CoverageViewOptions &getOptions() const { return Options; }

  /// \brief Add an expansion subview to this view.
  void addExpansion(const coverage::CounterMappingRegion &Region,
                    std::unique_ptr<SourceCoverageView> View) {
    ExpansionSubViews.emplace_back(Region, std::move(View));
  }

  /// \brief Add a function instantiation subview to this view.
  void addInstantiation(StringRef FunctionName, unsigned Line,
                        std::unique_ptr<SourceCoverageView> View) {
    InstantiationSubViews.emplace_back(FunctionName, Line, std::move(View));
  }

  /// \brief Print the code coverage information for a specific
  /// portion of a source file to the output stream.
  void render(raw_ostream &OS, bool WholeFile, unsigned IndentLevel = 0);
};

} // namespace llvm

#endif // LLVM_COV_SOURCECOVERAGEVIEW_H
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d9 3
a11 3
///
/// \file This class implements rendering for code coverage of source code.
///
d18 1
a18 1
#include "llvm/ProfileData/Coverage/CoverageMapping.h"
d26 1
a26 1
/// \brief A view that represents a macro or include expansion.
d51 1
a51 1
/// \brief A view that represents a function instantiation.
d76 26
a101 31
/// \brief Coverage statistics for a single line.
struct LineCoverageStats {
  uint64_t ExecutionCount;
  unsigned RegionCount;
  bool Mapped;

  LineCoverageStats() : ExecutionCount(0), RegionCount(0), Mapped(false) {}

  bool isMapped() const { return Mapped; }

  bool hasMultipleRegions() const { return RegionCount > 1; }

  void addRegionStartCount(uint64_t Count) {
    // The max of all region starts is the most interesting value.
    addRegionCount(RegionCount ? std::max(ExecutionCount, Count) : Count);
    ++RegionCount;
  }

  void addRegionCount(uint64_t Count) {
    Mapped = true;
    ExecutionCount = Count;
  }
};

/// \brief A file manager that handles format-aware file creation.
class CoveragePrinter {
  const CoverageViewOptions &Opts;

public:
  struct StreamDestructor {
    void operator()(raw_ostream *OS) const;
a103 51
  using OwnedStream = std::unique_ptr<raw_ostream, StreamDestructor>;

protected:
  CoveragePrinter(const CoverageViewOptions &Opts) : Opts(Opts) {}

  /// \brief Return `OutputDir/ToplevelDir/Path.Extension`. If \p InToplevel is
  /// false, skip the ToplevelDir component. If \p Relative is false, skip the
  /// OutputDir component.
  std::string getOutputPath(StringRef Path, StringRef Extension,
                            bool InToplevel, bool Relative = true);

  /// \brief If directory output is enabled, create a file in that directory
  /// at the path given by getOutputPath(). Otherwise, return stdout.
  Expected<OwnedStream> createOutputStream(StringRef Path, StringRef Extension,
                                           bool InToplevel);

  /// \brief Return the sub-directory name for file coverage reports.
  static StringRef getCoverageDir() { return "coverage"; }

public:
  static std::unique_ptr<CoveragePrinter>
  create(const CoverageViewOptions &Opts);

  virtual ~CoveragePrinter() {}

  /// @@name File Creation Interface
  /// @@{

  /// \brief Create a file to print a coverage view into.
  virtual Expected<OwnedStream> createViewFile(StringRef Path,
                                               bool InToplevel) = 0;

  /// \brief Close a file which has been used to print a coverage view.
  virtual void closeViewFile(OwnedStream OS) = 0;

  /// \brief Create an index which lists reports for the given source files.
  virtual Error createIndexFile(ArrayRef<StringRef> SourceFiles) = 0;

  /// @@}
};

/// \brief A code coverage view of a source file or function.
///
/// A source coverage view and its nested sub-views form a file-oriented
/// representation of code coverage data. This view can be printed out by a
/// renderer which implements the Rendering Interface.
class SourceCoverageView {
  /// A function or file name.
  StringRef SourceName;

  /// A memory buffer backing the source on display.
a104 2

  /// Various options to guide the coverage renderer.
a105 2

  /// Complete coverage information about the source on display.
a106 2

  /// A container for all expansions (e.g macros) in the source on display.
a107 3

  /// A container for all instantiations (e.g template functions) in the source
  /// on display.
d110 5
a114 21
protected:
  struct LineRef {
    StringRef Line;
    int64_t LineNo;

    LineRef(StringRef Line, int64_t LineNo) : Line(Line), LineNo(LineNo) {}
  };

  using CoverageSegmentArray = ArrayRef<const coverage::CoverageSegment *>;

  /// @@name Rendering Interface
  /// @@{

  /// \brief Render a header for the view.
  virtual void renderViewHeader(raw_ostream &OS) = 0;

  /// \brief Render a footer for the view.
  virtual void renderViewFooter(raw_ostream &OS) = 0;

  /// \brief Render the source name for the view.
  virtual void renderSourceName(raw_ostream &OS) = 0;
d116 1
a116 2
  /// \brief Render the line prefix at the given \p ViewDepth.
  virtual void renderLinePrefix(raw_ostream &OS, unsigned ViewDepth) = 0;
d118 1
a118 11
  /// \brief Render the line suffix at the given \p ViewDepth.
  virtual void renderLineSuffix(raw_ostream &OS, unsigned ViewDepth) = 0;

  /// \brief Render a view divider at the given \p ViewDepth.
  virtual void renderViewDivider(raw_ostream &OS, unsigned ViewDepth) = 0;

  /// \brief Render a source line with highlighting.
  virtual void renderLine(raw_ostream &OS, LineRef L,
                          const coverage::CoverageSegment *WrappedSegment,
                          CoverageSegmentArray Segments, unsigned ExpansionCol,
                          unsigned ViewDepth) = 0;
d121 1
a121 2
  virtual void renderLineCoverageColumn(raw_ostream &OS,
                                        const LineCoverageStats &Line) = 0;
d124 1
a124 1
  virtual void renderLineNumberColumn(raw_ostream &OS, unsigned LineNo) = 0;
d127 3
a129 24
  virtual void renderRegionMarkers(raw_ostream &OS,
                                   CoverageSegmentArray Segments,
                                   unsigned ViewDepth) = 0;

  /// \brief Render the site of an expansion.
  virtual void
  renderExpansionSite(raw_ostream &OS, LineRef L,
                      const coverage::CoverageSegment *WrappedSegment,
                      CoverageSegmentArray Segments, unsigned ExpansionCol,
                      unsigned ViewDepth) = 0;

  /// \brief Render an expansion view and any nested views.
  virtual void renderExpansionView(raw_ostream &OS, ExpansionView &ESV,
                                   unsigned ViewDepth) = 0;

  /// \brief Render an instantiation view and any nested views.
  virtual void renderInstantiationView(raw_ostream &OS, InstantiationView &ISV,
                                       unsigned ViewDepth) = 0;

  /// @@}

  /// \brief Format a count using engineering notation with 3 significant
  /// digits.
  static std::string formatCount(uint64_t N);
d131 2
a132 2
  /// \brief Check if region marker output is expected for a line.
  bool shouldRenderRegionMarkers(bool LineHasMultipleRegions) const;
d134 2
a135 4
  /// \brief Check if there are any sub-views attached to this view.
  bool hasSubViews() const;

  SourceCoverageView(StringRef SourceName, const MemoryBuffer &File,
d138 1
a138 12
      : SourceName(SourceName), File(File), Options(Options),
        CoverageInfo(std::move(CoverageInfo)) {}

public:
  static std::unique_ptr<SourceCoverageView>
  create(StringRef SourceName, const MemoryBuffer &File,
         const CoverageViewOptions &Options,
         coverage::CoverageData &&CoverageInfo);

  virtual ~SourceCoverageView() {}

  StringRef getSourceName() const { return SourceName; }
d144 3
a146 1
                    std::unique_ptr<SourceCoverageView> View);
d150 3
a152 1
                        std::unique_ptr<SourceCoverageView> View);
d154 3
a156 4
  /// \brief Print the code coverage information for a specific portion of a
  /// source file to the output stream.
  void print(raw_ostream &OS, bool WholeFile, bool ShowSourceName,
             unsigned ViewDepth = 0);
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d60 9
d102 2
a111 2
  const CoverageViewOptions &Opts;

d118 1
a118 1
                            bool InToplevel, bool Relative = true) const;
d123 1
a123 1
                                           bool InToplevel) const;
d145 1
a145 2
  virtual Error createIndexFile(ArrayRef<std::string> SourceFiles,
                                const coverage::CoverageMapping &Coverage) = 0;
a174 3
  /// Get the first uncovered line number for the source file.
  unsigned getFirstUncoveredLineNo();

d195 1
a195 1
  virtual void renderSourceName(raw_ostream &OS, bool WholeFile) = 0;
a238 8
  /// \brief Render \p Title, a project title if one is available, and the
  /// created time.
  virtual void renderTitle(raw_ostream &OS, StringRef CellText) = 0;

  /// \brief Render the table header for a given source file.
  virtual void renderTableHeader(raw_ostream &OS, unsigned FirstUncoveredLineNo,
                                 unsigned IndentLevel) = 0;

d265 1
a265 2
  /// \brief Return the source name formatted for the host OS.
  std::string getSourceName() const;
@


