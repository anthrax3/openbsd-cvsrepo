head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.3
	OPENBSD_6_2:1.1.1.2.0.2
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.24.08.33.00;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	so2WA7LCP6wbxtYl;

1.1.1.3
date	2017.10.04.20.27.35;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===-- FindBugs.cpp - Run Many Different Optimizations -------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an interface that allows bugpoint to choose different 
// combinations of optimizations to run on the selected input. Bugpoint will 
// run these optimizations and record the success/failure of each. This way
// we can hopefully spot bugs in the optimizations.
//
//===----------------------------------------------------------------------===//

#include "BugDriver.h"
#include "ToolRunner.h"
#include "llvm/Pass.h"
#include "llvm/Support/FileSystem.h"
#include "llvm/Support/raw_ostream.h"
#include <algorithm>
#include <ctime>
using namespace llvm;

/// runManyPasses - Take the specified pass list and create different 
/// combinations of passes to compile the program with. Compile the program with
/// each set and mark test to see if it compiled correctly. If the passes 
/// compiled correctly output nothing and rearrange the passes into a new order.
/// If the passes did not compile correctly, output the command required to 
/// recreate the failure. This returns true if a compiler error is found.
///
bool BugDriver::runManyPasses(const std::vector<std::string> &AllPasses,
                              std::string &ErrMsg) {
  setPassesToRun(AllPasses);
  outs() << "Starting bug finding procedure...\n\n";
  
  // Creating a reference output if necessary
  if (initializeExecutionEnvironment()) return false;
  
  outs() << "\n";
  if (ReferenceOutputFile.empty()) {
    outs() << "Generating reference output from raw program: \n";
    if (!createReferenceFile(Program))
      return false;
  }
  
  srand(time(nullptr));
  
  unsigned num = 1;
  while(1) {  
    //
    // Step 1: Randomize the order of the optimizer passes.
    //
    std::random_shuffle(PassesToRun.begin(), PassesToRun.end());
    
    //
    // Step 2: Run optimizer passes on the program and check for success.
    //
    outs() << "Running selected passes on program to test for crash: ";
    for(int i = 0, e = PassesToRun.size(); i != e; i++) {
      outs() << "-" << PassesToRun[i] << " ";
    }
    
    std::string Filename;
    if(runPasses(Program, PassesToRun, Filename, false)) {
      outs() << "\n";
      outs() << "Optimizer passes caused failure!\n\n";
      debugOptimizerCrash();
      return true;
    } else {
      outs() << "Combination " << num << " optimized successfully!\n";
    }
    
    //
    // Step 3: Compile the optimized code.
    //
    outs() << "Running the code generator to test for a crash: ";
    std::string Error;
    compileProgram(Program, &Error);
    if (!Error.empty()) {
      outs() << "\n*** compileProgram threw an exception: ";
      outs() << Error;
      return debugCodeGeneratorCrash(ErrMsg);
    }
    outs() << '\n';
    
    //
    // Step 4: Run the program and compare its output to the reference 
    // output (created above).
    //
    outs() << "*** Checking if passes caused miscompliation:\n";
    bool Diff = diffProgram(Program, Filename, "", false, &Error);
    if (Error.empty() && Diff) {
      outs() << "\n*** diffProgram returned true!\n";
      debugMiscompilation(&Error);
      if (Error.empty())
        return true;
    }
    if (!Error.empty()) {
      errs() << Error;
      debugCodeGeneratorCrash(ErrMsg);
      return true;
    }
    outs() << "\n*** diff'd output matches!\n";
    
    sys::fs::remove(Filename);
    
    outs() << "\n\n";
    num++;
  } //end while
  
  // Unreachable.
}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d10 2
a11 2
// This file defines an interface that allows bugpoint to choose different
// combinations of optimizations to run on the selected input. Bugpoint will
d26 9
a34 2
Error
BugDriver::runManyPasses(const std::vector<std::string> &AllPasses) {
d37 1
a37 1

d39 2
a40 3
  if (Error E = initializeExecutionEnvironment())
    return E;

d44 2
a45 2
    if (Error E = createReferenceFile(Program))
      return E;
d47 1
a47 1

d49 1
a49 1

d51 1
a51 1
  while (1) {
d56 1
a56 1

d61 1
a61 1
    for (int i = 0, e = PassesToRun.size(); i != e; i++) {
d64 1
a64 1

d66 1
a66 1
    if (runPasses(Program, PassesToRun, Filename, false)) {
d69 2
a70 1
      return debugOptimizerCrash();
d74 1
a74 1

d79 3
a81 1
    if (Error E = compileProgram(Program)) {
d83 2
a84 2
      outs() << toString(std::move(E));
      return debugCodeGeneratorCrash();
d87 1
a87 1

d89 1
a89 1
    // Step 4: Run the program and compare its output to the reference
d93 6
a98 4
    Expected<bool> Diff = diffProgram(Program, Filename, "", false);
    if (Error E = Diff.takeError()) {
      errs() << toString(std::move(E));
      return debugCodeGeneratorCrash();
d100 4
a103 5
    if (*Diff) {
      outs() << "\n*** diffProgram returned true!\n";
      Error E = debugMiscompilation();
      if (!E)
        return Error::success();
d106 1
a106 1

d108 1
a108 1

d111 2
a112 2
  } // end while

@


1.1.1.3
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@a23 1
#include <random>
d42 2
a43 1
  std::mt19937 randomness(std::random_device{}());
d49 1
a49 1
    std::shuffle(PassesToRun.begin(), PassesToRun.end(), randomness);
@


