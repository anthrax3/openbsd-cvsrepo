head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2_BASE:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.4
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.44;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.00;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===- llvm-pdbdump.cpp - Dump debug info from a PDB file -------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// Dumps debug information present in PDB files.  This utility makes use of
// the Microsoft Windows SDK, so will not compile or run on non-Windows
// platforms.
//
//===----------------------------------------------------------------------===//

#include "llvm-pdbdump.h"
#include "CompilandDumper.h"
#include "ExternalSymbolDumper.h"
#include "FunctionDumper.h"
#include "LinePrinter.h"
#include "TypeDumper.h"
#include "VariableDumper.h"

#include "llvm/ADT/ArrayRef.h"
#include "llvm/ADT/BitVector.h"
#include "llvm/ADT/DenseMap.h"
#include "llvm/ADT/StringExtras.h"
#include "llvm/Config/config.h"
#include "llvm/DebugInfo/PDB/IPDBEnumChildren.h"
#include "llvm/DebugInfo/PDB/IPDBRawSymbol.h"
#include "llvm/DebugInfo/PDB/IPDBSession.h"
#include "llvm/DebugInfo/PDB/PDB.h"
#include "llvm/DebugInfo/PDB/PDBSymbolCompiland.h"
#include "llvm/DebugInfo/PDB/PDBSymbolData.h"
#include "llvm/DebugInfo/PDB/PDBSymbolExe.h"
#include "llvm/DebugInfo/PDB/PDBSymbolFunc.h"
#include "llvm/DebugInfo/PDB/PDBSymbolThunk.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/ConvertUTF.h"
#include "llvm/Support/FileSystem.h"
#include "llvm/Support/Format.h"
#include "llvm/Support/ManagedStatic.h"
#include "llvm/Support/MemoryBuffer.h"
#include "llvm/Support/PrettyStackTrace.h"
#include "llvm/Support/Process.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/Signals.h"

#if defined(HAVE_DIA_SDK)
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <Windows.h>
#endif

using namespace llvm;

namespace opts {

enum class PDB_DumpType { ByType, ByObjFile, Both };

cl::list<std::string> InputFilenames(cl::Positional,
                                     cl::desc("<input PDB files>"),
                                     cl::OneOrMore);

cl::OptionCategory TypeCategory("Symbol Type Options");
cl::OptionCategory FilterCategory("Filtering Options");
cl::OptionCategory OtherOptions("Other Options");

cl::opt<bool> Compilands("compilands", cl::desc("Display compilands"),
                         cl::cat(TypeCategory));
cl::opt<bool> Symbols("symbols", cl::desc("Display symbols for each compiland"),
                      cl::cat(TypeCategory));
cl::opt<bool> Globals("globals", cl::desc("Dump global symbols"),
                      cl::cat(TypeCategory));
cl::opt<bool> Externals("externals", cl::desc("Dump external symbols"),
                        cl::cat(TypeCategory));
cl::opt<bool> Types("types", cl::desc("Display types"), cl::cat(TypeCategory));
cl::opt<bool>
    All("all", cl::desc("Implies all other options in 'Symbol Types' category"),
        cl::cat(TypeCategory));

cl::opt<uint64_t> LoadAddress(
    "load-address",
    cl::desc("Assume the module is loaded at the specified address"),
    cl::cat(OtherOptions));

cl::opt<bool> DumpHeaders("dump-headers", cl::desc("dump PDB headers"),
                          cl::cat(OtherOptions));
cl::opt<bool> DumpStreamSizes("dump-stream-sizes",
                              cl::desc("dump PDB stream sizes"),
                              cl::cat(OtherOptions));
cl::opt<bool> DumpStreamBlocks("dump-stream-blocks",
                               cl::desc("dump PDB stream blocks"),
                               cl::cat(OtherOptions));
cl::opt<std::string> DumpStreamData("dump-stream", cl::desc("dump stream data"),
                                    cl::cat(OtherOptions));

cl::list<std::string>
    ExcludeTypes("exclude-types",
                 cl::desc("Exclude types by regular expression"),
                 cl::ZeroOrMore, cl::cat(FilterCategory));
cl::list<std::string>
    ExcludeSymbols("exclude-symbols",
                   cl::desc("Exclude symbols by regular expression"),
                   cl::ZeroOrMore, cl::cat(FilterCategory));
cl::list<std::string>
    ExcludeCompilands("exclude-compilands",
                      cl::desc("Exclude compilands by regular expression"),
                      cl::ZeroOrMore, cl::cat(FilterCategory));

cl::list<std::string> IncludeTypes(
    "include-types",
    cl::desc("Include only types which match a regular expression"),
    cl::ZeroOrMore, cl::cat(FilterCategory));
cl::list<std::string> IncludeSymbols(
    "include-symbols",
    cl::desc("Include only symbols which match a regular expression"),
    cl::ZeroOrMore, cl::cat(FilterCategory));
cl::list<std::string> IncludeCompilands(
    "include-compilands",
    cl::desc("Include only compilands those which match a regular expression"),
    cl::ZeroOrMore, cl::cat(FilterCategory));

cl::opt<bool> ExcludeCompilerGenerated(
    "no-compiler-generated",
    cl::desc("Don't show compiler generated types and symbols"),
    cl::cat(FilterCategory));
cl::opt<bool>
    ExcludeSystemLibraries("no-system-libs",
                           cl::desc("Don't show symbols from system libraries"),
                           cl::cat(FilterCategory));
cl::opt<bool> NoClassDefs("no-class-definitions",
                          cl::desc("Don't display full class definitions"),
                          cl::cat(FilterCategory));
cl::opt<bool> NoEnumDefs("no-enum-definitions",
                         cl::desc("Don't display full enum definitions"),
                         cl::cat(FilterCategory));
}


static void reportError(StringRef Input, StringRef Message) {
  if (Input == "-")
    Input = "<stdin>";
  errs() << Input << ": " << Message << "\n";
  errs().flush();
  exit(1);
}

static void reportError(StringRef Input, std::error_code EC) {
  reportError(Input, EC.message());
}

static std::error_code checkOffset(MemoryBufferRef M, uintptr_t Addr,
                                   const uint64_t Size) {
  if (Addr + Size < Addr || Addr + Size < Size ||
      Addr + Size > uintptr_t(M.getBufferEnd()) ||
      Addr < uintptr_t(M.getBufferStart())) {
    return std::make_error_code(std::errc::bad_address);
  }
  return std::error_code();
}

template <typename T>
static std::error_code checkOffset(MemoryBufferRef M, ArrayRef<T> AR) {
  return checkOffset(M, uintptr_t(AR.data()), (uint64_t)AR.size() * sizeof(T));
}

static std::error_code checkOffset(MemoryBufferRef M, StringRef SR) {
  return checkOffset(M, uintptr_t(SR.data()), SR.size());
}

// Sets Obj unless any bytes in [addr, addr + size) fall outsize of m.
// Returns unexpected_eof if error.
template <typename T>
static std::error_code getObject(const T *&Obj, MemoryBufferRef M,
                                 const void *Ptr,
                                 const uint64_t Size = sizeof(T)) {
  uintptr_t Addr = uintptr_t(Ptr);
  if (std::error_code EC = checkOffset(M, Addr, Size))
    return EC;
  Obj = reinterpret_cast<const T *>(Addr);
  return std::error_code();
}

static uint64_t bytesToBlocks(uint64_t NumBytes, uint64_t BlockSize) {
  return RoundUpToAlignment(NumBytes, BlockSize) / BlockSize;
}

static uint64_t blockToOffset(uint64_t BlockNumber, uint64_t BlockSize) {
  return BlockNumber * BlockSize;
}

static void dumpStructure(MemoryBufferRef M) {
  const PDB::SuperBlock *SB;
  if (auto EC = getObject(SB, M, M.getBufferStart()))
    reportError(M.getBufferIdentifier(), EC);

  if (opts::DumpHeaders) {
    outs() << "BlockSize: " << SB->BlockSize << '\n';
    outs() << "Unknown0: " << SB->Unknown0 << '\n';
    outs() << "NumBlocks: " << SB->NumBlocks << '\n';
    outs() << "NumDirectoryBytes: " << SB->NumDirectoryBytes << '\n';
    outs() << "Unknown1: " << SB->Unknown1 << '\n';
    outs() << "BlockMapAddr: " << SB->BlockMapAddr << '\n';
  }

  // We don't support blocksizes which aren't a multiple of four bytes.
  if (SB->BlockSize % sizeof(support::ulittle32_t) != 0)
    reportError(M.getBufferIdentifier(),
                std::make_error_code(std::errc::illegal_byte_sequence));

  // We don't support directories whose sizes aren't a multiple of four bytes.
  if (SB->NumDirectoryBytes % sizeof(support::ulittle32_t) != 0)
    reportError(M.getBufferIdentifier(),
                std::make_error_code(std::errc::illegal_byte_sequence));

  // The number of blocks which comprise the directory is a simple function of
  // the number of bytes it contains.
  uint64_t NumDirectoryBlocks =
      bytesToBlocks(SB->NumDirectoryBytes, SB->BlockSize);
  if (opts::DumpHeaders)
    outs() << "NumDirectoryBlocks: " << NumDirectoryBlocks << '\n';

  // The block map, as we understand it, is a block which consists of a list of
  // block numbers.
  // It is unclear what would happen if the number of blocks couldn't fit on a
  // single block.
  if (NumDirectoryBlocks > SB->BlockSize / sizeof(support::ulittle32_t))
    reportError(M.getBufferIdentifier(),
                std::make_error_code(std::errc::illegal_byte_sequence));


  uint64_t BlockMapOffset = (uint64_t)SB->BlockMapAddr * SB->BlockSize;
  if (opts::DumpHeaders)
    outs() << "BlockMapOffset: " << BlockMapOffset << '\n';

  // The directory is not contiguous.  Instead, the block map contains a
  // contiguous list of block numbers whose contents, when concatenated in
  // order, make up the directory.
  auto DirectoryBlocks =
      makeArrayRef(reinterpret_cast<const support::ulittle32_t *>(
                       M.getBufferStart() + BlockMapOffset),
                   NumDirectoryBlocks);
  if (auto EC = checkOffset(M, DirectoryBlocks))
    reportError(M.getBufferIdentifier(), EC);

  if (opts::DumpHeaders) {
    outs() << "DirectoryBlocks: [";
    for (const support::ulittle32_t &DirectoryBlockAddr : DirectoryBlocks) {
      if (&DirectoryBlockAddr != &DirectoryBlocks.front())
        outs() << ", ";
      outs() << DirectoryBlockAddr;
    }
    outs() << "]\n";
  }

  bool SeenNumStreams = false;
  uint32_t NumStreams = 0;
  std::vector<uint32_t> StreamSizes;
  DenseMap<uint32_t, std::vector<uint32_t>> StreamMap;
  uint32_t StreamIdx = 0;
  uint64_t DirectoryBytesRead = 0;
  // The structure of the directory is as follows:
  //    struct PDBDirectory {
  //      uint32_t NumStreams;
  //      uint32_t StreamSizes[NumStreams];
  //      uint32_t StreamMap[NumStreams][];
  //    };
  //
  //  Empty streams don't consume entries in the StreamMap.
  for (uint32_t DirectoryBlockAddr : DirectoryBlocks) {
    uint64_t DirectoryBlockOffset =
        blockToOffset(DirectoryBlockAddr, SB->BlockSize);
    auto DirectoryBlock =
        makeArrayRef(reinterpret_cast<const support::ulittle32_t *>(
                         M.getBufferStart() + DirectoryBlockOffset),
                     SB->BlockSize / sizeof(support::ulittle32_t));
    if (auto EC = checkOffset(M, DirectoryBlock))
      reportError(M.getBufferIdentifier(), EC);

    // We read data out of the directory four bytes at a time.  Depending on
    // where we are in the directory, the contents may be: the number of streams
    // in the directory, a stream's size, or a block in the stream map.
    for (uint32_t Data : DirectoryBlock) {
      // Don't read beyond the end of the directory.
      if (DirectoryBytesRead == SB->NumDirectoryBytes)
        break;

      DirectoryBytesRead += sizeof(Data);

      // This data must be the number of streams if we haven't seen it yet.
      if (!SeenNumStreams) {
        NumStreams = Data;
        SeenNumStreams = true;
        continue;
      }
      // This data must be a stream size if we have not seen them all yet.
      if (StreamSizes.size() < NumStreams) {
        // It seems like some streams have their set to -1 when their contents
        // are not present.  Treat them like empty streams for now.
        if (Data == UINT32_MAX)
          StreamSizes.push_back(0);
        else
          StreamSizes.push_back(Data);
        continue;
      }

      // This data must be a stream block number if we have seen all of the
      // stream sizes.
      std::vector<uint32_t> *StreamBlocks = nullptr;
      // Figure out which stream this block number belongs to.
      while (StreamIdx < NumStreams) {
        uint64_t NumExpectedStreamBlocks =
            bytesToBlocks(StreamSizes[StreamIdx], SB->BlockSize);
        StreamBlocks = &StreamMap[StreamIdx];
        if (NumExpectedStreamBlocks > StreamBlocks->size())
          break;
        ++StreamIdx;
      }
      // It seems this block doesn't belong to any stream?  The stream is either
      // corrupt or something more mysterious is going on.
      if (StreamIdx == NumStreams)
        reportError(M.getBufferIdentifier(),
                    std::make_error_code(std::errc::illegal_byte_sequence));

      StreamBlocks->push_back(Data);
    }
  }

  // We should have read exactly SB->NumDirectoryBytes bytes.
  assert(DirectoryBytesRead == SB->NumDirectoryBytes);

  if (opts::DumpHeaders)
    outs() << "NumStreams: " << NumStreams << '\n';
  if (opts::DumpStreamSizes)
    for (uint32_t StreamIdx = 0; StreamIdx < NumStreams; ++StreamIdx)
      outs() << "StreamSizes[" << StreamIdx << "]: " << StreamSizes[StreamIdx]
             << '\n';

  if (opts::DumpStreamBlocks) {
    for (uint32_t StreamIdx = 0; StreamIdx < NumStreams; ++StreamIdx) {
      outs() << "StreamBlocks[" << StreamIdx << "]: [";
      std::vector<uint32_t> &StreamBlocks = StreamMap[StreamIdx];
      for (uint32_t &StreamBlock : StreamBlocks) {
        if (&StreamBlock != &StreamBlocks.front())
          outs() << ", ";
        outs() << StreamBlock;
      }
      outs() << "]\n";
    }
  }

  StringRef DumpStreamStr = opts::DumpStreamData;
  uint32_t DumpStreamNum;
  if (!DumpStreamStr.getAsInteger(/*Radix=*/0U, DumpStreamNum) &&
      DumpStreamNum < NumStreams) {
    uint32_t StreamBytesRead = 0;
    uint32_t StreamSize = StreamSizes[DumpStreamNum];
    std::vector<uint32_t> &StreamBlocks = StreamMap[DumpStreamNum];
    for (uint32_t &StreamBlockAddr : StreamBlocks) {
      uint64_t StreamBlockOffset = blockToOffset(StreamBlockAddr, SB->BlockSize);
      uint32_t BytesLeftToReadInStream = StreamSize - StreamBytesRead;
      if (BytesLeftToReadInStream == 0)
        break;

      uint32_t BytesToReadInBlock = std::min(
          BytesLeftToReadInStream, static_cast<uint32_t>(SB->BlockSize));
      auto StreamBlockData =
          StringRef(M.getBufferStart() + StreamBlockOffset, BytesToReadInBlock);
      if (auto EC = checkOffset(M, StreamBlockData))
        reportError(M.getBufferIdentifier(), EC);

      outs() << StreamBlockData;
      StreamBytesRead += StreamBlockData.size();
    }
  }
}

static void dumpInput(StringRef Path) {
  if (opts::DumpHeaders || !opts::DumpStreamData.empty()) {
    ErrorOr<std::unique_ptr<MemoryBuffer>> ErrorOrBuffer =
        MemoryBuffer::getFileOrSTDIN(Path, /*FileSize=*/-1,
                                     /*RequiresNullTerminator=*/false);

    if (std::error_code EC = ErrorOrBuffer.getError())
      reportError(Path, EC);

    std::unique_ptr<MemoryBuffer> &Buffer = ErrorOrBuffer.get();

    dumpStructure(Buffer->getMemBufferRef());

    outs().flush();
    return;
  }

  std::unique_ptr<IPDBSession> Session;
  PDB_ErrorCode Error = loadDataForPDB(PDB_ReaderType::DIA, Path, Session);
  switch (Error) {
  case PDB_ErrorCode::Success:
    break;
  case PDB_ErrorCode::NoPdbImpl:
    outs() << "Reading PDBs is not supported on this platform.\n";
    return;
  case PDB_ErrorCode::InvalidPath:
    outs() << "Unable to load PDB at '" << Path
           << "'.  Check that the file exists and is readable.\n";
    return;
  case PDB_ErrorCode::InvalidFileFormat:
    outs() << "Unable to load PDB at '" << Path
           << "'.  The file has an unrecognized format.\n";
    return;
  default:
    outs() << "Unable to load PDB at '" << Path
           << "'.  An unknown error occured.\n";
    return;
  }
  if (opts::LoadAddress)
    Session->setLoadAddress(opts::LoadAddress);

  LinePrinter Printer(2, outs());

  auto GlobalScope(Session->getGlobalScope());
  std::string FileName(GlobalScope->getSymbolsFileName());

  WithColor(Printer, PDB_ColorItem::None).get() << "Summary for ";
  WithColor(Printer, PDB_ColorItem::Path).get() << FileName;
  Printer.Indent();
  uint64_t FileSize = 0;

  Printer.NewLine();
  WithColor(Printer, PDB_ColorItem::Identifier).get() << "Size";
  if (!sys::fs::file_size(FileName, FileSize)) {
    Printer << ": " << FileSize << " bytes";
  } else {
    Printer << ": (Unable to obtain file size)";
  }

  Printer.NewLine();
  WithColor(Printer, PDB_ColorItem::Identifier).get() << "Guid";
  Printer << ": " << GlobalScope->getGuid();

  Printer.NewLine();
  WithColor(Printer, PDB_ColorItem::Identifier).get() << "Age";
  Printer << ": " << GlobalScope->getAge();

  Printer.NewLine();
  WithColor(Printer, PDB_ColorItem::Identifier).get() << "Attributes";
  Printer << ": ";
  if (GlobalScope->hasCTypes())
    outs() << "HasCTypes ";
  if (GlobalScope->hasPrivateSymbols())
    outs() << "HasPrivateSymbols ";
  Printer.Unindent();

  if (opts::Compilands) {
    Printer.NewLine();
    WithColor(Printer, PDB_ColorItem::SectionHeader).get()
        << "---COMPILANDS---";
    Printer.Indent();
    auto Compilands = GlobalScope->findAllChildren<PDBSymbolCompiland>();
    CompilandDumper Dumper(Printer);
    while (auto Compiland = Compilands->getNext())
      Dumper.start(*Compiland, false);
    Printer.Unindent();
  }

  if (opts::Types) {
    Printer.NewLine();
    WithColor(Printer, PDB_ColorItem::SectionHeader).get() << "---TYPES---";
    Printer.Indent();
    TypeDumper Dumper(Printer);
    Dumper.start(*GlobalScope);
    Printer.Unindent();
  }

  if (opts::Symbols) {
    Printer.NewLine();
    WithColor(Printer, PDB_ColorItem::SectionHeader).get() << "---SYMBOLS---";
    Printer.Indent();
    auto Compilands = GlobalScope->findAllChildren<PDBSymbolCompiland>();
    CompilandDumper Dumper(Printer);
    while (auto Compiland = Compilands->getNext())
      Dumper.start(*Compiland, true);
    Printer.Unindent();
  }

  if (opts::Globals) {
    Printer.NewLine();
    WithColor(Printer, PDB_ColorItem::SectionHeader).get() << "---GLOBALS---";
    Printer.Indent();
    {
      FunctionDumper Dumper(Printer);
      auto Functions = GlobalScope->findAllChildren<PDBSymbolFunc>();
      while (auto Function = Functions->getNext()) {
        Printer.NewLine();
        Dumper.start(*Function, FunctionDumper::PointerType::None);
      }
    }
    {
      auto Vars = GlobalScope->findAllChildren<PDBSymbolData>();
      VariableDumper Dumper(Printer);
      while (auto Var = Vars->getNext())
        Dumper.start(*Var);
    }
    {
      auto Thunks = GlobalScope->findAllChildren<PDBSymbolThunk>();
      CompilandDumper Dumper(Printer);
      while (auto Thunk = Thunks->getNext())
        Dumper.dump(*Thunk);
    }
    Printer.Unindent();
  }
  if (opts::Externals) {
    Printer.NewLine();
    WithColor(Printer, PDB_ColorItem::SectionHeader).get() << "---EXTERNALS---";
    Printer.Indent();
    ExternalSymbolDumper Dumper(Printer);
    Dumper.start(*GlobalScope);
  }
  outs().flush();
}

int main(int argc_, const char *argv_[]) {
  // Print a stack trace if we signal out.
  sys::PrintStackTraceOnErrorSignal();
  PrettyStackTraceProgram X(argc_, argv_);

  SmallVector<const char *, 256> argv;
  SpecificBumpPtrAllocator<char> ArgAllocator;
  std::error_code EC = sys::Process::GetArgumentVector(
      argv, makeArrayRef(argv_, argc_), ArgAllocator);
  if (EC) {
    errs() << "error: couldn't get arguments: " << EC.message() << '\n';
    return 1;
  }

  llvm_shutdown_obj Y; // Call llvm_shutdown() on exit.

  cl::ParseCommandLineOptions(argv.size(), argv.data(), "LLVM PDB Dumper\n");
  if (opts::All) {
    opts::Compilands = true;
    opts::Symbols = true;
    opts::Globals = true;
    opts::Types = true;
    opts::Externals = true;
  }
  if (opts::ExcludeCompilerGenerated) {
    opts::ExcludeTypes.push_back("__vc_attributes");
    opts::ExcludeCompilands.push_back("* Linker *");
  }
  if (opts::ExcludeSystemLibraries) {
    opts::ExcludeCompilands.push_back(
        "f:\\binaries\\Intermediate\\vctools\\crt_bld");
  }

#if defined(HAVE_DIA_SDK)
  CoInitializeEx(nullptr, COINIT_MULTITHREADED);
#endif

  std::for_each(opts::InputFilenames.begin(), opts::InputFilenames.end(),
                dumpInput);

#if defined(HAVE_DIA_SDK)
  CoUninitialize();
#endif

  return 0;
}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@a19 1
#include "LLVMOutputStyle.h"
a20 1
#include "OutputStyle.h"
a22 1
#include "YAMLOutputStyle.h"
a28 2
#include "llvm/DebugInfo/CodeView/ByteStream.h"
#include "llvm/DebugInfo/PDB/GenericError.h"
a37 10
#include "llvm/DebugInfo/PDB/Raw/DbiStream.h"
#include "llvm/DebugInfo/PDB/Raw/DbiStreamBuilder.h"
#include "llvm/DebugInfo/PDB/Raw/InfoStream.h"
#include "llvm/DebugInfo/PDB/Raw/InfoStreamBuilder.h"
#include "llvm/DebugInfo/PDB/Raw/PDBFile.h"
#include "llvm/DebugInfo/PDB/Raw/PDBFileBuilder.h"
#include "llvm/DebugInfo/PDB/Raw/RawConstants.h"
#include "llvm/DebugInfo/PDB/Raw/RawError.h"
#include "llvm/DebugInfo/PDB/Raw/RawSession.h"
#include "llvm/Support/COM.h"
a39 1
#include "llvm/Support/FileOutputBuffer.h"
d46 1
a46 1
#include "llvm/Support/ScopedPrinter.h"
d48 7
a54 1
#include "llvm/Support/raw_ostream.h"
a56 2
using namespace llvm::codeview;
using namespace llvm::pdb;
d58 1
a58 20
namespace {
// A simple adapter that acts like a ByteStream but holds ownership over
// and underlying FileOutputBuffer.
class FileBufferByteStream : public ByteStream<true> {
public:
  FileBufferByteStream(std::unique_ptr<FileOutputBuffer> Buffer)
      : ByteStream(MutableArrayRef<uint8_t>(Buffer->getBufferStart(),
                                            Buffer->getBufferEnd())),
        FileBuffer(std::move(Buffer)) {}

  Error commit() const override {
    if (FileBuffer->commit())
      return llvm::make_error<RawError>(raw_error_code::not_writable);
    return Error::success();
  }

private:
  std::unique_ptr<FileOutputBuffer> FileBuffer;
};
}
d60 1
a60 1
namespace opts {
d62 3
a64 10
cl::SubCommand RawSubcommand("raw", "Dump raw structure of the PDB file");
cl::SubCommand
    PrettySubcommand("pretty",
                     "Dump semantic information about types and symbols");
cl::SubCommand
    YamlToPdbSubcommand("yaml2pdb",
                        "Generate a PDB file from a YAML description");
cl::SubCommand
    PdbToYamlSubcommand("pdb2yaml",
                        "Generate a detailed YAML description of a PDB File");
a69 5
namespace pretty {
cl::list<std::string> InputFilenames(cl::Positional,
                                     cl::desc("<input PDB files>"),
                                     cl::OneOrMore, cl::sub(PrettySubcommand));

d71 1
a71 1
                         cl::cat(TypeCategory), cl::sub(PrettySubcommand));
d73 1
a73 1
                      cl::cat(TypeCategory), cl::sub(PrettySubcommand));
d75 1
a75 1
                      cl::cat(TypeCategory), cl::sub(PrettySubcommand));
d77 2
a78 5
                        cl::cat(TypeCategory), cl::sub(PrettySubcommand));
cl::opt<bool> Types("types", cl::desc("Display types"), cl::cat(TypeCategory),
                    cl::sub(PrettySubcommand));
cl::opt<bool> Lines("lines", cl::desc("Line tables"), cl::cat(TypeCategory),
                    cl::sub(PrettySubcommand));
d81 1
a81 1
        cl::cat(TypeCategory), cl::sub(PrettySubcommand));
d86 25
a110 10
    cl::cat(OtherOptions), cl::sub(PrettySubcommand));
cl::list<std::string> ExcludeTypes(
    "exclude-types", cl::desc("Exclude types by regular expression"),
    cl::ZeroOrMore, cl::cat(FilterCategory), cl::sub(PrettySubcommand));
cl::list<std::string> ExcludeSymbols(
    "exclude-symbols", cl::desc("Exclude symbols by regular expression"),
    cl::ZeroOrMore, cl::cat(FilterCategory), cl::sub(PrettySubcommand));
cl::list<std::string> ExcludeCompilands(
    "exclude-compilands", cl::desc("Exclude compilands by regular expression"),
    cl::ZeroOrMore, cl::cat(FilterCategory), cl::sub(PrettySubcommand));
d115 1
a115 1
    cl::ZeroOrMore, cl::cat(FilterCategory), cl::sub(PrettySubcommand));
d119 1
a119 1
    cl::ZeroOrMore, cl::cat(FilterCategory), cl::sub(PrettySubcommand));
d123 1
a123 1
    cl::ZeroOrMore, cl::cat(FilterCategory), cl::sub(PrettySubcommand));
d128 1
a128 1
    cl::cat(FilterCategory), cl::sub(PrettySubcommand));
d132 1
a132 1
                           cl::cat(FilterCategory), cl::sub(PrettySubcommand));
d135 1
a135 1
                          cl::cat(FilterCategory), cl::sub(PrettySubcommand));
d138 1
a138 1
                         cl::cat(FilterCategory), cl::sub(PrettySubcommand));
a140 1
namespace raw {
d142 11
a152 5
cl::OptionCategory MsfOptions("MSF Container Options");
cl::OptionCategory TypeOptions("Type Record Options");
cl::OptionCategory FileOptions("Module & File Options");
cl::OptionCategory SymbolOptions("Symbol Options");
cl::OptionCategory MiscOptions("Miscellaneous Options");
d154 9
a162 9
// MSF OPTIONS
cl::opt<bool> DumpHeaders("headers", cl::desc("dump PDB headers"),
                          cl::cat(MsfOptions), cl::sub(RawSubcommand));
cl::opt<bool> DumpStreamBlocks("stream-blocks",
                               cl::desc("dump PDB stream blocks"),
                               cl::cat(MsfOptions), cl::sub(RawSubcommand));
cl::opt<bool> DumpStreamSummary("stream-summary",
                                cl::desc("dump summary of the PDB streams"),
                                cl::cat(MsfOptions), cl::sub(RawSubcommand));
d164 4
a167 58
// TYPE OPTIONS
cl::opt<bool>
    DumpTpiRecords("tpi-records",
                   cl::desc("dump CodeView type records from TPI stream"),
                   cl::cat(TypeOptions), cl::sub(RawSubcommand));
cl::opt<bool> DumpTpiRecordBytes(
    "tpi-record-bytes",
    cl::desc("dump CodeView type record raw bytes from TPI stream"),
    cl::cat(TypeOptions), cl::sub(RawSubcommand));
cl::opt<bool> DumpTpiHash("tpi-hash", cl::desc("dump CodeView TPI hash stream"),
                          cl::cat(TypeOptions), cl::sub(RawSubcommand));
cl::opt<bool>
    DumpIpiRecords("ipi-records",
                   cl::desc("dump CodeView type records from IPI stream"),
                   cl::cat(TypeOptions), cl::sub(RawSubcommand));
cl::opt<bool> DumpIpiRecordBytes(
    "ipi-record-bytes",
    cl::desc("dump CodeView type record raw bytes from IPI stream"),
    cl::cat(TypeOptions), cl::sub(RawSubcommand));

// MODULE & FILE OPTIONS
cl::opt<bool> DumpModules("modules", cl::desc("dump compiland information"),
                          cl::cat(FileOptions), cl::sub(RawSubcommand));
cl::opt<bool> DumpModuleFiles("module-files", cl::desc("dump file information"),
                              cl::cat(FileOptions), cl::sub(RawSubcommand));
cl::opt<bool> DumpLineInfo("line-info",
                           cl::desc("dump file and line information"),
                           cl::cat(FileOptions), cl::sub(RawSubcommand));

// SYMBOL OPTIONS
cl::opt<bool> DumpModuleSyms("module-syms", cl::desc("dump module symbols"),
                             cl::cat(SymbolOptions), cl::sub(RawSubcommand));
cl::opt<bool> DumpPublics("publics", cl::desc("dump Publics stream data"),
                          cl::cat(SymbolOptions), cl::sub(RawSubcommand));
cl::opt<bool>
    DumpSymRecordBytes("sym-record-bytes",
                       cl::desc("dump CodeView symbol record raw bytes"),
                       cl::cat(SymbolOptions), cl::sub(RawSubcommand));

// MISCELLANEOUS OPTIONS
cl::opt<bool> DumpSectionContribs("section-contribs",
                                  cl::desc("dump section contributions"),
                                  cl::cat(MiscOptions), cl::sub(RawSubcommand));
cl::opt<bool> DumpSectionMap("section-map", cl::desc("dump section map"),
                             cl::cat(MiscOptions), cl::sub(RawSubcommand));
cl::opt<bool> DumpSectionHeaders("section-headers",
                                 cl::desc("dump section headers"),
                                 cl::cat(MiscOptions), cl::sub(RawSubcommand));
cl::opt<bool> DumpFpo("fpo", cl::desc("dump FPO records"), cl::cat(MiscOptions),
                      cl::sub(RawSubcommand));

cl::opt<std::string> DumpStreamDataIdx("stream", cl::desc("dump stream data"),
                                       cl::cat(MiscOptions),
                                       cl::sub(RawSubcommand));
cl::opt<std::string> DumpStreamDataName("stream-name",
                                        cl::desc("dump stream data"),
                                        cl::cat(MiscOptions),
                                        cl::sub(RawSubcommand));
d169 3
a171 2
cl::opt<bool> RawAll("all", cl::desc("Implies most other options."),
                     cl::cat(MiscOptions), cl::sub(RawSubcommand));
d173 11
a183 3
cl::list<std::string> InputFilenames(cl::Positional,
                                     cl::desc("<input PDB files>"),
                                     cl::OneOrMore, cl::sub(RawSubcommand));
d186 3
a188 4
namespace yaml2pdb {
cl::opt<std::string>
    YamlPdbOutputFile("pdb", cl::desc("the name of the PDB file to write"),
                      cl::sub(YamlToPdbSubcommand));
d190 2
a191 3
cl::list<std::string> InputFilename(cl::Positional,
                                    cl::desc("<input YAML file>"), cl::Required,
                                    cl::sub(YamlToPdbSubcommand));
d194 60
a253 73
namespace pdb2yaml {
cl::opt<bool>
    NoFileHeaders("no-file-headers",
                  cl::desc("Do not dump MSF file headers (you will not be able "
                           "to generate a fresh PDB from the resulting YAML)"),
                  cl::sub(PdbToYamlSubcommand), cl::init(false));

cl::opt<bool> StreamMetadata(
    "stream-metadata",
    cl::desc("Dump the number of streams and each stream's size"),
    cl::sub(PdbToYamlSubcommand), cl::init(false));
cl::opt<bool> StreamDirectory(
    "stream-directory",
    cl::desc("Dump each stream's block map (implies -stream-metadata)"),
    cl::sub(PdbToYamlSubcommand), cl::init(false));
cl::opt<bool> PdbStream("pdb-stream",
                        cl::desc("Dump the PDB Stream (Stream 1)"),
                        cl::sub(PdbToYamlSubcommand), cl::init(false));
cl::opt<bool> DbiStream("dbi-stream",
                        cl::desc("Dump the DBI Stream (Stream 2)"),
                        cl::sub(PdbToYamlSubcommand), cl::init(false));

cl::list<std::string> InputFilename(cl::Positional,
                                    cl::desc("<input PDB file>"), cl::Required,
                                    cl::sub(PdbToYamlSubcommand));
}
}

static ExitOnError ExitOnErr;

static void yamlToPdb(StringRef Path) {
  ErrorOr<std::unique_ptr<MemoryBuffer>> ErrorOrBuffer =
      MemoryBuffer::getFileOrSTDIN(Path, /*FileSize=*/-1,
                                   /*RequiresNullTerminator=*/false);

  if (ErrorOrBuffer.getError()) {
    ExitOnErr(make_error<GenericError>(generic_error_code::invalid_path, Path));
  }

  std::unique_ptr<MemoryBuffer> &Buffer = ErrorOrBuffer.get();

  llvm::yaml::Input In(Buffer->getBuffer());
  pdb::yaml::PdbObject YamlObj;
  In >> YamlObj;
  if (!YamlObj.Headers.hasValue())
    ExitOnErr(make_error<GenericError>(generic_error_code::unspecified,
                                       "Yaml does not contain MSF headers"));

  auto OutFileOrError = FileOutputBuffer::create(
      opts::yaml2pdb::YamlPdbOutputFile, YamlObj.Headers->FileSize);
  if (OutFileOrError.getError())
    ExitOnErr(make_error<GenericError>(generic_error_code::invalid_path,
                                       opts::yaml2pdb::YamlPdbOutputFile));

  auto FileByteStream =
      llvm::make_unique<FileBufferByteStream>(std::move(*OutFileOrError));
  PDBFileBuilder Builder(std::move(FileByteStream));

  ExitOnErr(Builder.initialize(YamlObj.Headers->SuperBlock));
  ExitOnErr(Builder.getMsfBuilder().setDirectoryBlocksHint(
      YamlObj.Headers->DirectoryBlocks));
  if (!YamlObj.StreamSizes.hasValue()) {
    ExitOnErr(make_error<GenericError>(
        generic_error_code::unspecified,
        "Cannot generate a PDB when stream sizes are not known"));
  }

  if (YamlObj.StreamMap.hasValue()) {
    if (YamlObj.StreamMap->size() != YamlObj.StreamSizes->size()) {
      ExitOnErr(make_error<GenericError>(generic_error_code::unspecified,
                                         "YAML specifies different number of "
                                         "streams in stream sizes and stream "
                                         "map"));
d255 2
d258 70
a327 13
    auto &Sizes = *YamlObj.StreamSizes;
    auto &Map = *YamlObj.StreamMap;
    for (uint32_t I = 0; I < Sizes.size(); ++I) {
      uint32_t Size = Sizes[I];
      std::vector<uint32_t> Blocks;
      for (auto E : Map[I].Blocks)
        Blocks.push_back(E);
      ExitOnErr(Builder.getMsfBuilder().addStream(Size, Blocks));
    }
  } else {
    auto &Sizes = *YamlObj.StreamSizes;
    for (auto S : Sizes) {
      ExitOnErr(Builder.getMsfBuilder().addStream(S));
d331 21
a351 20
  if (YamlObj.PdbStream.hasValue()) {
    auto &InfoBuilder = Builder.getInfoBuilder();
    InfoBuilder.setAge(YamlObj.PdbStream->Age);
    InfoBuilder.setGuid(YamlObj.PdbStream->Guid);
    InfoBuilder.setSignature(YamlObj.PdbStream->Signature);
    InfoBuilder.setVersion(YamlObj.PdbStream->Version);
    for (auto &NM : YamlObj.PdbStream->NamedStreams)
      InfoBuilder.getNamedStreamsBuilder().addMapping(NM.StreamName,
                                                      NM.StreamNumber);
  }

  if (YamlObj.DbiStream.hasValue()) {
    auto &DbiBuilder = Builder.getDbiBuilder();
    DbiBuilder.setAge(YamlObj.DbiStream->Age);
    DbiBuilder.setBuildNumber(YamlObj.DbiStream->BuildNumber);
    DbiBuilder.setFlags(YamlObj.DbiStream->Flags);
    DbiBuilder.setMachineType(YamlObj.DbiStream->MachineType);
    DbiBuilder.setPdbDllRbld(YamlObj.DbiStream->PdbDllRbld);
    DbiBuilder.setPdbDllVersion(YamlObj.DbiStream->PdbDllVersion);
    DbiBuilder.setVersionHeader(YamlObj.DbiStream->VerHeader);
d354 19
a372 2
  auto Pdb = Builder.build();
  ExitOnErr(Pdb.takeError());
d374 4
a377 2
  auto &PdbFile = *Pdb;
  ExitOnErr(PdbFile->commit());
d380 5
a384 3
static void pdb2Yaml(StringRef Path) {
  std::unique_ptr<IPDBSession> Session;
  ExitOnErr(loadDataForPDB(PDB_ReaderType::Raw, Path, Session));
d386 2
a387 4
  RawSession *RS = static_cast<RawSession *>(Session.get());
  PDBFile &File = RS->getPDBFile();
  auto O = llvm::make_unique<YAMLOutputStyle>(File);
  O = llvm::make_unique<YAMLOutputStyle>(File);
d389 1
a389 2
  ExitOnErr(O->dump());
}
d391 1
a391 3
static void dumpRaw(StringRef Path) {
  std::unique_ptr<IPDBSession> Session;
  ExitOnErr(loadDataForPDB(PDB_ReaderType::Raw, Path, Session));
d393 3
a395 6
  RawSession *RS = static_cast<RawSession *>(Session.get());
  PDBFile &File = RS->getPDBFile();
  auto O = llvm::make_unique<LLVMOutputStyle>(File);

  ExitOnErr(O->dump());
}
a396 1
static void dumpPretty(StringRef Path) {
d398 22
a419 5

  ExitOnErr(loadDataForPDB(PDB_ReaderType::DIA, Path, Session));

  if (opts::pretty::LoadAddress)
    Session->setLoadAddress(opts::pretty::LoadAddress);
d456 1
a456 1
  if (opts::pretty::Compilands) {
a462 3
    CompilandDumpFlags options = CompilandDumper::Flags::None;
    if (opts::pretty::Lines)
      options = options | CompilandDumper::Flags::Lines;
d464 1
a464 1
      Dumper.start(*Compiland, options);
d468 1
a468 1
  if (opts::pretty::Types) {
d477 1
a477 1
  if (opts::pretty::Symbols) {
d488 1
a488 1
  if (opts::pretty::Globals) {
d514 1
a514 1
  if (opts::pretty::Externals) {
a520 3
  if (opts::pretty::Lines) {
    Printer.NewLine();
  }
d526 1
a526 1
  sys::PrintStackTraceOnErrorSignal(argv_[0]);
a528 2
  ExitOnErr.setBanner("llvm-pdbdump: ");

d531 6
a536 2
  ExitOnErr(errorCodeToError(sys::Process::GetArgumentVector(
      argv, makeArrayRef(argv_, argc_), ArgAllocator)));
d541 26
a567 64
  // These options are shared by two subcommands.
  if ((opts::PdbToYamlSubcommand || opts::RawSubcommand) && opts::raw::RawAll) {
    opts::raw::DumpHeaders = true;
    opts::raw::DumpModules = true;
    opts::raw::DumpModuleFiles = true;
    opts::raw::DumpModuleSyms = true;
    opts::raw::DumpPublics = true;
    opts::raw::DumpSectionHeaders = true;
    opts::raw::DumpStreamSummary = true;
    opts::raw::DumpStreamBlocks = true;
    opts::raw::DumpTpiRecords = true;
    opts::raw::DumpTpiHash = true;
    opts::raw::DumpIpiRecords = true;
    opts::raw::DumpSectionMap = true;
    opts::raw::DumpSectionContribs = true;
    opts::raw::DumpLineInfo = true;
    opts::raw::DumpFpo = true;
  }

  llvm::sys::InitializeCOMRAII COM(llvm::sys::COMThreadingMode::MultiThreaded);

  if (opts::PdbToYamlSubcommand) {
    pdb2Yaml(opts::pdb2yaml::InputFilename.front());
  } else if (opts::YamlToPdbSubcommand) {
    yamlToPdb(opts::yaml2pdb::InputFilename.front());
  } else if (opts::PrettySubcommand) {
    if (opts::pretty::Lines)
      opts::pretty::Compilands = true;

    if (opts::pretty::All) {
      opts::pretty::Compilands = true;
      opts::pretty::Symbols = true;
      opts::pretty::Globals = true;
      opts::pretty::Types = true;
      opts::pretty::Externals = true;
      opts::pretty::Lines = true;
    }

    // When adding filters for excluded compilands and types, we need to
    // remember
    // that these are regexes.  So special characters such as * and \ need to be
    // escaped in the regex.  In the case of a literal \, this means it needs to
    // be escaped again in the C++.  So matching a single \ in the input
    // requires
    // 4 \es in the C++.
    if (opts::pretty::ExcludeCompilerGenerated) {
      opts::pretty::ExcludeTypes.push_back("__vc_attributes");
      opts::pretty::ExcludeCompilands.push_back("\\* Linker \\*");
    }
    if (opts::pretty::ExcludeSystemLibraries) {
      opts::pretty::ExcludeCompilands.push_back(
          "f:\\\\binaries\\\\Intermediate\\\\vctools\\\\crt_bld");
      opts::pretty::ExcludeCompilands.push_back("f:\\\\dd\\\\vctools\\\\crt");
      opts::pretty::ExcludeCompilands.push_back(
          "d:\\\\th.obj.x86fre\\\\minkernel");
    }
    std::for_each(opts::pretty::InputFilenames.begin(),
                  opts::pretty::InputFilenames.end(), dumpPretty);
  } else if (opts::RawSubcommand) {
    std::for_each(opts::raw::InputFilenames.begin(),
                  opts::raw::InputFilenames.end(), dumpRaw);
  }

  outs().flush();
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d17 3
d23 2
a24 5
#include "PrettyCompilandDumper.h"
#include "PrettyExternalSymbolDumper.h"
#include "PrettyFunctionDumper.h"
#include "PrettyTypeDumper.h"
#include "PrettyVariableDumper.h"
d32 1
a32 2
#include "llvm/DebugInfo/MSF/ByteStream.h"
#include "llvm/DebugInfo/MSF/MSFBuilder.h"
a51 2
#include "llvm/DebugInfo/PDB/Raw/TpiStream.h"
#include "llvm/DebugInfo/PDB/Raw/TpiStreamBuilder.h"
a61 1
#include "llvm/Support/Regex.h"
a67 1
using namespace llvm::msf;
d70 21
a188 14
cl::opt<bool> DumpPageStats(
    "page-stats",
    cl::desc("dump allocation stats of the pages in the MSF file"),
    cl::cat(MsfOptions), cl::sub(RawSubcommand));
cl::opt<std::string>
    DumpBlockRangeOpt("block-data", cl::value_desc("start[-end]"),
                      cl::desc("Dump binary data from specified range."),
                      cl::cat(MsfOptions), cl::sub(RawSubcommand));
llvm::Optional<BlockRange> DumpBlockRange;

cl::list<uint32_t>
    DumpStreamData("stream-data", cl::CommaSeparated, cl::ZeroOrMore,
                   cl::desc("Dump binary data from specified streams."),
                   cl::cat(MsfOptions), cl::sub(RawSubcommand));
a219 2
cl::opt<bool> DumpGlobals("globals", cl::desc("dump globals stream data"),
                          cl::cat(SymbolOptions), cl::sub(RawSubcommand));
d241 8
a287 23
cl::opt<bool>
    DbiModuleInfo("dbi-module-info",
                  cl::desc("Dump DBI Module Information (implies -dbi-stream)"),
                  cl::sub(PdbToYamlSubcommand), cl::init(false));

cl::opt<bool> DbiModuleSyms(
    "dbi-module-syms",
    cl::desc("Dump DBI Module Information (implies -dbi-module-info)"),
    cl::sub(PdbToYamlSubcommand), cl::init(false));

cl::opt<bool> DbiModuleSourceFileInfo(
    "dbi-module-source-info",
    cl::desc(
        "Dump DBI Module Source File Information (implies -dbi-module-info"),
    cl::sub(PdbToYamlSubcommand), cl::init(false));

cl::opt<bool> TpiStream("tpi-stream",
                        cl::desc("Dump the TPI Stream (Stream 3)"),
                        cl::sub(PdbToYamlSubcommand), cl::init(false));

cl::opt<bool> IpiStream("ipi-stream",
                        cl::desc("Dump the IPI Stream (Stream 5)"),
                        cl::sub(PdbToYamlSubcommand), cl::init(false));
a297 1
  BumpPtrAllocator Allocator;
d309 1
a309 1
  pdb::yaml::PdbObject YamlObj(Allocator);
d315 26
a340 1
  PDBFileBuilder Builder(Allocator);
d342 15
a356 9
  ExitOnErr(Builder.initialize(YamlObj.Headers->SuperBlock.BlockSize));
  // Add each of the reserved streams.  We ignore stream metadata in the
  // yaml, because we will reconstruct our own view of the streams.  For
  // example, the YAML may say that there were 20 streams in the original
  // PDB, but maybe we only dump a subset of those 20 streams, so we will
  // have fewer, and the ones we do have may end up with different indices
  // than the ones in the original PDB.  So we just start with a clean slate.
  for (uint32_t I = 0; I < kSpecialStreamCount; ++I)
    ExitOnErr(Builder.getMsfBuilder().addStream(0));
a377 5
    for (const auto &MI : YamlObj.DbiStream->ModInfos) {
      ExitOnErr(DbiBuilder.addModuleInfo(MI.Obj, MI.Mod));
      for (auto S : MI.SourceFiles)
        ExitOnErr(DbiBuilder.addModuleSourceFile(MI.Mod, S));
    }
d380 2
a381 13
  if (YamlObj.TpiStream.hasValue()) {
    auto &TpiBuilder = Builder.getTpiBuilder();
    TpiBuilder.setVersionHeader(YamlObj.TpiStream->Version);
    for (const auto &R : YamlObj.TpiStream->Records)
      TpiBuilder.addTypeRecord(R.Record);
  }

  if (YamlObj.IpiStream.hasValue()) {
    auto &IpiBuilder = Builder.getIpiBuilder();
    IpiBuilder.setVersionHeader(YamlObj.IpiStream->Version);
    for (const auto &R : YamlObj.IpiStream->Records)
      IpiBuilder.addTypeRecord(R.Record);
  }
d383 2
a384 1
  ExitOnErr(Builder.commit(opts::yaml2pdb::YamlPdbOutputFile));
a541 16
  if (!opts::raw::DumpBlockRangeOpt.empty()) {
    llvm::Regex R("^([0-9]+)(-([0-9]+))?$");
    llvm::SmallVector<llvm::StringRef, 2> Matches;
    if (!R.match(opts::raw::DumpBlockRangeOpt, &Matches)) {
      errs() << "Argument '" << opts::raw::DumpBlockRangeOpt
             << "' invalid format.\n";
      errs().flush();
      exit(1);
    }
    opts::raw::DumpBlockRange.emplace();
    Matches[1].getAsInteger(10, opts::raw::DumpBlockRange->Min);
    if (!Matches[3].empty()) {
      opts::raw::DumpBlockRange->Max.emplace();
      Matches[3].getAsInteger(10, *opts::raw::DumpBlockRange->Max);
    }
  }
d543 2
a544 1
  if (opts::RawSubcommand && opts::raw::RawAll) {
a548 1
    opts::raw::DumpGlobals = true;
a551 1
    opts::raw::DumpPageStats = true;
d582 6
a587 4
    // remember that these are regexes.  So special characters such as * and \
    // need to be escaped in the regex.  In the case of a literal \, this means
    // it needs to be escaped again in the C++.  So matching a single \ in the
    // input requires 4 \es in the C++.
@


