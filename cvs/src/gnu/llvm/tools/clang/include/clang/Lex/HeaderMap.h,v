head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.56;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.56;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.49;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.03;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===--- HeaderMap.h - A file that acts like dir of symlinks ----*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines the HeaderMap interface.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_CLANG_LEX_HEADERMAP_H
#define LLVM_CLANG_LEX_HEADERMAP_H

#include "clang/Basic/LLVM.h"
#include "llvm/Support/Compiler.h"
#include <memory>

namespace llvm {
  class MemoryBuffer;
}
namespace clang {
  class FileEntry;
  class FileManager;
  struct HMapBucket;
  struct HMapHeader;

/// This class represents an Apple concept known as a 'header map'.  To the
/// \#include file resolution process, it basically acts like a directory of
/// symlinks to files.  Its advantages are that it is dense and more efficient
/// to create and process than a directory of symlinks.
class HeaderMap {
  HeaderMap(const HeaderMap &) = delete;
  void operator=(const HeaderMap &) = delete;

  std::unique_ptr<const llvm::MemoryBuffer> FileBuffer;
  bool NeedsBSwap;

  HeaderMap(std::unique_ptr<const llvm::MemoryBuffer> File, bool BSwap)
      : FileBuffer(std::move(File)), NeedsBSwap(BSwap) {}
public:
  /// HeaderMap::Create - This attempts to load the specified file as a header
  /// map.  If it doesn't look like a HeaderMap, it gives up and returns null.
  static const HeaderMap *Create(const FileEntry *FE, FileManager &FM);

  /// LookupFile - Check to see if the specified relative filename is located in
  /// this HeaderMap.  If so, open it and return its FileEntry.
  /// If RawPath is not NULL and the file is found, RawPath will be set to the
  /// raw path at which the file was found in the file system. For example,
  /// for a search path ".." and a filename "../file.h" this would be
  /// "../../file.h".
  const FileEntry *LookupFile(StringRef Filename, FileManager &FM) const;

  /// If the specified relative filename is located in this HeaderMap return
  /// the filename it is mapped to, otherwise return an empty StringRef.
  StringRef lookupFilename(StringRef Filename,
                           SmallVectorImpl<char> &DestPath) const;

  /// getFileName - Return the filename of the headermap.
  const char *getFileName() const;

  /// dump - Print the contents of this headermap to stderr.
  void dump() const;

private:
  unsigned getEndianAdjustedWord(unsigned X) const;
  const HMapHeader &getHeader() const;
  HMapBucket getBucket(unsigned BucketNo) const;
  const char *getString(unsigned StrTabIdx) const;
};

} // end namespace clang.

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@a17 1
#include "llvm/ADT/Optional.h"
a18 1
#include "llvm/Support/MemoryBuffer.h"
d21 3
d25 4
d30 7
a36 4
class FileEntry;
class FileManager;
struct HMapBucket;
struct HMapHeader;
a37 2
/// Implementation for \a HeaderMap that doesn't depend on \a FileManager.
class HeaderMapImpl {
d41 2
d44 3
a46 2
  HeaderMapImpl(std::unique_ptr<const llvm::MemoryBuffer> File, bool NeedsBSwap)
      : FileBuffer(std::move(File)), NeedsBSwap(NeedsBSwap) {}
d48 7
a54 2
  // Check for a valid header and extract the byte swap.
  static bool checkHeader(const llvm::MemoryBuffer &File, bool &NeedsByteSwap);
d61 1
a61 1
  /// Return the filename of the headermap.
d64 1
a64 1
  /// Print the contents of this headermap to stderr.
d71 1
a71 29

  /// Look up the specified string in the string table.  If the string index is
  /// not valid, return None.
  Optional<StringRef> getString(unsigned StrTabIdx) const;
};

/// This class represents an Apple concept known as a 'header map'.  To the
/// \#include file resolution process, it basically acts like a directory of
/// symlinks to files.  Its advantages are that it is dense and more efficient
/// to create and process than a directory of symlinks.
class HeaderMap : private HeaderMapImpl {
  HeaderMap(std::unique_ptr<const llvm::MemoryBuffer> File, bool BSwap)
      : HeaderMapImpl(std::move(File), BSwap) {}

public:
  /// This attempts to load the specified file as a header map.  If it doesn't
  /// look like a HeaderMap, it gives up and returns null.
  static const HeaderMap *Create(const FileEntry *FE, FileManager &FM);

  /// Check to see if the specified relative filename is located in this
  /// HeaderMap.  If so, open it and return its FileEntry.  If RawPath is not
  /// NULL and the file is found, RawPath will be set to the raw path at which
  /// the file was found in the file system. For example, for a search path
  /// ".." and a filename "../file.h" this would be "../../file.h".
  const FileEntry *LookupFile(StringRef Filename, FileManager &FM) const;

  using HeaderMapImpl::lookupFilename;
  using HeaderMapImpl::getFileName;
  using HeaderMapImpl::dump;
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d48 1
a48 1
  StringRef getFileName() const;
@


