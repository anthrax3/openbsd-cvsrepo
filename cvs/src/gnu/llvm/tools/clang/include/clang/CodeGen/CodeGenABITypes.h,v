head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.56;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.56;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.47;	author patrick;	state Exp;
branches;
next	;
commitid	qMUxATnKgqN83Oct;


desc
@@


1.1
log
@Initial revision
@
text
@//==---- CodeGenABITypes.h - Convert Clang types to LLVM types for ABI -----==//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// CodeGenABITypes is a simple interface for getting LLVM types for
// the parameters and the return value of a function given the Clang
// types.
//
// The class is implemented as a public wrapper around the private
// CodeGenTypes class in lib/CodeGen.
//
// It allows other clients, like LLDB, to determine the LLVM types that are
// actually used in function calls, which makes it possible to then determine
// the acutal ABI locations (e.g. registers, stack locations, etc.) that
// these parameters are stored in.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_CLANG_CODEGEN_CODEGENABITYPES_H
#define LLVM_CLANG_CODEGEN_CODEGENABITYPES_H

#include "clang/AST/CanonicalType.h"
#include "clang/AST/Type.h"
#include "clang/CodeGen/CGFunctionInfo.h"

namespace llvm {
  class DataLayout;
  class Module;
}

namespace clang {
class ASTContext;
class CXXRecordDecl;
class CXXMethodDecl;
class CodeGenOptions;
class CoverageSourceInfo;
class DiagnosticsEngine;
class HeaderSearchOptions;
class ObjCMethodDecl;
class PreprocessorOptions;

namespace CodeGen {
class CGFunctionInfo;
class CodeGenModule;

class CodeGenABITypes
{
public:
  CodeGenABITypes(ASTContext &C, llvm::Module &M,
                  CoverageSourceInfo *CoverageInfo = nullptr);
  ~CodeGenABITypes();

  /// These methods all forward to methods in the private implementation class
  /// CodeGenTypes.

  const CGFunctionInfo &arrangeObjCMessageSendSignature(
                                                     const ObjCMethodDecl *MD,
                                                     QualType receiverType);
  const CGFunctionInfo &arrangeFreeFunctionType(CanQual<FunctionProtoType> Ty,
                                                const FunctionDecl *FD);
  const CGFunctionInfo &arrangeFreeFunctionType(
                                             CanQual<FunctionNoProtoType> Ty);
  const CGFunctionInfo &arrangeCXXMethodType(const CXXRecordDecl *RD,
                                             const FunctionProtoType *FTP,
                                             const CXXMethodDecl *MD);
  const CGFunctionInfo &arrangeFreeFunctionCall(CanQualType returnType,
                                                ArrayRef<CanQualType> argTypes,
                                                FunctionType::ExtInfo info,
                                                RequiredArgs args);

private:
  /// Default CodeGenOptions object used to initialize the
  /// CodeGenModule and otherwise not used. More specifically, it is
  /// not used in ABI type generation, so none of the options matter.
  std::unique_ptr<CodeGenOptions> CGO;
  std::unique_ptr<HeaderSearchOptions> HSO;
  std::unique_ptr<PreprocessorOptions> PPO;

  /// The CodeGenModule we use get to the CodeGenTypes object.
  std::unique_ptr<CodeGen::CodeGenModule> CGM;
};

}  // end namespace CodeGen
}  // end namespace clang

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d51 6
a56 3
const CGFunctionInfo &arrangeObjCMessageSendSignature(CodeGenModule &CGM,
                                                      const ObjCMethodDecl *MD,
                                                      QualType receiverType);
d58 2
a59 3
const CGFunctionInfo &arrangeFreeFunctionType(CodeGenModule &CGM,
                                              CanQual<FunctionProtoType> Ty,
                                              const FunctionDecl *FD);
d61 14
a74 2
const CGFunctionInfo &arrangeFreeFunctionType(CodeGenModule &CGM,
                                              CanQual<FunctionNoProtoType> Ty);
d76 7
a82 4
const CGFunctionInfo &arrangeCXXMethodType(CodeGenModule &CGM,
                                           const CXXRecordDecl *RD,
                                           const FunctionProtoType *FTP,
                                           const CXXMethodDecl *MD);
d84 3
a86 5
const CGFunctionInfo &arrangeFreeFunctionCall(CodeGenModule &CGM,
                                              CanQualType returnType,
                                              ArrayRef<CanQualType> argTypes,
                                              FunctionType::ExtInfo info,
                                              RequiredArgs args);
@

