head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.56;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.56;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.48;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.04;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===--- ASTConsumer.h - Abstract interface for reading ASTs ----*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
//  This file defines the ASTConsumer class.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_CLANG_AST_ASTCONSUMER_H
#define LLVM_CLANG_AST_ASTCONSUMER_H

#include "llvm/ADT/StringRef.h"

namespace clang {
  class ASTContext;
  class CXXMethodDecl;
  class CXXRecordDecl;
  class Decl;
  class DeclGroupRef;
  class ASTMutationListener;
  class ASTDeserializationListener; // layering violation because void* is ugly
  class SemaConsumer; // layering violation required for safe SemaConsumer
  class TagDecl;
  class VarDecl;
  class FunctionDecl;
  class ImportDecl;

/// ASTConsumer - This is an abstract interface that should be implemented by
/// clients that read ASTs.  This abstraction layer allows the client to be
/// independent of the AST producer (e.g. parser vs AST dump file reader, etc).
class ASTConsumer {
  /// \brief Whether this AST consumer also requires information about
  /// semantic analysis.
  bool SemaConsumer;

  friend class SemaConsumer;

public:
  ASTConsumer() : SemaConsumer(false) { }

  virtual ~ASTConsumer() {}

  /// Initialize - This is called to initialize the consumer, providing the
  /// ASTContext.
  virtual void Initialize(ASTContext &Context) {}

  /// HandleTopLevelDecl - Handle the specified top-level declaration.  This is
  /// called by the parser to process every top-level Decl*.
  ///
  /// \returns true to continue parsing, or false to abort parsing.
  virtual bool HandleTopLevelDecl(DeclGroupRef D);

  /// \brief This callback is invoked each time an inline method definition is
  /// completed.
  virtual void HandleInlineMethodDefinition(CXXMethodDecl *D) {}

  /// HandleInterestingDecl - Handle the specified interesting declaration. This
  /// is called by the AST reader when deserializing things that might interest
  /// the consumer. The default implementation forwards to HandleTopLevelDecl.
  virtual void HandleInterestingDecl(DeclGroupRef D);

  /// HandleTranslationUnit - This method is called when the ASTs for entire
  /// translation unit have been parsed.
  virtual void HandleTranslationUnit(ASTContext &Ctx) {}

  /// HandleTagDeclDefinition - This callback is invoked each time a TagDecl
  /// (e.g. struct, union, enum, class) is completed.  This allows the client to
  /// hack on the type, which can occur at any point in the file (because these
  /// can be defined in declspecs).
  virtual void HandleTagDeclDefinition(TagDecl *D) {}

  /// \brief This callback is invoked the first time each TagDecl is required to
  /// be complete.
  virtual void HandleTagDeclRequiredDefinition(const TagDecl *D) {}

  /// \brief Invoked when a function is implicitly instantiated.
  /// Note that at this point point it does not have a body, its body is
  /// instantiated at the end of the translation unit and passed to
  /// HandleTopLevelDecl.
  virtual void HandleCXXImplicitFunctionInstantiation(FunctionDecl *D) {}

  /// \brief Handle the specified top-level declaration that occurred inside
  /// and ObjC container.
  /// The default implementation ignored them.
  virtual void HandleTopLevelDeclInObjCContainer(DeclGroupRef D);

  /// \brief Handle an ImportDecl that was implicitly created due to an
  /// inclusion directive.
  /// The default implementation passes it to HandleTopLevelDecl.
  virtual void HandleImplicitImportDecl(ImportDecl *D);

  /// \brief Handle a pragma that appends to Linker Options.  Currently this
  /// only exists to support Microsoft's #pragma comment(linker, "/foo").
  virtual void HandleLinkerOptionPragma(llvm::StringRef Opts) {}

  /// \brief Handle a pragma that emits a mismatch identifier and value to the
  /// object file for the linker to work with.  Currently, this only exists to
  /// support Microsoft's #pragma detect_mismatch.
  virtual void HandleDetectMismatch(llvm::StringRef Name,
                                    llvm::StringRef Value) {}

  /// \brief Handle a dependent library created by a pragma in the source.
  /// Currently this only exists to support Microsoft's
  /// #pragma comment(lib, "/foo").
  virtual void HandleDependentLibrary(llvm::StringRef Lib) {}

  /// CompleteTentativeDefinition - Callback invoked at the end of a translation
  /// unit to notify the consumer that the given tentative definition should be
  /// completed.
  ///
  /// The variable declaration itself will be a tentative
  /// definition. If it had an incomplete array type, its type will
  /// have already been changed to an array of size 1. However, the
  /// declaration remains a tentative definition and has not been
  /// modified by the introduction of an implicit zero initializer.
  virtual void CompleteTentativeDefinition(VarDecl *D) {}

  /// HandleCXXStaticMemberVarInstantiation - Tell the consumer that this
  // variable has been instantiated.
  virtual void HandleCXXStaticMemberVarInstantiation(VarDecl *D) {}

  /// \brief Callback involved at the end of a translation unit to
  /// notify the consumer that a vtable for the given C++ class is
  /// required.
  ///
  /// \param RD The class whose vtable was used.
  virtual void HandleVTable(CXXRecordDecl *RD) {}

  /// \brief If the consumer is interested in entities getting modified after
  /// their initial creation, it should return a pointer to
  /// an ASTMutationListener here.
  virtual ASTMutationListener *GetASTMutationListener() { return nullptr; }

  /// \brief If the consumer is interested in entities being deserialized from
  /// AST files, it should return a pointer to a ASTDeserializationListener here
  virtual ASTDeserializationListener *GetASTDeserializationListener() {
    return nullptr;
  }

  /// PrintStats - If desired, print any statistics.
  virtual void PrintStats() {}

  /// \brief This callback is called for each function if the Parser was
  /// initialized with \c SkipFunctionBodies set to \c true.
  ///
  /// \return \c true if the function's body should be skipped. The function
  /// body may be parsed anyway if it is needed (for instance, if it contains
  /// the code completion point or is constexpr).
  virtual bool shouldSkipFunctionBody(Decl *D) { return true; }
};

} // end namespace clang.

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d58 3
a60 3
  /// \brief This callback is invoked each time an inline (method or friend)
  /// function definition in a class is completed.
  virtual void HandleInlineFunctionDefinition(FunctionDecl *D) {}
d97 15
a121 4

  /// \brief Callback invoked when an MSInheritanceAttr has been attached to a
  /// CXXRecordDecl.
  virtual void AssignInheritanceModel(CXXRecordDecl *RD) {}
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d17 2
@


