head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.2.0.6
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.57;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.57;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.50;	author patrick;	state Exp;
branches;
next	;
commitid	qMUxATnKgqN83Oct;


desc
@@


1.1
log
@Initial revision
@
text
@/*===---- arm_acle.h - ARM Non-Neon intrinsics -----------------------------===
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef __ARM_ACLE_H
#define __ARM_ACLE_H

#ifndef __ARM_ACLE
#error "ACLE intrinsics support not enabled."
#endif

#include <stdint.h>

#if defined(__cplusplus)
extern "C" {
#endif

/* 8 SYNCHRONIZATION, BARRIER AND HINT INTRINSICS */
/* 8.3 Memory barriers */
#if !defined(_MSC_VER)
#define __dmb(i) __builtin_arm_dmb(i)
#define __dsb(i) __builtin_arm_dsb(i)
#define __isb(i) __builtin_arm_isb(i)
#endif

/* 8.4 Hints */

#if !defined(_MSC_VER)
static __inline__ void __attribute__((__always_inline__, __nodebug__)) __wfi(void) {
  __builtin_arm_wfi();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__)) __wfe(void) {
  __builtin_arm_wfe();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__)) __sev(void) {
  __builtin_arm_sev();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__)) __sevl(void) {
  __builtin_arm_sevl();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__)) __yield(void) {
  __builtin_arm_yield();
}
#endif

#if __ARM_32BIT_STATE
#define __dbg(t) __builtin_arm_dbg(t)
#endif

/* 8.5 Swap */
static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
  __swp(uint32_t x, volatile uint32_t *p) {
  uint32_t v;
  do v = __builtin_arm_ldrex(p); while (__builtin_arm_strex(x, p));
  return v;
}

/* 8.6 Memory prefetch intrinsics */
/* 8.6.1 Data prefetch */
#define __pld(addr) __pldx(0, 0, 0, addr)

#if __ARM_32BIT_STATE
#define __pldx(access_kind, cache_level, retention_policy, addr) \
  __builtin_arm_prefetch(addr, access_kind, 1)
#else
#define __pldx(access_kind, cache_level, retention_policy, addr) \
  __builtin_arm_prefetch(addr, access_kind, cache_level, retention_policy, 1)
#endif

/* 8.6.2 Instruction prefetch */
#define __pli(addr) __plix(0, 0, addr)

#if __ARM_32BIT_STATE
#define __plix(cache_level, retention_policy, addr) \
  __builtin_arm_prefetch(addr, 0, 0)
#else
#define __plix(cache_level, retention_policy, addr) \
  __builtin_arm_prefetch(addr, 0, cache_level, retention_policy, 0)
#endif

/* 8.7 NOP */
static __inline__ void __attribute__((__always_inline__, __nodebug__)) __nop(void) {
  __builtin_arm_nop();
}

/* 9 DATA-PROCESSING INTRINSICS */
/* 9.2 Miscellaneous data-processing intrinsics */
/* ROR */
static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
  __ror(uint32_t x, uint32_t y) {
  y %= 32;
  if (y == 0)  return x;
  return (x >> y) | (x << (32 - y));
}

static __inline__ uint64_t __attribute__((__always_inline__, __nodebug__))
  __rorll(uint64_t x, uint32_t y) {
  y %= 64;
  if (y == 0)  return x;
  return (x >> y) | (x << (64 - y));
}

static __inline__ unsigned long __attribute__((__always_inline__, __nodebug__))
  __rorl(unsigned long x, uint32_t y) {
#if __SIZEOF_LONG__ == 4
  return __ror(x, y);
#else
  return __rorll(x, y);
#endif
}


/* CLZ */
static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
  __clz(uint32_t t) {
  return __builtin_clz(t);
}

static __inline__ unsigned long __attribute__((__always_inline__, __nodebug__))
  __clzl(unsigned long t) {
  return __builtin_clzl(t);
}

static __inline__ uint64_t __attribute__((__always_inline__, __nodebug__))
  __clzll(uint64_t t) {
  return __builtin_clzll(t);
}

/* REV */
static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
  __rev(uint32_t t) {
  return __builtin_bswap32(t);
}

static __inline__ unsigned long __attribute__((__always_inline__, __nodebug__))
  __revl(unsigned long t) {
#if __SIZEOF_LONG__ == 4
  return __builtin_bswap32(t);
#else
  return __builtin_bswap64(t);
#endif
}

static __inline__ uint64_t __attribute__((__always_inline__, __nodebug__))
  __revll(uint64_t t) {
  return __builtin_bswap64(t);
}

/* REV16 */
static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
  __rev16(uint32_t t) {
  return __ror(__rev(t), 16);
}

static __inline__ uint64_t __attribute__((__always_inline__, __nodebug__))
  __rev16ll(uint64_t t) {
  return (((uint64_t)__rev16(t >> 32)) << 32) | __rev16(t);
}

static __inline__ unsigned long __attribute__((__always_inline__, __nodebug__))
  __rev16l(unsigned long t) {
#if __SIZEOF_LONG__ == 4
    return __rev16(t);
#else
    return __rev16ll(t);
#endif
}

/* REVSH */
static __inline__ int16_t __attribute__((__always_inline__, __nodebug__))
  __revsh(int16_t t) {
  return __builtin_bswap16(t);
}

/* RBIT */
static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
  __rbit(uint32_t t) {
  return __builtin_arm_rbit(t);
}

static __inline__ uint64_t __attribute__((__always_inline__, __nodebug__))
  __rbitll(uint64_t t) {
#if __ARM_32BIT_STATE
  return (((uint64_t) __builtin_arm_rbit(t)) << 32) |
    __builtin_arm_rbit(t >> 32);
#else
  return __builtin_arm_rbit64(t);
#endif
}

static __inline__ unsigned long __attribute__((__always_inline__, __nodebug__))
  __rbitl(unsigned long t) {
#if __SIZEOF_LONG__ == 4
  return __rbit(t);
#else
  return __rbitll(t);
#endif
}

/*
 * 9.4 Saturating intrinsics
 *
 * FIXME: Change guard to their corrosponding __ARM_FEATURE flag when Q flag
 * intrinsics are implemented and the flag is enabled.
 */
/* 9.4.1 Width-specified saturation intrinsics */
#if __ARM_32BIT_STATE
#define __ssat(x, y) __builtin_arm_ssat(x, y)
#define __usat(x, y) __builtin_arm_usat(x, y)
#endif

/* 9.4.2 Saturating addition and subtraction intrinsics */
#if __ARM_32BIT_STATE
static __inline__ int32_t __attribute__((__always_inline__, __nodebug__))
  __qadd(int32_t t, int32_t v) {
  return __builtin_arm_qadd(t, v);
}

static __inline__ int32_t __attribute__((__always_inline__, __nodebug__))
  __qsub(int32_t t, int32_t v) {
  return __builtin_arm_qsub(t, v);
}

static __inline__ int32_t __attribute__((__always_inline__, __nodebug__))
__qdbl(int32_t t) {
  return __builtin_arm_qadd(t, t);
}
#endif

/* 9.7 CRC32 intrinsics */
#if __ARM_FEATURE_CRC32
static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
  __crc32b(uint32_t a, uint8_t b) {
  return __builtin_arm_crc32b(a, b);
}

static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
  __crc32h(uint32_t a, uint16_t b) {
  return __builtin_arm_crc32h(a, b);
}

static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
  __crc32w(uint32_t a, uint32_t b) {
  return __builtin_arm_crc32w(a, b);
}

static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
  __crc32d(uint32_t a, uint64_t b) {
  return __builtin_arm_crc32d(a, b);
}

static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
  __crc32cb(uint32_t a, uint8_t b) {
  return __builtin_arm_crc32cb(a, b);
}

static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
  __crc32ch(uint32_t a, uint16_t b) {
  return __builtin_arm_crc32ch(a, b);
}

static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
  __crc32cw(uint32_t a, uint32_t b) {
  return __builtin_arm_crc32cw(a, b);
}

static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
  __crc32cd(uint32_t a, uint64_t b) {
  return __builtin_arm_crc32cd(a, b);
}
#endif

/* 10.1 Special register intrinsics */
#define __arm_rsr(sysreg) __builtin_arm_rsr(sysreg)
#define __arm_rsr64(sysreg) __builtin_arm_rsr64(sysreg)
#define __arm_rsrp(sysreg) __builtin_arm_rsrp(sysreg)
#define __arm_wsr(sysreg, v) __builtin_arm_wsr(sysreg, v)
#define __arm_wsr64(sysreg, v) __builtin_arm_wsr64(sysreg, v)
#define __arm_wsrp(sysreg, v) __builtin_arm_wsrp(sysreg, v)

#if defined(__cplusplus)
}
#endif

#endif /* __ARM_ACLE_H */
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d75 1
a75 1
__swp(uint32_t __x, volatile uint32_t *__p) {
d77 1
a77 3
  do
    v = __builtin_arm_ldrex(__p);
  while (__builtin_arm_strex(__x, __p));
d113 4
a116 5
__ror(uint32_t __x, uint32_t __y) {
  __y %= 32;
  if (__y == 0)
    return __x;
  return (__x >> __y) | (__x << (32 - __y));
d120 4
a123 5
__rorll(uint64_t __x, uint32_t __y) {
  __y %= 64;
  if (__y == 0)
    return __x;
  return (__x >> __y) | (__x << (64 - __y));
d127 1
a127 1
__rorl(unsigned long __x, uint32_t __y) {
d129 1
a129 1
  return __ror(__x, __y);
d131 1
a131 1
  return __rorll(__x, __y);
d138 2
a139 2
__clz(uint32_t __t) {
  return __builtin_clz(__t);
d143 2
a144 2
__clzl(unsigned long __t) {
  return __builtin_clzl(__t);
d148 2
a149 2
__clzll(uint64_t __t) {
  return __builtin_clzll(__t);
d154 2
a155 2
__rev(uint32_t __t) {
  return __builtin_bswap32(__t);
d159 1
a159 1
__revl(unsigned long __t) {
d161 1
a161 1
  return __builtin_bswap32(__t);
d163 1
a163 1
  return __builtin_bswap64(__t);
d168 2
a169 2
__revll(uint64_t __t) {
  return __builtin_bswap64(__t);
d174 2
a175 2
__rev16(uint32_t __t) {
  return __ror(__rev(__t), 16);
d179 2
a180 2
__rev16ll(uint64_t __t) {
  return (((uint64_t)__rev16(__t >> 32)) << 32) | __rev16(__t);
d184 1
a184 1
__rev16l(unsigned long __t) {
d186 1
a186 1
    return __rev16(__t);
d188 1
a188 1
    return __rev16ll(__t);
d194 2
a195 2
__revsh(int16_t __t) {
  return __builtin_bswap16(__t);
d200 2
a201 2
__rbit(uint32_t __t) {
  return __builtin_arm_rbit(__t);
d205 1
a205 1
__rbitll(uint64_t __t) {
d207 2
a208 2
  return (((uint64_t)__builtin_arm_rbit(__t)) << 32) |
         __builtin_arm_rbit(__t >> 32);
d210 1
a210 1
  return __builtin_arm_rbit64(__t);
d215 1
a215 1
__rbitl(unsigned long __t) {
d217 1
a217 1
  return __rbit(__t);
d219 1
a219 1
  return __rbitll(__t);
d238 2
a239 2
__qadd(int32_t __t, int32_t __v) {
  return __builtin_arm_qadd(__t, __v);
d243 2
a244 2
__qsub(int32_t __t, int32_t __v) {
  return __builtin_arm_qsub(__t, __v);
d248 2
a249 2
__qdbl(int32_t __t) {
  return __builtin_arm_qadd(__t, __t);
d256 2
a257 2
__crc32b(uint32_t __a, uint8_t __b) {
  return __builtin_arm_crc32b(__a, __b);
d261 2
a262 2
__crc32h(uint32_t __a, uint16_t __b) {
  return __builtin_arm_crc32h(__a, __b);
d266 2
a267 2
__crc32w(uint32_t __a, uint32_t __b) {
  return __builtin_arm_crc32w(__a, __b);
d271 2
a272 2
__crc32d(uint32_t __a, uint64_t __b) {
  return __builtin_arm_crc32d(__a, __b);
d276 2
a277 2
__crc32cb(uint32_t __a, uint8_t __b) {
  return __builtin_arm_crc32cb(__a, __b);
d281 2
a282 2
__crc32ch(uint32_t __a, uint16_t __b) {
  return __builtin_arm_crc32ch(__a, __b);
d286 2
a287 2
__crc32cw(uint32_t __a, uint32_t __b) {
  return __builtin_arm_crc32cw(__a, __b);
d291 2
a292 2
__crc32cd(uint32_t __a, uint64_t __b) {
  return __builtin_arm_crc32cd(__a, __b);
@

