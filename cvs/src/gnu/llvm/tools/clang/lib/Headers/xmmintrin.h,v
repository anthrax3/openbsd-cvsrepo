head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.56;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.56;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.50;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.07;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@/*===---- xmmintrin.h - SSE intrinsics -------------------------------------===
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef __XMMINTRIN_H
#define __XMMINTRIN_H

#include <mmintrin.h>

typedef int __v4si __attribute__((__vector_size__(16)));
typedef float __v4sf __attribute__((__vector_size__(16)));
typedef float __m128 __attribute__((__vector_size__(16)));

/* This header should only be included in a hosted environment as it depends on
 * a standard library to provide allocation routines. */
#if __STDC_HOSTED__
#include <mm_malloc.h>
#endif

/* Define the default attributes for the functions in this file. */
#define __DEFAULT_FN_ATTRS __attribute__((__always_inline__, __nodebug__, __target__("sse")))

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_add_ss(__m128 __a, __m128 __b)
{
  __a[0] += __b[0];
  return __a;
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_add_ps(__m128 __a, __m128 __b)
{
  return __a + __b;
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_sub_ss(__m128 __a, __m128 __b)
{
  __a[0] -= __b[0];
  return __a;
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_sub_ps(__m128 __a, __m128 __b)
{
  return __a - __b;
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_mul_ss(__m128 __a, __m128 __b)
{
  __a[0] *= __b[0];
  return __a;
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_mul_ps(__m128 __a, __m128 __b)
{
  return __a * __b;
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_div_ss(__m128 __a, __m128 __b)
{
  __a[0] /= __b[0];
  return __a;
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_div_ps(__m128 __a, __m128 __b)
{
  return __a / __b;
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_sqrt_ss(__m128 __a)
{
  __m128 __c = __builtin_ia32_sqrtss(__a);
  return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_sqrt_ps(__m128 __a)
{
  return __builtin_ia32_sqrtps(__a);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_rcp_ss(__m128 __a)
{
  __m128 __c = __builtin_ia32_rcpss(__a);
  return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_rcp_ps(__m128 __a)
{
  return __builtin_ia32_rcpps(__a);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_rsqrt_ss(__m128 __a)
{
  __m128 __c = __builtin_ia32_rsqrtss(__a);
  return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_rsqrt_ps(__m128 __a)
{
  return __builtin_ia32_rsqrtps(__a);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_min_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_minss(__a, __b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_min_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_minps(__a, __b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_max_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_maxss(__a, __b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_max_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_maxps(__a, __b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_and_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4si)__a & (__v4si)__b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_andnot_ps(__m128 __a, __m128 __b)
{
  return (__m128)(~(__v4si)__a & (__v4si)__b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_or_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4si)__a | (__v4si)__b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_xor_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4si)__a ^ (__v4si)__b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmpeq_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpeqss(__a, __b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmpeq_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpeqps(__a, __b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmplt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpltss(__a, __b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmplt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpltps(__a, __b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmple_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpless(__a, __b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmple_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpleps(__a, __b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmpgt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpltss(__b, __a),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmpgt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpltps(__b, __a);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmpge_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpless(__b, __a),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmpge_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpleps(__b, __a);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmpneq_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpneqss(__a, __b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmpneq_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpneqps(__a, __b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmpnlt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnltss(__a, __b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmpnlt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnltps(__a, __b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmpnle_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnless(__a, __b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmpnle_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnleps(__a, __b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmpngt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpnltss(__b, __a),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmpngt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnltps(__b, __a);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmpnge_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpnless(__b, __a),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmpnge_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnleps(__b, __a);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmpord_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpordss(__a, __b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmpord_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpordps(__a, __b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmpunord_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpunordss(__a, __b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cmpunord_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpunordps(__a, __b);
}

static __inline__ int __DEFAULT_FN_ATTRS
_mm_comieq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comieq(__a, __b);
}

static __inline__ int __DEFAULT_FN_ATTRS
_mm_comilt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comilt(__a, __b);
}

static __inline__ int __DEFAULT_FN_ATTRS
_mm_comile_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comile(__a, __b);
}

static __inline__ int __DEFAULT_FN_ATTRS
_mm_comigt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comigt(__a, __b);
}

static __inline__ int __DEFAULT_FN_ATTRS
_mm_comige_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comige(__a, __b);
}

static __inline__ int __DEFAULT_FN_ATTRS
_mm_comineq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comineq(__a, __b);
}

static __inline__ int __DEFAULT_FN_ATTRS
_mm_ucomieq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomieq(__a, __b);
}

static __inline__ int __DEFAULT_FN_ATTRS
_mm_ucomilt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomilt(__a, __b);
}

static __inline__ int __DEFAULT_FN_ATTRS
_mm_ucomile_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomile(__a, __b);
}

static __inline__ int __DEFAULT_FN_ATTRS
_mm_ucomigt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomigt(__a, __b);
}

static __inline__ int __DEFAULT_FN_ATTRS
_mm_ucomige_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomige(__a, __b);
}

static __inline__ int __DEFAULT_FN_ATTRS
_mm_ucomineq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomineq(__a, __b);
}

static __inline__ int __DEFAULT_FN_ATTRS
_mm_cvtss_si32(__m128 __a)
{
  return __builtin_ia32_cvtss2si(__a);
}

static __inline__ int __DEFAULT_FN_ATTRS
_mm_cvt_ss2si(__m128 __a)
{
  return _mm_cvtss_si32(__a);
}

#ifdef __x86_64__

static __inline__ long long __DEFAULT_FN_ATTRS
_mm_cvtss_si64(__m128 __a)
{
  return __builtin_ia32_cvtss2si64(__a);
}

#endif

static __inline__ __m64 __DEFAULT_FN_ATTRS
_mm_cvtps_pi32(__m128 __a)
{
  return (__m64)__builtin_ia32_cvtps2pi(__a);
}

static __inline__ __m64 __DEFAULT_FN_ATTRS
_mm_cvt_ps2pi(__m128 __a)
{
  return _mm_cvtps_pi32(__a);
}

static __inline__ int __DEFAULT_FN_ATTRS
_mm_cvttss_si32(__m128 __a)
{
  return __a[0];
}

static __inline__ int __DEFAULT_FN_ATTRS
_mm_cvtt_ss2si(__m128 __a)
{
  return _mm_cvttss_si32(__a);
}

static __inline__ long long __DEFAULT_FN_ATTRS
_mm_cvttss_si64(__m128 __a)
{
  return __a[0];
}

static __inline__ __m64 __DEFAULT_FN_ATTRS
_mm_cvttps_pi32(__m128 __a)
{
  return (__m64)__builtin_ia32_cvttps2pi(__a);
}

static __inline__ __m64 __DEFAULT_FN_ATTRS
_mm_cvtt_ps2pi(__m128 __a)
{
  return _mm_cvttps_pi32(__a);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cvtsi32_ss(__m128 __a, int __b)
{
  __a[0] = __b;
  return __a;
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cvt_si2ss(__m128 __a, int __b)
{
  return _mm_cvtsi32_ss(__a, __b);
}

#ifdef __x86_64__

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cvtsi64_ss(__m128 __a, long long __b)
{
  __a[0] = __b;
  return __a;
}

#endif

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cvtpi32_ps(__m128 __a, __m64 __b)
{
  return __builtin_ia32_cvtpi2ps(__a, (__v2si)__b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cvt_pi2ps(__m128 __a, __m64 __b)
{
  return _mm_cvtpi32_ps(__a, __b);
}

static __inline__ float __DEFAULT_FN_ATTRS
_mm_cvtss_f32(__m128 __a)
{
  return __a[0];
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_loadh_pi(__m128 __a, const __m64 *__p)
{
  typedef float __mm_loadh_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadh_pi_struct {
    __mm_loadh_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadh_pi_v2f32 __b = ((struct __mm_loadh_pi_struct*)__p)->__u;
  __m128 __bb = __builtin_shufflevector(__b, __b, 0, 1, 0, 1);
  return __builtin_shufflevector(__a, __bb, 0, 1, 4, 5);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_loadl_pi(__m128 __a, const __m64 *__p)
{
  typedef float __mm_loadl_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadl_pi_struct {
    __mm_loadl_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadl_pi_v2f32 __b = ((struct __mm_loadl_pi_struct*)__p)->__u;
  __m128 __bb = __builtin_shufflevector(__b, __b, 0, 1, 0, 1);
  return __builtin_shufflevector(__a, __bb, 4, 5, 2, 3);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_load_ss(const float *__p)
{
  struct __mm_load_ss_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((struct __mm_load_ss_struct*)__p)->__u;
  return (__m128){ __u, 0, 0, 0 };
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_load1_ps(const float *__p)
{
  struct __mm_load1_ps_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((struct __mm_load1_ps_struct*)__p)->__u;
  return (__m128){ __u, __u, __u, __u };
}

#define        _mm_load_ps1(p) _mm_load1_ps(p)

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_load_ps(const float *__p)
{
  return *(__m128*)__p;
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_loadu_ps(const float *__p)
{
  struct __loadu_ps {
    __m128 __v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_ps*)__p)->__v;
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_loadr_ps(const float *__p)
{
  __m128 __a = _mm_load_ps(__p);
  return __builtin_shufflevector(__a, __a, 3, 2, 1, 0);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_undefined_ps()
{
  return (__m128)__builtin_ia32_undef128();
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_set_ss(float __w)
{
  return (__m128){ __w, 0, 0, 0 };
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_set1_ps(float __w)
{
  return (__m128){ __w, __w, __w, __w };
}

/* Microsoft specific. */
static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_set_ps1(float __w)
{
    return _mm_set1_ps(__w);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_set_ps(float __z, float __y, float __x, float __w)
{
  return (__m128){ __w, __x, __y, __z };
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_setr_ps(float __z, float __y, float __x, float __w)
{
  return (__m128){ __z, __y, __x, __w };
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_setzero_ps(void)
{
  return (__m128){ 0, 0, 0, 0 };
}

static __inline__ void __DEFAULT_FN_ATTRS
_mm_storeh_pi(__m64 *__p, __m128 __a)
{
  __builtin_ia32_storehps((__v2si *)__p, __a);
}

static __inline__ void __DEFAULT_FN_ATTRS
_mm_storel_pi(__m64 *__p, __m128 __a)
{
  __builtin_ia32_storelps((__v2si *)__p, __a);
}

static __inline__ void __DEFAULT_FN_ATTRS
_mm_store_ss(float *__p, __m128 __a)
{
  struct __mm_store_ss_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_ss_struct*)__p)->__u = __a[0];
}

static __inline__ void __DEFAULT_FN_ATTRS
_mm_storeu_ps(float *__p, __m128 __a)
{
  __builtin_ia32_storeups(__p, __a);
}

static __inline__ void __DEFAULT_FN_ATTRS
_mm_store1_ps(float *__p, __m128 __a)
{
  __a = __builtin_shufflevector(__a, __a, 0, 0, 0, 0);
  _mm_storeu_ps(__p, __a);
}

static __inline__ void __DEFAULT_FN_ATTRS
_mm_store_ps1(float *__p, __m128 __a)
{
    return _mm_store1_ps(__p, __a);
}

static __inline__ void __DEFAULT_FN_ATTRS
_mm_store_ps(float *__p, __m128 __a)
{
  *(__m128 *)__p = __a;
}

static __inline__ void __DEFAULT_FN_ATTRS
_mm_storer_ps(float *__p, __m128 __a)
{
  __a = __builtin_shufflevector(__a, __a, 3, 2, 1, 0);
  _mm_store_ps(__p, __a);
}

#define _MM_HINT_T0 3
#define _MM_HINT_T1 2
#define _MM_HINT_T2 1
#define _MM_HINT_NTA 0

#ifndef _MSC_VER
/* FIXME: We have to #define this because "sel" must be a constant integer, and
   Sema doesn't do any form of constant propagation yet. */

#define _mm_prefetch(a, sel) (__builtin_prefetch((void *)(a), 0, (sel)))
#endif

static __inline__ void __DEFAULT_FN_ATTRS
_mm_stream_pi(__m64 *__p, __m64 __a)
{
  __builtin_ia32_movntq(__p, __a);
}

static __inline__ void __DEFAULT_FN_ATTRS
_mm_stream_ps(float *__p, __m128 __a)
{
  __builtin_ia32_movntps(__p, __a);
}

static __inline__ void __DEFAULT_FN_ATTRS
_mm_sfence(void)
{
  __builtin_ia32_sfence();
}

static __inline__ int __DEFAULT_FN_ATTRS
_mm_extract_pi16(__m64 __a, int __n)
{
  __v4hi __b = (__v4hi)__a;
  return (unsigned short)__b[__n & 3];
}

static __inline__ __m64 __DEFAULT_FN_ATTRS
_mm_insert_pi16(__m64 __a, int __d, int __n)
{
   __v4hi __b = (__v4hi)__a;
   __b[__n & 3] = __d;
   return (__m64)__b;
}

static __inline__ __m64 __DEFAULT_FN_ATTRS
_mm_max_pi16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmaxsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __DEFAULT_FN_ATTRS
_mm_max_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmaxub((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m64 __DEFAULT_FN_ATTRS
_mm_min_pi16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pminsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __DEFAULT_FN_ATTRS
_mm_min_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pminub((__v8qi)__a, (__v8qi)__b);
}

static __inline__ int __DEFAULT_FN_ATTRS
_mm_movemask_pi8(__m64 __a)
{
  return __builtin_ia32_pmovmskb((__v8qi)__a);
}

static __inline__ __m64 __DEFAULT_FN_ATTRS
_mm_mulhi_pu16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmulhuw((__v4hi)__a, (__v4hi)__b);
}

#define _mm_shuffle_pi16(a, n) __extension__ ({ \
  (__m64)__builtin_ia32_pshufw((__v4hi)(__m64)(a), (n)); })

static __inline__ void __DEFAULT_FN_ATTRS
_mm_maskmove_si64(__m64 __d, __m64 __n, char *__p)
{
  __builtin_ia32_maskmovq((__v8qi)__d, (__v8qi)__n, __p);
}

static __inline__ __m64 __DEFAULT_FN_ATTRS
_mm_avg_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pavgb((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m64 __DEFAULT_FN_ATTRS
_mm_avg_pu16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pavgw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __DEFAULT_FN_ATTRS
_mm_sad_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_psadbw((__v8qi)__a, (__v8qi)__b);
}

static __inline__ unsigned int __DEFAULT_FN_ATTRS
_mm_getcsr(void)
{
  return __builtin_ia32_stmxcsr();
}

static __inline__ void __DEFAULT_FN_ATTRS
_mm_setcsr(unsigned int __i)
{
  __builtin_ia32_ldmxcsr(__i);
}

#define _mm_shuffle_ps(a, b, mask) __extension__ ({ \
  (__m128)__builtin_shufflevector((__v4sf)(__m128)(a), (__v4sf)(__m128)(b), \
                                  (mask) & 0x3, ((mask) & 0xc) >> 2, \
                                  (((mask) & 0x30) >> 4) + 4, \
                                  (((mask) & 0xc0) >> 6) + 4); })

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_unpackhi_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 2, 6, 3, 7);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_unpacklo_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 0, 4, 1, 5);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_move_ss(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 4, 1, 2, 3);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_movehl_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 6, 7, 2, 3);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_movelh_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 0, 1, 4, 5);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cvtpi16_ps(__m64 __a)
{
  __m64 __b, __c;
  __m128 __r;

  __b = _mm_setzero_si64();
  __b = _mm_cmpgt_pi16(__b, __a);
  __c = _mm_unpackhi_pi16(__a, __b);
  __r = _mm_setzero_ps();
  __r = _mm_cvtpi32_ps(__r, __c);
  __r = _mm_movelh_ps(__r, __r);
  __c = _mm_unpacklo_pi16(__a, __b);
  __r = _mm_cvtpi32_ps(__r, __c);

  return __r;
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cvtpu16_ps(__m64 __a)
{
  __m64 __b, __c;
  __m128 __r;

  __b = _mm_setzero_si64();
  __c = _mm_unpackhi_pi16(__a, __b);
  __r = _mm_setzero_ps();
  __r = _mm_cvtpi32_ps(__r, __c);
  __r = _mm_movelh_ps(__r, __r);
  __c = _mm_unpacklo_pi16(__a, __b);
  __r = _mm_cvtpi32_ps(__r, __c);

  return __r;
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cvtpi8_ps(__m64 __a)
{
  __m64 __b;

  __b = _mm_setzero_si64();
  __b = _mm_cmpgt_pi8(__b, __a);
  __b = _mm_unpacklo_pi8(__a, __b);

  return _mm_cvtpi16_ps(__b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cvtpu8_ps(__m64 __a)
{
  __m64 __b;

  __b = _mm_setzero_si64();
  __b = _mm_unpacklo_pi8(__a, __b);

  return _mm_cvtpi16_ps(__b);
}

static __inline__ __m128 __DEFAULT_FN_ATTRS
_mm_cvtpi32x2_ps(__m64 __a, __m64 __b)
{
  __m128 __c;

  __c = _mm_setzero_ps();
  __c = _mm_cvtpi32_ps(__c, __b);
  __c = _mm_movelh_ps(__c, __c);

  return _mm_cvtpi32_ps(__c, __a);
}

static __inline__ __m64 __DEFAULT_FN_ATTRS
_mm_cvtps_pi16(__m128 __a)
{
  __m64 __b, __c;

  __b = _mm_cvtps_pi32(__a);
  __a = _mm_movehl_ps(__a, __a);
  __c = _mm_cvtps_pi32(__a);

  return _mm_packs_pi32(__b, __c);
}

static __inline__ __m64 __DEFAULT_FN_ATTRS
_mm_cvtps_pi8(__m128 __a)
{
  __m64 __b, __c;

  __b = _mm_cvtps_pi16(__a);
  __c = _mm_setzero_si64();

  return _mm_packs_pi16(__b, __c);
}

static __inline__ int __DEFAULT_FN_ATTRS
_mm_movemask_ps(__m128 __a)
{
  return __builtin_ia32_movmskps(__a);
}


#ifdef _MSC_VER
#define _MM_ALIGN16 __declspec(align(16))
#endif

#define _MM_SHUFFLE(z, y, x, w) (((z) << 6) | ((y) << 4) | ((x) << 2) | (w))

#define _MM_EXCEPT_INVALID    (0x0001)
#define _MM_EXCEPT_DENORM     (0x0002)
#define _MM_EXCEPT_DIV_ZERO   (0x0004)
#define _MM_EXCEPT_OVERFLOW   (0x0008)
#define _MM_EXCEPT_UNDERFLOW  (0x0010)
#define _MM_EXCEPT_INEXACT    (0x0020)
#define _MM_EXCEPT_MASK       (0x003f)

#define _MM_MASK_INVALID      (0x0080)
#define _MM_MASK_DENORM       (0x0100)
#define _MM_MASK_DIV_ZERO     (0x0200)
#define _MM_MASK_OVERFLOW     (0x0400)
#define _MM_MASK_UNDERFLOW    (0x0800)
#define _MM_MASK_INEXACT      (0x1000)
#define _MM_MASK_MASK         (0x1f80)

#define _MM_ROUND_NEAREST     (0x0000)
#define _MM_ROUND_DOWN        (0x2000)
#define _MM_ROUND_UP          (0x4000)
#define _MM_ROUND_TOWARD_ZERO (0x6000)
#define _MM_ROUND_MASK        (0x6000)

#define _MM_FLUSH_ZERO_MASK   (0x8000)
#define _MM_FLUSH_ZERO_ON     (0x8000)
#define _MM_FLUSH_ZERO_OFF    (0x0000)

#define _MM_GET_EXCEPTION_MASK() (_mm_getcsr() & _MM_MASK_MASK)
#define _MM_GET_EXCEPTION_STATE() (_mm_getcsr() & _MM_EXCEPT_MASK)
#define _MM_GET_FLUSH_ZERO_MODE() (_mm_getcsr() & _MM_FLUSH_ZERO_MASK)
#define _MM_GET_ROUNDING_MODE() (_mm_getcsr() & _MM_ROUND_MASK)

#define _MM_SET_EXCEPTION_MASK(x) (_mm_setcsr((_mm_getcsr() & ~_MM_MASK_MASK) | (x)))
#define _MM_SET_EXCEPTION_STATE(x) (_mm_setcsr((_mm_getcsr() & ~_MM_EXCEPT_MASK) | (x)))
#define _MM_SET_FLUSH_ZERO_MODE(x) (_mm_setcsr((_mm_getcsr() & ~_MM_FLUSH_ZERO_MASK) | (x)))
#define _MM_SET_ROUNDING_MODE(x) (_mm_setcsr((_mm_getcsr() & ~_MM_ROUND_MASK) | (x)))

#define _MM_TRANSPOSE4_PS(row0, row1, row2, row3) \
do { \
  __m128 tmp3, tmp2, tmp1, tmp0; \
  tmp0 = _mm_unpacklo_ps((row0), (row1)); \
  tmp2 = _mm_unpacklo_ps((row2), (row3)); \
  tmp1 = _mm_unpackhi_ps((row0), (row1)); \
  tmp3 = _mm_unpackhi_ps((row2), (row3)); \
  (row0) = _mm_movelh_ps(tmp0, tmp2); \
  (row1) = _mm_movehl_ps(tmp2, tmp0); \
  (row2) = _mm_movelh_ps(tmp1, tmp3); \
  (row3) = _mm_movehl_ps(tmp3, tmp1); \
} while (0)

/* Aliases for compatibility. */
#define _m_pextrw _mm_extract_pi16
#define _m_pinsrw _mm_insert_pi16
#define _m_pmaxsw _mm_max_pi16
#define _m_pmaxub _mm_max_pu8
#define _m_pminsw _mm_min_pi16
#define _m_pminub _mm_min_pu8
#define _m_pmovmskb _mm_movemask_pi8
#define _m_pmulhuw _mm_mulhi_pu16
#define _m_pshufw _mm_shuffle_pi16
#define _m_maskmovq _mm_maskmove_si64
#define _m_pavgb _mm_avg_pu8
#define _m_pavgw _mm_avg_pu16
#define _m_psadbw _mm_sad_pu8
#define _m_ _mm_
#define _m_ _mm_

#undef __DEFAULT_FN_ATTRS

/* Ugly hack for backwards-compatibility (compatible with gcc) */
#if defined(__SSE2__) && !__has_feature(modules)
#include <emmintrin.h>
#endif

#endif /* __XMMINTRIN_H */
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@a32 3
/* Unsigned types */
typedef unsigned int __v4su __attribute__((__vector_size__(16)));

a41 15
/// \brief Adds the 32-bit float values in the low-order bits of the operands.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VADDSS / ADDSS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing one of the source operands.
///    The lower 32 bits of this operand are used in the calculation.
/// \param __b
///    A 128-bit vector of [4 x float] containing one of the source operands.
///    The lower 32 bits of this operand are used in the calculation.
/// \returns A 128-bit vector of [4 x float] whose lower 32 bits contain the sum
///    of the lower 32 bits of both operands. The upper 96 bits are copied from
///    the upper 96 bits of the first source operand.
a48 13
/// \brief Adds two 128-bit vectors of [4 x float], and returns the results of
///    the addition.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VADDPS / ADDPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing one of the source operands.
/// \param __b
///    A 128-bit vector of [4 x float] containing one of the source operands.
/// \returns A 128-bit vector of [4 x float] containing the sums of both
///    operands.
d52 1
a52 1
  return (__m128)((__v4sf)__a + (__v4sf)__b);
a54 16
/// \brief Subtracts the 32-bit float value in the low-order bits of the second
///    operand from the corresponding value in the first operand.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VSUBSS / SUBSS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing the minuend. The lower 32 bits
///    of this operand are used in the calculation.
/// \param __b
///    A 128-bit vector of [4 x float] containing the subtrahend. The lower 32
///    bits of this operand are used in the calculation.
/// \returns A 128-bit vector of [4 x float] whose lower 32 bits contain the
///    difference of the lower 32 bits of both operands. The upper 96 bits are
///    copied from the upper 96 bits of the first source operand.
a61 14
/// \brief Subtracts each of the values of the second operand from the first
///    operand, both of which are 128-bit vectors of [4 x float] and returns
///    the results of the subtraction.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VSUBPS / SUBPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing the minuend.
/// \param __b
///    A 128-bit vector of [4 x float] containing the subtrahend.
/// \returns A 128-bit vector of [4 x float] containing the differences between
///    both operands.
d65 1
a65 1
  return (__m128)((__v4sf)__a - (__v4sf)__b);
a67 16
/// \brief Multiplies two 32-bit float values in the low-order bits of the
///    operands.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMULSS / MULSS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing one of the source operands.
///    The lower 32 bits of this operand are used in the calculation.
/// \param __b
///    A 128-bit vector of [4 x float] containing one of the source operands.
///    The lower 32 bits of this operand are used in the calculation.
/// \returns A 128-bit vector of [4 x float] containing the product of the lower
///    32 bits of both operands. The upper 96 bits are copied from the upper 96
///    bits of the first source operand.
a74 13
/// \brief Multiplies two 128-bit vectors of [4 x float] and returns the
///    results of the multiplication.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMULPS / MULPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing one of the source operands.
/// \param __b
///    A 128-bit vector of [4 x float] containing one of the source operands.
/// \returns A 128-bit vector of [4 x float] containing the products of both
///    operands.
d78 1
a78 1
  return (__m128)((__v4sf)__a * (__v4sf)__b);
a80 16
/// \brief Divides the value in the low-order 32 bits of the first operand by
///    the corresponding value in the second operand.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VDIVSS / DIVSS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing the dividend. The lower 32
///    bits of this operand are used in the calculation.
/// \param __b
///    A 128-bit vector of [4 x float] containing the divisor. The lower 32 bits
///    of this operand are used in the calculation.
/// \returns A 128-bit vector of [4 x float] containing the quotients of the
///    lower 32 bits of both operands. The upper 96 bits are copied from the
///    upper 96 bits of the first source operand.
a87 12
/// \brief Divides two 128-bit vectors of [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VDIVPS / DIVPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing the dividend.
/// \param __b
///    A 128-bit vector of [4 x float] containing the divisor.
/// \returns A 128-bit vector of [4 x float] containing the quotients of both
///    operands.
d91 1
a91 1
  return (__m128)((__v4sf)__a / (__v4sf)__b);
a93 12
/// \brief Calculates the square root of the value stored in the low-order bits
///    of a 128-bit vector of [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VSQRTSS / SQRTSS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the calculation.
/// \returns A 128-bit vector of [4 x float] containing the square root of the
///    value in the low-order bits of the operand.
d97 1
a97 1
  __m128 __c = __builtin_ia32_sqrtss((__v4sf)__a);
a100 11
/// \brief Calculates the square roots of the values stored in a 128-bit vector
///    of [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VSQRTPS / SQRTPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \returns A 128-bit vector of [4 x float] containing the square roots of the
///    values in the operand.
d104 1
a104 1
  return __builtin_ia32_sqrtps((__v4sf)__a);
a106 12
/// \brief Calculates the approximate reciprocal of the value stored in the
///    low-order bits of a 128-bit vector of [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VRCPSS / RCPSS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the calculation.
/// \returns A 128-bit vector of [4 x float] containing the approximate
///    reciprocal of the value in the low-order bits of the operand.
d110 1
a110 1
  __m128 __c = __builtin_ia32_rcpss((__v4sf)__a);
a113 11
/// \brief Calculates the approximate reciprocals of the values stored in a
///    128-bit vector of [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VRCPPS / RCPPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \returns A 128-bit vector of [4 x float] containing the approximate
///    reciprocals of the values in the operand.
d117 1
a117 1
  return __builtin_ia32_rcpps((__v4sf)__a);
a119 13
/// \brief Calculates the approximate reciprocal of the square root of the value
///    stored in the low-order bits of a 128-bit vector of [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VRSQRTSS / RSQRTSS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the calculation.
/// \returns A 128-bit vector of [4 x float] containing the approximate
///    reciprocal of the square root of the value in the low-order bits of the
///    operand.
d123 1
a123 1
  __m128 __c = __builtin_ia32_rsqrtss((__v4sf)__a);
a126 11
/// \brief Calculates the approximate reciprocals of the square roots of the
///    values stored in a 128-bit vector of [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VRSQRTPS / RSQRTPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \returns A 128-bit vector of [4 x float] containing the approximate
///    reciprocals of the square roots of the values in the operand.
d130 1
a130 1
  return __builtin_ia32_rsqrtps((__v4sf)__a);
a132 17
/// \brief Compares two 32-bit float values in the low-order bits of both
///    operands and returns the lesser value in the low-order bits of the
///    vector of [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMINSS / MINSS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \returns A 128-bit vector of [4 x float] whose lower 32 bits contain the
///    minimum value between both operands. The upper 96 bits are copied from
///    the upper 96 bits of the first source operand.
d136 1
a136 1
  return __builtin_ia32_minss((__v4sf)__a, (__v4sf)__b);
a138 13
/// \brief Compares two 128-bit vectors of [4 x float] and returns the
///    lesser of each pair of values.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMINPS / MINPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing one of the operands.
/// \param __b
///    A 128-bit vector of [4 x float] containing one of the operands.
/// \returns A 128-bit vector of [4 x float] containing the minimum values
///    between both operands.
d142 1
a142 1
  return __builtin_ia32_minps((__v4sf)__a, (__v4sf)__b);
a144 17
/// \brief Compares two 32-bit float values in the low-order bits of both
///    operands and returns the greater value in the low-order bits of
///    a vector [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMAXSS / MAXSS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \returns A 128-bit vector of [4 x float] whose lower 32 bits contain the
///    maximum value between both operands. The upper 96 bits are copied from
///    the upper 96 bits of the first source operand.
d148 1
a148 1
  return __builtin_ia32_maxss((__v4sf)__a, (__v4sf)__b);
a150 13
/// \brief Compares two 128-bit vectors of [4 x float] and returns the greater
///    of each pair of values.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMAXPS / MAXPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing one of the operands.
/// \param __b
///    A 128-bit vector of [4 x float] containing one of the operands.
/// \returns A 128-bit vector of [4 x float] containing the maximum values
///    between both operands.
d154 1
a154 1
  return __builtin_ia32_maxps((__v4sf)__a, (__v4sf)__b);
a156 12
/// \brief Performs a bitwise AND of two 128-bit vectors of [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VANDPS / ANDPS instructions.
///
/// \param __a
///    A 128-bit vector containing one of the source operands.
/// \param __b
///    A 128-bit vector containing one of the source operands.
/// \returns A 128-bit vector of [4 x float] containing the bitwise AND of the
///    values between both operands.
d160 1
a160 1
  return (__m128)((__v4su)__a & (__v4su)__b);
a162 16
/// \brief Performs a bitwise AND of two 128-bit vectors of [4 x float], using
///    the one's complement of the values contained in the first source
///    operand.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VANDNPS / ANDNPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing the first source operand. The
///    one's complement of this value is used in the bitwise AND.
/// \param __b
///    A 128-bit vector of [4 x float] containing the second source operand.
/// \returns A 128-bit vector of [4 x float] containing the bitwise AND of the
///    one's complement of the first operand and the values in the second
///    operand.
d166 1
a166 1
  return (__m128)(~(__v4su)__a & (__v4su)__b);
a168 12
/// \brief Performs a bitwise OR of two 128-bit vectors of [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VORPS / ORPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing one of the source operands.
/// \param __b
///    A 128-bit vector of [4 x float] containing one of the source operands.
/// \returns A 128-bit vector of [4 x float] containing the bitwise OR of the
///    values between both operands.
d172 1
a172 1
  return (__m128)((__v4su)__a | (__v4su)__b);
a174 13
/// \brief Performs a bitwise exclusive OR of two 128-bit vectors of
///    [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VXORPS / XORPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing one of the source operands.
/// \param __b
///    A 128-bit vector of [4 x float] containing one of the source operands.
/// \returns A 128-bit vector of [4 x float] containing the bitwise exclusive OR
///    of the values between both operands.
d178 1
a178 1
  return (__m128)((__v4su)__a ^ (__v4su)__b);
a180 16
/// \brief Compares two 32-bit float values in the low-order bits of both
///    operands for equality and returns the result of the comparison in the
///    low-order bits of a vector [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPEQSS / CMPEQSS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \returns A 128-bit vector of [4 x float] containing the comparison results
///    in the low-order bits.
d184 1
a184 1
  return (__m128)__builtin_ia32_cmpeqss((__v4sf)__a, (__v4sf)__b);
a186 12
/// \brief Compares each of the corresponding 32-bit float values of the
///    128-bit vectors of [4 x float] for equality.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPEQPS / CMPEQPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \param __b
///    A 128-bit vector of [4 x float].
/// \returns A 128-bit vector of [4 x float] containing the comparison results.
d190 1
a190 1
  return (__m128)__builtin_ia32_cmpeqps((__v4sf)__a, (__v4sf)__b);
a192 17
/// \brief Compares two 32-bit float values in the low-order bits of both
///    operands to determine if the value in the first operand is less than the
///    corresponding value in the second operand and returns the result of the
///    comparison in the low-order bits of a vector of [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPLTSS / CMPLTSS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \returns A 128-bit vector of [4 x float] containing the comparison results
///    in the low-order bits.
d196 1
a196 1
  return (__m128)__builtin_ia32_cmpltss((__v4sf)__a, (__v4sf)__b);
a198 13
/// \brief Compares each of the corresponding 32-bit float values of the
///    128-bit vectors of [4 x float] to determine if the values in the first
///    operand are less than those in the second operand.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPLTPS / CMPLTPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \param __b
///    A 128-bit vector of [4 x float].
/// \returns A 128-bit vector of [4 x float] containing the comparison results.
d202 1
a202 1
  return (__m128)__builtin_ia32_cmpltps((__v4sf)__a, (__v4sf)__b);
a204 18
/// \brief Compares two 32-bit float values in the low-order bits of both
///    operands to determine if the value in the first operand is less than or
///    equal to the corresponding value in the second operand and returns the
///    result of the comparison in the low-order bits of a vector of
///    [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPLESS / CMPLESS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \returns A 128-bit vector of [4 x float] containing the comparison results
///    in the low-order bits.
d208 1
a208 1
  return (__m128)__builtin_ia32_cmpless((__v4sf)__a, (__v4sf)__b);
a210 13
/// \brief Compares each of the corresponding 32-bit float values of the
///    128-bit vectors of [4 x float] to determine if the values in the first
///    operand are less than or equal to those in the second operand.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPLEPS / CMPLEPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \param __b
///    A 128-bit vector of [4 x float].
/// \returns A 128-bit vector of [4 x float] containing the comparison results.
d214 1
a214 1
  return (__m128)__builtin_ia32_cmpleps((__v4sf)__a, (__v4sf)__b);
a216 17
/// \brief Compares two 32-bit float values in the low-order bits of both
///    operands to determine if the value in the first operand is greater than
///    the corresponding value in the second operand and returns the result of
///    the comparison in the low-order bits of a vector of [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPLTSS / CMPLTSS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \returns A 128-bit vector of [4 x float] containing the comparison results
///    in the low-order bits.
d220 2
a221 2
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpltss((__v4sf)__b, (__v4sf)__a),
a224 13
/// \brief Compares each of the corresponding 32-bit float values of the
///    128-bit vectors of [4 x float] to determine if the values in the first
///    operand are greater than those in the second operand.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPLTPS / CMPLTPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \param __b
///    A 128-bit vector of [4 x float].
/// \returns A 128-bit vector of [4 x float] containing the comparison results.
d228 1
a228 1
  return (__m128)__builtin_ia32_cmpltps((__v4sf)__b, (__v4sf)__a);
a230 18
/// \brief Compares two 32-bit float values in the low-order bits of both
///    operands to determine if the value in the first operand is greater than
///    or equal to the corresponding value in the second operand and returns
///    the result of the comparison in the low-order bits of a vector of
///    [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPLESS / CMPLESS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \returns A 128-bit vector of [4 x float] containing the comparison results
///    in the low-order bits.
d234 2
a235 2
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpless((__v4sf)__b, (__v4sf)__a),
a238 13
/// \brief Compares each of the corresponding 32-bit float values of the
///    128-bit vectors of [4 x float] to determine if the values in the first
///    operand are greater than or equal to those in the second operand.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPLEPS / CMPLEPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \param __b
///    A 128-bit vector of [4 x float].
/// \returns A 128-bit vector of [4 x float] containing the comparison results.
d242 1
a242 1
  return (__m128)__builtin_ia32_cmpleps((__v4sf)__b, (__v4sf)__a);
a244 16
/// \brief Compares two 32-bit float values in the low-order bits of both
///    operands for inequality and returns the result of the comparison in the
///    low-order bits of a vector of [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPNEQSS / CMPNEQSS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \returns A 128-bit vector of [4 x float] containing the comparison results
///    in the low-order bits.
d248 1
a248 1
  return (__m128)__builtin_ia32_cmpneqss((__v4sf)__a, (__v4sf)__b);
a250 12
/// \brief Compares each of the corresponding 32-bit float values of the
///    128-bit vectors of [4 x float] for inequality.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPNEQPS / CMPNEQPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \param __b
///    A 128-bit vector of [4 x float].
/// \returns A 128-bit vector of [4 x float] containing the comparison results.
d254 1
a254 1
  return (__m128)__builtin_ia32_cmpneqps((__v4sf)__a, (__v4sf)__b);
a256 17
/// \brief Compares two 32-bit float values in the low-order bits of both
///    operands to determine if the value in the first operand is not less than
///    the corresponding value in the second operand and returns the result of
///    the comparison in the low-order bits of a vector of [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPNLTSS / CMPNLTSS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \returns A 128-bit vector of [4 x float] containing the comparison results
///    in the low-order bits.
d260 1
a260 1
  return (__m128)__builtin_ia32_cmpnltss((__v4sf)__a, (__v4sf)__b);
a262 13
/// \brief Compares each of the corresponding 32-bit float values of the
///    128-bit vectors of [4 x float] to determine if the values in the first
///    operand are not less than those in the second operand.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPNLTPS / CMPNLTPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \param __b
///    A 128-bit vector of [4 x float].
/// \returns A 128-bit vector of [4 x float] containing the comparison results.
d266 1
a266 1
  return (__m128)__builtin_ia32_cmpnltps((__v4sf)__a, (__v4sf)__b);
a268 18
/// \brief Compares two 32-bit float values in the low-order bits of both
///    operands to determine if the value in the first operand is not less than
///    or equal to the corresponding value in the second operand and returns
///    the result of the comparison in the low-order bits of a vector of
///    [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPNLESS / CMPNLESS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \returns A 128-bit vector of [4 x float] containing the comparison results
///    in the low-order bits.
d272 1
a272 1
  return (__m128)__builtin_ia32_cmpnless((__v4sf)__a, (__v4sf)__b);
a274 13
/// \brief Compares each of the corresponding 32-bit float values of the
///    128-bit vectors of [4 x float] to determine if the values in the first
///    operand are not less than or equal to those in the second operand.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPNLEPS / CMPNLEPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \param __b
///    A 128-bit vector of [4 x float].
/// \returns A 128-bit vector of [4 x float] containing the comparison results.
d278 1
a278 1
  return (__m128)__builtin_ia32_cmpnleps((__v4sf)__a, (__v4sf)__b);
a280 18
/// \brief Compares two 32-bit float values in the low-order bits of both
///    operands to determine if the value in the first operand is not greater
///    than the corresponding value in the second operand and returns the
///    result of the comparison in the low-order bits of a vector of
///    [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPNLTSS / CMPNLTSS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \returns A 128-bit vector of [4 x float] containing the comparison results
///    in the low-order bits.
d284 2
a285 2
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpnltss((__v4sf)__b, (__v4sf)__a),
a288 13
/// \brief Compares each of the corresponding 32-bit float values of the
///    128-bit vectors of [4 x float] to determine if the values in the first
///    operand are not greater than those in the second operand.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPNLTPS / CMPNLTPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \param __b
///    A 128-bit vector of [4 x float].
/// \returns A 128-bit vector of [4 x float] containing the comparison results.
d292 1
a292 1
  return (__m128)__builtin_ia32_cmpnltps((__v4sf)__b, (__v4sf)__a);
a294 18
/// \brief Compares two 32-bit float values in the low-order bits of both
///    operands to determine if the value in the first operand is not greater
///    than or equal to the corresponding value in the second operand and
///    returns the result of the comparison in the low-order bits of a vector
///    of [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPNLESS / CMPNLESS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \returns A 128-bit vector of [4 x float] containing the comparison results
///    in the low-order bits.
d298 2
a299 2
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpnless((__v4sf)__b, (__v4sf)__a),
a302 13
/// \brief Compares each of the corresponding 32-bit float values of the
///    128-bit vectors of [4 x float] to determine if the values in the first
///    operand are not greater than or equal to those in the second operand.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPNLEPS / CMPNLEPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \param __b
///    A 128-bit vector of [4 x float].
/// \returns A 128-bit vector of [4 x float] containing the comparison results.
d306 1
a306 1
  return (__m128)__builtin_ia32_cmpnleps((__v4sf)__b, (__v4sf)__a);
a308 18
/// \brief Compares two 32-bit float values in the low-order bits of both
///    operands to determine if the value in the first operand is ordered with
///    respect to the corresponding value in the second operand and returns the
///    result of the comparison in the low-order bits of a vector of
///    [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPORDSS / CMPORDSS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \returns A 128-bit vector of [4 x float] containing the comparison results
///    in the low-order bits.
d312 1
a312 1
  return (__m128)__builtin_ia32_cmpordss((__v4sf)__a, (__v4sf)__b);
a314 13
/// \brief Compares each of the corresponding 32-bit float values of the
///    128-bit vectors of [4 x float] to determine if the values in the first
///    operand are ordered with respect to those in the second operand.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPORDPS / CMPORDPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \param __b
///    A 128-bit vector of [4 x float].
/// \returns A 128-bit vector of [4 x float] containing the comparison results.
d318 1
a318 1
  return (__m128)__builtin_ia32_cmpordps((__v4sf)__a, (__v4sf)__b);
a320 18
/// \brief Compares two 32-bit float values in the low-order bits of both
///    operands to determine if the value in the first operand is unordered
///    with respect to the corresponding value in the second operand and
///    returns the result of the comparison in the low-order bits of a vector
///    of [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPUNORDSS / CMPUNORDSS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float] containing one of the operands. The lower
///    32 bits of this operand are used in the comparison.
/// \returns A 128-bit vector of [4 x float] containing the comparison results
///    in the low-order bits.
d324 1
a324 1
  return (__m128)__builtin_ia32_cmpunordss((__v4sf)__a, (__v4sf)__b);
a326 13
/// \brief Compares each of the corresponding 32-bit float values of the
///    128-bit vectors of [4 x float] to determine if the values in the first
///    operand are unordered with respect to those in the second operand.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCMPUNORDPS / CMPUNORDPS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \param __b
///    A 128-bit vector of [4 x float].
/// \returns A 128-bit vector of [4 x float] containing the comparison results.
d330 1
a330 1
  return (__m128)__builtin_ia32_cmpunordps((__v4sf)__a, (__v4sf)__b);
a332 14
/// \brief Compares two 32-bit float values in the low-order bits of both
///    operands for equality and returns the result of the comparison.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCOMISS / COMISS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \returns An integer containing the comparison results.
d336 1
a336 1
  return __builtin_ia32_comieq((__v4sf)__a, (__v4sf)__b);
a338 15
/// \brief Compares two 32-bit float values in the low-order bits of both
///    operands to determine if the first operand is less than the second
///    operand and returns the result of the comparison.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCOMISS / COMISS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \returns An integer containing the comparison results.
d342 1
a342 1
  return __builtin_ia32_comilt((__v4sf)__a, (__v4sf)__b);
a344 15
/// \brief Compares two 32-bit float values in the low-order bits of both
///    operands to determine if the first operand is less than or equal to the
///    second operand and returns the result of the comparison.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCOMISS / COMISS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \returns An integer containing the comparison results.
d348 1
a348 1
  return __builtin_ia32_comile((__v4sf)__a, (__v4sf)__b);
a350 15
/// \brief Compares two 32-bit float values in the low-order bits of both
///    operands to determine if the first operand is greater than the second
///    operand and returns the result of the comparison.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCOMISS / COMISS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \returns An integer containing the comparison results.
d354 1
a354 1
  return __builtin_ia32_comigt((__v4sf)__a, (__v4sf)__b);
a356 15
/// \brief Compares two 32-bit float values in the low-order bits of both
///    operands to determine if the first operand is greater than or equal to
///    the second operand and returns the result of the comparison.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCOMISS / COMISS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \returns An integer containing the comparison results.
d360 1
a360 1
  return __builtin_ia32_comige((__v4sf)__a, (__v4sf)__b);
a362 15
/// \brief Compares two 32-bit float values in the low-order bits of both
///    operands to determine if the first operand is not equal to the second
///    operand and returns the result of the comparison.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCOMISS / COMISS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \returns An integer containing the comparison results.
d366 1
a366 1
  return __builtin_ia32_comineq((__v4sf)__a, (__v4sf)__b);
a368 15
/// \brief Performs an unordered comparison of two 32-bit float values using
///    the low-order bits of both operands to determine equality and returns
///    the result of the comparison.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VUCOMISS / UCOMISS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \returns An integer containing the comparison results.
d372 1
a372 1
  return __builtin_ia32_ucomieq((__v4sf)__a, (__v4sf)__b);
a374 15
/// \brief Performs an unordered comparison of two 32-bit float values using
///    the low-order bits of both operands to determine if the first operand is
///    less than the second operand and returns the result of the comparison.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VUCOMISS / UCOMISS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \returns An integer containing the comparison results.
d378 1
a378 1
  return __builtin_ia32_ucomilt((__v4sf)__a, (__v4sf)__b);
a380 16
/// \brief Performs an unordered comparison of two 32-bit float values using
///    the low-order bits of both operands to determine if the first operand
///    is less than or equal to the second operand and returns the result of
///    the comparison.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VUCOMISS / UCOMISS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \returns An integer containing the comparison results.
d384 1
a384 1
  return __builtin_ia32_ucomile((__v4sf)__a, (__v4sf)__b);
a386 16
/// \brief Performs an unordered comparison of two 32-bit float values using
///    the low-order bits of both operands to determine if the first operand
///    is greater than the second operand and returns the result of the
///    comparison.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VUCOMISS / UCOMISS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \returns An integer containing the comparison results.
d390 1
a390 1
  return __builtin_ia32_ucomigt((__v4sf)__a, (__v4sf)__b);
a392 16
/// \brief Performs an unordered comparison of two 32-bit float values using
///    the low-order bits of both operands to determine if the first operand is
///    greater than or equal to the second operand and returns the result of
///    the comparison.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VUCOMISS / UCOMISS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \returns An integer containing the comparison results.
d396 1
a396 1
  return __builtin_ia32_ucomige((__v4sf)__a, (__v4sf)__b);
a398 15
/// \brief Performs an unordered comparison of two 32-bit float values using
///    the low-order bits of both operands to determine inequality and returns
///    the result of the comparison.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VUCOMISS / UCOMISS instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \param __b
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the comparison.
/// \returns An integer containing the comparison results.
d402 1
a402 1
  return __builtin_ia32_ucomineq((__v4sf)__a, (__v4sf)__b);
a404 11
/// \brief Converts a float value contained in the lower 32 bits of a vector of
///    [4 x float] into a 32-bit integer.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCVTSS2SI / CVTSS2SI instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the conversion.
/// \returns A 32-bit integer containing the converted value.
d408 1
a408 1
  return __builtin_ia32_cvtss2si((__v4sf)__a);
a410 11
/// \brief Converts a float value contained in the lower 32 bits of a vector of
///    [4 x float] into a 32-bit integer.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCVTSS2SI / CVTSS2SI instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the conversion.
/// \returns A 32-bit integer containing the converted value.
a418 11
/// \brief Converts a float value contained in the lower 32 bits of a vector of
///    [4 x float] into a 64-bit integer.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCVTSS2SI / CVTSS2SI instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the conversion.
/// \returns A 64-bit integer containing the converted value.
d422 1
a422 1
  return __builtin_ia32_cvtss2si64((__v4sf)__a);
a426 10
/// \brief Converts two low-order float values in a 128-bit vector of
///    [4 x float] into a 64-bit vector of [2 x i32].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c CVTPS2PI instruction.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \returns A 64-bit integer vector containing the converted values.
d430 1
a430 1
  return (__m64)__builtin_ia32_cvtps2pi((__v4sf)__a);
a432 10
/// \brief Converts two low-order float values in a 128-bit vector of
///    [4 x float] into a 64-bit vector of [2 x i32].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c CVTPS2PI instruction.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \returns A 64-bit integer vector containing the converted values.
a438 12
/// \brief Converts a float value contained in the lower 32 bits of a vector of
///    [4 x float] into a 32-bit integer, truncating the result when it is
///    inexact.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCVTTSS2SI / CVTTSS2SI instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the conversion.
/// \returns A 32-bit integer containing the converted value.
d442 1
a442 1
  return __builtin_ia32_cvttss2si((__v4sf)__a);
a444 12
/// \brief Converts a float value contained in the lower 32 bits of a vector of
///    [4 x float] into a 32-bit integer, truncating the result when it is
///    inexact.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCVTTSS2SI / CVTTSS2SI instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the conversion.
/// \returns A 32-bit integer containing the converted value.
a450 12
/// \brief Converts a float value contained in the lower 32 bits of a vector of
///    [4 x float] into a 64-bit integer, truncating the result when it is
///    inexact.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCVTTSS2SI / CVTTSS2SI instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the conversion.
/// \returns A 64-bit integer containing the converted value.
d454 1
a454 1
  return __builtin_ia32_cvttss2si64((__v4sf)__a);
a456 11
/// \brief Converts two low-order float values in a 128-bit vector of
///    [4 x float] into a 64-bit vector of [2 x i32], truncating the result
///    when it is inexact.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c CVTTPS2PI / VTTPS2PI instructions.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \returns A 64-bit integer vector containing the converted values.
d460 1
a460 1
  return (__m64)__builtin_ia32_cvttps2pi((__v4sf)__a);
a462 11
/// \brief Converts two low-order float values in a 128-bit vector of [4 x
///    float] into a 64-bit vector of [2 x i32], truncating the result when it
///    is inexact.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c CVTTPS2PI instruction.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \returns A 64-bit integer vector containing the converted values.
a468 16
/// \brief Converts a 32-bit signed integer value into a floating point value
///    and writes it to the lower 32 bits of the destination. The remaining
///    higher order elements of the destination vector are copied from the
///    corresponding elements in the first operand.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCVTSI2SS / CVTSI2SS instruction.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \param __b
///    A 32-bit signed integer operand containing the value to be converted.
/// \returns A 128-bit vector of [4 x float] whose lower 32 bits contain the
///    converted value of the second operand. The upper 96 bits are copied from
///    the upper 96 bits of the first operand.
a475 16
/// \brief Converts a 32-bit signed integer value into a floating point value
///    and writes it to the lower 32 bits of the destination. The remaining
///    higher order elements of the destination are copied from the
///    corresponding elements in the first operand.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCVTSI2SS / CVTSI2SS instruction.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \param __b
///    A 32-bit signed integer operand containing the value to be converted.
/// \returns A 128-bit vector of [4 x float] whose lower 32 bits contain the
///    converted value of the second operand. The upper 96 bits are copied from
///    the upper 96 bits of the first operand.
a483 16
/// \brief Converts a 64-bit signed integer value into a floating point value
///    and writes it to the lower 32 bits of the destination. The remaining
///    higher order elements of the destination are copied from the
///    corresponding elements in the first operand.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VCVTSI2SS / CVTSI2SS instruction.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \param __b
///    A 64-bit signed integer operand containing the value to be converted.
/// \returns A 128-bit vector of [4 x float] whose lower 32 bits contain the
///    converted value of the second operand. The upper 96 bits are copied from
///    the upper 96 bits of the first operand.
a492 17
/// \brief Converts two elements of a 64-bit vector of [2 x i32] into two
///    floating point values and writes them to the lower 64-bits of the
///    destination. The remaining higher order elements of the destination are
///    copied from the corresponding elements in the first operand.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c CVTPI2PS instruction.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \param __b
///    A 64-bit vector of [2 x i32]. The elements in this vector are converted
///    and written to the corresponding low-order elements in the destination.
/// \returns A 128-bit vector of [4 x float] whose lower 64 bits contain the
///    converted value of the second operand. The upper 64 bits are copied from
///    the upper 64 bits of the first operand.
d496 1
a496 1
  return __builtin_ia32_cvtpi2ps((__v4sf)__a, (__v2si)__b);
a498 17
/// \brief Converts two elements of a 64-bit vector of [2 x i32] into two
///    floating point values and writes them to the lower 64-bits of the
///    destination. The remaining higher order elements of the destination are
///    copied from the corresponding elements in the first operand.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c CVTPI2PS instruction.
///
/// \param __a
///    A 128-bit vector of [4 x float].
/// \param __b
///    A 64-bit vector of [2 x i32]. The elements in this vector are converted
///    and written to the corresponding low-order elements in the destination.
/// \returns A 128-bit vector of [4 x float] whose lower 64 bits contain the
///    converted value from the second operand. The upper 64 bits are copied
///    from the upper 64 bits of the first operand.
a504 11
/// \brief Extracts a float value contained in the lower 32 bits of a vector of
///    [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMOVSS / MOVSS instruction.
///
/// \param __a
///    A 128-bit vector of [4 x float]. The lower 32 bits of this operand are
///    used in the extraction.
/// \returns A 32-bit float containing the extracted value.
a510 15
/// \brief Loads two packed float values from the address __p into the
///     high-order bits of a 128-bit vector of [4 x float]. The low-order bits
///     are copied from the low-order bits of the first operand.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMOVHPD / MOVHPD instruction.
///
/// \param __a
///    A 128-bit vector of [4 x float]. Bits [63:0] are written to bits [63:0]
///    of the destination.
/// \param __p
///    A pointer to two packed float values. Bits [63:0] are written to bits
///    [127:64] of the destination.
/// \returns A 128-bit vector of [4 x float] containing the moved values.
a522 15
/// \brief Loads two packed float values from the address __p into the low-order
///    bits of a 128-bit vector of [4 x float]. The high-order bits are copied
///    from the high-order bits of the first operand.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMOVLPD / MOVLPD instruction.
///
/// \param __a
///    A 128-bit vector of [4 x float]. Bits [127:64] are written to bits
///    [127:64] of the destination.
/// \param __p
///    A pointer to two packed float values. Bits [63:0] are written to bits
///    [63:0] of the destination.
/// \returns A 128-bit vector of [4 x float] containing the moved values.
a534 15
/// \brief Constructs a 128-bit floating-point vector of [4 x float]. The lower
///    32 bits of the vector are initialized with the single-precision
///    floating-point value loaded from a specified memory location. The upper
///    96 bits are set to zero.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMOVSS / MOVSS instruction.
///
/// \param __p
///    A pointer to a 32-bit memory location containing a single-precision
///    floating-point value.
/// \returns An initialized 128-bit floating-point vector of [4 x float]. The
///    lower 32 bits contain the value loaded from the memory location. The
///    upper 96 bits are set to zero.
a544 12
/// \brief Loads a 32-bit float value and duplicates it to all four vector
///    elements of a 128-bit vector of [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMOVSS / MOVSS + \c shuffling
///    instruction.
///
/// \param __p
///    A pointer to a float value to be loaded and duplicated.
/// \returns A 128-bit vector of [4 x float] containing the loaded
///    and duplicated values.
a556 11
/// \brief Loads a 128-bit floating-point vector of [4 x float] from an aligned
///    memory location.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMOVAPS / MOVAPS instruction.
///
/// \param __p
///    A pointer to a 128-bit memory location. The address of the memory
///    location has to be 128-bit aligned.
/// \returns A 128-bit vector of [4 x float] containing the loaded valus.
a562 11
/// \brief Loads a 128-bit floating-point vector of [4 x float] from an
///    unaligned memory location.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMOVUPS / MOVUPS instruction.
///
/// \param __p
///    A pointer to a 128-bit memory location. The address of the memory
///    location does not have to be aligned.
/// \returns A 128-bit vector of [4 x float] containing the loaded values.
a571 13
/// \brief Loads four packed float values, in reverse order, from an aligned
///    memory location to 32-bit elements in a 128-bit vector of [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMOVAPS / MOVAPS + \c shuffling
///    instruction.
///
/// \param __p
///    A pointer to a 128-bit memory location. The address of the memory
///    location has to be 128-bit aligned.
/// \returns A 128-bit vector of [4 x float] containing the moved values, loaded
///    in reverse order.
d576 1
a576 1
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 3, 2, 1, 0);
a578 8
/// \brief Create a 128-bit vector of [4 x float] with undefined values.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic has no corresponding instruction.
///
/// \returns A 128-bit vector of [4 x float] containing undefined values.

d580 1
a580 1
_mm_undefined_ps(void)
a584 14
/// \brief Constructs a 128-bit floating-point vector of [4 x float]. The lower
///    32 bits of the vector are initialized with the specified single-precision
///    floating-point value. The upper 96 bits are set to zero.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMOVSS / MOVSS instruction.
///
/// \param __w
///    A single-precision floating-point value used to initialize the lower 32
///    bits of the result.
/// \returns An initialized 128-bit floating-point vector of [4 x float]. The
///    lower 32 bits contain the value provided in the source operand. The
///    upper 96 bits are set to zero.
a590 12
/// \brief Constructs a 128-bit floating-point vector of [4 x float], with each
///    of the four single-precision floating-point vector elements set to the
///    specified single-precision floating-point value.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VPERMILPS / PERMILPS instruction.
///
/// \param __w
///    A single-precision floating-point value used to initialize each vector
///    element of the result.
/// \returns An initialized 128-bit floating-point vector of [4 x float].
a597 12
/// \brief Constructs a 128-bit floating-point vector of [4 x float], with each
///    of the four single-precision floating-point vector elements set to the
///    specified single-precision floating-point value.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VPERMILPS / PERMILPS instruction.
///
/// \param __w
///    A single-precision floating-point value used to initialize each vector
///    element of the result.
/// \returns An initialized 128-bit floating-point vector of [4 x float].
a603 21
/// \brief Constructs a 128-bit floating-point vector of [4 x float]
///    initialized with the specified single-precision floating-point values.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic is a utility function and does not correspond to a specific
///    instruction.
///
/// \param __z
///    A single-precision floating-point value used to initialize bits [127:96]
///    of the result.
/// \param __y
///    A single-precision floating-point value used to initialize bits [95:64]
///    of the result.
/// \param __x
///    A single-precision floating-point value used to initialize bits [63:32]
///    of the result.
/// \param __w
///    A single-precision floating-point value used to initialize bits [31:0]
///    of the result.
/// \returns An initialized 128-bit floating-point vector of [4 x float].
a609 22
/// \brief Constructs a 128-bit floating-point vector of [4 x float],
///    initialized in reverse order with the specified 32-bit single-precision
///    float-point values.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic is a utility function and does not correspond to a specific
///    instruction.
///
/// \param __z
///    A single-precision floating-point value used to initialize bits [31:0]
///    of the result.
/// \param __y
///    A single-precision floating-point value used to initialize bits [63:32]
///    of the result.
/// \param __x
///    A single-precision floating-point value used to initialize bits [95:64]
///    of the result.
/// \param __w
///    A single-precision floating-point value used to initialize bits [127:96]
///    of the result.
/// \returns An initialized 128-bit floating-point vector of [4 x float].
a615 9
/// \brief Constructs a 128-bit floating-point vector of [4 x float] initialized
///    to zero.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VXORPS / XORPS instruction.
///
/// \returns An initialized 128-bit floating-point vector of [4 x float] with
///    all elements set to zero.
a621 11
/// \brief Stores the upper 64 bits of a 128-bit vector of [4 x float] to a
///    memory location.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VPEXTRQ / MOVQ instruction.
///
/// \param __p
///    A pointer to a 64-bit memory location.
/// \param __a
///    A 128-bit vector of [4 x float] containing the values to be stored.
d625 1
a625 1
  __builtin_ia32_storehps((__v2si *)__p, (__v4sf)__a);
a627 11
/// \brief Stores the lower 64 bits of a 128-bit vector of [4 x float] to a
///     memory location.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMOVLPS / MOVLPS instruction.
///
/// \param __p
///    A pointer to a memory location that will receive the float values.
/// \param __a
///    A 128-bit vector of [4 x float] containing the values to be stored.
d631 1
a631 1
  __builtin_ia32_storelps((__v2si *)__p, (__v4sf)__a);
a633 11
/// \brief Stores the lower 32 bits of a 128-bit vector of [4 x float] to a
///     memory location.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMOVSS / MOVSS instruction.
///
/// \param __p
///    A pointer to a 32-bit memory location.
/// \param __a
///    A 128-bit vector of [4 x float] containing the value to be stored.
a642 12
/// \brief Stores float values from a 128-bit vector of [4 x float] to an
///    unaligned memory location.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMOVUPS / MOVUPS instruction.
///
/// \param __p
///    A pointer to a 128-bit memory location. The address of the memory
///    location does not have to be aligned.
/// \param __a
///    A 128-bit vector of [4 x float] containing the values to be stored.
d646 1
a646 4
  struct __storeu_ps {
    __m128 __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_ps*)__p)->__v = __a;
a648 13
/// \brief Stores the lower 32 bits of a 128-bit vector of [4 x float] into
///    four contiguous elements in an aligned memory location.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to \c VMOVAPS / MOVAPS + \c shuffling
///    instruction.
///
/// \param __p
///    A pointer to a 128-bit memory location.
/// \param __a
///    A 128-bit vector of [4 x float] whose lower 32 bits are stored to each
///    of the four contiguous elements pointed by __p.
d650 1
a650 1
_mm_store_ps(float *__p, __m128 __a)
d652 2
a653 1
  *(__m128*)__p = __a;
a655 13
/// \brief Stores the lower 32 bits of a 128-bit vector of [4 x float] into
///    four contiguous elements in an aligned memory location.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to \c VMOVAPS / MOVAPS + \c shuffling
///    instruction.
///
/// \param __p
///    A pointer to a 128-bit memory location.
/// \param __a
///    A 128-bit vector of [4 x float] whose lower 32 bits are stored to each
///    of the four contiguous elements pointed by __p.
d657 1
a657 1
_mm_store1_ps(float *__p, __m128 __a)
d659 1
a659 2
  __a = __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 0, 0, 0, 0);
  _mm_store_ps(__p, __a);
a661 12
/// \brief Stores float values from a 128-bit vector of [4 x float] to an
///    aligned memory location.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMOVAPS / MOVAPS instruction.
///
/// \param __p
///    A pointer to a 128-bit memory location. The address of the memory
///    location has to be 128-bit aligned.
/// \param __a
///    A 128-bit vector of [4 x float] containing the values to be stored.
d663 1
a663 1
_mm_store_ps1(float *__p, __m128 __a)
d665 1
a665 1
  return _mm_store1_ps(__p, __a);
a667 13
/// \brief Stores float values from a 128-bit vector of [4 x float] to an
///    aligned memory location in reverse order.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMOVAPS / MOVAPS + \c shuffling
///    instruction.
///
/// \param __p
///    A pointer to a 128-bit memory location. The address of the memory
///    location has to be 128-bit aligned.
/// \param __a
///    A 128-bit vector of [4 x float] containing the values to be stored.
d671 1
a671 1
  __a = __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 3, 2, 1, 0);
a683 23
/// \brief Loads one cache line of data from the specified address to a location
///    closer to the processor.
///
/// \headerfile <x86intrin.h>
///
/// \code
/// void _mm_prefetch(const void * a, const int sel);
/// \endcode
///
/// This intrinsic corresponds to the \c PREFETCHNTA instruction.
///
/// \param a
///    A pointer to a memory location containing a cache line of data.
/// \param sel
///    A predefined integer constant specifying the type of prefetch operation:
///    _MM_HINT_NTA: Move data using the non-temporal access (NTA) hint.
///    The PREFETCHNTA instruction will be generated.
///    _MM_HINT_T0: Move data using the T0 hint. The PREFETCHT0 instruction will
///    be generated.
///    _MM_HINT_T1: Move data using the T1 hint. The PREFETCHT1 instruction will
///    be generated.
///    _MM_HINT_T2: Move data using the T2 hint. The PREFETCHT2 instruction will
///    be generated.
a686 12
/// \brief Stores a 64-bit integer in the specified aligned memory location. To
///    minimize caching, the data is flagged as non-temporal (unlikely to be
///    used again soon).
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c MOVNTQ instruction.
///
/// \param __p
///    A pointer to an aligned memory location used to store the register value.
/// \param __a
///    A 64-bit integer containing the value to be stored.
a692 13
/// \brief Moves packed float values from a 128-bit vector of [4 x float] to a
///    128-bit aligned memory location. To minimize caching, the data is flagged
///    as non-temporal (unlikely to be used again soon).
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMOVNTPS / MOVNTPS instruction.
///
/// \param __p
///    A pointer to a 128-bit aligned memory location that will receive the
///    integer values.
/// \param __a
///    A 128-bit vector of [4 x float] containing the values to be moved.
d696 1
a696 1
  __builtin_nontemporal_store((__v4sf)__a, (__v4sf*)__p);
a698 9
/// \brief Forces strong memory ordering (serialization) between store
///    instructions preceding this instruction and store instructions following
///    this instruction, ensuring the system completes all previous stores
///    before executing subsequent stores.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c SFENCE instruction.
///
d705 15
a719 59
/// \brief Extracts 16-bit element from a 64-bit vector of [4 x i16] and
///    returns it, as specified by the immediate integer operand.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VPEXTRW / PEXTRW instruction.
///
/// \param __a
///    A 64-bit vector of [4 x i16].
/// \param __n
///    An immediate integer operand that determines which bits are extracted:
///    0: Bits [15:0] are copied to the destination.
///    1: Bits [31:16] are copied to the destination.
///    2: Bits [47:32] are copied to the destination.
///    3: Bits [63:48] are copied to the destination.
/// \returns A 16-bit integer containing the extracted 16 bits of packed data.
#define _mm_extract_pi16(a, n) __extension__ ({ \
  (int)__builtin_ia32_vec_ext_v4hi((__m64)a, (int)n); })

/// \brief Copies data from the 64-bit vector of [4 x i16] to the destination,
///    and inserts the lower 16-bits of an integer operand at the 16-bit offset
///    specified by the immediate operand __n.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VPINSRW / PINSRW instruction.
///
/// \param __a
///    A 64-bit vector of [4 x i16].
/// \param __d
///    An integer. The lower 16-bit value from this operand is written to the
///    destination at the offset specified by operand __n.
/// \param __n
///    An immediate integer operant that determines which the bits to be used
///    in the destination.
///    0: Bits [15:0] are copied to the destination.
///    1: Bits [31:16] are copied to the destination.
///    2: Bits [47:32] are copied to the destination.
///    3: Bits [63:48] are copied to the destination.
///    The remaining bits in the destination are copied from the corresponding
///    bits in operand __a.
/// \returns A 64-bit integer vector containing the copied packed data from the
///    operands.
#define _mm_insert_pi16(a, d, n) __extension__ ({ \
  (__m64)__builtin_ia32_vec_set_v4hi((__m64)a, (int)d, (int)n); })

/// \brief Compares each of the corresponding packed 16-bit integer values of
///    the 64-bit integer vectors, and writes the greater value to the
///    corresponding bits in the destination.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c PMAXSW instruction.
///
/// \param __a
///    A 64-bit integer vector containing one of the source operands.
/// \param __b
///    A 64-bit integer vector containing one of the source operands.
/// \returns A 64-bit integer vector containing the comparison results.
a725 13
/// \brief Compares each of the corresponding packed 8-bit unsigned integer
///    values of the 64-bit integer vectors, and writes the greater value to the
///    corresponding bits in the destination.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c PMAXUB instruction.
///
/// \param __a
///    A 64-bit integer vector containing one of the source operands.
/// \param __b
///    A 64-bit integer vector containing one of the source operands.
/// \returns A 64-bit integer vector containing the comparison results.
a731 13
/// \brief Compares each of the corresponding packed 16-bit integer values of
///    the 64-bit integer vectors, and writes the lesser value to the
///    corresponding bits in the destination.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c PMINSW instruction.
///
/// \param __a
///    A 64-bit integer vector containing one of the source operands.
/// \param __b
///    A 64-bit integer vector containing one of the source operands.
/// \returns A 64-bit integer vector containing the comparison results.
a737 13
/// \brief Compares each of the corresponding packed 8-bit unsigned integer
///    values of the 64-bit integer vectors, and writes the lesser value to the
///    corresponding bits in the destination.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c PMINUB instruction.
///
/// \param __a
///    A 64-bit integer vector containing one of the source operands.
/// \param __b
///    A 64-bit integer vector containing one of the source operands.
/// \returns A 64-bit integer vector containing the comparison results.
a743 12
/// \brief Takes the most significant bit from each 8-bit element in a 64-bit
///    integer vector to create a 16-bit mask value. Zero-extends the value to
///    32-bit integer and writes it to the destination.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c PMOVMSKB instruction.
///
/// \param __a
///    A 64-bit integer vector containing the values with bits to be extracted.
/// \returns The most significant bit from each 8-bit element in the operand,
///    written to bits [15:0].
a749 13
/// \brief Multiplies packed 16-bit unsigned integer values and writes the
///    high-order 16 bits of each 32-bit product to the corresponding bits in
///    the destination.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c PMULHUW instruction.
///
/// \param __a
///    A 64-bit integer vector containing one of the source operands.
/// \param __b
///    A 64-bit integer vector containing one of the source operands.
/// \returns A 64-bit integer vector containing the products of both operands.
a755 27
/// \brief Shuffles the 4 16-bit integers from a 64-bit integer vector to the
///    destination, as specified by the immediate value operand.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c PSHUFW instruction.
///
/// \code
/// __m64 _mm_shuffle_pi16(__m64 a, const int n);
/// \endcode
///
/// \param a
///    A 64-bit integer vector containing the values to be shuffled.
/// \param n
///    An immediate value containing an 8-bit value specifying which elements to
///    copy from a. The destinations within the 64-bit destination are assigned
///    values as follows:
///    Bits [1:0] are used to assign values to bits [15:0] in the destination.
///    Bits [3:2] are used to assign values to bits [31:16] in the destination.
///    Bits [5:4] are used to assign values to bits [47:32] in the destination.
///    Bits [7:6] are used to assign values to bits [63:48] in the destination.
///    Bit value assignments:
///    00: assigned from bits [15:0] of a.
///    01: assigned from bits [31:16] of a.
///    10: assigned from bits [47:32] of a.
///    11: assigned from bits [63:48] of a.
/// \returns A 64-bit integer vector containing the shuffled values.
a758 21
/// \brief Conditionally copies the values from each 8-bit element in the first
///    64-bit integer vector operand to the specified memory location, as
///    specified by the most significant bit in the corresponding element in the
///    second 64-bit integer vector operand. To minimize caching, the data is
///    flagged as non-temporal (unlikely to be used again soon).
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c MASKMOVQ instruction.
///
/// \param __d
///    A 64-bit integer vector containing the values with elements to be copied.
/// \param __n
///    A 64-bit integer vector operand. The most significant bit from each 8-bit
///    element determines whether the corresponding element in operand __d is
///    copied. If the most significant bit of a given element is 1, the
///    corresponding element in operand __d is copied.
/// \param __p
///    A pointer to a 64-bit memory location that will receive the conditionally
///    copied integer values. The address of the memory location does not have
///    to be aligned.
a764 13
/// \brief Computes the rounded averages of the packed unsigned 8-bit integer
///    values and writes the averages to the corresponding bits in the
///    destination.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c PAVGB instruction.
///
/// \param __a
///    A 64-bit integer vector containing one of the source operands.
/// \param __b
///    A 64-bit integer vector containing one of the source operands.
/// \returns A 64-bit integer vector containing the averages of both operands.
a770 13
/// \brief Computes the rounded averages of the packed unsigned 16-bit integer
///    values and writes the averages to the corresponding bits in the
///    destination.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c PAVGW instruction.
///
/// \param __a
///    A 64-bit integer vector containing one of the source operands.
/// \param __b
///    A 64-bit integer vector containing one of the source operands.
/// \returns A 64-bit integer vector containing the averages of both operands.
a776 16
/// \brief Subtracts the corresponding 8-bit unsigned integer values of the two
///    64-bit vector operands and computes the absolute value for each of the
///    difference. Then sum of the 8 absolute differences is written to the
///    bits [15:0] of the destination; the remaining bits [63:16] are cleared.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c PSADBW instruction.
///
/// \param __a
///    A 64-bit integer vector containing one of the source operands.
/// \param __b
///    A 64-bit integer vector containing one of the source operands.
/// \returns A 64-bit integer vector whose lower 16 bits contain the sums of the
///    sets of absolute differences between both operands. The upper bits are
///    cleared.
a782 32
/// \brief Returns the contents of the MXCSR register as a 32-bit unsigned
///    integer value. There are several groups of macros associated with this
///    intrinsic, including:
///    * For checking exception states: _MM_EXCEPT_INVALID, _MM_EXCEPT_DIV_ZERO,
///      _MM_EXCEPT_DENORM, _MM_EXCEPT_OVERFLOW, _MM_EXCEPT_UNDERFLOW,
///      _MM_EXCEPT_INEXACT. There is a convenience wrapper
///      _MM_GET_EXCEPTION_STATE().
///    * For checking exception masks: _MM_MASK_UNDERFLOW, _MM_MASK_OVERFLOW,
///      _MM_MASK_INVALID, _MM_MASK_DENORM, _MM_MASK_DIV_ZERO, _MM_MASK_INEXACT.
///      There is a convenience wrapper _MM_GET_EXCEPTION_MASK().
///    * For checking rounding modes: _MM_ROUND_NEAREST, _MM_ROUND_DOWN,
///      _MM_ROUND_UP, _MM_ROUND_TOWARD_ZERO. There is a convenience wrapper
///      _MM_GET_ROUNDING_MODE(x) where x is one of these macros.
///    * For checking flush-to-zero mode: _MM_FLUSH_ZERO_ON, _MM_FLUSH_ZERO_OFF.
///      There is a convenience wrapper _MM_GET_FLUSH_ZERO_MODE().
///    * For checking denormals-are-zero mode: _MM_DENORMALS_ZERO_ON,
///      _MM_DENORMALS_ZERO_OFF. There is a convenience wrapper
///      _MM_GET_DENORMALS_ZERO_MODE().
///
///    For example, the expression below checks if an overflow exception has
///    occurred:
///      ( _mm_getcsr() & _MM_EXCEPT_OVERFLOW )
///
///    The following example gets the current rounding mode:
///      _MM_GET_ROUNDING_MODE()
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VSTMXCSR / STMXCSR instruction.
///
/// \returns A 32-bit unsigned integer containing the contents of the MXCSR
///    register.
a788 36
/// \brief Sets the MXCSR register with the 32-bit unsigned integer value. There
///    are several groups of macros associated with this intrinsic, including:
///    * For setting exception states: _MM_EXCEPT_INVALID, _MM_EXCEPT_DIV_ZERO,
///      _MM_EXCEPT_DENORM, _MM_EXCEPT_OVERFLOW, _MM_EXCEPT_UNDERFLOW,
///      _MM_EXCEPT_INEXACT. There is a convenience wrapper
///      _MM_SET_EXCEPTION_STATE(x) where x is one of these macros.
///    * For setting exception masks: _MM_MASK_UNDERFLOW, _MM_MASK_OVERFLOW,
///      _MM_MASK_INVALID, _MM_MASK_DENORM, _MM_MASK_DIV_ZERO, _MM_MASK_INEXACT.
///      There is a convenience wrapper _MM_SET_EXCEPTION_MASK(x) where x is one
///      of these macros.
///    * For setting rounding modes: _MM_ROUND_NEAREST, _MM_ROUND_DOWN,
///      _MM_ROUND_UP, _MM_ROUND_TOWARD_ZERO. There is a convenience wrapper
///      _MM_SET_ROUNDING_MODE(x) where x is one of these macros.
///    * For setting flush-to-zero mode: _MM_FLUSH_ZERO_ON, _MM_FLUSH_ZERO_OFF.
///      There is a convenience wrapper _MM_SET_FLUSH_ZERO_MODE(x) where x is
///      one of these macros.
///    * For setting denormals-are-zero mode: _MM_DENORMALS_ZERO_ON,
///      _MM_DENORMALS_ZERO_OFF. There is a convenience wrapper
///      _MM_SET_DENORMALS_ZERO_MODE(x) where x is one of these macros.
///
///    For example, the following expression causes subsequent floating-point
///    operations to round up:
///      _mm_setcsr(_mm_getcsr() | _MM_ROUND_UP)
///
///    The following example sets the DAZ and FTZ flags:
///      void setFlags() {
///        _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON)
///        _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON)
///      }
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VLDMXCSR / LDMXCSR instruction.
///
/// \param __i
///    A 32-bit unsigned integer value to be written to the MXCSR register.
a794 31
/// \brief Selects 4 float values from the 128-bit operands of [4 x float], as
///    specified by the immediate value operand.
///
/// \headerfile <x86intrin.h>
///
/// \code
/// __m128 _mm_shuffle_ps(__m128 a, __m128 b, const int mask);
/// \endcode
///
/// This intrinsic corresponds to the \c VSHUFPS / SHUFPS instruction.
///
/// \param a
///    A 128-bit vector of [4 x float].
/// \param b
///    A 128-bit vector of [4 x float].
/// \param mask
///    An immediate value containing an 8-bit value specifying which elements to
///    copy from a and b.
///    Bits [3:0] specify the values copied from operand a.
///    Bits [7:4] specify the values copied from operand b. The destinations
///    within the 128-bit destination are assigned values as follows:
///    Bits [1:0] are used to assign values to bits [31:0] in the destination.
///    Bits [3:2] are used to assign values to bits [63:32] in the destination.
///    Bits [5:4] are used to assign values to bits [95:64] in the destination.
///    Bits [7:6] are used to assign values to bits [127:96] in the destination.
///    Bit value assignments:
///    00: Bits [31:0] copied from the specified operand.
///    01: Bits [63:32] copied from the specified operand.
///    10: Bits [95:64] copied from the specified operand.
///    11: Bits [127:96] copied from the specified operand.
/// \returns A 128-bit vector of [4 x float] containing the shuffled values.
d797 4
a800 22
                                  0 + (((mask) >> 0) & 0x3), \
                                  0 + (((mask) >> 2) & 0x3), \
                                  4 + (((mask) >> 4) & 0x3), \
                                  4 + (((mask) >> 6) & 0x3)); })

/// \brief Unpacks the high-order (index 2,3) values from two 128-bit vectors of
///    [4 x float] and interleaves them into a 128-bit vector of [4 x
///    float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VUNPCKHPS / UNPCKHPS instruction.
///
/// \param __a
///    A 128-bit vector of [4 x float].
///    Bits [95:64] are written to bits [31:0] of the destination.
///    Bits [127:96] are written to bits [95:64] of the destination.
/// \param __b
///    A 128-bit vector of [4 x float].
///    Bits [95:64] are written to bits [63:32] of the destination.
///    Bits [127:96] are written to bits [127:96] of the destination.
/// \returns A 128-bit vector of [4 x float] containing the interleaved values.
d804 1
a804 1
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 2, 6, 3, 7);
a806 17
/// \brief Unpacks the low-order (index 0,1) values from two 128-bit vectors of
///    [4 x float] and interleaves them into a 128-bit vector of [4 x
///    float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VUNPCKLPS / UNPCKLPS instruction.
///
/// \param __a
///    A 128-bit vector of [4 x float].
///    Bits [31:0] are written to bits [31:0] of the destination.
///    Bits [63:32] are written to bits [95:64] of the destination.
/// \param __b
///    A 128-bit vector of [4 x float].
///    Bits [31:0] are written to bits [63:32] of the destination.
///    Bits [63:32] are written to bits [127:96] of the destination.
/// \returns A 128-bit vector of [4 x float] containing the interleaved values.
d810 1
a810 1
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 0, 4, 1, 5);
a812 15
/// \brief Constructs a 128-bit floating-point vector of [4 x float]. The lower
///    32 bits are set to the lower 32 bits of the second parameter. The upper
///    96 bits are set to the upper 96 bits of the first parameter.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMOVSS / MOVSS instruction.
///
/// \param __a
///    A 128-bit floating-point vector of [4 x float]. The upper 96 bits are
///    written to the upper 96 bits of the result.
/// \param __b
///    A 128-bit floating-point vector of [4 x float]. The lower 32 bits are
///    written to the lower 32 bits of the result.
/// \returns A 128-bit floating-point vector of [4 x float].
d816 1
a816 1
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 4, 1, 2, 3);
a818 15
/// \brief Constructs a 128-bit floating-point vector of [4 x float]. The lower
///    64 bits are set to the upper 64 bits of the second parameter. The upper
///    64 bits are set to the upper 64 bits of the first parameter.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VUNPCKHPD / UNPCKHPD instruction.
///
/// \param __a
///    A 128-bit floating-point vector of [4 x float]. The upper 64 bits are
///    written to the upper 64 bits of the result.
/// \param __b
///    A 128-bit floating-point vector of [4 x float]. The upper 64 bits are
///    written to the lower 64 bits of the result.
/// \returns A 128-bit floating-point vector of [4 x float].
d822 1
a822 1
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 6, 7, 2, 3);
a824 15
/// \brief Constructs a 128-bit floating-point vector of [4 x float]. The lower
///    64 bits are set to the lower 64 bits of the first parameter. The upper
///    64 bits are set to the lower 64 bits of the second parameter.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VUNPCKLPD / UNPCKLPD instruction.
///
/// \param __a
///    A 128-bit floating-point vector of [4 x float]. The lower 64 bits are
///    written to the lower 64 bits of the result.
/// \param __b
///    A 128-bit floating-point vector of [4 x float]. The lower 64 bits are
///    written to the upper 64 bits of the result.
/// \returns A 128-bit floating-point vector of [4 x float].
d828 1
a828 1
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 0, 1, 4, 5);
a830 12
/// \brief Converts a 64-bit vector of [4 x i16] into a 128-bit vector of [4 x
///    float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c CVTPI2PS + \c COMPOSITE instruction.
///
/// \param __a
///    A 64-bit vector of [4 x i16]. The elements of the destination are copied
///    from the corresponding elements in this operand.
/// \returns A 128-bit vector of [4 x float] containing the copied and converted
///    values from the operand.
a848 12
/// \brief Converts a 64-bit vector of 16-bit unsigned integer values into a
///    128-bit vector of [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c CVTPI2PS + \c COMPOSITE instruction.
///
/// \param __a
///    A 64-bit vector of 16-bit unsigned integer values. The elements of the
///    destination are copied from the corresponding elements in this operand.
/// \returns A 128-bit vector of [4 x float] containing the copied and converted
///    values from the operand.
a865 12
/// \brief Converts the lower four 8-bit values from a 64-bit vector of [8 x i8]
///    into a 128-bit vector of [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c CVTPI2PS + \c COMPOSITE instruction.
///
/// \param __a
///    A 64-bit vector of [8 x i8]. The elements of the destination are copied
///    from the corresponding lower 4 elements in this operand.
/// \returns A 128-bit vector of [4 x float] containing the copied and converted
///    values from the operand.
a877 13
/// \brief Converts the lower four unsigned 8-bit integer values from a 64-bit
///    vector of [8 x u8] into a 128-bit vector of [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c CVTPI2PS + \c COMPOSITE instruction.
///
/// \param __a
///    A 64-bit vector of unsigned 8-bit integer values. The elements of the
///    destination are copied from the corresponding lower 4 elements in this
///    operand.
/// \returns A 128-bit vector of [4 x float] containing the copied and converted
///    values from the source operand.
a888 16
/// \brief Converts the two 32-bit signed integer values from each 64-bit vector
///    operand of [2 x i32] into a 128-bit vector of [4 x float].
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c CVTPI2PS + \c COMPOSITE instruction.
///
/// \param __a
///    A 64-bit vector of [2 x i32]. The lower elements of the destination are
///    copied from the elements in this operand.
/// \param __b
///    A 64-bit vector of [2 x i32]. The upper elements of the destination are
///    copied from the elements in this operand.
/// \returns A 128-bit vector of [4 x float] whose lower 64 bits contain the
///    copied and converted values from the first operand. The upper 64 bits
///    contain the copied and converted values from the second operand.
a900 16
/// \brief Converts each single-precision floating-point element of a 128-bit
///    floating-point vector of [4 x float] into a 16-bit signed integer, and
///    packs the results into a 64-bit integer vector of [4 x i16]. If the
///    floating-point element is NaN or infinity, or if the floating-point
///    element is greater than 0x7FFFFFFF or less than -0x8000, it is converted
///    to 0x8000. Otherwise if the floating-point element is greater
///    than 0x7FFF, it is converted to 0x7FFF.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c CVTPS2PI + \c COMPOSITE instruction.
///
/// \param __a
///    A 128-bit floating-point vector of [4 x float].
/// \returns A 64-bit integer vector of [4 x i16] containing the converted
///    values.
a912 17
/// \brief Converts each single-precision floating-point element of a 128-bit
///    floating-point vector of [4 x float] into an 8-bit signed integer, and
///    packs the results into the lower 32 bits of a 64-bit integer vector of
///    [8 x i8]. The upper 32 bits of the vector are set to 0. If the
///    floating-point element is NaN or infinity, or if the floating-point
///    element is greater than 0x7FFFFFFF or less than -0x80, it is converted
///    to 0x80. Otherwise if the floating-point element is greater
///    than 0x7F, it is converted to 0x7F.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c CVTPS2PI + \c COMPOSITE instruction.
///
/// \param __a
///    128-bit floating-point vector of [4 x float].
/// \returns A 64-bit integer vector of [8 x i8]. The lower 32 bits contain the
///    converted values and the uppper 32 bits are set to zero.
a923 14
/// \brief Extracts the sign bits from each single-precision floating-point
///    element of a 128-bit floating-point vector of [4 x float] and returns the
///    sign bits in bits [0:3] of the result. Bits [31:4] of the result are set
///    to zero.
///
/// \headerfile <x86intrin.h>
///
/// This intrinsic corresponds to the \c VMOVMSKPS / MOVMSKPS instruction.
///
/// \param __a
///    A 128-bit floating-point vector of [4 x float].
/// \returns A 32-bit integer value. Bits [3:0] contain the sign bits from each
///    single-precision floating-point element of the parameter. Bits [31:4] are
///    set to zero.
d927 1
a927 1
  return __builtin_ia32_movmskps((__v4sf)__a);
d931 3
a933 1
#define _MM_ALIGN16 __attribute__((aligned(16)))
d1006 1
a1006 1
#if defined(__SSE2__) && !__building_module(_Builtin_intrinsics)
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d49 1
a49 1
/// This intrinsic corresponds to the <c> VADDSS / ADDSS </c> instructions.
d72 1
a72 1
/// This intrinsic corresponds to the <c> VADDPS / ADDPS </c> instructions.
d91 1
a91 1
/// This intrinsic corresponds to the <c> VSUBSS / SUBSS </c> instructions.
d115 1
a115 1
/// This intrinsic corresponds to the <c> VSUBPS / SUBPS </c> instructions.
d134 1
a134 1
/// This intrinsic corresponds to the <c> VMULSS / MULSS </c> instructions.
d157 1
a157 1
/// This intrinsic corresponds to the <c> VMULPS / MULPS </c> instructions.
d176 1
a176 1
/// This intrinsic corresponds to the <c> VDIVSS / DIVSS </c> instructions.
d198 1
a198 1
/// This intrinsic corresponds to the <c> VDIVPS / DIVPS </c> instructions.
d217 1
a217 1
/// This intrinsic corresponds to the <c> VSQRTSS / SQRTSS </c> instructions.
d236 1
a236 1
/// This intrinsic corresponds to the <c> VSQRTPS / SQRTPS </c> instructions.
d253 1
a253 1
/// This intrinsic corresponds to the <c> VRCPSS / RCPSS </c> instructions.
d272 1
a272 1
/// This intrinsic corresponds to the <c> VRCPPS / RCPPS </c> instructions.
d289 1
a289 1
/// This intrinsic corresponds to the <c> VRSQRTSS / RSQRTSS </c> instructions.
d309 1
a309 1
/// This intrinsic corresponds to the <c> VRSQRTPS / RSQRTPS </c> instructions.
d327 1
a327 1
/// This intrinsic corresponds to the <c> VMINSS / MINSS </c> instructions.
d344 2
a345 2
/// \brief Compares two 128-bit vectors of [4 x float] and returns the lesser
///    of each pair of values.
d349 1
a349 1
/// This intrinsic corresponds to the <c> VMINPS / MINPS </c> instructions.
d364 2
a365 2
///    operands and returns the greater value in the low-order bits of a 128-bit
///    vector of [4 x float].
d369 1
a369 1
/// This intrinsic corresponds to the <c> VMAXSS / MAXSS </c> instructions.
d391 1
a391 1
/// This intrinsic corresponds to the <c> VMAXPS / MAXPS </c> instructions.
d409 1
a409 1
/// This intrinsic corresponds to the <c> VANDPS / ANDPS </c> instructions.
d429 1
a429 1
/// This intrinsic corresponds to the <c> VANDNPS / ANDNPS </c> instructions.
d449 1
a449 1
/// This intrinsic corresponds to the <c> VORPS / ORPS </c> instructions.
d468 1
a468 1
/// This intrinsic corresponds to the <c> VXORPS / XORPS </c> instructions.
d488 1
a488 1
/// This intrinsic corresponds to the <c> VCMPEQSS / CMPEQSS </c> instructions.
d509 1
a509 1
/// This intrinsic corresponds to the <c> VCMPEQPS / CMPEQPS </c> instructions.
d529 1
a529 1
/// This intrinsic corresponds to the <c> VCMPLTSS / CMPLTSS </c> instructions.
d551 1
a551 1
/// This intrinsic corresponds to the <c> VCMPLTPS / CMPLTPS </c> instructions.
d572 1
a572 1
/// This intrinsic corresponds to the <c> VCMPLESS / CMPLESS </c> instructions.
d594 1
a594 1
/// This intrinsic corresponds to the <c> VCMPLEPS / CMPLEPS </c> instructions.
d614 1
a614 1
/// This intrinsic corresponds to the <c> VCMPLTSS / CMPLTSS </c> instructions.
d638 1
a638 1
/// This intrinsic corresponds to the <c> VCMPLTPS / CMPLTPS </c> instructions.
d659 1
a659 1
/// This intrinsic corresponds to the <c> VCMPLESS / CMPLESS </c> instructions.
d683 1
a683 1
/// This intrinsic corresponds to the <c> VCMPLEPS / CMPLEPS </c> instructions.
d702 1
a702 2
/// This intrinsic corresponds to the <c> VCMPNEQSS / CMPNEQSS </c>
///   instructions.
d723 1
a723 2
/// This intrinsic corresponds to the <c> VCMPNEQPS / CMPNEQPS </c>
///   instructions.
d743 1
a743 2
/// This intrinsic corresponds to the <c> VCMPNLTSS / CMPNLTSS </c>
///   instructions.
d765 1
a765 2
/// This intrinsic corresponds to the <c> VCMPNLTPS / CMPNLTPS </c>
///   instructions.
d786 1
a786 2
/// This intrinsic corresponds to the <c> VCMPNLESS / CMPNLESS </c>
///   instructions.
d808 1
a808 2
/// This intrinsic corresponds to the <c> VCMPNLEPS / CMPNLEPS </c>
///   instructions.
d829 1
a829 2
/// This intrinsic corresponds to the <c> VCMPNLTSS / CMPNLTSS </c>
///   instructions.
d853 1
a853 2
/// This intrinsic corresponds to the <c> VCMPNLTPS / CMPNLTPS </c>
///   instructions.
d874 1
a874 2
/// This intrinsic corresponds to the <c> VCMPNLESS / CMPNLESS </c>
///   instructions.
d898 1
a898 2
/// This intrinsic corresponds to the <c> VCMPNLEPS / CMPNLEPS </c>
///   instructions.
d919 1
a919 2
/// This intrinsic corresponds to the <c> VCMPORDSS / CMPORDSS </c>
///   instructions.
d941 1
a941 2
/// This intrinsic corresponds to the <c> VCMPORDPS / CMPORDPS </c>
///   instructions.
d962 1
a962 2
/// This intrinsic corresponds to the <c> VCMPUNORDSS / CMPUNORDSS </c>
///   instructions.
d984 1
a984 2
/// This intrinsic corresponds to the <c> VCMPUNORDPS / CMPUNORDPS </c>
///   instructions.
d1002 1
a1002 2
/// This intrinsic corresponds to the <c> VCOMISS / COMISS </c>
///   instructions.
d1023 1
a1023 2
/// This intrinsic corresponds to the <c> VCOMISS / COMISS </c>
///   instructions.
d1044 1
a1044 1
/// This intrinsic corresponds to the <c> VCOMISS / COMISS </c> instructions.
d1065 1
a1065 1
/// This intrinsic corresponds to the <c> VCOMISS / COMISS </c> instructions.
d1086 1
a1086 1
/// This intrinsic corresponds to the <c> VCOMISS / COMISS </c> instructions.
d1107 1
a1107 1
/// This intrinsic corresponds to the <c> VCOMISS / COMISS </c> instructions.
d1128 1
a1128 1
/// This intrinsic corresponds to the <c> VUCOMISS / UCOMISS </c> instructions.
d1149 1
a1149 1
/// This intrinsic corresponds to the <c> VUCOMISS / UCOMISS </c> instructions.
d1165 3
a1167 3
///    the low-order bits of both operands to determine if the first operand is
///    less than or equal to the second operand and returns the result of the
///    comparison.
d1171 1
a1171 1
/// This intrinsic corresponds to the <c> VUCOMISS / UCOMISS </c> instructions.
d1187 2
a1188 2
///    the low-order bits of both operands to determine if the first operand is
///    greater than the second operand and returns the result of the
d1193 1
a1193 1
/// This intrinsic corresponds to the <c> VUCOMISS / UCOMISS </c> instructions.
d1215 1
a1215 1
/// This intrinsic corresponds to the <c> VUCOMISS / UCOMISS </c> instructions.
d1236 1
a1236 1
/// This intrinsic corresponds to the <c> VUCOMISS / UCOMISS </c> instructions.
d1256 1
a1256 2
/// This intrinsic corresponds to the <c> VCVTSS2SI / CVTSS2SI </c>
///   instructions.
d1273 1
a1273 2
/// This intrinsic corresponds to the <c> VCVTSS2SI / CVTSS2SI </c>
///   instructions.
d1292 1
a1292 2
/// This intrinsic corresponds to the <c> VCVTSS2SI / CVTSS2SI </c>
///   instructions.
d1311 1
a1311 1
/// This intrinsic corresponds to the <c> CVTPS2PI </c> instruction.
d1327 1
a1327 1
/// This intrinsic corresponds to the <c> CVTPS2PI </c> instruction.
d1344 1
a1344 2
/// This intrinsic corresponds to the <c> VCVTTSS2SI / CVTTSS2SI </c>
///   instructions.
d1362 1
a1362 2
/// This intrinsic corresponds to the <c> VCVTTSS2SI / CVTTSS2SI </c>
///   instructions.
a1373 1
#ifdef __x86_64__
d1380 1
a1380 2
/// This intrinsic corresponds to the <c> VCVTTSS2SI / CVTTSS2SI </c>
///   instructions.
a1390 1
#endif
d1398 1
a1398 2
/// This intrinsic corresponds to the <c> CVTTPS2PI / VTTPS2PI </c>
///   instructions.
d1415 1
a1415 1
/// This intrinsic corresponds to the <c> CVTTPS2PI </c> instruction.
d1433 1
a1433 1
/// This intrinsic corresponds to the <c> VCVTSI2SS / CVTSI2SS </c> instruction.
d1456 1
a1456 1
/// This intrinsic corresponds to the <c> VCVTSI2SS / CVTSI2SS </c> instruction.
d1480 1
a1480 1
/// This intrinsic corresponds to the <c> VCVTSI2SS / CVTSI2SS </c> instruction.
d1505 1
a1505 1
/// This intrinsic corresponds to the <c> CVTPI2PS </c> instruction.
d1528 1
a1528 1
/// This intrinsic corresponds to the <c> CVTPI2PS </c> instruction.
d1549 1
a1549 1
/// This intrinsic corresponds to the <c> VMOVSS / MOVSS </c> instruction.
d1561 1
a1561 1
/// \brief Loads two packed float values from the address \a __p into the
d1567 1
a1567 1
/// This intrinsic corresponds to the <c> VMOVHPD / MOVHPD </c> instruction.
d1588 3
a1590 3
/// \brief Loads two packed float values from the address \a __p into the
///    low-order bits of a 128-bit vector of [4 x float]. The high-order bits
///    are copied from the high-order bits of the first operand.
d1594 1
a1594 1
/// This intrinsic corresponds to the <c> VMOVLPD / MOVLPD </c> instruction.
d1622 1
a1622 1
/// This intrinsic corresponds to the <c> VMOVSS / MOVSS </c> instruction.
d1645 1
a1645 1
/// This intrinsic corresponds to the <c> VMOVSS / MOVSS + shuffling </c>
d1650 2
a1651 2
/// \returns A 128-bit vector of [4 x float] containing the loaded and
///    duplicated values.
d1669 1
a1669 1
/// This intrinsic corresponds to the <c> VMOVAPS / MOVAPS </c> instruction.
d1686 1
a1686 1
/// This intrinsic corresponds to the <c> VMOVUPS / MOVUPS </c> instruction.
d1706 1
a1706 1
/// This intrinsic corresponds to the <c> VMOVAPS / MOVAPS + shuffling </c>
d1728 1
d1741 1
a1741 1
/// This intrinsic corresponds to the <c> VMOVSS / MOVSS </c> instruction.
d1761 1
a1761 1
/// This intrinsic corresponds to the <c> VPERMILPS / PERMILPS </c> instruction.
d1780 1
a1780 1
/// This intrinsic corresponds to the <c> VPERMILPS / PERMILPS </c> instruction.
d1852 1
a1852 1
/// This intrinsic corresponds to the <c> VXORPS / XORPS </c> instruction.
d1867 1
a1867 1
/// This intrinsic corresponds to the <c> VPEXTRQ / MOVQ </c> instruction.
d1884 1
a1884 1
/// This intrinsic corresponds to the <c> VMOVLPS / MOVLPS </c> instruction.
d1901 1
a1901 1
/// This intrinsic corresponds to the <c> VMOVSS / MOVSS </c> instruction.
d1916 2
a1917 2
/// \brief Stores a 128-bit vector of [4 x float] to an unaligned memory
///    location.
d1921 1
a1921 1
/// This intrinsic corresponds to the <c> VMOVUPS / MOVUPS </c> instruction.
d1937 2
a1938 2
/// \brief Stores a 128-bit vector of [4 x float] into an aligned memory
///    location.
d1942 2
a1943 1
/// This intrinsic corresponds to the <c> VMOVAPS / MOVAPS </c> instruction.
d1946 1
a1946 2
///    A pointer to a 128-bit memory location. The address of the memory
///    location has to be 16-byte aligned.
d1948 2
a1949 1
///    A 128-bit vector of [4 x float] containing the values to be stored.
d1961 1
a1961 1
/// This intrinsic corresponds to <c> VMOVAPS / MOVAPS + shuffling </c>
d1968 1
a1968 1
///    of the four contiguous elements pointed by \a __p.
d1976 2
a1977 2
/// \brief Stores the lower 32 bits of a 128-bit vector of [4 x float] into
///    four contiguous elements in an aligned memory location.
d1981 1
a1981 2
/// This intrinsic corresponds to <c> VMOVAPS / MOVAPS + shuffling </c>
///    instruction.
d1984 2
a1985 1
///    A pointer to a 128-bit memory location.
d1987 1
a1987 2
///    A 128-bit vector of [4 x float] whose lower 32 bits are stored to each
///    of the four contiguous elements pointed by \a __p.
d1999 1
a1999 1
/// This intrinsic corresponds to the <c> VMOVAPS / MOVAPS + shuffling </c>
d2032 1
a2032 1
/// This intrinsic corresponds to the <c> PREFETCHNTA </c> instruction.
d2037 3
a2039 4
///    A predefined integer constant specifying the type of prefetch
///    operation: \n
///    _MM_HINT_NTA: Move data using the non-temporal access (NTA) hint. The
///    PREFETCHNTA instruction will be generated. \n
d2041 1
a2041 1
///    be generated. \n
d2043 1
a2043 1
///    be generated. \n
d2045 1
a2045 1
///    be generated.                                   
d2055 1
a2055 1
/// This intrinsic corresponds to the <c> MOVNTQ </c> instruction.
d2073 1
a2073 1
/// This intrinsic corresponds to the <c> VMOVNTPS / MOVNTPS </c> instruction.
a2085 4
#if defined(__cplusplus)
extern "C" {
#endif

d2093 1
a2093 1
/// This intrinsic corresponds to the <c> SFENCE </c> instruction.
d2095 5
a2099 5
void _mm_sfence(void);

#if defined(__cplusplus)
} // extern "C"
#endif
d2106 1
a2106 3
/// \code
/// void _mm_extract_pi(__m64 a, int n);
/// \endcode
d2108 1
a2108 3
/// This intrinsic corresponds to the <c> VPEXTRW / PEXTRW </c> instruction.
///
/// \param a
d2110 5
a2114 5
/// \param n
///    An immediate integer operand that determines which bits are extracted: \n
///    0: Bits [15:0] are copied to the destination. \n
///    1: Bits [31:16] are copied to the destination. \n
///    2: Bits [47:32] are copied to the destination. \n
d2122 1
a2122 1
///    specified by the immediate operand \a n.
d2126 1
a2126 3
/// \code
/// void _mm_insert_pi(__m64 a, int d, int n);
/// \endcode
d2128 1
a2128 3
/// This intrinsic corresponds to the <c> VPINSRW / PINSRW </c> instruction.
///
/// \param a
d2130 1
a2130 1
/// \param d
d2132 2
a2133 2
///    destination at the offset specified by operand \a n.
/// \param n
d2135 5
a2139 5
///    in the destination. \n
///    0: Bits [15:0] are copied to the destination. \n
///    1: Bits [31:16] are copied to the destination. \n
///    2: Bits [47:32] are copied to the destination. \n
///    3: Bits [63:48] are copied to the destination.  \n
d2141 1
a2141 1
///    bits in operand \a a.
d2153 1
a2153 1
/// This intrinsic corresponds to the <c> PMAXSW </c> instruction.
d2172 1
a2172 1
/// This intrinsic corresponds to the <c> PMAXUB </c> instruction.
d2191 1
a2191 1
/// This intrinsic corresponds to the <c> PMINSW </c> instruction.
d2210 1
a2210 1
/// This intrinsic corresponds to the <c> PMINUB </c> instruction.
d2229 1
a2229 1
/// This intrinsic corresponds to the <c> PMOVMSKB </c> instruction.
d2247 1
a2247 1
/// This intrinsic corresponds to the <c> PMULHUW </c> instruction.
d2265 2
a2270 2
/// This intrinsic corresponds to the <c> PSHUFW </c> instruction.
///
d2275 11
a2285 15
///    copy from \a a. The destinations within the 64-bit destination are
///    assigned values as follows: \n
///    Bits [1:0] are used to assign values to bits [15:0] in the
///    destination. \n
///    Bits [3:2] are used to assign values to bits [31:16] in the
///    destination. \n
///    Bits [5:4] are used to assign values to bits [47:32] in the
///    destination. \n
///    Bits [7:6] are used to assign values to bits [63:48] in the
///    destination. \n
///    Bit value assignments: \n
///    00: assigned from bits [15:0] of \a a. \n
///    01: assigned from bits [31:16] of \a a. \n
///    10: assigned from bits [47:32] of \a a. \n
///    11: assigned from bits [63:48] of \a a.
d2298 1
a2298 1
/// This intrinsic corresponds to the <c> MASKMOVQ </c> instruction.
d2304 3
a2306 3
///    element determines whether the corresponding element in operand \a __d
///    is copied. If the most significant bit of a given element is 1, the
///    corresponding element in operand \a __d is copied.
d2323 1
a2323 1
/// This intrinsic corresponds to the <c> PAVGB </c> instruction.
d2342 1
a2342 1
/// This intrinsic corresponds to the <c> PAVGW </c> instruction.
d2362 1
a2362 1
/// This intrinsic corresponds to the <c> PSADBW </c> instruction.
a2376 4
#if defined(__cplusplus)
extern "C" {
#endif

d2378 1
a2378 3
///    integer value.
///
///    There are several groups of macros associated with this
d2380 1
a2380 3
///    <ul>
///    <li>
///      For checking exception states: _MM_EXCEPT_INVALID, _MM_EXCEPT_DIV_ZERO,
d2384 1
a2384 3
///    </li>
///    <li>
///      For checking exception masks: _MM_MASK_UNDERFLOW, _MM_MASK_OVERFLOW,
d2387 1
a2387 3
///    </li>            
///    <li>
///      For checking rounding modes: _MM_ROUND_NEAREST, _MM_ROUND_DOWN,
d2390 1
a2390 3
///    </li>
///    <li> 
///      For checking flush-to-zero mode: _MM_FLUSH_ZERO_ON, _MM_FLUSH_ZERO_OFF.
d2392 1
a2392 3
///    </li>
///    <li> 
///      For checking denormals-are-zero mode: _MM_DENORMALS_ZERO_ON,
a2394 2
///    </li>
///    </ul>
d2405 1
a2405 1
/// This intrinsic corresponds to the <c> VSTMXCSR / STMXCSR </c> instruction.
d2409 5
a2413 1
unsigned int _mm_getcsr(void);
d2415 3
a2417 7
/// \brief Sets the MXCSR register with the 32-bit unsigned integer value.
///   
///    There are several groups of macros associated with this intrinsic,
///    including:
///    <ul>
///    <li> 
///      For setting exception states: _MM_EXCEPT_INVALID, _MM_EXCEPT_DIV_ZERO,
d2421 1
a2421 3
///    </li>
///    <li>
///      For setting exception masks: _MM_MASK_UNDERFLOW, _MM_MASK_OVERFLOW,
d2425 1
a2425 3
///    </li>
///    <li>
///      For setting rounding modes: _MM_ROUND_NEAREST, _MM_ROUND_DOWN,
d2428 1
a2428 3
///    </li>
///    <li>
///      For setting flush-to-zero mode: _MM_FLUSH_ZERO_ON, _MM_FLUSH_ZERO_OFF.
d2431 1
a2431 3
///    </li>
///    <li>
///      For setting denormals-are-zero mode: _MM_DENORMALS_ZERO_ON,
a2433 2
///    </li>
///    </ul>
d2447 1
a2447 1
/// This intrinsic corresponds to the <c> VLDMXCSR / LDMXCSR </c> instruction.
d2451 5
a2455 5
void _mm_setcsr(unsigned int);

#if defined(__cplusplus)
} // extern "C"
#endif
d2466 1
a2466 1
/// This intrinsic corresponds to the <c> VSHUFPS / SHUFPS </c> instruction.
d2474 12
a2485 17
///    copy from \ a and \a b. \n
///    Bits [3:0] specify the values copied from operand \a a. \n
///    Bits [7:4] specify the values copied from operand \a b. \n
///    The destinations within the 128-bit destination are assigned values as
///    follows: \n
///    Bits [1:0] are used to assign values to bits [31:0] in the
///    destination. \n
///    Bits [3:2] are used to assign values to bits [63:32] in the
///    destination. \n
///    Bits [5:4] are used to assign values to bits [95:64] in the
///    destination. \n
///    Bits [7:6] are used to assign values to bits [127:96] in the
///    destination. \n
///    Bit value assignments: \n
///    00: Bits [31:0] copied from the specified operand. \n
///    01: Bits [63:32] copied from the specified operand. \n
///    10: Bits [95:64] copied from the specified operand. \n
d2496 2
a2497 1
///    [4 x float] and interleaves them into a 128-bit vector of [4 x float].
d2501 1
a2501 1
/// This intrinsic corresponds to the <c> VUNPCKHPS / UNPCKHPS </c> instruction.
d2504 2
a2505 2
///    A 128-bit vector of [4 x float]. \n
///    Bits [95:64] are written to bits [31:0] of the destination. \n
d2509 1
a2509 1
///    Bits [95:64] are written to bits [63:32] of the destination. \n
d2519 2
a2520 1
///    [4 x float] and interleaves them into a 128-bit vector of [4 x float].
d2524 1
a2524 1
/// This intrinsic corresponds to the <c> VUNPCKLPS / UNPCKLPS </c> instruction.
d2527 2
a2528 2
///    A 128-bit vector of [4 x float]. \n
///    Bits [31:0] are written to bits [31:0] of the destination.  \n
d2531 2
a2532 2
///    A 128-bit vector of [4 x float]. \n
///    Bits [31:0] are written to bits [63:32] of the destination. \n
d2547 1
a2547 1
/// This intrinsic corresponds to the <c> VMOVSS / MOVSS </c> instruction.
d2568 1
a2568 1
/// This intrinsic corresponds to the <c> VUNPCKHPD / UNPCKHPD </c> instruction.
d2589 1
a2589 1
/// This intrinsic corresponds to the <c> VUNPCKLPD / UNPCKLPD </c> instruction.
d2609 1
a2609 2
/// This intrinsic corresponds to the <c> CVTPI2PS + \c COMPOSITE </c>
///   instruction.
d2639 1
a2639 2
/// This intrinsic corresponds to the <c> CVTPI2PS + \c COMPOSITE </c>
///   instruction.
d2668 1
a2668 2
/// This intrinsic corresponds to the <c> CVTPI2PS + \c COMPOSITE </c>
///   instruction.
d2692 1
a2692 2
/// This intrinsic corresponds to the <c> CVTPI2PS + \c COMPOSITE </c>
///   instruction.
d2716 1
a2716 2
/// This intrinsic corresponds to the <c> CVTPI2PS + \c COMPOSITE </c>
///   instruction.
d2744 2
a2745 2
///    to 0x8000. Otherwise if the floating-point element is greater than
///    0x7FFF, it is converted to 0x7FFF.
d2749 1
a2749 2
/// This intrinsic corresponds to the <c> CVTPS2PI + \c COMPOSITE </c>
///   instruction.
d2773 2
a2774 2
///    to 0x80. Otherwise if the floating-point element is greater than 0x7F,
///    it is converted to 0x7F.
d2778 1
a2778 2
/// This intrinsic corresponds to the <c> CVTPS2PI + \c COMPOSITE </c>
///   instruction.
d2802 1
a2802 1
/// This intrinsic corresponds to the <c> VMOVMSKPS / MOVMSKPS </c> instruction.
@


