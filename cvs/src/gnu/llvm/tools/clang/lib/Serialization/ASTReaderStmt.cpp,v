head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.46.57;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.57;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.52;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.10;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===--- ASTReaderStmt.cpp - Stmt/Expr Deserialization ----------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// Statement/expression deserialization.  This implements the
// ASTReader::ReadStmt method.
//
//===----------------------------------------------------------------------===//

#include "clang/Serialization/ASTReader.h"
#include "clang/AST/ASTContext.h"
#include "clang/AST/DeclCXX.h"
#include "clang/AST/DeclTemplate.h"
#include "clang/AST/StmtVisitor.h"
#include "clang/Lex/Token.h"
#include "llvm/ADT/SmallString.h"
using namespace clang;
using namespace clang::serialization;

namespace clang {

  class ASTStmtReader : public StmtVisitor<ASTStmtReader> {
    friend class OMPClauseReader;
    typedef ASTReader::RecordData RecordData;
    
    ASTReader &Reader;
    ModuleFile &F;
    llvm::BitstreamCursor &DeclsCursor;
    const ASTReader::RecordData &Record;
    unsigned &Idx;

    Token ReadToken(const RecordData &R, unsigned &I) {
      return Reader.ReadToken(F, R, I);
    }

    SourceLocation ReadSourceLocation(const RecordData &R, unsigned &I) {
      return Reader.ReadSourceLocation(F, R, I);
    }

    SourceRange ReadSourceRange(const RecordData &R, unsigned &I) {
      return Reader.ReadSourceRange(F, R, I);
    }

    std::string ReadString(const RecordData &R, unsigned &I) {
      return Reader.ReadString(R, I);
    }
        
    TypeSourceInfo *GetTypeSourceInfo(const RecordData &R, unsigned &I) {
      return Reader.GetTypeSourceInfo(F, R, I);
    }
    
    serialization::DeclID ReadDeclID(const RecordData &R, unsigned &I) {
      return Reader.ReadDeclID(F, R, I);
    }
    
    Decl *ReadDecl(const RecordData &R, unsigned &I) {
      return Reader.ReadDecl(F, R, I);
    }
    
    template<typename T>
    T *ReadDeclAs(const RecordData &R, unsigned &I) {
      return Reader.ReadDeclAs<T>(F, R, I);
    }

    void ReadDeclarationNameLoc(DeclarationNameLoc &DNLoc, DeclarationName Name,
                                const ASTReader::RecordData &R, unsigned &I) {
      Reader.ReadDeclarationNameLoc(F, DNLoc, Name, R, I);
    }
    
    void ReadDeclarationNameInfo(DeclarationNameInfo &NameInfo,
                                const ASTReader::RecordData &R, unsigned &I) {
      Reader.ReadDeclarationNameInfo(F, NameInfo, R, I);
    }

  public:
    ASTStmtReader(ASTReader &Reader, ModuleFile &F,
                  llvm::BitstreamCursor &Cursor,
                  const ASTReader::RecordData &Record, unsigned &Idx)
      : Reader(Reader), F(F), DeclsCursor(Cursor), Record(Record), Idx(Idx) { }

    /// \brief The number of record fields required for the Stmt class
    /// itself.
    static const unsigned NumStmtFields = 0;

    /// \brief The number of record fields required for the Expr class
    /// itself.
    static const unsigned NumExprFields = NumStmtFields + 7;

    /// \brief Read and initialize a ExplicitTemplateArgumentList structure.
    void ReadTemplateKWAndArgsInfo(ASTTemplateKWAndArgsInfo &Args,
                                   TemplateArgumentLoc *ArgsLocArray,
                                   unsigned NumTemplateArgs);
    /// \brief Read and initialize a ExplicitTemplateArgumentList structure.
    void ReadExplicitTemplateArgumentList(ASTTemplateArgumentListInfo &ArgList,
                                          unsigned NumTemplateArgs);

    void VisitStmt(Stmt *S);
#define STMT(Type, Base) \
    void Visit##Type(Type *);
#include "clang/AST/StmtNodes.inc"
  };
}

void ASTStmtReader::ReadTemplateKWAndArgsInfo(ASTTemplateKWAndArgsInfo &Args,
                                              TemplateArgumentLoc *ArgsLocArray,
                                              unsigned NumTemplateArgs) {
  SourceLocation TemplateKWLoc = ReadSourceLocation(Record, Idx);
  TemplateArgumentListInfo ArgInfo;
  ArgInfo.setLAngleLoc(ReadSourceLocation(Record, Idx));
  ArgInfo.setRAngleLoc(ReadSourceLocation(Record, Idx));
  for (unsigned i = 0; i != NumTemplateArgs; ++i)
    ArgInfo.addArgument(
        Reader.ReadTemplateArgumentLoc(F, Record, Idx));
  Args.initializeFrom(TemplateKWLoc, ArgInfo, ArgsLocArray);
}

void ASTStmtReader::VisitStmt(Stmt *S) {
  assert(Idx == NumStmtFields && "Incorrect statement field count");
}

void ASTStmtReader::VisitNullStmt(NullStmt *S) {
  VisitStmt(S);
  S->setSemiLoc(ReadSourceLocation(Record, Idx));
  S->HasLeadingEmptyMacro = Record[Idx++];
}

void ASTStmtReader::VisitCompoundStmt(CompoundStmt *S) {
  VisitStmt(S);
  SmallVector<Stmt *, 16> Stmts;
  unsigned NumStmts = Record[Idx++];
  while (NumStmts--)
    Stmts.push_back(Reader.ReadSubStmt());
  S->setStmts(Reader.getContext(), Stmts);
  S->LBraceLoc = ReadSourceLocation(Record, Idx);
  S->RBraceLoc = ReadSourceLocation(Record, Idx);
}

void ASTStmtReader::VisitSwitchCase(SwitchCase *S) {
  VisitStmt(S);
  Reader.RecordSwitchCaseID(S, Record[Idx++]);
  S->setKeywordLoc(ReadSourceLocation(Record, Idx));
  S->setColonLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitCaseStmt(CaseStmt *S) {
  VisitSwitchCase(S);
  S->setLHS(Reader.ReadSubExpr());
  S->setRHS(Reader.ReadSubExpr());
  S->setSubStmt(Reader.ReadSubStmt());
  S->setEllipsisLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitDefaultStmt(DefaultStmt *S) {
  VisitSwitchCase(S);
  S->setSubStmt(Reader.ReadSubStmt());
}

void ASTStmtReader::VisitLabelStmt(LabelStmt *S) {
  VisitStmt(S);
  LabelDecl *LD = ReadDeclAs<LabelDecl>(Record, Idx);
  LD->setStmt(S);
  S->setDecl(LD);
  S->setSubStmt(Reader.ReadSubStmt());
  S->setIdentLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitAttributedStmt(AttributedStmt *S) {
  VisitStmt(S);
  uint64_t NumAttrs = Record[Idx++];
  AttrVec Attrs;
  Reader.ReadAttributes(F, Attrs, Record, Idx);
  (void)NumAttrs;
  assert(NumAttrs == S->NumAttrs);
  assert(NumAttrs == Attrs.size());
  std::copy(Attrs.begin(), Attrs.end(), S->getAttrArrayPtr());
  S->SubStmt = Reader.ReadSubStmt();
  S->AttrLoc = ReadSourceLocation(Record, Idx);
}

void ASTStmtReader::VisitIfStmt(IfStmt *S) {
  VisitStmt(S);
  S->setConditionVariable(Reader.getContext(),
                          ReadDeclAs<VarDecl>(Record, Idx));
  S->setCond(Reader.ReadSubExpr());
  S->setThen(Reader.ReadSubStmt());
  S->setElse(Reader.ReadSubStmt());
  S->setIfLoc(ReadSourceLocation(Record, Idx));
  S->setElseLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitSwitchStmt(SwitchStmt *S) {
  VisitStmt(S);
  S->setConditionVariable(Reader.getContext(),
                          ReadDeclAs<VarDecl>(Record, Idx));
  S->setCond(Reader.ReadSubExpr());
  S->setBody(Reader.ReadSubStmt());
  S->setSwitchLoc(ReadSourceLocation(Record, Idx));
  if (Record[Idx++])
    S->setAllEnumCasesCovered();

  SwitchCase *PrevSC = nullptr;
  for (unsigned N = Record.size(); Idx != N; ++Idx) {
    SwitchCase *SC = Reader.getSwitchCaseWithID(Record[Idx]);
    if (PrevSC)
      PrevSC->setNextSwitchCase(SC);
    else
      S->setSwitchCaseList(SC);

    PrevSC = SC;
  }
}

void ASTStmtReader::VisitWhileStmt(WhileStmt *S) {
  VisitStmt(S);
  S->setConditionVariable(Reader.getContext(),
                          ReadDeclAs<VarDecl>(Record, Idx));

  S->setCond(Reader.ReadSubExpr());
  S->setBody(Reader.ReadSubStmt());
  S->setWhileLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitDoStmt(DoStmt *S) {
  VisitStmt(S);
  S->setCond(Reader.ReadSubExpr());
  S->setBody(Reader.ReadSubStmt());
  S->setDoLoc(ReadSourceLocation(Record, Idx));
  S->setWhileLoc(ReadSourceLocation(Record, Idx));
  S->setRParenLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitForStmt(ForStmt *S) {
  VisitStmt(S);
  S->setInit(Reader.ReadSubStmt());
  S->setCond(Reader.ReadSubExpr());
  S->setConditionVariable(Reader.getContext(),
                          ReadDeclAs<VarDecl>(Record, Idx));
  S->setInc(Reader.ReadSubExpr());
  S->setBody(Reader.ReadSubStmt());
  S->setForLoc(ReadSourceLocation(Record, Idx));
  S->setLParenLoc(ReadSourceLocation(Record, Idx));
  S->setRParenLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitGotoStmt(GotoStmt *S) {
  VisitStmt(S);
  S->setLabel(ReadDeclAs<LabelDecl>(Record, Idx));
  S->setGotoLoc(ReadSourceLocation(Record, Idx));
  S->setLabelLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitIndirectGotoStmt(IndirectGotoStmt *S) {
  VisitStmt(S);
  S->setGotoLoc(ReadSourceLocation(Record, Idx));
  S->setStarLoc(ReadSourceLocation(Record, Idx));
  S->setTarget(Reader.ReadSubExpr());
}

void ASTStmtReader::VisitContinueStmt(ContinueStmt *S) {
  VisitStmt(S);
  S->setContinueLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitBreakStmt(BreakStmt *S) {
  VisitStmt(S);
  S->setBreakLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitReturnStmt(ReturnStmt *S) {
  VisitStmt(S);
  S->setRetValue(Reader.ReadSubExpr());
  S->setReturnLoc(ReadSourceLocation(Record, Idx));
  S->setNRVOCandidate(ReadDeclAs<VarDecl>(Record, Idx));
}

void ASTStmtReader::VisitDeclStmt(DeclStmt *S) {
  VisitStmt(S);
  S->setStartLoc(ReadSourceLocation(Record, Idx));
  S->setEndLoc(ReadSourceLocation(Record, Idx));

  if (Idx + 1 == Record.size()) {
    // Single declaration
    S->setDeclGroup(DeclGroupRef(ReadDecl(Record, Idx)));
  } else {
    SmallVector<Decl *, 16> Decls;
    Decls.reserve(Record.size() - Idx);    
    for (unsigned N = Record.size(); Idx != N; )
      Decls.push_back(ReadDecl(Record, Idx));
    S->setDeclGroup(DeclGroupRef(DeclGroup::Create(Reader.getContext(),
                                                   Decls.data(),
                                                   Decls.size())));
  }
}

void ASTStmtReader::VisitAsmStmt(AsmStmt *S) {
  VisitStmt(S);
  S->NumOutputs = Record[Idx++];
  S->NumInputs = Record[Idx++];
  S->NumClobbers = Record[Idx++];
  S->setAsmLoc(ReadSourceLocation(Record, Idx));
  S->setVolatile(Record[Idx++]);
  S->setSimple(Record[Idx++]);
}

void ASTStmtReader::VisitGCCAsmStmt(GCCAsmStmt *S) {
  VisitAsmStmt(S);
  S->setRParenLoc(ReadSourceLocation(Record, Idx));
  S->setAsmString(cast_or_null<StringLiteral>(Reader.ReadSubStmt()));

  unsigned NumOutputs = S->getNumOutputs();
  unsigned NumInputs = S->getNumInputs();
  unsigned NumClobbers = S->getNumClobbers();

  // Outputs and inputs
  SmallVector<IdentifierInfo *, 16> Names;
  SmallVector<StringLiteral*, 16> Constraints;
  SmallVector<Stmt*, 16> Exprs;
  for (unsigned I = 0, N = NumOutputs + NumInputs; I != N; ++I) {
    Names.push_back(Reader.GetIdentifierInfo(F, Record, Idx));
    Constraints.push_back(cast_or_null<StringLiteral>(Reader.ReadSubStmt()));
    Exprs.push_back(Reader.ReadSubStmt());
  }

  // Constraints
  SmallVector<StringLiteral*, 16> Clobbers;
  for (unsigned I = 0; I != NumClobbers; ++I)
    Clobbers.push_back(cast_or_null<StringLiteral>(Reader.ReadSubStmt()));

  S->setOutputsAndInputsAndClobbers(Reader.getContext(),
                                    Names.data(), Constraints.data(), 
                                    Exprs.data(), NumOutputs, NumInputs, 
                                    Clobbers.data(), NumClobbers);
}

void ASTStmtReader::VisitMSAsmStmt(MSAsmStmt *S) {
  VisitAsmStmt(S);
  S->LBraceLoc = ReadSourceLocation(Record, Idx);
  S->EndLoc = ReadSourceLocation(Record, Idx);
  S->NumAsmToks = Record[Idx++];
  std::string AsmStr = ReadString(Record, Idx);

  // Read the tokens.
  SmallVector<Token, 16> AsmToks;
  AsmToks.reserve(S->NumAsmToks);
  for (unsigned i = 0, e = S->NumAsmToks; i != e; ++i) {
    AsmToks.push_back(ReadToken(Record, Idx));
  }

  // The calls to reserve() for the FooData vectors are mandatory to
  // prevent dead StringRefs in the Foo vectors.

  // Read the clobbers.
  SmallVector<std::string, 16> ClobbersData;
  SmallVector<StringRef, 16> Clobbers;
  ClobbersData.reserve(S->NumClobbers);
  Clobbers.reserve(S->NumClobbers);
  for (unsigned i = 0, e = S->NumClobbers; i != e; ++i) {
    ClobbersData.push_back(ReadString(Record, Idx));
    Clobbers.push_back(ClobbersData.back());
  }

  // Read the operands.
  unsigned NumOperands = S->NumOutputs + S->NumInputs;
  SmallVector<Expr*, 16> Exprs;
  SmallVector<std::string, 16> ConstraintsData;
  SmallVector<StringRef, 16> Constraints;
  Exprs.reserve(NumOperands);
  ConstraintsData.reserve(NumOperands);
  Constraints.reserve(NumOperands);
  for (unsigned i = 0; i != NumOperands; ++i) {
    Exprs.push_back(cast<Expr>(Reader.ReadSubStmt()));
    ConstraintsData.push_back(ReadString(Record, Idx));
    Constraints.push_back(ConstraintsData.back());
  }

  S->initialize(Reader.getContext(), AsmStr, AsmToks,
                Constraints, Exprs, Clobbers);
}

void ASTStmtReader::VisitCoroutineBodyStmt(CoroutineBodyStmt *S) {
  // FIXME: Implement coroutine serialization.
  llvm_unreachable("unimplemented");
}

void ASTStmtReader::VisitCoreturnStmt(CoreturnStmt *S) {
  // FIXME: Implement coroutine serialization.
  llvm_unreachable("unimplemented");
}

void ASTStmtReader::VisitCoawaitExpr(CoawaitExpr *S) {
  // FIXME: Implement coroutine serialization.
  llvm_unreachable("unimplemented");
}

void ASTStmtReader::VisitCoyieldExpr(CoyieldExpr *S) {
  // FIXME: Implement coroutine serialization.
  llvm_unreachable("unimplemented");
}

void ASTStmtReader::VisitCapturedStmt(CapturedStmt *S) {
  VisitStmt(S);
  ++Idx;
  S->setCapturedDecl(ReadDeclAs<CapturedDecl>(Record, Idx));
  S->setCapturedRegionKind(static_cast<CapturedRegionKind>(Record[Idx++]));
  S->setCapturedRecordDecl(ReadDeclAs<RecordDecl>(Record, Idx));

  // Capture inits
  for (CapturedStmt::capture_init_iterator I = S->capture_init_begin(),
                                           E = S->capture_init_end();
       I != E; ++I)
    *I = Reader.ReadSubExpr();

  // Body
  S->setCapturedStmt(Reader.ReadSubStmt());
  S->getCapturedDecl()->setBody(S->getCapturedStmt());

  // Captures
  for (auto &I : S->captures()) {
    I.VarAndKind.setPointer(ReadDeclAs<VarDecl>(Record, Idx));
    I.VarAndKind
        .setInt(static_cast<CapturedStmt::VariableCaptureKind>(Record[Idx++]));
    I.Loc = ReadSourceLocation(Record, Idx);
  }
}

void ASTStmtReader::VisitExpr(Expr *E) {
  VisitStmt(E);
  E->setType(Reader.readType(F, Record, Idx));
  E->setTypeDependent(Record[Idx++]);
  E->setValueDependent(Record[Idx++]);
  E->setInstantiationDependent(Record[Idx++]);
  E->ExprBits.ContainsUnexpandedParameterPack = Record[Idx++];
  E->setValueKind(static_cast<ExprValueKind>(Record[Idx++]));
  E->setObjectKind(static_cast<ExprObjectKind>(Record[Idx++]));
  assert(Idx == NumExprFields && "Incorrect expression field count");
}

void ASTStmtReader::VisitPredefinedExpr(PredefinedExpr *E) {
  VisitExpr(E);
  E->setLocation(ReadSourceLocation(Record, Idx));
  E->Type = (PredefinedExpr::IdentType)Record[Idx++];
  E->FnName = cast_or_null<StringLiteral>(Reader.ReadSubExpr());
}

void ASTStmtReader::VisitDeclRefExpr(DeclRefExpr *E) {
  VisitExpr(E);

  E->DeclRefExprBits.HasQualifier = Record[Idx++];
  E->DeclRefExprBits.HasFoundDecl = Record[Idx++];
  E->DeclRefExprBits.HasTemplateKWAndArgsInfo = Record[Idx++];
  E->DeclRefExprBits.HadMultipleCandidates = Record[Idx++];
  E->DeclRefExprBits.RefersToEnclosingVariableOrCapture = Record[Idx++];
  unsigned NumTemplateArgs = 0;
  if (E->hasTemplateKWAndArgsInfo())
    NumTemplateArgs = Record[Idx++];

  if (E->hasQualifier())
    new (E->getTrailingObjects<NestedNameSpecifierLoc>())
        NestedNameSpecifierLoc(
            Reader.ReadNestedNameSpecifierLoc(F, Record, Idx));

  if (E->hasFoundDecl())
    *E->getTrailingObjects<NamedDecl *>() = ReadDeclAs<NamedDecl>(Record, Idx);

  if (E->hasTemplateKWAndArgsInfo())
    ReadTemplateKWAndArgsInfo(
        *E->getTrailingObjects<ASTTemplateKWAndArgsInfo>(),
        E->getTrailingObjects<TemplateArgumentLoc>(), NumTemplateArgs);

  E->setDecl(ReadDeclAs<ValueDecl>(Record, Idx));
  E->setLocation(ReadSourceLocation(Record, Idx));
  ReadDeclarationNameLoc(E->DNLoc, E->getDecl()->getDeclName(), Record, Idx);
}

void ASTStmtReader::VisitIntegerLiteral(IntegerLiteral *E) {
  VisitExpr(E);
  E->setLocation(ReadSourceLocation(Record, Idx));
  E->setValue(Reader.getContext(), Reader.ReadAPInt(Record, Idx));
}

void ASTStmtReader::VisitFloatingLiteral(FloatingLiteral *E) {
  VisitExpr(E);
  E->setRawSemantics(static_cast<Stmt::APFloatSemantics>(Record[Idx++]));
  E->setExact(Record[Idx++]);
  E->setValue(Reader.getContext(),
              Reader.ReadAPFloat(Record, E->getSemantics(), Idx));
  E->setLocation(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitImaginaryLiteral(ImaginaryLiteral *E) {
  VisitExpr(E);
  E->setSubExpr(Reader.ReadSubExpr());
}

void ASTStmtReader::VisitStringLiteral(StringLiteral *E) {
  VisitExpr(E);
  unsigned Len = Record[Idx++];
  assert(Record[Idx] == E->getNumConcatenated() &&
         "Wrong number of concatenated tokens!");
  ++Idx;
  StringLiteral::StringKind kind =
        static_cast<StringLiteral::StringKind>(Record[Idx++]);
  bool isPascal = Record[Idx++];

  // Read string data
  SmallString<16> Str(&Record[Idx], &Record[Idx] + Len);
  E->setString(Reader.getContext(), Str, kind, isPascal);
  Idx += Len;

  // Read source locations
  for (unsigned I = 0, N = E->getNumConcatenated(); I != N; ++I)
    E->setStrTokenLoc(I, ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitCharacterLiteral(CharacterLiteral *E) {
  VisitExpr(E);
  E->setValue(Record[Idx++]);
  E->setLocation(ReadSourceLocation(Record, Idx));
  E->setKind(static_cast<CharacterLiteral::CharacterKind>(Record[Idx++]));
}

void ASTStmtReader::VisitParenExpr(ParenExpr *E) {
  VisitExpr(E);
  E->setLParen(ReadSourceLocation(Record, Idx));
  E->setRParen(ReadSourceLocation(Record, Idx));
  E->setSubExpr(Reader.ReadSubExpr());
}

void ASTStmtReader::VisitParenListExpr(ParenListExpr *E) {
  VisitExpr(E);
  unsigned NumExprs = Record[Idx++];
  E->Exprs = new (Reader.getContext()) Stmt*[NumExprs];
  for (unsigned i = 0; i != NumExprs; ++i)
    E->Exprs[i] = Reader.ReadSubStmt();
  E->NumExprs = NumExprs;
  E->LParenLoc = ReadSourceLocation(Record, Idx);
  E->RParenLoc = ReadSourceLocation(Record, Idx);
}

void ASTStmtReader::VisitUnaryOperator(UnaryOperator *E) {
  VisitExpr(E);
  E->setSubExpr(Reader.ReadSubExpr());
  E->setOpcode((UnaryOperator::Opcode)Record[Idx++]);
  E->setOperatorLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitOffsetOfExpr(OffsetOfExpr *E) {
  VisitExpr(E);
  assert(E->getNumComponents() == Record[Idx]);
  ++Idx;
  assert(E->getNumExpressions() == Record[Idx]);
  ++Idx;
  E->setOperatorLoc(ReadSourceLocation(Record, Idx));
  E->setRParenLoc(ReadSourceLocation(Record, Idx));
  E->setTypeSourceInfo(GetTypeSourceInfo(Record, Idx));
  for (unsigned I = 0, N = E->getNumComponents(); I != N; ++I) {
    OffsetOfNode::Kind Kind = static_cast<OffsetOfNode::Kind>(Record[Idx++]);
    SourceLocation Start = ReadSourceLocation(Record, Idx);
    SourceLocation End = ReadSourceLocation(Record, Idx);
    switch (Kind) {
    case OffsetOfNode::Array:
      E->setComponent(I, OffsetOfNode(Start, Record[Idx++], End));
      break;

    case OffsetOfNode::Field:
      E->setComponent(
          I, OffsetOfNode(Start, ReadDeclAs<FieldDecl>(Record, Idx), End));
      break;

    case OffsetOfNode::Identifier:
      E->setComponent(
          I,
          OffsetOfNode(Start, Reader.GetIdentifierInfo(F, Record, Idx), End));
      break;

    case OffsetOfNode::Base: {
      CXXBaseSpecifier *Base = new (Reader.getContext()) CXXBaseSpecifier();
      *Base = Reader.ReadCXXBaseSpecifier(F, Record, Idx);
      E->setComponent(I, OffsetOfNode(Base));
      break;
    }
    }
  }
  
  for (unsigned I = 0, N = E->getNumExpressions(); I != N; ++I)
    E->setIndexExpr(I, Reader.ReadSubExpr());
}

void ASTStmtReader::VisitUnaryExprOrTypeTraitExpr(UnaryExprOrTypeTraitExpr *E) {
  VisitExpr(E);
  E->setKind(static_cast<UnaryExprOrTypeTrait>(Record[Idx++]));
  if (Record[Idx] == 0) {
    E->setArgument(Reader.ReadSubExpr());
    ++Idx;
  } else {
    E->setArgument(GetTypeSourceInfo(Record, Idx));
  }
  E->setOperatorLoc(ReadSourceLocation(Record, Idx));
  E->setRParenLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitArraySubscriptExpr(ArraySubscriptExpr *E) {
  VisitExpr(E);
  E->setLHS(Reader.ReadSubExpr());
  E->setRHS(Reader.ReadSubExpr());
  E->setRBracketLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitOMPArraySectionExpr(OMPArraySectionExpr *E) {
  VisitExpr(E);
  E->setBase(Reader.ReadSubExpr());
  E->setLowerBound(Reader.ReadSubExpr());
  E->setLength(Reader.ReadSubExpr());
  E->setColonLoc(ReadSourceLocation(Record, Idx));
  E->setRBracketLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitCallExpr(CallExpr *E) {
  VisitExpr(E);
  E->setNumArgs(Reader.getContext(), Record[Idx++]);
  E->setRParenLoc(ReadSourceLocation(Record, Idx));
  E->setCallee(Reader.ReadSubExpr());
  for (unsigned I = 0, N = E->getNumArgs(); I != N; ++I)
    E->setArg(I, Reader.ReadSubExpr());
}

void ASTStmtReader::VisitCXXMemberCallExpr(CXXMemberCallExpr *E) {
  VisitCallExpr(E);
}

void ASTStmtReader::VisitMemberExpr(MemberExpr *E) {
  // Don't call VisitExpr, this is fully initialized at creation.
  assert(E->getStmtClass() == Stmt::MemberExprClass &&
         "It's a subclass, we must advance Idx!");
}

void ASTStmtReader::VisitObjCIsaExpr(ObjCIsaExpr *E) {
  VisitExpr(E);
  E->setBase(Reader.ReadSubExpr());
  E->setIsaMemberLoc(ReadSourceLocation(Record, Idx));
  E->setOpLoc(ReadSourceLocation(Record, Idx));
  E->setArrow(Record[Idx++]);
}

void ASTStmtReader::
VisitObjCIndirectCopyRestoreExpr(ObjCIndirectCopyRestoreExpr *E) {
  VisitExpr(E);
  E->Operand = Reader.ReadSubExpr();
  E->setShouldCopy(Record[Idx++]);
}

void ASTStmtReader::VisitObjCBridgedCastExpr(ObjCBridgedCastExpr *E) {
  VisitExplicitCastExpr(E);
  E->LParenLoc = ReadSourceLocation(Record, Idx);
  E->BridgeKeywordLoc = ReadSourceLocation(Record, Idx);
  E->Kind = Record[Idx++];
}

void ASTStmtReader::VisitCastExpr(CastExpr *E) {
  VisitExpr(E);
  unsigned NumBaseSpecs = Record[Idx++];
  assert(NumBaseSpecs == E->path_size());
  E->setSubExpr(Reader.ReadSubExpr());
  E->setCastKind((CastKind)Record[Idx++]);
  CastExpr::path_iterator BaseI = E->path_begin();
  while (NumBaseSpecs--) {
    CXXBaseSpecifier *BaseSpec = new (Reader.getContext()) CXXBaseSpecifier;
    *BaseSpec = Reader.ReadCXXBaseSpecifier(F, Record, Idx);
    *BaseI++ = BaseSpec;
  }
}

void ASTStmtReader::VisitBinaryOperator(BinaryOperator *E) {
  VisitExpr(E);
  E->setLHS(Reader.ReadSubExpr());
  E->setRHS(Reader.ReadSubExpr());
  E->setOpcode((BinaryOperator::Opcode)Record[Idx++]);
  E->setOperatorLoc(ReadSourceLocation(Record, Idx));
  E->setFPContractable((bool)Record[Idx++]);
}

void ASTStmtReader::VisitCompoundAssignOperator(CompoundAssignOperator *E) {
  VisitBinaryOperator(E);
  E->setComputationLHSType(Reader.readType(F, Record, Idx));
  E->setComputationResultType(Reader.readType(F, Record, Idx));
}

void ASTStmtReader::VisitConditionalOperator(ConditionalOperator *E) {
  VisitExpr(E);
  E->SubExprs[ConditionalOperator::COND] = Reader.ReadSubExpr();
  E->SubExprs[ConditionalOperator::LHS] = Reader.ReadSubExpr();
  E->SubExprs[ConditionalOperator::RHS] = Reader.ReadSubExpr();
  E->QuestionLoc = ReadSourceLocation(Record, Idx);
  E->ColonLoc = ReadSourceLocation(Record, Idx);
}

void
ASTStmtReader::VisitBinaryConditionalOperator(BinaryConditionalOperator *E) {
  VisitExpr(E);
  E->OpaqueValue = cast<OpaqueValueExpr>(Reader.ReadSubExpr());
  E->SubExprs[BinaryConditionalOperator::COMMON] = Reader.ReadSubExpr();
  E->SubExprs[BinaryConditionalOperator::COND] = Reader.ReadSubExpr();
  E->SubExprs[BinaryConditionalOperator::LHS] = Reader.ReadSubExpr();
  E->SubExprs[BinaryConditionalOperator::RHS] = Reader.ReadSubExpr();
  E->QuestionLoc = ReadSourceLocation(Record, Idx);
  E->ColonLoc = ReadSourceLocation(Record, Idx);
}

void ASTStmtReader::VisitImplicitCastExpr(ImplicitCastExpr *E) {
  VisitCastExpr(E);
}

void ASTStmtReader::VisitExplicitCastExpr(ExplicitCastExpr *E) {
  VisitCastExpr(E);
  E->setTypeInfoAsWritten(GetTypeSourceInfo(Record, Idx));
}

void ASTStmtReader::VisitCStyleCastExpr(CStyleCastExpr *E) {
  VisitExplicitCastExpr(E);
  E->setLParenLoc(ReadSourceLocation(Record, Idx));
  E->setRParenLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitCompoundLiteralExpr(CompoundLiteralExpr *E) {
  VisitExpr(E);
  E->setLParenLoc(ReadSourceLocation(Record, Idx));
  E->setTypeSourceInfo(GetTypeSourceInfo(Record, Idx));
  E->setInitializer(Reader.ReadSubExpr());
  E->setFileScope(Record[Idx++]);
}

void ASTStmtReader::VisitExtVectorElementExpr(ExtVectorElementExpr *E) {
  VisitExpr(E);
  E->setBase(Reader.ReadSubExpr());
  E->setAccessor(Reader.GetIdentifierInfo(F, Record, Idx));
  E->setAccessorLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitInitListExpr(InitListExpr *E) {
  VisitExpr(E);
  if (InitListExpr *SyntForm = cast_or_null<InitListExpr>(Reader.ReadSubStmt()))
    E->setSyntacticForm(SyntForm);
  E->setLBraceLoc(ReadSourceLocation(Record, Idx));
  E->setRBraceLoc(ReadSourceLocation(Record, Idx));
  bool isArrayFiller = Record[Idx++];
  Expr *filler = nullptr;
  if (isArrayFiller) {
    filler = Reader.ReadSubExpr();
    E->ArrayFillerOrUnionFieldInit = filler;
  } else
    E->ArrayFillerOrUnionFieldInit = ReadDeclAs<FieldDecl>(Record, Idx);
  E->sawArrayRangeDesignator(Record[Idx++]);
  unsigned NumInits = Record[Idx++];
  E->reserveInits(Reader.getContext(), NumInits);
  if (isArrayFiller) {
    for (unsigned I = 0; I != NumInits; ++I) {
      Expr *init = Reader.ReadSubExpr();
      E->updateInit(Reader.getContext(), I, init ? init : filler);
    }
  } else {
    for (unsigned I = 0; I != NumInits; ++I)
      E->updateInit(Reader.getContext(), I, Reader.ReadSubExpr());
  }
}

void ASTStmtReader::VisitDesignatedInitExpr(DesignatedInitExpr *E) {
  typedef DesignatedInitExpr::Designator Designator;

  VisitExpr(E);
  unsigned NumSubExprs = Record[Idx++];
  assert(NumSubExprs == E->getNumSubExprs() && "Wrong number of subexprs");
  for (unsigned I = 0; I != NumSubExprs; ++I)
    E->setSubExpr(I, Reader.ReadSubExpr());
  E->setEqualOrColonLoc(ReadSourceLocation(Record, Idx));
  E->setGNUSyntax(Record[Idx++]);

  SmallVector<Designator, 4> Designators;
  while (Idx < Record.size()) {
    switch ((DesignatorTypes)Record[Idx++]) {
    case DESIG_FIELD_DECL: {
      FieldDecl *Field = ReadDeclAs<FieldDecl>(Record, Idx);
      SourceLocation DotLoc
        = ReadSourceLocation(Record, Idx);
      SourceLocation FieldLoc
        = ReadSourceLocation(Record, Idx);
      Designators.push_back(Designator(Field->getIdentifier(), DotLoc,
                                       FieldLoc));
      Designators.back().setField(Field);
      break;
    }

    case DESIG_FIELD_NAME: {
      const IdentifierInfo *Name = Reader.GetIdentifierInfo(F, Record, Idx);
      SourceLocation DotLoc
        = ReadSourceLocation(Record, Idx);
      SourceLocation FieldLoc
        = ReadSourceLocation(Record, Idx);
      Designators.push_back(Designator(Name, DotLoc, FieldLoc));
      break;
    }

    case DESIG_ARRAY: {
      unsigned Index = Record[Idx++];
      SourceLocation LBracketLoc
        = ReadSourceLocation(Record, Idx);
      SourceLocation RBracketLoc
        = ReadSourceLocation(Record, Idx);
      Designators.push_back(Designator(Index, LBracketLoc, RBracketLoc));
      break;
    }

    case DESIG_ARRAY_RANGE: {
      unsigned Index = Record[Idx++];
      SourceLocation LBracketLoc
        = ReadSourceLocation(Record, Idx);
      SourceLocation EllipsisLoc
        = ReadSourceLocation(Record, Idx);
      SourceLocation RBracketLoc
        = ReadSourceLocation(Record, Idx);
      Designators.push_back(Designator(Index, LBracketLoc, EllipsisLoc,
                                       RBracketLoc));
      break;
    }
    }
  }
  E->setDesignators(Reader.getContext(), 
                    Designators.data(), Designators.size());
}

void ASTStmtReader::VisitDesignatedInitUpdateExpr(DesignatedInitUpdateExpr *E) {
  VisitExpr(E);
  E->setBase(Reader.ReadSubExpr());
  E->setUpdater(Reader.ReadSubExpr());
}

void ASTStmtReader::VisitNoInitExpr(NoInitExpr *E) {
  VisitExpr(E);
}

void ASTStmtReader::VisitImplicitValueInitExpr(ImplicitValueInitExpr *E) {
  VisitExpr(E);
}

void ASTStmtReader::VisitVAArgExpr(VAArgExpr *E) {
  VisitExpr(E);
  E->setSubExpr(Reader.ReadSubExpr());
  E->setWrittenTypeInfo(GetTypeSourceInfo(Record, Idx));
  E->setBuiltinLoc(ReadSourceLocation(Record, Idx));
  E->setRParenLoc(ReadSourceLocation(Record, Idx));
  E->setIsMicrosoftABI(Record[Idx++]);
}

void ASTStmtReader::VisitAddrLabelExpr(AddrLabelExpr *E) {
  VisitExpr(E);
  E->setAmpAmpLoc(ReadSourceLocation(Record, Idx));
  E->setLabelLoc(ReadSourceLocation(Record, Idx));
  E->setLabel(ReadDeclAs<LabelDecl>(Record, Idx));
}

void ASTStmtReader::VisitStmtExpr(StmtExpr *E) {
  VisitExpr(E);
  E->setLParenLoc(ReadSourceLocation(Record, Idx));
  E->setRParenLoc(ReadSourceLocation(Record, Idx));
  E->setSubStmt(cast_or_null<CompoundStmt>(Reader.ReadSubStmt()));
}

void ASTStmtReader::VisitChooseExpr(ChooseExpr *E) {
  VisitExpr(E);
  E->setCond(Reader.ReadSubExpr());
  E->setLHS(Reader.ReadSubExpr());
  E->setRHS(Reader.ReadSubExpr());
  E->setBuiltinLoc(ReadSourceLocation(Record, Idx));
  E->setRParenLoc(ReadSourceLocation(Record, Idx));
  E->setIsConditionTrue(Record[Idx++]);
}

void ASTStmtReader::VisitGNUNullExpr(GNUNullExpr *E) {
  VisitExpr(E);
  E->setTokenLocation(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitShuffleVectorExpr(ShuffleVectorExpr *E) {
  VisitExpr(E);
  SmallVector<Expr *, 16> Exprs;
  unsigned NumExprs = Record[Idx++];
  while (NumExprs--)
    Exprs.push_back(Reader.ReadSubExpr());
  E->setExprs(Reader.getContext(), Exprs);
  E->setBuiltinLoc(ReadSourceLocation(Record, Idx));
  E->setRParenLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitConvertVectorExpr(ConvertVectorExpr *E) {
  VisitExpr(E);
  E->BuiltinLoc = ReadSourceLocation(Record, Idx);
  E->RParenLoc = ReadSourceLocation(Record, Idx);
  E->TInfo = GetTypeSourceInfo(Record, Idx);
  E->SrcExpr = Reader.ReadSubExpr();
}

void ASTStmtReader::VisitBlockExpr(BlockExpr *E) {
  VisitExpr(E);
  E->setBlockDecl(ReadDeclAs<BlockDecl>(Record, Idx));
}

void ASTStmtReader::VisitGenericSelectionExpr(GenericSelectionExpr *E) {
  VisitExpr(E);
  E->NumAssocs = Record[Idx++];
  E->AssocTypes = new (Reader.getContext()) TypeSourceInfo*[E->NumAssocs];
  E->SubExprs =
   new(Reader.getContext()) Stmt*[GenericSelectionExpr::END_EXPR+E->NumAssocs];

  E->SubExprs[GenericSelectionExpr::CONTROLLING] = Reader.ReadSubExpr();
  for (unsigned I = 0, N = E->getNumAssocs(); I != N; ++I) {
    E->AssocTypes[I] = GetTypeSourceInfo(Record, Idx);
    E->SubExprs[GenericSelectionExpr::END_EXPR+I] = Reader.ReadSubExpr();
  }
  E->ResultIndex = Record[Idx++];

  E->GenericLoc = ReadSourceLocation(Record, Idx);
  E->DefaultLoc = ReadSourceLocation(Record, Idx);
  E->RParenLoc = ReadSourceLocation(Record, Idx);
}

void ASTStmtReader::VisitPseudoObjectExpr(PseudoObjectExpr *E) {
  VisitExpr(E);
  unsigned numSemanticExprs = Record[Idx++];
  assert(numSemanticExprs + 1 == E->PseudoObjectExprBits.NumSubExprs);
  E->PseudoObjectExprBits.ResultIndex = Record[Idx++];

  // Read the syntactic expression.
  E->getSubExprsBuffer()[0] = Reader.ReadSubExpr();

  // Read all the semantic expressions.
  for (unsigned i = 0; i != numSemanticExprs; ++i) {
    Expr *subExpr = Reader.ReadSubExpr();
    E->getSubExprsBuffer()[i+1] = subExpr;
  }
}

void ASTStmtReader::VisitAtomicExpr(AtomicExpr *E) {
  VisitExpr(E);
  E->Op = AtomicExpr::AtomicOp(Record[Idx++]);
  E->NumSubExprs = AtomicExpr::getNumSubExprs(E->Op);
  for (unsigned I = 0; I != E->NumSubExprs; ++I)
    E->SubExprs[I] = Reader.ReadSubExpr();
  E->BuiltinLoc = ReadSourceLocation(Record, Idx);
  E->RParenLoc = ReadSourceLocation(Record, Idx);
}

//===----------------------------------------------------------------------===//
// Objective-C Expressions and Statements

void ASTStmtReader::VisitObjCStringLiteral(ObjCStringLiteral *E) {
  VisitExpr(E);
  E->setString(cast<StringLiteral>(Reader.ReadSubStmt()));
  E->setAtLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitObjCBoxedExpr(ObjCBoxedExpr *E) {
  VisitExpr(E);
  // could be one of several IntegerLiteral, FloatLiteral, etc.
  E->SubExpr = Reader.ReadSubStmt();
  E->BoxingMethod = ReadDeclAs<ObjCMethodDecl>(Record, Idx);
  E->Range = ReadSourceRange(Record, Idx);
}

void ASTStmtReader::VisitObjCArrayLiteral(ObjCArrayLiteral *E) {
  VisitExpr(E);
  unsigned NumElements = Record[Idx++];
  assert(NumElements == E->getNumElements() && "Wrong number of elements");
  Expr **Elements = E->getElements();
  for (unsigned I = 0, N = NumElements; I != N; ++I)
    Elements[I] = Reader.ReadSubExpr();
  E->ArrayWithObjectsMethod = ReadDeclAs<ObjCMethodDecl>(Record, Idx);
  E->Range = ReadSourceRange(Record, Idx);
}

void ASTStmtReader::VisitObjCDictionaryLiteral(ObjCDictionaryLiteral *E) {
  VisitExpr(E);
  unsigned NumElements = Record[Idx++];
  assert(NumElements == E->getNumElements() && "Wrong number of elements");
  bool HasPackExpansions = Record[Idx++];
  assert(HasPackExpansions == E->HasPackExpansions &&"Pack expansion mismatch");
  ObjCDictionaryLiteral::KeyValuePair *KeyValues =
      E->getTrailingObjects<ObjCDictionaryLiteral::KeyValuePair>();
  ObjCDictionaryLiteral::ExpansionData *Expansions =
      E->getTrailingObjects<ObjCDictionaryLiteral::ExpansionData>();
  for (unsigned I = 0; I != NumElements; ++I) {
    KeyValues[I].Key = Reader.ReadSubExpr();
    KeyValues[I].Value = Reader.ReadSubExpr();
    if (HasPackExpansions) {
      Expansions[I].EllipsisLoc = ReadSourceLocation(Record, Idx);
      Expansions[I].NumExpansionsPlusOne = Record[Idx++];
    }
  }
  E->DictWithObjectsMethod = ReadDeclAs<ObjCMethodDecl>(Record, Idx);
  E->Range = ReadSourceRange(Record, Idx);
}

void ASTStmtReader::VisitObjCEncodeExpr(ObjCEncodeExpr *E) {
  VisitExpr(E);
  E->setEncodedTypeSourceInfo(GetTypeSourceInfo(Record, Idx));
  E->setAtLoc(ReadSourceLocation(Record, Idx));
  E->setRParenLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitObjCSelectorExpr(ObjCSelectorExpr *E) {
  VisitExpr(E);
  E->setSelector(Reader.ReadSelector(F, Record, Idx));
  E->setAtLoc(ReadSourceLocation(Record, Idx));
  E->setRParenLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitObjCProtocolExpr(ObjCProtocolExpr *E) {
  VisitExpr(E);
  E->setProtocol(ReadDeclAs<ObjCProtocolDecl>(Record, Idx));
  E->setAtLoc(ReadSourceLocation(Record, Idx));
  E->ProtoLoc = ReadSourceLocation(Record, Idx);
  E->setRParenLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitObjCIvarRefExpr(ObjCIvarRefExpr *E) {
  VisitExpr(E);
  E->setDecl(ReadDeclAs<ObjCIvarDecl>(Record, Idx));
  E->setLocation(ReadSourceLocation(Record, Idx));
  E->setOpLoc(ReadSourceLocation(Record, Idx));
  E->setBase(Reader.ReadSubExpr());
  E->setIsArrow(Record[Idx++]);
  E->setIsFreeIvar(Record[Idx++]);
}

void ASTStmtReader::VisitObjCPropertyRefExpr(ObjCPropertyRefExpr *E) {
  VisitExpr(E);
  unsigned MethodRefFlags = Record[Idx++];
  bool Implicit = Record[Idx++] != 0;
  if (Implicit) {
    ObjCMethodDecl *Getter = ReadDeclAs<ObjCMethodDecl>(Record, Idx);
    ObjCMethodDecl *Setter = ReadDeclAs<ObjCMethodDecl>(Record, Idx);
    E->setImplicitProperty(Getter, Setter, MethodRefFlags);
  } else {
    E->setExplicitProperty(ReadDeclAs<ObjCPropertyDecl>(Record, Idx),
                           MethodRefFlags);
  }
  E->setLocation(ReadSourceLocation(Record, Idx));
  E->setReceiverLocation(ReadSourceLocation(Record, Idx));
  switch (Record[Idx++]) {
  case 0:
    E->setBase(Reader.ReadSubExpr());
    break;
  case 1:
    E->setSuperReceiver(Reader.readType(F, Record, Idx));
    break;
  case 2:
    E->setClassReceiver(ReadDeclAs<ObjCInterfaceDecl>(Record, Idx));
    break;
  }
}

void ASTStmtReader::VisitObjCSubscriptRefExpr(ObjCSubscriptRefExpr *E) {
  VisitExpr(E);
  E->setRBracket(ReadSourceLocation(Record, Idx));
  E->setBaseExpr(Reader.ReadSubExpr());
  E->setKeyExpr(Reader.ReadSubExpr());
  E->GetAtIndexMethodDecl = ReadDeclAs<ObjCMethodDecl>(Record, Idx);
  E->SetAtIndexMethodDecl = ReadDeclAs<ObjCMethodDecl>(Record, Idx);
}

void ASTStmtReader::VisitObjCMessageExpr(ObjCMessageExpr *E) {
  VisitExpr(E);
  assert(Record[Idx] == E->getNumArgs());
  ++Idx;
  unsigned NumStoredSelLocs = Record[Idx++];
  E->SelLocsKind = Record[Idx++]; 
  E->setDelegateInitCall(Record[Idx++]);
  E->IsImplicit = Record[Idx++];
  ObjCMessageExpr::ReceiverKind Kind
    = static_cast<ObjCMessageExpr::ReceiverKind>(Record[Idx++]);
  switch (Kind) {
  case ObjCMessageExpr::Instance:
    E->setInstanceReceiver(Reader.ReadSubExpr());
    break;

  case ObjCMessageExpr::Class:
    E->setClassReceiver(GetTypeSourceInfo(Record, Idx));
    break;

  case ObjCMessageExpr::SuperClass:
  case ObjCMessageExpr::SuperInstance: {
    QualType T = Reader.readType(F, Record, Idx);
    SourceLocation SuperLoc = ReadSourceLocation(Record, Idx);
    E->setSuper(SuperLoc, T, Kind == ObjCMessageExpr::SuperInstance);
    break;
  }
  }

  assert(Kind == E->getReceiverKind());

  if (Record[Idx++])
    E->setMethodDecl(ReadDeclAs<ObjCMethodDecl>(Record, Idx));
  else
    E->setSelector(Reader.ReadSelector(F, Record, Idx));

  E->LBracLoc = ReadSourceLocation(Record, Idx);
  E->RBracLoc = ReadSourceLocation(Record, Idx);

  for (unsigned I = 0, N = E->getNumArgs(); I != N; ++I)
    E->setArg(I, Reader.ReadSubExpr());

  SourceLocation *Locs = E->getStoredSelLocs();
  for (unsigned I = 0; I != NumStoredSelLocs; ++I)
    Locs[I] = ReadSourceLocation(Record, Idx);
}

void ASTStmtReader::VisitObjCForCollectionStmt(ObjCForCollectionStmt *S) {
  VisitStmt(S);
  S->setElement(Reader.ReadSubStmt());
  S->setCollection(Reader.ReadSubExpr());
  S->setBody(Reader.ReadSubStmt());
  S->setForLoc(ReadSourceLocation(Record, Idx));
  S->setRParenLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitObjCAtCatchStmt(ObjCAtCatchStmt *S) {
  VisitStmt(S);
  S->setCatchBody(Reader.ReadSubStmt());
  S->setCatchParamDecl(ReadDeclAs<VarDecl>(Record, Idx));
  S->setAtCatchLoc(ReadSourceLocation(Record, Idx));
  S->setRParenLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitObjCAtFinallyStmt(ObjCAtFinallyStmt *S) {
  VisitStmt(S);
  S->setFinallyBody(Reader.ReadSubStmt());
  S->setAtFinallyLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitObjCAutoreleasePoolStmt(ObjCAutoreleasePoolStmt *S) {
  VisitStmt(S);
  S->setSubStmt(Reader.ReadSubStmt());
  S->setAtLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitObjCAtTryStmt(ObjCAtTryStmt *S) {
  VisitStmt(S);
  assert(Record[Idx] == S->getNumCatchStmts());
  ++Idx;
  bool HasFinally = Record[Idx++];
  S->setTryBody(Reader.ReadSubStmt());
  for (unsigned I = 0, N = S->getNumCatchStmts(); I != N; ++I)
    S->setCatchStmt(I, cast_or_null<ObjCAtCatchStmt>(Reader.ReadSubStmt()));

  if (HasFinally)
    S->setFinallyStmt(Reader.ReadSubStmt());
  S->setAtTryLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitObjCAtSynchronizedStmt(ObjCAtSynchronizedStmt *S) {
  VisitStmt(S);
  S->setSynchExpr(Reader.ReadSubStmt());
  S->setSynchBody(Reader.ReadSubStmt());
  S->setAtSynchronizedLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitObjCAtThrowStmt(ObjCAtThrowStmt *S) {
  VisitStmt(S);
  S->setThrowExpr(Reader.ReadSubStmt());
  S->setThrowLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitObjCBoolLiteralExpr(ObjCBoolLiteralExpr *E) {
  VisitExpr(E);
  E->setValue(Record[Idx++]);
  E->setLocation(ReadSourceLocation(Record, Idx));
}

//===----------------------------------------------------------------------===//
// C++ Expressions and Statements
//===----------------------------------------------------------------------===//

void ASTStmtReader::VisitCXXCatchStmt(CXXCatchStmt *S) {
  VisitStmt(S);
  S->CatchLoc = ReadSourceLocation(Record, Idx);
  S->ExceptionDecl = ReadDeclAs<VarDecl>(Record, Idx);
  S->HandlerBlock = Reader.ReadSubStmt();
}

void ASTStmtReader::VisitCXXTryStmt(CXXTryStmt *S) {
  VisitStmt(S);
  assert(Record[Idx] == S->getNumHandlers() && "NumStmtFields is wrong ?");
  ++Idx;
  S->TryLoc = ReadSourceLocation(Record, Idx);
  S->getStmts()[0] = Reader.ReadSubStmt();
  for (unsigned i = 0, e = S->getNumHandlers(); i != e; ++i)
    S->getStmts()[i + 1] = Reader.ReadSubStmt();
}

void ASTStmtReader::VisitCXXForRangeStmt(CXXForRangeStmt *S) {
  VisitStmt(S);
  S->ForLoc = ReadSourceLocation(Record, Idx);
  S->CoawaitLoc = ReadSourceLocation(Record, Idx);
  S->ColonLoc = ReadSourceLocation(Record, Idx);
  S->RParenLoc = ReadSourceLocation(Record, Idx);
  S->setRangeStmt(Reader.ReadSubStmt());
  S->setBeginEndStmt(Reader.ReadSubStmt());
  S->setCond(Reader.ReadSubExpr());
  S->setInc(Reader.ReadSubExpr());
  S->setLoopVarStmt(Reader.ReadSubStmt());
  S->setBody(Reader.ReadSubStmt());
}

void ASTStmtReader::VisitMSDependentExistsStmt(MSDependentExistsStmt *S) {
  VisitStmt(S);
  S->KeywordLoc = ReadSourceLocation(Record, Idx);
  S->IsIfExists = Record[Idx++];
  S->QualifierLoc = Reader.ReadNestedNameSpecifierLoc(F, Record, Idx);
  ReadDeclarationNameInfo(S->NameInfo, Record, Idx);
  S->SubStmt = Reader.ReadSubStmt();
}

void ASTStmtReader::VisitCXXOperatorCallExpr(CXXOperatorCallExpr *E) {
  VisitCallExpr(E);
  E->Operator = (OverloadedOperatorKind)Record[Idx++];
  E->Range = Reader.ReadSourceRange(F, Record, Idx);
  E->setFPContractable((bool)Record[Idx++]);
}

void ASTStmtReader::VisitCXXConstructExpr(CXXConstructExpr *E) {
  VisitExpr(E);
  E->NumArgs = Record[Idx++];
  if (E->NumArgs)
    E->Args = new (Reader.getContext()) Stmt*[E->NumArgs];
  for (unsigned I = 0, N = E->getNumArgs(); I != N; ++I)
    E->setArg(I, Reader.ReadSubExpr());
  E->setConstructor(ReadDeclAs<CXXConstructorDecl>(Record, Idx));
  E->setLocation(ReadSourceLocation(Record, Idx));
  E->setElidable(Record[Idx++]);
  E->setHadMultipleCandidates(Record[Idx++]);
  E->setListInitialization(Record[Idx++]);
  E->setStdInitListInitialization(Record[Idx++]);
  E->setRequiresZeroInitialization(Record[Idx++]);
  E->setConstructionKind((CXXConstructExpr::ConstructionKind)Record[Idx++]);
  E->ParenOrBraceRange = ReadSourceRange(Record, Idx);
}

void ASTStmtReader::VisitCXXTemporaryObjectExpr(CXXTemporaryObjectExpr *E) {
  VisitCXXConstructExpr(E);
  E->Type = GetTypeSourceInfo(Record, Idx);
}

void ASTStmtReader::VisitLambdaExpr(LambdaExpr *E) {
  VisitExpr(E);
  unsigned NumCaptures = Record[Idx++];
  assert(NumCaptures == E->NumCaptures);(void)NumCaptures;
  unsigned NumArrayIndexVars = Record[Idx++];
  E->IntroducerRange = ReadSourceRange(Record, Idx);
  E->CaptureDefault = static_cast<LambdaCaptureDefault>(Record[Idx++]);
  E->CaptureDefaultLoc = ReadSourceLocation(Record, Idx);
  E->ExplicitParams = Record[Idx++];
  E->ExplicitResultType = Record[Idx++];
  E->ClosingBrace = ReadSourceLocation(Record, Idx);
  
  // Read capture initializers.
  for (LambdaExpr::capture_init_iterator C = E->capture_init_begin(),
                                      CEnd = E->capture_init_end();
       C != CEnd; ++C)
    *C = Reader.ReadSubExpr();
  
  // Read array capture index variables.
  if (NumArrayIndexVars > 0) {
    unsigned *ArrayIndexStarts = E->getArrayIndexStarts();
    for (unsigned I = 0; I != NumCaptures + 1; ++I)
      ArrayIndexStarts[I] = Record[Idx++];
    
    VarDecl **ArrayIndexVars = E->getArrayIndexVars();
    for (unsigned I = 0; I != NumArrayIndexVars; ++I)
      ArrayIndexVars[I] = ReadDeclAs<VarDecl>(Record, Idx);
  }
}

void
ASTStmtReader::VisitCXXStdInitializerListExpr(CXXStdInitializerListExpr *E) {
  VisitExpr(E);
  E->SubExpr = Reader.ReadSubExpr();
}

void ASTStmtReader::VisitCXXNamedCastExpr(CXXNamedCastExpr *E) {
  VisitExplicitCastExpr(E);
  SourceRange R = ReadSourceRange(Record, Idx);
  E->Loc = R.getBegin();
  E->RParenLoc = R.getEnd();
  R = ReadSourceRange(Record, Idx);
  E->AngleBrackets = R;
}

void ASTStmtReader::VisitCXXStaticCastExpr(CXXStaticCastExpr *E) {
  return VisitCXXNamedCastExpr(E);
}

void ASTStmtReader::VisitCXXDynamicCastExpr(CXXDynamicCastExpr *E) {
  return VisitCXXNamedCastExpr(E);
}

void ASTStmtReader::VisitCXXReinterpretCastExpr(CXXReinterpretCastExpr *E) {
  return VisitCXXNamedCastExpr(E);
}

void ASTStmtReader::VisitCXXConstCastExpr(CXXConstCastExpr *E) {
  return VisitCXXNamedCastExpr(E);
}

void ASTStmtReader::VisitCXXFunctionalCastExpr(CXXFunctionalCastExpr *E) {
  VisitExplicitCastExpr(E);
  E->setLParenLoc(ReadSourceLocation(Record, Idx));
  E->setRParenLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitUserDefinedLiteral(UserDefinedLiteral *E) {
  VisitCallExpr(E);
  E->UDSuffixLoc = ReadSourceLocation(Record, Idx);
}

void ASTStmtReader::VisitCXXBoolLiteralExpr(CXXBoolLiteralExpr *E) {
  VisitExpr(E);
  E->setValue(Record[Idx++]);
  E->setLocation(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitCXXNullPtrLiteralExpr(CXXNullPtrLiteralExpr *E) {
  VisitExpr(E);
  E->setLocation(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitCXXTypeidExpr(CXXTypeidExpr *E) {
  VisitExpr(E);
  E->setSourceRange(ReadSourceRange(Record, Idx));
  if (E->isTypeOperand()) { // typeid(int)
    E->setTypeOperandSourceInfo(
        GetTypeSourceInfo(Record, Idx));
    return;
  }
  
  // typeid(42+2)
  E->setExprOperand(Reader.ReadSubExpr());
}

void ASTStmtReader::VisitCXXThisExpr(CXXThisExpr *E) {
  VisitExpr(E);
  E->setLocation(ReadSourceLocation(Record, Idx));
  E->setImplicit(Record[Idx++]);
}

void ASTStmtReader::VisitCXXThrowExpr(CXXThrowExpr *E) {
  VisitExpr(E);
  E->ThrowLoc = ReadSourceLocation(Record, Idx);
  E->Op = Reader.ReadSubExpr();
  E->IsThrownVariableInScope = Record[Idx++];
}

void ASTStmtReader::VisitCXXDefaultArgExpr(CXXDefaultArgExpr *E) {
  VisitExpr(E);
  E->Param = ReadDeclAs<ParmVarDecl>(Record, Idx);
  E->Loc = ReadSourceLocation(Record, Idx);
}

void ASTStmtReader::VisitCXXDefaultInitExpr(CXXDefaultInitExpr *E) {
  VisitExpr(E);
  E->Field = ReadDeclAs<FieldDecl>(Record, Idx);
  E->Loc = ReadSourceLocation(Record, Idx);
}

void ASTStmtReader::VisitCXXBindTemporaryExpr(CXXBindTemporaryExpr *E) {
  VisitExpr(E);
  E->setTemporary(Reader.ReadCXXTemporary(F, Record, Idx));
  E->setSubExpr(Reader.ReadSubExpr());
}

void ASTStmtReader::VisitCXXScalarValueInitExpr(CXXScalarValueInitExpr *E) {
  VisitExpr(E);
  E->TypeInfo = GetTypeSourceInfo(Record, Idx);
  E->RParenLoc = ReadSourceLocation(Record, Idx);
}

void ASTStmtReader::VisitCXXNewExpr(CXXNewExpr *E) {
  VisitExpr(E);
  E->GlobalNew = Record[Idx++];
  bool isArray = Record[Idx++];
  E->UsualArrayDeleteWantsSize = Record[Idx++];
  unsigned NumPlacementArgs = Record[Idx++];
  E->StoredInitializationStyle = Record[Idx++];
  E->setOperatorNew(ReadDeclAs<FunctionDecl>(Record, Idx));
  E->setOperatorDelete(ReadDeclAs<FunctionDecl>(Record, Idx));
  E->AllocatedTypeInfo = GetTypeSourceInfo(Record, Idx);
  E->TypeIdParens = ReadSourceRange(Record, Idx);
  E->Range = ReadSourceRange(Record, Idx);
  E->DirectInitRange = ReadSourceRange(Record, Idx);

  E->AllocateArgsArray(Reader.getContext(), isArray, NumPlacementArgs,
                       E->StoredInitializationStyle != 0);

  // Install all the subexpressions.
  for (CXXNewExpr::raw_arg_iterator I = E->raw_arg_begin(),e = E->raw_arg_end();
       I != e; ++I)
    *I = Reader.ReadSubStmt();
}

void ASTStmtReader::VisitCXXDeleteExpr(CXXDeleteExpr *E) {
  VisitExpr(E);
  E->GlobalDelete = Record[Idx++];
  E->ArrayForm = Record[Idx++];
  E->ArrayFormAsWritten = Record[Idx++];
  E->UsualArrayDeleteWantsSize = Record[Idx++];
  E->OperatorDelete = ReadDeclAs<FunctionDecl>(Record, Idx);
  E->Argument = Reader.ReadSubExpr();
  E->Loc = ReadSourceLocation(Record, Idx);
}

void ASTStmtReader::VisitCXXPseudoDestructorExpr(CXXPseudoDestructorExpr *E) {
  VisitExpr(E);

  E->Base = Reader.ReadSubExpr();
  E->IsArrow = Record[Idx++];
  E->OperatorLoc = ReadSourceLocation(Record, Idx);
  E->QualifierLoc = Reader.ReadNestedNameSpecifierLoc(F, Record, Idx);
  E->ScopeType = GetTypeSourceInfo(Record, Idx);
  E->ColonColonLoc = ReadSourceLocation(Record, Idx);
  E->TildeLoc = ReadSourceLocation(Record, Idx);
  
  IdentifierInfo *II = Reader.GetIdentifierInfo(F, Record, Idx);
  if (II)
    E->setDestroyedType(II, ReadSourceLocation(Record, Idx));
  else
    E->setDestroyedType(GetTypeSourceInfo(Record, Idx));
}

void ASTStmtReader::VisitExprWithCleanups(ExprWithCleanups *E) {
  VisitExpr(E);

  unsigned NumObjects = Record[Idx++];
  assert(NumObjects == E->getNumObjects());
  for (unsigned i = 0; i != NumObjects; ++i)
    E->getTrailingObjects<BlockDecl *>()[i] =
        ReadDeclAs<BlockDecl>(Record, Idx);

  E->SubExpr = Reader.ReadSubExpr();
}

void
ASTStmtReader::VisitCXXDependentScopeMemberExpr(CXXDependentScopeMemberExpr *E){
  VisitExpr(E);

  if (Record[Idx++]) // HasTemplateKWAndArgsInfo
    ReadTemplateKWAndArgsInfo(
        *E->getTrailingObjects<ASTTemplateKWAndArgsInfo>(),
        E->getTrailingObjects<TemplateArgumentLoc>(),
        /*NumTemplateArgs=*/Record[Idx++]);

  E->Base = Reader.ReadSubExpr();
  E->BaseType = Reader.readType(F, Record, Idx);
  E->IsArrow = Record[Idx++];
  E->OperatorLoc = ReadSourceLocation(Record, Idx);
  E->QualifierLoc = Reader.ReadNestedNameSpecifierLoc(F, Record, Idx);
  E->FirstQualifierFoundInScope = ReadDeclAs<NamedDecl>(Record, Idx);
  ReadDeclarationNameInfo(E->MemberNameInfo, Record, Idx);
}

void
ASTStmtReader::VisitDependentScopeDeclRefExpr(DependentScopeDeclRefExpr *E) {
  VisitExpr(E);

  if (Record[Idx++]) // HasTemplateKWAndArgsInfo
    ReadTemplateKWAndArgsInfo(
        *E->getTrailingObjects<ASTTemplateKWAndArgsInfo>(),
        E->getTrailingObjects<TemplateArgumentLoc>(),
        /*NumTemplateArgs=*/Record[Idx++]);

  E->QualifierLoc = Reader.ReadNestedNameSpecifierLoc(F, Record, Idx);
  ReadDeclarationNameInfo(E->NameInfo, Record, Idx);
}

void
ASTStmtReader::VisitCXXUnresolvedConstructExpr(CXXUnresolvedConstructExpr *E) {
  VisitExpr(E);
  assert(Record[Idx] == E->arg_size() && "Read wrong record during creation ?");
  ++Idx; // NumArgs;
  for (unsigned I = 0, N = E->arg_size(); I != N; ++I)
    E->setArg(I, Reader.ReadSubExpr());
  E->Type = GetTypeSourceInfo(Record, Idx);
  E->setLParenLoc(ReadSourceLocation(Record, Idx));
  E->setRParenLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitOverloadExpr(OverloadExpr *E) {
  VisitExpr(E);

  if (Record[Idx++]) // HasTemplateKWAndArgsInfo
    ReadTemplateKWAndArgsInfo(*E->getTrailingASTTemplateKWAndArgsInfo(),
                              E->getTrailingTemplateArgumentLoc(),
                              /*NumTemplateArgs=*/Record[Idx++]);

  unsigned NumDecls = Record[Idx++];
  UnresolvedSet<8> Decls;
  for (unsigned i = 0; i != NumDecls; ++i) {
    NamedDecl *D = ReadDeclAs<NamedDecl>(Record, Idx);
    AccessSpecifier AS = (AccessSpecifier)Record[Idx++];
    Decls.addDecl(D, AS);
  }
  E->initializeResults(Reader.getContext(), Decls.begin(), Decls.end());

  ReadDeclarationNameInfo(E->NameInfo, Record, Idx);
  E->QualifierLoc = Reader.ReadNestedNameSpecifierLoc(F, Record, Idx);
}

void ASTStmtReader::VisitUnresolvedMemberExpr(UnresolvedMemberExpr *E) {
  VisitOverloadExpr(E);
  E->IsArrow = Record[Idx++];
  E->HasUnresolvedUsing = Record[Idx++];
  E->Base = Reader.ReadSubExpr();
  E->BaseType = Reader.readType(F, Record, Idx);
  E->OperatorLoc = ReadSourceLocation(Record, Idx);
}

void ASTStmtReader::VisitUnresolvedLookupExpr(UnresolvedLookupExpr *E) {
  VisitOverloadExpr(E);
  E->RequiresADL = Record[Idx++];
  E->Overloaded = Record[Idx++];
  E->NamingClass = ReadDeclAs<CXXRecordDecl>(Record, Idx);
}

void ASTStmtReader::VisitTypeTraitExpr(TypeTraitExpr *E) {
  VisitExpr(E);
  E->TypeTraitExprBits.NumArgs = Record[Idx++];
  E->TypeTraitExprBits.Kind = Record[Idx++];
  E->TypeTraitExprBits.Value = Record[Idx++];
  SourceRange Range = ReadSourceRange(Record, Idx);
  E->Loc = Range.getBegin();
  E->RParenLoc = Range.getEnd();

  TypeSourceInfo **Args = E->getTrailingObjects<TypeSourceInfo *>();
  for (unsigned I = 0, N = E->getNumArgs(); I != N; ++I)
    Args[I] = GetTypeSourceInfo(Record, Idx);
}

void ASTStmtReader::VisitArrayTypeTraitExpr(ArrayTypeTraitExpr *E) {
  VisitExpr(E);
  E->ATT = (ArrayTypeTrait)Record[Idx++];
  E->Value = (unsigned int)Record[Idx++];
  SourceRange Range = ReadSourceRange(Record, Idx);
  E->Loc = Range.getBegin();
  E->RParen = Range.getEnd();
  E->QueriedType = GetTypeSourceInfo(Record, Idx);
}

void ASTStmtReader::VisitExpressionTraitExpr(ExpressionTraitExpr *E) {
  VisitExpr(E);
  E->ET = (ExpressionTrait)Record[Idx++];
  E->Value = (bool)Record[Idx++];
  SourceRange Range = ReadSourceRange(Record, Idx);
  E->QueriedExpression = Reader.ReadSubExpr();
  E->Loc = Range.getBegin();
  E->RParen = Range.getEnd();
}

void ASTStmtReader::VisitCXXNoexceptExpr(CXXNoexceptExpr *E) {
  VisitExpr(E);
  E->Value = (bool)Record[Idx++];
  E->Range = ReadSourceRange(Record, Idx);
  E->Operand = Reader.ReadSubExpr();
}

void ASTStmtReader::VisitPackExpansionExpr(PackExpansionExpr *E) {
  VisitExpr(E);
  E->EllipsisLoc = ReadSourceLocation(Record, Idx);
  E->NumExpansions = Record[Idx++];
  E->Pattern = Reader.ReadSubExpr();  
}

void ASTStmtReader::VisitSizeOfPackExpr(SizeOfPackExpr *E) {
  VisitExpr(E);
  unsigned NumPartialArgs = Record[Idx++];
  E->OperatorLoc = ReadSourceLocation(Record, Idx);
  E->PackLoc = ReadSourceLocation(Record, Idx);
  E->RParenLoc = ReadSourceLocation(Record, Idx);
  E->Pack = Reader.ReadDeclAs<NamedDecl>(F, Record, Idx);
  if (E->isPartiallySubstituted()) {
    assert(E->Length == NumPartialArgs);
    for (auto *I = E->getTrailingObjects<TemplateArgument>(),
              *E = I + NumPartialArgs;
         I != E; ++I)
      new (I) TemplateArgument(Reader.ReadTemplateArgument(F, Record, Idx));
  } else if (!E->isValueDependent()) {
    E->Length = Record[Idx++];
  }
}

void ASTStmtReader::VisitSubstNonTypeTemplateParmExpr(
                                              SubstNonTypeTemplateParmExpr *E) {
  VisitExpr(E);
  E->Param = ReadDeclAs<NonTypeTemplateParmDecl>(Record, Idx);
  E->NameLoc = ReadSourceLocation(Record, Idx);
  E->Replacement = Reader.ReadSubExpr();
}

void ASTStmtReader::VisitSubstNonTypeTemplateParmPackExpr(
                                          SubstNonTypeTemplateParmPackExpr *E) {
  VisitExpr(E);
  E->Param = ReadDeclAs<NonTypeTemplateParmDecl>(Record, Idx);
  TemplateArgument ArgPack = Reader.ReadTemplateArgument(F, Record, Idx);
  if (ArgPack.getKind() != TemplateArgument::Pack)
    return;
  
  E->Arguments = ArgPack.pack_begin();
  E->NumArguments = ArgPack.pack_size();
  E->NameLoc = ReadSourceLocation(Record, Idx);
}

void ASTStmtReader::VisitFunctionParmPackExpr(FunctionParmPackExpr *E) {
  VisitExpr(E);
  E->NumParameters = Record[Idx++];
  E->ParamPack = ReadDeclAs<ParmVarDecl>(Record, Idx);
  E->NameLoc = ReadSourceLocation(Record, Idx);
  ParmVarDecl **Parms = E->getTrailingObjects<ParmVarDecl *>();
  for (unsigned i = 0, n = E->NumParameters; i != n; ++i)
    Parms[i] = ReadDeclAs<ParmVarDecl>(Record, Idx);
}

void ASTStmtReader::VisitMaterializeTemporaryExpr(MaterializeTemporaryExpr *E) {
  VisitExpr(E);
  E->State = Reader.ReadSubExpr();
  auto VD = ReadDeclAs<ValueDecl>(Record, Idx);
  unsigned ManglingNumber = Record[Idx++];
  E->setExtendingDecl(VD, ManglingNumber);
}

void ASTStmtReader::VisitCXXFoldExpr(CXXFoldExpr *E) {
  VisitExpr(E);
  E->LParenLoc = ReadSourceLocation(Record, Idx);
  E->EllipsisLoc = ReadSourceLocation(Record, Idx);
  E->RParenLoc = ReadSourceLocation(Record, Idx);
  E->SubExprs[0] = Reader.ReadSubExpr();
  E->SubExprs[1] = Reader.ReadSubExpr();
  E->Opcode = (BinaryOperatorKind)Record[Idx++];
}

void ASTStmtReader::VisitOpaqueValueExpr(OpaqueValueExpr *E) {
  VisitExpr(E);
  E->SourceExpr = Reader.ReadSubExpr();
  E->Loc = ReadSourceLocation(Record, Idx);
}

void ASTStmtReader::VisitTypoExpr(TypoExpr *E) {
  llvm_unreachable("Cannot read TypoExpr nodes");
}

//===----------------------------------------------------------------------===//
// Microsoft Expressions and Statements
//===----------------------------------------------------------------------===//
void ASTStmtReader::VisitMSPropertyRefExpr(MSPropertyRefExpr *E) {
  VisitExpr(E);
  E->IsArrow = (Record[Idx++] != 0);
  E->BaseExpr = Reader.ReadSubExpr();
  E->QualifierLoc = Reader.ReadNestedNameSpecifierLoc(F, Record, Idx);
  E->MemberLoc = ReadSourceLocation(Record, Idx);
  E->TheDecl = ReadDeclAs<MSPropertyDecl>(Record, Idx);
}

void ASTStmtReader::VisitMSPropertySubscriptExpr(MSPropertySubscriptExpr *E) {
  VisitExpr(E);
  E->setBase(Reader.ReadSubExpr());
  E->setIdx(Reader.ReadSubExpr());
  E->setRBracketLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitCXXUuidofExpr(CXXUuidofExpr *E) {
  VisitExpr(E);
  E->setSourceRange(ReadSourceRange(Record, Idx));
  if (E->isTypeOperand()) { // __uuidof(ComType)
    E->setTypeOperandSourceInfo(
        GetTypeSourceInfo(Record, Idx));
    return;
  }
  
  // __uuidof(expr)
  E->setExprOperand(Reader.ReadSubExpr());
}

void ASTStmtReader::VisitSEHLeaveStmt(SEHLeaveStmt *S) {
  VisitStmt(S);
  S->setLeaveLoc(ReadSourceLocation(Record, Idx));
}

void ASTStmtReader::VisitSEHExceptStmt(SEHExceptStmt *S) {
  VisitStmt(S);
  S->Loc = ReadSourceLocation(Record, Idx);
  S->Children[SEHExceptStmt::FILTER_EXPR] = Reader.ReadSubStmt();
  S->Children[SEHExceptStmt::BLOCK] = Reader.ReadSubStmt();
}

void ASTStmtReader::VisitSEHFinallyStmt(SEHFinallyStmt *S) {
  VisitStmt(S);
  S->Loc = ReadSourceLocation(Record, Idx);
  S->Block = Reader.ReadSubStmt();
}

void ASTStmtReader::VisitSEHTryStmt(SEHTryStmt *S) {
  VisitStmt(S);
  S->IsCXXTry = Record[Idx++];
  S->TryLoc = ReadSourceLocation(Record, Idx);
  S->Children[SEHTryStmt::TRY] = Reader.ReadSubStmt();
  S->Children[SEHTryStmt::HANDLER] = Reader.ReadSubStmt();
}

//===----------------------------------------------------------------------===//
// CUDA Expressions and Statements
//===----------------------------------------------------------------------===//

void ASTStmtReader::VisitCUDAKernelCallExpr(CUDAKernelCallExpr *E) {
  VisitCallExpr(E);
  E->setConfig(cast<CallExpr>(Reader.ReadSubExpr()));
}

//===----------------------------------------------------------------------===//
// OpenCL Expressions and Statements.
//===----------------------------------------------------------------------===//
void ASTStmtReader::VisitAsTypeExpr(AsTypeExpr *E) {
  VisitExpr(E);
  E->BuiltinLoc = ReadSourceLocation(Record, Idx);
  E->RParenLoc = ReadSourceLocation(Record, Idx);
  E->SrcExpr = Reader.ReadSubExpr();
}

//===----------------------------------------------------------------------===//
// OpenMP Clauses.
//===----------------------------------------------------------------------===//

namespace clang {
class OMPClauseReader : public OMPClauseVisitor<OMPClauseReader> {
  ASTStmtReader *Reader;
  ASTContext &Context;
  const ASTReader::RecordData &Record;
  unsigned &Idx;
public:
  OMPClauseReader(ASTStmtReader *R, ASTContext &C,
                  const ASTReader::RecordData &Record, unsigned &Idx)
    : Reader(R), Context(C), Record(Record), Idx(Idx) { }
#define OPENMP_CLAUSE(Name, Class)    \
  void Visit##Class(Class *S);
#include "clang/Basic/OpenMPKinds.def"
  OMPClause *readClause();
};
}

OMPClause *OMPClauseReader::readClause() {
  OMPClause *C;
  switch (Record[Idx++]) {
  case OMPC_if:
    C = new (Context) OMPIfClause();
    break;
  case OMPC_final:
    C = new (Context) OMPFinalClause();
    break;
  case OMPC_num_threads:
    C = new (Context) OMPNumThreadsClause();
    break;
  case OMPC_safelen:
    C = new (Context) OMPSafelenClause();
    break;
  case OMPC_simdlen:
    C = new (Context) OMPSimdlenClause();
    break;
  case OMPC_collapse:
    C = new (Context) OMPCollapseClause();
    break;
  case OMPC_default:
    C = new (Context) OMPDefaultClause();
    break;
  case OMPC_proc_bind:
    C = new (Context) OMPProcBindClause();
    break;
  case OMPC_schedule:
    C = new (Context) OMPScheduleClause();
    break;
  case OMPC_ordered:
    C = new (Context) OMPOrderedClause();
    break;
  case OMPC_nowait:
    C = new (Context) OMPNowaitClause();
    break;
  case OMPC_untied:
    C = new (Context) OMPUntiedClause();
    break;
  case OMPC_mergeable:
    C = new (Context) OMPMergeableClause();
    break;
  case OMPC_read:
    C = new (Context) OMPReadClause();
    break;
  case OMPC_write:
    C = new (Context) OMPWriteClause();
    break;
  case OMPC_update:
    C = new (Context) OMPUpdateClause();
    break;
  case OMPC_capture:
    C = new (Context) OMPCaptureClause();
    break;
  case OMPC_seq_cst:
    C = new (Context) OMPSeqCstClause();
    break;
  case OMPC_threads:
    C = new (Context) OMPThreadsClause();
    break;
  case OMPC_simd:
    C = new (Context) OMPSIMDClause();
    break;
  case OMPC_nogroup:
    C = new (Context) OMPNogroupClause();
    break;
  case OMPC_private:
    C = OMPPrivateClause::CreateEmpty(Context, Record[Idx++]);
    break;
  case OMPC_firstprivate:
    C = OMPFirstprivateClause::CreateEmpty(Context, Record[Idx++]);
    break;
  case OMPC_lastprivate:
    C = OMPLastprivateClause::CreateEmpty(Context, Record[Idx++]);
    break;
  case OMPC_shared:
    C = OMPSharedClause::CreateEmpty(Context, Record[Idx++]);
    break;
  case OMPC_reduction:
    C = OMPReductionClause::CreateEmpty(Context, Record[Idx++]);
    break;
  case OMPC_linear:
    C = OMPLinearClause::CreateEmpty(Context, Record[Idx++]);
    break;
  case OMPC_aligned:
    C = OMPAlignedClause::CreateEmpty(Context, Record[Idx++]);
    break;
  case OMPC_copyin:
    C = OMPCopyinClause::CreateEmpty(Context, Record[Idx++]);
    break;
  case OMPC_copyprivate:
    C = OMPCopyprivateClause::CreateEmpty(Context, Record[Idx++]);
    break;
  case OMPC_flush:
    C = OMPFlushClause::CreateEmpty(Context, Record[Idx++]);
    break;
  case OMPC_depend:
    C = OMPDependClause::CreateEmpty(Context, Record[Idx++]);
    break;
  case OMPC_device:
    C = new (Context) OMPDeviceClause();
    break;
  case OMPC_map:
    C = OMPMapClause::CreateEmpty(Context, Record[Idx++]);
    break;
  case OMPC_num_teams:
    C = new (Context) OMPNumTeamsClause();
    break;
  case OMPC_thread_limit:
    C = new (Context) OMPThreadLimitClause();
    break;
  case OMPC_priority:
    C = new (Context) OMPPriorityClause();
    break;
  case OMPC_grainsize:
    C = new (Context) OMPGrainsizeClause();
    break;
  case OMPC_num_tasks:
    C = new (Context) OMPNumTasksClause();
    break;
  case OMPC_hint:
    C = new (Context) OMPHintClause();
    break;
  }
  Visit(C);
  C->setLocStart(Reader->ReadSourceLocation(Record, Idx));
  C->setLocEnd(Reader->ReadSourceLocation(Record, Idx));

  return C;
}

void OMPClauseReader::VisitOMPIfClause(OMPIfClause *C) {
  C->setNameModifier(static_cast<OpenMPDirectiveKind>(Record[Idx++]));
  C->setNameModifierLoc(Reader->ReadSourceLocation(Record, Idx));
  C->setColonLoc(Reader->ReadSourceLocation(Record, Idx));
  C->setCondition(Reader->Reader.ReadSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
}

void OMPClauseReader::VisitOMPFinalClause(OMPFinalClause *C) {
  C->setCondition(Reader->Reader.ReadSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
}

void OMPClauseReader::VisitOMPNumThreadsClause(OMPNumThreadsClause *C) {
  C->setNumThreads(Reader->Reader.ReadSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
}

void OMPClauseReader::VisitOMPSafelenClause(OMPSafelenClause *C) {
  C->setSafelen(Reader->Reader.ReadSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
}

void OMPClauseReader::VisitOMPSimdlenClause(OMPSimdlenClause *C) {
  C->setSimdlen(Reader->Reader.ReadSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
}

void OMPClauseReader::VisitOMPCollapseClause(OMPCollapseClause *C) {
  C->setNumForLoops(Reader->Reader.ReadSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
}

void OMPClauseReader::VisitOMPDefaultClause(OMPDefaultClause *C) {
  C->setDefaultKind(
       static_cast<OpenMPDefaultClauseKind>(Record[Idx++]));
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
  C->setDefaultKindKwLoc(Reader->ReadSourceLocation(Record, Idx));
}

void OMPClauseReader::VisitOMPProcBindClause(OMPProcBindClause *C) {
  C->setProcBindKind(
       static_cast<OpenMPProcBindClauseKind>(Record[Idx++]));
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
  C->setProcBindKindKwLoc(Reader->ReadSourceLocation(Record, Idx));
}

void OMPClauseReader::VisitOMPScheduleClause(OMPScheduleClause *C) {
  C->setScheduleKind(
       static_cast<OpenMPScheduleClauseKind>(Record[Idx++]));
  C->setFirstScheduleModifier(
      static_cast<OpenMPScheduleClauseModifier>(Record[Idx++]));
  C->setSecondScheduleModifier(
      static_cast<OpenMPScheduleClauseModifier>(Record[Idx++]));
  C->setChunkSize(Reader->Reader.ReadSubExpr());
  C->setHelperChunkSize(Reader->Reader.ReadSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
  C->setFirstScheduleModifierLoc(Reader->ReadSourceLocation(Record, Idx));
  C->setSecondScheduleModifierLoc(Reader->ReadSourceLocation(Record, Idx));
  C->setScheduleKindLoc(Reader->ReadSourceLocation(Record, Idx));
  C->setCommaLoc(Reader->ReadSourceLocation(Record, Idx));
}

void OMPClauseReader::VisitOMPOrderedClause(OMPOrderedClause *C) {
  C->setNumForLoops(Reader->Reader.ReadSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
}

void OMPClauseReader::VisitOMPNowaitClause(OMPNowaitClause *) {}

void OMPClauseReader::VisitOMPUntiedClause(OMPUntiedClause *) {}

void OMPClauseReader::VisitOMPMergeableClause(OMPMergeableClause *) {}

void OMPClauseReader::VisitOMPReadClause(OMPReadClause *) {}

void OMPClauseReader::VisitOMPWriteClause(OMPWriteClause *) {}

void OMPClauseReader::VisitOMPUpdateClause(OMPUpdateClause *) {}

void OMPClauseReader::VisitOMPCaptureClause(OMPCaptureClause *) {}

void OMPClauseReader::VisitOMPSeqCstClause(OMPSeqCstClause *) {}

void OMPClauseReader::VisitOMPThreadsClause(OMPThreadsClause *) {}

void OMPClauseReader::VisitOMPSIMDClause(OMPSIMDClause *) {}

void OMPClauseReader::VisitOMPNogroupClause(OMPNogroupClause *) {}

void OMPClauseReader::VisitOMPPrivateClause(OMPPrivateClause *C) {
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
  unsigned NumVars = C->varlist_size();
  SmallVector<Expr *, 16> Vars;
  Vars.reserve(NumVars);
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setVarRefs(Vars);
  Vars.clear();
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setPrivateCopies(Vars);
}

void OMPClauseReader::VisitOMPFirstprivateClause(OMPFirstprivateClause *C) {
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
  unsigned NumVars = C->varlist_size();
  SmallVector<Expr *, 16> Vars;
  Vars.reserve(NumVars);
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setVarRefs(Vars);
  Vars.clear();
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setPrivateCopies(Vars);
  Vars.clear();
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setInits(Vars);
}

void OMPClauseReader::VisitOMPLastprivateClause(OMPLastprivateClause *C) {
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
  unsigned NumVars = C->varlist_size();
  SmallVector<Expr *, 16> Vars;
  Vars.reserve(NumVars);
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setVarRefs(Vars);
  Vars.clear();
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setPrivateCopies(Vars);
  Vars.clear();
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setSourceExprs(Vars);
  Vars.clear();
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setDestinationExprs(Vars);
  Vars.clear();
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setAssignmentOps(Vars);
}

void OMPClauseReader::VisitOMPSharedClause(OMPSharedClause *C) {
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
  unsigned NumVars = C->varlist_size();
  SmallVector<Expr *, 16> Vars;
  Vars.reserve(NumVars);
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setVarRefs(Vars);
}

void OMPClauseReader::VisitOMPReductionClause(OMPReductionClause *C) {
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
  C->setColonLoc(Reader->ReadSourceLocation(Record, Idx));
  NestedNameSpecifierLoc NNSL =
    Reader->Reader.ReadNestedNameSpecifierLoc(Reader->F, Record, Idx);
  DeclarationNameInfo DNI;
  Reader->ReadDeclarationNameInfo(DNI, Record, Idx);
  C->setQualifierLoc(NNSL);
  C->setNameInfo(DNI);

  unsigned NumVars = C->varlist_size();
  SmallVector<Expr *, 16> Vars;
  Vars.reserve(NumVars);
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setVarRefs(Vars);
  Vars.clear();
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setPrivates(Vars);
  Vars.clear();
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setLHSExprs(Vars);
  Vars.clear();
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setRHSExprs(Vars);
  Vars.clear();
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setReductionOps(Vars);
}

void OMPClauseReader::VisitOMPLinearClause(OMPLinearClause *C) {
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
  C->setColonLoc(Reader->ReadSourceLocation(Record, Idx));
  C->setModifier(static_cast<OpenMPLinearClauseKind>(Record[Idx++]));
  C->setModifierLoc(Reader->ReadSourceLocation(Record, Idx));
  unsigned NumVars = C->varlist_size();
  SmallVector<Expr *, 16> Vars;
  Vars.reserve(NumVars);
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setVarRefs(Vars);
  Vars.clear();
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setPrivates(Vars);
  Vars.clear();
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setInits(Vars);
  Vars.clear();
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setUpdates(Vars);
  Vars.clear();
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setFinals(Vars);
  C->setStep(Reader->Reader.ReadSubExpr());
  C->setCalcStep(Reader->Reader.ReadSubExpr());
}

void OMPClauseReader::VisitOMPAlignedClause(OMPAlignedClause *C) {
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
  C->setColonLoc(Reader->ReadSourceLocation(Record, Idx));
  unsigned NumVars = C->varlist_size();
  SmallVector<Expr *, 16> Vars;
  Vars.reserve(NumVars);
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setVarRefs(Vars);
  C->setAlignment(Reader->Reader.ReadSubExpr());
}

void OMPClauseReader::VisitOMPCopyinClause(OMPCopyinClause *C) {
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
  unsigned NumVars = C->varlist_size();
  SmallVector<Expr *, 16> Exprs;
  Exprs.reserve(NumVars);
  for (unsigned i = 0; i != NumVars; ++i)
    Exprs.push_back(Reader->Reader.ReadSubExpr());
  C->setVarRefs(Exprs);
  Exprs.clear();
  for (unsigned i = 0; i != NumVars; ++i)
    Exprs.push_back(Reader->Reader.ReadSubExpr());
  C->setSourceExprs(Exprs);
  Exprs.clear();
  for (unsigned i = 0; i != NumVars; ++i)
    Exprs.push_back(Reader->Reader.ReadSubExpr());
  C->setDestinationExprs(Exprs);
  Exprs.clear();
  for (unsigned i = 0; i != NumVars; ++i)
    Exprs.push_back(Reader->Reader.ReadSubExpr());
  C->setAssignmentOps(Exprs);
}

void OMPClauseReader::VisitOMPCopyprivateClause(OMPCopyprivateClause *C) {
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
  unsigned NumVars = C->varlist_size();
  SmallVector<Expr *, 16> Exprs;
  Exprs.reserve(NumVars);
  for (unsigned i = 0; i != NumVars; ++i)
    Exprs.push_back(Reader->Reader.ReadSubExpr());
  C->setVarRefs(Exprs);
  Exprs.clear();
  for (unsigned i = 0; i != NumVars; ++i)
    Exprs.push_back(Reader->Reader.ReadSubExpr());
  C->setSourceExprs(Exprs);
  Exprs.clear();
  for (unsigned i = 0; i != NumVars; ++i)
    Exprs.push_back(Reader->Reader.ReadSubExpr());
  C->setDestinationExprs(Exprs);
  Exprs.clear();
  for (unsigned i = 0; i != NumVars; ++i)
    Exprs.push_back(Reader->Reader.ReadSubExpr());
  C->setAssignmentOps(Exprs);
}

void OMPClauseReader::VisitOMPFlushClause(OMPFlushClause *C) {
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
  unsigned NumVars = C->varlist_size();
  SmallVector<Expr *, 16> Vars;
  Vars.reserve(NumVars);
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setVarRefs(Vars);
}

void OMPClauseReader::VisitOMPDependClause(OMPDependClause *C) {
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
  C->setDependencyKind(static_cast<OpenMPDependClauseKind>(Record[Idx++]));
  C->setDependencyLoc(Reader->ReadSourceLocation(Record, Idx));
  C->setColonLoc(Reader->ReadSourceLocation(Record, Idx));
  unsigned NumVars = C->varlist_size();
  SmallVector<Expr *, 16> Vars;
  Vars.reserve(NumVars);
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setVarRefs(Vars);
}

void OMPClauseReader::VisitOMPDeviceClause(OMPDeviceClause *C) {
  C->setDevice(Reader->Reader.ReadSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
}

void OMPClauseReader::VisitOMPMapClause(OMPMapClause *C) {
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
  C->setMapTypeModifier(
     static_cast<OpenMPMapClauseKind>(Record[Idx++]));
  C->setMapType(
     static_cast<OpenMPMapClauseKind>(Record[Idx++]));
  C->setMapLoc(Reader->ReadSourceLocation(Record, Idx));
  C->setColonLoc(Reader->ReadSourceLocation(Record, Idx));
  auto NumVars = C->varlist_size();
  SmallVector<Expr *, 16> Vars;
  Vars.reserve(NumVars);
  for (unsigned i = 0; i != NumVars; ++i) {
    Vars.push_back(Reader->Reader.ReadSubExpr());
  }
  C->setVarRefs(Vars);
}

void OMPClauseReader::VisitOMPNumTeamsClause(OMPNumTeamsClause *C) {
  C->setNumTeams(Reader->Reader.ReadSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
}

void OMPClauseReader::VisitOMPThreadLimitClause(OMPThreadLimitClause *C) {
  C->setThreadLimit(Reader->Reader.ReadSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
}

void OMPClauseReader::VisitOMPPriorityClause(OMPPriorityClause *C) {
  C->setPriority(Reader->Reader.ReadSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
}

void OMPClauseReader::VisitOMPGrainsizeClause(OMPGrainsizeClause *C) {
  C->setGrainsize(Reader->Reader.ReadSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
}

void OMPClauseReader::VisitOMPNumTasksClause(OMPNumTasksClause *C) {
  C->setNumTasks(Reader->Reader.ReadSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
}

void OMPClauseReader::VisitOMPHintClause(OMPHintClause *C) {
  C->setHint(Reader->Reader.ReadSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
}

//===----------------------------------------------------------------------===//
// OpenMP Directives.
//===----------------------------------------------------------------------===//
void ASTStmtReader::VisitOMPExecutableDirective(OMPExecutableDirective *E) {
  E->setLocStart(ReadSourceLocation(Record, Idx));
  E->setLocEnd(ReadSourceLocation(Record, Idx));
  OMPClauseReader ClauseReader(this, Reader.getContext(), Record, Idx);
  SmallVector<OMPClause *, 5> Clauses;
  for (unsigned i = 0; i < E->getNumClauses(); ++i)
    Clauses.push_back(ClauseReader.readClause());
  E->setClauses(Clauses);
  if (E->hasAssociatedStmt())
    E->setAssociatedStmt(Reader.ReadSubStmt());
}

void ASTStmtReader::VisitOMPLoopDirective(OMPLoopDirective *D) {
  VisitStmt(D);
  // Two fields (NumClauses and CollapsedNum) were read in ReadStmtFromStream.
  Idx += 2;
  VisitOMPExecutableDirective(D);
  D->setIterationVariable(Reader.ReadSubExpr());
  D->setLastIteration(Reader.ReadSubExpr());
  D->setCalcLastIteration(Reader.ReadSubExpr());
  D->setPreCond(Reader.ReadSubExpr());
  D->setCond(Reader.ReadSubExpr());
  D->setInit(Reader.ReadSubExpr());
  D->setInc(Reader.ReadSubExpr());
  if (isOpenMPWorksharingDirective(D->getDirectiveKind())) {
    D->setIsLastIterVariable(Reader.ReadSubExpr());
    D->setLowerBoundVariable(Reader.ReadSubExpr());
    D->setUpperBoundVariable(Reader.ReadSubExpr());
    D->setStrideVariable(Reader.ReadSubExpr());
    D->setEnsureUpperBound(Reader.ReadSubExpr());
    D->setNextLowerBound(Reader.ReadSubExpr());
    D->setNextUpperBound(Reader.ReadSubExpr());
  }
  SmallVector<Expr *, 4> Sub;
  unsigned CollapsedNum = D->getCollapsedNumber();
  Sub.reserve(CollapsedNum);
  for (unsigned i = 0; i < CollapsedNum; ++i)
    Sub.push_back(Reader.ReadSubExpr());
  D->setCounters(Sub);
  Sub.clear();
  for (unsigned i = 0; i < CollapsedNum; ++i)
    Sub.push_back(Reader.ReadSubExpr());
  D->setPrivateCounters(Sub);
  Sub.clear();
  for (unsigned i = 0; i < CollapsedNum; ++i)
    Sub.push_back(Reader.ReadSubExpr());
  D->setInits(Sub);
  Sub.clear();
  for (unsigned i = 0; i < CollapsedNum; ++i)
    Sub.push_back(Reader.ReadSubExpr());
  D->setUpdates(Sub);
  Sub.clear();
  for (unsigned i = 0; i < CollapsedNum; ++i)
    Sub.push_back(Reader.ReadSubExpr());
  D->setFinals(Sub);
}

void ASTStmtReader::VisitOMPParallelDirective(OMPParallelDirective *D) {
  VisitStmt(D);
  // The NumClauses field was read in ReadStmtFromStream.
  ++Idx;
  VisitOMPExecutableDirective(D);
  D->setHasCancel(Record[Idx++]);
}

void ASTStmtReader::VisitOMPSimdDirective(OMPSimdDirective *D) {
  VisitOMPLoopDirective(D);
}

void ASTStmtReader::VisitOMPForDirective(OMPForDirective *D) {
  VisitOMPLoopDirective(D);
  D->setHasCancel(Record[Idx++]);
}

void ASTStmtReader::VisitOMPForSimdDirective(OMPForSimdDirective *D) {
  VisitOMPLoopDirective(D);
}

void ASTStmtReader::VisitOMPSectionsDirective(OMPSectionsDirective *D) {
  VisitStmt(D);
  // The NumClauses field was read in ReadStmtFromStream.
  ++Idx;
  VisitOMPExecutableDirective(D);
  D->setHasCancel(Record[Idx++]);
}

void ASTStmtReader::VisitOMPSectionDirective(OMPSectionDirective *D) {
  VisitStmt(D);
  VisitOMPExecutableDirective(D);
  D->setHasCancel(Record[Idx++]);
}

void ASTStmtReader::VisitOMPSingleDirective(OMPSingleDirective *D) {
  VisitStmt(D);
  // The NumClauses field was read in ReadStmtFromStream.
  ++Idx;
  VisitOMPExecutableDirective(D);
}

void ASTStmtReader::VisitOMPMasterDirective(OMPMasterDirective *D) {
  VisitStmt(D);
  VisitOMPExecutableDirective(D);
}

void ASTStmtReader::VisitOMPCriticalDirective(OMPCriticalDirective *D) {
  VisitStmt(D);
  // The NumClauses field was read in ReadStmtFromStream.
  ++Idx;
  VisitOMPExecutableDirective(D);
  ReadDeclarationNameInfo(D->DirName, Record, Idx);
}

void ASTStmtReader::VisitOMPParallelForDirective(OMPParallelForDirective *D) {
  VisitOMPLoopDirective(D);
  D->setHasCancel(Record[Idx++]);
}

void ASTStmtReader::VisitOMPParallelForSimdDirective(
    OMPParallelForSimdDirective *D) {
  VisitOMPLoopDirective(D);
}

void ASTStmtReader::VisitOMPParallelSectionsDirective(
    OMPParallelSectionsDirective *D) {
  VisitStmt(D);
  // The NumClauses field was read in ReadStmtFromStream.
  ++Idx;
  VisitOMPExecutableDirective(D);
  D->setHasCancel(Record[Idx++]);
}

void ASTStmtReader::VisitOMPTaskDirective(OMPTaskDirective *D) {
  VisitStmt(D);
  // The NumClauses field was read in ReadStmtFromStream.
  ++Idx;
  VisitOMPExecutableDirective(D);
  D->setHasCancel(Record[Idx++]);
}

void ASTStmtReader::VisitOMPTaskyieldDirective(OMPTaskyieldDirective *D) {
  VisitStmt(D);
  VisitOMPExecutableDirective(D);
}

void ASTStmtReader::VisitOMPBarrierDirective(OMPBarrierDirective *D) {
  VisitStmt(D);
  VisitOMPExecutableDirective(D);
}

void ASTStmtReader::VisitOMPTaskwaitDirective(OMPTaskwaitDirective *D) {
  VisitStmt(D);
  VisitOMPExecutableDirective(D);
}

void ASTStmtReader::VisitOMPTaskgroupDirective(OMPTaskgroupDirective *D) {
  VisitStmt(D);
  VisitOMPExecutableDirective(D);
}

void ASTStmtReader::VisitOMPFlushDirective(OMPFlushDirective *D) {
  VisitStmt(D);
  // The NumClauses field was read in ReadStmtFromStream.
  ++Idx;
  VisitOMPExecutableDirective(D);
}

void ASTStmtReader::VisitOMPOrderedDirective(OMPOrderedDirective *D) {
  VisitStmt(D);
  // The NumClauses field was read in ReadStmtFromStream.
  ++Idx;
  VisitOMPExecutableDirective(D);
}

void ASTStmtReader::VisitOMPAtomicDirective(OMPAtomicDirective *D) {
  VisitStmt(D);
  // The NumClauses field was read in ReadStmtFromStream.
  ++Idx;
  VisitOMPExecutableDirective(D);
  D->setX(Reader.ReadSubExpr());
  D->setV(Reader.ReadSubExpr());
  D->setExpr(Reader.ReadSubExpr());
  D->setUpdateExpr(Reader.ReadSubExpr());
  D->IsXLHSInRHSPart = Record[Idx++] != 0;
  D->IsPostfixUpdate = Record[Idx++] != 0;
}

void ASTStmtReader::VisitOMPTargetDirective(OMPTargetDirective *D) {
  VisitStmt(D);
  // The NumClauses field was read in ReadStmtFromStream.
  ++Idx;
  VisitOMPExecutableDirective(D);
}

void ASTStmtReader::VisitOMPTargetDataDirective(OMPTargetDataDirective *D) {
  VisitStmt(D);
  ++Idx;
  VisitOMPExecutableDirective(D);
}

void ASTStmtReader::VisitOMPTeamsDirective(OMPTeamsDirective *D) {
  VisitStmt(D);
  // The NumClauses field was read in ReadStmtFromStream.
  ++Idx;
  VisitOMPExecutableDirective(D);
}

void ASTStmtReader::VisitOMPCancellationPointDirective(
    OMPCancellationPointDirective *D) {
  VisitStmt(D);
  VisitOMPExecutableDirective(D);
  D->setCancelRegion(static_cast<OpenMPDirectiveKind>(Record[Idx++]));
}

void ASTStmtReader::VisitOMPCancelDirective(OMPCancelDirective *D) {
  VisitStmt(D);
  // The NumClauses field was read in ReadStmtFromStream.
  ++Idx;
  VisitOMPExecutableDirective(D);
  D->setCancelRegion(static_cast<OpenMPDirectiveKind>(Record[Idx++]));
}

void ASTStmtReader::VisitOMPTaskLoopDirective(OMPTaskLoopDirective *D) {
  VisitOMPLoopDirective(D);
}

void ASTStmtReader::VisitOMPTaskLoopSimdDirective(OMPTaskLoopSimdDirective *D) {
  VisitOMPLoopDirective(D);
}

void ASTStmtReader::VisitOMPDistributeDirective(OMPDistributeDirective *D) {
  VisitOMPLoopDirective(D);
}

//===----------------------------------------------------------------------===//
// ASTReader Implementation
//===----------------------------------------------------------------------===//

Stmt *ASTReader::ReadStmt(ModuleFile &F) {
  switch (ReadingKind) {
  case Read_None:
    llvm_unreachable("should not call this when not reading anything");
  case Read_Decl:
  case Read_Type:
    return ReadStmtFromStream(F);
  case Read_Stmt:
    return ReadSubStmt();
  }

  llvm_unreachable("ReadingKind not set ?");
}

Expr *ASTReader::ReadExpr(ModuleFile &F) {
  return cast_or_null<Expr>(ReadStmt(F));
}

Expr *ASTReader::ReadSubExpr() {
  return cast_or_null<Expr>(ReadSubStmt());
}

// Within the bitstream, expressions are stored in Reverse Polish
// Notation, with each of the subexpressions preceding the
// expression they are stored in. Subexpressions are stored from last to first.
// To evaluate expressions, we continue reading expressions and placing them on
// the stack, with expressions having operands removing those operands from the
// stack. Evaluation terminates when we see a STMT_STOP record, and
// the single remaining expression on the stack is our result.
Stmt *ASTReader::ReadStmtFromStream(ModuleFile &F) {

  ReadingKindTracker ReadingKind(Read_Stmt, *this);
  llvm::BitstreamCursor &Cursor = F.DeclsCursor;
  
  // Map of offset to previously deserialized stmt. The offset points
  /// just after the stmt record.
  llvm::DenseMap<uint64_t, Stmt *> StmtEntries;

#ifndef NDEBUG
  unsigned PrevNumStmts = StmtStack.size();
#endif

  RecordData Record;
  unsigned Idx;
  ASTStmtReader Reader(*this, F, Cursor, Record, Idx);
  Stmt::EmptyShell Empty;

  while (true) {
    llvm::BitstreamEntry Entry = Cursor.advanceSkippingSubblocks();
    
    switch (Entry.Kind) {
    case llvm::BitstreamEntry::SubBlock: // Handled for us already.
    case llvm::BitstreamEntry::Error:
      Error("malformed block record in AST file");
      return nullptr;
    case llvm::BitstreamEntry::EndBlock:
      goto Done;
    case llvm::BitstreamEntry::Record:
      // The interesting case.
      break;
    }

    Stmt *S = nullptr;
    Idx = 0;
    Record.clear();
    bool Finished = false;
    bool IsStmtReference = false;
    switch ((StmtCode)Cursor.readRecord(Entry.ID, Record)) {
    case STMT_STOP:
      Finished = true;
      break;

    case STMT_REF_PTR:
      IsStmtReference = true;
      assert(StmtEntries.find(Record[0]) != StmtEntries.end() &&
             "No stmt was recorded for this offset reference!");
      S = StmtEntries[Record[Idx++]];
      break;

    case STMT_NULL_PTR:
      S = nullptr;
      break;

    case STMT_NULL:
      S = new (Context) NullStmt(Empty);
      break;

    case STMT_COMPOUND:
      S = new (Context) CompoundStmt(Empty);
      break;

    case STMT_CASE:
      S = new (Context) CaseStmt(Empty);
      break;

    case STMT_DEFAULT:
      S = new (Context) DefaultStmt(Empty);
      break;

    case STMT_LABEL:
      S = new (Context) LabelStmt(Empty);
      break;

    case STMT_ATTRIBUTED:
      S = AttributedStmt::CreateEmpty(
        Context,
        /*NumAttrs*/Record[ASTStmtReader::NumStmtFields]);
      break;

    case STMT_IF:
      S = new (Context) IfStmt(Empty);
      break;

    case STMT_SWITCH:
      S = new (Context) SwitchStmt(Empty);
      break;

    case STMT_WHILE:
      S = new (Context) WhileStmt(Empty);
      break;

    case STMT_DO:
      S = new (Context) DoStmt(Empty);
      break;

    case STMT_FOR:
      S = new (Context) ForStmt(Empty);
      break;

    case STMT_GOTO:
      S = new (Context) GotoStmt(Empty);
      break;

    case STMT_INDIRECT_GOTO:
      S = new (Context) IndirectGotoStmt(Empty);
      break;

    case STMT_CONTINUE:
      S = new (Context) ContinueStmt(Empty);
      break;

    case STMT_BREAK:
      S = new (Context) BreakStmt(Empty);
      break;

    case STMT_RETURN:
      S = new (Context) ReturnStmt(Empty);
      break;

    case STMT_DECL:
      S = new (Context) DeclStmt(Empty);
      break;

    case STMT_GCCASM:
      S = new (Context) GCCAsmStmt(Empty);
      break;

    case STMT_MSASM:
      S = new (Context) MSAsmStmt(Empty);
      break;

    case STMT_CAPTURED:
      S = CapturedStmt::CreateDeserialized(Context,
                                           Record[ASTStmtReader::NumStmtFields]);
      break;

    case EXPR_PREDEFINED:
      S = new (Context) PredefinedExpr(Empty);
      break;

    case EXPR_DECL_REF:
      S = DeclRefExpr::CreateEmpty(
        Context,
        /*HasQualifier=*/Record[ASTStmtReader::NumExprFields],
        /*HasFoundDecl=*/Record[ASTStmtReader::NumExprFields + 1],
        /*HasTemplateKWAndArgsInfo=*/Record[ASTStmtReader::NumExprFields + 2],
        /*NumTemplateArgs=*/Record[ASTStmtReader::NumExprFields + 2] ?
          Record[ASTStmtReader::NumExprFields + 5] : 0);
      break;

    case EXPR_INTEGER_LITERAL:
      S = IntegerLiteral::Create(Context, Empty);
      break;

    case EXPR_FLOATING_LITERAL:
      S = FloatingLiteral::Create(Context, Empty);
      break;

    case EXPR_IMAGINARY_LITERAL:
      S = new (Context) ImaginaryLiteral(Empty);
      break;

    case EXPR_STRING_LITERAL:
      S = StringLiteral::CreateEmpty(Context,
                                     Record[ASTStmtReader::NumExprFields + 1]);
      break;

    case EXPR_CHARACTER_LITERAL:
      S = new (Context) CharacterLiteral(Empty);
      break;

    case EXPR_PAREN:
      S = new (Context) ParenExpr(Empty);
      break;

    case EXPR_PAREN_LIST:
      S = new (Context) ParenListExpr(Empty);
      break;

    case EXPR_UNARY_OPERATOR:
      S = new (Context) UnaryOperator(Empty);
      break;

    case EXPR_OFFSETOF:
      S = OffsetOfExpr::CreateEmpty(Context, 
                                    Record[ASTStmtReader::NumExprFields],
                                    Record[ASTStmtReader::NumExprFields + 1]);
      break;
        
    case EXPR_SIZEOF_ALIGN_OF:
      S = new (Context) UnaryExprOrTypeTraitExpr(Empty);
      break;

    case EXPR_ARRAY_SUBSCRIPT:
      S = new (Context) ArraySubscriptExpr(Empty);
      break;

    case EXPR_OMP_ARRAY_SECTION:
      S = new (Context) OMPArraySectionExpr(Empty);
      break;

    case EXPR_CALL:
      S = new (Context) CallExpr(Context, Stmt::CallExprClass, Empty);
      break;

    case EXPR_MEMBER: {
      // We load everything here and fully initialize it at creation.
      // That way we can use MemberExpr::Create and don't have to duplicate its
      // logic with a MemberExpr::CreateEmpty.

      assert(Idx == 0);
      NestedNameSpecifierLoc QualifierLoc;
      if (Record[Idx++]) { // HasQualifier.
        QualifierLoc = ReadNestedNameSpecifierLoc(F, Record, Idx);
      }

      SourceLocation TemplateKWLoc;
      TemplateArgumentListInfo ArgInfo;
      bool HasTemplateKWAndArgsInfo = Record[Idx++];
      if (HasTemplateKWAndArgsInfo) {
        TemplateKWLoc = ReadSourceLocation(F, Record, Idx);
        unsigned NumTemplateArgs = Record[Idx++];
        ArgInfo.setLAngleLoc(ReadSourceLocation(F, Record, Idx));
        ArgInfo.setRAngleLoc(ReadSourceLocation(F, Record, Idx));
        for (unsigned i = 0; i != NumTemplateArgs; ++i)
          ArgInfo.addArgument(ReadTemplateArgumentLoc(F, Record, Idx));
      }

      bool HadMultipleCandidates = Record[Idx++];

      NamedDecl *FoundD = ReadDeclAs<NamedDecl>(F, Record, Idx);
      AccessSpecifier AS = (AccessSpecifier)Record[Idx++];
      DeclAccessPair FoundDecl = DeclAccessPair::make(FoundD, AS);

      QualType T = readType(F, Record, Idx);
      ExprValueKind VK = static_cast<ExprValueKind>(Record[Idx++]);
      ExprObjectKind OK = static_cast<ExprObjectKind>(Record[Idx++]);
      Expr *Base = ReadSubExpr();
      ValueDecl *MemberD = ReadDeclAs<ValueDecl>(F, Record, Idx);
      SourceLocation MemberLoc = ReadSourceLocation(F, Record, Idx);
      DeclarationNameInfo MemberNameInfo(MemberD->getDeclName(), MemberLoc);
      bool IsArrow = Record[Idx++];
      SourceLocation OperatorLoc = ReadSourceLocation(F, Record, Idx);

      S = MemberExpr::Create(Context, Base, IsArrow, OperatorLoc, QualifierLoc,
                             TemplateKWLoc, MemberD, FoundDecl, MemberNameInfo,
                             HasTemplateKWAndArgsInfo ? &ArgInfo : nullptr, T,
                             VK, OK);
      ReadDeclarationNameLoc(F, cast<MemberExpr>(S)->MemberDNLoc,
                             MemberD->getDeclName(), Record, Idx);
      if (HadMultipleCandidates)
        cast<MemberExpr>(S)->setHadMultipleCandidates(true);
      break;
    }

    case EXPR_BINARY_OPERATOR:
      S = new (Context) BinaryOperator(Empty);
      break;

    case EXPR_COMPOUND_ASSIGN_OPERATOR:
      S = new (Context) CompoundAssignOperator(Empty);
      break;

    case EXPR_CONDITIONAL_OPERATOR:
      S = new (Context) ConditionalOperator(Empty);
      break;

    case EXPR_BINARY_CONDITIONAL_OPERATOR:
      S = new (Context) BinaryConditionalOperator(Empty);
      break;

    case EXPR_IMPLICIT_CAST:
      S = ImplicitCastExpr::CreateEmpty(Context,
                       /*PathSize*/ Record[ASTStmtReader::NumExprFields]);
      break;

    case EXPR_CSTYLE_CAST:
      S = CStyleCastExpr::CreateEmpty(Context,
                       /*PathSize*/ Record[ASTStmtReader::NumExprFields]);
      break;

    case EXPR_COMPOUND_LITERAL:
      S = new (Context) CompoundLiteralExpr(Empty);
      break;

    case EXPR_EXT_VECTOR_ELEMENT:
      S = new (Context) ExtVectorElementExpr(Empty);
      break;

    case EXPR_INIT_LIST:
      S = new (Context) InitListExpr(Empty);
      break;

    case EXPR_DESIGNATED_INIT:
      S = DesignatedInitExpr::CreateEmpty(Context,
                                     Record[ASTStmtReader::NumExprFields] - 1);

      break;

    case EXPR_DESIGNATED_INIT_UPDATE:
      S = new (Context) DesignatedInitUpdateExpr(Empty);
      break;

    case EXPR_IMPLICIT_VALUE_INIT:
      S = new (Context) ImplicitValueInitExpr(Empty);
      break;

    case EXPR_NO_INIT:
      S = new (Context) NoInitExpr(Empty);
      break;

    case EXPR_VA_ARG:
      S = new (Context) VAArgExpr(Empty);
      break;

    case EXPR_ADDR_LABEL:
      S = new (Context) AddrLabelExpr(Empty);
      break;

    case EXPR_STMT:
      S = new (Context) StmtExpr(Empty);
      break;

    case EXPR_CHOOSE:
      S = new (Context) ChooseExpr(Empty);
      break;

    case EXPR_GNU_NULL:
      S = new (Context) GNUNullExpr(Empty);
      break;

    case EXPR_SHUFFLE_VECTOR:
      S = new (Context) ShuffleVectorExpr(Empty);
      break;

    case EXPR_CONVERT_VECTOR:
      S = new (Context) ConvertVectorExpr(Empty);
      break;

    case EXPR_BLOCK:
      S = new (Context) BlockExpr(Empty);
      break;

    case EXPR_GENERIC_SELECTION:
      S = new (Context) GenericSelectionExpr(Empty);
      break;

    case EXPR_OBJC_STRING_LITERAL:
      S = new (Context) ObjCStringLiteral(Empty);
      break;
    case EXPR_OBJC_BOXED_EXPRESSION:
      S = new (Context) ObjCBoxedExpr(Empty);
      break;
    case EXPR_OBJC_ARRAY_LITERAL:
      S = ObjCArrayLiteral::CreateEmpty(Context,
                                        Record[ASTStmtReader::NumExprFields]);
      break;
    case EXPR_OBJC_DICTIONARY_LITERAL:
      S = ObjCDictionaryLiteral::CreateEmpty(Context,
            Record[ASTStmtReader::NumExprFields],
            Record[ASTStmtReader::NumExprFields + 1]);
      break;
    case EXPR_OBJC_ENCODE:
      S = new (Context) ObjCEncodeExpr(Empty);
      break;
    case EXPR_OBJC_SELECTOR_EXPR:
      S = new (Context) ObjCSelectorExpr(Empty);
      break;
    case EXPR_OBJC_PROTOCOL_EXPR:
      S = new (Context) ObjCProtocolExpr(Empty);
      break;
    case EXPR_OBJC_IVAR_REF_EXPR:
      S = new (Context) ObjCIvarRefExpr(Empty);
      break;
    case EXPR_OBJC_PROPERTY_REF_EXPR:
      S = new (Context) ObjCPropertyRefExpr(Empty);
      break;
    case EXPR_OBJC_SUBSCRIPT_REF_EXPR:
      S = new (Context) ObjCSubscriptRefExpr(Empty);
      break;
    case EXPR_OBJC_KVC_REF_EXPR:
      llvm_unreachable("mismatching AST file");
    case EXPR_OBJC_MESSAGE_EXPR:
      S = ObjCMessageExpr::CreateEmpty(Context,
                                     Record[ASTStmtReader::NumExprFields],
                                     Record[ASTStmtReader::NumExprFields + 1]);
      break;
    case EXPR_OBJC_ISA:
      S = new (Context) ObjCIsaExpr(Empty);
      break;
    case EXPR_OBJC_INDIRECT_COPY_RESTORE:
      S = new (Context) ObjCIndirectCopyRestoreExpr(Empty);
      break;
    case EXPR_OBJC_BRIDGED_CAST:
      S = new (Context) ObjCBridgedCastExpr(Empty);
      break;
    case STMT_OBJC_FOR_COLLECTION:
      S = new (Context) ObjCForCollectionStmt(Empty);
      break;
    case STMT_OBJC_CATCH:
      S = new (Context) ObjCAtCatchStmt(Empty);
      break;
    case STMT_OBJC_FINALLY:
      S = new (Context) ObjCAtFinallyStmt(Empty);
      break;
    case STMT_OBJC_AT_TRY:
      S = ObjCAtTryStmt::CreateEmpty(Context, 
                                     Record[ASTStmtReader::NumStmtFields],
                                     Record[ASTStmtReader::NumStmtFields + 1]);
      break;
    case STMT_OBJC_AT_SYNCHRONIZED:
      S = new (Context) ObjCAtSynchronizedStmt(Empty);
      break;
    case STMT_OBJC_AT_THROW:
      S = new (Context) ObjCAtThrowStmt(Empty);
      break;
    case STMT_OBJC_AUTORELEASE_POOL:
      S = new (Context) ObjCAutoreleasePoolStmt(Empty);
      break;
    case EXPR_OBJC_BOOL_LITERAL:
      S = new (Context) ObjCBoolLiteralExpr(Empty);
      break;
    case STMT_SEH_LEAVE:
      S = new (Context) SEHLeaveStmt(Empty);
      break;
    case STMT_SEH_EXCEPT:
      S = new (Context) SEHExceptStmt(Empty);
      break;
    case STMT_SEH_FINALLY:
      S = new (Context) SEHFinallyStmt(Empty);
      break;
    case STMT_SEH_TRY:
      S = new (Context) SEHTryStmt(Empty);
      break;
    case STMT_CXX_CATCH:
      S = new (Context) CXXCatchStmt(Empty);
      break;

    case STMT_CXX_TRY:
      S = CXXTryStmt::Create(Context, Empty,
             /*NumHandlers=*/Record[ASTStmtReader::NumStmtFields]);
      break;

    case STMT_CXX_FOR_RANGE:
      S = new (Context) CXXForRangeStmt(Empty);
      break;

    case STMT_MS_DEPENDENT_EXISTS:
      S = new (Context) MSDependentExistsStmt(SourceLocation(), true,
                                              NestedNameSpecifierLoc(),
                                              DeclarationNameInfo(),
                                              nullptr);
      break;

    case STMT_OMP_PARALLEL_DIRECTIVE:
      S =
        OMPParallelDirective::CreateEmpty(Context,
                                          Record[ASTStmtReader::NumStmtFields],
                                          Empty);
      break;

    case STMT_OMP_SIMD_DIRECTIVE: {
      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields];
      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
      S = OMPSimdDirective::CreateEmpty(Context, NumClauses,
                                        CollapsedNum, Empty);
      break;
    }

    case STMT_OMP_FOR_DIRECTIVE: {
      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields];
      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
      S = OMPForDirective::CreateEmpty(Context, NumClauses, CollapsedNum,
                                       Empty);
      break;
    }

    case STMT_OMP_FOR_SIMD_DIRECTIVE: {
      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields];
      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
      S = OMPForSimdDirective::CreateEmpty(Context, NumClauses, CollapsedNum,
                                           Empty);
      break;
    }

    case STMT_OMP_SECTIONS_DIRECTIVE:
      S = OMPSectionsDirective::CreateEmpty(
          Context, Record[ASTStmtReader::NumStmtFields], Empty);
      break;

    case STMT_OMP_SECTION_DIRECTIVE:
      S = OMPSectionDirective::CreateEmpty(Context, Empty);
      break;

    case STMT_OMP_SINGLE_DIRECTIVE:
      S = OMPSingleDirective::CreateEmpty(
          Context, Record[ASTStmtReader::NumStmtFields], Empty);
      break;

    case STMT_OMP_MASTER_DIRECTIVE:
      S = OMPMasterDirective::CreateEmpty(Context, Empty);
      break;

    case STMT_OMP_CRITICAL_DIRECTIVE:
      S = OMPCriticalDirective::CreateEmpty(
          Context, Record[ASTStmtReader::NumStmtFields], Empty);
      break;

    case STMT_OMP_PARALLEL_FOR_DIRECTIVE: {
      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields];
      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
      S = OMPParallelForDirective::CreateEmpty(Context, NumClauses,
                                               CollapsedNum, Empty);
      break;
    }

    case STMT_OMP_PARALLEL_FOR_SIMD_DIRECTIVE: {
      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields];
      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
      S = OMPParallelForSimdDirective::CreateEmpty(Context, NumClauses,
                                                   CollapsedNum, Empty);
      break;
    }

    case STMT_OMP_PARALLEL_SECTIONS_DIRECTIVE:
      S = OMPParallelSectionsDirective::CreateEmpty(
          Context, Record[ASTStmtReader::NumStmtFields], Empty);
      break;

    case STMT_OMP_TASK_DIRECTIVE:
      S = OMPTaskDirective::CreateEmpty(
          Context, Record[ASTStmtReader::NumStmtFields], Empty);
      break;

    case STMT_OMP_TASKYIELD_DIRECTIVE:
      S = OMPTaskyieldDirective::CreateEmpty(Context, Empty);
      break;

    case STMT_OMP_BARRIER_DIRECTIVE:
      S = OMPBarrierDirective::CreateEmpty(Context, Empty);
      break;

    case STMT_OMP_TASKWAIT_DIRECTIVE:
      S = OMPTaskwaitDirective::CreateEmpty(Context, Empty);
      break;

    case STMT_OMP_TASKGROUP_DIRECTIVE:
      S = OMPTaskgroupDirective::CreateEmpty(Context, Empty);
      break;

    case STMT_OMP_FLUSH_DIRECTIVE:
      S = OMPFlushDirective::CreateEmpty(
          Context, Record[ASTStmtReader::NumStmtFields], Empty);
      break;

    case STMT_OMP_ORDERED_DIRECTIVE:
      S = OMPOrderedDirective::CreateEmpty(
          Context, Record[ASTStmtReader::NumStmtFields], Empty);
      break;

    case STMT_OMP_ATOMIC_DIRECTIVE:
      S = OMPAtomicDirective::CreateEmpty(
          Context, Record[ASTStmtReader::NumStmtFields], Empty);
      break;

    case STMT_OMP_TARGET_DIRECTIVE:
      S = OMPTargetDirective::CreateEmpty(
          Context, Record[ASTStmtReader::NumStmtFields], Empty);
      break;

    case STMT_OMP_TARGET_DATA_DIRECTIVE:
      S = OMPTargetDataDirective::CreateEmpty(
          Context, Record[ASTStmtReader::NumStmtFields], Empty);
      break;

    case STMT_OMP_TEAMS_DIRECTIVE:
      S = OMPTeamsDirective::CreateEmpty(
          Context, Record[ASTStmtReader::NumStmtFields], Empty);
      break;

    case STMT_OMP_CANCELLATION_POINT_DIRECTIVE:
      S = OMPCancellationPointDirective::CreateEmpty(Context, Empty);
      break;

    case STMT_OMP_CANCEL_DIRECTIVE:
      S = OMPCancelDirective::CreateEmpty(
          Context, Record[ASTStmtReader::NumStmtFields], Empty);
      break;

    case STMT_OMP_TASKLOOP_DIRECTIVE: {
      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields];
      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
      S = OMPTaskLoopDirective::CreateEmpty(Context, NumClauses, CollapsedNum,
                                            Empty);
      break;
    }

    case STMT_OMP_TASKLOOP_SIMD_DIRECTIVE: {
      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields];
      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
      S = OMPTaskLoopSimdDirective::CreateEmpty(Context, NumClauses,
                                                CollapsedNum, Empty);
      break;
    }

    case STMT_OMP_DISTRIBUTE_DIRECTIVE: {
      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields];
      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
      S = OMPDistributeDirective::CreateEmpty(Context, NumClauses, CollapsedNum,
                                              Empty);
      break;
    }

    case EXPR_CXX_OPERATOR_CALL:
      S = new (Context) CXXOperatorCallExpr(Context, Empty);
      break;

    case EXPR_CXX_MEMBER_CALL:
      S = new (Context) CXXMemberCallExpr(Context, Empty);
      break;

    case EXPR_CXX_CONSTRUCT:
      S = new (Context) CXXConstructExpr(Empty);
      break;

    case EXPR_CXX_TEMPORARY_OBJECT:
      S = new (Context) CXXTemporaryObjectExpr(Empty);
      break;

    case EXPR_CXX_STATIC_CAST:
      S = CXXStaticCastExpr::CreateEmpty(Context,
                       /*PathSize*/ Record[ASTStmtReader::NumExprFields]);
      break;

    case EXPR_CXX_DYNAMIC_CAST:
      S = CXXDynamicCastExpr::CreateEmpty(Context,
                       /*PathSize*/ Record[ASTStmtReader::NumExprFields]);
      break;

    case EXPR_CXX_REINTERPRET_CAST:
      S = CXXReinterpretCastExpr::CreateEmpty(Context,
                       /*PathSize*/ Record[ASTStmtReader::NumExprFields]);
      break;

    case EXPR_CXX_CONST_CAST:
      S = CXXConstCastExpr::CreateEmpty(Context);
      break;

    case EXPR_CXX_FUNCTIONAL_CAST:
      S = CXXFunctionalCastExpr::CreateEmpty(Context,
                       /*PathSize*/ Record[ASTStmtReader::NumExprFields]);
      break;

    case EXPR_USER_DEFINED_LITERAL:
      S = new (Context) UserDefinedLiteral(Context, Empty);
      break;

    case EXPR_CXX_STD_INITIALIZER_LIST:
      S = new (Context) CXXStdInitializerListExpr(Empty);
      break;

    case EXPR_CXX_BOOL_LITERAL:
      S = new (Context) CXXBoolLiteralExpr(Empty);
      break;

    case EXPR_CXX_NULL_PTR_LITERAL:
      S = new (Context) CXXNullPtrLiteralExpr(Empty);
      break;
    case EXPR_CXX_TYPEID_EXPR:
      S = new (Context) CXXTypeidExpr(Empty, true);
      break;
    case EXPR_CXX_TYPEID_TYPE:
      S = new (Context) CXXTypeidExpr(Empty, false);
      break;
    case EXPR_CXX_UUIDOF_EXPR:
      S = new (Context) CXXUuidofExpr(Empty, true);
      break;
    case EXPR_CXX_PROPERTY_REF_EXPR:
      S = new (Context) MSPropertyRefExpr(Empty);
      break;
    case EXPR_CXX_PROPERTY_SUBSCRIPT_EXPR:
      S = new (Context) MSPropertySubscriptExpr(Empty);
      break;
    case EXPR_CXX_UUIDOF_TYPE:
      S = new (Context) CXXUuidofExpr(Empty, false);
      break;
    case EXPR_CXX_THIS:
      S = new (Context) CXXThisExpr(Empty);
      break;
    case EXPR_CXX_THROW:
      S = new (Context) CXXThrowExpr(Empty);
      break;
    case EXPR_CXX_DEFAULT_ARG:
      S = new (Context) CXXDefaultArgExpr(Empty);
      break;
    case EXPR_CXX_DEFAULT_INIT:
      S = new (Context) CXXDefaultInitExpr(Empty);
      break;
    case EXPR_CXX_BIND_TEMPORARY:
      S = new (Context) CXXBindTemporaryExpr(Empty);
      break;
        
    case EXPR_CXX_SCALAR_VALUE_INIT:
      S = new (Context) CXXScalarValueInitExpr(Empty);
      break;
    case EXPR_CXX_NEW:
      S = new (Context) CXXNewExpr(Empty);
      break;
    case EXPR_CXX_DELETE:
      S = new (Context) CXXDeleteExpr(Empty);
      break;
    case EXPR_CXX_PSEUDO_DESTRUCTOR:
      S = new (Context) CXXPseudoDestructorExpr(Empty);
      break;
        
    case EXPR_EXPR_WITH_CLEANUPS:
      S = ExprWithCleanups::Create(Context, Empty,
                                   Record[ASTStmtReader::NumExprFields]);
      break;
      
    case EXPR_CXX_DEPENDENT_SCOPE_MEMBER:
      S = CXXDependentScopeMemberExpr::CreateEmpty(Context,
         /*HasTemplateKWAndArgsInfo=*/Record[ASTStmtReader::NumExprFields],
                  /*NumTemplateArgs=*/Record[ASTStmtReader::NumExprFields]
                                   ? Record[ASTStmtReader::NumExprFields + 1] 
                                   : 0);
      break;
      
    case EXPR_CXX_DEPENDENT_SCOPE_DECL_REF:
      S = DependentScopeDeclRefExpr::CreateEmpty(Context,
         /*HasTemplateKWAndArgsInfo=*/Record[ASTStmtReader::NumExprFields],
                  /*NumTemplateArgs=*/Record[ASTStmtReader::NumExprFields]
                                   ? Record[ASTStmtReader::NumExprFields + 1] 
                                   : 0);
      break;
      
    case EXPR_CXX_UNRESOLVED_CONSTRUCT:
      S = CXXUnresolvedConstructExpr::CreateEmpty(Context,
                              /*NumArgs=*/Record[ASTStmtReader::NumExprFields]);
      break;
      
    case EXPR_CXX_UNRESOLVED_MEMBER:
      S = UnresolvedMemberExpr::CreateEmpty(Context,
         /*HasTemplateKWAndArgsInfo=*/Record[ASTStmtReader::NumExprFields],
                  /*NumTemplateArgs=*/Record[ASTStmtReader::NumExprFields]
                                   ? Record[ASTStmtReader::NumExprFields + 1] 
                                   : 0);
      break;
      
    case EXPR_CXX_UNRESOLVED_LOOKUP:
      S = UnresolvedLookupExpr::CreateEmpty(Context,
         /*HasTemplateKWAndArgsInfo=*/Record[ASTStmtReader::NumExprFields],
                  /*NumTemplateArgs=*/Record[ASTStmtReader::NumExprFields]
                                   ? Record[ASTStmtReader::NumExprFields + 1] 
                                   : 0);
      break;

    case EXPR_TYPE_TRAIT:
      S = TypeTraitExpr::CreateDeserialized(Context, 
            Record[ASTStmtReader::NumExprFields]);
      break;
        
    case EXPR_ARRAY_TYPE_TRAIT:
      S = new (Context) ArrayTypeTraitExpr(Empty);
      break;

    case EXPR_CXX_EXPRESSION_TRAIT:
      S = new (Context) ExpressionTraitExpr(Empty);
      break;

    case EXPR_CXX_NOEXCEPT:
      S = new (Context) CXXNoexceptExpr(Empty);
      break;

    case EXPR_PACK_EXPANSION:
      S = new (Context) PackExpansionExpr(Empty);
      break;
        
    case EXPR_SIZEOF_PACK:
      S = SizeOfPackExpr::CreateDeserialized(
              Context,
              /*NumPartialArgs=*/Record[ASTStmtReader::NumExprFields]);
      break;
        
    case EXPR_SUBST_NON_TYPE_TEMPLATE_PARM:
      S = new (Context) SubstNonTypeTemplateParmExpr(Empty);
      break;
        
    case EXPR_SUBST_NON_TYPE_TEMPLATE_PARM_PACK:
      S = new (Context) SubstNonTypeTemplateParmPackExpr(Empty);
      break;

    case EXPR_FUNCTION_PARM_PACK:
      S = FunctionParmPackExpr::CreateEmpty(Context,
                                          Record[ASTStmtReader::NumExprFields]);
      break;
        
    case EXPR_MATERIALIZE_TEMPORARY:
      S = new (Context) MaterializeTemporaryExpr(Empty);
      break;

    case EXPR_CXX_FOLD:
      S = new (Context) CXXFoldExpr(Empty);
      break;

    case EXPR_OPAQUE_VALUE:
      S = new (Context) OpaqueValueExpr(Empty);
      break;

    case EXPR_CUDA_KERNEL_CALL:
      S = new (Context) CUDAKernelCallExpr(Context, Empty);
      break;
        
    case EXPR_ASTYPE:
      S = new (Context) AsTypeExpr(Empty);
      break;

    case EXPR_PSEUDO_OBJECT: {
      unsigned numSemanticExprs = Record[ASTStmtReader::NumExprFields];
      S = PseudoObjectExpr::Create(Context, Empty, numSemanticExprs);
      break;
    }

    case EXPR_ATOMIC:
      S = new (Context) AtomicExpr(Empty);
      break;
        
    case EXPR_LAMBDA: {
      unsigned NumCaptures = Record[ASTStmtReader::NumExprFields];
      unsigned NumArrayIndexVars = Record[ASTStmtReader::NumExprFields + 1];
      S = LambdaExpr::CreateDeserialized(Context, NumCaptures, 
                                         NumArrayIndexVars);
      break;
    }
    }
    
    // We hit a STMT_STOP, so we're done with this expression.
    if (Finished)
      break;

    ++NumStatementsRead;

    if (S && !IsStmtReference) {
      Reader.Visit(S);
      StmtEntries[Cursor.GetCurrentBitNo()] = S;
    }


    assert(Idx == Record.size() && "Invalid deserialization of statement");
    StmtStack.push_back(S);
  }
Done:
  assert(StmtStack.size() > PrevNumStmts && "Read too many sub-stmts!");
  assert(StmtStack.size() == PrevNumStmts + 1 && "Extra expressions on stack!");
  return StmtStack.pop_back_val();
}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@a186 2
  S->setConstexpr(Record[Idx++]);
  S->setInit(Reader.ReadSubStmt());
a197 1
  S->setInit(Reader.ReadSubStmt());
a1181 8
void ASTStmtReader::VisitObjCAvailabilityCheckExpr(ObjCAvailabilityCheckExpr *E) {
  VisitExpr(E);
  SourceRange R = Reader.ReadSourceRange(F, Record, Idx);
  E->AtLoc = R.getBegin();
  E->RParen = R.getEnd();
  E->VersionToCheck = Reader.ReadVersionTuple(Record, Idx);
}

d1210 1
a1210 2
  S->setBeginStmt(Reader.ReadSubStmt());
  S->setEndStmt(Reader.ReadSubStmt());
a1250 8
void ASTStmtReader::VisitCXXInheritedCtorInitExpr(CXXInheritedCtorInitExpr *E) {
  VisitExpr(E);
  E->Constructor = ReadDeclAs<CXXConstructorDecl>(Record, Idx);
  E->Loc = ReadSourceLocation(Record, Idx);
  E->ConstructsVirtualBase = Record[Idx++];
  E->InheritedFromVirtualBase = Record[Idx++];
}

a1449 1
  E->ExprWithCleanupsBits.CleanupsHaveSideEffects = Record[Idx++];
a1681 2
  std::string UuidStr = ReadString(Record, Idx);
  E->setUuidStr(StringRef(UuidStr).copy(Reader.getContext()));
d1751 2
a1752 1
#define OPENMP_CLAUSE(Name, Class) void Visit##Class(Class *C);
a1754 2
  void VisitOMPClauseWithPreInit(OMPClauseWithPreInit *C);
  void VisitOMPClauseWithPostUpdate(OMPClauseWithPostUpdate *C);
d1860 2
a1861 7
  case OMPC_map: {
    unsigned NumVars = Record[Idx++];
    unsigned NumDeclarations = Record[Idx++];
    unsigned NumLists = Record[Idx++];
    unsigned NumComponents = Record[Idx++];
    C = OMPMapClause::CreateEmpty(Context, NumVars, NumDeclarations, NumLists,
                                  NumComponents);
a1862 1
  }
a1880 30
  case OMPC_dist_schedule:
    C = new (Context) OMPDistScheduleClause();
    break;
  case OMPC_defaultmap:
    C = new (Context) OMPDefaultmapClause();
    break;
  case OMPC_to: {
    unsigned NumVars = Record[Idx++];
    unsigned NumDeclarations = Record[Idx++];
    unsigned NumLists = Record[Idx++];
    unsigned NumComponents = Record[Idx++];
    C = OMPToClause::CreateEmpty(Context, NumVars, NumDeclarations, NumLists,
                                 NumComponents);
    break;
  }
  case OMPC_from: {
    unsigned NumVars = Record[Idx++];
    unsigned NumDeclarations = Record[Idx++];
    unsigned NumLists = Record[Idx++];
    unsigned NumComponents = Record[Idx++];
    C = OMPFromClause::CreateEmpty(Context, NumVars, NumDeclarations, NumLists,
                                   NumComponents);
    break;
  }
  case OMPC_use_device_ptr:
    C = OMPUseDevicePtrClause::CreateEmpty(Context, Record[Idx++]);
    break;
  case OMPC_is_device_ptr:
    C = OMPIsDevicePtrClause::CreateEmpty(Context, Record[Idx++]);
    break;
a1888 9
void OMPClauseReader::VisitOMPClauseWithPreInit(OMPClauseWithPreInit *C) {
  C->setPreInitStmt(Reader->Reader.ReadSubStmt());
}

void OMPClauseReader::VisitOMPClauseWithPostUpdate(OMPClauseWithPostUpdate *C) {
  VisitOMPClauseWithPreInit(C);
  C->setPostUpdateExpr(Reader->Reader.ReadSubExpr());
}

a1936 1
  VisitOMPClauseWithPreInit(C);
d1944 1
a1993 1
  VisitOMPClauseWithPreInit(C);
a2011 1
  VisitOMPClauseWithPostUpdate(C);
a2047 1
  VisitOMPClauseWithPostUpdate(C);
a2081 1
  VisitOMPClauseWithPostUpdate(C);
a2188 1
  C->setCounterValue(Reader->Reader.ReadSubExpr());
a2204 4
  auto UniqueDecls = C->getUniqueDeclarationsNum();
  auto TotalLists = C->getTotalComponentListNum();
  auto TotalComponents = C->getTotalComponentsNum();

d2207 1
a2207 1
  for (unsigned i = 0; i != NumVars; ++i)
d2209 1
a2210 30

  SmallVector<ValueDecl *, 16> Decls;
  Decls.reserve(UniqueDecls);
  for (unsigned i = 0; i < UniqueDecls; ++i)
    Decls.push_back(
        Reader->Reader.ReadDeclAs<ValueDecl>(Reader->F, Record, Idx));
  C->setUniqueDecls(Decls);

  SmallVector<unsigned, 16> ListsPerDecl;
  ListsPerDecl.reserve(UniqueDecls);
  for (unsigned i = 0; i < UniqueDecls; ++i)
    ListsPerDecl.push_back(Record[Idx++]);
  C->setDeclNumLists(ListsPerDecl);

  SmallVector<unsigned, 32> ListSizes;
  ListSizes.reserve(TotalLists);
  for (unsigned i = 0; i < TotalLists; ++i)
    ListSizes.push_back(Record[Idx++]);
  C->setComponentListSizes(ListSizes);

  SmallVector<OMPClauseMappableExprCommon::MappableComponent, 32> Components;
  Components.reserve(TotalComponents);
  for (unsigned i = 0; i < TotalComponents; ++i) {
    Expr *AssociatedExpr = Reader->Reader.ReadSubExpr();
    ValueDecl *AssociatedDecl =
        Reader->Reader.ReadDeclAs<ValueDecl>(Reader->F, Record, Idx);
    Components.push_back(OMPClauseMappableExprCommon::MappableComponent(
        AssociatedExpr, AssociatedDecl));
  }
  C->setComponents(Components, ListSizes);
a2242 130
void OMPClauseReader::VisitOMPDistScheduleClause(OMPDistScheduleClause *C) {
  VisitOMPClauseWithPreInit(C);
  C->setDistScheduleKind(
      static_cast<OpenMPDistScheduleClauseKind>(Record[Idx++]));
  C->setChunkSize(Reader->Reader.ReadSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
  C->setDistScheduleKindLoc(Reader->ReadSourceLocation(Record, Idx));
  C->setCommaLoc(Reader->ReadSourceLocation(Record, Idx));
}

void OMPClauseReader::VisitOMPDefaultmapClause(OMPDefaultmapClause *C) {
  C->setDefaultmapKind(
       static_cast<OpenMPDefaultmapClauseKind>(Record[Idx++]));
  C->setDefaultmapModifier(
      static_cast<OpenMPDefaultmapClauseModifier>(Record[Idx++]));
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
  C->setDefaultmapModifierLoc(Reader->ReadSourceLocation(Record, Idx));
  C->setDefaultmapKindLoc(Reader->ReadSourceLocation(Record, Idx));
}

void OMPClauseReader::VisitOMPToClause(OMPToClause *C) {
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
  auto NumVars = C->varlist_size();
  auto UniqueDecls = C->getUniqueDeclarationsNum();
  auto TotalLists = C->getTotalComponentListNum();
  auto TotalComponents = C->getTotalComponentsNum();

  SmallVector<Expr *, 16> Vars;
  Vars.reserve(NumVars);
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setVarRefs(Vars);

  SmallVector<ValueDecl *, 16> Decls;
  Decls.reserve(UniqueDecls);
  for (unsigned i = 0; i < UniqueDecls; ++i)
    Decls.push_back(
        Reader->Reader.ReadDeclAs<ValueDecl>(Reader->F, Record, Idx));
  C->setUniqueDecls(Decls);

  SmallVector<unsigned, 16> ListsPerDecl;
  ListsPerDecl.reserve(UniqueDecls);
  for (unsigned i = 0; i < UniqueDecls; ++i)
    ListsPerDecl.push_back(Record[Idx++]);
  C->setDeclNumLists(ListsPerDecl);

  SmallVector<unsigned, 32> ListSizes;
  ListSizes.reserve(TotalLists);
  for (unsigned i = 0; i < TotalLists; ++i)
    ListSizes.push_back(Record[Idx++]);
  C->setComponentListSizes(ListSizes);

  SmallVector<OMPClauseMappableExprCommon::MappableComponent, 32> Components;
  Components.reserve(TotalComponents);
  for (unsigned i = 0; i < TotalComponents; ++i) {
    Expr *AssociatedExpr = Reader->Reader.ReadSubExpr();
    ValueDecl *AssociatedDecl =
        Reader->Reader.ReadDeclAs<ValueDecl>(Reader->F, Record, Idx);
    Components.push_back(OMPClauseMappableExprCommon::MappableComponent(
        AssociatedExpr, AssociatedDecl));
  }
  C->setComponents(Components, ListSizes);
}

void OMPClauseReader::VisitOMPFromClause(OMPFromClause *C) {
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
  auto NumVars = C->varlist_size();
  auto UniqueDecls = C->getUniqueDeclarationsNum();
  auto TotalLists = C->getTotalComponentListNum();
  auto TotalComponents = C->getTotalComponentsNum();

  SmallVector<Expr *, 16> Vars;
  Vars.reserve(NumVars);
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setVarRefs(Vars);

  SmallVector<ValueDecl *, 16> Decls;
  Decls.reserve(UniqueDecls);
  for (unsigned i = 0; i < UniqueDecls; ++i)
    Decls.push_back(
        Reader->Reader.ReadDeclAs<ValueDecl>(Reader->F, Record, Idx));
  C->setUniqueDecls(Decls);

  SmallVector<unsigned, 16> ListsPerDecl;
  ListsPerDecl.reserve(UniqueDecls);
  for (unsigned i = 0; i < UniqueDecls; ++i)
    ListsPerDecl.push_back(Record[Idx++]);
  C->setDeclNumLists(ListsPerDecl);

  SmallVector<unsigned, 32> ListSizes;
  ListSizes.reserve(TotalLists);
  for (unsigned i = 0; i < TotalLists; ++i)
    ListSizes.push_back(Record[Idx++]);
  C->setComponentListSizes(ListSizes);

  SmallVector<OMPClauseMappableExprCommon::MappableComponent, 32> Components;
  Components.reserve(TotalComponents);
  for (unsigned i = 0; i < TotalComponents; ++i) {
    Expr *AssociatedExpr = Reader->Reader.ReadSubExpr();
    ValueDecl *AssociatedDecl =
        Reader->Reader.ReadDeclAs<ValueDecl>(Reader->F, Record, Idx);
    Components.push_back(OMPClauseMappableExprCommon::MappableComponent(
        AssociatedExpr, AssociatedDecl));
  }
  C->setComponents(Components, ListSizes);
}

void OMPClauseReader::VisitOMPUseDevicePtrClause(OMPUseDevicePtrClause *C) {
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
  unsigned NumVars = C->varlist_size();
  SmallVector<Expr *, 16> Vars;
  Vars.reserve(NumVars);
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setVarRefs(Vars);
  Vars.clear();
}

void OMPClauseReader::VisitOMPIsDevicePtrClause(OMPIsDevicePtrClause *C) {
  C->setLParenLoc(Reader->ReadSourceLocation(Record, Idx));
  unsigned NumVars = C->varlist_size();
  SmallVector<Expr *, 16> Vars;
  Vars.reserve(NumVars);
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Reader.ReadSubExpr());
  C->setVarRefs(Vars);
  Vars.clear();
}

d2270 1
a2270 4
  D->setPreInits(Reader.ReadSubStmt());
  if (isOpenMPWorksharingDirective(D->getDirectiveKind()) ||
      isOpenMPTaskLoopDirective(D->getDirectiveKind()) ||
      isOpenMPDistributeDirective(D->getDirectiveKind())) {
a2277 5
    D->setNumIterations(Reader.ReadSubExpr());
  }
  if (isOpenMPLoopBoundSharingDirective(D->getDirectiveKind())) {
    D->setPrevLowerBoundVariable(Reader.ReadSubExpr());
    D->setPrevUpperBoundVariable(Reader.ReadSubExpr());
a2444 27
void ASTStmtReader::VisitOMPTargetEnterDataDirective(
    OMPTargetEnterDataDirective *D) {
  VisitStmt(D);
  ++Idx;
  VisitOMPExecutableDirective(D);
}

void ASTStmtReader::VisitOMPTargetExitDataDirective(
    OMPTargetExitDataDirective *D) {
  VisitStmt(D);
  ++Idx;
  VisitOMPExecutableDirective(D);
}

void ASTStmtReader::VisitOMPTargetParallelDirective(
    OMPTargetParallelDirective *D) {
  VisitStmt(D);
  ++Idx;
  VisitOMPExecutableDirective(D);
}

void ASTStmtReader::VisitOMPTargetParallelForDirective(
    OMPTargetParallelForDirective *D) {
  VisitOMPLoopDirective(D);
  D->setHasCancel(Record[Idx++]);
}

a2478 25
void ASTStmtReader::VisitOMPTargetUpdateDirective(OMPTargetUpdateDirective *D) {
  VisitStmt(D);
  ++Idx;
  VisitOMPExecutableDirective(D);
}
void ASTStmtReader::VisitOMPDistributeParallelForDirective(
    OMPDistributeParallelForDirective *D) {
  VisitOMPLoopDirective(D);
}

void ASTStmtReader::VisitOMPDistributeParallelForSimdDirective(
    OMPDistributeParallelForSimdDirective *D) {
  VisitOMPLoopDirective(D);
}

void ASTStmtReader::VisitOMPDistributeSimdDirective(
    OMPDistributeSimdDirective *D) {
  VisitOMPLoopDirective(D);
}

void ASTStmtReader::VisitOMPTargetParallelForSimdDirective(
    OMPTargetParallelForSimdDirective *D) {
  VisitOMPLoopDirective(D);
}

a2934 3
    case EXPR_OBJC_AVAILABILITY_CHECK:
      S = new (Context) ObjCAvailabilityCheckExpr(Empty);
      break;
a3087 28
    case STMT_OMP_TARGET_ENTER_DATA_DIRECTIVE:
      S = OMPTargetEnterDataDirective::CreateEmpty(
          Context, Record[ASTStmtReader::NumStmtFields], Empty);
      break;

    case STMT_OMP_TARGET_EXIT_DATA_DIRECTIVE:
      S = OMPTargetExitDataDirective::CreateEmpty(
          Context, Record[ASTStmtReader::NumStmtFields], Empty);
      break;

    case STMT_OMP_TARGET_PARALLEL_DIRECTIVE:
      S = OMPTargetParallelDirective::CreateEmpty(
          Context, Record[ASTStmtReader::NumStmtFields], Empty);
      break;

    case STMT_OMP_TARGET_PARALLEL_FOR_DIRECTIVE: {
      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields];
      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
      S = OMPTargetParallelForDirective::CreateEmpty(Context, NumClauses,
                                                     CollapsedNum, Empty);
      break;
    }

    case STMT_OMP_TARGET_UPDATE_DIRECTIVE:
      S = OMPTargetUpdateDirective::CreateEmpty(
          Context, Record[ASTStmtReader::NumStmtFields], Empty);
      break;

a3125 33
    case STMT_OMP_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE: {
      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields];
      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
      S = OMPDistributeParallelForDirective::CreateEmpty(Context, NumClauses,
                                                         CollapsedNum, Empty);
      break;
    }

    case STMT_OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE: {
      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields];
      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
      S = OMPDistributeParallelForSimdDirective::CreateEmpty(Context, NumClauses,
                                                             CollapsedNum,
                                                             Empty);
      break;
    }

    case STMT_OMP_DISTRIBUTE_SIMD_DIRECTIVE: {
      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields];
      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
      S = OMPDistributeSimdDirective::CreateEmpty(Context, NumClauses,
                                                  CollapsedNum, Empty);
      break;
    }

    case STMT_OMP_TARGET_PARALLEL_FOR_SIMD_DIRECTIVE: {
      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields];
      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
      S = OMPTargetParallelForSimdDirective::CreateEmpty(Context, NumClauses,
                                                         CollapsedNum, Empty);
      break;
    }

a3135 4
      break;

    case EXPR_CXX_INHERITED_CTOR_INIT:
      S = new (Context) CXXInheritedCtorInitExpr(Empty);
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d29 4
a32 2

    ASTRecordReader &Record;
d34 2
d37 2
a38 2
    SourceLocation ReadSourceLocation() {
      return Record.readSourceLocation();
d41 2
a42 2
    SourceRange ReadSourceRange() {
      return Record.readSourceRange();
d45 2
a46 2
    std::string ReadString() {
      return Record.readString();
d49 10
a58 2
    TypeSourceInfo *GetTypeSourceInfo() {
      return Record.getTypeSourceInfo();
d60 3
a62 3

    Decl *ReadDecl() {
      return Record.readDecl();
d64 1
a64 1

d66 2
a67 2
    T *ReadDeclAs() {
      return Record.readDeclAs<T>();
d70 8
a77 7
    void ReadDeclarationNameLoc(DeclarationNameLoc &DNLoc,
                                DeclarationName Name) {
      Record.readDeclarationNameLoc(DNLoc, Name);
    }

    void ReadDeclarationNameInfo(DeclarationNameInfo &NameInfo) {
      Record.readDeclarationNameInfo(NameInfo);
d81 4
a84 2
    ASTStmtReader(ASTRecordReader &Record, llvm::BitstreamCursor &Cursor)
        : Record(Record), DeclsCursor(Cursor) {}
d112 1
a112 1
  SourceLocation TemplateKWLoc = ReadSourceLocation();
d114 2
a115 2
  ArgInfo.setLAngleLoc(ReadSourceLocation());
  ArgInfo.setRAngleLoc(ReadSourceLocation());
d117 2
a118 1
    ArgInfo.addArgument(Record.readTemplateArgumentLoc());
d123 1
a123 1
  assert(Record.getIdx() == NumStmtFields && "Incorrect statement field count");
d128 2
a129 2
  S->setSemiLoc(ReadSourceLocation());
  S->HasLeadingEmptyMacro = Record.readInt();
d135 1
a135 1
  unsigned NumStmts = Record.readInt();
d137 4
a140 4
    Stmts.push_back(Record.readSubStmt());
  S->setStmts(Record.getContext(), Stmts);
  S->LBraceLoc = ReadSourceLocation();
  S->RBraceLoc = ReadSourceLocation();
d145 3
a147 3
  Record.recordSwitchCaseID(S, Record.readInt());
  S->setKeywordLoc(ReadSourceLocation());
  S->setColonLoc(ReadSourceLocation());
d152 4
a155 4
  S->setLHS(Record.readSubExpr());
  S->setRHS(Record.readSubExpr());
  S->setSubStmt(Record.readSubStmt());
  S->setEllipsisLoc(ReadSourceLocation());
d160 1
a160 1
  S->setSubStmt(Record.readSubStmt());
d165 1
a165 1
  LabelDecl *LD = ReadDeclAs<LabelDecl>();
d168 2
a169 2
  S->setSubStmt(Record.readSubStmt());
  S->setIdentLoc(ReadSourceLocation());
d174 1
a174 1
  uint64_t NumAttrs = Record.readInt();
d176 1
a176 1
  Record.readAttributes(Attrs);
d181 2
a182 2
  S->SubStmt = Record.readSubStmt();
  S->AttrLoc = ReadSourceLocation();
d187 9
a195 8
  S->setConstexpr(Record.readInt());
  S->setInit(Record.readSubStmt());
  S->setConditionVariable(Record.getContext(), ReadDeclAs<VarDecl>());
  S->setCond(Record.readSubExpr());
  S->setThen(Record.readSubStmt());
  S->setElse(Record.readSubStmt());
  S->setIfLoc(ReadSourceLocation());
  S->setElseLoc(ReadSourceLocation());
d200 7
a206 6
  S->setInit(Record.readSubStmt());
  S->setConditionVariable(Record.getContext(), ReadDeclAs<VarDecl>());
  S->setCond(Record.readSubExpr());
  S->setBody(Record.readSubStmt());
  S->setSwitchLoc(ReadSourceLocation());
  if (Record.readInt())
d210 2
a211 2
  for (auto E = Record.size(); Record.getIdx() != E; ) {
    SwitchCase *SC = Record.getSwitchCaseWithID(Record.readInt());
d223 2
a224 1
  S->setConditionVariable(Record.getContext(), ReadDeclAs<VarDecl>());
d226 3
a228 3
  S->setCond(Record.readSubExpr());
  S->setBody(Record.readSubStmt());
  S->setWhileLoc(ReadSourceLocation());
d233 5
a237 5
  S->setCond(Record.readSubExpr());
  S->setBody(Record.readSubStmt());
  S->setDoLoc(ReadSourceLocation());
  S->setWhileLoc(ReadSourceLocation());
  S->setRParenLoc(ReadSourceLocation());
d242 9
a250 8
  S->setInit(Record.readSubStmt());
  S->setCond(Record.readSubExpr());
  S->setConditionVariable(Record.getContext(), ReadDeclAs<VarDecl>());
  S->setInc(Record.readSubExpr());
  S->setBody(Record.readSubStmt());
  S->setForLoc(ReadSourceLocation());
  S->setLParenLoc(ReadSourceLocation());
  S->setRParenLoc(ReadSourceLocation());
d255 3
a257 3
  S->setLabel(ReadDeclAs<LabelDecl>());
  S->setGotoLoc(ReadSourceLocation());
  S->setLabelLoc(ReadSourceLocation());
d262 3
a264 3
  S->setGotoLoc(ReadSourceLocation());
  S->setStarLoc(ReadSourceLocation());
  S->setTarget(Record.readSubExpr());
d269 1
a269 1
  S->setContinueLoc(ReadSourceLocation());
d274 1
a274 1
  S->setBreakLoc(ReadSourceLocation());
d279 3
a281 3
  S->setRetValue(Record.readSubExpr());
  S->setReturnLoc(ReadSourceLocation());
  S->setNRVOCandidate(ReadDeclAs<VarDecl>());
d286 2
a287 2
  S->setStartLoc(ReadSourceLocation());
  S->setEndLoc(ReadSourceLocation());
d289 1
a289 1
  if (Record.size() - Record.getIdx() == 1) {
d291 1
a291 1
    S->setDeclGroup(DeclGroupRef(ReadDecl()));
d294 4
a297 5
    int N = Record.size() - Record.getIdx();
    Decls.reserve(N);
    for (int I = 0; I < N; ++I)
      Decls.push_back(ReadDecl());
    S->setDeclGroup(DeclGroupRef(DeclGroup::Create(Record.getContext(),
d305 6
a310 6
  S->NumOutputs = Record.readInt();
  S->NumInputs = Record.readInt();
  S->NumClobbers = Record.readInt();
  S->setAsmLoc(ReadSourceLocation());
  S->setVolatile(Record.readInt());
  S->setSimple(Record.readInt());
d315 2
a316 2
  S->setRParenLoc(ReadSourceLocation());
  S->setAsmString(cast_or_null<StringLiteral>(Record.readSubStmt()));
d327 3
a329 3
    Names.push_back(Record.getIdentifierInfo());
    Constraints.push_back(cast_or_null<StringLiteral>(Record.readSubStmt()));
    Exprs.push_back(Record.readSubStmt());
d335 1
a335 1
    Clobbers.push_back(cast_or_null<StringLiteral>(Record.readSubStmt()));
d337 3
a339 3
  S->setOutputsAndInputsAndClobbers(Record.getContext(),
                                    Names.data(), Constraints.data(),
                                    Exprs.data(), NumOutputs, NumInputs,
d345 4
a348 4
  S->LBraceLoc = ReadSourceLocation();
  S->EndLoc = ReadSourceLocation();
  S->NumAsmToks = Record.readInt();
  std::string AsmStr = ReadString();
d354 1
a354 1
    AsmToks.push_back(Record.readToken());
d366 1
a366 1
    ClobbersData.push_back(ReadString());
d379 2
a380 2
    Exprs.push_back(cast<Expr>(Record.readSubStmt()));
    ConstraintsData.push_back(ReadString());
d384 1
a384 1
  S->initialize(Record.getContext(), AsmStr, AsmToks,
d410 4
a413 4
  Record.skipInts(1);
  S->setCapturedDecl(ReadDeclAs<CapturedDecl>());
  S->setCapturedRegionKind(static_cast<CapturedRegionKind>(Record.readInt()));
  S->setCapturedRecordDecl(ReadDeclAs<RecordDecl>());
d419 1
a419 1
    *I = Record.readSubExpr();
d422 1
a422 1
  S->setCapturedStmt(Record.readSubStmt());
d427 4
a430 4
    I.VarAndKind.setPointer(ReadDeclAs<VarDecl>());
    I.VarAndKind.setInt(
        static_cast<CapturedStmt::VariableCaptureKind>(Record.readInt()));
    I.Loc = ReadSourceLocation();
d436 8
a443 9
  E->setType(Record.readType());
  E->setTypeDependent(Record.readInt());
  E->setValueDependent(Record.readInt());
  E->setInstantiationDependent(Record.readInt());
  E->ExprBits.ContainsUnexpandedParameterPack = Record.readInt();
  E->setValueKind(static_cast<ExprValueKind>(Record.readInt()));
  E->setObjectKind(static_cast<ExprObjectKind>(Record.readInt()));
  assert(Record.getIdx() == NumExprFields &&
         "Incorrect expression field count");
d448 3
a450 3
  E->setLocation(ReadSourceLocation());
  E->Type = (PredefinedExpr::IdentType)Record.readInt();
  E->FnName = cast_or_null<StringLiteral>(Record.readSubExpr());
d456 5
a460 5
  E->DeclRefExprBits.HasQualifier = Record.readInt();
  E->DeclRefExprBits.HasFoundDecl = Record.readInt();
  E->DeclRefExprBits.HasTemplateKWAndArgsInfo = Record.readInt();
  E->DeclRefExprBits.HadMultipleCandidates = Record.readInt();
  E->DeclRefExprBits.RefersToEnclosingVariableOrCapture = Record.readInt();
d463 1
a463 1
    NumTemplateArgs = Record.readInt();
d467 2
a468 1
        NestedNameSpecifierLoc(Record.readNestedNameSpecifierLoc());
d471 1
a471 1
    *E->getTrailingObjects<NamedDecl *>() = ReadDeclAs<NamedDecl>();
d478 3
a480 3
  E->setDecl(ReadDeclAs<ValueDecl>());
  E->setLocation(ReadSourceLocation());
  ReadDeclarationNameLoc(E->DNLoc, E->getDecl()->getDeclName());
d485 2
a486 2
  E->setLocation(ReadSourceLocation());
  E->setValue(Record.getContext(), Record.readAPInt());
d491 5
a495 4
  E->setRawSemantics(static_cast<Stmt::APFloatSemantics>(Record.readInt()));
  E->setExact(Record.readInt());
  E->setValue(Record.getContext(), Record.readAPFloat(E->getSemantics()));
  E->setLocation(ReadSourceLocation());
d500 1
a500 1
  E->setSubExpr(Record.readSubExpr());
d505 2
a506 2
  unsigned Len = Record.readInt();
  assert(Record.peekInt() == E->getNumConcatenated() &&
d508 1
a508 1
  Record.skipInts(1);
d510 2
a511 2
        static_cast<StringLiteral::StringKind>(Record.readInt());
  bool isPascal = Record.readInt();
d514 3
a516 4
  auto B = &Record.peekInt();
  SmallString<16> Str(B, B + Len);
  E->setString(Record.getContext(), Str, kind, isPascal);
  Record.skipInts(Len);
d520 1
a520 1
    E->setStrTokenLoc(I, ReadSourceLocation());
d525 3
a527 3
  E->setValue(Record.readInt());
  E->setLocation(ReadSourceLocation());
  E->setKind(static_cast<CharacterLiteral::CharacterKind>(Record.readInt()));
d532 3
a534 3
  E->setLParen(ReadSourceLocation());
  E->setRParen(ReadSourceLocation());
  E->setSubExpr(Record.readSubExpr());
d539 2
a540 2
  unsigned NumExprs = Record.readInt();
  E->Exprs = new (Record.getContext()) Stmt*[NumExprs];
d542 1
a542 1
    E->Exprs[i] = Record.readSubStmt();
d544 2
a545 2
  E->LParenLoc = ReadSourceLocation();
  E->RParenLoc = ReadSourceLocation();
d550 3
a552 3
  E->setSubExpr(Record.readSubExpr());
  E->setOpcode((UnaryOperator::Opcode)Record.readInt());
  E->setOperatorLoc(ReadSourceLocation());
d557 7
a563 7
  assert(E->getNumComponents() == Record.peekInt());
  Record.skipInts(1);
  assert(E->getNumExpressions() == Record.peekInt());
  Record.skipInts(1);
  E->setOperatorLoc(ReadSourceLocation());
  E->setRParenLoc(ReadSourceLocation());
  E->setTypeSourceInfo(GetTypeSourceInfo());
d565 3
a567 3
    OffsetOfNode::Kind Kind = static_cast<OffsetOfNode::Kind>(Record.readInt());
    SourceLocation Start = ReadSourceLocation();
    SourceLocation End = ReadSourceLocation();
d570 1
a570 1
      E->setComponent(I, OffsetOfNode(Start, Record.readInt(), End));
d575 1
a575 1
          I, OffsetOfNode(Start, ReadDeclAs<FieldDecl>(), End));
d581 1
a581 1
          OffsetOfNode(Start, Record.getIdentifierInfo(), End));
d585 2
a586 2
      CXXBaseSpecifier *Base = new (Record.getContext()) CXXBaseSpecifier();
      *Base = Record.readCXXBaseSpecifier();
d592 1
a592 1

d594 1
a594 1
    E->setIndexExpr(I, Record.readSubExpr());
d599 4
a602 4
  E->setKind(static_cast<UnaryExprOrTypeTrait>(Record.readInt()));
  if (Record.peekInt() == 0) {
    E->setArgument(Record.readSubExpr());
    Record.skipInts(1);
d604 1
a604 1
    E->setArgument(GetTypeSourceInfo());
d606 2
a607 2
  E->setOperatorLoc(ReadSourceLocation());
  E->setRParenLoc(ReadSourceLocation());
d612 3
a614 3
  E->setLHS(Record.readSubExpr());
  E->setRHS(Record.readSubExpr());
  E->setRBracketLoc(ReadSourceLocation());
d619 5
a623 5
  E->setBase(Record.readSubExpr());
  E->setLowerBound(Record.readSubExpr());
  E->setLength(Record.readSubExpr());
  E->setColonLoc(ReadSourceLocation());
  E->setRBracketLoc(ReadSourceLocation());
d628 3
a630 3
  E->setNumArgs(Record.getContext(), Record.readInt());
  E->setRParenLoc(ReadSourceLocation());
  E->setCallee(Record.readSubExpr());
d632 1
a632 1
    E->setArg(I, Record.readSubExpr());
d647 4
a650 4
  E->setBase(Record.readSubExpr());
  E->setIsaMemberLoc(ReadSourceLocation());
  E->setOpLoc(ReadSourceLocation());
  E->setArrow(Record.readInt());
d656 2
a657 2
  E->Operand = Record.readSubExpr();
  E->setShouldCopy(Record.readInt());
d662 3
a664 3
  E->LParenLoc = ReadSourceLocation();
  E->BridgeKeywordLoc = ReadSourceLocation();
  E->Kind = Record.readInt();
d669 1
a669 1
  unsigned NumBaseSpecs = Record.readInt();
d671 2
a672 2
  E->setSubExpr(Record.readSubExpr());
  E->setCastKind((CastKind)Record.readInt());
d675 2
a676 2
    CXXBaseSpecifier *BaseSpec = new (Record.getContext()) CXXBaseSpecifier;
    *BaseSpec = Record.readCXXBaseSpecifier();
d683 5
a687 5
  E->setLHS(Record.readSubExpr());
  E->setRHS(Record.readSubExpr());
  E->setOpcode((BinaryOperator::Opcode)Record.readInt());
  E->setOperatorLoc(ReadSourceLocation());
  E->setFPContractable((bool)Record.readInt());
d692 2
a693 2
  E->setComputationLHSType(Record.readType());
  E->setComputationResultType(Record.readType());
d698 5
a702 5
  E->SubExprs[ConditionalOperator::COND] = Record.readSubExpr();
  E->SubExprs[ConditionalOperator::LHS] = Record.readSubExpr();
  E->SubExprs[ConditionalOperator::RHS] = Record.readSubExpr();
  E->QuestionLoc = ReadSourceLocation();
  E->ColonLoc = ReadSourceLocation();
d708 7
a714 7
  E->OpaqueValue = cast<OpaqueValueExpr>(Record.readSubExpr());
  E->SubExprs[BinaryConditionalOperator::COMMON] = Record.readSubExpr();
  E->SubExprs[BinaryConditionalOperator::COND] = Record.readSubExpr();
  E->SubExprs[BinaryConditionalOperator::LHS] = Record.readSubExpr();
  E->SubExprs[BinaryConditionalOperator::RHS] = Record.readSubExpr();
  E->QuestionLoc = ReadSourceLocation();
  E->ColonLoc = ReadSourceLocation();
d723 1
a723 1
  E->setTypeInfoAsWritten(GetTypeSourceInfo());
d728 2
a729 2
  E->setLParenLoc(ReadSourceLocation());
  E->setRParenLoc(ReadSourceLocation());
d734 4
a737 4
  E->setLParenLoc(ReadSourceLocation());
  E->setTypeSourceInfo(GetTypeSourceInfo());
  E->setInitializer(Record.readSubExpr());
  E->setFileScope(Record.readInt());
d742 3
a744 3
  E->setBase(Record.readSubExpr());
  E->setAccessor(Record.getIdentifierInfo());
  E->setAccessorLoc(ReadSourceLocation());
d749 1
a749 1
  if (InitListExpr *SyntForm = cast_or_null<InitListExpr>(Record.readSubStmt()))
d751 3
a753 3
  E->setLBraceLoc(ReadSourceLocation());
  E->setRBraceLoc(ReadSourceLocation());
  bool isArrayFiller = Record.readInt();
d756 1
a756 1
    filler = Record.readSubExpr();
d759 4
a762 4
    E->ArrayFillerOrUnionFieldInit = ReadDeclAs<FieldDecl>();
  E->sawArrayRangeDesignator(Record.readInt());
  unsigned NumInits = Record.readInt();
  E->reserveInits(Record.getContext(), NumInits);
d765 2
a766 2
      Expr *init = Record.readSubExpr();
      E->updateInit(Record.getContext(), I, init ? init : filler);
d770 1
a770 1
      E->updateInit(Record.getContext(), I, Record.readSubExpr());
d778 1
a778 1
  unsigned NumSubExprs = Record.readInt();
d781 3
a783 3
    E->setSubExpr(I, Record.readSubExpr());
  E->setEqualOrColonLoc(ReadSourceLocation());
  E->setGNUSyntax(Record.readInt());
d786 2
a787 2
  while (Record.getIdx() < Record.size()) {
    switch ((DesignatorTypes)Record.readInt()) {
d789 5
a793 3
      FieldDecl *Field = ReadDeclAs<FieldDecl>();
      SourceLocation DotLoc = ReadSourceLocation();
      SourceLocation FieldLoc = ReadSourceLocation();
d801 5
a805 3
      const IdentifierInfo *Name = Record.getIdentifierInfo();
      SourceLocation DotLoc = ReadSourceLocation();
      SourceLocation FieldLoc = ReadSourceLocation();
d811 5
a815 3
      unsigned Index = Record.readInt();
      SourceLocation LBracketLoc = ReadSourceLocation();
      SourceLocation RBracketLoc = ReadSourceLocation();
d821 7
a827 4
      unsigned Index = Record.readInt();
      SourceLocation LBracketLoc = ReadSourceLocation();
      SourceLocation EllipsisLoc = ReadSourceLocation();
      SourceLocation RBracketLoc = ReadSourceLocation();
d834 1
a834 1
  E->setDesignators(Record.getContext(),
d840 2
a841 2
  E->setBase(Record.readSubExpr());
  E->setUpdater(Record.readSubExpr());
a847 10
void ASTStmtReader::VisitArrayInitLoopExpr(ArrayInitLoopExpr *E) {
  VisitExpr(E);
  E->SubExprs[0] = Record.readSubExpr();
  E->SubExprs[1] = Record.readSubExpr();
}

void ASTStmtReader::VisitArrayInitIndexExpr(ArrayInitIndexExpr *E) {
  VisitExpr(E);
}

d854 5
a858 5
  E->setSubExpr(Record.readSubExpr());
  E->setWrittenTypeInfo(GetTypeSourceInfo());
  E->setBuiltinLoc(ReadSourceLocation());
  E->setRParenLoc(ReadSourceLocation());
  E->setIsMicrosoftABI(Record.readInt());
d863 3
a865 3
  E->setAmpAmpLoc(ReadSourceLocation());
  E->setLabelLoc(ReadSourceLocation());
  E->setLabel(ReadDeclAs<LabelDecl>());
d870 3
a872 3
  E->setLParenLoc(ReadSourceLocation());
  E->setRParenLoc(ReadSourceLocation());
  E->setSubStmt(cast_or_null<CompoundStmt>(Record.readSubStmt()));
d877 6
a882 6
  E->setCond(Record.readSubExpr());
  E->setLHS(Record.readSubExpr());
  E->setRHS(Record.readSubExpr());
  E->setBuiltinLoc(ReadSourceLocation());
  E->setRParenLoc(ReadSourceLocation());
  E->setIsConditionTrue(Record.readInt());
d887 1
a887 1
  E->setTokenLocation(ReadSourceLocation());
d893 1
a893 1
  unsigned NumExprs = Record.readInt();
d895 4
a898 4
    Exprs.push_back(Record.readSubExpr());
  E->setExprs(Record.getContext(), Exprs);
  E->setBuiltinLoc(ReadSourceLocation());
  E->setRParenLoc(ReadSourceLocation());
d903 4
a906 4
  E->BuiltinLoc = ReadSourceLocation();
  E->RParenLoc = ReadSourceLocation();
  E->TInfo = GetTypeSourceInfo();
  E->SrcExpr = Record.readSubExpr();
d911 1
a911 1
  E->setBlockDecl(ReadDeclAs<BlockDecl>());
d916 2
a917 2
  E->NumAssocs = Record.readInt();
  E->AssocTypes = new (Record.getContext()) TypeSourceInfo*[E->NumAssocs];
d919 1
a919 1
   new(Record.getContext()) Stmt*[GenericSelectionExpr::END_EXPR+E->NumAssocs];
d921 1
a921 1
  E->SubExprs[GenericSelectionExpr::CONTROLLING] = Record.readSubExpr();
d923 2
a924 2
    E->AssocTypes[I] = GetTypeSourceInfo();
    E->SubExprs[GenericSelectionExpr::END_EXPR+I] = Record.readSubExpr();
d926 1
a926 1
  E->ResultIndex = Record.readInt();
d928 3
a930 3
  E->GenericLoc = ReadSourceLocation();
  E->DefaultLoc = ReadSourceLocation();
  E->RParenLoc = ReadSourceLocation();
d935 1
a935 1
  unsigned numSemanticExprs = Record.readInt();
d937 1
a937 1
  E->PseudoObjectExprBits.ResultIndex = Record.readInt();
d940 1
a940 1
  E->getSubExprsBuffer()[0] = Record.readSubExpr();
d944 1
a944 1
    Expr *subExpr = Record.readSubExpr();
d951 1
a951 1
  E->Op = AtomicExpr::AtomicOp(Record.readInt());
d954 3
a956 3
    E->SubExprs[I] = Record.readSubExpr();
  E->BuiltinLoc = ReadSourceLocation();
  E->RParenLoc = ReadSourceLocation();
d964 2
a965 2
  E->setString(cast<StringLiteral>(Record.readSubStmt()));
  E->setAtLoc(ReadSourceLocation());
d971 3
a973 3
  E->SubExpr = Record.readSubStmt();
  E->BoxingMethod = ReadDeclAs<ObjCMethodDecl>();
  E->Range = ReadSourceRange();
d978 1
a978 1
  unsigned NumElements = Record.readInt();
d982 3
a984 3
    Elements[I] = Record.readSubExpr();
  E->ArrayWithObjectsMethod = ReadDeclAs<ObjCMethodDecl>();
  E->Range = ReadSourceRange();
d989 1
a989 1
  unsigned NumElements = Record.readInt();
d991 1
a991 1
  bool HasPackExpansions = Record.readInt();
d998 2
a999 2
    KeyValues[I].Key = Record.readSubExpr();
    KeyValues[I].Value = Record.readSubExpr();
d1001 2
a1002 2
      Expansions[I].EllipsisLoc = ReadSourceLocation();
      Expansions[I].NumExpansionsPlusOne = Record.readInt();
d1005 2
a1006 2
  E->DictWithObjectsMethod = ReadDeclAs<ObjCMethodDecl>();
  E->Range = ReadSourceRange();
d1011 3
a1013 3
  E->setEncodedTypeSourceInfo(GetTypeSourceInfo());
  E->setAtLoc(ReadSourceLocation());
  E->setRParenLoc(ReadSourceLocation());
d1018 3
a1020 3
  E->setSelector(Record.readSelector());
  E->setAtLoc(ReadSourceLocation());
  E->setRParenLoc(ReadSourceLocation());
d1025 4
a1028 4
  E->setProtocol(ReadDeclAs<ObjCProtocolDecl>());
  E->setAtLoc(ReadSourceLocation());
  E->ProtoLoc = ReadSourceLocation();
  E->setRParenLoc(ReadSourceLocation());
d1033 6
a1038 6
  E->setDecl(ReadDeclAs<ObjCIvarDecl>());
  E->setLocation(ReadSourceLocation());
  E->setOpLoc(ReadSourceLocation());
  E->setBase(Record.readSubExpr());
  E->setIsArrow(Record.readInt());
  E->setIsFreeIvar(Record.readInt());
d1043 2
a1044 2
  unsigned MethodRefFlags = Record.readInt();
  bool Implicit = Record.readInt() != 0;
d1046 2
a1047 2
    ObjCMethodDecl *Getter = ReadDeclAs<ObjCMethodDecl>();
    ObjCMethodDecl *Setter = ReadDeclAs<ObjCMethodDecl>();
d1050 2
a1051 1
    E->setExplicitProperty(ReadDeclAs<ObjCPropertyDecl>(), MethodRefFlags);
d1053 3
a1055 3
  E->setLocation(ReadSourceLocation());
  E->setReceiverLocation(ReadSourceLocation());
  switch (Record.readInt()) {
d1057 1
a1057 1
    E->setBase(Record.readSubExpr());
d1060 1
a1060 1
    E->setSuperReceiver(Record.readType());
d1063 1
a1063 1
    E->setClassReceiver(ReadDeclAs<ObjCInterfaceDecl>());
d1070 5
a1074 5
  E->setRBracket(ReadSourceLocation());
  E->setBaseExpr(Record.readSubExpr());
  E->setKeyExpr(Record.readSubExpr());
  E->GetAtIndexMethodDecl = ReadDeclAs<ObjCMethodDecl>();
  E->SetAtIndexMethodDecl = ReadDeclAs<ObjCMethodDecl>();
d1079 6
a1084 6
  assert(Record.peekInt() == E->getNumArgs());
  Record.skipInts(1);
  unsigned NumStoredSelLocs = Record.readInt();
  E->SelLocsKind = Record.readInt();
  E->setDelegateInitCall(Record.readInt());
  E->IsImplicit = Record.readInt();
d1086 1
a1086 1
    = static_cast<ObjCMessageExpr::ReceiverKind>(Record.readInt());
d1089 1
a1089 1
    E->setInstanceReceiver(Record.readSubExpr());
d1093 1
a1093 1
    E->setClassReceiver(GetTypeSourceInfo());
d1098 2
a1099 2
    QualType T = Record.readType();
    SourceLocation SuperLoc = ReadSourceLocation();
d1107 2
a1108 2
  if (Record.readInt())
    E->setMethodDecl(ReadDeclAs<ObjCMethodDecl>());
d1110 1
a1110 1
    E->setSelector(Record.readSelector());
d1112 2
a1113 2
  E->LBracLoc = ReadSourceLocation();
  E->RBracLoc = ReadSourceLocation();
d1116 1
a1116 1
    E->setArg(I, Record.readSubExpr());
d1120 1
a1120 1
    Locs[I] = ReadSourceLocation();
d1125 5
a1129 5
  S->setElement(Record.readSubStmt());
  S->setCollection(Record.readSubExpr());
  S->setBody(Record.readSubStmt());
  S->setForLoc(ReadSourceLocation());
  S->setRParenLoc(ReadSourceLocation());
d1134 4
a1137 4
  S->setCatchBody(Record.readSubStmt());
  S->setCatchParamDecl(ReadDeclAs<VarDecl>());
  S->setAtCatchLoc(ReadSourceLocation());
  S->setRParenLoc(ReadSourceLocation());
d1142 2
a1143 2
  S->setFinallyBody(Record.readSubStmt());
  S->setAtFinallyLoc(ReadSourceLocation());
d1148 2
a1149 2
  S->setSubStmt(Record.readSubStmt());
  S->setAtLoc(ReadSourceLocation());
d1154 4
a1157 4
  assert(Record.peekInt() == S->getNumCatchStmts());
  Record.skipInts(1);
  bool HasFinally = Record.readInt();
  S->setTryBody(Record.readSubStmt());
d1159 1
a1159 1
    S->setCatchStmt(I, cast_or_null<ObjCAtCatchStmt>(Record.readSubStmt()));
d1162 2
a1163 2
    S->setFinallyStmt(Record.readSubStmt());
  S->setAtTryLoc(ReadSourceLocation());
d1168 3
a1170 3
  S->setSynchExpr(Record.readSubStmt());
  S->setSynchBody(Record.readSubStmt());
  S->setAtSynchronizedLoc(ReadSourceLocation());
d1175 2
a1176 2
  S->setThrowExpr(Record.readSubStmt());
  S->setThrowLoc(ReadSourceLocation());
d1181 2
a1182 2
  E->setValue(Record.readInt());
  E->setLocation(ReadSourceLocation());
d1187 1
a1187 1
  SourceRange R = Record.readSourceRange();
d1190 1
a1190 1
  E->VersionToCheck = Record.readVersionTuple();
d1199 3
a1201 3
  S->CatchLoc = ReadSourceLocation();
  S->ExceptionDecl = ReadDeclAs<VarDecl>();
  S->HandlerBlock = Record.readSubStmt();
d1206 4
a1209 4
  assert(Record.peekInt() == S->getNumHandlers() && "NumStmtFields is wrong ?");
  Record.skipInts(1);
  S->TryLoc = ReadSourceLocation();
  S->getStmts()[0] = Record.readSubStmt();
d1211 1
a1211 1
    S->getStmts()[i + 1] = Record.readSubStmt();
d1216 11
a1226 11
  S->ForLoc = ReadSourceLocation();
  S->CoawaitLoc = ReadSourceLocation();
  S->ColonLoc = ReadSourceLocation();
  S->RParenLoc = ReadSourceLocation();
  S->setRangeStmt(Record.readSubStmt());
  S->setBeginStmt(Record.readSubStmt());
  S->setEndStmt(Record.readSubStmt());
  S->setCond(Record.readSubExpr());
  S->setInc(Record.readSubExpr());
  S->setLoopVarStmt(Record.readSubStmt());
  S->setBody(Record.readSubStmt());
d1231 5
a1235 5
  S->KeywordLoc = ReadSourceLocation();
  S->IsIfExists = Record.readInt();
  S->QualifierLoc = Record.readNestedNameSpecifierLoc();
  ReadDeclarationNameInfo(S->NameInfo);
  S->SubStmt = Record.readSubStmt();
d1240 3
a1242 3
  E->Operator = (OverloadedOperatorKind)Record.readInt();
  E->Range = Record.readSourceRange();
  E->setFPContractable((bool)Record.readInt());
d1247 1
a1247 1
  E->NumArgs = Record.readInt();
d1249 1
a1249 1
    E->Args = new (Record.getContext()) Stmt*[E->NumArgs];
d1251 10
a1260 10
    E->setArg(I, Record.readSubExpr());
  E->setConstructor(ReadDeclAs<CXXConstructorDecl>());
  E->setLocation(ReadSourceLocation());
  E->setElidable(Record.readInt());
  E->setHadMultipleCandidates(Record.readInt());
  E->setListInitialization(Record.readInt());
  E->setStdInitListInitialization(Record.readInt());
  E->setRequiresZeroInitialization(Record.readInt());
  E->setConstructionKind((CXXConstructExpr::ConstructionKind)Record.readInt());
  E->ParenOrBraceRange = ReadSourceRange();
d1265 4
a1268 4
  E->Constructor = ReadDeclAs<CXXConstructorDecl>();
  E->Loc = ReadSourceLocation();
  E->ConstructsVirtualBase = Record.readInt();
  E->InheritedFromVirtualBase = Record.readInt();
d1273 1
a1273 1
  E->Type = GetTypeSourceInfo();
d1278 1
a1278 1
  unsigned NumCaptures = Record.readInt();
d1280 8
a1287 7
  E->IntroducerRange = ReadSourceRange();
  E->CaptureDefault = static_cast<LambdaCaptureDefault>(Record.readInt());
  E->CaptureDefaultLoc = ReadSourceLocation();
  E->ExplicitParams = Record.readInt();
  E->ExplicitResultType = Record.readInt();
  E->ClosingBrace = ReadSourceLocation();

d1292 12
a1303 1
    *C = Record.readSubExpr();
d1309 1
a1309 1
  E->SubExpr = Record.readSubExpr();
d1314 1
a1314 1
  SourceRange R = ReadSourceRange();
d1317 1
a1317 1
  R = ReadSourceRange();
d1339 2
a1340 2
  E->setLParenLoc(ReadSourceLocation());
  E->setRParenLoc(ReadSourceLocation());
d1345 1
a1345 1
  E->UDSuffixLoc = ReadSourceLocation();
d1350 2
a1351 2
  E->setValue(Record.readInt());
  E->setLocation(ReadSourceLocation());
d1356 1
a1356 1
  E->setLocation(ReadSourceLocation());
d1361 1
a1361 1
  E->setSourceRange(ReadSourceRange());
d1364 1
a1364 1
        GetTypeSourceInfo());
d1367 1
a1367 1

d1369 1
a1369 1
  E->setExprOperand(Record.readSubExpr());
d1374 2
a1375 2
  E->setLocation(ReadSourceLocation());
  E->setImplicit(Record.readInt());
d1380 3
a1382 3
  E->ThrowLoc = ReadSourceLocation();
  E->Op = Record.readSubExpr();
  E->IsThrownVariableInScope = Record.readInt();
d1387 2
a1388 2
  E->Param = ReadDeclAs<ParmVarDecl>();
  E->Loc = ReadSourceLocation();
d1393 2
a1394 2
  E->Field = ReadDeclAs<FieldDecl>();
  E->Loc = ReadSourceLocation();
d1399 2
a1400 2
  E->setTemporary(Record.readCXXTemporary());
  E->setSubExpr(Record.readSubExpr());
d1405 2
a1406 2
  E->TypeInfo = GetTypeSourceInfo();
  E->RParenLoc = ReadSourceLocation();
d1411 11
a1421 12
  E->GlobalNew = Record.readInt();
  bool isArray = Record.readInt();
  E->PassAlignment = Record.readInt();
  E->UsualArrayDeleteWantsSize = Record.readInt();
  unsigned NumPlacementArgs = Record.readInt();
  E->StoredInitializationStyle = Record.readInt();
  E->setOperatorNew(ReadDeclAs<FunctionDecl>());
  E->setOperatorDelete(ReadDeclAs<FunctionDecl>());
  E->AllocatedTypeInfo = GetTypeSourceInfo();
  E->TypeIdParens = ReadSourceRange();
  E->Range = ReadSourceRange();
  E->DirectInitRange = ReadSourceRange();
d1423 1
a1423 1
  E->AllocateArgsArray(Record.getContext(), isArray, NumPlacementArgs,
d1429 1
a1429 1
    *I = Record.readSubStmt();
d1434 7
a1440 7
  E->GlobalDelete = Record.readInt();
  E->ArrayForm = Record.readInt();
  E->ArrayFormAsWritten = Record.readInt();
  E->UsualArrayDeleteWantsSize = Record.readInt();
  E->OperatorDelete = ReadDeclAs<FunctionDecl>();
  E->Argument = Record.readSubExpr();
  E->Loc = ReadSourceLocation();
d1446 9
a1454 9
  E->Base = Record.readSubExpr();
  E->IsArrow = Record.readInt();
  E->OperatorLoc = ReadSourceLocation();
  E->QualifierLoc = Record.readNestedNameSpecifierLoc();
  E->ScopeType = GetTypeSourceInfo();
  E->ColonColonLoc = ReadSourceLocation();
  E->TildeLoc = ReadSourceLocation();

  IdentifierInfo *II = Record.getIdentifierInfo();
d1456 1
a1456 1
    E->setDestroyedType(II, ReadSourceLocation());
d1458 1
a1458 1
    E->setDestroyedType(GetTypeSourceInfo());
d1464 1
a1464 1
  unsigned NumObjects = Record.readInt();
d1468 1
a1468 1
        ReadDeclAs<BlockDecl>();
d1470 2
a1471 2
  E->ExprWithCleanupsBits.CleanupsHaveSideEffects = Record.readInt();
  E->SubExpr = Record.readSubExpr();
d1478 1
a1478 1
  if (Record.readInt()) // HasTemplateKWAndArgsInfo
d1482 1
a1482 1
        /*NumTemplateArgs=*/Record.readInt());
d1484 7
a1490 7
  E->Base = Record.readSubExpr();
  E->BaseType = Record.readType();
  E->IsArrow = Record.readInt();
  E->OperatorLoc = ReadSourceLocation();
  E->QualifierLoc = Record.readNestedNameSpecifierLoc();
  E->FirstQualifierFoundInScope = ReadDeclAs<NamedDecl>();
  ReadDeclarationNameInfo(E->MemberNameInfo);
d1497 1
a1497 1
  if (Record.readInt()) // HasTemplateKWAndArgsInfo
d1501 1
a1501 1
        /*NumTemplateArgs=*/Record.readInt());
d1503 2
a1504 2
  E->QualifierLoc = Record.readNestedNameSpecifierLoc();
  ReadDeclarationNameInfo(E->NameInfo);
d1510 2
a1511 3
  assert(Record.peekInt() == E->arg_size() &&
         "Read wrong record during creation ?");
  Record.skipInts(1);
d1513 4
a1516 4
    E->setArg(I, Record.readSubExpr());
  E->Type = GetTypeSourceInfo();
  E->setLParenLoc(ReadSourceLocation());
  E->setRParenLoc(ReadSourceLocation());
d1522 1
a1522 1
  if (Record.readInt()) // HasTemplateKWAndArgsInfo
d1525 1
a1525 1
                              /*NumTemplateArgs=*/Record.readInt());
d1527 1
a1527 1
  unsigned NumDecls = Record.readInt();
d1530 2
a1531 2
    NamedDecl *D = ReadDeclAs<NamedDecl>();
    AccessSpecifier AS = (AccessSpecifier)Record.readInt();
d1534 1
a1534 1
  E->initializeResults(Record.getContext(), Decls.begin(), Decls.end());
d1536 2
a1537 2
  ReadDeclarationNameInfo(E->NameInfo);
  E->QualifierLoc = Record.readNestedNameSpecifierLoc();
d1542 5
a1546 5
  E->IsArrow = Record.readInt();
  E->HasUnresolvedUsing = Record.readInt();
  E->Base = Record.readSubExpr();
  E->BaseType = Record.readType();
  E->OperatorLoc = ReadSourceLocation();
d1551 3
a1553 3
  E->RequiresADL = Record.readInt();
  E->Overloaded = Record.readInt();
  E->NamingClass = ReadDeclAs<CXXRecordDecl>();
d1558 4
a1561 4
  E->TypeTraitExprBits.NumArgs = Record.readInt();
  E->TypeTraitExprBits.Kind = Record.readInt();
  E->TypeTraitExprBits.Value = Record.readInt();
  SourceRange Range = ReadSourceRange();
d1567 1
a1567 1
    Args[I] = GetTypeSourceInfo();
d1572 3
a1574 3
  E->ATT = (ArrayTypeTrait)Record.readInt();
  E->Value = (unsigned int)Record.readInt();
  SourceRange Range = ReadSourceRange();
d1577 1
a1577 2
  E->QueriedType = GetTypeSourceInfo();
  E->Dimension = Record.readSubExpr();
d1582 4
a1585 4
  E->ET = (ExpressionTrait)Record.readInt();
  E->Value = (bool)Record.readInt();
  SourceRange Range = ReadSourceRange();
  E->QueriedExpression = Record.readSubExpr();
d1592 3
a1594 3
  E->Value = (bool)Record.readInt();
  E->Range = ReadSourceRange();
  E->Operand = Record.readSubExpr();
d1599 3
a1601 3
  E->EllipsisLoc = ReadSourceLocation();
  E->NumExpansions = Record.readInt();
  E->Pattern = Record.readSubExpr();
d1606 5
a1610 5
  unsigned NumPartialArgs = Record.readInt();
  E->OperatorLoc = ReadSourceLocation();
  E->PackLoc = ReadSourceLocation();
  E->RParenLoc = ReadSourceLocation();
  E->Pack = Record.readDeclAs<NamedDecl>();
d1616 1
a1616 1
      new (I) TemplateArgument(Record.readTemplateArgument());
d1618 1
a1618 1
    E->Length = Record.readInt();
d1625 3
a1627 3
  E->Param = ReadDeclAs<NonTypeTemplateParmDecl>();
  E->NameLoc = ReadSourceLocation();
  E->Replacement = Record.readSubExpr();
d1633 2
a1634 2
  E->Param = ReadDeclAs<NonTypeTemplateParmDecl>();
  TemplateArgument ArgPack = Record.readTemplateArgument();
d1637 1
a1637 1

d1640 1
a1640 1
  E->NameLoc = ReadSourceLocation();
d1645 3
a1647 3
  E->NumParameters = Record.readInt();
  E->ParamPack = ReadDeclAs<ParmVarDecl>();
  E->NameLoc = ReadSourceLocation();
d1650 1
a1650 1
    Parms[i] = ReadDeclAs<ParmVarDecl>();
d1655 3
a1657 3
  E->State = Record.readSubExpr();
  auto VD = ReadDeclAs<ValueDecl>();
  unsigned ManglingNumber = Record.readInt();
d1663 6
a1668 6
  E->LParenLoc = ReadSourceLocation();
  E->EllipsisLoc = ReadSourceLocation();
  E->RParenLoc = ReadSourceLocation();
  E->SubExprs[0] = Record.readSubExpr();
  E->SubExprs[1] = Record.readSubExpr();
  E->Opcode = (BinaryOperatorKind)Record.readInt();
d1673 2
a1674 2
  E->SourceExpr = Record.readSubExpr();
  E->Loc = ReadSourceLocation();
d1686 5
a1690 5
  E->IsArrow = (Record.readInt() != 0);
  E->BaseExpr = Record.readSubExpr();
  E->QualifierLoc = Record.readNestedNameSpecifierLoc();
  E->MemberLoc = ReadSourceLocation();
  E->TheDecl = ReadDeclAs<MSPropertyDecl>();
d1695 3
a1697 3
  E->setBase(Record.readSubExpr());
  E->setIdx(Record.readSubExpr());
  E->setRBracketLoc(ReadSourceLocation());
d1702 3
a1704 3
  E->setSourceRange(ReadSourceRange());
  std::string UuidStr = ReadString();
  E->setUuidStr(StringRef(UuidStr).copy(Record.getContext()));
d1707 1
a1707 1
        GetTypeSourceInfo());
d1710 1
a1710 1

d1712 1
a1712 1
  E->setExprOperand(Record.readSubExpr());
d1717 1
a1717 1
  S->setLeaveLoc(ReadSourceLocation());
d1722 3
a1724 3
  S->Loc = ReadSourceLocation();
  S->Children[SEHExceptStmt::FILTER_EXPR] = Record.readSubStmt();
  S->Children[SEHExceptStmt::BLOCK] = Record.readSubStmt();
d1729 2
a1730 2
  S->Loc = ReadSourceLocation();
  S->Block = Record.readSubStmt();
d1735 4
a1738 4
  S->IsCXXTry = Record.readInt();
  S->TryLoc = ReadSourceLocation();
  S->Children[SEHTryStmt::TRY] = Record.readSubStmt();
  S->Children[SEHTryStmt::HANDLER] = Record.readSubStmt();
d1747 1
a1747 1
  E->setConfig(cast<CallExpr>(Record.readSubExpr()));
d1755 3
a1757 3
  E->BuiltinLoc = ReadSourceLocation();
  E->RParenLoc = ReadSourceLocation();
  E->SrcExpr = Record.readSubExpr();
d1768 2
d1771 3
a1773 2
  OMPClauseReader(ASTStmtReader *R, ASTRecordReader &Record)
      : Reader(R), Context(Record.getContext()) {}
d1784 1
a1784 1
  switch (Reader->Record.readInt()) {
d1849 1
a1849 1
    C = OMPPrivateClause::CreateEmpty(Context, Reader->Record.readInt());
d1852 1
a1852 1
    C = OMPFirstprivateClause::CreateEmpty(Context, Reader->Record.readInt());
d1855 1
a1855 1
    C = OMPLastprivateClause::CreateEmpty(Context, Reader->Record.readInt());
d1858 1
a1858 1
    C = OMPSharedClause::CreateEmpty(Context, Reader->Record.readInt());
d1861 1
a1861 1
    C = OMPReductionClause::CreateEmpty(Context, Reader->Record.readInt());
d1864 1
a1864 1
    C = OMPLinearClause::CreateEmpty(Context, Reader->Record.readInt());
d1867 1
a1867 1
    C = OMPAlignedClause::CreateEmpty(Context, Reader->Record.readInt());
d1870 1
a1870 1
    C = OMPCopyinClause::CreateEmpty(Context, Reader->Record.readInt());
d1873 1
a1873 1
    C = OMPCopyprivateClause::CreateEmpty(Context, Reader->Record.readInt());
d1876 1
a1876 1
    C = OMPFlushClause::CreateEmpty(Context, Reader->Record.readInt());
d1879 1
a1879 1
    C = OMPDependClause::CreateEmpty(Context, Reader->Record.readInt());
d1885 4
a1888 4
    unsigned NumVars = Reader->Record.readInt();
    unsigned NumDeclarations = Reader->Record.readInt();
    unsigned NumLists = Reader->Record.readInt();
    unsigned NumComponents = Reader->Record.readInt();
d1918 4
a1921 4
    unsigned NumVars = Reader->Record.readInt();
    unsigned NumDeclarations = Reader->Record.readInt();
    unsigned NumLists = Reader->Record.readInt();
    unsigned NumComponents = Reader->Record.readInt();
d1927 4
a1930 4
    unsigned NumVars = Reader->Record.readInt();
    unsigned NumDeclarations = Reader->Record.readInt();
    unsigned NumLists = Reader->Record.readInt();
    unsigned NumComponents = Reader->Record.readInt();
d1935 5
a1939 16
  case OMPC_use_device_ptr: {
    unsigned NumVars = Reader->Record.readInt();
    unsigned NumDeclarations = Reader->Record.readInt();
    unsigned NumLists = Reader->Record.readInt();
    unsigned NumComponents = Reader->Record.readInt();
    C = OMPUseDevicePtrClause::CreateEmpty(Context, NumVars, NumDeclarations,
                                           NumLists, NumComponents);
    break;
  }
  case OMPC_is_device_ptr: {
    unsigned NumVars = Reader->Record.readInt();
    unsigned NumDeclarations = Reader->Record.readInt();
    unsigned NumLists = Reader->Record.readInt();
    unsigned NumComponents = Reader->Record.readInt();
    C = OMPIsDevicePtrClause::CreateEmpty(Context, NumVars, NumDeclarations,
                                          NumLists, NumComponents);
a1941 1
  }
d1943 2
a1944 2
  C->setLocStart(Reader->ReadSourceLocation());
  C->setLocEnd(Reader->ReadSourceLocation());
d1950 1
a1950 1
  C->setPreInitStmt(Reader->Record.readSubStmt());
d1955 1
a1955 1
  C->setPostUpdateExpr(Reader->Record.readSubExpr());
d1959 5
a1963 5
  C->setNameModifier(static_cast<OpenMPDirectiveKind>(Reader->Record.readInt()));
  C->setNameModifierLoc(Reader->ReadSourceLocation());
  C->setColonLoc(Reader->ReadSourceLocation());
  C->setCondition(Reader->Record.readSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation());
d1967 2
a1968 2
  C->setCondition(Reader->Record.readSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation());
d1972 2
a1973 2
  C->setNumThreads(Reader->Record.readSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation());
d1977 2
a1978 2
  C->setSafelen(Reader->Record.readSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation());
d1982 2
a1983 2
  C->setSimdlen(Reader->Record.readSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation());
d1987 2
a1988 2
  C->setNumForLoops(Reader->Record.readSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation());
d1993 3
a1995 3
       static_cast<OpenMPDefaultClauseKind>(Reader->Record.readInt()));
  C->setLParenLoc(Reader->ReadSourceLocation());
  C->setDefaultKindKwLoc(Reader->ReadSourceLocation());
d2000 3
a2002 3
       static_cast<OpenMPProcBindClauseKind>(Reader->Record.readInt()));
  C->setLParenLoc(Reader->ReadSourceLocation());
  C->setProcBindKindKwLoc(Reader->ReadSourceLocation());
d2008 1
a2008 1
       static_cast<OpenMPScheduleClauseKind>(Reader->Record.readInt()));
d2010 1
a2010 1
      static_cast<OpenMPScheduleClauseModifier>(Reader->Record.readInt()));
d2012 7
a2018 7
      static_cast<OpenMPScheduleClauseModifier>(Reader->Record.readInt()));
  C->setChunkSize(Reader->Record.readSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation());
  C->setFirstScheduleModifierLoc(Reader->ReadSourceLocation());
  C->setSecondScheduleModifierLoc(Reader->ReadSourceLocation());
  C->setScheduleKindLoc(Reader->ReadSourceLocation());
  C->setCommaLoc(Reader->ReadSourceLocation());
d2022 2
a2023 2
  C->setNumForLoops(Reader->Record.readSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation());
d2049 1
a2049 1
  C->setLParenLoc(Reader->ReadSourceLocation());
d2054 1
a2054 1
    Vars.push_back(Reader->Record.readSubExpr());
d2058 1
a2058 1
    Vars.push_back(Reader->Record.readSubExpr());
d2064 1
a2064 1
  C->setLParenLoc(Reader->ReadSourceLocation());
d2069 1
a2069 1
    Vars.push_back(Reader->Record.readSubExpr());
d2073 1
a2073 1
    Vars.push_back(Reader->Record.readSubExpr());
d2077 1
a2077 1
    Vars.push_back(Reader->Record.readSubExpr());
d2083 1
a2083 1
  C->setLParenLoc(Reader->ReadSourceLocation());
d2088 1
a2088 1
    Vars.push_back(Reader->Record.readSubExpr());
d2092 1
a2092 1
    Vars.push_back(Reader->Record.readSubExpr());
d2096 1
a2096 1
    Vars.push_back(Reader->Record.readSubExpr());
d2100 1
a2100 1
    Vars.push_back(Reader->Record.readSubExpr());
d2104 1
a2104 1
    Vars.push_back(Reader->Record.readSubExpr());
d2109 1
a2109 1
  C->setLParenLoc(Reader->ReadSourceLocation());
d2114 1
a2114 1
    Vars.push_back(Reader->Record.readSubExpr());
d2120 4
a2123 3
  C->setLParenLoc(Reader->ReadSourceLocation());
  C->setColonLoc(Reader->ReadSourceLocation());
  NestedNameSpecifierLoc NNSL = Reader->Record.readNestedNameSpecifierLoc();
d2125 1
a2125 1
  Reader->ReadDeclarationNameInfo(DNI);
d2133 1
a2133 1
    Vars.push_back(Reader->Record.readSubExpr());
d2137 1
a2137 1
    Vars.push_back(Reader->Record.readSubExpr());
d2141 1
a2141 1
    Vars.push_back(Reader->Record.readSubExpr());
d2145 1
a2145 1
    Vars.push_back(Reader->Record.readSubExpr());
d2149 1
a2149 1
    Vars.push_back(Reader->Record.readSubExpr());
d2155 4
a2158 4
  C->setLParenLoc(Reader->ReadSourceLocation());
  C->setColonLoc(Reader->ReadSourceLocation());
  C->setModifier(static_cast<OpenMPLinearClauseKind>(Reader->Record.readInt()));
  C->setModifierLoc(Reader->ReadSourceLocation());
d2163 1
a2163 1
    Vars.push_back(Reader->Record.readSubExpr());
d2167 1
a2167 1
    Vars.push_back(Reader->Record.readSubExpr());
d2171 1
a2171 1
    Vars.push_back(Reader->Record.readSubExpr());
d2175 1
a2175 1
    Vars.push_back(Reader->Record.readSubExpr());
d2179 1
a2179 1
    Vars.push_back(Reader->Record.readSubExpr());
d2181 2
a2182 2
  C->setStep(Reader->Record.readSubExpr());
  C->setCalcStep(Reader->Record.readSubExpr());
d2186 2
a2187 2
  C->setLParenLoc(Reader->ReadSourceLocation());
  C->setColonLoc(Reader->ReadSourceLocation());
d2192 1
a2192 1
    Vars.push_back(Reader->Record.readSubExpr());
d2194 1
a2194 1
  C->setAlignment(Reader->Record.readSubExpr());
d2198 1
a2198 1
  C->setLParenLoc(Reader->ReadSourceLocation());
d2203 1
a2203 1
    Exprs.push_back(Reader->Record.readSubExpr());
d2207 1
a2207 1
    Exprs.push_back(Reader->Record.readSubExpr());
d2211 1
a2211 1
    Exprs.push_back(Reader->Record.readSubExpr());
d2215 1
a2215 1
    Exprs.push_back(Reader->Record.readSubExpr());
d2220 1
a2220 1
  C->setLParenLoc(Reader->ReadSourceLocation());
d2225 1
a2225 1
    Exprs.push_back(Reader->Record.readSubExpr());
d2229 1
a2229 1
    Exprs.push_back(Reader->Record.readSubExpr());
d2233 1
a2233 1
    Exprs.push_back(Reader->Record.readSubExpr());
d2237 1
a2237 1
    Exprs.push_back(Reader->Record.readSubExpr());
d2242 1
a2242 1
  C->setLParenLoc(Reader->ReadSourceLocation());
d2247 1
a2247 1
    Vars.push_back(Reader->Record.readSubExpr());
d2252 4
a2255 5
  C->setLParenLoc(Reader->ReadSourceLocation());
  C->setDependencyKind(
      static_cast<OpenMPDependClauseKind>(Reader->Record.readInt()));
  C->setDependencyLoc(Reader->ReadSourceLocation());
  C->setColonLoc(Reader->ReadSourceLocation());
d2260 1
a2260 1
    Vars.push_back(Reader->Record.readSubExpr());
d2262 1
a2262 1
  C->setCounterValue(Reader->Record.readSubExpr());
d2266 2
a2267 2
  C->setDevice(Reader->Record.readSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation());
d2271 1
a2271 1
  C->setLParenLoc(Reader->ReadSourceLocation());
d2273 1
a2273 1
     static_cast<OpenMPMapClauseKind>(Reader->Record.readInt()));
d2275 3
a2277 3
     static_cast<OpenMPMapClauseKind>(Reader->Record.readInt()));
  C->setMapLoc(Reader->ReadSourceLocation());
  C->setColonLoc(Reader->ReadSourceLocation());
d2286 1
a2286 1
    Vars.push_back(Reader->Record.readSubExpr());
d2292 2
a2293 1
    Decls.push_back(Reader->Record.readDeclAs<ValueDecl>());
d2299 1
a2299 1
    ListsPerDecl.push_back(Reader->Record.readInt());
d2305 1
a2305 1
    ListSizes.push_back(Reader->Record.readInt());
d2311 3
a2313 2
    Expr *AssociatedExpr = Reader->Record.readSubExpr();
    ValueDecl *AssociatedDecl = Reader->Record.readDeclAs<ValueDecl>();
d2321 2
a2322 2
  C->setNumTeams(Reader->Record.readSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation());
d2326 2
a2327 2
  C->setThreadLimit(Reader->Record.readSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation());
d2331 2
a2332 2
  C->setPriority(Reader->Record.readSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation());
d2336 2
a2337 2
  C->setGrainsize(Reader->Record.readSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation());
d2341 2
a2342 2
  C->setNumTasks(Reader->Record.readSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation());
d2346 2
a2347 2
  C->setHint(Reader->Record.readSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation());
d2353 5
a2357 5
      static_cast<OpenMPDistScheduleClauseKind>(Reader->Record.readInt()));
  C->setChunkSize(Reader->Record.readSubExpr());
  C->setLParenLoc(Reader->ReadSourceLocation());
  C->setDistScheduleKindLoc(Reader->ReadSourceLocation());
  C->setCommaLoc(Reader->ReadSourceLocation());
d2362 1
a2362 1
       static_cast<OpenMPDefaultmapClauseKind>(Reader->Record.readInt()));
d2364 4
a2367 4
      static_cast<OpenMPDefaultmapClauseModifier>(Reader->Record.readInt()));
  C->setLParenLoc(Reader->ReadSourceLocation());
  C->setDefaultmapModifierLoc(Reader->ReadSourceLocation());
  C->setDefaultmapKindLoc(Reader->ReadSourceLocation());
d2371 1
a2371 1
  C->setLParenLoc(Reader->ReadSourceLocation());
d2380 1
a2380 1
    Vars.push_back(Reader->Record.readSubExpr());
d2386 2
a2387 1
    Decls.push_back(Reader->Record.readDeclAs<ValueDecl>());
d2393 1
a2393 1
    ListsPerDecl.push_back(Reader->Record.readInt());
d2399 1
a2399 1
    ListSizes.push_back(Reader->Record.readInt());
d2405 3
a2407 2
    Expr *AssociatedExpr = Reader->Record.readSubExpr();
    ValueDecl *AssociatedDecl = Reader->Record.readDeclAs<ValueDecl>();
d2415 1
a2415 1
  C->setLParenLoc(Reader->ReadSourceLocation());
d2424 1
a2424 1
    Vars.push_back(Reader->Record.readSubExpr());
d2430 2
a2431 1
    Decls.push_back(Reader->Record.readDeclAs<ValueDecl>());
d2437 1
a2437 1
    ListsPerDecl.push_back(Reader->Record.readInt());
d2443 1
a2443 1
    ListSizes.push_back(Reader->Record.readInt());
d2449 3
a2451 2
    Expr *AssociatedExpr = Reader->Record.readSubExpr();
    ValueDecl *AssociatedDecl = Reader->Record.readDeclAs<ValueDecl>();
d2459 2
a2460 6
  C->setLParenLoc(Reader->ReadSourceLocation());
  auto NumVars = C->varlist_size();
  auto UniqueDecls = C->getUniqueDeclarationsNum();
  auto TotalLists = C->getTotalComponentListNum();
  auto TotalComponents = C->getTotalComponentsNum();

d2464 1
a2464 1
    Vars.push_back(Reader->Record.readSubExpr());
a2466 35
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Record.readSubExpr());
  C->setPrivateCopies(Vars);
  Vars.clear();
  for (unsigned i = 0; i != NumVars; ++i)
    Vars.push_back(Reader->Record.readSubExpr());
  C->setInits(Vars);

  SmallVector<ValueDecl *, 16> Decls;
  Decls.reserve(UniqueDecls);
  for (unsigned i = 0; i < UniqueDecls; ++i)
    Decls.push_back(Reader->Record.readDeclAs<ValueDecl>());
  C->setUniqueDecls(Decls);

  SmallVector<unsigned, 16> ListsPerDecl;
  ListsPerDecl.reserve(UniqueDecls);
  for (unsigned i = 0; i < UniqueDecls; ++i)
    ListsPerDecl.push_back(Reader->Record.readInt());
  C->setDeclNumLists(ListsPerDecl);

  SmallVector<unsigned, 32> ListSizes;
  ListSizes.reserve(TotalLists);
  for (unsigned i = 0; i < TotalLists; ++i)
    ListSizes.push_back(Reader->Record.readInt());
  C->setComponentListSizes(ListSizes);

  SmallVector<OMPClauseMappableExprCommon::MappableComponent, 32> Components;
  Components.reserve(TotalComponents);
  for (unsigned i = 0; i < TotalComponents; ++i) {
    Expr *AssociatedExpr = Reader->Record.readSubExpr();
    ValueDecl *AssociatedDecl = Reader->Record.readDeclAs<ValueDecl>();
    Components.push_back(OMPClauseMappableExprCommon::MappableComponent(
        AssociatedExpr, AssociatedDecl));
  }
  C->setComponents(Components, ListSizes);
d2470 2
a2471 6
  C->setLParenLoc(Reader->ReadSourceLocation());
  auto NumVars = C->varlist_size();
  auto UniqueDecls = C->getUniqueDeclarationsNum();
  auto TotalLists = C->getTotalComponentListNum();
  auto TotalComponents = C->getTotalComponentsNum();

d2475 1
a2475 1
    Vars.push_back(Reader->Record.readSubExpr());
a2477 28

  SmallVector<ValueDecl *, 16> Decls;
  Decls.reserve(UniqueDecls);
  for (unsigned i = 0; i < UniqueDecls; ++i)
    Decls.push_back(Reader->Record.readDeclAs<ValueDecl>());
  C->setUniqueDecls(Decls);

  SmallVector<unsigned, 16> ListsPerDecl;
  ListsPerDecl.reserve(UniqueDecls);
  for (unsigned i = 0; i < UniqueDecls; ++i)
    ListsPerDecl.push_back(Reader->Record.readInt());
  C->setDeclNumLists(ListsPerDecl);

  SmallVector<unsigned, 32> ListSizes;
  ListSizes.reserve(TotalLists);
  for (unsigned i = 0; i < TotalLists; ++i)
    ListSizes.push_back(Reader->Record.readInt());
  C->setComponentListSizes(ListSizes);

  SmallVector<OMPClauseMappableExprCommon::MappableComponent, 32> Components;
  Components.reserve(TotalComponents);
  for (unsigned i = 0; i < TotalComponents; ++i) {
    Expr *AssociatedExpr = Reader->Record.readSubExpr();
    ValueDecl *AssociatedDecl = Reader->Record.readDeclAs<ValueDecl>();
    Components.push_back(OMPClauseMappableExprCommon::MappableComponent(
        AssociatedExpr, AssociatedDecl));
  }
  C->setComponents(Components, ListSizes);
d2484 3
a2486 3
  E->setLocStart(ReadSourceLocation());
  E->setLocEnd(ReadSourceLocation());
  OMPClauseReader ClauseReader(this, Record);
d2492 1
a2492 1
    E->setAssociatedStmt(Record.readSubStmt());
d2498 1
a2498 1
  Record.skipInts(2);
d2500 8
a2507 8
  D->setIterationVariable(Record.readSubExpr());
  D->setLastIteration(Record.readSubExpr());
  D->setCalcLastIteration(Record.readSubExpr());
  D->setPreCond(Record.readSubExpr());
  D->setCond(Record.readSubExpr());
  D->setInit(Record.readSubExpr());
  D->setInc(Record.readSubExpr());
  D->setPreInits(Record.readSubStmt());
d2511 8
a2518 8
    D->setIsLastIterVariable(Record.readSubExpr());
    D->setLowerBoundVariable(Record.readSubExpr());
    D->setUpperBoundVariable(Record.readSubExpr());
    D->setStrideVariable(Record.readSubExpr());
    D->setEnsureUpperBound(Record.readSubExpr());
    D->setNextLowerBound(Record.readSubExpr());
    D->setNextUpperBound(Record.readSubExpr());
    D->setNumIterations(Record.readSubExpr());
d2521 2
a2522 2
    D->setPrevLowerBoundVariable(Record.readSubExpr());
    D->setPrevUpperBoundVariable(Record.readSubExpr());
d2528 1
a2528 1
    Sub.push_back(Record.readSubExpr());
d2532 1
a2532 1
    Sub.push_back(Record.readSubExpr());
d2536 1
a2536 1
    Sub.push_back(Record.readSubExpr());
d2540 1
a2540 1
    Sub.push_back(Record.readSubExpr());
d2544 1
a2544 1
    Sub.push_back(Record.readSubExpr());
d2551 1
a2551 1
  Record.skipInts(1);
d2553 1
a2553 1
  D->setHasCancel(Record.readInt());
d2562 1
a2562 1
  D->setHasCancel(Record.readInt());
d2572 1
a2572 1
  Record.skipInts(1);
d2574 1
a2574 1
  D->setHasCancel(Record.readInt());
d2580 1
a2580 1
  D->setHasCancel(Record.readInt());
d2586 1
a2586 1
  Record.skipInts(1);
d2598 1
a2598 1
  Record.skipInts(1);
d2600 1
a2600 1
  ReadDeclarationNameInfo(D->DirName);
d2605 1
a2605 1
  D->setHasCancel(Record.readInt());
d2617 1
a2617 1
  Record.skipInts(1);
d2619 1
a2619 1
  D->setHasCancel(Record.readInt());
d2625 1
a2625 1
  Record.skipInts(1);
d2627 1
a2627 1
  D->setHasCancel(Record.readInt());
d2653 1
a2653 1
  Record.skipInts(1);
d2660 1
a2660 1
  Record.skipInts(1);
d2667 1
a2667 1
  Record.skipInts(1);
d2669 6
a2674 6
  D->setX(Record.readSubExpr());
  D->setV(Record.readSubExpr());
  D->setExpr(Record.readSubExpr());
  D->setUpdateExpr(Record.readSubExpr());
  D->IsXLHSInRHSPart = Record.readInt() != 0;
  D->IsPostfixUpdate = Record.readInt() != 0;
d2680 1
a2680 1
  Record.skipInts(1);
d2686 1
a2686 1
  Record.skipInts(1);
d2693 1
a2693 1
  Record.skipInts(1);
d2700 1
a2700 1
  Record.skipInts(1);
d2707 1
a2707 1
  Record.skipInts(1);
d2714 1
a2714 1
  D->setHasCancel(Record.readInt());
d2720 1
a2720 1
  Record.skipInts(1);
d2728 1
a2728 1
  D->setCancelRegion(static_cast<OpenMPDirectiveKind>(Record.readInt()));
d2734 1
a2734 1
  Record.skipInts(1);
d2736 1
a2736 1
  D->setCancelRegion(static_cast<OpenMPDirectiveKind>(Record.readInt()));
d2753 1
a2753 1
  Record.skipInts(1);
a2775 51
void ASTStmtReader::VisitOMPTargetSimdDirective(OMPTargetSimdDirective *D) {
  VisitOMPLoopDirective(D);
}

void ASTStmtReader::VisitOMPTeamsDistributeDirective(
    OMPTeamsDistributeDirective *D) {
  VisitOMPLoopDirective(D);
}

void ASTStmtReader::VisitOMPTeamsDistributeSimdDirective(
    OMPTeamsDistributeSimdDirective *D) {
  VisitOMPLoopDirective(D);
}

void ASTStmtReader::VisitOMPTeamsDistributeParallelForSimdDirective(
    OMPTeamsDistributeParallelForSimdDirective *D) {
  VisitOMPLoopDirective(D);
}

void ASTStmtReader::VisitOMPTeamsDistributeParallelForDirective(
    OMPTeamsDistributeParallelForDirective *D) {
  VisitOMPLoopDirective(D);
}

void ASTStmtReader::VisitOMPTargetTeamsDirective(OMPTargetTeamsDirective *D) {
  VisitStmt(D);
  // The NumClauses field was read in ReadStmtFromStream.
  Record.skipInts(1);
  VisitOMPExecutableDirective(D);
}

void ASTStmtReader::VisitOMPTargetTeamsDistributeDirective(
    OMPTargetTeamsDistributeDirective *D) {
  VisitOMPLoopDirective(D);
}

void ASTStmtReader::VisitOMPTargetTeamsDistributeParallelForDirective(
    OMPTargetTeamsDistributeParallelForDirective *D) {
  VisitOMPLoopDirective(D);
}

void ASTStmtReader::VisitOMPTargetTeamsDistributeParallelForSimdDirective(
    OMPTargetTeamsDistributeParallelForSimdDirective *D) {
  VisitOMPLoopDirective(D);
}

void ASTStmtReader::VisitOMPTargetTeamsDistributeSimdDirective(
    OMPTargetTeamsDistributeSimdDirective *D) {
  VisitOMPLoopDirective(D);
}

d2813 1
a2813 1

d2822 3
a2824 2
  ASTRecordReader Record(*this, F);
  ASTStmtReader Reader(Record, Cursor);
d2829 1
a2829 1

d2843 2
d2847 1
a2847 1
    switch ((StmtCode)Record.readRecord(Cursor, Entry.ID)) {
d2856 1
a2856 1
      S = StmtEntries[Record.readInt()];
d2994 1
a2994 1
      S = OffsetOfExpr::CreateEmpty(Context,
d2998 1
a2998 1

d3020 1
a3020 1
      assert(Record.getIdx() == 0);
d3022 2
a3023 2
      if (Record.readInt()) { // HasQualifier.
        QualifierLoc = Record.readNestedNameSpecifierLoc();
d3028 1
a3028 1
      bool HasTemplateKWAndArgsInfo = Record.readInt();
d3030 4
a3033 4
        TemplateKWLoc = Record.readSourceLocation();
        unsigned NumTemplateArgs = Record.readInt();
        ArgInfo.setLAngleLoc(Record.readSourceLocation());
        ArgInfo.setRAngleLoc(Record.readSourceLocation());
d3035 1
a3035 1
          ArgInfo.addArgument(Record.readTemplateArgumentLoc());
d3038 1
a3038 1
      bool HadMultipleCandidates = Record.readInt();
d3040 2
a3041 2
      NamedDecl *FoundD = Record.readDeclAs<NamedDecl>();
      AccessSpecifier AS = (AccessSpecifier)Record.readInt();
d3044 3
a3046 3
      QualType T = Record.readType();
      ExprValueKind VK = static_cast<ExprValueKind>(Record.readInt());
      ExprObjectKind OK = static_cast<ExprObjectKind>(Record.readInt());
d3048 2
a3049 2
      ValueDecl *MemberD = Record.readDeclAs<ValueDecl>();
      SourceLocation MemberLoc = Record.readSourceLocation();
d3051 2
a3052 2
      bool IsArrow = Record.readInt();
      SourceLocation OperatorLoc = Record.readSourceLocation();
d3058 2
a3059 2
      Record.readDeclarationNameLoc(cast<MemberExpr>(S)->MemberDNLoc,
                                    MemberD->getDeclName());
a3120 8
    case EXPR_ARRAY_INIT_LOOP:
      S = new (Context) ArrayInitLoopExpr(Empty);
      break;

    case EXPR_ARRAY_INIT_INDEX:
      S = new (Context) ArrayInitIndexExpr(Empty);
      break;

d3216 1
a3216 1
      S = ObjCAtTryStmt::CreateEmpty(Context,
a3486 78
    case STMT_OMP_TARGET_SIMD_DIRECTIVE: {
      auto NumClauses = Record[ASTStmtReader::NumStmtFields];
      auto CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
      S = OMPTargetSimdDirective::CreateEmpty(Context, NumClauses, CollapsedNum,
                                              Empty);
      break;
    }

     case STMT_OMP_TEAMS_DISTRIBUTE_DIRECTIVE: {
      auto NumClauses = Record[ASTStmtReader::NumStmtFields];
      auto CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
      S = OMPTeamsDistributeDirective::CreateEmpty(Context, NumClauses,
                                                   CollapsedNum, Empty);
      break;
    }

    case STMT_OMP_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE: {
      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields];
      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
      S = OMPTeamsDistributeSimdDirective::CreateEmpty(Context, NumClauses,
                                                       CollapsedNum, Empty);
      break;
    }

    case STMT_OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE: {
      auto NumClauses = Record[ASTStmtReader::NumStmtFields];
      auto CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
      S = OMPTeamsDistributeParallelForSimdDirective::CreateEmpty(
          Context, NumClauses, CollapsedNum, Empty);
      break;
    }

    case STMT_OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE: {
      auto NumClauses = Record[ASTStmtReader::NumStmtFields];
      auto CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
      S = OMPTeamsDistributeParallelForDirective::CreateEmpty(
          Context, NumClauses, CollapsedNum, Empty);
      break;
    }

    case STMT_OMP_TARGET_TEAMS_DIRECTIVE: {
      S = OMPTargetTeamsDirective::CreateEmpty(
          Context, Record[ASTStmtReader::NumStmtFields], Empty);
      break;
    }

    case STMT_OMP_TARGET_TEAMS_DISTRIBUTE_DIRECTIVE: {
      auto NumClauses = Record[ASTStmtReader::NumStmtFields];
      auto CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
      S = OMPTargetTeamsDistributeDirective::CreateEmpty(Context, NumClauses,
                                                         CollapsedNum, Empty);
      break;
    }

    case STMT_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE: {
      auto NumClauses = Record[ASTStmtReader::NumStmtFields];
      auto CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
      S = OMPTargetTeamsDistributeParallelForDirective::CreateEmpty(
          Context, NumClauses, CollapsedNum, Empty);
      break;
    }

    case STMT_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE: {
      auto NumClauses = Record[ASTStmtReader::NumStmtFields];
      auto CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
      S = OMPTargetTeamsDistributeParallelForSimdDirective::CreateEmpty(
          Context, NumClauses, CollapsedNum, Empty);
      break;
    }

    case STMT_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE: {
      auto NumClauses = Record[ASTStmtReader::NumStmtFields];
      auto CollapsedNum = Record[ASTStmtReader::NumStmtFields + 1];
      S = OMPTargetTeamsDistributeSimdDirective::CreateEmpty(
          Context, NumClauses, CollapsedNum, Empty);
      break;
    }

d3579 1
a3579 1

d3592 1
a3592 1

d3597 1
a3597 1

d3602 1
a3602 1
                                   ? Record[ASTStmtReader::NumExprFields + 1]
d3605 1
a3605 1

d3610 1
a3610 1
                                   ? Record[ASTStmtReader::NumExprFields + 1]
d3613 1
a3613 1

d3618 1
a3618 1

d3623 1
a3623 1
                                   ? Record[ASTStmtReader::NumExprFields + 1]
d3626 1
a3626 1

d3631 1
a3631 1
                                   ? Record[ASTStmtReader::NumExprFields + 1]
d3636 1
a3636 1
      S = TypeTraitExpr::CreateDeserialized(Context,
d3639 1
a3639 1

d3655 1
a3655 1

d3661 1
a3661 1

d3665 1
a3665 1

d3674 1
a3674 1

d3690 1
a3690 1

d3704 1
a3704 1

d3707 3
a3709 1
      S = LambdaExpr::CreateDeserialized(Context, NumCaptures);
d3713 1
a3713 1

d3725 2
a3726 2
    assert(Record.getIdx() == Record.size() &&
           "Invalid deserialization of statement");
@


