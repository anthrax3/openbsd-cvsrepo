head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.2.0.2
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.24.08.33.05;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===- unittests/Tooling/ReplacementsYamlTest.cpp - Serialization tests ---===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// Tests for serialization of Replacements.
//
//===----------------------------------------------------------------------===//

#include "clang/Tooling/ReplacementsYaml.h"
#include "gtest/gtest.h"

using namespace llvm;
using namespace clang::tooling;

TEST(ReplacementsYamlTest, serializesReplacements) {

  TranslationUnitReplacements Doc;

  Doc.MainSourceFile = "/path/to/source.cpp";
  Doc.Context = "some context";
  Doc.Replacements
      .push_back(Replacement("/path/to/file1.h", 232, 56, "replacement #1"));
  Doc.Replacements
      .push_back(Replacement("/path/to/file2.h", 301, 2, "replacement #2"));

  std::string YamlContent;
  llvm::raw_string_ostream YamlContentStream(YamlContent);

  yaml::Output YAML(YamlContentStream);
  YAML << Doc;

  // NOTE: If this test starts to fail for no obvious reason, check whitespace.
  ASSERT_STREQ("---\n"
               "MainSourceFile:  /path/to/source.cpp\n"
               "Context:         some context\n"
               "Replacements:    \n" // Extra whitespace here!
               "  - FilePath:        /path/to/file1.h\n"
               "    Offset:          232\n"
               "    Length:          56\n"
               "    ReplacementText: 'replacement #1'\n"
               "  - FilePath:        /path/to/file2.h\n"
               "    Offset:          301\n"
               "    Length:          2\n"
               "    ReplacementText: 'replacement #2'\n"
               "...\n",
               YamlContentStream.str().c_str());
}

TEST(ReplacementsYamlTest, deserializesReplacements) {
  std::string YamlContent = "---\n"
                            "MainSourceFile:      /path/to/source.cpp\n"
                            "Context:             some context\n"
                            "Replacements:\n"
                            "  - FilePath:        /path/to/file1.h\n"
                            "    Offset:          232\n"
                            "    Length:          56\n"
                            "    ReplacementText: 'replacement #1'\n"
                            "  - FilePath:        /path/to/file2.h\n"
                            "    Offset:          301\n"
                            "    Length:          2\n"
                            "    ReplacementText: 'replacement #2'\n"
                            "...\n";
  TranslationUnitReplacements DocActual;
  yaml::Input YAML(YamlContent);
  YAML >> DocActual;
  ASSERT_FALSE(YAML.error());
  ASSERT_EQ(2u, DocActual.Replacements.size());
  ASSERT_EQ("/path/to/source.cpp", DocActual.MainSourceFile);
  ASSERT_EQ("some context", DocActual.Context);
  ASSERT_EQ("/path/to/file1.h", DocActual.Replacements[0].getFilePath());
  ASSERT_EQ(232u, DocActual.Replacements[0].getOffset());
  ASSERT_EQ(56u, DocActual.Replacements[0].getLength());
  ASSERT_EQ("replacement #1", DocActual.Replacements[0].getReplacementText());
  ASSERT_EQ("/path/to/file2.h", DocActual.Replacements[1].getFilePath());
  ASSERT_EQ(301u, DocActual.Replacements[1].getOffset());
  ASSERT_EQ(2u, DocActual.Replacements[1].getLength());
  ASSERT_EQ("replacement #2", DocActual.Replacements[1].getReplacementText());
}

TEST(ReplacementsYamlTest, deserializesWithoutContext) {
  // Make sure a doc can be read without the context field.
  std::string YamlContent = "---\n"
                            "MainSourceFile:      /path/to/source.cpp\n"
                            "Replacements:\n"
                            "  - FilePath:        target_file.h\n"
                            "    Offset:          1\n"
                            "    Length:          10\n"
                            "    ReplacementText: replacement\n"
                            "...\n";
  TranslationUnitReplacements DocActual;
  yaml::Input YAML(YamlContent);
  YAML >> DocActual;
  ASSERT_FALSE(YAML.error());
  ASSERT_EQ("/path/to/source.cpp", DocActual.MainSourceFile);
  ASSERT_EQ(1u, DocActual.Replacements.size());
  ASSERT_EQ(std::string(), DocActual.Context);
  ASSERT_EQ("target_file.h", DocActual.Replacements[0].getFilePath());
  ASSERT_EQ(1u, DocActual.Replacements[0].getOffset());
  ASSERT_EQ(10u, DocActual.Replacements[0].getLength());
  ASSERT_EQ("replacement", DocActual.Replacements[0].getReplacementText());
}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d25 5
a29 2
  Doc.Replacements.emplace_back("/path/to/file1.h", 232, 56, "replacement #1");
  Doc.Replacements.emplace_back("/path/to/file2.h", 301, 2, "replacement #2");
d40 1
d57 1
d74 1
d101 1
@

