head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.2
	OPENBSD_6_2:1.1.1.1.0.2
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.4
	OPENBSD_6_1_BASE:1.1.1.1
	LLVM_4_0_0:1.1.1.1
	LLVM_4_0_0_RC1:1.1.1.1
	LLVM_3_9_1:1.1.1.1
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.10.04.20.27.45;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===- unittest/Tooling/RefactoringCallbacksTest.cpp ----------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "clang/Tooling/RefactoringCallbacks.h"
#include "RewriterTestContext.h"
#include "clang/ASTMatchers/ASTMatchFinder.h"
#include "clang/ASTMatchers/ASTMatchers.h"
#include "gtest/gtest.h"

namespace clang {
namespace tooling {

using namespace ast_matchers;

template <typename T>
void expectRewritten(const std::string &Code,
                     const std::string &Expected,
                     const T &AMatcher,
                     RefactoringCallback &Callback) {
  MatchFinder Finder;
  Finder.addMatcher(AMatcher, &Callback);
  std::unique_ptr<tooling::FrontendActionFactory> Factory(
      tooling::newFrontendActionFactory(&Finder));
  ASSERT_TRUE(tooling::runToolOnCode(Factory->create(), Code))
      << "Parsing error in \"" << Code << "\"";
  RewriterTestContext Context;
  FileID ID = Context.createInMemoryFile("input.cc", Code);
  EXPECT_TRUE(tooling::applyAllReplacements(Callback.getReplacements(),
                                            Context.Rewrite));
  EXPECT_EQ(Expected, Context.getRewrittenText(ID));
}

TEST(RefactoringCallbacksTest, ReplacesStmtsWithString) {
  std::string Code = "void f() { int i = 1; }";
  std::string Expected = "void f() { ; }";
  ReplaceStmtWithText Callback("id", ";");
  expectRewritten(Code, Expected, id("id", declStmt()), Callback);
}

TEST(RefactoringCallbacksTest, ReplacesStmtsInCalledMacros) {
  std::string Code = "#define A void f() { int i = 1; }\nA";
  std::string Expected = "#define A void f() { ; }\nA";
  ReplaceStmtWithText Callback("id", ";");
  expectRewritten(Code, Expected, id("id", declStmt()), Callback);
}

TEST(RefactoringCallbacksTest, IgnoresStmtsInUncalledMacros) {
  std::string Code = "#define A void f() { int i = 1; }";
  std::string Expected = "#define A void f() { int i = 1; }";
  ReplaceStmtWithText Callback("id", ";");
  expectRewritten(Code, Expected, id("id", declStmt()), Callback);
}

TEST(RefactoringCallbacksTest, ReplacesInteger) {
  std::string Code = "void f() { int i = 1; }";
  std::string Expected = "void f() { int i = 2; }";
  ReplaceStmtWithText Callback("id", "2");
  expectRewritten(Code, Expected, id("id", expr(integerLiteral())),
                  Callback);
}

TEST(RefactoringCallbacksTest, ReplacesStmtWithStmt) {
  std::string Code = "void f() { int i = false ? 1 : i * 2; }";
  std::string Expected = "void f() { int i = i * 2; }";
  ReplaceStmtWithStmt Callback("always-false", "should-be");
  expectRewritten(Code, Expected,
      id("always-false", conditionalOperator(
          hasCondition(cxxBoolLiteral(equals(false))),
          hasFalseExpression(id("should-be", expr())))),
      Callback);
}

TEST(RefactoringCallbacksTest, ReplacesIfStmt) {
  std::string Code = "bool a; void f() { if (a) f(); else a = true; }";
  std::string Expected = "bool a; void f() { f(); }";
  ReplaceIfStmtWithItsBody Callback("id", true);
  expectRewritten(Code, Expected,
      id("id", ifStmt(
          hasCondition(implicitCastExpr(hasSourceExpression(
              declRefExpr(to(varDecl(hasName("a"))))))))),
      Callback);
}

TEST(RefactoringCallbacksTest, RemovesEntireIfOnEmptyElse) {
  std::string Code = "void f() { if (false) int i = 0; }";
  std::string Expected = "void f() {  }";
  ReplaceIfStmtWithItsBody Callback("id", false);
  expectRewritten(Code, Expected,
      id("id", ifStmt(hasCondition(cxxBoolLiteral(equals(false))))),
      Callback);
}

} // end namespace ast_matchers
} // end namespace clang
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@d10 1
a13 1
#include "clang/Tooling/RefactoringCallbacks.h"
d22 5
a26 4
void expectRewritten(const std::string &Code, const std::string &Expected,
                     const T &AMatcher, RefactoringCallback &Callback) {
  std::map<std::string, Replacements> FileToReplace;
  ASTMatchRefactorer Finder(FileToReplace);
d34 1
a34 1
  EXPECT_TRUE(tooling::applyAllReplacements(FileToReplace["input.cc"],
d64 2
a65 1
  expectRewritten(Code, Expected, id("id", expr(integerLiteral())), Callback);
d72 4
a75 5
  expectRewritten(
      Code, Expected,
      id("always-false",
         conditionalOperator(hasCondition(cxxBoolLiteral(equals(false))),
                             hasFalseExpression(id("should-be", expr())))),
d83 4
a86 4
  expectRewritten(
      Code, Expected,
      id("id", ifStmt(hasCondition(implicitCastExpr(hasSourceExpression(
                   declRefExpr(to(varDecl(hasName("a"))))))))),
d95 2
a96 2
                  id("id", ifStmt(hasCondition(cxxBoolLiteral(equals(false))))),
                  Callback);
a97 54

TEST(RefactoringCallbacksTest, TemplateJustText) {
  std::string Code = "void f() { int i = 1; }";
  std::string Expected = "void f() { FOO }";
  auto Callback = ReplaceNodeWithTemplate::create("id", "FOO");
  EXPECT_FALSE(Callback.takeError());
  expectRewritten(Code, Expected, id("id", declStmt()), **Callback);
}

TEST(RefactoringCallbacksTest, TemplateSimpleSubst) {
  std::string Code = "void f() { int i = 1; }";
  std::string Expected = "void f() { long x = 1; }";
  auto Callback = ReplaceNodeWithTemplate::create("decl", "long x = ${init}");
  EXPECT_FALSE(Callback.takeError());
  expectRewritten(Code, Expected,
                  id("decl", varDecl(hasInitializer(id("init", expr())))),
                  **Callback);
}

TEST(RefactoringCallbacksTest, TemplateLiteral) {
  std::string Code = "void f() { int i = 1; }";
  std::string Expected = "void f() { string x = \"$-1\"; }";
  auto Callback = ReplaceNodeWithTemplate::create("decl",
                                                  "string x = \"$$-${init}\"");
  EXPECT_FALSE(Callback.takeError());
  expectRewritten(Code, Expected,
                  id("decl", varDecl(hasInitializer(id("init", expr())))),
                  **Callback);
}

static void ExpectStringError(const std::string &Expected,
                              llvm::Error E) {
  std::string Found;
  handleAllErrors(std::move(E), [&](const llvm::StringError &SE) {
      llvm::raw_string_ostream Stream(Found);
      SE.log(Stream);
    });
  EXPECT_EQ(Expected, Found);
}

TEST(RefactoringCallbacksTest, TemplateUnterminated) {
  auto Callback = ReplaceNodeWithTemplate::create("decl",
                                                  "string x = \"$$-${init\"");
  ExpectStringError("Unterminated ${...} in replacement template near ${init\"",
                    Callback.takeError());
}

TEST(RefactoringCallbacksTest, TemplateUnknownDollar) {
  auto Callback = ReplaceNodeWithTemplate::create("decl",
                                                  "string x = \"$<");
  ExpectStringError("Invalid $ in replacement template near $<",
                    Callback.takeError());
}

@

