head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.1
	OPENBSD_6_2:1.1.1.1.0.2
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.4
	OPENBSD_6_1_BASE:1.1.1.1
	LLVM_4_0_0:1.1.1.1
	LLVM_4_0_0_RC1:1.1.1.1
	LLVM_3_9_1:1.1.1.1
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2016.09.03.22.46.56;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.56;	author pascal;	state Exp;
branches;
next	;
commitid	piLU3CHugy63NlaI;


desc
@@


1.1
log
@Initial revision
@
text
@# -*- coding: utf-8 -*-
#                     The LLVM Compiler Infrastructure
#
# This file is distributed under the University of Illinois Open Source
# License. See LICENSE.TXT for details.

import re
import os.path
import subprocess


def load_tests(loader, suite, pattern):
    from . import test_from_cdb
    suite.addTests(loader.loadTestsFromModule(test_from_cdb))
    from . import test_from_cmd
    suite.addTests(loader.loadTestsFromModule(test_from_cmd))
    from . import test_create_cdb
    suite.addTests(loader.loadTestsFromModule(test_create_cdb))
    from . import test_exec_anatomy
    suite.addTests(loader.loadTestsFromModule(test_exec_anatomy))
    return suite


def make_args(target):
    this_dir, _ = os.path.split(__file__)
    path = os.path.normpath(os.path.join(this_dir, '..', 'src'))
    return ['make', 'SRCDIR={}'.format(path), 'OBJDIR={}'.format(target), '-f',
            os.path.join(path, 'build', 'Makefile')]


def silent_call(cmd, *args, **kwargs):
    kwargs.update({'stdout': subprocess.PIPE, 'stderr': subprocess.STDOUT})
    return subprocess.call(cmd, *args, **kwargs)


def silent_check_call(cmd, *args, **kwargs):
    kwargs.update({'stdout': subprocess.PIPE, 'stderr': subprocess.STDOUT})
    return subprocess.check_call(cmd, *args, **kwargs)


def call_and_report(analyzer_cmd, build_cmd):
    child = subprocess.Popen(analyzer_cmd + ['-v'] + build_cmd,
                             universal_newlines=True,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)

    pattern = re.compile('Report directory created: (.+)')
    directory = None
    for line in child.stdout.readlines():
        match = pattern.search(line)
        if match and match.lastindex == 1:
            directory = match.group(1)
            break
    child.stdout.close()
    child.wait()

    return (child.returncode, directory)


def check_call_and_report(analyzer_cmd, build_cmd):
    exit_code, result = call_and_report(analyzer_cmd, build_cmd)
    if exit_code != 0:
        raise subprocess.CalledProcessError(
            exit_code, analyzer_cmd + build_cmd, None)
    else:
        return result


def create_empty_file(filename):
    with open(filename, 'a') as handle:
        pass
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@
