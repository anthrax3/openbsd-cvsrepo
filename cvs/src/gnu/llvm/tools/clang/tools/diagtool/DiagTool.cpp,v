head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.24.08.33.02;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===- DiagTool.cpp - Classes for defining diagtool tools -------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file implements the boilerplate for defining diagtool tools.
//
//===----------------------------------------------------------------------===//

#include "DiagTool.h"
#include "llvm/ADT/SmallString.h"
#include "llvm/ADT/StringMap.h"
#include <vector>

using namespace diagtool;

DiagTool::DiagTool(llvm::StringRef toolCmd,
                   llvm::StringRef toolDesc)
  : cmd(toolCmd), description(toolDesc) {}

DiagTool::~DiagTool() {}

typedef llvm::StringMap<DiagTool *> ToolMap;
static inline ToolMap *getTools(void *v) { return static_cast<ToolMap*>(v); }

DiagTools::DiagTools() : tools(new ToolMap()) {}
DiagTools::~DiagTools() { delete getTools(tools); }

DiagTool *DiagTools::getTool(llvm::StringRef toolCmd) {
  ToolMap::iterator it = getTools(tools)->find(toolCmd);
  return (it == getTools(tools)->end()) ? nullptr : it->getValue();
}

void DiagTools::registerTool(DiagTool *tool) {
  (*getTools(tools))[tool->getName()] = tool;
}

void DiagTools::printCommands(llvm::raw_ostream &out) {
  std::vector<llvm::StringRef> toolNames;
  unsigned maxName = 0;
  for (ToolMap::iterator it = getTools(tools)->begin(),
       ei = getTools(tools)->end(); it != ei; ++it) {
    toolNames.push_back(it->getKey());
    unsigned len = it->getKey().size();
    if (len > maxName)
      maxName = len;    
  }
  std::sort(toolNames.begin(), toolNames.end());

  for (std::vector<llvm::StringRef>::iterator it = toolNames.begin(),
       ei = toolNames.end(); it != ei; ++it) {

    out << "  " << (*it);
    unsigned spaces = (maxName + 3) - (it->size());
    for (unsigned i = 0; i < spaces; ++i)
      out << ' ';
    
    out << getTool(*it)->getDescription() << '\n';    
  }
}

namespace diagtool {
  llvm::ManagedStatic<DiagTools> diagTools;
}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d15 1
@

