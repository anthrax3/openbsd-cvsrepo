head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.4
	OPENBSD_6_2:1.1.1.3.0.6
	OPENBSD_6_2_BASE:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.4
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.44;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.20;	author patrick;	state Exp;
branches;
next	1.1.1.4;
commitid	so2WA7LCP6wbxtYl;

1.1.1.4
date	2017.10.04.20.27.56;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===- LazyCallGraphTest.cpp - Unit tests for the lazy CG analysis --------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "llvm/Analysis/LazyCallGraph.h"
#include "llvm/AsmParser/Parser.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/SourceMgr.h"
#include "gtest/gtest.h"
#include <memory>

using namespace llvm;

namespace {

std::unique_ptr<Module> parseAssembly(const char *Assembly) {
  SMDiagnostic Error;
  std::unique_ptr<Module> M =
      parseAssemblyString(Assembly, Error, getGlobalContext());

  std::string ErrMsg;
  raw_string_ostream OS(ErrMsg);
  Error.print("", OS);

  // A failure here means that the test itself is buggy.
  if (!M)
    report_fatal_error(OS.str().c_str());

  return M;
}

/*
   IR forming a call graph with a diamond of triangle-shaped SCCs:

           d1
          /  \
         d3--d2
        /     \
       b1     c1
     /  \    /  \
    b3--b2  c3--c2
         \  /
          a1
         /  \
        a3--a2

   All call edges go up between SCCs, and clockwise around the SCC.
 */
static const char DiamondOfTriangles[] =
     "define void @@a1() {\n"
     "entry:\n"
     "  call void @@a2()\n"
     "  call void @@b2()\n"
     "  call void @@c3()\n"
     "  ret void\n"
     "}\n"
     "define void @@a2() {\n"
     "entry:\n"
     "  call void @@a3()\n"
     "  ret void\n"
     "}\n"
     "define void @@a3() {\n"
     "entry:\n"
     "  call void @@a1()\n"
     "  ret void\n"
     "}\n"
     "define void @@b1() {\n"
     "entry:\n"
     "  call void @@b2()\n"
     "  call void @@d3()\n"
     "  ret void\n"
     "}\n"
     "define void @@b2() {\n"
     "entry:\n"
     "  call void @@b3()\n"
     "  ret void\n"
     "}\n"
     "define void @@b3() {\n"
     "entry:\n"
     "  call void @@b1()\n"
     "  ret void\n"
     "}\n"
     "define void @@c1() {\n"
     "entry:\n"
     "  call void @@c2()\n"
     "  call void @@d2()\n"
     "  ret void\n"
     "}\n"
     "define void @@c2() {\n"
     "entry:\n"
     "  call void @@c3()\n"
     "  ret void\n"
     "}\n"
     "define void @@c3() {\n"
     "entry:\n"
     "  call void @@c1()\n"
     "  ret void\n"
     "}\n"
     "define void @@d1() {\n"
     "entry:\n"
     "  call void @@d2()\n"
     "  ret void\n"
     "}\n"
     "define void @@d2() {\n"
     "entry:\n"
     "  call void @@d3()\n"
     "  ret void\n"
     "}\n"
     "define void @@d3() {\n"
     "entry:\n"
     "  call void @@d1()\n"
     "  ret void\n"
     "}\n";

TEST(LazyCallGraphTest, BasicGraphFormation) {
  std::unique_ptr<Module> M = parseAssembly(DiamondOfTriangles);
  LazyCallGraph CG(*M);

  // The order of the entry nodes should be stable w.r.t. the source order of
  // the IR, and everything in our module is an entry node, so just directly
  // build variables for each node.
  auto I = CG.begin();
  LazyCallGraph::Node &A1 = *I++;
  EXPECT_EQ("a1", A1.getFunction().getName());
  LazyCallGraph::Node &A2 = *I++;
  EXPECT_EQ("a2", A2.getFunction().getName());
  LazyCallGraph::Node &A3 = *I++;
  EXPECT_EQ("a3", A3.getFunction().getName());
  LazyCallGraph::Node &B1 = *I++;
  EXPECT_EQ("b1", B1.getFunction().getName());
  LazyCallGraph::Node &B2 = *I++;
  EXPECT_EQ("b2", B2.getFunction().getName());
  LazyCallGraph::Node &B3 = *I++;
  EXPECT_EQ("b3", B3.getFunction().getName());
  LazyCallGraph::Node &C1 = *I++;
  EXPECT_EQ("c1", C1.getFunction().getName());
  LazyCallGraph::Node &C2 = *I++;
  EXPECT_EQ("c2", C2.getFunction().getName());
  LazyCallGraph::Node &C3 = *I++;
  EXPECT_EQ("c3", C3.getFunction().getName());
  LazyCallGraph::Node &D1 = *I++;
  EXPECT_EQ("d1", D1.getFunction().getName());
  LazyCallGraph::Node &D2 = *I++;
  EXPECT_EQ("d2", D2.getFunction().getName());
  LazyCallGraph::Node &D3 = *I++;
  EXPECT_EQ("d3", D3.getFunction().getName());
  EXPECT_EQ(CG.end(), I);

  // Build vectors and sort them for the rest of the assertions to make them
  // independent of order.
  std::vector<std::string> Nodes;

  for (LazyCallGraph::Node &N : A1)
    Nodes.push_back(N.getFunction().getName());
  std::sort(Nodes.begin(), Nodes.end());
  EXPECT_EQ("a2", Nodes[0]);
  EXPECT_EQ("b2", Nodes[1]);
  EXPECT_EQ("c3", Nodes[2]);
  Nodes.clear();

  EXPECT_EQ(A2.end(), std::next(A2.begin()));
  EXPECT_EQ("a3", A2.begin()->getFunction().getName());
  EXPECT_EQ(A3.end(), std::next(A3.begin()));
  EXPECT_EQ("a1", A3.begin()->getFunction().getName());

  for (LazyCallGraph::Node &N : B1)
    Nodes.push_back(N.getFunction().getName());
  std::sort(Nodes.begin(), Nodes.end());
  EXPECT_EQ("b2", Nodes[0]);
  EXPECT_EQ("d3", Nodes[1]);
  Nodes.clear();

  EXPECT_EQ(B2.end(), std::next(B2.begin()));
  EXPECT_EQ("b3", B2.begin()->getFunction().getName());
  EXPECT_EQ(B3.end(), std::next(B3.begin()));
  EXPECT_EQ("b1", B3.begin()->getFunction().getName());

  for (LazyCallGraph::Node &N : C1)
    Nodes.push_back(N.getFunction().getName());
  std::sort(Nodes.begin(), Nodes.end());
  EXPECT_EQ("c2", Nodes[0]);
  EXPECT_EQ("d2", Nodes[1]);
  Nodes.clear();

  EXPECT_EQ(C2.end(), std::next(C2.begin()));
  EXPECT_EQ("c3", C2.begin()->getFunction().getName());
  EXPECT_EQ(C3.end(), std::next(C3.begin()));
  EXPECT_EQ("c1", C3.begin()->getFunction().getName());

  EXPECT_EQ(D1.end(), std::next(D1.begin()));
  EXPECT_EQ("d2", D1.begin()->getFunction().getName());
  EXPECT_EQ(D2.end(), std::next(D2.begin()));
  EXPECT_EQ("d3", D2.begin()->getFunction().getName());
  EXPECT_EQ(D3.end(), std::next(D3.begin()));
  EXPECT_EQ("d1", D3.begin()->getFunction().getName());

  // Now lets look at the SCCs.
  auto SCCI = CG.postorder_scc_begin();

  LazyCallGraph::SCC &D = *SCCI++;
  for (LazyCallGraph::Node *N : D)
    Nodes.push_back(N->getFunction().getName());
  std::sort(Nodes.begin(), Nodes.end());
  EXPECT_EQ(3u, Nodes.size());
  EXPECT_EQ("d1", Nodes[0]);
  EXPECT_EQ("d2", Nodes[1]);
  EXPECT_EQ("d3", Nodes[2]);
  Nodes.clear();
  EXPECT_FALSE(D.isParentOf(D));
  EXPECT_FALSE(D.isChildOf(D));
  EXPECT_FALSE(D.isAncestorOf(D));
  EXPECT_FALSE(D.isDescendantOf(D));

  LazyCallGraph::SCC &C = *SCCI++;
  for (LazyCallGraph::Node *N : C)
    Nodes.push_back(N->getFunction().getName());
  std::sort(Nodes.begin(), Nodes.end());
  EXPECT_EQ(3u, Nodes.size());
  EXPECT_EQ("c1", Nodes[0]);
  EXPECT_EQ("c2", Nodes[1]);
  EXPECT_EQ("c3", Nodes[2]);
  Nodes.clear();
  EXPECT_TRUE(C.isParentOf(D));
  EXPECT_FALSE(C.isChildOf(D));
  EXPECT_TRUE(C.isAncestorOf(D));
  EXPECT_FALSE(C.isDescendantOf(D));

  LazyCallGraph::SCC &B = *SCCI++;
  for (LazyCallGraph::Node *N : B)
    Nodes.push_back(N->getFunction().getName());
  std::sort(Nodes.begin(), Nodes.end());
  EXPECT_EQ(3u, Nodes.size());
  EXPECT_EQ("b1", Nodes[0]);
  EXPECT_EQ("b2", Nodes[1]);
  EXPECT_EQ("b3", Nodes[2]);
  Nodes.clear();
  EXPECT_TRUE(B.isParentOf(D));
  EXPECT_FALSE(B.isChildOf(D));
  EXPECT_TRUE(B.isAncestorOf(D));
  EXPECT_FALSE(B.isDescendantOf(D));
  EXPECT_FALSE(B.isAncestorOf(C));
  EXPECT_FALSE(C.isAncestorOf(B));

  LazyCallGraph::SCC &A = *SCCI++;
  for (LazyCallGraph::Node *N : A)
    Nodes.push_back(N->getFunction().getName());
  std::sort(Nodes.begin(), Nodes.end());
  EXPECT_EQ(3u, Nodes.size());
  EXPECT_EQ("a1", Nodes[0]);
  EXPECT_EQ("a2", Nodes[1]);
  EXPECT_EQ("a3", Nodes[2]);
  Nodes.clear();
  EXPECT_TRUE(A.isParentOf(B));
  EXPECT_TRUE(A.isParentOf(C));
  EXPECT_FALSE(A.isParentOf(D));
  EXPECT_TRUE(A.isAncestorOf(B));
  EXPECT_TRUE(A.isAncestorOf(C));
  EXPECT_TRUE(A.isAncestorOf(D));

  EXPECT_EQ(CG.postorder_scc_end(), SCCI);
}

static Function &lookupFunction(Module &M, StringRef Name) {
  for (Function &F : M)
    if (F.getName() == Name)
      return F;
  report_fatal_error("Couldn't find function!");
}

TEST(LazyCallGraphTest, BasicGraphMutation) {
  std::unique_ptr<Module> M = parseAssembly(
      "define void @@a() {\n"
      "entry:\n"
      "  call void @@b()\n"
      "  call void @@c()\n"
      "  ret void\n"
      "}\n"
      "define void @@b() {\n"
      "entry:\n"
      "  ret void\n"
      "}\n"
      "define void @@c() {\n"
      "entry:\n"
      "  ret void\n"
      "}\n");
  LazyCallGraph CG(*M);

  LazyCallGraph::Node &A = CG.get(lookupFunction(*M, "a"));
  LazyCallGraph::Node &B = CG.get(lookupFunction(*M, "b"));
  EXPECT_EQ(2, std::distance(A.begin(), A.end()));
  EXPECT_EQ(0, std::distance(B.begin(), B.end()));

  CG.insertEdge(B, lookupFunction(*M, "c"));
  EXPECT_EQ(1, std::distance(B.begin(), B.end()));
  LazyCallGraph::Node &C = *B.begin();
  EXPECT_EQ(0, std::distance(C.begin(), C.end()));

  CG.insertEdge(C, B.getFunction());
  EXPECT_EQ(1, std::distance(C.begin(), C.end()));
  EXPECT_EQ(&B, &*C.begin());

  CG.insertEdge(C, C.getFunction());
  EXPECT_EQ(2, std::distance(C.begin(), C.end()));
  EXPECT_EQ(&B, &*C.begin());
  EXPECT_EQ(&C, &*std::next(C.begin()));

  CG.removeEdge(C, B.getFunction());
  EXPECT_EQ(1, std::distance(C.begin(), C.end()));
  EXPECT_EQ(&C, &*C.begin());

  CG.removeEdge(C, C.getFunction());
  EXPECT_EQ(0, std::distance(C.begin(), C.end()));

  CG.removeEdge(B, C.getFunction());
  EXPECT_EQ(0, std::distance(B.begin(), B.end()));
}

TEST(LazyCallGraphTest, MultiArmSCC) {
  // Two interlocking cycles. The really useful thing about this SCC is that it
  // will require Tarjan's DFS to backtrack and finish processing all of the
  // children of each node in the SCC.
  std::unique_ptr<Module> M = parseAssembly(
      "define void @@a() {\n"
      "entry:\n"
      "  call void @@b()\n"
      "  call void @@d()\n"
      "  ret void\n"
      "}\n"
      "define void @@b() {\n"
      "entry:\n"
      "  call void @@c()\n"
      "  ret void\n"
      "}\n"
      "define void @@c() {\n"
      "entry:\n"
      "  call void @@a()\n"
      "  ret void\n"
      "}\n"
      "define void @@d() {\n"
      "entry:\n"
      "  call void @@e()\n"
      "  ret void\n"
      "}\n"
      "define void @@e() {\n"
      "entry:\n"
      "  call void @@a()\n"
      "  ret void\n"
      "}\n");
  LazyCallGraph CG(*M);

  // Force the graph to be fully expanded.
  auto SCCI = CG.postorder_scc_begin();
  LazyCallGraph::SCC &SCC = *SCCI++;
  EXPECT_EQ(CG.postorder_scc_end(), SCCI);

  LazyCallGraph::Node &A = *CG.lookup(lookupFunction(*M, "a"));
  LazyCallGraph::Node &B = *CG.lookup(lookupFunction(*M, "b"));
  LazyCallGraph::Node &C = *CG.lookup(lookupFunction(*M, "c"));
  LazyCallGraph::Node &D = *CG.lookup(lookupFunction(*M, "d"));
  LazyCallGraph::Node &E = *CG.lookup(lookupFunction(*M, "e"));
  EXPECT_EQ(&SCC, CG.lookupSCC(A));
  EXPECT_EQ(&SCC, CG.lookupSCC(B));
  EXPECT_EQ(&SCC, CG.lookupSCC(C));
  EXPECT_EQ(&SCC, CG.lookupSCC(D));
  EXPECT_EQ(&SCC, CG.lookupSCC(E));
}

TEST(LazyCallGraphTest, OutgoingSCCEdgeInsertion) {
  std::unique_ptr<Module> M = parseAssembly(
      "define void @@a() {\n"
      "entry:\n"
      "  call void @@b()\n"
      "  call void @@c()\n"
      "  ret void\n"
      "}\n"
      "define void @@b() {\n"
      "entry:\n"
      "  call void @@d()\n"
      "  ret void\n"
      "}\n"
      "define void @@c() {\n"
      "entry:\n"
      "  call void @@d()\n"
      "  ret void\n"
      "}\n"
      "define void @@d() {\n"
      "entry:\n"
      "  ret void\n"
      "}\n");
  LazyCallGraph CG(*M);

  // Force the graph to be fully expanded.
  for (LazyCallGraph::SCC &C : CG.postorder_sccs())
    (void)C;

  LazyCallGraph::Node &A = *CG.lookup(lookupFunction(*M, "a"));
  LazyCallGraph::Node &B = *CG.lookup(lookupFunction(*M, "b"));
  LazyCallGraph::Node &C = *CG.lookup(lookupFunction(*M, "c"));
  LazyCallGraph::Node &D = *CG.lookup(lookupFunction(*M, "d"));
  LazyCallGraph::SCC &AC = *CG.lookupSCC(A);
  LazyCallGraph::SCC &BC = *CG.lookupSCC(B);
  LazyCallGraph::SCC &CC = *CG.lookupSCC(C);
  LazyCallGraph::SCC &DC = *CG.lookupSCC(D);
  EXPECT_TRUE(AC.isAncestorOf(BC));
  EXPECT_TRUE(AC.isAncestorOf(CC));
  EXPECT_TRUE(AC.isAncestorOf(DC));
  EXPECT_TRUE(DC.isDescendantOf(AC));
  EXPECT_TRUE(DC.isDescendantOf(BC));
  EXPECT_TRUE(DC.isDescendantOf(CC));

  EXPECT_EQ(2, std::distance(A.begin(), A.end()));
  AC.insertOutgoingEdge(A, D);
  EXPECT_EQ(3, std::distance(A.begin(), A.end()));
  EXPECT_TRUE(AC.isParentOf(DC));
  EXPECT_EQ(&AC, CG.lookupSCC(A));
  EXPECT_EQ(&BC, CG.lookupSCC(B));
  EXPECT_EQ(&CC, CG.lookupSCC(C));
  EXPECT_EQ(&DC, CG.lookupSCC(D));
}

TEST(LazyCallGraphTest, IncomingSCCEdgeInsertion) {
  // We want to ensure we can add edges even across complex diamond graphs, so
  // we use the diamond of triangles graph defined above. The ascii diagram is
  // repeated here for easy reference.
  //
  //         d1       |
  //        /  \      |
  //       d3--d2     |
  //      /     \     |
  //     b1     c1    |
  //   /  \    /  \   |
  //  b3--b2  c3--c2  |
  //       \  /       |
  //        a1        |
  //       /  \       |
  //      a3--a2      |
  //
  std::unique_ptr<Module> M = parseAssembly(DiamondOfTriangles);
  LazyCallGraph CG(*M);

  // Force the graph to be fully expanded.
  for (LazyCallGraph::SCC &C : CG.postorder_sccs())
    (void)C;

  LazyCallGraph::Node &A1 = *CG.lookup(lookupFunction(*M, "a1"));
  LazyCallGraph::Node &A2 = *CG.lookup(lookupFunction(*M, "a2"));
  LazyCallGraph::Node &A3 = *CG.lookup(lookupFunction(*M, "a3"));
  LazyCallGraph::Node &B1 = *CG.lookup(lookupFunction(*M, "b1"));
  LazyCallGraph::Node &B2 = *CG.lookup(lookupFunction(*M, "b2"));
  LazyCallGraph::Node &B3 = *CG.lookup(lookupFunction(*M, "b3"));
  LazyCallGraph::Node &C1 = *CG.lookup(lookupFunction(*M, "c1"));
  LazyCallGraph::Node &C2 = *CG.lookup(lookupFunction(*M, "c2"));
  LazyCallGraph::Node &C3 = *CG.lookup(lookupFunction(*M, "c3"));
  LazyCallGraph::Node &D1 = *CG.lookup(lookupFunction(*M, "d1"));
  LazyCallGraph::Node &D2 = *CG.lookup(lookupFunction(*M, "d2"));
  LazyCallGraph::Node &D3 = *CG.lookup(lookupFunction(*M, "d3"));
  LazyCallGraph::SCC &AC = *CG.lookupSCC(A1);
  LazyCallGraph::SCC &BC = *CG.lookupSCC(B1);
  LazyCallGraph::SCC &CC = *CG.lookupSCC(C1);
  LazyCallGraph::SCC &DC = *CG.lookupSCC(D1);
  ASSERT_EQ(&AC, CG.lookupSCC(A2));
  ASSERT_EQ(&AC, CG.lookupSCC(A3));
  ASSERT_EQ(&BC, CG.lookupSCC(B2));
  ASSERT_EQ(&BC, CG.lookupSCC(B3));
  ASSERT_EQ(&CC, CG.lookupSCC(C2));
  ASSERT_EQ(&CC, CG.lookupSCC(C3));
  ASSERT_EQ(&DC, CG.lookupSCC(D2));
  ASSERT_EQ(&DC, CG.lookupSCC(D3));
  ASSERT_EQ(1, std::distance(D2.begin(), D2.end()));

  // Add an edge to make the graph:
  //
  //         d1         |
  //        /  \        |
  //       d3--d2---.   |
  //      /     \    |  |
  //     b1     c1   |  |
  //   /  \    /  \ /   |
  //  b3--b2  c3--c2    |
  //       \  /         |
  //        a1          |
  //       /  \         |
  //      a3--a2        |
  CC.insertIncomingEdge(D2, C2);
  // Make sure we connected the nodes.
  EXPECT_EQ(2, std::distance(D2.begin(), D2.end()));

  // Make sure we have the correct nodes in the SCC sets.
  EXPECT_EQ(&AC, CG.lookupSCC(A1));
  EXPECT_EQ(&AC, CG.lookupSCC(A2));
  EXPECT_EQ(&AC, CG.lookupSCC(A3));
  EXPECT_EQ(&BC, CG.lookupSCC(B1));
  EXPECT_EQ(&BC, CG.lookupSCC(B2));
  EXPECT_EQ(&BC, CG.lookupSCC(B3));
  EXPECT_EQ(&CC, CG.lookupSCC(C1));
  EXPECT_EQ(&CC, CG.lookupSCC(C2));
  EXPECT_EQ(&CC, CG.lookupSCC(C3));
  EXPECT_EQ(&CC, CG.lookupSCC(D1));
  EXPECT_EQ(&CC, CG.lookupSCC(D2));
  EXPECT_EQ(&CC, CG.lookupSCC(D3));

  // And that ancestry tests have been updated.
  EXPECT_TRUE(AC.isParentOf(BC));
  EXPECT_TRUE(AC.isParentOf(CC));
  EXPECT_FALSE(AC.isAncestorOf(DC));
  EXPECT_FALSE(BC.isAncestorOf(DC));
  EXPECT_FALSE(CC.isAncestorOf(DC));
}

TEST(LazyCallGraphTest, IncomingSCCEdgeInsertionMidTraversal) {
  // This is the same fundamental test as the previous, but we perform it
  // having only partially walked the SCCs of the graph.
  std::unique_ptr<Module> M = parseAssembly(DiamondOfTriangles);
  LazyCallGraph CG(*M);

  // Walk the SCCs until we find the one containing 'c1'.
  auto SCCI = CG.postorder_scc_begin(), SCCE = CG.postorder_scc_end();
  ASSERT_NE(SCCI, SCCE);
  LazyCallGraph::SCC &DC = *SCCI;
  ASSERT_NE(&DC, nullptr);
  ++SCCI;
  ASSERT_NE(SCCI, SCCE);
  LazyCallGraph::SCC &CC = *SCCI;
  ASSERT_NE(&CC, nullptr);

  ASSERT_EQ(nullptr, CG.lookup(lookupFunction(*M, "a1")));
  ASSERT_EQ(nullptr, CG.lookup(lookupFunction(*M, "a2")));
  ASSERT_EQ(nullptr, CG.lookup(lookupFunction(*M, "a3")));
  ASSERT_EQ(nullptr, CG.lookup(lookupFunction(*M, "b1")));
  ASSERT_EQ(nullptr, CG.lookup(lookupFunction(*M, "b2")));
  ASSERT_EQ(nullptr, CG.lookup(lookupFunction(*M, "b3")));
  LazyCallGraph::Node &C1 = *CG.lookup(lookupFunction(*M, "c1"));
  LazyCallGraph::Node &C2 = *CG.lookup(lookupFunction(*M, "c2"));
  LazyCallGraph::Node &C3 = *CG.lookup(lookupFunction(*M, "c3"));
  LazyCallGraph::Node &D1 = *CG.lookup(lookupFunction(*M, "d1"));
  LazyCallGraph::Node &D2 = *CG.lookup(lookupFunction(*M, "d2"));
  LazyCallGraph::Node &D3 = *CG.lookup(lookupFunction(*M, "d3"));
  ASSERT_EQ(&CC, CG.lookupSCC(C1));
  ASSERT_EQ(&CC, CG.lookupSCC(C2));
  ASSERT_EQ(&CC, CG.lookupSCC(C3));
  ASSERT_EQ(&DC, CG.lookupSCC(D1));
  ASSERT_EQ(&DC, CG.lookupSCC(D2));
  ASSERT_EQ(&DC, CG.lookupSCC(D3));
  ASSERT_EQ(1, std::distance(D2.begin(), D2.end()));

  CC.insertIncomingEdge(D2, C2);
  EXPECT_EQ(2, std::distance(D2.begin(), D2.end()));

  // Make sure we have the correct nodes in the SCC sets.
  EXPECT_EQ(&CC, CG.lookupSCC(C1));
  EXPECT_EQ(&CC, CG.lookupSCC(C2));
  EXPECT_EQ(&CC, CG.lookupSCC(C3));
  EXPECT_EQ(&CC, CG.lookupSCC(D1));
  EXPECT_EQ(&CC, CG.lookupSCC(D2));
  EXPECT_EQ(&CC, CG.lookupSCC(D3));

  // Check that we can form the last two SCCs now in a coherent way.
  ++SCCI;
  EXPECT_NE(SCCI, SCCE);
  LazyCallGraph::SCC &BC = *SCCI;
  EXPECT_NE(&BC, nullptr);
  EXPECT_EQ(&BC, CG.lookupSCC(*CG.lookup(lookupFunction(*M, "b1"))));
  EXPECT_EQ(&BC, CG.lookupSCC(*CG.lookup(lookupFunction(*M, "b2"))));
  EXPECT_EQ(&BC, CG.lookupSCC(*CG.lookup(lookupFunction(*M, "b3"))));
  ++SCCI;
  EXPECT_NE(SCCI, SCCE);
  LazyCallGraph::SCC &AC = *SCCI;
  EXPECT_NE(&AC, nullptr);
  EXPECT_EQ(&AC, CG.lookupSCC(*CG.lookup(lookupFunction(*M, "a1"))));
  EXPECT_EQ(&AC, CG.lookupSCC(*CG.lookup(lookupFunction(*M, "a2"))));
  EXPECT_EQ(&AC, CG.lookupSCC(*CG.lookup(lookupFunction(*M, "a3"))));
  ++SCCI;
  EXPECT_EQ(SCCI, SCCE);
}

TEST(LazyCallGraphTest, InterSCCEdgeRemoval) {
  std::unique_ptr<Module> M = parseAssembly(
      "define void @@a() {\n"
      "entry:\n"
      "  call void @@b()\n"
      "  ret void\n"
      "}\n"
      "define void @@b() {\n"
      "entry:\n"
      "  ret void\n"
      "}\n");
  LazyCallGraph CG(*M);

  // Force the graph to be fully expanded.
  for (LazyCallGraph::SCC &C : CG.postorder_sccs())
    (void)C;

  LazyCallGraph::Node &A = *CG.lookup(lookupFunction(*M, "a"));
  LazyCallGraph::Node &B = *CG.lookup(lookupFunction(*M, "b"));
  LazyCallGraph::SCC &AC = *CG.lookupSCC(A);
  LazyCallGraph::SCC &BC = *CG.lookupSCC(B);

  EXPECT_EQ("b", A.begin()->getFunction().getName());
  EXPECT_EQ(B.end(), B.begin());
  EXPECT_EQ(&AC, &*BC.parent_begin());

  AC.removeInterSCCEdge(A, B);

  EXPECT_EQ(A.end(), A.begin());
  EXPECT_EQ(B.end(), B.begin());
  EXPECT_EQ(BC.parent_end(), BC.parent_begin());
}

TEST(LazyCallGraphTest, IntraSCCEdgeInsertion) {
  std::unique_ptr<Module> M1 = parseAssembly(
      "define void @@a() {\n"
      "entry:\n"
      "  call void @@b()\n"
      "  ret void\n"
      "}\n"
      "define void @@b() {\n"
      "entry:\n"
      "  call void @@c()\n"
      "  ret void\n"
      "}\n"
      "define void @@c() {\n"
      "entry:\n"
      "  call void @@a()\n"
      "  ret void\n"
      "}\n");
  LazyCallGraph CG1(*M1);

  // Force the graph to be fully expanded.
  auto SCCI = CG1.postorder_scc_begin();
  LazyCallGraph::SCC &SCC = *SCCI++;
  EXPECT_EQ(CG1.postorder_scc_end(), SCCI);

  LazyCallGraph::Node &A = *CG1.lookup(lookupFunction(*M1, "a"));
  LazyCallGraph::Node &B = *CG1.lookup(lookupFunction(*M1, "b"));
  LazyCallGraph::Node &C = *CG1.lookup(lookupFunction(*M1, "c"));
  EXPECT_EQ(&SCC, CG1.lookupSCC(A));
  EXPECT_EQ(&SCC, CG1.lookupSCC(B));
  EXPECT_EQ(&SCC, CG1.lookupSCC(C));

  // Insert an edge from 'a' to 'c'. Nothing changes about the SCCs.
  SCC.insertIntraSCCEdge(A, C);
  EXPECT_EQ(2, std::distance(A.begin(), A.end()));
  EXPECT_EQ(&SCC, CG1.lookupSCC(A));
  EXPECT_EQ(&SCC, CG1.lookupSCC(B));
  EXPECT_EQ(&SCC, CG1.lookupSCC(C));

  // Insert a self edge from 'a' back to 'a'.
  SCC.insertIntraSCCEdge(A, A);
  EXPECT_EQ(3, std::distance(A.begin(), A.end()));
  EXPECT_EQ(&SCC, CG1.lookupSCC(A));
  EXPECT_EQ(&SCC, CG1.lookupSCC(B));
  EXPECT_EQ(&SCC, CG1.lookupSCC(C));
}

TEST(LazyCallGraphTest, IntraSCCEdgeRemoval) {
  // A nice fully connected (including self-edges) SCC.
  std::unique_ptr<Module> M1 = parseAssembly(
      "define void @@a() {\n"
      "entry:\n"
      "  call void @@a()\n"
      "  call void @@b()\n"
      "  call void @@c()\n"
      "  ret void\n"
      "}\n"
      "define void @@b() {\n"
      "entry:\n"
      "  call void @@a()\n"
      "  call void @@b()\n"
      "  call void @@c()\n"
      "  ret void\n"
      "}\n"
      "define void @@c() {\n"
      "entry:\n"
      "  call void @@a()\n"
      "  call void @@b()\n"
      "  call void @@c()\n"
      "  ret void\n"
      "}\n");
  LazyCallGraph CG1(*M1);

  // Force the graph to be fully expanded.
  auto SCCI = CG1.postorder_scc_begin();
  LazyCallGraph::SCC &SCC = *SCCI++;
  EXPECT_EQ(CG1.postorder_scc_end(), SCCI);

  LazyCallGraph::Node &A = *CG1.lookup(lookupFunction(*M1, "a"));
  LazyCallGraph::Node &B = *CG1.lookup(lookupFunction(*M1, "b"));
  LazyCallGraph::Node &C = *CG1.lookup(lookupFunction(*M1, "c"));
  EXPECT_EQ(&SCC, CG1.lookupSCC(A));
  EXPECT_EQ(&SCC, CG1.lookupSCC(B));
  EXPECT_EQ(&SCC, CG1.lookupSCC(C));

  // Remove the edge from b -> a, which should leave the 3 functions still in
  // a single connected component because of a -> b -> c -> a.
  SmallVector<LazyCallGraph::SCC *, 1> NewSCCs = SCC.removeIntraSCCEdge(B, A);
  EXPECT_EQ(0u, NewSCCs.size());
  EXPECT_EQ(&SCC, CG1.lookupSCC(A));
  EXPECT_EQ(&SCC, CG1.lookupSCC(B));
  EXPECT_EQ(&SCC, CG1.lookupSCC(C));

  // Remove the edge from c -> a, which should leave 'a' in the original SCC
  // and form a new SCC for 'b' and 'c'.
  NewSCCs = SCC.removeIntraSCCEdge(C, A);
  EXPECT_EQ(1u, NewSCCs.size());
  EXPECT_EQ(&SCC, CG1.lookupSCC(A));
  EXPECT_EQ(1, std::distance(SCC.begin(), SCC.end()));
  LazyCallGraph::SCC *SCC2 = CG1.lookupSCC(B);
  EXPECT_EQ(SCC2, CG1.lookupSCC(C));
  EXPECT_EQ(SCC2, NewSCCs[0]);
}

}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d24 1
a24 2
std::unique_ptr<Module> parseAssembly(LLVMContext &Context,
                                      const char *Assembly) {
d26 2
a27 1
  std::unique_ptr<Module> M = parseAssemblyString(Assembly, Error, Context);
d124 1
a124 2
  LLVMContext Context;
  std::unique_ptr<Module> M = parseAssembly(Context, DiamondOfTriangles);
d131 1
a131 1
  LazyCallGraph::Node &A1 = (I++)->getNode(CG);
d133 1
a133 1
  LazyCallGraph::Node &A2 = (I++)->getNode(CG);
d135 1
a135 1
  LazyCallGraph::Node &A3 = (I++)->getNode(CG);
d137 1
a137 1
  LazyCallGraph::Node &B1 = (I++)->getNode(CG);
d139 1
a139 1
  LazyCallGraph::Node &B2 = (I++)->getNode(CG);
d141 1
a141 1
  LazyCallGraph::Node &B3 = (I++)->getNode(CG);
d143 1
a143 1
  LazyCallGraph::Node &C1 = (I++)->getNode(CG);
d145 1
a145 1
  LazyCallGraph::Node &C2 = (I++)->getNode(CG);
d147 1
a147 1
  LazyCallGraph::Node &C3 = (I++)->getNode(CG);
d149 1
a149 1
  LazyCallGraph::Node &D1 = (I++)->getNode(CG);
d151 1
a151 1
  LazyCallGraph::Node &D2 = (I++)->getNode(CG);
d153 1
a153 1
  LazyCallGraph::Node &D3 = (I++)->getNode(CG);
d161 2
a162 2
  for (LazyCallGraph::Edge &E : A1)
    Nodes.push_back(E.getFunction().getName());
d174 2
a175 2
  for (LazyCallGraph::Edge &E : B1)
    Nodes.push_back(E.getFunction().getName());
d186 2
a187 2
  for (LazyCallGraph::Edge &E : C1)
    Nodes.push_back(E.getFunction().getName());
d205 2
a206 2
  // Now lets look at the RefSCCs and SCCs.
  auto J = CG.postorder_ref_scc_begin();
d208 3
a210 4
  LazyCallGraph::RefSCC &D = *J++;
  ASSERT_EQ(1, D.size());
  for (LazyCallGraph::Node &N : *D.begin())
    Nodes.push_back(N.getFunction().getName());
d222 3
a224 4
  LazyCallGraph::RefSCC &C = *J++;
  ASSERT_EQ(1, C.size());
  for (LazyCallGraph::Node &N : *C.begin())
    Nodes.push_back(N.getFunction().getName());
d236 3
a238 4
  LazyCallGraph::RefSCC &B = *J++;
  ASSERT_EQ(1, B.size());
  for (LazyCallGraph::Node &N : *B.begin())
    Nodes.push_back(N.getFunction().getName());
d252 3
a254 4
  LazyCallGraph::RefSCC &A = *J++;
  ASSERT_EQ(1, A.size());
  for (LazyCallGraph::Node &N : *A.begin())
    Nodes.push_back(N.getFunction().getName());
d268 1
a268 1
  EXPECT_EQ(CG.postorder_ref_scc_end(), J);
d279 15
a293 15
  LLVMContext Context;
  std::unique_ptr<Module> M = parseAssembly(Context, "define void @@a() {\n"
                                                     "entry:\n"
                                                     "  call void @@b()\n"
                                                     "  call void @@c()\n"
                                                     "  ret void\n"
                                                     "}\n"
                                                     "define void @@b() {\n"
                                                     "entry:\n"
                                                     "  ret void\n"
                                                     "}\n"
                                                     "define void @@c() {\n"
                                                     "entry:\n"
                                                     "  ret void\n"
                                                     "}\n");
d301 1
a301 1
  CG.insertEdge(B, lookupFunction(*M, "c"), LazyCallGraph::Edge::Call);
d303 1
a303 1
  LazyCallGraph::Node &C = B.begin()->getNode(CG);
d306 1
a306 1
  CG.insertEdge(C, B.getFunction(), LazyCallGraph::Edge::Call);
d308 1
a308 1
  EXPECT_EQ(&B, C.begin()->getNode());
d310 1
a310 1
  CG.insertEdge(C, C.getFunction(), LazyCallGraph::Edge::Call);
d312 2
a313 2
  EXPECT_EQ(&B, C.begin()->getNode());
  EXPECT_EQ(&C, std::next(C.begin())->getNode());
d317 1
a317 1
  EXPECT_EQ(&C, C.begin()->getNode());
a325 64
TEST(LazyCallGraphTest, InnerSCCFormation) {
  LLVMContext Context;
  std::unique_ptr<Module> M = parseAssembly(Context, DiamondOfTriangles);
  LazyCallGraph CG(*M);

  // Now mutate the graph to connect every node into a single RefSCC to ensure
  // that our inner SCC formation handles the rest.
  CG.insertEdge(lookupFunction(*M, "d1"), lookupFunction(*M, "a1"),
                LazyCallGraph::Edge::Ref);

  // Build vectors and sort them for the rest of the assertions to make them
  // independent of order.
  std::vector<std::string> Nodes;

  // We should build a single RefSCC for the entire graph.
  auto I = CG.postorder_ref_scc_begin();
  LazyCallGraph::RefSCC &RC = *I++;
  EXPECT_EQ(CG.postorder_ref_scc_end(), I);

  // Now walk the four SCCs which should be in post-order.
  auto J = RC.begin();
  LazyCallGraph::SCC &D = *J++;
  for (LazyCallGraph::Node &N : D)
    Nodes.push_back(N.getFunction().getName());
  std::sort(Nodes.begin(), Nodes.end());
  EXPECT_EQ(3u, Nodes.size());
  EXPECT_EQ("d1", Nodes[0]);
  EXPECT_EQ("d2", Nodes[1]);
  EXPECT_EQ("d3", Nodes[2]);
  Nodes.clear();

  LazyCallGraph::SCC &B = *J++;
  for (LazyCallGraph::Node &N : B)
    Nodes.push_back(N.getFunction().getName());
  std::sort(Nodes.begin(), Nodes.end());
  EXPECT_EQ(3u, Nodes.size());
  EXPECT_EQ("b1", Nodes[0]);
  EXPECT_EQ("b2", Nodes[1]);
  EXPECT_EQ("b3", Nodes[2]);
  Nodes.clear();

  LazyCallGraph::SCC &C = *J++;
  for (LazyCallGraph::Node &N : C)
    Nodes.push_back(N.getFunction().getName());
  std::sort(Nodes.begin(), Nodes.end());
  EXPECT_EQ(3u, Nodes.size());
  EXPECT_EQ("c1", Nodes[0]);
  EXPECT_EQ("c2", Nodes[1]);
  EXPECT_EQ("c3", Nodes[2]);
  Nodes.clear();

  LazyCallGraph::SCC &A = *J++;
  for (LazyCallGraph::Node &N : A)
    Nodes.push_back(N.getFunction().getName());
  std::sort(Nodes.begin(), Nodes.end());
  EXPECT_EQ(3u, Nodes.size());
  EXPECT_EQ("a1", Nodes[0]);
  EXPECT_EQ("a2", Nodes[1]);
  EXPECT_EQ("a3", Nodes[2]);
  Nodes.clear();

  EXPECT_EQ(RC.end(), J);
}

a326 1
  LLVMContext Context;
d329 28
a356 28
  // children of each node in the SCC. Since this involves call edges, both
  // Tarjan implementations will have to successfully navigate the structure.
  std::unique_ptr<Module> M = parseAssembly(Context, "define void @@f1() {\n"
                                                     "entry:\n"
                                                     "  call void @@f2()\n"
                                                     "  call void @@f4()\n"
                                                     "  ret void\n"
                                                     "}\n"
                                                     "define void @@f2() {\n"
                                                     "entry:\n"
                                                     "  call void @@f3()\n"
                                                     "  ret void\n"
                                                     "}\n"
                                                     "define void @@f3() {\n"
                                                     "entry:\n"
                                                     "  call void @@f1()\n"
                                                     "  ret void\n"
                                                     "}\n"
                                                     "define void @@f4() {\n"
                                                     "entry:\n"
                                                     "  call void @@f5()\n"
                                                     "  ret void\n"
                                                     "}\n"
                                                     "define void @@f5() {\n"
                                                     "entry:\n"
                                                     "  call void @@f1()\n"
                                                     "  ret void\n"
                                                     "}\n");
d360 14
a373 23
  auto I = CG.postorder_ref_scc_begin();
  LazyCallGraph::RefSCC &RC = *I++;
  EXPECT_EQ(CG.postorder_ref_scc_end(), I);

  LazyCallGraph::Node &N1 = *CG.lookup(lookupFunction(*M, "f1"));
  LazyCallGraph::Node &N2 = *CG.lookup(lookupFunction(*M, "f2"));
  LazyCallGraph::Node &N3 = *CG.lookup(lookupFunction(*M, "f3"));
  LazyCallGraph::Node &N4 = *CG.lookup(lookupFunction(*M, "f4"));
  LazyCallGraph::Node &N5 = *CG.lookup(lookupFunction(*M, "f4"));
  EXPECT_EQ(&RC, CG.lookupRefSCC(N1));
  EXPECT_EQ(&RC, CG.lookupRefSCC(N2));
  EXPECT_EQ(&RC, CG.lookupRefSCC(N3));
  EXPECT_EQ(&RC, CG.lookupRefSCC(N4));
  EXPECT_EQ(&RC, CG.lookupRefSCC(N5));

  ASSERT_EQ(1, RC.size());

  LazyCallGraph::SCC &C = *RC.begin();
  EXPECT_EQ(&C, CG.lookupSCC(N1));
  EXPECT_EQ(&C, CG.lookupSCC(N2));
  EXPECT_EQ(&C, CG.lookupSCC(N3));
  EXPECT_EQ(&C, CG.lookupSCC(N4));
  EXPECT_EQ(&C, CG.lookupSCC(N5));
d376 22
a397 22
TEST(LazyCallGraphTest, OutgoingEdgeMutation) {
  LLVMContext Context;
  std::unique_ptr<Module> M = parseAssembly(Context, "define void @@a() {\n"
                                                     "entry:\n"
                                                     "  call void @@b()\n"
                                                     "  call void @@c()\n"
                                                     "  ret void\n"
                                                     "}\n"
                                                     "define void @@b() {\n"
                                                     "entry:\n"
                                                     "  call void @@d()\n"
                                                     "  ret void\n"
                                                     "}\n"
                                                     "define void @@c() {\n"
                                                     "entry:\n"
                                                     "  call void @@d()\n"
                                                     "  ret void\n"
                                                     "}\n"
                                                     "define void @@d() {\n"
                                                     "entry:\n"
                                                     "  ret void\n"
                                                     "}\n");
d401 2
a402 2
  for (LazyCallGraph::RefSCC &RC : CG.postorder_ref_sccs())
    (void)RC;
d412 6
a417 12
  LazyCallGraph::RefSCC &ARC = *CG.lookupRefSCC(A);
  LazyCallGraph::RefSCC &BRC = *CG.lookupRefSCC(B);
  LazyCallGraph::RefSCC &CRC = *CG.lookupRefSCC(C);
  LazyCallGraph::RefSCC &DRC = *CG.lookupRefSCC(D);
  EXPECT_TRUE(ARC.isParentOf(BRC));
  EXPECT_TRUE(ARC.isParentOf(CRC));
  EXPECT_FALSE(ARC.isParentOf(DRC));
  EXPECT_TRUE(ARC.isAncestorOf(DRC));
  EXPECT_FALSE(DRC.isChildOf(ARC));
  EXPECT_TRUE(DRC.isDescendantOf(ARC));
  EXPECT_TRUE(DRC.isChildOf(BRC));
  EXPECT_TRUE(DRC.isChildOf(CRC));
d420 1
a420 1
  ARC.insertOutgoingEdge(A, D, LazyCallGraph::Edge::Call);
d422 1
a422 11
  const LazyCallGraph::Edge &NewE = A[D];
  EXPECT_TRUE(NewE);
  EXPECT_TRUE(NewE.isCall());
  EXPECT_EQ(&D, NewE.getNode());

  // Only the parent and child tests sholud have changed. The rest of the graph
  // remains the same.
  EXPECT_TRUE(ARC.isParentOf(DRC));
  EXPECT_TRUE(ARC.isAncestorOf(DRC));
  EXPECT_TRUE(DRC.isChildOf(ARC));
  EXPECT_TRUE(DRC.isDescendantOf(ARC));
a426 55
  EXPECT_EQ(&ARC, CG.lookupRefSCC(A));
  EXPECT_EQ(&BRC, CG.lookupRefSCC(B));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(C));
  EXPECT_EQ(&DRC, CG.lookupRefSCC(D));

  ARC.switchOutgoingEdgeToRef(A, D);
  EXPECT_FALSE(NewE.isCall());

  // Verify the graph remains the same.
  EXPECT_TRUE(ARC.isParentOf(DRC));
  EXPECT_TRUE(ARC.isAncestorOf(DRC));
  EXPECT_TRUE(DRC.isChildOf(ARC));
  EXPECT_TRUE(DRC.isDescendantOf(ARC));
  EXPECT_EQ(&AC, CG.lookupSCC(A));
  EXPECT_EQ(&BC, CG.lookupSCC(B));
  EXPECT_EQ(&CC, CG.lookupSCC(C));
  EXPECT_EQ(&DC, CG.lookupSCC(D));
  EXPECT_EQ(&ARC, CG.lookupRefSCC(A));
  EXPECT_EQ(&BRC, CG.lookupRefSCC(B));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(C));
  EXPECT_EQ(&DRC, CG.lookupRefSCC(D));

  ARC.switchOutgoingEdgeToCall(A, D);
  EXPECT_TRUE(NewE.isCall());

  // Verify the graph remains the same.
  EXPECT_TRUE(ARC.isParentOf(DRC));
  EXPECT_TRUE(ARC.isAncestorOf(DRC));
  EXPECT_TRUE(DRC.isChildOf(ARC));
  EXPECT_TRUE(DRC.isDescendantOf(ARC));
  EXPECT_EQ(&AC, CG.lookupSCC(A));
  EXPECT_EQ(&BC, CG.lookupSCC(B));
  EXPECT_EQ(&CC, CG.lookupSCC(C));
  EXPECT_EQ(&DC, CG.lookupSCC(D));
  EXPECT_EQ(&ARC, CG.lookupRefSCC(A));
  EXPECT_EQ(&BRC, CG.lookupRefSCC(B));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(C));
  EXPECT_EQ(&DRC, CG.lookupRefSCC(D));

  ARC.removeOutgoingEdge(A, D);
  EXPECT_EQ(2, std::distance(A.begin(), A.end()));

  // Now the parent and child tests fail again but the rest remains the same.
  EXPECT_FALSE(ARC.isParentOf(DRC));
  EXPECT_TRUE(ARC.isAncestorOf(DRC));
  EXPECT_FALSE(DRC.isChildOf(ARC));
  EXPECT_TRUE(DRC.isDescendantOf(ARC));
  EXPECT_EQ(&AC, CG.lookupSCC(A));
  EXPECT_EQ(&BC, CG.lookupSCC(B));
  EXPECT_EQ(&CC, CG.lookupSCC(C));
  EXPECT_EQ(&DC, CG.lookupSCC(D));
  EXPECT_EQ(&ARC, CG.lookupRefSCC(A));
  EXPECT_EQ(&BRC, CG.lookupRefSCC(B));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(C));
  EXPECT_EQ(&DRC, CG.lookupRefSCC(D));
d429 1
a429 2
TEST(LazyCallGraphTest, IncomingEdgeInsertion) {
  LLVMContext Context;
d446 1
a446 1
  std::unique_ptr<Module> M = parseAssembly(Context, DiamondOfTriangles);
d450 2
a451 2
  for (LazyCallGraph::RefSCC &RC : CG.postorder_ref_sccs())
    (void)RC;
d465 12
a476 12
  LazyCallGraph::RefSCC &ARC = *CG.lookupRefSCC(A1);
  LazyCallGraph::RefSCC &BRC = *CG.lookupRefSCC(B1);
  LazyCallGraph::RefSCC &CRC = *CG.lookupRefSCC(C1);
  LazyCallGraph::RefSCC &DRC = *CG.lookupRefSCC(D1);
  ASSERT_EQ(&ARC, CG.lookupRefSCC(A2));
  ASSERT_EQ(&ARC, CG.lookupRefSCC(A3));
  ASSERT_EQ(&BRC, CG.lookupRefSCC(B2));
  ASSERT_EQ(&BRC, CG.lookupRefSCC(B3));
  ASSERT_EQ(&CRC, CG.lookupRefSCC(C2));
  ASSERT_EQ(&CRC, CG.lookupRefSCC(C3));
  ASSERT_EQ(&DRC, CG.lookupRefSCC(D2));
  ASSERT_EQ(&DRC, CG.lookupRefSCC(D3));
d492 1
a492 1
  auto MergedRCs = CRC.insertIncomingRefEdge(D2, C2);
d494 1
a494 8
  for (LazyCallGraph::Edge E : D2) {
    if (E.getNode() == &D3)
      continue;
    EXPECT_EQ(&C2, E.getNode());
  }
  // And marked the D ref-SCC as no longer valid.
  EXPECT_EQ(1u, MergedRCs.size());
  EXPECT_EQ(&DRC, MergedRCs[0]);
d497 12
a508 12
  EXPECT_EQ(&ARC, CG.lookupRefSCC(A1));
  EXPECT_EQ(&ARC, CG.lookupRefSCC(A2));
  EXPECT_EQ(&ARC, CG.lookupRefSCC(A3));
  EXPECT_EQ(&BRC, CG.lookupRefSCC(B1));
  EXPECT_EQ(&BRC, CG.lookupRefSCC(B2));
  EXPECT_EQ(&BRC, CG.lookupRefSCC(B3));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(C1));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(C2));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(C3));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(D1));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(D2));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(D3));
d511 5
a515 2
  EXPECT_TRUE(ARC.isParentOf(CRC));
  EXPECT_TRUE(BRC.isParentOf(CRC));
d518 1
a518 2
TEST(LazyCallGraphTest, IncomingEdgeInsertionMidTraversal) {
  LLVMContext Context;
d520 2
a521 2
  // having only partially walked the RefSCCs of the graph.
  std::unique_ptr<Module> M = parseAssembly(Context, DiamondOfTriangles);
d524 9
a532 9
  // Walk the RefSCCs until we find the one containing 'c1'.
  auto I = CG.postorder_ref_scc_begin(), E = CG.postorder_ref_scc_end();
  ASSERT_NE(I, E);
  LazyCallGraph::RefSCC &DRC = *I;
  ASSERT_NE(&DRC, nullptr);
  ++I;
  ASSERT_NE(I, E);
  LazyCallGraph::RefSCC &CRC = *I;
  ASSERT_NE(&CRC, nullptr);
d546 6
a551 6
  ASSERT_EQ(&CRC, CG.lookupRefSCC(C1));
  ASSERT_EQ(&CRC, CG.lookupRefSCC(C2));
  ASSERT_EQ(&CRC, CG.lookupRefSCC(C3));
  ASSERT_EQ(&DRC, CG.lookupRefSCC(D1));
  ASSERT_EQ(&DRC, CG.lookupRefSCC(D2));
  ASSERT_EQ(&DRC, CG.lookupRefSCC(D3));
d554 28
a581 38
  auto MergedRCs = CRC.insertIncomingRefEdge(D2, C2);
  // Make sure we connected the nodes.
  for (LazyCallGraph::Edge E : D2) {
    if (E.getNode() == &D3)
      continue;
    EXPECT_EQ(&C2, E.getNode());
  }
  // And marked the D ref-SCC as no longer valid.
  EXPECT_EQ(1u, MergedRCs.size());
  EXPECT_EQ(&DRC, MergedRCs[0]);

  // Make sure we have the correct nodes in the RefSCCs.
  EXPECT_EQ(&CRC, CG.lookupRefSCC(C1));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(C2));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(C3));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(D1));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(D2));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(D3));

  // Check that we can form the last two RefSCCs now in a coherent way.
  ++I;
  EXPECT_NE(I, E);
  LazyCallGraph::RefSCC &BRC = *I;
  EXPECT_NE(&BRC, nullptr);
  EXPECT_EQ(&BRC, CG.lookupRefSCC(*CG.lookup(lookupFunction(*M, "b1"))));
  EXPECT_EQ(&BRC, CG.lookupRefSCC(*CG.lookup(lookupFunction(*M, "b2"))));
  EXPECT_EQ(&BRC, CG.lookupRefSCC(*CG.lookup(lookupFunction(*M, "b3"))));
  EXPECT_TRUE(BRC.isParentOf(CRC));
  ++I;
  EXPECT_NE(I, E);
  LazyCallGraph::RefSCC &ARC = *I;
  EXPECT_NE(&ARC, nullptr);
  EXPECT_EQ(&ARC, CG.lookupRefSCC(*CG.lookup(lookupFunction(*M, "a1"))));
  EXPECT_EQ(&ARC, CG.lookupRefSCC(*CG.lookup(lookupFunction(*M, "a2"))));
  EXPECT_EQ(&ARC, CG.lookupRefSCC(*CG.lookup(lookupFunction(*M, "a3"))));
  EXPECT_TRUE(ARC.isParentOf(CRC));
  ++I;
  EXPECT_EQ(E, I);
d584 11
a594 17
TEST(LazyCallGraphTest, InternalEdgeMutation) {
  LLVMContext Context;
  std::unique_ptr<Module> M = parseAssembly(Context, "define void @@a() {\n"
                                                     "entry:\n"
                                                     "  call void @@b()\n"
                                                     "  ret void\n"
                                                     "}\n"
                                                     "define void @@b() {\n"
                                                     "entry:\n"
                                                     "  call void @@c()\n"
                                                     "  ret void\n"
                                                     "}\n"
                                                     "define void @@c() {\n"
                                                     "entry:\n"
                                                     "  call void @@a()\n"
                                                     "  ret void\n"
                                                     "}\n");
d598 2
a599 3
  auto I = CG.postorder_ref_scc_begin();
  LazyCallGraph::RefSCC &RC = *I++;
  EXPECT_EQ(CG.postorder_ref_scc_end(), I);
a602 40
  LazyCallGraph::Node &C = *CG.lookup(lookupFunction(*M, "c"));
  EXPECT_EQ(&RC, CG.lookupRefSCC(A));
  EXPECT_EQ(&RC, CG.lookupRefSCC(B));
  EXPECT_EQ(&RC, CG.lookupRefSCC(C));
  EXPECT_EQ(1, RC.size());
  EXPECT_EQ(&*RC.begin(), CG.lookupSCC(A));
  EXPECT_EQ(&*RC.begin(), CG.lookupSCC(B));
  EXPECT_EQ(&*RC.begin(), CG.lookupSCC(C));

  // Insert an edge from 'a' to 'c'. Nothing changes about the graph.
  RC.insertInternalRefEdge(A, C);
  EXPECT_EQ(2, std::distance(A.begin(), A.end()));
  EXPECT_EQ(&RC, CG.lookupRefSCC(A));
  EXPECT_EQ(&RC, CG.lookupRefSCC(B));
  EXPECT_EQ(&RC, CG.lookupRefSCC(C));
  EXPECT_EQ(1, RC.size());
  EXPECT_EQ(&*RC.begin(), CG.lookupSCC(A));
  EXPECT_EQ(&*RC.begin(), CG.lookupSCC(B));
  EXPECT_EQ(&*RC.begin(), CG.lookupSCC(C));

  // Switch the call edge from 'b' to 'c' to a ref edge. This will break the
  // call cycle and cause us to form more SCCs. The RefSCC will remain the same
  // though.
  RC.switchInternalEdgeToRef(B, C);
  EXPECT_EQ(&RC, CG.lookupRefSCC(A));
  EXPECT_EQ(&RC, CG.lookupRefSCC(B));
  EXPECT_EQ(&RC, CG.lookupRefSCC(C));
  auto J = RC.begin();
  // The SCCs must be in *post-order* which means successors before
  // predecessors. At this point we have call edges from C to A and from A to
  // B. The only valid postorder is B, A, C.
  EXPECT_EQ(&*J++, CG.lookupSCC(B));
  EXPECT_EQ(&*J++, CG.lookupSCC(A));
  EXPECT_EQ(&*J++, CG.lookupSCC(C));
  EXPECT_EQ(RC.end(), J);

  // Test turning the ref edge from A to C into a call edge. This will form an
  // SCC out of A and C. Since we previously had a call edge from C to A, the
  // C SCC should be preserved and have A merged into it while the A SCC should
  // be invalidated.
d604 1
a604 12
  LazyCallGraph::SCC &CC = *CG.lookupSCC(C);
  auto InvalidatedSCCs = RC.switchInternalEdgeToCall(A, C);
  ASSERT_EQ(1u, InvalidatedSCCs.size());
  EXPECT_EQ(&AC, InvalidatedSCCs[0]);
  EXPECT_EQ(2, CC.size());
  EXPECT_EQ(&CC, CG.lookupSCC(A));
  EXPECT_EQ(&CC, CG.lookupSCC(C));
  J = RC.begin();
  EXPECT_EQ(&*J++, CG.lookupSCC(B));
  EXPECT_EQ(&*J++, CG.lookupSCC(C));
  EXPECT_EQ(RC.end(), J);
}
d606 29
a634 26
TEST(LazyCallGraphTest, InternalEdgeRemoval) {
  LLVMContext Context;
  // A nice fully connected (including self-edges) RefSCC.
  std::unique_ptr<Module> M = parseAssembly(
      Context, "define void @@a(i8** %ptr) {\n"
               "entry:\n"
               "  store i8* bitcast (void(i8**)* @@a to i8*), i8** %ptr\n"
               "  store i8* bitcast (void(i8**)* @@b to i8*), i8** %ptr\n"
               "  store i8* bitcast (void(i8**)* @@c to i8*), i8** %ptr\n"
               "  ret void\n"
               "}\n"
               "define void @@b(i8** %ptr) {\n"
               "entry:\n"
               "  store i8* bitcast (void(i8**)* @@a to i8*), i8** %ptr\n"
               "  store i8* bitcast (void(i8**)* @@b to i8*), i8** %ptr\n"
               "  store i8* bitcast (void(i8**)* @@c to i8*), i8** %ptr\n"
               "  ret void\n"
               "}\n"
               "define void @@c(i8** %ptr) {\n"
               "entry:\n"
               "  store i8* bitcast (void(i8**)* @@a to i8*), i8** %ptr\n"
               "  store i8* bitcast (void(i8**)* @@b to i8*), i8** %ptr\n"
               "  store i8* bitcast (void(i8**)* @@c to i8*), i8** %ptr\n"
               "  ret void\n"
               "}\n");
  LazyCallGraph CG(*M);
d637 10
a646 3
  auto I = CG.postorder_ref_scc_begin();
  LazyCallGraph::RefSCC &RC = *I++;
  EXPECT_EQ(CG.postorder_ref_scc_end(), I);
d648 6
a653 6
  LazyCallGraph::Node &A = *CG.lookup(lookupFunction(*M, "a"));
  LazyCallGraph::Node &B = *CG.lookup(lookupFunction(*M, "b"));
  LazyCallGraph::Node &C = *CG.lookup(lookupFunction(*M, "c"));
  EXPECT_EQ(&RC, CG.lookupRefSCC(A));
  EXPECT_EQ(&RC, CG.lookupRefSCC(B));
  EXPECT_EQ(&RC, CG.lookupRefSCC(C));
d655 33
a687 45
  // Remove the edge from b -> a, which should leave the 3 functions still in
  // a single connected component because of a -> b -> c -> a.
  SmallVector<LazyCallGraph::RefSCC *, 1> NewRCs =
      RC.removeInternalRefEdge(B, A);
  EXPECT_EQ(0u, NewRCs.size());
  EXPECT_EQ(&RC, CG.lookupRefSCC(A));
  EXPECT_EQ(&RC, CG.lookupRefSCC(B));
  EXPECT_EQ(&RC, CG.lookupRefSCC(C));

  // Remove the edge from c -> a, which should leave 'a' in the original RefSCC
  // and form a new RefSCC for 'b' and 'c'.
  NewRCs = RC.removeInternalRefEdge(C, A);
  EXPECT_EQ(1u, NewRCs.size());
  EXPECT_EQ(&RC, CG.lookupRefSCC(A));
  EXPECT_EQ(1, std::distance(RC.begin(), RC.end()));
  LazyCallGraph::RefSCC *RC2 = CG.lookupRefSCC(B);
  EXPECT_EQ(RC2, CG.lookupRefSCC(C));
  EXPECT_EQ(RC2, NewRCs[0]);
}

TEST(LazyCallGraphTest, InternalCallEdgeToRef) {
  LLVMContext Context;
  // A nice fully connected (including self-edges) SCC (and RefSCC)
  std::unique_ptr<Module> M = parseAssembly(Context, "define void @@a() {\n"
                                                     "entry:\n"
                                                     "  call void @@a()\n"
                                                     "  call void @@b()\n"
                                                     "  call void @@c()\n"
                                                     "  ret void\n"
                                                     "}\n"
                                                     "define void @@b() {\n"
                                                     "entry:\n"
                                                     "  call void @@a()\n"
                                                     "  call void @@b()\n"
                                                     "  call void @@c()\n"
                                                     "  ret void\n"
                                                     "}\n"
                                                     "define void @@c() {\n"
                                                     "entry:\n"
                                                     "  call void @@a()\n"
                                                     "  call void @@b()\n"
                                                     "  call void @@c()\n"
                                                     "  ret void\n"
                                                     "}\n");
  LazyCallGraph CG(*M);
d690 10
a699 3
  auto I = CG.postorder_ref_scc_begin();
  LazyCallGraph::RefSCC &RC = *I++;
  EXPECT_EQ(CG.postorder_ref_scc_end(), I);
d701 7
a707 18
  EXPECT_EQ(1, RC.size());
  LazyCallGraph::SCC &CallC = *RC.begin();

  LazyCallGraph::Node &A = *CG.lookup(lookupFunction(*M, "a"));
  LazyCallGraph::Node &B = *CG.lookup(lookupFunction(*M, "b"));
  LazyCallGraph::Node &C = *CG.lookup(lookupFunction(*M, "c"));
  EXPECT_EQ(&CallC, CG.lookupSCC(A));
  EXPECT_EQ(&CallC, CG.lookupSCC(B));
  EXPECT_EQ(&CallC, CG.lookupSCC(C));

  // Remove the call edge from b -> a to a ref edge, which should leave the
  // 3 functions still in a single connected component because of a -> b ->
  // c -> a.
  RC.switchInternalEdgeToRef(B, A);
  EXPECT_EQ(1, RC.size());
  EXPECT_EQ(&CallC, CG.lookupSCC(A));
  EXPECT_EQ(&CallC, CG.lookupSCC(B));
  EXPECT_EQ(&CallC, CG.lookupSCC(C));
d711 7
a717 362
  RC.switchInternalEdgeToRef(C, A);
  EXPECT_EQ(2, RC.size());
  EXPECT_EQ(&CallC, CG.lookupSCC(A));
  LazyCallGraph::SCC &BCallC = *CG.lookupSCC(B);
  EXPECT_NE(&BCallC, &CallC);
  EXPECT_EQ(&BCallC, CG.lookupSCC(C));
  auto J = RC.find(CallC);
  EXPECT_EQ(&CallC, &*J);
  --J;
  EXPECT_EQ(&BCallC, &*J);
  EXPECT_EQ(RC.begin(), J);

  // Remove the edge from c -> b, which should leave 'b' in the original SCC
  // and form a new SCC for 'c'. It shouldn't change 'a's SCC.
  RC.switchInternalEdgeToRef(C, B);
  EXPECT_EQ(3, RC.size());
  EXPECT_EQ(&CallC, CG.lookupSCC(A));
  EXPECT_EQ(&BCallC, CG.lookupSCC(B));
  LazyCallGraph::SCC &CCallC = *CG.lookupSCC(C);
  EXPECT_NE(&CCallC, &CallC);
  EXPECT_NE(&CCallC, &BCallC);
  J = RC.find(CallC);
  EXPECT_EQ(&CallC, &*J);
  --J;
  EXPECT_EQ(&BCallC, &*J);
  --J;
  EXPECT_EQ(&CCallC, &*J);
  EXPECT_EQ(RC.begin(), J);
}

TEST(LazyCallGraphTest, InternalRefEdgeToCall) {
  LLVMContext Context;
  // Basic tests for making a ref edge a call. This hits the basics of the
  // process only.
  std::unique_ptr<Module> M =
      parseAssembly(Context, "define void @@a() {\n"
                             "entry:\n"
                             "  call void @@b()\n"
                             "  call void @@c()\n"
                             "  store void()* @@d, void()** undef\n"
                             "  ret void\n"
                             "}\n"
                             "define void @@b() {\n"
                             "entry:\n"
                             "  store void()* @@c, void()** undef\n"
                             "  call void @@d()\n"
                             "  ret void\n"
                             "}\n"
                             "define void @@c() {\n"
                             "entry:\n"
                             "  store void()* @@b, void()** undef\n"
                             "  call void @@d()\n"
                             "  ret void\n"
                             "}\n"
                             "define void @@d() {\n"
                             "entry:\n"
                             "  store void()* @@a, void()** undef\n"
                             "  ret void\n"
                             "}\n");
  LazyCallGraph CG(*M);

  // Force the graph to be fully expanded.
  auto I = CG.postorder_ref_scc_begin();
  LazyCallGraph::RefSCC &RC = *I++;
  EXPECT_EQ(CG.postorder_ref_scc_end(), I);

  LazyCallGraph::Node &A = *CG.lookup(lookupFunction(*M, "a"));
  LazyCallGraph::Node &B = *CG.lookup(lookupFunction(*M, "b"));
  LazyCallGraph::Node &C = *CG.lookup(lookupFunction(*M, "c"));
  LazyCallGraph::Node &D = *CG.lookup(lookupFunction(*M, "d"));
  LazyCallGraph::SCC &AC = *CG.lookupSCC(A);
  LazyCallGraph::SCC &BC = *CG.lookupSCC(B);
  LazyCallGraph::SCC &CC = *CG.lookupSCC(C);
  LazyCallGraph::SCC &DC = *CG.lookupSCC(D);

  // Check the initial post-order. Note that B and C could be flipped here (and
  // in our mutation) without changing the nature of this test.
  ASSERT_EQ(4, RC.size());
  EXPECT_EQ(&DC, &RC[0]);
  EXPECT_EQ(&BC, &RC[1]);
  EXPECT_EQ(&CC, &RC[2]);
  EXPECT_EQ(&AC, &RC[3]);

  // Switch the ref edge from A -> D to a call edge. This should have no
  // effect as it is already in postorder and no new cycles are formed.
  auto MergedCs = RC.switchInternalEdgeToCall(A, D);
  EXPECT_EQ(0u, MergedCs.size());
  ASSERT_EQ(4, RC.size());
  EXPECT_EQ(&DC, &RC[0]);
  EXPECT_EQ(&BC, &RC[1]);
  EXPECT_EQ(&CC, &RC[2]);
  EXPECT_EQ(&AC, &RC[3]);

  // Switch B -> C to a call edge. This doesn't form any new cycles but does
  // require reordering the SCCs.
  MergedCs = RC.switchInternalEdgeToCall(B, C);
  EXPECT_EQ(0u, MergedCs.size());
  ASSERT_EQ(4, RC.size());
  EXPECT_EQ(&DC, &RC[0]);
  EXPECT_EQ(&CC, &RC[1]);
  EXPECT_EQ(&BC, &RC[2]);
  EXPECT_EQ(&AC, &RC[3]);

  // Switch C -> B to a call edge. This forms a cycle and forces merging SCCs.
  MergedCs = RC.switchInternalEdgeToCall(C, B);
  ASSERT_EQ(1u, MergedCs.size());
  EXPECT_EQ(&CC, MergedCs[0]);
  ASSERT_EQ(3, RC.size());
  EXPECT_EQ(&DC, &RC[0]);
  EXPECT_EQ(&BC, &RC[1]);
  EXPECT_EQ(&AC, &RC[2]);
  EXPECT_EQ(2, BC.size());
  EXPECT_EQ(&BC, CG.lookupSCC(B));
  EXPECT_EQ(&BC, CG.lookupSCC(C));
}

TEST(LazyCallGraphTest, InternalRefEdgeToCallNoCycleInterleaved) {
  LLVMContext Context;
  // Test for having a post-order prior to changing a ref edge to a call edge
  // with SCCs connecting to the source and connecting to the target, but not
  // connecting to both, interleaved between the source and target. This
  // ensures we correctly partition the range rather than simply moving one or
  // the other.
  std::unique_ptr<Module> M =
      parseAssembly(Context, "define void @@a() {\n"
                             "entry:\n"
                             "  call void @@b1()\n"
                             "  call void @@c1()\n"
                             "  ret void\n"
                             "}\n"
                             "define void @@b1() {\n"
                             "entry:\n"
                             "  call void @@c1()\n"
                             "  call void @@b2()\n"
                             "  ret void\n"
                             "}\n"
                             "define void @@c1() {\n"
                             "entry:\n"
                             "  call void @@b2()\n"
                             "  call void @@c2()\n"
                             "  ret void\n"
                             "}\n"
                             "define void @@b2() {\n"
                             "entry:\n"
                             "  call void @@c2()\n"
                             "  call void @@b3()\n"
                             "  ret void\n"
                             "}\n"
                             "define void @@c2() {\n"
                             "entry:\n"
                             "  call void @@b3()\n"
                             "  call void @@c3()\n"
                             "  ret void\n"
                             "}\n"
                             "define void @@b3() {\n"
                             "entry:\n"
                             "  call void @@c3()\n"
                             "  call void @@d()\n"
                             "  ret void\n"
                             "}\n"
                             "define void @@c3() {\n"
                             "entry:\n"
                             "  store void()* @@b1, void()** undef\n"
                             "  call void @@d()\n"
                             "  ret void\n"
                             "}\n"
                             "define void @@d() {\n"
                             "entry:\n"
                             "  store void()* @@a, void()** undef\n"
                             "  ret void\n"
                             "}\n");
  LazyCallGraph CG(*M);

  // Force the graph to be fully expanded.
  auto I = CG.postorder_ref_scc_begin();
  LazyCallGraph::RefSCC &RC = *I++;
  EXPECT_EQ(CG.postorder_ref_scc_end(), I);

  LazyCallGraph::Node &A = *CG.lookup(lookupFunction(*M, "a"));
  LazyCallGraph::Node &B1 = *CG.lookup(lookupFunction(*M, "b1"));
  LazyCallGraph::Node &B2 = *CG.lookup(lookupFunction(*M, "b2"));
  LazyCallGraph::Node &B3 = *CG.lookup(lookupFunction(*M, "b3"));
  LazyCallGraph::Node &C1 = *CG.lookup(lookupFunction(*M, "c1"));
  LazyCallGraph::Node &C2 = *CG.lookup(lookupFunction(*M, "c2"));
  LazyCallGraph::Node &C3 = *CG.lookup(lookupFunction(*M, "c3"));
  LazyCallGraph::Node &D = *CG.lookup(lookupFunction(*M, "d"));
  LazyCallGraph::SCC &AC = *CG.lookupSCC(A);
  LazyCallGraph::SCC &B1C = *CG.lookupSCC(B1);
  LazyCallGraph::SCC &B2C = *CG.lookupSCC(B2);
  LazyCallGraph::SCC &B3C = *CG.lookupSCC(B3);
  LazyCallGraph::SCC &C1C = *CG.lookupSCC(C1);
  LazyCallGraph::SCC &C2C = *CG.lookupSCC(C2);
  LazyCallGraph::SCC &C3C = *CG.lookupSCC(C3);
  LazyCallGraph::SCC &DC = *CG.lookupSCC(D);

  // Several call edges are initially present to force a particual post-order.
  // Remove them now, leaving an interleaved post-order pattern.
  RC.switchInternalEdgeToRef(B3, C3);
  RC.switchInternalEdgeToRef(C2, B3);
  RC.switchInternalEdgeToRef(B2, C2);
  RC.switchInternalEdgeToRef(C1, B2);
  RC.switchInternalEdgeToRef(B1, C1);

  // Check the initial post-order. We ensure this order with the extra edges
  // that are nuked above.
  ASSERT_EQ(8, RC.size());
  EXPECT_EQ(&DC, &RC[0]);
  EXPECT_EQ(&C3C, &RC[1]);
  EXPECT_EQ(&B3C, &RC[2]);
  EXPECT_EQ(&C2C, &RC[3]);
  EXPECT_EQ(&B2C, &RC[4]);
  EXPECT_EQ(&C1C, &RC[5]);
  EXPECT_EQ(&B1C, &RC[6]);
  EXPECT_EQ(&AC, &RC[7]);

  // Switch C3 -> B1 to a call edge. This doesn't form any new cycles but does
  // require reordering the SCCs in the face of tricky internal node
  // structures.
  auto MergedCs = RC.switchInternalEdgeToCall(C3, B1);
  EXPECT_EQ(0u, MergedCs.size());
  ASSERT_EQ(8, RC.size());
  EXPECT_EQ(&DC, &RC[0]);
  EXPECT_EQ(&B3C, &RC[1]);
  EXPECT_EQ(&B2C, &RC[2]);
  EXPECT_EQ(&B1C, &RC[3]);
  EXPECT_EQ(&C3C, &RC[4]);
  EXPECT_EQ(&C2C, &RC[5]);
  EXPECT_EQ(&C1C, &RC[6]);
  EXPECT_EQ(&AC, &RC[7]);
}

TEST(LazyCallGraphTest, InternalRefEdgeToCallBothPartitionAndMerge) {
  LLVMContext Context;
  // Test for having a postorder where between the source and target are all
  // three kinds of other SCCs:
  // 1) One connected to the target only that have to be shifted below the
  //    source.
  // 2) One connected to the source only that have to be shifted below the
  //    target.
  // 3) One connected to both source and target that has to remain and get
  //    merged away.
  //
  // To achieve this we construct a heavily connected graph to force
  // a particular post-order. Then we remove the forcing edges and connect
  // a cycle.
  //
  // Diagram for the graph we want on the left and the graph we use to force
  // the ordering on the right. Edges ponit down or right.
  //
  //   A    |    A    |
  //  / \   |   / \   |
  // B   E  |  B   \  |
  // |\  |  |  |\  |  |
  // | D |  |  C-D-E  |
  // |  \|  |  |  \|  |
  // C   F  |  \   F  |
  //  \ /   |   \ /   |
  //   G    |    G    |
  //
  // And we form a cycle by connecting F to B.
  std::unique_ptr<Module> M =
      parseAssembly(Context, "define void @@a() {\n"
                             "entry:\n"
                             "  call void @@b()\n"
                             "  call void @@e()\n"
                             "  ret void\n"
                             "}\n"
                             "define void @@b() {\n"
                             "entry:\n"
                             "  call void @@c()\n"
                             "  call void @@d()\n"
                             "  ret void\n"
                             "}\n"
                             "define void @@c() {\n"
                             "entry:\n"
                             "  call void @@d()\n"
                             "  call void @@g()\n"
                             "  ret void\n"
                             "}\n"
                             "define void @@d() {\n"
                             "entry:\n"
                             "  call void @@e()\n"
                             "  call void @@f()\n"
                             "  ret void\n"
                             "}\n"
                             "define void @@e() {\n"
                             "entry:\n"
                             "  call void @@f()\n"
                             "  ret void\n"
                             "}\n"
                             "define void @@f() {\n"
                             "entry:\n"
                             "  store void()* @@b, void()** undef\n"
                             "  call void @@g()\n"
                             "  ret void\n"
                             "}\n"
                             "define void @@g() {\n"
                             "entry:\n"
                             "  store void()* @@a, void()** undef\n"
                             "  ret void\n"
                             "}\n");
  LazyCallGraph CG(*M);

  // Force the graph to be fully expanded.
  auto I = CG.postorder_ref_scc_begin();
  LazyCallGraph::RefSCC &RC = *I++;
  EXPECT_EQ(CG.postorder_ref_scc_end(), I);

  LazyCallGraph::Node &A = *CG.lookup(lookupFunction(*M, "a"));
  LazyCallGraph::Node &B = *CG.lookup(lookupFunction(*M, "b"));
  LazyCallGraph::Node &C = *CG.lookup(lookupFunction(*M, "c"));
  LazyCallGraph::Node &D = *CG.lookup(lookupFunction(*M, "d"));
  LazyCallGraph::Node &E = *CG.lookup(lookupFunction(*M, "e"));
  LazyCallGraph::Node &F = *CG.lookup(lookupFunction(*M, "f"));
  LazyCallGraph::Node &G = *CG.lookup(lookupFunction(*M, "g"));
  LazyCallGraph::SCC &AC = *CG.lookupSCC(A);
  LazyCallGraph::SCC &BC = *CG.lookupSCC(B);
  LazyCallGraph::SCC &CC = *CG.lookupSCC(C);
  LazyCallGraph::SCC &DC = *CG.lookupSCC(D);
  LazyCallGraph::SCC &EC = *CG.lookupSCC(E);
  LazyCallGraph::SCC &FC = *CG.lookupSCC(F);
  LazyCallGraph::SCC &GC = *CG.lookupSCC(G);

  // Remove the extra edges that were used to force a particular post-order.
  RC.switchInternalEdgeToRef(C, D);
  RC.switchInternalEdgeToRef(D, E);

  // Check the initial post-order. We ensure this order with the extra edges
  // that are nuked above.
  ASSERT_EQ(7, RC.size());
  EXPECT_EQ(&GC, &RC[0]);
  EXPECT_EQ(&FC, &RC[1]);
  EXPECT_EQ(&EC, &RC[2]);
  EXPECT_EQ(&DC, &RC[3]);
  EXPECT_EQ(&CC, &RC[4]);
  EXPECT_EQ(&BC, &RC[5]);
  EXPECT_EQ(&AC, &RC[6]);

  // Switch F -> B to a call edge. This merges B, D, and F into a single SCC,
  // and has to place the C and E SCCs on either side of it:
  //   A          A    |
  //  / \        / \   |
  // B   E      |   E  |
  // |\  |       \ /   |
  // | D |  ->    B    |
  // |  \|       / \   |
  // C   F      C   |  |
  //  \ /        \ /   |
  //   G          G    |
  auto MergedCs = RC.switchInternalEdgeToCall(F, B);
  ASSERT_EQ(2u, MergedCs.size());
  EXPECT_EQ(&FC, MergedCs[0]);
  EXPECT_EQ(&DC, MergedCs[1]);
  EXPECT_EQ(3, BC.size());

  // And make sure the postorder was updated.
  ASSERT_EQ(5, RC.size());
  EXPECT_EQ(&GC, &RC[0]);
  EXPECT_EQ(&CC, &RC[1]);
  EXPECT_EQ(&BC, &RC[2]);
  EXPECT_EQ(&EC, &RC[3]);
  EXPECT_EQ(&AC, &RC[4]);
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a11 1
#include "llvm/IR/Instructions.h"
a122 95
/*
   IR forming a reference graph with a diamond of triangle-shaped RefSCCs

           d1
          /  \
         d3--d2
        /     \
       b1     c1
     /  \    /  \
    b3--b2  c3--c2
         \  /
          a1
         /  \
        a3--a2

   All call edges go up between RefSCCs, and clockwise around the RefSCC.
 */
static const char DiamondOfTrianglesRefGraph[] =
     "define void @@a1() {\n"
     "entry:\n"
     "  %a = alloca void ()*\n"
     "  store void ()* @@a2, void ()** %a\n"
     "  store void ()* @@b2, void ()** %a\n"
     "  store void ()* @@c3, void ()** %a\n"
     "  ret void\n"
     "}\n"
     "define void @@a2() {\n"
     "entry:\n"
     "  %a = alloca void ()*\n"
     "  store void ()* @@a3, void ()** %a\n"
     "  ret void\n"
     "}\n"
     "define void @@a3() {\n"
     "entry:\n"
     "  %a = alloca void ()*\n"
     "  store void ()* @@a1, void ()** %a\n"
     "  ret void\n"
     "}\n"
     "define void @@b1() {\n"
     "entry:\n"
     "  %a = alloca void ()*\n"
     "  store void ()* @@b2, void ()** %a\n"
     "  store void ()* @@d3, void ()** %a\n"
     "  ret void\n"
     "}\n"
     "define void @@b2() {\n"
     "entry:\n"
     "  %a = alloca void ()*\n"
     "  store void ()* @@b3, void ()** %a\n"
     "  ret void\n"
     "}\n"
     "define void @@b3() {\n"
     "entry:\n"
     "  %a = alloca void ()*\n"
     "  store void ()* @@b1, void ()** %a\n"
     "  ret void\n"
     "}\n"
     "define void @@c1() {\n"
     "entry:\n"
     "  %a = alloca void ()*\n"
     "  store void ()* @@c2, void ()** %a\n"
     "  store void ()* @@d2, void ()** %a\n"
     "  ret void\n"
     "}\n"
     "define void @@c2() {\n"
     "entry:\n"
     "  %a = alloca void ()*\n"
     "  store void ()* @@c3, void ()** %a\n"
     "  ret void\n"
     "}\n"
     "define void @@c3() {\n"
     "entry:\n"
     "  %a = alloca void ()*\n"
     "  store void ()* @@c1, void ()** %a\n"
     "  ret void\n"
     "}\n"
     "define void @@d1() {\n"
     "entry:\n"
     "  %a = alloca void ()*\n"
     "  store void ()* @@d2, void ()** %a\n"
     "  ret void\n"
     "}\n"
     "define void @@d2() {\n"
     "entry:\n"
     "  %a = alloca void ()*\n"
     "  store void ()* @@d3, void ()** %a\n"
     "  ret void\n"
     "}\n"
     "define void @@d3() {\n"
     "entry:\n"
     "  %a = alloca void ()*\n"
     "  store void ()* @@d1, void ()** %a\n"
     "  ret void\n"
     "}\n";

a222 1
  EXPECT_EQ(&D, &*CG.postorder_ref_scc_begin());
a237 1
  EXPECT_EQ(&C, &*std::next(CG.postorder_ref_scc_begin()));
a254 1
  EXPECT_EQ(&B, &*std::next(CG.postorder_ref_scc_begin(), 2));
a271 1
  EXPECT_EQ(&A, &*std::next(CG.postorder_ref_scc_begin(), 3));
a273 1
  EXPECT_EQ(J, std::next(CG.postorder_ref_scc_begin(), 4));
d481 1
a481 1
    dbgs() << "Formed RefSCC: " << RC << "\n";
a495 1
  EXPECT_TRUE(AC.isParentOf(BC));
a496 1
  EXPECT_TRUE(AC.isParentOf(CC));
a497 1
  EXPECT_FALSE(AC.isParentOf(DC));
a498 1
  EXPECT_TRUE(AC.isAncestorOf(DC));
a499 1
  EXPECT_FALSE(DC.isChildOf(AC));
a500 1
  EXPECT_TRUE(DC.isDescendantOf(AC));
a501 1
  EXPECT_TRUE(DC.isChildOf(BC));
a502 1
  EXPECT_TRUE(DC.isChildOf(CC));
a514 1
  EXPECT_TRUE(AC.isParentOf(DC));
a515 1
  EXPECT_TRUE(AC.isAncestorOf(DC));
a516 1
  EXPECT_TRUE(DC.isChildOf(AC));
a517 1
  EXPECT_TRUE(DC.isDescendantOf(AC));
d530 1
a530 1
  // Verify the reference graph remains the same but the SCC graph is updated.
a531 1
  EXPECT_FALSE(AC.isParentOf(DC));
a532 1
  EXPECT_TRUE(AC.isAncestorOf(DC));
a533 1
  EXPECT_FALSE(DC.isChildOf(AC));
a534 1
  EXPECT_TRUE(DC.isDescendantOf(AC));
d547 1
a547 1
  // Verify the reference graph remains the same but the SCC graph is updated.
a548 1
  EXPECT_TRUE(AC.isParentOf(DC));
a549 1
  EXPECT_TRUE(AC.isAncestorOf(DC));
a550 1
  EXPECT_TRUE(DC.isChildOf(AC));
a551 1
  EXPECT_TRUE(DC.isDescendantOf(AC));
a565 1
  EXPECT_FALSE(AC.isParentOf(DC));
a566 1
  EXPECT_TRUE(AC.isAncestorOf(DC));
a567 1
  EXPECT_FALSE(DC.isChildOf(AC));
a568 1
  EXPECT_TRUE(DC.isDescendantOf(AC));
d602 1
a602 1
    dbgs() << "Formed RefSCC: " << RC << "\n";
a670 10

  // And verify the post-order walk reflects the updated structure.
  auto I = CG.postorder_ref_scc_begin(), E = CG.postorder_ref_scc_end();
  ASSERT_NE(I, E);
  EXPECT_EQ(&CRC, &*I) << "Actual RefSCC: " << *I;
  ASSERT_NE(++I, E);
  EXPECT_EQ(&BRC, &*I) << "Actual RefSCC: " << *I;
  ASSERT_NE(++I, E);
  EXPECT_EQ(&ARC, &*I) << "Actual RefSCC: " << *I;
  EXPECT_EQ(++I, E);
d729 1
a729 23
  // Verify that the post-order walk reflects the updated but still incomplete
  // structure.
  auto J = CG.postorder_ref_scc_begin();
  EXPECT_NE(J, E);
  EXPECT_EQ(&CRC, &*J) << "Actual RefSCC: " << *J;
  EXPECT_EQ(I, J);

  // Check that we can form the last two RefSCCs now, and even that we can do
  // it with alternating iterators.
  ++J;
  EXPECT_NE(J, E);
  LazyCallGraph::RefSCC &BRC = *J;
  EXPECT_NE(&BRC, nullptr);
  EXPECT_EQ(&BRC, CG.lookupRefSCC(*CG.lookup(lookupFunction(*M, "b1"))));
  EXPECT_EQ(&BRC, CG.lookupRefSCC(*CG.lookup(lookupFunction(*M, "b2"))));
  EXPECT_EQ(&BRC, CG.lookupRefSCC(*CG.lookup(lookupFunction(*M, "b3"))));
  EXPECT_TRUE(BRC.isParentOf(CRC));
  ++I;
  EXPECT_EQ(J, I);
  EXPECT_EQ(&BRC, &*I) << "Actual RefSCC: " << *I;

  // Increment I this time to form the new RefSCC, flopping back to the first
  // iterator.
d732 1
a732 532
  LazyCallGraph::RefSCC &ARC = *I;
  EXPECT_NE(&ARC, nullptr);
  EXPECT_EQ(&ARC, CG.lookupRefSCC(*CG.lookup(lookupFunction(*M, "a1"))));
  EXPECT_EQ(&ARC, CG.lookupRefSCC(*CG.lookup(lookupFunction(*M, "a2"))));
  EXPECT_EQ(&ARC, CG.lookupRefSCC(*CG.lookup(lookupFunction(*M, "a3"))));
  EXPECT_TRUE(ARC.isParentOf(CRC));
  ++J;
  EXPECT_EQ(I, J);
  EXPECT_EQ(&ARC, &*J) << "Actual RefSCC: " << *J;
  ++I;
  EXPECT_EQ(E, I);
  ++J;
  EXPECT_EQ(E, J);
}

TEST(LazyCallGraphTest, IncomingEdgeInsertionRefGraph) {
  LLVMContext Context;
  // Another variation of the above test but with all the edges switched to
  // references rather than calls.
  std::unique_ptr<Module> M =
      parseAssembly(Context, DiamondOfTrianglesRefGraph);
  LazyCallGraph CG(*M);

  // Force the graph to be fully expanded.
  for (LazyCallGraph::RefSCC &RC : CG.postorder_ref_sccs())
    dbgs() << "Formed RefSCC: " << RC << "\n";

  LazyCallGraph::Node &A1 = *CG.lookup(lookupFunction(*M, "a1"));
  LazyCallGraph::Node &A2 = *CG.lookup(lookupFunction(*M, "a2"));
  LazyCallGraph::Node &A3 = *CG.lookup(lookupFunction(*M, "a3"));
  LazyCallGraph::Node &B1 = *CG.lookup(lookupFunction(*M, "b1"));
  LazyCallGraph::Node &B2 = *CG.lookup(lookupFunction(*M, "b2"));
  LazyCallGraph::Node &B3 = *CG.lookup(lookupFunction(*M, "b3"));
  LazyCallGraph::Node &C1 = *CG.lookup(lookupFunction(*M, "c1"));
  LazyCallGraph::Node &C2 = *CG.lookup(lookupFunction(*M, "c2"));
  LazyCallGraph::Node &C3 = *CG.lookup(lookupFunction(*M, "c3"));
  LazyCallGraph::Node &D1 = *CG.lookup(lookupFunction(*M, "d1"));
  LazyCallGraph::Node &D2 = *CG.lookup(lookupFunction(*M, "d2"));
  LazyCallGraph::Node &D3 = *CG.lookup(lookupFunction(*M, "d3"));
  LazyCallGraph::RefSCC &ARC = *CG.lookupRefSCC(A1);
  LazyCallGraph::RefSCC &BRC = *CG.lookupRefSCC(B1);
  LazyCallGraph::RefSCC &CRC = *CG.lookupRefSCC(C1);
  LazyCallGraph::RefSCC &DRC = *CG.lookupRefSCC(D1);
  ASSERT_EQ(&ARC, CG.lookupRefSCC(A2));
  ASSERT_EQ(&ARC, CG.lookupRefSCC(A3));
  ASSERT_EQ(&BRC, CG.lookupRefSCC(B2));
  ASSERT_EQ(&BRC, CG.lookupRefSCC(B3));
  ASSERT_EQ(&CRC, CG.lookupRefSCC(C2));
  ASSERT_EQ(&CRC, CG.lookupRefSCC(C3));
  ASSERT_EQ(&DRC, CG.lookupRefSCC(D2));
  ASSERT_EQ(&DRC, CG.lookupRefSCC(D3));
  ASSERT_EQ(1, std::distance(D2.begin(), D2.end()));

  // Add an edge to make the graph:
  //
  //         d1         |
  //        /  \        |
  //       d3--d2---.   |
  //      /     \    |  |
  //     b1     c1   |  |
  //   /  \    /  \ /   |
  //  b3--b2  c3--c2    |
  //       \  /         |
  //        a1          |
  //       /  \         |
  //      a3--a2        |
  auto MergedRCs = CRC.insertIncomingRefEdge(D2, C2);
  // Make sure we connected the nodes.
  for (LazyCallGraph::Edge E : D2) {
    if (E.getNode() == &D3)
      continue;
    EXPECT_EQ(&C2, E.getNode());
  }
  // And marked the D ref-SCC as no longer valid.
  EXPECT_EQ(1u, MergedRCs.size());
  EXPECT_EQ(&DRC, MergedRCs[0]);

  // Make sure we have the correct nodes in the SCC sets.
  EXPECT_EQ(&ARC, CG.lookupRefSCC(A1));
  EXPECT_EQ(&ARC, CG.lookupRefSCC(A2));
  EXPECT_EQ(&ARC, CG.lookupRefSCC(A3));
  EXPECT_EQ(&BRC, CG.lookupRefSCC(B1));
  EXPECT_EQ(&BRC, CG.lookupRefSCC(B2));
  EXPECT_EQ(&BRC, CG.lookupRefSCC(B3));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(C1));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(C2));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(C3));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(D1));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(D2));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(D3));

  // And that ancestry tests have been updated.
  EXPECT_TRUE(ARC.isParentOf(CRC));
  EXPECT_TRUE(BRC.isParentOf(CRC));

  // And verify the post-order walk reflects the updated structure.
  auto I = CG.postorder_ref_scc_begin(), E = CG.postorder_ref_scc_end();
  ASSERT_NE(I, E);
  EXPECT_EQ(&CRC, &*I) << "Actual RefSCC: " << *I;
  ASSERT_NE(++I, E);
  EXPECT_EQ(&BRC, &*I) << "Actual RefSCC: " << *I;
  ASSERT_NE(++I, E);
  EXPECT_EQ(&ARC, &*I) << "Actual RefSCC: " << *I;
  EXPECT_EQ(++I, E);
}

TEST(LazyCallGraphTest, IncomingEdgeInsertionLargeCallCycle) {
  LLVMContext Context;
  std::unique_ptr<Module> M = parseAssembly(Context, "define void @@a() {\n"
                                                     "entry:\n"
                                                     "  call void @@b()\n"
                                                     "  ret void\n"
                                                     "}\n"
                                                     "define void @@b() {\n"
                                                     "entry:\n"
                                                     "  call void @@c()\n"
                                                     "  ret void\n"
                                                     "}\n"
                                                     "define void @@c() {\n"
                                                     "entry:\n"
                                                     "  call void @@d()\n"
                                                     "  ret void\n"
                                                     "}\n"
                                                     "define void @@d() {\n"
                                                     "entry:\n"
                                                     "  ret void\n"
                                                     "}\n");
  LazyCallGraph CG(*M);

  // Force the graph to be fully expanded.
  for (LazyCallGraph::RefSCC &RC : CG.postorder_ref_sccs())
    dbgs() << "Formed RefSCC: " << RC << "\n";

  LazyCallGraph::Node &A = *CG.lookup(lookupFunction(*M, "a"));
  LazyCallGraph::Node &B = *CG.lookup(lookupFunction(*M, "b"));
  LazyCallGraph::Node &C = *CG.lookup(lookupFunction(*M, "c"));
  LazyCallGraph::Node &D = *CG.lookup(lookupFunction(*M, "d"));
  LazyCallGraph::SCC &AC = *CG.lookupSCC(A);
  LazyCallGraph::SCC &BC = *CG.lookupSCC(B);
  LazyCallGraph::SCC &CC = *CG.lookupSCC(C);
  LazyCallGraph::SCC &DC = *CG.lookupSCC(D);
  LazyCallGraph::RefSCC &ARC = *CG.lookupRefSCC(A);
  LazyCallGraph::RefSCC &BRC = *CG.lookupRefSCC(B);
  LazyCallGraph::RefSCC &CRC = *CG.lookupRefSCC(C);
  LazyCallGraph::RefSCC &DRC = *CG.lookupRefSCC(D);

  // Connect the top to the bottom forming a large RefSCC made up mostly of calls.
  auto MergedRCs = ARC.insertIncomingRefEdge(D, A);
  // Make sure we connected the nodes.
  EXPECT_NE(D.begin(), D.end());
  EXPECT_EQ(&A, D.begin()->getNode());

  // Check that we have the dead RCs, but ignore the order.
  EXPECT_EQ(3u, MergedRCs.size());
  EXPECT_NE(find(MergedRCs, &BRC), MergedRCs.end());
  EXPECT_NE(find(MergedRCs, &CRC), MergedRCs.end());
  EXPECT_NE(find(MergedRCs, &DRC), MergedRCs.end());

  // Make sure the nodes point to the right place now.
  EXPECT_EQ(&ARC, CG.lookupRefSCC(A));
  EXPECT_EQ(&ARC, CG.lookupRefSCC(B));
  EXPECT_EQ(&ARC, CG.lookupRefSCC(C));
  EXPECT_EQ(&ARC, CG.lookupRefSCC(D));

  // Check that the SCCs are in postorder.
  EXPECT_EQ(4, ARC.size());
  EXPECT_EQ(&DC, &ARC[0]);
  EXPECT_EQ(&CC, &ARC[1]);
  EXPECT_EQ(&BC, &ARC[2]);
  EXPECT_EQ(&AC, &ARC[3]);

  // And verify the post-order walk reflects the updated structure.
  auto I = CG.postorder_ref_scc_begin(), E = CG.postorder_ref_scc_end();
  ASSERT_NE(I, E);
  EXPECT_EQ(&ARC, &*I) << "Actual RefSCC: " << *I;
  EXPECT_EQ(++I, E);
}

TEST(LazyCallGraphTest, IncomingEdgeInsertionLargeRefCycle) {
  LLVMContext Context;
  std::unique_ptr<Module> M =
      parseAssembly(Context, "define void @@a() {\n"
                             "entry:\n"
                             "  %p = alloca void ()*\n"
                             "  store void ()* @@b, void ()** %p\n"
                             "  ret void\n"
                             "}\n"
                             "define void @@b() {\n"
                             "entry:\n"
                             "  %p = alloca void ()*\n"
                             "  store void ()* @@c, void ()** %p\n"
                             "  ret void\n"
                             "}\n"
                             "define void @@c() {\n"
                             "entry:\n"
                             "  %p = alloca void ()*\n"
                             "  store void ()* @@d, void ()** %p\n"
                             "  ret void\n"
                             "}\n"
                             "define void @@d() {\n"
                             "entry:\n"
                             "  ret void\n"
                             "}\n");
  LazyCallGraph CG(*M);

  // Force the graph to be fully expanded.
  for (LazyCallGraph::RefSCC &RC : CG.postorder_ref_sccs())
    dbgs() << "Formed RefSCC: " << RC << "\n";

  LazyCallGraph::Node &A = *CG.lookup(lookupFunction(*M, "a"));
  LazyCallGraph::Node &B = *CG.lookup(lookupFunction(*M, "b"));
  LazyCallGraph::Node &C = *CG.lookup(lookupFunction(*M, "c"));
  LazyCallGraph::Node &D = *CG.lookup(lookupFunction(*M, "d"));
  LazyCallGraph::RefSCC &ARC = *CG.lookupRefSCC(A);
  LazyCallGraph::RefSCC &BRC = *CG.lookupRefSCC(B);
  LazyCallGraph::RefSCC &CRC = *CG.lookupRefSCC(C);
  LazyCallGraph::RefSCC &DRC = *CG.lookupRefSCC(D);

  // Connect the top to the bottom forming a large RefSCC made up just of
  // references.
  auto MergedRCs = ARC.insertIncomingRefEdge(D, A);
  // Make sure we connected the nodes.
  EXPECT_NE(D.begin(), D.end());
  EXPECT_EQ(&A, D.begin()->getNode());

  // Check that we have the dead RCs, but ignore the order.
  EXPECT_EQ(3u, MergedRCs.size());
  EXPECT_NE(find(MergedRCs, &BRC), MergedRCs.end());
  EXPECT_NE(find(MergedRCs, &CRC), MergedRCs.end());
  EXPECT_NE(find(MergedRCs, &DRC), MergedRCs.end());

  // Make sure the nodes point to the right place now.
  EXPECT_EQ(&ARC, CG.lookupRefSCC(A));
  EXPECT_EQ(&ARC, CG.lookupRefSCC(B));
  EXPECT_EQ(&ARC, CG.lookupRefSCC(C));
  EXPECT_EQ(&ARC, CG.lookupRefSCC(D));

  // And verify the post-order walk reflects the updated structure.
  auto I = CG.postorder_ref_scc_begin(), End = CG.postorder_ref_scc_end();
  ASSERT_NE(I, End);
  EXPECT_EQ(&ARC, &*I) << "Actual RefSCC: " << *I;
  EXPECT_EQ(++I, End);
}

TEST(LazyCallGraphTest, InlineAndDeleteFunction) {
  LLVMContext Context;
  // We want to ensure we can delete nodes from relatively complex graphs and
  // so use the diamond of triangles graph defined above.
  //
  // The ascii diagram is repeated here for easy reference.
  //
  //         d1       |
  //        /  \      |
  //       d3--d2     |
  //      /     \     |
  //     b1     c1    |
  //   /  \    /  \   |
  //  b3--b2  c3--c2  |
  //       \  /       |
  //        a1        |
  //       /  \       |
  //      a3--a2      |
  //
  std::unique_ptr<Module> M = parseAssembly(Context, DiamondOfTriangles);
  LazyCallGraph CG(*M);

  // Force the graph to be fully expanded.
  for (LazyCallGraph::RefSCC &RC : CG.postorder_ref_sccs())
    dbgs() << "Formed RefSCC: " << RC << "\n";

  LazyCallGraph::Node &A1 = *CG.lookup(lookupFunction(*M, "a1"));
  LazyCallGraph::Node &A2 = *CG.lookup(lookupFunction(*M, "a2"));
  LazyCallGraph::Node &A3 = *CG.lookup(lookupFunction(*M, "a3"));
  LazyCallGraph::Node &B1 = *CG.lookup(lookupFunction(*M, "b1"));
  LazyCallGraph::Node &B2 = *CG.lookup(lookupFunction(*M, "b2"));
  LazyCallGraph::Node &B3 = *CG.lookup(lookupFunction(*M, "b3"));
  LazyCallGraph::Node &C1 = *CG.lookup(lookupFunction(*M, "c1"));
  LazyCallGraph::Node &C2 = *CG.lookup(lookupFunction(*M, "c2"));
  LazyCallGraph::Node &C3 = *CG.lookup(lookupFunction(*M, "c3"));
  LazyCallGraph::Node &D1 = *CG.lookup(lookupFunction(*M, "d1"));
  LazyCallGraph::Node &D2 = *CG.lookup(lookupFunction(*M, "d2"));
  LazyCallGraph::Node &D3 = *CG.lookup(lookupFunction(*M, "d3"));
  LazyCallGraph::RefSCC &ARC = *CG.lookupRefSCC(A1);
  LazyCallGraph::RefSCC &BRC = *CG.lookupRefSCC(B1);
  LazyCallGraph::RefSCC &CRC = *CG.lookupRefSCC(C1);
  LazyCallGraph::RefSCC &DRC = *CG.lookupRefSCC(D1);
  ASSERT_EQ(&ARC, CG.lookupRefSCC(A2));
  ASSERT_EQ(&ARC, CG.lookupRefSCC(A3));
  ASSERT_EQ(&BRC, CG.lookupRefSCC(B2));
  ASSERT_EQ(&BRC, CG.lookupRefSCC(B3));
  ASSERT_EQ(&CRC, CG.lookupRefSCC(C2));
  ASSERT_EQ(&CRC, CG.lookupRefSCC(C3));
  ASSERT_EQ(&DRC, CG.lookupRefSCC(D2));
  ASSERT_EQ(&DRC, CG.lookupRefSCC(D3));
  ASSERT_EQ(1, std::distance(D2.begin(), D2.end()));

  // Delete d2 from the graph, as if it had been inlined.
  //
  //         d1         |
  //        / /         |
  //       d3--.        |
  //      /     \       |
  //     b1     c1      |
  //   /  \    /  \     |
  //  b3--b2  c3--c2    |
  //       \  /         |
  //        a1          |
  //       /  \         |
  //      a3--a2        |

  Function &D2F = D2.getFunction();
  CallInst *C1Call = nullptr, *D1Call = nullptr;
  for (User *U : D2F.users()) {
    CallInst *CI = dyn_cast<CallInst>(U);
    ASSERT_TRUE(CI) << "Expected a call: " << *U;
    if (CI->getParent()->getParent() == &C1.getFunction()) {
      ASSERT_EQ(nullptr, C1Call) << "Found too many C1 calls: " << *CI;
      C1Call = CI;
    } else if (CI->getParent()->getParent() == &D1.getFunction()) {
      ASSERT_EQ(nullptr, D1Call) << "Found too many D1 calls: " << *CI;
      D1Call = CI;
    } else {
      FAIL() << "Found an unexpected call instruction: " << *CI;
    }
  }
  ASSERT_NE(C1Call, nullptr);
  ASSERT_NE(D1Call, nullptr);
  ASSERT_EQ(&D2F, C1Call->getCalledFunction());
  ASSERT_EQ(&D2F, D1Call->getCalledFunction());
  C1Call->setCalledFunction(&D3.getFunction());
  D1Call->setCalledFunction(&D3.getFunction());
  ASSERT_EQ(0u, D2F.getNumUses());

  // Insert new edges first.
  CRC.insertTrivialCallEdge(C1, D3);
  DRC.insertTrivialCallEdge(D1, D3);

  // Then remove the old ones.
  LazyCallGraph::SCC &DC = *CG.lookupSCC(D2);
  auto NewCs = DRC.switchInternalEdgeToRef(D1, D2);
  EXPECT_EQ(&DC, CG.lookupSCC(D2));
  EXPECT_EQ(NewCs.end(), std::next(NewCs.begin()));
  LazyCallGraph::SCC &NewDC = *NewCs.begin();
  EXPECT_EQ(&NewDC, CG.lookupSCC(D1));
  EXPECT_EQ(&NewDC, CG.lookupSCC(D3));
  auto NewRCs = DRC.removeInternalRefEdge(D1, D2);
  EXPECT_EQ(&DRC, CG.lookupRefSCC(D2));
  EXPECT_EQ(NewRCs.end(), std::next(NewRCs.begin()));
  LazyCallGraph::RefSCC &NewDRC = **NewRCs.begin();
  EXPECT_EQ(&NewDRC, CG.lookupRefSCC(D1));
  EXPECT_EQ(&NewDRC, CG.lookupRefSCC(D3));
  EXPECT_FALSE(NewDRC.isParentOf(DRC));
  EXPECT_TRUE(CRC.isParentOf(DRC));
  EXPECT_TRUE(CRC.isParentOf(NewDRC));
  EXPECT_TRUE(DRC.isParentOf(NewDRC));
  CRC.removeOutgoingEdge(C1, D2);
  EXPECT_FALSE(CRC.isParentOf(DRC));
  EXPECT_TRUE(CRC.isParentOf(NewDRC));
  EXPECT_TRUE(DRC.isParentOf(NewDRC));

  // Now that we've updated the call graph, D2 is dead, so remove it.
  CG.removeDeadFunction(D2F);

  // Check that the graph still looks the same.
  EXPECT_EQ(&ARC, CG.lookupRefSCC(A1));
  EXPECT_EQ(&ARC, CG.lookupRefSCC(A2));
  EXPECT_EQ(&ARC, CG.lookupRefSCC(A3));
  EXPECT_EQ(&BRC, CG.lookupRefSCC(B1));
  EXPECT_EQ(&BRC, CG.lookupRefSCC(B2));
  EXPECT_EQ(&BRC, CG.lookupRefSCC(B3));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(C1));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(C2));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(C3));
  EXPECT_EQ(&NewDRC, CG.lookupRefSCC(D1));
  EXPECT_EQ(&NewDRC, CG.lookupRefSCC(D3));
  EXPECT_TRUE(CRC.isParentOf(NewDRC));

  // Verify the post-order walk hasn't changed.
  auto I = CG.postorder_ref_scc_begin(), E = CG.postorder_ref_scc_end();
  ASSERT_NE(I, E);
  EXPECT_EQ(&NewDRC, &*I) << "Actual RefSCC: " << *I;
  ASSERT_NE(++I, E);
  EXPECT_EQ(&CRC, &*I) << "Actual RefSCC: " << *I;
  ASSERT_NE(++I, E);
  EXPECT_EQ(&BRC, &*I) << "Actual RefSCC: " << *I;
  ASSERT_NE(++I, E);
  EXPECT_EQ(&ARC, &*I) << "Actual RefSCC: " << *I;
  EXPECT_EQ(++I, E);
}

TEST(LazyCallGraphTest, InlineAndDeleteFunctionMidTraversal) {
  LLVMContext Context;
  // This is the same fundamental test as the previous, but we perform it
  // having only partially walked the RefSCCs of the graph.
  //
  // The ascii diagram is repeated here for easy reference.
  //
  //         d1       |
  //        /  \      |
  //       d3--d2     |
  //      /     \     |
  //     b1     c1    |
  //   /  \    /  \   |
  //  b3--b2  c3--c2  |
  //       \  /       |
  //        a1        |
  //       /  \       |
  //      a3--a2      |
  //
  std::unique_ptr<Module> M = parseAssembly(Context, DiamondOfTriangles);
  LazyCallGraph CG(*M);

  // Walk the RefSCCs until we find the one containing 'c1'.
  auto I = CG.postorder_ref_scc_begin(), E = CG.postorder_ref_scc_end();
  ASSERT_NE(I, E);
  LazyCallGraph::RefSCC &DRC = *I;
  ASSERT_NE(&DRC, nullptr);
  ++I;
  ASSERT_NE(I, E);
  LazyCallGraph::RefSCC &CRC = *I;
  ASSERT_NE(&CRC, nullptr);

  ASSERT_EQ(nullptr, CG.lookup(lookupFunction(*M, "a1")));
  ASSERT_EQ(nullptr, CG.lookup(lookupFunction(*M, "a2")));
  ASSERT_EQ(nullptr, CG.lookup(lookupFunction(*M, "a3")));
  ASSERT_EQ(nullptr, CG.lookup(lookupFunction(*M, "b1")));
  ASSERT_EQ(nullptr, CG.lookup(lookupFunction(*M, "b2")));
  ASSERT_EQ(nullptr, CG.lookup(lookupFunction(*M, "b3")));
  LazyCallGraph::Node &C1 = *CG.lookup(lookupFunction(*M, "c1"));
  LazyCallGraph::Node &C2 = *CG.lookup(lookupFunction(*M, "c2"));
  LazyCallGraph::Node &C3 = *CG.lookup(lookupFunction(*M, "c3"));
  LazyCallGraph::Node &D1 = *CG.lookup(lookupFunction(*M, "d1"));
  LazyCallGraph::Node &D2 = *CG.lookup(lookupFunction(*M, "d2"));
  LazyCallGraph::Node &D3 = *CG.lookup(lookupFunction(*M, "d3"));
  ASSERT_EQ(&CRC, CG.lookupRefSCC(C1));
  ASSERT_EQ(&CRC, CG.lookupRefSCC(C2));
  ASSERT_EQ(&CRC, CG.lookupRefSCC(C3));
  ASSERT_EQ(&DRC, CG.lookupRefSCC(D1));
  ASSERT_EQ(&DRC, CG.lookupRefSCC(D2));
  ASSERT_EQ(&DRC, CG.lookupRefSCC(D3));
  ASSERT_EQ(1, std::distance(D2.begin(), D2.end()));

  // Delete d2 from the graph, as if it had been inlined.
  //
  //         d1         |
  //        / /         |
  //       d3--.        |
  //      /     \       |
  //     b1     c1      |
  //   /  \    /  \     |
  //  b3--b2  c3--c2    |
  //       \  /         |
  //        a1          |
  //       /  \         |
  //      a3--a2        |

  Function &D2F = D2.getFunction();
  CallInst *C1Call = nullptr, *D1Call = nullptr;
  for (User *U : D2F.users()) {
    CallInst *CI = dyn_cast<CallInst>(U);
    ASSERT_TRUE(CI) << "Expected a call: " << *U;
    if (CI->getParent()->getParent() == &C1.getFunction()) {
      ASSERT_EQ(nullptr, C1Call) << "Found too many C1 calls: " << *CI;
      C1Call = CI;
    } else if (CI->getParent()->getParent() == &D1.getFunction()) {
      ASSERT_EQ(nullptr, D1Call) << "Found too many D1 calls: " << *CI;
      D1Call = CI;
    } else {
      FAIL() << "Found an unexpected call instruction: " << *CI;
    }
  }
  ASSERT_NE(C1Call, nullptr);
  ASSERT_NE(D1Call, nullptr);
  ASSERT_EQ(&D2F, C1Call->getCalledFunction());
  ASSERT_EQ(&D2F, D1Call->getCalledFunction());
  C1Call->setCalledFunction(&D3.getFunction());
  D1Call->setCalledFunction(&D3.getFunction());
  ASSERT_EQ(0u, D2F.getNumUses());

  // Insert new edges first.
  CRC.insertTrivialCallEdge(C1, D3);
  DRC.insertTrivialCallEdge(D1, D3);

  // Then remove the old ones.
  LazyCallGraph::SCC &DC = *CG.lookupSCC(D2);
  auto NewCs = DRC.switchInternalEdgeToRef(D1, D2);
  EXPECT_EQ(&DC, CG.lookupSCC(D2));
  EXPECT_EQ(NewCs.end(), std::next(NewCs.begin()));
  LazyCallGraph::SCC &NewDC = *NewCs.begin();
  EXPECT_EQ(&NewDC, CG.lookupSCC(D1));
  EXPECT_EQ(&NewDC, CG.lookupSCC(D3));
  auto NewRCs = DRC.removeInternalRefEdge(D1, D2);
  EXPECT_EQ(&DRC, CG.lookupRefSCC(D2));
  EXPECT_EQ(NewRCs.end(), std::next(NewRCs.begin()));
  LazyCallGraph::RefSCC &NewDRC = **NewRCs.begin();
  EXPECT_EQ(&NewDRC, CG.lookupRefSCC(D1));
  EXPECT_EQ(&NewDRC, CG.lookupRefSCC(D3));
  EXPECT_FALSE(NewDRC.isParentOf(DRC));
  EXPECT_TRUE(CRC.isParentOf(DRC));
  EXPECT_TRUE(CRC.isParentOf(NewDRC));
  EXPECT_TRUE(DRC.isParentOf(NewDRC));
  CRC.removeOutgoingEdge(C1, D2);
  EXPECT_FALSE(CRC.isParentOf(DRC));
  EXPECT_TRUE(CRC.isParentOf(NewDRC));
  EXPECT_TRUE(DRC.isParentOf(NewDRC));

  // Now that we've updated the call graph, D2 is dead, so remove it.
  CG.removeDeadFunction(D2F);

  // Check that the graph still looks the same.
  EXPECT_EQ(&CRC, CG.lookupRefSCC(C1));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(C2));
  EXPECT_EQ(&CRC, CG.lookupRefSCC(C3));
  EXPECT_EQ(&NewDRC, CG.lookupRefSCC(D1));
  EXPECT_EQ(&NewDRC, CG.lookupRefSCC(D3));
  EXPECT_TRUE(CRC.isParentOf(NewDRC));

  // Verify that the post-order walk reflects the updated but still incomplete
  // structure.
  auto J = CG.postorder_ref_scc_begin();
  EXPECT_NE(J, E);
  EXPECT_EQ(&NewDRC, &*J) << "Actual RefSCC: " << *J;
  ++J;
  EXPECT_NE(J, E);
  EXPECT_EQ(&CRC, &*J) << "Actual RefSCC: " << *J;
  EXPECT_EQ(I, J);

  // Check that we can form the last two RefSCCs now, and even that we can do
  // it with alternating iterators.
  ++J;
  EXPECT_NE(J, E);
  LazyCallGraph::RefSCC &BRC = *J;
d737 1
a737 7
  EXPECT_TRUE(BRC.isParentOf(NewDRC));
  ++I;
  EXPECT_EQ(J, I);
  EXPECT_EQ(&BRC, &*I) << "Actual RefSCC: " << *I;

  // Increment I this time to form the new RefSCC, flopping back to the first
  // iterator.
a744 1
  EXPECT_TRUE(ARC.isParentOf(BRC));
a745 3
  ++J;
  EXPECT_EQ(I, J);
  EXPECT_EQ(&ARC, &*J) << "Actual RefSCC: " << *J;
a747 2
  ++J;
  EXPECT_EQ(E, J);
d799 1
a799 1
  auto NewCs = RC.switchInternalEdgeToRef(B, C);
a810 4
  // And the returned range must be the slice of this sequence containing new
  // SCCs.
  EXPECT_EQ(RC.begin(), NewCs.begin());
  EXPECT_EQ(std::prev(RC.end()), NewCs.end());
d858 3
a860 3
  auto I = CG.postorder_ref_scc_begin(), E = CG.postorder_ref_scc_end();
  LazyCallGraph::RefSCC &RC = *I;
  EXPECT_EQ(E, std::next(I));
a876 4
  auto J = CG.postorder_ref_scc_begin();
  EXPECT_EQ(I, J);
  EXPECT_EQ(&RC, &*J);
  EXPECT_EQ(E, std::next(J));
d884 3
a886 91
  LazyCallGraph::RefSCC &RC2 = *CG.lookupRefSCC(B);
  EXPECT_EQ(&RC2, CG.lookupRefSCC(C));
  EXPECT_EQ(&RC2, NewRCs[0]);
  J = CG.postorder_ref_scc_begin();
  EXPECT_NE(I, J);
  EXPECT_EQ(&RC2, &*J);
  ++J;
  EXPECT_EQ(I, J);
  EXPECT_EQ(&RC, &*J);
  ++I;
  EXPECT_EQ(E, I);
  ++J;
  EXPECT_EQ(E, J);
}

TEST(LazyCallGraphTest, InternalNoOpEdgeRemoval) {
  LLVMContext Context;
  // A graph with a single cycle formed both from call and reference edges
  // which makes the reference edges trivial to delete. The graph looks like:
  //
  // Reference edges: a -> b -> c -> a
  //      Call edges: a -> c -> b -> a
  std::unique_ptr<Module> M = parseAssembly(
      Context, "define void @@a(i8** %ptr) {\n"
               "entry:\n"
               "  call void @@b(i8** %ptr)\n"
               "  store i8* bitcast (void(i8**)* @@c to i8*), i8** %ptr\n"
               "  ret void\n"
               "}\n"
               "define void @@b(i8** %ptr) {\n"
               "entry:\n"
               "  store i8* bitcast (void(i8**)* @@a to i8*), i8** %ptr\n"
               "  call void @@c(i8** %ptr)\n"
               "  ret void\n"
               "}\n"
               "define void @@c(i8** %ptr) {\n"
               "entry:\n"
               "  call void @@a(i8** %ptr)\n"
               "  store i8* bitcast (void(i8**)* @@b to i8*), i8** %ptr\n"
               "  ret void\n"
               "}\n");
  LazyCallGraph CG(*M);

  // Force the graph to be fully expanded.
  auto I = CG.postorder_ref_scc_begin(), E = CG.postorder_ref_scc_end();
  LazyCallGraph::RefSCC &RC = *I;
  EXPECT_EQ(E, std::next(I));

  LazyCallGraph::SCC &C = *RC.begin();
  EXPECT_EQ(RC.end(), std::next(RC.begin()));

  LazyCallGraph::Node &AN = *CG.lookup(lookupFunction(*M, "a"));
  LazyCallGraph::Node &BN = *CG.lookup(lookupFunction(*M, "b"));
  LazyCallGraph::Node &CN = *CG.lookup(lookupFunction(*M, "c"));
  EXPECT_EQ(&RC, CG.lookupRefSCC(AN));
  EXPECT_EQ(&RC, CG.lookupRefSCC(BN));
  EXPECT_EQ(&RC, CG.lookupRefSCC(CN));
  EXPECT_EQ(&C, CG.lookupSCC(AN));
  EXPECT_EQ(&C, CG.lookupSCC(BN));
  EXPECT_EQ(&C, CG.lookupSCC(CN));

  // Remove the edge from a -> c which doesn't change anything.
  SmallVector<LazyCallGraph::RefSCC *, 1> NewRCs =
      RC.removeInternalRefEdge(AN, CN);
  EXPECT_EQ(0u, NewRCs.size());
  EXPECT_EQ(&RC, CG.lookupRefSCC(AN));
  EXPECT_EQ(&RC, CG.lookupRefSCC(BN));
  EXPECT_EQ(&RC, CG.lookupRefSCC(CN));
  EXPECT_EQ(&C, CG.lookupSCC(AN));
  EXPECT_EQ(&C, CG.lookupSCC(BN));
  EXPECT_EQ(&C, CG.lookupSCC(CN));
  auto J = CG.postorder_ref_scc_begin();
  EXPECT_EQ(I, J);
  EXPECT_EQ(&RC, &*J);
  EXPECT_EQ(E, std::next(J));

  // Remove the edge from b -> a and c -> b; again this doesn't change
  // anything.
  NewRCs = RC.removeInternalRefEdge(BN, AN);
  NewRCs = RC.removeInternalRefEdge(CN, BN);
  EXPECT_EQ(0u, NewRCs.size());
  EXPECT_EQ(&RC, CG.lookupRefSCC(AN));
  EXPECT_EQ(&RC, CG.lookupRefSCC(BN));
  EXPECT_EQ(&RC, CG.lookupRefSCC(CN));
  EXPECT_EQ(&C, CG.lookupSCC(AN));
  EXPECT_EQ(&C, CG.lookupSCC(BN));
  EXPECT_EQ(&C, CG.lookupSCC(CN));
  J = CG.postorder_ref_scc_begin();
  EXPECT_EQ(I, J);
  EXPECT_EQ(&RC, &*J);
  EXPECT_EQ(E, std::next(J));
d921 1
a921 1
  LazyCallGraph::SCC &AC = *RC.begin();
d923 6
a928 6
  LazyCallGraph::Node &AN = *CG.lookup(lookupFunction(*M, "a"));
  LazyCallGraph::Node &BN = *CG.lookup(lookupFunction(*M, "b"));
  LazyCallGraph::Node &CN = *CG.lookup(lookupFunction(*M, "c"));
  EXPECT_EQ(&AC, CG.lookupSCC(AN));
  EXPECT_EQ(&AC, CG.lookupSCC(BN));
  EXPECT_EQ(&AC, CG.lookupSCC(CN));
d933 1
a933 2
  auto NewCs = RC.switchInternalEdgeToRef(BN, AN);
  EXPECT_EQ(NewCs.begin(), NewCs.end());
d935 3
a937 3
  EXPECT_EQ(&AC, CG.lookupSCC(AN));
  EXPECT_EQ(&AC, CG.lookupSCC(BN));
  EXPECT_EQ(&AC, CG.lookupSCC(CN));
d941 1
a941 2
  NewCs = RC.switchInternalEdgeToRef(CN, AN);
  EXPECT_EQ(1, std::distance(NewCs.begin(), NewCs.end()));
d943 6
a948 6
  EXPECT_EQ(&AC, CG.lookupSCC(AN));
  LazyCallGraph::SCC &BC = *CG.lookupSCC(BN);
  EXPECT_NE(&BC, &AC);
  EXPECT_EQ(&BC, CG.lookupSCC(CN));
  auto J = RC.find(AC);
  EXPECT_EQ(&AC, &*J);
d950 1
a950 1
  EXPECT_EQ(&BC, &*J);
a951 1
  EXPECT_EQ(J, NewCs.begin());
d955 1
a955 2
  NewCs = RC.switchInternalEdgeToRef(CN, BN);
  EXPECT_EQ(1, std::distance(NewCs.begin(), NewCs.end()));
d957 7
a963 7
  EXPECT_EQ(&AC, CG.lookupSCC(AN));
  EXPECT_EQ(&BC, CG.lookupSCC(BN));
  LazyCallGraph::SCC &CC = *CG.lookupSCC(CN);
  EXPECT_NE(&CC, &AC);
  EXPECT_NE(&CC, &BC);
  J = RC.find(AC);
  EXPECT_EQ(&AC, &*J);
d965 1
a965 1
  EXPECT_EQ(&BC, &*J);
d967 1
a967 1
  EXPECT_EQ(&CC, &*J);
a968 1
  EXPECT_EQ(J, NewCs.begin());
d1138 5
a1142 5
  RC.switchTrivialInternalEdgeToRef(B3, C3);
  RC.switchTrivialInternalEdgeToRef(C2, B3);
  RC.switchTrivialInternalEdgeToRef(B2, C2);
  RC.switchTrivialInternalEdgeToRef(C1, B2);
  RC.switchTrivialInternalEdgeToRef(B1, C1);
d1265 2
a1266 2
  RC.switchTrivialInternalEdgeToRef(C, D);
  RC.switchTrivialInternalEdgeToRef(D, E);
a1302 31
}

// Test for IR containing constants using blockaddress constant expressions.
// These are truly unique constructs: constant expressions with non-constant
// operands.
TEST(LazyCallGraphTest, HandleBlockAddress) {
  LLVMContext Context;
  std::unique_ptr<Module> M =
      parseAssembly(Context, "define void @@f() {\n"
                             "entry:\n"
                             "  ret void\n"
                             "bb:\n"
                             "  unreachable\n"
                             "}\n"
                             "define void @@g(i8** %ptr) {\n"
                             "entry:\n"
                             "  store i8* blockaddress(@@f, %bb), i8** %ptr\n"
                             "  ret void\n"
                             "}\n");
  LazyCallGraph CG(*M);

  auto I = CG.postorder_ref_scc_begin();
  LazyCallGraph::RefSCC &FRC = *I++;
  LazyCallGraph::RefSCC &GRC = *I++;
  EXPECT_EQ(CG.postorder_ref_scc_end(), I);

  LazyCallGraph::Node &F = *CG.lookup(lookupFunction(*M, "f"));
  LazyCallGraph::Node &G = *CG.lookup(lookupFunction(*M, "g"));
  EXPECT_EQ(&FRC, CG.lookupRefSCC(F));
  EXPECT_EQ(&GRC, CG.lookupRefSCC(G));
  EXPECT_TRUE(GRC.isParentOf(FRC));
@


1.1.1.4
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@d12 1
a13 1
#include "llvm/IR/Instructions.h"
a218 7
static LazyCallGraph buildCG(Module &M) {
  TargetLibraryInfoImpl TLII(Triple(M.getTargetTriple()));
  TargetLibraryInfo TLI(TLII);
  LazyCallGraph CG(M, TLI);
  return CG;
}

d222 1
a222 1
  LazyCallGraph CG = buildCG(*M);
d228 1
a228 1
  LazyCallGraph::Node &A1 = (I++)->getNode();
d230 1
a230 1
  LazyCallGraph::Node &A2 = (I++)->getNode();
d232 1
a232 1
  LazyCallGraph::Node &A3 = (I++)->getNode();
d234 1
a234 1
  LazyCallGraph::Node &B1 = (I++)->getNode();
d236 1
a236 1
  LazyCallGraph::Node &B2 = (I++)->getNode();
d238 1
a238 1
  LazyCallGraph::Node &B3 = (I++)->getNode();
d240 1
a240 1
  LazyCallGraph::Node &C1 = (I++)->getNode();
d242 1
a242 1
  LazyCallGraph::Node &C2 = (I++)->getNode();
d244 1
a244 1
  LazyCallGraph::Node &C3 = (I++)->getNode();
d246 1
a246 1
  LazyCallGraph::Node &D1 = (I++)->getNode();
d248 1
a248 1
  LazyCallGraph::Node &D2 = (I++)->getNode();
d250 1
a250 1
  LazyCallGraph::Node &D3 = (I++)->getNode();
d258 1
a258 1
  for (LazyCallGraph::Edge &E : A1.populate())
d266 4
a269 6
  A2.populate();
  EXPECT_EQ(A2->end(), std::next(A2->begin()));
  EXPECT_EQ("a3", A2->begin()->getFunction().getName());
  A3.populate();
  EXPECT_EQ(A3->end(), std::next(A3->begin()));
  EXPECT_EQ("a1", A3->begin()->getFunction().getName());
d271 1
a271 1
  for (LazyCallGraph::Edge &E : B1.populate())
d278 4
a281 6
  B2.populate();
  EXPECT_EQ(B2->end(), std::next(B2->begin()));
  EXPECT_EQ("b3", B2->begin()->getFunction().getName());
  B3.populate();
  EXPECT_EQ(B3->end(), std::next(B3->begin()));
  EXPECT_EQ("b1", B3->begin()->getFunction().getName());
d283 1
a283 1
  for (LazyCallGraph::Edge &E : C1.populate())
d290 11
a300 16
  C2.populate();
  EXPECT_EQ(C2->end(), std::next(C2->begin()));
  EXPECT_EQ("c3", C2->begin()->getFunction().getName());
  C3.populate();
  EXPECT_EQ(C3->end(), std::next(C3->begin()));
  EXPECT_EQ("c1", C3->begin()->getFunction().getName());

  D1.populate();
  EXPECT_EQ(D1->end(), std::next(D1->begin()));
  EXPECT_EQ("d2", D1->begin()->getFunction().getName());
  D2.populate();
  EXPECT_EQ(D2->end(), std::next(D2->begin()));
  EXPECT_EQ("d3", D2->begin()->getFunction().getName());
  D3.populate();
  EXPECT_EQ(D3->end(), std::next(D3->begin()));
  EXPECT_EQ("d1", D3->begin()->getFunction().getName());
a302 1
  CG.buildRefSCCs();
d400 1
a400 1
  LazyCallGraph CG = buildCG(*M);
d404 2
a405 23
  A.populate();
  EXPECT_EQ(2, std::distance(A->begin(), A->end()));
  B.populate();
  EXPECT_EQ(0, std::distance(B->begin(), B->end()));

  LazyCallGraph::Node &C = CG.get(lookupFunction(*M, "c"));
  C.populate();
  CG.insertEdge(B, C, LazyCallGraph::Edge::Call);
  EXPECT_EQ(1, std::distance(B->begin(), B->end()));
  EXPECT_EQ(0, std::distance(C->begin(), C->end()));

  CG.insertEdge(C, B, LazyCallGraph::Edge::Call);
  EXPECT_EQ(1, std::distance(C->begin(), C->end()));
  EXPECT_EQ(&B, &C->begin()->getNode());

  CG.insertEdge(C, C, LazyCallGraph::Edge::Call);
  EXPECT_EQ(2, std::distance(C->begin(), C->end()));
  EXPECT_EQ(&B, &C->begin()->getNode());
  EXPECT_EQ(&C, &std::next(C->begin())->getNode());

  CG.removeEdge(C, B);
  EXPECT_EQ(1, std::distance(C->begin(), C->end()));
  EXPECT_EQ(&C, &C->begin()->getNode());
d407 17
a423 2
  CG.removeEdge(C, C);
  EXPECT_EQ(0, std::distance(C->begin(), C->end()));
d425 5
a429 2
  CG.removeEdge(B, C);
  EXPECT_EQ(0, std::distance(B->begin(), B->end()));
d435 1
a435 1
  LazyCallGraph CG = buildCG(*M);
d439 2
a440 5
  LazyCallGraph::Node &D1 = CG.get(lookupFunction(*M, "d1"));
  LazyCallGraph::Node &A1 = CG.get(lookupFunction(*M, "a1"));
  A1.populate();
  D1.populate();
  CG.insertEdge(D1, A1, LazyCallGraph::Edge::Ref);
a446 1
  CG.buildRefSCCs();
d528 1
a528 1
  LazyCallGraph CG = buildCG(*M);
a530 1
  CG.buildRefSCCs();
d578 1
a578 1
  LazyCallGraph CG = buildCG(*M);
a580 1
  CG.buildRefSCCs();
d613 1
a613 1
  EXPECT_EQ(2, std::distance(A->begin(), A->end()));
d615 2
a616 2
  EXPECT_EQ(3, std::distance(A->begin(), A->end()));
  const LazyCallGraph::Edge &NewE = (*A)[D];
d619 1
a619 1
  EXPECT_EQ(&D, &NewE.getNode());
d683 1
a683 1
  EXPECT_EQ(2, std::distance(A->begin(), A->end()));
d723 1
a723 1
  LazyCallGraph CG = buildCG(*M);
a725 1
  CG.buildRefSCCs();
d753 1
a753 1
  ASSERT_EQ(1, std::distance(D2->begin(), D2->end()));
d770 2
a771 2
  for (LazyCallGraph::Edge E : *D2) {
    if (&E.getNode() == &D3)
d773 1
a773 1
    EXPECT_EQ(&C2, &E.getNode());
d808 96
d910 1
a910 1
  LazyCallGraph CG = buildCG(*M);
a912 1
  CG.buildRefSCCs();
d940 1
a940 1
  ASSERT_EQ(1, std::distance(D2->begin(), D2->end()));
d957 2
a958 2
  for (LazyCallGraph::Edge E : *D2) {
    if (&E.getNode() == &D3)
d960 1
a960 1
    EXPECT_EQ(&C2, &E.getNode());
d1016 1
a1016 1
  LazyCallGraph CG = buildCG(*M);
a1018 1
  CG.buildRefSCCs();
d1038 2
a1039 2
  EXPECT_NE(D->begin(), D->end());
  EXPECT_EQ(&A, &D->begin()->getNode());
d1092 1
a1092 1
  LazyCallGraph CG = buildCG(*M);
a1094 1
  CG.buildRefSCCs();
d1111 2
a1112 2
  EXPECT_NE(D->begin(), D->end());
  EXPECT_EQ(&A, &D->begin()->getNode());
d1153 1
a1153 1
  LazyCallGraph CG = buildCG(*M);
a1155 1
  CG.buildRefSCCs();
d1183 1
a1183 1
  ASSERT_EQ(1, std::distance(D2->begin(), D2->end()));
d1279 171
d1467 1
a1467 1
  LazyCallGraph CG = buildCG(*M);
a1469 1
  CG.buildRefSCCs();
d1487 1
a1487 1
  EXPECT_EQ(2, std::distance(A->begin(), A->end()));
d1522 3
a1524 4
  EXPECT_TRUE(RC.switchInternalEdgeToCall(A, C, [&](ArrayRef<LazyCallGraph::SCC *> MergedCs) {
    ASSERT_EQ(1u, MergedCs.size());
    EXPECT_EQ(&AC, MergedCs[0]);
  }));
d1559 1
a1559 1
  LazyCallGraph CG = buildCG(*M);
a1561 1
  CG.buildRefSCCs();
d1633 1
a1633 1
  LazyCallGraph CG = buildCG(*M);
a1635 1
  CG.buildRefSCCs();
d1709 1
a1709 1
  LazyCallGraph CG = buildCG(*M);
a1711 1
  CG.buildRefSCCs();
d1801 1
a1801 1
  LazyCallGraph CG = buildCG(*M);
a1803 1
  CG.buildRefSCCs();
d1827 2
a1828 1
  EXPECT_FALSE(RC.switchInternalEdgeToCall(A, D));
d1837 2
a1838 1
  EXPECT_FALSE(RC.switchInternalEdgeToCall(B, C));
d1846 3
a1848 4
  EXPECT_TRUE(RC.switchInternalEdgeToCall(C, B, [&](ArrayRef<LazyCallGraph::SCC *> MergedCs) {
    ASSERT_EQ(1u, MergedCs.size());
    EXPECT_EQ(&CC, MergedCs[0]);
  }));
d1913 1
a1913 1
  LazyCallGraph CG = buildCG(*M);
a1915 1
  CG.buildRefSCCs();
d1960 2
a1961 1
  EXPECT_FALSE(RC.switchInternalEdgeToCall(C3, B1));
d2043 1
a2043 1
  LazyCallGraph CG = buildCG(*M);
a2045 1
  CG.buildRefSCCs();
d2091 4
a2094 6
  EXPECT_TRUE(RC.switchInternalEdgeToCall(
      F, B, [&](ArrayRef<LazyCallGraph::SCC *> MergedCs) {
        ASSERT_EQ(2u, MergedCs.size());
        EXPECT_EQ(&FC, MergedCs[0]);
        EXPECT_EQ(&DC, MergedCs[1]);
      }));
d2123 1
a2123 1
  LazyCallGraph CG = buildCG(*M);
a2124 1
  CG.buildRefSCCs();
a2136 161
TEST(LazyCallGraphTest, ReplaceNodeFunction) {
  LLVMContext Context;
  // A graph with several different kinds of edges pointing at a particular
  // function.
  std::unique_ptr<Module> M =
      parseAssembly(Context,
                    "define void @@a(i8** %ptr) {\n"
                    "entry:\n"
                    "  store i8* bitcast (void(i8**)* @@d to i8*), i8** %ptr\n"
                    "  ret void\n"
                    "}\n"
                    "define void @@b(i8** %ptr) {\n"
                    "entry:\n"
                    "  store i8* bitcast (void(i8**)* @@d to i8*), i8** %ptr\n"
                    "  store i8* bitcast (void(i8**)* @@d to i8*), i8** %ptr\n"
                    "  call void @@d(i8** %ptr)"
                    "  ret void\n"
                    "}\n"
                    "define void @@c(i8** %ptr) {\n"
                    "entry:\n"
                    "  call void @@d(i8** %ptr)"
                    "  call void @@d(i8** %ptr)"
                    "  store i8* bitcast (void(i8**)* @@d to i8*), i8** %ptr\n"
                    "  ret void\n"
                    "}\n"
                    "define void @@d(i8** %ptr) {\n"
                    "entry:\n"
                    "  store i8* bitcast (void(i8**)* @@b to i8*), i8** %ptr\n"
                    "  call void @@c(i8** %ptr)"
                    "  call void @@d(i8** %ptr)"
                    "  store i8* bitcast (void(i8**)* @@d to i8*), i8** %ptr\n"
                    "  ret void\n"
                    "}\n");
  LazyCallGraph CG = buildCG(*M);

  // Force the graph to be fully expanded.
  CG.buildRefSCCs();
  auto I = CG.postorder_ref_scc_begin();
  LazyCallGraph::RefSCC &RC1 = *I++;
  LazyCallGraph::RefSCC &RC2 = *I++;
  EXPECT_EQ(CG.postorder_ref_scc_end(), I);

  ASSERT_EQ(2, RC1.size());
  LazyCallGraph::SCC &C1 = RC1[0];
  LazyCallGraph::SCC &C2 = RC1[1];

  LazyCallGraph::Node &AN = *CG.lookup(lookupFunction(*M, "a"));
  LazyCallGraph::Node &BN = *CG.lookup(lookupFunction(*M, "b"));
  LazyCallGraph::Node &CN = *CG.lookup(lookupFunction(*M, "c"));
  LazyCallGraph::Node &DN = *CG.lookup(lookupFunction(*M, "d"));
  EXPECT_EQ(&C1, CG.lookupSCC(DN));
  EXPECT_EQ(&C1, CG.lookupSCC(CN));
  EXPECT_EQ(&C2, CG.lookupSCC(BN));
  EXPECT_EQ(&RC1, CG.lookupRefSCC(DN));
  EXPECT_EQ(&RC1, CG.lookupRefSCC(CN));
  EXPECT_EQ(&RC1, CG.lookupRefSCC(BN));
  EXPECT_EQ(&RC2, CG.lookupRefSCC(AN));

  // Now we need to build a new function 'e' with the same signature as 'd'.
  Function &D = DN.getFunction();
  Function &E = *Function::Create(D.getFunctionType(), D.getLinkage(), "e");
  D.getParent()->getFunctionList().insert(D.getIterator(), &E);

  // Change each use of 'd' to use 'e'. This is particularly easy as they have
  // the same type.
  D.replaceAllUsesWith(&E);

  // Splice the body of the old function into the new one.
  E.getBasicBlockList().splice(E.begin(), D.getBasicBlockList());
  // And fix up the one argument.
  D.arg_begin()->replaceAllUsesWith(&*E.arg_begin());
  E.arg_begin()->takeName(&*D.arg_begin());

  // Now replace the function in the graph.
  RC1.replaceNodeFunction(DN, E);

  EXPECT_EQ(&E, &DN.getFunction());
  EXPECT_EQ(&DN, &(*CN)[DN].getNode());
  EXPECT_EQ(&DN, &(*BN)[DN].getNode());
}

TEST(LazyCallGraphTest, RemoveFunctionWithSpurriousRef) {
  LLVMContext Context;
  // A graph with a couple of RefSCCs.
  std::unique_ptr<Module> M =
      parseAssembly(Context,
                    "define void @@a(i8** %ptr) {\n"
                    "entry:\n"
                    "  store i8* bitcast (void(i8**)* @@d to i8*), i8** %ptr\n"
                    "  ret void\n"
                    "}\n"
                    "define void @@b(i8** %ptr) {\n"
                    "entry:\n"
                    "  store i8* bitcast (void(i8**)* @@c to i8*), i8** %ptr\n"
                    "  ret void\n"
                    "}\n"
                    "define void @@c(i8** %ptr) {\n"
                    "entry:\n"
                    "  call void @@d(i8** %ptr)"
                    "  ret void\n"
                    "}\n"
                    "define void @@d(i8** %ptr) {\n"
                    "entry:\n"
                    "  call void @@c(i8** %ptr)"
                    "  store i8* bitcast (void(i8**)* @@b to i8*), i8** %ptr\n"
                    "  ret void\n"
                    "}\n"
                    "define void @@dead() {\n"
                    "entry:\n"
                    "  ret void\n"
                    "}\n");
  LazyCallGraph CG = buildCG(*M);

  // Insert spurious ref edges.
  LazyCallGraph::Node &AN = CG.get(lookupFunction(*M, "a"));
  LazyCallGraph::Node &BN = CG.get(lookupFunction(*M, "b"));
  LazyCallGraph::Node &CN = CG.get(lookupFunction(*M, "c"));
  LazyCallGraph::Node &DN = CG.get(lookupFunction(*M, "d"));
  LazyCallGraph::Node &DeadN = CG.get(lookupFunction(*M, "dead"));
  AN.populate();
  BN.populate();
  CN.populate();
  DN.populate();
  DeadN.populate();
  CG.insertEdge(AN, DeadN, LazyCallGraph::Edge::Ref);
  CG.insertEdge(BN, DeadN, LazyCallGraph::Edge::Ref);
  CG.insertEdge(CN, DeadN, LazyCallGraph::Edge::Ref);
  CG.insertEdge(DN, DeadN, LazyCallGraph::Edge::Ref);

  // Force the graph to be fully expanded.
  CG.buildRefSCCs();
  auto I = CG.postorder_ref_scc_begin();
  LazyCallGraph::RefSCC &DeadRC = *I++;
  LazyCallGraph::RefSCC &RC1 = *I++;
  LazyCallGraph::RefSCC &RC2 = *I++;
  EXPECT_EQ(CG.postorder_ref_scc_end(), I);

  ASSERT_EQ(2, RC1.size());
  LazyCallGraph::SCC &C1 = RC1[0];
  LazyCallGraph::SCC &C2 = RC1[1];

  EXPECT_EQ(&DeadRC, CG.lookupRefSCC(DeadN));
  EXPECT_EQ(&C1, CG.lookupSCC(DN));
  EXPECT_EQ(&C1, CG.lookupSCC(CN));
  EXPECT_EQ(&C2, CG.lookupSCC(BN));
  EXPECT_EQ(&RC1, CG.lookupRefSCC(DN));
  EXPECT_EQ(&RC1, CG.lookupRefSCC(CN));
  EXPECT_EQ(&RC1, CG.lookupRefSCC(BN));
  EXPECT_EQ(&RC2, CG.lookupRefSCC(AN));

  // Now delete 'dead'. There are no uses of this function but there are
  // spurious references.
  CG.removeDeadFunction(DeadN.getFunction());

  // The only observable change should be that the RefSCC is gone from the
  // postorder sequence.
  I = CG.postorder_ref_scc_begin();
  EXPECT_EQ(&RC1, &*I++);
  EXPECT_EQ(&RC2, &*I++);
  EXPECT_EQ(CG.postorder_ref_scc_end(), I);
}
@


