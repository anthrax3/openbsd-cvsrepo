head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.2.0.2
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.1
date	2017.01.14.19.55.44;	author patrick;	state Exp;
branches
	1.1.1.1;
next	;
commitid	qMUxATnKgqN83Oct;

1.1.1.1
date	2017.01.14.19.55.44;	author patrick;	state Exp;
branches;
next	1.1.1.2;
commitid	qMUxATnKgqN83Oct;

1.1.1.2
date	2017.01.24.08.33.21;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===- llvm/unittest/DebugInfo/PDB/MappedBlockStreamTest.cpp --------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "ErrorChecking.h"

#include "llvm/DebugInfo/CodeView/ByteStream.h"
#include "llvm/DebugInfo/CodeView/StreamReader.h"
#include "llvm/DebugInfo/CodeView/StreamRef.h"
#include "llvm/DebugInfo/CodeView/StreamWriter.h"
#include "llvm/DebugInfo/PDB/Raw/IPDBFile.h"
#include "llvm/DebugInfo/PDB/Raw/IPDBStreamData.h"
#include "llvm/DebugInfo/PDB/Raw/IndexedStreamData.h"
#include "llvm/DebugInfo/PDB/Raw/MappedBlockStream.h"
#include "gtest/gtest.h"

#include <unordered_map>

using namespace llvm;
using namespace llvm::codeview;
using namespace llvm::pdb;

namespace {

static const uint32_t BlocksAry[] = {0, 1, 2, 5, 4, 3, 6, 7, 8, 9};
static uint8_t DataAry[] = {'A', 'B', 'C', 'F', 'E', 'D', 'G', 'H', 'I', 'J'};

class DiscontiguousFile : public IPDBFile {
public:
  DiscontiguousFile(ArrayRef<uint32_t> Blocks, MutableArrayRef<uint8_t> Data)
      : Blocks(Blocks.begin(), Blocks.end()), Data(Data.begin(), Data.end()) {}

  uint32_t getBlockSize() const override { return 1; }
  uint32_t getBlockCount() const override { return Blocks.size(); }
  uint32_t getNumStreams() const override { return 1; }
  uint32_t getStreamByteSize(uint32_t StreamIndex) const override {
    return getBlockCount() * getBlockSize();
  }
  ArrayRef<support::ulittle32_t>
  getStreamBlockList(uint32_t StreamIndex) const override {
    if (StreamIndex != 0)
      return ArrayRef<support::ulittle32_t>();
    return Blocks;
  }
  Expected<ArrayRef<uint8_t>> getBlockData(uint32_t BlockIndex,
                                           uint32_t NumBytes) const override {
    return ArrayRef<uint8_t>(&Data[BlockIndex], NumBytes);
  }

  Error setBlockData(uint32_t BlockIndex, uint32_t Offset,
                     ArrayRef<uint8_t> SrcData) const override {
    if (BlockIndex >= Blocks.size())
      return make_error<CodeViewError>(cv_error_code::insufficient_buffer);
    if (Offset > getBlockSize() - SrcData.size())
      return make_error<CodeViewError>(cv_error_code::insufficient_buffer);
    ::memcpy(&Data[BlockIndex] + Offset, SrcData.data(), SrcData.size());
    return Error::success();
  }

private:
  std::vector<support::ulittle32_t> Blocks;
  MutableArrayRef<uint8_t> Data;
};

class MappedBlockStreamImpl : public MappedBlockStream {
public:
  MappedBlockStreamImpl(std::unique_ptr<IPDBStreamData> Data,
                        const IPDBFile &File)
      : MappedBlockStream(std::move(Data), File) {}
};

// Tests that a read which is entirely contained within a single block works
// and does not allocate.
TEST(MappedBlockStreamTest, ReadBeyondEndOfStreamRef) {
  DiscontiguousFile F(BlocksAry, DataAry);
  MappedBlockStreamImpl S(llvm::make_unique<IndexedStreamData>(0, F), F);
  StreamReader R(S);
  StreamRef SR;
  EXPECT_NO_ERROR(R.readStreamRef(SR, 0U));
  ArrayRef<uint8_t> Buffer;
  EXPECT_ERROR(SR.readBytes(0U, 1U, Buffer));
  EXPECT_NO_ERROR(R.readStreamRef(SR, 1U));
  EXPECT_ERROR(SR.readBytes(1U, 1U, Buffer));
}

// Tests that a read which outputs into a full destination buffer works and
// does not fail due to the length of the output buffer.
TEST(MappedBlockStreamTest, ReadOntoNonEmptyBuffer) {
  DiscontiguousFile F(BlocksAry, DataAry);
  MappedBlockStreamImpl S(llvm::make_unique<IndexedStreamData>(0, F), F);
  StreamReader R(S);
  StringRef Str = "ZYXWVUTSRQPONMLKJIHGFEDCBA";
  EXPECT_NO_ERROR(R.readFixedString(Str, 1));
  EXPECT_EQ(Str, StringRef("A"));
  EXPECT_EQ(0U, S.getNumBytesCopied());
}

// Tests that a read which crosses a block boundary, but where the subsequent
// blocks are still contiguous in memory to the previous block works and does
// not allocate memory.
TEST(MappedBlockStreamTest, ZeroCopyReadContiguousBreak) {
  DiscontiguousFile F(BlocksAry, DataAry);
  MappedBlockStreamImpl S(llvm::make_unique<IndexedStreamData>(0, F), F);
  StreamReader R(S);
  StringRef Str;
  EXPECT_NO_ERROR(R.readFixedString(Str, 2));
  EXPECT_EQ(Str, StringRef("AB"));
  EXPECT_EQ(0U, S.getNumBytesCopied());

  R.setOffset(6);
  EXPECT_NO_ERROR(R.readFixedString(Str, 4));
  EXPECT_EQ(Str, StringRef("GHIJ"));
  EXPECT_EQ(0U, S.getNumBytesCopied());
}

// Tests that a read which crosses a block boundary and cannot be referenced
// contiguously works and allocates only the precise amount of bytes
// requested.
TEST(MappedBlockStreamTest, CopyReadNonContiguousBreak) {
  DiscontiguousFile F(BlocksAry, DataAry);
  MappedBlockStreamImpl S(llvm::make_unique<IndexedStreamData>(0, F), F);
  StreamReader R(S);
  StringRef Str;
  EXPECT_NO_ERROR(R.readFixedString(Str, 10));
  EXPECT_EQ(Str, StringRef("ABCDEFGHIJ"));
  EXPECT_EQ(10U, S.getNumBytesCopied());
}

// Test that an out of bounds read which doesn't cross a block boundary
// fails and allocates no memory.
TEST(MappedBlockStreamTest, InvalidReadSizeNoBreak) {
  DiscontiguousFile F(BlocksAry, DataAry);
  MappedBlockStreamImpl S(llvm::make_unique<IndexedStreamData>(0, F), F);
  StreamReader R(S);
  StringRef Str;

  R.setOffset(10);
  EXPECT_ERROR(R.readFixedString(Str, 1));
  EXPECT_EQ(0U, S.getNumBytesCopied());
}

// Test that an out of bounds read which crosses a contiguous block boundary
// fails and allocates no memory.
TEST(MappedBlockStreamTest, InvalidReadSizeContiguousBreak) {
  DiscontiguousFile F(BlocksAry, DataAry);
  MappedBlockStreamImpl S(llvm::make_unique<IndexedStreamData>(0, F), F);
  StreamReader R(S);
  StringRef Str;

  R.setOffset(6);
  EXPECT_ERROR(R.readFixedString(Str, 5));
  EXPECT_EQ(0U, S.getNumBytesCopied());
}

// Test that an out of bounds read which crosses a discontiguous block
// boundary fails and allocates no memory.
TEST(MappedBlockStreamTest, InvalidReadSizeNonContiguousBreak) {
  DiscontiguousFile F(BlocksAry, DataAry);
  MappedBlockStreamImpl S(llvm::make_unique<IndexedStreamData>(0, F), F);
  StreamReader R(S);
  StringRef Str;

  EXPECT_ERROR(R.readFixedString(Str, 11));
  EXPECT_EQ(0U, S.getNumBytesCopied());
}

// Tests that a read which is entirely contained within a single block but
// beyond the end of a StreamRef fails.
TEST(MappedBlockStreamTest, ZeroCopyReadNoBreak) {
  DiscontiguousFile F(BlocksAry, DataAry);
  MappedBlockStreamImpl S(llvm::make_unique<IndexedStreamData>(0, F), F);
  StreamReader R(S);
  StringRef Str;
  EXPECT_NO_ERROR(R.readFixedString(Str, 1));
  EXPECT_EQ(Str, StringRef("A"));
  EXPECT_EQ(0U, S.getNumBytesCopied());
}

// Tests that a read which is not aligned on the same boundary as a previous
// cached request, but which is known to overlap that request, shares the
// previous allocation.
TEST(MappedBlockStreamTest, UnalignedOverlappingRead) {
  DiscontiguousFile F(BlocksAry, DataAry);
  MappedBlockStreamImpl S(llvm::make_unique<IndexedStreamData>(0, F), F);
  StreamReader R(S);
  StringRef Str1;
  StringRef Str2;
  EXPECT_NO_ERROR(R.readFixedString(Str1, 7));
  EXPECT_EQ(Str1, StringRef("ABCDEFG"));
  EXPECT_EQ(7U, S.getNumBytesCopied());

  R.setOffset(2);
  EXPECT_NO_ERROR(R.readFixedString(Str2, 3));
  EXPECT_EQ(Str2, StringRef("CDE"));
  EXPECT_EQ(Str1.data() + 2, Str2.data());
  EXPECT_EQ(7U, S.getNumBytesCopied());
}

// Tests that a read which is not aligned on the same boundary as a previous
// cached request, but which only partially overlaps a previous cached request,
// still works correctly and allocates again from the shared pool.
TEST(MappedBlockStreamTest, UnalignedOverlappingReadFail) {
  DiscontiguousFile F(BlocksAry, DataAry);
  MappedBlockStreamImpl S(llvm::make_unique<IndexedStreamData>(0, F), F);
  StreamReader R(S);
  StringRef Str1;
  StringRef Str2;
  EXPECT_NO_ERROR(R.readFixedString(Str1, 6));
  EXPECT_EQ(Str1, StringRef("ABCDEF"));
  EXPECT_EQ(6U, S.getNumBytesCopied());

  R.setOffset(4);
  EXPECT_NO_ERROR(R.readFixedString(Str2, 4));
  EXPECT_EQ(Str2, StringRef("EFGH"));
  EXPECT_EQ(10U, S.getNumBytesCopied());
}

TEST(MappedBlockStreamTest, WriteBeyondEndOfStream) {
  static uint8_t Data[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'};
  static uint8_t LargeBuffer[] = {'0', '1', '2', '3', '4', '5',
                                  '6', '7', '8', '9', 'A'};
  static uint8_t SmallBuffer[] = {'0', '1', '2'};
  static_assert(sizeof(LargeBuffer) > sizeof(Data),
                "LargeBuffer is not big enough");

  DiscontiguousFile F(BlocksAry, Data);
  MappedBlockStreamImpl S(llvm::make_unique<IndexedStreamData>(0, F), F);
  ArrayRef<uint8_t> Buffer;

  EXPECT_ERROR(S.writeBytes(0, ArrayRef<uint8_t>(LargeBuffer)));
  EXPECT_NO_ERROR(S.writeBytes(0, ArrayRef<uint8_t>(SmallBuffer)));
  EXPECT_NO_ERROR(S.writeBytes(7, ArrayRef<uint8_t>(SmallBuffer)));
  EXPECT_ERROR(S.writeBytes(8, ArrayRef<uint8_t>(SmallBuffer)));
}

TEST(MappedBlockStreamTest, TestWriteBytesNoBreakBoundary) {
  static uint8_t Data[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'};
  DiscontiguousFile F(BlocksAry, Data);
  MappedBlockStreamImpl S(llvm::make_unique<IndexedStreamData>(0, F), F);
  ArrayRef<uint8_t> Buffer;

  EXPECT_NO_ERROR(S.readBytes(0, 1, Buffer));
  EXPECT_EQ(Buffer, ArrayRef<uint8_t>('A'));
  EXPECT_NO_ERROR(S.readBytes(9, 1, Buffer));
  EXPECT_EQ(Buffer, ArrayRef<uint8_t>('J'));

  EXPECT_NO_ERROR(S.writeBytes(0, ArrayRef<uint8_t>('J')));
  EXPECT_NO_ERROR(S.writeBytes(9, ArrayRef<uint8_t>('A')));

  EXPECT_NO_ERROR(S.readBytes(0, 1, Buffer));
  EXPECT_EQ(Buffer, ArrayRef<uint8_t>('J'));
  EXPECT_NO_ERROR(S.readBytes(9, 1, Buffer));
  EXPECT_EQ(Buffer, ArrayRef<uint8_t>('A'));

  EXPECT_NO_ERROR(S.writeBytes(0, ArrayRef<uint8_t>('A')));
  EXPECT_NO_ERROR(S.writeBytes(9, ArrayRef<uint8_t>('J')));

  EXPECT_NO_ERROR(S.readBytes(0, 1, Buffer));
  EXPECT_EQ(Buffer, ArrayRef<uint8_t>('A'));
  EXPECT_NO_ERROR(S.readBytes(9, 1, Buffer));
  EXPECT_EQ(Buffer, ArrayRef<uint8_t>('J'));
}

TEST(MappedBlockStreamTest, TestWriteBytesBreakBoundary) {
  static uint8_t Data[] = {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'};
  static uint8_t TestData[] = {'T', 'E', 'S', 'T', 'I', 'N', 'G', '.'};
  static uint8_t Expected[] = {'T', 'E', 'S', 'N', 'I',
                               'T', 'G', '.', '0', '0'};

  DiscontiguousFile F(BlocksAry, Data);
  MappedBlockStreamImpl S(llvm::make_unique<IndexedStreamData>(0, F), F);
  ArrayRef<uint8_t> Buffer;

  EXPECT_NO_ERROR(S.writeBytes(0, TestData));
  // First just compare the memory, then compare the result of reading the
  // string out.
  EXPECT_EQ(ArrayRef<uint8_t>(Data), ArrayRef<uint8_t>(Expected));

  EXPECT_NO_ERROR(S.readBytes(0, 8, Buffer));
  EXPECT_EQ(Buffer, ArrayRef<uint8_t>(TestData));
}

TEST(MappedBlockStreamTest, TestWriteThenRead) {
  std::vector<uint8_t> DataBytes(10);
  MutableArrayRef<uint8_t> Data(DataBytes);
  const uint32_t Blocks[] = {2, 1, 0, 6, 3, 4, 5, 7, 9, 8};

  DiscontiguousFile F(Blocks, Data);
  MappedBlockStreamImpl S(llvm::make_unique<IndexedStreamData>(0, F), F);

  enum class MyEnum : uint32_t { Val1 = 2908234, Val2 = 120891234 };
  using support::ulittle32_t;

  uint16_t u16[] = {31468, 0};
  uint32_t u32[] = {890723408, 0};
  MyEnum Enum[] = {MyEnum::Val1, MyEnum::Val2};
  StringRef ZStr[] = {"Zero Str", ""};
  StringRef FStr[] = {"Fixed Str", ""};
  uint8_t byteArray0[] = {'1', '2'};
  uint8_t byteArray1[] = {'0', '0'};
  ArrayRef<uint8_t> byteArrayRef0(byteArray0);
  ArrayRef<uint8_t> byteArrayRef1(byteArray1);
  ArrayRef<uint8_t> byteArray[] = { byteArrayRef0, byteArrayRef1 };
  ArrayRef<uint32_t> intArray[] = {{890723408, 29082234}, {0, 0}};

  StreamReader Reader(S);
  StreamWriter Writer(S);
  EXPECT_NO_ERROR(Writer.writeInteger(u16[0]));
  EXPECT_NO_ERROR(Reader.readInteger(u16[1]));
  EXPECT_EQ(u16[0], u16[1]);
  EXPECT_EQ(std::vector<uint8_t>({0, 0x7A, 0xEC, 0, 0, 0, 0, 0, 0, 0}),
            DataBytes);

  Reader.setOffset(0);
  Writer.setOffset(0);
  ::memset(DataBytes.data(), 0, 10);
  EXPECT_NO_ERROR(Writer.writeInteger(u32[0]));
  EXPECT_NO_ERROR(Reader.readInteger(u32[1]));
  EXPECT_EQ(u32[0], u32[1]);
  EXPECT_EQ(std::vector<uint8_t>({0x17, 0x5C, 0x50, 0, 0, 0, 0x35, 0, 0, 0}),
            DataBytes);

  Reader.setOffset(0);
  Writer.setOffset(0);
  ::memset(DataBytes.data(), 0, 10);
  EXPECT_NO_ERROR(Writer.writeEnum(Enum[0]));
  EXPECT_NO_ERROR(Reader.readEnum(Enum[1]));
  EXPECT_EQ(Enum[0], Enum[1]);
  EXPECT_EQ(std::vector<uint8_t>({0x2C, 0x60, 0x4A, 0, 0, 0, 0, 0, 0, 0}),
            DataBytes);

  Reader.setOffset(0);
  Writer.setOffset(0);
  ::memset(DataBytes.data(), 0, 10);
  EXPECT_NO_ERROR(Writer.writeZeroString(ZStr[0]));
  EXPECT_NO_ERROR(Reader.readZeroString(ZStr[1]));
  EXPECT_EQ(ZStr[0], ZStr[1]);
  EXPECT_EQ(
      std::vector<uint8_t>({'r', 'e', 'Z', ' ', 'S', 't', 'o', 'r', 0, 0}),
      DataBytes);

  Reader.setOffset(0);
  Writer.setOffset(0);
  ::memset(DataBytes.data(), 0, 10);
  EXPECT_NO_ERROR(Writer.writeFixedString(FStr[0]));
  EXPECT_NO_ERROR(Reader.readFixedString(FStr[1], FStr[0].size()));
  EXPECT_EQ(FStr[0], FStr[1]);
  EXPECT_EQ(
      std::vector<uint8_t>({'x', 'i', 'F', 'd', ' ', 'S', 'e', 't', 0, 'r'}),
      DataBytes);

  Reader.setOffset(0);
  Writer.setOffset(0);
  ::memset(DataBytes.data(), 0, 10);
  EXPECT_NO_ERROR(Writer.writeArray(byteArray[0]));
  EXPECT_NO_ERROR(Reader.readArray(byteArray[1], byteArray[0].size()));
  EXPECT_EQ(byteArray[0], byteArray[1]);
  EXPECT_EQ(std::vector<uint8_t>({0, 0x32, 0x31, 0, 0, 0, 0, 0, 0, 0}),
            DataBytes);

  Reader.setOffset(0);
  Writer.setOffset(0);
  ::memset(DataBytes.data(), 0, 10);
  EXPECT_NO_ERROR(Writer.writeArray(intArray[0]));
  EXPECT_NO_ERROR(Reader.readArray(intArray[1], intArray[0].size()));
  EXPECT_EQ(intArray[0], intArray[1]);
}

TEST(MappedBlockStreamTest, TestWriteContiguousStreamRef) {
  std::vector<uint8_t> DestDataBytes(10);
  MutableArrayRef<uint8_t> DestData(DestDataBytes);
  const uint32_t DestBlocks[] = {2, 1, 0, 6, 3, 4, 5, 7, 9, 8};

  std::vector<uint8_t> SrcDataBytes(10);
  MutableArrayRef<uint8_t> SrcData(SrcDataBytes);

  DiscontiguousFile F(DestBlocks, DestData);
  MappedBlockStreamImpl DestStream(llvm::make_unique<IndexedStreamData>(0, F),
                                   F);

  // First write "Test Str" into the source stream.
  ByteStream<true> SourceStream(SrcData);
  StreamWriter SourceWriter(SourceStream);
  EXPECT_NO_ERROR(SourceWriter.writeZeroString("Test Str"));
  EXPECT_EQ(SrcDataBytes, std::vector<uint8_t>(
                              {'T', 'e', 's', 't', ' ', 'S', 't', 'r', 0, 0}));

  // Then write the source stream into the dest stream.
  StreamWriter DestWriter(DestStream);
  EXPECT_NO_ERROR(DestWriter.writeStreamRef(SourceStream));
  EXPECT_EQ(DestDataBytes, std::vector<uint8_t>(
                               {'s', 'e', 'T', ' ', 'S', 't', 't', 'r', 0, 0}));

  // Then read the string back out of the dest stream.
  StringRef Result;
  StreamReader DestReader(DestStream);
  EXPECT_NO_ERROR(DestReader.readZeroString(Result));
  EXPECT_EQ(Result, "Test Str");
}

TEST(MappedBlockStreamTest, TestWriteDiscontiguousStreamRef) {
  std::vector<uint8_t> DestDataBytes(10);
  MutableArrayRef<uint8_t> DestData(DestDataBytes);
  const uint32_t DestBlocks[] = {2, 1, 0, 6, 3, 4, 5, 7, 9, 8};

  std::vector<uint8_t> SrcDataBytes(10);
  MutableArrayRef<uint8_t> SrcData(SrcDataBytes);
  const uint32_t SrcBlocks[] = {1, 0, 6, 3, 4, 5, 2, 7, 8, 9};

  DiscontiguousFile DestFile(DestBlocks, DestData);
  DiscontiguousFile SrcFile(SrcBlocks, SrcData);

  MappedBlockStreamImpl DestStream(
      llvm::make_unique<IndexedStreamData>(0, DestFile), DestFile);
  MappedBlockStreamImpl SrcStream(
      llvm::make_unique<IndexedStreamData>(0, SrcFile), SrcFile);

  // First write "Test Str" into the source stream.
  StreamWriter SourceWriter(SrcStream);
  EXPECT_NO_ERROR(SourceWriter.writeZeroString("Test Str"));
  EXPECT_EQ(SrcDataBytes, std::vector<uint8_t>(
                              {'e', 'T', 't', 't', ' ', 'S', 's', 'r', 0, 0}));

  // Then write the source stream into the dest stream.
  StreamWriter DestWriter(DestStream);
  EXPECT_NO_ERROR(DestWriter.writeStreamRef(SrcStream));
  EXPECT_EQ(DestDataBytes, std::vector<uint8_t>(
                               {'s', 'e', 'T', ' ', 'S', 't', 't', 'r', 0, 0}));

  // Then read the string back out of the dest stream.
  StringRef Result;
  StreamReader DestReader(DestStream);
  EXPECT_NO_ERROR(DestReader.readZeroString(Result));
  EXPECT_EQ(Result, "Test Str");
}

} // end anonymous namespace
@


1.1.1.1
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d12 8
a19 7
#include "llvm/DebugInfo/MSF/ByteStream.h"
#include "llvm/DebugInfo/MSF/IMSFFile.h"
#include "llvm/DebugInfo/MSF/MappedBlockStream.h"
#include "llvm/DebugInfo/MSF/MSFStreamLayout.h"
#include "llvm/DebugInfo/MSF/StreamReader.h"
#include "llvm/DebugInfo/MSF/StreamRef.h"
#include "llvm/DebugInfo/MSF/StreamWriter.h"
d25 2
a26 1
using namespace llvm::msf;
d33 1
a33 1
class DiscontiguousStream : public WritableStream {
d35 1
a35 1
  DiscontiguousStream(ArrayRef<uint32_t> Blocks, MutableArrayRef<uint8_t> Data)
d38 11
a48 9
  uint32_t block_size() const { return 1; }
  uint32_t block_count() const { return Blocks.size(); }

  Error readBytes(uint32_t Offset, uint32_t Size,
                  ArrayRef<uint8_t> &Buffer) const override {
    if (Offset + Size > Data.size())
      return make_error<MSFError>(msf_error_code::insufficient_buffer);
    Buffer = Data.slice(Offset, Size);
    return Error::success();
d50 3
a52 7

  Error readLongestContiguousChunk(uint32_t Offset,
                                   ArrayRef<uint8_t> &Buffer) const override {
    if (Offset >= Data.size())
      return make_error<MSFError>(msf_error_code::insufficient_buffer);
    Buffer = Data.drop_front(Offset);
    return Error::success();
d55 7
a61 6
  uint32_t getLength() const override { return Data.size(); }

  Error writeBytes(uint32_t Offset, ArrayRef<uint8_t> SrcData) const override {
    if (Offset + SrcData.size() > Data.size())
      return make_error<MSFError>(msf_error_code::insufficient_buffer);
    ::memcpy(&Data[Offset], SrcData.data(), SrcData.size());
a63 5
  Error commit() const override { return Error::success(); }

  MSFStreamLayout layout() const {
    return MSFStreamLayout{static_cast<uint32_t>(Data.size()), Blocks};
  }
d70 7
d80 4
a83 6
  DiscontiguousStream F(BlocksAry, DataAry);
  auto S = MappedBlockStream::createStream(F.block_size(), F.block_count(),
                                           F.layout(), F);

  StreamReader R(*S);
  ReadableStreamRef SR;
d94 3
a96 5
  DiscontiguousStream F(BlocksAry, DataAry);
  auto S = MappedBlockStream::createStream(F.block_size(), F.block_count(),
                                           F.layout(), F);

  StreamReader R(*S);
d100 1
a100 1
  EXPECT_EQ(0U, S->getNumBytesCopied());
d107 3
a109 4
  DiscontiguousStream F(BlocksAry, DataAry);
  auto S = MappedBlockStream::createStream(F.block_size(), F.block_count(),
                                           F.layout(), F);
  StreamReader R(*S);
d113 1
a113 1
  EXPECT_EQ(0U, S->getNumBytesCopied());
d118 1
a118 1
  EXPECT_EQ(0U, S->getNumBytesCopied());
d125 3
a127 4
  DiscontiguousStream F(BlocksAry, DataAry);
  auto S = MappedBlockStream::createStream(F.block_size(), F.block_count(),
                                           F.layout(), F);
  StreamReader R(*S);
d131 1
a131 1
  EXPECT_EQ(10U, S->getNumBytesCopied());
d137 3
a139 4
  DiscontiguousStream F(BlocksAry, DataAry);
  auto S = MappedBlockStream::createStream(F.block_size(), F.block_count(),
                                           F.layout(), F);
  StreamReader R(*S);
d144 1
a144 1
  EXPECT_EQ(0U, S->getNumBytesCopied());
d150 3
a152 4
  DiscontiguousStream F(BlocksAry, DataAry);
  auto S = MappedBlockStream::createStream(F.block_size(), F.block_count(),
                                           F.layout(), F);
  StreamReader R(*S);
d157 1
a157 1
  EXPECT_EQ(0U, S->getNumBytesCopied());
d163 3
a165 4
  DiscontiguousStream F(BlocksAry, DataAry);
  auto S = MappedBlockStream::createStream(F.block_size(), F.block_count(),
                                           F.layout(), F);
  StreamReader R(*S);
d169 1
a169 1
  EXPECT_EQ(0U, S->getNumBytesCopied());
d175 3
a177 4
  DiscontiguousStream F(BlocksAry, DataAry);
  auto S = MappedBlockStream::createStream(F.block_size(), F.block_count(),
                                           F.layout(), F);
  StreamReader R(*S);
d181 1
a181 1
  EXPECT_EQ(0U, S->getNumBytesCopied());
d188 3
a190 4
  DiscontiguousStream F(BlocksAry, DataAry);
  auto S = MappedBlockStream::createStream(F.block_size(), F.block_count(),
                                           F.layout(), F);
  StreamReader R(*S);
d195 1
a195 1
  EXPECT_EQ(7U, S->getNumBytesCopied());
d201 1
a201 1
  EXPECT_EQ(7U, S->getNumBytesCopied());
d208 3
a210 4
  DiscontiguousStream F(BlocksAry, DataAry);
  auto S = MappedBlockStream::createStream(F.block_size(), F.block_count(),
                                           F.layout(), F);
  StreamReader R(*S);
d215 1
a215 1
  EXPECT_EQ(6U, S->getNumBytesCopied());
d220 1
a220 1
  EXPECT_EQ(10U, S->getNumBytesCopied());
d231 2
a232 3
  DiscontiguousStream F(BlocksAry, Data);
  auto S = WritableMappedBlockStream::createStream(
      F.block_size(), F.block_count(), F.layout(), F);
d235 4
a238 4
  EXPECT_ERROR(S->writeBytes(0, ArrayRef<uint8_t>(LargeBuffer)));
  EXPECT_NO_ERROR(S->writeBytes(0, ArrayRef<uint8_t>(SmallBuffer)));
  EXPECT_NO_ERROR(S->writeBytes(7, ArrayRef<uint8_t>(SmallBuffer)));
  EXPECT_ERROR(S->writeBytes(8, ArrayRef<uint8_t>(SmallBuffer)));
d243 2
a244 3
  DiscontiguousStream F(BlocksAry, Data);
  auto S = WritableMappedBlockStream::createStream(
      F.block_size(), F.block_count(), F.layout(), F);
d247 1
a247 1
  EXPECT_NO_ERROR(S->readBytes(0, 1, Buffer));
d249 1
a249 1
  EXPECT_NO_ERROR(S->readBytes(9, 1, Buffer));
d252 2
a253 2
  EXPECT_NO_ERROR(S->writeBytes(0, ArrayRef<uint8_t>('J')));
  EXPECT_NO_ERROR(S->writeBytes(9, ArrayRef<uint8_t>('A')));
d255 1
a255 1
  EXPECT_NO_ERROR(S->readBytes(0, 1, Buffer));
d257 1
a257 1
  EXPECT_NO_ERROR(S->readBytes(9, 1, Buffer));
d260 2
a261 2
  EXPECT_NO_ERROR(S->writeBytes(0, ArrayRef<uint8_t>('A')));
  EXPECT_NO_ERROR(S->writeBytes(9, ArrayRef<uint8_t>('J')));
d263 1
a263 1
  EXPECT_NO_ERROR(S->readBytes(0, 1, Buffer));
d265 1
a265 1
  EXPECT_NO_ERROR(S->readBytes(9, 1, Buffer));
d275 2
a276 3
  DiscontiguousStream F(BlocksAry, Data);
  auto S = WritableMappedBlockStream::createStream(
      F.block_size(), F.block_count(), F.layout(), F);
d279 1
a279 1
  EXPECT_NO_ERROR(S->writeBytes(0, TestData));
d284 1
a284 1
  EXPECT_NO_ERROR(S->readBytes(0, 8, Buffer));
d293 2
a294 3
  DiscontiguousStream F(Blocks, Data);
  auto S = WritableMappedBlockStream::createStream(
      F.block_size(), F.block_count(), F.layout(), F);
d309 1
a309 3
  uint32_t intArr0[] = {890723408, 29082234};
  uint32_t intArr1[] = {890723408, 29082234};
  ArrayRef<uint32_t> intArray[] = {intArr0, intArr1};
d311 2
a312 2
  StreamReader Reader(*S);
  StreamWriter Writer(*S);
d382 3
a384 3
  DiscontiguousStream F(DestBlocks, DestData);
  auto DestStream = WritableMappedBlockStream::createStream(
      F.block_size(), F.block_count(), F.layout(), F);
d387 1
a387 1
  MutableByteStream SourceStream(SrcData);
d394 1
a394 1
  StreamWriter DestWriter(*DestStream);
d401 1
a401 1
  StreamReader DestReader(*DestStream);
d415 2
a416 2
  DiscontiguousStream DestF(DestBlocks, DestData);
  DiscontiguousStream SrcF(SrcBlocks, SrcData);
d418 4
a421 4
  auto Dest = WritableMappedBlockStream::createStream(
      DestF.block_size(), DestF.block_count(), DestF.layout(), DestF);
  auto Src = WritableMappedBlockStream::createStream(
      SrcF.block_size(), SrcF.block_count(), SrcF.layout(), SrcF);
d424 1
a424 1
  StreamWriter SourceWriter(*Src);
d430 2
a431 2
  StreamWriter DestWriter(*Dest);
  EXPECT_NO_ERROR(DestWriter.writeStreamRef(*Src));
d437 1
a437 1
  StreamReader DestReader(*Dest);
@

