head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.1.0.2
	OPENBSD_6_1_BASE:1.1.1.1
	LLVM_4_0_0:1.1.1.1
	LLVM_4_0_0_RC1:1.1.1.1
	LLVM_3_9_1:1.1.1.1
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.46.54;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.54;	author pascal;	state Exp;
branches;
next	;
commitid	piLU3CHugy63NlaI;


desc
@@


1.1
log
@Initial revision
@
text
@//===- llvm/unittest/ADT/SparseBitVectorTest.cpp - SparseBitVector tests --===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "llvm/ADT/SparseBitVector.h"
#include "gtest/gtest.h"

using namespace llvm;

namespace {

TEST(SparseBitVectorTest, TrivialOperation) {
  SparseBitVector<> Vec;
  EXPECT_EQ(0U, Vec.count());
  EXPECT_FALSE(Vec.test(17));
  Vec.set(5);
  EXPECT_TRUE(Vec.test(5));
  EXPECT_FALSE(Vec.test(17));
  Vec.reset(6);
  EXPECT_TRUE(Vec.test(5));
  EXPECT_FALSE(Vec.test(6));
  Vec.reset(5);
  EXPECT_FALSE(Vec.test(5));
  EXPECT_TRUE(Vec.test_and_set(17));
  EXPECT_FALSE(Vec.test_and_set(17));
  EXPECT_TRUE(Vec.test(17));
  Vec.clear();
  EXPECT_FALSE(Vec.test(17));
}

TEST(SparseBitVectorTest, IntersectWith) {
  SparseBitVector<> Vec, Other;

  Vec.set(1);
  Other.set(1);
  EXPECT_FALSE(Vec &= Other);
  EXPECT_TRUE(Vec.test(1));

  Vec.clear();
  Vec.set(5);
  Other.clear();
  Other.set(6);
  EXPECT_TRUE(Vec &= Other);
  EXPECT_TRUE(Vec.empty());

  Vec.clear();
  Vec.set(5);
  Other.clear();
  Other.set(225);
  EXPECT_TRUE(Vec &= Other);
  EXPECT_TRUE(Vec.empty());

  Vec.clear();
  Vec.set(225);
  Other.clear();
  Other.set(5);
  EXPECT_TRUE(Vec &= Other);
  EXPECT_TRUE(Vec.empty());
}

TEST(SparseBitVectorTest, SelfAssignment) {
  SparseBitVector<> Vec, Other;

  Vec.set(23);
  Vec.set(234);
  Vec = Vec;
  EXPECT_TRUE(Vec.test(23));
  EXPECT_TRUE(Vec.test(234));

  Vec.clear();
  Vec.set(17);
  Vec.set(256);
  EXPECT_FALSE(Vec |= Vec);
  EXPECT_TRUE(Vec.test(17));
  EXPECT_TRUE(Vec.test(256));

  Vec.clear();
  Vec.set(56);
  Vec.set(517);
  EXPECT_FALSE(Vec &= Vec);
  EXPECT_TRUE(Vec.test(56));
  EXPECT_TRUE(Vec.test(517));

  Vec.clear();
  Vec.set(99);
  Vec.set(333);
  EXPECT_TRUE(Vec.intersectWithComplement(Vec));
  EXPECT_TRUE(Vec.empty());
  EXPECT_FALSE(Vec.intersectWithComplement(Vec));

  Vec.clear();
  Vec.set(28);
  Vec.set(43);
  Vec.intersectWithComplement(Vec, Vec);
  EXPECT_TRUE(Vec.empty());

  Vec.clear();
  Vec.set(42);
  Vec.set(567);
  Other.set(55);
  Other.set(567);
  Vec.intersectWithComplement(Vec, Other);
  EXPECT_TRUE(Vec.test(42));
  EXPECT_FALSE(Vec.test(567));

  Vec.clear();
  Vec.set(19);
  Vec.set(21);
  Other.clear();
  Other.set(19);
  Other.set(31);
  Vec.intersectWithComplement(Other, Vec);
  EXPECT_FALSE(Vec.test(19));
  EXPECT_TRUE(Vec.test(31));

  Vec.clear();
  Vec.set(1);
  Other.clear();
  Other.set(59);
  Other.set(75);
  Vec.intersectWithComplement(Other, Other);
  EXPECT_TRUE(Vec.empty());
}

}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@
