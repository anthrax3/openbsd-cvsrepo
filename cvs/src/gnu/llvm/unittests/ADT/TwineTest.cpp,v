head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.2.0.6
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.46.54;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.54;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.24.08.33.21;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===- TwineTest.cpp - Twine unit tests -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "llvm/ADT/Twine.h"
#include "llvm/ADT/SmallString.h"
#include "llvm/Support/raw_ostream.h"
#include "gtest/gtest.h"
using namespace llvm;

namespace {

std::string repr(const Twine &Value) {
  std::string res;
  llvm::raw_string_ostream OS(res);
  Value.printRepr(OS);
  return OS.str();
}

TEST(TwineTest, Construction) {
  EXPECT_EQ("", Twine().str());
  EXPECT_EQ("hi", Twine("hi").str());
  EXPECT_EQ("hi", Twine(std::string("hi")).str());
  EXPECT_EQ("hi", Twine(StringRef("hi")).str());
  EXPECT_EQ("hi", Twine(StringRef(std::string("hi"))).str());
  EXPECT_EQ("hi", Twine(StringRef("hithere", 2)).str());
  EXPECT_EQ("hi", Twine(SmallString<4>("hi")).str());
}

TEST(TwineTest, Numbers) {
  EXPECT_EQ("123", Twine(123U).str());
  EXPECT_EQ("123", Twine(123).str());
  EXPECT_EQ("-123", Twine(-123).str());
  EXPECT_EQ("123", Twine(123).str());
  EXPECT_EQ("-123", Twine(-123).str());

  EXPECT_EQ("7b", Twine::utohexstr(123).str());
}

TEST(TwineTest, Characters) {
  EXPECT_EQ("x", Twine('x').str());
  EXPECT_EQ("x", Twine(static_cast<unsigned char>('x')).str());
  EXPECT_EQ("x", Twine(static_cast<signed char>('x')).str());
}

TEST(TwineTest, Concat) {
  // Check verse repr, since we care about the actual representation not just
  // the result.

  // Concat with null.
  EXPECT_EQ("(Twine null empty)", 
            repr(Twine("hi").concat(Twine::createNull())));
  EXPECT_EQ("(Twine null empty)", 
            repr(Twine::createNull().concat(Twine("hi"))));
  
  // Concat with empty.
  EXPECT_EQ("(Twine cstring:\"hi\" empty)", 
            repr(Twine("hi").concat(Twine())));
  EXPECT_EQ("(Twine cstring:\"hi\" empty)", 
            repr(Twine().concat(Twine("hi"))));
  EXPECT_EQ("(Twine smallstring:\"hi\" empty)", 
            repr(Twine().concat(Twine(SmallString<5>("hi")))));
  EXPECT_EQ("(Twine smallstring:\"hey\" cstring:\"there\")", 
            repr(Twine(SmallString<7>("hey")).concat(Twine("there"))));

  // Concatenation of unary ropes.
  EXPECT_EQ("(Twine cstring:\"a\" cstring:\"b\")", 
            repr(Twine("a").concat(Twine("b"))));

  // Concatenation of other ropes.
  EXPECT_EQ("(Twine rope:(Twine cstring:\"a\" cstring:\"b\") cstring:\"c\")", 
            repr(Twine("a").concat(Twine("b")).concat(Twine("c"))));
  EXPECT_EQ("(Twine cstring:\"a\" rope:(Twine cstring:\"b\" cstring:\"c\"))",
            repr(Twine("a").concat(Twine("b").concat(Twine("c")))));
  EXPECT_EQ("(Twine cstring:\"a\" rope:(Twine smallstring:\"b\" cstring:\"c\"))",
            repr(Twine("a").concat(Twine(SmallString<3>("b")).concat(Twine("c")))));
}

TEST(TwineTest, toNullTerminatedStringRef) {
  SmallString<8> storage;
  EXPECT_EQ(0, *Twine("hello").toNullTerminatedStringRef(storage).end());
  EXPECT_EQ(0,
           *Twine(StringRef("hello")).toNullTerminatedStringRef(storage).end());
  EXPECT_EQ(0, *Twine(SmallString<11>("hello"))
                    .toNullTerminatedStringRef(storage)
                    .end());
}

  // I suppose linking in the entire code generator to add a unit test to check
  // the code size of the concat operation is overkill... :)

} // end anonymous namespace
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d10 1
a11 3
#include "llvm/ADT/Twine.h"
#include "llvm/Support/FormatAdapters.h"
#include "llvm/Support/FormatVariadic.h"
a32 1
  EXPECT_EQ("hi", Twine(formatv("{0}", "hi")).str());
a67 4
  EXPECT_EQ("(Twine formatv:\"howdy\" empty)",
            repr(Twine(formatv("howdy")).concat(Twine())));
  EXPECT_EQ("(Twine formatv:\"howdy\" empty)",
            repr(Twine().concat(Twine(formatv("howdy")))));
a91 19
  EXPECT_EQ(0, *Twine(formatv("{0}{1}", "how", "dy"))
                    .toNullTerminatedStringRef(storage)
                    .end());
}

TEST(TwineTest, LazyEvaluation) {
  struct formatter : FormatAdapter<int> {
    explicit formatter(int &Count) : FormatAdapter(0), Count(Count) {}
    int &Count;

    void format(raw_ostream &OS, StringRef Style) { ++Count; }
  };

  int Count = 0;
  formatter Formatter(Count);
  (void)Twine(formatv("{0}", Formatter));
  EXPECT_EQ(0, Count);
  (void)Twine(formatv("{0}", Formatter)).str();
  EXPECT_EQ(1, Count);
@

