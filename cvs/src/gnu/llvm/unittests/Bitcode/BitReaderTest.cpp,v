head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.3.0.2
	OPENBSD_6_2_BASE:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.4
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.44;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.20;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===- llvm/unittest/Bitcode/BitReaderTest.cpp - Tests for BitReader ------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "llvm/ADT/SmallString.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/AsmParser/Parser.h"
#include "llvm/Bitcode/BitstreamReader.h"
#include "llvm/Bitcode/BitstreamWriter.h"
#include "llvm/Bitcode/ReaderWriter.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Verifier.h"
#include "llvm/Support/DataStream.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/MemoryBuffer.h"
#include "llvm/Support/SourceMgr.h"
#include "llvm/Support/StreamingMemoryObject.h"
#include "gtest/gtest.h"

using namespace llvm;

namespace {

std::unique_ptr<Module> parseAssembly(const char *Assembly) {
  SMDiagnostic Error;
  std::unique_ptr<Module> M =
      parseAssemblyString(Assembly, Error, getGlobalContext());

  std::string ErrMsg;
  raw_string_ostream OS(ErrMsg);
  Error.print("", OS);

  // A failure here means that the test itself is buggy.
  if (!M)
    report_fatal_error(OS.str().c_str());

  return M;
}

static void writeModuleToBuffer(std::unique_ptr<Module> Mod,
                                SmallVectorImpl<char> &Buffer) {
  raw_svector_ostream OS(Buffer);
  WriteBitcodeToFile(Mod.get(), OS);
}

static std::unique_ptr<Module> getLazyModuleFromAssembly(LLVMContext &Context,
                                                         SmallString<1024> &Mem,
                                                         const char *Assembly) {
  writeModuleToBuffer(parseAssembly(Assembly), Mem);
  std::unique_ptr<MemoryBuffer> Buffer =
      MemoryBuffer::getMemBuffer(Mem.str(), "test", false);
  ErrorOr<std::unique_ptr<Module>> ModuleOrErr =
      getLazyBitcodeModule(std::move(Buffer), Context);
  return std::move(ModuleOrErr.get());
}

class BufferDataStreamer : public DataStreamer {
  std::unique_ptr<MemoryBuffer> Buffer;
  unsigned Pos = 0;
  size_t GetBytes(unsigned char *Out, size_t Len) override {
    StringRef Buf = Buffer->getBuffer();
    size_t Left = Buf.size() - Pos;
    Len = std::min(Left, Len);
    memcpy(Out, Buffer->getBuffer().substr(Pos).data(), Len);
    Pos += Len;
    return Len;
  }

public:
  BufferDataStreamer(std::unique_ptr<MemoryBuffer> Buffer)
      : Buffer(std::move(Buffer)) {}
};

static std::unique_ptr<Module>
getStreamedModuleFromAssembly(LLVMContext &Context, SmallString<1024> &Mem,
                              const char *Assembly) {
  writeModuleToBuffer(parseAssembly(Assembly), Mem);
  std::unique_ptr<MemoryBuffer> Buffer =
      MemoryBuffer::getMemBuffer(Mem.str(), "test", false);
  auto Streamer = llvm::make_unique<BufferDataStreamer>(std::move(Buffer));
  ErrorOr<std::unique_ptr<Module>> ModuleOrErr =
      getStreamedBitcodeModule("test", std::move(Streamer), Context);
  return std::move(ModuleOrErr.get());
}

// Checks if we correctly detect eof if we try to read N bits when there are not
// enough bits left on the input stream to read N bits, and we are using a data
// streamer. In particular, it checks if we properly set the object size when
// the eof is reached under such conditions.
TEST(BitReaderTest, TestForEofAfterReadFailureOnDataStreamer) {
  // Note: Because StreamingMemoryObject does a call to method GetBytes in it's
  // constructor, using internal constant kChunkSize, we must fill the input
  // with more characters than that amount.
  static size_t InputSize = StreamingMemoryObject::kChunkSize + 5;
  char *Text = new char[InputSize];
  std::memset(Text, 'a', InputSize);
  Text[InputSize - 1] = '\0';
  StringRef Input(Text);

  // Build bitsteam reader using data streamer.
  auto MemoryBuf = MemoryBuffer::getMemBuffer(Input);
  std::unique_ptr<DataStreamer> Streamer(
      new BufferDataStreamer(std::move(MemoryBuf)));
  auto OwnedBytes =
      llvm::make_unique<StreamingMemoryObject>(std::move(Streamer));
  auto Reader = llvm::make_unique<BitstreamReader>(std::move(OwnedBytes));
  BitstreamCursor Cursor;
  Cursor.init(Reader.get());

  // Jump to two bytes before end of stream.
  Cursor.JumpToBit((InputSize - 4) * CHAR_BIT);
  // Try to read 4 bytes when only 2 are present, resulting in error value 0.
  const size_t ReadErrorValue = 0;
  EXPECT_EQ(ReadErrorValue, Cursor.Read(32));
  // Should be at eof now.
  EXPECT_TRUE(Cursor.AtEndOfStream());

  delete[] Text;
}

TEST(BitReaderTest, MateralizeForwardRefWithStream) {
  SmallString<1024> Mem;

  LLVMContext Context;
  std::unique_ptr<Module> M = getStreamedModuleFromAssembly(
      Context, Mem, "@@table = constant i8* blockaddress(@@func, %bb)\n"
                    "define void @@func() {\n"
                    "  unreachable\n"
                    "bb:\n"
                    "  unreachable\n"
                    "}\n");
  EXPECT_FALSE(M->getFunction("func")->empty());
}

// Tests that lazy evaluation can parse functions out of order.
TEST(BitReaderTest, MaterializeFunctionsOutOfOrder) {
  SmallString<1024> Mem;
  LLVMContext Context;
  std::unique_ptr<Module> M = getLazyModuleFromAssembly(
      Context, Mem, "define void @@f() {\n"
                    "  unreachable\n"
                    "}\n"
                    "define void @@g() {\n"
                    "  unreachable\n"
                    "}\n"
                    "define void @@h() {\n"
                    "  unreachable\n"
                    "}\n"
                    "define void @@j() {\n"
                    "  unreachable\n"
                    "}\n");
  EXPECT_FALSE(verifyModule(*M, &dbgs()));

  Function *F = M->getFunction("f");
  Function *G = M->getFunction("g");
  Function *H = M->getFunction("h");
  Function *J = M->getFunction("j");

  // Initially all functions are not materialized (no basic blocks).
  EXPECT_TRUE(F->empty());
  EXPECT_TRUE(G->empty());
  EXPECT_TRUE(H->empty());
  EXPECT_TRUE(J->empty());
  EXPECT_FALSE(verifyModule(*M, &dbgs()));

  // Materialize h.
  H->materialize();
  EXPECT_TRUE(F->empty());
  EXPECT_TRUE(G->empty());
  EXPECT_FALSE(H->empty());
  EXPECT_TRUE(J->empty());
  EXPECT_FALSE(verifyModule(*M, &dbgs()));

  // Materialize g.
  G->materialize();
  EXPECT_TRUE(F->empty());
  EXPECT_FALSE(G->empty());
  EXPECT_FALSE(H->empty());
  EXPECT_TRUE(J->empty());
  EXPECT_FALSE(verifyModule(*M, &dbgs()));

  // Materialize j.
  J->materialize();
  EXPECT_TRUE(F->empty());
  EXPECT_FALSE(G->empty());
  EXPECT_FALSE(H->empty());
  EXPECT_FALSE(J->empty());
  EXPECT_FALSE(verifyModule(*M, &dbgs()));

  // Materialize f.
  F->materialize();
  EXPECT_FALSE(F->empty());
  EXPECT_FALSE(G->empty());
  EXPECT_FALSE(H->empty());
  EXPECT_FALSE(J->empty());
  EXPECT_FALSE(verifyModule(*M, &dbgs()));
}

TEST(BitReaderTest, MaterializeFunctionsForBlockAddr) { // PR11677
  SmallString<1024> Mem;

  LLVMContext Context;
  std::unique_ptr<Module> M = getLazyModuleFromAssembly(
      Context, Mem, "@@table = constant i8* blockaddress(@@func, %bb)\n"
                    "define void @@func() {\n"
                    "  unreachable\n"
                    "bb:\n"
                    "  unreachable\n"
                    "}\n");
  EXPECT_FALSE(verifyModule(*M, &dbgs()));
}

TEST(BitReaderTest, MaterializeFunctionsForBlockAddrInFunctionBefore) {
  SmallString<1024> Mem;

  LLVMContext Context;
  std::unique_ptr<Module> M = getLazyModuleFromAssembly(
      Context, Mem, "define i8* @@before() {\n"
                    "  ret i8* blockaddress(@@func, %bb)\n"
                    "}\n"
                    "define void @@other() {\n"
                    "  unreachable\n"
                    "}\n"
                    "define void @@func() {\n"
                    "  unreachable\n"
                    "bb:\n"
                    "  unreachable\n"
                    "}\n");
  EXPECT_TRUE(M->getFunction("before")->empty());
  EXPECT_TRUE(M->getFunction("func")->empty());
  EXPECT_FALSE(verifyModule(*M, &dbgs()));

  // Materialize @@before, pulling in @@func.
  EXPECT_FALSE(M->getFunction("before")->materialize());
  EXPECT_FALSE(M->getFunction("func")->empty());
  EXPECT_TRUE(M->getFunction("other")->empty());
  EXPECT_FALSE(verifyModule(*M, &dbgs()));
}

TEST(BitReaderTest, MaterializeFunctionsForBlockAddrInFunctionAfter) {
  SmallString<1024> Mem;

  LLVMContext Context;
  std::unique_ptr<Module> M = getLazyModuleFromAssembly(
      Context, Mem, "define void @@func() {\n"
                    "  unreachable\n"
                    "bb:\n"
                    "  unreachable\n"
                    "}\n"
                    "define void @@other() {\n"
                    "  unreachable\n"
                    "}\n"
                    "define i8* @@after() {\n"
                    "  ret i8* blockaddress(@@func, %bb)\n"
                    "}\n");
  EXPECT_TRUE(M->getFunction("after")->empty());
  EXPECT_TRUE(M->getFunction("func")->empty());
  EXPECT_FALSE(verifyModule(*M, &dbgs()));

  // Materialize @@after, pulling in @@func.
  EXPECT_FALSE(M->getFunction("after")->materialize());
  EXPECT_FALSE(M->getFunction("func")->empty());
  EXPECT_TRUE(M->getFunction("other")->empty());
  EXPECT_FALSE(verifyModule(*M, &dbgs()));
}

} // end namespace
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d32 1
a32 2
std::unique_ptr<Module> parseAssembly(LLVMContext &Context,
                                      const char *Assembly) {
d34 2
a35 1
  std::unique_ptr<Module> M = parseAssemblyString(Assembly, Error, Context);
d57 1
a57 1
  writeModuleToBuffer(parseAssembly(Context, Assembly), Mem);
d85 1
a85 1
  writeModuleToBuffer(parseAssembly(Context, Assembly), Mem);
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d10 1
a11 1
#include "llvm/ADT/SmallString.h"
a12 2
#include "llvm/Bitcode/BitcodeReader.h"
#include "llvm/Bitcode/BitcodeWriter.h"
d15 1
d21 1
a22 1
#include "llvm/Support/Error.h"
d25 1
d58 33
a90 4
  Expected<std::unique_ptr<Module>> ModuleOrErr =
      getLazyBitcodeModule(MemoryBufferRef(Mem.str(), "test"), Context);
  if (!ModuleOrErr)
    report_fatal_error("Could not parse bitcode module");
d94 49
d175 1
a175 1
  ASSERT_FALSE(H->materialize());
d183 1
a183 1
  ASSERT_FALSE(G->materialize());
d191 1
a191 1
  ASSERT_FALSE(J->materialize());
d199 1
a199 1
  ASSERT_FALSE(F->materialize());
a218 1
  EXPECT_FALSE(M->getFunction("func")->empty());
@


