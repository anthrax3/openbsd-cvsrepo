head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.4
	OPENBSD_6_2:1.1.1.3.0.6
	OPENBSD_6_2_BASE:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.4
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.44;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.21;	author patrick;	state Exp;
branches;
next	1.1.1.4;
commitid	so2WA7LCP6wbxtYl;

1.1.1.4
date	2017.10.04.20.27.56;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===- ObjectTransformLayerTest.cpp - Unit tests for ObjectTransformLayer -===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "llvm/ExecutionEngine/Orc/ObjectTransformLayer.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/ADT/SmallVector.h"
#include "gtest/gtest.h"

using namespace llvm::orc;

namespace {

// Stand-in for RuntimeDyld::MemoryManager
typedef int MockMemoryManager;

// Stand-in for RuntimeDyld::SymbolResolver
typedef int MockSymbolResolver;

// stand-in for object::ObjectFile
typedef int MockObjectFile;

// stand-in for llvm::MemoryBuffer set
typedef int MockMemoryBufferSet;

// Mock transform that operates on unique pointers to object files, and
// allocates new object files rather than mutating the given ones.
struct AllocatingTransform {
  std::unique_ptr<MockObjectFile>
  operator()(std::unique_ptr<MockObjectFile> Obj) const {
    return llvm::make_unique<MockObjectFile>(*Obj + 1);
  }
};

// Mock base layer for verifying behavior of transform layer.
// Each method "T foo(args)" is accompanied by two auxiliary methods:
//  - "void expectFoo(args)", to be called before calling foo on the transform
//      layer; saves values of args, which mock layer foo then verifies against.
// - "void verifyFoo(T)", to be called after foo, which verifies that the
//      transform layer called the base layer and forwarded any return value.
class MockBaseLayer {
public:
  typedef int ObjSetHandleT;

  MockBaseLayer() : MockSymbol(nullptr) { resetExpectations(); }

  template <typename ObjSetT, typename MemoryManagerPtrT,
            typename SymbolResolverPtrT>
  ObjSetHandleT addObjectSet(ObjSetT &Objects, MemoryManagerPtrT MemMgr,
                             SymbolResolverPtrT Resolver) {
    EXPECT_EQ(MockManager, *MemMgr) << "MM should pass through";
    EXPECT_EQ(MockResolver, *Resolver) << "Resolver should pass through";
    size_t I = 0;
    for (auto &ObjPtr : Objects) {
      EXPECT_EQ(MockObjects[I++] + 1, *ObjPtr) << "Transform should be applied";
    }
    EXPECT_EQ(MockObjects.size(), I) << "Number of objects should match";
    LastCalled = "addObjectSet";
    MockObjSetHandle = 111;
    return MockObjSetHandle;
  }
  template <typename ObjSetT>
  void expectAddObjectSet(ObjSetT &Objects, MockMemoryManager *MemMgr,
                          MockSymbolResolver *Resolver) {
    MockManager = *MemMgr;
    MockResolver = *Resolver;
    for (auto &ObjPtr : Objects) {
      MockObjects.push_back(*ObjPtr);
    }
  }
  void verifyAddObjectSet(ObjSetHandleT Returned) {
    EXPECT_EQ("addObjectSet", LastCalled);
    EXPECT_EQ(MockObjSetHandle, Returned) << "Return should pass through";
    resetExpectations();
  }

  void removeObjectSet(ObjSetHandleT H) {
    EXPECT_EQ(MockObjSetHandle, H);
    LastCalled = "removeObjectSet";
  }
  void expectRemoveObjectSet(ObjSetHandleT H) { MockObjSetHandle = H; }
  void verifyRemoveObjectSet() {
    EXPECT_EQ("removeObjectSet", LastCalled);
    resetExpectations();
  }

  JITSymbol findSymbol(const std::string &Name, bool ExportedSymbolsOnly) {
    EXPECT_EQ(MockName, Name) << "Name should pass through";
    EXPECT_EQ(MockBool, ExportedSymbolsOnly) << "Flag should pass through";
    LastCalled = "findSymbol";
    MockSymbol = JITSymbol(122, llvm::JITSymbolFlags::None);
    return MockSymbol;
  }
  void expectFindSymbol(const std::string &Name, bool ExportedSymbolsOnly) {
    MockName = Name;
    MockBool = ExportedSymbolsOnly;
  }
  void verifyFindSymbol(llvm::orc::JITSymbol Returned) {
    EXPECT_EQ("findSymbol", LastCalled);
    EXPECT_EQ(MockSymbol.getAddress(), Returned.getAddress())
        << "Return should pass through";
    resetExpectations();
  }

  JITSymbol findSymbolIn(ObjSetHandleT H, const std::string &Name,
                         bool ExportedSymbolsOnly) {
    EXPECT_EQ(MockObjSetHandle, H) << "Handle should pass through";
    EXPECT_EQ(MockName, Name) << "Name should pass through";
    EXPECT_EQ(MockBool, ExportedSymbolsOnly) << "Flag should pass through";
    LastCalled = "findSymbolIn";
    MockSymbol = JITSymbol(122, llvm::JITSymbolFlags::None);
    return MockSymbol;
  }
  void expectFindSymbolIn(ObjSetHandleT H, const std::string &Name,
                          bool ExportedSymbolsOnly) {
    MockObjSetHandle = H;
    MockName = Name;
    MockBool = ExportedSymbolsOnly;
  }
  void verifyFindSymbolIn(llvm::orc::JITSymbol Returned) {
    EXPECT_EQ("findSymbolIn", LastCalled);
    EXPECT_EQ(MockSymbol.getAddress(), Returned.getAddress())
        << "Return should pass through";
    resetExpectations();
  }

  void emitAndFinalize(ObjSetHandleT H) {
    EXPECT_EQ(MockObjSetHandle, H) << "Handle should pass through";
    LastCalled = "emitAndFinalize";
  }
  void expectEmitAndFinalize(ObjSetHandleT H) { MockObjSetHandle = H; }
  void verifyEmitAndFinalize() {
    EXPECT_EQ("emitAndFinalize", LastCalled);
    resetExpectations();
  }

  void mapSectionAddress(ObjSetHandleT H, const void *LocalAddress,
                         TargetAddress TargetAddr) {
    EXPECT_EQ(MockObjSetHandle, H);
    EXPECT_EQ(MockLocalAddress, LocalAddress);
    EXPECT_EQ(MockTargetAddress, TargetAddr);
    LastCalled = "mapSectionAddress";
  }
  void expectMapSectionAddress(ObjSetHandleT H, const void *LocalAddress,
                               TargetAddress TargetAddr) {
    MockObjSetHandle = H;
    MockLocalAddress = LocalAddress;
    MockTargetAddress = TargetAddr;
  }
  void verifyMapSectionAddress() {
    EXPECT_EQ("mapSectionAddress", LastCalled);
    resetExpectations();
  }

private:
  // Backing fields for remembering parameter/return values
  std::string LastCalled;
  MockMemoryManager MockManager;
  MockSymbolResolver MockResolver;
  std::vector<MockObjectFile> MockObjects;
  ObjSetHandleT MockObjSetHandle;
  std::string MockName;
  bool MockBool;
  JITSymbol MockSymbol;
  const void *MockLocalAddress;
  TargetAddress MockTargetAddress;
  MockMemoryBufferSet MockBufferSet;

  // Clear remembered parameters between calls
  void resetExpectations() {
    LastCalled = "nothing";
    MockManager = 0;
    MockResolver = 0;
    MockObjects.clear();
    MockObjSetHandle = 0;
    MockName = "bogus";
    MockSymbol = JITSymbol(nullptr);
    MockLocalAddress = nullptr;
    MockTargetAddress = 0;
    MockBufferSet = 0;
  }
};

// Test each operation on ObjectTransformLayer.
TEST(ObjectTransformLayerTest, Main) {
  MockBaseLayer M;

  // Create one object transform layer using a transform (as a functor)
  // that allocates new objects, and deals in unique pointers.
  ObjectTransformLayer<MockBaseLayer, AllocatingTransform> T1(M);

  // Create a second object transform layer using a transform (as a lambda)
  // that mutates objects in place, and deals in naked pointers
  ObjectTransformLayer<MockBaseLayer,
                       std::function<MockObjectFile *(MockObjectFile *)>>
  T2(M, [](MockObjectFile *Obj) {
    ++(*Obj);
    return Obj;
  });

  // Instantiate some mock objects to use below
  MockObjectFile MockObject1 = 211;
  MockObjectFile MockObject2 = 222;
  MockMemoryManager MockManager = 233;
  MockSymbolResolver MockResolver = 244;

  // Test addObjectSet with T1 (allocating, unique pointers)
  std::vector<std::unique_ptr<MockObjectFile>> Objs1;
  Objs1.push_back(llvm::make_unique<MockObjectFile>(MockObject1));
  Objs1.push_back(llvm::make_unique<MockObjectFile>(MockObject2));
  auto MM = llvm::make_unique<MockMemoryManager>(MockManager);
  auto SR = llvm::make_unique<MockSymbolResolver>(MockResolver);
  M.expectAddObjectSet(Objs1, MM.get(), SR.get());
  auto H = T1.addObjectSet(Objs1, std::move(MM), std::move(SR));
  M.verifyAddObjectSet(H);

  // Test addObjectSet with T2 (mutating, naked pointers)
  llvm::SmallVector<MockObjectFile *, 2> Objs2;
  Objs2.push_back(&MockObject1);
  Objs2.push_back(&MockObject2);
  M.expectAddObjectSet(Objs2, &MockManager, &MockResolver);
  H = T2.addObjectSet(Objs2, &MockManager, &MockResolver);
  M.verifyAddObjectSet(H);
  EXPECT_EQ(212, MockObject1) << "Expected mutation";
  EXPECT_EQ(223, MockObject2) << "Expected mutation";

  // Test removeObjectSet
  M.expectRemoveObjectSet(H);
  T1.removeObjectSet(H);
  M.verifyRemoveObjectSet();

  // Test findSymbol
  std::string Name = "foo";
  bool ExportedOnly = true;
  M.expectFindSymbol(Name, ExportedOnly);
  JITSymbol Symbol = T2.findSymbol(Name, ExportedOnly);
  M.verifyFindSymbol(Symbol);

  // Test findSymbolIn
  Name = "bar";
  ExportedOnly = false;
  M.expectFindSymbolIn(H, Name, ExportedOnly);
  Symbol = T1.findSymbolIn(H, Name, ExportedOnly);
  M.verifyFindSymbolIn(Symbol);

  // Test emitAndFinalize
  M.expectEmitAndFinalize(H);
  T2.emitAndFinalize(H);
  M.verifyEmitAndFinalize();

  // Test mapSectionAddress
  char Buffer[24];
  TargetAddress MockAddress = 255;
  M.expectMapSectionAddress(H, Buffer, MockAddress);
  T1.mapSectionAddress(H, Buffer, MockAddress);
  M.verifyMapSectionAddress();

  // Verify transform getter (non-const)
  MockObjectFile Mutatee = 277;
  MockObjectFile *Out = T2.getTransform()(&Mutatee);
  EXPECT_EQ(&Mutatee, Out) << "Expected in-place transform";
  EXPECT_EQ(278, Mutatee) << "Expected incrementing transform";

  // Verify transform getter (const)
  auto OwnedObj = llvm::make_unique<MockObjectFile>(288);
  const auto &T1C = T1;
  OwnedObj = T1C.getTransform()(std::move(OwnedObj));
  EXPECT_EQ(289, *OwnedObj) << "Expected incrementing transform";
}
}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d10 1
a12 6
#include "llvm/ExecutionEngine/Orc/CompileUtils.h"
#include "llvm/ExecutionEngine/Orc/IRCompileLayer.h"
#include "llvm/ExecutionEngine/Orc/NullResolver.h"
#include "llvm/ExecutionEngine/Orc/ObjectLinkingLayer.h"
#include "llvm/ExecutionEngine/Orc/ObjectTransformLayer.h"
#include "llvm/Object/ObjectFile.h"
d54 1
a54 1
  ObjSetHandleT addObjectSet(ObjSetT Objects, MemoryManagerPtrT MemMgr,
d60 1
a60 2
      EXPECT_EQ(MockObjects[I] + 1, *ObjPtr) << "Transform should be applied";
      I++;
d219 1
a219 1
  auto H = T1.addObjectSet(std::move(Objs1), std::move(MM), std::move(SR));
d223 3
a225 4
  llvm::SmallVector<MockObjectFile *, 2> Objs2Vec;
  Objs2Vec.push_back(&MockObject1);
  Objs2Vec.push_back(&MockObject2);
  llvm::MutableArrayRef<MockObjectFile *> Objs2(Objs2Vec);
a273 56

  volatile bool RunStaticChecks = false;
  if (!RunStaticChecks)
    return;

  // Make sure that ObjectTransformLayer implements the object layer concept
  // correctly by sandwitching one between an ObjectLinkingLayer and an
  // IRCompileLayer, verifying that it compiles if we have a call to the
  // IRComileLayer's addModuleSet that should call the transform layer's
  // addObjectSet, and also calling the other public transform layer methods
  // directly to make sure the methods they intend to forward to exist on
  // the ObjectLinkingLayer.

  // We'll need a concrete MemoryManager class.
  class NullManager : public llvm::RuntimeDyld::MemoryManager {
  public:
    uint8_t *allocateCodeSection(uintptr_t, unsigned, unsigned,
                                 llvm::StringRef) override {
      return nullptr;
    }
    uint8_t *allocateDataSection(uintptr_t, unsigned, unsigned, llvm::StringRef,
                                 bool) override {
      return nullptr;
    }
    void registerEHFrames(uint8_t *, uint64_t, size_t) override {}
    void deregisterEHFrames(uint8_t *, uint64_t, size_t) override {}
    bool finalizeMemory(std::string *) override { return false; }
  };

  // Construct the jit layers.
  ObjectLinkingLayer<> BaseLayer;
  auto IdentityTransform = [](
      std::unique_ptr<llvm::object::OwningBinary<llvm::object::ObjectFile>>
          Obj) { return Obj; };
  ObjectTransformLayer<decltype(BaseLayer), decltype(IdentityTransform)>
      TransformLayer(BaseLayer, IdentityTransform);
  auto NullCompiler = [](llvm::Module &) {
    return llvm::object::OwningBinary<llvm::object::ObjectFile>();
  };
  IRCompileLayer<decltype(TransformLayer)> CompileLayer(TransformLayer,
                                                        NullCompiler);

  // Make sure that the calls from IRCompileLayer to ObjectTransformLayer
  // compile.
  NullResolver Resolver;
  NullManager Manager;
  CompileLayer.addModuleSet(std::vector<llvm::Module *>(), &Manager, &Resolver);

  // Make sure that the calls from ObjectTransformLayer to ObjectLinkingLayer
  // compile.
  decltype(TransformLayer)::ObjSetHandleT ObjSet;
  TransformLayer.emitAndFinalize(ObjSet);
  TransformLayer.findSymbolIn(ObjSet, Name, false);
  TransformLayer.findSymbol(Name, true);
  TransformLayer.mapSectionAddress(ObjSet, nullptr, 0);
  TransformLayer.removeObjectSet(ObjSet);
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d98 1
a98 2
  llvm::JITSymbol findSymbol(const std::string &Name,
                             bool ExportedSymbolsOnly) {
d102 1
a102 1
    MockSymbol = llvm::JITSymbol(122, llvm::JITSymbolFlags::None);
d109 1
a109 1
  void verifyFindSymbol(llvm::JITSymbol Returned) {
d116 2
a117 2
  llvm::JITSymbol findSymbolIn(ObjSetHandleT H, const std::string &Name,
                               bool ExportedSymbolsOnly) {
d122 1
a122 1
    MockSymbol = llvm::JITSymbol(122, llvm::JITSymbolFlags::None);
d131 1
a131 1
  void verifyFindSymbolIn(llvm::JITSymbol Returned) {
d149 1
a149 1
                         llvm::JITTargetAddress TargetAddr) {
d156 1
a156 1
                               llvm::JITTargetAddress TargetAddr) {
d175 1
a175 1
  llvm::JITSymbol MockSymbol;
d177 1
a177 1
  llvm::JITTargetAddress MockTargetAddress;
d188 1
a188 1
    MockSymbol = llvm::JITSymbol(nullptr);
d248 1
a248 1
  llvm::JITSymbol Symbol = T2.findSymbol(Name, ExportedOnly);
d265 1
a265 1
  llvm::JITTargetAddress MockAddress = 255;
@


1.1.1.4
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@a9 1
#include "llvm/ExecutionEngine/Orc/ObjectTransformLayer.h"
d15 2
a16 2
#include "llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h"
#include "llvm/ExecutionEngine/SectionMemoryManager.h"
d24 6
d34 1
a34 1
typedef int MockMemoryBuffer;
d39 3
a41 3
  std::shared_ptr<MockObjectFile>
  operator()(std::shared_ptr<MockObjectFile> Obj) const {
    return std::make_shared<MockObjectFile>(*Obj + 1);
d53 1
a53 1
  typedef int ObjHandleT;
d57 24
a80 16
  template <typename ObjPtrT>
  llvm::Expected<ObjHandleT>
  addObject(ObjPtrT Obj,
            std::shared_ptr<llvm::JITSymbolResolver> Resolver) {
    EXPECT_EQ(MockResolver, Resolver) << "Resolver should pass through";
    EXPECT_EQ(MockObject + 1, *Obj) << "Transform should be applied";
    LastCalled = "addObject";
    MockObjHandle = 111;
    return MockObjHandle;
  }

  template <typename ObjPtrT>
  void expectAddObject(ObjPtrT Obj,
                       std::shared_ptr<llvm::JITSymbolResolver> Resolver) {
    MockResolver = Resolver;
    MockObject = *Obj;
d82 3
a84 5


  void verifyAddObject(ObjHandleT Returned) {
    EXPECT_EQ("addObject", LastCalled);
    EXPECT_EQ(MockObjHandle, Returned) << "Return should pass through";
d88 7
a94 9
  llvm::Error removeObject(ObjHandleT H) {
    EXPECT_EQ(MockObjHandle, H);
    LastCalled = "removeObject";
    return llvm::Error::success();
  }

  void expectRemoveObject(ObjHandleT H) { MockObjHandle = H; }
  void verifyRemoveObject() {
    EXPECT_EQ("removeObject", LastCalled);
d104 1
a104 1
    return llvm::JITSymbol(122, llvm::JITSymbolFlags::None);
d112 1
a112 2
    EXPECT_EQ(cantFail(MockSymbol.getAddress()),
              cantFail(Returned.getAddress()))
d117 1
a117 1
  llvm::JITSymbol findSymbolIn(ObjHandleT H, const std::string &Name,
d119 1
a119 1
    EXPECT_EQ(MockObjHandle, H) << "Handle should pass through";
d124 1
a124 1
    return llvm::JITSymbol(122, llvm::JITSymbolFlags::None);
d126 1
a126 1
  void expectFindSymbolIn(ObjHandleT H, const std::string &Name,
d128 1
a128 1
    MockObjHandle = H;
d134 1
a134 2
    EXPECT_EQ(cantFail(MockSymbol.getAddress()),
              cantFail(Returned.getAddress()))
d139 2
a140 2
  llvm::Error emitAndFinalize(ObjHandleT H) {
    EXPECT_EQ(MockObjHandle, H) << "Handle should pass through";
a141 1
    return llvm::Error::success();
d143 1
a143 3

  void expectEmitAndFinalize(ObjHandleT H) { MockObjHandle = H; }

d149 1
a149 1
  void mapSectionAddress(ObjHandleT H, const void *LocalAddress,
d151 1
a151 1
    EXPECT_EQ(MockObjHandle, H);
d156 1
a156 1
  void expectMapSectionAddress(ObjHandleT H, const void *LocalAddress,
d158 1
a158 1
    MockObjHandle = H;
d170 4
a173 3
  std::shared_ptr<llvm::JITSymbolResolver> MockResolver;
  MockObjectFile MockObject;
  ObjHandleT MockObjHandle;
d179 1
a179 1
  MockMemoryBuffer MockBuffer;
d184 4
a187 3
    MockResolver = nullptr;
    MockObject = 0;
    MockObjHandle = 0;
d192 1
a192 1
    MockBuffer = 0;
d207 2
a208 3
                         std::function<std::shared_ptr<MockObjectFile>(
                           std::shared_ptr<MockObjectFile>)>>
    T2(M, [](std::shared_ptr<MockObjectFile> Obj) {
d213 26
a238 13
  // Test addObject with T1 (allocating)
  auto Obj1 = std::make_shared<MockObjectFile>(211);
  auto SR = std::make_shared<NullResolver>();
  M.expectAddObject(Obj1, SR);
  auto H = cantFail(T1.addObject(std::move(Obj1), SR));
  M.verifyAddObject(H);

  // Test addObjectSet with T2 (mutating)
  auto Obj2 = std::make_shared<MockObjectFile>(222);
  M.expectAddObject(Obj2, SR);
  H = cantFail(T2.addObject(Obj2, SR));
  M.verifyAddObject(H);
  EXPECT_EQ(223, *Obj2) << "Expected mutation";
d241 3
a243 3
  M.expectRemoveObject(H);
  cantFail(T1.removeObject(H));
  M.verifyRemoveObject();
d249 2
a250 2
  llvm::JITSymbol Sym1 = T2.findSymbol(Name, ExportedOnly);
  M.verifyFindSymbol(std::move(Sym1));
d256 2
a257 2
  llvm::JITSymbol Sym2 = T1.findSymbolIn(H, Name, ExportedOnly);
  M.verifyFindSymbolIn(std::move(Sym2));
d261 1
a261 1
  cantFail(T2.emitAndFinalize(H));
d272 4
a275 4
  auto Mutatee = std::make_shared<MockObjectFile>(277);
  auto Out = T2.getTransform()(Mutatee);
  EXPECT_EQ(*Mutatee, *Out) << "Expected in-place transform";
  EXPECT_EQ(278, *Mutatee) << "Expected incrementing transform";
d278 1
a278 1
  auto OwnedObj = std::make_shared<MockObjectFile>(288);
d290 2
a291 2
  // IRComileLayer's addModule that should call the transform layer's
  // addObject, and also calling the other public transform layer methods
d307 1
a307 1
    void deregisterEHFrames() override {}
d312 4
a315 10
  RTDyldObjectLinkingLayer BaseLayer(
    []() {
      return std::make_shared<llvm::SectionMemoryManager>();
    });

  auto IdentityTransform =
    [](std::shared_ptr<llvm::object::OwningBinary<llvm::object::ObjectFile>>
       Obj) {
      return Obj;
    };
d319 1
a319 2
    return llvm::object::OwningBinary<llvm::object::ObjectFile>(nullptr,
                                                                nullptr);
d321 2
a322 2
  IRCompileLayer<decltype(TransformLayer), decltype(NullCompiler)>
    CompileLayer(TransformLayer, NullCompiler);
d326 3
a328 2
  auto Resolver = std::make_shared<NullResolver>();
  cantFail(CompileLayer.addModule(std::shared_ptr<llvm::Module>(), Resolver));
d332 3
a334 3
  decltype(TransformLayer)::ObjHandleT H2;
  cantFail(TransformLayer.emitAndFinalize(H2));
  TransformLayer.findSymbolIn(H2, Name, false);
d336 2
a337 2
  TransformLayer.mapSectionAddress(H2, nullptr, 0);
  cantFail(TransformLayer.removeObject(H2));
@


