head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2_BASE:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.4
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.55;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.44;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.21;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===- unittest/ProfileData/CoverageMappingTest.cpp -------------------------=//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "llvm/ProfileData/CoverageMapping.h"
#include "llvm/ProfileData/CoverageMappingReader.h"
#include "llvm/ProfileData/CoverageMappingWriter.h"
#include "llvm/ProfileData/InstrProfReader.h"
#include "llvm/ProfileData/InstrProfWriter.h"
#include "llvm/Support/raw_ostream.h"
#include "gtest/gtest.h"

#include <sstream>

using namespace llvm;
using namespace coverage;

static ::testing::AssertionResult NoError(std::error_code EC) {
  if (!EC)
    return ::testing::AssertionSuccess();
  return ::testing::AssertionFailure() << "error " << EC.value()
                                       << ": " << EC.message();
}

namespace llvm {
namespace coverage {
void PrintTo(const Counter &C, ::std::ostream *os) {
  if (C.isZero())
    *os << "Zero";
  else if (C.isExpression())
    *os << "Expression " << C.getExpressionID();
  else
    *os << "Counter " << C.getCounterID();
}

void PrintTo(const CoverageSegment &S, ::std::ostream *os) {
  *os << "CoverageSegment(" << S.Line << ", " << S.Col << ", ";
  if (S.HasCount)
    *os << S.Count << ", ";
  *os << (S.IsRegionEntry ? "true" : "false") << ")";
}
}
}

namespace {

struct OneFunctionCoverageReader : CoverageMappingReader {
  StringRef Name;
  uint64_t Hash;
  std::vector<StringRef> Filenames;
  ArrayRef<CounterMappingRegion> Regions;
  bool Done;

  OneFunctionCoverageReader(StringRef Name, uint64_t Hash,
                            ArrayRef<StringRef> Filenames,
                            ArrayRef<CounterMappingRegion> Regions)
      : Name(Name), Hash(Hash), Filenames(Filenames), Regions(Regions),
        Done(false) {}

  std::error_code readNextRecord(CoverageMappingRecord &Record) override {
    if (Done)
      return instrprof_error::eof;
    Done = true;

    Record.FunctionName = Name;
    Record.FunctionHash = Hash;
    Record.Filenames = Filenames;
    Record.Expressions = {};
    Record.MappingRegions = Regions;
    return instrprof_error::success;
  }
};

struct CoverageMappingTest : ::testing::Test {
  StringMap<unsigned> Files;
  unsigned NextFile;
  std::vector<CounterMappingRegion> InputCMRs;

  std::vector<StringRef> OutputFiles;
  std::vector<CounterExpression> OutputExpressions;
  std::vector<CounterMappingRegion> OutputCMRs;

  InstrProfWriter ProfileWriter;
  std::unique_ptr<IndexedInstrProfReader> ProfileReader;

  std::unique_ptr<CoverageMapping> LoadedCoverage;

  void SetUp() override {
    NextFile = 0;
  }

  unsigned getFile(StringRef Name) {
    auto R = Files.find(Name);
    if (R != Files.end())
      return R->second;
    Files[Name] = NextFile;
    return NextFile++;
  }

  void addCMR(Counter C, StringRef File, unsigned LS, unsigned CS, unsigned LE,
              unsigned CE) {
    InputCMRs.push_back(
        CounterMappingRegion::makeRegion(C, getFile(File), LS, CS, LE, CE));
  }

  void addExpansionCMR(StringRef File, StringRef ExpandedFile, unsigned LS,
                       unsigned CS, unsigned LE, unsigned CE) {
    InputCMRs.push_back(CounterMappingRegion::makeExpansion(
        getFile(File), getFile(ExpandedFile), LS, CS, LE, CE));
  }

  std::string writeCoverageRegions() {
    SmallVector<unsigned, 8> FileIDs;
    for (const auto &E : Files)
      FileIDs.push_back(E.getValue());
    std::string Coverage;
    llvm::raw_string_ostream OS(Coverage);
    CoverageMappingWriter(FileIDs, None, InputCMRs).write(OS);
    return OS.str();
  }

  void readCoverageRegions(std::string Coverage) {
    SmallVector<StringRef, 8> Filenames;
    for (const auto &E : Files)
      Filenames.push_back(E.getKey());
    RawCoverageMappingReader Reader(Coverage, Filenames, OutputFiles,
                                    OutputExpressions, OutputCMRs);
    ASSERT_TRUE(NoError(Reader.read()));
  }

  void readProfCounts() {
    auto Profile = ProfileWriter.writeBuffer();
    auto ReaderOrErr = IndexedInstrProfReader::create(std::move(Profile));
    ASSERT_TRUE(NoError(ReaderOrErr.getError()));
    ProfileReader = std::move(ReaderOrErr.get());
  }

  void loadCoverageMapping(StringRef FuncName, uint64_t Hash) {
    std::string Regions = writeCoverageRegions();
    readCoverageRegions(Regions);

    SmallVector<StringRef, 8> Filenames;
    for (const auto &E : Files)
      Filenames.push_back(E.getKey());
    OneFunctionCoverageReader CovReader(FuncName, Hash, Filenames, OutputCMRs);
    auto CoverageOrErr = CoverageMapping::load(CovReader, *ProfileReader);
    ASSERT_TRUE(NoError(CoverageOrErr.getError()));
    LoadedCoverage = std::move(CoverageOrErr.get());
  }
};

TEST_F(CoverageMappingTest, basic_write_read) {
  addCMR(Counter::getCounter(0), "foo", 1, 1, 1, 1);
  addCMR(Counter::getCounter(1), "foo", 2, 1, 2, 2);
  addCMR(Counter::getZero(),     "foo", 3, 1, 3, 4);
  addCMR(Counter::getCounter(2), "foo", 4, 1, 4, 8);
  addCMR(Counter::getCounter(3), "bar", 1, 2, 3, 4);
  std::string Coverage = writeCoverageRegions();
  readCoverageRegions(Coverage);

  size_t N = makeArrayRef(InputCMRs).size();
  ASSERT_EQ(N, OutputCMRs.size());
  for (size_t I = 0; I < N; ++I) {
    ASSERT_EQ(InputCMRs[I].Count,      OutputCMRs[I].Count);
    ASSERT_EQ(InputCMRs[I].FileID,     OutputCMRs[I].FileID);
    ASSERT_EQ(InputCMRs[I].startLoc(), OutputCMRs[I].startLoc());
    ASSERT_EQ(InputCMRs[I].endLoc(),   OutputCMRs[I].endLoc());
    ASSERT_EQ(InputCMRs[I].Kind,       OutputCMRs[I].Kind);
  }
}

TEST_F(CoverageMappingTest, expansion_gets_first_counter) {
  addCMR(Counter::getCounter(1), "foo", 10, 1, 10, 2);
  // This starts earlier in "foo", so the expansion should get its counter.
  addCMR(Counter::getCounter(2), "foo", 1, 1, 20, 1);
  addExpansionCMR("bar", "foo", 3, 3, 3, 3);
  std::string Coverage = writeCoverageRegions();
  readCoverageRegions(Coverage);

  ASSERT_EQ(CounterMappingRegion::ExpansionRegion, OutputCMRs[2].Kind);
  ASSERT_EQ(Counter::getCounter(2), OutputCMRs[2].Count);
  ASSERT_EQ(3U, OutputCMRs[2].LineStart);
}

TEST_F(CoverageMappingTest, basic_coverage_iteration) {
  InstrProfRecord Record("func", 0x1234, {30, 20, 10, 0});
  ProfileWriter.addRecord(std::move(Record));
  readProfCounts();

  addCMR(Counter::getCounter(0), "file1", 1, 1, 9, 9);
  addCMR(Counter::getCounter(1), "file1", 1, 1, 4, 7);
  addCMR(Counter::getCounter(2), "file1", 5, 8, 9, 1);
  addCMR(Counter::getCounter(3), "file1", 10, 10, 11, 11);
  loadCoverageMapping("func", 0x1234);

  CoverageData Data = LoadedCoverage->getCoverageForFile("file1");
  std::vector<CoverageSegment> Segments(Data.begin(), Data.end());
  ASSERT_EQ(7U, Segments.size());
  ASSERT_EQ(CoverageSegment(1, 1, 20, true),  Segments[0]);
  ASSERT_EQ(CoverageSegment(4, 7, 30, false), Segments[1]);
  ASSERT_EQ(CoverageSegment(5, 8, 10, true),  Segments[2]);
  ASSERT_EQ(CoverageSegment(9, 1, 30, false), Segments[3]);
  ASSERT_EQ(CoverageSegment(9, 9, false),     Segments[4]);
  ASSERT_EQ(CoverageSegment(10, 10, 0, true), Segments[5]);
  ASSERT_EQ(CoverageSegment(11, 11, false),   Segments[6]);
}

TEST_F(CoverageMappingTest, uncovered_function) {
  readProfCounts();

  addCMR(Counter::getZero(), "file1", 1, 2, 3, 4);
  loadCoverageMapping("func", 0x1234);

  CoverageData Data = LoadedCoverage->getCoverageForFile("file1");
  std::vector<CoverageSegment> Segments(Data.begin(), Data.end());
  ASSERT_EQ(2U, Segments.size());
  ASSERT_EQ(CoverageSegment(1, 2, 0, true), Segments[0]);
  ASSERT_EQ(CoverageSegment(3, 4, false),   Segments[1]);
}

TEST_F(CoverageMappingTest, uncovered_function_with_mapping) {
  readProfCounts();

  addCMR(Counter::getCounter(0), "file1", 1, 1, 9, 9);
  addCMR(Counter::getCounter(1), "file1", 1, 1, 4, 7);
  loadCoverageMapping("func", 0x1234);

  CoverageData Data = LoadedCoverage->getCoverageForFile("file1");
  std::vector<CoverageSegment> Segments(Data.begin(), Data.end());
  ASSERT_EQ(3U, Segments.size());
  ASSERT_EQ(CoverageSegment(1, 1, 0, true),  Segments[0]);
  ASSERT_EQ(CoverageSegment(4, 7, 0, false), Segments[1]);
  ASSERT_EQ(CoverageSegment(9, 9, false),    Segments[2]);
}

TEST_F(CoverageMappingTest, combine_regions) {
  InstrProfRecord Record("func", 0x1234, {10, 20, 30});
  ProfileWriter.addRecord(std::move(Record));
  readProfCounts();

  addCMR(Counter::getCounter(0), "file1", 1, 1, 9, 9);
  addCMR(Counter::getCounter(1), "file1", 3, 3, 4, 4);
  addCMR(Counter::getCounter(2), "file1", 3, 3, 4, 4);
  loadCoverageMapping("func", 0x1234);

  CoverageData Data = LoadedCoverage->getCoverageForFile("file1");
  std::vector<CoverageSegment> Segments(Data.begin(), Data.end());
  ASSERT_EQ(4U, Segments.size());
  ASSERT_EQ(CoverageSegment(1, 1, 10, true), Segments[0]);
  ASSERT_EQ(CoverageSegment(3, 3, 50, true), Segments[1]);
  ASSERT_EQ(CoverageSegment(4, 4, 10, false), Segments[2]);
  ASSERT_EQ(CoverageSegment(9, 9, false), Segments[3]);
}

TEST_F(CoverageMappingTest, dont_combine_expansions) {
  InstrProfRecord Record("func", 0x1234, {10, 20});
  ProfileWriter.addRecord(std::move(Record));
  readProfCounts();

  addCMR(Counter::getCounter(0), "file1", 1, 1, 9, 9);
  addCMR(Counter::getCounter(1), "file1", 3, 3, 4, 4);
  addCMR(Counter::getCounter(1), "include1", 6, 6, 7, 7);
  addExpansionCMR("file1", "include1", 3, 3, 4, 4);
  loadCoverageMapping("func", 0x1234);

  CoverageData Data = LoadedCoverage->getCoverageForFile("file1");
  std::vector<CoverageSegment> Segments(Data.begin(), Data.end());
  ASSERT_EQ(4U, Segments.size());
  ASSERT_EQ(CoverageSegment(1, 1, 10, true), Segments[0]);
  ASSERT_EQ(CoverageSegment(3, 3, 20, true), Segments[1]);
  ASSERT_EQ(CoverageSegment(4, 4, 10, false), Segments[2]);
  ASSERT_EQ(CoverageSegment(9, 9, false), Segments[3]);
}

TEST_F(CoverageMappingTest, strip_filename_prefix) {
  InstrProfRecord Record("file1:func", 0x1234, {10});
  ProfileWriter.addRecord(std::move(Record));
  readProfCounts();

  addCMR(Counter::getCounter(0), "file1", 1, 1, 9, 9);
  loadCoverageMapping("file1:func", 0x1234);

  std::vector<std::string> Names;
  for (const auto &Func : LoadedCoverage->getCoveredFunctions())
    Names.push_back(Func.Name);
  ASSERT_EQ(1U, Names.size());
  ASSERT_EQ("func", Names[0]);
}

} // end anonymous namespace
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d10 3
a12 3
#include "llvm/ProfileData/Coverage/CoverageMapping.h"
#include "llvm/ProfileData/Coverage/CoverageMappingReader.h"
#include "llvm/ProfileData/Coverage/CoverageMappingWriter.h"
d18 1
a18 1
#include <ostream>
d23 2
a24 2
static ::testing::AssertionResult NoError(Error E) {
  if (!E)
d26 2
a27 2
  return ::testing::AssertionFailure() << "error: " << toString(std::move(E))
                                       << "\n";
d52 1
a52 1
struct OutputFunctionCoverageData {
d56 13
a68 1
  std::vector<CounterMappingRegion> Regions;
a69 1
  void fillCoverageMappingRecord(CoverageMappingRecord &Record) const {
d75 1
a78 33
struct CoverageMappingReaderMock : CoverageMappingReader {
  ArrayRef<OutputFunctionCoverageData> Functions;

  CoverageMappingReaderMock(ArrayRef<OutputFunctionCoverageData> Functions)
      : Functions(Functions) {}

  Error readNextRecord(CoverageMappingRecord &Record) override {
    if (Functions.empty())
      return make_error<CoverageMapError>(coveragemap_error::eof);

    Functions.front().fillCoverageMappingRecord(Record);
    Functions = Functions.slice(1);

    return Error::success();
  }
};

struct InputFunctionCoverageData {
  // Maps the global file index from CoverageMappingTest.Files
  // to the index of that file within this function. We can't just use
  // global file indexes here because local indexes have to be dense.
  // This map is used during serialization to create the virtual file mapping
  // (from local fileId to global Index) in the head of the per-function
  // coverage mapping data.
  SmallDenseMap<unsigned, unsigned> ReverseVirtualFileMapping;
  std::string Name;
  uint64_t Hash;
  std::vector<CounterMappingRegion> Regions;

  InputFunctionCoverageData(std::string Name, uint64_t Hash)
      : Name(std::move(Name)), Hash(Hash) {}
};

d81 6
a86 2
  std::vector<InputFunctionCoverageData> InputFunctions;
  std::vector<OutputFunctionCoverageData> OutputFunctions;
d94 1
a94 1
    ProfileWriter.setOutputSparse(false);
d97 1
a97 1
  unsigned getGlobalFileIndex(StringRef Name) {
d101 2
a102 24
    unsigned Index = Files.size();
    Files.emplace_second(Name, Index);
    return Index;
  }

  // Return the file index of file 'Name' for the current function.
  // Add the file into the global map if necesary.
  // See also InputFunctionCoverageData::ReverseVirtualFileMapping
  // for additional comments.
  unsigned getFileIndexForFunction(StringRef Name) {
    unsigned GlobalIndex = getGlobalFileIndex(Name);
    auto &CurrentFunctionFileMapping =
        InputFunctions.back().ReverseVirtualFileMapping;
    auto R = CurrentFunctionFileMapping.find(GlobalIndex);
    if (R != CurrentFunctionFileMapping.end())
      return R->second;
    unsigned IndexInFunction = CurrentFunctionFileMapping.size();
    CurrentFunctionFileMapping.insert(
        std::make_pair(GlobalIndex, IndexInFunction));
    return IndexInFunction;
  }

  void startFunction(StringRef FuncName, uint64_t Hash) {
    InputFunctions.emplace_back(FuncName.str(), Hash);
d107 2
a108 2
    InputFunctions.back().Regions.push_back(CounterMappingRegion::makeRegion(
        C, getFileIndexForFunction(File), LS, CS, LE, CE));
d113 2
a114 3
    InputFunctions.back().Regions.push_back(CounterMappingRegion::makeExpansion(
        getFileIndexForFunction(File), getFileIndexForFunction(ExpandedFile),
        LS, CS, LE, CE));
d117 4
a120 4
  std::string writeCoverageRegions(InputFunctionCoverageData &Data) {
    SmallVector<unsigned, 8> FileIDs(Data.ReverseVirtualFileMapping.size());
    for (const auto &E : Data.ReverseVirtualFileMapping)
      FileIDs[E.second] = E.first;
d123 1
a123 1
    CoverageMappingWriter(FileIDs, None, Data.Regions).write(OS);
d127 2
a128 3
  void readCoverageRegions(std::string Coverage,
                           OutputFunctionCoverageData &Data) {
    SmallVector<StringRef, 8> Filenames(Files.size());
d130 3
a132 4
      Filenames[E.getValue()] = E.getKey();
    std::vector<CounterExpression> Expressions;
    RawCoverageMappingReader Reader(Coverage, Filenames, Data.Filenames,
                                    Expressions, Data.Regions);
a135 12
  void writeAndReadCoverageRegions(bool EmitFilenames = true) {
    OutputFunctions.resize(InputFunctions.size());
    for (unsigned I = 0; I < InputFunctions.size(); ++I) {
      std::string Regions = writeCoverageRegions(InputFunctions[I]);
      readCoverageRegions(Regions, OutputFunctions[I]);
      OutputFunctions[I].Name = InputFunctions[I].Name;
      OutputFunctions[I].Hash = InputFunctions[I].Hash;
      if (!EmitFilenames)
        OutputFunctions[I].Filenames.clear();
    }
  }

d139 1
a139 1
    ASSERT_TRUE(NoError(ReaderOrErr.takeError()));
d143 3
a145 3
  void loadCoverageMapping(bool EmitFilenames = true) {
    readProfCounts();
    writeAndReadCoverageRegions(EmitFilenames);
d147 4
a150 1
    CoverageMappingReaderMock CovReader(OutputFunctions);
d152 1
a152 1
    ASSERT_TRUE(NoError(CoverageOrErr.takeError()));
d157 1
a157 11
struct MaybeSparseCoverageMappingTest
    : public CoverageMappingTest,
      public ::testing::WithParamInterface<bool> {
  void SetUp() {
    CoverageMappingTest::SetUp();
    ProfileWriter.setOutputSparse(GetParam());
  }
};

TEST_P(MaybeSparseCoverageMappingTest, basic_write_read) {
  startFunction("func", 0x1234);
d163 2
d166 2
a167 8
  writeAndReadCoverageRegions();
  ASSERT_EQ(1u, InputFunctions.size());
  ASSERT_EQ(1u, OutputFunctions.size());
  InputFunctionCoverageData &Input = InputFunctions.back();
  OutputFunctionCoverageData &Output = OutputFunctions.back();

  size_t N = makeArrayRef(Input.Regions).size();
  ASSERT_EQ(N, Output.Regions.size());
d169 5
a173 31
    ASSERT_EQ(Input.Regions[I].Count, Output.Regions[I].Count);
    ASSERT_EQ(Input.Regions[I].FileID, Output.Regions[I].FileID);
    ASSERT_EQ(Input.Regions[I].startLoc(), Output.Regions[I].startLoc());
    ASSERT_EQ(Input.Regions[I].endLoc(), Output.Regions[I].endLoc());
    ASSERT_EQ(Input.Regions[I].Kind, Output.Regions[I].Kind);
  }
}

TEST_P(MaybeSparseCoverageMappingTest,
       correct_deserialize_for_more_than_two_files) {
  const char *FileNames[] = {"bar", "baz", "foo"};
  static const unsigned N = array_lengthof(FileNames);

  startFunction("func", 0x1234);
  for (unsigned I = 0; I < N; ++I)
    // Use LineStart to hold the index of the file name
    // in order to preserve that information during possible sorting of CMRs.
    addCMR(Counter::getCounter(0), FileNames[I], I, 1, I, 1);

  writeAndReadCoverageRegions();
  ASSERT_EQ(1u, OutputFunctions.size());
  OutputFunctionCoverageData &Output = OutputFunctions.back();

  ASSERT_EQ(N, Output.Regions.size());
  ASSERT_EQ(N, Output.Filenames.size());

  for (unsigned I = 0; I < N; ++I) {
    ASSERT_GT(N, Output.Regions[I].FileID);
    ASSERT_GT(N, Output.Regions[I].LineStart);
    EXPECT_EQ(FileNames[Output.Regions[I].LineStart],
              Output.Filenames[Output.Regions[I].FileID]);
d177 1
a177 55
TEST_P(MaybeSparseCoverageMappingTest, load_coverage_for_more_than_two_files) {
  InstrProfRecord Record("func", 0x1234, {0});
  NoError(ProfileWriter.addRecord(std::move(Record)));

  const char *FileNames[] = {"bar", "baz", "foo"};
  static const unsigned N = array_lengthof(FileNames);

  startFunction("func", 0x1234);
  for (unsigned I = 0; I < N; ++I)
    // Use LineStart to hold the index of the file name
    // in order to preserve that information during possible sorting of CMRs.
    addCMR(Counter::getCounter(0), FileNames[I], I, 1, I, 1);

  loadCoverageMapping();

  for (unsigned I = 0; I < N; ++I) {
    CoverageData Data = LoadedCoverage->getCoverageForFile(FileNames[I]);
    ASSERT_TRUE(!Data.empty());
    EXPECT_EQ(I, Data.begin()->Line);
  }
}

TEST_P(MaybeSparseCoverageMappingTest, load_coverage_for_several_functions) {
  InstrProfRecord RecordFunc1("func1", 0x1234, {10});
  NoError(ProfileWriter.addRecord(std::move(RecordFunc1)));
  InstrProfRecord RecordFunc2("func2", 0x2345, {20});
  NoError(ProfileWriter.addRecord(std::move(RecordFunc2)));

  startFunction("func1", 0x1234);
  addCMR(Counter::getCounter(0), "foo", 1, 1, 5, 5);

  startFunction("func2", 0x2345);
  addCMR(Counter::getCounter(0), "bar", 2, 2, 6, 6);

  loadCoverageMapping();

  const auto FunctionRecords = LoadedCoverage->getCoveredFunctions();
  EXPECT_EQ(2U, std::distance(FunctionRecords.begin(), FunctionRecords.end()));
  for (const auto &FunctionRecord : FunctionRecords) {
    CoverageData Data = LoadedCoverage->getCoverageForFunction(FunctionRecord);
    std::vector<CoverageSegment> Segments(Data.begin(), Data.end());
    ASSERT_EQ(2U, Segments.size());
    if (FunctionRecord.Name == "func1") {
      EXPECT_EQ(CoverageSegment(1, 1, 10, true), Segments[0]);
      EXPECT_EQ(CoverageSegment(5, 5, false), Segments[1]);
    } else {
      ASSERT_EQ("func2", FunctionRecord.Name);
      EXPECT_EQ(CoverageSegment(2, 2, 20, true), Segments[0]);
      EXPECT_EQ(CoverageSegment(6, 6, false), Segments[1]);
    }
  }
}

TEST_P(MaybeSparseCoverageMappingTest, expansion_gets_first_counter) {
  startFunction("func", 0x1234);
d182 2
d185 3
a187 7
  writeAndReadCoverageRegions();
  ASSERT_EQ(1u, OutputFunctions.size());
  OutputFunctionCoverageData &Output = OutputFunctions.back();

  ASSERT_EQ(CounterMappingRegion::ExpansionRegion, Output.Regions[2].Kind);
  ASSERT_EQ(Counter::getCounter(2), Output.Regions[2].Count);
  ASSERT_EQ(3U, Output.Regions[2].LineStart);
d190 1
a190 1
TEST_P(MaybeSparseCoverageMappingTest, basic_coverage_iteration) {
d192 2
a193 1
  NoError(ProfileWriter.addRecord(std::move(Record)));
a194 1
  startFunction("func", 0x1234);
d199 1
a199 1
  loadCoverageMapping();
d213 3
a215 2
TEST_P(MaybeSparseCoverageMappingTest, uncovered_function) {
  startFunction("func", 0x1234);
d217 1
a217 1
  loadCoverageMapping();
d226 3
a228 2
TEST_P(MaybeSparseCoverageMappingTest, uncovered_function_with_mapping) {
  startFunction("func", 0x1234);
d231 1
a231 1
  loadCoverageMapping();
d241 1
a241 1
TEST_P(MaybeSparseCoverageMappingTest, combine_regions) {
d243 2
a244 1
  NoError(ProfileWriter.addRecord(std::move(Record)));
a245 1
  startFunction("func", 0x1234);
d249 1
a249 1
  loadCoverageMapping();
d260 4
a263 27
TEST_P(MaybeSparseCoverageMappingTest,
       restore_combined_counter_after_nested_region) {
  InstrProfRecord Record("func", 0x1234, {10, 20, 40});
  NoError(ProfileWriter.addRecord(std::move(Record)));

  startFunction("func", 0x1234);
  addCMR(Counter::getCounter(0), "file1", 1, 1, 9, 9);
  addCMR(Counter::getCounter(1), "file1", 1, 1, 9, 9);
  addCMR(Counter::getCounter(2), "file1", 3, 3, 5, 5);
  loadCoverageMapping();

  CoverageData Data = LoadedCoverage->getCoverageForFile("file1");
  std::vector<CoverageSegment> Segments(Data.begin(), Data.end());
  ASSERT_EQ(4U, Segments.size());
  EXPECT_EQ(CoverageSegment(1, 1, 30, true), Segments[0]);
  EXPECT_EQ(CoverageSegment(3, 3, 40, true), Segments[1]);
  EXPECT_EQ(CoverageSegment(5, 5, 30, false), Segments[2]);
  EXPECT_EQ(CoverageSegment(9, 9, false), Segments[3]);
}

// If CodeRegions and ExpansionRegions cover the same area,
// only counts of CodeRegions should be used.
TEST_P(MaybeSparseCoverageMappingTest, dont_combine_expansions) {
  InstrProfRecord Record1("func", 0x1234, {10, 20});
  InstrProfRecord Record2("func", 0x1234, {0, 0});
  NoError(ProfileWriter.addRecord(std::move(Record1)));
  NoError(ProfileWriter.addRecord(std::move(Record2)));
a264 1
  startFunction("func", 0x1234);
d269 1
a269 1
  loadCoverageMapping();
d280 4
a283 13
// If an area is covered only by ExpansionRegions, they should be combinated.
TEST_P(MaybeSparseCoverageMappingTest, combine_expansions) {
  InstrProfRecord Record("func", 0x1234, {2, 3, 7});
  NoError(ProfileWriter.addRecord(std::move(Record)));

  startFunction("func", 0x1234);
  addCMR(Counter::getCounter(1), "include1", 1, 1, 1, 10);
  addCMR(Counter::getCounter(2), "include2", 1, 1, 1, 10);
  addCMR(Counter::getCounter(0), "file", 1, 1, 5, 5);
  addExpansionCMR("file", "include1", 3, 1, 3, 5);
  addExpansionCMR("file", "include2", 3, 1, 3, 5);

  loadCoverageMapping();
a284 14
  CoverageData Data = LoadedCoverage->getCoverageForFile("file");
  std::vector<CoverageSegment> Segments(Data.begin(), Data.end());
  ASSERT_EQ(4U, Segments.size());
  EXPECT_EQ(CoverageSegment(1, 1, 2, true), Segments[0]);
  EXPECT_EQ(CoverageSegment(3, 1, 10, true), Segments[1]);
  EXPECT_EQ(CoverageSegment(3, 5, 2, false), Segments[2]);
  EXPECT_EQ(CoverageSegment(5, 5, false), Segments[3]);
}

TEST_P(MaybeSparseCoverageMappingTest, strip_filename_prefix) {
  InstrProfRecord Record("file1:func", 0x1234, {0});
  NoError(ProfileWriter.addRecord(std::move(Record)));

  startFunction("file1:func", 0x1234);
d286 1
a286 1
  loadCoverageMapping();
a293 56

TEST_P(MaybeSparseCoverageMappingTest, strip_unknown_filename_prefix) {
  InstrProfRecord Record("<unknown>:func", 0x1234, {0});
  NoError(ProfileWriter.addRecord(std::move(Record)));

  startFunction("<unknown>:func", 0x1234);
  addCMR(Counter::getCounter(0), "", 1, 1, 9, 9);
  loadCoverageMapping(/*EmitFilenames=*/false);

  std::vector<std::string> Names;
  for (const auto &Func : LoadedCoverage->getCoveredFunctions())
    Names.push_back(Func.Name);
  ASSERT_EQ(1U, Names.size());
  ASSERT_EQ("func", Names[0]);
}

TEST_P(MaybeSparseCoverageMappingTest, dont_detect_false_instantiations) {
  InstrProfRecord Record1("foo", 0x1234, {10});
  InstrProfRecord Record2("bar", 0x2345, {20});
  NoError(ProfileWriter.addRecord(std::move(Record1)));
  NoError(ProfileWriter.addRecord(std::move(Record2)));

  startFunction("foo", 0x1234);
  addCMR(Counter::getCounter(0), "expanded", 1, 1, 1, 10);
  addExpansionCMR("main", "expanded", 4, 1, 4, 5);

  startFunction("bar", 0x2345);
  addCMR(Counter::getCounter(0), "expanded", 1, 1, 1, 10);
  addExpansionCMR("main", "expanded", 9, 1, 9, 5);

  loadCoverageMapping();

  std::vector<const FunctionRecord *> Instantiations =
      LoadedCoverage->getInstantiations("expanded");
  ASSERT_TRUE(Instantiations.empty());
}

TEST_P(MaybeSparseCoverageMappingTest, load_coverage_for_expanded_file) {
  InstrProfRecord Record("func", 0x1234, {10});
  NoError(ProfileWriter.addRecord(std::move(Record)));

  startFunction("func", 0x1234);
  addCMR(Counter::getCounter(0), "expanded", 1, 1, 1, 10);
  addExpansionCMR("main", "expanded", 4, 1, 4, 5);

  loadCoverageMapping();

  CoverageData Data = LoadedCoverage->getCoverageForFile("expanded");
  std::vector<CoverageSegment> Segments(Data.begin(), Data.end());
  ASSERT_EQ(2U, Segments.size());
  EXPECT_EQ(CoverageSegment(1, 1, 10, true), Segments[0]);
  EXPECT_EQ(CoverageSegment(1, 10, false), Segments[1]);
}

INSTANTIATE_TEST_CASE_P(MaybeSparse, MaybeSparseCoverageMappingTest,
                        ::testing::Bool());
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a18 1
#include <utility>
a57 11
  OutputFunctionCoverageData() : Hash(0) {}

  OutputFunctionCoverageData(OutputFunctionCoverageData &&OFCD)
      : Name(OFCD.Name), Hash(OFCD.Hash), Filenames(std::move(OFCD.Filenames)),
        Regions(std::move(OFCD.Regions)) {}

  OutputFunctionCoverageData(const OutputFunctionCoverageData &) = delete;
  OutputFunctionCoverageData &
  operator=(const OutputFunctionCoverageData &) = delete;
  OutputFunctionCoverageData &operator=(OutputFunctionCoverageData &&) = delete;

a97 10

  InputFunctionCoverageData(InputFunctionCoverageData &&IFCD)
      : ReverseVirtualFileMapping(std::move(IFCD.ReverseVirtualFileMapping)),
        Name(std::move(IFCD.Name)), Hash(IFCD.Hash),
        Regions(std::move(IFCD.Regions)) {}

  InputFunctionCoverageData(const InputFunctionCoverageData &) = delete;
  InputFunctionCoverageData &
  operator=(const InputFunctionCoverageData &) = delete;
  InputFunctionCoverageData &operator=(InputFunctionCoverageData &&) = delete;
d100 1
a100 2
struct CoverageMappingTest : ::testing::TestWithParam<std::pair<bool, bool>> {
  bool UseMultipleReaders;
d111 1
a111 2
    ProfileWriter.setOutputSparse(GetParam().first);
    UseMultipleReaders = GetParam().second;
d119 1
a119 1
    Files.try_emplace(Name, Index);
d124 1
a124 1
  // Add the file into the global map if necessary.
d167 1
a167 1
  void readCoverageRegions(const std::string &Coverage,
a196 14
  Expected<std::unique_ptr<CoverageMapping>> readOutputFunctions() {
    if (!UseMultipleReaders) {
      CoverageMappingReaderMock CovReader(OutputFunctions);
      return CoverageMapping::load(CovReader, *ProfileReader);
    }

    std::vector<std::unique_ptr<CoverageMappingReader>> CoverageReaders;
    for (const auto &OF : OutputFunctions) {
      ArrayRef<OutputFunctionCoverageData> Funcs(OF);
      CoverageReaders.push_back(make_unique<CoverageMappingReaderMock>(Funcs));
    }
    return CoverageMapping::load(CoverageReaders, *ProfileReader);
  }

d200 3
a202 1
    auto CoverageOrErr = readOutputFunctions();
d208 10
a217 1
TEST_P(CoverageMappingTest, basic_write_read) {
d242 2
a243 1
TEST_P(CoverageMappingTest, correct_deserialize_for_more_than_two_files) {
d268 1
a268 1
TEST_P(CoverageMappingTest, load_coverage_for_more_than_two_files) {
d290 1
a290 1
TEST_P(CoverageMappingTest, load_coverage_for_several_functions) {
d321 1
a321 1
TEST_P(CoverageMappingTest, expansion_gets_first_counter) {
d337 1
a337 1
TEST_P(CoverageMappingTest, basic_coverage_iteration) {
d360 1
a360 1
TEST_P(CoverageMappingTest, uncovered_function) {
d372 1
a372 1
TEST_P(CoverageMappingTest, uncovered_function_with_mapping) {
d386 1
a386 1
TEST_P(CoverageMappingTest, combine_regions) {
d405 2
a406 1
TEST_P(CoverageMappingTest, restore_combined_counter_after_nested_region) {
d427 1
a427 1
TEST_P(CoverageMappingTest, dont_combine_expansions) {
d450 1
a450 1
TEST_P(CoverageMappingTest, combine_expansions) {
d472 1
a472 1
TEST_P(CoverageMappingTest, strip_filename_prefix) {
d487 1
a487 1
TEST_P(CoverageMappingTest, strip_unknown_filename_prefix) {
d502 1
a502 1
TEST_P(CoverageMappingTest, dont_detect_false_instantiations) {
d523 1
a523 1
TEST_P(CoverageMappingTest, load_coverage_for_expanded_file) {
d540 2
a541 23
TEST_P(CoverageMappingTest, skip_duplicate_function_record) {
  InstrProfRecord Record("func", 0x1234, {1});
  NoError(ProfileWriter.addRecord(std::move(Record)));

  startFunction("func", 0x1234);
  addCMR(Counter::getCounter(0), "file1", 1, 1, 9, 9);

  startFunction("func", 0x1234);
  addCMR(Counter::getCounter(0), "file1", 1, 1, 9, 9);

  loadCoverageMapping();

  auto Funcs = LoadedCoverage->getCoveredFunctions();
  unsigned NumFuncs = std::distance(Funcs.begin(), Funcs.end());
  ASSERT_EQ(1U, NumFuncs);
}

// FIXME: Use ::testing::Combine() when llvm updates its copy of googletest.
INSTANTIATE_TEST_CASE_P(ParameterizedCovMapTest, CoverageMappingTest,
                        ::testing::Values(std::pair<bool, bool>({false, false}),
                                          std::pair<bool, bool>({false, true}),
                                          std::pair<bool, bool>({true, false}),
                                          std::pair<bool, bool>({true, true})));
@


