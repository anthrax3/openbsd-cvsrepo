head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.2
	OPENBSD_6_2:1.1.1.1.0.2
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.4
	OPENBSD_6_1_BASE:1.1.1.1
	LLVM_4_0_0:1.1.1.1
	LLVM_4_0_0_RC1:1.1.1.1
	LLVM_3_9_1:1.1.1.1
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2016.09.03.22.46.59;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.59;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.10.04.20.27.57;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@=====================
How To Use Attributes
=====================

.. contents::
  :local:

Introduction
============

Attributes in LLVM have changed in some fundamental ways.  It was necessary to
do this to support expanding the attributes to encompass more than a handful of
attributes --- e.g. command line options.  The old way of handling attributes
consisted of representing them as a bit mask of values.  This bit mask was
stored in a "list" structure that was reference counted.  The advantage of this
was that attributes could be manipulated with 'or's and 'and's.  The
disadvantage of this was that there was limited room for expansion, and
virtually no support for attribute-value pairs other than alignment.

In the new scheme, an ``Attribute`` object represents a single attribute that's
uniqued.  You use the ``Attribute::get`` methods to create a new ``Attribute``
object.  An attribute can be a single "enum" value (the enum being the
``Attribute::AttrKind`` enum), a string representing a target-dependent
attribute, or an attribute-value pair.  Some examples:

* Target-independent: ``noinline``, ``zext``
* Target-dependent: ``"no-sse"``, ``"thumb2"``
* Attribute-value pair: ``"cpu" = "cortex-a8"``, ``align = 4``

Note: for an attribute value pair, we expect a target-dependent attribute to
have a string for the value.

``Attribute``
=============
An ``Attribute`` object is designed to be passed around by value.

Because attributes are no longer represented as a bit mask, you will need to
convert any code which does treat them as a bit mask to use the new query
methods on the Attribute class.

``AttributeSet``
================

The ``AttributeSet`` class replaces the old ``AttributeList`` class.  The
``AttributeSet`` stores a collection of Attribute objects for each kind of
object that may have an attribute associated with it: the function as a
whole, the return type, or the function's parameters.  A function's attributes
are at index ``AttributeSet::FunctionIndex``; the return type's attributes are
at index ``AttributeSet::ReturnIndex``; and the function's parameters'
attributes are at indices 1, ..., n (where 'n' is the number of parameters).
Most methods on the ``AttributeSet`` class take an index parameter.

An ``AttributeSet`` is also a uniqued and immutable object.  You create an
``AttributeSet`` through the ``AttributeSet::get`` methods.  You can add and
remove attributes, which result in the creation of a new ``AttributeSet``.

An ``AttributeSet`` object is designed to be passed around by value.

Note: It is advised that you do *not* use the ``AttributeSet`` "introspection"
methods (e.g. ``Raw``, ``getRawPointer``, etc.).  These methods break
encapsulation, and may be removed in a future release (i.e. LLVM 4.0).

``AttrBuilder``
===============

Lastly, we have a "builder" class to help create the ``AttributeSet`` object
without having to create several different intermediate uniqued
``AttributeSet`` objects.  The ``AttrBuilder`` class allows you to add and
remove attributes at will.  The attributes won't be uniqued until you call the
appropriate ``AttributeSet::get`` method.

An ``AttrBuilder`` object is *not* designed to be passed around by value.  It
should be passed by reference.

Note: It is advised that you do *not* use the ``AttrBuilder::addRawValue()``
method or the ``AttrBuilder(uint64_t Val)`` constructor.  These are for
backwards compatibility and may be removed in a future release (i.e. LLVM 4.0).

And that's basically it! A lot of functionality is hidden behind these classes,
but the interfaces are pretty straight forward.

@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@d41 2
a42 2
``AttributeList``
=================
d44 12
a55 11
The ``AttributeList`` stores a collection of Attribute objects for each kind of
object that may have an attribute associated with it: the function as a whole,
the return type, or the function's parameters.  A function's attributes are at
index ``AttributeList::FunctionIndex``; the return type's attributes are at
index ``AttributeList::ReturnIndex``; and the function's parameters' attributes
are at indices 1, ..., n (where 'n' is the number of parameters).  Most methods
on the ``AttributeList`` class take an index parameter.

An ``AttributeList`` is also a uniqued and immutable object.  You create an
``AttributeList`` through the ``AttributeList::get`` methods.  You can add and
remove attributes, which result in the creation of a new ``AttributeList``.
d57 1
a57 1
An ``AttributeList`` object is designed to be passed around by value.
d59 1
a59 1
Note: It is advised that you do *not* use the ``AttributeList`` "introspection"
d66 1
a66 1
Lastly, we have a "builder" class to help create the ``AttributeList`` object
d68 1
a68 1
``AttributeList`` objects.  The ``AttrBuilder`` class allows you to add and
d70 1
a70 1
appropriate ``AttributeList::get`` method.
@

