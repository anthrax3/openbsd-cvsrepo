head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.3.0.6
	OPENBSD_6_2_BASE:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.4
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.09.03.22.46.59;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.59;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.58;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.14;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@//===- CodeGenIntrinsic.h - Intrinsic Class Wrapper ------------*- C++ -*--===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines a wrapper class for the 'Intrinsic' TableGen class.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_UTILS_TABLEGEN_CODEGENINTRINSICS_H
#define LLVM_UTILS_TABLEGEN_CODEGENINTRINSICS_H

#include "llvm/CodeGen/MachineValueType.h"
#include <string>
#include <vector>

namespace llvm {
  class Record;
  class RecordKeeper;
  class CodeGenTarget;

  struct CodeGenIntrinsic {
    Record *TheDef;            // The actual record defining this intrinsic.
    std::string Name;          // The name of the LLVM function "llvm.bswap.i32"
    std::string EnumName;      // The name of the enum "bswap_i32"
    std::string GCCBuiltinName;// Name of the corresponding GCC builtin, or "".
    std::string MSBuiltinName; // Name of the corresponding MS builtin, or "".
    std::string TargetPrefix;  // Target prefix, e.g. "ppc" for t-s intrinsics.

    /// IntrinsicSignature - This structure holds the return values and
    /// parameter values of an intrinsic. If the number of return values is > 1,
    /// then the intrinsic implicitly returns a first-class aggregate. The
    /// numbering of the types starts at 0 with the first return value and
    /// continues from there through the parameter list. This is useful for
    /// "matching" types.
    struct IntrinsicSignature {
      /// RetVTs - The MVT::SimpleValueType for each return type. Note that this
      /// list is only populated when in the context of a target .td file. When
      /// building Intrinsics.td, this isn't available, because we don't know
      /// the target pointer size.
      std::vector<MVT::SimpleValueType> RetVTs;

      /// RetTypeDefs - The records for each return type.
      std::vector<Record*> RetTypeDefs;

      /// ParamVTs - The MVT::SimpleValueType for each parameter type. Note that
      /// this list is only populated when in the context of a target .td file.
      /// When building Intrinsics.td, this isn't available, because we don't
      /// know the target pointer size.
      std::vector<MVT::SimpleValueType> ParamVTs;

      /// ParamTypeDefs - The records for each parameter type.
      std::vector<Record*> ParamTypeDefs;
    };

    IntrinsicSignature IS;

    // Memory mod/ref behavior of this intrinsic.
    enum ModRefKind {
      NoMem, ReadArgMem, ReadMem, ReadWriteArgMem, ReadWriteMem
    };
    ModRefKind ModRef;

    /// This is set to true if the intrinsic is overloaded by its argument
    /// types.
    bool isOverloaded;

    /// isCommutative - True if the intrinsic is commutative.
    bool isCommutative;

    /// canThrow - True if the intrinsic can throw.
    bool canThrow;

    /// isNoDuplicate - True if the intrinsic is marked as noduplicate.
    bool isNoDuplicate;

    /// isNoReturn - True if the intrinsic is no-return.
    bool isNoReturn;

    /// isConvergent - True if the intrinsic is marked as convergent.
    bool isConvergent;

    enum ArgAttribute {
      NoCapture,
      ReadOnly,
      ReadNone
    };
    std::vector<std::pair<unsigned, ArgAttribute> > ArgumentAttributes;

    CodeGenIntrinsic(Record *R);
  };

  /// LoadIntrinsics - Read all of the intrinsics defined in the specified
  /// .td file.
  std::vector<CodeGenIntrinsic> LoadIntrinsics(const RecordKeeper &RC,
                                               bool TargetOnly);
}

#endif
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d22 71
a92 32
class Record;
class RecordKeeper;
class CodeGenTarget;

struct CodeGenIntrinsic {
  Record *TheDef;             // The actual record defining this intrinsic.
  std::string Name;           // The name of the LLVM function "llvm.bswap.i32"
  std::string EnumName;       // The name of the enum "bswap_i32"
  std::string GCCBuiltinName; // Name of the corresponding GCC builtin, or "".
  std::string MSBuiltinName;  // Name of the corresponding MS builtin, or "".
  std::string TargetPrefix;   // Target prefix, e.g. "ppc" for t-s intrinsics.

  /// This structure holds the return values and parameter values of an
  /// intrinsic. If the number of return values is > 1, then the intrinsic
  /// implicitly returns a first-class aggregate. The numbering of the types
  /// starts at 0 with the first return value and continues from there through
  /// the parameter list. This is useful for "matching" types.
  struct IntrinsicSignature {
    /// The MVT::SimpleValueType for each return type. Note that this list is
    /// only populated when in the context of a target .td file. When building
    /// Intrinsics.td, this isn't available, because we don't know the target
    /// pointer size.
    std::vector<MVT::SimpleValueType> RetVTs;

    /// The records for each return type.
    std::vector<Record *> RetTypeDefs;

    /// The MVT::SimpleValueType for each parameter type. Note that this list is
    /// only populated when in the context of a target .td file.  When building
    /// Intrinsics.td, this isn't available, because we don't know the target
    /// pointer size.
    std::vector<MVT::SimpleValueType> ParamVTs;
d94 1
a94 2
    /// The records for each parameter type.
    std::vector<Record *> ParamTypeDefs;
d97 4
a100 79
  IntrinsicSignature IS;

  /// Bit flags describing the type (ref/mod) and location of memory
  /// accesses that may be performed by the intrinsics. Analogous to
  /// \c FunctionModRefBehaviour.
  enum ModRefBits {
    /// The intrinsic may access memory anywhere, i.e. it is not restricted
    /// to access through pointer arguments.
    MR_Anywhere = 1,

    /// The intrinsic may read memory.
    MR_Ref = 2,

    /// The intrinsic may write memory.
    MR_Mod = 4,

    /// The intrinsic may both read and write memory.
    MR_ModRef = MR_Ref | MR_Mod,
  };

  /// Memory mod/ref behavior of this intrinsic, corresponding to intrinsic
  /// properties (IntrReadMem, IntrArgMemOnly, etc.).
  enum ModRefBehavior {
    NoMem = 0,
    ReadArgMem = MR_Ref,
    ReadMem = MR_Ref | MR_Anywhere,
    WriteArgMem = MR_Mod,
    WriteMem = MR_Mod | MR_Anywhere,
    ReadWriteArgMem = MR_ModRef,
    ReadWriteMem = MR_ModRef | MR_Anywhere,
  };
  ModRefBehavior ModRef;

  /// This is set to true if the intrinsic is overloaded by its argument
  /// types.
  bool isOverloaded;

  /// True if the intrinsic is commutative.
  bool isCommutative;

  /// True if the intrinsic can throw.
  bool canThrow;

  /// True if the intrinsic is marked as noduplicate.
  bool isNoDuplicate;

  /// True if the intrinsic is no-return.
  bool isNoReturn;

  /// True if the intrinsic is marked as convergent.
  bool isConvergent;

  enum ArgAttribute { NoCapture, Returned, ReadOnly, WriteOnly, ReadNone };
  std::vector<std::pair<unsigned, ArgAttribute>> ArgumentAttributes;

  CodeGenIntrinsic(Record *R);
};

class CodeGenIntrinsicTable {
  std::vector<CodeGenIntrinsic> Intrinsics;

public:
  struct TargetSet {
    std::string Name;
    size_t Offset;
    size_t Count;
  };
  std::vector<TargetSet> Targets;

  explicit CodeGenIntrinsicTable(const RecordKeeper &RC, bool TargetOnly);
  CodeGenIntrinsicTable() = default;

  bool empty() const { return Intrinsics.empty(); }
  size_t size() const { return Intrinsics.size(); }
  CodeGenIntrinsic &operator[](size_t Pos) { return Intrinsics[Pos]; }
  const CodeGenIntrinsic &operator[](size_t Pos) const {
    return Intrinsics[Pos];
  }
};
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@a64 8
    /// The intrinsic may access memory that is otherwise inaccessible via
    /// LLVM IR.
    MR_InaccessibleMem = 1,

    /// The intrinsic may access memory through pointer arguments.
    /// LLVM IR.
    MR_ArgMem = 2,

d67 1
a67 1
    MR_Anywhere = 4 | MR_ArgMem | MR_InaccessibleMem,
d70 1
a70 1
    MR_Ref = 8,
d73 1
a73 1
    MR_Mod = 16,
d83 1
a83 3
    ReadArgMem = MR_Ref | MR_ArgMem,
    ReadInaccessibleMem = MR_Ref | MR_InaccessibleMem,
    ReadInaccessibleMemOrArgMem = MR_Ref | MR_ArgMem | MR_InaccessibleMem,
d85 1
a85 3
    WriteArgMem = MR_Mod | MR_ArgMem,
    WriteInaccessibleMem = MR_Mod | MR_InaccessibleMem,
    WriteInaccessibleMemOrArgMem = MR_Mod | MR_ArgMem | MR_InaccessibleMem,
d87 1
a87 4
    ReadWriteArgMem = MR_ModRef | MR_ArgMem,
    ReadWriteInaccessibleMem = MR_ModRef | MR_InaccessibleMem,
    ReadWriteInaccessibleMemOrArgMem = MR_ModRef | MR_ArgMem |
                                       MR_InaccessibleMem,
@


