head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.3
	LLVM_4_0_0:1.1.1.3
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2016.09.03.22.46.59;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.59;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.58;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.13;	author patrick;	state Exp;
branches;
next	;
commitid	so2WA7LCP6wbxtYl;


desc
@@


1.1
log
@Initial revision
@
text
@#!/usr/bin/env python2.7

"""A test case update script.

This script is a utility to update LLVM X86 'llc' based test cases with new
FileCheck patterns. It can either update all of the tests in the file or
a single test function.
"""

import argparse
import itertools
import string
import subprocess
import sys
import tempfile
import re


def llc(args, cmd_args, ir):
  with open(ir) as ir_file:
    stdout = subprocess.check_output(args.llc_binary + ' ' + cmd_args,
                                     shell=True, stdin=ir_file)
  return stdout


ASM_SCRUB_WHITESPACE_RE = re.compile(r'(?!^(|  \w))[ \t]+', flags=re.M)
ASM_SCRUB_TRAILING_WHITESPACE_RE = re.compile(r'[ \t]+$', flags=re.M)
ASM_SCRUB_SHUFFLES_RE = (
    re.compile(
        r'^(\s*\w+) [^#\n]+#+ ((?:[xyz]mm\d+|mem) = .*)$',
        flags=re.M))
ASM_SCRUB_SP_RE = re.compile(r'\d+\(%(esp|rsp)\)')
ASM_SCRUB_RIP_RE = re.compile(r'[.\w]+\(%rip\)')
ASM_SCRUB_KILL_COMMENT_RE = re.compile(r'^ *#+ +kill:.*\n')


def scrub_asm(asm):
  # Scrub runs of whitespace out of the assembly, but leave the leading
  # whitespace in place.
  asm = ASM_SCRUB_WHITESPACE_RE.sub(r' ', asm)
  # Expand the tabs used for indentation.
  asm = string.expandtabs(asm, 2)
  # Detect shuffle asm comments and hide the operands in favor of the comments.
  asm = ASM_SCRUB_SHUFFLES_RE.sub(r'\1 {{.*#+}} \2', asm)
  # Generically match the stack offset of a memory operand.
  asm = ASM_SCRUB_SP_RE.sub(r'{{[0-9]+}}(%\1)', asm)
  # Generically match a RIP-relative memory operand.
  asm = ASM_SCRUB_RIP_RE.sub(r'{{.*}}(%rip)', asm)
  # Strip kill operands inserted into the asm.
  asm = ASM_SCRUB_KILL_COMMENT_RE.sub('', asm)
  # Strip trailing whitespace.
  asm = ASM_SCRUB_TRAILING_WHITESPACE_RE.sub(r'', asm)
  return asm


def main():
  parser = argparse.ArgumentParser(description=__doc__)
  parser.add_argument('-v', '--verbose', action='store_true',
                      help='Show verbose output')
  parser.add_argument('--llc-binary', default='llc',
                      help='The "llc" binary to use to generate the test case')
  parser.add_argument(
      '--function', help='The function in the test file to update')
  parser.add_argument('tests', nargs='+')
  args = parser.parse_args()

  run_line_re = re.compile('^\s*;\s*RUN:\s*(.*)$')
  ir_function_re = re.compile('^\s*define\s+(?:internal\s+)?[^@@]*@@(\w+)\s*\(')
  asm_function_re = re.compile(
      r'^_?(?P<f>[^:]+):[ \t]*#+[ \t]*@@(?P=f)\n[^:]*?'
      r'(?P<body>^##?[ \t]+[^:]+:.*?)\s*'
      r'^\s*(?:[^:\n]+?:\s*\n\s*\.size|\.cfi_endproc|\.globl|\.comm|\.(?:sub)?section)',
      flags=(re.M | re.S))
  check_prefix_re = re.compile('--check-prefix=(\S+)')
  check_re = re.compile(r'^\s*;\s*([^:]+?)(?:-NEXT|-NOT|-DAG|-LABEL)?:')
  autogenerated_note = ('; NOTE: Assertions have been autogenerated by '
                        'utils/update_llc_test_checks.py')

  for test in args.tests:
    if args.verbose:
      print >>sys.stderr, 'Scanning for RUN lines in test file: %s' % (test,)
    with open(test) as f:
      test_lines = [l.rstrip() for l in f]

    run_lines = [m.group(1)
                 for m in [run_line_re.match(l) for l in test_lines] if m]
    if args.verbose:
      print >>sys.stderr, 'Found %d RUN lines:' % (len(run_lines),)
      for l in run_lines:
        print >>sys.stderr, '  RUN: ' + l

    checks = []
    for l in run_lines:
      (llc_cmd, filecheck_cmd) = tuple([cmd.strip() for cmd in l.split('|', 1)])
      if not llc_cmd.startswith('llc '):
        print >>sys.stderr, 'WARNING: Skipping non-llc RUN line: ' + l
        continue

      if not filecheck_cmd.startswith('FileCheck '):
        print >>sys.stderr, 'WARNING: Skipping non-FileChecked RUN line: ' + l
        continue

      llc_cmd_args = llc_cmd[len('llc'):].strip()
      llc_cmd_args = llc_cmd_args.replace('< %s', '').replace('%s', '').strip()

      check_prefixes = [m.group(1)
                        for m in check_prefix_re.finditer(filecheck_cmd)]
      if not check_prefixes:
        check_prefixes = ['CHECK']

      # FIXME: We should use multiple check prefixes to common check lines. For
      # now, we just ignore all but the last.
      checks.append((check_prefixes, llc_cmd_args))

    asm = {}
    for prefixes, _ in checks:
      for prefix in prefixes:
        asm.update({prefix: dict()})
    for prefixes, llc_args in checks:
      if args.verbose:
        print >>sys.stderr, 'Extracted LLC cmd: llc ' + llc_args
        print >>sys.stderr, 'Extracted FileCheck prefixes: ' + str(prefixes)
      raw_asm = llc(args, llc_args, test)
      # Build up a dictionary of all the function bodies.
      for m in asm_function_re.finditer(raw_asm):
        if not m:
          continue
        f = m.group('f')
        f_asm = scrub_asm(m.group('body'))
        if f.startswith('stress'):
          # We only use the last line of the asm for stress tests.
          f_asm = '\n'.join(f_asm.splitlines()[-1:])
        if args.verbose:
          print >>sys.stderr, 'Processing asm for function: ' + f
          for l in f_asm.splitlines():
            print >>sys.stderr, '  ' + l
        for prefix in prefixes:
          if f in asm[prefix] and asm[prefix][f] != f_asm:
            if prefix == prefixes[-1]:
              print >>sys.stderr, ('WARNING: Found conflicting asm under the '
                                   'same prefix: %r!' % (prefix,))
            else:
              asm[prefix][f] = None
              continue

          asm[prefix][f] = f_asm

    is_in_function = False
    is_in_function_start = False
    prefix_set = set([prefix for prefixes, _ in checks for prefix in prefixes])
    if args.verbose:
      print >>sys.stderr, 'Rewriting FileCheck prefixes: %s' % (prefix_set,)
    fixed_lines = []
    fixed_lines.append(autogenerated_note)

    for l in test_lines:
      if is_in_function_start:
        if l.lstrip().startswith(';'):
          m = check_re.match(l)
          if not m or m.group(1) not in prefix_set:
            fixed_lines.append(l)
            continue

        # Print out the various check lines here
        printed_prefixes = []
        for prefixes, _ in checks:
          for prefix in prefixes:
            if prefix in printed_prefixes:
              break
            if not asm[prefix][name]:
              continue
            if len(printed_prefixes) != 0:
              fixed_lines.append(';')
            printed_prefixes.append(prefix)
            fixed_lines.append('; %s-LABEL: %s:' % (prefix, name))
            asm_lines = asm[prefix][name].splitlines()
            fixed_lines.append('; %s:       %s' % (prefix, asm_lines[0]))
            for asm_line in asm_lines[1:]:
              fixed_lines.append('; %s-NEXT:  %s' % (prefix, asm_line))
            break
        is_in_function_start = False

      if is_in_function:
        # Skip any blank comment lines in the IR.
        if l.strip() == ';':
          continue
        # And skip any CHECK lines. We'll build our own.
        m = check_re.match(l)
        if m and m.group(1) in prefix_set:
          continue
        # Collect the remaining lines in the function body and look for the end
        # of the function.
        fixed_lines.append(l)
        if l.strip() == '}':
          is_in_function = False
        continue

      if l == autogenerated_note:
        continue
      fixed_lines.append(l)

      m = ir_function_re.match(l)
      if not m:
        continue
      name = m.group(1)
      if args.function is not None and name != args.function:
        # When filtering on a specific function, skip all others.
        continue
      is_in_function = is_in_function_start = True

    if args.verbose:
      print>>sys.stderr, 'Writing %d fixed lines to %s...' % (
          len(fixed_lines), test)
    with open(test, 'w') as f:
      f.writelines([l + '\n' for l in fixed_lines])


if __name__ == '__main__':
  main()
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@a11 1
import os         # Used to advertise this file's name ("autogenerated_note").
d18 1
a18 1
# Invoke the tool that is being tested.
a22 2
  # Fix line endings to unix CR style.
  stdout = stdout.replace('\r\n', '\n')
d26 3
a28 5
# RegEx: this is where the magic happens.

SCRUB_WHITESPACE_RE = re.compile(r'(?!^(|  \w))[ \t]+', flags=re.M)
SCRUB_TRAILING_WHITESPACE_RE = re.compile(r'[ \t]+$', flags=re.M)
SCRUB_X86_SHUFFLES_RE = (
d30 1
a30 1
        r'^(\s*\w+) [^#\n]+#+ ((?:[xyz]mm\d+|mem)( \{%k\d+\}( \{z\})?)? = .*)$',
d32 3
a34 14
SCRUB_X86_SP_RE = re.compile(r'\d+\(%(esp|rsp)\)')
SCRUB_X86_RIP_RE = re.compile(r'[.\w]+\(%rip\)')
SCRUB_X86_LCP_RE = re.compile(r'\.LCPI[0-9]+_[0-9]+')
SCRUB_KILL_COMMENT_RE = re.compile(r'^ *#+ +kill:.*\n')

RUN_LINE_RE = re.compile('^\s*;\s*RUN:\s*(.*)$')
IR_FUNCTION_RE = re.compile('^\s*define\s+(?:internal\s+)?[^@@]*@@(\w+)\s*\(')
ASM_FUNCTION_RE = re.compile(
    r'^_?(?P<func>[^:]+):[ \t]*#+[ \t]*@@(?P=func)\n[^:]*?'
    r'(?P<body>^##?[ \t]+[^:]+:.*?)\s*'
    r'^\s*(?:[^:\n]+?:\s*\n\s*\.size|\.cfi_endproc|\.globl|\.comm|\.(?:sub)?section)',
    flags=(re.M | re.S))
CHECK_PREFIX_RE = re.compile('--check-prefix=(\S+)')
CHECK_RE = re.compile(r'^\s*;\s*([^:]+?)(?:-NEXT|-NOT|-DAG|-LABEL)?:')
d40 1
a40 1
  asm = SCRUB_WHITESPACE_RE.sub(r' ', asm)
d44 1
a44 1
  asm = SCRUB_X86_SHUFFLES_RE.sub(r'\1 {{.*#+}} \2', asm)
d46 1
a46 1
  asm = SCRUB_X86_SP_RE.sub(r'{{[0-9]+}}(%\1)', asm)
d48 1
a48 3
  asm = SCRUB_X86_RIP_RE.sub(r'{{.*}}(%rip)', asm)
  # Generically match a LCP symbol.
  asm = SCRUB_X86_LCP_RE.sub(r'{{\.LCPI.*}}', asm)
d50 1
a50 1
  asm = SCRUB_KILL_COMMENT_RE.sub('', asm)
d52 1
a52 1
  asm = SCRUB_TRAILING_WHITESPACE_RE.sub(r'', asm)
a55 64
# Build up a dictionary of all the function bodies.
def build_function_body_dictionary(raw_tool_output, prefixes, func_dict, verbose):
  for m in ASM_FUNCTION_RE.finditer(raw_tool_output):
    if not m:
      continue
    func = m.group('func')
    scrubbed_body = scrub_asm(m.group('body'))
    if func.startswith('stress'):
      # We only use the last line of the function body for stress tests.
      scrubbed_body = '\n'.join(scrubbed_body.splitlines()[-1:])
    if verbose:
      print >>sys.stderr, 'Processing function: ' + func
      for l in scrubbed_body.splitlines():
        print >>sys.stderr, '  ' + l
    for prefix in prefixes:
      if func in func_dict[prefix] and func_dict[prefix][func] != scrubbed_body:
        if prefix == prefixes[-1]:
          print >>sys.stderr, ('WARNING: Found conflicting asm under the '
                               'same prefix: %r!' % (prefix,))
        else:
          func_dict[prefix][func] = None
          continue

      func_dict[prefix][func] = scrubbed_body


def add_checks(output_lines, prefix_list, func_dict, func_name):
  printed_prefixes = []
  for checkprefixes, _ in prefix_list:
    for checkprefix in checkprefixes:
      if checkprefix in printed_prefixes:
        break
      if not func_dict[checkprefix][func_name]:
        continue
      # Add some space between different check prefixes.
      if len(printed_prefixes) != 0:
        output_lines.append(';')
      printed_prefixes.append(checkprefix)
      output_lines.append('; %s-LABEL: %s:' % (checkprefix, func_name))
      func_body = func_dict[checkprefix][func_name].splitlines()
      output_lines.append('; %s:       %s' % (checkprefix, func_body[0]))
      for func_line in func_body[1:]:
        output_lines.append('; %s-NEXT:  %s' % (checkprefix, func_line))
      # Add space between different check prefixes and the first line of code.
      # output_lines.append(';')
      break
  return output_lines


def should_add_line_to_output(input_line, prefix_set):
  # Skip any blank comment lines in the IR.
  if input_line.strip() == ';':
    return False
  # Skip any blank lines in the IR.
  #if input_line.strip() == '':
  #  return False
  # And skip any CHECK lines. We're building our own.
  m = CHECK_RE.match(input_line)
  if m and m.group(1) in prefix_set:
    return False

  return True


d67 9
d77 1
a77 1
                        'utils/' + os.path.basename(__file__))
d83 1
a83 1
      input_lines = [l.rstrip() for l in f]
d86 1
a86 1
                 for m in [RUN_LINE_RE.match(l) for l in input_lines] if m]
d92 1
a92 1
    prefix_list = []
d107 1
a107 1
                        for m in CHECK_PREFIX_RE.finditer(filecheck_cmd)]
d113 1
a113 1
      prefix_list.append((check_prefixes, llc_cmd_args))
d115 2
a116 2
    func_dict = {}
    for prefixes, _ in prefix_list:
d118 2
a119 2
        func_dict.update({prefix: dict()})
    for prefixes, llc_args in prefix_list:
d123 22
d146 1
a146 2
      raw_tool_output = llc(args, llc_args, test)
      build_function_body_dictionary(raw_tool_output, prefixes, func_dict, args.verbose)
d150 1
a150 1
    prefix_set = set([prefix for prefixes, _ in prefix_list for prefix in prefixes])
d153 2
a154 2
    output_lines = []
    output_lines.append(autogenerated_note)
d156 1
a156 1
    for input_line in input_lines:
d158 2
a159 4
        if input_line == '':
          continue
        if input_line.lstrip().startswith(';'):
          m = CHECK_RE.match(input_line)
d161 1
a161 1
            output_lines.append(input_line)
d164 17
a180 2
        # Print out the various check lines here.
        output_lines = add_checks(output_lines, prefix_list, func_dict, name)
d184 2
a185 4
        if should_add_line_to_output(input_line, prefix_set) == True:
          # This input line of the function body will go as-is into the output.
          output_lines.append(input_line)
        else:
d187 8
a194 1
        if input_line.strip() == '}':
d198 1
a198 1
      if input_line == autogenerated_note:
d200 1
d202 1
a202 4
      # If it's outside a function, it just gets copied to the output.
      output_lines.append(input_line)

      m = IR_FUNCTION_RE.match(input_line)
d212 4
a215 4
      print>>sys.stderr, 'Writing %d lines to %s...' % (len(output_lines), test)

    with open(test, 'wb') as f:
      f.writelines([l + '\n' for l in output_lines])
@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d11 1
d16 1
a32 7
SCRUB_KILL_COMMENT_RE = re.compile(r'^ *#+ +kill:.*\n')

ASM_FUNCTION_X86_RE = re.compile(
    r'^_?(?P<func>[^:]+):[ \t]*#+[ \t]*@@(?P=func)\n[^:]*?'
    r'(?P<body>^##?[ \t]+[^:]+:.*?)\s*'
    r'^\s*(?:[^:\n]+?:\s*\n\s*\.size|\.cfi_endproc|\.globl|\.comm|\.(?:sub)?section)',
    flags=(re.M | re.S))
d40 1
a40 7

ASM_FUNCTION_ARM_RE = re.compile(
        r'^(?P<func>[0-9a-zA-Z_]+):\n' # f: (name of function)
        r'\s+\.fnstart\n' # .fnstart
        r'(?P<body>.*?)\n' # (body of the function)
        r'.Lfunc_end[0-9]+:\n', # .Lfunc_end0:
        flags=(re.M | re.S))
a42 2
TRIPLE_ARG_RE = re.compile(r'-mtriple=([^ ]+)')
TRIPLE_IR_RE = re.compile(r'^target\s+triple\s*=\s*"([^"]+)"$')
d44 5
a51 11
ASM_FUNCTION_PPC_RE = re.compile(
    r'^_?(?P<func>[^:]+):[ \t]*#+[ \t]*@@(?P=func)\n'
    r'\.Lfunc_begin[0-9]+:\n'
    r'[ \t]+.cfi_startproc\n'
    r'(?:\.Lfunc_[gl]ep[0-9]+:\n(?:[ \t]+.*?\n)*)*'
    r'(?P<body>.*?)\n'
    # This list is incomplete
    r'(?:^[ \t]*(?:\.long[ \t]+[^\n]+|\.quad[ \t]+[^\n]+)\n)*'
    r'.Lfunc_end[0-9]+:\n',
    flags=(re.M | re.S))

d53 1
a53 1
def scrub_asm_x86(asm):
a72 22
def scrub_asm_arm_eabi(asm):
  # Scrub runs of whitespace out of the assembly, but leave the leading
  # whitespace in place.
  asm = SCRUB_WHITESPACE_RE.sub(r' ', asm)
  # Expand the tabs used for indentation.
  asm = string.expandtabs(asm, 2)
  # Strip kill operands inserted into the asm.
  asm = SCRUB_KILL_COMMENT_RE.sub('', asm)
  # Strip trailing whitespace.
  asm = SCRUB_TRAILING_WHITESPACE_RE.sub(r'', asm)
  return asm

def scrub_asm_powerpc64le(asm):
  # Scrub runs of whitespace out of the assembly, but leave the leading
  # whitespace in place.
  asm = SCRUB_WHITESPACE_RE.sub(r' ', asm)
  # Expand the tabs used for indentation.
  asm = string.expandtabs(asm, 2)
  # Strip trailing whitespace.
  asm = SCRUB_TRAILING_WHITESPACE_RE.sub(r'', asm)
  return asm

d75 2
a76 20
def build_function_body_dictionary(raw_tool_output, triple, prefixes, func_dict,
                                   verbose):
  target_handlers = {
      'x86_64': (scrub_asm_x86, ASM_FUNCTION_X86_RE),
      'i686': (scrub_asm_x86, ASM_FUNCTION_X86_RE),
      'x86': (scrub_asm_x86, ASM_FUNCTION_X86_RE),
      'i386': (scrub_asm_x86, ASM_FUNCTION_X86_RE),
      'arm-eabi': (scrub_asm_arm_eabi, ASM_FUNCTION_ARM_RE),
      'powerpc64le': (scrub_asm_powerpc64le, ASM_FUNCTION_PPC_RE),
  }
  handlers = None
  for prefix, s in target_handlers.items():
    if triple.startswith(prefix):
      handlers = s
      break
  else:
    raise KeyError('Triple %r is not supported' % (triple))

  scrubber, function_re = handlers
  for m in function_re.finditer(raw_tool_output):
d80 1
a80 1
    scrubbed_body = scrubber(m.group('body'))
d100 1
a100 1
def add_checks(output_lines, run_list, func_dict, func_name):
d102 1
a102 2
  for p in run_list:
    checkprefixes = p[0]
d158 1
a158 8
    triple_in_ir = None
    for l in input_lines:
      m = TRIPLE_IR_RE.match(l)
      if m:
        triple_in_ir = m.groups()[0]
        break

    raw_lines = [m.group(1)
a159 7
    run_lines = [raw_lines[0]] if len(raw_lines) > 0 else []
    for l in raw_lines[1:]:
      if run_lines[-1].endswith("\\"):
        run_lines[-1] = run_lines[-1].rstrip("\\") + " " + l
      else:
        run_lines.append(l)

d165 1
a165 1
    run_list = []
d167 1
a167 11
      commands = [cmd.strip() for cmd in l.split('|', 1)]
      llc_cmd = commands[0]

      triple_in_cmd = None
      m = TRIPLE_ARG_RE.search(llc_cmd)
      if m:
        triple_in_cmd = m.groups()[0]

      filecheck_cmd = ''
      if len(commands) > 1:
        filecheck_cmd = commands[1]
d186 1
a186 1
      run_list.append((check_prefixes, llc_cmd_args, triple_in_cmd))
d189 1
a189 2
    for p in run_list:
      prefixes = p[0]
d192 1
a192 1
    for prefixes, llc_args, triple_in_cmd in run_list:
d198 1
a198 5
      if not (triple_in_cmd or triple_in_ir):
        print >>sys.stderr, "Cannot find a triple. Assume 'x86'"

      build_function_body_dictionary(raw_tool_output,
          triple_in_cmd or triple_in_ir or 'x86', prefixes, func_dict, args.verbose)
d202 1
a202 2
    func_name = None
    prefix_set = set([prefix for p in run_list for prefix in p[0]])
d219 1
a219 1
        output_lines = add_checks(output_lines, run_list, func_dict, func_name)
d241 2
a242 2
      func_name = m.group(1)
      if args.function is not None and func_name != args.function:
@


