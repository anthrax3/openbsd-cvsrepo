head	1.1;
branch	1.1.1;
access;
symbols
	LLVM_5_0_0:1.1.1.3
	OPENBSD_6_2:1.1.1.2.0.2
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.4
	OPENBSD_6_1_BASE:1.1.1.2
	LLVM_4_0_0:1.1.1.2
	LLVM_4_0_0_RC1:1.1.1.2
	LLVM_3_9_1:1.1.1.1
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2016.09.03.22.46.54;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.54;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.24.08.33.13;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	so2WA7LCP6wbxtYl;

1.1.1.3
date	2017.10.04.20.27.51;	author patrick;	state Exp;
branches;
next	;
commitid	ufzi3t8MqoilCPqO;


desc
@@


1.1
log
@Initial revision
@
text
@//===- ir_test.go - Tests for ir ------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file tests bindings for the ir component.
//
//===----------------------------------------------------------------------===//

package llvm

import (
	"strings"
	"testing"
)

func testAttribute(t *testing.T, attr Attribute, name string) {
	mod := NewModule("")
	defer mod.Dispose()

	ftyp := FunctionType(VoidType(), nil, false)
	fn := AddFunction(mod, "foo", ftyp)

	fn.AddFunctionAttr(attr)
	newattr := fn.FunctionAttr()
	if attr != newattr {
		t.Errorf("got attribute mask %d, want %d", newattr, attr)
	}

	text := mod.String()
	if !strings.Contains(text, " "+name+" ") {
		t.Errorf("expected attribute '%s', got:\n%s", name, text)
	}

	fn.RemoveFunctionAttr(attr)
	newattr = fn.FunctionAttr()
	if newattr != 0 {
		t.Errorf("got attribute mask %d, want 0", newattr)
	}
}

func TestAttributes(t *testing.T) {
	// Tests that our attribute constants haven't drifted from LLVM's.
	attrTests := []struct {
		attr Attribute
		name string
	}{
		{SanitizeAddressAttribute, "sanitize_address"},
		{AlwaysInlineAttribute, "alwaysinline"},
		{BuiltinAttribute, "builtin"},
		{ByValAttribute, "byval"},
		{ConvergentAttribute, "convergent"},
		{InAllocaAttribute, "inalloca"},
		{InlineHintAttribute, "inlinehint"},
		{InRegAttribute, "inreg"},
		{JumpTableAttribute, "jumptable"},
		{MinSizeAttribute, "minsize"},
		{NakedAttribute, "naked"},
		{NestAttribute, "nest"},
		{NoAliasAttribute, "noalias"},
		{NoBuiltinAttribute, "nobuiltin"},
		{NoCaptureAttribute, "nocapture"},
		{NoDuplicateAttribute, "noduplicate"},
		{NoImplicitFloatAttribute, "noimplicitfloat"},
		{NoInlineAttribute, "noinline"},
		{NonLazyBindAttribute, "nonlazybind"},
		{NonNullAttribute, "nonnull"},
		{NoRedZoneAttribute, "noredzone"},
		{NoReturnAttribute, "noreturn"},
		{NoUnwindAttribute, "nounwind"},
		{OptimizeNoneAttribute, "optnone"},
		{OptimizeForSizeAttribute, "optsize"},
		{ReadNoneAttribute, "readnone"},
		{ReadOnlyAttribute, "readonly"},
		{ReturnedAttribute, "returned"},
		{ReturnsTwiceAttribute, "returns_twice"},
		{SExtAttribute, "signext"},
		{SafeStackAttribute, "safestack"},
		{StackProtectAttribute, "ssp"},
		{StackProtectReqAttribute, "sspreq"},
		{StackProtectStrongAttribute, "sspstrong"},
		{StructRetAttribute, "sret"},
		{SanitizeThreadAttribute, "sanitize_thread"},
		{SanitizeMemoryAttribute, "sanitize_memory"},
		{UWTableAttribute, "uwtable"},
		{ZExtAttribute, "zeroext"},
		{ColdAttribute, "cold"},
	}

	for _, a := range attrTests {
		testAttribute(t, a.attr, a.name)
	}
}
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d21 1
a21 1
func testAttribute(t *testing.T, name string) {
a27 3
	kind := AttributeKindID(name)
	attr := mod.Context().CreateEnumAttribute(kind, 0)

d29 1
a29 1
	newattr := fn.GetEnumFunctionAttribute(kind)
d39 3
a41 3
	fn.RemoveEnumFunctionAttribute(kind)
	newattr = fn.GetEnumFunctionAttribute(kind)
	if !newattr.IsNil() {
d48 44
a91 41
	attrTests := []string{
		"sanitize_address",
		"alwaysinline",
		"builtin",
		"byval",
		"convergent",
		"inalloca",
		"inlinehint",
		"inreg",
		"jumptable",
		"minsize",
		"naked",
		"nest",
		"noalias",
		"nobuiltin",
		"nocapture",
		"noduplicate",
		"noimplicitfloat",
		"noinline",
		"nonlazybind",
		"nonnull",
		"noredzone",
		"noreturn",
		"nounwind",
		"optnone",
		"optsize",
		"readnone",
		"readonly",
		"returned",
		"returns_twice",
		"signext",
		"safestack",
		"ssp",
		"sspreq",
		"sspstrong",
		"sret",
		"sanitize_thread",
		"sanitize_memory",
		"uwtable",
		"zeroext",
		"cold",
d94 2
a95 2
	for _, name := range attrTests {
		testAttribute(t, name)
@


1.1.1.3
log
@Import LLVM 5.0.0 release including clang, lld and lldb.
@
text
@a97 65

func TestDebugLoc(t *testing.T) {
	mod := NewModule("")
	defer mod.Dispose()

	ctx := mod.Context()

	b := ctx.NewBuilder()
	defer b.Dispose()

	d := NewDIBuilder(mod)
	defer func() {
		d.Destroy()
	}()
	file := d.CreateFile("dummy_file", "dummy_dir")
	voidInfo := d.CreateBasicType(DIBasicType{Name: "void"})
	typeInfo := d.CreateSubroutineType(DISubroutineType{file, []Metadata{voidInfo}})
	scope := d.CreateFunction(file, DIFunction{
		Name:         "foo",
		LinkageName:  "foo",
		Line:         10,
		ScopeLine:    10,
		Type:         typeInfo,
		File:         file,
		IsDefinition: true,
	})

	b.SetCurrentDebugLocation(10, 20, scope, Metadata{})
	loc := b.GetCurrentDebugLocation()
	if loc.Line != 10 {
		t.Errorf("Got line %d, though wanted 10", loc.Line)
	}
	if loc.Col != 20 {
		t.Errorf("Got column %d, though wanted 20", loc.Col)
	}
	if loc.Scope.C != scope.C {
		t.Errorf("Got metadata %v as scope, though wanted %v", loc.Scope.C, scope.C)
	}
}

func TestSubtypes(t *testing.T) {
	cont := NewContext()
	defer cont.Dispose()

	int_pointer := PointerType(cont.Int32Type(), 0)
	int_inner := int_pointer.Subtypes()
	if len(int_inner) != 1 {
		t.Errorf("Got size %d, though wanted 1")
	}
	if int_inner[0] != cont.Int32Type() {
		t.Errorf("Expected int32 type")
	}

	st_pointer := cont.StructType([]Type{cont.Int32Type(), cont.Int8Type()}, false)
	st_inner := st_pointer.Subtypes()
	if len(st_inner) != 2 {
		t.Errorf("Got size %d, though wanted 2")
	}
	if st_inner[0] != cont.Int32Type() {
		t.Errorf("Expected first struct field to be int32")
	}
	if st_inner[1] != cont.Int8Type() {
		t.Errorf("Expected second struct field to be int8")
	}
}
@


