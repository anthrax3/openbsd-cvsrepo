head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.1.0.30
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.28
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.24
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.26
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.18
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.22
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.20
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.16
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.14
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.12
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.10
	OPENBSD_5_0:1.1.1.1.0.8
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.6
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.4
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	gcc-4_2_1:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2009.10.15.17.11.31;	author robert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.10.15.17.11.31;	author robert;	state Exp;
branches;
next	;


desc
@@



1.1
log
@Initial revision
@
text
@! { dg-do run }
! { dg-options "-w" }

  character (6) :: c, f2
  character (6) :: d(2)
  c = f1 (6)
  if (c .ne. 'opqrst') call abort
  c = f2 (6)
  if (c .ne. '_/!!/_') call abort
  d = f3 (6)
  if (d(1) .ne. 'opqrst' .or. d(2) .ne. 'a') call abort
  d = f4 (6)
  if (d(1) .ne. 'Opqrst' .or. d(2) .ne. 'A') call abort
contains
  function f1 (n)
    use omp_lib
    character (n) :: f1
    logical :: l
    f1 = 'abcdef'
    l = .false.
!$omp parallel firstprivate (f1) reduction (.or.:l) num_threads (2)
    l = f1 .ne. 'abcdef'
    if (omp_get_thread_num () .eq. 0) f1 = 'ijklmn'
    if (omp_get_thread_num () .eq. 1) f1 = 'IJKLMN'
!$omp barrier
    l = l .or. (omp_get_thread_num () .eq. 0 .and. f1 .ne. 'ijklmn')
    l = l .or. (omp_get_thread_num () .eq. 1 .and. f1 .ne. 'IJKLMN')
!$omp end parallel
    f1 = 'zZzz_z'
!$omp parallel shared (f1) reduction (.or.:l) num_threads (2)
    l = l .or. f1 .ne. 'zZzz_z'
!$omp barrier
!$omp master
    f1 = 'abc'
!$omp end master
!$omp barrier
    l = l .or. f1 .ne. 'abc'
!$omp barrier
    if (omp_get_thread_num () .eq. 1) f1 = 'def'
!$omp barrier
    l = l .or. f1 .ne. 'def'
!$omp end parallel
    if (l) call abort
    f1 = 'opqrst'
  end function f1
  function f3 (n)
    use omp_lib
    character (n), dimension (2) :: f3
    logical :: l
    f3 = 'abcdef'
    l = .false.
!$omp parallel firstprivate (f3) reduction (.or.:l) num_threads (2)
    l = any (f3 .ne. 'abcdef')
    if (omp_get_thread_num () .eq. 0) f3 = 'ijklmn'
    if (omp_get_thread_num () .eq. 1) f3 = 'IJKLMN'
!$omp barrier
    l = l .or. (omp_get_thread_num () .eq. 0 .and. any (f3 .ne. 'ijklmn'))
    l = l .or. (omp_get_thread_num () .eq. 1 .and. any (f3 .ne. 'IJKLMN'))
!$omp end parallel
    f3 = 'zZzz_z'
!$omp parallel shared (f3) reduction (.or.:l) num_threads (2)
    l = l .or. any (f3 .ne. 'zZzz_z')
!$omp barrier
!$omp master
    f3 = 'abc'
!$omp end master
!$omp barrier
    l = l .or. any (f3 .ne. 'abc')
!$omp barrier
    if (omp_get_thread_num () .eq. 1) f3 = 'def'
!$omp barrier
    l = l .or. any (f3 .ne. 'def')
!$omp end parallel
    if (l) call abort
    f3(1) = 'opqrst'
    f3(2) = 'a'
  end function f3
  function f4 (n)
    use omp_lib
    character (n), dimension (n - 4) :: f4
    logical :: l
    f4 = 'abcdef'
    l = .false.
!$omp parallel firstprivate (f4) reduction (.or.:l) num_threads (2)
    l = any (f4 .ne. 'abcdef')
    if (omp_get_thread_num () .eq. 0) f4 = 'ijklmn'
    if (omp_get_thread_num () .eq. 1) f4 = 'IJKLMN'
!$omp barrier
    l = l .or. (omp_get_thread_num () .eq. 0 .and. any (f4 .ne. 'ijklmn'))
    l = l .or. (omp_get_thread_num () .eq. 1 .and. any (f4 .ne. 'IJKLMN'))
    l = l .or. size (f4) .ne. 2
!$omp end parallel
    f4 = 'zZzz_z'
!$omp parallel shared (f4) reduction (.or.:l) num_threads (2)
    l = l .or. any (f4 .ne. 'zZzz_z')
!$omp barrier
!$omp master
    f4 = 'abc'
!$omp end master
!$omp barrier
    l = l .or. any (f4 .ne. 'abc')
!$omp barrier
    if (omp_get_thread_num () .eq. 1) f4 = 'def'
!$omp barrier
    l = l .or. any (f4 .ne. 'def')
    l = l .or. size (f4) .ne. 2
!$omp end parallel
    if (l) call abort
    f4(1) = 'Opqrst'
    f4(2) = 'A'
  end function f4
end
function f2 (n)
  use omp_lib
  character (*) :: f2
  logical :: l
  f2 = 'abcdef'
  l = .false.
!$omp parallel firstprivate (f2) reduction (.or.:l) num_threads (2)
  l = f2 .ne. 'abcdef'
  if (omp_get_thread_num () .eq. 0) f2 = 'ijklmn'
  if (omp_get_thread_num () .eq. 1) f2 = 'IJKLMN'
!$omp barrier
  l = l .or. (omp_get_thread_num () .eq. 0 .and. f2 .ne. 'ijklmn')
  l = l .or. (omp_get_thread_num () .eq. 1 .and. f2 .ne. 'IJKLMN')
!$omp end parallel
  f2 = 'zZzz_z'
!$omp parallel shared (f2) reduction (.or.:l) num_threads (2)
  l = l .or. f2 .ne. 'zZzz_z'
!$omp barrier
!$omp master
  f2 = 'abc'
!$omp end master
!$omp barrier
  l = l .or. f2 .ne. 'abc'
!$omp barrier
  if (omp_get_thread_num () .eq. 1) f2 = 'def'
!$omp barrier
  l = l .or. f2 .ne. 'def'
!$omp end parallel
  if (l) call abort
  f2 = '_/!!/_'
end function f2
@


1.1.1.1
log
@import of gcc-4.2.1, the last gcc release under GPLv2
@
text
@@
