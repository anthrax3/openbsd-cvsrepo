head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.1.0.30
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.32
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.28
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.24
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.26
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.18
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.22
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.20
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.16
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.14
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.12
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.10
	OPENBSD_5_0:1.1.1.1.0.8
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.6
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.4
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	gcc-4_2_1:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2009.10.15.17.11.31;	author robert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.10.15.17.11.31;	author robert;	state Exp;
branches;
next	;


desc
@@



1.1
log
@Initial revision
@
text
@! { dg-do run }
use omp_lib
  call test_master
  call test_critical
  call test_barrier
  call test_atomic

contains
  subroutine test_master
    logical :: i, j
    i = .false.
    j = .false.
!$omp parallel num_threads (4)
!$omp master
    i = .true.
    j = omp_get_thread_num () .eq. 0
!$omp endmaster
!$omp end parallel
    if (.not. (i .or. j)) call abort
  end subroutine test_master

  subroutine test_critical_1 (i, j)
    integer :: i, j
!$omp critical(critical_foo) 
    i = i + 1
!$omp end critical (critical_foo)
!$omp critical
    j = j + 1
!$omp end critical
    end subroutine test_critical_1

  subroutine test_critical
    integer :: i, j, n
    n = -1
    i = 0
    j = 0
!$omp parallel num_threads (4)
    if (omp_get_thread_num () .eq. 0) n = omp_get_num_threads ()
    call test_critical_1 (i, j)
    call test_critical_1 (i, j)
!$omp critical
    j = j + 1
!$omp end critical
!$omp critical (critical_foo)
    i = i + 1
!$omp endcritical (critical_foo)
!$omp end parallel
    if (n .lt. 1 .or. i .ne. n * 3 .or. j .ne. n * 3) call abort
  end subroutine test_critical

  subroutine test_barrier
    integer :: i
    logical :: j
    i = 23
    j = .false.
!$omp parallel num_threads (4)
    if (omp_get_thread_num () .eq. 0) i = 5
!$omp flush (i)
!$omp barrier
    if (i .ne. 5) then
!$omp atomic
      j = j .or. .true.
    end if
!$omp end parallel
    if (i .ne. 5 .or. j) call abort
  end subroutine test_barrier

  subroutine test_atomic
    integer :: a, b, c, d, e, f, g
    a = 0
    b = 1
    c = 0
    d = 1024
    e = 1024
    f = -1
    g = -1
!$omp parallel num_threads (8)
!$omp atomic
    a = a + 2 + 4
!$omp atomic
    b = 3 * b
!$omp atomic
    c = 8 - c
!$omp atomic
    d = d / 2
!$omp atomic
    e = min (e, omp_get_thread_num ())
!$omp atomic
    f = max (omp_get_thread_num (), f)
    if (omp_get_thread_num () .eq. 0) g = omp_get_num_threads ()
!$omp end parallel
    if (g .le. 0 .or. g .gt. 8) call abort
    if (a .ne. 6 * g .or. b .ne. 3 ** g) call abort
    if (iand (g, 1) .eq. 1) then
      if (c .ne. 8) call abort
    else if (c .ne. 0) then
      call abort
    end if
    if (d .ne. 1024 / (2 ** g)) call abort
    if (e .ne. 0 .or. f .ne. g - 1) call abort
  end subroutine test_atomic
end
@


1.1.1.1
log
@import of gcc-4.2.1, the last gcc release under GPLv2
@
text
@@
