head	1.5;
access;
symbols
	OPENBSD_2_9:1.4.0.8
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.6
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.2.0.8
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.6
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2001.06.27.19.49.12;	author miod;	state dead;
branches;
next	1.4;

1.4
date	99.08.20.09.09.56;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	99.06.01.17.54.32;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	97.06.24.18.48.10;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	96.09.18.08.15.56;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.5
log
@More mips leftovers to get rid of...
@
text
@#ifdef USE_CACHE
#include <sys/stat.h>
#endif

#include <sys/syscall.h>

#ifndef _dl_MAX_ERRNO
#define _dl_MAX_ERRNO 4096
#endif
#define _dl_mmap_check_error(__res)	\
  ((int) __res < 0 && (int) __res >= -_dl_MAX_ERRNO)

/* Here are the definitions for a bunch of syscalls that are required
   by the dynamic linker.  The idea is that we want to be able to call
   these before the errno symbol is dynamicly linked, so we use our
   own version here.  Note that we cannot assume any dynamic linking
   at all, so we cannot return any error codes.  We just punt if there
   is an error. */

extern inline int
_dl_exit (int status)
{ 
  __asm__ volatile ("li    $2,%0\n\t"
		    "move  $4,%1\n\t"
                    "syscall"
                    : : "I" (SYS_exit), "r" (status)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		      "$10","$11","$12","$13","$14","$15","$24","$25");
  while (1)
    ;
} 

extern inline int
_dl_open (const char* addr, unsigned int flags)
{ 
  register int status;

  __asm__ volatile ("li    $2,%1\n\t"
		    "move  $4,%2\n\t"
                    "move  $5,%3\n\t"
                    "syscall\n\t"
		    "beq   $7,$0,1f\n\t"
		    "li    $2,-1\n\t"
		    "1:\n\t"
		    "move  %0,$2"
                    : "=r" (status)
                    : "I" (SYS_open), "r" (addr), "r" (flags)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		      "$10","$11","$12","$13","$14","$15","$24","$25");
  return status;
} 

extern inline int
_dl_close (int fd)
{ 
  register int status;

  __asm__ volatile ("li    $2,%1\n\t"
		    "move  $4,%2\n\t"
                    "syscall\n\t"
		    "beq   $7,$0,1f\n\t"
		    "li    $2,-1\n\t"
		    "1:\n\t"
		    "move  %0,$2"
                    : "=r" (status)
                    : "I" (SYS_close), "r" (fd)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		      "$10","$11","$12","$13","$14","$15","$24","$25");
  return status;
} 

extern inline int
_dl_write (int fd, const char* buf, int len)
{ 
  register int status;

  __asm__ volatile ("li    $2,%1\n\t"
		    "move  $4,%2\n\t"
                    "move  $5,%3\n\t"
                    "move  $6,%4\n\t"
                    "syscall\n\t"
		    "beq   $7,$0,1f\n\t"
		    "li    $2,-1\n\t"
		    "1:\n\t"
		    "move  %0,$2"
                    : "=r" (status)
                    : "I" (SYS_write), "r" (fd), "r" (buf), "r" (len)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		      "$10","$11","$12","$13","$14","$15","$24","$25");
  return status;
} 

extern inline int
_dl_read (int fd, const char* buf, int len)
{ 
  register int status;

  __asm__ volatile ("li    $2,%1\n\t"
		    "move  $4,%2\n\t"
                    "move  $5,%3\n\t"
                    "move  $6,%4\n\t"
                    "syscall\n\t"
		    "beq   $7,$0,1f\n\t"
		    "li    $2,-1\n\t"
		    "1:\n\t"
		    "move  %0,$2"
                    : "=r" (status)
                    : "I" (SYS_read), "r" (fd), "r" (buf), "r" (len)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		      "$10","$11","$12","$13","$14","$15","$24","$25");
  return status;
} 

extern inline int
_dl_mmap (void *addr, unsigned int size, unsigned int prot,
          unsigned int flags, int fd, unsigned int f_offset)
{ 
  register int malloc_buffer;

  __asm__ volatile ("li    $2,%1\n\t"
		    "addiu $29,-40\n\t"
                    "move  $6,%2\n\t"
                    "move  $7,%3\n\t"
		    "sw    %4,16($29)\n\t"
		    "sw    %5,20($29)\n\t"
#ifdef __MIPSEL__
		    "li    $4,%8\n\t"
                    "li    $5,0\n\t"
		    "sw    %6,24($29)\n\t"
		    "sw    $0,28($29)\n\t"
		    "sw    %7,32($29)\n\t"
		    "sw    $0,36($29)\n\t"
#else
#ifdef __MIPSEB__
                    "li    $4,0\n\t"
		    "li    $5,%8\n\t"
		    "sw    %6,24($29)\n\t"
		    "sw    $0,28($29)\n\t"
		    "sw    $0,32($29)\n\t"
		    "sw    %7,36($29)\n\t"
#else
#error "__MIPSEB__ or __MIPSEL__ not defined!"
#endif
#endif
                    "syscall\n\t"
		    "addiu $29,40\n\t"
		    "move  %0,$2"
                    : "=r" (malloc_buffer)
                    : "I" (SYS___syscall), "r" (addr), "r" (size), "r" (prot),
		      "r" (flags), "r" (fd), "r" (f_offset), "I" (SYS_mmap)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		      "$10","$11","$12","$13","$14","$15","$24","$25");
  return malloc_buffer;
} 

extern inline int
_dl_mprotect (const void *addr, int size, int prot)
{ 
  register int status;

  __asm__ volatile ("li    $2,%1\n\t"
		    "move  $4,%2\n\t"
                    "move  $5,%3\n\t"
                    "move  $6,%4\n\t"
                    "syscall\n\t"
		    "move  %0,$2"
                    : "=r" (status)
                    : "I" (SYS_mprotect), "r" (addr), "r" (size), "r" (prot)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		      "$10","$11","$12","$13","$14","$15","$24","$25");
  return status;
} 

#ifdef USE_CACHE
extern inline int
_dl_stat (const char *addr, struct stat *sb)
{ 
  register int status;

  __asm__ volatile ("li    $2,%1\n\t"
		    "move  $4,%2\n\t"
                    "move  $5,%3\n\t"
                    "syscall\n\t"
		    "move  %0,$2"
                    : "=r" (status)
                    : "I" (SYS_stat), "r" (addr), "r" (sb)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		      "$10","$11","$12","$13","$14","$15","$24","$25");
  return status;
} 

extern inline int
_dl_munmap (const void *addr, unsigned int size)
{ 
  register int status;

  __asm__ volatile ("li    $2,%1\n\t"
		    "move  $4,%2\n\t"
                    "move  $5,%3\n\t"
                    "syscall\n\t"
		    "move  %0,$2"
                    : "=r" (status)
                    : "I" (SYS_munmap), "r" (addr), "r" (size)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		      "$10","$11","$12","$13","$14","$15","$24","$25");
  return status;
} 
#endif

/* Not an actual syscall, but we need something in assembly to say
   whether this is OK or not.  */

extern inline int
_dl_suid_ok (void)
{
  unsigned int uid, euid, gid, egid;

  __asm__ volatile ("li $2,%1; syscall; move %0,$2"
                    : "=r" (uid) : "I" (SYS_getuid)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		     "$10","$11","$12","$13","$14","$15","$24","$25");
  __asm__ volatile ("li $2,%1; syscall; move %0,$2"
                    : "=r" (euid) : "I" (SYS_geteuid)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		     "$10","$11","$12","$13","$14","$15","$24","$25");
  __asm__ volatile ("li $2,%1; syscall; move %0,$2"
                    : "=r" (gid) : "I" (SYS_getgid)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		     "$10","$11","$12","$13","$14","$15","$24","$25");
  __asm__ volatile ("li $2,%1; syscall; move %0,$2"
                    : "=r" (egid) : "I" (SYS_getegid)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		     "$10","$11","$12","$13","$14","$15","$24","$25");

  	return (uid == euid && gid == egid);
}
@


1.4
log
@Fix faulty asms, that happened to work with old gcc, but not egcs
@
text
@@


1.3
log
@Fix some mips -> __mips__ stuff.
@
text
@d23 2
a24 2
  register int __status __asm__ ("$2");
  __asm__ volatile ("move  $4,%2\n\t"
d26 1
a26 2
                    : "=r" (__status)
                    : "0" (SYS_exit), "r" (status)
d28 3
a30 2
		     "$10","$11","$12","$13","$14","$15","$24","$25");
  while(1);
d36 4
a39 2
  register int status __asm__ ("$2");
  __asm__ volatile ("move  $4,%2\n\t"
d44 2
a45 1
		    "1:"
d47 1
a47 1
                    : "0" (SYS_open), "r" (addr), "r" (flags)
d49 1
a49 1
		     "$10","$11","$12","$13","$14","$15","$24","$25");
d56 4
a59 2
  register int status __asm__ ("$2");
  __asm__ volatile ("move  $4,%2\n\t"
d63 2
a64 1
		    "1:"
d66 1
a66 1
                    : "0" (SYS_close), "r" (fd)
d68 1
a68 1
		     "$10","$11","$12","$13","$14","$15","$24","$25");
d75 4
a78 2
  register int status __asm__ ("$2");
  __asm__ volatile ("move  $4,%2\n\t"
d84 2
a85 1
		    "1:"
d87 1
a87 1
                    : "0" (SYS_write), "r" (fd), "r" (buf), "r" (len)
d89 1
a89 1
		     "$10","$11","$12","$13","$14","$15","$24","$25");
d96 4
a99 2
  register int status __asm__ ("$2");
  __asm__ volatile ("move  $4,%2\n\t"
d105 2
a106 1
		    "1:"
d108 1
a108 1
                    : "0" (SYS_read), "r" (fd), "r" (buf), "r" (len)
d110 1
a110 1
		     "$10","$11","$12","$13","$14","$15","$24","$25");
d118 4
a121 2
  register int malloc_buffer __asm__ ("$2");
  __asm__ volatile ("addiu $29,-40\n\t"
d127 1
a127 1
		    "li    $4,197\n\t"
d136 1
a136 1
		    "li    $5,197\n\t"
d146 2
a147 1
		    "addiu $29,40"
d149 2
a150 2
                    : "0" (SYS___syscall), "r" (addr), "r" (size), "r" (prot),
		      "r" (flags), "r" (fd), "r" (f_offset)
d152 1
a152 1
		     "$10","$11","$12","$13","$14","$15","$24","$25");
d159 4
a162 2
  register int status __asm__ ("$2");
  __asm__ volatile ("move  $4,%2\n\t"
d165 2
a166 1
                    "syscall"
d168 1
a168 1
                    : "0" (SYS_mprotect), "r" (addr), "r" (size), "r" (prot)
d170 1
a170 1
		     "$10","$11","$12","$13","$14","$15","$24","$25");
d178 4
a181 2
  register int status __asm__ ("$2");
  __asm__ volatile ("move  $4,%2\n\t"
d183 2
a184 1
                    "syscall"
d186 1
a186 1
                    : "0" (SYS_stat), "r" (addr), "r" (sb)
d188 1
a188 1
		     "$10","$11","$12","$13","$14","$15","$24","$25");
d195 4
a198 2
  register int status __asm__ ("$2");
  __asm__ volatile ("move  $4,%2\n\t"
d200 2
a201 1
                    "syscall"
d203 1
a203 1
                    : "0" (SYS_munmap), "r" (addr), "r" (size)
d205 1
a205 1
		     "$10","$11","$12","$13","$14","$15","$24","$25");
d218 2
a219 2
  __asm__ volatile ("move $2,%1; syscall; move %0,$2"
                    : "=r" (uid) : "r" (SYS_getuid)
d222 2
a223 2
  __asm__ volatile ("move $2,%1; syscall; move %0,$2"
                    : "=r" (euid) : "r" (SYS_geteuid)
d226 2
a227 2
  __asm__ volatile ("move $2,%1; syscall; move %0,$2"
                    : "=r" (gid) : "r" (SYS_getgid)
d230 2
a231 2
  __asm__ volatile ("move $2,%1; syscall; move %0,$2"
                    : "=r" (egid) : "r" (SYS_getegid)
@


1.2
log
@Missing register usage definition in one of the syscall macros added...
@
text
@d112 1
a112 1
#ifdef MIPSEL
d119 2
a120 2
#endif
#ifdef MIPSEB
d127 3
@


1.1
log
@OK, this is the dynamic loader for the MIPS. It's a hack, it's GPL'd, its
just ugly, but it works. So we stick with it right now...
@
text
@d192 3
a194 1
                    : "=r" (uid) : "r" (SYS_getuid) : "$2");
d196 3
a198 1
                    : "=r" (euid) : "r" (SYS_geteuid) : "$2");
d200 3
a202 1
                    : "=r" (gid) : "r" (SYS_getgid) : "$2");
d204 3
a206 1
                    : "=r" (egid) : "r" (SYS_getegid) : "$2");
@
