head	1.3;
access;
symbols
	OPENBSD_2_9:1.2.0.18
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.16
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.14
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2001.06.27.19.48.55;	author miod;	state dead;
branches;
next	1.2;

1.2
date	97.04.14.08.09.46;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	96.09.18.08.15.27;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.3
log
@More mips leftovers to get rid of...
@
text
@
struct dyn_elf{
  struct elf_resolve * dyn;
  struct dyn_elf * next_handle;  /* Used by dlopen et al. */
  struct dyn_elf * next;
};
 
#include <link.h>

#define DT_MDEP         (DT_MIPS_HIPAGENO - DT_LOPROC + 1)

struct elf_resolve{
  /* These entries must be in this order to be compatible with the interface used
     by gdb to obtain the list of symbols. */
  char * loadaddr;
  char * loadoffs;
  char * libname;
  unsigned int dynamic_addr;
  struct elf_resolve * next;
  struct elf_resolve * prev;
  /* Nothing after this address is used by gdb. */
  enum {elf_lib, elf_executable,program_interpreter, loaded_file} libtype;
  struct dyn_elf * symbol_scope;
  unsigned short usage_count;
  unsigned short int init_flag;
  unsigned int nbucket;
  unsigned int * elf_buckets;
  /*
   * These are only used with ELF style shared libraries
   */
  unsigned int nchain;
  unsigned int * chains;
  unsigned int dynamic_info[DT_NUM + DT_MDEP];

  unsigned int dynamic_size;
  unsigned int n_phent;
  Elf32_Phdr * ppnt;
};

#define COPY_RELOCS_DONE 1
#define RELOCS_DONE 2
#define JMP_RELOCS_DONE 4
#define INIT_FUNCS_CALLED 8

extern struct dyn_elf     * _dl_symbol_tables;
extern struct elf_resolve * _dl_loaded_modules;

extern struct elf_resolve * _dl_check_hashed_files(char * libname);
extern struct elf_resolve * _dl_add_elf_hash_table(char * libname, 
					       char * loadaddr, 
					       char * loadoffs, 
					       unsigned int * dynamic_info, 
					       unsigned int dynamic_addr, 
					       unsigned int dynamic_size);
extern char * _dl_find_hash(char * name, struct dyn_elf * rpnt1, 
			unsigned int instr_addr, struct elf_resolve * f_tpnt, int copyrel);
extern struct elf_resolve * _dl_load_shared_library(struct dyn_elf *,
                                char * libname);  
int _dl_copy_fixups(struct dyn_elf * tpnt);


extern int _dl_linux_dynamic_link(void);

#ifdef __mc68000__
/* On m68k constant strings are referenced through the GOT. */
/* XXX Requires load_addr to be defined. */
#define SEND_STDERR(X)				\
  { const char *__s = (X);			\
    if (__s < (const char *) load_addr) __s += load_addr;	\
    _dl_write (2, __s, _dl_strlen (__s));	\
  }
#else
#define SEND_STDERR(X) _dl_write(2, X, _dl_strlen(X));
#endif
extern int _dl_write(int, const char *, int);
extern int _dl_fdprintf(int, const char *, ...);
extern char * _dl_library_path;
extern char * _dl_not_lazy;
extern char * _dl_strdup(const char *);
extern inline int _dl_symbol(char * name);
unsigned long _dl_elf_hash(const char * name);

extern inline int _dl_symbol(char * name)
{
  if(name[0] != '_' || name[1] != 'd' || name[2] != 'l' || name[3] != '_')
    return 0;
  return 1;
}

#define DL_ERROR_NOFILE 1
#define DL_ERROR_NOZERO 2
#define DL_ERROR_NOTELF 3
#define DL_ERROR_NOTMAGIC 4
#define DL_ERROR_NOTDYN 5
#define DL_ERROR_MMAP_FAILED 6
#define DL_ERROR_NODYNAMIC 7
#define DL_WRONG_RELOCS 8
#define DL_BAD_HANDLE 9
#define DL_NO_SYMBOL 10

@


1.2
log
@struct elf_resolv has to be compatible with struct link_map or gdb will
not be able to pick up loaded shared lib info.
@
text
@@


1.1
log
@OK, this is the dynamic loader for the MIPS. It's a hack, it's GPL'd, its
just ugly, but it works. So we stick with it right now...
@
text
@d16 1
a21 1
  char * loadoffs;
@
