head	1.2;
access;
symbols
	OPENBSD_2_9:1.1.1.1.0.20
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2001.09.09.16.41.32;	author deraadt;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.08.38.41;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.38.41;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.2
log
@uucp goes away
@
text
@/* time.c
   Routines to deal with UUCP time spans.

   Copyright (C) 1991, 1992, 1993 Ian Lance Taylor

   This file is part of the Taylor UUCP package.

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2 of the
   License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

   The author of the program may be contacted at ian@@airs.com or
   c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.
   */

#include "uucp.h"

#if USE_RCS_ID
const char time_rcsid[] = "$Id: time.c,v 1.1 1995/10/18 08:38:41 deraadt Exp $";
#endif

#include <ctype.h>

#if TM_IN_SYS_TIME
#include <sys/time.h>
#else
#include <time.h>
#endif

#include "uudefs.h"
#include "uuconf.h"

/* External functions.  */
#ifndef time
extern time_t time ();
#endif
#ifndef localtime
extern struct tm *localtime ();
#endif

/* See if the current time matches a time span.  If it does, return
   TRUE, set *pival to the value for the matching span, and set
   *pcretry to the retry for the matching span.  Otherwise return
   FALSE.  */

boolean
ftimespan_match (qspan, pival, pcretry)
     const struct uuconf_timespan *qspan;
     long *pival;
     int *pcretry;
{
  time_t inow;
  struct tm *qtm;
  int itm;
  const struct uuconf_timespan *q;

  if (qspan == NULL)
    return FALSE;

  time (&inow);
  qtm = localtime (&inow);

  /* Get the number of minutes since Sunday for the time.  */
  itm = qtm->tm_wday * 24 * 60 + qtm->tm_hour * 60 + qtm->tm_min;

  for (q = qspan; q != NULL; q = q->uuconf_qnext)
    {
      if (q->uuconf_istart <= itm && itm <= q->uuconf_iend)
	{
	  if (pival != NULL)
	    *pival = q->uuconf_ival;
	  if (pcretry != NULL)
	    *pcretry = q->uuconf_cretry;
	  return TRUE;
	}
    }

  return FALSE;
}

/* Determine the maximum size that may ever be transferred, according
   to a timesize span.  This returns -1 if there is no limit.  */

long
cmax_size_ever (qtimesize)
     const struct uuconf_timespan *qtimesize;
{
  long imax;
  const struct uuconf_timespan *q;

  if (qtimesize == NULL)
    return -1;

  /* Look through the list of spans.  If there is any gap larger than
     1 hour, we assume there are no restrictions.  Otherwise we keep
     track of the largest value we see.  I picked 1 hour arbitrarily,
     on the theory that a 1 hour span to transfer large files might
     actually occur, and is probably not an accident.  */
  if (qtimesize->uuconf_istart >= 60)
    return -1;

  imax = -1;

  for (q = qtimesize; q != NULL; q = q->uuconf_qnext)
    {
      if (q->uuconf_qnext == NULL)
	{
	  if (q->uuconf_iend <= 6 * 24 * 60 + 23 * 60)
	    return -1;
	}
      else
	{
	  if (q->uuconf_iend + 60 <= q->uuconf_qnext->uuconf_istart)
	    return -1;
	}

      if (imax < q->uuconf_ival)
	imax = q->uuconf_ival;
    }

  return imax;
}
@


1.1
log
@Initial revision
@
text
@d29 1
a29 1
const char time_rcsid[] = "$Id: time.c,v 1.3 1995/08/24 05:23:07 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
