head	1.1;
access;
symbols
	OPENBSD_6_2:1.1.0.68
	OPENBSD_6_2_BASE:1.1
	OPENBSD_6_1:1.1.0.70
	OPENBSD_6_1_BASE:1.1
	OPENBSD_6_0:1.1.0.66
	OPENBSD_6_0_BASE:1.1
	OPENBSD_5_9:1.1.0.62
	OPENBSD_5_9_BASE:1.1
	OPENBSD_5_8:1.1.0.64
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.56
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.60
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.58
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.54
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.52
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.50
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.48
	OPENBSD_5_0:1.1.0.46
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.44
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.42
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.38
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.40
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.36
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.34
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.32
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.30
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.28
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.26
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.24
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.22
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.20
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.18
	OPENBSD_3_6_BASE:1.1
	OPENBSD_3_5:1.1.0.16
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.14
	OPENBSD_3_4_BASE:1.1
	OPENBSD_3_3:1.1.0.12
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.10
	OPENBSD_3_2_BASE:1.1
	OPENBSD_3_1:1.1.0.8
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9:1.1.0.4
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.1
date	2000.10.10.20.40.27;	author beck;	state Exp;
branches;
next	;


desc
@@


1.1
log
@mkhybrid 1.12b5.1

Note, this normally makes a "mkisofs" which is the same binary, mkisofs
from here needs to be tested out prior to replacing our existing mkisofs
with this. (currently just installs mkhybrid)
@
text
@/*
 * File dump.c - dump a file/device both in hex and in ASCII.

   Written by Eric Youngdale (1993).

   Copyright 1993 Yggdrasil Computing, Incorporated

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

static char rcsid[] ="$Id: dump.c,v 1.3 1999/03/02 03:41:36 eric Exp $";

#include "../config.h"

#include <stdio.h>
#ifdef HAVE_TERMIOS_H
#include <termios.h>
#include <sys/ioctl.h>
#else
#include <termio.h>
#endif
#include <signal.h>

FILE * infile;
int file_addr;
unsigned char buffer[256];
unsigned char search[64];

#define PAGE 256

#ifdef HAVE_TERMIOS_H
struct termios savetty;
struct termios newtty;
#else
struct termio savetty;
struct termio newtty;
#endif

reset_tty(){
#ifdef HAVE_TERMIOS_H
  if(tcsetattr(0, TCSANOW, &savetty) == -1)
#else
  if(ioctl(0, TCSETAF, &savetty)==-1)
#endif
    {
      printf("cannot put tty into normal mode\n");
      exit(1);
    }
}

set_tty(){
#ifdef HAVE_TERMIOS_H
  if(tcsetattr(0, TCSANOW, &newtty) == -1)
#else
  if(ioctl(0, TCSETAF, &newtty)==-1)
#endif
    {
      printf("cannot put tty into raw mode\n");
      exit(1);
    }
}


/* Come here when we get a suspend signal from the terminal */

void
onsusp (int sig)
{
    /* ignore SIGTTOU so we don't get stopped if csh grabs the tty */
    signal(SIGTTOU, SIG_IGN);
    reset_tty ();
    fflush (stdout);
    signal(SIGTTOU, SIG_DFL);
    /* Send the TSTP signal to suspend our process group */
    signal(SIGTSTP, SIG_DFL);
/*    sigsetmask(0);*/
    kill (0, SIGTSTP);
    /* Pause for station break */

    /* We're back */
    signal (SIGTSTP, onsusp);
    set_tty ();
}



crsr2(int row, int col){
  printf("\033[%d;%dH",row,col);
}

showblock(int flag){
  unsigned int k;
  int i, j;
  lseek(fileno(infile), file_addr, 0);
  read(fileno(infile), buffer, sizeof(buffer));
  if(flag) {
    for(i=0;i<16;i++){
      crsr2(i+3,1);
      printf("%8.8x ",file_addr+(i<<4));
      for(j=15;j>=0;j--){
	printf("%2.2x",buffer[(i<<4)+j]);
	if(!(j & 0x3)) printf(" ");
      };
      for(j=0;j< 16;j++){
	k = buffer[(i << 4) + j];
	if(k >= ' ' && k < 0x80) printf("%c",k);
	else printf(".");
      };
    }
  };
  crsr2(20,1);
  printf(" Zone, zone offset: %6x %4.4x  ",file_addr>>11, file_addr & 0x7ff);
  fflush(stdout);
}

getbyte()
{
  char c1;
  c1 = buffer[file_addr & (PAGE-1)];
  file_addr++;
  if ((file_addr & (PAGE-1)) == 0) showblock(0);
  return c1;
}

main(int argc, char * argv[]){
  char c;
  int nbyte;
  int i,j;
  if(argc < 2) return 0;
  infile = fopen(argv[1],"rb");
  for(i=0;i<30;i++) printf("\n");
  file_addr = 0;
/* Now setup the keyboard for single character input. */
#ifdef HAVE_TERMIOS_H
  if(tcgetattr(0, &savetty) == -1)
#else
	if(ioctl(0, TCGETA, &savetty) == -1)
#endif
	  {
	    printf("stdin must be a tty\n");
	    exit(1);
	  }
	newtty=savetty;
	newtty.c_lflag&=~ICANON;
	newtty.c_lflag&=~ECHO;
	newtty.c_cc[VMIN]=1;
  	set_tty();
	signal(SIGTSTP, onsusp);

  do{
    if(file_addr < 0) file_addr = 0;
    showblock(1);
    read (0, &c, 1);
    if (c == 'a') file_addr -= PAGE;
    if (c == 'b') file_addr += PAGE;
    if (c == 'g') {
      crsr2(20,1);
      printf("Enter new starting block (in hex):");
      scanf("%x",&file_addr);
      file_addr = file_addr << 11;
      crsr2(20,1);
      printf("                                     ");
    };
    if (c == 'f') {
      crsr2(20,1);
      printf("Enter new search string:");
      fgets((char *)search,sizeof(search),stdin);
      while(search[strlen(search)-1] == '\n') search[strlen(search)-1] = 0;
      crsr2(20,1);
      printf("                                     ");
    };
    if (c == '+') {
      while(1==1){
	while(1==1){
	  c = getbyte(&file_addr);
	  if (c == search[0]) break;
	};
	for (j=1;j<strlen(search);j++) 
	  if(search[j] != getbyte()) break;
	if(j==strlen(search)) break;
      };
      file_addr &= ~(PAGE-1);
      showblock(1);
    };
    if (c == 'q') break;
  } while(1==1);
  reset_tty();
  fclose(infile);
}
  



@
