head	1.22;
access;
symbols
	OPENBSD_5_6:1.21.0.6
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.20.0.10
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.8
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.6
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.19.0.12
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.10
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.6
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.8
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.4
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.18.0.6
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.6
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.4
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2014.09.17.18.49.50;	author matthieu;	state dead;
branches;
next	1.21;
commitid	M7i5giHIoz3DMlTU;

1.21
date	2014.02.07.21.24.59;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2011.05.17.15.54.23;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.22.18.43.54;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.16.00.21.30;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.24.03.59.25;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.19.01.41.13;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.17.17.31.39;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.03.17.31.21;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.01.19.59.21;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.15.02.23.35;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.03.17.25.46;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.18.00.49.27;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.29.01.31.12;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.28.02.43.51;	author millert;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.01.15.21.09.02;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.43;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.52;	author millert;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	2001.05.31.00.28.50;	author miod;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.31.01.47.53;	author jason;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Bye.
@
text
@/*
 *  Copyright (c) 1999-2007 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sm/gen.h>
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.127 2013/11/22 20:51:36 ca Exp $")

/*
**  listener.c -- threaded network listener
*/

#include "libmilter.h"
#include <sm/errstring.h>

#include <sys/types.h>
#include <sys/stat.h>


# if NETINET || NETINET6
#  include <arpa/inet.h>
# endif /* NETINET || NETINET6 */
# if SM_CONF_POLL
#  undef SM_FD_OK_SELECT
#  define SM_FD_OK_SELECT(fd)		true
# endif /* SM_CONF_POLL */

static smutex_t L_Mutex;
static int L_family;
static SOCKADDR_LEN_T L_socksize;
static socket_t listenfd = INVALID_SOCKET;

static socket_t mi_milteropen __P((char *, int, bool, char *));
#if !_FFR_WORKERS_POOL
static void *mi_thread_handle_wrapper __P((void *));
#endif /* !_FFR_WORKERS_POOL */

/*
**  MI_OPENSOCKET -- create the socket where this filter and the MTA will meet
**
**	Parameters:
**		conn -- connection description
**		backlog -- listen backlog
**		dbg -- debug level
**		rmsocket -- if true, try to unlink() the socket first
**			(UNIX domain sockets only)
**		smfi -- filter structure to use
**
**	Return value:
**		MI_SUCCESS/MI_FAILURE
*/

int
mi_opensocket(conn, backlog, dbg, rmsocket, smfi)
	char *conn;
	int backlog;
	int dbg;
	bool rmsocket;
	smfiDesc_ptr smfi;
{
	if (smfi == NULL || conn == NULL)
		return MI_FAILURE;

	if (ValidSocket(listenfd))
		return MI_SUCCESS;

	if (dbg > 0)
	{
		smi_log(SMI_LOG_DEBUG,
			"%s: Opening listen socket on conn %s",
			smfi->xxfi_name, conn);
	}
	(void) smutex_init(&L_Mutex);
	(void) smutex_lock(&L_Mutex);
	listenfd = mi_milteropen(conn, backlog, rmsocket, smfi->xxfi_name);
	if (!ValidSocket(listenfd))
	{
		smi_log(SMI_LOG_FATAL,
			"%s: Unable to create listening socket on conn %s",
			smfi->xxfi_name, conn);
		(void) smutex_unlock(&L_Mutex);
		return MI_FAILURE;
	}
	if (!SM_FD_OK_SELECT(listenfd))
	{
		smi_log(SMI_LOG_ERR, "%s: fd %d is larger than FD_SETSIZE %d",
			smfi->xxfi_name, listenfd, FD_SETSIZE);
		(void) smutex_unlock(&L_Mutex);
		return MI_FAILURE;
	}
	(void) smutex_unlock(&L_Mutex);
	return MI_SUCCESS;
}

/*
**  MI_MILTEROPEN -- setup socket to listen on
**
**	Parameters:
**		conn -- connection description
**		backlog -- listen backlog
**		rmsocket -- if true, try to unlink() the socket first
**			(UNIX domain sockets only)
**		name -- name for logging
**
**	Returns:
**		socket upon success, error code otherwise.
**
**	Side effect:
**		sets sockpath if UNIX socket.
*/

#if NETUNIX
static char	*sockpath = NULL;
#endif /* NETUNIX */

static socket_t
mi_milteropen(conn, backlog, rmsocket, name)
	char *conn;
	int backlog;
	bool rmsocket;
	char *name;
{
	socket_t sock;
	int sockopt = 1;
	int fdflags;
	size_t len = 0;
	char *p;
	char *colon;
	char *at;
	SOCKADDR addr;

	if (conn == NULL || conn[0] == '\0')
	{
		smi_log(SMI_LOG_ERR, "%s: empty or missing socket information",
			name);
		return INVALID_SOCKET;
	}
	(void) memset(&addr, '\0', sizeof addr);

	/* protocol:filename or protocol:port@@host */
	p = conn;
	colon = strchr(p, ':');
	if (colon != NULL)
	{
		*colon = '\0';

		if (*p == '\0')
		{
#if NETUNIX
			/* default to AF_UNIX */
			addr.sa.sa_family = AF_UNIX;
			L_socksize = sizeof (struct sockaddr_un);
#else /* NETUNIX */
# if NETINET
			/* default to AF_INET */
			addr.sa.sa_family = AF_INET;
			L_socksize = sizeof addr.sin;
# else /* NETINET */
#  if NETINET6
			/* default to AF_INET6 */
			addr.sa.sa_family = AF_INET6;
			L_socksize = sizeof addr.sin6;
#  else /* NETINET6 */
			/* no protocols available */
			smi_log(SMI_LOG_ERR,
				"%s: no valid socket protocols available",
				name);
			return INVALID_SOCKET;
#  endif /* NETINET6 */
# endif /* NETINET */
#endif /* NETUNIX */
		}
#if NETUNIX
		else if (strcasecmp(p, "unix") == 0 ||
			 strcasecmp(p, "local") == 0)
		{
			addr.sa.sa_family = AF_UNIX;
			L_socksize = sizeof (struct sockaddr_un);
		}
#endif /* NETUNIX */
#if NETINET
		else if (strcasecmp(p, "inet") == 0)
		{
			addr.sa.sa_family = AF_INET;
			L_socksize = sizeof addr.sin;
		}
#endif /* NETINET */
#if NETINET6
		else if (strcasecmp(p, "inet6") == 0)
		{
			addr.sa.sa_family = AF_INET6;
			L_socksize = sizeof addr.sin6;
		}
#endif /* NETINET6 */
		else
		{
			smi_log(SMI_LOG_ERR, "%s: unknown socket type %s",
				name, p);
			return INVALID_SOCKET;
		}
		*colon++ = ':';
	}
	else
	{
		colon = p;
#if NETUNIX
		/* default to AF_UNIX */
		addr.sa.sa_family = AF_UNIX;
		L_socksize = sizeof (struct sockaddr_un);
#else /* NETUNIX */
# if NETINET
		/* default to AF_INET */
		addr.sa.sa_family = AF_INET;
		L_socksize = sizeof addr.sin;
# else /* NETINET */
#  if NETINET6
		/* default to AF_INET6 */
		addr.sa.sa_family = AF_INET6;
		L_socksize = sizeof addr.sin6;
#  else /* NETINET6 */
		smi_log(SMI_LOG_ERR, "%s: unknown socket type %s",
			name, p);
		return INVALID_SOCKET;
#  endif /* NETINET6 */
# endif /* NETINET */
#endif /* NETUNIX */
	}

#if NETUNIX
	if (addr.sa.sa_family == AF_UNIX)
	{
# if 0
		long sff = SFF_SAFEDIRPATH|SFF_OPENASROOT|SFF_NOLINK|SFF_CREAT|SFF_MUSTOWN;
# endif /* 0 */

		at = colon;
		len = strlen(colon) + 1;
		if (len >= sizeof addr.sunix.sun_path)
		{
			errno = EINVAL;
			smi_log(SMI_LOG_ERR, "%s: UNIX socket name %s too long",
				name, colon);
			return INVALID_SOCKET;
		}
		(void) sm_strlcpy(addr.sunix.sun_path, colon,
				sizeof addr.sunix.sun_path);
# if 0
		errno = safefile(colon, RunAsUid, RunAsGid, RunAsUserName, sff,
				 S_IRUSR|S_IWUSR, NULL);

		/* if not safe, don't create */
		if (errno != 0)
		{
			smi_log(SMI_LOG_ERR,
				"%s: UNIX socket name %s unsafe",
				name, colon);
			return INVALID_SOCKET;
		}
# endif /* 0 */
	}
#endif /* NETUNIX */

#if NETINET || NETINET6
	if (
# if NETINET
	    addr.sa.sa_family == AF_INET
# endif /* NETINET */
# if NETINET && NETINET6
	    ||
# endif /* NETINET && NETINET6 */
# if NETINET6
	    addr.sa.sa_family == AF_INET6
# endif /* NETINET6 */
	   )
	{
		unsigned short port;

		/* Parse port@@host */
		at = strchr(colon, '@@');
		if (at == NULL)
		{
			switch (addr.sa.sa_family)
			{
# if NETINET
			  case AF_INET:
				addr.sin.sin_addr.s_addr = INADDR_ANY;
				break;
# endif /* NETINET */

# if NETINET6
			  case AF_INET6:
				addr.sin6.sin6_addr = in6addr_any;
				break;
# endif /* NETINET6 */
			}
		}
		else
			*at = '\0';

		if (isascii(*colon) && isdigit(*colon))
			port = htons((unsigned short) atoi(colon));
		else
		{
# ifdef NO_GETSERVBYNAME
			smi_log(SMI_LOG_ERR, "%s: invalid port number %s",
				name, colon);
			return INVALID_SOCKET;
# else /* NO_GETSERVBYNAME */
			register struct servent *sp;

			sp = getservbyname(colon, "tcp");
			if (sp == NULL)
			{
				smi_log(SMI_LOG_ERR,
					"%s: unknown port name %s",
					name, colon);
				return INVALID_SOCKET;
			}
			port = sp->s_port;
# endif /* NO_GETSERVBYNAME */
		}
		if (at != NULL)
		{
			*at++ = '@@';
			if (*at == '[')
			{
				char *end;

				end = strchr(at, ']');
				if (end != NULL)
				{
					bool found = false;
# if NETINET
					unsigned long hid = INADDR_NONE;
# endif /* NETINET */
# if NETINET6
					struct sockaddr_in6 hid6;
# endif /* NETINET6 */

					*end = '\0';
# if NETINET
					if (addr.sa.sa_family == AF_INET &&
					    (hid = inet_addr(&at[1])) != INADDR_NONE)
					{
						addr.sin.sin_addr.s_addr = hid;
						addr.sin.sin_port = port;
						found = true;
					}
# endif /* NETINET */
# if NETINET6
					(void) memset(&hid6, '\0', sizeof hid6);
					if (addr.sa.sa_family == AF_INET6 &&
					    mi_inet_pton(AF_INET6, &at[1],
							 &hid6.sin6_addr) == 1)
					{
						addr.sin6.sin6_addr = hid6.sin6_addr;
						addr.sin6.sin6_port = port;
						found = true;
					}
# endif /* NETINET6 */
					*end = ']';
					if (!found)
					{
						smi_log(SMI_LOG_ERR,
							"%s: Invalid numeric domain spec \"%s\"",
							name, at);
						return INVALID_SOCKET;
					}
				}
				else
				{
					smi_log(SMI_LOG_ERR,
						"%s: Invalid numeric domain spec \"%s\"",
						name, at);
					return INVALID_SOCKET;
				}
			}
			else
			{
				struct hostent *hp = NULL;

				hp = mi_gethostbyname(at, addr.sa.sa_family);
				if (hp == NULL)
				{
					smi_log(SMI_LOG_ERR,
						"%s: Unknown host name %s",
						name, at);
					return INVALID_SOCKET;
				}
				addr.sa.sa_family = hp->h_addrtype;
				switch (hp->h_addrtype)
				{
# if NETINET
				  case AF_INET:
					(void) memmove(&addr.sin.sin_addr,
						       hp->h_addr,
						       INADDRSZ);
					addr.sin.sin_port = port;
					break;
# endif /* NETINET */

# if NETINET6
				  case AF_INET6:
					(void) memmove(&addr.sin6.sin6_addr,
						       hp->h_addr,
						       IN6ADDRSZ);
					addr.sin6.sin6_port = port;
					break;
# endif /* NETINET6 */

				  default:
					smi_log(SMI_LOG_ERR,
						"%s: Unknown protocol for %s (%d)",
						name, at, hp->h_addrtype);
					return INVALID_SOCKET;
				}
# if NETINET6
				freehostent(hp);
# endif /* NETINET6 */
			}
		}
		else
		{
			switch (addr.sa.sa_family)
			{
# if NETINET
			  case AF_INET:
				addr.sin.sin_port = port;
				break;
# endif /* NETINET */
# if NETINET6
			  case AF_INET6:
				addr.sin6.sin6_port = port;
				break;
# endif /* NETINET6 */
			}
		}
	}
#endif /* NETINET || NETINET6 */

	sock = socket(addr.sa.sa_family, SOCK_STREAM, 0);
	if (!ValidSocket(sock))
	{
		smi_log(SMI_LOG_ERR,
			"%s: Unable to create new socket: %s",
			name, sm_errstring(errno));
		return INVALID_SOCKET;
	}

	if ((fdflags = fcntl(sock, F_GETFD, 0)) == -1 ||
	    fcntl(sock, F_SETFD, fdflags | FD_CLOEXEC) == -1)
	{
		smi_log(SMI_LOG_ERR,
			"%s: Unable to set close-on-exec: %s", name,
			sm_errstring(errno));
		(void) closesocket(sock);
		return INVALID_SOCKET;
	}

	if (
#if NETUNIX
	    addr.sa.sa_family != AF_UNIX &&
#endif /* NETUNIX */
	    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *) &sockopt,
		       sizeof(sockopt)) == -1)
	{
		smi_log(SMI_LOG_ERR,
			"%s: set reuseaddr failed (%s)", name,
			sm_errstring(errno));
		(void) closesocket(sock);
		return INVALID_SOCKET;
	}

#if NETUNIX
	if (addr.sa.sa_family == AF_UNIX && rmsocket)
	{
		struct stat s;

		if (stat(colon, &s) != 0)
		{
			if (errno != ENOENT)
			{
				smi_log(SMI_LOG_ERR,
					"%s: Unable to stat() %s: %s",
					name, colon, sm_errstring(errno));
				(void) closesocket(sock);
				return INVALID_SOCKET;
			}
		}
		else if (!S_ISSOCK(s.st_mode))
		{
			smi_log(SMI_LOG_ERR,
				"%s: %s is not a UNIX domain socket",
				name, colon);
			(void) closesocket(sock);
			return INVALID_SOCKET;
		}
		else if (unlink(colon) != 0)
		{
			smi_log(SMI_LOG_ERR,
				"%s: Unable to remove %s: %s",
				name, colon, sm_errstring(errno));
			(void) closesocket(sock);
			return INVALID_SOCKET;
		}
	}
#endif /* NETUNIX */

	if (bind(sock, &addr.sa, L_socksize) < 0)
	{
		smi_log(SMI_LOG_ERR,
			"%s: Unable to bind to port %s: %s",
			name, conn, sm_errstring(errno));
		(void) closesocket(sock);
		return INVALID_SOCKET;
	}

	if (listen(sock, backlog) < 0)
	{
		smi_log(SMI_LOG_ERR,
			"%s: listen call failed: %s", name,
			sm_errstring(errno));
		(void) closesocket(sock);
		return INVALID_SOCKET;
	}

#if NETUNIX
	if (addr.sa.sa_family == AF_UNIX && len > 0)
	{
		/*
		**  Set global variable sockpath so the UNIX socket can be
		**  unlink()ed at exit.
		*/

		sockpath = (char *) malloc(len);
		if (sockpath != NULL)
			(void) sm_strlcpy(sockpath, colon, len);
		else
		{
			smi_log(SMI_LOG_ERR,
				"%s: can't malloc(%d) for sockpath: %s",
				name, (int) len, sm_errstring(errno));
			(void) closesocket(sock);
			return INVALID_SOCKET;
		}
	}
#endif /* NETUNIX */
	L_family = addr.sa.sa_family;
	return sock;
}

#if !_FFR_WORKERS_POOL
/*
**  MI_THREAD_HANDLE_WRAPPER -- small wrapper to handle session
**
**	Parameters:
**		arg -- argument to pass to mi_handle_session()
**
**	Returns:
**		results from mi_handle_session()
*/

static void *
mi_thread_handle_wrapper(arg)
	void *arg;
{
	/*
	**  Note: on some systems this generates a compiler warning:
	**  cast to pointer from integer of different size
	**  You can safely ignore this warning as the result of this function
	**  is not used anywhere.
	*/

	return (void *) mi_handle_session(arg);
}
#endif /* _FFR_WORKERS_POOL */

/*
**  MI_CLOSENER -- close listen socket
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
*/

void
mi_closener()
{
	(void) smutex_lock(&L_Mutex);
	if (ValidSocket(listenfd))
	{
#if NETUNIX
		bool removable;
		struct stat sockinfo;
		struct stat fileinfo;

		removable = sockpath != NULL &&
			    geteuid() != 0 &&
			    fstat(listenfd, &sockinfo) == 0 &&
			    (S_ISFIFO(sockinfo.st_mode)
# ifdef S_ISSOCK
			     || S_ISSOCK(sockinfo.st_mode)
# endif /* S_ISSOCK */
			    );
#endif /* NETUNIX */

		(void) closesocket(listenfd);
		listenfd = INVALID_SOCKET;

#if NETUNIX
		/* XXX sleep() some time before doing this? */
		if (sockpath != NULL)
		{
			if (removable &&
			    stat(sockpath, &fileinfo) == 0 &&
			    ((fileinfo.st_dev == sockinfo.st_dev &&
			      fileinfo.st_ino == sockinfo.st_ino)
# ifdef S_ISSOCK
			     || S_ISSOCK(fileinfo.st_mode)
# endif /* S_ISSOCK */
			    )
			    &&
			    (S_ISFIFO(fileinfo.st_mode)
# ifdef S_ISSOCK
			     || S_ISSOCK(fileinfo.st_mode)
# endif /* S_ISSOCK */
			     ))
				(void) unlink(sockpath);
			free(sockpath);
			sockpath = NULL;
		}
#endif /* NETUNIX */
	}
	(void) smutex_unlock(&L_Mutex);
}

/*
**  MI_LISTENER -- Generic listener harness
**
**	Open up listen port
**	Wait for connections
**
**	Parameters:
**		conn -- connection description
**		dbg -- debug level
**		smfi -- filter structure to use
**		timeout -- timeout for reads/writes
**		backlog -- listen queue backlog size
**
**	Returns:
**		MI_SUCCESS -- Exited normally
**			   (session finished or we were told to exit)
**		MI_FAILURE -- Network initialization failed.
*/

#if BROKEN_PTHREAD_SLEEP

/*
**  Solaris 2.6, perhaps others, gets an internal threads library panic
**  when sleep() is used:
**
**  thread_create() failed, returned 11 (EINVAL)
**  co_enable, thr_create() returned error = 24
**  libthread panic: co_enable failed (PID: 17793 LWP 1)
**  stacktrace:
**	ef526b10
**	ef52646c
**	ef534cbc
**	156a4
**	14644
**	1413c
**	135e0
**	0
*/

# define MI_SLEEP(s)							\
{									\
	int rs = 0;							\
	struct timeval st;						\
									\
	st.tv_sec = (s);						\
	st.tv_usec = 0;							\
	if (st.tv_sec > 0)						\
	{								\
		for (;;)						\
		{							\
			rs = select(0, NULL, NULL, NULL, &st);		\
			if (rs < 0 && errno == EINTR)			\
				continue;				\
			if (rs != 0)					\
			{						\
				smi_log(SMI_LOG_ERR,			\
					"MI_SLEEP(): select() returned non-zero result %d, errno = %d",	\
					rs, errno);			\
			}						\
			break;						\
		}							\
	}								\
}
#else /* BROKEN_PTHREAD_SLEEP */
# define MI_SLEEP(s)	sleep((s))
#endif /* BROKEN_PTHREAD_SLEEP */

int
mi_listener(conn, dbg, smfi, timeout, backlog)
	char *conn;
	int dbg;
	smfiDesc_ptr smfi;
	time_t timeout;
	int backlog;
{
	socket_t connfd = INVALID_SOCKET;
#if _FFR_DUP_FD
	socket_t dupfd = INVALID_SOCKET;
#endif /* _FFR_DUP_FD */
	int sockopt = 1;
	int r, mistop;
	int ret = MI_SUCCESS;
	int mcnt = 0;	/* error count for malloc() failures */
	int tcnt = 0;	/* error count for thread_create() failures */
	int acnt = 0;	/* error count for accept() failures */
	int scnt = 0;	/* error count for select() failures */
	int save_errno = 0;
#if !_FFR_WORKERS_POOL
	sthread_t thread_id;
#endif /* !_FFR_WORKERS_POOL */
	_SOCK_ADDR cliaddr;
	SOCKADDR_LEN_T clilen;
	SMFICTX_PTR ctx;
	FD_RD_VAR(rds, excs);
	struct timeval chktime;

	if (mi_opensocket(conn, backlog, dbg, false, smfi) == MI_FAILURE)
		return MI_FAILURE;

#if _FFR_WORKERS_POOL
	if (mi_pool_controller_init() == MI_FAILURE)
		return MI_FAILURE;
#endif /* _FFR_WORKERS_POOL */

	clilen = L_socksize;
	while ((mistop = mi_stop()) == MILTER_CONT)
	{
		(void) smutex_lock(&L_Mutex);
		if (!ValidSocket(listenfd))
		{
			ret = MI_FAILURE;
			smi_log(SMI_LOG_ERR,
				"%s: listenfd=%d corrupted, terminating, errno=%d",
				smfi->xxfi_name, listenfd, errno);
			(void) smutex_unlock(&L_Mutex);
			break;
		}

		/* select on interface ports */
		FD_RD_INIT(listenfd, rds, excs);
		chktime.tv_sec = MI_CHK_TIME;
		chktime.tv_usec = 0;
		r = FD_RD_READY(listenfd, rds, excs, &chktime);
		if (r == 0)		/* timeout */
		{
			(void) smutex_unlock(&L_Mutex);
			continue;	/* just check mi_stop() */
		}
		if (r < 0)
		{
			save_errno = errno;
			(void) smutex_unlock(&L_Mutex);
			if (save_errno == EINTR)
				continue;
			scnt++;
			smi_log(SMI_LOG_ERR,
				"%s: %s() failed (%s), %s",
				smfi->xxfi_name, MI_POLLSELECT,
				sm_errstring(save_errno),
				scnt >= MAX_FAILS_S ? "abort" : "try again");
			MI_SLEEP(scnt);
			if (scnt >= MAX_FAILS_S)
			{
				ret = MI_FAILURE;
				break;
			}
			continue;
		}
		if (!FD_IS_RD_RDY(listenfd, rds, excs))
		{
			/* some error: just stop for now... */
			ret = MI_FAILURE;
			(void) smutex_unlock(&L_Mutex);
			smi_log(SMI_LOG_ERR,
				"%s: %s() returned exception for socket, abort",
				smfi->xxfi_name, MI_POLLSELECT);
			break;
		}
		scnt = 0;	/* reset error counter for select() */

		(void) memset(&cliaddr, '\0', sizeof cliaddr);
		connfd = accept(listenfd, (struct sockaddr *) &cliaddr,
				&clilen);
		save_errno = errno;
		(void) smutex_unlock(&L_Mutex);

		/*
		**  If remote side closes before accept() finishes,
		**  sockaddr might not be fully filled in.
		*/

		if (ValidSocket(connfd) &&
		    (clilen == 0 ||
# ifdef BSD4_4_SOCKADDR
		     cliaddr.sa.sa_len == 0 ||
# endif /* BSD4_4_SOCKADDR */
		     cliaddr.sa.sa_family != L_family))
		{
			(void) closesocket(connfd);
			connfd = INVALID_SOCKET;
			save_errno = EINVAL;
		}

		/* check if acceptable for select() */
		if (ValidSocket(connfd) && !SM_FD_OK_SELECT(connfd))
		{
			(void) closesocket(connfd);
			connfd = INVALID_SOCKET;
			save_errno = ERANGE;
		}

		if (!ValidSocket(connfd))
		{
			if (save_errno == EINTR
#ifdef EAGAIN
			    || save_errno == EAGAIN
#endif /* EAGAIN */
#ifdef ECONNABORTED
			    || save_errno == ECONNABORTED
#endif /* ECONNABORTED */
#ifdef EMFILE
			    || save_errno == EMFILE
#endif /* EMFILE */
#ifdef ENFILE
			    || save_errno == ENFILE
#endif /* ENFILE */
#ifdef ENOBUFS
			    || save_errno == ENOBUFS
#endif /* ENOBUFS */
#ifdef ENOMEM
			    || save_errno == ENOMEM
#endif /* ENOMEM */
#ifdef ENOSR
			    || save_errno == ENOSR
#endif /* ENOSR */
#ifdef EWOULDBLOCK
			    || save_errno == EWOULDBLOCK
#endif /* EWOULDBLOCK */
			   )
				continue;
			acnt++;
			smi_log(SMI_LOG_ERR,
				"%s: accept() returned invalid socket (%s), %s",
				smfi->xxfi_name, sm_errstring(save_errno),
				acnt >= MAX_FAILS_A ? "abort" : "try again");
			MI_SLEEP(acnt);
			if (acnt >= MAX_FAILS_A)
			{
				ret = MI_FAILURE;
				break;
			}
			continue;
		}
		acnt = 0;	/* reset error counter for accept() */
#if _FFR_DUP_FD
		dupfd = fcntl(connfd, F_DUPFD, 256);
		if (ValidSocket(dupfd) && SM_FD_OK_SELECT(dupfd))
		{
			close(connfd);
			connfd = dupfd;
			dupfd = INVALID_SOCKET;
		}
#endif /* _FFR_DUP_FD */

		if (setsockopt(connfd, SOL_SOCKET, SO_KEEPALIVE,
				(void *) &sockopt, sizeof sockopt) < 0)
		{
			smi_log(SMI_LOG_WARN,
				"%s: set keepalive failed (%s)",
				smfi->xxfi_name, sm_errstring(errno));
			/* XXX: continue? */
		}
		if ((ctx = (SMFICTX_PTR) malloc(sizeof *ctx)) == NULL)
		{
			(void) closesocket(connfd);
			mcnt++;
			smi_log(SMI_LOG_ERR, "%s: malloc(ctx) failed (%s), %s",
				smfi->xxfi_name, sm_errstring(save_errno),
				mcnt >= MAX_FAILS_M ? "abort" : "try again");
			MI_SLEEP(mcnt);
			if (mcnt >= MAX_FAILS_M)
			{
				ret = MI_FAILURE;
				break;
			}
			continue;
		}
		mcnt = 0;	/* reset error counter for malloc() */
		(void) memset(ctx, '\0', sizeof *ctx);
		ctx->ctx_sd = connfd;
		ctx->ctx_dbg = dbg;
		ctx->ctx_timeout = timeout;
		ctx->ctx_smfi = smfi;
		if (smfi->xxfi_connect == NULL)
			ctx->ctx_pflags |= SMFIP_NOCONNECT;
		if (smfi->xxfi_helo == NULL)
			ctx->ctx_pflags |= SMFIP_NOHELO;
		if (smfi->xxfi_envfrom == NULL)
			ctx->ctx_pflags |= SMFIP_NOMAIL;
		if (smfi->xxfi_envrcpt == NULL)
			ctx->ctx_pflags |= SMFIP_NORCPT;
		if (smfi->xxfi_header == NULL)
			ctx->ctx_pflags |= SMFIP_NOHDRS;
		if (smfi->xxfi_eoh == NULL)
			ctx->ctx_pflags |= SMFIP_NOEOH;
		if (smfi->xxfi_body == NULL)
			ctx->ctx_pflags |= SMFIP_NOBODY;
		if (smfi->xxfi_version <= 3 || smfi->xxfi_data == NULL)
			ctx->ctx_pflags |= SMFIP_NODATA;
		if (smfi->xxfi_version <= 2 || smfi->xxfi_unknown == NULL)
			ctx->ctx_pflags |= SMFIP_NOUNKNOWN;

#if _FFR_WORKERS_POOL
# define LOG_CRT_FAIL	"%s: mi_start_session() failed: %d, %s"
		if ((r = mi_start_session(ctx)) != MI_SUCCESS)
#else /* _FFR_WORKERS_POOL */
# define LOG_CRT_FAIL	"%s: thread_create() failed: %d, %s"
		if ((r = thread_create(&thread_id,
					mi_thread_handle_wrapper,
					(void *) ctx)) != 0)
#endif /* _FFR_WORKERS_POOL */
		{
			tcnt++;
			smi_log(SMI_LOG_ERR,
				LOG_CRT_FAIL,
				smfi->xxfi_name,  r,
				tcnt >= MAX_FAILS_T ? "abort" : "try again");
			MI_SLEEP(tcnt);
			(void) closesocket(connfd);
			free(ctx);
			if (tcnt >= MAX_FAILS_T)
			{
				ret = MI_FAILURE;
				break;
			}
			continue;
		}
		tcnt = 0;
	}
	if (ret != MI_SUCCESS)
		mi_stop_milters(MILTER_ABRT);
	else
	{
		if (mistop != MILTER_CONT)
			smi_log(SMI_LOG_INFO, "%s: mi_stop=%d",
				smfi->xxfi_name, mistop);
		mi_closener();
	}
	(void) smutex_destroy(&L_Mutex);
	return ret;
}
@


1.21
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.20
log
@Update to sendmail 8.14.5
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2007 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.126 2009/12/16 16:40:23 ca Exp $")
@


1.19
log
@Update to sendmail-8.14.3
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.124 2007/04/23 22:22:50 ca Exp $")
d780 3
a782 2
				"%s: select() failed (%s), %s",
				smfi->xxfi_name, sm_errstring(save_errno),
@


1.18
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2006 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.122 2006/11/02 17:54:44 ca Exp $")
d930 1
a930 1
		if (smfi->xxfi_data == NULL)
d932 1
a932 1
		if (smfi->xxfi_unknown == NULL)
@


1.17
log
@Update to sendmail 8.13.6
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.115 2006/01/24 00:48:39 ca Exp $")
d28 4
d39 1
d41 1
a88 1
#if !SM_CONF_POLL
a95 1
#endif /* !SM_CONF_POLL */
d556 2
d572 7
d581 1
d731 1
d733 1
d743 5
d810 2
a811 3
		**  If remote side closes before
		**  accept() finishes, sockaddr
		**  might not be fully filled in.
a825 1
#if !SM_CONF_POLL
a832 1
#endif /* !SM_CONF_POLL */
d879 1
a879 5
		if (ValidSocket(dupfd)
# if !SM_CONF_POLL
		    && SM_FD_OK_SELECT(dupfd)
# endif /* !SM_CONF_POLL */
		   )
a915 6
#if 0
		if (smfi->xxfi_eoh == NULL)
		if (smfi->xxfi_eom == NULL)
		if (smfi->xxfi_abort == NULL)
		if (smfi->xxfi_close == NULL)
#endif /* 0 */
d930 10
a939 1

d943 1
d947 1
a947 1
				"%s: thread_create() failed: %d, %s",
@


1.16
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2004 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.111 2004/09/20 21:11:15 msk Exp $")
d461 5
a465 1
	if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *) &sockopt,
d469 1
a469 1
			"%s: Unable to setsockopt: %s", name,
a571 3
**	NOTE: It is assumed that this function is called from a
**	      function that has a mutex lock (currently mi_stop_milters()).
**
d876 2
a877 1
			smi_log(SMI_LOG_WARN, "%s: setsockopt() failed (%s)",
@


1.15
log
@Update to sendmail.8.13.0
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2003 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.109 2004/02/04 22:55:59 ca Exp $")
d35 1
d92 1
d558 1
a558 1
void *
a726 1
	(void) smutex_unlock(&L_Mutex);
@


1.14
log
@Update to sendmail 8.12.11.  I've been runninga beta version of this for
some time without problems.  See the RELEASE_NOTES for the change log.
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.85.2.17 2003/10/21 17:22:57 ca Exp $")
d44 1
a44 1
**		            (UNIX domain sockets only)
d82 1
a82 1
#if !_FFR_USE_POLL
d90 1
a90 1
#endif /* !_FFR_USE_POLL */
a587 1
#if _FFR_MILTER_ROOT_UNSAFE
a588 1
#endif /* _FFR_MILTER_ROOT_UNSAFE */
a635 2
**		rmsocket -- if true, try to unlink() the socket first
**			(UNIX domain sockets only)
d703 3
d804 1
a804 1
#if !_FFR_USE_POLL
d812 1
a812 1
#endif /* !_FFR_USE_POLL */
d816 26
a841 1
			if (save_errno == EINTR)
d857 13
@


1.13
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.85.2.12 2003/08/04 18:47:29 ca Exp $")
d21 3
d34 1
a34 1
static socket_t mi_milteropen __P((char *, int, char *));
d39 1
a39 1
**  	Parameters:
d42 3
a44 1
**  		dbg -- debug level
d47 2
a48 2
**  	Return value:
**  		MI_SUCCESS/MI_FAILURE
d52 1
a52 1
mi_opensocket(conn, backlog, dbg, smfi)
d56 1
d73 1
a73 1
	listenfd = mi_milteropen(conn, backlog, smfi->xxfi_name);
d100 2
d116 1
a116 1
mi_milteropen(conn, backlog, name)
d119 1
d469 35
d638 2
d642 1
a642 1
**  		backlog -- listen queue backlog size
d722 1
a722 1
	if (mi_opensocket(conn, backlog, dbg, smfi) == MI_FAILURE)
@


1.12
log
@Update to Sendmail 8.12.8; fixes a buffer overflow in the envelope
comments processing which may allow an attacker to gain root privileges.
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.85.2.9 2003/01/03 22:14:40 ca Exp $")
d385 3
a387 3
					memmove(&addr.sin.sin_addr,
						hp->h_addr,
						INADDRSZ);
d394 3
a396 3
					memmove(&addr.sin6.sin6_addr,
						hp->h_addr,
						IN6ADDRSZ);
d662 1
a662 1
	int r;
d681 1
a681 1
	while (mi_stop() == MILTER_CONT)
d686 4
d735 1
a735 1
		memset(&cliaddr, '\0', sizeof cliaddr);
d811 1
a811 1
		memset(ctx, '\0', sizeof *ctx);
d861 4
d866 1
@


1.11
log
@update to sendmail 8.12.7
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2002 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.85.2.7 2002/12/10 04:02:25 ca Exp $")
a19 1
#include <sm/fdset.h>
d76 1
d84 1
d673 1
a673 1
	fd_set readset, excset;
d691 1
a691 4
		FD_ZERO(&readset);
		FD_ZERO(&excset);
		FD_SET((unsigned int) listenfd, &readset);
		FD_SET((unsigned int) listenfd, &excset);
d694 1
a694 1
		r = select(listenfd + 1, &readset, NULL, &excset, &chktime);
d719 1
a719 1
		if (!FD_ISSET(listenfd, &readset))
d725 2
a726 2
				"%s: select() returned exception for socket, abort",
				smfi->xxfi_name);
d755 1
d763 1
@


1.10
log
@update to sendmail-8.12.6
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.85.2.1 2002/08/09 22:13:36 gshapiro Exp $")
d20 1
d77 7
a83 1

d492 1
a492 1
				name, len, sm_errstring(errno));
d640 1
a640 1
					"MI_SLEEP(): select() returned non-zero result %d, errno = %d",						\
d643 1
a678 8

	if (listenfd >= FD_SETSIZE)
	{
		smi_log(SMI_LOG_ERR, "%s: fd %d is larger than FD_SETSIZE %d",
			smfi->xxfi_name, listenfd, FD_SETSIZE);
		(void) smutex_unlock(&L_Mutex);
		return MI_FAILURE;
	}
a679 1

d755 8
@


1.9
log
@Update to sendmail-8.12.4
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.85 2002/05/28 18:17:41 gshapiro Exp $")
a623 2
		rs = select(0, NULL, NULL, NULL, &st);			\
	if (rs != 0)							\
d625 12
a636 3
		smi_log(SMI_LOG_ERR,					\
			"MI_SLEEP(): select() returned non-zero result %d, errno = %d",								\
			rs, errno);					\
@


1.8
log
@update to sendmail 8.12.3
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.82 2002/01/22 18:46:47 ca Exp $")
d27 52
a85 2
**		socksize -- socksize of created socket
**		family -- family of created socket
d100 1
a100 1
mi_milteropen(conn, backlog, socksize, family, name)
a102 2
	SOCKADDR_LEN_T *socksize;
	int *family;
d107 1
d134 1
a134 1
			*socksize = sizeof (struct sockaddr_un);
d139 1
a139 1
			*socksize = sizeof addr.sin;
d144 1
a144 1
			*socksize = sizeof addr.sin6;
d160 1
a160 1
			*socksize = sizeof (struct sockaddr_un);
d167 1
a167 1
			*socksize = sizeof addr.sin;
d174 1
a174 1
			*socksize = sizeof addr.sin6;
d191 1
a191 1
		*socksize = sizeof (struct sockaddr_un);
d196 1
a196 1
		*socksize = sizeof addr.sin;
d201 1
a201 1
		*socksize = sizeof addr.sin6;
d432 10
d452 1
a452 1
	if (bind(sock, &addr.sa, *socksize) < 0)
d491 1
a491 1
	*family = addr.sa.sa_family;
a510 2
static socket_t listenfd = INVALID_SOCKET;

d588 1
a644 1
	int family = AF_UNSPEC;
a654 1
	SOCKADDR_LEN_T socksize;
d660 1
a660 14
	if (dbg > 0)
		smi_log(SMI_LOG_DEBUG,
			"%s: Opening listen socket on conn %s",
			smfi->xxfi_name, conn);
	(void) smutex_init(&L_Mutex);
	(void) smutex_lock(&L_Mutex);
	listenfd = mi_milteropen(conn, backlog, &socksize, &family,
				 smfi->xxfi_name);
	if (!ValidSocket(listenfd))
	{
		smi_log(SMI_LOG_FATAL,
			"%s: Unable to create listening socket on conn %s",
			smfi->xxfi_name, conn);
		(void) smutex_unlock(&L_Mutex);
d662 2
a663 2
	}
	clilen = socksize;
d744 1
a744 1
		     cliaddr.sa.sa_family != family))
@


1.7
log
@update to sendmail-8.12.2
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.81 2002/01/08 23:14:23 ca Exp $")
d80 1
a80 1
 		if (*p == '\0')
d84 1
a84 1
 			addr.sa.sa_family = AF_UNIX;
d141 1
a141 1
 		addr.sa.sa_family = AF_UNIX;
d479 1
a479 1
#if _FFR_MILTER_ROOT_UNSAFE 
@


1.6
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.75 2001/09/11 04:04:45 gshapiro Exp $")
d59 1
a59 1
	size_t len = -1;
d389 1
a389 1
		(void) close(sock);
d398 1
a398 1
		(void) close(sock);
d407 1
a407 1
		(void) close(sock);
d418 1
d427 1
a427 1
			(void) close(sock);
d474 1
a474 1
		bool removable = false;
d478 6
a483 3
		if (sockpath != NULL &&
		    fstat(listenfd, &sockinfo) == 0 &&
		    (S_ISFIFO(sockinfo.st_mode)
d485 1
a485 1
		     || !S_ISSOCK(sockinfo.st_mode)
d487 1
a487 2
		     ))
			removable = true;
d490 1
a490 1
		(void) close(listenfd);
d499 7
a505 2
			    fileinfo.st_dev == sockinfo.st_dev &&
			    fileinfo.st_ino == sockinfo.st_ino &&
d703 1
a703 1
			(void) close(connfd);
d736 1
a736 1
			(void) close(connfd);
d786 1
a786 1
			(void) close(connfd);
@


1.5
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.72 2001/06/28 20:59:06 ca Exp $")
d28 1
a28 1
/*
d434 1
a434 1
/*
d453 1
a453 1
/*
d512 1
a512 1
/*
@


1.4
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d11 2
a12 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: listener.c,v 8.38.2.1.2.22 2001/05/16 17:15:58 ca Exp $";
#endif /* ! lint */
a13 1
#if _FFR_MILTER
d19 1
d25 3
d40 3
d45 4
d59 1
d170 2
a171 3
		if (strlcpy(addr.sunix.sun_path, colon,
			    sizeof addr.sunix.sun_path) >=
		    sizeof addr.sunix.sun_path)
d178 2
a192 1

d209 1
a209 1
		u_short port;
d234 1
a234 1
			port = htons((u_short) atoi(colon));
d265 1
a265 1
					bool found = FALSE;
d276 1
a276 2
					    (hid = inet_addr(&at[1])) !=
					    INADDR_NONE)
d280 1
a280 1
						found = TRUE;
d286 2
a287 2
					    inet_pton(AF_INET6, &at[1],
						      &hid6.sin6_addr) == 1)
d291 1
a291 1
						found = TRUE;
d350 1
a350 1
# if _FFR_FREEHOSTENT && NETINET6
d352 1
a352 1
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d379 1
a379 1
			name, strerror(errno));
d387 2
a388 1
			"%s: Unable to setsockopt: %s", name, strerror(errno));
d397 1
a397 1
			name, conn, strerror(errno));
d405 2
a406 1
			"%s: listen call failed: %s", name, strerror(errno));
d410 21
a452 2
static smutex_t L_Mutex;

d456 3
d472 15
d489 19
d530 1
a530 1
# if BROKEN_PTHREAD_SLEEP
d550 1
a550 1
#  define MI_SLEEP(s)							\
d566 3
a568 3
# else /* BROKEN_PTHREAD_SLEEP */
#  define MI_SLEEP(s)	sleep((s))
# endif /* BROKEN_PTHREAD_SLEEP */
d583 4
a586 3
	int mcnt = 0;
	int tcnt = 0;
	int acnt = 0;
d635 2
a636 2
		FD_SET((u_int) listenfd, &readset);
		FD_SET((u_int) listenfd, &excset);
d651 12
a662 2
			ret = MI_FAILURE;
			break;
d669 3
d674 1
a701 3
			smi_log(SMI_LOG_ERR,
				"%s: accept() returned invalid socket (%s)",
				smfi->xxfi_name, strerror(save_errno));
d705 4
d717 1
d722 2
a723 2
			smi_log(SMI_LOG_WARN, "%s: setsockopt() failed",
				smfi->xxfi_name);
a728 2
			smi_log(SMI_LOG_ERR, "%s: malloc(ctx) failed",
				smfi->xxfi_name);
d730 3
d741 1
a741 2
		mcnt = 0;
		acnt = 0;
d772 1
d774 3
a776 3
				"%s: thread_create() failed: %d",
				smfi->xxfi_name,  r);
			tcnt++;
a795 1
#endif /* _FFR_MILTER */
@


1.3
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: listener.c,v 8.38.2.1.2.21 2001/02/14 02:20:40 gshapiro Exp $";
d518 2
d579 1
a579 2
			int err = errno;

d581 1
a581 1
			if (err == EINTR)
d597 1
d615 1
a615 1
			errno = EINVAL;
d621 11
a631 2
				"%s: accept() returned invalid socket",
				smfi->xxfi_name);
d657 1
@


1.3.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: listener.c,v 8.38.2.1.2.22 2001/05/16 17:15:58 ca Exp $";
a517 2
	int acnt = 0;
	int save_errno = 0;
d577 2
a578 1
			save_errno = errno;
d580 1
a580 1
			if (save_errno == EINTR)
a595 1
		save_errno = errno;
d613 1
a613 1
			save_errno = EINVAL;
d619 2
a620 11
				"%s: accept() returned invalid socket (%s)",
				smfi->xxfi_name, strerror(save_errno));
			if (save_errno == EINTR)
				continue;
			acnt++;
			MI_SLEEP(acnt);
			if (acnt >= MAX_FAILS_A)
			{
				ret = MI_FAILURE;
				break;
			}
a645 1
		acnt = 0;
@


1.2
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2000 Sendmail, Inc. and its suppliers.
d12 1
a12 1
static char id[] = "@@(#)$Sendmail: listener.c,v 8.38.2.1.2.18 2000/12/29 19:44:28 gshapiro Exp $";
d33 2
d41 1
a41 1
mi_milteropen(conn, backlog, socksize, name)
d45 1
d399 1
a399 1

d463 40
d512 1
d516 2
a517 2
	int cnt_m = 0;
	int cnt_t = 0;
d532 2
a533 1
	listenfd = mi_milteropen(conn, backlog, &socksize, smfi->xxfi_name);
d593 1
d598 18
d636 3
a638 2
			sleep(++cnt_m);
			if (cnt_m >= MAX_FAILS_M)
d645 1
a645 1
		cnt_m = 0;
d679 2
a680 1
			sleep(++cnt_t);
d683 1
a683 1
			if (cnt_t >= MAX_FAILS_T)
d690 1
a690 1
		cnt_t = 0;
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: listener.c,v 8.38 2000/02/11 00:12:30 ca Exp $";
a21 3
#if NETINET || NETINET6
# include <arpa/inet.h>
#endif /* NETINET || NETINET6 */
d23 3
d38 1
a38 1
static int
d45 1
a45 1
	int sock = 0;
a49 1
	struct hostent *hp = NULL;
d56 1
a56 1
		return MI_INVALID_SOCKET;
d88 1
a88 1
			return MI_INVALID_SOCKET;
d119 1
a119 1
			return MI_INVALID_SOCKET;
d143 1
a143 1
		return MI_INVALID_SOCKET;
d164 1
a164 1
			return MI_INVALID_SOCKET;
d176 1
a176 1
			return MI_INVALID_SOCKET;
d221 1
a221 1
			port = htons(atoi(colon));
d227 1
a227 1
			return MI_INVALID_SOCKET;
d237 1
a237 1
				return MI_INVALID_SOCKET;
d288 1
a288 1
						return MI_INVALID_SOCKET;
d296 1
a296 1
					return MI_INVALID_SOCKET;
d301 2
d309 1
a309 1
					return MI_INVALID_SOCKET;
d336 1
a336 1
					return MI_INVALID_SOCKET;
d338 3
d363 1
a363 1
	if (sock < 0)
d368 1
a368 1
		return MI_INVALID_SOCKET;
d377 1
a377 1
		return MI_INVALID_SOCKET;
d386 1
a386 1
		return MI_INVALID_SOCKET;
d394 1
a394 1
		return MI_INVALID_SOCKET;
d416 26
d443 1
a443 1
**  MI_MILTER_LISTENER -- Generic listener harness
d461 1
a461 1
mi_listener(conn, dbg, smfi, timeout)
d466 1
d468 1
a468 3
	int connfd = -1;
	int listenfd = -1;
	int clilen;
d474 1
a474 1
	pthread_t thread_id;
d477 1
d486 4
a489 2
	if ((listenfd = mi_milteropen(conn, SOMAXCONN, &socksize,
				      smfi->xxfi_name)) < 0)
d494 1
d498 1
d503 1
d506 1
d510 7
a518 1
		FD_SET(listenfd, &readset);
d520 2
a521 1
		FD_SET(listenfd, &excset);
d526 2
d529 1
d532 4
a535 1
			if (errno == EINTR)
d544 1
d550 1
d552 1
a552 1
		if (connfd < 0)
d582 1
a582 1
		ctx->ctx_fd = connfd;
d593 1
a593 1
			smfi->xxfi_flags |= SMFIF_NOCONNECT;
d595 1
a595 1
			smfi->xxfi_flags |= SMFIF_NOHELO;
d597 1
a597 1
			smfi->xxfi_flags |= SMFIF_NOMAIL;
d599 1
a599 1
			smfi->xxfi_flags |= SMFIF_NORCPT;
d601 3
a603 1
			smfi->xxfi_flags |= SMFIF_NOHDRS;
d605 1
a605 1
			smfi->xxfi_flags |= SMFIF_NOBODY;
d607 1
a607 1
		if ((r = pthread_create(&thread_id, NULL,
d612 1
a612 1
				"%s: pthread_create() failed: %d",
d628 3
a630 2
	if (listenfd >= 0)
		(void) close(listenfd);
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.1.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d12 1
a12 1
static char id[] = "@@(#)$Sendmail: listener.c,v 8.38.2.1.2.22 2001/05/16 17:15:58 ca Exp $";
d22 3
a25 3
# if NETINET || NETINET6
#  include <arpa/inet.h>
# endif /* NETINET || NETINET6 */
a32 2
**		family -- family of created socket
**		name -- name for logging
d38 2
a39 2
static socket_t
mi_milteropen(conn, backlog, socksize, family, name)
a42 1
	int *family;
d45 1
a45 1
	socket_t sock;
d50 1
d57 1
a57 1
		return INVALID_SOCKET;
d89 1
a89 1
			return INVALID_SOCKET;
d120 1
a120 1
			return INVALID_SOCKET;
d144 1
a144 1
		return INVALID_SOCKET;
d165 1
a165 1
			return INVALID_SOCKET;
d177 1
a177 1
			return INVALID_SOCKET;
d222 1
a222 1
			port = htons((u_short) atoi(colon));
d228 1
a228 1
			return INVALID_SOCKET;
d238 1
a238 1
				return INVALID_SOCKET;
d289 1
a289 1
						return INVALID_SOCKET;
d297 1
a297 1
					return INVALID_SOCKET;
a301 2
				struct hostent *hp = NULL;

d308 1
a308 1
					return INVALID_SOCKET;
d335 1
a335 1
					return INVALID_SOCKET;
a336 3
# if _FFR_FREEHOSTENT && NETINET6
				freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d359 1
a359 1
	if (!ValidSocket(sock))
d364 1
a364 1
		return INVALID_SOCKET;
d373 1
a373 1
		return INVALID_SOCKET;
d382 1
a382 1
		return INVALID_SOCKET;
d390 1
a390 1
		return INVALID_SOCKET;
d392 1
a392 1
	*family = addr.sa.sa_family;
a411 26
static socket_t listenfd = INVALID_SOCKET;

static smutex_t L_Mutex;

/*
**  MI_CLOSENER -- close listen socket
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
*/

void
mi_closener()
{
	(void) smutex_lock(&L_Mutex);
	if (ValidSocket(listenfd))
	{
		(void) close(listenfd);
		listenfd = INVALID_SOCKET;
	}
	(void) smutex_unlock(&L_Mutex);
}

d413 1
a413 1
**  MI_LISTENER -- Generic listener harness
a429 40
# if BROKEN_PTHREAD_SLEEP

/*
**  Solaris 2.6, perhaps others, gets an internal threads library panic
**  when sleep() is used:
**
**  thread_create() failed, returned 11 (EINVAL)
**  co_enable, thr_create() returned error = 24
**  libthread panic: co_enable failed (PID: 17793 LWP 1)
**  stacktrace:
**	ef526b10
**	ef52646c
**	ef534cbc
**	156a4
**	14644
**	1413c
**	135e0
**	0
*/

#  define MI_SLEEP(s)							\
{									\
	int rs = 0;							\
	struct timeval st;						\
									\
	st.tv_sec = (s);						\
	st.tv_usec = 0;							\
	if (st.tv_sec > 0)						\
		rs = select(0, NULL, NULL, NULL, &st);			\
	if (rs != 0)							\
	{								\
		smi_log(SMI_LOG_ERR,					\
			"MI_SLEEP(): select() returned non-zero result %d, errno = %d",								\
			rs, errno);					\
	}								\
}
# else /* BROKEN_PTHREAD_SLEEP */
#  define MI_SLEEP(s)	sleep((s))
# endif /* BROKEN_PTHREAD_SLEEP */

d431 1
a431 1
mi_listener(conn, dbg, smfi, timeout, backlog)
a435 1
	int backlog;
d437 3
a439 2
	socket_t connfd = INVALID_SOCKET;
	int family = AF_UNSPEC;
d443 3
a445 5
	int mcnt = 0;
	int tcnt = 0;
	int acnt = 0;
	int save_errno = 0;
	sthread_t thread_id;
a447 1
	SOCKADDR_LEN_T clilen;
d456 2
a457 5
	(void) smutex_init(&L_Mutex);
	(void) smutex_lock(&L_Mutex);
	listenfd = mi_milteropen(conn, backlog, &socksize, &family,
				 smfi->xxfi_name);
	if (!ValidSocket(listenfd))
a461 1
		(void) smutex_unlock(&L_Mutex);
a464 1

a468 1
		(void) smutex_unlock(&L_Mutex);
a470 1
	(void) smutex_unlock(&L_Mutex);
a473 7
		(void) smutex_lock(&L_Mutex);
		if (!ValidSocket(listenfd))
		{
			(void) smutex_unlock(&L_Mutex);
			break;
		}

d476 1
d478 1
a478 2
		FD_SET((u_int) listenfd, &readset);
		FD_SET((u_int) listenfd, &excset);
a482 2
		{
			(void) smutex_unlock(&L_Mutex);
a483 1
		}
d486 1
a486 3
			save_errno = errno;
			(void) smutex_unlock(&L_Mutex);
			if (save_errno == EINTR)
a494 1
			(void) smutex_unlock(&L_Mutex);
a497 1
		memset(&cliaddr, '\0', sizeof cliaddr);
a499 2
		save_errno = errno;
		(void) smutex_unlock(&L_Mutex);
d501 1
a501 19
		/*
		**  If remote side closes before
		**  accept() finishes, sockaddr
		**  might not be fully filled in.
		*/

		if (ValidSocket(connfd) &&
		    (clilen == 0 ||
# ifdef BSD4_4_SOCKADDR
		     cliaddr.sa.sa_len == 0 ||
# endif /* BSD4_4_SOCKADDR */
		     cliaddr.sa.sa_family != family))
		{
			(void) close(connfd);
			connfd = INVALID_SOCKET;
			save_errno = EINVAL;
		}

		if (!ValidSocket(connfd))
d504 2
a505 11
				"%s: accept() returned invalid socket (%s)",
				smfi->xxfi_name, strerror(save_errno));
			if (save_errno == EINTR)
				continue;
			acnt++;
			MI_SLEEP(acnt);
			if (acnt >= MAX_FAILS_A)
			{
				ret = MI_FAILURE;
				break;
			}
d521 2
a522 3
			mcnt++;
			MI_SLEEP(mcnt);
			if (mcnt >= MAX_FAILS_M)
d529 1
a529 2
		mcnt = 0;
		acnt = 0;
d531 1
a531 1
		ctx->ctx_sd = connfd;
d542 1
a542 1
			ctx->ctx_pflags |= SMFIP_NOCONNECT;
d544 1
a544 1
			ctx->ctx_pflags |= SMFIP_NOHELO;
d546 1
a546 1
			ctx->ctx_pflags |= SMFIP_NOMAIL;
d548 1
a548 1
			ctx->ctx_pflags |= SMFIP_NORCPT;
d550 1
a550 3
			ctx->ctx_pflags |= SMFIP_NOHDRS;
		if (smfi->xxfi_eoh == NULL)
			ctx->ctx_pflags |= SMFIP_NOEOH;
d552 1
a552 1
			ctx->ctx_pflags |= SMFIP_NOBODY;
d554 1
a554 1
		if ((r = thread_create(&thread_id,
d559 1
a559 1
				"%s: thread_create() failed: %d",
d561 1
a561 2
			tcnt++;
			MI_SLEEP(tcnt);
d564 1
a564 1
			if (tcnt >= MAX_FAILS_T)
d571 1
a571 1
		tcnt = 0;
d575 2
a576 3
	else
		mi_closener();
	(void) smutex_destroy(&L_Mutex);
@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Id: listener.c,v 8.38.2.1.2.18 2000/12/29 19:44:28 gshapiro Exp $";
d22 3
a25 3
# if NETINET || NETINET6
#  include <arpa/inet.h>
# endif /* NETINET || NETINET6 */
d38 1
a38 1
static socket_t
d45 1
a45 1
	socket_t sock;
d50 1
d57 1
a57 1
		return INVALID_SOCKET;
d89 1
a89 1
			return INVALID_SOCKET;
d120 1
a120 1
			return INVALID_SOCKET;
d144 1
a144 1
		return INVALID_SOCKET;
d165 1
a165 1
			return INVALID_SOCKET;
d177 1
a177 1
			return INVALID_SOCKET;
d222 1
a222 1
			port = htons((u_short) atoi(colon));
d228 1
a228 1
			return INVALID_SOCKET;
d238 1
a238 1
				return INVALID_SOCKET;
d289 1
a289 1
						return INVALID_SOCKET;
d297 1
a297 1
					return INVALID_SOCKET;
a301 2
				struct hostent *hp = NULL;

d308 1
a308 1
					return INVALID_SOCKET;
d335 1
a335 1
					return INVALID_SOCKET;
a336 3
# if _FFR_FREEHOSTENT && NETINET6
				freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d359 1
a359 1
	if (!ValidSocket(sock))
d364 1
a364 1
		return INVALID_SOCKET;
d373 1
a373 1
		return INVALID_SOCKET;
d382 1
a382 1
		return INVALID_SOCKET;
d390 1
a390 1
		return INVALID_SOCKET;
a411 26
static socket_t listenfd = INVALID_SOCKET;

static smutex_t L_Mutex;

/*
**  MI_CLOSENER -- close listen socket
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
*/

void
mi_closener()
{
	(void) smutex_lock(&L_Mutex);
	if (ValidSocket(listenfd))
	{
		(void) close(listenfd);
		listenfd = INVALID_SOCKET;
	}
	(void) smutex_unlock(&L_Mutex);
}

d413 1
a413 1
**  MI_LISTENER -- Generic listener harness
d431 1
a431 1
mi_listener(conn, dbg, smfi, timeout, backlog)
a435 1
	int backlog;
d437 3
a439 1
	socket_t connfd = INVALID_SOCKET;
d445 1
a445 1
	sthread_t thread_id;
a447 1
	SOCKADDR_LEN_T clilen;
d456 2
a457 4
	(void) smutex_init(&L_Mutex);
	(void) smutex_lock(&L_Mutex);
	listenfd = mi_milteropen(conn, backlog, &socksize, smfi->xxfi_name);
	if (!ValidSocket(listenfd))
a461 1
		(void) smutex_unlock(&L_Mutex);
a464 1

a468 1
		(void) smutex_unlock(&L_Mutex);
a470 1
	(void) smutex_unlock(&L_Mutex);
a473 7
		(void) smutex_lock(&L_Mutex);
		if (!ValidSocket(listenfd))
		{
			(void) smutex_unlock(&L_Mutex);
			break;
		}

d476 1
d478 1
a478 2
		FD_SET((u_int) listenfd, &readset);
		FD_SET((u_int) listenfd, &excset);
a482 2
		{
			(void) smutex_unlock(&L_Mutex);
a483 1
		}
d486 1
a486 4
			int err = errno;

			(void) smutex_unlock(&L_Mutex);
			if (err == EINTR)
a494 1
			(void) smutex_unlock(&L_Mutex);
a499 1
		(void) smutex_unlock(&L_Mutex);
d501 1
a501 1
		if (!ValidSocket(connfd))
d531 1
a531 1
		ctx->ctx_sd = connfd;
d542 1
a542 1
			ctx->ctx_pflags |= SMFIP_NOCONNECT;
d544 1
a544 1
			ctx->ctx_pflags |= SMFIP_NOHELO;
d546 1
a546 1
			ctx->ctx_pflags |= SMFIP_NOMAIL;
d548 1
a548 1
			ctx->ctx_pflags |= SMFIP_NORCPT;
d550 1
a550 3
			ctx->ctx_pflags |= SMFIP_NOHDRS;
		if (smfi->xxfi_eoh == NULL)
			ctx->ctx_pflags |= SMFIP_NOEOH;
d552 1
a552 1
			ctx->ctx_pflags |= SMFIP_NOBODY;
d554 1
a554 1
		if ((r = thread_create(&thread_id,
d559 1
a559 1
				"%s: thread_create() failed: %d",
d575 2
a576 3
	else
		mi_closener();
	(void) smutex_destroy(&L_Mutex);
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d11 3
a13 2
#include <sm/gen.h>
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.72 2001/06/28 20:59:06 ca Exp $")
d15 1
a20 1
#include <sm/errstring.h>
a25 3

static smutex_t L_Mutex;

a32 2
**		family -- family of created socket
**		name -- name for logging
a35 3
**
**	Side effect:
**		sets sockpath if UNIX socket.
a37 4
#if NETUNIX
static char	*sockpath = NULL;
#endif /* NETUNIX */

d39 1
a39 1
mi_milteropen(conn, backlog, socksize, family, name)
a42 1
	int *family;
a46 1
	size_t len = -1;
d157 3
a159 2
		len = strlen(colon) + 1;
		if (len >= sizeof addr.sunix.sun_path)
a165 2
		(void) sm_strlcpy(addr.sunix.sun_path, colon,
				sizeof addr.sunix.sun_path);
d179 1
d196 1
a196 1
		unsigned short port;
d221 1
a221 1
			port = htons((unsigned short) atoi(colon));
d252 1
a252 1
					bool found = false;
d263 2
a264 1
					    (hid = inet_addr(&at[1])) != INADDR_NONE)
d268 1
a268 1
						found = true;
d274 2
a275 2
					    mi_inet_pton(AF_INET6, &at[1],
							 &hid6.sin6_addr) == 1)
d279 1
a279 1
						found = true;
d338 1
a338 1
# if NETINET6
d340 1
a340 1
# endif /* NETINET6 */
d367 1
a367 1
			name, sm_errstring(errno));
d375 1
a375 2
			"%s: Unable to setsockopt: %s", name,
			sm_errstring(errno));
d384 1
a384 1
			name, conn, sm_errstring(errno));
d392 1
a392 2
			"%s: listen call failed: %s", name,
			sm_errstring(errno));
a396 21
#if NETUNIX
	if (addr.sa.sa_family == AF_UNIX && len > 0)
	{
		/*
		**  Set global variable sockpath so the UNIX socket can be
		**  unlink()ed at exit.
		*/
		sockpath = (char *) malloc(len);
		if (sockpath != NULL)
			(void) sm_strlcpy(sockpath, colon, len);
		else
		{
			smi_log(SMI_LOG_ERR,
				"%s: can't malloc(%d) for sockpath: %s",
				name, len, sm_errstring(errno));
			(void) close(sock);
			return INVALID_SOCKET;
		}
	}
#endif /* NETUNIX */
	*family = addr.sa.sa_family;
d418 2
a422 3
**	NOTE: It is assumed that this function is called from a
**	      function that has a mutex lock (currently mi_stop_milters()).
**
a435 15
#if NETUNIX
		bool removable = false;
		struct stat sockinfo;
		struct stat fileinfo;

		if (sockpath != NULL &&
		    fstat(listenfd, &sockinfo) == 0 &&
		    (S_ISFIFO(sockinfo.st_mode)
# ifdef S_ISSOCK
		     || !S_ISSOCK(sockinfo.st_mode)
# endif /* S_ISSOCK */
		     ))
			removable = true;
#endif /* NETUNIX */

a437 19

#if NETUNIX
		/* XXX sleep() some time before doing this? */
		if (sockpath != NULL)
		{
			if (removable &&
			    stat(sockpath, &fileinfo) == 0 &&
			    fileinfo.st_dev == sockinfo.st_dev &&
			    fileinfo.st_ino == sockinfo.st_ino &&
			    (S_ISFIFO(fileinfo.st_mode)
# ifdef S_ISSOCK
			     || S_ISSOCK(fileinfo.st_mode)
# endif /* S_ISSOCK */
			     ))
				(void) unlink(sockpath);
			free(sockpath);
			sockpath = NULL;
		}
#endif /* NETUNIX */
a459 40
#if BROKEN_PTHREAD_SLEEP

/*
**  Solaris 2.6, perhaps others, gets an internal threads library panic
**  when sleep() is used:
**
**  thread_create() failed, returned 11 (EINVAL)
**  co_enable, thr_create() returned error = 24
**  libthread panic: co_enable failed (PID: 17793 LWP 1)
**  stacktrace:
**	ef526b10
**	ef52646c
**	ef534cbc
**	156a4
**	14644
**	1413c
**	135e0
**	0
*/

# define MI_SLEEP(s)							\
{									\
	int rs = 0;							\
	struct timeval st;						\
									\
	st.tv_sec = (s);						\
	st.tv_usec = 0;							\
	if (st.tv_sec > 0)						\
		rs = select(0, NULL, NULL, NULL, &st);			\
	if (rs != 0)							\
	{								\
		smi_log(SMI_LOG_ERR,					\
			"MI_SLEEP(): select() returned non-zero result %d, errno = %d",								\
			rs, errno);					\
	}								\
}
#else /* BROKEN_PTHREAD_SLEEP */
# define MI_SLEEP(s)	sleep((s))
#endif /* BROKEN_PTHREAD_SLEEP */

a468 1
	int family = AF_UNSPEC;
d472 2
a473 5
	int mcnt = 0;	/* error count for malloc() failures */
	int tcnt = 0;	/* error count for thread_create() failures */
	int acnt = 0;	/* error count for accept() failures */
	int scnt = 0;	/* error count for select() failures */
	int save_errno = 0;
d488 1
a488 2
	listenfd = mi_milteropen(conn, backlog, &socksize, &family,
				 smfi->xxfi_name);
d520 2
a521 2
		FD_SET((unsigned int) listenfd, &readset);
		FD_SET((unsigned int) listenfd, &excset);
d532 2
a533 1
			save_errno = errno;
d535 1
a535 1
			if (save_errno == EINTR)
d537 2
a538 12
			scnt++;
			smi_log(SMI_LOG_ERR,
				"%s: select() failed (%s), %s",
				smfi->xxfi_name, sm_errstring(save_errno),
				scnt >= MAX_FAILS_S ? "abort" : "try again");
			MI_SLEEP(scnt);
			if (scnt >= MAX_FAILS_S)
			{
				ret = MI_FAILURE;
				break;
			}
			continue;
a544 3
			smi_log(SMI_LOG_ERR,
				"%s: select() returned exception for socket, abort",
				smfi->xxfi_name);
a546 1
		scnt = 0;	/* reset error counter for select() */
a547 1
		memset(&cliaddr, '\0', sizeof cliaddr);
a549 1
		save_errno = errno;
a551 18
		/*
		**  If remote side closes before
		**  accept() finishes, sockaddr
		**  might not be fully filled in.
		*/

		if (ValidSocket(connfd) &&
		    (clilen == 0 ||
# ifdef BSD4_4_SOCKADDR
		     cliaddr.sa.sa_len == 0 ||
# endif /* BSD4_4_SOCKADDR */
		     cliaddr.sa.sa_family != family))
		{
			(void) close(connfd);
			connfd = INVALID_SOCKET;
			save_errno = EINVAL;
		}

a553 3
			if (save_errno == EINTR)
				continue;
			acnt++;
d555 2
a556 9
				"%s: accept() returned invalid socket (%s), %s",
				smfi->xxfi_name, sm_errstring(save_errno),
				acnt >= MAX_FAILS_A ? "abort" : "try again");
			MI_SLEEP(acnt);
			if (acnt >= MAX_FAILS_A)
			{
				ret = MI_FAILURE;
				break;
			}
a558 1
		acnt = 0;	/* reset error counter for accept() */
d563 2
a564 2
			smi_log(SMI_LOG_WARN, "%s: setsockopt() failed (%s)",
				smfi->xxfi_name, sm_errstring(errno));
d570 4
a573 6
			mcnt++;
			smi_log(SMI_LOG_ERR, "%s: malloc(ctx) failed (%s), %s",
				smfi->xxfi_name, sm_errstring(save_errno),
				mcnt >= MAX_FAILS_M ? "abort" : "try again");
			MI_SLEEP(mcnt);
			if (mcnt >= MAX_FAILS_M)
d580 1
a580 1
		mcnt = 0;	/* reset error counter for malloc() */
a610 1
			tcnt++;
d612 3
a614 4
				"%s: thread_create() failed: %d, %s",
				smfi->xxfi_name,  r,
				tcnt >= MAX_FAILS_T ? "abort" : "try again");
			MI_SLEEP(tcnt);
d617 1
a617 1
			if (tcnt >= MAX_FAILS_T)
d624 1
a624 1
		tcnt = 0;
d633 1
@


