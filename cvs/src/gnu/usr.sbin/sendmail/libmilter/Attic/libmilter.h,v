head	1.18;
access;
symbols
	OPENBSD_5_6:1.17.0.6
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.10
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.8
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.6
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.4
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.15.0.18
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.16
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.12
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.14
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.10
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.8
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.6
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.4
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.13.0.8
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.6
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2014.09.17.18.49.50;	author matthieu;	state dead;
branches;
next	1.17;
commitid	M7i5giHIoz3DMlTU;

1.17
date	2014.02.07.21.24.59;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2011.05.17.15.54.23;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.22.18.43.54;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.24.03.59.25;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.19.01.41.13;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.17.17.31.39;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.03.17.31.21;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.01.19.59.21;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.03.17.25.46;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.01.01.01.40;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.29.01.31.12;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.15.21.09.02;	author millert;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.43;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.52;	author millert;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	2001.05.31.00.28.50;	author miod;	state Exp;
branches;
next	;

1.2.2.1
date	2001.05.31.01.47.53;	author jason;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Bye.
@
text
@/*
 * Copyright (c) 1999-2003, 2006 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 */

/*
**  LIBMILTER.H -- include file for mail filter library functions
*/

#ifndef _LIBMILTER_H
# define _LIBMILTER_H	1

#include <sm/gen.h>

#ifdef _DEFINE
# define EXTERN
# define INIT(x)	= x
SM_IDSTR(MilterlId, "@@(#)$Sendmail: libmilter.h,v 8.78 2013/11/22 20:51:36 ca Exp $")
#else /* _DEFINE */
# define EXTERN extern
# define INIT(x)
#endif /* _DEFINE */


#include "sm/tailq.h"

#define NOT_SENDMAIL	1
#define _SOCK_ADDR	union bigsockaddr
#include "sendmail.h"

#ifdef SM_ASSERT
#undef SM_ASSERT
#endif
#ifndef SM_ASSERT
#include <assert.h>
#define SM_ASSERT(x) assert(x)
#endif

#include "libmilter/milter.h"

#define MAX_MACROS_ENTRIES	7	/* max size of macro pointer array */

typedef SM_TAILQ_HEAD(, smfi_str)	smfi_hd_T;
typedef struct smfi_str smfi_str_S;

/*
**  Context for one milter session.
**
**  Notes:
**	There is a 1-1 correlation between a sendmail SMTP server process,
**	an SMTP session, and an milter context. Due to the nature of SMTP
**	session handling in sendmail 8, this libmilter implementation deals
**	only with a single SMTP session per MTA - libmilter connection.
**
**	There is no "global" context for libmilter, global variables are
**	just that (they are not "collected" in a context).
**
**  Implementation hint:
**  macros are stored in mac_buf[] as sequence of:
**  macro_name \0 macro_value
**  (just as read from the MTA)
**  mac_ptr is a list of pointers into mac_buf to the beginning of each
**  entry, i.e., macro_name, macro_value, ...
*/

struct smfi_str
{
	sthread_t	ctx_id;		/* thread id */
	socket_t	ctx_sd;		/* socket descriptor */
	int		ctx_dbg;	/* debug level */
	time_t		ctx_timeout;	/* timeout */
	int		ctx_state;	/* state */
	smfiDesc_ptr	ctx_smfi;	/* filter description */

	int		ctx_prot_vers;	/* libmilter protocol version */
	unsigned long	ctx_aflags;	/* milter action flags */

	unsigned long	ctx_pflags;	/* milter protocol flags */

	/*
	**  milter protocol flags that are sent to the MTA;
	**  this is the same as ctx_pflags except for those flags that
	**  are not offered by the MTA but emulated in libmilter.
	*/

	unsigned long	ctx_pflags2mta;

	/*
	**  milter protocol version that is sent to the MTA;
	**  this is the same as ctx_prot_vers unless the
	**  MTA protocol version (ctx_mta_prot_vers) is smaller
	**  but still "acceptable".
	*/

	int		ctx_prot_vers2mta;

	char		**ctx_mac_ptr[MAX_MACROS_ENTRIES];
	char		*ctx_mac_buf[MAX_MACROS_ENTRIES];
	char		*ctx_mac_list[MAX_MACROS_ENTRIES];
	char		*ctx_reply;	/* reply code */
	void		*ctx_privdata;	/* private data */

	int		ctx_mta_prot_vers;	/* MTA protocol version */
	unsigned long	ctx_mta_pflags;	/* MTA protocol flags */
	unsigned long	ctx_mta_aflags;	/* MTA action flags */

#if _FFR_THREAD_MONITOR
	time_t		ctx_start;	/* start time of thread */
	SM_TAILQ_ENTRY(smfi_str)	ctx_mon_link;
#endif /* _FFR_THREAD_MONITOR */

#if _FFR_WORKERS_POOL
	long		ctx_sid;	/* session identifier */
	int		ctx_wstate;	/* state of the session (worker pool) */
	int		ctx_wait;	/* elapsed time waiting for sm cmd */
	SM_TAILQ_ENTRY(smfi_str)	ctx_link;
#endif /* _FFR_WORKERS_POOL */
};

# define ValidSocket(sd)	((sd) >= 0)
# define INVALID_SOCKET		(-1)
# define closesocket		close
# define MI_SOCK_READ(s, b, l)	read(s, b, l)
# define MI_SOCK_READ_FAIL(x)	((x) < 0)
# define MI_SOCK_WRITE(s, b, l)	write(s, b, l)

# define thread_create(ptid,wr,arg) pthread_create(ptid, NULL, wr, arg)
# define sthread_get_id()	pthread_self()

typedef pthread_mutex_t smutex_t;
# define smutex_init(mp)	(pthread_mutex_init(mp, NULL) == 0)
# define smutex_destroy(mp)	(pthread_mutex_destroy(mp) == 0)
# define smutex_lock(mp)	(pthread_mutex_lock(mp) == 0)
# define smutex_unlock(mp)	(pthread_mutex_unlock(mp) == 0)
# define smutex_trylock(mp)	(pthread_mutex_trylock(mp) == 0)

#if _FFR_WORKERS_POOL
/* SM_CONF_POLL shall be defined with _FFR_WORKERS_POOL */
# if !SM_CONF_POLL
#  define SM_CONF_POLL 1
# endif /* SM_CONF_POLL */
#endif /* _FFR_WORKERS_POOL */

typedef pthread_cond_t scond_t;
#define scond_init(cp)			pthread_cond_init(cp, NULL)
#define scond_destroy(cp)		pthread_cond_destroy(cp)
#define scond_wait(cp, mp)		pthread_cond_wait(cp, mp)
#define scond_signal(cp)		pthread_cond_signal(cp)
#define scond_broadcast(cp)		pthread_cond_broadcast(cp)
#define scond_timedwait(cp, mp, to)					\
	do								\
	{								\
		struct timespec timeout;				\
		struct timeval now;					\
		gettimeofday(&now, NULL);				\
		timeout.tv_sec = now.tv_sec + to;			\
		timeout.tv_nsec = now.tv_usec / 1000;			\
		r = pthread_cond_timedwait(cp,mp,&timeout);		\
		if (r != 0 && r != ETIMEDOUT)				\
			smi_log(SMI_LOG_ERR,				\
				"pthread_cond_timedwait error %d", r);	\
	} while (0)


#if SM_CONF_POLL

# include <poll.h>
# define MI_POLLSELECT  "poll"

# define MI_POLL_RD_FLAGS (POLLIN | POLLPRI)
# define MI_POLL_WR_FLAGS (POLLOUT)
# define MI_MS(timeout)	(((timeout)->tv_sec * 1000) + (timeout)->tv_usec)

# define FD_RD_VAR(rds, excs) struct pollfd rds
# define FD_WR_VAR(wrs) struct pollfd wrs

# define FD_RD_INIT(sd, rds, excs)			\
		(rds).fd = (sd);			\
		(rds).events = MI_POLL_RD_FLAGS;	\
		(rds).revents = 0

# define FD_WR_INIT(sd, wrs)				\
		(wrs).fd = (sd);			\
		(wrs).events = MI_POLL_WR_FLAGS;	\
		(wrs).revents = 0

# define FD_IS_RD_EXC(sd, rds, excs)	\
		(((rds).revents & (POLLERR | POLLHUP | POLLNVAL)) != 0)

# define FD_IS_WR_RDY(sd, wrs)		\
		(((wrs).revents & MI_POLL_WR_FLAGS) != 0)

# define FD_IS_RD_RDY(sd, rds, excs)			\
		(((rds).revents & MI_POLL_RD_FLAGS) != 0)

# define FD_WR_READY(sd, excs, timeout)	\
		poll(&(wrs), 1, MI_MS(timeout))

# define FD_RD_READY(sd, rds, excs, timeout)	\
		poll(&(rds), 1, MI_MS(timeout))

#else /* SM_CONF_POLL */

# include <sm/fdset.h>
# define MI_POLLSELECT  "select"

# define FD_RD_VAR(rds, excs) fd_set rds, excs
# define FD_WR_VAR(wrs) fd_set wrs

# define FD_RD_INIT(sd, rds, excs)			\
		FD_ZERO(&(rds));			\
		FD_SET((unsigned int) (sd), &(rds));	\
		FD_ZERO(&(excs));			\
		FD_SET((unsigned int) (sd), &(excs))

# define FD_WR_INIT(sd, wrs)			\
		FD_ZERO(&(wrs));			\
		FD_SET((unsigned int) (sd), &(wrs))

# define FD_IS_RD_EXC(sd, rds, excs) FD_ISSET(sd, &(excs))
# define FD_IS_WR_RDY(sd, wrs) FD_ISSET((sd), &(wrs))
# define FD_IS_RD_RDY(sd, rds, excs) FD_ISSET((sd), &(rds))

# define FD_WR_READY(sd, wrs, timeout)	\
		select((sd) + 1, NULL, &(wrs), NULL, (timeout))
# define FD_RD_READY(sd, rds, excs, timeout)	\
		select((sd) + 1, &(rds), NULL, &(excs), (timeout))

#endif /* SM_CONF_POLL */

#include <sys/time.h>

/* some defaults */
#define MI_TIMEOUT	7210		/* default timeout for read/write */
#define MI_CHK_TIME	5		/* checking whether to terminate */

#ifndef MI_SOMAXCONN
# if SOMAXCONN > 20
#  define MI_SOMAXCONN	SOMAXCONN
# else /* SOMAXCONN */
#  define MI_SOMAXCONN	20
# endif /* SOMAXCONN */
#endif /* ! MI_SOMAXCONN */

/* maximum number of repeated failures in mi_listener() */
#define MAX_FAILS_M	16	/* malloc() */
#define MAX_FAILS_T	16	/* thread creation */
#define MAX_FAILS_A	16	/* accept() */
#define MAX_FAILS_S	16	/* select() */

/* internal "commands", i.e., error codes */
#define SMFIC_TIMEOUT	((char) 1)	/* timeout */
#define SMFIC_SELECT	((char) 2)	/* select error */
#define SMFIC_MALLOC	((char) 3)	/* malloc error */
#define SMFIC_RECVERR	((char) 4)	/* recv() error */
#define SMFIC_EOF	((char) 5)	/* eof */
#define SMFIC_UNKNERR	((char) 6)	/* unknown error */
#define SMFIC_TOOBIG	((char) 7)	/* body chunk too big */
#define SMFIC_VALIDCMD	' '		/* first valid command */

/* hack */
#define smi_log		syslog
#define sm_dprintf	(void) printf
#define milter_ret	int
#define SMI_LOG_ERR	LOG_ERR
#define SMI_LOG_FATAL	LOG_ERR
#define SMI_LOG_WARN	LOG_WARNING
#define SMI_LOG_INFO	LOG_INFO
#define SMI_LOG_DEBUG	LOG_DEBUG

/* stop? */
#define MILTER_CONT	0
#define MILTER_STOP	1
#define MILTER_ABRT	2

/* functions */
extern int	mi_handle_session __P((SMFICTX_PTR));
extern int	mi_engine __P((SMFICTX_PTR));
extern int	mi_listener __P((char *, int, smfiDesc_ptr, time_t, int));
extern void	mi_clr_macros __P((SMFICTX_PTR, int));
extern void	mi_clr_ctx __P((SMFICTX_PTR));
extern int	mi_stop __P((void));
extern int	mi_control_startup __P((char *));
extern void	mi_stop_milters __P((int));
extern void	mi_clean_signals __P((void));
extern struct hostent *mi_gethostbyname __P((char *, int));
extern int	mi_inet_pton __P((int, const char *, void *));
extern void	mi_closener __P((void));
extern int	mi_opensocket __P((char *, int, int, bool, smfiDesc_ptr));

/* communication functions */
extern char	*mi_rd_cmd __P((socket_t, struct timeval *, char *, size_t *, char *));
extern int	mi_wr_cmd __P((socket_t, struct timeval *, int, char *, size_t));
extern bool	mi_sendok __P((SMFICTX_PTR, int));


#if _FFR_THREAD_MONITOR
extern bool Monitor;

#define MI_MONITOR_INIT()	mi_monitor_init()
#define MI_MONITOR_BEGIN(ctx, cmd)			\
	do						\
	{						\
		if (Monitor)				\
			mi_monitor_work_begin(ctx, cmd);\
	} while (0)

#define MI_MONITOR_END(ctx, cmd)			\
	do						\
	{						\
		if (Monitor)				\
			mi_monitor_work_end(ctx, cmd);	\
	} while (0)

int mi_monitor_init __P((void));
int mi_monitor_work_begin __P((SMFICTX_PTR, int));
int mi_monitor_work_end __P((SMFICTX_PTR, int));

#else /* _FFR_THREAD_MONITOR */
#define MI_MONITOR_INIT()	MI_SUCCESS
#define MI_MONITOR_BEGIN(ctx, cmd)
#define MI_MONITOR_END(ctx, cmd)
#endif /* _FFR_THREAD_MONITOR */

#if _FFR_WORKERS_POOL
extern int mi_pool_manager_init __P((void));
extern int mi_pool_controller_init __P((void));
extern int mi_start_session __P((SMFICTX_PTR));
#endif /* _FFR_WORKERS_POOL */

#endif /* ! _LIBMILTER_H */
@


1.17
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.16
log
@Update to sendmail 8.14.5
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2003, 2006 Sendmail, Inc. and its suppliers.
d22 1
a22 1
SM_IDSTR(MilterlId, "@@(#)$Sendmail: libmilter.h,v 8.77 2008/11/25 18:28:18 ca Exp $")
@


1.15
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d22 1
a22 1
SM_IDSTR(MilterlId, "@@(#)$Sendmail: libmilter.h,v 8.74 2006/12/19 18:19:52 ca Exp $")
d285 1
@


1.14
log
@Update to sendmail 8.13.6
@
text
@d22 1
a22 1
SM_IDSTR(MilterlId, "@@(#)$Sendmail: libmilter.h,v 8.51 2006/01/04 02:24:37 ca Exp $")
d29 2
d35 8
d45 79
d141 28
a236 4
/* version info */
#define MILTER_PRODUCT_NAME	"libmilter"
#define MILTER_VERSION		100

d299 34
@


1.13
log
@Update to sendmail.8.13.0
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2003 Sendmail, Inc. and its suppliers.
d22 1
a22 1
SM_IDSTR(MilterlId, "@@(#)$Sendmail: libmilter.h,v 8.50 2003/12/11 18:14:34 ca Exp $")
d105 1
a105 1
		FD_SET((unsigned int) (sd), &(wrs));	\
@


1.12
log
@Update to sendmail 8.12.11.  I've been runninga beta version of this for
some time without problems.  See the RELEASE_NOTES for the change log.
@
text
@d22 1
a22 1
SM_IDSTR(MilterlId, "@@(#)$Sendmail: libmilter.h,v 8.33.2.13 2003/10/20 21:51:50 msk Exp $")
d52 1
a52 1
#if _FFR_USE_POLL
d89 1
a89 1
#else /* _FFR_USE_POLL */
d116 1
a116 1
#endif /* _FFR_USE_POLL */
@


1.11
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d22 1
a22 1
SM_IDSTR(MilterlId, "@@(#)$Sendmail: libmilter.h,v 8.33.2.12 2003/09/08 21:39:55 yuri Exp $")
d179 1
a179 1
extern int	mi_opensocket __P((char *, int, int, smfiDesc_ptr));
@


1.10
log
@Update to Sendmail 8.12.8; fixes a buffer overflow in the envelope
comments processing which may allow an attacker to gain root privileges.
@
text
@d22 1
a22 1
SM_IDSTR(MilterlId, "@@(#)$Sendmail: libmilter.h,v 8.33.2.9 2003/01/03 22:14:40 ca Exp $")
d154 1
a154 1
#define sm_dprintf	printf
@


1.9
log
@update to sendmail 8.12.7
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2002 Sendmail, Inc. and its suppliers.
d22 1
a22 1
SM_IDSTR(MilterlId, "@@(#)$Sendmail: libmilter.h,v 8.33.2.7 2002/12/18 23:15:35 ca Exp $")
d51 66
@


1.8
log
@Update to sendmail-8.12.4
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d22 1
a22 1
SM_IDSTR(MilterlId, "@@(#)$Sendmail: libmilter.h,v 8.33 2002/04/30 23:52:24 msk Exp $")
d121 1
a121 1
#endif /* !_LIBMILTER_H */
@


1.7
log
@update to sendmail-8.12.2
@
text
@d22 1
a22 1
SM_IDSTR(MilterlId, "@@(#)$Sendmail: libmilter.h,v 8.32 2001/11/29 02:21:02 ca Exp $")
d113 1
@


1.6
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d22 1
a22 1
SM_IDSTR(MilterlId, "@@(#)$Sendmail: libmilter.h,v 8.28 2001/09/11 04:04:45 gshapiro Exp $")
d36 5
a40 3
# define INVALID_SOCKET		-1
# define MI_SOCK_READ(s, b, l)	(read(s, b, l))
# define MI_SOCK_WRITE(s, b, l)	(write(s, b, l))
d118 1
@


1.5
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d22 1
a22 1
SM_IDSTR(MilterlId, "@@(#)$Sendmail: libmilter.h,v 8.26 2001/07/20 02:48:37 gshapiro Exp $")
@


1.4
log
@update to sendmail 8.11.5
@
text
@d16 3
d22 1
a22 3
# ifndef lint
static char MilterlId[] = "@@(#)$Sendmail: libmilter.h,v 8.3.6.16 2001/06/07 23:21:35 geir Exp $";
# endif /* ! lint */
a34 5
#ifndef __P
# include "sendmail/cdefs.h"
#endif /* ! __P */
#include "sendmail/useful.h"

d60 7
a66 5
#if SOMAXCONN > 20
# define MI_SOMAXCONN	SOMAXCONN
#else /* SOMAXCONN */
# define MI_SOMAXCONN	20
#endif /* SOMAXCONN */
d72 1
d86 1
d109 1
@


1.3
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d20 1
a20 1
static char MilterlId[] = "@@(#)$Sendmail: libmilter.h,v 8.3.6.14 2001/05/27 14:31:12 ca Exp $";
@


1.2
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2000 Sendmail, Inc. and its suppliers.
d20 1
a20 1
static char MilterlId[] = "@@(#)$Sendmail: libmilter.h,v 8.3.6.10 2000/11/20 21:15:36 ca Exp $";
d61 1
a61 1
#define MI_TIMEOUT	1800		/* default timeout for read/write */
d73 1
@


1.2.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d20 1
a20 1
static char MilterlId[] = "@@(#)$Sendmail: libmilter.h,v 8.3.6.14 2001/05/27 14:31:12 ca Exp $";
d61 1
a61 1
#define MI_TIMEOUT	7210		/* default timeout for read/write */
a72 1
#define MAX_FAILS_A	16	/* accept() */
@


1.1
log
@Initial revision
@
text
@d11 1
a11 1
**  MILTER.H -- include file for mail filter library functions
d20 1
a20 1
static char MilterlId[] = "@@(#)$Sendmail: libmilter.h,v 8.3 2000/02/26 01:32:13 gshapiro Exp $";
d27 5
a32 1
#include "libmilter/mfapi.h"
d39 15
d64 6
a92 2
#define MI_INVALID_SOCKET	(-1)

d101 1
a101 1
extern int	mi_listener __P((char *, int, smfiDesc_ptr, time_t));
d108 1
d111 2
a112 2
extern char	*mi_rd_cmd __P((int, struct timeval *, char *, size_t *, char *));
extern int	mi_wr_cmd __P((int, struct timeval *, int, char *, size_t));
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.1.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d11 1
a11 1
**  LIBMILTER.H -- include file for mail filter library functions
d20 1
a20 1
static char MilterlId[] = "@@(#)$Sendmail: libmilter.h,v 8.3.6.14 2001/05/27 14:31:12 ca Exp $";
a26 5

#define NOT_SENDMAIL	1
#define _SOCK_ADDR	union bigsockaddr
#include "sendmail.h"

d28 1
a34 15
# define ValidSocket(sd)	((sd) >= 0)
# define INVALID_SOCKET		-1
# define MI_SOCK_READ(s, b, l)	(read(s, b, l))
# define MI_SOCK_WRITE(s, b, l)	(write(s, b, l))

# define thread_create(ptid,wr,arg) pthread_create(ptid, NULL, wr, arg)
# define sthread_get_id()	pthread_self()

typedef pthread_mutex_t smutex_t;
# define smutex_init(mp)	(pthread_mutex_init(mp, NULL) == 0)
# define smutex_destroy(mp)	(pthread_mutex_destroy(mp) == 0)
# define smutex_lock(mp)	(pthread_mutex_lock(mp) == 0)
# define smutex_unlock(mp)	(pthread_mutex_unlock(mp) == 0)
# define smutex_trylock(mp)	(pthread_mutex_trylock(mp) == 0)

d42 1
a42 1
#define MI_TIMEOUT	7210		/* default timeout for read/write */
a44 6
#if SOMAXCONN > 20
# define MI_SOMAXCONN	SOMAXCONN
#else /* SOMAXCONN */
# define MI_SOMAXCONN	20
#endif /* SOMAXCONN */

a47 1
#define MAX_FAILS_A	16	/* accept() */
d68 2
d78 1
a78 1
extern int	mi_listener __P((char *, int, smfiDesc_ptr, time_t, int));
a84 1
extern void	mi_closener __P((void));
d87 2
a88 2
extern char	*mi_rd_cmd __P((socket_t, struct timeval *, char *, size_t *, char *));
extern int	mi_wr_cmd __P((socket_t, struct timeval *, int, char *, size_t));
@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d11 1
a11 1
**  LIBMILTER.H -- include file for mail filter library functions
d20 1
a20 1
static char MilterlId[] = "@@(#)$Id: libmilter.h,v 8.3.6.10 2000/11/20 21:15:36 ca Exp $";
a26 5

#define NOT_SENDMAIL	1
#define _SOCK_ADDR	union bigsockaddr
#include "sendmail.h"

d28 1
a34 15
# define ValidSocket(sd)	((sd) >= 0)
# define INVALID_SOCKET		-1
# define MI_SOCK_READ(s, b, l)	(read(s, b, l))
# define MI_SOCK_WRITE(s, b, l)	(write(s, b, l))

# define thread_create(ptid,wr,arg) pthread_create(ptid, NULL, wr, arg)
# define sthread_get_id()	pthread_self()

typedef pthread_mutex_t smutex_t;
# define smutex_init(mp)	(pthread_mutex_init(mp, NULL) == 0)
# define smutex_destroy(mp)	(pthread_mutex_destroy(mp) == 0)
# define smutex_lock(mp)	(pthread_mutex_lock(mp) == 0)
# define smutex_unlock(mp)	(pthread_mutex_unlock(mp) == 0)
# define smutex_trylock(mp)	(pthread_mutex_trylock(mp) == 0)

a44 6
#if SOMAXCONN > 20
# define MI_SOMAXCONN	SOMAXCONN
#else /* SOMAXCONN */
# define MI_SOMAXCONN	20
#endif /* SOMAXCONN */

d68 2
d78 1
a78 1
extern int	mi_listener __P((char *, int, smfiDesc_ptr, time_t, int));
a84 1
extern void	mi_closener __P((void));
d87 2
a88 2
extern char	*mi_rd_cmd __P((socket_t, struct timeval *, char *, size_t *, char *));
extern int	mi_wr_cmd __P((socket_t, struct timeval *, int, char *, size_t));
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
a15 3

#include <sm/gen.h>

d19 3
a21 1
SM_IDSTR(MilterlId, "@@(#)$Sendmail: libmilter.h,v 8.26 2001/07/20 02:48:37 gshapiro Exp $")
d34 5
d61 1
a61 1
#define MI_TIMEOUT	7210		/* default timeout for read/write */
d64 5
a68 7
#ifndef MI_SOMAXCONN
# if SOMAXCONN > 20
#  define MI_SOMAXCONN	SOMAXCONN
# else /* SOMAXCONN */
#  define MI_SOMAXCONN	20
# endif /* SOMAXCONN */
#endif /* ! MI_SOMAXCONN */
a72 2
#define MAX_FAILS_A	16	/* accept() */
#define MAX_FAILS_S	16	/* select() */
a85 1
#define sm_dprintf	printf
a107 1
extern int	mi_inet_pton __P((int, const char *, void *));
@


