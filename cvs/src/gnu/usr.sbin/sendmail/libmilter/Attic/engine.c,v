head	1.21;
access;
symbols
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.10
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.8
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.6
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.4
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.18.0.12
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.10
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.6
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.8
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.4
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.17.0.4
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.6
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2014.09.17.18.49.50;	author matthieu;	state dead;
branches;
next	1.20;
commitid	M7i5giHIoz3DMlTU;

1.20
date	2014.02.07.21.24.59;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2011.05.17.15.54.23;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2008.05.04.18.34.04;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.04.14.43.48;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.13.13.01.48;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.16.00.21.30;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.24.03.59.25;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.19.01.41.13;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.17.17.31.39;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.01.19.59.21;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.15.02.23.35;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.18.00.49.27;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.28.02.43.51;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.15.21.09.02;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.07.19.20.34;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.42;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.52;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.28.50;	author miod;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Bye.
@
text
@/*
 *  Copyright (c) 1999-2004, 2006-2008 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sm/gen.h>
SM_RCSID("@@(#)$Sendmail: engine.c,v 8.168 2013/11/22 20:51:36 ca Exp $")

#include "libmilter.h"

#if NETINET || NETINET6
# include <arpa/inet.h>
#endif /* NETINET || NETINET6 */

/* generic argument for functions in the command table */
struct arg_struct
{
	size_t		a_len;		/* length of buffer */
	char		*a_buf;		/* argument string */
	int		a_idx;		/* index for macro array */
	SMFICTX_PTR	a_ctx;		/* context */
};

typedef struct arg_struct genarg;

/* structure for commands received from MTA */
struct cmdfct_t
{
	char	cm_cmd;				/* command */
	int	cm_argt;			/* type of arguments expected */
	int	cm_next;			/* next state */
	int	cm_todo;			/* what to do next */
	int	cm_macros;			/* index for macros */
	int	(*cm_fct) __P((genarg *));	/* function to execute */
};

typedef struct cmdfct_t cmdfct;

/* possible values for cm_argt */
#define	CM_ARG0	0	/* no args */
#define	CM_ARG1	1	/* one arg (string) */
#define	CM_ARG2	2	/* two args (strings) */
#define	CM_ARGA	4	/* one string and _SOCK_ADDR */
#define	CM_ARGO	5	/* two integers */
#define	CM_ARGV	8	/* \0 separated list of args, NULL-terminated */
#define	CM_ARGN	9	/* \0 separated list of args (strings) */

/* possible values for cm_todo */
#define	CT_CONT		0x0000	/* continue reading commands */
#define	CT_IGNO		0x0001	/* continue even when error  */

/* not needed right now, done via return code instead */
#define	CT_KEEP		0x0004	/* keep buffer (contains symbols) */
#define	CT_END		0x0008	/* last command of session, stop replying */

/* index in macro array: macros only for these commands */
#define	CI_NONE		(-1)
#define	CI_CONN		0
#define	CI_HELO		1
#define	CI_MAIL		2
#define CI_RCPT		3
#define CI_DATA		4
#define CI_EOM		5
#define CI_EOH		6
#define CI_LAST		CI_EOH
#if CI_LAST < CI_DATA
ERROR: do not compile with CI_LAST < CI_DATA
#endif
#if CI_LAST < CI_EOM
ERROR: do not compile with CI_LAST < CI_EOM
#endif
#if CI_LAST < CI_EOH
ERROR: do not compile with CI_LAST < CI_EOH
#endif
#if CI_LAST < CI_ENVRCPT
ERROR: do not compile with CI_LAST < CI_ENVRCPT
#endif
#if CI_LAST < CI_ENVFROM
ERROR: do not compile with CI_LAST < CI_ENVFROM
#endif
#if CI_LAST < CI_HELO
ERROR: do not compile with CI_LAST < CI_HELO
#endif
#if CI_LAST < CI_CONNECT
ERROR: do not compile with CI_LAST < CI_CONNECT
#endif
#if CI_LAST >= MAX_MACROS_ENTRIES
ERROR: do not compile with CI_LAST >= MAX_MACROS_ENTRIES
#endif

/* function prototypes */
static int	st_abortfct __P((genarg *));
static int	st_macros __P((genarg *));
static int	st_optionneg __P((genarg *));
static int	st_bodychunk __P((genarg *));
static int	st_connectinfo __P((genarg *));
static int	st_bodyend __P((genarg *));
static int	st_helo __P((genarg *));
static int	st_header __P((genarg *));
static int	st_sender __P((genarg *));
static int	st_rcpt __P((genarg *));
static int	st_unknown __P((genarg *));
static int	st_data __P((genarg *));
static int	st_eoh __P((genarg *));
static int	st_quit __P((genarg *));
static int	sendreply __P((sfsistat, socket_t, struct timeval *, SMFICTX_PTR));
static void	fix_stm __P((SMFICTX_PTR));
static bool	trans_ok __P((int, int));
static char	**dec_argv __P((char *, size_t));
static int	dec_arg2 __P((char *, size_t, char **, char **));
static void	mi_clr_symlist __P((SMFICTX_PTR));

#if _FFR_WORKERS_POOL
static bool     mi_rd_socket_ready __P((int));
#endif /* _FFR_WORKERS_POOL */

/* states */
#define ST_NONE	(-1)
#define ST_INIT	0	/* initial state */
#define ST_OPTS	1	/* option negotiation */
#define ST_CONN	2	/* connection info */
#define ST_HELO	3	/* helo */
#define ST_MAIL	4	/* mail from */
#define ST_RCPT	5	/* rcpt to */
#define ST_DATA	6	/* data */
#define ST_HDRS	7	/* headers */
#define ST_EOHS	8	/* end of headers */
#define ST_BODY	9	/* body */
#define ST_ENDM	10	/* end of message */
#define ST_QUIT	11	/* quit */
#define ST_ABRT	12	/* abort */
#define ST_UNKN 13	/* unknown SMTP command */
#define ST_Q_NC	14	/* quit, new connection follows */
#define ST_LAST	ST_Q_NC	/* last valid state */
#define ST_SKIP	16	/* not a state but required for the state table */

/* in a mail transaction? must be before eom according to spec. */
#define ST_IN_MAIL(st)	((st) >= ST_MAIL && (st) < ST_ENDM)

/*
**  set of next states
**  each state (ST_*) corresponds to bit in an int value (1 << state)
**  each state has a set of allowed transitions ('or' of bits of states)
**  so a state transition is valid if the mask of the next state
**  is set in the NX_* value
**  this function is coded in trans_ok(), see below.
*/

#define MI_MASK(x)	(0x0001 << (x))	/* generate a bit "mask" for a state */
#define NX_INIT	(MI_MASK(ST_OPTS))
#define NX_OPTS	(MI_MASK(ST_CONN) | MI_MASK(ST_UNKN))
#define NX_CONN	(MI_MASK(ST_HELO) | MI_MASK(ST_MAIL) | MI_MASK(ST_UNKN))
#define NX_HELO	(MI_MASK(ST_HELO) | MI_MASK(ST_MAIL) | MI_MASK(ST_UNKN))
#define NX_MAIL	(MI_MASK(ST_RCPT) | MI_MASK(ST_ABRT) | MI_MASK(ST_UNKN))
#define NX_RCPT	(MI_MASK(ST_HDRS) | MI_MASK(ST_EOHS) | MI_MASK(ST_DATA) | \
		 MI_MASK(ST_BODY) | MI_MASK(ST_ENDM) | \
		 MI_MASK(ST_RCPT) | MI_MASK(ST_ABRT) | MI_MASK(ST_UNKN))
#define NX_DATA	(MI_MASK(ST_EOHS) | MI_MASK(ST_HDRS) | MI_MASK(ST_ABRT))
#define NX_HDRS	(MI_MASK(ST_EOHS) | MI_MASK(ST_HDRS) | MI_MASK(ST_ABRT))
#define NX_EOHS	(MI_MASK(ST_BODY) | MI_MASK(ST_ENDM) | MI_MASK(ST_ABRT))
#define NX_BODY	(MI_MASK(ST_ENDM) | MI_MASK(ST_BODY) | MI_MASK(ST_ABRT))
#define NX_ENDM	(MI_MASK(ST_QUIT) | MI_MASK(ST_MAIL) | MI_MASK(ST_UNKN) | \
		MI_MASK(ST_Q_NC))
#define NX_QUIT	0
#define NX_ABRT	0
#define NX_UNKN (MI_MASK(ST_HELO) | MI_MASK(ST_MAIL) | \
		 MI_MASK(ST_RCPT) | MI_MASK(ST_ABRT) | \
		 MI_MASK(ST_DATA) | \
		 MI_MASK(ST_BODY) | MI_MASK(ST_UNKN) | \
		 MI_MASK(ST_ABRT) | MI_MASK(ST_QUIT) | MI_MASK(ST_Q_NC))
#define NX_Q_NC	(MI_MASK(ST_CONN) | MI_MASK(ST_UNKN))
#define NX_SKIP MI_MASK(ST_SKIP)

static int next_states[] =
{
	  NX_INIT
	, NX_OPTS
	, NX_CONN
	, NX_HELO
	, NX_MAIL
	, NX_RCPT
	, NX_DATA
	, NX_HDRS
	, NX_EOHS
	, NX_BODY
	, NX_ENDM
	, NX_QUIT
	, NX_ABRT
	, NX_UNKN
	, NX_Q_NC
};

#define SIZE_NEXT_STATES	(sizeof(next_states) / sizeof(next_states[0]))

/* commands received by milter */
static cmdfct cmds[] =
{
  {SMFIC_ABORT,	CM_ARG0, ST_ABRT,  CT_CONT,	CI_NONE, st_abortfct	}
, {SMFIC_MACRO,	CM_ARGV, ST_NONE,  CT_KEEP,	CI_NONE, st_macros	}
, {SMFIC_BODY,	CM_ARG1, ST_BODY,  CT_CONT,	CI_NONE, st_bodychunk	}
, {SMFIC_CONNECT, CM_ARG2, ST_CONN,  CT_CONT,	CI_CONN, st_connectinfo	}
, {SMFIC_BODYEOB, CM_ARG1, ST_ENDM,  CT_CONT,	CI_EOM,  st_bodyend	}
, {SMFIC_HELO,	CM_ARG1, ST_HELO,  CT_CONT,	CI_HELO, st_helo	}
, {SMFIC_HEADER, CM_ARG2, ST_HDRS,  CT_CONT,	CI_NONE, st_header	}
, {SMFIC_MAIL,	CM_ARGV, ST_MAIL,  CT_CONT,	CI_MAIL, st_sender	}
, {SMFIC_OPTNEG, CM_ARGO, ST_OPTS,  CT_CONT,	CI_NONE, st_optionneg	}
, {SMFIC_EOH,	CM_ARG0, ST_EOHS,  CT_CONT,	CI_EOH,  st_eoh		}
, {SMFIC_QUIT,	CM_ARG0, ST_QUIT,  CT_END,	CI_NONE, st_quit	}
, {SMFIC_DATA,	CM_ARG0, ST_DATA,  CT_CONT,	CI_DATA, st_data	}
, {SMFIC_RCPT,	CM_ARGV, ST_RCPT,  CT_IGNO,	CI_RCPT, st_rcpt	}
, {SMFIC_UNKNOWN, CM_ARG1, ST_UNKN,  CT_IGNO,	CI_NONE, st_unknown	}
, {SMFIC_QUIT_NC, CM_ARG0, ST_Q_NC,  CT_CONT,	CI_NONE, st_quit	}
};

/*
**  Additional (internal) reply codes;
**  must be coordinated wit libmilter/mfapi.h
*/

#define _SMFIS_KEEP	20
#define _SMFIS_ABORT	21
#define _SMFIS_OPTIONS	22
#define _SMFIS_NOREPLY	SMFIS_NOREPLY
#define _SMFIS_FAIL	(-1)
#define _SMFIS_NONE	(-2)

/*
**  MI_ENGINE -- receive commands and process them
**
**	Parameters:
**		ctx -- context structure
**
**	Returns:
**		MI_FAILURE/MI_SUCCESS
*/

int
mi_engine(ctx)
	SMFICTX_PTR ctx;
{
	size_t len;
	int i;
	socket_t sd;
	int ret = MI_SUCCESS;
	int ncmds = sizeof(cmds) / sizeof(cmdfct);
	int curstate = ST_INIT;
	int newstate;
	bool call_abort;
	sfsistat r;
	char cmd;
	char *buf = NULL;
	genarg arg;
	struct timeval timeout;
	int (*f) __P((genarg *));
	sfsistat (*fi_abort) __P((SMFICTX *));
	sfsistat (*fi_close) __P((SMFICTX *));

	arg.a_ctx = ctx;
	sd = ctx->ctx_sd;
	fi_abort = ctx->ctx_smfi->xxfi_abort;
#if _FFR_WORKERS_POOL
	curstate = ctx->ctx_state;
	if (curstate == ST_INIT)
	{
		mi_clr_macros(ctx, 0);
		fix_stm(ctx);
	}
#else   /* _FFR_WORKERS_POOL */
	mi_clr_macros(ctx, 0);
	fix_stm(ctx);
#endif  /* _FFR_WORKERS_POOL */
	r = _SMFIS_NONE;
	do
	{
		/* call abort only if in a mail transaction */
		call_abort = ST_IN_MAIL(curstate);
		timeout.tv_sec = ctx->ctx_timeout;
		timeout.tv_usec = 0;
		if (mi_stop() == MILTER_ABRT)
		{
			if (ctx->ctx_dbg > 3)
				sm_dprintf("[%lu] milter_abort\n",
					(long) ctx->ctx_id);
			ret = MI_FAILURE;
			break;
		}

		/*
		**  Notice: buf is allocated by mi_rd_cmd() and it will
		**  usually be free()d after it has been used in f().
		**  However, if the function returns _SMFIS_KEEP then buf
		**  contains macros and will not be free()d.
		**  Hence r must be set to _SMFIS_NONE if a new buf is
		**  allocated to avoid problem with housekeeping, esp.
		**  if the code "break"s out of the loop.
		*/

#if _FFR_WORKERS_POOL
		/* Is the socket ready to be read ??? */
		if (!mi_rd_socket_ready(sd))
		{
			ret = MI_CONTINUE;
			break;
		}
#endif  /* _FFR_WORKERS_POOL */

		r = _SMFIS_NONE;
		if ((buf = mi_rd_cmd(sd, &timeout, &cmd, &len,
				     ctx->ctx_smfi->xxfi_name)) == NULL &&
		    cmd < SMFIC_VALIDCMD)
		{
			if (ctx->ctx_dbg > 5)
				sm_dprintf("[%lu] mi_engine: mi_rd_cmd error (%x)\n",
					(long) ctx->ctx_id, (int) cmd);

			/*
			**  eof is currently treated as failure ->
			**  abort() instead of close(), otherwise use:
			**  if (cmd != SMFIC_EOF)
			*/

			ret = MI_FAILURE;
			break;
		}
		if (ctx->ctx_dbg > 4)
			sm_dprintf("[%lu] got cmd '%c' len %d\n",
				(long) ctx->ctx_id, cmd, (int) len);
		for (i = 0; i < ncmds; i++)
		{
			if (cmd == cmds[i].cm_cmd)
				break;
		}
		if (i >= ncmds)
		{
			/* unknown command */
			if (ctx->ctx_dbg > 1)
				sm_dprintf("[%lu] cmd '%c' unknown\n",
					(long) ctx->ctx_id, cmd);
			ret = MI_FAILURE;
			break;
		}
		if ((f = cmds[i].cm_fct) == NULL)
		{
			/* stop for now */
			if (ctx->ctx_dbg > 1)
				sm_dprintf("[%lu] cmd '%c' not impl\n",
					(long) ctx->ctx_id, cmd);
			ret = MI_FAILURE;
			break;
		}

		/* is new state ok? */
		newstate = cmds[i].cm_next;
		if (ctx->ctx_dbg > 5)
			sm_dprintf("[%lu] cur %x new %x nextmask %x\n",
				(long) ctx->ctx_id,
				curstate, newstate, next_states[curstate]);

		if (newstate != ST_NONE && !trans_ok(curstate, newstate))
		{
			if (ctx->ctx_dbg > 1)
				sm_dprintf("[%lu] abort: cur %d (%x) new %d (%x) next %x\n",
					(long) ctx->ctx_id,
					curstate, MI_MASK(curstate),
					newstate, MI_MASK(newstate),
					next_states[curstate]);

			/* call abort only if in a mail transaction */
			if (fi_abort != NULL && call_abort)
				(void) (*fi_abort)(ctx);

			/*
			**  try to reach the new state from HELO
			**  if it can't be reached, ignore the command.
			*/

			curstate = ST_HELO;
			if (!trans_ok(curstate, newstate))
			{
				if (buf != NULL)
				{
					free(buf);
					buf = NULL;
				}
				continue;
			}
		}
		arg.a_len = len;
		arg.a_buf = buf;
		if (newstate != ST_NONE)
		{
			curstate = newstate;
			ctx->ctx_state = curstate;
		}
		arg.a_idx = cmds[i].cm_macros;
		call_abort = ST_IN_MAIL(curstate);

		/* call function to deal with command */
		MI_MONITOR_BEGIN(ctx, cmd);
		r = (*f)(&arg);
		MI_MONITOR_END(ctx, cmd);
		if (r != _SMFIS_KEEP && buf != NULL)
		{
			free(buf);
			buf = NULL;
		}
		if (sendreply(r, sd, &timeout, ctx) != MI_SUCCESS)
		{
			ret = MI_FAILURE;
			break;
		}

		if (r == SMFIS_ACCEPT)
		{
			/* accept mail, no further actions taken */
			curstate = ST_HELO;
		}
		else if (r == SMFIS_REJECT || r == SMFIS_DISCARD ||
			 r ==  SMFIS_TEMPFAIL)
		{
			/*
			**  further actions depend on current state
			**  if the IGNO bit is set: "ignore" the error,
			**  i.e., stay in the current state
			*/
			if (!bitset(CT_IGNO, cmds[i].cm_todo))
				curstate = ST_HELO;
		}
		else if (r == _SMFIS_ABORT)
		{
			if (ctx->ctx_dbg > 5)
				sm_dprintf("[%lu] function returned abort\n",
					(long) ctx->ctx_id);
			ret = MI_FAILURE;
			break;
		}
	} while (!bitset(CT_END, cmds[i].cm_todo));

	ctx->ctx_state = curstate;

	if (ret == MI_FAILURE)
	{
		/* call abort only if in a mail transaction */
		if (fi_abort != NULL && call_abort)
			(void) (*fi_abort)(ctx);
	}

	/* has close been called? */
	if (ctx->ctx_state != ST_QUIT
#if _FFR_WORKERS_POOL
	   && ret != MI_CONTINUE
#endif /* _FFR_WORKERS_POOL */
	   )
	{
		if ((fi_close = ctx->ctx_smfi->xxfi_close) != NULL)
			(void) (*fi_close)(ctx);
	}
	if (r != _SMFIS_KEEP && buf != NULL)
		free(buf);
#if !_FFR_WORKERS_POOL
	mi_clr_macros(ctx, 0);
#endif /* _FFR_WORKERS_POOL */
	return ret;
}

static size_t milter_addsymlist __P((SMFICTX_PTR, char *, char **));

static size_t
milter_addsymlist(ctx, buf, newbuf)
	SMFICTX_PTR ctx;
	char *buf;
	char **newbuf;
{
	size_t len;
	int i;
	mi_int32 v;
	char *buffer;

	SM_ASSERT(ctx != NULL);
	SM_ASSERT(buf != NULL);
	SM_ASSERT(newbuf != NULL);
	len = 0;
	for (i = 0; i < MAX_MACROS_ENTRIES; i++)
	{
		if (ctx->ctx_mac_list[i] != NULL)
		{
			len += strlen(ctx->ctx_mac_list[i]) + 1 +
				MILTER_LEN_BYTES;
		}
	}
	if (len > 0)
	{
		size_t offset;

		SM_ASSERT(len + MILTER_OPTLEN > len);
		len += MILTER_OPTLEN;
		buffer = malloc(len);
		if (buffer != NULL)
		{
			(void) memcpy(buffer, buf, MILTER_OPTLEN);
			offset = MILTER_OPTLEN;
			for (i = 0; i < MAX_MACROS_ENTRIES; i++)
			{
				size_t l;

				if (ctx->ctx_mac_list[i] == NULL)
					continue;

				SM_ASSERT(offset + MILTER_LEN_BYTES < len);
				v = htonl(i);
				(void) memcpy(buffer + offset, (void *) &v,
						MILTER_LEN_BYTES);
				offset += MILTER_LEN_BYTES;
				l = strlen(ctx->ctx_mac_list[i]) + 1;
				SM_ASSERT(offset + l <= len);
				(void) memcpy(buffer + offset,
						ctx->ctx_mac_list[i], l);
				offset += l;
			}
		}
		else
		{
			/* oops ... */
		}
	}
	else
	{
		len = MILTER_OPTLEN;
		buffer = buf;
	}
	*newbuf = buffer;
	return len;
}

/*
**  GET_NR_BIT -- get "no reply" bit matching state
**
**	Parameters:
**		state -- current protocol stage
**
**	Returns:
**		0: no matching bit
**		>0: the matching "no reply" bit
*/

static unsigned long get_nr_bit __P((int));

static unsigned long
get_nr_bit(state)
	int state;
{
	unsigned long bit;

	switch (state)
	{
	  case ST_CONN:
		bit = SMFIP_NR_CONN;
		break;
	  case ST_HELO:
		bit = SMFIP_NR_HELO;
		break;
	  case ST_MAIL:
		bit = SMFIP_NR_MAIL;
		break;
	  case ST_RCPT:
		bit = SMFIP_NR_RCPT;
		break;
	  case ST_DATA:
		bit = SMFIP_NR_DATA;
		break;
	  case ST_UNKN:
		bit = SMFIP_NR_UNKN;
		break;
	  case ST_HDRS:
		bit = SMFIP_NR_HDR;
		break;
	  case ST_EOHS:
		bit = SMFIP_NR_EOH;
		break;
	  case ST_BODY:
		bit = SMFIP_NR_BODY;
		break;
	  default:
		bit = 0;
		break;
	}
	return bit;
}

/*
**  SENDREPLY -- send a reply to the MTA
**
**	Parameters:
**		r -- reply code
**		sd -- socket descriptor
**		timeout_ptr -- (ptr to) timeout to use for sending
**		ctx -- context structure
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

static int
sendreply(r, sd, timeout_ptr, ctx)
	sfsistat r;
	socket_t sd;
	struct timeval *timeout_ptr;
	SMFICTX_PTR ctx;
{
	int ret;
	unsigned long bit;

	ret = MI_SUCCESS;

	bit = get_nr_bit(ctx->ctx_state);
	if (bit != 0 && (ctx->ctx_pflags & bit) != 0 && r != SMFIS_NOREPLY)
	{
		if (r >= SMFIS_CONTINUE && r < _SMFIS_KEEP)
		{
			/* milter said it wouldn't reply, but it lied... */
			smi_log(SMI_LOG_ERR,
				"%s: milter claimed not to reply in state %d but did anyway %d\n",
				ctx->ctx_smfi->xxfi_name,
				ctx->ctx_state, r);

		}

		/*
		**  Force specified behavior, otherwise libmilter
		**  and MTA will fail to communicate properly.
		*/

		switch (r)
		{
		  case SMFIS_CONTINUE:
		  case SMFIS_TEMPFAIL:
		  case SMFIS_REJECT:
		  case SMFIS_DISCARD:
		  case SMFIS_ACCEPT:
		  case SMFIS_SKIP:
		  case _SMFIS_OPTIONS:
			r = SMFIS_NOREPLY;
			break;
		}
	}

	switch (r)
	{
	  case SMFIS_CONTINUE:
		ret = mi_wr_cmd(sd, timeout_ptr, SMFIR_CONTINUE, NULL, 0);
		break;
	  case SMFIS_TEMPFAIL:
	  case SMFIS_REJECT:
		if (ctx->ctx_reply != NULL &&
		    ((r == SMFIS_TEMPFAIL && *ctx->ctx_reply == '4') ||
		     (r == SMFIS_REJECT && *ctx->ctx_reply == '5')))
		{
			ret = mi_wr_cmd(sd, timeout_ptr, SMFIR_REPLYCODE,
					ctx->ctx_reply,
					strlen(ctx->ctx_reply) + 1);
			free(ctx->ctx_reply);
			ctx->ctx_reply = NULL;
		}
		else
		{
			ret = mi_wr_cmd(sd, timeout_ptr, r == SMFIS_REJECT ?
					SMFIR_REJECT : SMFIR_TEMPFAIL, NULL, 0);
		}
		break;
	  case SMFIS_DISCARD:
		ret = mi_wr_cmd(sd, timeout_ptr, SMFIR_DISCARD, NULL, 0);
		break;
	  case SMFIS_ACCEPT:
		ret = mi_wr_cmd(sd, timeout_ptr, SMFIR_ACCEPT, NULL, 0);
		break;
	  case SMFIS_SKIP:
		ret = mi_wr_cmd(sd, timeout_ptr, SMFIR_SKIP, NULL, 0);
		break;
	  case _SMFIS_OPTIONS:
		{
			mi_int32 v;
			size_t len;
			char *buffer;
			char buf[MILTER_OPTLEN];

			v = htonl(ctx->ctx_prot_vers2mta);
			(void) memcpy(&(buf[0]), (void *) &v,
				      MILTER_LEN_BYTES);
			v = htonl(ctx->ctx_aflags);
			(void) memcpy(&(buf[MILTER_LEN_BYTES]), (void *) &v,
				      MILTER_LEN_BYTES);
			v = htonl(ctx->ctx_pflags2mta);
			(void) memcpy(&(buf[MILTER_LEN_BYTES * 2]),
				      (void *) &v, MILTER_LEN_BYTES);
			len = milter_addsymlist(ctx, buf, &buffer);
			if (buffer != NULL)
				ret = mi_wr_cmd(sd, timeout_ptr, SMFIC_OPTNEG,
						buffer, len);
			else
				ret = MI_FAILURE;
		}
		break;
	  case SMFIS_NOREPLY:
		if (bit != 0 &&
		    (ctx->ctx_pflags & bit) != 0 &&
		    (ctx->ctx_mta_pflags & bit) == 0)
		{
			/*
			**  milter doesn't want to send a reply,
			**  but the MTA doesn't have that feature: fake it.
			*/

			ret = mi_wr_cmd(sd, timeout_ptr, SMFIR_CONTINUE, NULL,
					0);
		}
		break;
	  default:	/* don't send a reply */
		break;
	}
	return ret;
}

/*
**  CLR_MACROS -- clear set of macros starting from a given index
**
**	Parameters:
**		ctx -- context structure
**		m -- index from which to clear all macros
**
**	Returns:
**		None.
*/

void
mi_clr_macros(ctx, m)
	SMFICTX_PTR ctx;
	int m;
{
	int i;

	for (i = m; i < MAX_MACROS_ENTRIES; i++)
	{
		if (ctx->ctx_mac_ptr[i] != NULL)
		{
			free(ctx->ctx_mac_ptr[i]);
			ctx->ctx_mac_ptr[i] = NULL;
		}
		if (ctx->ctx_mac_buf[i] != NULL)
		{
			free(ctx->ctx_mac_buf[i]);
			ctx->ctx_mac_buf[i] = NULL;
		}
	}
}

/*
**  MI_CLR_SYMLIST -- clear list of macros
**
**	Parameters:
**		ctx -- context structure
**
**	Returns:
**		None.
*/

static void
mi_clr_symlist(ctx)
	SMFICTX *ctx;
{
	int i;

	SM_ASSERT(ctx != NULL);
	for (i = SMFIM_FIRST; i <= SMFIM_LAST; i++)
	{
		if (ctx->ctx_mac_list[i] != NULL)
		{
			free(ctx->ctx_mac_list[i]);
			ctx->ctx_mac_list[i] = NULL;
		}
	}
}

/*
**  MI_CLR_CTX -- clear context
**
**	Parameters:
**		ctx -- context structure
**
**	Returns:
**		None.
*/

void
mi_clr_ctx(ctx)
	SMFICTX *ctx;
{
	SM_ASSERT(ctx != NULL);
	if (ValidSocket(ctx->ctx_sd))
	{
		(void) closesocket(ctx->ctx_sd);
		ctx->ctx_sd = INVALID_SOCKET;
	}
	if (ctx->ctx_reply != NULL)
	{
		free(ctx->ctx_reply);
		ctx->ctx_reply = NULL;
	}
	if (ctx->ctx_privdata != NULL)
	{
		smi_log(SMI_LOG_WARN,
			"%s: private data not NULL",
			ctx->ctx_smfi->xxfi_name);
	}
	mi_clr_macros(ctx, 0);
	mi_clr_symlist(ctx);
	free(ctx);
}

/*
**  ST_OPTIONNEG -- negotiate options
**
**	Parameters:
**		g -- generic argument structure
**
**	Returns:
**		abort/send options/continue
*/

static int
st_optionneg(g)
	genarg *g;
{
	mi_int32 i, v, fake_pflags, internal_pflags;
	SMFICTX_PTR ctx;
#if _FFR_MILTER_CHECK
	bool testmode = false;
#endif /* _FFR_MILTER_CHECK */
	int (*fi_negotiate) __P((SMFICTX *,
					unsigned long, unsigned long,
					unsigned long, unsigned long,
					unsigned long *, unsigned long *,
					unsigned long *, unsigned long *));

	if (g == NULL || g->a_ctx->ctx_smfi == NULL)
		return SMFIS_CONTINUE;
	ctx = g->a_ctx;
	mi_clr_macros(ctx, g->a_idx + 1);
	ctx->ctx_prot_vers = SMFI_PROT_VERSION;

	/* check for minimum length */
	if (g->a_len < MILTER_OPTLEN)
	{
		smi_log(SMI_LOG_ERR,
			"%s: st_optionneg[%ld]: len too short %d < %d",
			ctx->ctx_smfi->xxfi_name,
			(long) ctx->ctx_id, (int) g->a_len,
			MILTER_OPTLEN);
		return _SMFIS_ABORT;
	}

	/* protocol version */
	(void) memcpy((void *) &i, (void *) &(g->a_buf[0]), MILTER_LEN_BYTES);
	v = ntohl(i);

#define SMFI_PROT_VERSION_MIN	2

	/* check for minimum version */
	if (v < SMFI_PROT_VERSION_MIN)
	{
		smi_log(SMI_LOG_ERR,
			"%s: st_optionneg[%ld]: protocol version too old %d < %d",
			ctx->ctx_smfi->xxfi_name,
			(long) ctx->ctx_id, v, SMFI_PROT_VERSION_MIN);
		return _SMFIS_ABORT;
	}
	ctx->ctx_mta_prot_vers = v;
	if (ctx->ctx_prot_vers < ctx->ctx_mta_prot_vers)
		ctx->ctx_prot_vers2mta = ctx->ctx_prot_vers;
	else
		ctx->ctx_prot_vers2mta = ctx->ctx_mta_prot_vers;

	(void) memcpy((void *) &i, (void *) &(g->a_buf[MILTER_LEN_BYTES]),
		      MILTER_LEN_BYTES);
	v = ntohl(i);

	/* no flags? set to default value for V1 actions */
	if (v == 0)
		v = SMFI_V1_ACTS;
	ctx->ctx_mta_aflags = v;	/* MTA action flags */

	internal_pflags = 0;
	(void) memcpy((void *) &i, (void *) &(g->a_buf[MILTER_LEN_BYTES * 2]),
		      MILTER_LEN_BYTES);
	v = ntohl(i);

	/* no flags? set to default value for V1 protocol */
	if (v == 0)
		v = SMFI_V1_PROT;
#if _FFR_MDS_NEGOTIATE
	else if (ctx->ctx_smfi->xxfi_version >= SMFI_VERSION_MDS)
	{
		/*
		**  Allow changing the size only if milter is compiled
		**  against a version that supports this.
		**  If a milter is dynamically linked against a newer
		**  libmilter version, we don't want to "surprise"
		**  it with a larger buffer as it may rely on it
		**  even though it is not documented as a limit.
		*/

		if (bitset(SMFIP_MDS_1M, v))
		{
			internal_pflags |= SMFIP_MDS_1M;
			(void) smfi_setmaxdatasize(MILTER_MDS_1M);
		}
		else if (bitset(SMFIP_MDS_256K, v))
		{
			internal_pflags |= SMFIP_MDS_256K;
			(void) smfi_setmaxdatasize(MILTER_MDS_256K);
		}
	}
# if 0
	/* don't log this for now... */
	else if (ctx->ctx_smfi->xxfi_version < SMFI_VERSION_MDS &&
		 bitset(SMFIP_MDS_1M|SMFIP_MDS_256K, v))
	{
		smi_log(SMI_LOG_WARN,
			"%s: st_optionneg[%ld]: milter version=%X, trying flags=%X",
			ctx->ctx_smfi->xxfi_name,
			(long) ctx->ctx_id, ctx->ctx_smfi->xxfi_version, v);
	}
# endif /* 0 */
#endif /* _FFR_MDS_NEGOTIATE */

	/*
	**  MTA protocol flags.
	**  We pass the internal flags to the milter as "read only",
	**  i.e., a milter can read them so it knows which size
	**  will be used, but any changes by a milter will be ignored
	**  (see below, search for SMFI_INTERNAL).
	*/

	ctx->ctx_mta_pflags = (v & ~SMFI_INTERNAL) | internal_pflags;

	/*
	**  Copy flags from milter struct into libmilter context;
	**  this variable will be used later on to check whether
	**  the MTA "actions" can fulfill the milter requirements,
	**  but it may be overwritten by the negotiate callback.
	*/

	ctx->ctx_aflags = ctx->ctx_smfi->xxfi_flags;
	fake_pflags = SMFIP_NR_CONN
			|SMFIP_NR_HELO
			|SMFIP_NR_MAIL
			|SMFIP_NR_RCPT
			|SMFIP_NR_DATA
			|SMFIP_NR_UNKN
			|SMFIP_NR_HDR
			|SMFIP_NR_EOH
			|SMFIP_NR_BODY
			;

	if (g->a_ctx->ctx_smfi != NULL &&
	    g->a_ctx->ctx_smfi->xxfi_version > 4 &&
	    (fi_negotiate = g->a_ctx->ctx_smfi->xxfi_negotiate) != NULL)
	{
		int r;
		unsigned long m_aflags, m_pflags, m_f2, m_f3;

		/*
		**  let milter decide whether the features offered by the
		**  MTA are "good enough".
		**  Notes:
		**  - libmilter can "fake" some features (e.g., SMFIP_NR_HDR)
		**  - m_f2, m_f3 are for future extensions
		*/

		m_f2 = m_f3 = 0;
		m_aflags = ctx->ctx_mta_aflags;
		m_pflags = ctx->ctx_pflags;
		if ((SMFIP_SKIP & ctx->ctx_mta_pflags) != 0)
			m_pflags |= SMFIP_SKIP;
		r = fi_negotiate(g->a_ctx,
				ctx->ctx_mta_aflags,
				ctx->ctx_mta_pflags|fake_pflags,
				0, 0,
				&m_aflags, &m_pflags, &m_f2, &m_f3);

#if _FFR_MILTER_CHECK
		testmode = bitset(SMFIP_TEST, m_pflags);
		if (testmode)
			m_pflags &= ~SMFIP_TEST;
#endif /* _FFR_MILTER_CHECK */

		/*
		**  Types of protocol flags (pflags):
		**  1. do NOT send protocol step X
		**  2. MTA can do/understand something extra (SKIP,
		**	send unknown RCPTs)
		**  3. MTA can deal with "no reply" for various protocol steps
		**  Note: this mean that it isn't possible to simply set all
		**	flags to get "everything":
		**	setting a flag of type 1 turns off a step
		**		(it should be the other way around:
		**		a flag means a protocol step can be sent)
		**	setting a flag of type 3 requires that milter
		**	never sends a reply for the corresponding step.
		**  Summary: the "negation" of protocol flags is causing
		**	problems, but at least for type 3 there is no simple
		**	solution.
		**
		**  What should "all options" mean?
		**  send all protocol steps _except_ those for which there is
		**	no callback (currently registered in ctx_pflags)
		**  expect SKIP as return code?		Yes
		**  send unknown RCPTs?			No,
		**				must be explicitly requested?
		**  "no reply" for some protocol steps?	No,
		**				must be explicitly requested.
		*/

		if (SMFIS_ALL_OPTS == r)
		{
			ctx->ctx_aflags = ctx->ctx_mta_aflags;
			ctx->ctx_pflags2mta = ctx->ctx_pflags;
			if ((SMFIP_SKIP & ctx->ctx_mta_pflags) != 0)
				ctx->ctx_pflags2mta |= SMFIP_SKIP;
		}
		else if (r != SMFIS_CONTINUE)
		{
			smi_log(SMI_LOG_ERR,
				"%s: st_optionneg[%ld]: xxfi_negotiate returned %d (protocol options=0x%lx, actions=0x%lx)",
				ctx->ctx_smfi->xxfi_name,
				(long) ctx->ctx_id, r, ctx->ctx_mta_pflags,
				ctx->ctx_mta_aflags);
			return _SMFIS_ABORT;
		}
		else
		{
			ctx->ctx_aflags = m_aflags;
			ctx->ctx_pflags = m_pflags;
			ctx->ctx_pflags2mta = m_pflags;
		}

		/* check whether some flags need to be "faked" */
		i = ctx->ctx_pflags2mta;
		if ((ctx->ctx_mta_pflags & i) != i)
		{
			unsigned int idx;
			unsigned long b;

			/*
			**  If some behavior can be faked (set in fake_pflags),
			**  but the MTA doesn't support it, then unset
			**  that flag in the value that is sent to the MTA.
			*/

			for (idx = 0; idx < 32; idx++)
			{
				b = 1 << idx;
				if ((ctx->ctx_mta_pflags & b) != b &&
				    (fake_pflags & b) == b)
					ctx->ctx_pflags2mta &= ~b;
			}
		}
	}
	else
	{
		/*
		**  Set the protocol flags based on the values determined
		**  in mi_listener() which checked the defined callbacks.
		*/

		ctx->ctx_pflags2mta = ctx->ctx_pflags;
	}

	/* check whether actions and protocol requirements can be satisfied */
	i = ctx->ctx_aflags;
	if ((i & ctx->ctx_mta_aflags) != i)
	{
		smi_log(SMI_LOG_ERR,
			"%s: st_optionneg[%ld]: 0x%lx does not fulfill action requirements 0x%x",
			ctx->ctx_smfi->xxfi_name,
			(long) ctx->ctx_id, ctx->ctx_mta_aflags, i);
		return _SMFIS_ABORT;
	}

	i = ctx->ctx_pflags2mta;
	if ((ctx->ctx_mta_pflags & i) != i)
	{
		/*
		**  Older MTAs do not support some protocol steps.
		**  As this protocol is a bit "wierd" (it asks for steps
		**  NOT to be taken/sent) we have to check whether we
		**  should turn off those "negative" requests.
		**  Currently these are only SMFIP_NODATA and SMFIP_NOUNKNOWN.
		*/

		if (bitset(SMFIP_NODATA, ctx->ctx_pflags2mta) &&
		    !bitset(SMFIP_NODATA, ctx->ctx_mta_pflags))
			ctx->ctx_pflags2mta &= ~SMFIP_NODATA;
		if (bitset(SMFIP_NOUNKNOWN, ctx->ctx_pflags2mta) &&
		    !bitset(SMFIP_NOUNKNOWN, ctx->ctx_mta_pflags))
			ctx->ctx_pflags2mta &= ~SMFIP_NOUNKNOWN;
		i = ctx->ctx_pflags2mta;
	}

	if ((ctx->ctx_mta_pflags & i) != i)
	{
		smi_log(SMI_LOG_ERR,
			"%s: st_optionneg[%ld]: 0x%lx does not fulfill protocol requirements 0x%x",
			ctx->ctx_smfi->xxfi_name,
			(long) ctx->ctx_id, ctx->ctx_mta_pflags, i);
		return _SMFIS_ABORT;
	}
	fix_stm(ctx);

	if (ctx->ctx_dbg > 3)
		sm_dprintf("[%lu] milter_negotiate:"
			" mta_actions=0x%lx, mta_flags=0x%lx"
			" actions=0x%lx, flags=0x%lx\n"
			, (long) ctx->ctx_id
			, ctx->ctx_mta_aflags, ctx->ctx_mta_pflags
			, ctx->ctx_aflags, ctx->ctx_pflags);

#if _FFR_MILTER_CHECK
	if (ctx->ctx_dbg > 3)
		sm_dprintf("[%lu] milter_negotiate:"
			" testmode=%d, pflags2mta=%X, internal_pflags=%X\n"
			, (long) ctx->ctx_id, testmode
			, ctx->ctx_pflags2mta, internal_pflags);

	/* in test mode: take flags without further modifications */
	if (!testmode)
		/* Warning: check statement below! */
#endif /* _FFR_MILTER_CHECK */

	/*
	**  Remove the internal flags that might have been set by a milter
	**  and set only those determined above.
	*/

	ctx->ctx_pflags2mta = (ctx->ctx_pflags2mta & ~SMFI_INTERNAL)
			      | internal_pflags;
	return _SMFIS_OPTIONS;
}

/*
**  ST_CONNECTINFO -- receive connection information
**
**	Parameters:
**		g -- generic argument structure
**
**	Returns:
**		continue or filter-specified value
*/

static int
st_connectinfo(g)
	genarg *g;
{
	size_t l;
	size_t i;
	char *s, family;
	unsigned short port = 0;
	_SOCK_ADDR sockaddr;
	sfsistat (*fi_connect) __P((SMFICTX *, char *, _SOCK_ADDR *));

	if (g == NULL)
		return _SMFIS_ABORT;
	mi_clr_macros(g->a_ctx, g->a_idx + 1);
	if (g->a_ctx->ctx_smfi == NULL ||
	    (fi_connect = g->a_ctx->ctx_smfi->xxfi_connect) == NULL)
		return SMFIS_CONTINUE;

	s = g->a_buf;
	i = 0;
	l = g->a_len;
	while (s[i] != '\0' && i <= l)
		++i;
	if (i + 1 >= l)
		return _SMFIS_ABORT;

	/* Move past trailing \0 in host string */
	i++;
	family = s[i++];
	(void) memset(&sockaddr, '\0', sizeof sockaddr);
	if (family != SMFIA_UNKNOWN)
	{
		if (i + sizeof port >= l)
		{
			smi_log(SMI_LOG_ERR,
				"%s: connect[%ld]: wrong len %d >= %d",
				g->a_ctx->ctx_smfi->xxfi_name,
				(long) g->a_ctx->ctx_id, (int) i, (int) l);
			return _SMFIS_ABORT;
		}
		(void) memcpy((void *) &port, (void *) (s + i),
			      sizeof port);
		i += sizeof port;

		/* make sure string is terminated */
		if (s[l - 1] != '\0')
			return _SMFIS_ABORT;
# if NETINET
		if (family == SMFIA_INET)
		{
			if (inet_aton(s + i, (struct in_addr *) &sockaddr.sin.sin_addr)
			    != 1)
			{
				smi_log(SMI_LOG_ERR,
					"%s: connect[%ld]: inet_aton failed",
					g->a_ctx->ctx_smfi->xxfi_name,
					(long) g->a_ctx->ctx_id);
				return _SMFIS_ABORT;
			}
			sockaddr.sa.sa_family = AF_INET;
			if (port > 0)
				sockaddr.sin.sin_port = port;
		}
		else
# endif /* NETINET */
# if NETINET6
		if (family == SMFIA_INET6)
		{
			if (mi_inet_pton(AF_INET6, s + i,
					 &sockaddr.sin6.sin6_addr) != 1)
			{
				smi_log(SMI_LOG_ERR,
					"%s: connect[%ld]: mi_inet_pton failed",
					g->a_ctx->ctx_smfi->xxfi_name,
					(long) g->a_ctx->ctx_id);
				return _SMFIS_ABORT;
			}
			sockaddr.sa.sa_family = AF_INET6;
			if (port > 0)
				sockaddr.sin6.sin6_port = port;
		}
		else
# endif /* NETINET6 */
# if NETUNIX
		if (family == SMFIA_UNIX)
		{
			if (sm_strlcpy(sockaddr.sunix.sun_path, s + i,
			    sizeof sockaddr.sunix.sun_path) >=
			    sizeof sockaddr.sunix.sun_path)
			{
				smi_log(SMI_LOG_ERR,
					"%s: connect[%ld]: path too long",
					g->a_ctx->ctx_smfi->xxfi_name,
					(long) g->a_ctx->ctx_id);
				return _SMFIS_ABORT;
			}
			sockaddr.sunix.sun_family = AF_UNIX;
		}
		else
# endif /* NETUNIX */
		{
			smi_log(SMI_LOG_ERR,
				"%s: connect[%ld]: unknown family %d",
				g->a_ctx->ctx_smfi->xxfi_name,
				(long) g->a_ctx->ctx_id, family);
			return _SMFIS_ABORT;
		}
	}
	return (*fi_connect)(g->a_ctx, g->a_buf,
			     family != SMFIA_UNKNOWN ? &sockaddr : NULL);
}

/*
**  ST_EOH -- end of headers
**
**	Parameters:
**		g -- generic argument structure
**
**	Returns:
**		continue or filter-specified value
*/

static int
st_eoh(g)
	genarg *g;
{
	sfsistat (*fi_eoh) __P((SMFICTX *));

	if (g == NULL)
		return _SMFIS_ABORT;
	if (g->a_ctx->ctx_smfi != NULL &&
	    (fi_eoh = g->a_ctx->ctx_smfi->xxfi_eoh) != NULL)
		return (*fi_eoh)(g->a_ctx);
	return SMFIS_CONTINUE;
}

/*
**  ST_DATA -- DATA command
**
**	Parameters:
**		g -- generic argument structure
**
**	Returns:
**		continue or filter-specified value
*/

static int
st_data(g)
	genarg *g;
{
	sfsistat (*fi_data) __P((SMFICTX *));

	if (g == NULL)
		return _SMFIS_ABORT;
	if (g->a_ctx->ctx_smfi != NULL &&
	    g->a_ctx->ctx_smfi->xxfi_version > 3 &&
	    (fi_data = g->a_ctx->ctx_smfi->xxfi_data) != NULL)
		return (*fi_data)(g->a_ctx);
	return SMFIS_CONTINUE;
}

/*
**  ST_HELO -- helo/ehlo command
**
**	Parameters:
**		g -- generic argument structure
**
**	Returns:
**		continue or filter-specified value
*/

static int
st_helo(g)
	genarg *g;
{
	sfsistat (*fi_helo) __P((SMFICTX *, char *));

	if (g == NULL)
		return _SMFIS_ABORT;
	mi_clr_macros(g->a_ctx, g->a_idx + 1);
	if (g->a_ctx->ctx_smfi != NULL &&
	    (fi_helo = g->a_ctx->ctx_smfi->xxfi_helo) != NULL)
	{
		/* paranoia: check for terminating '\0' */
		if (g->a_len == 0 || g->a_buf[g->a_len - 1] != '\0')
			return MI_FAILURE;
		return (*fi_helo)(g->a_ctx, g->a_buf);
	}
	return SMFIS_CONTINUE;
}

/*
**  ST_HEADER -- header line
**
**	Parameters:
**		g -- generic argument structure
**
**	Returns:
**		continue or filter-specified value
*/

static int
st_header(g)
	genarg *g;
{
	char *hf, *hv;
	sfsistat (*fi_header) __P((SMFICTX *, char *, char *));

	if (g == NULL)
		return _SMFIS_ABORT;
	if (g->a_ctx->ctx_smfi == NULL ||
	    (fi_header = g->a_ctx->ctx_smfi->xxfi_header) == NULL)
		return SMFIS_CONTINUE;
	if (dec_arg2(g->a_buf, g->a_len, &hf, &hv) == MI_SUCCESS)
		return (*fi_header)(g->a_ctx, hf, hv);
	else
		return _SMFIS_ABORT;
}

#define ARGV_FCT(lf, rf, idx)					\
	char **argv;						\
	sfsistat (*lf) __P((SMFICTX *, char **));		\
	int r;							\
								\
	if (g == NULL)						\
		return _SMFIS_ABORT;				\
	mi_clr_macros(g->a_ctx, g->a_idx + 1);			\
	if (g->a_ctx->ctx_smfi == NULL ||			\
	    (lf = g->a_ctx->ctx_smfi->rf) == NULL)		\
		return SMFIS_CONTINUE;				\
	if ((argv = dec_argv(g->a_buf, g->a_len)) == NULL)	\
		return _SMFIS_ABORT;				\
	r = (*lf)(g->a_ctx, argv);				\
	free(argv);						\
	return r;

/*
**  ST_SENDER -- MAIL FROM command
**
**	Parameters:
**		g -- generic argument structure
**
**	Returns:
**		continue or filter-specified value
*/

static int
st_sender(g)
	genarg *g;
{
	ARGV_FCT(fi_envfrom, xxfi_envfrom, CI_MAIL)
}

/*
**  ST_RCPT -- RCPT TO command
**
**	Parameters:
**		g -- generic argument structure
**
**	Returns:
**		continue or filter-specified value
*/

static int
st_rcpt(g)
	genarg *g;
{
	ARGV_FCT(fi_envrcpt, xxfi_envrcpt, CI_RCPT)
}

/*
**  ST_UNKNOWN -- unrecognized or unimplemented command
**
**	Parameters:
**		g -- generic argument structure
**
**	Returns:
**		continue or filter-specified value
*/

static int
st_unknown(g)
	genarg *g;
{
	sfsistat (*fi_unknown) __P((SMFICTX *, const char *));

	if (g == NULL)
		return _SMFIS_ABORT;
	if (g->a_ctx->ctx_smfi != NULL &&
	    g->a_ctx->ctx_smfi->xxfi_version > 2 &&
	    (fi_unknown = g->a_ctx->ctx_smfi->xxfi_unknown) != NULL)
		return (*fi_unknown)(g->a_ctx, (const char *) g->a_buf);
	return SMFIS_CONTINUE;
}

/*
**  ST_MACROS -- deal with macros received from the MTA
**
**	Parameters:
**		g -- generic argument structure
**
**	Returns:
**		continue/keep
**
**	Side effects:
**		set pointer in macro array to current values.
*/

static int
st_macros(g)
	genarg *g;
{
	int i;
	char **argv;

	if (g == NULL || g->a_len < 1)
		return _SMFIS_FAIL;
	if ((argv = dec_argv(g->a_buf + 1, g->a_len - 1)) == NULL)
		return _SMFIS_FAIL;
	switch (g->a_buf[0])
	{
	  case SMFIC_CONNECT:
		i = CI_CONN;
		break;
	  case SMFIC_HELO:
		i = CI_HELO;
		break;
	  case SMFIC_MAIL:
		i = CI_MAIL;
		break;
	  case SMFIC_RCPT:
		i = CI_RCPT;
		break;
	  case SMFIC_DATA:
		i = CI_DATA;
		break;
	  case SMFIC_BODYEOB:
		i = CI_EOM;
		break;
	  case SMFIC_EOH:
		i = CI_EOH;
		break;
	  default:
		free(argv);
		return _SMFIS_FAIL;
	}
	if (g->a_ctx->ctx_mac_ptr[i] != NULL)
		free(g->a_ctx->ctx_mac_ptr[i]);
	if (g->a_ctx->ctx_mac_buf[i] != NULL)
		free(g->a_ctx->ctx_mac_buf[i]);
	g->a_ctx->ctx_mac_ptr[i] = argv;
	g->a_ctx->ctx_mac_buf[i] = g->a_buf;
	return _SMFIS_KEEP;
}

/*
**  ST_QUIT -- quit command
**
**	Parameters:
**		g -- generic argument structure
**
**	Returns:
**		noreply
*/

/* ARGSUSED */
static int
st_quit(g)
	genarg *g;
{
	sfsistat (*fi_close) __P((SMFICTX *));

	if (g == NULL)
		return _SMFIS_ABORT;
	if (g->a_ctx->ctx_smfi != NULL &&
	    (fi_close = g->a_ctx->ctx_smfi->xxfi_close) != NULL)
		(void) (*fi_close)(g->a_ctx);
	mi_clr_macros(g->a_ctx, 0);
	return _SMFIS_NOREPLY;
}

/*
**  ST_BODYCHUNK -- deal with a piece of the mail body
**
**	Parameters:
**		g -- generic argument structure
**
**	Returns:
**		continue or filter-specified value
*/

static int
st_bodychunk(g)
	genarg *g;
{
	sfsistat (*fi_body) __P((SMFICTX *, unsigned char *, size_t));

	if (g == NULL)
		return _SMFIS_ABORT;
	if (g->a_ctx->ctx_smfi != NULL &&
	    (fi_body = g->a_ctx->ctx_smfi->xxfi_body) != NULL)
		return (*fi_body)(g->a_ctx, (unsigned char *)g->a_buf,
				  g->a_len);
	return SMFIS_CONTINUE;
}

/*
**  ST_BODYEND -- deal with the last piece of the mail body
**
**	Parameters:
**		g -- generic argument structure
**
**	Returns:
**		continue or filter-specified value
**
**	Side effects:
**		sends a reply for the body part (if non-empty).
*/

static int
st_bodyend(g)
	genarg *g;
{
	sfsistat r;
	sfsistat (*fi_body) __P((SMFICTX *, unsigned char *, size_t));
	sfsistat (*fi_eom) __P((SMFICTX *));

	if (g == NULL)
		return _SMFIS_ABORT;
	r = SMFIS_CONTINUE;
	if (g->a_ctx->ctx_smfi != NULL)
	{
		if ((fi_body = g->a_ctx->ctx_smfi->xxfi_body) != NULL &&
		    g->a_len > 0)
		{
			socket_t sd;
			struct timeval timeout;

			timeout.tv_sec = g->a_ctx->ctx_timeout;
			timeout.tv_usec = 0;
			sd = g->a_ctx->ctx_sd;
			r = (*fi_body)(g->a_ctx, (unsigned char *)g->a_buf,
				       g->a_len);
			if (r != SMFIS_CONTINUE &&
			    sendreply(r, sd, &timeout, g->a_ctx) != MI_SUCCESS)
				return _SMFIS_ABORT;
		}
	}
	if (r == SMFIS_CONTINUE &&
	    (fi_eom = g->a_ctx->ctx_smfi->xxfi_eom) != NULL)
		return (*fi_eom)(g->a_ctx);
	return r;
}

/*
**  ST_ABORTFCT -- deal with aborts
**
**	Parameters:
**		g -- generic argument structure
**
**	Returns:
**		abort or filter-specified value
*/

static int
st_abortfct(g)
	genarg *g;
{
	sfsistat (*fi_abort) __P((SMFICTX *));

	if (g == NULL)
		return _SMFIS_ABORT;
	if (g != NULL && g->a_ctx->ctx_smfi != NULL &&
	    (fi_abort = g->a_ctx->ctx_smfi->xxfi_abort) != NULL)
		(void) (*fi_abort)(g->a_ctx);
	return _SMFIS_NOREPLY;
}

/*
**  TRANS_OK -- is the state transition ok?
**
**	Parameters:
**		old -- old state
**		new -- new state
**
**	Returns:
**		state transition ok
*/

static bool
trans_ok(old, new)
	int old, new;
{
	int s, n;

	s = old;
	if (s >= SIZE_NEXT_STATES)
		return false;
	do
	{
		/* is this state transition allowed? */
		if ((MI_MASK(new) & next_states[s]) != 0)
			return true;

		/*
		**  no: try next state;
		**  this works since the relevant states are ordered
		**  strict sequentially
		*/

		n = s + 1;
		if (n >= SIZE_NEXT_STATES)
			return false;

		/*
		**  can we actually "skip" this state?
		**  see fix_stm() which sets this bit for those
		**  states which the filter program is not interested in
		*/

		if (bitset(NX_SKIP, next_states[n]))
			s = n;
		else
			return false;
	} while (s < SIZE_NEXT_STATES);
	return false;
}

/*
**  FIX_STM -- add "skip" bits to the state transition table
**
**	Parameters:
**		ctx -- context structure
**
**	Returns:
**		None.
**
**	Side effects:
**		may change state transition table.
*/

static void
fix_stm(ctx)
	SMFICTX_PTR ctx;
{
	unsigned long fl;

	if (ctx == NULL || ctx->ctx_smfi == NULL)
		return;
	fl = ctx->ctx_pflags;
	if (bitset(SMFIP_NOCONNECT, fl))
		next_states[ST_CONN] |= NX_SKIP;
	if (bitset(SMFIP_NOHELO, fl))
		next_states[ST_HELO] |= NX_SKIP;
	if (bitset(SMFIP_NOMAIL, fl))
		next_states[ST_MAIL] |= NX_SKIP;
	if (bitset(SMFIP_NORCPT, fl))
		next_states[ST_RCPT] |= NX_SKIP;
	if (bitset(SMFIP_NOHDRS, fl))
		next_states[ST_HDRS] |= NX_SKIP;
	if (bitset(SMFIP_NOEOH, fl))
		next_states[ST_EOHS] |= NX_SKIP;
	if (bitset(SMFIP_NOBODY, fl))
		next_states[ST_BODY] |= NX_SKIP;
	if (bitset(SMFIP_NODATA, fl))
		next_states[ST_DATA] |= NX_SKIP;
	if (bitset(SMFIP_NOUNKNOWN, fl))
		next_states[ST_UNKN] |= NX_SKIP;
}

/*
**  DEC_ARGV -- split a buffer into a list of strings, NULL terminated
**
**	Parameters:
**		buf -- buffer with several strings
**		len -- length of buffer
**
**	Returns:
**		array of pointers to the individual strings
*/

static char **
dec_argv(buf, len)
	char *buf;
	size_t len;
{
	char **s;
	size_t i;
	int elem, nelem;

	nelem = 0;
	for (i = 0; i < len; i++)
	{
		if (buf[i] == '\0')
			++nelem;
	}
	if (nelem == 0)
		return NULL;

	/* last entry is only for the name */
	s = (char **)malloc((nelem + 1) * (sizeof *s));
	if (s == NULL)
		return NULL;
	s[0] = buf;
	for (i = 0, elem = 0; i < len && elem < nelem; i++)
	{
		if (buf[i] == '\0')
		{
			++elem;
			if (i + 1 >= len)
				s[elem] = NULL;
			else
				s[elem] = &(buf[i + 1]);
		}
	}

	/* overwrite last entry (already done above, just paranoia) */
	s[elem] = NULL;
	return s;
}

/*
**  DEC_ARG2 -- split a buffer into two strings
**
**	Parameters:
**		buf -- buffer with two strings
**		len -- length of buffer
**		s1,s2 -- pointer to result strings
**
**	Returns:
**		MI_FAILURE/MI_SUCCESS
*/

static int
dec_arg2(buf, len, s1, s2)
	char *buf;
	size_t len;
	char **s1;
	char **s2;
{
	size_t i;

	/* paranoia: check for terminating '\0' */
	if (len == 0 || buf[len - 1] != '\0')
		return MI_FAILURE;
	*s1 = buf;
	for (i = 1; i < len && buf[i] != '\0'; i++)
		continue;
	if (i >= len - 1)
		return MI_FAILURE;
	*s2 = buf + i + 1;
	return MI_SUCCESS;
}

/*
**  SENDOK -- is it ok for the filter to send stuff to the MTA?
**
**	Parameters:
**		ctx -- context structure
**		flag -- flag to check
**
**	Returns:
**		sending allowed (in current state)
*/

bool
mi_sendok(ctx, flag)
	SMFICTX_PTR ctx;
	int flag;
{
	if (ctx == NULL || ctx->ctx_smfi == NULL)
		return false;

	/* did the milter request this operation? */
	if (flag != 0 && !bitset(flag, ctx->ctx_aflags))
		return false;

	/* are we in the correct state? It must be "End of Message". */
	return ctx->ctx_state == ST_ENDM;
}

#if _FFR_WORKERS_POOL
/*
**  MI_RD_SOCKET_READY - checks if the socket is ready for read(2)
**
**	Parameters:
**		sd -- socket_t
**
**	Returns:
**		true iff socket is ready for read(2)
*/

#define MI_RD_CMD_TO  1
#define MI_RD_MAX_ERR 16

static bool
mi_rd_socket_ready (sd)
	socket_t sd;
{
	int n;
	int nerr = 0;
#if SM_CONF_POLL
	struct pollfd pfd;
#else /* SM_CONF_POLL */
	fd_set	rd_set, exc_set;
#endif /* SM_CONF_POLL */

	do
	{
#if SM_CONF_POLL
		pfd.fd = sd;
		pfd.events = POLLIN;
		pfd.revents = 0;

		n = poll(&pfd, 1, MI_RD_CMD_TO);
#else /* SM_CONF_POLL */
		struct timeval timeout;

		FD_ZERO(&rd_set);
		FD_ZERO(&exc_set);
		FD_SET(sd, &rd_set);
		FD_SET(sd, &exc_set);

		timeout.tv_sec = MI_RD_CMD_TO / 1000;
		timeout.tv_usec = 0;
		n = select(sd + 1, &rd_set, NULL, &exc_set, &timeout);
#endif /* SM_CONF_POLL */

		if (n < 0)
		{
			if (errno == EINTR)
			{
				nerr++;
				continue;
			}
			return true;
		}

		if (n == 0)
			return false;
		break;
	} while (nerr < MI_RD_MAX_ERR);
	if (nerr >= MI_RD_MAX_ERR)
		return false;

#if SM_CONF_POLL
	return (pfd.revents != 0);
#else /* SM_CONF_POLL */
	return FD_ISSET(sd, &rd_set) || FD_ISSET(sd, &exc_set);
#endif /* SM_CONF_POLL */
}
#endif /* _FFR_WORKERS_POOL */
@


1.20
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.19
log
@Update to sendmail 8.14.5
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2004, 2006-2008 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: engine.c,v 8.167 2011/03/03 06:09:15 ca Exp $")
@


1.18
log
@Update to sendmail-8.14.3
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: engine.c,v 8.162 2008/02/27 01:34:14 ca Exp $")
d116 1
d287 1
a287 1
				sm_dprintf("[%ld] milter_abort\n",
d318 1
a318 1
				sm_dprintf("[%ld] mi_engine: mi_rd_cmd error (%x)\n",
d331 1
a331 1
			sm_dprintf("[%ld] got cmd '%c' len %d\n",
d342 1
a342 1
				sm_dprintf("[%ld] cmd '%c' unknown\n",
d351 1
a351 1
				sm_dprintf("[%ld] cmd '%c' not impl\n",
d360 1
a360 1
			sm_dprintf("[%ld] cur %x new %x nextmask %x\n",
d367 1
a367 1
				sm_dprintf("[%ld] abort: cur %d (%x) new %d (%x) next %x\n",
d437 1
a437 1
				sm_dprintf("[%ld] function returned abort\n",
d762 63
d838 1
a838 1
	mi_int32 i, v, fake_pflags;
d840 3
d896 1
d904 45
a948 1
	ctx->ctx_mta_pflags = v;	/* MTA protocol flags */
d995 6
d1125 1
a1125 1
		sm_dprintf("[%ld] milter_negotiate:"
d1132 19
@


1.17
log
@Update to sendmail-8.14.1
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2004, 2006 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: engine.c,v 8.157 2007/03/26 18:10:04 ca Exp $")
d858 1
d1004 1
d1182 1
d1316 1
d1729 1
a1729 1
		struct pollfd pfd;
d1731 1
a1731 1
		fd_set	rd_set, exc_set;
@


1.16
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: engine.c,v 8.155 2006/12/19 22:18:55 ca Exp $")
d737 1
d1194 1
d1214 1
a1311 1
	mi_clr_macros(g->a_ctx, g->a_idx + 1);
d1377 1
d1403 1
d1428 1
d1476 1
d1500 1
d1550 1
d1643 1
d1676 1
@


1.15
log
@Update to sendmail-8.13.8
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: engine.c,v 8.121 2006/04/18 21:01:46 ca Exp $")
d59 1
a59 1
#define	CT_END		0x0008	/* start replying */
d67 27
a93 3
#define CI_EOM		4
#if CI_EOM >= MAX_MACROS_ENTRIES
ERROR: do not compile with CI_EOM >= MAX_MACROS_ENTRIES
a106 1
#if SMFI_VERSION > 2
a107 2
#endif /* SMFI_VERSION > 2 */
#if SMFI_VERSION > 3
a108 1
#endif /* SMFI_VERSION > 3 */
d117 4
d137 3
a139 2
#define ST_LAST	ST_UNKN	/* last valid state */
#define ST_SKIP	15	/* not a state but required for the state table */
d166 2
a167 1
#define NX_ENDM	(MI_MASK(ST_QUIT) | MI_MASK(ST_MAIL) | MI_MASK(ST_UNKN))
d174 2
a175 1
		 MI_MASK(ST_ABRT) | MI_MASK(ST_QUIT))
d180 15
a194 14
	NX_INIT,
	NX_OPTS,
	NX_CONN,
	NX_HELO,
	NX_MAIL,
	NX_RCPT,
	NX_DATA,
	NX_HDRS,
	NX_EOHS,
	NX_BODY,
	NX_ENDM,
	NX_QUIT,
	NX_ABRT,
	NX_UNKN
d202 15
a216 18
{SMFIC_ABORT,	CM_ARG0, ST_ABRT,  CT_CONT,	CI_NONE, st_abortfct	},
{SMFIC_MACRO,	CM_ARGV, ST_NONE,  CT_KEEP,	CI_NONE, st_macros	},
{SMFIC_BODY,	CM_ARG1, ST_BODY,  CT_CONT,	CI_NONE, st_bodychunk	},
{SMFIC_CONNECT,	CM_ARG2, ST_CONN,  CT_CONT,	CI_CONN, st_connectinfo	},
{SMFIC_BODYEOB,	CM_ARG1, ST_ENDM,  CT_CONT,	CI_EOM,  st_bodyend	},
{SMFIC_HELO,	CM_ARG1, ST_HELO,  CT_CONT,	CI_HELO, st_helo	},
{SMFIC_HEADER,	CM_ARG2, ST_HDRS,  CT_CONT,	CI_NONE, st_header	},
{SMFIC_MAIL,	CM_ARGV, ST_MAIL,  CT_CONT,	CI_MAIL, st_sender	},
{SMFIC_OPTNEG,	CM_ARGO, ST_OPTS,  CT_CONT,	CI_NONE, st_optionneg	},
{SMFIC_EOH,	CM_ARG0, ST_EOHS,  CT_CONT,	CI_NONE, st_eoh		},
{SMFIC_QUIT,	CM_ARG0, ST_QUIT,  CT_END,	CI_NONE, st_quit	},
#if SMFI_VERSION > 3
{SMFIC_DATA,	CM_ARG0, ST_DATA,  CT_CONT,	CI_NONE, st_data	},
#endif /* SMFI_VERSION > 3 */
{SMFIC_RCPT,	CM_ARGV, ST_RCPT,  CT_IGNO,	CI_RCPT, st_rcpt	}
#if SMFI_VERSION > 2
,{SMFIC_UNKNOWN,CM_ARG1, ST_UNKN,  CT_IGNO,	CI_NONE, st_unknown	}
#endif /* SMFI_VERSION > 2 */
d219 5
a223 1
/* additional (internal) reply codes */
d227 1
a227 1
#define _SMFIS_NOREPLY	23
d240 1
d265 8
d275 1
d286 2
a287 2
				sm_dprintf("[%d] milter_abort\n",
					(int) ctx->ctx_id);
d302 9
d317 2
a318 2
				sm_dprintf("[%d] mi_engine: mi_rd_cmd error (%x)\n",
					(int) ctx->ctx_id, (int) cmd);
d330 2
a331 2
			sm_dprintf("[%d] got cmd '%c' len %d\n",
				(int) ctx->ctx_id, cmd, (int) len);
d341 2
a342 2
				sm_dprintf("[%d] cmd '%c' unknown\n",
					(int) ctx->ctx_id, cmd);
d350 2
a351 2
				sm_dprintf("[%d] cmd '%c' not impl\n",
					(int) ctx->ctx_id, cmd);
d359 2
a360 2
			sm_dprintf("[%d] cur %x new %x nextmask %x\n",
				(int) ctx->ctx_id,
d366 2
a367 2
				sm_dprintf("[%d] abort: cur %d (%x) new %d (%x) next %x\n",
					(int) ctx->ctx_id,
d403 1
d405 1
d436 2
a437 2
				sm_dprintf("[%d] function returned abort\n",
					(int) ctx->ctx_id);
d443 3
a445 1
	if (ret != MI_SUCCESS)
d452 10
a461 3
	/* close must always be called */
	if ((fi_close = ctx->ctx_smfi->xxfi_close) != NULL)
		(void) (*fi_close)(ctx);
d464 1
d466 1
d469 125
d614 36
a649 1
	int ret = MI_SUCCESS;
d680 3
d685 3
a688 1
			mi_int32 v;
d690 4
a693 3
			v = htonl(ctx->ctx_smfi->xxfi_version);
			(void) memcpy(&(buf[0]), (void *) &v, MILTER_LEN_BYTES);
			v = htonl(ctx->ctx_smfi->xxfi_flags);
d696 23
a718 5
			v = htonl(ctx->ctx_pflags);
			(void) memcpy(&(buf[MILTER_LEN_BYTES * 2]), (void *) &v,
				      MILTER_LEN_BYTES);
			ret = mi_wr_cmd(sd, timeout_ptr, SMFIC_OPTNEG, buf,
				       MILTER_OPTLEN);
d758 1
d773 7
a779 1
	mi_int32 i, v;
d783 3
a785 1
	mi_clr_macros(g->a_ctx, g->a_idx + 1);
d791 3
a793 3
			"%s: st_optionneg[%d]: len too short %d < %d",
			g->a_ctx->ctx_smfi->xxfi_name,
			(int) g->a_ctx->ctx_id, (int) g->a_len,
d798 2
a799 2
	(void) memcpy((void *) &i, (void *) &(g->a_buf[0]),
		      MILTER_LEN_BYTES);
d801 5
a805 1
	if (v < g->a_ctx->ctx_smfi->xxfi_version)
a806 1
		/* hard failure for now! */
d808 3
a810 4
			"%s: st_optionneg[%d]: version mismatch MTA: %d < milter: %d",
			g->a_ctx->ctx_smfi->xxfi_name,
			(int) g->a_ctx->ctx_id, (int) v,
			g->a_ctx->ctx_smfi->xxfi_version);
d813 5
d826 1
a826 9
	i = g->a_ctx->ctx_smfi->xxfi_flags;
	if ((v & i) != i)
	{
		smi_log(SMI_LOG_ERR,
			"%s: st_optionneg[%d]: 0x%x does not fulfill action requirements 0x%x",
			g->a_ctx->ctx_smfi->xxfi_name,
			(int) g->a_ctx->ctx_id, v, i);
		return _SMFIS_ABORT;
	}
d835 131
a965 2
	i = g->a_ctx->ctx_pflags;
	if ((v & i) != i)
d968 3
a970 3
			"%s: st_optionneg[%d]: 0x%x does not fulfill protocol requirements 0x%x",
			g->a_ctx->ctx_smfi->xxfi_name,
			(int) g->a_ctx->ctx_id, v, i);
d974 37
d1013 1
d1059 1
a1059 1
				"%s: connect[%d]: wrong len %d >= %d",
d1061 1
a1061 1
				(int) g->a_ctx->ctx_id, (int) i, (int) l);
d1078 1
a1078 1
					"%s: connect[%d]: inet_aton failed",
d1080 1
a1080 1
					(int) g->a_ctx->ctx_id);
d1096 1
a1096 1
					"%s: connect[%d]: mi_inet_pton failed",
d1098 1
a1098 1
					(int) g->a_ctx->ctx_id);
d1115 1
a1115 1
					"%s: connect[%d]: path too long",
d1117 1
a1117 1
					(int) g->a_ctx->ctx_id);
d1126 1
a1126 1
				"%s: connect[%d]: unknown family %d",
d1128 1
a1128 1
				(int) g->a_ctx->ctx_id, family);
a1159 1
#if SMFI_VERSION > 3
a1182 1
#endif /* SMFI_VERSION > 3 */
d1273 1
a1290 1
#if SMFI_VERSION > 2
d1305 1
a1305 1
	sfsistat (*fi_unknown) __P((SMFICTX *, char *));
d1312 1
a1312 1
		return (*fi_unknown)(g->a_ctx, g->a_buf);
a1314 1
#endif /* SMFI_VERSION > 2 */
d1354 3
d1360 3
d1390 8
d1579 4
d1584 1
d1687 1
a1687 1
	if (flag != 0 && !bitset(flag, ctx->ctx_smfi->xxfi_flags))
d1693 72
@


1.14
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2003 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: engine.c,v 8.120 2004/10/20 21:09:00 ca Exp $")
d169 2
d1081 2
d1096 2
d1109 1
a1109 1
	} while (s <= ST_LAST);
@


1.13
log
@Update to sendmail.8.13.0
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: engine.c,v 8.119 2003/12/02 18:53:57 ca Exp $")
d350 1
a364 1
		call_abort = ST_IN_MAIL(curstate);
@


1.12
log
@Update to sendmail 8.12.11.  I've been runninga beta version of this for
some time without problems.  See the RELEASE_NOTES for the change log.
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: engine.c,v 8.109.2.8 2003/12/01 23:57:45 msk Exp $")
d67 2
a68 3
#if _FFR_MILTER_MACROS_EOM
# define CI_EOM		4
# if CI_EOM >= MAX_MACROS_ENTRIES
d70 1
a70 6
# endif
#else /* _FFR_MILTER_MACROS_EOM */
# if CI_RCPT >= MAX_MACROS_ENTRIES
ERROR: do not compile with CI_RCPT >= MAX_MACROS_ENTRIES
# endif
#endif /* _FFR_MILTER_MACROS_EOM */
d83 6
d105 9
a113 7
#define ST_HDRS	6	/* headers */
#define ST_EOHS	7	/* end of headers */
#define ST_BODY	8	/* body */
#define ST_ENDM	9	/* end of message */
#define ST_QUIT	10	/* quit */
#define ST_ABRT	11	/* abort */
#define ST_LAST	ST_ABRT
d130 5
a134 5
#define NX_OPTS	(MI_MASK(ST_CONN))
#define NX_CONN	(MI_MASK(ST_HELO) | MI_MASK(ST_MAIL))
#define NX_HELO	(MI_MASK(ST_HELO) | MI_MASK(ST_MAIL))
#define NX_MAIL	(MI_MASK(ST_RCPT) | MI_MASK(ST_ABRT))
#define NX_RCPT	(MI_MASK(ST_HDRS) | MI_MASK(ST_EOHS) | \
d136 2
a137 1
		 MI_MASK(ST_RCPT) | MI_MASK(ST_ABRT))
d141 1
a141 1
#define NX_ENDM	(MI_MASK(ST_QUIT) | MI_MASK(ST_MAIL))
d144 5
d159 1
d165 2
a166 1
	NX_ABRT
a175 1
#if _FFR_MILTER_MACROS_EOM
a176 3
#else /* _FFR_MILTER_MACROS_EOM */
{SMFIC_BODYEOB,	CM_ARG1, ST_ENDM,  CT_CONT,	CI_NONE, st_bodyend	},
#endif /* _FFR_MILTER_MACROS_EOM */
d183 3
d187 3
d713 1
d737 27
d869 28
a934 1
#if _FFR_MILTER_MACROS_EOM
a937 1
#endif /* _FFR_MILTER_MACROS_EOM */
@


1.11
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2002 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: engine.c,v 8.109.2.5 2003/08/04 18:14:33 ca Exp $")
d62 12
a73 6
#define	CI_NONE	(-1)
#define	CI_CONN	0
#define	CI_HELO	1
#define	CI_MAIL	2
#define	CI_RCPT	3
#if CI_RCPT >= MAX_MACROS_ENTRIES
d75 2
a76 1
#endif
d166 3
d170 1
d613 1
a613 1
	if (i >= l)
d622 1
a622 3
		(void) memcpy((void *) &port, (void *) (s + i),
			      sizeof port);
		if ((i += sizeof port) >= l)
d630 3
d744 4
d749 1
d867 5
d1114 7
a1120 1
			s[++elem] = &(buf[i + 1]);
d1123 1
a1123 1
	/* overwrite last entry */
d1148 3
@


1.10
log
@update to sendmail 8.12.7
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: engine.c,v 8.109.2.4 2002/12/03 17:27:32 ca Exp $")
d608 1
a608 1
	memset(&sockaddr, '\0', sizeof sockaddr);
d872 1
@


1.9
log
@update to sendmail-8.12.6
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: engine.c,v 8.109.2.1 2002/07/29 16:40:47 ca Exp $")
d119 13
a131 13
#define MASK(x)	(0x0001 << (x))	/* generate a bit "mask" for a state */
#define NX_INIT	(MASK(ST_OPTS))
#define NX_OPTS	(MASK(ST_CONN))
#define NX_CONN	(MASK(ST_HELO) | MASK(ST_MAIL))
#define NX_HELO	(MASK(ST_HELO) | MASK(ST_MAIL))
#define NX_MAIL	(MASK(ST_RCPT) | MASK(ST_ABRT))
#define NX_RCPT	(MASK(ST_HDRS) | MASK(ST_EOHS) | \
		 MASK(ST_BODY) | MASK(ST_ENDM) | \
		 MASK(ST_RCPT) | MASK(ST_ABRT))
#define NX_HDRS	(MASK(ST_EOHS) | MASK(ST_HDRS) | MASK(ST_ABRT))
#define NX_EOHS	(MASK(ST_BODY) | MASK(ST_ENDM) | MASK(ST_ABRT))
#define NX_BODY	(MASK(ST_ENDM) | MASK(ST_BODY) | MASK(ST_ABRT))
#define NX_ENDM	(MASK(ST_QUIT) | MASK(ST_MAIL))
d134 1
a134 1
#define NX_SKIP MASK(ST_SKIP)
d258 1
a258 1
				(int) ctx->ctx_id, cmd, len);
d295 2
a296 2
					curstate, MASK(curstate),
					newstate, MASK(newstate),
d514 1
a514 1
			(int) g->a_ctx->ctx_id, g->a_len,
d618 1
a618 1
				(int) g->a_ctx->ctx_id, i, l);
d993 1
a993 1
		if ((MASK(new) & next_states[s]) != 0)
@


1.8
log
@update to sendmail 8.12.3
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: engine.c,v 8.109 2002/03/13 17:18:44 gshapiro Exp $")
d311 5
a315 2
				free(buf);
				buf = NULL;
@


1.7
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: engine.c,v 8.102 2001/12/13 17:10:00 ca Exp $")
d409 3
a411 1
		if (ctx->ctx_reply != NULL)
a609 1
		port = ntohs(port);
d618 4
d626 1
a626 1
			    == INADDR_NONE)
@


1.6
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: engine.c,v 8.97 2001/09/11 04:04:44 gshapiro Exp $")
d175 1
d212 1
d227 12
d310 3
d314 1
d375 1
a375 1
	if (buf != NULL)
d1137 2
d1141 2
@


1.5
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: engine.c,v 8.94 2001/08/14 12:49:45 ca Exp $")
d176 1
a176 1
/*
d362 1
a362 1
/*
d465 1
a465 1
/*
d546 1
a546 1
/*
d663 1
a663 1
/*
d686 1
a686 1
/*
d709 1
a709 1
/*
d754 1
a754 1
/*
d770 1
a770 1
/*
d786 1
a786 1
/*
d836 1
a836 1
/*
d852 1
a852 1
/*
d876 1
a876 1
/*
d923 1
a923 1
/*
d946 1
a946 1
/*
d991 1
a991 1
/*
d1028 1
a1028 1
/*
d1072 1
a1072 1
/*
d1101 1
a1101 1
/*
@


1.4
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d11 2
a12 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: engine.c,v 8.67.4.17 2001/01/22 19:00:16 gshapiro Exp $";
#endif /* ! lint */
a13 1
#if _FFR_MILTER
a14 1
#include "sendmail/useful.h"
d118 1
d125 3
a127 1
#define NX_RCPT	(MASK(ST_HDRS) | MASK(ST_EOHS) | MASK(ST_RCPT) | MASK(ST_ABRT))
d220 1
a220 1
				dprintf("[%d] milter_abort\n",
d230 1
a230 1
				dprintf("[%d] mi_engine: mi_rd_cmd error (%x)\n",
d243 1
a243 1
			dprintf("[%d] got cmd '%c' len %d\n",
d254 1
a254 1
				dprintf("[%d] cmd '%c' unknown\n",
d263 1
a263 1
				dprintf("[%d] cmd '%c' not impl\n",
d272 1
a272 1
			dprintf("[%d] cur %x new %x nextmask %x\n",
d279 1
a279 1
				dprintf("[%d] abort: cur %d (%x) new %d (%x) next %x\n",
d340 1
a340 1
				dprintf("[%d] function returned abort\n",
d563 1
a563 1
	u_short port = 0;
d620 2
a621 2
			if (inet_pton(AF_INET6, s + i,
				      &sockaddr.sin6.sin6_addr) != 1)
d624 1
a624 1
					"%s: connect[%d]: inet_pton failed",
d638 1
a638 1
			if (strlcpy(sockaddr.sunix.sun_path, s + i,
d737 11
a747 11
#define ARGV_FCT(lf, rf, idx) \
	char **argv;	\
	sfsistat (*lf) __P((SMFICTX *, char **));	\
	int r;	\
	\
	if (g == NULL)	\
		return _SMFIS_ABORT;	\
	mi_clr_macros(g->a_ctx, g->a_idx + 1);	\
	if (g->a_ctx->ctx_smfi == NULL ||	\
	    (lf = g->a_ctx->ctx_smfi->rf) == NULL)	\
		return SMFIS_CONTINUE;	\
d749 3
a751 3
		return _SMFIS_ABORT;	\
	r = (*lf)(g->a_ctx, argv);	\
	free(argv);	\
d866 1
a866 1
	sfsistat (*fi_body) __P((SMFICTX *, u_char *, size_t));
d872 2
a873 1
		return (*fi_body)(g->a_ctx, (u_char *)g->a_buf, g->a_len);
d894 1
a894 1
	sfsistat (*fi_body) __P((SMFICTX *, u_char *, size_t));
d911 2
a912 1
			r = (*fi_body)(g->a_ctx, (u_char *)g->a_buf, g->a_len);
d968 1
a968 1
			return TRUE;
d975 1
d983 1
d987 1
a987 1
			return FALSE;
d989 1
a989 1
	return FALSE;
d1008 1
a1008 1
	u_long fl;
d1118 1
a1118 1
		return FALSE;
d1120 1
a1120 1
		return FALSE;
a1122 1
#endif /* _FFR_MILTER */
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2000 Sendmail, Inc. and its suppliers.
d12 1
a12 1
static char id[] = "@@(#)$Sendmail: engine.c,v 8.67.4.15 2000/12/29 19:43:10 gshapiro Exp $";
d125 1
a125 1
#define NX_HELO	(MASK(ST_MAIL))
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: engine.c,v 8.67 2000/03/27 05:04:16 ca Exp $";
a22 3
/* length of options: two 32bit integers */
#define MILTER_OPTLEN	8

d87 1
a87 1
static int	sendreply __P((sfsistat, int, struct timeval *, SMFICTX_PTR));
d110 3
d190 2
a191 1
	int i, fd;
d196 1
d204 1
d207 1
a207 1
	fd = ctx->ctx_fd;
d211 4
a214 1
	do {
d225 1
a225 1
		if ((buf = mi_rd_cmd(fd, &timeout, &cmd, &len,
d230 1
a230 1
				dprintf("[%d] error (%x)\n",
d284 3
a286 1
			if (fi_abort != NULL)
d314 1
a314 1
		if (sendreply(r, fd, &timeout, ctx) != MI_SUCCESS)
d320 1
d349 2
a350 1
		if (fi_abort != NULL)
a352 3
	else
	{
		sfsistat (*fi_close) __P((SMFICTX *));
d354 3
a356 3
		if ((fi_close = ctx->ctx_smfi->xxfi_close) != NULL)
			(void) (*fi_close)(ctx);
	}
d367 1
a367 1
**		fd -- file descriptor
d376 1
a376 1
sendreply(r, fd, timeout_ptr, ctx)
d378 1
a378 1
	int fd;
d384 1
a384 1
	switch(r)
d387 1
a387 1
		ret = mi_wr_cmd(fd, timeout_ptr, SMFIR_CONTINUE, NULL, 0);
d393 1
a393 1
			ret = mi_wr_cmd(fd, timeout_ptr, SMFIR_REPLYCODE,
d401 1
a401 1
			ret = mi_wr_cmd(fd, timeout_ptr, r == SMFIS_REJECT ?
d406 1
a406 1
		ret = mi_wr_cmd(fd, timeout_ptr, SMFIR_DISCARD, NULL, 0);
d409 1
a409 1
		ret = mi_wr_cmd(fd, timeout_ptr, SMFIR_ACCEPT, NULL, 0);
d421 4
a424 1
			ret = mi_wr_cmd(fd, timeout_ptr, SMFIC_OPTNEG, buf,
d479 1
a479 1
	mi_int32 i, version;
d484 3
a486 1
	if (g->a_len != MILTER_OPTLEN)
d489 1
a489 1
			"%s: st_optionneg[%d]: len mismatch %d != %d",
d498 2
a499 2
	version = ntohl(i);
	if (version != g->a_ctx->ctx_smfi->xxfi_version)
d501 1
d503 1
a503 1
			"%s: st_optionneg[%d]: version mismatch %d != %d",
d505 1
a505 1
			(int) g->a_ctx->ctx_id, (int) version,
a509 2
#if 0
	/* flags are currently ignored */
d512 31
a542 2
	flags = ntohl(i);
#endif /* 0 */
d561 1
a561 1
	int i;
d563 1
a563 1
	u_short port;
d612 2
d630 2
d810 1
a810 1
	switch(g->a_buf[0])
d904 1
a904 1
			int fd;
d909 1
a909 1
			fd = g->a_ctx->ctx_fd;
d912 1
a912 1
			    sendreply(r, fd, &timeout, g->a_ctx) != MI_SUCCESS)
d962 2
a963 1
	do {
d1008 2
a1009 2
	fl = ctx->ctx_smfi->xxfi_flags;
	if (bitset(SMFIF_NOCONNECT, fl))
d1011 1
a1011 1
	if (bitset(SMFIF_NOHELO, fl))
d1013 1
a1013 1
	if (bitset(SMFIF_NOMAIL, fl))
d1015 1
a1015 1
	if (bitset(SMFIF_NORCPT, fl))
d1017 1
a1017 2
	if (bitset(SMFIF_NOHDRS, fl))
	{
d1019 1
d1021 1
a1021 2
	}
	if (bitset(SMFIF_NOBODY, fl))
d1066 1
a1066 1
	return (s);
d1087 1
a1087 1
	int i;
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d12 1
a12 1
static char id[] = "@@(#)$Sendmail: engine.c,v 8.67.4.17 2001/01/22 19:00:16 gshapiro Exp $";
d23 3
d90 1
a90 1
static int	sendreply __P((sfsistat, socket_t, struct timeval *, SMFICTX_PTR));
a112 3
/* in a mail transaction? must be before eom according to spec. */
#define ST_IN_MAIL(st)	((st) >= ST_MAIL && (st) < ST_ENDM)

d125 1
a125 1
#define NX_HELO	(MASK(ST_HELO) | MASK(ST_MAIL))
d190 1
a190 2
	int i;
	socket_t sd;
a194 1
	bool call_abort;
a201 1
	sfsistat (*fi_close) __P((SMFICTX *));
d204 1
a204 1
	sd = ctx->ctx_sd;
d208 1
a208 4
	do
	{
		/* call abort only if in a mail transaction */
		call_abort = ST_IN_MAIL(curstate);
d219 1
a219 1
		if ((buf = mi_rd_cmd(sd, &timeout, &cmd, &len,
d224 1
a224 1
				dprintf("[%d] mi_engine: mi_rd_cmd error (%x)\n",
d278 1
a278 3

			/* call abort only if in a mail transaction */
			if (fi_abort != NULL && call_abort)
d306 1
a306 1
		if (sendreply(r, sd, &timeout, ctx) != MI_SUCCESS)
a311 1
		call_abort = ST_IN_MAIL(curstate);
d340 1
a340 2
		/* call abort only if in a mail transaction */
		if (fi_abort != NULL && call_abort)
d343 3
d347 3
a349 3
	/* close must always be called */
	if ((fi_close = ctx->ctx_smfi->xxfi_close) != NULL)
		(void) (*fi_close)(ctx);
d360 1
a360 1
**		sd -- socket descriptor
d369 1
a369 1
sendreply(r, sd, timeout_ptr, ctx)
d371 1
a371 1
	socket_t sd;
d377 1
a377 1
	switch (r)
d380 1
a380 1
		ret = mi_wr_cmd(sd, timeout_ptr, SMFIR_CONTINUE, NULL, 0);
d386 1
a386 1
			ret = mi_wr_cmd(sd, timeout_ptr, SMFIR_REPLYCODE,
d394 1
a394 1
			ret = mi_wr_cmd(sd, timeout_ptr, r == SMFIS_REJECT ?
d399 1
a399 1
		ret = mi_wr_cmd(sd, timeout_ptr, SMFIR_DISCARD, NULL, 0);
d402 1
a402 1
		ret = mi_wr_cmd(sd, timeout_ptr, SMFIR_ACCEPT, NULL, 0);
d414 1
a414 4
			v = htonl(ctx->ctx_pflags);
			(void) memcpy(&(buf[MILTER_LEN_BYTES * 2]), (void *) &v,
				      MILTER_LEN_BYTES);
			ret = mi_wr_cmd(sd, timeout_ptr, SMFIC_OPTNEG, buf,
d469 1
a469 1
	mi_int32 i, v;
d474 1
a474 3

	/* check for minimum length */
	if (g->a_len < MILTER_OPTLEN)
d477 1
a477 1
			"%s: st_optionneg[%d]: len too short %d < %d",
d486 2
a487 2
	v = ntohl(i);
	if (v < g->a_ctx->ctx_smfi->xxfi_version)
a488 1
		/* hard failure for now! */
d490 1
a490 1
			"%s: st_optionneg[%d]: version mismatch MTA: %d < milter: %d",
d492 1
a492 1
			(int) g->a_ctx->ctx_id, (int) v,
d497 2
d501 2
a502 31
	v = ntohl(i);

	/* no flags? set to default value for V1 actions */
	if (v == 0)
		v = SMFI_V1_ACTS;
	i = g->a_ctx->ctx_smfi->xxfi_flags;
	if ((v & i) != i)
	{
		smi_log(SMI_LOG_ERR,
			"%s: st_optionneg[%d]: 0x%x does not fulfill action requirements 0x%x",
			g->a_ctx->ctx_smfi->xxfi_name,
			(int) g->a_ctx->ctx_id, v, i);
		return _SMFIS_ABORT;
	}

	(void) memcpy((void *) &i, (void *) &(g->a_buf[MILTER_LEN_BYTES * 2]),
		      MILTER_LEN_BYTES);
	v = ntohl(i);

	/* no flags? set to default value for V1 protocol */
	if (v == 0)
		v = SMFI_V1_PROT;
	i = g->a_ctx->ctx_pflags;
	if ((v & i) != i)
	{
		smi_log(SMI_LOG_ERR,
			"%s: st_optionneg[%d]: 0x%x does not fulfill protocol requirements 0x%x",
			g->a_ctx->ctx_smfi->xxfi_name,
			(int) g->a_ctx->ctx_id, v, i);
		return _SMFIS_ABORT;
	}
d521 1
a521 1
	size_t i;
d523 1
a523 1
	u_short port = 0;
a571 2
			if (port > 0)
				sockaddr.sin.sin_port = port;
a587 2
			if (port > 0)
				sockaddr.sin6.sin6_port = port;
d766 1
a766 1
	switch (g->a_buf[0])
d860 1
a860 1
			socket_t sd;
d865 1
a865 1
			sd = g->a_ctx->ctx_sd;
d868 1
a868 1
			    sendreply(r, sd, &timeout, g->a_ctx) != MI_SUCCESS)
d918 1
a918 2
	do
	{
d963 2
a964 2
	fl = ctx->ctx_pflags;
	if (bitset(SMFIP_NOCONNECT, fl))
d966 1
a966 1
	if (bitset(SMFIP_NOHELO, fl))
d968 1
a968 1
	if (bitset(SMFIP_NOMAIL, fl))
d970 1
a970 1
	if (bitset(SMFIP_NORCPT, fl))
d972 2
a973 1
	if (bitset(SMFIP_NOHDRS, fl))
a974 1
	if (bitset(SMFIP_NOEOH, fl))
d976 2
a977 1
	if (bitset(SMFIP_NOBODY, fl))
d1022 1
a1022 1
	return s;
d1043 1
a1043 1
	size_t i;
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: engine.c,v 8.65 2000/02/17 17:52:14 ca Exp $";
d387 2
a388 1
					ctx->ctx_reply, strlen(ctx->ctx_reply));
d541 4
a544 1
	family = s[++i];
d551 1
a551 1
		if ((i += 2) >= l)
d562 1
a562 1
			if (inet_aton(s + i, (struct in_addr *) &sockaddr)
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Id: engine.c,v 8.67.4.15 2000/12/29 19:43:10 gshapiro Exp $";
d23 3
d90 1
a90 1
static int	sendreply __P((sfsistat, socket_t, struct timeval *, SMFICTX_PTR));
a112 3
/* in a mail transaction? must be before eom according to spec. */
#define ST_IN_MAIL(st)	((st) >= ST_MAIL && (st) < ST_ENDM)

d190 1
a190 2
	int i;
	socket_t sd;
a194 1
	bool call_abort;
a201 1
	sfsistat (*fi_close) __P((SMFICTX *));
d204 1
a204 1
	sd = ctx->ctx_sd;
d208 1
a208 4
	do
	{
		/* call abort only if in a mail transaction */
		call_abort = ST_IN_MAIL(curstate);
d219 1
a219 1
		if ((buf = mi_rd_cmd(sd, &timeout, &cmd, &len,
d224 1
a224 1
				dprintf("[%d] mi_engine: mi_rd_cmd error (%x)\n",
d278 1
a278 3

			/* call abort only if in a mail transaction */
			if (fi_abort != NULL && call_abort)
d306 1
a306 1
		if (sendreply(r, sd, &timeout, ctx) != MI_SUCCESS)
a311 1
		call_abort = ST_IN_MAIL(curstate);
d340 1
a340 2
		/* call abort only if in a mail transaction */
		if (fi_abort != NULL && call_abort)
d343 3
d347 3
a349 3
	/* close must always be called */
	if ((fi_close = ctx->ctx_smfi->xxfi_close) != NULL)
		(void) (*fi_close)(ctx);
d360 1
a360 1
**		sd -- socket descriptor
d369 1
a369 1
sendreply(r, sd, timeout_ptr, ctx)
d371 1
a371 1
	socket_t sd;
d377 1
a377 1
	switch (r)
d380 1
a380 1
		ret = mi_wr_cmd(sd, timeout_ptr, SMFIR_CONTINUE, NULL, 0);
d386 2
a387 3
			ret = mi_wr_cmd(sd, timeout_ptr, SMFIR_REPLYCODE,
					ctx->ctx_reply,
					strlen(ctx->ctx_reply) + 1);
d393 1
a393 1
			ret = mi_wr_cmd(sd, timeout_ptr, r == SMFIS_REJECT ?
d398 1
a398 1
		ret = mi_wr_cmd(sd, timeout_ptr, SMFIR_DISCARD, NULL, 0);
d401 1
a401 1
		ret = mi_wr_cmd(sd, timeout_ptr, SMFIR_ACCEPT, NULL, 0);
d413 1
a413 4
			v = htonl(ctx->ctx_pflags);
			(void) memcpy(&(buf[MILTER_LEN_BYTES * 2]), (void *) &v,
				      MILTER_LEN_BYTES);
			ret = mi_wr_cmd(sd, timeout_ptr, SMFIC_OPTNEG, buf,
d468 1
a468 1
	mi_int32 i, v;
d473 1
a473 3

	/* check for minimum length */
	if (g->a_len < MILTER_OPTLEN)
d476 1
a476 1
			"%s: st_optionneg[%d]: len too short %d < %d",
d485 2
a486 2
	v = ntohl(i);
	if (v < g->a_ctx->ctx_smfi->xxfi_version)
a487 1
		/* hard failure for now! */
d489 1
a489 1
			"%s: st_optionneg[%d]: version mismatch MTA: %d < milter: %d",
d491 1
a491 1
			(int) g->a_ctx->ctx_id, (int) v,
d496 2
d500 2
a501 31
	v = ntohl(i);

	/* no flags? set to default value for V1 actions */
	if (v == 0)
		v = SMFI_V1_ACTS;
	i = g->a_ctx->ctx_smfi->xxfi_flags;
	if ((v & i) != i)
	{
		smi_log(SMI_LOG_ERR,
			"%s: st_optionneg[%d]: 0x%x does not fulfill action requirements 0x%x",
			g->a_ctx->ctx_smfi->xxfi_name,
			(int) g->a_ctx->ctx_id, v, i);
		return _SMFIS_ABORT;
	}

	(void) memcpy((void *) &i, (void *) &(g->a_buf[MILTER_LEN_BYTES * 2]),
		      MILTER_LEN_BYTES);
	v = ntohl(i);

	/* no flags? set to default value for V1 protocol */
	if (v == 0)
		v = SMFI_V1_PROT;
	i = g->a_ctx->ctx_pflags;
	if ((v & i) != i)
	{
		smi_log(SMI_LOG_ERR,
			"%s: st_optionneg[%d]: 0x%x does not fulfill protocol requirements 0x%x",
			g->a_ctx->ctx_smfi->xxfi_name,
			(int) g->a_ctx->ctx_id, v, i);
		return _SMFIS_ABORT;
	}
d520 1
a520 1
	size_t i;
d522 1
a522 1
	u_short port = 0;
d540 1
a540 4

	/* Move past trailing \0 in host string */
	i++;
	family = s[i++];
d547 1
a547 1
		if ((i += sizeof port) >= l)
d558 1
a558 1
			if (inet_aton(s + i, (struct in_addr *) &sockaddr.sin.sin_addr)
a567 2
			if (port > 0)
				sockaddr.sin.sin_port = port;
a583 2
			if (port > 0)
				sockaddr.sin6.sin6_port = port;
d762 1
a762 1
	switch (g->a_buf[0])
d856 1
a856 1
			socket_t sd;
d861 1
a861 1
			sd = g->a_ctx->ctx_sd;
d864 1
a864 1
			    sendreply(r, sd, &timeout, g->a_ctx) != MI_SUCCESS)
d914 1
a914 2
	do
	{
d959 2
a960 2
	fl = ctx->ctx_pflags;
	if (bitset(SMFIP_NOCONNECT, fl))
d962 1
a962 1
	if (bitset(SMFIP_NOHELO, fl))
d964 1
a964 1
	if (bitset(SMFIP_NOMAIL, fl))
d966 1
a966 1
	if (bitset(SMFIP_NORCPT, fl))
d968 2
a969 1
	if (bitset(SMFIP_NOHDRS, fl))
a970 1
	if (bitset(SMFIP_NOEOH, fl))
d972 2
a973 1
	if (bitset(SMFIP_NOBODY, fl))
d1018 1
a1018 1
	return s;
d1039 1
a1039 1
	size_t i;
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d11 3
a13 2
#include <sm/gen.h>
SM_RCSID("@@(#)$Sendmail: engine.c,v 8.94 2001/08/14 12:49:45 ca Exp $")
d15 1
d17 1
a120 1

d125 1
a125 1
#define NX_HELO	(MASK(ST_HELO) | MASK(ST_MAIL))
d127 1
a127 3
#define NX_RCPT	(MASK(ST_HDRS) | MASK(ST_EOHS) | \
		 MASK(ST_BODY) | MASK(ST_ENDM) | \
		 MASK(ST_RCPT) | MASK(ST_ABRT))
d220 1
a220 1
				sm_dprintf("[%d] milter_abort\n",
d230 1
a230 1
				sm_dprintf("[%d] mi_engine: mi_rd_cmd error (%x)\n",
d243 1
a243 1
			sm_dprintf("[%d] got cmd '%c' len %d\n",
d254 1
a254 1
				sm_dprintf("[%d] cmd '%c' unknown\n",
d263 1
a263 1
				sm_dprintf("[%d] cmd '%c' not impl\n",
d272 1
a272 1
			sm_dprintf("[%d] cur %x new %x nextmask %x\n",
d279 1
a279 1
				sm_dprintf("[%d] abort: cur %d (%x) new %d (%x) next %x\n",
d340 1
a340 1
				sm_dprintf("[%d] function returned abort\n",
d563 1
a563 1
	unsigned short port = 0;
d620 2
a621 2
			if (mi_inet_pton(AF_INET6, s + i,
					 &sockaddr.sin6.sin6_addr) != 1)
d624 1
a624 1
					"%s: connect[%d]: mi_inet_pton failed",
d638 1
a638 1
			if (sm_strlcpy(sockaddr.sunix.sun_path, s + i,
d737 11
a747 11
#define ARGV_FCT(lf, rf, idx)					\
	char **argv;						\
	sfsistat (*lf) __P((SMFICTX *, char **));		\
	int r;							\
								\
	if (g == NULL)						\
		return _SMFIS_ABORT;				\
	mi_clr_macros(g->a_ctx, g->a_idx + 1);			\
	if (g->a_ctx->ctx_smfi == NULL ||			\
	    (lf = g->a_ctx->ctx_smfi->rf) == NULL)		\
		return SMFIS_CONTINUE;				\
d749 3
a751 3
		return _SMFIS_ABORT;				\
	r = (*lf)(g->a_ctx, argv);				\
	free(argv);						\
d866 1
a866 1
	sfsistat (*fi_body) __P((SMFICTX *, unsigned char *, size_t));
d872 1
a872 2
		return (*fi_body)(g->a_ctx, (unsigned char *)g->a_buf,
				  g->a_len);
d893 1
a893 1
	sfsistat (*fi_body) __P((SMFICTX *, unsigned char *, size_t));
d910 1
a910 2
			r = (*fi_body)(g->a_ctx, (unsigned char *)g->a_buf,
				       g->a_len);
d966 1
a966 1
			return true;
a972 1

a979 1

d983 1
a983 1
			return false;
d985 1
a985 1
	return false;
d1004 1
a1004 1
	unsigned long fl;
d1114 1
a1114 1
		return false;
d1116 1
a1116 1
		return false;
d1119 1
@


