head	1.14;
access;
symbols
	OPENBSD_5_6:1.13.0.6
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.30
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.28
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.26
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.24
	OPENBSD_5_0:1.12.0.22
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.20
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.18
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.14
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.16
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.12
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.10
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.8
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2014.09.17.18.49.50;	author matthieu;	state dead;
branches;
next	1.13;
commitid	M7i5giHIoz3DMlTU;

1.13
date	2014.02.07.21.24.59;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.22.18.43.54;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.16.00.21.30;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2004.06.24.03.59.25;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.19.01.41.13;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.17.17.31.39;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.01.19.59.21;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.18.00.49.27;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.15.21.09.02;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.43;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.52;	author millert;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	2001.05.31.00.28.51;	author miod;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Bye.
@
text
@/*
 *  Copyright (c) 1999-2004, 2006 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sm/gen.h>
SM_RCSID("@@(#)$Sendmail: signal.c,v 8.45 2013/11/22 20:51:36 ca Exp $")

#include "libmilter.h"

/*
**  thread to handle signals
*/

static smutex_t M_Mutex;

static int MilterStop = MILTER_CONT;

static void	*mi_signal_thread __P((void *));
static int	 mi_spawn_signal_thread __P((char *));

/*
**  MI_STOP -- return value of MilterStop
**
**	Parameters:
**		none.
**
**	Returns:
**		value of MilterStop
*/

int
mi_stop()
{
	return MilterStop;
}
/*
**  MI_STOP_MILTERS -- set value of MilterStop
**
**	Parameters:
**		v -- new value for MilterStop.
**
**	Returns:
**		none.
*/

void
mi_stop_milters(v)
	int v;
{
	(void) smutex_lock(&M_Mutex);
	if (MilterStop < v)
		MilterStop = v;

	/* close listen socket */
	mi_closener();
	(void) smutex_unlock(&M_Mutex);
}
/*
**  MI_CLEAN_SIGNALS -- clean up signal handler thread
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
*/

void
mi_clean_signals()
{
	(void) smutex_destroy(&M_Mutex);
}
/*
**  MI_SIGNAL_THREAD -- thread to deal with signals
**
**	Parameters:
**		name -- name of milter
**
**	Returns:
**		NULL
*/

static void *
mi_signal_thread(name)
	void *name;
{
	int sig, errs, sigerr;
	sigset_t set;

	(void) sigemptyset(&set);
	(void) sigaddset(&set, SIGHUP);
	(void) sigaddset(&set, SIGTERM);

	/* Handle Ctrl-C gracefully for debugging */
	(void) sigaddset(&set, SIGINT);
	errs = 0;

	for (;;)
	{
		sigerr = sig = 0;
#if defined(SOLARIS) || defined(__svr5__)
		if ((sig = sigwait(&set)) < 0)
#else /* defined(SOLARIS) || defined(__svr5__) */
		if ((sigerr = sigwait(&set, &sig)) != 0)
#endif /* defined(SOLARIS) || defined(__svr5__) */
		{
			/* some OS return -1 and set errno: copy it */
			if (sigerr <= 0)
				sigerr = errno;

			/* this can happen on OSF/1 (at least) */
			if (sigerr == EINTR)
				continue;
			smi_log(SMI_LOG_ERR,
				"%s: sigwait returned error: %d",
				(char *)name, sigerr);
			if (++errs > MAX_FAILS_T)
			{
				mi_stop_milters(MILTER_ABRT);
				return NULL;
			}
			continue;
		}
		errs = 0;

		switch (sig)
		{
		  case SIGHUP:
		  case SIGTERM:
			mi_stop_milters(MILTER_STOP);
			return NULL;
		  case SIGINT:
			mi_stop_milters(MILTER_ABRT);
			return NULL;
		  default:
			smi_log(SMI_LOG_ERR,
				"%s: sigwait returned unmasked signal: %d",
				(char *)name, sig);
			break;
		}
	}
	/* NOTREACHED */
}
/*
**  MI_SPAWN_SIGNAL_THREAD -- spawn thread to handle signals
**
**	Parameters:
**		name -- name of milter
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

static int
mi_spawn_signal_thread(name)
	char *name;
{
	sthread_t tid;
	int r;
	sigset_t set;

	/* Mask HUP and KILL signals */
	(void) sigemptyset(&set);
	(void) sigaddset(&set, SIGHUP);
	(void) sigaddset(&set, SIGTERM);
	(void) sigaddset(&set, SIGINT);

	if (pthread_sigmask(SIG_BLOCK, &set, NULL) != 0)
	{
		smi_log(SMI_LOG_ERR,
			"%s: Couldn't mask HUP and KILL signals", name);
		return MI_FAILURE;
	}
	r = thread_create(&tid, mi_signal_thread, (void *)name);
	if (r != 0)
	{
		smi_log(SMI_LOG_ERR,
			"%s: Couldn't start signal thread: %d",
			name, r);
		return MI_FAILURE;
	}
	return MI_SUCCESS;
}
/*
**  MI_CONTROL_STARTUP -- startup for thread to handle signals
**
**	Parameters:
**		name -- name of milter
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
mi_control_startup(name)
	char *name;
{

	if (!smutex_init(&M_Mutex))
	{
		smi_log(SMI_LOG_ERR,
			"%s: Couldn't initialize control pipe mutex", name);
		return MI_FAILURE;
	}

	/*
	**  spawn_signal_thread must happen before other threads are spawned
	**  off so that it can mask the right signals and other threads
	**  will inherit that mask.
	*/
	if (mi_spawn_signal_thread(name) == MI_FAILURE)
	{
		smi_log(SMI_LOG_ERR,
			"%s: Couldn't spawn signal thread", name);
		(void) smutex_destroy(&M_Mutex);
		return MI_FAILURE;
	}
	return MI_SUCCESS;
}
@


1.13
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.12
log
@Update to sendmail 8.13.6
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2004, 2006 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: signal.c,v 8.44 2006/03/03 03:42:04 ca Exp $")
@


1.11
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2004 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: signal.c,v 8.42 2004/08/20 21:10:30 ca Exp $")
d93 1
a93 1
	int sig, errs;
d106 1
a106 1
		sig = 0;
d110 1
a110 1
		if (sigwait(&set, &sig) != 0)
d113 4
d118 1
a118 1
			if (errno == EINTR)
d122 1
a122 1
				(char *)name, errno);
@


1.10
log
@Update to sendmail.8.13.0
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2003 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: signal.c,v 8.41 2003/11/19 00:25:20 ca Exp $")
d23 3
@


1.9
log
@Update to sendmail 8.12.11.  I've been runninga beta version of this for
some time without problems.  See the RELEASE_NOTES for the change log.
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: signal.c,v 8.37.2.4 2003/11/19 00:22:40 ca Exp $")
@


1.8
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2002 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: signal.c,v 8.37.2.3 2003/08/04 18:14:33 ca Exp $")
@


1.7
log
@update to sendmail 8.12.7
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: signal.c,v 8.37.2.2 2002/10/23 16:52:00 ca Exp $")
d93 3
a95 3
	sigemptyset(&set);
	sigaddset(&set, SIGHUP);
	sigaddset(&set, SIGTERM);
d98 1
a98 1
	sigaddset(&set, SIGINT);
d101 1
a101 1
	while (true)
d141 1
d162 4
a165 4
	sigemptyset(&set);
	sigaddset(&set, SIGHUP);
	sigaddset(&set, SIGTERM);
	sigaddset(&set, SIGINT);
@


1.6
log
@update to sendmail 8.12.3
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: signal.c,v 8.37 2002/03/23 00:55:19 ca Exp $")
d110 3
@


1.5
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: signal.c,v 8.35 2002/01/10 01:34:55 ca Exp $")
@


1.4
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: signal.c,v 8.27 2001/09/11 04:04:45 gshapiro Exp $")
d104 1
a104 1
#ifdef SOLARIS
d106 1
a106 1
#else /* SOLARIS */
d108 1
a108 1
#endif /* SOLARIS */
d111 2
a112 2
				"%s: sigwait returned error: %s",
				(char *)name, strerror(errno));
d154 1
d169 2
a170 2
	if (thread_create(&tid, mi_signal_thread,
			  (void *)name) != MI_SUCCESS)
d173 2
a174 1
			"%s: Couldn't start signal thread", name);
@


1.3
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: signal.c,v 8.24 2001/01/24 00:27:35 ca Exp $")
d24 1
a24 1
/*
d39 1
a39 1
/*
d61 1
a61 1
/*
d76 1
a76 1
/*
d139 1
a139 1
/*
d177 1
a177 1
/*
@


1.2
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2000 Sendmail, Inc. and its suppliers.
d11 2
a12 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: signal.c,v 8.10.4.8 2000/11/20 21:15:37 ca Exp $";
#endif /* ! lint */
a13 1
#if _FFR_MILTER
d101 1
a101 1
	while (TRUE)
a212 1
#endif /* _FFR_MILTER */
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: signal.c,v 8.10 2000/02/26 01:32:14 gshapiro Exp $";
d19 1
a19 1
** thread to handle signals
a21 7
typedef pthread_mutex_t smutex_t;
#define smutex_init(mp)		(pthread_mutex_init(mp, NULL) == 0)
#define smutex_destroy(mp)	(pthread_mutex_destroy(mp) == 0)
#define smutex_lock(mp)		(pthread_mutex_lock(mp) == 0)
#define smutex_unlock(mp)	(pthread_mutex_unlock(mp) == 0)
#define smutex_trylock(mp)	(pthread_mutex_trylock(mp) == 0)

d26 1
a26 2

/*
d39 1
a39 1
	return(MilterStop);
d41 1
a41 3


/*
d58 3
d63 1
a63 2

/*
d78 2
a79 3

/*
**  MI -- thread to deal with signals
d141 1
a141 2

/*
d155 1
a156 1
	pthread_t tid;
d170 2
a171 2
	if (pthread_create(&tid, NULL, mi_signal_thread, (void *)name)
	    != MI_SUCCESS)
d179 1
a179 2

/*
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.1.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: signal.c,v 8.10.4.8 2000/11/20 21:15:37 ca Exp $";
d19 1
a19 1
**  thread to handle signals
d22 7
d33 2
a34 1
/*
d47 1
a47 1
	return MilterStop;
d49 3
a51 1
/*
a67 3

	/* close listen socket */
	mi_closener();
d70 2
a71 1
/*
d86 3
a88 2
/*
**  MI_SIGNAL_THREAD -- thread to deal with signals
d150 2
a151 1
/*
a164 1
	sthread_t tid;
d166 1
d180 2
a181 2
	if (thread_create(&tid, mi_signal_thread,
			  (void *)name) != MI_SUCCESS)
d189 2
a190 1
/*
@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Id: signal.c,v 8.10.4.8 2000/11/20 21:15:37 ca Exp $";
d19 1
a19 1
**  thread to handle signals
d22 7
d33 2
a34 1
/*
d47 1
a47 1
	return MilterStop;
d49 3
a51 1
/*
a67 3

	/* close listen socket */
	mi_closener();
d70 2
a71 1
/*
d86 3
a88 2
/*
**  MI_SIGNAL_THREAD -- thread to deal with signals
d150 2
a151 1
/*
a164 1
	sthread_t tid;
d166 1
d180 2
a181 2
	if (thread_create(&tid, mi_signal_thread,
			  (void *)name) != MI_SUCCESS)
d189 2
a190 1
/*
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d11 3
a13 2
#include <sm/gen.h>
SM_RCSID("@@(#)$Sendmail: signal.c,v 8.24 2001/01/24 00:27:35 ca Exp $")
d15 1
d103 1
a103 1
	while (true)
d215 1
@


