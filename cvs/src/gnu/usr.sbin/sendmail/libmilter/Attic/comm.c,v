head	1.16;
access;
symbols
	OPENBSD_5_6:1.15.0.6
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.10
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.8
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.6
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.4
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.13.0.18
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.16
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.12
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.14
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.10
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.8
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.6
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.4
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.12.0.8
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.9.0.6
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2014.09.17.18.49.50;	author matthieu;	state dead;
branches;
next	1.15;
commitid	M7i5giHIoz3DMlTU;

1.15
date	2014.02.07.21.24.59;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2011.05.17.15.54.23;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.16.00.21.30;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2004.09.18.04.08.34;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2004.06.24.03.59.25;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.03.17.31.21;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.01.19.59.21;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.15.02.23.35;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.18.00.49.27;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.15.21.09.02;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.42;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.52;	author millert;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	2001.05.31.00.28.49;	author miod;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Bye.
@
text
@/*
 *  Copyright (c) 1999-2004, 2009 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sm/gen.h>
SM_RCSID("@@(#)$Sendmail: comm.c,v 8.71 2013/11/22 20:51:36 ca Exp $")

#include "libmilter.h"
#include <sm/errstring.h>
#include <sys/uio.h>

static ssize_t	retry_writev __P((socket_t, struct iovec *, int, struct timeval *));
static size_t Maxdatasize = MILTER_MAX_DATA_SIZE;

/*
**  SMFI_SETMAXDATASIZE -- set limit for milter data read/write.
**
**	Parameters:
**		sz -- new limit.
**
**	Returns:
**		old limit
*/

size_t
smfi_setmaxdatasize(sz)
	size_t sz;
{
	size_t old;

	old = Maxdatasize;
	Maxdatasize = sz;
	return old;
}

/*
**  MI_RD_CMD -- read a command
**
**	Parameters:
**		sd -- socket descriptor
**		timeout -- maximum time to wait
**		cmd -- single character command read from sd
**		rlen -- pointer to length of result
**		name -- name of milter
**
**	Returns:
**		buffer with rest of command
**		(malloc()ed here, should be free()d)
**		hack: encode error in cmd
*/

char *
mi_rd_cmd(sd, timeout, cmd, rlen, name)
	socket_t sd;
	struct timeval *timeout;
	char *cmd;
	size_t *rlen;
	char *name;
{
	ssize_t len;
	mi_int32 expl;
	ssize_t i;
	FD_RD_VAR(rds, excs);
	int ret;
	int save_errno;
	char *buf;
	char data[MILTER_LEN_BYTES + 1];

	*cmd = '\0';
	*rlen = 0;

	i = 0;
	for (;;)
	{
		FD_RD_INIT(sd, rds, excs);
		ret = FD_RD_READY(sd, rds, excs, timeout);
		if (ret == 0)
			break;
		else if (ret < 0)
		{
			if (errno == EINTR)
				continue;
			break;
		}
		if (FD_IS_RD_EXC(sd, rds, excs))
		{
			*cmd = SMFIC_SELECT;
			return NULL;
		}

		len = MI_SOCK_READ(sd, data + i, sizeof data - i);
		if (MI_SOCK_READ_FAIL(len))
		{
			smi_log(SMI_LOG_ERR,
				"%s, mi_rd_cmd: read returned %d: %s",
				name, (int) len, sm_errstring(errno));
			*cmd = SMFIC_RECVERR;
			return NULL;
		}
		if (len == 0)
		{
			*cmd = SMFIC_EOF;
			return NULL;
		}
		if (len >= (ssize_t) sizeof data - i)
			break;
		i += len;
	}
	if (ret == 0)
	{
		*cmd = SMFIC_TIMEOUT;
		return NULL;
	}
	else if (ret < 0)
	{
		smi_log(SMI_LOG_ERR,
			"%s: mi_rd_cmd: %s() returned %d: %s",
			name, MI_POLLSELECT, ret, sm_errstring(errno));
		*cmd = SMFIC_RECVERR;
		return NULL;
	}

	*cmd = data[MILTER_LEN_BYTES];
	data[MILTER_LEN_BYTES] = '\0';
	(void) memcpy((void *) &expl, (void *) &(data[0]), MILTER_LEN_BYTES);
	expl = ntohl(expl) - 1;
	if (expl <= 0)
		return NULL;
	if (expl > Maxdatasize)
	{
		*cmd = SMFIC_TOOBIG;
		return NULL;
	}
#if _FFR_ADD_NULL
	buf = malloc(expl + 1);
#else /* _FFR_ADD_NULL */
	buf = malloc(expl);
#endif /* _FFR_ADD_NULL */
	if (buf == NULL)
	{
		*cmd = SMFIC_MALLOC;
		return NULL;
	}

	i = 0;
	for (;;)
	{
		FD_RD_INIT(sd, rds, excs);
		ret = FD_RD_READY(sd, rds, excs, timeout);
		if (ret == 0)
			break;
		else if (ret < 0)
		{
			if (errno == EINTR)
				continue;
			break;
		}
		if (FD_IS_RD_EXC(sd, rds, excs))
		{
			*cmd = SMFIC_SELECT;
			free(buf);
			return NULL;
		}
		len = MI_SOCK_READ(sd, buf + i, expl - i);
		if (MI_SOCK_READ_FAIL(len))
		{
			smi_log(SMI_LOG_ERR,
				"%s: mi_rd_cmd: read returned %d: %s",
				name, (int) len, sm_errstring(errno));
			ret = -1;
			break;
		}
		if (len == 0)
		{
			*cmd = SMFIC_EOF;
			free(buf);
			return NULL;
		}
		if (len > expl - i)
		{
			*cmd = SMFIC_RECVERR;
			free(buf);
			return NULL;
		}
		if (len >= expl - i)
		{
			*rlen = expl;
#if _FFR_ADD_NULL
			/* makes life simpler for common string routines */
			buf[expl] = '\0';
#endif /* _FFR_ADD_NULL */
			return buf;
		}
		i += len;
	}

	save_errno = errno;
	free(buf);

	/* select returned 0 (timeout) or < 0 (error) */
	if (ret == 0)
	{
		*cmd = SMFIC_TIMEOUT;
		return NULL;
	}
	if (ret < 0)
	{
		smi_log(SMI_LOG_ERR,
			"%s: mi_rd_cmd: %s() returned %d: %s",
			name, MI_POLLSELECT, ret, sm_errstring(save_errno));
		*cmd = SMFIC_RECVERR;
		return NULL;
	}
	*cmd = SMFIC_UNKNERR;
	return NULL;
}

/*
**  RETRY_WRITEV -- Keep calling the writev() system call
**	until all the data is written out or an error occurs.
**
**	Parameters:
**		fd -- socket descriptor
**		iov -- io vector
**		iovcnt -- number of elements in io vector
**			must NOT exceed UIO_MAXIOV.
**		timeout -- maximum time to wait
**
**	Returns:
**		success: number of bytes written
**		otherwise: MI_FAILURE
*/

static ssize_t
retry_writev(fd, iov, iovcnt, timeout)
	socket_t fd;
	struct iovec *iov;
	int iovcnt;
	struct timeval *timeout;
{
	int i;
	ssize_t n, written;
	FD_WR_VAR(wrs);

	written = 0;
	for (;;)
	{
		while (iovcnt > 0 && iov[0].iov_len == 0)
		{
			iov++;
			iovcnt--;
		}
		if (iovcnt <= 0)
			return written;

		/*
		**  We don't care much about the timeout here,
		**  it's very long anyway; correct solution would be
		**  to take the time before the loop and reduce the
		**  timeout after each invocation.
		**  FD_SETSIZE is checked when socket is created.
		*/

		FD_WR_INIT(fd, wrs);
		i = FD_WR_READY(fd, wrs, timeout);
		if (i == 0)
			return MI_FAILURE;
		if (i < 0)
		{
			if (errno == EINTR || errno == EAGAIN)
				continue;
			return MI_FAILURE;
		}
		n = writev(fd, iov, iovcnt);
		if (n == -1)
		{
			if (errno == EINTR || errno == EAGAIN)
				continue;
			return MI_FAILURE;
		}

		written += n;
		for (i = 0; i < iovcnt; i++)
		{
			if (iov[i].iov_len > (unsigned int) n)
			{
				iov[i].iov_base = (char *)iov[i].iov_base + n;
				iov[i].iov_len -= (unsigned int) n;
				break;
			}
			n -= (int) iov[i].iov_len;
			iov[i].iov_len = 0;
		}
		if (i == iovcnt)
			return written;
	}
}

/*
**  MI_WR_CMD -- write a cmd to sd
**
**	Parameters:
**		sd -- socket descriptor
**		timeout -- maximum time to wait
**		cmd -- single character command to write
**		buf -- buffer with further data
**		len -- length of buffer (without cmd!)
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
mi_wr_cmd(sd, timeout, cmd, buf, len)
	socket_t sd;
	struct timeval *timeout;
	int cmd;
	char *buf;
	size_t len;
{
	size_t sl;
	ssize_t l;
	mi_int32 nl;
	int iovcnt;
	struct iovec iov[2];
	char data[MILTER_LEN_BYTES + 1];

	if (len > Maxdatasize || (len > 0 && buf == NULL))
		return MI_FAILURE;

	nl = htonl(len + 1);	/* add 1 for the cmd char */
	(void) memcpy(data, (void *) &nl, MILTER_LEN_BYTES);
	data[MILTER_LEN_BYTES] = (char) cmd;
	sl = MILTER_LEN_BYTES + 1;

	/* set up the vector for the size / command */
	iov[0].iov_base = (void *) data;
	iov[0].iov_len  = sl;
	iovcnt = 1;
	if (len >= 0 && buf != NULL)
	{
		iov[1].iov_base = (void *) buf;
		iov[1].iov_len  = len;
		iovcnt = 2;
	}

	l = retry_writev(sd, iov, iovcnt, timeout);
	if (l == MI_FAILURE)
		return MI_FAILURE;
	return MI_SUCCESS;
}
@


1.15
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.14
log
@Update to sendmail 8.14.5
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2004, 2009 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: comm.c,v 8.70 2009/12/16 16:33:48 ca Exp $")
@


1.13
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2004 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: comm.c,v 8.67 2006/11/02 17:54:44 ca Exp $")
a20 1
#if _FFR_MAXDATASIZE
a40 1
#endif /* _FFR_MAXDATASIZE */
d123 2
a124 2
			"%s: mi_rd_cmd: select returned %d: %s",
			name, ret, sm_errstring(errno));
d215 2
a216 2
			"%s: mi_rd_cmd: select returned %d: %s",
			name, ret, sm_errstring(save_errno));
d327 1
a327 1
	size_t sl, i;
a339 1
	i = 0;
@


1.12
log
@Update to sendmail-8.13.2
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: comm.c,v 8.66 2004/08/20 20:38:35 ca Exp $")
d355 1
a355 1
    
@


1.11
log
@Update to sendmail-8.13.1
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: comm.c,v 8.65 2004/07/07 21:41:30 ca Exp $")
d18 1
@


1.10
log
@Update to sendmail.8.13.0
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: comm.c,v 8.64 2004/04/30 22:02:57 ca Exp $")
d18 25
d136 1
a136 1
	if (expl > MILTER_CHUNK_SIZE)
d335 1
a335 1
	if (len > MILTER_CHUNK_SIZE || (len > 0 && buf == NULL))
@


1.9
log
@Update to Sendmail 8.12.8; fixes a buffer overflow in the envelope
comments processing which may allow an attacker to gain root privileges.
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2003 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: comm.c,v 8.54.2.6 2003/01/03 22:14:40 ca Exp $")
d16 1
d199 82
d286 1
a286 1
**		timeout -- maximum time to wait (currently unused)
a294 32
/*
**  we don't care much about the timeout here, it's very long anyway
**  FD_SETSIZE is checked when socket is created.
**  XXX l == 0 ?
*/

#define MI_WR(data)	\
	while (sl > 0)							\
	{								\
		FD_WR_INIT(sd, wrs);					\
		ret = FD_WR_READY(sd, wrs, timeout);			\
		if (ret == 0)						\
			return MI_FAILURE;				\
		if (ret < 0)						\
		{							\
			if (errno == EINTR)				\
				continue;				\
			else						\
				return MI_FAILURE;			\
		}							\
		l = MI_SOCK_WRITE(sd, (void *) ((data) + i), sl);	\
		if (l < 0)						\
		{							\
			if (errno == EINTR)				\
				continue;				\
			else						\
				return MI_FAILURE;			\
		}							\
		i += l;							\
		sl -= l;						\
	}

d306 2
a307 2
	int ret;
	FD_WR_VAR(wrs);
d310 1
a310 1
	if (len > MILTER_CHUNK_SIZE)
d312 1
d319 13
a331 4
	/* use writev() instead to send the whole stuff at once? */

	MI_WR(data);
	if (len > 0 && buf == NULL)
a332 5
	if (len == 0 || buf == NULL)
		return MI_SUCCESS;
	i = 0;
	sl = len;
	MI_WR(buf);
@


1.8
log
@update to sendmail 8.12.7
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2002 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: comm.c,v 8.54.2.4 2002/12/03 17:32:45 ca Exp $")
a16 5
#define FD_Z	FD_ZERO(&readset);			\
		FD_SET((unsigned int) sd, &readset);	\
		FD_ZERO(&excset);			\
		FD_SET((unsigned int) sd, &excset)

d44 1
a44 1
	fd_set readset, excset;
d56 2
a57 2
		FD_Z;
		ret = select(sd + 1, &readset, NULL, &excset, timeout);
d66 1
a66 1
		if (FD_ISSET(sd, &excset))
d129 2
a130 2
		FD_Z;
		ret = select(sd + 1, &readset, NULL, &excset, timeout);
d139 1
a139 1
		if (FD_ISSET(sd, &excset))
d221 2
a222 3
		FD_ZERO(&wrtset);					\
		FD_SET((unsigned int) sd, &wrtset);			\
		ret = select(sd + 1, NULL, &wrtset, NULL, timeout);	\
d256 1
a256 1
	fd_set wrtset;
@


1.7
log
@update to sendmail-8.12.6
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: comm.c,v 8.54.2.2 2002/08/16 17:09:13 ca Exp $")
a57 8
	if (sd >= FD_SETSIZE)
	{
		smi_log(SMI_LOG_ERR, "%s: fd %d is larger than FD_SETSIZE %d",
			name, sd, FD_SETSIZE);
		*cmd = SMFIC_SELECT;
		return NULL;
	}

d82 1
a82 1
				name, len, sm_errstring(errno));
d155 1
a155 1
				name, len, sm_errstring(errno));
d219 1
a219 1
**  FD_SETSIZE is only checked in mi_rd_cmd.
@


1.6
log
@update to sendmail 8.12.3
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: comm.c,v 8.54 2002/03/06 16:03:26 ca Exp $")
a65 1
	FD_Z;
d67 1
a67 1
	while ((ret = select(sd + 1, &readset, NULL, &excset, timeout)) >= 1)
d69 10
a101 1
		FD_Z;
d140 1
a140 2
	FD_Z;
	while ((ret = select(sd + 1, &readset, NULL, &excset, timeout)) == 1)
d142 10
a188 1
		FD_Z;
@


1.5
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: comm.c,v 8.48 2001/11/07 17:43:04 ca Exp $")
d209 33
a264 10
	do
	{
		FD_ZERO(&wrtset);
		FD_SET((unsigned int) sd, &wrtset);
		if ((ret = select(sd + 1, NULL, &wrtset, NULL, timeout)) == 0)
			return MI_FAILURE;
	} while (ret < 0 && errno == EINTR);
	if (ret < 0)
		return MI_FAILURE;

a265 8
	while ((l = MI_SOCK_WRITE(sd, (void *) (data + i),
				  sl - i)) < (ssize_t) sl)
	{
		if (l < 0)
			return MI_FAILURE;
		i += l;
		sl -= l;
	}
d267 1
d274 1
a274 17
	do
	{
		FD_ZERO(&wrtset);
		FD_SET((unsigned int) sd, &wrtset);
		if ((ret = select(sd + 1, NULL, &wrtset, NULL, timeout)) == 0)
			return MI_FAILURE;
	} while (ret < 0 && errno == EINTR);
	if (ret < 0)
		return MI_FAILURE;
	while ((l = MI_SOCK_WRITE(sd, (void *) (buf + i),
				  sl - i)) < (ssize_t) sl)
	{
		if (l < 0)
			return MI_FAILURE;
		i += l;
		sl -= l;
	}
@


1.4
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: comm.c,v 8.46 2001/09/11 04:04:44 gshapiro Exp $")
d75 3
a77 1
		if ((len = MI_SOCK_READ(sd, data + i, sizeof data - i)) < 0)
d141 2
a142 1
		if ((len = MI_SOCK_READ(sd, buf + i, expl - i)) < 0)
@


1.3
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: comm.c,v 8.43 2001/07/20 20:33:07 ca Exp $")
d192 1
a192 1
/*
@


1.2
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2000 Sendmail, Inc. and its suppliers.
d11 2
a12 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: comm.c,v 8.30.4.6 2000/10/05 22:44:01 gshapiro Exp $";
#endif /* ! lint */
a13 1
#if _FFR_MILTER
d15 1
d17 4
a20 4
#define FD_Z	FD_ZERO(&readset);	\
		FD_SET((u_int) sd, &readset);	\
		FD_ZERO(&excset);	\
		FD_SET((u_int) sd, &excset)
d79 1
a79 1
				name, len, strerror(errno));
d102 1
a102 1
			name, ret, strerror(errno));
d118 3
d122 1
d143 1
a143 1
				name, len, strerror(errno));
d162 4
d185 1
a185 1
			name, ret, strerror(save_errno));
d232 1
a232 1
		FD_SET((u_int) sd, &wrtset);
d258 1
a258 1
		FD_SET((u_int) sd, &wrtset);
a273 1
#endif /* _FFR_MILTER */
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: comm.c,v 8.30 2000/02/11 00:12:29 ca Exp $";
d19 1
a19 1
		FD_SET(fd, &readset);	\
d21 1
a21 1
		FD_SET(fd, &excset)
d27 1
a27 1
**		fd -- file descriptor
d29 1
a29 1
**		cmd -- single character command read from fd
d40 2
a41 2
mi_rd_cmd(fd, timeout, cmd, rlen, name)
	int fd;
d58 2
a59 1
	if (fd >= FD_SETSIZE)
d62 1
a62 1
			name, fd, FD_SETSIZE);
d66 1
d69 1
a69 1
	while ((ret = select(fd + 1, &readset, NULL, &excset, timeout)) >= 1)
d71 1
a71 1
		if (FD_ISSET(fd, &excset))
d76 1
a76 1
		if ((len = read(fd, data + i, sizeof data - i)) < 0)
d89 1
a89 1
		if (len >= sizeof data - i)
d128 1
a128 1
	while ((ret = select(fd + 1, &readset, NULL, &excset, timeout)) == 1)
d130 1
a130 1
		if (FD_ISSET(fd, &excset))
d136 1
a136 1
		if ((len = read(fd, buf + i, expl - i)) < 0)
d186 1
a186 1
**  MI_WR_CMD -- write a cmd to fd
d189 1
a189 1
**		fd -- file descriptor
d200 2
a201 2
mi_wr_cmd(fd, timeout, cmd, buf, len)
	int fd;
d222 2
a223 1
	do {
d225 2
a226 2
		FD_SET(fd, &wrtset);
		if ((ret = select(fd + 1, NULL, &wrtset, NULL, timeout)) == 0)
d233 2
a234 1
	while ((l = write(fd, (void *) (data + i), sl - i)) < sl)
d248 2
a249 1
	do {
d251 2
a252 2
		FD_SET(fd, &wrtset);
		if ((ret = select(fd + 1, NULL, &wrtset, NULL, timeout)) == 0)
d257 2
a258 1
	while ((l = write(fd, (void *) (buf + i), sl - i)) < sl)
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.1.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: comm.c,v 8.30.4.6 2000/10/05 22:44:01 gshapiro Exp $";
d19 1
a19 1
		FD_SET((u_int) sd, &readset);	\
d21 1
a21 1
		FD_SET((u_int) sd, &excset)
d27 1
a27 1
**		sd -- socket descriptor
d29 1
a29 1
**		cmd -- single character command read from sd
d40 2
a41 2
mi_rd_cmd(sd, timeout, cmd, rlen, name)
	socket_t sd;
d58 1
a58 2

	if (sd >= FD_SETSIZE)
d61 1
a61 1
			name, sd, FD_SETSIZE);
a64 1

d67 1
a67 1
	while ((ret = select(sd + 1, &readset, NULL, &excset, timeout)) >= 1)
d69 1
a69 1
		if (FD_ISSET(sd, &excset))
d74 1
a74 1
		if ((len = MI_SOCK_READ(sd, data + i, sizeof data - i)) < 0)
d87 1
a87 1
		if (len >= (ssize_t) sizeof data - i)
d126 1
a126 1
	while ((ret = select(sd + 1, &readset, NULL, &excset, timeout)) == 1)
d128 1
a128 1
		if (FD_ISSET(sd, &excset))
d134 1
a134 1
		if ((len = MI_SOCK_READ(sd, buf + i, expl - i)) < 0)
d184 1
a184 1
**  MI_WR_CMD -- write a cmd to sd
d187 1
a187 1
**		sd -- socket descriptor
d198 2
a199 2
mi_wr_cmd(sd, timeout, cmd, buf, len)
	socket_t sd;
d220 1
a220 2
	do
	{
d222 2
a223 2
		FD_SET((u_int) sd, &wrtset);
		if ((ret = select(sd + 1, NULL, &wrtset, NULL, timeout)) == 0)
d230 1
a230 2
	while ((l = MI_SOCK_WRITE(sd, (void *) (data + i),
				  sl - i)) < (ssize_t) sl)
d244 1
a244 2
	do
	{
d246 2
a247 2
		FD_SET((u_int) sd, &wrtset);
		if ((ret = select(sd + 1, NULL, &wrtset, NULL, timeout)) == 0)
d252 1
a252 2
	while ((l = MI_SOCK_WRITE(sd, (void *) (buf + i),
				  sl - i)) < (ssize_t) sl)
@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Id: comm.c,v 8.30.4.6 2000/10/05 22:44:01 gshapiro Exp $";
d19 1
a19 1
		FD_SET((u_int) sd, &readset);	\
d21 1
a21 1
		FD_SET((u_int) sd, &excset)
d27 1
a27 1
**		sd -- socket descriptor
d29 1
a29 1
**		cmd -- single character command read from sd
d40 2
a41 2
mi_rd_cmd(sd, timeout, cmd, rlen, name)
	socket_t sd;
d58 1
a58 2

	if (sd >= FD_SETSIZE)
d61 1
a61 1
			name, sd, FD_SETSIZE);
a64 1

d67 1
a67 1
	while ((ret = select(sd + 1, &readset, NULL, &excset, timeout)) >= 1)
d69 1
a69 1
		if (FD_ISSET(sd, &excset))
d74 1
a74 1
		if ((len = MI_SOCK_READ(sd, data + i, sizeof data - i)) < 0)
d87 1
a87 1
		if (len >= (ssize_t) sizeof data - i)
d126 1
a126 1
	while ((ret = select(sd + 1, &readset, NULL, &excset, timeout)) == 1)
d128 1
a128 1
		if (FD_ISSET(sd, &excset))
d134 1
a134 1
		if ((len = MI_SOCK_READ(sd, buf + i, expl - i)) < 0)
d184 1
a184 1
**  MI_WR_CMD -- write a cmd to sd
d187 1
a187 1
**		sd -- socket descriptor
d198 2
a199 2
mi_wr_cmd(sd, timeout, cmd, buf, len)
	socket_t sd;
d220 1
a220 2
	do
	{
d222 2
a223 2
		FD_SET((u_int) sd, &wrtset);
		if ((ret = select(sd + 1, NULL, &wrtset, NULL, timeout)) == 0)
d230 1
a230 2
	while ((l = MI_SOCK_WRITE(sd, (void *) (data + i),
				  sl - i)) < (ssize_t) sl)
d244 1
a244 2
	do
	{
d246 2
a247 2
		FD_SET((u_int) sd, &wrtset);
		if ((ret = select(sd + 1, NULL, &wrtset, NULL, timeout)) == 0)
d252 1
a252 2
	while ((l = MI_SOCK_WRITE(sd, (void *) (buf + i),
				  sl - i)) < (ssize_t) sl)
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d11 3
a13 2
#include <sm/gen.h>
SM_RCSID("@@(#)$Sendmail: comm.c,v 8.43 2001/07/20 20:33:07 ca Exp $")
d15 1
a16 1
#include <sm/errstring.h>
d18 4
a21 4
#define FD_Z	FD_ZERO(&readset);			\
		FD_SET((unsigned int) sd, &readset);	\
		FD_ZERO(&excset);			\
		FD_SET((unsigned int) sd, &excset)
d80 1
a80 1
				name, len, sm_errstring(errno));
d103 1
a103 1
			name, ret, sm_errstring(errno));
a118 3
#if _FFR_ADD_NULL
	buf = malloc(expl + 1);
#else /* _FFR_ADD_NULL */
a119 1
#endif /* _FFR_ADD_NULL */
d140 1
a140 1
				name, len, sm_errstring(errno));
a158 4
#if _FFR_ADD_NULL
			/* makes life simpler for common string routines */
			buf[expl] = '\0';
#endif /* _FFR_ADD_NULL */
d178 1
a178 1
			name, ret, sm_errstring(save_errno));
d225 1
a225 1
		FD_SET((unsigned int) sd, &wrtset);
d251 1
a251 1
		FD_SET((unsigned int) sd, &wrtset);
d267 1
@


