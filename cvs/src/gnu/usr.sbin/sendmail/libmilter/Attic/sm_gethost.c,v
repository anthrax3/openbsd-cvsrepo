head	1.12;
access;
symbols
	OPENBSD_5_6:1.11.0.6
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.8
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.4
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.7.0.14
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.12
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.8
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.10
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.6
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.4
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2014.09.17.18.49.50;	author matthieu;	state dead;
branches;
next	1.11;
commitid	M7i5giHIoz3DMlTU;

1.11
date	2014.02.07.21.24.59;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.9;

1.9
date	2011.05.17.15.54.23;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.16.00.21.30;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.01.01.01.40;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.29.01.31.13;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.28.02.43.51;	author millert;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.01.15.21.09.03;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.43;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.52;	author millert;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	2001.05.31.00.28.51;	author miod;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.31.01.47.54;	author jason;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Bye.
@
text
@/*
 *  Copyright (c) 1999-2001, 2004, 2010, 2013 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sm/gen.h>
SM_RCSID("@@(#)$Sendmail: sm_gethost.c,v 8.32 2013/11/22 20:51:36 ca Exp $")

#include <sendmail.h>
#if NETINET || NETINET6
# include <arpa/inet.h>
#endif /* NETINET || NETINET6 */
#include "libmilter.h"

/*
**  MI_GETHOSTBY{NAME,ADDR} -- compatibility routines for gethostbyXXX
**
**	Some operating systems have wierd problems with the gethostbyXXX
**	routines.  For example, Solaris versions at least through 2.3
**	don't properly deliver a canonical h_name field.  This tries to
**	work around these problems.
**
**	Support IPv6 as well as IPv4.
*/

#if NETINET6 && NEEDSGETIPNODE

static struct hostent *sm_getipnodebyname __P((const char *, int, int, int *));

# ifndef AI_ADDRCONFIG
#  define AI_ADDRCONFIG	0	/* dummy */
# endif /* ! AI_ADDRCONFIG */
# ifndef AI_ALL
#  define AI_ALL	0	/* dummy */
# endif /* ! AI_ALL */
# ifndef AI_DEFAULT
#  define AI_DEFAULT	0	/* dummy */
# endif /* ! AI_DEFAULT */

static struct hostent *
sm_getipnodebyname(name, family, flags, err)
	const char *name;
	int family;
	int flags;
	int *err;
{
	bool resv6 = true;
	struct hostent *h;

	if (family == AF_INET6)
	{
		/* From RFC2133, section 6.1 */
		resv6 = bitset(RES_USE_INET6, _res.options);
		_res.options |= RES_USE_INET6;
	}
	SM_SET_H_ERRNO(0);
	h = gethostbyname(name);
	if (family == AF_INET6 && !resv6)
		_res.options &= ~RES_USE_INET6;

	/* the function is supposed to return only the requested family */
	if (h != NULL && h->h_addrtype != family)
	{
# if NETINET6
		freehostent(h);
# endif /* NETINET6 */
		h = NULL;
		*err = NO_DATA;
	}
	else
		*err = h_errno;
	return h;
}

void
freehostent(h)
	struct hostent *h;
{
	/*
	**  Stub routine -- if they don't have getipnodeby*(),
	**  they probably don't have the free routine either.
	*/

	return;
}
#else /* NEEDSGETIPNODE && NETINET6 */
#define sm_getipnodebyname getipnodebyname 
#endif /* NEEDSGETIPNODE && NETINET6 */

struct hostent *
mi_gethostbyname(name, family)
	char *name;
	int family;
{
	struct hostent *h = NULL;
#if (SOLARIS > 10000 && SOLARIS < 20400) || (defined(SOLARIS) && SOLARIS < 204) || (defined(sony_news) && defined(__svr4))
# if SOLARIS == 20300 || SOLARIS == 203
	static struct hostent hp;
	static char buf[1000];
	extern struct hostent *_switch_gethostbyname_r();

	h = _switch_gethostbyname_r(name, &hp, buf, sizeof(buf), &h_errno);
# else /* SOLARIS == 20300 || SOLARIS == 203 */
	extern struct hostent *__switch_gethostbyname();

	h = __switch_gethostbyname(name);
# endif /* SOLARIS == 20300 || SOLARIS == 203 */
#else /* (SOLARIS > 10000 && SOLARIS < 20400) || (defined(SOLARIS) && SOLARIS < 204) || (defined(sony_news) && defined(__svr4)) */
# if NETINET6
#  ifndef SM_IPNODEBYNAME_FLAGS
    /* For IPv4-mapped addresses, use: AI_DEFAULT|AI_ALL */
#   define SM_IPNODEBYNAME_FLAGS	AI_ADDRCONFIG
#  endif /* SM_IPNODEBYNAME_FLAGS */

	int flags = SM_IPNODEBYNAME_FLAGS;
	int err;
# endif /* NETINET6 */

# if NETINET6
#  if ADDRCONFIG_IS_BROKEN
	flags &= ~AI_ADDRCONFIG;
#  endif /* ADDRCONFIG_IS_BROKEN */
	h = sm_getipnodebyname(name, family, flags, &err);
	SM_SET_H_ERRNO(err);
# else /* NETINET6 */
	h = gethostbyname(name);
# endif /* NETINET6 */

#endif /* (SOLARIS > 10000 && SOLARIS < 20400) || (defined(SOLARIS) && SOLARIS < 204) || (defined(sony_news) && defined(__svr4)) */

	/* the function is supposed to return only the requested family */
	if (h != NULL && h->h_addrtype != family)
	{
# if NETINET6
		freehostent(h);
# endif /* NETINET6 */
		h = NULL;
		SM_SET_H_ERRNO(NO_DATA);
	}
	return h;
}

#if NETINET6
/*
**  MI_INET_PTON -- convert printed form to network address.
**
**	Wrapper for inet_pton() which handles IPv6: labels.
**
**	Parameters:
**		family -- address family
**		src -- string
**		dst -- destination address structure
**
**	Returns:
**		1 if the address was valid
**		0 if the address wasn't parseable
**		-1 if error
*/

int
mi_inet_pton(family, src, dst)
	int family;
	const char *src;
	void *dst;
{
	if (family == AF_INET6 &&
	    strncasecmp(src, "IPv6:", 5) == 0)
		src += 5;
	return inet_pton(family, src, dst);
}
#endif /* NETINET6 */
@


1.11
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.10
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2001, 2004, 2010, 2013 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sm_gethost.c,v 8.30 2013/02/22 22:43:33 gshapiro Exp $")
d65 12
a76 1
	*err = h_errno;
d135 10
@


1.9
log
@Update to sendmail 8.14.5
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2001, 2004, 2010 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sm_gethost.c,v 8.29 2010/07/27 01:09:31 ca Exp $")
d104 6
a109 1
	int flags = AI_DEFAULT|AI_ALL;
@


1.8
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2001, 2004 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sm_gethost.c,v 8.27 2004/08/20 21:12:37 ca Exp $")
d33 1
a33 1
static struct hostent *getipnodebyname __P((char *, int, int, int *));
d46 2
a47 2
getipnodebyname(name, family, flags, err)
	char *name;
d80 2
d112 1
a112 1
	h = getipnodebyname(name, family, flags, &err);
@


1.7
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sm_gethost.c,v 8.26 2001/09/11 04:04:45 gshapiro Exp $")
d18 1
d32 2
@


1.6
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sm_gethost.c,v 8.23 2001/07/21 00:05:06 gshapiro Exp $")
d19 1
a19 1
/*
@


1.5
log
@update to sendmail 8.11.5
@
text
@d11 2
a12 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: sm_gethost.c,v 8.7.8.11 2001/07/21 00:10:23 gshapiro Exp $";
#endif /* ! lint */
a13 1
#if _FFR_MILTER
d49 1
a49 1
	bool resv6 = TRUE;
a59 1
	*err = h_errno;
d62 1
a65 1
# if _FFR_FREEHOSTENT
a76 1
# endif /* _FFR_FREEHOSTENT */
d116 30
a145 1
#endif /* _FFR_MILTER */
@


1.4
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: sm_gethost.c,v 8.7.8.10 2001/05/09 20:57:12 gshapiro Exp $";
d34 3
a36 3
# ifndef AI_V4MAPPED
#  define AI_V4MAPPED	0	/* dummy */
# endif /* ! AI_V4MAPPED */
d40 3
d103 1
d108 4
a111 1
	h = getipnodebyname(name, family, AI_V4MAPPED|AI_ALL, &err);
@


1.3
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: sm_gethost.c,v 8.7.8.6 2001/02/14 04:07:23 gshapiro Exp $";
d32 1
a32 1
#if NETINET6 && NEEDSGETIPNODE && __RES < 19990909
d78 1
a78 1
#endif /* NEEDSGETIPNODE && NETINET6 && __RES < 19990909 */
@


1.3.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: sm_gethost.c,v 8.7.8.10 2001/05/09 20:57:12 gshapiro Exp $";
d32 1
a32 1
#if NETINET6 && NEEDSGETIPNODE
d78 1
a78 1
#endif /* NEEDSGETIPNODE && NETINET6 */
@


1.2
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2000 Sendmail, Inc. and its suppliers.
d12 1
a12 1
static char id[] = "@@(#)$Sendmail: sm_gethost.c,v 8.7.8.4 2000/12/19 04:26:33 gshapiro Exp $";
d57 1
a57 1
	h_errno = 0;
d105 1
a105 1
	h_errno = err;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 *  Copyright (c) 1999 Sendmail, Inc. and its suppliers.
d12 1
a12 1
static char id[] = "@@(#)$Sendmail: sm_gethost.c,v 8.7 2000/01/20 21:51:52 geir Exp $";
d42 1
a42 1
mi_getipnodebyname(name, family, flags, err)
d64 14
d104 1
a104 1
	h = mi_getipnodebyname(name, family, AI_V4MAPPED|AI_ALL, &err);
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.1.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d12 1
a12 1
static char id[] = "@@(#)$Sendmail: sm_gethost.c,v 8.7.8.10 2001/05/09 20:57:12 gshapiro Exp $";
d32 1
a32 1
#if NETINET6 && NEEDSGETIPNODE
d42 1
a42 1
getipnodebyname(name, family, flags, err)
d57 1
a57 1
	SM_SET_H_ERRNO(0);
d64 1
a64 15

# if _FFR_FREEHOSTENT
void
freehostent(h)
	struct hostent *h;
{
	/*
	**  Stub routine -- if they don't have getipnodeby*(),
	**  they probably don't have the free routine either.
	*/

	return;
}
# endif /* _FFR_FREEHOSTENT */
#endif /* NEEDSGETIPNODE && NETINET6 */
d90 2
a91 2
	h = getipnodebyname(name, family, AI_V4MAPPED|AI_ALL, &err);
	SM_SET_H_ERRNO(err);
@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2000 Sendmail, Inc. and its suppliers.
d12 1
a12 1
static char id[] = "@@(#)$Id: sm_gethost.c,v 8.7.8.4 2000/12/19 04:26:33 gshapiro Exp $";
d42 1
a42 1
getipnodebyname(name, family, flags, err)
a63 14

# if _FFR_FREEHOSTENT
void
freehostent(h)
	struct hostent *h;
{
	/*
	**  Stub routine -- if they don't have getipnodeby*(),
	**  they probably don't have the free routine either.
	*/

	return;
}
# endif /* _FFR_FREEHOSTENT */
d90 1
a90 1
	h = getipnodebyname(name, family, AI_V4MAPPED|AI_ALL, &err);
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d11 3
a13 2
#include <sm/gen.h>
SM_RCSID("@@(#)$Sendmail: sm_gethost.c,v 8.23 2001/07/21 00:05:06 gshapiro Exp $")
d15 1
d32 1
a32 1
#if NETINET6 && NEEDSGETIPNODE
d34 3
a36 3
# ifndef AI_ADDRCONFIG
#  define AI_ADDRCONFIG	0	/* dummy */
# endif /* ! AI_ADDRCONFIG */
a39 3
# ifndef AI_DEFAULT
#  define AI_DEFAULT	0	/* dummy */
# endif /* ! AI_DEFAULT */
d48 1
a48 1
	bool resv6 = true;
d57 1
a57 1
	SM_SET_H_ERRNO(0);
d59 1
a61 1
	*err = h_errno;
d65 1
d77 2
a78 1
#endif /* NEEDSGETIPNODE && NETINET6 */
a99 1
	int flags = AI_DEFAULT|AI_ALL;
d104 2
a105 5
#  if ADDRCONFIG_IS_BROKEN
	flags &= ~AI_ADDRCONFIG;
#  endif /* ADDRCONFIG_IS_BROKEN */
	h = getipnodebyname(name, family, flags, &err);
	SM_SET_H_ERRNO(err);
d113 1
a113 30

#if NETINET6
/*
**  MI_INET_PTON -- convert printed form to network address.
**
**	Wrapper for inet_pton() which handles IPv6: labels.
**
**	Parameters:
**		family -- address family
**		src -- string
**		dst -- destination address structure
**
**	Returns:
**		1 if the address was valid
**		0 if the address wasn't parseable
**		-1 if error
*/

int
mi_inet_pton(family, src, dst)
	int family;
	const char *src;
	void *dst;
{
	if (family == AF_INET6 &&
	    strncasecmp(src, "IPv6:", 5) == 0)
		src += 5;
	return inet_pton(family, src, dst);
}
#endif /* NETINET6 */
@


