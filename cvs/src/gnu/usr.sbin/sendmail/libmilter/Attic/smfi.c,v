head	1.15;
access;
symbols
	OPENBSD_5_6:1.14.0.6
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.22
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.20
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.18
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.16
	OPENBSD_5_0:1.13.0.14
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.12
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.10
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.6
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.8
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.4
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.6
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.4
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.8.0.8
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2014.09.17.18.49.50;	author matthieu;	state dead;
branches;
next	1.14;
commitid	M7i5giHIoz3DMlTU;

1.14
date	2014.02.07.21.24.59;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.22.18.43.54;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.16.00.21.30;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.24.03.59.25;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.03.17.25.46;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.18.00.49.27;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.20.01.31.38;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.15.21.09.03;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.43;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.52;	author millert;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	2001.05.31.00.28.51;	author miod;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Bye.
@
text
@/*
 *  Copyright (c) 1999-2007 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sm/gen.h>
SM_RCSID("@@(#)$Sendmail: smfi.c,v 8.84 2013/11/22 20:51:36 ca Exp $")
#include <sm/varargs.h>
#include "libmilter.h"

static int smfi_header __P((SMFICTX *, int, int, char *, char *));
static int myisenhsc __P((const char *, int));

/* for smfi_set{ml}reply, let's be generous. 256/16 should be sufficient */
#define MAXREPLYLEN	980	/* max. length of a reply string */
#define MAXREPLIES	32	/* max. number of reply strings */

/*
**  SMFI_HEADER -- send a header to the MTA
**
**	Parameters:
**		ctx -- Opaque context structure
**		cmd -- Header modification command
**		hdridx -- Header index
**		headerf -- Header field name
**		headerv -- Header field value
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

static int
smfi_header(ctx, cmd, hdridx, headerf, headerv)
	SMFICTX *ctx;
	int cmd;
	int hdridx;
	char *headerf;
	char *headerv;
{
	size_t len, l1, l2, offset;
	int r;
	mi_int32 v;
	char *buf;
	struct timeval timeout;

	if (headerf == NULL || *headerf == '\0' || headerv == NULL)
		return MI_FAILURE;
	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;
	l1 = strlen(headerf) + 1;
	l2 = strlen(headerv) + 1;
	len = l1 + l2;
	if (hdridx >= 0)
		len += MILTER_LEN_BYTES;
	buf = malloc(len);
	if (buf == NULL)
		return MI_FAILURE;
	offset = 0;
	if (hdridx >= 0)
	{
		v = htonl(hdridx);
		(void) memcpy(&(buf[0]), (void *) &v, MILTER_LEN_BYTES);
		offset += MILTER_LEN_BYTES;
	}
	(void) memcpy(buf + offset, headerf, l1);
	(void) memcpy(buf + offset + l1, headerv, l2);
	r = mi_wr_cmd(ctx->ctx_sd, &timeout, cmd, buf, len);
	free(buf);
	return r;
}

/*
**  SMFI_ADDHEADER -- send a new header to the MTA
**
**	Parameters:
**		ctx -- Opaque context structure
**		headerf -- Header field name
**		headerv -- Header field value
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_addheader(ctx, headerf, headerv)
	SMFICTX *ctx;
	char *headerf;
	char *headerv;
{
	if (!mi_sendok(ctx, SMFIF_ADDHDRS))
		return MI_FAILURE;

	return smfi_header(ctx, SMFIR_ADDHEADER, -1, headerf, headerv);
}

/*
**  SMFI_INSHEADER -- send a new header to the MTA (to be inserted)
**
**	Parameters:
**		ctx -- Opaque context structure
**  		hdridx -- index into header list where insertion should occur
**		headerf -- Header field name
**		headerv -- Header field value
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_insheader(ctx, hdridx, headerf, headerv)
	SMFICTX *ctx;
	int hdridx;
	char *headerf;
	char *headerv;
{
	if (!mi_sendok(ctx, SMFIF_ADDHDRS) || hdridx < 0)
		return MI_FAILURE;

	return smfi_header(ctx, SMFIR_INSHEADER, hdridx, headerf, headerv);
}

/*
**  SMFI_CHGHEADER -- send a changed header to the MTA
**
**	Parameters:
**		ctx -- Opaque context structure
**		headerf -- Header field name
**		hdridx -- Header index value
**		headerv -- Header field value
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_chgheader(ctx, headerf, hdridx, headerv)
	SMFICTX *ctx;
	char *headerf;
	mi_int32 hdridx;
	char *headerv;
{
	if (!mi_sendok(ctx, SMFIF_CHGHDRS) || hdridx < 0)
		return MI_FAILURE;
	if (headerv == NULL)
		headerv = "";

	return smfi_header(ctx, SMFIR_CHGHEADER, hdridx, headerf, headerv);
}

#if 0
/*
**  BUF_CRT_SEND -- construct buffer to send from arguments
**
**	Parameters:
**		ctx -- Opaque context structure
**		cmd -- command
**		arg0 -- first argument
**		argv -- list of arguments (NULL terminated)
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

static int
buf_crt_send __P((SMFICTX *, int cmd, char *, char **));

static int
buf_crt_send(ctx, cmd, arg0, argv)
	SMFICTX *ctx;
	int cmd;
	char *arg0;
	char **argv;
{
	size_t len, l0, l1, offset;
	int r;
	char *buf, *arg, **argvl;
	struct timeval timeout;

	if (arg0 == NULL || *arg0 == '\0')
		return MI_FAILURE;
	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;
	l0 = strlen(arg0) + 1;
	len = l0;
	argvl = argv;
	while (argvl != NULL && (arg = *argv) != NULL && *arg != '\0')
	{
		l1 = strlen(arg) + 1;
		len += l1;
		SM_ASSERT(len > l1);
	}

	buf = malloc(len);
	if (buf == NULL)
		return MI_FAILURE;
	(void) memcpy(buf, arg0, l0);
	offset = l0;

	argvl = argv;
	while (argvl != NULL && (arg = *argv) != NULL && *arg != '\0')
	{
		l1 = strlen(arg) + 1;
		SM_ASSERT(offset < len);
		SM_ASSERT(offset + l1 <= len);
		(void) memcpy(buf + offset, arg, l1);
		offset += l1;
		SM_ASSERT(offset > l1);
	}

	r = mi_wr_cmd(ctx->ctx_sd, &timeout, cmd, buf, len);
	free(buf);
	return r;
}
#endif /* 0 */

/*
**  SEND2 -- construct buffer to send from arguments
**
**	Parameters:
**		ctx -- Opaque context structure
**		cmd -- command
**		arg0 -- first argument
**		argv -- list of arguments (NULL terminated)
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

static int
send2 __P((SMFICTX *, int cmd, char *, char *));

static int
send2(ctx, cmd, arg0, arg1)
	SMFICTX *ctx;
	int cmd;
	char *arg0;
	char *arg1;
{
	size_t len, l0, l1, offset;
	int r;
	char *buf;
	struct timeval timeout;

	if (arg0 == NULL || *arg0 == '\0')
		return MI_FAILURE;
	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;
	l0 = strlen(arg0) + 1;
	len = l0;
	if (arg1 != NULL)
	{
		l1 = strlen(arg1) + 1;
		len += l1;
		SM_ASSERT(len > l1);
	}

	buf = malloc(len);
	if (buf == NULL)
		return MI_FAILURE;
	(void) memcpy(buf, arg0, l0);
	offset = l0;

	if (arg1 != NULL)
	{
		l1 = strlen(arg1) + 1;
		SM_ASSERT(offset < len);
		SM_ASSERT(offset + l1 <= len);
		(void) memcpy(buf + offset, arg1, l1);
		offset += l1;
		SM_ASSERT(offset > l1);
	}

	r = mi_wr_cmd(ctx->ctx_sd, &timeout, cmd, buf, len);
	free(buf);
	return r;
}

/*
**  SMFI_CHGFROM -- change enveloper sender ("from") address
**
**	Parameters:
**		ctx -- Opaque context structure
**		from -- new envelope sender address ("MAIL From")
**		args -- ESMTP arguments
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_chgfrom(ctx, from, args)
	SMFICTX *ctx;
	char *from;
	char *args;
{
	if (from == NULL || *from == '\0')
		return MI_FAILURE;
	if (!mi_sendok(ctx, SMFIF_CHGFROM))
		return MI_FAILURE;
	return send2(ctx, SMFIR_CHGFROM, from, args);
}

/*
**  SMFI_SETSYMLIST -- set list of macros that the MTA should send.
**
**	Parameters:
**		ctx -- Opaque context structure
**		where -- SMTP stage
**		macros -- list of macros
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_setsymlist(ctx, where, macros)
	SMFICTX *ctx;
	int where;
	char *macros;
{
	SM_ASSERT(ctx != NULL);

	if (macros == NULL || *macros == '\0')
		return MI_FAILURE;
	if (where < SMFIM_FIRST || where > SMFIM_LAST)
		return MI_FAILURE;
	if (where < 0 || where >= MAX_MACROS_ENTRIES)
		return MI_FAILURE;

	if (ctx->ctx_mac_list[where] != NULL)
		return MI_FAILURE;

	ctx->ctx_mac_list[where] = strdup(macros);
	if (ctx->ctx_mac_list[where] == NULL)
		return MI_FAILURE;

	return MI_SUCCESS;
}

/*
**  SMFI_ADDRCPT_PAR -- send an additional recipient to the MTA
**
**	Parameters:
**		ctx -- Opaque context structure
**		rcpt -- recipient address
**		args -- ESMTP arguments
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_addrcpt_par(ctx, rcpt, args)
	SMFICTX *ctx;
	char *rcpt;
	char *args;
{
	if (rcpt == NULL || *rcpt == '\0')
		return MI_FAILURE;
	if (!mi_sendok(ctx, SMFIF_ADDRCPT_PAR))
		return MI_FAILURE;
	return send2(ctx, SMFIR_ADDRCPT_PAR, rcpt, args);
}

/*
**  SMFI_ADDRCPT -- send an additional recipient to the MTA
**
**	Parameters:
**		ctx -- Opaque context structure
**		rcpt -- recipient address
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_addrcpt(ctx, rcpt)
	SMFICTX *ctx;
	char *rcpt;
{
	size_t len;
	struct timeval timeout;

	if (rcpt == NULL || *rcpt == '\0')
		return MI_FAILURE;
	if (!mi_sendok(ctx, SMFIF_ADDRCPT))
		return MI_FAILURE;
	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;
	len = strlen(rcpt) + 1;
	return mi_wr_cmd(ctx->ctx_sd, &timeout, SMFIR_ADDRCPT, rcpt, len);
}

/*
**  SMFI_DELRCPT -- send a recipient to be removed to the MTA
**
**	Parameters:
**		ctx -- Opaque context structure
**		rcpt -- recipient address
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_delrcpt(ctx, rcpt)
	SMFICTX *ctx;
	char *rcpt;
{
	size_t len;
	struct timeval timeout;

	if (rcpt == NULL || *rcpt == '\0')
		return MI_FAILURE;
	if (!mi_sendok(ctx, SMFIF_DELRCPT))
		return MI_FAILURE;
	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;
	len = strlen(rcpt) + 1;
	return mi_wr_cmd(ctx->ctx_sd, &timeout, SMFIR_DELRCPT, rcpt, len);
}

/*
**  SMFI_REPLACEBODY -- send a body chunk to the MTA
**
**	Parameters:
**		ctx -- Opaque context structure
**		bodyp -- body chunk
**		bodylen -- length of body chunk
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_replacebody(ctx, bodyp, bodylen)
	SMFICTX *ctx;
	unsigned char *bodyp;
	int bodylen;
{
	int len, off, r;
	struct timeval timeout;

	if (bodylen < 0 ||
	    (bodyp == NULL && bodylen > 0))
		return MI_FAILURE;
	if (!mi_sendok(ctx, SMFIF_CHGBODY))
		return MI_FAILURE;
	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;

	/* split body chunk if necessary */
	off = 0;
	do
	{
		len = (bodylen >= MILTER_CHUNK_SIZE) ? MILTER_CHUNK_SIZE :
						       bodylen;
		if ((r = mi_wr_cmd(ctx->ctx_sd, &timeout, SMFIR_REPLBODY,
				(char *) (bodyp + off), len)) != MI_SUCCESS)
			return r;
		off += len;
		bodylen -= len;
	} while (bodylen > 0);
	return MI_SUCCESS;
}

/*
**  SMFI_QUARANTINE -- quarantine an envelope
**
**	Parameters:
**		ctx -- Opaque context structure
**		reason -- why?
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_quarantine(ctx, reason)
	SMFICTX *ctx;
	char *reason;
{
	size_t len;
	int r;
	char *buf;
	struct timeval timeout;

	if (reason == NULL || *reason == '\0')
		return MI_FAILURE;
	if (!mi_sendok(ctx, SMFIF_QUARANTINE))
		return MI_FAILURE;
	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;
	len = strlen(reason) + 1;
	buf = malloc(len);
	if (buf == NULL)
		return MI_FAILURE;
	(void) memcpy(buf, reason, len);
	r = mi_wr_cmd(ctx->ctx_sd, &timeout, SMFIR_QUARANTINE, buf, len);
	free(buf);
	return r;
}

/*
**  MYISENHSC -- check whether a string contains an enhanced status code
**
**	Parameters:
**		s -- string with possible enhanced status code.
**		delim -- delim for enhanced status code.
**
**	Returns:
**		0  -- no enhanced status code.
**		>4 -- length of enhanced status code.
**
**	Side Effects:
**		none.
*/

static int
myisenhsc(s, delim)
	const char *s;
	int delim;
{
	int l, h;

	if (s == NULL)
		return 0;
	if (!((*s == '2' || *s == '4' || *s == '5') && s[1] == '.'))
		return 0;
	h = 0;
	l = 2;
	while (h < 3 && isascii(s[l + h]) && isdigit(s[l + h]))
		++h;
	if (h == 0 || s[l + h] != '.')
		return 0;
	l += h + 1;
	h = 0;
	while (h < 3 && isascii(s[l + h]) && isdigit(s[l + h]))
		++h;
	if (h == 0 || s[l + h] != delim)
		return 0;
	return l + h;
}

/*
**  SMFI_SETREPLY -- set the reply code for the next reply to the MTA
**
**	Parameters:
**		ctx -- Opaque context structure
**		rcode -- The three-digit (RFC 821) SMTP reply code.
**		xcode -- The extended (RFC 2034) reply code.
**		message -- The text part of the SMTP reply.
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_setreply(ctx, rcode, xcode, message)
	SMFICTX *ctx;
	char *rcode;
	char *xcode;
	char *message;
{
	size_t len;
	char *buf;

	if (rcode == NULL || ctx == NULL)
		return MI_FAILURE;

	/* ### <sp> \0 */
	len = strlen(rcode) + 2;
	if (len != 5)
		return MI_FAILURE;
	if ((rcode[0] != '4' && rcode[0] != '5') ||
	    !isascii(rcode[1]) || !isdigit(rcode[1]) ||
	    !isascii(rcode[2]) || !isdigit(rcode[2]))
		return MI_FAILURE;
	if (xcode != NULL)
	{
		if (!myisenhsc(xcode, '\0'))
			return MI_FAILURE;
		len += strlen(xcode) + 1;
	}
	if (message != NULL)
	{
		size_t ml;

		/* XXX check also for unprintable chars? */
		if (strpbrk(message, "\r\n") != NULL)
			return MI_FAILURE;
		ml = strlen(message);
		if (ml > MAXREPLYLEN)
			return MI_FAILURE;
		len += ml + 1;
	}
	buf = malloc(len);
	if (buf == NULL)
		return MI_FAILURE;		/* oops */
	(void) sm_strlcpy(buf, rcode, len);
	(void) sm_strlcat(buf, " ", len);
	if (xcode != NULL)
		(void) sm_strlcat(buf, xcode, len);
	if (message != NULL)
	{
		if (xcode != NULL)
			(void) sm_strlcat(buf, " ", len);
		(void) sm_strlcat(buf, message, len);
	}
	if (ctx->ctx_reply != NULL)
		free(ctx->ctx_reply);
	ctx->ctx_reply = buf;
	return MI_SUCCESS;
}

/*
**  SMFI_SETMLREPLY -- set multiline reply code for the next reply to the MTA
**
**	Parameters:
**		ctx -- Opaque context structure
**		rcode -- The three-digit (RFC 821) SMTP reply code.
**		xcode -- The extended (RFC 2034) reply code.
**		txt, ... -- The text part of the SMTP reply,
**			MUST be terminated with NULL.
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
#if SM_VA_STD
smfi_setmlreply(SMFICTX *ctx, const char *rcode, const char *xcode, ...)
#else /* SM_VA_STD */
smfi_setmlreply(ctx, rcode, xcode, va_alist)
	SMFICTX *ctx;
	const char *rcode;
	const char *xcode;
	va_dcl
#endif /* SM_VA_STD */
{
	size_t len;
	size_t rlen;
	int args;
	char *buf, *txt;
	const char *xc;
	char repl[16];
	SM_VA_LOCAL_DECL

	if (rcode == NULL || ctx == NULL)
		return MI_FAILURE;

	/* ### <sp> */
	len = strlen(rcode) + 1;
	if (len != 4)
		return MI_FAILURE;
	if ((rcode[0] != '4' && rcode[0] != '5') ||
	    !isascii(rcode[1]) || !isdigit(rcode[1]) ||
	    !isascii(rcode[2]) || !isdigit(rcode[2]))
		return MI_FAILURE;
	if (xcode != NULL)
	{
		if (!myisenhsc(xcode, '\0'))
			return MI_FAILURE;
		xc = xcode;
	}
	else
	{
		if (rcode[0] == '4')
			xc = "4.0.0";
		else
			xc = "5.0.0";
	}

	/* add trailing space */
	len += strlen(xc) + 1;
	rlen = len;
	args = 0;
	SM_VA_START(ap, xcode);
	while ((txt = SM_VA_ARG(ap, char *)) != NULL)
	{
		size_t tl;

		tl = strlen(txt);
		if (tl > MAXREPLYLEN)
			break;

		/* this text, reply codes, \r\n */
		len += tl + 2 + rlen;
		if (++args > MAXREPLIES)
			break;

		/* XXX check also for unprintable chars? */
		if (strpbrk(txt, "\r\n") != NULL)
			break;
	}
	SM_VA_END(ap);
	if (txt != NULL)
		return MI_FAILURE;

	/* trailing '\0' */
	++len;
	buf = malloc(len);
	if (buf == NULL)
		return MI_FAILURE;		/* oops */
	(void) sm_strlcpyn(buf, len, 3, rcode, args == 1 ? " " : "-", xc);
	(void) sm_strlcpyn(repl, sizeof repl, 4, rcode, args == 1 ? " " : "-",
			   xc, " ");
	SM_VA_START(ap, xcode);
	txt = SM_VA_ARG(ap, char *);
	if (txt != NULL)
	{
		(void) sm_strlcat2(buf, " ", txt, len);
		while ((txt = SM_VA_ARG(ap, char *)) != NULL)
		{
			if (--args <= 1)
				repl[3] = ' ';
			(void) sm_strlcat2(buf, "\r\n", repl, len);
			(void) sm_strlcat(buf, txt, len);
		}
	}
	if (ctx->ctx_reply != NULL)
		free(ctx->ctx_reply);
	ctx->ctx_reply = buf;
	SM_VA_END(ap);
	return MI_SUCCESS;
}

/*
**  SMFI_SETPRIV -- set private data
**
**	Parameters:
**		ctx -- Opaque context structure
**		privatedata -- pointer to private data
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_setpriv(ctx, privatedata)
	SMFICTX *ctx;
	void *privatedata;
{
	if (ctx == NULL)
		return MI_FAILURE;
	ctx->ctx_privdata = privatedata;
	return MI_SUCCESS;
}

/*
**  SMFI_GETPRIV -- get private data
**
**	Parameters:
**		ctx -- Opaque context structure
**
**	Returns:
**		pointer to private data
*/

void *
smfi_getpriv(ctx)
	SMFICTX *ctx;
{
	if (ctx == NULL)
		return NULL;
	return ctx->ctx_privdata;
}

/*
**  SMFI_GETSYMVAL -- get the value of a macro
**
**	See explanation in mfapi.h about layout of the structures.
**
**	Parameters:
**		ctx -- Opaque context structure
**		symname -- name of macro
**
**	Returns:
**		value of macro (NULL in case of failure)
*/

char *
smfi_getsymval(ctx, symname)
	SMFICTX *ctx;
	char *symname;
{
	int i;
	char **s;
	char one[2];
	char braces[4];

	if (ctx == NULL || symname == NULL || *symname == '\0')
		return NULL;

	if (strlen(symname) == 3 && symname[0] == '{' && symname[2] == '}')
	{
		one[0] = symname[1];
		one[1] = '\0';
	}
	else
		one[0] = '\0';
	if (strlen(symname) == 1)
	{
		braces[0] = '{';
		braces[1] = *symname;
		braces[2] = '}';
		braces[3] = '\0';
	}
	else
		braces[0] = '\0';

	/* search backwards through the macro array */
	for (i = MAX_MACROS_ENTRIES - 1 ; i >= 0; --i)
	{
		if ((s = ctx->ctx_mac_ptr[i]) == NULL ||
		    ctx->ctx_mac_buf[i] == NULL)
			continue;
		while (s != NULL && *s != NULL)
		{
			if (strcmp(*s, symname) == 0)
				return *++s;
			if (one[0] != '\0' && strcmp(*s, one) == 0)
				return *++s;
			if (braces[0] != '\0' && strcmp(*s, braces) == 0)
				return *++s;
			++s;	/* skip over macro value */
			++s;	/* points to next macro name */
		}
	}
	return NULL;
}

/*
**  SMFI_PROGRESS -- send "progress" message to the MTA to prevent premature
**		     timeouts during long milter-side operations
**
**	Parameters:
**		ctx -- Opaque context structure
**
**	Return value:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_progress(ctx)
	SMFICTX *ctx;
{
	struct timeval timeout;

	if (ctx == NULL)
		return MI_FAILURE;

	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;

	return mi_wr_cmd(ctx->ctx_sd, &timeout, SMFIR_PROGRESS, NULL, 0);
}

/*
**  SMFI_VERSION -- return (runtime) version of libmilter
**
**	Parameters:
**		major -- (pointer to) major version
**		minor -- (pointer to) minor version
**		patchlevel -- (pointer to) patchlevel version
**
**	Return value:
**		MI_SUCCESS
*/

int
smfi_version(major, minor, patchlevel)
	unsigned int *major;
	unsigned int *minor;
	unsigned int *patchlevel;
{
	if (major != NULL)
		*major = SM_LM_VRS_MAJOR(SMFI_VERSION);
	if (minor != NULL)
		*minor = SM_LM_VRS_MINOR(SMFI_VERSION);
	if (patchlevel != NULL)
		*patchlevel = SM_LM_VRS_PLVL(SMFI_VERSION);
	return MI_SUCCESS;
}
@


1.14
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.13
log
@Update to sendmail-8.14.3
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2007 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: smfi.c,v 8.83 2007/04/23 16:44:39 ca Exp $")
@


1.12
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2006 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: smfi.c,v 8.82 2007/01/20 06:37:19 ca Exp $")
d887 1
a887 1
		*patchlevel = SM_LM_VRS_MINOR(SMFI_VERSION);
@


1.11
log
@Update to sendmail 8.13.6
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2005 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: smfi.c,v 8.74 2005/03/30 00:44:07 ca Exp $")
a32 1
**
d155 215
d862 27
@


1.10
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2004 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: smfi.c,v 8.73 2004/09/20 21:26:57 ca Exp $")
d245 1
a245 1
	while (bodylen > 0)
d254 1
a254 1
	}
@


1.9
log
@Update to sendmail.8.13.0
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: smfi.c,v 8.72 2004/05/05 00:07:21 msk Exp $")
d17 1
@


1.8
log
@Update to sendmail-8.12.4
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2002 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: smfi.c,v 8.64 2002/04/30 22:22:02 msk Exp $")
d16 2
d23 1
a23 1
**  SMFI_ADDHEADER -- send a new header to the MTA
d27 2
d32 1
d37 2
a38 2
int
smfi_addheader(ctx, headerf, headerv)
d40 2
d45 1
a45 2
	/* do we want to copy the stuff or have a special mi_wr_cmd call? */
	size_t len, l1, l2;
d47 1
a52 2
	if (!mi_sendok(ctx, SMFIF_ADDHDRS))
		return MI_FAILURE;
d55 5
a59 3
	l1 = strlen(headerf);
	l2 = strlen(headerv);
	len = l1 + l2 + 2;
d63 10
a72 3
	(void) memcpy(buf, headerf, l1 + 1);
	(void) memcpy(buf + l1 + 1, headerv, l2 + 1);
	r = mi_wr_cmd(ctx->ctx_sd, &timeout, SMFIR_ADDHEADER, buf, len);
d78 50
d147 1
a147 12
	/* do we want to copy the stuff or have a special mi_wr_cmd call? */
	size_t len, l1, l2;
	int r;
	mi_int32 v;
	char *buf;
	struct timeval timeout;

	if (headerf == NULL || *headerf == '\0')
		return MI_FAILURE;
	if (hdridx < 0)
		return MI_FAILURE;
	if (!mi_sendok(ctx, SMFIF_CHGHDRS))
a148 2
	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;
d151 2
a152 13
	l1 = strlen(headerf);
	l2 = strlen(headerv);
	len = l1 + l2 + 2 + MILTER_LEN_BYTES;
	buf = malloc(len);
	if (buf == NULL)
		return MI_FAILURE;
	v = htonl(hdridx);
	(void) memcpy(&(buf[0]), (void *) &v, MILTER_LEN_BYTES);
	(void) memcpy(buf + MILTER_LEN_BYTES, headerf, l1 + 1);
	(void) memcpy(buf + MILTER_LEN_BYTES + l1 + 1, headerv, l2 + 1);
	r = mi_wr_cmd(ctx->ctx_sd, &timeout, SMFIR_CHGHEADER, buf, len);
	free(buf);
	return r;
a256 1
#if _FFR_QUARANTINE
a292 1
#endif /* _FFR_QUARANTINE */
a405 1
#if _FFR_MULTILINE
a516 1
#endif /* _FFR_MULTILINE */
a622 1
#if _FFR_SMFI_PROGRESS
a647 1
#endif /* _FFR_SMFI_PROGRESS */
@


1.7
log
@update to sendmail 8.12.3
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: smfi.c,v 8.63 2002/02/07 01:16:13 msk Exp $")
d270 1
@


1.6
log
@Add missing va_end() calls, patch sent to sendmail folks.
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: smfi.c,v 8.57 2001/11/20 18:47:49 ca Exp $")
d114 1
d143 1
d172 1
d216 1
d502 1
d521 1
d585 28
@


1.5
log
@update to sendmail-8.12.2
@
text
@d433 1
a433 1
			return MI_FAILURE;
d438 1
a438 1
			return MI_FAILURE;
d442 1
a442 1
			return MI_FAILURE;
d445 2
@


1.4
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d12 3
a14 1
SM_RCSID("@@(#)$Sendmail: smfi.c,v 8.46 2001/09/11 04:04:45 gshapiro Exp $")
d16 3
a18 1
#include "libmilter.h"
d241 1
a241 1
	len = strlen(reason);
d245 1
a245 1
	(void) memcpy(buf, reason, len + 1);
d291 1
d327 3
d331 1
d333 11
a343 1
		len += strlen(message) + 1;
a349 3
	{
		if (!myisenhsc(xcode, '\0'))
			return MI_FAILURE;
a350 1
	}
d362 113
@


1.3
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: smfi.c,v 8.42 2001/08/27 18:09:16 gshapiro Exp $")
d110 1
a110 1
/*
d138 1
a138 1
/*
d166 1
a166 1
/*
d209 40
a248 1
/*
d287 1
a287 1
/*
d347 1
a347 1
/*
d368 1
a368 1
/*
d386 1
a386 1
/*
@


1.2
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2000 Sendmail, Inc. and its suppliers.
d11 2
a12 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: smfi.c,v 8.28.4.6 2000/06/28 23:48:56 gshapiro Exp $";
#endif /* ! lint */
a13 1
#if _FFR_MILTER
a14 1
#include "sendmail/useful.h"
d181 1
a181 1
	u_char *bodyp;
d187 2
a188 1
	if (bodyp == NULL && bodylen > 0)
d268 1
a268 1
	size_t len, l1, l2, l3;
d273 4
a276 2
	l1 = strlen(rcode) + 1;
	if (l1 != 4)
d282 4
a285 5
	l2 = xcode == NULL ? 1 : strlen(xcode) + 1;
	if (xcode != NULL && !myisenhsc(xcode, '\0'))
		return MI_FAILURE;
	l3 = message == NULL ? 1 : strlen(message) + 1;
	len = l1 + l2 + l3;
d289 14
a302 3
	(void) snprintf(buf, len, "%s %s %s", rcode,
			xcode == NULL ? "" : xcode,
			message == NULL ? "" : message);
a409 1
#endif /* _FFR_MILTER */
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: smfi.c,v 8.28 2000/02/26 01:32:15 gshapiro Exp $";
d43 1
a43 1
	if (headerf == NULL || headerv == NULL)
d45 1
a45 1
	if (!mi_sendok(ctx, SMFIF_MODHDRS))
d57 53
a109 1
	r = mi_wr_cmd(ctx->ctx_fd, &timeout, SMFIR_ADDHEADER, buf, len);
d132 1
a132 1
	if (rcpt == NULL)
d139 1
a139 1
	return mi_wr_cmd(ctx->ctx_fd, &timeout, SMFIR_ADDRCPT, rcpt, len);
d160 1
a160 1
	if (rcpt == NULL)
d167 1
a167 1
	return mi_wr_cmd(ctx->ctx_fd, &timeout, SMFIR_DELRCPT, rcpt, len);
d192 1
a192 1
	if (!mi_sendok(ctx, SMFIF_MODBODY))
d203 1
a203 1
		if ((r = mi_wr_cmd(ctx->ctx_fd, &timeout, SMFIR_REPLBODY,
d357 2
d363 17
d389 4
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.1.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: smfi.c,v 8.28.4.6 2000/06/28 23:48:56 gshapiro Exp $";
d43 1
a43 1
	if (headerf == NULL || *headerf == '\0' || headerv == NULL)
d45 1
a45 1
	if (!mi_sendok(ctx, SMFIF_ADDHDRS))
d57 1
a57 53
	r = mi_wr_cmd(ctx->ctx_sd, &timeout, SMFIR_ADDHEADER, buf, len);
	free(buf);
	return r;
}

/*
**  SMFI_CHGHEADER -- send a changed header to the MTA
**
**	Parameters:
**		ctx -- Opaque context structure
**		headerf -- Header field name
**		hdridx -- Header index value
**		headerv -- Header field value
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_chgheader(ctx, headerf, hdridx, headerv)
	SMFICTX *ctx;
	char *headerf;
	mi_int32 hdridx;
	char *headerv;
{
	/* do we want to copy the stuff or have a special mi_wr_cmd call? */
	size_t len, l1, l2;
	int r;
	mi_int32 v;
	char *buf;
	struct timeval timeout;

	if (headerf == NULL || *headerf == '\0')
		return MI_FAILURE;
	if (hdridx < 0)
		return MI_FAILURE;
	if (!mi_sendok(ctx, SMFIF_CHGHDRS))
		return MI_FAILURE;
	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;
	if (headerv == NULL)
		headerv = "";
	l1 = strlen(headerf);
	l2 = strlen(headerv);
	len = l1 + l2 + 2 + MILTER_LEN_BYTES;
	buf = malloc(len);
	if (buf == NULL)
		return MI_FAILURE;
	v = htonl(hdridx);
	(void) memcpy(&(buf[0]), (void *) &v, MILTER_LEN_BYTES);
	(void) memcpy(buf + MILTER_LEN_BYTES, headerf, l1 + 1);
	(void) memcpy(buf + MILTER_LEN_BYTES + l1 + 1, headerv, l2 + 1);
	r = mi_wr_cmd(ctx->ctx_sd, &timeout, SMFIR_CHGHEADER, buf, len);
d80 1
a80 1
	if (rcpt == NULL || *rcpt == '\0')
d87 1
a87 1
	return mi_wr_cmd(ctx->ctx_sd, &timeout, SMFIR_ADDRCPT, rcpt, len);
d108 1
a108 1
	if (rcpt == NULL || *rcpt == '\0')
d115 1
a115 1
	return mi_wr_cmd(ctx->ctx_sd, &timeout, SMFIR_DELRCPT, rcpt, len);
d140 1
a140 1
	if (!mi_sendok(ctx, SMFIF_CHGBODY))
d151 1
a151 1
		if ((r = mi_wr_cmd(ctx->ctx_sd, &timeout, SMFIR_REPLBODY,
a304 2
	char one[2];
	char braces[4];
a308 17
	if (strlen(symname) == 3 && symname[0] == '{' && symname[2] == '}')
	{
		one[0] = symname[1];
		one[1] = '\0';
	}
	else
		one[0] = '\0';
	if (strlen(symname) == 1)
	{
		braces[0] = '{';
		braces[1] = *symname;
		braces[2] = '}';
		braces[3] = '\0';
	}
	else
		braces[0] = '\0';

a317 4
				return *++s;
			if (one[0] != '\0' && strcmp(*s, one) == 0)
				return *++s;
			if (braces[0] != '\0' && strcmp(*s, braces) == 0)
@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Id: smfi.c,v 8.28.4.6 2000/06/28 23:48:56 gshapiro Exp $";
d43 1
a43 1
	if (headerf == NULL || *headerf == '\0' || headerv == NULL)
d45 1
a45 1
	if (!mi_sendok(ctx, SMFIF_ADDHDRS))
d57 1
a57 53
	r = mi_wr_cmd(ctx->ctx_sd, &timeout, SMFIR_ADDHEADER, buf, len);
	free(buf);
	return r;
}

/*
**  SMFI_CHGHEADER -- send a changed header to the MTA
**
**	Parameters:
**		ctx -- Opaque context structure
**		headerf -- Header field name
**		hdridx -- Header index value
**		headerv -- Header field value
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_chgheader(ctx, headerf, hdridx, headerv)
	SMFICTX *ctx;
	char *headerf;
	mi_int32 hdridx;
	char *headerv;
{
	/* do we want to copy the stuff or have a special mi_wr_cmd call? */
	size_t len, l1, l2;
	int r;
	mi_int32 v;
	char *buf;
	struct timeval timeout;

	if (headerf == NULL || *headerf == '\0')
		return MI_FAILURE;
	if (hdridx < 0)
		return MI_FAILURE;
	if (!mi_sendok(ctx, SMFIF_CHGHDRS))
		return MI_FAILURE;
	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;
	if (headerv == NULL)
		headerv = "";
	l1 = strlen(headerf);
	l2 = strlen(headerv);
	len = l1 + l2 + 2 + MILTER_LEN_BYTES;
	buf = malloc(len);
	if (buf == NULL)
		return MI_FAILURE;
	v = htonl(hdridx);
	(void) memcpy(&(buf[0]), (void *) &v, MILTER_LEN_BYTES);
	(void) memcpy(buf + MILTER_LEN_BYTES, headerf, l1 + 1);
	(void) memcpy(buf + MILTER_LEN_BYTES + l1 + 1, headerv, l2 + 1);
	r = mi_wr_cmd(ctx->ctx_sd, &timeout, SMFIR_CHGHEADER, buf, len);
d80 1
a80 1
	if (rcpt == NULL || *rcpt == '\0')
d87 1
a87 1
	return mi_wr_cmd(ctx->ctx_sd, &timeout, SMFIR_ADDRCPT, rcpt, len);
d108 1
a108 1
	if (rcpt == NULL || *rcpt == '\0')
d115 1
a115 1
	return mi_wr_cmd(ctx->ctx_sd, &timeout, SMFIR_DELRCPT, rcpt, len);
d140 1
a140 1
	if (!mi_sendok(ctx, SMFIF_CHGBODY))
d151 1
a151 1
		if ((r = mi_wr_cmd(ctx->ctx_sd, &timeout, SMFIR_REPLBODY,
a304 2
	char one[2];
	char braces[4];
a308 17
	if (strlen(symname) == 3 && symname[0] == '{' && symname[2] == '}')
	{
		one[0] = symname[1];
		one[1] = '\0';
	}
	else
		one[0] = '\0';
	if (strlen(symname) == 1)
	{
		braces[0] = '{';
		braces[1] = *symname;
		braces[2] = '}';
		braces[3] = '\0';
	}
	else
		braces[0] = '\0';

a317 4
				return *++s;
			if (one[0] != '\0' && strcmp(*s, one) == 0)
				return *++s;
			if (braces[0] != '\0' && strcmp(*s, braces) == 0)
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d11 3
a13 2
#include <sm/gen.h>
SM_RCSID("@@(#)$Sendmail: smfi.c,v 8.42 2001/08/27 18:09:16 gshapiro Exp $")
d15 1
d17 1
d184 1
a184 1
	unsigned char *bodyp;
d190 1
a190 2
	if (bodylen < 0 ||
	    (bodyp == NULL && bodylen > 0))
d270 1
a270 1
	size_t len;
d275 2
a276 4

	/* ### <sp> \0 */
	len = strlen(rcode) + 2;
	if (len != 5)
d282 5
a286 4
	if (xcode != NULL)
		len += strlen(xcode) + 1;
	if (message != NULL)
		len += strlen(message) + 1;
d290 3
a292 14
	(void) sm_strlcpy(buf, rcode, len);
	(void) sm_strlcat(buf, " ", len);
	if (xcode != NULL)
	{
		if (!myisenhsc(xcode, '\0'))
			return MI_FAILURE;
		(void) sm_strlcat(buf, xcode, len);
	}
	if (message != NULL)
	{
		if (xcode != NULL)
			(void) sm_strlcat(buf, " ", len);
		(void) sm_strlcat(buf, message, len);
	}
d400 1
@


