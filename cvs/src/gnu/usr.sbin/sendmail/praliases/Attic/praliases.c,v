head	1.12;
access;
symbols
	OPENBSD_5_6:1.11.0.6
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.8
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.4
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.8.0.12
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.10
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.6
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.8
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.4
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.2
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.7.0.28
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.26
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.24
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.22
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.20
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.18
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.16
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.14
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.12
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.8
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.10
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.6
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.4
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.11;
commitid	M7i5giHIoz3DMlTU;

1.11
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.9;

1.9
date	2011.05.17.15.54.23;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.29.01.31.13;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.28.02.43.52;	author millert;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.01.15.21.09.05;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.03.02.52.11;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.57;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.57;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.39;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.52;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.30.47;	author miod;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.31.01.47.54;	author jason;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2001, 2008 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sm/gen.h>

SM_IDSTR(copyright,
"@@(#) Copyright (c) 1998-2001 Proofpoint, Inc. and its suppliers.\n\
	All rights reserved.\n\
     Copyright (c) 1983 Eric P. Allman.  All rights reserved.\n\
     Copyright (c) 1988, 1993\n\
	The Regents of the University of California.  All rights reserved.\n")

SM_IDSTR(id, "@@(#)$Sendmail: praliases.c,v 8.98 2013/11/22 20:51:53 ca Exp $")

#include <sys/types.h>
#include <ctype.h>
#include <stdlib.h>
#include <unistd.h>
#ifdef EX_OK
# undef EX_OK		/* unistd.h may have another use for this */
#endif /* EX_OK */
#include <sysexits.h>


#ifndef NOT_SENDMAIL
# define NOT_SENDMAIL
#endif /* ! NOT_SENDMAIL */
#include <sendmail/sendmail.h>
#include <sendmail/pathnames.h>
#include <libsmdb/smdb.h>

static void praliases __P((char *, int, char **));

uid_t	RealUid;
gid_t	RealGid;
char	*RealUserName;
uid_t	RunAsUid;
gid_t	RunAsGid;
char	*RunAsUserName;
int	Verbose = 2;
bool	DontInitGroups = false;
uid_t	TrustedUid = 0;
BITMAP256 DontBlameSendmail;

# define DELIMITERS		" ,/"
# define PATH_SEPARATOR		':'

int
main(argc, argv)
	int argc;
	char **argv;
{
	char *cfile;
	char *filename = NULL;
	SM_FILE_T *cfp;
	int ch;
	char afilebuf[MAXLINE];
	char buf[MAXLINE];
	struct passwd *pw;
	static char rnamebuf[MAXNAME];
	extern char *optarg;
	extern int optind;

	clrbitmap(DontBlameSendmail);
	RunAsUid = RealUid = getuid();
	RunAsGid = RealGid = getgid();
	pw = getpwuid(RealUid);
	if (pw != NULL)
	{
		if (strlen(pw->pw_name) > MAXNAME - 1)
			pw->pw_name[MAXNAME] = 0;
		sm_snprintf(rnamebuf, sizeof rnamebuf, "%s", pw->pw_name);
	}
	else
		(void) sm_snprintf(rnamebuf, sizeof rnamebuf,
		    "Unknown UID %d", (int) RealUid);
	RunAsUserName = RealUserName = rnamebuf;

	cfile = getcfname(0, 0, SM_GET_SENDMAIL_CF, NULL);
	while ((ch = getopt(argc, argv, "C:f:")) != -1)
	{
		switch ((char)ch) {
		case 'C':
			cfile = optarg;
			break;
		case 'f':
			filename = optarg;
			break;
		case '?':
		default:
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
			    "usage: praliases [-C cffile] [-f aliasfile]"
			    " [key ...]\n");
			exit(EX_USAGE);
		}
	}
	argc -= optind;
	argv += optind;

	if (filename != NULL)
	{
		praliases(filename, argc, argv);
		exit(EX_OK);
	}

	if ((cfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, cfile, SM_IO_RDONLY,
			      NULL)) == NULL)
	{
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				     "praliases: %s: %s\n", cfile,
				     sm_errstring(errno));
		exit(EX_NOINPUT);
	}

	while (sm_io_fgets(cfp, SM_TIME_DEFAULT, buf, sizeof(buf)) >= 0)
	{
		register char *b, *p;

		b = strchr(buf, '\n');
		if (b != NULL)
			*b = '\0';

		b = buf;
		switch (*b++)
		{
		  case 'O':		/* option -- see if alias file */
			if (sm_strncasecmp(b, " AliasFile", 10) == 0 &&
			    !(isascii(b[10]) && isalnum(b[10])))
			{
				/* new form -- find value */
				b = strchr(b, '=');
				if (b == NULL)
					continue;
				while (isascii(*++b) && isspace(*b))
					continue;
			}
			else if (*b++ != 'A')
			{
				/* something else boring */
				continue;
			}

			/* this is the A or AliasFile option -- save it */
			if (sm_strlcpy(afilebuf, b, sizeof afilebuf) >=
			    sizeof afilebuf)
			{
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				    "praliases: AliasFile filename too long: %.30s\n",
					b);
				(void) sm_io_close(cfp, SM_TIME_DEFAULT);
				exit(EX_CONFIG);
			}
			b = afilebuf;

			for (p = b; p != NULL; )
			{
				while (isascii(*p) && isspace(*p))
					p++;
				if (*p == '\0')
					break;
				b = p;

				p = strpbrk(p, DELIMITERS);

				/* find end of spec */
				if (p != NULL)
				{
					bool quoted = false;

					for (; *p != '\0'; p++)
					{
						/*
						**  Don't break into a quoted
						**  string.
						*/

						if (*p == '"')
							quoted = !quoted;
						else if (*p == ',' && !quoted)
							break;
					}

					/* No more alias specs follow */
					if (*p == '\0')
					{
						/* chop trailing whitespace */
						while (isascii(*p) &&
						       isspace(*p) &&
						       p > b)
							p--;
						*p = '\0';
						p = NULL;
					}
				}

				if (p != NULL)
				{
					char *e = p - 1;

					/* chop trailing whitespace */
					while (isascii(*e) &&
					       isspace(*e) &&
					       e > b)
						e--;
					*++e = '\0';
					*p++ = '\0';
				}
				praliases(b, argc, argv);
			}

		  default:
			continue;
		}
	}
	(void) sm_io_close(cfp, SM_TIME_DEFAULT);
	exit(EX_OK);
	/* NOTREACHED */
	return EX_OK;
}

static void
praliases(filename, argc, argv)
	char *filename;
	int argc;
	char **argv;
{
	int result;
	char *colon;
	char *db_name;
	char *db_type;
	SMDB_DATABASE *database = NULL;
	SMDB_CURSOR *cursor = NULL;
	SMDB_DBENT db_key, db_value;
	SMDB_DBPARAMS params;
	SMDB_USER_INFO user_info;

	colon = strchr(filename, PATH_SEPARATOR);
	if (colon == NULL)
	{
		db_name = filename;
		db_type = SMDB_TYPE_DEFAULT;
	}
	else
	{
		*colon = '\0';
		db_name = colon + 1;
		db_type = filename;
	}

	/* clean off arguments */
	for (;;)
	{
		while (isascii(*db_name) && isspace(*db_name))
			db_name++;

		if (*db_name != '-')
			break;
		while (*db_name != '\0' &&
		       !(isascii(*db_name) && isspace(*db_name)))
			db_name++;
	}

	/* Skip non-file based DB types */
	if (db_type != NULL && *db_type != '\0')
	{
		if (db_type != SMDB_TYPE_DEFAULT &&
		    strcmp(db_type, "hash") != 0 &&
		    strcmp(db_type, "btree") != 0 &&
		    strcmp(db_type, "dbm") != 0)
		{
			sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				      "praliases: Skipping non-file based alias type %s\n",
				db_type);
			return;
		}
	}

	if (*db_name == '\0' || (db_type != NULL && *db_type == '\0'))
	{
		if (colon != NULL)
			*colon = ':';
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
		    "praliases: illegal alias specification: %s\n", filename);
		goto fatal;
	}

	memset(&params, '\0', sizeof params);
	params.smdbp_cache_size = 1024 * 1024;

	user_info.smdbu_id = RunAsUid;
	user_info.smdbu_group_id = RunAsGid;
	(void) sm_strlcpy(user_info.smdbu_name, RunAsUserName,
			  SMDB_MAX_USER_NAME_LEN);

	result = smdb_open_database(&database, db_name, O_RDONLY, 0,
				    SFF_ROOTOK, db_type, &user_info, &params);
	if (result != SMDBE_OK)
	{
		sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
			      "praliases: %s: open: %s\n",
			      db_name, sm_errstring(result));
		goto fatal;
	}

	if (argc == 0)
	{
		memset(&db_key, '\0', sizeof db_key);
		memset(&db_value, '\0', sizeof db_value);

		result = database->smdb_cursor(database, &cursor, 0);
		if (result != SMDBE_OK)
		{
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
			    "praliases: %s: set cursor: %s\n", db_name,
			    sm_errstring(result));
			goto fatal;
		}

		while ((result = cursor->smdbc_get(cursor, &db_key, &db_value,
						   SMDB_CURSOR_GET_NEXT)) ==
						   SMDBE_OK)
		{
#if 0
			/* skip magic @@:@@ entry */
			if (db_key.size == 2 &&
			    db_key.data[0] == '@@' &&
			    db_key.data[1] == '\0' &&
			    db_value.size == 2 &&
			    db_value.data[0] == '@@' &&
			    db_value.data[1] == '\0')
				continue;
#endif /* 0 */

			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "%.*s:%.*s\n",
					     (int) db_key.size,
					     (char *) db_key.data,
					     (int) db_value.size,
					     (char *) db_value.data);
		}

		if (result != SMDBE_OK && result != SMDBE_LAST_ENTRY)
		{
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				"praliases: %s: get value at cursor: %s\n",
				db_name, sm_errstring(result));
			goto fatal;
		}
	}
	else for (; *argv != NULL; ++argv)
	{
		int get_res;

		memset(&db_key, '\0', sizeof db_key);
		memset(&db_value, '\0', sizeof db_value);
		db_key.data = *argv;
		db_key.size = strlen(*argv);
		get_res = database->smdb_get(database, &db_key, &db_value, 0);
		if (get_res == SMDBE_NOT_FOUND)
		{
			db_key.size++;
			get_res = database->smdb_get(database, &db_key,
						     &db_value, 0);
		}
		if (get_res == SMDBE_OK)
		{
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "%.*s:%.*s\n",
					     (int) db_key.size,
					     (char *) db_key.data,
					     (int) db_value.size,
					     (char *) db_value.data);
		}
		else
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "%s: No such key\n",
					     (char *)db_key.data);
	}

 fatal:
	if (cursor != NULL)
		(void) cursor->smdbc_close(cursor);
	if (database != NULL)
		(void) database->smdb_close(database);
	if (colon != NULL)
		*colon = ':';
	return;
}
@


1.11
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.10
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001, 2008 Sendmail, Inc. and its suppliers.
d17 1
a17 1
"@@(#) Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.\n\
d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: praliases.c,v 8.97 2013/03/12 15:24:51 ca Exp $")
@


1.9
log
@Update to sendmail 8.14.5
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: praliases.c,v 8.96 2008/07/10 20:13:10 ca Exp $")
d125 1
a125 1
	while (sm_io_fgets(cfp, SM_TIME_DEFAULT, buf, sizeof(buf)) != NULL)
@


1.8
log
@Update to sendmail-8.14.3
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: praliases.c,v 8.94 2007/05/11 18:50:36 ca Exp $")
d102 2
a103 1
			    "usage: praliases [-C cffile] [-f aliasfile]\n");
@


1.7
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: praliases.c,v 8.93 2001/09/11 04:05:07 gshapiro Exp $")
d48 1
a48 1
uid_t	RunAsGid;
@


1.6
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: praliases.c,v 8.91 2001/03/29 21:15:53 rodney Exp $")
@


1.5
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d14 3
a16 2
#ifndef lint
static char copyright[] =
d21 1
a21 2
	The Regents of the University of California.  All rights reserved.\n";
#endif /* ! lint */
d23 1
a23 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: praliases.c,v 8.59.4.19 2001/02/28 02:37:57 ca Exp $";
#endif /* ! lint */
d51 1
a51 1
bool	DontInitGroups = FALSE;
a54 2
extern void	syserr __P((const char *, ...));

d65 1
a65 1
	FILE *cfp;
a73 1

d82 1
a82 1
		snprintf(rnamebuf, sizeof rnamebuf, "%s", pw->pw_name);
d85 2
a86 2
		(void) snprintf(rnamebuf, sizeof rnamebuf, "Unknown UID %d",
				(int) RealUid);
d89 1
a89 1
	cfile = _PATH_SENDMAILCF;
d101 2
a102 2
			(void)fprintf(stderr,
				      "usage: praliases [-C cffile] [-f aliasfile]\n");
d115 2
a116 1
	if ((cfp = fopen(cfile, "r")) == NULL)
d118 3
a120 2
		fprintf(stderr, "praliases: %s: %s\n",
			cfile, errstring(errno));
d124 1
a124 1
	while (fgets(buf, sizeof(buf), cfp) != NULL)
d136 1
a136 1
			if (strncasecmp(b, " AliasFile", 10) == 0 &&
d153 1
a153 1
			if (strlcpy(afilebuf, b, sizeof afilebuf) >=
d156 2
a157 2
				fprintf(stderr,
					"praliases: AliasFile filename too long: %.30s\n",
d159 1
a159 1
				(void) fclose(cfp);
d177 1
a177 1
					bool quoted = FALSE;
d224 1
a224 1
	(void) fclose(cfp);
d280 2
a281 2
			fprintf(stderr,
				"praliases: Skipping non-file based alias type %s\n",
d291 2
a292 2
		fprintf(stderr,	"praliases: illegal alias specification: %s\n",
			filename);
d301 2
a302 1
	strlcpy(user_info.smdbu_name, RunAsUserName, SMDB_MAX_USER_NAME_LEN);
d308 3
a310 2
		fprintf(stderr, "praliases: %s: open: %s\n",
			db_name, errstring(result));
d322 3
a324 2
			fprintf(stderr, "praliases: %s: set cursor: %s\n",
				db_name, errstring(result));
d343 6
a348 5
			printf("%.*s:%.*s\n",
			       (int) db_key.size,
			       (char *) db_key.data,
			       (int) db_value.size,
			       (char *) db_value.data);
d353 1
a353 1
			fprintf(stderr,
d355 1
a355 1
				db_name, errstring(result));
d376 6
a381 5
			printf("%.*s:%.*s\n",
			       (int) db_key.size,
			       (char *) db_key.data,
			       (int) db_value.size,
			       (char *) db_value.data);
d384 3
a386 1
			printf("%s: No such key\n", (char *) db_key.data);
a396 48
}

/*VARARGS1*/
void
#ifdef __STDC__
message(const char *msg, ...)
#else /* __STDC__ */
message(msg, va_alist)
	const char *msg;
	va_dcl
#endif /* __STDC__ */
{
	const char *m;
	VA_LOCAL_DECL

	m = msg;
	if (isascii(m[0]) && isdigit(m[0]) &&
	    isascii(m[1]) && isdigit(m[1]) &&
	    isascii(m[2]) && isdigit(m[2]) && m[3] == ' ')
		m += 4;
	VA_START(msg);
	(void) vfprintf(stderr, m, ap);
	VA_END;
	(void) fprintf(stderr, "\n");
}

/*VARARGS1*/
void
#ifdef __STDC__
syserr(const char *msg, ...)
#else /* __STDC__ */
syserr(msg, va_alist)
	const char *msg;
	va_dcl
#endif /* __STDC__ */
{
	const char *m;
	VA_LOCAL_DECL

	m = msg;
	if (isascii(m[0]) && isdigit(m[0]) &&
	    isascii(m[1]) && isdigit(m[1]) &&
	    isascii(m[2]) && isdigit(m[2]) && m[3] == ' ')
		m += 4;
	VA_START(msg);
	(void) vfprintf(stderr, m, ap);
	VA_END;
	(void) fprintf(stderr, "\n");
@


1.4
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d24 1
a24 1
static char id[] = "@@(#)$Sendmail: praliases.c,v 8.59.4.18 2001/01/22 19:00:18 gshapiro Exp $";
d360 2
d365 9
a373 3
		db_key.size = strlen(*argv) + 1;
		if (database->smdb_get(database, &db_key,
				       &db_value, 0) == SMDBE_OK)
@


1.4.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d24 1
a24 1
static char id[] = "@@(#)$Sendmail: praliases.c,v 8.59.4.19 2001/02/28 02:37:57 ca Exp $";
a359 2
		int get_res;

d363 3
a365 9
		db_key.size = strlen(*argv);
		get_res = database->smdb_get(database, &db_key, &db_value, 0);
		if (get_res == SMDBE_NOT_FOUND)
		{
			db_key.size++;
			get_res = database->smdb_get(database, &db_key,
						     &db_value, 0);
		}
		if (get_res == SMDBE_OK)
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d16 1
a16 1
"@@(#) Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.\n\
d24 1
a24 1
static char id[] = "@@(#)$Sendmail: praliases.c,v 8.59.4.15 2000/10/24 00:42:59 geir Exp $";
d273 15
@


1.2
log
@Add missing 'praliases user1 user2 ...' functionality from sendmail-8.10.1.Beta1
@
text
@d24 1
a24 1
static char id[] = "@@(#)$Sendmail: praliases.c,v 8.59 2000/03/17 07:32:47 gshapiro Exp $";
d36 1
d59 3
d78 1
d90 2
a91 2
		snprintf(rnamebuf, sizeof rnamebuf,
			 "Unknown UID %d", (int) RealUid);
d95 1
a95 1
	while ((ch = getopt(argc, argv, "C:f:")) != EOF)
d175 1
a175 1
				p = strpbrk(p, " ,/");
d249 1
a249 1
	colon = strchr(filename, ':');
d267 1
d319 6
a324 6
			if (db_key.data.size == 2 &&
			    db_key.data.data[0] == '@@' &&
			    db_key.data.data[1] == '\0' &&
			    db_value.data.size == 2 &&
			    db_value.data.data[0] == '@@' &&
			    db_value.data.data[1] == '\0')
d329 4
a332 4
			       (int) db_key.data.size,
			       (char *) db_key.data.data,
			       (int) db_value.data.size,
			       (char *) db_value.data.data);
d347 2
a348 2
		db_key.data.data = *argv;
		db_key.data.size = strlen(*argv) + 1;
d353 4
a356 4
			       (int) db_key.data.size,
			       (char *) db_key.data.data,
			       (int) db_value.data.size,
			       (char *) db_value.data.data);
d359 1
a359 1
			printf("%s: No such key\n", (char *) db_key.data.data);
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
"@@(#) Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.\n\
d24 1
a24 1
static char id[] = "@@(#)$Sendmail: praliases.c,v 8.59.4.19 2001/02/28 02:37:57 ca Exp $";
a35 1

a57 3
# define DELIMITERS		" ,/"
# define PATH_SEPARATOR		':'

a73 1

d85 2
a86 2
		(void) snprintf(rnamebuf, sizeof rnamebuf, "Unknown UID %d",
				(int) RealUid);
d90 1
a90 1
	while ((ch = getopt(argc, argv, "C:f:")) != -1)
d170 1
a170 1
				p = strpbrk(p, DELIMITERS);
d244 1
a244 1
	colon = strchr(filename, PATH_SEPARATOR);
a261 1

a268 15
	/* Skip non-file based DB types */
	if (db_type != NULL && *db_type != '\0')
	{
		if (db_type != SMDB_TYPE_DEFAULT &&
		    strcmp(db_type, "hash") != 0 &&
		    strcmp(db_type, "btree") != 0 &&
		    strcmp(db_type, "dbm") != 0)
		{
			fprintf(stderr,
				"praliases: Skipping non-file based alias type %s\n",
				db_type);
			return;
		}
	}

d313 6
a318 6
			if (db_key.size == 2 &&
			    db_key.data[0] == '@@' &&
			    db_key.data[1] == '\0' &&
			    db_value.size == 2 &&
			    db_value.data[0] == '@@' &&
			    db_value.data[1] == '\0')
d323 4
a326 4
			       (int) db_key.size,
			       (char *) db_key.data,
			       (int) db_value.size,
			       (char *) db_value.data);
a338 2
		int get_res;

d341 4
a344 10
		db_key.data = *argv;
		db_key.size = strlen(*argv);
		get_res = database->smdb_get(database, &db_key, &db_value, 0);
		if (get_res == SMDBE_NOT_FOUND)
		{
			db_key.size++;
			get_res = database->smdb_get(database, &db_key,
						     &db_value, 0);
		}
		if (get_res == SMDBE_OK)
d347 4
a350 4
			       (int) db_key.size,
			       (char *) db_key.data,
			       (int) db_value.size,
			       (char *) db_value.data);
d353 1
a353 1
			printf("%s: No such key\n", (char *) db_key.data);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1998, 1999 Sendmail, Inc. and its suppliers.
d16 1
a16 1
"@@(#) Copyright (c) 1998, 1999 Sendmail, Inc. and its suppliers.\n\
d24 1
a24 1
static char id[] = "@@(#)$Sendmail: praliases.c,v 8.57 1999/10/13 03:35:16 ca Exp $";
d294 4
a297 2
	memset(&db_key, '\0', sizeof db_key);
	memset(&db_value, '\0', sizeof db_value);
d299 7
a305 7
	result = database->smdb_cursor(database, &cursor, 0);
	if (result != SMDBE_OK)
	{
		fprintf(stderr, "praliases: %s: set cursor: %s\n",
			db_name, errstring(result));
		goto fatal;
	}
d307 4
a310 3
	while ((result = cursor->smdbc_get(cursor, &db_key, &db_value,
					   SMDB_CURSOR_GET_NEXT)) == SMDBE_OK)
	{
d312 8
a319 8
		/* skip magic @@:@@ entry */
		if (db_key.data.size == 2 &&
		    db_key.data.data[0] == '@@' &&
		    db_key.data.data[1] == '\0' &&
		    db_value.data.size == 2 &&
		    db_value.data.data[0] == '@@' &&
		    db_value.data.data[1] == '\0')
			continue;
d322 14
a335 5
		printf("%.*s:%.*s\n",
		       (int) db_key.data.size,
		       (char *) db_key.data.data,
		       (int) db_value.data.size,
		       (char *) db_value.data.data);
d337 1
a337 2

	if (result != SMDBE_OK && result != SMDBE_LAST_ENTRY)
d339 15
a353 3
		fprintf(stderr,	"praliases: %s: get value at cursor: %s\n",
			db_name, errstring(result));
		goto fatal;
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d16 1
a16 1
"@@(#) Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.\n\
d24 1
a24 1
static char id[] = "@@(#)$Id: praliases.c,v 8.59.4.15 2000/10/24 00:42:59 geir Exp $";
a35 1

a57 3
# define DELIMITERS		" ,/"
# define PATH_SEPARATOR		':'

a73 1

d85 2
a86 2
		(void) snprintf(rnamebuf, sizeof rnamebuf, "Unknown UID %d",
				(int) RealUid);
d90 1
a90 1
	while ((ch = getopt(argc, argv, "C:f:")) != -1)
d170 1
a170 1
				p = strpbrk(p, DELIMITERS);
d244 1
a244 1
	colon = strchr(filename, PATH_SEPARATOR);
a261 1

d294 5
a298 1
	if (argc == 0)
d300 4
a303 2
		memset(&db_key, '\0', sizeof db_key);
		memset(&db_value, '\0', sizeof db_value);
d305 3
a307 12
		result = database->smdb_cursor(database, &cursor, 0);
		if (result != SMDBE_OK)
		{
			fprintf(stderr, "praliases: %s: set cursor: %s\n",
				db_name, errstring(result));
			goto fatal;
		}

		while ((result = cursor->smdbc_get(cursor, &db_key, &db_value,
						   SMDB_CURSOR_GET_NEXT)) ==
						   SMDBE_OK)
		{
d309 8
a316 8
			/* skip magic @@:@@ entry */
			if (db_key.size == 2 &&
			    db_key.data[0] == '@@' &&
			    db_key.data[1] == '\0' &&
			    db_value.size == 2 &&
			    db_value.data[0] == '@@' &&
			    db_value.data[1] == '\0')
				continue;
d319 6
a324 6
			printf("%.*s:%.*s\n",
			       (int) db_key.size,
			       (char *) db_key.data,
			       (int) db_value.size,
			       (char *) db_value.data);
		}
d326 1
a326 9
		if (result != SMDBE_OK && result != SMDBE_LAST_ENTRY)
		{
			fprintf(stderr,
				"praliases: %s: get value at cursor: %s\n",
				db_name, errstring(result));
			goto fatal;
		}
	}
	else for (; *argv != NULL; ++argv)
d328 3
a330 15
		memset(&db_key, '\0', sizeof db_key);
		memset(&db_value, '\0', sizeof db_value);
		db_key.data = *argv;
		db_key.size = strlen(*argv) + 1;
		if (database->smdb_get(database, &db_key,
				       &db_value, 0) == SMDBE_OK)
		{
			printf("%.*s:%.*s\n",
			       (int) db_key.size,
			       (char *) db_key.data,
			       (int) db_value.size,
			       (char *) db_value.data);
		}
		else
			printf("%s: No such key\n", (char *) db_key.data);
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d14 3
a16 4
#include <sm/gen.h>

SM_IDSTR(copyright,
"@@(#) Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.\n\
d20 2
a21 1
	The Regents of the University of California.  All rights reserved.\n")
d23 3
a25 1
SM_IDSTR(id, "@@(#)$Sendmail: praliases.c,v 8.91 2001/03/29 21:15:53 rodney Exp $")
d53 1
a53 1
bool	DontInitGroups = false;
d57 2
d69 1
a69 1
	SM_FILE_T *cfp;
d78 1
d87 1
a87 1
		sm_snprintf(rnamebuf, sizeof rnamebuf, "%s", pw->pw_name);
d90 2
a91 2
		(void) sm_snprintf(rnamebuf, sizeof rnamebuf,
		    "Unknown UID %d", (int) RealUid);
d94 1
a94 1
	cfile = getcfname(0, 0, SM_GET_SENDMAIL_CF, NULL);
d106 2
a107 2
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
			    "usage: praliases [-C cffile] [-f aliasfile]\n");
d120 1
a120 2
	if ((cfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, cfile, SM_IO_RDONLY,
			      NULL)) == NULL)
d122 2
a123 3
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				     "praliases: %s: %s\n", cfile,
				     sm_errstring(errno));
d127 1
a127 1
	while (sm_io_fgets(cfp, SM_TIME_DEFAULT, buf, sizeof(buf)) != NULL)
d139 1
a139 1
			if (sm_strncasecmp(b, " AliasFile", 10) == 0 &&
d156 1
a156 1
			if (sm_strlcpy(afilebuf, b, sizeof afilebuf) >=
d159 2
a160 2
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				    "praliases: AliasFile filename too long: %.30s\n",
d162 1
a162 1
				(void) sm_io_close(cfp, SM_TIME_DEFAULT);
d180 1
a180 1
					bool quoted = false;
d227 1
a227 1
	(void) sm_io_close(cfp, SM_TIME_DEFAULT);
a274 15
	/* Skip non-file based DB types */
	if (db_type != NULL && *db_type != '\0')
	{
		if (db_type != SMDB_TYPE_DEFAULT &&
		    strcmp(db_type, "hash") != 0 &&
		    strcmp(db_type, "btree") != 0 &&
		    strcmp(db_type, "dbm") != 0)
		{
			sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				      "praliases: Skipping non-file based alias type %s\n",
				db_type);
			return;
		}
	}

d279 2
a280 2
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
		    "praliases: illegal alias specification: %s\n", filename);
d289 1
a289 2
	(void) sm_strlcpy(user_info.smdbu_name, RunAsUserName,
			  SMDB_MAX_USER_NAME_LEN);
d295 2
a296 3
		sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
			      "praliases: %s: open: %s\n",
			      db_name, sm_errstring(result));
d308 2
a309 3
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
			    "praliases: %s: set cursor: %s\n", db_name,
			    sm_errstring(result));
d328 5
a332 6
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "%.*s:%.*s\n",
					     (int) db_key.size,
					     (char *) db_key.data,
					     (int) db_value.size,
					     (char *) db_value.data);
d337 1
a337 1
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
d339 1
a339 1
				db_name, sm_errstring(result));
a344 2
		int get_res;

d348 3
a350 3
		db_key.size = strlen(*argv);
		get_res = database->smdb_get(database, &db_key, &db_value, 0);
		if (get_res == SMDBE_NOT_FOUND)
d352 5
a356 12
			db_key.size++;
			get_res = database->smdb_get(database, &db_key,
						     &db_value, 0);
		}
		if (get_res == SMDBE_OK)
		{
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "%.*s:%.*s\n",
					     (int) db_key.size,
					     (char *) db_key.data,
					     (int) db_value.size,
					     (char *) db_value.data);
d359 1
a359 3
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "%s: No such key\n",
					     (char *)db_key.data);
d370 48
@


