head	1.7;
access;
symbols
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.5.0.50
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.48
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.46
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.44
	OPENBSD_5_0:1.5.0.42
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.40
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.38
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.34
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.36
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.32
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.30
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.28
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.26
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.24
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.22
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.20
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.18
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.16
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.14
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.12
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.8
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.10
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.6;
commitid	M7i5giHIoz3DMlTU;

1.6
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.01.01.01.40;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.15.21.09.04;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.02.19.05.41;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.41;	author millert;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.07;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.49;	author millert;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	2001.05.31.00.29.29;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2001 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>

SM_RCSID("@@(#)$Sendmail: snprintf.c,v 8.45 2013/11/22 20:51:50 ca Exp $")

/*
**  SHORTENSTRING -- return short version of a string
**
**	If the string is already short, just return it.  If it is too
**	long, return the head and tail of the string.
**
**	Parameters:
**		s -- the string to shorten.
**		m -- the max length of the string (strlen()).
**
**	Returns:
**		Either s or a short version of s.
*/

char *
shortenstring(s, m)
	register const char *s;
	size_t m;
{
	size_t l;
	static char buf[MAXSHORTSTR + 1];

	l = strlen(s);
	if (l < m)
		return (char *) s;
	if (m > MAXSHORTSTR)
		m = MAXSHORTSTR;
	else if (m < 10)
	{
		if (m < 5)
		{
			(void) sm_strlcpy(buf, s, m + 1);
			return buf;
		}
		(void) sm_strlcpy(buf, s, m - 2);
		(void) sm_strlcat(buf, "...", sizeof buf);
		return buf;
	}
	m = (m - 3) / 2;
	(void) sm_strlcpy(buf, s, m + 1);
	(void) sm_strlcat2(buf, "...", s + l - m, sizeof buf);
	return buf;
}
@


1.6
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.5
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: snprintf.c,v 8.44 2001/09/11 04:04:56 gshapiro Exp $")
@


1.4
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: snprintf.c,v 8.41 2001/08/28 23:07:01 gshapiro Exp $")
d18 1
a18 1
/*
@


1.3
log
@update to sendmail 8.11.5
@
text
@a13 4
#ifndef lint
static char id[] = "@@(#)$Sendmail: snprintf.c,v 8.27.16.4 2001/07/20 04:19:37 gshapiro Exp $";
#endif /* ! lint */

d16 1
a16 358
/*
**  SNPRINTF, VSNPRINT -- counted versions of printf
**
**	These versions have been grabbed off the net.  They have been
**	cleaned up to compile properly and support for .precision and
**	%lx has been added.
*/

/**************************************************************
 * Original:
 * Patrick Powell Tue Apr 11 09:48:21 PDT 1995
 * A bombproof version of doprnt (sm_dopr) included.
 * Sigh.  This sort of thing is always nasty do deal with.  Note that
 * the version here does not include floating point...
 *
 * snprintf() is used instead of sprintf() as it does limit checks
 * for string length.  This covers a nasty loophole.
 *
 * The other functions are there to prevent NULL pointers from
 * causing nast effects.
 **************************************************************/

/*static char _id[] = "$OrigId: snprintf.c,v 1.2 1995/10/09 11:19:47 roberto Exp $";*/
void	sm_dopr();
char	*DoprEnd;
int	SnprfOverflow;

#if !HASSNPRINTF && !SNPRINTF_IS_BROKEN
# define sm_snprintf	snprintf
# ifndef luna2
#  define sm_vsnprintf	vsnprintf
extern int	vsnprintf __P((char *, size_t, const char *, va_list));
# endif /* ! luna2 */
#endif /* !HASSNPRINTF && !SNPRINTF_IS_BROKEN */

/* VARARGS3 */
int
# ifdef __STDC__
sm_snprintf(char *str, size_t count, const char *fmt, ...)
# else /* __STDC__ */
sm_snprintf(str, count, fmt, va_alist)
	char *str;
	size_t count;
	const char *fmt;
	va_dcl
# endif /* __STDC__ */
{
	int len;
	VA_LOCAL_DECL

	VA_START(fmt);
	len = sm_vsnprintf(str, count, fmt, ap);
	VA_END;
	return len;
}

int
sm_vsnprintf(str, count, fmt, args)
	char *str;
	size_t count;
	const char *fmt;
	va_list args;
{
	str[0] = 0;
	DoprEnd = str + count - 1;
	SnprfOverflow = 0;
	sm_dopr( str, fmt, args );
	if (count > 0)
		DoprEnd[0] = 0;
	if (SnprfOverflow > 0 && tTd(57, 2))
		dprintf("\nvsnprintf overflow, len = %ld, str = %s",
			(long) count, shortenstring(str, MAXSHORTSTR));
	return strlen(str) + SnprfOverflow;
}

/*
 * sm_dopr(): poor man's version of doprintf
 */

void fmtstr __P((char *value, int ljust, int len, int zpad, int maxwidth));
void fmtnum __P((long value, int base, int dosign, int ljust, int len, int zpad));
void dostr __P(( char * , int ));
char *output;
void dopr_outch __P(( int c ));
int	SyslogErrno;

void
sm_dopr( buffer, format, args )
       char *buffer;
       const char *format;
       va_list args;
{
       int ch;
       long value;
       int longflag  = 0;
       int pointflag = 0;
       int maxwidth  = 0;
       char *strvalue;
       int ljust;
       int len;
       int zpad;
#if !HASSTRERROR && !defined(ERRLIST_PREDEFINED)
	extern char *sys_errlist[];
	extern int sys_nerr;
#endif /* !HASSTRERROR && !defined(ERRLIST_PREDEFINED) */


       output = buffer;
       while( (ch = *format++) != '\0' ){
	       switch( ch ){
	       case '%':
		       ljust = len = zpad = maxwidth = 0;
		       longflag = pointflag = 0;
	       nextch:
		       ch = *format++;
		       switch( ch ){
		       case 0:
			       dostr( "**end of format**" , 0);
			       return;
		       case '-': ljust = 1; goto nextch;
		       case '0': /* set zero padding if len not set */
			       if(len==0 && !pointflag) zpad = '0';
				/* FALLTHROUGH */
		       case '1': case '2': case '3':
		       case '4': case '5': case '6':
		       case '7': case '8': case '9':
			       if (pointflag)
				 maxwidth = maxwidth*10 + ch - '0';
			       else
				 len = len*10 + ch - '0';
			       goto nextch;
		       case '*':
			       if (pointflag)
				 maxwidth = va_arg( args, int );
			       else
				 len = va_arg( args, int );
			       goto nextch;
		       case '.': pointflag = 1; goto nextch;
		       case 'l': longflag = 1; goto nextch;
		       case 'u': case 'U':
			       /*fmtnum(value,base,dosign,ljust,len,zpad) */
			       if( longflag ){
				       value = va_arg( args, long );
			       } else {
				       value = va_arg( args, int );
			       }
			       fmtnum( value, 10,0, ljust, len, zpad ); break;
		       case 'o': case 'O':
			       /*fmtnum(value,base,dosign,ljust,len,zpad) */
			       if( longflag ){
				       value = va_arg( args, long );
			       } else {
				       value = va_arg( args, int );
			       }
			       fmtnum( value, 8,0, ljust, len, zpad ); break;
		       case 'd': case 'D':
			       if( longflag ){
				       value = va_arg( args, long );
			       } else {
				       value = va_arg( args, int );
			       }
			       fmtnum( value, 10,1, ljust, len, zpad ); break;
		       case 'x':
			       if( longflag ){
				       value = va_arg( args, long );
			       } else {
				       value = va_arg( args, int );
			       }
			       fmtnum( value, 16,0, ljust, len, zpad ); break;
		       case 'X':
			       if( longflag ){
				       value = va_arg( args, long );
			       } else {
				       value = va_arg( args, int );
			       }
			       fmtnum( value,-16,0, ljust, len, zpad ); break;
		       case 's':
			       strvalue = va_arg( args, char *);
			       if (maxwidth > 0 || !pointflag) {
				 if (pointflag && len > maxwidth)
				   len = maxwidth; /* Adjust padding */
				 fmtstr( strvalue,ljust,len,zpad, maxwidth);
			       }
			       break;
		       case 'c':
			       ch = va_arg( args, int );
			       dopr_outch( ch ); break;
		       case 'm':
#if HASSTRERROR
			       dostr(strerror(SyslogErrno), 0);
#else /* HASSTRERROR */
			       if (SyslogErrno < 0 || SyslogErrno >= sys_nerr)
			       {
				   dostr("Error ", 0);
				   fmtnum(SyslogErrno, 10, 0, 0, 0, 0);
			       }
			       else
				   dostr((char *)sys_errlist[SyslogErrno], 0);
#endif /* HASSTRERROR */
			       break;

		       case '%': dopr_outch( ch ); continue;
		       default:
			       dostr(  "???????" , 0);
		       }
		       break;
	       default:
		       dopr_outch( ch );
		       break;
	       }
       }
       *output = 0;
}

void
fmtstr(  value, ljust, len, zpad, maxwidth )
       char *value;
       int ljust, len, zpad, maxwidth;
{
       int padlen, strleng;     /* amount to pad */

       if( value == 0 ){
	       value = "<NULL>";
       }
       for( strleng = 0; value[strleng]; ++ strleng ); /* strlen */
       if (strleng > maxwidth && maxwidth)
	 strleng = maxwidth;
       padlen = len - strleng;
       if( padlen < 0 ) padlen = 0;
       if( ljust ) padlen = -padlen;
       while( padlen > 0 ) {
	       dopr_outch( ' ' );
	       --padlen;
       }
       dostr( value, maxwidth );
       while( padlen < 0 ) {
	       dopr_outch( ' ' );
	       ++padlen;
       }
}

void
fmtnum(  value, base, dosign, ljust, len, zpad )
       long value;
       int base, dosign, ljust, len, zpad;
{
       int signvalue = 0;
       unsigned long uvalue;
       char convert[20];
       int place = 0;
       int padlen = 0; /* amount to pad */
       int caps = 0;

       /* DEBUGP(("value 0x%x, base %d, dosign %d, ljust %d, len %d, zpad %d\n",
	       value, base, dosign, ljust, len, zpad )); */
       uvalue = value;
       if( dosign ){
	       if( value < 0 ) {
		       signvalue = '-';
		       uvalue = -value;
	       }
       }
       if( base < 0 ){
	       caps = 1;
	       base = -base;
       }
       do{
	       convert[place++] =
		       (caps? "0123456789ABCDEF":"0123456789abcdef")
			[uvalue % (unsigned)base  ];
	       uvalue = (uvalue / (unsigned)base );
       }while(uvalue);
       convert[place] = 0;
       padlen = len - place;
       if( padlen < 0 ) padlen = 0;
       if( ljust ) padlen = -padlen;
       /* DEBUGP(( "str '%s', place %d, sign %c, padlen %d\n",
	       convert,place,signvalue,padlen)); */
       if( zpad && padlen > 0 ){
	       if( signvalue ){
		       dopr_outch( signvalue );
		       --padlen;
		       signvalue = 0;
	       }
	       while( padlen > 0 ){
		       dopr_outch( zpad );
		       --padlen;
	       }
       }
       while( padlen > 0 ) {
	       dopr_outch( ' ' );
	       --padlen;
       }
       if( signvalue ) dopr_outch( signvalue );
       while( place > 0 ) dopr_outch( convert[--place] );
       while( padlen < 0 ){
	       dopr_outch( ' ' );
	       ++padlen;
       }
}

void
dostr( str , cut)
     char *str;
     int cut;
{
  if (cut) {
    while(*str && cut-- > 0) dopr_outch(*str++);
  } else {
    while(*str) dopr_outch(*str++);
  }
}

void
dopr_outch( c )
       int c;
{
#if 0
       if( iscntrl(c) && c != '\n' && c != '\t' ){
	       c = '@@' + (c & 0x1F);
	       if( DoprEnd == 0 || output < DoprEnd )
		       *output++ = '^';
       }
#endif /* 0 */
       if( DoprEnd == 0 || output < DoprEnd )
	       *output++ = c;
       else
		SnprfOverflow++;
}

/*
**  QUAD_TO_STRING -- Convert a quad type to a string.
**
**	Convert a quad type to a string.  This must be done
**	separately as %lld/%qd are not supported by snprint()
**	and adding support would slow down systems which only
**	emulate the data type.
**
**	Parameters:
**		value -- number to convert to a string.
**
**	Returns:
**		pointer to a string.
*/

char *
quad_to_string(value)
	QUAD_T value;
{
	char *formatstr;
	static char buf[64];

	/*
	**  Use sprintf() instead of snprintf() since snprintf()
	**  does not support %qu or %llu.  The buffer is large enough
	**  to hold the string so there is no danger of buffer
	**  overflow.
	*/
a17 8
#if NEED_PERCENTQ
	formatstr = "%qu";
#else /* NEED_PERCENTQ */
	formatstr = "%llu";
#endif /* NEED_PERCENTQ */
	sprintf(buf, formatstr, value);
	return buf;
}
d35 1
a35 1
	int m;
d37 1
a37 1
	int l;
d49 1
a49 1
			(void) strlcpy(buf, s, m + 1);
d52 2
a53 2
		(void) strlcpy(buf, s, m - 2);
		(void) strlcat(buf, "...", sizeof buf);
d57 2
a58 3
	(void) strlcpy(buf, s, m + 1);
	(void) strlcat(buf, "...", sizeof buf);
	(void) strlcat(buf, s + l - m, sizeof buf);
@


1.2
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: snprintf.c,v 8.27.16.2 2000/09/17 17:04:24 gshapiro Exp $";
d89 1
a89 1
	if (SnprfOverflow && tTd(57, 2))
d92 1
a92 1
	return strlen(str);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1998, 1999 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: snprintf.c,v 8.27 1999/10/13 03:27:08 ca Exp $";
d47 7
a53 1
#if !HASSNPRINTF
d58 1
a58 1
snprintf(char *str, size_t count, const char *fmt, ...)
d60 1
a60 1
snprintf(str, count, fmt, va_alist)
d71 1
a71 1
	len = vsnprintf(str, count, fmt, ap);
a75 2

# ifndef luna2
d77 1
a77 1
vsnprintf(str, count, fmt, args)
a93 3

# endif /* ! luna2 */
#endif /* !HASSNPRINTF */
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.1.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: snprintf.c,v 8.27.16.2 2000/09/17 17:04:24 gshapiro Exp $";
d47 1
a47 7
#if !HASSNPRINTF && !SNPRINTF_IS_BROKEN
# define sm_snprintf	snprintf
# ifndef luna2
#  define sm_vsnprintf	vsnprintf
extern int	vsnprintf __P((char *, size_t, const char *, va_list));
# endif /* ! luna2 */
#endif /* !HASSNPRINTF && !SNPRINTF_IS_BROKEN */
d52 1
a52 1
sm_snprintf(char *str, size_t count, const char *fmt, ...)
d54 1
a54 1
sm_snprintf(str, count, fmt, va_alist)
d65 1
a65 1
	len = sm_vsnprintf(str, count, fmt, ap);
d70 2
d73 1
a73 1
sm_vsnprintf(str, count, fmt, args)
d90 3
@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Id: snprintf.c,v 8.27.16.2 2000/09/17 17:04:24 gshapiro Exp $";
d47 1
a47 7
#if !HASSNPRINTF && !SNPRINTF_IS_BROKEN
# define sm_snprintf	snprintf
# ifndef luna2
#  define sm_vsnprintf	vsnprintf
extern int	vsnprintf __P((char *, size_t, const char *, va_list));
# endif /* ! luna2 */
#endif /* !HASSNPRINTF && !SNPRINTF_IS_BROKEN */
d52 1
a52 1
sm_snprintf(char *str, size_t count, const char *fmt, ...)
d54 1
a54 1
sm_snprintf(str, count, fmt, va_alist)
d65 1
a65 1
	len = sm_vsnprintf(str, count, fmt, ap);
d70 2
d73 1
a73 1
sm_vsnprintf(str, count, fmt, args)
d90 3
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d14 4
d20 358
a377 1
SM_RCSID("@@(#)$Sendmail: snprintf.c,v 8.41 2001/08/28 23:07:01 gshapiro Exp $")
d379 8
d404 1
a404 1
	size_t m;
d406 1
a406 1
	size_t l;
d418 1
a418 1
			(void) sm_strlcpy(buf, s, m + 1);
d421 2
a422 2
		(void) sm_strlcpy(buf, s, m - 2);
		(void) sm_strlcat(buf, "...", sizeof buf);
d426 3
a428 2
	(void) sm_strlcpy(buf, s, m + 1);
	(void) sm_strlcat2(buf, "...", s + l - m, sizeof buf);
@


