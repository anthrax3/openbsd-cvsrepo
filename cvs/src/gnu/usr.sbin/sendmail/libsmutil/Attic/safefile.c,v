head	1.12;
access;
symbols
	OPENBSD_5_6:1.11.0.6
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.10
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.8
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.6
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.4
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.9.0.26
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.24
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.20
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.22
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.18
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.16
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.14
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.12
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.10
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.8
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.7.0.8
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.11;
commitid	M7i5giHIoz3DMlTU;

1.11
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2011.05.17.15.54.23;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.16.00.21.30;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.06.24.03.59.26;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.03.17.25.46;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.01.01.01.40;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.15.21.09.04;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.02.19.05.41;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.41;	author millert;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.07;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.49;	author millert;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	2001.05.31.00.29.29;	author miod;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2004 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>
#include <sm/io.h>
#include <sm/errstring.h>

SM_RCSID("@@(#)$Sendmail: safefile.c,v 8.130 2013/11/22 20:51:50 ca Exp $")


/*
**  SAFEFILE -- return 0 if a file exists and is safe for a user.
**
**	Parameters:
**		fn -- filename to check.
**		uid -- user id to compare against.
**		gid -- group id to compare against.
**		user -- user name to compare against (used for group
**			sets).
**		flags -- modifiers:
**			SFF_MUSTOWN -- "uid" must own this file.
**			SFF_NOSLINK -- file cannot be a symbolic link.
**		mode -- mode bits that must match.
**		st -- if set, points to a stat structure that will
**			get the stat info for the file.
**
**	Returns:
**		0 if fn exists, is owned by uid, and matches mode.
**		An errno otherwise.  The actual errno is cleared.
**
**	Side Effects:
**		none.
*/

int
safefile(fn, uid, gid, user, flags, mode, st)
	char *fn;
	UID_T uid;
	GID_T gid;
	char *user;
	long flags;
	int mode;
	struct stat *st;
{
	register char *p;
	register struct group *gr = NULL;
	int file_errno = 0;
	bool checkpath;
	struct stat stbuf;
	struct stat fstbuf;
	char fbuf[MAXPATHLEN];

	if (tTd(44, 4))
		sm_dprintf("safefile(%s, uid=%d, gid=%d, flags=%lx, mode=%o):\n",
			fn, (int) uid, (int) gid, flags, mode);
	errno = 0;
	if (sm_strlcpy(fbuf, fn, sizeof fbuf) >= sizeof fbuf)
	{
		if (tTd(44, 4))
			sm_dprintf("\tpathname too long\n");
		return ENAMETOOLONG;
	}
	fn = fbuf;
	if (st == NULL)
		st = &fstbuf;

	/* ignore SFF_SAFEDIRPATH if we are debugging */
	if (RealUid != 0 && RunAsUid == RealUid)
		flags &= ~SFF_SAFEDIRPATH;

	/* first check to see if the file exists at all */
# if HASLSTAT
	if ((bitset(SFF_NOSLINK, flags) ? lstat(fn, st)
					: stat(fn, st)) < 0)
# else /* HASLSTAT */
	if (stat(fn, st) < 0)
# endif /* HASLSTAT */
	{
		file_errno = errno;
	}
	else if (bitset(SFF_SETUIDOK, flags) &&
		 !bitset(S_IXUSR|S_IXGRP|S_IXOTH, st->st_mode) &&
		 S_ISREG(st->st_mode))
	{
		/*
		**  If final file is set-user-ID, run as the owner of that
		**  file.  Gotta be careful not to reveal anything too
		**  soon here!
		*/

# ifdef SUID_ROOT_FILES_OK
		if (bitset(S_ISUID, st->st_mode))
# else /* SUID_ROOT_FILES_OK */
		if (bitset(S_ISUID, st->st_mode) && st->st_uid != 0 &&
		    st->st_uid != TrustedUid)
# endif /* SUID_ROOT_FILES_OK */
		{
			uid = st->st_uid;
			user = NULL;
		}
# ifdef SUID_ROOT_FILES_OK
		if (bitset(S_ISGID, st->st_mode))
# else /* SUID_ROOT_FILES_OK */
		if (bitset(S_ISGID, st->st_mode) && st->st_gid != 0)
# endif /* SUID_ROOT_FILES_OK */
			gid = st->st_gid;
	}

	checkpath = !bitset(SFF_NOPATHCHECK, flags) ||
		    (uid == 0 && !bitset(SFF_ROOTOK|SFF_OPENASROOT, flags));
	if (bitset(SFF_NOWLINK, flags) && !bitset(SFF_SAFEDIRPATH, flags))
	{
		int ret;

		/* check the directory */
		p = strrchr(fn, '/');
		if (p == NULL)
		{
			ret = safedirpath(".", uid, gid, user,
					  flags|SFF_SAFEDIRPATH, 0, 0);
		}
		else
		{
			*p = '\0';
			ret = safedirpath(fn, uid, gid, user,
					  flags|SFF_SAFEDIRPATH, 0, 0);
			*p = '/';
		}
		if (ret == 0)
		{
			/* directory is safe */
			checkpath = false;
		}
		else
		{
# if HASLSTAT
			/* Need lstat() information if called stat() before */
			if (!bitset(SFF_NOSLINK, flags) && lstat(fn, st) < 0)
			{
				ret = errno;
				if (tTd(44, 4))
					sm_dprintf("\t%s\n", sm_errstring(ret));
				return ret;
			}
# endif /* HASLSTAT */
			/* directory is writable: disallow links */
			flags |= SFF_NOLINK;
		}
	}

	if (checkpath)
	{
		int ret;

		p = strrchr(fn, '/');
		if (p == NULL)
		{
			ret = safedirpath(".", uid, gid, user, flags, 0, 0);
		}
		else
		{
			*p = '\0';
			ret = safedirpath(fn, uid, gid, user, flags, 0, 0);
			*p = '/';
		}
		if (ret != 0)
			return ret;
	}

	/*
	**  If the target file doesn't exist, check the directory to
	**  ensure that it is writable by this user.
	*/

	if (file_errno != 0)
	{
		int ret = file_errno;
		char *dir = fn;

		if (tTd(44, 4))
			sm_dprintf("\t%s\n", sm_errstring(ret));

		errno = 0;
		if (!bitset(SFF_CREAT, flags) || file_errno != ENOENT)
			return ret;

		/* check to see if legal to create the file */
		p = strrchr(dir, '/');
		if (p == NULL)
			dir = ".";
		else if (p == dir)
			dir = "/";
		else
			*p = '\0';
		if (stat(dir, &stbuf) >= 0)
		{
			int md = S_IWRITE|S_IEXEC;

			ret = 0;
			if (stbuf.st_uid == uid)
				/* EMPTY */
				;
			else if (uid == 0 && stbuf.st_uid == TrustedUid)
				/* EMPTY */
				;
			else
			{
				md >>= 3;
				if (stbuf.st_gid == gid)
					/* EMPTY */
					;
# ifndef NO_GROUP_SET
				else if (user != NULL && !DontInitGroups &&
					 ((gr != NULL &&
					   gr->gr_gid == stbuf.st_gid) ||
					  (gr = getgrgid(stbuf.st_gid)) != NULL))
				{
					register char **gp;

					for (gp = gr->gr_mem; *gp != NULL; gp++)
						if (strcmp(*gp, user) == 0)
							break;
					if (*gp == NULL)
						md >>= 3;
				}
# endif /* ! NO_GROUP_SET */
				else
					md >>= 3;
			}
			if ((stbuf.st_mode & md) != md)
				ret = errno = EACCES;
		}
		else
			ret = errno;
		if (tTd(44, 4))
			sm_dprintf("\t[final dir %s uid %d mode %lo] %s\n",
				dir, (int) stbuf.st_uid,
				(unsigned long) stbuf.st_mode,
				sm_errstring(ret));
		if (p != NULL)
			*p = '/';
		st->st_mode = ST_MODE_NOFILE;
		return ret;
	}

# ifdef S_ISLNK
	if (bitset(SFF_NOSLINK, flags) && S_ISLNK(st->st_mode))
	{
		if (tTd(44, 4))
			sm_dprintf("\t[slink mode %lo]\tE_SM_NOSLINK\n",
				(unsigned long) st->st_mode);
		return E_SM_NOSLINK;
	}
# endif /* S_ISLNK */
	if (bitset(SFF_REGONLY, flags) && !S_ISREG(st->st_mode))
	{
		if (tTd(44, 4))
			sm_dprintf("\t[non-reg mode %lo]\tE_SM_REGONLY\n",
				(unsigned long) st->st_mode);
		return E_SM_REGONLY;
	}
	if (bitset(SFF_NOGWFILES, flags) &&
	    bitset(S_IWGRP, st->st_mode))
	{
		if (tTd(44, 4))
			sm_dprintf("\t[write bits %lo]\tE_SM_GWFILE\n",
				(unsigned long) st->st_mode);
		return E_SM_GWFILE;
	}
	if (bitset(SFF_NOWWFILES, flags) &&
	    bitset(S_IWOTH, st->st_mode))
	{
		if (tTd(44, 4))
			sm_dprintf("\t[write bits %lo]\tE_SM_WWFILE\n",
				(unsigned long) st->st_mode);
		return E_SM_WWFILE;
	}
	if (bitset(SFF_NOGRFILES, flags) && bitset(S_IRGRP, st->st_mode))
	{
		if (tTd(44, 4))
			sm_dprintf("\t[read bits %lo]\tE_SM_GRFILE\n",
				(unsigned long) st->st_mode);
		return E_SM_GRFILE;
	}
	if (bitset(SFF_NOWRFILES, flags) && bitset(S_IROTH, st->st_mode))
	{
		if (tTd(44, 4))
			sm_dprintf("\t[read bits %lo]\tE_SM_WRFILE\n",
				(unsigned long) st->st_mode);
		return E_SM_WRFILE;
	}
	if (!bitset(SFF_EXECOK, flags) &&
	    bitset(S_IWUSR|S_IWGRP|S_IWOTH, mode) &&
	    bitset(S_IXUSR|S_IXGRP|S_IXOTH, st->st_mode))
	{
		if (tTd(44, 4))
			sm_dprintf("\t[exec bits %lo]\tE_SM_ISEXEC\n",
				(unsigned long) st->st_mode);
		return E_SM_ISEXEC;
	}
	if (bitset(SFF_NOHLINK, flags) && st->st_nlink != 1)
	{
		if (tTd(44, 4))
			sm_dprintf("\t[link count %d]\tE_SM_NOHLINK\n",
				(int) st->st_nlink);
		return E_SM_NOHLINK;
	}

	if (uid == 0 && bitset(SFF_OPENASROOT, flags))
		/* EMPTY */
		;
	else if (uid == 0 && !bitset(SFF_ROOTOK, flags))
		mode >>= 6;
	else if (st->st_uid == uid)
		/* EMPTY */
		;
	else if (uid == 0 && st->st_uid == TrustedUid)
		/* EMPTY */
		;
	else
	{
		mode >>= 3;
		if (st->st_gid == gid)
			/* EMPTY */
			;
# ifndef NO_GROUP_SET
		else if (user != NULL && !DontInitGroups &&
			 ((gr != NULL && gr->gr_gid == st->st_gid) ||
			  (gr = getgrgid(st->st_gid)) != NULL))
		{
			register char **gp;

			for (gp = gr->gr_mem; *gp != NULL; gp++)
				if (strcmp(*gp, user) == 0)
					break;
			if (*gp == NULL)
				mode >>= 3;
		}
# endif /* ! NO_GROUP_SET */
		else
			mode >>= 3;
	}
	if (tTd(44, 4))
		sm_dprintf("\t[uid %d, nlink %d, stat %lo, mode %lo] ",
			(int) st->st_uid, (int) st->st_nlink,
			(unsigned long) st->st_mode, (unsigned long) mode);
	if ((st->st_uid == uid || st->st_uid == 0 ||
	     st->st_uid == TrustedUid ||
	     !bitset(SFF_MUSTOWN, flags)) &&
	    (st->st_mode & mode) == mode)
	{
		if (tTd(44, 4))
			sm_dprintf("\tOK\n");
		return 0;
	}
	if (tTd(44, 4))
		sm_dprintf("\tEACCES\n");
	return EACCES;
}
/*
**  SAFEDIRPATH -- check to make sure a path to a directory is safe
**
**	Safe means not writable and owned by the right folks.
**
**	Parameters:
**		fn -- filename to check.
**		uid -- user id to compare against.
**		gid -- group id to compare against.
**		user -- user name to compare against (used for group
**			sets).
**		flags -- modifiers:
**			SFF_ROOTOK -- ok to use root permissions to open.
**			SFF_SAFEDIRPATH -- writable directories are considered
**				to be fatal errors.
**		level -- symlink recursive level.
**		offset -- offset into fn to start checking from.
**
**	Returns:
**		0 -- if the directory path is "safe".
**		else -- an error number associated with the path.
*/

int
safedirpath(fn, uid, gid, user, flags, level, offset)
	char *fn;
	UID_T uid;
	GID_T gid;
	char *user;
	long flags;
	int level;
	int offset;
{
	int ret = 0;
	int mode = S_IWOTH;
	char save = '\0';
	char *saveptr = NULL;
	char *p, *enddir;
	register struct group *gr = NULL;
	char s[MAXLINKPATHLEN];
	struct stat stbuf;

	/* make sure we aren't in a symlink loop */
	if (level > MAXSYMLINKS)
		return ELOOP;

	if (level < 0 || offset < 0 || offset > strlen(fn))
		return EINVAL;

	/* special case root directory */
	if (*fn == '\0')
		fn = "/";

	if (tTd(44, 4))
		sm_dprintf("safedirpath(%s, uid=%ld, gid=%ld, flags=%lx, level=%d, offset=%d):\n",
			fn, (long) uid, (long) gid, flags, level, offset);

	if (!bitnset(DBS_GROUPWRITABLEDIRPATHSAFE, DontBlameSendmail))
		mode |= S_IWGRP;

	/* Make a modifiable copy of the filename */
	if (sm_strlcpy(s, fn, sizeof s) >= sizeof s)
		return EINVAL;

	p = s + offset;
	while (p != NULL)
	{
		/* put back character */
		if (saveptr != NULL)
		{
			*saveptr = save;
			saveptr = NULL;
			p++;
		}

		if (*p == '\0')
			break;

		p = strchr(p, '/');

		/* Special case for root directory */
		if (p == s)
		{
			save = *(p + 1);
			saveptr = p + 1;
			*(p + 1) = '\0';
		}
		else if (p != NULL)
		{
			save = *p;
			saveptr = p;
			*p = '\0';
		}

		/* Heuristic: . and .. have already been checked */
		enddir = strrchr(s, '/');
		if (enddir != NULL &&
		    (strcmp(enddir, "/..") == 0 ||
		     strcmp(enddir, "/.") == 0))
			continue;

		if (tTd(44, 20))
			sm_dprintf("\t[dir %s]\n", s);

# if HASLSTAT
		ret = lstat(s, &stbuf);
# else /* HASLSTAT */
		ret = stat(s, &stbuf);
# endif /* HASLSTAT */
		if (ret < 0)
		{
			ret = errno;
			break;
		}

# ifdef S_ISLNK
		/* Follow symlinks */
		if (S_ISLNK(stbuf.st_mode))
		{
			int linklen;
			char *target;
			char buf[MAXPATHLEN];
			char fullbuf[MAXLINKPATHLEN];

			memset(buf, '\0', sizeof buf);
			linklen = readlink(s, buf, sizeof buf);
			if (linklen < 0)
			{
				ret = errno;
				break;
			}
			if (linklen >= sizeof buf)
			{
				/* file name too long for buffer */
				ret = errno = EINVAL;
				break;
			}

			offset = 0;
			if (*buf == '/')
			{
				target = buf;

				/* If path is the same, avoid rechecks */
				while (s[offset] == buf[offset] &&
				       s[offset] != '\0')
					offset++;

				if (s[offset] == '\0' && buf[offset] == '\0')
				{
					/* strings match, symlink loop */
					return ELOOP;
				}

				/* back off from the mismatch */
				if (offset > 0)
					offset--;

				/* Make sure we are at a directory break */
				if (offset > 0 &&
				    s[offset] != '/' &&
				    s[offset] != '\0')
				{
					while (buf[offset] != '/' &&
					       offset > 0)
						offset--;
				}
				if (offset > 0 &&
				    s[offset] == '/' &&
				    buf[offset] == '/')
				{
					/* Include the trailing slash */
					offset++;
				}
			}
			else
			{
				char *sptr;

				sptr = strrchr(s, '/');
				if (sptr != NULL)
				{
					*sptr = '\0';
					offset = sptr + 1 - s;
					if (sm_strlcpyn(fullbuf,
							sizeof fullbuf, 2,
							s, "/") >=
						sizeof fullbuf ||
					    sm_strlcat(fullbuf, buf,
						       sizeof fullbuf) >=
						sizeof fullbuf)
					{
						ret = EINVAL;
						break;
					}
					*sptr = '/';
				}
				else
				{
					if (sm_strlcpy(fullbuf, buf,
						       sizeof fullbuf) >=
						sizeof fullbuf)
					{
						ret = EINVAL;
						break;
					}
				}
				target = fullbuf;
			}
			ret = safedirpath(target, uid, gid, user, flags,
					  level + 1, offset);
			if (ret != 0)
				break;

			/* Don't check permissions on the link file itself */
			continue;
		}
#endif /* S_ISLNK */

		if ((uid == 0 || bitset(SFF_SAFEDIRPATH, flags)) &&
#ifdef S_ISVTX
		    !(bitnset(DBS_TRUSTSTICKYBIT, DontBlameSendmail) &&
		      bitset(S_ISVTX, stbuf.st_mode)) &&
#endif /* S_ISVTX */
		    bitset(mode, stbuf.st_mode))
		{
			if (tTd(44, 4))
				sm_dprintf("\t[dir %s] mode %lo ",
					s, (unsigned long) stbuf.st_mode);
			if (bitset(SFF_SAFEDIRPATH, flags))
			{
				if (bitset(S_IWOTH, stbuf.st_mode))
					ret = E_SM_WWDIR;
				else
					ret = E_SM_GWDIR;
				if (tTd(44, 4))
					sm_dprintf("FATAL\n");
				break;
			}
			if (tTd(44, 4))
				sm_dprintf("WARNING\n");
			if (Verbose > 1)
				message("051 WARNING: %s writable directory %s",
					bitset(S_IWOTH, stbuf.st_mode)
					   ? "World"
					   : "Group",
					s);
		}
		if (uid == 0 && !bitset(SFF_ROOTOK|SFF_OPENASROOT, flags))
		{
			if (bitset(S_IXOTH, stbuf.st_mode))
				continue;
			ret = EACCES;
			break;
		}

		/*
		**  Let OS determine access to file if we are not
		**  running as a privileged user.  This allows ACLs
		**  to work.  Also, if opening as root, assume we can
		**  scan the directory.
		*/
		if (geteuid() != 0 || bitset(SFF_OPENASROOT, flags))
			continue;

		if (stbuf.st_uid == uid &&
		    bitset(S_IXUSR, stbuf.st_mode))
			continue;
		if (stbuf.st_gid == gid &&
		    bitset(S_IXGRP, stbuf.st_mode))
			continue;
# ifndef NO_GROUP_SET
		if (user != NULL && !DontInitGroups &&
		    ((gr != NULL && gr->gr_gid == stbuf.st_gid) ||
		     (gr = getgrgid(stbuf.st_gid)) != NULL))
		{
			register char **gp;

			for (gp = gr->gr_mem; gp != NULL && *gp != NULL; gp++)
				if (strcmp(*gp, user) == 0)
					break;
			if (gp != NULL && *gp != NULL &&
			    bitset(S_IXGRP, stbuf.st_mode))
				continue;
		}
# endif /* ! NO_GROUP_SET */
		if (!bitset(S_IXOTH, stbuf.st_mode))
		{
			ret = EACCES;
			break;
		}
	}
	if (tTd(44, 4))
		sm_dprintf("\t[dir %s] %s\n", fn,
			ret == 0 ? "OK" : sm_errstring(ret));
	return ret;
}
/*
**  SAFEOPEN -- do a file open with extra checking
**
**	Parameters:
**		fn -- the file name to open.
**		omode -- the open-style mode flags.
**		cmode -- the create-style mode flags.
**		sff -- safefile flags.
**
**	Returns:
**		Same as open.
*/

int
safeopen(fn, omode, cmode, sff)
	char *fn;
	int omode;
	int cmode;
	long sff;
{
#if !NOFTRUNCATE
	bool truncate;
#endif /* !NOFTRUNCATE */
	int rval;
	int fd;
	int smode;
	struct stat stb;

	if (tTd(44, 10))
		sm_dprintf("safeopen: fn=%s, omode=%x, cmode=%x, sff=%lx\n",
			   fn, omode, cmode, sff);

	if (bitset(O_CREAT, omode))
		sff |= SFF_CREAT;
	omode &= ~O_CREAT;
	switch (omode & O_ACCMODE)
	{
	  case O_RDONLY:
		smode = S_IREAD;
		break;

	  case O_WRONLY:
		smode = S_IWRITE;
		break;

	  case O_RDWR:
		smode = S_IREAD|S_IWRITE;
		break;

	  default:
		smode = 0;
		break;
	}
	if (bitset(SFF_OPENASROOT, sff))
		rval = safefile(fn, RunAsUid, RunAsGid, RunAsUserName,
				sff, smode, &stb);
	else
		rval = safefile(fn, RealUid, RealGid, RealUserName,
				sff, smode, &stb);
	if (rval != 0)
	{
		errno = rval;
		return -1;
	}
	if (stb.st_mode == ST_MODE_NOFILE && bitset(SFF_CREAT, sff))
		omode |= O_CREAT | (bitset(SFF_NOTEXCL, sff) ? 0 : O_EXCL);
	else if (bitset(SFF_CREAT, sff) && bitset(O_EXCL, omode))
	{
		/* The file exists so an exclusive create would fail */
		errno = EEXIST;
		return -1;
	}

#if !NOFTRUNCATE
	truncate = bitset(O_TRUNC, omode);
	if (truncate)
		omode &= ~O_TRUNC;
#endif /* !NOFTRUNCATE */

	fd = dfopen(fn, omode, cmode, sff);
	if (fd < 0)
		return fd;
	if (filechanged(fn, fd, &stb))
	{
		syserr("554 5.3.0 cannot open: file %s changed after open", fn);
		(void) close(fd);
		errno = E_SM_FILECHANGE;
		return -1;
	}

#if !NOFTRUNCATE
	if (truncate &&
	    ftruncate(fd, (off_t) 0) < 0)
	{
		int save_errno;

		save_errno = errno;
		syserr("554 5.3.0 cannot open: file %s could not be truncated",
		       fn);
		(void) close(fd);
		errno = save_errno;
		return -1;
	}
#endif /* !NOFTRUNCATE */

	return fd;
}
/*
**  SAFEFOPEN -- do a file open with extra checking
**
**	Parameters:
**		fn -- the file name to open.
**		omode -- the open-style mode flags.
**		cmode -- the create-style mode flags.
**		sff -- safefile flags.
**
**	Returns:
**		Same as fopen.
*/

SM_FILE_T *
safefopen(fn, omode, cmode, sff)
	char *fn;
	int omode;
	int cmode;
	long sff;
{
	int fd;
	int save_errno;
	SM_FILE_T *fp;
	int fmode;

	switch (omode & O_ACCMODE)
	{
	  case O_RDONLY:
		fmode = SM_IO_RDONLY;
		break;

	  case O_WRONLY:
		if (bitset(O_APPEND, omode))
			fmode = SM_IO_APPEND;
		else
			fmode = SM_IO_WRONLY;
		break;

	  case O_RDWR:
		if (bitset(O_TRUNC, omode))
			fmode = SM_IO_RDWRTR;
		else if (bitset(O_APPEND, omode))
			fmode = SM_IO_APPENDRW;
		else
			fmode = SM_IO_RDWR;
		break;

	  default:
		syserr("554 5.3.5 safefopen: unknown omode %o", omode);
		fmode = 0;
	}
	fd = safeopen(fn, omode, cmode, sff);
	if (fd < 0)
	{
		save_errno = errno;
		if (tTd(44, 10))
			sm_dprintf("safefopen: safeopen failed: %s\n",
				   sm_errstring(errno));
		errno = save_errno;
		return NULL;
	}
	fp = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT,
			(void *) &fd, fmode, NULL);
	if (fp != NULL)
		return fp;

	save_errno = errno;
	if (tTd(44, 10))
	{
		sm_dprintf("safefopen: fdopen(%s, %d) failed: omode=%x, sff=%lx, err=%s\n",
			   fn, fmode, omode, sff, sm_errstring(errno));
	}
	(void) close(fd);
	errno = save_errno;
	return NULL;
}
/*
**  FILECHANGED -- check to see if file changed after being opened
**
**	Parameters:
**		fn -- pathname of file to check.
**		fd -- file descriptor to check.
**		stb -- stat structure from before open.
**
**	Returns:
**		true -- if a problem was detected.
**		false -- if this file is still the same.
*/

bool
filechanged(fn, fd, stb)
	char *fn;
	int fd;
	struct stat *stb;
{
	struct stat sta;

	if (stb->st_mode == ST_MODE_NOFILE)
	{
# if HASLSTAT && BOGUS_O_EXCL
		/* only necessary if exclusive open follows symbolic links */
		if (lstat(fn, stb) < 0 || stb->st_nlink != 1)
			return true;
# else /* HASLSTAT && BOGUS_O_EXCL */
		return false;
# endif /* HASLSTAT && BOGUS_O_EXCL */
	}
	if (fstat(fd, &sta) < 0)
		return true;

	if (sta.st_nlink != stb->st_nlink ||
	    sta.st_dev != stb->st_dev ||
	    sta.st_ino != stb->st_ino ||
# if HAS_ST_GEN && 0		/* AFS returns garbage in st_gen */
	    sta.st_gen != stb->st_gen ||
# endif /* HAS_ST_GEN && 0 */
	    sta.st_uid != stb->st_uid ||
	    sta.st_gid != stb->st_gid)
	{
		if (tTd(44, 8))
		{
			sm_dprintf("File changed after opening:\n");
			sm_dprintf(" nlink	= %ld/%ld\n",
				(long) stb->st_nlink, (long) sta.st_nlink);
			sm_dprintf(" dev	= %ld/%ld\n",
				(long) stb->st_dev, (long) sta.st_dev);
			sm_dprintf(" ino	= %llu/%llu\n",
				(ULONGLONG_T) stb->st_ino,
				(ULONGLONG_T) sta.st_ino);
# if HAS_ST_GEN
			sm_dprintf(" gen	= %ld/%ld\n",
				(long) stb->st_gen, (long) sta.st_gen);
# endif /* HAS_ST_GEN */
			sm_dprintf(" uid	= %ld/%ld\n",
				(long) stb->st_uid, (long) sta.st_uid);
			sm_dprintf(" gid	= %ld/%ld\n",
				(long) stb->st_gid, (long) sta.st_gid);
		}
		return true;
	}

	return false;
}
/*
**  DFOPEN -- determined file open
**
**	This routine has the semantics of open, except that it will
**	keep trying a few times to make this happen.  The idea is that
**	on very loaded systems, we may run out of resources (inodes,
**	whatever), so this tries to get around it.
*/

int
dfopen(filename, omode, cmode, sff)
	char *filename;
	int omode;
	int cmode;
	long sff;
{
	register int tries;
	int fd = -1;
	struct stat st;

	for (tries = 0; tries < 10; tries++)
	{
		(void) sleep((unsigned) (10 * tries));
		errno = 0;
		fd = open(filename, omode, cmode);
		if (fd >= 0)
			break;
		switch (errno)
		{
		  case ENFILE:		/* system file table full */
		  case EINTR:		/* interrupted syscall */
#ifdef ETXTBSY
		  case ETXTBSY:		/* Apollo: net file locked */
#endif /* ETXTBSY */
			continue;
		}
		break;
	}
	if (!bitset(SFF_NOLOCK, sff) &&
	    fd >= 0 &&
	    fstat(fd, &st) >= 0 &&
	    S_ISREG(st.st_mode))
	{
		int locktype;

		/* lock the file to avoid accidental conflicts */
		if ((omode & O_ACCMODE) != O_RDONLY)
			locktype = LOCK_EX;
		else
			locktype = LOCK_SH;
		if (bitset(SFF_NBLOCK, sff))
			locktype |= LOCK_NB;

		if (!lockfile(fd, filename, NULL, locktype))
		{
			int save_errno = errno;

			(void) close(fd);
			fd = -1;
			errno = save_errno;
		}
		else
			errno = 0;
	}
	return fd;
}
@


1.11
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.10
log
@Update to sendmail 8.14.5
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004 Sendmail, Inc. and its suppliers.
d18 1
a18 1
SM_RCSID("@@(#)$Sendmail: safefile.c,v 8.129 2008/08/04 18:07:04 gshapiro Exp $")
@


1.9
log
@Update to sendmail-8.13.2
@
text
@d18 1
a18 1
SM_RCSID("@@(#)$Sendmail: safefile.c,v 8.128 2004/09/30 18:15:49 ca Exp $")
a701 1
	smode = 0;
@


1.8
log
@Update to sendmail.8.13.0
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d18 1
a18 1
SM_RCSID("@@(#)$Sendmail: safefile.c,v 8.127 2004/05/27 22:37:51 msk Exp $")
d492 1
a547 1
				char fullbuf[MAXLINKPATHLEN];
@


1.7
log
@Update to sendmail-8.12.4
@
text
@d18 1
a18 1
SM_RCSID("@@(#)$Sendmail: safefile.c,v 8.124 2002/05/24 20:50:15 gshapiro Exp $")
d307 1
a307 1
			sm_dprintf("\t[exec bits %lo]\tE_SM_ISEXEC]\n",
d687 3
d741 6
d757 16
d968 3
@


1.6
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d18 1
a18 1
SM_RCSID("@@(#)$Sendmail: safefile.c,v 8.121 2001/10/11 21:46:13 gshapiro Exp $")
d61 1
a61 1
	char fbuf[MAXPATHLEN + 1];
d409 1
a409 1
	char s[MAXLINKPATHLEN + 1];
d489 1
d491 1
a491 1
			char buf[MAXPATHLEN + 1];
d494 2
a495 1
			if (readlink(s, buf, sizeof buf) < 0)
d500 6
d547 1
a547 1
				char fullbuf[MAXLINKPATHLEN + 1];
@


1.5
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d18 1
a18 1
SM_RCSID("@@(#)$Sendmail: safefile.c,v 8.118 2001/09/18 21:45:27 gshapiro Exp $")
d209 1
d241 1
a241 1
				errno = EACCES;
d243 2
a244 1
		ret = errno;
@


1.4
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d18 1
a18 1
SM_RCSID("@@(#)$Sendmail: safefile.c,v 8.114 2001/09/08 01:21:03 gshapiro Exp $")
d21 1
a21 1
/*
d368 1
a368 1
/*
d657 1
a657 1
/*
d740 1
a740 1
/*
d801 2
a802 1
	fp = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT, (void *) fd, fmode, NULL);
d816 1
a816 1
/*
d883 1
a883 1
/*
@


1.3
log
@update to sendmail 8.11.5
@
text
@d14 3
a16 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: safefile.c,v 8.81.4.10 2001/07/20 04:19:36 gshapiro Exp $";
#endif /* ! lint */
d18 1
a18 1
#include <sendmail.h>
d64 1
a64 1
		dprintf("safefile(%s, uid=%d, gid=%d, flags=%lx, mode=%o):\n",
d67 1
a67 3
	if (st == NULL)
		st = &fstbuf;
	if (strlcpy(fbuf, fn, sizeof fbuf) >= sizeof fbuf)
d70 1
a70 1
			dprintf("\tpathname too long\n");
d74 2
d96 1
a96 1
		**  If final file is setuid, run as the owner of that
d142 1
a142 1
			checkpath = FALSE;
d152 1
a152 1
					dprintf("\t%s\n", errstring(ret));
d191 1
a191 1
			dprintf("\t%s\n", errstring(ret));
d244 4
a247 3
			dprintf("\t[final dir %s uid %d mode %lo] %s\n",
				dir, (int) stbuf.st_uid, (u_long) stbuf.st_mode,
				errstring(ret));
d258 2
a259 2
			dprintf("\t[slink mode %lo]\tE_SM_NOSLINK\n",
				(u_long) st->st_mode);
d266 2
a267 2
			dprintf("\t[non-reg mode %lo]\tE_SM_REGONLY\n",
				(u_long) st->st_mode);
d274 2
a275 2
			dprintf("\t[write bits %lo]\tE_SM_GWFILE\n",
				(u_long) st->st_mode);
d282 2
a283 2
			dprintf("\t[write bits %lo]\tE_SM_WWFILE\n",
				(u_long) st->st_mode);
d289 2
a290 2
			dprintf("\t[read bits %lo]\tE_SM_GRFILE\n",
				(u_long) st->st_mode);
d296 2
a297 2
			dprintf("\t[read bits %lo]\tE_SM_WRFILE\n",
				(u_long) st->st_mode);
d305 2
a306 2
			dprintf("\t[exec bits %lo]\tE_SM_ISEXEC]\n",
				(u_long) st->st_mode);
d312 1
a312 1
			dprintf("\t[link count %d]\tE_SM_NOHLINK\n",
d352 1
a352 1
		dprintf("\t[uid %d, nlink %d, stat %lo, mode %lo] ",
d354 1
a354 1
			(u_long) st->st_mode, (u_long) mode);
d361 1
a361 1
			dprintf("\tOK\n");
d365 1
a365 1
		dprintf("\tEACCES\n");
d414 3
d422 1
a422 1
		dprintf("safedirpath(%s, uid=%ld, gid=%ld, flags=%lx, level=%d, offset=%d):\n",
d429 1
a429 1
	if (strlcpy(s, fn, sizeof s) >= sizeof s)
d470 1
a470 1
			dprintf("\t[dir %s]\n", s);
d544 7
a550 2
					if ((strlen(s) + 1 +
					     strlen(buf) + 1) > sizeof fullbuf)
a554 2
					snprintf(fullbuf, sizeof fullbuf,
						 "%s/%s", s, buf);
d559 3
a561 1
					if (strlen(buf) + 1 > sizeof fullbuf)
a565 2
					(void) strlcpy(fullbuf, buf,
						       sizeof fullbuf);
d587 2
a588 2
				dprintf("\t[dir %s] mode %lo ",
					s, (u_long) stbuf.st_mode);
d596 1
a596 1
					dprintf("FATAL\n");
d600 1
a600 1
				dprintf("WARNING\n");
d653 2
a654 2
		dprintf("\t[dir %s] %s\n", fn,
			ret == 0 ? "OK" : errstring(ret));
d683 2
a684 2
		printf("safeopen: fn=%s, omode=%x, cmode=%x, sff=%lx\n",
		       fn, omode, cmode, sff);
d741 75
d824 2
a825 2
**		TRUE -- if a problem was detected.
**		FALSE -- if this file is still the same.
d841 1
a841 1
			return TRUE;
d843 1
a843 1
		return FALSE;
d847 1
a847 1
		return TRUE;
d860 2
a861 2
			dprintf("File changed after opening:\n");
			dprintf(" nlink	= %ld/%ld\n",
d863 1
a863 1
			dprintf(" dev	= %ld/%ld\n",
d865 3
a867 11
			if (sizeof sta.st_ino > sizeof (long))
			{
				dprintf(" ino	= %s/",
					quad_to_string(stb->st_ino));
				dprintf("%s\n",
					quad_to_string(sta.st_ino));
			}
			else
				dprintf(" ino	= %lu/%lu\n",
					(unsigned long) stb->st_ino,
					(unsigned long) sta.st_ino);
d869 1
a869 1
			dprintf(" gen	= %ld/%ld\n",
d872 1
a872 1
			dprintf(" uid	= %ld/%ld\n",
d874 1
a874 1
			dprintf(" gid	= %ld/%ld\n",
d877 1
a877 1
		return TRUE;
d880 1
a880 1
	return FALSE;
@


1.2
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: safefile.c,v 8.81.4.7 2000/09/01 21:09:23 ca Exp $";
a662 4
#ifndef O_ACCMODE
# define O_ACCMODE	(O_RDONLY|O_WRONLY|O_RDWR)
#endif /* ! O_ACCMODE */

a731 75
}
/*
**  SAFEFOPEN -- do a file open with extra checking
**
**	Parameters:
**		fn -- the file name to open.
**		omode -- the open-style mode flags.
**		cmode -- the create-style mode flags.
**		sff -- safefile flags.
**
**	Returns:
**		Same as fopen.
*/

FILE *
safefopen(fn, omode, cmode, sff)
	char *fn;
	int omode;
	int cmode;
	long sff;
{
	int fd;
	int save_errno;
	FILE *fp;
	char *fmode;

	switch (omode & O_ACCMODE)
	{
	  case O_RDONLY:
		fmode = "r";
		break;

	  case O_WRONLY:
		if (bitset(O_APPEND, omode))
			fmode = "a";
		else
			fmode = "w";
		break;

	  case O_RDWR:
		if (bitset(O_TRUNC, omode))
			fmode = "w+";
		else if (bitset(O_APPEND, omode))
			fmode = "a+";
		else
			fmode = "r+";
		break;

	  default:
		syserr("554 5.3.5 safefopen: unknown omode %o", omode);
		fmode = "x";
	}
	fd = safeopen(fn, omode, cmode, sff);
	if (fd < 0)
	{
		save_errno = errno;
		if (tTd(44, 10))
			dprintf("safefopen: safeopen failed: %s\n",
				errstring(errno));
		errno = save_errno;
		return NULL;
	}
	fp = fdopen(fd, fmode);
	if (fp != NULL)
		return fp;

	save_errno = errno;
	if (tTd(44, 10))
	{
		dprintf("safefopen: fdopen(%s, %s) failed: omode=%x, sff=%lx, err=%s\n",
			fn, fmode, omode, sff, errstring(errno));
	}
	(void) close(fd);
	errno = save_errno;
	return NULL;
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: safefile.c,v 8.81 2000/02/26 01:32:17 gshapiro Exp $";
d19 2
d22 1
a22 1
**  SAFEFILE -- return true if a file exists and is safe for a user.
d82 1
a82 1
#if HASLSTAT
d85 1
a85 1
#else /* HASLSTAT */
d87 1
a87 1
#endif /* HASLSTAT */
d101 1
a101 1
#ifdef SUID_ROOT_FILES_OK
d103 1
a103 1
#else /* SUID_ROOT_FILES_OK */
d106 1
a106 1
#endif /* SUID_ROOT_FILES_OK */
d111 1
a111 1
#ifdef SUID_ROOT_FILES_OK
d113 1
a113 1
#else /* SUID_ROOT_FILES_OK */
d115 1
a115 1
#endif /* SUID_ROOT_FILES_OK */
d146 1
a146 1
#if HASLSTAT
d155 1
a155 1
#endif /* HASLSTAT */
d221 1
a221 1
#ifndef NO_GROUP_SET
d235 1
a235 1
#endif /* ! NO_GROUP_SET */
d253 1
a253 1
#ifdef S_ISLNK
d261 1
a261 1
#endif /* S_ISLNK */
d333 1
a333 1
#ifndef NO_GROUP_SET
d346 1
a346 1
#endif /* ! NO_GROUP_SET */
d468 1
a468 1
#if HASLSTAT
d470 1
a470 1
#else /* HASLSTAT */
d472 1
a472 1
#endif /* HASLSTAT */
d479 1
a479 1
#ifdef S_ISLNK
d624 1
a624 1
#ifndef NO_GROUP_SET
d638 1
a638 1
#endif /* ! NO_GROUP_SET */
d835 1
a835 1
#if HASLSTAT && BOGUS_O_EXCL
d839 1
a839 1
#else /* HASLSTAT && BOGUS_O_EXCL */
d841 1
a841 1
#endif /* HASLSTAT && BOGUS_O_EXCL */
d849 1
a849 1
#if HAS_ST_GEN && 0		/* AFS returns garbage in st_gen */
d851 1
a851 1
#endif /* HAS_ST_GEN && 0 */
d873 1
a873 1
#if HAS_ST_GEN
d876 1
a876 1
#endif /* HAS_ST_GEN */
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.1.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: safefile.c,v 8.81.4.7 2000/09/01 21:09:23 ca Exp $";
a18 2


d20 1
a20 1
**  SAFEFILE -- return 0 if a file exists and is safe for a user.
d80 1
a80 1
# if HASLSTAT
d83 1
a83 1
# else /* HASLSTAT */
d85 1
a85 1
# endif /* HASLSTAT */
d99 1
a99 1
# ifdef SUID_ROOT_FILES_OK
d101 1
a101 1
# else /* SUID_ROOT_FILES_OK */
d104 1
a104 1
# endif /* SUID_ROOT_FILES_OK */
d109 1
a109 1
# ifdef SUID_ROOT_FILES_OK
d111 1
a111 1
# else /* SUID_ROOT_FILES_OK */
d113 1
a113 1
# endif /* SUID_ROOT_FILES_OK */
d144 1
a144 1
# if HASLSTAT
d153 1
a153 1
# endif /* HASLSTAT */
d219 1
a219 1
# ifndef NO_GROUP_SET
d233 1
a233 1
# endif /* ! NO_GROUP_SET */
d251 1
a251 1
# ifdef S_ISLNK
d259 1
a259 1
# endif /* S_ISLNK */
d331 1
a331 1
# ifndef NO_GROUP_SET
d344 1
a344 1
# endif /* ! NO_GROUP_SET */
d466 1
a466 1
# if HASLSTAT
d468 1
a468 1
# else /* HASLSTAT */
d470 1
a470 1
# endif /* HASLSTAT */
d477 1
a477 1
# ifdef S_ISLNK
d622 1
a622 1
# ifndef NO_GROUP_SET
d636 1
a636 1
# endif /* ! NO_GROUP_SET */
d833 1
a833 1
# if HASLSTAT && BOGUS_O_EXCL
d837 1
a837 1
# else /* HASLSTAT && BOGUS_O_EXCL */
d839 1
a839 1
# endif /* HASLSTAT && BOGUS_O_EXCL */
d847 1
a847 1
# if HAS_ST_GEN && 0		/* AFS returns garbage in st_gen */
d849 1
a849 1
# endif /* HAS_ST_GEN && 0 */
d871 1
a871 1
# if HAS_ST_GEN
d874 1
a874 1
# endif /* HAS_ST_GEN */
@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Id: safefile.c,v 8.81.4.7 2000/09/01 21:09:23 ca Exp $";
a18 2


d20 1
a20 1
**  SAFEFILE -- return 0 if a file exists and is safe for a user.
d80 1
a80 1
# if HASLSTAT
d83 1
a83 1
# else /* HASLSTAT */
d85 1
a85 1
# endif /* HASLSTAT */
d99 1
a99 1
# ifdef SUID_ROOT_FILES_OK
d101 1
a101 1
# else /* SUID_ROOT_FILES_OK */
d104 1
a104 1
# endif /* SUID_ROOT_FILES_OK */
d109 1
a109 1
# ifdef SUID_ROOT_FILES_OK
d111 1
a111 1
# else /* SUID_ROOT_FILES_OK */
d113 1
a113 1
# endif /* SUID_ROOT_FILES_OK */
d144 1
a144 1
# if HASLSTAT
d153 1
a153 1
# endif /* HASLSTAT */
d219 1
a219 1
# ifndef NO_GROUP_SET
d233 1
a233 1
# endif /* ! NO_GROUP_SET */
d251 1
a251 1
# ifdef S_ISLNK
d259 1
a259 1
# endif /* S_ISLNK */
d331 1
a331 1
# ifndef NO_GROUP_SET
d344 1
a344 1
# endif /* ! NO_GROUP_SET */
d466 1
a466 1
# if HASLSTAT
d468 1
a468 1
# else /* HASLSTAT */
d470 1
a470 1
# endif /* HASLSTAT */
d477 1
a477 1
# ifdef S_ISLNK
d622 1
a622 1
# ifndef NO_GROUP_SET
d636 1
a636 1
# endif /* ! NO_GROUP_SET */
d833 1
a833 1
# if HASLSTAT && BOGUS_O_EXCL
d837 1
a837 1
# else /* HASLSTAT && BOGUS_O_EXCL */
d839 1
a839 1
# endif /* HASLSTAT && BOGUS_O_EXCL */
d847 1
a847 1
# if HAS_ST_GEN && 0		/* AFS returns garbage in st_gen */
d849 1
a849 1
# endif /* HAS_ST_GEN && 0 */
d871 1
a871 1
# if HAS_ST_GEN
d874 1
a874 1
# endif /* HAS_ST_GEN */
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d14 4
a18 4
#include <sm/io.h>
#include <sm/errstring.h>

SM_RCSID("@@(#)$Sendmail: safefile.c,v 8.114 2001/09/08 01:21:03 gshapiro Exp $")
d64 1
a64 1
		sm_dprintf("safefile(%s, uid=%d, gid=%d, flags=%lx, mode=%o):\n",
d67 3
a69 1
	if (sm_strlcpy(fbuf, fn, sizeof fbuf) >= sizeof fbuf)
d72 1
a72 1
			sm_dprintf("\tpathname too long\n");
a75 2
	if (st == NULL)
		st = &fstbuf;
d96 1
a96 1
		**  If final file is set-user-ID, run as the owner of that
d142 1
a142 1
			checkpath = false;
d152 1
a152 1
					sm_dprintf("\t%s\n", sm_errstring(ret));
d191 1
a191 1
			sm_dprintf("\t%s\n", sm_errstring(ret));
d244 3
a246 4
			sm_dprintf("\t[final dir %s uid %d mode %lo] %s\n",
				dir, (int) stbuf.st_uid,
				(unsigned long) stbuf.st_mode,
				sm_errstring(ret));
d257 2
a258 2
			sm_dprintf("\t[slink mode %lo]\tE_SM_NOSLINK\n",
				(unsigned long) st->st_mode);
d265 2
a266 2
			sm_dprintf("\t[non-reg mode %lo]\tE_SM_REGONLY\n",
				(unsigned long) st->st_mode);
d273 2
a274 2
			sm_dprintf("\t[write bits %lo]\tE_SM_GWFILE\n",
				(unsigned long) st->st_mode);
d281 2
a282 2
			sm_dprintf("\t[write bits %lo]\tE_SM_WWFILE\n",
				(unsigned long) st->st_mode);
d288 2
a289 2
			sm_dprintf("\t[read bits %lo]\tE_SM_GRFILE\n",
				(unsigned long) st->st_mode);
d295 2
a296 2
			sm_dprintf("\t[read bits %lo]\tE_SM_WRFILE\n",
				(unsigned long) st->st_mode);
d304 2
a305 2
			sm_dprintf("\t[exec bits %lo]\tE_SM_ISEXEC]\n",
				(unsigned long) st->st_mode);
d311 1
a311 1
			sm_dprintf("\t[link count %d]\tE_SM_NOHLINK\n",
d351 1
a351 1
		sm_dprintf("\t[uid %d, nlink %d, stat %lo, mode %lo] ",
d353 1
a353 1
			(unsigned long) st->st_mode, (unsigned long) mode);
d360 1
a360 1
			sm_dprintf("\tOK\n");
d364 1
a364 1
		sm_dprintf("\tEACCES\n");
a412 3
	if (level < 0 || offset < 0 || offset > strlen(fn))
		return EINVAL;

d418 1
a418 1
		sm_dprintf("safedirpath(%s, uid=%ld, gid=%ld, flags=%lx, level=%d, offset=%d):\n",
d425 1
a425 1
	if (sm_strlcpy(s, fn, sizeof s) >= sizeof s)
d466 1
a466 1
			sm_dprintf("\t[dir %s]\n", s);
d540 2
a541 7
					if (sm_strlcpyn(fullbuf,
							sizeof fullbuf, 2,
							s, "/") >=
						sizeof fullbuf ||
					    sm_strlcat(fullbuf, buf,
						       sizeof fullbuf) >=
						sizeof fullbuf)
d546 2
d552 1
a552 3
					if (sm_strlcpy(fullbuf, buf,
						       sizeof fullbuf) >=
						sizeof fullbuf)
d557 2
d580 2
a581 2
				sm_dprintf("\t[dir %s] mode %lo ",
					s, (unsigned long) stbuf.st_mode);
d589 1
a589 1
					sm_dprintf("FATAL\n");
d593 1
a593 1
				sm_dprintf("WARNING\n");
d646 2
a647 2
		sm_dprintf("\t[dir %s] %s\n", fn,
			ret == 0 ? "OK" : sm_errstring(ret));
d663 4
d680 2
a681 2
		sm_dprintf("safeopen: fn=%s, omode=%x, cmode=%x, sff=%lx\n",
			   fn, omode, cmode, sff);
d750 1
a750 1
SM_FILE_T *
d759 2
a760 2
	SM_FILE_T *fp;
	int fmode;
d765 1
a765 1
		fmode = SM_IO_RDONLY;
d770 1
a770 1
			fmode = SM_IO_APPEND;
d772 1
a772 1
			fmode = SM_IO_WRONLY;
d777 1
a777 1
			fmode = SM_IO_RDWRTR;
d779 1
a779 1
			fmode = SM_IO_APPENDRW;
d781 1
a781 1
			fmode = SM_IO_RDWR;
d786 1
a786 1
		fmode = 0;
d793 2
a794 2
			sm_dprintf("safefopen: safeopen failed: %s\n",
				   sm_errstring(errno));
d798 1
a798 1
	fp = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT, (void *) fd, fmode, NULL);
d805 2
a806 2
		sm_dprintf("safefopen: fdopen(%s, %d) failed: omode=%x, sff=%lx, err=%s\n",
			   fn, fmode, omode, sff, sm_errstring(errno));
d821 2
a822 2
**		true -- if a problem was detected.
**		false -- if this file is still the same.
d838 1
a838 1
			return true;
d840 1
a840 1
		return false;
d844 1
a844 1
		return true;
d857 2
a858 2
			sm_dprintf("File changed after opening:\n");
			sm_dprintf(" nlink	= %ld/%ld\n",
d860 1
a860 1
			sm_dprintf(" dev	= %ld/%ld\n",
d862 11
a872 3
			sm_dprintf(" ino	= %llu/%llu\n",
				(ULONGLONG_T) stb->st_ino,
				(ULONGLONG_T) sta.st_ino);
d874 1
a874 1
			sm_dprintf(" gen	= %ld/%ld\n",
d877 1
a877 1
			sm_dprintf(" uid	= %ld/%ld\n",
d879 1
a879 1
			sm_dprintf(" gid	= %ld/%ld\n",
d882 1
a882 1
		return true;
d885 1
a885 1
	return false;
@


