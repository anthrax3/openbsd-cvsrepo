head	1.20;
access;
symbols
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.8
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.12
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.10
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.6
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.8
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.4
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.15.0.6
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.4
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.14.0.8
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.6
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.12.0.6
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2014.09.17.18.49.52;	author matthieu;	state dead;
branches;
next	1.19;
commitid	M7i5giHIoz3DMlTU;

1.19
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.17;

1.17
date	2011.05.17.15.54.24;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.16.00.21.31;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.24.03.59.28;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.01.19.59.24;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.15.02.23.36;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.03.17.25.47;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.18.00.49.29;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.14.03.21.41;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.01.17.18.30;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.11.19.02.51;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.29.01.31.17;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.28.02.43.56;	author millert;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.01.15.21.09.12;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.07.19.20.47;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.44;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.52;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.32.13;	author miod;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.31.01.47.59;	author jason;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Bye.
@
text
@/*
 * Copyright (c) 1999-2002, 2009 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1987, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1983 Eric P. Allman.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sm/gen.h>

SM_IDSTR(copyright,
"@@(#) Copyright (c) 1999-2002, 2009 Proofpoint, Inc. and its suppliers.\n\
	All rights reserved.\n\
     Copyright (c) 1983, 1987, 1993\n\
	The Regents of the University of California.  All rights reserved.\n\
     Copyright (c) 1983 Eric P. Allman.  All rights reserved.\n")

SM_IDSTR(id, "@@(#)$Sendmail: vacation.c,v 8.148 2013/11/22 20:52:02 ca Exp $")


#include <ctype.h>
#include <stdlib.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>
#ifdef EX_OK
# undef EX_OK		/* unistd.h may have another use for this */
#endif /* EX_OK */
#include <sm/sysexits.h>

#include <sm/cf.h>
#include <sm/mbdb.h>
#include "sendmail/sendmail.h"
#include <sendmail/pathnames.h>
#include "libsmdb/smdb.h"

#define ONLY_ONCE	((time_t) 0)	/* send at most one reply */
#define INTERVAL_UNDEF	((time_t) (-1))	/* no value given */

uid_t	RealUid;
gid_t	RealGid;
char	*RealUserName;
uid_t	RunAsUid;
gid_t	RunAsGid;
char	*RunAsUserName;
int	Verbose = 2;
bool	DontInitGroups = false;
uid_t	TrustedUid = 0;
BITMAP256 DontBlameSendmail;

static int readheaders __P((bool));
static bool junkmail __P((char *));
static bool nsearch __P((char *, char *));
static void usage __P((void));
static void setinterval __P((time_t));
static bool recent __P((void));
static void setreply __P((char *, time_t));
static void sendmessage __P((char *, char *, char *));
static void xclude __P((SM_FILE_T *));

/*
**  VACATION -- return a message to the sender when on vacation.
**
**	This program is invoked as a message receiver.  It returns a
**	message specified by the user to whomever sent the mail, taking
**	care not to return a message too often to prevent "I am on
**	vacation" loops.
*/

#define	VDB	".vacation"		/* vacation database */
#define	VMSG	".vacation.msg"		/* vacation message */
#define SECSPERDAY	(60 * 60 * 24)
#define DAYSPERWEEK	7

typedef struct alias
{
	char *name;
	struct alias *next;
} ALIAS;

ALIAS *Names = NULL;

SMDB_DATABASE *Db;

char From[MAXLINE];
bool CloseMBDB = false;

#if defined(__hpux) || defined(__osf__)
# ifndef SM_CONF_SYSLOG_INT
#  define SM_CONF_SYSLOG_INT	1
# endif /* SM_CONF_SYSLOG_INT */
#endif /* defined(__hpux) || defined(__osf__) */

#if SM_CONF_SYSLOG_INT
# define SYSLOG_RET_T	int
# define SYSLOG_RET	return 0
#else /* SM_CONF_SYSLOG_INT */
# define SYSLOG_RET_T	void
# define SYSLOG_RET
#endif /* SM_CONF_SYSLOG_INT */

typedef SYSLOG_RET_T SYSLOG_T __P((int, const char *, ...));
SYSLOG_T *msglog = syslog;
static SYSLOG_RET_T debuglog __P((int, const char *, ...));
static void eatmsg __P((void));
static void listdb __P((void));

/* exit after reading input */
#define EXITIT(excode)			\
{					\
	eatmsg();			\
	if (CloseMBDB)			\
	{				\
		sm_mbdb_terminate();	\
		CloseMBDB = false;	\
	}				\
	return excode;			\
}

#define EXITM(excode)			\
{					\
	if (!initdb && !list)		\
		eatmsg();		\
	if (CloseMBDB)			\
	{				\
		sm_mbdb_terminate();	\
		CloseMBDB = false;	\
	}				\
	exit(excode);			\
}

int
main(argc, argv)
	int argc;
	char **argv;
{
	bool alwaysrespond = false;
	bool initdb, exclude;
	bool runasuser = false;
	bool list = false;
	int mfail = 0, ufail = 0;
	int ch;
	int result;
	long sff;
	time_t interval;
	struct passwd *pw;
	ALIAS *cur;
	char *dbfilename = NULL;
	char *msgfilename = NULL;
	char *cfpath = NULL;
	char *name = NULL;
	char *returnaddr = NULL;
	SMDB_USER_INFO user_info;
	static char rnamebuf[MAXNAME];
	extern int optind, opterr;
	extern char *optarg;

	/* Vars needed to link with smutil */
	clrbitmap(DontBlameSendmail);
	RunAsUid = RealUid = getuid();
	RunAsGid = RealGid = getgid();
	pw = getpwuid(RealUid);
	if (pw != NULL)
	{
		if (strlen(pw->pw_name) > MAXNAME - 1)
			pw->pw_name[MAXNAME] = '\0';
		sm_snprintf(rnamebuf, sizeof rnamebuf, "%s", pw->pw_name);
	}
	else
		sm_snprintf(rnamebuf, sizeof rnamebuf,
			    "Unknown UID %d", (int) RealUid);
	RunAsUserName = RealUserName = rnamebuf;

# ifdef LOG_MAIL
	openlog("vacation", LOG_PID, LOG_MAIL);
# else /* LOG_MAIL */
	openlog("vacation", LOG_PID);
# endif /* LOG_MAIL */

	opterr = 0;
	initdb = false;
	exclude = false;
	interval = INTERVAL_UNDEF;
	*From = '\0';


#define OPTIONS	"a:C:df:Iijlm:R:r:s:t:Uxz"

	while (mfail == 0 && ufail == 0 &&
	       (ch = getopt(argc, argv, OPTIONS)) != -1)
	{
		switch((char)ch)
		{
		  case 'a':			/* alias */
			cur = (ALIAS *) malloc((unsigned int) sizeof(ALIAS));
			if (cur == NULL)
			{
				mfail++;
				break;
			}
			cur->name = optarg;
			cur->next = Names;
			Names = cur;
			break;

		  case 'C':
			cfpath = optarg;
			break;

		  case 'd':			/* debug mode */
			msglog = debuglog;
			break;

		  case 'f':		/* alternate database */
			dbfilename = optarg;
			break;

		  case 'I':			/* backward compatible */
		  case 'i':			/* init the database */
			initdb = true;
			break;

		  case 'j':
			alwaysrespond = true;
			break;

		  case 'l':
			list = true;		/* list the database */
			break;

		  case 'm':		/* alternate message file */
			msgfilename = optarg;
			break;

		  case 'R':
			returnaddr = optarg;
			break;

		  case 'r':
			if (isascii(*optarg) && isdigit(*optarg))
			{
				interval = atol(optarg) * SECSPERDAY;
				if (interval < 0)
					ufail++;
			}
			else
				interval = ONLY_ONCE;
			break;

		  case 's':		/* alternate sender name */
			(void) sm_strlcpy(From, optarg, sizeof From);
			break;

		  case 't':		/* SunOS: -t1d (default expire) */
			break;

		  case 'U':		/* run as single user mode */
			runasuser = true;
			break;

		  case 'x':
			exclude = true;
			break;

		  case 'z':
			returnaddr = "<>";
			break;

		  case '?':
		  default:
			ufail++;
			break;
		}
	}
	argc -= optind;
	argv += optind;

	if (mfail != 0)
	{
		msglog(LOG_NOTICE,
		       "vacation: can't allocate memory for alias.\n");
		EXITM(EX_TEMPFAIL);
	}
	if (ufail != 0)
		usage();

	if (argc != 1)
	{
		if (!initdb && !list && !exclude)
			usage();
		if ((pw = getpwuid(getuid())) == NULL)
		{
			msglog(LOG_ERR,
			       "vacation: no such user uid %u.\n", getuid());
			EXITM(EX_NOUSER);
		}
		name = strdup(pw->pw_name);
		user_info.smdbu_id = pw->pw_uid;
		user_info.smdbu_group_id = pw->pw_gid;
		(void) sm_strlcpy(user_info.smdbu_name, pw->pw_name,
				  SMDB_MAX_USER_NAME_LEN);
		if (chdir(pw->pw_dir) != 0)
		{
			msglog(LOG_NOTICE,
			       "vacation: no such directory %s.\n",
			       pw->pw_dir);
			EXITM(EX_NOINPUT);
		}
	}
	else if (runasuser)
	{
		name = strdup(*argv);
		if (dbfilename == NULL || msgfilename == NULL)
		{
			msglog(LOG_NOTICE,
			       "vacation: -U requires setting both -f and -m\n");
			EXITM(EX_NOINPUT);
		}
		user_info.smdbu_id = pw->pw_uid;
		user_info.smdbu_group_id = pw->pw_gid;
		(void) sm_strlcpy(user_info.smdbu_name, pw->pw_name,
			       SMDB_MAX_USER_NAME_LEN);
	}
	else
	{
		int err;
		SM_CF_OPT_T mbdbname;
		SM_MBDB_T user;

		cfpath = getcfname(0, 0, SM_GET_SENDMAIL_CF, cfpath);
		mbdbname.opt_name = "MailboxDatabase";
		mbdbname.opt_val = "pw";
		(void) sm_cf_getopt(cfpath, 1, &mbdbname);
		err = sm_mbdb_initialize(mbdbname.opt_val);
		if (err != EX_OK)
		{
			msglog(LOG_ERR,
			       "vacation: can't open mailbox database: %s.\n",
			       sm_strexit(err));
			EXITM(err);
		}
		CloseMBDB = true;
		err = sm_mbdb_lookup(*argv, &user);
		if (err == EX_NOUSER)
		{
			msglog(LOG_ERR, "vacation: no such user %s.\n", *argv);
			EXITM(EX_NOUSER);
		}
		if (err != EX_OK)
		{
			msglog(LOG_ERR,
			       "vacation: can't read mailbox database: %s.\n",
			       sm_strexit(err));
			EXITM(err);
		}
		name = strdup(user.mbdb_name);
		if (chdir(user.mbdb_homedir) != 0)
		{
			msglog(LOG_NOTICE,
			       "vacation: no such directory %s.\n",
			       user.mbdb_homedir);
			EXITM(EX_NOINPUT);
		}
		user_info.smdbu_id = user.mbdb_uid;
		user_info.smdbu_group_id = user.mbdb_gid;
		(void) sm_strlcpy(user_info.smdbu_name, user.mbdb_name,
			       SMDB_MAX_USER_NAME_LEN);
	}
	if (name == NULL)
	{
		msglog(LOG_ERR,
		       "vacation: can't allocate memory for username.\n");
		EXITM(EX_OSERR);
	}

	if (dbfilename == NULL)
		dbfilename = VDB;
	if (msgfilename == NULL)
		msgfilename = VMSG;

	sff = SFF_CREAT;
	if (getegid() != getgid())
	{
		/* Allow a set-group-ID vacation binary */
		RunAsGid = user_info.smdbu_group_id = getegid();
		sff |= SFF_OPENASROOT;
	}
	if (getuid() == 0)
	{
		/* Allow root to initialize user's vacation databases */
		sff |= SFF_OPENASROOT|SFF_ROOTOK;

		/* ... safely */
		sff |= SFF_NOSLINK|SFF_NOHLINK|SFF_REGONLY;
	}


	result = smdb_open_database(&Db, dbfilename,
				    O_CREAT|O_RDWR | (initdb ? O_TRUNC : 0),
				    S_IRUSR|S_IWUSR, sff,
				    SMDB_TYPE_DEFAULT, &user_info, NULL);
	if (result != SMDBE_OK)
	{
		msglog(LOG_NOTICE, "vacation: %s: %s\n", dbfilename,
		       sm_errstring(result));
		EXITM(EX_DATAERR);
	}

	if (list)
	{
		listdb();
		(void) Db->smdb_close(Db);
		exit(EX_OK);
	}

	if (interval != INTERVAL_UNDEF)
		setinterval(interval);

	if (initdb && !exclude)
	{
		(void) Db->smdb_close(Db);
		exit(EX_OK);
	}

	if (exclude)
	{
		xclude(smioin);
		(void) Db->smdb_close(Db);
		EXITM(EX_OK);
	}

	if ((cur = (ALIAS *) malloc((unsigned int) sizeof(ALIAS))) == NULL)
	{
		msglog(LOG_NOTICE,
		       "vacation: can't allocate memory for username.\n");
		(void) Db->smdb_close(Db);
		EXITM(EX_OSERR);
	}
	cur->name = name;
	cur->next = Names;
	Names = cur;

	result = readheaders(alwaysrespond);
	if (result == EX_OK && !recent())
	{
		time_t now;

		(void) time(&now);
		setreply(From, now);
		(void) Db->smdb_close(Db);
		sendmessage(name, msgfilename, returnaddr);
	}
	else
		(void) Db->smdb_close(Db);
	if (result == EX_NOUSER)
		result = EX_OK;
	exit(result);
}

/*
** EATMSG -- read stdin till EOF
**
**	Parameters:
**		none.
**
**	Returns:
**		nothing.
**
*/

static void
eatmsg()
{
	/*
	**  read the rest of the e-mail and ignore it to avoid problems
	**  with EPIPE in sendmail
	*/
	while (getc(stdin) != EOF)
		continue;
}

/*
** READHEADERS -- read mail headers
**
**	Parameters:
**		alwaysrespond -- respond regardless of whether msg is to me
**
**	Returns:
**		a exit code: NOUSER if no reply, OK if reply, * if error
**
**	Side Effects:
**		may exit().
**
*/

static int
readheaders(alwaysrespond)
	bool alwaysrespond;
{
	bool tome, cont;
	register char *p;
	register ALIAS *cur;
	char buf[MAXLINE];

	cont = false;
	tome = alwaysrespond;
	while (sm_io_fgets(smioin, SM_TIME_DEFAULT, buf, sizeof(buf)) >= 0 &&
	       *buf != '\n')
	{
		switch(*buf)
		{
		  case 'F':		/* "From " */
			cont = false;
			if (strncmp(buf, "From ", 5) == 0)
			{
				bool quoted = false;

				p = buf + 5;
				while (*p != '\0')
				{
					/* escaped character */
					if (*p == '\\')
					{
						p++;
						if (*p == '\0')
						{
							msglog(LOG_NOTICE,
							       "vacation: badly formatted \"From \" line.\n");
							EXITIT(EX_DATAERR);
						}
					}
					else if (*p == '"')
						quoted = !quoted;
					else if (*p == '\r' || *p == '\n')
						break;
					else if (*p == ' ' && !quoted)
						break;
					p++;
				}
				if (quoted)
				{
					msglog(LOG_NOTICE,
					       "vacation: badly formatted \"From \" line.\n");
					EXITIT(EX_DATAERR);
				}
				*p = '\0';

				/* ok since both strings have MAXLINE length */
				if (*From == '\0')
					(void) sm_strlcpy(From, buf + 5,
							  sizeof From);
				if ((p = strchr(buf + 5, '\n')) != NULL)
					*p = '\0';
				if (junkmail(buf + 5))
					EXITIT(EX_NOUSER);
			}
			break;

		  case 'P':		/* "Precedence:" */
		  case 'p':
			cont = false;
			if (strlen(buf) <= 10 ||
			    strncasecmp(buf, "Precedence", 10) != 0 ||
			    (buf[10] != ':' && buf[10] != ' ' &&
			     buf[10] != '\t'))
				break;
			if ((p = strchr(buf, ':')) == NULL)
				break;
			while (*++p != '\0' && isascii(*p) && isspace(*p));
			if (*p == '\0')
				break;
			if (strncasecmp(p, "junk", 4) == 0 ||
			    strncasecmp(p, "bulk", 4) == 0 ||
			    strncasecmp(p, "list", 4) == 0)
				EXITIT(EX_NOUSER);
			break;

		  case 'C':		/* "Cc:" */
		  case 'c':
			if (strncasecmp(buf, "Cc:", 3) != 0)
				break;
			cont = true;
			goto findme;

		  case 'T':		/* "To:" */
		  case 't':
			if (strncasecmp(buf, "To:", 3) != 0)
				break;
			cont = true;
			goto findme;

		  default:
			if (!isascii(*buf) || !isspace(*buf) || !cont || tome)
			{
				cont = false;
				break;
			}
findme:
			for (cur = Names;
			     !tome && cur != NULL;
			     cur = cur->next)
				tome = nsearch(cur->name, buf);
		}
	}
	if (!tome)
		EXITIT(EX_NOUSER);
	if (*From == '\0')
	{
		msglog(LOG_NOTICE, "vacation: no initial \"From \" line.\n");
		EXITIT(EX_DATAERR);
	}
	EXITIT(EX_OK);
}

/*
** NSEARCH --
**	do a nice, slow, search of a string for a substring.
**
**	Parameters:
**		name -- name to search.
**		str -- string in which to search.
**
**	Returns:
**		is name a substring of str?
**
*/

static bool
nsearch(name, str)
	register char *name, *str;
{
	register size_t len;
	register char *s;

	len = strlen(name);

	for (s = str; *s != '\0'; ++s)
	{
		/*
		**  Check to make sure that the string matches and
		**  the previous character is not an alphanumeric and
		**  the next character after the match is not an alphanumeric.
		**
		**  This prevents matching "eric" to "derick" while still
		**  matching "eric" to "<eric+detail>".
		*/

		if (tolower(*s) == tolower(*name) &&
		    strncasecmp(name, s, len) == 0 &&
		    (s == str || !isascii(*(s - 1)) || !isalnum(*(s - 1))) &&
		    (!isascii(*(s + len)) || !isalnum(*(s + len))))
			return true;
	}
	return false;
}

/*
** JUNKMAIL --
**	read the header and return if automagic/junk/bulk/list mail
**
**	Parameters:
**		from -- sender address.
**
**	Returns:
**		is this some automated/junk/bulk/list mail?
**
*/

struct ignore
{
	char	*name;
	size_t	len;
};

typedef struct ignore IGNORE_T;

#define MAX_USER_LEN 256	/* maximum length of local part (sender) */

/* delimiters for the local part of an address */
#define isdelim(c)	((c) == '%' || (c) == '@@' || (c) == '+')

static bool
junkmail(from)
	char *from;
{
	bool quot;
	char *e;
	size_t len;
	IGNORE_T *cur;
	char sender[MAX_USER_LEN];
	static IGNORE_T ignore[] =
	{
		{ "postmaster",		10	},
		{ "uucp",		4	},
		{ "mailer-daemon",	13	},
		{ "mailer",		6	},
		{ NULL,			0	}
	};

	static IGNORE_T ignorepost[] =
	{
		{ "-request",		8	},
		{ "-relay",		6	},
		{ "-owner",		6	},
		{ NULL,			0	}
	};

	static IGNORE_T ignorepre[] =
	{
		{ "owner-",		6	},
		{ NULL,			0	}
	};

	/*
	**  This is mildly amusing, and I'm not positive it's right; trying
	**  to find the "real" name of the sender, assuming that addresses
	**  will be some variant of:
	**
	**  From site!site!SENDER%site.domain%site.domain@@site.domain
	*/

	quot = false;
	e = from;
	len = 0;
	while (*e != '\0' && (quot || !isdelim(*e)))
	{
		if (*e == '"')
		{
			quot = !quot;
			++e;
			continue;
		}
		if (*e == '\\')
		{
			if (*(++e) == '\0')
			{
				/* '\\' at end of string? */
				break;
			}
			if (len < MAX_USER_LEN)
				sender[len++] = *e;
			++e;
			continue;
		}
		if (*e == '!' && !quot)
		{
			len = 0;
			sender[len] = '\0';
		}
		else
			if (len < MAX_USER_LEN)
				sender[len++] = *e;
		++e;
	}
	if (len < MAX_USER_LEN)
		sender[len] = '\0';
	else
		sender[MAX_USER_LEN - 1] = '\0';

	if (len <= 0)
		return false;
#if 0
	if (quot)
		return false;	/* syntax error... */
#endif /* 0 */

	/* test prefixes */
	for (cur = ignorepre; cur->name != NULL; ++cur)
	{
		if (len >= cur->len &&
		    strncasecmp(cur->name, sender, cur->len) == 0)
			return true;
	}

	/*
	**  If the name is truncated, don't test the rest.
	**	We could extract the "tail" of the sender address and
	**	compare it it ignorepost, however, it seems not worth
	**	the effort.
	**	The address surely can't match any entry in ignore[]
	**	(as long as all of them are shorter than MAX_USER_LEN).
	*/

	if (len > MAX_USER_LEN)
		return false;

	/* test full local parts */
	for (cur = ignore; cur->name != NULL; ++cur)
	{
		if (len == cur->len &&
		    strncasecmp(cur->name, sender, cur->len) == 0)
			return true;
	}

	/* test postfixes */
	for (cur = ignorepost; cur->name != NULL; ++cur)
	{
		if (len >= cur->len &&
		    strncasecmp(cur->name, e - cur->len - 1,
				cur->len) == 0)
			return true;
	}
	return false;
}

#define	VIT	"__VACATION__INTERVAL__TIMER__"

/*
** RECENT --
**	find out if user has gotten a vacation message recently.
**
**	Parameters:
**		none.
**
**	Returns:
**		true iff user has gotten a vacation message recently.
**
*/

static bool
recent()
{
	SMDB_DBENT key, data;
	time_t then, next;
	bool trydomain = false;
	int st;
	char *domain;

	memset(&key, '\0', sizeof key);
	memset(&data, '\0', sizeof data);

	/* get interval time */
	key.data = VIT;
	key.size = sizeof(VIT);

	st = Db->smdb_get(Db, &key, &data, 0);
	if (st != SMDBE_OK)
		next = SECSPERDAY * DAYSPERWEEK;
	else
		memmove(&next, data.data, sizeof(next));

	memset(&data, '\0', sizeof data);

	/* get record for this address */
	key.data = From;
	key.size = strlen(From);

	do
	{
		st = Db->smdb_get(Db, &key, &data, 0);
		if (st == SMDBE_OK)
		{
			memmove(&then, data.data, sizeof(then));
			if (next == ONLY_ONCE || then == ONLY_ONCE ||
			    then + next > time(NULL))
				return true;
		}
		if ((trydomain = !trydomain) &&
		    (domain = strchr(From, '@@')) != NULL)
		{
			key.data = domain;
			key.size = strlen(domain);
		}
	} while (trydomain);
	return false;
}

/*
** SETINTERVAL --
**	store the reply interval
**
**	Parameters:
**		interval -- time interval for replies.
**
**	Returns:
**		nothing.
**
**	Side Effects:
**		stores the reply interval in database.
*/

static void
setinterval(interval)
	time_t interval;
{
	SMDB_DBENT key, data;

	memset(&key, '\0', sizeof key);
	memset(&data, '\0', sizeof data);

	key.data = VIT;
	key.size = sizeof(VIT);
	data.data = (char*) &interval;
	data.size = sizeof(interval);
	(void) (Db->smdb_put)(Db, &key, &data, 0);
}

/*
** SETREPLY --
**	store that this user knows about the vacation.
**
**	Parameters:
**		from -- sender address.
**		when -- last reply time.
**
**	Returns:
**		nothing.
**
**	Side Effects:
**		stores user/time in database.
*/

static void
setreply(from, when)
	char *from;
	time_t when;
{
	SMDB_DBENT key, data;

	memset(&key, '\0', sizeof key);
	memset(&data, '\0', sizeof data);

	key.data = from;
	key.size = strlen(from);
	data.data = (char*) &when;
	data.size = sizeof(when);
	(void) (Db->smdb_put)(Db, &key, &data, 0);
}

/*
** XCLUDE --
**	add users to vacation db so they don't get a reply.
**
**	Parameters:
**		f -- file pointer with list of address to exclude
**
**	Returns:
**		nothing.
**
**	Side Effects:
**		stores users in database.
*/

static void
xclude(f)
	SM_FILE_T *f;
{
	char buf[MAXLINE], *p;

	if (f == NULL)
		return;
	while (sm_io_fgets(f, SM_TIME_DEFAULT, buf, sizeof buf) >= 0)
	{
		if ((p = strchr(buf, '\n')) != NULL)
			*p = '\0';
		setreply(buf, ONLY_ONCE);
	}
}

/*
** SENDMESSAGE --
**	exec sendmail to send the vacation file to sender
**
**	Parameters:
**		myname -- user name.
**		msgfn -- name of file with vacation message.
**		sender -- use as sender address
**
**	Returns:
**		nothing.
**
**	Side Effects:
**		sends vacation reply.
*/

static void
sendmessage(myname, msgfn, sender)
	char *myname;
	char *msgfn;
	char *sender;
{
	SM_FILE_T *mfp, *sfp;
	int i;
	int pvect[2];
	char *pv[8];
	char buf[MAXLINE];

	mfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, msgfn, SM_IO_RDONLY, NULL);
	if (mfp == NULL)
	{
		if (msgfn[0] == '/')
			msglog(LOG_NOTICE, "vacation: no %s file.\n", msgfn);
		else
			msglog(LOG_NOTICE, "vacation: no ~%s/%s file.\n",
			       myname, msgfn);
		exit(EX_NOINPUT);
	}
	if (pipe(pvect) < 0)
	{
		msglog(LOG_ERR, "vacation: pipe: %s", sm_errstring(errno));
		exit(EX_OSERR);
	}
	pv[0] = "sendmail";
	pv[1] = "-oi";
	pv[2] = "-f";
	if (sender != NULL)
		pv[3] = sender;
	else
		pv[3] = myname;
	pv[4] = "--";
	pv[5] = From;
	pv[6] = NULL;
	i = fork();
	if (i < 0)
	{
		msglog(LOG_ERR, "vacation: fork: %s", sm_errstring(errno));
		exit(EX_OSERR);
	}
	if (i == 0)
	{
		(void) dup2(pvect[0], 0);
		(void) close(pvect[0]);
		(void) close(pvect[1]);
		(void) sm_io_close(mfp, SM_TIME_DEFAULT);
		(void) execv(_PATH_SENDMAIL, pv);
		msglog(LOG_ERR, "vacation: can't exec %s: %s",
			_PATH_SENDMAIL, sm_errstring(errno));
		exit(EX_UNAVAILABLE);
	}
	/* check return status of the following calls? XXX */
	(void) close(pvect[0]);
	if ((sfp = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT,
			      (void *) &(pvect[1]),
			      SM_IO_WRONLY, NULL)) != NULL)
	{
#if _FFR_VAC_WAIT4SM
# ifdef WAITUNION
		union wait st;
# else /* WAITUNION */
		auto int st;
# endif /* WAITUNION */
#endif /* _FFR_VAC_WAIT4SM */

		(void) sm_io_fprintf(sfp, SM_TIME_DEFAULT, "To: %s\n", From);
		(void) sm_io_fprintf(sfp, SM_TIME_DEFAULT,
				     "Auto-Submitted: auto-replied\n");
		while (sm_io_fgets(mfp, SM_TIME_DEFAULT, buf, sizeof buf) >= 0)
			(void) sm_io_fputs(sfp, SM_TIME_DEFAULT, buf);
		(void) sm_io_close(mfp, SM_TIME_DEFAULT);
		(void) sm_io_close(sfp, SM_TIME_DEFAULT);
#if _FFR_VAC_WAIT4SM
		(void) wait(&st);
#endif /* _FFR_VAC_WAIT4SM */
	}
	else
	{
		(void) sm_io_close(mfp, SM_TIME_DEFAULT);
		msglog(LOG_ERR, "vacation: can't open pipe to sendmail");
		exit(EX_UNAVAILABLE);
	}
}

static void
usage()
{
	msglog(LOG_NOTICE,
	       "uid %u: usage: vacation [-a alias] [-C cfpath] [-d] [-f db] [-i] [-j] [-l] [-m msg] [-R returnaddr] [-r interval] [-s sender] [-t time] [-U] [-x] [-z] login\n",
	       getuid());
	exit(EX_USAGE);
}

/*
** LISTDB -- list the contents of the vacation database
**
**	Parameters:
**		none.
**
**	Returns:
**		nothing.
*/

static void
listdb()
{
	int result;
	time_t t;
	SMDB_CURSOR *cursor = NULL;
	SMDB_DBENT db_key, db_value;

	memset(&db_key, '\0', sizeof db_key);
	memset(&db_value, '\0', sizeof db_value);

	result = Db->smdb_cursor(Db, &cursor, 0);
	if (result != SMDBE_OK)
	{
		sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
			      "vacation: set cursor: %s\n",
			      sm_errstring(result));
		return;
	}

	while ((result = cursor->smdbc_get(cursor, &db_key, &db_value,
					   SMDB_CURSOR_GET_NEXT)) == SMDBE_OK)
	{
		char *timestamp;

		/* skip magic VIT entry */
		if (db_key.size == strlen(VIT) + 1 &&
		    strncmp((char *)db_key.data, VIT,
			    (int)db_key.size - 1) == 0)
			continue;

		/* skip bogus values */
		if (db_value.size != sizeof t)
		{
			sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				      "vacation: %.*s invalid time stamp\n",
				      (int) db_key.size, (char *) db_key.data);
			continue;
		}

		memcpy(&t, db_value.data, sizeof t);

		if (db_key.size > 40)
			db_key.size = 40;

		if (t <= 0)
		{
			/* must be an exclude */
			timestamp = "(exclusion)\n";
		}
		else
		{
			timestamp = ctime(&t);
		}
		sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%-40.*s %-10s",
			      (int) db_key.size, (char *) db_key.data,
			      timestamp);

		memset(&db_key, '\0', sizeof db_key);
		memset(&db_value, '\0', sizeof db_value);
	}

	if (result != SMDBE_OK && result != SMDBE_LAST_ENTRY)
	{
		sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
			      "vacation: get value at cursor: %s\n",
			      sm_errstring(result));
		if (cursor != NULL)
		{
			(void) cursor->smdbc_close(cursor);
			cursor = NULL;
		}
		return;
	}
	(void) cursor->smdbc_close(cursor);
	cursor = NULL;
}

/*
** DEBUGLOG -- write message to standard error
**
**	Append a message to the standard error for the convenience of
**	end-users debugging without access to the syslog messages.
**
**	Parameters:
**		i -- syslog log level
**		fmt -- string format
**
**	Returns:
**		nothing.
*/

/*VARARGS2*/
static SYSLOG_RET_T
#ifdef __STDC__
debuglog(int i, const char *fmt, ...)
#else /* __STDC__ */
debuglog(i, fmt, va_alist)
	int i;
	const char *fmt;
	va_dcl
#endif /* __STDC__ */

{
	SM_VA_LOCAL_DECL

	SM_VA_START(ap, fmt);
	sm_io_vfprintf(smioerr, SM_TIME_DEFAULT, fmt, ap);
	SM_VA_END(ap);
	SYSLOG_RET;
}
@


1.19
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.18
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2002, 2009 Sendmail, Inc. and its suppliers.
d17 1
a17 1
"@@(#) Copyright (c) 1999-2002, 2009 Sendmail, Inc. and its suppliers.\n\
d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: vacation.c,v 8.147 2013/03/12 15:24:56 ca Exp $")
@


1.17
log
@Update to sendmail 8.14.5
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: vacation.c,v 8.146 2009/08/07 21:28:39 ca Exp $")
d512 1
a512 1
	while (sm_io_fgets(smioin, SM_TIME_DEFAULT, buf, sizeof(buf)) &&
d957 1
a957 1
	while (sm_io_fgets(f, SM_TIME_DEFAULT, buf, sizeof buf))
d1052 1
a1052 1
		while (sm_io_fgets(mfp, SM_TIME_DEFAULT, buf, sizeof buf))
@


1.16
log
@Update to sendmail-8.14.3
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2002 Sendmail, Inc. and its suppliers.
d17 1
a17 1
"@@(#) Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.\n\
d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: vacation.c,v 8.144 2007/05/11 18:50:36 ca Exp $")
d156 1
a156 1
	char *name;
d302 1
a302 1
		name = pw->pw_name;
d317 1
a317 1
		name = *argv;
d361 1
a361 1
		name = user.mbdb_name;
d374 6
d1041 8
d1056 3
@


1.15
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: vacation.c,v 8.143 2006/12/19 19:00:43 ca Exp $")
d49 1
a49 1
uid_t	RunAsGid;
@


1.14
log
@Update to sendmail-8.13.2
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: vacation.c,v 8.142 2004/11/02 18:25:33 ca Exp $")
d56 10
a161 7
	extern void usage __P((void));
	extern void setinterval __P((time_t));
	extern int readheaders __P((bool));
	extern bool recent __P((void));
	extern void setreply __P((char *, time_t));
	extern void sendmessage __P((char *, char *, char *));
	extern void xclude __P((SM_FILE_T *));
d495 1
a495 1
int
a502 2
	extern bool junkmail __P((char *));
	extern bool nsearch __P((char *, char *));
d627 1
a627 1
bool
d681 1
a681 1
bool
d819 1
a819 1
bool
d881 1
a881 1
void
d912 1
a912 1
void
d943 1
a943 1
void
d975 1
a975 1
void
d1051 1
a1051 1
void
@


1.13
log
@Update to sendmail.8.13.0
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: vacation.c,v 8.141 2002/11/01 16:49:40 ca Exp $")
d81 1
d104 9
a112 4
#define EXITIT(excode) \
{ \
	eatmsg(); \
	return excode; \
d115 10
a124 5
#define EXITM(excode) \
{ \
	if (!initdb && !list) \
		eatmsg(); \
	exit(excode); \
d344 1
@


1.12
log
@update to sendmail 8.12.7
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: vacation.c,v 8.137.2.2 2002/11/01 16:48:55 ca Exp $")
a213 1
#if _FFR_RESPOND_ALL
a216 1
#endif /* _FFR_RESPOND_ALL */
a225 1
#if _FFR_RETURN_ADDR
a228 1
#endif /* _FFR_RETURN_ADDR */
a1040 11
	char *retusage = "";
	char *respusage = "";

#if _FFR_RETURN_ADDR
	retusage = "[-R returnaddr] ";
#endif /* _FFR_RETURN_ADDR */

#if _FFR_RESPOND_ALL
	respusage = "[-j] ";
#endif /* _FFR_RESPOND_ALL */

d1042 2
a1043 2
	       "uid %u: usage: vacation [-a alias] [-C cfpath] [-d] [-f db] [-i] %s[-l] [-m msg] %s[-r interval] [-s sender] [-t time] [-U] [-x] [-z] login\n",
	       getuid(), respusage, retusage);
@


1.11
log
@update to sendmail-8.12.6
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: vacation.c,v 8.137.2.1 2002/08/15 16:23:08 gshapiro Exp $")
d1098 1
a1098 1
		if ((int)db_key.size - 1 == strlen(VIT) &&
@


1.10
log
@Update to sendmail-8.12.4
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: vacation.c,v 8.137 2002/04/22 18:48:12 gshapiro Exp $")
@


1.9
log
@update to sendmail 8.12.3
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: vacation.c,v 8.134 2002/03/01 20:45:00 ca Exp $")
d111 1
a111 1
	if (!iflag && !lflag) \
d121 2
a122 1
	bool iflag, exclude;
d124 1
a124 1
	bool lflag = false;
d143 1
a143 1
	extern int readheaders __P((void));
d172 1
a172 1
	iflag = false;
d178 1
a178 5
#if _FFR_RETURN_ADDR
# define OPTIONS	"a:C:df:Iilm:R:r:s:t:Uxz"
#else /* _FFR_RETURN_ADDR */
# define OPTIONS	"a:C:df:Iilm:r:s:t:Uxz"
#endif /* _FFR_RETURN_ADDR */
d211 6
a216 1
			iflag = true;
d218 1
d221 1
a221 1
			lflag = true;		/* list the database */
d284 1
a284 1
		if (!iflag && !lflag && !exclude)
d387 1
a387 1
				    O_CREAT|O_RDWR | (iflag ? O_TRUNC : 0),
d397 1
a397 1
	if (lflag)
d407 1
a407 1
	if (iflag && !exclude)
d431 1
a431 1
	result = readheaders();
d474 1
a474 1
**		none.
d485 2
a486 1
readheaders()
d495 2
a496 1
	cont = tome = false;
d1045 2
a1046 1
	char *retusage;
a1049 2
#else /* _FFR_RETURN_ADDR */
	retusage = "";
d1052 4
d1057 2
a1058 2
	       "uid %u: usage: vacation [-a alias] [-C cfpath] [-d] [-f db] [-i] [-l] [-m msg] %s[-r interval] [-s sender] [-t time] [-U] [-x] [-z] login\n",
	       getuid(), retusage);
d1095 2
d1117 9
d1128 1
a1128 1
			      ctime(&t));
@


1.8
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: vacation.c,v 8.131 2001/12/12 00:02:42 gshapiro Exp $")
d322 1
a322 1
		cfpath = getcfname(0, 0, SM_GET_SENDMAIL_CF, NULL);
d373 9
@


1.7
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: vacation.c,v 8.130 2001/09/18 21:45:35 gshapiro Exp $")
d121 1
a121 1
	bool iflag, emptysender, exclude;
d135 1
d145 1
a145 1
	extern void sendmessage __P((char *, char *, bool));
a171 1
	emptysender = false;
d176 6
a181 1
#define OPTIONS		"a:C:df:Iilm:r:s:t:Uxz"
d225 6
d258 1
a258 1
			emptysender = true;
d427 1
a427 1
		sendmessage(name, msgfilename, emptysender);
d943 1
a943 1
**		emptysender -- use <> as sender address?
d953 1
a953 1
sendmessage(myname, msgfn, emptysender)
d956 1
a956 1
	bool emptysender;
d982 2
a983 2
	if (emptysender)
		pv[3] = "<>";
d1031 8
d1040 2
a1041 2
	       "uid %u: usage: vacation [-a alias] [-C cfpath] [-d] [-f db] [-i] [-l] [-m msg] [-r interval] [-s sender] [-t time] [-U] [-x] [-z] login\n",
	       getuid());
@


1.6
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: vacation.c,v 8.127 2001/09/08 01:21:15 gshapiro Exp $")
d997 2
a998 1
	if ((sfp = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT, (void *)pvect[1],
@


1.5
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d14 3
a16 2
#ifndef lint
static char copyright[] =
d21 1
a21 2
     Copyright (c) 1983 Eric P. Allman.  All rights reserved.\n";
#endif /* ! lint */
d23 1
a23 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: vacation.c,v 8.68.4.21 2001/05/07 22:06:41 gshapiro Exp $";
#endif /* ! lint */
d34 1
a34 1
#include <sysexits.h>
d36 2
d39 1
a41 8
#if defined(__hpux) && !defined(HPUX11)
# undef syslog		/* Undo hard_syslog conf.h change */
#endif /* defined(__hpux) && !defined(HPUX11) */

#ifndef _PATH_SENDMAIL
# define _PATH_SENDMAIL "/usr/lib/sendmail"
#endif /* ! _PATH_SENDMAIL */

a44 5
#ifndef TRUE
# define TRUE	1
# define FALSE	0
#endif /* ! TRUE */

d52 1
a52 1
bool	DontInitGroups = FALSE;
a69 9
#ifndef __P
# ifdef __STDC__
#  define __P(protos)	protos
# else /* __STDC__ */
#  define __P(protos)	()
#  define const
# endif /* __STDC__ */
#endif /* ! __P */

d82 17
a98 7
#if _FFR_DEBUG
void (*msglog)(int, const char *, ...) = &syslog;
static void debuglog __P((int, const char *, ...));
#else /* _FFR_DEBUG */
# define msglog		syslog
#endif /* _FFR_DEBUG */

d100 1
d103 12
a114 4
#define EXITIT(excode)	{ \
				eatmsg(); \
				return excode; \
			}
d122 2
a123 6
#if _FFR_BLACKBOX
	bool runasuser = FALSE;
#endif /* _FFR_BLACKBOX */
#if _FFR_LISTDB
	bool lflag = FALSE;
#endif /* _FFR_LISTDB */
d133 1
d145 1
a145 14
	extern void xclude __P((FILE *));
#if _FFR_LISTDB
#define EXITM(excode)	{ \
				if (!iflag && !lflag) \
					eatmsg(); \
				exit(excode); \
			}
#else /* _FFR_LISTDB */
#define EXITM(excode)	{ \
				if (!iflag) \
					eatmsg(); \
				exit(excode); \
			}
#endif /* _FFR_LISTDB */
d156 1
a156 1
		snprintf(rnamebuf, sizeof rnamebuf, "%s", pw->pw_name);
d159 2
a160 2
		snprintf(rnamebuf, sizeof rnamebuf,
			 "Unknown UID %d", (int) RealUid);
d170 3
a172 3
	iflag = FALSE;
	emptysender = FALSE;
	exclude = FALSE;
d176 1
a176 1
#define OPTIONS		"a:df:Iilm:r:s:t:Uxz"
d184 1
a184 1
			cur = (ALIAS *)malloc((u_int)sizeof(ALIAS));
d195 4
a198 1
#if _FFR_DEBUG
d200 1
a200 1
			msglog = &debuglog;
a201 1
#endif /* _FFR_DEBUG */
d209 1
a209 1
			iflag = TRUE;
a211 1
#if _FFR_LISTDB
d213 1
a213 1
			lflag = TRUE;		/* list the database */
a214 1
#endif /* _FFR_LISTDB */
d232 1
a232 1
			(void) strlcpy(From, optarg, sizeof From);
a237 1
#if _FFR_BLACKBOX
d239 1
a239 1
			runasuser = TRUE;
a240 1
#endif /* _FFR_BLACKBOX */
d243 1
a243 1
			exclude = TRUE;
d247 1
a247 1
			emptysender = TRUE;
d270 1
a270 5
		if (!iflag &&
#if _FFR_LISTDB
		    !lflag &&
#endif /* _FFR_LISTDB */
		    !exclude)
d281 2
a282 2
		(void) strlcpy(user_info.smdbu_name, pw->pw_name,
			       SMDB_MAX_USER_NAME_LEN);
d285 2
a286 1
			msglog(LOG_NOTICE, "vacation: no such directory %s.\n",
a290 1
#if _FFR_BLACKBOX
d302 1
a302 1
		(void) strlcpy(user_info.smdbu_name, pw->pw_name,
a304 6
#endif /* _FFR_BLACKBOX */
	else if ((pw = getpwnam(*argv)) == NULL)
	{
		msglog(LOG_ERR, "vacation: no such user %s.\n", *argv);
		EXITM(EX_NOUSER);
	}
d307 31
a337 2
		name = pw->pw_name;
		if (chdir(pw->pw_dir) != 0)
d339 3
a341 2
			msglog(LOG_NOTICE, "vacation: no such directory %s.\n",
			       pw->pw_dir);
d344 3
a346 3
		user_info.smdbu_id = pw->pw_uid;
		user_info.smdbu_group_id = pw->pw_gid;
		(void) strlcpy(user_info.smdbu_name, pw->pw_name,
a355 1
#if _FFR_BLACKBOX
d358 1
a358 1
		/* Allow a set-group-id vacation binary */
d360 1
a360 1
		sff |= SFF_NOPATHCHECK|SFF_OPENASROOT;
a361 1
#endif /* _FFR_BLACKBOX */
d370 1
a370 1
		       errstring(result));
a373 1
#if _FFR_LISTDB
a375 2
		static void listdb __P((void));

a379 1
#endif /* _FFR_LISTDB */
d392 1
a392 1
		xclude(stdin);
d397 1
a397 1
	if ((cur = (ALIAS *)malloc((u_int)sizeof(ALIAS))) == NULL)
d471 3
a473 2
	cont = tome = FALSE;
	while (fgets(buf, sizeof(buf), stdin) && *buf != '\n')
d478 1
a478 1
			cont = FALSE;
d481 1
a481 1
				bool quoted = FALSE;
d515 2
a516 2
					(void) strlcpy(From, buf + 5,
						       sizeof From);
d526 1
a526 1
			cont = FALSE;
d547 1
a547 1
			cont = TRUE;
d554 1
a554 1
			cont = TRUE;
d560 1
a560 1
				cont = FALSE;
d617 1
a617 1
			return TRUE;
d619 1
a619 1
	return FALSE;
d687 1
a687 1
	quot = FALSE;
d726 1
a726 1
		return FALSE;
d729 1
a729 1
		return FALSE;	/* syntax error... */
d737 1
a737 1
			return TRUE;
d750 1
a750 1
		return FALSE;
d757 1
a757 1
			return TRUE;
d766 1
a766 1
			return TRUE;
d768 1
a768 1
	return FALSE;
d781 1
a781 1
**		TRUE iff user has gotten a vacation message recently.
d790 1
a790 1
	bool trydomain = FALSE;
d821 1
a821 1
				return TRUE;
d830 1
a830 1
	return FALSE;
d911 1
a911 1
	FILE *f;
d917 1
a917 1
	while (fgets(buf, sizeof buf, f))
d947 1
a947 1
	FILE *mfp, *sfp;
d953 1
a953 1
	mfp = fopen(msgfn, "r");
d965 1
a965 1
		msglog(LOG_ERR, "vacation: pipe: %s", errstring(errno));
d981 1
a981 1
		msglog(LOG_ERR, "vacation: fork: %s", errstring(errno));
d989 1
a989 1
		(void) fclose(mfp);
d992 1
a992 1
			_PATH_SENDMAIL, errstring(errno));
d997 2
a998 1
	if ((sfp = fdopen(pvect[1], "w")) != NULL)
d1000 7
a1006 6
		(void) fprintf(sfp, "To: %s\n", From);
		(void) fprintf(sfp, "Auto-Submitted: auto-generated\n");
		while (fgets(buf, sizeof buf, mfp))
			(void) fputs(buf, sfp);
		(void) fclose(mfp);
		(void) fclose(sfp);
d1010 1
a1010 1
		(void) fclose(mfp);
d1020 2
a1021 18
	       "uid %u: usage: vacation [-a alias]%s [-f db] [-i]%s [-m msg] [-r interval] [-s sender] [-t time]%s [-x] [-z] login\n",
	       getuid(),
#if _FFR_DEBUG
	       " [-d]",
#else /* _FFR_DEBUG */
	       "",
#endif /* _FFR_DEBUG */
#if _FFR_LISTDB
	       " [-l]",
#else /* _FFR_LISTDB */
	       "",
#endif /* _FFR_LISTDB */
#if _FFR_BLACKBOX
	       " [-U]"
#else /* _FFR_BLACKBOX */
	       ""
#endif /* _FFR_BLACKBOX */
	       );
a1024 1
#if _FFR_LISTDB
d1049 3
a1051 2
		fprintf(stderr, "vacation: set cursor: %s\n",
			errstring(result));
d1059 1
a1059 1
		if ((int)db_key.size -1 == strlen(VIT) &&
d1067 3
a1069 2
			fprintf(stderr, "vacation: %.*s invalid time stamp\n",
				(int) db_key.size, (char *) db_key.data);
d1078 3
a1080 2
		printf("%-40.*s %-10s",
		       (int) db_key.size, (char *) db_key.data, ctime(&t));
d1088 3
a1090 2
		fprintf(stderr,	"vacation: get value at cursor: %s\n",
			errstring(result));
a1100 1
#endif /* _FFR_LISTDB */
a1101 1
#if _FFR_DEBUG
d1117 1
a1117 1
static void
d1128 1
a1128 44
	VA_LOCAL_DECL

	VA_START(fmt);
	vfprintf(stderr, fmt, ap);
	VA_END;
}
#endif /* _FFR_DEBUG */

/*VARARGS1*/
void
#ifdef __STDC__
message(const char *msg, ...)
#else /* __STDC__ */
message(msg, va_alist)
	const char *msg;
	va_dcl
#endif /* __STDC__ */
{
	const char *m;
	VA_LOCAL_DECL

	m = msg;
	if (isascii(m[0]) && isdigit(m[0]) &&
	    isascii(m[1]) && isdigit(m[1]) &&
	    isascii(m[2]) && isdigit(m[2]) && m[3] == ' ')
		m += 4;
	VA_START(msg);
	(void) vfprintf(stderr, m, ap);
	VA_END;
	(void) fprintf(stderr, "\n");
}

/*VARARGS1*/
void
#ifdef __STDC__
syserr(const char *msg, ...)
#else /* __STDC__ */
syserr(msg, va_alist)
	const char *msg;
	va_dcl
#endif /* __STDC__ */
{
	const char *m;
	VA_LOCAL_DECL
d1130 4
a1133 18
	m = msg;
	if (isascii(m[0]) && isdigit(m[0]) &&
	    isascii(m[1]) && isdigit(m[1]) &&
	    isascii(m[2]) && isdigit(m[2]) && m[3] == ' ')
		m += 4;
	VA_START(msg);
	(void) vfprintf(stderr, m, ap);
	VA_END;
	(void) fprintf(stderr, "\n");
}

void
dumpfd(fd, printclosed, logit)
	int fd;
	bool printclosed;
	bool logit;
{
	return;
@


1.4
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2000 Sendmail, Inc. and its suppliers.
d16 1
a16 1
"@@(#) Copyright (c) 1999-2000 Sendmail, Inc. and its suppliers.\n\
d24 1
a24 1
static char id[] = "@@(#)$Sendmail: vacation.c,v 8.68.4.16 2001/02/14 05:02:21 gshapiro Exp $";
d27 1
d117 1
d124 3
d137 2
a138 2
	char *dbfilename = VDB;
	char *msgfilename = VMSG;
d181 1
a181 1
#ifdef LOG_MAIL
d183 1
a183 1
#else /* LOG_MAIL */
d185 1
a185 1
#endif /* LOG_MAIL */
d194 1
a194 13
#if _FFR_DEBUG && _FFR_LISTDB
# define OPTIONS		"a:df:Iilm:r:s:t:xz"
#else /* _FFR_DEBUG && _FFR_LISTDB */
# if _FFR_DEBUG
#  define OPTIONS		"a:df:Iim:r:s:t:xz"
# else /* _FFR_DEBUG */
#  if _FFR_LISTDB
#   define OPTIONS		"a:f:Iilm:r:s:t:xz"
#  else /* _FFR_LISTDB */
#   define OPTIONS		"a:f:Iim:r:s:t:xz"
#  endif /* _FFR_LISTDB */
# endif /* _FFR_DEBUG */
#endif /* _FFR_DEBUG && _FFR_LISTDB */
d214 1
a214 1
		case 'd':			/* debug mode */
a218 1

d256 6
d302 11
d315 15
a329 2
	name = *argv;
#else /* _FFR_BLACKBOX */
d335 1
a335 2
	name = pw->pw_name;
	if (chdir(pw->pw_dir) != 0)
d337 11
a347 3
		msglog(LOG_NOTICE,
		       "vacation: no such directory %s.\n", pw->pw_dir);
		EXITM(EX_NOINPUT);
d349 5
a353 5
#endif /* _FFR_BLACKBOX */
	user_info.smdbu_id = pw->pw_uid;
	user_info.smdbu_group_id = pw->pw_gid;
	(void) strlcpy(user_info.smdbu_name, pw->pw_name,
		       SMDB_MAX_USER_NAME_LEN);
d358 2
d361 2
a362 2

	sff |= SFF_NOPATHCHECK|SFF_OPENASROOT;
d441 1
d597 1
a772 1

d789 1
d851 1
d882 1
d913 1
d945 1
d955 1
d973 10
d995 1
a995 4
		if (emptysender)
			myname = "<>";
		(void) execl(_PATH_SENDMAIL, "sendmail", "-oi",
			     "-f", myname, "--", From, NULL);
d1022 2
a1023 1
	msglog(LOG_NOTICE, "uid %u: usage: vacation [-i] [-a alias]%s [-f db]%s [-m msg] [-r interval] [-s sender] [-t time] [-x] [-z] login\n",
d1031 1
a1031 1
	       " [-l]"
d1033 5
d1039 1
a1039 1
#endif /* _FFR_LISTDB */
@


1.4.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
"@@(#) Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.\n\
d24 1
a24 1
static char id[] = "@@(#)$Sendmail: vacation.c,v 8.68.4.21 2001/05/07 22:06:41 gshapiro Exp $";
a26 1

a115 1

a121 3
#if _FFR_BLACKBOX
	bool runasuser = FALSE;
#endif /* _FFR_BLACKBOX */
d132 2
a133 2
	char *dbfilename = NULL;
	char *msgfilename = NULL;
d176 1
a176 1
# ifdef LOG_MAIL
d178 1
a178 1
# else /* LOG_MAIL */
d180 1
a180 1
# endif /* LOG_MAIL */
d189 13
a201 1
#define OPTIONS		"a:df:Iilm:r:s:t:Uxz"
d221 1
a221 1
		  case 'd':			/* debug mode */
d226 1
a263 6
#if _FFR_BLACKBOX
		  case 'U':		/* run as single user mode */
			runasuser = TRUE;
			break;
#endif /* _FFR_BLACKBOX */

a303 11
		name = pw->pw_name;
		user_info.smdbu_id = pw->pw_uid;
		user_info.smdbu_group_id = pw->pw_gid;
		(void) strlcpy(user_info.smdbu_name, pw->pw_name,
			       SMDB_MAX_USER_NAME_LEN);
		if (chdir(pw->pw_dir) != 0)
		{
			msglog(LOG_NOTICE, "vacation: no such directory %s.\n",
			       pw->pw_dir);
			EXITM(EX_NOINPUT);
		}
d306 2
a307 15
	else if (runasuser)
	{
		name = *argv;
		if (dbfilename == NULL || msgfilename == NULL)
		{
			msglog(LOG_NOTICE,
			       "vacation: -U requires setting both -f and -m\n");
			EXITM(EX_NOINPUT);
		}
		user_info.smdbu_id = pw->pw_uid;
		user_info.smdbu_group_id = pw->pw_gid;
		(void) strlcpy(user_info.smdbu_name, pw->pw_name,
			       SMDB_MAX_USER_NAME_LEN);
	}
#endif /* _FFR_BLACKBOX */
d313 2
a314 1
	else
d316 3
a318 11
		name = pw->pw_name;
		if (chdir(pw->pw_dir) != 0)
		{
			msglog(LOG_NOTICE, "vacation: no such directory %s.\n",
			       pw->pw_dir);
			EXITM(EX_NOINPUT);
		}
		user_info.smdbu_id = pw->pw_uid;
		user_info.smdbu_group_id = pw->pw_gid;
		(void) strlcpy(user_info.smdbu_name, pw->pw_name,
			       SMDB_MAX_USER_NAME_LEN);
d320 5
a324 5

	if (dbfilename == NULL)
		dbfilename = VDB;
	if (msgfilename == NULL)
		msgfilename = VMSG;
a328 2
	{
		/* Allow a set-group-id vacation binary */
d330 2
a331 2
		sff |= SFF_NOPATHCHECK|SFF_OPENASROOT;
	}
a409 1

a564 1

d740 1
a756 1

a817 1

a847 1

a877 1

a908 1

a917 1
	char *pv[8];
a934 10
	pv[0] = "sendmail";
	pv[1] = "-oi";
	pv[2] = "-f";
	if (emptysender)
		pv[3] = "<>";
	else
		pv[3] = myname;
	pv[4] = "--";
	pv[5] = From;
	pv[6] = NULL;
d947 4
a950 1
		(void) execv(_PATH_SENDMAIL, pv);
d977 1
a977 2
	msglog(LOG_NOTICE,
	       "uid %u: usage: vacation [-a alias]%s [-f db] [-i]%s [-m msg] [-r interval] [-s sender] [-t time]%s [-x] [-z] login\n",
d985 1
a985 1
	       " [-l]",
d987 1
a987 1
	       "",
a988 5
#if _FFR_BLACKBOX
	       " [-U]"
#else /* _FFR_BLACKBOX */
	       ""
#endif /* _FFR_BLACKBOX */
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d16 1
a16 1
"@@(#) Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.\n\
d24 1
a24 1
static char id[] = "@@(#)$Sendmail: vacation.c,v 8.68.4.15 2000/11/27 22:17:27 ca Exp $";
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d24 1
a24 1
static char id[] = "@@(#)$Sendmail: vacation.c,v 8.68 2000/03/17 07:32:51 gshapiro Exp $";
d51 5
a80 5
#ifndef TRUE
# define TRUE	1
# define FALSE	0
#endif /* ! TRUE */

d102 14
d122 4
d128 1
d141 1
a141 1
	extern void readheaders __P((void));
d146 13
d188 17
a204 1
	while ((ch = getopt(argc, argv, "a:f:Iim:r:s:t:xz")) != -1)
d212 1
a212 3
				syslog(LOG_NOTICE,
				       "vacation: can't allocate memory for alias %s.\n",
				       optarg);
d220 7
d236 6
d251 1
a251 1
					usage();
d274 1
a274 1
			usage();
d281 9
d292 5
a296 1
		if (!iflag && !exclude)
d300 1
a300 1
			syslog(LOG_ERR,
d302 1
a302 1
			exit(EX_NOUSER);
d310 2
a311 2
		syslog(LOG_ERR, "vacation: no such user %s.\n", *argv);
		exit(EX_NOUSER);
d316 1
a316 1
		syslog(LOG_NOTICE,
d318 1
a318 1
		exit(EX_NOINPUT);
d326 8
d336 1
a336 1
				    S_IRUSR|S_IWUSR, SFF_CREAT,
d340 1
a340 1
		syslog(LOG_NOTICE, "vacation: %s: %s\n", dbfilename,
d342 1
a342 1
		exit(EX_DATAERR);
d345 11
d359 1
a359 1
	if (iflag)
d361 2
a362 3
		result = Db->smdb_close(Db);
		if (!exclude)
			exit(EX_OK);
d368 2
a369 2
		result = Db->smdb_close(Db);
		exit(EX_OK);
d374 1
a374 1
		syslog(LOG_NOTICE,
d376 2
a377 1
		exit(EX_OSERR);
d383 2
a384 2
	readheaders();
	if (!recent())
d390 1
a390 1
		result = Db->smdb_close(Db);
d394 25
a418 4
		result = Db->smdb_close(Db);
	exit(EX_OK);
	/* NOTREACHED */
	return EX_OK;
d428 4
a431 1
**		nothing.
d434 2
a435 1
void
d446 1
a446 1
	while (!tome && fgets(buf, sizeof(buf), stdin) && *buf != '\n')
d465 1
a465 1
							syslog(LOG_NOTICE,
d467 1
a467 1
							exit(EX_DATAERR);
d480 1
a480 1
					syslog(LOG_NOTICE,
d482 1
a482 1
					exit(EX_DATAERR);
d488 2
a489 2
					(void)strlcpy(From, buf + 5,
						      sizeof From);
d493 1
a493 1
					exit(EX_OK);
d513 1
a513 1
				exit(EX_OK);
d544 1
a544 1
		exit(EX_OK);
d547 2
a548 2
		syslog(LOG_NOTICE, "vacation: no initial \"From \" line.\n");
		exit(EX_DATAERR);
d550 1
d605 14
d623 6
a628 8
	register size_t len;
	register char *p;
	register struct ignore *cur;
	static struct ignore
	{
		char	*name;
		size_t	len;
	} ignore[] =
a629 1
		{ "-request",		8	},
d634 6
d641 7
d652 11
a662 8
	 * This is mildly amusing, and I'm not positive it's right; trying
	 * to find the "real" name of the sender, assuming that addresses
	 * will be some variant of:
	 *
	 * From site!site!SENDER%site.domain%site.domain@@site.domain
	 */
	if ((p = strchr(from, '%')) == NULL &&
	    (p = strchr(from, '@@')) == NULL)
d664 23
a686 2
		if ((p = strrchr(from, '!')) != NULL)
			++p;
d688 22
a709 3
			p = from;
		for (; *p; ++p)
			continue;
d711 14
a724 1
	len = p - from;
d727 8
d736 2
a737 1
		    strncasecmp(cur->name, p - cur->len, cur->len) == 0)
d740 1
d770 2
a771 2
	key.data.data = VIT;
	key.data.size = sizeof(VIT);
d777 1
a777 1
		memmove(&next, data.data.data, sizeof(next));
d782 2
a783 2
	key.data.data = From;
	key.data.size = strlen(From);
d790 1
a790 1
			memmove(&then, data.data.data, sizeof(then));
d798 2
a799 2
			key.data.data = domain;
			key.data.size = strlen(domain);
d827 5
a831 5
	key.data.data = VIT;
	key.data.size = sizeof(VIT);
	data.data.data = (char*) &interval;
	data.data.size = sizeof(interval);
	(void)(Db->smdb_put)(Db, &key, &data, 0);
d858 5
a862 5
	key.data.data = from;
	key.data.size = strlen(from);
	data.data.data = (char*) &when;
	data.data.size = sizeof(when);
	(void)(Db->smdb_put)(Db, &key, &data, 0);
d924 1
a924 1
			syslog(LOG_NOTICE, "vacation: no %s file.\n", msgfn);
d926 1
a926 1
			syslog(LOG_NOTICE, "vacation: no ~%s/%s file.\n",
d932 1
a932 1
		syslog(LOG_ERR, "vacation: pipe: %s", errstring(errno));
d938 1
a938 1
		syslog(LOG_ERR, "vacation: fork: %s", errstring(errno));
d949 3
a951 3
		(void) execl(_PATH_SENDMAIL, "sendmail", "-f", myname, "--",
		      From, NULL);
		syslog(LOG_ERR, "vacation: can't exec %s: %s",
d969 1
a969 1
		syslog(LOG_ERR, "vacation: can't open pipe to sendmail");
d977 13
a989 2
	syslog(LOG_NOTICE, "uid %u: usage: vacation [-i] [-a alias] [-f db] [-m msg] [-r interval] [-s sender] [-t time] [-x] [-z] login\n",
	    getuid());
d992 110
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
"@@(#) Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.\n\
d24 1
a24 1
static char id[] = "@@(#)$Sendmail: vacation.c,v 8.68.4.21 2001/05/07 22:06:41 gshapiro Exp $";
a26 1

a50 5
#ifndef TRUE
# define TRUE	1
# define FALSE	0
#endif /* ! TRUE */

d76 5
a101 15
#if _FFR_DEBUG
void (*msglog)(int, const char *, ...) = &syslog;
static void debuglog __P((int, const char *, ...));
#else /* _FFR_DEBUG */
# define msglog		syslog
#endif /* _FFR_DEBUG */

static void eatmsg __P((void));

/* exit after reading input */
#define EXITIT(excode)	{ \
				eatmsg(); \
				return excode; \
			}

a107 7
#if _FFR_BLACKBOX
	bool runasuser = FALSE;
#endif /* _FFR_BLACKBOX */
#if _FFR_LISTDB
	bool lflag = FALSE;
#endif /* _FFR_LISTDB */
	int mfail = 0, ufail = 0;
a109 1
	long sff;
d113 2
a114 2
	char *dbfilename = NULL;
	char *msgfilename = NULL;
d122 1
a122 1
	extern int readheaders __P((void));
a126 13
#if _FFR_LISTDB
#define EXITM(excode)	{ \
				if (!iflag && !lflag) \
					eatmsg(); \
				exit(excode); \
			}
#else /* _FFR_LISTDB */
#define EXITM(excode)	{ \
				if (!iflag) \
					eatmsg(); \
				exit(excode); \
			}
#endif /* _FFR_LISTDB */
d144 1
a144 1
# ifdef LOG_MAIL
d146 1
a146 1
# else /* LOG_MAIL */
d148 1
a148 1
# endif /* LOG_MAIL */
d156 1
a156 5

#define OPTIONS		"a:df:Iilm:r:s:t:Uxz"

	while (mfail == 0 && ufail == 0 &&
	       (ch = getopt(argc, argv, OPTIONS)) != -1)
d164 3
a166 1
				mfail++;
a173 6
#if _FFR_DEBUG
		  case 'd':			/* debug mode */
			msglog = &debuglog;
			break;
#endif /* _FFR_DEBUG */

a182 6
#if _FFR_LISTDB
		  case 'l':
			lflag = TRUE;		/* list the database */
			break;
#endif /* _FFR_LISTDB */

d192 1
a192 1
					ufail++;
a204 6
#if _FFR_BLACKBOX
		  case 'U':		/* run as single user mode */
			runasuser = TRUE;
			break;
#endif /* _FFR_BLACKBOX */

d215 1
a215 1
			ufail++;
a221 9
	if (mfail != 0)
	{
		msglog(LOG_NOTICE,
		       "vacation: can't allocate memory for alias.\n");
		EXITM(EX_TEMPFAIL);
	}
	if (ufail != 0)
		usage();

d224 1
a224 5
		if (!iflag &&
#if _FFR_LISTDB
		    !lflag &&
#endif /* _FFR_LISTDB */
		    !exclude)
d228 1
a228 1
			msglog(LOG_ERR,
d230 1
a230 12
			EXITM(EX_NOUSER);
		}
		name = pw->pw_name;
		user_info.smdbu_id = pw->pw_uid;
		user_info.smdbu_group_id = pw->pw_gid;
		(void) strlcpy(user_info.smdbu_name, pw->pw_name,
			       SMDB_MAX_USER_NAME_LEN);
		if (chdir(pw->pw_dir) != 0)
		{
			msglog(LOG_NOTICE, "vacation: no such directory %s.\n",
			       pw->pw_dir);
			EXITM(EX_NOINPUT);
d234 2
a235 15
	else if (runasuser)
	{
		name = *argv;
		if (dbfilename == NULL || msgfilename == NULL)
		{
			msglog(LOG_NOTICE,
			       "vacation: -U requires setting both -f and -m\n");
			EXITM(EX_NOINPUT);
		}
		user_info.smdbu_id = pw->pw_uid;
		user_info.smdbu_group_id = pw->pw_gid;
		(void) strlcpy(user_info.smdbu_name, pw->pw_name,
			       SMDB_MAX_USER_NAME_LEN);
	}
#endif /* _FFR_BLACKBOX */
d238 2
a239 2
		msglog(LOG_ERR, "vacation: no such user %s.\n", *argv);
		EXITM(EX_NOUSER);
d241 2
a242 1
	else
d244 3
a246 25
		name = pw->pw_name;
		if (chdir(pw->pw_dir) != 0)
		{
			msglog(LOG_NOTICE, "vacation: no such directory %s.\n",
			       pw->pw_dir);
			EXITM(EX_NOINPUT);
		}
		user_info.smdbu_id = pw->pw_uid;
		user_info.smdbu_group_id = pw->pw_gid;
		(void) strlcpy(user_info.smdbu_name, pw->pw_name,
			       SMDB_MAX_USER_NAME_LEN);
	}

	if (dbfilename == NULL)
		dbfilename = VDB;
	if (msgfilename == NULL)
		msgfilename = VMSG;

	sff = SFF_CREAT;
#if _FFR_BLACKBOX
	if (getegid() != getgid())
	{
		/* Allow a set-group-id vacation binary */
		RunAsGid = user_info.smdbu_group_id = getegid();
		sff |= SFF_NOPATHCHECK|SFF_OPENASROOT;
d249 4
d256 1
a256 1
				    S_IRUSR|S_IWUSR, sff,
d260 1
a260 1
		msglog(LOG_NOTICE, "vacation: %s: %s\n", dbfilename,
d262 1
a262 11
		EXITM(EX_DATAERR);
	}

#if _FFR_LISTDB
	if (lflag)
	{
		static void listdb __P((void));

		listdb();
		(void) Db->smdb_close(Db);
		exit(EX_OK);
a263 1
#endif /* _FFR_LISTDB */
d268 1
a268 1
	if (iflag && !exclude)
d270 3
a272 2
		(void) Db->smdb_close(Db);
		exit(EX_OK);
d278 2
a279 2
		(void) Db->smdb_close(Db);
		EXITM(EX_OK);
d284 1
a284 1
		msglog(LOG_NOTICE,
d286 1
a286 2
		(void) Db->smdb_close(Db);
		EXITM(EX_OSERR);
d292 2
a293 2
	result = readheaders();
	if (result == EX_OK && !recent())
d299 1
a299 1
		(void) Db->smdb_close(Db);
d303 4
a306 4
		(void) Db->smdb_close(Db);
	if (result == EX_NOUSER)
		result = EX_OK;
	exit(result);
d310 1
a310 1
** EATMSG -- read stdin till EOF
d319 1
a319 27

static void
eatmsg()
{
	/*
	**  read the rest of the e-mail and ignore it to avoid problems
	**  with EPIPE in sendmail
	*/
	while (getc(stdin) != EOF)
		continue;
}

/*
** READHEADERS -- read mail headers
**
**	Parameters:
**		none.
**
**	Returns:
**		a exit code: NOUSER if no reply, OK if reply, * if error
**
**	Side Effects:
**		may exit().
**
*/

int
d330 1
a330 1
	while (fgets(buf, sizeof(buf), stdin) && *buf != '\n')
d349 1
a349 1
							msglog(LOG_NOTICE,
d351 1
a351 1
							EXITIT(EX_DATAERR);
d364 1
a364 1
					msglog(LOG_NOTICE,
d366 1
a366 1
					EXITIT(EX_DATAERR);
d372 2
a373 2
					(void) strlcpy(From, buf + 5,
						       sizeof From);
d377 1
a377 1
					EXITIT(EX_NOUSER);
d397 1
a397 1
				EXITIT(EX_NOUSER);
d428 1
a428 1
		EXITIT(EX_NOUSER);
d431 2
a432 2
		msglog(LOG_NOTICE, "vacation: no initial \"From \" line.\n");
		EXITIT(EX_DATAERR);
a433 1
	EXITIT(EX_OK);
a447 1

a487 14

struct ignore
{
	char	*name;
	size_t	len;
};

typedef struct ignore IGNORE_T;

#define MAX_USER_LEN 256	/* maximum length of local part (sender) */

/* delimiters for the local part of an address */
#define isdelim(c)	((c) == '%' || (c) == '@@' || (c) == '+')

d492 8
a499 6
	bool quot;
	char *e;
	size_t len;
	IGNORE_T *cur;
	char sender[MAX_USER_LEN];
	static IGNORE_T ignore[] =
d501 1
a505 6
		{ NULL,			0	}
	};

	static IGNORE_T ignorepost[] =
	{
		{ "-request",		8	},
a506 7
		{ "-owner",		6	},
		{ NULL,			0	}
	};

	static IGNORE_T ignorepre[] =
	{
		{ "owner-",		6	},
d511 8
a518 11
	**  This is mildly amusing, and I'm not positive it's right; trying
	**  to find the "real" name of the sender, assuming that addresses
	**  will be some variant of:
	**
	**  From site!site!SENDER%site.domain%site.domain@@site.domain
	*/

	quot = FALSE;
	e = from;
	len = 0;
	while (*e != '\0' && (quot || !isdelim(*e)))
d520 5
a524 16
		if (*e == '"')
		{
			quot = !quot;
			++e;
			continue;
		}
		if (*e == '\\')
		{
			if (*(++e) == '\0')
			{
				/* '\\' at end of string? */
				break;
			}
			if (len < MAX_USER_LEN)
				sender[len++] = *e;
			++e;
a525 29
		}
		if (*e == '!' && !quot)
		{
			len = 0;
			sender[len] = '\0';
		}
		else
			if (len < MAX_USER_LEN)
				sender[len++] = *e;
		++e;
	}
	if (len < MAX_USER_LEN)
		sender[len] = '\0';
	else
		sender[MAX_USER_LEN - 1] = '\0';

	if (len <= 0)
		return FALSE;
#if 0
	if (quot)
		return FALSE;	/* syntax error... */
#endif /* 0 */

	/* test prefixes */
	for (cur = ignorepre; cur->name != NULL; ++cur)
	{
		if (len >= cur->len &&
		    strncasecmp(cur->name, sender, cur->len) == 0)
			return TRUE;
d527 1
a527 14

	/*
	**  If the name is truncated, don't test the rest.
	**	We could extract the "tail" of the sender address and
	**	compare it it ignorepost, however, it seems not worth
	**	the effort.
	**	The address surely can't match any entry in ignore[]
	**	(as long as all of them are shorter than MAX_USER_LEN).
	*/

	if (len > MAX_USER_LEN)
		return FALSE;

	/* test full local parts */
a529 8
		if (len == cur->len &&
		    strncasecmp(cur->name, sender, cur->len) == 0)
			return TRUE;
	}

	/* test postfixes */
	for (cur = ignorepost; cur->name != NULL; ++cur)
	{
d531 1
a531 2
		    strncasecmp(cur->name, e - cur->len - 1,
				cur->len) == 0)
a549 1

d563 2
a564 2
	key.data = VIT;
	key.size = sizeof(VIT);
d570 1
a570 1
		memmove(&next, data.data, sizeof(next));
d575 2
a576 2
	key.data = From;
	key.size = strlen(From);
d583 1
a583 1
			memmove(&then, data.data, sizeof(then));
d591 2
a592 2
			key.data = domain;
			key.size = strlen(domain);
a610 1

d620 5
a624 5
	key.data = VIT;
	key.size = sizeof(VIT);
	data.data = (char*) &interval;
	data.size = sizeof(interval);
	(void) (Db->smdb_put)(Db, &key, &data, 0);
a640 1

d651 5
a655 5
	key.data = from;
	key.size = strlen(from);
	data.data = (char*) &when;
	data.size = sizeof(when);
	(void) (Db->smdb_put)(Db, &key, &data, 0);
a670 1

a701 1

a710 1
	char *pv[8];
d717 1
a717 1
			msglog(LOG_NOTICE, "vacation: no %s file.\n", msgfn);
d719 1
a719 1
			msglog(LOG_NOTICE, "vacation: no ~%s/%s file.\n",
d725 1
a725 1
		msglog(LOG_ERR, "vacation: pipe: %s", errstring(errno));
a727 10
	pv[0] = "sendmail";
	pv[1] = "-oi";
	pv[2] = "-f";
	if (emptysender)
		pv[3] = "<>";
	else
		pv[3] = myname;
	pv[4] = "--";
	pv[5] = From;
	pv[6] = NULL;
d731 1
a731 1
		msglog(LOG_ERR, "vacation: fork: %s", errstring(errno));
d740 5
a744 2
		(void) execv(_PATH_SENDMAIL, pv);
		msglog(LOG_ERR, "vacation: can't exec %s: %s",
d762 1
a762 1
		msglog(LOG_ERR, "vacation: can't open pipe to sendmail");
d770 2
a771 19
	msglog(LOG_NOTICE,
	       "uid %u: usage: vacation [-a alias]%s [-f db] [-i]%s [-m msg] [-r interval] [-s sender] [-t time]%s [-x] [-z] login\n",
	       getuid(),
#if _FFR_DEBUG
	       " [-d]",
#else /* _FFR_DEBUG */
	       "",
#endif /* _FFR_DEBUG */
#if _FFR_LISTDB
	       " [-l]",
#else /* _FFR_LISTDB */
	       "",
#endif /* _FFR_LISTDB */
#if _FFR_BLACKBOX
	       " [-U]"
#else /* _FFR_BLACKBOX */
	       ""
#endif /* _FFR_BLACKBOX */
	       );
a773 110

#if _FFR_LISTDB
/*
** LISTDB -- list the contents of the vacation database
**
**	Parameters:
**		none.
**
**	Returns:
**		nothing.
*/

static void
listdb()
{
	int result;
	time_t t;
	SMDB_CURSOR *cursor = NULL;
	SMDB_DBENT db_key, db_value;

	memset(&db_key, '\0', sizeof db_key);
	memset(&db_value, '\0', sizeof db_value);

	result = Db->smdb_cursor(Db, &cursor, 0);
	if (result != SMDBE_OK)
	{
		fprintf(stderr, "vacation: set cursor: %s\n",
			errstring(result));
		return;
	}

	while ((result = cursor->smdbc_get(cursor, &db_key, &db_value,
					   SMDB_CURSOR_GET_NEXT)) == SMDBE_OK)
	{
		/* skip magic VIT entry */
		if ((int)db_key.size -1 == strlen(VIT) &&
		    strncmp((char *)db_key.data, VIT,
			    (int)db_key.size - 1) == 0)
			continue;

		/* skip bogus values */
		if (db_value.size != sizeof t)
		{
			fprintf(stderr, "vacation: %.*s invalid time stamp\n",
				(int) db_key.size, (char *) db_key.data);
			continue;
		}

		memcpy(&t, db_value.data, sizeof t);

		if (db_key.size > 40)
			db_key.size = 40;

		printf("%-40.*s %-10s",
		       (int) db_key.size, (char *) db_key.data, ctime(&t));

		memset(&db_key, '\0', sizeof db_key);
		memset(&db_value, '\0', sizeof db_value);
	}

	if (result != SMDBE_OK && result != SMDBE_LAST_ENTRY)
	{
		fprintf(stderr,	"vacation: get value at cursor: %s\n",
			errstring(result));
		if (cursor != NULL)
		{
			(void) cursor->smdbc_close(cursor);
			cursor = NULL;
		}
		return;
	}
	(void) cursor->smdbc_close(cursor);
	cursor = NULL;
}
#endif /* _FFR_LISTDB */

#if _FFR_DEBUG
/*
** DEBUGLOG -- write message to standard error
**
**	Append a message to the standard error for the convenience of
**	end-users debugging without access to the syslog messages.
**
**	Parameters:
**		i -- syslog log level
**		fmt -- string format
**
**	Returns:
**		nothing.
*/

/*VARARGS2*/
static void
#ifdef __STDC__
debuglog(int i, const char *fmt, ...)
#else /* __STDC__ */
debuglog(i, fmt, va_alist)
	int i;
	const char *fmt;
	va_dcl
#endif /* __STDC__ */

{
	VA_LOCAL_DECL

	VA_START(fmt);
	vfprintf(stderr, fmt, ap);
	VA_END;
}
#endif /* _FFR_DEBUG */
@


1.1
log
@Initial revision
@
text
@d16 1
a16 1
"@@(#) Copyright (c) 1998, 1999 Sendmail, Inc. and its suppliers.\n\
d24 1
a24 1
static char id[] = "@@(#)$Sendmail: vacation.c,v 8.63 2000/02/01 05:50:00 gshapiro Exp $";
a36 4
#if defined(sun) && !defined(BSD) && !defined(SOLARIS)
# include <pathname.h>
#endif /* sun && ! BSD && ! SOLARIS */

d115 1
d156 1
a156 1
	while ((ch = getopt(argc, argv, "a:f:Iim:r:s:xz")) != -1)
d233 3
d241 1
d248 1
d288 1
a288 1
	cur->name = pw->pw_name;
d300 1
a300 1
		sendmessage(pw->pw_name, msgfilename, emptysender);
d770 1
a770 1
	syslog(LOG_NOTICE, "uid %u: usage: vacation [-i] [-a alias] [-f db] [-m msg] [-r interval] [-s sender] [-x] [-z] login\n",
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d16 1
a16 1
"@@(#) Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.\n\
d24 1
a24 1
static char id[] = "@@(#)$Id: vacation.c,v 8.68.4.15 2000/11/27 22:17:27 ca Exp $";
d37 4
a54 5
#ifndef TRUE
# define TRUE	1
# define FALSE	0
#endif /* ! TRUE */

d80 5
a105 14
#if _FFR_DEBUG
void (*msglog)(int, const char *, ...) = &syslog;
static void debuglog __P((int, const char *, ...));
#else /* _FFR_DEBUG */
# define msglog		syslog
#endif /* _FFR_DEBUG */

static void eatmsg __P((void));

/* exit after reading input */
#define EXITIT(excode)	{ \
				eatmsg(); \
				return excode; \
			}
a111 4
#if _FFR_LISTDB
	bool lflag = FALSE;
#endif /* _FFR_LISTDB */
	int mfail = 0, ufail = 0;
a113 1
	long sff;
a118 1
	char *name;
d125 1
a125 1
	extern int readheaders __P((void));
a129 13
#if _FFR_LISTDB
#define EXITM(excode)	{ \
				if (!iflag && !lflag) \
					eatmsg(); \
				exit(excode); \
			}
#else /* _FFR_LISTDB */
#define EXITM(excode)	{ \
				if (!iflag) \
					eatmsg(); \
				exit(excode); \
			}
#endif /* _FFR_LISTDB */
d159 1
a159 17

#if _FFR_DEBUG && _FFR_LISTDB
# define OPTIONS		"a:df:Iilm:r:s:t:xz"
#else /* _FFR_DEBUG && _FFR_LISTDB */
# if _FFR_DEBUG
#  define OPTIONS		"a:df:Iim:r:s:t:xz"
# else /* _FFR_DEBUG */
#  if _FFR_LISTDB
#   define OPTIONS		"a:f:Iilm:r:s:t:xz"
#  else /* _FFR_LISTDB */
#   define OPTIONS		"a:f:Iim:r:s:t:xz"
#  endif /* _FFR_LISTDB */
# endif /* _FFR_DEBUG */
#endif /* _FFR_DEBUG && _FFR_LISTDB */

	while (mfail == 0 && ufail == 0 &&
	       (ch = getopt(argc, argv, OPTIONS)) != -1)
d167 3
a169 1
				mfail++;
a176 7
#if _FFR_DEBUG
		case 'd':			/* debug mode */
			msglog = &debuglog;
			break;
#endif /* _FFR_DEBUG */


a185 6
#if _FFR_LISTDB
		  case 'l':
			lflag = TRUE;		/* list the database */
			break;
#endif /* _FFR_LISTDB */

d195 1
a195 1
					ufail++;
d218 1
a218 1
			ufail++;
a224 9
	if (mfail != 0)
	{
		msglog(LOG_NOTICE,
		       "vacation: can't allocate memory for alias.\n");
		EXITM(EX_TEMPFAIL);
	}
	if (ufail != 0)
		usage();

d227 1
a227 5
		if (!iflag &&
#if _FFR_LISTDB
		    !lflag &&
#endif /* _FFR_LISTDB */
		    !exclude)
d231 1
a231 1
			msglog(LOG_ERR,
d233 1
a233 1
			EXITM(EX_NOUSER);
a235 3
#if _FFR_BLACKBOX
	name = *argv;
#else /* _FFR_BLACKBOX */
d238 2
a239 2
		msglog(LOG_ERR, "vacation: no such user %s.\n", *argv);
		EXITM(EX_NOUSER);
a240 1
	name = pw->pw_name;
d243 1
a243 1
		msglog(LOG_NOTICE,
d245 1
a245 1
		EXITM(EX_NOINPUT);
a246 1
#endif /* _FFR_BLACKBOX */
a251 8
	sff = SFF_CREAT;
#if _FFR_BLACKBOX
	if (getegid() != getgid())
		RunAsGid = user_info.smdbu_group_id = getegid();

	sff |= SFF_NOPATHCHECK|SFF_OPENASROOT;
#endif /* _FFR_BLACKBOX */

d254 1
a254 1
				    S_IRUSR|S_IWUSR, sff,
d258 1
a258 1
		msglog(LOG_NOTICE, "vacation: %s: %s\n", dbfilename,
d260 1
a260 1
		EXITM(EX_DATAERR);
a262 11
#if _FFR_LISTDB
	if (lflag)
	{
		static void listdb __P((void));

		listdb();
		(void) Db->smdb_close(Db);
		exit(EX_OK);
	}
#endif /* _FFR_LISTDB */

d266 1
a266 1
	if (iflag && !exclude)
d268 3
a270 2
		(void) Db->smdb_close(Db);
		exit(EX_OK);
d276 2
a277 2
		(void) Db->smdb_close(Db);
		EXITM(EX_OK);
d282 1
a282 1
		msglog(LOG_NOTICE,
d284 1
a284 2
		(void) Db->smdb_close(Db);
		EXITM(EX_OSERR);
d286 1
a286 1
	cur->name = name;
d290 2
a291 2
	result = readheaders();
	if (result == EX_OK && !recent())
d297 2
a298 2
		(void) Db->smdb_close(Db);
		sendmessage(name, msgfilename, emptysender);
d301 4
a304 4
		(void) Db->smdb_close(Db);
	if (result == EX_NOUSER)
		result = EX_OK;
	exit(result);
d308 1
a308 1
** EATMSG -- read stdin till EOF
d317 1
a317 26
static void
eatmsg()
{
	/*
	**  read the rest of the e-mail and ignore it to avoid problems
	**  with EPIPE in sendmail
	*/
	while (getc(stdin) != EOF)
		continue;
}

/*
** READHEADERS -- read mail headers
**
**	Parameters:
**		none.
**
**	Returns:
**		a exit code: NOUSER if no reply, OK if reply, * if error
**
**	Side Effects:
**		may exit().
**
*/

int
d328 1
a328 1
	while (fgets(buf, sizeof(buf), stdin) && *buf != '\n')
d347 1
a347 1
							msglog(LOG_NOTICE,
d349 1
a349 1
							EXITIT(EX_DATAERR);
d362 1
a362 1
					msglog(LOG_NOTICE,
d364 1
a364 1
					EXITIT(EX_DATAERR);
d370 2
a371 2
					(void) strlcpy(From, buf + 5,
						       sizeof From);
d375 1
a375 1
					EXITIT(EX_NOUSER);
d395 1
a395 1
				EXITIT(EX_NOUSER);
d426 1
a426 1
		EXITIT(EX_NOUSER);
d429 2
a430 2
		msglog(LOG_NOTICE, "vacation: no initial \"From \" line.\n");
		EXITIT(EX_DATAERR);
a431 1
	EXITIT(EX_OK);
a485 14

struct ignore
{
	char	*name;
	size_t	len;
};

typedef struct ignore IGNORE_T;

#define MAX_USER_LEN 256	/* maximum length of local part (sender) */

/* delimiters for the local part of an address */
#define isdelim(c)	((c) == '%' || (c) == '@@' || (c) == '+')

d490 8
a497 6
	bool quot;
	char *e;
	size_t len;
	IGNORE_T *cur;
	char sender[MAX_USER_LEN];
	static IGNORE_T ignore[] =
d499 1
a503 6
		{ NULL,			0	}
	};

	static IGNORE_T ignorepost[] =
	{
		{ "-request",		8	},
a504 7
		{ "-owner",		6	},
		{ NULL,			0	}
	};

	static IGNORE_T ignorepre[] =
	{
		{ "owner-",		6	},
d509 8
a516 11
	**  This is mildly amusing, and I'm not positive it's right; trying
	**  to find the "real" name of the sender, assuming that addresses
	**  will be some variant of:
	**
	**  From site!site!SENDER%site.domain%site.domain@@site.domain
	*/

	quot = FALSE;
	e = from;
	len = 0;
	while (*e != '\0' && (quot || !isdelim(*e)))
d518 5
a522 4
		if (*e == '"')
		{
			quot = !quot;
			++e;
a523 22
		}
		if (*e == '\\')
		{
			if (*(++e) == '\0')
			{
				/* '\\' at end of string? */
				break;
			}
			if (len < MAX_USER_LEN)
				sender[len++] = *e;
			++e;
			continue;
		}
		if (*e == '!' && !quot)
		{
			len = 0;
			sender[len] = '\0';
		}
		else
			if (len < MAX_USER_LEN)
				sender[len++] = *e;
		++e;
d525 1
a525 33
	if (len < MAX_USER_LEN)
		sender[len] = '\0';
	else
		sender[MAX_USER_LEN - 1] = '\0';

	if (len <= 0)
		return FALSE;
#if 0
	if (quot)
		return FALSE;	/* syntax error... */
#endif /* 0 */

	/* test prefixes */
	for (cur = ignorepre; cur->name != NULL; ++cur)
	{
		if (len >= cur->len &&
		    strncasecmp(cur->name, sender, cur->len) == 0)
			return TRUE;
	}

	/*
	**  If the name is truncated, don't test the rest.
	**	We could extract the "tail" of the sender address and
	**	compare it it ignorepost, however, it seems not worth
	**	the effort.
	**	The address surely can't match any entry in ignore[]
	**	(as long as all of them are shorter than MAX_USER_LEN).
	*/

	if (len > MAX_USER_LEN)
		return FALSE;

	/* test full local parts */
a527 8
		if (len == cur->len &&
		    strncasecmp(cur->name, sender, cur->len) == 0)
			return TRUE;
	}

	/* test postfixes */
	for (cur = ignorepost; cur->name != NULL; ++cur)
	{
d529 1
a529 2
		    strncasecmp(cur->name, e - cur->len - 1,
				cur->len) == 0)
a531 1

d561 2
a562 2
	key.data = VIT;
	key.size = sizeof(VIT);
d568 1
a568 1
		memmove(&next, data.data, sizeof(next));
d573 2
a574 2
	key.data = From;
	key.size = strlen(From);
d581 1
a581 1
			memmove(&then, data.data, sizeof(then));
d589 2
a590 2
			key.data = domain;
			key.size = strlen(domain);
d618 5
a622 5
	key.data = VIT;
	key.size = sizeof(VIT);
	data.data = (char*) &interval;
	data.size = sizeof(interval);
	(void) (Db->smdb_put)(Db, &key, &data, 0);
d649 5
a653 5
	key.data = from;
	key.size = strlen(from);
	data.data = (char*) &when;
	data.size = sizeof(when);
	(void) (Db->smdb_put)(Db, &key, &data, 0);
d715 1
a715 1
			msglog(LOG_NOTICE, "vacation: no %s file.\n", msgfn);
d717 1
a717 1
			msglog(LOG_NOTICE, "vacation: no ~%s/%s file.\n",
d723 1
a723 1
		msglog(LOG_ERR, "vacation: pipe: %s", errstring(errno));
d729 1
a729 1
		msglog(LOG_ERR, "vacation: fork: %s", errstring(errno));
d740 3
a742 3
		(void) execl(_PATH_SENDMAIL, "sendmail", "-oi",
			     "-f", myname, "--", From, NULL);
		msglog(LOG_ERR, "vacation: can't exec %s: %s",
d760 1
a760 1
		msglog(LOG_ERR, "vacation: can't open pipe to sendmail");
d768 2
a769 13
	msglog(LOG_NOTICE, "uid %u: usage: vacation [-i] [-a alias]%s [-f db]%s [-m msg] [-r interval] [-s sender] [-t time] [-x] [-z] login\n",
	       getuid(),
#if _FFR_DEBUG
	       " [-d]",
#else /* _FFR_DEBUG */
	       "",
#endif /* _FFR_DEBUG */
#if _FFR_LISTDB
	       " [-l]"
#else /* _FFR_LISTDB */
	       ""
#endif /* _FFR_LISTDB */
	       );
a771 110

#if _FFR_LISTDB
/*
** LISTDB -- list the contents of the vacation database
**
**	Parameters:
**		none.
**
**	Returns:
**		nothing.
*/

static void
listdb()
{
	int result;
	time_t t;
	SMDB_CURSOR *cursor = NULL;
	SMDB_DBENT db_key, db_value;

	memset(&db_key, '\0', sizeof db_key);
	memset(&db_value, '\0', sizeof db_value);

	result = Db->smdb_cursor(Db, &cursor, 0);
	if (result != SMDBE_OK)
	{
		fprintf(stderr, "vacation: set cursor: %s\n",
			errstring(result));
		return;
	}

	while ((result = cursor->smdbc_get(cursor, &db_key, &db_value,
					   SMDB_CURSOR_GET_NEXT)) == SMDBE_OK)
	{
		/* skip magic VIT entry */
		if ((int)db_key.size -1 == strlen(VIT) &&
		    strncmp((char *)db_key.data, VIT,
			    (int)db_key.size - 1) == 0)
			continue;

		/* skip bogus values */
		if (db_value.size != sizeof t)
		{
			fprintf(stderr, "vacation: %.*s invalid time stamp\n",
				(int) db_key.size, (char *) db_key.data);
			continue;
		}

		memcpy(&t, db_value.data, sizeof t);

		if (db_key.size > 40)
			db_key.size = 40;

		printf("%-40.*s %-10s",
		       (int) db_key.size, (char *) db_key.data, ctime(&t));

		memset(&db_key, '\0', sizeof db_key);
		memset(&db_value, '\0', sizeof db_value);
	}

	if (result != SMDBE_OK && result != SMDBE_LAST_ENTRY)
	{
		fprintf(stderr,	"vacation: get value at cursor: %s\n",
			errstring(result));
		if (cursor != NULL)
		{
			(void) cursor->smdbc_close(cursor);
			cursor = NULL;
		}
		return;
	}
	(void) cursor->smdbc_close(cursor);
	cursor = NULL;
}
#endif /* _FFR_LISTDB */

#if _FFR_DEBUG
/*
** DEBUGLOG -- write message to standard error
**
**	Append a message to the standard error for the convenience of
**	end-users debugging without access to the syslog messages.
**
**	Parameters:
**		i -- syslog log level
**		fmt -- string format
**
**	Returns:
**		nothing.
*/

/*VARARGS2*/
static void
#ifdef __STDC__
debuglog(int i, const char *fmt, ...)
#else /* __STDC__ */
debuglog(i, fmt, va_alist)
	int i;
	const char *fmt;
	va_dcl
#endif /* __STDC__ */

{
	VA_LOCAL_DECL

	VA_START(fmt);
	vfprintf(stderr, fmt, ap);
	VA_END;
}
#endif /* _FFR_DEBUG */
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d14 3
a16 4
#include <sm/gen.h>

SM_IDSTR(copyright,
"@@(#) Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.\n\
d20 2
a21 3
     Copyright (c) 1983 Eric P. Allman.  All rights reserved.\n")

SM_IDSTR(id, "@@(#)$Sendmail: vacation.c,v 8.127 2001/09/08 01:21:15 gshapiro Exp $")
d23 3
d35 1
a35 1
#include <sm/sysexits.h>
a36 2
#include <sm/cf.h>
#include <sm/mbdb.h>
a37 1
#include <sendmail/pathnames.h>
d40 8
d51 5
d63 1
a63 1
bool	DontInitGroups = false;
d81 9
d102 7
a108 17
#if defined(__hpux) || defined(__osf__)
# ifndef SM_CONF_SYSLOG_INT
#  define SM_CONF_SYSLOG_INT	1
# endif /* SM_CONF_SYSLOG_INT */
#endif /* defined(__hpux) || defined(__osf__) */

#if SM_CONF_SYSLOG_INT
# define SYSLOG_RET_T	int
# define SYSLOG_RET	return 0
#else /* SM_CONF_SYSLOG_INT */
# define SYSLOG_RET_T	void
# define SYSLOG_RET
#endif /* SM_CONF_SYSLOG_INT */

typedef SYSLOG_RET_T SYSLOG_T __P((int, const char *, ...));
SYSLOG_T *msglog = syslog;
static SYSLOG_RET_T debuglog __P((int, const char *, ...));
a109 1
static void listdb __P((void));
d112 4
a115 13
#define EXITIT(excode) \
{ \
	eatmsg(); \
	return excode; \
}

#define EXITM(excode) \
{ \
	if (!iflag && !lflag) \
		eatmsg(); \
	exit(excode); \
}

d122 3
a124 2
	bool runasuser = false;
	bool lflag = false;
d132 2
a133 3
	char *dbfilename = NULL;
	char *msgfilename = NULL;
	char *cfpath = NULL;
d145 14
a158 1
	extern void xclude __P((SM_FILE_T *));
d169 1
a169 1
		sm_snprintf(rnamebuf, sizeof rnamebuf, "%s", pw->pw_name);
d172 2
a173 2
		sm_snprintf(rnamebuf, sizeof rnamebuf,
			    "Unknown UID %d", (int) RealUid);
d176 1
a176 1
# ifdef LOG_MAIL
d178 1
a178 1
# else /* LOG_MAIL */
d180 1
a180 1
# endif /* LOG_MAIL */
d183 3
a185 3
	iflag = false;
	emptysender = false;
	exclude = false;
d189 13
a201 1
#define OPTIONS		"a:C:df:Iilm:r:s:t:Uxz"
d209 1
a209 1
			cur = (ALIAS *) malloc((unsigned int) sizeof(ALIAS));
d220 3
a222 2
		  case 'C':
			cfpath = optarg;
d224 1
a225 3
		  case 'd':			/* debug mode */
			msglog = debuglog;
			break;
d233 1
a233 1
			iflag = true;
d236 1
d238 1
a238 1
			lflag = true;		/* list the database */
d240 1
d258 1
a258 1
			(void) sm_strlcpy(From, optarg, sizeof From);
a263 4
		  case 'U':		/* run as single user mode */
			runasuser = true;
			break;

d265 1
a265 1
			exclude = true;
d269 1
a269 1
			emptysender = true;
d292 5
a296 1
		if (!iflag && !lflag && !exclude)
a303 12
		name = pw->pw_name;
		user_info.smdbu_id = pw->pw_uid;
		user_info.smdbu_group_id = pw->pw_gid;
		(void) sm_strlcpy(user_info.smdbu_name, pw->pw_name,
				  SMDB_MAX_USER_NAME_LEN);
		if (chdir(pw->pw_dir) != 0)
		{
			msglog(LOG_NOTICE,
			       "vacation: no such directory %s.\n",
			       pw->pw_dir);
			EXITM(EX_NOINPUT);
		}
d305 4
a308 1
	else if (runasuser)
d310 2
a311 11
		name = *argv;
		if (dbfilename == NULL || msgfilename == NULL)
		{
			msglog(LOG_NOTICE,
			       "vacation: -U requires setting both -f and -m\n");
			EXITM(EX_NOINPUT);
		}
		user_info.smdbu_id = pw->pw_uid;
		user_info.smdbu_group_id = pw->pw_gid;
		(void) sm_strlcpy(user_info.smdbu_name, pw->pw_name,
			       SMDB_MAX_USER_NAME_LEN);
d313 2
a314 1
	else
d316 3
a318 41
		int err;
		SM_CF_OPT_T mbdbname;
		SM_MBDB_T user;

		cfpath = getcfname(0, 0, SM_GET_SENDMAIL_CF, NULL);
		mbdbname.opt_name = "MailboxDatabase";
		mbdbname.opt_val = "pw";
		(void) sm_cf_getopt(cfpath, 1, &mbdbname);
		err = sm_mbdb_initialize(mbdbname.opt_val);
		if (err != EX_OK)
		{
			msglog(LOG_ERR,
			       "vacation: can't open mailbox database: %s.\n",
			       sm_strexit(err));
			EXITM(err);
		}
		err = sm_mbdb_lookup(*argv, &user);
		if (err == EX_NOUSER)
		{
			msglog(LOG_ERR, "vacation: no such user %s.\n", *argv);
			EXITM(EX_NOUSER);
		}
		if (err != EX_OK)
		{
			msglog(LOG_ERR,
			       "vacation: can't read mailbox database: %s.\n",
			       sm_strexit(err));
			EXITM(err);
		}
		name = user.mbdb_name;
		if (chdir(user.mbdb_homedir) != 0)
		{
			msglog(LOG_NOTICE,
			       "vacation: no such directory %s.\n",
			       user.mbdb_homedir);
			EXITM(EX_NOINPUT);
		}
		user_info.smdbu_id = user.mbdb_uid;
		user_info.smdbu_group_id = user.mbdb_gid;
		(void) sm_strlcpy(user_info.smdbu_name, user.mbdb_name,
			       SMDB_MAX_USER_NAME_LEN);
d320 5
a324 5

	if (dbfilename == NULL)
		dbfilename = VDB;
	if (msgfilename == NULL)
		msgfilename = VMSG;
d327 1
a328 2
	{
		/* Allow a set-group-ID vacation binary */
d330 3
a332 2
		sff |= SFF_OPENASROOT;
	}
d341 1
a341 1
		       sm_errstring(result));
d345 1
d348 2
d354 1
d367 1
a367 1
		xclude(smioin);
d372 1
a372 1
	if ((cur = (ALIAS *) malloc((unsigned int) sizeof(ALIAS))) == NULL)
a409 1

d445 2
a446 3
	cont = tome = false;
	while (sm_io_fgets(smioin, SM_TIME_DEFAULT, buf, sizeof(buf)) &&
	       *buf != '\n')
d451 1
a451 1
			cont = false;
d454 1
a454 1
				bool quoted = false;
d488 2
a489 2
					(void) sm_strlcpy(From, buf + 5,
							  sizeof From);
d499 1
a499 1
			cont = false;
d520 1
a520 1
			cont = true;
d527 1
a527 1
			cont = true;
d533 1
a533 1
				cont = false;
a564 1

d589 1
a589 1
			return true;
d591 1
a591 1
	return false;
d659 1
a659 1
	quot = false;
d698 1
a698 1
		return false;
d701 1
a701 1
		return false;	/* syntax error... */
d709 1
a709 1
			return true;
d722 1
a722 1
		return false;
d729 1
a729 1
			return true;
d738 1
a738 1
			return true;
d740 2
a741 1
	return false;
d754 1
a754 1
**		true iff user has gotten a vacation message recently.
a756 1

d762 1
a762 1
	bool trydomain = false;
d793 1
a793 1
				return true;
d802 1
a802 1
	return false;
a817 1

a847 1

a877 1

d880 1
a880 1
	SM_FILE_T *f;
d886 1
a886 1
	while (sm_io_fgets(f, SM_TIME_DEFAULT, buf, sizeof buf))
a908 1

d915 1
a915 1
	SM_FILE_T *mfp, *sfp;
a917 1
	char *pv[8];
d920 1
a920 1
	mfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, msgfn, SM_IO_RDONLY, NULL);
d932 1
a932 1
		msglog(LOG_ERR, "vacation: pipe: %s", sm_errstring(errno));
a934 10
	pv[0] = "sendmail";
	pv[1] = "-oi";
	pv[2] = "-f";
	if (emptysender)
		pv[3] = "<>";
	else
		pv[3] = myname;
	pv[4] = "--";
	pv[5] = From;
	pv[6] = NULL;
d938 1
a938 1
		msglog(LOG_ERR, "vacation: fork: %s", sm_errstring(errno));
d946 5
a950 2
		(void) sm_io_close(mfp, SM_TIME_DEFAULT);
		(void) execv(_PATH_SENDMAIL, pv);
d952 1
a952 1
			_PATH_SENDMAIL, sm_errstring(errno));
d957 1
a957 2
	if ((sfp = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT, (void *)pvect[1],
			      SM_IO_WRONLY, NULL)) != NULL)
d959 6
a964 7
		(void) sm_io_fprintf(sfp, SM_TIME_DEFAULT, "To: %s\n", From);
		(void) sm_io_fprintf(sfp, SM_TIME_DEFAULT,
				     "Auto-Submitted: auto-replied\n");
		while (sm_io_fgets(mfp, SM_TIME_DEFAULT, buf, sizeof buf))
			(void) sm_io_fputs(sfp, SM_TIME_DEFAULT, buf);
		(void) sm_io_close(mfp, SM_TIME_DEFAULT);
		(void) sm_io_close(sfp, SM_TIME_DEFAULT);
d968 1
a968 1
		(void) sm_io_close(mfp, SM_TIME_DEFAULT);
d977 13
a989 3
	msglog(LOG_NOTICE,
	       "uid %u: usage: vacation [-a alias] [-C cfpath] [-d] [-f db] [-i] [-l] [-m msg] [-r interval] [-s sender] [-t time] [-U] [-x] [-z] login\n",
	       getuid());
d993 1
d1018 2
a1019 3
		sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
			      "vacation: set cursor: %s\n",
			      sm_errstring(result));
d1027 1
a1027 1
		if ((int)db_key.size - 1 == strlen(VIT) &&
d1035 2
a1036 3
			sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				      "vacation: %.*s invalid time stamp\n",
				      (int) db_key.size, (char *) db_key.data);
d1045 2
a1046 3
		sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%-40.*s %-10s",
			      (int) db_key.size, (char *) db_key.data,
			      ctime(&t));
d1054 2
a1055 3
		sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
			      "vacation: get value at cursor: %s\n",
			      sm_errstring(result));
d1066 1
d1068 1
d1084 1
a1084 1
static SYSLOG_RET_T
d1095 1
a1095 1
	SM_VA_LOCAL_DECL
d1097 61
a1157 4
	SM_VA_START(ap, fmt);
	sm_io_vfprintf(smioerr, SM_TIME_DEFAULT, fmt, ap);
	SM_VA_END(ap);
	SYSLOG_RET;
@


