head	1.11;
access;
symbols
	OPENBSD_5_6:1.10.0.6
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.36
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.34
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.32
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.30
	OPENBSD_5_0:1.9.0.28
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.26
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.24
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.20
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.22
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.18
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.16
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.14
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.12
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.10
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.8
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.8.0.10
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.8
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.10;
commitid	M7i5giHIoz3DMlTU;

1.10
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.16.00.21.30;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.03.17.25.46;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.18.00.49.27;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.15.21.09.03;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.07.19.20.35;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.42;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.52;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.29.11;	author miod;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Bye.
@
text
@/*
** Copyright (c) 1999-2002 Proofpoint, Inc. and its suppliers.
**	All rights reserved.
**
** By using this file, you agree to the terms and conditions set
** forth in the LICENSE file which can be found at the top level of
** the sendmail distribution.
*/

#include <sm/gen.h>
SM_RCSID("@@(#)$Sendmail: smdb.c,v 8.59 2013/11/22 20:51:49 ca Exp $")

#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>


#include <sendmail/sendmail.h>
#include <libsmdb/smdb.h>

static bool	smdb_lockfile __P((int, int));

/*
** SMDB_MALLOC_DATABASE -- Allocates a database structure.
**
**	Parameters:
**		None
**
**	Returns:
**		An pointer to an allocated SMDB_DATABASE structure or
**		NULL if it couldn't allocate the memory.
*/

SMDB_DATABASE *
smdb_malloc_database()
{
	SMDB_DATABASE *db;

	db = (SMDB_DATABASE *) malloc(sizeof(SMDB_DATABASE));

	if (db != NULL)
		(void) memset(db, '\0', sizeof(SMDB_DATABASE));

	return db;
}


/*
** SMDB_FREE_DATABASE -- Unallocates a database structure.
**
**	Parameters:
**		database -- a SMDB_DATABASE pointer to deallocate.
**
**	Returns:
**		None
*/

void
smdb_free_database(database)
	SMDB_DATABASE *database;
{
	if (database != NULL)
		free(database);
}
/*
**  SMDB_LOCKFILE -- lock a file using flock or (shudder) fcntl locking
**
**	Parameters:
**		fd -- the file descriptor of the file.
**		type -- type of the lock.  Bits can be:
**			LOCK_EX -- exclusive lock.
**			LOCK_NB -- non-blocking.
**
**	Returns:
**		true if the lock was acquired.
**		false otherwise.
*/

static bool
smdb_lockfile(fd, type)
	int fd;
	int type;
{
	int i;
	int save_errno;
#if !HASFLOCK
	int action;
	struct flock lfd;

	(void) memset(&lfd, '\0', sizeof lfd);
	if (bitset(LOCK_UN, type))
		lfd.l_type = F_UNLCK;
	else if (bitset(LOCK_EX, type))
		lfd.l_type = F_WRLCK;
	else
		lfd.l_type = F_RDLCK;

	if (bitset(LOCK_NB, type))
		action = F_SETLK;
	else
		action = F_SETLKW;

	while ((i = fcntl(fd, action, &lfd)) < 0 && errno == EINTR)
		continue;
	if (i >= 0)
		return true;
	save_errno = errno;

	/*
	**  On SunOS, if you are testing using -oQ/tmp/mqueue or
	**  -oA/tmp/aliases or anything like that, and /tmp is mounted
	**  as type "tmp" (that is, served from swap space), the
	**  previous fcntl will fail with "Invalid argument" errors.
	**  Since this is fairly common during testing, we will assume
	**  that this indicates that the lock is successfully grabbed.
	*/

	if (save_errno == EINVAL)
		return true;

	if (!bitset(LOCK_NB, type) ||
	    (save_errno != EACCES && save_errno != EAGAIN))
	{
# if 0
		int omode = fcntl(fd, F_GETFL, NULL);
		int euid = (int) geteuid();

		syslog(LOG_ERR, "cannot lockf(%s%s, fd=%d, type=%o, omode=%o, euid=%d)",
		       filename, ext, fd, type, omode, euid);
# endif /* 0 */
		errno = save_errno;
		return false;
	}
#else /* !HASFLOCK */

	while ((i = flock(fd, type)) < 0 && errno == EINTR)
		continue;
	if (i >= 0)
		return true;
	save_errno = errno;

	if (!bitset(LOCK_NB, type) || save_errno != EWOULDBLOCK)
	{
# if 0
		int omode = fcntl(fd, F_GETFL, NULL);
		int euid = (int) geteuid();

		syslog(LOG_ERR, "cannot flock(%s%s, fd=%d, type=%o, omode=%o, euid=%d)",
		       filename, ext, fd, type, omode, euid);
# endif /* 0 */
		errno = save_errno;
		return false;
	}
#endif /* !HASFLOCK */
	errno = save_errno;
	return false;
}
/*
** SMDB_OPEN_DATABASE -- Opens a database.
**
**	This opens a database. If type is SMDB_DEFAULT it tries to
**	use a DB1 or DB2 hash. If that isn't available, it will try
**	to use NDBM. If a specific type is given it will try to open
**	a database of that type.
**
**	Parameters:
**		database -- An pointer to a SMDB_DATABASE pointer where the
**			   opened database will be stored. This should
**			   be unallocated.
**		db_name -- The name of the database to open. Do not include
**			  the file name extension.
**		mode -- The mode to set on the database file or files.
**		mode_mask -- Mode bits that must match on an opened database.
**		sff -- Flags to safefile.
**		type -- The type of database to open. Supported types
**		       vary depending on what was compiled in.
**		user_info -- Information on the user to use for file
**			    permissions.
**		params -- Params specific to the database being opened.
**			 Only supports some DB hash options right now
**			 (see smdb_db_open() for details).
**
**	Returns:
**		SMDBE_OK -- Success.
**		Anything else is an error. Look up more info about the
**		error in the comments for the specific open() used.
*/

int
smdb_open_database(database, db_name, mode, mode_mask, sff, type, user_info,
		   params)
	SMDB_DATABASE **database;
	char *db_name;
	int mode;
	int mode_mask;
	long sff;
	SMDB_DBTYPE type;
	SMDB_USER_INFO *user_info;
	SMDB_DBPARAMS *params;
{
	bool type_was_default = false;

	if (type == SMDB_TYPE_DEFAULT)
	{
		type_was_default = true;
#ifdef NEWDB
		type = SMDB_TYPE_HASH;
#else /* NEWDB */
# ifdef NDBM
		type = SMDB_TYPE_NDBM;
# endif /* NDBM */
#endif /* NEWDB */
	}

	if (type == SMDB_TYPE_DEFAULT)
		return SMDBE_UNKNOWN_DB_TYPE;

	if ((strncmp(type, SMDB_TYPE_HASH, SMDB_TYPE_HASH_LEN) == 0) ||
	    (strncmp(type, SMDB_TYPE_BTREE, SMDB_TYPE_BTREE_LEN) == 0))
	{
#ifdef NEWDB
		int result;

		result = smdb_db_open(database, db_name, mode, mode_mask, sff,
				      type, user_info, params);
# ifdef NDBM
		if (result == ENOENT && type_was_default)
			type = SMDB_TYPE_NDBM;
		else
# endif /* NDBM */
			return result;
#else /* NEWDB */
		return SMDBE_UNSUPPORTED_DB_TYPE;
#endif /* NEWDB */
	}

	if (strncmp(type, SMDB_TYPE_NDBM, SMDB_TYPE_NDBM_LEN) == 0)
	{
#ifdef NDBM
		int result;

		result = smdb_ndbm_open(database, db_name, mode, mode_mask,
					sff, type, user_info, params);
		return result;
#else /* NDBM */
		return SMDBE_UNSUPPORTED_DB_TYPE;
#endif /* NDBM */
	}

	return SMDBE_UNKNOWN_DB_TYPE;
}
/*
** SMDB_ADD_EXTENSION -- Adds an extension to a file name.
**
**	Just adds a . followed by a string to a db_name if there
**	is room and the db_name does not already have that extension.
**
**	Parameters:
**		full_name -- The final file name.
**		max_full_name_len -- The max length for full_name.
**		db_name -- The name of the db.
**		extension -- The extension to add.
**
**	Returns:
**		SMDBE_OK -- Success.
**		Anything else is an error. Look up more info about the
**		error in the comments for the specific open() used.
*/

int
smdb_add_extension(full_name, max_full_name_len, db_name, extension)
	char *full_name;
	int max_full_name_len;
	char *db_name;
	char *extension;
{
	int extension_len;
	int db_name_len;

	if (full_name == NULL || db_name == NULL || extension == NULL)
		return SMDBE_INVALID_PARAMETER;

	extension_len = strlen(extension);
	db_name_len = strlen(db_name);

	if (extension_len + db_name_len + 2 > max_full_name_len)
		return SMDBE_DB_NAME_TOO_LONG;

	if (db_name_len < extension_len + 1 ||
	    db_name[db_name_len - extension_len - 1] != '.' ||
	    strcmp(&db_name[db_name_len - extension_len], extension) != 0)
		(void) sm_snprintf(full_name, max_full_name_len, "%s.%s",
				   db_name, extension);
	else
		(void) sm_strlcpy(full_name, db_name, max_full_name_len);

	return SMDBE_OK;
}
/*
**  SMDB_LOCK_FILE -- Locks the database file.
**
**	Locks the actual database file.
**
**	Parameters:
**		lock_fd -- The resulting descriptor for the locked file.
**		db_name -- The name of the database without extension.
**		mode -- The open mode.
**		sff -- Flags to safefile.
**		extension -- The extension for the file.
**
**	Returns:
**		SMDBE_OK -- Success, otherwise errno.
*/

int
smdb_lock_file(lock_fd, db_name, mode, sff, extension)
	int *lock_fd;
	char *db_name;
	int mode;
	long sff;
	char *extension;
{
	int result;
	char file_name[MAXPATHLEN];

	result = smdb_add_extension(file_name, sizeof file_name, db_name,
				    extension);
	if (result != SMDBE_OK)
		return result;

	*lock_fd = safeopen(file_name, mode & ~O_TRUNC, DBMMODE, sff);
	if (*lock_fd < 0)
		return errno;

	return SMDBE_OK;
}
/*
**  SMDB_UNLOCK_FILE -- Unlocks a file
**
**	Unlocks a file.
**
**	Parameters:
**		lock_fd -- The descriptor for the locked file.
**
**	Returns:
**		SMDBE_OK -- Success, otherwise errno.
*/

int
smdb_unlock_file(lock_fd)
	int lock_fd;
{
	int result;

	result = close(lock_fd);
	if (result != 0)
		return errno;

	return SMDBE_OK;
}
/*
**  SMDB_LOCK_MAP -- Locks a database.
**
**	Parameters:
**		database -- database description.
**		type -- type of the lock.  Bits can be:
**			LOCK_EX -- exclusive lock.
**			LOCK_NB -- non-blocking.
**
**	Returns:
**		SMDBE_OK -- Success, otherwise errno.
*/

int
smdb_lock_map(database, type)
	SMDB_DATABASE *database;
	int type;
{
	int fd;

	fd = database->smdb_lockfd(database);
	if (fd < 0)
		return SMDBE_NOT_FOUND;
	if (!smdb_lockfile(fd, type))
		return SMDBE_LOCK_NOT_GRANTED;
	return SMDBE_OK;
}
/*
**  SMDB_UNLOCK_MAP -- Unlocks a database
**
**	Parameters:
**		database -- database description.
**
**	Returns:
**		SMDBE_OK -- Success, otherwise errno.
*/

int
smdb_unlock_map(database)
	SMDB_DATABASE *database;
{
	int fd;

	fd = database->smdb_lockfd(database);
	if (fd < 0)
		return SMDBE_NOT_FOUND;
	if (!smdb_lockfile(fd, LOCK_UN))
		return SMDBE_LOCK_NOT_HELD;
	return SMDBE_OK;
}
/*
**  SMDB_SETUP_FILE -- Gets db file ready for use.
**
**	Makes sure permissions on file are safe and creates it if it
**	doesn't exist.
**
**	Parameters:
**		db_name -- The name of the database without extension.
**		extension -- The extension.
**		sff -- Flags to safefile.
**		mode_mask -- Mode bits that must match.
**		user_info -- Information on the user to use for file
**			    permissions.
**		stat_info -- A place to put the stat info for the file.
**	Returns:
**		SMDBE_OK -- Success, otherwise errno.
*/

int
smdb_setup_file(db_name, extension, mode_mask, sff, user_info, stat_info)
	char *db_name;
	char *extension;
	int mode_mask;
	long sff;
	SMDB_USER_INFO *user_info;
	struct stat *stat_info;
{
	int st;
	int result;
	char db_file_name[MAXPATHLEN];

	result = smdb_add_extension(db_file_name, sizeof db_file_name, db_name,
				    extension);
	if (result != SMDBE_OK)
		return result;

	st = safefile(db_file_name, user_info->smdbu_id,
		      user_info->smdbu_group_id, user_info->smdbu_name,
		      sff, mode_mask, stat_info);
	if (st != 0)
		return st;

	return SMDBE_OK;
}
/*
**  SMDB_FILECHANGED -- Checks to see if a file changed.
**
**	Compares the passed in stat_info with a current stat on
**	the passed in file descriptor. Check filechanged for
**	return values.
**
**	Parameters:
**		db_name -- The name of the database without extension.
**		extension -- The extension.
**		db_fd -- A file descriptor for the database file.
**		stat_info -- An old stat_info.
**	Returns:
**		SMDBE_OK -- Success, otherwise errno.
*/

int
smdb_filechanged(db_name, extension, db_fd, stat_info)
	char *db_name;
	char *extension;
	int db_fd;
	struct stat *stat_info;
{
	int result;
	char db_file_name[MAXPATHLEN];

	result = smdb_add_extension(db_file_name, sizeof db_file_name, db_name,
				    extension);
	if (result != SMDBE_OK)
		return result;
	return filechanged(db_file_name, db_fd, stat_info);
}
/*
** SMDB_PRINT_AVAILABLE_TYPES -- Prints the names of the available types.
**
**	Parameters:
**		None
**
**	Returns:
**		None
*/

void
smdb_print_available_types()
{
#ifdef NDBM
	printf("dbm\n");
#endif /* NDBM */
#ifdef NEWDB
	printf("hash\n");
	printf("btree\n");
#endif /* NEWDB */
}
/*
** SMDB_DB_DEFINITION -- Given a database type, return database definition
**
**	Reads though a structure making an association with the database
**	type and the required cpp define from sendmail/README.
**	List size is dynamic and must be NULL terminated.
**
**	Parameters:
**		type -- The name of the database type.
**
**	Returns:
**		definition for type, otherwise NULL.
*/

typedef struct
{
	SMDB_DBTYPE type;
	char *dbdef;
} dbtype;

static dbtype DatabaseDefs[] =
{
	{ SMDB_TYPE_HASH,	"NEWDB" },
	{ SMDB_TYPE_BTREE,	"NEWDB" },
	{ SMDB_TYPE_NDBM,	"NDBM"	},
	{ NULL,			"OOPS"	}
};

char *
smdb_db_definition(type)
	SMDB_DBTYPE type;
{
	dbtype *ptr = DatabaseDefs;

	while (ptr != NULL && ptr->type != NULL)
	{
		if (strcmp(type, ptr->type) == 0)
			return ptr->dbdef;
		ptr++;
	}
	return NULL;
}
@


1.10
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.9
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
** Copyright (c) 1999-2002 Sendmail, Inc. and its suppliers.
d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: smdb.c,v 8.58 2004/08/03 20:58:38 ca Exp $")
@


1.8
log
@Update to sendmail-8.12.4
@
text
@d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: smdb.c,v 8.57 2002/05/24 23:09:11 gshapiro Exp $")
d20 2
@


1.7
log
@update to sendmail 8.12.3
@
text
@d2 1
a2 1
** Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: smdb.c,v 8.54 2002/04/04 21:32:14 gshapiro Exp $")
d322 1
a322 1
	char file_name[SMDB_MAX_NAME_LEN];
d324 1
a324 1
	result = smdb_add_extension(file_name, SMDB_MAX_NAME_LEN, db_name,
d329 1
a329 1
	*lock_fd = safeopen(file_name, mode & ~O_TRUNC, 0644, sff);
d438 1
a438 1
	char db_file_name[SMDB_MAX_NAME_LEN];
d440 1
a440 1
	result = smdb_add_extension(db_file_name, SMDB_MAX_NAME_LEN, db_name,
d477 1
a477 1
	char db_file_name[SMDB_MAX_NAME_LEN];
d479 1
a479 1
	result = smdb_add_extension(db_file_name, SMDB_MAX_NAME_LEN, db_name,
@


1.6
log
@update to sendmail-8.12.2
@
text
@d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: smdb.c,v 8.53 2001/11/19 19:31:14 gshapiro Exp $")
a121 5
		int omode = -1;
# ifdef F_GETFL
		(void) fcntl(fd, F_GETFL, &omode);
		errno = save_errno;
# endif /* F_GETFL */
d123 3
d127 1
a127 1
		       filename, ext, fd, type, omode, (int) geteuid());
d129 1
a141 5
		int omode = -1;
# ifdef F_GETFL
		(void) fcntl(fd, F_GETFL, &omode);
		errno = save_errno;
# endif /* F_GETFL */
d143 3
d147 1
a147 1
		       filename, ext, fd, type, omode, (int) geteuid());
d149 1
@


1.5
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: smdb.c,v 8.52 2001/09/11 04:04:52 gshapiro Exp $")
a200 1
	int result;
d222 2
d240 2
@


1.4
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: smdb.c,v 8.49 2001/09/04 22:43:45 ca Exp $")
d21 1
a21 1
/*
d46 1
a46 1
/*
d63 1
a63 1
/*
d158 1
a158 1
/*
d249 1
a249 1
/*
d296 1
a296 1
/*
d334 1
a334 1
/*
d358 1
a358 1
/*
d385 1
a385 1
/*
d408 1
a408 1
/*
d452 1
a452 1
/*
d484 1
a484 1
/*
d505 1
a505 1
/*
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
** Copyright (c) 1999-2000 Sendmail, Inc. and its suppliers.
d10 2
a11 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: smdb.c,v 8.37.4.2 2000/08/24 17:08:00 gshapiro Exp $";
#endif /* ! lint */
d40 1
a40 1
		memset(db, '\0', sizeof(SMDB_DATABASE));
a62 1

d73 2
a74 2
**		TRUE if the lock was acquired.
**		FALSE otherwise.
d88 1
a88 1
	memset(&lfd, '\0', sizeof lfd);
d104 1
a104 3
	{
		return TRUE;
	}
d117 1
a117 3
	{
		return TRUE;
	}
d129 1
a129 1
			filename, ext, fd, type, omode, geteuid());
d131 1
a131 1
		return FALSE;
d138 1
a138 3
	{
		return TRUE;
	}
d150 1
a150 1
			filename, ext, fd, type, omode, geteuid());
d152 1
a152 1
		return FALSE;
d156 1
a156 1
	return FALSE;
a157 1

d202 1
a202 1
	bool type_was_default = FALSE;
d206 1
a206 1
		type_was_default = TRUE;
a248 1

d289 2
a290 2
		snprintf(full_name, max_full_name_len, "%s.%s", db_name,
			 extension);
d292 1
a292 1
		(void) strlcpy(full_name, db_name, max_full_name_len);
a295 1

a333 1

a357 1

a384 1

a407 2


a451 1

d482 1
a482 4

	result = filechanged(db_file_name, db_fd, stat_info);

	return result;
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d11 1
a11 1
static char id[] = "@@(#)$Sendmail: smdb.c,v 8.37 2000/03/17 07:32:43 gshapiro Exp $";
d18 1
d65 101
d370 53
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d11 1
a11 1
static char id[] = "@@(#)$Sendmail: smdb.c,v 8.37.4.2 2000/08/24 17:08:00 gshapiro Exp $";
a17 1

a63 101
/*
**  SMDB_LOCKFILE -- lock a file using flock or (shudder) fcntl locking
**
**	Parameters:
**		fd -- the file descriptor of the file.
**		type -- type of the lock.  Bits can be:
**			LOCK_EX -- exclusive lock.
**			LOCK_NB -- non-blocking.
**
**	Returns:
**		TRUE if the lock was acquired.
**		FALSE otherwise.
*/

static bool
smdb_lockfile(fd, type)
	int fd;
	int type;
{
	int i;
	int save_errno;
#if !HASFLOCK
	int action;
	struct flock lfd;

	memset(&lfd, '\0', sizeof lfd);
	if (bitset(LOCK_UN, type))
		lfd.l_type = F_UNLCK;
	else if (bitset(LOCK_EX, type))
		lfd.l_type = F_WRLCK;
	else
		lfd.l_type = F_RDLCK;

	if (bitset(LOCK_NB, type))
		action = F_SETLK;
	else
		action = F_SETLKW;

	while ((i = fcntl(fd, action, &lfd)) < 0 && errno == EINTR)
		continue;
	if (i >= 0)
	{
		return TRUE;
	}
	save_errno = errno;

	/*
	**  On SunOS, if you are testing using -oQ/tmp/mqueue or
	**  -oA/tmp/aliases or anything like that, and /tmp is mounted
	**  as type "tmp" (that is, served from swap space), the
	**  previous fcntl will fail with "Invalid argument" errors.
	**  Since this is fairly common during testing, we will assume
	**  that this indicates that the lock is successfully grabbed.
	*/

	if (save_errno == EINVAL)
	{
		return TRUE;
	}

	if (!bitset(LOCK_NB, type) ||
	    (save_errno != EACCES && save_errno != EAGAIN))
	{
		int omode = -1;
# ifdef F_GETFL
		(void) fcntl(fd, F_GETFL, &omode);
		errno = save_errno;
# endif /* F_GETFL */
# if 0
		syslog(LOG_ERR, "cannot lockf(%s%s, fd=%d, type=%o, omode=%o, euid=%d)",
			filename, ext, fd, type, omode, geteuid());
# endif /* 0 */
		return FALSE;
	}
#else /* !HASFLOCK */

	while ((i = flock(fd, type)) < 0 && errno == EINTR)
		continue;
	if (i >= 0)
	{
		return TRUE;
	}
	save_errno = errno;

	if (!bitset(LOCK_NB, type) || save_errno != EWOULDBLOCK)
	{
		int omode = -1;
# ifdef F_GETFL
		(void) fcntl(fd, F_GETFL, &omode);
		errno = save_errno;
# endif /* F_GETFL */
# if 0
		syslog(LOG_ERR, "cannot flock(%s%s, fd=%d, type=%o, omode=%o, euid=%d)",
			filename, ext, fd, type, omode, geteuid());
# endif /* 0 */
		return FALSE;
	}
#endif /* !HASFLOCK */
	errno = save_errno;
	return FALSE;
}
a267 53

/*
**  SMDB_LOCK_MAP -- Locks a database.
**
**	Parameters:
**		database -- database description.
**		type -- type of the lock.  Bits can be:
**			LOCK_EX -- exclusive lock.
**			LOCK_NB -- non-blocking.
**
**	Returns:
**		SMDBE_OK -- Success, otherwise errno.
*/

int
smdb_lock_map(database, type)
	SMDB_DATABASE *database;
	int type;
{
	int fd;

	fd = database->smdb_lockfd(database);
	if (fd < 0)
		return SMDBE_NOT_FOUND;
	if (!smdb_lockfile(fd, type))
		return SMDBE_LOCK_NOT_GRANTED;
	return SMDBE_OK;
}

/*
**  SMDB_UNLOCK_MAP -- Unlocks a database
**
**	Parameters:
**		database -- database description.
**
**	Returns:
**		SMDBE_OK -- Success, otherwise errno.
*/

int
smdb_unlock_map(database)
	SMDB_DATABASE *database;
{
	int fd;

	fd = database->smdb_lockfd(database);
	if (fd < 0)
		return SMDBE_NOT_FOUND;
	if (!smdb_lockfile(fd, LOCK_UN))
		return SMDBE_LOCK_NOT_HELD;
	return SMDBE_OK;
}

@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
** Copyright (c) 1999 Sendmail, Inc. and its suppliers.
d11 1
a11 10
static char copyright[] =
"@@(#) Copyright (c) 1998, 1999 Sendmail, Inc. and its suppliers.\n\
	All rights reserved.\n\
     Copyright (c) 1983, 1987, 1993\n\
	The Regents of the University of California.  All rights reserved.\n\
     Copyright (c) 1983 Eric P. Allman.  All rights reserved.\n";
#endif /* ! lint */

#ifndef lint
static char id[] = "@@(#)$Sendmail: smdb.c,v 8.33 1999/10/13 06:17:07 gshapiro Exp $";
d103 1
a103 1
	int sff;
d109 1
d111 3
a114 1
	if (type == SMDB_TYPE_DEFAULT)
d116 4
d121 1
a121 4
#ifdef NDBM
	if (type == SMDB_TYPE_DEFAULT)
		type = SMDB_TYPE_NDBM;
#endif /* NDBM */
d126 17
a153 12
	if ((strncmp(type, SMDB_TYPE_HASH, SMDB_TYPE_HASH_LEN) == 0) ||
	    (strncmp(type, SMDB_TYPE_BTREE, SMDB_TYPE_BTREE_LEN) == 0))
	{
#ifdef NEWDB
		result = smdb_db_open(database, db_name, mode, mode_mask, sff,
				      type, user_info, params);
		return result;
#else /* NEWDB */
		return SMDBE_UNSUPPORTED_DB_TYPE;
#endif /* NEWDB */
	}

d194 2
a195 1
	if (db_name_len < extension_len ||
d226 1
a226 1
	int sff;
d292 1
a292 1
	int sff;
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d2 1
a2 1
** Copyright (c) 1999-2000 Sendmail, Inc. and its suppliers.
d11 10
a20 1
static char id[] = "@@(#)$Id: smdb.c,v 8.37.4.2 2000/08/24 17:08:00 gshapiro Exp $";
a26 1

a72 101
/*
**  SMDB_LOCKFILE -- lock a file using flock or (shudder) fcntl locking
**
**	Parameters:
**		fd -- the file descriptor of the file.
**		type -- type of the lock.  Bits can be:
**			LOCK_EX -- exclusive lock.
**			LOCK_NB -- non-blocking.
**
**	Returns:
**		TRUE if the lock was acquired.
**		FALSE otherwise.
*/

static bool
smdb_lockfile(fd, type)
	int fd;
	int type;
{
	int i;
	int save_errno;
#if !HASFLOCK
	int action;
	struct flock lfd;

	memset(&lfd, '\0', sizeof lfd);
	if (bitset(LOCK_UN, type))
		lfd.l_type = F_UNLCK;
	else if (bitset(LOCK_EX, type))
		lfd.l_type = F_WRLCK;
	else
		lfd.l_type = F_RDLCK;

	if (bitset(LOCK_NB, type))
		action = F_SETLK;
	else
		action = F_SETLKW;

	while ((i = fcntl(fd, action, &lfd)) < 0 && errno == EINTR)
		continue;
	if (i >= 0)
	{
		return TRUE;
	}
	save_errno = errno;

	/*
	**  On SunOS, if you are testing using -oQ/tmp/mqueue or
	**  -oA/tmp/aliases or anything like that, and /tmp is mounted
	**  as type "tmp" (that is, served from swap space), the
	**  previous fcntl will fail with "Invalid argument" errors.
	**  Since this is fairly common during testing, we will assume
	**  that this indicates that the lock is successfully grabbed.
	*/

	if (save_errno == EINVAL)
	{
		return TRUE;
	}

	if (!bitset(LOCK_NB, type) ||
	    (save_errno != EACCES && save_errno != EAGAIN))
	{
		int omode = -1;
# ifdef F_GETFL
		(void) fcntl(fd, F_GETFL, &omode);
		errno = save_errno;
# endif /* F_GETFL */
# if 0
		syslog(LOG_ERR, "cannot lockf(%s%s, fd=%d, type=%o, omode=%o, euid=%d)",
			filename, ext, fd, type, omode, geteuid());
# endif /* 0 */
		return FALSE;
	}
#else /* !HASFLOCK */

	while ((i = flock(fd, type)) < 0 && errno == EINTR)
		continue;
	if (i >= 0)
	{
		return TRUE;
	}
	save_errno = errno;

	if (!bitset(LOCK_NB, type) || save_errno != EWOULDBLOCK)
	{
		int omode = -1;
# ifdef F_GETFL
		(void) fcntl(fd, F_GETFL, &omode);
		errno = save_errno;
# endif /* F_GETFL */
# if 0
		syslog(LOG_ERR, "cannot flock(%s%s, fd=%d, type=%o, omode=%o, euid=%d)",
			filename, ext, fd, type, omode, geteuid());
# endif /* 0 */
		return FALSE;
	}
#endif /* !HASFLOCK */
	errno = save_errno;
	return FALSE;
}
d112 1
a112 1
	long sff;
a117 1
	bool type_was_default = FALSE;
d119 1
a120 3
	{
		type_was_default = TRUE;
#ifdef NEWDB
d122 3
a124 2
#else /* NEWDB */
# ifdef NDBM
d126 1
a126 3
# endif /* NDBM */
#endif /* NEWDB */
	}
d131 11
d148 1
a148 6
# ifdef NDBM
		if (result == ENOENT && type_was_default)
			type = SMDB_TYPE_NDBM;
		else
# endif /* NDBM */
			return result;
a153 11
	if (strncmp(type, SMDB_TYPE_NDBM, SMDB_TYPE_NDBM_LEN) == 0)
	{
#ifdef NDBM
		result = smdb_ndbm_open(database, db_name, mode, mode_mask,
					sff, type, user_info, params);
		return result;
#else /* NDBM */
		return SMDBE_UNSUPPORTED_DB_TYPE;
#endif /* NDBM */
	}

d194 1
a194 2
	if (db_name_len < extension_len + 1 ||
	    db_name[db_name_len - extension_len - 1] != '.' ||
d225 1
a225 1
	long sff;
a268 53
**  SMDB_LOCK_MAP -- Locks a database.
**
**	Parameters:
**		database -- database description.
**		type -- type of the lock.  Bits can be:
**			LOCK_EX -- exclusive lock.
**			LOCK_NB -- non-blocking.
**
**	Returns:
**		SMDBE_OK -- Success, otherwise errno.
*/

int
smdb_lock_map(database, type)
	SMDB_DATABASE *database;
	int type;
{
	int fd;

	fd = database->smdb_lockfd(database);
	if (fd < 0)
		return SMDBE_NOT_FOUND;
	if (!smdb_lockfile(fd, type))
		return SMDBE_LOCK_NOT_GRANTED;
	return SMDBE_OK;
}

/*
**  SMDB_UNLOCK_MAP -- Unlocks a database
**
**	Parameters:
**		database -- database description.
**
**	Returns:
**		SMDBE_OK -- Success, otherwise errno.
*/

int
smdb_unlock_map(database)
	SMDB_DATABASE *database;
{
	int fd;

	fd = database->smdb_lockfd(database);
	if (fd < 0)
		return SMDBE_NOT_FOUND;
	if (!smdb_lockfile(fd, LOCK_UN))
		return SMDBE_LOCK_NOT_HELD;
	return SMDBE_OK;
}


/*
d291 1
a291 1
	long sff;
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
** Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d10 3
a12 2
#include <sm/gen.h>
SM_RCSID("@@(#)$Sendmail: smdb.c,v 8.49 2001/09/04 22:43:45 ca Exp $")
d41 1
a41 1
		(void) memset(db, '\0', sizeof(SMDB_DATABASE));
d64 1
d75 2
a76 2
**		true if the lock was acquired.
**		false otherwise.
d90 1
a90 1
	(void) memset(&lfd, '\0', sizeof lfd);
d106 3
a108 1
		return true;
d121 3
a123 1
		return true;
d135 1
a135 1
		       filename, ext, fd, type, omode, (int) geteuid());
d137 1
a137 1
		return false;
d144 3
a146 1
		return true;
d158 1
a158 1
		       filename, ext, fd, type, omode, (int) geteuid());
d160 1
a160 1
		return false;
d164 1
a164 1
	return false;
d166 1
d211 1
a211 1
	bool type_was_default = false;
d215 1
a215 1
		type_was_default = true;
d258 1
d299 2
a300 2
		(void) sm_snprintf(full_name, max_full_name_len, "%s.%s",
				   db_name, extension);
d302 1
a302 1
		(void) sm_strlcpy(full_name, db_name, max_full_name_len);
d306 1
d345 1
d370 1
d398 1
d422 2
d468 1
d499 4
a502 1
	return filechanged(db_file_name, db_fd, stat_info);
@


