head	1.14;
access;
symbols
	OPENBSD_5_6:1.13.0.6
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.16
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.14
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.12
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.10
	OPENBSD_5_0:1.12.0.8
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.24
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.20
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.18
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.16
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.14
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.12
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.10
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.8
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.6
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.13;
commitid	M7i5giHIoz3DMlTU;

1.13
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.11.13.18.55.13;	author guenther;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.24.03.59.26;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.17.17.31.40;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.03.17.31.21;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.01.19.59.21;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.03.17.25.46;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.28.02.43.52;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.15.21.09.03;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.07.19.20.36;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.42;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.52;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.29.11;	author miod;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Bye.
@
text
@/*
** Copyright (c) 1999-2003, 2009 Proofpoint, Inc. and its suppliers.
**	All rights reserved.
**
** By using this file, you agree to the terms and conditions set
** forth in the LICENSE file which can be found at the top level of
** the sendmail distribution.
*/

#include <sm/gen.h>
SM_RCSID("@@(#)$Sendmail: smdb2.c,v 8.83 2013/11/22 20:51:49 ca Exp $")

#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>


#include <sendmail/sendmail.h>
#include <libsmdb/smdb.h>

#if (DB_VERSION_MAJOR >= 2)

# define SMDB2_FILE_EXTENSION "db"

struct smdb_db2_database
{
	DB	*smdb2_db;
	int	smdb2_lock_fd;
};
typedef struct smdb_db2_database SMDB_DB2_DATABASE;

/*
**  SMDB_TYPE_TO_DB2_TYPE -- Translates smdb database type to db2 type.
**
**	Parameters:
**		type -- The type to translate.
**
**	Returns:
**		The DB2 type that corresponsds to the passed in SMDB type.
**		Returns -1 if there is no equivalent type.
**
*/

DBTYPE
smdb_type_to_db2_type(type)
	SMDB_DBTYPE type;
{
	if (type == SMDB_TYPE_DEFAULT)
		return DB_HASH;

	if (strncmp(type, SMDB_TYPE_HASH, SMDB_TYPE_HASH_LEN) == 0)
		return DB_HASH;

	if (strncmp(type, SMDB_TYPE_BTREE, SMDB_TYPE_BTREE_LEN) == 0)
		return DB_BTREE;

	return DB_UNKNOWN;
}
/*
**  DB2_ERROR_TO_SMDB -- Translates db2 errors to smdbe errors
**
**	Parameters:
**		error -- The error to translate.
**
**	Returns:
**		The SMDBE error corresponding to the db2 error.
**		If we don't have a corresponding error, it returs errno.
**
*/

int
db2_error_to_smdb(error)
	int error;
{
	int result;

	switch (error)
	{
# ifdef DB_INCOMPLETE
		case DB_INCOMPLETE:
			result = SMDBE_INCOMPLETE;
			break;
# endif /* DB_INCOMPLETE */

# ifdef DB_NOTFOUND
		case DB_NOTFOUND:
			result = SMDBE_NOT_FOUND;
			break;
# endif /* DB_NOTFOUND */

# ifdef DB_KEYEMPTY
		case DB_KEYEMPTY:
			result = SMDBE_KEY_EMPTY;
			break;
# endif /* DB_KEYEMPTY */

# ifdef DB_KEYEXIST
		case DB_KEYEXIST:
			result = SMDBE_KEY_EXIST;
			break;
# endif /* DB_KEYEXIST */

# ifdef DB_LOCK_DEADLOCK
		case DB_LOCK_DEADLOCK:
			result = SMDBE_LOCK_DEADLOCK;
			break;
# endif /* DB_LOCK_DEADLOCK */

# ifdef DB_LOCK_NOTGRANTED
		case DB_LOCK_NOTGRANTED:
			result = SMDBE_LOCK_NOT_GRANTED;
			break;
# endif /* DB_LOCK_NOTGRANTED */

# ifdef DB_LOCK_NOTHELD
		case DB_LOCK_NOTHELD:
			result = SMDBE_LOCK_NOT_HELD;
			break;
# endif /* DB_LOCK_NOTHELD */

# ifdef DB_RUNRECOVERY
		case DB_RUNRECOVERY:
			result = SMDBE_RUN_RECOVERY;
			break;
# endif /* DB_RUNRECOVERY */

# ifdef DB_OLD_VERSION
		case DB_OLD_VERSION:
			result = SMDBE_OLD_VERSION;
			break;
# endif /* DB_OLD_VERSION */

		case 0:
			result = SMDBE_OK;
			break;

		default:
			result = error;
	}
	return result;
}
/*
**  SMDB_PUT_FLAGS_TO_DB2_FLAGS -- Translates smdb put flags to db2 put flags.
**
**	Parameters:
**		flags -- The flags to translate.
**
**	Returns:
**		The db2 flags that are equivalent to the smdb flags.
**
**	Notes:
**		Any invalid flags are ignored.
**
*/

unsigned int
smdb_put_flags_to_db2_flags(flags)
	SMDB_FLAG flags;
{
	int return_flags;

	return_flags = 0;

	if (bitset(SMDBF_NO_OVERWRITE, flags))
		return_flags |= DB_NOOVERWRITE;

	return return_flags;
}
/*
**  SMDB_CURSOR_GET_FLAGS_TO_DB2 -- Translates smdb cursor get flags to db2
**	getflags.
**
**	Parameters:
**		flags -- The flags to translate.
**
**	Returns:
**		The db2 flags that are equivalent to the smdb flags.
**
**	Notes:
**		-1 is returned if flag is unknown.
**
*/

int
smdb_cursor_get_flags_to_db2(flags)
	SMDB_FLAG flags;
{
	switch (flags)
	{
		case SMDB_CURSOR_GET_FIRST:
			return DB_FIRST;

		case SMDB_CURSOR_GET_LAST:
			return DB_LAST;

		case SMDB_CURSOR_GET_NEXT:
			return DB_NEXT;

		case SMDB_CURSOR_GET_RANGE:
			return DB_SET_RANGE;

		default:
			return -1;
	}
}

/*
**  Except for smdb_db_open, the rest of these functions correspond to the
**  interface laid out in smdb.h.
*/

SMDB_DB2_DATABASE *
smdb2_malloc_database()
{
	SMDB_DB2_DATABASE *db2;

	db2 = (SMDB_DB2_DATABASE *) malloc(sizeof(SMDB_DB2_DATABASE));
	if (db2 != NULL)
		db2->smdb2_lock_fd = -1;

	return db2;
}

int
smdb2_close(database)
	SMDB_DATABASE *database;
{
	int result;
	SMDB_DB2_DATABASE *db2 = (SMDB_DB2_DATABASE *) database->smdb_impl;
	DB *db = ((SMDB_DB2_DATABASE *) database->smdb_impl)->smdb2_db;

	result = db2_error_to_smdb(db->close(db, 0));
	if (db2->smdb2_lock_fd != -1)
		close(db2->smdb2_lock_fd);

	free(db2);
	database->smdb_impl = NULL;

	return result;
}

int
smdb2_del(database, key, flags)
	SMDB_DATABASE *database;
	SMDB_DBENT *key;
	unsigned int flags;
{
	DB *db = ((SMDB_DB2_DATABASE *) database->smdb_impl)->smdb2_db;
	DBT dbkey;

	(void) memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;
	return db2_error_to_smdb(db->del(db, NULL, &dbkey, flags));
}

int
smdb2_fd(database, fd)
	SMDB_DATABASE *database;
	int *fd;
{
	DB *db = ((SMDB_DB2_DATABASE *) database->smdb_impl)->smdb2_db;

	return db2_error_to_smdb(db->fd(db, fd));
}

int
smdb2_lockfd(database)
	SMDB_DATABASE *database;
{
	SMDB_DB2_DATABASE *db2 = (SMDB_DB2_DATABASE *) database->smdb_impl;

	return db2->smdb2_lock_fd;
}

int
smdb2_get(database, key, data, flags)
	SMDB_DATABASE *database;
	SMDB_DBENT *key;
	SMDB_DBENT *data;
	unsigned int flags;
{
	int result;
	DB *db = ((SMDB_DB2_DATABASE *) database->smdb_impl)->smdb2_db;
	DBT dbkey, dbdata;

	(void) memset(&dbdata, '\0', sizeof dbdata);
	(void) memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;

	result = db->get(db, NULL, &dbkey, &dbdata, flags);
	data->data = dbdata.data;
	data->size = dbdata.size;
	return db2_error_to_smdb(result);
}

int
smdb2_put(database, key, data, flags)
	SMDB_DATABASE *database;
	SMDB_DBENT *key;
	SMDB_DBENT *data;
	unsigned int flags;
{
	DB *db = ((SMDB_DB2_DATABASE *) database->smdb_impl)->smdb2_db;
	DBT dbkey, dbdata;

	(void) memset(&dbdata, '\0', sizeof dbdata);
	(void) memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;
	dbdata.data = data->data;
	dbdata.size = data->size;

	return db2_error_to_smdb(db->put(db, NULL, &dbkey, &dbdata,
					 smdb_put_flags_to_db2_flags(flags)));
}


int
smdb2_set_owner(database, uid, gid)
	SMDB_DATABASE *database;
	uid_t uid;
	gid_t gid;
{
# if HASFCHOWN
	int fd;
	int result;
	DB *db = ((SMDB_DB2_DATABASE *) database->smdb_impl)->smdb2_db;

	result = db->fd(db, &fd);
	if (result != 0)
		return result;

	result = fchown(fd, uid, gid);
	if (result < 0)
		return errno;
# endif /* HASFCHOWN */

	return SMDBE_OK;
}

int
smdb2_sync(database, flags)
	SMDB_DATABASE *database;
	unsigned int flags;
{
	DB *db = ((SMDB_DB2_DATABASE *) database->smdb_impl)->smdb2_db;

	return db2_error_to_smdb(db->sync(db, flags));
}

int
smdb2_cursor_close(cursor)
	SMDB_CURSOR *cursor;
{
	int ret;
	DBC *dbc = (DBC *) cursor->smdbc_impl;

	ret = db2_error_to_smdb(dbc->c_close(dbc));
	free(cursor);
	return ret;
}

int
smdb2_cursor_del(cursor, flags)
	SMDB_CURSOR *cursor;
	SMDB_FLAG flags;
{
	DBC *dbc = (DBC *) cursor->smdbc_impl;

	return db2_error_to_smdb(dbc->c_del(dbc, 0));
}

int
smdb2_cursor_get(cursor, key, value, flags)
	SMDB_CURSOR *cursor;
	SMDB_DBENT *key;
	SMDB_DBENT *value;
	SMDB_FLAG flags;
{
	int db2_flags;
	int result;
	DBC *dbc = (DBC *) cursor->smdbc_impl;
	DBT dbkey, dbdata;

	(void) memset(&dbdata, '\0', sizeof dbdata);
	(void) memset(&dbkey, '\0', sizeof dbkey);

	db2_flags = smdb_cursor_get_flags_to_db2(flags);
	result = dbc->c_get(dbc, &dbkey, &dbdata, db2_flags);
	if (result == DB_NOTFOUND)
		return SMDBE_LAST_ENTRY;
	key->data = dbkey.data;
	key->size = dbkey.size;
	value->data = dbdata.data;
	value->size = dbdata.size;
	return db2_error_to_smdb(result);
}

int
smdb2_cursor_put(cursor, key, value, flags)
	SMDB_CURSOR *cursor;
	SMDB_DBENT *key;
	SMDB_DBENT *value;
	SMDB_FLAG flags;
{
	DBC *dbc = (DBC *) cursor->smdbc_impl;
	DBT dbkey, dbdata;

	(void) memset(&dbdata, '\0', sizeof dbdata);
	(void) memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;
	dbdata.data = value->data;
	dbdata.size = value->size;

	return db2_error_to_smdb(dbc->c_put(dbc, &dbkey, &dbdata, 0));
}

int
smdb2_cursor(database, cursor, flags)
	SMDB_DATABASE *database;
	SMDB_CURSOR **cursor;
	SMDB_FLAG flags;
{
	int result;
	DB *db = ((SMDB_DB2_DATABASE *) database->smdb_impl)->smdb2_db;
	DBC *db2_cursor;

# if DB_VERSION_MAJOR > 2 || DB_VERSION_MINOR >= 6
	result = db->cursor(db, NULL, &db2_cursor, 0);
# else /* DB_VERSION_MAJOR > 2 || DB_VERSION_MINOR >= 6 */
	result = db->cursor(db, NULL, &db2_cursor);
# endif /* DB_VERSION_MAJOR > 2 || DB_VERSION_MINOR >= 6 */
	if (result != 0)
		return db2_error_to_smdb(result);

	*cursor = (SMDB_CURSOR *) malloc(sizeof(SMDB_CURSOR));
	if (*cursor == NULL)
		return SMDBE_MALLOC;

	(*cursor)->smdbc_close = smdb2_cursor_close;
	(*cursor)->smdbc_del = smdb2_cursor_del;
	(*cursor)->smdbc_get = smdb2_cursor_get;
	(*cursor)->smdbc_put = smdb2_cursor_put;
	(*cursor)->smdbc_impl = db2_cursor;

	return SMDBE_OK;
}

# if DB_VERSION_MAJOR == 2
static int
smdb_db_open_internal(db_name, db_type, db_flags, db_params, db)
	char *db_name;
	DBTYPE db_type;
	int db_flags;
	SMDB_DBPARAMS *db_params;
	DB **db;
{
	void *params;
	DB_INFO db_info;

	params = NULL;
	(void) memset(&db_info, '\0', sizeof db_info);
	if (db_params != NULL)
	{
		db_info.db_cachesize = db_params->smdbp_cache_size;
		if (db_type == DB_HASH)
			db_info.h_nelem = db_params->smdbp_num_elements;
		if (db_params->smdbp_allow_dup)
			db_info.flags |= DB_DUP;
		params = &db_info;
	}
	return db_open(db_name, db_type, db_flags, DBMMODE, NULL, params, db);
}
# endif /* DB_VERSION_MAJOR == 2 */

# if DB_VERSION_MAJOR > 2
static int
smdb_db_open_internal(db_name, db_type, db_flags, db_params, db)
	char *db_name;
	DBTYPE db_type;
	int db_flags;
	SMDB_DBPARAMS *db_params;
	DB **db;
{
	int result;

	result = db_create(db, NULL, 0);
	if (result != 0 || *db == NULL)
		return result;

	if (db_params != NULL)
	{
		result = (*db)->set_cachesize(*db, 0,
					      db_params->smdbp_cache_size, 0);
		if (result != 0)
		{
			(void) (*db)->close((*db), 0);
			*db = NULL;
			return db2_error_to_smdb(result);
		}
		if (db_type == DB_HASH)
		{
			result = (*db)->set_h_nelem(*db, db_params->smdbp_num_elements);
			if (result != 0)
			{
				(void) (*db)->close(*db, 0);
				*db = NULL;
				return db2_error_to_smdb(result);
			}
		}
		if (db_params->smdbp_allow_dup)
		{
			result = (*db)->set_flags(*db, DB_DUP);
			if (result != 0)
			{
				(void) (*db)->close(*db, 0);
				*db = NULL;
				return db2_error_to_smdb(result);
			}
		}
	}

	result = (*db)->open(*db,
			     DBTXN	/* transaction for DB 4.1 */
			     db_name, NULL, db_type, db_flags, DBMMODE);
	if (result != 0)
	{
		(void) (*db)->close(*db, 0);
		*db = NULL;
	}
	return db2_error_to_smdb(result);
}
# endif /* DB_VERSION_MAJOR > 2 */
/*
**  SMDB_DB_OPEN -- Opens a db database.
**
**	Parameters:
**		database -- An unallocated database pointer to a pointer.
**		db_name -- The name of the database without extension.
**		mode -- File permisions for a created database.
**		mode_mask -- Mode bits that must match on an opened database.
**		sff -- Flags for safefile.
**		type -- The type of database to open
**			See smdb_type_to_db2_type for valid types.
**		user_info -- User information for file permissions.
**		db_params --
**			An SMDB_DBPARAMS struct including params. These
**			are processed according to the type of the
**			database. Currently supported params (only for
**			HASH type) are:
**			   num_elements
**			   cache_size
**
**	Returns:
**		SMDBE_OK -- Success, other errno:
**		SMDBE_MALLOC -- Cannot allocate memory.
**		SMDBE_BAD_OPEN -- db_open didn't return an error, but
**				 somehow the DB pointer is NULL.
**		Anything else: translated error from db2
*/

int
smdb_db_open(database, db_name, mode, mode_mask, sff, type, user_info, db_params)
	SMDB_DATABASE **database;
	char *db_name;
	int mode;
	int mode_mask;
	long sff;
	SMDB_DBTYPE type;
	SMDB_USER_INFO *user_info;
	SMDB_DBPARAMS *db_params;
{
	bool lockcreated = false;
	int result;
	int db_flags;
	int lock_fd;
	int db_fd;
	int major_v, minor_v, patch_v;
	SMDB_DATABASE *smdb_db;
	SMDB_DB2_DATABASE *db2;
	DB *db;
	DBTYPE db_type;
	struct stat stat_info;
	char db_file_name[MAXPATHLEN];

	(void) db_version(&major_v, &minor_v, &patch_v);
	if (major_v != DB_VERSION_MAJOR || minor_v != DB_VERSION_MINOR)
		return SMDBE_VERSION_MISMATCH;

	*database = NULL;

	result = smdb_add_extension(db_file_name, sizeof db_file_name,
				    db_name, SMDB2_FILE_EXTENSION);
	if (result != SMDBE_OK)
		return result;

	result = smdb_setup_file(db_name, SMDB2_FILE_EXTENSION,
				 mode_mask, sff, user_info, &stat_info);
	if (result != SMDBE_OK)
		return result;

	lock_fd = -1;

	if (stat_info.st_mode == ST_MODE_NOFILE &&
	    bitset(mode, O_CREAT))
		lockcreated = true;

	result = smdb_lock_file(&lock_fd, db_name, mode, sff,
				SMDB2_FILE_EXTENSION);
	if (result != SMDBE_OK)
		return result;

	if (lockcreated)
	{
		mode |= O_TRUNC;
		mode &= ~(O_CREAT|O_EXCL);
	}

	smdb_db = smdb_malloc_database();
	db2 = smdb2_malloc_database();
	if (db2 == NULL || smdb_db == NULL)
	{
		smdb_unlock_file(lock_fd);
		smdb_free_database(smdb_db);	/* ok to be NULL */
		if (db2 != NULL)
			free(db2);
		return SMDBE_MALLOC;
	}

	db2->smdb2_lock_fd = lock_fd;

	db_type = smdb_type_to_db2_type(type);

	db = NULL;

	db_flags = 0;
	if (bitset(O_CREAT, mode))
		db_flags |= DB_CREATE;
	if (bitset(O_TRUNC, mode))
		db_flags |= DB_TRUNCATE;
	if (mode == O_RDONLY)
		db_flags |= DB_RDONLY;
	SM_DB_FLAG_ADD(db_flags);

	result = smdb_db_open_internal(db_file_name, db_type,
				       db_flags, db_params, &db);

	if (result == 0 && db != NULL)
	{
		result = db->fd(db, &db_fd);
		if (result == 0)
			result = SMDBE_OK;
	}
	else
	{
		/* Try and narrow down on the problem */
		if (result != 0)
			result = db2_error_to_smdb(result);
		else
			result = SMDBE_BAD_OPEN;
	}

	if (result == SMDBE_OK)
		result = smdb_filechanged(db_name, SMDB2_FILE_EXTENSION, db_fd,
					  &stat_info);

	if (result == SMDBE_OK)
	{
		/* Everything is ok. Setup driver */
		db2->smdb2_db = db;

		smdb_db->smdb_close = smdb2_close;
		smdb_db->smdb_del = smdb2_del;
		smdb_db->smdb_fd = smdb2_fd;
		smdb_db->smdb_lockfd = smdb2_lockfd;
		smdb_db->smdb_get = smdb2_get;
		smdb_db->smdb_put = smdb2_put;
		smdb_db->smdb_set_owner = smdb2_set_owner;
		smdb_db->smdb_sync = smdb2_sync;
		smdb_db->smdb_cursor = smdb2_cursor;
		smdb_db->smdb_impl = db2;

		*database = smdb_db;

		return SMDBE_OK;
	}

	if (db != NULL)
		db->close(db, 0);

	smdb_unlock_file(db2->smdb2_lock_fd);
	free(db2);
	smdb_free_database(smdb_db);

	return result;
}

#endif /* (DB_VERSION_MAJOR >= 2) */
@


1.13
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.12
log
@Merge from the Sendmail CVS: fix potential memory leak: only set
up data after all allocations succeeded, free previously allocated
data if later allocation fails.

Prompted by parfait and based on a patch from jsg@@; additional bits
from me and Claus Assmann of Sendmail.  ok deraadt@@
@
text
@d2 1
a2 1
** Copyright (c) 1999-2003, 2009 Sendmail, Inc. and its suppliers.
d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: smdb2.c,v 8.80 2009/11/12 23:07:49 ca Exp $")
d628 2
@


1.11
log
@Update to sendmail.8.13.0
@
text
@d2 1
a2 1
** Copyright (c) 1999-2003 Sendmail, Inc. and its suppliers.
d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: smdb2.c,v 8.79 2003/06/13 21:33:11 ca Exp $")
a622 3
	if (smdb_db == NULL)
		return SMDBE_MALLOC;

d624 4
a627 1
	if (db2 == NULL)
d629 1
@


1.10
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: smdb2.c,v 8.72.2.7 2003/06/24 17:16:10 ca Exp $")
@


1.9
log
@Update to Sendmail 8.12.8; fixes a buffer overflow in the envelope
comments processing which may allow an attacker to gain root privileges.
@
text
@d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: smdb2.c,v 8.72.2.6 2003/01/23 22:21:39 ca Exp $")
d581 1
d588 4
@


1.8
log
@update to sendmail 8.12.7
@
text
@d2 1
a2 1
** Copyright (c) 1999-2002 Sendmail, Inc. and its suppliers.
d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: smdb2.c,v 8.72.2.4 2002/12/03 17:01:15 ca Exp $")
@


1.7
log
@Update to sendmail-8.12.4
@
text
@d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: smdb2.c,v 8.72 2002/05/24 23:09:11 gshapiro Exp $")
d526 3
a528 1
	result = (*db)->open(*db, db_name, NULL, db_type, db_flags, DBMMODE);
d638 1
a638 3
# if !HASFLOCK && defined(DB_FCNTL_LOCKING)
	db_flags |= DB_FCNTL_LOCKING;
# endif /* !HASFLOCK && defined(DB_FCNTL_LOCKING) */
@


1.6
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d2 1
a2 1
** Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: smdb2.c,v 8.69 2001/09/12 21:19:12 gshapiro Exp $")
d475 1
a475 1
	return db_open(db_name, db_type, db_flags, 0644, NULL, params, db);
d526 1
a526 1
	result = (*db)->open(*db, db_name, NULL, db_type, db_flags, 0644);
d584 1
a584 1
	char db_file_name[SMDB_MAX_NAME_LEN];
d588 1
a588 1
	result = smdb_add_extension(db_file_name, SMDB_MAX_NAME_LEN,
@


1.5
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: smdb2.c,v 8.65 2001/05/10 01:23:58 ca Exp $")
d32 1
a32 1
/*
d59 1
a59 1
/*
d142 1
a142 1
/*
d169 1
a169 1
/*
d228 1
d232 1
d239 1
a239 1
	return db2_error_to_smdb(db->close(db, 0));
d535 1
a535 1
/*
@


1.4
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d10 2
a11 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: smdb2.c,v 8.53.2.1.2.7 2001/02/14 04:07:24 gshapiro Exp $";
#endif /* ! lint */
a58 2


a141 1

d156 1
a156 1
u_int
a168 1

d207 5
a223 6

/*
** Except for smdb_db_open, the rest of these function correspond to the
** interface laid out in smdb.h.
*/

d244 1
a244 1
	u_int flags;
d249 1
a249 1
	memset(&dbkey, '\0', sizeof dbkey);
a273 1

d279 1
a279 1
	u_int flags;
d285 2
a286 2
	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
d301 1
a301 1
	u_int flags;
d306 2
a307 2
	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
d344 1
a344 1
	u_int flags;
d385 2
a386 2
	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
d409 2
a410 2
	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
d463 1
a463 1
	memset(&db_info, '\0', sizeof db_info);
d572 1
a572 1
	bool lockcreated = FALSE;
d600 1
a600 1
		lockcreated = TRUE;
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
** Copyright (c) 1999-2000 Sendmail, Inc. and its suppliers.
d11 1
a11 1
static char id[] = "@@(#)$Sendmail: smdb2.c,v 8.53.2.1.2.5 2000/10/26 00:39:56 geir Exp $";
d362 1
d365 3
a367 1
	return db2_error_to_smdb(dbc->c_close(dbc));
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d11 1
a11 1
static char id[] = "@@(#)$Sendmail: smdb2.c,v 8.53 2000/03/17 07:32:43 gshapiro Exp $";
d18 1
d141 1
a141 1
			result = errno;
d253 1
d255 4
a258 1
	return db2_error_to_smdb(db->del(db, NULL, &key->db, flags));
d272 10
d288 1
d290 1
d292 9
a300 1
	return db2_error_to_smdb(db->get(db, NULL, &key->db, &data->db, flags));
d311 1
d313 8
a320 1
	return db2_error_to_smdb(db->put(db, NULL, &key->db, &data->db,
d387 4
d393 1
a393 1
	result = dbc->c_get(dbc, &key->db, &value->db, db2_flags);
d396 4
d411 8
d420 1
a420 1
	return db2_error_to_smdb(dbc->c_put(dbc, &key->db, &value->db, 0));
d672 1
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
** Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d11 1
a11 1
static char id[] = "@@(#)$Sendmail: smdb2.c,v 8.53.2.1.2.7 2001/02/14 04:07:24 gshapiro Exp $";
a17 1

d140 1
a140 1
			result = error;
a251 1
	DBT dbkey;
d253 1
a253 4
	memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;
	return db2_error_to_smdb(db->del(db, NULL, &dbkey, flags));
a266 10
smdb2_lockfd(database)
	SMDB_DATABASE *database;
{
	SMDB_DB2_DATABASE *db2 = (SMDB_DB2_DATABASE *) database->smdb_impl;

	return db2->smdb2_lock_fd;
}


int
a272 1
	int result;
a273 1
	DBT dbkey, dbdata;
d275 1
a275 9
	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;

	result = db->get(db, NULL, &dbkey, &dbdata, flags);
	data->data = dbdata.data;
	data->size = dbdata.size;
	return db2_error_to_smdb(result);
a285 1
	DBT dbkey, dbdata;
d287 1
a287 8
	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;
	dbdata.data = data->data;
	dbdata.size = data->size;

	return db2_error_to_smdb(db->put(db, NULL, &dbkey, &dbdata,
a328 1
	int ret;
d331 1
a331 3
	ret = db2_error_to_smdb(dbc->c_close(dbc));
	free(cursor);
	return ret;
a353 4
	DBT dbkey, dbdata;

	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
d356 1
a356 1
	result = dbc->c_get(dbc, &dbkey, &dbdata, db2_flags);
a358 4
	key->data = dbkey.data;
	key->size = dbkey.size;
	value->data = dbdata.data;
	value->size = dbdata.size;
a369 8
	DBT dbkey, dbdata;

	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;
	dbdata.data = value->data;
	dbdata.size = value->size;
d371 1
a371 1
	return db2_error_to_smdb(dbc->c_put(dbc, &dbkey, &dbdata, 0));
a622 1
		smdb_db->smdb_lockfd = smdb2_lockfd;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
** Copyright (c) 1999 Sendmail, Inc. and its suppliers.
d11 1
a11 1
static char id[] = "@@(#)$Sendmail: smdb2.c,v 8.48 1999/11/23 08:42:54 gshapiro Exp $";
d203 3
d522 1
a522 1
	int sff;
d527 1
d553 4
d562 6
d583 1
a583 1
	if (O_CREAT & mode)
d585 1
a585 1
	if (O_TRUNC & mode)
d587 1
a587 1
	if (O_RDONLY == mode)
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d2 1
a2 1
** Copyright (c) 1999-2000 Sendmail, Inc. and its suppliers.
d11 1
a11 1
static char id[] = "@@(#)$Id: smdb2.c,v 8.53.2.1.2.5 2000/10/26 00:39:56 geir Exp $";
a17 1

d140 1
a140 1
			result = error;
a202 3
		case SMDB_CURSOR_GET_RANGE:
			return DB_SET_RANGE;

a248 1
	DBT dbkey;
d250 1
a250 4
	memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;
	return db2_error_to_smdb(db->del(db, NULL, &dbkey, flags));
a263 10
smdb2_lockfd(database)
	SMDB_DATABASE *database;
{
	SMDB_DB2_DATABASE *db2 = (SMDB_DB2_DATABASE *) database->smdb_impl;

	return db2->smdb2_lock_fd;
}


int
a269 1
	int result;
a270 1
	DBT dbkey, dbdata;
d272 1
a272 9
	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;

	result = db->get(db, NULL, &dbkey, &dbdata, flags);
	data->data = dbdata.data;
	data->size = dbdata.size;
	return db2_error_to_smdb(result);
a282 8
	DBT dbkey, dbdata;

	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;
	dbdata.data = data->data;
	dbdata.size = data->size;
d284 1
a284 1
	return db2_error_to_smdb(db->put(db, NULL, &dbkey, &dbdata,
a350 4
	DBT dbkey, dbdata;

	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
d353 1
a353 1
	result = dbc->c_get(dbc, &dbkey, &dbdata, db2_flags);
a355 4
	key->data = dbkey.data;
	key->size = dbkey.size;
	value->data = dbdata.data;
	value->size = dbdata.size;
a366 8
	DBT dbkey, dbdata;

	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;
	dbdata.data = value->data;
	dbdata.size = value->size;
d368 1
a368 1
	return db2_error_to_smdb(dbc->c_put(dbc, &dbkey, &dbdata, 0));
d519 1
a519 1
	long sff;
a523 1
	bool lockcreated = FALSE;
a548 4
	if (stat_info.st_mode == ST_MODE_NOFILE &&
	    bitset(mode, O_CREAT))
		lockcreated = TRUE;

a553 6
	if (lockcreated)
	{
		mode |= O_TRUNC;
		mode &= ~(O_CREAT|O_EXCL);
	}

d569 1
a569 1
	if (bitset(O_CREAT, mode))
d571 1
a571 1
	if (bitset(O_TRUNC, mode))
d573 1
a573 1
	if (mode == O_RDONLY)
a608 1
		smdb_db->smdb_lockfd = smdb2_lockfd;
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
** Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d10 3
a12 2
#include <sm/gen.h>
SM_RCSID("@@(#)$Sendmail: smdb2.c,v 8.65 2001/05/10 01:23:58 ca Exp $")
d60 2
d145 1
d160 1
a160 1
unsigned int
d173 1
a211 5
/*
**  Except for smdb_db_open, the rest of these functions correspond to the
**  interface laid out in smdb.h.
*/

d224 6
d250 1
a250 1
	unsigned int flags;
d255 1
a255 1
	(void) memset(&dbkey, '\0', sizeof dbkey);
d280 1
d286 1
a286 1
	unsigned int flags;
d292 2
a293 2
	(void) memset(&dbdata, '\0', sizeof dbdata);
	(void) memset(&dbkey, '\0', sizeof dbkey);
d308 1
a308 1
	unsigned int flags;
d313 2
a314 2
	(void) memset(&dbdata, '\0', sizeof dbdata);
	(void) memset(&dbkey, '\0', sizeof dbkey);
d351 1
a351 1
	unsigned int flags;
a361 1
	int ret;
d364 1
a364 3
	ret = db2_error_to_smdb(dbc->c_close(dbc));
	free(cursor);
	return ret;
d389 2
a390 2
	(void) memset(&dbdata, '\0', sizeof dbdata);
	(void) memset(&dbkey, '\0', sizeof dbkey);
d413 2
a414 2
	(void) memset(&dbdata, '\0', sizeof dbdata);
	(void) memset(&dbkey, '\0', sizeof dbkey);
d467 1
a467 1
	(void) memset(&db_info, '\0', sizeof db_info);
d576 1
a576 1
	bool lockcreated = false;
d604 1
a604 1
		lockcreated = true;
@


