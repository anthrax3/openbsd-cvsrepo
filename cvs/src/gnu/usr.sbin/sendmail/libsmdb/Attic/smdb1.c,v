head	1.11;
access;
symbols
	OPENBSD_5_6:1.10.0.6
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.16
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.14
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.12
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.10
	OPENBSD_5_0:1.9.0.8
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.7.0.10
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.8
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.10;
commitid	M7i5giHIoz3DMlTU;

1.10
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.13.18.55.13;	author guenther;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.16.00.21.30;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.03.17.25.46;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.18.00.49.27;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.15.21.09.03;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.07.19.20.36;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.42;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.52;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.29.11;	author miod;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Bye.
@
text
@/*
** Copyright (c) 1999-2002, 2004, 2009 Proofpoint, Inc. and its suppliers.
**	All rights reserved.
**
** By using this file, you agree to the terms and conditions set
** forth in the LICENSE file which can be found at the top level of
** the sendmail distribution.
*/

#include <sm/gen.h>
SM_RCSID("@@(#)$Sendmail: smdb1.c,v 8.63 2013/11/22 20:51:49 ca Exp $")

#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>

#include <sendmail/sendmail.h>
#include <libsmdb/smdb.h>

#if (DB_VERSION_MAJOR == 1)

# define SMDB1_FILE_EXTENSION "db"

struct smdb_db1_struct
{
	DB	*smdb1_db;
	int	smdb1_lock_fd;
	bool	smdb1_cursor_in_use;
};
typedef struct smdb_db1_struct SMDB_DB1_DATABASE;

struct smdb_db1_cursor
{
	SMDB_DB1_DATABASE	*db;
};
typedef struct smdb_db1_cursor SMDB_DB1_CURSOR;

static DBTYPE		smdb_type_to_db1_type __P((SMDB_DBTYPE));
static unsigned int	smdb_put_flags_to_db1_flags __P((SMDB_FLAG));
static int		smdb_cursor_get_flags_to_smdb1 __P((SMDB_FLAG));
static SMDB_DB1_DATABASE *smdb1_malloc_database __P((void));
static int		smdb1_close __P((SMDB_DATABASE *));
static int		smdb1_del __P((SMDB_DATABASE *, SMDB_DBENT *, unsigned int));
static int		smdb1_fd __P((SMDB_DATABASE *, int *));
static int		smdb1_lockfd __P((SMDB_DATABASE *));
static int		smdb1_get __P((SMDB_DATABASE *, SMDB_DBENT *, SMDB_DBENT *, unsigned int));
static int		smdb1_put __P((SMDB_DATABASE *, SMDB_DBENT *, SMDB_DBENT *, unsigned int));
static int		smdb1_set_owner __P((SMDB_DATABASE *, uid_t, gid_t));
static int		smdb1_sync __P((SMDB_DATABASE *, unsigned int));
static int		smdb1_cursor_close __P((SMDB_CURSOR *));
static int		smdb1_cursor_del __P((SMDB_CURSOR *, unsigned int));
static int		smdb1_cursor_get __P((SMDB_CURSOR *, SMDB_DBENT *, SMDB_DBENT *, SMDB_FLAG));
static int		smdb1_cursor_put __P((SMDB_CURSOR *, SMDB_DBENT *, SMDB_DBENT *, SMDB_FLAG));
static int		smdb1_cursor __P((SMDB_DATABASE *, SMDB_CURSOR **, unsigned int));

/*
**  SMDB_TYPE_TO_DB1_TYPE -- Translates smdb database type to db1 type.
**
**	Parameters:
**		type -- The type to translate.
**
**	Returns:
**		The DB1 type that corresponsds to the passed in SMDB type.
**		Returns -1 if there is no equivalent type.
**
*/

static DBTYPE
smdb_type_to_db1_type(type)
	SMDB_DBTYPE type;
{
	if (type == SMDB_TYPE_DEFAULT)
		return DB_HASH;

	if (strncmp(type, SMDB_TYPE_HASH, SMDB_TYPE_HASH_LEN) == 0)
		return DB_HASH;

	if (strncmp(type, SMDB_TYPE_BTREE, SMDB_TYPE_BTREE_LEN) == 0)
		return DB_BTREE;

	/* Should never get here thanks to test in smdb_db_open() */
	return DB_HASH;
}
/*
**  SMDB_PUT_FLAGS_TO_DB1_FLAGS -- Translates smdb put flags to db1 put flags.
**
**	Parameters:
**		flags -- The flags to translate.
**
**	Returns:
**		The db1 flags that are equivalent to the smdb flags.
**
**	Notes:
**		Any invalid flags are ignored.
**
*/

static unsigned int
smdb_put_flags_to_db1_flags(flags)
	SMDB_FLAG flags;
{
	int return_flags;

	return_flags = 0;

	if (bitset(SMDBF_NO_OVERWRITE, flags))
		return_flags |= R_NOOVERWRITE;

	return return_flags;
}
/*
**  SMDB_CURSOR_GET_FLAGS_TO_SMDB1
**
**	Parameters:
**		flags -- The flags to translate.
**
**	Returns:
**		The db1 flags that are equivalent to the smdb flags.
**
**	Notes:
**		Returns -1 if we don't support the flag.
**
*/

static int
smdb_cursor_get_flags_to_smdb1(flags)
	SMDB_FLAG flags;
{
	switch(flags)
	{
		case SMDB_CURSOR_GET_FIRST:
			return R_FIRST;

		case SMDB_CURSOR_GET_LAST:
			return R_LAST;

		case SMDB_CURSOR_GET_NEXT:
			return R_NEXT;

		case SMDB_CURSOR_GET_RANGE:
			return R_CURSOR;

		default:
			return -1;
	}
}

/*
**  The rest of these functions correspond to the interface laid out in smdb.h.
*/

static SMDB_DB1_DATABASE *
smdb1_malloc_database()
{
	SMDB_DB1_DATABASE *db1;

	db1 = (SMDB_DB1_DATABASE *) malloc(sizeof(SMDB_DB1_DATABASE));

	if (db1 != NULL)
	{
		db1->smdb1_lock_fd = -1;
		db1->smdb1_cursor_in_use = false;
	}

	return db1;
}

static int
smdb1_close(database)
	SMDB_DATABASE *database;
{
	int result;
	SMDB_DB1_DATABASE *db1 = (SMDB_DB1_DATABASE *) database->smdb_impl;
	DB *db = ((SMDB_DB1_DATABASE *) database->smdb_impl)->smdb1_db;

	result = db->close(db);
	if (db1->smdb1_lock_fd != -1)
		(void) close(db1->smdb1_lock_fd);

	free(db1);
	database->smdb_impl = NULL;

	return result;
}

static int
smdb1_del(database, key, flags)
	SMDB_DATABASE *database;
	SMDB_DBENT *key;
	unsigned int flags;
{
	DB *db = ((SMDB_DB1_DATABASE *) database->smdb_impl)->smdb1_db;
	DBT dbkey;

	(void) memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;
	return db->del(db, &dbkey, flags);
}

static int
smdb1_fd(database, fd)
	SMDB_DATABASE *database;
	int *fd;
{
	DB *db = ((SMDB_DB1_DATABASE *) database->smdb_impl)->smdb1_db;

	*fd = db->fd(db);
	if (*fd == -1)
		return errno;

	return SMDBE_OK;
}

static int
smdb1_lockfd(database)
	SMDB_DATABASE *database;
{
	SMDB_DB1_DATABASE *db1 = (SMDB_DB1_DATABASE *) database->smdb_impl;

	return db1->smdb1_lock_fd;
}


static int
smdb1_get(database, key, data, flags)
	SMDB_DATABASE *database;
	SMDB_DBENT *key;
	SMDB_DBENT *data;
	unsigned int flags;
{
	int result;
	DB *db = ((SMDB_DB1_DATABASE *) database->smdb_impl)->smdb1_db;
	DBT dbkey, dbdata;

	(void) memset(&dbdata, '\0', sizeof dbdata);
	(void) memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;

	result = db->get(db, &dbkey, &dbdata, flags);
	if (result != 0)
	{
		if (result == 1)
			return SMDBE_NOT_FOUND;
		return errno;
	}
	data->data = dbdata.data;
	data->size = dbdata.size;
	return SMDBE_OK;
}

static int
smdb1_put(database, key, data, flags)
	SMDB_DATABASE *database;
	SMDB_DBENT *key;
	SMDB_DBENT *data;
	unsigned int flags;
{
	DB *db = ((SMDB_DB1_DATABASE *) database->smdb_impl)->smdb1_db;
	DBT dbkey, dbdata;

	(void) memset(&dbdata, '\0', sizeof dbdata);
	(void) memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;
	dbdata.data = data->data;
	dbdata.size = data->size;

	return db->put(db, &dbkey, &dbdata,
		       smdb_put_flags_to_db1_flags(flags));
}

static int
smdb1_set_owner(database, uid, gid)
	SMDB_DATABASE *database;
	uid_t uid;
	gid_t gid;
{
# if HASFCHOWN
	int fd;
	int result;
	DB *db = ((SMDB_DB1_DATABASE *) database->smdb_impl)->smdb1_db;

	fd = db->fd(db);
	if (fd == -1)
		return errno;

	result = fchown(fd, uid, gid);
	if (result < 0)
		return errno;
# endif /* HASFCHOWN */

	return SMDBE_OK;
}

static int
smdb1_sync(database, flags)
	SMDB_DATABASE *database;
	unsigned int flags;
{
	DB *db = ((SMDB_DB1_DATABASE *) database->smdb_impl)->smdb1_db;

	return db->sync(db, flags);
}

static int
smdb1_cursor_close(cursor)
	SMDB_CURSOR *cursor;
{
	SMDB_DB1_CURSOR *db1_cursor = (SMDB_DB1_CURSOR *) cursor->smdbc_impl;
	SMDB_DB1_DATABASE *db1 = db1_cursor->db;

	if (!db1->smdb1_cursor_in_use)
		return SMDBE_NOT_A_VALID_CURSOR;

	db1->smdb1_cursor_in_use = false;
	free(cursor);

	return SMDBE_OK;
}

static int
smdb1_cursor_del(cursor, flags)
	SMDB_CURSOR *cursor;
	unsigned int flags;
{
	SMDB_DB1_CURSOR *db1_cursor = (SMDB_DB1_CURSOR *) cursor->smdbc_impl;
	SMDB_DB1_DATABASE *db1 = db1_cursor->db;
	DB *db = db1->smdb1_db;

	return db->del(db, NULL, R_CURSOR);
}

static int
smdb1_cursor_get(cursor, key, value, flags)
	SMDB_CURSOR *cursor;
	SMDB_DBENT *key;
	SMDB_DBENT *value;
	SMDB_FLAG flags;
{
	int db1_flags;
	int result;
	SMDB_DB1_CURSOR *db1_cursor = (SMDB_DB1_CURSOR *) cursor->smdbc_impl;
	SMDB_DB1_DATABASE *db1 = db1_cursor->db;
	DB *db = db1->smdb1_db;
	DBT dbkey, dbdata;

	(void) memset(&dbdata, '\0', sizeof dbdata);
	(void) memset(&dbkey, '\0', sizeof dbkey);

	db1_flags = smdb_cursor_get_flags_to_smdb1(flags);
	result = db->seq(db, &dbkey, &dbdata, db1_flags);
	if (result == -1)
		return errno;
	if (result == 1)
		return SMDBE_LAST_ENTRY;
	value->data = dbdata.data;
	value->size = dbdata.size;
	key->data = dbkey.data;
	key->size = dbkey.size;
	return SMDBE_OK;
}

static int
smdb1_cursor_put(cursor, key, value, flags)
	SMDB_CURSOR *cursor;
	SMDB_DBENT *key;
	SMDB_DBENT *value;
	SMDB_FLAG flags;
{
	SMDB_DB1_CURSOR *db1_cursor = (SMDB_DB1_CURSOR *) cursor->smdbc_impl;
	SMDB_DB1_DATABASE *db1 = db1_cursor->db;
	DB *db = db1->smdb1_db;
	DBT dbkey, dbdata;

	(void) memset(&dbdata, '\0', sizeof dbdata);
	(void) memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;
	dbdata.data = value->data;
	dbdata.size = value->size;

	return db->put(db, &dbkey, &dbdata, R_CURSOR);
}

static int
smdb1_cursor(database, cursor, flags)
	SMDB_DATABASE *database;
	SMDB_CURSOR **cursor;
	unsigned int flags;
{
	SMDB_DB1_DATABASE *db1 = (SMDB_DB1_DATABASE *) database->smdb_impl;
	SMDB_CURSOR *cur;
	SMDB_DB1_CURSOR *db1_cursor;

	if (db1->smdb1_cursor_in_use)
		return SMDBE_ONLY_SUPPORTS_ONE_CURSOR;

	db1_cursor = (SMDB_DB1_CURSOR *) malloc(sizeof(SMDB_DB1_CURSOR));
	if (db1_cursor == NULL)
		return SMDBE_MALLOC;

	cur = (SMDB_CURSOR *) malloc(sizeof(SMDB_CURSOR));
	if (cur == NULL)
	{
		free(db1_cursor);
		return SMDBE_MALLOC;
	}

	db1->smdb1_cursor_in_use = true;
	db1_cursor->db = db1;
	cur->smdbc_impl = db1_cursor;
	cur->smdbc_close = smdb1_cursor_close;
	cur->smdbc_del = smdb1_cursor_del;
	cur->smdbc_get = smdb1_cursor_get;
	cur->smdbc_put = smdb1_cursor_put;
	*cursor = cur;

	return SMDBE_OK;
}
/*
**  SMDB_DB_OPEN -- Opens a db1 database.
**
**	Parameters:
**		database -- An unallocated database pointer to a pointer.
**		db_name -- The name of the database without extension.
**		mode -- File permisions on the database if created.
**		mode_mask -- Mode bits that must match on an existing database.
**		sff -- Flags for safefile.
**		type -- The type of database to open
**			See smdb_type_to_db1_type for valid types.
**		user_info -- Information on the user to use for file
**			    permissions.
**		db_params --
**			An SMDB_DBPARAMS struct including params. These
**			are processed according to the type of the
**			database. Currently supported params (only for
**			HASH type) are:
**			   num_elements
**			   cache_size
**
**	Returns:
**		SMDBE_OK -- Success, otherwise errno.
*/

int
smdb_db_open(database, db_name, mode, mode_mask, sff, type, user_info,
	     db_params)
	SMDB_DATABASE **database;
	char *db_name;
	int mode;
	int mode_mask;
	long sff;
	SMDB_DBTYPE type;
	SMDB_USER_INFO *user_info;
	SMDB_DBPARAMS *db_params;
{
	bool lockcreated = false;
	int db_fd;
	int lock_fd;
	int result;
	void *params;
	SMDB_DATABASE *smdb_db;
	SMDB_DB1_DATABASE *db1;
	DB *db;
	HASHINFO hash_info;
	BTREEINFO btree_info;
	DBTYPE db_type;
	struct stat stat_info;
	char db_file_name[MAXPATHLEN];

	if (type == NULL ||
	    (strncmp(SMDB_TYPE_HASH, type, SMDB_TYPE_HASH_LEN) != 0 &&
	     strncmp(SMDB_TYPE_BTREE, type, SMDB_TYPE_BTREE_LEN) != 0))
		return SMDBE_UNKNOWN_DB_TYPE;

	result = smdb_add_extension(db_file_name, sizeof db_file_name,
				    db_name, SMDB1_FILE_EXTENSION);
	if (result != SMDBE_OK)
		return result;

	result = smdb_setup_file(db_name, SMDB1_FILE_EXTENSION, mode_mask,
				 sff, user_info, &stat_info);
	if (result != SMDBE_OK)
		return result;

	if (stat_info.st_mode == ST_MODE_NOFILE &&
	    bitset(mode, O_CREAT))
		lockcreated = true;

	lock_fd = -1;
	result = smdb_lock_file(&lock_fd, db_name, mode, sff,
				SMDB1_FILE_EXTENSION);
	if (result != SMDBE_OK)
		return result;

	if (lockcreated)
	{
		mode |= O_TRUNC;
		mode &= ~(O_CREAT|O_EXCL);
	}

	*database = NULL;

	smdb_db = smdb_malloc_database();
	db1 = smdb1_malloc_database();
	if (smdb_db == NULL || db1 == NULL)
	{
		(void) smdb_unlock_file(lock_fd);
		smdb_free_database(smdb_db);
		free(db1);
		return SMDBE_MALLOC;
	}
	db1->smdb1_lock_fd = lock_fd;

	params = NULL;
	if (db_params != NULL &&
	    (strncmp(SMDB_TYPE_HASH, type, SMDB_TYPE_HASH_LEN) == 0))
	{
		(void) memset(&hash_info, '\0', sizeof hash_info);
		hash_info.nelem = db_params->smdbp_num_elements;
		hash_info.cachesize = db_params->smdbp_cache_size;
		params = &hash_info;
	}

	if (db_params != NULL &&
	    (strncmp(SMDB_TYPE_BTREE, type, SMDB_TYPE_BTREE_LEN) == 0))
	{
		(void) memset(&btree_info, '\0', sizeof btree_info);
		btree_info.cachesize = db_params->smdbp_cache_size;
		if (db_params->smdbp_allow_dup)
			btree_info.flags |= R_DUP;
		params = &btree_info;
	}

	db_type = smdb_type_to_db1_type(type);
	db = dbopen(db_file_name, mode, DBMMODE, db_type, params);
	if (db != NULL)
	{
		db_fd = db->fd(db);
		result = smdb_filechanged(db_name, SMDB1_FILE_EXTENSION, db_fd,
					  &stat_info);
	}
	else
	{
		if (errno == 0)
			result = SMDBE_BAD_OPEN;
		else
			result = errno;
	}

	if (result == SMDBE_OK)
	{
		/* Everything is ok. Setup driver */
		db1->smdb1_db = db;

		smdb_db->smdb_close = smdb1_close;
		smdb_db->smdb_del = smdb1_del;
		smdb_db->smdb_fd = smdb1_fd;
		smdb_db->smdb_lockfd = smdb1_lockfd;
		smdb_db->smdb_get = smdb1_get;
		smdb_db->smdb_put = smdb1_put;
		smdb_db->smdb_set_owner = smdb1_set_owner;
		smdb_db->smdb_sync = smdb1_sync;
		smdb_db->smdb_cursor = smdb1_cursor;
		smdb_db->smdb_impl = db1;

		*database = smdb_db;
		return SMDBE_OK;
	}

	if (db != NULL)
		(void) db->close(db);

	/* Error opening database */
	(void) smdb_unlock_file(db1->smdb1_lock_fd);
	free(db1);
	smdb_free_database(smdb_db);

	return result;
}

#endif /* (DB_VERSION_MAJOR == 1) */
@


1.10
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.9
log
@Merge from the Sendmail CVS: fix potential memory leak: only set
up data after all allocations succeeded, free previously allocated
data if later allocation fails.

Prompted by parfait and based on a patch from jsg@@; additional bits
from me and Claus Assmann of Sendmail.  ok deraadt@@
@
text
@d2 1
a2 1
** Copyright (c) 1999-2002, 2004, 2009 Sendmail, Inc. and its suppliers.
d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: smdb1.c,v 8.62 2009/11/12 23:04:18 ca Exp $")
@


1.8
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
** Copyright (c) 1999-2002 Sendmail, Inc. and its suppliers.
d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: smdb1.c,v 8.59 2004/08/03 20:58:39 ca Exp $")
a399 1
	db1->smdb1_cursor_in_use = true;
d401 2
a402 1
	db1_cursor->db = db1;
a404 1

d406 2
d409 1
d411 2
d509 4
d514 1
@


1.7
log
@Update to sendmail-8.12.4
@
text
@d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: smdb1.c,v 8.58 2002/05/24 23:09:11 gshapiro Exp $")
d38 18
d68 1
a68 1
DBTYPE
d98 1
a98 1
unsigned int
d125 1
a125 1
int
d152 1
a152 1
SMDB_DB1_DATABASE *
d168 1
a168 1
int
d186 1
a186 1
int
d201 1
a201 1
int
d215 1
a215 1
int
d225 1
a225 1
int
d253 1
a253 1
int
d274 1
a274 1
int
d297 1
a297 1
int
d307 1
a307 1
int
d323 1
a323 1
int
d335 1
a335 1
int
d365 1
a365 1
int
d387 1
a387 1
int
@


1.6
log
@update to sendmail 8.12.3
@
text
@d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: smdb1.c,v 8.56 2002/01/21 04:10:44 gshapiro Exp $")
d449 1
a449 1
	char db_file_name[SMDB_MAX_NAME_LEN];
d456 1
a456 1
	result = smdb_add_extension(db_file_name, SMDB_MAX_NAME_LEN,
d511 1
a511 1
	db = dbopen(db_file_name, mode, 0644, db_type, params);
@


1.5
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d2 1
a2 1
** Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: smdb1.c,v 8.55 2001/09/12 21:19:12 gshapiro Exp $")
d437 1
d466 4
a470 3
# if O_EXLOCK
	mode |= O_EXLOCK;
# else /* O_EXLOCK */
d475 6
a480 1
# endif /* O_EXLOCK */
@


1.4
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: smdb1.c,v 8.51 2001/05/10 01:23:58 ca Exp $")
d38 1
a38 1
/*
d66 1
a66 1
/*
d93 1
a93 1
/*
d154 1
d158 1
d165 1
a165 1
	return db->close(db);
d400 1
a400 1
/*
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
** Copyright (c) 1999-2000 Sendmail, Inc. and its suppliers.
d10 2
a11 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: smdb1.c,v 8.43.4.3 2000/10/05 23:06:30 gshapiro Exp $";
#endif /* ! lint */
a65 2


d80 1
a80 1
u_int
a92 1

d130 4
d144 1
a144 1
		db1->smdb1_cursor_in_use = FALSE;
a149 5
/*
** The rest of these function correspond to the interface laid out
** in smdb.h.
*/

d170 1
a170 1
	u_int flags;
d175 1
a175 1
	memset(&dbkey, '\0', sizeof dbkey);
d210 1
a210 1
	u_int flags;
d216 2
a217 2
	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
d238 1
a238 1
	u_int flags;
d243 2
a244 2
	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
d280 1
a280 1
	u_int flags;
d297 1
a297 1
	db1->smdb1_cursor_in_use = FALSE;
d306 1
a306 1
	u_int flags;
d329 2
a330 2
	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
d357 2
a358 2
	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
d371 1
a371 1
	u_int flags;
d380 1
a380 1
	db1->smdb1_cursor_in_use = TRUE;
a397 1

d485 1
a485 1
		memset(&hash_info, '\0', sizeof hash_info);
d494 1
a494 1
		memset(&btree_info, '\0', sizeof btree_info);
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d11 1
a11 1
static char id[] = "@@(#)$Sendmail: smdb1.c,v 8.43 2000/03/17 07:32:43 gshapiro Exp $";
d178 1
d180 4
a183 1
	return db->del(db, &key->db, flags);
d201 10
d219 6
d226 1
a226 1
	result = db->get(db, &key->db, &data->db, flags);
d233 2
d246 1
d248 9
a256 2
	return db->put(db, &key->db, &data->db,
			    smdb_put_flags_to_db1_flags(flags));
d332 4
d338 1
a338 1
	result = db->seq(db, &key->db, &value->db, db1_flags);
d343 4
d360 8
d369 1
a369 1
	return db->put(db, &key->db, &value->db, R_CURSOR);
d531 1
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d11 1
a11 1
static char id[] = "@@(#)$Sendmail: smdb1.c,v 8.43.4.3 2000/10/05 23:06:30 gshapiro Exp $";
a177 1
	DBT dbkey;
d179 1
a179 4
	memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;
	return db->del(db, &dbkey, flags);
a196 10
smdb1_lockfd(database)
	SMDB_DATABASE *database;
{
	SMDB_DB1_DATABASE *db1 = (SMDB_DB1_DATABASE *) database->smdb_impl;

	return db1->smdb1_lock_fd;
}


int
a204 6
	DBT dbkey, dbdata;

	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;
d206 1
a206 1
	result = db->get(db, &dbkey, &dbdata, flags);
a212 2
	data->data = dbdata.data;
	data->size = dbdata.size;
a223 1
	DBT dbkey, dbdata;
d225 2
a226 9
	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;
	dbdata.data = data->data;
	dbdata.size = data->size;

	return db->put(db, &dbkey, &dbdata,
		       smdb_put_flags_to_db1_flags(flags));
a301 4
	DBT dbkey, dbdata;

	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
d304 1
a304 1
	result = db->seq(db, &dbkey, &dbdata, db1_flags);
a308 4
	value->data = dbdata.data;
	value->size = dbdata.size;
	key->data = dbkey.data;
	key->size = dbkey.size;
a321 8
	DBT dbkey, dbdata;

	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;
	dbdata.data = value->data;
	dbdata.size = value->size;
d323 1
a323 1
	return db->put(db, &dbkey, &dbdata, R_CURSOR);
a484 1
		smdb_db->smdb_lockfd = smdb1_lockfd;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
** Copyright (c) 1999 Sendmail, Inc. and its suppliers.
d11 1
a11 1
static char id[] = "@@(#)$Sendmail: smdb1.c,v 8.40 1999/11/23 08:42:53 gshapiro Exp $";
d126 3
d390 1
a390 1
	int sff;
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d2 1
a2 1
** Copyright (c) 1999-2000 Sendmail, Inc. and its suppliers.
d11 1
a11 1
static char id[] = "@@(#)$Id: smdb1.c,v 8.43.4.3 2000/10/05 23:06:30 gshapiro Exp $";
a125 3
		case SMDB_CURSOR_GET_RANGE:
			return R_CURSOR;

a174 1
	DBT dbkey;
d176 1
a176 4
	memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;
	return db->del(db, &dbkey, flags);
a193 10
smdb1_lockfd(database)
	SMDB_DATABASE *database;
{
	SMDB_DB1_DATABASE *db1 = (SMDB_DB1_DATABASE *) database->smdb_impl;

	return db1->smdb1_lock_fd;
}


int
a201 6
	DBT dbkey, dbdata;

	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;
d203 1
a203 1
	result = db->get(db, &dbkey, &dbdata, flags);
a209 2
	data->data = dbdata.data;
	data->size = dbdata.size;
a220 1
	DBT dbkey, dbdata;
d222 2
a223 9
	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;
	dbdata.data = data->data;
	dbdata.size = data->size;

	return db->put(db, &dbkey, &dbdata,
		       smdb_put_flags_to_db1_flags(flags));
a298 4
	DBT dbkey, dbdata;

	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
d301 1
a301 1
	result = db->seq(db, &dbkey, &dbdata, db1_flags);
a305 4
	value->data = dbdata.data;
	value->size = dbdata.size;
	key->data = dbkey.data;
	key->size = dbkey.size;
a318 8
	DBT dbkey, dbdata;

	memset(&dbdata, '\0', sizeof dbdata);
	memset(&dbkey, '\0', sizeof dbkey);
	dbkey.data = key->data;
	dbkey.size = key->size;
	dbdata.data = value->data;
	dbdata.size = value->size;
d320 1
a320 1
	return db->put(db, &dbkey, &dbdata, R_CURSOR);
d387 1
a387 1
	long sff;
a481 1
		smdb_db->smdb_lockfd = smdb1_lockfd;
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
** Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d10 3
a12 2
#include <sm/gen.h>
SM_RCSID("@@(#)$Sendmail: smdb1.c,v 8.51 2001/05/10 01:23:58 ca Exp $")
d67 2
d83 1
a83 1
unsigned int
d96 1
a133 4
/*
**  The rest of these functions correspond to the interface laid out in smdb.h.
*/

d144 1
a144 1
		db1->smdb1_cursor_in_use = false;
d150 5
d175 1
a175 1
	unsigned int flags;
d180 1
a180 1
	(void) memset(&dbkey, '\0', sizeof dbkey);
d215 1
a215 1
	unsigned int flags;
d221 2
a222 2
	(void) memset(&dbdata, '\0', sizeof dbdata);
	(void) memset(&dbkey, '\0', sizeof dbkey);
d243 1
a243 1
	unsigned int flags;
d248 2
a249 2
	(void) memset(&dbdata, '\0', sizeof dbdata);
	(void) memset(&dbkey, '\0', sizeof dbkey);
d285 1
a285 1
	unsigned int flags;
d302 1
a302 1
	db1->smdb1_cursor_in_use = false;
d311 1
a311 1
	unsigned int flags;
d334 2
a335 2
	(void) memset(&dbdata, '\0', sizeof dbdata);
	(void) memset(&dbkey, '\0', sizeof dbkey);
d362 2
a363 2
	(void) memset(&dbdata, '\0', sizeof dbdata);
	(void) memset(&dbkey, '\0', sizeof dbkey);
d376 1
a376 1
	unsigned int flags;
d385 1
a385 1
	db1->smdb1_cursor_in_use = true;
d403 1
d491 1
a491 1
		(void) memset(&hash_info, '\0', sizeof hash_info);
d500 1
a500 1
		(void) memset(&btree_info, '\0', sizeof btree_info);
@


