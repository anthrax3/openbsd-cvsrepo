head	1.14;
access;
symbols
	OPENBSD_5_6:1.13.0.6
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.8
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.6
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.4
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.10.0.12
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.10
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.6
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.8
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.4
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.9.0.10
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.8
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.6
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.4
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.6.0.10
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.8
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.13;
commitid	M7i5giHIoz3DMlTU;

1.13
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.11;

1.11
date	2011.05.17.15.54.23;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.14.15.09.28;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.16.00.21.30;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.24.03.59.26;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.15.21.09.05;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.07.19.20.37;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.42;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.42;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.09;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.49;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.30.27;	author miod;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2002, 2004, 2008 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1992 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sm/gen.h>

SM_IDSTR(copyright,
"@@(#) Copyright (c) 1998-2002, 2004 Proofpoint, Inc. and its suppliers.\n\
	All rights reserved.\n\
     Copyright (c) 1992 Eric P. Allman.  All rights reserved.\n\
     Copyright (c) 1992, 1993\n\
	The Regents of the University of California.  All rights reserved.\n")

SM_IDSTR(id, "@@(#)$Sendmail: makemap.c,v 8.183 2013/11/22 20:51:52 ca Exp $")


#include <sys/types.h>
#ifndef ISC_UNIX
# include <sys/file.h>
#endif /* ! ISC_UNIX */
#include <ctype.h>
#include <stdlib.h>
#include <unistd.h>
#ifdef EX_OK
# undef EX_OK		/* unistd.h may have another use for this */
#endif /* EX_OK */
#include <sysexits.h>
#include <sendmail/sendmail.h>
#include <sendmail/pathnames.h>
#include <libsmdb/smdb.h>

uid_t	RealUid;
gid_t	RealGid;
char	*RealUserName;
uid_t	RunAsUid;
gid_t	RunAsGid;
char	*RunAsUserName;
int	Verbose = 2;
bool	DontInitGroups = false;
uid_t	TrustedUid = 0;
BITMAP256 DontBlameSendmail;

#define BUFSIZE		1024
#define ISSEP(c) (sep == '\0' ? isascii(c) && isspace(c) : (c) == sep)

static void usage __P((char *));

static void
usage(progname)
	char *progname;
{
	sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
		      "Usage: %s [-C cffile] [-N] [-c cachesize] [-D commentchar]\n",
		      progname);
	sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
		      "       %*s [-d] [-e] [-f] [-l] [-o] [-r] [-s] [-t delimiter]\n",
		      (int) strlen(progname), "");
	sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
		      "       %*s [-u] [-v] type mapname\n",
		      (int) strlen(progname), "");
	exit(EX_USAGE);
}

int
main(argc, argv)
	int argc;
	char **argv;
{
	char *progname;
	char *cfile;
	bool inclnull = false;
	bool notrunc = false;
	bool allowreplace = false;
	bool allowempty = false;
	bool verbose = false;
	bool foldcase = true;
	bool unmake = false;
	char sep = '\0';
	char comment = '#';
	int exitstat;
	int opt;
	char *typename = NULL;
	char *mapname = NULL;
	unsigned int lineno;
	int st;
	int mode;
	int smode;
	int putflags = 0;
	long sff = SFF_ROOTOK|SFF_REGONLY;
	struct passwd *pw;
	SMDB_DATABASE *database;
	SMDB_CURSOR *cursor;
	SMDB_DBENT db_key, db_val;
	SMDB_DBPARAMS params;
	SMDB_USER_INFO user_info;
	char ibuf[BUFSIZE];
#if HASFCHOWN
	SM_FILE_T *cfp;
	char buf[MAXLINE];
#endif /* HASFCHOWN */
	static char rnamebuf[MAXNAME];	/* holds RealUserName */
	extern char *optarg;
	extern int optind;

	memset(&params, '\0', sizeof params);
	params.smdbp_cache_size = 1024 * 1024;

	progname = strrchr(argv[0], '/');
	if (progname != NULL)
		progname++;
	else
		progname = argv[0];
	cfile = getcfname(0, 0, SM_GET_SENDMAIL_CF, NULL);

	clrbitmap(DontBlameSendmail);
	RunAsUid = RealUid = getuid();
	RunAsGid = RealGid = getgid();
	pw = getpwuid(RealUid);
	if (pw != NULL)
		(void) sm_strlcpy(rnamebuf, pw->pw_name, sizeof rnamebuf);
	else
		(void) sm_snprintf(rnamebuf, sizeof rnamebuf,
		    "Unknown UID %d", (int) RealUid);
	RunAsUserName = RealUserName = rnamebuf;
	user_info.smdbu_id = RunAsUid;
	user_info.smdbu_group_id = RunAsGid;
	(void) sm_strlcpy(user_info.smdbu_name, RunAsUserName,
		       SMDB_MAX_USER_NAME_LEN);

#define OPTIONS		"C:D:Nc:deflorst:uv"
	while ((opt = getopt(argc, argv, OPTIONS)) != -1)
	{
		switch (opt)
		{
		  case 'C':
			cfile = optarg;
			break;

		  case 'N':
			inclnull = true;
			break;

		  case 'c':
			params.smdbp_cache_size = atol(optarg);
			break;

		  case 'd':
			params.smdbp_allow_dup = true;
			break;

		  case 'e':
			allowempty = true;
			break;

		  case 'f':
			foldcase = false;
			break;

		  case 'D':
			comment = *optarg;
			break;

		  case 'l':
			smdb_print_available_types();
			exit(EX_OK);
			break;

		  case 'o':
			notrunc = true;
			break;

		  case 'r':
			allowreplace = true;
			break;

		  case 's':
			setbitn(DBS_MAPINUNSAFEDIRPATH, DontBlameSendmail);
			setbitn(DBS_WRITEMAPTOHARDLINK, DontBlameSendmail);
			setbitn(DBS_WRITEMAPTOSYMLINK, DontBlameSendmail);
			setbitn(DBS_LINKEDMAPINWRITABLEDIR, DontBlameSendmail);
			break;

		  case 't':
			if (optarg == NULL || *optarg == '\0')
			{
				sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
					      "Invalid separator\n");
				break;
			}
			sep = *optarg;
			break;

		  case 'u':
			unmake = true;
			break;

		  case 'v':
			verbose = true;
			break;

		  default:
			usage(progname);
			/* NOTREACHED */
		}
	}

	if (!bitnset(DBS_WRITEMAPTOSYMLINK, DontBlameSendmail))
		sff |= SFF_NOSLINK;
	if (!bitnset(DBS_WRITEMAPTOHARDLINK, DontBlameSendmail))
		sff |= SFF_NOHLINK;
	if (!bitnset(DBS_LINKEDMAPINWRITABLEDIR, DontBlameSendmail))
		sff |= SFF_NOWLINK;

	argc -= optind;
	argv += optind;
	if (argc != 2)
	{
		usage(progname);
		/* NOTREACHED */
	}
	else
	{
		typename = argv[0];
		mapname = argv[1];
	}

#if HASFCHOWN
	if (!unmake && geteuid() == 0)
	{
		/* Find TrustedUser value in sendmail.cf */
		if ((cfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, cfile,
				      SM_IO_RDONLY, NULL)) == NULL)
		{
			sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				      "makemap: %s: %s\n",
				      cfile, sm_errstring(errno));
			exit(EX_NOINPUT);
		}
		while (sm_io_fgets(cfp, SM_TIME_DEFAULT, buf, sizeof(buf)) >= 0)
		{
			register char *b;

			if ((b = strchr(buf, '\n')) != NULL)
				*b = '\0';

			b = buf;
			switch (*b++)
			{
			  case 'O':		/* option */
				if (strncasecmp(b, " TrustedUser", 12) == 0 &&
				    !(isascii(b[12]) && isalnum(b[12])))
				{
					b = strchr(b, '=');
					if (b == NULL)
						continue;
					while (isascii(*++b) && isspace(*b))
						continue;
					if (isascii(*b) && isdigit(*b))
						TrustedUid = atoi(b);
					else
					{
						TrustedUid = 0;
						pw = getpwnam(b);
						if (pw == NULL)
							(void) sm_io_fprintf(smioerr,
									     SM_TIME_DEFAULT,
									     "TrustedUser: unknown user %s\n", b);
						else
							TrustedUid = pw->pw_uid;
					}

# ifdef UID_MAX
					if (TrustedUid > UID_MAX)
					{
						(void) sm_io_fprintf(smioerr,
								     SM_TIME_DEFAULT,
								     "TrustedUser: uid value (%ld) > UID_MAX (%ld)",
							(long) TrustedUid,
							(long) UID_MAX);
						TrustedUid = 0;
					}
# endif /* UID_MAX */
					break;
				}


			  default:
				continue;
			}
		}
		(void) sm_io_close(cfp, SM_TIME_DEFAULT);
	}
#endif /* HASFCHOWN */

	if (!params.smdbp_allow_dup && !allowreplace)
		putflags = SMDBF_NO_OVERWRITE;

	if (unmake)
	{
		mode = O_RDONLY;
		smode = S_IRUSR;
	}
	else
	{
		mode = O_RDWR;
		if (!notrunc)
		{
			mode |= O_CREAT|O_TRUNC;
			sff |= SFF_CREAT;
		}
		smode = S_IWUSR;
	}

	params.smdbp_num_elements = 4096;

	errno = smdb_open_database(&database, mapname, mode, smode, sff,
				   typename, &user_info, &params);
	if (errno != SMDBE_OK)
	{
		char *hint;

		if (errno == SMDBE_UNSUPPORTED_DB_TYPE &&
		    (hint = smdb_db_definition(typename)) != NULL)
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
					     "%s: Need to recompile with -D%s for %s support\n",
					     progname, hint, typename);
		else
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
					     "%s: error opening type %s map %s: %s\n",
					     progname, typename, mapname,
					     sm_errstring(errno));
		exit(EX_CANTCREAT);
	}

	(void) database->smdb_sync(database, 0);

	if (!unmake && geteuid() == 0 && TrustedUid != 0)
	{
		errno = database->smdb_set_owner(database, TrustedUid, -1);
		if (errno != SMDBE_OK)
		{
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
					     "WARNING: ownership change on %s failed %s",
					     mapname, sm_errstring(errno));
		}
	}

	/*
	**  Copy the data
	*/

	exitstat = EX_OK;
	if (unmake)
	{
		errno = database->smdb_cursor(database, &cursor, 0);
		if (errno != SMDBE_OK)
		{

			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
					     "%s: cannot make cursor for type %s map %s\n",
					     progname, typename, mapname);
			exit(EX_SOFTWARE);
		}

		memset(&db_key, '\0', sizeof db_key);
		memset(&db_val, '\0', sizeof db_val);

		for (lineno = 0; ; lineno++)
		{
			errno = cursor->smdbc_get(cursor, &db_key, &db_val,
						  SMDB_CURSOR_GET_NEXT);
			if (errno != SMDBE_OK)
				break;

			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "%.*s%c%.*s\n",
					     (int) db_key.size,
					     (char *) db_key.data,
					     (sep != '\0') ? sep : '\t',
					     (int) db_val.size,
					     (char *)db_val.data);

		}
		(void) cursor->smdbc_close(cursor);
	}
	else
	{
		lineno = 0;
		while (sm_io_fgets(smioin, SM_TIME_DEFAULT, ibuf, sizeof ibuf)
		       >= 0)
		{
			register char *p;

			lineno++;

			/*
			**  Parse the line.
			*/

			p = strchr(ibuf, '\n');
			if (p != NULL)
				*p = '\0';
			else if (!sm_io_eof(smioin))
			{
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: %s: line %u: line too long (%ld bytes max)\n",
						     progname, mapname, lineno,
						     (long) sizeof ibuf);
				exitstat = EX_DATAERR;
				continue;
			}

			if (ibuf[0] == '\0' || ibuf[0] == comment)
				continue;
			if (sep == '\0' && isascii(ibuf[0]) && isspace(ibuf[0]))
			{
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: %s: line %u: syntax error (leading space)\n",
						     progname, mapname, lineno);
				exitstat = EX_DATAERR;
				continue;
			}

			memset(&db_key, '\0', sizeof db_key);
			memset(&db_val, '\0', sizeof db_val);
			db_key.data = ibuf;

			for (p = ibuf; *p != '\0' && !(ISSEP(*p)); p++)
			{
				if (foldcase && isascii(*p) && isupper(*p))
					*p = tolower(*p);
			}
			db_key.size = p - ibuf;
			if (inclnull)
				db_key.size++;

			if (*p != '\0')
				*p++ = '\0';
			while (*p != '\0' && ISSEP(*p))
				p++;
			if (!allowempty && *p == '\0')
			{
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: %s: line %u: no RHS for LHS %s\n",
						     progname, mapname, lineno,
						     (char *) db_key.data);
				exitstat = EX_DATAERR;
				continue;
			}

			db_val.data = p;
			db_val.size = strlen(p);
			if (inclnull)
				db_val.size++;

			/*
			**  Do the database insert.
			*/

			if (verbose)
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "key=`%s', val=`%s'\n",
						     (char *) db_key.data,
						     (char *) db_val.data);
			}

			errno = database->smdb_put(database, &db_key, &db_val,
						   putflags);
			switch (errno)
			{
			  case SMDBE_KEY_EXIST:
				st = 1;
				break;

			  case 0:
				st = 0;
				break;

			  default:
				st = -1;
				break;
			}

			if (st < 0)
			{
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: %s: line %u: key %s: put error: %s\n",
						     progname, mapname, lineno,
						     (char *) db_key.data,
						     sm_errstring(errno));
				exitstat = EX_IOERR;
			}
			else if (st > 0)
			{
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: %s: line %u: key %s: duplicate key\n",
						     progname, mapname,
						     lineno,
						     (char *) db_key.data);
				exitstat = EX_DATAERR;
			}
		}
	}

	/*
	**  Now close the database.
	*/

	errno = database->smdb_close(database);
	if (errno != SMDBE_OK)
	{
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				     "%s: close(%s): %s\n",
				     progname, mapname, sm_errstring(errno));
		exitstat = EX_IOERR;
	}
	smdb_free_database(database);

	exit(exitstat);

	/* NOTREACHED */
	return exitstat;
}
@


1.13
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.12
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002, 2004, 2008 Sendmail, Inc. and its suppliers.
d17 1
a17 1
"@@(#) Copyright (c) 1998-2002, 2004 Sendmail, Inc. and its suppliers.\n\
d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: makemap.c,v 8.181 2013/03/12 15:24:51 ca Exp $")
d237 1
a237 3
	/* Find TrustedUser value in sendmail.cf */
	if ((cfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, cfile, SM_IO_RDONLY,
			      NULL)) == NULL)
d239 12
a250 7
		sm_io_fprintf(smioerr, SM_TIME_DEFAULT, "makemap: %s: %s\n",
			      cfile, sm_errstring(errno));
		exit(EX_NOINPUT);
	}
	while (sm_io_fgets(cfp, SM_TIME_DEFAULT, buf, sizeof(buf)) >= 0)
	{
		register char *b;
d252 2
a253 2
		if ((b = strchr(buf, '\n')) != NULL)
			*b = '\0';
d255 2
a256 6
		b = buf;
		switch (*b++)
		{
		  case 'O':		/* option */
			if (strncasecmp(b, " TrustedUser", 12) == 0 &&
			    !(isascii(b[12]) && isalnum(b[12])))
d258 3
a260 8
				b = strchr(b, '=');
				if (b == NULL)
					continue;
				while (isascii(*++b) && isspace(*b))
					continue;
				if (isascii(*b) && isdigit(*b))
					TrustedUid = atoi(b);
				else
d262 7
a268 6
					TrustedUid = 0;
					pw = getpwnam(b);
					if (pw == NULL)
						(void) sm_io_fprintf(smioerr,
								     SM_TIME_DEFAULT,
								     "TrustedUser: unknown user %s\n", b);
d270 10
a279 2
						TrustedUid = pw->pw_uid;
				}
d282 11
a292 8
				if (TrustedUid > UID_MAX)
				{
					(void) sm_io_fprintf(smioerr,
							     SM_TIME_DEFAULT,
							     "TrustedUser: uid value (%ld) > UID_MAX (%ld)",
						(long) TrustedUid,
						(long) UID_MAX);
					TrustedUid = 0;
a293 3
# endif /* UID_MAX */
				break;
			}
d296 3
a298 2
		  default:
			continue;
d300 1
a301 1
	(void) sm_io_close(cfp, SM_TIME_DEFAULT);
@


1.11
log
@Update to sendmail 8.14.5
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: makemap.c,v 8.180 2010/11/23 02:35:08 gshapiro Exp $")
d245 1
a245 1
	while (sm_io_fgets(cfp, SM_TIME_DEFAULT, buf, sizeof(buf)) != NULL)
d395 1
a395 1
		       != NULL)
@


1.10
log
@Update to sendmail-8.14.3
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: makemap.c,v 8.179 2008/04/14 02:06:16 ca Exp $")
d241 1
a241 1
		sm_io_fprintf(smioerr, SM_TIME_DEFAULT, "makemap: %s: %s",
@


1.9
log
@Tab was hard-coded as delimeter for undump even though it can be
specified with -t.  Problem found (and slightly different diff)
by robert@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002, 2004 Sendmail, Inc. and its suppliers.
d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: makemap.c,v 8.177 2004/08/03 23:57:24 ca Exp $")
d45 1
a45 1
uid_t	RunAsGid;
d384 1
a384 1
					     sep ? sep : '\t',
@


1.8
log
@Update to sendmail-8.13.2
@
text
@d381 1
a381 1
					     "%.*s\t%.*s\n",
d384 1
@


1.7
log
@Update to sendmail.8.13.0
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d17 1
a17 1
"@@(#) Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.\n\
d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: makemap.c,v 8.176 2002/06/27 23:41:04 gshapiro Exp $")
d54 2
@


1.6
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: makemap.c,v 8.175 2001/12/28 22:44:01 ca Exp $")
a58 1
	/* XXX break the usage output into multiple lines? it's too long */
d60 8
a67 5
		"Usage: %s [-C cffile] [-N] [-c cachesize] [-d] [-e] [-f] [-l] [-o] [-r] [-s] [-t delimiter] [-u] [-v] type mapname\n",
		progname);
#if _FFR_COMMENT_CHAR
	/* add -D comment-char */
#endif /* _FFR_COMMENT_CHAR */
a165 1
#if _FFR_COMMENT_CHAR
a168 1
#endif /* _FFR_COMMENT_CHAR */
@


1.5
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: makemap.c,v 8.173 2001/09/26 22:18:21 ca Exp $")
d59 1
d63 3
d84 1
d135 1
a135 2

#define OPTIONS		"C:Nc:t:deflorsuv"
d164 6
d415 1
a415 1
			if (ibuf[0] == '\0' || ibuf[0] == '#')
@


1.4
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: makemap.c,v 8.170 2001/08/28 23:07:04 gshapiro Exp $")
d53 1
a53 1
#define ISSEP(c) ((sep == '\0' && isascii(c) && isspace(c)) || (c) == sep)
d431 1
a431 1
			while (ISSEP(*p))
d513 1
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d14 4
a17 3
#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.\n\
d21 1
a21 2
	The Regents of the University of California.  All rights reserved.\n";
#endif /* ! lint */
d23 1
a23 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: makemap.c,v 8.135.4.13 2000/10/05 23:00:50 gshapiro Exp $";
#endif /* ! lint */
d48 1
a48 1
bool	DontInitGroups = FALSE;
d53 1
a53 6
#if _FFR_DELIM
# define ISSEP(c) ((sep == '\0' && isascii(c) && isspace(c)) || (c) == sep)
#else /* _FFR_DELIM */
# define ISSEP(c) (isascii(c) && isspace(c))
#endif /* _FFR_DELIM */

d59 3
a61 9
	fprintf(stderr,
		"Usage: %s [-C cffile] [-N] [-c cachesize] [-d] [-e] [-f] [-l] [-o] [-r] [-s] %s[-u] [-v] type mapname\n",
		progname,
#if _FFR_DELIM
		"[-t  delimiter] "
#else /* _FFR_DELIM */
		""
#endif /* _FFR_DELIM */
		);
d72 7
a78 8
	bool inclnull = FALSE;
	bool notrunc = FALSE;
	bool allowreplace = FALSE;
	bool allowempty = FALSE;
	bool verbose = FALSE;
	bool foldcase = TRUE;
	bool unmake = FALSE;
#if _FFR_DELIM
a79 1
#endif /* _FFR_DELIM */
d84 1
a84 1
	int lineno;
d98 1
a98 1
	FILE *cfp;
d113 1
a113 1
	cfile = _PATH_SENDMAILCF;
d120 1
a120 1
		(void) strlcpy(rnamebuf, pw->pw_name, sizeof rnamebuf);
d122 2
a123 2
		(void) snprintf(rnamebuf, sizeof rnamebuf, "Unknown UID %d",
				(int) RealUid);
d127 1
a127 1
	(void) strlcpy(user_info.smdbu_name, RunAsUserName,
d141 1
a141 1
			inclnull = TRUE;
d149 1
a149 1
			params.smdbp_allow_dup = TRUE;
d153 1
a153 1
			allowempty = TRUE;
d157 1
a157 1
			foldcase = FALSE;
d166 1
a166 1
			notrunc = TRUE;
d170 1
a170 1
			allowreplace = TRUE;
a179 1
#if _FFR_DELIM
d183 2
a184 1
				fprintf(stderr, "Invalid separator\n");
a188 1
#endif /* _FFR_DELIM */
d191 1
a191 1
			unmake = TRUE;
d195 1
a195 1
			verbose = TRUE;
d226 2
a227 1
	if ((cfp = fopen(cfile, "r")) == NULL)
d229 2
a230 1
		fprintf(stderr, "makemap: %s: %s", cfile, errstring(errno));
d233 1
a233 1
	while (fgets(buf, sizeof(buf), cfp) != NULL)
d259 3
a261 2
						fprintf(stderr,
							"TrustedUser: unknown user %s\n", b);
d269 3
a271 2
					fprintf(stderr,
						"TrustedUser: uid value (%ld) > UID_MAX (%ld)",
d285 1
a285 1
	(void) fclose(cfp);
d317 3
a319 3
			fprintf(stderr,
				"%s: Need to recompile with -D%s for %s support\n",
				progname, hint, typename);
d321 4
a324 3
			fprintf(stderr,
				"%s: error opening type %s map %s: %s\n",
				progname, typename, mapname, errstring(errno));
d335 3
a337 3
			fprintf(stderr,
				"WARNING: ownership change on %s failed %s",
				mapname, errstring(errno));
d352 3
a354 3
			fprintf(stderr,
				"%s: cannot make cursor for type %s map %s\n",
				progname, typename, mapname);
d368 6
a373 5
			printf("%.*s\t%.*s\n",
			       (int) db_key.size,
			       (char *) db_key.data,
			       (int) db_val.size,
			       (char *)db_val.data);
d381 2
a382 1
		while (fgets(ibuf, sizeof ibuf, stdin) != NULL)
d395 1
a395 1
			else if (!feof(stdin))
d397 4
a400 3
				fprintf(stderr,
					"%s: %s: line %d: line too long (%ld bytes max)\n",
					progname, mapname, lineno, (long) sizeof ibuf);
d407 1
a407 5
			if (
#if _FFR_DELIM
			    sep == '\0' &&
#endif /* _FFR_DELIM */
			    isascii(ibuf[0]) && isspace(ibuf[0]))
d409 3
a411 3
				fprintf(stderr,
					"%s: %s: line %d: syntax error (leading space)\n",
					progname, mapname, lineno);
d435 4
a438 4
				fprintf(stderr,
					"%s: %s: line %d: no RHS for LHS %s\n",
					progname, mapname, lineno,
					(char *) db_key.data);
d454 4
a457 3
				printf("key=`%s', val=`%s'\n",
				       (char *) db_key.data,
				       (char *) db_val.data);
d479 5
a483 5
				fprintf(stderr,
					"%s: %s: line %d: key %s: put error: %s\n",
					progname, mapname, lineno,
					(char *) db_key.data,
					errstring(errno));
d488 5
a492 4
				fprintf(stderr,
					"%s: %s: line %d: key %s: duplicate key\n",
					progname, mapname,
					lineno, (char *) db_key.data);
d505 3
a507 2
		fprintf(stderr, "%s: close(%s): %s\n",
			progname, mapname, errstring(errno));
a514 48
}

/*VARARGS1*/
void
#ifdef __STDC__
message(const char *msg, ...)
#else /* __STDC__ */
message(msg, va_alist)
	const char *msg;
	va_dcl
#endif /* __STDC__ */
{
	const char *m;
	VA_LOCAL_DECL

	m = msg;
	if (isascii(m[0]) && isdigit(m[0]) &&
	    isascii(m[1]) && isdigit(m[1]) &&
	    isascii(m[2]) && isdigit(m[2]) && m[3] == ' ')
		m += 4;
	VA_START(msg);
	(void) vfprintf(stderr, m, ap);
	VA_END;
	(void) fprintf(stderr, "\n");
}

/*VARARGS1*/
void
#ifdef __STDC__
syserr(const char *msg, ...)
#else /* __STDC__ */
syserr(msg, va_alist)
	const char *msg;
	va_dcl
#endif /* __STDC__ */
{
	const char *m;
	VA_LOCAL_DECL

	m = msg;
	if (isascii(m[0]) && isdigit(m[0]) &&
	    isascii(m[1]) && isdigit(m[1]) &&
	    isascii(m[2]) && isdigit(m[2]) && m[3] == ' ')
		m += 4;
	VA_START(msg);
	(void) vfprintf(stderr, m, ap);
	VA_END;
	(void) fprintf(stderr, "\n");
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d24 1
a24 1
static char id[] = "@@(#)$Sendmail: makemap.c,v 8.135 2000/04/07 17:05:21 ca Exp $";
d27 1
d61 1
d137 2
a138 2
		snprintf(rnamebuf, sizeof rnamebuf,
			"Unknown UID %d", (int) RealUid);
d147 1
a147 1
	while ((opt = getopt(argc, argv, OPTIONS)) != EOF)
d341 1
a341 1
	if (geteuid() == 0 && TrustedUid != 0)
a358 1
		bool stop;
d372 1
a372 1
		for (stop = FALSE, lineno = 0; !stop; lineno++)
d377 7
a383 9
			{
				stop = TRUE;
			}
			if (!stop)
				printf("%.*s\t%.*s\n",
				       (int) db_key.data.size,
				       (char *) db_key.data.data,
				       (int) db_val.data.size,
				       (char *)db_val.data.data);
d430 1
a430 1
			db_key.data.data = ibuf;
d437 1
a437 1
			db_key.data.size = p - ibuf;
d439 1
a439 1
				db_key.data.size++;
d450 1
a450 1
					(char *) db_key.data.data);
d455 2
a456 2
			db_val.data.data = p;
			db_val.data.size = strlen(p);
d458 1
a458 1
				db_val.data.size++;
d467 2
a468 2
				       (char *) db_key.data.data,
				       (char *) db_val.data.data);
d493 1
a493 1
					(char *) db_key.data.data,
d502 1
a502 1
					lineno, (char *) db_key.data.data);
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d24 1
a24 1
static char id[] = "@@(#)$Sendmail: makemap.c,v 8.135.4.13 2000/10/05 23:00:50 gshapiro Exp $";
a26 1

a59 1

d135 2
a136 2
		(void) snprintf(rnamebuf, sizeof rnamebuf, "Unknown UID %d",
				(int) RealUid);
d145 1
a145 1
	while ((opt = getopt(argc, argv, OPTIONS)) != -1)
d339 1
a339 1
	if (!unmake && geteuid() == 0 && TrustedUid != 0)
d357 1
d371 1
a371 1
		for (lineno = 0; ; lineno++)
d376 9
a384 7
				break;

			printf("%.*s\t%.*s\n",
			       (int) db_key.size,
			       (char *) db_key.data,
			       (int) db_val.size,
			       (char *)db_val.data);
d431 1
a431 1
			db_key.data = ibuf;
d438 1
a438 1
			db_key.size = p - ibuf;
d440 1
a440 1
				db_key.size++;
d451 1
a451 1
					(char *) db_key.data);
d456 2
a457 2
			db_val.data = p;
			db_val.size = strlen(p);
d459 1
a459 1
				db_val.size++;
d468 2
a469 2
				       (char *) db_key.data,
				       (char *) db_val.data);
d494 1
a494 1
					(char *) db_key.data,
d503 1
a503 1
					lineno, (char *) db_key.data);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1998, 1999 Sendmail, Inc. and its suppliers.
d16 1
a16 1
"@@(#) Copyright (c) 1998, 1999 Sendmail, Inc. and its suppliers.\n\
d24 1
a24 1
static char id[] = "@@(#)$Sendmail: makemap.c,v 8.132 1999/12/28 17:10:34 gshapiro Exp $";
d66 1
d68 1
a68 1
		"[-t  delimiter] ",
d70 1
a70 1
		"",
d72 1
a72 1
		progname);
d102 1
a102 1
	int sff = SFF_ROOTOK|SFF_REGONLY;
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d16 1
a16 1
"@@(#) Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.\n\
d24 1
a24 1
static char id[] = "@@(#)$Id: makemap.c,v 8.135.4.13 2000/10/05 23:00:50 gshapiro Exp $";
a26 1

a59 1

a65 1
		progname,
d67 1
a67 1
		"[-t  delimiter] "
d69 1
a69 1
		""
d71 1
a71 1
		);
d101 1
a101 1
	long sff = SFF_ROOTOK|SFF_REGONLY;
d134 2
a135 2
		(void) snprintf(rnamebuf, sizeof rnamebuf, "Unknown UID %d",
				(int) RealUid);
d144 1
a144 1
	while ((opt = getopt(argc, argv, OPTIONS)) != -1)
d338 1
a338 1
	if (!unmake && geteuid() == 0 && TrustedUid != 0)
d356 1
d370 1
a370 1
		for (lineno = 0; ; lineno++)
d375 9
a383 7
				break;

			printf("%.*s\t%.*s\n",
			       (int) db_key.size,
			       (char *) db_key.data,
			       (int) db_val.size,
			       (char *)db_val.data);
d430 1
a430 1
			db_key.data = ibuf;
d437 1
a437 1
			db_key.size = p - ibuf;
d439 1
a439 1
				db_key.size++;
d450 1
a450 1
					(char *) db_key.data);
d455 2
a456 2
			db_val.data = p;
			db_val.size = strlen(p);
d458 1
a458 1
				db_val.size++;
d467 2
a468 2
				       (char *) db_key.data,
				       (char *) db_val.data);
d493 1
a493 1
					(char *) db_key.data,
d502 1
a502 1
					lineno, (char *) db_key.data);
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d14 3
a16 4
#include <sm/gen.h>

SM_IDSTR(copyright,
"@@(#) Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.\n\
d20 2
a21 1
	The Regents of the University of California.  All rights reserved.\n")
d23 3
a25 1
SM_IDSTR(id, "@@(#)$Sendmail: makemap.c,v 8.170 2001/08/28 23:07:04 gshapiro Exp $")
d50 1
a50 1
bool	DontInitGroups = false;
d55 6
a60 1
#define ISSEP(c) ((sep == '\0' && isascii(c) && isspace(c)) || (c) == sep)
d66 9
a74 3
	sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
		"Usage: %s [-C cffile] [-N] [-c cachesize] [-d] [-e] [-f] [-l] [-o] [-r] [-s] [-t delimiter] [-u] [-v] type mapname\n",
		progname);
d85 8
a92 7
	bool inclnull = false;
	bool notrunc = false;
	bool allowreplace = false;
	bool allowempty = false;
	bool verbose = false;
	bool foldcase = true;
	bool unmake = false;
d94 1
d99 1
a99 1
	unsigned int lineno;
d113 1
a113 1
	SM_FILE_T *cfp;
d128 1
a128 1
	cfile = getcfname(0, 0, SM_GET_SENDMAIL_CF, NULL);
d135 1
a135 1
		(void) sm_strlcpy(rnamebuf, pw->pw_name, sizeof rnamebuf);
d137 2
a138 2
		(void) sm_snprintf(rnamebuf, sizeof rnamebuf,
		    "Unknown UID %d", (int) RealUid);
d142 1
a142 1
	(void) sm_strlcpy(user_info.smdbu_name, RunAsUserName,
d156 1
a156 1
			inclnull = true;
d164 1
a164 1
			params.smdbp_allow_dup = true;
d168 1
a168 1
			allowempty = true;
d172 1
a172 1
			foldcase = false;
d181 1
a181 1
			notrunc = true;
d185 1
a185 1
			allowreplace = true;
d195 1
d199 1
a199 2
				sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
					      "Invalid separator\n");
d204 1
d207 1
a207 1
			unmake = true;
d211 1
a211 1
			verbose = true;
d242 1
a242 2
	if ((cfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, cfile, SM_IO_RDONLY,
			      NULL)) == NULL)
d244 1
a244 2
		sm_io_fprintf(smioerr, SM_TIME_DEFAULT, "makemap: %s: %s",
			      cfile, sm_errstring(errno));
d247 1
a247 1
	while (sm_io_fgets(cfp, SM_TIME_DEFAULT, buf, sizeof(buf)) != NULL)
d273 2
a274 3
						(void) sm_io_fprintf(smioerr,
								     SM_TIME_DEFAULT,
								     "TrustedUser: unknown user %s\n", b);
d282 2
a283 3
					(void) sm_io_fprintf(smioerr,
							     SM_TIME_DEFAULT,
							     "TrustedUser: uid value (%ld) > UID_MAX (%ld)",
d297 1
a297 1
	(void) sm_io_close(cfp, SM_TIME_DEFAULT);
d329 3
a331 3
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
					     "%s: Need to recompile with -D%s for %s support\n",
					     progname, hint, typename);
d333 3
a335 4
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
					     "%s: error opening type %s map %s: %s\n",
					     progname, typename, mapname,
					     sm_errstring(errno));
d346 3
a348 3
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
					     "WARNING: ownership change on %s failed %s",
					     mapname, sm_errstring(errno));
d363 3
a365 3
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
					     "%s: cannot make cursor for type %s map %s\n",
					     progname, typename, mapname);
d379 5
a383 6
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "%.*s\t%.*s\n",
					     (int) db_key.size,
					     (char *) db_key.data,
					     (int) db_val.size,
					     (char *)db_val.data);
d391 1
a391 2
		while (sm_io_fgets(smioin, SM_TIME_DEFAULT, ibuf, sizeof ibuf)
		       != NULL)
d404 1
a404 1
			else if (!sm_io_eof(smioin))
d406 3
a408 4
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: %s: line %u: line too long (%ld bytes max)\n",
						     progname, mapname, lineno,
						     (long) sizeof ibuf);
d415 5
a419 1
			if (sep == '\0' && isascii(ibuf[0]) && isspace(ibuf[0]))
d421 3
a423 3
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: %s: line %u: syntax error (leading space)\n",
						     progname, mapname, lineno);
d447 4
a450 4
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: %s: line %u: no RHS for LHS %s\n",
						     progname, mapname, lineno,
						     (char *) db_key.data);
d466 3
a468 4
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "key=`%s', val=`%s'\n",
						     (char *) db_key.data,
						     (char *) db_val.data);
d490 5
a494 5
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: %s: line %u: key %s: put error: %s\n",
						     progname, mapname, lineno,
						     (char *) db_key.data,
						     sm_errstring(errno));
d499 4
a502 5
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: %s: line %u: key %s: duplicate key\n",
						     progname, mapname,
						     lineno,
						     (char *) db_key.data);
d515 2
a516 3
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				     "%s: close(%s): %s\n",
				     progname, mapname, sm_errstring(errno));
d524 48
@


