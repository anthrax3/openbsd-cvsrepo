head	1.4;
access;
symbols
	OPENBSD_5_6:1.3.0.6
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.2.0.50
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.48
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.46
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.44
	OPENBSD_5_0:1.2.0.42
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.40
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.38
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.34
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.36
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.32
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.30
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.28
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.26
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.24
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.22
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.20
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.18
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.16
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.14
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.12
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.8
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.10
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.6
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.4
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	SENDMAIL_8_12_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.4
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.3;
commitid	M7i5giHIoz3DMlTU;

1.3
date	2014.02.07.21.24.59;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.11.18.55.51;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.09.11.18.55.51;	author millert;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Bye.
@
text
@/*
 * Copyright (c) 2001 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 */

#include <sm/gen.h>
SM_RCSID("@@(#)$Sendmail: niprop.c,v 1.9 2013/11/22 20:51:43 ca Exp $")

#if NETINFO
#include <ctype.h>
#include <stdlib.h>
#include <sm/io.h>
#include <sm/assert.h>
#include <sm/debug.h>
#include <sm/string.h>
#include <sm/varargs.h>
#include <sm/heap.h>

/*
**  NI_PROPVAL -- NetInfo property value lookup routine
**
**	Parameters:
**		keydir -- the NetInfo directory name in which to search
**			for the key.
**		keyprop -- the name of the property in which to find the
**			property we are interested.  Defaults to "name".
**		keyval -- the value for which we are really searching.
**		valprop -- the property name for the value in which we
**			are interested.
**		sepchar -- if non-nil, this can be multiple-valued, and
**			we should return a string separated by this
**			character.
**
**	Returns:
**		NULL -- if:
**			1. the directory is not found
**			2. the property name is not found
**			3. the property contains multiple values
**			4. some error occurred
**		else -- the value of the lookup.
**
**	Example:
**		To search for an alias value, use:
**		  ni_propval("/aliases", "name", aliasname, "members", ',')
**
**	Notes:
**		Caller should free the return value of ni_proval
*/

# include <netinfo/ni.h>

# define LOCAL_NETINFO_DOMAIN	"."
# define PARENT_NETINFO_DOMAIN	".."
# define MAX_NI_LEVELS		256

char *
ni_propval(keydir, keyprop, keyval, valprop, sepchar)
	char *keydir;
	char *keyprop;
	char *keyval;
	char *valprop;
	int sepchar;
{
	char *propval = NULL;
	int i;
	int j, alen, l;
	void *ni = NULL;
	void *lastni = NULL;
	ni_status nis;
	ni_id nid;
	ni_namelist ninl;
	register char *p;
	char keybuf[1024];

	/*
	**  Create the full key from the two parts.
	**
	**	Note that directory can end with, e.g., "name=" to specify
	**	an alternate search property.
	*/

	i = strlen(keydir) + strlen(keyval) + 2;
	if (keyprop != NULL)
		i += strlen(keyprop) + 1;
	if (i >= sizeof keybuf)
		return NULL;
	(void) sm_strlcpyn(keybuf, sizeof keybuf, 2, keydir, "/");
	if (keyprop != NULL)
	{
		(void) sm_strlcat2(keybuf, keyprop, "=", sizeof keybuf);
	}
	(void) sm_strlcat(keybuf, keyval, sizeof keybuf);

#if 0
	if (tTd(38, 21))
		sm_dprintf("ni_propval(%s, %s, %s, %s, %d) keybuf='%s'\n",
			keydir, keyprop, keyval, valprop, sepchar, keybuf);
#endif /* 0 */

	/*
	**  If the passed directory and property name are found
	**  in one of netinfo domains we need to search (starting
	**  from the local domain moving all the way back to the
	**  root domain) set propval to the property's value
	**  and return it.
	*/

	for (i = 0; i < MAX_NI_LEVELS && propval == NULL; i++)
	{
		if (i == 0)
		{
			nis = ni_open(NULL, LOCAL_NETINFO_DOMAIN, &ni);
#if 0
			if (tTd(38, 20))
				sm_dprintf("ni_open(LOCAL) = %d\n", nis);
#endif /* 0 */
		}
		else
		{
			if (lastni != NULL)
				ni_free(lastni);
			lastni = ni;
			nis = ni_open(lastni, PARENT_NETINFO_DOMAIN, &ni);
#if 0
			if (tTd(38, 20))
				sm_dprintf("ni_open(PARENT) = %d\n", nis);
#endif /* 0 */
		}

		/*
		**  Don't bother if we didn't get a handle on a
		**  proper domain.  This is not necessarily an error.
		**  We would get a positive ni_status if, for instance
		**  we never found the directory or property and tried
		**  to open the parent of the root domain!
		*/

		if (nis != 0)
			break;

		/*
		**  Find the path to the server information.
		*/

		if (ni_pathsearch(ni, &nid, keybuf) != 0)
			continue;

		/*
		**  Find associated value information.
		*/

		if (ni_lookupprop(ni, &nid, valprop, &ninl) != 0)
			continue;

#if 0
		if (tTd(38, 20))
			sm_dprintf("ni_lookupprop: len=%d\n",
				ninl.ni_namelist_len);
#endif /* 0 */

		/*
		**  See if we have an acceptable number of values.
		*/

		if (ninl.ni_namelist_len <= 0)
			continue;

		if (sepchar == '\0' && ninl.ni_namelist_len > 1)
		{
			ni_namelist_free(&ninl);
			continue;
		}

		/*
		**  Calculate number of bytes needed and build result
		*/

		alen = 1;
		for (j = 0; j < ninl.ni_namelist_len; j++)
			alen += strlen(ninl.ni_namelist_val[j]) + 1;
		propval = p = sm_malloc(alen);
		if (propval == NULL)
			goto cleanup;
		for (j = 0; j < ninl.ni_namelist_len; j++)
		{
			(void) sm_strlcpy(p, ninl.ni_namelist_val[j], alen);
			l = strlen(p);
			p += l;
			*p++ = sepchar;
			alen -= l + 1;
		}
		*--p = '\0';

		ni_namelist_free(&ninl);
	}

  cleanup:
	if (ni != NULL)
		ni_free(ni);
	if (lastni != NULL && ni != lastni)
		ni_free(lastni);
#if 0
	if (tTd(38, 20))
		sm_dprintf("ni_propval returns: '%s'\n", propval);
#endif /* 0 */

	return propval;
}
#endif /* NETINFO */
@


1.3
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.2
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d2 1
a2 1
 * Copyright (c) 2001 Sendmail, Inc. and its suppliers.
d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: niprop.c,v 1.8 2001/09/11 04:04:48 gshapiro Exp $")
@


1.1
log
@Initial revision
@
text
@d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: niprop.c,v 1.6 2001/09/04 22:41:27 ca Exp $")
@


1.1.1.1
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@@
