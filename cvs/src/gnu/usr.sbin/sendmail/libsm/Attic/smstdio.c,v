head	1.8;
access;
symbols
	OPENBSD_5_6:1.7.0.6
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.6.0.36
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.34
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.32
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.3.0.4
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.2.0.4
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	SENDMAIL_8_12_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.8
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.7;
commitid	M7i5giHIoz3DMlTU;

1.7
date	2014.02.07.21.24.59;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.16.00.21.30;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.24.03.59.26;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.17.17.31.40;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.18.00.49.27;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.11.18.55.51;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.09.11.18.55.51;	author millert;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Bye.
@
text
@/*
 * Copyright (c) 2000-2002, 2004 Proofpoint, Inc. and its suppliers.
 *      All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 */

#include <sm/gen.h>
SM_IDSTR(id, "@@(#)$Sendmail: smstdio.c,v 1.35 2013/11/22 20:51:43 ca Exp $")
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/stat.h>
#include <sm/assert.h>
#include <sm/io.h>
#include <sm/string.h>
#include "local.h"

static void	setup __P((SM_FILE_T *));

/*
** Overall:
**	This is a file type which implements a layer on top of the system
**	stdio. fp->f_cookie is the FILE* of stdio. The cookie may be
**	"bound late" because of the manner which Linux implements stdio.
**	When binding late  (when fp->f_cookie==NULL) then the value of
**	fp->f_ival is used (0, 1 or 2) to map to stdio's stdin, stdout or
**	stderr.
*/

/*
**  SM_STDIOOPEN -- open a file to system stdio implementation
**
**	Parameters:
**		fp -- file pointer assign for this open
**		info -- info about file to open
**		flags -- indicating method of opening
**		rpool -- ignored
**
**	Returns:
**		Failure: -1
**		Success: 0 (zero)
*/

/* ARGSUSED3 */
int
sm_stdioopen(fp, info, flags, rpool)
	SM_FILE_T *fp;
	const void *info;
	int flags;
	const void *rpool;
{
	register FILE *s;
	char *stdiomode;

	switch (flags)
	{
	  case SM_IO_RDONLY:
		stdiomode = "r";
		break;
	  case SM_IO_WRONLY:
		stdiomode = "w";
		break;
	  case SM_IO_APPEND:
		stdiomode = "a";
		break;
	  case SM_IO_APPENDRW:
		stdiomode = "a+";
		break;
#if SM_IO_BINARY != 0
	  case SM_IO_RDONLY_B:
		stdiomode = "rb";
		break;
	  case SM_IO_WRONLY_B:
		stdiomode = "wb";
		break;
	  case SM_IO_APPEND_B:
		stdiomode = "ab";
		break;
	  case SM_IO_APPENDRW_B:
		stdiomode = "a+b";
		break;
	  case SM_IO_RDWR_B:
		stdiomode = "r+b";
		break;
#endif /* SM_IO_BINARY != 0 */
	  case SM_IO_RDWR:
	  default:
		stdiomode = "r+";
		break;
	}

	if ((s = fopen((char *)info, stdiomode)) == NULL)
		return -1;
	fp->f_cookie = s;
	return 0;
}

/*
**  SETUP -- assign file type cookie when not already assigned
**
**	Parameters:
**		fp - the file pointer to get the cookie assigned
**
**	Return:
**		none.
*/

static void
setup(fp)
	SM_FILE_T *fp;
{
	if (fp->f_cookie == NULL)
	{
		switch (fp->f_ival)
		{
		  case 0:
			fp->f_cookie = stdin;
			break;
		  case 1:
			fp->f_cookie = stdout;
			break;
		  case 2:
			fp->f_cookie = stderr;
			break;
		  default:
			sm_abort("fp->f_ival=%d: out of range (0...2)", fp->f_ival);
			break;
		}
	}
}

/*
**  SM_STDIOREAD -- read from the file
**
**	Parameters:
**		fp -- the file pointer
**		buf -- location to place the read data
**		n - number of bytes to read
**
**	Returns:
**		result from fread().
*/

ssize_t
sm_stdioread(fp, buf, n)
	SM_FILE_T *fp;
	char *buf;
	size_t n;
{
	register FILE *s;

	if (fp->f_cookie == NULL)
		setup(fp);
	s = fp->f_cookie;
	return fread(buf, 1, n, s);
}

/*
**  SM_STDIOWRITE -- write to the file
**
**	Parameters:
**		fp -- the file pointer
**		buf -- location of data to write
**		n - number of bytes to write
**
**	Returns:
**		result from fwrite().
*/

ssize_t
sm_stdiowrite(fp, buf, n)
	SM_FILE_T *fp;
	char const *buf;
	size_t n;
{
	register FILE *s;

	if (fp->f_cookie == NULL)
		setup(fp);
	s = fp->f_cookie;
	return fwrite(buf, 1, n, s);
}

/*
**  SM_STDIOSEEK -- set position within file
**
**	Parameters:
**		fp -- the file pointer
**		offset -- new location based on 'whence'
**		whence -- indicates "base" for 'offset'
**
**	Returns:
**		result from fseek().
*/

off_t
sm_stdioseek(fp, offset, whence)
	SM_FILE_T *fp;
	off_t offset;
	int whence;
{
	register FILE *s;

	if (fp->f_cookie == NULL)
		setup(fp);
	s = fp->f_cookie;
	return fseek(s, offset, whence);
}

/*
**  SM_STDIOCLOSE -- close the file
**
**	Parameters:
**		fp -- close file pointer
**
**	Return:
**		status from fclose()
*/

int
sm_stdioclose(fp)
	SM_FILE_T *fp;
{
	register FILE *s;

	if (fp->f_cookie == NULL)
		setup(fp);
	s = fp->f_cookie;
	return fclose(s);
}

/*
**  SM_STDIOSETINFO -- set info for this open file
**
**	Parameters:
**		fp -- the file pointer
**		what -- type of information setting
**		valp -- memory location of info to set
**
**	Return:
**		Failure: -1 and sets errno
**		Success: none (currently).
*/

/* ARGSUSED2 */
int
sm_stdiosetinfo(fp, what, valp)
	SM_FILE_T *fp;
	int what;
	void *valp;
{
	switch (what)
	{
	  case SM_IO_WHAT_MODE:
	  default:
		errno = EINVAL;
		return -1;
	}
}

/*
**  SM_STDIOGETINFO -- get info for this open file
**
**	Parameters:
**		fp -- the file pointer
**		what -- type of information request
**		valp -- memory location to place info
**
**	Return:
**		Failure: -1 and sets errno
**		Success: none (currently).
*/

/* ARGSUSED2 */
int
sm_stdiogetinfo(fp, what, valp)
	SM_FILE_T *fp;
	int what;
	void *valp;
{
	switch (what)
	{
	  case SM_IO_WHAT_SIZE:
	  {
		  int fd;
		  struct stat st;

		  if (fp->f_cookie == NULL)
			  setup(fp);
		  fd = fileno((FILE *) fp->f_cookie);
		  if (fd < 0)
			  return -1;
		  if (fstat(fd, &st) == 0)
			  return st.st_size;
		  else
			  return -1;
	  }

	  case SM_IO_WHAT_MODE:
	  default:
		errno = EINVAL;
		return -1;
	}
}

/*
**  SM_IO_STDIOOPEN -- create an SM_FILE which interfaces to a stdio FILE
**
**	Parameters:
**		stream -- an open stdio stream, as returned by fopen()
**		mode -- the mode argument to fopen() which describes stream
**
**	Return:
**		On success, return a pointer to an SM_FILE object which
**		can be used for reading and writing 'stream'.
**		Abort if mode is gibberish or stream is bad.
**		Raise an exception if we can't allocate memory.
*/

SM_FILE_T *
sm_io_stdioopen(stream, mode)
	FILE *stream;
	char *mode;
{
	int fd;
	bool r, w;
	int ioflags;
	SM_FILE_T *fp;

	fd = fileno(stream);
	SM_REQUIRE(fd >= 0);

	r = w = false;
	switch (mode[0])
	{
	  case 'r':
		r = true;
		break;
	  case 'w':
	  case 'a':
		w = true;
		break;
	  default:
		sm_abort("sm_io_stdioopen: mode '%s' is bad", mode);
	}
	if (strchr(&mode[1], '+') != NULL)
		r = w = true;
	if (r && w)
		ioflags = SMRW;
	else if (r)
		ioflags = SMRD;
	else
		ioflags = SMWR;

	fp = sm_fp(SmFtRealStdio, ioflags, NULL);
	fp->f_file = fd;
	fp->f_cookie = stream;
	return fp;
}
@


1.7
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.6
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
 * Copyright (c) 2000-2002, 2004 Sendmail, Inc. and its suppliers.
d11 1
a11 1
SM_IDSTR(id, "@@(#)$Sendmail: smstdio.c,v 1.34 2004/08/03 20:46:34 ca Exp $")
@


1.5
log
@Update to sendmail.8.13.0
@
text
@d11 1
a11 1
SM_IDSTR(id, "@@(#)$Sendmail: smstdio.c,v 1.33 2004/03/03 19:14:51 ca Exp $")
d21 2
@


1.4
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d2 1
a2 1
 * Copyright (c) 2000-2002 Sendmail, Inc. and its suppliers.
d11 1
a11 1
SM_IDSTR(id, "@@(#)$Sendmail: smstdio.c,v 1.32.2.2 2003/09/05 20:35:28 ca Exp $")
@


1.3
log
@update to sendmail 8.12.3
@
text
@d11 1
a11 1
SM_IDSTR(id, "@@(#)$Sendmail: smstdio.c,v 1.32 2002/02/23 20:18:36 gshapiro Exp $")
d71 17
@


1.2
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d2 1
a2 1
 * Copyright (c) 2000-2001 Sendmail, Inc. and its suppliers.
d11 1
a11 1
SM_IDSTR(id, "@@(#)$Sendmail: smstdio.c,v 1.29 2001/09/11 04:04:49 gshapiro Exp $")
d16 1
d268 16
@


1.1
log
@Initial revision
@
text
@d11 1
a11 1
SM_IDSTR(id, "@@(#)$Sendmail: smstdio.c,v 1.27 2001/03/05 03:22:41 ca Exp $")
@


1.1.1.1
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@@
