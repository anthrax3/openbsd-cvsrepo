head	1.13;
access;
symbols
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.30
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.28
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.26
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.24
	OPENBSD_5_0:1.11.0.22
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.20
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.18
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.14
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.16
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.12
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	SENDMAIL_8_12_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.13
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.12;
commitid	M7i5giHIoz3DMlTU;

1.12
date	2014.02.07.21.24.59;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.22.18.43.54;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.16.00.21.30;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.24.03.59.26;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.17.17.31.39;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.29.19.44.00;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.15.02.23.35;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.26.04.48.55;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.18.00.49.27;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.11.18.55.51;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.09.11.18.55.51;	author millert;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2004 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sm/gen.h>
SM_RCSID("@@(#)$Sendmail: clock.c,v 1.48 2013/11/22 20:51:42 ca Exp $")
#include <unistd.h>
#include <time.h>
#include <errno.h>
#if SM_CONF_SETITIMER
# include <sm/time.h>
#endif /* SM_CONF_SETITIMER */
#include <sm/heap.h>
#include <sm/debug.h>
#include <sm/bitops.h>
#include <sm/clock.h>
#include "local.h"
#if _FFR_SLEEP_USE_SELECT > 0
# include <sys/types.h>
#endif /* _FFR_SLEEP_USE_SELECT > 0 */
#if defined(_FFR_MAX_SLEEP_TIME) && _FFR_MAX_SLEEP_TIME > 2
# include <syslog.h>
#endif /* defined(_FFR_MAX_SLEEP_TIME) && _FFR_MAX_SLEEP_TIME > 2 */

#ifndef sigmask
# define sigmask(s)	(1 << ((s) - 1))
#endif /* ! sigmask */


/*
**  SM_SETEVENTM -- set an event to happen at a specific time in milliseconds.
**
**	Events are stored in a sorted list for fast processing.
**	An event only applies to the process that set it.
**	Source is #ifdef'd to work with older OS's that don't have setitimer()
**	(that is, don't have a timer granularity less than 1 second).
**
**	Parameters:
**		intvl -- interval until next event occurs (milliseconds).
**		func -- function to call on event.
**		arg -- argument to func on event.
**
**	Returns:
**		On success returns the SM_EVENT entry created.
**		On failure returns NULL.
**
**	Side Effects:
**		none.
*/

static SM_EVENT	*volatile SmEventQueue;		/* head of event queue */
static SM_EVENT	*volatile SmFreeEventList;	/* list of free events */

SM_EVENT *
sm_seteventm(intvl, func, arg)
	int intvl;
	void (*func)__P((int));
	int arg;
{
	ENTER_CRITICAL();
	if (SmFreeEventList == NULL)
	{
		SmFreeEventList = (SM_EVENT *) sm_pmalloc_x(sizeof *SmFreeEventList);
		SmFreeEventList->ev_link = NULL;
	}
	LEAVE_CRITICAL();

	return sm_sigsafe_seteventm(intvl, func, arg);
}

/*
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

SM_EVENT *
sm_sigsafe_seteventm(intvl, func, arg)
	int intvl;
	void (*func)__P((int));
	int arg;
{
	register SM_EVENT **evp;
	register SM_EVENT *ev;
#if SM_CONF_SETITIMER
	auto struct timeval now, nowi, ival;
	auto struct itimerval itime;
#else /*  SM_CONF_SETITIMER */
	auto time_t now, nowi;
#endif /*  SM_CONF_SETITIMER */
	int wasblocked;

	/* negative times are not allowed */
	if (intvl <= 0)
		return NULL;

	wasblocked = sm_blocksignal(SIGALRM);
#if SM_CONF_SETITIMER
	ival.tv_sec = intvl / 1000;
	ival.tv_usec = (intvl - ival.tv_sec * 1000) * 10;
	(void) gettimeofday(&now, NULL);
	nowi = now;
	timeradd(&now, &ival, &nowi);
#else /*  SM_CONF_SETITIMER */
	now = time(NULL);
	nowi = now + (time_t)(intvl / 1000);
#endif /*  SM_CONF_SETITIMER */

	/* search event queue for correct position */
	for (evp = (SM_EVENT **) (&SmEventQueue);
	     (ev = *evp) != NULL;
	     evp = &ev->ev_link)
	{
#if SM_CONF_SETITIMER
		if (timercmp(&(ev->ev_time), &nowi, >=))
#else /* SM_CONF_SETITIMER */
		if (ev->ev_time >= nowi)
#endif /* SM_CONF_SETITIMER */
			break;
	}

	ENTER_CRITICAL();
	if (SmFreeEventList == NULL)
	{
		/*
		**  This shouldn't happen.  If called from sm_seteventm(),
		**  we have just malloced a SmFreeEventList entry.  If
		**  called from a signal handler, it should have been
		**  from an existing event which sm_tick() just added to
		**  SmFreeEventList.
		*/

		LEAVE_CRITICAL();
		if (wasblocked == 0)
			(void) sm_releasesignal(SIGALRM);
		return NULL;
	}
	else
	{
		ev = SmFreeEventList;
		SmFreeEventList = ev->ev_link;
	}
	LEAVE_CRITICAL();

	/* insert new event */
	ev->ev_time = nowi;
	ev->ev_func = func;
	ev->ev_arg = arg;
	ev->ev_pid = getpid();
	ENTER_CRITICAL();
	ev->ev_link = *evp;
	*evp = ev;
	LEAVE_CRITICAL();

	(void) sm_signal(SIGALRM, sm_tick);
# if SM_CONF_SETITIMER
	timersub(&SmEventQueue->ev_time, &now, &itime.it_value);
	itime.it_interval.tv_sec = 0;
	itime.it_interval.tv_usec = 0;
	if (itime.it_value.tv_sec < 0)
		itime.it_value.tv_sec = 0;
	if (itime.it_value.tv_sec == 0 && itime.it_value.tv_usec == 0)
		itime.it_value.tv_usec = 1000;
	(void) setitimer(ITIMER_REAL, &itime, NULL);
# else /* SM_CONF_SETITIMER */
	intvl = SmEventQueue->ev_time - now;
	(void) alarm((unsigned) (intvl < 1 ? 1 : intvl));
# endif /* SM_CONF_SETITIMER */
	if (wasblocked == 0)
		(void) sm_releasesignal(SIGALRM);
	return ev;
}
/*
**  SM_CLREVENT -- remove an event from the event queue.
**
**	Parameters:
**		ev -- pointer to event to remove.
**
**	Returns:
**		none.
**
**	Side Effects:
**		arranges for event ev to not happen.
*/

void
sm_clrevent(ev)
	register SM_EVENT *ev;
{
	register SM_EVENT **evp;
	int wasblocked;
# if SM_CONF_SETITIMER
	struct itimerval clr;
# endif /* SM_CONF_SETITIMER */

	if (ev == NULL)
		return;

	/* find the parent event */
	wasblocked = sm_blocksignal(SIGALRM);
	for (evp = (SM_EVENT **) (&SmEventQueue);
	     *evp != NULL;
	     evp = &(*evp)->ev_link)
	{
		if (*evp == ev)
			break;
	}

	/* now remove it */
	if (*evp != NULL)
	{
		ENTER_CRITICAL();
		*evp = ev->ev_link;
		ev->ev_link = SmFreeEventList;
		SmFreeEventList = ev;
		LEAVE_CRITICAL();
	}

	/* restore clocks and pick up anything spare */
	if (wasblocked == 0)
		(void) sm_releasesignal(SIGALRM);
	if (SmEventQueue != NULL)
		(void) kill(getpid(), SIGALRM);
	else
	{
		/* nothing left in event queue, no need for an alarm */
# if SM_CONF_SETITIMER
		clr.it_interval.tv_sec = 0;
		clr.it_interval.tv_usec = 0;
		clr.it_value.tv_sec = 0;
		clr.it_value.tv_usec = 0;
		(void) setitimer(ITIMER_REAL, &clr, NULL);
# else /* SM_CONF_SETITIMER */
		(void) alarm(0);
# endif /* SM_CONF_SETITIMER */
	}
}
/*
**  SM_CLEAR_EVENTS -- remove all events from the event queue.
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
*/

void
sm_clear_events()
{
	register SM_EVENT *ev;
#if SM_CONF_SETITIMER
	struct itimerval clr;
#endif /* SM_CONF_SETITIMER */
	int wasblocked;

	/* nothing will be left in event queue, no need for an alarm */
#if SM_CONF_SETITIMER
	clr.it_interval.tv_sec = 0;
	clr.it_interval.tv_usec = 0;
	clr.it_value.tv_sec = 0;
	clr.it_value.tv_usec = 0;
	(void) setitimer(ITIMER_REAL, &clr, NULL);
#else /* SM_CONF_SETITIMER */
	(void) alarm(0);
#endif /* SM_CONF_SETITIMER */

	if (SmEventQueue == NULL)
		return;

	wasblocked = sm_blocksignal(SIGALRM);

	/* find the end of the EventQueue */
	for (ev = SmEventQueue; ev->ev_link != NULL; ev = ev->ev_link)
		continue;

	ENTER_CRITICAL();
	ev->ev_link = SmFreeEventList;
	SmFreeEventList = SmEventQueue;
	SmEventQueue = NULL;
	LEAVE_CRITICAL();

	/* restore clocks and pick up anything spare */
	if (wasblocked == 0)
		(void) sm_releasesignal(SIGALRM);
}
/*
**  SM_TICK -- take a clock tick
**
**	Called by the alarm clock.  This routine runs events as needed.
**	Always called as a signal handler, so we assume that SIGALRM
**	has been blocked.
**
**	Parameters:
**		One that is ignored; for compatibility with signal handlers.
**
**	Returns:
**		none.
**
**	Side Effects:
**		calls the next function in EventQueue.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

/* ARGSUSED */
SIGFUNC_DECL
sm_tick(sig)
	int sig;
{
	register SM_EVENT *ev;
	pid_t mypid;
	int save_errno = errno;
#if SM_CONF_SETITIMER
	struct itimerval clr;
	struct timeval now;
#else /* SM_CONF_SETITIMER */
	register time_t now;
#endif /* SM_CONF_SETITIMER */

#if SM_CONF_SETITIMER
	clr.it_interval.tv_sec = 0;
	clr.it_interval.tv_usec = 0;
	clr.it_value.tv_sec = 0;
	clr.it_value.tv_usec = 0;
	(void) setitimer(ITIMER_REAL, &clr, NULL);
	gettimeofday(&now, NULL);
#else /* SM_CONF_SETITIMER */
	(void) alarm(0);
	now = time(NULL);
#endif /* SM_CONF_SETITIMER */

	FIX_SYSV_SIGNAL(sig, sm_tick);
	errno = save_errno;
	CHECK_CRITICAL(sig);

	mypid = getpid();
	while (PendingSignal != 0)
	{
		int sigbit = 0;
		int sig = 0;

		if (bitset(PEND_SIGHUP, PendingSignal))
		{
			sigbit = PEND_SIGHUP;
			sig = SIGHUP;
		}
		else if (bitset(PEND_SIGINT, PendingSignal))
		{
			sigbit = PEND_SIGINT;
			sig = SIGINT;
		}
		else if (bitset(PEND_SIGTERM, PendingSignal))
		{
			sigbit = PEND_SIGTERM;
			sig = SIGTERM;
		}
		else if (bitset(PEND_SIGUSR1, PendingSignal))
		{
			sigbit = PEND_SIGUSR1;
			sig = SIGUSR1;
		}
		else
		{
			/* If we get here, we are in trouble */
			abort();
		}
		PendingSignal &= ~sigbit;
		kill(mypid, sig);
	}

#if SM_CONF_SETITIMER
	gettimeofday(&now, NULL);
#else /* SM_CONF_SETITIMER */
	now = time(NULL);
#endif /* SM_CONF_SETITIMER */
	while ((ev = SmEventQueue) != NULL &&
	       (ev->ev_pid != mypid ||
#if SM_CONF_SETITIMER
		timercmp(&ev->ev_time, &now, <=)
#else /* SM_CONF_SETITIMER */
		ev->ev_time <= now
#endif /* SM_CONF_SETITIMER */
		))
	{
		void (*f)__P((int));
		int arg;
		pid_t pid;

		/* process the event on the top of the queue */
		ev = SmEventQueue;
		SmEventQueue = SmEventQueue->ev_link;

		/* we must be careful in here because ev_func may not return */
		f = ev->ev_func;
		arg = ev->ev_arg;
		pid = ev->ev_pid;
		ENTER_CRITICAL();
		ev->ev_link = SmFreeEventList;
		SmFreeEventList = ev;
		LEAVE_CRITICAL();
		if (pid != getpid())
			continue;
		if (SmEventQueue != NULL)
		{
#if SM_CONF_SETITIMER
			if (timercmp(&SmEventQueue->ev_time, &now, >))
			{
				timersub(&SmEventQueue->ev_time, &now,
					 &clr.it_value);
				clr.it_interval.tv_sec = 0;
				clr.it_interval.tv_usec = 0;
				if (clr.it_value.tv_sec < 0)
					clr.it_value.tv_sec = 0;
				if (clr.it_value.tv_sec == 0 &&
				    clr.it_value.tv_usec == 0)
					clr.it_value.tv_usec = 1000;
				(void) setitimer(ITIMER_REAL, &clr, NULL);
			}
			else
			{
				clr.it_interval.tv_sec = 0;
				clr.it_interval.tv_usec = 0;
				clr.it_value.tv_sec = 3;
				clr.it_value.tv_usec = 0;
				(void) setitimer(ITIMER_REAL, &clr, NULL);
			}
#else /* SM_CONF_SETITIMER */
			if (SmEventQueue->ev_time > now)
				(void) alarm((unsigned) (SmEventQueue->ev_time
							 - now));
			else
				(void) alarm(3);
#endif /* SM_CONF_SETITIMER */
		}

		/* call ev_func */
		errno = save_errno;
		(*f)(arg);
#if SM_CONF_SETITIMER
		clr.it_interval.tv_sec = 0;
		clr.it_interval.tv_usec = 0;
		clr.it_value.tv_sec = 0;
		clr.it_value.tv_usec = 0;
		(void) setitimer(ITIMER_REAL, &clr, NULL);
		gettimeofday(&now, NULL);
#else /* SM_CONF_SETITIMER */
		(void) alarm(0);
		now = time(NULL);
#endif /* SM_CONF_SETITIMER */
	}
	if (SmEventQueue != NULL)
	{
#if SM_CONF_SETITIMER
		timersub(&SmEventQueue->ev_time, &now, &clr.it_value);
		clr.it_interval.tv_sec = 0;
		clr.it_interval.tv_usec = 0;
		if (clr.it_value.tv_sec < 0)
			clr.it_value.tv_sec = 0;
		if (clr.it_value.tv_sec == 0 && clr.it_value.tv_usec == 0)
			clr.it_value.tv_usec = 1000;
		(void) setitimer(ITIMER_REAL, &clr, NULL);
#else /* SM_CONF_SETITIMER */
		(void) alarm((unsigned) (SmEventQueue->ev_time - now));
#endif /* SM_CONF_SETITIMER */
	}
	errno = save_errno;
	return SIGFUNC_RETURN;
}
/*
**  SLEEP -- a version of sleep that works with this stuff
**
**	Because Unix sleep uses the alarm facility, I must reimplement
**	it here.
**
**	Parameters:
**		intvl -- time to sleep.
**
**	Returns:
**		zero.
**
**	Side Effects:
**		waits for intvl time.  However, other events can
**		be run during that interval.
*/


# if !HAVE_NANOSLEEP
static void	sm_endsleep __P((int));
static bool	volatile SmSleepDone;
# endif /* !HAVE_NANOSLEEP */

#ifndef SLEEP_T
# define SLEEP_T	unsigned int
#endif /* ! SLEEP_T */

SLEEP_T
sleep(intvl)
	unsigned int intvl;
{
#if HAVE_NANOSLEEP
	struct timespec rqtp;

	if (intvl == 0)
		return (SLEEP_T) 0;
	rqtp.tv_sec = intvl;
	rqtp.tv_nsec = 0;
	nanosleep(&rqtp, NULL);
	return (SLEEP_T) 0;
#else /* HAVE_NANOSLEEP */
	int was_held;
	SM_EVENT *ev;
#if _FFR_SLEEP_USE_SELECT > 0
	int r;
# if _FFR_SLEEP_USE_SELECT > 0
	struct timeval sm_io_to;
# endif /* _FFR_SLEEP_USE_SELECT > 0 */
#endif /* _FFR_SLEEP_USE_SELECT > 0 */
#if SM_CONF_SETITIMER
	struct timeval now, begin, diff;
# if _FFR_SLEEP_USE_SELECT > 0
	struct timeval slpv;
# endif /* _FFR_SLEEP_USE_SELECT > 0 */
#else /*  SM_CONF_SETITIMER */
	time_t begin, now;
#endif /*  SM_CONF_SETITIMER */

	if (intvl == 0)
		return (SLEEP_T) 0;
#if defined(_FFR_MAX_SLEEP_TIME) && _FFR_MAX_SLEEP_TIME > 2
	if (intvl > _FFR_MAX_SLEEP_TIME)
	{
		syslog(LOG_ERR, "sleep: interval=%u exceeds max value %d",
			intvl, _FFR_MAX_SLEEP_TIME);
# if 0
		SM_ASSERT(intvl < (unsigned int) INT_MAX);
# endif /* 0 */
		intvl = _FFR_MAX_SLEEP_TIME;
	}
#endif /* defined(_FFR_MAX_SLEEP_TIME) && _FFR_MAX_SLEEP_TIME > 2 */
	SmSleepDone = false;

#if SM_CONF_SETITIMER
# if _FFR_SLEEP_USE_SELECT > 0
	slpv.tv_sec = intvl;
	slpv.tv_usec = 0;
# endif /* _FFR_SLEEP_USE_SELECT > 0 */
	(void) gettimeofday(&now, NULL);
	begin = now;
#else /*  SM_CONF_SETITIMER */
	now = begin = time(NULL);
#endif /*  SM_CONF_SETITIMER */

	ev = sm_setevent((time_t) intvl, sm_endsleep, 0);
	if (ev == NULL)
	{
		/* COMPLAIN */
#if 0
		syslog(LOG_ERR, "sleep: sm_setevent(%u) failed", intvl);
#endif /* 0 */
		SmSleepDone = true;
	}
	was_held = sm_releasesignal(SIGALRM);

	while (!SmSleepDone)
	{
#if SM_CONF_SETITIMER
		(void) gettimeofday(&now, NULL);
		timersub(&now, &begin, &diff);
		if (diff.tv_sec < 0 ||
		    (diff.tv_sec == 0 && diff.tv_usec == 0))
			break;
# if _FFR_SLEEP_USE_SELECT > 0
		timersub(&slpv, &diff, &sm_io_to);
# endif /* _FFR_SLEEP_USE_SELECT > 0 */
#else /* SM_CONF_SETITIMER */
		now = time(NULL);

		/*
		**  Check whether time expired before signal is released.
		**  Due to the granularity of time() add 1 to be on the
		**  safe side.
		*/

		if (!(begin + (time_t) intvl + 1 > now))
			break;
# if _FFR_SLEEP_USE_SELECT > 0
		sm_io_to.tv_sec = intvl - (now - begin);
		if (sm_io_to.tv_sec <= 0)
			sm_io_to.tv_sec = 1;
		sm_io_to.tv_usec = 0;
# endif /* _FFR_SLEEP_USE_SELECT > 0 */
#endif /* SM_CONF_SETITIMER */
#if _FFR_SLEEP_USE_SELECT > 0
		if (intvl <= _FFR_SLEEP_USE_SELECT)
		{
			r = select(0, NULL, NULL, NULL, &sm_io_to);
			if (r == 0)
				break;
		}
		else
#endif /* _FFR_SLEEP_USE_SELECT > 0 */
		(void) pause();
	}

	/* if out of the loop without the event being triggered remove it */
	if (!SmSleepDone)
		sm_clrevent(ev);
	if (was_held > 0)
		(void) sm_blocksignal(SIGALRM);
	return (SLEEP_T) 0;
#endif /* HAVE_NANOSLEEP */
}

#if !HAVE_NANOSLEEP
static void
sm_endsleep(ignore)
	int ignore;
{
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	SmSleepDone = true;
}
#endif /* !HAVE_NANOSLEEP */

@


1.12
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.11
log
@Update to sendmail 8.13.6
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004 Sendmail, Inc. and its suppliers.
d15 1
a15 1
SM_RCSID("@@(#)$Sendmail: clock.c,v 1.47 2005/06/14 23:07:20 ca Exp $")
@


1.10
log
@Update to sendmail-8.13.2
@
text
@d15 1
a15 1
SM_RCSID("@@(#)$Sendmail: clock.c,v 1.46 2004/08/03 19:57:22 ca Exp $")
d20 1
a20 1
# include <sys/time.h>
@


1.9
log
@Update to sendmail.8.13.0
@
text
@d15 1
a15 1
SM_RCSID("@@(#)$Sendmail: clock.c,v 1.45 2004/01/19 19:32:08 ca Exp $")
d66 1
a66 1
	void (*func)();
d89 1
a89 1
	void (*func)();
d397 1
a397 1
		void (*f)();
d500 1
a500 1
static void	sm_endsleep __P((void));
d628 2
a629 1
sm_endsleep()
@


1.8
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d15 1
a15 1
SM_RCSID("@@(#)$Sendmail: clock.c,v 1.35.2.10 2003/06/26 16:36:49 ca Exp $")
d526 3
d533 1
a533 1
	struct timeval sm_io_to, slpv;
d602 1
a602 1
		sm_io_to.utv_sec = 0;
@


1.7
log
@Update to sendmail 8.12.9; fixes a buffer overflow in address parsing
due to a char to int conversion problem which is potentially remotely
exploitable.
@
text
@d15 1
a15 1
SM_RCSID("@@(#)$Sendmail: clock.c,v 1.35.2.3 2003/03/03 19:57:40 ca Exp $")
d27 6
a37 2
static void	sm_endsleep __P((void));

d143 2
d499 2
d502 1
d512 10
d523 12
d538 11
d550 21
a570 1
	(void) sm_setevent((time_t) intvl, sm_endsleep, 0);
d572 1
d574 37
d612 5
d620 1
d623 1
d635 1
@


1.6
log
@update to sendmail-8.12.6
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d15 1
a15 1
SM_RCSID("@@(#)$Sendmail: clock.c,v 1.35.2.2 2002/06/27 23:24:20 gshapiro Exp $")
d170 1
a170 1
	(void) alarm((unsigned) intvl < 1 ? 1 : intvl);
@


1.5
log
@sendmail 8.12.5
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
SM_RCSID("@@(#)$Sendmail: clock.c,v 1.35.2.1 2002/06/20 05:14:45 gshapiro Exp $")
@


1.4
log
@update to sendmail 8.12.3
@
text
@d15 1
a15 1
SM_RCSID("@@(#)$Sendmail: clock.c,v 1.35 2002/03/22 18:34:38 gshapiro Exp $")
a259 3
	if (SmEventQueue == NULL)
		return;

d270 4
@


1.3
log
@update to sendmail-8.12.2
@
text
@d15 1
a15 1
SM_RCSID("@@(#)$Sendmail: clock.c,v 1.34 2001/11/05 18:33:20 ca Exp $")
d163 2
d417 5
d462 4
@


1.2
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d15 1
a15 1
SM_RCSID("@@(#)$Sendmail: clock.c,v 1.33 2001/09/11 04:04:47 gshapiro Exp $")
d120 1
a120 1
		if (timercmp(&(ev->ev_time), &nowi, >))
d163 2
d382 1
a382 1
		timercmp(&ev->ev_time, &now, <)
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
SM_RCSID("@@(#)$Sendmail: clock.c,v 1.30 2001/08/31 20:44:28 ca Exp $")
d172 1
a172 1
/*
d237 1
a237 1
/*
d285 1
a285 1
/*
d461 1
a461 1
/*
@


1.1.1.1
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@@
