head	1.16;
access;
symbols
	OPENBSD_5_6:1.15.0.6
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.36
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.34
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.32
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.30
	OPENBSD_5_0:1.14.0.28
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.26
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.24
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.20
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.22
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.18
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.16
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.14
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.12
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.10
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.8
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.6
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.4
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2014.09.17.18.49.52;	author matthieu;	state dead;
branches;
next	1.15;
commitid	M7i5giHIoz3DMlTU;

1.15
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.16.00.21.31;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.24.03.59.28;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.19.01.41.14;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.01.19.59.23;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.10.09.03.58.48;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.03.17.25.47;	author millert;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.10.01.17.18.30;	author millert;	state Exp;
branches
	1.8.2.1
	1.8.4.1;
next	1.7;

1.7
date	2001.09.11.19.02.50;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.09.07.04.37;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.29.01.31.17;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.28.02.43.56;	author millert;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.01.15.21.09.11;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.07.19.20.46;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.42;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.42;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.09;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.49;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.32.01;	author miod;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.31.01.47.59;	author jason;	state Exp;
branches;
next	;

1.8.2.1
date	2002.11.06.22.06.44;	author miod;	state Exp;
branches;
next	;

1.8.4.1
date	2002.11.06.22.07.54;	author miod;	state Exp;
branches;
next	;

1.9.2.1
date	2002.11.04.14.29.09;	author jason;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2004 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1993 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sm/gen.h>

SM_IDSTR(copyright,
"@@(#) Copyright (c) 1998-2004 Proofpoint, Inc. and its suppliers.\n\
	All rights reserved.\n\
     Copyright (c) 1993 Eric P. Allman.  All rights reserved.\n\
     Copyright (c) 1993\n\
	The Regents of the University of California.  All rights reserved.\n")

SM_IDSTR(id, "@@(#)$Sendmail: smrsh.c,v 8.66 2013/11/22 20:52:00 ca Exp $")

/*
**  SMRSH -- sendmail restricted shell
**
**	This is a patch to get around the prog mailer bugs in most
**	versions of sendmail.
**
**	Use this in place of /bin/sh in the "prog" mailer definition
**	in your sendmail.cf file.  You then create CMDDIR (owned by
**	root, mode 755) and put links to any programs you want
**	available to prog mailers in that directory.  This should
**	include things like "vacation" and "procmail", but not "sed"
**	or "sh".
**
**	Leading pathnames are stripped from program names so that
**	existing .forward files that reference things like
**	"/usr/bin/vacation" will continue to work.
**
**	The following characters are completely illegal:
**		<  >  ^  &  `  (  ) \n \r
**	The following characters are sometimes illegal:
**		|  &
**	This is more restrictive than strictly necessary.
**
**	To use this, add FEATURE(`smrsh') to your .mc file.
**
**	This can be used on any version of sendmail.
**
**	In loving memory of RTM.  11/02/93.
*/

#include <unistd.h>
#include <sm/io.h>
#include <sm/limits.h>
#include <sm/string.h>
#include <sys/file.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#ifdef EX_OK
# undef EX_OK
#endif /* EX_OK */
#include <sysexits.h>
#include <syslog.h>
#include <stdlib.h>

#include <sm/conf.h>
#include <sm/errstring.h>

/* directory in which all commands must reside */
#ifndef CMDDIR
# ifdef SMRSH_CMDDIR
#  define CMDDIR	SMRSH_CMDDIR
# else /* SMRSH_CMDDIR */
#  define CMDDIR	"/usr/adm/sm.bin"
# endif /* SMRSH_CMDDIR */
#endif /* ! CMDDIR */

/* characters disallowed in the shell "-c" argument */
#define SPECIALS	"<|>^();&`$\r\n"

/* default search path */
#ifndef PATH
# ifdef SMRSH_PATH
#  define PATH		SMRSH_PATH
# else /* SMRSH_PATH */
#  define PATH		"/bin:/usr/bin:/usr/ucb"
# endif /* SMRSH_PATH */
#endif /* ! PATH */

char newcmdbuf[1000];
char *prg, *par;

static void	addcmd __P((char *, bool, size_t));

/*
**  ADDCMD -- add a string to newcmdbuf, check for overflow
**
**    Parameters:
**	s -- string to add
**	cmd -- it's a command: prepend CMDDIR/
**	len -- length of string to add
**
**    Side Effects:
**	changes newcmdbuf or exits with a failure.
**
*/

static void
addcmd(s, cmd, len)
	char *s;
	bool cmd;
	size_t len;
{
	if (s == NULL || *s == '\0')
		return;

	/* enough space for s (len) and CMDDIR + "/" and '\0'? */
	if (sizeof newcmdbuf - strlen(newcmdbuf) <=
	    len + 1 + (cmd ? (strlen(CMDDIR) + 1) : 0))
	{
		(void)sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				    "%s: command too long: %s\n", prg, par);
#ifndef DEBUG
		syslog(LOG_WARNING, "command too long: %.40s", par);
#endif /* ! DEBUG */
		exit(EX_UNAVAILABLE);
	}
	if (cmd)
		(void) sm_strlcat2(newcmdbuf, CMDDIR, "/", sizeof newcmdbuf);
	(void) strncat(newcmdbuf, s, len);
}

int
main(argc, argv)
	int argc;
	char **argv;
{
	register char *p;
	register char *q;
	register char *r;
	register char *cmd;
	int isexec;
	int save_errno;
	char *newenv[2];
	char pathbuf[1000];
	char specialbuf[32];
	struct stat st;

#ifndef DEBUG
# ifndef LOG_MAIL
	openlog("smrsh", 0);
# else /* ! LOG_MAIL */
	openlog("smrsh", LOG_ODELAY|LOG_CONS, LOG_MAIL);
# endif /* ! LOG_MAIL */
#endif /* ! DEBUG */

	(void) sm_strlcpyn(pathbuf, sizeof pathbuf, 2, "PATH=", PATH);
	newenv[0] = pathbuf;
	newenv[1] = NULL;

	/*
	**  Do basic argv usage checking
	*/

	prg = argv[0];

	if (argc != 3 || strcmp(argv[1], "-c") != 0)
	{
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				     "Usage: %s -c command\n", prg);
#ifndef DEBUG
		syslog(LOG_ERR, "usage");
#endif /* ! DEBUG */
		exit(EX_USAGE);
	}

	par = argv[2];

	/*
	**  Disallow special shell syntax.  This is overly restrictive,
	**  but it should shut down all attacks.
	**  Be sure to include 8-bit versions, since many shells strip
	**  the address to 7 bits before checking.
	*/

	if (strlen(SPECIALS) * 2 >= sizeof specialbuf)
	{
#ifndef DEBUG
		syslog(LOG_ERR, "too many specials: %.40s", SPECIALS);
#endif /* ! DEBUG */
		exit(EX_UNAVAILABLE);
	}
	(void) sm_strlcpy(specialbuf, SPECIALS, sizeof specialbuf);
	for (p = specialbuf; *p != '\0'; p++)
		*p |= '\200';
	(void) sm_strlcat(specialbuf, SPECIALS, sizeof specialbuf);

	/*
	**  Do a quick sanity check on command line length.
	*/

	if (strlen(par) > (sizeof newcmdbuf - sizeof CMDDIR - 2))
	{
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				     "%s: command too long: %s\n", prg, par);
#ifndef DEBUG
		syslog(LOG_WARNING, "command too long: %.40s", par);
#endif /* ! DEBUG */
		exit(EX_UNAVAILABLE);
	}

	q = par;
	newcmdbuf[0] = '\0';
	isexec = false;

	while (*q != '\0')
	{
		/*
		**  Strip off a leading pathname on the command name.  For
		**  example, change /usr/ucb/vacation to vacation.
		*/

		/* strip leading spaces */
		while (*q != '\0' && isascii(*q) && isspace(*q))
			q++;
		if (*q == '\0')
		{
			if (isexec)
			{
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: missing command to exec\n",
						     prg);
#ifndef DEBUG
				syslog(LOG_CRIT, "uid %d: missing command to exec", (int) getuid());
#endif /* ! DEBUG */
				exit(EX_UNAVAILABLE);
			}
			break;
		}

		/* find the end of the command name */
		p = strpbrk(q, " \t");
		if (p == NULL)
			cmd = &q[strlen(q)];
		else
		{
			*p = '\0';
			cmd = p;
		}
		/* search backwards for last / (allow for 0200 bit) */
		while (cmd > q)
		{
			if ((*--cmd & 0177) == '/')
			{
				cmd++;
				break;
			}
		}
		/* cmd now points at final component of path name */

		/* allow a few shell builtins */
		if (strcmp(q, "exec") == 0 && p != NULL)
		{
			addcmd("exec ", false, strlen("exec "));

			/* test _next_ arg */
			q = ++p;
			isexec = true;
			continue;
		}
		else if (strcmp(q, "exit") == 0 || strcmp(q, "echo") == 0)
		{
			addcmd(cmd, false, strlen(cmd));

			/* test following chars */
		}
		else
		{
			char cmdbuf[MAXPATHLEN];

			/*
			**  Check to see if the command name is legal.
			*/

			if (sm_strlcpyn(cmdbuf, sizeof cmdbuf, 3, CMDDIR,
					"/", cmd) >= sizeof cmdbuf)
			{
				/* too long */
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: \"%s\" not available for sendmail programs (filename too long)\n",
						      prg, cmd);
				if (p != NULL)
					*p = ' ';
#ifndef DEBUG
				syslog(LOG_CRIT, "uid %d: attempt to use \"%s\" (filename too long)",
				       (int) getuid(), cmd);
#endif /* ! DEBUG */
				exit(EX_UNAVAILABLE);
			}

#ifdef DEBUG
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Trying %s\n", cmdbuf);
#endif /* DEBUG */
			if (stat(cmdbuf, &st) < 0)
			{
				/* can't stat it */
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: \"%s\" not available for sendmail programs (stat failed)\n",
						      prg, cmd);
				if (p != NULL)
					*p = ' ';
#ifndef DEBUG
				syslog(LOG_CRIT, "uid %d: attempt to use \"%s\" (stat failed)",
				       (int) getuid(), cmd);
#endif /* ! DEBUG */
				exit(EX_UNAVAILABLE);
			}
			if (!S_ISREG(st.st_mode)
#ifdef S_ISLNK
			    && !S_ISLNK(st.st_mode)
#endif /* S_ISLNK */
			   )
			{
				/* can't stat it */
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: \"%s\" not available for sendmail programs (not a file)\n",
						      prg, cmd);
				if (p != NULL)
					*p = ' ';
#ifndef DEBUG
				syslog(LOG_CRIT, "uid %d: attempt to use \"%s\" (not a file)",
				       (int) getuid(), cmd);
#endif /* ! DEBUG */
				exit(EX_UNAVAILABLE);
			}
			if (access(cmdbuf, X_OK) < 0)
			{
				/* oops....  crack attack possiblity */
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: \"%s\" not available for sendmail programs\n",
						      prg, cmd);
				if (p != NULL)
					*p = ' ';
#ifndef DEBUG
				syslog(LOG_CRIT, "uid %d: attempt to use \"%s\"",
				       (int) getuid(), cmd);
#endif /* ! DEBUG */
				exit(EX_UNAVAILABLE);
			}

			/*
			**  Create the actual shell input.
			*/

			addcmd(cmd, true, strlen(cmd));
		}
		isexec = false;

		if (p != NULL)
			*p = ' ';
		else
			break;

		r = strpbrk(p, specialbuf);
		if (r == NULL)
		{
			addcmd(p, false, strlen(p));
			break;
		}
#if ALLOWSEMI
		if (*r == ';')
		{
			addcmd(p, false,  r - p + 1);
			q = r + 1;
			continue;
		}
#endif /* ALLOWSEMI */
		if ((*r == '&' && *(r + 1) == '&') ||
		    (*r == '|' && *(r + 1) == '|'))
		{
			addcmd(p, false,  r - p + 2);
			q = r + 2;
			continue;
		}

		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				     "%s: cannot use %c in command\n", prg, *r);
#ifndef DEBUG
		syslog(LOG_CRIT, "uid %d: attempt to use %c in command: %s",
		       (int) getuid(), *r, par);
#endif /* ! DEBUG */
		exit(EX_UNAVAILABLE);
	}
	if (isexec)
	{
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				     "%s: missing command to exec\n", prg);
#ifndef DEBUG
		syslog(LOG_CRIT, "uid %d: missing command to exec",
		       (int) getuid());
#endif /* ! DEBUG */
		exit(EX_UNAVAILABLE);
	}
	/* make sure we created something */
	if (newcmdbuf[0] == '\0')
	{
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				     "Usage: %s -c command\n", prg);
#ifndef DEBUG
		syslog(LOG_ERR, "usage");
#endif /* ! DEBUG */
		exit(EX_USAGE);
	}

	/*
	**  Now invoke the shell
	*/

#ifdef DEBUG
	(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s\n", newcmdbuf);
#endif /* DEBUG */
	(void) execle("/bin/sh", "/bin/sh", "-c", newcmdbuf,
		      (char *)NULL, newenv);
	save_errno = errno;
#ifndef DEBUG
	syslog(LOG_CRIT, "Cannot exec /bin/sh: %s", sm_errstring(errno));
#endif /* ! DEBUG */
	errno = save_errno;
	sm_perror("/bin/sh");
	exit(EX_OSFILE);
	/* NOTREACHED */
	return EX_OSFILE;
}
@


1.15
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.14
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004 Sendmail, Inc. and its suppliers.
d17 1
a17 1
"@@(#) Copyright (c) 1998-2004 Sendmail, Inc. and its suppliers.\n\
d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: smrsh.c,v 8.65 2004/08/06 18:54:22 ca Exp $")
@


1.13
log
@Update to sendmail.8.13.0
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d17 1
a17 1
"@@(#) Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.\n\
d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: smrsh.c,v 8.63 2003/12/15 17:12:29 ca Exp $")
d99 2
d114 1
a114 1
void
@


1.12
log
@Update to sendmail 8.12.11.  I've been runninga beta version of this for
some time without problems.  See the RELEASE_NOTES for the change log.
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: smrsh.c,v 8.58.2.5 2003/12/15 17:09:39 ca Exp $")
@


1.11
log
@update to sendmail 8.12.7
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: smrsh.c,v 8.58.2.2 2002/09/24 21:40:05 ca Exp $")
d121 1
d123 1
a123 1
	    len + (cmd ? (strlen(CMDDIR) + 1) : 0))
d134 1
a134 1
	(void) sm_strlcat(newcmdbuf, s, sizeof newcmdbuf);
d427 2
a428 1
	(void) execle("/bin/sh", "/bin/sh", "-c", newcmdbuf, (char *)NULL, newenv);
@


1.10
log
@Patch from sendmail.org to fix potential smrsh bypass described
in http://www.sendmail.org/smrsh.adv.txt
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: smrsh.c,v 8.58 2002/05/25 02:41:31 ca Exp $")
d293 1
a293 1
						     "%s: %s not available for sendmail programs (filename too long)\n",
d298 1
a298 1
				syslog(LOG_CRIT, "uid %d: attempt to use %s (filename too long)",
d312 1
a312 1
						     "%s: %s not available for sendmail programs (stat failed)\n",
d317 1
a317 1
				syslog(LOG_CRIT, "uid %d: attempt to use %s (stat failed)",
d330 1
a330 1
						     "%s: %s not available for sendmail programs (not a file)\n",
d335 1
a335 1
				syslog(LOG_CRIT, "uid %d: attempt to use %s (not a file)",
d344 1
a344 1
						     "%s: %s not available for sendmail programs\n",
d349 1
a349 1
				syslog(LOG_CRIT, "uid %d: attempt to use %s",
@


1.9
log
@Update to sendmail-8.12.4
@
text
@d60 2
d150 1
d308 32
@


1.9.2.1
log
@Pull in patch from current:
Fix (millert):
Patch from sendmail.org to fix potential smrsh bypass described
in http://www.sendmail.org/smrsh.adv.txt
@
text
@a59 2
#include <sys/types.h>
#include <sys/stat.h>
a147 1
	struct stat st;
a304 32
			if (stat(cmdbuf, &st) < 0)
			{
				/* can't stat it */
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: %s not available for sendmail programs (stat failed)\n",
						      prg, cmd);
				if (p != NULL)
					*p = ' ';
#ifndef DEBUG
				syslog(LOG_CRIT, "uid %d: attempt to use %s (stat failed)",
				       (int) getuid(), cmd);
#endif /* ! DEBUG */
				exit(EX_UNAVAILABLE);
			}
			if (!S_ISREG(st.st_mode)
#ifdef S_ISLNK
			    && !S_ISLNK(st.st_mode)
#endif /* S_ISLNK */
			   )
			{
				/* can't stat it */
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: %s not available for sendmail programs (not a file)\n",
						      prg, cmd);
				if (p != NULL)
					*p = ' ';
#ifndef DEBUG
				syslog(LOG_CRIT, "uid %d: attempt to use %s (not a file)",
				       (int) getuid(), cmd);
#endif /* ! DEBUG */
				exit(EX_UNAVAILABLE);
			}
@


1.8
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: smrsh.c,v 8.55 2001/09/11 04:05:22 gshapiro Exp $")
d57 1
d130 1
a130 4
	{
		(void) sm_strlcat(newcmdbuf, CMDDIR, sizeof newcmdbuf);
		(void) sm_strlcat(newcmdbuf, "/", sizeof newcmdbuf);
	}
a145 1
	char cmdbuf[1000];
d157 1
a157 2
	(void) sm_strlcpy(pathbuf, "PATH=", sizeof pathbuf);
	(void) sm_strlcat(pathbuf, PATH, sizeof pathbuf);
d216 1
a216 1
	while (*q)
d265 1
d274 1
d279 2
d284 17
a300 3
			(void) sm_strlcpy(cmdbuf, CMDDIR, sizeof cmdbuf);
			(void) sm_strlcat(cmdbuf, "/", sizeof cmdbuf);
			(void) sm_strlcat(cmdbuf, cmd, sizeof cmdbuf);
d362 1
a362 1
	}		/* end of while *q */
@


1.8.4.1
log
@MFC:
Patch from sendmail.org to fix potential smrsh bypass described
in http://www.sendmail.org/smrsh.adv.txt
@
text
@a58 2
#include <sys/types.h>
#include <sys/stat.h>
a150 1
	struct stat st;
a290 32
			if (stat(cmdbuf, &st) < 0)
			{
				/* can't stat it */
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: %s not available for sendmail programs (stat failed)\n",
						      prg, cmd);
				if (p != NULL)
					*p = ' ';
#ifndef DEBUG
				syslog(LOG_CRIT, "uid %d: attempt to use %s (stat failed)",
				       (int) getuid(), cmd);
#endif /* ! DEBUG */
				exit(EX_UNAVAILABLE);
			}
			if (!S_ISREG(st.st_mode)
#ifdef S_ISLNK
			    && !S_ISLNK(st.st_mode)
#endif /* S_ISLNK */
			   )
			{
				/* can't stat it */
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: %s not available for sendmail programs (not a file)\n",
						      prg, cmd);
				if (p != NULL)
					*p = ' ';
#ifndef DEBUG
				syslog(LOG_CRIT, "uid %d: attempt to use %s (not a file)",
				       (int) getuid(), cmd);
#endif /* ! DEBUG */
				exit(EX_UNAVAILABLE);
			}
@


1.8.2.1
log
@MFC:
Patch from sendmail.org to fix potential smrsh bypass described
in http://www.sendmail.org/smrsh.adv.txt
@
text
@a58 2
#include <sys/types.h>
#include <sys/stat.h>
a150 1
	struct stat st;
a290 32
			if (stat(cmdbuf, &st) < 0)
			{
				/* can't stat it */
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: %s not available for sendmail programs (stat failed)\n",
						      prg, cmd);
				if (p != NULL)
					*p = ' ';
#ifndef DEBUG
				syslog(LOG_CRIT, "uid %d: attempt to use %s (stat failed)",
				       (int) getuid(), cmd);
#endif /* ! DEBUG */
				exit(EX_UNAVAILABLE);
			}
			if (!S_ISREG(st.st_mode)
#ifdef S_ISLNK
			    && !S_ISLNK(st.st_mode)
#endif /* S_ISLNK */
			   )
			{
				/* can't stat it */
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: %s not available for sendmail programs (not a file)\n",
						      prg, cmd);
				if (p != NULL)
					*p = ' ';
#ifndef DEBUG
				syslog(LOG_CRIT, "uid %d: attempt to use %s (not a file)",
				       (int) getuid(), cmd);
#endif /* ! DEBUG */
				exit(EX_UNAVAILABLE);
			}
@


1.7
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: smrsh.c,v 8.53 2001/08/31 18:36:04 gshapiro Exp $")
@


1.6
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d14 3
a16 2
#ifndef lint
static char copyright[] =
d21 1
a21 2
	The Regents of the University of California.  All rights reserved.\n";
#endif /* ! lint */
d23 1
a23 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: smrsh.c,v 8.31.4.9 2001/04/24 04:11:51 ca Exp $";
#endif /* ! lint */
d56 2
a57 1
#include <stdio.h>
d69 2
a70 4
#ifndef TRUE
# define TRUE	1
# define FALSE	0
#endif /* ! TRUE */
d74 3
a76 3
# if defined(HPUX10) || defined(HPUX11) || SOLARIS >= 20800
#  define CMDDIR	"/var/adm/sm.bin"
# else /* HPUX10 || HPUX11 || SOLARIS >= 20800 */
d78 1
a78 1
# endif /* HPUX10 || HPUX11 || SOLARIS >= 20800 */
d86 5
a90 1
# define PATH		"/bin:/usr/bin:/usr/ucb"
a92 7
#ifndef __P
# include "sendmail/cdefs.h"
#endif /* ! __P */

extern size_t	strlcpy __P((char *, const char *, size_t));
extern size_t	strlcat __P((char *, const char *, size_t));

d112 2
a113 2
	int cmd;
	int len;
d121 2
a122 1
		fprintf(stderr, "%s: command too long: %s\n", prg, par);
d130 2
a131 2
		(void) strlcat(newcmdbuf, CMDDIR, sizeof newcmdbuf);
		(void) strlcat(newcmdbuf, "/", sizeof newcmdbuf);
d133 1
a133 1
	(void) strlcat(newcmdbuf, s, sizeof newcmdbuf);
a144 1
	int i;
d160 2
a161 2
	(void) strlcpy(pathbuf, "PATH=", sizeof pathbuf);
	(void) strlcat(pathbuf, PATH, sizeof pathbuf);
d173 2
a174 1
		fprintf(stderr, "Usage: %s -c command\n", prg);
d197 1
a197 1
	(void) strlcpy(specialbuf, SPECIALS, sizeof specialbuf);
d200 1
a200 1
	(void) strlcat(specialbuf, SPECIALS, sizeof specialbuf);
d206 1
a206 2
	i = strlen(par);
	if (i > (sizeof newcmdbuf - sizeof CMDDIR - 2))
d208 2
a209 1
		fprintf(stderr, "%s: command too long: %s\n", prg, par);
d218 1
a218 1
	isexec = FALSE;
d234 3
a236 2
				fprintf(stderr, "%s: missing command to exec\n",
					prg);
d238 1
a238 1
				syslog(LOG_CRIT, "uid %d: missing command to exec", getuid());
d268 1
a268 1
			addcmd("exec ", FALSE, strlen("exec "));
d271 1
a271 1
			isexec = TRUE;
d276 1
a276 1
			addcmd(cmd, FALSE, strlen(cmd));
d284 3
a286 3
			(void) strlcpy(cmdbuf, CMDDIR, sizeof cmdbuf);
			(void) strlcat(cmdbuf, "/", sizeof cmdbuf);
			(void) strlcat(cmdbuf, cmd, sizeof cmdbuf);
d288 2
a289 1
			printf("Trying %s\n", cmdbuf);
d294 3
a296 3
				fprintf(stderr,
					"%s: %s not available for sendmail programs\n",
					prg, cmd);
d301 1
a301 1
				       getuid(), cmd);
d310 1
a310 1
			addcmd(cmd, TRUE, strlen(cmd));
d312 1
a312 1
		isexec = FALSE;
d320 3
a322 2
		if (r == NULL) {
			addcmd(p, FALSE, strlen(p));
d326 3
a328 2
		if (*r == ';') {
			addcmd(p, FALSE,  r - p + 1);
d336 1
a336 1
			addcmd(p, FALSE,  r - p + 2);
d341 2
a342 1
		fprintf(stderr, "%s: cannot use %c in command\n", prg, *r);
d345 1
a345 1
			getuid(), *r, par);
d351 2
a352 1
		fprintf(stderr, "%s: missing command to exec\n", prg);
d354 2
a355 1
		syslog(LOG_CRIT, "uid %d: missing command to exec", getuid());
d362 2
a363 1
		fprintf(stderr, "Usage: %s -c command\n", prg);
d375 1
a375 1
	printf("%s\n", newcmdbuf);
d380 1
a380 1
	syslog(LOG_CRIT, "Cannot exec /bin/sh: %m");
d383 1
a383 1
	perror("/bin/sh");
@


1.5
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d374 1
a374 1
	(void) execle("/bin/sh", "/bin/sh", "-c", newcmdbuf, NULL, newenv);
@


1.4
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d24 1
a24 1
static char id[] = "@@(#)$Sendmail: smrsh.c,v 8.31.4.8 2001/01/22 19:00:26 gshapiro Exp $";
a175 1
	par = argv[2];
d185 2
@


1.4.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d24 1
a24 1
static char id[] = "@@(#)$Sendmail: smrsh.c,v 8.31.4.9 2001/04/24 04:11:51 ca Exp $";
d176 1
a185 2

	par = argv[2];
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d16 1
a16 1
"@@(#) Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.\n\
d24 1
a24 1
static char id[] = "@@(#)$Sendmail: smrsh.c,v 8.31.4.6 2000/10/09 20:37:16 gshapiro Exp $";
d79 1
a79 1
# else /* HPUX10 || HPUX11 || SOLARIS > 20800 */
d81 1
a81 1
# endif /* HPUX10 || HPUX11 || SOLARIS > 20800 */
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d24 1
a24 1
static char id[] = "@@(#)$Sendmail: smrsh.c,v 8.31 2000/03/17 07:32:49 gshapiro Exp $";
d77 5
a81 1
# define CMDDIR		"/usr/adm/sm.bin"
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
"@@(#) Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.\n\
d24 1
a24 1
static char id[] = "@@(#)$Sendmail: smrsh.c,v 8.31.4.9 2001/04/24 04:11:51 ca Exp $";
d77 1
a77 5
# if defined(HPUX10) || defined(HPUX11) || SOLARIS >= 20800
#  define CMDDIR	"/var/adm/sm.bin"
# else /* HPUX10 || HPUX11 || SOLARIS >= 20800 */
#  define CMDDIR	"/usr/adm/sm.bin"
# endif /* HPUX10 || HPUX11 || SOLARIS >= 20800 */
d172 1
a181 2

	par = argv[2];
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1998, 1999 Sendmail, Inc. and its suppliers.
d16 1
a16 1
"@@(#) Copyright (c) 1998, 1999 Sendmail, Inc. and its suppliers.\n\
d24 1
a24 1
static char id[] = "@@(#)$Sendmail: smrsh.c,v 8.28 1999/10/26 16:11:32 ca Exp $";
d42 1
a42 1
**	"/usr/ucb/vacation" will continue to work.
d50 1
a50 3
**	To use this, edit /etc/sendmail.cf, search for ^Mprog, and
**	change P=/bin/sh to P=/usr/local/etc/smrsh, where this compiled
**	binary is installed /usr/local/etc/smrsh.
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d16 1
a16 1
"@@(#) Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.\n\
d24 1
a24 1
static char id[] = "@@(#)$Id: smrsh.c,v 8.31.4.6 2000/10/09 20:37:16 gshapiro Exp $";
d42 1
a42 1
**	"/usr/bin/vacation" will continue to work.
d50 3
a52 1
**	To use this, add FEATURE(`smrsh') to your .mc file.
d79 1
a79 5
# if defined(HPUX10) || defined(HPUX11) || SOLARIS >= 20800
#  define CMDDIR	"/var/adm/sm.bin"
# else /* HPUX10 || HPUX11 || SOLARIS > 20800 */
#  define CMDDIR	"/usr/adm/sm.bin"
# endif /* HPUX10 || HPUX11 || SOLARIS > 20800 */
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d14 3
a16 4
#include <sm/gen.h>

SM_IDSTR(copyright,
"@@(#) Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.\n\
d20 2
a21 1
	The Regents of the University of California.  All rights reserved.\n")
d23 3
a25 1
SM_IDSTR(id, "@@(#)$Sendmail: smrsh.c,v 8.53 2001/08/31 18:36:04 gshapiro Exp $")
d58 1
a58 2
#include <sm/io.h>
#include <sm/string.h>
d70 4
a73 2
#include <sm/conf.h>
#include <sm/errstring.h>
d77 3
a79 3
# ifdef SMRSH_CMDDIR
#  define CMDDIR	SMRSH_CMDDIR
# else /* SMRSH_CMDDIR */
d81 1
a81 1
# endif /* SMRSH_CMDDIR */
d89 1
a89 5
# ifdef SMRSH_PATH
#  define PATH		SMRSH_PATH
# else /* SMRSH_PATH */
#  define PATH		"/bin:/usr/bin:/usr/ucb"
# endif /* SMRSH_PATH */
d92 7
d118 2
a119 2
	bool cmd;
	size_t len;
d127 1
a127 2
		(void)sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				    "%s: command too long: %s\n", prg, par);
d135 2
a136 2
		(void) sm_strlcat(newcmdbuf, CMDDIR, sizeof newcmdbuf);
		(void) sm_strlcat(newcmdbuf, "/", sizeof newcmdbuf);
d138 1
a138 1
	(void) sm_strlcat(newcmdbuf, s, sizeof newcmdbuf);
d150 1
d166 2
a167 2
	(void) sm_strlcpy(pathbuf, "PATH=", sizeof pathbuf);
	(void) sm_strlcat(pathbuf, PATH, sizeof pathbuf);
d176 1
d180 1
a180 2
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				     "Usage: %s -c command\n", prg);
a186 2
	par = argv[2];

d201 1
a201 1
	(void) sm_strlcpy(specialbuf, SPECIALS, sizeof specialbuf);
d204 1
a204 1
	(void) sm_strlcat(specialbuf, SPECIALS, sizeof specialbuf);
d210 2
a211 1
	if (strlen(par) > (sizeof newcmdbuf - sizeof CMDDIR - 2))
d213 1
a213 2
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				     "%s: command too long: %s\n", prg, par);
d222 1
a222 1
	isexec = false;
d238 2
a239 3
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: missing command to exec\n",
						     prg);
d241 1
a241 1
				syslog(LOG_CRIT, "uid %d: missing command to exec", (int) getuid());
d271 1
a271 1
			addcmd("exec ", false, strlen("exec "));
d274 1
a274 1
			isexec = true;
d279 1
a279 1
			addcmd(cmd, false, strlen(cmd));
d287 3
a289 3
			(void) sm_strlcpy(cmdbuf, CMDDIR, sizeof cmdbuf);
			(void) sm_strlcat(cmdbuf, "/", sizeof cmdbuf);
			(void) sm_strlcat(cmdbuf, cmd, sizeof cmdbuf);
d291 1
a291 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Trying %s\n", cmdbuf);
d296 3
a298 3
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "%s: %s not available for sendmail programs\n",
						      prg, cmd);
d303 1
a303 1
				       (int) getuid(), cmd);
d312 1
a312 1
			addcmd(cmd, true, strlen(cmd));
d314 1
a314 1
		isexec = false;
d322 2
a323 3
		if (r == NULL)
		{
			addcmd(p, false, strlen(p));
d327 2
a328 3
		if (*r == ';')
		{
			addcmd(p, false,  r - p + 1);
d336 1
a336 1
			addcmd(p, false,  r - p + 2);
d341 1
a341 2
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				     "%s: cannot use %c in command\n", prg, *r);
d344 1
a344 1
		       (int) getuid(), *r, par);
d350 1
a350 2
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				     "%s: missing command to exec\n", prg);
d352 1
a352 2
		syslog(LOG_CRIT, "uid %d: missing command to exec",
		       (int) getuid());
d359 1
a359 2
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				     "Usage: %s -c command\n", prg);
d371 1
a371 1
	(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s\n", newcmdbuf);
d376 1
a376 1
	syslog(LOG_CRIT, "Cannot exec /bin/sh: %s", sm_errstring(errno));
d379 1
a379 1
	sm_perror("/bin/sh");
@


