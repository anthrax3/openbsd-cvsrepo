head	1.22;
access;
symbols
	OPENBSD_5_6:1.21.0.6
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.20.0.22
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.20
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.18
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.16
	OPENBSD_5_0:1.20.0.14
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.12
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.10
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.6
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.8
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.4
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.19.0.6
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.4
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.18.0.8
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.6
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.4
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.21;
commitid	M7i5giHIoz3DMlTU;

1.21
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.16.00.21.30;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2004.06.24.03.59.26;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.09.17.17.31.40;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.12.01.07.31;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.29.19.44.00;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.03.17.31.21;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.01.19.59.22;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.03.17.25.46;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.18.00.49.27;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.05.22.32.30;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.01.01.01.41;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.28.02.43.52;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.15.21.09.05;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.07.19.20.36;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.42;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.42;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.08;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.49;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.29.55;	author miod;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2004 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sm/gen.h>

SM_IDSTR(copyright,
"@@(#) Copyright (c) 1998-2004 Proofpoint, Inc. and its suppliers.\n\
	All rights reserved.\n\
     Copyright (c) 1990, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n")

SM_IDSTR(id, "@@(#)$Sendmail: mail.local.c,v 8.257 2013/11/22 20:51:51 ca Exp $")

#include <stdlib.h>
#include <sm/errstring.h>
#include <sm/io.h>
#include <sm/limits.h>
# include <unistd.h>
# ifdef EX_OK
#  undef EX_OK		/* unistd.h may have another use for this */
# endif /* EX_OK */
# define LOCKFILE_PMODE 0
#include <sm/mbdb.h>
#include <sm/sysexits.h>

#ifndef HASHSPOOL
# define HASHSPOOL	0
#endif /* ! HASHSPOOL */
#ifndef HASHSPOOLMD5
# define HASHSPOOLMD5	0
#endif /* ! HASHSPOOLMD5 */

/*
**  This is not intended to work on System V derived systems
**  such as Solaris or HP-UX, since they use a totally different
**  approach to mailboxes (essentially, they have a set-group-ID program
**  rather than set-user-ID, and they rely on the ability to "give away"
**  files to do their work).  IT IS NOT A BUG that this doesn't
**  work on such architectures.
*/


#include <stdio.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <time.h>
#include <stdlib.h>
# include <sys/socket.h>
# include <sys/file.h>
# include <netinet/in.h>
# include <arpa/nameser.h>
# include <netdb.h>
# include <pwd.h>

#include <sm/string.h>
#include <syslog.h>
#include <ctype.h>

#include <sm/conf.h>
#include <sendmail/pathnames.h>

#if HASHSPOOL
# define HASH_NONE	0
# define HASH_USER	1
# if HASHSPOOLMD5
#  define HASH_MD5	2
#  include <openssl/md5.h>
# endif /* HASHSPOOLMD5 */
#endif /* HASHSPOOL */

#if _FFR_SPOOL_PATH
	/*
	**  Override path to mail store at run time (using -p).
	**  From: Eugene Grosbein of Svyaz Service JSC
	**  See: http://www.freebsd.org/cgi/query-pr.cgi?pr=bin/114195
	**  NOTE: Update man page before adding this to a release.
	*/
#endif /* _FFR_SPOOL_PATH */


#ifndef LOCKTO_RM
# define LOCKTO_RM	300	/* timeout for stale lockfile removal */
#endif /* ! LOCKTO_RM */
#ifndef LOCKTO_GLOB
# define LOCKTO_GLOB	400	/* global timeout for lockfile creation */
#endif /* ! LOCKTO_GLOB */

/* define a realloc() which works for NULL pointers */
#define REALLOC(ptr, size)	(((ptr) == NULL) ? malloc(size) : realloc(ptr, size))

/*
**  If you don't have flock, you could try using lockf instead.
*/

#ifdef LDA_USE_LOCKF
# define flock(a, b)	lockf(a, b, 0)
# ifdef LOCK_EX
#  undef LOCK_EX
# endif /* LOCK_EX */
# define LOCK_EX	F_LOCK
#endif /* LDA_USE_LOCKF */

#ifndef LOCK_EX
# include <sys/file.h>
#endif /* ! LOCK_EX */

/*
**  If you don't have setreuid, and you have saved uids, and you have
**  a seteuid() call that doesn't try to emulate using setuid(), then
**  you can try defining LDA_USE_SETEUID.
*/

#ifdef LDA_USE_SETEUID
# define setreuid(r, e)		seteuid(e)
#endif /* LDA_USE_SETEUID */

#ifdef LDA_CONTENTLENGTH
# define CONTENTLENGTH	1
#endif /* LDA_CONTENTLENGTH */

#ifndef INADDRSZ
# define INADDRSZ	4		/* size of an IPv4 address in bytes */
#endif /* ! INADDRSZ */

#ifdef MAILLOCK
# include <maillock.h>
#endif /* MAILLOCK */

#ifndef MAILER_DAEMON
# define MAILER_DAEMON	"MAILER-DAEMON"
#endif /* ! MAILER_DAEMON */

#ifdef CONTENTLENGTH
char	ContentHdr[40] = "Content-Length: ";
off_t	HeaderLength;
off_t	BodyLength;
#endif /* CONTENTLENGTH */

bool	EightBitMime = true;		/* advertise 8BITMIME in LMTP */
char	ErrBuf[10240];			/* error buffer */
int	ExitVal = EX_OK;		/* sysexits.h error value. */
bool	HoldErrs = false;		/* Hold errors in ErrBuf */
bool	LMTPMode = false;
bool	BounceQuota = false;		/* permanent error when over quota */
bool	CloseMBDB = false;
char	*HomeMailFile = NULL;		/* store mail in homedir */

#if HASHSPOOL
int	HashType = HASH_NONE;
int	HashDepth = 0;
bool	StripRcptDomain = true;
#else /* HASHSPOOL */
# define StripRcptDomain true
#endif /* HASHSPOOL */
char	SpoolPath[MAXPATHLEN];

char	*parseaddr __P((char *, bool));
char	*process_recipient __P((char *));
void	dolmtp __P((void));
void	deliver __P((int, char *));
int	e_to_sys __P((int));
void	notifybiff __P((char *));
int	store __P((char *, bool *));
void	usage __P((void));
int	lockmbox __P((char *));
void	unlockmbox __P((void));
void	mailerr __P((const char *, const char *, ...));
void	flush_error __P((void));
#if HASHSPOOL
const char	*hashname __P((char *));
#endif /* HASHSPOOL */


static void sm_exit __P((int));

static void
sm_exit(status)
	int status;
{
	if (CloseMBDB)
	{
		sm_mbdb_terminate();
		CloseMBDB = false;	/* not really necessary, but ... */
	}
	exit(status);
}

int
main(argc, argv)
	int argc;
	char *argv[];
{
	struct passwd *pw;
	int ch, fd;
	uid_t uid;
	char *from;
	char *mbdbname = "pw";
	int err;
	extern char *optarg;
	extern int optind;


	/* make sure we have some open file descriptors */
	for (fd = 10; fd < 30; fd++)
		(void) close(fd);

	/* use a reasonable umask */
	(void) umask(0077);

# ifdef LOG_MAIL
	openlog("mail.local", 0, LOG_MAIL);
# else /* LOG_MAIL */
	openlog("mail.local", 0);
# endif /* LOG_MAIL */

	from = NULL;

	/* XXX can this be converted to a compile time check? */
	if (sm_strlcpy(SpoolPath, _PATH_MAILDIR, sizeof(SpoolPath)) >=
	    sizeof(SpoolPath))
	{
		mailerr("421", "Configuration error: _PATH_MAILDIR too large");
		sm_exit(EX_CONFIG);
	}
#if HASHSPOOL
	while ((ch = getopt(argc, argv, "7bdD:f:h:r:lH:p:n")) != -1)
#else /* HASHSPOOL */
#  if _FFR_SPOOL_PATH
	while ((ch = getopt(argc, argv, "7bdD:f:h:r:lp:")) != -1)
#  else /* _FFR_SPOOL_PATH */
	while ((ch = getopt(argc, argv, "7bdD:f:h:r:l")) != -1)
#  endif /* _FFR_SPOOL_PATH */
#endif /* HASHSPOOL */
	{
		switch(ch)
		{
		  case '7':		/* Do not advertise 8BITMIME */
			EightBitMime = false;
			break;

		  case 'b':		/* bounce mail when over quota. */
			BounceQuota = true;
			break;

		  case 'd':		/* Backward compatible. */
			break;

		  case 'D':		/* mailbox database type */
			mbdbname = optarg;
			break;

		  case 'f':
		  case 'r':		/* Backward compatible. */
			if (from != NULL)
			{
				mailerr(NULL, "Multiple -f options");
				usage();
			}
			from = optarg;
			break;

		  case 'h':
			if (optarg != NULL || *optarg != '\0')
				HomeMailFile = optarg;
			else
			{
				mailerr(NULL, "-h: missing filename");
				usage();
			}
			break;

		  case 'l':
			LMTPMode = true;
			break;


#if HASHSPOOL
		  case 'H':
			if (optarg == NULL || *optarg == '\0')
			{
				mailerr(NULL, "-H: missing hashinfo");
				usage();
			}
			switch(optarg[0])
			{
			  case 'u':
				HashType = HASH_USER;
				break;

# if HASHSPOOLMD5
			  case 'm':
				HashType = HASH_MD5;
				break;
# endif /* HASHSPOOLMD5 */

			  default:
				mailerr(NULL, "-H: unknown hash type");
				usage();
			}
			if (optarg[1] == '\0')
			{
				mailerr(NULL, "-H: invalid hash depth");
				usage();
			}
			HashDepth = atoi(&optarg[1]);
			if ((HashDepth <= 0) || ((HashDepth * 2) >= MAXPATHLEN))
			{
				mailerr(NULL, "-H: invalid hash depth");
				usage();
			}
			break;

		  case 'n':
			StripRcptDomain = false;
			break;
#endif /* HASHSPOOL */

#if HASHSPOOL || _FFR_SPOOL_PATH
		  case 'p':
			if (optarg == NULL || *optarg == '\0')
			{
				mailerr(NULL, "-p: missing spool path");
				usage();
			}
			if (sm_strlcpy(SpoolPath, optarg, sizeof(SpoolPath)) >=
			    sizeof(SpoolPath))
			{
				mailerr(NULL, "-p: invalid spool path");
				usage();
			}
			break;
#endif /* HASHSPOOL || _FFR_SPOOL_PATH */

		  case '?':
		  default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	/* initialize biff structures */
	notifybiff(NULL);

	err = sm_mbdb_initialize(mbdbname);
	if (err != EX_OK)
	{
		char *errcode = "521";

		if (err == EX_TEMPFAIL)
			errcode = "421";

		mailerr(errcode, "Can not open mailbox database %s: %s",
			mbdbname, sm_strexit(err));
		sm_exit(err);
	}
	CloseMBDB = true;

	if (LMTPMode)
	{
		if (argc > 0)
		{
			mailerr("421", "Users should not be specified in command line if LMTP required");
			sm_exit(EX_TEMPFAIL);
		}

		dolmtp();
		/* NOTREACHED */
		sm_exit(EX_OK);
	}

	/* Non-LMTP from here on out */
	if (*argv == '\0')
		usage();

	/*
	**  If from not specified, use the name from getlogin() if the
	**  uid matches, otherwise, use the name from the password file
	**  corresponding to the uid.
	*/

	uid = getuid();
	if (from == NULL && ((from = getlogin()) == NULL ||
			     (pw = getpwnam(from)) == NULL ||
			     pw->pw_uid != uid))
		from = (pw = getpwuid(uid)) != NULL ? pw->pw_name : "???";

	/*
	**  There is no way to distinguish the error status of one delivery
	**  from the rest of the deliveries.  So, if we failed hard on one
	**  or more deliveries, but had no failures on any of the others, we
	**  return a hard failure.  If we failed temporarily on one or more
	**  deliveries, we return a temporary failure regardless of the other
	**  failures.  This results in the delivery being reattempted later
	**  at the expense of repeated failures and multiple deliveries.
	*/

	HoldErrs = true;
	fd = store(from, NULL);
	HoldErrs = false;
	if (fd < 0)
	{
		flush_error();
		sm_exit(ExitVal);
	}
	for (; *argv != NULL; ++argv)
		deliver(fd, *argv);
	sm_exit(ExitVal);
	/* NOTREACHED */
	return ExitVal;
}

char *
parseaddr(s, rcpt)
	char *s;
	bool rcpt;
{
	char *p;
	int l;

	if (*s++ != '<')
		return NULL;

	p = s;

	/* at-domain-list */
	while (*p == '@@')
	{
		p++;
		while (*p != ',' && *p != ':' && *p != '\0')
			p++;
		if (*p == '\0')
			return NULL;

		/* Skip over , or : */
		p++;
	}

	s = p;

	/* local-part */
	while (*p != '\0' && *p != '@@' && *p != '>')
	{
		if (*p == '\\')
		{
			if (*++p == '\0')
				return NULL;
		}
		else if (*p == '\"')
		{
			p++;
			while (*p != '\0' && *p != '\"')
			{
				if (*p == '\\')
				{
					if (*++p == '\0')
						return NULL;
				}
				p++;
			}
			if (*p == '\0' || *(p + 1) == '\0')
				return NULL;
		}
		/* +detail ? */
		if (*p == '+' && rcpt)
			*p = '\0';
		p++;
	}

	/* @@domain */
	if (*p == '@@')
	{
		if (rcpt)
			*p++ = '\0';
		while (*p != '\0' && *p != '>')
			p++;
	}

	if (*p != '>')
		return NULL;
	else
		*p = '\0';
	p++;

	if (*p != '\0' && *p != ' ')
		return NULL;

	if (*s == '\0')
		s = MAILER_DAEMON;

	l = strlen(s) + 1;
	if (l < 0)
		return NULL;
	p = malloc(l);
	if (p == NULL)
	{
		mailerr("421 4.3.0", "Memory exhausted");
		sm_exit(EX_TEMPFAIL);
	}

	(void) sm_strlcpy(p, s, l);
	return p;
}

char *
process_recipient(addr)
	char *addr;
{
	SM_MBDB_T user;

	switch (sm_mbdb_lookup(addr, &user))
	{
	  case EX_OK:
		return NULL;

	  case EX_NOUSER:
		return "550 5.1.1 User unknown";

	  case EX_TEMPFAIL:
		return "451 4.3.0 User database failure; retry later";

	  default:
		return "550 5.3.0 User database failure";
	}
}

#define RCPT_GROW	30

void
dolmtp()
{
	char *return_path = NULL;
	char **rcpt_addr = NULL;
	int rcpt_num = 0;
	int rcpt_alloc = 0;
	bool gotlhlo = false;
	char *err;
	int msgfd;
	char *p;
	int i;
	char myhostname[1024];
	char buf[4096];

	memset(myhostname, '\0', sizeof myhostname);
	(void) gethostname(myhostname, sizeof myhostname - 1);
	if (myhostname[0] == '\0')
		sm_strlcpy(myhostname, "localhost", sizeof myhostname);

	printf("220 %s LMTP ready\r\n", myhostname);
	for (;;)
	{
		(void) fflush(stdout);
		if (fgets(buf, sizeof(buf) - 1, stdin) == NULL)
			sm_exit(EX_OK);
		p = buf + strlen(buf) - 1;
		if (p >= buf && *p == '\n')
			*p-- = '\0';
		if (p >= buf && *p == '\r')
			*p-- = '\0';

		switch (buf[0])
		{
		  case 'd':
		  case 'D':
			if (sm_strcasecmp(buf, "data") == 0)
			{
				bool inbody = false;

				if (rcpt_num == 0)
				{
					mailerr("503 5.5.1", "No recipients");
					continue;
				}
				HoldErrs = true;
				msgfd = store(return_path, &inbody);
				HoldErrs = false;
				if (msgfd < 0 && !inbody)
				{
					flush_error();
					continue;
				}

				for (i = 0; i < rcpt_num; i++)
				{
					if (msgfd < 0)
					{
						/* print error for rcpt */
						flush_error();
						continue;
					}
					p = strchr(rcpt_addr[i], '+');
					if (p != NULL)
						*p = '\0';
					deliver(msgfd, rcpt_addr[i]);
				}
				if (msgfd >= 0)
					(void) close(msgfd);
				goto rset;
			}
			goto syntaxerr;
			/* NOTREACHED */
			break;

		  case 'l':
		  case 'L':
			if (sm_strncasecmp(buf, "lhlo ", 5) == 0)
			{
				/* check for duplicate per RFC 1651 4.2 */
				if (gotlhlo)
				{
					mailerr("503", "%s Duplicate LHLO",
					       myhostname);
					continue;
				}
				gotlhlo = true;
				printf("250-%s\r\n", myhostname);
				if (EightBitMime)
					printf("250-8BITMIME\r\n");
				printf("250-ENHANCEDSTATUSCODES\r\n");
				printf("250 PIPELINING\r\n");
				continue;
			}
			goto syntaxerr;
			/* NOTREACHED */
			break;

		  case 'm':
		  case 'M':
			if (sm_strncasecmp(buf, "mail ", 5) == 0)
			{
				if (return_path != NULL)
				{
					mailerr("503 5.5.1",
						"Nested MAIL command");
					continue;
				}
				if (sm_strncasecmp(buf + 5, "from:", 5) != 0 ||
				    ((return_path = parseaddr(buf + 10,
							      false)) == NULL))
				{
					mailerr("501 5.5.4",
						"Syntax error in parameters");
					continue;
				}
				printf("250 2.5.0 Ok\r\n");
				continue;
			}
			goto syntaxerr;
			/* NOTREACHED */
			break;

		  case 'n':
		  case 'N':
			if (sm_strcasecmp(buf, "noop") == 0)
			{
				printf("250 2.0.0 Ok\r\n");
				continue;
			}
			goto syntaxerr;
			/* NOTREACHED */
			break;

		  case 'q':
		  case 'Q':
			if (sm_strcasecmp(buf, "quit") == 0)
			{
				printf("221 2.0.0 Bye\r\n");
				sm_exit(EX_OK);
			}
			goto syntaxerr;
			/* NOTREACHED */
			break;

		  case 'r':
		  case 'R':
			if (sm_strncasecmp(buf, "rcpt ", 5) == 0)
			{
				if (return_path == NULL)
				{
					mailerr("503 5.5.1",
						"Need MAIL command");
					continue;
				}
				if (rcpt_num >= rcpt_alloc)
				{
					rcpt_alloc += RCPT_GROW;
					rcpt_addr = (char **)
						REALLOC((char *) rcpt_addr,
							rcpt_alloc *
							sizeof(char **));
					if (rcpt_addr == NULL)
					{
						mailerr("421 4.3.0",
							"Memory exhausted");
						sm_exit(EX_TEMPFAIL);
					}
				}
				if (sm_strncasecmp(buf + 5, "to:", 3) != 0 ||
				    ((rcpt_addr[rcpt_num] = parseaddr(buf + 8,
								      StripRcptDomain)) == NULL))
				{
					mailerr("501 5.5.4",
						"Syntax error in parameters");
					continue;
				}
				err = process_recipient(rcpt_addr[rcpt_num]);
				if (err != NULL)
				{
					mailerr(NULL, "%s", err);
					continue;
				}
				rcpt_num++;
				printf("250 2.1.5 Ok\r\n");
				continue;
			}
			else if (sm_strcasecmp(buf, "rset") == 0)
			{
				printf("250 2.0.0 Ok\r\n");

rset:
				while (rcpt_num > 0)
					free(rcpt_addr[--rcpt_num]);
				if (return_path != NULL)
					free(return_path);
				return_path = NULL;
				continue;
			}
			goto syntaxerr;
			/* NOTREACHED */
			break;

		  case 'v':
		  case 'V':
			if (sm_strncasecmp(buf, "vrfy ", 5) == 0)
			{
				printf("252 2.3.3 Try RCPT to attempt delivery\r\n");
				continue;
			}
			goto syntaxerr;
			/* NOTREACHED */
			break;

		  default:
  syntaxerr:
			mailerr("500 5.5.2", "Syntax error");
			continue;
			/* NOTREACHED */
			break;
		}
	}
}

int
store(from, inbody)
	char *from;
	bool *inbody;
{
	FILE *fp = NULL;
	time_t tval;
	bool eline;		/* previous line was empty */
	bool fullline = true;	/* current line is terminated */
	bool prevfl;		/* previous line was terminated */
	char line[2048];
	int fd;
	char tmpbuf[sizeof _PATH_LOCTMP + 1];

	if (inbody != NULL)
		*inbody = false;

	(void) umask(0077);
	(void) sm_strlcpy(tmpbuf, _PATH_LOCTMP, sizeof tmpbuf);
	if ((fd = mkstemp(tmpbuf)) < 0 || (fp = fdopen(fd, "w+")) == NULL)
	{
		if (fd >= 0)
			(void) close(fd);
		mailerr("451 4.3.0", "Unable to open temporary file");
		return -1;
	}
	(void) unlink(tmpbuf);

	if (LMTPMode)
	{
		printf("354 Go ahead\r\n");
		(void) fflush(stdout);
	}
	if (inbody != NULL)
		*inbody = true;

	(void) time(&tval);
	(void) fprintf(fp, "From %s %s", from, ctime(&tval));

#ifdef CONTENTLENGTH
	HeaderLength = 0;
	BodyLength = -1;
#endif /* CONTENTLENGTH */

	line[0] = '\0';
	eline = true;
	while (fgets(line, sizeof(line), stdin) != (char *) NULL)
	{
		size_t line_len = 0;
		int peek;

		prevfl = fullline;	/* preserve state of previous line */
		while (line[line_len] != '\n' && line_len < sizeof(line) - 2)
			line_len++;
		line_len++;

		/* Check for dot-stuffing */
		if (prevfl && LMTPMode && line[0] == '.')
		{
			if (line[1] == '\n' ||
			    (line[1] == '\r' && line[2] == '\n'))
				goto lmtpdot;
			memcpy(line, line + 1, line_len);
			line_len--;
		}

		/* Check to see if we have the full line from fgets() */
		fullline = false;
		if (line_len > 0)
		{
			if (line[line_len - 1] == '\n')
			{
				if (line_len >= 2 &&
				    line[line_len - 2] == '\r')
				{
					line[line_len - 2] = '\n';
					line[line_len - 1] = '\0';
					line_len--;
				}
				fullline = true;
			}
			else if (line[line_len - 1] == '\r')
			{
				/* Did we just miss the CRLF? */
				peek = fgetc(stdin);
				if (peek == '\n')
				{
					line[line_len - 1] = '\n';
					fullline = true;
				}
				else
					(void) ungetc(peek, stdin);
			}
		}
		else
			fullline = true;

#ifdef CONTENTLENGTH
		if (prevfl && line[0] == '\n' && HeaderLength == 0)
		{
			eline = false;
			if (fp != NULL)
				HeaderLength = ftell(fp);
			if (HeaderLength <= 0)
			{
				/*
				**  shouldn't happen, unless ftell() is
				**  badly broken
				*/

				HeaderLength = -1;
			}
		}
#else /* CONTENTLENGTH */
		if (prevfl && line[0] == '\n')
			eline = true;
#endif /* CONTENTLENGTH */
		else
		{
			if (eline && line[0] == 'F' &&
			    fp != NULL &&
			    !memcmp(line, "From ", 5))
				(void) putc('>', fp);
			eline = false;
#ifdef CONTENTLENGTH
			/* discard existing "Content-Length:" headers */
			if (prevfl && HeaderLength == 0 &&
			    (line[0] == 'C' || line[0] == 'c') &&
			    sm_strncasecmp(line, ContentHdr, 15) == 0)
			{
				/*
				**  be paranoid: clear the line
				**  so no "wrong matches" may occur later
				*/
				line[0] = '\0';
				continue;
			}
#endif /* CONTENTLENGTH */

		}
		if (fp != NULL)
		{
			(void) fwrite(line, sizeof(char), line_len, fp);
			if (ferror(fp))
			{
				mailerr("451 4.3.0",
					"Temporary file write error");
				(void) fclose(fp);
				fp = NULL;
				continue;
			}
		}
	}

	/* check if an error occurred */
	if (fp == NULL)
		return -1;

	if (LMTPMode)
	{
		/* Got a premature EOF -- toss message and exit */
		sm_exit(EX_OK);
	}

	/* If message not newline terminated, need an extra. */
	if (fp != NULL && strchr(line, '\n') == NULL)
		(void) putc('\n', fp);

  lmtpdot:

#ifdef CONTENTLENGTH
	if (fp != NULL)
		BodyLength = ftell(fp);
	if (HeaderLength == 0 && BodyLength > 0)	/* empty body */
	{
		HeaderLength = BodyLength;
		BodyLength = 0;
	}
	else
		BodyLength = BodyLength - HeaderLength - 1 ;

	if (HeaderLength > 0 && BodyLength >= 0)
	{
		(void) sm_snprintf(line, sizeof line, "%lld\n",
				   (LONGLONG_T) BodyLength);
		(void) sm_strlcpy(&ContentHdr[16], line,
				  sizeof(ContentHdr) - 16);
	}
	else
		BodyLength = -1;	/* Something is wrong here */
#endif /* CONTENTLENGTH */

	/* Output a newline; note, empty messages are allowed. */
	if (fp != NULL)
		(void) putc('\n', fp);

	if (fp == NULL || fflush(fp) == EOF || ferror(fp) != 0)
	{
		mailerr("451 4.3.0", "Temporary file write error");
		if (fp != NULL)
			(void) fclose(fp);
		return -1;
	}
	return fd;
}

void
deliver(fd, name)
	int fd;
	char *name;
{
	struct stat fsb;
	struct stat sb;
	char path[MAXPATHLEN];
	int mbfd = -1, nr = 0, nw, off;
	int exitval;
	char *p;
	char *errcode;
	off_t curoff, cursize;
#ifdef CONTENTLENGTH
	off_t headerbytes;
	int readamount;
#endif /* CONTENTLENGTH */
	char biffmsg[100], buf[8 * 1024];
	SM_MBDB_T user;

	/*
	**  Disallow delivery to unknown names -- special mailboxes can be
	**  handled in the sendmail aliases file.
	*/

	exitval = sm_mbdb_lookup(name, &user);
	switch (exitval)
	{
	  case EX_OK:
		break;

	  case EX_NOUSER:
		exitval = EX_UNAVAILABLE;
		mailerr("550 5.1.1", "%s: User unknown", name);
		break;

	  case EX_TEMPFAIL:
		mailerr("451 4.3.0", "%s: User database failure; retry later",
			name);
		break;

	  default:
		exitval = EX_UNAVAILABLE;
		mailerr("550 5.3.0", "%s: User database failure", name);
		break;
	}

	if (exitval != EX_OK)
	{
		if (ExitVal != EX_TEMPFAIL)
			ExitVal = exitval;
		return;
	}

	endpwent();

	/*
	**  Keep name reasonably short to avoid buffer overruns.
	**	This isn't necessary on BSD because of the proper
	**	definition of snprintf(), but it can cause problems
	**	on other systems.
	**  Also, clear out any bogus characters.
	*/

#if !HASHSPOOL
	if (strlen(name) > 40)
		name[40] = '\0';
	for (p = name; *p != '\0'; p++)
	{
		if (!isascii(*p))
			*p &= 0x7f;
		else if (!isprint(*p))
			*p = '.';
	}
#endif /* !HASHSPOOL */


	if (HomeMailFile == NULL)
	{
		if (sm_strlcpyn(path, sizeof(path), 
#if HASHSPOOL
				4,
#else /* HASHSPOOL */
				3,
#endif /* HASHSPOOL */
				SpoolPath, "/",
#if HASHSPOOL
				hashname(name),
#endif /* HASHSPOOL */
				name) >= sizeof(path))
		{
			exitval = EX_UNAVAILABLE;
			mailerr("550 5.1.1", "%s: Invalid mailbox path", name);
			return;
		}
	}
	else if (*user.mbdb_homedir == '\0')
	{
		exitval = EX_UNAVAILABLE;
		mailerr("550 5.1.1", "%s: User missing home directory", name);
		return;
	}
	else if (sm_snprintf(path, sizeof(path), "%s/%s",
			     user.mbdb_homedir, HomeMailFile) >= sizeof(path))
	{
		exitval = EX_UNAVAILABLE;
		mailerr("550 5.1.1", "%s: Invalid mailbox path", name);
		return;
	}


	/*
	**  If the mailbox is linked or a symlink, fail.  There's an obvious
	**  race here, that the file was replaced with a symbolic link after
	**  the lstat returned, but before the open.  We attempt to detect
	**  this by comparing the original stat information and information
	**  returned by an fstat of the file descriptor returned by the open.
	**
	**  NB: this is a symptom of a larger problem, that the mail spooling
	**  directory is writeable by the wrong users.  If that directory is
	**  writeable, system security is compromised for other reasons, and
	**  it cannot be fixed here.
	**
	**  If we created the mailbox, set the owner/group.  If that fails,
	**  just return.  Another process may have already opened it, so we
	**  can't unlink it.  Historically, binmail set the owner/group at
	**  each mail delivery.  We no longer do this, assuming that if the
	**  ownership or permissions were changed there was a reason.
	**
	**  XXX
	**  open(2) should support flock'ing the file.
	*/

tryagain:
#ifdef MAILLOCK
	p = name;
#else /* MAILLOCK */
	p = path;
#endif /* MAILLOCK */
	if ((off = lockmbox(p)) != 0)
	{
		if (off == EX_TEMPFAIL || e_to_sys(off) == EX_TEMPFAIL)
		{
			ExitVal = EX_TEMPFAIL;
			errcode = "451 4.3.0";
		}
		else
			errcode = "551 5.3.0";

		mailerr(errcode, "lockmailbox %s failed; error code %d %s",
			p, off, errno > 0 ? sm_errstring(errno) : "");
		return;
	}

	if (lstat(path, &sb) < 0)
	{
		int save_errno;
		int mode = S_IRUSR|S_IWUSR;
		gid_t gid = user.mbdb_gid;

#ifdef MAILGID
		(void) umask(0007);
		gid = MAILGID;
		mode |= S_IRGRP|S_IWGRP;
#endif /* MAILGID */

		mbfd = open(path, O_APPEND|O_CREAT|O_EXCL|O_WRONLY,
			    mode);
		save_errno = errno;

		if (lstat(path, &sb) < 0)
		{
			ExitVal = EX_CANTCREAT;
			mailerr("550 5.2.0",
				"%s: lstat: file changed after open", path);
			goto err1;
		}
		if (mbfd < 0)
		{
			if (save_errno == EEXIST)
				goto tryagain;

			/* open failed, don't try again */
			mailerr("450 4.2.0", "%s: %s", path,
				sm_errstring(save_errno));
			goto err0;
		}
		else if (fchown(mbfd, user.mbdb_uid, gid) < 0)
		{
			mailerr("451 4.3.0", "chown %u.%u: %s",
				user.mbdb_uid, gid, name);
			goto err1;
		}
		else
		{
			/*
			**  open() was successful, now close it so can
			**  be opened as the right owner again.
			**  Paranoia: reset mbdf since the file descriptor
			**  is no longer valid; better safe than sorry.
			*/

			sb.st_uid = user.mbdb_uid;
			(void) close(mbfd);
			mbfd = -1;
		}
	}
	else if (sb.st_nlink != 1)
	{
		mailerr("550 5.2.0", "%s: too many links", path);
		goto err0;
	}
	else if (!S_ISREG(sb.st_mode))
	{
		mailerr("550 5.2.0", "%s: irregular file", path);
		goto err0;
	}
	else if (sb.st_uid != user.mbdb_uid)
	{
		ExitVal = EX_CANTCREAT;
		mailerr("550 5.2.0", "%s: wrong ownership (%d)",
			path, (int) sb.st_uid);
		goto err0;
	}

	/* change UID for quota checks */
	if (setreuid(0, user.mbdb_uid) < 0)
	{
		mailerr("450 4.2.0", "setreuid(0, %d): %s (r=%d, e=%d)",
			(int) user.mbdb_uid, sm_errstring(errno),
			(int) getuid(), (int) geteuid());
		goto err1;
	}
#ifdef DEBUG
	fprintf(stderr, "new euid = %d\n", (int) geteuid());
#endif /* DEBUG */
	mbfd = open(path, O_APPEND|O_WRONLY, 0);
	if (mbfd < 0)
	{
		mailerr("450 4.2.0", "%s: %s", path, sm_errstring(errno));
		goto err0;
	}
	else if (fstat(mbfd, &fsb) < 0 ||
		 fsb.st_nlink != 1 ||
		 sb.st_nlink != 1 ||
		 !S_ISREG(fsb.st_mode) ||
		 sb.st_dev != fsb.st_dev ||
		 sb.st_ino != fsb.st_ino ||
# if HAS_ST_GEN && 0		/* AFS returns random values for st_gen */
		 sb.st_gen != fsb.st_gen ||
# endif /* HAS_ST_GEN && 0 */
		 sb.st_uid != fsb.st_uid)
	{
		ExitVal = EX_TEMPFAIL;
		mailerr("550 5.2.0", "%s: fstat: file changed after open",
			path);
		goto err1;
	}

#if 0
	/*
	**  This code could be reused if we decide to add a
	**  per-user quota field to the sm_mbdb interface.
	*/

	/*
	**  Fail if the user has a quota specified, and delivery of this
	**  message would exceed that quota.  We bounce such failures using
	**  EX_UNAVAILABLE, unless there were internal problems, since
	**  storing immense messages for later retries can cause queueing
	**  issues.
	*/

	if (ui.quota > 0)
	{
		struct stat dsb;

		if (fstat(fd, &dsb) < 0)
		{
			ExitVal = EX_TEMPFAIL;
			mailerr("451 4.3.0",
				"%s: fstat: can't stat temporary storage: %s",
				ui.mailspool, sm_errstring(errno));
			goto err1;
		}

		if (dsb.st_size + sb.st_size + 1 > ui.quota)
		{
			ExitVal = EX_UNAVAILABLE;
			mailerr("551 5.2.2",
				"%s: Mailbox full or quota exceeded",
				ui.mailspool);
			goto err1;
		}
	}
#endif /* 0 */

	/* Wait until we can get a lock on the file. */
	if (flock(mbfd, LOCK_EX) < 0)
	{
		mailerr("450 4.2.0", "%s: %s", path, sm_errstring(errno));
		goto err1;
	}

	/* Get the starting offset of the new message */
	curoff = lseek(mbfd, (off_t) 0, SEEK_END);
	(void) sm_snprintf(biffmsg, sizeof(biffmsg), "%s@@%lld\n",
			   name, (LONGLONG_T) curoff);

	/* Copy the message into the file. */
	if (lseek(fd, (off_t) 0, SEEK_SET) == (off_t) -1)
	{
		mailerr("450 4.2.0", "Temporary file: %s",
			sm_errstring(errno));
		goto err1;
	}
#ifdef DEBUG
	fprintf(stderr, "before writing: euid = %d\n", (int) geteuid());
#endif /* DEBUG */
#ifdef CONTENTLENGTH
	headerbytes = (BodyLength >= 0) ? HeaderLength : -1 ;
	for (;;)
	{
		if (headerbytes == 0)
		{
			(void) sm_snprintf(buf, sizeof buf, "%s", ContentHdr);
			nr = strlen(buf);
			headerbytes = -1;
			readamount = 0;
		}
		else if (headerbytes > sizeof(buf) || headerbytes < 0)
			readamount = sizeof(buf);
		else
			readamount = headerbytes;
		if (readamount != 0)
			nr = read(fd, buf, readamount);
		if (nr <= 0)
			break;
		if (headerbytes > 0)
			headerbytes -= nr ;

#else /* CONTENTLENGTH */
	while ((nr = read(fd, buf, sizeof(buf))) > 0)
	{
#endif /* CONTENTLENGTH */
		for (off = 0; off < nr; off += nw)
		{
			if ((nw = write(mbfd, buf + off, nr - off)) < 0)
			{
				errcode = "450 4.2.0";
#ifdef EDQUOT
				if (errno == EDQUOT && BounceQuota)
					errcode = "552 5.2.2";
#endif /* EDQUOT */
				mailerr(errcode, "%s: %s",
					path, sm_errstring(errno));
				goto err3;
			}
		}
	}
	if (nr < 0)
	{
		mailerr("450 4.2.0", "Temporary file: %s",
			sm_errstring(errno));
		goto err3;
	}

	/* Flush to disk, don't wait for update. */
	if (fsync(mbfd) < 0)
	{
		mailerr("450 4.2.0", "%s: %s", path, sm_errstring(errno));
err3:
#ifdef DEBUG
		fprintf(stderr, "reset euid = %d\n", (int) geteuid());
#endif /* DEBUG */
		if (mbfd >= 0)
			(void) ftruncate(mbfd, curoff);
err1:		if (mbfd >= 0)
			(void) close(mbfd);
err0:		(void) setreuid(0, 0);
		unlockmbox();
		return;
	}

	/*
	**  Save the current size so if the close() fails below
	**  we can make sure no other process has changed the mailbox
	**  between the failed close and the re-open()/re-lock().
	**  If something else has changed the size, we shouldn't
	**  try to truncate it as we may do more harm then good
	**  (e.g., truncate a later message delivery).
	*/

	if (fstat(mbfd, &sb) < 0)
		cursize = 0;
	else
		cursize = sb.st_size;


	/* Close and check -- NFS doesn't write until the close. */
	if (close(mbfd))
	{
		errcode = "450 4.2.0";
#ifdef EDQUOT
		if (errno == EDQUOT && BounceQuota)
			errcode = "552 5.2.2";
#endif /* EDQUOT */
		mailerr(errcode, "%s: %s", path, sm_errstring(errno));
		mbfd = open(path, O_WRONLY, 0);
		if (mbfd < 0 ||
		    cursize == 0
		    || flock(mbfd, LOCK_EX) < 0 ||
		    fstat(mbfd, &sb) < 0 ||
		    sb.st_size != cursize ||
		    sb.st_nlink != 1 ||
		    !S_ISREG(sb.st_mode) ||
		    sb.st_dev != fsb.st_dev ||
		    sb.st_ino != fsb.st_ino ||
# if HAS_ST_GEN && 0		/* AFS returns random values for st_gen */
		    sb.st_gen != fsb.st_gen ||
# endif /* HAS_ST_GEN && 0 */
		    sb.st_uid != fsb.st_uid
		   )
		{
			/* Don't use a bogus file */
			if (mbfd >= 0)
			{
				(void) close(mbfd);
				mbfd = -1;
			}
		}

		/* Attempt to truncate back to pre-write size */
		goto err3;
	}
	else
		notifybiff(biffmsg);

	if (setreuid(0, 0) < 0)
	{
		mailerr("450 4.2.0", "setreuid(0, 0): %s",
			sm_errstring(errno));
		goto err0;
	}
#ifdef DEBUG
	fprintf(stderr, "reset euid = %d\n", (int) geteuid());
#endif /* DEBUG */
	unlockmbox();
	if (LMTPMode)
		printf("250 2.1.5 %s Ok\r\n", name);
}

/*
**  user.lock files are necessary for compatibility with other
**  systems, e.g., when the mail spool file is NFS exported.
**  Alas, mailbox locking is more than just a local matter.
**  EPA 11/94.
*/

bool	Locked = false;

#ifdef MAILLOCK
int
lockmbox(name)
	char *name;
{
	int r = 0;

	if (Locked)
		return 0;
	if ((r = maillock(name, 15)) == L_SUCCESS)
	{
		Locked = true;
		return 0;
	}
	switch (r)
	{
	  case L_TMPLOCK:	/* Can't create tmp file */
	  case L_TMPWRITE:	/* Can't write pid into lockfile */
	  case L_MAXTRYS:	/* Failed after retrycnt attempts */
		errno = 0;
		r = EX_TEMPFAIL;
		break;
	  case L_ERROR:		/* Check errno for reason */
		r = errno;
		break;
	  default:		/* other permanent errors */
		errno = 0;
		r = EX_UNAVAILABLE;
		break;
	}
	return r;
}

void
unlockmbox()
{
	if (Locked)
		mailunlock();
	Locked = false;
}
#else /* MAILLOCK */

char	LockName[MAXPATHLEN];

int
lockmbox(path)
	char *path;
{
	int statfailed = 0;
	time_t start;

	if (Locked)
		return 0;
	if (strlen(path) + 6 > sizeof LockName)
		return EX_SOFTWARE;
	(void) sm_snprintf(LockName, sizeof LockName, "%s.lock", path);
	(void) time(&start);
	for (; ; sleep(5))
	{
		int fd;
		struct stat st;
		time_t now;

		/* global timeout */
		(void) time(&now);
		if (now > start + LOCKTO_GLOB)
		{
			errno = 0;
			return EX_TEMPFAIL;
		}
		fd = open(LockName, O_WRONLY|O_EXCL|O_CREAT, LOCKFILE_PMODE);
		if (fd >= 0)
		{
			/* defeat lock checking programs which test pid */
			(void) write(fd, "0", 2);
			Locked = true;
			(void) close(fd);
			return 0;
		}
		if (stat(LockName, &st) < 0)
		{
			if (statfailed++ > 5)
			{
				errno = 0;
				return EX_TEMPFAIL;
			}
			continue;
		}
		statfailed = 0;
		(void) time(&now);
		if (now < st.st_ctime + LOCKTO_RM)
			continue;

		/* try to remove stale lockfile */
		if (unlink(LockName) < 0)
			return errno;
	}
}

void
unlockmbox()
{
	if (!Locked)
		return;
	(void) unlink(LockName);
	Locked = false;
}
#endif /* MAILLOCK */

void
notifybiff(msg)
	char *msg;
{
	static bool initialized = false;
	static int f = -1;
	struct hostent *hp;
	struct servent *sp;
	int len;
	static struct sockaddr_in addr;

	if (!initialized)
	{
		initialized = true;

		/* Be silent if biff service not available. */
		if ((sp = getservbyname("biff", "udp")) == NULL ||
		    (hp = gethostbyname("localhost")) == NULL ||
		    hp->h_length != INADDRSZ)
			return;

		addr.sin_family = hp->h_addrtype;
		memcpy(&addr.sin_addr, hp->h_addr, INADDRSZ);
		addr.sin_port = sp->s_port;
	}

	/* No message, just return */
	if (msg == NULL)
		return;

	/* Couldn't initialize addr struct */
	if (addr.sin_family == AF_UNSPEC)
		return;

	if (f < 0 && (f = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
		return;
	len = strlen(msg) + 1;
	(void) sendto(f, msg, len, 0, (struct sockaddr *) &addr, sizeof(addr));
}

void
usage()
{
	ExitVal = EX_USAGE;
# if _FFR_SPOOL_PATH
	mailerr(NULL, "usage: mail.local [-7] [-b] [-d] [-l] [-f from|-r from] [-h filename] [-p path] user ...");
# else /* _FFR_SPOOL_PATH */
	mailerr(NULL, "usage: mail.local [-7] [-b] [-d] [-l] [-f from|-r from] [-h filename] user ...");
# endif /* _FFR_SPOOL_PATH */
	sm_exit(ExitVal);
}

void
/*VARARGS2*/
#ifdef __STDC__
mailerr(const char *hdr, const char *fmt, ...)
#else /* __STDC__ */
mailerr(hdr, fmt, va_alist)
	const char *hdr;
	const char *fmt;
	va_dcl
#endif /* __STDC__ */
{
	size_t len = 0;
	SM_VA_LOCAL_DECL

	(void) e_to_sys(errno);

	SM_VA_START(ap, fmt);

	if (LMTPMode && hdr != NULL)
	{
		sm_snprintf(ErrBuf, sizeof ErrBuf, "%s ", hdr);
		len = strlen(ErrBuf);
	}
	(void) sm_vsnprintf(&ErrBuf[len], sizeof ErrBuf - len, fmt, ap);
	SM_VA_END(ap);

	if (!HoldErrs)
		flush_error();

	/* Log the message to syslog. */
	if (!LMTPMode)
		syslog(LOG_ERR, "%s", ErrBuf);
}

void
flush_error()
{
	if (LMTPMode)
		printf("%s\r\n", ErrBuf);
	else
	{
		if (ExitVal != EX_USAGE)
			(void) fprintf(stderr, "mail.local: ");
		fprintf(stderr, "%s\n", ErrBuf);
	}
}

#if HASHSPOOL
const char *
hashname(name)
	char *name;
{
	static char p[MAXPATHLEN];
	int i;
	int len;
	char *str;
# if HASHSPOOLMD5
	char Base64[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+_";
	MD5_CTX ctx;
	unsigned char md5[18];
#  if MAXPATHLEN <= 24
    ERROR _MAXPATHLEN <= 24
#  endif /* MAXPATHLEN <= 24 */
	char b64[24];
	MD5_LONG bits;
	int j;
# endif /* HASHSPOOLMD5 */

	if (HashType == HASH_NONE || HashDepth * 2 >= MAXPATHLEN)
	{
		p[0] = '\0';
		return p;
	}

	switch(HashType)
	{
	  case HASH_USER:
		str = name;
		break;

# if HASHSPOOLMD5
	  case HASH_MD5:
		MD5_Init(&ctx);
		MD5_Update(&ctx, name, strlen(name));
		MD5_Final(md5, &ctx);
		md5[16] = 0;
		md5[17] = 0;

		for (i = 0; i < 6; i++)
		{
			bits = (unsigned) md5[(3 * i)] << 16;
			bits |= (unsigned) md5[(3 * i) + 1] << 8;
			bits |= (unsigned) md5[(3 * i) + 2];

			for (j = 3; j >= 0; j--)
			{
				b64[(4 * i) + j] = Base64[(bits & 0x3f)];
				bits >>= 6;
			}
		}
		b64[22] = '\0';
		str = b64;
		break;
# endif /* HASHSPOOLMD5 */
	}

	len = strlen(str);
	for (i = 0; i < HashDepth; i++)
	{
		if (i < len)
			p[i * 2] = str[i];
		else
			p[i * 2] = '_';
		p[(i * 2) + 1] = '/';
	}
	p[HashDepth * 2] = '\0';
	return p;
}
#endif /* HASHSPOOL */

/*
 * e_to_sys --
 *	Guess which errno's are temporary.  Gag me.
 */

int
e_to_sys(num)
	int num;
{
	/* Temporary failures override hard errors. */
	if (ExitVal == EX_TEMPFAIL)
		return ExitVal;

	switch (num)		/* Hopefully temporary errors. */
	{
#ifdef EDQUOT
	  case EDQUOT:		/* Disc quota exceeded */
		if (BounceQuota)
		{
			ExitVal = EX_UNAVAILABLE;
			break;
		}
		/* FALLTHROUGH */
#endif /* EDQUOT */
#ifdef EAGAIN
	  case EAGAIN:		/* Resource temporarily unavailable */
#endif /* EAGAIN */
#ifdef EBUSY
	  case EBUSY:		/* Device busy */
#endif /* EBUSY */
#ifdef EPROCLIM
	  case EPROCLIM:	/* Too many processes */
#endif /* EPROCLIM */
#ifdef EUSERS
	  case EUSERS:		/* Too many users */
#endif /* EUSERS */
#ifdef ECONNABORTED
	  case ECONNABORTED:	/* Software caused connection abort */
#endif /* ECONNABORTED */
#ifdef ECONNREFUSED
	  case ECONNREFUSED:	/* Connection refused */
#endif /* ECONNREFUSED */
#ifdef ECONNRESET
	  case ECONNRESET:	/* Connection reset by peer */
#endif /* ECONNRESET */
#ifdef EDEADLK
	  case EDEADLK:		/* Resource deadlock avoided */
#endif /* EDEADLK */
#ifdef EFBIG
	  case EFBIG:		/* File too large */
#endif /* EFBIG */
#ifdef EHOSTDOWN
	  case EHOSTDOWN:	/* Host is down */
#endif /* EHOSTDOWN */
#ifdef EHOSTUNREACH
	  case EHOSTUNREACH:	/* No route to host */
#endif /* EHOSTUNREACH */
#ifdef EMFILE
	  case EMFILE:		/* Too many open files */
#endif /* EMFILE */
#ifdef ENETDOWN
	  case ENETDOWN:	/* Network is down */
#endif /* ENETDOWN */
#ifdef ENETRESET
	  case ENETRESET:	/* Network dropped connection on reset */
#endif /* ENETRESET */
#ifdef ENETUNREACH
	  case ENETUNREACH:	/* Network is unreachable */
#endif /* ENETUNREACH */
#ifdef ENFILE
	  case ENFILE:		/* Too many open files in system */
#endif /* ENFILE */
#ifdef ENOBUFS
	  case ENOBUFS:		/* No buffer space available */
#endif /* ENOBUFS */
#ifdef ENOMEM
	  case ENOMEM:		/* Cannot allocate memory */
#endif /* ENOMEM */
#ifdef ENOSPC
	  case ENOSPC:		/* No space left on device */
#endif /* ENOSPC */
#ifdef EROFS
	  case EROFS:		/* Read-only file system */
#endif /* EROFS */
#ifdef ESTALE
	  case ESTALE:		/* Stale NFS file handle */
#endif /* ESTALE */
#ifdef ETIMEDOUT
	  case ETIMEDOUT:	/* Connection timed out */
#endif /* ETIMEDOUT */
#if defined(EWOULDBLOCK) && EWOULDBLOCK != EAGAIN && EWOULDBLOCK != EDEADLK
	  case EWOULDBLOCK:	/* Operation would block. */
#endif /* defined(EWOULDBLOCK) && EWOULDBLOCK != EAGAIN && EWOULDBLOCK != EDEADLK */
		ExitVal = EX_TEMPFAIL;
		break;

	  default:
		ExitVal = EX_UNAVAILABLE;
		break;
	}
	return ExitVal;
}

#if defined(ultrix) || defined(_CRAY)
/*
 * Copyright (c) 1987, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

# if defined(LIBC_SCCS) && !defined(lint)
static char sccsid[] = "@@(#)mktemp.c	8.1 (Berkeley) 6/4/93";
# endif /* defined(LIBC_SCCS) && !defined(lint) */

# include <sys/types.h>
# include <sys/stat.h>
# include <fcntl.h>
# include <errno.h>
# include <stdio.h>
# include <ctype.h>

static int _gettemp();

mkstemp(path)
	char *path;
{
	int fd;

	return (_gettemp(path, &fd) ? fd : -1);
}

static
_gettemp(path, doopen)
	char *path;
	register int *doopen;
{
	extern int errno;
	register char *start, *trv;
	struct stat sbuf;
	unsigned int pid;

	pid = getpid();
	for (trv = path; *trv; ++trv);		/* extra X's get set to 0's */
	while (*--trv == 'X')
	{
		*trv = (pid % 10) + '0';
		pid /= 10;
	}

	/*
	 * check the target directory; if you have six X's and it
	 * doesn't exist this runs for a *very* long time.
	 */
	for (start = trv + 1;; --trv)
	{
		if (trv <= path)
			break;
		if (*trv == '/')
		{
			*trv = '\0';
			if (stat(path, &sbuf) < 0)
				return(0);
			if (!S_ISDIR(sbuf.st_mode))
			{
				errno = ENOTDIR;
				return(0);
			}
			*trv = '/';
			break;
		}
	}

	for (;;)
	{
		if (doopen)
		{
			if ((*doopen = open(path, O_CREAT|O_EXCL|O_RDWR,
					    0600)) >= 0)
				return(1);
			if (errno != EEXIST)
				return(0);
		}
		else if (stat(path, &sbuf) < 0)
			return(errno == ENOENT ? 1 : 0);

		/* tricky little algorithm for backward compatibility */
		for (trv = start;;)
		{
			if (!*trv)
				return(0);
			if (*trv == 'z')
				*trv++ = 'a';
			else
			{
				if (isascii(*trv) && isdigit(*trv))
					*trv = 'a';
				else
					++*trv;
				break;
			}
		}
	}
	/* NOTREACHED */
}
#endif /* defined(ultrix) || defined(_CRAY) */
@


1.21
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.20
log
@Update to sendmail-8.14.3
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004 Sendmail, Inc. and its suppliers.
d16 1
a16 1
"@@(#) Copyright (c) 1998-2004 Sendmail, Inc. and its suppliers.\n\
d21 1
a21 1
SM_IDSTR(id, "@@(#)$Sendmail: mail.local.c,v 8.256 2008/02/19 07:13:30 gshapiro Exp $")
@


1.19
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d21 1
a21 1
SM_IDSTR(id, "@@(#)$Sendmail: mail.local.c,v 8.254 2006/10/12 22:23:45 ca Exp $")
d82 9
d239 3
d243 1
d324 6
d343 1
a343 5

		  case 'n':
			StripRcptDomain = false;
			break;
#endif /* HASHSPOOL */
d1584 3
d1588 1
@


1.18
log
@Update to sendmail-8.13.2
@
text
@d21 1
a21 1
SM_IDSTR(id, "@@(#)$Sendmail: mail.local.c,v 8.253 2004/11/01 20:42:42 ca Exp $")
d175 2
@


1.17
log
@Update to sendmail.8.13.0
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d16 1
a16 1
"@@(#) Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.\n\
d21 1
a21 1
SM_IDSTR(id, "@@(#)$Sendmail: mail.local.c,v 8.251 2003/11/03 18:38:29 ca Exp $")
d147 1
d159 3
d176 12
d217 2
d223 1
a223 1
		exit(EX_CONFIG);
d349 1
a349 1
		exit(err);
d351 1
a354 2
		extern void dolmtp __P((void));

d358 1
a358 1
			exit(EX_TEMPFAIL);
d363 1
a363 1
		exit(EX_OK);
d398 1
a398 1
		exit(ExitVal);
d402 1
a402 1
	exit(ExitVal);
d492 1
a492 1
		exit(EX_TEMPFAIL);
d548 1
a548 1
			exit(EX_OK);
d662 1
a662 1
				exit(EX_OK);
d689 1
a689 1
						exit(EX_TEMPFAIL);
d908 1
a908 1
		exit(EX_OK);
d1568 1
a1568 1
	exit(ExitVal);
@


1.16
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d21 1
a21 1
SM_IDSTR(id, "@@(#)$Sendmail: mail.local.c,v 8.239.2.11 2003/09/01 01:49:46 gshapiro Exp $")
d35 7
d73 9
d149 9
d167 3
d201 9
d211 1
d254 56
d677 1
a677 1
								      true)) == NULL))
d1000 1
d1010 1
d1015 11
a1025 2
		if (sm_snprintf(path, sizeof(path), "%s/%s",
				_PATH_MAILDIR, name) >= sizeof(path))
d1600 73
@


1.15
log
@final bits of obvious UCB term 3 removal
@
text
@d21 1
a21 1
SM_IDSTR(id, "@@(#)$Sendmail: mail.local.c,v 8.239.2.5 2003/03/15 23:43:20 gshapiro Exp $")
d31 1
a66 4
/* additional mode for open() */
# define EXTRA_MODE 0


d854 1
a854 1
	off_t curoff;
d997 1
a997 1
		mbfd = open(path, O_APPEND|O_CREAT|O_EXCL|O_WRONLY|EXTRA_MODE,
d1067 1
a1067 1
	mbfd = open(path, O_APPEND|O_WRONLY|EXTRA_MODE, 0);
a1202 1
		(void) setreuid(0, 0);
d1210 2
a1211 1
err0:		unlockmbox();
d1215 15
d1239 6
a1244 3
		mbfd = open(path, O_WRONLY|EXTRA_MODE, 0);
		if (mbfd < 0
		    || fstat(mbfd, &sb) < 0 ||
d1362 1
a1362 1
		fd = open(LockName, O_WRONLY|O_EXCL|O_CREAT, 0);
@


1.14
log
@Update to sendmail 8.12.9; fixes a buffer overflow in address parsing
due to a char to int conversion problem which is potentially remotely
exploitable.
@
text
@d1597 1
a1597 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.13
log
@Update to Sendmail 8.12.8; fixes a buffer overflow in the envelope
comments processing which may allow an attacker to gain root privileges.
@
text
@d21 1
a21 1
SM_IDSTR(id, "@@(#)$Sendmail: mail.local.c,v 8.239.2.4 2003/01/15 19:17:15 ca Exp $")
d1138 1
a1138 1
	/* Get the starting offset of the new message for biff. */
@


1.12
log
@update to sendmail 8.12.7
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d21 1
a21 1
SM_IDSTR(id, "@@(#)$Sendmail: mail.local.c,v 8.239.2.2 2002/09/24 02:09:09 ca Exp $")
d1041 6
a1046 1
	else if (sb.st_nlink != 1 || !S_ISREG(sb.st_mode))
@


1.11
log
@Update to sendmail-8.12.4
@
text
@d21 1
a21 1
SM_IDSTR(id, "@@(#)$Sendmail: mail.local.c,v 8.239 2002/05/24 20:56:32 gshapiro Exp $")
d660 2
d1205 2
a1206 1
		(void) ftruncate(mbfd, curoff);
d1222 23
a1244 1
		(void) truncate(path, curoff);
@


1.10
log
@update to sendmail 8.12.3
@
text
@d21 1
a21 1
SM_IDSTR(id, "@@(#)$Sendmail: mail.local.c,v 8.238 2002/03/30 07:43:21 geir Exp $")
d523 1
a523 1
				if (sm_strncasecmp(buf+5, "from:", 5) != 0 ||
d860 1
a860 1
	char biffmsg[100], buf[8*1024];
@


1.9
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d21 1
a21 1
SM_IDSTR(id, "@@(#)$Sendmail: mail.local.c,v 8.235 2001/12/30 04:59:39 gshapiro Exp $")
@


1.8
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d21 1
a21 1
SM_IDSTR(id, "@@(#)$Sendmail: mail.local.c,v 8.234 2001/09/11 04:04:59 gshapiro Exp $")
d26 1
@


1.7
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d21 1
a21 1
SM_IDSTR(id, "@@(#)$Sendmail: mail.local.c,v 8.232 2001/09/08 01:21:04 gshapiro Exp $")
@


1.6
log
@make sure that va_start() has matching va_end()
@
text
@d13 3
a15 2
#ifndef lint
static char copyright[] =
d19 3
a21 2
	The Regents of the University of California.  All rights reserved.\n";
#endif /* ! lint */
d23 9
a31 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: mail.local.c,v 8.143.4.58 2001/06/01 05:33:31 gshapiro Exp $";
#endif /* ! lint */
d36 2
a37 2
**  approach to mailboxes (essentially, they have a setgid program
**  rather than setuid, and they rely on the ability to "give away"
d43 7
a49 6
/* additional mode for open() */
# define EXTRA_MODE 0

# include <sys/types.h>
# include <sys/param.h>
# include <sys/stat.h>
a51 1

d54 9
a63 14
# include <fcntl.h>
# include <netdb.h>
#  include <pwd.h>
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <syslog.h>
# include <time.h>
# include <unistd.h>
# ifdef EX_OK
#  undef EX_OK		/* unistd.h may have another use for this */
# endif /* EX_OK */
# include <sysexits.h>
# include <ctype.h>
d65 2
a66 31
# ifndef __P
#  include "sendmail/cdefs.h"
# endif /* ! __P */
# include "sendmail/useful.h"

extern size_t	strlcpy __P((char *, const char *, size_t));
extern size_t	strlcat __P((char *, const char *, size_t));

# if defined(BSD4_4) || defined(__osf__) || defined(__GNU_LIBRARY__) || defined(IRIX64) || defined(IRIX5) || defined(IRIX6)
#  ifndef HASSTRERROR
#   define HASSTRERROR	1
#  endif /* ! HASSTRERROR */
# endif /* defined(BSD4_4) || defined(__osf__) || defined(__GNU_LIBRARY__) || defined(IRIX64) || defined(IRIX5) || defined(IRIX6) */

# include "sendmail/errstring.h"

# ifndef LOCKTO_RM
#  define LOCKTO_RM	300	/* timeout for stale lockfile removal */
# endif /* ! LOCKTO_RM */
# ifndef LOCKTO_GLOB
#  define LOCKTO_GLOB	400	/* global timeout for lockfile creation */
# endif /* ! LOCKTO_GLOB */

# ifdef __STDC__
#  include <stdarg.h>
#  define REALLOC(ptr, size)	realloc(ptr, size)
# else /* __STDC__ */
#  include <varargs.h>
/* define a realloc() which works for NULL pointers */
#  define REALLOC(ptr, size)	(((ptr) == NULL) ? malloc(size) : realloc(ptr, size))
# endif /* __STDC__ */
a67 44
# if (defined(sun) && defined(__svr4__)) || defined(__SVR4)
#  define USE_LOCKF	1
#  define USE_SETEUID	1
#   define _PATH_MAILDIR	"/var/mail"
# endif /* (defined(sun) && defined(__svr4__)) || defined(__SVR4) */

# ifdef NCR_MP_RAS3
#  define USE_LOCKF	1
#  define HASSNPRINTF	1
#   define _PATH_MAILDIR	"/var/mail"
# endif /* NCR_MP_RAS3 */

# if defined(_AIX)
#  define USE_LOCKF	1
#  define USE_SETEUID	1
# endif /* defined(_AIX) */

# if defined(__hpux)
#  define USE_LOCKF	1
#  define USE_SETRESUID	1
# endif /* defined(__hpux) */

# ifdef DGUX
#  define HASSNPRINTF	1
#  define USE_LOCKF	1
# endif /* DGUX */

# if defined(_CRAY)
#  if !defined(MAXPATHLEN)
#   define MAXPATHLEN PATHSIZE
#  endif /* !defined(MAXPATHLEN) */
#   define _PATH_MAILDIR	"/usr/spool/mail"
# endif /* defined(_CRAY) */

# if defined(NeXT) && !defined(__APPLE__)
#  include <libc.h>
#   define _PATH_MAILDIR	"/usr/spool/mail"
#  define S_IRUSR	S_IREAD
#  define S_IWUSR	S_IWRITE
# endif /* defined(NeXT) && !defined(__APPLE__) */

# if defined(IRIX64) || defined(IRIX5) || defined(IRIX6)
#   include <paths.h>
# endif /* defined(IRIX64) || defined(IRIX5) || defined(IRIX6) */
d69 6
a74 3
/*
 * If you don't have flock, you could try using lockf instead.
 */
d76 2
a77 55
# ifdef USE_LOCKF
#  define flock(a, b)	lockf(a, b, 0)
#  ifdef LOCK_EX
#   undef LOCK_EX
#  endif /* LOCK_EX */
#  define LOCK_EX	F_LOCK
# endif /* USE_LOCKF */

# ifndef LOCK_EX
#  include <sys/file.h>
# endif /* ! LOCK_EX */

# if defined(BSD4_4) || defined(__GLIBC__)
#   include <paths.h>
#  define _PATH_LOCTMP	"/tmp/local.XXXXXX"
# endif /* defined(BSD4_4) || defined(__GLIBC__) */

# ifdef BSD4_4
#  define HAS_ST_GEN	1
# else /* BSD4_4 */
#  ifndef _BSD_VA_LIST_
#   define _BSD_VA_LIST_	va_list
#  endif /* ! _BSD_VA_LIST_ */
# endif /* BSD4_4 */

# if defined(BSD4_4) || defined(linux)
#  define HASSNPRINTF	1
# else /* defined(BSD4_4) || defined(linux) */
#  ifndef ultrix
extern FILE	*fdopen __P((int, const char *));
#  endif /* ! ultrix */
# endif /* defined(BSD4_4) || defined(linux) */

# if SOLARIS >= 20300 || (SOLARIS < 10000 && SOLARIS >= 203)
#  define CONTENTLENGTH	1	/* Needs the Content-Length header */
# endif /* SOLARIS >= 20300 || (SOLARIS < 10000 && SOLARIS >= 203) */

# if SOLARIS >= 20600 || (SOLARIS < 10000 && SOLARIS >= 206)
#  define HASSNPRINTF	1		/* has snprintf starting in 2.6 */
# endif /* SOLARIS >= 20600 || (SOLARIS < 10000 && SOLARIS >= 206) */

# ifdef HPUX11
#  define HASSNPRINTF	1		/* has snprintf starting in 11.X */
# endif /* HPUX11 */

# if _AIX4 >= 40300
#  define HASSNPRINTF	1		/* has snprintf starting in 4.3 */
# endif /* _AIX4 >= 40300 */

# if !HASSNPRINTF && !SFIO
extern int	snprintf __P((char *, size_t, const char *, ...));
#  ifndef _CRAY
extern int	vsnprintf __P((char *, size_t, const char *, ...));
#  endif /* ! _CRAY */
# endif /* !HASSNPRINTF && !SFIO */
d80 1
a80 3
**  If you don't have setreuid, and you have saved uids, and you have
**  a seteuid() call that doesn't try to emulate using setuid(), then
**  you can try defining USE_SETEUID.
d83 11
a93 3
# ifdef USE_SETEUID
#  define setreuid(r, e)		seteuid(e)
# endif /* USE_SETEUID */
d96 3
a98 1
**  And of course on hpux you have setresuid()
d101 7
a107 21
# ifdef USE_SETRESUID
#  define setreuid(r, e)		setresuid(-1, e, -1)
# endif /* USE_SETRESUID */

# ifndef _PATH_LOCTMP
#  define _PATH_LOCTMP	"/tmp/local.XXXXXX"
# endif /* ! _PATH_LOCTMP */
#  ifndef _PATH_MAILDIR
#   define _PATH_MAILDIR	"/var/spool/mail"
#  endif /* ! _PATH_MAILDIR */

# ifndef S_ISREG
#  define S_ISREG(mode)	(((mode) & _S_IFMT) == S_IFREG)
# endif /* ! S_ISREG */

# ifdef MAILLOCK
#  include <maillock.h>
# endif /* MAILLOCK */

# define U_UID pw->pw_uid
# define U_GID pw->pw_gid
d113 4
d127 1
a127 1
bool	EightBitMime = TRUE;		/* advertise 8BITMIME in LMTP */
d130 4
a133 3
bool	HoldErrs = FALSE;		/* Hold errors in ErrBuf */
bool	LMTPMode = FALSE;
bool	BounceQuota = FALSE;		/* permanent error when over quota */
d138 1
a138 1
int	store __P((char *, int, bool *));
d155 2
d175 1
a175 1
	while ((ch = getopt(argc, argv, "7bdf:r:l")) != -1)
d180 1
a180 1
			EightBitMime = FALSE;
d184 1
a184 1
			BounceQuota = TRUE;
d190 4
d204 10
d215 1
a215 1
			LMTPMode = TRUE;
d229 13
a267 1

d283 3
a285 3
	HoldErrs = TRUE;
	fd = store(from, 0, NULL);
	HoldErrs = FALSE;
d377 2
d386 1
a386 1
	(void) strlcpy(p, s, l);
d394 8
a401 1
	if (getpwnam(addr) == NULL)
d403 7
a409 1
	return NULL;
d421 1
a421 1
	bool gotlhlo = FALSE;
d432 1
a432 1
		strlcpy(myhostname, "localhost", sizeof myhostname);
d450 1
a450 1
			if (strcasecmp(buf, "data") == 0)
d452 1
a452 1
				bool inbody = FALSE;
d459 3
a461 3
				HoldErrs = TRUE;
				msgfd = store(return_path, rcpt_num, &inbody);
				HoldErrs = FALSE;
d491 1
a491 1
			if (strncasecmp(buf, "lhlo ", 5) == 0)
d500 1
a500 1
				gotlhlo = TRUE;
d514 1
a514 1
			if (strncasecmp(buf, "mail ", 5) == 0)
d522 1
a522 1
				if (strncasecmp(buf+5, "from:", 5) != 0 ||
d524 1
a524 1
							      FALSE)) == NULL))
d539 1
a539 1
			if (strcasecmp(buf, "noop") == 0)
d550 1
a550 1
			if (strcasecmp(buf, "quit") == 0)
d561 1
a561 1
			if (strncasecmp(buf, "rcpt ", 5) == 0)
d583 1
a583 1
				if (strncasecmp(buf + 5, "to:", 3) != 0 ||
d585 1
a585 1
								      TRUE)) == NULL))
d601 1
a601 1
			else if (strcasecmp(buf, "rset") == 0)
d619 1
a619 1
			if (strncasecmp(buf, "vrfy ", 5) == 0)
d639 1
a639 1
store(from, lmtprcpts, inbody)
a640 1
	int lmtprcpts;
d645 2
a646 2
	bool eline;
	bool fullline = TRUE;	/* current line is terminated */
d653 1
a653 1
		*inbody = FALSE;
d656 1
a656 1
	(void) strlcpy(tmpbuf, _PATH_LOCTMP, sizeof tmpbuf);
d670 1
a670 1
		*inbody = TRUE;
d681 1
a681 1
	eline = TRUE;
d703 1
a703 1
		fullline = FALSE;
d715 1
a715 1
				fullline = TRUE;
d724 1
a724 1
					fullline = TRUE;
d731 1
a731 1
			fullline = TRUE;
d736 1
a736 1
			eline = FALSE;
d751 1
a751 1
			eline = TRUE;
d759 1
a759 1
			eline = FALSE;
d764 1
a764 1
			    strncasecmp(line, ContentHdr, 15) == 0)
d819 4
a822 9
		extern char *quad_to_string();

		if (sizeof BodyLength > sizeof(long))
			snprintf(line, sizeof line, "%s\n",
				 quad_to_string(BodyLength));
		else
			snprintf(line, sizeof line, "%ld\n",
				 (long) BodyLength);
		strlcpy(&ContentHdr[16], line, sizeof(ContentHdr) - 16);
a848 1
	struct passwd *pw;
d851 1
d860 1
a860 2
	extern char *quad_to_string();

d867 23
a889 1
	if ((pw = getpwnam(name)) == NULL)
d891 2
a892 8
		if (ExitVal == EX_TEMPFAIL)
			errcode = "451 4.3.0";
		else
		{
			ExitVal = EX_UNAVAILABLE;
			errcode = "550 5.1.1";
		}
		mailerr(errcode, "Unknown name: %s", name);
d895 1
d917 23
a939 1
	(void) snprintf(path, sizeof(path), "%s/%s", _PATH_MAILDIR, name);
d981 1
a981 1
			p, off, errno > 0 ? errstring(errno) : "");
d989 1
a989 1
		gid_t gid = U_GID;
d1015 1
a1015 1
				errstring(save_errno));
d1018 1
a1018 1
		else if (fchown(mbfd, U_UID, gid) < 0)
d1021 1
a1021 1
				U_UID, gid, name);
d1033 1
a1033 1
			sb.st_uid = U_UID;
d1043 1
a1043 1
	else if (sb.st_uid != U_UID)
d1047 1
a1047 1
			path, sb.st_uid);
d1052 1
a1052 1
	if (setreuid(0, U_UID) < 0)
d1055 2
a1056 1
			U_UID, errstring(errno), getuid(), geteuid());
d1060 1
a1060 1
	fprintf(stderr, "new euid = %d\n", geteuid());
d1065 1
a1065 1
		mailerr("450 4.2.0", "%s: %s", path, errstring(errno));
d1085 37
d1126 1
a1126 1
		mailerr("450 4.2.0", "%s: %s", path, errstring(errno));
d1132 2
a1133 6
	if (sizeof curoff > sizeof(long))
		(void) snprintf(biffmsg, sizeof(biffmsg), "%s@@%s\n",
				name, quad_to_string(curoff));
	else
		(void) snprintf(biffmsg, sizeof(biffmsg), "%s@@%ld\n",
				name, (long) curoff);
d1139 1
a1139 1
			errstring(errno));
d1143 1
a1143 1
	fprintf(stderr, "before writing: euid = %d\n", geteuid());
d1151 1
a1151 1
			snprintf(buf, sizeof buf, "%s", ContentHdr);
d1181 1
a1181 1
					path, errstring(errno));
d1189 1
a1189 1
			errstring(errno));
d1196 1
a1196 1
		mailerr("450 4.2.0", "%s: %s", path, errstring(errno));
d1200 1
a1200 1
		fprintf(stderr, "reset euid = %d\n", geteuid());
d1217 1
a1217 1
		mailerr(errcode, "%s: %s", path, errstring(errno));
d1226 1
a1226 1
			errstring(errno));
d1230 1
a1230 1
	fprintf(stderr, "reset euid = %d\n", geteuid());
d1244 1
a1244 1
bool	Locked = FALSE;
d1257 1
a1257 1
		Locked = TRUE;
d1284 1
a1284 1
	Locked = FALSE;
d1301 1
a1301 1
	(void) snprintf(LockName, sizeof LockName, "%s.lock", path);
d1321 1
a1321 1
			Locked = TRUE;
d1351 1
a1351 1
	Locked = FALSE;
d1359 1
a1359 1
	static bool initialized = FALSE;
d1368 1
a1368 1
		initialized = TRUE;
d1399 1
a1399 1
	mailerr(NULL, "usage: mail.local [-7] [-b] [-l] [-f from] user ...");
d1404 1
d1415 1
a1415 1
	va_list ap;
d1419 1
a1419 5
#ifdef __STDC__
	va_start(ap, fmt);
#else /* __STDC__ */
	va_start(ap);
#endif /* __STDC__ */
d1421 1
a1421 1
	if (LMTPMode)
d1423 2
a1424 5
		if (hdr != NULL)
		{
			snprintf(ErrBuf, sizeof ErrBuf, "%s ", hdr);
			len = strlen(ErrBuf);
		}
d1426 2
a1427 2
	(void) vsnprintf(&ErrBuf[len], sizeof ErrBuf - len, fmt, ap);
	va_end(ap);
d1616 1
a1616 1
	u_int pid;
@


1.5
log
@update to sendmail 8.11.5
@
text
@d1445 1
@


1.4
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d22 1
a22 1
static char id[] = "@@(#)$Sendmail: mail.local.c,v 8.143.4.57 2001/02/11 20:08:20 gshapiro Exp $";
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
"@@(#) Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.\n\
d22 1
a22 1
static char id[] = "@@(#)$Sendmail: mail.local.c,v 8.143.4.39 2000/11/14 20:02:47 gshapiro Exp $";
a108 1
#  define USE_VSYSLOG	0
a113 1
#  define USE_VSYSLOG	0
a118 1
#  define USE_VSYSLOG	0
a124 1
#  define USE_VSYSLOG   0
a127 8
# if defined(ultrix)
#  define USE_VSYSLOG	0
# endif /* defined(ultrix) */

# if defined(__osf__)
#  define USE_VSYSLOG	0
# endif /* defined(__osf__) */

a150 4
# ifndef USE_VSYSLOG
#  define USE_VSYSLOG	1
# endif /* ! USE_VSYSLOG */

d192 1
a192 1
# if !HASSNPRINTF
d197 1
a197 1
# endif /* !HASSNPRINTF */
d204 1
d212 1
d250 1
d252 1
d254 1
a254 1
bool	bouncequota = FALSE;		/* permanent error when over quota */
d256 1
a256 1
void	deliver __P((int, char *, bool));
d259 1
a259 1
int	store __P((char *, int));
a260 1
void	vwarn __P((const char *, _BSD_VA_LIST_));
d264 1
a277 1
	extern void dolmtp __P((bool));
d303 1
a303 1
			bouncequota = TRUE;
d313 1
a313 1
				mailerr(NULL, "multiple -f options");
d335 13
a347 1
		dolmtp(bouncequota);
d349 1
d358 1
d375 11
a385 2
	for (fd = store(from, 0); *argv; ++argv)
		deliver(fd, *argv, bouncequota);
d473 1
a473 1
		printf("421 4.3.0 memory exhausted\r\n");
d486 1
a486 1
		return "550 5.1.1 user unknown";
d493 1
a493 2
dolmtp(bouncequota)
	bool bouncequota;
d507 1
d509 2
d530 2
d534 1
a534 1
					printf("503 5.5.1 No recipients\r\n");
d537 6
a542 2
				msgfd = store(return_path, rcpt_num);
				if (msgfd == -1)
d544 1
d548 6
d556 2
a557 3
						*p++ = '\0';
					deliver(msgfd, rcpt_addr[i],
						bouncequota);
d559 2
a560 1
				(void) close(msgfd);
d574 1
a574 1
					printf("503 %s Duplicate LHLO\r\n",
d596 2
a597 1
					printf("503 5.5.1 Nested MAIL command\r\n");
d604 2
a605 1
					printf("501 5.5.4 Syntax error in parameters\r\n");
d608 1
a608 1
				printf("250 2.5.0 ok\r\n");
d619 1
a619 1
				printf("250 2.0.0 ok\r\n");
d630 1
a630 1
				printf("221 2.0.0 bye\r\n");
d643 2
a644 1
					printf("503 5.5.1 Need MAIL command\r\n");
d656 2
a657 1
						printf("421 4.3.0 memory exhausted\r\n");
d665 2
a666 1
					printf("501 5.5.4 Syntax error in parameters\r\n");
d669 2
a670 1
				if ((err = process_recipient(rcpt_addr[rcpt_num])) != NULL)
d672 1
a672 1
					printf("%s\r\n", err);
d676 1
a676 1
				printf("250 2.1.5 ok\r\n");
d681 1
a681 1
				printf("250 2.0.0 ok\r\n");
d699 1
a699 1
				printf("252 2.3.3 try RCPT to attempt delivery\r\n");
d708 1
a708 1
			printf("500 5.5.2 Syntax error\r\n");
d717 1
a717 1
store(from, lmtprcpts)
d720 1
d731 3
d736 1
a736 1
	if ((fd = mkstemp(tmpbuf)) == -1 || (fp = fdopen(fd, "w+")) == NULL)
d738 2
a739 10
		if (lmtprcpts)
		{
			printf("451 4.3.0 unable to open temporary file\r\n");
			return -1;
		}
		else
		{
			mailerr("451 4.3.0", "unable to open temporary file");
			exit(ExitVal);
		}
d745 1
a745 1
		printf("354 go ahead\r\n");
d748 2
d761 1
a761 1
	while (fgets(line, sizeof(line), stdin) != (char *)NULL)
d772 1
a772 1
		if (prevfl && lmtprcpts && line[0] == '.')
d816 2
a817 1
			HeaderLength = ftell(fp);
d835 1
d855 1
a855 2
		(void) fwrite(line, sizeof(char), line_len, fp);
		if (ferror(fp))
d857 2
a858 8
			if (lmtprcpts)
			{
				while (lmtprcpts--)
					printf("451 4.3.0 temporary file write error\r\n");
				(void) fclose(fp);
				return -1;
			}
			else
d861 1
a861 1
					"temporary file write error");
d863 2
a864 1
				exit(ExitVal);
d869 5
a873 1
	if (lmtprcpts)
d880 1
a880 1
	if (strchr(line, '\n') == NULL)
d886 2
a887 1
	BodyLength = ftell(fp);
d913 2
a914 1
	(void) putc('\n', fp);
d916 1
a916 1
	if (fflush(fp) == EOF || ferror(fp) != 0)
d918 2
a919 10
		if (lmtprcpts)
		{
			while (lmtprcpts--)
				printf("451 4.3.0 temporary file write error\r\n");
			(void) fclose(fp);
			return -1;
		}
		else
		{
			mailerr("451 4.3.0", "temporary file write error");
d921 1
a921 2
			exit(ExitVal);
		}
d927 1
a927 1
deliver(fd, name, bouncequota)
a929 1
	bool bouncequota;
d937 1
d951 1
d954 2
a955 10
		if (ExitVal != EX_TEMPFAIL)
			ExitVal = EX_UNAVAILABLE;
		if (LMTPMode)
		{
			if (ExitVal == EX_TEMPFAIL)
				printf("451 4.3.0 cannot lookup name: %s\r\n",
				       name);
			else
				printf("550 5.1.1 unknown name: %s\r\n", name);
		}
d958 2
a959 7
			char *errcode = NULL;

			if (ExitVal == EX_TEMPFAIL)
				errcode = "451 4.3.0";
			else
				errcode = "550 5.1.1";
			mailerr(errcode, "unknown name: %s", name);
d961 1
d1021 1
a1021 3
			mailerr("451 4.3.0",
				"lockmailbox %s failed; error code %d %s",
				p, off, errno > 0 ? errstring(errno) : "");
d1024 4
a1027 5
		{
			mailerr("551 5.3.0",
				"lockmailbox %s failed; error code %d %s",
				p, off, errno > 0 ? errstring(errno) : "");
		}
d1054 1
a1054 1
		if (mbfd == -1)
d1139 1
a1139 1
	curoff = lseek(mbfd, (off_t)0, SEEK_END);
d1148 1
a1148 1
	if (lseek(fd, (off_t)0, SEEK_SET) == (off_t)-1)
d1150 1
a1150 1
		mailerr("450 4.2.0", "temporary file: %s",
d1187 1
d1189 2
a1190 4
				if (errno == EDQUOT && bouncequota)
					mailerr("552 5.2.2", "%s: %s",
						path, errstring(errno));
				else
d1192 1
a1192 1
				mailerr("450 4.2.0", "%s: %s",
d1200 1
a1200 1
		mailerr("450 4.2.0", "temporary file: %s",
d1210 1
a1210 9
		if (setreuid(0, 0) < 0)
		{
#if 0
			/* already printed an error above for this recipient */
			(void) e_to_sys(errno);
			mailerr("450 4.2.0", "setreuid(0, 0): %s",
				errstring(errno));
#endif /* 0 */
		}
d1224 1
d1226 2
a1227 3
		if (errno == EDQUOT && bouncequota)
			mailerr("552 5.2.2", "%s: %s", path, errstring(errno));
		else
d1229 1
a1229 1
		mailerr("450 4.2.0", "%s: %s", path, errstring(errno));
d1246 1
a1246 1
		printf("250 2.1.5 %s OK\r\n", name);
d1401 1
a1401 1
	if (f < 0 && (f = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
d1425 1
d1428 2
d1435 1
d1439 4
a1442 8
			printf("%s ", hdr);
		(void) vprintf(fmt, ap);
		(void) printf("\r\n");
	}
	else
	{
		(void) e_to_sys(errno);
		vwarn(fmt, ap);
d1444 8
d1455 1
a1455 3
vwarn(fmt, ap)
	const char *fmt;
	_BSD_VA_LIST_ ap;
d1457 3
a1459 16
	/*
	**  Log the message to stderr.
	**
	**  Don't use LOG_PERROR as an openlog() flag to do this,
	**  it's not portable enough.
	*/

	if (ExitVal != EX_USAGE)
		(void) fprintf(stderr, "mail.local: ");
	(void) vfprintf(stderr, fmt, ap);
	(void) fprintf(stderr, "\n");

#if USE_VSYSLOG
	/* Log the message to syslog. */
	vsyslog(LOG_ERR, fmt, ap);
#else /* USE_VSYSLOG */
d1461 3
a1463 4
		char fmtbuf[10240];

		(void) vsnprintf(fmtbuf, sizeof fmtbuf, fmt, ap);
		syslog(LOG_ERR, "%s", fmtbuf);
a1464 1
#endif /* USE_VSYSLOG */
d1471 1
d1484 1
a1484 1
		if (bouncequota)
a1623 9

# if 0
char *
mktemp(path)
	char *path;
{
	return(_gettemp(path, (int *)NULL) ? path : (char *)NULL);
}
# endif /* 0 */
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d22 1
a22 1
static char id[] = "@@(#)$Sendmail: mail.local.c,v 8.143 2000/03/17 07:32:44 gshapiro Exp $";
d34 32
a65 28
#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/file.h>

#include <netinet/in.h>
#include <arpa/nameser.h>

#include <fcntl.h>
#include <netdb.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>
#ifdef EX_OK
# undef EX_OK		/* unistd.h may have another use for this */
#endif /* EX_OK */
#include <sysexits.h>
#include <ctype.h>

#ifndef __P
# include "sendmail/cdefs.h"
#endif /* ! __P */
#include "sendmail/useful.h"
d70 20
a89 22
#if defined(BSD4_4) || defined(__osf__) || defined(__GNU_LIBRARY__) || defined(IRIX64) || defined(IRIX5) || defined(IRIX6)
# ifndef HASSTRERROR
#  define HASSTRERROR	1
# endif /* ! HASSTRERROR */
#endif /* defined(BSD4_4) || defined(__osf__) || defined(__GNU_LIBRARY__) ||
	  defined(IRIX64) || defined(IRIX5) || defined(IRIX6) */

#include "sendmail/errstring.h"


#ifndef LOCKTO_RM
# define LOCKTO_RM	300	/* timeout for stale lockfile removal */
#endif /* LOCKTO_RM */
#ifndef LOCKTO_GLOB
# define LOCKTO_GLOB	400	/* global timeout for lockfile creation */
#endif /* LOCKTO_GLOB */

#ifdef __STDC__
# include <stdarg.h>
# define REALLOC(ptr, size)	realloc(ptr, size)
#else /* __STDC__ */
# include <varargs.h>
d91 2
a92 2
# define REALLOC(ptr, size)	(((ptr) == NULL) ? malloc(size) : realloc(ptr, size))
#endif /* __STDC__ */
d94 56
a149 50
#if (defined(sun) && defined(__svr4__)) || defined(__SVR4)
# define USE_LOCKF	1
# define USE_SETEUID	1
#  define _PATH_MAILDIR	"/var/mail"
#endif /* (defined(sun) && defined(__svr4__)) || defined(__SVR4) */

#ifdef NCR_MP_RAS3
# define USE_LOCKF	1
# define HASSNPRINTF	1
#  define _PATH_MAILDIR	"/var/mail"
#endif /* NCR_MP_RAS3 */

#if defined(_AIX)
# define USE_LOCKF	1
# define USE_SETEUID	1
# define USE_VSYSLOG	0
#endif /* defined(_AIX) */

#if defined(__hpux)
# define USE_LOCKF	1
# define USE_SETRESUID	1
# define USE_VSYSLOG	0
#endif /* defined(__hpux) */

#if defined(_CRAY)
# if !defined(MAXPATHLEN)
#  define MAXPATHLEN PATHSIZE
# endif /* !defined(MAXPATHLEN) */
# define USE_VSYSLOG   0
#  define _PATH_MAILDIR	"/usr/spool/mail"
#endif /* defined(_CRAY) */

#if defined(ultrix)
# define USE_VSYSLOG	0
#endif /* defined(ultrix) */

#if defined(__osf__)
# define USE_VSYSLOG	0
#endif /* defined(__osf__) */

#if defined(NeXT) && !defined(__APPLE__)
# include <libc.h>
#  define _PATH_MAILDIR	"/usr/spool/mail"
# define S_IRUSR	S_IREAD
# define S_IWUSR	S_IWRITE
#endif /* defined(NeXT) && !defined(__APPLE__) */

#if defined(IRIX64) || defined(IRIX5) || defined(IRIX6)
#  include <paths.h>
#endif /* defined(IRIX64) || defined(IRIX5) || defined(IRIX6) */
d155 33
a187 33
#ifdef USE_LOCKF
# define flock(a, b)	lockf(a, b, 0)
# ifdef LOCK_EX
#  undef LOCK_EX
# endif /* LOCK_EX */
# define LOCK_EX	F_LOCK
#endif /* USE_LOCKF */

#ifndef USE_VSYSLOG
# define USE_VSYSLOG	1
#endif /* ! USE_VSYSLOG */

#ifndef LOCK_EX
# include <sys/file.h>
#endif /* ! LOCK_EX */

#if defined(BSD4_4) || defined(__GLIBC__)
#  include <paths.h>
# define _PATH_LOCTMP	"/tmp/local.XXXXXX"
#endif /* defined(BSD4_4) || defined(__GLIBC__) */

#ifdef BSD4_4
# define HAS_ST_GEN	1
#else /* BSD4_4 */
# ifndef _BSD_VA_LIST_
#  define _BSD_VA_LIST_	va_list
# endif /* ! _BSD_VA_LIST_ */
#endif /* BSD4_4 */

#if defined(BSD4_4) || defined(linux)
# define HASSNPRINTF	1
#else /* defined(BSD4_4) || defined(linux) */
# ifndef ultrix
d189 2
a190 2
# endif /* ! ultrix */
#endif /* defined(BSD4_4) || defined(linux) */
d192 15
a206 15
#if SOLARIS >= 20300 || (SOLARIS < 10000 && SOLARIS >= 203)
# define CONTENTLENGTH	1	/* Needs the Content-Length header */
#endif /* SOLARIS >= 20300 || (SOLARIS < 10000 && SOLARIS >= 203) */

#if SOLARIS >= 20600 || (SOLARIS < 10000 && SOLARIS >= 206)
# define HASSNPRINTF	1		/* has snprintf starting in 2.6 */
#endif /* SOLARIS >= 20600 || (SOLARIS < 10000 && SOLARIS >= 206) */

#ifdef HPUX11
# define HASSNPRINTF	1		/* has snprintf starting in 2.6 */
#endif /* HPUX11 */

#if _AIX4 >= 40300
# define HASSNPRINTF	1		/* has snprintf starting in 4.3 */
#endif /* _AIX4 >= 40300 */
d208 1
a208 1
#if !HASSNPRINTF
d210 1
a210 1
# ifndef _CRAY
d212 2
a213 2
# endif /* ! _CRAY */
#endif /* !HASSNPRINTF */
d220 3
a222 3
#ifdef USE_SETEUID
# define setreuid(r, e)		seteuid(e)
#endif /* USE_SETEUID */
d227 21
a247 14
#ifdef USE_SETRESUID
# define setreuid(r, e)		setresuid(-1, e, -1)
#endif /* USE_SETRESUID */

#ifndef _PATH_LOCTMP
# define _PATH_LOCTMP	"/tmp/local.XXXXXX"
#endif /* ! _PATH_LOCTMP */
# ifndef _PATH_MAILDIR
#  define _PATH_MAILDIR	"/var/spool/mail"
# endif /* ! _PATH_MAILDIR */

#ifndef S_ISREG
# define S_ISREG(mode)	(((mode) & _S_IFMT) == S_IFREG)
#endif /* ! S_ISREG */
a256 4
#ifdef MAILLOCK
# include <maillock.h>
#endif /* MAILLOCK */

d278 1
d292 1
d300 1
a300 1
#ifdef LOG_MAIL
d302 1
a302 1
#else /* LOG_MAIL */
d304 1
a304 1
#endif /* LOG_MAIL */
d307 1
a307 1
	while ((ch = getopt(argc, argv, "7bdf:r:l")) != EOF)
d532 2
a533 1
					deliver(msgfd, rcpt_addr[i], bouncequota);
d623 1
a623 1
						REALLOC((char *)rcpt_addr,
d653 1
a653 1
				while (rcpt_num)
d693 2
a694 1
	bool fullline = TRUE;
d731 2
a732 1
	for (eline = TRUE; fgets(line, sizeof(line), stdin); )
d736 2
d743 1
a743 1
		if (fullline && lmtprcpts && line[0] == '.')
d752 1
a752 1
		/* Check to see if we have the full line from the fgets() */
d760 3
a762 4
				    {
					(void) strlcpy(line + line_len - 2,
						       "\n", sizeof line -
							     line_len + 2);
d764 1
a764 1
				    }
d784 1
a784 1
		if (line[0] == '\n' && HeaderLength == 0)
d799 1
a799 1
		if (line[0] == '\n')
d806 1
a806 1
				(void)putc('>', fp);
d810 1
a810 1
			if (HeaderLength == 0 &&
d813 8
a820 1
					continue;
d874 2
a875 1
			snprintf(line, sizeof line, "%ld\n", (long) BodyLength);
d910 2
a911 1
	struct stat fsb, sb;
d914 1
a914 1
	int mbfd, nr = 0, nw, off;
d936 2
a937 1
				printf("451 4.3.0 cannot lookup name: %s\r\n", name);
d973 1
d976 1
d1027 1
a1027 1
		gid_t gid = pw->pw_gid;
d1035 2
a1036 2
		mbfd = open(path, O_APPEND|O_CREAT|O_EXCL|O_WRONLY, mode);

a1045 2
		else
			sb.st_uid = pw->pw_uid;
d1050 5
d1056 1
a1056 1
		else if (fchown(mbfd, pw->pw_uid, gid) < 0)
d1059 1
a1059 1
				pw->pw_uid, gid, name);
d1062 13
d1081 1
a1081 1
	else if (sb.st_uid != pw->pw_uid)
a1087 2
	else
		mbfd = open(path, O_APPEND|O_WRONLY, 0);
d1089 12
a1100 1
	if (mbfd == -1)
d1111 1
a1111 1
#if HAS_ST_GEN && 0		/* AFS returns random values for st_gen */
d1113 1
a1113 1
#endif /* HAS_ST_GEN && 0 */
d1133 2
a1134 2
		(void)snprintf(biffmsg, sizeof(biffmsg), "%s@@%s\n",
			       name, quad_to_string(curoff));
d1136 2
a1137 2
		(void)snprintf(biffmsg, sizeof(biffmsg), "%s@@%ld\n",
			       name, (long) curoff);
a1145 6
	if (setreuid(0, pw->pw_uid) < 0)
	{
		mailerr("450 4.2.0", "setreuid(0, %d): %s (r=%d, e=%d)",
		     pw->pw_uid, errstring(errno), getuid(), geteuid());
		goto err1;
	}
d1147 1
a1147 1
	fprintf(stderr, "new euid = %d\n", geteuid());
d1216 2
a1217 1
err1:		(void) close(mbfd);
d1264 1
a1264 1
	int r;
d1412 1
a1412 1
	mailerr(NULL, "usage: mail.local [-l] [-f from] user ...");
d1688 2
a1689 2
			if ((*doopen =
			    open(path, O_CREAT|O_EXCL|O_RDWR, 0600)) >= 0)
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
"@@(#) Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.\n\
d22 1
a22 1
static char id[] = "@@(#)$Sendmail: mail.local.c,v 8.143.4.57 2001/02/11 20:08:20 gshapiro Exp $";
d34 28
a61 32

/* additional mode for open() */
# define EXTRA_MODE 0

# include <sys/types.h>
# include <sys/param.h>
# include <sys/stat.h>
# include <sys/socket.h>
# include <sys/file.h>

# include <netinet/in.h>
# include <arpa/nameser.h>

# include <fcntl.h>
# include <netdb.h>
#  include <pwd.h>
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <syslog.h>
# include <time.h>
# include <unistd.h>
# ifdef EX_OK
#  undef EX_OK		/* unistd.h may have another use for this */
# endif /* EX_OK */
# include <sysexits.h>
# include <ctype.h>

# ifndef __P
#  include "sendmail/cdefs.h"
# endif /* ! __P */
# include "sendmail/useful.h"
d66 22
a87 20
# if defined(BSD4_4) || defined(__osf__) || defined(__GNU_LIBRARY__) || defined(IRIX64) || defined(IRIX5) || defined(IRIX6)
#  ifndef HASSTRERROR
#   define HASSTRERROR	1
#  endif /* ! HASSTRERROR */
# endif /* defined(BSD4_4) || defined(__osf__) || defined(__GNU_LIBRARY__) || defined(IRIX64) || defined(IRIX5) || defined(IRIX6) */

# include "sendmail/errstring.h"

# ifndef LOCKTO_RM
#  define LOCKTO_RM	300	/* timeout for stale lockfile removal */
# endif /* ! LOCKTO_RM */
# ifndef LOCKTO_GLOB
#  define LOCKTO_GLOB	400	/* global timeout for lockfile creation */
# endif /* ! LOCKTO_GLOB */

# ifdef __STDC__
#  include <stdarg.h>
#  define REALLOC(ptr, size)	realloc(ptr, size)
# else /* __STDC__ */
#  include <varargs.h>
d89 2
a90 2
#  define REALLOC(ptr, size)	(((ptr) == NULL) ? malloc(size) : realloc(ptr, size))
# endif /* __STDC__ */
d92 50
a141 44
# if (defined(sun) && defined(__svr4__)) || defined(__SVR4)
#  define USE_LOCKF	1
#  define USE_SETEUID	1
#   define _PATH_MAILDIR	"/var/mail"
# endif /* (defined(sun) && defined(__svr4__)) || defined(__SVR4) */

# ifdef NCR_MP_RAS3
#  define USE_LOCKF	1
#  define HASSNPRINTF	1
#   define _PATH_MAILDIR	"/var/mail"
# endif /* NCR_MP_RAS3 */

# if defined(_AIX)
#  define USE_LOCKF	1
#  define USE_SETEUID	1
# endif /* defined(_AIX) */

# if defined(__hpux)
#  define USE_LOCKF	1
#  define USE_SETRESUID	1
# endif /* defined(__hpux) */

# ifdef DGUX
#  define HASSNPRINTF	1
#  define USE_LOCKF	1
# endif /* DGUX */

# if defined(_CRAY)
#  if !defined(MAXPATHLEN)
#   define MAXPATHLEN PATHSIZE
#  endif /* !defined(MAXPATHLEN) */
#   define _PATH_MAILDIR	"/usr/spool/mail"
# endif /* defined(_CRAY) */

# if defined(NeXT) && !defined(__APPLE__)
#  include <libc.h>
#   define _PATH_MAILDIR	"/usr/spool/mail"
#  define S_IRUSR	S_IREAD
#  define S_IWUSR	S_IWRITE
# endif /* defined(NeXT) && !defined(__APPLE__) */

# if defined(IRIX64) || defined(IRIX5) || defined(IRIX6)
#   include <paths.h>
# endif /* defined(IRIX64) || defined(IRIX5) || defined(IRIX6) */
d147 33
a179 29
# ifdef USE_LOCKF
#  define flock(a, b)	lockf(a, b, 0)
#  ifdef LOCK_EX
#   undef LOCK_EX
#  endif /* LOCK_EX */
#  define LOCK_EX	F_LOCK
# endif /* USE_LOCKF */

# ifndef LOCK_EX
#  include <sys/file.h>
# endif /* ! LOCK_EX */

# if defined(BSD4_4) || defined(__GLIBC__)
#   include <paths.h>
#  define _PATH_LOCTMP	"/tmp/local.XXXXXX"
# endif /* defined(BSD4_4) || defined(__GLIBC__) */

# ifdef BSD4_4
#  define HAS_ST_GEN	1
# else /* BSD4_4 */
#  ifndef _BSD_VA_LIST_
#   define _BSD_VA_LIST_	va_list
#  endif /* ! _BSD_VA_LIST_ */
# endif /* BSD4_4 */

# if defined(BSD4_4) || defined(linux)
#  define HASSNPRINTF	1
# else /* defined(BSD4_4) || defined(linux) */
#  ifndef ultrix
d181 2
a182 2
#  endif /* ! ultrix */
# endif /* defined(BSD4_4) || defined(linux) */
d184 15
a198 15
# if SOLARIS >= 20300 || (SOLARIS < 10000 && SOLARIS >= 203)
#  define CONTENTLENGTH	1	/* Needs the Content-Length header */
# endif /* SOLARIS >= 20300 || (SOLARIS < 10000 && SOLARIS >= 203) */

# if SOLARIS >= 20600 || (SOLARIS < 10000 && SOLARIS >= 206)
#  define HASSNPRINTF	1		/* has snprintf starting in 2.6 */
# endif /* SOLARIS >= 20600 || (SOLARIS < 10000 && SOLARIS >= 206) */

# ifdef HPUX11
#  define HASSNPRINTF	1		/* has snprintf starting in 11.X */
# endif /* HPUX11 */

# if _AIX4 >= 40300
#  define HASSNPRINTF	1		/* has snprintf starting in 4.3 */
# endif /* _AIX4 >= 40300 */
d200 1
a200 1
# if !HASSNPRINTF && !SFIO
d202 1
a202 1
#  ifndef _CRAY
d204 2
a205 2
#  endif /* ! _CRAY */
# endif /* !HASSNPRINTF && !SFIO */
d212 3
a214 4

# ifdef USE_SETEUID
#  define setreuid(r, e)		seteuid(e)
# endif /* USE_SETEUID */
d219 14
a232 22

# ifdef USE_SETRESUID
#  define setreuid(r, e)		setresuid(-1, e, -1)
# endif /* USE_SETRESUID */

# ifndef _PATH_LOCTMP
#  define _PATH_LOCTMP	"/tmp/local.XXXXXX"
# endif /* ! _PATH_LOCTMP */
#  ifndef _PATH_MAILDIR
#   define _PATH_MAILDIR	"/var/spool/mail"
#  endif /* ! _PATH_MAILDIR */

# ifndef S_ISREG
#  define S_ISREG(mode)	(((mode) & _S_IFMT) == S_IFREG)
# endif /* ! S_ISREG */

# ifdef MAILLOCK
#  include <maillock.h>
# endif /* MAILLOCK */

# define U_UID pw->pw_uid
# define U_GID pw->pw_gid
d242 4
a252 1
char	ErrBuf[10240];			/* error buffer */
a253 1
bool	HoldErrs = FALSE;		/* Hold errors in ErrBuf */
d255 1
a255 1
bool	BounceQuota = FALSE;		/* permanent error when over quota */
d257 1
a257 1
void	deliver __P((int, char *));
d260 1
a260 1
int	store __P((char *, int, bool *));
d262 1
a265 2
void	flush_error __P((void));

d278 1
a278 1

d287 1
a287 1
# ifdef LOG_MAIL
d289 1
a289 1
# else /* LOG_MAIL */
d291 1
a291 1
# endif /* LOG_MAIL */
d294 1
a294 1
	while ((ch = getopt(argc, argv, "7bdf:r:l")) != -1)
d303 1
a303 1
			BounceQuota = TRUE;
d313 1
a313 1
				mailerr(NULL, "Multiple -f options");
d335 1
a335 13
	{
		extern void dolmtp __P((void));

		if (argc > 0)
		{
			mailerr("421", "Users should not be specified in command line if LMTP required");
			exit(EX_TEMPFAIL);
		}

		dolmtp();
		/* NOTREACHED */
		exit(EX_OK);
	}
a336 1
	/* Non-LMTP from here on out */
a344 1

d361 2
a362 11

	HoldErrs = TRUE;
	fd = store(from, 0, NULL);
	HoldErrs = FALSE;
	if (fd < 0)
	{
		flush_error();
		exit(ExitVal);
	}
	for (; *argv != NULL; ++argv)
		deliver(fd, *argv);
d450 1
a450 1
		mailerr("421 4.3.0", "Memory exhausted");
d463 1
a463 1
		return "550 5.1.1 User unknown";
d470 2
a471 1
dolmtp()
a484 1
	memset(myhostname, '\0', sizeof myhostname);
a485 2
	if (myhostname[0] == '\0')
		strlcpy(myhostname, "localhost", sizeof myhostname);
a504 2
				bool inbody = FALSE;

d507 1
a507 1
					mailerr("503 5.5.1", "No recipients");
d510 2
a511 6
				HoldErrs = TRUE;
				msgfd = store(return_path, rcpt_num, &inbody);
				HoldErrs = FALSE;
				if (msgfd < 0 && !inbody)
				{
					flush_error();
a512 1
				}
a515 6
					if (msgfd < 0)
					{
						/* print error for rcpt */
						flush_error();
						continue;
					}
d518 2
a519 2
						*p = '\0';
					deliver(msgfd, rcpt_addr[i]);
d521 1
a521 2
				if (msgfd >= 0)
					(void) close(msgfd);
d535 1
a535 1
					mailerr("503", "%s Duplicate LHLO",
d557 1
a557 2
					mailerr("503 5.5.1",
						"Nested MAIL command");
d564 1
a564 2
					mailerr("501 5.5.4",
						"Syntax error in parameters");
d567 1
a567 1
				printf("250 2.5.0 Ok\r\n");
d578 1
a578 1
				printf("250 2.0.0 Ok\r\n");
d589 1
a589 1
				printf("221 2.0.0 Bye\r\n");
d602 1
a602 2
					mailerr("503 5.5.1",
						"Need MAIL command");
d609 1
a609 1
						REALLOC((char *) rcpt_addr,
d614 1
a614 2
						mailerr("421 4.3.0",
							"Memory exhausted");
d622 1
a622 2
					mailerr("501 5.5.4",
						"Syntax error in parameters");
d625 1
a625 2
				err = process_recipient(rcpt_addr[rcpt_num]);
				if (err != NULL)
d627 1
a627 1
					mailerr(NULL, "%s", err);
d631 1
a631 1
				printf("250 2.1.5 Ok\r\n");
d636 1
a636 1
				printf("250 2.0.0 Ok\r\n");
d639 1
a639 1
				while (rcpt_num > 0)
d654 1
a654 1
				printf("252 2.3.3 Try RCPT to attempt delivery\r\n");
d663 1
a663 1
			mailerr("500 5.5.2", "Syntax error");
d672 1
a672 1
store(from, lmtprcpts, inbody)
a674 1
	bool *inbody;
d679 1
a679 2
	bool fullline = TRUE;	/* current line is terminated */
	bool prevfl;		/* previous line was terminated */
a683 3
	if (inbody != NULL)
		*inbody = FALSE;

d686 1
a686 1
	if ((fd = mkstemp(tmpbuf)) < 0 || (fp = fdopen(fd, "w+")) == NULL)
d688 10
a697 2
		mailerr("451 4.3.0", "Unable to open temporary file");
		return -1;
d703 1
a703 1
		printf("354 Go ahead\r\n");
a705 2
	if (inbody != NULL)
		*inbody = TRUE;
d716 1
a716 2
	eline = TRUE;
	while (fgets(line, sizeof(line), stdin) != (char *) NULL)
a719 2

		prevfl = fullline;	/* preserve state of previous line */
d725 1
a725 1
		if (prevfl && LMTPMode && line[0] == '.')
d734 1
a734 1
		/* Check to see if we have the full line from fgets() */
d742 4
a745 3
				{
					line[line_len - 2] = '\n';
					line[line_len - 1] = '\0';
d747 1
a747 1
				}
d767 1
a767 1
		if (prevfl && line[0] == '\n' && HeaderLength == 0)
d770 1
a770 2
			if (fp != NULL)
				HeaderLength = ftell(fp);
d782 1
a782 1
		if (prevfl && line[0] == '\n')
a787 1
			    fp != NULL &&
d789 1
a789 1
				(void) putc('>', fp);
d793 1
a793 1
			if (prevfl && HeaderLength == 0 &&
d796 1
a796 8
			{
				/*
				**  be paranoid: clear the line
				**  so no "wrong matches" may occur later
				*/
				line[0] = '\0';
				continue;
			}
d800 2
a801 1
		if (fp != NULL)
d803 8
a810 2
			(void) fwrite(line, sizeof(char), line_len, fp);
			if (ferror(fp))
d813 1
a813 1
					"Temporary file write error");
d815 1
a815 2
				fp = NULL;
				continue;
d820 1
a820 5
	/* check if an error occurred */
	if (fp == NULL)
		return -1;

	if (LMTPMode)
d827 1
a827 1
	if (fp != NULL && strchr(line, '\n') == NULL)
d833 1
a833 2
	if (fp != NULL)
		BodyLength = ftell(fp);
d850 1
a850 2
			snprintf(line, sizeof line, "%ld\n",
				 (long) BodyLength);
d858 1
a858 2
	if (fp != NULL)
		(void) putc('\n', fp);
d860 1
a860 1
	if (fp == NULL || fflush(fp) == EOF || ferror(fp) != 0)
d862 4
a865 2
		mailerr("451 4.3.0", "Temporary file write error");
		if (fp != NULL)
d867 8
a874 1
		return -1;
d880 1
a880 1
deliver(fd, name)
d883 1
d885 1
a885 2
	struct stat fsb;
	struct stat sb;
d888 1
a888 1
	int mbfd = -1, nr = 0, nw, off;
a889 1
	char *errcode;
a902 1

d905 9
a913 2
		if (ExitVal == EX_TEMPFAIL)
			errcode = "451 4.3.0";
d916 7
a922 2
			ExitVal = EX_UNAVAILABLE;
			errcode = "550 5.1.1";
a923 1
		mailerr(errcode, "Unknown name: %s", name);
a945 1

a947 1

d981 3
a983 1
			errcode = "451 4.3.0";
d986 5
a990 4
			errcode = "551 5.3.0";

		mailerr(errcode, "lockmailbox %s failed; error code %d %s",
			p, off, errno > 0 ? errstring(errno) : "");
d998 1
a998 1
		gid_t gid = U_GID;
d1006 2
a1007 2
		mbfd = open(path, O_APPEND|O_CREAT|O_EXCL|O_WRONLY|EXTRA_MODE,
			    mode);
d1017 3
a1019 1
		if (mbfd < 0)
a1022 5

			/* open failed, don't try again */
			mailerr("450 4.2.0", "%s: %s", path,
				errstring(save_errno));
			goto err0;
d1024 1
a1024 1
		else if (fchown(mbfd, U_UID, gid) < 0)
d1027 1
a1027 1
				U_UID, gid, name);
a1029 13
		else
		{
			/*
			**  open() was successful, now close it so can
			**  be opened as the right owner again.
			**  Paranoia: reset mbdf since the file descriptor
			**  is no longer valid; better safe than sorry.
			*/

			sb.st_uid = U_UID;
			(void) close(mbfd);
			mbfd = -1;
		}
d1036 1
a1036 1
	else if (sb.st_uid != U_UID)
d1043 2
d1046 1
a1046 12
	/* change UID for quota checks */
	if (setreuid(0, U_UID) < 0)
	{
		mailerr("450 4.2.0", "setreuid(0, %d): %s (r=%d, e=%d)",
			U_UID, errstring(errno), getuid(), geteuid());
		goto err1;
	}
#ifdef DEBUG
	fprintf(stderr, "new euid = %d\n", geteuid());
#endif /* DEBUG */
	mbfd = open(path, O_APPEND|O_WRONLY|EXTRA_MODE, 0);
	if (mbfd < 0)
d1057 1
a1057 1
# if HAS_ST_GEN && 0		/* AFS returns random values for st_gen */
d1059 1
a1059 1
# endif /* HAS_ST_GEN && 0 */
d1077 1
a1077 1
	curoff = lseek(mbfd, (off_t) 0, SEEK_END);
d1079 2
a1080 2
		(void) snprintf(biffmsg, sizeof(biffmsg), "%s@@%s\n",
				name, quad_to_string(curoff));
d1082 2
a1083 2
		(void) snprintf(biffmsg, sizeof(biffmsg), "%s@@%ld\n",
				name, (long) curoff);
d1086 1
a1086 1
	if (lseek(fd, (off_t) 0, SEEK_SET) == (off_t) -1)
d1088 1
a1088 1
		mailerr("450 4.2.0", "Temporary file: %s",
d1092 6
d1099 1
a1099 1
	fprintf(stderr, "before writing: euid = %d\n", geteuid());
a1130 1
				errcode = "450 4.2.0";
d1132 4
a1135 2
				if (errno == EDQUOT && BounceQuota)
					errcode = "552 5.2.2";
d1137 1
a1137 1
				mailerr(errcode, "%s: %s",
d1145 1
a1145 1
		mailerr("450 4.2.0", "Temporary file: %s",
d1155 9
a1163 1
		(void) setreuid(0, 0);
d1168 1
a1168 2
err1:		if (mbfd >= 0)
			(void) close(mbfd);
a1175 1
		errcode = "450 4.2.0";
d1177 3
a1179 2
		if (errno == EDQUOT && BounceQuota)
			errcode = "552 5.2.2";
d1181 1
a1181 1
		mailerr(errcode, "%s: %s", path, errstring(errno));
d1198 1
a1198 1
		printf("250 2.1.5 %s Ok\r\n", name);
d1215 1
a1215 1
	int r = 0;
d1353 1
a1353 1
	if (f < 0 && (f = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
d1363 1
a1363 1
	mailerr(NULL, "usage: mail.local [-7] [-b] [-l] [-f from] user ...");
a1376 1
	size_t len = 0;
a1378 2
	(void) e_to_sys(errno);

a1383 1

d1387 8
a1394 4
		{
			snprintf(ErrBuf, sizeof ErrBuf, "%s ", hdr);
			len = strlen(ErrBuf);
		}
a1395 8
	(void) vsnprintf(&ErrBuf[len], sizeof ErrBuf - len, fmt, ap);

	if (!HoldErrs)
		flush_error();

	/* Log the message to syslog. */
	if (!LMTPMode)
		syslog(LOG_ERR, "%s", ErrBuf);
d1399 3
a1401 1
flush_error()
d1403 16
a1418 3
	if (LMTPMode)
		printf("%s\r\n", ErrBuf);
	else
d1420 4
a1423 3
		if (ExitVal != EX_USAGE)
			(void) fprintf(stderr, "mail.local: ");
		fprintf(stderr, "%s\n", ErrBuf);
d1425 1
a1431 1

d1444 1
a1444 1
		if (BounceQuota)
d1585 9
d1639 2
a1640 2
			if ((*doopen = open(path, O_CREAT|O_EXCL|O_RDWR,
					    0600)) >= 0)
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
"@@(#) Copyright (c) 1998, 1999 Sendmail, Inc. and its suppliers.\n\
d22 1
a22 1
static char id[] = "@@(#)$Sendmail: mail.local.c,v 8.142 2000/02/26 01:32:19 gshapiro Exp $";
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d15 1
a15 1
"@@(#) Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.\n\
d22 1
a22 1
static char id[] = "@@(#)$Id: mail.local.c,v 8.143.4.39 2000/11/14 20:02:47 gshapiro Exp $";
d34 28
a61 32

/* additional mode for open() */
# define EXTRA_MODE 0

# include <sys/types.h>
# include <sys/param.h>
# include <sys/stat.h>
# include <sys/socket.h>
# include <sys/file.h>

# include <netinet/in.h>
# include <arpa/nameser.h>

# include <fcntl.h>
# include <netdb.h>
#  include <pwd.h>
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <syslog.h>
# include <time.h>
# include <unistd.h>
# ifdef EX_OK
#  undef EX_OK		/* unistd.h may have another use for this */
# endif /* EX_OK */
# include <sysexits.h>
# include <ctype.h>

# ifndef __P
#  include "sendmail/cdefs.h"
# endif /* ! __P */
# include "sendmail/useful.h"
d66 22
a87 20
# if defined(BSD4_4) || defined(__osf__) || defined(__GNU_LIBRARY__) || defined(IRIX64) || defined(IRIX5) || defined(IRIX6)
#  ifndef HASSTRERROR
#   define HASSTRERROR	1
#  endif /* ! HASSTRERROR */
# endif /* defined(BSD4_4) || defined(__osf__) || defined(__GNU_LIBRARY__) || defined(IRIX64) || defined(IRIX5) || defined(IRIX6) */

# include "sendmail/errstring.h"

# ifndef LOCKTO_RM
#  define LOCKTO_RM	300	/* timeout for stale lockfile removal */
# endif /* ! LOCKTO_RM */
# ifndef LOCKTO_GLOB
#  define LOCKTO_GLOB	400	/* global timeout for lockfile creation */
# endif /* ! LOCKTO_GLOB */

# ifdef __STDC__
#  include <stdarg.h>
#  define REALLOC(ptr, size)	realloc(ptr, size)
# else /* __STDC__ */
#  include <varargs.h>
d89 2
a90 2
#  define REALLOC(ptr, size)	(((ptr) == NULL) ? malloc(size) : realloc(ptr, size))
# endif /* __STDC__ */
d92 50
a141 56
# if (defined(sun) && defined(__svr4__)) || defined(__SVR4)
#  define USE_LOCKF	1
#  define USE_SETEUID	1
#   define _PATH_MAILDIR	"/var/mail"
# endif /* (defined(sun) && defined(__svr4__)) || defined(__SVR4) */

# ifdef NCR_MP_RAS3
#  define USE_LOCKF	1
#  define HASSNPRINTF	1
#   define _PATH_MAILDIR	"/var/mail"
# endif /* NCR_MP_RAS3 */

# if defined(_AIX)
#  define USE_LOCKF	1
#  define USE_SETEUID	1
#  define USE_VSYSLOG	0
# endif /* defined(_AIX) */

# if defined(__hpux)
#  define USE_LOCKF	1
#  define USE_SETRESUID	1
#  define USE_VSYSLOG	0
# endif /* defined(__hpux) */

# ifdef DGUX
#  define HASSNPRINTF	1
#  define USE_LOCKF	1
#  define USE_VSYSLOG	0
# endif /* DGUX */

# if defined(_CRAY)
#  if !defined(MAXPATHLEN)
#   define MAXPATHLEN PATHSIZE
#  endif /* !defined(MAXPATHLEN) */
#  define USE_VSYSLOG   0
#   define _PATH_MAILDIR	"/usr/spool/mail"
# endif /* defined(_CRAY) */

# if defined(ultrix)
#  define USE_VSYSLOG	0
# endif /* defined(ultrix) */

# if defined(__osf__)
#  define USE_VSYSLOG	0
# endif /* defined(__osf__) */

# if defined(NeXT) && !defined(__APPLE__)
#  include <libc.h>
#   define _PATH_MAILDIR	"/usr/spool/mail"
#  define S_IRUSR	S_IREAD
#  define S_IWUSR	S_IWRITE
# endif /* defined(NeXT) && !defined(__APPLE__) */

# if defined(IRIX64) || defined(IRIX5) || defined(IRIX6)
#   include <paths.h>
# endif /* defined(IRIX64) || defined(IRIX5) || defined(IRIX6) */
d147 33
a179 33
# ifdef USE_LOCKF
#  define flock(a, b)	lockf(a, b, 0)
#  ifdef LOCK_EX
#   undef LOCK_EX
#  endif /* LOCK_EX */
#  define LOCK_EX	F_LOCK
# endif /* USE_LOCKF */

# ifndef USE_VSYSLOG
#  define USE_VSYSLOG	1
# endif /* ! USE_VSYSLOG */

# ifndef LOCK_EX
#  include <sys/file.h>
# endif /* ! LOCK_EX */

# if defined(BSD4_4) || defined(__GLIBC__)
#   include <paths.h>
#  define _PATH_LOCTMP	"/tmp/local.XXXXXX"
# endif /* defined(BSD4_4) || defined(__GLIBC__) */

# ifdef BSD4_4
#  define HAS_ST_GEN	1
# else /* BSD4_4 */
#  ifndef _BSD_VA_LIST_
#   define _BSD_VA_LIST_	va_list
#  endif /* ! _BSD_VA_LIST_ */
# endif /* BSD4_4 */

# if defined(BSD4_4) || defined(linux)
#  define HASSNPRINTF	1
# else /* defined(BSD4_4) || defined(linux) */
#  ifndef ultrix
d181 2
a182 2
#  endif /* ! ultrix */
# endif /* defined(BSD4_4) || defined(linux) */
d184 15
a198 15
# if SOLARIS >= 20300 || (SOLARIS < 10000 && SOLARIS >= 203)
#  define CONTENTLENGTH	1	/* Needs the Content-Length header */
# endif /* SOLARIS >= 20300 || (SOLARIS < 10000 && SOLARIS >= 203) */

# if SOLARIS >= 20600 || (SOLARIS < 10000 && SOLARIS >= 206)
#  define HASSNPRINTF	1		/* has snprintf starting in 2.6 */
# endif /* SOLARIS >= 20600 || (SOLARIS < 10000 && SOLARIS >= 206) */

# ifdef HPUX11
#  define HASSNPRINTF	1		/* has snprintf starting in 11.X */
# endif /* HPUX11 */

# if _AIX4 >= 40300
#  define HASSNPRINTF	1		/* has snprintf starting in 4.3 */
# endif /* _AIX4 >= 40300 */
d200 1
a200 1
# if !HASSNPRINTF
d202 1
a202 1
#  ifndef _CRAY
d204 2
a205 2
#  endif /* ! _CRAY */
# endif /* !HASSNPRINTF */
d212 3
a214 3
# ifdef USE_SETEUID
#  define setreuid(r, e)		seteuid(e)
# endif /* USE_SETEUID */
d219 14
a232 21
# ifdef USE_SETRESUID
#  define setreuid(r, e)		setresuid(-1, e, -1)
# endif /* USE_SETRESUID */

# ifndef _PATH_LOCTMP
#  define _PATH_LOCTMP	"/tmp/local.XXXXXX"
# endif /* ! _PATH_LOCTMP */
#  ifndef _PATH_MAILDIR
#   define _PATH_MAILDIR	"/var/spool/mail"
#  endif /* ! _PATH_MAILDIR */

# ifndef S_ISREG
#  define S_ISREG(mode)	(((mode) & _S_IFMT) == S_IFREG)
# endif /* ! S_ISREG */

# ifdef MAILLOCK
#  include <maillock.h>
# endif /* MAILLOCK */

# define U_UID pw->pw_uid
# define U_GID pw->pw_gid
d242 4
a266 1

a279 1

d287 1
a287 1
# ifdef LOG_MAIL
d289 1
a289 1
# else /* LOG_MAIL */
d291 1
a291 1
# endif /* LOG_MAIL */
d294 1
a294 1
	while ((ch = getopt(argc, argv, "7bdf:r:l")) != -1)
d519 1
a519 2
					deliver(msgfd, rcpt_addr[i],
						bouncequota);
d609 1
a609 1
						REALLOC((char *) rcpt_addr,
d639 1
a639 1
				while (rcpt_num > 0)
d679 1
a679 2
	bool fullline = TRUE;	/* current line is terminated */
	bool prevfl;		/* previous line was terminated */
d716 1
a716 2
	eline = TRUE;
	while (fgets(line, sizeof(line), stdin) != (char *)NULL)
a719 2

		prevfl = fullline;	/* preserve state of previous line */
d725 1
a725 1
		if (prevfl && lmtprcpts && line[0] == '.')
d734 1
a734 1
		/* Check to see if we have the full line from fgets() */
d742 4
a745 3
				{
					line[line_len - 2] = '\n';
					line[line_len - 1] = '\0';
d747 1
a747 1
				}
d767 1
a767 1
		if (prevfl && line[0] == '\n' && HeaderLength == 0)
d782 1
a782 1
		if (prevfl && line[0] == '\n')
d789 1
a789 1
				(void) putc('>', fp);
d793 1
a793 1
			if (prevfl && HeaderLength == 0 &&
d796 1
a796 8
			{
				/*
				**  be paranoid: clear the line
				**  so no "wrong matches" may occur later
				*/
				line[0] = '\0';
				continue;
			}
d850 1
a850 2
			snprintf(line, sizeof line, "%ld\n",
				 (long) BodyLength);
d885 1
a885 2
	struct stat fsb;
	struct stat sb;
d888 1
a888 1
	int mbfd = -1, nr = 0, nw, off;
d910 1
a910 2
				printf("451 4.3.0 cannot lookup name: %s\r\n",
				       name);
a945 1

a947 1

d998 1
a998 1
		gid_t gid = U_GID;
d1006 2
a1007 2
		mbfd = open(path, O_APPEND|O_CREAT|O_EXCL|O_WRONLY|EXTRA_MODE,
			    mode);
d1017 2
a1022 5

			/* open failed, don't try again */
			mailerr("450 4.2.0", "%s: %s", path,
				errstring(save_errno));
			goto err0;
d1024 1
a1024 1
		else if (fchown(mbfd, U_UID, gid) < 0)
d1027 1
a1027 1
				U_UID, gid, name);
a1029 13
		else
		{
			/*
			**  open() was successful, now close it so can
			**  be opened as the right owner again.
			**  Paranoia: reset mbdf since the file descriptor
			**  is no longer valid; better safe than sorry.
			*/

			sb.st_uid = U_UID;
			(void) close(mbfd);
			mbfd = -1;
		}
d1036 1
a1036 1
	else if (sb.st_uid != U_UID)
d1043 2
d1046 1
a1046 12
	/* change UID for quota checks */
	if (setreuid(0, U_UID) < 0)
	{
		mailerr("450 4.2.0", "setreuid(0, %d): %s (r=%d, e=%d)",
			U_UID, errstring(errno), getuid(), geteuid());
		goto err1;
	}
#ifdef DEBUG
	fprintf(stderr, "new euid = %d\n", geteuid());
#endif /* DEBUG */
	mbfd = open(path, O_APPEND|O_WRONLY|EXTRA_MODE, 0);
	if (mbfd < 0)
d1057 1
a1057 1
# if HAS_ST_GEN && 0		/* AFS returns random values for st_gen */
d1059 1
a1059 1
# endif /* HAS_ST_GEN && 0 */
d1079 2
a1080 2
		(void) snprintf(biffmsg, sizeof(biffmsg), "%s@@%s\n",
				name, quad_to_string(curoff));
d1082 2
a1083 2
		(void) snprintf(biffmsg, sizeof(biffmsg), "%s@@%ld\n",
				name, (long) curoff);
d1092 6
d1099 1
a1099 1
	fprintf(stderr, "before writing: euid = %d\n", geteuid());
d1168 1
a1168 2
err1:		if (mbfd >= 0)
			(void) close(mbfd);
d1215 1
a1215 1
	int r = 0;
d1363 1
a1363 1
	mailerr(NULL, "usage: mail.local [-7] [-b] [-l] [-f from] user ...");
d1639 2
a1640 2
			if ((*doopen = open(path, O_CREAT|O_EXCL|O_RDWR,
					    0600)) >= 0)
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d13 3
a15 4
#include <sm/gen.h>

SM_IDSTR(copyright,
"@@(#) Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.\n\
d18 2
a19 1
	The Regents of the University of California.  All rights reserved.\n")
d21 3
a23 11
SM_IDSTR(id, "@@(#)$Sendmail: mail.local.c,v 8.232 2001/09/08 01:21:04 gshapiro Exp $")

#include <stdlib.h>
#include <sm/errstring.h>
#include <sm/io.h>
# include <unistd.h>
# ifdef EX_OK
#  undef EX_OK		/* unistd.h may have another use for this */
# endif /* EX_OK */
#include <sm/mbdb.h>
#include <sm/sysexits.h>
d28 2
a29 2
**  approach to mailboxes (essentially, they have a set-group-ID program
**  rather than set-user-ID, and they rely on the ability to "give away"
d35 6
a40 7
#include <stdio.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <time.h>
#include <stdlib.h>
d43 1
d46 2
d49 12
a60 1
# include <pwd.h>
d62 31
a92 3
#include <sm/string.h>
#include <syslog.h>
#include <ctype.h>
d94 56
a149 2
#include <sm/conf.h>
#include <sendmail/pathnames.h>
d151 3
d155 59
a213 13
/* additional mode for open() */
# define EXTRA_MODE 0


#ifndef LOCKTO_RM
# define LOCKTO_RM	300	/* timeout for stale lockfile removal */
#endif /* ! LOCKTO_RM */
#ifndef LOCKTO_GLOB
# define LOCKTO_GLOB	400	/* global timeout for lockfile creation */
#endif /* ! LOCKTO_GLOB */

/* define a realloc() which works for NULL pointers */
#define REALLOC(ptr, size)	(((ptr) == NULL) ? malloc(size) : realloc(ptr, size))
d216 3
a218 1
**  If you don't have flock, you could try using lockf instead.
d220 3
a222 12

#ifdef LDA_USE_LOCKF
# define flock(a, b)	lockf(a, b, 0)
# ifdef LOCK_EX
#  undef LOCK_EX
# endif /* LOCK_EX */
# define LOCK_EX	F_LOCK
#endif /* LDA_USE_LOCKF */

#ifndef LOCK_EX
# include <sys/file.h>
#endif /* ! LOCK_EX */
d225 1
a225 3
**  If you don't have setreuid, and you have saved uids, and you have
**  a seteuid() call that doesn't try to emulate using setuid(), then
**  you can try defining LDA_USE_SETEUID.
d227 18
d246 2
a247 7
#ifdef LDA_USE_SETEUID
# define setreuid(r, e)		seteuid(e)
#endif /* LDA_USE_SETEUID */

#ifdef LDA_CONTENTLENGTH
# define CONTENTLENGTH	1
#endif /* LDA_CONTENTLENGTH */
a252 4
#ifdef MAILLOCK
# include <maillock.h>
#endif /* MAILLOCK */

d263 1
a263 2
bool	EightBitMime = true;		/* advertise 8BITMIME in LMTP */
char	ErrBuf[10240];			/* error buffer */
d265 2
a266 4
bool	HoldErrs = false;		/* Hold errors in ErrBuf */
bool	LMTPMode = false;
bool	BounceQuota = false;		/* permanent error when over quota */
char	*HomeMailFile = NULL;		/* store mail in homedir */
d268 1
a268 1
void	deliver __P((int, char *));
d271 1
a271 1
int	store __P((char *, bool *));
d273 1
a276 1
void	flush_error __P((void));
a287 2
	char *mbdbname = "pw";
	int err;
d290 1
d307 1
a307 1
	while ((ch = getopt(argc, argv, "7bdD:f:h:r:l")) != -1)
d312 1
a312 1
			EightBitMime = false;
d316 1
a316 1
			BounceQuota = true;
a321 4
		  case 'D':		/* mailbox database type */
			mbdbname = optarg;
			break;

d326 1
a326 1
				mailerr(NULL, "Multiple -f options");
a331 10
		  case 'h':
			if (optarg != NULL || *optarg != '\0')
				HomeMailFile = optarg;
			else
			{
				mailerr(NULL, "-h: missing filename");
				usage();
			}
			break;

d333 1
a333 1
			LMTPMode = true;
a346 13
	err = sm_mbdb_initialize(mbdbname);
	if (err != EX_OK)
	{
		char *errcode = "521";

		if (err == EX_TEMPFAIL)
			errcode = "421";

		mailerr(errcode, "Can not open mailbox database %s: %s",
			mbdbname, sm_strexit(err));
		exit(err);
	}

d348 1
a348 8
	{
		extern void dolmtp __P((void));

		if (argc > 0)
		{
			mailerr("421", "Users should not be specified in command line if LMTP required");
			exit(EX_TEMPFAIL);
		}
a349 6
		dolmtp();
		/* NOTREACHED */
		exit(EX_OK);
	}

	/* Non-LMTP from here on out */
d358 1
a359 1
	uid = getuid();
d374 2
a375 11

	HoldErrs = true;
	fd = store(from, NULL);
	HoldErrs = false;
	if (fd < 0)
	{
		flush_error();
		exit(ExitVal);
	}
	for (; *argv != NULL; ++argv)
		deliver(fd, *argv);
a459 2
	if (l < 0)
		return NULL;
d463 1
a463 1
		mailerr("421 4.3.0", "Memory exhausted");
d467 1
a467 1
	(void) sm_strlcpy(p, s, l);
d475 3
a477 16
	SM_MBDB_T user;

	switch (sm_mbdb_lookup(addr, &user))
	{
	  case EX_OK:
		return NULL;

	  case EX_NOUSER:
		return "550 5.1.1 User unknown";

	  case EX_TEMPFAIL:
		return "451 4.3.0 User database failure; retry later";

	  default:
		return "550 5.3.0 User database failure";
	}
d483 2
a484 1
dolmtp()
d490 1
a490 1
	bool gotlhlo = false;
a497 1
	memset(myhostname, '\0', sizeof myhostname);
a498 2
	if (myhostname[0] == '\0')
		sm_strlcpy(myhostname, "localhost", sizeof myhostname);
d516 1
a516 1
			if (sm_strcasecmp(buf, "data") == 0)
a517 2
				bool inbody = false;

d520 1
a520 1
					mailerr("503 5.5.1", "No recipients");
d523 2
a524 6
				HoldErrs = true;
				msgfd = store(return_path, &inbody);
				HoldErrs = false;
				if (msgfd < 0 && !inbody)
				{
					flush_error();
a525 1
				}
a528 6
					if (msgfd < 0)
					{
						/* print error for rcpt */
						flush_error();
						continue;
					}
d531 3
a533 2
						*p = '\0';
					deliver(msgfd, rcpt_addr[i]);
d535 1
a535 2
				if (msgfd >= 0)
					(void) close(msgfd);
d544 1
a544 1
			if (sm_strncasecmp(buf, "lhlo ", 5) == 0)
d549 1
a549 1
					mailerr("503", "%s Duplicate LHLO",
d553 1
a553 1
				gotlhlo = true;
d567 1
a567 1
			if (sm_strncasecmp(buf, "mail ", 5) == 0)
d571 1
a571 2
					mailerr("503 5.5.1",
						"Nested MAIL command");
d574 1
a574 1
				if (sm_strncasecmp(buf+5, "from:", 5) != 0 ||
d576 1
a576 1
							      false)) == NULL))
d578 1
a578 2
					mailerr("501 5.5.4",
						"Syntax error in parameters");
d581 1
a581 1
				printf("250 2.5.0 Ok\r\n");
d590 1
a590 1
			if (sm_strcasecmp(buf, "noop") == 0)
d592 1
a592 1
				printf("250 2.0.0 Ok\r\n");
d601 1
a601 1
			if (sm_strcasecmp(buf, "quit") == 0)
d603 1
a603 1
				printf("221 2.0.0 Bye\r\n");
d612 1
a612 1
			if (sm_strncasecmp(buf, "rcpt ", 5) == 0)
d616 1
a616 2
					mailerr("503 5.5.1",
						"Need MAIL command");
d628 1
a628 2
						mailerr("421 4.3.0",
							"Memory exhausted");
d632 1
a632 1
				if (sm_strncasecmp(buf + 5, "to:", 3) != 0 ||
d634 1
a634 1
								      true)) == NULL))
d636 1
a636 2
					mailerr("501 5.5.4",
						"Syntax error in parameters");
d639 1
a639 2
				err = process_recipient(rcpt_addr[rcpt_num]);
				if (err != NULL)
d641 1
a641 1
					mailerr(NULL, "%s", err);
d645 1
a645 1
				printf("250 2.1.5 Ok\r\n");
d648 1
a648 1
			else if (sm_strcasecmp(buf, "rset") == 0)
d650 1
a650 1
				printf("250 2.0.0 Ok\r\n");
d666 1
a666 1
			if (sm_strncasecmp(buf, "vrfy ", 5) == 0)
d668 1
a668 1
				printf("252 2.3.3 Try RCPT to attempt delivery\r\n");
d677 1
a677 1
			mailerr("500 5.5.2", "Syntax error");
d686 1
a686 1
store(from, inbody)
d688 1
a688 1
	bool *inbody;
d692 2
a693 2
	bool eline;		/* previous line was empty */
	bool fullline = true;	/* current line is terminated */
a698 3
	if (inbody != NULL)
		*inbody = false;

d700 2
a701 2
	(void) sm_strlcpy(tmpbuf, _PATH_LOCTMP, sizeof tmpbuf);
	if ((fd = mkstemp(tmpbuf)) < 0 || (fp = fdopen(fd, "w+")) == NULL)
d703 10
a712 2
		mailerr("451 4.3.0", "Unable to open temporary file");
		return -1;
d718 1
a718 1
		printf("354 Go ahead\r\n");
a720 2
	if (inbody != NULL)
		*inbody = true;
d731 2
a732 2
	eline = true;
	while (fgets(line, sizeof(line), stdin) != (char *) NULL)
d743 1
a743 1
		if (prevfl && LMTPMode && line[0] == '.')
d753 1
a753 1
		fullline = false;
d765 1
a765 1
				fullline = true;
d774 1
a774 1
					fullline = true;
d781 1
a781 1
			fullline = true;
d786 2
a787 3
			eline = false;
			if (fp != NULL)
				HeaderLength = ftell(fp);
d800 1
a800 1
			eline = true;
a804 1
			    fp != NULL &&
d807 1
a807 1
			eline = false;
d812 1
a812 1
			    sm_strncasecmp(line, ContentHdr, 15) == 0)
d824 2
a825 1
		if (fp != NULL)
d827 8
a834 2
			(void) fwrite(line, sizeof(char), line_len, fp);
			if (ferror(fp))
d837 1
a837 1
					"Temporary file write error");
d839 1
a839 2
				fp = NULL;
				continue;
d844 1
a844 5
	/* check if an error occurred */
	if (fp == NULL)
		return -1;

	if (LMTPMode)
d851 1
a851 1
	if (fp != NULL && strchr(line, '\n') == NULL)
d857 1
a857 2
	if (fp != NULL)
		BodyLength = ftell(fp);
d868 9
a876 4
		(void) sm_snprintf(line, sizeof line, "%lld\n",
				   (LONGLONG_T) BodyLength);
		(void) sm_strlcpy(&ContentHdr[16], line,
				  sizeof(ContentHdr) - 16);
d883 1
a883 2
	if (fp != NULL)
		(void) putc('\n', fp);
d885 1
a885 1
	if (fp == NULL || fflush(fp) == EOF || ferror(fp) != 0)
d887 4
a890 2
		mailerr("451 4.3.0", "Temporary file write error");
		if (fp != NULL)
d892 8
a899 1
		return -1;
d905 1
a905 1
deliver(fd, name)
d908 1
d912 1
a914 1
	int exitval;
a915 1
	char *errcode;
d922 2
a923 1
	SM_MBDB_T user;
d929 1
a929 3

	exitval = sm_mbdb_lookup(name, &user);
	switch (exitval)
d931 13
a943 2
	  case EX_OK:
		break;
d945 6
a950 20
	  case EX_NOUSER:
		exitval = EX_UNAVAILABLE;
		mailerr("550 5.1.1", "%s: User unknown", name);
		break;

	  case EX_TEMPFAIL:
		mailerr("451 4.3.0", "%s: User database failure; retry later",
			name);
		break;

	  default:
		exitval = EX_UNAVAILABLE;
		mailerr("550 5.3.0", "%s: User database failure", name);
		break;
	}

	if (exitval != EX_OK)
	{
		if (ExitVal != EX_TEMPFAIL)
			ExitVal = exitval;
a952 1

d974 1
a974 23
	if (HomeMailFile == NULL)
	{
		if (sm_snprintf(path, sizeof(path), "%s/%s",
				_PATH_MAILDIR, name) >= sizeof(path))
		{
			exitval = EX_UNAVAILABLE;
			mailerr("550 5.1.1", "%s: Invalid mailbox path", name);
			return;
		}
	}
	else if (*user.mbdb_homedir == '\0')
	{
		exitval = EX_UNAVAILABLE;
		mailerr("550 5.1.1", "%s: User missing home directory", name);
		return;
	}
	else if (sm_snprintf(path, sizeof(path), "%s/%s",
			     user.mbdb_homedir, HomeMailFile) >= sizeof(path))
	{
		exitval = EX_UNAVAILABLE;
		mailerr("550 5.1.1", "%s: Invalid mailbox path", name);
		return;
	}
d1010 3
a1012 1
			errcode = "451 4.3.0";
d1015 5
a1019 4
			errcode = "551 5.3.0";

		mailerr(errcode, "lockmailbox %s failed; error code %d %s",
			p, off, errno > 0 ? sm_errstring(errno) : "");
d1027 1
a1027 1
		gid_t gid = user.mbdb_gid;
d1046 1
a1046 1
		if (mbfd < 0)
d1053 1
a1053 1
				sm_errstring(save_errno));
d1056 1
a1056 1
		else if (fchown(mbfd, user.mbdb_uid, gid) < 0)
d1059 1
a1059 1
				user.mbdb_uid, gid, name);
d1071 1
a1071 1
			sb.st_uid = user.mbdb_uid;
d1081 1
a1081 1
	else if (sb.st_uid != user.mbdb_uid)
d1085 1
a1085 1
			path, (int) sb.st_uid);
d1090 1
a1090 1
	if (setreuid(0, user.mbdb_uid) < 0)
d1093 1
a1093 2
			(int) user.mbdb_uid, sm_errstring(errno),
			(int) getuid(), (int) geteuid());
d1097 1
a1097 1
	fprintf(stderr, "new euid = %d\n", (int) geteuid());
d1102 1
a1102 1
		mailerr("450 4.2.0", "%s: %s", path, sm_errstring(errno));
a1121 37
#if 0
	/*
	**  This code could be reused if we decide to add a
	**  per-user quota field to the sm_mbdb interface.
	*/

	/*
	**  Fail if the user has a quota specified, and delivery of this
	**  message would exceed that quota.  We bounce such failures using
	**  EX_UNAVAILABLE, unless there were internal problems, since
	**  storing immense messages for later retries can cause queueing
	**  issues.
	*/

	if (ui.quota > 0)
	{
		struct stat dsb;

		if (fstat(fd, &dsb) < 0)
		{
			ExitVal = EX_TEMPFAIL;
			mailerr("451 4.3.0",
				"%s: fstat: can't stat temporary storage: %s",
				ui.mailspool, sm_errstring(errno));
			goto err1;
		}

		if (dsb.st_size + sb.st_size + 1 > ui.quota)
		{
			ExitVal = EX_UNAVAILABLE;
			mailerr("551 5.2.2",
				"%s: Mailbox full or quota exceeded",
				ui.mailspool);
			goto err1;
		}
	}
#endif /* 0 */
d1126 1
a1126 1
		mailerr("450 4.2.0", "%s: %s", path, sm_errstring(errno));
d1131 7
a1137 3
	curoff = lseek(mbfd, (off_t) 0, SEEK_END);
	(void) sm_snprintf(biffmsg, sizeof(biffmsg), "%s@@%lld\n",
			   name, (LONGLONG_T) curoff);
d1140 1
a1140 1
	if (lseek(fd, (off_t) 0, SEEK_SET) == (off_t) -1)
d1142 2
a1143 2
		mailerr("450 4.2.0", "Temporary file: %s",
			sm_errstring(errno));
d1147 1
a1147 1
	fprintf(stderr, "before writing: euid = %d\n", (int) geteuid());
d1155 1
a1155 1
			(void) sm_snprintf(buf, sizeof buf, "%s", ContentHdr);
a1178 1
				errcode = "450 4.2.0";
d1180 4
a1183 2
				if (errno == EDQUOT && BounceQuota)
					errcode = "552 5.2.2";
d1185 2
a1186 2
				mailerr(errcode, "%s: %s",
					path, sm_errstring(errno));
d1193 2
a1194 2
		mailerr("450 4.2.0", "Temporary file: %s",
			sm_errstring(errno));
d1201 1
a1201 1
		mailerr("450 4.2.0", "%s: %s", path, sm_errstring(errno));
d1203 9
a1211 1
		(void) setreuid(0, 0);
d1213 1
a1213 1
		fprintf(stderr, "reset euid = %d\n", (int) geteuid());
a1224 1
		errcode = "450 4.2.0";
d1226 3
a1228 2
		if (errno == EDQUOT && BounceQuota)
			errcode = "552 5.2.2";
d1230 1
a1230 1
		mailerr(errcode, "%s: %s", path, sm_errstring(errno));
d1239 1
a1239 1
			sm_errstring(errno));
d1243 1
a1243 1
	fprintf(stderr, "reset euid = %d\n", (int) geteuid());
d1247 1
a1247 1
		printf("250 2.1.5 %s Ok\r\n", name);
d1257 1
a1257 1
bool	Locked = false;
d1270 1
a1270 1
		Locked = true;
d1297 1
a1297 1
	Locked = false;
d1314 1
a1314 1
	(void) sm_snprintf(LockName, sizeof LockName, "%s.lock", path);
d1334 1
a1334 1
			Locked = true;
d1364 1
a1364 1
	Locked = false;
d1372 1
a1372 1
	static bool initialized = false;
d1381 1
a1381 1
		initialized = true;
d1402 1
a1402 1
	if (f < 0 && (f = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
d1412 1
a1412 1
	mailerr(NULL, "usage: mail.local [-7] [-b] [-d] [-l] [-f from|-r from] [-h filename] user ...");
a1416 1
/*VARARGS2*/
d1426 1
a1426 2
	size_t len = 0;
	SM_VA_LOCAL_DECL
d1428 13
a1440 5
	(void) e_to_sys(errno);

	SM_VA_START(ap, fmt);

	if (LMTPMode && hdr != NULL)
d1442 2
a1443 2
		sm_snprintf(ErrBuf, sizeof ErrBuf, "%s ", hdr);
		len = strlen(ErrBuf);
a1444 9
	(void) sm_vsnprintf(&ErrBuf[len], sizeof ErrBuf - len, fmt, ap);
	SM_VA_END(ap);

	if (!HoldErrs)
		flush_error();

	/* Log the message to syslog. */
	if (!LMTPMode)
		syslog(LOG_ERR, "%s", ErrBuf);
d1448 3
a1450 1
flush_error()
d1452 16
a1467 3
	if (LMTPMode)
		printf("%s\r\n", ErrBuf);
	else
d1469 4
a1472 3
		if (ExitVal != EX_USAGE)
			(void) fprintf(stderr, "mail.local: ");
		fprintf(stderr, "%s\n", ErrBuf);
d1474 1
a1480 1

d1493 1
a1493 1
		if (BounceQuota)
d1634 9
d1651 1
a1651 1
	unsigned int pid;
@


