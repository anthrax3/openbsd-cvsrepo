head	1.26;
access;
symbols
	OPENBSD_5_6:1.25.0.6
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.23.0.8
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.12
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.10
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.6
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.8
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.21.0.6
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.4
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.19.0.4
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.4
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2014.09.17.18.49.52;	author matthieu;	state dead;
branches;
next	1.25;
commitid	M7i5giHIoz3DMlTU;

1.25
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.23;

1.23
date	2011.05.17.15.54.24;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.22.18.43.56;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.08.16.00.51;	author millert;	state Exp;
branches
	1.19.2.1
	1.19.4.1;
next	1.18;

1.18
date	2005.01.12.18.15.46;	author millert;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2004.12.16.00.21.31;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.24.03.59.28;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.09.17.17.31.41;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.29.19.44.01;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.01.19.59.23;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.15.02.23.36;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.03.17.25.47;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.18.00.49.29;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.01.17.18.30;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.11.19.02.50;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.01.01.01.41;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.29.01.31.16;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.28.02.43.55;	author millert;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.01.15.21.09.11;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.07.19.20.44;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.48;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.48;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.19;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.51;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.31.45;	author miod;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.31.01.47.58;	author jason;	state Exp;
branches;
next	;

1.18.2.1
date	2006.03.24.05.42.49;	author brad;	state Exp;
branches;
next	;

1.19.2.1
date	2006.03.24.05.56.18;	author brad;	state Exp;
branches;
next	;

1.19.4.1
date	2006.03.25.01.49.38;	author brad;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2006, 2008-2010 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>

SM_RCSID("@@(#)$Sendmail: usersmtp.c,v 8.488 2013/11/22 20:51:57 ca Exp $")

#include <sysexits.h>


static void	esmtp_check __P((char *, bool, MAILER *, MCI *, ENVELOPE *));
static void	helo_options __P((char *, bool, MAILER *, MCI *, ENVELOPE *));
static int	smtprcptstat __P((ADDRESS *, MAILER *, MCI *, ENVELOPE *));

#if SASL
extern void	*sm_sasl_malloc __P((unsigned long));
extern void	sm_sasl_free __P((void *));
#endif /* SASL */

/*
**  USERSMTP -- run SMTP protocol from the user end.
**
**	This protocol is described in RFC821.
*/

#define SMTPCLOSING	421			/* "Service Shutting Down" */

#define ENHSCN(e, d)	((e) == NULL ? (d) : (e))

#define ENHSCN_RPOOL(e, d, rpool) \
	((e) == NULL ? (d) : sm_rpool_strdup_x(rpool, e))

static char	SmtpMsgBuffer[MAXLINE];		/* buffer for commands */
static char	SmtpReplyBuffer[MAXLINE];	/* buffer for replies */
static bool	SmtpNeedIntro;		/* need "while talking" in transcript */
/*
**  SMTPINIT -- initialize SMTP.
**
**	Opens the connection and sends the initial protocol.
**
**	Parameters:
**		m -- mailer to create connection to.
**		mci -- the mailer connection info.
**		e -- the envelope.
**		onlyhelo -- send only helo command?
**
**	Returns:
**		none.
**
**	Side Effects:
**		creates connection and sends initial protocol.
*/

void
smtpinit(m, mci, e, onlyhelo)
	MAILER *m;
	register MCI *mci;
	ENVELOPE *e;
	bool onlyhelo;
{
	register int r;
	int state;
	register char *p;
	register char *hn;
	char *enhsc;

	enhsc = NULL;
	if (tTd(18, 1))
	{
		sm_dprintf("smtpinit ");
		mci_dump(sm_debug_file(), mci, false);
	}

	/*
	**  Open the connection to the mailer.
	*/

	SmtpError[0] = '\0';
	SmtpMsgBuffer[0] = '\0';
	CurHostName = mci->mci_host;		/* XXX UGLY XXX */
	if (CurHostName == NULL)
		CurHostName = MyHostName;
	SmtpNeedIntro = true;
	state = mci->mci_state;
	switch (state)
	{
	  case MCIS_MAIL:
	  case MCIS_RCPT:
	  case MCIS_DATA:
		/* need to clear old information */
		smtprset(m, mci, e);
		/* FALLTHROUGH */

	  case MCIS_OPEN:
		if (!onlyhelo)
			return;
		break;

	  case MCIS_ERROR:
	  case MCIS_QUITING:
	  case MCIS_SSD:
		/* shouldn't happen */
		smtpquit(m, mci, e);
		/* FALLTHROUGH */

	  case MCIS_CLOSED:
		syserr("451 4.4.0 smtpinit: state CLOSED (was %d)", state);
		return;

	  case MCIS_OPENING:
		break;
	}
	if (onlyhelo)
		goto helo;

	mci->mci_state = MCIS_OPENING;
	clrsessenvelope(e);

	/*
	**  Get the greeting message.
	**	This should appear spontaneously.  Give it five minutes to
	**	happen.
	*/

	SmtpPhase = mci->mci_phase = "client greeting";
	sm_setproctitle(true, e, "%s %s: %s",
			qid_printname(e), CurHostName, mci->mci_phase);
	r = reply(m, mci, e, TimeOuts.to_initial, esmtp_check, NULL, XS_GREET);
	if (r < 0)
		goto tempfail1;
	if (REPLYTYPE(r) == 4)
		goto tempfail2;
	if (REPLYTYPE(r) != 2)
		goto unavailable;

	/*
	**  Send the HELO command.
	**	My mother taught me to always introduce myself.
	*/

helo:
	if (bitnset(M_ESMTP, m->m_flags) || bitnset(M_LMTP, m->m_flags))
		mci->mci_flags |= MCIF_ESMTP;
	hn = mci->mci_heloname ? mci->mci_heloname : MyHostName;

tryhelo:
#if _FFR_IGNORE_EXT_ON_HELO
	mci->mci_flags &= ~MCIF_HELO;
#endif /* _FFR_IGNORE_EXT_ON_HELO */
	if (bitnset(M_LMTP, m->m_flags))
	{
		smtpmessage("LHLO %s", m, mci, hn);
		SmtpPhase = mci->mci_phase = "client LHLO";
	}
	else if (bitset(MCIF_ESMTP, mci->mci_flags) &&
		 !bitnset(M_FSMTP, m->m_flags))
	{
		smtpmessage("EHLO %s", m, mci, hn);
		SmtpPhase = mci->mci_phase = "client EHLO";
	}
	else
	{
		smtpmessage("HELO %s", m, mci, hn);
		SmtpPhase = mci->mci_phase = "client HELO";
#if _FFR_IGNORE_EXT_ON_HELO
		mci->mci_flags |= MCIF_HELO;
#endif /* _FFR_IGNORE_EXT_ON_HELO */
	}
	sm_setproctitle(true, e, "%s %s: %s", qid_printname(e),
			CurHostName, mci->mci_phase);
	r = reply(m, mci, e,
		  bitnset(M_LMTP, m->m_flags) ? TimeOuts.to_lhlo
					      : TimeOuts.to_helo,
		  helo_options, NULL, XS_EHLO);
	if (r < 0)
		goto tempfail1;
	else if (REPLYTYPE(r) == 5)
	{
		if (bitset(MCIF_ESMTP, mci->mci_flags) &&
		    !bitnset(M_LMTP, m->m_flags))
		{
			/* try old SMTP instead */
			mci->mci_flags &= ~MCIF_ESMTP;
			goto tryhelo;
		}
		goto unavailable;
	}
	else if (REPLYTYPE(r) != 2)
		goto tempfail2;

	/*
	**  Check to see if we actually ended up talking to ourself.
	**  This means we didn't know about an alias or MX, or we managed
	**  to connect to an echo server.
	*/

	p = strchr(&SmtpReplyBuffer[4], ' ');
	if (p != NULL)
		*p = '\0';
	if (!bitnset(M_NOLOOPCHECK, m->m_flags) &&
	    !bitnset(M_LMTP, m->m_flags) &&
	    sm_strcasecmp(&SmtpReplyBuffer[4], MyHostName) == 0)
	{
		syserr("553 5.3.5 %s config error: mail loops back to me (MX problem?)",
			CurHostName);
		mci_setstat(mci, EX_CONFIG, "5.3.5",
			    "553 5.3.5 system config error");
		mci->mci_errno = 0;
		smtpquit(m, mci, e);
		return;
	}

	/*
	**  If this is expected to be another sendmail, send some internal
	**  commands.
	**  If we're running as MSP, "propagate" -v flag if possible.
	*/

	if ((UseMSP && Verbose && bitset(MCIF_VERB, mci->mci_flags))
# if !_FFR_DEPRECATE_MAILER_FLAG_I
	    || bitnset(M_INTERNAL, m->m_flags)
# endif /* !_FFR_DEPRECATE_MAILER_FLAG_I */
	   )
	{
		/* tell it to be verbose */
		smtpmessage("VERB", m, mci);
		r = reply(m, mci, e, TimeOuts.to_miscshort, NULL, &enhsc,
			XS_DEFAULT);
		if (r < 0)
			goto tempfail1;
	}

	if (mci->mci_state != MCIS_CLOSED)
	{
		mci->mci_state = MCIS_OPEN;
		return;
	}

	/* got a 421 error code during startup */

  tempfail1:
	mci_setstat(mci, EX_TEMPFAIL, ENHSCN(enhsc, "4.4.2"), NULL);
	if (mci->mci_state != MCIS_CLOSED)
		smtpquit(m, mci, e);
	return;

  tempfail2:
	/* XXX should use code from other end iff ENHANCEDSTATUSCODES */
	mci_setstat(mci, EX_TEMPFAIL, ENHSCN(enhsc, "4.5.0"),
		    SmtpReplyBuffer);
	if (mci->mci_state != MCIS_CLOSED)
		smtpquit(m, mci, e);
	return;

  unavailable:
	mci_setstat(mci, EX_UNAVAILABLE, "5.5.0", SmtpReplyBuffer);
	smtpquit(m, mci, e);
	return;
}
/*
**  ESMTP_CHECK -- check to see if this implementation likes ESMTP protocol
**
**	Parameters:
**		line -- the response line.
**		firstline -- set if this is the first line of the reply.
**		m -- the mailer.
**		mci -- the mailer connection info.
**		e -- the envelope.
**
**	Returns:
**		none.
*/

static void
esmtp_check(line, firstline, m, mci, e)
	char *line;
	bool firstline;
	MAILER *m;
	register MCI *mci;
	ENVELOPE *e;
{
	if (strstr(line, "ESMTP") != NULL)
		mci->mci_flags |= MCIF_ESMTP;

	/*
	**  Dirty hack below. Quoting the author:
	**  This was a response to people who wanted SMTP transmission to be
	**  just-send-8 by default.  Essentially, you could put this tag into
	**  your greeting message to behave as though the F=8 flag was set on
	**  the mailer.
	*/

	if (strstr(line, "8BIT-OK") != NULL)
		mci->mci_flags |= MCIF_8BITOK;
}

#if SASL
/* specify prototype so compiler can check calls */
static char *str_union __P((char *, char *, SM_RPOOL_T *));

/*
**  STR_UNION -- create the union of two lists
**
**	Parameters:
**		s1, s2 -- lists of items (separated by single blanks).
**		rpool -- resource pool from which result is allocated.
**
**	Returns:
**		the union of both lists.
*/

static char *
str_union(s1, s2, rpool)
	char *s1, *s2;
	SM_RPOOL_T *rpool;
{
	char *hr, *h1, *h, *res;
	int l1, l2, rl;

	if (s1 == NULL || *s1 == '\0')
		return s2;
	if (s2 == NULL || *s2 == '\0')
		return s1;
	l1 = strlen(s1);
	l2 = strlen(s2);
	rl = l1 + l2;
	if (rl <= 0)
	{
		sm_syslog(LOG_WARNING, NOQID,
			  "str_union: stringlen1=%d, stringlen2=%d, sum=%d, status=overflow",
			  l1, l2, rl);
		res = NULL;
	}
	else
		res = (char *) sm_rpool_malloc(rpool, rl + 2);
	if (res == NULL)
	{
		if (l1 > l2)
			return s1;
		return s2;
	}
	(void) sm_strlcpy(res, s1, rl);
	hr = res + l1;
	h1 = s2;
	h = s2;

	/* walk through s2 */
	while (h != NULL && *h1 != '\0')
	{
		/* is there something after the current word? */
		if ((h = strchr(h1, ' ')) != NULL)
			*h = '\0';
		l1 = strlen(h1);

		/* does the current word appear in s1 ? */
		if (iteminlist(h1, s1, " ") == NULL)
		{
			/* add space as delimiter */
			*hr++ = ' ';

			/* copy the item */
			memcpy(hr, h1, l1);

			/* advance pointer in result list */
			hr += l1;
			*hr = '\0';
		}
		if (h != NULL)
		{
			/* there are more items */
			*h = ' ';
			h1 = h + 1;
		}
	}
	return res;
}
#endif /* SASL */

/*
**  HELO_OPTIONS -- process the options on a HELO line.
**
**	Parameters:
**		line -- the response line.
**		firstline -- set if this is the first line of the reply.
**		m -- the mailer.
**		mci -- the mailer connection info.
**		e -- the envelope (unused).
**
**	Returns:
**		none.
*/

static void
helo_options(line, firstline, m, mci, e)
	char *line;
	bool firstline;
	MAILER *m;
	register MCI *mci;
	ENVELOPE *e;
{
	register char *p;
#if _FFR_IGNORE_EXT_ON_HELO
	static bool logged = false;
#endif /* _FFR_IGNORE_EXT_ON_HELO */

	if (firstline)
	{
		mci_clr_extensions(mci);
#if _FFR_IGNORE_EXT_ON_HELO
		logged = false;
#endif /* _FFR_IGNORE_EXT_ON_HELO */
		return;
	}
#if _FFR_IGNORE_EXT_ON_HELO
	else if (bitset(MCIF_HELO, mci->mci_flags))
	{
		if (LogLevel > 8 && !logged)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "server=%s [%s] returned extensions despite HELO command",
				  macvalue(macid("{server_name}"), e),
				  macvalue(macid("{server_addr}"), e));
			logged = true;
		}
		return;
	}
#endif /* _FFR_IGNORE_EXT_ON_HELO */

	if (strlen(line) < 5)
		return;
	line += 4;
	p = strpbrk(line, " =");
	if (p != NULL)
		*p++ = '\0';
	if (sm_strcasecmp(line, "size") == 0)
	{
		mci->mci_flags |= MCIF_SIZE;
		if (p != NULL)
			mci->mci_maxsize = atol(p);
	}
	else if (sm_strcasecmp(line, "8bitmime") == 0)
	{
		mci->mci_flags |= MCIF_8BITMIME;
		mci->mci_flags &= ~MCIF_7BIT;
	}
	else if (sm_strcasecmp(line, "expn") == 0)
		mci->mci_flags |= MCIF_EXPN;
	else if (sm_strcasecmp(line, "dsn") == 0)
		mci->mci_flags |= MCIF_DSN;
	else if (sm_strcasecmp(line, "enhancedstatuscodes") == 0)
		mci->mci_flags |= MCIF_ENHSTAT;
	else if (sm_strcasecmp(line, "pipelining") == 0)
		mci->mci_flags |= MCIF_PIPELINED;
	else if (sm_strcasecmp(line, "verb") == 0)
		mci->mci_flags |= MCIF_VERB;
#if STARTTLS
	else if (sm_strcasecmp(line, "starttls") == 0)
		mci->mci_flags |= MCIF_TLS;
#endif /* STARTTLS */
	else if (sm_strcasecmp(line, "deliverby") == 0)
	{
		mci->mci_flags |= MCIF_DLVR_BY;
		if (p != NULL)
			mci->mci_min_by = atol(p);
	}
#if SASL
	else if (sm_strcasecmp(line, "auth") == 0)
	{
		if (p != NULL && *p != '\0' &&
		    !bitset(MCIF_AUTH2, mci->mci_flags))
		{
			if (mci->mci_saslcap != NULL)
			{
				/*
				**  Create the union with previous auth
				**  offerings because we recognize "auth "
				**  and "auth=" (old format).
				*/

				mci->mci_saslcap = str_union(mci->mci_saslcap,
							     p, mci->mci_rpool);
				mci->mci_flags |= MCIF_AUTH2;
			}
			else
			{
				int l;

				l = strlen(p) + 1;
				mci->mci_saslcap = (char *)
					sm_rpool_malloc(mci->mci_rpool, l);
				if (mci->mci_saslcap != NULL)
				{
					(void) sm_strlcpy(mci->mci_saslcap, p,
							  l);
					mci->mci_flags |= MCIF_AUTH;
				}
			}
		}
		if (tTd(95, 5))
			sm_syslog(LOG_DEBUG, NOQID, "AUTH flags=%lx, mechs=%s",
				mci->mci_flags, mci->mci_saslcap);
	}
#endif /* SASL */
}
#if SASL

static int getsimple	__P((void *, int, const char **, unsigned *));
static int getsecret	__P((sasl_conn_t *, void *, int, sasl_secret_t **));
static int saslgetrealm	__P((void *, int, const char **, const char **));
static int readauth	__P((char *, bool, SASL_AI_T *m, SM_RPOOL_T *));
static int getauth	__P((MCI *, ENVELOPE *, SASL_AI_T *));
static char *removemech	__P((char *, char *, SM_RPOOL_T *));
static int attemptauth	__P((MAILER *, MCI *, ENVELOPE *, SASL_AI_T *));

static sasl_callback_t callbacks[] =
{
	{	SASL_CB_GETREALM,	(sasl_callback_ft)&saslgetrealm,	NULL	},
#define CB_GETREALM_IDX	0
	{	SASL_CB_PASS,		(sasl_callback_ft)&getsecret,	NULL	},
#define CB_PASS_IDX	1
	{	SASL_CB_USER,		(sasl_callback_ft)&getsimple,	NULL	},
#define CB_USER_IDX	2
	{	SASL_CB_AUTHNAME,	(sasl_callback_ft)&getsimple,	NULL	},
#define CB_AUTHNAME_IDX	3
	{	SASL_CB_VERIFYFILE,	(sasl_callback_ft)&safesaslfile,	NULL	},
#define CB_SAFESASL_IDX	4
	{	SASL_CB_LIST_END,	NULL,		NULL	}
};

/*
**  INIT_SASL_CLIENT -- initialize client side of Cyrus-SASL
**
**	Parameters:
**		none.
**
**	Returns:
**		SASL_OK -- if successful.
**		SASL error code -- otherwise.
**
**	Side Effects:
**		checks/sets sasl_clt_init.
**
**	Note:
**	Callbacks are ignored if sasl_client_init() has
**	been called before (by a library such as libnss_ldap)
*/

static bool sasl_clt_init = false;

static int
init_sasl_client()
{
	int result;

	if (sasl_clt_init)
		return SASL_OK;
	result = sasl_client_init(callbacks);

	/* should we retry later again or just remember that it failed? */
	if (result == SASL_OK)
		sasl_clt_init = true;
	return result;
}
/*
**  STOP_SASL_CLIENT -- shutdown client side of Cyrus-SASL
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		checks/sets sasl_clt_init.
*/

void
stop_sasl_client()
{
	if (!sasl_clt_init)
		return;
	sasl_clt_init = false;
	sasl_done();
}
/*
**  GETSASLDATA -- process the challenges from the SASL protocol
**
**	This gets the relevant sasl response data out of the reply
**	from the server.
**
**	Parameters:
**		line -- the response line.
**		firstline -- set if this is the first line of the reply.
**		m -- the mailer.
**		mci -- the mailer connection info.
**		e -- the envelope (unused).
**
**	Returns:
**		none.
*/

static void getsasldata __P((char *, bool, MAILER *, MCI *, ENVELOPE *));

static void
getsasldata(line, firstline, m, mci, e)
	char *line;
	bool firstline;
	MAILER *m;
	register MCI *mci;
	ENVELOPE *e;
{
	int len;
	int result;
# if SASL < 20000
	char *out;
# endif /* SASL < 20000 */

	/* if not a continue we don't care about it */
	len = strlen(line);
	if ((len <= 4) ||
	    (line[0] != '3') ||
	     !isascii(line[1]) || !isdigit(line[1]) ||
	     !isascii(line[2]) || !isdigit(line[2]))
	{
		SM_FREE_CLR(mci->mci_sasl_string);
		return;
	}

	/* forget about "334 " */
	line += 4;
	len -= 4;
# if SASL >= 20000
	/* XXX put this into a macro/function? It's duplicated below */
	if (mci->mci_sasl_string != NULL)
	{
		if (mci->mci_sasl_string_len <= len)
		{
			sm_free(mci->mci_sasl_string); /* XXX */
			mci->mci_sasl_string = xalloc(len + 1);
		}
	}
	else
		mci->mci_sasl_string = xalloc(len + 1);

	result = sasl_decode64(line, len, mci->mci_sasl_string, len + 1,
			       (unsigned int *) &mci->mci_sasl_string_len);
	if (result != SASL_OK)
	{
		mci->mci_sasl_string_len = 0;
		*mci->mci_sasl_string = '\0';
	}
# else /* SASL >= 20000 */
	out = (char *) sm_rpool_malloc_x(mci->mci_rpool, len + 1);
	result = sasl_decode64(line, len, out, (unsigned int *) &len);
	if (result != SASL_OK)
	{
		len = 0;
		*out = '\0';
	}

	/*
	**  mci_sasl_string is "shared" with Cyrus-SASL library; hence
	**	it can't be in an rpool unless we use the same memory
	**	management mechanism (with same rpool!) for Cyrus SASL.
	*/

	if (mci->mci_sasl_string != NULL)
	{
		if (mci->mci_sasl_string_len <= len)
		{
			sm_free(mci->mci_sasl_string); /* XXX */
			mci->mci_sasl_string = xalloc(len + 1);
		}
	}
	else
		mci->mci_sasl_string = xalloc(len + 1);

	memcpy(mci->mci_sasl_string, out, len);
	mci->mci_sasl_string[len] = '\0';
	mci->mci_sasl_string_len = len;
# endif /* SASL >= 20000 */
	return;
}
/*
**  READAUTH -- read auth values from a file
**
**	Parameters:
**		filename -- name of file to read.
**		safe -- if set, this is a safe read.
**		sai -- where to store auth_info.
**		rpool -- resource pool for sai.
**
**	Returns:
**		EX_OK -- data succesfully read.
**		EX_UNAVAILABLE -- no valid filename.
**		EX_TEMPFAIL -- temporary failure.
*/

static char *sasl_info_name[] =
{
	"user id",
	"authentication id",
	"password",
	"realm",
	"mechlist"
};
static int
readauth(filename, safe, sai, rpool)
	char *filename;
	bool safe;
	SASL_AI_T *sai;
	SM_RPOOL_T *rpool;
{
	SM_FILE_T *f;
	long sff;
	pid_t pid;
	int lc;
	char *s;
	char buf[MAXLINE];

	if (filename == NULL || filename[0] == '\0')
		return EX_UNAVAILABLE;

#if !_FFR_ALLOW_SASLINFO
	/*
	**  make sure we don't use a program that is not
	**  accesible to the user who specified a different authinfo file.
	**  However, currently we don't pass this info (authinfo file
	**  specified by user) around, so we just turn off program access.
	*/

	if (filename[0] == '|')
	{
		auto int fd;
		int i;
		char *p;
		char *argv[MAXPV + 1];

		i = 0;
		for (p = strtok(&filename[1], " \t"); p != NULL;
		     p = strtok(NULL, " \t"))
		{
			if (i >= MAXPV)
				break;
			argv[i++] = p;
		}
		argv[i] = NULL;
		pid = prog_open(argv, &fd, CurEnv);
		if (pid < 0)
			f = NULL;
		else
			f = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT,
				       (void *) &fd, SM_IO_RDONLY, NULL);
	}
	else
#endif /* !_FFR_ALLOW_SASLINFO */
	{
		pid = -1;
		sff = SFF_REGONLY|SFF_SAFEDIRPATH|SFF_NOWLINK
		      |SFF_NOGWFILES|SFF_NOWWFILES|SFF_NOWRFILES;
# if _FFR_GROUPREADABLEAUTHINFOFILE
		if (!bitnset(DBS_GROUPREADABLEAUTHINFOFILE, DontBlameSendmail))
# endif /* _FFR_GROUPREADABLEAUTHINFOFILE */
			sff |= SFF_NOGRFILES;
		if (DontLockReadFiles)
			sff |= SFF_NOLOCK;

#if _FFR_ALLOW_SASLINFO
		/*
		**  XXX: make sure we don't read or open files that are not
		**  accesible to the user who specified a different authinfo
		**  file.
		*/

		sff |= SFF_MUSTOWN;
#else /* _FFR_ALLOW_SASLINFO */
		if (safe)
			sff |= SFF_OPENASROOT;
#endif /* _FFR_ALLOW_SASLINFO */

		f = safefopen(filename, O_RDONLY, 0, sff);
	}
	if (f == NULL)
	{
		if (LogLevel > 5)
			sm_syslog(LOG_ERR, NOQID,
				  "AUTH=client, error: can't open %s: %s",
				  filename, sm_errstring(errno));
		return EX_TEMPFAIL;
	}

	lc = 0;
	while (lc <= SASL_MECHLIST &&
		sm_io_fgets(f, SM_TIME_DEFAULT, buf, sizeof(buf)) >= 0)
	{
		if (buf[0] != '#')
		{
			(*sai)[lc] = sm_rpool_strdup_x(rpool, buf);
			if ((s = strchr((*sai)[lc], '\n')) != NULL)
				*s = '\0';
			lc++;
		}
	}

	(void) sm_io_close(f, SM_TIME_DEFAULT);
	if (pid > 0)
		(void) waitfor(pid);
	if (lc < SASL_PASSWORD)
	{
		if (LogLevel > 8)
			sm_syslog(LOG_ERR, NOQID,
				  "AUTH=client, error: can't read %s from %s",
				  sasl_info_name[lc + 1], filename);
		return EX_TEMPFAIL;
	}
	return EX_OK;
}

/*
**  GETAUTH -- get authinfo from ruleset call
**
**	{server_name}, {server_addr} must be set
**
**	Parameters:
**		mci -- the mailer connection structure.
**		e -- the envelope (including the sender to specify).
**		sai -- pointer to authinfo (result).
**
**	Returns:
**		EX_OK -- ruleset was succesfully called, data may not
**			be available, sai must be checked.
**		EX_UNAVAILABLE -- ruleset unavailable (or failed).
**		EX_TEMPFAIL -- temporary failure (from ruleset).
**
**	Side Effects:
**		Fills in sai if successful.
*/

static int
getauth(mci, e, sai)
	MCI *mci;
	ENVELOPE *e;
	SASL_AI_T *sai;
{
	int i, r, l, got, ret;
	char **pvp;
	char pvpbuf[PSBUFSIZE];

	r = rscap("authinfo", macvalue(macid("{server_name}"), e),
		   macvalue(macid("{server_addr}"), e), e,
		   &pvp, pvpbuf, sizeof(pvpbuf));

	if (r != EX_OK)
		return EX_UNAVAILABLE;

	/* other than expected return value: ok (i.e., no auth) */
	if (pvp == NULL || pvp[0] == NULL || (pvp[0][0] & 0377) != CANONNET)
		return EX_OK;
	if (pvp[1] != NULL && sm_strncasecmp(pvp[1], "temp", 4) == 0)
		return EX_TEMPFAIL;

	/*
	**  parse the data, put it into sai
	**  format: "TDstring" (including the '"' !)
	**  where T is a tag: 'U', ...
	**  D is a delimiter: ':' or '='
	*/

	ret = EX_OK;	/* default return value */
	i = 0;
	got = 0;
	while (i < SASL_ENTRIES)
	{
		if (pvp[i + 1] == NULL)
			break;
		if (pvp[i + 1][0] != '"')
			break;
		switch (pvp[i + 1][1])
		{
		  case 'U':
		  case 'u':
			r = SASL_USER;
			break;
		  case 'I':
		  case 'i':
			r = SASL_AUTHID;
			break;
		  case 'P':
		  case 'p':
			r = SASL_PASSWORD;
			break;
		  case 'R':
		  case 'r':
			r = SASL_DEFREALM;
			break;
		  case 'M':
		  case 'm':
			r = SASL_MECHLIST;
			break;
		  default:
			goto fail;
		}
		l = strlen(pvp[i + 1]);

		/* check syntax */
		if (l <= 3 || pvp[i + 1][l - 1] != '"')
			goto fail;

		/* remove closing quote */
		pvp[i + 1][l - 1] = '\0';

		/* remove "TD and " */
		l -= 4;
		(*sai)[r] = (char *) sm_rpool_malloc(mci->mci_rpool, l + 1);
		if ((*sai)[r] == NULL)
			goto tempfail;
		if (pvp[i + 1][2] == ':')
		{
			/* ':text' (just copy) */
			(void) sm_strlcpy((*sai)[r], pvp[i + 1] + 3, l + 1);
			got |= 1 << r;
		}
		else if (pvp[i + 1][2] == '=')
		{
			unsigned int len;

			/* '=base64' (decode) */
# if SASL >= 20000
			ret = sasl_decode64(pvp[i + 1] + 3,
					  (unsigned int) l, (*sai)[r],
					  (unsigned int) l + 1, &len);
# else /* SASL >= 20000 */
			ret = sasl_decode64(pvp[i + 1] + 3,
					  (unsigned int) l, (*sai)[r], &len);
# endif /* SASL >= 20000 */
			if (ret != SASL_OK)
				goto fail;
			got |= 1 << r;
		}
		else
			goto fail;
		if (tTd(95, 5))
			sm_syslog(LOG_DEBUG, NOQID, "getauth %s=%s",
				  sasl_info_name[r], (*sai)[r]);
		++i;
	}

	/* did we get the expected data? */
	/* XXX: EXTERNAL mechanism only requires (and only uses) SASL_USER */
	if (!(bitset(SASL_USER_BIT|SASL_AUTHID_BIT, got) &&
	      bitset(SASL_PASSWORD_BIT, got)))
		goto fail;

	/* no authid? copy uid */
	if (!bitset(SASL_AUTHID_BIT, got))
	{
		l = strlen((*sai)[SASL_USER]) + 1;
		(*sai)[SASL_AUTHID] = (char *) sm_rpool_malloc(mci->mci_rpool,
							       l + 1);
		if ((*sai)[SASL_AUTHID] == NULL)
			goto tempfail;
		(void) sm_strlcpy((*sai)[SASL_AUTHID], (*sai)[SASL_USER], l);
	}

	/* no uid? copy authid */
	if (!bitset(SASL_USER_BIT, got))
	{
		l = strlen((*sai)[SASL_AUTHID]) + 1;
		(*sai)[SASL_USER] = (char *) sm_rpool_malloc(mci->mci_rpool,
							     l + 1);
		if ((*sai)[SASL_USER] == NULL)
			goto tempfail;
		(void) sm_strlcpy((*sai)[SASL_USER], (*sai)[SASL_AUTHID], l);
	}
	return EX_OK;

  tempfail:
	ret = EX_TEMPFAIL;
  fail:
	if (LogLevel > 8)
		sm_syslog(LOG_WARNING, NOQID,
			  "AUTH=client, relay=%.64s [%.16s], authinfo %sfailed",
			  macvalue(macid("{server_name}"), e),
			  macvalue(macid("{server_addr}"), e),
			  ret == EX_TEMPFAIL ? "temp" : "");
	for (i = 0; i <= SASL_MECHLIST; i++)
		(*sai)[i] = NULL;	/* just clear; rpool */
	return ret;
}

# if SASL >= 20000
/*
**  GETSIMPLE -- callback to get userid or authid
**
**	Parameters:
**		context -- sai
**		id -- what to do
**		result -- (pointer to) result
**		len -- (pointer to) length of result
**
**	Returns:
**		OK/failure values
*/

static int
getsimple(context, id, result, len)
	void *context;
	int id;
	const char **result;
	unsigned *len;
{
	SASL_AI_T *sai;

	if (result == NULL || context == NULL)
		return SASL_BADPARAM;
	sai = (SASL_AI_T *) context;

	switch (id)
	{
	  case SASL_CB_USER:
		*result = (*sai)[SASL_USER];
		if (tTd(95, 5))
			sm_syslog(LOG_DEBUG, NOQID, "AUTH username '%s'",
				  *result);
		if (len != NULL)
			*len = *result != NULL ? strlen(*result) : 0;
		break;

	  case SASL_CB_AUTHNAME:
		*result = (*sai)[SASL_AUTHID];
		if (tTd(95, 5))
			sm_syslog(LOG_DEBUG, NOQID, "AUTH authid '%s'",
				  *result);
		if (len != NULL)
			*len = *result != NULL ? strlen(*result) : 0;
		break;

	  case SASL_CB_LANGUAGE:
		*result = NULL;
		if (len != NULL)
			*len = 0;
		break;

	  default:
		return SASL_BADPARAM;
	}
	return SASL_OK;
}
/*
**  GETSECRET -- callback to get password
**
**	Parameters:
**		conn -- connection information
**		context -- sai
**		id -- what to do
**		psecret -- (pointer to) result
**
**	Returns:
**		OK/failure values
*/

static int
getsecret(conn, context, id, psecret)
	sasl_conn_t *conn;
	SM_UNUSED(void *context);
	int id;
	sasl_secret_t **psecret;
{
	int len;
	char *authpass;
	MCI *mci;

	if (conn == NULL || psecret == NULL || id != SASL_CB_PASS)
		return SASL_BADPARAM;

	mci = (MCI *) context;
	authpass = mci->mci_sai[SASL_PASSWORD];
	len = strlen(authpass);

	/*
	**  use an rpool because we are responsible for free()ing the secret,
	**  but we can't free() it until after the auth completes
	*/

	*psecret = (sasl_secret_t *) sm_rpool_malloc(mci->mci_rpool,
						     sizeof(sasl_secret_t) +
						     len + 1);
	if (*psecret == NULL)
		return SASL_FAIL;
	(void) sm_strlcpy((char *) (*psecret)->data, authpass, len + 1);
	(*psecret)->len = (unsigned long) len;
	return SASL_OK;
}
# else /* SASL >= 20000 */
/*
**  GETSIMPLE -- callback to get userid or authid
**
**	Parameters:
**		context -- sai
**		id -- what to do
**		result -- (pointer to) result
**		len -- (pointer to) length of result
**
**	Returns:
**		OK/failure values
*/

static int
getsimple(context, id, result, len)
	void *context;
	int id;
	const char **result;
	unsigned *len;
{
	char *h, *s;
# if SASL > 10509
	bool addrealm;
# endif /* SASL > 10509 */
	size_t l;
	SASL_AI_T *sai;
	char *authid = NULL;

	if (result == NULL || context == NULL)
		return SASL_BADPARAM;
	sai = (SASL_AI_T *) context;

	/*
	**  Unfortunately it is not clear whether this routine should
	**  return a copy of a string or just a pointer to a string.
	**  The Cyrus-SASL plugins treat these return values differently, e.g.,
	**  plugins/cram.c free()s authid, plugings/digestmd5.c does not.
	**  The best solution to this problem is to fix Cyrus-SASL, but it
	**  seems there is nobody who creates patches... Hello CMU!?
	**  The second best solution is to have flags that tell this routine
	**  whether to return an malloc()ed copy.
	**  The next best solution is to always return an malloc()ed copy,
	**  and suffer from some memory leak, which is ugly for persistent
	**  queue runners.
	**  For now we go with the last solution...
	**  We can't use rpools (which would avoid this particular problem)
	**  as explained in sasl.c.
	*/

	switch (id)
	{
	  case SASL_CB_USER:
		l = strlen((*sai)[SASL_USER]) + 1;
		s = sm_sasl_malloc(l);
		if (s == NULL)
		{
			if (len != NULL)
				*len = 0;
			*result = NULL;
			return SASL_NOMEM;
		}
		(void) sm_strlcpy(s, (*sai)[SASL_USER], l);
		*result = s;
		if (tTd(95, 5))
			sm_syslog(LOG_DEBUG, NOQID, "AUTH username '%s'",
				  *result);
		if (len != NULL)
			*len = *result != NULL ? strlen(*result) : 0;
		break;

	  case SASL_CB_AUTHNAME:
		h = (*sai)[SASL_AUTHID];
# if SASL > 10509
		/* XXX maybe other mechanisms too?! */
		addrealm = (*sai)[SASL_MECH] != NULL &&
			   sm_strcasecmp((*sai)[SASL_MECH], "CRAM-MD5") == 0;

		/*
		**  Add realm to authentication id unless authid contains
		**  '@@' (i.e., a realm) or the default realm is empty.
		*/

		if (addrealm && h != NULL && strchr(h, '@@') == NULL)
		{
			/* has this been done before? */
			if ((*sai)[SASL_ID_REALM] == NULL)
			{
				char *realm;

				realm = (*sai)[SASL_DEFREALM];

				/* do not add an empty realm */
				if (*realm == '\0')
				{
					authid = h;
					(*sai)[SASL_ID_REALM] = NULL;
				}
				else
				{
					l = strlen(h) + strlen(realm) + 2;

					/* should use rpool, but from where? */
					authid = sm_sasl_malloc(l);
					if (authid != NULL)
					{
						(void) sm_snprintf(authid, l,
								  "%s@@%s",
								   h, realm);
						(*sai)[SASL_ID_REALM] = authid;
					}
					else
					{
						authid = h;
						(*sai)[SASL_ID_REALM] = NULL;
					}
				}
			}
			else
				authid = (*sai)[SASL_ID_REALM];
		}
		else
# endif /* SASL > 10509 */
			authid = h;
		l = strlen(authid) + 1;
		s = sm_sasl_malloc(l);
		if (s == NULL)
		{
			if (len != NULL)
				*len = 0;
			*result = NULL;
			return SASL_NOMEM;
		}
		(void) sm_strlcpy(s, authid, l);
		*result = s;
		if (tTd(95, 5))
			sm_syslog(LOG_DEBUG, NOQID, "AUTH authid '%s'",
				  *result);
		if (len != NULL)
			*len = authid ? strlen(authid) : 0;
		break;

	  case SASL_CB_LANGUAGE:
		*result = NULL;
		if (len != NULL)
			*len = 0;
		break;

	  default:
		return SASL_BADPARAM;
	}
	return SASL_OK;
}
/*
**  GETSECRET -- callback to get password
**
**	Parameters:
**		conn -- connection information
**		context -- sai
**		id -- what to do
**		psecret -- (pointer to) result
**
**	Returns:
**		OK/failure values
*/

static int
getsecret(conn, context, id, psecret)
	sasl_conn_t *conn;
	SM_UNUSED(void *context);
	int id;
	sasl_secret_t **psecret;
{
	int len;
	char *authpass;
	SASL_AI_T *sai;

	if (conn == NULL || psecret == NULL || id != SASL_CB_PASS)
		return SASL_BADPARAM;

	sai = (SASL_AI_T *) context;
	authpass = (*sai)[SASL_PASSWORD];
	len = strlen(authpass);
	*psecret = (sasl_secret_t *) sm_sasl_malloc(sizeof(sasl_secret_t) +
						    len + 1);
	if (*psecret == NULL)
		return SASL_FAIL;
	(void) sm_strlcpy((*psecret)->data, authpass, len + 1);
	(*psecret)->len = (unsigned long) len;
	return SASL_OK;
}
# endif /* SASL >= 20000 */

/*
**  SAFESASLFILE -- callback for sasl: is file safe?
**
**	Parameters:
**		context -- pointer to context between invocations (unused)
**		file -- name of file to check
**		type -- type of file to check
**
**	Returns:
**		SASL_OK -- file can be used
**		SASL_CONTINUE -- don't use file
**		SASL_FAIL -- failure (not used here)
**
*/

int
#if SASL > 10515
safesaslfile(context, file, type)
#else /* SASL > 10515 */
safesaslfile(context, file)
#endif /* SASL > 10515 */
	void *context;
# if SASL >= 20000
	const char *file;
# else /* SASL >= 20000 */
	char *file;
# endif /* SASL >= 20000 */
#if SASL > 10515
# if SASL >= 20000
	sasl_verify_type_t type;
# else /* SASL >= 20000 */
	int type;
# endif /* SASL >= 20000 */
#endif /* SASL > 10515 */
{
	long sff;
	int r;
#if SASL <= 10515
	size_t len;
#endif /* SASL <= 10515 */
	char *p;

	if (file == NULL || *file == '\0')
		return SASL_OK;
	sff = SFF_SAFEDIRPATH|SFF_NOWLINK|SFF_NOWWFILES|SFF_ROOTOK;
#if SASL <= 10515
	if ((p = strrchr(file, '/')) == NULL)
		p = file;
	else
		++p;

	/* everything beside libs and .conf files must not be readable */
	len = strlen(p);
	if ((len <= 3 || strncmp(p, "lib", 3) != 0) &&
	    (len <= 5 || strncmp(p + len - 5, ".conf", 5) != 0))
	{
		if (!bitnset(DBS_GROUPREADABLESASLDBFILE, DontBlameSendmail))
			sff |= SFF_NORFILES;
		if (!bitnset(DBS_GROUPWRITABLESASLDBFILE, DontBlameSendmail))
			sff |= SFF_NOGWFILES;
	}
#else /* SASL <= 10515 */
	/* files containing passwords should be not readable */
	if (type == SASL_VRFY_PASSWD)
	{
		if (bitnset(DBS_GROUPREADABLESASLDBFILE, DontBlameSendmail))
			sff |= SFF_NOWRFILES;
		else
			sff |= SFF_NORFILES;
		if (!bitnset(DBS_GROUPWRITABLESASLDBFILE, DontBlameSendmail))
			sff |= SFF_NOGWFILES;
	}
#endif /* SASL <= 10515 */

	p = (char *) file;
	if ((r = safefile(p, RunAsUid, RunAsGid, RunAsUserName, sff,
			  S_IRUSR, NULL)) == 0)
		return SASL_OK;
	if (LogLevel > (r != ENOENT ? 8 : 10))
		sm_syslog(LOG_WARNING, NOQID, "error: safesasl(%s) failed: %s",
			  p, sm_errstring(r));
	return SASL_CONTINUE;
}

/*
**  SASLGETREALM -- return the realm for SASL
**
**	return the realm for the client
**
**	Parameters:
**		context -- context shared between invocations
**		availrealms -- list of available realms
**			{realm, realm, ...}
**		result -- pointer to result
**
**	Returns:
**		failure/success
*/

static int
saslgetrealm(context, id, availrealms, result)
	void *context;
	int id;
	const char **availrealms;
	const char **result;
{
	char *r;
	SASL_AI_T *sai;

	sai = (SASL_AI_T *) context;
	if (sai == NULL)
		return SASL_FAIL;
	r = (*sai)[SASL_DEFREALM];

	if (LogLevel > 12)
		sm_syslog(LOG_INFO, NOQID,
			  "AUTH=client, realm=%s, available realms=%s",
			  r == NULL ? "<No Realm>" : r,
			  (availrealms == NULL || *availrealms == NULL)
				? "<No Realms>" : *availrealms);

	/* check whether context is in list */
	if (availrealms != NULL && *availrealms != NULL)
	{
		if (iteminlist(context, (char *)(*availrealms + 1), " ,}") ==
		    NULL)
		{
			if (LogLevel > 8)
				sm_syslog(LOG_ERR, NOQID,
					  "AUTH=client, realm=%s not in list=%s",
					  r, *availrealms);
			return SASL_FAIL;
		}
	}
	*result = r;
	return SASL_OK;
}
/*
**  ITEMINLIST -- does item appear in list?
**
**	Check whether item appears in list (which must be separated by a
**	character in delim) as a "word", i.e. it must appear at the begin
**	of the list or after a space, and it must end with a space or the
**	end of the list.
**
**	Parameters:
**		item -- item to search.
**		list -- list of items.
**		delim -- list of delimiters.
**
**	Returns:
**		pointer to occurrence (NULL if not found).
*/

char *
iteminlist(item, list, delim)
	char *item;
	char *list;
	char *delim;
{
	char *s;
	int len;

	if (list == NULL || *list == '\0')
		return NULL;
	if (item == NULL || *item == '\0')
		return NULL;
	s = list;
	len = strlen(item);
	while (s != NULL && *s != '\0')
	{
		if (sm_strncasecmp(s, item, len) == 0 &&
		    (s[len] == '\0' || strchr(delim, s[len]) != NULL))
			return s;
		s = strpbrk(s, delim);
		if (s != NULL)
			while (*++s == ' ')
				continue;
	}
	return NULL;
}
/*
**  REMOVEMECH -- remove item [rem] from list [list]
**
**	Parameters:
**		rem -- item to remove
**		list -- list of items
**		rpool -- resource pool from which result is allocated.
**
**	Returns:
**		pointer to new list (NULL in case of error).
*/

static char *
removemech(rem, list, rpool)
	char *rem;
	char *list;
	SM_RPOOL_T *rpool;
{
	char *ret;
	char *needle;
	int len;

	if (list == NULL)
		return NULL;
	if (rem == NULL || *rem == '\0')
	{
		/* take out what? */
		return NULL;
	}

	/* find the item in the list */
	if ((needle = iteminlist(rem, list, " ")) == NULL)
	{
		/* not in there: return original */
		return list;
	}

	/* length of string without rem */
	len = strlen(list) - strlen(rem);
	if (len <= 0)
	{
		ret = (char *) sm_rpool_malloc_x(rpool, 1);
		*ret = '\0';
		return ret;
	}
	ret = (char *) sm_rpool_malloc_x(rpool, len);
	memset(ret, '\0', len);

	/* copy from start to removed item */
	memcpy(ret, list, needle - list);

	/* length of rest of string past removed item */
	len = strlen(needle) - strlen(rem) - 1;
	if (len > 0)
	{
		/* not last item -- copy into string */
		memcpy(ret + (needle - list),
		       list + (needle - list) + strlen(rem) + 1,
		       len);
	}
	else
		ret[(needle - list) - 1] = '\0';
	return ret;
}
/*
**  ATTEMPTAUTH -- try to AUTHenticate using one mechanism
**
**	Parameters:
**		m -- the mailer.
**		mci -- the mailer connection structure.
**		e -- the envelope (including the sender to specify).
**		sai - sasl authinfo
**
**	Returns:
**		EX_OK -- authentication was successful.
**		EX_NOPERM -- authentication failed.
**		EX_IOERR -- authentication dialogue failed (I/O problem?).
**		EX_TEMPFAIL -- temporary failure.
**
*/

static int
attemptauth(m, mci, e, sai)
	MAILER *m;
	MCI *mci;
	ENVELOPE *e;
	SASL_AI_T *sai;
{
	int saslresult, smtpresult;
# if SASL >= 20000
	sasl_ssf_t ssf;
	const char *auth_id;
	const char *out;
# else /* SASL >= 20000 */
	sasl_external_properties_t ssf;
	char *out;
# endif /* SASL >= 20000 */
	unsigned int outlen;
	sasl_interact_t *client_interact = NULL;
	char *mechusing;
	sasl_security_properties_t ssp;

	/* MUST NOT be a multiple of 4: bug in some sasl_encode64() versions */
	char in64[MAXOUTLEN + 1];
#if NETINET || (NETINET6 && SASL >= 20000)
	extern SOCKADDR CurHostAddr;
#endif /* NETINET || (NETINET6 && SASL >= 20000) */

	/* no mechanism selected (yet) */
	(*sai)[SASL_MECH] = NULL;

	/* dispose old connection */
	if (mci->mci_conn != NULL)
		sasl_dispose(&(mci->mci_conn));

	/* make a new client sasl connection */
# if SASL >= 20000
	/*
	**  We provide the callbacks again because global callbacks in
	**  sasl_client_init() are ignored if SASL has been initialized
	**  before, for example, by a library such as libnss-ldap.
	*/

	saslresult = sasl_client_new(bitnset(M_LMTP, m->m_flags) ? "lmtp"
								 : "smtp",
				     CurHostName, NULL, NULL, callbacks, 0,
				     &mci->mci_conn);
# else /* SASL >= 20000 */
	saslresult = sasl_client_new(bitnset(M_LMTP, m->m_flags) ? "lmtp"
								 : "smtp",
				     CurHostName, NULL, 0, &mci->mci_conn);
# endif /* SASL >= 20000 */
	if (saslresult != SASL_OK)
		return EX_TEMPFAIL;

	/* set properties */
	(void) memset(&ssp, '\0', sizeof(ssp));

	/* XXX should these be options settable via .cf ? */
	ssp.max_ssf = MaxSLBits;
	ssp.maxbufsize = MAXOUTLEN;
#  if 0
	ssp.security_flags = SASL_SEC_NOPLAINTEXT;
#  endif /* 0 */
	saslresult = sasl_setprop(mci->mci_conn, SASL_SEC_PROPS, &ssp);
	if (saslresult != SASL_OK)
		return EX_TEMPFAIL;

# if SASL >= 20000
	/* external security strength factor, authentication id */
	ssf = 0;
	auth_id = NULL;
#  if STARTTLS
	out = macvalue(macid("{cert_subject}"), e);
	if (out != NULL && *out != '\0')
		auth_id = out;
	out = macvalue(macid("{cipher_bits}"), e);
	if (out != NULL && *out != '\0')
		ssf = atoi(out);
#  endif /* STARTTLS */
	saslresult = sasl_setprop(mci->mci_conn, SASL_SSF_EXTERNAL, &ssf);
	if (saslresult != SASL_OK)
		return EX_TEMPFAIL;
	saslresult = sasl_setprop(mci->mci_conn, SASL_AUTH_EXTERNAL, auth_id);
	if (saslresult != SASL_OK)
		return EX_TEMPFAIL;

#  if NETINET || NETINET6
	/* set local/remote ipv4 addresses */
	if (mci->mci_out != NULL && (
#   if NETINET6
		CurHostAddr.sa.sa_family == AF_INET6 ||
#   endif /* NETINET6 */
		CurHostAddr.sa.sa_family == AF_INET))
	{
		SOCKADDR_LEN_T addrsize;
		SOCKADDR saddr_l;
		char localip[60], remoteip[60];

		switch (CurHostAddr.sa.sa_family)
		{
		  case AF_INET:
			addrsize = sizeof(struct sockaddr_in);
			break;
#   if NETINET6
		  case AF_INET6:
			addrsize = sizeof(struct sockaddr_in6);
			break;
#   endif /* NETINET6 */
		  default:
			break;
		}
		if (iptostring(&CurHostAddr, addrsize,
			       remoteip, sizeof(remoteip)))
		{
			if (sasl_setprop(mci->mci_conn, SASL_IPREMOTEPORT,
					 remoteip) != SASL_OK)
				return EX_TEMPFAIL;
		}
		addrsize = sizeof(saddr_l);
		if (getsockname(sm_io_getinfo(mci->mci_out, SM_IO_WHAT_FD,
					      NULL),
				(struct sockaddr *) &saddr_l, &addrsize) == 0)
		{
			if (iptostring(&saddr_l, addrsize,
				       localip, sizeof(localip)))
			{
				if (sasl_setprop(mci->mci_conn,
						 SASL_IPLOCALPORT,
						 localip) != SASL_OK)
					return EX_TEMPFAIL;
			}
		}
	}
#  endif /* NETINET || NETINET6 */

	/* start client side of sasl */
	saslresult = sasl_client_start(mci->mci_conn, mci->mci_saslcap,
				       &client_interact,
				       &out, &outlen,
				       (const char **) &mechusing);
# else /* SASL >= 20000 */
	/* external security strength factor, authentication id */
	ssf.ssf = 0;
	ssf.auth_id = NULL;
#  if STARTTLS
	out = macvalue(macid("{cert_subject}"), e);
	if (out != NULL && *out != '\0')
		ssf.auth_id = out;
	out = macvalue(macid("{cipher_bits}"), e);
	if (out != NULL && *out != '\0')
		ssf.ssf = atoi(out);
#  endif /* STARTTLS */
	saslresult = sasl_setprop(mci->mci_conn, SASL_SSF_EXTERNAL, &ssf);
	if (saslresult != SASL_OK)
		return EX_TEMPFAIL;

#  if NETINET
	/* set local/remote ipv4 addresses */
	if (mci->mci_out != NULL && CurHostAddr.sa.sa_family == AF_INET)
	{
		SOCKADDR_LEN_T addrsize;
		struct sockaddr_in saddr_l;

		if (sasl_setprop(mci->mci_conn, SASL_IP_REMOTE,
				 (struct sockaddr_in *) &CurHostAddr)
		    != SASL_OK)
			return EX_TEMPFAIL;
		addrsize = sizeof(struct sockaddr_in);
		if (getsockname(sm_io_getinfo(mci->mci_out, SM_IO_WHAT_FD,
					      NULL),
				(struct sockaddr *) &saddr_l, &addrsize) == 0)
		{
			if (sasl_setprop(mci->mci_conn, SASL_IP_LOCAL,
					 &saddr_l) != SASL_OK)
				return EX_TEMPFAIL;
		}
	}
#  endif /* NETINET */

	/* start client side of sasl */
	saslresult = sasl_client_start(mci->mci_conn, mci->mci_saslcap,
				       NULL, &client_interact,
				       &out, &outlen,
				       (const char **) &mechusing);
# endif /* SASL >= 20000 */

	if (saslresult != SASL_OK && saslresult != SASL_CONTINUE)
	{
		if (saslresult == SASL_NOMECH && LogLevel > 8)
		{
			sm_syslog(LOG_NOTICE, e->e_id,
				  "AUTH=client, available mechanisms do not fulfill requirements");
		}
		return EX_TEMPFAIL;
	}

	/* just point current mechanism to the data in the sasl library */
	(*sai)[SASL_MECH] = mechusing;

	/* send the info across the wire */
	if (out == NULL
		/* login and digest-md5 up to 1.5.28 set out="" */
	    || (outlen == 0 &&
		(sm_strcasecmp(mechusing, "LOGIN") == 0 ||
		 sm_strcasecmp(mechusing, "DIGEST-MD5") == 0))
	   )
	{
		/* no initial response */
		smtpmessage("AUTH %s", m, mci, mechusing);
	}
	else if (outlen == 0)
	{
		/*
		**  zero-length initial response, per RFC 2554 4.:
		**  "Unlike a zero-length client answer to a 334 reply, a zero-
		**  length initial response is sent as a single equals sign"
		*/

		smtpmessage("AUTH %s =", m, mci, mechusing);
	}
	else
	{
		saslresult = sasl_encode64(out, outlen, in64, sizeof(in64),
					   NULL);
		if (saslresult != SASL_OK) /* internal error */
		{
			if (LogLevel > 8)
				sm_syslog(LOG_ERR, e->e_id,
					"encode64 for AUTH failed");
			return EX_TEMPFAIL;
		}
		smtpmessage("AUTH %s %s", m, mci, mechusing, in64);
	}
# if SASL < 20000
	sm_sasl_free(out); /* XXX only if no rpool is used */
# endif /* SASL < 20000 */

	/* get the reply */
	smtpresult = reply(m, mci, e, TimeOuts.to_auth, getsasldata, NULL,
			XS_AUTH);

	for (;;)
	{
		/* check return code from server */
		if (smtpresult == 235)
		{
			macdefine(&mci->mci_macro, A_TEMP, macid("{auth_type}"),
				  mechusing);
			return EX_OK;
		}
		if (smtpresult == -1)
			return EX_IOERR;
		if (REPLYTYPE(smtpresult) == 5)
			return EX_NOPERM;	/* ugly, but ... */
		if (REPLYTYPE(smtpresult) != 3)
		{
			/* should we fail deliberately, see RFC 2554 4. ? */
			/* smtpmessage("*", m, mci); */
			return EX_TEMPFAIL;
		}

		saslresult = sasl_client_step(mci->mci_conn,
					      mci->mci_sasl_string,
					      mci->mci_sasl_string_len,
					      &client_interact,
					      &out, &outlen);

		if (saslresult != SASL_OK && saslresult != SASL_CONTINUE)
		{
			if (tTd(95, 5))
				sm_dprintf("AUTH FAIL=%s (%d)\n",
					sasl_errstring(saslresult, NULL, NULL),
					saslresult);

			/* fail deliberately, see RFC 2554 4. */
			smtpmessage("*", m, mci);

			/*
			**  but we should only fail for this authentication
			**  mechanism; how to do that?
			*/

			smtpresult = reply(m, mci, e, TimeOuts.to_auth,
					   getsasldata, NULL, XS_AUTH);
			return EX_NOPERM;
		}

		if (outlen > 0)
		{
			saslresult = sasl_encode64(out, outlen, in64,
						   sizeof(in64), NULL);
			if (saslresult != SASL_OK)
			{
				/* give an error reply to the other side! */
				smtpmessage("*", m, mci);
				return EX_TEMPFAIL;
			}
		}
		else
			in64[0] = '\0';
# if SASL < 20000
		sm_sasl_free(out); /* XXX only if no rpool is used */
# endif /* SASL < 20000 */
		smtpmessage("%s", m, mci, in64);
		smtpresult = reply(m, mci, e, TimeOuts.to_auth,
				   getsasldata, NULL, XS_AUTH);
	}
	/* NOTREACHED */
}
/*
**  SMTPAUTH -- try to AUTHenticate
**
**	This will try mechanisms in the order the sasl library decided until:
**	- there are no more mechanisms
**	- a mechanism succeeds
**	- the sasl library fails initializing
**
**	Parameters:
**		m -- the mailer.
**		mci -- the mailer connection info.
**		e -- the envelope.
**
**	Returns:
**		EX_OK -- authentication was successful
**		EX_UNAVAILABLE -- authentication not possible, e.g.,
**			no data available.
**		EX_NOPERM -- authentication failed.
**		EX_TEMPFAIL -- temporary failure.
**
**	Notice: AuthInfo is used for all connections, hence we must
**		return EX_TEMPFAIL only if we really want to retry, i.e.,
**		iff getauth() tempfailed or getauth() was used and
**		authentication tempfailed.
*/

int
smtpauth(m, mci, e)
	MAILER *m;
	MCI *mci;
	ENVELOPE *e;
{
	int result;
	int i;
	bool usedgetauth;

	mci->mci_sasl_auth = false;
	for (i = 0; i < SASL_MECH ; i++)
		mci->mci_sai[i] = NULL;

	result = getauth(mci, e, &(mci->mci_sai));
	if (result == EX_TEMPFAIL)
		return result;
	usedgetauth = true;

	/* no data available: don't try to authenticate */
	if (result == EX_OK && mci->mci_sai[SASL_AUTHID] == NULL)
		return result;
	if (result != EX_OK)
	{
		if (SASLInfo == NULL)
			return EX_UNAVAILABLE;

		/* read authinfo from file */
		result = readauth(SASLInfo, true, &(mci->mci_sai),
				  mci->mci_rpool);
		if (result != EX_OK)
			return result;
		usedgetauth = false;
	}

	/* check whether sufficient data is available */
	if (mci->mci_sai[SASL_PASSWORD] == NULL ||
	    *(mci->mci_sai)[SASL_PASSWORD] == '\0')
		return EX_UNAVAILABLE;
	if ((mci->mci_sai[SASL_AUTHID] == NULL ||
	     *(mci->mci_sai)[SASL_AUTHID] == '\0') &&
	    (mci->mci_sai[SASL_USER] == NULL ||
	     *(mci->mci_sai)[SASL_USER] == '\0'))
		return EX_UNAVAILABLE;

	/* set the context for the callback function to sai */
# if SASL >= 20000
	callbacks[CB_PASS_IDX].context = (void *) mci;
# else /* SASL >= 20000 */
	callbacks[CB_PASS_IDX].context = (void *) &mci->mci_sai;
# endif /* SASL >= 20000 */
	callbacks[CB_USER_IDX].context = (void *) &mci->mci_sai;
	callbacks[CB_AUTHNAME_IDX].context = (void *) &mci->mci_sai;
	callbacks[CB_GETREALM_IDX].context = (void *) &mci->mci_sai;
#if 0
	callbacks[CB_SAFESASL_IDX].context = (void *) &mci->mci_sai;
#endif /* 0 */

	/* set default value for realm */
	if ((mci->mci_sai)[SASL_DEFREALM] == NULL)
		(mci->mci_sai)[SASL_DEFREALM] = sm_rpool_strdup_x(e->e_rpool,
							macvalue('j', CurEnv));

	/* set default value for list of mechanism to use */
	if ((mci->mci_sai)[SASL_MECHLIST] == NULL ||
	    *(mci->mci_sai)[SASL_MECHLIST] == '\0')
		(mci->mci_sai)[SASL_MECHLIST] = AuthMechanisms;

	/* create list of mechanisms to try */
	mci->mci_saslcap = intersect((mci->mci_sai)[SASL_MECHLIST],
				     mci->mci_saslcap, mci->mci_rpool);

	/* initialize sasl client library */
	result = init_sasl_client();
	if (result != SASL_OK)
		return usedgetauth ? EX_TEMPFAIL : EX_UNAVAILABLE;
	do
	{
		result = attemptauth(m, mci, e, &(mci->mci_sai));
		if (result == EX_OK)
			mci->mci_sasl_auth = true;
		else if (result == EX_TEMPFAIL || result == EX_NOPERM)
		{
			mci->mci_saslcap = removemech((mci->mci_sai)[SASL_MECH],
						      mci->mci_saslcap,
						      mci->mci_rpool);
			if (mci->mci_saslcap == NULL ||
			    *(mci->mci_saslcap) == '\0')
				return usedgetauth ? result
						   : EX_UNAVAILABLE;
		}
		else
			return result;
	} while (result != EX_OK);
	return result;
}
#endif /* SASL */

/*
**  SMTPMAILFROM -- send MAIL command
**
**	Parameters:
**		m -- the mailer.
**		mci -- the mailer connection structure.
**		e -- the envelope (including the sender to specify).
*/

int
smtpmailfrom(m, mci, e)
	MAILER *m;
	MCI *mci;
	ENVELOPE *e;
{
	int r;
	char *bufp;
	char *bodytype;
	char *enhsc;
	char buf[MAXNAME + 1];
	char optbuf[MAXLINE];

	if (tTd(18, 2))
		sm_dprintf("smtpmailfrom: CurHost=%s\n", CurHostName);
	enhsc = NULL;

	/*
	**  Check if connection is gone, if so
	**  it's a tempfail and we use mci_errno
	**  for the reason.
	*/

	if (mci->mci_state == MCIS_CLOSED)
	{
		errno = mci->mci_errno;
		return EX_TEMPFAIL;
	}

	/* set up appropriate options to include */
	if (bitset(MCIF_SIZE, mci->mci_flags) && e->e_msgsize > 0)
	{
		(void) sm_snprintf(optbuf, sizeof(optbuf), " SIZE=%ld",
			e->e_msgsize);
		bufp = &optbuf[strlen(optbuf)];
	}
	else
	{
		optbuf[0] = '\0';
		bufp = optbuf;
	}

	bodytype = e->e_bodytype;
	if (bitset(MCIF_8BITMIME, mci->mci_flags))
	{
		if (bodytype == NULL &&
		    bitset(MM_MIME8BIT, MimeMode) &&
		    bitset(EF_HAS8BIT, e->e_flags) &&
		    !bitset(EF_DONT_MIME, e->e_flags) &&
		    !bitnset(M_8BITS, m->m_flags))
			bodytype = "8BITMIME";
		if (bodytype != NULL &&
		    SPACELEFT(optbuf, bufp) > strlen(bodytype) + 7)
		{
			(void) sm_snprintf(bufp, SPACELEFT(optbuf, bufp),
				 " BODY=%s", bodytype);
			bufp += strlen(bufp);
		}
	}
	else if (bitnset(M_8BITS, m->m_flags) ||
		 !bitset(EF_HAS8BIT, e->e_flags) ||
		 bitset(MCIF_8BITOK, mci->mci_flags))
	{
		/* EMPTY */
		/* just pass it through */
	}
#if MIME8TO7
	else if (bitset(MM_CVTMIME, MimeMode) &&
		 !bitset(EF_DONT_MIME, e->e_flags) &&
		 (!bitset(MM_PASS8BIT, MimeMode) ||
		  bitset(EF_IS_MIME, e->e_flags)))
	{
		/* must convert from 8bit MIME format to 7bit encoded */
		mci->mci_flags |= MCIF_CVT8TO7;
	}
#endif /* MIME8TO7 */
	else if (!bitset(MM_PASS8BIT, MimeMode))
	{
		/* cannot just send a 8-bit version */
		extern char MsgBuf[];

		usrerrenh("5.6.3", "%s does not support 8BITMIME", CurHostName);
		mci_setstat(mci, EX_NOTSTICKY, "5.6.3", MsgBuf);
		return EX_DATAERR;
	}

	if (bitset(MCIF_DSN, mci->mci_flags))
	{
		if (e->e_envid != NULL &&
		    SPACELEFT(optbuf, bufp) > strlen(e->e_envid) + 7)
		{
			(void) sm_snprintf(bufp, SPACELEFT(optbuf, bufp),
				 " ENVID=%s", e->e_envid);
			bufp += strlen(bufp);
		}

		/* RET= parameter */
		if (bitset(EF_RET_PARAM, e->e_flags) &&
		    SPACELEFT(optbuf, bufp) > 9)
		{
			(void) sm_snprintf(bufp, SPACELEFT(optbuf, bufp),
				 " RET=%s",
				 bitset(EF_NO_BODY_RETN, e->e_flags) ?
					"HDRS" : "FULL");
			bufp += strlen(bufp);
		}
	}

	if (bitset(MCIF_AUTH, mci->mci_flags) && e->e_auth_param != NULL &&
	    SPACELEFT(optbuf, bufp) > strlen(e->e_auth_param) + 7
#if SASL
	     && (!bitset(SASL_AUTH_AUTH, SASLOpts) || mci->mci_sasl_auth)
#endif /* SASL */
	    )
	{
		(void) sm_snprintf(bufp, SPACELEFT(optbuf, bufp),
			 " AUTH=%s", e->e_auth_param);
		bufp += strlen(bufp);
	}

	/*
	**  17 is the max length required, we could use log() to compute
	**  the exact length (and check IS_DLVR_TRACE())
	*/

	if (bitset(MCIF_DLVR_BY, mci->mci_flags) &&
	    IS_DLVR_BY(e) && SPACELEFT(optbuf, bufp) > 17)
	{
		long dby;

		/*
		**  Avoid problems with delays (for R) since the check
		**  in deliver() whether min-deliver-time is sufficient.
		**  Alternatively we could pass the computed time to this
		**  function.
		*/

		dby = e->e_deliver_by - (curtime() - e->e_ctime);
		if (dby <= 0 && IS_DLVR_RETURN(e))
			dby = mci->mci_min_by <= 0 ? 1 : mci->mci_min_by;
		(void) sm_snprintf(bufp, SPACELEFT(optbuf, bufp),
			" BY=%ld;%c%s",
			dby,
			IS_DLVR_RETURN(e) ? 'R' : 'N',
			IS_DLVR_TRACE(e) ? "T" : "");
		bufp += strlen(bufp);
	}

	/*
	**  Send the MAIL command.
	**	Designates the sender.
	*/

	mci->mci_state = MCIS_MAIL;

	if (bitset(EF_RESPONSE, e->e_flags) &&
	    !bitnset(M_NO_NULL_FROM, m->m_flags))
		buf[0] = '\0';
	else
		expand("\201g", buf, sizeof(buf), e);
	if (buf[0] == '<')
	{
		/* strip off <angle brackets> (put back on below) */
		bufp = &buf[strlen(buf) - 1];
		if (*bufp == '>')
			*bufp = '\0';
		bufp = &buf[1];
	}
	else
		bufp = buf;
	if (bitnset(M_LOCALMAILER, e->e_from.q_mailer->m_flags) ||
	    !bitnset(M_FROMPATH, m->m_flags))
	{
		smtpmessage("MAIL From:<%s>%s", m, mci, bufp, optbuf);
	}
	else
	{
		smtpmessage("MAIL From:<@@%s%c%s>%s", m, mci, MyHostName,
			    *bufp == '@@' ? ',' : ':', bufp, optbuf);
	}
	SmtpPhase = mci->mci_phase = "client MAIL";
	sm_setproctitle(true, e, "%s %s: %s", qid_printname(e),
			CurHostName, mci->mci_phase);
	r = reply(m, mci, e, TimeOuts.to_mail, NULL, &enhsc, XS_MAIL);
	if (r < 0)
	{
		/* communications failure */
		mci_setstat(mci, EX_TEMPFAIL, "4.4.2", NULL);
		return EX_TEMPFAIL;
	}
	else if (r == SMTPCLOSING)
	{
		/* service shutting down: handled by reply() */
		return EX_TEMPFAIL;
	}
	else if (REPLYTYPE(r) == 4)
	{
		mci_setstat(mci, EX_NOTSTICKY, ENHSCN(enhsc, smtptodsn(r)),
			    SmtpReplyBuffer);
		return EX_TEMPFAIL;
	}
	else if (REPLYTYPE(r) == 2)
	{
		return EX_OK;
	}
	else if (r == 501)
	{
		/* syntax error in arguments */
		mci_setstat(mci, EX_NOTSTICKY, ENHSCN(enhsc, "5.5.2"),
			    SmtpReplyBuffer);
		return EX_DATAERR;
	}
	else if (r == 553)
	{
		/* mailbox name not allowed */
		mci_setstat(mci, EX_NOTSTICKY, ENHSCN(enhsc, "5.1.3"),
			    SmtpReplyBuffer);
		return EX_DATAERR;
	}
	else if (r == 552)
	{
		/* exceeded storage allocation */
		mci_setstat(mci, EX_NOTSTICKY, ENHSCN(enhsc, "5.3.4"),
			    SmtpReplyBuffer);
		if (bitset(MCIF_SIZE, mci->mci_flags))
			e->e_flags |= EF_NO_BODY_RETN;
		return EX_UNAVAILABLE;
	}
	else if (REPLYTYPE(r) == 5)
	{
		/* unknown error */
		mci_setstat(mci, EX_NOTSTICKY, ENHSCN(enhsc, "5.0.0"),
			    SmtpReplyBuffer);
		return EX_UNAVAILABLE;
	}

	if (LogLevel > 1)
	{
		sm_syslog(LOG_CRIT, e->e_id,
			  "%.100s: SMTP MAIL protocol error: %s",
			  CurHostName,
			  shortenstring(SmtpReplyBuffer, 403));
	}

	/* protocol error -- close up */
	mci_setstat(mci, EX_PROTOCOL, ENHSCN(enhsc, "5.5.1"),
		    SmtpReplyBuffer);
	smtpquit(m, mci, e);
	return EX_PROTOCOL;
}
/*
**  SMTPRCPT -- designate recipient.
**
**	Parameters:
**		to -- address of recipient.
**		m -- the mailer we are sending to.
**		mci -- the connection info for this transaction.
**		e -- the envelope for this transaction.
**
**	Returns:
**		exit status corresponding to recipient status.
**
**	Side Effects:
**		Sends the mail via SMTP.
*/

int
smtprcpt(to, m, mci, e, ctladdr, xstart)
	ADDRESS *to;
	register MAILER *m;
	MCI *mci;
	ENVELOPE *e;
	ADDRESS *ctladdr;
	time_t xstart;
{
	char *bufp;
	char optbuf[MAXLINE];

#if PIPELINING
	/*
	**  If there is status waiting from the other end, read it.
	**  This should normally happen because of SMTP pipelining.
	*/

	while (mci->mci_nextaddr != NULL &&
	       sm_io_getinfo(mci->mci_in, SM_IO_IS_READABLE, NULL) > 0)
	{
		int r;

		r = smtprcptstat(mci->mci_nextaddr, m, mci, e);
		if (r != EX_OK)
		{
			markfailure(e, mci->mci_nextaddr, mci, r, false);
			giveresponse(r, mci->mci_nextaddr->q_status,  m, mci,
				     ctladdr, xstart, e, to);
		}
		mci->mci_nextaddr = mci->mci_nextaddr->q_pchain;
	}
#endif /* PIPELINING */

	/*
	**  Check if connection is gone, if so
	**  it's a tempfail and we use mci_errno
	**  for the reason.
	*/

	if (mci->mci_state == MCIS_CLOSED)
	{
		errno = mci->mci_errno;
		return EX_TEMPFAIL;
	}

	optbuf[0] = '\0';
	bufp = optbuf;

	/*
	**  Warning: in the following it is assumed that the free space
	**  in bufp is sizeof(optbuf)
	*/

	if (bitset(MCIF_DSN, mci->mci_flags))
	{
		if (IS_DLVR_NOTIFY(e) &&
		    !bitset(MCIF_DLVR_BY, mci->mci_flags))
		{
			/* RFC 2852: 4.1.4.2 */
			if (!bitset(QHASNOTIFY, to->q_flags))
				to->q_flags |= QPINGONFAILURE|QPINGONDELAY|QHASNOTIFY;
			else if (bitset(QPINGONSUCCESS, to->q_flags) ||
				 bitset(QPINGONFAILURE, to->q_flags) ||
				 bitset(QPINGONDELAY, to->q_flags))
				to->q_flags |= QPINGONDELAY;
		}

		/* NOTIFY= parameter */
		if (bitset(QHASNOTIFY, to->q_flags) &&
		    bitset(QPRIMARY, to->q_flags) &&
		    !bitnset(M_LOCALMAILER, m->m_flags))
		{
			bool firstone = true;

			(void) sm_strlcat(bufp, " NOTIFY=", sizeof(optbuf));
			if (bitset(QPINGONSUCCESS, to->q_flags))
			{
				(void) sm_strlcat(bufp, "SUCCESS", sizeof(optbuf));
				firstone = false;
			}
			if (bitset(QPINGONFAILURE, to->q_flags))
			{
				if (!firstone)
					(void) sm_strlcat(bufp, ",",
						       sizeof(optbuf));
				(void) sm_strlcat(bufp, "FAILURE", sizeof(optbuf));
				firstone = false;
			}
			if (bitset(QPINGONDELAY, to->q_flags))
			{
				if (!firstone)
					(void) sm_strlcat(bufp, ",",
						       sizeof(optbuf));
				(void) sm_strlcat(bufp, "DELAY", sizeof(optbuf));
				firstone = false;
			}
			if (firstone)
				(void) sm_strlcat(bufp, "NEVER", sizeof(optbuf));
			bufp += strlen(bufp);
		}

		/* ORCPT= parameter */
		if (to->q_orcpt != NULL &&
		    SPACELEFT(optbuf, bufp) > strlen(to->q_orcpt) + 7)
		{
			(void) sm_snprintf(bufp, SPACELEFT(optbuf, bufp),
				 " ORCPT=%s", to->q_orcpt);
			bufp += strlen(bufp);
		}
	}

	smtpmessage("RCPT To:<%s>%s", m, mci, to->q_user, optbuf);
	mci->mci_state = MCIS_RCPT;

	SmtpPhase = mci->mci_phase = "client RCPT";
	sm_setproctitle(true, e, "%s %s: %s", qid_printname(e),
			CurHostName, mci->mci_phase);

#if PIPELINING
	/*
	**  If running SMTP pipelining, we will pick up status later
	*/

	if (bitset(MCIF_PIPELINED, mci->mci_flags))
		return EX_OK;
#endif /* PIPELINING */

	return smtprcptstat(to, m, mci, e);
}
/*
**  SMTPRCPTSTAT -- get recipient status
**
**	This is only called during SMTP pipelining
**
**	Parameters:
**		to -- address of recipient.
**		m -- mailer being sent to.
**		mci -- the mailer connection information.
**		e -- the envelope for this message.
**
**	Returns:
**		EX_* -- protocol status
*/

static int
smtprcptstat(to, m, mci, e)
	ADDRESS *to;
	MAILER *m;
	register MCI *mci;
	register ENVELOPE *e;
{
	int r;
	int save_errno;
	char *enhsc;

	/*
	**  Check if connection is gone, if so
	**  it's a tempfail and we use mci_errno
	**  for the reason.
	*/

	if (mci->mci_state == MCIS_CLOSED)
	{
		errno = mci->mci_errno;
		return EX_TEMPFAIL;
	}

	enhsc = NULL;
	r = reply(m, mci, e, TimeOuts.to_rcpt, NULL, &enhsc, XS_RCPT);
	save_errno = errno;
	to->q_rstatus = sm_rpool_strdup_x(e->e_rpool, SmtpReplyBuffer);
	to->q_status = ENHSCN_RPOOL(enhsc, smtptodsn(r), e->e_rpool);
	if (!bitnset(M_LMTP, m->m_flags))
		to->q_statmta = mci->mci_host;
	if (r < 0 || REPLYTYPE(r) == 4)
	{
		mci->mci_retryrcpt = true;
		errno = save_errno;
		return EX_TEMPFAIL;
	}
	else if (REPLYTYPE(r) == 2)
	{
		char *t;

		if ((t = mci->mci_tolist) != NULL)
		{
			char *p;

			*t++ = ',';
			for (p = to->q_paddr; *p != '\0'; *t++ = *p++)
				continue;
			*t = '\0';
			mci->mci_tolist = t;
		}
#if PIPELINING
		mci->mci_okrcpts++;
#endif /* PIPELINING */
		return EX_OK;
	}
	else if (r == 550)
	{
		to->q_status = ENHSCN_RPOOL(enhsc, "5.1.1", e->e_rpool);
		return EX_NOUSER;
	}
	else if (r == 551)
	{
		to->q_status = ENHSCN_RPOOL(enhsc, "5.1.6", e->e_rpool);
		return EX_NOUSER;
	}
	else if (r == 553)
	{
		to->q_status = ENHSCN_RPOOL(enhsc, "5.1.3", e->e_rpool);
		return EX_NOUSER;
	}
	else if (REPLYTYPE(r) == 5)
	{
		return EX_UNAVAILABLE;
	}

	if (LogLevel > 1)
	{
		sm_syslog(LOG_CRIT, e->e_id,
			  "%.100s: SMTP RCPT protocol error: %s",
			  CurHostName,
			  shortenstring(SmtpReplyBuffer, 403));
	}

	mci_setstat(mci, EX_PROTOCOL, ENHSCN(enhsc, "5.5.1"),
		    SmtpReplyBuffer);
	return EX_PROTOCOL;
}
/*
**  SMTPDATA -- send the data and clean up the transaction.
**
**	Parameters:
**		m -- mailer being sent to.
**		mci -- the mailer connection information.
**		e -- the envelope for this message.
**
**	Returns:
**		exit status corresponding to DATA command.
*/

int
smtpdata(m, mci, e, ctladdr, xstart)
	MAILER *m;
	register MCI *mci;
	register ENVELOPE *e;
	ADDRESS *ctladdr;
	time_t xstart;
{
	register int r;
	int rstat;
	int xstat;
	int timeout;
	char *enhsc;

	/*
	**  Check if connection is gone, if so
	**  it's a tempfail and we use mci_errno
	**  for the reason.
	*/

	if (mci->mci_state == MCIS_CLOSED)
	{
		errno = mci->mci_errno;
		return EX_TEMPFAIL;
	}

	enhsc = NULL;

	/*
	**  Send the data.
	**	First send the command and check that it is ok.
	**	Then send the data (if there are valid recipients).
	**	Follow it up with a dot to terminate.
	**	Finally get the results of the transaction.
	*/

	/* send the command and check ok to proceed */
	smtpmessage("DATA", m, mci);

#if PIPELINING
	if (mci->mci_nextaddr != NULL)
	{
		char *oldto = e->e_to;

		/* pick up any pending RCPT responses for SMTP pipelining */
		while (mci->mci_nextaddr != NULL)
		{
			int r;

			e->e_to = mci->mci_nextaddr->q_paddr;
			r = smtprcptstat(mci->mci_nextaddr, m, mci, e);
			if (r != EX_OK)
			{
				markfailure(e, mci->mci_nextaddr, mci, r,
					    false);
				giveresponse(r, mci->mci_nextaddr->q_status, m,
					     mci, ctladdr, xstart, e,
					     mci->mci_nextaddr);
				if (r == EX_TEMPFAIL)
					mci->mci_nextaddr->q_state = QS_RETRY;
			}
			mci->mci_nextaddr = mci->mci_nextaddr->q_pchain;
		}
		e->e_to = oldto;

		/*
		**  Connection might be closed in response to a RCPT command,
		**  i.e., the server responded with 421. In that case (at
		**  least) one RCPT has a temporary failure, hence we don't
		**  need to check mci_okrcpts (as it is done below) to figure
		**  out which error to return.
		*/

		if (mci->mci_state == MCIS_CLOSED)
		{
			errno = mci->mci_errno;
			return EX_TEMPFAIL;
		}
	}
#endif /* PIPELINING */

	/* now proceed with DATA phase */
	SmtpPhase = mci->mci_phase = "client DATA 354";
	mci->mci_state = MCIS_DATA;
	sm_setproctitle(true, e, "%s %s: %s",
			qid_printname(e), CurHostName, mci->mci_phase);
	r = reply(m, mci, e, TimeOuts.to_datainit, NULL, &enhsc, XS_DATA);
	if (r < 0 || REPLYTYPE(r) == 4)
	{
		if (r >= 0)
			smtpquit(m, mci, e);
		errno = mci->mci_errno;
		return EX_TEMPFAIL;
	}
	else if (REPLYTYPE(r) == 5)
	{
		smtprset(m, mci, e);
#if PIPELINING
		if (mci->mci_okrcpts <= 0)
			return mci->mci_retryrcpt ? EX_TEMPFAIL
						  : EX_UNAVAILABLE;
#endif /* PIPELINING */
		return EX_UNAVAILABLE;
	}
	else if (REPLYTYPE(r) != 3)
	{
		if (LogLevel > 1)
		{
			sm_syslog(LOG_CRIT, e->e_id,
				  "%.100s: SMTP DATA-1 protocol error: %s",
				  CurHostName,
				  shortenstring(SmtpReplyBuffer, 403));
		}
		smtprset(m, mci, e);
		mci_setstat(mci, EX_PROTOCOL, ENHSCN(enhsc, "5.5.1"),
			    SmtpReplyBuffer);
#if PIPELINING
		if (mci->mci_okrcpts <= 0)
			return mci->mci_retryrcpt ? EX_TEMPFAIL
						  : EX_PROTOCOL;
#endif /* PIPELINING */
		return EX_PROTOCOL;
	}

#if PIPELINING
	if (mci->mci_okrcpts > 0)
	{
#endif /* PIPELINING */

	/*
	**  Set timeout around data writes.  Make it at least large
	**  enough for DNS timeouts on all recipients plus some fudge
	**  factor.  The main thing is that it should not be infinite.
	*/

	if (tTd(18, 101))
	{
		/* simulate a DATA timeout */
		timeout = 10;
	}
	else
		timeout = DATA_PROGRESS_TIMEOUT * 1000;
	sm_io_setinfo(mci->mci_out, SM_IO_WHAT_TIMEOUT, &timeout);


	/*
	**  Output the actual message.
	*/

	if (!(*e->e_puthdr)(mci, e->e_header, e, M87F_OUTER))
		goto writeerr;

	if (tTd(18, 101))
	{
		/* simulate a DATA timeout */
		(void) sleep(2);
	}

	if (!(*e->e_putbody)(mci, e, NULL))
		goto writeerr;

	/*
	**  Cleanup after sending message.
	*/


#if PIPELINING
	}
#endif /* PIPELINING */

#if _FFR_CATCH_BROKEN_MTAS
	if (sm_io_getinfo(mci->mci_in, SM_IO_IS_READABLE, NULL) > 0)
	{
		/* terminate the message */
		(void) sm_io_fprintf(mci->mci_out, SM_TIME_DEFAULT, ".%s",
				     m->m_eol);
		if (TrafficLogFile != NULL)
			(void) sm_io_fprintf(TrafficLogFile, SM_TIME_DEFAULT,
					     "%05d >>> .\n", (int) CurrentPid);
		if (Verbose)
			nmessage(">>> .");

		sm_syslog(LOG_CRIT, e->e_id,
			  "%.100s: SMTP DATA-1 protocol error: remote server returned response before final dot",
			  CurHostName);
		mci->mci_errno = EIO;
		mci->mci_state = MCIS_ERROR;
		mci_setstat(mci, EX_PROTOCOL, "5.5.0", NULL);
		smtpquit(m, mci, e);
		return EX_PROTOCOL;
	}
#endif /* _FFR_CATCH_BROKEN_MTAS */

	if (sm_io_error(mci->mci_out))
	{
		/* error during processing -- don't send the dot */
		mci->mci_errno = EIO;
		mci->mci_state = MCIS_ERROR;
		mci_setstat(mci, EX_IOERR, "4.4.2", NULL);
		smtpquit(m, mci, e);
		return EX_IOERR;
	}

	/* terminate the message */
	if (sm_io_fprintf(mci->mci_out, SM_TIME_DEFAULT, "%s.%s",
			bitset(MCIF_INLONGLINE, mci->mci_flags) ? m->m_eol : "",
			m->m_eol) == SM_IO_EOF)
		goto writeerr;
	if (TrafficLogFile != NULL)
		(void) sm_io_fprintf(TrafficLogFile, SM_TIME_DEFAULT,
				     "%05d >>> .\n", (int) CurrentPid);
	if (Verbose)
		nmessage(">>> .");

	/* check for the results of the transaction */
	SmtpPhase = mci->mci_phase = "client DATA status";
	sm_setproctitle(true, e, "%s %s: %s", qid_printname(e),
			CurHostName, mci->mci_phase);
	if (bitnset(M_LMTP, m->m_flags))
		return EX_OK;
	r = reply(m, mci, e, TimeOuts.to_datafinal, NULL, &enhsc, XS_EOM);
	if (r < 0)
		return EX_TEMPFAIL;
	if (mci->mci_state == MCIS_DATA)
		mci->mci_state = MCIS_OPEN;
	xstat = EX_NOTSTICKY;
	if (r == 452)
		rstat = EX_TEMPFAIL;
	else if (REPLYTYPE(r) == 4)
		rstat = xstat = EX_TEMPFAIL;
	else if (REPLYTYPE(r) == 2)
		rstat = xstat = EX_OK;
	else if (REPLYCLASS(r) != 5)
		rstat = xstat = EX_PROTOCOL;
	else if (REPLYTYPE(r) == 5)
		rstat = EX_UNAVAILABLE;
	else
		rstat = EX_PROTOCOL;
	mci_setstat(mci, xstat, ENHSCN(enhsc, smtptodsn(r)),
		    SmtpReplyBuffer);
	if (bitset(MCIF_ENHSTAT, mci->mci_flags) &&
	    (r = isenhsc(SmtpReplyBuffer + 4, ' ')) > 0)
		r += 5;
	else
		r = 4;
	e->e_statmsg = sm_rpool_strdup_x(e->e_rpool, &SmtpReplyBuffer[r]);
	SmtpPhase = mci->mci_phase = "idle";
	sm_setproctitle(true, e, "%s: %s", CurHostName, mci->mci_phase);
	if (rstat != EX_PROTOCOL)
		return rstat;
	if (LogLevel > 1)
	{
		sm_syslog(LOG_CRIT, e->e_id,
			  "%.100s: SMTP DATA-2 protocol error: %s",
			  CurHostName,
			  shortenstring(SmtpReplyBuffer, 403));
	}
	return rstat;

  writeerr:
	mci->mci_errno = errno;
	mci->mci_state = MCIS_ERROR;
	mci_setstat(mci, EX_TEMPFAIL, "4.4.2", NULL);

	/*
	**  If putbody() couldn't finish due to a timeout,
	**  rewind it here in the timeout handler.  See
	**  comments at the end of putbody() for reasoning.
	*/

	if (e->e_dfp != NULL)
		(void) bfrewind(e->e_dfp);

	errno = mci->mci_errno;
	syserr("451 4.4.1 timeout writing message to %s", CurHostName);
	smtpquit(m, mci, e);
	return EX_TEMPFAIL;
}

/*
**  SMTPGETSTAT -- get status code from DATA in LMTP
**
**	Parameters:
**		m -- the mailer to which we are sending the message.
**		mci -- the mailer connection structure.
**		e -- the current envelope.
**
**	Returns:
**		The exit status corresponding to the reply code.
*/

int
smtpgetstat(m, mci, e)
	MAILER *m;
	MCI *mci;
	ENVELOPE *e;
{
	int r;
	int off;
	int status, xstat;
	char *enhsc;

	enhsc = NULL;

	/* check for the results of the transaction */
	r = reply(m, mci, e, TimeOuts.to_datafinal, NULL, &enhsc, XS_DATA2);
	if (r < 0)
		return EX_TEMPFAIL;
	xstat = EX_NOTSTICKY;
	if (REPLYTYPE(r) == 4)
		status = EX_TEMPFAIL;
	else if (REPLYTYPE(r) == 2)
		status = xstat = EX_OK;
	else if (REPLYCLASS(r) != 5)
		status = xstat = EX_PROTOCOL;
	else if (REPLYTYPE(r) == 5)
		status = EX_UNAVAILABLE;
	else
		status = EX_PROTOCOL;
	if (bitset(MCIF_ENHSTAT, mci->mci_flags) &&
	    (off = isenhsc(SmtpReplyBuffer + 4, ' ')) > 0)
		off += 5;
	else
		off = 4;
	e->e_statmsg = sm_rpool_strdup_x(e->e_rpool, &SmtpReplyBuffer[off]);
	mci_setstat(mci, xstat, ENHSCN(enhsc, smtptodsn(r)), SmtpReplyBuffer);
	if (LogLevel > 1 && status == EX_PROTOCOL)
	{
		sm_syslog(LOG_CRIT, e->e_id,
			  "%.100s: SMTP DATA-3 protocol error: %s",
			  CurHostName,
			  shortenstring(SmtpReplyBuffer, 403));
	}
	return status;
}
/*
**  SMTPQUIT -- close the SMTP connection.
**
**	Parameters:
**		m -- a pointer to the mailer.
**		mci -- the mailer connection information.
**		e -- the current envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		sends the final protocol and closes the connection.
*/

void
smtpquit(m, mci, e)
	register MAILER *m;
	register MCI *mci;
	ENVELOPE *e;
{
	bool oldSuprErrs = SuprErrs;
	int rcode;
	char *oldcurhost;

	if (mci->mci_state == MCIS_CLOSED)
	{
		mci_close(mci, "smtpquit:1");
		return;
	}

	oldcurhost = CurHostName;
	CurHostName = mci->mci_host;		/* XXX UGLY XXX */
	if (CurHostName == NULL)
		CurHostName = MyHostName;

#if PIPELINING
	mci->mci_okrcpts = 0;
#endif /* PIPELINING */

	/*
	**	Suppress errors here -- we may be processing a different
	**	job when we do the quit connection, and we don't want the
	**	new job to be penalized for something that isn't it's
	**	problem.
	*/

	SuprErrs = true;

	/* send the quit message if we haven't gotten I/O error */
	if (mci->mci_state != MCIS_ERROR &&
	    mci->mci_state != MCIS_QUITING)
	{
		SmtpPhase = "client QUIT";
		mci->mci_state = MCIS_QUITING;
		smtpmessage("QUIT", m, mci);
		(void) reply(m, mci, e, TimeOuts.to_quit, NULL, NULL, XS_QUIT);
		SuprErrs = oldSuprErrs;
		if (mci->mci_state == MCIS_CLOSED)
			goto end;
	}

	/* now actually close the connection and pick up the zombie */
	rcode = endmailer(mci, e, NULL);
	if (rcode != EX_OK)
	{
		char *mailer = NULL;

		if (mci->mci_mailer != NULL &&
		    mci->mci_mailer->m_name != NULL)
			mailer = mci->mci_mailer->m_name;

		/* look for naughty mailers */
		sm_syslog(LOG_ERR, e->e_id,
			  "smtpquit: mailer%s%s exited with exit value %d",
			  mailer == NULL ? "" : " ",
			  mailer == NULL ? "" : mailer,
			  rcode);
	}

	SuprErrs = oldSuprErrs;

  end:
	CurHostName = oldcurhost;
	return;
}
/*
**  SMTPRSET -- send a RSET (reset) command
**
**	Parameters:
**		m -- a pointer to the mailer.
**		mci -- the mailer connection information.
**		e -- the current envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		closes the connection if there is no reply to RSET.
*/

void
smtprset(m, mci, e)
	register MAILER *m;
	register MCI *mci;
	ENVELOPE *e;
{
	int r;

	CurHostName = mci->mci_host;		/* XXX UGLY XXX */
	if (CurHostName == NULL)
		CurHostName = MyHostName;

#if PIPELINING
	mci->mci_okrcpts = 0;
#endif /* PIPELINING */

	/*
	**  Check if connection is gone, if so
	**  it's a tempfail and we use mci_errno
	**  for the reason.
	*/

	if (mci->mci_state == MCIS_CLOSED)
	{
		errno = mci->mci_errno;
		return;
	}

	SmtpPhase = "client RSET";
	smtpmessage("RSET", m, mci);
	r = reply(m, mci, e, TimeOuts.to_rset, NULL, NULL, XS_DEFAULT);
	if (r < 0)
		return;

	/*
	**  Any response is deemed to be acceptable.
	**  The standard does not state the proper action
	**  to take when a value other than 250 is received.
	**
	**  However, if 421 is returned for the RSET, leave
	**  mci_state alone (MCIS_SSD can be set in reply()
	**  and MCIS_CLOSED can be set in smtpquit() if
	**  reply() gets a 421 and calls smtpquit()).
	*/

	if (mci->mci_state != MCIS_SSD && mci->mci_state != MCIS_CLOSED)
		mci->mci_state = MCIS_OPEN;
	else if (mci->mci_exitstat == EX_OK)
		mci_setstat(mci, EX_TEMPFAIL, "4.5.0", NULL);
}
/*
**  SMTPPROBE -- check the connection state
**
**	Parameters:
**		mci -- the mailer connection information.
**
**	Returns:
**		none.
**
**	Side Effects:
**		closes the connection if there is no reply to RSET.
*/

int
smtpprobe(mci)
	register MCI *mci;
{
	int r;
	MAILER *m = mci->mci_mailer;
	ENVELOPE *e;
	extern ENVELOPE BlankEnvelope;

	CurHostName = mci->mci_host;		/* XXX UGLY XXX */
	if (CurHostName == NULL)
		CurHostName = MyHostName;

	e = &BlankEnvelope;
	SmtpPhase = "client probe";
	smtpmessage("RSET", m, mci);
	r = reply(m, mci, e, TimeOuts.to_miscshort, NULL, NULL, XS_DEFAULT);
	if (REPLYTYPE(r) != 2)
		smtpquit(m, mci, e);
	return r;
}
/*
**  REPLY -- read arpanet reply
**
**	Parameters:
**		m -- the mailer we are reading the reply from.
**		mci -- the mailer connection info structure.
**		e -- the current envelope.
**		timeout -- the timeout for reads.
**		pfunc -- processing function called on each line of response.
**			If null, no special processing is done.
**		enhstat -- optional, returns enhanced error code string (if set)
**		rtype -- type of SmtpMsgBuffer: does it contains secret data?
**
**	Returns:
**		reply code it reads.
**
**	Side Effects:
**		flushes the mail file.
*/

int
reply(m, mci, e, timeout, pfunc, enhstat, rtype)
	MAILER *m;
	MCI *mci;
	ENVELOPE *e;
	time_t timeout;
	void (*pfunc) __P((char *, bool, MAILER *, MCI *, ENVELOPE *));
	char **enhstat;
	int rtype;
{
	register char *bufp;
	register int r;
	bool firstline = true;
	char junkbuf[MAXLINE];
	static char enhstatcode[ENHSCLEN];
	int save_errno;

	/*
	**  Flush the output before reading response.
	**
	**	For SMTP pipelining, it would be better if we didn't do
	**	this if there was already data waiting to be read.  But
	**	to do it properly means pushing it to the I/O library,
	**	since it really needs to be done below the buffer layer.
	*/

	if (mci->mci_out != NULL)
		(void) sm_io_flush(mci->mci_out, SM_TIME_DEFAULT);

	if (tTd(18, 1))
		sm_dprintf("reply\n");

	/*
	**  Read the input line, being careful not to hang.
	*/

	bufp = SmtpReplyBuffer;
	set_tls_rd_tmo(timeout);
	for (;;)
	{
		register char *p;

		/* actually do the read */
		if (e->e_xfp != NULL)	/* for debugging */
			(void) sm_io_flush(e->e_xfp, SM_TIME_DEFAULT);

		/* if we are in the process of closing just give the code */
		if (mci->mci_state == MCIS_CLOSED)
			return SMTPCLOSING;

		/* don't try to read from a non-existent fd */
		if (mci->mci_in == NULL)
		{
			if (mci->mci_errno == 0)
				mci->mci_errno = EBADF;

			/* errors on QUIT should be ignored */
			if (strncmp(SmtpMsgBuffer, "QUIT", 4) == 0)
			{
				errno = mci->mci_errno;
				mci_close(mci, "reply:1");
				return -1;
			}
			mci->mci_state = MCIS_ERROR;
			smtpquit(m, mci, e);
			errno = mci->mci_errno;
			return -1;
		}

		if (mci->mci_out != NULL)
			(void) sm_io_flush(mci->mci_out, SM_TIME_DEFAULT);

		/* get the line from the other side */
		p = sfgets(bufp, MAXLINE, mci->mci_in, timeout, SmtpPhase);
		save_errno = errno;
		mci->mci_lastuse = curtime();

		if (p == NULL)
		{
			bool oldholderrs;
			extern char MsgBuf[];

			/* errors on QUIT should be ignored */
			if (strncmp(SmtpMsgBuffer, "QUIT", 4) == 0)
			{
				mci_close(mci, "reply:2");
				return -1;
			}

			/* if the remote end closed early, fake an error */
			errno = save_errno;
			if (errno == 0)
			{
				(void) sm_snprintf(SmtpReplyBuffer,
						   sizeof(SmtpReplyBuffer),
						   "421 4.4.1 Connection reset by %s",
						   CURHOSTNAME);
#ifdef ECONNRESET
				errno = ECONNRESET;
#else /* ECONNRESET */
				errno = EPIPE;
#endif /* ECONNRESET */
			}

			mci->mci_errno = errno;
			oldholderrs = HoldErrs;
			HoldErrs = true;
			usrerr("451 4.4.1 reply: read error from %s",
			       CURHOSTNAME);
			mci_setstat(mci, EX_TEMPFAIL, "4.4.2", MsgBuf);

			/* if debugging, pause so we can see state */
			if (tTd(18, 100))
				(void) pause();
			mci->mci_state = MCIS_ERROR;
			smtpquit(m, mci, e);
#if XDEBUG
			{
				char wbuf[MAXLINE];

				p = wbuf;
				if (e->e_to != NULL)
				{
					(void) sm_snprintf(p,
							   SPACELEFT(wbuf, p),
							   "%s... ",
							   shortenstring(e->e_to, MAXSHORTSTR));
					p += strlen(p);
				}
				(void) sm_snprintf(p, SPACELEFT(wbuf, p),
						   "reply(%.100s) during %s",
						   CURHOSTNAME, SmtpPhase);
				checkfd012(wbuf);
			}
#endif /* XDEBUG */
			HoldErrs = oldholderrs;
			errno = save_errno;
			return -1;
		}
		fixcrlf(bufp, true);

		/* EHLO failure is not a real error */
		if (e->e_xfp != NULL && (bufp[0] == '4' ||
		    (bufp[0] == '5' && strncmp(SmtpMsgBuffer, "EHLO", 4) != 0)))
		{
			/* serious error -- log the previous command */
			if (SmtpNeedIntro)
			{
				/* inform user who we are chatting with */
				(void) sm_io_fprintf(CurEnv->e_xfp,
						     SM_TIME_DEFAULT,
						     "... while talking to %s:\n",
						     CURHOSTNAME);
				SmtpNeedIntro = false;
			}
			if (SmtpMsgBuffer[0] != '\0')
			{
				(void) sm_io_fprintf(e->e_xfp,
					SM_TIME_DEFAULT,
					">>> %s\n",
					(rtype == XS_STARTTLS)
					? "STARTTLS dialogue"
					: ((rtype == XS_AUTH)
					   ? "AUTH dialogue"
					   : SmtpMsgBuffer));
				SmtpMsgBuffer[0] = '\0';
			}

			/* now log the message as from the other side */
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
					     "<<< %s\n", bufp);
		}

		/* display the input for verbose mode */
		if (Verbose)
			nmessage("050 %s", bufp);

		/* ignore improperly formatted input */
		if (!ISSMTPREPLY(bufp))
			continue;

		if (bitset(MCIF_ENHSTAT, mci->mci_flags) &&
		    enhstat != NULL &&
		    extenhsc(bufp + 4, ' ', enhstatcode) > 0)
			*enhstat = enhstatcode;

		/* process the line */
		if (pfunc != NULL)
			(*pfunc)(bufp, firstline, m, mci, e);

		/* decode the reply code */
		r = atoi(bufp);

		/* extra semantics: 0xx codes are "informational" */
		if (r < 100)
		{
			firstline = false;
			continue;
		}

		firstline = false;

		/* if no continuation lines, return this line */
		if (bufp[3] != '-')
			break;

		/* first line of real reply -- ignore rest */
		bufp = junkbuf;
	}

	/*
	**  Now look at SmtpReplyBuffer -- only care about the first
	**  line of the response from here on out.
	*/

	/* save temporary failure messages for posterity */
	if (SmtpReplyBuffer[0] == '4')
		(void) sm_strlcpy(SmtpError, SmtpReplyBuffer, sizeof(SmtpError));

	/* reply code 421 is "Service Shutting Down" */
	if (r == SMTPCLOSING && mci->mci_state != MCIS_SSD &&
	    mci->mci_state != MCIS_QUITING)
	{
		/* send the quit protocol */
		mci->mci_state = MCIS_SSD;
		smtpquit(m, mci, e);
	}

	return r;
}
/*
**  SMTPMESSAGE -- send message to server
**
**	Parameters:
**		f -- format
**		m -- the mailer to control formatting.
**		a, b, c -- parameters
**
**	Returns:
**		none.
**
**	Side Effects:
**		writes message to mci->mci_out.
*/

/*VARARGS1*/
void
#ifdef __STDC__
smtpmessage(char *f, MAILER *m, MCI *mci, ...)
#else /* __STDC__ */
smtpmessage(f, m, mci, va_alist)
	char *f;
	MAILER *m;
	MCI *mci;
	va_dcl
#endif /* __STDC__ */
{
	SM_VA_LOCAL_DECL

	SM_VA_START(ap, mci);
	(void) sm_vsnprintf(SmtpMsgBuffer, sizeof(SmtpMsgBuffer), f, ap);
	SM_VA_END(ap);

	if (tTd(18, 1) || Verbose)
		nmessage(">>> %s", SmtpMsgBuffer);
	if (TrafficLogFile != NULL)
		(void) sm_io_fprintf(TrafficLogFile, SM_TIME_DEFAULT,
				     "%05d >>> %s\n", (int) CurrentPid,
				     SmtpMsgBuffer);
	if (mci->mci_out != NULL)
	{
		(void) sm_io_fprintf(mci->mci_out, SM_TIME_DEFAULT, "%s%s",
				     SmtpMsgBuffer, m == NULL ? "\r\n"
							      : m->m_eol);
	}
	else if (tTd(18, 1))
	{
		sm_dprintf("smtpmessage: NULL mci_out\n");
	}
}
@


1.25
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.24
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2006, 2008-2010 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: usersmtp.c,v 8.486 2013/03/12 15:24:54 ca Exp $")
d527 1
a527 1
	{	SASL_CB_GETREALM,	&saslgetrealm,	NULL	},
d529 1
a529 1
	{	SASL_CB_PASS,		&getsecret,	NULL	},
d531 1
a531 1
	{	SASL_CB_USER,		&getsimple,	NULL	},
d533 1
a533 1
	{	SASL_CB_AUTHNAME,	&getsimple,	NULL	},
d535 1
a535 1
	{	SASL_CB_VERIFYFILE,	&safesaslfile,	NULL	},
@


1.23
log
@Update to sendmail 8.14.5
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: usersmtp.c,v 8.485 2010/07/23 21:09:38 ca Exp $")
d804 1
a804 1
		sm_io_fgets(f, SM_TIME_DEFAULT, buf, sizeof(buf)) != NULL)
@


1.22
log
@Update to sendmail-8.14.3
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2006, 2008 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: usersmtp.c,v 8.472 2008/01/31 18:48:29 ca Exp $")
a35 1
#define REPLYCLASS(r)	(((r) / 10) % 10)	/* second digit of reply code */
d138 1
a138 2
	r = reply(m, mci, e, TimeOuts.to_initial, esmtp_check, NULL,
		XS_DEFAULT);
d184 1
a184 1
		  helo_options, NULL, XS_DEFAULT);
d337 9
a345 1
	res = (char *) sm_rpool_malloc(rpool, rl + 2);
d418 1
a418 3
#if SASL
		mci->mci_saslcap = NULL;
#endif /* SASL */
d479 2
a480 1
		if (p != NULL && *p != '\0')
d492 1
a492 1
				mci->mci_flags |= MCIF_AUTH;
d509 3
d1579 3
a1581 1
	char in64[MAXOUTLEN];
d1617 2
a1618 3
	{
		ssp.max_ssf = MaxSLBits;
		ssp.maxbufsize = MAXOUTLEN;
d1620 1
a1620 1
		ssp.security_flags = SASL_SEC_NOPLAINTEXT;
a1621 1
	}
d1781 2
a1782 1
		saslresult = sasl_encode64(out, outlen, in64, MAXOUTLEN, NULL);
d1849 1
a1849 1
						   MAXOUTLEN, NULL);
d2184 1
a2184 1
	r = reply(m, mci, e, TimeOuts.to_mail, NULL, &enhsc, XS_DEFAULT);
d2436 1
a2436 1
	r = reply(m, mci, e, TimeOuts.to_rcpt, NULL, &enhsc, XS_DEFAULT);
d2597 1
a2597 1
	r = reply(m, mci, e, TimeOuts.to_datainit, NULL, &enhsc, XS_DEFAULT);
d2731 1
a2731 1
	r = reply(m, mci, e, TimeOuts.to_datafinal, NULL, &enhsc, XS_DEFAULT);
d2816 1
a2816 1
	r = reply(m, mci, e, TimeOuts.to_datafinal, NULL, &enhsc, XS_DEFAULT);
d2902 1
a2902 2
		(void) reply(m, mci, e, TimeOuts.to_quit, NULL, NULL,
				XS_DEFAULT);
a3240 2
		firstline = false;

d3246 2
d3249 3
@


1.21
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2006 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: usersmtp.c,v 8.469 2006/12/13 20:11:15 ca Exp $")
d2706 3
a2708 2
	if (sm_io_fprintf(mci->mci_out, SM_TIME_DEFAULT, ".%s", m->m_eol) ==
								SM_IO_EOF)
d3080 1
@


1.20
log
@Update to sendmail 8.13.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: usersmtp.c,v 8.467 2006/03/19 06:07:56 ca Exp $")
d544 4
d796 1
a796 1
		sm_io_fgets(f, SM_TIME_DEFAULT, buf, sizeof buf) != NULL)
d1585 6
d1593 1
a1593 1
				     CurHostName, NULL, NULL, NULL, 0,
d1604 1
a1604 1
	(void) memset(&ssp, '\0', sizeof ssp);
d1663 1
a1663 1
			       remoteip, sizeof remoteip))
d1675 1
a1675 1
				       localip, sizeof localip))
d2024 1
a2024 1
		(void) sm_snprintf(optbuf, sizeof optbuf, " SIZE=%ld",
d2151 1
a2151 1
		expand("\201g", buf, sizeof buf, e);
d2309 1
a2309 1
	**  in bufp is sizeof optbuf
d2333 1
a2333 1
			(void) sm_strlcat(bufp, " NOTIFY=", sizeof optbuf);
d2336 1
a2336 1
				(void) sm_strlcat(bufp, "SUCCESS", sizeof optbuf);
d2343 2
a2344 2
						       sizeof optbuf);
				(void) sm_strlcat(bufp, "FAILURE", sizeof optbuf);
d2351 2
a2352 2
						       sizeof optbuf);
				(void) sm_strlcat(bufp, "DELAY", sizeof optbuf);
d2356 1
a2356 1
				(void) sm_strlcat(bufp, "NEVER", sizeof optbuf);
d3135 1
a3135 1
						   sizeof SmtpReplyBuffer,
d3255 1
a3255 1
		(void) sm_strlcpy(SmtpError, SmtpReplyBuffer, sizeof SmtpError);
d3298 1
a3298 1
	(void) sm_vsnprintf(SmtpMsgBuffer, sizeof SmtpMsgBuffer, f, ap);
@


1.19
log
@update to sendmail 8.13.4
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2005 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: usersmtp.c,v 8.463 2005/03/16 00:36:09 ca Exp $")
a20 1
static void	datatimeout __P((int));
a35 1
#define REPLYTYPE(r)	((r) / 100)		/* first digit of reply code */
a2491 3
static jmp_buf	CtxDataTimeout;
static SM_EVENT	*volatile DataTimeout = NULL;

d2503 1
a2503 1
	time_t timeout;
a2626 21
	if (setjmp(CtxDataTimeout) != 0)
	{
		mci->mci_errno = errno;
		mci->mci_state = MCIS_ERROR;
		mci_setstat(mci, EX_TEMPFAIL, "4.4.2", NULL);

		/*
		**  If putbody() couldn't finish due to a timeout,
		**  rewind it here in the timeout handler.  See
		**  comments at the end of putbody() for reasoning.
		*/

		if (e->e_dfp != NULL)
			(void) bfrewind(e->e_dfp);

		errno = mci->mci_errno;
		syserr("451 4.4.1 timeout writing message to %s", CurHostName);
		smtpquit(m, mci, e);
		return EX_TEMPFAIL;
	}

d2630 1
a2630 1
		timeout = 1;
d2633 2
a2634 3
		timeout = DATA_PROGRESS_TIMEOUT;

	DataTimeout = sm_setevent(timeout, datatimeout, 0);
d2641 2
a2642 1
	(*e->e_puthdr)(mci, e->e_header, e, M87F_OUTER);
d2650 2
a2651 1
	(*e->e_putbody)(mci, e, NULL);
a2656 2
	if (DataTimeout != NULL)
		sm_clrevent(DataTimeout);
d2696 3
a2698 1
	(void) sm_io_fprintf(mci->mci_out, SM_TIME_DEFAULT, ".%s", m->m_eol);
a2748 1
}
d2750 4
a2753 5
static void
datatimeout(ignore)
	int ignore;
{
	int save_errno = errno;
d2756 3
a2758 3
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
d2761 2
a2762 3
	if (DataProgress)
	{
		time_t timeout;
d2764 5
a2768 8
		/* check back again later */
		if (tTd(18, 101))
		{
			/* simulate a DATA timeout */
			timeout = 1;
		}
		else
			timeout = DATA_PROGRESS_TIMEOUT;
a2769 18
		/* reset the timeout */
		DataTimeout = sm_sigsafe_setevent(timeout, datatimeout, 0);
		DataProgress = false;
	}
	else
	{
		/* event is done */
		DataTimeout = NULL;
	}

	/* if no progress was made or problem resetting event, die now */
	if (DataTimeout == NULL)
	{
		errno = ETIMEDOUT;
		longjmp(CtxDataTimeout, 1);
	}
	errno = save_errno;
}
d2975 2
@


1.19.4.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@d21 1
d2494 3
d2632 21
d2656 1
a2656 1
		timeout = 10;
d2659 3
a2661 2
		timeout = DATA_PROGRESS_TIMEOUT * 1000;
	sm_io_setinfo(mci->mci_out, SM_IO_WHAT_TIMEOUT, &timeout);
d2668 1
a2668 2
	if (!(*e->e_puthdr)(mci, e->e_header, e, M87F_OUTER))
		goto writeerr;
d2676 1
a2676 2
	if (!(*e->e_putbody)(mci, e, NULL))
		goto writeerr;
d2682 2
d2723 1
a2723 3
	if (sm_io_fprintf(mci->mci_out, SM_TIME_DEFAULT, ".%s", m->m_eol) ==
								SM_IO_EOF)
		goto writeerr;
d2774 1
d2776 5
a2780 4
  writeerr:
	mci->mci_errno = errno;
	mci->mci_state = MCIS_ERROR;
	mci_setstat(mci, EX_TEMPFAIL, "4.4.2", NULL);
d2783 3
a2785 3
	**  If putbody() couldn't finish due to a timeout,
	**  rewind it here in the timeout handler.  See
	**  comments at the end of putbody() for reasoning.
d2788 22
a2809 2
	if (e->e_dfp != NULL)
		(void) bfrewind(e->e_dfp);
d2811 7
a2817 4
	errno = mci->mci_errno;
	syserr("451 4.4.1 timeout writing message to %s", CurHostName);
	smtpquit(m, mci, e);
	return EX_TEMPFAIL;
a2818 1

@


1.19.2.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@d21 1
d2494 3
d2632 21
d2656 1
a2656 1
		timeout = 10;
d2659 3
a2661 2
		timeout = DATA_PROGRESS_TIMEOUT * 1000;
	sm_io_setinfo(mci->mci_out, SM_IO_WHAT_TIMEOUT, &timeout);
d2668 1
a2668 2
	if (!(*e->e_puthdr)(mci, e->e_header, e, M87F_OUTER))
		goto writeerr;
d2676 1
a2676 2
	if (!(*e->e_putbody)(mci, e, NULL))
		goto writeerr;
d2682 2
d2723 1
a2723 3
	if (sm_io_fprintf(mci->mci_out, SM_TIME_DEFAULT, ".%s", m->m_eol) ==
								SM_IO_EOF)
		goto writeerr;
d2774 1
d2776 5
a2780 4
  writeerr:
	mci->mci_errno = errno;
	mci->mci_state = MCIS_ERROR;
	mci_setstat(mci, EX_TEMPFAIL, "4.4.2", NULL);
d2783 3
a2785 3
	**  If putbody() couldn't finish due to a timeout,
	**  rewind it here in the timeout handler.  See
	**  comments at the end of putbody() for reasoning.
d2788 22
a2809 2
	if (e->e_dfp != NULL)
		(void) bfrewind(e->e_dfp);
d2811 7
a2817 4
	errno = mci->mci_errno;
	syserr("451 4.4.1 timeout writing message to %s", CurHostName);
	smtpquit(m, mci, e);
	return EX_TEMPFAIL;
a2818 1

@


1.18
log
@update to sendmail 8.13.3
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: usersmtp.c,v 8.460 2005/01/11 00:24:19 ca Exp $")
d92 1
a1598 2
#  if STARTTLS
#endif /* STARTTLS */
d2901 2
d2904 1
d3138 1
a3138 1
				mci->mci_state = MCIS_CLOSED;
d3163 1
a3163 1
				mci->mci_state = MCIS_CLOSED;
@


1.18.2.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@d21 1
d2495 3
d2633 21
d2657 1
a2657 1
		timeout = 10;
d2660 3
a2662 2
		timeout = DATA_PROGRESS_TIMEOUT * 1000;
	sm_io_setinfo(mci->mci_out, SM_IO_WHAT_TIMEOUT, &timeout);
d2669 1
a2669 2
	if (!(*e->e_puthdr)(mci, e->e_header, e, M87F_OUTER))
		goto writeerr;
d2677 1
a2677 2
	if (!(*e->e_putbody)(mci, e, NULL))
		goto writeerr;
d2683 2
d2724 1
a2724 3
	if (sm_io_fprintf(mci->mci_out, SM_TIME_DEFAULT, ".%s", m->m_eol) ==
								SM_IO_EOF)
		goto writeerr;
d2775 1
d2777 5
a2781 4
  writeerr:
	mci->mci_errno = errno;
	mci->mci_state = MCIS_ERROR;
	mci_setstat(mci, EX_TEMPFAIL, "4.4.2", NULL);
d2784 3
a2786 3
	**  If putbody() couldn't finish due to a timeout,
	**  rewind it here in the timeout handler.  See
	**  comments at the end of putbody() for reasoning.
d2789 22
a2810 2
	if (e->e_dfp != NULL)
		(void) bfrewind(e->e_dfp);
d2812 7
a2818 4
	errno = mci->mci_errno;
	syserr("451 4.4.1 timeout writing message to %s", CurHostName);
	smtpquit(m, mci, e);
	return EX_TEMPFAIL;
a2819 1

@


1.17
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: usersmtp.c,v 8.455 2004/08/12 23:23:19 gshapiro Exp $")
d2562 14
d2740 2
a2741 1
	mci->mci_state = MCIS_OPEN;
d3126 1
a3126 1
		/* don't try to read from a non-existant fd */
d3136 1
d3160 2
d3163 1
@


1.16
log
@Update to sendmail.8.13.0
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: usersmtp.c,v 8.451 2004/03/01 21:50:36 ca Exp $")
d21 1
a21 2
extern void	markfailure __P((ENVELOPE *, ADDRESS *, MCI *, int, bool));
static void	datatimeout __P((void));
d2763 2
a2764 1
datatimeout()
d3000 3
a3002 1
	**  mci_state as MCIS_SSD (set in reply()).
d3005 1
a3005 1
	if (mci->mci_state != MCIS_SSD)
d3068 1
a3068 1
	void (*pfunc)();
@


1.15
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: usersmtp.c,v 8.437.2.10 2003/05/05 23:51:47 ca Exp $")
d85 1
a85 1
		mci_dump(mci, false);
d141 2
a142 1
	r = reply(m, mci, e, TimeOuts.to_initial, esmtp_check, NULL);
d188 1
a188 1
		  helo_options, NULL);
d230 1
d233 1
a233 1
	if (false
a236 4
# if _FFR_MSP_VERBOSE
	    /* If we're running as MSP, "propagate" -v flag if possible. */
	    || (UseMSP && Verbose && bitset(MCIF_VERB, mci->mci_flags))
# endif /* _FFR_MSP_VERBOSE */
d241 2
a242 1
		r = reply(m, mci, e, TimeOuts.to_miscshort, NULL, &enhsc);
a1745 1
#if _FFR_SASL_INITIAL_WORKAROUND
a1749 1
#endif /* _FFR_SASL_INITIAL_WORKAROUND */
d1782 2
a1783 1
	smtpresult = reply(m, mci, e, TimeOuts.to_auth, getsasldata, NULL);
d1827 1
a1827 1
					   getsasldata, NULL);
d1849 1
a1849 1
				   getsasldata, NULL);
d2169 1
a2169 1
	r = reply(m, mci, e, TimeOuts.to_mail, NULL, &enhsc);
d2421 1
a2421 1
	r = reply(m, mci, e, TimeOuts.to_rcpt, NULL, &enhsc);
d2571 1
a2571 1
	r = reply(m, mci, e, TimeOuts.to_datainit, NULL, &enhsc);
d2724 1
a2724 1
	r = reply(m, mci, e, TimeOuts.to_datafinal, NULL, &enhsc);
d2831 1
a2831 1
	r = reply(m, mci, e, TimeOuts.to_datafinal, NULL, &enhsc);
d2914 2
a2915 1
		(void) reply(m, mci, e, TimeOuts.to_quit, NULL, NULL);
d2990 1
a2990 1
	r = reply(m, mci, e, TimeOuts.to_rset, NULL, NULL);
d3035 1
a3035 1
	r = reply(m, mci, e, TimeOuts.to_miscshort, NULL, NULL);
d3051 1
d3061 1
a3061 1
reply(m, mci, e, timeout, pfunc, enhstat)
d3068 1
d3211 11
a3221 3
				(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
						     ">>> %s\n", SmtpMsgBuffer);
			SmtpMsgBuffer[0] = '\0';
@


1.14
log
@Update to sendmail 8.12.9; fixes a buffer overflow in address parsing
due to a char to int conversion problem which is potentially remotely
exploitable.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: usersmtp.c,v 8.437.2.9 2003/03/15 23:57:52 gshapiro Exp $")
d1091 1
a1091 1
	(void) sm_strlcpy((*psecret)->data, authpass, len + 1);
@


1.13
log
@update to sendmail 8.12.7
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: usersmtp.c,v 8.437.2.8 2002/12/12 17:40:07 ca Exp $")
d2826 1
d2848 2
a2849 2
	    (r = isenhsc(SmtpReplyBuffer + 4, ' ')) > 0)
		r += 5;
d2851 3
a2853 4
		r = 4;
	e->e_statmsg = sm_rpool_strdup_x(e->e_rpool, &SmtpReplyBuffer[r]);
	mci_setstat(mci, xstat, ENHSCN(enhsc, smtptodsn(r)),
		    SmtpReplyBuffer);
@


1.12
log
@update to sendmail-8.12.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: usersmtp.c,v 8.437.2.5 2002/08/16 16:48:11 ca Exp $")
d130 1
a225 1
#if !_FFR_DEPRECATE_MAILER_FLAG_I
d231 9
a239 1
	if (bitnset(M_INTERNAL, m->m_flags))
a246 1
#endif /* !_FFR_DEPRECATE_MAILER_FLAG_I */
d463 2
d2273 1
a2273 1
	       sm_io_getinfo(mci->mci_in, SM_IO_IS_READABLE, NULL))
d2680 1
a2680 1
	if (sm_io_getinfo(mci->mci_in, SM_IO_IS_READABLE, NULL))
@


1.11
log
@Update to sendmail-8.12.4
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: usersmtp.c,v 8.437 2002/05/24 18:53:48 gshapiro Exp $")
d921 1
a921 1
  			r = sasl_decode64(pvp[i + 1] + 3,
d925 1
a925 1
			r = sasl_decode64(pvp[i + 1] + 3,
d928 1
a928 1
			if (r != SASL_OK)
d941 1
d1575 2
a1576 2
  	saslresult = sasl_client_new(bitnset(M_LMTP, m->m_flags) ? "lmtp"
  								 : "smtp",
d1737 8
a1744 1
	if (out == NULL)
@


1.10
log
@update to sendmail 8.12.3
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: usersmtp.c,v 8.431 2002/04/03 00:23:25 gshapiro Exp $")
d98 1
a98 1
	switch (mci->mci_state)
d606 1
d608 1
d624 12
d637 8
d646 1
a646 1
	result = sasl_decode64(line, len, out, (unsigned int *)&len);
d673 1
d920 5
d927 1
d935 1
a935 1
			sm_syslog(LOG_WARNING, NOQID, "getauth %s=%s",
d981 105
d1150 1
a1150 1
			sm_syslog(LOG_WARNING, NOQID, "AUTH username '%s'",
d1221 1
a1221 1
			sm_syslog(LOG_WARNING, NOQID, "AUTH authid '%s'",
d1276 2
d1300 3
d1304 1
d1306 3
d1310 1
d1352 1
a1352 1
	p = file;
d1548 5
a1553 1
	sasl_interact_t *client_interact = NULL;
d1555 1
d1557 1
d1561 1
a1561 1
#if NETINET
d1563 1
a1563 1
#endif /* NETINET */
d1573 6
d1582 1
d1603 74
d1680 1
a1680 1
#if STARTTLS
d1687 1
a1687 1
#endif /* STARTTLS */
d1692 1
a1692 1
#if NETINET
d1713 1
a1713 1
#endif /* NETINET */
d1719 2
a1720 1
				       (const char **)&mechusing);
d1736 16
a1751 1
	if (outlen > 0)
d1763 1
a1763 4
	else
	{
		smtpmessage("AUTH %s", m, mci, mechusing);
	}
d1765 1
d1829 1
d1831 1
d1910 8
a1917 4
	callbacks[CB_PASS_IDX].context = (void *)&mci->mci_sai;
	callbacks[CB_USER_IDX].context = (void *)&mci->mci_sai;
	callbacks[CB_AUTHNAME_IDX].context = (void *)&mci->mci_sai;
	callbacks[CB_GETREALM_IDX].context = (void *)&mci->mci_sai;
d1919 1
a1919 1
	callbacks[CB_SAFESASL_IDX].context = (void *)&mci->mci_sai;
@


1.9
log
@update to sendmail-8.12.2
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: usersmtp.c,v 8.428 2002/01/08 00:56:23 ca Exp $")
d76 1
d97 1
d120 1
a120 1
		syserr("451 4.4.0 smtpinit: state CLOSED");
a1907 1
		smtpquit(m, mci, e);
d1912 1
a1912 4
		/* service shutting down */
		mci_setstat(mci, EX_TEMPFAIL, ENHSCN(enhsc, "4.5.0"),
			    SmtpReplyBuffer);
		smtpquit(m, mci, e);
d2308 2
a2309 1
		smtpquit(m, mci, e);
a2459 2
	{
		smtpquit(m, mci, e);
a2460 1
	}
a2565 2
	{
		smtpquit(m, mci, e);
a2566 1
	}
d2620 3
a2644 2
		int origstate = mci->mci_state;

d2650 1
a2650 2
		if (mci->mci_state == MCIS_CLOSED ||
		    origstate == MCIS_CLOSED)
d2725 10
a2734 11
		mci->mci_state = MCIS_ERROR;
	else
	{
		/*
		**  Any response is deemed to be acceptable.
		**  The standard does not state the proper action
		**  to take when a value other than 250 is received.
		**
		**  However, if 421 is returned for the RSET, leave
		**  mci_state as MCIS_SSD (set in reply()).
		*/
d2736 2
a2737 5
		if (mci->mci_state != MCIS_SSD)
			mci->mci_state = MCIS_OPEN;
		return;
	}
	smtpquit(m, mci, e);
d2769 1
a2769 1
	if (r < 0 || REPLYTYPE(r) != 2)
d2845 9
d2871 4
d2895 1
a2895 4

			/* errors on QUIT should not be persistent */
			if (strncmp(SmtpMsgBuffer, "QUIT", 4) != 0)
				mci_setstat(mci, EX_TEMPFAIL, "4.4.2", MsgBuf);
d2995 2
a2996 1
	if (r == SMTPCLOSING && mci->mci_state != MCIS_SSD)
@


1.8
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: usersmtp.c,v 8.423 2001/09/24 14:16:54 ca Exp $")
a247 2
	if (mci->mci_errno == 0)
		mci->mci_errno = errno;
a253 3
	if (mci->mci_errno == 0)
		mci->mci_errno = errno;

a261 1
	mci->mci_errno = errno;
d1026 6
d1034 1
a1039 1
				l = strlen(h) + strlen(realm) + 2;
d1041 2
a1042 3
				/* should use rpool, but how to get it? */
				authid = sm_sasl_malloc(l);
				if (authid != NULL)
d1044 2
a1045 3
					(void) sm_snprintf(authid, l, "%s@@%s",
							   h, realm);
					(*sai)[SASL_ID_REALM] = authid;
d1049 16
a1064 2
					authid = h;
					(*sai)[SASL_ID_REALM] = NULL;
d1670 1
a1670 2
	if ((mci->mci_sai)[SASL_DEFREALM] == NULL ||
	    *(mci->mci_sai)[SASL_DEFREALM] == '\0')
d1735 12
a1904 1
		mci->mci_errno = errno;
d2022 12
d2141 1
d2144 12
d2158 1
d2166 1
d2249 12
d2311 1
d2716 12
d2851 9
d2876 5
d2886 1
@


1.7
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: usersmtp.c,v 8.418 2001/09/04 22:43:06 ca Exp $")
d50 1
a50 1
/*
d272 1
a272 1
/*
d313 1
a313 1
/*
d383 1
a383 1
/*
d530 1
a530 1
/*
d581 1
a581 1
/*
d657 1
a657 1
/*
d726 1
a726 1
				       (void *) fd, SM_IO_RDONLY, NULL);
d878 4
d883 1
a883 4
		if (l > 3 && pvp[i + 1][l - 1] == '"')
			pvp[i + 1][l - 1] = '\0';
		else
			goto fail;
d956 1
a956 1
/*
d1090 1
a1090 1
/*
d1128 1
a1128 1
/*
d1165 1
a1170 1
#if SASL <= 10515
d1257 1
a1257 1
/*
d1301 1
a1301 1
/*
d1365 1
a1365 1
/*
d1577 1
a1577 1
/*
d1698 1
a1698 1
/*
d1950 1
a1950 1
/*
d2084 1
a2084 1
/*
d2171 1
a2171 1
/*
d2481 1
a2481 1
/*
d2540 1
a2540 1
/*
d2623 1
a2623 1
/*
d2676 1
a2676 1
/*
d2710 1
a2710 1
/*
d2916 1
a2916 1
/*
@


1.6
log
@update to sendmail 8.11.5
@
text
@d16 1
a16 7
#ifndef lint
# if SMTP
static char id[] = "@@(#)$Sendmail: usersmtp.c,v 8.245.4.34 2001/06/26 21:55:23 gshapiro Exp $ (with SMTP)";
# else /* SMTP */
static char id[] = "@@(#)$Sendmail: usersmtp.c,v 8.245.4.34 2001/06/26 21:55:23 gshapiro Exp $ (without SMTP)";
# endif /* SMTP */
#endif /* ! lint */
a19 2
#if SMTP

d21 1
d25 6
d38 5
a42 3
# define REPLYTYPE(r)	((r) / 100)		/* first digit of reply code */
# define REPLYCLASS(r)	(((r) / 10) % 10)	/* second digit of reply code */
# define SMTPCLOSING	421			/* "Service Shutting Down" */
d44 2
a45 1
#define ENHSCN(e, d)	(e) == NULL ? (d) : newstr(e)
d83 2
a84 2
		dprintf("smtpinit ");
		mci_dump(mci, FALSE);
d95 1
a95 1
	SmtpNeedIntro = TRUE;
d98 3
a100 1
	  case MCIS_ACTIVE:
d136 1
a136 1
	sm_setproctitle(TRUE, e, "%s %s: %s",
d157 3
d165 2
a166 1
	else if (bitset(MCIF_ESMTP, mci->mci_flags))
d175 3
d179 1
a179 1
	sm_setproctitle(TRUE, e, "%s %s: %s", qid_printname(e),
d181 4
a184 1
	r = reply(m, mci, e, TimeOuts.to_helo, helo_options, NULL);
d212 1
a212 1
	    strcasecmp(&SmtpReplyBuffer[4], MyHostName) == 0)
d223 1
d237 1
d258 1
d296 9
d308 5
a312 1
# if SASL
d318 1
d325 1
a325 1
str_union(s1, s2)
d327 1
d339 8
a346 2
	res = (char *)xalloc(rl + 2);
	(void) strlcpy(res, s1, rl);
d381 2
a382 1
# endif /* SASL */
d391 1
a391 1
**		e -- the envelope.
d406 3
d412 1
a412 3
# if SASL
		if (mci->mci_saslcap != NULL)
			sm_free(mci->mci_saslcap);
d414 17
a430 1
# endif /* SASL */
d433 1
d435 1
a435 1
	if (strlen(line) < (SIZE_T) 5)
d441 1
a441 1
	if (strcasecmp(line, "size") == 0)
d447 1
a447 1
	else if (strcasecmp(line, "8bitmime") == 0)
d452 1
a452 1
	else if (strcasecmp(line, "expn") == 0)
d454 1
a454 1
	else if (strcasecmp(line, "dsn") == 0)
d456 1
a456 1
	else if (strcasecmp(line, "enhancedstatuscodes") == 0)
d458 4
a461 2
# if STARTTLS
	else if (strcasecmp(line, "starttls") == 0)
d463 9
a471 3
# endif /* STARTTLS */
# if SASL
	else if (strcasecmp(line, "auth") == 0)
a476 2
				char *h;

d478 1
a478 1
				**  create the union with previous auth
d482 3
a484 4
				h = mci->mci_saslcap;
				mci->mci_saslcap = str_union(h, p);
				if (h != mci->mci_saslcap)
					sm_free(h);
d492 8
a499 3
				mci->mci_saslcap = (char *)xalloc(l);
				(void) strlcpy(mci->mci_saslcap, p, l);
				mci->mci_flags |= MCIF_AUTH;
d503 1
a503 1
# endif /* SASL */
d505 24
a528 1
# if SASL
d531 51
d585 1
a585 1
**	from the server
d592 1
a592 1
**		e -- the envelope.
d598 3
a600 1
void
d609 1
a610 1
	int result;
d613 2
a614 1
	if ((strlen(line) <= 4) ||
d616 2
a617 2
	    (line[1] != '3') ||
	    (line[2] != '4'))
d619 1
a619 1
		mci->mci_sasl_string = NULL;
d625 1
a625 1
	len = strlen(line);
d627 2
a628 2
	out = xalloc(len + 1);
	result = sasl_decode64(line, len, out, (u_int *)&len);
d634 7
d645 1
a645 1
			sm_free(mci->mci_sasl_string);
d651 1
a651 1
	/* XXX this is probably leaked */
a654 1
	sm_free(out);
a656 1

d658 1
a658 1
**  READAUTH -- read auth value from a file
a660 1
**		l -- line to define.
d663 2
d667 3
a669 6
**		line from file
**
**	Side Effects:
**		overwrites local static buffer. The caller should copy
**		the result.
**
a671 7
/* lines in authinfo file */
# define SASL_USER	1
# define SASL_AUTHID	2
# define SASL_PASSWORD	3
# define SASL_DEFREALM	4
# define SASL_MECH	5

a673 1
	"",
d675 1
a675 1
	"authorization id",
d678 1
a678 1
	"mechanism"
d680 2
a681 4

static char *
readauth(l, filename, safe)
	int l;
d684 2
d687 1
a687 1
	FILE *f;
d691 2
a692 1
	static char buf[MAXLINE];
d695 2
a696 1
		return "";
d704 1
d725 2
a726 1
			f = fdopen(fd, "r");
d732 6
a737 2
		sff = SFF_REGONLY | SFF_SAFEDIRPATH | SFF_NOWLINK
		      | SFF_NOGWFILES | SFF_NOWWFILES | SFF_NORFILES;
d740 1
d747 1
d758 5
a762 2
		syserr("readauth: cannot open %s", filename);
		return "";
d766 2
a767 1
	while (lc < l && fgets(buf, sizeof buf, f) != NULL)
d770 4
d775 1
d778 1
a778 1
	(void) fclose(f);
d781 1
a781 1
	if (lc < l)
d783 8
a790 16
		if (LogLevel >= 9)
			sm_syslog(LOG_WARNING, NOQID, "SASL: error: can't read %s from %s",
			  sasl_info_name[l], filename);
		return "";
	}
	lc = strlen(buf) - 1;
	if (lc >= 0)
		buf[lc] = '\0';
	if (tTd(95, 6))
		dprintf("readauth(%s, %d) = '%s'\n", filename, l, buf);
	return buf;
}

#  ifndef __attribute__
#   define __attribute__(x)
#  endif /* ! __attribute__ */
d792 19
a810 3
static int getsimple	__P((void *, int, const char **, unsigned *));
static int getsecret	__P((sasl_conn_t *, void *, int, sasl_secret_t **));
static int saslgetrealm	__P((void *, int, const char **, const char **));
d812 5
a816 1
static sasl_callback_t callbacks[] =
d818 65
a882 11
	{	SASL_CB_GETREALM,	&saslgetrealm,	NULL	},
# define CB_GETREALM_IDX	0
	{	SASL_CB_PASS,		&getsecret,	NULL	},
# define CB_PASS_IDX	1
	{	SASL_CB_USER,		&getsimple,	NULL	},
# define CB_USER_IDX	2
	{	SASL_CB_AUTHNAME,	&getsimple,	NULL	},
# define CB_AUTHNAME_IDX	3
	{	SASL_CB_VERIFYFILE,	&safesaslfile,	NULL	},
	{	SASL_CB_LIST_END,	NULL,		NULL	}
};
d884 71
d959 1
a959 1
**		context -- unused
d970 1
a970 1
	void *context __attribute__((unused));
d975 7
a981 7
	char *h;
#  if SASL > 10509
	int addrealm;
	static int addedrealm = FALSE;
#  endif /* SASL > 10509 */
	static char *user = NULL;
	static char *authid = NULL;
d983 1
a983 1
	if (result == NULL)
d985 18
d1007 8
a1014 4
		if (user == NULL)
		{
			h = readauth(SASL_USER, SASLInfo, TRUE);
			user = newstr(h);
d1016 2
a1017 1
		*result = user;
d1019 2
a1020 1
			dprintf("AUTH username '%s'\n", *result);
d1022 1
a1022 1
			*len = user ? strlen(user) : 0;
d1026 2
a1027 1
#  if SASL > 10509
d1029 3
a1031 3
		addrealm = context != NULL &&
			   strcasecmp(context, "CRAM-MD5") == 0;
		if (addedrealm != addrealm && authid != NULL)
d1033 1
a1033 20
#  if SASL > 10522
			/*
			**  digest-md5 prior to 1.5.23 doesn't copy the
			**  value it gets from the callback, but free()s
			**  it later on
			**  workaround: don't free() it here
			**  this can cause a memory leak!
			*/

			sm_free(authid);
#  endif /* SASL > 10522 */
			authid = NULL;
			addedrealm = addrealm;
		}
#  endif /* SASL > 10509 */
		if (authid == NULL)
		{
			h = readauth(SASL_AUTHID, SASLInfo, TRUE);
#  if SASL > 10509
			if (addrealm && strchr(h, '@@') == NULL)
a1034 1
				size_t l;
d1037 1
a1037 1
				realm = callbacks[CB_GETREALM_IDX].context;
d1039 14
a1052 2
				authid = xalloc(l);
				snprintf(authid, l, "%s@@%s", h, realm);
d1055 13
a1067 2
#  endif /* SASL > 10509 */
				authid = newstr(h);
d1069 2
a1070 1
		*result = authid;
d1072 2
a1073 1
			dprintf("AUTH authid '%s'\n", *result);
a1088 1

d1094 1
a1094 1
**		context -- unused
d1105 1
a1105 1
	void *context __attribute__((unused));
a1108 1
	char *h;
d1110 2
a1111 1
	static char *authpass = NULL;
d1116 2
a1117 5
	if (authpass == NULL)
	{
		h = readauth(SASL_PASSWORD, SASLInfo, TRUE);
		authpass = newstr(h);
	}
d1119 6
a1124 3
	*psecret = (sasl_secret_t *) xalloc(sizeof(sasl_secret_t) + len + 1);
	(void) strlcpy((*psecret)->data, authpass, len + 1);
	(*psecret)->len = len;
a1126 1

d1136 3
a1138 3
**		SASL_OK: file can be used
**		SASL_CONTINUE: don't use file
**		SASL_FAIL: failure (not used here)
d1141 1
d1143 1
a1143 1
# if SASL > 10515
d1145 1
a1145 1
# else /* SASL > 10515 */
d1147 1
a1147 1
# endif /* SASL > 10515 */
d1150 1
a1150 1
# if SASL > 10515
d1152 1
a1152 1
# endif /* SASL > 10515 */
d1156 3
d1163 1
a1163 2

	sff = SFF_SAFEDIRPATH|SFF_NOWLINK|SFF_NOGWFILES|SFF_NOWWFILES|SFF_ROOTOK;
d1169 1
a1169 1
# if SASL <= 10515
d1171 10
a1180 9
	r = strlen(p);
	if ((r <= 3 || strncmp(p, "lib", 3) != 0) &&
	    (r <= 5 || strncmp(p + r - 5, ".conf", 5) != 0)
#  if _FFR_UNSAFE_SASL
	    && !bitnset(DBS_GROUPREADABLESASLFILE, DontBlameSendmail)
#  endif /* _FFR_UNSAFE_SASL */
	   )
		sff |= SFF_NORFILES;
# else /* SASL > 10515 */
d1184 1
a1184 2
#  if _FFR_UNSAFE_SASL
		if (bitnset(DBS_GROUPREADABLESASLFILE, DontBlameSendmail))
a1186 1
#  endif /* _FFR_UNSAFE_SASL */
d1188 2
d1191 1
a1191 1
# endif /* SASL <= 10515 */
d1197 1
a1197 1
	if (LogLevel >= 11 || (r != ENOENT && LogLevel >= 9))
d1199 1
a1199 1
			  p, errstring(r));
a1209 1
**			here: realm to return
d1217 1
d1225 8
d1234 5
a1238 5
		sm_syslog(LOG_INFO, NOQID, "saslgetrealm: realm %s available realms %s",
			  context == NULL ? "<No Context>" : (char *) context,
			  (availrealms == NULL || *availrealms == NULL) ? "<No Realms>" : *availrealms);
	if (context == NULL)
		return SASL_FAIL;
d1240 1
a1240 1
	/* check whether context is in list? */
d1248 2
a1249 2
					  "saslgetrealm: realm %s not in list %s",
					  context, *availrealms);
d1253 1
a1253 1
	*result = (char *)context;
d1290 1
a1290 1
		if (strncasecmp(s, item, len) == 0 &&
d1306 1
d1312 2
a1313 2
char *
removemech(rem, list)
d1316 1
d1339 1
a1339 1
	if (len == 0)
d1341 1
a1341 1
		ret = xalloc(1);  /* XXX leaked */
d1345 1
a1345 1
	ret = xalloc(len);  /* XXX leaked */
a1364 61
**  INTERSECT -- create the intersection between two lists
**
**	Parameters:
**		s1, s2 -- lists of items (separated by single blanks).
**
**	Returns:
**		the intersection of both lists.
*/

char *
intersect(s1, s2)
	char *s1, *s2;
{
	char *hr, *h1, *h, *res;
	int l1, l2, rl;

	if (s1 == NULL || s2 == NULL)	/* NULL string(s) -> NULL result */
		return NULL;
	l1 = strlen(s1);
	l2 = strlen(s2);
	rl = min(l1, l2);
	res = (char *)xalloc(rl + 1);
	*res = '\0';
	if (rl == 0)	/* at least one string empty? */
		return res;
	hr = res;
	h1 = s1;
	h = s1;

	/* walk through s1 */
	while (h != NULL && *h1 != '\0')
	{
		/* is there something after the current word? */
		if ((h = strchr(h1, ' ')) != NULL)
			*h = '\0';
		l1 = strlen(h1);

		/* does the current word appear in s2 ? */
		if (iteminlist(h1, s2, " ") != NULL)
		{
			/* add a blank if not first item */
			if (hr != res)
				*hr++ = ' ';

			/* copy the item */
			memcpy(hr, h1, l1);

			/* advance pointer in result list */
			hr += l1;
			*hr = '\0';
		}
		if (h != NULL)
		{
			/* there are more items */
			*h = ' ';
			h1 = h + 1;
		}
	}
	return res;
}
/*
d1371 1
a1371 1
**		mechused - filled in with mechanism used
d1374 5
a1378 1
**		EX_OK/EX_TEMPFAIL
d1381 2
a1382 2
int
attemptauth(m, mci, e, mechused)
d1386 1
a1386 1
	char **mechused;
d1393 1
a1393 1
	static char *mechusing;
d1396 1
a1396 1
# if NETINET
d1398 4
a1401 1
# endif /* NETINET */
d1403 1
a1403 1
	*mechused = NULL;
a1404 1
	{
a1406 4
		/* just in case, sasl_dispose() should take care of it */
		mci->mci_conn = NULL;
	}

d1411 2
d1416 1
a1416 1
#  if SFIO
d1418 2
a1419 1
	/* ssp.min_ssf = 0; is default due to memset() */
d1421 1
a1421 1
		ssp.max_ssf = INT_MAX;
d1423 1
a1423 1
#   if 0
d1425 1
a1425 1
#   endif /* 0 */
a1426 1
#  endif /* SFIO */
d1434 2
a1435 2
# if _FFR_EXT_MECH
	out = macvalue(macid("{cert_subject}", NULL), e);
d1438 1
a1438 1
	out = macvalue(macid("{cipher_bits}", NULL), e);
d1441 1
a1441 1
# endif /* _FFR_EXT_MECH */
d1446 1
a1446 1
# if NETINET
d1458 2
a1459 1
		if (getsockname(fileno(mci->mci_out),
d1467 1
a1467 1
# endif /* NETINET */
a1473 1
	callbacks[CB_AUTHNAME_IDX].context = mechusing;
a1476 1
#  if SFIO
d1480 1
a1480 1
				  "available AUTH mechanisms do not fulfill requirements");
a1481 1
#  endif /* SFIO */
d1485 2
a1486 1
	*mechused = mechusing;
d1505 1
d1508 1
a1508 2
	smtpresult = reply(m, mci, e, TimeOuts.to_datafinal, getsasldata, NULL);
	/* which timeout? XXX */
d1515 2
a1516 8
			define(macid("{auth_type}", NULL),
			       newstr(mechusing), e);
#  if !SFIO
			if (LogLevel > 9)
				sm_syslog(LOG_INFO, NOQID,
					  "SASL: outgoing connection to %.64s: mech=%.16s",
					  mci->mci_host, mechusing);
#  endif /* !SFIO */
d1521 6
a1526 1
		if (smtpresult != 334)
d1528 1
d1539 1
a1539 1
				dprintf("AUTH FAIL: %s (%d)\n",
d1543 1
a1543 1
			/* fail deliberately, see RFC 2254 4. */
d1551 1
a1551 1
			smtpresult = reply(m, mci, e, TimeOuts.to_datafinal,
d1553 1
a1553 1
			return EX_TEMPFAIL;
d1569 1
d1571 1
a1571 1
		smtpresult = reply(m, mci, e, TimeOuts.to_datafinal,
a1572 1
		/* which timeout? XXX */
a1575 1

d1590 10
a1599 1
**		EX_OK/EX_TEMPFAIL
d1609 61
a1669 27
	char *mechused;
	char *h;
	static char *defrealm = NULL;
	static char *mechs = NULL;

	mci->mci_sasl_auth = FALSE;
	if (defrealm == NULL)
	{
		h = readauth(SASL_DEFREALM, SASLInfo, TRUE);
		if (h != NULL && *h != '\0')
			defrealm = newstr(h);
	}
	if (defrealm == NULL || *defrealm == '\0')
		defrealm = newstr(macvalue('j', CurEnv));
	callbacks[CB_GETREALM_IDX].context = defrealm;

# if _FFR_DEFAUTHINFO_MECHS
	if (mechs == NULL)
	{
		h = readauth(SASL_MECH, SASLInfo, TRUE);
		if (h != NULL && *h != '\0')
			mechs = newstr(h);
	}
# endif /* _FFR_DEFAUTHINFO_MECHS */
	if (mechs == NULL || *mechs == '\0')
		mechs = AuthMechanisms;
	mci->mci_saslcap = intersect(mechs, mci->mci_saslcap);
d1672 1
a1672 1
	result = sasl_client_init(callbacks);
d1674 1
a1674 1
		return EX_TEMPFAIL;
d1677 1
a1677 1
		result = attemptauth(m, mci, e, &mechused);
d1679 2
a1680 2
			mci->mci_sasl_auth = TRUE;
		else if (result == EX_TEMPFAIL)
d1682 3
a1684 2
			mci->mci_saslcap = removemech(mechused,
						      mci->mci_saslcap);
d1687 2
a1688 1
				return EX_TEMPFAIL;
d1690 2
a1691 2
		else	/* all others for now */
			return EX_TEMPFAIL;
d1695 1
a1695 1
# endif /* SASL */
d1715 1
a1717 1
	char *enhsc;
d1720 1
a1720 1
		dprintf("smtpmailfrom: CurHost=%s\n", CurHostName);
d1726 2
a1727 1
		snprintf(optbuf, sizeof optbuf, " SIZE=%ld", e->e_msgsize);
d1748 1
a1748 1
			snprintf(bufp, SPACELEFT(optbuf, bufp),
d1760 1
a1760 1
# if MIME8TO7
d1769 1
a1769 1
# endif /* MIME8TO7 */
d1785 1
a1785 1
			snprintf(bufp, SPACELEFT(optbuf, bufp),
d1794 1
a1794 1
			snprintf(bufp, SPACELEFT(optbuf, bufp),
d1804 1
a1804 1
# if SASL
d1806 1
a1806 1
# endif /* SASL */
d1809 1
a1809 1
		snprintf(bufp, SPACELEFT(optbuf, bufp),
d1815 28
d1847 1
a1847 1
	mci->mci_state = MCIS_ACTIVE;
d1875 1
a1875 1
	sm_setproctitle(TRUE, e, "%s %s: %s", qid_printname(e),
d1966 1
a1966 1
smtprcpt(to, m, mci, e)
d1971 2
a1973 1
	register int r;
a1975 1
	char *enhsc;
d1977 22
a1998 1
	enhsc = NULL;
d2003 1
a2003 1
	**  warning: in the following it is assumed that the free space
d2006 1
d2009 12
d2026 1
a2026 1
			bool firstone = TRUE;
d2028 1
a2028 1
			(void) strlcat(bufp, " NOTIFY=", sizeof optbuf);
d2031 2
a2032 2
				(void) strlcat(bufp, "SUCCESS", sizeof optbuf);
				firstone = FALSE;
d2037 1
a2037 1
					(void) strlcat(bufp, ",",
d2039 2
a2040 2
				(void) strlcat(bufp, "FAILURE", sizeof optbuf);
				firstone = FALSE;
d2045 1
a2045 1
					(void) strlcat(bufp, ",",
d2047 2
a2048 2
				(void) strlcat(bufp, "DELAY", sizeof optbuf);
				firstone = FALSE;
d2051 1
a2051 1
				(void) strlcat(bufp, "NEVER", sizeof optbuf);
d2059 1
a2059 1
			snprintf(bufp, SPACELEFT(optbuf, bufp),
d2066 1
d2069 1
a2069 1
	sm_setproctitle(TRUE, e, "%s %s: %s", qid_printname(e),
d2071 38
d2110 2
a2111 2
	to->q_rstatus = newstr(SmtpReplyBuffer);
	to->q_status = ENHSCN(enhsc, smtptodsn(r));
d2115 2
d2118 1
d2120 16
d2137 1
d2140 1
a2140 1
		to->q_status = ENHSCN(enhsc, "5.1.1");
d2145 1
a2145 1
		to->q_status = ENHSCN(enhsc, "5.1.6");
d2150 1
a2150 1
		to->q_status = ENHSCN(enhsc, "5.1.3");
a2179 3
**
**	Side Effects:
**		none.
d2183 1
a2183 1
static EVENT	*volatile DataTimeout = NULL;
d2186 1
a2186 1
smtpdata(m, mci, e)
d2190 2
d2204 1
a2204 1
	**	Then send the data.
d2211 30
d2242 2
a2243 1
	sm_setproctitle(TRUE, e, "%s %s: %s",
d2254 5
d2273 5
d2281 5
d2321 1
a2321 1
	DataTimeout = setevent(timeout, datatimeout, 0);
d2343 1
a2343 1
		clrevent(DataTimeout);
d2345 6
a2350 1
# if _FFR_CATCH_BROKEN_MTAS
d2352 8
a2359 2
		fd_set readfds;
		struct timeval timeout;
d2361 8
a2368 25
		FD_ZERO(&readfds);
		FD_SET(fileno(mci->mci_in), &readfds);
		timeout.tv_sec = 0;
		timeout.tv_usec = 0;
		if (select(fileno(mci->mci_in) + 1, FDSET_CAST &readfds,
			   NULL, NULL, &timeout) > 0 &&
		    FD_ISSET(fileno(mci->mci_in), &readfds))
		{
			/* terminate the message */
			fprintf(mci->mci_out, ".%s", m->m_eol);
			if (TrafficLogFile != NULL)
				fprintf(TrafficLogFile, "%05d >>> .\n",
					(int) getpid());
			if (Verbose)
				nmessage(">>> .");

			sm_syslog(LOG_CRIT, e->e_id,
				  "%.100s: SMTP DATA-1 protocol error: remote server returned response before final dot",
				  CurHostName);
			mci->mci_errno = EIO;
			mci->mci_state = MCIS_ERROR;
			mci_setstat(mci, EX_PROTOCOL, "5.5.0", NULL);
			smtpquit(m, mci, e);
			return EX_PROTOCOL;
		}
d2370 1
a2370 1
# endif /* _FFR_CATCH_BROKEN_MTAS */
d2372 1
a2372 1
	if (ferror(mci->mci_out))
d2383 1
a2383 1
	fprintf(mci->mci_out, ".%s", m->m_eol);
d2385 2
a2386 1
		fprintf(TrafficLogFile, "%05d >>> .\n", (int) getpid());
d2392 1
a2392 1
	sm_setproctitle(TRUE, e, "%s %s: %s", qid_printname(e),
d2408 2
a2411 2
	else if (REPLYTYPE(r) == 2)
		rstat = xstat = EX_OK;
a2417 2
	if (e->e_statmsg != NULL)
		sm_free(e->e_statmsg);
d2423 1
a2423 1
	e->e_statmsg = newstr(&SmtpReplyBuffer[r]);
d2425 1
a2425 1
	sm_setproctitle(TRUE, e, "%s: %s", CurHostName, mci->mci_phase);
a2437 1

d2463 2
a2464 2
		DataTimeout = sigsafe_setevent(timeout, datatimeout, 0);
		DataProgress = FALSE;
a2477 1

d2499 1
a2499 1
	int status;
d2503 1
d2511 1
d2514 2
d2517 1
a2517 3
		status = EX_PROTOCOL;
	else if (REPLYTYPE(r) == 2)
		status = EX_OK;
a2521 2
	if (e->e_statmsg != NULL)
		sm_free(e->e_statmsg);
d2527 2
a2528 2
	e->e_statmsg = newstr(&SmtpReplyBuffer[r]);
	mci_setstat(mci, status, ENHSCN(enhsc, smtptodsn(r)),
d2562 1
d2564 1
d2569 4
d2580 1
a2580 1
	SuprErrs = TRUE;
d2595 1
a2595 1
			return;
d2617 4
d2649 4
d2719 1
d2739 1
a2739 1
	bool firstline = TRUE;
d2744 9
d2754 1
a2754 1
		(void) fflush(mci->mci_out);
d2757 1
a2757 1
		dprintf("reply\n");
d2769 2
a2770 2
		if (e->e_xfp != NULL)
			(void) fflush(e->e_xfp);	/* for debugging */
d2777 1
a2777 1
			(void) fflush(mci->mci_out);
d2781 1
d2790 1
d2792 1
a2792 1
# ifdef ECONNRESET
d2794 1
a2794 1
# else /* ECONNRESET */
d2796 1
a2796 1
# endif /* ECONNRESET */
d2800 1
a2800 1
			HoldErrs = TRUE;
d2802 1
a2802 1
			       CurHostName == NULL ? "NO_HOST" : CurHostName);
a2811 1
			save_errno = errno;
d2813 1
a2813 1
# if XDEBUG
a2815 1
				int wbufleft = sizeof wbuf;
d2820 5
a2824 7
					int plen;

					snprintf(p, wbufleft, "%s... ",
						shortenstring(e->e_to, MAXSHORTSTR));
					plen = strlen(p);
					p += plen;
					wbufleft -= plen;
d2826 3
a2828 3
				snprintf(p, wbufleft, "reply(%.100s) during %s",
					 CurHostName == NULL ? "NO_HOST" : CurHostName,
					 SmtpPhase);
d2831 2
a2832 1
# endif /* XDEBUG */
a2833 1
			HoldErrs = oldholderrs;
d2836 1
a2836 1
		fixcrlf(bufp, TRUE);
d2846 5
a2850 4
				fprintf(CurEnv->e_xfp,
					"... while talking to %s:\n",
					CurHostName == NULL ? "NO_HOST" : CurHostName);
				SmtpNeedIntro = FALSE;
d2853 2
a2854 1
				fprintf(e->e_xfp, ">>> %s\n", SmtpMsgBuffer);
d2858 2
a2859 1
			fprintf(e->e_xfp, "<<< %s\n", bufp);
d2879 1
a2879 1
		firstline = FALSE;
d2902 2
a2903 3
	if (SmtpReplyBuffer[0] == '4' &&
	    (bitnset(M_LMTP, m->m_flags) || SmtpError[0] == '\0'))
		snprintf(SmtpError, sizeof SmtpError, "%s", SmtpReplyBuffer);
d2932 1
a2932 1
# ifdef __STDC__
d2934 1
a2934 1
# else /* __STDC__ */
d2940 1
a2940 1
# endif /* __STDC__ */
d2942 1
a2942 1
	VA_LOCAL_DECL
d2944 3
a2946 3
	VA_START(mci);
	(void) vsnprintf(SmtpMsgBuffer, sizeof SmtpMsgBuffer, f, ap);
	VA_END;
d2951 3
a2953 2
		fprintf(TrafficLogFile, "%05d >>> %s\n",
			(int) getpid(), SmtpMsgBuffer);
d2956 3
a2958 2
		fprintf(mci->mci_out, "%s%s", SmtpMsgBuffer,
			m == NULL ? "\r\n" : m->m_eol);
d2962 1
a2962 1
		dprintf("smtpmessage: NULL mci_out\n");
a2964 2

#endif /* SMTP */
@


1.5
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d18 1
a18 1
static char id[] = "@@(#)$Sendmail: usersmtp.c,v 8.245.4.33 2001/05/23 18:53:09 ca Exp $ (with SMTP)";
d20 1
a20 1
static char id[] = "@@(#)$Sendmail: usersmtp.c,v 8.245.4.33 2001/05/23 18:53:09 ca Exp $ (without SMTP)";
d1876 3
@


1.4
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d18 1
a18 1
static char id[] = "@@(#)$Sendmail: usersmtp.c,v 8.245.4.24 2001/02/21 00:59:09 gshapiro Exp $ (with SMTP)";
d20 1
a20 1
static char id[] = "@@(#)$Sendmail: usersmtp.c,v 8.245.4.24 2001/02/21 00:59:09 gshapiro Exp $ (without SMTP)";
d202 2
a203 1
		mci_setstat(mci, EX_CONFIG, "5.3.5", "system config error");
d307 1
a307 7
	res = (char *)malloc(rl + 2);
	if (res == NULL)
	{
		if (l1 > l2)
			return s1;
		return s2;
	}
d309 1
a309 1
	hr = res;
d372 1
a372 1
			free(mci->mci_saslcap);
d422 1
a422 1
					free(h);
d430 3
a432 8
				mci->mci_saslcap = (char *)malloc(l);

				/* XXX this may be leaked */
				if (mci->mci_saslcap != NULL)
				{
					(void) strlcpy(mci->mci_saslcap, p, l);
					mci->mci_flags |= MCIF_AUTH;
				}
d494 1
a494 1
			free(mci->mci_sasl_string);
d504 1
a504 1
	free(out);
d721 2
a722 1
			free(authid);
d798 1
a798 3
	*psecret = (sasl_secret_t *) malloc(sizeof(sasl_secret_t) + len + 1);
	if (*psecret == NULL)
		return SASL_FAIL;
d1049 1
a1049 3
	res = (char *)malloc(rl + 1);
	if (res == NULL)
		return NULL;
d1741 1
a1749 1
	register EVENT *ev;
d1756 1
d1831 1
a1831 1
	ev = setevent(timeout, datatimeout, 0);
d1834 6
d1843 1
a1843 1
		(void) sleep(1);
a1845 5
	/*
	**  Output the actual message.
	*/

	(*e->e_puthdr)(mci, e->e_header, e, M87F_OUTER);
d1852 2
a1853 1
	clrevent(ev);
d1931 1
a1931 1
		free(e->e_statmsg);
d1956 8
a1966 1
		register EVENT *ev;
d1977 2
a1979 1
		ev = setevent(timeout, datatimeout, 0);
d1983 8
a1990 1
		/* no progress, give up */
d1993 2
d2037 1
a2037 1
		free(e->e_statmsg);
@


1.4.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d18 1
a18 1
static char id[] = "@@(#)$Sendmail: usersmtp.c,v 8.245.4.33 2001/05/23 18:53:09 ca Exp $ (with SMTP)";
d20 1
a20 1
static char id[] = "@@(#)$Sendmail: usersmtp.c,v 8.245.4.33 2001/05/23 18:53:09 ca Exp $ (without SMTP)";
d202 1
a202 2
		mci_setstat(mci, EX_CONFIG, "5.3.5",
			    "553 5.3.5 system config error");
d306 7
a312 1
	res = (char *)xalloc(rl + 2);
d314 1
a314 1
	hr = res + l1;
d377 1
a377 1
			sm_free(mci->mci_saslcap);
d427 1
a427 1
					sm_free(h);
d435 8
a442 3
				mci->mci_saslcap = (char *)xalloc(l);
				(void) strlcpy(mci->mci_saslcap, p, l);
				mci->mci_flags |= MCIF_AUTH;
d504 1
a504 1
			sm_free(mci->mci_sasl_string);
d514 1
a514 1
	sm_free(out);
d731 1
a731 2

			sm_free(authid);
d807 3
a809 1
	*psecret = (sasl_secret_t *) xalloc(sizeof(sasl_secret_t) + len + 1);
d1060 3
a1062 1
	res = (char *)xalloc(rl + 1);
a1753 1
static EVENT	*volatile DataTimeout = NULL;
d1762 1
a1768 1

d1843 1
a1843 1
	DataTimeout = setevent(timeout, datatimeout, 0);
d1846 6
a1856 7

	if (tTd(18, 101))
	{
		/* simulate a DATA timeout */
		(void) sleep(2);
	}

d1863 1
a1863 2
	if (DataTimeout != NULL)
		clrevent(DataTimeout);
d1941 1
a1941 1
		sm_free(e->e_statmsg);
a1965 8
	int save_errno = errno;

	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

d1969 1
a1979 2
		/* reset the timeout */
		DataTimeout = sigsafe_setevent(timeout, datatimeout, 0);
d1981 1
d1985 1
a1985 8
		/* event is done */
		DataTimeout = NULL;
	}

	/* if no progress was made or problem resetting event, die now */
	if (DataTimeout == NULL)
	{
		errno = ETIMEDOUT;
a1987 2

	errno = save_errno;
d2030 1
a2030 1
		sm_free(e->e_statmsg);
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d18 1
a18 1
static char id[] = "@@(#)$Sendmail: usersmtp.c,v 8.245.4.18 2000/12/20 16:36:11 ca Exp $ (with SMTP)";
d20 1
a20 1
static char id[] = "@@(#)$Sendmail: usersmtp.c,v 8.245.4.18 2000/12/20 16:36:11 ca Exp $ (without SMTP)";
d847 1
d877 2
a878 1
	if ((r = safefile(file, RunAsUid, RunAsGid, RunAsUserName, sff,
d883 1
a883 1
			  file, errstring(r));
d1533 1
a1533 1
			*bufp == '@@' ? ',' : ':', bufp, optbuf);
d1948 2
d2123 11
d2172 9
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d18 1
a18 1
static char id[] = "@@(#)$Sendmail: usersmtp.c,v 8.245 2000/03/23 17:35:10 ca Exp $ (with SMTP)";
d20 1
a20 1
static char id[] = "@@(#)$Sendmail: usersmtp.c,v 8.245 2000/03/23 17:35:10 ca Exp $ (without SMTP)";
d28 1
d281 68
d374 6
d381 1
d406 4
d413 1
a413 6
		if (p == NULL || *p == '\0')
		{
			/* no parameter? */
			mci->mci_saslcap = NULL;
		}
		else
a414 2
			int l;

d416 2
a417 3
				free(mci->mci_saslcap);
			l = strlen(p) + 1;
			mci->mci_saslcap = (char *)malloc(l);
d419 12
a430 2
			/* XXX this may be leaked */
			if (mci->mci_saslcap != NULL)
d432 11
a442 2
				(void) strlcpy(mci->mci_saslcap, p, l);
				mci->mci_flags |= MCIF_AUTH;
d542 2
a543 1
static char *sasl_info_name[] = {
d656 2
a657 1
static sasl_callback_t callbacks[] = {
d701 2
a702 1
	switch (id) {
d723 8
d732 1
d909 2
a910 2
			  context,
			  availrealms == NULL ? "<No Realms>" : *availrealms);
d915 1
a915 1
	if (availrealms != NULL)
d1133 6
a1138 2
		free(mci->mci_conn);
	mci->mci_conn = NULL;
d1147 11
d1162 1
a1162 1
	/* external security strength factor; we have none so zero */
d1165 8
d1190 1
a1190 1
				(struct sockaddr *) &saddr_l, &addrsize) != 0)
d1208 7
d1249 1
d1254 1
d1301 1
a1301 1
		smtpmessage(in64, m, mci);
d1365 2
a1366 1
	do {
d1545 1
a1545 1
	else if (r == 421)
d1843 1
d2109 1
a2109 1
			  "smtpquit: mailer%s%s exited with exit value %d\n",
d2144 3
d2149 2
a2150 1
		mci->mci_state = MCIS_OPEN;
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d18 1
a18 1
static char id[] = "@@(#)$Sendmail: usersmtp.c,v 8.245.4.33 2001/05/23 18:53:09 ca Exp $ (with SMTP)";
d20 1
a20 1
static char id[] = "@@(#)$Sendmail: usersmtp.c,v 8.245.4.33 2001/05/23 18:53:09 ca Exp $ (without SMTP)";
a27 1

d201 1
a201 2
		mci_setstat(mci, EX_CONFIG, "5.3.5",
			    "553 5.3.5 system config error");
a279 62
# if SASL
/*
**  STR_UNION -- create the union of two lists
**
**	Parameters:
**		s1, s2 -- lists of items (separated by single blanks).
**
**	Returns:
**		the union of both lists.
*/

static char *
str_union(s1, s2)
	char *s1, *s2;
{
	char *hr, *h1, *h, *res;
	int l1, l2, rl;

	if (s1 == NULL || *s1 == '\0')
		return s2;
	if (s2 == NULL || *s2 == '\0')
		return s1;
	l1 = strlen(s1);
	l2 = strlen(s2);
	rl = l1 + l2;
	res = (char *)xalloc(rl + 2);
	(void) strlcpy(res, s1, rl);
	hr = res + l1;
	h1 = s2;
	h = s2;

	/* walk through s2 */
	while (h != NULL && *h1 != '\0')
	{
		/* is there something after the current word? */
		if ((h = strchr(h1, ' ')) != NULL)
			*h = '\0';
		l1 = strlen(h1);

		/* does the current word appear in s1 ? */
		if (iteminlist(h1, s1, " ") == NULL)
		{
			/* add space as delimiter */
			*hr++ = ' ';

			/* copy the item */
			memcpy(hr, h1, l1);

			/* advance pointer in result list */
			hr += l1;
			*hr = '\0';
		}
		if (h != NULL)
		{
			/* there are more items */
			*h = ' ';
			h1 = h + 1;
		}
	}
	return res;
}
# endif /* SASL */
a304 6
	{
# if SASL
		if (mci->mci_saslcap != NULL)
			sm_free(mci->mci_saslcap);
		mci->mci_saslcap = NULL;
# endif /* SASL */
a305 1
	}
a329 4
# if STARTTLS
	else if (strcasecmp(line, "starttls") == 0)
		mci->mci_flags |= MCIF_TLS;
# endif /* STARTTLS */
d333 6
a338 1
		if (p != NULL && *p != '\0')
d340 2
d343 3
a345 2
			{
				char *h;
d347 2
a348 12
				/*
				**  create the union with previous auth
				**  offerings because we recognize "auth "
				**  and "auth=" (old format).
				*/
				h = mci->mci_saslcap;
				mci->mci_saslcap = str_union(h, p);
				if (h != mci->mci_saslcap)
					sm_free(h);
				mci->mci_flags |= MCIF_AUTH;
			}
			else
a349 4
				int l;

				l = strlen(p) + 1;
				mci->mci_saslcap = (char *)xalloc(l);
d413 1
a413 1
			sm_free(mci->mci_sasl_string);
d423 1
a423 1
	sm_free(out);
d451 1
a451 2
static char *sasl_info_name[] =
{
d564 1
a564 2
static sasl_callback_t callbacks[] =
{
d608 1
a608 2
	switch (id)
	{
d629 1
a629 11
#  if SASL > 10522
			/*
			**  digest-md5 prior to 1.5.23 doesn't copy the
			**  value it gets from the callback, but free()s
			**  it later on
			**  workaround: don't free() it here
			**  this can cause a memory leak!
			*/

			sm_free(authid);
#  endif /* SASL > 10522 */
d704 3
a706 1
	*psecret = (sasl_secret_t *) xalloc(sizeof(sasl_secret_t) + len + 1);
a743 1

d773 1
a773 2
	p = file;
	if ((r = safefile(p, RunAsUid, RunAsGid, RunAsUserName, sff,
d778 1
a778 1
			  p, errstring(r));
d806 2
a807 2
			  context == NULL ? "<No Context>" : (char *) context,
			  (availrealms == NULL || *availrealms == NULL) ? "<No Realms>" : *availrealms);
d812 1
a812 1
	if (availrealms != NULL && *availrealms != NULL)
d955 3
a957 1
	res = (char *)xalloc(rl + 1);
d1030 2
a1031 6
	{
		sasl_dispose(&(mci->mci_conn));

		/* just in case, sasl_dispose() should take care of it */
		mci->mci_conn = NULL;
	}
a1039 11
#  if SFIO
	/* XXX should these be options settable via .cf ? */
	/* ssp.min_ssf = 0; is default due to memset() */
	{
		ssp.max_ssf = INT_MAX;
		ssp.maxbufsize = MAXOUTLEN;
#   if 0
		ssp.security_flags = SASL_SEC_NOPLAINTEXT;
#   endif /* 0 */
	}
#  endif /* SFIO */
d1044 1
a1044 1
	/* external security strength factor, authentication id */
a1046 8
# if _FFR_EXT_MECH
	out = macvalue(macid("{cert_subject}", NULL), e);
	if (out != NULL && *out != '\0')
		ssf.auth_id = out;
	out = macvalue(macid("{cipher_bits}", NULL), e);
	if (out != NULL && *out != '\0')
		ssf.ssf = atoi(out);
# endif /* _FFR_EXT_MECH */
d1064 1
a1064 1
				(struct sockaddr *) &saddr_l, &addrsize) == 0)
a1081 7
#  if SFIO
		if (saslresult == SASL_NOMECH && LogLevel > 8)
		{
			sm_syslog(LOG_NOTICE, e->e_id,
				  "available AUTH mechanisms do not fulfill requirements");
		}
#  endif /* SFIO */
a1115 1
#  if !SFIO
a1119 1
#  endif /* !SFIO */
d1166 1
a1166 1
		smtpmessage("%s", m, mci, in64);
d1230 1
a1230 2
	do
	{
d1395 1
a1395 1
			    *bufp == '@@' ? ',' : ':', bufp, optbuf);
d1409 1
a1409 1
	else if (r == SMTPCLOSING)
a1615 1
static EVENT	*volatile DataTimeout = NULL;
d1624 1
a1630 1

d1705 1
a1705 1
	DataTimeout = setevent(timeout, datatimeout, 0);
d1707 5
a1717 7

	if (tTd(18, 101))
	{
		/* simulate a DATA timeout */
		(void) sleep(2);
	}

d1724 1
a1724 2
	if (DataTimeout != NULL)
		clrevent(DataTimeout);
d1802 1
a1802 1
		sm_free(e->e_statmsg);
a1808 2
	SmtpPhase = mci->mci_phase = "idle";
	sm_setproctitle(TRUE, e, "%s: %s", CurHostName, mci->mci_phase);
a1824 8
	int save_errno = errno;

	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

d1828 1
a1838 2
		/* reset the timeout */
		DataTimeout = sigsafe_setevent(timeout, datatimeout, 0);
d1840 1
d1844 1
a1844 8
		/* event is done */
		DataTimeout = NULL;
	}

	/* if no progress was made or problem resetting event, die now */
	if (DataTimeout == NULL)
	{
		errno = ETIMEDOUT;
a1846 2

	errno = save_errno;
d1889 1
a1889 1
		sm_free(e->e_statmsg);
d1972 1
a1972 1
			  "smtpquit: mailer%s%s exited with exit value %d",
a1981 11
**
**	Parameters:
**		m -- a pointer to the mailer.
**		mci -- the mailer connection information.
**		e -- the current envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		closes the connection if there is no reply to RSET.
a2006 3
		**
		**  However, if 421 is returned for the RSET, leave
		**  mci_state as MCIS_SSD (set in reply()).
d2009 1
a2009 2
		if (mci->mci_state != MCIS_SSD)
			mci->mci_state = MCIS_OPEN;
a2015 9
**
**	Parameters:
**		mci -- the mailer connection information.
**
**	Returns:
**		none.
**
**	Side Effects:
**		closes the connection if there is no reply to RSET.
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
static char id[] = "@@(#)$Sendmail: usersmtp.c,v 8.240 2000/02/23 06:56:16 gshapiro Exp $ (with SMTP)";
d20 1
a20 1
static char id[] = "@@(#)$Sendmail: usersmtp.c,v 8.240 2000/02/23 06:56:16 gshapiro Exp $ (without SMTP)";
d438 4
d1201 1
d1214 12
d1356 1
a1356 1
	     && (SASLTryAuth != SASL_AUTH_AUTH || mci->mci_sasl_auth)
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d18 1
a18 1
static char id[] = "@@(#)$Id: usersmtp.c,v 8.245.4.18 2000/12/20 16:36:11 ca Exp $ (with SMTP)";
d20 1
a20 1
static char id[] = "@@(#)$Id: usersmtp.c,v 8.245.4.18 2000/12/20 16:36:11 ca Exp $ (without SMTP)";
a27 1

a279 68
# if SASL
/*
**  STR_UNION -- create the union of two lists
**
**	Parameters:
**		s1, s2 -- lists of items (separated by single blanks).
**
**	Returns:
**		the union of both lists.
*/

static char *
str_union(s1, s2)
	char *s1, *s2;
{
	char *hr, *h1, *h, *res;
	int l1, l2, rl;

	if (s1 == NULL || *s1 == '\0')
		return s2;
	if (s2 == NULL || *s2 == '\0')
		return s1;
	l1 = strlen(s1);
	l2 = strlen(s2);
	rl = l1 + l2;
	res = (char *)malloc(rl + 2);
	if (res == NULL)
	{
		if (l1 > l2)
			return s1;
		return s2;
	}
	(void) strlcpy(res, s1, rl);
	hr = res;
	h1 = s2;
	h = s2;

	/* walk through s2 */
	while (h != NULL && *h1 != '\0')
	{
		/* is there something after the current word? */
		if ((h = strchr(h1, ' ')) != NULL)
			*h = '\0';
		l1 = strlen(h1);

		/* does the current word appear in s1 ? */
		if (iteminlist(h1, s1, " ") == NULL)
		{
			/* add space as delimiter */
			*hr++ = ' ';

			/* copy the item */
			memcpy(hr, h1, l1);

			/* advance pointer in result list */
			hr += l1;
			*hr = '\0';
		}
		if (h != NULL)
		{
			/* there are more items */
			*h = ' ';
			h1 = h + 1;
		}
	}
	return res;
}
# endif /* SASL */
a304 6
	{
# if SASL
		if (mci->mci_saslcap != NULL)
			free(mci->mci_saslcap);
		mci->mci_saslcap = NULL;
# endif /* SASL */
a305 1
	}
a329 4
# if STARTTLS
	else if (strcasecmp(line, "starttls") == 0)
		mci->mci_flags |= MCIF_TLS;
# endif /* STARTTLS */
d333 1
a333 1
		if (p != NULL && *p != '\0')
d335 13
d350 1
a350 11
				char *h;

				/*
				**  create the union with previous auth
				**  offerings because we recognize "auth "
				**  and "auth=" (old format).
				*/
				h = mci->mci_saslcap;
				mci->mci_saslcap = str_union(h, p);
				if (h != mci->mci_saslcap)
					free(h);
a352 14
			else
			{
				int l;

				l = strlen(p) + 1;
				mci->mci_saslcap = (char *)malloc(l);

				/* XXX this may be leaked */
				if (mci->mci_saslcap != NULL)
				{
					(void) strlcpy(mci->mci_saslcap, p, l);
					mci->mci_flags |= MCIF_AUTH;
				}
			}
a437 4
**	Side Effects:
**		overwrites local static buffer. The caller should copy
**		the result.
**
d447 1
a447 2
static char *sasl_info_name[] =
{
d560 1
a560 2
static sasl_callback_t callbacks[] =
{
d604 1
a604 2
	switch (id)
	{
a624 8
#  if SASL > 10522
			/*
			**  digest-md5 prior to 1.5.23 doesn't copy the
			**  value it gets from the callback, but free()s
			**  it later on
			**  workaround: don't free() it here
			**  this can cause a memory leak!
			*/
a625 1
#  endif /* SASL > 10522 */
d802 2
a803 2
			  context == NULL ? "<No Context>" : (char *) context,
			  (availrealms == NULL || *availrealms == NULL) ? "<No Realms>" : *availrealms);
d808 1
a808 1
	if (availrealms != NULL && *availrealms != NULL)
d1026 2
a1027 6
	{
		sasl_dispose(&(mci->mci_conn));

		/* just in case, sasl_dispose() should take care of it */
		mci->mci_conn = NULL;
	}
a1035 11
#  if SFIO
	/* XXX should these be options settable via .cf ? */
	/* ssp.min_ssf = 0; is default due to memset() */
	{
		ssp.max_ssf = INT_MAX;
		ssp.maxbufsize = MAXOUTLEN;
#   if 0
		ssp.security_flags = SASL_SEC_NOPLAINTEXT;
#   endif /* 0 */
	}
#  endif /* SFIO */
d1040 1
a1040 1
	/* external security strength factor, authentication id */
a1042 8
# if _FFR_EXT_MECH
	out = macvalue(macid("{cert_subject}", NULL), e);
	if (out != NULL && *out != '\0')
		ssf.auth_id = out;
	out = macvalue(macid("{cipher_bits}", NULL), e);
	if (out != NULL && *out != '\0')
		ssf.ssf = atoi(out);
# endif /* _FFR_EXT_MECH */
d1060 1
a1060 1
				(struct sockaddr *) &saddr_l, &addrsize) == 0)
a1077 7
#  if SFIO
		if (saslresult == SASL_NOMECH && LogLevel > 8)
		{
			sm_syslog(LOG_NOTICE, e->e_id,
				  "available AUTH mechanisms do not fulfill requirements");
		}
#  endif /* SFIO */
a1111 1
#  if !SFIO
a1115 1
#  endif /* !SFIO */
d1162 1
a1162 1
		smtpmessage("%s", m, mci, in64);
a1196 1
	static char *mechs = NULL;
a1208 12
# if _FFR_DEFAUTHINFO_MECHS
	if (mechs == NULL)
	{
		h = readauth(SASL_MECH, SASLInfo, TRUE);
		if (h != NULL && *h != '\0')
			mechs = newstr(h);
	}
# endif /* _FFR_DEFAUTHINFO_MECHS */
	if (mechs == NULL || *mechs == '\0')
		mechs = AuthMechanisms;
	mci->mci_saslcap = intersect(mechs, mci->mci_saslcap);

d1213 1
a1213 2
	do
	{
d1339 1
a1339 1
	     && (!bitset(SASL_AUTH_AUTH, SASLOpts) || mci->mci_sasl_auth)
d1392 1
a1392 1
	else if (r == SMTPCLOSING)
a1689 1

d1955 1
a1955 1
			  "smtpquit: mailer%s%s exited with exit value %d",
a1989 3
		**
		**  However, if 421 is returned for the RSET, leave
		**  mci_state as MCIS_SSD (set in reply()).
d1992 1
a1992 2
		if (mci->mci_state != MCIS_SSD)
			mci->mci_state = MCIS_OPEN;
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 7
a22 1
SM_RCSID("@@(#)$Sendmail: usersmtp.c,v 8.418 2001/09/04 22:43:06 ca Exp $")
d26 2
a28 1
extern void	markfailure __P((ENVELOPE *, ADDRESS *, MCI *, int, bool));
a31 6
static int	smtprcptstat __P((ADDRESS *, MAILER *, MCI *, ENVELOPE *));

#if SASL
extern void	*sm_sasl_malloc __P((unsigned long));
extern void	sm_sasl_free __P((void *));
#endif /* SASL */
d39 3
a41 3
#define REPLYTYPE(r)	((r) / 100)		/* first digit of reply code */
#define REPLYCLASS(r)	(((r) / 10) % 10)	/* second digit of reply code */
#define SMTPCLOSING	421			/* "Service Shutting Down" */
d43 1
a43 4
#define ENHSCN(e, d)	((e) == NULL ? (d) : (e))

#define ENHSCN_RPOOL(e, d, rpool) \
	((e) == NULL ? (d) : sm_rpool_strdup_x(rpool, e))
d81 2
a82 2
		sm_dprintf("smtpinit ");
		mci_dump(mci, false);
d93 1
a93 1
	SmtpNeedIntro = true;
d96 1
a96 3
	  case MCIS_MAIL:
	  case MCIS_RCPT:
	  case MCIS_DATA:
d132 1
a132 1
	sm_setproctitle(true, e, "%s %s: %s",
a152 3
#if _FFR_IGNORE_EXT_ON_HELO
	mci->mci_flags &= ~MCIF_HELO;
#endif /* _FFR_IGNORE_EXT_ON_HELO */
d158 1
a158 2
	else if (bitset(MCIF_ESMTP, mci->mci_flags) &&
		 !bitnset(M_FSMTP, m->m_flags))
a166 3
#if _FFR_IGNORE_EXT_ON_HELO
		mci->mci_flags |= MCIF_HELO;
#endif /* _FFR_IGNORE_EXT_ON_HELO */
d168 1
a168 1
	sm_setproctitle(true, e, "%s %s: %s", qid_printname(e),
d170 1
a170 4
	r = reply(m, mci, e,
		  bitnset(M_LMTP, m->m_flags) ? TimeOuts.to_lhlo
					      : TimeOuts.to_helo,
		  helo_options, NULL);
d198 1
a198 1
	    sm_strcasecmp(&SmtpReplyBuffer[4], MyHostName) == 0)
d202 1
a202 2
		mci_setstat(mci, EX_CONFIG, "5.3.5",
			    "553 5.3.5 system config error");
a207 1
#if !_FFR_DEPRECATE_MAILER_FLAG_I
a220 1
#endif /* !_FFR_DEPRECATE_MAILER_FLAG_I */
a240 1

a277 9

	/*
	**  Dirty hack below. Quoting the author:
	**  This was a response to people who wanted SMTP transmission to be
	**  just-send-8 by default.  Essentially, you could put this tag into
	**  your greeting message to behave as though the F=8 flag was set on
	**  the mailer.
	*/

d281 1
a281 5

#if SASL
/* specify prototype so compiler can check calls */
static char *str_union __P((char *, char *, SM_RPOOL_T *));

a286 1
**		rpool -- resource pool from which result is allocated.
d293 1
a293 1
str_union(s1, s2, rpool)
a294 1
	SM_RPOOL_T *rpool;
d306 1
a306 1
	res = (char *) sm_rpool_malloc(rpool, rl + 2);
d313 2
a314 2
	(void) sm_strlcpy(res, s1, rl);
	hr = res + l1;
d348 1
a348 2
#endif /* SASL */

d357 1
a357 1
**		e -- the envelope (unused).
a371 3
#if _FFR_IGNORE_EXT_ON_HELO
	static bool logged = false;
#endif /* _FFR_IGNORE_EXT_ON_HELO */
d375 3
a377 1
#if SASL
d379 1
a379 17
#endif /* SASL */
#if _FFR_IGNORE_EXT_ON_HELO
		logged = false;
#endif /* _FFR_IGNORE_EXT_ON_HELO */
		return;
	}
#if _FFR_IGNORE_EXT_ON_HELO
	else if (bitset(MCIF_HELO, mci->mci_flags))
	{
		if (LogLevel > 8 && !logged)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "server=%s [%s] returned extensions despite HELO command",
				  macvalue(macid("{server_name}"), e),
				  macvalue(macid("{server_addr}"), e));
			logged = true;
		}
a381 1
#endif /* _FFR_IGNORE_EXT_ON_HELO */
d383 1
a383 1
	if (strlen(line) < 5)
d389 1
a389 1
	if (sm_strcasecmp(line, "size") == 0)
d395 1
a395 1
	else if (sm_strcasecmp(line, "8bitmime") == 0)
d400 1
a400 1
	else if (sm_strcasecmp(line, "expn") == 0)
d402 1
a402 1
	else if (sm_strcasecmp(line, "dsn") == 0)
d404 1
a404 1
	else if (sm_strcasecmp(line, "enhancedstatuscodes") == 0)
d406 2
a407 4
	else if (sm_strcasecmp(line, "pipelining") == 0)
		mci->mci_flags |= MCIF_PIPELINED;
#if STARTTLS
	else if (sm_strcasecmp(line, "starttls") == 0)
d409 3
a411 9
#endif /* STARTTLS */
	else if (sm_strcasecmp(line, "deliverby") == 0)
	{
		mci->mci_flags |= MCIF_DLVR_BY;
		if (p != NULL)
			mci->mci_min_by = atol(p);
	}
#if SASL
	else if (sm_strcasecmp(line, "auth") == 0)
d417 2
d420 1
a420 1
				**  Create the union with previous auth
d424 4
a427 3

				mci->mci_saslcap = str_union(mci->mci_saslcap,
							     p, mci->mci_rpool);
d435 3
a437 2
				mci->mci_saslcap = (char *)
					sm_rpool_malloc(mci->mci_rpool, l);
d440 1
a440 2
					(void) sm_strlcpy(mci->mci_saslcap, p,
							  l);
d446 1
a446 56
#endif /* SASL */
}
#if SASL

static int getsimple	__P((void *, int, const char **, unsigned *));
static int getsecret	__P((sasl_conn_t *, void *, int, sasl_secret_t **));
static int saslgetrealm	__P((void *, int, const char **, const char **));
static int readauth	__P((char *, bool, SASL_AI_T *m, SM_RPOOL_T *));
static int getauth	__P((MCI *, ENVELOPE *, SASL_AI_T *));
static char *removemech	__P((char *, char *, SM_RPOOL_T *));
static int attemptauth	__P((MAILER *, MCI *, ENVELOPE *, SASL_AI_T *));

static sasl_callback_t callbacks[] =
{
	{	SASL_CB_GETREALM,	&saslgetrealm,	NULL	},
#define CB_GETREALM_IDX	0
	{	SASL_CB_PASS,		&getsecret,	NULL	},
#define CB_PASS_IDX	1
	{	SASL_CB_USER,		&getsimple,	NULL	},
#define CB_USER_IDX	2
	{	SASL_CB_AUTHNAME,	&getsimple,	NULL	},
#define CB_AUTHNAME_IDX	3
	{	SASL_CB_VERIFYFILE,	&safesaslfile,	NULL	},
#define CB_SAFESASL_IDX	4
	{	SASL_CB_LIST_END,	NULL,		NULL	}
};

/*
**  INIT_SASL_CLIENT -- initialize client side of Cyrus-SASL
**
**	Parameters:
**		none.
**
**	Returns:
**		SASL_OK -- if successful.
**		SASL error code -- otherwise.
**
**	Side Effects:
**		checks/sets sasl_clt_init.
*/

static bool sasl_clt_init = false;

static int
init_sasl_client()
{
	int result;

	if (sasl_clt_init)
		return SASL_OK;
	result = sasl_client_init(callbacks);

	/* should we retry later again or just remember that it failed? */
	if (result == SASL_OK)
		sasl_clt_init = true;
	return result;
d448 1
a448 12
/*
**  STOP_SASL_CLIENT -- shutdown client side of Cyrus-SASL
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		checks/sets sasl_clt_init.
*/
a449 8
void
stop_sasl_client()
{
	if (!sasl_clt_init)
		return;
	sasl_clt_init = false;
	sasl_done();
}
d454 1
a454 1
**	from the server.
d461 1
a461 1
**		e -- the envelope (unused).
d467 1
a467 3
static void getsasldata __P((char *, bool, MAILER *, MCI *, ENVELOPE *));

static void
d476 1
a477 1
	char *out;
d480 1
a480 2
	len = strlen(line);
	if ((len <= 4) ||
d482 2
a483 2
	     !isascii(line[1]) || !isdigit(line[1]) ||
	     !isascii(line[2]) || !isdigit(line[2]))
d485 1
a485 1
		SM_FREE_CLR(mci->mci_sasl_string);
d491 1
a491 1
	len -= 4;
d493 2
a494 2
	out = (char *) sm_rpool_malloc_x(mci->mci_rpool, len + 1);
	result = sasl_decode64(line, len, out, (unsigned int *)&len);
a499 7

	/*
	**  mci_sasl_string is "shared" with Cyrus-SASL library; hence
	**	it can't be in an rpool unless we use the same memory
	**	management mechanism (with same rpool!) for Cyrus SASL.
	*/

d504 1
a504 1
			sm_free(mci->mci_sasl_string); /* XXX */
d510 1
a510 1

d514 1
d517 1
d519 1
a519 1
**  READAUTH -- read auth values from a file
d522 1
a524 2
**		sai -- where to store auth_info.
**		rpool -- resource pool for sai.
d527 6
a532 3
**		EX_OK -- data succesfully read.
**		EX_UNAVAILABLE -- no valid filename.
**		EX_TEMPFAIL -- temporary failure.
d535 7
d544 1
d546 1
a546 1
	"authentication id",
d549 1
a549 1
	"mechlist"
d551 4
a554 2
static int
readauth(filename, safe, sai, rpool)
a556 2
	SASL_AI_T *sai;
	SM_RPOOL_T *rpool;
d558 1
a558 1
	SM_FILE_T *f;
d562 1
a562 2
	char *s;
	char buf[MAXLINE];
d565 1
a565 2
		return EX_UNAVAILABLE;

a572 1

d593 1
a593 2
			f = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT,
				       (void *) fd, SM_IO_RDONLY, NULL);
d599 2
a600 6
		sff = SFF_REGONLY|SFF_SAFEDIRPATH|SFF_NOWLINK
		      |SFF_NOGWFILES|SFF_NOWWFILES|SFF_NOWRFILES;
# if _FFR_GROUPREADABLEAUTHINFOFILE
		if (!bitnset(DBS_GROUPREADABLEAUTHINFOFILE, DontBlameSendmail))
# endif /* _FFR_GROUPREADABLEAUTHINFOFILE */
			sff |= SFF_NOGRFILES;
a602 1

a608 1

d619 2
a620 5
		if (LogLevel > 5)
			sm_syslog(LOG_ERR, NOQID,
				  "AUTH=client, error: can't open %s: %s",
				  filename, sm_errstring(errno));
		return EX_TEMPFAIL;
d624 1
a624 2
	while (lc <= SASL_MECHLIST &&
		sm_io_fgets(f, SM_TIME_DEFAULT, buf, sizeof buf) != NULL)
a626 4
		{
			(*sai)[lc] = sm_rpool_strdup_x(rpool, buf);
			if ((s = strchr((*sai)[lc], '\n')) != NULL)
				*s = '\0';
a627 1
		}
d630 1
a630 1
	(void) sm_io_close(f, SM_TIME_DEFAULT);
d633 1
a633 1
	if (lc < SASL_PASSWORD)
d635 16
a650 8
		if (LogLevel > 8)
			sm_syslog(LOG_ERR, NOQID,
				  "AUTH=client, error: can't read %s from %s",
				  sasl_info_name[lc + 1], filename);
		return EX_TEMPFAIL;
	}
	return EX_OK;
}
d652 3
a654 19
/*
**  GETAUTH -- get authinfo from ruleset call
**
**	{server_name}, {server_addr} must be set
**
**	Parameters:
**		mci -- the mailer connection structure.
**		e -- the envelope (including the sender to specify).
**		sai -- pointer to authinfo (result).
**
**	Returns:
**		EX_OK -- ruleset was succesfully called, data may not
**			be available, sai must be checked.
**		EX_UNAVAILABLE -- ruleset unavailable (or failed).
**		EX_TEMPFAIL -- temporary failure (from ruleset).
**
**	Side Effects:
**		Fills in sai if successful.
*/
d656 1
a656 5
static int
getauth(mci, e, sai)
	MCI *mci;
	ENVELOPE *e;
	SASL_AI_T *sai;
d658 11
a668 3
	int i, r, l, got, ret;
	char **pvp;
	char pvpbuf[PSBUFSIZE];
a669 133
	r = rscap("authinfo", macvalue(macid("{server_name}"), e),
		   macvalue(macid("{server_addr}"), e), e,
		   &pvp, pvpbuf, sizeof(pvpbuf));

	if (r != EX_OK)
		return EX_UNAVAILABLE;

	/* other than expected return value: ok (i.e., no auth) */
	if (pvp == NULL || pvp[0] == NULL || (pvp[0][0] & 0377) != CANONNET)
		return EX_OK;
	if (pvp[1] != NULL && sm_strncasecmp(pvp[1], "temp", 4) == 0)
		return EX_TEMPFAIL;

	/*
	**  parse the data, put it into sai
	**  format: "TDstring" (including the '"' !)
	**  where T is a tag: 'U', ...
	**  D is a delimiter: ':' or '='
	*/

	ret = EX_OK;	/* default return value */
	i = 0;
	got = 0;
	while (i < SASL_ENTRIES)
	{
		if (pvp[i + 1] == NULL)
			break;
		if (pvp[i + 1][0] != '"')
			break;
		switch (pvp[i + 1][1])
		{
		  case 'U':
		  case 'u':
			r = SASL_USER;
			break;
		  case 'I':
		  case 'i':
			r = SASL_AUTHID;
			break;
		  case 'P':
		  case 'p':
			r = SASL_PASSWORD;
			break;
		  case 'R':
		  case 'r':
			r = SASL_DEFREALM;
			break;
		  case 'M':
		  case 'm':
			r = SASL_MECHLIST;
			break;
		  default:
			goto fail;
		}
		l = strlen(pvp[i + 1]);

		/* remove closing quote */
		if (l > 3 && pvp[i + 1][l - 1] == '"')
			pvp[i + 1][l - 1] = '\0';
		else
			goto fail;

		/* remove "TD and " */
		l -= 4;
		(*sai)[r] = (char *) sm_rpool_malloc(mci->mci_rpool, l + 1);
		if ((*sai)[r] == NULL)
			goto tempfail;
		if (pvp[i + 1][2] == ':')
		{
			/* ':text' (just copy) */
			(void) sm_strlcpy((*sai)[r], pvp[i + 1] + 3, l + 1);
			got |= 1 << r;
		}
		else if (pvp[i + 1][2] == '=')
		{
			unsigned int len;

			/* '=base64' (decode) */
			r = sasl_decode64(pvp[i + 1] + 3,
					  (unsigned int) l, (*sai)[r], &len);
			if (r != SASL_OK)
				goto fail;
			got |= 1 << r;
		}
		else
			goto fail;
		if (tTd(95, 5))
			sm_syslog(LOG_WARNING, NOQID, "getauth %s=%s",
				  sasl_info_name[r], (*sai)[r]);
		++i;
	}

	/* did we get the expected data? */
	if (!(bitset(SASL_USER_BIT|SASL_AUTHID_BIT, got) &&
	      bitset(SASL_PASSWORD_BIT, got)))
		goto fail;

	/* no authid? copy uid */
	if (!bitset(SASL_AUTHID_BIT, got))
	{
		l = strlen((*sai)[SASL_USER]) + 1;
		(*sai)[SASL_AUTHID] = (char *) sm_rpool_malloc(mci->mci_rpool,
							       l + 1);
		if ((*sai)[SASL_AUTHID] == NULL)
			goto tempfail;
		(void) sm_strlcpy((*sai)[SASL_AUTHID], (*sai)[SASL_USER], l);
	}

	/* no uid? copy authid */
	if (!bitset(SASL_USER_BIT, got))
	{
		l = strlen((*sai)[SASL_AUTHID]) + 1;
		(*sai)[SASL_USER] = (char *) sm_rpool_malloc(mci->mci_rpool,
							     l + 1);
		if ((*sai)[SASL_USER] == NULL)
			goto tempfail;
		(void) sm_strlcpy((*sai)[SASL_USER], (*sai)[SASL_AUTHID], l);
	}
	return EX_OK;

  tempfail:
	ret = EX_TEMPFAIL;
  fail:
	if (LogLevel > 8)
		sm_syslog(LOG_WARNING, NOQID,
			  "AUTH=client, relay=%.64s [%.16s], authinfo %sfailed",
			  macvalue(macid("{server_name}"), e),
			  macvalue(macid("{server_addr}"), e),
			  ret == EX_TEMPFAIL ? "temp" : "");
	for (i = 0; i <= SASL_MECHLIST; i++)
		(*sai)[i] = NULL;	/* just clear; rpool */
	return ret;
}
d674 1
a674 1
**		context -- sai
d685 1
a685 1
	void *context;
d690 7
a696 7
	char *h, *s;
# if SASL > 10509
	bool addrealm;
# endif /* SASL > 10509 */
	size_t l;
	SASL_AI_T *sai;
	char *authid = NULL;
d698 1
a698 1
	if (result == NULL || context == NULL)
a699 18
	sai = (SASL_AI_T *) context;

	/*
	**  Unfortunately it is not clear whether this routine should
	**  return a copy of a string or just a pointer to a string.
	**  The Cyrus-SASL plugins treat these return values differently, e.g.,
	**  plugins/cram.c free()s authid, plugings/digestmd5.c does not.
	**  The best solution to this problem is to fix Cyrus-SASL, but it
	**  seems there is nobody who creates patches... Hello CMU!?
	**  The second best solution is to have flags that tell this routine
	**  whether to return an malloc()ed copy.
	**  The next best solution is to always return an malloc()ed copy,
	**  and suffer from some memory leak, which is ugly for persistent
	**  queue runners.
	**  For now we go with the last solution...
	**  We can't use rpools (which would avoid this particular problem)
	**  as explained in sasl.c.
	*/
d704 4
a707 8
		l = strlen((*sai)[SASL_USER]) + 1;
		s = sm_sasl_malloc(l);
		if (s == NULL)
		{
			if (len != NULL)
				*len = 0;
			*result = NULL;
			return SASL_NOMEM;
d709 1
a709 2
		(void) sm_strlcpy(s, (*sai)[SASL_USER], l);
		*result = s;
d711 1
a711 2
			sm_syslog(LOG_WARNING, NOQID, "AUTH username '%s'",
				  *result);
d713 1
a713 1
			*len = *result != NULL ? strlen(*result) : 0;
d717 1
a717 2
		h = (*sai)[SASL_AUTHID];
# if SASL > 10509
d719 3
a721 3
		addrealm = (*sai)[SASL_MECH] != NULL &&
			   sm_strcasecmp((*sai)[SASL_MECH], "CRAM-MD5") == 0;
		if (addrealm && h != NULL && strchr(h, '@@') == NULL)
d723 19
a741 1
			if ((*sai)[SASL_ID_REALM] == NULL)
d743 1
d746 1
a746 1
				realm = (*sai)[SASL_DEFREALM];
d748 2
a749 14

				/* should use rpool, but how to get it? */
				authid = sm_sasl_malloc(l);
				if (authid != NULL)
				{
					(void) sm_snprintf(authid, l, "%s@@%s",
							   h, realm);
					(*sai)[SASL_ID_REALM] = authid;
				}
				else
				{
					authid = h;
					(*sai)[SASL_ID_REALM] = NULL;
				}
d752 2
a753 1
				authid = (*sai)[SASL_ID_REALM];
d755 1
a755 14
		else
# endif /* SASL > 10509 */
			authid = h;
		l = strlen(authid) + 1;
		s = sm_sasl_malloc(l);
		if (s == NULL)
		{
			if (len != NULL)
				*len = 0;
			*result = NULL;
			return SASL_NOMEM;
		}
		(void) sm_strlcpy(s, authid, l);
		*result = s;
d757 1
a757 2
			sm_syslog(LOG_WARNING, NOQID, "AUTH authid '%s'",
				  *result);
d773 1
d779 1
a779 1
**		context -- sai
d790 1
a790 1
	SM_UNUSED(void *context);
d794 1
d796 1
a796 2
	char *authpass;
	SASL_AI_T *sai;
d801 5
a805 2
	sai = (SASL_AI_T *) context;
	authpass = (*sai)[SASL_PASSWORD];
d807 1
a807 2
	*psecret = (sasl_secret_t *) sm_sasl_malloc(sizeof(sasl_secret_t) +
						    len + 1);
d810 2
a811 2
	(void) sm_strlcpy((*psecret)->data, authpass, len + 1);
	(*psecret)->len = (unsigned long) len;
d814 1
d824 3
a826 3
**		SASL_OK -- file can be used
**		SASL_CONTINUE -- don't use file
**		SASL_FAIL -- failure (not used here)
a828 1

d830 1
a830 1
#if SASL > 10515
d832 1
a832 1
#else /* SASL > 10515 */
d834 1
a834 1
#endif /* SASL > 10515 */
d837 1
a837 1
#if SASL > 10515
d839 1
a839 1
#endif /* SASL > 10515 */
a842 3
#if SASL <= 10515
	size_t len;
#endif /* SASL <= 10515 */
d847 1
a847 1
	sff = SFF_SAFEDIRPATH|SFF_NOWLINK|SFF_NOWWFILES|SFF_ROOTOK;
d853 1
a853 1
#if SASL <= 10515
d855 9
a863 10
	len = strlen(p);
	if ((len <= 3 || strncmp(p, "lib", 3) != 0) &&
	    (len <= 5 || strncmp(p + len - 5, ".conf", 5) != 0))
	{
		if (!bitnset(DBS_GROUPREADABLESASLDBFILE, DontBlameSendmail))
			sff |= SFF_NORFILES;
		if (!bitnset(DBS_GROUPWRITABLESASLDBFILE, DontBlameSendmail))
			sff |= SFF_NOGWFILES;
	}
#else /* SASL <= 10515 */
d867 2
a868 1
		if (bitnset(DBS_GROUPREADABLESASLDBFILE, DontBlameSendmail))
d871 1
a872 2
		if (!bitnset(DBS_GROUPWRITABLESASLDBFILE, DontBlameSendmail))
			sff |= SFF_NOGWFILES;
d874 1
a874 1
#endif /* SASL <= 10515 */
d876 1
a876 2
	p = file;
	if ((r = safefile(p, RunAsUid, RunAsGid, RunAsUserName, sff,
d879 1
a879 1
	if (LogLevel > (r != ENOENT ? 8 : 10))
d881 1
a881 1
			  p, sm_errstring(r));
d892 1
a899 1

d907 5
a911 5
	char *r;
	SASL_AI_T *sai;

	sai = (SASL_AI_T *) context;
	if (sai == NULL)
a912 1
	r = (*sai)[SASL_DEFREALM];
d914 1
a914 8
	if (LogLevel > 12)
		sm_syslog(LOG_INFO, NOQID,
			  "AUTH=client, realm=%s, available realms=%s",
			  r == NULL ? "<No Realm>" : r,
			  (availrealms == NULL || *availrealms == NULL)
				? "<No Realms>" : *availrealms);

	/* check whether context is in list */
d922 2
a923 2
					  "AUTH=client, realm=%s not in list=%s",
					  r, *availrealms);
d927 1
a927 1
	*result = r;
d964 1
a964 1
		if (sm_strncasecmp(s, item, len) == 0 &&
a979 1
**		rpool -- resource pool from which result is allocated.
d985 2
a986 2
static char *
removemech(rem, list, rpool)
a988 1
	SM_RPOOL_T *rpool;
d1011 1
a1011 1
	if (len <= 0)
d1013 1
a1013 1
		ret = (char *) sm_rpool_malloc_x(rpool, 1);
d1017 1
a1017 1
	ret = (char *) sm_rpool_malloc_x(rpool, len);
d1037 63
d1106 1
a1106 1
**		sai - sasl authinfo
d1109 1
a1109 5
**		EX_OK -- authentication was successful.
**		EX_NOPERM -- authentication failed.
**		EX_IOERR -- authentication dialogue failed (I/O problem?).
**		EX_TEMPFAIL -- temporary failure.
**
d1112 2
a1113 2
static int
attemptauth(m, mci, e, sai)
d1117 1
a1117 1
	SASL_AI_T *sai;
d1124 1
a1124 1
	char *mechusing;
d1127 1
a1127 1
#if NETINET
d1129 1
a1129 1
#endif /* NETINET */
d1131 1
a1131 4
	/* no mechanism selected (yet) */
	(*sai)[SASL_MECH] = NULL;

	/* dispose old connection */
d1133 1
d1136 4
a1143 2
	if (saslresult != SASL_OK)
		return EX_TEMPFAIL;
d1147 1
a1147 1

d1149 1
a1149 2
#  if STARTTLS
#endif /* STARTTLS */
d1151 1
a1151 1
		ssp.max_ssf = MaxSLBits;
d1153 1
a1153 1
#  if 0
d1155 1
a1155 1
#  endif /* 0 */
d1157 1
d1165 2
a1166 2
#if STARTTLS
	out = macvalue(macid("{cert_subject}"), e);
d1169 1
a1169 1
	out = macvalue(macid("{cipher_bits}"), e);
d1172 1
a1172 1
#endif /* STARTTLS */
d1177 1
a1177 1
#if NETINET
d1189 1
a1189 2
		if (getsockname(sm_io_getinfo(mci->mci_out, SM_IO_WHAT_FD,
					      NULL),
d1197 1
a1197 1
#endif /* NETINET */
d1204 1
d1208 1
d1212 1
a1212 1
				  "AUTH=client, available mechanisms do not fulfill requirements");
d1214 1
d1218 1
a1218 2
	/* just point current mechanism to the data in the sasl library */
	(*sai)[SASL_MECH] = mechusing;
a1236 1
	sm_sasl_free(out); /* XXX only if no rpool is used */
d1239 2
a1240 1
	smtpresult = reply(m, mci, e, TimeOuts.to_auth, getsasldata, NULL);
d1247 8
a1254 2
			macdefine(&mci->mci_macro, A_TEMP, macid("{auth_type}"),
				  mechusing);
d1259 1
a1259 6
		if (REPLYTYPE(smtpresult) == 5)
			return EX_NOPERM;	/* ugly, but ... */
		if (REPLYTYPE(smtpresult) != 3)
		{
			/* should we fail deliberately, see RFC 2554 4. ? */
			/* smtpmessage("*", m, mci); */
a1260 1
		}
d1271 1
a1271 1
				sm_dprintf("AUTH FAIL=%s (%d)\n",
d1275 1
a1275 1
			/* fail deliberately, see RFC 2554 4. */
d1283 1
a1283 1
			smtpresult = reply(m, mci, e, TimeOuts.to_auth,
d1285 1
a1285 1
			return EX_NOPERM;
a1300 1
		sm_sasl_free(out); /* XXX only if no rpool is used */
d1302 1
a1302 1
		smtpresult = reply(m, mci, e, TimeOuts.to_auth,
d1304 1
d1308 1
d1323 1
a1323 10
**		EX_OK -- authentication was successful
**		EX_UNAVAILABLE -- authentication not possible, e.g.,
**			no data available.
**		EX_NOPERM -- authentication failed.
**		EX_TEMPFAIL -- temporary failure.
**
**	Notice: AuthInfo is used for all connections, hence we must
**		return EX_TEMPFAIL only if we really want to retry, i.e.,
**		iff getauth() tempfailed or getauth() was used and
**		authentication tempfailed.
d1333 27
a1359 61
	int i;
	bool usedgetauth;

	mci->mci_sasl_auth = false;
	for (i = 0; i < SASL_MECH ; i++)
		mci->mci_sai[i] = NULL;

	result = getauth(mci, e, &(mci->mci_sai));
	if (result == EX_TEMPFAIL)
		return result;
	usedgetauth = true;

	/* no data available: don't try to authenticate */
	if (result == EX_OK && mci->mci_sai[SASL_AUTHID] == NULL)
		return result;
	if (result != EX_OK)
	{
		if (SASLInfo == NULL)
			return EX_UNAVAILABLE;

		/* read authinfo from file */
		result = readauth(SASLInfo, true, &(mci->mci_sai),
				  mci->mci_rpool);
		if (result != EX_OK)
			return result;
		usedgetauth = false;
	}

	/* check whether sufficient data is available */
	if (mci->mci_sai[SASL_PASSWORD] == NULL ||
	    *(mci->mci_sai)[SASL_PASSWORD] == '\0')
		return EX_UNAVAILABLE;
	if ((mci->mci_sai[SASL_AUTHID] == NULL ||
	     *(mci->mci_sai)[SASL_AUTHID] == '\0') &&
	    (mci->mci_sai[SASL_USER] == NULL ||
	     *(mci->mci_sai)[SASL_USER] == '\0'))
		return EX_UNAVAILABLE;

	/* set the context for the callback function to sai */
	callbacks[CB_PASS_IDX].context = (void *)&mci->mci_sai;
	callbacks[CB_USER_IDX].context = (void *)&mci->mci_sai;
	callbacks[CB_AUTHNAME_IDX].context = (void *)&mci->mci_sai;
	callbacks[CB_GETREALM_IDX].context = (void *)&mci->mci_sai;
#if 0
	callbacks[CB_SAFESASL_IDX].context = (void *)&mci->mci_sai;
#endif /* 0 */

	/* set default value for realm */
	if ((mci->mci_sai)[SASL_DEFREALM] == NULL ||
	    *(mci->mci_sai)[SASL_DEFREALM] == '\0')
		(mci->mci_sai)[SASL_DEFREALM] = sm_rpool_strdup_x(e->e_rpool,
							macvalue('j', CurEnv));

	/* set default value for list of mechanism to use */
	if ((mci->mci_sai)[SASL_MECHLIST] == NULL ||
	    *(mci->mci_sai)[SASL_MECHLIST] == '\0')
		(mci->mci_sai)[SASL_MECHLIST] = AuthMechanisms;

	/* create list of mechanisms to try */
	mci->mci_saslcap = intersect((mci->mci_sai)[SASL_MECHLIST],
				     mci->mci_saslcap, mci->mci_rpool);
d1362 1
a1362 1
	result = init_sasl_client();
d1364 1
a1364 1
		return usedgetauth ? EX_TEMPFAIL : EX_UNAVAILABLE;
d1367 1
a1367 1
		result = attemptauth(m, mci, e, &(mci->mci_sai));
d1369 2
a1370 2
			mci->mci_sasl_auth = true;
		else if (result == EX_TEMPFAIL || result == EX_NOPERM)
d1372 2
a1373 3
			mci->mci_saslcap = removemech((mci->mci_sai)[SASL_MECH],
						      mci->mci_saslcap,
						      mci->mci_rpool);
d1376 1
a1376 2
				return usedgetauth ? result
						   : EX_UNAVAILABLE;
d1378 2
a1379 2
		else
			return result;
d1383 1
a1383 1
#endif /* SASL */
a1402 1
	char *enhsc;
d1405 1
d1408 1
a1408 1
		sm_dprintf("smtpmailfrom: CurHost=%s\n", CurHostName);
d1414 1
a1414 2
		(void) sm_snprintf(optbuf, sizeof optbuf, " SIZE=%ld",
			e->e_msgsize);
d1435 1
a1435 1
			(void) sm_snprintf(bufp, SPACELEFT(optbuf, bufp),
d1447 1
a1447 1
#if MIME8TO7
d1456 1
a1456 1
#endif /* MIME8TO7 */
d1472 1
a1472 1
			(void) sm_snprintf(bufp, SPACELEFT(optbuf, bufp),
d1481 1
a1481 1
			(void) sm_snprintf(bufp, SPACELEFT(optbuf, bufp),
d1491 1
a1491 1
#if SASL
d1493 1
a1493 1
#endif /* SASL */
d1496 1
a1496 1
		(void) sm_snprintf(bufp, SPACELEFT(optbuf, bufp),
a1501 28
	**  17 is the max length required, we could use log() to compute
	**  the exact length (and check IS_DLVR_TRACE())
	*/

	if (bitset(MCIF_DLVR_BY, mci->mci_flags) &&
	    IS_DLVR_BY(e) && SPACELEFT(optbuf, bufp) > 17)
	{
		long dby;

		/*
		**  Avoid problems with delays (for R) since the check
		**  in deliver() whether min-deliver-time is sufficient.
		**  Alternatively we could pass the computed time to this
		**  function.
		*/

		dby = e->e_deliver_by - (curtime() - e->e_ctime);
		if (dby <= 0 && IS_DLVR_RETURN(e))
			dby = mci->mci_min_by <= 0 ? 1 : mci->mci_min_by;
		(void) sm_snprintf(bufp, SPACELEFT(optbuf, bufp),
			" BY=%ld;%c%s",
			dby,
			IS_DLVR_RETURN(e) ? 'R' : 'N',
			IS_DLVR_TRACE(e) ? "T" : "");
		bufp += strlen(bufp);
	}

	/*
d1506 1
a1506 1
	mci->mci_state = MCIS_MAIL;
d1531 1
a1531 1
			    *bufp == '@@' ? ',' : ':', bufp, optbuf);
d1534 1
a1534 1
	sm_setproctitle(true, e, "%s %s: %s", qid_printname(e),
d1625 1
a1625 1
smtprcpt(to, m, mci, e, ctladdr, xstart)
a1629 2
	ADDRESS *ctladdr;
	time_t xstart;
d1631 1
d1634 1
d1636 1
a1636 22
#if PIPELINING
	/*
	**  If there is status waiting from the other end, read it.
	**  This should normally happen because of SMTP pipelining.
	*/

	while (mci->mci_nextaddr != NULL &&
	       sm_io_getinfo(mci->mci_in, SM_IO_IS_READABLE, NULL))
	{
		int r;

		r = smtprcptstat(mci->mci_nextaddr, m, mci, e);
		if (r != EX_OK)
		{
			markfailure(e, mci->mci_nextaddr, mci, r, false);
			giveresponse(r, mci->mci_nextaddr->q_status,  m, mci,
				     ctladdr, xstart, e, to);
		}
		mci->mci_nextaddr = mci->mci_nextaddr->q_pchain;
	}
#endif /* PIPELINING */

d1641 1
a1641 1
	**  Warning: in the following it is assumed that the free space
a1643 1

a1645 12
		if (IS_DLVR_NOTIFY(e) &&
		    !bitset(MCIF_DLVR_BY, mci->mci_flags))
		{
			/* RFC 2852: 4.1.4.2 */
			if (!bitset(QHASNOTIFY, to->q_flags))
				to->q_flags |= QPINGONFAILURE|QPINGONDELAY|QHASNOTIFY;
			else if (bitset(QPINGONSUCCESS, to->q_flags) ||
				 bitset(QPINGONFAILURE, to->q_flags) ||
				 bitset(QPINGONDELAY, to->q_flags))
				to->q_flags |= QPINGONDELAY;
		}

d1651 1
a1651 1
			bool firstone = true;
d1653 1
a1653 1
			(void) sm_strlcat(bufp, " NOTIFY=", sizeof optbuf);
d1656 2
a1657 2
				(void) sm_strlcat(bufp, "SUCCESS", sizeof optbuf);
				firstone = false;
d1662 1
a1662 1
					(void) sm_strlcat(bufp, ",",
d1664 2
a1665 2
				(void) sm_strlcat(bufp, "FAILURE", sizeof optbuf);
				firstone = false;
d1670 1
a1670 1
					(void) sm_strlcat(bufp, ",",
d1672 2
a1673 2
				(void) sm_strlcat(bufp, "DELAY", sizeof optbuf);
				firstone = false;
d1676 1
a1676 1
				(void) sm_strlcat(bufp, "NEVER", sizeof optbuf);
d1684 1
a1684 1
			(void) sm_snprintf(bufp, SPACELEFT(optbuf, bufp),
a1690 1
	mci->mci_state = MCIS_RCPT;
d1693 1
a1693 1
	sm_setproctitle(true, e, "%s %s: %s", qid_printname(e),
a1694 38

#if PIPELINING
	/*
	**  If running SMTP pipelining, we will pick up status later
	*/

	if (bitset(MCIF_PIPELINED, mci->mci_flags))
		return EX_OK;
#endif /* PIPELINING */

	return smtprcptstat(to, m, mci, e);
}
/*
**  SMTPRCPTSTAT -- get recipient status
**
**	This is only called during SMTP pipelining
**
**	Parameters:
**		to -- address of recipient.
**		m -- mailer being sent to.
**		mci -- the mailer connection information.
**		e -- the envelope for this message.
**
**	Returns:
**		EX_* -- protocol status
*/

static int
smtprcptstat(to, m, mci, e)
	ADDRESS *to;
	MAILER *m;
	register MCI *mci;
	register ENVELOPE *e;
{
	int r;
	char *enhsc;

	enhsc = NULL;
d1696 2
a1697 2
	to->q_rstatus = sm_rpool_strdup_x(e->e_rpool, SmtpReplyBuffer);
	to->q_status = ENHSCN_RPOOL(enhsc, smtptodsn(r), e->e_rpool);
a1700 2
	{
		mci->mci_retryrcpt = true;
a1701 1
	}
a1702 16
	{
		char *t;

		if ((t = mci->mci_tolist) != NULL)
		{
			char *p;

			*t++ = ',';
			for (p = to->q_paddr; *p != '\0'; *t++ = *p++)
				continue;
			*t = '\0';
			mci->mci_tolist = t;
		}
#if PIPELINING
		mci->mci_okrcpts++;
#endif /* PIPELINING */
a1703 1
	}
d1706 1
a1706 1
		to->q_status = ENHSCN_RPOOL(enhsc, "5.1.1", e->e_rpool);
d1711 1
a1711 1
		to->q_status = ENHSCN_RPOOL(enhsc, "5.1.6", e->e_rpool);
d1716 1
a1716 1
		to->q_status = ENHSCN_RPOOL(enhsc, "5.1.3", e->e_rpool);
d1746 3
a1751 1
static SM_EVENT	*volatile DataTimeout = NULL;
d1754 1
a1754 1
smtpdata(m, mci, e, ctladdr, xstart)
a1757 2
	ADDRESS *ctladdr;
	time_t xstart;
d1760 1
a1766 1

d1770 1
a1770 1
	**	Then send the data (if there are valid recipients).
a1776 30

#if PIPELINING
	if (mci->mci_nextaddr != NULL)
	{
		char *oldto = e->e_to;

		/* pick up any pending RCPT responses for SMTP pipelining */
		while (mci->mci_nextaddr != NULL)
		{
			int r;

			e->e_to = mci->mci_nextaddr->q_paddr;
			r = smtprcptstat(mci->mci_nextaddr, m, mci, e);
			if (r != EX_OK)
			{
				markfailure(e, mci->mci_nextaddr, mci, r,
					    false);
				giveresponse(r, mci->mci_nextaddr->q_status, m,
					     mci, ctladdr, xstart, e,
					     mci->mci_nextaddr);
				if (r == EX_TEMPFAIL)
					mci->mci_nextaddr->q_state = QS_RETRY;
			}
			mci->mci_nextaddr = mci->mci_nextaddr->q_pchain;
		}
		e->e_to = oldto;
	}
#endif /* PIPELINING */

	/* now proceed with DATA phase */
d1778 1
a1778 2
	mci->mci_state = MCIS_DATA;
	sm_setproctitle(true, e, "%s %s: %s",
a1788 5
#if PIPELINING
		if (mci->mci_okrcpts <= 0)
			return mci->mci_retryrcpt ? EX_TEMPFAIL
						  : EX_UNAVAILABLE;
#endif /* PIPELINING */
a1802 5
#if PIPELINING
		if (mci->mci_okrcpts <= 0)
			return mci->mci_retryrcpt ? EX_TEMPFAIL
						  : EX_PROTOCOL;
#endif /* PIPELINING */
a1805 5
#if PIPELINING
	if (mci->mci_okrcpts > 0)
	{
#endif /* PIPELINING */

d1841 1
a1841 1
	DataTimeout = sm_setevent(timeout, datatimeout, 0);
d1844 6
a1854 7

	if (tTd(18, 101))
	{
		/* simulate a DATA timeout */
		(void) sleep(2);
	}

d1861 1
a1861 2
	if (DataTimeout != NULL)
		sm_clrevent(DataTimeout);
d1863 4
a1866 3
#if PIPELINING
	}
#endif /* PIPELINING */
d1868 15
a1882 11
#if _FFR_CATCH_BROKEN_MTAS
	if (sm_io_getinfo(mci->mci_in, SM_IO_IS_READABLE, NULL))
	{
		/* terminate the message */
		(void) sm_io_fprintf(mci->mci_out, SM_TIME_DEFAULT, ".%s",
				     m->m_eol);
		if (TrafficLogFile != NULL)
			(void) sm_io_fprintf(TrafficLogFile, SM_TIME_DEFAULT,
					     "%05d >>> .\n", (int) CurrentPid);
		if (Verbose)
			nmessage(">>> .");
d1884 6
a1889 8
		sm_syslog(LOG_CRIT, e->e_id,
			  "%.100s: SMTP DATA-1 protocol error: remote server returned response before final dot",
			  CurHostName);
		mci->mci_errno = EIO;
		mci->mci_state = MCIS_ERROR;
		mci_setstat(mci, EX_PROTOCOL, "5.5.0", NULL);
		smtpquit(m, mci, e);
		return EX_PROTOCOL;
d1891 1
a1891 1
#endif /* _FFR_CATCH_BROKEN_MTAS */
d1893 1
a1893 1
	if (sm_io_error(mci->mci_out))
d1904 1
a1904 1
	(void) sm_io_fprintf(mci->mci_out, SM_TIME_DEFAULT, ".%s", m->m_eol);
d1906 1
a1906 2
		(void) sm_io_fprintf(TrafficLogFile, SM_TIME_DEFAULT,
				     "%05d >>> .\n", (int) CurrentPid);
d1912 1
a1912 1
	sm_setproctitle(true, e, "%s %s: %s", qid_printname(e),
d1928 2
a1931 2
	else if (REPLYCLASS(r) != 5)
		rstat = xstat = EX_PROTOCOL;
d1938 2
d1945 1
a1945 3
	e->e_statmsg = sm_rpool_strdup_x(e->e_rpool, &SmtpReplyBuffer[r]);
	SmtpPhase = mci->mci_phase = "idle";
	sm_setproctitle(true, e, "%s: %s", CurHostName, mci->mci_phase);
d1958 1
a1961 8
	int save_errno = errno;

	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

d1965 1
d1976 2
a1977 3
		/* reset the timeout */
		DataTimeout = sm_sigsafe_setevent(timeout, datatimeout, 0);
		DataProgress = false;
d1981 1
a1981 8
		/* event is done */
		DataTimeout = NULL;
	}

	/* if no progress was made or problem resetting event, die now */
	if (DataTimeout == NULL)
	{
		errno = ETIMEDOUT;
a1983 1
	errno = save_errno;
d2004 1
a2004 1
	int status, xstat;
a2007 1

a2014 1
	xstat = EX_NOTSTICKY;
d2017 2
d2020 1
a2020 3
		status = xstat = EX_OK;
	else if (REPLYCLASS(r) != 5)
		status = xstat = EX_PROTOCOL;
d2025 2
d2032 2
a2033 2
	e->e_statmsg = sm_rpool_strdup_x(e->e_rpool, &SmtpReplyBuffer[r]);
	mci_setstat(mci, xstat, ENHSCN(enhsc, smtptodsn(r)),
a2066 1
	char *oldcurhost;
a2067 1
	oldcurhost = CurHostName;
a2071 4
#if PIPELINING
	mci->mci_okrcpts = 0;
#endif /* PIPELINING */

d2079 1
a2079 1
	SuprErrs = true;
d2094 1
a2094 1
			goto end;
a2115 4

  end:
	CurHostName = oldcurhost;
	return;
a2118 11
**
**	Parameters:
**		m -- a pointer to the mailer.
**		mci -- the mailer connection information.
**		e -- the current envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		closes the connection if there is no reply to RSET.
a2132 4
#if PIPELINING
	mci->mci_okrcpts = 0;
#endif /* PIPELINING */

a2156 9
**
**	Parameters:
**		mci -- the mailer connection information.
**
**	Returns:
**		none.
**
**	Side Effects:
**		closes the connection if there is no reply to RSET.
a2189 1
**		enhstat -- optional, returns enhanced error code string (if set)
d2209 1
a2209 1
	bool firstline = true;
a2213 9
	/*
	**  Flush the output before reading response.
	**
	**	For SMTP pipelining, it would be better if we didn't do
	**	this if there was already data waiting to be read.  But
	**	to do it properly means pushing it to the I/O library,
	**	since it really needs to be done below the buffer layer.
	*/

d2215 1
a2215 1
		(void) sm_io_flush(mci->mci_out, SM_TIME_DEFAULT);
d2218 1
a2218 1
		sm_dprintf("reply\n");
d2230 2
a2231 2
		if (e->e_xfp != NULL)	/* for debugging */
			(void) sm_io_flush(e->e_xfp, SM_TIME_DEFAULT);
d2238 1
a2238 1
			(void) sm_io_flush(mci->mci_out, SM_TIME_DEFAULT);
a2241 1
		save_errno = errno;
a2249 1
			errno = save_errno;
d2251 1
a2251 1
#ifdef ECONNRESET
d2253 1
a2253 1
#else /* ECONNRESET */
d2255 1
a2255 1
#endif /* ECONNRESET */
d2259 1
a2259 1
			HoldErrs = true;
d2261 1
a2261 1
			       CURHOSTNAME);
d2271 1
d2273 1
a2273 1
#if XDEBUG
d2276 1
d2281 7
a2287 5
					(void) sm_snprintf(p,
							   SPACELEFT(wbuf, p),
							   "%s... ",
							   shortenstring(e->e_to, MAXSHORTSTR));
					p += strlen(p);
d2289 3
a2291 3
				(void) sm_snprintf(p, SPACELEFT(wbuf, p),
						   "reply(%.100s) during %s",
						   CURHOSTNAME, SmtpPhase);
d2294 2
a2295 1
#endif /* XDEBUG */
a2296 1
			errno = save_errno;
d2299 1
a2299 1
		fixcrlf(bufp, true);
d2309 4
a2312 5
				(void) sm_io_fprintf(CurEnv->e_xfp,
						     SM_TIME_DEFAULT,
						     "... while talking to %s:\n",
						     CURHOSTNAME);
				SmtpNeedIntro = false;
d2315 1
a2315 2
				(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
						     ">>> %s\n", SmtpMsgBuffer);
d2319 1
a2319 2
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
					     "<<< %s\n", bufp);
d2339 1
a2339 1
		firstline = false;
d2362 3
a2364 2
	if (SmtpReplyBuffer[0] == '4')
		(void) sm_strlcpy(SmtpError, SmtpReplyBuffer, sizeof SmtpError);
d2393 1
a2393 1
#ifdef __STDC__
d2395 1
a2395 1
#else /* __STDC__ */
d2401 1
a2401 1
#endif /* __STDC__ */
d2403 1
a2403 1
	SM_VA_LOCAL_DECL
d2405 3
a2407 3
	SM_VA_START(ap, mci);
	(void) sm_vsnprintf(SmtpMsgBuffer, sizeof SmtpMsgBuffer, f, ap);
	SM_VA_END(ap);
d2412 2
a2413 3
		(void) sm_io_fprintf(TrafficLogFile, SM_TIME_DEFAULT,
				     "%05d >>> %s\n", (int) CurrentPid,
				     SmtpMsgBuffer);
d2416 2
a2417 3
		(void) sm_io_fprintf(mci->mci_out, SM_TIME_DEFAULT, "%s%s",
				     SmtpMsgBuffer, m == NULL ? "\r\n"
							      : m->m_eol);
d2421 1
a2421 1
		sm_dprintf("smtpmessage: NULL mci_out\n");
d2424 2
@


