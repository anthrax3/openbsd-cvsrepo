head	1.8;
access;
symbols
	OPENBSD_5_6:1.7.0.6
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.6.0.28
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.26
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.24
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.22
	OPENBSD_5_0:1.6.0.20
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.18
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.16
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.12
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.14
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.10
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.8
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.6
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.4
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.5.0.22
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.20
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.18
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.16
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.14
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.12
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.8
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.10
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.7;
commitid	M7i5giHIoz3DMlTU;

1.7
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.29.01.31.14;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.15.21.09.07;	author millert;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.04.02.19.05.43;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.43;	author millert;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.10;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.50;	author millert;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	2001.05.31.00.31.29;	author miod;	state Exp;
branches;
next	;

1.2.2.1
date	2001.05.31.01.47.55;	author jason;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2001 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>

SM_RCSID("@@(#)$Sendmail: arpadate.c,v 8.32 2013/11/22 20:51:55 ca Exp $")

/*
**  ARPADATE -- Create date in ARPANET format
**
**	Parameters:
**		ud -- unix style date string.  if NULL, one is created.
**
**	Returns:
**		pointer to an ARPANET date field
**
**	Side Effects:
**		none
**
**	WARNING:
**		date is stored in a local buffer -- subsequent
**		calls will overwrite.
**
**	Bugs:
**		Timezone is computed from local time, rather than
**		from wherever (and whenever) the message was sent.
**		To do better is very hard.
**
**		Some sites are now inserting the timezone into the
**		local date.  This routine should figure out what
**		the format is and work appropriately.
*/

#ifndef TZNAME_MAX
# define TZNAME_MAX	50	/* max size of timezone */
#endif /* ! TZNAME_MAX */

/* values for TZ_TYPE */
#define TZ_NONE		0	/* no character timezone support */
#define TZ_TM_NAME	1	/* use tm->tm_name */
#define TZ_TM_ZONE	2	/* use tm->tm_zone */
#define TZ_TZNAME	3	/* use tzname[] */
#define TZ_TIMEZONE	4	/* use timezone() */

char *
arpadate(ud)
	register char *ud;
{
	register char *p;
	register char *q;
	register int off;
	register int i;
	register struct tm *lt;
	time_t t;
	struct tm gmt;
	char *tz;
	static char b[43 + TZNAME_MAX];

	/*
	**  Get current time.
	**	This will be used if a null argument is passed and
	**	to resolve the timezone.
	*/

	/* SM_REQUIRE(ud == NULL || strlen(ud) >= 23); */
	t = curtime();
	if (ud == NULL)
		ud = ctime(&t);

	/*
	**  Crack the UNIX date line in a singularly unoriginal way.
	*/

	q = b;

	p = &ud[0];		/* Mon */
	*q++ = *p++;
	*q++ = *p++;
	*q++ = *p++;
	*q++ = ',';
	*q++ = ' ';

	p = &ud[8];		/* 16 */
	if (*p == ' ')
		p++;
	else
		*q++ = *p++;
	*q++ = *p++;
	*q++ = ' ';

	p = &ud[4];		/* Sep */
	*q++ = *p++;
	*q++ = *p++;
	*q++ = *p++;
	*q++ = ' ';

	p = &ud[20];		/* 1979 */
	*q++ = *p++;
	*q++ = *p++;
	*q++ = *p++;
	*q++ = *p++;
	*q++ = ' ';

	p = &ud[11];		/* 01:03:52 */
	for (i = 8; i > 0; i--)
		*q++ = *p++;

	/*
	**  should really get the timezone from the time in "ud" (which
	**  is only different if a non-null arg was passed which is different
	**  from the current time), but for all practical purposes, returning
	**  the current local zone will do (its all that is ever needed).
	*/

	gmt = *gmtime(&t);
	lt = localtime(&t);

	off = (lt->tm_hour - gmt.tm_hour) * 60 + lt->tm_min - gmt.tm_min;

	/* assume that offset isn't more than a day ... */
	if (lt->tm_year < gmt.tm_year)
		off -= 24 * 60;
	else if (lt->tm_year > gmt.tm_year)
		off += 24 * 60;
	else if (lt->tm_yday < gmt.tm_yday)
		off -= 24 * 60;
	else if (lt->tm_yday > gmt.tm_yday)
		off += 24 * 60;

	*q++ = ' ';
	if (off == 0)
	{
		*q++ = 'G';
		*q++ = 'M';
		*q++ = 'T';
	}
	else
	{
		tz = NULL;
#if TZ_TYPE == TZ_TM_NAME
		tz = lt->tm_name;
#endif /* TZ_TYPE == TZ_TM_NAME */
#if TZ_TYPE == TZ_TM_ZONE
		tz = lt->tm_zone;
#endif /* TZ_TYPE == TZ_TM_ZONE */
#if TZ_TYPE == TZ_TZNAME
		{
			extern char *tzname[];

			if (lt->tm_isdst > 0)
				tz = tzname[1];
			else if (lt->tm_isdst == 0)
				tz = tzname[0];
			else
				tz = NULL;
		}
#endif /* TZ_TYPE == TZ_TZNAME */
#if TZ_TYPE == TZ_TIMEZONE
		{
			extern char *timezone();

			tz = timezone(off, lt->tm_isdst);
		}
#endif /* TZ_TYPE == TZ_TIMEZONE */
		if (off < 0)
		{
			off = -off;
			*q++ = '-';
		}
		else
			*q++ = '+';

		if (off >= 24*60)		/* should be impossible */
			off = 23*60+59;		/* if not, insert silly value */

		*q++ = (off / 600) + '0';
		*q++ = (off / 60) % 10 + '0';
		off %= 60;
		*q++ = (off / 10) + '0';
		*q++ = (off % 10) + '0';
		if (tz != NULL && *tz != '\0')
		{
			*q++ = ' ';
			*q++ = '(';
			while (*tz != '\0' && q < &b[sizeof(b) - 3])
				*q++ = *tz++;
			*q++ = ')';
		}
	}
	*q = '\0';

	return b;
}
@


1.7
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.6
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: arpadate.c,v 8.31 2006/08/15 23:24:55 ca Exp $")
@


1.5
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: arpadate.c,v 8.30 2001/09/11 04:05:12 gshapiro Exp $")
d195 1
a195 1
			while (*tz != '\0' && q < &b[sizeof b - 3])
@


1.4
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: arpadate.c,v 8.28 2001/02/14 14:45:47 ca Exp $")
@


1.3
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998, 1999, 2001 Sendmail, Inc. and its suppliers.
d14 1
a14 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: arpadate.c,v 8.23.20.2 2001/05/07 22:07:26 gshapiro Exp $";
#endif /* ! lint */
d16 1
a16 1
#include <sendmail.h>
d75 1
@


1.2
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998, 1999 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: arpadate.c,v 8.23 1999/09/23 19:59:18 ca Exp $";
d120 6
a125 5
	 * should really get the timezone from the time in "ud" (which
	 * is only different if a non-null arg was passed which is different
	 * from the current time), but for all practical purposes, returning
	 * the current local zone will do (its all that is ever needed).
	 */
@


1.2.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998, 1999, 2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: arpadate.c,v 8.23.20.2 2001/05/07 22:07:26 gshapiro Exp $";
d120 5
a124 6
	**  should really get the timezone from the time in "ud" (which
	**  is only different if a non-null arg was passed which is different
	**  from the current time), but for all practical purposes, returning
	**  the current local zone will do (its all that is ever needed).
	*/

@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.1.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998, 1999, 2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: arpadate.c,v 8.23.20.2 2001/05/07 22:07:26 gshapiro Exp $";
d120 5
a124 6
	**  should really get the timezone from the time in "ud" (which
	**  is only different if a non-null arg was passed which is different
	**  from the current time), but for all practical purposes, returning
	**  the current local zone will do (its all that is ever needed).
	*/

@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Id: arpadate.c,v 8.23 1999/09/23 19:59:18 ca Exp $";
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d14 4
a19 2
SM_RCSID("@@(#)$Sendmail: arpadate.c,v 8.28 2001/02/14 14:45:47 ca Exp $")

a76 1
	/* SM_REQUIRE(ud == NULL || strlen(ud) >= 23); */
d120 5
a124 6
	**  should really get the timezone from the time in "ud" (which
	**  is only different if a non-null arg was passed which is different
	**  from the current time), but for all practical purposes, returning
	**  the current local zone will do (its all that is ever needed).
	*/

@


