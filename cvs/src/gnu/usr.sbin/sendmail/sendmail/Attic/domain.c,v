head	1.19;
access;
symbols
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.10
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.8
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.18
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.16
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.12
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.14
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.10
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.8
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.6
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.18;
commitid	M7i5giHIoz3DMlTU;

1.18
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2011.05.17.15.54.23;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.13.13.01.48;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.08.16.00.51;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.16.00.21.30;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.24.03.59.27;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.17.17.31.40;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.03.17.31.21;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.15.02.23.35;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.03.17.25.47;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.18.00.49.28;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.01.17.18.30;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.28.02.43.54;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.15.21.09.08;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.02.19.05.45;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.45;	author millert;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.13;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.50;	author millert;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	2001.05.31.00.31.34;	author miod;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2004, 2006, 2010 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1986, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>
#include "map.h"

#if NAMED_BIND
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.205 2013/11/22 20:51:55 ca Exp $ (with name server)")
#else /* NAMED_BIND */
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.205 2013/11/22 20:51:55 ca Exp $ (without name server)")
#endif /* NAMED_BIND */

#if NAMED_BIND

# include <arpa/inet.h>


# ifndef MXHOSTBUFSIZE
#  define MXHOSTBUFSIZE	(128 * MAXMXHOSTS)
# endif /* ! MXHOSTBUFSIZE */

static char	MXHostBuf[MXHOSTBUFSIZE];
#if (MXHOSTBUFSIZE < 2) || (MXHOSTBUFSIZE >= INT_MAX/2)
	ERROR: _MXHOSTBUFSIZE is out of range
#endif /* (MXHOSTBUFSIZE < 2) || (MXHOSTBUFSIZE >= INT_MAX/2) */

# ifndef MAXDNSRCH
#  define MAXDNSRCH	6	/* number of possible domains to search */
# endif /* ! MAXDNSRCH */

# ifndef RES_DNSRCH_VARIABLE
#  define RES_DNSRCH_VARIABLE	_res.dnsrch
# endif /* ! RES_DNSRCH_VARIABLE */

# ifndef NO_DATA
#  define NO_DATA	NO_ADDRESS
# endif /* ! NO_DATA */

# ifndef HFIXEDSZ
#  define HFIXEDSZ	12	/* sizeof(HEADER) */
# endif /* ! HFIXEDSZ */

# define MAXCNAMEDEPTH	10	/* maximum depth of CNAME recursion */

# if defined(__RES) && (__RES >= 19940415)
#  define RES_UNC_T	char *
# else /* defined(__RES) && (__RES >= 19940415) */
#  define RES_UNC_T	unsigned char *
# endif /* defined(__RES) && (__RES >= 19940415) */

static int	mxrand __P((char *));
static int	fallbackmxrr __P((int, unsigned short *, char **));

/*
**  GETFALLBACKMXRR -- get MX resource records for fallback MX host.
**
**	We have to initialize this once before doing anything else.
**	Moreover, we have to repeat this from time to time to avoid
**	stale data, e.g., in persistent queue runners.
**	This should be done in a parent process so the child
**	processes have the right data.
**
**	Parameters:
**		host -- the name of the fallback MX host.
**
**	Returns:
**		number of MX records.
**
**	Side Effects:
**		Populates NumFallbackMXHosts and fbhosts.
**		Sets renewal time (based on TTL).
*/

int NumFallbackMXHosts = 0;	/* Number of fallback MX hosts (after MX expansion) */
static char *fbhosts[MAXMXHOSTS + 1];

int
getfallbackmxrr(host)
	char *host;
{
	int i, rcode;
	int ttl;
	static time_t renew = 0;

#if 0
	/* This is currently done before this function is called. */
	if (host == NULL || *host == '\0')
		return 0;
#endif /* 0 */
	if (NumFallbackMXHosts > 0 && renew > curtime())
		return NumFallbackMXHosts;
	if (host[0] == '[')
	{
		fbhosts[0] = host;
		NumFallbackMXHosts = 1;
	}
	else
	{
		/* free old data */
		for (i = 0; i < NumFallbackMXHosts; i++)
			sm_free(fbhosts[i]);

		/* get new data */
		NumFallbackMXHosts = getmxrr(host, fbhosts, NULL, false,
					     &rcode, false, &ttl);
		renew = curtime() + ttl;
		for (i = 0; i < NumFallbackMXHosts; i++)
			fbhosts[i] = newstr(fbhosts[i]);
	}
	return NumFallbackMXHosts;
}

/*
**  FALLBACKMXRR -- add MX resource records for fallback MX host to list.
**
**	Parameters:
**		nmx -- current number of MX records.
**		prefs -- array of preferences.
**		mxhosts -- array of MX hosts (maximum size: MAXMXHOSTS)
**
**	Returns:
**		new number of MX records.
**
**	Side Effects:
**		If FallbackMX was set, it appends the MX records for
**		that host to mxhosts (and modifies prefs accordingly).
*/

static int
fallbackmxrr(nmx, prefs, mxhosts)
	int nmx;
	unsigned short *prefs;
	char **mxhosts;
{
	int i;

	for (i = 0; i < NumFallbackMXHosts && nmx < MAXMXHOSTS; i++)
	{
		if (nmx > 0)
			prefs[nmx] = prefs[nmx - 1] + 1;
		else
			prefs[nmx] = 0;
		mxhosts[nmx++] = fbhosts[i];
	}
	return nmx;
}

/*
**  GETMXRR -- get MX resource records for a domain
**
**	Parameters:
**		host -- the name of the host to MX.
**		mxhosts -- a pointer to a return buffer of MX records.
**		mxprefs -- a pointer to a return buffer of MX preferences.
**			If NULL, don't try to populate.
**		droplocalhost -- If true, all MX records less preferred
**			than the local host (as determined by $=w) will
**			be discarded.
**		rcode -- a pointer to an EX_ status code.
**		tryfallback -- add also fallback MX host?
**		pttl -- pointer to return TTL (can be NULL).
**
**	Returns:
**		The number of MX records found.
**		-1 if there is an internal failure.
**		If no MX records are found, mxhosts[0] is set to host
**			and 1 is returned.
**
**	Side Effects:
**		The entries made for mxhosts point to a static array
**		MXHostBuf[MXHOSTBUFSIZE], so the data needs to be copied,
**		if it must be preserved across calls to this function.
*/

int
getmxrr(host, mxhosts, mxprefs, droplocalhost, rcode, tryfallback, pttl)
	char *host;
	char **mxhosts;
	unsigned short *mxprefs;
	bool droplocalhost;
	int *rcode;
	bool tryfallback;
	int *pttl;
{
	register unsigned char *eom, *cp;
	register int i, j, n;
	int nmx = 0;
	register char *bp;
	HEADER *hp;
	querybuf answer;
	int ancount, qdcount, buflen;
	bool seenlocal = false;
	unsigned short pref, type;
	unsigned short localpref = 256;
	char *fallbackMX = FallbackMX;
	bool trycanon = false;
	unsigned short *prefs;
	int (*resfunc) __P((const char *, int, int, u_char *, int));
	unsigned short prefer[MAXMXHOSTS];
	int weight[MAXMXHOSTS];
	int ttl = 0;
	extern int res_query(), res_search();

	if (tTd(8, 2))
		sm_dprintf("getmxrr(%s, droplocalhost=%d)\n",
			   host, droplocalhost);
	*rcode = EX_OK;
	if (pttl != NULL)
		*pttl = SM_DEFAULT_TTL;
	if (*host == '\0')
		return 0;

	if ((fallbackMX != NULL && droplocalhost &&
	     wordinclass(fallbackMX, 'w')) || !tryfallback)
	{
		/* don't use fallback for this pass */
		fallbackMX = NULL;
	}

	if (mxprefs != NULL)
		prefs = mxprefs;
	else
		prefs = prefer;

	/* efficiency hack -- numeric or non-MX lookups */
	if (host[0] == '[')
		goto punt;

	/*
	**  If we don't have MX records in our host switch, don't
	**  try for MX records.  Note that this really isn't "right",
	**  since we might be set up to try NIS first and then DNS;
	**  if the host is found in NIS we really shouldn't be doing
	**  MX lookups.  However, that should be a degenerate case.
	*/

	if (!UseNameServer)
		goto punt;
	if (HasWildcardMX && ConfigLevel >= 6)
		resfunc = res_query;
	else
		resfunc = res_search;

	errno = 0;
	n = (*resfunc)(host, C_IN, T_MX, (unsigned char *) &answer,
		       sizeof(answer));
	if (n < 0)
	{
		if (tTd(8, 1))
			sm_dprintf("getmxrr: res_search(%s) failed (errno=%d, h_errno=%d)\n",
				host, errno, h_errno);
		switch (h_errno)
		{
		  case NO_DATA:
			trycanon = true;
			/* FALLTHROUGH */

		  case NO_RECOVERY:
			/* no MX data on this host */
			goto punt;

		  case HOST_NOT_FOUND:
# if BROKEN_RES_SEARCH
		  case 0:	/* Ultrix resolver retns failure w/ h_errno=0 */
# endif /* BROKEN_RES_SEARCH */
			/* host doesn't exist in DNS; might be in /etc/hosts */
			trycanon = true;
			*rcode = EX_NOHOST;
			goto punt;

		  case TRY_AGAIN:
		  case -1:
			/* couldn't connect to the name server */
			if (fallbackMX != NULL)
			{
				/* name server is hosed -- push to fallback */
				return fallbackmxrr(nmx, prefs, mxhosts);
			}
			/* it might come up later; better queue it up */
			*rcode = EX_TEMPFAIL;
			break;

		  default:
			syserr("getmxrr: res_search (%s) failed with impossible h_errno (%d)",
				host, h_errno);
			*rcode = EX_OSERR;
			break;
		}

		/* irreconcilable differences */
		return -1;
	}

	/* avoid problems after truncation in tcp packets */
	if (n > sizeof(answer))
		n = sizeof(answer);

	/* find first satisfactory answer */
	hp = (HEADER *)&answer;
	cp = (unsigned char *)&answer + HFIXEDSZ;
	eom = (unsigned char *)&answer + n;
	for (qdcount = ntohs((unsigned short) hp->qdcount);
	     qdcount--;
	     cp += n + QFIXEDSZ)
	{
		if ((n = dn_skipname(cp, eom)) < 0)
			goto punt;
	}

	/* NOTE: see definition of MXHostBuf! */
	buflen = sizeof(MXHostBuf) - 1;
	SM_ASSERT(buflen > 0);
	bp = MXHostBuf;
	ancount = ntohs((unsigned short) hp->ancount);

	/* See RFC 1035 for layout of RRs. */
	/* XXX leave room for FallbackMX ? */
	while (--ancount >= 0 && cp < eom && nmx < MAXMXHOSTS - 1)
	{
		if ((n = dn_expand((unsigned char *)&answer, eom, cp,
				   (RES_UNC_T) bp, buflen)) < 0)
			break;
		cp += n;
		GETSHORT(type, cp);
		cp += INT16SZ;		/* skip over class */
		GETLONG(ttl, cp);
		GETSHORT(n, cp);	/* rdlength */
		if (type != T_MX)
		{
			if (tTd(8, 8) || _res.options & RES_DEBUG)
				sm_dprintf("unexpected answer type %d, size %d\n",
					type, n);
			cp += n;
			continue;
		}
		GETSHORT(pref, cp);
		if ((n = dn_expand((unsigned char *)&answer, eom, cp,
				   (RES_UNC_T) bp, buflen)) < 0)
			break;
		cp += n;
		n = strlen(bp);
# if 0
		/* Can this happen? */
		if (n == 0)
		{
			if (LogLevel > 4)
				sm_syslog(LOG_ERR, NOQID,
					  "MX records for %s contain empty string",
					  host);
			continue;
		}
# endif /* 0 */
		if (wordinclass(bp, 'w'))
		{
			if (tTd(8, 3))
				sm_dprintf("found localhost (%s) in MX list, pref=%d\n",
					bp, pref);
			if (droplocalhost)
			{
				if (!seenlocal || pref < localpref)
					localpref = pref;
				seenlocal = true;
				continue;
			}
			weight[nmx] = 0;
		}
		else
			weight[nmx] = mxrand(bp);
		prefs[nmx] = pref;
		mxhosts[nmx++] = bp;
		bp += n;
		if (bp[-1] != '.')
		{
			*bp++ = '.';
			n++;
		}
		*bp++ = '\0';
		if (buflen < n + 1)
		{
			/* don't want to wrap buflen */
			break;
		}
		buflen -= n + 1;
	}

	/* return only one TTL entry, that should be sufficient */
	if (ttl > 0 && pttl != NULL)
		*pttl = ttl;

	/* sort the records */
	for (i = 0; i < nmx; i++)
	{
		for (j = i + 1; j < nmx; j++)
		{
			if (prefs[i] > prefs[j] ||
			    (prefs[i] == prefs[j] && weight[i] > weight[j]))
			{
				register int temp;
				register char *temp1;

				temp = prefs[i];
				prefs[i] = prefs[j];
				prefs[j] = temp;
				temp1 = mxhosts[i];
				mxhosts[i] = mxhosts[j];
				mxhosts[j] = temp1;
				temp = weight[i];
				weight[i] = weight[j];
				weight[j] = temp;
			}
		}
		if (seenlocal && prefs[i] >= localpref)
		{
			/* truncate higher preference part of list */
			nmx = i;
		}
	}

	/* delete duplicates from list (yes, some bozos have duplicates) */
	for (i = 0; i < nmx - 1; )
	{
		if (sm_strcasecmp(mxhosts[i], mxhosts[i + 1]) != 0)
			i++;
		else
		{
			/* compress out duplicate */
			for (j = i + 1; j < nmx; j++)
			{
				mxhosts[j] = mxhosts[j + 1];
				prefs[j] = prefs[j + 1];
			}
			nmx--;
		}
	}

	if (nmx == 0)
	{
punt:
		if (seenlocal)
		{
			struct hostent *h = NULL;

			/*
			**  If we have deleted all MX entries, this is
			**  an error -- we should NEVER send to a host that
			**  has an MX, and this should have been caught
			**  earlier in the config file.
			**
			**  Some sites prefer to go ahead and try the
			**  A record anyway; that case is handled by
			**  setting TryNullMXList.  I believe this is a
			**  bad idea, but it's up to you....
			*/

			if (TryNullMXList)
			{
				SM_SET_H_ERRNO(0);
				errno = 0;
				h = sm_gethostbyname(host, AF_INET);
				if (h == NULL)
				{
					if (errno == ETIMEDOUT ||
					    h_errno == TRY_AGAIN ||
					    (errno == ECONNREFUSED &&
					     UseNameServer))
					{
						*rcode = EX_TEMPFAIL;
						return -1;
					}
# if NETINET6
					SM_SET_H_ERRNO(0);
					errno = 0;
					h = sm_gethostbyname(host, AF_INET6);
					if (h == NULL &&
					    (errno == ETIMEDOUT ||
					     h_errno == TRY_AGAIN ||
					     (errno == ECONNREFUSED &&
					      UseNameServer)))
					{
						*rcode = EX_TEMPFAIL;
						return -1;
					}
# endif /* NETINET6 */
				}
			}

			if (h == NULL)
			{
				*rcode = EX_CONFIG;
				syserr("MX list for %s points back to %s",
				       host, MyHostName);
				return -1;
			}
# if NETINET6
			freehostent(h);
			h = NULL;
# endif /* NETINET6 */
		}
		if (strlen(host) >= sizeof(MXHostBuf))
		{
			*rcode = EX_CONFIG;
			syserr("Host name %s too long",
			       shortenstring(host, MAXSHORTSTR));
			return -1;
		}
		(void) sm_strlcpy(MXHostBuf, host, sizeof(MXHostBuf));
		mxhosts[0] = MXHostBuf;
		prefs[0] = 0;
		if (host[0] == '[')
		{
			register char *p;
# if NETINET6
			struct sockaddr_in6 tmp6;
# endif /* NETINET6 */

			/* this may be an MX suppression-style address */
			p = strchr(MXHostBuf, ']');
			if (p != NULL)
			{
				*p = '\0';

				if (inet_addr(&MXHostBuf[1]) != INADDR_NONE)
				{
					nmx++;
					*p = ']';
				}
# if NETINET6
				else if (anynet_pton(AF_INET6, &MXHostBuf[1],
						     &tmp6.sin6_addr) == 1)
				{
					nmx++;
					*p = ']';
				}
# endif /* NETINET6 */
				else
				{
					trycanon = true;
					mxhosts[0]++;
				}
			}
		}
		if (trycanon &&
		    getcanonname(mxhosts[0], sizeof(MXHostBuf) - 2, false, pttl))
		{
			/* XXX MXHostBuf == "" ?  is that possible? */
			bp = &MXHostBuf[strlen(MXHostBuf)];
			if (bp[-1] != '.')
			{
				*bp++ = '.';
				*bp = '\0';
			}
			nmx = 1;
		}
	}

	/* if we have a default lowest preference, include that */
	if (fallbackMX != NULL && !seenlocal)
	{
		nmx = fallbackmxrr(nmx, prefs, mxhosts);
	}
	return nmx;
}
/*
**  MXRAND -- create a randomizer for equal MX preferences
**
**	If two MX hosts have equal preferences we want to randomize
**	the selection.  But in order for signatures to be the same,
**	we need to randomize the same way each time.  This function
**	computes a pseudo-random hash function from the host name.
**
**	Parameters:
**		host -- the name of the host.
**
**	Returns:
**		A random but repeatable value based on the host name.
*/

static int
mxrand(host)
	register char *host;
{
	int hfunc;
	static unsigned int seed;

	if (seed == 0)
	{
		seed = (int) curtime() & 0xffff;
		if (seed == 0)
			seed++;
	}

	if (tTd(17, 9))
		sm_dprintf("mxrand(%s)", host);

	hfunc = seed;
	while (*host != '\0')
	{
		int c = *host++;

		if (isascii(c) && isupper(c))
			c = tolower(c);
		hfunc = ((hfunc << 1) ^ c) % 2003;
	}

	hfunc &= 0xff;
	hfunc++;

	if (tTd(17, 9))
		sm_dprintf(" = %d\n", hfunc);
	return hfunc;
}
/*
**  BESTMX -- find the best MX for a name
**
**	This is really a hack, but I don't see any obvious way
**	to generalize it at the moment.
*/

/* ARGSUSED3 */
char *
bestmx_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	int nmx;
	int saveopts = _res.options;
	int i;
	ssize_t len = 0;
	char *result;
	char *mxhosts[MAXMXHOSTS + 1];
#if _FFR_BESTMX_BETTER_TRUNCATION
	char *buf;
#else /* _FFR_BESTMX_BETTER_TRUNCATION */
	char *p;
	char buf[PSBUFSIZE / 2];
#endif /* _FFR_BESTMX_BETTER_TRUNCATION */

	_res.options &= ~(RES_DNSRCH|RES_DEFNAMES);
	nmx = getmxrr(name, mxhosts, NULL, false, statp, false, NULL);
	_res.options = saveopts;
	if (nmx <= 0)
		return NULL;
	if (bitset(MF_MATCHONLY, map->map_mflags))
		return map_rewrite(map, name, strlen(name), NULL);
	if ((map->map_coldelim == '\0') || (nmx == 1))
		return map_rewrite(map, mxhosts[0], strlen(mxhosts[0]), av);

	/*
	**  We were given a -z flag (return all MXs) and there are multiple
	**  ones.  We need to build them all into a list.
	*/

#if _FFR_BESTMX_BETTER_TRUNCATION
	for (i = 0; i < nmx; i++)
	{
		if (strchr(mxhosts[i], map->map_coldelim) != NULL)
		{
			syserr("bestmx_map_lookup: MX host %.64s includes map delimiter character 0x%02X",
			       mxhosts[i], map->map_coldelim);
			return NULL;
		}
		len += strlen(mxhosts[i]) + 1;
		if (len < 0)
		{
			len -= strlen(mxhosts[i]) + 1;
			break;
		}
	}
	buf = (char *) sm_malloc(len);
	if (buf == NULL)
	{
		*statp = EX_UNAVAILABLE;
		return NULL;
	}
	*buf = '\0';
	for (i = 0; i < nmx; i++)
	{
		int end;

		end = sm_strlcat(buf, mxhosts[i], len);
		if (i != nmx && end + 1 < len)
		{
			buf[end] = map->map_coldelim;
			buf[end + 1] = '\0';
		}
	}

	/* Cleanly truncate for rulesets */
	truncate_at_delim(buf, PSBUFSIZE / 2, map->map_coldelim);
#else /* _FFR_BESTMX_BETTER_TRUNCATION */
	p = buf;
	for (i = 0; i < nmx; i++)
	{
		size_t slen;

		if (strchr(mxhosts[i], map->map_coldelim) != NULL)
		{
			syserr("bestmx_map_lookup: MX host %.64s includes map delimiter character 0x%02X",
			       mxhosts[i], map->map_coldelim);
			return NULL;
		}
		slen = strlen(mxhosts[i]);
		if (len + slen + 2 > sizeof(buf))
			break;
		if (i > 0)
		{
			*p++ = map->map_coldelim;
			len++;
		}
		(void) sm_strlcpy(p, mxhosts[i], sizeof(buf) - len);
		p += slen;
		len += slen;
	}
#endif /* _FFR_BESTMX_BETTER_TRUNCATION */

	result = map_rewrite(map, buf, len, av);
#if _FFR_BESTMX_BETTER_TRUNCATION
	sm_free(buf);
#endif /* _FFR_BESTMX_BETTER_TRUNCATION */
	return result;
}
/*
**  DNS_GETCANONNAME -- get the canonical name for named host using DNS
**
**	This algorithm tries to be smart about wildcard MX records.
**	This is hard to do because DNS doesn't tell is if we matched
**	against a wildcard or a specific MX.
**
**	We always prefer A & CNAME records, since these are presumed
**	to be specific.
**
**	If we match an MX in one pass and lose it in the next, we use
**	the old one.  For example, consider an MX matching *.FOO.BAR.COM.
**	A hostname bletch.foo.bar.com will match against this MX, but
**	will stop matching when we try bletch.bar.com -- so we know
**	that bletch.foo.bar.com must have been right.  This fails if
**	there was also an MX record matching *.BAR.COM, but there are
**	some things that just can't be fixed.
**
**	Parameters:
**		host -- a buffer containing the name of the host.
**			This is a value-result parameter.
**		hbsize -- the size of the host buffer.
**		trymx -- if set, try MX records as well as A and CNAME.
**		statp -- pointer to place to store status.
**		pttl -- pointer to return TTL (can be NULL).
**
**	Returns:
**		true -- if the host matched.
**		false -- otherwise.
*/

bool
dns_getcanonname(host, hbsize, trymx, statp, pttl)
	char *host;
	int hbsize;
	bool trymx;
	int *statp;
	int *pttl;
{
	register unsigned char *eom, *ap;
	register char *cp;
	register int n;
	HEADER *hp;
	querybuf answer;
	int ancount, qdcount;
	int ret;
	char **domain;
	int type;
	int ttl = 0;
	char **dp;
	char *mxmatch;
	bool amatch;
	bool gotmx = false;
	int qtype;
	int initial;
	int loopcnt;
	char nbuf[SM_MAX(MAXPACKET, MAXDNAME*2+2)];
	char *searchlist[MAXDNSRCH + 2];

	if (tTd(8, 2))
		sm_dprintf("dns_getcanonname(%s, trymx=%d)\n", host, trymx);

	if ((_res.options & RES_INIT) == 0 && res_init() == -1)
	{
		*statp = EX_UNAVAILABLE;
		return false;
	}

	*statp = EX_OK;

	/*
	**  Initialize domain search list.  If there is at least one
	**  dot in the name, search the unmodified name first so we
	**  find "vse.CS" in Czechoslovakia instead of in the local
	**  domain (e.g., vse.CS.Berkeley.EDU).  Note that there is no
	**  longer a country named Czechoslovakia but this type of problem
	**  is still present.
	**
	**  Older versions of the resolver could create this
	**  list by tearing apart the host name.
	*/

	loopcnt = 0;
cnameloop:
	/* Check for dots in the name */
	for (cp = host, n = 0; *cp != '\0'; cp++)
		if (*cp == '.')
			n++;

	/*
	**  Build the search list.
	**	If there is at least one dot in name, start with a null
	**	domain to search the unmodified name first.
	**	If name does not end with a dot and search up local domain
	**	tree desired, append each local domain component to the
	**	search list; if name contains no dots and default domain
	**	name is desired, append default domain name to search list;
	**	else if name ends in a dot, remove that dot.
	*/

	dp = searchlist;
	if (n > 0)
		*dp++ = "";
	if (n >= 0 && *--cp != '.' && bitset(RES_DNSRCH, _res.options))
	{
		/* make sure there are less than MAXDNSRCH domains */
		for (domain = RES_DNSRCH_VARIABLE, ret = 0;
		     *domain != NULL && ret < MAXDNSRCH;
		     ret++)
			*dp++ = *domain++;
	}
	else if (n == 0 && bitset(RES_DEFNAMES, _res.options))
	{
		*dp++ = _res.defdname;
	}
	else if (*cp == '.')
	{
		*cp = '\0';
	}
	*dp = NULL;

	/*
	**  Now loop through the search list, appending each domain in turn
	**  name and searching for a match.
	*/

	mxmatch = NULL;
	initial = T_A;
# if NETINET6
	if (InetMode == AF_INET6)
		initial = T_AAAA;
# endif /* NETINET6 */
	qtype = initial;

	for (dp = searchlist; *dp != NULL; )
	{
		if (qtype == initial)
			gotmx = false;
		if (tTd(8, 5))
			sm_dprintf("dns_getcanonname: trying %s.%s (%s)\n",
				host, *dp,
# if NETINET6
				qtype == T_AAAA ? "AAAA" :
# endif /* NETINET6 */
				qtype == T_A ? "A" :
				qtype == T_MX ? "MX" :
				"???");
		errno = 0;
		ret = res_querydomain(host, *dp, C_IN, qtype,
				      answer.qb2, sizeof(answer.qb2));
		if (ret <= 0)
		{
			int save_errno = errno;

			if (tTd(8, 7))
				sm_dprintf("\tNO: errno=%d, h_errno=%d\n",
					   save_errno, h_errno);

			if (save_errno == ECONNREFUSED || h_errno == TRY_AGAIN)
			{
				/*
				**  the name server seems to be down or broken.
				*/

				SM_SET_H_ERRNO(TRY_AGAIN);
				if (**dp == '\0')
				{
					if (*statp == EX_OK)
						*statp = EX_TEMPFAIL;
					goto nexttype;
				}
				*statp = EX_TEMPFAIL;

				if (WorkAroundBrokenAAAA)
				{
					/*
					**  Only return if not TRY_AGAIN as an
					**  attempt with a different qtype may
					**  succeed (res_querydomain() calls
					**  res_query() calls res_send() which
					**  sets errno to ETIMEDOUT if the
					**  nameservers could be contacted but
					**  didn't give an answer).
					*/

					if (save_errno != ETIMEDOUT)
						return false;
				}
				else
					return false;
			}

nexttype:
			if (h_errno != HOST_NOT_FOUND)
			{
				/* might have another type of interest */
# if NETINET6
				if (qtype == T_AAAA)
				{
					qtype = T_A;
					continue;
				}
				else
# endif /* NETINET6 */
				if (qtype == T_A && !gotmx &&
				    (trymx || **dp == '\0'))
				{
					qtype = T_MX;
					continue;
				}
			}

			/* definite no -- try the next domain */
			dp++;
			qtype = initial;
			continue;
		}
		else if (tTd(8, 7))
			sm_dprintf("\tYES\n");

		/* avoid problems after truncation in tcp packets */
		if (ret > sizeof(answer))
			ret = sizeof(answer);
		SM_ASSERT(ret >= 0);

		/*
		**  Appear to have a match.  Confirm it by searching for A or
		**  CNAME records.  If we don't have a local domain
		**  wild card MX record, we will accept MX as well.
		*/

		hp = (HEADER *) &answer;
		ap = (unsigned char *) &answer + HFIXEDSZ;
		eom = (unsigned char *) &answer + ret;

		/* skip question part of response -- we know what we asked */
		for (qdcount = ntohs((unsigned short) hp->qdcount);
		     qdcount--;
		     ap += ret + QFIXEDSZ)
		{
			if ((ret = dn_skipname(ap, eom)) < 0)
			{
				if (tTd(8, 20))
					sm_dprintf("qdcount failure (%d)\n",
						ntohs((unsigned short) hp->qdcount));
				*statp = EX_SOFTWARE;
				return false;		/* ???XXX??? */
			}
		}

		amatch = false;
		for (ancount = ntohs((unsigned short) hp->ancount);
		     --ancount >= 0 && ap < eom;
		     ap += n)
		{
			n = dn_expand((unsigned char *) &answer, eom, ap,
				      (RES_UNC_T) nbuf, sizeof(nbuf));
			if (n < 0)
				break;
			ap += n;
			GETSHORT(type, ap);
			ap += INT16SZ;		/* skip over class */
			GETLONG(ttl, ap);
			GETSHORT(n, ap);	/* rdlength */
			switch (type)
			{
			  case T_MX:
				gotmx = true;
				if (**dp != '\0' && HasWildcardMX)
				{
					/*
					**  If we are using MX matches and have
					**  not yet gotten one, save this one
					**  but keep searching for an A or
					**  CNAME match.
					*/

					if (trymx && mxmatch == NULL)
						mxmatch = *dp;
					continue;
				}

				/*
				**  If we did not append a domain name, this
				**  must have been a canonical name to start
				**  with.  Even if we did append a domain name,
				**  in the absence of a wildcard MX this must
				**  still be a real MX match.
				**  Such MX matches are as good as an A match,
				**  fall through.
				*/
				/* FALLTHROUGH */

# if NETINET6
			  case T_AAAA:
# endif /* NETINET6 */
			  case T_A:
				/* Flag that a good match was found */
				amatch = true;

				/* continue in case a CNAME also exists */
				continue;

			  case T_CNAME:
				if (DontExpandCnames)
				{
					/* got CNAME -- guaranteed canonical */
					amatch = true;
					break;
				}

				if (loopcnt++ > MAXCNAMEDEPTH)
				{
					/*XXX should notify postmaster XXX*/
					message("DNS failure: CNAME loop for %s",
						host);
					if (CurEnv->e_message == NULL)
					{
						char ebuf[MAXLINE];

						(void) sm_snprintf(ebuf,
							sizeof(ebuf),
							"Deferred: DNS failure: CNAME loop for %.100s",
							host);
						CurEnv->e_message =
						    sm_rpool_strdup_x(
							CurEnv->e_rpool, ebuf);
					}
					SM_SET_H_ERRNO(NO_RECOVERY);
					*statp = EX_CONFIG;
					return false;
				}

				/* value points at name */
				if ((ret = dn_expand((unsigned char *)&answer,
						     eom, ap, (RES_UNC_T) nbuf,
						     sizeof(nbuf))) < 0)
					break;
				(void) sm_strlcpy(host, nbuf, hbsize);

				/*
				**  RFC 1034 section 3.6 specifies that CNAME
				**  should point at the canonical name -- but
				**  urges software to try again anyway.
				*/

				goto cnameloop;

			  default:
				/* not a record of interest */
				continue;
			}
		}

		if (amatch)
		{
			/*
			**  Got a good match -- either an A, CNAME, or an
			**  exact MX record.  Save it and get out of here.
			*/

			mxmatch = *dp;
			break;
		}

		/*
		**  Nothing definitive yet.
		**	If this was a T_A query and we haven't yet found a MX
		**		match, try T_MX if allowed to do so.
		**	Otherwise, try the next domain.
		*/

# if NETINET6
		if (qtype == T_AAAA)
			qtype = T_A;
		else
# endif /* NETINET6 */
		if (qtype == T_A && !gotmx && (trymx || **dp == '\0'))
			qtype = T_MX;
		else
		{
			qtype = initial;
			dp++;
		}
	}

	/* if nothing was found, we are done */
	if (mxmatch == NULL)
	{
		if (*statp == EX_OK)
			*statp = EX_NOHOST;
		return false;
	}

	/*
	**  Create canonical name and return.
	**  If saved domain name is null, name was already canonical.
	**  Otherwise append the saved domain name.
	*/

	(void) sm_snprintf(nbuf, sizeof(nbuf), "%.*s%s%.*s", MAXDNAME, host,
			   *mxmatch == '\0' ? "" : ".",
			   MAXDNAME, mxmatch);
	(void) sm_strlcpy(host, nbuf, hbsize);
	if (tTd(8, 5))
		sm_dprintf("dns_getcanonname: %s\n", host);
	*statp = EX_OK;

	/* return only one TTL entry, that should be sufficient */
	if (ttl > 0 && pttl != NULL)
		*pttl = ttl;
	return true;
}
#endif /* NAMED_BIND */
@


1.18
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.17
log
@Update to sendmail 8.14.5
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004, 2006, 2010 Sendmail, Inc. and its suppliers.
d18 1
a18 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.204 2010/06/29 15:35:33 ca Exp $ (with name server)")
d20 1
a20 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.204 2010/06/29 15:35:33 ca Exp $ (without name server)")
@


1.16
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004, 2006 Sendmail, Inc. and its suppliers.
d18 1
a18 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.202 2006/12/19 01:15:07 ca Exp $ (with name server)")
d20 1
a20 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.202 2006/12/19 01:15:07 ca Exp $ (without name server)")
a26 19

/*
**  The standard udp packet size PACKETSZ (512) is not sufficient for some
**  nameserver answers containing very many resource records. The resolver
**  may switch to tcp and retry if it detects udp packet overflow.
**  Also note that the resolver routines res_query and res_search return
**  the size of the *un*truncated answer in case the supplied answer buffer
**  it not big enough to accommodate the entire answer.
*/

# ifndef MAXPACKET
#  define MAXPACKET 8192	/* max packet size used internally by BIND */
# endif /* ! MAXPACKET */

typedef union
{
	HEADER		qb1;
	unsigned char	qb2[MAXPACKET];
} querybuf;
@


1.15
log
@Update to sendmail-8.13.8
@
text
@d15 1
d18 1
a18 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.199 2006/04/18 00:00:34 ca Exp $ (with name server)")
d20 1
a20 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.199 2006/04/18 00:00:34 ca Exp $ (without name server)")
d280 1
a280 1
				host == NULL ? "<NULL>" : host, errno, h_errno);
d528 1
a528 1
		if (strlen(host) >= sizeof MXHostBuf)
d535 1
a535 1
		(void) sm_strlcpy(MXHostBuf, host, sizeof MXHostBuf);
d572 1
a572 1
		    getcanonname(mxhosts[0], sizeof MXHostBuf - 2, false, pttl))
d734 1
a734 1
		if (len + slen + 2 > sizeof buf)
d741 1
a741 1
		(void) sm_strlcpy(p, mxhosts[i], sizeof buf - len);
d1009 1
a1009 1
				      (RES_UNC_T) nbuf, sizeof nbuf);
d1074 1
a1074 1
							sizeof ebuf,
d1153 1
a1153 1
	(void) sm_snprintf(nbuf, sizeof nbuf, "%.*s%s%.*s", MAXDNAME, host,
@


1.14
log
@update to sendmail 8.13.4
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.197 2005/03/04 00:54:42 ca Exp $ (with name server)")
d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.197 2005/03/04 00:54:42 ca Exp $ (without name server)")
d524 1
a524 1
			hp = NULL;
d975 1
a975 5
		if (ret < 0)
		{
			*statp = EX_SOFTWARE;
			return false;
		}
@


1.13
log
@Update to sendmail-8.13.2
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.195 2004/08/04 21:11:31 ca Exp $ (with name server)")
d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.195 2004/08/04 21:11:31 ca Exp $ (without name server)")
d235 3
a246 2

	*rcode = EX_OK;
@


1.12
log
@Update to sendmail.8.13.0
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.194 2004/01/14 01:47:34 ca Exp $ (with name server)")
d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.194 2004/01/14 01:47:34 ca Exp $ (without name server)")
d226 1
a226 1
	int (*resfunc)();
@


1.11
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.181.2.9 2003/08/11 23:23:40 gshapiro Exp $ (with name server)")
d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.181.2.9 2003/08/11 23:23:40 gshapiro Exp $ (without name server)")
a78 1
static char	*gethostalias __P((char *));
d98 1
a98 1
**		Populates NumFallBackMXHosts and fbhosts.
d102 1
a102 1
int NumFallBackMXHosts = 0;	/* Number of fallback MX hosts (after MX expansion) */
d118 2
a119 2
	if (NumFallBackMXHosts > 0 && renew > curtime())
		return NumFallBackMXHosts;
d123 1
a123 1
		NumFallBackMXHosts = 1;
d128 1
a128 1
		for (i = 0; i < NumFallBackMXHosts; i++)
d132 1
a132 1
		NumFallBackMXHosts = getmxrr(host, fbhosts, NULL, false,
d135 1
a135 1
		for (i = 0; i < NumFallBackMXHosts; i++)
d138 1
a138 1
	return NumFallBackMXHosts;
d153 1
a153 1
**		If FallBackMX was set, it appends the MX records for
d165 1
a165 1
	for (i = 0; i < NumFallBackMXHosts && nmx < MAXMXHOSTS; i++)
d223 1
a223 1
	char *fallbackMX = FallBackMX;
d344 1
a344 1
	/* XXX leave room for FallBackMX ? */
a806 1
	char *xp;
a840 18
	**  If this is a simple name, determine whether it matches an
	**  alias in the file defined by the environment variable HOSTALIASES.
	*/

	if (n == 0 && (xp = gethostalias(host)) != NULL)
	{
		if (loopcnt++ > MAXCNAMEDEPTH)
		{
			syserr("loop in ${HOSTALIASES} file");
		}
		else
		{
			(void) sm_strlcpy(host, xp, hbsize);
			goto cnameloop;
		}
	}

	/*
a915 1
# if _FFR_DONT_STOP_LOOKING
a921 1
# endif /* _FFR_DONT_STOP_LOOKING */
a942 1
# if _FFR_DONT_STOP_LOOKING
a943 1
# endif /* _FFR_DONT_STOP_LOOKING */
a1166 52
}

static char *
gethostalias(host)
	char *host;
{
	char *fname;
	SM_FILE_T *fp;
	register char *p = NULL;
	long sff = SFF_REGONLY;
	char buf[MAXLINE];
	static char hbuf[MAXDNAME];

	if (ResNoAliases)
		return NULL;
	if (DontLockReadFiles)
		sff |= SFF_NOLOCK;
	fname = getenv("HOSTALIASES");
	if (fname == NULL ||
	    (fp = safefopen(fname, O_RDONLY, 0, sff)) == NULL)
		return NULL;
	while (sm_io_fgets(fp, SM_TIME_DEFAULT, buf, sizeof buf) != NULL)
	{
		for (p = buf; p != '\0' && !(isascii(*p) && isspace(*p)); p++)
			continue;
		if (*p == 0)
		{
			/* syntax error */
			continue;
		}
		*p++ = '\0';
		if (sm_strcasecmp(buf, host) == 0)
			break;
	}

	if (sm_io_eof(fp))
	{
		/* no match */
		(void) sm_io_close(fp, SM_TIME_DEFAULT);
		return NULL;
	}
	(void) sm_io_close(fp, SM_TIME_DEFAULT);

	/* got a match; extract the equivalent name */
	while (*p != '\0' && isascii(*p) && isspace(*p))
		p++;
	host = p;
	while (*p != '\0' && !(isascii(*p) && isspace(*p)))
		p++;
	*p = '\0';
	(void) sm_strlcpy(hbuf, host, sizeof hbuf);
	return hbuf;
@


1.10
log
@Update to Sendmail 8.12.8; fixes a buffer overflow in the envelope
comments processing which may allow an attacker to gain root privileges.
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.181.2.6 2003/01/15 19:17:15 ca Exp $ (with name server)")
d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.181.2.6 2003/01/15 19:17:15 ca Exp $ (without name server)")
d236 2
a782 6
# if NETINET6
#  define SM_T_INITIAL	T_AAAA
# else /* NETINET6 */
#  define SM_T_INITIAL	T_A
# endif /* NETINET6 */

d806 1
d898 6
a903 1
	qtype = SM_T_INITIAL;
d907 1
a907 1
		if (qtype == SM_T_INITIAL)
d989 1
a989 1
			qtype = SM_T_INITIAL;
a1073 5
				/* Flag that a good match was found */
				amatch = true;

				/* continue in case a CNAME also exists */
				continue;
a1074 1

d1160 1
a1160 1
			qtype = SM_T_INITIAL;
@


1.9
log
@update to sendmail-8.12.6
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.181.2.1 2002/06/27 16:55:04 ca Exp $ (with name server)")
d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.181.2.1 2002/06/27 16:55:04 ca Exp $ (without name server)")
@


1.8
log
@Update to sendmail-8.12.4
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.181 2002/05/24 23:48:42 gshapiro Exp $ (with name server)")
d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.181 2002/05/24 23:48:42 gshapiro Exp $ (without name server)")
d667 1
a667 1
	nmx = getmxrr(name, mxhosts, NULL, false, statp, true, NULL);
@


1.7
log
@update to sendmail 8.12.3
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.180 2002/03/05 05:47:12 gshapiro Exp $ (with name server)")
d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.180 2002/03/05 05:47:12 gshapiro Exp $ (without name server)")
d813 1
a813 1
	char *searchlist[MAXDNSRCH+2];
@


1.6
log
@update to sendmail-8.12.2
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.177 2001/12/12 01:16:15 ca Exp $ (with name server)")
d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.177 2001/12/12 01:16:15 ca Exp $ (without name server)")
d934 8
d963 3
@


1.5
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.176 2001/09/22 17:52:42 gshapiro Exp $ (with name server)")
d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.176 2001/09/22 17:52:42 gshapiro Exp $ (without name server)")
d310 1
a310 1
			syserr("getmxrr: res_search (%s) failed with impossible h_errno (%d)\n",
@


1.4
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.172 2001/09/04 22:43:03 ca Exp $ (with name server)")
d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.172 2001/09/04 22:43:03 ca Exp $ (without name server)")
d83 1
a83 1
/*
d142 1
a142 1
/*
d177 1
a177 1
/*
d589 1
a589 1
/*
d638 1
a638 1
/*
d750 1
a750 1
/*
d921 2
d925 1
a925 1
					errno, h_errno);
d927 1
a927 1
			if (errno == ECONNREFUSED || h_errno == TRY_AGAIN)
d948 1
a948 1
					if (errno != ETIMEDOUT)
@


1.3
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d16 5
a20 8
#ifndef lint
# if NAMED_BIND
static char id[] = "@@(#)$Sendmail: domain.c,v 8.114.6.1.2.8 2001/02/12 21:40:19 gshapiro Exp $ (with name server)";
# else /* NAMED_BIND */
static char id[] = "@@(#)$Sendmail: domain.c,v 8.114.6.1.2.8 2001/02/12 21:40:19 gshapiro Exp $ (without name server)";
# endif /* NAMED_BIND */
#endif /* ! lint */

d26 1
d42 2
a43 2
	HEADER	qb1;
	u_char	qb2[MAXPACKET];
d51 3
a62 4
# ifndef MAX
#  define MAX(a, b)	((a) > (b) ? (a) : (b))
# endif /* ! MAX */

d76 1
a76 1
#  define RES_UNC_T	u_char *
d81 95
d185 1
a185 1
**		droplocalhost -- If TRUE, all MX records less preferred
d189 2
d197 5
d205 1
a205 1
getmxrr(host, mxhosts, mxprefs, droplocalhost, rcode)
d208 1
a208 1
	u_short *mxprefs;
d211 2
d214 1
a214 1
	register u_char *eom, *cp;
d221 3
a223 3
	bool seenlocal = FALSE;
	u_short pref, type;
	u_short localpref = 256;
d225 2
a226 2
	bool trycanon = FALSE;
	u_short *prefs;
d228 1
a228 1
	u_short prefer[MAXMXHOSTS];
d230 1
d234 2
a235 2
		dprintf("getmxrr(%s, droplocalhost=%d)\n",
			host, droplocalhost);
d237 2
a238 2
	if (fallbackMX != NULL && droplocalhost &&
	    wordinclass(fallbackMX, 'w'))
a250 1

d271 2
a272 1
	n = (*resfunc)(host, C_IN, T_MX, (u_char *) &answer, sizeof(answer));
d276 2
a277 2
			dprintf("getmxrr: res_search(%s) failed (errno=%d, h_errno=%d)\n",
			    (host == NULL) ? "<NULL>" : host, errno, h_errno);
d281 1
a281 1
			trycanon = TRUE;
d293 1
a293 1
			trycanon = TRUE;
d303 1
a303 6
				if (nmx > 0)
					prefs[nmx] = prefs[nmx - 1] + 1;
				else
					prefs[nmx] = 0;
				mxhosts[nmx++] = fallbackMX;
				return nmx;
d326 3
a328 3
	cp = (u_char *)&answer + HFIXEDSZ;
	eom = (u_char *)&answer + n;
	for (qdcount = ntohs((u_short)hp->qdcount);
d335 2
d338 1
d340 4
a343 1
	ancount = ntohs((u_short)hp->ancount);
d346 2
a347 2
		if ((n = dn_expand((u_char *)&answer,
		    eom, cp, (RES_UNC_T) bp, buflen)) < 0)
d351 3
a353 2
		cp += INT16SZ + INT32SZ;
		GETSHORT(n, cp);
d357 1
a357 1
				dprintf("unexpected answer type %d, size %d\n",
d363 1
a363 1
		if ((n = dn_expand((u_char *)&answer, eom, cp,
d367 12
d382 1
a382 1
				dprintf("found localhost (%s) in MX list, pref=%d\n",
d388 1
a388 1
				seenlocal = TRUE;
a396 1
		n = strlen(bp);
d404 5
d412 4
d448 1
a448 1
		if (strcasecmp(mxhosts[i], mxhosts[i + 1]) != 0)
d520 1
a520 1
# if _FFR_FREEHOSTENT && NETINET6
d523 1
a523 1
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d525 1
a525 1
		if (strlen(host) >= (SIZE_T) sizeof MXHostBuf)
d532 1
a532 1
		snprintf(MXHostBuf, sizeof MXHostBuf, "%s", host);
d554 2
a555 2
				else if (inet_pton(AF_INET6, &MXHostBuf[1],
						   &tmp6.sin6_addr) == 1)
d563 1
a563 1
					trycanon = TRUE;
d569 1
a569 1
		    getcanonname(mxhosts[0], sizeof MXHostBuf - 2, FALSE))
d571 1
d585 1
a585 5
		if (nmx > 0)
			prefs[nmx] = prefs[nmx - 1] + 1;
		else
			prefs[nmx] = 0;
		mxhosts[nmx++] = fallbackMX;
a586 1

a601 3
**
**	Side Effects:
**		none.
d619 1
a619 1
		dprintf("mxrand(%s)", host);
d635 1
a635 1
		dprintf(" = %d\n", hfunc);
d655 7
a661 1
	int i, len = 0;
a662 1
	char *mxhosts[MAXMXHOSTS + 1];
d664 1
d667 1
a667 1
	nmx = getmxrr(name, mxhosts, NULL, FALSE, statp);
d680 39
d722 1
a722 1
		int slen;
d738 1
a738 1
		(void) strlcpy(p, mxhosts[i], sizeof buf - len);
d742 7
a748 1
	return map_rewrite(map, buf, len, av);
d774 1
d777 2
a778 2
**		TRUE -- if the host matched.
**		FALSE -- otherwise.
d781 6
d788 1
a788 1
dns_getcanonname(host, hbsize, trymx, statp)
d793 1
d795 1
a795 1
	register u_char *eom, *ap;
d804 1
d808 1
a808 1
	bool gotmx = FALSE;
d812 1
a812 1
	char nbuf[MAX(MAXPACKET, MAXDNAME*2+2)];
d816 1
a816 1
		dprintf("dns_getcanonname(%s, trymx=%d)\n", host, trymx);
d821 1
a821 1
		return FALSE;
d849 1
d858 1
a858 1
			(void) strlcpy(host, xp, hbsize);
d901 1
a901 1
	qtype = T_ANY;
d905 2
a906 2
		if (qtype == T_ANY)
			gotmx = FALSE;
d908 1
a908 1
			dprintf("dns_getcanonname: trying %s.%s (%s)\n",
a909 1
				qtype == T_ANY ? "ANY" :
d922 1
a922 1
				dprintf("\tNO: errno=%d, h_errno=%d\n",
d928 1
a928 2
				**  the name server seems to be down or
				**  broken.
a933 14
				/*
				**  If the ANY query is larger than the
				**  UDP packet size, the resolver will
				**  fall back to TCP.  However, some
				**  misconfigured firewalls block 53/TCP
				**  so the ANY lookup fails whereas an MX
				**  or A record might work.  Therefore,
				**  don't fail on ANY queries.
				**
				**  The ANY query is really meant to prime
				**  the cache so this isn't dangerous.
				*/

#if _FFR_WORKAROUND_BROKEN_NAMESERVERS
d946 2
a947 3
					if (qtype != T_ANY &&
					    errno != ETIMEDOUT)
						return FALSE;
d949 2
a950 4
#else /* _FFR_WORKAROUND_BROKEN_NAMESERVERS */
				if (qtype != T_ANY)
					return FALSE;
#endif /* _FFR_WORKAROUND_BROKEN_NAMESERVERS */
a955 9
				if (qtype == T_ANY)
				{
# if NETINET6
					qtype = T_AAAA;
# else /* NETINET6 */
					qtype = T_A;
# endif /* NETINET6 */
					continue;
				}
d957 1
a957 1
				else if (qtype == T_AAAA)
d962 1
d964 2
a965 2
				else if (qtype == T_A && !gotmx &&
					 (trymx || **dp == '\0'))
d974 1
a974 1
			qtype = T_ANY;
d978 1
a978 1
			dprintf("\tYES\n");
d983 5
d996 2
a997 2
		ap = (u_char *) &answer + HFIXEDSZ;
		eom = (u_char *) &answer + ret;
d1000 1
a1000 1
		for (qdcount = ntohs((u_short)hp->qdcount);
d1007 2
a1008 2
					dprintf("qdcount failure (%d)\n",
						ntohs((u_short)hp->qdcount));
d1010 1
a1010 1
				return FALSE;		/* ???XXX??? */
d1014 2
a1015 2
		amatch = FALSE;
		for (ancount = ntohs((u_short)hp->ancount);
d1019 1
a1019 1
			n = dn_expand((u_char *) &answer, eom, ap,
d1025 3
a1027 2
			ap += INT16SZ + INT32SZ;
			GETSHORT(n, ap);
d1031 1
a1031 1
				gotmx = TRUE;
d1060 1
a1060 1
				amatch = TRUE;
d1068 1
a1068 1
				amatch = TRUE;
d1077 1
a1077 1
					amatch = TRUE;
d1090 2
a1091 1
						snprintf(ebuf, sizeof ebuf,
d1094 3
a1096 1
						CurEnv->e_message = newstr(ebuf);
d1100 1
a1100 1
					return FALSE;
d1104 3
a1106 2
				if ((ret = dn_expand((u_char *)&answer,
				    eom, ap, (RES_UNC_T) nbuf, sizeof(nbuf))) < 0)
d1108 1
a1108 1
				(void)strlcpy(host, nbuf, hbsize);
a1136 4
		**	If this was a T_ANY query, we don't really know what
		**		was returned -- it might have been a T_NS,
		**		for example.  Try T_A to be more specific
		**		during the next pass.
a1141 2
		if (qtype == T_ANY)
		{
d1143 1
a1143 7
			qtype = T_AAAA;
# else /* NETINET6 */
			qtype = T_A;
# endif /* NETINET6 */
		}
# if NETINET6
		else if (qtype == T_AAAA)
d1145 1
d1147 1
a1147 1
		else if (qtype == T_A && !gotmx && (trymx || **dp == '\0'))
d1151 1
a1151 1
			qtype = T_ANY;
d1161 1
a1161 1
		return FALSE;
d1170 4
a1173 4
	(void) snprintf(nbuf, sizeof nbuf, "%.*s%s%.*s", MAXDNAME, host,
			*mxmatch == '\0' ? "" : ".",
			MAXDNAME, mxmatch);
	(void) strlcpy(host, nbuf, hbsize);
d1175 1
a1175 1
		dprintf("dns_getcanonname: %s\n", host);
d1177 5
a1181 1
	return TRUE;
d1189 1
a1189 1
	FILE *fp;
d1195 2
d1203 1
a1203 1
	while (fgets(buf, sizeof buf, fp) != NULL)
d1213 1
a1213 1
		if (strcasecmp(buf, host) == 0)
d1217 1
a1217 1
	if (feof(fp))
d1220 1
a1220 1
		(void) fclose(fp);
d1223 1
a1223 1
	(void) fclose(fp);
d1232 1
a1232 1
	(void) strlcpy(hbuf, host, sizeof hbuf);
@


1.2
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d18 1
a18 1
static char id[] = "@@(#)$Sendmail: domain.c,v 8.114.6.1.2.6 2000/12/19 02:50:33 gshapiro Exp $ (with name server)";
d20 1
a20 1
static char id[] = "@@(#)$Sendmail: domain.c,v 8.114.6.1.2.6 2000/12/19 02:50:33 gshapiro Exp $ (without name server)";
d359 1
a359 1
				h_errno = 0;
d373 1
a373 1
					h_errno = 0;
d755 1
a755 1
				h_errno = TRY_AGAIN;
d772 11
a782 9
				/*
				**  Only return if not TRY_AGAIN as an
				**  attempt with a different qtype may
				**  succeed (res_querydomain() calls
				**  res_query() calls res_send() which
				**  sets errno to ETIMEDOUT if the
				**  nameservers could be contacted but
				**  didn't give an answer).
				*/
d784 4
a787 2
				if (qtype != T_ANY && errno != ETIMEDOUT)
					return FALSE;
d938 1
a938 1
					h_errno = NO_RECOVERY;
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
static char id[] = "@@(#)$Sendmail: domain.c,v 8.114 2000/02/01 05:49:56 gshapiro Exp $ (with name server)";
d20 1
a20 1
static char id[] = "@@(#)$Sendmail: domain.c,v 8.114 2000/02/01 05:49:56 gshapiro Exp $ (without name server)";
d24 1
d231 4
a234 1
	for (qdcount = ntohs(hp->qdcount); qdcount--; cp += n + QFIXEDSZ)
d237 1
d240 1
a240 1
	ancount = ntohs(hp->ancount);
d341 1
a341 7
		if (seenlocal &&
		    (!TryNullMXList ||
		     (sm_gethostbyname(host, AF_INET) == NULL
# if NETINET6
		      && sm_gethostbyname(host, AF_INET6) == NULL
# endif /* NETINET6 */
		      )))
d343 2
d357 43
a399 4
			*rcode = EX_CONFIG;
			syserr("MX list for %s points back to %s",
				host, MyHostName);
			return -1;
d647 2
d739 1
d750 5
a754 1
				/* the name server seems to be down */
d762 1
a762 1
				**  misconfigured firewalls black 53/TCP
d771 14
d787 1
d840 3
a842 1
		for (qdcount = ntohs(hp->qdcount); qdcount--; ap += ret + QFIXEDSZ)
d848 1
a848 1
						ntohs(hp->qdcount));
d855 3
a857 2
		for (ancount = ntohs(hp->ancount); --ancount >= 0 && ap < eom;
									ap += n)
d1005 2
a1006 1
		*statp = EX_NOHOST;
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.1.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d18 1
a18 1
static char id[] = "@@(#)$Sendmail: domain.c,v 8.114.6.1.2.8 2001/02/12 21:40:19 gshapiro Exp $ (with name server)";
d20 1
a20 1
static char id[] = "@@(#)$Sendmail: domain.c,v 8.114.6.1.2.8 2001/02/12 21:40:19 gshapiro Exp $ (without name server)";
a23 1

d230 1
a230 4
	for (qdcount = ntohs((u_short)hp->qdcount);
	     qdcount--;
	     cp += n + QFIXEDSZ)
	{
a232 1
	}
d235 1
a235 1
	ancount = ntohs((u_short)hp->ancount);
d336 7
a342 1
		if (seenlocal)
a343 2
			struct hostent *h = NULL;

d356 4
a359 43
			if (TryNullMXList)
			{
				SM_SET_H_ERRNO(0);
				errno = 0;
				h = sm_gethostbyname(host, AF_INET);
				if (h == NULL)
				{
					if (errno == ETIMEDOUT ||
					    h_errno == TRY_AGAIN ||
					    (errno == ECONNREFUSED &&
					     UseNameServer))
					{
						*rcode = EX_TEMPFAIL;
						return -1;
					}
# if NETINET6
					SM_SET_H_ERRNO(0);
					errno = 0;
					h = sm_gethostbyname(host, AF_INET6);
					if (h == NULL &&
					    (errno == ETIMEDOUT ||
					     h_errno == TRY_AGAIN ||
					     (errno == ECONNREFUSED &&
					      UseNameServer)))
					{
						*rcode = EX_TEMPFAIL;
						return -1;
					}
# endif /* NETINET6 */
				}
			}

			if (h == NULL)
			{
				*rcode = EX_CONFIG;
				syserr("MX list for %s points back to %s",
				       host, MyHostName);
				return -1;
			}
# if _FFR_FREEHOSTENT && NETINET6
			freehostent(h);
			hp = NULL;
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a606 2
	*statp = EX_OK;

a696 1
		errno = 0;
d707 2
a708 6
				/*
				**  the name server seems to be down or
				**  broken.
				*/

				SM_SET_H_ERRNO(TRY_AGAIN);
d715 1
a715 1
				**  misconfigured firewalls block 53/TCP
a723 18
#if _FFR_WORKAROUND_BROKEN_NAMESERVERS
				if (WorkAroundBrokenAAAA)
				{
					/*
					**  Only return if not TRY_AGAIN as an
					**  attempt with a different qtype may
					**  succeed (res_querydomain() calls
					**  res_query() calls res_send() which
					**  sets errno to ETIMEDOUT if the
					**  nameservers could be contacted but
					**  didn't give an answer).
					*/

					if (qtype != T_ANY &&
					    errno != ETIMEDOUT)
						return FALSE;
				}
#else /* _FFR_WORKAROUND_BROKEN_NAMESERVERS */
a725 1
#endif /* _FFR_WORKAROUND_BROKEN_NAMESERVERS */
d778 1
a778 3
		for (qdcount = ntohs((u_short)hp->qdcount);
		     qdcount--;
		     ap += ret + QFIXEDSZ)
d784 1
a784 1
						ntohs((u_short)hp->qdcount));
d791 2
a792 3
		for (ancount = ntohs((u_short)hp->ancount);
		     --ancount >= 0 && ap < eom;
		     ap += n)
d869 1
a869 1
					SM_SET_H_ERRNO(NO_RECOVERY);
d940 1
a940 2
		if (*statp == EX_OK)
			*statp = EX_NOHOST;
@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d18 1
a18 1
static char id[] = "@@(#)$Id: domain.c,v 8.114.6.1.2.6 2000/12/19 02:50:33 gshapiro Exp $ (with name server)";
d20 1
a20 1
static char id[] = "@@(#)$Id: domain.c,v 8.114.6.1.2.6 2000/12/19 02:50:33 gshapiro Exp $ (without name server)";
a23 1

d230 1
a230 4
	for (qdcount = ntohs((u_short)hp->qdcount);
	     qdcount--;
	     cp += n + QFIXEDSZ)
	{
a232 1
	}
d235 1
a235 1
	ancount = ntohs((u_short)hp->ancount);
d336 7
a342 1
		if (seenlocal)
a343 2
			struct hostent *h = NULL;

d356 4
a359 43
			if (TryNullMXList)
			{
				h_errno = 0;
				errno = 0;
				h = sm_gethostbyname(host, AF_INET);
				if (h == NULL)
				{
					if (errno == ETIMEDOUT ||
					    h_errno == TRY_AGAIN ||
					    (errno == ECONNREFUSED &&
					     UseNameServer))
					{
						*rcode = EX_TEMPFAIL;
						return -1;
					}
# if NETINET6
					h_errno = 0;
					errno = 0;
					h = sm_gethostbyname(host, AF_INET6);
					if (h == NULL &&
					    (errno == ETIMEDOUT ||
					     h_errno == TRY_AGAIN ||
					     (errno == ECONNREFUSED &&
					      UseNameServer)))
					{
						*rcode = EX_TEMPFAIL;
						return -1;
					}
# endif /* NETINET6 */
				}
			}

			if (h == NULL)
			{
				*rcode = EX_CONFIG;
				syserr("MX list for %s points back to %s",
				       host, MyHostName);
				return -1;
			}
# if _FFR_FREEHOSTENT && NETINET6
			freehostent(h);
			hp = NULL;
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a606 2
	*statp = EX_OK;

a696 1
		errno = 0;
d707 1
a707 5
				/*
				**  the name server seems to be down or
				**  broken.
				*/

d715 1
a715 1
				**  misconfigured firewalls block 53/TCP
a723 14
#if _FFR_WORKAROUND_BROKEN_NAMESERVERS
				/*
				**  Only return if not TRY_AGAIN as an
				**  attempt with a different qtype may
				**  succeed (res_querydomain() calls
				**  res_query() calls res_send() which
				**  sets errno to ETIMEDOUT if the
				**  nameservers could be contacted but
				**  didn't give an answer).
				*/

				if (qtype != T_ANY && errno != ETIMEDOUT)
					return FALSE;
#else /* _FFR_WORKAROUND_BROKEN_NAMESERVERS */
a725 1
#endif /* _FFR_WORKAROUND_BROKEN_NAMESERVERS */
d778 1
a778 3
		for (qdcount = ntohs((u_short)hp->qdcount);
		     qdcount--;
		     ap += ret + QFIXEDSZ)
d784 1
a784 1
						ntohs((u_short)hp->qdcount));
d791 2
a792 3
		for (ancount = ntohs((u_short)hp->ancount);
		     --ancount >= 0 && ap < eom;
		     ap += n)
d940 1
a940 2
		if (*statp == EX_OK)
			*statp = EX_NOHOST;
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 8
a23 5
#if NAMED_BIND
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.172 2001/09/04 22:43:03 ca Exp $ (with name server)")
#else /* NAMED_BIND */
SM_RCSID("@@(#)$Sendmail: domain.c,v 8.172 2001/09/04 22:43:03 ca Exp $ (without name server)")
#endif /* NAMED_BIND */
a28 1

d44 2
a45 2
	HEADER		qb1;
	unsigned char	qb2[MAXPACKET];
a52 3
#if (MXHOSTBUFSIZE < 2) || (MXHOSTBUFSIZE >= INT_MAX/2)
	ERROR: _MXHOSTBUFSIZE is out of range
#endif /* (MXHOSTBUFSIZE < 2) || (MXHOSTBUFSIZE >= INT_MAX/2) */
d62 4
d79 1
a79 1
#  define RES_UNC_T	unsigned char *
a83 95
static int	fallbackmxrr __P((int, unsigned short *, char **));

/*
**  GETFALLBACKMXRR -- get MX resource records for fallback MX host.
**
**	We have to initialize this once before doing anything else.
**	Moreover, we have to repeat this from time to time to avoid
**	stale data, e.g., in persistent queue runners.
**	This should be done in a parent process so the child
**	processes have the right data.
**
**	Parameters:
**		host -- the name of the fallback MX host.
**
**	Returns:
**		number of MX records.
**
**	Side Effects:
**		Populates NumFallBackMXHosts and fbhosts.
**		Sets renewal time (based on TTL).
*/

int NumFallBackMXHosts = 0;	/* Number of fallback MX hosts (after MX expansion) */
static char *fbhosts[MAXMXHOSTS + 1];

int
getfallbackmxrr(host)
	char *host;
{
	int i, rcode;
	int ttl;
	static time_t renew = 0;

#if 0
	/* This is currently done before this function is called. */
	if (host == NULL || *host == '\0')
		return 0;
#endif /* 0 */
	if (NumFallBackMXHosts > 0 && renew > curtime())
		return NumFallBackMXHosts;
	if (host[0] == '[')
	{
		fbhosts[0] = host;
		NumFallBackMXHosts = 1;
	}
	else
	{
		/* free old data */
		for (i = 0; i < NumFallBackMXHosts; i++)
			sm_free(fbhosts[i]);

		/* get new data */
		NumFallBackMXHosts = getmxrr(host, fbhosts, NULL, false,
					     &rcode, false, &ttl);
		renew = curtime() + ttl;
		for (i = 0; i < NumFallBackMXHosts; i++)
			fbhosts[i] = newstr(fbhosts[i]);
	}
	return NumFallBackMXHosts;
}

/*
**  FALLBACKMXRR -- add MX resource records for fallback MX host to list.
**
**	Parameters:
**		nmx -- current number of MX records.
**		prefs -- array of preferences.
**		mxhosts -- array of MX hosts (maximum size: MAXMXHOSTS)
**
**	Returns:
**		new number of MX records.
**
**	Side Effects:
**		If FallBackMX was set, it appends the MX records for
**		that host to mxhosts (and modifies prefs accordingly).
*/

static int
fallbackmxrr(nmx, prefs, mxhosts)
	int nmx;
	unsigned short *prefs;
	char **mxhosts;
{
	int i;

	for (i = 0; i < NumFallBackMXHosts && nmx < MAXMXHOSTS; i++)
	{
		if (nmx > 0)
			prefs[nmx] = prefs[nmx - 1] + 1;
		else
			prefs[nmx] = 0;
		mxhosts[nmx++] = fbhosts[i];
	}
	return nmx;
}
d93 1
a93 1
**		droplocalhost -- If true, all MX records less preferred
a96 2
**		tryfallback -- add also fallback MX host?
**		pttl -- pointer to return TTL (can be NULL).
a102 5
**
**	Side Effects:
**		The entries made for mxhosts point to a static array
**		MXHostBuf[MXHOSTBUFSIZE], so the data needs to be copied,
**		if it must be preserved across calls to this function.
d106 1
a106 1
getmxrr(host, mxhosts, mxprefs, droplocalhost, rcode, tryfallback, pttl)
d109 1
a109 1
	unsigned short *mxprefs;
a111 2
	bool tryfallback;
	int *pttl;
d113 1
a113 1
	register unsigned char *eom, *cp;
d120 3
a122 3
	bool seenlocal = false;
	unsigned short pref, type;
	unsigned short localpref = 256;
d124 2
a125 2
	bool trycanon = false;
	unsigned short *prefs;
d127 1
a127 1
	unsigned short prefer[MAXMXHOSTS];
a128 1
	int ttl = 0;
d132 2
a133 2
		sm_dprintf("getmxrr(%s, droplocalhost=%d)\n",
			   host, droplocalhost);
d135 2
a136 2
	if ((fallbackMX != NULL && droplocalhost &&
	     wordinclass(fallbackMX, 'w')) || !tryfallback)
d149 1
d170 1
a170 2
	n = (*resfunc)(host, C_IN, T_MX, (unsigned char *) &answer,
		       sizeof(answer));
d174 2
a175 2
			sm_dprintf("getmxrr: res_search(%s) failed (errno=%d, h_errno=%d)\n",
				host == NULL ? "<NULL>" : host, errno, h_errno);
d179 1
a179 1
			trycanon = true;
d191 1
a191 1
			trycanon = true;
d201 6
a206 1
				return fallbackmxrr(nmx, prefs, mxhosts);
d229 3
a231 3
	cp = (unsigned char *)&answer + HFIXEDSZ;
	eom = (unsigned char *)&answer + n;
	for (qdcount = ntohs((unsigned short) hp->qdcount);
a237 2

	/* NOTE: see definition of MXHostBuf! */
a238 1
	SM_ASSERT(buflen > 0);
d240 1
a240 4
	ancount = ntohs((unsigned short) hp->ancount);

	/* See RFC 1035 for layout of RRs. */
	/* XXX leave room for FallBackMX ? */
d243 2
a244 2
		if ((n = dn_expand((unsigned char *)&answer, eom, cp,
				   (RES_UNC_T) bp, buflen)) < 0)
d248 2
a249 3
		cp += INT16SZ;		/* skip over class */
		GETLONG(ttl, cp);
		GETSHORT(n, cp);	/* rdlength */
d253 1
a253 1
				sm_dprintf("unexpected answer type %d, size %d\n",
d259 1
a259 1
		if ((n = dn_expand((unsigned char *)&answer, eom, cp,
a262 12
		n = strlen(bp);
# if 0
		/* Can this happen? */
		if (n == 0)
		{
			if (LogLevel > 4)
				sm_syslog(LOG_ERR, NOQID,
					  "MX records for %s contain empty string",
					  host);
			continue;
		}
# endif /* 0 */
d266 1
a266 1
				sm_dprintf("found localhost (%s) in MX list, pref=%d\n",
d272 1
a272 1
				seenlocal = true;
d281 1
a288 5
		if (buflen < n + 1)
		{
			/* don't want to wrap buflen */
			break;
		}
a291 4
	/* return only one TTL entry, that should be sufficient */
	if (ttl > 0 && pttl != NULL)
		*pttl = ttl;

d324 1
a324 1
		if (sm_strcasecmp(mxhosts[i], mxhosts[i + 1]) != 0)
d359 1
a359 1
				SM_SET_H_ERRNO(0);
d373 1
a373 1
					SM_SET_H_ERRNO(0);
d396 1
a396 1
# if NETINET6
d399 1
a399 1
# endif /* NETINET6 */
d401 1
a401 1
		if (strlen(host) >= sizeof MXHostBuf)
d408 1
a408 1
		(void) sm_strlcpy(MXHostBuf, host, sizeof MXHostBuf);
d430 2
a431 2
				else if (anynet_pton(AF_INET6, &MXHostBuf[1],
						     &tmp6.sin6_addr) == 1)
d439 1
a439 1
					trycanon = true;
d445 1
a445 1
		    getcanonname(mxhosts[0], sizeof MXHostBuf - 2, false, pttl))
a446 1
			/* XXX MXHostBuf == "" ?  is that possible? */
d460 5
a464 1
		nmx = fallbackmxrr(nmx, prefs, mxhosts);
d466 1
d482 3
d502 1
a502 1
		sm_dprintf("mxrand(%s)", host);
d518 1
a518 1
		sm_dprintf(" = %d\n", hfunc);
d538 2
a539 3
	int i;
	ssize_t len = 0;
	char *result;
a540 4
#if _FFR_BESTMX_BETTER_TRUNCATION
	char *buf;
#else /* _FFR_BESTMX_BETTER_TRUNCATION */
	char *p;
a541 1
#endif /* _FFR_BESTMX_BETTER_TRUNCATION */
d544 1
a544 1
	nmx = getmxrr(name, mxhosts, NULL, false, statp, true, NULL);
a556 39

#if _FFR_BESTMX_BETTER_TRUNCATION
	for (i = 0; i < nmx; i++)
	{
		if (strchr(mxhosts[i], map->map_coldelim) != NULL)
		{
			syserr("bestmx_map_lookup: MX host %.64s includes map delimiter character 0x%02X",
			       mxhosts[i], map->map_coldelim);
			return NULL;
		}
		len += strlen(mxhosts[i]) + 1;
		if (len < 0)
		{
			len -= strlen(mxhosts[i]) + 1;
			break;
		}
	}
	buf = (char *) sm_malloc(len);
	if (buf == NULL)
	{
		*statp = EX_UNAVAILABLE;
		return NULL;
	}
	*buf = '\0';
	for (i = 0; i < nmx; i++)
	{
		int end;

		end = sm_strlcat(buf, mxhosts[i], len);
		if (i != nmx && end + 1 < len)
		{
			buf[end] = map->map_coldelim;
			buf[end + 1] = '\0';
		}
	}

	/* Cleanly truncate for rulesets */
	truncate_at_delim(buf, PSBUFSIZE / 2, map->map_coldelim);
#else /* _FFR_BESTMX_BETTER_TRUNCATION */
d560 1
a560 1
		size_t slen;
d576 1
a576 1
		(void) sm_strlcpy(p, mxhosts[i], sizeof buf - len);
d580 1
a580 7
#endif /* _FFR_BESTMX_BETTER_TRUNCATION */

	result = map_rewrite(map, buf, len, av);
#if _FFR_BESTMX_BETTER_TRUNCATION
	sm_free(buf);
#endif /* _FFR_BESTMX_BETTER_TRUNCATION */
	return result;
a605 1
**		pttl -- pointer to return TTL (can be NULL).
d608 2
a609 2
**		true -- if the host matched.
**		false -- otherwise.
a611 6
# if NETINET6
#  define SM_T_INITIAL	T_AAAA
# else /* NETINET6 */
#  define SM_T_INITIAL	T_A
# endif /* NETINET6 */

d613 1
a613 1
dns_getcanonname(host, hbsize, trymx, statp, pttl)
a617 1
	int *pttl;
d619 1
a619 1
	register unsigned char *eom, *ap;
a627 1
	int ttl = 0;
d631 1
a631 1
	bool gotmx = false;
d635 1
a635 1
	char nbuf[SM_MAX(MAXPACKET, MAXDNAME*2+2)];
d639 1
a639 1
		sm_dprintf("dns_getcanonname(%s, trymx=%d)\n", host, trymx);
d644 1
a644 1
		return false;
a671 1

d680 1
a680 1
			(void) sm_strlcpy(host, xp, hbsize);
d723 1
a723 1
	qtype = SM_T_INITIAL;
d727 2
a728 2
		if (qtype == SM_T_INITIAL)
			gotmx = false;
d730 1
a730 1
			sm_dprintf("dns_getcanonname: trying %s.%s (%s)\n",
d732 1
d745 1
a745 1
				sm_dprintf("\tNO: errno=%d, h_errno=%d\n",
d751 2
a752 1
				**  the name server seems to be down or broken.
d755 1
a755 1
				SM_SET_H_ERRNO(TRY_AGAIN);
d758 23
a780 11
				if (WorkAroundBrokenAAAA)
				{
					/*
					**  Only return if not TRY_AGAIN as an
					**  attempt with a different qtype may
					**  succeed (res_querydomain() calls
					**  res_query() calls res_send() which
					**  sets errno to ETIMEDOUT if the
					**  nameservers could be contacted but
					**  didn't give an answer).
					*/
d782 6
a787 5
					if (errno != ETIMEDOUT)
						return false;
				}
				else
					return false;
d793 2
d796 8
a803 1
				if (qtype == T_AAAA)
a807 1
				else
d809 2
a810 2
				if (qtype == T_A && !gotmx &&
				    (trymx || **dp == '\0'))
d819 1
a819 1
			qtype = SM_T_INITIAL;
d823 1
a823 1
			sm_dprintf("\tYES\n");
a827 5
		if (ret < 0)
		{
			*statp = EX_SOFTWARE;
			return false;
		}
d836 2
a837 2
		ap = (unsigned char *) &answer + HFIXEDSZ;
		eom = (unsigned char *) &answer + ret;
d840 1
a840 1
		for (qdcount = ntohs((unsigned short) hp->qdcount);
d847 2
a848 2
					sm_dprintf("qdcount failure (%d)\n",
						ntohs((unsigned short) hp->qdcount));
d850 1
a850 1
				return false;		/* ???XXX??? */
d854 2
a855 2
		amatch = false;
		for (ancount = ntohs((unsigned short) hp->ancount);
d859 1
a859 1
			n = dn_expand((unsigned char *) &answer, eom, ap,
d865 2
a866 3
			ap += INT16SZ;		/* skip over class */
			GETLONG(ttl, ap);
			GETSHORT(n, ap);	/* rdlength */
d870 1
a870 1
				gotmx = true;
d899 1
a899 1
				amatch = true;
d907 1
a907 1
				amatch = true;
d916 1
a916 1
					amatch = true;
d929 1
a929 2
						(void) sm_snprintf(ebuf,
							sizeof ebuf,
d932 1
a932 3
						CurEnv->e_message =
						    sm_rpool_strdup_x(
							CurEnv->e_rpool, ebuf);
d934 1
a934 1
					SM_SET_H_ERRNO(NO_RECOVERY);
d936 1
a936 1
					return false;
d940 2
a941 3
				if ((ret = dn_expand((unsigned char *)&answer,
						     eom, ap, (RES_UNC_T) nbuf,
						     sizeof(nbuf))) < 0)
d943 1
a943 1
				(void) sm_strlcpy(host, nbuf, hbsize);
d972 4
d981 2
d984 7
a990 1
		if (qtype == T_AAAA)
a991 1
		else
d993 1
a993 1
		if (qtype == T_A && !gotmx && (trymx || **dp == '\0'))
d997 1
a997 1
			qtype = SM_T_INITIAL;
d1007 1
a1007 1
		return false;
d1016 4
a1019 4
	(void) sm_snprintf(nbuf, sizeof nbuf, "%.*s%s%.*s", MAXDNAME, host,
			   *mxmatch == '\0' ? "" : ".",
			   MAXDNAME, mxmatch);
	(void) sm_strlcpy(host, nbuf, hbsize);
d1021 1
a1021 1
		sm_dprintf("dns_getcanonname: %s\n", host);
d1023 1
a1023 5

	/* return only one TTL entry, that should be sufficient */
	if (ttl > 0 && pttl != NULL)
		*pttl = ttl;
	return true;
d1031 1
a1031 1
	SM_FILE_T *fp;
a1036 2
	if (ResNoAliases)
		return NULL;
d1043 1
a1043 1
	while (sm_io_fgets(fp, SM_TIME_DEFAULT, buf, sizeof buf) != NULL)
d1053 1
a1053 1
		if (sm_strcasecmp(buf, host) == 0)
d1057 1
a1057 1
	if (sm_io_eof(fp))
d1060 1
a1060 1
		(void) sm_io_close(fp, SM_TIME_DEFAULT);
d1063 1
a1063 1
	(void) sm_io_close(fp, SM_TIME_DEFAULT);
d1072 1
a1072 1
	(void) sm_strlcpy(hbuf, host, sizeof hbuf);
@


