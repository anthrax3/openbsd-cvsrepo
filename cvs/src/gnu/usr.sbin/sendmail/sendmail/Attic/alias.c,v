head	1.15;
access;
symbols
	OPENBSD_5_6:1.14.0.6
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.12.0.26
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.24
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.22
	OPENBSD_5_0:1.12.0.20
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.18
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.16
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.12
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.14
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.10
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.8
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.6
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.4
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.10
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.8
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.6
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.14;
commitid	M7i5giHIoz3DMlTU;

1.14
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.24.03.59.26;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.19.01.41.13;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.17.17.31.40;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.03.17.25.46;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.29.01.31.14;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.15.21.09.06;	author millert;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.04.07.19.20.38;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.43;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.43;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.10;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.50;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.31.28;	author miod;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.31.01.47.55;	author jason;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2003 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>

SM_RCSID("@@(#)$Sendmail: alias.c,v 8.221 2013/11/22 20:51:54 ca Exp $")

#define SEPARATOR ':'
# define ALIAS_SPEC_SEPARATORS	" ,/:"

static MAP	*AliasFileMap = NULL;	/* the actual aliases.files map */
static int	NAliasFileMaps;	/* the number of entries in AliasFileMap */

static char	*aliaslookup __P((char *, int *, char *));

/*
**  ALIAS -- Compute aliases.
**
**	Scans the alias file for an alias for the given address.
**	If found, it arranges to deliver to the alias list instead.
**	Uses libdbm database if -DDBM.
**
**	Parameters:
**		a -- address to alias.
**		sendq -- a pointer to the head of the send queue
**			to put the aliases in.
**		aliaslevel -- the current alias nesting depth.
**		e -- the current envelope.
**
**	Returns:
**		none
**
**	Side Effects:
**		Aliases found are expanded.
**
**	Deficiencies:
**		It should complain about names that are aliased to
**			nothing.
*/

void
alias(a, sendq, aliaslevel, e)
	register ADDRESS *a;
	ADDRESS **sendq;
	int aliaslevel;
	register ENVELOPE *e;
{
	register char *p;
	char *owner;
	auto int status = EX_OK;
	char obuf[MAXNAME + 7];

	if (tTd(27, 1))
		sm_dprintf("alias(%s)\n", a->q_user);

	/* don't realias already aliased names */
	if (!QS_IS_OK(a->q_state))
		return;

	if (NoAlias)
		return;

	e->e_to = a->q_paddr;

	/*
	**  Look up this name.
	**
	**	If the map was unavailable, we will queue this message
	**	until the map becomes available; otherwise, we could
	**	bounce messages inappropriately.
	*/

#if _FFR_REDIRECTEMPTY
	/*
	**  envelope <> can't be sent to mailing lists, only owner-
	**  send spam of this type to owner- of the list
	**  ----  to stop spam from going to mailing lists!
	*/

	if (e->e_sender != NULL && *e->e_sender == '\0')
	{
		/* Look for owner of alias */
		(void) sm_strlcpyn(obuf, sizeof(obuf), 2, "owner-", a->q_user);
		if (aliaslookup(obuf, &status, a->q_host) != NULL)
		{
			if (LogLevel > 8)
				sm_syslog(LOG_WARNING, e->e_id,
				       "possible spam from <> to list: %s, redirected to %s\n",
				       a->q_user, obuf);
			a->q_user = sm_rpool_strdup_x(e->e_rpool, obuf);
		}
	}
#endif /* _FFR_REDIRECTEMPTY */

	p = aliaslookup(a->q_user, &status, a->q_host);
	if (status == EX_TEMPFAIL || status == EX_UNAVAILABLE)
	{
		a->q_state = QS_QUEUEUP;
		if (e->e_message == NULL)
			e->e_message = sm_rpool_strdup_x(e->e_rpool,
						"alias database unavailable");

		/* XXX msg only per recipient? */
		if (a->q_message == NULL)
			a->q_message = "alias database unavailable";
		return;
	}
	if (p == NULL)
		return;

	/*
	**  Match on Alias.
	**	Deliver to the target list.
	*/

	if (tTd(27, 1))
		sm_dprintf("%s (%s, %s) aliased to %s\n",
			   a->q_paddr, a->q_host, a->q_user, p);
	if (bitset(EF_VRFYONLY, e->e_flags))
	{
		a->q_state = QS_VERIFIED;
		return;
	}
	message("aliased to %s", shortenstring(p, MAXSHORTSTR));
	if (LogLevel > 10)
		sm_syslog(LOG_INFO, e->e_id,
			  "alias %.100s => %s",
			  a->q_paddr, shortenstring(p, MAXSHORTSTR));
	a->q_flags &= ~QSELFREF;
	if (tTd(27, 5))
	{
		sm_dprintf("alias: QS_EXPANDED ");
		printaddr(sm_debug_file(), a, false);
	}
	a->q_state = QS_EXPANDED;

	/*
	**  Always deliver aliased items as the default user.
	**  Setting q_gid to 0 forces deliver() to use DefUser
	**  instead of the alias name for the call to initgroups().
	*/

	a->q_uid = DefUid;
	a->q_gid = 0;
	a->q_fullname = NULL;
	a->q_flags |= QGOODUID|QALIAS;

	(void) sendtolist(p, a, sendq, aliaslevel + 1, e);

	if (bitset(QSELFREF, a->q_flags) && QS_IS_EXPANDED(a->q_state))
		a->q_state = QS_OK;

	/*
	**  Look for owner of alias
	*/

	if (strncmp(a->q_user, "owner-", 6) == 0 ||
	    strlen(a->q_user) > sizeof(obuf) - 7)
		(void) sm_strlcpy(obuf, "owner-owner", sizeof(obuf));
	else
		(void) sm_strlcpyn(obuf, sizeof(obuf), 2, "owner-", a->q_user);
	owner = aliaslookup(obuf, &status, a->q_host);
	if (owner == NULL)
		return;

	/* reflect owner into envelope sender */
	if (strpbrk(owner, ",:/|\"") != NULL)
		owner = obuf;
	a->q_owner = sm_rpool_strdup_x(e->e_rpool, owner);

	/* announce delivery to this alias; NORECEIPT bit set later */
	if (e->e_xfp != NULL)
		(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
				"Message delivered to mailing list %s\n",
				a->q_paddr);
	e->e_flags |= EF_SENDRECEIPT;
	a->q_flags |= QDELIVERED|QEXPANDED;
}
/*
**  ALIASLOOKUP -- look up a name in the alias file.
**
**	Parameters:
**		name -- the name to look up.
**		pstat -- a pointer to a place to put the status.
**		av -- argument for %1 expansion.
**
**	Returns:
**		the value of name.
**		NULL if unknown.
**
**	Side Effects:
**		none.
**
**	Warnings:
**		The return value will be trashed across calls.
*/

static char *
aliaslookup(name, pstat, av)
	char *name;
	int *pstat;
	char *av;
{
	static MAP *map = NULL;
#if _FFR_ALIAS_DETAIL
	int i;
	char *argv[4];
#endif /* _FFR_ALIAS_DETAIL */

	if (map == NULL)
	{
		STAB *s = stab("aliases", ST_MAP, ST_FIND);

		if (s == NULL)
			return NULL;
		map = &s->s_map;
	}
	DYNOPENMAP(map);

	/* special case POstMastER -- always use lower case */
	if (sm_strcasecmp(name, "postmaster") == 0)
		name = "postmaster";

#if _FFR_ALIAS_DETAIL
	i = 0;
	argv[i++] = name;
	argv[i++] = av;

	/* XXX '+' is hardwired here as delimiter! */
	if (av != NULL && *av == '+')
		argv[i++] = av + 1;
	argv[i++] = NULL;
	return (*map->map_class->map_lookup)(map, name, argv, pstat);
#else /* _FFR_ALIAS_DETAIL */
	return (*map->map_class->map_lookup)(map, name, NULL, pstat);
#endif /* _FFR_ALIAS_DETAIL */
}
/*
**  SETALIAS -- set up an alias map
**
**	Called when reading configuration file.
**
**	Parameters:
**		spec -- the alias specification
**
**	Returns:
**		none.
*/

void
setalias(spec)
	char *spec;
{
	register char *p;
	register MAP *map;
	char *class;
	STAB *s;

	if (tTd(27, 8))
		sm_dprintf("setalias(%s)\n", spec);

	for (p = spec; p != NULL; )
	{
		char buf[50];

		while (isascii(*p) && isspace(*p))
			p++;
		if (*p == '\0')
			break;
		spec = p;

		if (NAliasFileMaps >= MAXMAPSTACK)
		{
			syserr("Too many alias databases defined, %d max",
				MAXMAPSTACK);
			return;
		}
		if (AliasFileMap == NULL)
		{
			(void) sm_strlcpy(buf, "aliases.files sequence",
					  sizeof(buf));
			AliasFileMap = makemapentry(buf);
			if (AliasFileMap == NULL)
			{
				syserr("setalias: cannot create aliases.files map");
				return;
			}
		}
		(void) sm_snprintf(buf, sizeof(buf), "Alias%d", NAliasFileMaps);
		s = stab(buf, ST_MAP, ST_ENTER);
		map = &s->s_map;
		memset(map, '\0', sizeof(*map));
		map->map_mname = s->s_name;
		p = strpbrk(p, ALIAS_SPEC_SEPARATORS);
		if (p != NULL && *p == SEPARATOR)
		{
			/* map name */
			*p++ = '\0';
			class = spec;
			spec = p;
		}
		else
		{
			class = "implicit";
			map->map_mflags = MF_INCLNULL;
		}

		/* find end of spec */
		if (p != NULL)
		{
			bool quoted = false;

			for (; *p != '\0'; p++)
			{
				/*
				**  Don't break into a quoted string.
				**  Needed for ldap maps which use
				**  commas in their specifications.
				*/

				if (*p == '"')
					quoted = !quoted;
				else if (*p == ',' && !quoted)
					break;
			}

			/* No more alias specifications follow */
			if (*p == '\0')
				p = NULL;
		}
		if (p != NULL)
			*p++ = '\0';

		if (tTd(27, 20))
			sm_dprintf("  map %s:%s %s\n", class, s->s_name, spec);

		/* look up class */
		s = stab(class, ST_MAPCLASS, ST_FIND);
		if (s == NULL)
		{
			syserr("setalias: unknown alias class %s", class);
		}
		else if (!bitset(MCF_ALIASOK, s->s_mapclass.map_cflags))
		{
			syserr("setalias: map class %s can't handle aliases",
				class);
		}
		else
		{
			map->map_class = &s->s_mapclass;
			map->map_mflags |= MF_ALIAS;
			if (map->map_class->map_parse(map, spec))
			{
				map->map_mflags |= MF_VALID;
				AliasFileMap->map_stack[NAliasFileMaps++] = map;
			}
		}
	}
}
/*
**  ALIASWAIT -- wait for distinguished @@:@@ token to appear.
**
**	This can decide to reopen or rebuild the alias file
**
**	Parameters:
**		map -- a pointer to the map descriptor for this alias file.
**		ext -- the filename extension (e.g., ".db") for the
**			database file.
**		isopen -- if set, the database is already open, and we
**			should check for validity; otherwise, we are
**			just checking to see if it should be created.
**
**	Returns:
**		true -- if the database is open when we return.
**		false -- if the database is closed when we return.
*/

bool
aliaswait(map, ext, isopen)
	MAP *map;
	char *ext;
	bool isopen;
{
	bool attimeout = false;
	time_t mtime;
	struct stat stb;
	char buf[MAXPATHLEN];

	if (tTd(27, 3))
		sm_dprintf("aliaswait(%s:%s)\n",
			   map->map_class->map_cname, map->map_file);
	if (bitset(MF_ALIASWAIT, map->map_mflags))
		return isopen;
	map->map_mflags |= MF_ALIASWAIT;

	if (SafeAlias > 0)
	{
		auto int st;
		unsigned int sleeptime = 2;
		unsigned int loopcount = 0;	/* only used for debugging */
		time_t toolong = curtime() + SafeAlias;

		while (isopen &&
		       map->map_class->map_lookup(map, "@@", NULL, &st) == NULL)
		{
			if (curtime() > toolong)
			{
				/* we timed out */
				attimeout = true;
				break;
			}

			/*
			**  Close and re-open the alias database in case
			**  the one is mv'ed instead of cp'ed in.
			*/

			if (tTd(27, 2))
			{
				loopcount++;
				sm_dprintf("aliaswait: sleeping for %u seconds (loopcount = %u)\n",
					   sleeptime, loopcount);
			}

			map->map_mflags |= MF_CLOSING;
			map->map_class->map_close(map);
			map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
			(void) sleep(sleeptime);
			sleeptime *= 2;
			if (sleeptime > 60)
				sleeptime = 60;
			isopen = map->map_class->map_open(map, O_RDONLY);
		}
	}

	/* see if we need to go into auto-rebuild mode */
	if (!bitset(MCF_REBUILDABLE, map->map_class->map_cflags))
	{
		if (tTd(27, 3))
			sm_dprintf("aliaswait: not rebuildable\n");
		map->map_mflags &= ~MF_ALIASWAIT;
		return isopen;
	}
	if (stat(map->map_file, &stb) < 0)
	{
		if (tTd(27, 3))
			sm_dprintf("aliaswait: no source file\n");
		map->map_mflags &= ~MF_ALIASWAIT;
		return isopen;
	}
	mtime = stb.st_mtime;
	if (sm_strlcpyn(buf, sizeof(buf), 2,
			map->map_file, ext == NULL ? "" : ext) >= sizeof(buf))
	{
		if (LogLevel > 3)
			sm_syslog(LOG_INFO, NOQID,
				  "alias database %s%s name too long",
				  map->map_file, ext == NULL ? "" : ext);
		message("alias database %s%s name too long",
			map->map_file, ext == NULL ? "" : ext);
	}

	if (stat(buf, &stb) < 0 || stb.st_mtime < mtime || attimeout)
	{
		if (LogLevel > 3)
			sm_syslog(LOG_INFO, NOQID,
				  "alias database %s out of date", buf);
		message("Warning: alias database %s out of date", buf);
	}
	map->map_mflags &= ~MF_ALIASWAIT;
	return isopen;
}
/*
**  REBUILDALIASES -- rebuild the alias database.
**
**	Parameters:
**		map -- the database to rebuild.
**		automatic -- set if this was automatically generated.
**
**	Returns:
**		true if successful; false otherwise.
**
**	Side Effects:
**		Reads the text version of the database, builds the
**		DBM or DB version.
*/

bool
rebuildaliases(map, automatic)
	register MAP *map;
	bool automatic;
{
	SM_FILE_T *af;
	bool nolock = false;
	bool success = false;
	long sff = SFF_OPENASROOT|SFF_REGONLY|SFF_NOLOCK;
	sigfunc_t oldsigint, oldsigquit;
#ifdef SIGTSTP
	sigfunc_t oldsigtstp;
#endif /* SIGTSTP */

	if (!bitset(MCF_REBUILDABLE, map->map_class->map_cflags))
		return false;

	if (!bitnset(DBS_LINKEDALIASFILEINWRITABLEDIR, DontBlameSendmail))
		sff |= SFF_NOWLINK;
	if (!bitnset(DBS_GROUPWRITABLEALIASFILE, DontBlameSendmail))
		sff |= SFF_NOGWFILES;
	if (!bitnset(DBS_WORLDWRITABLEALIASFILE, DontBlameSendmail))
		sff |= SFF_NOWWFILES;

	/* try to lock the source file */
	if ((af = safefopen(map->map_file, O_RDWR, 0, sff)) == NULL)
	{
		struct stat stb;

		if ((errno != EACCES && errno != EROFS) || automatic ||
		    (af = safefopen(map->map_file, O_RDONLY, 0, sff)) == NULL)
		{
			int saveerr = errno;

			if (tTd(27, 1))
				sm_dprintf("Can't open %s: %s\n",
					map->map_file, sm_errstring(saveerr));
			if (!automatic && !bitset(MF_OPTIONAL, map->map_mflags))
				message("newaliases: cannot open %s: %s",
					map->map_file, sm_errstring(saveerr));
			errno = 0;
			return false;
		}
		nolock = true;
		if (tTd(27, 1) ||
		    fstat(sm_io_getinfo(af, SM_IO_WHAT_FD, NULL), &stb) < 0 ||
		    bitset(S_IWUSR|S_IWGRP|S_IWOTH, stb.st_mode))
			message("warning: cannot lock %s: %s",
				map->map_file, sm_errstring(errno));
	}

	/* see if someone else is rebuilding the alias file */
	if (!nolock &&
	    !lockfile(sm_io_getinfo(af, SM_IO_WHAT_FD, NULL), map->map_file,
		      NULL, LOCK_EX|LOCK_NB))
	{
		/* yes, they are -- wait until done */
		message("Alias file %s is locked (maybe being rebuilt)",
			map->map_file);
		if (OpMode != MD_INITALIAS)
		{
			/* wait for other rebuild to complete */
			(void) lockfile(sm_io_getinfo(af, SM_IO_WHAT_FD, NULL),
					map->map_file, NULL, LOCK_EX);
		}
		(void) sm_io_close(af, SM_TIME_DEFAULT);
		errno = 0;
		return false;
	}

	oldsigint = sm_signal(SIGINT, SIG_IGN);
	oldsigquit = sm_signal(SIGQUIT, SIG_IGN);
#ifdef SIGTSTP
	oldsigtstp = sm_signal(SIGTSTP, SIG_IGN);
#endif /* SIGTSTP */

	if (map->map_class->map_open(map, O_RDWR))
	{
		if (LogLevel > 7)
		{
			sm_syslog(LOG_NOTICE, NOQID,
				"alias database %s %srebuilt by %s",
				map->map_file, automatic ? "auto" : "",
				username());
		}
		map->map_mflags |= MF_OPEN|MF_WRITABLE;
		map->map_pid = CurrentPid;
		readaliases(map, af, !automatic, true);
		success = true;
	}
	else
	{
		if (tTd(27, 1))
			sm_dprintf("Can't create database for %s: %s\n",
				map->map_file, sm_errstring(errno));
		if (!automatic)
			syserr("Cannot create database for alias file %s",
				map->map_file);
	}

	/* close the file, thus releasing locks */
	(void) sm_io_close(af, SM_TIME_DEFAULT);

	/* add distinguished entries and close the database */
	if (bitset(MF_OPEN, map->map_mflags))
	{
		map->map_mflags |= MF_CLOSING;
		map->map_class->map_close(map);
		map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
	}

	/* restore the old signals */
	(void) sm_signal(SIGINT, oldsigint);
	(void) sm_signal(SIGQUIT, oldsigquit);
#ifdef SIGTSTP
	(void) sm_signal(SIGTSTP, oldsigtstp);
#endif /* SIGTSTP */
	return success;
}
/*
**  READALIASES -- read and process the alias file.
**
**	This routine implements the part of initaliases that occurs
**	when we are not going to use the DBM stuff.
**
**	Parameters:
**		map -- the alias database descriptor.
**		af -- file to read the aliases from.
**		announcestats -- announce statistics regarding number of
**			aliases, longest alias, etc.
**		logstats -- lot the same info.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Reads aliasfile into the symbol table.
**		Optionally, builds the .dir & .pag files.
*/

void
readaliases(map, af, announcestats, logstats)
	register MAP *map;
	SM_FILE_T *af;
	bool announcestats;
	bool logstats;
{
	register char *p;
	char *rhs;
	bool skipping;
	long naliases, bytes, longest;
	ADDRESS al, bl;
	char line[BUFSIZ];

	/*
	**  Read and interpret lines
	*/

	FileName = map->map_file;
	LineNumber = 0;
	naliases = bytes = longest = 0;
	skipping = false;
	while (sm_io_fgets(af, SM_TIME_DEFAULT, line, sizeof(line)) >= 0)
	{
		int lhssize, rhssize;
		int c;

		LineNumber++;
		p = strchr(line, '\n');

		/* XXX what if line="a\\" ? */
		while (p != NULL && p > line && p[-1] == '\\')
		{
			p--;
			if (sm_io_fgets(af, SM_TIME_DEFAULT, p,
					SPACELEFT(line, p)) < 0)
				break;
			LineNumber++;
			p = strchr(p, '\n');
		}
		if (p != NULL)
			*p = '\0';
		else if (!sm_io_eof(af))
		{
			errno = 0;
			syserr("554 5.3.0 alias line too long");

			/* flush to end of line */
			while ((c = sm_io_getc(af, SM_TIME_DEFAULT)) !=
				SM_IO_EOF && c != '\n')
				continue;

			/* skip any continuation lines */
			skipping = true;
			continue;
		}
		switch (line[0])
		{
		  case '#':
		  case '\0':
			skipping = false;
			continue;

		  case ' ':
		  case '\t':
			if (!skipping)
				syserr("554 5.3.5 Non-continuation line starts with space");
			skipping = true;
			continue;
		}
		skipping = false;

		/*
		**  Process the LHS
		**	Find the colon separator, and parse the address.
		**	It should resolve to a local name -- this will
		**	be checked later (we want to optionally do
		**	parsing of the RHS first to maximize error
		**	detection).
		*/

		for (p = line; *p != '\0' && *p != ':' && *p != '\n'; p++)
			continue;
		if (*p++ != ':')
		{
			syserr("554 5.3.5 missing colon");
			continue;
		}
		if (parseaddr(line, &al, RF_COPYALL, ':', NULL, CurEnv, true)
		    == NULL)
		{
			syserr("554 5.3.5 %.40s... illegal alias name", line);
			continue;
		}

		/*
		**  Process the RHS.
		**	'al' is the internal form of the LHS address.
		**	'p' points to the text of the RHS.
		*/

		while (isascii(*p) && isspace(*p))
			p++;
		rhs = p;
		for (;;)
		{
			register char *nlp;

			nlp = &p[strlen(p)];
			if (nlp > p && nlp[-1] == '\n')
				*--nlp = '\0';

			if (CheckAliases)
			{
				/* do parsing & compression of addresses */
				while (*p != '\0')
				{
					auto char *delimptr;

					while ((isascii(*p) && isspace(*p)) ||
								*p == ',')
						p++;
					if (*p == '\0')
						break;
					if (parseaddr(p, &bl, RF_COPYNONE, ',',
						      &delimptr, CurEnv, true)
					    == NULL)
						usrerr("553 5.3.5 %s... bad address", p);
					p = delimptr;
				}
			}
			else
			{
				p = nlp;
			}

			/* see if there should be a continuation line */
			c = sm_io_getc(af, SM_TIME_DEFAULT);
			if (!sm_io_eof(af))
				(void) sm_io_ungetc(af, SM_TIME_DEFAULT, c);
			if (c != ' ' && c != '\t')
				break;

			/* read continuation line */
			if (sm_io_fgets(af, SM_TIME_DEFAULT, p,
					sizeof(line) - (p-line)) < 0)
				break;
			LineNumber++;

			/* check for line overflow */
			if (strchr(p, '\n') == NULL && !sm_io_eof(af))
			{
				usrerr("554 5.3.5 alias too long");
				while ((c = sm_io_getc(af, SM_TIME_DEFAULT))
				       != SM_IO_EOF && c != '\n')
					continue;
				skipping = true;
				break;
			}
		}

		if (skipping)
			continue;

		if (!bitnset(M_ALIASABLE, al.q_mailer->m_flags))
		{
			syserr("554 5.3.5 %s... cannot alias non-local names",
				al.q_paddr);
			continue;
		}

		/*
		**  Insert alias into symbol table or database file.
		**
		**	Special case pOStmaStER -- always make it lower case.
		*/

		if (sm_strcasecmp(al.q_user, "postmaster") == 0)
			makelower(al.q_user);

		lhssize = strlen(al.q_user);
		rhssize = strlen(rhs);
		if (rhssize > 0)
		{
			/* is RHS empty (just spaces)? */
			p = rhs;
			while (isascii(*p) && isspace(*p))
				p++;
		}
		if (rhssize == 0 || *p == '\0')
		{
			syserr("554 5.3.5 %.40s... missing value for alias",
			       line);

		}
		else
		{
			map->map_class->map_store(map, al.q_user, rhs);

			/* statistics */
			naliases++;
			bytes += lhssize + rhssize;
			if (rhssize > longest)
				longest = rhssize;
		}

#if 0
	/*
	**  address strings are now stored in the envelope rpool,
	**  and therefore cannot be freed.
	*/
		if (al.q_paddr != NULL)
			sm_free(al.q_paddr);  /* disabled */
		if (al.q_host != NULL)
			sm_free(al.q_host);  /* disabled */
		if (al.q_user != NULL)
			sm_free(al.q_user);  /* disabled */
#endif /* 0 */
	}

	CurEnv->e_to = NULL;
	FileName = NULL;
	if (Verbose || announcestats)
		message("%s: %ld aliases, longest %ld bytes, %ld bytes total",
			map->map_file, naliases, longest, bytes);
	if (LogLevel > 7 && logstats)
		sm_syslog(LOG_INFO, NOQID,
			"%s: %ld aliases, longest %ld bytes, %ld bytes total",
			map->map_file, naliases, longest, bytes);
}
/*
**  FORWARD -- Try to forward mail
**
**	This is similar but not identical to aliasing.
**
**	Parameters:
**		user -- the name of the user who's mail we would like
**			to forward to.  It must have been verified --
**			i.e., the q_home field must have been filled
**			in.
**		sendq -- a pointer to the head of the send queue to
**			put this user's aliases in.
**		aliaslevel -- the current alias nesting depth.
**		e -- the current envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		New names are added to send queues.
*/

void
forward(user, sendq, aliaslevel, e)
	ADDRESS *user;
	ADDRESS **sendq;
	int aliaslevel;
	register ENVELOPE *e;
{
	char *pp;
	char *ep;
	bool got_transient;

	if (tTd(27, 1))
		sm_dprintf("forward(%s)\n", user->q_paddr);

	if (!bitnset(M_HASPWENT, user->q_mailer->m_flags) ||
	    !QS_IS_OK(user->q_state))
		return;
	if (ForwardPath != NULL && *ForwardPath == '\0')
		return;
	if (user->q_home == NULL)
	{
		syserr("554 5.3.0 forward: no home");
		user->q_home = "/no/such/directory";
	}

	/* good address -- look for .forward file in home */
	macdefine(&e->e_macro, A_PERM, 'z', user->q_home);
	macdefine(&e->e_macro, A_PERM, 'u', user->q_user);
	macdefine(&e->e_macro, A_PERM, 'h', user->q_host);
	if (ForwardPath == NULL)
		ForwardPath = newstr("\201z/.forward");

	got_transient = false;
	for (pp = ForwardPath; pp != NULL; pp = ep)
	{
		int err;
		char buf[MAXPATHLEN];
		struct stat st;

		ep = strchr(pp, SEPARATOR);
		if (ep != NULL)
			*ep = '\0';
		expand(pp, buf, sizeof(buf), e);
		if (ep != NULL)
			*ep++ = SEPARATOR;
		if (buf[0] == '\0')
			continue;
		if (tTd(27, 3))
			sm_dprintf("forward: trying %s\n", buf);

		err = include(buf, true, user, sendq, aliaslevel, e);
		if (err == 0)
			break;
		else if (transienterror(err))
		{
			/* we may have to suspend this message */
			got_transient = true;
			if (tTd(27, 2))
				sm_dprintf("forward: transient error on %s\n",
					   buf);
			if (LogLevel > 2)
			{
				char *curhost = CurHostName;

				CurHostName = NULL;
				sm_syslog(LOG_ERR, e->e_id,
					  "forward %s: transient error: %s",
					  buf, sm_errstring(err));
				CurHostName = curhost;
			}

		}
		else
		{
			switch (err)
			{
			  case ENOENT:
				break;

			  case E_SM_WWDIR:
			  case E_SM_GWDIR:
				/* check if it even exists */
				if (stat(buf, &st) < 0 && errno == ENOENT)
				{
					if (bitnset(DBS_DONTWARNFORWARDFILEINUNSAFEDIRPATH,
						    DontBlameSendmail))
						break;
				}
				/* FALLTHROUGH */

#if _FFR_FORWARD_SYSERR
			  case E_SM_NOSLINK:
			  case E_SM_NOHLINK:
			  case E_SM_REGONLY:
			  case E_SM_ISEXEC:
			  case E_SM_WWFILE:
			  case E_SM_GWFILE:
				syserr("forward: %s: %s", buf, sm_errstring(err));
				break;
#endif /* _FFR_FORWARD_SYSERR */

			  default:
				if (LogLevel > (RunAsUid == 0 ? 2 : 10))
					sm_syslog(LOG_WARNING, e->e_id,
						  "forward %s: %s", buf,
						  sm_errstring(err));
				if (Verbose)
					message("forward: %s: %s",
						buf, sm_errstring(err));
				break;
			}
		}
	}
	if (pp == NULL && got_transient)
	{
		/*
		**  There was no successful .forward open and at least one
		**  transient open.  We have to defer this address for
		**  further delivery.
		*/

		message("transient .forward open error: message queued");
		user->q_state = QS_QUEUEUP;
		return;
	}
}
@


1.14
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.13
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: alias.c,v 8.220 2013/03/12 15:24:52 ca Exp $")
@


1.12
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: alias.c,v 8.219 2006/10/24 18:04:09 ca Exp $")
d660 1
a660 1
	while (sm_io_fgets(af, SM_TIME_DEFAULT, line, sizeof(line)) != NULL)
d673 1
a673 1
					SPACELEFT(line, p)) == NULL)
d783 1
a783 1
					sizeof(line) - (p-line)) == NULL)
@


1.11
log
@Update to sendmail.8.13.0
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: alias.c,v 8.217 2003/07/28 17:47:18 ca Exp $")
d93 1
a93 1
		(void) sm_strlcpyn(obuf, sizeof obuf, 2, "owner-", a->q_user);
d110 2
a111 1
			e->e_message = "alias database unavailable";
d168 2
a169 2
	    strlen(a->q_user) > sizeof obuf - 7)
		(void) sm_strlcpy(obuf, "owner-owner", sizeof obuf);
d171 1
a171 1
		(void) sm_strlcpyn(obuf, sizeof obuf, 2, "owner-", a->q_user);
d291 1
a291 1
					  sizeof buf);
d299 1
a299 1
		(void) sm_snprintf(buf, sizeof buf, "Alias%d", NAliasFileMaps);
d302 1
a302 1
		memset(map, '\0', sizeof *map);
d462 2
a463 2
	if (sm_strlcpyn(buf, sizeof buf, 2,
			map->map_file, ext == NULL ? "" : ext) >= sizeof buf)
d660 1
a660 1
	while (sm_io_fgets(af, SM_TIME_DEFAULT, line, sizeof line) != NULL)
d783 1
a783 1
					sizeof line - (p-line)) == NULL)
d932 1
a932 1
		expand(pp, buf, sizeof buf, e);
@


1.10
log
@Update to sendmail 8.12.11.  I've been runninga beta version of this for
some time without problems.  See the RELEASE_NOTES for the change log.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: alias.c,v 8.214.2.2 2003/10/06 20:43:29 ca Exp $")
d142 1
a142 1
		printaddr(a, false);
@


1.9
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: alias.c,v 8.214.2.1 2003/07/28 17:47:55 ca Exp $")
@


1.8
log
@Update to sendmail-8.12.4
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: alias.c,v 8.214 2002/05/24 20:50:16 gshapiro Exp $")
d97 1
a97 1
				syslog(LOG_WARNING,
@


1.7
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: alias.c,v 8.211 2001/11/12 22:52:18 ca Exp $")
d396 1
a396 1
	char buf[MAXNAME + 1];
d461 11
a471 2
	(void) sm_strlcpyn(buf, sizeof buf, 2,
			   map->map_file, ext == NULL ? "" : ext);
d925 1
a925 1
		char buf[MAXPATHLEN + 1];
@


1.6
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: alias.c,v 8.206 2001/09/11 04:05:11 gshapiro Exp $")
d18 1
a18 1
# define SEPARATOR ':'
d24 1
a24 1
static char	*aliaslookup __P((char *, int *));
d89 1
d94 1
a94 1
		if (aliaslookup(obuf, &status) != NULL)
d105 1
a105 1
	p = aliaslookup(a->q_user, &status);
d158 1
d171 1
a171 1
	owner = aliaslookup(obuf, &status);
d194 1
d208 1
a208 1
aliaslookup(name, pstat)
d211 1
d214 4
d233 11
d245 1
d409 1
a409 1
		int loopcount = 0;
a414 1
			loopcount++;
d428 3
a430 1
				sm_dprintf("aliaswait: sleeping for %u seconds (loopcount = %d)\n",
d432 1
d602 1
a602 1
# ifdef SIGTSTP
d604 1
a604 1
# endif /* SIGTSTP */
@


1.5
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: alias.c,v 8.203 2001/09/04 22:43:02 ca Exp $")
d26 1
a26 1
/*
d186 1
a186 1
/*
d227 1
a227 1
/*
d349 1
a349 1
/*
d451 1
a451 1
/*
d585 1
a585 1
/*
d836 1
a836 1
/*
@


1.4
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d11 1
d16 1
a16 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: alias.c,v 8.142.4.11 2001/05/03 17:24:01 gshapiro Exp $";
#endif /* ! lint */
d64 1
a64 1
		dprintf("alias(%s)\n", a->q_user);
a82 1

d92 1
a92 2
		(void) strlcpy(obuf, "owner-", sizeof obuf);
		(void) strlcat(obuf, a->q_user, sizeof obuf);
d99 1
a99 1
			a->q_user = newstr(obuf);
d109 5
a113 1
			e->e_message = newstr("alias database unavailable");
d125 2
a126 2
		dprintf("%s (%s, %s) aliased to %s\n",
			a->q_paddr, a->q_host, a->q_user, p);
d135 2
a136 2
			"alias %.100s => %s",
			a->q_paddr, shortenstring(p, MAXSHORTSTR));
d140 2
a141 2
		dprintf("alias: QS_EXPANDED ");
		printaddr(a, FALSE);
a163 1
	(void) strlcpy(obuf, "owner-", sizeof obuf);
d165 2
a166 2
	    strlen(a->q_user) > (SIZE_T) sizeof obuf - 7)
		(void) strlcat(obuf, "owner", sizeof obuf);
d168 1
a168 1
		(void) strlcat(obuf, a->q_user, sizeof obuf);
d176 1
a176 1
	a->q_owner = newstr(owner);
d180 3
a182 2
		fprintf(e->e_xfp, "Message delivered to mailing list %s\n",
			a->q_paddr);
d222 1
a222 1
	if (strcasecmp(name, "postmaster") == 0)
d249 1
a249 1
		dprintf("setalias(%s)\n", spec);
d269 2
a270 2
			(void) strlcpy(buf, "aliases.files sequence",
				       sizeof buf);
d278 1
a278 1
		(void) snprintf(buf, sizeof buf, "Alias%d", NAliasFileMaps);
d300 1
a300 1
			bool quoted = FALSE;
d324 1
a324 1
			dprintf("  map %s:%s %s\n", class, s->s_name, spec);
d340 1
d343 1
a343 1
				map->map_mflags |= MF_VALID|MF_ALIAS;
d363 2
a364 2
**		TRUE -- if the database is open when we return.
**		FALSE -- if the database is closed when we return.
d373 1
a373 1
	bool attimeout = FALSE;
d379 2
a380 2
		dprintf("aliaswait(%s:%s)\n",
			map->map_class->map_cname, map->map_file);
d388 2
a390 1
		unsigned int sleeptime = 2;
d395 1
d399 1
a399 1
				attimeout = TRUE;
d409 2
a410 2
				dprintf("aliaswait: sleeping for %u seconds\n",
					sleeptime);
d427 1
a427 1
			dprintf("aliaswait: not rebuildable\n");
d434 1
a434 1
			dprintf("aliaswait: no source file\n");
d439 2
a440 2
	snprintf(buf, sizeof buf, "%s%s",
		map->map_file, ext == NULL ? "" : ext);
a442 31
#if !_FFR_REMOVE_AUTOREBUILD
		/* database is out of date */
		if (AutoRebuild &&
		    stb.st_ino != 0 &&
		    (stb.st_uid == geteuid() ||
		     (geteuid() == 0 && stb.st_uid == TrustedUid)))
		{
			bool oldSuprErrs;

			message("auto-rebuilding alias database %s", buf);
			oldSuprErrs = SuprErrs;
			SuprErrs = TRUE;
			if (isopen)
			{
				map->map_mflags |= MF_CLOSING;
				map->map_class->map_close(map);
				map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
			}
			(void) rebuildaliases(map, TRUE);
			isopen = map->map_class->map_open(map, O_RDONLY);
			SuprErrs = oldSuprErrs;
		}
		else
		{
			if (LogLevel > 3)
				sm_syslog(LOG_INFO, NOQID,
					"alias database %s out of date",
					buf);
			message("Warning: alias database %s out of date", buf);
		}
#else /* !_FFR_REMOVE_AUTOREBUILD */
d445 1
a445 2
				  "alias database %s out of date",
				  buf);
a446 1
#endif /* !_FFR_REMOVE_AUTOREBUILD */
d459 1
a459 1
**		TRUE if successful; FALSE otherwise.
d471 3
a473 3
	FILE *af;
	bool nolock = FALSE;
	bool success = FALSE;
d481 1
a481 1
		return FALSE;
d501 2
a502 2
				dprintf("Can't open %s: %s\n",
					map->map_file, errstring(saveerr));
d505 1
a505 1
					map->map_file, errstring(saveerr));
d507 1
a507 1
			return FALSE;
d509 1
a509 1
		nolock = TRUE;
d511 1
a511 1
		    fstat(fileno(af), &stb) < 0 ||
d514 1
a514 1
				map->map_file, errstring(errno));
d519 2
a520 1
	    !lockfile(fileno(af), map->map_file, NULL, LOCK_EX|LOCK_NB))
d528 2
a529 2
			(void) lockfile(fileno(af), map->map_file, NULL,
					LOCK_EX);
d531 1
a531 1
		(void) fclose(af);
d533 1
a533 1
		return FALSE;
d536 2
a537 2
	oldsigint = setsignal(SIGINT, SIG_IGN);
	oldsigquit = setsignal(SIGQUIT, SIG_IGN);
d539 1
a539 1
	oldsigtstp = setsignal(SIGTSTP, SIG_IGN);
d552 3
a554 3
		map->map_pid = getpid();
		readaliases(map, af, !automatic, TRUE);
		success = TRUE;
d559 2
a560 2
			dprintf("Can't create database for %s: %s\n",
				map->map_file, errstring(errno));
d567 1
a567 1
	(void) fclose(af);
d578 2
a579 2
	(void) setsignal(SIGINT, oldsigint);
	(void) setsignal(SIGQUIT, oldsigquit);
d581 1
a581 1
	(void) setsignal(SIGTSTP, oldsigtstp);
d609 1
a609 1
	FILE *af;
d627 2
a628 2
	skipping = FALSE;
	while (fgets(line, sizeof line, af) != NULL)
d635 2
d640 2
a641 1
			if (fgets(p, SPACELEFT(line, p), af) == NULL)
d648 1
a648 1
		else if (!feof(af))
d654 2
a655 1
			while ((c = getc(af)) != EOF && c != '\n')
d659 1
a659 1
			skipping = TRUE;
d666 1
a666 1
			skipping = FALSE;
d673 1
a673 1
			skipping = TRUE;
d676 1
a676 1
		skipping = FALSE;
d694 2
a695 1
		if (parseaddr(line, &al, RF_COPYALL, ':', NULL, CurEnv) == NULL)
d731 2
a732 1
						      &delimptr, CurEnv) == NULL)
d743 3
a745 3
			c = getc(af);
			if (!feof(af))
				(void) ungetc(c, af);
d750 2
a751 1
			if (fgets(p, sizeof line - (p - line), af) == NULL)
d756 1
a756 1
			if (strchr(p, '\n') == NULL && !feof(af))
d759 2
a760 1
				while ((c = fgetc(af)) != EOF && c != '\n')
d762 1
a762 1
				skipping = TRUE;
d783 1
a783 1
		if (strcasecmp(al.q_user, "postmaster") == 0)
d812 5
d818 1
a818 1
			sm_free(al.q_paddr);
d820 1
a820 1
			sm_free(al.q_host);
d822 2
a823 1
			sm_free(al.q_user);
d870 1
a870 1
		dprintf("forward(%s)\n", user->q_paddr);
d875 2
d884 3
a886 3
	define('z', user->q_home, e);
	define('u', user->q_user, e);
	define('h', user->q_host, e);
d890 1
a890 1
	got_transient = FALSE;
d906 1
a906 1
			dprintf("forward: trying %s\n", buf);
d908 1
a908 1
		err = include(buf, TRUE, user, sendq, aliaslevel, e);
d914 1
a914 1
			got_transient = TRUE;
d916 2
a917 2
				dprintf("forward: transient error on %s\n",
					buf);
d925 1
a925 1
					  buf, errstring(err));
d955 1
a955 1
				syserr("forward: %s: %s", buf, errstring(err));
d962 2
a963 2
						"forward %s: %s", buf,
						errstring(err));
d966 1
a966 2
						buf,
						errstring(err));
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d16 1
a16 1
static char id[] = "@@(#)$Sendmail: alias.c,v 8.142.4.9 2000/11/08 20:58:42 geir Exp $";
d408 1
d410 1
a410 1
			map->map_mflags &= ~(MF_OPEN|MF_WRITABLE);
d453 1
d455 1
a455 1
				map->map_mflags &= ~(MF_OPEN|MF_WRITABLE);
d600 1
d602 1
a602 1
		map->map_mflags &= ~(MF_OPEN|MF_WRITABLE);
d833 1
a833 1
			free(al.q_paddr);
d835 1
a835 1
			free(al.q_host);
d837 1
a837 1
			free(al.q_user);
@


1.3.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
static char id[] = "@@(#)$Sendmail: alias.c,v 8.142.4.11 2001/05/03 17:24:01 gshapiro Exp $";
a407 1
			map->map_mflags |= MF_CLOSING;
d409 1
a409 1
			map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
a451 1
				map->map_mflags |= MF_CLOSING;
d453 1
a453 1
				map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
a597 1
		map->map_mflags |= MF_CLOSING;
d599 1
a599 1
		map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
d830 1
a830 1
			sm_free(al.q_paddr);
d832 1
a832 1
			sm_free(al.q_host);
d834 1
a834 1
			sm_free(al.q_user);
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d16 1
a16 1
static char id[] = "@@(#)$Sendmail: alias.c,v 8.142 2000/03/31 05:35:29 ca Exp $";
d19 3
d282 2
a283 3

		p = strpbrk(p, " ,/:");
		if (p != NULL && *p == ':')
d440 2
a441 1
		if (AutoRebuild && stb.st_ino != 0 &&
d605 1
a605 1
#ifdef SIGTSTP
d607 1
a607 1
#endif /* SIGTSTP */
d735 1
a735 1
			if (nlp[-1] == '\n')
d840 1
a840 1
		message("%s: %d aliases, longest %d bytes, %d bytes total",
d844 1
a844 1
			"%s: %d aliases, longest %d bytes, %d bytes total",
d906 1
a906 1
		ep = strchr(pp, ':');
d911 1
a911 1
			*ep++ = ':';
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
static char id[] = "@@(#)$Sendmail: alias.c,v 8.142.4.11 2001/05/03 17:24:01 gshapiro Exp $";
a18 3
# define SEPARATOR ':'
# define ALIAS_SPEC_SEPARATORS	" ,/:"

d279 3
a281 2
		p = strpbrk(p, ALIAS_SPEC_SEPARATORS);
		if (p != NULL && *p == SEPARATOR)
a405 1
			map->map_mflags |= MF_CLOSING;
d407 1
a407 1
			map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
d438 1
a438 2
		if (AutoRebuild &&
		    stb.st_ino != 0 &&
a448 1
				map->map_mflags |= MF_CLOSING;
d450 1
a450 1
				map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
a594 1
		map->map_mflags |= MF_CLOSING;
d596 1
a596 1
		map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
d602 1
a602 1
# ifdef SIGTSTP
d604 1
a604 1
# endif /* SIGTSTP */
d732 1
a732 1
			if (nlp > p && nlp[-1] == '\n')
d827 1
a827 1
			sm_free(al.q_paddr);
d829 1
a829 1
			sm_free(al.q_host);
d831 1
a831 1
			sm_free(al.q_user);
d837 1
a837 1
		message("%s: %ld aliases, longest %ld bytes, %ld bytes total",
d841 1
a841 1
			"%s: %ld aliases, longest %ld bytes, %ld bytes total",
d903 1
a903 1
		ep = strchr(pp, SEPARATOR);
d908 1
a908 1
			*ep++ = SEPARATOR;
@


1.1
log
@Initial revision
@
text
@d16 1
a16 1
static char id[] = "@@(#)$Sendmail: alias.c,v 8.140 2000/02/01 05:49:54 gshapiro Exp $";
d669 1
d802 23
a824 1
		map->map_class->map_store(map, al.q_user, rhs);
a831 6

		/* statistics */
		naliases++;
		bytes += lhssize + rhssize;
		if (rhssize > longest)
			longest = rhssize;
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d16 1
a16 1
static char id[] = "@@(#)$Id: alias.c,v 8.142.4.9 2000/11/08 20:58:42 geir Exp $";
a18 3
# define SEPARATOR ':'
# define ALIAS_SPEC_SEPARATORS	" ,/:"

d279 3
a281 2
		p = strpbrk(p, ALIAS_SPEC_SEPARATORS);
		if (p != NULL && *p == SEPARATOR)
d438 1
a438 2
		if (AutoRebuild &&
		    stb.st_ino != 0 &&
d602 1
a602 1
# ifdef SIGTSTP
d604 1
a604 1
# endif /* SIGTSTP */
a668 1
			errno = 0;
d731 1
a731 1
			if (nlp > p && nlp[-1] == '\n')
d801 1
a801 23
		if (rhssize > 0)
		{
			/* is RHS empty (just spaces)? */
			p = rhs;
			while (isascii(*p) && isspace(*p))
				p++;
		}
		if (rhssize == 0 || *p == '\0')
		{
			syserr("554 5.3.5 %.40s... missing value for alias",
			       line);

		}
		else
		{
			map->map_class->map_store(map, al.q_user, rhs);

			/* statistics */
			naliases++;
			bytes += lhssize + rhssize;
			if (rhssize > longest)
				longest = rhssize;
		}
d809 6
d820 1
a820 1
		message("%s: %ld aliases, longest %ld bytes, %ld bytes total",
d824 1
a824 1
			"%s: %ld aliases, longest %ld bytes, %ld bytes total",
d886 1
a886 1
		ep = strchr(pp, SEPARATOR);
d891 1
a891 1
			*ep++ = SEPARATOR;
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
a10 1
 *
d15 3
a17 1
SM_RCSID("@@(#)$Sendmail: alias.c,v 8.203 2001/09/04 22:43:02 ca Exp $")
d65 1
a65 1
		sm_dprintf("alias(%s)\n", a->q_user);
d84 1
d94 2
a95 1
		(void) sm_strlcpyn(obuf, sizeof obuf, 2, "owner-", a->q_user);
d102 1
a102 1
			a->q_user = sm_rpool_strdup_x(e->e_rpool, obuf);
d112 1
a112 5
			e->e_message = "alias database unavailable";

		/* XXX msg only per recipient? */
		if (a->q_message == NULL)
			a->q_message = "alias database unavailable";
d124 2
a125 2
		sm_dprintf("%s (%s, %s) aliased to %s\n",
			   a->q_paddr, a->q_host, a->q_user, p);
d134 2
a135 2
			  "alias %.100s => %s",
			  a->q_paddr, shortenstring(p, MAXSHORTSTR));
d139 2
a140 2
		sm_dprintf("alias: QS_EXPANDED ");
		printaddr(a, false);
d163 1
d165 2
a166 2
	    strlen(a->q_user) > sizeof obuf - 7)
		(void) sm_strlcpy(obuf, "owner-owner", sizeof obuf);
d168 1
a168 1
		(void) sm_strlcpyn(obuf, sizeof obuf, 2, "owner-", a->q_user);
d176 1
a176 1
	a->q_owner = sm_rpool_strdup_x(e->e_rpool, owner);
d180 2
a181 3
		(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
				"Message delivered to mailing list %s\n",
				a->q_paddr);
d221 1
a221 1
	if (sm_strcasecmp(name, "postmaster") == 0)
d248 1
a248 1
		sm_dprintf("setalias(%s)\n", spec);
d268 2
a269 2
			(void) sm_strlcpy(buf, "aliases.files sequence",
					  sizeof buf);
d277 1
a277 1
		(void) sm_snprintf(buf, sizeof buf, "Alias%d", NAliasFileMaps);
d299 1
a299 1
			bool quoted = false;
d323 1
a323 1
			sm_dprintf("  map %s:%s %s\n", class, s->s_name, spec);
a338 1
			map->map_mflags |= MF_ALIAS;
d341 1
a341 1
				map->map_mflags |= MF_VALID;
d361 2
a362 2
**		true -- if the database is open when we return.
**		false -- if the database is closed when we return.
d371 1
a371 1
	bool attimeout = false;
d377 2
a378 2
		sm_dprintf("aliaswait(%s:%s)\n",
			   map->map_class->map_cname, map->map_file);
d386 1
a387 2
		int loopcount = 0;
		time_t toolong = curtime() + SafeAlias;
a391 1
			loopcount++;
d395 1
a395 1
				attimeout = true;
d405 2
a406 2
				sm_dprintf("aliaswait: sleeping for %u seconds (loopcount = %d)\n",
					   sleeptime, loopcount);
a407 1
			map->map_mflags |= MF_CLOSING;
d409 1
a409 1
			map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
d422 1
a422 1
			sm_dprintf("aliaswait: not rebuildable\n");
d429 1
a429 1
			sm_dprintf("aliaswait: no source file\n");
d434 2
a435 2
	(void) sm_strlcpyn(buf, sizeof buf, 2,
			   map->map_file, ext == NULL ? "" : ext);
d438 30
d470 2
a471 1
				  "alias database %s out of date", buf);
d473 1
d486 1
a486 1
**		true if successful; false otherwise.
d498 3
a500 3
	SM_FILE_T *af;
	bool nolock = false;
	bool success = false;
d508 1
a508 1
		return false;
d528 2
a529 2
				sm_dprintf("Can't open %s: %s\n",
					map->map_file, sm_errstring(saveerr));
d532 1
a532 1
					map->map_file, sm_errstring(saveerr));
d534 1
a534 1
			return false;
d536 1
a536 1
		nolock = true;
d538 1
a538 1
		    fstat(sm_io_getinfo(af, SM_IO_WHAT_FD, NULL), &stb) < 0 ||
d541 1
a541 1
				map->map_file, sm_errstring(errno));
d546 1
a546 2
	    !lockfile(sm_io_getinfo(af, SM_IO_WHAT_FD, NULL), map->map_file,
		      NULL, LOCK_EX|LOCK_NB))
d554 2
a555 2
			(void) lockfile(sm_io_getinfo(af, SM_IO_WHAT_FD, NULL),
					map->map_file, NULL, LOCK_EX);
d557 1
a557 1
		(void) sm_io_close(af, SM_TIME_DEFAULT);
d559 1
a559 1
		return false;
d562 2
a563 2
	oldsigint = sm_signal(SIGINT, SIG_IGN);
	oldsigquit = sm_signal(SIGQUIT, SIG_IGN);
d565 1
a565 1
	oldsigtstp = sm_signal(SIGTSTP, SIG_IGN);
d578 3
a580 3
		map->map_pid = CurrentPid;
		readaliases(map, af, !automatic, true);
		success = true;
d585 2
a586 2
			sm_dprintf("Can't create database for %s: %s\n",
				map->map_file, sm_errstring(errno));
d593 1
a593 1
	(void) sm_io_close(af, SM_TIME_DEFAULT);
a597 1
		map->map_mflags |= MF_CLOSING;
d599 1
a599 1
		map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
d603 2
a604 2
	(void) sm_signal(SIGINT, oldsigint);
	(void) sm_signal(SIGQUIT, oldsigquit);
d606 1
a606 1
	(void) sm_signal(SIGTSTP, oldsigtstp);
d634 1
a634 1
	SM_FILE_T *af;
d652 2
a653 2
	skipping = false;
	while (sm_io_fgets(af, SM_TIME_DEFAULT, line, sizeof line) != NULL)
a659 2

		/* XXX what if line="a\\" ? */
d663 1
a663 2
			if (sm_io_fgets(af, SM_TIME_DEFAULT, p,
					SPACELEFT(line, p)) == NULL)
d670 1
a670 1
		else if (!sm_io_eof(af))
d676 1
a676 2
			while ((c = sm_io_getc(af, SM_TIME_DEFAULT)) !=
				SM_IO_EOF && c != '\n')
d680 1
a680 1
			skipping = true;
d687 1
a687 1
			skipping = false;
d694 1
a694 1
			skipping = true;
d697 1
a697 1
		skipping = false;
d715 1
a715 2
		if (parseaddr(line, &al, RF_COPYALL, ':', NULL, CurEnv, true)
		    == NULL)
d751 1
a751 2
						      &delimptr, CurEnv, true)
					    == NULL)
d762 3
a764 3
			c = sm_io_getc(af, SM_TIME_DEFAULT);
			if (!sm_io_eof(af))
				(void) sm_io_ungetc(af, SM_TIME_DEFAULT, c);
d769 1
a769 2
			if (sm_io_fgets(af, SM_TIME_DEFAULT, p,
					sizeof line - (p-line)) == NULL)
d774 1
a774 1
			if (strchr(p, '\n') == NULL && !sm_io_eof(af))
d777 1
a777 2
				while ((c = sm_io_getc(af, SM_TIME_DEFAULT))
				       != SM_IO_EOF && c != '\n')
d779 1
a779 1
				skipping = true;
d800 1
a800 1
		if (sm_strcasecmp(al.q_user, "postmaster") == 0)
a828 5
#if 0
	/*
	**  address strings are now stored in the envelope rpool,
	**  and therefore cannot be freed.
	*/
d830 1
a830 1
			sm_free(al.q_paddr);  /* disabled */
d832 1
a832 1
			sm_free(al.q_host);  /* disabled */
d834 1
a834 2
			sm_free(al.q_user);  /* disabled */
#endif /* 0 */
d881 1
a881 1
		sm_dprintf("forward(%s)\n", user->q_paddr);
a885 2
	if (ForwardPath != NULL && *ForwardPath == '\0')
		return;
d893 3
a895 3
	macdefine(&e->e_macro, A_PERM, 'z', user->q_home);
	macdefine(&e->e_macro, A_PERM, 'u', user->q_user);
	macdefine(&e->e_macro, A_PERM, 'h', user->q_host);
d899 1
a899 1
	got_transient = false;
d915 1
a915 1
			sm_dprintf("forward: trying %s\n", buf);
d917 1
a917 1
		err = include(buf, true, user, sendq, aliaslevel, e);
d923 1
a923 1
			got_transient = true;
d925 2
a926 2
				sm_dprintf("forward: transient error on %s\n",
					   buf);
d934 1
a934 1
					  buf, sm_errstring(err));
d964 1
a964 1
				syserr("forward: %s: %s", buf, sm_errstring(err));
d971 2
a972 2
						  "forward %s: %s", buf,
						  sm_errstring(err));
d975 2
a976 1
						buf, sm_errstring(err));
@


