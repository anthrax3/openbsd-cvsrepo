head	1.24;
access;
symbols
	OPENBSD_5_6:1.23.0.6
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.21.0.8
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.6
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.4
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.20.0.12
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.10
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.6
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.8
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.4
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.19.0.8
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.6
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.4
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.17.0.6
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.4
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.8.0.4
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2014.09.17.18.49.52;	author matthieu;	state dead;
branches;
next	1.23;
commitid	M7i5giHIoz3DMlTU;

1.23
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.21;

1.21
date	2011.05.17.15.54.24;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2006.08.13.13.01.48;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.22.18.43.56;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.12.18.15.46;	author millert;	state Exp;
branches
	1.17.2.1
	1.17.4.1
	1.17.6.1;
next	1.16;

1.16
date	2004.12.16.00.21.31;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.24.03.59.27;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.09.17.17.31.40;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.01.19.59.23;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.15.02.23.36;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.26.04.48.55;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.03.17.25.47;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.18.00.49.28;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.01.17.18.30;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.11.19.02.50;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.01.01.01.41;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.07.01.02.47;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.29.01.31.16;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.15.21.09.10;	author millert;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.04.07.19.20.44;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.48;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.48;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.17;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.51;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.31.42;	author miod;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.31.01.47.58;	author jason;	state Exp;
branches;
next	;

1.17.2.1
date	2006.03.24.05.42.48;	author brad;	state Exp;
branches;
next	;

1.17.4.1
date	2006.03.24.05.56.18;	author brad;	state Exp;
branches;
next	;

1.17.6.1
date	2006.03.25.01.49.38;	author brad;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Bye.
@
text
@/*
 * Copyright (c) 1999-2006, 2008 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sm/gen.h>
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.121 2013/11/22 20:51:56 ca Exp $")
#include <stdlib.h>
#include <sendmail.h>
#include <sm/time.h>
#include <errno.h>

/* allow to disable error handling code just in case... */
#ifndef DEAL_WITH_ERROR_SSL
# define DEAL_WITH_ERROR_SSL	1
#endif /* ! DEAL_WITH_ERROR_SSL */

#if SASL
# include "sfsasl.h"

/* Structure used by the "sasl" file type */
struct sasl_obj
{
	SM_FILE_T *fp;
	sasl_conn_t *conn;
};

struct sasl_info
{
	SM_FILE_T *fp;
	sasl_conn_t *conn;
};

/*
**  SASL_GETINFO - returns requested information about a "sasl" file
**		  descriptor.
**
**	Parameters:
**		fp -- the file descriptor
**		what -- the type of information requested
**		valp -- the thang to return the information in
**
**	Returns:
**		-1 for unknown requests
**		>=0 on success with valp filled in (if possible).
*/

static int sasl_getinfo __P((SM_FILE_T *, int, void *));

static int
sasl_getinfo(fp, what, valp)
	SM_FILE_T *fp;
	int what;
	void *valp;
{
	struct sasl_obj *so = (struct sasl_obj *) fp->f_cookie;

	switch (what)
	{
	  case SM_IO_WHAT_FD:
		if (so->fp == NULL)
			return -1;
		return so->fp->f_file; /* for stdio fileno() compatability */

	  case SM_IO_IS_READABLE:
		if (so->fp == NULL)
			return 0;

		/* get info from underlying file */
		return sm_io_getinfo(so->fp, what, valp);

	  default:
		return -1;
	}
}

/*
**  SASL_OPEN -- creates the sasl specific information for opening a
**		file of the sasl type.
**
**	Parameters:
**		fp -- the file pointer associated with the new open
**		info -- contains the sasl connection information pointer and
**			the original SM_FILE_T that holds the open
**		flags -- ignored
**		rpool -- ignored
**
**	Returns:
**		0 on success
*/

static int sasl_open __P((SM_FILE_T *, const void *, int, const void *));

/* ARGSUSED2 */
static int
sasl_open(fp, info, flags, rpool)
	SM_FILE_T *fp;
	const void *info;
	int flags;
	const void *rpool;
{
	struct sasl_obj *so;
	struct sasl_info *si = (struct sasl_info *) info;

	so = (struct sasl_obj *) sm_malloc(sizeof(struct sasl_obj));
	if (so == NULL)
	{
		errno = ENOMEM;
		return -1;
	}
	so->fp = si->fp;
	so->conn = si->conn;

	/*
	**  The underlying 'fp' is set to SM_IO_NOW so that the entire
	**  encoded string is written in one chunk. Otherwise there is
	**  the possibility that it may appear illegal, bogus or
	**  mangled to the other side of the connection.
	**  We will read or write through 'fp' since it is the opaque
	**  connection for the communications. We need to treat it this
	**  way in case the encoded string is to be sent down a TLS
	**  connection rather than, say, sm_io's stdio.
	*/

	(void) sm_io_setvbuf(so->fp, SM_TIME_DEFAULT, NULL, SM_IO_NOW, 0);
	fp->f_cookie = so;
	return 0;
}

/*
**  SASL_CLOSE -- close the sasl specific parts of the sasl file pointer
**
**	Parameters:
**		fp -- the file pointer to close
**
**	Returns:
**		0 on success
*/

static int sasl_close __P((SM_FILE_T *));

static int
sasl_close(fp)
	SM_FILE_T *fp;
{
	struct sasl_obj *so;

	so = (struct sasl_obj *) fp->f_cookie;
	if (so == NULL)
		return 0;
	if (so->fp != NULL)
	{
		sm_io_close(so->fp, SM_TIME_DEFAULT);
		so->fp = NULL;
	}
	sm_free(so);
	so = NULL;
	return 0;
}

/* how to deallocate a buffer allocated by SASL */
extern void	sm_sasl_free __P((void *));
#  define SASL_DEALLOC(b)	sm_sasl_free(b)

/*
**  SASL_READ -- read encrypted information and decrypt it for the caller
**
**	Parameters:
**		fp -- the file pointer
**		buf -- the location to place the decrypted information
**		size -- the number of bytes to read after decryption
**
**	Results:
**		-1 on error
**		otherwise the number of bytes read
*/

static ssize_t sasl_read __P((SM_FILE_T *, char *, size_t));

static ssize_t
sasl_read(fp, buf, size)
	SM_FILE_T *fp;
	char *buf;
	size_t size;
{
	int result;
	ssize_t len;
# if SASL >= 20000
	static const char *outbuf = NULL;
# else /* SASL >= 20000 */
	static char *outbuf = NULL;
# endif /* SASL >= 20000 */
	static unsigned int outlen = 0;
	static unsigned int offset = 0;
	struct sasl_obj *so = (struct sasl_obj *) fp->f_cookie;

	/*
	**  sasl_decode() may require more data than a single read() returns.
	**  Hence we have to put a loop around the decoding.
	**  This also requires that we may have to split up the returned
	**  data since it might be larger than the allowed size.
	**  Therefore we use a static pointer and return portions of it
	**  if necessary.
	**  XXX Note: This function is not thread-safe nor can it be used
	**  on more than one file. A correct implementation would store
	**  this data in fp->f_cookie.
	*/

# if SASL >= 20000
	while (outlen == 0)
# else /* SASL >= 20000 */
	while (outbuf == NULL && outlen == 0)
# endif /* SASL >= 20000 */
	{
		len = sm_io_read(so->fp, SM_TIME_DEFAULT, buf, size);
		if (len <= 0)
			return len;
		result = sasl_decode(so->conn, buf,
				     (unsigned int) len, &outbuf, &outlen);
		if (result != SASL_OK)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					"AUTH: sasl_decode error=%d", result);
			outbuf = NULL;
			offset = 0;
			outlen = 0;
			return -1;
		}
	}

	if (outbuf == NULL)
	{
		/* be paranoid: outbuf == NULL but outlen != 0 */
		syserr("@@sasl_read failure: outbuf == NULL but outlen != 0");
		/* NOTREACHED */
	}
	if (outlen - offset > size)
	{
		/* return another part of the buffer */
		(void) memcpy(buf, outbuf + offset, size);
		offset += size;
		len = size;
	}
	else
	{
		/* return the rest of the buffer */
		len = outlen - offset;
		(void) memcpy(buf, outbuf + offset, (size_t) len);
# if SASL < 20000
		SASL_DEALLOC(outbuf);
# endif /* SASL < 20000 */
		outbuf = NULL;
		offset = 0;
		outlen = 0;
	}
	return len;
}

/*
**  SASL_WRITE -- write information out after encrypting it
**
**	Parameters:
**		fp -- the file pointer
**		buf -- holds the data to be encrypted and written
**		size -- the number of bytes to have encrypted and written
**
**	Returns:
**		-1 on error
**		otherwise number of bytes written
*/

static ssize_t sasl_write __P((SM_FILE_T *, const char *, size_t));

static ssize_t
sasl_write(fp, buf, size)
	SM_FILE_T *fp;
	const char *buf;
	size_t size;
{
	int result;
# if SASL >= 20000
	const char *outbuf;
# else /* SASL >= 20000 */
	char *outbuf;
# endif /* SASL >= 20000 */
	unsigned int outlen, *maxencode;
	size_t ret = 0, total = 0;
	struct sasl_obj *so = (struct sasl_obj *) fp->f_cookie;

	/*
	**  Fetch the maximum input buffer size for sasl_encode().
	**  This can be less than the size set in attemptauth()
	**  due to a negotiation with the other side, e.g.,
	**  Cyrus IMAP lmtp program sets maxbuf=4096,
	**  digestmd5 substracts 25 and hence we'll get 4071
	**  instead of 8192 (MAXOUTLEN).
	**  Hack (for now): simply reduce the size, callers are (must be)
	**  able to deal with that and invoke sasl_write() again with
	**  the rest of the data.
	**  Note: it would be better to store this value in the context
	**  after the negotiation.
	*/

	result = sasl_getprop(so->conn, SASL_MAXOUTBUF,
				(const void **) &maxencode);
	if (result == SASL_OK && size > *maxencode && *maxencode > 0)
		size = *maxencode;

	result = sasl_encode(so->conn, buf,
			     (unsigned int) size, &outbuf, &outlen);

	if (result != SASL_OK)
	{
		if (LogLevel > 7)
			sm_syslog(LOG_WARNING, NOQID,
				"AUTH: sasl_encode error=%d", result);
		return -1;
	}

	if (outbuf != NULL)
	{
		while (outlen > 0)
		{
			errno = 0;
			/* XXX result == 0? */
			ret = sm_io_write(so->fp, SM_TIME_DEFAULT,
					  &outbuf[total], outlen);
			if (ret <= 0)
				return ret;
			outlen -= ret;
			total += ret;
		}
# if SASL < 20000
		SASL_DEALLOC(outbuf);
# endif /* SASL < 20000 */
	}
	return size;
}

/*
**  SFDCSASL -- create sasl file type and open in and out file pointers
**	       for sendmail to read from and write to.
**
**	Parameters:
**		fin -- the sm_io file encrypted data to be read from
**		fout -- the sm_io file encrypted data to be written to
**		conn -- the sasl connection pointer
**		tmo -- timeout
**
**	Returns:
**		-1 on error
**		0 on success
**
**	Side effects:
**		The arguments "fin" and "fout" are replaced with the new
**		SM_FILE_T pointers.
*/

int
sfdcsasl(fin, fout, conn, tmo)
	SM_FILE_T **fin;
	SM_FILE_T **fout;
	sasl_conn_t *conn;
	int tmo;
{
	SM_FILE_T *newin, *newout;
	SM_FILE_T  SM_IO_SET_TYPE(sasl_vector, "sasl", sasl_open, sasl_close,
		sasl_read, sasl_write, NULL, sasl_getinfo, NULL,
		SM_TIME_DEFAULT);
	struct sasl_info info;

	if (conn == NULL)
	{
		/* no need to do anything */
		return 0;
	}

	SM_IO_INIT_TYPE(sasl_vector, "sasl", sasl_open, sasl_close,
		sasl_read, sasl_write, NULL, sasl_getinfo, NULL,
		SM_TIME_DEFAULT);
	info.fp = *fin;
	info.conn = conn;
	newin = sm_io_open(&sasl_vector, SM_TIME_DEFAULT, &info,
			SM_IO_RDONLY_B, NULL);

	if (newin == NULL)
		return -1;

	info.fp = *fout;
	info.conn = conn;
	newout = sm_io_open(&sasl_vector, SM_TIME_DEFAULT, &info,
			SM_IO_WRONLY_B, NULL);

	if (newout == NULL)
	{
		(void) sm_io_close(newin, SM_TIME_DEFAULT);
		return -1;
	}
	sm_io_automode(newin, newout);

	sm_io_setinfo(*fin, SM_IO_WHAT_TIMEOUT, &tmo);
	sm_io_setinfo(*fout, SM_IO_WHAT_TIMEOUT, &tmo);

	*fin = newin;
	*fout = newout;
	return 0;
}
#endif /* SASL */

#if STARTTLS
# include "sfsasl.h"
#  include <openssl/err.h>

/* Structure used by the "tls" file type */
struct tls_obj
{
	SM_FILE_T *fp;
	SSL *con;
};

struct tls_info
{
	SM_FILE_T *fp;
	SSL *con;
};

/*
**  TLS_GETINFO - returns requested information about a "tls" file
**		 descriptor.
**
**	Parameters:
**		fp -- the file descriptor
**		what -- the type of information requested
**		valp -- the thang to return the information in (unused)
**
**	Returns:
**		-1 for unknown requests
**		>=0 on success with valp filled in (if possible).
*/

static int tls_getinfo __P((SM_FILE_T *, int, void *));

/* ARGSUSED2 */
static int
tls_getinfo(fp, what, valp)
	SM_FILE_T *fp;
	int what;
	void *valp;
{
	struct tls_obj *so = (struct tls_obj *) fp->f_cookie;

	switch (what)
	{
	  case SM_IO_WHAT_FD:
		if (so->fp == NULL)
			return -1;
		return so->fp->f_file; /* for stdio fileno() compatability */

	  case SM_IO_IS_READABLE:
		return SSL_pending(so->con) > 0;

	  default:
		return -1;
	}
}

/*
**  TLS_OPEN -- creates the tls specific information for opening a
**	       file of the tls type.
**
**	Parameters:
**		fp -- the file pointer associated with the new open
**		info -- the sm_io file pointer holding the open and the
**			TLS encryption connection to be read from or written to
**		flags -- ignored
**		rpool -- ignored
**
**	Returns:
**		0 on success
*/

static int tls_open __P((SM_FILE_T *, const void *, int, const void *));

/* ARGSUSED2 */
static int
tls_open(fp, info, flags, rpool)
	SM_FILE_T *fp;
	const void *info;
	int flags;
	const void *rpool;
{
	struct tls_obj *so;
	struct tls_info *ti = (struct tls_info *) info;

	so = (struct tls_obj *) sm_malloc(sizeof(struct tls_obj));
	if (so == NULL)
	{
		errno = ENOMEM;
		return -1;
	}
	so->fp = ti->fp;
	so->con = ti->con;

	/*
	**  We try to get the "raw" file descriptor that TLS uses to
	**  do the actual read/write with. This is to allow us control
	**  over the file descriptor being a blocking or non-blocking type.
	**  Under the covers TLS handles the change and this allows us
	**  to do timeouts with sm_io.
	*/

	fp->f_file = sm_io_getinfo(so->fp, SM_IO_WHAT_FD, NULL);
	(void) sm_io_setvbuf(so->fp, SM_TIME_DEFAULT, NULL, SM_IO_NOW, 0);
	fp->f_cookie = so;
	return 0;
}

/*
**  TLS_CLOSE -- close the tls specific parts of the tls file pointer
**
**	Parameters:
**		fp -- the file pointer to close
**
**	Returns:
**		0 on success
*/

static int tls_close __P((SM_FILE_T *));

static int
tls_close(fp)
	SM_FILE_T *fp;
{
	struct tls_obj *so;

	so = (struct tls_obj *) fp->f_cookie;
	if (so == NULL)
		return 0;
	if (so->fp != NULL)
	{
		sm_io_close(so->fp, SM_TIME_DEFAULT);
		so->fp = NULL;
	}
	sm_free(so);
	so = NULL;
	return 0;
}

/* maximum number of retries for TLS related I/O due to handshakes */
# define MAX_TLS_IOS	4

/*
**  TLS_RETRY -- check whether a failed SSL operation can be retried
**
**	Parameters:
**		ssl -- TLS structure
**		rfd -- read fd
**		wfd -- write fd
**		tlsstart -- start time of TLS operation
**		timeout -- timeout for TLS operation
**		err -- SSL error
**		where -- description of operation
**
**	Results:
**		>0 on success
**		0 on timeout
**		<0 on error
*/

int
tls_retry(ssl, rfd, wfd, tlsstart, timeout, err, where)
	SSL *ssl;
	int rfd;
	int wfd;
	time_t tlsstart;
	int timeout;
	int err;
	const char *where;
{
	int ret;
	time_t left;
	time_t now = curtime();
	struct timeval tv;

	ret = -1;

	/*
	**  For SSL_ERROR_WANT_{READ,WRITE}:
	**  There is not a complete SSL record available yet
	**  or there is only a partial SSL record removed from
	**  the network (socket) buffer into the SSL buffer.
	**  The SSL_connect will only succeed when a full
	**  SSL record is available (assuming a "real" error
	**  doesn't happen). To handle when a "real" error
	**  does happen the select is set for exceptions too.
	**  The connection may be re-negotiated during this time
	**  so both read and write "want errors" need to be handled.
	**  A select() exception loops back so that a proper SSL
	**  error message can be gotten.
	*/

	left = timeout - (now - tlsstart);
	if (left <= 0)
		return 0;	/* timeout */
	tv.tv_sec = left;
	tv.tv_usec = 0;

	if (LogLevel > 14)
	{
		sm_syslog(LOG_INFO, NOQID,
			  "STARTTLS=%s, info: fds=%d/%d, err=%d",
			  where, rfd, wfd, err);
	}

	if (FD_SETSIZE > 0 &&
	    ((err == SSL_ERROR_WANT_READ && rfd >= FD_SETSIZE) ||
	     (err == SSL_ERROR_WANT_WRITE && wfd >= FD_SETSIZE)))
	{
		if (LogLevel > 5)
		{
			sm_syslog(LOG_ERR, NOQID,
				  "STARTTLS=%s, error: fd %d/%d too large",
				  where, rfd, wfd);
		if (LogLevel > 8)
			tlslogerr(LOG_WARNING, where);
		}
		errno = EINVAL;
	}
	else if (err == SSL_ERROR_WANT_READ)
	{
		fd_set ssl_maskr, ssl_maskx;
		int save_errno = errno;

		FD_ZERO(&ssl_maskr);
		FD_SET(rfd, &ssl_maskr);
		FD_ZERO(&ssl_maskx);
		FD_SET(rfd, &ssl_maskx);
		do
		{
			ret = select(rfd + 1, &ssl_maskr, NULL, &ssl_maskx,
					&tv);
		} while (ret < 0 && errno == EINTR);
		if (ret < 0 && errno > 0)
			ret = -errno;
		errno = save_errno;
	}
	else if (err == SSL_ERROR_WANT_WRITE)
	{
		fd_set ssl_maskw, ssl_maskx;
		int save_errno = errno;

		FD_ZERO(&ssl_maskw);
		FD_SET(wfd, &ssl_maskw);
		FD_ZERO(&ssl_maskx);
		FD_SET(rfd, &ssl_maskx);
		do
		{
			ret = select(wfd + 1, NULL, &ssl_maskw, &ssl_maskx,
					&tv);
		} while (ret < 0 && errno == EINTR);
		if (ret < 0 && errno > 0)
			ret = -errno;
		errno = save_errno;
	}
	return ret;
}

/* errno to force refill() etc to stop (see IS_IO_ERROR()) */
#ifdef ETIMEDOUT
# define SM_ERR_TIMEOUT	ETIMEDOUT
#else /* ETIMEDOUT */
# define SM_ERR_TIMEOUT	EIO
#endif /* ETIMEDOUT */

/*
**  SET_TLS_RD_TMO -- read secured information for the caller
**
**	Parameters:
**		rd_tmo -- read timeout
**
**	Results:
**		none
**	This is a hack: there is no way to pass it in
*/

static int tls_rd_tmo = -1;

void
set_tls_rd_tmo(rd_tmo)
	int rd_tmo;
{
	tls_rd_tmo = rd_tmo;
}

/*
**  TLS_READ -- read secured information for the caller
**
**	Parameters:
**		fp -- the file pointer
**		buf -- the location to place the data
**		size -- the number of bytes to read from connection
**
**	Results:
**		-1 on error
**		otherwise the number of bytes read
*/

static ssize_t tls_read __P((SM_FILE_T *, char *, size_t));

static ssize_t
tls_read(fp, buf, size)
	SM_FILE_T *fp;
	char *buf;
	size_t size;
{
	int r, rfd, wfd, try, ssl_err;
	struct tls_obj *so = (struct tls_obj *) fp->f_cookie;
	time_t tlsstart;
	char *err;

	try = 99;
	err = NULL;
	tlsstart = curtime();

  retry:
	r = SSL_read(so->con, (char *) buf, size);

	if (r > 0)
		return r;

	err = NULL;
	switch (ssl_err = SSL_get_error(so->con, r))
	{
	  case SSL_ERROR_NONE:
	  case SSL_ERROR_ZERO_RETURN:
		break;
	  case SSL_ERROR_WANT_WRITE:
		err = "read W BLOCK";
		/* FALLTHROUGH */
	  case SSL_ERROR_WANT_READ:
		if (err == NULL)
			err = "read R BLOCK";
		rfd = SSL_get_rfd(so->con);
		wfd = SSL_get_wfd(so->con);
		try = tls_retry(so->con, rfd, wfd, tlsstart,
				(tls_rd_tmo < 0) ? TimeOuts.to_datablock
						 : tls_rd_tmo,
				ssl_err, "read");
		if (try > 0)
			goto retry;
		errno = SM_ERR_TIMEOUT;
		break;

	  case SSL_ERROR_WANT_X509_LOOKUP:
		err = "write X BLOCK";
		break;
	  case SSL_ERROR_SYSCALL:
		if (r == 0 && errno == 0) /* out of protocol EOF found */
			break;
		err = "syscall error";
/*
		get_last_socket_error());
*/
		break;
	  case SSL_ERROR_SSL:
#if DEAL_WITH_ERROR_SSL
		if (r == 0 && errno == 0) /* out of protocol EOF found */
			break;
#endif /* DEAL_WITH_ERROR_SSL */
		err = "generic SSL error";

		if (LogLevel > 9)
		{
			int pri;

			if (errno == EAGAIN && try > 0)
				pri = LOG_DEBUG;
			else
				pri = LOG_WARNING;
			tlslogerr(pri, "read");
		}

#if DEAL_WITH_ERROR_SSL
		/* avoid repeated calls? */
		if (r == 0)
			r = -1;
#endif /* DEAL_WITH_ERROR_SSL */
		break;
	}
	if (err != NULL)
	{
		int save_errno;

		save_errno = (errno == 0) ? EIO : errno;
		if (try == 0 && save_errno == SM_ERR_TIMEOUT)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					  "STARTTLS: read error=timeout");
		}
		else if (LogLevel > 8)
		{
			int pri;

			if (save_errno == EAGAIN && try > 0)
				pri = LOG_DEBUG;
			else
				pri = LOG_WARNING;
			sm_syslog(pri, NOQID,
				  "STARTTLS: read error=%s (%d), errno=%d, get_error=%s, retry=%d, ssl_err=%d",
				  err, r, errno,
				  ERR_error_string(ERR_get_error(), NULL), try,
				  ssl_err);
		}
		else if (LogLevel > 7)
			sm_syslog(LOG_WARNING, NOQID,
				  "STARTTLS: read error=%s (%d), retry=%d, ssl_err=%d",
				  err, r, errno, try, ssl_err);
		errno = save_errno;
	}
	return r;
}

/*
**  TLS_WRITE -- write information out through secure connection
**
**	Parameters:
**		fp -- the file pointer
**		buf -- holds the data to be securely written
**		size -- the number of bytes to write
**
**	Returns:
**		-1 on error
**		otherwise number of bytes written
*/

static ssize_t tls_write __P((SM_FILE_T *, const char *, size_t));

static ssize_t
tls_write(fp, buf, size)
	SM_FILE_T *fp;
	const char *buf;
	size_t size;
{
	int r, rfd, wfd, try, ssl_err;
	struct tls_obj *so = (struct tls_obj *) fp->f_cookie;
	time_t tlsstart;
	char *err;

	try = 99;
	err = NULL;
	tlsstart = curtime();

  retry:
	r = SSL_write(so->con, (char *) buf, size);

	if (r > 0)
		return r;
	err = NULL;
	switch (ssl_err = SSL_get_error(so->con, r))
	{
	  case SSL_ERROR_NONE:
	  case SSL_ERROR_ZERO_RETURN:
		break;
	  case SSL_ERROR_WANT_WRITE:
		err = "read W BLOCK";
		/* FALLTHROUGH */
	  case SSL_ERROR_WANT_READ:
		if (err == NULL)
			err = "read R BLOCK";
		rfd = SSL_get_rfd(so->con);
		wfd = SSL_get_wfd(so->con);
		try = tls_retry(so->con, rfd, wfd, tlsstart,
				DATA_PROGRESS_TIMEOUT, ssl_err, "write");
		if (try > 0)
			goto retry;
		errno = SM_ERR_TIMEOUT;
		break;
	  case SSL_ERROR_WANT_X509_LOOKUP:
		err = "write X BLOCK";
		break;
	  case SSL_ERROR_SYSCALL:
		if (r == 0 && errno == 0) /* out of protocol EOF found */
			break;
		err = "syscall error";
/*
		get_last_socket_error());
*/
		break;
	  case SSL_ERROR_SSL:
		err = "generic SSL error";
/*
		ERR_GET_REASON(ERR_peek_error()));
*/
		if (LogLevel > 9)
			tlslogerr(LOG_WARNING, "write");

#if DEAL_WITH_ERROR_SSL
		/* avoid repeated calls? */
		if (r == 0)
			r = -1;
#endif /* DEAL_WITH_ERROR_SSL */
		break;
	}
	if (err != NULL)
	{
		int save_errno;

		save_errno = (errno == 0) ? EIO : errno;
		if (try == 0 && save_errno == SM_ERR_TIMEOUT)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					  "STARTTLS: write error=timeout");
		}
		else if (LogLevel > 8)
			sm_syslog(LOG_WARNING, NOQID,
				  "STARTTLS: write error=%s (%d), errno=%d, get_error=%s, retry=%d, ssl_err=%d",
				  err, r, errno,
				  ERR_error_string(ERR_get_error(), NULL), try,
				  ssl_err);
		else if (LogLevel > 7)
			sm_syslog(LOG_WARNING, NOQID,
				  "STARTTLS: write error=%s (%d), errno=%d, retry=%d, ssl_err=%d",
				  err, r, errno, try, ssl_err);
		errno = save_errno;
	}
	return r;
}

/*
**  SFDCTLS -- create tls file type and open in and out file pointers
**	      for sendmail to read from and write to.
**
**	Parameters:
**		fin -- data input source being replaced
**		fout -- data output source being replaced
**		con -- the tls connection pointer
**
**	Returns:
**		-1 on error
**		0 on success
**
**	Side effects:
**		The arguments "fin" and "fout" are replaced with the new
**		SM_FILE_T pointers.
**		The original "fin" and "fout" are preserved in the tls file
**		type but are not actually used because of the design of TLS.
*/

int
sfdctls(fin, fout, con)
	SM_FILE_T **fin;
	SM_FILE_T **fout;
	SSL *con;
{
	SM_FILE_T *tlsin, *tlsout;
	SM_FILE_T SM_IO_SET_TYPE(tls_vector, "tls", tls_open, tls_close,
		tls_read, tls_write, NULL, tls_getinfo, NULL,
		SM_TIME_FOREVER);
	struct tls_info info;

	SM_ASSERT(con != NULL);

	SM_IO_INIT_TYPE(tls_vector, "tls", tls_open, tls_close,
		tls_read, tls_write, NULL, tls_getinfo, NULL,
		SM_TIME_FOREVER);
	info.fp = *fin;
	info.con = con;
	tlsin = sm_io_open(&tls_vector, SM_TIME_DEFAULT, &info, SM_IO_RDONLY_B,
			   NULL);
	if (tlsin == NULL)
		return -1;

	info.fp = *fout;
	tlsout = sm_io_open(&tls_vector, SM_TIME_DEFAULT, &info, SM_IO_WRONLY_B,
			    NULL);
	if (tlsout == NULL)
	{
		(void) sm_io_close(tlsin, SM_TIME_DEFAULT);
		return -1;
	}
	sm_io_automode(tlsin, tlsout);

	*fin = tlsin;
	*fout = tlsout;
	return 0;
}
#endif /* STARTTLS */
@


1.23
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.22
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2006, 2008 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.120 2013/03/15 17:49:12 guenther Exp $")
@


1.21
log
@Update to sendmail 8.14.5
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.118 2008/07/22 15:12:48 ca Exp $")
d631 1
a631 1
			tlslogerr(where);
d638 1
d651 1
d656 1
d669 1
d777 1
d779 9
a787 1
			tlslogerr("read");
d808 8
a815 1
			sm_syslog(LOG_WARNING, NOQID,
d820 1
d902 1
a902 1
			tlslogerr("write");
@


1.20
log
@Update to sendmail-8.14.3
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.117 2008/01/31 18:48:29 ca Exp $")
d299 1
a299 1
	**  due to a negotation with the other side, e.g.,
@


1.19
log
@Update to sendmail-8.13.8
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2006 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.115 2006/04/18 21:34:07 ca Exp $")
d678 20
d748 3
a750 1
				TimeOuts.to_datablock, ssl_err, "read");
@


1.18
log
@Update to sendmail 8.13.6
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.113 2006/03/02 19:18:27 ca Exp $")
d15 1
d330 1
d352 1
a352 1
**		fout -- the sm_io file encrypted data to be writen to
d354 1
d366 1
a366 1
sfdcsasl(fin, fout, conn)
d370 1
d375 1
a375 1
		SM_TIME_FOREVER);
d386 1
a386 1
		SM_TIME_FOREVER);
d406 3
@


1.17
log
@update to sendmail 8.13.3
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2004 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.101 2004/12/15 22:45:55 ca Exp $")
d226 3
d310 1
a310 1
                             (const void **) &maxencode);
d318 4
d323 1
d552 119
d691 1
a691 2
	int r;
	static int again = MAX_TLS_IOS;
d693 1
d696 5
a703 2
	{
		again = MAX_TLS_IOS;
a704 1
	}
d707 1
a707 1
	switch (SSL_get_error(so->con, r))
a710 1
		again = MAX_TLS_IOS;
d713 2
a714 5
		if (--again <= 0)
			err = "read W BLOCK";
		else
			errno = EAGAIN;
		break;
d716 1
a716 1
		if (--again <= 0)
d718 7
a724 2
		else
			errno = EAGAIN;
d726 1
d759 7
a765 2
		again = MAX_TLS_IOS;
		if (LogLevel > 9)
d767 1
a767 1
				  "STARTTLS: read error=%s (%d), errno=%d, get_error=%s",
d769 2
a770 1
				  ERR_error_string(ERR_get_error(), NULL));
d773 2
a774 1
				  "STARTTLS: read error=%s (%d)", err, r);
d801 1
a801 2
	int r;
	static int again = MAX_TLS_IOS;
d803 1
d806 5
a813 2
	{
		again = MAX_TLS_IOS;
a814 1
	}
d816 1
a816 1
	switch (SSL_get_error(so->con, r))
a819 1
		again = MAX_TLS_IOS;
d822 2
a823 5
		if (--again <= 0)
			err = "write W BLOCK";
		else
			errno = EAGAIN;
		break;
d825 9
a833 4
		if (--again <= 0)
			err = "write R BLOCK";
		else
			errno = EAGAIN;
d866 7
a872 2
		again = MAX_TLS_IOS;
		if (LogLevel > 9)
d874 1
a874 1
				  "STARTTLS: write error=%s (%d), errno=%d, get_error=%s",
d876 2
a877 1
				  ERR_error_string(ERR_get_error(), NULL));
d880 2
a881 1
				  "STARTTLS: write error=%s (%d)", err, r);
@


1.17.6.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@a543 119
**  TLS_RETRY -- check whether a failed SSL operation can be retried
**
**	Parameters:
**		ssl -- TLS structure
**		rfd -- read fd
**		wfd -- write fd
**		tlsstart -- start time of TLS operation
**		timeout -- timeout for TLS operation
**		err -- SSL error
**		where -- description of operation
**
**	Results:
**		>0 on success
**		0 on timeout
**		<0 on error
*/

int
tls_retry(ssl, rfd, wfd, tlsstart, timeout, err, where)
	SSL *ssl;
	int rfd;
	int wfd;
	time_t tlsstart;
	int timeout;
	int err;
	const char *where;
{
	int ret;
	time_t left;
	time_t now = curtime();
	struct timeval tv;

	ret = -1;

	/*
	**  For SSL_ERROR_WANT_{READ,WRITE}:
	**  There is not a complete SSL record available yet
	**  or there is only a partial SSL record removed from
	**  the network (socket) buffer into the SSL buffer.
	**  The SSL_connect will only succeed when a full
	**  SSL record is available (assuming a "real" error
	**  doesn't happen). To handle when a "real" error
	**  does happen the select is set for exceptions too.
	**  The connection may be re-negotiated during this time
	**  so both read and write "want errors" need to be handled.
	**  A select() exception loops back so that a proper SSL
	**  error message can be gotten.
	*/

	left = timeout - (now - tlsstart);
	if (left <= 0)
		return 0;	/* timeout */
	tv.tv_sec = left;
	tv.tv_usec = 0;

	if (LogLevel > 14)
	{
		sm_syslog(LOG_INFO, NOQID,
			  "STARTTLS=%s, info: fds=%d/%d, err=%d",
			  where, rfd, wfd, err);
	}

	if (FD_SETSIZE > 0 &&
	    ((err == SSL_ERROR_WANT_READ && rfd >= FD_SETSIZE) ||
	     (err == SSL_ERROR_WANT_WRITE && wfd >= FD_SETSIZE)))
	{
		if (LogLevel > 5)
		{
			sm_syslog(LOG_ERR, NOQID,
				  "STARTTLS=%s, error: fd %d/%d too large",
				  where, rfd, wfd);
		if (LogLevel > 8)
			tlslogerr(where);
		}
		errno = EINVAL;
	}
	else if (err == SSL_ERROR_WANT_READ)
	{
		fd_set ssl_maskr, ssl_maskx;

		FD_ZERO(&ssl_maskr);
		FD_SET(rfd, &ssl_maskr);
		FD_ZERO(&ssl_maskx);
		FD_SET(rfd, &ssl_maskx);
		do
		{
			ret = select(rfd + 1, &ssl_maskr, NULL, &ssl_maskx,
					&tv);
		} while (ret < 0 && errno == EINTR);
		if (ret < 0 && errno > 0)
			ret = -errno;
	}
	else if (err == SSL_ERROR_WANT_WRITE)
	{
		fd_set ssl_maskw, ssl_maskx;

		FD_ZERO(&ssl_maskw);
		FD_SET(wfd, &ssl_maskw);
		FD_ZERO(&ssl_maskx);
		FD_SET(rfd, &ssl_maskx);
		do
		{
			ret = select(wfd + 1, NULL, &ssl_maskw, &ssl_maskx,
					&tv);
		} while (ret < 0 && errno == EINTR);
		if (ret < 0 && errno > 0)
			ret = -errno;
	}
	return ret;
}

/* errno to force refill() etc to stop (see IS_IO_ERROR()) */
#ifdef ETIMEDOUT
# define SM_ERR_TIMEOUT	ETIMEDOUT
#else /* ETIMEDOUT */
# define SM_ERR_TIMEOUT	EIO
#endif /* ETIMEDOUT */

/*
d564 2
a565 1
	int r, rfd, wfd, try, ssl_err;
a566 1
	time_t tlsstart;
a568 5
	try = 99;
	err = NULL;
	tlsstart = curtime();

  retry:
d572 2
d575 1
d578 1
a578 1
	switch (ssl_err = SSL_get_error(so->con, r))
d582 1
d585 5
a589 2
		err = "read W BLOCK";
		/* FALLTHROUGH */
d591 1
a591 1
		if (err == NULL)
d593 2
a594 7
		rfd = SSL_get_rfd(so->con);
		wfd = SSL_get_wfd(so->con);
		try = tls_retry(so->con, rfd, wfd, tlsstart,
				TimeOuts.to_datablock, ssl_err, "read");
		if (try > 0)
			goto retry;
		errno = SM_ERR_TIMEOUT;
a595 1

d628 2
a629 7
		if (try == 0 && save_errno == SM_ERR_TIMEOUT)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					  "STARTTLS: read error=timeout");
		}
		else if (LogLevel > 8)
d631 1
a631 1
				  "STARTTLS: read error=%s (%d), errno=%d, get_error=%s, retry=%d, ssl_err=%d",
d633 1
a633 2
				  ERR_error_string(ERR_get_error(), NULL), try,
				  ssl_err);
d636 1
a636 2
				  "STARTTLS: read error=%s (%d), retry=%d, ssl_err=%d",
				  err, r, errno, try, ssl_err);
d663 2
a664 1
	int r, rfd, wfd, try, ssl_err;
a665 1
	time_t tlsstart;
a667 5
	try = 99;
	err = NULL;
	tlsstart = curtime();

  retry:
d671 2
d674 1
d676 1
a676 1
	switch (ssl_err = SSL_get_error(so->con, r))
d680 1
d683 5
a687 2
		err = "read W BLOCK";
		/* FALLTHROUGH */
d689 4
a692 9
		if (err == NULL)
			err = "read R BLOCK";
		rfd = SSL_get_rfd(so->con);
		wfd = SSL_get_wfd(so->con);
		try = tls_retry(so->con, rfd, wfd, tlsstart,
				DATA_PROGRESS_TIMEOUT, ssl_err, "write");
		if (try > 0)
			goto retry;
		errno = SM_ERR_TIMEOUT;
d725 2
a726 7
		if (try == 0 && save_errno == SM_ERR_TIMEOUT)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					  "STARTTLS: write error=timeout");
		}
		else if (LogLevel > 8)
d728 1
a728 1
				  "STARTTLS: write error=%s (%d), errno=%d, get_error=%s, retry=%d, ssl_err=%d",
d730 1
a730 2
				  ERR_error_string(ERR_get_error(), NULL), try,
				  ssl_err);
d733 1
a733 2
				  "STARTTLS: write error=%s (%d), errno=%d, retry=%d, ssl_err=%d",
				  err, r, errno, try, ssl_err);
@


1.17.4.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@a543 119
**  TLS_RETRY -- check whether a failed SSL operation can be retried
**
**	Parameters:
**		ssl -- TLS structure
**		rfd -- read fd
**		wfd -- write fd
**		tlsstart -- start time of TLS operation
**		timeout -- timeout for TLS operation
**		err -- SSL error
**		where -- description of operation
**
**	Results:
**		>0 on success
**		0 on timeout
**		<0 on error
*/

int
tls_retry(ssl, rfd, wfd, tlsstart, timeout, err, where)
	SSL *ssl;
	int rfd;
	int wfd;
	time_t tlsstart;
	int timeout;
	int err;
	const char *where;
{
	int ret;
	time_t left;
	time_t now = curtime();
	struct timeval tv;

	ret = -1;

	/*
	**  For SSL_ERROR_WANT_{READ,WRITE}:
	**  There is not a complete SSL record available yet
	**  or there is only a partial SSL record removed from
	**  the network (socket) buffer into the SSL buffer.
	**  The SSL_connect will only succeed when a full
	**  SSL record is available (assuming a "real" error
	**  doesn't happen). To handle when a "real" error
	**  does happen the select is set for exceptions too.
	**  The connection may be re-negotiated during this time
	**  so both read and write "want errors" need to be handled.
	**  A select() exception loops back so that a proper SSL
	**  error message can be gotten.
	*/

	left = timeout - (now - tlsstart);
	if (left <= 0)
		return 0;	/* timeout */
	tv.tv_sec = left;
	tv.tv_usec = 0;

	if (LogLevel > 14)
	{
		sm_syslog(LOG_INFO, NOQID,
			  "STARTTLS=%s, info: fds=%d/%d, err=%d",
			  where, rfd, wfd, err);
	}

	if (FD_SETSIZE > 0 &&
	    ((err == SSL_ERROR_WANT_READ && rfd >= FD_SETSIZE) ||
	     (err == SSL_ERROR_WANT_WRITE && wfd >= FD_SETSIZE)))
	{
		if (LogLevel > 5)
		{
			sm_syslog(LOG_ERR, NOQID,
				  "STARTTLS=%s, error: fd %d/%d too large",
				  where, rfd, wfd);
		if (LogLevel > 8)
			tlslogerr(where);
		}
		errno = EINVAL;
	}
	else if (err == SSL_ERROR_WANT_READ)
	{
		fd_set ssl_maskr, ssl_maskx;

		FD_ZERO(&ssl_maskr);
		FD_SET(rfd, &ssl_maskr);
		FD_ZERO(&ssl_maskx);
		FD_SET(rfd, &ssl_maskx);
		do
		{
			ret = select(rfd + 1, &ssl_maskr, NULL, &ssl_maskx,
					&tv);
		} while (ret < 0 && errno == EINTR);
		if (ret < 0 && errno > 0)
			ret = -errno;
	}
	else if (err == SSL_ERROR_WANT_WRITE)
	{
		fd_set ssl_maskw, ssl_maskx;

		FD_ZERO(&ssl_maskw);
		FD_SET(wfd, &ssl_maskw);
		FD_ZERO(&ssl_maskx);
		FD_SET(rfd, &ssl_maskx);
		do
		{
			ret = select(wfd + 1, NULL, &ssl_maskw, &ssl_maskx,
					&tv);
		} while (ret < 0 && errno == EINTR);
		if (ret < 0 && errno > 0)
			ret = -errno;
	}
	return ret;
}

/* errno to force refill() etc to stop (see IS_IO_ERROR()) */
#ifdef ETIMEDOUT
# define SM_ERR_TIMEOUT	ETIMEDOUT
#else /* ETIMEDOUT */
# define SM_ERR_TIMEOUT	EIO
#endif /* ETIMEDOUT */

/*
d564 2
a565 1
	int r, rfd, wfd, try, ssl_err;
a566 1
	time_t tlsstart;
a568 5
	try = 99;
	err = NULL;
	tlsstart = curtime();

  retry:
d572 2
d575 1
d578 1
a578 1
	switch (ssl_err = SSL_get_error(so->con, r))
d582 1
d585 5
a589 2
		err = "read W BLOCK";
		/* FALLTHROUGH */
d591 1
a591 1
		if (err == NULL)
d593 2
a594 7
		rfd = SSL_get_rfd(so->con);
		wfd = SSL_get_wfd(so->con);
		try = tls_retry(so->con, rfd, wfd, tlsstart,
				TimeOuts.to_datablock, ssl_err, "read");
		if (try > 0)
			goto retry;
		errno = SM_ERR_TIMEOUT;
a595 1

d628 2
a629 7
		if (try == 0 && save_errno == SM_ERR_TIMEOUT)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					  "STARTTLS: read error=timeout");
		}
		else if (LogLevel > 8)
d631 1
a631 1
				  "STARTTLS: read error=%s (%d), errno=%d, get_error=%s, retry=%d, ssl_err=%d",
d633 1
a633 2
				  ERR_error_string(ERR_get_error(), NULL), try,
				  ssl_err);
d636 1
a636 2
				  "STARTTLS: read error=%s (%d), retry=%d, ssl_err=%d",
				  err, r, errno, try, ssl_err);
d663 2
a664 1
	int r, rfd, wfd, try, ssl_err;
a665 1
	time_t tlsstart;
a667 5
	try = 99;
	err = NULL;
	tlsstart = curtime();

  retry:
d671 2
d674 1
d676 1
a676 1
	switch (ssl_err = SSL_get_error(so->con, r))
d680 1
d683 5
a687 2
		err = "read W BLOCK";
		/* FALLTHROUGH */
d689 4
a692 9
		if (err == NULL)
			err = "read R BLOCK";
		rfd = SSL_get_rfd(so->con);
		wfd = SSL_get_wfd(so->con);
		try = tls_retry(so->con, rfd, wfd, tlsstart,
				DATA_PROGRESS_TIMEOUT, ssl_err, "write");
		if (try > 0)
			goto retry;
		errno = SM_ERR_TIMEOUT;
d725 2
a726 7
		if (try == 0 && save_errno == SM_ERR_TIMEOUT)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					  "STARTTLS: write error=timeout");
		}
		else if (LogLevel > 8)
d728 1
a728 1
				  "STARTTLS: write error=%s (%d), errno=%d, get_error=%s, retry=%d, ssl_err=%d",
d730 1
a730 2
				  ERR_error_string(ERR_get_error(), NULL), try,
				  ssl_err);
d733 1
a733 2
				  "STARTTLS: write error=%s (%d), errno=%d, retry=%d, ssl_err=%d",
				  err, r, errno, try, ssl_err);
@


1.17.2.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@a543 119
**  TLS_RETRY -- check whether a failed SSL operation can be retried
**
**	Parameters:
**		ssl -- TLS structure
**		rfd -- read fd
**		wfd -- write fd
**		tlsstart -- start time of TLS operation
**		timeout -- timeout for TLS operation
**		err -- SSL error
**		where -- description of operation
**
**	Results:
**		>0 on success
**		0 on timeout
**		<0 on error
*/

int
tls_retry(ssl, rfd, wfd, tlsstart, timeout, err, where)
	SSL *ssl;
	int rfd;
	int wfd;
	time_t tlsstart;
	int timeout;
	int err;
	const char *where;
{
	int ret;
	time_t left;
	time_t now = curtime();
	struct timeval tv;

	ret = -1;

	/*
	**  For SSL_ERROR_WANT_{READ,WRITE}:
	**  There is not a complete SSL record available yet
	**  or there is only a partial SSL record removed from
	**  the network (socket) buffer into the SSL buffer.
	**  The SSL_connect will only succeed when a full
	**  SSL record is available (assuming a "real" error
	**  doesn't happen). To handle when a "real" error
	**  does happen the select is set for exceptions too.
	**  The connection may be re-negotiated during this time
	**  so both read and write "want errors" need to be handled.
	**  A select() exception loops back so that a proper SSL
	**  error message can be gotten.
	*/

	left = timeout - (now - tlsstart);
	if (left <= 0)
		return 0;	/* timeout */
	tv.tv_sec = left;
	tv.tv_usec = 0;

	if (LogLevel > 14)
	{
		sm_syslog(LOG_INFO, NOQID,
			  "STARTTLS=%s, info: fds=%d/%d, err=%d",
			  where, rfd, wfd, err);
	}

	if (FD_SETSIZE > 0 &&
	    ((err == SSL_ERROR_WANT_READ && rfd >= FD_SETSIZE) ||
	     (err == SSL_ERROR_WANT_WRITE && wfd >= FD_SETSIZE)))
	{
		if (LogLevel > 5)
		{
			sm_syslog(LOG_ERR, NOQID,
				  "STARTTLS=%s, error: fd %d/%d too large",
				  where, rfd, wfd);
		if (LogLevel > 8)
			tlslogerr(where);
		}
		errno = EINVAL;
	}
	else if (err == SSL_ERROR_WANT_READ)
	{
		fd_set ssl_maskr, ssl_maskx;

		FD_ZERO(&ssl_maskr);
		FD_SET(rfd, &ssl_maskr);
		FD_ZERO(&ssl_maskx);
		FD_SET(rfd, &ssl_maskx);
		do
		{
			ret = select(rfd + 1, &ssl_maskr, NULL, &ssl_maskx,
					&tv);
		} while (ret < 0 && errno == EINTR);
		if (ret < 0 && errno > 0)
			ret = -errno;
	}
	else if (err == SSL_ERROR_WANT_WRITE)
	{
		fd_set ssl_maskw, ssl_maskx;

		FD_ZERO(&ssl_maskw);
		FD_SET(wfd, &ssl_maskw);
		FD_ZERO(&ssl_maskx);
		FD_SET(rfd, &ssl_maskx);
		do
		{
			ret = select(wfd + 1, NULL, &ssl_maskw, &ssl_maskx,
					&tv);
		} while (ret < 0 && errno == EINTR);
		if (ret < 0 && errno > 0)
			ret = -errno;
	}
	return ret;
}

/* errno to force refill() etc to stop (see IS_IO_ERROR()) */
#ifdef ETIMEDOUT
# define SM_ERR_TIMEOUT	ETIMEDOUT
#else /* ETIMEDOUT */
# define SM_ERR_TIMEOUT	EIO
#endif /* ETIMEDOUT */

/*
d564 2
a565 1
	int r, rfd, wfd, try, ssl_err;
a566 1
	time_t tlsstart;
a568 5
	try = 99;
	err = NULL;
	tlsstart = curtime();

  retry:
d572 2
d575 1
d578 1
a578 1
	switch (ssl_err = SSL_get_error(so->con, r))
d582 1
d585 5
a589 2
		err = "read W BLOCK";
		/* FALLTHROUGH */
d591 1
a591 1
		if (err == NULL)
d593 2
a594 7
		rfd = SSL_get_rfd(so->con);
		wfd = SSL_get_wfd(so->con);
		try = tls_retry(so->con, rfd, wfd, tlsstart,
				TimeOuts.to_datablock, ssl_err, "read");
		if (try > 0)
			goto retry;
		errno = SM_ERR_TIMEOUT;
a595 1

d628 2
a629 7
		if (try == 0 && save_errno == SM_ERR_TIMEOUT)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					  "STARTTLS: read error=timeout");
		}
		else if (LogLevel > 8)
d631 1
a631 1
				  "STARTTLS: read error=%s (%d), errno=%d, get_error=%s, retry=%d, ssl_err=%d",
d633 1
a633 2
				  ERR_error_string(ERR_get_error(), NULL), try,
				  ssl_err);
d636 1
a636 2
				  "STARTTLS: read error=%s (%d), retry=%d, ssl_err=%d",
				  err, r, errno, try, ssl_err);
d663 2
a664 1
	int r, rfd, wfd, try, ssl_err;
a665 1
	time_t tlsstart;
a667 5
	try = 99;
	err = NULL;
	tlsstart = curtime();

  retry:
d671 2
d674 1
d676 1
a676 1
	switch (ssl_err = SSL_get_error(so->con, r))
d680 1
d683 5
a687 2
		err = "read W BLOCK";
		/* FALLTHROUGH */
d689 4
a692 9
		if (err == NULL)
			err = "read R BLOCK";
		rfd = SSL_get_rfd(so->con);
		wfd = SSL_get_wfd(so->con);
		try = tls_retry(so->con, rfd, wfd, tlsstart,
				DATA_PROGRESS_TIMEOUT, ssl_err, "write");
		if (try > 0)
			goto retry;
		errno = SM_ERR_TIMEOUT;
d725 2
a726 7
		if (try == 0 && save_errno == SM_ERR_TIMEOUT)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					  "STARTTLS: write error=timeout");
		}
		else if (LogLevel > 8)
d728 1
a728 1
				  "STARTTLS: write error=%s (%d), errno=%d, get_error=%s, retry=%d, ssl_err=%d",
d730 1
a730 2
				  ERR_error_string(ERR_get_error(), NULL), try,
				  ssl_err);
d733 1
a733 2
				  "STARTTLS: write error=%s (%d), errno=%d, retry=%d, ssl_err=%d",
				  err, r, errno, try, ssl_err);
@


1.16
log
@Update to sendmail-8.13.2
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.100 2004/11/23 18:32:32 ca Exp $")
d16 6
d608 1
a608 1
#if _FFR_DEAL_WITH_ERROR_SSL
d611 1
a611 1
#endif /* _FFR_DEAL_WITH_ERROR_SSL */
d616 1
a616 1
#if _FFR_DEAL_WITH_ERROR_SSL
d620 1
a620 1
#endif /* _FFR_DEAL_WITH_ERROR_SSL */
d713 1
a713 1
#if _FFR_DEAL_WITH_ERROR_SSL
d717 1
a717 1
#endif /* _FFR_DEAL_WITH_ERROR_SSL */
@


1.15
log
@Update to sendmail.8.13.0
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.98 2004/03/03 19:20:31 ca Exp $")
d282 1
a282 1
	unsigned int outlen;
d285 19
@


1.14
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2003 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.91.2.5 2003/08/08 17:30:11 ca Exp $")
d352 2
a353 2
	newin = sm_io_open(&sasl_vector, SM_TIME_DEFAULT, &info, SM_IO_RDONLY,
			   NULL);
d360 2
a361 2
	newout = sm_io_open(&sasl_vector, SM_TIME_DEFAULT, &info, SM_IO_WRONLY,
			    NULL);
d753 1
a753 1
	tlsin = sm_io_open(&tls_vector, SM_TIME_DEFAULT, &info, SM_IO_RDONLY,
d759 1
a759 1
	tlsout = sm_io_open(&tls_vector, SM_TIME_DEFAULT, &info, SM_IO_WRONLY,
@


1.13
log
@update to sendmail 8.12.7
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2002 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.91.2.2 2002/09/12 21:07:50 ca Exp $")
d104 5
d147 2
d202 3
d299 2
d462 5
d503 2
d604 6
a609 1
		if (LogLevel > 7)
d701 6
a706 1
		if (LogLevel > 7)
d721 1
a721 1
**		conn -- the tls connection pointer
@


1.12
log
@update to sendmail-8.12.6
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.91.2.1 2002/08/27 01:35:17 ca Exp $")
d180 1
a180 1
	const char *outbuf = NULL;
d197 3
d201 1
@


1.11
log
@sendmail 8.12.5
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.91 2002/06/07 00:06:27 geir Exp $")
d560 4
d567 6
d659 6
@


1.10
log
@Update to sendmail-8.12.4
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.90 2002/05/09 20:44:11 ca Exp $")
d154 1
a154 1
# define SASL_DEALLOC(b)	sm_sasl_free(b)
@


1.9
log
@update to sendmail 8.12.3
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.89 2002/02/22 04:41:28 ca Exp $")
a16 1
# include <sasl.h>
d179 3
d183 1
d231 1
d233 1
d263 3
d267 1
d288 1
d290 1
@


1.8
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.86 2001/09/11 04:05:16 gshapiro Exp $")
d273 1
d556 3
a559 2
		if (errno == 0)
			errno = EIO;
d563 1
d642 3
a645 2
		if (errno == 0)
			errno = EIO;
d649 1
@


1.7
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.84 2001/09/03 22:35:38 gshapiro Exp $")
@


1.6
log
@update to sendmail 8.11.5
@
text
@d11 2
a12 8
#ifndef lint
static char id[] = "@@(#)$Sendmail: sfsasl.c,v 8.17.4.15 2001/07/11 17:37:07 gshapiro Exp $";
#endif /* ! lint */

#if SFIO
# include <sfio/stdio.h>
#endif /* SFIO */

d15 108
a123 1
#if SASL && SFIO
d125 7
a131 1
**  SASL
d134 18
a151 2
# include <sasl.h>
# include "sfsasl.h"
d154 17
a170 1
#  define SASL_DEALLOC(b)	sm_free(b)
d173 3
a175 3
sasl_read(f, buf, size, disc)
	Sfio_t *f;
	Void_t *buf;
a176 1
	Sfdisc_t *disc;
d178 2
a179 1
	int len, result;
d183 1
a183 1
	Sasldisc_t *sd = (Sasldisc_t *) disc;
d196 1
a196 1
		len = sfrd(f, buf, size, disc);
d199 2
a200 1
		result = sasl_decode(sd->conn, buf, len, &outbuf, &outlen);
d210 7
a216 1
	if (outbuf != NULL)
d218 4
a221 17
		if (outlen - offset > size)
		{
			/* return another part of the buffer */
			(void) memcpy(buf, outbuf + offset, (size_t) size);
			offset += size;
			result = size;
		}
		else
		{
			/* return the rest of the buffer */
			result = outlen - offset;
			(void) memcpy(buf, outbuf + offset, (size_t) result);
			SASL_DEALLOC(outbuf);
			outbuf = NULL;
			offset = 0;
			outlen = 0;
		}
d225 7
a231 2
		/* be paranoid: outbuf == NULL but outlen != 0 */
		syserr("!sasl_read failure: outbuf == NULL but outlen != 0");
d233 1
a233 1
	return result;
d236 15
d252 3
a254 3
sasl_write(f, buf, size, disc)
	Sfio_t *f;
	const Void_t *buf;
a255 1
	Sfdisc_t *disc;
d260 2
a261 1
	Sasldisc_t *sd = (Sasldisc_t *) disc;
d263 2
a264 1
	result = sasl_encode(sd->conn, buf, size, &outbuf, &outlen);
d271 7
a277 1
		sfwr(f, outbuf, outlen, disc);
d283 18
d303 2
a304 2
	Sfio_t *fin;
	Sfio_t *fout;
d307 5
a311 1
	Sasldisc_t *saslin, *saslout;
d319 10
a328 11
	saslin = (Sasldisc_t *) xalloc(sizeof(Sasldisc_t));
	saslout = (Sasldisc_t *) xalloc(sizeof(Sasldisc_t));
	saslin->disc.readf = sasl_read;
	saslin->disc.writef = sasl_write;
	saslin->disc.seekf = NULL;
	saslin->disc.exceptf = NULL;

	saslout->disc.readf = sasl_read;
	saslout->disc.writef = sasl_write;
	saslout->disc.seekf = NULL;
	saslout->disc.exceptf = NULL;
d330 4
a333 2
	saslin->conn = conn;
	saslout->conn = conn;
d335 1
a335 2
	if (sfdisc(fin, (Sfdisc_t *) saslin) != (Sfdisc_t *) saslin ||
	    sfdisc(fout, (Sfdisc_t *) saslout) != (Sfdisc_t *) saslout)
d337 1
a337 2
		sm_free(saslin);
		sm_free(saslout);
d340 4
d346 58
a403 1
#endif /* SASL && SFIO */
a404 1
#if STARTTLS && (SFIO || _FFR_TLS_TOREK)
d406 12
a417 1
**  STARTTLS
d420 1
a420 2
# include "sfsasl.h"
#  include <openssl/err.h>
d422 1
a422 8
# if SFIO
static ssize_t
tls_read(f, buf, size, disc)
	Sfio_t *f;
	Void_t *buf;
	size_t size;
	Sfdisc_t *disc;
# else /* SFIO */
d424 5
a428 5
tls_read(disc, buf, size)
	void *disc;
	char *buf;
	int size;
# endif /* SFIO */
d430 32
a461 2
	int r;
	Tlsdisc_t *sd;
d463 5
a467 2
	/* Cast back to correct type */
	sd = (Tlsdisc_t *) disc;
d469 2
a470 2
	r = SSL_read(sd->con, (char *) buf, size);
	if (r < 0 && LogLevel > 7)
d472 2
a473 31
		char *err;

		err = NULL;
		switch (SSL_get_error(sd->con, r))
		{
			case SSL_ERROR_NONE:
				break;
			case SSL_ERROR_WANT_WRITE:
				err = "write W BLOCK";
				break;
			case SSL_ERROR_WANT_READ:
				err = "write R BLOCK";
				break;
			case SSL_ERROR_WANT_X509_LOOKUP:
				err = "write X BLOCK";
				break;
			case SSL_ERROR_ZERO_RETURN:
				break;
			case SSL_ERROR_SYSCALL:
				err = "syscall error";
/*
				get_last_socket_error());
*/
				break;
			case SSL_ERROR_SSL:
				err = "generic SSL error";
				break;
		}
		if (err != NULL)
			sm_syslog(LOG_WARNING, NOQID, "TLS: read error:  %s",
				  err);
d475 3
a477 1
	return r;
d480 18
a497 1
# if SFIO
d499 3
a501 3
tls_write(f, buf, size, disc)
	Sfio_t *f;
	const Void_t *buf;
a502 8
	Sfdisc_t *disc;
# else /* SFIO */
static int
tls_write(disc, buf, size)
	void *disc;
	const char *buf;
	int size;
# endif /* SFIO */
d505 3
a507 1
	Tlsdisc_t *sd;
d509 1
a509 2
	/* Cast back to correct type */
	sd = (Tlsdisc_t *) disc;
d511 1
a511 2
	r = SSL_write(sd->con, (char *)buf, size);
	if (r < 0 && LogLevel > 7)
d513 3
a515 1
		char *err;
d517 26
a542 24
		err = NULL;
		switch (SSL_get_error(sd->con, r))
		{
			case SSL_ERROR_NONE:
				break;
			case SSL_ERROR_WANT_WRITE:
				err = "write W BLOCK";
				break;
			case SSL_ERROR_WANT_READ:
				err = "write R BLOCK";
				break;
			case SSL_ERROR_WANT_X509_LOOKUP:
				err = "write X BLOCK";
				break;
			case SSL_ERROR_ZERO_RETURN:
				break;
			case SSL_ERROR_SYSCALL:
				err = "syscall error";
/*
				get_last_socket_error());
*/
				break;
			case SSL_ERROR_SSL:
				err = "generic SSL error";
d544 1
a544 1
				ERR_GET_REASON(ERR_peek_error()));
d546 15
a560 5
				break;
		}
		if (err != NULL)
			sm_syslog(LOG_WARNING, NOQID, "TLS: write error:  %s",
				  err);
d565 12
a576 7
# if !SFIO
static int
tls_close(cookie)
	void *cookie;
{
	int retval = 0;
	Tlsdisc_t *tc;
d578 1
a578 2
	/* Cast back to correct type */
	tc = (Tlsdisc_t *)cookie;
d580 65
a644 4
	if (tc->fp != NULL)
	{
		retval = fclose(tc->fp);
		tc->fp = NULL;
d646 2
d649 19
a667 4
	sm_free(tc);
	return retval;
}
# endif /* !SFIO */
d671 2
a672 7
# if SFIO
	Sfio_t *fin;
	Sfio_t *fout;
# else /* SFIO */
	FILE **fin;
	FILE **fout;
# endif /* SFIO */
d675 17
a691 9
	Tlsdisc_t *tlsin, *tlsout;
# if !SFIO
	FILE *fp;
# else /* !SFIO */
	int rfd, wfd;
# endif /* !SFIO */

	if (con == NULL)
		return 0;
d693 4
a696 26
	tlsin = (Tlsdisc_t *) xalloc(sizeof(Tlsdisc_t));
	tlsout = (Tlsdisc_t *) xalloc(sizeof(Tlsdisc_t));
# if SFIO
	tlsin->disc.readf = tls_read;
	tlsin->disc.writef = tls_write;
	tlsin->disc.seekf = NULL;
	tlsin->disc.exceptf = NULL;
	tlsin->con = con;

	tlsout->disc.readf = tls_read;
	tlsout->disc.writef = tls_write;
	tlsout->disc.seekf = NULL;
	tlsout->disc.exceptf = NULL;
	tlsout->con = con;

	rfd = fileno(fin);
	wfd = fileno(fout);
	if (rfd < 0 || wfd < 0 ||
	    SSL_set_rfd(con, rfd) <= 0 || SSL_set_wfd(con, wfd) <= 0)
	{
		sm_free(tlsin);
		sm_free(tlsout);
		return -1;
	}
	if (sfdisc(fin, (Sfdisc_t *) tlsin) != (Sfdisc_t *) tlsin ||
	    sfdisc(fout, (Sfdisc_t *) tlsout) != (Sfdisc_t *) tlsout)
d698 1
a698 2
		sm_free(tlsin);
		sm_free(tlsout);
d701 1
a701 10
# else /* SFIO */
	tlsin->fp = *fin;
	tlsin->con = con;
	fp = funopen(tlsin, tls_read, tls_write, NULL, tls_close);
	if (fp == NULL)
	{
		sm_free(tlsin);
		return -1;
	}
	*fin = fp;
d703 2
a704 19
	tlsout->fp = *fout;
	tlsout->con = con;
	fp = funopen(tlsout, tls_read, tls_write, NULL, tls_close);
	if (fp == NULL)
	{
		FILE *save;

		/* Hack: Don't close underlying fp */
		save = tlsin->fp;
		tlsin->fp = NULL;
		fclose(*fin);
		*fin = save;
		sm_free(tlsout);
		return -1;
	}
	*fout = fp;
	SSL_set_rfd(con, fileno(tlsin->fp));
	SSL_set_wfd(con, fileno(tlsout->fp));
# endif /* SFIO */
d707 1
a707 1
#endif /* STARTTLS && (SFIO || _FFR_TLS_TOREK) */
@


1.5
log
@swat size_t vs. int bug (benign)
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: sfsasl.c,v 8.17.4.14 2001/05/03 17:24:16 gshapiro Exp $";
@


1.4
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d171 1
a172 1
# if SFIO
d179 1
d182 2
a183 2
	void *buf;
	size_t size;
d230 1
a231 1
# if SFIO
d238 1
d241 2
a242 2
	const void *buf;
	size_t size;
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2000 Sendmail, Inc. and its suppliers.
d12 1
a12 1
static char id[] = "@@(#)$Sendmail: sfsasl.c,v 8.17.4.13 2000/11/03 00:24:49 gshapiro Exp $";
d31 1
a31 1
#  define SASL_DEALLOC(b)	free(b)
d137 2
a138 8
	if ((saslin = (Sasldisc_t *) malloc(sizeof(Sasldisc_t))) == NULL)
		return -1;
	if ((saslout = (Sasldisc_t *) malloc(sizeof(Sasldisc_t))) == NULL)
	{
		free(saslin);
		return -1;
	}

d155 2
a156 2
		free(saslin);
		free(saslout);
d307 1
a307 1
	free(tc);
d333 2
a334 8
	if ((tlsin = (Tlsdisc_t *) malloc(sizeof(Tlsdisc_t))) == NULL)
		return -1;
	if ((tlsout = (Tlsdisc_t *) malloc(sizeof(Tlsdisc_t))) == NULL)
	{
		free(tlsin);
		return -1;
	}

d353 2
a354 2
		free(tlsin);
		free(tlsout);
d360 2
a361 2
		free(tlsin);
		free(tlsout);
d370 1
a370 1
		free(tlsin);
d387 1
a387 1
		free(tlsout);
@


1.3.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d12 1
a12 1
static char id[] = "@@(#)$Sendmail: sfsasl.c,v 8.17.4.14 2001/05/03 17:24:16 gshapiro Exp $";
d31 1
a31 1
#  define SASL_DEALLOC(b)	sm_free(b)
d137 8
a144 2
	saslin = (Sasldisc_t *) xalloc(sizeof(Sasldisc_t));
	saslout = (Sasldisc_t *) xalloc(sizeof(Sasldisc_t));
d161 2
a162 2
		sm_free(saslin);
		sm_free(saslout);
d313 1
a313 1
	sm_free(tc);
d339 8
a346 2
	tlsin = (Tlsdisc_t *) xalloc(sizeof(Tlsdisc_t));
	tlsout = (Tlsdisc_t *) xalloc(sizeof(Tlsdisc_t));
d365 2
a366 2
		sm_free(tlsin);
		sm_free(tlsout);
d372 2
a373 2
		sm_free(tlsin);
		sm_free(tlsout);
d382 1
a382 1
		sm_free(tlsin);
d399 1
a399 1
		sm_free(tlsout);
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: sfsasl.c,v 8.17 2000/03/10 17:58:19 ca Exp $";
d15 394
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d12 1
a12 1
static char id[] = "@@(#)$Sendmail: sfsasl.c,v 8.17.4.14 2001/05/03 17:24:16 gshapiro Exp $";
a14 382
#if SFIO
# include <sfio/stdio.h>
#endif /* SFIO */

#include <stdlib.h>
#include <sendmail.h>

#if SASL && SFIO
/*
**  SASL
*/

# include <sasl.h>
# include "sfsasl.h"

/* how to deallocate a buffer allocated by SASL */
#  define SASL_DEALLOC(b)	sm_free(b)

static ssize_t
sasl_read(f, buf, size, disc)
	Sfio_t *f;
	Void_t *buf;
	size_t size;
	Sfdisc_t *disc;
{
	int len, result;
	static char *outbuf = NULL;
	static unsigned int outlen = 0;
	static unsigned int offset = 0;
	Sasldisc_t *sd = (Sasldisc_t *) disc;

	/*
	**  sasl_decode() may require more data than a single read() returns.
	**  Hence we have to put a loop around the decoding.
	**  This also requires that we may have to split up the returned
	**  data since it might be larger than the allowed size.
	**  Therefore we use a static pointer and return portions of it
	**  if necessary.
	*/

	while (outbuf == NULL && outlen == 0)
	{
		len = sfrd(f, buf, size, disc);
		if (len <= 0)
			return len;
		result = sasl_decode(sd->conn, buf, len, &outbuf, &outlen);
		if (result != SASL_OK)
		{
			outbuf = NULL;
			offset = 0;
			outlen = 0;
			return -1;
		}
	}

	if (outbuf != NULL)
	{
		if (outlen - offset > size)
		{
			/* return another part of the buffer */
			(void) memcpy(buf, outbuf + offset, (size_t) size);
			offset += size;
			result = size;
		}
		else
		{
			/* return the rest of the buffer */
			result = outlen - offset;
			(void) memcpy(buf, outbuf + offset, (size_t) result);
			SASL_DEALLOC(outbuf);
			outbuf = NULL;
			offset = 0;
			outlen = 0;
		}
	}
	else
	{
		/* be paranoid: outbuf == NULL but outlen != 0 */
		syserr("!sasl_read failure: outbuf == NULL but outlen != 0");
	}
	return result;
}

static ssize_t
sasl_write(f, buf, size, disc)
	Sfio_t *f;
	const Void_t *buf;
	size_t size;
	Sfdisc_t *disc;
{
	int result;
	char *outbuf;
	unsigned int outlen;
	Sasldisc_t *sd = (Sasldisc_t *) disc;

	result = sasl_encode(sd->conn, buf, size, &outbuf, &outlen);

	if (result != SASL_OK)
		return -1;

	if (outbuf != NULL)
	{
		sfwr(f, outbuf, outlen, disc);
		SASL_DEALLOC(outbuf);
	}
	return size;
}

int
sfdcsasl(fin, fout, conn)
	Sfio_t *fin;
	Sfio_t *fout;
	sasl_conn_t *conn;
{
	Sasldisc_t *saslin, *saslout;

	if (conn == NULL)
	{
		/* no need to do anything */
		return 0;
	}

	saslin = (Sasldisc_t *) xalloc(sizeof(Sasldisc_t));
	saslout = (Sasldisc_t *) xalloc(sizeof(Sasldisc_t));
	saslin->disc.readf = sasl_read;
	saslin->disc.writef = sasl_write;
	saslin->disc.seekf = NULL;
	saslin->disc.exceptf = NULL;

	saslout->disc.readf = sasl_read;
	saslout->disc.writef = sasl_write;
	saslout->disc.seekf = NULL;
	saslout->disc.exceptf = NULL;

	saslin->conn = conn;
	saslout->conn = conn;

	if (sfdisc(fin, (Sfdisc_t *) saslin) != (Sfdisc_t *) saslin ||
	    sfdisc(fout, (Sfdisc_t *) saslout) != (Sfdisc_t *) saslout)
	{
		sm_free(saslin);
		sm_free(saslout);
		return -1;
	}
	return 0;
}
#endif /* SASL && SFIO */

#if STARTTLS && (SFIO || _FFR_TLS_TOREK)
/*
**  STARTTLS
*/

# include "sfsasl.h"
#  include <openssl/err.h>

static ssize_t
# if SFIO
tls_read(f, buf, size, disc)
	Sfio_t *f;
	Void_t *buf;
	size_t size;
	Sfdisc_t *disc;
# else /* SFIO */
tls_read(disc, buf, size)
	void *disc;
	void *buf;
	size_t size;
# endif /* SFIO */
{
	int r;
	Tlsdisc_t *sd;

	/* Cast back to correct type */
	sd = (Tlsdisc_t *) disc;

	r = SSL_read(sd->con, (char *) buf, size);
	if (r < 0 && LogLevel > 7)
	{
		char *err;

		err = NULL;
		switch (SSL_get_error(sd->con, r))
		{
			case SSL_ERROR_NONE:
				break;
			case SSL_ERROR_WANT_WRITE:
				err = "write W BLOCK";
				break;
			case SSL_ERROR_WANT_READ:
				err = "write R BLOCK";
				break;
			case SSL_ERROR_WANT_X509_LOOKUP:
				err = "write X BLOCK";
				break;
			case SSL_ERROR_ZERO_RETURN:
				break;
			case SSL_ERROR_SYSCALL:
				err = "syscall error";
/*
				get_last_socket_error());
*/
				break;
			case SSL_ERROR_SSL:
				err = "generic SSL error";
				break;
		}
		if (err != NULL)
			sm_syslog(LOG_WARNING, NOQID, "TLS: read error:  %s",
				  err);
	}
	return r;
}

static ssize_t
# if SFIO
tls_write(f, buf, size, disc)
	Sfio_t *f;
	const Void_t *buf;
	size_t size;
	Sfdisc_t *disc;
# else /* SFIO */
tls_write(disc, buf, size)
	void *disc;
	const void *buf;
	size_t size;
# endif /* SFIO */
{
	int r;
	Tlsdisc_t *sd;

	/* Cast back to correct type */
	sd = (Tlsdisc_t *) disc;

	r = SSL_write(sd->con, (char *)buf, size);
	if (r < 0 && LogLevel > 7)
	{
		char *err;

		err = NULL;
		switch (SSL_get_error(sd->con, r))
		{
			case SSL_ERROR_NONE:
				break;
			case SSL_ERROR_WANT_WRITE:
				err = "write W BLOCK";
				break;
			case SSL_ERROR_WANT_READ:
				err = "write R BLOCK";
				break;
			case SSL_ERROR_WANT_X509_LOOKUP:
				err = "write X BLOCK";
				break;
			case SSL_ERROR_ZERO_RETURN:
				break;
			case SSL_ERROR_SYSCALL:
				err = "syscall error";
/*
				get_last_socket_error());
*/
				break;
			case SSL_ERROR_SSL:
				err = "generic SSL error";
/*
				ERR_GET_REASON(ERR_peek_error()));
*/
				break;
		}
		if (err != NULL)
			sm_syslog(LOG_WARNING, NOQID, "TLS: write error:  %s",
				  err);
	}
	return r;
}

# if !SFIO
static int
tls_close(cookie)
	void *cookie;
{
	int retval = 0;
	Tlsdisc_t *tc;

	/* Cast back to correct type */
	tc = (Tlsdisc_t *)cookie;

	if (tc->fp != NULL)
	{
		retval = fclose(tc->fp);
		tc->fp = NULL;
	}

	sm_free(tc);
	return retval;
}
# endif /* !SFIO */

int
sfdctls(fin, fout, con)
# if SFIO
	Sfio_t *fin;
	Sfio_t *fout;
# else /* SFIO */
	FILE **fin;
	FILE **fout;
# endif /* SFIO */
	SSL *con;
{
	Tlsdisc_t *tlsin, *tlsout;
# if !SFIO
	FILE *fp;
# else /* !SFIO */
	int rfd, wfd;
# endif /* !SFIO */

	if (con == NULL)
		return 0;

	tlsin = (Tlsdisc_t *) xalloc(sizeof(Tlsdisc_t));
	tlsout = (Tlsdisc_t *) xalloc(sizeof(Tlsdisc_t));
# if SFIO
	tlsin->disc.readf = tls_read;
	tlsin->disc.writef = tls_write;
	tlsin->disc.seekf = NULL;
	tlsin->disc.exceptf = NULL;
	tlsin->con = con;

	tlsout->disc.readf = tls_read;
	tlsout->disc.writef = tls_write;
	tlsout->disc.seekf = NULL;
	tlsout->disc.exceptf = NULL;
	tlsout->con = con;

	rfd = fileno(fin);
	wfd = fileno(fout);
	if (rfd < 0 || wfd < 0 ||
	    SSL_set_rfd(con, rfd) <= 0 || SSL_set_wfd(con, wfd) <= 0)
	{
		sm_free(tlsin);
		sm_free(tlsout);
		return -1;
	}
	if (sfdisc(fin, (Sfdisc_t *) tlsin) != (Sfdisc_t *) tlsin ||
	    sfdisc(fout, (Sfdisc_t *) tlsout) != (Sfdisc_t *) tlsout)
	{
		sm_free(tlsin);
		sm_free(tlsout);
		return -1;
	}
# else /* SFIO */
	tlsin->fp = *fin;
	tlsin->con = con;
	fp = funopen(tlsin, tls_read, tls_write, NULL, tls_close);
	if (fp == NULL)
	{
		sm_free(tlsin);
		return -1;
	}
	*fin = fp;

	tlsout->fp = *fout;
	tlsout->con = con;
	fp = funopen(tlsout, tls_read, tls_write, NULL, tls_close);
	if (fp == NULL)
	{
		FILE *save;

		/* Hack: Don't close underlying fp */
		save = tlsin->fp;
		tlsin->fp = NULL;
		fclose(*fin);
		*fin = save;
		sm_free(tlsout);
		return -1;
	}
	*fout = fp;
	SSL_set_rfd(con, fileno(tlsin->fp));
	SSL_set_wfd(con, fileno(tlsout->fp));
# endif /* SFIO */
	return 0;
}
#endif /* STARTTLS && (SFIO || _FFR_TLS_TOREK) */
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: sfsasl.c,v 8.16 2000/02/01 21:55:24 ca Exp $";
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Id: sfsasl.c,v 8.17.4.13 2000/11/03 00:24:49 gshapiro Exp $";
a14 394
#if SFIO
# include <sfio/stdio.h>
#endif /* SFIO */

#include <stdlib.h>
#include <sendmail.h>

#if SASL && SFIO
/*
**  SASL
*/

# include <sasl.h>
# include "sfsasl.h"

/* how to deallocate a buffer allocated by SASL */
#  define SASL_DEALLOC(b)	free(b)

static ssize_t
sasl_read(f, buf, size, disc)
	Sfio_t *f;
	Void_t *buf;
	size_t size;
	Sfdisc_t *disc;
{
	int len, result;
	static char *outbuf = NULL;
	static unsigned int outlen = 0;
	static unsigned int offset = 0;
	Sasldisc_t *sd = (Sasldisc_t *) disc;

	/*
	**  sasl_decode() may require more data than a single read() returns.
	**  Hence we have to put a loop around the decoding.
	**  This also requires that we may have to split up the returned
	**  data since it might be larger than the allowed size.
	**  Therefore we use a static pointer and return portions of it
	**  if necessary.
	*/

	while (outbuf == NULL && outlen == 0)
	{
		len = sfrd(f, buf, size, disc);
		if (len <= 0)
			return len;
		result = sasl_decode(sd->conn, buf, len, &outbuf, &outlen);
		if (result != SASL_OK)
		{
			outbuf = NULL;
			offset = 0;
			outlen = 0;
			return -1;
		}
	}

	if (outbuf != NULL)
	{
		if (outlen - offset > size)
		{
			/* return another part of the buffer */
			(void) memcpy(buf, outbuf + offset, (size_t) size);
			offset += size;
			result = size;
		}
		else
		{
			/* return the rest of the buffer */
			result = outlen - offset;
			(void) memcpy(buf, outbuf + offset, (size_t) result);
			SASL_DEALLOC(outbuf);
			outbuf = NULL;
			offset = 0;
			outlen = 0;
		}
	}
	else
	{
		/* be paranoid: outbuf == NULL but outlen != 0 */
		syserr("!sasl_read failure: outbuf == NULL but outlen != 0");
	}
	return result;
}

static ssize_t
sasl_write(f, buf, size, disc)
	Sfio_t *f;
	const Void_t *buf;
	size_t size;
	Sfdisc_t *disc;
{
	int result;
	char *outbuf;
	unsigned int outlen;
	Sasldisc_t *sd = (Sasldisc_t *) disc;

	result = sasl_encode(sd->conn, buf, size, &outbuf, &outlen);

	if (result != SASL_OK)
		return -1;

	if (outbuf != NULL)
	{
		sfwr(f, outbuf, outlen, disc);
		SASL_DEALLOC(outbuf);
	}
	return size;
}

int
sfdcsasl(fin, fout, conn)
	Sfio_t *fin;
	Sfio_t *fout;
	sasl_conn_t *conn;
{
	Sasldisc_t *saslin, *saslout;

	if (conn == NULL)
	{
		/* no need to do anything */
		return 0;
	}

	if ((saslin = (Sasldisc_t *) malloc(sizeof(Sasldisc_t))) == NULL)
		return -1;
	if ((saslout = (Sasldisc_t *) malloc(sizeof(Sasldisc_t))) == NULL)
	{
		free(saslin);
		return -1;
	}

	saslin->disc.readf = sasl_read;
	saslin->disc.writef = sasl_write;
	saslin->disc.seekf = NULL;
	saslin->disc.exceptf = NULL;

	saslout->disc.readf = sasl_read;
	saslout->disc.writef = sasl_write;
	saslout->disc.seekf = NULL;
	saslout->disc.exceptf = NULL;

	saslin->conn = conn;
	saslout->conn = conn;

	if (sfdisc(fin, (Sfdisc_t *) saslin) != (Sfdisc_t *) saslin ||
	    sfdisc(fout, (Sfdisc_t *) saslout) != (Sfdisc_t *) saslout)
	{
		free(saslin);
		free(saslout);
		return -1;
	}
	return 0;
}
#endif /* SASL && SFIO */

#if STARTTLS && (SFIO || _FFR_TLS_TOREK)
/*
**  STARTTLS
*/

# include "sfsasl.h"
#  include <openssl/err.h>

static ssize_t
# if SFIO
tls_read(f, buf, size, disc)
	Sfio_t *f;
	Void_t *buf;
	size_t size;
	Sfdisc_t *disc;
# else /* SFIO */
tls_read(disc, buf, size)
	void *disc;
	void *buf;
	size_t size;
# endif /* SFIO */
{
	int r;
	Tlsdisc_t *sd;

	/* Cast back to correct type */
	sd = (Tlsdisc_t *) disc;

	r = SSL_read(sd->con, (char *) buf, size);
	if (r < 0 && LogLevel > 7)
	{
		char *err;

		err = NULL;
		switch (SSL_get_error(sd->con, r))
		{
			case SSL_ERROR_NONE:
				break;
			case SSL_ERROR_WANT_WRITE:
				err = "write W BLOCK";
				break;
			case SSL_ERROR_WANT_READ:
				err = "write R BLOCK";
				break;
			case SSL_ERROR_WANT_X509_LOOKUP:
				err = "write X BLOCK";
				break;
			case SSL_ERROR_ZERO_RETURN:
				break;
			case SSL_ERROR_SYSCALL:
				err = "syscall error";
/*
				get_last_socket_error());
*/
				break;
			case SSL_ERROR_SSL:
				err = "generic SSL error";
				break;
		}
		if (err != NULL)
			sm_syslog(LOG_WARNING, NOQID, "TLS: read error:  %s",
				  err);
	}
	return r;
}

static ssize_t
# if SFIO
tls_write(f, buf, size, disc)
	Sfio_t *f;
	const Void_t *buf;
	size_t size;
	Sfdisc_t *disc;
# else /* SFIO */
tls_write(disc, buf, size)
	void *disc;
	const void *buf;
	size_t size;
# endif /* SFIO */
{
	int r;
	Tlsdisc_t *sd;

	/* Cast back to correct type */
	sd = (Tlsdisc_t *) disc;

	r = SSL_write(sd->con, (char *)buf, size);
	if (r < 0 && LogLevel > 7)
	{
		char *err;

		err = NULL;
		switch (SSL_get_error(sd->con, r))
		{
			case SSL_ERROR_NONE:
				break;
			case SSL_ERROR_WANT_WRITE:
				err = "write W BLOCK";
				break;
			case SSL_ERROR_WANT_READ:
				err = "write R BLOCK";
				break;
			case SSL_ERROR_WANT_X509_LOOKUP:
				err = "write X BLOCK";
				break;
			case SSL_ERROR_ZERO_RETURN:
				break;
			case SSL_ERROR_SYSCALL:
				err = "syscall error";
/*
				get_last_socket_error());
*/
				break;
			case SSL_ERROR_SSL:
				err = "generic SSL error";
/*
				ERR_GET_REASON(ERR_peek_error()));
*/
				break;
		}
		if (err != NULL)
			sm_syslog(LOG_WARNING, NOQID, "TLS: write error:  %s",
				  err);
	}
	return r;
}

# if !SFIO
static int
tls_close(cookie)
	void *cookie;
{
	int retval = 0;
	Tlsdisc_t *tc;

	/* Cast back to correct type */
	tc = (Tlsdisc_t *)cookie;

	if (tc->fp != NULL)
	{
		retval = fclose(tc->fp);
		tc->fp = NULL;
	}

	free(tc);
	return retval;
}
# endif /* !SFIO */

int
sfdctls(fin, fout, con)
# if SFIO
	Sfio_t *fin;
	Sfio_t *fout;
# else /* SFIO */
	FILE **fin;
	FILE **fout;
# endif /* SFIO */
	SSL *con;
{
	Tlsdisc_t *tlsin, *tlsout;
# if !SFIO
	FILE *fp;
# else /* !SFIO */
	int rfd, wfd;
# endif /* !SFIO */

	if (con == NULL)
		return 0;

	if ((tlsin = (Tlsdisc_t *) malloc(sizeof(Tlsdisc_t))) == NULL)
		return -1;
	if ((tlsout = (Tlsdisc_t *) malloc(sizeof(Tlsdisc_t))) == NULL)
	{
		free(tlsin);
		return -1;
	}

# if SFIO
	tlsin->disc.readf = tls_read;
	tlsin->disc.writef = tls_write;
	tlsin->disc.seekf = NULL;
	tlsin->disc.exceptf = NULL;
	tlsin->con = con;

	tlsout->disc.readf = tls_read;
	tlsout->disc.writef = tls_write;
	tlsout->disc.seekf = NULL;
	tlsout->disc.exceptf = NULL;
	tlsout->con = con;

	rfd = fileno(fin);
	wfd = fileno(fout);
	if (rfd < 0 || wfd < 0 ||
	    SSL_set_rfd(con, rfd) <= 0 || SSL_set_wfd(con, wfd) <= 0)
	{
		free(tlsin);
		free(tlsout);
		return -1;
	}
	if (sfdisc(fin, (Sfdisc_t *) tlsin) != (Sfdisc_t *) tlsin ||
	    sfdisc(fout, (Sfdisc_t *) tlsout) != (Sfdisc_t *) tlsout)
	{
		free(tlsin);
		free(tlsout);
		return -1;
	}
# else /* SFIO */
	tlsin->fp = *fin;
	tlsin->con = con;
	fp = funopen(tlsin, tls_read, tls_write, NULL, tls_close);
	if (fp == NULL)
	{
		free(tlsin);
		return -1;
	}
	*fin = fp;

	tlsout->fp = *fout;
	tlsout->con = con;
	fp = funopen(tlsout, tls_read, tls_write, NULL, tls_close);
	if (fp == NULL)
	{
		FILE *save;

		/* Hack: Don't close underlying fp */
		save = tlsin->fp;
		tlsin->fp = NULL;
		fclose(*fin);
		*fin = save;
		free(tlsout);
		return -1;
	}
	*fout = fp;
	SSL_set_rfd(con, fileno(tlsin->fp));
	SSL_set_wfd(con, fileno(tlsout->fp));
# endif /* SFIO */
	return 0;
}
#endif /* STARTTLS && (SFIO || _FFR_TLS_TOREK) */
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d11 8
a18 2
#include <sm/gen.h>
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.84 2001/09/03 22:35:38 gshapiro Exp $")
a20 17
#include <errno.h>
#if SASL
# include <sasl.h>
# include "sfsasl.h"

/* Structure used by the "sasl" file type */
struct sasl_obj
{
	SM_FILE_T *fp;
	sasl_conn_t *conn;
};

struct sasl_info
{
	SM_FILE_T *fp;
	sasl_conn_t *conn;
};
d22 1
d24 1
a24 11
**  SASL_GETINFO - returns requested information about a "sasl" file
**		  descriptor.
**
**	Parameters:
**		fp -- the file descriptor
**		what -- the type of information requested
**		valp -- the thang to return the information in
**
**	Returns:
**		-1 for unknown requests
**		>=0 on success with valp filled in (if possible).
d27 2
a28 105
static int sasl_getinfo __P((SM_FILE_T *, int, void *));

static int
sasl_getinfo(fp, what, valp)
	SM_FILE_T *fp;
	int what;
	void *valp;
{
	struct sasl_obj *so = (struct sasl_obj *) fp->f_cookie;

	switch (what)
	{
	  case SM_IO_WHAT_FD:
		if (so->fp == NULL)
			return -1;
		return so->fp->f_file; /* for stdio fileno() compatability */

	  case SM_IO_IS_READABLE:
		if (so->fp == NULL)
			return 0;

		/* get info from underlying file */
		return sm_io_getinfo(so->fp, what, valp);

	  default:
		return -1;
	}
}

/*
**  SASL_OPEN -- creates the sasl specific information for opening a
**		file of the sasl type.
**
**	Parameters:
**		fp -- the file pointer associated with the new open
**		info -- contains the sasl connection information pointer and
**			the original SM_FILE_T that holds the open
**		flags -- ignored
**		rpool -- ignored
**
**	Returns:
**		0 on success
*/

static int sasl_open __P((SM_FILE_T *, const void *, int, const void *));

/* ARGSUSED2 */
static int
sasl_open(fp, info, flags, rpool)
	SM_FILE_T *fp;
	const void *info;
	int flags;
	const void *rpool;
{
	struct sasl_obj *so;
	struct sasl_info *si = (struct sasl_info *) info;

	so = (struct sasl_obj *) sm_malloc(sizeof(struct sasl_obj));
	so->fp = si->fp;
	so->conn = si->conn;

	/*
	**  The underlying 'fp' is set to SM_IO_NOW so that the entire
	**  encoded string is written in one chunk. Otherwise there is
	**  the possibility that it may appear illegal, bogus or
	**  mangled to the other side of the connection.
	**  We will read or write through 'fp' since it is the opaque
	**  connection for the communications. We need to treat it this
	**  way in case the encoded string is to be sent down a TLS
	**  connection rather than, say, sm_io's stdio.
	*/

	(void) sm_io_setvbuf(so->fp, SM_TIME_DEFAULT, NULL, SM_IO_NOW, 0);
	fp->f_cookie = so;
	return 0;
}

/*
**  SASL_CLOSE -- close the sasl specific parts of the sasl file pointer
**
**	Parameters:
**		fp -- the file pointer to close
**
**	Returns:
**		0 on success
*/

static int sasl_close __P((SM_FILE_T *));

static int
sasl_close(fp)
	SM_FILE_T *fp;
{
	struct sasl_obj *so;

	so = (struct sasl_obj *) fp->f_cookie;
	if (so->fp != NULL)
	{
		sm_io_close(so->fp, SM_TIME_DEFAULT);
		so->fp = NULL;
	}
	sm_free(so);
	so = NULL;
	return 0;
}
d31 1
a31 17
extern void	sm_sasl_free __P((void *));
# define SASL_DEALLOC(b)	sm_sasl_free(b)

/*
**  SASL_READ -- read encrypted information and decrypt it for the caller
**
**	Parameters:
**		fp -- the file pointer
**		buf -- the location to place the decrypted information
**		size -- the number of bytes to read after decryption
**
**	Results:
**		-1 on error
**		otherwise the number of bytes read
*/

static ssize_t sasl_read __P((SM_FILE_T *, char *, size_t));
d34 3
a36 3
sasl_read(fp, buf, size)
	SM_FILE_T *fp;
	char *buf;
d38 1
d40 1
a40 2
	int result;
	ssize_t len;
d44 1
a44 1
	struct sasl_obj *so = (struct sasl_obj *) fp->f_cookie;
d57 1
a57 1
		len = sm_io_read(so->fp, SM_TIME_DEFAULT, buf, size);
d60 1
a60 2
		result = sasl_decode(so->conn, buf,
				     (unsigned int) len, &outbuf, &outlen);
d70 1
a70 1
	if (outbuf == NULL)
d72 17
a88 10
		/* be paranoid: outbuf == NULL but outlen != 0 */
		syserr("@@sasl_read failure: outbuf == NULL but outlen != 0");
		/* NOTREACHED */
	}
	if (outlen - offset > size)
	{
		/* return another part of the buffer */
		(void) memcpy(buf, outbuf + offset, size);
		offset += size;
		len = size;
d92 2
a93 7
		/* return the rest of the buffer */
		len = outlen - offset;
		(void) memcpy(buf, outbuf + offset, (size_t) len);
		SASL_DEALLOC(outbuf);
		outbuf = NULL;
		offset = 0;
		outlen = 0;
d95 1
a95 1
	return len;
a97 15
/*
**  SASL_WRITE -- write information out after encrypting it
**
**	Parameters:
**		fp -- the file pointer
**		buf -- holds the data to be encrypted and written
**		size -- the number of bytes to have encrypted and written
**
**	Returns:
**		-1 on error
**		otherwise number of bytes written
*/

static ssize_t sasl_write __P((SM_FILE_T *, const char *, size_t));

d99 3
a101 3
sasl_write(fp, buf, size)
	SM_FILE_T *fp;
	const char *buf;
d103 1
d108 1
a108 2
	size_t ret = 0, total = 0;
	struct sasl_obj *so = (struct sasl_obj *) fp->f_cookie;
d110 1
a110 2
	result = sasl_encode(so->conn, buf,
			     (unsigned int) size, &outbuf, &outlen);
d117 1
a117 7
		while (outlen > 0)
		{
			ret = sm_io_write(so->fp, SM_TIME_DEFAULT,
					  &outbuf[total], outlen);
			outlen -= ret;
			total += ret;
		}
a122 18
/*
**  SFDCSASL -- create sasl file type and open in and out file pointers
**	       for sendmail to read from and write to.
**
**	Parameters:
**		fin -- the sm_io file encrypted data to be read from
**		fout -- the sm_io file encrypted data to be writen to
**		conn -- the sasl connection pointer
**
**	Returns:
**		-1 on error
**		0 on success
**
**	Side effects:
**		The arguments "fin" and "fout" are replaced with the new
**		SM_FILE_T pointers.
*/

d125 2
a126 2
	SM_FILE_T **fin;
	SM_FILE_T **fout;
d129 1
a129 5
	SM_FILE_T *newin, *newout;
	SM_FILE_T  SM_IO_SET_TYPE(sasl_vector, "sasl", sasl_open, sasl_close,
		sasl_read, sasl_write, NULL, sasl_getinfo, NULL,
		SM_TIME_FOREVER);
	struct sasl_info info;
d137 1
a137 9
	SM_IO_INIT_TYPE(sasl_vector, "sasl", sasl_open, sasl_close,
		sasl_read, sasl_write, NULL, sasl_getinfo, NULL,
		SM_TIME_FOREVER);
	info.fp = *fin;
	info.conn = conn;
	newin = sm_io_open(&sasl_vector, SM_TIME_DEFAULT, &info, SM_IO_RDONLY,
			   NULL);

	if (newin == NULL)
d139 1
a139 7

	info.fp = *fout;
	info.conn = conn;
	newout = sm_io_open(&sasl_vector, SM_TIME_DEFAULT, &info, SM_IO_WRONLY,
			    NULL);

	if (newout == NULL)
d141 1
a141 1
		(void) sm_io_close(newin, SM_TIME_DEFAULT);
a143 11
	sm_io_automode(newin, newout);

	*fin = newin;
	*fout = newout;
	return 0;
}
#endif /* SASL */

#if STARTTLS
# include "sfsasl.h"
#  include <openssl/err.h>
d145 9
a153 12
/* Structure used by the "tls" file type */
struct tls_obj
{
	SM_FILE_T *fp;
	SSL *con;
};

struct tls_info
{
	SM_FILE_T *fp;
	SSL *con;
};
d155 2
a156 24
/*
**  TLS_GETINFO - returns requested information about a "tls" file
**		 descriptor.
**
**	Parameters:
**		fp -- the file descriptor
**		what -- the type of information requested
**		valp -- the thang to return the information in (unused)
**
**	Returns:
**		-1 for unknown requests
**		>=0 on success with valp filled in (if possible).
*/

static int tls_getinfo __P((SM_FILE_T *, int, void *));

/* ARGSUSED2 */
static int
tls_getinfo(fp, what, valp)
	SM_FILE_T *fp;
	int what;
	void *valp;
{
	struct tls_obj *so = (struct tls_obj *) fp->f_cookie;
d158 2
a159 1
	switch (what)
d161 2
a162 9
	  case SM_IO_WHAT_FD:
		if (so->fp == NULL)
			return -1;
		return so->fp->f_file; /* for stdio fileno() compatability */

	  case SM_IO_IS_READABLE:
		return SSL_pending(so->con) > 0;

	  default:
d165 1
d167 1
d169 1
d171 1
a171 12
**  TLS_OPEN -- creates the tls specific information for opening a
**	       file of the tls type.
**
**	Parameters:
**		fp -- the file pointer associated with the new open
**		info -- the sm_io file pointer holding the open and the
**			TLS encryption connection to be read from or written to
**		flags -- ignored
**		rpool -- ignored
**
**	Returns:
**		0 on success
d174 2
a175 1
static int tls_open __P((SM_FILE_T *, const void *, int, const void *));
d177 13
a189 7
/* ARGSUSED2 */
static int
tls_open(fp, info, flags, rpool)
	SM_FILE_T *fp;
	const void *info;
	int flags;
	const void *rpool;
d191 2
a192 2
	struct tls_obj *so;
	struct tls_info *ti = (struct tls_info *) info;
d194 2
a195 3
	so = (struct tls_obj *) sm_malloc(sizeof(struct tls_obj));
	so->fp = ti->fp;
	so->con = ti->con;
d197 4
a200 7
	/*
	**  We try to get the "raw" file descriptor that TLS uses to
	**  do the actual read/write with. This is to allow us control
	**  over the file descriptor being a blocking or non-blocking type.
	**  Under the covers TLS handles the change and this allows us
	**  to do timeouts with sm_io.
	*/
d202 29
a230 29
	fp->f_file = sm_io_getinfo(so->fp, SM_IO_WHAT_FD, NULL);
	(void) sm_io_setvbuf(so->fp, SM_TIME_DEFAULT, NULL, SM_IO_NOW, 0);
	fp->f_cookie = so;
	return 0;
}

/*
**  TLS_CLOSE -- close the tls specific parts of the tls file pointer
**
**	Parameters:
**		fp -- the file pointer to close
**
**	Returns:
**		0 on success
*/

static int tls_close __P((SM_FILE_T *));

static int
tls_close(fp)
	SM_FILE_T *fp;
{
	struct tls_obj *so;

	so = (struct tls_obj *) fp->f_cookie;
	if (so->fp != NULL)
	{
		sm_io_close(so->fp, SM_TIME_DEFAULT);
		so->fp = NULL;
d232 1
a232 3
	sm_free(so);
	so = NULL;
	return 0;
a234 18
/* maximum number of retries for TLS related I/O due to handshakes */
# define MAX_TLS_IOS	4

/*
**  TLS_READ -- read secured information for the caller
**
**	Parameters:
**		fp -- the file pointer
**		buf -- the location to place the data
**		size -- the number of bytes to read from connection
**
**	Results:
**		-1 on error
**		otherwise the number of bytes read
*/

static ssize_t tls_read __P((SM_FILE_T *, char *, size_t));

d236 10
a245 3
tls_read(fp, buf, size)
	SM_FILE_T *fp;
	char *buf;
d247 1
d250 1
a250 3
	static int again = MAX_TLS_IOS;
	struct tls_obj *so = (struct tls_obj *) fp->f_cookie;
	char *err;
d252 2
a253 1
	r = SSL_read(so->con, (char *) buf, size);
d255 2
a256 1
	if (r > 0)
d258 1
a258 3
		again = MAX_TLS_IOS;
		return r;
	}
d260 24
a283 26
	err = NULL;
	switch (SSL_get_error(so->con, r))
	{
	  case SSL_ERROR_NONE:
	  case SSL_ERROR_ZERO_RETURN:
		again = MAX_TLS_IOS;
		break;
	  case SSL_ERROR_WANT_WRITE:
		if (--again <= 0)
			err = "read W BLOCK";
		else
			errno = EAGAIN;
		break;
	  case SSL_ERROR_WANT_READ:
		if (--again <= 0)
			err = "read R BLOCK";
		else
			errno = EAGAIN;
		break;
	  case SSL_ERROR_WANT_X509_LOOKUP:
		err = "write X BLOCK";
		break;
	  case SSL_ERROR_SYSCALL:
		if (r == 0 && errno == 0) /* out of protocol EOF found */
			break;
		err = "syscall error";
d285 1
a285 1
		get_last_socket_error());
d287 5
a291 15
		break;
	  case SSL_ERROR_SSL:
		err = "generic SSL error";
		if (LogLevel > 9)
			tlslogerr("read");
		break;
	}
	if (err != NULL)
	{
		again = MAX_TLS_IOS;
		if (errno == 0)
			errno = EIO;
		if (LogLevel > 7)
			sm_syslog(LOG_WARNING, NOQID,
				  "STARTTLS: read error=%s (%d)", err, r);
d296 7
a302 12
/*
**  TLS_WRITE -- write information out through secure connection
**
**	Parameters:
**		fp -- the file pointer
**		buf -- holds the data to be securely written
**		size -- the number of bytes to write
**
**	Returns:
**		-1 on error
**		otherwise number of bytes written
*/
d304 2
a305 1
static ssize_t tls_write __P((SM_FILE_T *, const char *, size_t));
d307 4
a310 65
static ssize_t
tls_write(fp, buf, size)
	SM_FILE_T *fp;
	const char *buf;
	size_t size;
{
	int r;
	static int again = MAX_TLS_IOS;
	struct tls_obj *so = (struct tls_obj *) fp->f_cookie;
	char *err;

	r = SSL_write(so->con, (char *) buf, size);

	if (r > 0)
	{
		again = MAX_TLS_IOS;
		return r;
	}
	err = NULL;
	switch (SSL_get_error(so->con, r))
	{
	  case SSL_ERROR_NONE:
	  case SSL_ERROR_ZERO_RETURN:
		again = MAX_TLS_IOS;
		break;
	  case SSL_ERROR_WANT_WRITE:
		if (--again <= 0)
			err = "write W BLOCK";
		else
			errno = EAGAIN;
		break;
	  case SSL_ERROR_WANT_READ:
		if (--again <= 0)
			err = "write R BLOCK";
		else
			errno = EAGAIN;
		break;
	  case SSL_ERROR_WANT_X509_LOOKUP:
		err = "write X BLOCK";
		break;
	  case SSL_ERROR_SYSCALL:
		if (r == 0 && errno == 0) /* out of protocol EOF found */
			break;
		err = "syscall error";
/*
		get_last_socket_error());
*/
		break;
	  case SSL_ERROR_SSL:
		err = "generic SSL error";
/*
		ERR_GET_REASON(ERR_peek_error()));
*/
		if (LogLevel > 9)
			tlslogerr("write");
		break;
	}
	if (err != NULL)
	{
		again = MAX_TLS_IOS;
		if (errno == 0)
			errno = EIO;
		if (LogLevel > 7)
			sm_syslog(LOG_WARNING, NOQID,
				  "STARTTLS: write error=%s (%d)", err, r);
d312 3
a314 1
	return r;
d316 1
a316 20

/*
**  SFDCTLS -- create tls file type and open in and out file pointers
**	      for sendmail to read from and write to.
**
**	Parameters:
**		fin -- data input source being replaced
**		fout -- data output source being replaced
**		conn -- the tls connection pointer
**
**	Returns:
**		-1 on error
**		0 on success
**
**	Side effects:
**		The arguments "fin" and "fout" are replaced with the new
**		SM_FILE_T pointers.
**		The original "fin" and "fout" are preserved in the tls file
**		type but are not actually used because of the design of TLS.
*/
d320 7
a326 2
	SM_FILE_T **fin;
	SM_FILE_T **fout;
d329 11
a339 16
	SM_FILE_T *tlsin, *tlsout;
	SM_FILE_T SM_IO_SET_TYPE(tls_vector, "tls", tls_open, tls_close,
		tls_read, tls_write, NULL, tls_getinfo, NULL,
		SM_TIME_FOREVER);
	struct tls_info info;

	SM_ASSERT(con != NULL);

	SM_IO_INIT_TYPE(tls_vector, "tls", tls_open, tls_close,
		tls_read, tls_write, NULL, tls_getinfo, NULL,
		SM_TIME_FOREVER);
	info.fp = *fin;
	info.con = con;
	tlsin = sm_io_open(&tls_vector, SM_TIME_DEFAULT, &info, SM_IO_RDONLY,
			   NULL);
	if (tlsin == NULL)
d341 5
d347 24
a370 4
	info.fp = *fout;
	tlsout = sm_io_open(&tls_vector, SM_TIME_DEFAULT, &info, SM_IO_WRONLY,
			    NULL);
	if (tlsout == NULL)
d372 2
a373 1
		(void) sm_io_close(tlsin, SM_TIME_DEFAULT);
d376 10
a385 1
	sm_io_automode(tlsin, tlsout);
d387 19
a405 2
	*fin = tlsin;
	*fout = tlsout;
d408 1
a408 1
#endif /* STARTTLS */
@


