head	1.37;
access;
symbols
	OPENBSD_5_6:1.36.0.6
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.36.0.4
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.35.0.2
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.34.0.2
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.33.0.6
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.4
	OPENBSD_5_0:1.33.0.2
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.32.0.12
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.10
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.6
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.8
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.4
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.2
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.31.0.4
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.31.0.2
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.30.0.2
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.26.0.4
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.19.0.4
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.36;
commitid	M7i5giHIoz3DMlTU;

1.36
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.34;

1.34
date	2012.12.26.11.44.12;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2011.05.17.15.54.23;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2007.04.04.14.43.48;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2006.08.13.13.01.48;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2006.06.14.17.53.02;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2006.03.22.18.43.55;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.08.16.00.51;	author millert;	state Exp;
branches
	1.26.2.1
	1.26.4.1;
next	1.25;

1.25
date	2005.01.12.18.15.46;	author millert;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2004.12.16.00.21.30;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2004.09.18.04.08.34;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2004.06.24.03.59.27;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.19.01.41.13;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.09.17.17.31.40;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.29.19.44.00;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.03.17.31.21;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.01.19.59.22;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.15.02.23.35;	author millert;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2002.07.20.17.43.18;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.14.23.13.24;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.26.04.48.55;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.03.17.25.47;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.18.00.49.28;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.17.23.46.27;	author millert;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.01.01.01.41;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.29.01.31.14;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.28.02.43.54;	author millert;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.01.15.21.09.08;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.07.19.20.40;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.44;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.44;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.13;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.50;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.31.33;	author miod;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.31.01.47.56;	author jason;	state Exp;
branches;
next	;

1.10.2.1
date	2003.03.31.07.07.07;	author miod;	state Exp;
branches;
next	;

1.16.2.1
date	2003.03.31.01.01.47;	author margarida;	state Exp;
branches;
next	;

1.25.2.1
date	2006.03.24.05.42.48;	author brad;	state Exp;
branches;
next	;

1.26.2.1
date	2006.03.24.05.56.18;	author brad;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2006.06.15.02.57.36;	author brad;	state Exp;
branches;
next	;

1.26.4.1
date	2006.03.25.01.49.37;	author brad;	state Exp;
branches;
next	1.26.4.2;

1.26.4.2
date	2006.06.15.02.46.09;	author brad;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2010, 2012 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>
#include <sm/time.h>

SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.1030 2013/11/22 20:51:55 ca Exp $")

#if HASSETUSERCONTEXT
# include <login_cap.h>
#endif /* HASSETUSERCONTEXT */

#if NETINET || NETINET6
# include <arpa/inet.h>
#endif /* NETINET || NETINET6 */

#if STARTTLS || SASL
# include "sfsasl.h"
#endif /* STARTTLS || SASL */

static int	deliver __P((ENVELOPE *, ADDRESS *));
static void	dup_queue_file __P((ENVELOPE *, ENVELOPE *, int));
static void	mailfiletimeout __P((int));
static void	endwaittimeout __P((int));
static int	parse_hostsignature __P((char *, char **, MAILER *));
static void	sendenvelope __P((ENVELOPE *, int));
static int	coloncmp __P((const char *, const char *));

#if STARTTLS
#  include <openssl/err.h>
static int	starttls __P((MAILER *, MCI *, ENVELOPE *));
static int	endtlsclt __P((MCI *));
#endif /* STARTTLS */
# if STARTTLS || SASL
static bool	iscltflgset __P((ENVELOPE *, int));
# endif /* STARTTLS || SASL */

/*
**  SENDALL -- actually send all the messages.
**
**	Parameters:
**		e -- the envelope to send.
**		mode -- the delivery mode to use.  If SM_DEFAULT, use
**			the current e->e_sendmode.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Scans the send lists and sends everything it finds.
**		Delivers any appropriate error messages.
**		If we are running in a non-interactive mode, takes the
**			appropriate action.
*/

void
sendall(e, mode)
	ENVELOPE *e;
	int mode;
{
	register ADDRESS *q;
	char *owner;
	int otherowners;
	int save_errno;
	register ENVELOPE *ee;
	ENVELOPE *splitenv = NULL;
	int oldverbose = Verbose;
	bool somedeliveries = false, expensive = false;
	pid_t pid;

	/*
	**  If this message is to be discarded, don't bother sending
	**  the message at all.
	*/

	if (bitset(EF_DISCARD, e->e_flags))
	{
		if (tTd(13, 1))
			sm_dprintf("sendall: discarding id %s\n", e->e_id);
		e->e_flags |= EF_CLRQUEUE;
		if (LogLevel > 9)
			logundelrcpts(e, "discarded", 9, true);
		else if (LogLevel > 4)
			sm_syslog(LOG_INFO, e->e_id, "discarded");
		markstats(e, NULL, STATS_REJECT);
		return;
	}

	/*
	**  If we have had global, fatal errors, don't bother sending
	**  the message at all if we are in SMTP mode.  Local errors
	**  (e.g., a single address failing) will still cause the other
	**  addresses to be sent.
	*/

	if (bitset(EF_FATALERRS, e->e_flags) &&
	    (OpMode == MD_SMTP || OpMode == MD_DAEMON))
	{
		e->e_flags |= EF_CLRQUEUE;
		return;
	}

	/* determine actual delivery mode */
	if (mode == SM_DEFAULT)
	{
		mode = e->e_sendmode;
		if (mode != SM_VERIFY && mode != SM_DEFER &&
		    shouldqueue(e->e_msgpriority, e->e_ctime))
			mode = SM_QUEUE;
	}

	if (tTd(13, 1))
	{
		sm_dprintf("\n===== SENDALL: mode %c, id %s, e_from ",
			mode, e->e_id);
		printaddr(sm_debug_file(), &e->e_from, false);
		sm_dprintf("\te_flags = ");
		printenvflags(e);
		sm_dprintf("sendqueue:\n");
		printaddr(sm_debug_file(), e->e_sendqueue, true);
	}

	/*
	**  Do any preprocessing necessary for the mode we are running.
	**	Check to make sure the hop count is reasonable.
	**	Delete sends to the sender in mailing lists.
	*/

	CurEnv = e;
	if (tTd(62, 1))
		checkfds(NULL);

	if (e->e_hopcount > MaxHopCount)
	{
		char *recip;

		if (e->e_sendqueue != NULL &&
		    e->e_sendqueue->q_paddr != NULL)
			recip = e->e_sendqueue->q_paddr;
		else
			recip = "(nobody)";

		errno = 0;
		queueup(e, WILL_BE_QUEUED(mode), false);
		e->e_flags |= EF_FATALERRS|EF_PM_NOTIFY|EF_CLRQUEUE;
		ExitStat = EX_UNAVAILABLE;
		syserr("554 5.4.6 Too many hops %d (%d max): from %s via %s, to %s",
		       e->e_hopcount, MaxHopCount, e->e_from.q_paddr,
		       RealHostName == NULL ? "localhost" : RealHostName,
		       recip);
		for (q = e->e_sendqueue; q != NULL; q = q->q_next)
		{
			if (QS_IS_DEAD(q->q_state))
				continue;
			q->q_state = QS_BADADDR;
			q->q_status = "5.4.6";
			q->q_rstatus = "554 5.4.6 Too many hops";
		}
		return;
	}

	/*
	**  Do sender deletion.
	**
	**	If the sender should be queued up, skip this.
	**	This can happen if the name server is hosed when you
	**	are trying to send mail.  The result is that the sender
	**	is instantiated in the queue as a recipient.
	*/

	if (!bitset(EF_METOO, e->e_flags) &&
	    !QS_IS_QUEUEUP(e->e_from.q_state))
	{
		if (tTd(13, 5))
		{
			sm_dprintf("sendall: QS_SENDER ");
			printaddr(sm_debug_file(), &e->e_from, false);
		}
		e->e_from.q_state = QS_SENDER;
		(void) recipient(&e->e_from, &e->e_sendqueue, 0, e);
	}

	/*
	**  Handle alias owners.
	**
	**	We scan up the q_alias chain looking for owners.
	**	We discard owners that are the same as the return path.
	*/

	for (q = e->e_sendqueue; q != NULL; q = q->q_next)
	{
		register struct address *a;

		for (a = q; a != NULL && a->q_owner == NULL; a = a->q_alias)
			continue;
		if (a != NULL)
			q->q_owner = a->q_owner;

		if (q->q_owner != NULL &&
		    !QS_IS_DEAD(q->q_state) &&
		    strcmp(q->q_owner, e->e_from.q_paddr) == 0)
			q->q_owner = NULL;
	}

	if (tTd(13, 25))
	{
		sm_dprintf("\nAfter first owner pass, sendq =\n");
		printaddr(sm_debug_file(), e->e_sendqueue, true);
	}

	owner = "";
	otherowners = 1;
	while (owner != NULL && otherowners > 0)
	{
		if (tTd(13, 28))
			sm_dprintf("owner = \"%s\", otherowners = %d\n",
				   owner, otherowners);
		owner = NULL;
		otherowners = bitset(EF_SENDRECEIPT, e->e_flags) ? 1 : 0;

		for (q = e->e_sendqueue; q != NULL; q = q->q_next)
		{
			if (tTd(13, 30))
			{
				sm_dprintf("Checking ");
				printaddr(sm_debug_file(), q, false);
			}
			if (QS_IS_DEAD(q->q_state))
			{
				if (tTd(13, 30))
					sm_dprintf("    ... QS_IS_DEAD\n");
				continue;
			}
			if (tTd(13, 29) && !tTd(13, 30))
			{
				sm_dprintf("Checking ");
				printaddr(sm_debug_file(), q, false);
			}

			if (q->q_owner != NULL)
			{
				if (owner == NULL)
				{
					if (tTd(13, 40))
						sm_dprintf("    ... First owner = \"%s\"\n",
							   q->q_owner);
					owner = q->q_owner;
				}
				else if (owner != q->q_owner)
				{
					if (strcmp(owner, q->q_owner) == 0)
					{
						if (tTd(13, 40))
							sm_dprintf("    ... Same owner = \"%s\"\n",
								   owner);

						/* make future comparisons cheap */
						q->q_owner = owner;
					}
					else
					{
						if (tTd(13, 40))
							sm_dprintf("    ... Another owner \"%s\"\n",
								   q->q_owner);
						otherowners++;
					}
					owner = q->q_owner;
				}
				else if (tTd(13, 40))
					sm_dprintf("    ... Same owner = \"%s\"\n",
						   owner);
			}
			else
			{
				if (tTd(13, 40))
					sm_dprintf("    ... Null owner\n");
				otherowners++;
			}

			if (QS_IS_BADADDR(q->q_state))
			{
				if (tTd(13, 30))
					sm_dprintf("    ... QS_IS_BADADDR\n");
				continue;
			}

			if (QS_IS_QUEUEUP(q->q_state))
			{
				MAILER *m = q->q_mailer;

				/*
				**  If we have temporary address failures
				**  (e.g., dns failure) and a fallback MX is
				**  set, send directly to the fallback MX host.
				*/

				if (FallbackMX != NULL &&
				    !wordinclass(FallbackMX, 'w') &&
				    mode != SM_VERIFY &&
				    !bitnset(M_NOMX, m->m_flags) &&
				    strcmp(m->m_mailer, "[IPC]") == 0 &&
				    m->m_argv[0] != NULL &&
				    strcmp(m->m_argv[0], "TCP") == 0)
				{
					int len;
					char *p;

					if (tTd(13, 30))
						sm_dprintf("    ... FallbackMX\n");

					len = strlen(FallbackMX) + 1;
					p = sm_rpool_malloc_x(e->e_rpool, len);
					(void) sm_strlcpy(p, FallbackMX, len);
					q->q_state = QS_OK;
					q->q_host = p;
				}
				else
				{
					if (tTd(13, 30))
						sm_dprintf("    ... QS_IS_QUEUEUP\n");
					continue;
				}
			}

			/*
			**  If this mailer is expensive, and if we don't
			**  want to make connections now, just mark these
			**  addresses and return.  This is useful if we
			**  want to batch connections to reduce load.  This
			**  will cause the messages to be queued up, and a
			**  daemon will come along to send the messages later.
			*/

			if (NoConnect && !Verbose &&
			    bitnset(M_EXPENSIVE, q->q_mailer->m_flags))
			{
				if (tTd(13, 30))
					sm_dprintf("    ... expensive\n");
				q->q_state = QS_QUEUEUP;
				expensive = true;
			}
			else if (bitnset(M_HOLD, q->q_mailer->m_flags) &&
				 QueueLimitId == NULL &&
				 QueueLimitSender == NULL &&
				 QueueLimitRecipient == NULL)
			{
				if (tTd(13, 30))
					sm_dprintf("    ... hold\n");
				q->q_state = QS_QUEUEUP;
				expensive = true;
			}
			else if (QueueMode != QM_QUARANTINE &&
				 e->e_quarmsg != NULL)
			{
				if (tTd(13, 30))
					sm_dprintf("    ... quarantine: %s\n",
						   e->e_quarmsg);
				q->q_state = QS_QUEUEUP;
				expensive = true;
			}
			else
			{
				if (tTd(13, 30))
					sm_dprintf("    ... deliverable\n");
				somedeliveries = true;
			}
		}

		if (owner != NULL && otherowners > 0)
		{
			/*
			**  Split this envelope into two.
			*/

			ee = (ENVELOPE *) sm_rpool_malloc_x(e->e_rpool,
							    sizeof(*ee));
			STRUCTCOPY(*e, *ee);
			ee->e_message = NULL;
			ee->e_id = NULL;
			assign_queueid(ee);

			if (tTd(13, 1))
				sm_dprintf("sendall: split %s into %s, owner = \"%s\", otherowners = %d\n",
					   e->e_id, ee->e_id, owner,
					   otherowners);

			ee->e_header = copyheader(e->e_header, ee->e_rpool);
			ee->e_sendqueue = copyqueue(e->e_sendqueue,
						    ee->e_rpool);
			ee->e_errorqueue = copyqueue(e->e_errorqueue,
						     ee->e_rpool);
			ee->e_flags = e->e_flags & ~(EF_INQUEUE|EF_CLRQUEUE|EF_FATALERRS|EF_SENDRECEIPT|EF_RET_PARAM);
			ee->e_flags |= EF_NORECEIPT;
			setsender(owner, ee, NULL, '\0', true);
			if (tTd(13, 5))
			{
				sm_dprintf("sendall(split): QS_SENDER ");
				printaddr(sm_debug_file(), &ee->e_from, false);
			}
			ee->e_from.q_state = QS_SENDER;
			ee->e_dfp = NULL;
			ee->e_lockfp = NULL;
			ee->e_xfp = NULL;
			ee->e_qgrp = e->e_qgrp;
			ee->e_qdir = e->e_qdir;
			ee->e_errormode = EM_MAIL;
			ee->e_sibling = splitenv;
			ee->e_statmsg = NULL;
			if (e->e_quarmsg != NULL)
				ee->e_quarmsg = sm_rpool_strdup_x(ee->e_rpool,
								  e->e_quarmsg);
			splitenv = ee;

			for (q = e->e_sendqueue; q != NULL; q = q->q_next)
			{
				if (q->q_owner == owner)
				{
					q->q_state = QS_CLONED;
					if (tTd(13, 6))
						sm_dprintf("\t... stripping %s from original envelope\n",
							   q->q_paddr);
				}
			}
			for (q = ee->e_sendqueue; q != NULL; q = q->q_next)
			{
				if (q->q_owner != owner)
				{
					q->q_state = QS_CLONED;
					if (tTd(13, 6))
						sm_dprintf("\t... dropping %s from cloned envelope\n",
							   q->q_paddr);
				}
				else
				{
					/* clear DSN parameters */
					q->q_flags &= ~(QHASNOTIFY|Q_PINGFLAGS);
					q->q_flags |= DefaultNotify & ~QPINGONSUCCESS;
					if (tTd(13, 6))
						sm_dprintf("\t... moving %s to cloned envelope\n",
							   q->q_paddr);
				}
			}

			if (mode != SM_VERIFY && bitset(EF_HAS_DF, e->e_flags))
				dup_queue_file(e, ee, DATAFL_LETTER);

			/*
			**  Give the split envelope access to the parent
			**  transcript file for errors obtained while
			**  processing the recipients (done before the
			**  envelope splitting).
			*/

			if (e->e_xfp != NULL)
				ee->e_xfp = sm_io_dup(e->e_xfp);

			/* failed to dup e->e_xfp, start a new transcript */
			if (ee->e_xfp == NULL)
				openxscript(ee);

			if (mode != SM_VERIFY && LogLevel > 4)
				sm_syslog(LOG_INFO, e->e_id,
					  "%s: clone: owner=%s",
					  ee->e_id, owner);
		}
	}

	if (owner != NULL)
	{
		setsender(owner, e, NULL, '\0', true);
		if (tTd(13, 5))
		{
			sm_dprintf("sendall(owner): QS_SENDER ");
			printaddr(sm_debug_file(), &e->e_from, false);
		}
		e->e_from.q_state = QS_SENDER;
		e->e_errormode = EM_MAIL;
		e->e_flags |= EF_NORECEIPT;
		e->e_flags &= ~EF_FATALERRS;
	}

	/* if nothing to be delivered, just queue up everything */
	if (!somedeliveries && !WILL_BE_QUEUED(mode) &&
	    mode != SM_VERIFY)
	{
		time_t now;

		if (tTd(13, 29))
			sm_dprintf("No deliveries: auto-queueing\n");
		mode = SM_QUEUE;
		now = curtime();

		/* treat this as a delivery in terms of counting tries */
		e->e_dtime = now;
		if (!expensive)
			e->e_ntries++;
		for (ee = splitenv; ee != NULL; ee = ee->e_sibling)
		{
			ee->e_dtime = now;
			if (!expensive)
				ee->e_ntries++;
		}
	}

	if ((WILL_BE_QUEUED(mode) || mode == SM_FORK ||
	     (mode != SM_VERIFY &&
	      (SuperSafe == SAFE_REALLY ||
	       SuperSafe == SAFE_REALLY_POSTMILTER))) &&
	    (!bitset(EF_INQUEUE, e->e_flags) || splitenv != NULL))
	{
		bool msync;

		/*
		**  Be sure everything is instantiated in the queue.
		**  Split envelopes first in case the machine crashes.
		**  If the original were done first, we may lose
		**  recipients.
		*/

#if !HASFLOCK
		msync = false;
#else /* !HASFLOCK */
		msync = mode == SM_FORK;
#endif /* !HASFLOCK */

		for (ee = splitenv; ee != NULL; ee = ee->e_sibling)
			queueup(ee, WILL_BE_QUEUED(mode), msync);
		queueup(e, WILL_BE_QUEUED(mode), msync);
	}

	if (tTd(62, 10))
		checkfds("after envelope splitting");

	/*
	**  If we belong in background, fork now.
	*/

	if (tTd(13, 20))
	{
		sm_dprintf("sendall: final mode = %c\n", mode);
		if (tTd(13, 21))
		{
			sm_dprintf("\n================ Final Send Queue(s) =====================\n");
			sm_dprintf("\n  *** Envelope %s, e_from=%s ***\n",
				   e->e_id, e->e_from.q_paddr);
			printaddr(sm_debug_file(), e->e_sendqueue, true);
			for (ee = splitenv; ee != NULL; ee = ee->e_sibling)
			{
				sm_dprintf("\n  *** Envelope %s, e_from=%s ***\n",
					   ee->e_id, ee->e_from.q_paddr);
				printaddr(sm_debug_file(), ee->e_sendqueue, true);
			}
			sm_dprintf("==========================================================\n\n");
		}
	}
	switch (mode)
	{
	  case SM_VERIFY:
		Verbose = 2;
		break;

	  case SM_QUEUE:
	  case SM_DEFER:
#if HASFLOCK
  queueonly:
#endif /* HASFLOCK */
		if (e->e_nrcpts > 0)
			e->e_flags |= EF_INQUEUE;
		(void) dropenvelope(e, splitenv != NULL, true);
		for (ee = splitenv; ee != NULL; ee = ee->e_sibling)
		{
			if (ee->e_nrcpts > 0)
				ee->e_flags |= EF_INQUEUE;
			(void) dropenvelope(ee, false, true);
		}
		return;

	  case SM_FORK:
		if (e->e_xfp != NULL)
			(void) sm_io_flush(e->e_xfp, SM_TIME_DEFAULT);

#if !HASFLOCK
		/*
		**  Since fcntl locking has the interesting semantic that
		**  the lock is owned by a process, not by an open file
		**  descriptor, we have to flush this to the queue, and
		**  then restart from scratch in the child.
		*/

		{
			/* save id for future use */
			char *qid = e->e_id;

			/* now drop the envelope in the parent */
			e->e_flags |= EF_INQUEUE;
			(void) dropenvelope(e, splitenv != NULL, false);

			/* arrange to reacquire lock after fork */
			e->e_id = qid;
		}

		for (ee = splitenv; ee != NULL; ee = ee->e_sibling)
		{
			/* save id for future use */
			char *qid = ee->e_id;

			/* drop envelope in parent */
			ee->e_flags |= EF_INQUEUE;
			(void) dropenvelope(ee, false, false);

			/* and save qid for reacquisition */
			ee->e_id = qid;
		}

#endif /* !HASFLOCK */

		/*
		**  Since the delivery may happen in a child and the parent
		**  does not wait, the parent may close the maps thereby
		**  removing any shared memory used by the map.  Therefore,
		**  close the maps now so the child will dynamically open
		**  them if necessary.
		*/

		closemaps(false);

		pid = fork();
		if (pid < 0)
		{
			syserr("deliver: fork 1");
#if HASFLOCK
			goto queueonly;
#else /* HASFLOCK */
			e->e_id = NULL;
			for (ee = splitenv; ee != NULL; ee = ee->e_sibling)
				ee->e_id = NULL;
			return;
#endif /* HASFLOCK */
		}
		else if (pid > 0)
		{
#if HASFLOCK
			/* be sure we leave the temp files to our child */
			/* close any random open files in the envelope */
			closexscript(e);
			if (e->e_dfp != NULL)
				(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT);
			e->e_dfp = NULL;
			e->e_flags &= ~EF_HAS_DF;

			/* can't call unlockqueue to avoid unlink of xfp */
			if (e->e_lockfp != NULL)
				(void) sm_io_close(e->e_lockfp, SM_TIME_DEFAULT);
			else
				syserr("%s: sendall: null lockfp", e->e_id);
			e->e_lockfp = NULL;
#endif /* HASFLOCK */

			/* make sure the parent doesn't own the envelope */
			e->e_id = NULL;

#if USE_DOUBLE_FORK
			/* catch intermediate zombie */
			(void) waitfor(pid);
#endif /* USE_DOUBLE_FORK */
			return;
		}

		/* Reset global flags */
		RestartRequest = NULL;
		RestartWorkGroup = false;
		ShutdownRequest = NULL;
		PendingSignal = 0;

		/*
		**  Initialize exception stack and default exception
		**  handler for child process.
		*/

		sm_exc_newthread(fatal_error);

		/*
		**  Since we have accepted responsbility for the message,
		**  change the SIGTERM handler.  intsig() (the old handler)
		**  would remove the envelope if this was a command line
		**  message submission.
		*/

		(void) sm_signal(SIGTERM, SIG_DFL);

#if USE_DOUBLE_FORK
		/* double fork to avoid zombies */
		pid = fork();
		if (pid > 0)
			exit(EX_OK);
		save_errno = errno;
#endif /* USE_DOUBLE_FORK */

		CurrentPid = getpid();

		/* be sure we are immune from the terminal */
		disconnect(2, e);
		clearstats();

		/* prevent parent from waiting if there was an error */
		if (pid < 0)
		{
			errno = save_errno;
			syserr("deliver: fork 2");
#if HASFLOCK
			e->e_flags |= EF_INQUEUE;
#else /* HASFLOCK */
			e->e_id = NULL;
#endif /* HASFLOCK */
			finis(true, true, ExitStat);
		}

		/* be sure to give error messages in child */
		QuickAbort = false;

		/*
		**  Close any cached connections.
		**
		**	We don't send the QUIT protocol because the parent
		**	still knows about the connection.
		**
		**	This should only happen when delivering an error
		**	message.
		*/

		mci_flush(false, NULL);

#if HASFLOCK
		break;
#else /* HASFLOCK */

		/*
		**  Now reacquire and run the various queue files.
		*/

		for (ee = splitenv; ee != NULL; ee = ee->e_sibling)
		{
			ENVELOPE *sibling = ee->e_sibling;

			(void) dowork(ee->e_qgrp, ee->e_qdir, ee->e_id,
				      false, false, ee);
			ee->e_sibling = sibling;
		}
		(void) dowork(e->e_qgrp, e->e_qdir, e->e_id,
			      false, false, e);
		finis(true, true, ExitStat);
#endif /* HASFLOCK */
	}

	sendenvelope(e, mode);
	(void) dropenvelope(e, true, true);
	for (ee = splitenv; ee != NULL; ee = ee->e_sibling)
	{
		CurEnv = ee;
		if (mode != SM_VERIFY)
			openxscript(ee);
		sendenvelope(ee, mode);
		(void) dropenvelope(ee, true, true);
	}
	CurEnv = e;

	Verbose = oldverbose;
	if (mode == SM_FORK)
		finis(true, true, ExitStat);
}

static void
sendenvelope(e, mode)
	register ENVELOPE *e;
	int mode;
{
	register ADDRESS *q;
	bool didany;

	if (tTd(13, 10))
		sm_dprintf("sendenvelope(%s) e_flags=0x%lx\n",
			   e->e_id == NULL ? "[NOQUEUE]" : e->e_id,
			   e->e_flags);
	if (LogLevel > 80)
		sm_syslog(LOG_DEBUG, e->e_id,
			  "sendenvelope, flags=0x%lx",
			  e->e_flags);

	/*
	**  If we have had global, fatal errors, don't bother sending
	**  the message at all if we are in SMTP mode.  Local errors
	**  (e.g., a single address failing) will still cause the other
	**  addresses to be sent.
	*/

	if (bitset(EF_FATALERRS, e->e_flags) &&
	    (OpMode == MD_SMTP || OpMode == MD_DAEMON))
	{
		e->e_flags |= EF_CLRQUEUE;
		return;
	}

	/*
	**  Don't attempt deliveries if we want to bounce now
	**  or if deliver-by time is exceeded.
	*/

	if (!bitset(EF_RESPONSE, e->e_flags) &&
	    (TimeOuts.to_q_return[e->e_timeoutclass] == NOW ||
	     (IS_DLVR_RETURN(e) && e->e_deliver_by > 0 &&
	      curtime() > e->e_ctime + e->e_deliver_by)))
		return;

	/*
	**  Run through the list and send everything.
	**
	**	Set EF_GLOBALERRS so that error messages during delivery
	**	result in returned mail.
	*/

	e->e_nsent = 0;
	e->e_flags |= EF_GLOBALERRS;

	macdefine(&e->e_macro, A_PERM, macid("{envid}"), e->e_envid);
	macdefine(&e->e_macro, A_PERM, macid("{bodytype}"), e->e_bodytype);
	didany = false;

	if (!bitset(EF_SPLIT, e->e_flags))
	{
		ENVELOPE *oldsib;
		ENVELOPE *ee;

		/*
		**  Save old sibling and set it to NULL to avoid
		**  queueing up the same envelopes again.
		**  This requires that envelopes in that list have
		**  been take care of before (or at some other place).
		*/

		oldsib = e->e_sibling;
		e->e_sibling = NULL;
		if (!split_by_recipient(e) &&
		    bitset(EF_FATALERRS, e->e_flags))
		{
			if (OpMode == MD_SMTP || OpMode == MD_DAEMON)
				e->e_flags |= EF_CLRQUEUE;
			return;
		}
		for (ee = e->e_sibling; ee != NULL; ee = ee->e_sibling)
			queueup(ee, false, true);

		/* clean up */
		for (ee = e->e_sibling; ee != NULL; ee = ee->e_sibling)
		{
			/* now unlock the job */
			closexscript(ee);
			unlockqueue(ee);

			/* this envelope is marked unused */
			if (ee->e_dfp != NULL)
			{
				(void) sm_io_close(ee->e_dfp, SM_TIME_DEFAULT);
				ee->e_dfp = NULL;
			}
			ee->e_id = NULL;
			ee->e_flags &= ~EF_HAS_DF;
		}
		e->e_sibling = oldsib;
	}

	/* now run through the queue */
	for (q = e->e_sendqueue; q != NULL; q = q->q_next)
	{
#if XDEBUG
		char wbuf[MAXNAME + 20];

		(void) sm_snprintf(wbuf, sizeof(wbuf), "sendall(%.*s)",
				   MAXNAME, q->q_paddr);
		checkfd012(wbuf);
#endif /* XDEBUG */
		if (mode == SM_VERIFY)
		{
			e->e_to = q->q_paddr;
			if (QS_IS_SENDABLE(q->q_state))
			{
				if (q->q_host != NULL && q->q_host[0] != '\0')
					message("deliverable: mailer %s, host %s, user %s",
						q->q_mailer->m_name,
						q->q_host,
						q->q_user);
				else
					message("deliverable: mailer %s, user %s",
						q->q_mailer->m_name,
						q->q_user);
			}
		}
		else if (QS_IS_OK(q->q_state))
		{
			/*
			**  Checkpoint the send list every few addresses
			*/

			if (CheckpointInterval > 0 &&
			    e->e_nsent >= CheckpointInterval)
			{
				queueup(e, false, false);
				e->e_nsent = 0;
			}
			(void) deliver(e, q);
			didany = true;
		}
	}
	if (didany)
	{
		e->e_dtime = curtime();
		e->e_ntries++;
	}

#if XDEBUG
	checkfd012("end of sendenvelope");
#endif /* XDEBUG */
}

#if REQUIRES_DIR_FSYNC
/*
**  SYNC_DIR -- fsync a directory based on a filename
**
**	Parameters:
**		filename -- path of file
**		panic -- panic?
**
**	Returns:
**		none
*/

void
sync_dir(filename, panic)
	char *filename;
	bool panic;
{
	int dirfd;
	char *dirp;
	char dir[MAXPATHLEN];

	if (!RequiresDirfsync)
		return;

	/* filesystems which require the directory be synced */
	dirp = strrchr(filename, '/');
	if (dirp != NULL)
	{
		if (sm_strlcpy(dir, filename, sizeof(dir)) >= sizeof(dir))
			return;
		dir[dirp - filename] = '\0';
		dirp = dir;
	}
	else
		dirp = ".";
	dirfd = open(dirp, O_RDONLY, 0700);
	if (tTd(40,32))
		sm_syslog(LOG_INFO, NOQID, "sync_dir: %s: fsync(%d)",
			  dirp, dirfd);
	if (dirfd >= 0)
	{
		if (fsync(dirfd) < 0)
		{
			if (panic)
				syserr("!sync_dir: cannot fsync directory %s",
				       dirp);
			else if (LogLevel > 1)
				sm_syslog(LOG_ERR, NOQID,
					  "sync_dir: cannot fsync directory %s: %s",
					  dirp, sm_errstring(errno));
		}
		(void) close(dirfd);
	}
}
#endif /* REQUIRES_DIR_FSYNC */
/*
**  DUP_QUEUE_FILE -- duplicate a queue file into a split queue
**
**	Parameters:
**		e -- the existing envelope
**		ee -- the new envelope
**		type -- the queue file type (e.g., DATAFL_LETTER)
**
**	Returns:
**		none
*/

static void
dup_queue_file(e, ee, type)
	ENVELOPE *e, *ee;
	int type;
{
	char f1buf[MAXPATHLEN], f2buf[MAXPATHLEN];

	ee->e_dfp = NULL;
	ee->e_xfp = NULL;

	/*
	**  Make sure both are in the same directory.
	*/

	(void) sm_strlcpy(f1buf, queuename(e, type), sizeof(f1buf));
	(void) sm_strlcpy(f2buf, queuename(ee, type), sizeof(f2buf));

	/* Force the df to disk if it's not there yet */
	if (type == DATAFL_LETTER && e->e_dfp != NULL &&
	    sm_io_setinfo(e->e_dfp, SM_BF_COMMIT, NULL) < 0 &&
	    errno != EINVAL)
	{
		syserr("!dup_queue_file: can't commit %s", f1buf);
		/* NOTREACHED */
	}

	if (link(f1buf, f2buf) < 0)
	{
		int save_errno = errno;

		syserr("sendall: link(%s, %s)", f1buf, f2buf);
		if (save_errno == EEXIST)
		{
			if (unlink(f2buf) < 0)
			{
				syserr("!sendall: unlink(%s): permanent",
				       f2buf);
				/* NOTREACHED */
			}
			if (link(f1buf, f2buf) < 0)
			{
				syserr("!sendall: link(%s, %s): permanent",
				       f1buf, f2buf);
				/* NOTREACHED */
			}
		}
	}
	SYNC_DIR(f2buf, true);
}
/*
**  DOFORK -- do a fork, retrying a couple of times on failure.
**
**	This MUST be a macro, since after a vfork we are running
**	two processes on the same stack!!!
**
**	Parameters:
**		none.
**
**	Returns:
**		From a macro???  You've got to be kidding!
**
**	Side Effects:
**		Modifies the ==> LOCAL <== variable 'pid', leaving:
**			pid of child in parent, zero in child.
**			-1 on unrecoverable error.
**
**	Notes:
**		I'm awfully sorry this looks so awful.  That's
**		vfork for you.....
*/

#define NFORKTRIES	5

#ifndef FORK
# define FORK	fork
#endif /* ! FORK */

#define DOFORK(fORKfN) \
{\
	register int i;\
\
	for (i = NFORKTRIES; --i >= 0; )\
	{\
		pid = fORKfN();\
		if (pid >= 0)\
			break;\
		if (i > 0)\
			(void) sleep((unsigned) NFORKTRIES - i);\
	}\
}
/*
**  DOFORK -- simple fork interface to DOFORK.
**
**	Parameters:
**		none.
**
**	Returns:
**		pid of child in parent.
**		zero in child.
**		-1 on error.
**
**	Side Effects:
**		returns twice, once in parent and once in child.
*/

pid_t
dofork()
{
	register pid_t pid = -1;

	DOFORK(fork);
	return pid;
}

/*
**  COLONCMP -- compare host-signatures up to first ':' or EOS
**
**	This takes two strings which happen to be host-signatures and
**	compares them. If the lowest preference portions of the MX-RR's
**	match (up to ':' or EOS, whichever is first), then we have
**	match. This is used for coattail-piggybacking messages during
**	message delivery.
**	If the signatures are the same up to the first ':' the remainder of
**	the signatures are then compared with a normal strcmp(). This saves
**	re-examining the first part of the signatures.
**
**	Parameters:
**		a - first host-signature
**		b - second host-signature
**
**	Returns:
**		HS_MATCH_NO -- no "match".
**		HS_MATCH_FIRST -- "match" for the first MX preference
**			(up to the first colon (':')).
**		HS_MATCH_FULL -- match for the entire MX record.
**
**	Side Effects:
**		none.
*/

#define HS_MATCH_NO	0
#define HS_MATCH_FIRST	1
#define HS_MATCH_FULL	2

static int
coloncmp(a, b)
	register const char *a;
	register const char *b;
{
	int ret = HS_MATCH_NO;
	int braclev = 0;

	while (*a == *b++)
	{
		/* Need to account for IPv6 bracketed addresses */
		if (*a == '[')
			braclev++;
		else if (*a == ']' && braclev > 0)
			braclev--;
		else if (*a == ':' && braclev <= 0)
		{
			ret = HS_MATCH_FIRST;
			a++;
			break;
		}
		else if (*a == '\0')
			return HS_MATCH_FULL; /* a full match */
		a++;
	}
	if (ret == HS_MATCH_NO &&
	    braclev <= 0 &&
	    ((*a == '\0' && *(b - 1) == ':') ||
	     (*a == ':' && *(b - 1) == '\0')))
		return HS_MATCH_FIRST;
	if (ret == HS_MATCH_FIRST && strcmp(a, b) == 0)
		return HS_MATCH_FULL;

	return ret;
}

/*
**  SHOULD_TRY_FBSH -- Should try FallbackSmartHost?
**
**	Parameters:
**		e -- envelope
**		tried_fallbacksmarthost -- has been tried already? (in/out)
**		hostbuf -- buffer for hostname (expand FallbackSmartHost) (out)
**		hbsz -- size of hostbuf
**		status -- current delivery status
**
**	Returns:
**		true iff FallbackSmartHost should be tried.
*/

static bool should_try_fbsh __P((ENVELOPE *, bool *, char *, size_t, int));

static bool
should_try_fbsh(e, tried_fallbacksmarthost, hostbuf, hbsz, status)
	ENVELOPE *e;
	bool *tried_fallbacksmarthost;
	char *hostbuf;
	size_t hbsz;
	int status;
{
	/*
	**  If the host was not found or a temporary failure occurred
	**  and a FallbackSmartHost is defined (and we have not yet
	**  tried it), then make one last try with it as the host.
	*/

	if ((status == EX_NOHOST || status == EX_TEMPFAIL) &&
	    FallbackSmartHost != NULL && !*tried_fallbacksmarthost)
	{
		*tried_fallbacksmarthost = true;
		expand(FallbackSmartHost, hostbuf, hbsz, e);
		if (!wordinclass(hostbuf, 'w'))
		{
			if (tTd(11, 1))
				sm_dprintf("one last try with FallbackSmartHost %s\n",
					   hostbuf);
			return true;
		}
	}
	return false;
}
/*
**  DELIVER -- Deliver a message to a list of addresses.
**
**	This routine delivers to everyone on the same host as the
**	user on the head of the list.  It is clever about mailers
**	that don't handle multiple users.  It is NOT guaranteed
**	that it will deliver to all these addresses however -- so
**	deliver should be called once for each address on the
**	list.
**	Deliver tries to be as opportunistic as possible about piggybacking
**	messages. Some definitions to make understanding easier follow below.
**	Piggybacking occurs when an existing connection to a mail host can
**	be used to send the same message to more than one recipient at the
**	same time. So "no piggybacking" means one message for one recipient
**	per connection. "Intentional piggybacking" happens when the
**	recipients' host address (not the mail host address) is used to
**	attempt piggybacking. Recipients with the same host address
**	have the same mail host. "Coincidental piggybacking" relies on
**	piggybacking based on all the mail host addresses in the MX-RR. This
**	is "coincidental" in the fact it could not be predicted until the
**	MX Resource Records for the hosts were obtained and examined. For
**	example (preference order and equivalence is important, not values):
**		domain1 IN MX 10 mxhost-A
**			IN MX 20 mxhost-B
**		domain2 IN MX  4 mxhost-A
**			IN MX  8 mxhost-B
**	Domain1 and domain2 can piggyback the same message to mxhost-A or
**	mxhost-B (if mxhost-A cannot be reached).
**	"Coattail piggybacking" relaxes the strictness of "coincidental
**	piggybacking" in the hope that most significant (lowest value)
**	MX preference host(s) can create more piggybacking. For example
**	(again, preference order and equivalence is important, not values):
**		domain3 IN MX 100 mxhost-C
**			IN MX 100 mxhost-D
**			IN MX 200 mxhost-E
**		domain4 IN MX  50 mxhost-C
**			IN MX  50 mxhost-D
**			IN MX  80 mxhost-F
**	A message for domain3 and domain4 can piggyback to mxhost-C if mxhost-C
**	is available. Same with mxhost-D because in both RR's the preference
**	value is the same as mxhost-C, respectively.
**	So deliver attempts coattail piggybacking when possible. If the
**	first MX preference level hosts cannot be used then the piggybacking
**	reverts to coincidental piggybacking. Using the above example you
**	cannot deliver to mxhost-F for domain3 regardless of preference value.
**	("Coattail" from "riding on the coattails of your predecessor" meaning
**	gaining benefit from a predecessor effort with no or little addition
**	effort. The predecessor here being the preceding MX RR).
**
**	Parameters:
**		e -- the envelope to deliver.
**		firstto -- head of the address list to deliver to.
**
**	Returns:
**		zero -- successfully delivered.
**		else -- some failure, see ExitStat for more info.
**
**	Side Effects:
**		The standard input is passed off to someone.
*/

static int
deliver(e, firstto)
	register ENVELOPE *e;
	ADDRESS *firstto;
{
	char *host;			/* host being sent to */
	char *user;			/* user being sent to */
	char **pvp;
	register char **mvp;
	register char *p;
	register MAILER *m;		/* mailer for this recipient */
	ADDRESS *volatile ctladdr;
#if HASSETUSERCONTEXT
	ADDRESS *volatile contextaddr = NULL;
#endif /* HASSETUSERCONTEXT */
	register MCI *volatile mci;
	register ADDRESS *SM_NONVOLATILE to = firstto;
	volatile bool clever = false;	/* running user smtp to this mailer */
	ADDRESS *volatile tochain = NULL; /* users chain in this mailer call */
	int rcode;			/* response code */
	SM_NONVOLATILE int lmtp_rcode = EX_OK;
	SM_NONVOLATILE int nummxhosts = 0; /* number of MX hosts available */
	SM_NONVOLATILE int hostnum = 0;	/* current MX host index */
	char *firstsig;			/* signature of firstto */
	volatile pid_t pid = -1;
	char *volatile curhost;
	SM_NONVOLATILE unsigned short port = 0;
	SM_NONVOLATILE time_t enough = 0;
#if NETUNIX
	char *SM_NONVOLATILE mux_path = NULL;	/* path to UNIX domain socket */
#endif /* NETUNIX */
	time_t xstart;
	bool suidwarn;
	bool anyok;			/* at least one address was OK */
	SM_NONVOLATILE bool goodmxfound = false; /* at least one MX was OK */
	bool ovr;
	bool quarantine;
	int strsize;
	int rcptcount;
	int ret;
	static int tobufsize = 0;
	static char *tobuf = NULL;
	char *rpath;	/* translated return path */
	int mpvect[2];
	int rpvect[2];
	char *mxhosts[MAXMXHOSTS + 1];
	char *pv[MAXPV + 1];
	char buf[MAXNAME + 1];
	char cbuf[MAXPATHLEN];

	errno = 0;
	SM_REQUIRE(firstto != NULL);	/* same as to */
	if (!QS_IS_OK(to->q_state))
		return 0;

	suidwarn = geteuid() == 0;

	SM_REQUIRE(e != NULL);
	m = to->q_mailer;
	host = to->q_host;
	CurEnv = e;			/* just in case */
	e->e_statmsg = NULL;
	SmtpError[0] = '\0';
	xstart = curtime();

	if (tTd(10, 1))
		sm_dprintf("\n--deliver, id=%s, mailer=%s, host=`%s', first user=`%s'\n",
			e->e_id, m->m_name, host, to->q_user);
	if (tTd(10, 100))
		printopenfds(false);

	/*
	**  Clear {client_*} macros if this is a bounce message to
	**  prevent rejection by check_compat ruleset.
	*/

	if (bitset(EF_RESPONSE, e->e_flags))
	{
		macdefine(&e->e_macro, A_PERM, macid("{client_name}"), "");
		macdefine(&e->e_macro, A_PERM, macid("{client_ptr}"), "");
		macdefine(&e->e_macro, A_PERM, macid("{client_addr}"), "");
		macdefine(&e->e_macro, A_PERM, macid("{client_port}"), "");
		macdefine(&e->e_macro, A_PERM, macid("{client_resolve}"), "");
	}

	SM_TRY
	{
	ADDRESS *skip_back = NULL;

	/*
	**  Do initial argv setup.
	**	Insert the mailer name.  Notice that $x expansion is
	**	NOT done on the mailer name.  Then, if the mailer has
	**	a picky -f flag, we insert it as appropriate.  This
	**	code does not check for 'pv' overflow; this places a
	**	manifest lower limit of 4 for MAXPV.
	**		The from address rewrite is expected to make
	**		the address relative to the other end.
	*/

	/* rewrite from address, using rewriting rules */
	rcode = EX_OK;
	SM_ASSERT(e->e_from.q_mailer != NULL);
	if (bitnset(M_UDBENVELOPE, e->e_from.q_mailer->m_flags))
		p = e->e_sender;
	else
		p = e->e_from.q_paddr;
	rpath = remotename(p, m, RF_SENDERADDR|RF_CANONICAL, &rcode, e);
	if (strlen(rpath) > MAXNAME)
	{
		rpath = shortenstring(rpath, MAXSHORTSTR);

		/* avoid bogus errno */
		errno = 0;
		syserr("remotename: huge return path %s", rpath);
	}
	rpath = sm_rpool_strdup_x(e->e_rpool, rpath);
	macdefine(&e->e_macro, A_PERM, 'g', rpath);
	macdefine(&e->e_macro, A_PERM, 'h', host);
	Errors = 0;
	pvp = pv;
	*pvp++ = m->m_argv[0];

	/* ignore long term host status information if mailer flag W is set */
	if (bitnset(M_NOHOSTSTAT, m->m_flags))
		IgnoreHostStatus = true;

	/* insert -f or -r flag as appropriate */
	if (FromFlag &&
	    (bitnset(M_FOPT, m->m_flags) ||
	     bitnset(M_ROPT, m->m_flags)))
	{
		if (bitnset(M_FOPT, m->m_flags))
			*pvp++ = "-f";
		else
			*pvp++ = "-r";
		*pvp++ = rpath;
	}

	/*
	**  Append the other fixed parts of the argv.  These run
	**  up to the first entry containing "$u".  There can only
	**  be one of these, and there are only a few more slots
	**  in the pv after it.
	*/

	for (mvp = m->m_argv; (p = *++mvp) != NULL; )
	{
		/* can't use strchr here because of sign extension problems */
		while (*p != '\0')
		{
			if ((*p++ & 0377) == MACROEXPAND)
			{
				if (*p == 'u')
					break;
			}
		}

		if (*p != '\0')
			break;

		/* this entry is safe -- go ahead and process it */
		expand(*mvp, buf, sizeof(buf), e);
		*pvp++ = sm_rpool_strdup_x(e->e_rpool, buf);
		if (pvp >= &pv[MAXPV - 3])
		{
			syserr("554 5.3.5 Too many parameters to %s before $u",
			       pv[0]);
			rcode = -1;
			goto cleanup;
		}
	}

	/*
	**  If we have no substitution for the user name in the argument
	**  list, we know that we must supply the names otherwise -- and
	**  SMTP is the answer!!
	*/

	if (*mvp == NULL)
	{
		/* running LMTP or SMTP */
		clever = true;
		*pvp = NULL;
	}
	else if (bitnset(M_LMTP, m->m_flags))
	{
		/* not running LMTP */
		sm_syslog(LOG_ERR, NULL,
			  "Warning: mailer %s: LMTP flag (F=z) turned off",
			  m->m_name);
		clrbitn(M_LMTP, m->m_flags);
	}

	/*
	**  At this point *mvp points to the argument with $u.  We
	**  run through our address list and append all the addresses
	**  we can.  If we run out of space, do not fret!  We can
	**  always send another copy later.
	*/

	e->e_to = NULL;
	strsize = 2;
	rcptcount = 0;
	ctladdr = NULL;
	if (firstto->q_signature == NULL)
		firstto->q_signature = hostsignature(firstto->q_mailer,
						     firstto->q_host);
	firstsig = firstto->q_signature;

	for (; to != NULL; to = to->q_next)
	{
		/* avoid sending multiple recipients to dumb mailers */
		if (tochain != NULL && !bitnset(M_MUSER, m->m_flags))
			break;

		/* if already sent or not for this host, don't send */
		if (!QS_IS_OK(to->q_state)) /* already sent; look at next */
			continue;

		/*
		**  Must be same mailer to keep grouping rcpts.
		**  If mailers don't match: continue; sendqueue is not
		**  sorted by mailers, so don't break;
		*/

		if (to->q_mailer != firstto->q_mailer)
			continue;

		if (to->q_signature == NULL) /* for safety */
			to->q_signature = hostsignature(to->q_mailer,
							to->q_host);

		/*
		**  This is for coincidental and tailcoat piggybacking messages
		**  to the same mail host. While the signatures are identical
		**  (that's the MX-RR's are identical) we can do coincidental
		**  piggybacking. We try hard for coattail piggybacking
		**  with the same mail host when the next recipient has the
		**  same host at lowest preference. It may be that this
		**  won't work out, so 'skip_back' is maintained if a backup
		**  to coincidental piggybacking or full signature must happen.
		*/

		ret = firstto == to ? HS_MATCH_FULL :
				      coloncmp(to->q_signature, firstsig);
		if (ret == HS_MATCH_FULL)
			skip_back = to;
		else if (ret == HS_MATCH_NO)
			break;

		if (!clever)
		{
			/* avoid overflowing tobuf */
			strsize += strlen(to->q_paddr) + 1;
			if (strsize > TOBUFSIZE)
				break;
		}

		if (++rcptcount > to->q_mailer->m_maxrcpt)
			break;

		if (tTd(10, 1))
		{
			sm_dprintf("\nsend to ");
			printaddr(sm_debug_file(), to, false);
		}

		/* compute effective uid/gid when sending */
		if (bitnset(M_RUNASRCPT, to->q_mailer->m_flags))
# if HASSETUSERCONTEXT
			contextaddr = ctladdr = getctladdr(to);
# else /* HASSETUSERCONTEXT */
			ctladdr = getctladdr(to);
# endif /* HASSETUSERCONTEXT */

		if (tTd(10, 2))
		{
			sm_dprintf("ctladdr=");
			printaddr(sm_debug_file(), ctladdr, false);
		}

		user = to->q_user;
		e->e_to = to->q_paddr;

		/*
		**  Check to see that these people are allowed to
		**  talk to each other.
		**  Check also for overflow of e_msgsize.
		*/

		if (m->m_maxsize != 0 &&
		    (e->e_msgsize > m->m_maxsize || e->e_msgsize < 0))
		{
			e->e_flags |= EF_NO_BODY_RETN;
			if (bitnset(M_LOCALMAILER, to->q_mailer->m_flags))
				to->q_status = "5.2.3";
			else
				to->q_status = "5.3.4";

			/* set to->q_rstatus = NULL; or to the following? */
			usrerrenh(to->q_status,
				  "552 Message is too large; %ld bytes max",
				  m->m_maxsize);
			markfailure(e, to, NULL, EX_UNAVAILABLE, false);
			giveresponse(EX_UNAVAILABLE, to->q_status, m,
				     NULL, ctladdr, xstart, e, to);
			continue;
		}
		SM_SET_H_ERRNO(0);
		ovr = true;

		/* do config file checking of compatibility */
		quarantine = (e->e_quarmsg != NULL);
		rcode = rscheck("check_compat", e->e_from.q_paddr, to->q_paddr,
				e, RSF_RMCOMM|RSF_COUNT, 3, NULL,
				e->e_id, NULL);
		if (rcode == EX_OK)
		{
			/* do in-code checking if not discarding */
			if (!bitset(EF_DISCARD, e->e_flags))
			{
				rcode = checkcompat(to, e);
				ovr = false;
			}
		}
		if (rcode != EX_OK)
		{
			markfailure(e, to, NULL, rcode, ovr);
			giveresponse(rcode, to->q_status, m,
				     NULL, ctladdr, xstart, e, to);
			continue;
		}
		if (!quarantine && e->e_quarmsg != NULL)
		{
			/*
			**  check_compat or checkcompat() has tried
			**  to quarantine but that isn't supported.
			**  Revert the attempt.
			*/

			e->e_quarmsg = NULL;
			macdefine(&e->e_macro, A_PERM,
				  macid("{quarantine}"), "");
		}
		if (bitset(EF_DISCARD, e->e_flags))
		{
			if (tTd(10, 5))
			{
				sm_dprintf("deliver: discarding recipient ");
				printaddr(sm_debug_file(), to, false);
			}

			/* pretend the message was sent */
			/* XXX should we log something here? */
			to->q_state = QS_DISCARDED;

			/*
			**  Remove discard bit to prevent discard of
			**  future recipients.  This is safe because the
			**  true "global discard" has been handled before
			**  we get here.
			*/

			e->e_flags &= ~EF_DISCARD;
			continue;
		}

		/*
		**  Strip quote bits from names if the mailer is dumb
		**	about them.
		*/

		if (bitnset(M_STRIPQ, m->m_flags))
		{
			stripquotes(user);
			stripquotes(host);
		}

		/*
		**  Strip all leading backslashes if requested and the
		**  next character is alphanumerical (the latter can
		**  probably relaxed a bit, see RFC2821).
		*/

		if (bitnset(M_STRIPBACKSL, m->m_flags) && user[0] == '\\')
			stripbackslash(user);

		/* hack attack -- delivermail compatibility */
		if (m == ProgMailer && *user == '|')
			user++;

		/*
		**  If an error message has already been given, don't
		**	bother to send to this address.
		**
		**	>>>>>>>>>> This clause assumes that the local mailer
		**	>> NOTE >> cannot do any further aliasing; that
		**	>>>>>>>>>> function is subsumed by sendmail.
		*/

		if (!QS_IS_OK(to->q_state))
			continue;

		/*
		**  See if this user name is "special".
		**	If the user name has a slash in it, assume that this
		**	is a file -- send it off without further ado.  Note
		**	that this type of addresses is not processed along
		**	with the others, so we fudge on the To person.
		*/

		if (strcmp(m->m_mailer, "[FILE]") == 0)
		{
			macdefine(&e->e_macro, A_PERM, 'u', user);
			p = to->q_home;
			if (p == NULL && ctladdr != NULL)
				p = ctladdr->q_home;
			macdefine(&e->e_macro, A_PERM, 'z', p);
			expand(m->m_argv[1], buf, sizeof(buf), e);
			if (strlen(buf) > 0)
				rcode = mailfile(buf, m, ctladdr, SFF_CREAT, e);
			else
			{
				syserr("empty filename specification for mailer %s",
				       m->m_name);
				rcode = EX_CONFIG;
			}
			giveresponse(rcode, to->q_status, m, NULL,
				     ctladdr, xstart, e, to);
			markfailure(e, to, NULL, rcode, true);
			e->e_nsent++;
			if (rcode == EX_OK)
			{
				to->q_state = QS_SENT;
				if (bitnset(M_LOCALMAILER, m->m_flags) &&
				    bitset(QPINGONSUCCESS, to->q_flags))
				{
					to->q_flags |= QDELIVERED;
					to->q_status = "2.1.5";
					(void) sm_io_fprintf(e->e_xfp,
							     SM_TIME_DEFAULT,
							     "%s... Successfully delivered\n",
							     to->q_paddr);
				}
			}
			to->q_statdate = curtime();
			markstats(e, to, STATS_NORMAL);
			continue;
		}

		/*
		**  Address is verified -- add this user to mailer
		**  argv, and add it to the print list of recipients.
		*/

		/* link together the chain of recipients */
		to->q_tchain = tochain;
		tochain = to;
		e->e_to = "[CHAIN]";

		macdefine(&e->e_macro, A_PERM, 'u', user);  /* to user */
		p = to->q_home;
		if (p == NULL && ctladdr != NULL)
			p = ctladdr->q_home;
		macdefine(&e->e_macro, A_PERM, 'z', p);  /* user's home */

		/* set the ${dsn_notify} macro if applicable */
		if (bitset(QHASNOTIFY, to->q_flags))
		{
			char notify[MAXLINE];

			notify[0] = '\0';
			if (bitset(QPINGONSUCCESS, to->q_flags))
				(void) sm_strlcat(notify, "SUCCESS,",
						  sizeof(notify));
			if (bitset(QPINGONFAILURE, to->q_flags))
				(void) sm_strlcat(notify, "FAILURE,",
						  sizeof(notify));
			if (bitset(QPINGONDELAY, to->q_flags))
				(void) sm_strlcat(notify, "DELAY,",
						  sizeof(notify));

			/* Set to NEVER or drop trailing comma */
			if (notify[0] == '\0')
				(void) sm_strlcat(notify, "NEVER",
						  sizeof(notify));
			else
				notify[strlen(notify) - 1] = '\0';

			macdefine(&e->e_macro, A_TEMP,
				macid("{dsn_notify}"), notify);
		}
		else
			macdefine(&e->e_macro, A_PERM,
				macid("{dsn_notify}"), NULL);

		/*
		**  Expand out this user into argument list.
		*/

		if (!clever)
		{
			expand(*mvp, buf, sizeof(buf), e);
			*pvp++ = sm_rpool_strdup_x(e->e_rpool, buf);
			if (pvp >= &pv[MAXPV - 2])
			{
				/* allow some space for trailing parms */
				break;
			}
		}
	}

	/* see if any addresses still exist */
	if (tochain == NULL)
	{
		rcode = 0;
		goto cleanup;
	}

	/* print out messages as full list */
	strsize = 1;
	for (to = tochain; to != NULL; to = to->q_tchain)
		strsize += strlen(to->q_paddr) + 1;
	if (strsize < TOBUFSIZE)
		strsize = TOBUFSIZE;
	if (strsize > tobufsize)
	{
		SM_FREE_CLR(tobuf);
		tobuf = sm_pmalloc_x(strsize);
		tobufsize = strsize;
	}
	p = tobuf;
	*p = '\0';
	for (to = tochain; to != NULL; to = to->q_tchain)
	{
		(void) sm_strlcpyn(p, tobufsize - (p - tobuf), 2,
				   ",", to->q_paddr);
		p += strlen(p);
	}
	e->e_to = tobuf + 1;

	/*
	**  Fill out any parameters after the $u parameter.
	*/

	if (!clever)
	{
		while (*++mvp != NULL)
		{
			expand(*mvp, buf, sizeof(buf), e);
			*pvp++ = sm_rpool_strdup_x(e->e_rpool, buf);
			if (pvp >= &pv[MAXPV])
				syserr("554 5.3.0 deliver: pv overflow after $u for %s",
				       pv[0]);
		}
	}
	*pvp++ = NULL;

	/*
	**  Call the mailer.
	**	The argument vector gets built, pipes
	**	are created as necessary, and we fork & exec as
	**	appropriate.
	**	If we are running SMTP, we just need to clean up.
	*/

	/* XXX this seems a bit weird */
	if (ctladdr == NULL && m != ProgMailer && m != FileMailer &&
	    bitset(QGOODUID, e->e_from.q_flags))
		ctladdr = &e->e_from;

#if NAMED_BIND
	if (ConfigLevel < 2)
		_res.options &= ~(RES_DEFNAMES | RES_DNSRCH);	/* XXX */
#endif /* NAMED_BIND */

	if (tTd(11, 1))
	{
		sm_dprintf("openmailer:");
		printav(sm_debug_file(), pv);
	}
	errno = 0;
	SM_SET_H_ERRNO(0);
	CurHostName = NULL;

	/*
	**  Deal with the special case of mail handled through an IPC
	**  connection.
	**	In this case we don't actually fork.  We must be
	**	running SMTP for this to work.  We will return a
	**	zero pid to indicate that we are running IPC.
	**  We also handle a debug version that just talks to stdin/out.
	*/

	curhost = NULL;
	SmtpPhase = NULL;
	mci = NULL;

#if XDEBUG
	{
		char wbuf[MAXLINE];

		/* make absolutely certain 0, 1, and 2 are in use */
		(void) sm_snprintf(wbuf, sizeof(wbuf), "%s... openmailer(%s)",
				   shortenstring(e->e_to, MAXSHORTSTR),
				   m->m_name);
		checkfd012(wbuf);
	}
#endif /* XDEBUG */

	/* check for 8-bit available */
	if (bitset(EF_HAS8BIT, e->e_flags) &&
	    bitnset(M_7BITS, m->m_flags) &&
	    (bitset(EF_DONT_MIME, e->e_flags) ||
	     !(bitset(MM_MIME8BIT, MimeMode) ||
	       (bitset(EF_IS_MIME, e->e_flags) &&
		bitset(MM_CVTMIME, MimeMode)))))
	{
		e->e_status = "5.6.3";
		usrerrenh(e->e_status,
			  "554 Cannot send 8-bit data to 7-bit destination");
		rcode = EX_DATAERR;
		goto give_up;
	}

	if (tTd(62, 8))
		checkfds("before delivery");

	/* check for Local Person Communication -- not for mortals!!! */
	if (strcmp(m->m_mailer, "[LPC]") == 0)
	{
		if (clever)
		{
			/* flush any expired connections */
			(void) mci_scan(NULL);

			/* try to get a cached connection or just a slot */
			mci = mci_get(m->m_name, m);
			if (mci->mci_host == NULL)
				mci->mci_host = m->m_name;
			CurHostName = mci->mci_host;
			if (mci->mci_state != MCIS_CLOSED)
			{
				message("Using cached SMTP/LPC connection for %s...",
					m->m_name);
				mci->mci_deliveries++;
				goto do_transfer;
			}
		}
		else
		{
			mci = mci_new(e->e_rpool);
		}
		mci->mci_in = smioin;
		mci->mci_out = smioout;
		mci->mci_mailer = m;
		mci->mci_host = m->m_name;
		if (clever)
		{
			mci->mci_state = MCIS_OPENING;
			mci_cache(mci);
		}
		else
			mci->mci_state = MCIS_OPEN;
	}
	else if (strcmp(m->m_mailer, "[IPC]") == 0)
	{
		register int i;

		if (pv[0] == NULL || pv[1] == NULL || pv[1][0] == '\0')
		{
			syserr("null destination for %s mailer", m->m_mailer);
			rcode = EX_CONFIG;
			goto give_up;
		}

# if NETUNIX
		if (strcmp(pv[0], "FILE") == 0)
		{
			curhost = CurHostName = "localhost";
			mux_path = pv[1];
		}
		else
# endif /* NETUNIX */
		{
			CurHostName = pv[1];
			curhost = hostsignature(m, pv[1]);
		}

		if (curhost == NULL || curhost[0] == '\0')
		{
			syserr("null host signature for %s", pv[1]);
			rcode = EX_CONFIG;
			goto give_up;
		}

		if (!clever)
		{
			syserr("554 5.3.5 non-clever IPC");
			rcode = EX_CONFIG;
			goto give_up;
		}
		if (pv[2] != NULL
# if NETUNIX
		    && mux_path == NULL
# endif /* NETUNIX */
		    )
		{
			port = htons((unsigned short) atoi(pv[2]));
			if (port == 0)
			{
# ifdef NO_GETSERVBYNAME
				syserr("Invalid port number: %s", pv[2]);
# else /* NO_GETSERVBYNAME */
				struct servent *sp = getservbyname(pv[2], "tcp");

				if (sp == NULL)
					syserr("Service %s unknown", pv[2]);
				else
					port = sp->s_port;
# endif /* NO_GETSERVBYNAME */
			}
		}

		nummxhosts = parse_hostsignature(curhost, mxhosts, m);
		if (TimeOuts.to_aconnect > 0)
			enough = curtime() + TimeOuts.to_aconnect;
tryhost:
		while (hostnum < nummxhosts)
		{
			char sep = ':';
			char *endp;
			static char hostbuf[MAXNAME + 1];
			bool tried_fallbacksmarthost = false;

# if NETINET6
			if (*mxhosts[hostnum] == '[')
			{
				endp = strchr(mxhosts[hostnum] + 1, ']');
				if (endp != NULL)
					endp = strpbrk(endp + 1, ":,");
			}
			else
				endp = strpbrk(mxhosts[hostnum], ":,");
# else /* NETINET6 */
			endp = strpbrk(mxhosts[hostnum], ":,");
# endif /* NETINET6 */
			if (endp != NULL)
			{
				sep = *endp;
				*endp = '\0';
			}

			if (hostnum == 1 && skip_back != NULL)
			{
				/*
				**  Coattail piggybacking is no longer an
				**  option with the mail host next to be tried
				**  no longer the lowest MX preference
				**  (hostnum == 1 meaning we're on the second
				**  preference). We do not try to coattail
				**  piggyback more than the first MX preference.
				**  Revert 'tochain' to last location for
				**  coincidental piggybacking. This works this
				**  easily because the q_tchain kept getting
				**  added to the top of the linked list.
				*/

				tochain = skip_back;
			}

			if (*mxhosts[hostnum] == '\0')
			{
				syserr("deliver: null host name in signature");
				hostnum++;
				if (endp != NULL)
					*endp = sep;
				continue;
			}
			(void) sm_strlcpy(hostbuf, mxhosts[hostnum],
					  sizeof(hostbuf));
			hostnum++;
			if (endp != NULL)
				*endp = sep;

  one_last_try:
			/* see if we already know that this host is fried */
			CurHostName = hostbuf;
			mci = mci_get(hostbuf, m);
			if (mci->mci_state != MCIS_CLOSED)
			{
				char *type;

				if (tTd(11, 1))
				{
					sm_dprintf("openmailer: ");
					mci_dump(sm_debug_file(), mci, false);
				}
				CurHostName = mci->mci_host;
				if (bitnset(M_LMTP, m->m_flags))
					type = "L";
				else if (bitset(MCIF_ESMTP, mci->mci_flags))
					type = "ES";
				else
					type = "S";
				message("Using cached %sMTP connection to %s via %s...",
					type, hostbuf, m->m_name);
				mci->mci_deliveries++;
				break;
			}
			mci->mci_mailer = m;
			if (mci->mci_exitstat != EX_OK)
			{
				if (mci->mci_exitstat == EX_TEMPFAIL)
					goodmxfound = true;

				/* Try FallbackSmartHost? */
				if (should_try_fbsh(e, &tried_fallbacksmarthost,
						    hostbuf, sizeof(hostbuf),
						    mci->mci_exitstat))
					goto one_last_try;

				continue;
			}

			if (mci_lock_host(mci) != EX_OK)
			{
				mci_setstat(mci, EX_TEMPFAIL, "4.4.5", NULL);
				goodmxfound = true;
				continue;
			}

			/* try the connection */
			sm_setproctitle(true, e, "%s %s: %s",
					qid_printname(e),
					hostbuf, "user open");
# if NETUNIX
			if (mux_path != NULL)
			{
				message("Connecting to %s via %s...",
					mux_path, m->m_name);
				i = makeconnection_ds((char *) mux_path, mci);
			}
			else
# endif /* NETUNIX */
			{
				if (port == 0)
					message("Connecting to %s via %s...",
						hostbuf, m->m_name);
				else
					message("Connecting to %s port %d via %s...",
						hostbuf, ntohs(port),
						m->m_name);
				i = makeconnection(hostbuf, port, mci, e,
						   enough);
			}
			mci->mci_errno = errno;
			mci->mci_lastuse = curtime();
			mci->mci_deliveries = 0;
			mci->mci_exitstat = i;
			mci_clr_extensions(mci);
# if NAMED_BIND
			mci->mci_herrno = h_errno;
# endif /* NAMED_BIND */

			/*
			**  Have we tried long enough to get a connection?
			**	If yes, skip to the fallback MX hosts
			**	(if existent).
			*/

			if (enough > 0 && mci->mci_lastuse >= enough)
			{
				int h;
# if NAMED_BIND
				extern int NumFallbackMXHosts;
# else /* NAMED_BIND */
				const int NumFallbackMXHosts = 0;
# endif /* NAMED_BIND */

				if (hostnum < nummxhosts && LogLevel > 9)
					sm_syslog(LOG_INFO, e->e_id,
						  "Timeout.to_aconnect occurred before exhausting all addresses");

				/* turn off timeout if fallback available */
				if (NumFallbackMXHosts > 0)
					enough = 0;

				/* skip to a fallback MX host */
				h = nummxhosts - NumFallbackMXHosts;
				if (hostnum < h)
					hostnum = h;
			}
			if (i == EX_OK)
			{
				goodmxfound = true;
				markstats(e, firstto, STATS_CONNECT);
				mci->mci_state = MCIS_OPENING;
				mci_cache(mci);
				if (TrafficLogFile != NULL)
					(void) sm_io_fprintf(TrafficLogFile,
							     SM_TIME_DEFAULT,
							     "%05d === CONNECT %s\n",
							     (int) CurrentPid,
							     hostbuf);
				break;
			}
			else
			{
				/* Try FallbackSmartHost? */
				if (should_try_fbsh(e, &tried_fallbacksmarthost,
						    hostbuf, sizeof(hostbuf), i))
					goto one_last_try;

				if (tTd(11, 1))
					sm_dprintf("openmailer: makeconnection => stat=%d, errno=%d\n",
						   i, errno);
				if (i == EX_TEMPFAIL)
					goodmxfound = true;
				mci_unlock_host(mci);
			}

			/* enter status of this host */
			setstat(i);

			/* should print some message here for -v mode */
		}
		if (mci == NULL)
		{
			syserr("deliver: no host name");
			rcode = EX_SOFTWARE;
			goto give_up;
		}
		mci->mci_pid = 0;
	}
	else
	{
		/* flush any expired connections */
		(void) mci_scan(NULL);
		mci = NULL;

		if (bitnset(M_LMTP, m->m_flags))
		{
			/* try to get a cached connection */
			mci = mci_get(m->m_name, m);
			if (mci->mci_host == NULL)
				mci->mci_host = m->m_name;
			CurHostName = mci->mci_host;
			if (mci->mci_state != MCIS_CLOSED)
			{
				message("Using cached LMTP connection for %s...",
					m->m_name);
				mci->mci_deliveries++;
				goto do_transfer;
			}
		}

		/* announce the connection to verbose listeners */
		if (host == NULL || host[0] == '\0')
			message("Connecting to %s...", m->m_name);
		else
			message("Connecting to %s via %s...", host, m->m_name);
		if (TrafficLogFile != NULL)
		{
			char **av;

			(void) sm_io_fprintf(TrafficLogFile, SM_TIME_DEFAULT,
					     "%05d === EXEC", (int) CurrentPid);
			for (av = pv; *av != NULL; av++)
				(void) sm_io_fprintf(TrafficLogFile,
						     SM_TIME_DEFAULT, " %s",
						     *av);
			(void) sm_io_fprintf(TrafficLogFile, SM_TIME_DEFAULT,
					     "\n");
		}

#if XDEBUG
		checkfd012("before creating mail pipe");
#endif /* XDEBUG */

		/* create a pipe to shove the mail through */
		if (pipe(mpvect) < 0)
		{
			syserr("%s... openmailer(%s): pipe (to mailer)",
			       shortenstring(e->e_to, MAXSHORTSTR), m->m_name);
			if (tTd(11, 1))
				sm_dprintf("openmailer: NULL\n");
			rcode = EX_OSERR;
			goto give_up;
		}

#if XDEBUG
		/* make sure we didn't get one of the standard I/O files */
		if (mpvect[0] < 3 || mpvect[1] < 3)
		{
			syserr("%s... openmailer(%s): bogus mpvect %d %d",
			       shortenstring(e->e_to, MAXSHORTSTR), m->m_name,
			       mpvect[0], mpvect[1]);
			printopenfds(true);
			if (tTd(11, 1))
				sm_dprintf("openmailer: NULL\n");
			rcode = EX_OSERR;
			goto give_up;
		}

		/* make sure system call isn't dead meat */
		checkfdopen(mpvect[0], "mpvect[0]");
		checkfdopen(mpvect[1], "mpvect[1]");
		if (mpvect[0] == mpvect[1] ||
		    (e->e_lockfp != NULL &&
		     (mpvect[0] == sm_io_getinfo(e->e_lockfp, SM_IO_WHAT_FD,
						 NULL) ||
		      mpvect[1] == sm_io_getinfo(e->e_lockfp, SM_IO_WHAT_FD,
						 NULL))))
		{
			if (e->e_lockfp == NULL)
				syserr("%s... openmailer(%s): overlapping mpvect %d %d",
				       shortenstring(e->e_to, MAXSHORTSTR),
				       m->m_name, mpvect[0], mpvect[1]);
			else
				syserr("%s... openmailer(%s): overlapping mpvect %d %d, lockfp = %d",
				       shortenstring(e->e_to, MAXSHORTSTR),
				       m->m_name, mpvect[0], mpvect[1],
				       sm_io_getinfo(e->e_lockfp,
						     SM_IO_WHAT_FD, NULL));
		}
#endif /* XDEBUG */

		/* create a return pipe */
		if (pipe(rpvect) < 0)
		{
			syserr("%s... openmailer(%s): pipe (from mailer)",
			       shortenstring(e->e_to, MAXSHORTSTR),
			       m->m_name);
			(void) close(mpvect[0]);
			(void) close(mpvect[1]);
			if (tTd(11, 1))
				sm_dprintf("openmailer: NULL\n");
			rcode = EX_OSERR;
			goto give_up;
		}
#if XDEBUG
		checkfdopen(rpvect[0], "rpvect[0]");
		checkfdopen(rpvect[1], "rpvect[1]");
#endif /* XDEBUG */

		/*
		**  Actually fork the mailer process.
		**	DOFORK is clever about retrying.
		**
		**	Dispose of SIGCHLD signal catchers that may be laying
		**	around so that endmailer will get it.
		*/

		if (e->e_xfp != NULL)	/* for debugging */
			(void) sm_io_flush(e->e_xfp, SM_TIME_DEFAULT);
		(void) sm_io_flush(smioout, SM_TIME_DEFAULT);
		(void) sm_signal(SIGCHLD, SIG_DFL);


		DOFORK(FORK);
		/* pid is set by DOFORK */

		if (pid < 0)
		{
			/* failure */
			syserr("%s... openmailer(%s): cannot fork",
			       shortenstring(e->e_to, MAXSHORTSTR), m->m_name);
			(void) close(mpvect[0]);
			(void) close(mpvect[1]);
			(void) close(rpvect[0]);
			(void) close(rpvect[1]);
			if (tTd(11, 1))
				sm_dprintf("openmailer: NULL\n");
			rcode = EX_OSERR;
			goto give_up;
		}
		else if (pid == 0)
		{
			int save_errno;
			int sff;
			int new_euid = NO_UID;
			int new_ruid = NO_UID;
			int new_gid = NO_GID;
			char *user = NULL;
			struct stat stb;
			extern int DtableSize;

			CurrentPid = getpid();

			/* clear the events to turn off SIGALRMs */
			sm_clear_events();

			/* Reset global flags */
			RestartRequest = NULL;
			RestartWorkGroup = false;
			ShutdownRequest = NULL;
			PendingSignal = 0;

			if (e->e_lockfp != NULL)
				(void) close(sm_io_getinfo(e->e_lockfp,
							   SM_IO_WHAT_FD,
							   NULL));

			/* child -- set up input & exec mailer */
			(void) sm_signal(SIGALRM, sm_signal_noop);
			(void) sm_signal(SIGCHLD, SIG_DFL);
			(void) sm_signal(SIGHUP, SIG_IGN);
			(void) sm_signal(SIGINT, SIG_IGN);
			(void) sm_signal(SIGTERM, SIG_DFL);
# ifdef SIGUSR1
			(void) sm_signal(SIGUSR1, sm_signal_noop);
# endif /* SIGUSR1 */

			if (m != FileMailer || stat(tochain->q_user, &stb) < 0)
				stb.st_mode = 0;

# if HASSETUSERCONTEXT
			/*
			**  Set user resources.
			*/

			if (contextaddr != NULL)
			{
				int sucflags;
				struct passwd *pwd;

				if (contextaddr->q_ruser != NULL)
					pwd = sm_getpwnam(contextaddr->q_ruser);
				else
					pwd = sm_getpwnam(contextaddr->q_user);
				sucflags = LOGIN_SETRESOURCES|LOGIN_SETPRIORITY;
#ifdef LOGIN_SETCPUMASK
				sucflags |= LOGIN_SETCPUMASK;
#endif /* LOGIN_SETCPUMASK */
#ifdef LOGIN_SETLOGINCLASS
				sucflags |= LOGIN_SETLOGINCLASS;
#endif /* LOGIN_SETLOGINCLASS */
#ifdef LOGIN_SETMAC
				sucflags |= LOGIN_SETMAC;
#endif /* LOGIN_SETMAC */
				if (pwd != NULL &&
				    setusercontext(NULL, pwd, pwd->pw_uid,
						   sucflags) == -1 &&
				    suidwarn)
				{
					syserr("openmailer: setusercontext() failed");
					exit(EX_TEMPFAIL);
				}
			}
# endif /* HASSETUSERCONTEXT */

#if HASNICE
			/* tweak niceness */
			if (m->m_nice != 0)
				(void) nice(m->m_nice);
#endif /* HASNICE */

			/* reset group id */
			if (bitnset(M_SPECIFIC_UID, m->m_flags))
			{
				if (m->m_gid == NO_GID)
					new_gid = RunAsGid;
				else
					new_gid = m->m_gid;
			}
			else if (bitset(S_ISGID, stb.st_mode))
				new_gid = stb.st_gid;
			else if (ctladdr != NULL && ctladdr->q_gid != 0)
			{
				if (!DontInitGroups)
				{
					user = ctladdr->q_ruser;
					if (user == NULL)
						user = ctladdr->q_user;

					if (initgroups(user,
						       ctladdr->q_gid) == -1
					    && suidwarn)
					{
						syserr("openmailer: initgroups(%s, %d) failed",
							user, ctladdr->q_gid);
						exit(EX_TEMPFAIL);
					}
				}
				else
				{
					GIDSET_T gidset[1];

					gidset[0] = ctladdr->q_gid;
					if (setgroups(1, gidset) == -1
					    && suidwarn)
					{
						syserr("openmailer: setgroups() failed");
						exit(EX_TEMPFAIL);
					}
				}
				new_gid = ctladdr->q_gid;
			}
			else
			{
				if (!DontInitGroups)
				{
					user = DefUser;
					if (initgroups(DefUser, DefGid) == -1 &&
					    suidwarn)
					{
						syserr("openmailer: initgroups(%s, %d) failed",
						       DefUser, DefGid);
						exit(EX_TEMPFAIL);
					}
				}
				else
				{
					GIDSET_T gidset[1];

					gidset[0] = DefGid;
					if (setgroups(1, gidset) == -1
					    && suidwarn)
					{
						syserr("openmailer: setgroups() failed");
						exit(EX_TEMPFAIL);
					}
				}
				if (m->m_gid == NO_GID)
					new_gid = DefGid;
				else
					new_gid = m->m_gid;
			}
			if (new_gid != NO_GID)
			{
				if (RunAsUid != 0 &&
				    bitnset(M_SPECIFIC_UID, m->m_flags) &&
				    new_gid != getgid() &&
				    new_gid != getegid())
				{
					/* Only root can change the gid */
					syserr("openmailer: insufficient privileges to change gid, RunAsUid=%d, new_gid=%d, gid=%d, egid=%d",
					       (int) RunAsUid, (int) new_gid,
					       (int) getgid(), (int) getegid());
					exit(EX_TEMPFAIL);
				}

				if (setgid(new_gid) < 0 && suidwarn)
				{
					syserr("openmailer: setgid(%ld) failed",
					       (long) new_gid);
					exit(EX_TEMPFAIL);
				}
			}

			/* change root to some "safe" directory */
			if (m->m_rootdir != NULL)
			{
				expand(m->m_rootdir, cbuf, sizeof(cbuf), e);
				if (tTd(11, 20))
					sm_dprintf("openmailer: chroot %s\n",
						   cbuf);
				if (chroot(cbuf) < 0)
				{
					syserr("openmailer: Cannot chroot(%s)",
					       cbuf);
					exit(EX_TEMPFAIL);
				}
				if (chdir("/") < 0)
				{
					syserr("openmailer: cannot chdir(/)");
					exit(EX_TEMPFAIL);
				}
			}

			/* reset user id */
			endpwent();
			sm_mbdb_terminate();
			if (bitnset(M_SPECIFIC_UID, m->m_flags))
			{
				if (m->m_uid == NO_UID)
					new_euid = RunAsUid;
				else
					new_euid = m->m_uid;

				/*
				**  Undo the effects of the uid change in main
				**  for signal handling.  The real uid may
				**  be used by mailer in adding a "From "
				**  line.
				*/

				if (RealUid != 0 && RealUid != getuid())
				{
# if MAILER_SETUID_METHOD == USE_SETEUID
#  if HASSETREUID
					if (setreuid(RealUid, geteuid()) < 0)
					{
						syserr("openmailer: setreuid(%d, %d) failed",
						       (int) RealUid, (int) geteuid());
						exit(EX_OSERR);
					}
#  endif /* HASSETREUID */
# endif /* MAILER_SETUID_METHOD == USE_SETEUID */
# if MAILER_SETUID_METHOD == USE_SETREUID
					new_ruid = RealUid;
# endif /* MAILER_SETUID_METHOD == USE_SETREUID */
				}
			}
			else if (bitset(S_ISUID, stb.st_mode))
				new_ruid = stb.st_uid;
			else if (ctladdr != NULL && ctladdr->q_uid != 0)
				new_ruid = ctladdr->q_uid;
			else if (m->m_uid != NO_UID)
				new_ruid = m->m_uid;
			else
				new_ruid = DefUid;

# if _FFR_USE_SETLOGIN
			/* run disconnected from terminal and set login name */
			if (setsid() >= 0 &&
			    ctladdr != NULL && ctladdr->q_uid != 0 &&
			    new_euid == ctladdr->q_uid)
			{
				struct passwd *pwd;

				pwd = sm_getpwuid(ctladdr->q_uid);
				if (pwd != NULL && suidwarn)
					(void) setlogin(pwd->pw_name);
				endpwent();
			}
# endif /* _FFR_USE_SETLOGIN */

			if (new_euid != NO_UID)
			{
				if (RunAsUid != 0 && new_euid != RunAsUid)
				{
					/* Only root can change the uid */
					syserr("openmailer: insufficient privileges to change uid, new_euid=%d, RunAsUid=%d",
					       (int) new_euid, (int) RunAsUid);
					exit(EX_TEMPFAIL);
				}

				vendor_set_uid(new_euid);
# if MAILER_SETUID_METHOD == USE_SETEUID
				if (seteuid(new_euid) < 0 && suidwarn)
				{
					syserr("openmailer: seteuid(%ld) failed",
					       (long) new_euid);
					exit(EX_TEMPFAIL);
				}
# endif /* MAILER_SETUID_METHOD == USE_SETEUID */
# if MAILER_SETUID_METHOD == USE_SETREUID
				if (setreuid(new_ruid, new_euid) < 0 && suidwarn)
				{
					syserr("openmailer: setreuid(%ld, %ld) failed",
					       (long) new_ruid, (long) new_euid);
					exit(EX_TEMPFAIL);
				}
# endif /* MAILER_SETUID_METHOD == USE_SETREUID */
# if MAILER_SETUID_METHOD == USE_SETUID
				if (new_euid != geteuid() && setuid(new_euid) < 0 && suidwarn)
				{
					syserr("openmailer: setuid(%ld) failed",
					       (long) new_euid);
					exit(EX_TEMPFAIL);
				}
# endif /* MAILER_SETUID_METHOD == USE_SETUID */
			}
			else if (new_ruid != NO_UID)
			{
				vendor_set_uid(new_ruid);
				if (setuid(new_ruid) < 0 && suidwarn)
				{
					syserr("openmailer: setuid(%ld) failed",
					       (long) new_ruid);
					exit(EX_TEMPFAIL);
				}
			}

			if (tTd(11, 2))
				sm_dprintf("openmailer: running as r/euid=%d/%d, r/egid=%d/%d\n",
					   (int) getuid(), (int) geteuid(),
					   (int) getgid(), (int) getegid());

			/* move into some "safe" directory */
			if (m->m_execdir != NULL)
			{
				char *q;

				for (p = m->m_execdir; p != NULL; p = q)
				{
					q = strchr(p, ':');
					if (q != NULL)
						*q = '\0';
					expand(p, cbuf, sizeof(cbuf), e);
					if (q != NULL)
						*q++ = ':';
					if (tTd(11, 20))
						sm_dprintf("openmailer: trydir %s\n",
							   cbuf);
					if (cbuf[0] != '\0' &&
					    chdir(cbuf) >= 0)
						break;
				}
			}

			/* Check safety of program to be run */
			sff = SFF_ROOTOK|SFF_EXECOK;
			if (!bitnset(DBS_RUNWRITABLEPROGRAM,
				     DontBlameSendmail))
				sff |= SFF_NOGWFILES|SFF_NOWWFILES;
			if (bitnset(DBS_RUNPROGRAMINUNSAFEDIRPATH,
				    DontBlameSendmail))
				sff |= SFF_NOPATHCHECK;
			else
				sff |= SFF_SAFEDIRPATH;
			ret = safefile(m->m_mailer, getuid(), getgid(),
				       user, sff, 0, NULL);
			if (ret != 0)
				sm_syslog(LOG_INFO, e->e_id,
					  "Warning: program %s unsafe: %s",
					  m->m_mailer, sm_errstring(ret));

			/* arrange to filter std & diag output of command */
			(void) close(rpvect[0]);
			if (dup2(rpvect[1], STDOUT_FILENO) < 0)
			{
				syserr("%s... openmailer(%s): cannot dup pipe %d for stdout",
				       shortenstring(e->e_to, MAXSHORTSTR),
				       m->m_name, rpvect[1]);
				_exit(EX_OSERR);
			}
			(void) close(rpvect[1]);

			if (dup2(STDOUT_FILENO, STDERR_FILENO) < 0)
			{
				syserr("%s... openmailer(%s): cannot dup stdout for stderr",
				       shortenstring(e->e_to, MAXSHORTSTR),
				       m->m_name);
				_exit(EX_OSERR);
			}

			/* arrange to get standard input */
			(void) close(mpvect[1]);
			if (dup2(mpvect[0], STDIN_FILENO) < 0)
			{
				syserr("%s... openmailer(%s): cannot dup pipe %d for stdin",
				       shortenstring(e->e_to, MAXSHORTSTR),
				       m->m_name, mpvect[0]);
				_exit(EX_OSERR);
			}
			(void) close(mpvect[0]);

			/* arrange for all the files to be closed */
			sm_close_on_exec(STDERR_FILENO + 1, DtableSize);

# if !_FFR_USE_SETLOGIN
			/* run disconnected from terminal */
			(void) setsid();
# endif /* !_FFR_USE_SETLOGIN */

			/* try to execute the mailer */
			(void) execve(m->m_mailer, (ARGV_T) pv,
				      (ARGV_T) UserEnviron);
			save_errno = errno;
			syserr("Cannot exec %s", m->m_mailer);
			if (bitnset(M_LOCALMAILER, m->m_flags) ||
			    transienterror(save_errno))
				_exit(EX_OSERR);
			_exit(EX_UNAVAILABLE);
		}

		/*
		**  Set up return value.
		*/

		if (mci == NULL)
		{
			if (clever)
			{
				/*
				**  Allocate from general heap, not
				**  envelope rpool, because this mci
				**  is going to be cached.
				*/

				mci = mci_new(NULL);
			}
			else
			{
				/*
				**  Prevent a storage leak by allocating
				**  this from the envelope rpool.
				*/

				mci = mci_new(e->e_rpool);
			}
		}
		mci->mci_mailer = m;
		if (clever)
		{
			mci->mci_state = MCIS_OPENING;
			mci_cache(mci);
		}
		else
		{
			mci->mci_state = MCIS_OPEN;
		}
		mci->mci_pid = pid;
		(void) close(mpvect[0]);
		mci->mci_out = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT,
					  (void *) &(mpvect[1]), SM_IO_WRONLY_B,
					  NULL);
		if (mci->mci_out == NULL)
		{
			syserr("deliver: cannot create mailer output channel, fd=%d",
			       mpvect[1]);
			(void) close(mpvect[1]);
			(void) close(rpvect[0]);
			(void) close(rpvect[1]);
			rcode = EX_OSERR;
			goto give_up;
		}

		(void) close(rpvect[1]);
		mci->mci_in = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT,
					 (void *) &(rpvect[0]), SM_IO_RDONLY_B,
					 NULL);
		if (mci->mci_in == NULL)
		{
			syserr("deliver: cannot create mailer input channel, fd=%d",
			       mpvect[1]);
			(void) close(rpvect[0]);
			(void) sm_io_close(mci->mci_out, SM_TIME_DEFAULT);
			mci->mci_out = NULL;
			rcode = EX_OSERR;
			goto give_up;
		}
	}

	/*
	**  If we are in SMTP opening state, send initial protocol.
	*/

	if (bitnset(M_7BITS, m->m_flags) &&
	    (!clever || mci->mci_state == MCIS_OPENING))
		mci->mci_flags |= MCIF_7BIT;
	if (clever && mci->mci_state != MCIS_CLOSED)
	{
# if STARTTLS || SASL
		int dotpos;
		char *srvname;
		extern SOCKADDR CurHostAddr;
# endif /* STARTTLS || SASL */

# if SASL
#  define DONE_AUTH(f)		bitset(MCIF_AUTHACT, f)
# endif /* SASL */
# if STARTTLS
#  define DONE_STARTTLS(f)	bitset(MCIF_TLSACT, f)
# endif /* STARTTLS */
# define ONLY_HELO(f)		bitset(MCIF_ONLY_EHLO, f)
# define SET_HELO(f)		f |= MCIF_ONLY_EHLO
# define CLR_HELO(f)		f &= ~MCIF_ONLY_EHLO

# if STARTTLS || SASL
		/* don't use CurHostName, it is changed in many places */
		if (mci->mci_host != NULL)
		{
			srvname = mci->mci_host;
			dotpos = strlen(srvname) - 1;
			if (dotpos >= 0)
			{
				if (srvname[dotpos] == '.')
					srvname[dotpos] = '\0';
				else
					dotpos = -1;
			}
		}
		else if (mci->mci_mailer != NULL)
		{
			srvname = mci->mci_mailer->m_name;
			dotpos = -1;
		}
		else
		{
			srvname = "local";
			dotpos = -1;
		}

		/* don't set {server_name} to NULL or "": see getauth() */
		macdefine(&mci->mci_macro, A_TEMP, macid("{server_name}"),
			  srvname);

		/* CurHostAddr is set by makeconnection() and mci_get() */
		if (CurHostAddr.sa.sa_family != 0)
		{
			macdefine(&mci->mci_macro, A_TEMP,
				  macid("{server_addr}"),
				  anynet_ntoa(&CurHostAddr));
		}
		else if (mci->mci_mailer != NULL)
		{
			/* mailer name is unique, use it as address */
			macdefine(&mci->mci_macro, A_PERM,
				  macid("{server_addr}"),
				  mci->mci_mailer->m_name);
		}
		else
		{
			/* don't set it to NULL or "": see getauth() */
			macdefine(&mci->mci_macro, A_PERM,
				  macid("{server_addr}"), "0");
		}

		/* undo change of srvname (mci->mci_host) */
		if (dotpos >= 0)
			srvname[dotpos] = '.';

reconnect:	/* after switching to an encrypted connection */
# endif /* STARTTLS || SASL */

		/* set the current connection information */
		e->e_mci = mci;
# if SASL
		mci->mci_saslcap = NULL;
# endif /* SASL */
		smtpinit(m, mci, e, ONLY_HELO(mci->mci_flags));
		CLR_HELO(mci->mci_flags);

		if (IS_DLVR_RETURN(e))
		{
			/*
			**  Check whether other side can deliver e-mail
			**  fast enough
			*/

			if (!bitset(MCIF_DLVR_BY, mci->mci_flags))
			{
				e->e_status = "5.4.7";
				usrerrenh(e->e_status,
					  "554 Server does not support Deliver By");
				rcode = EX_UNAVAILABLE;
				goto give_up;
			}
			if (e->e_deliver_by > 0 &&
			    e->e_deliver_by - (curtime() - e->e_ctime) <
			    mci->mci_min_by)
			{
				e->e_status = "5.4.7";
				usrerrenh(e->e_status,
					  "554 Message can't be delivered in time; %ld < %ld",
					  e->e_deliver_by - (curtime() - e->e_ctime),
					  mci->mci_min_by);
				rcode = EX_UNAVAILABLE;
				goto give_up;
			}
		}

# if STARTTLS
		/* first TLS then AUTH to provide a security layer */
		if (mci->mci_state != MCIS_CLOSED &&
		    !DONE_STARTTLS(mci->mci_flags))
		{
			int olderrors;
			bool usetls;
			bool saveQuickAbort = QuickAbort;
			bool saveSuprErrs = SuprErrs;
			char *host = NULL;

			rcode = EX_OK;
			usetls = bitset(MCIF_TLS, mci->mci_flags);
			if (usetls)
				usetls = !iscltflgset(e, D_NOTLS);

			host = macvalue(macid("{server_name}"), e);
			if (usetls)
			{
				olderrors = Errors;
				QuickAbort = false;
				SuprErrs = true;
				if (rscheck("try_tls", host, NULL, e,
					    RSF_RMCOMM, 7, host, NOQID, NULL)
								!= EX_OK
				    || Errors > olderrors)
				{
					usetls = false;
				}
				SuprErrs = saveSuprErrs;
				QuickAbort = saveQuickAbort;
			}

			if (usetls)
			{
				if ((rcode = starttls(m, mci, e)) == EX_OK)
				{
					/* start again without STARTTLS */
					mci->mci_flags |= MCIF_TLSACT;
				}
				else
				{
					char *s;

					/*
					**  TLS negotiation failed, what to do?
					**  fall back to unencrypted connection
					**  or abort? How to decide?
					**  set a macro and call a ruleset.
					*/

					mci->mci_flags &= ~MCIF_TLS;
					switch (rcode)
					{
					  case EX_TEMPFAIL:
						s = "TEMP";
						break;
					  case EX_USAGE:
						s = "USAGE";
						break;
					  case EX_PROTOCOL:
						s = "PROTOCOL";
						break;
					  case EX_SOFTWARE:
						s = "SOFTWARE";
						break;
					  case EX_UNAVAILABLE:
						s = "NONE";
						break;

					  /* everything else is a failure */
					  default:
						s = "FAILURE";
						rcode = EX_TEMPFAIL;
					}
					macdefine(&e->e_macro, A_PERM,
						  macid("{verify}"), s);
				}
			}
			else
				macdefine(&e->e_macro, A_PERM,
					  macid("{verify}"), "NONE");
			olderrors = Errors;
			QuickAbort = false;
			SuprErrs = true;

			/*
			**  rcode == EX_SOFTWARE is special:
			**  the TLS negotiation failed
			**  we have to drop the connection no matter what
			**  However, we call tls_server to give it the chance
			**  to log the problem and return an appropriate
			**  error code.
			*/

			if (rscheck("tls_server",
				    macvalue(macid("{verify}"), e),
				    NULL, e, RSF_RMCOMM|RSF_COUNT, 5,
				    host, NOQID, NULL) != EX_OK ||
			    Errors > olderrors ||
			    rcode == EX_SOFTWARE)
			{
				char enhsc[ENHSCLEN];
				extern char MsgBuf[];

				if (ISSMTPCODE(MsgBuf) &&
				    extenhsc(MsgBuf + 4, ' ', enhsc) > 0)
				{
					p = sm_rpool_strdup_x(e->e_rpool,
							      MsgBuf);
				}
				else
				{
					p = "403 4.7.0 server not authenticated.";
					(void) sm_strlcpy(enhsc, "4.7.0",
							  sizeof(enhsc));
				}
				SuprErrs = saveSuprErrs;
				QuickAbort = saveQuickAbort;

				if (rcode == EX_SOFTWARE)
				{
					/* drop the connection */
					mci->mci_state = MCIS_QUITING;
					if (mci->mci_in != NULL)
					{
						(void) sm_io_close(mci->mci_in,
								   SM_TIME_DEFAULT);
						mci->mci_in = NULL;
					}
					mci->mci_flags &= ~MCIF_TLSACT;
					(void) endmailer(mci, e, pv);
				}
				else
				{
					/* abort transfer */
					smtpquit(m, mci, e);
				}

				/* avoid bogus error msg */
				mci->mci_errno = 0;

				/* temp or permanent failure? */
				rcode = (*p == '4') ? EX_TEMPFAIL
						    : EX_UNAVAILABLE;
				mci_setstat(mci, rcode, enhsc, p);

				/*
				**  hack to get the error message into
				**  the envelope (done in giveresponse())
				*/

				(void) sm_strlcpy(SmtpError, p,
						  sizeof(SmtpError));
			}
			else if (mci->mci_state == MCIS_CLOSED)
			{
				/* connection close caused by 421 */
				mci->mci_errno = 0;
				rcode = EX_TEMPFAIL;
				mci_setstat(mci, rcode, NULL, "421");
			}
			else
				rcode = 0;

			QuickAbort = saveQuickAbort;
			SuprErrs = saveSuprErrs;
			if (DONE_STARTTLS(mci->mci_flags) &&
			    mci->mci_state != MCIS_CLOSED)
			{
				SET_HELO(mci->mci_flags);
				mci_clr_extensions(mci);
				goto reconnect;
			}
		}
# endif /* STARTTLS */
# if SASL
		/* if other server supports authentication let's authenticate */
		if (mci->mci_state != MCIS_CLOSED &&
		    mci->mci_saslcap != NULL &&
		    !DONE_AUTH(mci->mci_flags) && !iscltflgset(e, D_NOAUTH))
		{
			/* Should we require some minimum authentication? */
			if ((ret = smtpauth(m, mci, e)) == EX_OK)
			{
				int result;
				sasl_ssf_t *ssf = NULL;

				/* Get security strength (features) */
				result = sasl_getprop(mci->mci_conn, SASL_SSF,
# if SASL >= 20000
						      (const void **) &ssf);
# else /* SASL >= 20000 */
						      (void **) &ssf);
# endif /* SASL >= 20000 */

				/* XXX authid? */
				if (LogLevel > 9)
					sm_syslog(LOG_INFO, NOQID,
						  "AUTH=client, relay=%.100s, mech=%.16s, bits=%d",
						  mci->mci_host,
						  macvalue(macid("{auth_type}"), e),
						  result == SASL_OK ? *ssf : 0);

				/*
				**  Only switch to encrypted connection
				**  if a security layer has been negotiated
				*/

				if (result == SASL_OK && *ssf > 0)
				{
					int tmo;

					/*
					**  Convert I/O layer to use SASL.
					**  If the call fails, the connection
					**  is aborted.
					*/

					tmo = DATA_PROGRESS_TIMEOUT * 1000;
					if (sfdcsasl(&mci->mci_in,
						     &mci->mci_out,
						     mci->mci_conn, tmo) == 0)
					{
						mci_clr_extensions(mci);
						mci->mci_flags |= MCIF_AUTHACT|
								  MCIF_ONLY_EHLO;
						goto reconnect;
					}
					syserr("AUTH TLS switch failed in client");
				}
				/* else? XXX */
				mci->mci_flags |= MCIF_AUTHACT;

			}
			else if (ret == EX_TEMPFAIL)
			{
				if (LogLevel > 8)
					sm_syslog(LOG_ERR, NOQID,
						  "AUTH=client, relay=%.100s, temporary failure, connection abort",
						  mci->mci_host);
				smtpquit(m, mci, e);

				/* avoid bogus error msg */
				mci->mci_errno = 0;
				rcode = EX_TEMPFAIL;
				mci_setstat(mci, rcode, "4.3.0", p);

				/*
				**  hack to get the error message into
				**  the envelope (done in giveresponse())
				*/

				(void) sm_strlcpy(SmtpError,
						  "Temporary AUTH failure",
						  sizeof(SmtpError));
			}
		}
# endif /* SASL */
	}


do_transfer:
	/* clear out per-message flags from connection structure */
	mci->mci_flags &= ~(MCIF_CVT7TO8|MCIF_CVT8TO7);

	if (bitset(EF_HAS8BIT, e->e_flags) &&
	    !bitset(EF_DONT_MIME, e->e_flags) &&
	    bitnset(M_7BITS, m->m_flags))
		mci->mci_flags |= MCIF_CVT8TO7;

#if MIME7TO8
	if (bitnset(M_MAKE8BIT, m->m_flags) &&
	    !bitset(MCIF_7BIT, mci->mci_flags) &&
	    (p = hvalue("Content-Transfer-Encoding", e->e_header)) != NULL &&
	     (sm_strcasecmp(p, "quoted-printable") == 0 ||
	      sm_strcasecmp(p, "base64") == 0) &&
	    (p = hvalue("Content-Type", e->e_header)) != NULL)
	{
		/* may want to convert 7 -> 8 */
		/* XXX should really parse it here -- and use a class XXX */
		if (sm_strncasecmp(p, "text/plain", 10) == 0 &&
		    (p[10] == '\0' || p[10] == ' ' || p[10] == ';'))
			mci->mci_flags |= MCIF_CVT7TO8;
	}
#endif /* MIME7TO8 */

	if (tTd(11, 1))
	{
		sm_dprintf("openmailer: ");
		mci_dump(sm_debug_file(), mci, false);
	}

#if _FFR_CLIENT_SIZE
	/*
	**  See if we know the maximum size and
	**  abort if the message is too big.
	**
	**  NOTE: _FFR_CLIENT_SIZE is untested.
	*/

	if (bitset(MCIF_SIZE, mci->mci_flags) &&
	    mci->mci_maxsize > 0 &&
	    e->e_msgsize > mci->mci_maxsize)
	{
		e->e_flags |= EF_NO_BODY_RETN;
		if (bitnset(M_LOCALMAILER, m->m_flags))
			e->e_status = "5.2.3";
		else
			e->e_status = "5.3.4";

		usrerrenh(e->e_status,
			  "552 Message is too large; %ld bytes max",
			  mci->mci_maxsize);
		rcode = EX_DATAERR;

		/* Need an e_message for error */
		(void) sm_snprintf(SmtpError, sizeof(SmtpError),
				   "Message is too large; %ld bytes max",
				   mci->mci_maxsize);
		goto give_up;
	}
#endif /* _FFR_CLIENT_SIZE */

	if (mci->mci_state != MCIS_OPEN)
	{
		/* couldn't open the mailer */
		rcode = mci->mci_exitstat;
		errno = mci->mci_errno;
		SM_SET_H_ERRNO(mci->mci_herrno);
		if (rcode == EX_OK)
		{
			/* shouldn't happen */
			syserr("554 5.3.5 deliver: mci=%lx rcode=%d errno=%d state=%d sig=%s",
			       (unsigned long) mci, rcode, errno,
			       mci->mci_state, firstsig);
			mci_dump_all(smioout, true);
			rcode = EX_SOFTWARE;
		}
		else if (nummxhosts > hostnum)
		{
			/* try next MX site */
			goto tryhost;
		}
	}
	else if (!clever)
	{
		bool ok;

		/*
		**  Format and send message.
		*/

		rcode = EX_OK;
		errno = 0;
		ok = putfromline(mci, e);
		if (ok)
			ok = (*e->e_puthdr)(mci, e->e_header, e, M87F_OUTER);
		if (ok)
			ok = (*e->e_putbody)(mci, e, NULL);
		if (ok && bitset(MCIF_INLONGLINE, mci->mci_flags))
			ok = putline("", mci);

		/*
		**  Ignore an I/O error that was caused by EPIPE.
		**  Some broken mailers don't read the entire body
		**  but just exit() thus causing an I/O error.
		*/

		if (!ok && (sm_io_error(mci->mci_out) && errno == EPIPE))
			ok = true;

		/* (always) get the exit status */
		rcode = endmailer(mci, e, pv);
		if (!ok)
			rcode = EX_TEMPFAIL;
		if (rcode == EX_TEMPFAIL && SmtpError[0] == '\0')
		{
			/*
			**  Need an e_message for mailq display.
			**  We set SmtpError as
			*/

			(void) sm_snprintf(SmtpError, sizeof(SmtpError),
					   "%s mailer (%s) exited with EX_TEMPFAIL",
					   m->m_name, m->m_mailer);
		}
	}
	else
	{
		/*
		**  Send the MAIL FROM: protocol
		*/

		/* XXX this isn't pipelined... */
		rcode = smtpmailfrom(m, mci, e);
		if (rcode == EX_OK)
		{
			register int i;
# if PIPELINING
			ADDRESS *volatile pchain;
# endif /* PIPELINING */

			/* send the recipient list */
			tobuf[0] = '\0';
			mci->mci_retryrcpt = false;
			mci->mci_tolist = tobuf;
# if PIPELINING
			pchain = NULL;
			mci->mci_nextaddr = NULL;
# endif /* PIPELINING */

			for (to = tochain; to != NULL; to = to->q_tchain)
			{
				if (!QS_IS_UNMARKED(to->q_state))
					continue;

				/* mark recipient state as "ok so far" */
				to->q_state = QS_OK;
				e->e_to = to->q_paddr;
# if STARTTLS
				i = rscheck("tls_rcpt", to->q_user, NULL, e,
					    RSF_RMCOMM|RSF_COUNT, 3,
					    mci->mci_host, e->e_id, NULL);
				if (i != EX_OK)
				{
					markfailure(e, to, mci, i, false);
					giveresponse(i, to->q_status,  m, mci,
						     ctladdr, xstart, e, to);
					if (i == EX_TEMPFAIL)
					{
						mci->mci_retryrcpt = true;
						to->q_state = QS_RETRY;
					}
					continue;
				}
# endif /* STARTTLS */

				i = smtprcpt(to, m, mci, e, ctladdr, xstart);
# if PIPELINING
				if (i == EX_OK &&
				    bitset(MCIF_PIPELINED, mci->mci_flags))
				{
					/*
					**  Add new element to list of
					**  recipients for pipelining.
					*/

					to->q_pchain = NULL;
					if (mci->mci_nextaddr == NULL)
						mci->mci_nextaddr = to;
					if (pchain == NULL)
						pchain = to;
					else
					{
						pchain->q_pchain = to;
						pchain = pchain->q_pchain;
					}
				}
# endif /* PIPELINING */
				if (i != EX_OK)
				{
					markfailure(e, to, mci, i, false);
					giveresponse(i, to->q_status, m, mci,
						     ctladdr, xstart, e, to);
					if (i == EX_TEMPFAIL)
						to->q_state = QS_RETRY;
				}
			}

			/* No recipients in list and no missing responses? */
			if (tobuf[0] == '\0'
# if PIPELINING
			    && bitset(MCIF_PIPELINED, mci->mci_flags)
			    && mci->mci_nextaddr == NULL
# endif /* PIPELINING */
			   )
			{
				rcode = EX_OK;
				e->e_to = NULL;
				if (bitset(MCIF_CACHED, mci->mci_flags))
					smtprset(m, mci, e);
			}
			else
			{
				e->e_to = tobuf + 1;
				rcode = smtpdata(m, mci, e, ctladdr, xstart);
			}
		}
		if (rcode == EX_TEMPFAIL && nummxhosts > hostnum)
		{
			/* try next MX site */
			goto tryhost;
		}
	}
#if NAMED_BIND
	if (ConfigLevel < 2)
		_res.options |= RES_DEFNAMES | RES_DNSRCH;	/* XXX */
#endif /* NAMED_BIND */

	if (tTd(62, 1))
		checkfds("after delivery");

	/*
	**  Do final status disposal.
	**	We check for something in tobuf for the SMTP case.
	**	If we got a temporary failure, arrange to queue the
	**		addressees.
	*/

  give_up:
	if (bitnset(M_LMTP, m->m_flags))
	{
		lmtp_rcode = rcode;
		tobuf[0] = '\0';
		anyok = false;
		strsize = 0;
	}
	else
		anyok = rcode == EX_OK;

	for (to = tochain; to != NULL; to = to->q_tchain)
	{
		/* see if address already marked */
		if (!QS_IS_OK(to->q_state))
			continue;

		/* if running LMTP, get the status for each address */
		if (bitnset(M_LMTP, m->m_flags))
		{
			if (lmtp_rcode == EX_OK)
				rcode = smtpgetstat(m, mci, e);
			if (rcode == EX_OK)
			{
				strsize += sm_strlcat2(tobuf + strsize, ",",
						to->q_paddr,
						tobufsize - strsize);
				SM_ASSERT(strsize < tobufsize);
				anyok = true;
			}
			else
			{
				e->e_to = to->q_paddr;
				markfailure(e, to, mci, rcode, true);
				giveresponse(rcode, to->q_status, m, mci,
					     ctladdr, xstart, e, to);
				e->e_to = tobuf + 1;
				continue;
			}
		}
		else
		{
			/* mark bad addresses */
			if (rcode != EX_OK)
			{
				if (goodmxfound && rcode == EX_NOHOST)
					rcode = EX_TEMPFAIL;
				markfailure(e, to, mci, rcode, true);
				continue;
			}
		}

		/* successful delivery */
		to->q_state = QS_SENT;
		to->q_statdate = curtime();
		e->e_nsent++;

		/*
		**  Checkpoint the send list every few addresses
		*/

		if (CheckpointInterval > 0 && e->e_nsent >= CheckpointInterval)
		{
			queueup(e, false, false);
			e->e_nsent = 0;
		}

		if (bitnset(M_LOCALMAILER, m->m_flags) &&
		    bitset(QPINGONSUCCESS, to->q_flags))
		{
			to->q_flags |= QDELIVERED;
			to->q_status = "2.1.5";
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
					     "%s... Successfully delivered\n",
					     to->q_paddr);
		}
		else if (bitset(QPINGONSUCCESS, to->q_flags) &&
			 bitset(QPRIMARY, to->q_flags) &&
			 !bitset(MCIF_DSN, mci->mci_flags))
		{
			to->q_flags |= QRELAYED;
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
					     "%s... relayed; expect no further notifications\n",
					     to->q_paddr);
		}
		else if (IS_DLVR_NOTIFY(e) &&
			 !bitset(MCIF_DLVR_BY, mci->mci_flags) &&
			 bitset(QPRIMARY, to->q_flags) &&
			 (!bitset(QHASNOTIFY, to->q_flags) ||
			  bitset(QPINGONSUCCESS, to->q_flags) ||
			  bitset(QPINGONFAILURE, to->q_flags) ||
			  bitset(QPINGONDELAY, to->q_flags)))
		{
			/* RFC 2852, 4.1.4.2: no NOTIFY, or not NEVER */
			to->q_flags |= QBYNRELAY;
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
					     "%s... Deliver-by notify: relayed\n",
					     to->q_paddr);
		}
		else if (IS_DLVR_TRACE(e) &&
			 (!bitset(QHASNOTIFY, to->q_flags) ||
			  bitset(QPINGONSUCCESS, to->q_flags) ||
			  bitset(QPINGONFAILURE, to->q_flags) ||
			  bitset(QPINGONDELAY, to->q_flags)) &&
			 bitset(QPRIMARY, to->q_flags))
		{
			/* RFC 2852, 4.1.4: no NOTIFY, or not NEVER */
			to->q_flags |= QBYTRACE;
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
					     "%s... Deliver-By trace: relayed\n",
					     to->q_paddr);
		}
	}

	if (bitnset(M_LMTP, m->m_flags))
	{
		/*
		**  Global information applies to the last recipient only;
		**  clear it out to avoid bogus errors.
		*/

		rcode = EX_OK;
		e->e_statmsg = NULL;

		/* reset the mci state for the next transaction */
		if (mci != NULL &&
		    (mci->mci_state == MCIS_MAIL ||
		     mci->mci_state == MCIS_RCPT ||
		     mci->mci_state == MCIS_DATA))
		{
			mci->mci_state = MCIS_OPEN;
			SmtpPhase = mci->mci_phase = "idle";
			sm_setproctitle(true, e, "%s: %s", CurHostName,
					mci->mci_phase);
		}
	}

	if (tobuf[0] != '\0')
	{
		giveresponse(rcode, NULL, m, mci, ctladdr, xstart, e, tochain);
#if 0
		/*
		**  This code is disabled for now because I am not
		**  sure that copying status from the first recipient
		**  to all non-status'ed recipients is a good idea.
		*/

		if (tochain->q_message != NULL &&
		    !bitnset(M_LMTP, m->m_flags) && rcode != EX_OK)
		{
			for (to = tochain->q_tchain; to != NULL;
			     to = to->q_tchain)
			{
				/* see if address already marked */
				if (QS_IS_QUEUEUP(to->q_state) &&
				    to->q_message == NULL)
					to->q_message = sm_rpool_strdup_x(e->e_rpool,
							tochain->q_message);
			}
		}
#endif /* 0 */
	}
	if (anyok)
		markstats(e, tochain, STATS_NORMAL);
	mci_store_persistent(mci);

	/* Some recipients were tempfailed, try them on the next host */
	if (mci != NULL && mci->mci_retryrcpt && nummxhosts > hostnum)
	{
		/* try next MX site */
		goto tryhost;
	}

	/* now close the connection */
	if (clever && mci != NULL && mci->mci_state != MCIS_CLOSED &&
	    !bitset(MCIF_CACHED, mci->mci_flags))
		smtpquit(m, mci, e);

cleanup: ;
	}
	SM_FINALLY
	{
		/*
		**  Restore state and return.
		*/
#if XDEBUG
		char wbuf[MAXLINE];

		/* make absolutely certain 0, 1, and 2 are in use */
		(void) sm_snprintf(wbuf, sizeof(wbuf),
				   "%s... end of deliver(%s)",
				   e->e_to == NULL ? "NO-TO-LIST"
						   : shortenstring(e->e_to,
								   MAXSHORTSTR),
				  m->m_name);
		checkfd012(wbuf);
#endif /* XDEBUG */

		errno = 0;

		/*
		**  It was originally necessary to set macro 'g' to NULL
		**  because it previously pointed to an auto buffer.
		**  We don't do this any more, so this may be unnecessary.
		*/

		macdefine(&e->e_macro, A_PERM, 'g', (char *) NULL);
		e->e_to = NULL;
	}
	SM_END_TRY
	return rcode;
}

/*
**  MARKFAILURE -- mark a failure on a specific address.
**
**	Parameters:
**		e -- the envelope we are sending.
**		q -- the address to mark.
**		mci -- mailer connection information.
**		rcode -- the code signifying the particular failure.
**		ovr -- override an existing code?
**
**	Returns:
**		none.
**
**	Side Effects:
**		marks the address (and possibly the envelope) with the
**			failure so that an error will be returned or
**			the message will be queued, as appropriate.
*/

void
markfailure(e, q, mci, rcode, ovr)
	register ENVELOPE *e;
	register ADDRESS *q;
	register MCI *mci;
	int rcode;
	bool ovr;
{
	int save_errno = errno;
	char *status = NULL;
	char *rstatus = NULL;

	switch (rcode)
	{
	  case EX_OK:
		break;

	  case EX_TEMPFAIL:
	  case EX_IOERR:
	  case EX_OSERR:
		q->q_state = QS_QUEUEUP;
		break;

	  default:
		q->q_state = QS_BADADDR;
		break;
	}

	/* find most specific error code possible */
	if (mci != NULL && mci->mci_status != NULL)
	{
		status = sm_rpool_strdup_x(e->e_rpool, mci->mci_status);
		if (mci->mci_rstatus != NULL)
			rstatus = sm_rpool_strdup_x(e->e_rpool,
						    mci->mci_rstatus);
		else
			rstatus = NULL;
	}
	else if (e->e_status != NULL)
	{
		status = e->e_status;
		rstatus = NULL;
	}
	else
	{
		switch (rcode)
		{
		  case EX_USAGE:
			status = "5.5.4";
			break;

		  case EX_DATAERR:
			status = "5.5.2";
			break;

		  case EX_NOUSER:
			status = "5.1.1";
			break;

		  case EX_NOHOST:
			status = "5.1.2";
			break;

		  case EX_NOINPUT:
		  case EX_CANTCREAT:
		  case EX_NOPERM:
			status = "5.3.0";
			break;

		  case EX_UNAVAILABLE:
		  case EX_SOFTWARE:
		  case EX_OSFILE:
		  case EX_PROTOCOL:
		  case EX_CONFIG:
			status = "5.5.0";
			break;

		  case EX_OSERR:
		  case EX_IOERR:
			status = "4.5.0";
			break;

		  case EX_TEMPFAIL:
			status = "4.2.0";
			break;
		}
	}

	/* new status? */
	if (status != NULL && *status != '\0' && (ovr || q->q_status == NULL ||
	    *q->q_status == '\0' || *q->q_status < *status))
	{
		q->q_status = status;
		q->q_rstatus = rstatus;
	}
	if (rcode != EX_OK && q->q_rstatus == NULL &&
	    q->q_mailer != NULL && q->q_mailer->m_diagtype != NULL &&
	    sm_strcasecmp(q->q_mailer->m_diagtype, "X-UNIX") == 0)
	{
		char buf[16];

		(void) sm_snprintf(buf, sizeof(buf), "%d", rcode);
		q->q_rstatus = sm_rpool_strdup_x(e->e_rpool, buf);
	}

	q->q_statdate = curtime();
	if (CurHostName != NULL && CurHostName[0] != '\0' &&
	    mci != NULL && !bitset(M_LOCALMAILER, mci->mci_flags))
		q->q_statmta = sm_rpool_strdup_x(e->e_rpool, CurHostName);

	/* restore errno */
	errno = save_errno;
}
/*
**  ENDMAILER -- Wait for mailer to terminate.
**
**	We should never get fatal errors (e.g., segmentation
**	violation), so we report those specially.  For other
**	errors, we choose a status message (into statmsg),
**	and if it represents an error, we print it.
**
**	Parameters:
**		mci -- the mailer connection info.
**		e -- the current envelope.
**		pv -- the parameter vector that invoked the mailer
**			(for error messages).
**
**	Returns:
**		exit code of mailer.
**
**	Side Effects:
**		none.
*/

static jmp_buf	EndWaitTimeout;

static void
endwaittimeout(ignore)
	int ignore;
{
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
	longjmp(EndWaitTimeout, 1);
}

int
endmailer(mci, e, pv)
	register MCI *mci;
	register ENVELOPE *e;
	char **pv;
{
	int st;
	int save_errno = errno;
	char buf[MAXLINE];
	SM_EVENT *ev = NULL;


	mci_unlock_host(mci);

	/* close output to mailer */
	if (mci->mci_out != NULL)
	{
		(void) sm_io_close(mci->mci_out, SM_TIME_DEFAULT);
		mci->mci_out = NULL;
	}

	/* copy any remaining input to transcript */
	if (mci->mci_in != NULL && mci->mci_state != MCIS_ERROR &&
	    e->e_xfp != NULL)
	{
		while (sfgets(buf, sizeof(buf), mci->mci_in,
			      TimeOuts.to_quit, "Draining Input") != NULL)
			(void) sm_io_fputs(e->e_xfp, SM_TIME_DEFAULT, buf);
	}

#if SASL
	/* close SASL connection */
	if (bitset(MCIF_AUTHACT, mci->mci_flags))
	{
		sasl_dispose(&mci->mci_conn);
		mci->mci_flags &= ~MCIF_AUTHACT;
	}
#endif /* SASL */

#if STARTTLS
	/* shutdown TLS */
	(void) endtlsclt(mci);
#endif /* STARTTLS */

	/* now close the input */
	if (mci->mci_in != NULL)
	{
		(void) sm_io_close(mci->mci_in, SM_TIME_DEFAULT);
		mci->mci_in = NULL;
	}
	mci->mci_state = MCIS_CLOSED;

	errno = save_errno;

	/* in the IPC case there is nothing to wait for */
	if (mci->mci_pid == 0)
		return EX_OK;

	/* put a timeout around the wait */
	if (mci->mci_mailer->m_wait > 0)
	{
		if (setjmp(EndWaitTimeout) == 0)
			ev = sm_setevent(mci->mci_mailer->m_wait,
					 endwaittimeout, 0);
		else
		{
			syserr("endmailer %s: wait timeout (%ld)",
			       mci->mci_mailer->m_name,
			       (long) mci->mci_mailer->m_wait);
			return EX_TEMPFAIL;
		}
	}

	/* wait for the mailer process, collect status */
	st = waitfor(mci->mci_pid);
	save_errno = errno;
	if (ev != NULL)
		sm_clrevent(ev);
	errno = save_errno;

	if (st == -1)
	{
		syserr("endmailer %s: wait", mci->mci_mailer->m_name);
		return EX_SOFTWARE;
	}

	if (WIFEXITED(st))
	{
		/* normal death -- return status */
		return (WEXITSTATUS(st));
	}

	/* it died a horrid death */
	syserr("451 4.3.0 mailer %s died with signal %d%s",
		mci->mci_mailer->m_name, WTERMSIG(st),
		WCOREDUMP(st) ? " (core dumped)" :
		(WIFSTOPPED(st) ? " (stopped)" : ""));

	/* log the arguments */
	if (pv != NULL && e->e_xfp != NULL)
	{
		register char **av;

		(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT, "Arguments:");
		for (av = pv; *av != NULL; av++)
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT, " %s",
					     *av);
		(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT, "\n");
	}

	ExitStat = EX_TEMPFAIL;
	return EX_TEMPFAIL;
}
/*
**  GIVERESPONSE -- Interpret an error response from a mailer
**
**	Parameters:
**		status -- the status code from the mailer (high byte
**			only; core dumps must have been taken care of
**			already).
**		dsn -- the DSN associated with the address, if any.
**		m -- the mailer info for this mailer.
**		mci -- the mailer connection info -- can be NULL if the
**			response is given before the connection is made.
**		ctladdr -- the controlling address for the recipient
**			address(es).
**		xstart -- the transaction start time, for computing
**			transaction delays.
**		e -- the current envelope.
**		to -- the current recipient (NULL if none).
**
**	Returns:
**		none.
**
**	Side Effects:
**		Errors may be incremented.
**		ExitStat may be set.
*/

void
giveresponse(status, dsn, m, mci, ctladdr, xstart, e, to)
	int status;
	char *dsn;
	register MAILER *m;
	register MCI *mci;
	ADDRESS *ctladdr;
	time_t xstart;
	ENVELOPE *e;
	ADDRESS *to;
{
	register const char *statmsg;
	int errnum = errno;
	int off = 4;
	bool usestat = false;
	char dsnbuf[ENHSCLEN];
	char buf[MAXLINE];
	char *exmsg;

	if (e == NULL)
	{
		syserr("giveresponse: null envelope");
		/* NOTREACHED */
		SM_ASSERT(0);
	}

	/*
	**  Compute status message from code.
	*/

	exmsg = sm_sysexmsg(status);
	if (status == 0)
	{
		statmsg = "250 2.0.0 Sent";
		if (e->e_statmsg != NULL)
		{
			(void) sm_snprintf(buf, sizeof(buf), "%s (%s)",
					   statmsg,
					   shortenstring(e->e_statmsg, 403));
			statmsg = buf;
		}
	}
	else if (exmsg == NULL)
	{
		(void) sm_snprintf(buf, sizeof(buf),
				   "554 5.3.0 unknown mailer error %d",
				   status);
		status = EX_UNAVAILABLE;
		statmsg = buf;
		usestat = true;
	}
	else if (status == EX_TEMPFAIL)
	{
		char *bp = buf;

		(void) sm_strlcpy(bp, exmsg + 1, SPACELEFT(buf, bp));
		bp += strlen(bp);
#if NAMED_BIND
		if (h_errno == TRY_AGAIN)
			statmsg = sm_errstring(h_errno + E_DNSBASE);
		else
#endif /* NAMED_BIND */
		{
			if (errnum != 0)
				statmsg = sm_errstring(errnum);
			else
				statmsg = SmtpError;
		}
		if (statmsg != NULL && statmsg[0] != '\0')
		{
			switch (errnum)
			{
#ifdef ENETDOWN
			  case ENETDOWN:	/* Network is down */
#endif /* ENETDOWN */
#ifdef ENETUNREACH
			  case ENETUNREACH:	/* Network is unreachable */
#endif /* ENETUNREACH */
#ifdef ENETRESET
			  case ENETRESET:	/* Network dropped connection on reset */
#endif /* ENETRESET */
#ifdef ECONNABORTED
			  case ECONNABORTED:	/* Software caused connection abort */
#endif /* ECONNABORTED */
#ifdef EHOSTDOWN
			  case EHOSTDOWN:	/* Host is down */
#endif /* EHOSTDOWN */
#ifdef EHOSTUNREACH
			  case EHOSTUNREACH:	/* No route to host */
#endif /* EHOSTUNREACH */
				if (mci != NULL && mci->mci_host != NULL)
				{
					(void) sm_strlcpyn(bp,
							   SPACELEFT(buf, bp),
							   2, ": ",
							   mci->mci_host);
					bp += strlen(bp);
				}
				break;
			}
			(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2, ": ",
					   statmsg);
			usestat = true;
		}
		statmsg = buf;
	}
#if NAMED_BIND
	else if (status == EX_NOHOST && h_errno != 0)
	{
		statmsg = sm_errstring(h_errno + E_DNSBASE);
		(void) sm_snprintf(buf, sizeof(buf), "%s (%s)", exmsg + 1,
				   statmsg);
		statmsg = buf;
		usestat = true;
	}
#endif /* NAMED_BIND */
	else
	{
		statmsg = exmsg;
		if (*statmsg++ == ':' && errnum != 0)
		{
			(void) sm_snprintf(buf, sizeof(buf), "%s: %s", statmsg,
					   sm_errstring(errnum));
			statmsg = buf;
			usestat = true;
		}
		else if (bitnset(M_LMTP, m->m_flags) && e->e_statmsg != NULL)
		{
			(void) sm_snprintf(buf, sizeof(buf), "%s (%s)", statmsg,
					   shortenstring(e->e_statmsg, 403));
			statmsg = buf;
			usestat = true;
		}
	}

	/*
	**  Print the message as appropriate
	*/

	if (status == EX_OK || status == EX_TEMPFAIL)
	{
		extern char MsgBuf[];

		if ((off = isenhsc(statmsg + 4, ' ')) > 0)
		{
			if (dsn == NULL)
			{
				(void) sm_snprintf(dsnbuf, sizeof(dsnbuf),
						   "%.*s", off, statmsg + 4);
				dsn = dsnbuf;
			}
			off += 5;
		}
		else
		{
			off = 4;
		}
		message("%s", statmsg + off);
		if (status == EX_TEMPFAIL && e->e_xfp != NULL)
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT, "%s\n",
					     &MsgBuf[4]);
	}
	else
	{
		char mbuf[ENHSCLEN + 4];

		Errors++;
		if ((off = isenhsc(statmsg + 4, ' ')) > 0 &&
		    off < sizeof(mbuf) - 4)
		{
			if (dsn == NULL)
			{
				(void) sm_snprintf(dsnbuf, sizeof(dsnbuf),
						   "%.*s", off, statmsg + 4);
				dsn = dsnbuf;
			}
			off += 5;

			/* copy only part of statmsg to mbuf */
			(void) sm_strlcpy(mbuf, statmsg, off);
			(void) sm_strlcat(mbuf, " %s", sizeof(mbuf));
		}
		else
		{
			dsnbuf[0] = '\0';
			(void) sm_snprintf(mbuf, sizeof(mbuf), "%.3s %%s",
					   statmsg);
			off = 4;
		}
		usrerr(mbuf, &statmsg[off]);
	}

	/*
	**  Final cleanup.
	**	Log a record of the transaction.  Compute the new
	**	ExitStat -- if we already had an error, stick with
	**	that.
	*/

	if (OpMode != MD_VERIFY && !bitset(EF_VRFYONLY, e->e_flags) &&
	    LogLevel > ((status == EX_TEMPFAIL) ? 8 : (status == EX_OK) ? 7 : 6))
		logdelivery(m, mci, dsn, statmsg + off, ctladdr, xstart, e);

	if (tTd(11, 2))
		sm_dprintf("giveresponse: status=%d, dsn=%s, e->e_message=%s, errnum=%d\n",
			   status,
			   dsn == NULL ? "<NULL>" : dsn,
			   e->e_message == NULL ? "<NULL>" : e->e_message,
			   errnum);

	if (status != EX_TEMPFAIL)
		setstat(status);
	if (status != EX_OK && (status != EX_TEMPFAIL || e->e_message == NULL))
		e->e_message = sm_rpool_strdup_x(e->e_rpool, statmsg + off);
	if (status != EX_OK && to != NULL && to->q_message == NULL)
	{
		if (!usestat && e->e_message != NULL)
			to->q_message = sm_rpool_strdup_x(e->e_rpool,
							  e->e_message);
		else
			to->q_message = sm_rpool_strdup_x(e->e_rpool,
							  statmsg + off);
	}
	errno = 0;
	SM_SET_H_ERRNO(0);
}
/*
**  LOGDELIVERY -- log the delivery in the system log
**
**	Care is taken to avoid logging lines that are too long, because
**	some versions of syslog have an unfortunate proclivity for core
**	dumping.  This is a hack, to be sure, that is at best empirical.
**
**	Parameters:
**		m -- the mailer info.  Can be NULL for initial queue.
**		mci -- the mailer connection info -- can be NULL if the
**			log is occurring when no connection is active.
**		dsn -- the DSN attached to the status.
**		status -- the message to print for the status.
**		ctladdr -- the controlling address for the to list.
**		xstart -- the transaction start time, used for
**			computing transaction delay.
**		e -- the current envelope.
**
**	Returns:
**		none
**
**	Side Effects:
**		none
*/

void
logdelivery(m, mci, dsn, status, ctladdr, xstart, e)
	MAILER *m;
	register MCI *mci;
	char *dsn;
	const char *status;
	ADDRESS *ctladdr;
	time_t xstart;
	register ENVELOPE *e;
{
	register char *bp;
	register char *p;
	int l;
	time_t now = curtime();
	char buf[1024];

#if (SYSLOG_BUFSIZE) >= 256
	/* ctladdr: max 106 bytes */
	bp = buf;
	if (ctladdr != NULL)
	{
		(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2, ", ctladdr=",
				   shortenstring(ctladdr->q_paddr, 83));
		bp += strlen(bp);
		if (bitset(QGOODUID, ctladdr->q_flags))
		{
			(void) sm_snprintf(bp, SPACELEFT(buf, bp), " (%d/%d)",
					   (int) ctladdr->q_uid,
					   (int) ctladdr->q_gid);
			bp += strlen(bp);
		}
	}

	/* delay & xdelay: max 41 bytes */
	(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2, ", delay=",
			   pintvl(now - e->e_ctime, true));
	bp += strlen(bp);

	if (xstart != (time_t) 0)
	{
		(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2, ", xdelay=",
				   pintvl(now - xstart, true));
		bp += strlen(bp);
	}

	/* mailer: assume about 19 bytes (max 10 byte mailer name) */
	if (m != NULL)
	{
		(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2, ", mailer=",
				   m->m_name);
		bp += strlen(bp);
	}

	/* pri: changes with each delivery attempt */
	(void) sm_snprintf(bp, SPACELEFT(buf, bp), ", pri=%ld",
		PRT_NONNEGL(e->e_msgpriority));
	bp += strlen(bp);

	/* relay: max 66 bytes for IPv4 addresses */
	if (mci != NULL && mci->mci_host != NULL)
	{
		extern SOCKADDR CurHostAddr;

		(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2, ", relay=",
				   shortenstring(mci->mci_host, 40));
		bp += strlen(bp);

		if (CurHostAddr.sa.sa_family != 0)
		{
			(void) sm_snprintf(bp, SPACELEFT(buf, bp), " [%s]",
					   anynet_ntoa(&CurHostAddr));
		}
	}
	else if (strcmp(status, "quarantined") == 0)
	{
		if (e->e_quarmsg != NULL)
			(void) sm_snprintf(bp, SPACELEFT(buf, bp),
					   ", quarantine=%s",
					   shortenstring(e->e_quarmsg, 40));
	}
	else if (strcmp(status, "queued") != 0)
	{
		p = macvalue('h', e);
		if (p != NULL && p[0] != '\0')
		{
			(void) sm_snprintf(bp, SPACELEFT(buf, bp),
					   ", relay=%s", shortenstring(p, 40));
		}
	}
	bp += strlen(bp);

	/* dsn */
	if (dsn != NULL && *dsn != '\0')
	{
		(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2, ", dsn=",
				   shortenstring(dsn, ENHSCLEN));
		bp += strlen(bp);
	}

#if _FFR_LOG_NTRIES
	/* ntries */
	if (e->e_ntries >= 0)
	{
		(void) sm_snprintf(bp, SPACELEFT(buf, bp),
				   ", ntries=%d", e->e_ntries + 1);
		bp += strlen(bp);
	}
#endif /* _FFR_LOG_NTRIES */

# define STATLEN		(((SYSLOG_BUFSIZE) - 100) / 4)
# if (STATLEN) < 63
#  undef STATLEN
#  define STATLEN	63
# endif /* (STATLEN) < 63 */
# if (STATLEN) > 203
#  undef STATLEN
#  define STATLEN	203
# endif /* (STATLEN) > 203 */

	/* stat: max 210 bytes */
	if ((bp - buf) > (sizeof(buf) - ((STATLEN) + 20)))
	{
		/* desperation move -- truncate data */
		bp = buf + sizeof(buf) - ((STATLEN) + 17);
		(void) sm_strlcpy(bp, "...", SPACELEFT(buf, bp));
		bp += 3;
	}

	(void) sm_strlcpy(bp, ", stat=", SPACELEFT(buf, bp));
	bp += strlen(bp);

	(void) sm_strlcpy(bp, shortenstring(status, STATLEN),
			  SPACELEFT(buf, bp));

	/* id, to: max 13 + TOBUFSIZE bytes */
	l = SYSLOG_BUFSIZE - 100 - strlen(buf);
	if (l < 0)
		l = 0;
	p = e->e_to == NULL ? "NO-TO-LIST" : e->e_to;
	while (strlen(p) >= l)
	{
		register char *q;

		for (q = p + l; q > p; q--)
		{
			if (*q == ',')
				break;
		}
		if (p == q)
			break;
		sm_syslog(LOG_INFO, e->e_id, "to=%.*s [more]%s",
			  (int) (++q - p), p, buf);
		p = q;
	}
	sm_syslog(LOG_INFO, e->e_id, "to=%.*s%s", l, p, buf);

#else /* (SYSLOG_BUFSIZE) >= 256 */

	l = SYSLOG_BUFSIZE - 85;
	if (l < 0)
		l = 0;
	p = e->e_to == NULL ? "NO-TO-LIST" : e->e_to;
	while (strlen(p) >= l)
	{
		register char *q;

		for (q = p + l; q > p; q--)
		{
			if (*q == ',')
				break;
		}
		if (p == q)
			break;

		sm_syslog(LOG_INFO, e->e_id, "to=%.*s [more]",
			  (int) (++q - p), p);
		p = q;
	}
	sm_syslog(LOG_INFO, e->e_id, "to=%.*s", l, p);

	if (ctladdr != NULL)
	{
		bp = buf;
		(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2, "ctladdr=",
				   shortenstring(ctladdr->q_paddr, 83));
		bp += strlen(bp);
		if (bitset(QGOODUID, ctladdr->q_flags))
		{
			(void) sm_snprintf(bp, SPACELEFT(buf, bp), " (%d/%d)",
					   ctladdr->q_uid, ctladdr->q_gid);
			bp += strlen(bp);
		}
		sm_syslog(LOG_INFO, e->e_id, "%s", buf);
	}
	bp = buf;
	(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2, "delay=",
			   pintvl(now - e->e_ctime, true));
	bp += strlen(bp);
	if (xstart != (time_t) 0)
	{
		(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2, ", xdelay=",
				   pintvl(now - xstart, true));
		bp += strlen(bp);
	}

	if (m != NULL)
	{
		(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2, ", mailer=",
				   m->m_name);
		bp += strlen(bp);
	}
	sm_syslog(LOG_INFO, e->e_id, "%.1000s", buf);

	buf[0] = '\0';
	bp = buf;
	if (mci != NULL && mci->mci_host != NULL)
	{
		extern SOCKADDR CurHostAddr;

		(void) sm_snprintf(bp, SPACELEFT(buf, bp), "relay=%.100s",
				   mci->mci_host);
		bp += strlen(bp);

		if (CurHostAddr.sa.sa_family != 0)
			(void) sm_snprintf(bp, SPACELEFT(buf, bp),
					   " [%.100s]",
					   anynet_ntoa(&CurHostAddr));
	}
	else if (strcmp(status, "quarantined") == 0)
	{
		if (e->e_quarmsg != NULL)
			(void) sm_snprintf(bp, SPACELEFT(buf, bp),
					   ", quarantine=%.100s",
					   e->e_quarmsg);
	}
	else if (strcmp(status, "queued") != 0)
	{
		p = macvalue('h', e);
		if (p != NULL && p[0] != '\0')
			(void) sm_snprintf(buf, sizeof(buf), "relay=%.100s", p);
	}
	if (buf[0] != '\0')
		sm_syslog(LOG_INFO, e->e_id, "%.1000s", buf);

	sm_syslog(LOG_INFO, e->e_id, "stat=%s", shortenstring(status, 63));
#endif /* (SYSLOG_BUFSIZE) >= 256 */
}
/*
**  PUTFROMLINE -- output a UNIX-style from line (or whatever)
**
**	This can be made an arbitrary message separator by changing $l
**
**	One of the ugliest hacks seen by human eyes is contained herein:
**	UUCP wants those stupid "remote from <host>" lines.  Why oh why
**	does a well-meaning programmer such as myself have to deal with
**	this kind of antique garbage????
**
**	Parameters:
**		mci -- the connection information.
**		e -- the envelope.
**
**	Returns:
**		true iff line was written successfully
**
**	Side Effects:
**		outputs some text to fp.
*/

bool
putfromline(mci, e)
	register MCI *mci;
	ENVELOPE *e;
{
	char *template = UnixFromLine;
	char buf[MAXLINE];
	char xbuf[MAXLINE];

	if (bitnset(M_NHDR, mci->mci_mailer->m_flags))
		return true;

	mci->mci_flags |= MCIF_INHEADER;

	if (bitnset(M_UGLYUUCP, mci->mci_mailer->m_flags))
	{
		char *bang;

		expand("\201g", buf, sizeof(buf), e);
		bang = strchr(buf, '!');
		if (bang == NULL)
		{
			char *at;
			char hname[MAXNAME];

			/*
			**  If we can construct a UUCP path, do so
			*/

			at = strrchr(buf, '@@');
			if (at == NULL)
			{
				expand("\201k", hname, sizeof(hname), e);
				at = hname;
			}
			else
				*at++ = '\0';
			(void) sm_snprintf(xbuf, sizeof(xbuf),
					   "From %.800s  \201d remote from %.100s\n",
					   buf, at);
		}
		else
		{
			*bang++ = '\0';
			(void) sm_snprintf(xbuf, sizeof(xbuf),
					   "From %.800s  \201d remote from %.100s\n",
					   bang, buf);
			template = xbuf;
		}
	}
	expand(template, buf, sizeof(buf), e);
	return putxline(buf, strlen(buf), mci, PXLF_HEADER);
}

/*
**  PUTBODY -- put the body of a message.
**
**	Parameters:
**		mci -- the connection information.
**		e -- the envelope to put out.
**		separator -- if non-NULL, a message separator that must
**			not be permitted in the resulting message.
**
**	Returns:
**		true iff message was written successfully
**
**	Side Effects:
**		The message is written onto fp.
*/

/* values for output state variable */
#define OSTATE_HEAD	0	/* at beginning of line */
#define OSTATE_CR	1	/* read a carriage return */
#define OSTATE_INLINE	2	/* putting rest of line */

bool
putbody(mci, e, separator)
	register MCI *mci;
	register ENVELOPE *e;
	char *separator;
{
	bool dead = false;
	bool ioerr = false;
	int save_errno;
	char buf[MAXLINE];
#if MIME8TO7
	char *boundaries[MAXMIMENESTING + 1];
#endif /* MIME8TO7 */

	/*
	**  Output the body of the message
	*/

	if (e->e_dfp == NULL && bitset(EF_HAS_DF, e->e_flags))
	{
		char *df = queuename(e, DATAFL_LETTER);

		e->e_dfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, df,
				      SM_IO_RDONLY_B, NULL);
		if (e->e_dfp == NULL)
		{
			char *msg = "!putbody: Cannot open %s for %s from %s";

			if (errno == ENOENT)
				msg++;
			syserr(msg, df, e->e_to, e->e_from.q_paddr);
		}

	}
	if (e->e_dfp == NULL)
	{
		if (bitset(MCIF_INHEADER, mci->mci_flags))
		{
			if (!putline("", mci))
				goto writeerr;
			mci->mci_flags &= ~MCIF_INHEADER;
		}
		if (!putline("<<< No Message Collected >>>", mci))
			goto writeerr;
		goto endofmessage;
	}

	if (e->e_dfino == (ino_t) 0)
	{
		struct stat stbuf;

		if (fstat(sm_io_getinfo(e->e_dfp, SM_IO_WHAT_FD, NULL), &stbuf)
		    < 0)
			e->e_dfino = -1;
		else
		{
			e->e_dfdev = stbuf.st_dev;
			e->e_dfino = stbuf.st_ino;
		}
	}

	/* paranoia: the data file should always be in a rewound state */
	(void) bfrewind(e->e_dfp);

	/* simulate an I/O timeout when used as source */
	if (tTd(84, 101))
		sleep(319);

#if MIME8TO7
	if (bitset(MCIF_CVT8TO7, mci->mci_flags))
	{
		/*
		**  Do 8 to 7 bit MIME conversion.
		*/

		/* make sure it looks like a MIME message */
		if (hvalue("MIME-Version", e->e_header) == NULL &&
		    !putline("MIME-Version: 1.0", mci))
			goto writeerr;

		if (hvalue("Content-Type", e->e_header) == NULL)
		{
			(void) sm_snprintf(buf, sizeof(buf),
					   "Content-Type: text/plain; charset=%s",
					   defcharset(e));
			if (!putline(buf, mci))
				goto writeerr;
		}

		/* now do the hard work */
		boundaries[0] = NULL;
		mci->mci_flags |= MCIF_INHEADER;
		if (mime8to7(mci, e->e_header, e, boundaries, M87F_OUTER, 0) ==
								SM_IO_EOF)
			goto writeerr;
	}
# if MIME7TO8
	else if (bitset(MCIF_CVT7TO8, mci->mci_flags))
	{
		if (!mime7to8(mci, e->e_header, e))
			goto writeerr;
	}
# endif /* MIME7TO8 */
	else if (MaxMimeHeaderLength > 0 || MaxMimeFieldLength > 0)
	{
		bool oldsuprerrs = SuprErrs;

		/* Use mime8to7 to check multipart for MIME header overflows */
		boundaries[0] = NULL;
		mci->mci_flags |= MCIF_INHEADER;

		/*
		**  If EF_DONT_MIME is set, we have a broken MIME message
		**  and don't want to generate a new bounce message whose
		**  body propagates the broken MIME.  We can't just not call
		**  mime8to7() as is done above since we need the security
		**  checks.  The best we can do is suppress the errors.
		*/

		if (bitset(EF_DONT_MIME, e->e_flags))
			SuprErrs = true;

		if (mime8to7(mci, e->e_header, e, boundaries,
				M87F_OUTER|M87F_NO8TO7, 0) == SM_IO_EOF)
			goto writeerr;

		/* restore SuprErrs */
		SuprErrs = oldsuprerrs;
	}
	else
#endif /* MIME8TO7 */
	{
		int ostate;
		register char *bp;
		register char *pbp;
		register int c;
		register char *xp;
		int padc;
		char *buflim;
		int pos = 0;
		char peekbuf[12];

		if (bitset(MCIF_INHEADER, mci->mci_flags))
		{
			if (!putline("", mci))
				goto writeerr;
			mci->mci_flags &= ~MCIF_INHEADER;
		}

		/* determine end of buffer; allow for short mailer lines */
		buflim = &buf[sizeof(buf) - 1];
		if (mci->mci_mailer->m_linelimit > 0 &&
		    mci->mci_mailer->m_linelimit < sizeof(buf) - 1)
			buflim = &buf[mci->mci_mailer->m_linelimit - 1];

		/* copy temp file to output with mapping */
		ostate = OSTATE_HEAD;
		bp = buf;
		pbp = peekbuf;
		while (!sm_io_error(mci->mci_out) && !dead)
		{
			if (pbp > peekbuf)
				c = *--pbp;
			else if ((c = sm_io_getc(e->e_dfp, SM_TIME_DEFAULT))
				 == SM_IO_EOF)
				break;
			if (bitset(MCIF_7BIT, mci->mci_flags))
				c &= 0x7f;
			switch (ostate)
			{
			  case OSTATE_HEAD:
				if (c == '\0' &&
				    bitnset(M_NONULLS,
					    mci->mci_mailer->m_flags))
					break;
				if (c != '\r' && c != '\n' && bp < buflim)
				{
					*bp++ = c;
					break;
				}

				/* check beginning of line for special cases */
				*bp = '\0';
				pos = 0;
				padc = SM_IO_EOF;
				if (buf[0] == 'F' &&
				    bitnset(M_ESCFROM, mci->mci_mailer->m_flags)
				    && strncmp(buf, "From ", 5) == 0)
				{
					padc = '>';
				}
				if (buf[0] == '-' && buf[1] == '-' &&
				    separator != NULL)
				{
					/* possible separator */
					int sl = strlen(separator);

					if (strncmp(&buf[2], separator, sl)
					    == 0)
						padc = ' ';
				}
				if (buf[0] == '.' &&
				    bitnset(M_XDOT, mci->mci_mailer->m_flags))
				{
					padc = '.';
				}

				/* now copy out saved line */
				if (TrafficLogFile != NULL)
				{
					(void) sm_io_fprintf(TrafficLogFile,
							     SM_TIME_DEFAULT,
							     "%05d >>> ",
							     (int) CurrentPid);
					if (padc != SM_IO_EOF)
						(void) sm_io_putc(TrafficLogFile,
								  SM_TIME_DEFAULT,
								  padc);
					for (xp = buf; xp < bp; xp++)
						(void) sm_io_putc(TrafficLogFile,
								  SM_TIME_DEFAULT,
								  (unsigned char) *xp);
					if (c == '\n')
						(void) sm_io_fputs(TrafficLogFile,
								   SM_TIME_DEFAULT,
								   mci->mci_mailer->m_eol);
				}
				if (padc != SM_IO_EOF)
				{
					if (sm_io_putc(mci->mci_out,
						       SM_TIME_DEFAULT, padc)
					    == SM_IO_EOF)
					{
						dead = true;
						continue;
					}
					pos++;
				}
				for (xp = buf; xp < bp; xp++)
				{
					if (sm_io_putc(mci->mci_out,
						       SM_TIME_DEFAULT,
						       (unsigned char) *xp)
					    == SM_IO_EOF)
					{
						dead = true;
						break;
					}
				}
				if (dead)
					continue;
				if (c == '\n')
				{
					if (sm_io_fputs(mci->mci_out,
							SM_TIME_DEFAULT,
							mci->mci_mailer->m_eol)
							== SM_IO_EOF)
						break;
					pos = 0;
				}
				else
				{
					pos += bp - buf;
					if (c != '\r')
					{
						SM_ASSERT(pbp < peekbuf +
								sizeof(peekbuf));
						*pbp++ = c;
					}
				}

				bp = buf;

				/* determine next state */
				if (c == '\n')
					ostate = OSTATE_HEAD;
				else if (c == '\r')
					ostate = OSTATE_CR;
				else
					ostate = OSTATE_INLINE;
				continue;

			  case OSTATE_CR:
				if (c == '\n')
				{
					/* got CRLF */
					if (sm_io_fputs(mci->mci_out,
							SM_TIME_DEFAULT,
							mci->mci_mailer->m_eol)
							== SM_IO_EOF)
						continue;

					if (TrafficLogFile != NULL)
					{
						(void) sm_io_fputs(TrafficLogFile,
								   SM_TIME_DEFAULT,
								   mci->mci_mailer->m_eol);
					}
					pos = 0;
					ostate = OSTATE_HEAD;
					continue;
				}

				/* had a naked carriage return */
				SM_ASSERT(pbp < peekbuf + sizeof(peekbuf));
				*pbp++ = c;
				c = '\r';
				ostate = OSTATE_INLINE;
				goto putch;

			  case OSTATE_INLINE:
				if (c == '\r')
				{
					ostate = OSTATE_CR;
					continue;
				}
				if (c == '\0' &&
				    bitnset(M_NONULLS,
					    mci->mci_mailer->m_flags))
					break;
putch:
				if (mci->mci_mailer->m_linelimit > 0 &&
				    pos >= mci->mci_mailer->m_linelimit - 1 &&
				    c != '\n')
				{
					int d;

					/* check next character for EOL */
					if (pbp > peekbuf)
						d = *(pbp - 1);
					else if ((d = sm_io_getc(e->e_dfp,
								 SM_TIME_DEFAULT))
						 != SM_IO_EOF)
					{
						SM_ASSERT(pbp < peekbuf +
								sizeof(peekbuf));
						*pbp++ = d;
					}

					if (d == '\n' || d == SM_IO_EOF)
					{
						if (TrafficLogFile != NULL)
							(void) sm_io_putc(TrafficLogFile,
									  SM_TIME_DEFAULT,
									  (unsigned char) c);
						if (sm_io_putc(mci->mci_out,
							       SM_TIME_DEFAULT,
							       (unsigned char) c)
							       == SM_IO_EOF)
						{
							dead = true;
							continue;
						}
						pos++;
						continue;
					}

					if (sm_io_putc(mci->mci_out,
						       SM_TIME_DEFAULT, '!')
					    == SM_IO_EOF ||
					    sm_io_fputs(mci->mci_out,
							SM_TIME_DEFAULT,
							mci->mci_mailer->m_eol)
					    == SM_IO_EOF)
					{
						dead = true;
						continue;
					}

					if (TrafficLogFile != NULL)
					{
						(void) sm_io_fprintf(TrafficLogFile,
								     SM_TIME_DEFAULT,
								     "!%s",
								     mci->mci_mailer->m_eol);
					}
					ostate = OSTATE_HEAD;
					SM_ASSERT(pbp < peekbuf +
							sizeof(peekbuf));
					*pbp++ = c;
					continue;
				}
				if (c == '\n')
				{
					if (TrafficLogFile != NULL)
						(void) sm_io_fputs(TrafficLogFile,
								   SM_TIME_DEFAULT,
								   mci->mci_mailer->m_eol);
					if (sm_io_fputs(mci->mci_out,
							SM_TIME_DEFAULT,
							mci->mci_mailer->m_eol)
							== SM_IO_EOF)
						continue;
					pos = 0;
					ostate = OSTATE_HEAD;
				}
				else
				{
					if (TrafficLogFile != NULL)
						(void) sm_io_putc(TrafficLogFile,
								  SM_TIME_DEFAULT,
								  (unsigned char) c);
					if (sm_io_putc(mci->mci_out,
						       SM_TIME_DEFAULT,
						       (unsigned char) c)
					    == SM_IO_EOF)
					{
						dead = true;
						continue;
					}
					pos++;
					ostate = OSTATE_INLINE;
				}
				break;
			}
		}

		/* make sure we are at the beginning of a line */
		if (bp > buf)
		{
			if (TrafficLogFile != NULL)
			{
				for (xp = buf; xp < bp; xp++)
					(void) sm_io_putc(TrafficLogFile,
							  SM_TIME_DEFAULT,
							  (unsigned char) *xp);
			}
			for (xp = buf; xp < bp; xp++)
			{
				if (sm_io_putc(mci->mci_out, SM_TIME_DEFAULT,
					       (unsigned char) *xp)
				    == SM_IO_EOF)
				{
					dead = true;
					break;
				}
			}
			pos += bp - buf;
		}
		if (!dead && pos > 0)
		{
			if (TrafficLogFile != NULL)
				(void) sm_io_fputs(TrafficLogFile,
						   SM_TIME_DEFAULT,
						   mci->mci_mailer->m_eol);
			if (sm_io_fputs(mci->mci_out, SM_TIME_DEFAULT,
					   mci->mci_mailer->m_eol) == SM_IO_EOF)
				goto writeerr;
		}
	}

	if (sm_io_error(e->e_dfp))
	{
		syserr("putbody: %s/%cf%s: read error",
		       qid_printqueue(e->e_dfqgrp, e->e_dfqdir),
		       DATAFL_LETTER, e->e_id);
		ExitStat = EX_IOERR;
		ioerr = true;
	}

endofmessage:
	/*
	**  Since mailfile() uses e_dfp in a child process,
	**  the file offset in the stdio library for the
	**  parent process will not agree with the in-kernel
	**  file offset since the file descriptor is shared
	**  between the processes.  Therefore, it is vital
	**  that the file always be rewound.  This forces the
	**  kernel offset (lseek) and stdio library (ftell)
	**  offset to match.
	*/

	save_errno = errno;
	if (e->e_dfp != NULL)
		(void) bfrewind(e->e_dfp);

	/* some mailers want extra blank line at end of message */
	if (!dead && bitnset(M_BLANKEND, mci->mci_mailer->m_flags) &&
	    buf[0] != '\0' && buf[0] != '\n')
	{
		if (!putline("", mci))
			goto writeerr;
	}

	if (!dead &&
	    (sm_io_flush(mci->mci_out, SM_TIME_DEFAULT) == SM_IO_EOF ||
	     (sm_io_error(mci->mci_out) && errno != EPIPE)))
	{
		save_errno = errno;
		syserr("putbody: write error");
		ExitStat = EX_IOERR;
		ioerr = true;
	}

	errno = save_errno;
	return !dead && !ioerr;

  writeerr:
	return false;
}

/*
**  MAILFILE -- Send a message to a file.
**
**	If the file has the set-user-ID/set-group-ID bits set, but NO
**	execute bits, sendmail will try to become the owner of that file
**	rather than the real user.  Obviously, this only works if
**	sendmail runs as root.
**
**	This could be done as a subordinate mailer, except that it
**	is used implicitly to save messages in ~/dead.letter.  We
**	view this as being sufficiently important as to include it
**	here.  For example, if the system is dying, we shouldn't have
**	to create another process plus some pipes to save the message.
**
**	Parameters:
**		filename -- the name of the file to send to.
**		mailer -- mailer definition for recipient -- if NULL,
**			use FileMailer.
**		ctladdr -- the controlling address header -- includes
**			the userid/groupid to be when sending.
**		sfflags -- flags for opening.
**		e -- the current envelope.
**
**	Returns:
**		The exit code associated with the operation.
**
**	Side Effects:
**		none.
*/

# define RETURN(st)			exit(st);

static jmp_buf	CtxMailfileTimeout;

int
mailfile(filename, mailer, ctladdr, sfflags, e)
	char *volatile filename;
	MAILER *volatile mailer;
	ADDRESS *ctladdr;
	volatile long sfflags;
	register ENVELOPE *e;
{
	register SM_FILE_T *f;
	register pid_t pid = -1;
	volatile int mode;
	int len;
	off_t curoff;
	bool suidwarn = geteuid() == 0;
	char *p;
	char *volatile realfile;
	SM_EVENT *ev;
	char buf[MAXPATHLEN];
	char targetfile[MAXPATHLEN];

	if (tTd(11, 1))
	{
		sm_dprintf("mailfile %s\n  ctladdr=", filename);
		printaddr(sm_debug_file(), ctladdr, false);
	}

	if (mailer == NULL)
		mailer = FileMailer;

	if (e->e_xfp != NULL)
		(void) sm_io_flush(e->e_xfp, SM_TIME_DEFAULT);

	/*
	**  Special case /dev/null.  This allows us to restrict file
	**  delivery to regular files only.
	*/

	if (sm_path_isdevnull(filename))
		return EX_OK;

	/* check for 8-bit available */
	if (bitset(EF_HAS8BIT, e->e_flags) &&
	    bitnset(M_7BITS, mailer->m_flags) &&
	    (bitset(EF_DONT_MIME, e->e_flags) ||
	     !(bitset(MM_MIME8BIT, MimeMode) ||
	       (bitset(EF_IS_MIME, e->e_flags) &&
		bitset(MM_CVTMIME, MimeMode)))))
	{
		e->e_status = "5.6.3";
		usrerrenh(e->e_status,
			  "554 Cannot send 8-bit data to 7-bit destination");
		errno = 0;
		return EX_DATAERR;
	}

	/* Find the actual file */
	if (SafeFileEnv != NULL && SafeFileEnv[0] != '\0')
	{
		len = strlen(SafeFileEnv);

		if (strncmp(SafeFileEnv, filename, len) == 0)
			filename += len;

		if (len + strlen(filename) + 1 >= sizeof(targetfile))
		{
			syserr("mailfile: filename too long (%s/%s)",
			       SafeFileEnv, filename);
			return EX_CANTCREAT;
		}
		(void) sm_strlcpy(targetfile, SafeFileEnv, sizeof(targetfile));
		realfile = targetfile + len;
		if (*filename == '/')
			filename++;
		if (*filename != '\0')
		{
			/* paranoia: trailing / should be removed in readcf */
			if (targetfile[len - 1] != '/')
				(void) sm_strlcat(targetfile,
						  "/", sizeof(targetfile));
			(void) sm_strlcat(targetfile, filename,
					  sizeof(targetfile));
		}
	}
	else if (mailer->m_rootdir != NULL)
	{
		expand(mailer->m_rootdir, targetfile, sizeof(targetfile), e);
		len = strlen(targetfile);

		if (strncmp(targetfile, filename, len) == 0)
			filename += len;

		if (len + strlen(filename) + 1 >= sizeof(targetfile))
		{
			syserr("mailfile: filename too long (%s/%s)",
			       targetfile, filename);
			return EX_CANTCREAT;
		}
		realfile = targetfile + len;
		if (targetfile[len - 1] != '/')
			(void) sm_strlcat(targetfile, "/", sizeof(targetfile));
		if (*filename == '/')
			(void) sm_strlcat(targetfile, filename + 1,
					  sizeof(targetfile));
		else
			(void) sm_strlcat(targetfile, filename,
					  sizeof(targetfile));
	}
	else
	{
		if (sm_strlcpy(targetfile, filename, sizeof(targetfile)) >=
		    sizeof(targetfile))
		{
			syserr("mailfile: filename too long (%s)", filename);
			return EX_CANTCREAT;
		}
		realfile = targetfile;
	}

	/*
	**  Fork so we can change permissions here.
	**	Note that we MUST use fork, not vfork, because of
	**	the complications of calling subroutines, etc.
	*/


	/*
	**  Dispose of SIGCHLD signal catchers that may be laying
	**  around so that the waitfor() below will get it.
	*/

	(void) sm_signal(SIGCHLD, SIG_DFL);

	DOFORK(fork);

	if (pid < 0)
		return EX_OSERR;
	else if (pid == 0)
	{
		/* child -- actually write to file */
		struct stat stb;
		MCI mcibuf;
		int err;
		volatile int oflags = O_WRONLY|O_APPEND;

		/* Reset global flags */
		RestartRequest = NULL;
		RestartWorkGroup = false;
		ShutdownRequest = NULL;
		PendingSignal = 0;
		CurrentPid = getpid();

		if (e->e_lockfp != NULL)
		{
			int fd;

			fd = sm_io_getinfo(e->e_lockfp, SM_IO_WHAT_FD, NULL);
			/* SM_ASSERT(fd >= 0); */
			if (fd >= 0)
				(void) close(fd);
		}

		(void) sm_signal(SIGINT, SIG_DFL);
		(void) sm_signal(SIGHUP, SIG_DFL);
		(void) sm_signal(SIGTERM, SIG_DFL);
		(void) umask(OldUmask);
		e->e_to = filename;
		ExitStat = EX_OK;

		if (setjmp(CtxMailfileTimeout) != 0)
		{
			RETURN(EX_TEMPFAIL);
		}

		if (TimeOuts.to_fileopen > 0)
			ev = sm_setevent(TimeOuts.to_fileopen, mailfiletimeout,
					 0);
		else
			ev = NULL;

		/* check file mode to see if set-user-ID */
		if (stat(targetfile, &stb) < 0)
			mode = FileMode;
		else
			mode = stb.st_mode;

		/* limit the errors to those actually caused in the child */
		errno = 0;
		ExitStat = EX_OK;

		/* Allow alias expansions to use the S_IS{U,G}ID bits */
		if ((ctladdr != NULL && !bitset(QALIAS, ctladdr->q_flags)) ||
		    bitset(SFF_RUNASREALUID, sfflags))
		{
			/* ignore set-user-ID and set-group-ID bits */
			mode &= ~(S_ISGID|S_ISUID);
			if (tTd(11, 20))
				sm_dprintf("mailfile: ignoring set-user-ID/set-group-ID bits\n");
		}

		/* we have to open the data file BEFORE setuid() */
		if (e->e_dfp == NULL && bitset(EF_HAS_DF, e->e_flags))
		{
			char *df = queuename(e, DATAFL_LETTER);

			e->e_dfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, df,
					      SM_IO_RDONLY_B, NULL);
			if (e->e_dfp == NULL)
			{
				syserr("mailfile: Cannot open %s for %s from %s",
					df, e->e_to, e->e_from.q_paddr);
			}
		}

		/* select a new user to run as */
		if (!bitset(SFF_RUNASREALUID, sfflags))
		{
			if (bitnset(M_SPECIFIC_UID, mailer->m_flags))
			{
				RealUserName = NULL;
				if (mailer->m_uid == NO_UID)
					RealUid = RunAsUid;
				else
					RealUid = mailer->m_uid;
				if (RunAsUid != 0 && RealUid != RunAsUid)
				{
					/* Only root can change the uid */
					syserr("mailfile: insufficient privileges to change uid, RunAsUid=%d, RealUid=%d",
						(int) RunAsUid, (int) RealUid);
					RETURN(EX_TEMPFAIL);
				}
			}
			else if (bitset(S_ISUID, mode))
			{
				RealUserName = NULL;
				RealUid = stb.st_uid;
			}
			else if (ctladdr != NULL && ctladdr->q_uid != 0)
			{
				if (ctladdr->q_ruser != NULL)
					RealUserName = ctladdr->q_ruser;
				else
					RealUserName = ctladdr->q_user;
				RealUid = ctladdr->q_uid;
			}
			else if (mailer != NULL && mailer->m_uid != NO_UID)
			{
				RealUserName = DefUser;
				RealUid = mailer->m_uid;
			}
			else
			{
				RealUserName = DefUser;
				RealUid = DefUid;
			}

			/* select a new group to run as */
			if (bitnset(M_SPECIFIC_UID, mailer->m_flags))
			{
				if (mailer->m_gid == NO_GID)
					RealGid = RunAsGid;
				else
					RealGid = mailer->m_gid;
				if (RunAsUid != 0 &&
				    (RealGid != getgid() ||
				     RealGid != getegid()))
				{
					/* Only root can change the gid */
					syserr("mailfile: insufficient privileges to change gid, RealGid=%d, RunAsUid=%d, gid=%d, egid=%d",
					       (int) RealGid, (int) RunAsUid,
					       (int) getgid(), (int) getegid());
					RETURN(EX_TEMPFAIL);
				}
			}
			else if (bitset(S_ISGID, mode))
				RealGid = stb.st_gid;
			else if (ctladdr != NULL &&
				 ctladdr->q_uid == DefUid &&
				 ctladdr->q_gid == 0)
			{
				/*
				**  Special case:  This means it is an
				**  alias and we should act as DefaultUser.
				**  See alias()'s comments.
				*/

				RealGid = DefGid;
				RealUserName = DefUser;
			}
			else if (ctladdr != NULL && ctladdr->q_uid != 0)
				RealGid = ctladdr->q_gid;
			else if (mailer != NULL && mailer->m_gid != NO_GID)
				RealGid = mailer->m_gid;
			else
				RealGid = DefGid;
		}

		/* last ditch */
		if (!bitset(SFF_ROOTOK, sfflags))
		{
			if (RealUid == 0)
				RealUid = DefUid;
			if (RealGid == 0)
				RealGid = DefGid;
		}

		/* set group id list (needs /etc/group access) */
		if (RealUserName != NULL && !DontInitGroups)
		{
			if (initgroups(RealUserName, RealGid) == -1 && suidwarn)
			{
				syserr("mailfile: initgroups(%s, %d) failed",
					RealUserName, RealGid);
				RETURN(EX_TEMPFAIL);
			}
		}
		else
		{
			GIDSET_T gidset[1];

			gidset[0] = RealGid;
			if (setgroups(1, gidset) == -1 && suidwarn)
			{
				syserr("mailfile: setgroups() failed");
				RETURN(EX_TEMPFAIL);
			}
		}

		/*
		**  If you have a safe environment, go into it.
		*/

		if (realfile != targetfile)
		{
			char save;

			save = *realfile;
			*realfile = '\0';
			if (tTd(11, 20))
				sm_dprintf("mailfile: chroot %s\n", targetfile);
			if (chroot(targetfile) < 0)
			{
				syserr("mailfile: Cannot chroot(%s)",
				       targetfile);
				RETURN(EX_CANTCREAT);
			}
			*realfile = save;
		}

		if (tTd(11, 40))
			sm_dprintf("mailfile: deliver to %s\n", realfile);

		if (chdir("/") < 0)
		{
			syserr("mailfile: cannot chdir(/)");
			RETURN(EX_CANTCREAT);
		}

		/* now reset the group and user ids */
		endpwent();
		sm_mbdb_terminate();
		if (setgid(RealGid) < 0 && suidwarn)
		{
			syserr("mailfile: setgid(%ld) failed", (long) RealGid);
			RETURN(EX_TEMPFAIL);
		}
		vendor_set_uid(RealUid);
		if (setuid(RealUid) < 0 && suidwarn)
		{
			syserr("mailfile: setuid(%ld) failed", (long) RealUid);
			RETURN(EX_TEMPFAIL);
		}

		if (tTd(11, 2))
			sm_dprintf("mailfile: running as r/euid=%d/%d, r/egid=%d/%d\n",
				(int) getuid(), (int) geteuid(),
				(int) getgid(), (int) getegid());


		/* move into some "safe" directory */
		if (mailer->m_execdir != NULL)
		{
			char *q;

			for (p = mailer->m_execdir; p != NULL; p = q)
			{
				q = strchr(p, ':');
				if (q != NULL)
					*q = '\0';
				expand(p, buf, sizeof(buf), e);
				if (q != NULL)
					*q++ = ':';
				if (tTd(11, 20))
					sm_dprintf("mailfile: trydir %s\n",
						   buf);
				if (buf[0] != '\0' && chdir(buf) >= 0)
					break;
			}
		}

		/*
		**  Recheck the file after we have assumed the ID of the
		**  delivery user to make sure we can deliver to it as
		**  that user.  This is necessary if sendmail is running
		**  as root and the file is on an NFS mount which treats
		**  root as nobody.
		*/

#if HASLSTAT
		if (bitnset(DBS_FILEDELIVERYTOSYMLINK, DontBlameSendmail))
			err = stat(realfile, &stb);
		else
			err = lstat(realfile, &stb);
#else /* HASLSTAT */
		err = stat(realfile, &stb);
#endif /* HASLSTAT */

		if (err < 0)
		{
			stb.st_mode = ST_MODE_NOFILE;
			mode = FileMode;
			oflags |= O_CREAT|O_EXCL;
		}
		else if (bitset(S_IXUSR|S_IXGRP|S_IXOTH, mode) ||
			 (!bitnset(DBS_FILEDELIVERYTOHARDLINK,
				   DontBlameSendmail) &&
			  stb.st_nlink != 1) ||
			 (realfile != targetfile && !S_ISREG(mode)))
			exit(EX_CANTCREAT);
		else
			mode = stb.st_mode;

		if (!bitnset(DBS_FILEDELIVERYTOSYMLINK, DontBlameSendmail))
			sfflags |= SFF_NOSLINK;
		if (!bitnset(DBS_FILEDELIVERYTOHARDLINK, DontBlameSendmail))
			sfflags |= SFF_NOHLINK;
		sfflags &= ~SFF_OPENASROOT;
		f = safefopen(realfile, oflags, mode, sfflags);
		if (f == NULL)
		{
			if (transienterror(errno))
			{
				usrerr("454 4.3.0 cannot open %s: %s",
				       shortenstring(realfile, MAXSHORTSTR),
				       sm_errstring(errno));
				RETURN(EX_TEMPFAIL);
			}
			else
			{
				usrerr("554 5.3.0 cannot open %s: %s",
				       shortenstring(realfile, MAXSHORTSTR),
				       sm_errstring(errno));
				RETURN(EX_CANTCREAT);
			}
		}
		if (filechanged(realfile, sm_io_getinfo(f, SM_IO_WHAT_FD, NULL),
		    &stb))
		{
			syserr("554 5.3.0 file changed after open");
			RETURN(EX_CANTCREAT);
		}
		if (fstat(sm_io_getinfo(f, SM_IO_WHAT_FD, NULL), &stb) < 0)
		{
			syserr("554 5.3.0 cannot fstat %s",
				sm_errstring(errno));
			RETURN(EX_CANTCREAT);
		}

		curoff = stb.st_size;

		if (ev != NULL)
			sm_clrevent(ev);

		memset(&mcibuf, '\0', sizeof(mcibuf));
		mcibuf.mci_mailer = mailer;
		mcibuf.mci_out = f;
		if (bitnset(M_7BITS, mailer->m_flags))
			mcibuf.mci_flags |= MCIF_7BIT;

		/* clear out per-message flags from connection structure */
		mcibuf.mci_flags &= ~(MCIF_CVT7TO8|MCIF_CVT8TO7);

		if (bitset(EF_HAS8BIT, e->e_flags) &&
		    !bitset(EF_DONT_MIME, e->e_flags) &&
		    bitnset(M_7BITS, mailer->m_flags))
			mcibuf.mci_flags |= MCIF_CVT8TO7;

#if MIME7TO8
		if (bitnset(M_MAKE8BIT, mailer->m_flags) &&
		    !bitset(MCIF_7BIT, mcibuf.mci_flags) &&
		    (p = hvalue("Content-Transfer-Encoding", e->e_header)) != NULL &&
		    (sm_strcasecmp(p, "quoted-printable") == 0 ||
		     sm_strcasecmp(p, "base64") == 0) &&
		    (p = hvalue("Content-Type", e->e_header)) != NULL)
		{
			/* may want to convert 7 -> 8 */
			/* XXX should really parse it here -- and use a class XXX */
			if (sm_strncasecmp(p, "text/plain", 10) == 0 &&
			    (p[10] == '\0' || p[10] == ' ' || p[10] == ';'))
				mcibuf.mci_flags |= MCIF_CVT7TO8;
		}
#endif /* MIME7TO8 */

		if (!putfromline(&mcibuf, e) ||
		    !(*e->e_puthdr)(&mcibuf, e->e_header, e, M87F_OUTER) ||
		    !(*e->e_putbody)(&mcibuf, e, NULL) ||
		    !putline("\n", &mcibuf) ||
		    (sm_io_flush(f, SM_TIME_DEFAULT) != 0 ||
		    (SuperSafe != SAFE_NO &&
		     fsync(sm_io_getinfo(f, SM_IO_WHAT_FD, NULL)) < 0) ||
		    sm_io_error(f)))
		{
			setstat(EX_IOERR);
#if !NOFTRUNCATE
			(void) ftruncate(sm_io_getinfo(f, SM_IO_WHAT_FD, NULL),
					 curoff);
#endif /* !NOFTRUNCATE */
		}

		/* reset ISUID & ISGID bits for paranoid systems */
#if HASFCHMOD
		(void) fchmod(sm_io_getinfo(f, SM_IO_WHAT_FD, NULL),
			      (MODE_T) mode);
#else /* HASFCHMOD */
		(void) chmod(filename, (MODE_T) mode);
#endif /* HASFCHMOD */
		if (sm_io_close(f, SM_TIME_DEFAULT) < 0)
			setstat(EX_IOERR);
		(void) sm_io_flush(smioout, SM_TIME_DEFAULT);
		(void) setuid(RealUid);
		exit(ExitStat);
		/* NOTREACHED */
	}
	else
	{
		/* parent -- wait for exit status */
		int st;

		st = waitfor(pid);
		if (st == -1)
		{
			syserr("mailfile: %s: wait", mailer->m_name);
			return EX_SOFTWARE;
		}
		if (WIFEXITED(st))
		{
			errno = 0;
			return (WEXITSTATUS(st));
		}
		else
		{
			syserr("mailfile: %s: child died on signal %d",
			       mailer->m_name, st);
			return EX_UNAVAILABLE;
		}
		/* NOTREACHED */
	}
	return EX_UNAVAILABLE;	/* avoid compiler warning on IRIX */
}

static void
mailfiletimeout(ignore)
	int ignore;
{
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
	longjmp(CtxMailfileTimeout, 1);
}
/*
**  HOSTSIGNATURE -- return the "signature" for a host.
**
**	The signature describes how we are going to send this -- it
**	can be just the hostname (for non-Internet hosts) or can be
**	an ordered list of MX hosts.
**
**	Parameters:
**		m -- the mailer describing this host.
**		host -- the host name.
**
**	Returns:
**		The signature for this host.
**
**	Side Effects:
**		Can tweak the symbol table.
*/

#define MAXHOSTSIGNATURE	8192	/* max len of hostsignature */

char *
hostsignature(m, host)
	register MAILER *m;
	char *host;
{
	register char *p;
	register STAB *s;
	time_t now;
#if NAMED_BIND
	char sep = ':';
	char prevsep = ':';
	int i;
	int len;
	int nmx;
	int hl;
	char *hp;
	char *endp;
	int oldoptions = _res.options;
	char *mxhosts[MAXMXHOSTS + 1];
	unsigned short mxprefs[MAXMXHOSTS + 1];
#endif /* NAMED_BIND */

	if (tTd(17, 3))
		sm_dprintf("hostsignature(%s)\n", host);

	/*
	**  If local delivery (and not remote), just return a constant.
	*/

	if (bitnset(M_LOCALMAILER, m->m_flags) &&
	    strcmp(m->m_mailer, "[IPC]") != 0 &&
	    !(m->m_argv[0] != NULL && strcmp(m->m_argv[0], "TCP") == 0))
		return "localhost";

	/* an empty host does not have MX records */
	if (*host == '\0')
		return "_empty_";

	/*
	**  Check to see if this uses IPC -- if not, it can't have MX records.
	*/

	if (strcmp(m->m_mailer, "[IPC]") != 0 ||
	    CurEnv->e_sendmode == SM_DEFER)
	{
		/* just an ordinary mailer or deferred mode */
		return host;
	}
#if NETUNIX
	else if (m->m_argv[0] != NULL &&
		 strcmp(m->m_argv[0], "FILE") == 0)
	{
		/* rendezvous in the file system, no MX records */
		return host;
	}
#endif /* NETUNIX */

	/*
	**  Look it up in the symbol table.
	*/

	now = curtime();
	s = stab(host, ST_HOSTSIG, ST_ENTER);
	if (s->s_hostsig.hs_sig != NULL)
	{
		if (s->s_hostsig.hs_exp >= now)
		{
			if (tTd(17, 3))
				sm_dprintf("hostsignature(): stab(%s) found %s\n", host,
					   s->s_hostsig.hs_sig);
			return s->s_hostsig.hs_sig;
		}

		/* signature is expired: clear it */
		sm_free(s->s_hostsig.hs_sig);
		s->s_hostsig.hs_sig = NULL;
	}

	/* set default TTL */
	s->s_hostsig.hs_exp = now + SM_DEFAULT_TTL;

	/*
	**  Not already there or expired -- create a signature.
	*/

#if NAMED_BIND
	if (ConfigLevel < 2)
		_res.options &= ~(RES_DEFNAMES | RES_DNSRCH);	/* XXX */

	for (hp = host; hp != NULL; hp = endp)
	{
#if NETINET6
		if (*hp == '[')
		{
			endp = strchr(hp + 1, ']');
			if (endp != NULL)
				endp = strpbrk(endp + 1, ":,");
		}
		else
			endp = strpbrk(hp, ":,");
#else /* NETINET6 */
		endp = strpbrk(hp, ":,");
#endif /* NETINET6 */
		if (endp != NULL)
		{
			sep = *endp;
			*endp = '\0';
		}

		if (bitnset(M_NOMX, m->m_flags))
		{
			/* skip MX lookups */
			nmx = 1;
			mxhosts[0] = hp;
		}
		else
		{
			auto int rcode;
			int ttl;

			nmx = getmxrr(hp, mxhosts, mxprefs, true, &rcode, true,
				      &ttl);
			if (nmx <= 0)
			{
				int save_errno;
				register MCI *mci;

				/* update the connection info for this host */
				save_errno = errno;
				mci = mci_get(hp, m);
				mci->mci_errno = save_errno;
				mci->mci_herrno = h_errno;
				mci->mci_lastuse = now;
				if (rcode == EX_NOHOST)
					mci_setstat(mci, rcode, "5.1.2",
						    "550 Host unknown");
				else
					mci_setstat(mci, rcode, NULL, NULL);

				/* use the original host name as signature */
				nmx = 1;
				mxhosts[0] = hp;
			}
			if (tTd(17, 3))
				sm_dprintf("hostsignature(): getmxrr() returned %d, mxhosts[0]=%s\n",
					   nmx, mxhosts[0]);

			/*
			**  Set new TTL: we use only one!
			**	We could try to use the minimum instead.
			*/

			s->s_hostsig.hs_exp = now + SM_MIN(ttl, SM_DEFAULT_TTL);
		}

		len = 0;
		for (i = 0; i < nmx; i++)
			len += strlen(mxhosts[i]) + 1;
		if (s->s_hostsig.hs_sig != NULL)
			len += strlen(s->s_hostsig.hs_sig) + 1;
		if (len < 0 || len >= MAXHOSTSIGNATURE)
		{
			sm_syslog(LOG_WARNING, NOQID, "hostsignature for host '%s' exceeds maxlen (%d): %d",
				  host, MAXHOSTSIGNATURE, len);
			len = MAXHOSTSIGNATURE;
		}
		p = sm_pmalloc_x(len);
		if (s->s_hostsig.hs_sig != NULL)
		{
			(void) sm_strlcpy(p, s->s_hostsig.hs_sig, len);
			sm_free(s->s_hostsig.hs_sig); /* XXX */
			s->s_hostsig.hs_sig = p;
			hl = strlen(p);
			p += hl;
			*p++ = prevsep;
			len -= hl + 1;
		}
		else
			s->s_hostsig.hs_sig = p;
		for (i = 0; i < nmx; i++)
		{
			hl = strlen(mxhosts[i]);
			if (len - 1 < hl || len <= 1)
			{
				/* force to drop out of outer loop */
				len = -1;
				break;
			}
			if (i != 0)
			{
				if (mxprefs[i] == mxprefs[i - 1])
					*p++ = ',';
				else
					*p++ = ':';
				len--;
			}
			(void) sm_strlcpy(p, mxhosts[i], len);
			p += hl;
			len -= hl;
		}

		/*
		**  break out of loop if len exceeded MAXHOSTSIGNATURE
		**  because we won't have more space for further hosts
		**  anyway (separated by : in the .cf file).
		*/

		if (len < 0)
			break;
		if (endp != NULL)
			*endp++ = sep;
		prevsep = sep;
	}
	makelower(s->s_hostsig.hs_sig);
	if (ConfigLevel < 2)
		_res.options = oldoptions;
#else /* NAMED_BIND */
	/* not using BIND -- the signature is just the host name */
	/*
	**  'host' points to storage that will be freed after we are
	**  done processing the current envelope, so we copy it.
	*/
	s->s_hostsig.hs_sig = sm_pstrdup_x(host);
#endif /* NAMED_BIND */
	if (tTd(17, 1))
		sm_dprintf("hostsignature(%s) = %s\n", host, s->s_hostsig.hs_sig);
	return s->s_hostsig.hs_sig;
}
/*
**  PARSE_HOSTSIGNATURE -- parse the "signature" and return MX host array.
**
**	The signature describes how we are going to send this -- it
**	can be just the hostname (for non-Internet hosts) or can be
**	an ordered list of MX hosts which must be randomized for equal
**	MX preference values.
**
**	Parameters:
**		sig -- the host signature.
**		mxhosts -- array to populate.
**		mailer -- mailer.
**
**	Returns:
**		The number of hosts inserted into mxhosts array.
**
**	Side Effects:
**		Randomizes equal MX preference hosts in mxhosts.
*/

static int
parse_hostsignature(sig, mxhosts, mailer)
	char *sig;
	char **mxhosts;
	MAILER *mailer;
{
	unsigned short curpref = 0;
	int nmx = 0, i, j;	/* NOTE: i, j, and nmx must have same type */
	char *hp, *endp;
	unsigned short prefer[MAXMXHOSTS];
	long rndm[MAXMXHOSTS];

	for (hp = sig; hp != NULL; hp = endp)
	{
		char sep = ':';

#if NETINET6
		if (*hp == '[')
		{
			endp = strchr(hp + 1, ']');
			if (endp != NULL)
				endp = strpbrk(endp + 1, ":,");
		}
		else
			endp = strpbrk(hp, ":,");
#else /* NETINET6 */
		endp = strpbrk(hp, ":,");
#endif /* NETINET6 */
		if (endp != NULL)
		{
			sep = *endp;
			*endp = '\0';
		}

		mxhosts[nmx] = hp;
		prefer[nmx] = curpref;
		if (mci_match(hp, mailer))
			rndm[nmx] = 0;
		else
			rndm[nmx] = get_random();

		if (endp != NULL)
		{
			/*
			**  Since we don't have the original MX prefs,
			**  make our own.  If the separator is a ':', that
			**  means the preference for the next host will be
			**  higher than this one, so simply increment curpref.
			*/

			if (sep == ':')
				curpref++;

			*endp++ = sep;
		}
		if (++nmx >= MAXMXHOSTS)
			break;
	}

	/* sort the records using the random factor for equal preferences */
	for (i = 0; i < nmx; i++)
	{
		for (j = i + 1; j < nmx; j++)
		{
			/*
			**  List is already sorted by MX preference, only
			**  need to look for equal preference MX records
			*/

			if (prefer[i] < prefer[j])
				break;

			if (prefer[i] > prefer[j] ||
			    (prefer[i] == prefer[j] && rndm[i] > rndm[j]))
			{
				register unsigned short tempp;
				register long tempr;
				register char *temp1;

				tempp = prefer[i];
				prefer[i] = prefer[j];
				prefer[j] = tempp;
				temp1 = mxhosts[i];
				mxhosts[i] = mxhosts[j];
				mxhosts[j] = temp1;
				tempr = rndm[i];
				rndm[i] = rndm[j];
				rndm[j] = tempr;
			}
		}
	}
	return nmx;
}

# if STARTTLS
static SSL_CTX	*clt_ctx = NULL;
static bool	tls_ok_clt = true;

/*
**  SETCLTTLS -- client side TLS: allow/disallow.
**
**	Parameters:
**		tls_ok -- should tls be done?
**
**	Returns:
**		none.
**
**	Side Effects:
**		sets tls_ok_clt (static variable in this module)
*/

void
setclttls(tls_ok)
	bool tls_ok;
{
	tls_ok_clt = tls_ok;
	return;
}
/*
**  INITCLTTLS -- initialize client side TLS
**
**	Parameters:
**		tls_ok -- should tls initialization be done?
**
**	Returns:
**		succeeded?
**
**	Side Effects:
**		sets tls_ok_clt (static variable in this module)
*/

bool
initclttls(tls_ok)
	bool tls_ok;
{
	if (!tls_ok_clt)
		return false;
	tls_ok_clt = tls_ok;
	if (!tls_ok_clt)
		return false;
	if (clt_ctx != NULL)
		return true;	/* already done */
	tls_ok_clt = inittls(&clt_ctx, TLS_I_CLT, Clt_SSL_Options, false,
			     CltCertFile, CltKeyFile,
			     CACertPath, CACertFile, DHParams);
	return tls_ok_clt;
}

/*
**  STARTTLS -- try to start secure connection (client side)
**
**	Parameters:
**		m -- the mailer.
**		mci -- the mailer connection info.
**		e -- the envelope.
**
**	Returns:
**		success?
**		(maybe this should be some other code than EX_
**		that denotes which stage failed.)
*/

static int
starttls(m, mci, e)
	MAILER *m;
	MCI *mci;
	ENVELOPE *e;
{
	int smtpresult;
	int result = 0;
	int rfd, wfd;
	SSL *clt_ssl = NULL;
	time_t tlsstart;

	if (clt_ctx == NULL && !initclttls(true))
		return EX_TEMPFAIL;

# if USE_OPENSSL_ENGINE
	if (!SSLEngineInitialized && !SSL_set_engine(NULL))
	{
		sm_syslog(LOG_ERR, NOQID,
			  "STARTTLS=client, SSL_set_engine=failed");
		return EX_TEMPFAIL;
	}
	SSLEngineInitialized = true;
# endif /* USE_OPENSSL_ENGINE */

	smtpmessage("STARTTLS", m, mci);

	/* get the reply */
	smtpresult = reply(m, mci, e, TimeOuts.to_starttls, NULL, NULL,
			XS_STARTTLS);

	/* check return code from server */
	if (REPLYTYPE(smtpresult) == 4)
		return EX_TEMPFAIL;
	if (smtpresult == 501)
		return EX_USAGE;
	if (smtpresult == -1)
		return smtpresult;

	/* not an expected reply but we have to deal with it */
	if (REPLYTYPE(smtpresult) == 5)
		return EX_UNAVAILABLE;
	if (smtpresult != 220)
		return EX_PROTOCOL;

	if (LogLevel > 13)
		sm_syslog(LOG_INFO, NOQID, "STARTTLS=client, start=ok");

	/* start connection */
	if ((clt_ssl = SSL_new(clt_ctx)) == NULL)
	{
		if (LogLevel > 5)
		{
			sm_syslog(LOG_ERR, NOQID,
				  "STARTTLS=client, error: SSL_new failed");
			if (LogLevel > 9)
				tlslogerr(LOG_WARNING, "client");
		}
		return EX_SOFTWARE;
	}

	rfd = sm_io_getinfo(mci->mci_in, SM_IO_WHAT_FD, NULL);
	wfd = sm_io_getinfo(mci->mci_out, SM_IO_WHAT_FD, NULL);

	/* SSL_clear(clt_ssl); ? */
	if (rfd < 0 || wfd < 0 ||
	    (result = SSL_set_rfd(clt_ssl, rfd)) != 1 ||
	    (result = SSL_set_wfd(clt_ssl, wfd)) != 1)
	{
		if (LogLevel > 5)
		{
			sm_syslog(LOG_ERR, NOQID,
				  "STARTTLS=client, error: SSL_set_xfd failed=%d",
				  result);
			if (LogLevel > 9)
				tlslogerr(LOG_WARNING, "client");
		}
		return EX_SOFTWARE;
	}
	SSL_set_connect_state(clt_ssl);
	tlsstart = curtime();

ssl_retry:
	if ((result = SSL_connect(clt_ssl)) <= 0)
	{
		int i, ssl_err;

		ssl_err = SSL_get_error(clt_ssl, result);
		i = tls_retry(clt_ssl, rfd, wfd, tlsstart,
			TimeOuts.to_starttls, ssl_err, "client");
		if (i > 0)
			goto ssl_retry;

		if (LogLevel > 5)
		{
			unsigned long l;
			const char *sr;

			l = ERR_peek_error();
			sr = ERR_reason_error_string(l);
			sm_syslog(LOG_WARNING, NOQID,
				  "STARTTLS=client, error: connect failed=%d, reason=%s, SSL_error=%d, errno=%d, retry=%d",
				  result, sr == NULL ? "unknown" : sr, ssl_err,
				  errno, i);
			if (LogLevel > 9)
				tlslogerr(LOG_WARNING, "client");
		}

		SSL_free(clt_ssl);
		clt_ssl = NULL;
		return EX_SOFTWARE;
	}
	mci->mci_ssl = clt_ssl;
	result = tls_get_info(mci->mci_ssl, false, mci->mci_host,
			      &mci->mci_macro, true);

	/* switch to use TLS... */
	if (sfdctls(&mci->mci_in, &mci->mci_out, mci->mci_ssl) == 0)
		return EX_OK;

	/* failure */
	SSL_free(clt_ssl);
	clt_ssl = NULL;
	return EX_SOFTWARE;
}
/*
**  ENDTLSCLT -- shutdown secure connection (client side)
**
**	Parameters:
**		mci -- the mailer connection info.
**
**	Returns:
**		success?
*/

static int
endtlsclt(mci)
	MCI *mci;
{
	int r;

	if (!bitset(MCIF_TLSACT, mci->mci_flags))
		return EX_OK;
	r = endtls(mci->mci_ssl, "client");
	mci->mci_flags &= ~MCIF_TLSACT;
	return r;
}
# endif /* STARTTLS */
# if STARTTLS || SASL
/*
**  ISCLTFLGSET -- check whether client flag is set.
**
**	Parameters:
**		e -- envelope.
**		flag -- flag to check in {client_flags}
**
**	Returns:
**		true iff flag is set.
*/

static bool
iscltflgset(e, flag)
	ENVELOPE *e;
	int flag;
{
	char *p;

	p = macvalue(macid("{client_flags}"), e);
	if (p == NULL)
		return false;
	for (; *p != '\0'; p++)
	{
		/* look for just this one flag */
		if (*p == (char) flag)
			return true;
	}
	return false;
}
# endif /* STARTTLS || SASL */
@


1.36
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.35
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2010, 2012 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.1028 2013/01/02 18:57:42 ca Exp $")
d2420 6
@


1.34
log
@Update to sendmail 8.14.6
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.1027 2012/12/19 02:49:21 ca Exp $")
d6156 1
a6156 1
				tlslogerr("client");
d6175 1
a6175 1
				tlslogerr("client");
d6205 1
a6205 1
				tlslogerr("client");
@


1.33
log
@Update to sendmail 8.14.5
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2010 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.1024 2011/01/12 23:52:59 ca Exp $")
d40 1
d4275 1
a4275 1
		e->e_msgpriority);
d6195 5
d6201 4
a6204 3
				  "STARTTLS=client, error: connect failed=%d, SSL_error=%d, errno=%d, retry=%d",
				  result, ssl_err, errno, i);
			if (LogLevel > 8)
@


1.32
log
@Update to sendmail-8.14.3
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2007 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.1015 2007/10/17 21:35:30 ca Exp $")
d578 1
a578 1
		dropenvelope(e, splitenv != NULL, true);
d583 1
a583 1
			dropenvelope(ee, false, true);
d605 1
a605 1
			dropenvelope(e, splitenv != NULL, false);
d618 1
a618 1
			dropenvelope(ee, false, false);
d765 1
a765 1
	dropenvelope(e, true, true);
d772 1
a772 1
		dropenvelope(ee, true, true);
d1394 1
a1394 1
	if (strlen(rpath) > MAXSHORTSTR)
d1853 1
a1853 1
	/* XXX this seems a bit wierd */
d2147 1
d2982 1
a2982 1
					**  TLS negotation failed, what to do?
d3025 1
a3025 1
			**  the TLS negotation failed
d3108 1
a3108 1
				mci->mci_flags &= ~MCIF_EXTENS;
d3161 1
a3161 1
						mci->mci_flags &= ~MCIF_EXTENS;
d6079 3
a6081 2
	tls_ok_clt = inittls(&clt_ctx, TLS_I_CLT, false, CltCertFile,
			     CltKeyFile, CACertPath, CACertFile, DHParams);
d6113 11
@


1.31
log
@Update to sendmail-8.14.1
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.1012 2007/03/29 21:20:15 ca Exp $")
d498 1
a498 1
			sm_dprintf("No deliveries: auto-queuing\n");
d3296 2
d3409 1
@


1.30
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2006 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.1010 2006/12/19 01:15:06 ca Exp $")
d1337 1
d1343 1
d1388 1
d3091 10
@


1.29
log
@Update to sendmail-8.13.8
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.1003.2.1 2006/05/23 01:32:08 ca Exp $")
a36 1
extern MCI	*mci_new __P((SM_RPOOL_T *));
d385 1
a385 1
							    sizeof *ee);
d886 1
a886 1
		(void) sm_snprintf(wbuf, sizeof wbuf, "sendall(%.*s)",
d961 1
a961 1
		if (sm_strlcpy(dir, filename, sizeof dir) >= sizeof dir)
d1014 2
a1015 2
	(void) sm_strlcpy(f1buf, queuename(e, type), sizeof f1buf);
	(void) sm_strlcpy(f2buf, queuename(ee, type), sizeof f2buf);
d1194 2
d1445 1
a1445 1
		expand(*mvp, buf, sizeof buf, e);
d1599 1
a1599 1
				e->e_id);
d1702 1
a1702 1
			expand(m->m_argv[1], buf, sizeof buf, e);
d1758 1
a1758 1
						  sizeof notify);
d1761 1
a1761 1
						  sizeof notify);
d1764 1
a1764 1
						  sizeof notify);
d1769 1
a1769 1
						  sizeof notify);
d1786 1
a1786 1
			expand(*mvp, buf, sizeof buf, e);
d1833 1
a1833 1
			expand(*mvp, buf, sizeof buf, e);
d1887 1
a1887 1
		(void) sm_snprintf(wbuf, sizeof wbuf, "%s... openmailer(%s)",
d2064 1
a2064 1
					  sizeof hostbuf);
d2102 1
a2102 1
						    hostbuf, sizeof hostbuf,
d2194 1
a2194 1
						    hostbuf, sizeof hostbuf, i))
d2531 1
a2531 1
				expand(m->m_rootdir, cbuf, sizeof cbuf, e);
d2668 1
a2668 1
					expand(p, cbuf, sizeof cbuf, e);
d2949 1
a2951 1
				host = macvalue(macid("{server_name}"), e);
d2956 2
a2957 1
					    RSF_RMCOMM, 7, host, NOQID) != EX_OK
d2959 1
d2961 1
d3031 1
a3031 1
				    host, NOQID) != EX_OK ||
d3048 1
a3048 1
							  sizeof enhsc);
d3086 1
a3086 1
						  sizeof SmtpError);
d3178 1
a3178 1
						  sizeof SmtpError);
d3240 1
a3240 1
		(void) sm_snprintf(SmtpError, sizeof SmtpError,
d3304 1
a3304 1
			(void) sm_snprintf(SmtpError, sizeof SmtpError,
d3344 1
a3344 1
					    mci->mci_host, e->e_id);
d3619 1
a3619 1
		(void) sm_snprintf(wbuf, sizeof wbuf,
d3763 1
a3763 1
		(void) sm_snprintf(buf, sizeof buf, "%d", rcode);
d3837 1
a3837 1
		while (sfgets(buf, sizeof buf, mci->mci_in,
d3987 1
a3987 1
			(void) sm_snprintf(buf, sizeof buf, "%s (%s)",
d3995 1
a3995 1
		(void) sm_snprintf(buf, sizeof buf,
d4061 1
a4061 1
		(void) sm_snprintf(buf, sizeof buf, "%s (%s)", exmsg + 1,
d4072 1
a4072 1
			(void) sm_snprintf(buf, sizeof buf, "%s: %s", statmsg,
d4079 1
a4079 1
			(void) sm_snprintf(buf, sizeof buf, "%s (%s)", statmsg,
d4098 1
a4098 1
				(void) sm_snprintf(dsnbuf, sizeof dsnbuf,
d4119 1
a4119 1
		    off < sizeof mbuf - 4)
d4123 1
a4123 1
				(void) sm_snprintf(dsnbuf, sizeof dsnbuf,
d4131 1
a4131 1
			(void) sm_strlcat(mbuf, " %s", sizeof mbuf);
d4136 1
a4136 1
			(void) sm_snprintf(mbuf, sizeof mbuf, "%.3s %%s",
d4322 1
a4322 1
	if ((bp - buf) > (sizeof buf - ((STATLEN) + 20)))
d4325 1
a4325 1
		bp = buf + sizeof buf - ((STATLEN) + 17);
d4441 1
a4441 1
			(void) sm_snprintf(buf, sizeof buf, "relay=%.100s", p);
d4488 1
a4488 1
		expand("\201g", buf, sizeof buf, e);
d4502 1
a4502 1
				expand("\201k", hname, sizeof hname, e);
d4507 1
a4507 1
			(void) sm_snprintf(xbuf, sizeof xbuf,
d4514 1
a4514 1
			(void) sm_snprintf(xbuf, sizeof xbuf,
d4520 1
a4520 1
	expand(template, buf, sizeof buf, e);
d4627 1
a4627 1
			(void) sm_snprintf(buf, sizeof buf,
d4695 1
a4695 1
		buflim = &buf[sizeof buf - 1];
d4697 1
a4697 1
		    mci->mci_mailer->m_linelimit < sizeof buf - 1)
d4843 1
d5143 1
a5143 1
		if (len + strlen(filename) + 1 >= sizeof targetfile)
d5149 1
a5149 1
		(void) sm_strlcpy(targetfile, SafeFileEnv, sizeof targetfile);
d5158 1
a5158 1
						  "/", sizeof targetfile);
d5160 1
a5160 1
					  sizeof targetfile);
d5165 1
a5165 1
		expand(mailer->m_rootdir, targetfile, sizeof targetfile, e);
d5171 1
a5171 1
		if (len + strlen(filename) + 1 >= sizeof targetfile)
d5179 1
a5179 1
			(void) sm_strlcat(targetfile, "/", sizeof targetfile);
d5182 1
a5182 1
					  sizeof targetfile);
d5185 1
a5185 1
					  sizeof targetfile);
d5189 2
a5190 2
		if (sm_strlcpy(targetfile, filename, sizeof targetfile) >=
		    sizeof targetfile)
d5468 1
a5468 1
				expand(p, buf, sizeof buf, e);
d5552 1
a5552 1
		memset(&mcibuf, '\0', sizeof mcibuf);
@


1.28
log
@fix bug which would make very deeply nested mime cause (essentially)
a stack overflow and thus make sendmail queue processing crash.  not
really exploitable to gain anything except denial of service.  vu#146718
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.1000 2006/03/02 01:37:39 ca Exp $")
d3130 2
d3138 1
d3141 1
a3141 1
						     mci->mci_conn) == 0)
d3967 1
d3969 3
d5227 8
a5234 2
			(void) close(sm_io_getinfo(e->e_lockfp, SM_IO_WHAT_FD,
				     NULL));
@


1.27
log
@Update to sendmail 8.13.6
@
text
@d4626 1
a4626 1
		if (mime8to7(mci, e->e_header, e, boundaries, M87F_OUTER) ==
d4657 1
a4657 1
				M87F_OUTER|M87F_NO8TO7) == SM_IO_EOF)
@


1.26
log
@update to sendmail 8.13.4
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2005 Sendmail, Inc. and its suppliers.
d15 1
a15 1
#include <sys/time.h>
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.986 2005/03/05 02:28:50 ca Exp $")
d1204 3
a1206 3
	**  If the host was not found and a FallbackSmartHost is defined
	**  (and we have not yet tried it), then make one last try with
	**  it as the host.
d1209 2
a1210 2
	if (status == EX_NOHOST && FallbackSmartHost != NULL &&
	    !*tried_fallbacksmarthost)
d2995 3
d3263 2
d3269 7
a3275 3
		putfromline(mci, e);
		(*e->e_puthdr)(mci, e->e_header, e, M87F_OUTER);
		(*e->e_putbody)(mci, e, NULL);
d3277 10
a3286 1
		/* get the exit status */
d3288 2
d4453 1
a4453 1
**		none
d4459 1
a4459 1
void
d4469 1
a4469 1
		return;
d4510 1
a4510 1
	putxline(buf, strlen(buf), mci, PXLF_HEADER);
d4512 1
d4523 1
a4523 1
**		none.
d4530 3
a4532 3
#define OS_HEAD		0	/* at beginning of line */
#define OS_CR		1	/* read a carriage return */
#define OS_INLINE	2	/* putting rest of line */
d4534 1
a4534 1
void
d4541 2
d4572 2
a4573 1
			putline("", mci);
d4576 2
a4577 1
		putline("<<< No Message Collected >>>", mci);
d4598 4
d4610 3
a4612 2
		if (hvalue("MIME-Version", e->e_header) == NULL)
			putline("MIME-Version: 1.0", mci);
d4619 2
a4620 1
			putline(buf, mci);
d4626 3
a4628 1
		(void) mime8to7(mci, e->e_header, e, boundaries, M87F_OUTER);
d4633 2
a4634 1
		(void) mime7to8(mci, e->e_header, e);
d4656 3
a4658 2
		(void) mime8to7(mci, e->e_header, e, boundaries,
				M87F_OUTER|M87F_NO8TO7);
d4678 2
a4679 1
			putline("", mci);
d4690 1
a4690 1
		ostate = OS_HEAD;
d4704 1
a4704 1
			  case OS_HEAD:
a4769 5
					else
					{
						/* record progress for DATA timeout */
						DataProgress = true;
					}
a4781 5
					else
					{
						/* record progress for DATA timeout */
						DataProgress = true;
					}
a4791 5
					else
					{
						/* record progress for DATA timeout */
						DataProgress = true;
					}
d4809 1
a4809 1
					ostate = OS_HEAD;
d4811 1
a4811 1
					ostate = OS_CR;
d4813 1
a4813 1
					ostate = OS_INLINE;
d4816 1
a4816 1
			  case OS_CR:
a4824 5
					else
					{
						/* record progress for DATA timeout */
						DataProgress = true;
					}
d4832 1
a4832 1
					ostate = OS_HEAD;
d4840 1
a4840 1
				ostate = OS_INLINE;
d4843 1
a4843 1
			  case OS_INLINE:
d4846 1
a4846 1
					ostate = OS_CR;
a4885 5
						else
						{
							/* record progress for DATA timeout */
							DataProgress = true;
						}
a4900 5
					else
					{
						/* record progress for DATA timeout */
						DataProgress = true;
					}
d4909 1
a4909 1
					ostate = OS_HEAD;
a4925 5
					else
					{
						/* record progress for DATA timeout */
						DataProgress = true;
					}
d4927 1
a4927 1
					ostate = OS_HEAD;
a4942 5
					else
					{
						/* record progress for DATA timeout */
						DataProgress = true;
					}
d4944 1
a4944 1
					ostate = OS_INLINE;
a4968 5
				else
				{
					/* record progress for DATA timeout */
					DataProgress = true;
				}
d4978 3
a4980 5
			(void) sm_io_fputs(mci->mci_out, SM_TIME_DEFAULT,
					   mci->mci_mailer->m_eol);

			/* record progress for DATA timeout */
			DataProgress = true;
d4990 1
d5005 1
d5012 4
a5015 1
		putline("", mci);
d5017 3
a5019 2
	(void) sm_io_flush(mci->mci_out, SM_TIME_DEFAULT);
	if (sm_io_error(mci->mci_out) && errno != EPIPE)
d5021 1
d5024 1
d5027 5
a5031 1
	errno = 0;
d5033 1
d5564 5
a5568 5
		putfromline(&mcibuf, e);
		(*e->e_puthdr)(&mcibuf, e->e_header, e, M87F_OUTER);
		(*e->e_putbody)(&mcibuf, e, NULL);
		putline("\n", &mcibuf);
		if (sm_io_flush(f, SM_TIME_DEFAULT) != 0 ||
d5571 1
a5571 1
		    sm_io_error(f))
d6084 1
a6084 1
	if (smtpresult == 454)
d6090 4
d6137 1
a6137 5
		int i;
		bool timedout;
		time_t left;
		time_t now = curtime();
		struct timeval tv;
d6139 5
a6143 2
		/* what to do in this case? */
		i = SSL_get_error(clt_ssl, result);
d6145 1
a6145 18
		/*
		**  For SSL_ERROR_WANT_{READ,WRITE}:
		**  There is not a complete SSL record available yet
		**  or there is only a partial SSL record removed from
		**  the network (socket) buffer into the SSL buffer.
		**  The SSL_connect will only succeed when a full
		**  SSL record is available (assuming a "real" error
		**  doesn't happen). To handle when a "real" error
		**  does happen the select is set for exceptions too.
		**  The connection may be re-negotiated during this time
		**  so both read and write "want errors" need to be handled.
		**  A select() exception loops back so that a proper SSL
		**  error message can be gotten.
		*/

		left = TimeOuts.to_starttls - (now - tlsstart);
		timedout = left <= 0;
		if (!timedout)
d6147 3
a6149 13
			tv.tv_sec = left;
			tv.tv_usec = 0;
		}

		if (!timedout && FD_SETSIZE > 0 &&
		    (rfd >= FD_SETSIZE ||
		     (i == SSL_ERROR_WANT_WRITE && wfd >= FD_SETSIZE)))
		{
			if (LogLevel > 5)
			{
				sm_syslog(LOG_ERR, e->e_id,
					  "STARTTLS=client, error: fd %d/%d too large",
					  rfd, wfd);
a6151 3
			}
			errno = EINVAL;
			goto tlsfail;
a6152 3
		if (!timedout && i == SSL_ERROR_WANT_READ)
		{
			fd_set ssl_maskr, ssl_maskx;
a6153 29
			FD_ZERO(&ssl_maskr);
			FD_SET(rfd, &ssl_maskr);
			FD_ZERO(&ssl_maskx);
			FD_SET(rfd, &ssl_maskx);
			if (select(rfd + 1, &ssl_maskr, NULL, &ssl_maskx, &tv)
			    > 0)
				goto ssl_retry;
		}
		if (!timedout && i == SSL_ERROR_WANT_WRITE)
		{
			fd_set ssl_maskw, ssl_maskx;

			FD_ZERO(&ssl_maskw);
			FD_SET(wfd, &ssl_maskw);
			FD_ZERO(&ssl_maskx);
			FD_SET(rfd, &ssl_maskx);
			if (select(wfd + 1, NULL, &ssl_maskw, &ssl_maskx, &tv)
			    > 0)
				goto ssl_retry;
		}
		if (LogLevel > 5)
		{
			sm_syslog(LOG_ERR, e->e_id,
				  "STARTTLS=client, error: connect failed=%d, SSL_error=%d, timedout=%d, errno=%d",
				  result, i, (int) timedout, errno);
			if (LogLevel > 8)
				tlslogerr("client");
		}
tlsfail:
@


1.26.4.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@a3259 2
		bool ok;

d3264 3
a3266 16
		rcode = EX_OK;
		errno = 0;
		ok = putfromline(mci, e);
		if (ok)
			ok = (*e->e_puthdr)(mci, e->e_header, e, M87F_OUTER);
		if (ok)
			ok = (*e->e_putbody)(mci, e, NULL);

		/*
		**  Ignore an I/O error that was caused by EPIPE.
		**  Some broken mailers don't read the entire body
		**  but just exit() thus causing an I/O error.
		*/

		if (!ok && (sm_io_error(mci->mci_out) && errno == EPIPE))
			ok = true;
d3268 1
a3268 1
		/* (always) get the exit status */
a3269 2
		if (!ok)
			rcode = EX_TEMPFAIL;
d4433 1
a4433 1
**		true iff line was written successfully
d4439 1
a4439 1
bool
d4449 1
a4449 1
		return true;
d4490 1
a4490 1
	return putxline(buf, strlen(buf), mci, PXLF_HEADER);
a4491 1

d4502 1
a4502 1
**		true iff message was written successfully
d4513 1
a4513 1
bool
a4519 2
	bool ioerr = false;
	int save_errno;
d4549 1
a4549 2
			if (!putline("", mci))
				goto writeerr;
d4552 1
a4552 2
		if (!putline("<<< No Message Collected >>>", mci))
			goto writeerr;
d4581 2
a4582 3
		if (hvalue("MIME-Version", e->e_header) == NULL &&
		    !putline("MIME-Version: 1.0", mci))
			goto writeerr;
d4589 1
a4589 2
			if (!putline(buf, mci))
				goto writeerr;
d4595 1
a4595 3
		if (mime8to7(mci, e->e_header, e, boundaries, M87F_OUTER) ==
								SM_IO_EOF)
			goto writeerr;
d4600 1
a4600 2
		if (!mime7to8(mci, e->e_header, e))
			goto writeerr;
d4622 2
a4623 3
		if (mime8to7(mci, e->e_header, e, boundaries,
				M87F_OUTER|M87F_NO8TO7) == SM_IO_EOF)
			goto writeerr;
d4643 1
a4643 2
			if (!putline("", mci))
				goto writeerr;
d4734 5
d4751 5
d4766 5
d4804 5
d4870 5
d4890 5
d4920 5
d4942 5
d4973 5
d4987 5
a4991 3
			if (sm_io_fputs(mci->mci_out, SM_TIME_DEFAULT,
					   mci->mci_mailer->m_eol) == SM_IO_EOF)
				goto writeerr;
a5000 1
		ioerr = true;
a5014 1
	save_errno = errno;
d5021 1
a5021 4
	{
		if (!putline("", mci))
			goto writeerr;
	}
d5023 2
a5024 3
	if (!dead &&
	    (sm_io_flush(mci->mci_out, SM_TIME_DEFAULT) == SM_IO_EOF ||
	     (sm_io_error(mci->mci_out) && errno != EPIPE)))
a5025 1
		save_errno = errno;
a5027 1
		ioerr = true;
d5030 1
a5030 5
	errno = save_errno;
	return !dead && !ioerr;

  writeerr:
	return false;
a5031 1

d5562 5
a5566 5
		if (!putfromline(&mcibuf, e) ||
		    !(*e->e_puthdr)(&mcibuf, e->e_header, e, M87F_OUTER) ||
		    !(*e->e_putbody)(&mcibuf, e, NULL) ||
		    !putline("\n", &mcibuf) ||
		    (sm_io_flush(f, SM_TIME_DEFAULT) != 0 ||
d5569 1
a5569 1
		    sm_io_error(f)))
d6131 5
a6135 1
		int i, ssl_err;
d6137 2
a6138 5
		ssl_err = SSL_get_error(clt_ssl, result);
		i = tls_retry(clt_ssl, rfd, wfd, tlsstart,
			TimeOuts.to_starttls, ssl_err, "client");
		if (i > 0)
			goto ssl_retry;
d6140 62
d6204 3
a6206 3
			sm_syslog(LOG_WARNING, NOQID,
				  "STARTTLS=client, error: connect failed=%d, SSL_error=%d, errno=%d, retry=%d",
				  result, ssl_err, errno, i);
d6210 1
a6210 1

@


1.26.4.2
log
@MFC:
Fix by deraadt@@

fix bug which would make very deeply nested mime cause (essentially)
a stack overflow and thus make sendmail queue processing crash.  not
really exploitable to gain anything except denial of service.  vu#146718
@
text
@d4619 1
a4619 1
		if (mime8to7(mci, e->e_header, e, boundaries, M87F_OUTER, 0) ==
d4650 1
a4650 1
				M87F_OUTER|M87F_NO8TO7, 0) == SM_IO_EOF)
@


1.26.2.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@a3259 2
		bool ok;

d3264 3
a3266 16
		rcode = EX_OK;
		errno = 0;
		ok = putfromline(mci, e);
		if (ok)
			ok = (*e->e_puthdr)(mci, e->e_header, e, M87F_OUTER);
		if (ok)
			ok = (*e->e_putbody)(mci, e, NULL);

		/*
		**  Ignore an I/O error that was caused by EPIPE.
		**  Some broken mailers don't read the entire body
		**  but just exit() thus causing an I/O error.
		*/

		if (!ok && (sm_io_error(mci->mci_out) && errno == EPIPE))
			ok = true;
d3268 1
a3268 1
		/* (always) get the exit status */
a3269 2
		if (!ok)
			rcode = EX_TEMPFAIL;
d4433 1
a4433 1
**		true iff line was written successfully
d4439 1
a4439 1
bool
d4449 1
a4449 1
		return true;
d4490 1
a4490 1
	return putxline(buf, strlen(buf), mci, PXLF_HEADER);
a4491 1

d4502 1
a4502 1
**		true iff message was written successfully
d4513 1
a4513 1
bool
a4519 2
	bool ioerr = false;
	int save_errno;
d4549 1
a4549 2
			if (!putline("", mci))
				goto writeerr;
d4552 1
a4552 2
		if (!putline("<<< No Message Collected >>>", mci))
			goto writeerr;
d4581 2
a4582 3
		if (hvalue("MIME-Version", e->e_header) == NULL &&
		    !putline("MIME-Version: 1.0", mci))
			goto writeerr;
d4589 1
a4589 2
			if (!putline(buf, mci))
				goto writeerr;
d4595 1
a4595 3
		if (mime8to7(mci, e->e_header, e, boundaries, M87F_OUTER) ==
								SM_IO_EOF)
			goto writeerr;
d4600 1
a4600 2
		if (!mime7to8(mci, e->e_header, e))
			goto writeerr;
d4622 2
a4623 3
		if (mime8to7(mci, e->e_header, e, boundaries,
				M87F_OUTER|M87F_NO8TO7) == SM_IO_EOF)
			goto writeerr;
d4643 1
a4643 2
			if (!putline("", mci))
				goto writeerr;
d4734 5
d4751 5
d4766 5
d4804 5
d4870 5
d4890 5
d4920 5
d4942 5
d4973 5
d4987 5
a4991 3
			if (sm_io_fputs(mci->mci_out, SM_TIME_DEFAULT,
					   mci->mci_mailer->m_eol) == SM_IO_EOF)
				goto writeerr;
a5000 1
		ioerr = true;
a5014 1
	save_errno = errno;
d5021 1
a5021 4
	{
		if (!putline("", mci))
			goto writeerr;
	}
d5023 2
a5024 3
	if (!dead &&
	    (sm_io_flush(mci->mci_out, SM_TIME_DEFAULT) == SM_IO_EOF ||
	     (sm_io_error(mci->mci_out) && errno != EPIPE)))
a5025 1
		save_errno = errno;
a5027 1
		ioerr = true;
d5030 1
a5030 5
	errno = save_errno;
	return !dead && !ioerr;

  writeerr:
	return false;
a5031 1

d5562 5
a5566 5
		if (!putfromline(&mcibuf, e) ||
		    !(*e->e_puthdr)(&mcibuf, e->e_header, e, M87F_OUTER) ||
		    !(*e->e_putbody)(&mcibuf, e, NULL) ||
		    !putline("\n", &mcibuf) ||
		    (sm_io_flush(f, SM_TIME_DEFAULT) != 0 ||
d5569 1
a5569 1
		    sm_io_error(f)))
d6131 5
a6135 1
		int i, ssl_err;
d6137 2
a6138 5
		ssl_err = SSL_get_error(clt_ssl, result);
		i = tls_retry(clt_ssl, rfd, wfd, tlsstart,
			TimeOuts.to_starttls, ssl_err, "client");
		if (i > 0)
			goto ssl_retry;
d6140 62
d6204 3
a6206 3
			sm_syslog(LOG_WARNING, NOQID,
				  "STARTTLS=client, error: connect failed=%d, SSL_error=%d, errno=%d, retry=%d",
				  result, ssl_err, errno, i);
d6210 1
a6210 1

@


1.26.2.2
log
@MFC:
Fix by deraadt@@

fix bug which would make very deeply nested mime cause (essentially)
a stack overflow and thus make sendmail queue processing crash.  not
really exploitable to gain anything except denial of service.  vu#146718
@
text
@d4619 1
a4619 1
		if (mime8to7(mci, e->e_header, e, boundaries, M87F_OUTER, 0) ==
d4650 1
a4650 1
				M87F_OUTER|M87F_NO8TO7, 0) == SM_IO_EOF)
@


1.25
log
@update to sendmail 8.13.3
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.983 2005/01/07 17:43:22 ca Exp $")
d4270 10
d5685 4
@


1.25.2.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@a3259 2
		bool ok;

d3264 3
a3266 16
		rcode = EX_OK;
		errno = 0;
		ok = putfromline(mci, e);
		if (ok)
			ok = (*e->e_puthdr)(mci, e->e_header, e, M87F_OUTER);
		if (ok)
			ok = (*e->e_putbody)(mci, e, NULL);

		/*
		**  Ignore an I/O error that was caused by EPIPE.
		**  Some broken mailers don't read the entire body
		**  but just exit() thus causing an I/O error.
		*/

		if (!ok && (sm_io_error(mci->mci_out) && errno == EPIPE))
			ok = true;
d3268 1
a3268 1
		/* (always) get the exit status */
a3269 2
		if (!ok)
			rcode = EX_TEMPFAIL;
d4423 1
a4423 1
**		true iff line was written successfully
d4429 1
a4429 1
bool
d4439 1
a4439 1
		return true;
d4480 1
a4480 1
	return putxline(buf, strlen(buf), mci, PXLF_HEADER);
a4481 1

d4492 1
a4492 1
**		true iff message was written successfully
d4503 1
a4503 1
bool
a4509 2
	bool ioerr = false;
	int save_errno;
d4539 1
a4539 2
			if (!putline("", mci))
				goto writeerr;
d4542 1
a4542 2
		if (!putline("<<< No Message Collected >>>", mci))
			goto writeerr;
d4571 2
a4572 3
		if (hvalue("MIME-Version", e->e_header) == NULL &&
		    !putline("MIME-Version: 1.0", mci))
			goto writeerr;
d4579 1
a4579 2
			if (!putline(buf, mci))
				goto writeerr;
d4585 1
a4585 3
		if (mime8to7(mci, e->e_header, e, boundaries, M87F_OUTER) ==
								SM_IO_EOF)
			goto writeerr;
d4590 1
a4590 2
		if (!mime7to8(mci, e->e_header, e))
			goto writeerr;
d4612 2
a4613 3
		if (mime8to7(mci, e->e_header, e, boundaries,
				M87F_OUTER|M87F_NO8TO7) == SM_IO_EOF)
			goto writeerr;
d4633 1
a4633 2
			if (!putline("", mci))
				goto writeerr;
d4724 5
d4741 5
d4756 5
d4794 5
d4860 5
d4880 5
d4910 5
d4932 5
d4963 5
d4977 5
a4981 3
			if (sm_io_fputs(mci->mci_out, SM_TIME_DEFAULT,
					   mci->mci_mailer->m_eol) == SM_IO_EOF)
				goto writeerr;
a4990 1
		ioerr = true;
a5004 1
	save_errno = errno;
d5011 1
a5011 4
	{
		if (!putline("", mci))
			goto writeerr;
	}
d5013 2
a5014 3
	if (!dead &&
	    (sm_io_flush(mci->mci_out, SM_TIME_DEFAULT) == SM_IO_EOF ||
	     (sm_io_error(mci->mci_out) && errno != EPIPE)))
a5015 1
		save_errno = errno;
a5017 1
		ioerr = true;
d5020 1
a5020 5
	errno = save_errno;
	return !dead && !ioerr;

  writeerr:
	return false;
a5021 1

d5552 5
a5556 5
		if (!putfromline(&mcibuf, e) ||
		    !(*e->e_puthdr)(&mcibuf, e->e_header, e, M87F_OUTER) ||
		    !(*e->e_putbody)(&mcibuf, e, NULL) ||
		    !putline("\n", &mcibuf) ||
		    (sm_io_flush(f, SM_TIME_DEFAULT) != 0 ||
d5559 1
a5559 1
		    sm_io_error(f)))
d6117 5
a6121 1
		int i, ssl_err;
d6123 2
a6124 5
		ssl_err = SSL_get_error(clt_ssl, result);
		i = tls_retry(clt_ssl, rfd, wfd, tlsstart,
			TimeOuts.to_starttls, ssl_err, "client");
		if (i > 0)
			goto ssl_retry;
d6126 62
d6190 3
a6192 3
			sm_syslog(LOG_WARNING, NOQID,
				  "STARTTLS=client, error: connect failed=%d, SSL_error=%d, errno=%d, retry=%d",
				  result, ssl_err, errno, i);
d6196 1
a6196 1

@


1.24
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.981 2004/09/30 18:28:32 ca Exp $")
a2902 11
		/*
		**  If a cached connection gave a 421 reply to the
		**  RSET, the connection will be closed by now.
		*/

		if (mci->mci_state == MCIS_CLOSED)
		{
			rcode = EX_TEMPFAIL;
			goto give_up;
		}

d3801 1
d3803 2
d3831 1
d3833 2
a3834 1
	mci->mci_in = mci->mci_out = NULL;
@


1.23
log
@Update to sendmail-8.13.1
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.976 2004/07/23 20:45:01 gshapiro Exp $")
a30 1
void		markfailure __P((ENVELOPE *, ADDRESS *, MCI *, int, bool));
d33 2
a34 1
static void	mailfiletimeout __P((void));
d1662 1
a1662 1
		**  Strip one leading backslash if requested and the
d2903 11
d3783 2
a3784 1
endwaittimeout()
d4016 1
a4016 1
				if (mci->mci_host != NULL)
d5616 2
a5617 1
mailfiletimeout()
@


1.22
log
@Update to sendmail.8.13.0
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.973 2004/06/03 18:21:44 ca Exp $")
d1180 44
a1284 7
#ifndef NO_UID
# define NO_UID		-1
#endif /* ! NO_UID */
#ifndef NO_GID
# define NO_GID		-1
#endif /* ! NO_GID */

d2098 7
d2191 4
a2194 6
				/*
				**  If the host was not found and a Fallback-
				**  SmartHost is defined (and we have not yet
				**  tried it), then make one last try with it
				**  as the host.
				*/
a2195 15
				if (i == EX_NOHOST &&
				    FallbackSmartHost != NULL &&
				    !tried_fallbacksmarthost)
				{
					tried_fallbacksmarthost = true;
					expand(FallbackSmartHost, hostbuf,
					       sizeof hostbuf, e);
					if (!wordinclass(hostbuf, 'w'))
					{
						if (tTd(11, 1))
							sm_dprintf("one last try with FallbackSmartHost %s",
								   hostbuf);
						goto one_last_try;
					}
				}
d2436 6
a2441 1
				new_gid = m->m_gid;
d2500 1
a2500 1
				if (m->m_gid == 0)
d2552 4
a2555 1
				new_euid = m->m_uid;
d2585 1
a2585 1
			else if (m->m_uid != 0)
d5263 4
a5266 1
				RealUid = mailer->m_uid;
d5288 1
a5288 1
			else if (mailer != NULL && mailer->m_uid != 0)
d5302 4
a5305 1
				RealGid = mailer->m_gid;
d5334 1
a5334 1
			else if (mailer != NULL && mailer->m_gid != 0)
@


1.21
log
@Update to sendmail 8.12.11.  I've been runninga beta version of this for
some time without problems.  See the RELEASE_NOTES for the change log.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.940.2.20 2003/09/26 18:26:19 ca Exp $")
d126 1
a126 1
		printaddr(&e->e_from, false);
d130 1
a130 1
		printaddr(e->e_sendqueue, true);
d187 1
a187 1
			printaddr(&e->e_from, false);
d218 1
a218 1
		printaddr(e->e_sendqueue, true);
d236 1
a236 1
				printaddr(q, false);
d247 1
a247 1
				printaddr(q, false);
d307 2
a308 2
				if (FallBackMX != NULL &&
				    !wordinclass(FallBackMX, 'w') &&
d319 1
a319 1
						sm_dprintf("    ... FallBackMX\n");
d321 1
a321 1
					len = strlen(FallBackMX) + 1;
d323 1
a323 1
					(void) sm_strlcpy(p, FallBackMX, len);
a361 1
#if _FFR_QUARANTINE
a370 1
#endif /* _FFR_QUARANTINE */
d408 1
a408 1
				printaddr(&ee->e_from, false);
a418 1
#if _FFR_QUARANTINE
a421 1
#endif /* _FFR_QUARANTINE */
d484 1
a484 1
			printaddr(&e->e_from, false);
d516 3
a518 1
	     (mode != SM_VERIFY && SuperSafe == SAFE_REALLY)) &&
d556 1
a556 1
			printaddr(e->e_sendqueue, true);
d561 1
a561 1
				printaddr(ee->e_sendqueue, true);
d624 1
a954 1
#if _FFR_REQ_DIR_FSYNC_OPT
a956 1
#endif /* _FFR_REQ_DIR_FSYNC_OPT */
a1283 1
#if _FFR_QUARANTINE
a1284 1
#endif /* _FFR_QUARANTINE */
d1325 1
d1368 4
d1510 1
a1510 1
			printaddr(to, false);
d1524 1
a1524 1
			printaddr(ctladdr, false);
a1557 1
#if _FFR_QUARANTINE
a1558 1
#endif /* _FFR_QUARANTINE */
a1577 1
#if _FFR_QUARANTINE
a1589 1
#endif /* _FFR_QUARANTINE */
d1595 1
a1595 1
				printaddr(to, false);
d1623 1
a1623 1
#if _FFR_STRIPBACKSL
a1631 1
#endif /* _FFR_STRIPBACKSL */
d1825 1
a1825 1
		printav(pv);
a1876 1
#if _FFR_CACHE_LPC
a1909 7
#else /* _FFR_CACHE_LPC */
		mci = mci_new(e->e_rpool);
		mci->mci_in = smioin;
		mci->mci_out = smioout;
		mci->mci_state = clever ? MCIS_OPENING : MCIS_OPEN;
		mci->mci_mailer = m;
#endif /* _FFR_CACHE_LPC */
d1979 1
d2031 1
d2042 1
a2042 1
					mci_dump(mci, false);
d2113 1
a2113 1
				extern int NumFallBackMXHosts;
d2115 1
a2115 1
				const int NumFallBackMXHosts = 0;
d2123 1
a2123 1
				if (NumFallBackMXHosts > 0)
d2127 1
a2127 1
				h = nummxhosts - NumFallBackMXHosts;
d2147 22
a2333 1
			int i;
d2692 1
a2692 8
			for (i = 3; i < DtableSize; i++)
			{
				register int j;

				if ((j = fcntl(i, F_GETFD, 0)) != -1)
					(void) fcntl(i, F_SETFD,
						     j | FD_CLOEXEC);
			}
d2749 1
a2749 1
					  (void *) &(mpvect[1]), SM_IO_WRONLY,
d2764 1
a2764 1
					 (void *) &(rpvect[0]), SM_IO_RDONLY,
d3124 1
a3124 1
				mci_setstat(mci, rcode, "4.7.1", p);
d3168 1
a3168 1
		mci_dump(mci, false);
d3214 1
a3214 1
			mci_dump_all(true);
a4202 1
#if _FFR_QUARANTINE
a4209 1
#endif /* _FFR_QUARANTINE */
a4347 1
#if _FFR_QUARANTINE
a4354 1
#endif /* _FFR_QUARANTINE */
d5038 1
a5038 1
		printaddr(ctladdr, false);
d6016 2
a6017 1
	smtpresult = reply(m, mci, e, TimeOuts.to_starttls, NULL, NULL);
@


1.20
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.940.2.19 2003/09/03 19:58:26 ca Exp $")
d3494 1
d3496 4
@


1.19
log
@Update to sendmail 8.12.9; fixes a buffer overflow in address parsing
due to a char to int conversion problem which is potentially remotely
exploitable.
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.940.2.18 2003/03/28 17:34:39 ca Exp $")
d4479 1
a4479 1
				      SM_IO_RDONLY, NULL);
d5210 1
a5210 1
					      SM_IO_RDONLY, NULL);
@


1.18
log
@Update to Sendmail 8.12.8; fixes a buffer overflow in the envelope
comments processing which may allow an attacker to gain root privileges.
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.940.2.15 2003/02/07 17:57:43 ca Exp $")
d1161 1
a1161 1
		else if (*a == '[' && braclev > 0)
d1629 1
a1629 1
		**  Strip one leading backslash if requesting and the
d4722 3
d4726 1
d4766 1
d4795 3
d4799 1
d4849 2
@


1.17
log
@update to sendmail 8.12.7
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.940.2.10 2002/12/12 22:46:34 ca Exp $")
d6127 2
a6128 2
				  "STARTTLS=client, error: connect failed=%d, SSL_error=%d, timedout=%d",
				  result, i, (int) timedout);
@


1.16
log
@update to sendmail-8.12.6
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.940.2.3 2002/08/16 14:56:01 ca Exp $")
a625 1

d956 5
d1627 10
d2369 1
d2376 4
d2382 1
a2382 1
						   LOGIN_SETRESOURCES|LOGIN_SETPRIORITY) == -1 &&
d5965 2
a5966 2
	tls_ok_clt = inittls(&clt_ctx, TLS_I_CLT, false, CltCERTfile,
			     Cltkeyfile, CACERTpath, CACERTfile, DHParams);
d6085 15
d6132 1
@


1.16.2.1
log
@Errata #14
Fix by millert@@
Fix a buffer overflow in address parsing due to a char to int conversion
problem which is potentially remotely exploitable.
@
text
@d1157 1
a1157 1
		else if (*a == ']' && braclev > 0)
a4702 3
					{
						SM_ASSERT(pbp < peekbuf +
								sizeof(peekbuf));
a4703 1
					}
a4742 1
				SM_ASSERT(pbp < peekbuf + sizeof(peekbuf));
a4770 3
					{
						SM_ASSERT(pbp < peekbuf +
									sizeof(peekbuf));
a4771 1
					}
a4820 2
					SM_ASSERT(pbp < peekbuf +
							sizeof(peekbuf));
@


1.15
log
@Exit if setusercontext() fails to set resources/priority and suidwarn
is true.  This is consistent with sendmail's behavior when things like
initgroups() fail.
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.940 2002/06/06 00:03:16 gshapiro Exp $")
d1558 2
a1559 1
				e, true, true, 3, NULL, e->e_id);
d2361 4
a2364 3
				if (pwd != NULL && setusercontext(NULL, pwd,
				    pwd->pw_uid, LOGIN_SETRESOURCES | 
				    LOGIN_SETPRIORITY) == -1 && suidwarn)
d2897 2
a2898 2
				if (rscheck("try_tls", host, NULL, e, true,
					    false, 7, host, NOQID) != EX_OK
d2966 2
a2967 2
				    NULL, e, true, true, 5, host,
				    NOQID) != EX_OK ||
d3259 2
a3260 2
					    true, true, 3, mci->mci_host,
					    e->e_id);
@


1.14
log
@Fix SuperSafe=Interactive when DeliveryMode=i; Gregory Neil Shapiro
@
text
@d2360 7
a2366 4
				if (pwd != NULL)
					(void) setusercontext(NULL,
							      pwd, pwd->pw_uid,
							      LOGIN_SETRESOURCES|LOGIN_SETPRIORITY);
@


1.13
log
@sendmail 8.12.5
@
text
@d1016 10
@


1.12
log
@Update to sendmail-8.12.4
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.939 2002/05/25 00:46:00 gshapiro Exp $")
d3285 1
a3285 1
					giveresponse(i, to->q_status,  m, mci,
@


1.11
log
@update to sendmail 8.12.3
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.935 2002/03/23 18:30:40 gshapiro Exp $")
d1287 1
d2454 1
a2454 1
				expand(m->m_rootdir, buf, sizeof buf, e);
d2457 2
a2458 2
						   buf);
				if (chroot(buf) < 0)
d2461 1
a2461 1
						buf);
d2588 1
a2588 1
					expand(p, buf, sizeof buf, e);
d2593 3
a2595 2
							   buf);
					if (buf[0] != '\0' && chdir(buf) >= 0)
d3034 3
d3038 1
d4983 2
a4984 2
	char buf[MAXLINE + 1];
	char targetfile[MAXPATHLEN + 1];
@


1.10
log
@Use LOGIN_SETLOGIN flag to setsuercontext() so the user name gets
set properly to the user commands will be run on behalf of.
Bug report and different patch from Peter Philipp.
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.928 2002/01/10 03:23:29 gshapiro Exp $")
d23 4
d2119 1
d2338 1
a2338 1
			**  Set user resources and login name.
d2352 1
a2352 1
							      LOGIN_SETRESOURCES|LOGIN_SETPRIORITY|LOGIN_SETLOGIN);
a2354 11
# if HASSETLOGIN && !HASSETUSERCONTEXT
			/* set login name */
			if (ctladdr != NULL)
			{
				user = ctladdr->q_ruser;
				if (user == NULL)
					user = ctladdr->q_user;
				(void)setlogin(user);

			}
# endif /* HASSETLOGIN && !!HASSETUSERCONTEXT*/
d2509 16
d2655 1
d2658 1
d3957 7
a5030 2
		if (targetfile[len - 1] != '/')
			(void) sm_strlcat(targetfile, "/", sizeof targetfile);
d5033 9
a5041 1
		(void) sm_strlcat(targetfile, filename, sizeof targetfile);
d5084 8
d5281 3
d5293 1
a5293 1
			*realfile = '/';
@


1.10.2.1
log
@Errata #027 (millert)
Fix a buffer overflow in address parsing due to a char to int conversion
problem which is potentially remotely exploitable.
@
text
@d1143 1
a1143 1
		else if (*a == ']' && braclev > 0)
a4662 3
					{
						SM_ASSERT(pbp < peekbuf +
								sizeof(peekbuf));
a4663 1
					}
a4702 1
				SM_ASSERT(pbp < peekbuf + sizeof(peekbuf));
a4730 3
					{
						SM_ASSERT(pbp < peekbuf +
									sizeof(peekbuf));
a4731 1
					}
a4780 2
					SM_ASSERT(pbp < peekbuf +
							sizeof(peekbuf));
@


1.9
log
@update to sendmail-8.12.2
@
text
@d2333 1
a2333 1
			**  Set user resources.
d2347 1
a2347 1
							      LOGIN_SETRESOURCES|LOGIN_SETPRIORITY);
d2350 11
@


1.8
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.907 2001/09/18 21:45:33 gshapiro Exp $")
d91 1
a91 1
		markstats(e, NULL, true);
d306 1
d309 1
a309 1
				    strcmp(m->m_argv[0], "TCP"))
d359 2
a360 2
			else if (QueueMode != QM_HELD &&
				 e->e_holdmsg != NULL)
d364 1
a364 1
						   e->e_holdmsg);
d417 5
d670 1
d673 1
d699 1
d705 1
d723 1
a723 1
			finis(true, ExitStat);
d759 1
a759 1
		finis(true, ExitStat);
d777 1
a777 1
		finis(true, ExitStat);
d850 7
a856 1
		(void) split_by_recipient(e);
d1269 3
d1341 4
a1344 1
		syserr("remotename: huge return %s", rpath);
d1539 3
d1560 14
d1667 1
a1667 1
			markstats(e, to, false);
d2302 2
a2311 1
			CurrentPid = getpid();
d2351 1
d2355 1
d2431 3
a2433 1
					syserr("openmailer: insufficient privileges to change gid");
d2509 2
a2510 1
					syserr("openmailer: insufficient privileges to change uid");
d3105 31
a3218 2
					/* avoid bogus error msg */
					errno = 0;
d3233 2
a3234 1
				if (bitset(MCIF_PIPELINED, mci->mci_flags))
d3437 7
d3457 1
d3460 1
a3460 1
		markstats(e, tochain, false);
d3537 1
d3638 3
d4125 9
d4272 9
d4981 1
d5133 2
a5134 1
					syserr("mailfile: insufficient privileges to change uid");
d5171 3
a5173 1
					syserr("mailfile: insufficient privileges to change gid");
d5445 2
d5448 1
d5522 2
a5523 1
	    strcmp(m->m_mailer, "[IPC]") != 0)
@


1.7
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.899 2001/09/08 01:21:09 gshapiro Exp $")
d357 11
d449 1
a449 1
				dup_queue_file(e, ee, 'd');
d917 1
a917 1
/*
d968 1
a968 1
/*
d974 1
a974 1
**		type -- the queue file type (e.g., 'd')
d1019 1
a1019 1
/*
d1060 1
a1060 1
/*
d1084 1
a1084 1
/*
d1149 1
a1149 1
/*
d1229 1
a1229 1
# if HASSETUSERCONTEXT
d1231 1
a1231 1
# endif /* HASSETUSERCONTEXT */
d2642 1
a2642 1
					  (void *) mpvect[1], SM_IO_WRONLY,
d2657 1
a2657 1
					 (void *) rpvect[0], SM_IO_RDONLY,
d2710 5
d2717 1
a2717 1
			srvname = "";
d2720 2
d2727 1
d2731 8
d2740 2
d2743 2
a2744 1
				  macid("{server_addr}"), NULL);
d3427 1
a3427 1
/*
d3555 1
a3555 1
/*
d3699 1
a3699 1
/*
d3940 1
a3940 1
/*
d4188 1
a4188 1
/*
d4262 1
a4262 1
/*
d4301 1
a4301 1
		char *df = queuename(e, 'd');
d4340 1
a4340 1
	/* paranoia: the df file should always be in a rewound state */
d4756 3
a4758 2
		syserr("putbody: %s/df%s: read error",
		       qid_printqueue(e->e_dfqgrp, e->e_dfqdir), e->e_id);
d4791 1
a4791 1
/*
d5003 1
a5003 1
		/* we have to open the dfile BEFORE setuid() */
d5006 1
a5006 1
			char *df = queuename(e, 'd');
d5360 1
a5360 1
/*
d5603 1
a5603 1
/*
d5721 1
a5721 1
/*
d5741 1
a5741 1
/*
d5770 1
a5770 1
/*
d5934 1
a5934 1
/*
d5958 1
a5958 1
/*
@


1.6
log
@update to sendmail 8.11.5
@
text
@a13 4
#ifndef lint
static char id[] = "@@(#)$Sendmail: deliver.c,v 8.600.2.1.2.86 2001/07/20 21:52:55 gshapiro Exp $";
#endif /* ! lint */

d15 1
d17 1
d23 1
a23 1
#if STARTTLS || (SASL && SFIO)
d25 1
a25 1
#endif /* STARTTLS || (SASL && SFIO) */
d27 1
a30 1
static void	markfailure __P((ENVELOPE *, ADDRESS *, MCI *, int, bool));
d33 2
a34 1
static char	*hostsignature __P((MAILER *, char *));
d36 1
a36 2
#if SMTP
# if STARTTLS
d38 5
a42 2
# endif /* STARTTLS */
#endif /* SMTP */
d74 1
a74 1
	bool somedeliveries = FALSE, expensive = FALSE;
d85 1
a85 1
			dprintf("sendall: discarding id %s\n", e->e_id);
d87 3
a89 1
		if (LogLevel > 4)
d91 1
a91 1
		markstats(e, NULL, TRUE);
d120 1
a120 1
		dprintf("\n===== SENDALL: mode %c, id %s, e_from ",
d122 2
a123 2
		printaddr(&e->e_from, FALSE);
		dprintf("\te_flags = ");
d125 2
a126 2
		dprintf("sendqueue:\n");
		printaddr(e->e_sendqueue, TRUE);
d150 1
a150 3
#if QUEUE
		queueup(e, mode == SM_QUEUE || mode == SM_DEFER);
#endif /* QUEUE */
d182 2
a183 2
			dprintf("sendall: QS_SENDER ");
			printaddr(&e->e_from, FALSE);
d213 2
a214 2
		dprintf("\nAfter first owner pass, sendq =\n");
		printaddr(e->e_sendqueue, TRUE);
d222 2
a223 2
			dprintf("owner = \"%s\", otherowners = %d\n",
				owner, otherowners);
d231 2
a232 2
				dprintf("Checking ");
				printaddr(q, FALSE);
d237 1
a237 1
					dprintf("    ... QS_IS_DEAD\n");
d242 2
a243 2
				dprintf("Checking ");
				printaddr(q, FALSE);
d251 2
a252 2
						dprintf("    ... First owner = \"%s\"\n",
							q->q_owner);
d260 2
a261 2
							dprintf("    ... Same owner = \"%s\"\n",
								owner);
d269 2
a270 2
							dprintf("    ... Another owner \"%s\"\n",
								q->q_owner);
d276 2
a277 2
					dprintf("    ... Same owner = \"%s\"\n",
						owner);
d282 1
a282 1
					dprintf("    ... Null owner\n");
d289 1
a289 1
					dprintf("    ... QS_IS_BADADDR\n");
d306 1
a306 2
				    (strcmp(m->m_mailer, "[IPC]") == 0 ||
				     strcmp(m->m_mailer, "[TCP]") == 0) &&
d308 1
a308 2
				    (strcmp(m->m_argv[0], "TCP") == 0 ||
				     strcmp(m->m_argv[0], "IPC") == 0))
d314 1
a314 1
						dprintf("    ... FallBackMX\n");
d316 3
a318 3
					len = strlen(FallBackMX) + 3;
					p = xalloc(len);
					snprintf(p, len, "[%s]", FallBackMX);
d325 1
a325 1
						dprintf("    ... QS_IS_QUEUEUP\n");
d343 1
a343 1
					dprintf("    ... expensive\n");
d345 1
a345 1
				expensive = TRUE;
d353 1
a353 1
					dprintf("    ... hold\n");
d355 1
a355 1
				expensive = TRUE;
d360 2
a361 2
					dprintf("    ... deliverable\n");
				somedeliveries = TRUE;
d371 3
a373 2
			ee = (ENVELOPE *) xalloc(sizeof *ee);
			*ee = *e;
d379 9
a387 6
				dprintf("sendall: split %s into %s, owner = \"%s\", otherowners = %d\n",
					e->e_id, ee->e_id, owner, otherowners);

			ee->e_header = copyheader(e->e_header);
			ee->e_sendqueue = copyqueue(e->e_sendqueue);
			ee->e_errorqueue = copyqueue(e->e_errorqueue);
d390 1
a390 1
			setsender(owner, ee, NULL, '\0', TRUE);
d393 2
a394 2
				dprintf("sendall(split): QS_SENDER ");
				printaddr(&ee->e_from, FALSE);
d400 2
a401 1
			ee->e_queuedir = e->e_queuedir;
d413 2
a414 2
						dprintf("\t... stripping %s from original envelope\n",
							q->q_paddr);
d423 2
a424 2
						dprintf("\t... dropping %s from cloned envelope\n",
							q->q_paddr);
d432 2
a433 2
						dprintf("\t... moving %s to cloned envelope\n",
							q->q_paddr);
d448 1
a448 1
				ee->e_xfp = bfdup(e->e_xfp);
d455 3
a457 3
				sm_syslog(LOG_INFO, ee->e_id,
					  "clone %s, owner=%s",
					  e->e_id, owner);
d463 1
a463 1
		setsender(owner, e, NULL, '\0', TRUE);
d466 2
a467 2
			dprintf("sendall(owner): QS_SENDER ");
			printaddr(&e->e_from, FALSE);
d476 1
a476 1
	if (!somedeliveries && mode != SM_QUEUE && mode != SM_DEFER &&
d479 1
a479 1
		time_t now = curtime();
d482 1
a482 1
			dprintf("No deliveries: auto-queuing\n");
d484 1
d498 2
a499 3
#if QUEUE
	if ((mode == SM_QUEUE || mode == SM_DEFER || mode == SM_FORK ||
	     (mode != SM_VERIFY && SuperSafe)) &&
d502 2
d511 6
d518 2
a519 2
			queueup(ee, mode == SM_QUEUE || mode == SM_DEFER);
		queueup(e, mode == SM_QUEUE || mode == SM_DEFER);
a520 1
#endif /* QUEUE */
d531 1
a531 1
		dprintf("sendall: final mode = %c\n", mode);
d534 4
a537 4
			dprintf("\n================ Final Send Queue(s) =====================\n");
			dprintf("\n  *** Envelope %s, e_from=%s ***\n",
				e->e_id, e->e_from.q_paddr);
			printaddr(e->e_sendqueue, TRUE);
d540 3
a542 3
				dprintf("\n  *** Envelope %s, e_from=%s ***\n",
					ee->e_id, ee->e_from.q_paddr);
				printaddr(ee->e_sendqueue, TRUE);
d544 1
a544 1
			dprintf("==========================================================\n\n");
d560 1
a560 1
		dropenvelope(e, splitenv != NULL);
d565 1
a565 1
			dropenvelope(ee, FALSE);
d571 1
a571 1
			(void) fflush(e->e_xfp);
d587 1
a587 1
			dropenvelope(e, splitenv != NULL);
d600 1
a600 1
			dropenvelope(ee, FALSE);
d616 1
a616 1
		closemaps();
d638 1
a638 1
				(void) bfclose(e->e_dfp);
d644 1
a644 1
				(void) fclose(e->e_lockfp);
d660 1
d665 7
d678 1
a678 1
		(void) setsignal(SIGTERM, SIG_DFL);
d686 2
d702 1
a702 1
			finis(TRUE, ExitStat);
d706 1
a706 1
		QuickAbort = FALSE;
d718 1
a718 1
		mci_flush(FALSE, NULL);
d732 2
a733 2
			(void) dowork(ee->e_queuedir, ee->e_id,
				      FALSE, FALSE, ee);
d736 3
a738 3
		(void) dowork(e->e_queuedir, e->e_id,
			      FALSE, FALSE, e);
		finis(TRUE, ExitStat);
d743 1
a743 1
	dropenvelope(e, TRUE);
d750 1
a750 1
		dropenvelope(ee, TRUE);
d756 1
a756 1
		finis(TRUE, ExitStat);
d768 3
a770 3
		dprintf("sendenvelope(%s) e_flags=0x%lx\n",
			e->e_id == NULL ? "[NOQUEUE]" : e->e_id,
			e->e_flags);
d790 5
a794 1
	/* Don't attempt deliveries if we want to bounce now */
d796 3
a798 1
	    TimeOuts.to_q_return[e->e_timeoutclass] == NOW)
d811 40
a850 3
	define(macid("{envid}", NULL), e->e_envid, e);
	define(macid("{bodytype}", NULL), e->e_bodytype, e);
	didany = FALSE;
d858 2
a859 2
		(void) snprintf(wbuf, sizeof wbuf, "sendall(%.*s)",
			MAXNAME, q->q_paddr);
a879 1
#if QUEUE
d887 1
a887 1
				queueup(e, FALSE);
a889 1
#endif /* QUEUE */
d891 1
a891 1
			didany = TRUE;
d904 53
d971 1
a971 1
	struct envelope *e, *ee;
d983 2
a984 2
	snprintf(f1buf, sizeof f1buf, "%s", queuename(e, type));
	snprintf(f2buf, sizeof f2buf, "%s", queuename(ee, type));
d995 1
a995 1
					f2buf);
d1001 1
a1001 1
					f1buf, f2buf);
d1006 1
d1072 66
d1147 39
d1218 1
d1220 1
d1222 2
a1223 2
	register ADDRESS *to = firstto;
	volatile bool clever = FALSE;	/* running user smtp to this mailer */
d1226 3
a1228 3
	int lmtp_rcode = EX_OK;
	int nummxhosts = 0;		/* number of MX hosts available */
	int hostnum = 0;		/* current MX host index */
d1230 1
a1230 1
	pid_t pid = -1;
d1232 2
a1233 1
	register u_short port = 0;
d1235 1
a1235 1
	char *mux_path = NULL;		/* path to UNIX domain socket */
d1240 1
a1240 1
	bool goodmxfound = FALSE;	/* at least one MX was OK */
a1241 1
#if _FFR_DYNAMIC_TOBUF
d1244 1
d1247 1
a1247 3
#else /* _FFR_DYNAMIC_TOBUF */
	char tobuf[TOBUFSIZE];		/* text line of to people */
#endif /* _FFR_DYNAMIC_TOBUF */
a1252 1
	char rpathbuf[MAXNAME + 1];	/* translated return path */
a1263 1
#if SMTP
a1264 1
#endif /* SMTP */
d1268 1
a1268 1
		dprintf("\n--deliver, id=%s, mailer=%s, host=`%s', first user=`%s'\n",
d1271 1
a1271 1
		printopenfds(FALSE);
d1274 1
a1274 1
	**  Clear $&{client_*} macros if this is a bounce message to
d1280 4
a1283 3
		define(macid("{client_name}", NULL), "", e);
		define(macid("{client_addr}", NULL), "", e);
		define(macid("{client_port}", NULL), "", e);
d1286 4
d1307 2
a1308 2
	p = remotename(p, m, RF_SENDERADDR|RF_CANONICAL, &rcode, e);
	if (strlen(p) >= (SIZE_T) sizeof rpathbuf)
d1310 2
a1311 2
		p = shortenstring(p, MAXSHORTSTR);
		syserr("remotename: huge return %s", p);
d1313 3
a1315 3
	snprintf(rpathbuf, sizeof rpathbuf, "%s", p);
	define('g', rpathbuf, e);		/* translated return path */
	define('h', host, e);			/* to host */
d1329 1
a1329 1
		*pvp++ = newstr(rpathbuf);
d1356 1
a1356 1
		*pvp++ = newstr(buf);
d1361 2
a1362 1
			return -1;
d1375 1
a1375 2
#if SMTP
		clever = TRUE;
a1376 5
#else /* SMTP */
		/* oops!  we don't implement SMTP */
		syserr("554 5.3.5 SMTP style mailer not implemented");
		return EX_SOFTWARE;
#endif /* SMTP */
a1393 1
#if _FFR_DYNAMIC_TOBUF
d1397 5
a1401 4
#else /* _FFR_DYNAMIC_TOBUF */
	tobuf[0] = '\0';
	e->e_to = tobuf;
#endif /* _FFR_DYNAMIC_TOBUF */
a1402 2
	ctladdr = NULL;
	firstsig = hostsignature(firstto->q_mailer, firstto->q_host);
a1405 1
#if _FFR_DYNAMIC_TOBUF
a1407 4
#else /* _FFR_DYNAMIC_TOBUF */
		if (tobuf[0] != '\0' && !bitnset(M_MUSER, m->m_flags))
			break;
#endif /* _FFR_DYNAMIC_TOBUF */
d1410 1
a1410 4
		if (!QS_IS_OK(to->q_state) ||
		    to->q_mailer != firstto->q_mailer ||
		    strcmp(hostsignature(to->q_mailer, to->q_host),
			   firstsig) != 0)
d1413 29
a1441 4
		/* avoid overflowing tobuf */
#if _FFR_DYNAMIC_TOBUF
		strsize += strlen(to->q_paddr) + 1;
		if (!clever && strsize > TOBUFSIZE)
d1444 8
a1453 4
#else /* _FFR_DYNAMIC_TOBUF */
		if (sizeof tobuf < (strlen(to->q_paddr) + strlen(tobuf) + 2))
			break;
#endif /* _FFR_DYNAMIC_TOBUF */
d1457 2
a1458 2
			dprintf("\nsend to ");
			printaddr(to, FALSE);
d1463 1
d1465 3
d1471 2
a1472 2
			dprintf("ctladdr=");
			printaddr(ctladdr, FALSE);
d1492 1
d1497 1
a1497 1
			markfailure(e, to, NULL, EX_UNAVAILABLE, FALSE);
d1499 1
a1499 1
				     NULL, ctladdr, xstart, e);
a1501 1
#if NAMED_BIND
d1503 1
a1503 1
#endif /* NAMED_BIND */
a1504 1
		ovr = TRUE;
d1507 1
a1507 1
				e, TRUE, TRUE, 4, NULL);
d1514 1
a1514 1
				ovr = FALSE;
d1521 1
a1521 1
				     NULL, ctladdr, xstart, e);
d1528 2
a1529 2
				dprintf("deliver: discarding recipient ");
				printaddr(to, FALSE);
d1584 1
a1584 1
			define('u', user, e);	/* to user */
d1588 1
a1588 1
			define('z', p, e);	/* user's home */
d1599 2
a1600 2
				     ctladdr, xstart, e);
			markfailure(e, to, NULL, rcode, TRUE);
d1610 4
a1613 2
					fprintf(e->e_xfp, "%s... Successfully delivered\n",
						to->q_paddr);
d1617 1
a1617 1
			markstats(e, to, FALSE);
a1628 2

#if _FFR_DYNAMIC_TOBUF
a1629 5
#else /* _FFR_DYNAMIC_TOBUF */
		/* create list of users for error messages */
		(void) strlcat(tobuf, ",", sizeof tobuf);
		(void) strlcat(tobuf, to->q_paddr, sizeof tobuf);
#endif /* _FFR_DYNAMIC_TOBUF */
d1631 1
a1631 1
		define('u', user, e);		/* to user */
d1635 1
a1635 1
		define('z', p, e);	/* user's home */
d1644 2
a1645 2
				(void) strlcat(notify, "SUCCESS,",
					       sizeof notify);
d1647 2
a1648 2
				(void) strlcat(notify, "FAILURE,",
					       sizeof notify);
d1650 2
a1651 1
				(void) strlcat(notify, "DELAY,", sizeof notify);
d1655 2
a1656 1
				(void) strlcat(notify, "NEVER", sizeof notify);
d1660 2
a1661 1
			define(macid("{dsn_notify}", NULL), newstr(notify), e);
d1664 2
a1665 1
			define(macid("{dsn_notify}", NULL), NULL, e);
d1674 1
a1674 1
			*pvp++ = newstr(buf);
a1683 1
#if _FFR_DYNAMIC_TOBUF
a1684 3
#else /* _FFR_DYNAMIC_TOBUF */
	if (tobuf[0] == '\0')
#endif /* _FFR_DYNAMIC_TOBUF */
d1686 2
a1687 3
		define('g', (char *) NULL, e);
		e->e_to = NULL;
		return 0;
d1691 14
a1704 1
#if _FFR_DYNAMIC_TOBUF
d1706 3
a1708 22
		int l = 1;
		char *tobufptr;

		for (to = tochain; to != NULL; to = to->q_tchain)
			l += strlen(to->q_paddr) + 1;
		if (l < TOBUFSIZE)
			l = TOBUFSIZE;
		if (l > tobufsize)
		{
			if (tobuf != NULL)
				sm_free(tobuf);
			tobufsize = l;
			tobuf = xalloc(tobufsize);
		}
		tobufptr = tobuf;
		*tobufptr = '\0';
		for (to = tochain; to != NULL; to = to->q_tchain)
		{
			snprintf(tobufptr, tobufsize - (tobufptr - tobuf),
				 ",%s", to->q_paddr);
			tobufptr += strlen(tobufptr);
		}
a1709 1
#endif /* _FFR_DYNAMIC_TOBUF */
d1716 1
a1716 1
	while (!clever && *++mvp != NULL)
d1718 8
a1725 5
		expand(*mvp, buf, sizeof buf, e);
		*pvp++ = newstr(buf);
		if (pvp >= &pv[MAXPV])
			syserr("554 5.3.0 deliver: pv overflow after $u for %s",
			       pv[0]);
d1749 1
a1749 1
		dprintf("openmailer:");
a1752 1
#if NAMED_BIND
a1753 2
#endif /* NAMED_BIND */

d1774 3
a1776 2
		snprintf(wbuf, sizeof wbuf, "%s... openmailer(%s)",
			shortenstring(e->e_to, MAXSHORTSTR), m->m_name);
d1791 1
a1791 1
		       "554 Cannot send 8-bit data to 7-bit destination");
d1802 38
a1839 4
		mci = (MCI *) xalloc(sizeof *mci);
		memset((char *) mci, '\0', sizeof *mci);
		mci->mci_in = stdin;
		mci->mci_out = stdout;
d1842 1
d1844 1
a1844 2
	else if (strcmp(m->m_mailer, "[IPC]") == 0 ||
		 strcmp(m->m_mailer, "[TCP]") == 0)
a1845 1
#if DAEMON
d1887 1
a1887 1
			port = htons((u_short)atoi(pv[2]));
d1904 2
d1931 18
d1957 2
a1958 2
			(void) strlcpy(hostbuf, mxhosts[hostnum],
				       sizeof hostbuf);
d1968 2
d1972 2
a1973 2
					dprintf("openmailer: ");
					mci_dump(mci, FALSE);
d1976 8
a1983 3
				message("Using cached %sSMTP connection to %s via %s...",
					bitset(MCIF_ESMTP, mci->mci_flags) ? "E" : "",
					hostbuf, m->m_name);
d1991 1
a1991 1
					goodmxfound = TRUE;
d1998 1
a1998 1
				goodmxfound = TRUE;
d2003 1
a2003 1
			sm_setproctitle(TRUE, e, "%s %s: %s",
d2011 1
a2011 1
				i = makeconnection_ds(mux_path, mci);
d2023 2
a2024 1
				i = makeconnection(hostbuf, port, mci, e);
d2033 29
d2064 1
a2064 1
				goodmxfound = TRUE;
d2068 5
a2072 2
					fprintf(TrafficLogFile, "%05d === CONNECT %s\n",
						(int) getpid(), hostbuf);
d2078 2
a2079 2
					dprintf("openmailer: makeconnection => stat=%d, errno=%d\n",
						i, errno);
d2081 1
a2081 1
					goodmxfound = TRUE;
a2096 7
#else /* DAEMON */
		syserr("554 5.3.5 openmailer: no IPC");
		if (tTd(11, 1))
			dprintf("openmailer: NULL\n");
		rcode = EX_UNAVAILABLE;
		goto give_up;
#endif /* DAEMON */
a2103 1
#if SMTP
a2118 1
#endif /* SMTP */
d2129 2
a2130 1
			fprintf(TrafficLogFile, "%05d === EXEC", (int) getpid());
d2132 5
a2136 2
				fprintf(TrafficLogFile, " %s", *av);
			fprintf(TrafficLogFile, "\n");
d2147 1
a2147 1
				shortenstring(e->e_to, MAXSHORTSTR), m->m_name);
d2149 1
a2149 1
				dprintf("openmailer: NULL\n");
d2159 3
a2161 3
				shortenstring(e->e_to, MAXSHORTSTR), m->m_name,
				mpvect[0], mpvect[1]);
			printopenfds(TRUE);
d2163 1
a2163 1
				dprintf("openmailer: NULL\n");
d2173 4
a2176 2
		     (mpvect[0] == fileno(e->e_lockfp) ||
		      mpvect[1] == fileno(e->e_lockfp))))
d2180 2
a2181 2
					shortenstring(e->e_to, MAXSHORTSTR),
					m->m_name, mpvect[0], mpvect[1]);
d2184 4
a2187 3
					shortenstring(e->e_to, MAXSHORTSTR),
					m->m_name, mpvect[0], mpvect[1],
					fileno(e->e_lockfp));
d2195 2
a2196 2
				shortenstring(e->e_to, MAXSHORTSTR),
				m->m_name);
d2200 1
a2200 1
				dprintf("openmailer: NULL\n");
d2217 4
a2220 4
		if (e->e_xfp != NULL)
			(void) fflush(e->e_xfp);	/* for debugging */
		(void) fflush(stdout);
		(void) setsignal(SIGCHLD, SIG_DFL);
d2230 1
a2230 1
				shortenstring(e->e_to, MAXSHORTSTR), m->m_name);
d2236 1
a2236 1
				dprintf("openmailer: NULL\n");
d2244 1
d2248 1
d2253 1
a2253 1
			clear_events();
d2257 1
d2260 1
d2263 3
a2265 1
				(void) close(fileno(e->e_lockfp));
d2268 5
a2272 5
			(void) setsignal(SIGALRM, sm_signal_noop);
			(void) setsignal(SIGCHLD, SIG_DFL);
			(void) setsignal(SIGHUP, SIG_IGN);
			(void) setsignal(SIGINT, SIG_IGN);
			(void) setsignal(SIGTERM, SIG_DFL);
d2274 1
a2274 1
			(void) setsignal(SIGUSR1, sm_signal_noop);
d2295 2
a2296 2
						pwd, pwd->pw_uid,
						LOGIN_SETRESOURCES|LOGIN_SETPRIORITY);
d2313 7
a2319 6
					char *u = ctladdr->q_ruser;

					if (u == NULL)
						u = ctladdr->q_user;

					if (initgroups(u, ctladdr->q_gid) == -1 && suidwarn)
d2322 1
a2322 1
							u, ctladdr->q_gid);
d2331 2
a2332 1
					if (setgroups(1, gidset) == -1 && suidwarn)
d2344 3
a2346 1
					if (initgroups(DefUser, DefGid) == -1 && suidwarn)
d2349 1
a2349 1
							DefUser, DefGid);
d2358 2
a2359 1
					if (setgroups(1, gidset) == -1 && suidwarn)
d2395 2
a2396 2
					dprintf("openmailer: chroot %s\n",
						buf);
d2400 1
a2400 1
					       buf);
d2412 1
d2425 12
d2438 2
a2459 16
#  if HASSETREUID
				/*
				**  Undo the effects of the uid change in main
				**  for signal handling.  The real uid may
				**  be used by mailer in adding a "From "
				**  line.
				*/

				if (new_ruid != NO_UID &&
				    setreuid(RealUid, geteuid()) < 0)
				{
					syserr("openmailer: setreuid(%d, %d) failed",
					       (int) new_ruid, (int) geteuid());
					exit(EX_OSERR);
				}
#  endif /* HASSETREUID */
d2463 1
a2463 1
						(long) new_euid);
d2471 1
a2471 1
						(long) new_ruid, (long) new_euid);
d2479 1
a2479 1
						(long) new_euid);
d2490 1
a2490 1
						(long) new_ruid);
d2496 3
a2498 3
				dprintf("openmailer: running as r/euid=%d/%d, r/egid=%d/%d\n",
					(int) getuid(), (int) geteuid(),
					(int) getgid(), (int) getegid());
d2514 2
a2515 2
						dprintf("openmailer: trydir %s\n",
							buf);
d2521 17
d2552 2
a2553 2
					shortenstring(e->e_to, MAXSHORTSTR),
					m->m_name);
d2562 2
a2563 2
					shortenstring(e->e_to, MAXSHORTSTR),
					m->m_name, mpvect[0]);
d2598 19
a2616 2
			mci = (MCI *) xalloc(sizeof *mci);
			memset((char *) mci, '\0', sizeof *mci);
d2630 3
a2632 1
		mci->mci_out = fdopen(mpvect[1], "w");
d2636 1
a2636 1
				mpvect[1]);
d2645 3
a2647 1
		mci->mci_in = fdopen(rpvect[0], "r");
d2653 1
a2653 1
			(void) fclose(mci->mci_out);
a2657 4

		/* Don't cache non-clever connections */
		if (!clever)
			mci->mci_flags |= MCIF_TEMP;
a2666 1
#if SMTP
d2669 7
a2675 1
# if SASL && SFIO
d2677 1
a2677 1
# endif /* SASL && SFIO */
d2685 21
d2707 15
a2721 3
# if STARTTLS || (SASL && SFIO)
reconnect:	/* after switching to an authenticated connection */
# endif /* STARTTLS || (SASL && SFIO) */
d2723 2
d2731 29
a2765 1
			int dotpos;
a2769 5
#  if _FFR_TLS_CLT1
			char *p;
#  endif /* _FFR_TLS_CLT1 */
			char *srvname;
			extern SOCKADDR CurHostAddr;
d2773 2
a2774 16
#  if _FFR_TLS_CLT1
			if (usetls &&
			    (p = macvalue(macid("{client_flags}", NULL), e))
			    != NULL)
			{
				for (; *p != '\0'; p++)
				{
					/* look for just this one flag */
					if (*p == D_CLTNOTLS)
					{
						usetls = FALSE;
						break;
					}
				}
			}
#  endif /* _FFR_TLS_CLT1 */
a2775 24
			if (mci->mci_host != NULL)
			{
				srvname = mci->mci_host;
				dotpos = strlen(srvname) - 1;
				if (dotpos >= 0)
				{
					if (srvname[dotpos] == '.')
						srvname[dotpos] = '\0';
					else
						dotpos = -1;
				}
			}
			else
			{
				srvname = "";
				dotpos = -1;
			}
			define(macid("{server_name}", NULL),
			       newstr(srvname), e);
			if (CurHostAddr.sa.sa_family != 0)
				define(macid("{server_addr}", NULL),
				       newstr(anynet_ntoa(&CurHostAddr)), e);
			else
				define(macid("{server_addr}", NULL), NULL, e);
d2778 1
a2778 3
				host = macvalue(macid("{server_name}", NULL),
						e);
#  if _FFR_TLS_O_T
d2780 4
a2783 4
				QuickAbort = FALSE;
				SuprErrs = TRUE;
				if (rscheck("try_tls", srvname, NULL,
					    e, TRUE, FALSE, 8, host) != EX_OK
d2785 1
a2785 1
					usetls = FALSE;
a2787 1
#  endif /* _FFR_TLS_O_T */
a2789 3
			/* undo change of srvname */
			if (dotpos >= 0)
				srvname[dotpos] = '.';
d2807 1
d2829 2
a2830 2
					define(macid("{verify}", NULL),
					       newstr(s), e);
a2832 6
			else if (mci->mci_ssl != NULL)
			{
				/* active TLS connection, use that data */
				(void) tls_get_info(mci->mci_ssl, e, FALSE,
						    mci->mci_host, FALSE);
			}
d2834 2
a2835 1
				define(macid("{verify}", NULL), "NONE", e);
d2837 2
a2838 2
			QuickAbort = FALSE;
			SuprErrs = TRUE;
d2848 1
d2850 3
a2852 2
				     macvalue(macid("{verify}", NULL), e),
				     NULL, e, TRUE, TRUE, 6, host) != EX_OK ||
d2862 2
a2863 1
					p = newstr(MsgBuf);
d2868 2
a2869 2
					(void) strlcpy(enhsc, "4.7.0",
						       sizeof enhsc);
d2880 2
a2881 1
						(void) fclose(mci->mci_in);
d2899 1
a2899 1
				mci_setstat(mci, rcode, newstr(enhsc), p);
d2905 3
a2907 1
				(void) strlcpy(SmtpError, p, sizeof SmtpError);
a2918 6
		else if (mci->mci_ssl != NULL)
		{
			/* active TLS connection, use that data */
			(void) tls_get_info(mci->mci_ssl, e, FALSE,
					    mci->mci_host, FALSE);
		}
d2924 1
a2924 4
#  if SFIO
		    !DONE_AUTH(mci->mci_flags) &&
#  endif /* SFIO */
		    SASLInfo != NULL)
d2926 2
a2927 5
			/*
			**  should we require some minimum authentication?
			**  XXX ignore result?
			*/
			if (smtpauth(m, mci, e) == EX_OK)
a2928 1
#  if SFIO
d2930 1
a2930 1
				sasl_ssf_t *ssf;
d2932 1
a2932 1
				/* get security strength (features) */
d2935 2
d2939 1
a2939 1
						  "SASL: outgoing connection to %.64s: mech=%.16s, bits=%d",
d2941 2
a2942 4
						  macvalue(macid("{auth_type}",
								 NULL), e),
						  result == SASL_OK ? *ssf
						  		    : 0);
d2945 1
a2945 1
				**  only switch to encrypted connection
d2948 1
d2952 3
a2954 7
					**  convert sfio stuff to use SASL
					**  check return values
					**  if the call fails,
					**  fall back to unencrypted version
					**  unless some cf option requires
					**  encryption then the connection must
					**  be aborted
d2956 3
a2958 1
					if (sfdcsasl(mci->mci_in, mci->mci_out,
a2960 1
						SET_HELO(mci->mci_flags);
d2962 2
a2963 1
						mci->mci_flags |= MCIF_AUTHACT;
d2966 1
a2966 1
					syserr("SASL TLS switch failed in client");
a2968 1
#  endif /* SFIO */
d2972 22
a2997 1
#endif /* SMTP */
d3012 2
a3013 2
	     (strcasecmp(p, "quoted-printable") == 0 ||
	      strcasecmp(p, "base64") == 0) &&
d3018 1
a3018 1
		if (strncasecmp(p, "text/plain", 10) == 0 &&
d3026 2
a3027 2
		dprintf("openmailer: ");
		mci_dump(mci, FALSE);
a3034 1
#if NAMED_BIND
a3035 1
#endif /* NAMED_BIND */
d3040 3
a3042 3
				(u_long) mci, rcode, errno, mci->mci_state,
				firstsig);
			mci_dump_all(TRUE);
a3044 1
#if DAEMON
a3049 1
#endif /* DAEMON */
d3063 1
a3063 2
		if (rcode == EX_TEMPFAIL &&
		    SmtpError[0] == '\0')
d3070 3
a3072 3
			snprintf(SmtpError, sizeof SmtpError,
				 "%s mailer (%s) exited with EX_TEMPFAIL",
				 m->m_name, m->m_mailer);
a3075 1
#if SMTP
d3081 1
a3084 1
			register char *t = tobuf;
d3086 3
d3092 6
d3101 1
a3101 6
				e->e_to = to->q_paddr;
#if !_FFR_DYNAMIC_TOBUF
				if (strlen(to->q_paddr) +
				    (t - tobuf) + 2 > sizeof tobuf)
				{
					/* not enough room */
a3102 2
				}
#endif /* !_FFR_DYNAMIC_TOBUF */
d3104 3
a3107 1
#  if _FFR_TLS_RCPT
d3109 2
a3110 1
					    TRUE, TRUE, 4, mci->mci_host);
d3115 8
a3122 3
					markfailure(e, to, mci, i, FALSE);
					giveresponse(i, to->q_status,  m,
						     mci, ctladdr, xstart, e);
a3124 1
#  endif /* _FFR_TLS_RCPT */
d3127 3
a3129 1
				if ((i = smtprcpt(to, m, mci, e)) != EX_OK)
d3131 15
a3145 3
					markfailure(e, to, mci, i, FALSE);
					giveresponse(i, to->q_status,  m,
						     mci, ctladdr, xstart, e);
d3147 2
a3148 1
				else
d3150 5
a3154 4
					*t++ = ',';
					for (p = to->q_paddr; *p; *t++ = *p++)
						continue;
					*t = '\0';
d3158 6
a3163 2
			/* now send the data */
			if (tobuf[0] == '\0')
d3173 1
a3173 1
				rcode = smtpdata(m, mci, e);
a3175 1
# if DAEMON
a3180 7
# endif /* DAEMON */
	}
#else /* SMTP */
	{
		syserr("554 5.3.5 deliver: need SMTP compiled to use clever mailer");
		rcode = EX_CONFIG;
		goto give_up;
a3181 1
#endif /* SMTP */
a3197 1
#if SMTP
d3202 2
a3203 1
		anyok = FALSE;
a3205 1
#endif /* SMTP */
a3213 1
#if SMTP
d3221 5
a3225 18
#if _FFR_DYNAMIC_TOBUF
				(void) strlcat(tobuf, ",", tobufsize);
				(void) strlcat(tobuf, to->q_paddr, tobufsize);
#else /* _FFR_DYNAMIC_TOBUF */
				if (strlen(to->q_paddr) +
				    strlen(tobuf) + 2 > sizeof tobuf)
				{
					syserr("LMTP tobuf overflow");
				}
				else
				{
					(void) strlcat(tobuf, ",",
						       sizeof tobuf);
					(void) strlcat(tobuf, to->q_paddr,
						       sizeof tobuf);
				}
#endif /* _FFR_DYNAMIC_TOBUF */
				anyok = TRUE;
d3230 1
a3230 1
				markfailure(e, to, mci, rcode, TRUE);
d3232 1
a3232 1
					     ctladdr, xstart, e);
a3237 1
#endif /* SMTP */
d3244 1
a3244 1
				markfailure(e, to, mci, rcode, TRUE);
a3253 1
#if QUEUE
d3260 1
a3260 1
			queueup(e, FALSE);
a3262 1
#endif /* QUEUE */
d3269 3
a3271 2
			fprintf(e->e_xfp, "%s... Successfully delivered\n",
				to->q_paddr);
d3278 30
a3307 2
			fprintf(e->e_xfp, "%s... relayed; expect no further notifications\n",
				to->q_paddr);
a3310 1
#if SMTP
d3322 4
a3325 1
		if (mci != NULL && mci->mci_state == MCIS_ACTIVE)
a3327 1
#endif /* SMTP */
d3330 16
a3345 1
		giveresponse(rcode, NULL, m, mci, ctladdr, xstart, e);
d3347 1
a3347 1
		markstats(e, tochain, FALSE);
d3350 7
a3356 1
#if SMTP
a3360 5
#endif /* SMTP */

	/*
	**  Restore state and return.
	*/
d3362 7
a3369 1
	{
d3373 6
a3378 4
		snprintf(wbuf, sizeof wbuf, "%s... end of deliver(%s)",
			e->e_to == NULL ? "NO-TO-LIST"
					: shortenstring(e->e_to, MAXSHORTSTR),
			m->m_name);
a3379 1
	}
d3382 12
a3393 3
	errno = 0;
	define('g', (char *) NULL, e);
	e->e_to = NULL;
d3416 1
a3416 1
static void
d3446 1
a3446 1
		status = mci->mci_status;
d3448 2
a3449 1
			rstatus = newstr(mci->mci_rstatus);
d3512 1
a3512 1
	    strcasecmp(q->q_mailer->m_diagtype, "X-UNIX") == 0)
d3516 2
a3517 2
		(void) snprintf(buf, sizeof buf, "%d", rcode);
		q->q_rstatus = newstr(buf);
d3523 1
a3523 1
		q->q_statmta = newstr(CurHostName);
d3570 1
a3570 1
	EVENT *ev = NULL;
d3577 1
a3577 1
		(void) fclose(mci->mci_out);
d3584 2
a3585 2
		       TimeOuts.to_quit, "Draining Input") != NULL)
			(void) fputs(buf, e->e_xfp);
d3589 1
a3589 1
	/* shutdown SASL */
d3604 1
a3604 1
		(void) fclose(mci->mci_in);
d3618 2
a3619 2
			ev = setevent(mci->mci_mailer->m_wait,
				      endwaittimeout, 0);
d3633 1
a3633 1
		clrevent(ev);
d3659 1
a3659 1
		fprintf(e->e_xfp, "Arguments:");
d3661 3
a3663 2
			fprintf(e->e_xfp, " %s", *av);
		fprintf(e->e_xfp, "\n");
d3685 1
d3696 1
a3696 1
giveresponse(status, dsn, m, mci, ctladdr, xstart, e)
d3704 1
a3706 2
	extern char *SysExMsg[];
	register int i;
d3709 1
a3709 1
	extern int N_SysEx;
d3712 1
d3721 1
a3721 1
	i = status - EX__BASE;
d3727 3
a3729 3
			(void) snprintf(buf, sizeof buf, "%s (%s)",
					statmsg,
					shortenstring(e->e_statmsg, 403));
d3733 1
a3733 1
	else if (i < 0 || i >= N_SysEx)
d3735 3
a3737 3
		(void) snprintf(buf, sizeof buf,
				"554 5.3.0 unknown mailer error %d",
				status);
d3740 1
d3746 1
a3746 1
		snprintf(bp, SPACELEFT(buf, bp), "%s", SysExMsg[i] + 1);
d3750 1
a3750 1
			statmsg = errstring(h_errno+E_DNSBASE);
d3755 1
a3755 1
				statmsg = errstring(errnum);
a3756 2
			{
#if SMTP
a3757 4
#else /* SMTP */
				statmsg = NULL;
#endif /* SMTP */
			}
d3783 4
a3786 2
					snprintf(bp, SPACELEFT(buf, bp),
						 ": %s", mci->mci_host);
d3791 3
a3793 1
			snprintf(bp, SPACELEFT(buf, bp), ": %s", statmsg);
d3800 3
a3802 3
		statmsg = errstring(h_errno + E_DNSBASE);
		(void) snprintf(buf, sizeof buf, "%s (%s)",
			SysExMsg[i] + 1, statmsg);
d3804 1
d3809 1
a3809 1
		statmsg = SysExMsg[i];
d3812 2
a3813 2
			(void) snprintf(buf, sizeof buf, "%s: %s",
				statmsg, errstring(errnum));
d3815 1
d3831 2
a3832 2
				snprintf(dsnbuf, sizeof dsnbuf,
					 "%.*s", off, statmsg + 4);
d3843 2
a3844 1
			fprintf(e->e_xfp, "%s\n", &MsgBuf[4]);
d3856 2
a3857 2
				snprintf(dsnbuf, sizeof dsnbuf,
					 "%.*s", off, statmsg + 4);
d3861 4
a3864 2
			(void) strlcpy(mbuf, statmsg, off);
			(void) strlcat(mbuf, " %s", sizeof mbuf);
d3869 2
a3870 1
			(void) snprintf(mbuf, sizeof mbuf, "%.3s %%s", statmsg);
d3888 5
a3892 4
		dprintf("giveresponse: status=%d, dsn=%s, e->e_message=%s\n",
			status,
			dsn == NULL ? "<NULL>" : dsn,
			e->e_message == NULL ? "<NULL>" : e->e_message);
d3897 2
d3900 6
a3905 3
		if (e->e_message != NULL)
			sm_free(e->e_message);
		e->e_message = newstr(statmsg + off);
a3907 1
#if NAMED_BIND
a3908 1
#endif /* NAMED_BIND */
d3948 1
a3948 1
	time_t now;
d3956 2
a3957 2
		snprintf(bp, SPACELEFT(buf, bp), ", ctladdr=%s",
			 shortenstring(ctladdr->q_paddr, 83));
d3961 3
a3963 3
			(void) snprintf(bp, SPACELEFT(buf, bp), " (%d/%d)",
					(int) ctladdr->q_uid,
					(int) ctladdr->q_gid);
d3969 2
a3970 3
	now = curtime();
	snprintf(bp, SPACELEFT(buf, bp), ", delay=%s",
		 pintvl(now - e->e_ctime, TRUE));
d3975 2
a3976 2
		snprintf(bp, SPACELEFT(buf, bp), ", xdelay=%s",
			 pintvl(now - xstart, TRUE));
d3983 2
a3984 1
		snprintf(bp, SPACELEFT(buf, bp), ", mailer=%s", m->m_name);
d3989 2
a3990 1
	snprintf(bp, SPACELEFT(buf, bp), ", pri=%ld", e->e_msgpriority);
a3995 1
# if DAEMON
a3996 1
# endif /* DAEMON */
d3998 2
a3999 2
		snprintf(bp, SPACELEFT(buf, bp), ", relay=%s",
			 shortenstring(mci->mci_host, 40));
a4001 1
# if DAEMON
d4004 2
a4005 2
			snprintf(bp, SPACELEFT(buf, bp), " [%s]",
				 anynet_ntoa(&CurHostAddr));
a4006 1
# endif /* DAEMON */
d4013 2
a4014 2
			snprintf(bp, SPACELEFT(buf, bp), ", relay=%s",
				 shortenstring(p, 40));
d4022 2
a4023 2
		snprintf(bp, SPACELEFT(buf, bp), ", dsn=%s",
			 shortenstring(dsn, ENHSCLEN));
d4042 1
a4042 1
		(void) strlcpy(bp, "...", SPACELEFT(buf, bp));
d4046 1
a4046 1
	(void) strlcpy(bp, ", stat=", SPACELEFT(buf, bp));
d4049 2
a4050 1
	(void) strlcpy(bp, shortenstring(status, STATLEN), SPACELEFT(buf, bp));
d4054 2
d4057 1
a4057 1
	while (strlen(p) >= (SIZE_T) l)
a4060 1
#if _FFR_DYNAMIC_TOBUF
d4068 1
a4068 8
#else /* _FFR_DYNAMIC_TOBUF */
		q = strchr(p + l, ',');
		if (q == NULL)
			break;
#endif /* _FFR_DYNAMIC_TOBUF */

		sm_syslog(LOG_INFO, e->e_id,
			  "to=%.*s [more]%s",
a4071 1
#if _FFR_DYNAMIC_TOBUF
a4072 3
#else /* _FFR_DYNAMIC_TOBUF */
	sm_syslog(LOG_INFO, e->e_id, "to=%s%s", p, buf);
#endif /* _FFR_DYNAMIC_TOBUF */
d4077 2
d4080 1
a4080 1
	while (strlen(p) >= (SIZE_T) l)
a4083 1
#if _FFR_DYNAMIC_TOBUF
a4090 5
#else /* _FFR_DYNAMIC_TOBUF */
		q = strchr(p + l, ',');
		if (q == NULL)
			break;
#endif /* _FFR_DYNAMIC_TOBUF */
d4092 1
a4092 2
		sm_syslog(LOG_INFO, e->e_id,
			  "to=%.*s [more]",
a4095 1
#if _FFR_DYNAMIC_TOBUF
a4096 3
#else /* _FFR_DYNAMIC_TOBUF */
	sm_syslog(LOG_INFO, e->e_id, "to=%s", p);
#endif /* _FFR_DYNAMIC_TOBUF */
d4101 2
a4102 2
		snprintf(bp, SPACELEFT(buf, bp), "ctladdr=%s",
			 shortenstring(ctladdr->q_paddr, 83));
d4106 2
a4107 2
			(void) snprintf(bp, SPACELEFT(buf, bp), " (%d/%d)",
					ctladdr->q_uid, ctladdr->q_gid);
d4113 2
a4114 2
	snprintf(bp, SPACELEFT(buf, bp), "delay=%s",
		 pintvl(now - e->e_ctime, TRUE));
d4118 2
a4119 2
		snprintf(bp, SPACELEFT(buf, bp), ", xdelay=%s",
			 pintvl(now - xstart, TRUE));
d4125 2
a4126 1
		snprintf(bp, SPACELEFT(buf, bp), ", mailer=%s", m->m_name);
a4134 1
# if DAEMON
a4135 1
# endif /* DAEMON */
d4137 2
a4138 1
		snprintf(bp, SPACELEFT(buf, bp), "relay=%.100s", mci->mci_host);
a4140 1
# if DAEMON
d4142 3
a4144 3
			snprintf(bp, SPACELEFT(buf, bp), " [%.100s]",
				anynet_ntoa(&CurHostAddr));
# endif /* DAEMON */
d4150 1
a4150 1
			snprintf(buf, sizeof buf, "relay=%.100s", p);
d4216 3
a4218 3
			(void) snprintf(xbuf, sizeof xbuf,
				"From %.800s  \201d remote from %.100s\n",
				buf, at);
d4223 3
a4225 3
			(void) snprintf(xbuf, sizeof xbuf,
				"From %.800s  \201d remote from %.100s\n",
				bang, buf);
d4259 1
a4259 1
	bool dead = FALSE;
d4261 1
d4263 1
d4273 2
a4274 1
		e->e_dfp = fopen(df, "r");
d4283 1
d4300 2
a4301 1
		if (fstat(fileno(e->e_dfp), &stbuf) < 0)
d4326 3
a4328 3
			snprintf(buf, sizeof buf,
				"Content-Type: text/plain; charset=%s",
				defcharset(e));
d4360 1
a4360 1
			SuprErrs = TRUE;
d4397 1
a4397 1
		while (!ferror(mci->mci_out) && !dead)
d4401 2
a4402 1
			else if ((c = getc(e->e_dfp)) == EOF)
a4408 1
#if _FFR_NONULLS
d4410 2
a4411 1
				    bitnset(M_NONULLS, mci->mci_mailer->m_flags))
a4412 1
#endif /* _FFR_NONULLS */
d4422 1
a4422 1
				padc = EOF;
d4424 2
a4425 2
				    bitnset(M_ESCFROM, mci->mci_mailer->m_flags) &&
				    strncmp(buf, "From ", 5) == 0)
d4435 2
a4436 1
					if (strncmp(&buf[2], separator, sl) == 0)
d4448 8
a4455 5
					fprintf(TrafficLogFile, "%05d >>> ",
						(int) getpid());
					if (padc != EOF)
						(void) putc(padc,
							    TrafficLogFile);
d4457 3
a4459 2
						(void) putc((unsigned char) *xp,
							    TrafficLogFile);
d4461 9
a4469 6
						(void) fputs(mci->mci_mailer->m_eol,
							     TrafficLogFile);
				}
				if (padc != EOF)
				{
					if (putc(padc, mci->mci_out) == EOF)
d4471 1
a4471 1
						dead = TRUE;
d4477 1
a4477 1
						DataProgress = TRUE;
d4483 4
a4486 2
					if (putc((unsigned char) *xp,
						 mci->mci_out) == EOF)
d4488 1
a4488 1
						dead = TRUE;
d4494 1
a4494 1
						DataProgress = TRUE;
d4501 4
a4504 2
					if (fputs(mci->mci_mailer->m_eol,
						  mci->mci_out) == EOF)
d4509 1
a4509 1
						DataProgress = TRUE;
d4535 4
a4538 2
					if (fputs(mci->mci_mailer->m_eol,
						  mci->mci_out) == EOF)
d4543 1
a4543 1
						DataProgress = TRUE;
d4548 3
a4550 2
						(void) fputs(mci->mci_mailer->m_eol,
							     TrafficLogFile);
a4567 1
#if _FFR_NONULLS
d4569 2
a4570 1
				    bitnset(M_NONULLS, mci->mci_mailer->m_flags))
a4571 1
#endif /* _FFR_NONULLS */
d4582 3
a4584 1
					else if ((d = getc(e->e_dfp)) != EOF)
d4587 1
a4587 1
					if (d == '\n' || d == EOF)
d4590 7
a4596 4
							(void) putc((unsigned char) c,
							    TrafficLogFile);
						if (putc((unsigned char) c,
							 mci->mci_out) == EOF)
d4598 1
a4598 1
							dead = TRUE;
d4604 1
a4604 1
							DataProgress = TRUE;
d4610 7
a4616 3
					if (putc('!', mci->mci_out) == EOF ||
					    fputs(mci->mci_mailer->m_eol,
						  mci->mci_out) == EOF)
d4618 1
a4618 1
						dead = TRUE;
d4624 1
a4624 1
						DataProgress = TRUE;
d4629 4
a4632 2
						fprintf(TrafficLogFile, "!%s",
							mci->mci_mailer->m_eol);
d4641 7
a4647 4
						(void) fputs(mci->mci_mailer->m_eol,
						      TrafficLogFile);
					if (fputs(mci->mci_mailer->m_eol,
						  mci->mci_out) == EOF)
d4652 1
a4652 1
						DataProgress = TRUE;
d4660 7
a4666 4
						(void) putc((unsigned char) c,
							    TrafficLogFile);
					if (putc((unsigned char) c,
						 mci->mci_out) == EOF)
d4668 1
a4668 1
						dead = TRUE;
d4674 1
a4674 1
						DataProgress = TRUE;
d4689 3
a4691 2
					(void) putc((unsigned char) *xp,
						    TrafficLogFile);
d4695 3
a4697 2
				if (putc((unsigned char) *xp, mci->mci_out) ==
				    EOF)
d4699 1
a4699 1
					dead = TRUE;
d4705 1
a4705 1
					DataProgress = TRUE;
d4713 5
a4717 3
				(void) fputs(mci->mci_mailer->m_eol,
					     TrafficLogFile);
			(void) fputs(mci->mci_mailer->m_eol, mci->mci_out);
d4720 1
a4720 1
			DataProgress = TRUE;
d4724 1
a4724 1
	if (ferror(e->e_dfp))
d4727 1
a4727 1
		       qid_printqueue(e->e_queuedir), e->e_id);
d4751 2
a4752 2
	(void) fflush(mci->mci_out);
	if (ferror(mci->mci_out) && errno != EPIPE)
d4763 2
a4764 2
**	If the file has the setuid/setgid bits set, but NO execute
**	bits, sendmail will try to become the owner of that file
d4790 2
d4802 1
a4802 1
	register FILE *f;
d4810 1
a4810 1
	EVENT *ev;
d4816 2
a4817 2
		dprintf("mailfile %s\n  ctladdr=", filename);
		printaddr(ctladdr, FALSE);
d4824 1
a4824 1
		(void) fflush(e->e_xfp);
d4831 1
a4831 1
	if (strcmp(filename, "/dev/null") == 0)
d4844 1
a4844 1
		       "554 Cannot send 8-bit data to 7-bit destination");
d4856 1
a4856 1
		if (len + strlen(filename) + 1 > MAXPATHLEN)
d4862 1
a4862 1
		(void) strlcpy(targetfile, SafeFileEnv, sizeof targetfile);
d4865 1
a4865 1
			(void) strlcat(targetfile, "/", sizeof targetfile);
d4868 1
a4868 1
		(void) strlcat(targetfile, filename, sizeof targetfile);
d4878 1
a4878 1
		if (len + strlen(filename) + 1 > MAXPATHLEN)
d4886 1
a4886 1
			(void) strlcat(targetfile, "/", sizeof targetfile);
d4888 2
a4889 2
			(void) strlcat(targetfile, filename + 1,
				       sizeof targetfile);
d4891 2
a4892 1
			(void) strlcat(targetfile, filename, sizeof targetfile);
d4896 2
a4897 1
		if (strlen(filename) > MAXPATHLEN)
a4901 1
		(void) strlcpy(targetfile, filename, sizeof targetfile);
d4925 1
d4928 1
d4931 2
a4932 1
			(void) close(fileno(e->e_lockfp));
d4934 3
a4936 3
		(void) setsignal(SIGINT, SIG_DFL);
		(void) setsignal(SIGHUP, SIG_DFL);
		(void) setsignal(SIGTERM, SIG_DFL);
d4943 1
a4943 1
			exit(EX_TEMPFAIL);
d4947 2
a4948 2
			ev = setevent(TimeOuts.to_fileopen,
				      mailfiletimeout, 0);
d4952 1
a4952 1
		/* check file mode to see if setuid */
d4966 1
a4966 1
			/* ignore setuid and setgid bits */
d4969 1
a4969 1
				dprintf("mailfile: ignoring setuid/setgid bits\n");
d4972 1
a4972 1
		/* we have to open the dfile BEFORE setuid */
d4977 2
a4978 1
			e->e_dfp = fopen(df, "r");
d4997 1
a4997 1
					exit(EX_TEMPFAIL);
d5034 1
a5034 1
					exit(EX_TEMPFAIL);
d5076 1
a5076 1
				exit(EX_TEMPFAIL);
d5087 1
a5087 1
				exit(EX_TEMPFAIL);
d5099 1
a5099 1
				dprintf("mailfile: chroot %s\n", targetfile);
d5104 1
a5104 1
				exit(EX_CANTCREAT);
d5110 1
a5110 1
			dprintf("mailfile: deliver to %s\n", realfile);
d5115 1
a5115 1
			exit(EX_CANTCREAT);
d5120 1
d5124 1
a5124 1
			exit(EX_TEMPFAIL);
d5130 1
a5130 1
			exit(EX_TEMPFAIL);
d5134 1
a5134 1
			dprintf("mailfile: running as r/euid=%d/%d, r/egid=%d/%d\n",
d5153 2
a5154 1
					dprintf("mailfile: trydir %s\n", buf);
d5204 2
a5205 2
				       errstring(errno));
				exit(EX_TEMPFAIL);
d5211 2
a5212 2
				       errstring(errno));
				exit(EX_CANTCREAT);
d5215 2
a5216 1
		if (filechanged(realfile, fileno(f), &stb))
d5219 1
a5219 1
			exit(EX_CANTCREAT);
d5221 1
a5221 1
		if (fstat(fileno(f), &stb) < 0)
d5223 3
a5225 2
			syserr("554 5.3.0 cannot fstat %s", errstring(errno));
			exit(EX_CANTCREAT);
d5231 1
a5231 1
			clrevent(ev);
d5251 2
a5252 2
		    (strcasecmp(p, "quoted-printable") == 0 ||
		     strcasecmp(p, "base64") == 0) &&
d5257 1
a5257 1
			if (strncasecmp(p, "text/plain", 10) == 0 &&
d5267 4
a5270 3
		if (fflush(f) != 0 ||
		    (SuperSafe && fsync(fileno(f)) < 0) ||
		    ferror(f))
d5274 2
a5275 1
			(void) ftruncate(fileno(f), curoff);
d5281 2
a5282 1
		(void) fchmod(fileno(f), (MODE_T) mode);
d5286 1
a5286 1
		if (fclose(f) < 0)
d5288 1
a5288 1
		(void) fflush(stdout);
d5346 1
d5349 1
a5349 1
static char *
d5356 1
a5363 1
	time_t now;
d5368 1
a5368 1
	u_short mxprefs[MAXMXHOSTS + 1];
d5372 1
a5372 1
		dprintf("hostsignature(%s)\n", host);
a5377 1
	p = m->m_mailer;
d5379 1
a5379 2
	    strcmp(p, "[IPC]") != 0 &&
	    strcmp(p, "[TCP]") != 0)
d5386 2
a5387 2
	if (strcmp(p, "[IPC]") != 0 &&
	    strcmp(p, "[TCP]") != 0)
d5389 1
a5389 1
		/* just an ordinary mailer */
d5405 1
d5407 1
a5407 1
	if (s->s_hostsig != NULL)
d5409 11
a5419 4
		if (tTd(17, 3))
			dprintf("hostsignature(): stab(%s) found %s\n", host,
				s->s_hostsig);
		return s->s_hostsig;
d5422 3
d5426 1
a5426 1
	**  Not already there -- create a signature.
a5432 1
	now = curtime();
d5462 1
d5464 2
a5465 1
			nmx = getmxrr(hp, mxhosts, mxprefs, TRUE, &rcode);
d5479 1
a5479 1
						"550 Host unknown");
d5488 9
a5496 2
				dprintf("hostsignature(): getmxrr() returned %d, mxhosts[0]=%s\n",
					nmx, mxhosts[0]);
d5502 3
a5504 3
		if (s->s_hostsig != NULL)
			len += strlen(s->s_hostsig) + 1;
		if (len >= MAXHOSTSIGNATURE)
d5510 2
a5511 2
		p = xalloc(len);
		if (s->s_hostsig != NULL)
d5513 3
a5515 3
			(void) strlcpy(p, s->s_hostsig, len);
			sm_free(s->s_hostsig);
			s->s_hostsig = p;
d5522 1
a5522 1
			s->s_hostsig = p;
d5540 1
a5540 1
			(void) strlcpy(p, mxhosts[i], len);
d5557 1
a5557 1
	makelower(s->s_hostsig);
d5562 5
a5566 1
	s->s_hostsig = host;
d5569 2
a5570 2
		dprintf("hostsignature(%s) = %s\n", host, s->s_hostsig);
	return s->s_hostsig;
d5583 1
d5598 2
a5599 3
	int nmx = 0;
	int curpref = 0;
	int i, j;
d5601 1
a5601 1
	u_short prefer[MAXMXHOSTS];
d5667 1
a5667 1
				register u_short tempp;
a5685 1
#if SMTP
d5688 1
d5691 20
d5714 1
a5714 1
**		none.
d5718 3
d5724 2
a5725 1
initclttls()
d5727 5
d5733 4
a5736 3
		return TRUE;	/* already done */
	return inittls(&clt_ctx, TLS_I_CLT, FALSE, CltCERTfile, Cltkeyfile,
		       CACERTpath, CACERTfile, DHParams);
d5763 1
d5765 1
a5765 1
	if (clt_ctx == NULL && !initclttls())
d5770 1
a5770 2
	smtpresult = reply(m, mci, e, TimeOuts.to_datafinal, NULL, NULL);
	/* which timeout? XXX */
d5783 1
a5783 1
		sm_syslog(LOG_INFO, e->e_id, "TLS: start client");
d5790 2
a5791 2
			sm_syslog(LOG_ERR, e->e_id,
				  "TLS: error: client: SSL_new failed");
d5793 1
a5793 1
				tlslogerr();
d5798 2
a5799 2
	rfd = fileno(mci->mci_in);
	wfd = fileno(mci->mci_out);
d5803 2
a5804 2
	    (result = SSL_set_rfd(clt_ssl, rfd)) <= 0 ||
	    (result = SSL_set_wfd(clt_ssl, wfd)) <= 0)
d5808 3
a5810 2
			sm_syslog(LOG_ERR, e->e_id,
				  "TLS: error: SSL_set_xfd failed=%d", result);
d5812 1
a5812 1
				tlslogerr();
d5817 3
d5823 4
d5830 48
d5881 4
a5884 4
				  "TLS: error: SSL_connect failed=%d (%d)",
				  result, i);
			if (LogLevel > 9)
				tlslogerr();
d5891 2
a5892 1
	result = tls_get_info(clt_ssl, e, FALSE, mci->mci_host, TRUE);
d5894 1
a5894 6
	/* switch to use SSL... */
#if SFIO
	if (sfdctls(mci->mci_in, mci->mci_out, mci->mci_ssl) == 0)
		return EX_OK;
#else /* SFIO */
# if _FFR_TLS_TOREK
a5896 2
# endif /* _FFR_TLS_TOREK */
#endif /* SFIO */
a5902 1

d5912 2
a5913 1
int
d5925 2
d5928 1
a5928 1
**  ENDTLS -- shutdown secure connection
d5931 2
a5932 2
**		ssl -- SSL connection information.
**		side -- srv/clt (for logging).
d5935 1
a5935 1
**		success?
d5938 4
a5941 4
int
endtls(ssl, side)
	SSL *ssl;
	char *side;
d5943 1
a5943 5
	int ret = EX_OK;

	if (ssl != NULL)
	{
		int r;
d5945 8
a5952 18
		if ((r = SSL_shutdown(ssl)) < 0)
		{
			if (LogLevel > 11)
				sm_syslog(LOG_WARNING, NOQID,
					  "SSL_shutdown %s failed: %d",
					  side, r);
			ret = EX_SOFTWARE;
		}
		else if (r == 0)
		{
			if (LogLevel > 13)
				sm_syslog(LOG_WARNING, NOQID,
					  "SSL_shutdown %s not done",
					  side);
			ret = EX_SOFTWARE;
		}
		SSL_free(ssl);
		ssl = NULL;
d5954 1
a5954 1
	return ret;
d5956 1
a5956 2
# endif /* STARTTLS */
#endif /* SMTP */
@


1.5
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: deliver.c,v 8.600.2.1.2.81 2001/05/23 02:15:42 ca Exp $";
d1930 3
d1942 3
a1945 1
			(void) setsignal(SIGHUP, SIG_IGN);
d1947 3
d2082 1
d2084 11
d2114 16
d3084 1
a3084 1
**		pid -- pid of mailer.
d4964 1
d4968 1
d4970 1
a4970 1
				mci->mci_errno = errno;
@


1.4
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: deliver.c,v 8.600.2.1.2.66 2001/02/25 23:30:35 gshapiro Exp $";
d138 8
d152 4
a155 4
		syserr("554 5.0.0 Too many hops %d (%d max): from %s via %s, to %s",
			e->e_hopcount, MaxHopCount, e->e_from.q_paddr,
			RealHostName == NULL ? "localhost" : RealHostName,
			e->e_sendqueue->q_paddr);
d162 1
d647 5
d948 1
a948 1
int
d1468 1
a1468 1
				free(tobuf);
d1736 1
a1739 1
			mci->mci_errno = errno;
d1930 5
d2533 3
a2535 1
						  *ssf);
d3065 6
d3089 13
a3115 13
	/* close output to mailer */
	if (mci->mci_out != NULL)
		(void) fclose(mci->mci_out);

	/* copy any remaining input to transcript */
	if (mci->mci_in != NULL && mci->mci_state != MCIS_ERROR &&
	    e->e_xfp != NULL)
	{
		while (sfgets(buf, sizeof buf, mci->mci_in,
		       TimeOuts.to_quit, "Draining Input") != NULL)
			(void) fputs(buf, e->e_xfp);
	}

d3405 1
a3405 1
			free(e->e_message);
d3977 1
a3977 1
						      TrafficLogFile);
d4405 5
d4426 2
a4427 1
			ev = setevent(TimeOuts.to_fileopen, mailfiletimeout, 0);
d4741 1
a4741 1
		if (fflush(f) < 0 ||
d4791 7
d4845 1
a4845 1
	**  If local delivery, just return a constant.
d4848 4
a4851 1
	if (bitnset(M_LOCALMAILER, m->m_flags))
a4857 1
	p = m->m_mailer;
d4965 1
a4965 1
			free(s->s_hostsig);
@


1.4.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: deliver.c,v 8.600.2.1.2.81 2001/05/23 02:15:42 ca Exp $";
a137 8
		char *recip;

		if (e->e_sendqueue != NULL &&
		    e->e_sendqueue->q_paddr != NULL)
			recip = e->e_sendqueue->q_paddr;
		else
			recip = "(nobody)";

d144 4
a147 4
		syserr("554 5.4.6 Too many hops %d (%d max): from %s via %s, to %s",
		       e->e_hopcount, MaxHopCount, e->e_from.q_paddr,
		       RealHostName == NULL ? "localhost" : RealHostName,
		       recip);
a153 1
			q->q_rstatus = "554 5.4.6 Too many hops";
a637 5
		/* Reset global flags */
		RestartRequest = NULL;
		ShutdownRequest = NULL;
		PendingSignal = 0;

d934 1
a934 1
pid_t
d1454 1
a1454 1
				sm_free(tobuf);
a1721 1
			mci->mci_errno = errno;
d1725 1
a1915 5
			/* Reset global flags */
			RestartRequest = NULL;
			ShutdownRequest = NULL;
			PendingSignal = 0;

d2514 1
a2514 3
						  result == SASL_OK ? *ssf
						  		    : 0);

a3043 6
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

a3061 13
	/* close output to mailer */
	if (mci->mci_out != NULL)
		(void) fclose(mci->mci_out);

	/* copy any remaining input to transcript */
	if (mci->mci_in != NULL && mci->mci_state != MCIS_ERROR &&
	    e->e_xfp != NULL)
	{
		while (sfgets(buf, sizeof buf, mci->mci_in,
		       TimeOuts.to_quit, "Draining Input") != NULL)
			(void) fputs(buf, e->e_xfp);
	}

d3076 13
d3378 1
a3378 1
			sm_free(e->e_message);
d3950 1
a3950 1
							     TrafficLogFile);
a4377 5
		/* Reset global flags */
		RestartRequest = NULL;
		ShutdownRequest = NULL;
		PendingSignal = 0;

d4394 1
a4394 2
			ev = setevent(TimeOuts.to_fileopen,
				      mailfiletimeout, 0);
d4708 1
a4708 1
		if (fflush(f) != 0 ||
a4757 7
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
d4805 1
a4805 1
	**  If local delivery (and not remote), just return a constant.
d4808 1
a4808 4
	p = m->m_mailer;
	if (bitnset(M_LOCALMAILER, m->m_flags) &&
	    strcmp(p, "[IPC]") != 0 &&
	    strcmp(p, "[TCP]") != 0)
d4815 1
d4923 1
a4923 1
			sm_free(s->s_hostsig);
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: deliver.c,v 8.600.2.1.2.56 2000/12/19 01:16:12 gshapiro Exp $";
d1135 1
a1135 1
		/* running SMTP */
d1145 8
d1246 1
a1246 1
		h_errno = 0;
d1509 1
a1509 1
	h_errno = 0;
d2278 1
a2278 1
			bool hasdot;
d2286 1
d2308 17
a2324 3
			hasdot = CurHostName[strlen(CurHostName) - 1] == '.';
			if (hasdot)
				CurHostName[strlen(CurHostName) - 1] = '\0';
d2326 1
a2326 1
			       newstr(CurHostName), e);
d2340 1
a2340 1
				if (rscheck("try_tls", CurHostName, NULL,
d2349 3
a2351 3
			/* undo change of CurHostName */
			if (hasdot)
				CurHostName[strlen(CurHostName)] = '.';
d2588 1
a2588 1
		h_errno = mci->mci_herrno;
d2619 12
d3383 1
a3383 1
	h_errno = 0;
d5266 2
d5278 1
a5278 1
			return EX_SOFTWARE;
d5286 1
a5286 1
			return EX_SOFTWARE;
d5291 1
a5291 1
	return EX_OK;
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: deliver.c,v 8.600 2000/04/06 00:50:14 gshapiro Exp $";
d20 1
d25 3
d38 3
d152 1
d466 2
d473 1
a473 1
		e->e_dtime = curtime();
d478 1
a478 1
			ee->e_dtime = curtime();
d489 7
a495 2
		/* be sure everything is instantiated in the queue */
		queueup(e, mode == SM_QUEUE || mode == SM_DEFER);
d498 1
d638 9
d807 2
a808 1
			if (e->e_nsent >= CheckpointInterval)
d1004 8
a1015 1
	char tobuf[TOBUFSIZE];		/* text line of to people */
d1153 5
d1160 2
d1167 4
d1173 1
d1183 8
d1193 1
d1217 1
d1220 2
a1221 1
		if (m->m_maxsize != 0 && e->e_msgsize > m->m_maxsize)
d1244 1
a1244 1
				e, TRUE, TRUE, 4);
d1365 3
d1371 2
d1422 3
d1426 1
d1429 1
d1434 26
d1603 1
a1603 1
			port = htons(atoi(pv[2]));
d1879 2
d1883 1
d1919 1
a1919 1
#if HASSETUSERCONTEXT
d1937 1
a1937 1
#endif /* HASSETUSERCONTEXT */
d1958 1
d1961 2
d1970 1
d1972 2
d1982 1
d1985 2
d1994 1
d1996 2
d2004 19
a2022 3
			if (new_gid != NO_GID && setgid(new_gid) < 0 && suidwarn)
				syserr("openmailer: setgid(%ld) failed",
					(long) new_gid);
d2032 1
d2035 2
d2038 1
d2040 2
d2058 7
d2066 1
a2066 1
#if MAILER_SETUID_METHOD == USE_SETEUID
d2068 1
d2071 4
a2074 2
#endif /* MAILER_SETUID_METHOD == USE_SETEUID */
#if MAILER_SETUID_METHOD == USE_SETREUID
d2076 1
d2079 4
a2082 2
#endif /* MAILER_SETUID_METHOD == USE_SETREUID */
#if MAILER_SETUID_METHOD == USE_SETUID
d2084 1
d2087 3
a2089 1
#endif /* MAILER_SETUID_METHOD == USE_SETUID */
d2095 1
d2098 2
d2243 9
a2251 5
		static u_short again = 0;
# define ONLY_HELO_B	0x04
# define ONLY_HELO	bitset(ONLY_HELO_B, again)
# define SET_HELO	again |= ONLY_HELO_B
# define CLR_HELO	again &= ~ONLY_HELO_B
d2254 4
d2261 2
a2262 2
		smtpinit(m, mci, e, ONLY_HELO);
		CLR_HELO;
d2264 199
d2467 3
d2478 41
d2612 1
d2616 1
d2623 1
d2625 15
d2726 4
d2742 1
d2778 1
a2778 1
		if (e->e_nsent >= CheckpointInterval)
d2852 1
d3024 1
d3036 4
d3046 2
a3047 1
	if (mci->mci_in != NULL && e->e_xfp != NULL)
a3050 1
		/* while (fgets(buf, sizeof buf, mci->mci_in) != NULL) */
d3074 1
a3074 1
			syserr("endmailer %s: wait timeout (%d)",
d3076 1
a3076 1
			       mci->mci_mailer->m_wait);
d3389 1
d3410 1
d3412 1
a3412 1
		 pintvl(curtime() - e->e_ctime, TRUE));
d3418 1
a3418 1
			 pintvl(curtime() - xstart, TRUE));
d3500 1
a3500 1
		register char *q = strchr(p + l, ',');
d3502 10
d3514 2
d3518 1
a3518 1
			  ++q - p, p, buf);
d3521 3
d3525 1
d3533 1
a3533 1
		register char *q = strchr(p + l, ',');
d3535 10
d3547 2
d3551 1
a3551 1
			  ++q - p, p);
d3554 3
d3558 1
d3576 1
a3576 1
		 pintvl(curtime() - e->e_ctime, TRUE));
d3581 1
a3581 1
			 pintvl(curtime() - xstart, TRUE));
d3736 7
a3742 2
			syserr("putbody: Cannot open %s for %s from %s",
				df, e->e_to, e->e_from.q_paddr);
d3754 1
d3855 1
a3855 1
		while (!ferror(mci->mci_out))
d3911 2
a3912 1
						(void) putc(*xp, TrafficLogFile);
d3920 2
d3923 6
d3933 2
a3934 1
					if (putc(*xp, mci->mci_out) == EOF)
d3939 5
a3943 3

					/* record progress for DATA timeout */
					DataProgress = TRUE;
d3952 5
a3965 2
				/* record progress for DATA timeout */
				DataProgress = TRUE;
d3984 5
a3988 3

					/* record progress for DATA timeout */
					DataProgress = TRUE;
d4032 6
a4037 2
							(void) putc(c, TrafficLogFile);
						if (putc(c, mci->mci_out) == EOF)
d4039 6
d4052 2
d4055 6
a4060 3

					/* record progress for DATA timeout */
					DataProgress = TRUE;
d4079 5
d4090 6
a4095 2
						(void) putc(c, TrafficLogFile);
					if (putc(c, mci->mci_out) == EOF)
d4097 6
a4105 3

				/* record progress for DATA timeout */
				DataProgress = TRUE;
d4116 2
a4117 1
					(void) putc(*xp, TrafficLogFile);
d4121 2
a4122 1
				if (putc(*xp, mci->mci_out) == EOF)
d4127 5
a4131 3

				/* record progress for DATA timeout */
				DataProgress = TRUE;
d4170 1
a4170 1
	if (bitnset(M_BLANKEND, mci->mci_mailer->m_flags) &&
d4403 6
d4436 1
d4438 9
a4448 2
			else if (ctladdr != NULL && ctladdr->q_uid != 0)
				RealGid = ctladdr->q_gid;
d4452 7
d4460 4
d4483 1
d4486 2
d4495 1
d4497 2
d4523 1
d4525 2
d4531 1
d4533 2
d4537 1
d4539 2
d4758 1
d4817 1
d4857 1
a4857 1
				mci->mci_lastuse = curtime();
d5057 200
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: deliver.c,v 8.600.2.1.2.81 2001/05/23 02:15:42 ca Exp $";
a19 1

a23 3
#if STARTTLS || (SASL && SFIO)
# include "sfsasl.h"
#endif /* STARTTLS || (SASL && SFIO) */
a33 3
# if STARTTLS
static int	starttls __P((MAILER *, MCI *, ENVELOPE *));
# endif /* STARTTLS */
a130 8
		char *recip;

		if (e->e_sendqueue != NULL &&
		    e->e_sendqueue->q_paddr != NULL)
			recip = e->e_sendqueue->q_paddr;
		else
			recip = "(nobody)";

d137 4
a140 4
		syserr("554 5.4.6 Too many hops %d (%d max): from %s via %s, to %s",
		       e->e_hopcount, MaxHopCount, e->e_from.q_paddr,
		       RealHostName == NULL ? "localhost" : RealHostName,
		       recip);
a144 1
			q->q_state = QS_BADADDR;
a145 1
			q->q_rstatus = "554 5.4.6 Too many hops";
a457 2
		time_t now = curtime();

d463 1
a463 1
		e->e_dtime = now;
d468 1
a468 1
			ee->e_dtime = now;
d479 2
a480 7
		/*
		**  Be sure everything is instantiated in the queue.
		**  Split envelopes first in case the machine crashes.
		**  If the original were done first, we may lose
		**  recipients.
		*/

a482 1
		queueup(e, mode == SM_QUEUE || mode == SM_DEFER);
a621 14
		/* Reset global flags */
		RestartRequest = NULL;
		ShutdownRequest = NULL;
		PendingSignal = 0;

		/*
		**  Since we have accepted responsbility for the message,
		**  change the SIGTERM handler.  intsig() (the old handler)
		**  would remove the envelope if this was a command line
		**  message submission.
		*/

		(void) setsignal(SIGTERM, SIG_DFL);

d782 1
a782 2
			if (CheckpointInterval > 0 &&
			    e->e_nsent >= CheckpointInterval)
d908 1
a908 1
pid_t
a977 8
#if _FFR_DYNAMIC_TOBUF
	int strsize;
	int rcptcount;
	static int tobufsize = 0;
	static char *tobuf = NULL;
#else /* _FFR_DYNAMIC_TOBUF */
	char tobuf[TOBUFSIZE];		/* text line of to people */
#endif /* _FFR_DYNAMIC_TOBUF */
d982 1
d1102 1
a1102 1
		/* running LMTP or SMTP */
a1111 8
	else if (bitnset(M_LMTP, m->m_flags))
	{
		/* not running LMTP */
		sm_syslog(LOG_ERR, NULL,
			  "Warning: mailer %s: LMTP flag (F=z) turned off",
			  m->m_name);
		clrbitn(M_LMTP, m->m_flags);
	}
a1119 5
#if _FFR_DYNAMIC_TOBUF
	e->e_to = NULL;
	strsize = 2;
	rcptcount = 0;
#else /* _FFR_DYNAMIC_TOBUF */
a1121 2
#endif /* _FFR_DYNAMIC_TOBUF */

a1126 4
#if _FFR_DYNAMIC_TOBUF
		if (tochain != NULL && !bitnset(M_MUSER, m->m_flags))
			break;
#else /* _FFR_DYNAMIC_TOBUF */
a1128 1
#endif /* _FFR_DYNAMIC_TOBUF */
a1137 8
#if _FFR_DYNAMIC_TOBUF
		strsize += strlen(to->q_paddr) + 1;
		if (!clever && strsize > TOBUFSIZE)
			break;

		if (++rcptcount > to->q_mailer->m_maxrcpt)
			break;
#else /* _FFR_DYNAMIC_TOBUF */
a1139 1
#endif /* _FFR_DYNAMIC_TOBUF */
a1162 1
		**  Check also for overflow of e_msgsize.
d1165 1
a1165 2
		if (m->m_maxsize != 0 &&
		    (e->e_msgsize > m->m_maxsize || e->e_msgsize < 0))
d1182 1
a1182 1
		SM_SET_H_ERRNO(0);
d1188 1
a1188 1
				e, TRUE, TRUE, 4, NULL);
a1308 3
#if _FFR_DYNAMIC_TOBUF
		e->e_to = "[CHAIN]";
#else /* _FFR_DYNAMIC_TOBUF */
a1311 2
#endif /* _FFR_DYNAMIC_TOBUF */

a1360 3
#if _FFR_DYNAMIC_TOBUF
	if (tochain == NULL)
#else /* _FFR_DYNAMIC_TOBUF */
a1361 1
#endif /* _FFR_DYNAMIC_TOBUF */
a1363 1
		e->e_to = NULL;
a1367 26
#if _FFR_DYNAMIC_TOBUF
	{
		int l = 1;
		char *tobufptr;

		for (to = tochain; to != NULL; to = to->q_tchain)
			l += strlen(to->q_paddr) + 1;
		if (l < TOBUFSIZE)
			l = TOBUFSIZE;
		if (l > tobufsize)
		{
			if (tobuf != NULL)
				sm_free(tobuf);
			tobufsize = l;
			tobuf = xalloc(tobufsize);
		}
		tobufptr = tobuf;
		*tobufptr = '\0';
		for (to = tochain; to != NULL; to = to->q_tchain)
		{
			snprintf(tobufptr, tobufsize - (tobufptr - tobuf),
				 ",%s", to->q_paddr);
			tobufptr += strlen(tobufptr);
		}
	}
#endif /* _FFR_DYNAMIC_TOBUF */
d1409 1
a1409 1
	SM_SET_H_ERRNO(0);
d1511 1
a1511 1
			port = htons((u_short)atoi(pv[2]));
a1621 1
			mci->mci_errno = errno;
d1625 1
a1786 2


a1788 1

a1812 5
			/* Reset global flags */
			RestartRequest = NULL;
			ShutdownRequest = NULL;
			PendingSignal = 0;

d1824 1
a1824 1
# if HASSETUSERCONTEXT
d1842 1
a1842 1
# endif /* HASSETUSERCONTEXT */
a1862 1
					{
a1864 2
						exit(EX_TEMPFAIL);
					}
a1871 1
					{
a1872 2
						exit(EX_TEMPFAIL);
					}
a1880 1
					{
a1882 2
						exit(EX_TEMPFAIL);
					}
a1889 1
					{
a1890 2
						exit(EX_TEMPFAIL);
					}
d1897 3
a1899 19
			if (new_gid != NO_GID)
			{
				if (RunAsUid != 0 &&
				    bitnset(M_SPECIFIC_UID, m->m_flags) &&
				    new_gid != getgid() &&
				    new_gid != getegid())
				{
					/* Only root can change the gid */
					syserr("openmailer: insufficient privileges to change gid");
					exit(EX_TEMPFAIL);
				}

				if (setgid(new_gid) < 0 && suidwarn)
				{
					syserr("openmailer: setgid(%ld) failed",
					       (long) new_gid);
					exit(EX_TEMPFAIL);
				}
			}
a1908 1
				{
a1910 2
					exit(EX_TEMPFAIL);
				}
a1911 1
				{
a1912 2
					exit(EX_TEMPFAIL);
				}
a1928 7
				if (RunAsUid != 0 && new_euid != RunAsUid)
				{
					/* Only root can change the uid */
					syserr("openmailer: insufficient privileges to change uid");
					exit(EX_TEMPFAIL);
				}

d1930 1
a1930 1
# if MAILER_SETUID_METHOD == USE_SETEUID
a1931 1
				{
d1934 2
a1935 4
					exit(EX_TEMPFAIL);
				}
# endif /* MAILER_SETUID_METHOD == USE_SETEUID */
# if MAILER_SETUID_METHOD == USE_SETREUID
a1936 1
				{
d1939 2
a1940 4
					exit(EX_TEMPFAIL);
				}
# endif /* MAILER_SETUID_METHOD == USE_SETREUID */
# if MAILER_SETUID_METHOD == USE_SETUID
a1941 1
				{
d1944 1
a1944 3
					exit(EX_TEMPFAIL);
				}
# endif /* MAILER_SETUID_METHOD == USE_SETUID */
a1949 1
				{
a1951 2
					exit(EX_TEMPFAIL);
				}
d2095 5
a2099 10
# if SASL && SFIO
#  define DONE_AUTH(f)		bitset(MCIF_AUTHACT, f)
# endif /* SASL && SFIO */
# if STARTTLS
#  define DONE_STARTTLS(f)	bitset(MCIF_TLSACT, f)
# endif /* STARTTLS */
# define ONLY_HELO(f)		bitset(MCIF_ONLY_EHLO, f)
# define SET_HELO(f)		f |= MCIF_ONLY_EHLO
# define CLR_HELO(f)		f &= ~MCIF_ONLY_EHLO

a2100 3
# if STARTTLS || (SASL && SFIO)
reconnect:	/* after switching to an authenticated connection */
# endif /* STARTTLS || (SASL && SFIO) */
d2105 2
a2106 38
		smtpinit(m, mci, e, ONLY_HELO(mci->mci_flags));
		CLR_HELO(mci->mci_flags);

# if STARTTLS
		/* first TLS then AUTH to provide a security layer */
		if (mci->mci_state != MCIS_CLOSED &&
		    !DONE_STARTTLS(mci->mci_flags))
		{
			int olderrors;
			int dotpos;
			bool usetls;
			bool saveQuickAbort = QuickAbort;
			bool saveSuprErrs = SuprErrs;
			char *host = NULL;
#  if _FFR_TLS_CLT1
			char *p;
#  endif /* _FFR_TLS_CLT1 */
			char *srvname;
			extern SOCKADDR CurHostAddr;

			rcode = EX_OK;
			usetls = bitset(MCIF_TLS, mci->mci_flags);
#  if _FFR_TLS_CLT1
			if (usetls &&
			    (p = macvalue(macid("{client_flags}", NULL), e))
			    != NULL)
			{
				for (; *p != '\0'; p++)
				{
					/* look for just this one flag */
					if (*p == D_CLTNOTLS)
					{
						usetls = FALSE;
						break;
					}
				}
			}
#  endif /* _FFR_TLS_CLT1 */
a2107 178
			if (mci->mci_host != NULL)
			{
				srvname = mci->mci_host;
				dotpos = strlen(srvname) - 1;
				if (dotpos >= 0)
				{
					if (srvname[dotpos] == '.')
						srvname[dotpos] = '\0';
					else
						dotpos = -1;
				}
			}
			else
			{
				srvname = "";
				dotpos = -1;
			}
			define(macid("{server_name}", NULL),
			       newstr(srvname), e);
			if (CurHostAddr.sa.sa_family != 0)
				define(macid("{server_addr}", NULL),
				       newstr(anynet_ntoa(&CurHostAddr)), e);
			else
				define(macid("{server_addr}", NULL), NULL, e);
			if (usetls)
			{
				host = macvalue(macid("{server_name}", NULL),
						e);
#  if _FFR_TLS_O_T
				olderrors = Errors;
				QuickAbort = FALSE;
				SuprErrs = TRUE;
				if (rscheck("try_tls", srvname, NULL,
					    e, TRUE, FALSE, 8, host) != EX_OK
				    || Errors > olderrors)
					usetls = FALSE;
				SuprErrs = saveSuprErrs;
				QuickAbort = saveQuickAbort;
#  endif /* _FFR_TLS_O_T */
			}

			/* undo change of srvname */
			if (dotpos >= 0)
				srvname[dotpos] = '.';
			if (usetls)
			{
				if ((rcode = starttls(m, mci, e)) == EX_OK)
				{
					/* start again without STARTTLS */
					mci->mci_flags |= MCIF_TLSACT;
				}
				else
				{
					char *s;

					/*
					**  TLS negotation failed, what to do?
					**  fall back to unencrypted connection
					**  or abort? How to decide?
					**  set a macro and call a ruleset.
					*/
					mci->mci_flags &= ~MCIF_TLS;
					switch (rcode)
					{
					  case EX_TEMPFAIL:
						s = "TEMP";
						break;
					  case EX_USAGE:
						s = "USAGE";
						break;
					  case EX_PROTOCOL:
						s = "PROTOCOL";
						break;
					  case EX_SOFTWARE:
						s = "SOFTWARE";
						break;

					  /* everything else is a failure */
					  default:
						s = "FAILURE";
						rcode = EX_TEMPFAIL;
					}
					define(macid("{verify}", NULL),
					       newstr(s), e);
				}
			}
			else if (mci->mci_ssl != NULL)
			{
				/* active TLS connection, use that data */
				(void) tls_get_info(mci->mci_ssl, e, FALSE,
						    mci->mci_host, FALSE);
			}
			else
				define(macid("{verify}", NULL), "NONE", e);
			olderrors = Errors;
			QuickAbort = FALSE;
			SuprErrs = TRUE;

			/*
			**  rcode == EX_SOFTWARE is special:
			**  the TLS negotation failed
			**  we have to drop the connection no matter what
			**  However, we call tls_server to give it the chance
			**  to log the problem and return an appropriate
			**  error code.
			*/
			if (rscheck("tls_server",
				     macvalue(macid("{verify}", NULL), e),
				     NULL, e, TRUE, TRUE, 6, host) != EX_OK ||
			    Errors > olderrors ||
			    rcode == EX_SOFTWARE)
			{
				char enhsc[ENHSCLEN];
				extern char MsgBuf[];

				if (ISSMTPCODE(MsgBuf) &&
				    extenhsc(MsgBuf + 4, ' ', enhsc) > 0)
				{
					p = newstr(MsgBuf);
				}
				else
				{
					p = "403 4.7.0 server not authenticated.";
					(void) strlcpy(enhsc, "4.7.0",
						       sizeof enhsc);
				}
				SuprErrs = saveSuprErrs;
				QuickAbort = saveQuickAbort;

				if (rcode == EX_SOFTWARE)
				{
					/* drop the connection */
					mci->mci_state = MCIS_QUITING;
					if (mci->mci_in != NULL)
					{
						(void) fclose(mci->mci_in);
						mci->mci_in = NULL;
					}
					mci->mci_flags &= ~MCIF_TLSACT;
					(void) endmailer(mci, e, pv);
				}
				else
				{
					/* abort transfer */
					smtpquit(m, mci, e);
				}

				/* avoid bogus error msg */
				mci->mci_errno = 0;

				/* temp or permanent failure? */
				rcode = (*p == '4') ? EX_TEMPFAIL
						    : EX_UNAVAILABLE;
				mci_setstat(mci, rcode, newstr(enhsc), p);

				/*
				**  hack to get the error message into
				**  the envelope (done in giveresponse())
				*/
				(void) strlcpy(SmtpError, p, sizeof SmtpError);
			}
			QuickAbort = saveQuickAbort;
			SuprErrs = saveSuprErrs;
			if (DONE_STARTTLS(mci->mci_flags) &&
			    mci->mci_state != MCIS_CLOSED)
			{
				SET_HELO(mci->mci_flags);
				mci->mci_flags &= ~MCIF_EXTENS;
				goto reconnect;
			}
		}
		else if (mci->mci_ssl != NULL)
		{
			/* active TLS connection, use that data */
			(void) tls_get_info(mci->mci_ssl, e, FALSE,
					    mci->mci_host, FALSE);
		}
# endif /* STARTTLS */
a2111 3
#  if SFIO
		    !DONE_AUTH(mci->mci_flags) &&
#  endif /* SFIO */
a2119 43
#  if SFIO
				int result;
				sasl_ssf_t *ssf;

				/* get security strength (features) */
				result = sasl_getprop(mci->mci_conn, SASL_SSF,
						      (void **) &ssf);
				if (LogLevel > 9)
					sm_syslog(LOG_INFO, NOQID,
						  "SASL: outgoing connection to %.64s: mech=%.16s, bits=%d",
						  mci->mci_host,
						  macvalue(macid("{auth_type}",
								 NULL), e),
						  result == SASL_OK ? *ssf
						  		    : 0);

				/*
				**  only switch to encrypted connection
				**  if a security layer has been negotiated
				*/
				if (result == SASL_OK && *ssf > 0)
				{
					/*
					**  convert sfio stuff to use SASL
					**  check return values
					**  if the call fails,
					**  fall back to unencrypted version
					**  unless some cf option requires
					**  encryption then the connection must
					**  be aborted
					*/
					if (sfdcsasl(mci->mci_in, mci->mci_out,
						     mci->mci_conn) == 0)
					{
						SET_HELO(mci->mci_flags);
						mci->mci_flags &= ~MCIF_EXTENS;
						mci->mci_flags |= MCIF_AUTHACT;
						goto reconnect;
					}
					syserr("SASL TLS switch failed in client");
				}
				/* else? XXX */
#  endif /* SFIO */
d2166 1
a2166 1
		SM_SET_H_ERRNO(mci->mci_herrno);
a2196 12
		if (rcode == EX_TEMPFAIL &&
		    SmtpError[0] == '\0')
		{
			/*
			**  Need an e_message for mailq display.
			**  We set SmtpError as
			*/

			snprintf(SmtpError, sizeof SmtpError,
				 "%s mailer (%s) exited with EX_TEMPFAIL",
				 m->m_name, m->m_mailer);
		}
a2212 1

a2215 1
#if !_FFR_DYNAMIC_TOBUF
a2221 1
#endif /* !_FFR_DYNAMIC_TOBUF */
a2222 15
# if STARTTLS
#  if _FFR_TLS_RCPT
				i = rscheck("tls_rcpt", to->q_user, NULL, e,
					    TRUE, TRUE, 4, mci->mci_host);
				if (i != EX_OK)
				{
					/* avoid bogus error msg */
					errno = 0;
					markfailure(e, to, mci, i, FALSE);
					giveresponse(i, to->q_status,  m,
						     mci, ctladdr, xstart, e);
					continue;
				}
#  endif /* _FFR_TLS_RCPT */
# endif /* STARTTLS */
a2308 4
#if _FFR_DYNAMIC_TOBUF
				(void) strlcat(tobuf, ",", tobufsize);
				(void) strlcat(tobuf, to->q_paddr, tobufsize);
#else /* _FFR_DYNAMIC_TOBUF */
a2320 1
#endif /* _FFR_DYNAMIC_TOBUF */
d2356 1
a2356 1
		if (CheckpointInterval > 0 && e->e_nsent >= CheckpointInterval)
a2429 1
	e->e_to = NULL;
a2585 6
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

d2601 10
a2611 1
	mci_unlock_host(mci);
d2618 1
a2618 2
	if (mci->mci_in != NULL && mci->mci_state != MCIS_ERROR &&
	    e->e_xfp != NULL)
d2622 1
a2625 14
#if SASL
	/* shutdown SASL */
	if (bitset(MCIF_AUTHACT, mci->mci_flags))
	{
		sasl_dispose(&mci->mci_conn);
		mci->mci_flags &= ~MCIF_AUTHACT;
	}
#endif /* SASL */

#if STARTTLS
	/* shutdown TLS */
	(void) endtlsclt(mci);
#endif /* STARTTLS */

d2646 1
a2646 1
			syserr("endmailer %s: wait timeout (%ld)",
d2648 1
a2648 1
			       (long) mci->mci_mailer->m_wait);
d2915 1
a2915 1
			sm_free(e->e_message);
d2920 1
a2920 1
	SM_SET_H_ERRNO(0);
a2960 1
	time_t now;
a2980 1
	now = curtime();
d2982 1
a2982 1
		 pintvl(now - e->e_ctime, TRUE));
d2988 1
a2988 1
			 pintvl(now - xstart, TRUE));
d3070 1
a3070 1
		register char *q;
a3071 10
#if _FFR_DYNAMIC_TOBUF
		for (q = p + l; q > p; q--)
		{
			if (*q == ',')
				break;
		}
		if (p == q)
			break;
#else /* _FFR_DYNAMIC_TOBUF */
		q = strchr(p + l, ',');
a3073 2
#endif /* _FFR_DYNAMIC_TOBUF */

d3076 1
a3076 1
			  (int) (++q - p), p, buf);
a3078 3
#if _FFR_DYNAMIC_TOBUF
	sm_syslog(LOG_INFO, e->e_id, "to=%.*s%s", l, p, buf);
#else /* _FFR_DYNAMIC_TOBUF */
a3079 1
#endif /* _FFR_DYNAMIC_TOBUF */
d3087 1
a3087 1
		register char *q;
a3088 10
#if _FFR_DYNAMIC_TOBUF
		for (q = p + l; q > p; q--)
		{
			if (*q == ',')
				break;
		}
		if (p == q)
			break;
#else /* _FFR_DYNAMIC_TOBUF */
		q = strchr(p + l, ',');
a3090 2
#endif /* _FFR_DYNAMIC_TOBUF */

d3093 1
a3093 1
			  (int) (++q - p), p);
a3095 3
#if _FFR_DYNAMIC_TOBUF
	sm_syslog(LOG_INFO, e->e_id, "to=%.*s", l, p);
#else /* _FFR_DYNAMIC_TOBUF */
a3096 1
#endif /* _FFR_DYNAMIC_TOBUF */
d3114 1
a3114 1
		 pintvl(now - e->e_ctime, TRUE));
d3119 1
a3119 1
			 pintvl(now - xstart, TRUE));
d3274 2
a3275 7
		{
			char *msg = "!putbody: Cannot open %s for %s from %s";

			if (errno == ENOENT)
				msg++;
			syserr(msg, df, e->e_to, e->e_from.q_paddr);
		}
a3286 1

d3387 1
a3387 1
		while (!ferror(mci->mci_out) && !dead)
d3443 1
a3443 2
						(void) putc((unsigned char) *xp,
							    TrafficLogFile);
d3446 1
a3446 1
							     TrafficLogFile);
a3450 2
					{
						dead = TRUE;
a3451 6
					}
					else
					{
						/* record progress for DATA timeout */
						DataProgress = TRUE;
					}
d3456 1
a3456 2
					if (putc((unsigned char) *xp,
						 mci->mci_out) == EOF)
d3461 3
a3463 5
					else
					{
						/* record progress for DATA timeout */
						DataProgress = TRUE;
					}
a3471 5
					else
					{
						/* record progress for DATA timeout */
						DataProgress = TRUE;
					}
d3481 2
d3501 3
a3503 5
					else
					{
						/* record progress for DATA timeout */
						DataProgress = TRUE;
					}
d3547 2
a3548 6
							(void) putc((unsigned char) c,
							    TrafficLogFile);
						if (putc((unsigned char) c,
							 mci->mci_out) == EOF)
						{
							dead = TRUE;
a3549 6
						}
						else
						{
							/* record progress for DATA timeout */
							DataProgress = TRUE;
						}
a3556 2
					{
						dead = TRUE;
d3558 3
a3560 6
					}
					else
					{
						/* record progress for DATA timeout */
						DataProgress = TRUE;
					}
a3578 5
					else
					{
						/* record progress for DATA timeout */
						DataProgress = TRUE;
					}
d3585 2
a3586 6
						(void) putc((unsigned char) c,
							    TrafficLogFile);
					if (putc((unsigned char) c,
						 mci->mci_out) == EOF)
					{
						dead = TRUE;
a3587 6
					}
					else
					{
						/* record progress for DATA timeout */
						DataProgress = TRUE;
					}
d3591 3
d3604 1
a3604 2
					(void) putc((unsigned char) *xp,
						    TrafficLogFile);
d3608 1
a3608 2
				if (putc((unsigned char) *xp, mci->mci_out) ==
				    EOF)
d3613 3
a3615 5
				else
				{
					/* record progress for DATA timeout */
					DataProgress = TRUE;
				}
d3654 1
a3654 1
	if (!dead && bitnset(M_BLANKEND, mci->mci_mailer->m_flags) &&
a3826 5
		/* Reset global flags */
		RestartRequest = NULL;
		ShutdownRequest = NULL;
		PendingSignal = 0;

d3843 1
a3843 2
			ev = setevent(TimeOuts.to_fileopen,
				      mailfiletimeout, 0);
a3886 6
				if (RunAsUid != 0 && RealUid != RunAsUid)
				{
					/* Only root can change the uid */
					syserr("mailfile: insufficient privileges to change uid");
					exit(EX_TEMPFAIL);
				}
a3913 1
			{
a3914 9
				if (RunAsUid != 0 &&
				    (RealGid != getgid() ||
				     RealGid != getegid()))
				{
					/* Only root can change the gid */
					syserr("mailfile: insufficient privileges to change gid");
					exit(EX_TEMPFAIL);
				}
			}
d3917 2
a3921 7
			{
				/*
				**  Special case:  This means it is an
				**  alias and we should act as DefaultUser.
				**  See alias()'s comments.
				*/

a3922 4
				RealUserName = DefUser;
			}
			else if (ctladdr != NULL && ctladdr->q_uid != 0)
				RealGid = ctladdr->q_gid;
a3941 1
			{
a3943 2
				exit(EX_TEMPFAIL);
			}
a3950 1
			{
a3951 2
				exit(EX_TEMPFAIL);
			}
a3975 1
		{
a3976 2
			exit(EX_CANTCREAT);
		}
a3980 1
		{
a3981 2
			exit(EX_TEMPFAIL);
		}
a3983 1
		{
a3984 2
			exit(EX_TEMPFAIL);
		}
d4117 1
a4117 1
		if (fflush(f) != 0 ||
a4166 7
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
a4201 1
	time_t now;
d4213 1
a4213 1
	**  If local delivery (and not remote), just return a constant.
d4216 1
a4216 4
	p = m->m_mailer;
	if (bitnset(M_LOCALMAILER, m->m_flags) &&
	    strcmp(p, "[IPC]") != 0 &&
	    strcmp(p, "[TCP]") != 0)
d4223 1
a4259 1
	now = curtime();
d4299 1
a4299 1
				mci->mci_lastuse = now;
d4330 1
a4330 1
			sm_free(s->s_hostsig);
a4498 202
# if STARTTLS
static SSL_CTX	*clt_ctx = NULL;

/*
**  INITCLTTLS -- initialize client side TLS
**
**	Parameters:
**		none.
**
**	Returns:
**		succeeded?
*/

bool
initclttls()
{
	if (clt_ctx != NULL)
		return TRUE;	/* already done */
	return inittls(&clt_ctx, TLS_I_CLT, FALSE, CltCERTfile, Cltkeyfile,
		       CACERTpath, CACERTfile, DHParams);
}

/*
**  STARTTLS -- try to start secure connection (client side)
**
**	Parameters:
**		m -- the mailer.
**		mci -- the mailer connection info.
**		e -- the envelope.
**
**	Returns:
**		success?
**		(maybe this should be some other code than EX_
**		that denotes which stage failed.)
*/

static int
starttls(m, mci, e)
	MAILER *m;
	MCI *mci;
	ENVELOPE *e;
{
	int smtpresult;
	int result = 0;
	int rfd, wfd;
	SSL *clt_ssl = NULL;

	if (clt_ctx == NULL && !initclttls())
		return EX_TEMPFAIL;
	smtpmessage("STARTTLS", m, mci);

	/* get the reply */
	smtpresult = reply(m, mci, e, TimeOuts.to_datafinal, NULL, NULL);
	/* which timeout? XXX */

	/* check return code from server */
	if (smtpresult == 454)
		return EX_TEMPFAIL;
	if (smtpresult == 501)
		return EX_USAGE;
	if (smtpresult == -1)
		return smtpresult;
	if (smtpresult != 220)
		return EX_PROTOCOL;

	if (LogLevel > 13)
		sm_syslog(LOG_INFO, e->e_id, "TLS: start client");

	/* start connection */
	if ((clt_ssl = SSL_new(clt_ctx)) == NULL)
	{
		if (LogLevel > 5)
		{
			sm_syslog(LOG_ERR, e->e_id,
				  "TLS: error: client: SSL_new failed");
			if (LogLevel > 9)
				tlslogerr();
		}
		return EX_SOFTWARE;
	}

	rfd = fileno(mci->mci_in);
	wfd = fileno(mci->mci_out);

	/* SSL_clear(clt_ssl); ? */
	if (rfd < 0 || wfd < 0 ||
	    (result = SSL_set_rfd(clt_ssl, rfd)) <= 0 ||
	    (result = SSL_set_wfd(clt_ssl, wfd)) <= 0)
	{
		if (LogLevel > 5)
		{
			sm_syslog(LOG_ERR, e->e_id,
				  "TLS: error: SSL_set_xfd failed=%d", result);
			if (LogLevel > 9)
				tlslogerr();
		}
		return EX_SOFTWARE;
	}
	SSL_set_connect_state(clt_ssl);
	if ((result = SSL_connect(clt_ssl)) <= 0)
	{
		int i;

		/* what to do in this case? */
		i = SSL_get_error(clt_ssl, result);
		if (LogLevel > 5)
		{
			sm_syslog(LOG_ERR, e->e_id,
				  "TLS: error: SSL_connect failed=%d (%d)",
				  result, i);
			if (LogLevel > 9)
				tlslogerr();
		}
		SSL_free(clt_ssl);
		clt_ssl = NULL;
		return EX_SOFTWARE;
	}
	mci->mci_ssl = clt_ssl;
	result = tls_get_info(clt_ssl, e, FALSE, mci->mci_host, TRUE);

	/* switch to use SSL... */
#if SFIO
	if (sfdctls(mci->mci_in, mci->mci_out, mci->mci_ssl) == 0)
		return EX_OK;
#else /* SFIO */
# if _FFR_TLS_TOREK
	if (sfdctls(&mci->mci_in, &mci->mci_out, mci->mci_ssl) == 0)
		return EX_OK;
# endif /* _FFR_TLS_TOREK */
#endif /* SFIO */

	/* failure */
	SSL_free(clt_ssl);
	clt_ssl = NULL;
	return EX_SOFTWARE;
}

/*
**  ENDTLSCLT -- shutdown secure connection (client side)
**
**	Parameters:
**		mci -- the mailer connection info.
**
**	Returns:
**		success?
*/
int
endtlsclt(mci)
	MCI *mci;
{
	int r;

	if (!bitset(MCIF_TLSACT, mci->mci_flags))
		return EX_OK;
	r = endtls(mci->mci_ssl, "client");
	mci->mci_flags &= ~MCIF_TLSACT;
	return r;
}
/*
**  ENDTLS -- shutdown secure connection
**
**	Parameters:
**		ssl -- SSL connection information.
**		side -- srv/clt (for logging).
**
**	Returns:
**		success?
*/

int
endtls(ssl, side)
	SSL *ssl;
	char *side;
{
	int ret = EX_OK;

	if (ssl != NULL)
	{
		int r;

		if ((r = SSL_shutdown(ssl)) < 0)
		{
			if (LogLevel > 11)
				sm_syslog(LOG_WARNING, NOQID,
					  "SSL_shutdown %s failed: %d",
					  side, r);
			ret = EX_SOFTWARE;
		}
		else if (r == 0)
		{
			if (LogLevel > 13)
				sm_syslog(LOG_WARNING, NOQID,
					  "SSL_shutdown %s not done",
					  side);
			ret = EX_SOFTWARE;
		}
		SSL_free(ssl);
		ssl = NULL;
	}
	return ret;
}
# endif /* STARTTLS */
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: deliver.c,v 8.594 2000/02/10 20:40:06 ca Exp $";
d1187 2
a1188 2
		rcode = rscheck("check_compat",
				e->e_from.q_paddr, to->q_paddr, e, TRUE, TRUE);
d2222 3
a2224 1
				else if ((i = smtprcpt(to, m, mci, e)) != EX_OK)
d3067 1
a3067 1
	p = e->e_to;
d3084 1
a3084 1
	p = e->e_to;
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Id: deliver.c,v 8.600.2.1.2.56 2000/12/19 01:16:12 gshapiro Exp $";
a19 1

a23 3
#if STARTTLS || (SASL && SFIO)
# include "sfsasl.h"
#endif /* STARTTLS || (SASL && SFIO) */
a33 3
# if STARTTLS
static int	starttls __P((MAILER *, MCI *, ENVELOPE *));
# endif /* STARTTLS */
a144 1
			q->q_state = QS_BADADDR;
a457 2
		time_t now = curtime();

d463 1
a463 1
		e->e_dtime = now;
d468 1
a468 1
			ee->e_dtime = now;
d479 2
a480 7
		/*
		**  Be sure everything is instantiated in the queue.
		**  Split envelopes first in case the machine crashes.
		**  If the original were done first, we may lose
		**  recipients.
		*/

a482 1
		queueup(e, mode == SM_QUEUE || mode == SM_DEFER);
a621 9
		/*
		**  Since we have accepted responsbility for the message,
		**  change the SIGTERM handler.  intsig() (the old handler)
		**  would remove the envelope if this was a command line
		**  message submission.
		*/

		(void) setsignal(SIGTERM, SIG_DFL);

d782 1
a782 2
			if (CheckpointInterval > 0 &&
			    e->e_nsent >= CheckpointInterval)
a977 8
#if _FFR_DYNAMIC_TOBUF
	int strsize;
	int rcptcount;
	static int tobufsize = 0;
	static char *tobuf = NULL;
#else /* _FFR_DYNAMIC_TOBUF */
	char tobuf[TOBUFSIZE];		/* text line of to people */
#endif /* _FFR_DYNAMIC_TOBUF */
d982 1
a1119 5
#if _FFR_DYNAMIC_TOBUF
	e->e_to = NULL;
	strsize = 2;
	rcptcount = 0;
#else /* _FFR_DYNAMIC_TOBUF */
a1121 2
#endif /* _FFR_DYNAMIC_TOBUF */

a1126 4
#if _FFR_DYNAMIC_TOBUF
		if (tochain != NULL && !bitnset(M_MUSER, m->m_flags))
			break;
#else /* _FFR_DYNAMIC_TOBUF */
a1128 1
#endif /* _FFR_DYNAMIC_TOBUF */
a1137 8
#if _FFR_DYNAMIC_TOBUF
		strsize += strlen(to->q_paddr) + 1;
		if (!clever && strsize > TOBUFSIZE)
			break;

		if (++rcptcount > to->q_mailer->m_maxrcpt)
			break;
#else /* _FFR_DYNAMIC_TOBUF */
a1139 1
#endif /* _FFR_DYNAMIC_TOBUF */
a1162 1
		**  Check also for overflow of e_msgsize.
d1165 1
a1165 2
		if (m->m_maxsize != 0 &&
		    (e->e_msgsize > m->m_maxsize || e->e_msgsize < 0))
d1187 2
a1188 2
		rcode = rscheck("check_compat", e->e_from.q_paddr, to->q_paddr,
				e, TRUE, TRUE, 4, NULL);
a1308 3
#if _FFR_DYNAMIC_TOBUF
		e->e_to = "[CHAIN]";
#else /* _FFR_DYNAMIC_TOBUF */
a1311 2
#endif /* _FFR_DYNAMIC_TOBUF */

a1360 3
#if _FFR_DYNAMIC_TOBUF
	if (tochain == NULL)
#else /* _FFR_DYNAMIC_TOBUF */
a1361 1
#endif /* _FFR_DYNAMIC_TOBUF */
a1363 1
		e->e_to = NULL;
a1367 26
#if _FFR_DYNAMIC_TOBUF
	{
		int l = 1;
		char *tobufptr;

		for (to = tochain; to != NULL; to = to->q_tchain)
			l += strlen(to->q_paddr) + 1;
		if (l < TOBUFSIZE)
			l = TOBUFSIZE;
		if (l > tobufsize)
		{
			if (tobuf != NULL)
				free(tobuf);
			tobufsize = l;
			tobuf = xalloc(tobufsize);
		}
		tobufptr = tobuf;
		*tobufptr = '\0';
		for (to = tochain; to != NULL; to = to->q_tchain)
		{
			snprintf(tobufptr, tobufsize - (tobufptr - tobuf),
				 ",%s", to->q_paddr);
			tobufptr += strlen(tobufptr);
		}
	}
#endif /* _FFR_DYNAMIC_TOBUF */
d1511 1
a1511 1
			port = htons((u_short)atoi(pv[2]));
a1786 2


a1788 1

d1824 1
a1824 1
# if HASSETUSERCONTEXT
d1842 1
a1842 1
# endif /* HASSETUSERCONTEXT */
a1862 1
					{
a1864 2
						exit(EX_TEMPFAIL);
					}
a1871 1
					{
a1872 2
						exit(EX_TEMPFAIL);
					}
a1880 1
					{
a1882 2
						exit(EX_TEMPFAIL);
					}
a1889 1
					{
a1890 2
						exit(EX_TEMPFAIL);
					}
d1897 3
a1899 19
			if (new_gid != NO_GID)
			{
				if (RunAsUid != 0 &&
				    bitnset(M_SPECIFIC_UID, m->m_flags) &&
				    new_gid != getgid() &&
				    new_gid != getegid())
				{
					/* Only root can change the gid */
					syserr("openmailer: insufficient privileges to change gid");
					exit(EX_TEMPFAIL);
				}

				if (setgid(new_gid) < 0 && suidwarn)
				{
					syserr("openmailer: setgid(%ld) failed",
					       (long) new_gid);
					exit(EX_TEMPFAIL);
				}
			}
a1908 1
				{
a1910 2
					exit(EX_TEMPFAIL);
				}
a1911 1
				{
a1912 2
					exit(EX_TEMPFAIL);
				}
a1928 7
				if (RunAsUid != 0 && new_euid != RunAsUid)
				{
					/* Only root can change the uid */
					syserr("openmailer: insufficient privileges to change uid");
					exit(EX_TEMPFAIL);
				}

d1930 1
a1930 1
# if MAILER_SETUID_METHOD == USE_SETEUID
a1931 1
				{
d1934 2
a1935 4
					exit(EX_TEMPFAIL);
				}
# endif /* MAILER_SETUID_METHOD == USE_SETEUID */
# if MAILER_SETUID_METHOD == USE_SETREUID
a1936 1
				{
d1939 2
a1940 4
					exit(EX_TEMPFAIL);
				}
# endif /* MAILER_SETUID_METHOD == USE_SETREUID */
# if MAILER_SETUID_METHOD == USE_SETUID
a1941 1
				{
d1944 1
a1944 3
					exit(EX_TEMPFAIL);
				}
# endif /* MAILER_SETUID_METHOD == USE_SETUID */
a1949 1
				{
a1951 2
					exit(EX_TEMPFAIL);
				}
d2095 5
a2099 9
# if SASL && SFIO
#  define DONE_AUTH(f)		bitset(MCIF_AUTHACT, f)
# endif /* SASL && SFIO */
# if STARTTLS
#  define DONE_STARTTLS(f)	bitset(MCIF_TLSACT, f)
# endif /* STARTTLS */
# define ONLY_HELO(f)		bitset(MCIF_ONLY_EHLO, f)
# define SET_HELO(f)		f |= MCIF_ONLY_EHLO
# define CLR_HELO(f)		f &= ~MCIF_ONLY_EHLO
a2101 4
# if STARTTLS || (SASL && SFIO)
reconnect:	/* after switching to an authenticated connection */
# endif /* STARTTLS || (SASL && SFIO) */

d2105 2
a2106 178
		smtpinit(m, mci, e, ONLY_HELO(mci->mci_flags));
		CLR_HELO(mci->mci_flags);

# if STARTTLS
		/* first TLS then AUTH to provide a security layer */
		if (mci->mci_state != MCIS_CLOSED &&
		    !DONE_STARTTLS(mci->mci_flags))
		{
			int olderrors;
			bool hasdot;
			bool usetls;
			bool saveQuickAbort = QuickAbort;
			bool saveSuprErrs = SuprErrs;
			char *host = NULL;
#  if _FFR_TLS_CLT1
			char *p;
#  endif /* _FFR_TLS_CLT1 */
			extern SOCKADDR CurHostAddr;

			rcode = EX_OK;
			usetls = bitset(MCIF_TLS, mci->mci_flags);
#  if _FFR_TLS_CLT1
			if (usetls &&
			    (p = macvalue(macid("{client_flags}", NULL), e))
			    != NULL)
			{
				for (; *p != '\0'; p++)
				{
					/* look for just this one flag */
					if (*p == D_CLTNOTLS)
					{
						usetls = FALSE;
						break;
					}
				}
			}
#  endif /* _FFR_TLS_CLT1 */

			hasdot = CurHostName[strlen(CurHostName) - 1] == '.';
			if (hasdot)
				CurHostName[strlen(CurHostName) - 1] = '\0';
			define(macid("{server_name}", NULL),
			       newstr(CurHostName), e);
			if (CurHostAddr.sa.sa_family != 0)
				define(macid("{server_addr}", NULL),
				       newstr(anynet_ntoa(&CurHostAddr)), e);
			else
				define(macid("{server_addr}", NULL), NULL, e);
			if (usetls)
			{
				host = macvalue(macid("{server_name}", NULL),
						e);
#  if _FFR_TLS_O_T
				olderrors = Errors;
				QuickAbort = FALSE;
				SuprErrs = TRUE;
				if (rscheck("try_tls", CurHostName, NULL,
					    e, TRUE, FALSE, 8, host) != EX_OK
				    || Errors > olderrors)
					usetls = FALSE;
				SuprErrs = saveSuprErrs;
				QuickAbort = saveQuickAbort;
#  endif /* _FFR_TLS_O_T */
			}

			/* undo change of CurHostName */
			if (hasdot)
				CurHostName[strlen(CurHostName)] = '.';
			if (usetls)
			{
				if ((rcode = starttls(m, mci, e)) == EX_OK)
				{
					/* start again without STARTTLS */
					mci->mci_flags |= MCIF_TLSACT;
				}
				else
				{
					char *s;

					/*
					**  TLS negotation failed, what to do?
					**  fall back to unencrypted connection
					**  or abort? How to decide?
					**  set a macro and call a ruleset.
					*/
					mci->mci_flags &= ~MCIF_TLS;
					switch (rcode)
					{
					  case EX_TEMPFAIL:
						s = "TEMP";
						break;
					  case EX_USAGE:
						s = "USAGE";
						break;
					  case EX_PROTOCOL:
						s = "PROTOCOL";
						break;
					  case EX_SOFTWARE:
						s = "SOFTWARE";
						break;

					  /* everything else is a failure */
					  default:
						s = "FAILURE";
						rcode = EX_TEMPFAIL;
					}
					define(macid("{verify}", NULL),
					       newstr(s), e);
				}
			}
			else if (mci->mci_ssl != NULL)
			{
				/* active TLS connection, use that data */
				(void) tls_get_info(mci->mci_ssl, e, FALSE,
						    mci->mci_host, FALSE);
			}
			else
				define(macid("{verify}", NULL), "NONE", e);
			olderrors = Errors;
			QuickAbort = FALSE;
			SuprErrs = TRUE;

			/*
			**  rcode == EX_SOFTWARE is special:
			**  the TLS negotation failed
			**  we have to drop the connection no matter what
			**  However, we call tls_server to give it the chance
			**  to log the problem and return an appropriate
			**  error code.
			*/
			if (rscheck("tls_server",
				     macvalue(macid("{verify}", NULL), e),
				     NULL, e, TRUE, TRUE, 6, host) != EX_OK ||
			    Errors > olderrors ||
			    rcode == EX_SOFTWARE)
			{
				char enhsc[ENHSCLEN];
				extern char MsgBuf[];

				if (ISSMTPCODE(MsgBuf) &&
				    extenhsc(MsgBuf + 4, ' ', enhsc) > 0)
				{
					p = newstr(MsgBuf);
				}
				else
				{
					p = "403 4.7.0 server not authenticated.";
					(void) strlcpy(enhsc, "4.7.0",
						       sizeof enhsc);
				}
				SuprErrs = saveSuprErrs;
				QuickAbort = saveQuickAbort;

				if (rcode == EX_SOFTWARE)
				{
					/* drop the connection */
					mci->mci_state = MCIS_QUITING;
					if (mci->mci_in != NULL)
					{
						(void) fclose(mci->mci_in);
						mci->mci_in = NULL;
					}
					mci->mci_flags &= ~MCIF_TLSACT;
					(void) endmailer(mci, e, pv);
				}
				else
				{
					/* abort transfer */
					smtpquit(m, mci, e);
				}

				/* avoid bogus error msg */
				mci->mci_errno = 0;

				/* temp or permanent failure? */
				rcode = (*p == '4') ? EX_TEMPFAIL
						    : EX_UNAVAILABLE;
				mci_setstat(mci, rcode, newstr(enhsc), p);
a2107 23
				/*
				**  hack to get the error message into
				**  the envelope (done in giveresponse())
				*/
				(void) strlcpy(SmtpError, p, sizeof SmtpError);
			}
			QuickAbort = saveQuickAbort;
			SuprErrs = saveSuprErrs;
			if (DONE_STARTTLS(mci->mci_flags) &&
			    mci->mci_state != MCIS_CLOSED)
			{
				SET_HELO(mci->mci_flags);
				mci->mci_flags &= ~MCIF_EXTENS;
				goto reconnect;
			}
		}
		else if (mci->mci_ssl != NULL)
		{
			/* active TLS connection, use that data */
			(void) tls_get_info(mci->mci_ssl, e, FALSE,
					    mci->mci_host, FALSE);
		}
# endif /* STARTTLS */
a2111 3
#  if SFIO
		    !DONE_AUTH(mci->mci_flags) &&
#  endif /* SFIO */
a2119 41
#  if SFIO
				int result;
				sasl_ssf_t *ssf;

				/* get security strength (features) */
				result = sasl_getprop(mci->mci_conn, SASL_SSF,
						      (void **) &ssf);
				if (LogLevel > 9)
					sm_syslog(LOG_INFO, NOQID,
						  "SASL: outgoing connection to %.64s: mech=%.16s, bits=%d",
						  mci->mci_host,
						  macvalue(macid("{auth_type}",
								 NULL), e),
						  *ssf);
				/*
				**  only switch to encrypted connection
				**  if a security layer has been negotiated
				*/
				if (result == SASL_OK && *ssf > 0)
				{
					/*
					**  convert sfio stuff to use SASL
					**  check return values
					**  if the call fails,
					**  fall back to unencrypted version
					**  unless some cf option requires
					**  encryption then the connection must
					**  be aborted
					*/
					if (sfdcsasl(mci->mci_in, mci->mci_out,
						     mci->mci_conn) == 0)
					{
						SET_HELO(mci->mci_flags);
						mci->mci_flags &= ~MCIF_EXTENS;
						mci->mci_flags |= MCIF_AUTHACT;
						goto reconnect;
					}
					syserr("SASL TLS switch failed in client");
				}
				/* else? XXX */
#  endif /* SFIO */
a2212 1

a2215 1
#if !_FFR_DYNAMIC_TOBUF
d2222 1
a2222 19
#endif /* !_FFR_DYNAMIC_TOBUF */

# if STARTTLS
#  if _FFR_TLS_RCPT
				i = rscheck("tls_rcpt", to->q_user, NULL, e,
					    TRUE, TRUE, 4, mci->mci_host);
				if (i != EX_OK)
				{
					/* avoid bogus error msg */
					errno = 0;
					markfailure(e, to, mci, i, FALSE);
					giveresponse(i, to->q_status,  m,
						     mci, ctladdr, xstart, e);
					continue;
				}
#  endif /* _FFR_TLS_RCPT */
# endif /* STARTTLS */

				if ((i = smtprcpt(to, m, mci, e)) != EX_OK)
a2306 4
#if _FFR_DYNAMIC_TOBUF
				(void) strlcat(tobuf, ",", tobufsize);
				(void) strlcat(tobuf, to->q_paddr, tobufsize);
#else /* _FFR_DYNAMIC_TOBUF */
a2318 1
#endif /* _FFR_DYNAMIC_TOBUF */
d2354 1
a2354 1
		if (CheckpointInterval > 0 && e->e_nsent >= CheckpointInterval)
a2427 1
	e->e_to = NULL;
a2598 1

a2609 4
#if STARTTLS
	/* shutdown TLS */
	(void) endtlsclt(mci);
#endif /* STARTTLS */
d2616 1
a2616 2
	if (mci->mci_in != NULL && mci->mci_state != MCIS_ERROR &&
	    e->e_xfp != NULL)
d2620 1
d2644 1
a2644 1
			syserr("endmailer %s: wait timeout (%ld)",
d2646 1
a2646 1
			       (long) mci->mci_mailer->m_wait);
a2958 1
	time_t now;
a2978 1
	now = curtime();
d2980 1
a2980 1
		 pintvl(now - e->e_ctime, TRUE));
d2986 1
a2986 1
			 pintvl(now - xstart, TRUE));
d3065 1
a3065 1
	p = e->e_to == NULL ? "NO-TO-LIST" : e->e_to;
d3068 1
a3068 1
		register char *q;
a3069 10
#if _FFR_DYNAMIC_TOBUF
		for (q = p + l; q > p; q--)
		{
			if (*q == ',')
				break;
		}
		if (p == q)
			break;
#else /* _FFR_DYNAMIC_TOBUF */
		q = strchr(p + l, ',');
a3071 2
#endif /* _FFR_DYNAMIC_TOBUF */

d3074 1
a3074 1
			  (int) (++q - p), p, buf);
a3076 3
#if _FFR_DYNAMIC_TOBUF
	sm_syslog(LOG_INFO, e->e_id, "to=%.*s%s", l, p, buf);
#else /* _FFR_DYNAMIC_TOBUF */
a3077 1
#endif /* _FFR_DYNAMIC_TOBUF */
d3082 1
a3082 1
	p = e->e_to == NULL ? "NO-TO-LIST" : e->e_to;
d3085 1
a3085 1
		register char *q;
a3086 10
#if _FFR_DYNAMIC_TOBUF
		for (q = p + l; q > p; q--)
		{
			if (*q == ',')
				break;
		}
		if (p == q)
			break;
#else /* _FFR_DYNAMIC_TOBUF */
		q = strchr(p + l, ',');
a3088 2
#endif /* _FFR_DYNAMIC_TOBUF */

d3091 1
a3091 1
			  (int) (++q - p), p);
a3093 3
#if _FFR_DYNAMIC_TOBUF
	sm_syslog(LOG_INFO, e->e_id, "to=%.*s", l, p);
#else /* _FFR_DYNAMIC_TOBUF */
a3094 1
#endif /* _FFR_DYNAMIC_TOBUF */
d3112 1
a3112 1
		 pintvl(now - e->e_ctime, TRUE));
d3117 1
a3117 1
			 pintvl(now - xstart, TRUE));
d3272 2
a3273 7
		{
			char *msg = "!putbody: Cannot open %s for %s from %s";

			if (errno == ENOENT)
				msg++;
			syserr(msg, df, e->e_to, e->e_from.q_paddr);
		}
a3284 1

d3385 1
a3385 1
		while (!ferror(mci->mci_out) && !dead)
d3441 1
a3441 2
						(void) putc((unsigned char) *xp,
							    TrafficLogFile);
a3448 2
					{
						dead = TRUE;
a3449 6
					}
					else
					{
						/* record progress for DATA timeout */
						DataProgress = TRUE;
					}
d3454 1
a3454 2
					if (putc((unsigned char) *xp,
						 mci->mci_out) == EOF)
d3459 3
a3461 5
					else
					{
						/* record progress for DATA timeout */
						DataProgress = TRUE;
					}
a3469 5
					else
					{
						/* record progress for DATA timeout */
						DataProgress = TRUE;
					}
d3479 2
d3499 3
a3501 5
					else
					{
						/* record progress for DATA timeout */
						DataProgress = TRUE;
					}
d3545 2
a3546 6
							(void) putc((unsigned char) c,
							    TrafficLogFile);
						if (putc((unsigned char) c,
							 mci->mci_out) == EOF)
						{
							dead = TRUE;
a3547 6
						}
						else
						{
							/* record progress for DATA timeout */
							DataProgress = TRUE;
						}
a3554 2
					{
						dead = TRUE;
d3556 3
a3558 6
					}
					else
					{
						/* record progress for DATA timeout */
						DataProgress = TRUE;
					}
a3576 5
					else
					{
						/* record progress for DATA timeout */
						DataProgress = TRUE;
					}
d3583 2
a3584 6
						(void) putc((unsigned char) c,
							    TrafficLogFile);
					if (putc((unsigned char) c,
						 mci->mci_out) == EOF)
					{
						dead = TRUE;
a3585 6
					}
					else
					{
						/* record progress for DATA timeout */
						DataProgress = TRUE;
					}
d3589 3
d3602 1
a3602 2
					(void) putc((unsigned char) *xp,
						    TrafficLogFile);
d3606 1
a3606 2
				if (putc((unsigned char) *xp, mci->mci_out) ==
				    EOF)
d3611 3
a3613 5
				else
				{
					/* record progress for DATA timeout */
					DataProgress = TRUE;
				}
d3652 1
a3652 1
	if (!dead && bitnset(M_BLANKEND, mci->mci_mailer->m_flags) &&
a3884 6
				if (RunAsUid != 0 && RealUid != RunAsUid)
				{
					/* Only root can change the uid */
					syserr("mailfile: insufficient privileges to change uid");
					exit(EX_TEMPFAIL);
				}
a3911 1
			{
a3912 9
				if (RunAsUid != 0 &&
				    (RealGid != getgid() ||
				     RealGid != getegid()))
				{
					/* Only root can change the gid */
					syserr("mailfile: insufficient privileges to change gid");
					exit(EX_TEMPFAIL);
				}
			}
d3915 2
a3919 7
			{
				/*
				**  Special case:  This means it is an
				**  alias and we should act as DefaultUser.
				**  See alias()'s comments.
				*/

a3920 4
				RealUserName = DefUser;
			}
			else if (ctladdr != NULL && ctladdr->q_uid != 0)
				RealGid = ctladdr->q_gid;
a3939 1
			{
a3941 2
				exit(EX_TEMPFAIL);
			}
a3948 1
			{
a3949 2
				exit(EX_TEMPFAIL);
			}
a3973 1
		{
a3974 2
			exit(EX_CANTCREAT);
		}
a3978 1
		{
a3979 2
			exit(EX_TEMPFAIL);
		}
a3981 1
		{
a3982 2
			exit(EX_TEMPFAIL);
		}
a4199 1
	time_t now;
a4257 1
	now = curtime();
d4297 1
a4297 1
				mci->mci_lastuse = now;
a4496 200
# if STARTTLS
static SSL_CTX	*clt_ctx = NULL;

/*
**  INITCLTTLS -- initialize client side TLS
**
**	Parameters:
**		none.
**
**	Returns:
**		succeeded?
*/

bool
initclttls()
{
	if (clt_ctx != NULL)
		return TRUE;	/* already done */
	return inittls(&clt_ctx, TLS_I_CLT, FALSE, CltCERTfile, Cltkeyfile,
		       CACERTpath, CACERTfile, DHParams);
}

/*
**  STARTTLS -- try to start secure connection (client side)
**
**	Parameters:
**		m -- the mailer.
**		mci -- the mailer connection info.
**		e -- the envelope.
**
**	Returns:
**		success?
**		(maybe this should be some other code than EX_
**		that denotes which stage failed.)
*/

static int
starttls(m, mci, e)
	MAILER *m;
	MCI *mci;
	ENVELOPE *e;
{
	int smtpresult;
	int result = 0;
	int rfd, wfd;
	SSL *clt_ssl = NULL;

	if (clt_ctx == NULL && !initclttls())
		return EX_TEMPFAIL;
	smtpmessage("STARTTLS", m, mci);

	/* get the reply */
	smtpresult = reply(m, mci, e, TimeOuts.to_datafinal, NULL, NULL);
	/* which timeout? XXX */

	/* check return code from server */
	if (smtpresult == 454)
		return EX_TEMPFAIL;
	if (smtpresult == 501)
		return EX_USAGE;
	if (smtpresult == -1)
		return smtpresult;
	if (smtpresult != 220)
		return EX_PROTOCOL;

	if (LogLevel > 13)
		sm_syslog(LOG_INFO, e->e_id, "TLS: start client");

	/* start connection */
	if ((clt_ssl = SSL_new(clt_ctx)) == NULL)
	{
		if (LogLevel > 5)
		{
			sm_syslog(LOG_ERR, e->e_id,
				  "TLS: error: client: SSL_new failed");
			if (LogLevel > 9)
				tlslogerr();
		}
		return EX_SOFTWARE;
	}

	rfd = fileno(mci->mci_in);
	wfd = fileno(mci->mci_out);

	/* SSL_clear(clt_ssl); ? */
	if (rfd < 0 || wfd < 0 ||
	    (result = SSL_set_rfd(clt_ssl, rfd)) <= 0 ||
	    (result = SSL_set_wfd(clt_ssl, wfd)) <= 0)
	{
		if (LogLevel > 5)
		{
			sm_syslog(LOG_ERR, e->e_id,
				  "TLS: error: SSL_set_xfd failed=%d", result);
			if (LogLevel > 9)
				tlslogerr();
		}
		return EX_SOFTWARE;
	}
	SSL_set_connect_state(clt_ssl);
	if ((result = SSL_connect(clt_ssl)) <= 0)
	{
		int i;

		/* what to do in this case? */
		i = SSL_get_error(clt_ssl, result);
		if (LogLevel > 5)
		{
			sm_syslog(LOG_ERR, e->e_id,
				  "TLS: error: SSL_connect failed=%d (%d)",
				  result, i);
			if (LogLevel > 9)
				tlslogerr();
		}
		SSL_free(clt_ssl);
		clt_ssl = NULL;
		return EX_SOFTWARE;
	}
	mci->mci_ssl = clt_ssl;
	result = tls_get_info(clt_ssl, e, FALSE, mci->mci_host, TRUE);

	/* switch to use SSL... */
#if SFIO
	if (sfdctls(mci->mci_in, mci->mci_out, mci->mci_ssl) == 0)
		return EX_OK;
#else /* SFIO */
# if _FFR_TLS_TOREK
	if (sfdctls(&mci->mci_in, &mci->mci_out, mci->mci_ssl) == 0)
		return EX_OK;
# endif /* _FFR_TLS_TOREK */
#endif /* SFIO */

	/* failure */
	SSL_free(clt_ssl);
	clt_ssl = NULL;
	return EX_SOFTWARE;
}

/*
**  ENDTLSCLT -- shutdown secure connection (client side)
**
**	Parameters:
**		mci -- the mailer connection info.
**
**	Returns:
**		success?
*/
int
endtlsclt(mci)
	MCI *mci;
{
	int r;

	if (!bitset(MCIF_TLSACT, mci->mci_flags))
		return EX_OK;
	r = endtls(mci->mci_ssl, "client");
	mci->mci_flags &= ~MCIF_TLSACT;
	return r;
}
/*
**  ENDTLS -- shutdown secure connection
**
**	Parameters:
**		ssl -- SSL connection information.
**		side -- srv/clt (for logging).
**
**	Returns:
**		success?
*/

int
endtls(ssl, side)
	SSL *ssl;
	char *side;
{
	if (ssl != NULL)
	{
		int r;

		if ((r = SSL_shutdown(ssl)) < 0)
		{
			if (LogLevel > 11)
				sm_syslog(LOG_WARNING, NOQID,
					  "SSL_shutdown %s failed: %d",
					  side, r);
			return EX_SOFTWARE;
		}
		else if (r == 0)
		{
			if (LogLevel > 13)
				sm_syslog(LOG_WARNING, NOQID,
					  "SSL_shutdown %s not done",
					  side);
			return EX_SOFTWARE;
		}
		SSL_free(ssl);
		ssl = NULL;
	}
	return EX_OK;
}
# endif /* STARTTLS */
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d14 4
a18 1
#include <sys/time.h>
a19 1
SM_RCSID("@@(#)$Sendmail: deliver.c,v 8.899 2001/09/08 01:21:09 gshapiro Exp $")
d25 1
a25 1
#if STARTTLS || SASL
d27 1
a27 1
#endif /* STARTTLS || SASL */
a28 1
void		markfailure __P((ENVELOPE *, ADDRESS *, MCI *, int, bool));
d32 1
d35 1
a35 2
extern MCI	*mci_new __P((SM_RPOOL_T *));
static int	coloncmp __P((const char *, const char *));
d37 2
a38 1
#if STARTTLS
d40 2
a41 5
static int	endtlsclt __P((MCI *));
#endif /* STARTTLS */
# if STARTTLS || SASL
static bool	iscltflgset __P((ENVELOPE *, int));
# endif /* STARTTLS || SASL */
d73 1
a73 1
	bool somedeliveries = false, expensive = false;
d84 1
a84 1
			sm_dprintf("sendall: discarding id %s\n", e->e_id);
d86 1
a86 3
		if (LogLevel > 9)
			logundelrcpts(e, "discarded", 9, true);
		else if (LogLevel > 4)
d88 1
a88 1
		markstats(e, NULL, true);
d117 1
a117 1
		sm_dprintf("\n===== SENDALL: mode %c, id %s, e_from ",
d119 2
a120 2
		printaddr(&e->e_from, false);
		sm_dprintf("\te_flags = ");
d122 2
a123 2
		sm_dprintf("sendqueue:\n");
		printaddr(e->e_sendqueue, true);
a137 8
		char *recip;

		if (e->e_sendqueue != NULL &&
		    e->e_sendqueue->q_paddr != NULL)
			recip = e->e_sendqueue->q_paddr;
		else
			recip = "(nobody)";

d139 3
a141 1
		queueup(e, WILL_BE_QUEUED(mode), false);
d144 4
a147 4
		syserr("554 5.4.6 Too many hops %d (%d max): from %s via %s, to %s",
		       e->e_hopcount, MaxHopCount, e->e_from.q_paddr,
		       RealHostName == NULL ? "localhost" : RealHostName,
		       recip);
a153 1
			q->q_rstatus = "554 5.4.6 Too many hops";
d172 2
a173 2
			sm_dprintf("sendall: QS_SENDER ");
			printaddr(&e->e_from, false);
d203 2
a204 2
		sm_dprintf("\nAfter first owner pass, sendq =\n");
		printaddr(e->e_sendqueue, true);
d212 2
a213 2
			sm_dprintf("owner = \"%s\", otherowners = %d\n",
				   owner, otherowners);
d221 2
a222 2
				sm_dprintf("Checking ");
				printaddr(q, false);
d227 1
a227 1
					sm_dprintf("    ... QS_IS_DEAD\n");
d232 2
a233 2
				sm_dprintf("Checking ");
				printaddr(q, false);
d241 2
a242 2
						sm_dprintf("    ... First owner = \"%s\"\n",
							   q->q_owner);
d250 2
a251 2
							sm_dprintf("    ... Same owner = \"%s\"\n",
								   owner);
d259 2
a260 2
							sm_dprintf("    ... Another owner \"%s\"\n",
								   q->q_owner);
d266 2
a267 2
					sm_dprintf("    ... Same owner = \"%s\"\n",
						   owner);
d272 1
a272 1
					sm_dprintf("    ... Null owner\n");
d279 1
a279 1
					sm_dprintf("    ... QS_IS_BADADDR\n");
d296 2
a297 1
				    strcmp(m->m_mailer, "[IPC]") == 0 &&
d299 2
a300 1
				    strcmp(m->m_argv[0], "TCP"))
d306 1
a306 1
						sm_dprintf("    ... FallBackMX\n");
d308 3
a310 3
					len = strlen(FallBackMX) + 1;
					p = sm_rpool_malloc_x(e->e_rpool, len);
					(void) sm_strlcpy(p, FallBackMX, len);
d317 1
a317 1
						sm_dprintf("    ... QS_IS_QUEUEUP\n");
d335 1
a335 1
					sm_dprintf("    ... expensive\n");
d337 1
a337 1
				expensive = true;
d345 1
a345 1
					sm_dprintf("    ... hold\n");
d347 1
a347 1
				expensive = true;
d352 2
a353 2
					sm_dprintf("    ... deliverable\n");
				somedeliveries = true;
d363 2
a364 3
			ee = (ENVELOPE *) sm_rpool_malloc_x(e->e_rpool,
							    sizeof *ee);
			STRUCTCOPY(*e, *ee);
d370 6
a375 9
				sm_dprintf("sendall: split %s into %s, owner = \"%s\", otherowners = %d\n",
					   e->e_id, ee->e_id, owner,
					   otherowners);

			ee->e_header = copyheader(e->e_header, ee->e_rpool);
			ee->e_sendqueue = copyqueue(e->e_sendqueue,
						    ee->e_rpool);
			ee->e_errorqueue = copyqueue(e->e_errorqueue,
						     ee->e_rpool);
d378 1
a378 1
			setsender(owner, ee, NULL, '\0', true);
d381 2
a382 2
				sm_dprintf("sendall(split): QS_SENDER ");
				printaddr(&ee->e_from, false);
d388 1
a388 2
			ee->e_qgrp = e->e_qgrp;
			ee->e_qdir = e->e_qdir;
d400 2
a401 2
						sm_dprintf("\t... stripping %s from original envelope\n",
							   q->q_paddr);
d410 2
a411 2
						sm_dprintf("\t... dropping %s from cloned envelope\n",
							   q->q_paddr);
d419 2
a420 2
						sm_dprintf("\t... moving %s to cloned envelope\n",
							   q->q_paddr);
d435 1
a435 1
				ee->e_xfp = sm_io_dup(e->e_xfp);
d442 3
a444 3
				sm_syslog(LOG_INFO, e->e_id,
					  "%s: clone: owner=%s",
					  ee->e_id, owner);
d450 1
a450 1
		setsender(owner, e, NULL, '\0', true);
d453 2
a454 2
			sm_dprintf("sendall(owner): QS_SENDER ");
			printaddr(&e->e_from, false);
d463 1
a463 1
	if (!somedeliveries && !WILL_BE_QUEUED(mode) &&
d466 1
a466 1
		time_t now;
d469 1
a469 1
			sm_dprintf("No deliveries: auto-queuing\n");
a470 1
		now = curtime();
d484 3
a486 2
	if ((WILL_BE_QUEUED(mode) || mode == SM_FORK ||
	     (mode != SM_VERIFY && SuperSafe == SAFE_REALLY)) &&
a488 2
		bool msync;

a495 6
#if !HASFLOCK
		msync = false;
#else /* !HASFLOCK */
		msync = mode == SM_FORK;
#endif /* !HASFLOCK */

d497 2
a498 2
			queueup(ee, WILL_BE_QUEUED(mode), msync);
		queueup(e, WILL_BE_QUEUED(mode), msync);
d500 1
d511 1
a511 1
		sm_dprintf("sendall: final mode = %c\n", mode);
d514 4
a517 4
			sm_dprintf("\n================ Final Send Queue(s) =====================\n");
			sm_dprintf("\n  *** Envelope %s, e_from=%s ***\n",
				   e->e_id, e->e_from.q_paddr);
			printaddr(e->e_sendqueue, true);
d520 3
a522 3
				sm_dprintf("\n  *** Envelope %s, e_from=%s ***\n",
					   ee->e_id, ee->e_from.q_paddr);
				printaddr(ee->e_sendqueue, true);
d524 1
a524 1
			sm_dprintf("==========================================================\n\n");
d540 1
a540 1
		dropenvelope(e, splitenv != NULL, true);
d545 1
a545 1
			dropenvelope(ee, false, true);
d551 1
a551 1
			(void) sm_io_flush(e->e_xfp, SM_TIME_DEFAULT);
d567 1
a567 1
			dropenvelope(e, splitenv != NULL, false);
d580 1
a580 1
			dropenvelope(ee, false, false);
d596 1
a596 1
		closemaps(false);
d618 1
a618 1
				(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT);
d624 1
a624 1
				(void) sm_io_close(e->e_lockfp, SM_TIME_DEFAULT);
a637 13
		/* Reset global flags */
		RestartRequest = NULL;
		RestartWorkGroup = false;
		ShutdownRequest = NULL;
		PendingSignal = 0;

		/*
		**  Initialize exception stack and default exception
		**  handler for child process.
		*/

		sm_exc_newthread(fatal_error);

d645 1
a645 1
		(void) sm_signal(SIGTERM, SIG_DFL);
a652 2
		CurrentPid = getpid();

d667 1
a667 1
			finis(true, ExitStat);
d671 1
a671 1
		QuickAbort = false;
d683 1
a683 1
		mci_flush(false, NULL);
d697 2
a698 2
			(void) dowork(ee->e_qgrp, ee->e_qdir, ee->e_id,
				      false, false, ee);
d701 3
a703 3
		(void) dowork(e->e_qgrp, e->e_qdir, e->e_id,
			      false, false, e);
		finis(true, ExitStat);
d708 1
a708 1
	dropenvelope(e, true, true);
d715 1
a715 1
		dropenvelope(ee, true, true);
d721 1
a721 1
		finis(true, ExitStat);
d733 3
a735 3
		sm_dprintf("sendenvelope(%s) e_flags=0x%lx\n",
			   e->e_id == NULL ? "[NOQUEUE]" : e->e_id,
			   e->e_flags);
d755 1
a755 5
	/*
	**  Don't attempt deliveries if we want to bounce now
	**  or if deliver-by time is exceeded.
	*/

d757 1
a757 3
	    (TimeOuts.to_q_return[e->e_timeoutclass] == NOW ||
	     (IS_DLVR_RETURN(e) && e->e_deliver_by > 0 &&
	      curtime() > e->e_ctime + e->e_deliver_by)))
d770 3
a772 40
	macdefine(&e->e_macro, A_PERM, macid("{envid}"), e->e_envid);
	macdefine(&e->e_macro, A_PERM, macid("{bodytype}"), e->e_bodytype);
	didany = false;

	if (!bitset(EF_SPLIT, e->e_flags))
	{
		ENVELOPE *oldsib;
		ENVELOPE *ee;

		/*
		**  Save old sibling and set it to NULL to avoid
		**  queueing up the same envelopes again.
		**  This requires that envelopes in that list have
		**  been take care of before (or at some other place).
		*/

		oldsib = e->e_sibling;
		e->e_sibling = NULL;
		(void) split_by_recipient(e);
		for (ee = e->e_sibling; ee != NULL; ee = ee->e_sibling)
			queueup(ee, false, true);

		/* clean up */
		for (ee = e->e_sibling; ee != NULL; ee = ee->e_sibling)
		{
			/* now unlock the job */
			closexscript(ee);
			unlockqueue(ee);

			/* this envelope is marked unused */
			if (ee->e_dfp != NULL)
			{
				(void) sm_io_close(ee->e_dfp, SM_TIME_DEFAULT);
				ee->e_dfp = NULL;
			}
			ee->e_id = NULL;
			ee->e_flags &= ~EF_HAS_DF;
		}
		e->e_sibling = oldsib;
	}
d780 2
a781 2
		(void) sm_snprintf(wbuf, sizeof wbuf, "sendall(%.*s)",
				   MAXNAME, q->q_paddr);
d802 1
d810 1
a810 1
				queueup(e, false, false);
d813 1
d815 1
a815 1
			didany = true;
a827 53

#if REQUIRES_DIR_FSYNC
/*
**  SYNC_DIR -- fsync a directory based on a filename
**
**	Parameters:
**		filename -- path of file
**		panic -- panic?
**
**	Returns:
**		none
*/

void
sync_dir(filename, panic)
	char *filename;
	bool panic;
{
	int dirfd;
	char *dirp;
	char dir[MAXPATHLEN];

	/* filesystems which require the directory be synced */
	dirp = strrchr(filename, '/');
	if (dirp != NULL)
	{
		if (sm_strlcpy(dir, filename, sizeof dir) >= sizeof dir)
			return;
		dir[dirp - filename] = '\0';
		dirp = dir;
	}
	else
		dirp = ".";
	dirfd = open(dirp, O_RDONLY, 0700);
	if (tTd(40,32))
		sm_syslog(LOG_INFO, NOQID, "sync_dir: %s: fsync(%d)",
			  dirp, dirfd);
	if (dirfd >= 0)
	{
		if (fsync(dirfd) < 0)
		{
			if (panic)
				syserr("!sync_dir: cannot fsync directory %s",
				       dirp);
			else if (LogLevel > 1)
				sm_syslog(LOG_ERR, NOQID,
					  "sync_dir: cannot fsync directory %s: %s",
					  dirp, sm_errstring(errno));
		}
		(void) close(dirfd);
	}
}
#endif /* REQUIRES_DIR_FSYNC */
d842 1
a842 1
	ENVELOPE *e, *ee;
d854 2
a855 2
	(void) sm_strlcpy(f1buf, queuename(e, type), sizeof f1buf);
	(void) sm_strlcpy(f2buf, queuename(ee, type), sizeof f2buf);
d866 1
a866 1
				       f2buf);
d872 1
a872 1
				       f1buf, f2buf);
a876 1
	SYNC_DIR(f2buf, true);
d934 1
a934 1
pid_t
a941 66

/*
**  COLONCMP -- compare host-signatures up to first ':' or EOS
**
**	This takes two strings which happen to be host-signatures and
**	compares them. If the lowest preference portions of the MX-RR's
**	match (up to ':' or EOS, whichever is first), then we have
**	match. This is used for coattail-piggybacking messages during
**	message delivery.
**	If the signatures are the same up to the first ':' the remainder of
**	the signatures are then compared with a normal strcmp(). This saves
**	re-examining the first part of the signatures.
**
**	Parameters:
**		a - first host-signature
**		b - second host-signature
**
**	Returns:
**		HS_MATCH_NO -- no "match".
**		HS_MATCH_FIRST -- "match" for the first MX preference
**			(up to the first colon (':')).
**		HS_MATCH_FULL -- match for the entire MX record.
**
**	Side Effects:
**		none.
*/

#define HS_MATCH_NO	0
#define HS_MATCH_FIRST	1
#define HS_MATCH_FULL	2

static int
coloncmp(a, b)
	register const char *a;
	register const char *b;
{
	int ret = HS_MATCH_NO;
	int braclev = 0;

	while (*a == *b++)
	{
		/* Need to account for IPv6 bracketed addresses */
		if (*a == '[')
			braclev++;
		else if (*a == '[' && braclev > 0)
			braclev--;
		else if (*a == ':' && braclev <= 0)
		{
			ret = HS_MATCH_FIRST;
			a++;
			break;
		}
		else if (*a == '\0')
			return HS_MATCH_FULL; /* a full match */
		a++;
	}
	if (ret == HS_MATCH_NO &&
	    braclev <= 0 &&
	    ((*a == '\0' && *(b - 1) == ':') ||
	     (*a == ':' && *(b - 1) == '\0')))
		return HS_MATCH_FIRST;
	if (ret == HS_MATCH_FIRST && strcmp(a, b) == 0)
		return HS_MATCH_FULL;

	return ret;
}
a950 39
**	Deliver tries to be as opportunistic as possible about piggybacking
**	messages. Some definitions to make understanding easier follow below.
**	Piggybacking occurs when an existing connection to a mail host can
**	be used to send the same message to more than one recipient at the
**	same time. So "no piggybacking" means one message for one recipient
**	per connection. "Intentional piggybacking" happens when the
**	recipients' host address (not the mail host address) is used to
**	attempt piggybacking. Recipients with the same host address
**	have the same mail host. "Coincidental piggybacking" relies on
**	piggybacking based on all the mail host addresses in the MX-RR. This
**	is "coincidental" in the fact it could not be predicted until the
**	MX Resource Records for the hosts were obtained and examined. For
**	example (preference order and equivalence is important, not values):
**		domain1 IN MX 10 mxhost-A
**			IN MX 20 mxhost-B
**		domain2 IN MX  4 mxhost-A
**			IN MX  8 mxhost-B
**	Domain1 and domain2 can piggyback the same message to mxhost-A or
**	mxhost-B (if mxhost-A cannot be reached).
**	"Coattail piggybacking" relaxes the strictness of "coincidental
**	piggybacking" in the hope that most significant (lowest value)
**	MX preference host(s) can create more piggybacking. For example
**	(again, preference order and equivalence is important, not values):
**		domain3 IN MX 100 mxhost-C
**			IN MX 100 mxhost-D
**			IN MX 200 mxhost-E
**		domain4 IN MX  50 mxhost-C
**			IN MX  50 mxhost-D
**			IN MX  80 mxhost-F
**	A message for domain3 and domain4 can piggyback to mxhost-C if mxhost-C
**	is available. Same with mxhost-D because in both RR's the preference
**	value is the same as mxhost-C, respectively.
**	So deliver attempts coattail piggybacking when possible. If the
**	first MX preference level hosts cannot be used then the piggybacking
**	reverts to coincidental piggybacking. Using the above example you
**	cannot deliver to mxhost-F for domain3 regardless of preference value.
**	("Coattail" from "riding on the coattails of your predecessor" meaning
**	gaining benefit from a predecessor effort with no or little addition
**	effort. The predecessor here being the preceding MX RR).
a982 1
# if HASSETUSERCONTEXT
a983 1
# endif /* HASSETUSERCONTEXT */
d985 2
a986 2
	register ADDRESS *SM_NONVOLATILE to = firstto;
	volatile bool clever = false;	/* running user smtp to this mailer */
d989 3
a991 3
	SM_NONVOLATILE int lmtp_rcode = EX_OK;
	SM_NONVOLATILE int nummxhosts = 0; /* number of MX hosts available */
	SM_NONVOLATILE int hostnum = 0;	/* current MX host index */
d993 1
a993 1
	volatile pid_t pid = -1;
d995 1
a995 2
	SM_NONVOLATILE unsigned short port = 0;
	SM_NONVOLATILE time_t enough = 0;
d997 1
a997 1
	char *SM_NONVOLATILE mux_path = NULL;	/* path to UNIX domain socket */
d1002 1
a1002 1
	SM_NONVOLATILE bool goodmxfound = false; /* at least one MX was OK */
d1004 1
a1006 1
	int ret;
d1009 3
a1011 1
	char *rpath;	/* translated return path */
d1017 1
d1029 1
d1031 1
d1035 1
a1035 1
		sm_dprintf("\n--deliver, id=%s, mailer=%s, host=`%s', first user=`%s'\n",
d1038 1
a1038 1
		printopenfds(false);
d1041 1
a1041 1
	**  Clear {client_*} macros if this is a bounce message to
d1047 3
a1049 4
		macdefine(&e->e_macro, A_PERM, macid("{client_name}"), "");
		macdefine(&e->e_macro, A_PERM, macid("{client_addr}"), "");
		macdefine(&e->e_macro, A_PERM, macid("{client_port}"), "");
		macdefine(&e->e_macro, A_PERM, macid("{client_resolve}"), "");
a1051 4
	SM_TRY
	{
	ADDRESS *skip_back = NULL;

d1069 2
a1070 2
	rpath = remotename(p, m, RF_SENDERADDR|RF_CANONICAL, &rcode, e);
	if (strlen(rpath) > MAXSHORTSTR)
d1072 2
a1073 2
		rpath = shortenstring(rpath, MAXSHORTSTR);
		syserr("remotename: huge return %s", rpath);
d1075 3
a1077 3
	rpath = sm_rpool_strdup_x(e->e_rpool, rpath);
	macdefine(&e->e_macro, A_PERM, 'g', rpath);
	macdefine(&e->e_macro, A_PERM, 'h', host);
d1091 1
a1091 1
		*pvp++ = rpath;
d1118 1
a1118 1
		*pvp++ = sm_rpool_strdup_x(e->e_rpool, buf);
d1123 1
a1123 2
			rcode = -1;
			goto cleanup;
d1135 3
a1137 2
		/* running LMTP or SMTP */
		clever = true;
d1139 5
a1143 8
	}
	else if (bitnset(M_LMTP, m->m_flags))
	{
		/* not running LMTP */
		sm_syslog(LOG_ERR, NULL,
			  "Warning: mailer %s: LMTP flag (F=z) turned off",
			  m->m_name);
		clrbitn(M_LMTP, m->m_flags);
d1153 1
d1157 5
d1163 1
a1163 5
	if (firstto->q_signature == NULL)
		firstto->q_signature = hostsignature(firstto->q_mailer,
						     firstto->q_host);
	firstsig = firstto->q_signature;

d1167 1
d1170 4
d1176 4
a1179 1
		if (!QS_IS_OK(to->q_state)) /* already sent; look at next */
d1182 4
a1185 29
		/*
		**  Must be same mailer to keep grouping rcpts.
		**  If mailers don't match: continue; sendqueue is not
		**  sorted by mailers, so don't break;
		*/

		if (to->q_mailer != firstto->q_mailer)
			continue;

		if (to->q_signature == NULL) /* for safety */
			to->q_signature = hostsignature(to->q_mailer,
							to->q_host);

		/*
		**  This is for coincidental and tailcoat piggybacking messages
		**  to the same mail host. While the signatures are identical
		**  (that's the MX-RR's are identical) we can do coincidental
		**  piggybacking. We try hard for coattail piggybacking
		**  with the same mail host when the next recipient has the
		**  same host at lowest preference. It may be that this
		**  won't work out, so 'skip_back' is maintained if a backup
		**  to coincidental piggybacking or full signature must happen.
		*/

		ret = firstto == to ? HS_MATCH_FULL :
				      coloncmp(to->q_signature, firstsig);
		if (ret == HS_MATCH_FULL)
			skip_back = to;
		else if (ret == HS_MATCH_NO)
a1187 8
		if (!clever)
		{
			/* avoid overflowing tobuf */
			strsize += strlen(to->q_paddr) + 1;
			if (strsize > TOBUFSIZE)
				break;
		}

d1190 4
d1197 2
a1198 2
			sm_dprintf("\nsend to ");
			printaddr(to, false);
a1202 1
# if HASSETUSERCONTEXT
a1203 3
# else /* HASSETUSERCONTEXT */
			ctladdr = getctladdr(to);
# endif /* HASSETUSERCONTEXT */
d1207 2
a1208 2
			sm_dprintf("ctladdr=");
			printaddr(ctladdr, false);
a1227 1

d1232 1
a1232 1
			markfailure(e, to, NULL, EX_UNAVAILABLE, false);
d1234 1
a1234 1
				     NULL, ctladdr, xstart, e, to);
d1237 3
a1239 2
		SM_SET_H_ERRNO(0);
		ovr = true;
d1241 1
d1244 1
a1244 1
				e, true, true, 3, NULL, e->e_id);
d1251 1
a1251 1
				ovr = false;
d1258 1
a1258 1
				     NULL, ctladdr, xstart, e, to);
d1265 2
a1266 2
				sm_dprintf("deliver: discarding recipient ");
				printaddr(to, false);
d1321 1
a1321 1
			macdefine(&e->e_macro, A_PERM, 'u', user);
d1325 1
a1325 1
			macdefine(&e->e_macro, A_PERM, 'z', p);
d1336 2
a1337 2
				     ctladdr, xstart, e, to);
			markfailure(e, to, NULL, rcode, true);
d1347 2
a1348 4
					(void) sm_io_fprintf(e->e_xfp,
							     SM_TIME_DEFAULT,
							     "%s... Successfully delivered\n",
							     to->q_paddr);
d1352 1
a1352 1
			markstats(e, to, false);
d1364 2
d1367 5
d1373 1
a1373 1
		macdefine(&e->e_macro, A_PERM, 'u', user);  /* to user */
d1377 1
a1377 1
		macdefine(&e->e_macro, A_PERM, 'z', p);  /* user's home */
d1386 2
a1387 2
				(void) sm_strlcat(notify, "SUCCESS,",
						  sizeof notify);
d1389 2
a1390 2
				(void) sm_strlcat(notify, "FAILURE,",
						  sizeof notify);
d1392 1
a1392 2
				(void) sm_strlcat(notify, "DELAY,",
						  sizeof notify);
d1396 1
a1396 2
				(void) sm_strlcat(notify, "NEVER",
						  sizeof notify);
d1400 1
a1400 2
			macdefine(&e->e_macro, A_TEMP,
				macid("{dsn_notify}"), notify);
d1403 1
a1403 2
			macdefine(&e->e_macro, A_PERM,
				macid("{dsn_notify}"), NULL);
d1412 1
a1412 1
			*pvp++ = sm_rpool_strdup_x(e->e_rpool, buf);
d1422 1
d1424 3
d1428 3
a1430 2
		rcode = 0;
		goto cleanup;
d1434 1
a1434 14
	strsize = 1;
	for (to = tochain; to != NULL; to = to->q_tchain)
		strsize += strlen(to->q_paddr) + 1;
	if (strsize < TOBUFSIZE)
		strsize = TOBUFSIZE;
	if (strsize > tobufsize)
	{
		SM_FREE_CLR(tobuf);
		tobuf = sm_pmalloc_x(strsize);
		tobufsize = strsize;
	}
	p = tobuf;
	*p = '\0';
	for (to = tochain; to != NULL; to = to->q_tchain)
d1436 22
a1457 3
		(void) sm_strlcpyn(p, tobufsize - (p - tobuf), 2,
				   ",", to->q_paddr);
		p += strlen(p);
d1459 1
d1466 1
a1466 1
	if (!clever)
d1468 5
a1472 8
		while (*++mvp != NULL)
		{
			expand(*mvp, buf, sizeof buf, e);
			*pvp++ = sm_rpool_strdup_x(e->e_rpool, buf);
			if (pvp >= &pv[MAXPV])
				syserr("554 5.3.0 deliver: pv overflow after $u for %s",
				       pv[0]);
		}
d1496 1
a1496 1
		sm_dprintf("openmailer:");
d1500 4
a1503 1
	SM_SET_H_ERRNO(0);
d1524 2
a1525 3
		(void) sm_snprintf(wbuf, sizeof wbuf, "%s... openmailer(%s)",
				   shortenstring(e->e_to, MAXSHORTSTR),
				   m->m_name);
d1540 1
a1540 1
			  "554 Cannot send 8-bit data to 7-bit destination");
d1551 4
a1554 38
#if _FFR_CACHE_LPC
		if (clever)
		{
			/* flush any expired connections */
			(void) mci_scan(NULL);

			/* try to get a cached connection or just a slot */
			mci = mci_get(m->m_name, m);
			if (mci->mci_host == NULL)
				mci->mci_host = m->m_name;
			CurHostName = mci->mci_host;
			if (mci->mci_state != MCIS_CLOSED)
			{
				message("Using cached SMTP/LPC connection for %s...",
					m->m_name);
				mci->mci_deliveries++;
				goto do_transfer;
			}
		}
		else
		{
			mci = mci_new(e->e_rpool);
		}
		mci->mci_in = smioin;
		mci->mci_out = smioout;
		mci->mci_mailer = m;
		mci->mci_host = m->m_name;
		if (clever)
		{
			mci->mci_state = MCIS_OPENING;
			mci_cache(mci);
		}
		else
			mci->mci_state = MCIS_OPEN;
#else /* _FFR_CACHE_LPC */
		mci = mci_new(e->e_rpool);
		mci->mci_in = smioin;
		mci->mci_out = smioout;
a1556 1
#endif /* _FFR_CACHE_LPC */
d1558 2
a1559 1
	else if (strcmp(m->m_mailer, "[IPC]") == 0)
d1561 1
d1603 1
a1603 1
			port = htons((unsigned short) atoi(pv[2]));
a1619 2
		if (TimeOuts.to_aconnect > 0)
			enough = curtime() + TimeOuts.to_aconnect;
a1644 18
			if (hostnum == 1 && skip_back != NULL)
			{
				/*
				**  Coattail piggybacking is no longer an
				**  option with the mail host next to be tried
				**  no longer the lowest MX preference
				**  (hostnum == 1 meaning we're on the second
				**  preference). We do not try to coattail
				**  piggyback more than the first MX preference.
				**  Revert 'tochain' to last location for
				**  coincidental piggybacking. This works this
				**  easily because the q_tchain kept getting
				**  added to the top of the linked list.
				*/

				tochain = skip_back;
			}

d1653 2
a1654 2
			(void) sm_strlcpy(hostbuf, mxhosts[hostnum],
					  sizeof hostbuf);
a1663 2
				char *type;

d1666 2
a1667 2
					sm_dprintf("openmailer: ");
					mci_dump(mci, false);
d1670 3
a1672 8
				if (bitnset(M_LMTP, m->m_flags))
					type = "L";
				else if (bitset(MCIF_ESMTP, mci->mci_flags))
					type = "ES";
				else
					type = "S";
				message("Using cached %sMTP connection to %s via %s...",
					type, hostbuf, m->m_name);
d1680 1
a1680 1
					goodmxfound = true;
d1687 1
a1687 1
				goodmxfound = true;
d1692 1
a1692 1
			sm_setproctitle(true, e, "%s %s: %s",
d1700 1
a1700 1
				i = makeconnection_ds((char *) mux_path, mci);
d1712 1
a1712 2
				i = makeconnection(hostbuf, port, mci, e,
						   enough);
a1713 1
			mci->mci_errno = errno;
d1717 1
a1720 29

			/*
			**  Have we tried long enough to get a connection?
			**	If yes, skip to the fallback MX hosts
			**	(if existent).
			*/

			if (enough > 0 && mci->mci_lastuse >= enough)
			{
				int h;
# if NAMED_BIND
				extern int NumFallBackMXHosts;
# else /* NAMED_BIND */
				const int NumFallBackMXHosts = 0;
# endif /* NAMED_BIND */

				if (hostnum < nummxhosts && LogLevel > 9)
					sm_syslog(LOG_INFO, e->e_id,
						  "Timeout.to_aconnect occurred before exhausting all addresses");

				/* turn off timeout if fallback available */
				if (NumFallBackMXHosts > 0)
					enough = 0;

				/* skip to a fallback MX host */
				h = nummxhosts - NumFallBackMXHosts;
				if (hostnum < h)
					hostnum = h;
			}
d1723 1
a1723 1
				goodmxfound = true;
d1727 2
a1728 5
					(void) sm_io_fprintf(TrafficLogFile,
							     SM_TIME_DEFAULT,
							     "%05d === CONNECT %s\n",
							     (int) CurrentPid,
							     hostbuf);
d1734 2
a1735 2
					sm_dprintf("openmailer: makeconnection => stat=%d, errno=%d\n",
						   i, errno);
d1737 1
a1737 1
					goodmxfound = true;
d1753 7
d1767 1
d1783 1
d1794 1
a1794 2
			(void) sm_io_fprintf(TrafficLogFile, SM_TIME_DEFAULT,
					     "%05d === EXEC", (int) CurrentPid);
d1796 2
a1797 5
				(void) sm_io_fprintf(TrafficLogFile,
						     SM_TIME_DEFAULT, " %s",
						     *av);
			(void) sm_io_fprintf(TrafficLogFile, SM_TIME_DEFAULT,
					     "\n");
d1808 1
a1808 1
			       shortenstring(e->e_to, MAXSHORTSTR), m->m_name);
d1810 1
a1810 1
				sm_dprintf("openmailer: NULL\n");
d1820 3
a1822 3
			       shortenstring(e->e_to, MAXSHORTSTR), m->m_name,
			       mpvect[0], mpvect[1]);
			printopenfds(true);
d1824 1
a1824 1
				sm_dprintf("openmailer: NULL\n");
d1834 2
a1835 4
		     (mpvect[0] == sm_io_getinfo(e->e_lockfp, SM_IO_WHAT_FD,
						 NULL) ||
		      mpvect[1] == sm_io_getinfo(e->e_lockfp, SM_IO_WHAT_FD,
						 NULL))))
d1839 2
a1840 2
				       shortenstring(e->e_to, MAXSHORTSTR),
				       m->m_name, mpvect[0], mpvect[1]);
d1843 3
a1845 4
				       shortenstring(e->e_to, MAXSHORTSTR),
				       m->m_name, mpvect[0], mpvect[1],
				       sm_io_getinfo(e->e_lockfp,
						     SM_IO_WHAT_FD, NULL));
d1853 2
a1854 2
			       shortenstring(e->e_to, MAXSHORTSTR),
			       m->m_name);
d1858 1
a1858 1
				sm_dprintf("openmailer: NULL\n");
d1875 4
a1878 4
		if (e->e_xfp != NULL)	/* for debugging */
			(void) sm_io_flush(e->e_xfp, SM_TIME_DEFAULT);
		(void) sm_io_flush(smioout, SM_TIME_DEFAULT);
		(void) sm_signal(SIGCHLD, SIG_DFL);
d1888 1
a1888 1
			       shortenstring(e->e_to, MAXSHORTSTR), m->m_name);
d1894 1
a1894 1
				sm_dprintf("openmailer: NULL\n");
a1901 1
			int sff;
a1904 1
			char *user = NULL;
a1907 10
			/* clear the events to turn off SIGALRMs */
			sm_clear_events();

			/* Reset global flags */
			RestartRequest = NULL;
			RestartWorkGroup = false;
			ShutdownRequest = NULL;
			PendingSignal = 0;
			CurrentPid = getpid();

d1909 1
a1909 3
				(void) close(sm_io_getinfo(e->e_lockfp,
							   SM_IO_WHAT_FD,
							   NULL));
d1912 3
a1914 8
			(void) sm_signal(SIGALRM, sm_signal_noop);
			(void) sm_signal(SIGCHLD, SIG_DFL);
			(void) sm_signal(SIGHUP, SIG_IGN);
			(void) sm_signal(SIGINT, SIG_IGN);
			(void) sm_signal(SIGTERM, SIG_DFL);
# ifdef SIGUSR1
			(void) sm_signal(SIGUSR1, sm_signal_noop);
# endif /* SIGUSR1 */
d1934 2
a1935 2
							      pwd, pwd->pw_uid,
							      LOGIN_SETRESOURCES|LOGIN_SETPRIORITY);
d1952 6
a1957 7
					user = ctladdr->q_ruser;
					if (user == NULL)
						user = ctladdr->q_user;

					if (initgroups(user,
						       ctladdr->q_gid) == -1
					    && suidwarn)
d1960 1
a1960 1
							user, ctladdr->q_gid);
d1969 1
a1969 2
					if (setgroups(1, gidset) == -1
					    && suidwarn)
d1981 1
a1981 3
					user = DefUser;
					if (initgroups(DefUser, DefGid) == -1 &&
					    suidwarn)
d1984 1
a1984 1
						       DefUser, DefGid);
d1993 1
a1993 2
					if (setgroups(1, gidset) == -1
					    && suidwarn)
d2029 2
a2030 2
					sm_dprintf("openmailer: chroot %s\n",
						   buf);
d2034 1
a2034 1
						buf);
a2045 1
			sm_mbdb_terminate();
a2046 1
			{
a2047 25

				/*
				**  Undo the effects of the uid change in main
				**  for signal handling.  The real uid may
				**  be used by mailer in adding a "From "
				**  line.
				*/

				if (RealUid != 0 && RealUid != getuid())
				{
# if MAILER_SETUID_METHOD == USE_SETEUID
#  if HASSETREUID
					if (setreuid(RealUid, geteuid()) < 0)
					{
						syserr("openmailer: setreuid(%d, %d) failed",
						       (int) RealUid, (int) geteuid());
						exit(EX_OSERR);
					}
#  endif /* HASSETREUID */
# endif /* MAILER_SETUID_METHOD == USE_SETEUID */
# if MAILER_SETUID_METHOD == USE_SETREUID
					new_ruid = RealUid;
# endif /* MAILER_SETUID_METHOD == USE_SETREUID */
				}
			}
d2070 1
a2070 1
					       (long) new_euid);
d2078 1
a2078 1
					       (long) new_ruid, (long) new_euid);
d2086 1
a2086 1
					       (long) new_euid);
d2097 1
a2097 1
					       (long) new_ruid);
d2103 3
a2105 3
				sm_dprintf("openmailer: running as r/euid=%d/%d, r/egid=%d/%d\n",
					   (int) getuid(), (int) geteuid(),
					   (int) getgid(), (int) getegid());
d2121 2
a2122 2
						sm_dprintf("openmailer: trydir %s\n",
							   buf);
a2127 17
			/* Check safety of program to be run */
			sff = SFF_ROOTOK|SFF_EXECOK;
			if (!bitnset(DBS_RUNWRITABLEPROGRAM,
				     DontBlameSendmail))
				sff |= SFF_NOGWFILES|SFF_NOWWFILES;
			if (bitnset(DBS_RUNPROGRAMINUNSAFEDIRPATH,
				    DontBlameSendmail))
				sff |= SFF_NOPATHCHECK;
			else
				sff |= SFF_SAFEDIRPATH;
			ret = safefile(m->m_mailer, getuid(), getgid(),
				       user, sff, 0, NULL);
			if (ret != 0)
				sm_syslog(LOG_INFO, e->e_id,
					  "Warning: program %s unsafe: %s",
					  m->m_mailer, sm_errstring(ret));

d2142 2
a2143 2
				       shortenstring(e->e_to, MAXSHORTSTR),
				       m->m_name);
d2152 2
a2153 2
				       shortenstring(e->e_to, MAXSHORTSTR),
				       m->m_name, mpvect[0]);
d2188 2
a2189 19
			if (clever)
			{
				/*
				**  Allocate from general heap, not
				**  envelope rpool, because this mci
				**  is going to be cached.
				*/

				mci = mci_new(NULL);
			}
			else
			{
				/*
				**  Prevent a storage leak by allocating
				**  this from the envelope rpool.
				*/

				mci = mci_new(e->e_rpool);
			}
d2203 1
a2203 3
		mci->mci_out = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT,
					  (void *) mpvect[1], SM_IO_WRONLY,
					  NULL);
d2207 1
a2207 1
			       mpvect[1]);
d2216 1
a2216 3
		mci->mci_in = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT,
					 (void *) rpvect[0], SM_IO_RDONLY,
					 NULL);
d2222 1
a2222 1
			(void) sm_io_close(mci->mci_out, SM_TIME_DEFAULT);
d2227 4
d2240 1
d2243 1
a2243 7
# if STARTTLS || SASL
		int dotpos;
		char *srvname;
		extern SOCKADDR CurHostAddr;
# endif /* STARTTLS || SASL */

# if SASL
d2245 1
a2245 1
# endif /* SASL */
a2252 30
# if STARTTLS || SASL
		/* don't use CurHostName, it is changed in many places */
		if (mci->mci_host != NULL)
		{
			srvname = mci->mci_host;
			dotpos = strlen(srvname) - 1;
			if (dotpos >= 0)
			{
				if (srvname[dotpos] == '.')
					srvname[dotpos] = '\0';
				else
					dotpos = -1;
			}
		}
		else
		{
			srvname = "";
			dotpos = -1;
		}
		macdefine(&mci->mci_macro, A_TEMP, macid("{server_name}"),
			  srvname);

		/* CurHostAddr is set by makeconnection() and mci_get() */
		if (CurHostAddr.sa.sa_family != 0)
			macdefine(&mci->mci_macro, A_TEMP,
				  macid("{server_addr}"),
				  anynet_ntoa(&CurHostAddr));
		else
			macdefine(&mci->mci_macro, A_PERM,
				  macid("{server_addr}"), NULL);
d2254 3
a2256 3
		/* undo change of srvname (mci->mci_host) */
		if (dotpos >= 0)
			srvname[dotpos] = '.';
a2257 5
reconnect:	/* after switching to an encrypted connection */
# endif /* STARTTLS || SASL */

		/* set the current connection information */
		e->e_mci = mci;
a2263 29
		if (IS_DLVR_RETURN(e))
		{
			/*
			**  Check whether other side can deliver e-mail
			**  fast enough
			*/

			if (!bitset(MCIF_DLVR_BY, mci->mci_flags))
			{
				e->e_status = "5.4.7";
				usrerrenh(e->e_status,
					  "554 Server does not support Deliver By");
				rcode = EX_UNAVAILABLE;
				goto give_up;
			}
			if (e->e_deliver_by > 0 &&
			    e->e_deliver_by - (curtime() - e->e_ctime) <
			    mci->mci_min_by)
			{
				e->e_status = "5.4.7";
				usrerrenh(e->e_status,
					  "554 Message can't be delivered in time; %ld < %ld",
					  e->e_deliver_by - (curtime() - e->e_ctime),
					  mci->mci_min_by);
				rcode = EX_UNAVAILABLE;
				goto give_up;
			}
		}

d2270 1
d2275 4
d2282 16
a2297 2
			if (usetls)
				usetls = !iscltflgset(e, D_NOTLS);
d2299 10
d2311 3
a2313 1
				host = macvalue(macid("{server_name}"), e);
d2315 4
a2318 4
				QuickAbort = false;
				SuprErrs = true;
				if (rscheck("try_tls", host, NULL, e, true,
					    false, 7, host, NOQID) != EX_OK
d2320 1
a2320 1
					usetls = false;
d2323 1
d2326 3
a2345 1

d2367 2
a2368 2
					macdefine(&e->e_macro, A_PERM,
						  macid("{verify}"), s);
d2371 6
d2378 1
a2378 2
				macdefine(&e->e_macro, A_PERM,
					  macid("{verify}"), "NONE");
d2380 2
a2381 2
			QuickAbort = false;
			SuprErrs = true;
a2390 1

d2392 2
a2393 3
				    macvalue(macid("{verify}"), e),
				    NULL, e, true, true, 5, host,
				    NOQID) != EX_OK ||
d2403 1
a2403 2
					p = sm_rpool_strdup_x(e->e_rpool,
							      MsgBuf);
d2408 2
a2409 2
					(void) sm_strlcpy(enhsc, "4.7.0",
							  sizeof enhsc);
d2420 1
a2420 2
						(void) sm_io_close(mci->mci_in,
								   SM_TIME_DEFAULT);
d2438 1
a2438 1
				mci_setstat(mci, rcode, enhsc, p);
d2444 1
a2444 3

				(void) sm_strlcpy(SmtpError, p,
						  sizeof SmtpError);
d2456 6
d2467 4
a2470 1
		    !DONE_AUTH(mci->mci_flags) && !iscltflgset(e, D_NOAUTH))
d2472 5
a2476 2
			/* Should we require some minimum authentication? */
			if ((ret = smtpauth(m, mci, e)) == EX_OK)
d2478 1
d2480 1
a2480 1
				sasl_ssf_t *ssf = NULL;
d2482 1
a2482 1
				/* Get security strength (features) */
a2484 2

				/* XXX authid? */
d2487 1
a2487 1
						  "AUTH=client, relay=%.100s, mech=%.16s, bits=%d",
d2489 3
a2491 3
						  macvalue(macid("{auth_type}"), e),
						  result == SASL_OK ? *ssf : 0);

d2493 1
a2493 1
				**  Only switch to encrypted connection
a2495 1

d2499 7
a2505 3
					**  Convert I/O layer to use SASL.
					**  If the call fails, the connection
					**  is aborted.
d2507 1
a2507 3

					if (sfdcsasl(&mci->mci_in,
						     &mci->mci_out,
d2510 1
d2512 1
a2512 2
						mci->mci_flags |= MCIF_AUTHACT|
								  MCIF_ONLY_EHLO;
d2515 1
a2515 1
					syserr("AUTH TLS switch failed in client");
d2518 1
a2521 22
			else if (ret == EX_TEMPFAIL)
			{
				if (LogLevel > 8)
					sm_syslog(LOG_ERR, NOQID,
						  "AUTH=client, relay=%.100s, temporary failure, connection abort",
						  mci->mci_host);
				smtpquit(m, mci, e);

				/* avoid bogus error msg */
				mci->mci_errno = 0;
				rcode = EX_TEMPFAIL;
				mci_setstat(mci, rcode, "4.7.1", p);

				/*
				**  hack to get the error message into
				**  the envelope (done in giveresponse())
				*/

				(void) sm_strlcpy(SmtpError,
						  "Temporary AUTH failure",
						  sizeof SmtpError);
			}
d2526 1
d2541 2
a2542 2
	     (sm_strcasecmp(p, "quoted-printable") == 0 ||
	      sm_strcasecmp(p, "base64") == 0) &&
d2547 1
a2547 1
		if (sm_strncasecmp(p, "text/plain", 10) == 0 &&
d2555 2
a2556 2
		sm_dprintf("openmailer: ");
		mci_dump(mci, false);
d2564 3
a2566 1
		SM_SET_H_ERRNO(mci->mci_herrno);
d2571 3
a2573 3
			       (unsigned long) mci, rcode, errno,
			       mci->mci_state, firstsig);
			mci_dump_all(true);
d2576 1
d2582 1
a2595 11
		if (rcode == EX_TEMPFAIL && SmtpError[0] == '\0')
		{
			/*
			**  Need an e_message for mailq display.
			**  We set SmtpError as
			*/

			(void) sm_snprintf(SmtpError, sizeof SmtpError,
					   "%s mailer (%s) exited with EX_TEMPFAIL",
					   m->m_name, m->m_mailer);
		}
d2598 1
a2603 1
		/* XXX this isn't pipelined... */
d2607 1
a2608 3
# if PIPELINING
			ADDRESS *volatile pchain;
# endif /* PIPELINING */
a2611 6
			mci->mci_retryrcpt = false;
			mci->mci_tolist = tobuf;
# if PIPELINING
			pchain = NULL;
			mci->mci_nextaddr = NULL;
# endif /* PIPELINING */
d2615 6
a2620 1
				if (!QS_IS_UNMARKED(to->q_state))
d2622 2
a2624 3
				/* mark recipient state as "ok so far" */
				to->q_state = QS_OK;
				e->e_to = to->q_paddr;
d2626 1
d2628 1
a2628 2
					    true, true, 3, mci->mci_host,
					    e->e_id);
d2633 3
a2635 8
					markfailure(e, to, mci, i, false);
					giveresponse(i, to->q_status,  m, mci,
						     ctladdr, xstart, e, to);
					if (i == EX_TEMPFAIL)
					{
						mci->mci_retryrcpt = true;
						to->q_state = QS_RETRY;
					}
d2638 1
d2641 1
a2641 3
				i = smtprcpt(to, m, mci, e, ctladdr, xstart);
# if PIPELINING
				if (bitset(MCIF_PIPELINED, mci->mci_flags))
d2643 3
a2645 15
					/*
					**  Add new element to list of
					**  recipients for pipelining.
					*/

					to->q_pchain = NULL;
					if (mci->mci_nextaddr == NULL)
						mci->mci_nextaddr = to;
					if (pchain == NULL)
						pchain = to;
					else
					{
						pchain->q_pchain = to;
						pchain = pchain->q_pchain;
					}
d2647 1
a2647 2
# endif /* PIPELINING */
				if (i != EX_OK)
d2649 4
a2652 5
					markfailure(e, to, mci, i, false);
					giveresponse(i, to->q_status,  m, mci,
						     ctladdr, xstart, e, to);
					if (i == EX_TEMPFAIL)
						to->q_state = QS_RETRY;
d2656 2
a2657 6
			/* No recipients in list and no missing responses? */
			if (tobuf[0] == '\0'
# if PIPELINING
			    && mci->mci_nextaddr == NULL
# endif /* PIPELINING */
			   )
d2667 1
a2667 1
				rcode = smtpdata(m, mci, e, ctladdr, xstart);
d2670 1
d2676 7
d2684 1
d2701 1
d2706 1
a2706 2
		anyok = false;
		strsize = 0;
d2709 1
d2718 1
d2726 18
a2743 5
				strsize += sm_strlcat2(tobuf + strsize, ",",
						to->q_paddr,
						tobufsize - strsize);
				SM_ASSERT(strsize < tobufsize);
				anyok = true;
d2748 1
a2748 1
				markfailure(e, to, mci, rcode, true);
d2750 1
a2750 1
					     ctladdr, xstart, e, to);
d2756 1
d2763 1
a2763 1
				markfailure(e, to, mci, rcode, true);
d2773 1
d2780 1
a2780 1
			queueup(e, false, false);
d2783 1
d2790 2
a2791 3
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
					     "%s... Successfully delivered\n",
					     to->q_paddr);
d2798 2
a2799 30
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
					     "%s... relayed; expect no further notifications\n",
					     to->q_paddr);
		}
		else if (IS_DLVR_NOTIFY(e) &&
			 !bitset(MCIF_DLVR_BY, mci->mci_flags) &&
			 bitset(QPRIMARY, to->q_flags) &&
			 (!bitset(QHASNOTIFY, to->q_flags) ||
			  bitset(QPINGONSUCCESS, to->q_flags) ||
			  bitset(QPINGONFAILURE, to->q_flags) ||
			  bitset(QPINGONDELAY, to->q_flags)))
		{
			/* RFC 2852, 4.1.4.2: no NOTIFY, or not NEVER */
			to->q_flags |= QBYNRELAY;
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
					     "%s... Deliver-by notify: relayed\n",
					     to->q_paddr);
		}
		else if (IS_DLVR_TRACE(e) &&
			 (!bitset(QHASNOTIFY, to->q_flags) ||
			  bitset(QPINGONSUCCESS, to->q_flags) ||
			  bitset(QPINGONFAILURE, to->q_flags) ||
			  bitset(QPINGONDELAY, to->q_flags)) &&
			 bitset(QPRIMARY, to->q_flags))
		{
			/* RFC 2852, 4.1.4: no NOTIFY, or not NEVER */
			to->q_flags |= QBYTRACE;
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
					     "%s... Deliver-By trace: relayed\n",
					     to->q_paddr);
d2803 1
d2815 1
a2815 4
		if (mci != NULL &&
		    (mci->mci_state == MCIS_MAIL ||
		     mci->mci_state == MCIS_RCPT ||
		     mci->mci_state == MCIS_DATA))
d2818 1
d2821 1
a2821 16
	{
		giveresponse(rcode, NULL, m, mci, ctladdr, xstart, e, tochain);
		if (tochain->q_message != NULL &&
		    !bitnset(M_LMTP, m->m_flags) && rcode != EX_OK)
		{
			for (to = tochain->q_tchain; to != NULL;
			     to = to->q_tchain)
			{
				/* see if address already marked */
				if (QS_IS_QUEUEUP(to->q_state) &&
				    to->q_message == NULL)
					to->q_message = sm_rpool_strdup_x(e->e_rpool,
							tochain->q_message);
			}
		}
	}
d2823 1
a2823 1
		markstats(e, tochain, false);
d2826 1
a2826 7
	/* Some recipients were tempfailed, try them on the next host */
	if (mci != NULL && mci->mci_retryrcpt && nummxhosts > hostnum)
	{
		/* try next MX site */
		goto tryhost;
	}

d2831 5
d2837 1
a2837 3
cleanup: ;
	}
	SM_FINALLY
a2838 4
		/*
		**  Restore state and return.
		*/
#if XDEBUG
d2842 4
a2845 6
		(void) sm_snprintf(wbuf, sizeof wbuf,
				   "%s... end of deliver(%s)",
				   e->e_to == NULL ? "NO-TO-LIST"
						   : shortenstring(e->e_to,
								   MAXSHORTSTR),
				  m->m_name);
d2847 1
d2850 3
a2852 12
		errno = 0;

		/*
		**  It was originally necessary to set macro 'g' to NULL
		**  because it previously pointed to an auto buffer.
		**  We don't do this any more, so this may be unnecessary.
		*/

		macdefine(&e->e_macro, A_PERM, 'g', (char *) NULL);
		e->e_to = NULL;
	}
	SM_END_TRY
d2875 1
a2875 1
void
d2905 1
a2905 1
		status = sm_rpool_strdup_x(e->e_rpool, mci->mci_status);
d2907 1
a2907 2
			rstatus = sm_rpool_strdup_x(e->e_rpool,
						    mci->mci_rstatus);
d2970 1
a2970 1
	    sm_strcasecmp(q->q_mailer->m_diagtype, "X-UNIX") == 0)
d2974 2
a2975 2
		(void) sm_snprintf(buf, sizeof buf, "%d", rcode);
		q->q_rstatus = sm_rpool_strdup_x(e->e_rpool, buf);
d2981 1
a2981 1
		q->q_statmta = sm_rpool_strdup_x(e->e_rpool, CurHostName);
d2992 1
a2992 1
**		mci -- the mailer connection info.
a3008 6
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

d3022 1
a3022 1
	SM_EVENT *ev = NULL;
a3026 13
	/* close output to mailer */
	if (mci->mci_out != NULL)
		(void) sm_io_close(mci->mci_out, SM_TIME_DEFAULT);

	/* copy any remaining input to transcript */
	if (mci->mci_in != NULL && mci->mci_state != MCIS_ERROR &&
	    e->e_xfp != NULL)
	{
		while (sfgets(buf, sizeof buf, mci->mci_in,
			      TimeOuts.to_quit, "Draining Input") != NULL)
			(void) sm_io_fputs(e->e_xfp, SM_TIME_DEFAULT, buf);
	}

d3028 1
a3028 1
	/* close SASL connection */
d3041 13
d3056 1
a3056 1
		(void) sm_io_close(mci->mci_in, SM_TIME_DEFAULT);
d3070 2
a3071 2
			ev = sm_setevent(mci->mci_mailer->m_wait,
					 endwaittimeout, 0);
d3085 1
a3085 1
		sm_clrevent(ev);
d3111 1
a3111 1
		(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT, "Arguments:");
d3113 2
a3114 3
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT, " %s",
					     *av);
		(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT, "\n");
a3135 1
**		to -- the current recipient (NULL if none).
d3146 1
a3146 1
giveresponse(status, dsn, m, mci, ctladdr, xstart, e, to)
a3153 1
	ADDRESS *to;
d3156 2
d3160 1
a3160 1
	bool usestat = false;
a3162 1
	char *exmsg;
d3171 1
a3171 1
	exmsg = sm_sysexmsg(status);
d3177 3
a3179 3
			(void) sm_snprintf(buf, sizeof buf, "%s (%s)",
					   statmsg,
					   shortenstring(e->e_statmsg, 403));
d3183 1
a3183 1
	else if (exmsg == NULL)
d3185 3
a3187 3
		(void) sm_snprintf(buf, sizeof buf,
				   "554 5.3.0 unknown mailer error %d",
				   status);
a3189 1
		usestat = true;
d3195 1
a3195 1
		(void) sm_strlcpy(bp, exmsg + 1, SPACELEFT(buf, bp));
d3199 1
a3199 1
			statmsg = sm_errstring(h_errno + E_DNSBASE);
d3204 1
a3204 1
				statmsg = sm_errstring(errnum);
d3206 2
d3209 4
d3238 2
a3239 4
					(void) sm_strlcpyn(bp,
							   SPACELEFT(buf, bp),
							   2, ": ",
							   mci->mci_host);
d3244 1
a3244 3
			(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2, ": ",
					   statmsg);
			usestat = true;
d3251 3
a3253 3
		statmsg = sm_errstring(h_errno + E_DNSBASE);
		(void) sm_snprintf(buf, sizeof buf, "%s (%s)", exmsg + 1,
				   statmsg);
a3254 1
		usestat = true;
d3259 1
a3259 1
		statmsg = exmsg;
d3262 2
a3263 2
			(void) sm_snprintf(buf, sizeof buf, "%s: %s", statmsg,
					   sm_errstring(errnum));
a3264 1
			usestat = true;
d3280 2
a3281 2
				(void) sm_snprintf(dsnbuf, sizeof dsnbuf,
						   "%.*s", off, statmsg + 4);
d3292 1
a3292 2
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT, "%s\n",
					     &MsgBuf[4]);
d3304 2
a3305 2
				(void) sm_snprintf(dsnbuf, sizeof dsnbuf,
						   "%.*s", off, statmsg + 4);
d3309 2
a3310 4

			/* copy only part of statmsg to mbuf */
			(void) sm_strlcpy(mbuf, statmsg, off);
			(void) sm_strlcat(mbuf, " %s", sizeof mbuf);
d3315 1
a3315 2
			(void) sm_snprintf(mbuf, sizeof mbuf, "%.3s %%s",
					   statmsg);
d3333 4
a3336 5
		sm_dprintf("giveresponse: status=%d, dsn=%s, e->e_message=%s, errnum=%d\n",
			   status,
			   dsn == NULL ? "<NULL>" : dsn,
			   e->e_message == NULL ? "<NULL>" : e->e_message,
			   errnum);
a3340 2
		e->e_message = sm_rpool_strdup_x(e->e_rpool, statmsg + off);
	if (status != EX_OK && to != NULL && to->q_message == NULL)
d3342 3
a3344 6
		if (!usestat && e->e_message != NULL)
			to->q_message = sm_rpool_strdup_x(e->e_rpool,
							  e->e_message);
		else
			to->q_message = sm_rpool_strdup_x(e->e_rpool,
							  statmsg + off);
d3347 3
a3349 1
	SM_SET_H_ERRNO(0);
d3389 1
a3389 1
	time_t now = curtime();
d3397 2
a3398 2
		(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2, ", ctladdr=",
				   shortenstring(ctladdr->q_paddr, 83));
d3402 3
a3404 3
			(void) sm_snprintf(bp, SPACELEFT(buf, bp), " (%d/%d)",
					   (int) ctladdr->q_uid,
					   (int) ctladdr->q_gid);
d3410 3
a3412 2
	(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2, ", delay=",
			   pintvl(now - e->e_ctime, true));
d3417 2
a3418 2
		(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2, ", xdelay=",
				   pintvl(now - xstart, true));
d3425 1
a3425 2
		(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2, ", mailer=",
				   m->m_name);
d3430 1
a3430 2
	(void) sm_snprintf(bp, SPACELEFT(buf, bp), ", pri=%ld",
		e->e_msgpriority);
d3436 1
d3438 1
d3440 2
a3441 2
		(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2, ", relay=",
				   shortenstring(mci->mci_host, 40));
d3444 1
d3447 2
a3448 2
			(void) sm_snprintf(bp, SPACELEFT(buf, bp), " [%s]",
					   anynet_ntoa(&CurHostAddr));
d3450 1
d3457 2
a3458 2
			(void) sm_snprintf(bp, SPACELEFT(buf, bp),
					   ", relay=%s", shortenstring(p, 40));
d3466 2
a3467 2
		(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2, ", dsn=",
				   shortenstring(dsn, ENHSCLEN));
d3486 1
a3486 1
		(void) sm_strlcpy(bp, "...", SPACELEFT(buf, bp));
d3490 1
a3490 1
	(void) sm_strlcpy(bp, ", stat=", SPACELEFT(buf, bp));
d3493 1
a3493 2
	(void) sm_strlcpy(bp, shortenstring(status, STATLEN),
			  SPACELEFT(buf, bp));
a3496 2
	if (l < 0)
		l = 0;
d3498 1
a3498 1
	while (strlen(p) >= l)
d3502 1
d3510 8
a3517 1
		sm_syslog(LOG_INFO, e->e_id, "to=%.*s [more]%s",
d3521 1
d3523 3
a3529 2
	if (l < 0)
		l = 0;
d3531 1
a3531 1
	while (strlen(p) >= l)
d3535 1
d3543 5
d3549 2
a3550 1
		sm_syslog(LOG_INFO, e->e_id, "to=%.*s [more]",
d3554 1
d3556 3
d3563 2
a3564 2
		(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2, "ctladdr=",
				   shortenstring(ctladdr->q_paddr, 83));
d3568 2
a3569 2
			(void) sm_snprintf(bp, SPACELEFT(buf, bp), " (%d/%d)",
					   ctladdr->q_uid, ctladdr->q_gid);
d3575 2
a3576 2
	(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2, "delay=",
			   pintvl(now - e->e_ctime, true));
d3580 2
a3581 2
		(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2, ", xdelay=",
				   pintvl(now - xstart, true));
d3587 1
a3587 2
		(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2, ", mailer=",
				   m->m_name);
d3596 1
d3598 1
d3600 1
a3600 2
		(void) sm_snprintf(bp, SPACELEFT(buf, bp), "relay=%.100s",
				   mci->mci_host);
d3603 1
d3605 3
a3607 3
			(void) sm_snprintf(bp, SPACELEFT(buf, bp),
					   " [%.100s]",
					   anynet_ntoa(&CurHostAddr));
d3613 1
a3613 1
			(void) sm_snprintf(buf, sizeof buf, "relay=%.100s", p);
d3679 3
a3681 3
			(void) sm_snprintf(xbuf, sizeof xbuf,
					   "From %.800s  \201d remote from %.100s\n",
					   buf, at);
d3686 3
a3688 3
			(void) sm_snprintf(xbuf, sizeof xbuf,
					   "From %.800s  \201d remote from %.100s\n",
					   bang, buf);
d3722 1
a3722 1
	bool dead = false;
a3723 1
#if MIME8TO7
a3724 1
#endif /* MIME8TO7 */
d3734 1
a3734 2
		e->e_dfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, df,
				      SM_IO_RDONLY, NULL);
a3742 1

d3759 1
a3759 2
		if (fstat(sm_io_getinfo(e->e_dfp, SM_IO_WHAT_FD, NULL), &stbuf)
		    < 0)
d3784 3
a3786 3
			(void) sm_snprintf(buf, sizeof buf,
					   "Content-Type: text/plain; charset=%s",
					   defcharset(e));
d3818 1
a3818 1
			SuprErrs = true;
d3855 1
a3855 1
		while (!sm_io_error(mci->mci_out) && !dead)
d3859 1
a3859 2
			else if ((c = sm_io_getc(e->e_dfp, SM_TIME_DEFAULT))
				 == SM_IO_EOF)
d3866 1
d3868 1
a3868 2
				    bitnset(M_NONULLS,
					    mci->mci_mailer->m_flags))
d3870 1
d3880 1
a3880 1
				padc = SM_IO_EOF;
d3882 2
a3883 2
				    bitnset(M_ESCFROM, mci->mci_mailer->m_flags)
				    && strncmp(buf, "From ", 5) == 0)
d3893 1
a3893 2
					if (strncmp(&buf[2], separator, sl)
					    == 0)
d3905 5
a3909 8
					(void) sm_io_fprintf(TrafficLogFile,
							     SM_TIME_DEFAULT,
							     "%05d >>> ",
							     (int) CurrentPid);
					if (padc != SM_IO_EOF)
						(void) sm_io_putc(TrafficLogFile,
								  SM_TIME_DEFAULT,
								  padc);
d3911 2
a3912 3
						(void) sm_io_putc(TrafficLogFile,
								  SM_TIME_DEFAULT,
								  (unsigned char) *xp);
d3914 6
a3919 9
						(void) sm_io_fputs(TrafficLogFile,
								   SM_TIME_DEFAULT,
								   mci->mci_mailer->m_eol);
				}
				if (padc != SM_IO_EOF)
				{
					if (sm_io_putc(mci->mci_out,
						       SM_TIME_DEFAULT, padc)
					    == SM_IO_EOF)
d3921 1
a3921 1
						dead = true;
d3927 1
a3927 1
						DataProgress = true;
d3933 2
a3934 4
					if (sm_io_putc(mci->mci_out,
						       SM_TIME_DEFAULT,
						       (unsigned char) *xp)
					    == SM_IO_EOF)
d3936 1
a3936 1
						dead = true;
d3942 1
a3942 1
						DataProgress = true;
d3949 2
a3950 4
					if (sm_io_fputs(mci->mci_out,
							SM_TIME_DEFAULT,
							mci->mci_mailer->m_eol)
							== SM_IO_EOF)
d3955 1
a3955 1
						DataProgress = true;
d3981 2
a3982 4
					if (sm_io_fputs(mci->mci_out,
							SM_TIME_DEFAULT,
							mci->mci_mailer->m_eol)
							== SM_IO_EOF)
d3987 1
a3987 1
						DataProgress = true;
d3992 2
a3993 3
						(void) sm_io_fputs(TrafficLogFile,
								   SM_TIME_DEFAULT,
								   mci->mci_mailer->m_eol);
d4011 1
d4013 1
a4013 2
				    bitnset(M_NONULLS,
					    mci->mci_mailer->m_flags))
d4015 1
d4026 1
a4026 3
					else if ((d = sm_io_getc(e->e_dfp,
								 SM_TIME_DEFAULT))
						 != SM_IO_EOF)
d4029 1
a4029 1
					if (d == '\n' || d == SM_IO_EOF)
d4032 4
a4035 7
							(void) sm_io_putc(TrafficLogFile,
									  SM_TIME_DEFAULT,
									  (unsigned char) c);
						if (sm_io_putc(mci->mci_out,
							       SM_TIME_DEFAULT,
							       (unsigned char) c)
							       == SM_IO_EOF)
d4037 1
a4037 1
							dead = true;
d4043 1
a4043 1
							DataProgress = true;
d4049 3
a4051 7
					if (sm_io_putc(mci->mci_out,
						       SM_TIME_DEFAULT, '!')
					    == SM_IO_EOF ||
					    sm_io_fputs(mci->mci_out,
							SM_TIME_DEFAULT,
							mci->mci_mailer->m_eol)
					    == SM_IO_EOF)
d4053 1
a4053 1
						dead = true;
d4059 1
a4059 1
						DataProgress = true;
d4064 2
a4065 4
						(void) sm_io_fprintf(TrafficLogFile,
								     SM_TIME_DEFAULT,
								     "!%s",
								     mci->mci_mailer->m_eol);
d4074 4
a4077 7
						(void) sm_io_fputs(TrafficLogFile,
								   SM_TIME_DEFAULT,
								   mci->mci_mailer->m_eol);
					if (sm_io_fputs(mci->mci_out,
							SM_TIME_DEFAULT,
							mci->mci_mailer->m_eol)
							== SM_IO_EOF)
d4082 1
a4082 1
						DataProgress = true;
d4090 4
a4093 7
						(void) sm_io_putc(TrafficLogFile,
								  SM_TIME_DEFAULT,
								  (unsigned char) c);
					if (sm_io_putc(mci->mci_out,
						       SM_TIME_DEFAULT,
						       (unsigned char) c)
					    == SM_IO_EOF)
d4095 1
a4095 1
						dead = true;
d4101 1
a4101 1
						DataProgress = true;
d4116 2
a4117 3
					(void) sm_io_putc(TrafficLogFile,
							  SM_TIME_DEFAULT,
							  (unsigned char) *xp);
d4121 2
a4122 3
				if (sm_io_putc(mci->mci_out, SM_TIME_DEFAULT,
					       (unsigned char) *xp)
				    == SM_IO_EOF)
d4124 1
a4124 1
					dead = true;
d4130 1
a4130 1
					DataProgress = true;
d4138 3
a4140 5
				(void) sm_io_fputs(TrafficLogFile,
						   SM_TIME_DEFAULT,
						   mci->mci_mailer->m_eol);
			(void) sm_io_fputs(mci->mci_out, SM_TIME_DEFAULT,
					   mci->mci_mailer->m_eol);
d4143 1
a4143 1
			DataProgress = true;
d4147 1
a4147 1
	if (sm_io_error(e->e_dfp))
d4150 1
a4150 1
		       qid_printqueue(e->e_dfqgrp, e->e_dfqdir), e->e_id);
d4174 2
a4175 2
	(void) sm_io_flush(mci->mci_out, SM_TIME_DEFAULT);
	if (sm_io_error(mci->mci_out) && errno != EPIPE)
d4186 2
a4187 2
**	If the file has the set-user-ID/set-group-ID bits set, but NO
**	execute bits, sendmail will try to become the owner of that file
a4212 2
# define RETURN(st)			exit(st);

d4223 1
a4223 1
	register SM_FILE_T *f;
d4231 1
a4231 1
	SM_EVENT *ev;
d4237 2
a4238 2
		sm_dprintf("mailfile %s\n  ctladdr=", filename);
		printaddr(ctladdr, false);
d4245 1
a4245 1
		(void) sm_io_flush(e->e_xfp, SM_TIME_DEFAULT);
d4252 1
a4252 1
	if (sm_path_isdevnull(filename))
d4265 1
a4265 1
			  "554 Cannot send 8-bit data to 7-bit destination");
d4277 1
a4277 1
		if (len + strlen(filename) + 1 >= sizeof targetfile)
d4283 1
a4283 1
		(void) sm_strlcpy(targetfile, SafeFileEnv, sizeof targetfile);
d4286 1
a4286 1
			(void) sm_strlcat(targetfile, "/", sizeof targetfile);
d4289 1
a4289 1
		(void) sm_strlcat(targetfile, filename, sizeof targetfile);
d4299 1
a4299 1
		if (len + strlen(filename) + 1 >= sizeof targetfile)
d4307 1
a4307 1
			(void) sm_strlcat(targetfile, "/", sizeof targetfile);
d4309 2
a4310 2
			(void) sm_strlcat(targetfile, filename + 1,
					  sizeof targetfile);
d4312 1
a4312 2
			(void) sm_strlcat(targetfile, filename,
					  sizeof targetfile);
d4316 1
a4316 2
		if (sm_strlcpy(targetfile, filename, sizeof targetfile) >=
		    sizeof targetfile)
d4321 1
a4342 7
		/* Reset global flags */
		RestartRequest = NULL;
		RestartWorkGroup = false;
		ShutdownRequest = NULL;
		PendingSignal = 0;
		CurrentPid = getpid();

d4344 1
a4344 2
			(void) close(sm_io_getinfo(e->e_lockfp, SM_IO_WHAT_FD,
				     NULL));
d4346 3
a4348 3
		(void) sm_signal(SIGINT, SIG_DFL);
		(void) sm_signal(SIGHUP, SIG_DFL);
		(void) sm_signal(SIGTERM, SIG_DFL);
d4355 1
a4355 1
			RETURN(EX_TEMPFAIL);
d4359 1
a4359 2
			ev = sm_setevent(TimeOuts.to_fileopen, mailfiletimeout,
					 0);
d4363 1
a4363 1
		/* check file mode to see if set-user-ID */
d4377 1
a4377 1
			/* ignore set-user-ID and set-group-ID bits */
d4380 1
a4380 1
				sm_dprintf("mailfile: ignoring set-user-ID/set-group-ID bits\n");
d4383 1
a4383 1
		/* we have to open the dfile BEFORE setuid() */
d4388 1
a4388 2
			e->e_dfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, df,
					      SM_IO_RDONLY, NULL);
d4407 1
a4407 1
					RETURN(EX_TEMPFAIL);
d4444 1
a4444 1
					RETURN(EX_TEMPFAIL);
d4486 1
a4486 1
				RETURN(EX_TEMPFAIL);
d4497 1
a4497 1
				RETURN(EX_TEMPFAIL);
d4509 1
a4509 1
				sm_dprintf("mailfile: chroot %s\n", targetfile);
d4514 1
a4514 1
				RETURN(EX_CANTCREAT);
d4520 1
a4520 1
			sm_dprintf("mailfile: deliver to %s\n", realfile);
d4525 1
a4525 1
			RETURN(EX_CANTCREAT);
a4529 1
		sm_mbdb_terminate();
d4533 1
a4533 1
			RETURN(EX_TEMPFAIL);
d4539 1
a4539 1
			RETURN(EX_TEMPFAIL);
d4543 1
a4543 1
			sm_dprintf("mailfile: running as r/euid=%d/%d, r/egid=%d/%d\n",
d4562 1
a4562 2
					sm_dprintf("mailfile: trydir %s\n",
						   buf);
d4612 2
a4613 2
				       sm_errstring(errno));
				RETURN(EX_TEMPFAIL);
d4619 2
a4620 2
				       sm_errstring(errno));
				RETURN(EX_CANTCREAT);
d4623 1
a4623 2
		if (filechanged(realfile, sm_io_getinfo(f, SM_IO_WHAT_FD, NULL),
		    &stb))
d4626 1
a4626 1
			RETURN(EX_CANTCREAT);
d4628 1
a4628 1
		if (fstat(sm_io_getinfo(f, SM_IO_WHAT_FD, NULL), &stb) < 0)
d4630 2
a4631 3
			syserr("554 5.3.0 cannot fstat %s",
				sm_errstring(errno));
			RETURN(EX_CANTCREAT);
d4637 1
a4637 1
			sm_clrevent(ev);
d4657 2
a4658 2
		    (sm_strcasecmp(p, "quoted-printable") == 0 ||
		     sm_strcasecmp(p, "base64") == 0) &&
d4663 1
a4663 1
			if (sm_strncasecmp(p, "text/plain", 10) == 0 &&
d4673 3
a4675 4
		if (sm_io_flush(f, SM_TIME_DEFAULT) != 0 ||
		    (SuperSafe != SAFE_NO &&
		     fsync(sm_io_getinfo(f, SM_IO_WHAT_FD, NULL)) < 0) ||
		    sm_io_error(f))
d4679 1
a4679 2
			(void) ftruncate(sm_io_getinfo(f, SM_IO_WHAT_FD, NULL),
					 curoff);
d4685 1
a4685 2
		(void) fchmod(sm_io_getinfo(f, SM_IO_WHAT_FD, NULL),
			      (MODE_T) mode);
d4689 1
a4689 1
		if (sm_io_close(f, SM_TIME_DEFAULT) < 0)
d4691 1
a4691 1
		(void) sm_io_flush(smioout, SM_TIME_DEFAULT);
a4722 7
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
a4741 1

d4744 1
a4744 1
char *
a4750 1
	time_t now;
d4758 1
d4763 1
a4763 1
	unsigned short mxprefs[MAXMXHOSTS + 1];
d4767 1
a4767 1
		sm_dprintf("hostsignature(%s)\n", host);
d4770 1
a4770 1
	**  If local delivery (and not remote), just return a constant.
d4773 1
a4773 2
	if (bitnset(M_LOCALMAILER, m->m_flags) &&
	    strcmp(m->m_mailer, "[IPC]") != 0)
d4780 3
a4782 2
	if (strcmp(m->m_mailer, "[IPC]") != 0 ||
	    CurEnv->e_sendmode == SM_DEFER)
d4784 1
a4784 1
		/* just an ordinary mailer or deferred mode */
a4799 1
	now = curtime();
d4801 1
a4801 1
	if (s->s_hostsig.hs_sig != NULL)
d4803 4
a4806 11
		if (s->s_hostsig.hs_exp >= now)
		{
			if (tTd(17, 3))
				sm_dprintf("hostsignature(): stab(%s) found %s\n", host,
					   s->s_hostsig.hs_sig);
			return s->s_hostsig.hs_sig;
		}

		/* signature is expired: clear it */
		sm_free(s->s_hostsig.hs_sig);
		s->s_hostsig.hs_sig = NULL;
a4808 3
	/* set default TTL */
	s->s_hostsig.hs_exp = now + SM_DEFAULT_TTL;

d4810 1
a4810 1
	**  Not already there or expired -- create a signature.
d4817 1
a4846 1
			int ttl;
d4848 1
a4848 2
			nmx = getmxrr(hp, mxhosts, mxprefs, true, &rcode, true,
				      &ttl);
a4850 1
				int save_errno;
a4853 1
				save_errno = errno;
d4855 1
a4855 1
				mci->mci_errno = save_errno;
d4860 1
a4860 1
						    "550 Host unknown");
d4869 2
a4870 9
				sm_dprintf("hostsignature(): getmxrr() returned %d, mxhosts[0]=%s\n",
					   nmx, mxhosts[0]);

			/*
			**  Set new TTL: we use only one!
			**	We could try to use the minimum instead.
			*/

			s->s_hostsig.hs_exp = now + SM_MIN(ttl, SM_DEFAULT_TTL);
d4876 3
a4878 3
		if (s->s_hostsig.hs_sig != NULL)
			len += strlen(s->s_hostsig.hs_sig) + 1;
		if (len < 0 || len >= MAXHOSTSIGNATURE)
d4884 2
a4885 2
		p = sm_pmalloc_x(len);
		if (s->s_hostsig.hs_sig != NULL)
d4887 3
a4889 3
			(void) sm_strlcpy(p, s->s_hostsig.hs_sig, len);
			sm_free(s->s_hostsig.hs_sig); /* XXX */
			s->s_hostsig.hs_sig = p;
d4896 1
a4896 1
			s->s_hostsig.hs_sig = p;
d4914 1
a4914 1
			(void) sm_strlcpy(p, mxhosts[i], len);
d4931 1
a4931 1
	makelower(s->s_hostsig.hs_sig);
d4936 1
a4936 5
	/*
	**  'host' points to storage that will be freed after we are
	**  done processing the current envelope, so we copy it.
	*/
	s->s_hostsig.hs_sig = sm_pstrdup_x(host);
d4939 2
a4940 2
		sm_dprintf("hostsignature(%s) = %s\n", host, s->s_hostsig.hs_sig);
	return s->s_hostsig.hs_sig;
a4952 1
**		mailer -- mailer.
d4967 3
a4969 2
	unsigned short curpref = 0;
	int nmx = 0, i, j;	/* NOTE: i, j, and nmx must have same type */
d4971 1
a4971 1
	unsigned short prefer[MAXMXHOSTS];
d5037 1
a5037 1
				register unsigned short tempp;
d5056 1
a5058 1
static bool	tls_ok_clt = true;
d5061 1
a5061 1
**  SETCLTTLS -- client side TLS: allow/disallow.
a5063 3
**		tls_ok -- should tls be done?
**
**	Returns:
a5065 17
**	Side Effects:
**		sets tls_ok_clt (static variable in this module)
*/

void
setclttls(tls_ok)
	bool tls_ok;
{
	tls_ok_clt = tls_ok;
	return;
}
/*
**  INITCLTTLS -- initialize client side TLS
**
**	Parameters:
**		tls_ok -- should tls initialization be done?
**
a5067 3
**
**	Side Effects:
**		sets tls_ok_clt (static variable in this module)
d5071 1
a5071 2
initclttls(tls_ok)
	bool tls_ok;
a5072 5
	if (!tls_ok_clt)
		return false;
	tls_ok_clt = tls_ok;
	if (!tls_ok_clt)
		return false;
d5074 3
a5076 4
		return true;	/* already done */
	tls_ok_clt = inittls(&clt_ctx, TLS_I_CLT, false, CltCERTfile,
			     Cltkeyfile, CACERTpath, CACERTfile, DHParams);
	return tls_ok_clt;
a5102 1
	time_t tlsstart;
d5104 1
a5104 1
	if (clt_ctx == NULL && !initclttls(true))
d5109 2
a5110 1
	smtpresult = reply(m, mci, e, TimeOuts.to_starttls, NULL, NULL);
d5123 1
a5123 1
		sm_syslog(LOG_INFO, NOQID, "STARTTLS=client, start=ok");
d5130 2
a5131 2
			sm_syslog(LOG_ERR, NOQID,
				  "STARTTLS=client, error: SSL_new failed");
d5133 1
a5133 1
				tlslogerr("client");
d5138 2
a5139 2
	rfd = sm_io_getinfo(mci->mci_in, SM_IO_WHAT_FD, NULL);
	wfd = sm_io_getinfo(mci->mci_out, SM_IO_WHAT_FD, NULL);
d5143 2
a5144 2
	    (result = SSL_set_rfd(clt_ssl, rfd)) != 1 ||
	    (result = SSL_set_wfd(clt_ssl, wfd)) != 1)
d5148 2
a5149 3
			sm_syslog(LOG_ERR, NOQID,
				  "STARTTLS=client, error: SSL_set_xfd failed=%d",
				  result);
d5151 1
a5151 1
				tlslogerr("client");
a5155 3
	tlsstart = curtime();

ssl_retry:
a5158 4
		bool timedout;
		time_t left;
		time_t now = curtime();
		struct timeval tv;
a5161 48

		/*
		**  For SSL_ERROR_WANT_{READ,WRITE}:
		**  There is not a complete SSL record available yet
		**  or there is only a partial SSL record removed from
		**  the network (socket) buffer into the SSL buffer.
		**  The SSL_connect will only succeed when a full
		**  SSL record is available (assuming a "real" error
		**  doesn't happen). To handle when a "real" error
		**  does happen the select is set for exceptions too.
		**  The connection may be re-negotiated during this time
		**  so both read and write "want errors" need to be handled.
		**  A select() exception loops back so that a proper SSL
		**  error message can be gotten.
		*/

		left = TimeOuts.to_starttls - (now - tlsstart);
		timedout = left <= 0;
		if (!timedout)
		{
			tv.tv_sec = left;
			tv.tv_usec = 0;
		}

		if (!timedout && i == SSL_ERROR_WANT_READ)
		{
			fd_set ssl_maskr, ssl_maskx;

			FD_ZERO(&ssl_maskr);
			FD_SET(rfd, &ssl_maskr);
			FD_ZERO(&ssl_maskx);
			FD_SET(rfd, &ssl_maskx);
			if (select(rfd + 1, &ssl_maskr, NULL, &ssl_maskx, &tv)
			    > 0)
				goto ssl_retry;
		}
		if (!timedout && i == SSL_ERROR_WANT_WRITE)
		{
			fd_set ssl_maskw, ssl_maskx;

			FD_ZERO(&ssl_maskw);
			FD_SET(wfd, &ssl_maskw);
			FD_ZERO(&ssl_maskx);
			FD_SET(rfd, &ssl_maskx);
			if (select(wfd + 1, NULL, &ssl_maskw, &ssl_maskx, &tv)
			    > 0)
				goto ssl_retry;
		}
d5165 4
a5168 4
				  "STARTTLS=client, error: connect failed=%d, SSL_error=%d, timedout=%d",
				  result, i, (int) timedout);
			if (LogLevel > 8)
				tlslogerr("client");
d5175 1
a5175 2
	result = tls_get_info(mci->mci_ssl, false, mci->mci_host,
			      &mci->mci_macro, true);
d5177 6
a5182 1
	/* switch to use TLS... */
d5185 2
d5193 1
d5203 1
a5203 2

static int
a5214 2
# endif /* STARTTLS */
# if STARTTLS || SASL
d5216 1
a5216 1
**  ISCLTFLGSET -- check whether client flag is set.
d5219 2
a5220 2
**		e -- envelope.
**		flag -- flag to check in {client_flags}
d5223 1
a5223 1
**		true iff flag is set.
d5226 4
a5229 4
static bool
iscltflgset(e, flag)
	ENVELOPE *e;
	int flag;
d5231 3
a5233 1
	char *p;
d5235 18
a5252 8
	p = macvalue(macid("{client_flags}"), e);
	if (p == NULL)
		return false;
	for (; *p != '\0'; p++)
	{
		/* look for just this one flag */
		if (*p == (char) flag)
			return true;
d5254 1
a5254 1
	return false;
d5256 2
a5257 1
# endif /* STARTTLS || SASL */
@


