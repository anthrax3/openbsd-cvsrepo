head	1.22;
access;
symbols
	OPENBSD_5_6:1.21.0.6
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.19.0.8
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.6
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.4
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.18.0.12
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.10
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.6
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.8
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.4
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.17.0.6
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.4
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2014.09.17.18.49.52;	author matthieu;	state dead;
branches;
next	1.21;
commitid	M7i5giHIoz3DMlTU;

1.21
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.19;

1.19
date	2011.05.17.15.54.23;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2006.08.13.13.01.48;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.22.18.43.55;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.08.16.00.51;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.16.00.21.31;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.24.03.59.27;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.17.17.31.40;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.03.17.31.21;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.01.19.59.23;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.03.17.25.47;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.18.00.49.28;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.01.17.18.30;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.11.19.02.50;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.29.01.31.15;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.15.21.09.09;	author millert;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.04.02.19.05.46;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.46;	author millert;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.15;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.50;	author millert;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	2001.05.31.00.31.37;	author miod;	state Exp;
branches;
next	;

1.2.2.1
date	2001.05.31.01.47.57;	author jason;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2005, 2010 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>

SM_RCSID("@@(#)$Sendmail: mci.c,v 8.225 2013/11/22 20:51:56 ca Exp $")

#if NETINET || NETINET6
# include <arpa/inet.h>
#endif /* NETINET || NETINET6 */

#include <dirent.h>

static int	mci_generate_persistent_path __P((const char *, char *,
						  int, bool));
static bool	mci_load_persistent __P((MCI *));
static void	mci_uncache __P((MCI **, bool));
static int	mci_lock_host_statfile __P((MCI *));
static int	mci_read_persistent __P((SM_FILE_T *, MCI *));

/*
**  Mail Connection Information (MCI) Caching Module.
**
**	There are actually two separate things cached.  The first is
**	the set of all open connections -- these are stored in a
**	(small) list.  The second is stored in the symbol table; it
**	has the overall status for all hosts, whether or not there
**	is a connection open currently.
**
**	There should never be too many connections open (since this
**	could flood the socket table), nor should a connection be
**	allowed to sit idly for too long.
**
**	MaxMciCache is the maximum number of open connections that
**	will be supported.
**
**	MciCacheTimeout is the time (in seconds) that a connection
**	is permitted to survive without activity.
**
**	We actually try any cached connections by sending a RSET
**	before we use them; if the RSET fails we close down the
**	connection and reopen it (see smtpprobe()).
**
**	The persistent MCI code is donated by Mark Lovell and Paul
**	Vixie.  It is based on the long term host status code in KJS
**	written by Paul but has been adapted by Mark to fit into the
**	MCI structure.
*/

static MCI	**MciCache;		/* the open connection cache */

/*
**  MCI_CACHE -- enter a connection structure into the open connection cache
**
**	This may cause something else to be flushed.
**
**	Parameters:
**		mci -- the connection to cache.
**
**	Returns:
**		none.
*/

void
mci_cache(mci)
	register MCI *mci;
{
	register MCI **mcislot;

	/*
	**  Find the best slot.  This may cause expired connections
	**  to be closed.
	*/

	mcislot = mci_scan(mci);
	if (mcislot == NULL)
	{
		/* we don't support caching */
		return;
	}

	if (mci->mci_host == NULL)
		return;

	/* if this is already cached, we are done */
	if (bitset(MCIF_CACHED, mci->mci_flags))
		return;

	/* otherwise we may have to clear the slot */
	if (*mcislot != NULL)
		mci_uncache(mcislot, true);

	if (tTd(42, 5))
		sm_dprintf("mci_cache: caching %p (%s) in slot %d\n",
			   mci, mci->mci_host, (int) (mcislot - MciCache));
	if (tTd(91, 100))
		sm_syslog(LOG_DEBUG, CurEnv->e_id,
			  "mci_cache: caching %lx (%.100s) in slot %d",
			  (unsigned long) mci, mci->mci_host,
			  (int) (mcislot - MciCache));

	*mcislot = mci;
	mci->mci_flags |= MCIF_CACHED;
}
/*
**  MCI_SCAN -- scan the cache, flush junk, and return best slot
**
**	Parameters:
**		savemci -- never flush this one.  Can be null.
**
**	Returns:
**		The LRU (or empty) slot.
*/

MCI **
mci_scan(savemci)
	MCI *savemci;
{
	time_t now;
	register MCI **bestmci;
	register MCI *mci;
	register int i;

	if (MaxMciCache <= 0)
	{
		/* we don't support caching */
		return NULL;
	}

	if (MciCache == NULL)
	{
		/* first call */
		MciCache = (MCI **) sm_pmalloc_x(MaxMciCache * sizeof(*MciCache));
		memset((char *) MciCache, '\0', MaxMciCache * sizeof(*MciCache));
		return &MciCache[0];
	}

	now = curtime();
	bestmci = &MciCache[0];
	for (i = 0; i < MaxMciCache; i++)
	{
		mci = MciCache[i];
		if (mci == NULL || mci->mci_state == MCIS_CLOSED)
		{
			bestmci = &MciCache[i];
			continue;
		}
		if ((mci->mci_lastuse + MciCacheTimeout <= now ||
		     (mci->mci_mailer != NULL &&
		      mci->mci_mailer->m_maxdeliveries > 0 &&
		      mci->mci_deliveries + 1 >= mci->mci_mailer->m_maxdeliveries))&&
		    mci != savemci)
		{
			/* connection idle too long or too many deliveries */
			bestmci = &MciCache[i];

			/* close it */
			mci_uncache(bestmci, true);
			continue;
		}
		if (*bestmci == NULL)
			continue;
		if (mci->mci_lastuse < (*bestmci)->mci_lastuse)
			bestmci = &MciCache[i];
	}
	return bestmci;
}
/*
**  MCI_UNCACHE -- remove a connection from a slot.
**
**	May close a connection.
**
**	Parameters:
**		mcislot -- the slot to empty.
**		doquit -- if true, send QUIT protocol on this connection.
**			  if false, we are assumed to be in a forked child;
**				all we want to do is close the file(s).
**
**	Returns:
**		none.
*/

static void
mci_uncache(mcislot, doquit)
	register MCI **mcislot;
	bool doquit;
{
	register MCI *mci;
	extern ENVELOPE BlankEnvelope;

	mci = *mcislot;
	if (mci == NULL)
		return;
	*mcislot = NULL;
	if (mci->mci_host == NULL)
		return;

	mci_unlock_host(mci);

	if (tTd(42, 5))
		sm_dprintf("mci_uncache: uncaching %p (%s) from slot %d (%d)\n",
			   mci, mci->mci_host, (int) (mcislot - MciCache),
			   doquit);
	if (tTd(91, 100))
		sm_syslog(LOG_DEBUG, CurEnv->e_id,
			  "mci_uncache: uncaching %lx (%.100s) from slot %d (%d)",
			  (unsigned long) mci, mci->mci_host,
			  (int) (mcislot - MciCache), doquit);

	mci->mci_deliveries = 0;
	if (doquit)
	{
		message("Closing connection to %s", mci->mci_host);

		mci->mci_flags &= ~MCIF_CACHED;

		/* only uses the envelope to flush the transcript file */
		if (mci->mci_state != MCIS_CLOSED)
			smtpquit(mci->mci_mailer, mci, &BlankEnvelope);
#if XLA
		xla_host_end(mci->mci_host);
#endif /* XLA */
	}
	else
	{
		if (mci->mci_in != NULL)
			(void) sm_io_close(mci->mci_in, SM_TIME_DEFAULT);
		if (mci->mci_out != NULL)
			(void) sm_io_close(mci->mci_out, SM_TIME_DEFAULT);
		mci->mci_in = mci->mci_out = NULL;
		mci->mci_state = MCIS_CLOSED;
		mci->mci_exitstat = EX_OK;
		mci->mci_errno = 0;
		mci->mci_flags = 0;

		mci->mci_retryrcpt = false;
		mci->mci_tolist = NULL;
#if PIPELINING
		mci->mci_okrcpts = 0;
#endif /* PIPELINING */
	}

	SM_FREE_CLR(mci->mci_status);
	SM_FREE_CLR(mci->mci_rstatus);
	SM_FREE_CLR(mci->mci_heloname);
	if (mci->mci_rpool != NULL)
	{
		sm_rpool_free(mci->mci_rpool);
		mci->mci_macro.mac_rpool = NULL;
		mci->mci_rpool = NULL;
	}
}
/*
**  MCI_FLUSH -- flush the entire cache
**
**	Parameters:
**		doquit -- if true, send QUIT protocol.
**			  if false, just close the connection.
**		allbut -- but leave this one open.
**
**	Returns:
**		none.
*/

void
mci_flush(doquit, allbut)
	bool doquit;
	MCI *allbut;
{
	register int i;

	if (MciCache == NULL)
		return;

	for (i = 0; i < MaxMciCache; i++)
	{
		if (allbut != MciCache[i])
			mci_uncache(&MciCache[i], doquit);
	}
}

/*
**  MCI_CLR_EXTENSIONS -- clear knowledge about SMTP extensions
**
**	Parameters:
**		mci -- the connection to clear.
**
**	Returns:
**		none.
*/

void
mci_clr_extensions(mci)
	MCI *mci;
{
	if (mci == NULL)
		return;

	mci->mci_flags &= ~MCIF_EXTENS;
	mci->mci_maxsize = 0;
	mci->mci_min_by = 0;
#if SASL
	mci->mci_saslcap = NULL;
#endif /* SASL */
}

/*
**  MCI_GET -- get information about a particular host
**
**	Parameters:
**		host -- host to look for.
**		m -- mailer.
**
**	Returns:
**		mci for this host (might be new).
*/

MCI *
mci_get(host, m)
	char *host;
	MAILER *m;
{
	register MCI *mci;
	register STAB *s;
	extern SOCKADDR CurHostAddr;

	/* clear CurHostAddr so we don't get a bogus address with this name */
	memset(&CurHostAddr, '\0', sizeof(CurHostAddr));

	/* clear out any expired connections */
	(void) mci_scan(NULL);

	if (m->m_mno < 0)
		syserr("!negative mno %d (%s)", m->m_mno, m->m_name);

	s = stab(host, ST_MCI + m->m_mno, ST_ENTER);
	mci = &s->s_mci;

	/* initialize per-message data */
	mci->mci_retryrcpt = false;
	mci->mci_tolist = NULL;
#if PIPELINING
	mci->mci_okrcpts = 0;
#endif /* PIPELINING */

	if (mci->mci_rpool == NULL)
		mci->mci_rpool = sm_rpool_new_x(NULL);

	if (mci->mci_macro.mac_rpool == NULL)
		mci->mci_macro.mac_rpool = mci->mci_rpool;

	/*
	**  We don't need to load the persistent data if we have data
	**  already loaded in the cache.
	*/

	if (mci->mci_host == NULL &&
	    (mci->mci_host = s->s_name) != NULL &&
	    !mci_load_persistent(mci))
	{
		if (tTd(42, 2))
			sm_dprintf("mci_get(%s %s): lock failed\n",
				host, m->m_name);
		mci->mci_exitstat = EX_TEMPFAIL;
		mci->mci_state = MCIS_CLOSED;
		mci->mci_statfile = NULL;
		return mci;
	}

	if (tTd(42, 2))
	{
		sm_dprintf("mci_get(%s %s): mci_state=%d, _flags=%lx, _exitstat=%d, _errno=%d\n",
			host, m->m_name, mci->mci_state, mci->mci_flags,
			mci->mci_exitstat, mci->mci_errno);
	}

	if (mci->mci_state == MCIS_OPEN)
	{
		/* poke the connection to see if it's still alive */
		(void) smtpprobe(mci);

		/* reset the stored state in the event of a timeout */
		if (mci->mci_state != MCIS_OPEN)
		{
			mci->mci_errno = 0;
			mci->mci_exitstat = EX_OK;
			mci->mci_state = MCIS_CLOSED;
		}
		else
		{
			/* get peer host address */
			/* (this should really be in the mci struct) */
			SOCKADDR_LEN_T socklen = sizeof(CurHostAddr);

			(void) getpeername(sm_io_getinfo(mci->mci_in,
							 SM_IO_WHAT_FD, NULL),
				(struct sockaddr *) &CurHostAddr, &socklen);
		}
	}
	if (mci->mci_state == MCIS_CLOSED)
	{
		time_t now = curtime();

		/* if this info is stale, ignore it */
		if (mci->mci_lastuse + MciInfoTimeout <= now)
		{
			mci->mci_lastuse = now;
			mci->mci_errno = 0;
			mci->mci_exitstat = EX_OK;
		}
	}

	return mci;
}

/*
**  MCI_CLOSE -- (forcefully) close files used for a connection.
**	Note: this is a last resort, usually smtpquit() or endmailer()
**		should be used to close a connection.
**
**	Parameters:
**		mci -- the connection to close.
**		where -- where has this been called?
**
**	Returns:
**		none.
*/

void
mci_close(mci, where)
	MCI *mci;
	char *where;
{
	bool dumped;

	if (mci == NULL)
		return;
	dumped = false;
	if (mci->mci_out != NULL)
	{
		if (tTd(56, 1))
		{
			sm_dprintf("mci_close: mci_out!=NULL, where=%s\n",
				where);
			mci_dump(sm_debug_file(), mci, false);
			dumped = true;
		}
		(void) sm_io_close(mci->mci_out, SM_TIME_DEFAULT);
		mci->mci_out = NULL;
	}
	if (mci->mci_in != NULL)
	{
		if (tTd(56, 1))
		{
			sm_dprintf("mci_close: mci_in!=NULL, where=%s\n",
				where);
			if (!dumped)
				mci_dump(sm_debug_file(), mci, false);
		}
		(void) sm_io_close(mci->mci_in, SM_TIME_DEFAULT);
		mci->mci_in = NULL;
	}
	mci->mci_state = MCIS_CLOSED;
}

/*
**  MCI_NEW -- allocate new MCI structure
**
**	Parameters:
**		rpool -- if non-NULL: allocate from that rpool.
**
**	Returns:
**		mci (new).
*/

MCI *
mci_new(rpool)
	SM_RPOOL_T *rpool;
{
	register MCI *mci;

	if (rpool == NULL)
		mci = (MCI *) sm_malloc_x(sizeof(*mci));
	else
		mci = (MCI *) sm_rpool_malloc_x(rpool, sizeof(*mci));
	memset((char *) mci, '\0', sizeof(*mci));
	mci->mci_rpool = sm_rpool_new_x(NULL);
	mci->mci_macro.mac_rpool = mci->mci_rpool;
	return mci;
}
/*
**  MCI_MATCH -- check connection cache for a particular host
**
**	Parameters:
**		host -- host to look for.
**		m -- mailer.
**
**	Returns:
**		true iff open connection exists.
*/

bool
mci_match(host, m)
	char *host;
	MAILER *m;
{
	register MCI *mci;
	register STAB *s;

	if (m->m_mno < 0 || m->m_mno > MAXMAILERS)
		return false;
	s = stab(host, ST_MCI + m->m_mno, ST_FIND);
	if (s == NULL)
		return false;

	mci = &s->s_mci;
	return mci->mci_state == MCIS_OPEN;
}
/*
**  MCI_SETSTAT -- set status codes in MCI structure.
**
**	Parameters:
**		mci -- the MCI structure to set.
**		xstat -- the exit status code.
**		dstat -- the DSN status code.
**		rstat -- the SMTP status code.
**
**	Returns:
**		none.
*/

void
mci_setstat(mci, xstat, dstat, rstat)
	MCI *mci;
	int xstat;
	char *dstat;
	char *rstat;
{
	/* protocol errors should never be interpreted as sticky */
	if (xstat != EX_NOTSTICKY && xstat != EX_PROTOCOL)
		mci->mci_exitstat = xstat;

	SM_FREE_CLR(mci->mci_status);
	if (dstat != NULL)
		mci->mci_status = sm_strdup_x(dstat);

	SM_FREE_CLR(mci->mci_rstatus);
	if (rstat != NULL)
		mci->mci_rstatus = sm_strdup_x(rstat);
}
/*
**  MCI_DUMP -- dump the contents of an MCI structure.
**
**	Parameters:
**		fp -- output file pointer
**		mci -- the MCI structure to dump.
**
**	Returns:
**		none.
**
**	Side Effects:
**		none.
*/

struct mcifbits
{
	int	mcif_bit;	/* flag bit */
	char	*mcif_name;	/* flag name */
};
static struct mcifbits	MciFlags[] =
{
	{ MCIF_VALID,		"VALID"		},
	{ MCIF_CACHED,		"CACHED"	},
	{ MCIF_ESMTP,		"ESMTP"		},
	{ MCIF_EXPN,		"EXPN"		},
	{ MCIF_SIZE,		"SIZE"		},
	{ MCIF_8BITMIME,	"8BITMIME"	},
	{ MCIF_7BIT,		"7BIT"		},
	{ MCIF_INHEADER,	"INHEADER"	},
	{ MCIF_CVT8TO7,		"CVT8TO7"	},
	{ MCIF_DSN,		"DSN"		},
	{ MCIF_8BITOK,		"8BITOK"	},
	{ MCIF_CVT7TO8,		"CVT7TO8"	},
	{ MCIF_INMIME,		"INMIME"	},
	{ MCIF_AUTH,		"AUTH"		},
	{ MCIF_AUTH2,		"AUTH2"		},
	{ MCIF_AUTHACT,		"AUTHACT"	},
	{ MCIF_ENHSTAT,		"ENHSTAT"	},
	{ MCIF_PIPELINED,	"PIPELINED"	},
#if STARTTLS
	{ MCIF_TLS,		"TLS"		},
	{ MCIF_TLSACT,		"TLSACT"	},
#endif /* STARTTLS */
	{ MCIF_DLVR_BY,		"DLVR_BY"	},
	{ 0,			NULL		}
};

void
mci_dump(fp, mci, logit)
	SM_FILE_T *fp;
	register MCI *mci;
	bool logit;
{
	register char *p;
	char *sep;
	char buf[4000];

	sep = logit ? " " : "\n\t";
	p = buf;
	(void) sm_snprintf(p, SPACELEFT(buf, p), "MCI@@%p: ", mci);
	p += strlen(p);
	if (mci == NULL)
	{
		(void) sm_snprintf(p, SPACELEFT(buf, p), "NULL");
		goto printit;
	}
	(void) sm_snprintf(p, SPACELEFT(buf, p), "flags=%lx", mci->mci_flags);
	p += strlen(p);

	/*
	**  The following check is just for paranoia.  It protects the
	**  assignment in the if() clause. If there's not some minimum
	**  amount of space we can stop right now. The check will not
	**  trigger as long as sizeof(buf)=4000.
	*/

	if (p >= buf + sizeof(buf) - 4)
		goto printit;
	if (mci->mci_flags != 0)
	{
		struct mcifbits *f;

		*p++ = '<';	/* protected above */
		for (f = MciFlags; f->mcif_bit != 0; f++)
		{
			if (!bitset(f->mcif_bit, mci->mci_flags))
				continue;
			(void) sm_strlcpyn(p, SPACELEFT(buf, p), 2,
					   f->mcif_name, ",");
			p += strlen(p);
		}
		p[-1] = '>';
	}

	/* Note: sm_snprintf() takes care of NULL arguments for %s */
	(void) sm_snprintf(p, SPACELEFT(buf, p),
		",%serrno=%d, herrno=%d, exitstat=%d, state=%d, pid=%d,%s",
		sep, mci->mci_errno, mci->mci_herrno,
		mci->mci_exitstat, mci->mci_state, (int) mci->mci_pid, sep);
	p += strlen(p);
	(void) sm_snprintf(p, SPACELEFT(buf, p),
		"maxsize=%ld, phase=%s, mailer=%s,%s",
		mci->mci_maxsize, mci->mci_phase,
		mci->mci_mailer == NULL ? "NULL" : mci->mci_mailer->m_name,
		sep);
	p += strlen(p);
	(void) sm_snprintf(p, SPACELEFT(buf, p),
		"status=%s, rstatus=%s,%s",
		mci->mci_status, mci->mci_rstatus, sep);
	p += strlen(p);
	(void) sm_snprintf(p, SPACELEFT(buf, p),
		"host=%s, lastuse=%s",
		mci->mci_host, ctime(&mci->mci_lastuse));
printit:
	if (logit)
		sm_syslog(LOG_DEBUG, CurEnv->e_id, "%.1000s", buf);
	else
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "%s\n", buf);
}
/*
**  MCI_DUMP_ALL -- print the entire MCI cache
**
**	Parameters:
**		fp -- output file pointer
**		logit -- if set, log the result instead of printing
**			to stdout.
**
**	Returns:
**		none.
*/

void
mci_dump_all(fp, logit)
	SM_FILE_T *fp;
	bool logit;
{
	register int i;

	if (MciCache == NULL)
		return;

	for (i = 0; i < MaxMciCache; i++)
		mci_dump(fp, MciCache[i], logit);
}
/*
**  MCI_LOCK_HOST -- Lock host while sending.
**
**	If we are contacting a host, we'll need to
**	update the status information in the host status
**	file, and if we want to do that, we ought to have
**	locked it. This has the (according to some)
**	desirable effect of serializing connectivity with
**	remote hosts -- i.e.: one connection to a given
**	host at a time.
**
**	Parameters:
**		mci -- containing the host we want to lock.
**
**	Returns:
**		EX_OK	    -- got the lock.
**		EX_TEMPFAIL -- didn't get the lock.
*/

int
mci_lock_host(mci)
	MCI *mci;
{
	if (mci == NULL)
	{
		if (tTd(56, 1))
			sm_dprintf("mci_lock_host: NULL mci\n");
		return EX_OK;
	}

	if (!SingleThreadDelivery)
		return EX_OK;

	return mci_lock_host_statfile(mci);
}

static int
mci_lock_host_statfile(mci)
	MCI *mci;
{
	int save_errno = errno;
	int retVal = EX_OK;
	char fname[MAXPATHLEN];

	if (HostStatDir == NULL || mci->mci_host == NULL)
		return EX_OK;

	if (tTd(56, 2))
		sm_dprintf("mci_lock_host: attempting to lock %s\n",
			   mci->mci_host);

	if (mci_generate_persistent_path(mci->mci_host, fname, sizeof(fname),
					 true) < 0)
	{
		/* of course this should never happen */
		if (tTd(56, 2))
			sm_dprintf("mci_lock_host: Failed to generate host path for %s\n",
				   mci->mci_host);

		retVal = EX_TEMPFAIL;
		goto cleanup;
	}

	mci->mci_statfile = safefopen(fname, O_RDWR, FileMode,
				      SFF_NOLOCK|SFF_NOLINK|SFF_OPENASROOT|SFF_REGONLY|SFF_SAFEDIRPATH|SFF_CREAT);

	if (mci->mci_statfile == NULL)
	{
		syserr("mci_lock_host: cannot create host lock file %s", fname);
		goto cleanup;
	}

	if (!lockfile(sm_io_getinfo(mci->mci_statfile, SM_IO_WHAT_FD, NULL),
		      fname, "", LOCK_EX|LOCK_NB))
	{
		if (tTd(56, 2))
			sm_dprintf("mci_lock_host: couldn't get lock on %s\n",
				fname);
		(void) sm_io_close(mci->mci_statfile, SM_TIME_DEFAULT);
		mci->mci_statfile = NULL;
		retVal = EX_TEMPFAIL;
		goto cleanup;
	}

	if (tTd(56, 12) && mci->mci_statfile != NULL)
		sm_dprintf("mci_lock_host: Sanity check -- lock is good\n");

cleanup:
	errno = save_errno;
	return retVal;
}
/*
**  MCI_UNLOCK_HOST -- unlock host
**
**	Clean up the lock on a host, close the file, let
**	someone else use it.
**
**	Parameters:
**		mci -- us.
**
**	Returns:
**		nothing.
*/

void
mci_unlock_host(mci)
	MCI *mci;
{
	int save_errno = errno;

	if (mci == NULL)
	{
		if (tTd(56, 1))
			sm_dprintf("mci_unlock_host: NULL mci\n");
		return;
	}

	if (HostStatDir == NULL || mci->mci_host == NULL)
		return;

	if (!SingleThreadDelivery && mci_lock_host_statfile(mci) == EX_TEMPFAIL)
	{
		if (tTd(56, 1))
			sm_dprintf("mci_unlock_host: stat file already locked\n");
	}
	else
	{
		if (tTd(56, 2))
			sm_dprintf("mci_unlock_host: store prior to unlock\n");
		mci_store_persistent(mci);
	}

	if (mci->mci_statfile != NULL)
	{
		(void) sm_io_close(mci->mci_statfile, SM_TIME_DEFAULT);
		mci->mci_statfile = NULL;
	}

	errno = save_errno;
}
/*
**  MCI_LOAD_PERSISTENT -- load persistent host info
**
**	Load information about host that is kept
**	in common for all running sendmails.
**
**	Parameters:
**		mci -- the host/connection to load persistent info for.
**
**	Returns:
**		true -- lock was successful
**		false -- lock failed
*/

static bool
mci_load_persistent(mci)
	MCI *mci;
{
	int save_errno = errno;
	bool locked = true;
	SM_FILE_T *fp;
	char fname[MAXPATHLEN];

	if (mci == NULL)
	{
		if (tTd(56, 1))
			sm_dprintf("mci_load_persistent: NULL mci\n");
		return true;
	}

	if (IgnoreHostStatus || HostStatDir == NULL || mci->mci_host == NULL)
		return true;

	/* Already have the persistent information in memory */
	if (SingleThreadDelivery && mci->mci_statfile != NULL)
		return true;

	if (tTd(56, 1))
		sm_dprintf("mci_load_persistent: Attempting to load persistent information for %s\n",
			   mci->mci_host);

	if (mci_generate_persistent_path(mci->mci_host, fname, sizeof(fname),
					 false) < 0)
	{
		/* Not much we can do if the file isn't there... */
		if (tTd(56, 1))
			sm_dprintf("mci_load_persistent: Couldn't generate host path\n");
		goto cleanup;
	}

	fp = safefopen(fname, O_RDONLY, FileMode,
		       SFF_NOLOCK|SFF_NOLINK|SFF_OPENASROOT|SFF_REGONLY|SFF_SAFEDIRPATH);
	if (fp == NULL)
	{
		/* I can't think of any reason this should ever happen */
		if (tTd(56, 1))
			sm_dprintf("mci_load_persistent: open(%s): %s\n",
				fname, sm_errstring(errno));
		goto cleanup;
	}

	FileName = fname;
	locked = lockfile(sm_io_getinfo(fp, SM_IO_WHAT_FD, NULL), fname, "",
			  LOCK_SH|LOCK_NB);
	if (locked)
	{
		(void) mci_read_persistent(fp, mci);
		(void) lockfile(sm_io_getinfo(fp, SM_IO_WHAT_FD, NULL), fname,
				"", LOCK_UN);
	}
	FileName = NULL;
	(void) sm_io_close(fp, SM_TIME_DEFAULT);

cleanup:
	errno = save_errno;
	return locked;
}
/*
**  MCI_READ_PERSISTENT -- read persistent host status file
**
**	Parameters:
**		fp -- the file pointer to read.
**		mci -- the pointer to fill in.
**
**	Returns:
**		-1 -- if the file was corrupt.
**		0 -- otherwise.
**
**	Warning:
**		This code makes the assumption that this data
**		will be read in an atomic fashion, and that the data
**		was written in an atomic fashion.  Any other functioning
**		may lead to some form of insanity.  This should be
**		perfectly safe due to underlying stdio buffering.
*/

static int
mci_read_persistent(fp, mci)
	SM_FILE_T *fp;
	register MCI *mci;
{
	int ver;
	register char *p;
	int saveLineNumber = LineNumber;
	char buf[MAXLINE];

	if (fp == NULL)
	{
		syserr("mci_read_persistent: NULL fp");
		/* NOTREACHED */
		return -1;
	}
	if (mci == NULL)
	{
		syserr("mci_read_persistent: NULL mci");
		/* NOTREACHED */
		return -1;
	}
	if (tTd(56, 93))
	{
		sm_dprintf("mci_read_persistent: fp=%lx, mci=",
			   (unsigned long) fp);
	}

	SM_FREE_CLR(mci->mci_status);
	SM_FREE_CLR(mci->mci_rstatus);

	sm_io_rewind(fp, SM_TIME_DEFAULT);
	ver = -1;
	LineNumber = 0;
	while (sm_io_fgets(fp, SM_TIME_DEFAULT, buf, sizeof(buf)) >= 0)
	{
		LineNumber++;
		p = strchr(buf, '\n');
		if (p != NULL)
			*p = '\0';
		switch (buf[0])
		{
		  case 'V':		/* version stamp */
			ver = atoi(&buf[1]);
			if (ver < 0 || ver > 0)
				syserr("Unknown host status version %d: %d max",
					ver, 0);
			break;

		  case 'E':		/* UNIX error number */
			mci->mci_errno = atoi(&buf[1]);
			break;

		  case 'H':		/* DNS error number */
			mci->mci_herrno = atoi(&buf[1]);
			break;

		  case 'S':		/* UNIX exit status */
			mci->mci_exitstat = atoi(&buf[1]);
			break;

		  case 'D':		/* DSN status */
			mci->mci_status = newstr(&buf[1]);
			break;

		  case 'R':		/* SMTP status */
			mci->mci_rstatus = newstr(&buf[1]);
			break;

		  case 'U':		/* last usage time */
			mci->mci_lastuse = atol(&buf[1]);
			break;

		  case '.':		/* end of file */
			if (tTd(56, 93))
				mci_dump(sm_debug_file(), mci, false);
			return 0;

		  default:
			sm_syslog(LOG_CRIT, NOQID,
				  "%s: line %d: Unknown host status line \"%s\"",
				  FileName == NULL ? mci->mci_host : FileName,
				  LineNumber, buf);
			LineNumber = saveLineNumber;
			return -1;
		}
	}
	LineNumber = saveLineNumber;
	if (tTd(56, 93))
		sm_dprintf("incomplete (missing dot for EOF)\n");
	if (ver < 0)
		return -1;
	return 0;
}
/*
**  MCI_STORE_PERSISTENT -- Store persistent MCI information
**
**	Store information about host that is kept
**	in common for all running sendmails.
**
**	Parameters:
**		mci -- the host/connection to store persistent info for.
**
**	Returns:
**		none.
*/

void
mci_store_persistent(mci)
	MCI *mci;
{
	int save_errno = errno;

	if (mci == NULL)
	{
		if (tTd(56, 1))
			sm_dprintf("mci_store_persistent: NULL mci\n");
		return;
	}

	if (HostStatDir == NULL || mci->mci_host == NULL)
		return;

	if (tTd(56, 1))
		sm_dprintf("mci_store_persistent: Storing information for %s\n",
			   mci->mci_host);

	if (mci->mci_statfile == NULL)
	{
		if (tTd(56, 1))
			sm_dprintf("mci_store_persistent: no statfile\n");
		return;
	}

	sm_io_rewind(mci->mci_statfile, SM_TIME_DEFAULT);
#if !NOFTRUNCATE
	(void) ftruncate(sm_io_getinfo(mci->mci_statfile, SM_IO_WHAT_FD, NULL),
			 (off_t) 0);
#endif /* !NOFTRUNCATE */

	(void) sm_io_fprintf(mci->mci_statfile, SM_TIME_DEFAULT, "V0\n");
	(void) sm_io_fprintf(mci->mci_statfile, SM_TIME_DEFAULT, "E%d\n",
			     mci->mci_errno);
	(void) sm_io_fprintf(mci->mci_statfile, SM_TIME_DEFAULT, "H%d\n",
			     mci->mci_herrno);
	(void) sm_io_fprintf(mci->mci_statfile, SM_TIME_DEFAULT, "S%d\n",
			     mci->mci_exitstat);
	if (mci->mci_status != NULL)
		(void) sm_io_fprintf(mci->mci_statfile, SM_TIME_DEFAULT,
				     "D%.80s\n",
				     denlstring(mci->mci_status, true, false));
	if (mci->mci_rstatus != NULL)
		(void) sm_io_fprintf(mci->mci_statfile, SM_TIME_DEFAULT,
				     "R%.80s\n",
				     denlstring(mci->mci_rstatus, true, false));
	(void) sm_io_fprintf(mci->mci_statfile, SM_TIME_DEFAULT, "U%ld\n",
			     (long)(mci->mci_lastuse));
	(void) sm_io_fprintf(mci->mci_statfile, SM_TIME_DEFAULT, ".\n");

	(void) sm_io_flush(mci->mci_statfile, SM_TIME_DEFAULT);

	errno = save_errno;
	return;
}
/*
**  MCI_TRAVERSE_PERSISTENT -- walk persistent status tree
**
**	Recursively find all the mci host files in `pathname'.  Default to
**		main host status directory if no path is provided.
**	Call (*action)(pathname, host) for each file found.
**
**	Note: all information is collected in a list before it is processed.
**	This may not be the best way to do it, but it seems safest, since
**	the file system would be touched while we are attempting to traverse
**	the directory tree otherwise (during purges).
**
**	Parameters:
**		action -- function to call on each node.  If returns < 0,
**			return immediately.
**		pathname -- root of tree.  If null, use main host status
**			directory.
**
**	Returns:
**		< 0 -- if any action routine returns a negative value, that
**			value is returned.
**		0 -- if we successfully went to completion.
**		> 0 -- return status from action()
*/

int
mci_traverse_persistent(action, pathname)
	int (*action)__P((char *, char *));
	char *pathname;
{
	struct stat statbuf;
	DIR *d;
	int ret;

	if (pathname == NULL)
		pathname = HostStatDir;
	if (pathname == NULL)
		return -1;

	if (tTd(56, 1))
		sm_dprintf("mci_traverse: pathname is %s\n", pathname);

	ret = stat(pathname, &statbuf);
	if (ret < 0)
	{
		if (tTd(56, 2))
			sm_dprintf("mci_traverse: Failed to stat %s: %s\n",
				pathname, sm_errstring(errno));
		return ret;
	}
	if (S_ISDIR(statbuf.st_mode))
	{
		bool leftone, removedone;
		size_t len;
		char *newptr;
		struct dirent *e;
		char newpath[MAXPATHLEN];
#if MAXPATHLEN <= MAXNAMLEN - 3
 ERROR "MAXPATHLEN <= MAXNAMLEN - 3"
#endif /* MAXPATHLEN  <= MAXNAMLEN - 3 */

		if ((d = opendir(pathname)) == NULL)
		{
			if (tTd(56, 2))
				sm_dprintf("mci_traverse: opendir %s: %s\n",
					pathname, sm_errstring(errno));
			return -1;
		}

		/*
		**  Reserve space for trailing '/', at least one
		**  character, and '\0'
		*/

		len = sizeof(newpath) - 3;
		if (sm_strlcpy(newpath, pathname, len) >= len)
		{
			int save_errno = errno;

			if (tTd(56, 2))
				sm_dprintf("mci_traverse: path \"%s\" too long",
					pathname);
			(void) closedir(d);
			errno = save_errno;
			return -1;
		}
		newptr = newpath + strlen(newpath);
		*newptr++ = '/';
		len = sizeof(newpath) - (newptr - newpath);

		/*
		**  repeat until no file has been removed
		**  this may become ugly when several files "expire"
		**  during these loops, but it's better than doing
		**  a rewinddir() inside the inner loop
		*/

		do
		{
			leftone = removedone = false;
			while ((e = readdir(d)) != NULL)
			{
				if (e->d_name[0] == '.')
					continue;

				if (sm_strlcpy(newptr, e->d_name, len) >= len)
				{
					/* Skip truncated copies */
					if (tTd(56, 4))
					{
						*newptr = '\0';
						sm_dprintf("mci_traverse: path \"%s%s\" too long",
							   newpath, e->d_name);
					}
					continue;
				}

				if (StopRequest)
					stop_sendmail();
				ret = mci_traverse_persistent(action, newpath);
				if (ret < 0)
					break;
				if (ret == 1)
					leftone = true;
				if (!removedone && ret == 0 &&
				    action == mci_purge_persistent)
					removedone = true;
			}
			if (ret < 0)
				break;

			/*
			**  The following appears to be
			**  necessary during purges, since
			**  we modify the directory structure
			*/

			if (removedone)
				rewinddir(d);
			if (tTd(56, 40))
				sm_dprintf("mci_traverse: path %s: ret %d removed %d left %d\n",
					pathname, ret, removedone, leftone);
		} while (removedone);

		/* purge (or whatever) the directory proper */
		if (!leftone)
		{
			*--newptr = '\0';
			ret = (*action)(newpath, NULL);
		}
		(void) closedir(d);
	}
	else if (S_ISREG(statbuf.st_mode))
	{
		char *end = pathname + strlen(pathname) - 1;
		char *start;
		char *scan;
		char host[MAXHOSTNAMELEN];
		char *hostptr = host;

		/*
		**  Reconstruct the host name from the path to the
		**  persistent information.
		*/

		do
		{
			if (hostptr != host)
				*(hostptr++) = '.';
			start = end;
			while (start > pathname && *(start - 1) != '/')
				start--;

			if (*end == '.')
				end--;

			for (scan = start; scan <= end; scan++)
				*(hostptr++) = *scan;

			end = start - 2;
		} while (end > pathname && *end == '.');

		*hostptr = '\0';

		/*
		**  Do something with the file containing the persistent
		**  information.
		*/

		ret = (*action)(pathname, host);
	}

	return ret;
}
/*
**  MCI_PRINT_PERSISTENT -- print persistent info
**
**	Dump the persistent information in the file 'pathname'
**
**	Parameters:
**		pathname -- the pathname to the status file.
**		hostname -- the corresponding host name.
**
**	Returns:
**		0
*/

int
mci_print_persistent(pathname, hostname)
	char *pathname;
	char *hostname;
{
	static bool initflag = false;
	SM_FILE_T *fp;
	int width = Verbose ? 78 : 25;
	bool locked;
	MCI mcib;

	/* skip directories */
	if (hostname == NULL)
		return 0;

	if (StopRequest)
		stop_sendmail();

	if (!initflag)
	{
		initflag = true;
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     " -------------- Hostname --------------- How long ago ---------Results---------\n");
	}

	fp = safefopen(pathname, O_RDONLY, FileMode,
		       SFF_NOLOCK|SFF_NOLINK|SFF_OPENASROOT|SFF_REGONLY|SFF_SAFEDIRPATH);

	if (fp == NULL)
	{
		if (tTd(56, 1))
			sm_dprintf("mci_print_persistent: cannot open %s: %s\n",
				pathname, sm_errstring(errno));
		return 0;
	}

	FileName = pathname;
	memset(&mcib, '\0', sizeof(mcib));
	if (mci_read_persistent(fp, &mcib) < 0)
	{
		syserr("%s: could not read status file", pathname);
		(void) sm_io_close(fp, SM_TIME_DEFAULT);
		FileName = NULL;
		return 0;
	}

	locked = !lockfile(sm_io_getinfo(fp, SM_IO_WHAT_FD, NULL), pathname,
			   "", LOCK_SH|LOCK_NB);
	(void) sm_io_close(fp, SM_TIME_DEFAULT);
	FileName = NULL;

	(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%c%-39s %12s ",
			     locked ? '*' : ' ', hostname,
			     pintvl(curtime() - mcib.mci_lastuse, true));
	if (mcib.mci_rstatus != NULL)
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%.*s\n", width,
				     mcib.mci_rstatus);
	else if (mcib.mci_exitstat == EX_TEMPFAIL && mcib.mci_errno != 0)
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Deferred: %.*s\n", width - 10,
				     sm_errstring(mcib.mci_errno));
	else if (mcib.mci_exitstat != 0)
	{
		char *exmsg = sm_sysexmsg(mcib.mci_exitstat);

		if (exmsg == NULL)
		{
			char buf[80];

			(void) sm_snprintf(buf, sizeof(buf),
				"Unknown mailer error %d",
				mcib.mci_exitstat);
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%.*s\n",
					     width, buf);
		}
		else
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%.*s\n",
					     width, &exmsg[5]);
	}
	else if (mcib.mci_errno == 0)
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "OK\n");
	else
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "OK: %.*s\n",
				     width - 4, sm_errstring(mcib.mci_errno));

	return 0;
}
/*
**  MCI_PURGE_PERSISTENT -- Remove a persistence status file.
**
**	Parameters:
**		pathname -- path to the status file.
**		hostname -- name of host corresponding to that file.
**			NULL if this is a directory (domain).
**
**	Returns:
**		0 -- ok
**		1 -- file not deleted (too young, incorrect format)
**		< 0 -- some error occurred
*/

int
mci_purge_persistent(pathname, hostname)
	char *pathname;
	char *hostname;
{
	struct stat statbuf;
	char *end = pathname + strlen(pathname) - 1;
	int ret;

	if (tTd(56, 1))
		sm_dprintf("mci_purge_persistent: purging %s\n", pathname);

	ret = stat(pathname, &statbuf);
	if (ret < 0)
	{
		if (tTd(56, 2))
			sm_dprintf("mci_purge_persistent: Failed to stat %s: %s\n",
				pathname, sm_errstring(errno));
		return ret;
	}
	if (curtime() - statbuf.st_mtime <= MciInfoTimeout)
		return 1;
	if (hostname != NULL)
	{
		/* remove the file */
		ret = unlink(pathname);
		if (ret < 0)
		{
			if (LogLevel > 8)
				sm_syslog(LOG_ERR, NOQID,
					  "mci_purge_persistent: failed to unlink %s: %s",
					  pathname, sm_errstring(errno));
			if (tTd(56, 2))
				sm_dprintf("mci_purge_persistent: failed to unlink %s: %s\n",
					pathname, sm_errstring(errno));
			return ret;
		}
	}
	else
	{
		/* remove the directory */
		if (*end != '.')
			return 1;

		if (tTd(56, 1))
			sm_dprintf("mci_purge_persistent: dpurge %s\n", pathname);

		ret = rmdir(pathname);
		if (ret < 0)
		{
			if (tTd(56, 2))
				sm_dprintf("mci_purge_persistent: rmdir %s: %s\n",
					pathname, sm_errstring(errno));
			return ret;
		}
	}

	return 0;
}
/*
**  MCI_GENERATE_PERSISTENT_PATH -- generate path from hostname
**
**	Given `host', convert from a.b.c to $HostStatDir/c./b./a,
**	putting the result into `path'.  if `createflag' is set, intervening
**	directories will be created as needed.
**
**	Parameters:
**		host -- host name to convert from.
**		path -- place to store result.
**		pathlen -- length of path buffer.
**		createflag -- if set, create intervening directories as
**			needed.
**
**	Returns:
**		0 -- success
**		-1 -- failure
*/

static int
mci_generate_persistent_path(host, path, pathlen, createflag)
	const char *host;
	char *path;
	int pathlen;
	bool createflag;
{
	char *elem, *p, *x, ch;
	int ret = 0;
	int len;
	char t_host[MAXHOSTNAMELEN];
#if NETINET6
	struct in6_addr in6_addr;
#endif /* NETINET6 */

	/*
	**  Rationality check the arguments.
	*/

	if (host == NULL)
	{
		syserr("mci_generate_persistent_path: null host");
		return -1;
	}
	if (path == NULL)
	{
		syserr("mci_generate_persistent_path: null path");
		return -1;
	}

	if (tTd(56, 80))
		sm_dprintf("mci_generate_persistent_path(%s): ", host);

	if (*host == '\0' || *host == '.')
		return -1;

	/* make certain this is not a bracketed host number */
	if (strlen(host) > sizeof(t_host) - 1)
		return -1;
	if (host[0] == '[')
		(void) sm_strlcpy(t_host, host + 1, sizeof(t_host));
	else
		(void) sm_strlcpy(t_host, host, sizeof(t_host));

	/*
	**  Delete any trailing dots from the hostname.
	**  Leave 'elem' pointing at the \0.
	*/

	elem = t_host + strlen(t_host);
	while (elem > t_host &&
	       (elem[-1] == '.' || (host[0] == '[' && elem[-1] == ']')))
		*--elem = '\0';

	/* check for bogus bracketed address */
	if (host[0] == '[')
	{
		bool good = false;
# if NETINET6
		if (anynet_pton(AF_INET6, t_host, &in6_addr) == 1)
			good = true;
# endif /* NETINET6 */
# if NETINET
		if (inet_addr(t_host) != INADDR_NONE)
			good = true;
# endif /* NETINET */
		if (!good)
			return -1;
	}

	/* check for what will be the final length of the path */
	len = strlen(HostStatDir) + 2;
	for (p = (char *) t_host; *p != '\0'; p++)
	{
		if (*p == '.')
			len++;
		len++;
		if (p[0] == '.' && p[1] == '.')
			return -1;
	}
	if (len > pathlen || len < 1)
		return -1;
	(void) sm_strlcpy(path, HostStatDir, pathlen);
	p = path + strlen(path);
	while (elem > t_host)
	{
		if (!path_is_dir(path, createflag))
		{
			ret = -1;
			break;
		}
		elem--;
		while (elem >= t_host && *elem != '.')
			elem--;
		*p++ = '/';
		x = elem + 1;
		while ((ch = *x++) != '\0' && ch != '.')
		{
			if (isascii(ch) && isupper(ch))
				ch = tolower(ch);
			if (ch == '/')
				ch = ':';	/* / -> : */
			*p++ = ch;
		}
		if (elem >= t_host)
			*p++ = '.';
		*p = '\0';
	}
	if (tTd(56, 80))
	{
		if (ret < 0)
			sm_dprintf("FAILURE %d\n", ret);
		else
			sm_dprintf("SUCCESS %s\n", path);
	}
	return ret;
}
@


1.21
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.20
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2005, 2010 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: mci.c,v 8.224 2013/03/12 15:24:53 ca Exp $")
@


1.19
log
@Update to sendmail 8.14.5
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: mci.c,v 8.223 2010/03/10 04:35:28 ca Exp $")
d975 1
a975 1
	while (sm_io_fgets(fp, SM_TIME_DEFAULT, buf, sizeof(buf)) != NULL)
@


1.18
log
@Update to sendmail-8.14.3
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2005 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: mci.c,v 8.221 2007/11/13 23:44:25 gshapiro Exp $")
d291 26
d596 1
@


1.17
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: mci.c,v 8.218 2006/08/15 23:24:57 ca Exp $")
d1146 7
a1152 1
		len = sizeof(newpath) - MAXNAMLEN - 3;
d1155 2
d1160 2
d1166 1
d1183 11
a1193 3
				(void) sm_strlcpy(newptr, e->d_name,
					       sizeof(newpath) -
					       (newptr - newpath));
@


1.16
log
@Update to sendmail-8.13.8
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: mci.c,v 8.217 2006/04/18 01:27:36 ca Exp $")
d143 2
a144 2
		MciCache = (MCI **) sm_pmalloc_x(MaxMciCache * sizeof *MciCache);
		memset((char *) MciCache, '\0', MaxMciCache * sizeof *MciCache);
d312 1
a312 1
	memset(&CurHostAddr, '\0', sizeof CurHostAddr);
d377 1
a377 1
			SOCKADDR_LEN_T socklen = sizeof CurHostAddr;
d467 1
a467 1
		mci = (MCI *) sm_malloc_x(sizeof *mci);
d469 2
a470 2
		mci = (MCI *) sm_rpool_malloc_x(rpool, sizeof *mci);
	memset((char *) mci, '\0', sizeof *mci);
d729 1
a729 1
	if (mci_generate_persistent_path(mci->mci_host, fname, sizeof fname,
d859 1
a859 1
	if (mci_generate_persistent_path(mci->mci_host, fname, sizeof fname,
d948 1
a948 1
	while (sm_io_fgets(fp, SM_TIME_DEFAULT, buf, sizeof buf) != NULL)
d1173 1
a1173 1
					       sizeof newpath -
d1303 1
a1303 1
	memset(&mcib, '\0', sizeof mcib);
d1335 1
a1335 1
			(void) sm_snprintf(buf, sizeof buf,
d1482 1
a1482 1
	if (strlen(host) > sizeof t_host - 1)
d1485 1
a1485 1
		(void) sm_strlcpy(t_host, host + 1, sizeof t_host);
d1487 1
a1487 1
		(void) sm_strlcpy(t_host, host, sizeof t_host);
@


1.15
log
@Update to sendmail 8.13.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: mci.c,v 8.216 2005/07/12 22:27:44 ca Exp $")
d925 1
d927 3
d931 1
d933 3
@


1.14
log
@update to sendmail 8.13.4
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: mci.c,v 8.214 2005/02/04 22:01:45 ca Exp $")
d50 3
a52 5
**	We actually try any cached connections by sending a NOOP
**	before we use them; if the NOOP fails we close down the
**	connection and reopen it.  Note that this means that a
**	server SMTP that doesn't support NOOP will hose the
**	algorithm -- but that doesn't seem too likely.
d1127 3
@


1.13
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: mci.c,v 8.212 2004/08/04 21:11:31 ca Exp $")
d401 51
@


1.12
log
@Update to sendmail.8.13.0
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: mci.c,v 8.211 2003/03/31 17:35:50 ca Exp $")
d1048 1
a1048 1
	int (*action)();
@


1.11
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: mci.c,v 8.205.2.4 2003/03/31 17:35:27 ca Exp $")
d490 1
d533 2
a534 1
mci_dump(mci, logit)
d602 1
a602 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s\n", buf);
d608 1
d617 2
a618 1
mci_dump_all(logit)
d627 1
a627 1
		mci_dump(MciCache[i], logit);
d932 1
a932 1
				mci_dump(mci, false);
@


1.10
log
@Update to Sendmail 8.12.8; fixes a buffer overflow in the envelope
comments processing which may allow an attacker to gain root privileges.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: mci.c,v 8.205.2.3 2003/01/07 03:56:19 ca Exp $")
d551 10
d565 1
a565 1
		*p++ = '<';
d1165 1
a1165 1
			while (*(start - 1) != '/')
d1175 1
a1175 1
		} while (*end == '.');
d1365 1
a1365 1
**	Given `host', convert from a.b.c to $QueueDir/.hoststat/c./b./a,
@


1.9
log
@update to sendmail 8.12.7
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: mci.c,v 8.205.2.2 2002/11/26 19:15:19 gshapiro Exp $")
a1246 1
	{
a1248 1
	}
@


1.8
log
@Update to sendmail-8.12.4
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: mci.c,v 8.205 2002/05/24 18:53:48 gshapiro Exp $")
d1247 1
d1250 1
@


1.7
log
@update to sendmail 8.12.3
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: mci.c,v 8.204 2002/02/22 18:24:57 ca Exp $")
d657 1
a657 1
	char fname[MAXPATHLEN + 1];
d776 1
a776 1
	char fname[MAXPATHLEN + 1];
d1063 1
a1063 1
		char newpath[MAXPATHLEN + 1];
@


1.6
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: mci.c,v 8.202 2001/11/05 22:12:17 ca Exp $")
d160 1
a160 1
		if ((mci->mci_lastuse + MciCacheTimeout < now ||
d391 1
a391 1
		if (now > mci->mci_lastuse + MciInfoTimeout)
a512 1
	{ MCIF_MULTSTAT,	"MULTSTAT"	},
d1313 1
a1313 1
	if (curtime() - statbuf.st_mtime < MciInfoTimeout)
@


1.5
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: mci.c,v 8.200 2001/09/21 20:01:42 ca Exp $")
a869 1
		mci_dump(mci, false);
d918 2
d932 2
d1319 2
a1320 1
		if (unlink(pathname) < 0)
d1322 4
d1329 1
d1341 2
a1342 1
		if (rmdir(pathname) < 0)
d1347 1
a1348 1

@


1.4
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: mci.c,v 8.196 2001/09/04 22:43:04 ca Exp $")
d64 1
a64 1
/*
d117 1
a117 1
/*
d180 1
a180 1
/*
d265 1
a265 1
/*
d293 1
a293 1
/*
d401 1
a401 1
/*
d426 1
a426 1
/*
d454 1
a454 1
/*
d486 1
a486 1
/*
d593 1
a593 1
/*
d616 1
a616 1
/*
d707 1
a707 1
/*
d756 1
a756 1
/*
d833 1
a833 1
/*
d935 1
a935 1
/*
d1005 1
a1005 1
/*
d1177 1
a1177 1
/*
d1237 1
a1237 1
			   "", LOCK_EX|LOCK_NB);
d1277 1
a1277 1
/*
d1343 1
a1343 1
/*
@


1.3
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@a13 4
#ifndef lint
static char id[] = "@@(#)$Sendmail: mci.c,v 8.133.10.8 2001/05/03 17:24:10 gshapiro Exp $";
#endif /* ! lint */

d16 1
d29 1
a29 1
static int	mci_read_persistent __P((FILE *, MCI *));
d103 1
a103 1
		mci_uncache(mcislot, TRUE);
d106 2
a107 3
		dprintf("mci_cache: caching %lx (%s) in slot %d\n",
			(u_long) mci, mci->mci_host,
			(int)(mcislot - MciCache));
d111 2
a112 1
			  (u_long) mci, mci->mci_host, mcislot - MciCache);
d145 1
a145 1
		MciCache = (MCI **) xalloc(MaxMciCache * sizeof *MciCache);
d170 1
a170 1
			mci_uncache(bestmci, TRUE);
d187 2
a188 2
**		doquit -- if TRUE, send QUIT protocol on this connection.
**			  if FALSE, we are assumed to be in a forked child;
d213 3
a215 3
		dprintf("mci_uncache: uncaching %lx (%s) from slot %d (%d)\n",
			(u_long) mci, mci->mci_host,
			(int)(mcislot - MciCache), doquit);
d219 2
a220 2
			  (u_long) mci, mci->mci_host,
			  mcislot - MciCache, doquit);
a222 1
#if SMTP
d232 1
a232 1
# ifdef XLA
d234 1
a234 1
# endif /* XLA */
a236 1
#endif /* SMTP */
d239 1
a239 1
			(void) fclose(mci->mci_in);
d241 1
a241 1
			(void) fclose(mci->mci_out);
d247 16
d269 2
a270 2
**		doquit -- if TRUE, send QUIT protocol.
**			  if FALSE, just close the connection.
d295 7
a310 2

#if DAEMON
a314 1
#endif /* DAEMON */
d325 13
d339 1
a339 1
	**  We don't need to load the peristent data if we have data
d348 1
a348 1
			dprintf("mci_get(%s %s): lock failed\n",
d358 1
a358 1
		dprintf("mci_get(%s %s): mci_state=%d, _flags=%lx, _exitstat=%d, _errno=%d\n",
a362 1
#if SMTP
a374 1
# if DAEMON
d377 1
a377 1
			/* get peer host address for logging reasons only */
d381 2
a382 1
			(void) getpeername(fileno(mci->mci_in),
a384 1
# endif /* DAEMON */
a385 1
#endif /* SMTP */
d402 25
d428 7
d446 1
a446 1
		return FALSE;
d449 1
a449 1
		return FALSE;
d452 1
a452 3
	if (mci->mci_state == MCIS_OPEN)
		return TRUE;
	return FALSE;
d478 5
a482 3
	mci->mci_status = dstat;
	if (mci->mci_rstatus != NULL)
		sm_free(mci->mci_rstatus);
d484 1
a484 2
		rstat = newstr(rstat);
	mci->mci_rstatus = rstat;
a506 1
	{ MCIF_TEMP,		"TEMP"		},
d520 9
a531 1

d543 1
a543 1
	snprintf(p, SPACELEFT(buf, p), "MCI@@%lx: ", (u_long) mci);
d547 1
a547 1
		snprintf(p, SPACELEFT(buf, p), "NULL");
d550 1
a550 1
	snprintf(p, SPACELEFT(buf, p), "flags=%lx", mci->mci_flags);
d561 2
a562 1
			snprintf(p, SPACELEFT(buf, p), "%s,", f->mcif_name);
d567 3
a569 1
	snprintf(p, SPACELEFT(buf, p),
d574 1
a574 1
	snprintf(p, SPACELEFT(buf, p),
d576 1
a576 2
		mci->mci_maxsize,
		mci->mci_phase == NULL ? "NULL" : mci->mci_phase,
d580 1
a580 1
	snprintf(p, SPACELEFT(buf, p),
d582 1
a582 3
		mci->mci_status == NULL ? "NULL" : mci->mci_status,
		mci->mci_rstatus == NULL ? "NULL" : mci->mci_rstatus,
		sep);
d584 1
a584 1
	snprintf(p, SPACELEFT(buf, p),
d586 1
a586 2
		mci->mci_host == NULL ? "NULL" : mci->mci_host,
		ctime(&mci->mci_lastuse));
d591 1
a591 1
		printf("%s\n", buf);
d624 1
a624 1
**	remote hosts -- i.e.: one connection to a give
d642 1
a642 1
			dprintf("mci_lock_host: NULL mci\n");
d664 2
a665 2
		dprintf("mci_lock_host: attempting to lock %s\n",
			mci->mci_host);
d667 2
a668 1
	if (mci_generate_persistent_path(mci->mci_host, fname, sizeof fname, TRUE) < 0)
d672 2
a673 2
			dprintf("mci_lock_host: Failed to generate host path for %s\n",
				mci->mci_host);
d684 1
a684 2
		syserr("mci_lock_host: cannot create host lock file %s",
			       fname);
d688 2
a689 1
	if (!lockfile(fileno(mci->mci_statfile), fname, "", LOCK_EX|LOCK_NB))
d692 1
a692 1
			dprintf("mci_lock_host: couldn't get lock on %s\n",
d694 1
a694 1
		(void) fclose(mci->mci_statfile);
d701 1
a701 1
		dprintf("mci_lock_host: Sanity check -- lock is good\n");
d729 1
a729 1
			dprintf("mci_unlock_host: NULL mci\n");
d739 1
a739 1
			dprintf("mci_unlock_host: stat file already locked\n");
d744 1
a744 2
			dprintf("mci_unlock_host: store prior to unlock\n");

d750 1
a750 1
		(void) fclose(mci->mci_statfile);
d763 1
a763 2
**		mci -- the host/connection to load persistent info
**			   for.
d766 2
a767 2
**		TRUE -- lock was successful
**		FALSE -- lock failed
d775 2
a776 2
	bool locked = TRUE;
	FILE *fp;
d782 2
a783 2
			dprintf("mci_load_persistent: NULL mci\n");
		return TRUE;
d787 1
a787 1
		return TRUE;
d791 1
a791 1
		return TRUE;
d794 2
a795 2
		dprintf("mci_load_persistent: Attempting to load persistent information for %s\n",
			mci->mci_host);
d797 2
a798 1
	if (mci_generate_persistent_path(mci->mci_host, fname, sizeof fname, FALSE) < 0)
d802 1
a802 1
			dprintf("mci_load_persistent: Couldn't generate host path\n");
d812 2
a813 2
			dprintf("mci_load_persistent: open(%s): %s\n",
				fname, errstring(errno));
d818 2
a819 1
	locked = lockfile(fileno(fp), fname, "", LOCK_SH|LOCK_NB);
d823 2
a824 1
		(void) lockfile(fileno(fp), fname, "", LOCK_UN);
d827 1
a827 1
	(void) fclose(fp);
d854 1
a854 1
	FILE *fp;
d868 3
a870 2
		dprintf("mci_read_persistent: fp=%lx, mci=", (u_long) fp);
		mci_dump(mci, FALSE);
d873 2
a874 4
	mci->mci_status = NULL;
	if (mci->mci_rstatus != NULL)
		sm_free(mci->mci_rstatus);
	mci->mci_rstatus = NULL;
d876 1
a876 1
	rewind(fp);
d879 1
a879 1
	while (fgets(buf, sizeof buf, fp) != NULL)
d957 1
a957 1
			dprintf("mci_store_persistent: NULL mci\n");
d965 2
a966 2
		dprintf("mci_store_persistent: Storing information for %s\n",
			mci->mci_host);
d971 1
a971 1
			dprintf("mci_store_persistent: no statfile\n");
d975 1
a975 1
	rewind(mci->mci_statfile);
d977 2
a978 1
	(void) ftruncate(fileno(mci->mci_statfile), (off_t) 0);
d981 7
a987 4
	fprintf(mci->mci_statfile, "V0\n");
	fprintf(mci->mci_statfile, "E%d\n", mci->mci_errno);
	fprintf(mci->mci_statfile, "H%d\n", mci->mci_herrno);
	fprintf(mci->mci_statfile, "S%d\n", mci->mci_exitstat);
d989 3
a991 2
		fprintf(mci->mci_statfile, "D%.80s\n",
			denlstring(mci->mci_status, TRUE, FALSE));
d993 6
a998 4
		fprintf(mci->mci_statfile, "R%.80s\n",
			denlstring(mci->mci_rstatus, TRUE, FALSE));
	fprintf(mci->mci_statfile, "U%ld\n", (long)(mci->mci_lastuse));
	fprintf(mci->mci_statfile, ".\n");
d1000 1
a1000 1
	(void) fflush(mci->mci_statfile);
d1045 1
a1045 1
		dprintf("mci_traverse: pathname is %s\n", pathname);
d1051 2
a1052 2
			dprintf("mci_traverse: Failed to stat %s: %s\n",
				pathname, errstring(errno));
d1057 3
a1060 1
		char *newptr;
a1061 1
		bool leftone, removedone;
d1066 2
a1067 2
				dprintf("mci_traverse: opendir %s: %s\n",
					pathname, errstring(errno));
d1070 2
a1071 2

		if (strlen(pathname) >= sizeof newpath - MAXNAMLEN - 3)
d1074 1
a1074 1
				dprintf("mci_traverse: path \"%s\" too long",
a1077 1
		(void) strlcpy(newpath, pathname, sizeof newpath);
d1087 1
d1090 1
a1090 1
			leftone = removedone = FALSE;
d1096 1
a1096 1
				(void) strlcpy(newptr, e->d_name,
d1106 1
a1106 1
					leftone = TRUE;
d1109 1
a1109 1
					removedone = TRUE;
d1113 1
d1119 1
d1123 1
a1123 1
				dprintf("mci_traverse: path %s: ret %d removed %d left %d\n",
d1171 1
d1195 2
a1196 2
	static int initflag = FALSE;
	FILE *fp;
d1210 3
a1212 2
		initflag = TRUE;
		printf(" -------------- Hostname --------------- How long ago ---------Results---------\n");
d1215 1
a1215 1
	fp = safefopen(pathname, O_RDWR, FileMode,
d1221 2
a1222 2
			dprintf("mci_print_persistent: cannot open %s: %s\n",
				pathname, errstring(errno));
d1231 1
a1231 1
		(void) fclose(fp);
d1236 3
a1238 2
	locked = !lockfile(fileno(fp), pathname, "", LOCK_EX|LOCK_NB);
	(void) fclose(fp);
d1241 3
a1243 3
	printf("%c%-39s %12s ",
		locked ? '*' : ' ', hostname,
		pintvl(curtime() - mcib.mci_lastuse, TRUE));
d1245 2
a1246 1
		printf("%.*s\n", width, mcib.mci_rstatus);
d1248 3
a1250 1
		printf("Deferred: %.*s\n", width - 10, errstring(mcib.mci_errno));
d1253 1
a1253 3
		int i = mcib.mci_exitstat - EX__BASE;
		extern int N_SysEx;
		extern char *SysExMsg[];
d1255 1
a1255 1
		if (i < 0 || i >= N_SysEx)
d1259 2
a1260 1
			snprintf(buf, sizeof buf, "Unknown mailer error %d",
d1262 2
a1263 1
			printf("%.*s\n", width, buf);
d1266 2
a1267 1
			printf("%.*s\n", width, &(SysExMsg[i])[5]);
d1270 1
a1270 1
		printf("OK\n");
d1272 2
a1273 1
		printf("OK: %.*s\n", width - 4, errstring(mcib.mci_errno));
d1301 1
a1301 1
		dprintf("mci_purge_persistent: purging %s\n", pathname);
d1307 2
a1308 2
			dprintf("mci_purge_persistent: Failed to stat %s: %s\n",
				pathname, errstring(errno));
d1319 2
a1320 2
				dprintf("mci_purge_persistent: failed to unlink %s: %s\n",
					pathname, errstring(errno));
d1330 1
a1330 1
			dprintf("mci_purge_persistent: dpurge %s\n", pathname);
d1335 2
a1336 2
				dprintf("mci_purge_persistent: rmdir %s: %s\n",
					pathname, errstring(errno));
d1393 1
a1393 1
		dprintf("mci_generate_persistent_path(%s): ", host);
d1402 1
a1402 1
		(void) strlcpy(t_host, host + 1, sizeof t_host);
d1404 1
a1404 1
		(void) strlcpy(t_host, host, sizeof t_host);
a1415 1
#if NETINET || NETINET6
d1417 3
a1419 1
	if (host[0] == '['
d1421 2
a1422 1
	    && inet_pton(AF_INET6, t_host, &in6_addr) != 1
d1425 2
a1426 1
	    && inet_addr(t_host) == INADDR_NONE
d1428 3
a1430 3
	    )
		return -1;
#endif /* NETINET || NETINET6 */
d1444 1
a1444 2

	(void) strlcpy(path, HostStatDir, pathlen);
a1445 1

a1469 1

d1473 1
a1473 1
			dprintf("FAILURE %d\n", ret);
d1475 1
a1475 1
			dprintf("SUCCESS %s\n", path);
a1476 1

@


1.2
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: mci.c,v 8.133.10.7 2000/12/12 00:39:34 ca Exp $";
d425 1
a425 1
		free(mci->mci_rstatus);
d810 1
a810 1
		free(mci->mci_rstatus);
d1029 2
d1130 3
@


1.2.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: mci.c,v 8.133.10.8 2001/05/03 17:24:10 gshapiro Exp $";
d425 1
a425 1
		sm_free(mci->mci_rstatus);
d810 1
a810 1
		sm_free(mci->mci_rstatus);
a1028 2
				if (StopRequest)
					stop_sendmail();
a1127 3

	if (StopRequest)
		stop_sendmail();
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: mci.c,v 8.133 2000/01/18 01:19:07 ca Exp $";
d19 2
d24 1
d277 1
d280 1
d305 1
a305 1
		syserr("negative mno %d (%s)", m->m_mno, m->m_name);
d388 1
a388 1
	if (m->m_mno < 0)
d465 1
a465 1
	{ 0,			NULL }
d957 1
d1201 1
a1201 1
**		1 -- file too young to be deleted
d1241 1
a1241 1
			return 0;
d1332 1
a1332 1
	if (host[0] == '[' &&
d1334 1
a1334 1
	    inet_pton(AF_INET6, t_host, &in6_addr) != 1 &&
d1337 1
a1337 1
	    inet_addr(t_host) == INADDR_NONE
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.1.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: mci.c,v 8.133.10.8 2001/05/03 17:24:10 gshapiro Exp $";
a18 2


a21 1

a273 1
	{
a275 1
	}
d300 1
a300 1
		syserr("!negative mno %d (%s)", m->m_mno, m->m_name);
d383 1
a383 1
	if (m->m_mno < 0 || m->m_mno > MAXMAILERS)
d420 1
a420 1
		sm_free(mci->mci_rstatus);
d460 1
a460 1
	{ 0,			NULL		}
d805 1
a805 1
		sm_free(mci->mci_rstatus);
a951 1
**		> 0 -- return status from action()
a1022 2
				if (StopRequest)
					stop_sendmail();
a1122 3
	if (StopRequest)
		stop_sendmail();

d1195 1
a1195 1
**		1 -- file not deleted (too young, incorrect format)
d1235 1
a1235 1
			return 1;
d1326 1
a1326 1
	if (host[0] == '['
d1328 1
a1328 1
	    && inet_pton(AF_INET6, t_host, &in6_addr) != 1
d1331 1
a1331 1
	    && inet_addr(t_host) == INADDR_NONE
@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Id: mci.c,v 8.133.10.7 2000/12/12 00:39:34 ca Exp $";
a18 2


a21 1

a273 1
	{
a275 1
	}
d300 1
a300 1
		syserr("!negative mno %d (%s)", m->m_mno, m->m_name);
d383 1
a383 1
	if (m->m_mno < 0 || m->m_mno > MAXMAILERS)
d460 1
a460 1
	{ 0,			NULL		}
a951 1
**		> 0 -- return status from action()
d1195 1
a1195 1
**		1 -- file not deleted (too young, incorrect format)
d1235 1
a1235 1
			return 1;
d1326 1
a1326 1
	if (host[0] == '['
d1328 1
a1328 1
	    && inet_pton(AF_INET6, t_host, &in6_addr) != 1
d1331 1
a1331 1
	    && inet_addr(t_host) == INADDR_NONE
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d14 4
a19 1
SM_RCSID("@@(#)$Sendmail: mci.c,v 8.196 2001/09/04 22:43:04 ca Exp $")
d32 1
a32 1
static int	mci_read_persistent __P((SM_FILE_T *, MCI *));
d106 1
a106 1
		mci_uncache(mcislot, true);
d109 3
a111 2
		sm_dprintf("mci_cache: caching %p (%s) in slot %d\n",
			   mci, mci->mci_host, (int) (mcislot - MciCache));
d115 1
a115 2
			  (unsigned long) mci, mci->mci_host,
			  (int) (mcislot - MciCache));
d148 1
a148 1
		MciCache = (MCI **) sm_pmalloc_x(MaxMciCache * sizeof *MciCache);
d173 1
a173 1
			mci_uncache(bestmci, true);
d190 2
a191 2
**		doquit -- if true, send QUIT protocol on this connection.
**			  if false, we are assumed to be in a forked child;
d216 3
a218 3
		sm_dprintf("mci_uncache: uncaching %p (%s) from slot %d (%d)\n",
			   mci, mci->mci_host, (int) (mcislot - MciCache),
			   doquit);
d222 2
a223 2
			  (unsigned long) mci, mci->mci_host,
			  (int) (mcislot - MciCache), doquit);
d226 1
d236 1
a236 1
#if XLA
d238 1
a238 1
#endif /* XLA */
d241 1
d244 1
a244 1
			(void) sm_io_close(mci->mci_in, SM_TIME_DEFAULT);
d246 1
a246 1
			(void) sm_io_close(mci->mci_out, SM_TIME_DEFAULT);
a251 16

		mci->mci_retryrcpt = false;
		mci->mci_tolist = NULL;
#if PIPELINING
		mci->mci_okrcpts = 0;
#endif /* PIPELINING */
	}

	SM_FREE_CLR(mci->mci_status);
	SM_FREE_CLR(mci->mci_rstatus);
	SM_FREE_CLR(mci->mci_heloname);
	if (mci->mci_rpool != NULL)
	{
		sm_rpool_free(mci->mci_rpool);
		mci->mci_macro.mac_rpool = NULL;
		mci->mci_rpool = NULL;
d258 2
a259 2
**		doquit -- if true, send QUIT protocol.
**			  if false, just close the connection.
a283 7
**
**	Parameters:
**		host -- host to look for.
**		m -- mailer.
**
**	Returns:
**		mci for this host (might be new).
d293 2
d299 1
a309 13
	/* initialize per-message data */
	mci->mci_retryrcpt = false;
	mci->mci_tolist = NULL;
#if PIPELINING
	mci->mci_okrcpts = 0;
#endif /* PIPELINING */

	if (mci->mci_rpool == NULL)
		mci->mci_rpool = sm_rpool_new_x(NULL);

	if (mci->mci_macro.mac_rpool == NULL)
		mci->mci_macro.mac_rpool = mci->mci_rpool;

d311 1
a311 1
	**  We don't need to load the persistent data if we have data
d320 1
a320 1
			sm_dprintf("mci_get(%s %s): lock failed\n",
d330 1
a330 1
		sm_dprintf("mci_get(%s %s): mci_state=%d, _flags=%lx, _exitstat=%d, _errno=%d\n",
d335 1
d348 1
d351 1
a351 1
			/* get peer host address */
d355 1
a355 2
			(void) getpeername(sm_io_getinfo(mci->mci_in,
							 SM_IO_WHAT_FD, NULL),
d358 1
d360 1
a376 25
**  MCI_NEW -- allocate new MCI structure
**
**	Parameters:
**		rpool -- if non-NULL: allocate from that rpool.
**
**	Returns:
**		mci (new).
*/

MCI *
mci_new(rpool)
	SM_RPOOL_T *rpool;
{
	register MCI *mci;

	if (rpool == NULL)
		mci = (MCI *) sm_malloc_x(sizeof *mci);
	else
		mci = (MCI *) sm_rpool_malloc_x(rpool, sizeof *mci);
	memset((char *) mci, '\0', sizeof *mci);
	mci->mci_rpool = sm_rpool_new_x(NULL);
	mci->mci_macro.mac_rpool = mci->mci_rpool;
	return mci;
}
/*
a377 7
**
**	Parameters:
**		host -- host to look for.
**		m -- mailer.
**
**	Returns:
**		true iff open connection exists.
d389 1
a389 1
		return false;
d392 1
a392 1
		return false;
d395 3
a397 1
	return mci->mci_state == MCIS_OPEN;
d423 3
a425 5
	SM_FREE_CLR(mci->mci_status);
	if (dstat != NULL)
		mci->mci_status = sm_strdup_x(dstat);

	SM_FREE_CLR(mci->mci_rstatus);
d427 2
a428 1
		mci->mci_rstatus = sm_strdup_x(rstat);
d451 1
a464 9
	{ MCIF_AUTH,		"AUTH"		},
	{ MCIF_AUTHACT,		"AUTHACT"	},
	{ MCIF_ENHSTAT,		"ENHSTAT"	},
	{ MCIF_PIPELINED,	"PIPELINED"	},
#if STARTTLS
	{ MCIF_TLS,		"TLS"		},
	{ MCIF_TLSACT,		"TLSACT"	},
#endif /* STARTTLS */
	{ MCIF_DLVR_BY,		"DLVR_BY"	},
d468 1
d480 1
a480 1
	(void) sm_snprintf(p, SPACELEFT(buf, p), "MCI@@%p: ", mci);
d484 1
a484 1
		(void) sm_snprintf(p, SPACELEFT(buf, p), "NULL");
d487 1
a487 1
	(void) sm_snprintf(p, SPACELEFT(buf, p), "flags=%lx", mci->mci_flags);
d498 1
a498 2
			(void) sm_strlcpyn(p, SPACELEFT(buf, p), 2,
					   f->mcif_name, ",");
d503 1
a503 3

	/* Note: sm_snprintf() takes care of NULL arguments for %s */
	(void) sm_snprintf(p, SPACELEFT(buf, p),
d508 1
a508 1
	(void) sm_snprintf(p, SPACELEFT(buf, p),
d510 2
a511 1
		mci->mci_maxsize, mci->mci_phase,
d515 1
a515 1
	(void) sm_snprintf(p, SPACELEFT(buf, p),
d517 3
a519 1
		mci->mci_status, mci->mci_rstatus, sep);
d521 1
a521 1
	(void) sm_snprintf(p, SPACELEFT(buf, p),
d523 2
a524 1
		mci->mci_host, ctime(&mci->mci_lastuse));
d529 1
a529 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s\n", buf);
d562 1
a562 1
**	remote hosts -- i.e.: one connection to a given
d580 1
a580 1
			sm_dprintf("mci_lock_host: NULL mci\n");
d602 2
a603 2
		sm_dprintf("mci_lock_host: attempting to lock %s\n",
			   mci->mci_host);
d605 1
a605 2
	if (mci_generate_persistent_path(mci->mci_host, fname, sizeof fname,
					 true) < 0)
d609 2
a610 2
			sm_dprintf("mci_lock_host: Failed to generate host path for %s\n",
				   mci->mci_host);
d621 2
a622 1
		syserr("mci_lock_host: cannot create host lock file %s", fname);
d626 1
a626 2
	if (!lockfile(sm_io_getinfo(mci->mci_statfile, SM_IO_WHAT_FD, NULL),
		      fname, "", LOCK_EX|LOCK_NB))
d629 1
a629 1
			sm_dprintf("mci_lock_host: couldn't get lock on %s\n",
d631 1
a631 1
		(void) sm_io_close(mci->mci_statfile, SM_TIME_DEFAULT);
d638 1
a638 1
		sm_dprintf("mci_lock_host: Sanity check -- lock is good\n");
d666 1
a666 1
			sm_dprintf("mci_unlock_host: NULL mci\n");
d676 1
a676 1
			sm_dprintf("mci_unlock_host: stat file already locked\n");
d681 2
a682 1
			sm_dprintf("mci_unlock_host: store prior to unlock\n");
d688 1
a688 1
		(void) sm_io_close(mci->mci_statfile, SM_TIME_DEFAULT);
d701 2
a702 1
**		mci -- the host/connection to load persistent info for.
d705 2
a706 2
**		true -- lock was successful
**		false -- lock failed
d714 2
a715 2
	bool locked = true;
	SM_FILE_T *fp;
d721 2
a722 2
			sm_dprintf("mci_load_persistent: NULL mci\n");
		return true;
d726 1
a726 1
		return true;
d730 1
a730 1
		return true;
d733 2
a734 2
		sm_dprintf("mci_load_persistent: Attempting to load persistent information for %s\n",
			   mci->mci_host);
d736 1
a736 2
	if (mci_generate_persistent_path(mci->mci_host, fname, sizeof fname,
					 false) < 0)
d740 1
a740 1
			sm_dprintf("mci_load_persistent: Couldn't generate host path\n");
d750 2
a751 2
			sm_dprintf("mci_load_persistent: open(%s): %s\n",
				fname, sm_errstring(errno));
d756 1
a756 2
	locked = lockfile(sm_io_getinfo(fp, SM_IO_WHAT_FD, NULL), fname, "",
			  LOCK_SH|LOCK_NB);
d760 1
a760 2
		(void) lockfile(sm_io_getinfo(fp, SM_IO_WHAT_FD, NULL), fname,
				"", LOCK_UN);
d763 1
a763 1
	(void) sm_io_close(fp, SM_TIME_DEFAULT);
d790 1
a790 1
	SM_FILE_T *fp;
d804 2
a805 3
		sm_dprintf("mci_read_persistent: fp=%lx, mci=",
			   (unsigned long) fp);
		mci_dump(mci, false);
d808 4
a811 2
	SM_FREE_CLR(mci->mci_status);
	SM_FREE_CLR(mci->mci_rstatus);
d813 1
a813 1
	sm_io_rewind(fp, SM_TIME_DEFAULT);
d816 1
a816 1
	while (sm_io_fgets(fp, SM_TIME_DEFAULT, buf, sizeof buf) != NULL)
d894 1
a894 1
			sm_dprintf("mci_store_persistent: NULL mci\n");
d902 2
a903 2
		sm_dprintf("mci_store_persistent: Storing information for %s\n",
			   mci->mci_host);
d908 1
a908 1
			sm_dprintf("mci_store_persistent: no statfile\n");
d912 1
a912 1
	sm_io_rewind(mci->mci_statfile, SM_TIME_DEFAULT);
d914 1
a914 2
	(void) ftruncate(sm_io_getinfo(mci->mci_statfile, SM_IO_WHAT_FD, NULL),
			 (off_t) 0);
d917 4
a920 7
	(void) sm_io_fprintf(mci->mci_statfile, SM_TIME_DEFAULT, "V0\n");
	(void) sm_io_fprintf(mci->mci_statfile, SM_TIME_DEFAULT, "E%d\n",
			     mci->mci_errno);
	(void) sm_io_fprintf(mci->mci_statfile, SM_TIME_DEFAULT, "H%d\n",
			     mci->mci_herrno);
	(void) sm_io_fprintf(mci->mci_statfile, SM_TIME_DEFAULT, "S%d\n",
			     mci->mci_exitstat);
d922 2
a923 3
		(void) sm_io_fprintf(mci->mci_statfile, SM_TIME_DEFAULT,
				     "D%.80s\n",
				     denlstring(mci->mci_status, true, false));
d925 4
a928 6
		(void) sm_io_fprintf(mci->mci_statfile, SM_TIME_DEFAULT,
				     "R%.80s\n",
				     denlstring(mci->mci_rstatus, true, false));
	(void) sm_io_fprintf(mci->mci_statfile, SM_TIME_DEFAULT, "U%ld\n",
			     (long)(mci->mci_lastuse));
	(void) sm_io_fprintf(mci->mci_statfile, SM_TIME_DEFAULT, ".\n");
d930 1
a930 1
	(void) sm_io_flush(mci->mci_statfile, SM_TIME_DEFAULT);
d975 1
a975 1
		sm_dprintf("mci_traverse: pathname is %s\n", pathname);
d981 2
a982 2
			sm_dprintf("mci_traverse: Failed to stat %s: %s\n",
				pathname, sm_errstring(errno));
d987 1
a987 2
		bool leftone, removedone;
		size_t len;
a988 1
		struct dirent *e;
d990 1
d995 2
a996 2
				sm_dprintf("mci_traverse: opendir %s: %s\n",
					pathname, sm_errstring(errno));
d999 2
a1000 2
		len = sizeof(newpath) - MAXNAMLEN - 3;
		if (sm_strlcpy(newpath, pathname, len) >= len)
d1003 1
a1003 1
				sm_dprintf("mci_traverse: path \"%s\" too long",
d1007 1
a1016 1

d1019 1
a1019 1
			leftone = removedone = false;
d1025 1
a1025 1
				(void) sm_strlcpy(newptr, e->d_name,
a1028 2
				if (StopRequest)
					stop_sendmail();
d1033 1
a1033 1
					leftone = true;
d1036 1
a1036 1
					removedone = true;
a1039 1

a1044 1

d1048 1
a1048 1
				sm_dprintf("mci_traverse: path %s: ret %d removed %d left %d\n",
a1095 1

d1119 2
a1120 2
	static bool initflag = false;
	SM_FILE_T *fp;
a1128 3
	if (StopRequest)
		stop_sendmail();

d1131 2
a1132 3
		initflag = true;
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     " -------------- Hostname --------------- How long ago ---------Results---------\n");
d1135 1
a1135 1
	fp = safefopen(pathname, O_RDONLY, FileMode,
d1141 2
a1142 2
			sm_dprintf("mci_print_persistent: cannot open %s: %s\n",
				pathname, sm_errstring(errno));
d1151 1
a1151 1
		(void) sm_io_close(fp, SM_TIME_DEFAULT);
d1156 2
a1157 3
	locked = !lockfile(sm_io_getinfo(fp, SM_IO_WHAT_FD, NULL), pathname,
			   "", LOCK_EX|LOCK_NB);
	(void) sm_io_close(fp, SM_TIME_DEFAULT);
d1160 3
a1162 3
	(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%c%-39s %12s ",
			     locked ? '*' : ' ', hostname,
			     pintvl(curtime() - mcib.mci_lastuse, true));
d1164 1
a1164 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%.*s\n", width,
				     mcib.mci_rstatus);
d1166 1
a1166 3
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Deferred: %.*s\n", width - 10,
				     sm_errstring(mcib.mci_errno));
d1169 3
a1171 1
		char *exmsg = sm_sysexmsg(mcib.mci_exitstat);
d1173 1
a1173 1
		if (exmsg == NULL)
d1177 1
a1177 2
			(void) sm_snprintf(buf, sizeof buf,
				"Unknown mailer error %d",
d1179 1
a1179 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%.*s\n",
					     width, buf);
d1182 1
a1182 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%.*s\n",
					     width, &exmsg[5]);
d1185 1
a1185 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "OK\n");
d1187 1
a1187 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "OK: %.*s\n",
				     width - 4, sm_errstring(mcib.mci_errno));
d1215 1
a1215 1
		sm_dprintf("mci_purge_persistent: purging %s\n", pathname);
d1221 2
a1222 2
			sm_dprintf("mci_purge_persistent: Failed to stat %s: %s\n",
				pathname, sm_errstring(errno));
d1233 2
a1234 2
				sm_dprintf("mci_purge_persistent: failed to unlink %s: %s\n",
					pathname, sm_errstring(errno));
d1244 1
a1244 1
			sm_dprintf("mci_purge_persistent: dpurge %s\n", pathname);
d1249 2
a1250 2
				sm_dprintf("mci_purge_persistent: rmdir %s: %s\n",
					pathname, sm_errstring(errno));
d1307 1
a1307 1
		sm_dprintf("mci_generate_persistent_path(%s): ", host);
d1316 1
a1316 1
		(void) sm_strlcpy(t_host, host + 1, sizeof t_host);
d1318 1
a1318 1
		(void) sm_strlcpy(t_host, host, sizeof t_host);
d1330 1
d1332 1
a1332 3
	if (host[0] == '[')
	{
		bool good = false;
d1334 1
a1334 2
		if (anynet_pton(AF_INET6, t_host, &in6_addr) == 1)
			good = true;
d1337 1
a1337 2
		if (inet_addr(t_host) != INADDR_NONE)
			good = true;
d1339 3
a1341 3
		if (!good)
			return -1;
	}
d1355 2
a1356 1
	(void) sm_strlcpy(path, HostStatDir, pathlen);
d1358 1
d1383 1
d1387 1
a1387 1
			sm_dprintf("FAILURE %d\n", ret);
d1389 1
a1389 1
			sm_dprintf("SUCCESS %s\n", path);
d1391 1
@


