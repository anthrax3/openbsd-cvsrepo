head	1.31;
access;
symbols
	OPENBSD_5_6:1.30.0.6
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.28.0.2
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.27.0.6
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.4
	OPENBSD_5_0:1.27.0.2
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.26.0.10
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.8
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.4
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.6
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.2
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.24.0.4
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.20.0.4
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2014.09.17.18.49.52;	author matthieu;	state dead;
branches;
next	1.30;
commitid	M7i5giHIoz3DMlTU;

1.30
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.28;

1.28
date	2012.12.26.11.44.12;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2011.05.17.15.54.23;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2008.09.04.11.57.56;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.04.14.43.48;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2006.08.13.13.01.48;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.22.18.43.55;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.08.16.00.51;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.16.00.21.30;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2004.09.18.04.08.34;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2004.06.24.03.59.27;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.09.17.17.31.40;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.01.19.59.23;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.15.02.23.36;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.26.04.48.55;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.03.17.25.47;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.18.00.49.28;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.10.01.17.18.30;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.21.16.31.45;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.01.01.01.41;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.29.01.31.15;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.28.02.43.54;	author millert;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.01.15.21.09.08;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.07.19.20.41;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.46;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.46;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.15;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.50;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.31.36;	author miod;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.31.01.47.57;	author jason;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2008 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1992, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>

SM_RCSID("@@(#)$Sendmail: map.c,v 8.713 2013/11/22 20:51:55 ca Exp $")

#if LDAPMAP
# include <sm/ldap.h>
#endif /* LDAPMAP */

#if NDBM
# include <ndbm.h>
# ifdef R_FIRST
  ERROR README:	You are running the Berkeley DB version of ndbm.h.  See
  ERROR README:	the README file about tweaking Berkeley DB so it can
  ERROR README:	coexist with NDBM, or delete -DNDBM from the Makefile
  ERROR README: and use -DNEWDB instead.
# endif /* R_FIRST */
#endif /* NDBM */
#if NEWDB
# include "sm/bdb.h"
#endif /* NEWDB */
#if NIS
  struct dom_binding;	/* forward reference needed on IRIX */
# include <rpcsvc/ypclnt.h>
# if NDBM
#  define NDBM_YP_COMPAT	/* create YP-compatible NDBM files */
# endif /* NDBM */
#endif /* NIS */

#include "map.h"

#if NEWDB
# if DB_VERSION_MAJOR < 2
static bool	db_map_open __P((MAP *, int, char *, DBTYPE, const void *));
# endif /* DB_VERSION_MAJOR < 2 */
# if DB_VERSION_MAJOR == 2
static bool	db_map_open __P((MAP *, int, char *, DBTYPE, DB_INFO *));
# endif /* DB_VERSION_MAJOR == 2 */
# if DB_VERSION_MAJOR > 2
static bool	db_map_open __P((MAP *, int, char *, DBTYPE, void **));
# endif /* DB_VERSION_MAJOR > 2 */
#endif /* NEWDB */
static bool	extract_canonname __P((char *, char *, char *, char[], int));
static void	map_close __P((STAB *, int));
static void	map_init __P((STAB *, int));
#ifdef LDAPMAP
static STAB *	ldapmap_findconn __P((SM_LDAP_STRUCT *));
#endif /* LDAPMAP */
#if NISPLUS
static bool	nisplus_getcanonname __P((char *, int, int *));
#endif /* NISPLUS */
#if NIS
static bool	nis_getcanonname __P((char *, int, int *));
#endif /* NIS */
#if NETINFO
static bool	ni_getcanonname __P((char *, int, int *));
#endif /* NETINFO */
static bool	text_getcanonname __P((char *, int, int *));
#if SOCKETMAP
static STAB	*socket_map_findconn __P((const char*));

/* XXX arbitrary limit for sanity */
# define SOCKETMAP_MAXL 1000000
#endif /* SOCKETMAP */

/* default error message for trying to open a map in write mode */
#ifdef ENOSYS
# define SM_EMAPCANTWRITE	ENOSYS
#else /* ENOSYS */
# ifdef EFTYPE
#  define SM_EMAPCANTWRITE	EFTYPE
# else /* EFTYPE */
#  define SM_EMAPCANTWRITE	ENXIO
# endif /* EFTYPE */
#endif /* ENOSYS */

/*
**  MAP.C -- implementations for various map classes.
**
**	Each map class implements a series of functions:
**
**	bool map_parse(MAP *map, char *args)
**		Parse the arguments from the config file.  Return true
**		if they were ok, false otherwise.  Fill in map with the
**		values.
**
**	char *map_lookup(MAP *map, char *key, char **args, int *pstat)
**		Look up the key in the given map.  If found, do any
**		rewriting the map wants (including "args" if desired)
**		and return the value.  Set *pstat to the appropriate status
**		on error and return NULL.  Args will be NULL if called
**		from the alias routines, although this should probably
**		not be relied upon.  It is suggested you call map_rewrite
**		to return the results -- it takes care of null termination
**		and uses a dynamically expanded buffer as needed.
**
**	void map_store(MAP *map, char *key, char *value)
**		Store the key:value pair in the map.
**
**	bool map_open(MAP *map, int mode)
**		Open the map for the indicated mode.  Mode should
**		be either O_RDONLY or O_RDWR.  Return true if it
**		was opened successfully, false otherwise.  If the open
**		failed and the MF_OPTIONAL flag is not set, it should
**		also print an error.  If the MF_ALIAS bit is set
**		and this map class understands the @@:@@ convention, it
**		should call aliaswait() before returning.
**
**	void map_close(MAP *map)
**		Close the map.
**
**	This file also includes the implementation for getcanonname.
**	It is currently implemented in a pretty ad-hoc manner; it ought
**	to be more properly integrated into the map structure.
*/

#if O_EXLOCK && HASFLOCK && !BOGUS_O_EXCL
# define LOCK_ON_OPEN	1	/* we can open/create a locked file */
#else /* O_EXLOCK && HASFLOCK && !BOGUS_O_EXCL */
# define LOCK_ON_OPEN	0	/* no such luck -- bend over backwards */
#endif /* O_EXLOCK && HASFLOCK && !BOGUS_O_EXCL */

/*
**  MAP_PARSEARGS -- parse config line arguments for database lookup
**
**	This is a generic version of the map_parse method.
**
**	Parameters:
**		map -- the map being initialized.
**		ap -- a pointer to the args on the config line.
**
**	Returns:
**		true -- if everything parsed OK.
**		false -- otherwise.
**
**	Side Effects:
**		null terminates the filename; stores it in map
*/

bool
map_parseargs(map, ap)
	MAP *map;
	char *ap;
{
	register char *p = ap;

	/*
	**  There is no check whether there is really an argument,
	**  but that's not important enough to warrant extra code.
	*/

	map->map_mflags |= MF_TRY0NULL|MF_TRY1NULL;
	map->map_spacesub = SpaceSub;	/* default value */
	for (;;)
	{
		while (isascii(*p) && isspace(*p))
			p++;
		if (*p != '-')
			break;
		switch (*++p)
		{
		  case 'N':
			map->map_mflags |= MF_INCLNULL;
			map->map_mflags &= ~MF_TRY0NULL;
			break;

		  case 'O':
			map->map_mflags &= ~MF_TRY1NULL;
			break;

		  case 'o':
			map->map_mflags |= MF_OPTIONAL;
			break;

		  case 'f':
			map->map_mflags |= MF_NOFOLDCASE;
			break;

		  case 'm':
			map->map_mflags |= MF_MATCHONLY;
			break;

		  case 'A':
			map->map_mflags |= MF_APPEND;
			break;

		  case 'q':
			map->map_mflags |= MF_KEEPQUOTES;
			break;

		  case 'a':
			map->map_app = ++p;
			break;

		  case 'T':
			map->map_tapp = ++p;
			break;

		  case 'k':
			while (isascii(*++p) && isspace(*p))
				continue;
			map->map_keycolnm = p;
			break;

		  case 'v':
			while (isascii(*++p) && isspace(*p))
				continue;
			map->map_valcolnm = p;
			break;

		  case 'z':
			if (*++p != '\\')
				map->map_coldelim = *p;
			else
			{
				switch (*++p)
				{
				  case 'n':
					map->map_coldelim = '\n';
					break;

				  case 't':
					map->map_coldelim = '\t';
					break;

				  default:
					map->map_coldelim = '\\';
				}
			}
			break;

		  case 't':
			map->map_mflags |= MF_NODEFER;
			break;


		  case 'S':
			map->map_spacesub = *++p;
			break;

		  case 'D':
			map->map_mflags |= MF_DEFER;
			break;

		  default:
			syserr("Illegal option %c map %s", *p, map->map_mname);
			break;
		}
		while (*p != '\0' && !(isascii(*p) && isspace(*p)))
			p++;
		if (*p != '\0')
			*p++ = '\0';
	}
	if (map->map_app != NULL)
		map->map_app = newstr(map->map_app);
	if (map->map_tapp != NULL)
		map->map_tapp = newstr(map->map_tapp);
	if (map->map_keycolnm != NULL)
		map->map_keycolnm = newstr(map->map_keycolnm);
	if (map->map_valcolnm != NULL)
		map->map_valcolnm = newstr(map->map_valcolnm);

	if (*p != '\0')
	{
		map->map_file = p;
		while (*p != '\0' && !(isascii(*p) && isspace(*p)))
			p++;
		if (*p != '\0')
			*p++ = '\0';
		map->map_file = newstr(map->map_file);
	}

	while (*p != '\0' && isascii(*p) && isspace(*p))
		p++;
	if (*p != '\0')
		map->map_rebuild = newstr(p);

	if (map->map_file == NULL &&
	    !bitset(MCF_OPTFILE, map->map_class->map_cflags))
	{
		syserr("No file name for %s map %s",
			map->map_class->map_cname, map->map_mname);
		return false;
	}
	return true;
}
/*
**  MAP_REWRITE -- rewrite a database key, interpolating %n indications.
**
**	It also adds the map_app string.  It can be used as a utility
**	in the map_lookup method.
**
**	Parameters:
**		map -- the map that causes this.
**		s -- the string to rewrite, NOT necessarily null terminated.
**		slen -- the length of s.
**		av -- arguments to interpolate into buf.
**
**	Returns:
**		Pointer to rewritten result.  This is static data that
**		should be copied if it is to be saved!
*/

char *
map_rewrite(map, s, slen, av)
	register MAP *map;
	register const char *s;
	size_t slen;
	char **av;
{
	register char *bp;
	register char c;
	char **avp;
	register char *ap;
	size_t l;
	size_t len;
	static size_t buflen = 0;
	static char *buf = NULL;

	if (tTd(39, 1))
	{
		sm_dprintf("map_rewrite(%.*s), av =", (int) slen, s);
		if (av == NULL)
			sm_dprintf(" (nullv)");
		else
		{
			for (avp = av; *avp != NULL; avp++)
				sm_dprintf("\n\t%s", *avp);
		}
		sm_dprintf("\n");
	}

	/* count expected size of output (can safely overestimate) */
	l = len = slen;
	if (av != NULL)
	{
		const char *sp = s;

		while (l-- > 0 && (c = *sp++) != '\0')
		{
			if (c != '%')
				continue;
			if (l-- <= 0)
				break;
			c = *sp++;
			if (!(isascii(c) && isdigit(c)))
				continue;
			for (avp = av; --c >= '0' && *avp != NULL; avp++)
				continue;
			if (*avp == NULL)
				continue;
			len += strlen(*avp);
		}
	}
	if (map->map_app != NULL)
		len += strlen(map->map_app);
	if (buflen < ++len)
	{
		/* need to malloc additional space */
		buflen = len;
		if (buf != NULL)
			sm_free(buf);
		buf = sm_pmalloc_x(buflen);
	}

	bp = buf;
	if (av == NULL)
	{
		memmove(bp, s, slen);
		bp += slen;

		/* assert(len > slen); */
		len -= slen;
	}
	else
	{
		while (slen-- > 0 && (c = *s++) != '\0')
		{
			if (c != '%')
			{
  pushc:
				if (len-- <= 1)
				     break;
				*bp++ = c;
				continue;
			}
			if (slen-- <= 0 || (c = *s++) == '\0')
				c = '%';
			if (c == '%')
				goto pushc;
			if (!(isascii(c) && isdigit(c)))
			{
				if (len-- <= 1)
				     break;
				*bp++ = '%';
				goto pushc;
			}
			for (avp = av; --c >= '0' && *avp != NULL; avp++)
				continue;
			if (*avp == NULL)
				continue;

			/* transliterate argument into output string */
			for (ap = *avp; (c = *ap++) != '\0' && len > 0; --len)
				*bp++ = c;
		}
	}
	if (map->map_app != NULL && len > 0)
		(void) sm_strlcpy(bp, map->map_app, len);
	else
		*bp = '\0';
	if (tTd(39, 1))
		sm_dprintf("map_rewrite => %s\n", buf);
	return buf;
}
/*
**  INITMAPS -- rebuild alias maps
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
*/

void
initmaps()
{
#if XDEBUG
	checkfd012("entering initmaps");
#endif /* XDEBUG */
	stabapply(map_init, 0);
#if XDEBUG
	checkfd012("exiting initmaps");
#endif /* XDEBUG */
}
/*
**  MAP_INIT -- rebuild a map
**
**	Parameters:
**		s -- STAB entry: if map: try to rebuild
**		unused -- unused variable
**
**	Returns:
**		none.
**
**	Side Effects:
**		will close already open rebuildable map.
*/

/* ARGSUSED1 */
static void
map_init(s, unused)
	register STAB *s;
	int unused;
{
	register MAP *map;

	/* has to be a map */
	if (s->s_symtype != ST_MAP)
		return;

	map = &s->s_map;
	if (!bitset(MF_VALID, map->map_mflags))
		return;

	if (tTd(38, 2))
		sm_dprintf("map_init(%s:%s, %s)\n",
			map->map_class->map_cname == NULL ? "NULL" :
				map->map_class->map_cname,
			map->map_mname == NULL ? "NULL" : map->map_mname,
			map->map_file == NULL ? "NULL" : map->map_file);

	if (!bitset(MF_ALIAS, map->map_mflags) ||
	    !bitset(MCF_REBUILDABLE, map->map_class->map_cflags))
	{
		if (tTd(38, 3))
			sm_dprintf("\tnot rebuildable\n");
		return;
	}

	/* if already open, close it (for nested open) */
	if (bitset(MF_OPEN, map->map_mflags))
	{
		map->map_mflags |= MF_CLOSING;
		map->map_class->map_close(map);
		map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
	}

	(void) rebuildaliases(map, false);
	return;
}
/*
**  OPENMAP -- open a map
**
**	Parameters:
**		map -- map to open (it must not be open).
**
**	Returns:
**		whether open succeeded.
*/

bool
openmap(map)
	MAP *map;
{
	bool restore = false;
	bool savehold = HoldErrs;
	bool savequick = QuickAbort;
	int saveerrors = Errors;

	if (!bitset(MF_VALID, map->map_mflags))
		return false;

	/* better safe than sorry... */
	if (bitset(MF_OPEN, map->map_mflags))
		return true;

	/* Don't send a map open error out via SMTP */
	if ((OnlyOneError || QuickAbort) &&
	    (OpMode == MD_SMTP || OpMode == MD_DAEMON))
	{
		restore = true;
		HoldErrs = true;
		QuickAbort = false;
	}

	errno = 0;
	if (map->map_class->map_open(map, O_RDONLY))
	{
		if (tTd(38, 4))
			sm_dprintf("openmap()\t%s:%s %s: valid\n",
				map->map_class->map_cname == NULL ? "NULL" :
					map->map_class->map_cname,
				map->map_mname == NULL ? "NULL" :
					map->map_mname,
				map->map_file == NULL ? "NULL" :
					map->map_file);
		map->map_mflags |= MF_OPEN;
		map->map_pid = CurrentPid;
	}
	else
	{
		if (tTd(38, 4))
			sm_dprintf("openmap()\t%s:%s %s: invalid%s%s\n",
				map->map_class->map_cname == NULL ? "NULL" :
					map->map_class->map_cname,
				map->map_mname == NULL ? "NULL" :
					map->map_mname,
				map->map_file == NULL ? "NULL" :
					map->map_file,
				errno == 0 ? "" : ": ",
				errno == 0 ? "" : sm_errstring(errno));
		if (!bitset(MF_OPTIONAL, map->map_mflags))
		{
			extern MAPCLASS BogusMapClass;

			map->map_orgclass = map->map_class;
			map->map_class = &BogusMapClass;
			map->map_mflags |= MF_OPEN|MF_OPENBOGUS;
			map->map_pid = CurrentPid;
		}
		else
		{
			/* don't try again */
			map->map_mflags &= ~MF_VALID;
		}
	}

	if (restore)
	{
		Errors = saveerrors;
		HoldErrs = savehold;
		QuickAbort = savequick;
	}

	return bitset(MF_OPEN, map->map_mflags);
}
/*
**  CLOSEMAPS -- close all open maps opened by the current pid.
**
**	Parameters:
**		bogus -- only close bogus maps.
**
**	Returns:
**		none.
*/

void
closemaps(bogus)
	bool bogus;
{
	stabapply(map_close, bogus);
}
/*
**  MAP_CLOSE -- close a map opened by the current pid.
**
**	Parameters:
**		s -- STAB entry: if map: try to close
**		bogus -- only close bogus maps or MCF_NOTPERSIST maps.
**
**	Returns:
**		none.
*/

/* ARGSUSED1 */
static void
map_close(s, bogus)
	register STAB *s;
	int bogus;	/* int because of stabapply(), used as bool */
{
	MAP *map;
	extern MAPCLASS BogusMapClass;

	if (s->s_symtype != ST_MAP)
		return;

	map = &s->s_map;

	/*
	**  close the map iff:
	**  it is valid and open and opened by this process
	**  and (!bogus or it's a bogus map or it is not persistent)
	**  negate this: return iff
	**  it is not valid or it is not open or not opened by this process
	**  or (bogus and it's not a bogus map and it's not not-persistent)
	*/

	if (!bitset(MF_VALID, map->map_mflags) ||
	    !bitset(MF_OPEN, map->map_mflags) ||
	    bitset(MF_CLOSING, map->map_mflags) ||
	    map->map_pid != CurrentPid ||
	    (bogus && map->map_class != &BogusMapClass &&
	     !bitset(MCF_NOTPERSIST, map->map_class->map_cflags)))
		return;

	if (map->map_class == &BogusMapClass && map->map_orgclass != NULL &&
	    map->map_orgclass != &BogusMapClass)
		map->map_class = map->map_orgclass;
	if (tTd(38, 5))
		sm_dprintf("closemaps: closing %s (%s)\n",
			map->map_mname == NULL ? "NULL" : map->map_mname,
			map->map_file == NULL ? "NULL" : map->map_file);

	if (!bitset(MF_OPENBOGUS, map->map_mflags))
	{
		map->map_mflags |= MF_CLOSING;
		map->map_class->map_close(map);
	}
	map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_OPENBOGUS|MF_CLOSING);
}

#if defined(SUN_EXTENSIONS) && defined(SUN_INIT_DOMAIN)
extern int getdomainname();

/* this is mainly for backward compatibility in Sun environment */
static char *
sun_init_domain()
{
	/*
	**  Get the domain name from the kernel.
	**  If it does not start with a leading dot, then remove
	**  the first component.  Since leading dots are funny Unix
	**  files, we treat a leading "+" the same as a leading dot.
	**  Finally, force there to be at least one dot in the domain name
	**  (i.e. top-level domains are not allowed, like "com", must be
	**  something like "sun.com").
	*/

	char buf[MAXNAME];
	char *period, *autodomain;

	if (getdomainname(buf, sizeof buf) < 0)
		return NULL;

	if (buf[0] == '\0')
		return NULL;

	if (tTd(0, 20))
		printf("domainname = %s\n", buf);

	if (buf[0] == '+')
		buf[0] = '.';
	period = strchr(buf, '.');
	if (period == NULL)
		autodomain = buf;
	else
		autodomain = period + 1;
	if (strchr(autodomain, '.') == NULL)
		return newstr(buf);
	else
		return newstr(autodomain);
}
#endif /* SUN_EXTENSIONS && SUN_INIT_DOMAIN */

/*
**  GETCANONNAME -- look up name using service switch
**
**	Parameters:
**		host -- the host name to look up.
**		hbsize -- the size of the host buffer.
**		trymx -- if set, try MX records.
**		pttl -- pointer to return TTL (can be NULL).
**
**	Returns:
**		true -- if the host was found.
**		false -- otherwise.
*/

bool
getcanonname(host, hbsize, trymx, pttl)
	char *host;
	int hbsize;
	bool trymx;
	int *pttl;
{
	int nmaps;
	int mapno;
	bool found = false;
	bool got_tempfail = false;
	auto int status = EX_UNAVAILABLE;
	char *maptype[MAXMAPSTACK];
	short mapreturn[MAXMAPACTIONS];
#if defined(SUN_EXTENSIONS) && defined(SUN_INIT_DOMAIN)
	bool should_try_nis_domain = false;
	static char *nis_domain = NULL;
#endif

	nmaps = switch_map_find("hosts", maptype, mapreturn);
	if (pttl != 0)
		*pttl = SM_DEFAULT_TTL;
	for (mapno = 0; mapno < nmaps; mapno++)
	{
		int i;

		if (tTd(38, 20))
			sm_dprintf("getcanonname(%s), trying %s\n",
				host, maptype[mapno]);
		if (strcmp("files", maptype[mapno]) == 0)
		{
			found = text_getcanonname(host, hbsize, &status);
		}
#if NIS
		else if (strcmp("nis", maptype[mapno]) == 0)
		{
			found = nis_getcanonname(host, hbsize, &status);
# if defined(SUN_EXTENSIONS) && defined(SUN_INIT_DOMAIN)
			if (nis_domain == NULL)
				nis_domain = sun_init_domain();
# endif /* defined(SUN_EXTENSIONS) && defined(SUN_INIT_DOMAIN) */
		}
#endif /* NIS */
#if NISPLUS
		else if (strcmp("nisplus", maptype[mapno]) == 0)
		{
			found = nisplus_getcanonname(host, hbsize, &status);
# if defined(SUN_EXTENSIONS) && defined(SUN_INIT_DOMAIN)
			if (nis_domain == NULL)
				nis_domain = sun_init_domain();
# endif /* defined(SUN_EXTENSIONS) && defined(SUN_INIT_DOMAIN) */
		}
#endif /* NISPLUS */
#if NAMED_BIND
		else if (strcmp("dns", maptype[mapno]) == 0)
		{
			found = dns_getcanonname(host, hbsize, trymx, &status,							 pttl);
		}
#endif /* NAMED_BIND */
#if NETINFO
		else if (strcmp("netinfo", maptype[mapno]) == 0)
		{
			found = ni_getcanonname(host, hbsize, &status);
		}
#endif /* NETINFO */
		else
		{
			found = false;
			status = EX_UNAVAILABLE;
		}

		/*
		**  Heuristic: if $m is not set, we are running during system
		**  startup.  In this case, when a name is apparently found
		**  but has no dot, treat is as not found.  This avoids
		**  problems if /etc/hosts has no FQDN but is listed first
		**  in the service switch.
		*/

		if (found &&
		    (macvalue('m', CurEnv) != NULL || strchr(host, '.') != NULL))
			break;

#if defined(SUN_EXTENSIONS) && defined(SUN_INIT_DOMAIN)
		if (found)
			should_try_nis_domain = true;
		/* but don't break, as we need to try all methods first */
#endif /* defined(SUN_EXTENSIONS) && defined(SUN_INIT_DOMAIN) */

		/* see if we should continue */
		if (status == EX_TEMPFAIL)
		{
			i = MA_TRYAGAIN;
			got_tempfail = true;
		}
		else if (status == EX_NOTFOUND)
			i = MA_NOTFOUND;
		else
			i = MA_UNAVAIL;
		if (bitset(1 << mapno, mapreturn[i]))
			break;
	}

	if (found)
	{
		char *d;

		if (tTd(38, 20))
			sm_dprintf("getcanonname(%s), found\n", host);

		/*
		**  If returned name is still single token, compensate
		**  by tagging on $m.  This is because some sites set
		**  up their DNS or NIS databases wrong.
		*/

		if ((d = strchr(host, '.')) == NULL || d[1] == '\0')
		{
			d = macvalue('m', CurEnv);
			if (d != NULL &&
			    hbsize > (int) (strlen(host) + strlen(d) + 1))
			{
				if (host[strlen(host) - 1] != '.')
					(void) sm_strlcat2(host, ".", d,
							   hbsize);
				else
					(void) sm_strlcat(host, d, hbsize);
			}
			else
			{
#if defined(SUN_EXTENSIONS) && defined(SUN_INIT_DOMAIN)
				if (VendorCode == VENDOR_SUN &&
				    should_try_nis_domain)
				{
					goto try_nis_domain;
				}
#endif /* defined(SUN_EXTENSIONS) && defined(SUN_INIT_DOMAIN) */
				return false;
			}
		}
		return true;
	}

#if defined(SUN_EXTENSIONS) && defined(SUN_INIT_DOMAIN)
	if (VendorCode == VENDOR_SUN && should_try_nis_domain)
	{
  try_nis_domain:
		if (nis_domain != NULL &&
		    strlen(nis_domain) + strlen(host) + 1 < hbsize)
		{
			(void) sm_strlcat2(host, ".", nis_domain, hbsize);
			return true;
		}
	}
#endif /* defined(SUN_EXTENSIONS) && defined(SUN_INIT_DOMAIN) */

	if (tTd(38, 20))
		sm_dprintf("getcanonname(%s), failed, status=%d\n", host,
			status);

	if (got_tempfail)
		SM_SET_H_ERRNO(TRY_AGAIN);
	else
		SM_SET_H_ERRNO(HOST_NOT_FOUND);

	return false;
}
/*
**  EXTRACT_CANONNAME -- extract canonical name from /etc/hosts entry
**
**	Parameters:
**		name -- the name against which to match.
**		dot -- where to reinsert '.' to get FQDN
**		line -- the /etc/hosts line.
**		cbuf -- the location to store the result.
**		cbuflen -- the size of cbuf.
**
**	Returns:
**		true -- if the line matched the desired name.
**		false -- otherwise.
*/

static bool
extract_canonname(name, dot, line, cbuf, cbuflen)
	char *name;
	char *dot;
	char *line;
	char cbuf[];
	int cbuflen;
{
	int i;
	char *p;
	bool found = false;

	cbuf[0] = '\0';
	if (line[0] == '#')
		return false;

	for (i = 1; ; i++)
	{
		char nbuf[MAXNAME + 1];

		p = get_column(line, i, '\0', nbuf, sizeof(nbuf));
		if (p == NULL)
			break;
		if (*p == '\0')
			continue;
		if (cbuf[0] == '\0' ||
		    (strchr(cbuf, '.') == NULL && strchr(p, '.') != NULL))
		{
			(void) sm_strlcpy(cbuf, p, cbuflen);
		}
		if (sm_strcasecmp(name, p) == 0)
			found = true;
		else if (dot != NULL)
		{
			/* try looking for the FQDN as well */
			*dot = '.';
			if (sm_strcasecmp(name, p) == 0)
				found = true;
			*dot = '\0';
		}
	}
	if (found && strchr(cbuf, '.') == NULL)
	{
		/* try to add a domain on the end of the name */
		char *domain = macvalue('m', CurEnv);

		if (domain != NULL &&
		    strlen(domain) + (i = strlen(cbuf)) + 1 < (size_t) cbuflen)
		{
			p = &cbuf[i];
			*p++ = '.';
			(void) sm_strlcpy(p, domain, cbuflen - i - 1);
		}
	}
	return found;
}

/*
**  DNS modules
*/

#if NAMED_BIND
# if DNSMAP

#  include "sm_resolve.h"
#  if NETINET || NETINET6
#   include <arpa/inet.h>
#  endif /* NETINET || NETINET6 */

/*
**  DNS_MAP_OPEN -- stub to check proper value for dns map type
*/

bool
dns_map_open(map, mode)
	MAP *map;
	int mode;
{
	if (tTd(38,2))
		sm_dprintf("dns_map_open(%s, %d)\n", map->map_mname, mode);

	mode &= O_ACCMODE;
	if (mode != O_RDONLY)
	{
		/* issue a pseudo-error message */
		errno = SM_EMAPCANTWRITE;
		return false;
	}
	return true;
}

/*
**  DNS_MAP_PARSEARGS -- parse dns map definition args.
**
**	Parameters:
**		map -- pointer to MAP
**		args -- pointer to the args on the config line.
**
**	Returns:
**		true -- if everything parsed OK.
**		false -- otherwise.
*/

#define map_sizelimit	map_lockfd	/* overload field */

struct dns_map
{
	int dns_m_type;
};

bool
dns_map_parseargs(map,args)
	MAP *map;
	char *args;
{
	register char *p = args;
	struct dns_map *map_p;

	map_p = (struct dns_map *) xalloc(sizeof(*map_p));
	map_p->dns_m_type = -1;
	map->map_mflags |= MF_TRY0NULL|MF_TRY1NULL;

	for (;;)
	{
		while (isascii(*p) && isspace(*p))
			p++;
		if (*p != '-')
			break;
		switch (*++p)
		{
		  case 'N':
			map->map_mflags |= MF_INCLNULL;
			map->map_mflags &= ~MF_TRY0NULL;
			break;

		  case 'O':
			map->map_mflags &= ~MF_TRY1NULL;
			break;

		  case 'o':
			map->map_mflags |= MF_OPTIONAL;
			break;

		  case 'f':
			map->map_mflags |= MF_NOFOLDCASE;
			break;

		  case 'm':
			map->map_mflags |= MF_MATCHONLY;
			break;

		  case 'A':
			map->map_mflags |= MF_APPEND;
			break;

		  case 'q':
			map->map_mflags |= MF_KEEPQUOTES;
			break;

		  case 't':
			map->map_mflags |= MF_NODEFER;
			break;

		  case 'a':
			map->map_app = ++p;
			break;

		  case 'T':
			map->map_tapp = ++p;
			break;

		  case 'd':
			{
				char *h;

				++p;
				h = strchr(p, ' ');
				if (h != NULL)
					*h = '\0';
				map->map_timeout = convtime(p, 's');
				if (h != NULL)
					*h = ' ';
			}
			break;

		  case 'r':
			while (isascii(*++p) && isspace(*p))
				continue;
			map->map_retry = atoi(p);
			break;

		  case 'z':
			if (*++p != '\\')
				map->map_coldelim = *p;
			else
			{
				switch (*++p)
				{
				  case 'n':
					map->map_coldelim = '\n';
					break;

				  case 't':
					map->map_coldelim = '\t';
					break;

				  default:
					map->map_coldelim = '\\';
				}
			}
			break;

		  case 'Z':
			while (isascii(*++p) && isspace(*p))
				continue;
			map->map_sizelimit = atoi(p);
			break;

			/* Start of dns_map specific args */
		  case 'R':		/* search field */
			{
				char *h;

				while (isascii(*++p) && isspace(*p))
					continue;
				h = strchr(p, ' ');
				if (h != NULL)
					*h = '\0';
				map_p->dns_m_type = dns_string_to_type(p);
				if (h != NULL)
					*h = ' ';
				if (map_p->dns_m_type < 0)
					syserr("dns map %s: wrong type %s",
						map->map_mname, p);
			}
			break;

		  case 'B':		/* base domain */
			{
				char *h;

				while (isascii(*++p) && isspace(*p))
					continue;
				h = strchr(p, ' ');
				if (h != NULL)
					*h = '\0';

				/*
				**  slight abuse of map->map_file; it isn't
				**	used otherwise in this map type.
				*/

				map->map_file = newstr(p);
				if (h != NULL)
					*h = ' ';
			}
			break;
		}
		while (*p != '\0' && !(isascii(*p) && isspace(*p)))
			p++;
		if (*p != '\0')
			*p++ = '\0';
	}
	if (map_p->dns_m_type < 0)
		syserr("dns map %s: missing -R type", map->map_mname);
	if (map->map_app != NULL)
		map->map_app = newstr(map->map_app);
	if (map->map_tapp != NULL)
		map->map_tapp = newstr(map->map_tapp);

	/*
	**  Assumption: assert(sizeof(int) <= sizeof(ARBPTR_T));
	**  Even if this assumption is wrong, we use only one byte,
	**  so it doesn't really matter.
	*/

	map->map_db1 = (ARBPTR_T) map_p;
	return true;
}

/*
**  DNS_MAP_LOOKUP -- perform dns map lookup.
**
**	Parameters:
**		map -- pointer to MAP
**		name -- name to lookup
**		av -- arguments to interpolate into buf.
**		statp -- pointer to status (EX_)
**
**	Returns:
**		result of lookup if succeeded.
**		NULL -- otherwise.
*/

char *
dns_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	int resnum = 0;
	char *vp = NULL, *result = NULL;
	size_t vsize;
	struct dns_map *map_p;
	RESOURCE_RECORD_T *rr = NULL;
	DNS_REPLY_T *r = NULL;
#  if NETINET6
	static char buf6[INET6_ADDRSTRLEN];
#  endif /* NETINET6 */

	if (tTd(38, 20))
		sm_dprintf("dns_map_lookup(%s, %s)\n",
			   map->map_mname, name);

	map_p = (struct dns_map *)(map->map_db1);
	if (map->map_file != NULL && *map->map_file != '\0')
	{
		size_t len;
		char *appdomain;

		len = strlen(map->map_file) + strlen(name) + 2;
		appdomain = (char *) sm_malloc(len);
		if (appdomain == NULL)
		{
			*statp = EX_UNAVAILABLE;
			return NULL;
		}
		(void) sm_strlcpyn(appdomain, len, 3, name, ".", map->map_file);
		r = dns_lookup_int(appdomain, C_IN, map_p->dns_m_type,
				   map->map_timeout, map->map_retry);
		sm_free(appdomain);
	}
	else
	{
		r = dns_lookup_int(name, C_IN, map_p->dns_m_type,
				   map->map_timeout, map->map_retry);
	}

	if (r == NULL)
	{
		result = NULL;
		if (h_errno == TRY_AGAIN || transienterror(errno))
			*statp = EX_TEMPFAIL;
		else
			*statp = EX_NOTFOUND;
		goto cleanup;
	}
	*statp = EX_OK;
	for (rr = r->dns_r_head; rr != NULL; rr = rr->rr_next)
	{
		char *type = NULL;
		char *value = NULL;

		switch (rr->rr_type)
		{
		  case T_NS:
			type = "T_NS";
			value = rr->rr_u.rr_txt;
			break;
		  case T_CNAME:
			type = "T_CNAME";
			value = rr->rr_u.rr_txt;
			break;
		  case T_AFSDB:
			type = "T_AFSDB";
			value = rr->rr_u.rr_mx->mx_r_domain;
			break;
		  case T_SRV:
			type = "T_SRV";
			value = rr->rr_u.rr_srv->srv_r_target;
			break;
		  case T_PTR:
			type = "T_PTR";
			value = rr->rr_u.rr_txt;
			break;
		  case T_TXT:
			type = "T_TXT";
			value = rr->rr_u.rr_txt;
			break;
		  case T_MX:
			type = "T_MX";
			value = rr->rr_u.rr_mx->mx_r_domain;
			break;
#  if NETINET
		  case T_A:
			type = "T_A";
			value = inet_ntoa(*(rr->rr_u.rr_a));
			break;
#  endif /* NETINET */
#  if NETINET6
		  case T_AAAA:
			type = "T_AAAA";
			value = anynet_ntop(rr->rr_u.rr_aaaa, buf6,
					    sizeof(buf6));
			break;
#  endif /* NETINET6 */
		}

		(void) strreplnonprt(value, 'X');
		if (map_p->dns_m_type != rr->rr_type)
		{
			if (tTd(38, 40))
				sm_dprintf("\tskipping type %s (%d) value %s\n",
					   type != NULL ? type : "<UNKNOWN>",
					   rr->rr_type,
					   value != NULL ? value : "<NO VALUE>");
			continue;
		}

#  if NETINET6
		if (rr->rr_type == T_AAAA && value == NULL)
		{
			result = NULL;
			*statp = EX_DATAERR;
			if (tTd(38, 40))
				sm_dprintf("\tbad T_AAAA conversion\n");
			goto cleanup;
		}
#  endif /* NETINET6 */
		if (tTd(38, 40))
			sm_dprintf("\tfound type %s (%d) value %s\n",
				   type != NULL ? type : "<UNKNOWN>",
				   rr->rr_type,
				   value != NULL ? value : "<NO VALUE>");
		if (value != NULL &&
		    (map->map_coldelim == '\0' ||
		     map->map_sizelimit == 1 ||
		     bitset(MF_MATCHONLY, map->map_mflags)))
		{
			/* Only care about the first match */
			vp = newstr(value);
			break;
		}
		else if (vp == NULL)
		{
			/* First result */
			vp = newstr(value);
		}
		else
		{
			/* concatenate the results */
			int sz;
			char *new;

			sz = strlen(vp) + strlen(value) + 2;
			new = xalloc(sz);
			(void) sm_snprintf(new, sz, "%s%c%s",
					   vp, map->map_coldelim, value);
			sm_free(vp);
			vp = new;
			if (map->map_sizelimit > 0 &&
			    ++resnum >= map->map_sizelimit)
				break;
		}
	}
	if (vp == NULL)
	{
		result = NULL;
		*statp = EX_NOTFOUND;
		if (tTd(38, 40))
			sm_dprintf("\tno match found\n");
		goto cleanup;
	}

	/* Cleanly truncate for rulesets */
	truncate_at_delim(vp, PSBUFSIZE / 2, map->map_coldelim);

	vsize = strlen(vp);

	if (LogLevel > 9)
		sm_syslog(LOG_INFO, CurEnv->e_id, "dns %.100s => %s",
			  name, vp);
	if (bitset(MF_MATCHONLY, map->map_mflags))
		result = map_rewrite(map, name, strlen(name), NULL);
	else
		result = map_rewrite(map, vp, vsize, av);

  cleanup:
	if (vp != NULL)
		sm_free(vp);
	if (r != NULL)
		dns_free_data(r);
	return result;
}
# endif /* DNSMAP */
#endif /* NAMED_BIND */

/*
**  NDBM modules
*/

#if NDBM

/*
**  NDBM_MAP_OPEN -- DBM-style map open
*/

bool
ndbm_map_open(map, mode)
	MAP *map;
	int mode;
{
	register DBM *dbm;
	int save_errno;
	int dfd;
	int pfd;
	long sff;
	int ret;
	int smode = S_IREAD;
	char dirfile[MAXPATHLEN];
	char pagfile[MAXPATHLEN];
	struct stat st;
	struct stat std, stp;

	if (tTd(38, 2))
		sm_dprintf("ndbm_map_open(%s, %s, %d)\n",
			map->map_mname, map->map_file, mode);
	map->map_lockfd = -1;
	mode &= O_ACCMODE;

	/* do initial file and directory checks */
	if (sm_strlcpyn(dirfile, sizeof(dirfile), 2,
			map->map_file, ".dir") >= sizeof(dirfile) ||
	    sm_strlcpyn(pagfile, sizeof(pagfile), 2,
			map->map_file, ".pag") >= sizeof(pagfile))
	{
		errno = 0;
		if (!bitset(MF_OPTIONAL, map->map_mflags))
			syserr("dbm map \"%s\": map file %s name too long",
				map->map_mname, map->map_file);
		return false;
	}
	sff = SFF_ROOTOK|SFF_REGONLY;
	if (mode == O_RDWR)
	{
		sff |= SFF_CREAT;
		if (!bitnset(DBS_WRITEMAPTOSYMLINK, DontBlameSendmail))
			sff |= SFF_NOSLINK;
		if (!bitnset(DBS_WRITEMAPTOHARDLINK, DontBlameSendmail))
			sff |= SFF_NOHLINK;
		smode = S_IWRITE;
	}
	else
	{
		if (!bitnset(DBS_LINKEDMAPINWRITABLEDIR, DontBlameSendmail))
			sff |= SFF_NOWLINK;
	}
	if (!bitnset(DBS_MAPINUNSAFEDIRPATH, DontBlameSendmail))
		sff |= SFF_SAFEDIRPATH;
	ret = safefile(dirfile, RunAsUid, RunAsGid, RunAsUserName,
		       sff, smode, &std);
	if (ret == 0)
		ret = safefile(pagfile, RunAsUid, RunAsGid, RunAsUserName,
			       sff, smode, &stp);

	if (ret != 0)
	{
		char *prob = "unsafe";

		/* cannot open this map */
		if (ret == ENOENT)
			prob = "missing";
		if (tTd(38, 2))
			sm_dprintf("\t%s map file: %d\n", prob, ret);
		if (!bitset(MF_OPTIONAL, map->map_mflags))
			syserr("dbm map \"%s\": %s map file %s",
				map->map_mname, prob, map->map_file);
		return false;
	}
	if (std.st_mode == ST_MODE_NOFILE)
		mode |= O_CREAT|O_EXCL;

# if LOCK_ON_OPEN
	if (mode == O_RDONLY)
		mode |= O_SHLOCK;
	else
		mode |= O_TRUNC|O_EXLOCK;
# else /* LOCK_ON_OPEN */
	if ((mode & O_ACCMODE) == O_RDWR)
	{
#  if NOFTRUNCATE
		/*
		**  Warning: race condition.  Try to lock the file as
		**  quickly as possible after opening it.
		**	This may also have security problems on some systems,
		**	but there isn't anything we can do about it.
		*/

		mode |= O_TRUNC;
#  else /* NOFTRUNCATE */
		/*
		**  This ugly code opens the map without truncating it,
		**  locks the file, then truncates it.  Necessary to
		**  avoid race conditions.
		*/

		int dirfd;
		int pagfd;
		long sff = SFF_CREAT|SFF_OPENASROOT;

		if (!bitnset(DBS_WRITEMAPTOSYMLINK, DontBlameSendmail))
			sff |= SFF_NOSLINK;
		if (!bitnset(DBS_WRITEMAPTOHARDLINK, DontBlameSendmail))
			sff |= SFF_NOHLINK;

		dirfd = safeopen(dirfile, mode, DBMMODE, sff);
		pagfd = safeopen(pagfile, mode, DBMMODE, sff);

		if (dirfd < 0 || pagfd < 0)
		{
			save_errno = errno;
			if (dirfd >= 0)
				(void) close(dirfd);
			if (pagfd >= 0)
				(void) close(pagfd);
			errno = save_errno;
			syserr("ndbm_map_open: cannot create database %s",
				map->map_file);
			return false;
		}
		if (ftruncate(dirfd, (off_t) 0) < 0 ||
		    ftruncate(pagfd, (off_t) 0) < 0)
		{
			save_errno = errno;
			(void) close(dirfd);
			(void) close(pagfd);
			errno = save_errno;
			syserr("ndbm_map_open: cannot truncate %s.{dir,pag}",
				map->map_file);
			return false;
		}

		/* if new file, get "before" bits for later filechanged check */
		if (std.st_mode == ST_MODE_NOFILE &&
		    (fstat(dirfd, &std) < 0 || fstat(pagfd, &stp) < 0))
		{
			save_errno = errno;
			(void) close(dirfd);
			(void) close(pagfd);
			errno = save_errno;
			syserr("ndbm_map_open(%s.{dir,pag}): cannot fstat pre-opened file",
				map->map_file);
			return false;
		}

		/* have to save the lock for the duration (bletch) */
		map->map_lockfd = dirfd;
		(void) close(pagfd);

		/* twiddle bits for dbm_open */
		mode &= ~(O_CREAT|O_EXCL);
#  endif /* NOFTRUNCATE */
	}
# endif /* LOCK_ON_OPEN */

	/* open the database */
	dbm = dbm_open(map->map_file, mode, DBMMODE);
	if (dbm == NULL)
	{
		save_errno = errno;
		if (bitset(MF_ALIAS, map->map_mflags) &&
		    aliaswait(map, ".pag", false))
			return true;
# if !LOCK_ON_OPEN && !NOFTRUNCATE
		if (map->map_lockfd >= 0)
			(void) close(map->map_lockfd);
# endif /* !LOCK_ON_OPEN && !NOFTRUNCATE */
		errno = save_errno;
		if (!bitset(MF_OPTIONAL, map->map_mflags))
			syserr("Cannot open DBM database %s", map->map_file);
		return false;
	}
	dfd = dbm_dirfno(dbm);
	pfd = dbm_pagfno(dbm);
	if (dfd == pfd)
	{
		/* heuristic: if files are linked, this is actually gdbm */
		dbm_close(dbm);
# if !LOCK_ON_OPEN && !NOFTRUNCATE
		if (map->map_lockfd >= 0)
			(void) close(map->map_lockfd);
# endif /* !LOCK_ON_OPEN && !NOFTRUNCATE */
		errno = 0;
		syserr("dbm map \"%s\": cannot support GDBM",
			map->map_mname);
		return false;
	}

	if (filechanged(dirfile, dfd, &std) ||
	    filechanged(pagfile, pfd, &stp))
	{
		save_errno = errno;
		dbm_close(dbm);
# if !LOCK_ON_OPEN && !NOFTRUNCATE
		if (map->map_lockfd >= 0)
			(void) close(map->map_lockfd);
# endif /* !LOCK_ON_OPEN && !NOFTRUNCATE */
		errno = save_errno;
		syserr("ndbm_map_open(%s): file changed after open",
			map->map_file);
		return false;
	}

	map->map_db1 = (ARBPTR_T) dbm;

	/*
	**  Need to set map_mtime before the call to aliaswait()
	**  as aliaswait() will call map_lookup() which requires
	**  map_mtime to be set
	*/

	if (fstat(pfd, &st) >= 0)
		map->map_mtime = st.st_mtime;

	if (mode == O_RDONLY)
	{
# if LOCK_ON_OPEN
		if (dfd >= 0)
			(void) lockfile(dfd, map->map_file, ".dir", LOCK_UN);
		if (pfd >= 0)
			(void) lockfile(pfd, map->map_file, ".pag", LOCK_UN);
# endif /* LOCK_ON_OPEN */
		if (bitset(MF_ALIAS, map->map_mflags) &&
		    !aliaswait(map, ".pag", true))
			return false;
	}
	else
	{
		map->map_mflags |= MF_LOCKED;
		if (geteuid() == 0 && TrustedUid != 0)
		{
#  if HASFCHOWN
			if (fchown(dfd, TrustedUid, -1) < 0 ||
			    fchown(pfd, TrustedUid, -1) < 0)
			{
				int err = errno;

				sm_syslog(LOG_ALERT, NOQID,
					  "ownership change on %s failed: %s",
					  map->map_file, sm_errstring(err));
				message("050 ownership change on %s failed: %s",
					map->map_file, sm_errstring(err));
			}
#  else /* HASFCHOWN */
			sm_syslog(LOG_ALERT, NOQID,
				  "no fchown(): cannot change ownership on %s",
				  map->map_file);
			message("050 no fchown(): cannot change ownership on %s",
				map->map_file);
#  endif /* HASFCHOWN */
		}
	}
	return true;
}


/*
**  NDBM_MAP_LOOKUP -- look up a datum in a DBM-type map
*/

char *
ndbm_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	datum key, val;
	int dfd, pfd;
	char keybuf[MAXNAME + 1];
	struct stat stbuf;

	if (tTd(38, 20))
		sm_dprintf("ndbm_map_lookup(%s, %s)\n",
			map->map_mname, name);

	key.dptr = name;
	key.dsize = strlen(name);
	if (!bitset(MF_NOFOLDCASE, map->map_mflags))
	{
		if (key.dsize > sizeof(keybuf) - 1)
			key.dsize = sizeof(keybuf) - 1;
		memmove(keybuf, key.dptr, key.dsize);
		keybuf[key.dsize] = '\0';
		makelower(keybuf);
		key.dptr = keybuf;
	}
lockdbm:
	dfd = dbm_dirfno((DBM *) map->map_db1);
	if (dfd >= 0 && !bitset(MF_LOCKED, map->map_mflags))
		(void) lockfile(dfd, map->map_file, ".dir", LOCK_SH);
	pfd = dbm_pagfno((DBM *) map->map_db1);
	if (pfd < 0 || fstat(pfd, &stbuf) < 0 ||
	    stbuf.st_mtime > map->map_mtime)
	{
		/* Reopen the database to sync the cache */
		int omode = bitset(map->map_mflags, MF_WRITABLE) ? O_RDWR
								 : O_RDONLY;

		if (dfd >= 0 && !bitset(MF_LOCKED, map->map_mflags))
			(void) lockfile(dfd, map->map_file, ".dir", LOCK_UN);
		map->map_mflags |= MF_CLOSING;
		map->map_class->map_close(map);
		map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
		if (map->map_class->map_open(map, omode))
		{
			map->map_mflags |= MF_OPEN;
			map->map_pid = CurrentPid;
			if ((omode & O_ACCMODE) == O_RDWR)
				map->map_mflags |= MF_WRITABLE;
			goto lockdbm;
		}
		else
		{
			if (!bitset(MF_OPTIONAL, map->map_mflags))
			{
				extern MAPCLASS BogusMapClass;

				*statp = EX_TEMPFAIL;
				map->map_orgclass = map->map_class;
				map->map_class = &BogusMapClass;
				map->map_mflags |= MF_OPEN;
				map->map_pid = CurrentPid;
				syserr("Cannot reopen NDBM database %s",
					map->map_file);
			}
			return NULL;
		}
	}
	val.dptr = NULL;
	if (bitset(MF_TRY0NULL, map->map_mflags))
	{
		val = dbm_fetch((DBM *) map->map_db1, key);
		if (val.dptr != NULL)
			map->map_mflags &= ~MF_TRY1NULL;
	}
	if (val.dptr == NULL && bitset(MF_TRY1NULL, map->map_mflags))
	{
		key.dsize++;
		val = dbm_fetch((DBM *) map->map_db1, key);
		if (val.dptr != NULL)
			map->map_mflags &= ~MF_TRY0NULL;
	}
	if (dfd >= 0 && !bitset(MF_LOCKED, map->map_mflags))
		(void) lockfile(dfd, map->map_file, ".dir", LOCK_UN);
	if (val.dptr == NULL)
		return NULL;
	if (bitset(MF_MATCHONLY, map->map_mflags))
		return map_rewrite(map, name, strlen(name), NULL);
	else
		return map_rewrite(map, val.dptr, val.dsize, av);
}


/*
**  NDBM_MAP_STORE -- store a datum in the database
*/

void
ndbm_map_store(map, lhs, rhs)
	register MAP *map;
	char *lhs;
	char *rhs;
{
	datum key;
	datum data;
	int status;
	char keybuf[MAXNAME + 1];

	if (tTd(38, 12))
		sm_dprintf("ndbm_map_store(%s, %s, %s)\n",
			map->map_mname, lhs, rhs);

	key.dsize = strlen(lhs);
	key.dptr = lhs;
	if (!bitset(MF_NOFOLDCASE, map->map_mflags))
	{
		if (key.dsize > sizeof(keybuf) - 1)
			key.dsize = sizeof(keybuf) - 1;
		memmove(keybuf, key.dptr, key.dsize);
		keybuf[key.dsize] = '\0';
		makelower(keybuf);
		key.dptr = keybuf;
	}

	data.dsize = strlen(rhs);
	data.dptr = rhs;

	if (bitset(MF_INCLNULL, map->map_mflags))
	{
		key.dsize++;
		data.dsize++;
	}

	status = dbm_store((DBM *) map->map_db1, key, data, DBM_INSERT);
	if (status > 0)
	{
		if (!bitset(MF_APPEND, map->map_mflags))
			message("050 Warning: duplicate alias name %s", lhs);
		else
		{
			static char *buf = NULL;
			static int bufsiz = 0;
			auto int xstat;
			datum old;

			old.dptr = ndbm_map_lookup(map, key.dptr,
						   (char **) NULL, &xstat);
			if (old.dptr != NULL && *(char *) old.dptr != '\0')
			{
				old.dsize = strlen(old.dptr);
				if (data.dsize + old.dsize + 2 > bufsiz)
				{
					if (buf != NULL)
						(void) sm_free(buf);
					bufsiz = data.dsize + old.dsize + 2;
					buf = sm_pmalloc_x(bufsiz);
				}
				(void) sm_strlcpyn(buf, bufsiz, 3,
					data.dptr, ",", old.dptr);
				data.dsize = data.dsize + old.dsize + 1;
				data.dptr = buf;
				if (tTd(38, 9))
					sm_dprintf("ndbm_map_store append=%s\n",
						data.dptr);
			}
		}
		status = dbm_store((DBM *) map->map_db1,
				   key, data, DBM_REPLACE);
	}
	if (status != 0)
		syserr("readaliases: dbm put (%s): %d", lhs, status);
}


/*
**  NDBM_MAP_CLOSE -- close the database
*/

void
ndbm_map_close(map)
	register MAP  *map;
{
	if (tTd(38, 9))
		sm_dprintf("ndbm_map_close(%s, %s, %lx)\n",
			map->map_mname, map->map_file, map->map_mflags);

	if (bitset(MF_WRITABLE, map->map_mflags))
	{
# ifdef NDBM_YP_COMPAT
		bool inclnull;
		char buf[MAXHOSTNAMELEN];

		inclnull = bitset(MF_INCLNULL, map->map_mflags);
		map->map_mflags &= ~MF_INCLNULL;

		if (strstr(map->map_file, "/yp/") != NULL)
		{
			long save_mflags = map->map_mflags;

			map->map_mflags |= MF_NOFOLDCASE;

			(void) sm_snprintf(buf, sizeof(buf), "%010ld", curtime());
			ndbm_map_store(map, "YP_LAST_MODIFIED", buf);

			(void) gethostname(buf, sizeof(buf));
			ndbm_map_store(map, "YP_MASTER_NAME", buf);

			map->map_mflags = save_mflags;
		}

		if (inclnull)
			map->map_mflags |= MF_INCLNULL;
# endif /* NDBM_YP_COMPAT */

		/* write out the distinguished alias */
		ndbm_map_store(map, "@@", "@@");
	}
	dbm_close((DBM *) map->map_db1);

	/* release lock (if needed) */
# if !LOCK_ON_OPEN
	if (map->map_lockfd >= 0)
		(void) close(map->map_lockfd);
# endif /* !LOCK_ON_OPEN */
}

#endif /* NDBM */
/*
**  NEWDB (Hash and BTree) Modules
*/

#if NEWDB

/*
**  BT_MAP_OPEN, HASH_MAP_OPEN -- database open primitives.
**
**	These do rather bizarre locking.  If you can lock on open,
**	do that to avoid the condition of opening a database that
**	is being rebuilt.  If you don't, we'll try to fake it, but
**	there will be a race condition.  If opening for read-only,
**	we immediately release the lock to avoid freezing things up.
**	We really ought to hold the lock, but guarantee that we won't
**	be pokey about it.  That's hard to do.
*/

/* these should be K line arguments */
# if DB_VERSION_MAJOR < 2
#  define db_cachesize	cachesize
#  define h_nelem	nelem
#  ifndef DB_CACHE_SIZE
#   define DB_CACHE_SIZE	(1024 * 1024)	/* database memory cache size */
#  endif /* ! DB_CACHE_SIZE */
#  ifndef DB_HASH_NELEM
#   define DB_HASH_NELEM	4096		/* (starting) size of hash table */
#  endif /* ! DB_HASH_NELEM */
# endif /* DB_VERSION_MAJOR < 2 */

bool
bt_map_open(map, mode)
	MAP *map;
	int mode;
{
# if DB_VERSION_MAJOR < 2
	BTREEINFO btinfo;
# endif /* DB_VERSION_MAJOR < 2 */
# if DB_VERSION_MAJOR == 2
	DB_INFO btinfo;
# endif /* DB_VERSION_MAJOR == 2 */
# if DB_VERSION_MAJOR > 2
	void *btinfo = NULL;
# endif /* DB_VERSION_MAJOR > 2 */

	if (tTd(38, 2))
		sm_dprintf("bt_map_open(%s, %s, %d)\n",
			map->map_mname, map->map_file, mode);

# if DB_VERSION_MAJOR < 3
	memset(&btinfo, '\0', sizeof(btinfo));
#  ifdef DB_CACHE_SIZE
	btinfo.db_cachesize = DB_CACHE_SIZE;
#  endif /* DB_CACHE_SIZE */
# endif /* DB_VERSION_MAJOR < 3 */

	return db_map_open(map, mode, "btree", DB_BTREE, &btinfo);
}

bool
hash_map_open(map, mode)
	MAP *map;
	int mode;
{
# if DB_VERSION_MAJOR < 2
	HASHINFO hinfo;
# endif /* DB_VERSION_MAJOR < 2 */
# if DB_VERSION_MAJOR == 2
	DB_INFO hinfo;
# endif /* DB_VERSION_MAJOR == 2 */
# if DB_VERSION_MAJOR > 2
	void *hinfo = NULL;
# endif /* DB_VERSION_MAJOR > 2 */

	if (tTd(38, 2))
		sm_dprintf("hash_map_open(%s, %s, %d)\n",
			map->map_mname, map->map_file, mode);

# if DB_VERSION_MAJOR < 3
	memset(&hinfo, '\0', sizeof(hinfo));
#  ifdef DB_HASH_NELEM
	hinfo.h_nelem = DB_HASH_NELEM;
#  endif /* DB_HASH_NELEM */
#  ifdef DB_CACHE_SIZE
	hinfo.db_cachesize = DB_CACHE_SIZE;
#  endif /* DB_CACHE_SIZE */
# endif /* DB_VERSION_MAJOR < 3 */

	return db_map_open(map, mode, "hash", DB_HASH, &hinfo);
}

static bool
db_map_open(map, mode, mapclassname, dbtype, openinfo)
	MAP *map;
	int mode;
	char *mapclassname;
	DBTYPE dbtype;
# if DB_VERSION_MAJOR < 2
	const void *openinfo;
# endif /* DB_VERSION_MAJOR < 2 */
# if DB_VERSION_MAJOR == 2
	DB_INFO *openinfo;
# endif /* DB_VERSION_MAJOR == 2 */
# if DB_VERSION_MAJOR > 2
	void **openinfo;
# endif /* DB_VERSION_MAJOR > 2 */
{
	DB *db = NULL;
	int i;
	int omode;
	int smode = S_IREAD;
	int fd;
	long sff;
	int save_errno;
	struct stat st;
	char buf[MAXPATHLEN];

	/* do initial file and directory checks */
	if (sm_strlcpy(buf, map->map_file, sizeof(buf)) >= sizeof(buf))
	{
		errno = 0;
		if (!bitset(MF_OPTIONAL, map->map_mflags))
			syserr("map \"%s\": map file %s name too long",
				map->map_mname, map->map_file);
		return false;
	}
	i = strlen(buf);
	if (i < 3 || strcmp(&buf[i - 3], ".db") != 0)
	{
		if (sm_strlcat(buf, ".db", sizeof(buf)) >= sizeof(buf))
		{
			errno = 0;
			if (!bitset(MF_OPTIONAL, map->map_mflags))
				syserr("map \"%s\": map file %s name too long",
					map->map_mname, map->map_file);
			return false;
		}
	}

	mode &= O_ACCMODE;
	omode = mode;

	sff = SFF_ROOTOK|SFF_REGONLY;
	if (mode == O_RDWR)
	{
		sff |= SFF_CREAT;
		if (!bitnset(DBS_WRITEMAPTOSYMLINK, DontBlameSendmail))
			sff |= SFF_NOSLINK;
		if (!bitnset(DBS_WRITEMAPTOHARDLINK, DontBlameSendmail))
			sff |= SFF_NOHLINK;
		smode = S_IWRITE;
	}
	else
	{
		if (!bitnset(DBS_LINKEDMAPINWRITABLEDIR, DontBlameSendmail))
			sff |= SFF_NOWLINK;
	}
	if (!bitnset(DBS_MAPINUNSAFEDIRPATH, DontBlameSendmail))
		sff |= SFF_SAFEDIRPATH;
	i = safefile(buf, RunAsUid, RunAsGid, RunAsUserName, sff, smode, &st);

	if (i != 0)
	{
		char *prob = "unsafe";

		/* cannot open this map */
		if (i == ENOENT)
			prob = "missing";
		if (tTd(38, 2))
			sm_dprintf("\t%s map file: %s\n", prob, sm_errstring(i));
		errno = i;
		if (!bitset(MF_OPTIONAL, map->map_mflags))
			syserr("%s map \"%s\": %s map file %s",
				mapclassname, map->map_mname, prob, buf);
		return false;
	}
	if (st.st_mode == ST_MODE_NOFILE)
		omode |= O_CREAT|O_EXCL;

	map->map_lockfd = -1;

# if LOCK_ON_OPEN
	if (mode == O_RDWR)
		omode |= O_TRUNC|O_EXLOCK;
	else
		omode |= O_SHLOCK;
# else /* LOCK_ON_OPEN */
	/*
	**  Pre-lock the file to avoid race conditions.  In particular,
	**  since dbopen returns NULL if the file is zero length, we
	**  must have a locked instance around the dbopen.
	*/

	fd = open(buf, omode, DBMMODE);
	if (fd < 0)
	{
		if (!bitset(MF_OPTIONAL, map->map_mflags))
			syserr("db_map_open: cannot pre-open database %s", buf);
		return false;
	}

	/* make sure no baddies slipped in just before the open... */
	if (filechanged(buf, fd, &st))
	{
		save_errno = errno;
		(void) close(fd);
		errno = save_errno;
		syserr("db_map_open(%s): file changed after pre-open", buf);
		return false;
	}

	/* if new file, get the "before" bits for later filechanged check */
	if (st.st_mode == ST_MODE_NOFILE && fstat(fd, &st) < 0)
	{
		save_errno = errno;
		(void) close(fd);
		errno = save_errno;
		syserr("db_map_open(%s): cannot fstat pre-opened file",
			buf);
		return false;
	}

	/* actually lock the pre-opened file */
	if (!lockfile(fd, buf, NULL, mode == O_RDONLY ? LOCK_SH : LOCK_EX))
		syserr("db_map_open: cannot lock %s", buf);

	/* set up mode bits for dbopen */
	if (mode == O_RDWR)
		omode |= O_TRUNC;
	omode &= ~(O_EXCL|O_CREAT);
# endif /* LOCK_ON_OPEN */

# if DB_VERSION_MAJOR < 2
	db = dbopen(buf, omode, DBMMODE, dbtype, openinfo);
# else /* DB_VERSION_MAJOR < 2 */
	{
		int flags = 0;
#  if DB_VERSION_MAJOR > 2
		int ret;
#  endif /* DB_VERSION_MAJOR > 2 */

		if (mode == O_RDONLY)
			flags |= DB_RDONLY;
		if (bitset(O_CREAT, omode))
			flags |= DB_CREATE;
		if (bitset(O_TRUNC, omode))
			flags |= DB_TRUNCATE;
		SM_DB_FLAG_ADD(flags);

#  if DB_VERSION_MAJOR > 2
		ret = db_create(&db, NULL, 0);
#  ifdef DB_CACHE_SIZE
		if (ret == 0 && db != NULL)
		{
			ret = db->set_cachesize(db, 0, DB_CACHE_SIZE, 0);
			if (ret != 0)
			{
				(void) db->close(db, 0);
				db = NULL;
			}
		}
#  endif /* DB_CACHE_SIZE */
#  ifdef DB_HASH_NELEM
		if (dbtype == DB_HASH && ret == 0 && db != NULL)
		{
			ret = db->set_h_nelem(db, DB_HASH_NELEM);
			if (ret != 0)
			{
				(void) db->close(db, 0);
				db = NULL;
			}
		}
#  endif /* DB_HASH_NELEM */
		if (ret == 0 && db != NULL)
		{
			ret = db->open(db,
					DBTXN	/* transaction for DB 4.1 */
					buf, NULL, dbtype, flags, DBMMODE);
			if (ret != 0)
			{
#ifdef DB_OLD_VERSION
				if (ret == DB_OLD_VERSION)
					ret = EINVAL;
#endif /* DB_OLD_VERSION */
				(void) db->close(db, 0);
				db = NULL;
			}
		}
		errno = ret;
#  else /* DB_VERSION_MAJOR > 2 */
		errno = db_open(buf, dbtype, flags, DBMMODE,
				NULL, openinfo, &db);
#  endif /* DB_VERSION_MAJOR > 2 */
	}
# endif /* DB_VERSION_MAJOR < 2 */
	save_errno = errno;

# if !LOCK_ON_OPEN
	if (mode == O_RDWR)
		map->map_lockfd = fd;
	else
		(void) close(fd);
# endif /* !LOCK_ON_OPEN */

	if (db == NULL)
	{
		if (mode == O_RDONLY && bitset(MF_ALIAS, map->map_mflags) &&
		    aliaswait(map, ".db", false))
			return true;
# if !LOCK_ON_OPEN
		if (map->map_lockfd >= 0)
			(void) close(map->map_lockfd);
# endif /* !LOCK_ON_OPEN */
		errno = save_errno;
		if (!bitset(MF_OPTIONAL, map->map_mflags))
			syserr("Cannot open %s database %s",
				mapclassname, buf);
		return false;
	}

# if DB_VERSION_MAJOR < 2
	fd = db->fd(db);
# else /* DB_VERSION_MAJOR < 2 */
	fd = -1;
	errno = db->fd(db, &fd);
# endif /* DB_VERSION_MAJOR < 2 */
	if (filechanged(buf, fd, &st))
	{
		save_errno = errno;
# if DB_VERSION_MAJOR < 2
		(void) db->close(db);
# else /* DB_VERSION_MAJOR < 2 */
		errno = db->close(db, 0);
# endif /* DB_VERSION_MAJOR < 2 */
# if !LOCK_ON_OPEN
		if (map->map_lockfd >= 0)
			(void) close(map->map_lockfd);
# endif /* !LOCK_ON_OPEN */
		errno = save_errno;
		syserr("db_map_open(%s): file changed after open", buf);
		return false;
	}

	if (mode == O_RDWR)
		map->map_mflags |= MF_LOCKED;
# if LOCK_ON_OPEN
	if (fd >= 0 && mode == O_RDONLY)
	{
		(void) lockfile(fd, buf, NULL, LOCK_UN);
	}
# endif /* LOCK_ON_OPEN */

	/* try to make sure that at least the database header is on disk */
	if (mode == O_RDWR)
	{
		(void) db->sync(db, 0);
		if (geteuid() == 0 && TrustedUid != 0)
		{
#  if HASFCHOWN
			if (fchown(fd, TrustedUid, -1) < 0)
			{
				int err = errno;

				sm_syslog(LOG_ALERT, NOQID,
					  "ownership change on %s failed: %s",
					  buf, sm_errstring(err));
				message("050 ownership change on %s failed: %s",
					buf, sm_errstring(err));
			}
#  else /* HASFCHOWN */
			sm_syslog(LOG_ALERT, NOQID,
				  "no fchown(): cannot change ownership on %s",
				  map->map_file);
			message("050 no fchown(): cannot change ownership on %s",
				map->map_file);
#  endif /* HASFCHOWN */
		}
	}

	map->map_db2 = (ARBPTR_T) db;

	/*
	**  Need to set map_mtime before the call to aliaswait()
	**  as aliaswait() will call map_lookup() which requires
	**  map_mtime to be set
	*/

	if (fd >= 0 && fstat(fd, &st) >= 0)
		map->map_mtime = st.st_mtime;

	if (mode == O_RDONLY && bitset(MF_ALIAS, map->map_mflags) &&
	    !aliaswait(map, ".db", true))
		return false;
	return true;
}


/*
**  DB_MAP_LOOKUP -- look up a datum in a BTREE- or HASH-type map
*/

char *
db_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	DBT key, val;
	register DB *db = (DB *) map->map_db2;
	int i;
	int st;
	int save_errno;
	int fd;
	struct stat stbuf;
	char keybuf[MAXNAME + 1];
	char buf[MAXPATHLEN];

	memset(&key, '\0', sizeof(key));
	memset(&val, '\0', sizeof(val));

	if (tTd(38, 20))
		sm_dprintf("db_map_lookup(%s, %s)\n",
			map->map_mname, name);

	if (sm_strlcpy(buf, map->map_file, sizeof(buf)) >= sizeof(buf))
	{
		errno = 0;
		if (!bitset(MF_OPTIONAL, map->map_mflags))
			syserr("map \"%s\": map file %s name too long",
				map->map_mname, map->map_file);
		return NULL;
	}
	i = strlen(buf);
	if (i > 3 && strcmp(&buf[i - 3], ".db") == 0)
		buf[i - 3] = '\0';

	key.size = strlen(name);
	if (key.size > sizeof(keybuf) - 1)
		key.size = sizeof(keybuf) - 1;
	key.data = keybuf;
	memmove(keybuf, name, key.size);
	keybuf[key.size] = '\0';
	if (!bitset(MF_NOFOLDCASE, map->map_mflags))
		makelower(keybuf);
  lockdb:
# if DB_VERSION_MAJOR < 2
	fd = db->fd(db);
# else /* DB_VERSION_MAJOR < 2 */
	fd = -1;
	errno = db->fd(db, &fd);
# endif /* DB_VERSION_MAJOR < 2 */
	if (fd >= 0 && !bitset(MF_LOCKED, map->map_mflags))
		(void) lockfile(fd, buf, ".db", LOCK_SH);
	if (fd < 0 || fstat(fd, &stbuf) < 0 || stbuf.st_mtime > map->map_mtime)
	{
		/* Reopen the database to sync the cache */
		int omode = bitset(map->map_mflags, MF_WRITABLE) ? O_RDWR
								 : O_RDONLY;

		if (fd >= 0 && !bitset(MF_LOCKED, map->map_mflags))
			(void) lockfile(fd, buf, ".db", LOCK_UN);
		map->map_mflags |= MF_CLOSING;
		map->map_class->map_close(map);
		map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
		if (map->map_class->map_open(map, omode))
		{
			map->map_mflags |= MF_OPEN;
			map->map_pid = CurrentPid;
			if ((omode & O_ACCMODE) == O_RDWR)
				map->map_mflags |= MF_WRITABLE;
			db = (DB *) map->map_db2;
			goto lockdb;
		}
		else
		{
			if (!bitset(MF_OPTIONAL, map->map_mflags))
			{
				extern MAPCLASS BogusMapClass;

				*statp = EX_TEMPFAIL;
				map->map_orgclass = map->map_class;
				map->map_class = &BogusMapClass;
				map->map_mflags |= MF_OPEN;
				map->map_pid = CurrentPid;
				syserr("Cannot reopen DB database %s",
					map->map_file);
			}
			return NULL;
		}
	}

	st = 1;
	if (bitset(MF_TRY0NULL, map->map_mflags))
	{
# if DB_VERSION_MAJOR < 2
		st = db->get(db, &key, &val, 0);
# else /* DB_VERSION_MAJOR < 2 */
		errno = db->get(db, NULL, &key, &val, 0);
		switch (errno)
		{
		  case DB_NOTFOUND:
		  case DB_KEYEMPTY:
			st = 1;
			break;

		  case 0:
			st = 0;
			break;

		  default:
			st = -1;
			break;
		}
# endif /* DB_VERSION_MAJOR < 2 */
		if (st == 0)
			map->map_mflags &= ~MF_TRY1NULL;
	}
	if (st != 0 && bitset(MF_TRY1NULL, map->map_mflags))
	{
		key.size++;
# if DB_VERSION_MAJOR < 2
		st = db->get(db, &key, &val, 0);
# else /* DB_VERSION_MAJOR < 2 */
		errno = db->get(db, NULL, &key, &val, 0);
		switch (errno)
		{
		  case DB_NOTFOUND:
		  case DB_KEYEMPTY:
			st = 1;
			break;

		  case 0:
			st = 0;
			break;

		  default:
			st = -1;
			break;
		}
# endif /* DB_VERSION_MAJOR < 2 */
		if (st == 0)
			map->map_mflags &= ~MF_TRY0NULL;
	}
	save_errno = errno;
	if (fd >= 0 && !bitset(MF_LOCKED, map->map_mflags))
		(void) lockfile(fd, buf, ".db", LOCK_UN);
	if (st != 0)
	{
		errno = save_errno;
		if (st < 0)
			syserr("db_map_lookup: get (%s)", name);
		return NULL;
	}
	if (bitset(MF_MATCHONLY, map->map_mflags))
		return map_rewrite(map, name, strlen(name), NULL);
	else
		return map_rewrite(map, val.data, val.size, av);
}


/*
**  DB_MAP_STORE -- store a datum in the NEWDB database
*/

void
db_map_store(map, lhs, rhs)
	register MAP *map;
	char *lhs;
	char *rhs;
{
	int status;
	DBT key;
	DBT data;
	register DB *db = map->map_db2;
	char keybuf[MAXNAME + 1];

	memset(&key, '\0', sizeof(key));
	memset(&data, '\0', sizeof(data));

	if (tTd(38, 12))
		sm_dprintf("db_map_store(%s, %s, %s)\n",
			map->map_mname, lhs, rhs);

	key.size = strlen(lhs);
	key.data = lhs;
	if (!bitset(MF_NOFOLDCASE, map->map_mflags))
	{
		if (key.size > sizeof(keybuf) - 1)
			key.size = sizeof(keybuf) - 1;
		memmove(keybuf, key.data, key.size);
		keybuf[key.size] = '\0';
		makelower(keybuf);
		key.data = keybuf;
	}

	data.size = strlen(rhs);
	data.data = rhs;

	if (bitset(MF_INCLNULL, map->map_mflags))
	{
		key.size++;
		data.size++;
	}

# if DB_VERSION_MAJOR < 2
	status = db->put(db, &key, &data, R_NOOVERWRITE);
# else /* DB_VERSION_MAJOR < 2 */
	errno = db->put(db, NULL, &key, &data, DB_NOOVERWRITE);
	switch (errno)
	{
	  case DB_KEYEXIST:
		status = 1;
		break;

	  case 0:
		status = 0;
		break;

	  default:
		status = -1;
		break;
	}
# endif /* DB_VERSION_MAJOR < 2 */
	if (status > 0)
	{
		if (!bitset(MF_APPEND, map->map_mflags))
			message("050 Warning: duplicate alias name %s", lhs);
		else
		{
			static char *buf = NULL;
			static int bufsiz = 0;
			DBT old;

			memset(&old, '\0', sizeof(old));

			old.data = db_map_lookup(map, key.data,
						 (char **) NULL, &status);
			if (old.data != NULL)
			{
				old.size = strlen(old.data);
				if (data.size + old.size + 2 > (size_t) bufsiz)
				{
					if (buf != NULL)
						sm_free(buf);
					bufsiz = data.size + old.size + 2;
					buf = sm_pmalloc_x(bufsiz);
				}
				(void) sm_strlcpyn(buf, bufsiz, 3,
					(char *) data.data, ",",
					(char *) old.data);
				data.size = data.size + old.size + 1;
				data.data = buf;
				if (tTd(38, 9))
					sm_dprintf("db_map_store append=%s\n",
						(char *) data.data);
			}
		}
# if DB_VERSION_MAJOR < 2
		status = db->put(db, &key, &data, 0);
# else /* DB_VERSION_MAJOR < 2 */
		status = errno = db->put(db, NULL, &key, &data, 0);
# endif /* DB_VERSION_MAJOR < 2 */
	}
	if (status != 0)
		syserr("readaliases: db put (%s)", lhs);
}


/*
**  DB_MAP_CLOSE -- add distinguished entries and close the database
*/

void
db_map_close(map)
	MAP *map;
{
	register DB *db = map->map_db2;

	if (tTd(38, 9))
		sm_dprintf("db_map_close(%s, %s, %lx)\n",
			map->map_mname, map->map_file, map->map_mflags);

	if (bitset(MF_WRITABLE, map->map_mflags))
	{
		/* write out the distinguished alias */
		db_map_store(map, "@@", "@@");
	}

	(void) db->sync(db, 0);

# if !LOCK_ON_OPEN
	if (map->map_lockfd >= 0)
		(void) close(map->map_lockfd);
# endif /* !LOCK_ON_OPEN */

# if DB_VERSION_MAJOR < 2
	if (db->close(db) != 0)
# else /* DB_VERSION_MAJOR < 2 */
	/*
	**  Berkeley DB can use internal shared memory
	**  locking for its memory pool.  Closing a map
	**  opened by another process will interfere
	**  with the shared memory and locks of the parent
	**  process leaving things in a bad state.
	*/

	/*
	**  If this map was not opened by the current
	**  process, do not close the map but recover
	**  the file descriptor.
	*/

	if (map->map_pid != CurrentPid)
	{
		int fd = -1;

		errno = db->fd(db, &fd);
		if (fd >= 0)
			(void) close(fd);
		return;
	}

	if ((errno = db->close(db, 0)) != 0)
# endif /* DB_VERSION_MAJOR < 2 */
		syserr("db_map_close(%s, %s, %lx): db close failure",
			map->map_mname, map->map_file, map->map_mflags);
}
#endif /* NEWDB */
/*
**  NIS Modules
*/

#if NIS

# ifndef YPERR_BUSY
#  define YPERR_BUSY	16
# endif /* ! YPERR_BUSY */

/*
**  NIS_MAP_OPEN -- open DBM map
*/

bool
nis_map_open(map, mode)
	MAP *map;
	int mode;
{
	int yperr;
	register char *p;
	auto char *vp;
	auto int vsize;

	if (tTd(38, 2))
		sm_dprintf("nis_map_open(%s, %s, %d)\n",
			map->map_mname, map->map_file, mode);

	mode &= O_ACCMODE;
	if (mode != O_RDONLY)
	{
		/* issue a pseudo-error message */
		errno = SM_EMAPCANTWRITE;
		return false;
	}

	p = strchr(map->map_file, '@@');
	if (p != NULL)
	{
		*p++ = '\0';
		if (*p != '\0')
			map->map_domain = p;
	}

	if (*map->map_file == '\0')
		map->map_file = "mail.aliases";

	if (map->map_domain == NULL)
	{
		yperr = yp_get_default_domain(&map->map_domain);
		if (yperr != 0)
		{
			if (!bitset(MF_OPTIONAL, map->map_mflags))
				syserr("451 4.3.5 NIS map %s specified, but NIS not running",
				       map->map_file);
			return false;
		}
	}

	/* check to see if this map actually exists */
	vp = NULL;
	yperr = yp_match(map->map_domain, map->map_file, "@@", 1,
			&vp, &vsize);
	if (tTd(38, 10))
		sm_dprintf("nis_map_open: yp_match(@@, %s, %s) => %s\n",
			map->map_domain, map->map_file, yperr_string(yperr));
	if (vp != NULL)
		sm_free(vp);

	if (yperr == 0 || yperr == YPERR_KEY || yperr == YPERR_BUSY)
	{
		/*
		**  We ought to be calling aliaswait() here if this is an
		**  alias file, but powerful HP-UX NIS servers  apparently
		**  don't insert the @@:@@ token into the alias map when it
		**  is rebuilt, so aliaswait() just hangs.  I hate HP-UX.
		*/

# if 0
		if (!bitset(MF_ALIAS, map->map_mflags) ||
		    aliaswait(map, NULL, true))
# endif /* 0 */
			return true;
	}

	if (!bitset(MF_OPTIONAL, map->map_mflags))
	{
		syserr("451 4.3.5 Cannot bind to map %s in domain %s: %s",
			map->map_file, map->map_domain, yperr_string(yperr));
	}

	return false;
}


/*
**  NIS_MAP_LOOKUP -- look up a datum in a NIS map
*/

/* ARGSUSED3 */
char *
nis_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	char *vp;
	auto int vsize;
	int buflen;
	int yperr;
	char keybuf[MAXNAME + 1];
	char *SM_NONVOLATILE result = NULL;

	if (tTd(38, 20))
		sm_dprintf("nis_map_lookup(%s, %s)\n",
			map->map_mname, name);

	buflen = strlen(name);
	if (buflen > sizeof(keybuf) - 1)
		buflen = sizeof(keybuf) - 1;
	memmove(keybuf, name, buflen);
	keybuf[buflen] = '\0';
	if (!bitset(MF_NOFOLDCASE, map->map_mflags))
		makelower(keybuf);
	yperr = YPERR_KEY;
	vp = NULL;
	if (bitset(MF_TRY0NULL, map->map_mflags))
	{
		yperr = yp_match(map->map_domain, map->map_file, keybuf, buflen,
			     &vp, &vsize);
		if (yperr == 0)
			map->map_mflags &= ~MF_TRY1NULL;
	}
	if (yperr == YPERR_KEY && bitset(MF_TRY1NULL, map->map_mflags))
	{
		SM_FREE_CLR(vp);
		buflen++;
		yperr = yp_match(map->map_domain, map->map_file, keybuf, buflen,
			     &vp, &vsize);
		if (yperr == 0)
			map->map_mflags &= ~MF_TRY0NULL;
	}
	if (yperr != 0)
	{
		if (yperr != YPERR_KEY && yperr != YPERR_BUSY)
			map->map_mflags &= ~(MF_VALID|MF_OPEN);
		if (vp != NULL)
			sm_free(vp);
		return NULL;
	}
	SM_TRY
		if (bitset(MF_MATCHONLY, map->map_mflags))
			result = map_rewrite(map, name, strlen(name), NULL);
		else
			result = map_rewrite(map, vp, vsize, av);
	SM_FINALLY
		if (vp != NULL)
			sm_free(vp);
	SM_END_TRY
	return result;
}


/*
**  NIS_GETCANONNAME -- look up canonical name in NIS
*/

static bool
nis_getcanonname(name, hbsize, statp)
	char *name;
	int hbsize;
	int *statp;
{
	char *vp;
	auto int vsize;
	int keylen;
	int yperr;
	static bool try0null = true;
	static bool try1null = true;
	static char *yp_domain = NULL;
	char host_record[MAXLINE];
	char cbuf[MAXNAME];
	char nbuf[MAXNAME + 1];

	if (tTd(38, 20))
		sm_dprintf("nis_getcanonname(%s)\n", name);

	if (sm_strlcpy(nbuf, name, sizeof(nbuf)) >= sizeof(nbuf))
	{
		*statp = EX_UNAVAILABLE;
		return false;
	}
	(void) shorten_hostname(nbuf);
	keylen = strlen(nbuf);

	if (yp_domain == NULL)
		(void) yp_get_default_domain(&yp_domain);
	makelower(nbuf);
	yperr = YPERR_KEY;
	vp = NULL;
	if (try0null)
	{
		yperr = yp_match(yp_domain, "hosts.byname", nbuf, keylen,
			     &vp, &vsize);
		if (yperr == 0)
			try1null = false;
	}
	if (yperr == YPERR_KEY && try1null)
	{
		SM_FREE_CLR(vp);
		keylen++;
		yperr = yp_match(yp_domain, "hosts.byname", nbuf, keylen,
			     &vp, &vsize);
		if (yperr == 0)
			try0null = false;
	}
	if (yperr != 0)
	{
		if (yperr == YPERR_KEY)
			*statp = EX_NOHOST;
		else if (yperr == YPERR_BUSY)
			*statp = EX_TEMPFAIL;
		else
			*statp = EX_UNAVAILABLE;
		if (vp != NULL)
			sm_free(vp);
		return false;
	}
	(void) sm_strlcpy(host_record, vp, sizeof(host_record));
	sm_free(vp);
	if (tTd(38, 44))
		sm_dprintf("got record `%s'\n", host_record);
	vp = strpbrk(host_record, "#\n");
	if (vp != NULL)
		*vp = '\0';
	if (!extract_canonname(nbuf, NULL, host_record, cbuf, sizeof(cbuf)))
	{
		/* this should not happen, but.... */
		*statp = EX_NOHOST;
		return false;
	}
	if (sm_strlcpy(name, cbuf, hbsize) >= hbsize)
	{
		*statp = EX_UNAVAILABLE;
		return false;
	}
	*statp = EX_OK;
	return true;
}

#endif /* NIS */
/*
**  NISPLUS Modules
**
**	This code donated by Sun Microsystems.
*/

#if NISPLUS

# undef NIS		/* symbol conflict in nis.h */
# undef T_UNSPEC	/* symbol conflict in nis.h -> ... -> sys/tiuser.h */
# include <rpcsvc/nis.h>
# include <rpcsvc/nislib.h>
# ifndef NIS_TABLE_OBJ
#  define NIS_TABLE_OBJ TABLE_OBJ
# endif /* NIS_TABLE_OBJ */

# define EN_col(col)	zo_data.objdata_u.en_data.en_cols.en_cols_val[(col)].ec_value.ec_value_val
# define COL_NAME(res,i)	((res->objects.objects_val)->TA_data.ta_cols.ta_cols_val)[i].tc_name
# define COL_MAX(res)	((res->objects.objects_val)->TA_data.ta_cols.ta_cols_len)
# define PARTIAL_NAME(x)	((x)[strlen(x) - 1] != '.')

/*
**  NISPLUS_MAP_OPEN -- open nisplus table
*/

bool
nisplus_map_open(map, mode)
	MAP *map;
	int mode;
{
	nis_result *res = NULL;
	int retry_cnt, max_col, i;
	char qbuf[MAXLINE + NIS_MAXNAMELEN];

	if (tTd(38, 2))
		sm_dprintf("nisplus_map_open(%s, %s, %d)\n",
			map->map_mname, map->map_file, mode);

	mode &= O_ACCMODE;
	if (mode != O_RDONLY)
	{
		errno = EPERM;
		return false;
	}

	if (*map->map_file == '\0')
		map->map_file = "mail_aliases.org_dir";

	if (PARTIAL_NAME(map->map_file) && map->map_domain == NULL)
	{
		/* set default NISPLUS Domain to $m */
		map->map_domain = newstr(nisplus_default_domain());
		if (tTd(38, 2))
			sm_dprintf("nisplus_map_open(%s): using domain %s\n",
				map->map_file, map->map_domain);
	}
	if (!PARTIAL_NAME(map->map_file))
	{
		map->map_domain = newstr("");
		(void) sm_strlcpy(qbuf, map->map_file, sizeof(qbuf));
	}
	else
	{
		/* check to see if this map actually exists */
		(void) sm_strlcpyn(qbuf, sizeof(qbuf), 3,
				   map->map_file, ".", map->map_domain);
	}

	retry_cnt = 0;
	while (res == NULL || res->status != NIS_SUCCESS)
	{
		res = nis_lookup(qbuf, FOLLOW_LINKS);
		switch (res->status)
		{
		  case NIS_SUCCESS:
			break;

		  case NIS_TRYAGAIN:
		  case NIS_RPCERROR:
		  case NIS_NAMEUNREACHABLE:
			if (retry_cnt++ > 4)
			{
				errno = EAGAIN;
				return false;
			}
			/* try not to overwhelm hosed server */
			sleep(2);
			break;

		  default:		/* all other nisplus errors */
# if 0
			if (!bitset(MF_OPTIONAL, map->map_mflags))
				syserr("451 4.3.5 Cannot find table %s.%s: %s",
					map->map_file, map->map_domain,
					nis_sperrno(res->status));
# endif /* 0 */
			errno = EAGAIN;
			return false;
		}
	}

	if (NIS_RES_NUMOBJ(res) != 1 ||
	    (NIS_RES_OBJECT(res)->zo_data.zo_type != NIS_TABLE_OBJ))
	{
		if (tTd(38, 10))
			sm_dprintf("nisplus_map_open: %s is not a table\n", qbuf);
# if 0
		if (!bitset(MF_OPTIONAL, map->map_mflags))
			syserr("451 4.3.5 %s.%s: %s is not a table",
				map->map_file, map->map_domain,
				nis_sperrno(res->status));
# endif /* 0 */
		errno = EBADF;
		return false;
	}
	/* default key column is column 0 */
	if (map->map_keycolnm == NULL)
		map->map_keycolnm = newstr(COL_NAME(res,0));

	max_col = COL_MAX(res);

	/* verify the key column exist */
	for (i = 0; i < max_col; i++)
	{
		if (strcmp(map->map_keycolnm, COL_NAME(res,i)) == 0)
			break;
	}
	if (i == max_col)
	{
		if (tTd(38, 2))
			sm_dprintf("nisplus_map_open(%s): can not find key column %s\n",
				map->map_file, map->map_keycolnm);
		errno = ENOENT;
		return false;
	}

	/* default value column is the last column */
	if (map->map_valcolnm == NULL)
	{
		map->map_valcolno = max_col - 1;
		return true;
	}

	for (i = 0; i< max_col; i++)
	{
		if (strcmp(map->map_valcolnm, COL_NAME(res,i)) == 0)
		{
			map->map_valcolno = i;
			return true;
		}
	}

	if (tTd(38, 2))
		sm_dprintf("nisplus_map_open(%s): can not find column %s\n",
			map->map_file, map->map_keycolnm);
	errno = ENOENT;
	return false;
}


/*
**  NISPLUS_MAP_LOOKUP -- look up a datum in a NISPLUS table
*/

char *
nisplus_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	char *p;
	auto int vsize;
	char *skp;
	int skleft;
	char search_key[MAXNAME + 4];
	char qbuf[MAXLINE + NIS_MAXNAMELEN];
	nis_result *result;

	if (tTd(38, 20))
		sm_dprintf("nisplus_map_lookup(%s, %s)\n",
			map->map_mname, name);

	if (!bitset(MF_OPEN, map->map_mflags))
	{
		if (nisplus_map_open(map, O_RDONLY))
		{
			map->map_mflags |= MF_OPEN;
			map->map_pid = CurrentPid;
		}
		else
		{
			*statp = EX_UNAVAILABLE;
			return NULL;
		}
	}

	/*
	**  Copy the name to the key buffer, escaping double quote characters
	**  by doubling them and quoting "]" and "," to avoid having the
	**  NIS+ parser choke on them.
	*/

	skleft = sizeof(search_key) - 4;
	skp = search_key;
	for (p = name; *p != '\0' && skleft > 0; p++)
	{
		switch (*p)
		{
		  case ']':
		  case ',':
			/* quote the character */
			*skp++ = '"';
			*skp++ = *p;
			*skp++ = '"';
			skleft -= 3;
			break;

		  case '"':
			/* double the quote */
			*skp++ = '"';
			skleft--;
			/* FALLTHROUGH */

		  default:
			*skp++ = *p;
			skleft--;
			break;
		}
	}
	*skp = '\0';
	if (!bitset(MF_NOFOLDCASE, map->map_mflags))
		makelower(search_key);

	/* construct the query */
	if (PARTIAL_NAME(map->map_file))
		(void) sm_snprintf(qbuf, sizeof(qbuf), "[%s=%s],%s.%s",
			map->map_keycolnm, search_key, map->map_file,
			map->map_domain);
	else
		(void) sm_snprintf(qbuf, sizeof(qbuf), "[%s=%s],%s",
			map->map_keycolnm, search_key, map->map_file);

	if (tTd(38, 20))
		sm_dprintf("qbuf=%s\n", qbuf);
	result = nis_list(qbuf, FOLLOW_LINKS | FOLLOW_PATH, NULL, NULL);
	if (result->status == NIS_SUCCESS)
	{
		int count;
		char *str;

		if ((count = NIS_RES_NUMOBJ(result)) != 1)
		{
			if (LogLevel > 10)
				sm_syslog(LOG_WARNING, CurEnv->e_id,
					  "%s: lookup error, expected 1 entry, got %d",
					  map->map_file, count);

			/* ignore second entry */
			if (tTd(38, 20))
				sm_dprintf("nisplus_map_lookup(%s), got %d entries, additional entries ignored\n",
					name, count);
		}

		p = ((NIS_RES_OBJECT(result))->EN_col(map->map_valcolno));
		/* set the length of the result */
		if (p == NULL)
			p = "";
		vsize = strlen(p);
		if (tTd(38, 20))
			sm_dprintf("nisplus_map_lookup(%s), found %s\n",
				name, p);
		if (bitset(MF_MATCHONLY, map->map_mflags))
			str = map_rewrite(map, name, strlen(name), NULL);
		else
			str = map_rewrite(map, p, vsize, av);
		nis_freeresult(result);
		*statp = EX_OK;
		return str;
	}
	else
	{
		if (result->status == NIS_NOTFOUND)
			*statp = EX_NOTFOUND;
		else if (result->status == NIS_TRYAGAIN)
			*statp = EX_TEMPFAIL;
		else
		{
			*statp = EX_UNAVAILABLE;
			map->map_mflags &= ~(MF_VALID|MF_OPEN);
		}
	}
	if (tTd(38, 20))
		sm_dprintf("nisplus_map_lookup(%s), failed\n", name);
	nis_freeresult(result);
	return NULL;
}



/*
**  NISPLUS_GETCANONNAME -- look up canonical name in NIS+
*/

static bool
nisplus_getcanonname(name, hbsize, statp)
	char *name;
	int hbsize;
	int *statp;
{
	char *vp;
	auto int vsize;
	nis_result *result;
	char *p;
	char nbuf[MAXNAME + 1];
	char qbuf[MAXLINE + NIS_MAXNAMELEN];

	if (sm_strlcpy(nbuf, name, sizeof(nbuf)) >= sizeof(nbuf))
	{
		*statp = EX_UNAVAILABLE;
		return false;
	}
	(void) shorten_hostname(nbuf);

	p = strchr(nbuf, '.');
	if (p == NULL)
	{
		/* single token */
		(void) sm_snprintf(qbuf, sizeof(qbuf),
			"[name=%s],hosts.org_dir", nbuf);
	}
	else if (p[1] != '\0')
	{
		/* multi token -- take only first token in nbuf */
		*p = '\0';
		(void) sm_snprintf(qbuf, sizeof(qbuf),
				   "[name=%s],hosts.org_dir.%s", nbuf, &p[1]);
	}
	else
	{
		*statp = EX_NOHOST;
		return false;
	}

	if (tTd(38, 20))
		sm_dprintf("\nnisplus_getcanonname(%s), qbuf=%s\n",
			   name, qbuf);

	result = nis_list(qbuf, EXPAND_NAME|FOLLOW_LINKS|FOLLOW_PATH,
			  NULL, NULL);

	if (result->status == NIS_SUCCESS)
	{
		int count;
		char *domain;

		if ((count = NIS_RES_NUMOBJ(result)) != 1)
		{
			if (LogLevel > 10)
				sm_syslog(LOG_WARNING, CurEnv->e_id,
					  "nisplus_getcanonname: lookup error, expected 1 entry, got %d",
					  count);

			/* ignore second entry */
			if (tTd(38, 20))
				sm_dprintf("nisplus_getcanonname(%s), got %d entries, all but first ignored\n",
					   name, count);
		}

		if (tTd(38, 20))
			sm_dprintf("nisplus_getcanonname(%s), found in directory \"%s\"\n",
				   name, (NIS_RES_OBJECT(result))->zo_domain);


		vp = ((NIS_RES_OBJECT(result))->EN_col(0));
		vsize = strlen(vp);
		if (tTd(38, 20))
			sm_dprintf("nisplus_getcanonname(%s), found %s\n",
				   name, vp);
		if (strchr(vp, '.') != NULL)
		{
			domain = "";
		}
		else
		{
			domain = macvalue('m', CurEnv);
			if (domain == NULL)
				domain = "";
		}
		if (hbsize > vsize + (int) strlen(domain) + 1)
		{
			if (domain[0] == '\0')
				(void) sm_strlcpy(name, vp, hbsize);
			else
				(void) sm_snprintf(name, hbsize,
						   "%s.%s", vp, domain);
			*statp = EX_OK;
		}
		else
			*statp = EX_NOHOST;
		nis_freeresult(result);
		return true;
	}
	else
	{
		if (result->status == NIS_NOTFOUND)
			*statp = EX_NOHOST;
		else if (result->status == NIS_TRYAGAIN)
			*statp = EX_TEMPFAIL;
		else
			*statp = EX_UNAVAILABLE;
	}
	if (tTd(38, 20))
		sm_dprintf("nisplus_getcanonname(%s), failed, status=%d, nsw_stat=%d\n",
			   name, result->status, *statp);
	nis_freeresult(result);
	return false;
}

char *
nisplus_default_domain()
{
	static char default_domain[MAXNAME + 1] = "";
	char *p;

	if (default_domain[0] != '\0')
		return default_domain;

	p = nis_local_directory();
	(void) sm_strlcpy(default_domain, p, sizeof(default_domain));
	return default_domain;
}

#endif /* NISPLUS */
/*
**  LDAP Modules
*/

/*
**  LDAPMAP_DEQUOTE - helper routine for ldapmap_parseargs
*/

#if defined(LDAPMAP) || defined(PH_MAP)

# if PH_MAP
#  define ph_map_dequote ldapmap_dequote
# endif /* PH_MAP */

static char *ldapmap_dequote __P((char *));

static char *
ldapmap_dequote(str)
	char *str;
{
	char *p;
	char *start;

	if (str == NULL)
		return NULL;

	p = str;
	if (*p == '"')
	{
		/* Should probably swallow initial whitespace here */
		start = ++p;
	}
	else
		return str;
	while (*p != '"' && *p != '\0')
		p++;
	if (*p != '\0')
		*p = '\0';
	return start;
}
#endif /* defined(LDAPMAP) || defined(PH_MAP) */

#if LDAPMAP

static SM_LDAP_STRUCT *LDAPDefaults = NULL;

/*
**  LDAPMAP_OPEN -- open LDAP map
**
**	Connect to the LDAP server.  Re-use existing connections since a
**	single server connection to a host (with the same host, port,
**	bind DN, and secret) can answer queries for multiple maps.
*/

bool
ldapmap_open(map, mode)
	MAP *map;
	int mode;
{
	SM_LDAP_STRUCT *lmap;
	STAB *s;
	char *id;

	if (tTd(38, 2))
		sm_dprintf("ldapmap_open(%s, %d): ", map->map_mname, mode);

#if defined(SUN_EXTENSIONS) && defined(SUN_SIMPLIFIED_LDAP) && \
    HASLDAPGETALIASBYNAME
	if (VendorCode == VENDOR_SUN &&
	    strcmp(map->map_mname, "aliases.ldap") == 0)
	{
		return true;
	}
#endif /* defined(SUN_EXTENSIONS) && defined(SUN_SIMPLIFIED_LDAP) && ... */

	mode &= O_ACCMODE;

	/* sendmail doesn't have the ability to write to LDAP (yet) */
	if (mode != O_RDONLY)
	{
		/* issue a pseudo-error message */
		errno = SM_EMAPCANTWRITE;
		return false;
	}

	lmap = (SM_LDAP_STRUCT *) map->map_db1;

	s = ldapmap_findconn(lmap);
	if (s->s_lmap != NULL)
	{
		/* Already have a connection open to this LDAP server */
		lmap->ldap_ld = ((SM_LDAP_STRUCT *)s->s_lmap->map_db1)->ldap_ld;
		lmap->ldap_pid = ((SM_LDAP_STRUCT *)s->s_lmap->map_db1)->ldap_pid;

		/* Add this map as head of linked list */
		lmap->ldap_next = s->s_lmap;
		s->s_lmap = map;

		if (tTd(38, 2))
			sm_dprintf("using cached connection\n");
		return true;
	}

	if (tTd(38, 2))
		sm_dprintf("opening new connection\n");

	if (lmap->ldap_host != NULL)
		id = lmap->ldap_host;
	else if (lmap->ldap_uri != NULL)
		id = lmap->ldap_uri;
	else
		id = "localhost";

	if (tTd(74, 104))
	{
		extern MAPCLASS NullMapClass;

		/* debug mode: don't actually open an LDAP connection */
		map->map_orgclass = map->map_class;
		map->map_class = &NullMapClass;
		map->map_mflags |= MF_OPEN;
		map->map_pid = CurrentPid;
		return true;
	}

	/* No connection yet, connect */
	if (!sm_ldap_start(map->map_mname, lmap))
	{
		if (errno == ETIMEDOUT)
		{
			if (LogLevel > 1)
				sm_syslog(LOG_NOTICE, CurEnv->e_id,
					  "timeout connecting to LDAP server %.100s",
					  id);
		}

		if (!bitset(MF_OPTIONAL, map->map_mflags))
		{
			if (bitset(MF_NODEFER, map->map_mflags))
			{
				syserr("%s failed to %s in map %s",
# if USE_LDAP_INIT
				       "ldap_init/ldap_bind",
# else /* USE_LDAP_INIT */
				       "ldap_open",
# endif /* USE_LDAP_INIT */
				       id, map->map_mname);
			}
			else
			{
				syserr("451 4.3.5 %s failed to %s in map %s",
# if USE_LDAP_INIT
				       "ldap_init/ldap_bind",
# else /* USE_LDAP_INIT */
				       "ldap_open",
# endif /* USE_LDAP_INIT */
				       id, map->map_mname);
			}
		}
		return false;
	}

	/* Save connection for reuse */
	s->s_lmap = map;
	return true;
}

/*
**  LDAPMAP_CLOSE -- close ldap map
*/

void
ldapmap_close(map)
	MAP *map;
{
	SM_LDAP_STRUCT *lmap;
	STAB *s;

	if (tTd(38, 2))
		sm_dprintf("ldapmap_close(%s)\n", map->map_mname);

	lmap = (SM_LDAP_STRUCT *) map->map_db1;

	/* Check if already closed */
	if (lmap->ldap_ld == NULL)
		return;

	/* Close the LDAP connection */
	sm_ldap_close(lmap);

	/* Mark all the maps that share the connection as closed */
	s = ldapmap_findconn(lmap);

	while (s->s_lmap != NULL)
	{
		MAP *smap = s->s_lmap;

		if (tTd(38, 2) && smap != map)
			sm_dprintf("ldapmap_close(%s): closed %s (shared LDAP connection)\n",
				   map->map_mname, smap->map_mname);
		smap->map_mflags &= ~(MF_OPEN|MF_WRITABLE);
		lmap = (SM_LDAP_STRUCT *) smap->map_db1;
		lmap->ldap_ld = NULL;
		s->s_lmap = lmap->ldap_next;
		lmap->ldap_next = NULL;
	}
}

# ifdef SUNET_ID
/*
**  SUNET_ID_HASH -- Convert a string to its Sunet_id canonical form
**  This only makes sense at Stanford University.
*/

static char *
sunet_id_hash(str)
	char *str;
{
	char *p, *p_last;

	p = str;
	p_last = p;
	while (*p != '\0')
	{
		if (isascii(*p) && (islower(*p) || isdigit(*p)))
		{
			*p_last = *p;
			p_last++;
		}
		else if (isascii(*p) && isupper(*p))
		{
			*p_last = tolower(*p);
			p_last++;
		}
		++p;
	}
	if (*p_last != '\0')
		*p_last = '\0';
	return str;
}
#  define SM_CONVERT_ID(str)	sunet_id_hash(str)
# else /* SUNET_ID */
#  define SM_CONVERT_ID(str)	makelower(str)
# endif /* SUNET_ID */

/*
**  LDAPMAP_LOOKUP -- look up a datum in a LDAP map
*/

char *
ldapmap_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	int flags;
	int i;
	int plen = 0;
	int psize = 0;
	int msgid;
	int save_errno;
	char *vp, *p;
	char *result = NULL;
	SM_RPOOL_T *rpool;
	SM_LDAP_STRUCT *lmap = NULL;
	char *argv[SM_LDAP_ARGS];
	char keybuf[MAXKEY];
#if SM_LDAP_ARGS != MAX_MAP_ARGS
# ERROR _SM_LDAP_ARGS must be the same as _MAX_MAP_ARGS
#endif /* SM_LDAP_ARGS != MAX_MAP_ARGS */

#if defined(SUN_EXTENSIONS) && defined(SUN_SIMPLIFIED_LDAP) && \
    HASLDAPGETALIASBYNAME
	if (VendorCode == VENDOR_SUN &&
	    strcmp(map->map_mname, "aliases.ldap") == 0)
	{
		int rc;
#if defined(GETLDAPALIASBYNAME_VERSION) && (GETLDAPALIASBYNAME_VERSION >= 2)
		extern char *__getldapaliasbyname();
		char *answer;

		answer = __getldapaliasbyname(name, &rc);
#else
		char answer[MAXNAME + 1];

		rc = __getldapaliasbyname(name, answer, sizeof(answer));
#endif
		if (rc != 0)
		{
			if (tTd(38, 20))
				sm_dprintf("getldapaliasbyname(%.100s) failed, errno=%d\n",
					   name, errno);
			*statp = EX_NOTFOUND;
			return NULL;
		}
		*statp = EX_OK;
		if (tTd(38, 20))
			sm_dprintf("getldapaliasbyname(%.100s) => %s\n", name,
				   answer);
		if (bitset(MF_MATCHONLY, map->map_mflags))
			result = map_rewrite(map, name, strlen(name), NULL);
		else
			result = map_rewrite(map, answer, strlen(answer), av);
#if defined(GETLDAPALIASBYNAME_VERSION) && (GETLDAPALIASBYNAME_VERSION >= 2)
		free(answer);
#endif
		return result;
	}
#endif /* defined(SUN_EXTENSIONS) && defined(SUN_SIMPLIFIED_LDAP) && ... */

	/* Get ldap struct pointer from map */
	lmap = (SM_LDAP_STRUCT *) map->map_db1;
	sm_ldap_setopts(lmap->ldap_ld, lmap);

	if (lmap->ldap_multi_args)
	{
		SM_REQUIRE(av != NULL);
		memset(argv, '\0', sizeof(argv));
		for (i = 0; i < SM_LDAP_ARGS && av[i] != NULL; i++)
		{
			argv[i] = sm_strdup(av[i]);
			if (argv[i] == NULL)
			{
				int save_errno, j;

				save_errno = errno;
				for (j = 0; j < i && argv[j] != NULL; j++)
					SM_FREE(argv[j]);
				*statp = EX_TEMPFAIL;
				errno = save_errno;
				return NULL;
			}

			if (!bitset(MF_NOFOLDCASE, map->map_mflags))
				SM_CONVERT_ID(av[i]);
		}
	}
	else
	{
		(void) sm_strlcpy(keybuf, name, sizeof(keybuf));

		if (!bitset(MF_NOFOLDCASE, map->map_mflags))
			SM_CONVERT_ID(keybuf);
	}

	if (tTd(38, 20))
	{
		if (lmap->ldap_multi_args)
		{
			sm_dprintf("ldapmap_lookup(%s, argv)\n",
				map->map_mname);
			for (i = 0; i < SM_LDAP_ARGS; i++)
			{
				sm_dprintf("   argv[%d] = %s\n", i,
					   argv[i] == NULL ? "NULL" : argv[i]);
			}
		}
		else
		{
			sm_dprintf("ldapmap_lookup(%s, %s)\n",
				   map->map_mname, name);
		}
	}

	if (lmap->ldap_multi_args)
	{
		msgid = sm_ldap_search_m(lmap, argv);

		/* free the argv array and its content, no longer needed */
		for (i = 0; i < SM_LDAP_ARGS && argv[i] != NULL; i++)
			SM_FREE(argv[i]);
	}
	else
		msgid = sm_ldap_search(lmap, keybuf);
	if (msgid == SM_LDAP_ERR)
	{
		errno = sm_ldap_geterrno(lmap->ldap_ld) + E_LDAPBASE;
		save_errno = errno;
		if (!bitset(MF_OPTIONAL, map->map_mflags))
		{
			/*
			**  Do not include keybuf as this error may be shown
			**  to outsiders.
			*/

			if (bitset(MF_NODEFER, map->map_mflags))
				syserr("Error in ldap_search in map %s",
				       map->map_mname);
			else
				syserr("451 4.3.5 Error in ldap_search in map %s",
				       map->map_mname);
		}
		*statp = EX_TEMPFAIL;
		switch (save_errno - E_LDAPBASE)
		{
# ifdef LDAP_SERVER_DOWN
		  case LDAP_SERVER_DOWN:
# endif /* LDAP_SERVER_DOWN */
		  case LDAP_TIMEOUT:
		  case LDAP_UNAVAILABLE:
			/* server disappeared, try reopen on next search */
			ldapmap_close(map);
			break;
		}
		errno = save_errno;
		return NULL;
	}
#if SM_LDAP_ERROR_ON_MISSING_ARGS
	else if (msgid == SM_LDAP_ERR_ARG_MISS)
	{
		if (bitset(MF_NODEFER, map->map_mflags))
			syserr("Error in ldap_search in map %s, too few arguments",
			       map->map_mname);
		else
			syserr("554 5.3.5 Error in ldap_search in map %s, too few arguments",
			       map->map_mname);
		*statp = EX_CONFIG;
		return NULL;
	}
#endif /* SM_LDAP_ERROR_ON_MISSING_ARGS */

	*statp = EX_NOTFOUND;
	vp = NULL;

	flags = 0;
	if (bitset(MF_SINGLEMATCH, map->map_mflags))
		flags |= SM_LDAP_SINGLEMATCH;
	if (bitset(MF_MATCHONLY, map->map_mflags))
		flags |= SM_LDAP_MATCHONLY;
# if _FFR_LDAP_SINGLEDN
	if (bitset(MF_SINGLEDN, map->map_mflags))
		flags |= SM_LDAP_SINGLEDN;
# endif /* _FFR_LDAP_SINGLEDN */

	/* Create an rpool for search related memory usage */
	rpool = sm_rpool_new_x(NULL);

	p = NULL;
	*statp = sm_ldap_results(lmap, msgid, flags, map->map_coldelim,
				 rpool, &p, &plen, &psize, NULL);
	save_errno = errno;

	/* Copy result so rpool can be freed */
	if (*statp == EX_OK && p != NULL)
		vp = newstr(p);
	sm_rpool_free(rpool);

	/* need to restart LDAP connection? */
	if (*statp == EX_RESTART)
	{
		*statp = EX_TEMPFAIL;
		ldapmap_close(map);
	}

	errno = save_errno;
	if (*statp != EX_OK && *statp != EX_NOTFOUND)
	{
		if (!bitset(MF_OPTIONAL, map->map_mflags))
		{
			if (bitset(MF_NODEFER, map->map_mflags))
				syserr("Error getting LDAP results, map=%s, name=%s",
				       map->map_mname, name);
			else
				syserr("451 4.3.5 Error getting LDAP results, map=%s, name=%s",
				       map->map_mname, name);
		}
		errno = save_errno;
		return NULL;
	}

	/* Did we match anything? */
	if (vp == NULL && !bitset(MF_MATCHONLY, map->map_mflags))
		return NULL;

	if (*statp == EX_OK)
	{
		if (LogLevel > 9)
			sm_syslog(LOG_INFO, CurEnv->e_id,
				  "ldap=%s, %.100s=>%s", map->map_mname, name,
				  vp == NULL ? "<NULL>" : vp);
		if (bitset(MF_MATCHONLY, map->map_mflags))
			result = map_rewrite(map, name, strlen(name), NULL);
		else
		{
			/* vp != NULL according to test above */
			result = map_rewrite(map, vp, strlen(vp), av);
		}
		if (vp != NULL)
			sm_free(vp); /* XXX */
	}
	return result;
}

/*
**  LDAPMAP_FINDCONN -- find an LDAP connection to the server
**
**	Cache LDAP connections based on the host, port, bind DN,
**	secret, and PID so we don't have multiple connections open to
**	the same server for different maps.  Need a separate connection
**	per PID since a parent process may close the map before the
**	child is done with it.
**
**	Parameters:
**		lmap -- LDAP map information
**
**	Returns:
**		Symbol table entry for the LDAP connection.
*/

static STAB *
ldapmap_findconn(lmap)
	SM_LDAP_STRUCT *lmap;
{
	char *format;
	char *nbuf;
	char *id;
	STAB *SM_NONVOLATILE s = NULL;

	if (lmap->ldap_host != NULL)
		id = lmap->ldap_host;
	else if (lmap->ldap_uri != NULL)
		id = lmap->ldap_uri;
	else
		id = "localhost";

	format = "%s%c%d%c%d%c%s%c%s%d";
	nbuf = sm_stringf_x(format,
			    id,
			    CONDELSE,
			    lmap->ldap_port,
			    CONDELSE,
			    lmap->ldap_version,
			    CONDELSE,
			    (lmap->ldap_binddn == NULL ? ""
						       : lmap->ldap_binddn),
			    CONDELSE,
			    (lmap->ldap_secret == NULL ? ""
						       : lmap->ldap_secret),
			    (int) CurrentPid);
	SM_TRY
		s = stab(nbuf, ST_LMAP, ST_ENTER);
	SM_FINALLY
		sm_free(nbuf);
	SM_END_TRY
	return s;
}
/*
**  LDAPMAP_PARSEARGS -- parse ldap map definition args.
*/

static struct lamvalues LDAPAuthMethods[] =
{
	{	"none",		LDAP_AUTH_NONE		},
	{	"simple",	LDAP_AUTH_SIMPLE	},
# ifdef LDAP_AUTH_KRBV4
	{	"krbv4",	LDAP_AUTH_KRBV4		},
# endif /* LDAP_AUTH_KRBV4 */
	{	NULL,		0			}
};

static struct ladvalues LDAPAliasDereference[] =
{
	{	"never",	LDAP_DEREF_NEVER	},
	{	"always",	LDAP_DEREF_ALWAYS	},
	{	"search",	LDAP_DEREF_SEARCHING	},
	{	"find",		LDAP_DEREF_FINDING	},
	{	NULL,		0			}
};

static struct lssvalues LDAPSearchScope[] =
{
	{	"base",		LDAP_SCOPE_BASE		},
	{	"one",		LDAP_SCOPE_ONELEVEL	},
	{	"sub",		LDAP_SCOPE_SUBTREE	},
	{	NULL,		0			}
};

bool
ldapmap_parseargs(map, args)
	MAP *map;
	char *args;
{
	bool secretread = true;
	bool attrssetup = false;
	int i;
	register char *p = args;
	SM_LDAP_STRUCT *lmap;
	struct lamvalues *lam;
	struct ladvalues *lad;
	struct lssvalues *lss;
	char ldapfilt[MAXLINE];
	char m_tmp[MAXPATHLEN + LDAPMAP_MAX_PASSWD];

	/* Get ldap struct pointer from map */
	lmap = (SM_LDAP_STRUCT *) map->map_db1;

	/* Check if setting the initial LDAP defaults */
	if (lmap == NULL || lmap != LDAPDefaults)
	{
		/* We need to alloc an SM_LDAP_STRUCT struct */
		lmap = (SM_LDAP_STRUCT *) xalloc(sizeof(*lmap));
		if (LDAPDefaults == NULL)
			sm_ldap_clear(lmap);
		else
			STRUCTCOPY(*LDAPDefaults, *lmap);
	}

	/* there is no check whether there is really an argument */
	map->map_mflags |= MF_TRY0NULL|MF_TRY1NULL;
	map->map_spacesub = SpaceSub;	/* default value */

	/* Check if setting up an alias or file class LDAP map */
	if (bitset(MF_ALIAS, map->map_mflags))
	{
		/* Comma separate if used as an alias file */
		map->map_coldelim = ',';
		if (*args == '\0')
		{
			int n;
			char *lc;
			char jbuf[MAXHOSTNAMELEN];
			char lcbuf[MAXLINE];

			/* Get $j */
			expand("\201j", jbuf, sizeof(jbuf), &BlankEnvelope);
			if (jbuf[0] == '\0')
			{
				(void) sm_strlcpy(jbuf, "localhost",
						  sizeof(jbuf));
			}

			lc = macvalue(macid("{sendmailMTACluster}"), CurEnv);
			if (lc == NULL)
				lc = "";
			else
			{
				expand(lc, lcbuf, sizeof(lcbuf), CurEnv);
				lc = lcbuf;
			}

			n = sm_snprintf(ldapfilt, sizeof(ldapfilt),
					"(&(objectClass=sendmailMTAAliasObject)(sendmailMTAAliasGrouping=aliases)(|(sendmailMTACluster=%s)(sendmailMTAHost=%s))(sendmailMTAKey=%%0))",
					lc, jbuf);
			if (n >= sizeof(ldapfilt))
			{
				syserr("%s: Default LDAP string too long",
				       map->map_mname);
				return false;
			}

			/* default args for an alias LDAP entry */
			lmap->ldap_filter = ldapfilt;
			lmap->ldap_attr[0] = "objectClass";
			lmap->ldap_attr_type[0] = SM_LDAP_ATTR_OBJCLASS;
			lmap->ldap_attr_needobjclass[0] = NULL;
			lmap->ldap_attr[1] = "sendmailMTAAliasValue";
			lmap->ldap_attr_type[1] = SM_LDAP_ATTR_NORMAL;
			lmap->ldap_attr_needobjclass[1] = NULL;
			lmap->ldap_attr[2] = "sendmailMTAAliasSearch";
			lmap->ldap_attr_type[2] = SM_LDAP_ATTR_FILTER;
			lmap->ldap_attr_needobjclass[2] = "sendmailMTAMapObject";
			lmap->ldap_attr[3] = "sendmailMTAAliasURL";
			lmap->ldap_attr_type[3] = SM_LDAP_ATTR_URL;
			lmap->ldap_attr_needobjclass[3] = "sendmailMTAMapObject";
			lmap->ldap_attr[4] = NULL;
			lmap->ldap_attr_type[4] = SM_LDAP_ATTR_NONE;
			lmap->ldap_attr_needobjclass[4] = NULL;
			attrssetup = true;
		}
	}
	else if (bitset(MF_FILECLASS, map->map_mflags))
	{
		/* Space separate if used as a file class file */
		map->map_coldelim = ' ';
	}

# if _FFR_LDAP_NETWORK_TIMEOUT
	lmap->ldap_networktmo = 120;
# endif /* _FFR_LDAP_NETWORK_TIMEOUT */

	for (;;)
	{
		while (isascii(*p) && isspace(*p))
			p++;
		if (*p != '-')
			break;
		switch (*++p)
		{
		  case 'A':
			map->map_mflags |= MF_APPEND;
			break;

		  case 'a':
			map->map_app = ++p;
			break;

		  case 'D':
			map->map_mflags |= MF_DEFER;
			break;

		  case 'f':
			map->map_mflags |= MF_NOFOLDCASE;
			break;

		  case 'm':
			map->map_mflags |= MF_MATCHONLY;
			break;

		  case 'N':
			map->map_mflags |= MF_INCLNULL;
			map->map_mflags &= ~MF_TRY0NULL;
			break;

		  case 'O':
			map->map_mflags &= ~MF_TRY1NULL;
			break;

		  case 'o':
			map->map_mflags |= MF_OPTIONAL;
			break;

		  case 'q':
			map->map_mflags |= MF_KEEPQUOTES;
			break;

		  case 'S':
			map->map_spacesub = *++p;
			break;

		  case 'T':
			map->map_tapp = ++p;
			break;

		  case 't':
			map->map_mflags |= MF_NODEFER;
			break;

		  case 'z':
			if (*++p != '\\')
				map->map_coldelim = *p;
			else
			{
				switch (*++p)
				{
				  case 'n':
					map->map_coldelim = '\n';
					break;

				  case 't':
					map->map_coldelim = '\t';
					break;

				  default:
					map->map_coldelim = '\\';
				}
			}
			break;

			/* Start of ldapmap specific args */
		  case '1':
			map->map_mflags |= MF_SINGLEMATCH;
			break;

# if _FFR_LDAP_SINGLEDN
		  case '2':
			map->map_mflags |= MF_SINGLEDN;
			break;
# endif /* _FFR_LDAP_SINGLEDN */

		  case 'b':		/* search base */
			while (isascii(*++p) && isspace(*p))
				continue;
			lmap->ldap_base = p;
			break;

# if _FFR_LDAP_NETWORK_TIMEOUT
		  case 'c':		/* network (connect) timeout */
			while (isascii(*++p) && isspace(*p))
				continue;
			lmap->ldap_networktmo = atoi(p);
			break;
# endif /* _FFR_LDAP_NETWORK_TIMEOUT */

		  case 'd':		/* Dn to bind to server as */
			while (isascii(*++p) && isspace(*p))
				continue;
			lmap->ldap_binddn = p;
			break;

		  case 'H':		/* Use LDAP URI */
#  if !USE_LDAP_INIT
			syserr("Must compile with -DUSE_LDAP_INIT to use LDAP URIs (-H) in map %s",
			       map->map_mname);
			return false;
#   else /* !USE_LDAP_INIT */
			if (lmap->ldap_host != NULL)
			{
				syserr("Can not specify both an LDAP host and an LDAP URI in map %s",
				       map->map_mname);
				return false;
			}
			while (isascii(*++p) && isspace(*p))
				continue;
			lmap->ldap_uri = p;
			break;
#  endif /* !USE_LDAP_INIT */

		  case 'h':		/* ldap host */
			while (isascii(*++p) && isspace(*p))
				continue;
			if (lmap->ldap_uri != NULL)
			{
				syserr("Can not specify both an LDAP host and an LDAP URI in map %s",
				       map->map_mname);
				return false;
			}
			lmap->ldap_host = p;
			break;

		  case 'K':
			lmap->ldap_multi_args = true;
			break;

		  case 'k':		/* search field */
			while (isascii(*++p) && isspace(*p))
				continue;
			lmap->ldap_filter = p;
			break;

		  case 'l':		/* time limit */
			while (isascii(*++p) && isspace(*p))
				continue;
			lmap->ldap_timelimit = atoi(p);
			lmap->ldap_timeout.tv_sec = lmap->ldap_timelimit;
			break;

		  case 'M':		/* Method for binding */
			while (isascii(*++p) && isspace(*p))
				continue;

			if (sm_strncasecmp(p, "LDAP_AUTH_", 10) == 0)
				p += 10;

			for (lam = LDAPAuthMethods;
			     lam != NULL && lam->lam_name != NULL; lam++)
			{
				if (sm_strncasecmp(p, lam->lam_name,
						   strlen(lam->lam_name)) == 0)
					break;
			}
			if (lam->lam_name != NULL)
				lmap->ldap_method = lam->lam_code;
			else
			{
				/* bad config line */
				if (!bitset(MCF_OPTFILE,
					    map->map_class->map_cflags))
				{
					char *ptr;

					if ((ptr = strchr(p, ' ')) != NULL)
						*ptr = '\0';
					syserr("Method for binding must be [none|simple|krbv4] (not %s) in map %s",
						p, map->map_mname);
					if (ptr != NULL)
						*ptr = ' ';
					return false;
				}
			}
			break;

		  case 'n':		/* retrieve attribute names only */
			lmap->ldap_attrsonly = LDAPMAP_TRUE;
			break;

			/*
			**  This is a string that is dependent on the
			**  method used defined by 'M'.
			*/

		  case 'P':		/* Secret password for binding */
			 while (isascii(*++p) && isspace(*p))
				continue;
			lmap->ldap_secret = p;
			secretread = false;
			break;

		  case 'p':		/* ldap port */
			while (isascii(*++p) && isspace(*p))
				continue;
			lmap->ldap_port = atoi(p);
			break;

			/* args stolen from ldapsearch.c */
		  case 'R':		/* don't auto chase referrals */
# ifdef LDAP_REFERRALS
			lmap->ldap_options &= ~LDAP_OPT_REFERRALS;
# else /* LDAP_REFERRALS */
			syserr("compile with -DLDAP_REFERRALS for referral support");
# endif /* LDAP_REFERRALS */
			break;

		  case 'r':		/* alias dereferencing */
			while (isascii(*++p) && isspace(*p))
				continue;

			if (sm_strncasecmp(p, "LDAP_DEREF_", 11) == 0)
				p += 11;

			for (lad = LDAPAliasDereference;
			     lad != NULL && lad->lad_name != NULL; lad++)
			{
				if (sm_strncasecmp(p, lad->lad_name,
						   strlen(lad->lad_name)) == 0)
					break;
			}
			if (lad->lad_name != NULL)
				lmap->ldap_deref = lad->lad_code;
			else
			{
				/* bad config line */
				if (!bitset(MCF_OPTFILE,
					    map->map_class->map_cflags))
				{
					char *ptr;

					if ((ptr = strchr(p, ' ')) != NULL)
						*ptr = '\0';
					syserr("Deref must be [never|always|search|find] (not %s) in map %s",
						p, map->map_mname);
					if (ptr != NULL)
						*ptr = ' ';
					return false;
				}
			}
			break;

		  case 's':		/* search scope */
			while (isascii(*++p) && isspace(*p))
				continue;

			if (sm_strncasecmp(p, "LDAP_SCOPE_", 11) == 0)
				p += 11;

			for (lss = LDAPSearchScope;
			     lss != NULL && lss->lss_name != NULL; lss++)
			{
				if (sm_strncasecmp(p, lss->lss_name,
						   strlen(lss->lss_name)) == 0)
					break;
			}
			if (lss->lss_name != NULL)
				lmap->ldap_scope = lss->lss_code;
			else
			{
				/* bad config line */
				if (!bitset(MCF_OPTFILE,
					    map->map_class->map_cflags))
				{
					char *ptr;

					if ((ptr = strchr(p, ' ')) != NULL)
						*ptr = '\0';
					syserr("Scope must be [base|one|sub] (not %s) in map %s",
						p, map->map_mname);
					if (ptr != NULL)
						*ptr = ' ';
					return false;
				}
			}
			break;

		  case 'V':
			if (*++p != '\\')
				lmap->ldap_attrsep = *p;
			else
			{
				switch (*++p)
				{
				  case 'n':
					lmap->ldap_attrsep = '\n';
					break;

				  case 't':
					lmap->ldap_attrsep = '\t';
					break;

				  default:
					lmap->ldap_attrsep = '\\';
				}
			}
			break;

		  case 'v':		/* attr to return */
			while (isascii(*++p) && isspace(*p))
				continue;
			lmap->ldap_attr[0] = p;
			lmap->ldap_attr[1] = NULL;
			break;

		  case 'w':
			/* -w should be for passwd, -P should be for version */
			while (isascii(*++p) && isspace(*p))
				continue;
			lmap->ldap_version = atoi(p);
# ifdef LDAP_VERSION_MAX
			if (lmap->ldap_version > LDAP_VERSION_MAX)
			{
				syserr("LDAP version %d exceeds max of %d in map %s",
				       lmap->ldap_version, LDAP_VERSION_MAX,
				       map->map_mname);
				return false;
			}
# endif /* LDAP_VERSION_MAX */
# ifdef LDAP_VERSION_MIN
			if (lmap->ldap_version < LDAP_VERSION_MIN)
			{
				syserr("LDAP version %d is lower than min of %d in map %s",
				       lmap->ldap_version, LDAP_VERSION_MIN,
				       map->map_mname);
				return false;
			}
# endif /* LDAP_VERSION_MIN */
			break;

		  case 'Z':
			while (isascii(*++p) && isspace(*p))
				continue;
			lmap->ldap_sizelimit = atoi(p);
			break;

		  default:
			syserr("Illegal option %c map %s", *p, map->map_mname);
			break;
		}

		/* need to account for quoted strings here */
		while (*p != '\0' && !(isascii(*p) && isspace(*p)))
		{
			if (*p == '"')
			{
				while (*++p != '"' && *p != '\0')
					continue;
				if (*p != '\0')
					p++;
			}
			else
				p++;
		}

		if (*p != '\0')
			*p++ = '\0';
	}

	if (map->map_app != NULL)
		map->map_app = newstr(ldapmap_dequote(map->map_app));
	if (map->map_tapp != NULL)
		map->map_tapp = newstr(ldapmap_dequote(map->map_tapp));

	/*
	**  We need to swallow up all the stuff into a struct
	**  and dump it into map->map_dbptr1
	*/

	if (lmap->ldap_host != NULL &&
	    (LDAPDefaults == NULL ||
	     LDAPDefaults == lmap ||
	     LDAPDefaults->ldap_host != lmap->ldap_host))
		lmap->ldap_host = newstr(ldapmap_dequote(lmap->ldap_host));
	map->map_domain = lmap->ldap_host;

	if (lmap->ldap_uri != NULL &&
	    (LDAPDefaults == NULL ||
	     LDAPDefaults == lmap ||
	     LDAPDefaults->ldap_uri != lmap->ldap_uri))
		lmap->ldap_uri = newstr(ldapmap_dequote(lmap->ldap_uri));
	map->map_domain = lmap->ldap_uri;

	if (lmap->ldap_binddn != NULL &&
	    (LDAPDefaults == NULL ||
	     LDAPDefaults == lmap ||
	     LDAPDefaults->ldap_binddn != lmap->ldap_binddn))
		lmap->ldap_binddn = newstr(ldapmap_dequote(lmap->ldap_binddn));

	if (lmap->ldap_secret != NULL &&
	    (LDAPDefaults == NULL ||
	     LDAPDefaults == lmap ||
	     LDAPDefaults->ldap_secret != lmap->ldap_secret))
	{
		SM_FILE_T *sfd;
		long sff = SFF_OPENASROOT|SFF_ROOTOK|SFF_NOWLINK|SFF_NOWWFILES|SFF_NOGWFILES;

		if (DontLockReadFiles)
			sff |= SFF_NOLOCK;

		/* need to use method to map secret to passwd string */
		switch (lmap->ldap_method)
		{
		  case LDAP_AUTH_NONE:
			/* Do nothing */
			break;

		  case LDAP_AUTH_SIMPLE:

			/*
			**  Secret is the name of a file with
			**  the first line as the password.
			*/

			/* Already read in the secret? */
			if (secretread)
				break;

			sfd = safefopen(ldapmap_dequote(lmap->ldap_secret),
					O_RDONLY, 0, sff);
			if (sfd == NULL)
			{
				syserr("LDAP map: cannot open secret %s",
				       ldapmap_dequote(lmap->ldap_secret));
				return false;
			}
			lmap->ldap_secret = sfgets(m_tmp, sizeof(m_tmp),
						   sfd, TimeOuts.to_fileopen,
						   "ldapmap_parseargs");
			(void) sm_io_close(sfd, SM_TIME_DEFAULT);
			if (strlen(m_tmp) > LDAPMAP_MAX_PASSWD)
			{
				syserr("LDAP map: secret in %s too long",
				       ldapmap_dequote(lmap->ldap_secret));
				return false;
			}
			if (lmap->ldap_secret != NULL &&
			    strlen(m_tmp) > 0)
			{
				/* chomp newline */
				if (m_tmp[strlen(m_tmp) - 1] == '\n')
					m_tmp[strlen(m_tmp) - 1] = '\0';

				lmap->ldap_secret = m_tmp;
			}
			break;

# ifdef LDAP_AUTH_KRBV4
		  case LDAP_AUTH_KRBV4:

			/*
			**  Secret is where the ticket file is
			**  stashed
			*/

			(void) sm_snprintf(m_tmp, sizeof(m_tmp),
				"KRBTKFILE=%s",
				ldapmap_dequote(lmap->ldap_secret));
			lmap->ldap_secret = m_tmp;
			break;
# endif /* LDAP_AUTH_KRBV4 */

		  default:	       /* Should NEVER get here */
			syserr("LDAP map: Illegal value in lmap method");
			return false;
			/* NOTREACHED */
			break;
		}
	}

	if (lmap->ldap_secret != NULL &&
	    (LDAPDefaults == NULL ||
	     LDAPDefaults == lmap ||
	     LDAPDefaults->ldap_secret != lmap->ldap_secret))
		lmap->ldap_secret = newstr(ldapmap_dequote(lmap->ldap_secret));

	if (lmap->ldap_base != NULL &&
	    (LDAPDefaults == NULL ||
	     LDAPDefaults == lmap ||
	     LDAPDefaults->ldap_base != lmap->ldap_base))
		lmap->ldap_base = newstr(ldapmap_dequote(lmap->ldap_base));

	/*
	**  Save the server from extra work.  If request is for a single
	**  match, tell the server to only return enough records to
	**  determine if there is a single match or not.  This can not
	**  be one since the server would only return one and we wouldn't
	**  know if there were others available.
	*/

	if (bitset(MF_SINGLEMATCH, map->map_mflags))
		lmap->ldap_sizelimit = 2;

	/* If setting defaults, don't process ldap_filter and ldap_attr */
	if (lmap == LDAPDefaults)
		return true;

	if (lmap->ldap_filter != NULL)
		lmap->ldap_filter = newstr(ldapmap_dequote(lmap->ldap_filter));
	else
	{
		if (!bitset(MCF_OPTFILE, map->map_class->map_cflags))
		{
			syserr("No filter given in map %s", map->map_mname);
			return false;
		}
	}

	if (!attrssetup && lmap->ldap_attr[0] != NULL)
	{
		bool recurse = false;
		bool normalseen = false;

		i = 0;
		p = ldapmap_dequote(lmap->ldap_attr[0]);
		lmap->ldap_attr[0] = NULL;

		/* Prime the attr list with the objectClass attribute */
		lmap->ldap_attr[i] = "objectClass";
		lmap->ldap_attr_type[i] = SM_LDAP_ATTR_OBJCLASS;
		lmap->ldap_attr_needobjclass[i] = NULL;
		i++;

		while (p != NULL)
		{
			char *v;

			while (isascii(*p) && isspace(*p))
				p++;
			if (*p == '\0')
				break;
			v = p;
			p = strchr(v, ',');
			if (p != NULL)
				*p++ = '\0';

			if (i >= LDAPMAP_MAX_ATTR)
			{
				syserr("Too many return attributes in %s (max %d)",
				       map->map_mname, LDAPMAP_MAX_ATTR);
				return false;
			}
			if (*v != '\0')
			{
				int j;
				int use;
				char *type;
				char *needobjclass;

				type = strchr(v, ':');
				if (type != NULL)
				{
					*type++ = '\0';
					needobjclass = strchr(type, ':');
					if (needobjclass != NULL)
						*needobjclass++ = '\0';
				}
				else
				{
					needobjclass = NULL;
				}

				use = i;

				/* allow override on "objectClass" type */
				if (sm_strcasecmp(v, "objectClass") == 0 &&
				    lmap->ldap_attr_type[0] == SM_LDAP_ATTR_OBJCLASS)
				{
					use = 0;
				}
				else
				{
					/*
					**  Don't add something to attribute
					**  list twice.
					*/

					for (j = 1; j < i; j++)
					{
						if (sm_strcasecmp(v, lmap->ldap_attr[j]) == 0)
						{
							syserr("Duplicate attribute (%s) in %s",
							       v, map->map_mname);
							return false;
						}
					}

					lmap->ldap_attr[use] = newstr(v);
					if (needobjclass != NULL &&
					    *needobjclass != '\0' &&
					    *needobjclass != '*')
					{
						lmap->ldap_attr_needobjclass[use] = newstr(needobjclass);
					}
					else
					{
						lmap->ldap_attr_needobjclass[use] = NULL;
					}

				}

				if (type != NULL && *type != '\0')
				{
					if (sm_strcasecmp(type, "dn") == 0)
					{
						recurse = true;
						lmap->ldap_attr_type[use] = SM_LDAP_ATTR_DN;
					}
					else if (sm_strcasecmp(type, "filter") == 0)
					{
						recurse = true;
						lmap->ldap_attr_type[use] = SM_LDAP_ATTR_FILTER;
					}
					else if (sm_strcasecmp(type, "url") == 0)
					{
						recurse = true;
						lmap->ldap_attr_type[use] = SM_LDAP_ATTR_URL;
					}
					else if (sm_strcasecmp(type, "normal") == 0)
					{
						lmap->ldap_attr_type[use] = SM_LDAP_ATTR_NORMAL;
						normalseen = true;
					}
					else
					{
						syserr("Unknown attribute type (%s) in %s",
						       type, map->map_mname);
						return false;
					}
				}
				else
				{
					lmap->ldap_attr_type[use] = SM_LDAP_ATTR_NORMAL;
					normalseen = true;
				}
				i++;
			}
		}
		lmap->ldap_attr[i] = NULL;

		/* Set in case needed in future code */
		attrssetup = true;

		if (recurse && !normalseen)
		{
			syserr("LDAP recursion requested in %s but no returnable attribute given",
			       map->map_mname);
			return false;
		}
		if (recurse && lmap->ldap_attrsonly == LDAPMAP_TRUE)
		{
			syserr("LDAP recursion requested in %s can not be used with -n",
			       map->map_mname);
			return false;
		}
	}
	map->map_db1 = (ARBPTR_T) lmap;
	return true;
}

/*
**  LDAPMAP_SET_DEFAULTS -- Read default map spec from LDAPDefaults in .cf
**
**	Parameters:
**		spec -- map argument string from LDAPDefaults option
**
**	Returns:
**		None.
*/

void
ldapmap_set_defaults(spec)
	char *spec;
{
	STAB *class;
	MAP map;

	/* Allocate and set the default values */
	if (LDAPDefaults == NULL)
		LDAPDefaults = (SM_LDAP_STRUCT *) xalloc(sizeof(*LDAPDefaults));
	sm_ldap_clear(LDAPDefaults);

	memset(&map, '\0', sizeof(map));

	/* look up the class */
	class = stab("ldap", ST_MAPCLASS, ST_FIND);
	if (class == NULL)
	{
		syserr("readcf: LDAPDefaultSpec: class ldap not available");
		return;
	}
	map.map_class = &class->s_mapclass;
	map.map_db1 = (ARBPTR_T) LDAPDefaults;
	map.map_mname = "O LDAPDefaultSpec";

	(void) ldapmap_parseargs(&map, spec);

	/* These should never be set in LDAPDefaults */
	if (map.map_mflags != (MF_TRY0NULL|MF_TRY1NULL) ||
	    map.map_spacesub != SpaceSub ||
	    map.map_app != NULL ||
	    map.map_tapp != NULL)
	{
		syserr("readcf: option LDAPDefaultSpec: Do not set non-LDAP specific flags");
		SM_FREE_CLR(map.map_app);
		SM_FREE_CLR(map.map_tapp);
	}

	if (LDAPDefaults->ldap_filter != NULL)
	{
		syserr("readcf: option LDAPDefaultSpec: Do not set the LDAP search filter");

		/* don't free, it isn't malloc'ed in parseargs */
		LDAPDefaults->ldap_filter = NULL;
	}

	if (LDAPDefaults->ldap_attr[0] != NULL)
	{
		syserr("readcf: option LDAPDefaultSpec: Do not set the requested LDAP attributes");
		/* don't free, they aren't malloc'ed in parseargs */
		LDAPDefaults->ldap_attr[0] = NULL;
	}
}
#endif /* LDAPMAP */
/*
**  PH map
*/

#if PH_MAP

/*
**  Support for the CCSO Nameserver (ph/qi).
**  This code is intended to replace the so-called "ph mailer".
**  Contributed by Mark D. Roth.  Contact him for support.
*/

/* what version of the ph map code we're running */
static char phmap_id[128];

/* sendmail version for phmap id string */
extern const char Version[];

/* assume we're using nph-1.2.x if not specified */
# ifndef NPH_VERSION
#  define NPH_VERSION		10200
# endif

/* compatibility for versions older than nph-1.2.0 */
# if NPH_VERSION < 10200
#  define PH_OPEN_ROUNDROBIN	PH_ROUNDROBIN
#  define PH_OPEN_DONTID	PH_DONTID
#  define PH_CLOSE_FAST		PH_FASTCLOSE
#  define PH_ERR_DATAERR	PH_DATAERR
#  define PH_ERR_NOMATCH	PH_NOMATCH
# endif /* NPH_VERSION < 10200 */

/*
**  PH_MAP_PARSEARGS -- parse ph map definition args.
*/

bool
ph_map_parseargs(map, args)
	MAP *map;
	char *args;
{
	register bool done;
	register char *p = args;
	PH_MAP_STRUCT *pmap = NULL;

	/* initialize version string */
	(void) sm_snprintf(phmap_id, sizeof(phmap_id),
			   "sendmail-%s phmap-20010529 libphclient-%s",
			   Version, libphclient_version);

	pmap = (PH_MAP_STRUCT *) xalloc(sizeof(*pmap));

	/* defaults */
	pmap->ph_servers = NULL;
	pmap->ph_field_list = NULL;
	pmap->ph = NULL;
	pmap->ph_timeout = 0;
	pmap->ph_fastclose = 0;

	map->map_mflags |= MF_TRY0NULL|MF_TRY1NULL;
	for (;;)
	{
		while (isascii(*p) && isspace(*p))
			p++;
		if (*p != '-')
			break;
		switch (*++p)
		{
		  case 'N':
			map->map_mflags |= MF_INCLNULL;
			map->map_mflags &= ~MF_TRY0NULL;
			break;

		  case 'O':
			map->map_mflags &= ~MF_TRY1NULL;
			break;

		  case 'o':
			map->map_mflags |= MF_OPTIONAL;
			break;

		  case 'f':
			map->map_mflags |= MF_NOFOLDCASE;
			break;

		  case 'm':
			map->map_mflags |= MF_MATCHONLY;
			break;

		  case 'A':
			map->map_mflags |= MF_APPEND;
			break;

		  case 'q':
			map->map_mflags |= MF_KEEPQUOTES;
			break;

		  case 't':
			map->map_mflags |= MF_NODEFER;
			break;

		  case 'a':
			map->map_app = ++p;
			break;

		  case 'T':
			map->map_tapp = ++p;
			break;

		  case 'l':
			while (isascii(*++p) && isspace(*p))
				continue;
			pmap->ph_timeout = atoi(p);
			break;

		  case 'S':
			map->map_spacesub = *++p;
			break;

		  case 'D':
			map->map_mflags |= MF_DEFER;
			break;

		  case 'h':		/* PH server list */
			while (isascii(*++p) && isspace(*p))
				continue;
			pmap->ph_servers = p;
			break;

		  case 'k':		/* fields to search for */
			while (isascii(*++p) && isspace(*p))
				continue;
			pmap->ph_field_list = p;
			break;

		  default:
			syserr("ph_map_parseargs: unknown option -%c", *p);
		}

		/* try to account for quoted strings */
		done = isascii(*p) && isspace(*p);
		while (*p != '\0' && !done)
		{
			if (*p == '"')
			{
				while (*++p != '"' && *p != '\0')
					continue;
				if (*p != '\0')
					p++;
			}
			else
				p++;
			done = isascii(*p) && isspace(*p);
		}

		if (*p != '\0')
			*p++ = '\0';
	}

	if (map->map_app != NULL)
		map->map_app = newstr(ph_map_dequote(map->map_app));
	if (map->map_tapp != NULL)
		map->map_tapp = newstr(ph_map_dequote(map->map_tapp));

	if (pmap->ph_field_list != NULL)
		pmap->ph_field_list = newstr(ph_map_dequote(pmap->ph_field_list));

	if (pmap->ph_servers != NULL)
		pmap->ph_servers = newstr(ph_map_dequote(pmap->ph_servers));
	else
	{
		syserr("ph_map_parseargs: -h flag is required");
		return false;
	}

	map->map_db1 = (ARBPTR_T) pmap;
	return true;
}

/*
**  PH_MAP_CLOSE -- close the connection to the ph server
*/

void
ph_map_close(map)
	MAP *map;
{
	PH_MAP_STRUCT *pmap;

	pmap = (PH_MAP_STRUCT *)map->map_db1;
	if (tTd(38, 9))
		sm_dprintf("ph_map_close(%s): pmap->ph_fastclose=%d\n",
			   map->map_mname, pmap->ph_fastclose);


	if (pmap->ph != NULL)
	{
		ph_set_sendhook(pmap->ph, NULL);
		ph_set_recvhook(pmap->ph, NULL);
		ph_close(pmap->ph, pmap->ph_fastclose);
	}

	map->map_mflags &= ~(MF_OPEN|MF_WRITABLE);
}

static jmp_buf  PHTimeout;

/* ARGSUSED */
static void
ph_timeout(unused)
	int unused;
{
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
	longjmp(PHTimeout, 1);
}

static void
#if NPH_VERSION >= 10200
ph_map_send_debug(appdata, text)
	void *appdata;
#else
ph_map_send_debug(text)
#endif
	char *text;
{
	if (LogLevel > 9)
		sm_syslog(LOG_NOTICE, CurEnv->e_id,
			  "ph_map_send_debug: ==> %s", text);
	if (tTd(38, 20))
		sm_dprintf("ph_map_send_debug: ==> %s\n", text);
}

static void
#if NPH_VERSION >= 10200
ph_map_recv_debug(appdata, text)
	void *appdata;
#else
ph_map_recv_debug(text)
#endif
	char *text;
{
	if (LogLevel > 10)
		sm_syslog(LOG_NOTICE, CurEnv->e_id,
			  "ph_map_recv_debug: <== %s", text);
	if (tTd(38, 21))
		sm_dprintf("ph_map_recv_debug: <== %s\n", text);
}

/*
**  PH_MAP_OPEN -- sub for opening PH map
*/
bool
ph_map_open(map, mode)
	MAP *map;
	int mode;
{
	PH_MAP_STRUCT *pmap;
	register SM_EVENT *ev = NULL;
	int save_errno = 0;
	char *hostlist, *host;

	if (tTd(38, 2))
		sm_dprintf("ph_map_open(%s)\n", map->map_mname);

	mode &= O_ACCMODE;
	if (mode != O_RDONLY)
	{
		/* issue a pseudo-error message */
		errno = SM_EMAPCANTWRITE;
		return false;
	}

	if (CurEnv != NULL && CurEnv->e_sendmode == SM_DEFER &&
	    bitset(MF_DEFER, map->map_mflags))
	{
		if (tTd(9, 1))
			sm_dprintf("ph_map_open(%s) => DEFERRED\n",
				   map->map_mname);

		/*
		**  Unset MF_DEFER here so that map_lookup() returns
		**  a temporary failure using the bogus map and
		**  map->map_tapp instead of the default permanent error.
		*/

		map->map_mflags &= ~MF_DEFER;
		return false;
	}

	pmap = (PH_MAP_STRUCT *)map->map_db1;
	pmap->ph_fastclose = 0;		/* refresh field for reopen */

	/* try each host in the list */
	hostlist = newstr(pmap->ph_servers);
	for (host = strtok(hostlist, " ");
	     host != NULL;
	     host = strtok(NULL, " "))
	{
		/* set timeout */
		if (pmap->ph_timeout != 0)
		{
			if (setjmp(PHTimeout) != 0)
			{
				ev = NULL;
				if (LogLevel > 1)
					sm_syslog(LOG_NOTICE, CurEnv->e_id,
						  "timeout connecting to PH server %.100s",
						  host);
				errno = ETIMEDOUT;
				goto ph_map_open_abort;
			}
			ev = sm_setevent(pmap->ph_timeout, ph_timeout, 0);
		}

		/* open connection to server */
		if (ph_open(&(pmap->ph), host,
			    PH_OPEN_ROUNDROBIN|PH_OPEN_DONTID,
			    ph_map_send_debug, ph_map_recv_debug
#if NPH_VERSION >= 10200
			    , NULL
#endif
			    ) == 0
		    && ph_id(pmap->ph, phmap_id) == 0)
		{
			if (ev != NULL)
				sm_clrevent(ev);
			sm_free(hostlist); /* XXX */
			return true;
		}

  ph_map_open_abort:
		save_errno = errno;
		if (ev != NULL)
			sm_clrevent(ev);
		pmap->ph_fastclose = PH_CLOSE_FAST;
		ph_map_close(map);
		errno = save_errno;
	}

	if (bitset(MF_NODEFER, map->map_mflags))
	{
		if (errno == 0)
			errno = EAGAIN;
		syserr("ph_map_open: %s: cannot connect to PH server",
		       map->map_mname);
	}
	else if (!bitset(MF_OPTIONAL, map->map_mflags) && LogLevel > 1)
		sm_syslog(LOG_NOTICE, CurEnv->e_id,
			  "ph_map_open: %s: cannot connect to PH server",
			  map->map_mname);
	sm_free(hostlist); /* XXX */
	return false;
}

/*
**  PH_MAP_LOOKUP -- look up key from ph server
*/

char *
ph_map_lookup(map, key, args, pstat)
	MAP *map;
	char *key;
	char **args;
	int *pstat;
{
	int i, save_errno = 0;
	register SM_EVENT *ev = NULL;
	PH_MAP_STRUCT *pmap;
	char *value = NULL;

	pmap = (PH_MAP_STRUCT *)map->map_db1;

	*pstat = EX_OK;

	/* set timeout */
	if (pmap->ph_timeout != 0)
	{
		if (setjmp(PHTimeout) != 0)
		{
			ev = NULL;
			if (LogLevel > 1)
				sm_syslog(LOG_NOTICE, CurEnv->e_id,
					  "timeout during PH lookup of %.100s",
					  key);
			errno = ETIMEDOUT;
			*pstat = EX_TEMPFAIL;
			goto ph_map_lookup_abort;
		}
		ev = sm_setevent(pmap->ph_timeout, ph_timeout, 0);
	}

	/* perform lookup */
	i = ph_email_resolve(pmap->ph, key, pmap->ph_field_list, &value);
	if (i == -1)
		*pstat = EX_TEMPFAIL;
	else if (i == PH_ERR_NOMATCH || i == PH_ERR_DATAERR)
		*pstat = EX_UNAVAILABLE;

  ph_map_lookup_abort:
	if (ev != NULL)
		sm_clrevent(ev);

	/*
	**  Close the connection if the timer popped
	**  or we got a temporary PH error
	*/

	if (*pstat == EX_TEMPFAIL)
	{
		save_errno = errno;
		pmap->ph_fastclose = PH_CLOSE_FAST;
		ph_map_close(map);
		errno = save_errno;
	}

	if (*pstat == EX_OK)
	{
		if (tTd(38,20))
			sm_dprintf("ph_map_lookup: %s => %s\n", key, value);

		if (bitset(MF_MATCHONLY, map->map_mflags))
			return map_rewrite(map, key, strlen(key), NULL);
		else
			return map_rewrite(map, value, strlen(value), args);
	}

	return NULL;
}
#endif /* PH_MAP */

/*
**  syslog map
*/

#define map_prio	map_lockfd	/* overload field */

/*
**  SYSLOG_MAP_PARSEARGS -- check for priority level to syslog messages.
*/

bool
syslog_map_parseargs(map, args)
	MAP *map;
	char *args;
{
	char *p = args;
	char *priority = NULL;

	/* there is no check whether there is really an argument */
	while (*p != '\0')
	{
		while (isascii(*p) && isspace(*p))
			p++;
		if (*p != '-')
			break;
		++p;
		if (*p == 'D')
		{
			map->map_mflags |= MF_DEFER;
			++p;
		}
		else if (*p == 'S')
		{
			map->map_spacesub = *++p;
			if (*p != '\0')
				p++;
		}
		else if (*p == 'L')
		{
			while (*++p != '\0' && isascii(*p) && isspace(*p))
				continue;
			if (*p == '\0')
				break;
			priority = p;
			while (*p != '\0' && !(isascii(*p) && isspace(*p)))
				p++;
			if (*p != '\0')
				*p++ = '\0';
		}
		else
		{
			syserr("Illegal option %c map syslog", *p);
			++p;
		}
	}

	if (priority == NULL)
		map->map_prio = LOG_INFO;
	else
	{
		if (sm_strncasecmp("LOG_", priority, 4) == 0)
			priority += 4;

#ifdef LOG_EMERG
		if (sm_strcasecmp("EMERG", priority) == 0)
			map->map_prio = LOG_EMERG;
		else
#endif /* LOG_EMERG */
#ifdef LOG_ALERT
		if (sm_strcasecmp("ALERT", priority) == 0)
			map->map_prio = LOG_ALERT;
		else
#endif /* LOG_ALERT */
#ifdef LOG_CRIT
		if (sm_strcasecmp("CRIT", priority) == 0)
			map->map_prio = LOG_CRIT;
		else
#endif /* LOG_CRIT */
#ifdef LOG_ERR
		if (sm_strcasecmp("ERR", priority) == 0)
			map->map_prio = LOG_ERR;
		else
#endif /* LOG_ERR */
#ifdef LOG_WARNING
		if (sm_strcasecmp("WARNING", priority) == 0)
			map->map_prio = LOG_WARNING;
		else
#endif /* LOG_WARNING */
#ifdef LOG_NOTICE
		if (sm_strcasecmp("NOTICE", priority) == 0)
			map->map_prio = LOG_NOTICE;
		else
#endif /* LOG_NOTICE */
#ifdef LOG_INFO
		if (sm_strcasecmp("INFO", priority) == 0)
			map->map_prio = LOG_INFO;
		else
#endif /* LOG_INFO */
#ifdef LOG_DEBUG
		if (sm_strcasecmp("DEBUG", priority) == 0)
			map->map_prio = LOG_DEBUG;
		else
#endif /* LOG_DEBUG */
		{
			syserr("syslog_map_parseargs: Unknown priority %s",
			       priority);
			return false;
		}
	}
	return true;
}

/*
**  SYSLOG_MAP_LOOKUP -- rewrite and syslog message.  Always return empty string
*/

char *
syslog_map_lookup(map, string, args, statp)
	MAP *map;
	char *string;
	char **args;
	int *statp;
{
	char *ptr = map_rewrite(map, string, strlen(string), args);

	if (ptr != NULL)
	{
		if (tTd(38, 20))
			sm_dprintf("syslog_map_lookup(%s (priority %d): %s\n",
				map->map_mname, map->map_prio, ptr);

		sm_syslog(map->map_prio, CurEnv->e_id, "%s", ptr);
	}

	*statp = EX_OK;
	return "";
}

#if _FFR_DPRINTF_MAP
/*
**  dprintf map
*/

#define map_dbg_level	map_lockfd	/* overload field */

/*
**  DPRINTF_MAP_PARSEARGS -- check for priority level to dprintf messages.
*/

bool
dprintf_map_parseargs(map, args)
	MAP *map;
	char *args;
{
	char *p = args;
	char *dbg_level = NULL;

	/* there is no check whether there is really an argument */
	while (*p != '\0')
	{
		while (isascii(*p) && isspace(*p))
			p++;
		if (*p != '-')
			break;
		++p;
		if (*p == 'D')
		{
			map->map_mflags |= MF_DEFER;
			++p;
		}
		else if (*p == 'S')
		{
			map->map_spacesub = *++p;
			if (*p != '\0')
				p++;
		}
		else if (*p == 'd')
		{
			while (*++p != '\0' && isascii(*p) && isspace(*p))
				continue;
			if (*p == '\0')
				break;
			dbg_level = p;
			while (*p != '\0' && !(isascii(*p) && isspace(*p)))
				p++;
			if (*p != '\0')
				*p++ = '\0';
		}
		else
		{
			syserr("Illegal option %c map dprintf", *p);
			++p;
		}
	}

	if (dbg_level == NULL)
		map->map_dbg_level = 0;
	else
	{
		if (!(isascii(*dbg_level) && isdigit(*dbg_level)))
		{
			syserr("dprintf map \"%s\", file %s: -d should specify a number, not %s",
				map->map_mname, map->map_file,
				dbg_level);
			return false;
		}
		map->map_dbg_level = atoi(dbg_level);
	}
	return true;
}

/*
**  DPRINTF_MAP_LOOKUP -- rewrite and print message.  Always return empty string
*/

char *
dprintf_map_lookup(map, string, args, statp)
	MAP *map;
	char *string;
	char **args;
	int *statp;
{
	char *ptr = map_rewrite(map, string, strlen(string), args);

	if (ptr != NULL && tTd(85, map->map_dbg_level))
		sm_dprintf("%s\n", ptr);
	*statp = EX_OK;
	return "";
}
#endif /* _FFR_DPRINTF_MAP */

/*
**  HESIOD Modules
*/

#if HESIOD

bool
hes_map_open(map, mode)
	MAP *map;
	int mode;
{
	if (tTd(38, 2))
		sm_dprintf("hes_map_open(%s, %s, %d)\n",
			map->map_mname, map->map_file, mode);

	if (mode != O_RDONLY)
	{
		/* issue a pseudo-error message */
		errno = SM_EMAPCANTWRITE;
		return false;
	}

# ifdef HESIOD_INIT
	if (HesiodContext != NULL || hesiod_init(&HesiodContext) == 0)
		return true;

	if (!bitset(MF_OPTIONAL, map->map_mflags))
		syserr("451 4.3.5 cannot initialize Hesiod map (%s)",
			sm_errstring(errno));
	return false;
# else /* HESIOD_INIT */
	if (hes_error() == HES_ER_UNINIT)
		hes_init();
	switch (hes_error())
	{
	  case HES_ER_OK:
	  case HES_ER_NOTFOUND:
		return true;
	}

	if (!bitset(MF_OPTIONAL, map->map_mflags))
		syserr("451 4.3.5 cannot initialize Hesiod map (%d)", hes_error());

	return false;
# endif /* HESIOD_INIT */
}

char *
hes_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	char **hp;

	if (tTd(38, 20))
		sm_dprintf("hes_map_lookup(%s, %s)\n", map->map_file, name);

	if (name[0] == '\\')
	{
		char *np;
		int nl;
		int save_errno;
		char nbuf[MAXNAME];

		nl = strlen(name);
		if (nl < sizeof(nbuf) - 1)
			np = nbuf;
		else
			np = xalloc(strlen(name) + 2);
		np[0] = '\\';
		(void) sm_strlcpy(&np[1], name, (sizeof(nbuf)) - 1);
# ifdef HESIOD_INIT
		hp = hesiod_resolve(HesiodContext, np, map->map_file);
# else /* HESIOD_INIT */
		hp = hes_resolve(np, map->map_file);
# endif /* HESIOD_INIT */
		save_errno = errno;
		if (np != nbuf)
			sm_free(np); /* XXX */
		errno = save_errno;
	}
	else
	{
# ifdef HESIOD_INIT
		hp = hesiod_resolve(HesiodContext, name, map->map_file);
# else /* HESIOD_INIT */
		hp = hes_resolve(name, map->map_file);
# endif /* HESIOD_INIT */
	}
# ifdef HESIOD_INIT
	if (hp == NULL || *hp == NULL)
	{
		switch (errno)
		{
		  case ENOENT:
			  *statp = EX_NOTFOUND;
			  break;
		  case ECONNREFUSED:
			  *statp = EX_TEMPFAIL;
			  break;
		  case EMSGSIZE:
		  case ENOMEM:
		  default:
			  *statp = EX_UNAVAILABLE;
			  break;
		}
		if (hp != NULL)
			hesiod_free_list(HesiodContext, hp);
		return NULL;
	}
# else /* HESIOD_INIT */
	if (hp == NULL || hp[0] == NULL)
	{
		switch (hes_error())
		{
		  case HES_ER_OK:
			*statp = EX_OK;
			break;

		  case HES_ER_NOTFOUND:
			*statp = EX_NOTFOUND;
			break;

		  case HES_ER_CONFIG:
			*statp = EX_UNAVAILABLE;
			break;

		  case HES_ER_NET:
			*statp = EX_TEMPFAIL;
			break;
		}
		return NULL;
	}
# endif /* HESIOD_INIT */

	if (bitset(MF_MATCHONLY, map->map_mflags))
		return map_rewrite(map, name, strlen(name), NULL);
	else
		return map_rewrite(map, hp[0], strlen(hp[0]), av);
}

/*
**  HES_MAP_CLOSE -- free the Hesiod context
*/

void
hes_map_close(map)
	MAP *map;
{
	if (tTd(38, 20))
		sm_dprintf("hes_map_close(%s)\n", map->map_file);

# ifdef HESIOD_INIT
	/* Free the hesiod context */
	if (HesiodContext != NULL)
	{
		hesiod_end(HesiodContext);
		HesiodContext = NULL;
	}
# endif /* HESIOD_INIT */
}

#endif /* HESIOD */
/*
**  NeXT NETINFO Modules
*/

#if NETINFO

# define NETINFO_DEFAULT_DIR		"/aliases"
# define NETINFO_DEFAULT_PROPERTY	"members"

/*
**  NI_MAP_OPEN -- open NetInfo Aliases
*/

bool
ni_map_open(map, mode)
	MAP *map;
	int mode;
{
	if (tTd(38, 2))
		sm_dprintf("ni_map_open(%s, %s, %d)\n",
			map->map_mname, map->map_file, mode);
	mode &= O_ACCMODE;

	if (*map->map_file == '\0')
		map->map_file = NETINFO_DEFAULT_DIR;

	if (map->map_valcolnm == NULL)
		map->map_valcolnm = NETINFO_DEFAULT_PROPERTY;

	if (map->map_coldelim == '\0')
	{
		if (bitset(MF_ALIAS, map->map_mflags))
			map->map_coldelim = ',';
		else if (bitset(MF_FILECLASS, map->map_mflags))
			map->map_coldelim = ' ';
	}
	return true;
}


/*
**  NI_MAP_LOOKUP -- look up a datum in NetInfo
*/

char *
ni_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	char *res;
	char *propval;

	if (tTd(38, 20))
		sm_dprintf("ni_map_lookup(%s, %s)\n", map->map_mname, name);

	propval = ni_propval(map->map_file, map->map_keycolnm, name,
			     map->map_valcolnm, map->map_coldelim);

	if (propval == NULL)
		return NULL;

	SM_TRY
		if (bitset(MF_MATCHONLY, map->map_mflags))
			res = map_rewrite(map, name, strlen(name), NULL);
		else
			res = map_rewrite(map, propval, strlen(propval), av);
	SM_FINALLY
		sm_free(propval);
	SM_END_TRY
	return res;
}


static bool
ni_getcanonname(name, hbsize, statp)
	char *name;
	int hbsize;
	int *statp;
{
	char *vptr;
	char *ptr;
	char nbuf[MAXNAME + 1];

	if (tTd(38, 20))
		sm_dprintf("ni_getcanonname(%s)\n", name);

	if (sm_strlcpy(nbuf, name, sizeof(nbuf)) >= sizeof(nbuf))
	{
		*statp = EX_UNAVAILABLE;
		return false;
	}
	(void) shorten_hostname(nbuf);

	/* we only accept single token search key */
	if (strchr(nbuf, '.'))
	{
		*statp = EX_NOHOST;
		return false;
	}

	/* Do the search */
	vptr = ni_propval("/machines", NULL, nbuf, "name", '\n');

	if (vptr == NULL)
	{
		*statp = EX_NOHOST;
		return false;
	}

	/* Only want the first machine name */
	if ((ptr = strchr(vptr, '\n')) != NULL)
		*ptr = '\0';

	if (sm_strlcpy(name, vptr, hbsize) >= hbsize)
	{
		sm_free(vptr);
		*statp = EX_UNAVAILABLE;
		return true;
	}
	sm_free(vptr);
	*statp = EX_OK;
	return false;
}
#endif /* NETINFO */
/*
**  TEXT (unindexed text file) Modules
**
**	This code donated by Sun Microsystems.
*/

#define map_sff		map_lockfd	/* overload field */


/*
**  TEXT_MAP_OPEN -- open text table
*/

bool
text_map_open(map, mode)
	MAP *map;
	int mode;
{
	long sff;
	int i;

	if (tTd(38, 2))
		sm_dprintf("text_map_open(%s, %s, %d)\n",
			map->map_mname, map->map_file, mode);

	mode &= O_ACCMODE;
	if (mode != O_RDONLY)
	{
		errno = EPERM;
		return false;
	}

	if (*map->map_file == '\0')
	{
		syserr("text map \"%s\": file name required",
			map->map_mname);
		return false;
	}

	if (map->map_file[0] != '/')
	{
		syserr("text map \"%s\": file name must be fully qualified",
			map->map_mname);
		return false;
	}

	sff = SFF_ROOTOK|SFF_REGONLY;
	if (!bitnset(DBS_LINKEDMAPINWRITABLEDIR, DontBlameSendmail))
		sff |= SFF_NOWLINK;
	if (!bitnset(DBS_MAPINUNSAFEDIRPATH, DontBlameSendmail))
		sff |= SFF_SAFEDIRPATH;
	if ((i = safefile(map->map_file, RunAsUid, RunAsGid, RunAsUserName,
			  sff, S_IRUSR, NULL)) != 0)
	{
		int save_errno = errno;

		/* cannot open this map */
		if (tTd(38, 2))
			sm_dprintf("\tunsafe map file: %d\n", i);
		errno = save_errno;
		if (!bitset(MF_OPTIONAL, map->map_mflags))
			syserr("text map \"%s\": unsafe map file %s",
				map->map_mname, map->map_file);
		return false;
	}

	if (map->map_keycolnm == NULL)
		map->map_keycolno = 0;
	else
	{
		if (!(isascii(*map->map_keycolnm) && isdigit(*map->map_keycolnm)))
		{
			syserr("text map \"%s\", file %s: -k should specify a number, not %s",
				map->map_mname, map->map_file,
				map->map_keycolnm);
			return false;
		}
		map->map_keycolno = atoi(map->map_keycolnm);
	}

	if (map->map_valcolnm == NULL)
		map->map_valcolno = 0;
	else
	{
		if (!(isascii(*map->map_valcolnm) && isdigit(*map->map_valcolnm)))
		{
			syserr("text map \"%s\", file %s: -v should specify a number, not %s",
					map->map_mname, map->map_file,
					map->map_valcolnm);
			return false;
		}
		map->map_valcolno = atoi(map->map_valcolnm);
	}

	if (tTd(38, 2))
	{
		sm_dprintf("text_map_open(%s, %s): delimiter = ",
			map->map_mname, map->map_file);
		if (map->map_coldelim == '\0')
			sm_dprintf("(white space)\n");
		else
			sm_dprintf("%c\n", map->map_coldelim);
	}

	map->map_sff = sff;
	return true;
}


/*
**  TEXT_MAP_LOOKUP -- look up a datum in a TEXT table
*/

char *
text_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	char *vp;
	auto int vsize;
	int buflen;
	SM_FILE_T *f;
	char delim;
	int key_idx;
	bool found_it;
	long sff = map->map_sff;
	char search_key[MAXNAME + 1];
	char linebuf[MAXLINE];
	char buf[MAXNAME + 1];

	found_it = false;
	if (tTd(38, 20))
		sm_dprintf("text_map_lookup(%s, %s)\n", map->map_mname,  name);

	buflen = strlen(name);
	if (buflen > sizeof(search_key) - 1)
		buflen = sizeof(search_key) - 1;	/* XXX just cut if off? */
	memmove(search_key, name, buflen);
	search_key[buflen] = '\0';
	if (!bitset(MF_NOFOLDCASE, map->map_mflags))
		makelower(search_key);

	f = safefopen(map->map_file, O_RDONLY, FileMode, sff);
	if (f == NULL)
	{
		map->map_mflags &= ~(MF_VALID|MF_OPEN);
		*statp = EX_UNAVAILABLE;
		return NULL;
	}
	key_idx = map->map_keycolno;
	delim = map->map_coldelim;
	while (sm_io_fgets(f, SM_TIME_DEFAULT,
			   linebuf, sizeof(linebuf)) >= 0)
	{
		char *p;

		/* skip comment line */
		if (linebuf[0] == '#')
			continue;
		p = strchr(linebuf, '\n');
		if (p != NULL)
			*p = '\0';
		p = get_column(linebuf, key_idx, delim, buf, sizeof(buf));
		if (p != NULL && sm_strcasecmp(search_key, p) == 0)
		{
			found_it = true;
			break;
		}
	}
	(void) sm_io_close(f, SM_TIME_DEFAULT);
	if (!found_it)
	{
		*statp = EX_NOTFOUND;
		return NULL;
	}
	vp = get_column(linebuf, map->map_valcolno, delim, buf, sizeof(buf));
	if (vp == NULL)
	{
		*statp = EX_NOTFOUND;
		return NULL;
	}
	vsize = strlen(vp);
	*statp = EX_OK;
	if (bitset(MF_MATCHONLY, map->map_mflags))
		return map_rewrite(map, name, strlen(name), NULL);
	else
		return map_rewrite(map, vp, vsize, av);
}

/*
**  TEXT_GETCANONNAME -- look up canonical name in hosts file
*/

static bool
text_getcanonname(name, hbsize, statp)
	char *name;
	int hbsize;
	int *statp;
{
	bool found;
	char *dot;
	SM_FILE_T *f;
	char linebuf[MAXLINE];
	char cbuf[MAXNAME + 1];
	char nbuf[MAXNAME + 1];

	if (tTd(38, 20))
		sm_dprintf("text_getcanonname(%s)\n", name);

	if (sm_strlcpy(nbuf, name, sizeof(nbuf)) >= sizeof(nbuf))
	{
		*statp = EX_UNAVAILABLE;
		return false;
	}
	dot = shorten_hostname(nbuf);

	f = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, HostsFile, SM_IO_RDONLY,
		       NULL);
	if (f == NULL)
	{
		*statp = EX_UNAVAILABLE;
		return false;
	}
	found = false;
	while (!found &&
		sm_io_fgets(f, SM_TIME_DEFAULT,
			    linebuf, sizeof(linebuf)) >= 0)
	{
		char *p = strpbrk(linebuf, "#\n");

		if (p != NULL)
			*p = '\0';
		if (linebuf[0] != '\0')
			found = extract_canonname(nbuf, dot, linebuf,
						  cbuf, sizeof(cbuf));
	}
	(void) sm_io_close(f, SM_TIME_DEFAULT);
	if (!found)
	{
		*statp = EX_NOHOST;
		return false;
	}

	if (sm_strlcpy(name, cbuf, hbsize) >= hbsize)
	{
		*statp = EX_UNAVAILABLE;
		return false;
	}
	*statp = EX_OK;
	return true;
}
/*
**  STAB (Symbol Table) Modules
*/


/*
**  STAB_MAP_LOOKUP -- look up alias in symbol table
*/

/* ARGSUSED2 */
char *
stab_map_lookup(map, name, av, pstat)
	register MAP *map;
	char *name;
	char **av;
	int *pstat;
{
	register STAB *s;

	if (tTd(38, 20))
		sm_dprintf("stab_lookup(%s, %s)\n",
			map->map_mname, name);

	s = stab(name, ST_ALIAS, ST_FIND);
	if (s == NULL)
		return NULL;
	if (bitset(MF_MATCHONLY, map->map_mflags))
		return map_rewrite(map, name, strlen(name), NULL);
	else
		return map_rewrite(map, s->s_alias, strlen(s->s_alias), av);
}

/*
**  STAB_MAP_STORE -- store in symtab (actually using during init, not rebuild)
*/

void
stab_map_store(map, lhs, rhs)
	register MAP *map;
	char *lhs;
	char *rhs;
{
	register STAB *s;

	s = stab(lhs, ST_ALIAS, ST_ENTER);
	s->s_alias = newstr(rhs);
}


/*
**  STAB_MAP_OPEN -- initialize (reads data file)
**
**	This is a weird case -- it is only intended as a fallback for
**	aliases.  For this reason, opens for write (only during a
**	"newaliases") always fails, and opens for read open the
**	actual underlying text file instead of the database.
*/

bool
stab_map_open(map, mode)
	register MAP *map;
	int mode;
{
	SM_FILE_T *af;
	long sff;
	struct stat st;

	if (tTd(38, 2))
		sm_dprintf("stab_map_open(%s, %s, %d)\n",
			map->map_mname, map->map_file, mode);

	mode &= O_ACCMODE;
	if (mode != O_RDONLY)
	{
		errno = EPERM;
		return false;
	}

	sff = SFF_ROOTOK|SFF_REGONLY;
	if (!bitnset(DBS_LINKEDMAPINWRITABLEDIR, DontBlameSendmail))
		sff |= SFF_NOWLINK;
	if (!bitnset(DBS_MAPINUNSAFEDIRPATH, DontBlameSendmail))
		sff |= SFF_SAFEDIRPATH;
	af = safefopen(map->map_file, O_RDONLY, 0444, sff);
	if (af == NULL)
		return false;
	readaliases(map, af, false, false);

	if (fstat(sm_io_getinfo(af, SM_IO_WHAT_FD, NULL), &st) >= 0)
		map->map_mtime = st.st_mtime;
	(void) sm_io_close(af, SM_TIME_DEFAULT);

	return true;
}
/*
**  Implicit Modules
**
**	Tries several types.  For back compatibility of aliases.
*/


/*
**  IMPL_MAP_LOOKUP -- lookup in best open database
*/

char *
impl_map_lookup(map, name, av, pstat)
	MAP *map;
	char *name;
	char **av;
	int *pstat;
{
	if (tTd(38, 20))
		sm_dprintf("impl_map_lookup(%s, %s)\n",
			map->map_mname, name);

#if NEWDB
	if (bitset(MF_IMPL_HASH, map->map_mflags))
		return db_map_lookup(map, name, av, pstat);
#endif /* NEWDB */
#if NDBM
	if (bitset(MF_IMPL_NDBM, map->map_mflags))
		return ndbm_map_lookup(map, name, av, pstat);
#endif /* NDBM */
	return stab_map_lookup(map, name, av, pstat);
}

/*
**  IMPL_MAP_STORE -- store in open databases
*/

void
impl_map_store(map, lhs, rhs)
	MAP *map;
	char *lhs;
	char *rhs;
{
	if (tTd(38, 12))
		sm_dprintf("impl_map_store(%s, %s, %s)\n",
			map->map_mname, lhs, rhs);
#if NEWDB
	if (bitset(MF_IMPL_HASH, map->map_mflags))
		db_map_store(map, lhs, rhs);
#endif /* NEWDB */
#if NDBM
	if (bitset(MF_IMPL_NDBM, map->map_mflags))
		ndbm_map_store(map, lhs, rhs);
#endif /* NDBM */
	stab_map_store(map, lhs, rhs);
}

/*
**  IMPL_MAP_OPEN -- implicit database open
*/

bool
impl_map_open(map, mode)
	MAP *map;
	int mode;
{
	if (tTd(38, 2))
		sm_dprintf("impl_map_open(%s, %s, %d)\n",
			map->map_mname, map->map_file, mode);

	mode &= O_ACCMODE;
#if NEWDB
	map->map_mflags |= MF_IMPL_HASH;
	if (hash_map_open(map, mode))
	{
# ifdef NDBM_YP_COMPAT
		if (mode == O_RDONLY || strstr(map->map_file, "/yp/") == NULL)
# endif /* NDBM_YP_COMPAT */
			return true;
	}
	else
		map->map_mflags &= ~MF_IMPL_HASH;
#endif /* NEWDB */
#if NDBM
	map->map_mflags |= MF_IMPL_NDBM;
	if (ndbm_map_open(map, mode))
	{
		return true;
	}
	else
		map->map_mflags &= ~MF_IMPL_NDBM;
#endif /* NDBM */

#if defined(NEWDB) || defined(NDBM)
	if (Verbose)
		message("WARNING: cannot open alias database %s%s",
			map->map_file,
			mode == O_RDONLY ? "; reading text version" : "");
#else /* defined(NEWDB) || defined(NDBM) */
	if (mode != O_RDONLY)
		usrerr("Cannot rebuild aliases: no database format defined");
#endif /* defined(NEWDB) || defined(NDBM) */

	if (mode == O_RDONLY)
		return stab_map_open(map, mode);
	else
		return false;
}


/*
**  IMPL_MAP_CLOSE -- close any open database(s)
*/

void
impl_map_close(map)
	MAP *map;
{
	if (tTd(38, 9))
		sm_dprintf("impl_map_close(%s, %s, %lx)\n",
			map->map_mname, map->map_file, map->map_mflags);
#if NEWDB
	if (bitset(MF_IMPL_HASH, map->map_mflags))
	{
		db_map_close(map);
		map->map_mflags &= ~MF_IMPL_HASH;
	}
#endif /* NEWDB */

#if NDBM
	if (bitset(MF_IMPL_NDBM, map->map_mflags))
	{
		ndbm_map_close(map);
		map->map_mflags &= ~MF_IMPL_NDBM;
	}
#endif /* NDBM */
}
/*
**  User map class.
**
**	Provides access to the system password file.
*/

/*
**  USER_MAP_OPEN -- open user map
**
**	Really just binds field names to field numbers.
*/

bool
user_map_open(map, mode)
	MAP *map;
	int mode;
{
	if (tTd(38, 2))
		sm_dprintf("user_map_open(%s, %d)\n",
			map->map_mname, mode);

	mode &= O_ACCMODE;
	if (mode != O_RDONLY)
	{
		/* issue a pseudo-error message */
		errno = SM_EMAPCANTWRITE;
		return false;
	}
	if (map->map_valcolnm == NULL)
		/* EMPTY */
		/* nothing */ ;
	else if (sm_strcasecmp(map->map_valcolnm, "name") == 0)
		map->map_valcolno = 1;
	else if (sm_strcasecmp(map->map_valcolnm, "passwd") == 0)
		map->map_valcolno = 2;
	else if (sm_strcasecmp(map->map_valcolnm, "uid") == 0)
		map->map_valcolno = 3;
	else if (sm_strcasecmp(map->map_valcolnm, "gid") == 0)
		map->map_valcolno = 4;
	else if (sm_strcasecmp(map->map_valcolnm, "gecos") == 0)
		map->map_valcolno = 5;
	else if (sm_strcasecmp(map->map_valcolnm, "dir") == 0)
		map->map_valcolno = 6;
	else if (sm_strcasecmp(map->map_valcolnm, "shell") == 0)
		map->map_valcolno = 7;
	else
	{
		syserr("User map %s: unknown column name %s",
			map->map_mname, map->map_valcolnm);
		return false;
	}
	return true;
}


/*
**  USER_MAP_LOOKUP -- look up a user in the passwd file.
*/

/* ARGSUSED3 */
char *
user_map_lookup(map, key, av, statp)
	MAP *map;
	char *key;
	char **av;
	int *statp;
{
	auto bool fuzzy;
	SM_MBDB_T user;

	if (tTd(38, 20))
		sm_dprintf("user_map_lookup(%s, %s)\n",
			map->map_mname, key);

	*statp = finduser(key, &fuzzy, &user);
	if (*statp != EX_OK)
		return NULL;
	if (bitset(MF_MATCHONLY, map->map_mflags))
		return map_rewrite(map, key, strlen(key), NULL);
	else
	{
		char *rwval = NULL;
		char buf[30];

		switch (map->map_valcolno)
		{
		  case 0:
		  case 1:
			rwval = user.mbdb_name;
			break;

		  case 2:
			rwval = "x";	/* passwd no longer supported */
			break;

		  case 3:
			(void) sm_snprintf(buf, sizeof(buf), "%d",
					   (int) user.mbdb_uid);
			rwval = buf;
			break;

		  case 4:
			(void) sm_snprintf(buf, sizeof(buf), "%d",
					   (int) user.mbdb_gid);
			rwval = buf;
			break;

		  case 5:
			rwval = user.mbdb_fullname;
			break;

		  case 6:
			rwval = user.mbdb_homedir;
			break;

		  case 7:
			rwval = user.mbdb_shell;
			break;
		  default:
			syserr("user_map %s: bogus field %d",
				map->map_mname, map->map_valcolno);
			return NULL;
		}
		return map_rewrite(map, rwval, strlen(rwval), av);
	}
}
/*
**  Program map type.
**
**	This provides access to arbitrary programs.  It should be used
**	only very sparingly, since there is no way to bound the cost
**	of invoking an arbitrary program.
*/

char *
prog_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	int i;
	int save_errno;
	int fd;
	int status;
	auto pid_t pid;
	register char *p;
	char *rval;
	char *argv[MAXPV + 1];
	char buf[MAXLINE];

	if (tTd(38, 20))
		sm_dprintf("prog_map_lookup(%s, %s) %s\n",
			map->map_mname, name, map->map_file);

	i = 0;
	argv[i++] = map->map_file;
	if (map->map_rebuild != NULL)
	{
		(void) sm_strlcpy(buf, map->map_rebuild, sizeof(buf));
		for (p = strtok(buf, " \t"); p != NULL; p = strtok(NULL, " \t"))
		{
			if (i >= MAXPV - 1)
				break;
			argv[i++] = p;
		}
	}
	argv[i++] = name;
	argv[i] = NULL;
	if (tTd(38, 21))
	{
		sm_dprintf("prog_open:");
		for (i = 0; argv[i] != NULL; i++)
			sm_dprintf(" %s", argv[i]);
		sm_dprintf("\n");
	}
	(void) sm_blocksignal(SIGCHLD);
	pid = prog_open(argv, &fd, CurEnv);
	if (pid < 0)
	{
		if (!bitset(MF_OPTIONAL, map->map_mflags))
			syserr("prog_map_lookup(%s) failed (%s) -- closing",
			       map->map_mname, sm_errstring(errno));
		else if (tTd(38, 9))
			sm_dprintf("prog_map_lookup(%s) failed (%s) -- closing",
				   map->map_mname, sm_errstring(errno));
		map->map_mflags &= ~(MF_VALID|MF_OPEN);
		*statp = EX_OSFILE;
		return NULL;
	}
	i = read(fd, buf, sizeof(buf) - 1);
	if (i < 0)
	{
		syserr("prog_map_lookup(%s): read error %s",
		       map->map_mname, sm_errstring(errno));
		rval = NULL;
	}
	else if (i == 0)
	{
		if (tTd(38, 20))
			sm_dprintf("prog_map_lookup(%s): empty answer\n",
				   map->map_mname);
		rval = NULL;
	}
	else
	{
		buf[i] = '\0';
		p = strchr(buf, '\n');
		if (p != NULL)
			*p = '\0';

		/* collect the return value */
		if (bitset(MF_MATCHONLY, map->map_mflags))
			rval = map_rewrite(map, name, strlen(name), NULL);
		else
			rval = map_rewrite(map, buf, strlen(buf), av);

		/* now flush any additional output */
		while ((i = read(fd, buf, sizeof(buf))) > 0)
			continue;
	}

	/* wait for the process to terminate */
	(void) close(fd);
	status = waitfor(pid);
	save_errno = errno;
	(void) sm_releasesignal(SIGCHLD);
	errno = save_errno;

	if (status == -1)
	{
		syserr("prog_map_lookup(%s): wait error %s",
		       map->map_mname, sm_errstring(errno));
		*statp = EX_SOFTWARE;
		rval = NULL;
	}
	else if (WIFEXITED(status))
	{
		if ((*statp = WEXITSTATUS(status)) != EX_OK)
			rval = NULL;
	}
	else
	{
		syserr("prog_map_lookup(%s): child died on signal %d",
		       map->map_mname, status);
		*statp = EX_UNAVAILABLE;
		rval = NULL;
	}
	return rval;
}
/*
**  Sequenced map type.
**
**	Tries each map in order until something matches, much like
**	implicit.  Stores go to the first map in the list that can
**	support storing.
**
**	This is slightly unusual in that there are two interfaces.
**	The "sequence" interface lets you stack maps arbitrarily.
**	The "switch" interface builds a sequence map by looking
**	at a system-dependent configuration file such as
**	/etc/nsswitch.conf on Solaris or /etc/svc.conf on Ultrix.
**
**	We don't need an explicit open, since all maps are
**	opened on demand.
*/

/*
**  SEQ_MAP_PARSE -- Sequenced map parsing
*/

bool
seq_map_parse(map, ap)
	MAP *map;
	char *ap;
{
	int maxmap;

	if (tTd(38, 2))
		sm_dprintf("seq_map_parse(%s, %s)\n", map->map_mname, ap);
	maxmap = 0;
	while (*ap != '\0')
	{
		register char *p;
		STAB *s;

		/* find beginning of map name */
		while (isascii(*ap) && isspace(*ap))
			ap++;
		for (p = ap;
		     (isascii(*p) && isalnum(*p)) || *p == '_' || *p == '.';
		     p++)
			continue;
		if (*p != '\0')
			*p++ = '\0';
		while (*p != '\0' && (!isascii(*p) || !isalnum(*p)))
			p++;
		if (*ap == '\0')
		{
			ap = p;
			continue;
		}
		s = stab(ap, ST_MAP, ST_FIND);
		if (s == NULL)
		{
			syserr("Sequence map %s: unknown member map %s",
				map->map_mname, ap);
		}
		else if (maxmap >= MAXMAPSTACK)
		{
			syserr("Sequence map %s: too many member maps (%d max)",
				map->map_mname, MAXMAPSTACK);
			maxmap++;
		}
		else if (maxmap < MAXMAPSTACK)
		{
			map->map_stack[maxmap++] = &s->s_map;
		}
		ap = p;
	}
	return true;
}

/*
**  SWITCH_MAP_OPEN -- open a switched map
**
**	This looks at the system-dependent configuration and builds
**	a sequence map that does the same thing.
**
**	Every system must define a switch_map_find routine in conf.c
**	that will return the list of service types associated with a
**	given service class.
*/

bool
switch_map_open(map, mode)
	MAP *map;
	int mode;
{
	int mapno;
	int nmaps;
	char *maptype[MAXMAPSTACK];

	if (tTd(38, 2))
		sm_dprintf("switch_map_open(%s, %s, %d)\n",
			map->map_mname, map->map_file, mode);

	mode &= O_ACCMODE;
	nmaps = switch_map_find(map->map_file, maptype, map->map_return);
	if (tTd(38, 19))
	{
		sm_dprintf("\tswitch_map_find => %d\n", nmaps);
		for (mapno = 0; mapno < nmaps; mapno++)
			sm_dprintf("\t\t%s\n", maptype[mapno]);
	}
	if (nmaps <= 0 || nmaps > MAXMAPSTACK)
		return false;

	for (mapno = 0; mapno < nmaps; mapno++)
	{
		register STAB *s;
		char nbuf[MAXNAME + 1];

		if (maptype[mapno] == NULL)
			continue;
		(void) sm_strlcpyn(nbuf, sizeof(nbuf), 3,
				   map->map_mname, ".", maptype[mapno]);
		s = stab(nbuf, ST_MAP, ST_FIND);
		if (s == NULL)
		{
			syserr("Switch map %s: unknown member map %s",
				map->map_mname, nbuf);
		}
		else
		{
			map->map_stack[mapno] = &s->s_map;
			if (tTd(38, 4))
				sm_dprintf("\tmap_stack[%d] = %s:%s\n",
					   mapno,
					   s->s_map.map_class->map_cname,
					   nbuf);
		}
	}
	return true;
}

#if 0
/*
**  SEQ_MAP_CLOSE -- close all underlying maps
*/

void
seq_map_close(map)
	MAP *map;
{
	int mapno;

	if (tTd(38, 9))
		sm_dprintf("seq_map_close(%s)\n", map->map_mname);

	for (mapno = 0; mapno < MAXMAPSTACK; mapno++)
	{
		MAP *mm = map->map_stack[mapno];

		if (mm == NULL || !bitset(MF_OPEN, mm->map_mflags))
			continue;
		mm->map_mflags |= MF_CLOSING;
		mm->map_class->map_close(mm);
		mm->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
	}
}
#endif /* 0 */

/*
**  SEQ_MAP_LOOKUP -- sequenced map lookup
*/

char *
seq_map_lookup(map, key, args, pstat)
	MAP *map;
	char *key;
	char **args;
	int *pstat;
{
	int mapno;
	int mapbit = 0x01;
	bool tempfail = false;

	if (tTd(38, 20))
		sm_dprintf("seq_map_lookup(%s, %s)\n", map->map_mname, key);

	for (mapno = 0; mapno < MAXMAPSTACK; mapbit <<= 1, mapno++)
	{
		MAP *mm = map->map_stack[mapno];
		char *rv;

		if (mm == NULL)
			continue;
		if (!bitset(MF_OPEN, mm->map_mflags) &&
		    !openmap(mm))
		{
			if (bitset(mapbit, map->map_return[MA_UNAVAIL]))
			{
				*pstat = EX_UNAVAILABLE;
				return NULL;
			}
			continue;
		}
		*pstat = EX_OK;
		rv = mm->map_class->map_lookup(mm, key, args, pstat);
		if (rv != NULL)
			return rv;
		if (*pstat == EX_TEMPFAIL)
		{
			if (bitset(mapbit, map->map_return[MA_TRYAGAIN]))
				return NULL;
			tempfail = true;
		}
		else if (bitset(mapbit, map->map_return[MA_NOTFOUND]))
			break;
	}
	if (tempfail)
		*pstat = EX_TEMPFAIL;
	else if (*pstat == EX_OK)
		*pstat = EX_NOTFOUND;
	return NULL;
}

/*
**  SEQ_MAP_STORE -- sequenced map store
*/

void
seq_map_store(map, key, val)
	MAP *map;
	char *key;
	char *val;
{
	int mapno;

	if (tTd(38, 12))
		sm_dprintf("seq_map_store(%s, %s, %s)\n",
			map->map_mname, key, val);

	for (mapno = 0; mapno < MAXMAPSTACK; mapno++)
	{
		MAP *mm = map->map_stack[mapno];

		if (mm == NULL || !bitset(MF_WRITABLE, mm->map_mflags))
			continue;

		mm->map_class->map_store(mm, key, val);
		return;
	}
	syserr("seq_map_store(%s, %s, %s): no writable map",
		map->map_mname, key, val);
}
/*
**  NULL stubs
*/

/* ARGSUSED */
bool
null_map_open(map, mode)
	MAP *map;
	int mode;
{
	return true;
}

/* ARGSUSED */
void
null_map_close(map)
	MAP *map;
{
	return;
}

char *
null_map_lookup(map, key, args, pstat)
	MAP *map;
	char *key;
	char **args;
	int *pstat;
{
	*pstat = EX_NOTFOUND;
	return NULL;
}

/* ARGSUSED */
void
null_map_store(map, key, val)
	MAP *map;
	char *key;
	char *val;
{
	return;
}

MAPCLASS	NullMapClass =
{
	"null-map",		NULL,			0,
	NULL,			null_map_lookup,	null_map_store,
	null_map_open,		null_map_close,
};

/*
**  BOGUS stubs
*/

char *
bogus_map_lookup(map, key, args, pstat)
	MAP *map;
	char *key;
	char **args;
	int *pstat;
{
	*pstat = EX_TEMPFAIL;
	return NULL;
}

MAPCLASS	BogusMapClass =
{
	"bogus-map",		NULL,			0,
	NULL,			bogus_map_lookup,	null_map_store,
	null_map_open,		null_map_close,
};
/*
**  MACRO modules
*/

char *
macro_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	int mid;

	if (tTd(38, 20))
		sm_dprintf("macro_map_lookup(%s, %s)\n", map->map_mname,
			name == NULL ? "NULL" : name);

	if (name == NULL ||
	    *name == '\0' ||
	    (mid = macid(name)) == 0)
	{
		*statp = EX_CONFIG;
		return NULL;
	}

	if (av[1] == NULL)
		macdefine(&CurEnv->e_macro, A_PERM, mid, NULL);
	else
		macdefine(&CurEnv->e_macro, A_TEMP, mid, av[1]);

	*statp = EX_OK;
	return "";
}
/*
**  REGEX modules
*/

#if MAP_REGEX

# include <regex.h>

# define DEFAULT_DELIM	CONDELSE
# define END_OF_FIELDS	-1
# define ERRBUF_SIZE	80
# define MAX_MATCH	32

# define xnalloc(s)	memset(xalloc(s), '\0', s);

struct regex_map
{
	regex_t	*regex_pattern_buf;	/* xalloc it */
	int	*regex_subfields;	/* move to type MAP */
	char	*regex_delim;		/* move to type MAP */
};

static int	parse_fields __P((char *, int *, int, int));
static char	*regex_map_rewrite __P((MAP *, const char*, size_t, char **));

static int
parse_fields(s, ibuf, blen, nr_substrings)
	char *s;
	int *ibuf;		/* array */
	int blen;		/* number of elements in ibuf */
	int nr_substrings;	/* number of substrings in the pattern */
{
	register char *cp;
	int i = 0;
	bool lastone = false;

	blen--;		/* for terminating END_OF_FIELDS */
	cp = s;
	do
	{
		for (;; cp++)
		{
			if (*cp == ',')
			{
				*cp = '\0';
				break;
			}
			if (*cp == '\0')
			{
				lastone = true;
				break;
			}
		}
		if (i < blen)
		{
			int val = atoi(s);

			if (val < 0 || val >= nr_substrings)
			{
				syserr("field (%d) out of range, only %d substrings in pattern",
				       val, nr_substrings);
				return -1;
			}
			ibuf[i++] = val;
		}
		else
		{
			syserr("too many fields, %d max", blen);
			return -1;
		}
		s = ++cp;
	} while (!lastone);
	ibuf[i] = END_OF_FIELDS;
	return i;
}

bool
regex_map_init(map, ap)
	MAP *map;
	char *ap;
{
	int regerr;
	struct regex_map *map_p;
	register char *p;
	char *sub_param = NULL;
	int pflags;
	static char defdstr[] = { (char) DEFAULT_DELIM, '\0' };

	if (tTd(38, 2))
		sm_dprintf("regex_map_init: mapname '%s', args '%s'\n",
			map->map_mname, ap);

	pflags = REG_ICASE | REG_EXTENDED | REG_NOSUB;
	p = ap;
	map_p = (struct regex_map *) xnalloc(sizeof(*map_p));
	map_p->regex_pattern_buf = (regex_t *)xnalloc(sizeof(regex_t));

	for (;;)
	{
		while (isascii(*p) && isspace(*p))
			p++;
		if (*p != '-')
			break;
		switch (*++p)
		{
		  case 'n':	/* not */
			map->map_mflags |= MF_REGEX_NOT;
			break;

		  case 'f':	/* case sensitive */
			map->map_mflags |= MF_NOFOLDCASE;
			pflags &= ~REG_ICASE;
			break;

		  case 'b':	/* basic regular expressions */
			pflags &= ~REG_EXTENDED;
			break;

		  case 's':	/* substring match () syntax */
			sub_param = ++p;
			pflags &= ~REG_NOSUB;
			break;

		  case 'd':	/* delimiter */
			map_p->regex_delim = ++p;
			break;

		  case 'a':	/* map append */
			map->map_app = ++p;
			break;

		  case 'm':	/* matchonly */
			map->map_mflags |= MF_MATCHONLY;
			break;

		  case 'q':
			map->map_mflags |= MF_KEEPQUOTES;
			break;

		  case 'S':
			map->map_spacesub = *++p;
			break;

		  case 'D':
			map->map_mflags |= MF_DEFER;
			break;

		}
		while (*p != '\0' && !(isascii(*p) && isspace(*p)))
			p++;
		if (*p != '\0')
			*p++ = '\0';
	}
	if (tTd(38, 3))
		sm_dprintf("regex_map_init: compile '%s' 0x%x\n", p, pflags);

	if ((regerr = regcomp(map_p->regex_pattern_buf, p, pflags)) != 0)
	{
		/* Errorhandling */
		char errbuf[ERRBUF_SIZE];

		(void) regerror(regerr, map_p->regex_pattern_buf,
			 errbuf, sizeof(errbuf));
		syserr("pattern-compile-error: %s", errbuf);
		sm_free(map_p->regex_pattern_buf); /* XXX */
		sm_free(map_p); /* XXX */
		return false;
	}

	if (map->map_app != NULL)
		map->map_app = newstr(map->map_app);
	if (map_p->regex_delim != NULL)
		map_p->regex_delim = newstr(map_p->regex_delim);
	else
		map_p->regex_delim = defdstr;

	if (!bitset(REG_NOSUB, pflags))
	{
		/* substring matching */
		int substrings;
		int *fields = (int *) xalloc(sizeof(int) * (MAX_MATCH + 1));

		substrings = map_p->regex_pattern_buf->re_nsub + 1;

		if (tTd(38, 3))
			sm_dprintf("regex_map_init: nr of substrings %d\n",
				substrings);

		if (substrings >= MAX_MATCH)
		{
			syserr("too many substrings, %d max", MAX_MATCH);
			sm_free(map_p->regex_pattern_buf); /* XXX */
			sm_free(map_p); /* XXX */
			return false;
		}
		if (sub_param != NULL && sub_param[0] != '\0')
		{
			/* optional parameter -sfields */
			if (parse_fields(sub_param, fields,
					 MAX_MATCH + 1, substrings) == -1)
				return false;
		}
		else
		{
			int i;

			/* set default fields */
			for (i = 0; i < substrings; i++)
				fields[i] = i;
			fields[i] = END_OF_FIELDS;
		}
		map_p->regex_subfields = fields;
		if (tTd(38, 3))
		{
			int *ip;

			sm_dprintf("regex_map_init: subfields");
			for (ip = fields; *ip != END_OF_FIELDS; ip++)
				sm_dprintf(" %d", *ip);
			sm_dprintf("\n");
		}
	}
	map->map_db1 = (ARBPTR_T) map_p;	/* dirty hack */
	return true;
}

static char *
regex_map_rewrite(map, s, slen, av)
	MAP *map;
	const char *s;
	size_t slen;
	char **av;
{
	if (bitset(MF_MATCHONLY, map->map_mflags))
		return map_rewrite(map, av[0], strlen(av[0]), NULL);
	else
		return map_rewrite(map, s, slen, av);
}

char *
regex_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	int reg_res;
	struct regex_map *map_p;
	regmatch_t pmatch[MAX_MATCH];

	if (tTd(38, 20))
	{
		char **cpp;

		sm_dprintf("regex_map_lookup: key '%s'\n", name);
		for (cpp = av; cpp != NULL && *cpp != NULL; cpp++)
			sm_dprintf("regex_map_lookup: arg '%s'\n", *cpp);
	}

	map_p = (struct regex_map *)(map->map_db1);
	reg_res = regexec(map_p->regex_pattern_buf,
			  name, MAX_MATCH, pmatch, 0);

	if (bitset(MF_REGEX_NOT, map->map_mflags))
	{
		/* option -n */
		if (reg_res == REG_NOMATCH)
			return regex_map_rewrite(map, "", (size_t) 0, av);
		else
			return NULL;
	}
	if (reg_res == REG_NOMATCH)
		return NULL;

	if (map_p->regex_subfields != NULL)
	{
		/* option -s */
		static char retbuf[MAXNAME];
		int fields[MAX_MATCH + 1];
		bool first = true;
		int anglecnt = 0, cmntcnt = 0, spacecnt = 0;
		bool quotemode = false, bslashmode = false;
		register char *dp, *sp;
		char *endp, *ldp;
		int *ip;

		dp = retbuf;
		ldp = retbuf + sizeof(retbuf) - 1;

		if (av[1] != NULL)
		{
			if (parse_fields(av[1], fields, MAX_MATCH + 1,
					 (int) map_p->regex_pattern_buf->re_nsub + 1) == -1)
			{
				*statp = EX_CONFIG;
				return NULL;
			}
			ip = fields;
		}
		else
			ip = map_p->regex_subfields;

		for ( ; *ip != END_OF_FIELDS; ip++)
		{
			if (!first)
			{
				for (sp = map_p->regex_delim; *sp; sp++)
				{
					if (dp < ldp)
						*dp++ = *sp;
				}
			}
			else
				first = false;

			if (*ip >= MAX_MATCH ||
			    pmatch[*ip].rm_so < 0 || pmatch[*ip].rm_eo < 0)
				continue;

			sp = name + pmatch[*ip].rm_so;
			endp = name + pmatch[*ip].rm_eo;
			for (; endp > sp; sp++)
			{
				if (dp < ldp)
				{
					if (bslashmode)
					{
						*dp++ = *sp;
						bslashmode = false;
					}
					else if (quotemode && *sp != '"' &&
						*sp != '\\')
					{
						*dp++ = *sp;
					}
					else switch (*dp++ = *sp)
					{
					  case '\\':
						bslashmode = true;
						break;

					  case '(':
						cmntcnt++;
						break;

					  case ')':
						cmntcnt--;
						break;

					  case '<':
						anglecnt++;
						break;

					  case '>':
						anglecnt--;
						break;

					  case ' ':
						spacecnt++;
						break;

					  case '"':
						quotemode = !quotemode;
						break;
					}
				}
			}
		}
		if (anglecnt != 0 || cmntcnt != 0 || quotemode ||
		    bslashmode || spacecnt != 0)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "Warning: regex may cause prescan() failure map=%s lookup=%s",
				  map->map_mname, name);
			return NULL;
		}

		*dp = '\0';

		return regex_map_rewrite(map, retbuf, strlen(retbuf), av);
	}
	return regex_map_rewrite(map, "", (size_t)0, av);
}
#endif /* MAP_REGEX */
/*
**  NSD modules
*/
#if MAP_NSD

# include <ndbm.h>
# define _DATUM_DEFINED
# include <ns_api.h>

typedef struct ns_map_list
{
	ns_map_t		*map;		/* XXX ns_ ? */
	char			*mapname;
	struct ns_map_list	*next;
} ns_map_list_t;

static ns_map_t *
ns_map_t_find(mapname)
	char *mapname;
{
	static ns_map_list_t *ns_maps = NULL;
	ns_map_list_t *ns_map;

	/* walk the list of maps looking for the correctly named map */
	for (ns_map = ns_maps; ns_map != NULL; ns_map = ns_map->next)
	{
		if (strcmp(ns_map->mapname, mapname) == 0)
			break;
	}

	/* if we are looking at a NULL ns_map_list_t, then create a new one */
	if (ns_map == NULL)
	{
		ns_map = (ns_map_list_t *) xalloc(sizeof(*ns_map));
		ns_map->mapname = newstr(mapname);
		ns_map->map = (ns_map_t *) xalloc(sizeof(*ns_map->map));
		memset(ns_map->map, '\0', sizeof(*ns_map->map));
		ns_map->next = ns_maps;
		ns_maps = ns_map;
	}
	return ns_map->map;
}

char *
nsd_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	int buflen, r;
	char *p;
	ns_map_t *ns_map;
	char keybuf[MAXNAME + 1];
	char buf[MAXLINE];

	if (tTd(38, 20))
		sm_dprintf("nsd_map_lookup(%s, %s)\n", map->map_mname, name);

	buflen = strlen(name);
	if (buflen > sizeof(keybuf) - 1)
		buflen = sizeof(keybuf) - 1;	/* XXX simply cut off? */
	memmove(keybuf, name, buflen);
	keybuf[buflen] = '\0';
	if (!bitset(MF_NOFOLDCASE, map->map_mflags))
		makelower(keybuf);

	ns_map = ns_map_t_find(map->map_file);
	if (ns_map == NULL)
	{
		if (tTd(38, 20))
			sm_dprintf("nsd_map_t_find failed\n");
		*statp = EX_UNAVAILABLE;
		return NULL;
	}
	r = ns_lookup(ns_map, NULL, map->map_file, keybuf, NULL,
		      buf, sizeof(buf));
	if (r == NS_UNAVAIL || r == NS_TRYAGAIN)
	{
		*statp = EX_TEMPFAIL;
		return NULL;
	}
	if (r == NS_BADREQ
# ifdef NS_NOPERM
	    || r == NS_NOPERM
# endif /* NS_NOPERM */
	    )
	{
		*statp = EX_CONFIG;
		return NULL;
	}
	if (r != NS_SUCCESS)
	{
		*statp = EX_NOTFOUND;
		return NULL;
	}

	*statp = EX_OK;

	/* Null out trailing \n */
	if ((p = strchr(buf, '\n')) != NULL)
		*p = '\0';

	return map_rewrite(map, buf, strlen(buf), av);
}
#endif /* MAP_NSD */

char *
arith_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	long r;
	long v[2];
	bool res = false;
	bool boolres;
	static char result[16];
	char **cpp;

	if (tTd(38, 2))
	{
		sm_dprintf("arith_map_lookup: key '%s'\n", name);
		for (cpp = av; cpp != NULL && *cpp != NULL; cpp++)
			sm_dprintf("arith_map_lookup: arg '%s'\n", *cpp);
	}
	r = 0;
	boolres = false;
	cpp = av;
	*statp = EX_OK;

	/*
	**  read arguments for arith map
	**  - no check is made whether they are really numbers
	**  - just ignores args after the second
	*/

	for (++cpp; cpp != NULL && *cpp != NULL && r < 2; cpp++)
		v[r++] = strtol(*cpp, NULL, 0);

	/* operator and (at least) two operands given? */
	if (name != NULL && r == 2)
	{
		switch (*name)
		{
		  case '|':
			r = v[0] | v[1];
			break;

		  case '&':
			r = v[0] & v[1];
			break;

		  case '%':
			if (v[1] == 0)
				return NULL;
			r = v[0] % v[1];
			break;
		  case '+':
			r = v[0] + v[1];
			break;

		  case '-':
			r = v[0] - v[1];
			break;

		  case '*':
			r = v[0] * v[1];
			break;

		  case '/':
			if (v[1] == 0)
				return NULL;
			r = v[0] / v[1];
			break;

		  case 'l':
			res = v[0] < v[1];
			boolres = true;
			break;

		  case '=':
			res = v[0] == v[1];
			boolres = true;
			break;

		  case 'r':
			r = v[1] - v[0] + 1;
			if (r <= 0)
				return NULL;
			r = get_random() % r + v[0];
			break;

		  default:
			/* XXX */
			*statp = EX_CONFIG;
			if (LogLevel > 10)
				sm_syslog(LOG_WARNING, NOQID,
					  "arith_map: unknown operator %c",
					  (isascii(*name) && isprint(*name)) ?
					  *name : '?');
			return NULL;
		}
		if (boolres)
			(void) sm_snprintf(result, sizeof(result),
				res ? "TRUE" : "FALSE");
		else
			(void) sm_snprintf(result, sizeof(result), "%ld", r);
		return result;
	}
	*statp = EX_CONFIG;
	return NULL;
}

#if _FFR_ARPA_MAP
char *
arpa_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	int r;
	char *rval;
	char result[128];	/* IPv6: 64 + 10 + 1 would be enough */

	if (tTd(38, 2))
		sm_dprintf("arpa_map_lookup: key '%s'\n", name);
	*statp = EX_DATAERR;
	r = 1;
	memset(result, '\0', sizeof(result));
	rval = NULL;

# if NETINET6
	if (sm_strncasecmp(name, "IPv6:", 5) == 0)
	{
		struct in6_addr in6_addr;

		r = anynet_pton(AF_INET6, name, &in6_addr);
		if (r == 1)
		{
			static char hex_digits[] =
				{ '0', '1', '2', '3', '4', '5', '6', '7', '8',
				  '9', 'a', 'b', 'c', 'd', 'e', 'f' };

			unsigned char *src;
			char *dst;
			int i;

			src = (unsigned char *) &in6_addr;
			dst = result;
			for (i = 15; i >= 0; i--) {
				*dst++ = hex_digits[src[i] & 0x0f];
				*dst++ = '.';
				*dst++ = hex_digits[(src[i] >> 4) & 0x0f];
				if (i > 0)
					*dst++ = '.';
			}
			*statp = EX_OK;
		}
	}
	else
# endif /* NETINET6 */
# if NETINET
	{
		struct in_addr in_addr;

		r = anynet_pton(AF_INET, name, &in_addr);
		if (r == 1)
		{
			unsigned char *src;

			src = (unsigned char *) &in_addr;
			(void) snprintf(result, sizeof(result),
				"%u.%u.%u.%u",
				src[3], src[2], src[1], src[0]);
			*statp = EX_OK;
		}
	}
# endif /* NETINET */
	if (r < 0)
		*statp = EX_UNAVAILABLE;
	if (tTd(38, 2))
		sm_dprintf("arpa_map_lookup: r=%d, result='%s'\n", r, result);
	if (*statp == EX_OK)
	{
		if (bitset(MF_MATCHONLY, map->map_mflags))
			rval = map_rewrite(map, name, strlen(name), NULL);
		else
			rval = map_rewrite(map, result, strlen(result), av);
	}
	return rval;
}
#endif /* _FFR_ARPA_MAP */

#if SOCKETMAP

# if NETINET || NETINET6
#  include <arpa/inet.h>
# endif /* NETINET || NETINET6 */

# define socket_map_next map_stack[0]

/*
**  SOCKET_MAP_OPEN -- open socket table
*/

bool
socket_map_open(map, mode)
	MAP *map;
	int mode;
{
	STAB *s;
	int sock = 0;
	SOCKADDR_LEN_T addrlen = 0;
	int addrno = 0;
	int save_errno;
	char *p;
	char *colon;
	char *at;
	struct hostent *hp = NULL;
	SOCKADDR addr;

	if (tTd(38, 2))
		sm_dprintf("socket_map_open(%s, %s, %d)\n",
			map->map_mname, map->map_file, mode);

	mode &= O_ACCMODE;

	/* sendmail doesn't have the ability to write to SOCKET (yet) */
	if (mode != O_RDONLY)
	{
		/* issue a pseudo-error message */
		errno = SM_EMAPCANTWRITE;
		return false;
	}

	if (*map->map_file == '\0')
	{
		syserr("socket map \"%s\": empty or missing socket information",
			map->map_mname);
		return false;
	}

	s = socket_map_findconn(map->map_file);
	if (s->s_socketmap != NULL)
	{
		/* Copy open connection */
		map->map_db1 = s->s_socketmap->map_db1;

		/* Add this map as head of linked list */
		map->socket_map_next = s->s_socketmap;
		s->s_socketmap = map;

		if (tTd(38, 2))
			sm_dprintf("using cached connection\n");
		return true;
	}

	if (tTd(38, 2))
		sm_dprintf("opening new connection\n");

	/* following code is ripped from milter.c */
	/* XXX It should be put in a library... */

	/* protocol:filename or protocol:port@@host */
	memset(&addr, '\0', sizeof(addr));
	p = map->map_file;
	colon = strchr(p, ':');
	if (colon != NULL)
	{
		*colon = '\0';

		if (*p == '\0')
		{
# if NETUNIX
			/* default to AF_UNIX */
			addr.sa.sa_family = AF_UNIX;
# else /* NETUNIX */
#  if NETINET
			/* default to AF_INET */
			addr.sa.sa_family = AF_INET;
#  else /* NETINET */
#   if NETINET6
			/* default to AF_INET6 */
			addr.sa.sa_family = AF_INET6;
#   else /* NETINET6 */
			/* no protocols available */
			syserr("socket map \"%s\": no valid socket protocols available",
			map->map_mname);
			return false;
#   endif /* NETINET6 */
#  endif /* NETINET */
# endif /* NETUNIX */
		}
# if NETUNIX
		else if (sm_strcasecmp(p, "unix") == 0 ||
			 sm_strcasecmp(p, "local") == 0)
			addr.sa.sa_family = AF_UNIX;
# endif /* NETUNIX */
# if NETINET
		else if (sm_strcasecmp(p, "inet") == 0)
			addr.sa.sa_family = AF_INET;
# endif /* NETINET */
# if NETINET6
		else if (sm_strcasecmp(p, "inet6") == 0)
			addr.sa.sa_family = AF_INET6;
# endif /* NETINET6 */
		else
		{
# ifdef EPROTONOSUPPORT
			errno = EPROTONOSUPPORT;
# else /* EPROTONOSUPPORT */
			errno = EINVAL;
# endif /* EPROTONOSUPPORT */
			syserr("socket map \"%s\": unknown socket type %s",
			       map->map_mname, p);
			return false;
		}
		*colon++ = ':';
	}
	else
	{
		colon = p;
#if NETUNIX
		/* default to AF_UNIX */
		addr.sa.sa_family = AF_UNIX;
#else /* NETUNIX */
# if NETINET
		/* default to AF_INET */
		addr.sa.sa_family = AF_INET;
# else /* NETINET */
#  if NETINET6
		/* default to AF_INET6 */
		addr.sa.sa_family = AF_INET6;
#  else /* NETINET6 */
		syserr("socket map \"%s\": unknown socket type %s",
		       map->map_mname, p);
		return false;
#  endif /* NETINET6 */
# endif /* NETINET */
#endif /* NETUNIX */
	}

# if NETUNIX
	if (addr.sa.sa_family == AF_UNIX)
	{
		long sff = SFF_SAFEDIRPATH|SFF_OPENASROOT|SFF_NOLINK|SFF_EXECOK;

		at = colon;
		if (strlen(colon) >= sizeof(addr.sunix.sun_path))
		{
			syserr("socket map \"%s\": local socket name %s too long",
			       map->map_mname, colon);
			return false;
		}
		errno = safefile(colon, RunAsUid, RunAsGid, RunAsUserName, sff,
				 S_IRUSR|S_IWUSR, NULL);

		if (errno != 0)
		{
			/* if not safe, don't create */
				syserr("socket map \"%s\": local socket name %s unsafe",
			       map->map_mname, colon);
			return false;
		}

		(void) sm_strlcpy(addr.sunix.sun_path, colon,
			       sizeof(addr.sunix.sun_path));
		addrlen = sizeof(struct sockaddr_un);
	}
	else
# endif /* NETUNIX */
# if NETINET || NETINET6
	if (false
#  if NETINET
		 || addr.sa.sa_family == AF_INET
#  endif /* NETINET */
#  if NETINET6
		 || addr.sa.sa_family == AF_INET6
#  endif /* NETINET6 */
		 )
	{
		unsigned short port;

		/* Parse port@@host */
		at = strchr(colon, '@@');
		if (at == NULL)
		{
			syserr("socket map \"%s\": bad address %s (expected port@@host)",
				       map->map_mname, colon);
			return false;
		}
		*at = '\0';
		if (isascii(*colon) && isdigit(*colon))
			port = htons((unsigned short) atoi(colon));
		else
		{
#  ifdef NO_GETSERVBYNAME
			syserr("socket map \"%s\": invalid port number %s",
				       map->map_mname, colon);
			return false;
#  else /* NO_GETSERVBYNAME */
			register struct servent *sp;

			sp = getservbyname(colon, "tcp");
			if (sp == NULL)
			{
				syserr("socket map \"%s\": unknown port name %s",
					       map->map_mname, colon);
				return false;
			}
			port = sp->s_port;
#  endif /* NO_GETSERVBYNAME */
		}
		*at++ = '@@';
		if (*at == '[')
		{
			char *end;

			end = strchr(at, ']');
			if (end != NULL)
			{
				bool found = false;
#  if NETINET
				unsigned long hid = INADDR_NONE;
#  endif /* NETINET */
#  if NETINET6
				struct sockaddr_in6 hid6;
#  endif /* NETINET6 */

				*end = '\0';
#  if NETINET
				if (addr.sa.sa_family == AF_INET &&
				    (hid = inet_addr(&at[1])) != INADDR_NONE)
				{
					addr.sin.sin_addr.s_addr = hid;
					addr.sin.sin_port = port;
					found = true;
				}
#  endif /* NETINET */
#  if NETINET6
				(void) memset(&hid6, '\0', sizeof(hid6));
				if (addr.sa.sa_family == AF_INET6 &&
				    anynet_pton(AF_INET6, &at[1],
						&hid6.sin6_addr) == 1)
				{
					addr.sin6.sin6_addr = hid6.sin6_addr;
					addr.sin6.sin6_port = port;
					found = true;
				}
#  endif /* NETINET6 */
				*end = ']';
				if (!found)
				{
					syserr("socket map \"%s\": Invalid numeric domain spec \"%s\"",
					       map->map_mname, at);
					return false;
				}
			}
			else
			{
				syserr("socket map \"%s\": Invalid numeric domain spec \"%s\"",
				       map->map_mname, at);
				return false;
			}
		}
		else
		{
			hp = sm_gethostbyname(at, addr.sa.sa_family);
			if (hp == NULL)
			{
				syserr("socket map \"%s\": Unknown host name %s",
					map->map_mname, at);
				return false;
			}
			addr.sa.sa_family = hp->h_addrtype;
			switch (hp->h_addrtype)
			{
#  if NETINET
			  case AF_INET:
				memmove(&addr.sin.sin_addr,
					hp->h_addr, INADDRSZ);
				addr.sin.sin_port = port;
				addrlen = sizeof(struct sockaddr_in);
				addrno = 1;
				break;
#  endif /* NETINET */

#  if NETINET6
			  case AF_INET6:
				memmove(&addr.sin6.sin6_addr,
					hp->h_addr, IN6ADDRSZ);
				addr.sin6.sin6_port = port;
				addrlen = sizeof(struct sockaddr_in6);
				addrno = 1;
				break;
#  endif /* NETINET6 */

			  default:
				syserr("socket map \"%s\": Unknown protocol for %s (%d)",
					map->map_mname, at, hp->h_addrtype);
#  if NETINET6
				freehostent(hp);
#  endif /* NETINET6 */
				return false;
			}
		}
	}
	else
# endif /* NETINET || NETINET6 */
	{
		syserr("socket map \"%s\": unknown socket protocol",
			map->map_mname);
		return false;
	}

	/* nope, actually connecting */
	for (;;)
	{
		sock = socket(addr.sa.sa_family, SOCK_STREAM, 0);
		if (sock < 0)
		{
			save_errno = errno;
			if (tTd(38, 5))
				sm_dprintf("socket map \"%s\": error creating socket: %s\n",
					   map->map_mname,
					   sm_errstring(save_errno));
# if NETINET6
			if (hp != NULL)
				freehostent(hp);
# endif /* NETINET6 */
			return false;
		}

		if (connect(sock, (struct sockaddr *) &addr, addrlen) >= 0)
			break;

		/* couldn't connect.... try next address */
		save_errno = errno;
		p = CurHostName;
		CurHostName = at;
		if (tTd(38, 5))
			sm_dprintf("socket_open (%s): open %s failed: %s\n",
				map->map_mname, at, sm_errstring(save_errno));
		CurHostName = p;
		(void) close(sock);

		/* try next address */
		if (hp != NULL && hp->h_addr_list[addrno] != NULL)
		{
			switch (addr.sa.sa_family)
			{
# if NETINET
			  case AF_INET:
				memmove(&addr.sin.sin_addr,
					hp->h_addr_list[addrno++],
					INADDRSZ);
				break;
# endif /* NETINET */

# if NETINET6
			  case AF_INET6:
				memmove(&addr.sin6.sin6_addr,
					hp->h_addr_list[addrno++],
					IN6ADDRSZ);
				break;
# endif /* NETINET6 */

			  default:
				if (tTd(38, 5))
					sm_dprintf("socket map \"%s\": Unknown protocol for %s (%d)\n",
						   map->map_mname, at,
						   hp->h_addrtype);
# if NETINET6
				freehostent(hp);
# endif /* NETINET6 */
				return false;
			}
			continue;
		}
		p = CurHostName;
		CurHostName = at;
		if (tTd(38, 5))
			sm_dprintf("socket map \"%s\": error connecting to socket map: %s\n",
				   map->map_mname, sm_errstring(save_errno));
		CurHostName = p;
# if NETINET6
		if (hp != NULL)
			freehostent(hp);
# endif /* NETINET6 */
		return false;
	}
# if NETINET6
	if (hp != NULL)
	{
		freehostent(hp);
		hp = NULL;
	}
# endif /* NETINET6 */
	if ((map->map_db1 = (ARBPTR_T) sm_io_open(SmFtStdiofd,
						  SM_TIME_DEFAULT,
						  (void *) &sock,
						  SM_IO_RDWR,
						  NULL)) == NULL)
	{
		close(sock);
		if (tTd(38, 2))
		    sm_dprintf("socket_open (%s): failed to create stream: %s\n",
			       map->map_mname, sm_errstring(errno));
		return false;
	}

	/* Save connection for reuse */
	s->s_socketmap = map;
	return true;
}

/*
**  SOCKET_MAP_FINDCONN -- find a SOCKET connection to the server
**
**	Cache SOCKET connections based on the connection specifier
**	and PID so we don't have multiple connections open to
**	the same server for different maps.  Need a separate connection
**	per PID since a parent process may close the map before the
**	child is done with it.
**
**	Parameters:
**		conn -- SOCKET map connection specifier
**
**	Returns:
**		Symbol table entry for the SOCKET connection.
*/

static STAB *
socket_map_findconn(conn)
	const char *conn;
{
	char *nbuf;
	STAB *SM_NONVOLATILE s = NULL;

	nbuf = sm_stringf_x("%s%c%d", conn, CONDELSE, (int) CurrentPid);
	SM_TRY
		s = stab(nbuf, ST_SOCKETMAP, ST_ENTER);
	SM_FINALLY
		sm_free(nbuf);
	SM_END_TRY
	return s;
}

/*
**  SOCKET_MAP_CLOSE -- close the socket
*/

void
socket_map_close(map)
	MAP *map;
{
	STAB *s;
	MAP *smap;

	if (tTd(38, 20))
		sm_dprintf("socket_map_close(%s), pid=%ld\n", map->map_file,
			(long) CurrentPid);

	/* Check if already closed */
	if (map->map_db1 == NULL)
	{
		if (tTd(38, 20))
			sm_dprintf("socket_map_close(%s) already closed\n",
				map->map_file);
		return;
	}
	sm_io_close((SM_FILE_T *)map->map_db1, SM_TIME_DEFAULT);

	/* Mark all the maps that share the connection as closed */
	s = socket_map_findconn(map->map_file);
	smap = s->s_socketmap;
	while (smap != NULL)
	{
		MAP *next;

		if (tTd(38, 2) && smap != map)
			sm_dprintf("socket_map_close(%s): closed %s (shared SOCKET connection)\n",
				map->map_mname, smap->map_mname);

		smap->map_mflags &= ~(MF_OPEN|MF_WRITABLE);
		smap->map_db1 = NULL;
		next = smap->socket_map_next;
		smap->socket_map_next = NULL;
		smap = next;
	}
	s->s_socketmap = NULL;
}

/*
** SOCKET_MAP_LOOKUP -- look up a datum in a SOCKET table
*/

char *
socket_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	unsigned int nettolen, replylen, recvlen;
	char *replybuf, *rval, *value, *status, *key;
	SM_FILE_T *f;
	char keybuf[MAXNAME + 1];

	replybuf = NULL;
	rval = NULL;
	f = (SM_FILE_T *)map->map_db1;
	if (tTd(38, 20))
		sm_dprintf("socket_map_lookup(%s, %s) %s\n",
			map->map_mname, name, map->map_file);

	if (!bitset(MF_NOFOLDCASE, map->map_mflags))
	{
		nettolen = strlen(name);
		if (nettolen > sizeof(keybuf) - 1)
			nettolen = sizeof(keybuf) - 1;
		memmove(keybuf, name, nettolen);
		keybuf[nettolen] = '\0';
		makelower(keybuf);
		key = keybuf;
	}
	else
		key = name;

	nettolen = strlen(map->map_mname) + 1 + strlen(key);
	SM_ASSERT(nettolen > strlen(map->map_mname));
	SM_ASSERT(nettolen > strlen(key));
	if ((sm_io_fprintf(f, SM_TIME_DEFAULT, "%u:%s %s,",
			   nettolen, map->map_mname, key) == SM_IO_EOF) ||
	    (sm_io_flush(f, SM_TIME_DEFAULT) != 0) ||
	    (sm_io_error(f)))
	{
		syserr("451 4.3.0 socket_map_lookup(%s): failed to send lookup request",
			map->map_mname);
		*statp = EX_TEMPFAIL;
		goto errcl;
	}

	if (sm_io_fscanf(f, SM_TIME_DEFAULT, "%9u", &replylen) != 1)
	{
		syserr("451 4.3.0 socket_map_lookup(%s): failed to read length parameter of reply",
			map->map_mname);
		*statp = EX_TEMPFAIL;
		goto errcl;
	}
	if (replylen > SOCKETMAP_MAXL)
	{
		syserr("451 4.3.0 socket_map_lookup(%s): reply too long: %u",
			   map->map_mname, replylen);
		*statp = EX_TEMPFAIL;
		goto errcl;
	}
	if (sm_io_getc(f, SM_TIME_DEFAULT) != ':')
	{
		syserr("451 4.3.0 socket_map_lookup(%s): missing ':' in reply",
			map->map_mname);
		*statp = EX_TEMPFAIL;
		goto error;
	}

	replybuf = (char *) sm_malloc(replylen + 1);
	if (replybuf == NULL)
	{
		syserr("451 4.3.0 socket_map_lookup(%s): can't allocate %u bytes",
			map->map_mname, replylen + 1);
		*statp = EX_OSERR;
		goto error;
	}

	recvlen = sm_io_read(f, SM_TIME_DEFAULT, replybuf, replylen);
	if (recvlen < replylen)
	{
		syserr("451 4.3.0 socket_map_lookup(%s): received only %u of %u reply characters",
			   map->map_mname, recvlen, replylen);
		*statp = EX_TEMPFAIL;
		goto errcl;
	}
	if (sm_io_getc(f, SM_TIME_DEFAULT) != ',')
	{
		syserr("451 4.3.0 socket_map_lookup(%s): missing ',' in reply",
			map->map_mname);
		*statp = EX_TEMPFAIL;
		goto errcl;
	}
	status = replybuf;
	replybuf[recvlen] = '\0';
	value = strchr(replybuf, ' ');
	if (value != NULL)
	{
		*value = '\0';
		value++;
	}
	if (strcmp(status, "OK") == 0)
	{
		*statp = EX_OK;

		/* collect the return value */
		if (bitset(MF_MATCHONLY, map->map_mflags))
			rval = map_rewrite(map, key, strlen(key), NULL);
		else
			rval = map_rewrite(map, value, strlen(value), av);
	}
	else if (strcmp(status, "NOTFOUND") == 0)
	{
		*statp = EX_NOTFOUND;
		if (tTd(38, 20))
			sm_dprintf("socket_map_lookup(%s): %s not found\n",
				map->map_mname, key);
	}
	else
	{
		if (tTd(38, 5))
			sm_dprintf("socket_map_lookup(%s, %s): server returned error: type=%s, reason=%s\n",
				map->map_mname, key, status,
				value ? value : "");
		if ((strcmp(status, "TEMP") == 0) ||
		    (strcmp(status, "TIMEOUT") == 0))
			*statp = EX_TEMPFAIL;
		else if(strcmp(status, "PERM") == 0)
			*statp = EX_UNAVAILABLE;
		else
			*statp = EX_PROTOCOL;
	}

	if (replybuf != NULL)
		sm_free(replybuf);
	return rval;

  errcl:
	socket_map_close(map);
  error:
	if (replybuf != NULL)
		sm_free(replybuf);
	return rval;
}
#endif /* SOCKETMAP */
@


1.30
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.29
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2008 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: map.c,v 8.711 2013/03/12 15:24:52 ca Exp $")
d7368 81
@


1.28
log
@Update to sendmail 8.14.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: map.c,v 8.709 2012/04/20 18:47:09 ca Exp $")
d2886 3
d2976 1
a2976 1
	    (NIS_RES_OBJECT(res)->zo_data.zo_type != TABLE_OBJ))
d5840 1
a5840 1
			   linebuf, sizeof(linebuf)) != NULL)
d5914 1
a5914 1
			    linebuf, sizeof(linebuf)) != NULL)
@


1.27
log
@Update to sendmail 8.14.5
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: map.c,v 8.706 2010/07/27 03:35:42 ca Exp $")
d3437 1
a3437 1
					  "timeout conning to LDAP server %.100s",
d3766 2
a3767 2
				syserr("Error getting LDAP results in map %s",
				       map->map_mname);
d3769 2
a3770 2
				syserr("451 4.3.5 Error getting LDAP results in map %s",
				       map->map_mname);
d3784 1
a3784 1
				  "ldap %.100s => %s", name,
@


1.26
log
@Use & not && to mask bits.
Sendmail folks have been notified and are fixing this for
the next release.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2007 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: map.c,v 8.699 2007/10/10 00:06:45 ca Exp $")
d733 1
a733 1
	auto int status;
d3418 12
d3529 1
a3529 1
		if (islower(*p) || isdigit(*p))
d3534 1
a3534 1
		else if (isupper(*p))
d3982 4
d4085 1
a4085 1
			lmap->ldap_networktmo.tv_sec = atoi(p);
d5988 1
a5988 1
**	This is a wierd case -- it is only intended as a fallback for
d6706 7
d7351 2
a7352 1
					  isprint(*name) ? *name : '?');
@


1.25
log
@Update to sendmail-8.14.3
@
text
@d1713 1
a1713 1
			if ((omode && O_ACCMODE) == O_RDWR)
d2362 1
a2362 1
			if ((omode && O_ACCMODE) == O_RDWR)
@


1.24
log
@Update to sendmail-8.14.1
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2006 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: map.c,v 8.696 2007/04/03 21:33:14 ca Exp $")
d3570 7
a3577 1
		int rc;
d3580 1
d3597 3
d3978 2
a3979 3
		  case 'N':
			map->map_mflags |= MF_INCLNULL;
			map->map_mflags &= ~MF_TRY0NULL;
d3982 2
a3983 2
		  case 'O':
			map->map_mflags &= ~MF_TRY1NULL;
d3986 2
a3987 2
		  case 'o':
			map->map_mflags |= MF_OPTIONAL;
d3998 11
a4008 2
		  case 'A':
			map->map_mflags |= MF_APPEND;
d4015 2
a4016 2
		  case 'a':
			map->map_app = ++p;
a4026 8
		  case 'S':
			map->map_spacesub = *++p;
			break;

		  case 'D':
			map->map_mflags |= MF_DEFER;
			break;

d4049 37
a4085 4
		  case 'V':
			if (*++p != '\\')
				lmap->ldap_attrsep = *p;
			else
d4087 9
a4095 5
				switch (*++p)
				{
				  case 'n':
					lmap->ldap_attrsep = '\n';
					break;
d4097 11
a4107 3
				  case 't':
					lmap->ldap_attrsep = '\t';
					break;
d4109 2
a4110 4
				  default:
					lmap->ldap_attrsep = '\\';
				}
			}
d4119 8
a4126 1
		  case 'v':		/* attr to return */
d4129 34
a4162 2
			lmap->ldap_attr[0] = p;
			lmap->ldap_attr[1] = NULL;
d4165 10
a4174 2
		  case '1':
			map->map_mflags |= MF_SINGLEMATCH;
d4177 4
a4180 3
# if _FFR_LDAP_SINGLEDN
		  case '2':
			map->map_mflags |= MF_SINGLEDN;
a4181 1
# endif /* _FFR_LDAP_SINGLEDN */
a4191 4
		  case 'n':		/* retrieve attribute names only */
			lmap->ldap_attrsonly = LDAPMAP_TRUE;
			break;

d4262 4
a4265 4
		  case 'h':		/* ldap host */
			while (isascii(*++p) && isspace(*p))
				continue;
			if (lmap->ldap_uri != NULL)
d4267 5
a4271 6
				syserr("Can not specify both an LDAP host and an LDAP URI in map %s",
				       map->map_mname);
				return false;
			}
			lmap->ldap_host = p;
			break;
d4273 2
a4274 43
		  case 'b':		/* search base */
			while (isascii(*++p) && isspace(*p))
				continue;
			lmap->ldap_base = p;
			break;

		  case 'p':		/* ldap port */
			while (isascii(*++p) && isspace(*p))
				continue;
			lmap->ldap_port = atoi(p);
			break;

		  case 'l':		/* time limit */
			while (isascii(*++p) && isspace(*p))
				continue;
			lmap->ldap_timelimit = atoi(p);
			lmap->ldap_timeout.tv_sec = lmap->ldap_timelimit;
			break;

		  case 'Z':
			while (isascii(*++p) && isspace(*p))
				continue;
			lmap->ldap_sizelimit = atoi(p);
			break;

		  case 'd':		/* Dn to bind to server as */
			while (isascii(*++p) && isspace(*p))
				continue;
			lmap->ldap_binddn = p;
			break;

		  case 'M':		/* Method for binding */
			while (isascii(*++p) && isspace(*p))
				continue;

			if (sm_strncasecmp(p, "LDAP_AUTH_", 10) == 0)
				p += 10;

			for (lam = LDAPAuthMethods;
			     lam != NULL && lam->lam_name != NULL; lam++)
			{
				if (sm_strncasecmp(p, lam->lam_name,
						   strlen(lam->lam_name)) == 0)
a4275 10
			}
			if (lam->lam_name != NULL)
				lmap->ldap_method = lam->lam_code;
			else
			{
				/* bad config line */
				if (!bitset(MCF_OPTFILE,
					    map->map_class->map_cflags))
				{
					char *ptr;
d4277 2
a4278 7
					if ((ptr = strchr(p, ' ')) != NULL)
						*ptr = '\0';
					syserr("Method for binding must be [none|simple|krbv4] (not %s) in map %s",
						p, map->map_mname);
					if (ptr != NULL)
						*ptr = ' ';
					return false;
a4280 1

d4283 1
a4283 24
			/*
			**  This is a string that is dependent on the
			**  method used defined above.
			*/

		  case 'P':		/* Secret password for binding */
			 while (isascii(*++p) && isspace(*p))
				continue;
			lmap->ldap_secret = p;
			secretread = false;
			break;

		  case 'H':		/* Use LDAP URI */
#  if !USE_LDAP_INIT
			syserr("Must compile with -DUSE_LDAP_INIT to use LDAP URIs (-H) in map %s",
			       map->map_mname);
			return false;
#   else /* !USE_LDAP_INIT */
			if (lmap->ldap_host != NULL)
			{
				syserr("Can not specify both an LDAP host and an LDAP URI in map %s",
				       map->map_mname);
				return false;
			}
d4286 2
a4287 1
			lmap->ldap_uri = p;
a4288 1
#  endif /* !USE_LDAP_INIT */
d4315 4
a4318 2
		  case 'K':
			lmap->ldap_multi_args = true;
@


1.23
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: map.c,v 8.693 2006/12/19 00:58:56 ca Exp $")
d4701 1
a4701 1
**  Contributed by Mark D. Roth <roth@@uiuc.edu>.  Contact him for support.
@


1.22
log
@Update to sendmail-8.13.8
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2005 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: map.c,v 8.672 2006/04/18 01:26:41 ca Exp $")
d42 2
d664 44
d736 4
d759 4
d769 4
d805 6
d851 8
d860 1
d865 13
d924 1
a924 1
		p = get_column(line, i, '\0', nbuf, sizeof nbuf);
d1007 1
a1007 11
#  if _FFR_DNSMAP_MULTILIMIT
#   if !_FFR_DNSMAP_MULTI
  ERROR README:	You must define _FFR_DNSMAP_MULTI to use _FFR_DNSMAP_MULTILIMIT
#   endif /* ! _FFR_DNSMAP_MULTI */
#  endif /* _FFR_DNSMAP_MULTILIMIT */

#  if _FFR_DNSMAP_MULTI
#   if _FFR_DNSMAP_MULTILIMIT
#    define map_sizelimit	map_lockfd	/* overload field */
#   endif /* _FFR_DNSMAP_MULTILIMIT */
#  endif /* _FFR_DNSMAP_MULTI */
d1022 1
a1022 1
	map_p = (struct dns_map *) xalloc(sizeof *map_p);
a1094 1
#  if _FFR_DNSMAP_MULTI
a1115 1
#   if _FFR_DNSMAP_MULTILIMIT
a1120 2
#   endif /* _FFR_DNSMAP_MULTILIMIT */
#  endif /* _FFR_DNSMAP_MULTI */
a1140 1
#  if _FFR_DNSMAP_BASE
a1160 2
#  endif /* _FFR_DNSMAP_BASE */

d1175 1
a1175 1
	**  Assumption: assert(sizeof int <= sizeof(ARBPTR_T));
a1204 2
#  if _FFR_DNSMAP_MULTI
#   if _FFR_DNSMAP_MULTILIMIT
a1205 2
#   endif /* _FFR_DNSMAP_MULTILIMIT */
#  endif /* _FFR_DNSMAP_MULTI */
a1219 1
#  if _FFR_DNSMAP_BASE
a1237 1
#  endif /* _FFR_DNSMAP_BASE */
d1298 1
a1298 1
					    sizeof buf6);
a1328 1
#  if _FFR_DNSMAP_MULTI
a1330 1
#   if _FFR_DNSMAP_MULTILIMIT
a1331 1
#   endif /* _FFR_DNSMAP_MULTILIMIT */
a1354 1
#   if _FFR_DNSMAP_MULTILIMIT
a1357 1
#   endif /* _FFR_DNSMAP_MULTILIMIT */
a1358 4
#  else /* _FFR_DNSMAP_MULTI */
		vp = value;
		break;
#  endif /* _FFR_DNSMAP_MULTI */
a1368 1
#  if _FFR_DNSMAP_MULTI
a1370 1
#  endif /* _FFR_DNSMAP_MULTI */
a1382 1
#  if _FFR_DNSMAP_MULTI
a1384 1
#  endif /* _FFR_DNSMAP_MULTI */
d1426 4
a1429 4
	if (sm_strlcpyn(dirfile, sizeof dirfile, 2,
			map->map_file, ".dir") >= sizeof dirfile ||
	    sm_strlcpyn(pagfile, sizeof pagfile, 2,
			map->map_file, ".pag") >= sizeof pagfile)
d1685 2
a1686 2
		if (key.dsize > sizeof keybuf - 1)
			key.dsize = sizeof keybuf - 1;
d1782 2
a1783 2
		if (key.dsize > sizeof keybuf - 1)
			key.dsize = sizeof keybuf - 1;
d1867 1
a1867 1
			(void) sm_snprintf(buf, sizeof buf, "%010ld", curtime());
d1870 1
a1870 1
			(void) gethostname(buf, sizeof buf);
d1943 1
a1943 1
	memset(&btinfo, '\0', sizeof btinfo);
d1972 1
a1972 1
	memset(&hinfo, '\0', sizeof hinfo);
d2011 1
a2011 1
	if (sm_strlcpy(buf, map->map_file, sizeof buf) >= sizeof buf)
d2022 1
a2022 1
		if (sm_strlcat(buf, ".db", sizeof buf) >= sizeof buf)
d2311 2
a2312 2
	memset(&key, '\0', sizeof key);
	memset(&val, '\0', sizeof val);
d2318 1
a2318 1
	if (sm_strlcpy(buf, map->map_file, sizeof buf) >= sizeof buf)
d2331 2
a2332 2
	if (key.size > sizeof keybuf - 1)
		key.size = sizeof keybuf - 1;
d2470 2
a2471 2
	memset(&key, '\0', sizeof key);
	memset(&data, '\0', sizeof data);
d2481 2
a2482 2
		if (key.size > sizeof keybuf - 1)
			key.size = sizeof keybuf - 1;
d2527 1
a2527 1
			memset(&old, '\0', sizeof old);
d2741 2
a2742 2
	if (buflen > sizeof keybuf - 1)
		buflen = sizeof keybuf - 1;
d2810 1
a2810 1
	if (sm_strlcpy(nbuf, name, sizeof nbuf) >= sizeof nbuf)
d2851 1
a2851 1
	(void) sm_strlcpy(host_record, vp, sizeof host_record);
d2858 1
a2858 1
	if (!extract_canonname(nbuf, NULL, host_record, cbuf, sizeof cbuf))
d2930 1
a2930 1
		(void) sm_strlcpy(qbuf, map->map_file, sizeof qbuf);
d2935 1
a2935 1
		(void) sm_strlcpyn(qbuf, sizeof qbuf, 3,
d3074 1
a3074 1
	skleft = sizeof search_key - 4;
d3107 1
a3107 1
		(void) sm_snprintf(qbuf, sizeof qbuf, "[%s=%s],%s.%s",
d3111 1
a3111 1
		(void) sm_snprintf(qbuf, sizeof qbuf, "[%s=%s],%s",
d3188 1
a3188 1
	if (sm_strlcpy(nbuf, name, sizeof nbuf) >= sizeof nbuf)
d3199 1
a3199 1
		(void) sm_snprintf(qbuf, sizeof qbuf,
d3206 1
a3206 1
		(void) sm_snprintf(qbuf, sizeof qbuf,
d3300 1
a3300 1
	(void) sm_strlcpy(default_domain, p, sizeof default_domain);
d3371 9
d3533 3
d3550 1
d3559 1
d3561 11
d3573 20
a3592 2
	if (tTd(38, 20))
		sm_dprintf("ldapmap_lookup(%s, %s)\n", map->map_mname, name);
d3598 18
a3615 1
	(void) sm_strlcpy(keybuf, name, sizeof keybuf);
d3617 13
a3629 1
	if (!bitset(MF_NOFOLDCASE, map->map_mflags))
d3631 15
a3645 5
# ifdef SUNET_ID
		sunet_id_hash(keybuf);
# else /* SUNET_ID */
		makelower(keybuf);
# endif /* SUNET_ID */
d3648 11
a3658 2
	msgid = sm_ldap_search(lmap, keybuf);
	if (msgid == -1)
d3664 5
d3670 2
a3671 2
				syserr("Error in ldap_search using %s in map %s",
				       keybuf, map->map_mname);
d3673 2
a3674 2
				syserr("451 4.3.5 Error in ldap_search using %s in map %s",
				       keybuf, map->map_mname);
d3691 13
d3884 1
a3884 1
		lmap = (SM_LDAP_STRUCT *) xalloc(sizeof *lmap);
d3908 1
a3908 1
			expand("\201j", jbuf, sizeof jbuf, &BlankEnvelope);
d3912 1
a3912 1
						  sizeof jbuf);
d3920 1
a3920 1
				expand(lc, lcbuf, sizeof lcbuf, CurEnv);
d3924 1
a3924 1
			n = sm_snprintf(ldapfilt, sizeof ldapfilt,
d3927 1
a3927 1
			if (n >= sizeof ldapfilt)
d4300 4
d4394 1
a4394 1
			lmap->ldap_secret = sfgets(m_tmp, sizeof m_tmp,
d4423 1
a4423 1
			(void) sm_snprintf(m_tmp, sizeof m_tmp,
d4647 1
a4647 1
		LDAPDefaults = (SM_LDAP_STRUCT *) xalloc(sizeof *LDAPDefaults);
d4650 1
a4650 1
	memset(&map, '\0', sizeof map);
d4738 1
a4738 1
	(void) sm_snprintf(phmap_id, sizeof phmap_id,
d4742 1
a4742 1
	pmap = (PH_MAP_STRUCT *) xalloc(sizeof *pmap);
d5127 1
d5266 93
d5426 1
a5426 1
		if (nl < sizeof nbuf - 1)
d5431 1
a5431 1
		(void) sm_strlcpy(&np[1], name, (sizeof nbuf) - 1);
d5612 1
a5612 1
	if (sm_strlcpy(nbuf, name, sizeof nbuf) >= sizeof nbuf)
d5787 2
a5788 2
	if (buflen > sizeof search_key - 1)
		buflen = sizeof search_key - 1;	/* XXX just cut if off? */
d5804 1
a5804 1
			   linebuf, sizeof linebuf) != NULL)
d5814 1
a5814 1
		p = get_column(linebuf, key_idx, delim, buf, sizeof buf);
d5827 1
a5827 1
	vp = get_column(linebuf, map->map_valcolno, delim, buf, sizeof buf);
d5861 1
a5861 1
	if (sm_strlcpy(nbuf, name, sizeof nbuf) >= sizeof nbuf)
d5878 1
a5878 1
			    linebuf, sizeof linebuf) != NULL)
d5886 1
a5886 1
						  cbuf, sizeof cbuf);
d6230 1
a6230 1
			(void) sm_snprintf(buf, sizeof buf, "%d",
d6236 1
a6236 1
			(void) sm_snprintf(buf, sizeof buf, "%d",
d6293 1
a6293 1
		(void) sm_strlcpy(buf, map->map_rebuild, sizeof buf);
d6324 1
a6324 1
	i = read(fd, buf, sizeof buf - 1);
d6352 1
a6352 1
		while ((i = read(fd, buf, sizeof buf)) > 0)
d6499 1
a6499 1
		(void) sm_strlcpyn(nbuf, sizeof nbuf, 3,
d6821 1
a6821 1
	map_p = (struct regex_map *) xnalloc(sizeof *map_p);
d6889 1
a6889 1
			 errbuf, sizeof errbuf);
d7144 1
a7144 1
		ns_map = (ns_map_list_t *) xalloc(sizeof *ns_map);
d7146 2
a7147 2
		ns_map->map = (ns_map_t *) xalloc(sizeof *ns_map->map);
		memset(ns_map->map, '\0', sizeof *ns_map->map);
d7171 2
a7172 2
	if (buflen > sizeof keybuf - 1)
		buflen = sizeof keybuf - 1;	/* XXX simply cut off? */
d7187 1
a7187 1
		      buf, sizeof buf);
d7298 7
d7315 1
a7315 1
			(void) sm_snprintf(result, sizeof result,
d7318 1
a7318 1
			(void) sm_snprintf(result, sizeof result, "%ld", r);
d7396 1
a7396 1
	memset(&addr, '\0', sizeof addr);
d7480 1
a7480 1
		if (strlen(colon) >= sizeof addr.sunix.sun_path)
d7498 2
a7499 2
			       sizeof addr.sunix.sun_path);
		addrlen = sizeof (struct sockaddr_un);
d7572 1
a7572 1
				(void) memset(&hid6, '\0', sizeof hid6);
d7614 1
a7614 1
				addrlen = sizeof (struct sockaddr_in);
d7624 1
a7624 1
				addrlen = sizeof (struct sockaddr_in6);
d7851 2
a7852 2
		if (nettolen > sizeof keybuf - 1)
			nettolen = sizeof keybuf - 1;
@


1.21
log
@Update to sendmail 8.13.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: map.c,v 8.671 2005/10/25 17:55:50 ca Exp $")
d5995 4
@


1.20
log
@update to sendmail 8.13.4
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: map.c,v 8.669 2005/02/09 01:46:35 ca Exp $")
d3496 1
a3496 1
	char keybuf[MAXNAME + 1];
d3554 4
d3917 6
@


1.19
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: map.c,v 8.666 2004/08/17 16:50:19 gshapiro Exp $")
d5660 6
a5665 3
	if (s != NULL)
		return s->s_alias;
	return NULL;
a5667 1

d7559 1
a7559 1
	char *replybuf, *rval, *value, *status;
d7561 1
d7570 14
a7583 1
	nettolen = strlen(map->map_mname) + 1 + strlen(name);
d7585 1
a7585 1
	SM_ASSERT(nettolen > strlen(name));
d7587 1
a7587 1
			   nettolen, map->map_mname, name) == SM_IO_EOF) ||
d7657 1
a7657 1
			rval = map_rewrite(map, name, strlen(name), NULL);
d7666 1
a7666 1
				map->map_mname, name);
d7672 1
a7672 1
				map->map_mname, name, status,
@


1.18
log
@Update to sendmail-8.13.1
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: map.c,v 8.664 2004/06/28 17:46:13 ca Exp $")
d4434 2
d4437 1
d6475 3
@


1.17
log
@Update to sendmail.8.13.0
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: map.c,v 8.662 2004/06/08 17:26:21 ca Exp $")
d3704 1
d3788 1
d4303 1
a4303 1
	if (lmap->ldap_attr[0] != NULL)
d4434 1
d7550 1
a7550 1
	size_t nettolen, replylen, recvlen;
d7562 2
@


1.16
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: map.c,v 8.645.2.10 2003/07/24 18:24:17 ca Exp $")
d69 6
d3316 1
d3352 7
d3367 1
a3367 1
					  lmap->ldap_target == NULL ? "localhost" : lmap->ldap_target);
d3373 1
d3380 2
a3381 3
				       lmap->ldap_target == NULL ? "localhost"
								 : lmap->ldap_target,
				       map->map_mname);
d3383 1
d3390 2
a3391 3
				       lmap->ldap_target == NULL ? "localhost"
								 : lmap->ldap_target,
				       map->map_mname);
d3487 1
a3487 1
# if _FFR_LDAP_RECURSION
a3489 6
# else /* _FFR_LDAP_RECURSION */
	int entries = 0;
	int i;
	int ret;
	int vsize;
# endif /* _FFR_LDAP_RECURSION */
d3494 1
d3549 5
a3553 10
# if _FFR_LDAP_RECURSION
	{
		int flags;
		SM_RPOOL_T *rpool;

		flags = 0;
		if (bitset(MF_SINGLEMATCH, map->map_mflags))
			flags |= SM_LDAP_SINGLEMATCH;
		if (bitset(MF_MATCHONLY, map->map_mflags))
			flags |= SM_LDAP_MATCHONLY;
d3555 2
a3556 2
		/* Create an rpool for search related memory usage */
		rpool = sm_rpool_new_x(NULL);
d3558 4
a3561 9
		p = NULL;
		*statp = sm_ldap_results(lmap, msgid, flags, map->map_coldelim,
					 rpool, &p, &plen, &psize, NULL);
		save_errno = errno;

		/* Copy result so rpool can be freed */
		if (*statp == EX_OK && p != NULL)
			vp = newstr(p);
		sm_rpool_free(rpool);
d3563 4
a3566 6
		/* need to restart LDAP connection? */
		if (*statp == EX_RESTART)
		{
			*statp = EX_TEMPFAIL;
			ldapmap_close(map);
		}
d3568 2
a3569 23
		errno = save_errno;
		if (*statp != EX_OK && *statp != EX_NOTFOUND)
		{
			if (!bitset(MF_OPTIONAL, map->map_mflags))
			{
				if (bitset(MF_NODEFER, map->map_mflags))
					syserr("Error getting LDAP results in map %s",
					       map->map_mname);
				else
					syserr("451 4.3.5 Error getting LDAP results in map %s",
					       map->map_mname);
			}
			errno = save_errno;
			return NULL;
		}
	}
# else /* _FFR_LDAP_RECURSION */

	/* Get results */
	while ((ret = ldap_result(lmap->ldap_ld, msgid, 0,
				  (lmap->ldap_timeout.tv_sec == 0 ? NULL :
				   &(lmap->ldap_timeout)),
				  &(lmap->ldap_res))) == LDAP_RES_SEARCH_ENTRY)
d3571 2
a3572 316
		LDAPMessage *entry;

		if (bitset(MF_SINGLEMATCH, map->map_mflags))
		{
			entries += ldap_count_entries(lmap->ldap_ld,
						      lmap->ldap_res);
			if (entries > 1)
			{
				*statp = EX_NOTFOUND;
				if (lmap->ldap_res != NULL)
				{
					ldap_msgfree(lmap->ldap_res);
					lmap->ldap_res = NULL;
				}
				(void) ldap_abandon(lmap->ldap_ld, msgid);
				if (vp != NULL)
					sm_free(vp); /* XXX */
				if (tTd(38, 25))
					sm_dprintf("ldap search found multiple on a single match query\n");
				return NULL;
			}
		}

		/* If we don't want multiple values and we have one, break */
		if (map->map_coldelim == '\0' && vp != NULL)
			break;

		/* Cycle through all entries */
		for (entry = ldap_first_entry(lmap->ldap_ld, lmap->ldap_res);
		     entry != NULL;
		     entry = ldap_next_entry(lmap->ldap_ld, lmap->ldap_res))
		{
			BerElement *ber;
			char *attr;
			char **vals = NULL;

			/*
			**  If matching only and found an entry,
			**  no need to spin through attributes
			*/

			if (*statp == EX_OK &&
			    bitset(MF_MATCHONLY, map->map_mflags))
				continue;

#  if !defined(LDAP_VERSION_MAX) && !defined(LDAP_OPT_SIZELIMIT)
			/*
			**  Reset value to prevent lingering
			**  LDAP_DECODING_ERROR due to
			**  OpenLDAP 1.X's hack (see below)
			*/

			lmap->ldap_ld->ld_errno = LDAP_SUCCESS;
#  endif /* !defined(LDAP_VERSION_MAX) !defined(LDAP_OPT_SIZELIMIT) */

			for (attr = ldap_first_attribute(lmap->ldap_ld, entry,
							 &ber);
			     attr != NULL;
			     attr = ldap_next_attribute(lmap->ldap_ld, entry,
							ber))
			{
				char *tmp, *vp_tmp;

				if (lmap->ldap_attrsonly == LDAPMAP_FALSE)
				{
					vals = ldap_get_values(lmap->ldap_ld,
							       entry,
							       attr);
					if (vals == NULL)
					{
						save_errno = sm_ldap_geterrno(lmap->ldap_ld);
						if (save_errno == LDAP_SUCCESS)
						{
							ldap_memfree(attr);
							continue;
						}

						/* Must be an error */
						save_errno += E_LDAPBASE;
						if (!bitset(MF_OPTIONAL,
							    map->map_mflags))
						{
							errno = save_errno;
							if (bitset(MF_NODEFER,
								   map->map_mflags))
								syserr("Error getting LDAP values in map %s",
								       map->map_mname);
							else
								syserr("451 4.3.5 Error getting LDAP values in map %s",
								       map->map_mname);
						}
						*statp = EX_TEMPFAIL;
						ldap_memfree(attr);
						if (lmap->ldap_res != NULL)
						{
							ldap_msgfree(lmap->ldap_res);
							lmap->ldap_res = NULL;
						}
						(void) ldap_abandon(lmap->ldap_ld,
								    msgid);
						if (vp != NULL)
							sm_free(vp); /* XXX */
						errno = save_errno;
						return NULL;
					}
				}

				*statp = EX_OK;

#  if !defined(LDAP_VERSION_MAX) && !defined(LDAP_OPT_SIZELIMIT)
				/*
				**  Reset value to prevent lingering
				**  LDAP_DECODING_ERROR due to
				**  OpenLDAP 1.X's hack (see below)
				*/

				lmap->ldap_ld->ld_errno = LDAP_SUCCESS;
#  endif /* !defined(LDAP_VERSION_MAX) !defined(LDAP_OPT_SIZELIMIT) */

				/*
				**  If matching only,
				**  no need to spin through entries
				*/

				if (bitset(MF_MATCHONLY, map->map_mflags))
				{
					if (lmap->ldap_attrsonly == LDAPMAP_FALSE)
						ldap_value_free(vals);

					ldap_memfree(attr);
					continue;
				}

				/*
				**  If we don't want multiple values,
				**  return first found.
				*/

				if (map->map_coldelim == '\0')
				{
					if (lmap->ldap_attrsonly == LDAPMAP_TRUE)
					{
						vp = newstr(attr);
						ldap_memfree(attr);
						break;
					}

					if (vals[0] == NULL)
					{
						ldap_value_free(vals);
						ldap_memfree(attr);
						continue;
					}

					vsize = strlen(vals[0]) + 1;
					if (lmap->ldap_attrsep != '\0')
						vsize += strlen(attr) + 1;
					vp = xalloc(vsize);
					if (lmap->ldap_attrsep != '\0')
						sm_snprintf(vp, vsize,
							    "%s%c%s",
							    attr,
							    lmap->ldap_attrsep,
							    vals[0]);
					else
						sm_strlcpy(vp, vals[0], vsize);
					ldap_value_free(vals);
					ldap_memfree(attr);
					break;
				}

				/* attributes only */
				if (lmap->ldap_attrsonly == LDAPMAP_TRUE)
				{
					if (vp == NULL)
						vp = newstr(attr);
					else
					{
						vsize = strlen(vp) +
							strlen(attr) + 2;
						tmp = xalloc(vsize);
						(void) sm_snprintf(tmp,
							vsize, "%s%c%s",
							vp, map->map_coldelim,
							attr);
						sm_free(vp); /* XXX */
						vp = tmp;
					}
					ldap_memfree(attr);
					continue;
				}

				/*
				**  If there is more than one,
				**  munge then into a map_coldelim
				**  separated string
				*/

				vsize = 0;
				for (i = 0; vals[i] != NULL; i++)
				{
					vsize += strlen(vals[i]) + 1;
					if (lmap->ldap_attrsep != '\0')
						vsize += strlen(attr) + 1;
				}
				vp_tmp = xalloc(vsize);
				*vp_tmp = '\0';

				p = vp_tmp;
				for (i = 0; vals[i] != NULL; i++)
				{
					if (lmap->ldap_attrsep != '\0')
					{
						p += sm_strlcpy(p, attr,
								vsize - (p - vp_tmp));
						if (p >= vp_tmp + vsize)
							syserr("ldapmap_lookup: Internal error: buffer too small for LDAP values");
						*p++ = lmap->ldap_attrsep;
					}
					p += sm_strlcpy(p, vals[i],
							vsize - (p - vp_tmp));
					if (p >= vp_tmp + vsize)
						syserr("ldapmap_lookup: Internal error: buffer too small for LDAP values");
					if (vals[i + 1] != NULL)
						*p++ = map->map_coldelim;
				}

				ldap_value_free(vals);
				ldap_memfree(attr);
				if (vp == NULL)
				{
					vp = vp_tmp;
					continue;
				}
				vsize = strlen(vp) + strlen(vp_tmp) + 2;
				tmp = xalloc(vsize);
				(void) sm_snprintf(tmp, vsize, "%s%c%s",
					 vp, map->map_coldelim, vp_tmp);

				sm_free(vp); /* XXX */
				sm_free(vp_tmp); /* XXX */
				vp = tmp;
			}
			save_errno = sm_ldap_geterrno(lmap->ldap_ld);

			/*
			**  We check errno != LDAP_DECODING_ERROR since
			**  OpenLDAP 1.X has a very ugly *undocumented*
			**  hack of returning this error code from
			**  ldap_next_attribute() if the library freed the
			**  ber attribute.  See:
			**  http://www.openldap.org/lists/openldap-devel/9901/msg00064.html
			*/

			if (save_errno != LDAP_SUCCESS &&
			    save_errno != LDAP_DECODING_ERROR)
			{
				/* Must be an error */
				save_errno += E_LDAPBASE;
				if (!bitset(MF_OPTIONAL, map->map_mflags))
				{
					errno = save_errno;
					if (bitset(MF_NODEFER, map->map_mflags))
						syserr("Error getting LDAP attributes in map %s",
						       map->map_mname);
					else
						syserr("451 4.3.5 Error getting LDAP attributes in map %s",
						       map->map_mname);
				}
				*statp = EX_TEMPFAIL;
				if (lmap->ldap_res != NULL)
				{
					ldap_msgfree(lmap->ldap_res);
					lmap->ldap_res = NULL;
				}
				(void) ldap_abandon(lmap->ldap_ld, msgid);
				if (vp != NULL)
					sm_free(vp); /* XXX */
				errno = save_errno;
				return NULL;
			}

			/* We don't want multiple values and we have one */
			if (map->map_coldelim == '\0' && vp != NULL)
				break;
		}
		save_errno = sm_ldap_geterrno(lmap->ldap_ld);
		if (save_errno != LDAP_SUCCESS &&
		    save_errno != LDAP_DECODING_ERROR)
		{
			/* Must be an error */
			save_errno += E_LDAPBASE;
			if (!bitset(MF_OPTIONAL, map->map_mflags))
			{
				errno = save_errno;
				if (bitset(MF_NODEFER, map->map_mflags))
					syserr("Error getting LDAP entries in map %s",
					       map->map_mname);
				else
					syserr("451 4.3.5 Error getting LDAP entries in map %s",
					       map->map_mname);
			}
			*statp = EX_TEMPFAIL;
			if (lmap->ldap_res != NULL)
			{
				ldap_msgfree(lmap->ldap_res);
				lmap->ldap_res = NULL;
			}
			(void) ldap_abandon(lmap->ldap_ld, msgid);
			if (vp != NULL)
				sm_free(vp); /* XXX */
			errno = save_errno;
			return NULL;
		}
		ldap_msgfree(lmap->ldap_res);
		lmap->ldap_res = NULL;
d3575 2
a3576 5
	if (ret == 0)
		save_errno = ETIMEDOUT;
	else
		save_errno = sm_ldap_geterrno(lmap->ldap_ld);
	if (save_errno != LDAP_SUCCESS)
a3577 3
		if (ret != 0)
			save_errno += E_LDAPBASE;

a3579 1
			errno = save_errno;
a3586 15
		*statp = EX_TEMPFAIL;
		if (vp != NULL)
			sm_free(vp); /* XXX */

		switch (save_errno - E_LDAPBASE)
		{
#  ifdef LDAP_SERVER_DOWN
		  case LDAP_SERVER_DOWN:
#  endif /* LDAP_SERVER_DOWN */
		  case LDAP_TIMEOUT:
		  case LDAP_UNAVAILABLE:
			/* server disappeared, try reopen on next search */
			ldapmap_close(map);
			break;
		}
a3589 1
# endif /* _FFR_LDAP_RECURSION */
d3636 1
d3639 7
a3645 1
# if _FFR_LDAP_SETVERSION
a3646 3
# else /* _FFR_LDAP_SETVERSION */
	format = "%s%c%d%c%s%c%s%d";
# endif /* _FFR_LDAP_SETVERSION */
d3648 1
a3648 2
			    (lmap->ldap_target == NULL ? "localhost"
						       : lmap->ldap_target),
a3651 1
# if _FFR_LDAP_SETVERSION
a3653 1
# endif /* _FFR_LDAP_SETVERSION */
a3703 3
# if _FFR_LDAP_URI
	bool ldaphost = false;
# endif /* _FFR_LDAP_URI */
d3772 15
a3786 2
			lmap->ldap_attr[0] = "sendmailMTAAliasValue";
			lmap->ldap_attr[1] = NULL;
d3998 1
a3998 2
# if _FFR_LDAP_URI
			if (lmap->ldap_uri)
d4004 1
a4004 3
			ldaphost = true;
# endif /* _FFR_LDAP_URI */
			lmap->ldap_target = p;
a4085 1
# if _FFR_LDAP_URI
d4091 2
a4092 2
#  else /* !USE_LDAP_INIT */
			if (ldaphost)
d4100 1
a4100 2
			lmap->ldap_target = p;
			lmap->ldap_uri = true;
a4102 1
# endif /* _FFR_LDAP_URI */
a4103 1
# if _FFR_LDAP_SETVERSION
d4109 1
a4109 1
#  ifdef LDAP_VERSION_MAX
d4117 2
a4118 2
#  endif /* LDAP_VERSION_MAX */
#  ifdef LDAP_VERSION_MIN
d4126 1
a4126 1
#  endif /* LDAP_VERSION_MIN */
a4127 1
# endif /* _FFR_LDAP_SETVERSION */
d4162 8
a4169 1
	if (lmap->ldap_target != NULL &&
d4172 3
a4174 3
	     LDAPDefaults->ldap_target != lmap->ldap_target))
		lmap->ldap_target = newstr(ldapmap_dequote(lmap->ldap_target));
	map->map_domain = lmap->ldap_target;
a4302 1
# if _FFR_LDAP_RECURSION
a4304 1
# endif /* _FFR_LDAP_RECURSION */
a4309 1
# if _FFR_LDAP_RECURSION
a4314 1
# endif /* _FFR_LDAP_RECURSION */
a4336 1
# if _FFR_LDAP_RECURSION
a4427 3
# else /* _FFR_LDAP_RECURSION */
				lmap->ldap_attr[i] = newstr(v);
# endif /* _FFR_LDAP_RECURSION */
a4431 1
# if _FFR_LDAP_RECURSION
a4443 1
# endif /* _FFR_LDAP_RECURSION */
d4531 1
a4531 1
/* assume we're using nph-1.1.x if not specified */
d4533 1
a4533 1
#  define NPH_VERSION		10100
a4641 6
		  case 'v':
			sm_syslog(LOG_WARNING, NULL,
				  "ph_map_parseargs: WARNING: -v option will be removed in a future release - please use -k instead");
			/* intentional fallthrough for backward compatibility */
			/* FALLTHROUGH */

d7035 633
@


1.15
log
@update to sendmail 8.12.7
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: map.c,v 8.645.2.7 2002/12/03 17:01:15 ca Exp $")
d386 1
a386 1
				if (--len <= 0)
d397 2
a399 1
				--len;
d1177 1
a1177 2
		if (errno == ETIMEDOUT || h_errno == TRY_AGAIN ||
		    errno == ECONNREFUSED)
d6945 4
@


1.14
log
@update to sendmail-8.12.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: map.c,v 8.645.2.3 2002/08/09 22:23:13 gshapiro Exp $")
d32 1
a32 4
# include <db.h>
# ifndef DB_VERSION_MAJOR
#  define DB_VERSION_MAJOR 1
# endif /* ! DB_VERSION_MAJOR */
d2084 1
a2084 4

#  if !HASFLOCK && defined(DB_FCNTL_LOCKING)
		flags |= DB_FCNTL_LOCKING;
#  endif /* !HASFLOCK && defined(DB_FCNTL_LOCKING) */
d2112 3
a2114 1
			ret = db->open(db, buf, NULL, dbtype, flags, DBMMODE);
d4887 1
a4887 1
static char phmap_id[PH_BUF_SIZE];
d4892 14
d5103 4
d5108 1
d5119 4
d5124 1
d5201 8
a5208 3
		if (!ph_open(&(pmap->ph), host, PH_ROUNDROBIN|PH_DONTID,
			     ph_map_send_debug, ph_map_recv_debug) &&
		    !ph_id(pmap->ph, phmap_id))
d5220 1
a5220 1
		pmap->ph_fastclose = PH_FASTCLOSE;
d5281 1
a5281 1
	else if (i == PH_NOMATCH || i == PH_DATAERR)
d5296 1
a5296 1
		pmap->ph_fastclose = PH_FASTCLOSE;
@


1.13
log
@sendmail 8.12.5
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: map.c,v 8.645.2.1 2002/06/21 20:25:23 ca Exp $")
d3814 2
d7203 1
@


1.12
log
@Update to sendmail-8.12.4
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: map.c,v 8.645 2002/05/24 21:07:36 gshapiro Exp $")
d1237 1
@


1.11
log
@update to sendmail 8.12.3
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: map.c,v 8.641 2002/03/26 22:56:36 gshapiro Exp $")
a123 2
#define DBMMODE		0644

d1360 2
a1361 2
	char dirfile[MAXNAME + 1];
	char pagfile[MAXNAME + 1];
d1372 11
a1382 2
	(void) sm_strlcpyn(dirfile, sizeof dirfile, 2, map->map_file, ".dir");
	(void) sm_strlcpyn(pagfile, sizeof pagfile, 2, map->map_file, ".pag");
d1954 1
a1954 1
	char buf[MAXNAME + 1];
d1957 8
a1964 1
	(void) sm_strlcpy(buf, map->map_file, sizeof buf - 3);
d1967 10
a1976 1
		(void) sm_strlcat(buf, ".db", sizeof buf);
d2256 1
a2256 1
	char buf[MAXNAME + 1];
d2265 9
a2273 4
	i = strlen(map->map_file);
	if (i > MAXNAME)
		i = MAXNAME;
	(void) sm_strlcpy(buf, map->map_file, i + 1);
d4571 1
a4571 1
			lmap->ldap_secret = sfgets(m_tmp, LDAPMAP_MAX_PASSWD,
d4575 6
d4600 1
a4600 2
			(void) sm_snprintf(m_tmp,
				MAXPATHLEN + LDAPMAP_MAX_PASSWD,
d5869 2
a5870 1
	while (sm_io_fgets(f, SM_TIME_DEFAULT, linebuf, MAXLINE) != NULL)
d5943 2
a5944 1
		sm_io_fgets(f, SM_TIME_DEFAULT, linebuf, MAXLINE) != NULL)
d7238 2
a7239 1
	r = ns_lookup(ns_map, NULL, map->map_file, keybuf, NULL, buf, MAXLINE);
@


1.10
log
@update to sendmail-8.12.2
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: map.c,v 8.618 2002/01/11 22:06:52 gshapiro Exp $")
d2594 1
a2594 1
				syserr("421 4.3.5 NIS map %s specified, but NIS not running",
d2628 1
a2628 1
		syserr("421 4.0.0 Cannot bind to map %s in domain %s: %s",
d2882 1
a2882 1
				syserr("421 4.0.0 Cannot find table %s.%s: %s",
d2898 1
a2898 1
			syserr("421 4.0.0 %s.%s: %s is not a table",
d3135 1
a3135 1
		sm_dprintf("\nnisplus_getcanoname(%s), qbuf=%s\n",
d3155 1
a3155 1
				sm_dprintf("nisplus_getcanoname(%s), got %d entries, all but first ignored\n",
d3160 1
a3160 1
			sm_dprintf("nisplus_getcanoname(%s), found in directory \"%s\"\n",
d3328 1
a3328 1
					  lmap->ldap_host == NULL ? "localhost" : lmap->ldap_host);
d3340 2
a3341 2
				       lmap->ldap_host == NULL ? "localhost"
							       : lmap->ldap_host,
d3344 1
a3344 1
				syserr("421 4.0.0 %s failed to %s in map %s",
d3350 2
a3351 2
				       lmap->ldap_host == NULL ? "localhost"
							       : lmap->ldap_host,
d3448 5
d3454 3
a3456 1
	int entries = 0;
a3457 1
	int ret;
a3458 1
	int vsize;
d3493 1
a3493 1
				syserr("421 4.0.0 Error in ldap_search using %s in map %s",
d3499 1
a3499 1
#ifdef LDAP_SERVER_DOWN
d3501 1
a3501 1
#endif /* LDAP_SERVER_DOWN */
d3531 1
a3531 1
					 rpool, &p, NULL);
d3555 1
a3555 1
					syserr("421 4.0.0 Error getting LDAP results in map %s",
a3560 1
		goto finishlookup;
d3562 1
a3562 1
# endif /* _FFR_LDAP_RECURSION */
d3615 1
a3615 1
# if !defined(LDAP_VERSION_MAX) && !defined(LDAP_OPT_SIZELIMIT)
d3623 1
a3623 1
# endif /* !defined(LDAP_VERSION_MAX) !defined(LDAP_OPT_SIZELIMIT) */
a3642 1
# if USING_NETSCAPE_LDAP
a3643 1
# endif /* USING_NETSCAPE_LDAP */
d3658 1
a3658 1
								syserr("421 4.0.0 Error getting LDAP values in map %s",
a3661 1
# if USING_NETSCAPE_LDAP
a3662 1
# endif /* USING_NETSCAPE_LDAP */
d3679 1
a3679 1
# if !defined(LDAP_VERSION_MAX) && !defined(LDAP_OPT_SIZELIMIT)
d3687 1
a3687 1
# endif /* !defined(LDAP_VERSION_MAX) !defined(LDAP_OPT_SIZELIMIT) */
a3698 1
# if USING_NETSCAPE_LDAP
a3699 1
# endif /* USING_NETSCAPE_LDAP */
a3712 1
# if USING_NETSCAPE_LDAP
a3713 1
# endif /* USING_NETSCAPE_LDAP */
a3719 1
# if USING_NETSCAPE_LDAP
a3720 1
# endif /* USING_NETSCAPE_LDAP */
a3736 1
# if USING_NETSCAPE_LDAP
a3737 1
# endif /* USING_NETSCAPE_LDAP */
a3757 1
# if USING_NETSCAPE_LDAP
a3758 1
# endif /* USING_NETSCAPE_LDAP */
a3795 1
# if USING_NETSCAPE_LDAP
a3796 1
# endif /* USING_NETSCAPE_LDAP */
d3834 1
a3834 1
						syserr("421 4.0.0 Error getting LDAP attributes in map %s",
d3867 1
a3867 1
					syserr("421 4.0.0 Error getting LDAP entries in map %s",
d3902 1
a3902 1
				syserr("421 4.0.0 Error getting LDAP results in map %s",
d3911 1
a3911 1
#ifdef LDAP_SERVER_DOWN
d3913 1
a3913 1
#endif /* LDAP_SERVER_DOWN */
a3922 3

# if _FFR_LDAP_RECURSION
finishlookup:
d3968 1
d3972 8
a3979 3
	nbuf = sm_stringf_x("%s%c%d%c%s%c%s%d",
			    (lmap->ldap_host == NULL ? "localhost"
						     : lmap->ldap_host),
d3983 4
d4037 3
d4321 10
a4330 1
			lmap->ldap_host = p;
d4412 48
d4493 1
a4493 1
	if (lmap->ldap_host != NULL &&
d4496 3
a4498 3
	     LDAPDefaults->ldap_host != lmap->ldap_host))
		lmap->ldap_host = newstr(ldapmap_dequote(lmap->ldap_host));
	map->map_domain = lmap->ldap_host;
d4622 1
a4622 1
#if _FFR_LDAP_RECURSION
d4624 2
a4625 2
		int final = 0;
#endif /* _FFR_LDAP_RECURSION */
d4631 8
d4660 3
a4662 1
#if _FFR_LDAP_RECURSION
d4664 1
d4668 1
d4670 8
a4677 1
#endif /* _FFR_LDAP_RECURSION */
d4679 1
a4679 1
				lmap->ldap_attr[i] = newstr(v);
d4681 7
a4687 2
#if _FFR_LDAP_RECURSION
				if (type != NULL)
d4689 6
a4694 1
					if (sm_strcasecmp(type, "normal") == 0)
d4696 6
a4701 1
						lmap->ldap_attr_type[i] = LDAPMAP_ATTR_NORMAL;
d4703 18
a4720 1
					else if (sm_strcasecmp(type, "dn") == 0)
d4723 1
a4723 1
						lmap->ldap_attr_type[i] = LDAPMAP_ATTR_DN;
d4728 1
a4728 1
						lmap->ldap_attr_type[i] = LDAPMAP_ATTR_FILTER;
d4733 1
a4733 1
						lmap->ldap_attr_type[i] = LDAPMAP_ATTR_URL;
d4735 1
a4735 1
					else if (sm_strcasecmp(type, "final") == 0)
d4737 2
a4738 8
						lmap->ldap_attr_type[i] = LDAPMAP_ATTR_FINAL;
						if (final >= LDAPMAP_MAX_ATTR)
						{
							syserr("Too many FINAL attributes in %s (max %d)",
							       map->map_mname, LDAPMAP_MAX_ATTR);
							return false;
						}
						lmap->ldap_attr_final[final++] = lmap->ldap_attr[i];
d4748 7
a4754 2
					lmap->ldap_attr_type[i] = LDAPMAP_ATTR_NORMAL;
#endif /* _FFR_LDAP_RECURSION */
d4759 2
a4760 3
#if _FFR_LDAP_RECURSION
		lmap->ldap_attr_final[final] = NULL;
		if (recurse && lmap->ldap_attr_final[0] == NULL)
d4762 1
a4762 1
			syserr("LDAP recursion requested in %s but no FINAL attribute given",
d4772 1
a4772 1
#endif /* _FFR_LDAP_RECURSION */
d4829 1
d5025 1
a5025 1
		sm_dprintf("ph_map_close(%s): pmap->ph_fastclose=%d",
d5419 1
a5419 1
		syserr("421 4.0.0 cannot initialize Hesiod map (%s)",
d5433 1
a5433 1
		syserr("421 4.0.0 cannot initialize Hesiod map (%d)", hes_error());
@


1.9
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: map.c,v 8.606 2001/09/25 18:32:36 gshapiro Exp $")
d468 1
a468 1
	if (s->s_type != ST_MAP)
d623 1
a623 1
	if (s->s_type != ST_MAP)
d3306 1
d3452 1
a3479 2
		int save_errno;

d3492 1
a3492 2
		errno = save_errno - E_LDAPBASE;
		switch (errno)
d3510 52
a3561 3
	/* Get results (all if MF_NOREWRITE, otherwise one by one) */
	while ((ret = ldap_result(lmap->ldap_ld, msgid,
				  bitset(MF_NOREWRITE, map->map_mflags),
d3636 6
a3641 2
						errno = sm_ldap_geterrno(lmap->ldap_ld);
						if (errno == LDAP_SUCCESS)
d3643 1
d3646 1
a3646 1
						errno += E_LDAPBASE;
d3650 1
d3672 1
d3695 7
d3703 1
d3823 1
a3823 1
			errno = sm_ldap_geterrno(lmap->ldap_ld);
d3834 2
a3835 2
			if (errno != LDAP_SUCCESS &&
			    errno != LDAP_DECODING_ERROR)
d3838 1
a3838 1
				errno += E_LDAPBASE;
d3841 1
d3858 1
d3866 3
a3868 2
		errno = sm_ldap_geterrno(lmap->ldap_ld);
		if (errno != LDAP_SUCCESS && errno != LDAP_DECODING_ERROR)
d3871 1
a3871 1
			errno += E_LDAPBASE;
d3874 1
d3891 1
a3897 24
	/*
	**  If grabbing all results at once for MF_NOREWRITE and
	**  only want a single match, make sure that's all we have
	*/

	if (ret == LDAP_RES_SEARCH_RESULT &&
	    bitset(MF_NOREWRITE|MF_SINGLEMATCH, map->map_mflags))
	{
		entries += ldap_count_entries(lmap->ldap_ld, lmap->ldap_res);
		if (entries > 1)
		{
			*statp = EX_NOTFOUND;
			if (lmap->ldap_res != NULL)
			{
				ldap_msgfree(lmap->ldap_res);
				lmap->ldap_res = NULL;
			}
			if (vp != NULL)
				sm_free(vp); /* XXX */
			return NULL;
		}
		*statp = EX_OK;
	}

d3899 1
a3899 1
		errno = ETIMEDOUT;
d3901 2
a3902 2
		errno = sm_ldap_geterrno(lmap->ldap_ld);
	if (errno != LDAP_SUCCESS)
a3903 2
		int save_errno;

d3905 1
a3905 2
			errno += E_LDAPBASE;
		save_errno = errno;
d3909 1
d3921 1
a3921 2
		errno = save_errno - E_LDAPBASE;
		switch (errno)
d3936 3
a3938 14
	/*
	**  If MF_NOREWRITE, we are special map which doesn't
	**  actually return a map value.  Instead, we don't free
	**  ldap_res and let the calling function process the LDAP
	**  results.  The caller should ldap_msgfree(lmap->ldap_res).
	*/

	if (bitset(MF_NOREWRITE, map->map_mflags))
	{
		if (vp != NULL)
			sm_free(vp); /* XXX */
		*statp = EX_OK;
		return "";
	}
d4242 1
a4242 1
			syserr("compile with -DLDAP_REFERRALS for referral support\n");
d4567 5
d4596 56
a4651 1
				lmap->ldap_attr[i++] = newstr(v);
d4654 15
a4669 1

d4865 1
a4865 1
			syserr("ph_map_parseargs: unknown option -%c\n", *p);
d5253 1
a5253 1
			syserr("syslog_map_parseargs: Unknown priority %s\n",
d6247 1
a6247 1
		syserr("prog_map_lookup(%s): read error %s\n",
d6285 1
a6285 1
		syserr("prog_map_lookup(%s): wait error %s\n",
d6711 1
a6711 1
			syserr("too many fields, %d max\n", blen);
@


1.8
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: map.c,v 8.601 2001/09/04 22:43:03 ca Exp $")
d132 1
a132 1
/*
d296 1
a296 1
/*
d424 1
a424 1
/*
d445 1
a445 1
/*
d501 1
a501 1
/*
d587 1
a587 1
/*
d603 1
a603 1
/*
d660 1
a660 1
/*
d801 1
a801 1
/*
d873 1
a873 1
/*
d931 5
d942 1
a942 1
	int dns_m_type;
d944 2
a945 1
	dns_m_type = -1;
d1058 1
a1058 1
				dns_m_type = dns_string_to_type(p);
d1061 1
a1061 1
				if (dns_m_type < 0)
d1096 1
a1096 1
	if (dns_m_type < 0)
d1109 1
a1109 1
	map->map_db1 = (ARBPTR_T) dns_m_type;
a1138 1
	int dns_m_type = (int) map->map_db1;
d1141 1
d1152 1
d1167 1
a1167 1
		r = dns_lookup_int(appdomain, C_IN, dns_m_type,
d1174 2
a1175 2
		r = dns_lookup_int(name, C_IN, dns_m_type, map->map_timeout,
				   map->map_retry);
d1239 1
a1239 1
		if (dns_m_type != rr->rr_type)
d1340 1
a1340 1
/*
d1832 1
a1832 1
/*
d2541 1
a2541 1
/*
d2774 3
d2793 1
a2793 1
/*
d3224 1
a3224 1
/*
d3975 1
a3975 1
/*
d4570 1
a4570 1
/*
d4633 1
a4633 1
/*
d4869 1
a4869 1
/*
d5045 1
a5045 1
/*
d5183 1
a5183 1
/*
d5348 1
a5348 1
/*
d5474 1
a5474 1
/*
d5725 1
a5725 1
/*
d5817 1
a5817 1
/*
d5954 1
a5954 1
/*
d6076 1
a6076 1
/*
d6200 1
a6200 1
/*
d6447 1
a6447 1
/*
d6510 1
a6510 1
/*
d6543 1
a6543 1
/*
d6920 1
a6920 1
/*
@


1.7
log
@Update to sendmail 8.11.6, from the release notes:

SECURITY: Fix a possible memory access violation when specifying
	out-of-bounds debug parameters.  Problem detected by
	Cade Cairns of SecurityFocus.
Avoid leaking recipient information in unrelated DSNs.  This could
	happen if a connection is aborted, several mails had been
	scheduled for delivery via that connection, and the timeout
	is reached such that several DSNs are sent next.  Problem
	noted by Dileepan Moorkanat of Hewlett-Packard.
Fix a possible segmentation violation when specifying too many
	wildcard operators in a rule.  Problem detected by
	Werner Wiethege.
Avoid a segmentation fault on non-matching Hesiod lookups.  Problem
	noted by Russell McOrmond of flora.ca
@
text
@d14 1
a14 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: map.c,v 8.414.4.55 2001/08/15 22:08:58 gshapiro Exp $";
#endif /* ! lint */
d16 1
a16 1
#include <sendmail.h>
d18 3
d22 1
a22 1
#ifdef NDBM
d31 1
a31 1
#ifdef NEWDB
d37 1
a37 1
#ifdef NIS
d40 1
a40 1
# ifdef NDBM
d45 1
a45 1
#ifdef NEWDB
d57 2
d60 1
a60 6
static void	ldapmap_clear __P((LDAPMAP_STRUCT *));
static STAB	*ldapmap_findconn __P((LDAPMAP_STRUCT *));
static int	ldapmap_geterrno __P((LDAP *));
static void	ldapmap_setopts __P((LDAP *, LDAPMAP_STRUCT *));
static bool	ldapmap_start __P((MAP *));
static void	ldaptimeout __P((int));
d62 1
a62 3
static void	map_close __P((STAB *, int));
static void	map_init __P((STAB *, int));
#ifdef NISPLUS
d65 1
a65 1
#ifdef NIS
d73 11
d90 2
a91 2
**		Parse the arguments from the config file.  Return TRUE
**		if they were ok, FALSE otherwise.  Fill in map with the
d109 3
a111 3
**		be either O_RDONLY or O_RDWR.  Return TRUE if it
**		was opened successfully, FALSE otherwise.  If the open
**		failed an the MF_OPTIONAL flag is not set, it should
a125 4
#ifndef EX_NOTFOUND
# define EX_NOTFOUND	EX_NOHOST
#endif /* ! EX_NOTFOUND */

d142 2
a143 2
**		TRUE -- if everything parsed OK.
**		FALSE -- otherwise.
d157 2
a158 2
	**  there is no check whether there is really an argument,
	**  but that's not important enough to warrant extra code
d160 2
a161 1
	map->map_mflags |= MF_TRY0NULL | MF_TRY1NULL;
d292 1
a292 1
		return FALSE;
d294 1
a294 1
	return TRUE;
a310 3
**
**	Side Effects:
**		none.
d331 1
a331 1
		dprintf("map_rewrite(%.*s), av =", (int)slen, s);
d333 1
a333 1
			dprintf(" (nullv)");
d337 1
a337 1
				dprintf("\n\t%s", *avp);
d339 1
a339 1
		dprintf("\n");
d372 1
a372 1
		buf = xalloc(buflen);
d392 1
a392 1
					break;
d417 1
a417 1
		(void) strlcpy(bp, map->map_app, len);
d421 1
a421 1
		dprintf("map_rewrite => %s\n", buf);
d476 1
a476 1
		dprintf("map_init(%s:%s, %s)\n",
d486 1
a486 1
			dprintf("\tnot rebuildable\n");
d498 1
a498 1
	(void) rebuildaliases(map, FALSE);
a508 1
**
d515 1
a515 1
	bool restore = FALSE;
d521 1
a521 1
		return FALSE;
d525 1
a525 1
		return TRUE;
d531 3
a533 3
		restore = TRUE;
		HoldErrs = TRUE;
		QuickAbort = FALSE;
d540 1
a540 1
			dprintf("openmap()\t%s:%s %s: valid\n",
d548 1
a548 1
		map->map_pid = getpid();
d553 1
a553 1
			dprintf("openmap()\t%s:%s %s: invalid%s%s\n",
d561 1
a561 1
				errno == 0 ? "" : errstring(errno));
d566 1
d568 2
a569 3
			map->map_mflags |= MF_OPEN;
			map->map_pid = getpid();
			MapOpenErr = TRUE;
d591 1
a591 1
**		none
d598 2
a599 1
closemaps()
d601 1
a601 1
	stabapply(map_close, 0);
d607 2
a608 2
**		s -- STAB entry: if map: try to open
**		second parameter is unused (required by stabapply())
d616 1
a616 1
map_close(s, unused)
d618 1
a618 1
	int unused;
d621 1
d628 9
d640 3
a642 1
	    map->map_pid != getpid())
d645 3
d649 1
a649 1
		dprintf("closemaps: closing %s (%s)\n",
d653 6
a658 3
	map->map_mflags |= MF_CLOSING;
	map->map_class->map_close(map);
	map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
d667 1
d670 2
a671 2
**		TRUE -- if the host was found.
**		FALSE -- otherwise.
d675 1
a675 1
getcanonname(host, hbsize, trymx)
d679 1
d683 2
a684 2
	bool found = FALSE;
	bool got_tempfail = FALSE;
d690 2
d697 1
a697 1
			dprintf("getcanonname(%s), trying %s\n",
d703 1
a703 1
#ifdef NIS
d709 1
a709 1
#ifdef NISPLUS
d718 1
a718 1
			found = dns_getcanonname(host, hbsize, trymx, &status);
d729 1
a729 1
			found = FALSE;
d749 1
a749 1
			got_tempfail = TRUE;
d764 1
a764 1
			dprintf("getcanonname(%s), found\n", host);
d779 4
a782 2
					(void) strlcat(host, ".", hbsize);
				(void) strlcat(host, d, hbsize);
d785 1
a785 1
				return FALSE;
d787 1
a787 1
		return TRUE;
d791 2
a792 1
		dprintf("getcanonname(%s), failed, status=%d\n", host, status);
a793 1
#if NAMED_BIND
d798 2
a799 2
#endif /* NAMED_BIND */
	return FALSE;
d812 2
a813 2
**		TRUE -- if the line matched the desired name.
**		FALSE -- otherwise.
d826 1
a826 1
	bool found = FALSE;
d830 1
a830 1
		return FALSE;
d844 1
a844 1
			snprintf(cbuf, cbuflen, "%s", p);
d846 2
a847 2
		if (strcasecmp(name, p) == 0)
			found = TRUE;
d852 2
a853 2
			if (strcasecmp(name, p) == 0)
				found = TRUE;
d867 1
a867 1
			(void) strlcpy(p, domain, cbuflen - i - 1);
d872 461
d1337 1
a1337 1
#ifdef NDBM
d1361 1
a1361 1
		dprintf("ndbm_map_open(%s, %s, %d)\n",
d1367 2
a1368 2
	snprintf(dirfile, sizeof dirfile, "%s.dir", map->map_file);
	snprintf(pagfile, sizeof pagfile, "%s.pag", map->map_file);
d1387 1
a1387 1
			    sff, smode, &std);
a1391 20
# if !_FFR_REMOVE_AUTOREBUILD
	if (ret == ENOENT && AutoRebuild &&
	    bitset(MCF_REBUILDABLE, map->map_class->map_cflags) &&
	    (bitset(MF_IMPL_NDBM, map->map_mflags) ||
	     bitset(MF_ALIAS, map->map_mflags)) &&
	    mode == O_RDONLY)
	{
		bool impl = bitset(MF_IMPL_NDBM, map->map_mflags);

		/* may be able to rebuild */
		map->map_mflags &= ~MF_IMPL_NDBM;
		if (!rebuildaliases(map, TRUE))
			return FALSE;
		if (impl)
			return impl_map_open(map, O_RDONLY);
		else
			return ndbm_map_open(map, O_RDONLY);
	}
# endif /* !_FFR_REMOVE_AUTOREBUILD */

d1400 1
a1400 1
			dprintf("\t%s map file: %d\n", prob, ret);
d1404 1
a1404 1
		return FALSE;
d1455 1
a1455 1
			return FALSE;
d1466 1
a1466 1
			return FALSE;
d1479 1
a1479 1
			return FALSE;
d1498 2
a1499 2
		    aliaswait(map, ".pag", FALSE))
			return TRUE;
d1507 1
a1507 1
		return FALSE;
d1522 1
a1522 1
		return FALSE;
d1537 1
a1537 1
		return FALSE;
d1560 2
a1561 2
		    !aliaswait(map, ".pag", TRUE))
			return FALSE;
d1576 1
a1576 1
					  map->map_file, errstring(err));
d1578 1
a1578 1
					map->map_file, errstring(err));
d1580 6
d1589 1
a1589 1
	return TRUE;
d1610 1
a1610 1
		dprintf("ndbm_map_lookup(%s, %s)\n",
d1644 1
a1644 1
			map->map_pid = getpid();
d1656 1
d1659 1
a1659 1
				map->map_pid = getpid();
d1707 1
a1707 1
		dprintf("ndbm_map_store(%s, %s, %s)\n",
d1744 1
a1744 1
						   (char **)NULL, &xstat);
d1751 1
a1751 1
						sm_free(buf);
d1753 1
a1753 1
					buf = xalloc(bufsiz);
d1755 2
a1756 2
				snprintf(buf, bufsiz, "%s,%s",
					data.dptr, old.dptr);
d1760 1
a1760 1
					dprintf("ndbm_map_store append=%s\n",
d1781 1
a1781 1
		dprintf("ndbm_map_close(%s, %s, %lx)\n",
d1799 1
a1799 1
			(void) snprintf(buf, sizeof buf, "%010ld", curtime());
d1829 1
a1829 1
#ifdef NEWDB
d1871 1
a1871 1
		dprintf("bt_map_open(%s, %s, %d)\n",
d1900 1
a1900 1
		dprintf("hash_map_open(%s, %s, %d)\n",
d1943 1
a1943 1
	(void) strlcpy(buf, map->map_file, sizeof buf - 3);
d1946 1
a1946 1
		(void) strlcat(buf, ".db", sizeof buf);
a1969 21
# if !_FFR_REMOVE_AUTOREBUILD
	if (i == ENOENT && AutoRebuild &&
	    bitset(MCF_REBUILDABLE, map->map_class->map_cflags) &&
	    (bitset(MF_IMPL_HASH, map->map_mflags) ||
	     bitset(MF_ALIAS, map->map_mflags)) &&
	    mode == O_RDONLY)
	{
		bool impl = bitset(MF_IMPL_HASH, map->map_mflags);

		/* may be able to rebuild */
		map->map_mflags &= ~MF_IMPL_HASH;
		if (!rebuildaliases(map, TRUE))
			return FALSE;
		if (impl)
			return impl_map_open(map, O_RDONLY);
		else
			return db_map_open(map, O_RDONLY, mapclassname,
					   dbtype, openinfo);
	}
# endif /* !_FFR_REMOVE_AUTOREBUILD */

d1978 1
a1978 1
			dprintf("\t%s map file: %s\n", prob, errstring(i));
d1983 1
a1983 1
		return FALSE;
d2007 1
a2007 1
		return FALSE;
d2017 1
a2017 1
		return FALSE;
d2028 1
a2028 1
		return FALSE;
d2117 2
a2118 2
		    aliaswait(map, ".db", FALSE))
			return TRUE;
d2127 1
a2127 1
		return FALSE;
d2150 1
a2150 1
		return FALSE;
d2175 1
a2175 1
					  buf, errstring(err));
d2177 1
a2177 1
					buf, errstring(err));
d2179 6
d2201 3
a2203 3
	    !aliaswait(map, ".db", TRUE))
		return FALSE;
	return TRUE;
d2232 1
a2232 1
		dprintf("db_map_lookup(%s, %s)\n",
d2238 1
a2238 1
	(void) strlcpy(buf, map->map_file, i + 1);
d2273 1
a2273 1
			map->map_pid = getpid();
d2286 1
d2289 1
a2289 1
				map->map_pid = getpid();
d2386 1
a2386 1
		dprintf("db_map_store(%s, %s, %s)\n",
d2442 1
a2442 1
						 (char **)NULL, &status);
d2446 1
a2446 1
				if (data.size + old.size + 2 > (size_t)bufsiz)
d2451 1
a2451 1
					buf = xalloc(bufsiz);
d2453 3
a2455 2
				snprintf(buf, bufsiz, "%s,%s",
					(char *) data.data, (char *) old.data);
d2459 1
a2459 1
					dprintf("db_map_store append=%s\n",
d2485 1
a2485 1
		dprintf("db_map_close(%s, %s, %lx)\n",
d2517 2
a2518 1
	if (map->map_pid != getpid())
d2538 1
a2538 1
#ifdef NIS
d2559 1
a2559 1
		dprintf("nis_map_open(%s, %s, %d)\n",
d2566 2
a2567 10
# ifdef ENOSYS
		errno = ENOSYS;
# else /* ENOSYS */
#  ifdef EFTYPE
		errno = EFTYPE;
#  else /* EFTYPE */
		errno = ENXIO;
#  endif /* EFTYPE */
# endif /* ENOSYS */
		return FALSE;
d2589 1
a2589 1
			return FALSE;
d2598 1
a2598 1
		dprintf("nis_map_open: yp_match(@@, %s, %s) => %s\n",
d2614 1
a2614 1
		    aliaswait(map, NULL, TRUE))
d2616 1
a2616 1
			return TRUE;
d2625 1
a2625 1
	return FALSE;
d2646 1
d2649 1
a2649 1
		dprintf("nis_map_lookup(%s, %s)\n",
d2670 1
a2670 5
		if (vp != NULL)
		{
			sm_free(vp);
			vp = NULL;
		}
d2685 6
a2690 7
	if (bitset(MF_MATCHONLY, map->map_mflags))
		return map_rewrite(map, name, strlen(name), NULL);
	else
	{
		char *ret;

		ret = map_rewrite(map, vp, vsize, av);
d2693 2
a2694 2
		return ret;
	}
d2712 2
a2713 2
	static bool try0null = TRUE;
	static bool try1null = TRUE;
d2720 1
a2720 1
		dprintf("nis_getcanonname(%s)\n", name);
d2722 1
a2722 1
	if (strlcpy(nbuf, name, sizeof nbuf) >= sizeof nbuf)
d2725 1
a2725 1
		return FALSE;
d2740 1
a2740 1
			try1null = FALSE;
d2744 1
a2744 5
		if (vp != NULL)
		{
			sm_free(vp);
			vp = NULL;
		}
d2749 1
a2749 1
			try0null = FALSE;
d2761 1
a2761 1
		return FALSE;
d2763 1
a2763 1
	(void) strlcpy(host_record, vp, sizeof host_record);
d2766 1
a2766 1
		dprintf("got record `%s'\n", host_record);
d2771 1
a2771 1
		return FALSE;
d2773 1
a2773 1
	if (hbsize <= strlen(cbuf))
d2776 1
a2776 1
		return FALSE;
a2777 1
	(void) strlcpy(name, cbuf, hbsize);
d2779 1
a2779 1
	return TRUE;
d2789 1
a2789 1
#ifdef NISPLUS
d2815 1
a2815 1
		dprintf("nisplus_map_open(%s, %s, %d)\n",
d2822 1
a2822 1
		return FALSE;
d2833 1
a2833 1
			dprintf("nisplus_map_open(%s): using domain %s\n",
d2839 1
a2839 1
		snprintf(qbuf, sizeof qbuf, "%s", map->map_file);
d2844 2
a2845 2
		snprintf(qbuf, sizeof qbuf, "%s.%s",
			map->map_file, map->map_domain);
d2863 1
a2863 1
				return FALSE;
d2877 1
a2877 1
			return FALSE;
d2885 1
a2885 1
			dprintf("nisplus_map_open: %s is not a table\n", qbuf);
d2893 1
a2893 1
		return FALSE;
d2902 1
a2902 1
	for (i = 0; i< max_col; i++)
d2910 1
a2910 1
			dprintf("nisplus_map_open(%s): can not find key column %s\n",
d2913 1
a2913 1
		return FALSE;
d2920 1
a2920 1
		return TRUE;
d2928 1
a2928 1
			return TRUE;
d2933 1
a2933 1
		dprintf("nisplus_map_open(%s): can not find column %s\n",
d2936 1
a2936 1
	return FALSE;
d2960 1
a2960 1
		dprintf("nisplus_map_lookup(%s, %s)\n",
d2968 1
a2968 1
			map->map_pid = getpid();
d3016 1
a3016 1
		snprintf(qbuf, sizeof qbuf, "[%s=%s],%s.%s",
d3020 1
a3020 1
		snprintf(qbuf, sizeof qbuf, "[%s=%s],%s",
d3024 1
a3024 1
		dprintf("qbuf=%s\n", qbuf);
d3040 1
a3040 1
				dprintf("nisplus_map_lookup(%s), got %d entries, additional entries ignored\n",
d3050 1
a3050 1
			dprintf("nisplus_map_lookup(%s), found %s\n",
d3073 1
a3073 1
		dprintf("nisplus_map_lookup(%s), failed\n", name);
d3097 1
a3097 1
	if (strlen(name) >= sizeof nbuf)
d3100 1
a3100 1
		return FALSE;
a3101 1
	(void) strlcpy(nbuf, name, sizeof nbuf);
d3108 2
a3109 1
		snprintf(qbuf, sizeof qbuf, "[name=%s],hosts.org_dir", nbuf);
d3115 2
a3116 2
		snprintf(qbuf, sizeof qbuf, "[name=%s],hosts.org_dir.%s",
			nbuf, &p[1]);
d3121 1
a3121 1
		return FALSE;
d3125 2
a3126 2
		dprintf("\nnisplus_getcanoname(%s), qbuf=%s\n",
			name, qbuf);
d3129 1
a3129 1
		NULL, NULL);
d3145 2
a3146 2
				dprintf("nisplus_getcanoname(%s), got %d entries, all but first ignored\n",
					name, count);
d3150 2
a3151 2
			dprintf("nisplus_getcanoname(%s), found in directory \"%s\"\n",
				name, (NIS_RES_OBJECT(result))->zo_domain);
d3157 2
a3158 2
			dprintf("nisplus_getcanonname(%s), found %s\n",
				name, vp);
d3172 1
a3172 1
				(void) strlcpy(name, vp, hbsize);
d3174 2
a3175 1
				snprintf(name, hbsize, "%s.%s", vp, domain);
d3181 1
a3181 1
		return TRUE;
d3193 2
a3194 2
		dprintf("nisplus_getcanonname(%s), failed, status=%d, nsw_stat=%d\n",
			name, result->status, *statp);
d3196 1
a3196 1
	return FALSE;
d3209 1
a3209 1
	snprintf(default_domain, sizeof default_domain, "%s", p);
d3224 1
a3224 1
# ifdef PH_MAP
d3228 3
a3230 1
char *
d3256 1
a3256 1
#ifdef LDAPMAP
d3258 1
a3258 1
LDAPMAP_STRUCT *LDAPDefaults = NULL;
d3273 1
a3273 1
	LDAPMAP_STRUCT *lmap;
d3277 1
a3277 1
		dprintf("ldapmap_open(%s, %d): ", map->map_mname, mode);
d3281 7
a3287 63
	/* sendmail doesn't have the ability to write to LDAP (yet) */
	if (mode != O_RDONLY)
	{
		/* issue a pseudo-error message */
# ifdef ENOSYS
		errno = ENOSYS;
# else /* ENOSYS */
#  ifdef EFTYPE
		errno = EFTYPE;
#  else /* EFTYPE */
		errno = ENXIO;
#  endif /* EFTYPE */
# endif /* ENOSYS */
		return FALSE;
	}

	/* Comma separate if used as an alias file */
	if (map->map_coldelim == '\0' && bitset(MF_ALIAS, map->map_mflags))
		map->map_coldelim = ',';

	lmap = (LDAPMAP_STRUCT *) map->map_db1;

	s = ldapmap_findconn(lmap);
	if (s->s_lmap != NULL)
	{
		/* Already have a connection open to this LDAP server */
		lmap->ldap_ld = ((LDAPMAP_STRUCT *)s->s_lmap->map_db1)->ldap_ld;

		/* Add this map as head of linked list */
		lmap->ldap_next = s->s_lmap;
		s->s_lmap = map;

		if (tTd(38, 2))
			dprintf("using cached connection\n");
		return TRUE;
	}

	if (tTd(38, 2))
		dprintf("opening new connection\n");

	/* No connection yet, connect */
	if (!ldapmap_start(map))
		return FALSE;

	/* Save connection for reuse */
	s->s_lmap = map;
	return TRUE;
}

/*
**  LDAPMAP_START -- actually connect to an LDAP server
**
**	Parameters:
**		map -- the map being opened.
**
**	Returns:
**		TRUE if connection is successful, FALSE otherwise.
**
**	Side Effects:
**		Populates lmap->ldap_ld.
*/

static jmp_buf	LDAPTimeout;
d3289 1
a3289 9
static bool
ldapmap_start(map)
	MAP *map;
{
	register int bind_result;
	int save_errno;
	register EVENT *ev = NULL;
	LDAPMAP_STRUCT *lmap;
	LDAP *ld;
d3291 5
a3295 2
	if (tTd(38, 2))
		dprintf("ldapmap_start(%s)\n", map->map_mname);
d3297 3
a3299 1
	lmap = (LDAPMAP_STRUCT *) map->map_db1;
d3301 4
a3304 4
	if (tTd(38,9))
		dprintf("ldapmap_start(%s, %d)\n",
			lmap->ldap_host == NULL ? "localhost" : lmap->ldap_host,
			lmap->ldap_port);
d3306 2
a3307 9
# if USE_LDAP_INIT
	ld = ldap_init(lmap->ldap_host, lmap->ldap_port);
	save_errno = errno;
# else /* USE_LDAP_INIT */
	/*
	**  If using ldap_open(), the actual connection to the server
	**  happens now so we need the timeout here.  For ldap_init(),
	**  the connection happens at bind time.
	*/
d3309 2
a3310 2
	/* set the timeout */
	if (lmap->ldap_timeout.tv_sec != 0)
d3312 1
a3312 1
		if (setjmp(LDAPTimeout) != 0)
a3317 1
			return FALSE;
a3318 10
		ev = setevent(lmap->ldap_timeout.tv_sec, ldaptimeout, 0);
	}

	ld = ldap_open(lmap->ldap_host, lmap->ldap_port);
	save_errno = errno;

	/* clear the event if it has not sprung */
	if (ev != NULL)
		clrevent(ev);
# endif /* USE_LDAP_INIT */
a3319 3
	errno = save_errno;
	if (ld == NULL)
	{
d3325 1
a3325 1
				       "ldap_init",
d3335 1
a3335 1
				       "ldap_init",
d3343 1
a3343 1
		return FALSE;
d3346 3
a3348 77
	ldapmap_setopts(ld, lmap);

# if USE_LDAP_INIT
	/*
	**  If using ldap_init(), the actual connection to the server
	**  happens at ldap_bind_s() so we need the timeout here.
	*/

	/* set the timeout */
	if (lmap->ldap_timeout.tv_sec != 0)
	{
		if (setjmp(LDAPTimeout) != 0)
		{
			if (LogLevel > 1)
				sm_syslog(LOG_NOTICE, CurEnv->e_id,
					  "timeout conning to LDAP server %.100s",
					  lmap->ldap_host == NULL ? "localhost"
								  : lmap->ldap_host);
			return FALSE;
		}
		ev = setevent(lmap->ldap_timeout.tv_sec, ldaptimeout, 0);
	}
# endif /* USE_LDAP_INIT */

# ifdef LDAP_AUTH_KRBV4
	if (lmap->ldap_method == LDAP_AUTH_KRBV4 &&
	    lmap->ldap_secret != NULL)
	{
		/*
		**  Need to put ticket in environment here instead of
		**  during parseargs as there may be different tickets
		**  for different LDAP connections.
		*/

		(void) putenv(lmap->ldap_secret);
	}
# endif /* LDAP_AUTH_KRBV4 */

	bind_result = ldap_bind_s(ld, lmap->ldap_binddn,
				  lmap->ldap_secret, lmap->ldap_method);

# if USE_LDAP_INIT
	/* clear the event if it has not sprung */
	if (ev != NULL)
		clrevent(ev);
# endif /* USE_LDAP_INIT */

	if (bind_result != LDAP_SUCCESS)
	{
		errno = bind_result + E_LDAPBASE;
		if (!bitset(MF_OPTIONAL, map->map_mflags))
		{
			syserr("421 4.0.0 Cannot bind to map %s in ldap server %s",
			       map->map_mname,
			       lmap->ldap_host == NULL ? "localhost" : lmap->ldap_host);
		}
		return FALSE;
	}

	/* We need to cast ld into the map structure */
	lmap->ldap_ld = ld;
	return TRUE;
}

/* ARGSUSED */
static void
ldaptimeout(sig_no)
	int sig_no;
{
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
	longjmp(LDAPTimeout, 1);
d3359 1
a3359 1
	LDAPMAP_STRUCT *lmap;
d3363 1
a3363 1
		dprintf("ldapmap_close(%s)\n", map->map_mname);
d3365 1
a3365 1
	lmap = (LDAPMAP_STRUCT *) map->map_db1;
d3372 1
a3372 1
	ldap_unbind(lmap->ldap_ld);
d3382 2
a3383 3
			dprintf("ldapmap_close(%s): closed %s (shared LDAP connection)\n",
				map->map_mname, smap->map_mname);

d3385 1
a3385 1
		lmap = (LDAPMAP_STRUCT *) smap->map_db1;
d3394 1
a3394 1
**  SUNET_ID_HASH -- Convert a string to it's Sunet_id canonical form
d3398 1
a3398 1
char *
d3442 1
a3442 2
	char *fp, *vp;
	char *p, *q;
d3444 1
a3444 1
	LDAPMAP_STRUCT *lmap = NULL;
a3445 1
	char filter[LDAPMAP_MAX_FILTER + 1];
d3448 1
a3448 1
		dprintf("ldapmap_lookup(%s, %s)\n", map->map_mname, name);
d3451 2
a3452 2
	lmap = (LDAPMAP_STRUCT *) map->map_db1;
	ldapmap_setopts(lmap->ldap_ld, lmap);
d3454 1
a3454 1
	(void) strlcpy(keybuf, name, sizeof keybuf);
d3465 1
a3465 61
	/* substitute keybuf into filter, perhaps multiple times */
	memset(filter, '\0', sizeof filter);
	fp = filter;
	p = lmap->ldap_filter;
	while ((q = strchr(p, '%')) != NULL)
	{
		if (q[1] == 's')
		{
			snprintf(fp, SPACELEFT(filter, fp), "%.*s%s",
				 (int) (q - p), p, keybuf);
			fp += strlen(fp);
			p = q + 2;
		}
		else if (q[1] == '0')
		{
			char *k = keybuf;

			snprintf(fp, SPACELEFT(filter, fp), "%.*s",
				 (int) (q - p), p);
			fp += strlen(fp);
			p = q + 2;

			/* Properly escape LDAP special characters */
			while (SPACELEFT(filter, fp) > 0 &&
			       *k != '\0')
			{
				if (*k == '*' || *k == '(' ||
				    *k == ')' || *k == '\\')
				{
					(void) strlcat(fp,
						       (*k == '*' ? "\\2A" :
							(*k == '(' ? "\\28" :
							 (*k == ')' ? "\\29" :
							  (*k == '\\' ? "\\5C" :
							   "\00")))),
						SPACELEFT(filter, fp));
					fp += strlen(fp);
					k++;
				}
				else
					*fp++ = *k++;
			}
		}
		else
		{
			snprintf(fp, SPACELEFT(filter, fp), "%.*s",
				 (int) (q - p + 1), p);
			p = q + (q[1] == '%' ? 2 : 1);
			fp += strlen(fp);
		}
	}
	snprintf(fp, SPACELEFT(filter, fp), "%s", p);
	if (tTd(38, 20))
		dprintf("ldap search filter=%s\n", filter);

	lmap->ldap_res = NULL;
	msgid = ldap_search(lmap->ldap_ld, lmap->ldap_base, lmap->ldap_scope,
			    filter,
			    (lmap->ldap_attr[0] == NULL ? NULL :
			     lmap->ldap_attr),
			    lmap->ldap_attrsonly);
d3470 1
a3470 1
		errno = ldapmap_geterrno(lmap->ldap_ld) + E_LDAPBASE;
d3476 1
a3476 1
				       filter, map->map_mname);
d3479 1
a3479 1
				       filter, map->map_mname);
d3482 3
d3486 4
a3489 3
		errno = save_errno;
		if (errno == LDAP_SERVER_DOWN + E_LDAPBASE)
		{
d3492 1
a3493 1
#endif /* LDAP_SERVER_DOWN */
d3524 1
a3524 1
					sm_free(vp);
d3526 1
a3526 1
					dprintf("ldap search found multiple on a single match query\n");
d3578 1
a3578 1
						errno = ldapmap_geterrno(lmap->ldap_ld);
d3607 1
a3607 1
							sm_free(vp);
d3657 12
a3668 1
					vp = newstr(vals[0]);
d3686 5
a3690 4
						snprintf(tmp, vsize, "%s%c%s",
							 vp, map->map_coldelim,
							 attr);
						sm_free(vp);
d3707 1
d3709 3
d3718 8
a3725 2
					p += strlcpy(p, vals[i],
						     vsize - (p - vp_tmp));
d3743 1
a3743 1
				snprintf(tmp, vsize, "%s%c%s",
d3746 2
a3747 2
				sm_free(vp);
				sm_free(vp_tmp);
d3750 1
a3750 1
			errno = ldapmap_geterrno(lmap->ldap_ld);
d3783 1
a3783 1
					sm_free(vp);
d3791 1
a3791 1
		errno = ldapmap_geterrno(lmap->ldap_ld);
d3813 1
a3813 1
				sm_free(vp);
d3838 1
a3838 1
				sm_free(vp);
d3847 1
a3847 1
		errno = ldapmap_geterrno(lmap->ldap_ld);
a3851 1
		/* Must be an error */
d3867 5
a3871 1
			sm_free(vp);
d3873 4
a3876 3
		errno = save_errno;
		if (errno == LDAP_SERVER_DOWN + E_LDAPBASE)
		{
d3879 1
a3880 1
#endif /* LDAP_SERVER_DOWN */
a3884 4
	/* Did we match anything? */
	if (vp == NULL && !bitset(MF_MATCHONLY, map->map_mflags))
		return NULL;

d3895 2
a3896 1
			sm_free(vp);
d3900 4
d3918 1
a3918 1
			sm_free(vp);
a3936 1
**
d3941 1
a3941 1
	LDAPMAP_STRUCT *lmap;
a3942 1
	int len;
d3944 1
a3944 1
	STAB *s;
d3946 17
a3962 18
	len = (lmap->ldap_host == NULL ? strlen("localhost") :
					 strlen(lmap->ldap_host)) + 1 + 8 + 1 +
		(lmap->ldap_binddn == NULL ? 0 : strlen(lmap->ldap_binddn)) +
		1 +
		(lmap->ldap_secret == NULL ? 0 : strlen(lmap->ldap_secret)) +
		8 + 1;
	nbuf = xalloc(len);
	snprintf(nbuf, len, "%s%c%d%c%s%c%s%d",
		 (lmap->ldap_host == NULL ? "localhost" : lmap->ldap_host),
		 CONDELSE,
		 lmap->ldap_port,
		 CONDELSE,
		 (lmap->ldap_binddn == NULL ? "" : lmap->ldap_binddn),
		 CONDELSE,
		 (lmap->ldap_secret == NULL ? "" : lmap->ldap_secret),
		 (int) getpid());
	s = stab(nbuf, ST_LMAP, ST_ENTER);
	sm_free(nbuf);
a3965 84
**  LDAPMAP_SETOPTS -- set LDAP options
**
**	Parameters:
**		ld -- LDAP session handle
**		lmap -- LDAP map information
**
**	Returns:
**		None.
**
*/

static void
ldapmap_setopts(ld, lmap)
	LDAP *ld;
	LDAPMAP_STRUCT *lmap;
{
# if USE_LDAP_SET_OPTION
	ldap_set_option(ld, LDAP_OPT_DEREF, &lmap->ldap_deref);
	if (bitset(LDAP_OPT_REFERRALS, lmap->ldap_options))
		ldap_set_option(ld, LDAP_OPT_REFERRALS, LDAP_OPT_ON);
	else
		ldap_set_option(ld, LDAP_OPT_REFERRALS, LDAP_OPT_OFF);
	ldap_set_option(ld, LDAP_OPT_SIZELIMIT, &lmap->ldap_sizelimit);
	ldap_set_option(ld, LDAP_OPT_TIMELIMIT, &lmap->ldap_timelimit);
# else /* USE_LDAP_SET_OPTION */
	/* From here on in we can use ldap internal timelimits */
	ld->ld_deref = lmap->ldap_deref;
	ld->ld_options = lmap->ldap_options;
	ld->ld_sizelimit = lmap->ldap_sizelimit;
	ld->ld_timelimit = lmap->ldap_timelimit;
# endif /* USE_LDAP_SET_OPTION */
}
/*
**  LDAPMAP_GETERRNO -- get ldap errno value
**
**	Parameters:
**		ld -- LDAP session handle
**
**	Returns:
**		LDAP errno.
**
*/

static int
ldapmap_geterrno(ld)
	LDAP *ld;
{
	int err = LDAP_SUCCESS;

# if defined(LDAP_VERSION_MAX) && LDAP_VERSION_MAX >= 3
	(void) ldap_get_option(ld, LDAP_OPT_ERROR_NUMBER, &err);
# else /* defined(LDAP_VERSION_MAX) && LDAP_VERSION_MAX >= 3 */
#  ifdef LDAP_OPT_SIZELIMIT
	err = ldap_get_lderrno(ld, NULL, NULL);
#  else /* LDAP_OPT_SIZELIMIT */
	err = ld->ld_errno;

	/*
	**  Reset value to prevent lingering LDAP_DECODING_ERROR due to
	**  OpenLDAP 1.X's hack (see above)
	*/

	ld->ld_errno = LDAP_SUCCESS;
#  endif /* LDAP_OPT_SIZELIMIT */
# endif /* defined(LDAP_VERSION_MAX) && LDAP_VERSION_MAX >= 3 */
	return err;
}

/*
**  LDAPX_MAP_PARSEARGS -- print warning about use of ldapx map.
*/

bool
ldapx_map_parseargs(map, args)
	MAP *map;
	char *args;
{
	printf("Warning: The \"ldapx\" map class is deprecated and will be removed in a future\n");
	printf("         version.  Use the \"ldap\" map class instead for map \"%s\".\n",
	       map->map_mname);
	return ldapmap_parseargs(map, args);
}

/*
d3969 1
a3969 1
struct lamvalues LDAPAuthMethods[] =
d3979 1
a3979 1
struct ladvalues LDAPAliasDereference[] =
d3988 1
a3988 1
struct lssvalues LDAPSearchScope[] =
d4001 1
a4001 1
	bool secretread = TRUE;
d4004 1
a4004 1
	LDAPMAP_STRUCT *lmap;
d4008 1
d4012 1
a4012 1
	lmap = (LDAPMAP_STRUCT *) map->map_db1;
d4017 2
a4018 2
		/* We need to alloc an LDAPMAP_STRUCT struct */
		lmap = (LDAPMAP_STRUCT *) xalloc(sizeof *lmap);
d4020 1
a4020 1
			ldapmap_clear(lmap);
d4028 52
d4159 21
d4214 1
a4214 1
			if (strncasecmp(p, "LDAP_DEREF_", 11) == 0)
d4220 2
a4221 2
				if (strncasecmp(p, lad->lad_name,
						strlen(lad->lad_name)) == 0)
d4240 1
a4240 1
					return FALSE;
d4249 1
a4249 1
			if (strncasecmp(p, "LDAP_SCOPE_", 11) == 0)
d4255 2
a4256 2
				if (strncasecmp(p, lss->lss_name,
						strlen(lss->lss_name)) == 0)
d4275 1
a4275 1
					return FALSE;
d4321 1
a4321 1
			if (strncasecmp(p, "LDAP_AUTH_", 10) == 0)
d4327 2
a4328 2
				if (strncasecmp(p, lam->lam_name,
						strlen(lam->lam_name)) == 0)
d4347 1
a4347 1
					return FALSE;
d4362 1
a4362 1
			secretread = FALSE;
d4416 1
a4416 1
		FILE *sfd;
d4446 1
a4446 1
				return FALSE;
d4451 1
a4451 1
			(void) fclose(sfd);
d4471 4
a4474 3
			snprintf(m_tmp, MAXPATHLEN + LDAPMAP_MAX_PASSWD,
				 "KRBTKFILE=%s",
				 ldapmap_dequote(lmap->ldap_secret));
d4481 2
a4482 1
			return FALSE;
d4512 1
a4512 1
		return TRUE;
d4521 1
a4521 1
			return FALSE;
d4548 1
a4548 1
				return FALSE;
d4557 1
a4557 1
	return TRUE;
a4559 39
/*
**  LDAPMAP_CLEAR -- set default values for LDAPMAP_STRUCT
**
**	Parameters:
**		lmap -- pointer to LDAPMAP_STRUCT to clear
**
**	Returns:
**		None.
**
*/

static void
ldapmap_clear(lmap)
	LDAPMAP_STRUCT *lmap;
{
	lmap->ldap_host = NULL;
	lmap->ldap_port = LDAP_PORT;
	lmap->ldap_deref = LDAP_DEREF_NEVER;
	lmap->ldap_timelimit = LDAP_NO_LIMIT;
	lmap->ldap_sizelimit = LDAP_NO_LIMIT;
# ifdef LDAP_REFERRALS
	lmap->ldap_options = LDAP_OPT_REFERRALS;
# else /* LDAP_REFERRALS */
	lmap->ldap_options = 0;
# endif /* LDAP_REFERRALS */
	lmap->ldap_binddn = NULL;
	lmap->ldap_secret = NULL;
	lmap->ldap_method = LDAP_AUTH_SIMPLE;
	lmap->ldap_base = NULL;
	lmap->ldap_scope = LDAP_SCOPE_SUBTREE;
	lmap->ldap_attrsonly = LDAPMAP_FALSE;
	lmap->ldap_timeout.tv_sec = 0;
	lmap->ldap_timeout.tv_usec = 0;
	lmap->ldap_ld = NULL;
	lmap->ldap_filter = NULL;
	lmap->ldap_attr[0] = NULL;
	lmap->ldap_res = NULL;
	lmap->ldap_next = NULL;
}
a4567 1
**
d4579 2
a4580 2
		LDAPDefaults = (LDAPMAP_STRUCT *) xalloc(sizeof *LDAPDefaults);
	ldapmap_clear(LDAPDefaults);
d4604 2
a4605 10
		if (map.map_app != NULL)
		{
			sm_free(map.map_app);
			map.map_app = NULL;
		}
		if (map.map_tapp != NULL)
		{
			sm_free(map.map_tapp);
			map.map_tapp = NULL;
		}
d4627 1
a4627 1
#ifdef PH_MAP
d4635 5
a4639 2
# include <qiapi.h>
# include <qicode.h>
d4650 2
a4651 2
	int i;
	register int done;
d4653 5
a4657 1
	register char *p = args;
d4664 1
a4664 3
	pmap->ph_to_server = NULL;
	pmap->ph_from_server = NULL;
	pmap->ph_sockfd = -1;
d4666 1
a4717 1
#if _FFR_PHMAP_TIMEOUT
a4722 1
#endif /* _FFR_PHMAP_TIMEOUT */
d4738 7
a4744 1
		  case 'v':		/* fields to search for */
a4780 2
	else
		pmap->ph_field_list = DEFAULT_PH_MAP_FIELDS;
d4787 1
a4787 1
		return FALSE;
d4791 1
a4791 1
	return TRUE;
a4793 1
#if _FFR_PHMAP_TIMEOUT
d4798 2
a4799 2
static void
ph_map_safeclose(map)
a4801 1
	int save_errno = errno;
d4805 4
d4810 1
a4810 1
	if (pmap->ph_sockfd != -1)
d4812 3
a4814 12
		(void) close(pmap->ph_sockfd);
		pmap->ph_sockfd = -1;
	}
	if (pmap->ph_from_server != NULL)
	{
		(void) fclose(pmap->ph_from_server);
		pmap->ph_from_server = NULL;
	}
	if (pmap->ph_to_server != NULL)
	{
		(void) fclose(pmap->ph_to_server);
		pmap->ph_to_server = NULL;
d4816 1
a4817 13
	errno = save_errno;
}

void
ph_map_close(map)
	MAP *map;
{
	PH_MAP_STRUCT *pmap;

	pmap = (PH_MAP_STRUCT *)map->map_db1;
	(void) fprintf(pmap->ph_to_server, "quit\n");
	(void) fflush(pmap->ph_to_server);
	ph_map_safeclose(map);
d4824 2
a4825 2
ph_timeout(sig)
	int sig;
a4835 4
#else /* _FFR_PHMAP_TIMEOUT */
/*
**  PH_MAP_CLOSE -- close the connection to the ph server
*/
d4837 3
a4839 3
void
ph_map_close(map)
	MAP *map;
d4841 6
a4846 1
	PH_MAP_STRUCT *pmap;
d4848 9
a4856 4
	pmap = (PH_MAP_STRUCT *)map->map_db1;
	CloseQi(pmap->ph_to_server, pmap->ph_from_server);
	pmap->ph_to_server = NULL;
	pmap->ph_from_server = NULL;
a4857 1
#endif /* _FFR_PHMAP_TIMEOUT */
d4867 2
a4868 1
#if !_FFR_PHMAP_TIMEOUT
d4870 1
a4870 8
#endif /* !_FFR_PHMAP_TIMEOUT */
	int j;
	char *hostlist, *tmp;
	QIR *server_data = NULL;
	PH_MAP_STRUCT *pmap;
#if _FFR_PHMAP_TIMEOUT
	register EVENT *ev = NULL;
#endif /* _FFR_PHMAP_TIMEOUT */
d4873 1
a4873 1
		dprintf("ph_map_open(%s)\n", map->map_mname);
d4879 2
a4880 10
# ifdef ENOSYS
		errno = ENOSYS;
# else /* ENOSYS */
#  ifdef EFTYPE
		errno = EFTYPE;
#  else /* EFTYPE */
		errno = ENXIO;
#  endif /* EFTYPE */
# endif /* ENOSYS */
		return FALSE;
d4887 2
a4888 2
			dprintf("ph_map_open(%s) => DEFERRED\n",
				map->map_mname);
d4891 3
a4893 3
		** Unset MF_DEFER here so that map_lookup() returns
		** a temporary failure using the bogus map and
		** map->map_tapp instead of the default permanent error.
d4897 1
a4897 1
		return FALSE;
d4901 1
d4903 1
d4905 3
a4907 2
	tmp = strtok(hostlist, " ");
	do
d4909 1
a4909 1
#if _FFR_PHMAP_TIMEOUT
d4918 1
a4918 2
						  tmp);
# ifdef ETIMEDOUT
a4919 3
# else /* ETIMEDOUT */
				errno = EAGAIN;
# endif /* ETIMEDOUT */
d4922 1
a4922 1
			ev = setevent(pmap->ph_timeout, ph_timeout, 0);
d4924 5
a4928 7
		if (!OpenQiSock(tmp, &(pmap->ph_sockfd)) &&
		    !Sock2FILEs(pmap->ph_sockfd, &(pmap->ph_to_server),
				&(pmap->ph_from_server)) &&
		    fprintf(pmap->ph_to_server, "id sendmail+phmap\n") >= 0 &&
		    fflush(pmap->ph_to_server) == 0 &&
		    (server_data = ReadQi(pmap->ph_from_server, &j)) != NULL &&
		    server_data->code == 200)
d4931 3
a4933 23
				clrevent(ev);
			FreeQIR(server_data);
#else /* _FFR_PHMAP_TIMEOUT */
		if (OpenQi(tmp, &(pmap->ph_to_server),
			   &(pmap->ph_from_server)) >= 0)
		{
			if (fprintf(pmap->ph_to_server,
				    "id sendmail+phmap\n") < 0 ||
			    fflush(pmap->ph_to_server) != 0 ||
			    (server_data = ReadQi(pmap->ph_from_server,
						  &j)) == NULL ||
			    server_data->code != 200)
			{
				save_errno = errno;
				CloseQi(pmap->ph_to_server,
					pmap->ph_from_server);
				continue;
			}
			if (server_data != NULL)
				FreeQIR(server_data);
#endif /* _FFR_PHMAP_TIMEOUT */
			sm_free(hostlist);
			return TRUE;
d4935 1
a4935 1
#if _FFR_PHMAP_TIMEOUT
d4937 1
d4939 5
a4943 11
			clrevent(ev);
		ph_map_safeclose(map);
		if (server_data != NULL)
		{
			FreeQIR(server_data);
			server_data = NULL;
		}
#else /* _FFR_PHMAP_TIMEOUT */
		save_errno = errno;
#endif /* _FFR_PHMAP_TIMEOUT */
	} while (tmp = strtok(NULL, " "));
a4944 3
#if !_FFR_PHMAP_TIMEOUT
	errno = save_errno;
#endif /* !_FFR_PHMAP_TIMEOUT */
d4956 2
a4957 2
	sm_free(hostlist);
	return FALSE;
a4963 4
#if _FFR_PHMAP_TIMEOUT
# define MAX_PH_FIELDS	20
#endif /* _FFR_PHMAP_TIMEOUT */

d4971 2
a4972 12
	int j;
	size_t sz;
	char *tmp, *tmp2;
	char *message = NULL, *field = NULL, *fmtkey;
	QIR *server_data = NULL;
	QIR *qirp;
	char keybuf[MAXKEY + 1], fieldbuf[101];
#if _FFR_PHMAP_TIMEOUT
	QIR *hold_data[MAX_PH_FIELDS];
	int hold_data_idx = 0;
	register EVENT *ev = NULL;
#endif /* _FFR_PHMAP_TIMEOUT */
d4974 1
d4980 1
a4980 1
#if _FFR_PHMAP_TIMEOUT
a4989 1
# ifdef ETIMEDOUT
a4990 3
# else /* ETIMEDOUT */
			errno = 0;
# endif /* ETIMEDOUT */
d4994 1
a4994 1
		ev = setevent(pmap->ph_timeout, ph_timeout, 0);
d4997 6
a5002 134
#endif /* _FFR_PHMAP_TIMEOUT */
	/* check all relevant fields */
	tmp = pmap->ph_field_list;
	do
	{
#if _FFR_PHMAP_TIMEOUT
		server_data = NULL;
#endif /* _FFR_PHMAP_TIMEOUT */
		while (isascii(*tmp) && isspace(*tmp))
			tmp++;
		if (*tmp == '\0')
			break;
		sz = strcspn(tmp, " ") + 1;
		if (sz > sizeof fieldbuf)
			sz = sizeof fieldbuf;
		(void) strlcpy(fieldbuf, tmp, sz);
		field = fieldbuf;
		tmp += sz;

		(void) strlcpy(keybuf, key, sizeof keybuf);
		fmtkey = keybuf;
		if (strcmp(field, "alias") == 0)
		{
			/*
			**  for alias lookups, replace any punctuation
			**  characters with '-'
			*/

			for (tmp2 = fmtkey; *tmp2 !=  '\0'; tmp2++)
			{
				if (isascii(*tmp2) && ispunct(*tmp2))
					*tmp2 = '-';
			}
			tmp2 = field;
		}
		else if (strcmp(field,"spacedname") == 0)
		{
			/*
			**  for "spaced" name lookups, replace any
			**  punctuation characters with a space
			*/

			for (tmp2 = fmtkey; *tmp2 != '\0'; tmp2++)
			{
				if (isascii(*tmp2) && ispunct(*tmp2) &&
				    *tmp2 != '*')
					*tmp2 = ' ';
			}
			tmp2 = &(field[6]);
		}
		else
			tmp2 = field;

		if (LogLevel > 9)
			sm_syslog(LOG_NOTICE, CurEnv->e_id,
				  "ph_map_lookup: query %s=\"%s\" return email",
				  tmp2, fmtkey);
		if (tTd(38, 20))
			dprintf("ph_map_lookup: query %s=\"%s\" return email\n",
				tmp2, fmtkey);

		j = 0;

		if (fprintf(pmap->ph_to_server, "query %s=%s return email\n",
			    tmp2, fmtkey) < 0)
			message = "qi query command failed";
		else if (fflush(pmap->ph_to_server) != 0)
			message = "qi fflush failed";
		else if ((server_data = ReadQi(pmap->ph_from_server,
					       &j)) == NULL)
			message = "ReadQi() returned NULL";

#if _FFR_PHMAP_TIMEOUT
		if ((hold_data[hold_data_idx] = server_data) != NULL)
		{
			/* save pointer for later free() */
			hold_data_idx++;
		}
#endif /* _FFR_PHMAP_TIMEOUT */

		if (server_data == NULL ||
		    (server_data->code >= 400 &&
		     server_data->code < 500))
		{
			/* temporary failure */
			*pstat = EX_TEMPFAIL;
#if _FFR_PHMAP_TIMEOUT
			break;
#else /* _FFR_PHMAP_TIMEOUT */
			if (server_data != NULL)
			{
				FreeQIR(server_data);
				server_data = NULL;
			}
			return NULL;
#endif /* _FFR_PHMAP_TIMEOUT */
		}

		/*
		**  if we found a single match, break out.
		**  otherwise, try the next field.
		*/

		if (j == 1)
			break;

		/*
		**  check for a single response which is an error:
		**  ReadQi() doesn't set j on error responses,
		**  but we should stop here instead of moving on if
		**  it happens (e.g., alias found but email field empty)
		*/

		for (qirp = server_data;
		     qirp != NULL && qirp->code < 0;
		     qirp++)
		{
			if (tTd(38, 20))
				dprintf("ph_map_lookup: QIR: %d:%d:%d:%s\n",
					qirp->code, qirp->subcode, qirp->field,
					(qirp->message ? qirp->message
					 : "[NULL]"));
			if (qirp->code <= -500)
			{
				j = 0;
				goto ph_map_lookup_abort;
			}
		}

#if _FFR_PHMAP_TIMEOUT
	} while (*tmp != '\0' && hold_data_idx < MAX_PH_FIELDS);
#else /* _FFR_PHMAP_TIMEOUT */
	} while (*tmp != '\0');
#endif /* _FFR_PHMAP_TIMEOUT */
a5004 1
#if _FFR_PHMAP_TIMEOUT
d5006 1
a5006 1
		clrevent(ev);
d5009 1
a5009 1
	**  Return EX_TEMPFAIL if the timer popped
d5014 6
a5019 5
		ph_map_safeclose(map);

	/* if we didn't find a single match, bail out */
	if (*pstat == EX_OK && j != 1)
		*pstat = EX_UNAVAILABLE;
a5022 18
		/*
		** skip leading whitespace and chop at first address
		*/

		for (tmp = server_data->message;
		     isascii(*tmp) && isspace(*tmp);
		     tmp++)
			continue;

		for (tmp2 = tmp; *tmp2 != '\0'; tmp2++)
		{
			if (isascii(*tmp2) && isspace(*tmp2))
			{
				*tmp2 = '\0';
				break;
			}
		}

d5024 1
a5024 1
			dprintf("ph_map_lookup: %s => %s\n", key, tmp);
d5027 1
a5027 1
			message = map_rewrite(map, key, strlen(key), NULL);
d5029 1
a5029 14
			message = map_rewrite(map, tmp, strlen(tmp), args);
	}

	/*
	**  Deferred free() of returned server_data values
	**  the deferral is to avoid the risk of a free() being
	**  interrupted by the event timer.  By now the timeout event
	**  has been cleared and none of the data is still in use.
	*/

	while (--hold_data_idx >= 0)
	{
		if (hold_data[hold_data_idx] != NULL)
			FreeQIR(hold_data[hold_data_idx]);
a5031 3
	if (*pstat == EX_OK)
		return message;

a5032 45
#else /* _FFR_PHMAP_TIMEOUT */
	/* if we didn't find a single match, bail out */
	if (j != 1)
	{
		*pstat = EX_UNAVAILABLE;
		if (server_data != NULL)
		{
			FreeQIR(server_data);
			server_data = NULL;
		}
		return NULL;
	}

	/*
	** skip leading whitespace and chop at first address
	*/

	for (tmp = server_data->message;
	     isascii(*tmp) && isspace(*tmp);
	     tmp++)
		continue;

	for (tmp2 = tmp; *tmp2 != '\0'; tmp2++)
	{
		if (isascii(*tmp2) && isspace(*tmp2))
		{
			*tmp2 = '\0';
			break;
		}
	}

	if (tTd(38,20))
		dprintf("ph_map_lookup: %s => %s\n", key, tmp);

	if (bitset(MF_MATCHONLY, map->map_mflags))
		message = map_rewrite(map, key, strlen(key), NULL);
	else
		message = map_rewrite(map, tmp, strlen(tmp), args);
	if (server_data != NULL)
	{
		FreeQIR(server_data);
		server_data = NULL;
	}
	return message;
#endif /* _FFR_PHMAP_TIMEOUT */
d5095 1
a5095 1
		if (strncasecmp("LOG_", priority, 4) == 0)
d5099 1
a5099 1
		if (strcasecmp("EMERG", priority) == 0)
d5104 1
a5104 1
		if (strcasecmp("ALERT", priority) == 0)
d5109 1
a5109 1
		if (strcasecmp("CRIT", priority) == 0)
d5114 1
a5114 1
		if (strcasecmp("ERR", priority) == 0)
d5119 1
a5119 1
		if (strcasecmp("WARNING", priority) == 0)
d5124 1
a5124 1
		if (strcasecmp("NOTICE", priority) == 0)
d5129 1
a5129 1
		if (strcasecmp("INFO", priority) == 0)
d5134 1
a5134 1
		if (strcasecmp("DEBUG", priority) == 0)
d5141 1
a5141 1
			return FALSE;
d5144 1
a5144 1
	return TRUE;
d5163 1
a5163 1
			dprintf("syslog_map_lookup(%s (priority %d): %s\n",
d5177 1
a5177 1
#ifdef HESIOD
d5185 1
a5185 1
		dprintf("hes_map_open(%s, %s, %d)\n",
d5191 2
a5192 10
# ifdef ENOSYS
		errno = ENOSYS;
# else /* ENOSYS */
#  ifdef EFTYPE
		errno = EFTYPE;
#  else /* EFTYPE */
		errno = ENXIO;
#  endif /* EFTYPE */
# endif /* ENOSYS */
		return FALSE;
d5197 1
a5197 1
		return TRUE;
d5201 2
a5202 2
			errstring(errno));
	return FALSE;
d5210 1
a5210 1
		return TRUE;
d5216 1
a5216 1
	return FALSE;
d5230 1
a5230 1
		dprintf("hes_map_lookup(%s, %s)\n", map->map_file, name);
d5245 1
a5245 1
		(void) strlcpy(&np[1], name, (sizeof nbuf) - 1);
d5253 1
a5253 1
			sm_free(np);
a5272 1
		  case EMSGSIZE:
d5275 1
d5316 21
d5357 1
a5357 1
		dprintf("ni_map_open(%s, %s, %d)\n",
d5367 8
a5374 4
	if (map->map_coldelim == '\0' && bitset(MF_ALIAS, map->map_mflags))
		map->map_coldelim = ',';

	return TRUE;
d5393 1
a5393 1
		dprintf("ni_map_lookup(%s, %s)\n", map->map_mname, name);
d5401 8
a5408 5
	if (bitset(MF_MATCHONLY, map->map_mflags))
		res = map_rewrite(map, name, strlen(name), NULL);
	else
		res = map_rewrite(map, propval, strlen(propval), av);
	sm_free(propval);
d5424 1
a5424 1
		dprintf("ni_getcanonname(%s)\n", name);
d5426 1
a5426 1
	if (strlcpy(nbuf, name, sizeof nbuf) >= sizeof nbuf)
d5429 1
a5429 1
		return FALSE;
d5437 1
a5437 1
		return FALSE;
d5446 1
a5446 1
		return FALSE;
d5453 1
a5453 1
	if (hbsize >= strlen(vptr))
a5454 1
		(void) strlcpy(name, vptr, hbsize);
d5456 2
a5457 2
		*statp = EX_OK;
		return TRUE;
a5458 1
	*statp = EX_UNAVAILABLE;
d5460 2
a5461 185
	return FALSE;
}


/*
**  NI_PROPVAL -- NetInfo property value lookup routine
**
**	Parameters:
**		keydir -- the NetInfo directory name in which to search
**			for the key.
**		keyprop -- the name of the property in which to find the
**			property we are interested.  Defaults to "name".
**		keyval -- the value for which we are really searching.
**		valprop -- the property name for the value in which we
**			are interested.
**		sepchar -- if non-nil, this can be multiple-valued, and
**			we should return a string separated by this
**			character.
**
**	Returns:
**		NULL -- if:
**			1. the directory is not found
**			2. the property name is not found
**			3. the property contains multiple values
**			4. some error occurred
**		else -- the value of the lookup.
**
**	Example:
**		To search for an alias value, use:
**		  ni_propval("/aliases", "name", aliasname, "members", ',')
**
**	Notes:
**		Caller should free the return value of ni_proval
*/

# include <netinfo/ni.h>

# define LOCAL_NETINFO_DOMAIN	"."
# define PARENT_NETINFO_DOMAIN	".."
# define MAX_NI_LEVELS		256

char *
ni_propval(keydir, keyprop, keyval, valprop, sepchar)
	char *keydir;
	char *keyprop;
	char *keyval;
	char *valprop;
	int sepchar;
{
	char *propval = NULL;
	int i;
	int j, alen, l;
	void *ni = NULL;
	void *lastni = NULL;
	ni_status nis;
	ni_id nid;
	ni_namelist ninl;
	register char *p;
	char keybuf[1024];

	/*
	**  Create the full key from the two parts.
	**
	**	Note that directory can end with, e.g., "name=" to specify
	**	an alternate search property.
	*/

	i = strlen(keydir) + strlen(keyval) + 2;
	if (keyprop != NULL)
		i += strlen(keyprop) + 1;
	if (i >= sizeof keybuf)
		return NULL;
	(void) strlcpy(keybuf, keydir, sizeof keybuf);
	(void) strlcat(keybuf, "/", sizeof keybuf);
	if (keyprop != NULL)
	{
		(void) strlcat(keybuf, keyprop, sizeof keybuf);
		(void) strlcat(keybuf, "=", sizeof keybuf);
	}
	(void) strlcat(keybuf, keyval, sizeof keybuf);

	if (tTd(38, 21))
		dprintf("ni_propval(%s, %s, %s, %s, %d) keybuf='%s'\n",
			keydir, keyprop, keyval, valprop, sepchar, keybuf);
	/*
	**  If the passed directory and property name are found
	**  in one of netinfo domains we need to search (starting
	**  from the local domain moving all the way back to the
	**  root domain) set propval to the property's value
	**  and return it.
	*/

	for (i = 0; i < MAX_NI_LEVELS && propval == NULL; i++)
	{
		if (i == 0)
		{
			nis = ni_open(NULL, LOCAL_NETINFO_DOMAIN, &ni);
			if (tTd(38, 20))
				dprintf("ni_open(LOCAL) = %d\n", nis);
		}
		else
		{
			if (lastni != NULL)
				ni_free(lastni);
			lastni = ni;
			nis = ni_open(lastni, PARENT_NETINFO_DOMAIN, &ni);
			if (tTd(38, 20))
				dprintf("ni_open(PARENT) = %d\n", nis);
		}

		/*
		**  Don't bother if we didn't get a handle on a
		**  proper domain.  This is not necessarily an error.
		**  We would get a positive ni_status if, for instance
		**  we never found the directory or property and tried
		**  to open the parent of the root domain!
		*/

		if (nis != 0)
			break;

		/*
		**  Find the path to the server information.
		*/

		if (ni_pathsearch(ni, &nid, keybuf) != 0)
			continue;

		/*
		**  Find associated value information.
		*/

		if (ni_lookupprop(ni, &nid, valprop, &ninl) != 0)
			continue;

		if (tTd(38, 20))
			dprintf("ni_lookupprop: len=%d\n",
				ninl.ni_namelist_len);

		/*
		**  See if we have an acceptable number of values.
		*/

		if (ninl.ni_namelist_len <= 0)
			continue;

		if (sepchar == '\0' && ninl.ni_namelist_len > 1)
		{
			ni_namelist_free(&ninl);
			continue;
		}

		/*
		**  Calculate number of bytes needed and build result
		*/

		alen = 1;
		for (j = 0; j < ninl.ni_namelist_len; j++)
			alen += strlen(ninl.ni_namelist_val[j]) + 1;
		propval = p = xalloc(alen);
		for (j = 0; j < ninl.ni_namelist_len; j++)
		{
			(void) strlcpy(p, ninl.ni_namelist_val[j], alen);
			l = strlen(p);
			p += l;
			*p++ = sepchar;
			alen -= l + 1;
		}
		*--p = '\0';

		ni_namelist_free(&ninl);
	}

	/*
	**  Clean up.
	*/

	if (ni != NULL)
		ni_free(ni);
	if (lastni != NULL && ni != lastni)
		ni_free(lastni);
	if (tTd(38, 20))
		dprintf("ni_propval returns: '%s'\n", propval);

	return propval;
a5462 1

d5486 1
a5486 1
		dprintf("text_map_open(%s, %s, %d)\n",
d5493 1
a5493 1
		return FALSE;
d5500 1
a5500 1
		return FALSE;
d5507 1
a5507 1
		return FALSE;
d5522 1
a5522 1
			dprintf("\tunsafe map file: %d\n", i);
d5527 1
a5527 1
		return FALSE;
d5539 1
a5539 1
			return FALSE;
d5553 1
a5553 1
			return FALSE;
d5560 1
a5560 1
		dprintf("text_map_open(%s, %s): delimiter = ",
d5563 1
a5563 1
			dprintf("(white space)\n");
d5565 1
a5565 1
			dprintf("%c\n", map->map_coldelim);
d5569 1
a5569 1
	return TRUE;
d5587 1
a5587 1
	FILE *f;
d5596 1
a5596 1
	found_it = FALSE;
d5598 1
a5598 1
		dprintf("text_map_lookup(%s, %s)\n", map->map_mname,  name);
d5602 1
a5602 1
		buflen = sizeof search_key - 1;
d5617 1
a5617 1
	while (fgets(linebuf, MAXLINE, f) != NULL)
d5628 1
a5628 1
		if (p != NULL && strcasecmp(search_key, p) == 0)
d5630 1
a5630 1
			found_it = TRUE;
d5634 1
a5634 1
	(void) fclose(f);
d5666 1
a5666 1
	FILE *f;
d5672 1
a5672 1
		dprintf("text_getcanonname(%s)\n", name);
d5674 1
a5674 1
	if (strlen(name) >= (SIZE_T) sizeof nbuf)
d5677 1
a5677 1
		return FALSE;
a5678 1
	(void) strlcpy(nbuf, name, sizeof nbuf);
d5681 2
a5682 1
	f = fopen(HostsFile, "r");
d5686 1
a5686 1
		return FALSE;
d5688 3
a5690 2
	found = FALSE;
	while (!found && fgets(linebuf, MAXLINE, f) != NULL)
d5700 1
a5700 1
	(void) fclose(f);
d5704 1
a5704 1
		return FALSE;
d5707 1
a5707 1
	if ((SIZE_T) hbsize >= strlen(cbuf))
d5709 2
a5710 3
		(void) strlcpy(name, cbuf, hbsize);
		*statp = EX_OK;
		return TRUE;
d5712 2
a5713 2
	*statp = EX_UNAVAILABLE;
	return FALSE;
d5735 1
a5735 1
		dprintf("stab_lookup(%s, %s)\n",
d5776 1
a5776 1
	FILE *af;
d5781 1
a5781 1
		dprintf("stab_map_open(%s, %s, %d)\n",
d5788 1
a5788 1
		return FALSE;
d5798 2
a5799 2
		return FALSE;
	readaliases(map, af, FALSE, FALSE);
d5801 1
a5801 1
	if (fstat(fileno(af), &st) >= 0)
d5803 1
a5803 1
	(void) fclose(af);
d5805 1
a5805 1
	return TRUE;
d5826 1
a5826 1
		dprintf("impl_map_lookup(%s, %s)\n",
d5829 1
a5829 1
#ifdef NEWDB
d5833 1
a5833 1
#ifdef NDBM
d5851 1
a5851 1
		dprintf("impl_map_store(%s, %s, %s)\n",
d5853 1
a5853 1
#ifdef NEWDB
d5857 1
a5857 1
#ifdef NDBM
d5874 1
a5874 1
		dprintf("impl_map_open(%s, %s, %d)\n",
d5878 1
a5878 1
#ifdef NEWDB
d5885 1
a5885 1
			return TRUE;
d5890 1
a5890 1
#ifdef NDBM
d5894 1
a5894 1
		return TRUE;
d5913 1
a5913 1
		return FALSE;
d5926 1
a5926 1
		dprintf("impl_map_close(%s, %s, %lx)\n",
d5928 1
a5928 1
#ifdef NEWDB
d5936 1
a5936 1
#ifdef NDBM
d5962 1
a5962 1
		dprintf("user_map_open(%s, %d)\n",
d5969 2
a5970 10
#ifdef ENOSYS
		errno = ENOSYS;
#else /* ENOSYS */
# ifdef EFTYPE
		errno = EFTYPE;
# else /* EFTYPE */
		errno = ENXIO;
# endif /* EFTYPE */
#endif /* ENOSYS */
		return FALSE;
d5975 1
a5975 1
	else if (strcasecmp(map->map_valcolnm, "name") == 0)
d5977 1
a5977 1
	else if (strcasecmp(map->map_valcolnm, "passwd") == 0)
d5979 1
a5979 1
	else if (strcasecmp(map->map_valcolnm, "uid") == 0)
d5981 1
a5981 1
	else if (strcasecmp(map->map_valcolnm, "gid") == 0)
d5983 1
a5983 1
	else if (strcasecmp(map->map_valcolnm, "gecos") == 0)
d5985 1
a5985 1
	else if (strcasecmp(map->map_valcolnm, "dir") == 0)
d5987 1
a5987 1
	else if (strcasecmp(map->map_valcolnm, "shell") == 0)
d5993 1
a5993 1
		return FALSE;
d5995 1
a5995 1
	return TRUE;
a6010 1
	struct passwd *pw;
d6012 1
d6015 1
a6015 1
		dprintf("user_map_lookup(%s, %s)\n",
d6018 2
a6019 2
	pw = finduser(key, &fuzzy);
	if (pw == NULL)
d6032 1
a6032 1
			rwval = pw->pw_name;
d6036 1
a6036 1
			rwval = pw->pw_passwd;
d6040 2
a6041 1
			snprintf(buf, sizeof buf, "%d", (int) pw->pw_uid);
d6046 2
a6047 1
			snprintf(buf, sizeof buf, "%d", (int) pw->pw_gid);
d6052 1
a6052 1
			rwval = pw->pw_gecos;
d6056 1
a6056 1
			rwval = pw->pw_dir;
d6060 1
a6060 1
			rwval = pw->pw_shell;
d6092 1
a6092 1
		dprintf("prog_map_lookup(%s, %s) %s\n",
d6099 1
a6099 1
		snprintf(buf, sizeof buf, "%s", map->map_rebuild);
d6111 1
a6111 1
		dprintf("prog_open:");
d6113 2
a6114 2
			dprintf(" %s", argv[i]);
		dprintf("\n");
d6116 1
a6116 1
	(void) blocksignal(SIGCHLD);
d6122 1
a6122 1
				map->map_mname, errstring(errno));
d6124 2
a6125 2
			dprintf("prog_map_lookup(%s) failed (%s) -- closing",
				map->map_mname, errstring(errno));
d6134 1
a6134 1
			map->map_mname, errstring(errno));
d6140 2
a6141 2
			dprintf("prog_map_lookup(%s): empty answer\n",
				map->map_mname);
d6166 1
a6166 1
	(void) releasesignal(SIGCHLD);
d6172 1
a6172 1
			map->map_mname, errstring(errno));
d6184 1
a6184 1
			map->map_mname, status);
d6204 1
a6204 1
**	opened during startup, including underlying maps.
d6219 1
a6219 1
		dprintf("seq_map_parse(%s, %s)\n", map->map_mname, ap);
d6248 1
a6248 1
		else if (maxmap == MAXMAPSTACK)
d6260 1
a6260 1
	return TRUE;
a6262 1

d6284 1
a6284 1
		dprintf("switch_map_open(%s, %s, %d)\n",
d6291 1
a6291 1
		dprintf("\tswitch_map_find => %d\n", nmaps);
d6293 1
a6293 1
			dprintf("\t\t%s\n", maptype[mapno]);
d6296 1
a6296 1
		return FALSE;
d6305 2
a6306 2
		(void) snprintf(nbuf, sizeof nbuf, "%s.%s",
			map->map_mname, maptype[mapno]);
d6317 4
a6320 3
				dprintf("\tmap_stack[%d] = %s:%s\n",
					mapno, s->s_map.map_class->map_cname,
					nbuf);
d6323 1
a6323 1
	return TRUE;
d6326 1
a6326 1

d6338 1
a6338 1
		dprintf("seq_map_close(%s)\n", map->map_mname);
d6351 1
a6351 1

d6366 1
a6366 1
	bool tempfail = FALSE;
d6369 1
a6369 1
		dprintf("seq_map_lookup(%s, %s)\n", map->map_mname, key);
d6396 1
a6396 1
			tempfail = TRUE;
a6407 1

d6421 1
a6421 1
		dprintf("seq_map_store(%s, %s, %s)\n",
d6447 1
a6447 1
	return TRUE;
a6478 1

d6496 3
a6498 3
	"bogus-map",		NULL,		0,
	NULL,		bogus_map_lookup,	null_map_store,
	null_map_open,	null_map_close,
d6514 1
a6514 1
		dprintf("macro_map_lookup(%s, %s)\n", map->map_mname,
d6519 1
a6519 1
	    (mid = macid(name, NULL)) == '\0')
d6526 1
a6526 1
		define(mid, NULL, CurEnv);
d6528 1
a6528 1
		define(mid, newstr(av[1]), CurEnv);
d6537 1
a6537 1
#ifdef MAP_REGEX
a6541 1

a6542 1

d6564 1
a6564 1
	bool lastone = FALSE;
d6579 1
a6579 1
				lastone = TRUE;
d6616 1
a6616 1
	static char defdstr[] = { (char)DEFAULT_DELIM, '\0' };
d6619 1
a6619 1
		dprintf("regex_map_init: mapname '%s', args '%s'\n",
a6622 1

a6623 1

d6680 1
a6680 1
		dprintf("regex_map_init: compile '%s' 0x%x\n", p, pflags);
d6688 5
a6692 5
			 errbuf, ERRBUF_SIZE);
		syserr("pattern-compile-error: %s\n", errbuf);
		sm_free(map_p->regex_pattern_buf);
		sm_free(map_p);
		return FALSE;
d6711 1
a6711 1
			dprintf("regex_map_init: nr of substrings %d\n",
d6716 4
a6719 4
			syserr("too many substrings, %d max\n", MAX_MATCH);
			sm_free(map_p->regex_pattern_buf);
			sm_free(map_p);
			return FALSE;
d6726 1
a6726 1
				return FALSE;
a6729 1
			/* set default fields */
d6732 1
d6742 1
a6742 1
			dprintf("regex_map_init: subfields");
d6744 2
a6745 2
				dprintf(" %d", *ip);
			dprintf("\n");
d6748 2
a6749 3
	map->map_db1 = (ARBPTR_T)map_p;	/* dirty hack */

	return TRUE;
d6780 1
a6780 1
		dprintf("regex_map_lookup: key '%s'\n", name);
d6782 1
a6782 1
			dprintf("regex_map_lookup: arg '%s'\n", *cpp);
d6793 1
a6793 1
			return regex_map_rewrite(map, "", (size_t)0, av);
d6805 1
a6805 1
		bool first = TRUE;
d6807 1
a6807 1
		bool quotemode = FALSE, bslashmode = FALSE;
d6839 1
a6839 2
				first = FALSE;

d6854 1
a6854 1
						bslashmode = FALSE;
d6861 1
a6861 1
					else switch(*dp++ = *sp)
d6863 2
a6864 2
						case '\\':
						bslashmode = TRUE;
d6867 1
a6867 1
						case '(':
d6871 1
a6871 1
						case ')':
d6875 1
a6875 1
						case '<':
d6879 1
a6879 1
						case '>':
d6883 1
a6883 1
						case ' ':
d6887 1
a6887 1
						case '"':
d6913 1
a6913 1
#ifdef MAP_NSD
d6921 3
a6923 3
	ns_map_t *map;
	char *mapname;
	struct ns_map_list *next;
d6966 1
a6966 1
		dprintf("nsd_map_lookup(%s, %s)\n", map->map_mname, name);
d6970 1
a6970 1
		buflen = sizeof keybuf - 1;
d6980 1
a6980 1
			dprintf("nsd_map_t_find failed\n");
d7024 1
a7024 1
	bool res = FALSE;
d7031 1
a7031 1
		dprintf("arith_map_lookup: key '%s'\n", name);
d7033 1
a7033 1
			dprintf("arith_map_lookup: arg '%s'\n", *cpp);
d7036 1
a7036 1
	boolres = FALSE;
d7045 1
d7052 1
a7052 1
		switch(*name)
a7053 1
#if _FFR_ARITH
a7066 2
#endif /* _FFR_ARITH */

d7087 1
a7087 1
			boolres = TRUE;
d7092 1
a7092 1
			boolres = TRUE;
d7105 2
a7106 1
			snprintf(result, sizeof result, res ? "TRUE" : "FALSE");
d7108 1
a7108 1
			snprintf(result, sizeof result, "%ld", r);
@


1.6
log
@update to sendmail 8.11.5
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: map.c,v 8.414.4.54 2001/06/01 08:23:24 gshapiro Exp $";
d5362 2
a5363 1
		hesiod_free_list(HesiodContext, hp);
@


1.5
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: map.c,v 8.414.4.53 2001/05/04 01:29:00 gshapiro Exp $";
a128 3
#ifndef O_ACCMODE
# define O_ACCMODE	(O_RDONLY|O_WRONLY|O_RDWR)
#endif /* ! O_ACCMODE */
@


1.4
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: map.c,v 8.414.4.39 2001/02/22 18:56:22 gshapiro Exp $";
d373 1
a373 1
			free(buf);
d495 1
d497 1
a497 1
		map->map_mflags &= ~(MF_OPEN|MF_WRITABLE);
d631 1
d640 1
d642 1
a642 1
	map->map_mflags &= ~(MF_OPEN|MF_WRITABLE);
d1085 1
a1085 1
	if (fstat(dfd, &st) >= 0)
d1136 1
a1136 1
	int fd;
d1156 6
a1161 4
	fd = dbm_dirfno((DBM *) map->map_db1);
	if (fd >= 0 && !bitset(MF_LOCKED, map->map_mflags))
		(void) lockfile(fd, map->map_file, ".dir", LOCK_SH);
	if (fd < 0 || fstat(fd, &stbuf) < 0 || stbuf.st_mtime > map->map_mtime)
d1167 3
a1169 2
		if (fd >= 0 && !bitset(MF_LOCKED, map->map_mflags))
			(void) lockfile(fd, map->map_file, ".dir", LOCK_UN);
d1171 1
a1171 1
		map->map_mflags &= ~(MF_OPEN|MF_WRITABLE);
d1210 2
a1211 2
	if (fd >= 0 && !bitset(MF_LOCKED, map->map_mflags))
		(void) lockfile(fd, map->map_file, ".dir", LOCK_UN);
d1281 1
a1281 1
						(void) free(buf);
d1812 1
d1814 1
a1814 1
		map->map_mflags &= ~(MF_OPEN|MF_WRITABLE);
d1993 1
a1993 1
						(void) free(buf);
d2151 1
a2151 1
		free(vp);
d2221 1
a2221 1
			free(vp);
d2235 1
a2235 1
			free(vp);
d2246 1
a2246 1
			free(vp);
d2300 1
a2300 1
			free(vp);
d2318 1
a2318 1
			free(vp);
d2322 1
a2322 1
	free(vp);
d2860 1
a2860 1
	if (s->s_ldap != NULL)
d2863 6
a2868 1
		lmap->ldap_ld = s->s_ldap;
d2882 1
a2882 1
	s->s_ldap = lmap->ldap_ld;
d3051 7
d3081 4
d3087 3
a3089 3
	/* Check if already closed */
	if (s->s_ldap == NULL)
		return;
d3091 3
a3093 3
	/* If same as saved connection, stored connection is going away */
	if (s->s_ldap == lmap->ldap_ld)
		s->s_ldap = NULL;
d3095 2
a3096 3
	if (lmap->ldap_ld != NULL)
	{
		ldap_unbind(lmap->ldap_ld);
d3098 2
d3241 2
d3244 1
d3256 2
a3257 1
		if (errno == LDAP_SERVER_DOWN)
a3258 2
			int save_errno = errno;

d3260 1
a3260 3
			map->map_class->map_close(map);
			map->map_mflags &= ~(MF_OPEN|MF_WRITABLE);
			errno = save_errno;
d3263 1
d3293 1
a3293 1
					free(vp);
d3376 1
a3376 1
							free(vp);
d3447 1
a3447 1
						free(vp);
d3493 2
a3494 2
				free(vp);
				free(vp_tmp);
d3530 1
a3530 1
					free(vp);
d3560 1
a3560 1
				free(vp);
d3585 1
a3585 1
				free(vp);
d3597 2
d3602 2
d3615 10
a3624 1
			free(vp);
d3642 1
a3642 1
			free(vp);
d3660 1
a3660 1
			free(vp);
d3705 3
a3707 3
		 getpid());
	s = stab(nbuf, ST_LDAP, ST_ENTER);
	free(nbuf);
d4350 1
d4399 1
a4399 1
			free(map.map_app);
d4404 1
a4404 1
			free(map.map_tapp);
d4636 2
a4637 2
ph_timeout_func(sig_no)
	int sig_no;
d4639 7
d4744 1
a4744 1
			ev = setevent(pmap->ph_timeout, ph_timeout_func, 0);
d4763 1
a4763 1
			    fflush(pmap->ph_to_server) < 0 ||
d4776 1
a4776 1
			free(hostlist);
d4808 1
a4808 1
	free(hostlist);
d4863 1
a4863 1
		ev = setevent(pmap->ph_timeout, ph_timeout_func, 0);
d4932 1
a4932 1
		else if (fflush(pmap->ph_to_server) < 0)
d5320 1
d5335 1
d5337 2
a5338 1
			free(np);
d5349 1
a5349 3
	if (hp == NULL)
		return NULL;
	if (*hp == NULL)
a5350 1
		hesiod_free_list(HesiodContext, hp);
d5365 1
d5463 1
a5463 1
	free(propval);
d5511 1
a5511 1
		free(vptr);
d5516 1
a5516 1
	free(vptr);
d6402 1
a6402 1
			rval = map_rewrite(map, buf, strlen(buf), NULL);
d6593 1
d6595 1
a6595 1
		mm->map_mflags &= ~(MF_OPEN|MF_WRITABLE);
d6943 2
a6944 2
		free(map_p->regex_pattern_buf);
		free(map_p);
d6970 2
a6971 2
			free(map_p->regex_pattern_buf);
			free(map_p);
d7016 1
a7016 1
		return map_rewrite(map, s, slen, NULL);
d7245 5
a7249 1
	if (r == NS_BADREQ || r == NS_NOPERM)
@


1.4.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: map.c,v 8.414.4.53 2001/05/04 01:29:00 gshapiro Exp $";
d373 1
a373 1
			sm_free(buf);
a494 1
		map->map_mflags |= MF_CLOSING;
d496 1
a496 1
		map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
a629 1
	    bitset(MF_CLOSING, map->map_mflags) ||
a637 1
	map->map_mflags |= MF_CLOSING;
d639 1
a639 1
	map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
d1082 1
a1082 1
	if (fstat(pfd, &st) >= 0)
d1133 1
a1133 1
	int dfd, pfd;
d1153 4
a1156 6
	dfd = dbm_dirfno((DBM *) map->map_db1);
	if (dfd >= 0 && !bitset(MF_LOCKED, map->map_mflags))
		(void) lockfile(dfd, map->map_file, ".dir", LOCK_SH);
	pfd = dbm_pagfno((DBM *) map->map_db1);
	if (pfd < 0 || fstat(pfd, &stbuf) < 0 ||
	    stbuf.st_mtime > map->map_mtime)
d1162 2
a1163 3
		if (dfd >= 0 && !bitset(MF_LOCKED, map->map_mflags))
			(void) lockfile(dfd, map->map_file, ".dir", LOCK_UN);
		map->map_mflags |= MF_CLOSING;
d1165 1
a1165 1
		map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
d1204 2
a1205 2
	if (dfd >= 0 && !bitset(MF_LOCKED, map->map_mflags))
		(void) lockfile(dfd, map->map_file, ".dir", LOCK_UN);
d1275 1
a1275 1
						sm_free(buf);
a1805 1
		map->map_mflags |= MF_CLOSING;
d1807 1
a1807 1
		map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
d1986 1
a1986 1
						sm_free(buf);
d2144 1
a2144 1
		sm_free(vp);
d2214 1
a2214 1
			sm_free(vp);
d2228 1
a2228 1
			sm_free(vp);
d2239 1
a2239 1
			sm_free(vp);
d2293 1
a2293 1
			sm_free(vp);
d2311 1
a2311 1
			sm_free(vp);
d2315 1
a2315 1
	sm_free(vp);
d2853 1
a2853 1
	if (s->s_lmap != NULL)
d2856 1
a2856 6
		lmap->ldap_ld = ((LDAPMAP_STRUCT *)s->s_lmap->map_db1)->ldap_ld;

		/* Add this map as head of linked list */
		lmap->ldap_next = s->s_lmap;
		s->s_lmap = map;

d2870 1
a2870 1
	s->s_lmap = map;
a3038 7
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
a3061 4
	/* Close the LDAP connection */
	ldap_unbind(lmap->ldap_ld);

	/* Mark all the maps that share the connection as closed */
d3064 3
a3066 3
	while (s->s_lmap != NULL)
	{
		MAP *smap = s->s_lmap;
d3068 3
a3070 3
		if (tTd(38, 2) && smap != map)
			dprintf("ldapmap_close(%s): closed %s (shared LDAP connection)\n",
				map->map_mname, smap->map_mname);
d3072 3
a3074 2
		smap->map_mflags &= ~(MF_OPEN|MF_WRITABLE);
		lmap = (LDAPMAP_STRUCT *) smap->map_db1;
a3075 2
		s->s_lmap = lmap->ldap_next;
		lmap->ldap_next = NULL;
a3216 2
		int save_errno;

a3217 1
		save_errno = errno;
d3229 1
a3229 2
		errno = save_errno;
		if (errno == LDAP_SERVER_DOWN + E_LDAPBASE)
d3231 2
d3234 3
a3236 1
			ldapmap_close(map);
a3238 1
		errno = save_errno;
d3268 1
a3268 1
					sm_free(vp);
d3351 1
a3351 1
							sm_free(vp);
d3422 1
a3422 1
						sm_free(vp);
d3468 2
a3469 2
				sm_free(vp);
				sm_free(vp_tmp);
d3505 1
a3505 1
					sm_free(vp);
d3535 1
a3535 1
				sm_free(vp);
d3560 1
a3560 1
				sm_free(vp);
a3571 2
		int save_errno;

a3574 2
		save_errno = errno;

d3586 1
a3586 10
			sm_free(vp);
#ifdef LDAP_SERVER_DOWN
		errno = save_errno;
		if (errno == LDAP_SERVER_DOWN + E_LDAPBASE)
		{
			/* server disappeared, try reopen on next search */
			ldapmap_close(map);
		}
#endif /* LDAP_SERVER_DOWN */
		errno = save_errno;
d3604 1
a3604 1
			sm_free(vp);
d3622 1
a3622 1
			sm_free(vp);
d3667 3
a3669 3
		 (int) getpid());
	s = stab(nbuf, ST_LMAP, ST_ENTER);
	sm_free(nbuf);
a4311 1
	lmap->ldap_next = NULL;
d4360 1
a4360 1
			sm_free(map.map_app);
d4365 1
a4365 1
			sm_free(map.map_tapp);
d4597 2
a4598 2
ph_timeout(sig)
	int sig;
a4599 7
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
d4698 1
a4698 1
			ev = setevent(pmap->ph_timeout, ph_timeout, 0);
d4717 1
a4717 1
			    fflush(pmap->ph_to_server) != 0 ||
d4730 1
a4730 1
			sm_free(hostlist);
d4762 1
a4762 1
	sm_free(hostlist);
d4817 1
a4817 1
		ev = setevent(pmap->ph_timeout, ph_timeout, 0);
d4886 1
a4886 1
		else if (fflush(pmap->ph_to_server) != 0)
a5273 1
		int save_errno;
a5287 1
		save_errno = errno;
d5289 1
a5289 2
			sm_free(np);
		errno = save_errno;
d5300 3
a5302 1
	if (hp == NULL || *hp == NULL)
d5304 1
a5318 1
		hesiod_free_list(HesiodContext, hp);
d5416 1
a5416 1
	sm_free(propval);
d5464 1
a5464 1
		sm_free(vptr);
d5469 1
a5469 1
	sm_free(vptr);
d6355 1
a6355 1
			rval = map_rewrite(map, buf, strlen(buf), av);
a6545 1
		mm->map_mflags |= MF_CLOSING;
d6547 1
a6547 1
		mm->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
d6895 2
a6896 2
		sm_free(map_p->regex_pattern_buf);
		sm_free(map_p);
d6922 2
a6923 2
			sm_free(map_p->regex_pattern_buf);
			sm_free(map_p);
d6968 1
a6968 1
		return map_rewrite(map, s, slen, av);
d7197 1
a7197 5
	if (r == NS_BADREQ
# ifdef NS_NOPERM
	    || r == NS_NOPERM
# endif /* NS_NOPERM */
	    )
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: map.c,v 8.414.4.34 2000/12/18 18:00:43 ca Exp $";
d55 1
a55 1
static bool	extract_canonname __P((char *, char *, char[], int));
d770 1
a770 1
		h_errno = TRY_AGAIN;
d772 1
a772 1
		h_errno = HOST_NOT_FOUND;
a773 1

d781 1
d792 1
a792 1
extract_canonname(name, line, cbuf, cbuflen)
d794 1
d823 8
d1635 4
d2274 1
a2274 1
	shorten_hostname(nbuf);
d2318 1
a2318 1
	if (!extract_canonname(nbuf, host_record, cbuf, sizeof cbuf))
d2324 1
a2324 1
	if (hbsize < strlen(cbuf))
d2655 1
a2655 1
	shorten_hostname(nbuf);
d3953 1
a3953 1
					syserr("Deref must be [never|always|search|find] not %s in map %s",
d3988 1
a3988 1
					syserr("Scope must be [base|one|sub] not %s in map %s",
d4060 1
a4060 1
					syserr("Method for binding must be [none|simple|krbv4] not %s in map %s",
d4328 1
d4337 9
d4347 1
d5439 1
a5439 1
	shorten_hostname(nbuf);
d5859 1
d5874 1
a5874 1
	shorten_hostname(nbuf);
d5890 2
a5891 1
			found = extract_canonname(nbuf, linebuf, cbuf, sizeof cbuf);
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: map.c,v 8.414 2000/03/15 06:13:16 gshapiro Exp $";
d20 1
d244 1
d393 2
a394 2
			        if (--len <= 0)
				     break;
d571 1
d829 1
a829 1
		    strlen(domain) + (i = strlen(cbuf)) + 1 < cbuflen)
d1093 1
a1093 1
# if HASFCHOWN
d1105 1
a1105 1
# endif /* HASFCHOWN */
d1700 1
a1700 1
# if HASFCHOWN
d1711 1
a1711 1
# endif /* HASFCHOWN */
d1970 1
a1970 1
				if (data.size + old.size + 2 > bufsiz)
d2443 1
a2443 1
		if (!strcmp(map->map_keycolnm, COL_NAME(res,i)))
d2813 1
a2813 1
		dprintf("ldapmap_open(%s, %d)\n", map->map_mname, mode);
d2844 2
d2849 3
d2898 1
d2981 1
d2993 1
d3040 3
d3150 1
a3150 1
				 q - p, p, keybuf);
d3159 1
a3159 1
				 q - p, p);
d3187 1
a3187 1
				 q - p + 1, p);
d3208 1
a3208 1
				syserr("Error in ldap_search_st using %s in map %s",
d3211 1
a3211 1
				syserr("421 4.0.0 Error in ldap_search_st using %s in map %s",
d3215 11
d3262 4
d3273 1
a3273 1
			char **vals;
d3284 10
d3302 1
a3302 3
				vals = ldap_get_values(lmap->ldap_ld, entry,
						       attr);
				if (vals == NULL)
d3304 4
a3307 8
					errno = ldapmap_geterrno(lmap->ldap_ld);
					if (errno == LDAP_SUCCESS)
						continue;

					/* Must be an error */
					errno += E_LDAPBASE;
					if (!bitset(MF_OPTIONAL,
						    map->map_mflags))
d3309 18
a3326 9
						if (bitset(MF_NODEFER,
							   map->map_mflags))
							syserr("Error getting LDAP values in map %s",
							       map->map_mname);
						else
							syserr("421 4.0.0 Error getting LDAP values in map %s",
							       map->map_mname);
					}
					*statp = EX_TEMPFAIL;
d3328 1
a3328 1
					ldap_mem_free(attr);
d3330 10
a3339 4
					if (lmap->ldap_res != NULL)
					{
						ldap_msgfree(lmap->ldap_res);
						lmap->ldap_res = NULL;
a3340 5
					(void) ldap_abandon(lmap->ldap_ld,
							    msgid);
					if (vp != NULL)
						free(vp);
					return NULL;
d3345 10
d3370 9
d3383 1
a3383 1
						ldap_mem_free(attr);
d3391 1
a3391 1
					ldap_mem_free(attr);
d3396 22
d3443 1
a3443 1
				ldap_mem_free(attr);
d3501 1
a3501 1
		if (errno != LDAP_SUCCESS)
a3526 4

		/* If we don't want multiple values and we have one, break */
		if (map->map_coldelim == '\0' && vp != NULL)
			break;
d3578 1
a3578 1
	if (vp == NULL)
d3590 2
a3591 2
		/* vp != NULL due to test above */
		free(vp);
a3596 1
		/* vp != NULL due to test above */
d3599 2
a3600 1
				  "ldap %.100s => %s", name, vp);
d3604 2
d3607 3
a3609 1
		free(vp);
d3618 4
a3621 2
**	and secret so we don't have multiple connections open to
**	the same server for different maps.
d3644 1
a3644 1
		1;
d3646 1
a3646 1
	snprintf(nbuf, len, "%s%c%d%c%s%c%s",
d3653 2
a3654 1
		 (lmap->ldap_secret == NULL ? "" : lmap->ldap_secret));
d3751 1
d3753 1
d4153 2
a4154 1
						   sfd, 0, "ldapmap_parseargs");
d4167 1
d4180 1
d4246 1
a4246 1
			if (i == LDAPMAP_MAX_ATTR)
d4634 17
d4655 2
a4656 1
	do {
d4670 1
a4670 1
				errno = 0;
d4727 1
a4727 1
	if (!bitset(MF_OPTIONAL, map->map_mflags))
d4729 1
a4729 1
		if (errno == 0 && !bitset(MF_NODEFER,map->map_mflags))
d4731 2
a4732 1
		syserr("ph_map_open: cannot connect to PH server");
d4734 1
a4734 1
	else if (LogLevel > 1)
d4736 2
a4737 1
			  "ph_map_open: cannot connect to PH server");
d4799 2
a4800 1
	do {
d6727 1
a6727 1
	regex_t	regex_pattern_buf;	/* xalloc it */
d6804 1
d6861 1
a6861 1
	if ((regerr = regcomp(&(map_p->regex_pattern_buf), p, pflags)) != 0)
d6866 1
a6866 1
		(void) regerror(regerr, &(map_p->regex_pattern_buf),
d6869 1
d6887 1
a6887 1
		substrings = map_p->regex_pattern_buf.re_nsub + 1;
d6896 1
d6966 1
a6966 1
	reg_res = regexec(&(map_p->regex_pattern_buf),
d6998 1
a6998 1
					 (int) map_p->regex_pattern_buf.re_nsub + 1) == -1)
d7022 2
a7023 1
			if (pmatch[*ip].rm_so < 0 || pmatch[*ip].rm_eo < 0)
d7140 1
a7140 1
	int buflen;
d7162 17
d7182 1
a7182 3
	if (ns_lookup(ns_map, NULL, map->map_file,
		      keybuf, NULL, buf, MAXLINE) == NULL)
		return NULL;
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: map.c,v 8.414.4.53 2001/05/04 01:29:00 gshapiro Exp $";
a19 1

d54 1
a54 1
static bool	extract_canonname __P((char *, char *, char *, char[], int));
a242 1

d371 1
a371 1
			sm_free(buf);
d391 2
a392 2
				if (--len <= 0)
					break;
a492 1
		map->map_mflags |= MF_CLOSING;
d494 1
a494 1
		map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
a568 1
			MapOpenErr = TRUE;
a626 1
	    bitset(MF_CLOSING, map->map_mflags) ||
a634 1
	map->map_mflags |= MF_CLOSING;
d636 1
a636 1
	map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
d767 1
a767 1
		SM_SET_H_ERRNO(TRY_AGAIN);
d769 1
a769 1
		SM_SET_H_ERRNO(HOST_NOT_FOUND);
d771 1
a778 1
**		dot -- where to reinsert '.' to get FQDN
d789 1
a789 1
extract_canonname(name, dot, line, cbuf, cbuflen)
a790 1
	char *dot;
a818 8
		else if (dot != NULL)
		{
			/* try looking for the FQDN as well */
			*dot = '.';
			if (strcasecmp(name, p) == 0)
				found = TRUE;
			*dot = '\0';
		}
d826 1
a826 1
		    strlen(domain) + (i = strlen(cbuf)) + 1 < (size_t) cbuflen)
d1070 1
a1070 1
	if (fstat(pfd, &st) >= 0)
d1090 1
a1090 1
#  if HASFCHOWN
d1102 1
a1102 1
#  endif /* HASFCHOWN */
d1121 1
a1121 1
	int dfd, pfd;
d1141 4
a1144 6
	dfd = dbm_dirfno((DBM *) map->map_db1);
	if (dfd >= 0 && !bitset(MF_LOCKED, map->map_mflags))
		(void) lockfile(dfd, map->map_file, ".dir", LOCK_SH);
	pfd = dbm_pagfno((DBM *) map->map_db1);
	if (pfd < 0 || fstat(pfd, &stbuf) < 0 ||
	    stbuf.st_mtime > map->map_mtime)
d1150 2
a1151 3
		if (dfd >= 0 && !bitset(MF_LOCKED, map->map_mflags))
			(void) lockfile(dfd, map->map_file, ".dir", LOCK_UN);
		map->map_mflags |= MF_CLOSING;
d1153 1
a1153 1
		map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
d1192 2
a1193 2
	if (dfd >= 0 && !bitset(MF_LOCKED, map->map_mflags))
		(void) lockfile(dfd, map->map_file, ".dir", LOCK_UN);
d1263 1
a1263 1
						sm_free(buf);
a1622 4
#ifdef DB_OLD_VERSION
				if (ret == DB_OLD_VERSION)
					ret = EINVAL;
#endif /* DB_OLD_VERSION */
d1697 1
a1697 1
#  if HASFCHOWN
d1708 1
a1708 1
#  endif /* HASFCHOWN */
a1789 1
		map->map_mflags |= MF_CLOSING;
d1791 1
a1791 1
		map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
d1967 1
a1967 1
				if (data.size + old.size + 2 > (size_t)bufsiz)
d1970 1
a1970 1
						sm_free(buf);
d2128 1
a2128 1
		sm_free(vp);
d2198 1
a2198 1
			sm_free(vp);
d2212 1
a2212 1
			sm_free(vp);
d2223 1
a2223 1
			sm_free(vp);
d2258 1
a2258 1
	(void) shorten_hostname(nbuf);
d2277 1
a2277 1
			sm_free(vp);
d2295 1
a2295 1
			sm_free(vp);
d2299 1
a2299 1
	sm_free(vp);
d2302 1
a2302 1
	if (!extract_canonname(nbuf, NULL, host_record, cbuf, sizeof cbuf))
d2308 1
a2308 1
	if (hbsize <= strlen(cbuf))
d2440 1
a2440 1
		if (strcmp(map->map_keycolnm, COL_NAME(res,i)) == 0)
d2639 1
a2639 1
	(void) shorten_hostname(nbuf);
d2810 1
a2810 1
		dprintf("ldapmap_open(%s, %d): ", map->map_mname, mode);
d2837 1
a2837 1
	if (s->s_lmap != NULL)
d2840 1
a2840 8
		lmap->ldap_ld = ((LDAPMAP_STRUCT *)s->s_lmap->map_db1)->ldap_ld;

		/* Add this map as head of linked list */
		lmap->ldap_next = s->s_lmap;
		s->s_lmap = map;

		if (tTd(38, 2))
			dprintf("using cached connection\n");
a2843 3
	if (tTd(38, 2))
		dprintf("opening new connection\n");

d2849 1
a2849 1
	s->s_lmap = map;
a2889 1
	save_errno = errno;
a2971 1
# ifdef LDAP_AUTH_KRBV4
a2982 1
# endif /* LDAP_AUTH_KRBV4 */
a3014 7
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
a3028 3
	if (tTd(38, 2))
		dprintf("ldapmap_close(%s)\n", map->map_mname);

a3034 4
	/* Close the LDAP connection */
	ldap_unbind(lmap->ldap_ld);

	/* Mark all the maps that share the connection as closed */
d3037 3
a3039 3
	while (s->s_lmap != NULL)
	{
		MAP *smap = s->s_lmap;
d3041 3
a3043 3
		if (tTd(38, 2) && smap != map)
			dprintf("ldapmap_close(%s): closed %s (shared LDAP connection)\n",
				map->map_mname, smap->map_mname);
d3045 3
a3047 2
		smap->map_mflags &= ~(MF_OPEN|MF_WRITABLE);
		lmap = (LDAPMAP_STRUCT *) smap->map_db1;
a3048 2
		s->s_lmap = lmap->ldap_next;
		lmap->ldap_next = NULL;
d3136 1
a3136 1
				 (int) (q - p), p, keybuf);
d3145 1
a3145 1
				 (int) (q - p), p);
d3173 1
a3173 1
				 (int) (q - p + 1), p);
a3189 2
		int save_errno;

a3190 1
		save_errno = errno;
d3194 1
a3194 1
				syserr("Error in ldap_search using %s in map %s",
d3197 1
a3197 1
				syserr("421 4.0.0 Error in ldap_search using %s in map %s",
a3200 9
#ifdef LDAP_SERVER_DOWN
		errno = save_errno;
		if (errno == LDAP_SERVER_DOWN + E_LDAPBASE)
		{
			/* server disappeared, try reopen on next search */
			ldapmap_close(map);
		}
#endif /* LDAP_SERVER_DOWN */
		errno = save_errno;
d3230 1
a3230 1
					sm_free(vp);
a3236 4
		/* If we don't want multiple values and we have one, break */
		if (map->map_coldelim == '\0' && vp != NULL)
			break;

d3244 1
a3244 1
			char **vals = NULL;
a3254 10
# if !defined(LDAP_VERSION_MAX) && !defined(LDAP_OPT_SIZELIMIT)
			/*
			**  Reset value to prevent lingering
			**  LDAP_DECODING_ERROR due to
			**  OpenLDAP 1.X's hack (see below)
			*/

			lmap->ldap_ld->ld_errno = LDAP_SUCCESS;
# endif /* !defined(LDAP_VERSION_MAX) !defined(LDAP_OPT_SIZELIMIT) */

d3263 3
a3265 1
				if (lmap->ldap_attrsonly == LDAPMAP_FALSE)
d3267 8
a3274 4
					vals = ldap_get_values(lmap->ldap_ld,
							       entry,
							       attr);
					if (vals == NULL)
d3276 9
a3284 18
						errno = ldapmap_geterrno(lmap->ldap_ld);
						if (errno == LDAP_SUCCESS)
							continue;

						/* Must be an error */
						errno += E_LDAPBASE;
						if (!bitset(MF_OPTIONAL,
							    map->map_mflags))
						{
							if (bitset(MF_NODEFER,
								   map->map_mflags))
								syserr("Error getting LDAP values in map %s",
								       map->map_mname);
							else
								syserr("421 4.0.0 Error getting LDAP values in map %s",
								       map->map_mname);
						}
						*statp = EX_TEMPFAIL;
d3286 1
a3286 1
						ldap_memfree(attr);
d3288 4
a3291 10
						if (lmap->ldap_res != NULL)
						{
							ldap_msgfree(lmap->ldap_res);
							lmap->ldap_res = NULL;
						}
						(void) ldap_abandon(lmap->ldap_ld,
								    msgid);
						if (vp != NULL)
							sm_free(vp);
						return NULL;
d3293 5
a3301 10
# if !defined(LDAP_VERSION_MAX) && !defined(LDAP_OPT_SIZELIMIT)
				/*
				**  Reset value to prevent lingering
				**  LDAP_DECODING_ERROR due to
				**  OpenLDAP 1.X's hack (see below)
				*/

				lmap->ldap_ld->ld_errno = LDAP_SUCCESS;
# endif /* !defined(LDAP_VERSION_MAX) !defined(LDAP_OPT_SIZELIMIT) */

a3316 9
					if (lmap->ldap_attrsonly == LDAPMAP_TRUE)
					{
						vp = newstr(attr);
# if USING_NETSCAPE_LDAP
						ldap_memfree(attr);
# endif /* USING_NETSCAPE_LDAP */
						break;
					}

d3321 1
a3321 1
						ldap_memfree(attr);
d3329 1
a3329 1
					ldap_memfree(attr);
a3333 22
				/* attributes only */
				if (lmap->ldap_attrsonly == LDAPMAP_TRUE)
				{
					if (vp == NULL)
						vp = newstr(attr);
					else
					{
						vsize = strlen(vp) +
							strlen(attr) + 2;
						tmp = xalloc(vsize);
						snprintf(tmp, vsize, "%s%c%s",
							 vp, map->map_coldelim,
							 attr);
						sm_free(vp);
						vp = tmp;
					}
# if USING_NETSCAPE_LDAP
					ldap_memfree(attr);
# endif /* USING_NETSCAPE_LDAP */
					continue;
				}

d3359 1
a3359 1
				ldap_memfree(attr);
d3371 2
a3372 2
				sm_free(vp);
				sm_free(vp_tmp);
d3408 1
a3408 1
					sm_free(vp);
d3417 1
a3417 1
		if (errno != LDAP_SUCCESS && errno != LDAP_DECODING_ERROR)
d3438 1
a3438 1
				sm_free(vp);
d3443 4
d3467 1
a3467 1
				sm_free(vp);
a3478 2
		int save_errno;

a3481 2
		save_errno = errno;

d3493 1
a3493 10
			sm_free(vp);
#ifdef LDAP_SERVER_DOWN
		errno = save_errno;
		if (errno == LDAP_SERVER_DOWN + E_LDAPBASE)
		{
			/* server disappeared, try reopen on next search */
			ldapmap_close(map);
		}
#endif /* LDAP_SERVER_DOWN */
		errno = save_errno;
d3498 1
a3498 1
	if (vp == NULL && !bitset(MF_MATCHONLY, map->map_mflags))
d3510 2
a3511 2
		if (vp != NULL)
			sm_free(vp);
d3517 1
d3520 1
a3520 2
				  "ldap %.100s => %s", name,
				  vp == NULL ? "<NULL>" : vp);
a3523 2
		{
			/* vp != NULL according to test above */
d3525 1
a3525 3
		}
		if (vp != NULL)
			sm_free(vp);
d3534 2
a3535 4
**	secret, and PID so we don't have multiple connections open to
**	the same server for different maps.  Need a separate connection
**	per PID since a parent process may close the map before the
**	child is done with it.
d3558 1
a3558 1
		8 + 1;
d3560 1
a3560 1
	snprintf(nbuf, len, "%s%c%d%c%s%c%s%d",
d3567 3
a3569 4
		 (lmap->ldap_secret == NULL ? "" : lmap->ldap_secret),
		 (int) getpid());
	s = stab(nbuf, ST_LMAP, ST_ENTER);
	sm_free(nbuf);
a3663 1
# ifdef LDAP_AUTH_KRBV4
a3664 1
# endif /* LDAP_AUTH_KRBV4 */
d3851 1
a3851 1
					syserr("Deref must be [never|always|search|find] (not %s) in map %s",
d3886 1
a3886 1
					syserr("Scope must be [base|one|sub] (not %s) in map %s",
d3958 1
a3958 1
					syserr("Method for binding must be [none|simple|krbv4] (not %s) in map %s",
d4064 1
a4064 2
						   sfd, TimeOuts.to_fileopen,
						   "ldapmap_parseargs");
a4076 1
# ifdef LDAP_AUTH_KRBV4
a4088 1
# endif /* LDAP_AUTH_KRBV4 */
d4154 1
a4154 1
			if (i >= LDAPMAP_MAX_ATTR)
a4206 1
	lmap->ldap_next = NULL;
a4222 1
	STAB *class;
a4230 9

	/* look up the class */
	class = stab("ldap", ST_MAPCLASS, ST_FIND);
	if (class == NULL)
	{
		syserr("readcf: LDAPDefaultSpec: class ldap not available");
		return;
	}
	map.map_class = &class->s_mapclass;
a4231 1
	map.map_mname = "O LDAPDefaultSpec";
d4244 1
a4244 1
			sm_free(map.map_app);
d4249 1
a4249 1
			sm_free(map.map_tapp);
d4481 2
a4482 2
ph_timeout(sig)
	int sig;
a4483 7
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
a4541 17
	if (CurEnv != NULL && CurEnv->e_sendmode == SM_DEFER &&
	    bitset(MF_DEFER, map->map_mflags))
	{
		if (tTd(9, 1))
			dprintf("ph_map_open(%s) => DEFERRED\n",
				map->map_mname);

		/*
		** Unset MF_DEFER here so that map_lookup() returns
		** a temporary failure using the bogus map and
		** map->map_tapp instead of the default permanent error.
		*/

		map->map_mflags &= ~MF_DEFER;
		return FALSE;
	}

d4546 1
a4546 2
	do
	{
d4560 1
a4560 1
				errno = EAGAIN;
d4564 1
a4564 1
			ev = setevent(pmap->ph_timeout, ph_timeout, 0);
d4583 1
a4583 1
			    fflush(pmap->ph_to_server) != 0 ||
d4596 1
a4596 1
			sm_free(hostlist);
d4617 1
a4617 1
	if (bitset(MF_NODEFER, map->map_mflags))
d4619 1
a4619 1
		if (errno == 0)
d4621 1
a4621 2
		syserr("ph_map_open: %s: cannot connect to PH server",
		       map->map_mname);
d4623 1
a4623 1
	else if (!bitset(MF_OPTIONAL, map->map_mflags) && LogLevel > 1)
d4625 2
a4626 3
			  "ph_map_open: %s: cannot connect to PH server",
			  map->map_mname);
	sm_free(hostlist);
d4681 1
a4681 1
		ev = setevent(pmap->ph_timeout, ph_timeout, 0);
d4687 1
a4687 2
	do
	{
d4749 1
a4749 1
		else if (fflush(pmap->ph_to_server) != 0)
a5136 1
		int save_errno;
a5150 1
		save_errno = errno;
d5152 1
a5152 2
			sm_free(np);
		errno = save_errno;
d5163 3
a5165 1
	if (hp == NULL || *hp == NULL)
d5167 1
a5181 1
		hesiod_free_list(HesiodContext, hp);
d5279 1
a5279 1
	sm_free(propval);
d5302 1
a5302 1
	(void) shorten_hostname(nbuf);
d5327 1
a5327 1
		sm_free(vptr);
d5332 1
a5332 1
	sm_free(vptr);
a5721 1
	char *dot;
d5736 1
a5736 1
	dot = shorten_hostname(nbuf);
d5752 1
a5752 2
			found = extract_canonname(nbuf, dot, linebuf,
						  cbuf, sizeof cbuf);
d6216 1
a6216 1
			rval = map_rewrite(map, buf, strlen(buf), av);
a6406 1
		mm->map_mflags |= MF_CLOSING;
d6408 1
a6408 1
		mm->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
d6614 1
a6614 1
	regex_t	*regex_pattern_buf;	/* xalloc it */
a6690 1
	map_p->regex_pattern_buf = (regex_t *)xnalloc(sizeof(regex_t));
d6747 1
a6747 1
	if ((regerr = regcomp(map_p->regex_pattern_buf, p, pflags)) != 0)
d6752 1
a6752 1
		(void) regerror(regerr, map_p->regex_pattern_buf,
d6755 1
a6755 2
		sm_free(map_p->regex_pattern_buf);
		sm_free(map_p);
d6772 1
a6772 1
		substrings = map_p->regex_pattern_buf->re_nsub + 1;
d6781 1
a6781 2
			sm_free(map_p->regex_pattern_buf);
			sm_free(map_p);
d6826 1
a6826 1
		return map_rewrite(map, s, slen, av);
d6850 1
a6850 1
	reg_res = regexec(map_p->regex_pattern_buf,
d6882 1
a6882 1
					 (int) map_p->regex_pattern_buf->re_nsub + 1) == -1)
d6906 1
a6906 2
			if (*ip >= MAX_MATCH ||
			    pmatch[*ip].rm_so < 0 || pmatch[*ip].rm_eo < 0)
d7023 1
a7023 1
	int buflen, r;
a7044 1
		*statp = EX_UNAVAILABLE;
d7047 3
a7049 13
	r = ns_lookup(ns_map, NULL, map->map_file, keybuf, NULL, buf, MAXLINE);
	if (r == NS_UNAVAIL || r == NS_TRYAGAIN)
	{
		*statp = EX_TEMPFAIL;
		return NULL;
	}
	if (r == NS_BADREQ
# ifdef NS_NOPERM
	    || r == NS_NOPERM
# endif /* NS_NOPERM */
	    )
	{
		*statp = EX_CONFIG;
a7050 8
	}
	if (r != NS_SUCCESS)
	{
		*statp = EX_NOTFOUND;
		return NULL;
	}

	*statp = EX_OK;
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: map.c,v 8.413 2000/02/26 05:35:01 gshapiro Exp $";
d2121 1
d2127 3
d2186 1
d2196 5
d2211 2
d2218 8
a2225 1
		return map_rewrite(map, vp, vsize, av);
d2265 1
d2275 5
d2294 2
d2299 1
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Id: map.c,v 8.414.4.34 2000/12/18 18:00:43 ca Exp $";
a19 1

a242 1

d391 2
a392 2
				if (--len <= 0)
					break;
a568 1
			MapOpenErr = TRUE;
d826 1
a826 1
		    strlen(domain) + (i = strlen(cbuf)) + 1 < (size_t) cbuflen)
d1090 1
a1090 1
#  if HASFCHOWN
d1102 1
a1102 1
#  endif /* HASFCHOWN */
d1697 1
a1697 1
#  if HASFCHOWN
d1708 1
a1708 1
#  endif /* HASFCHOWN */
d1967 1
a1967 1
				if (data.size + old.size + 2 > (size_t)bufsiz)
a2120 1
	vp = NULL;
a2125 3
	if (vp != NULL)
		free(vp);

a2181 1
	vp = NULL;
a2190 5
		if (vp != NULL)
		{
			free(vp);
			vp = NULL;
		}
a2200 2
		if (vp != NULL)
			free(vp);
d2206 1
a2206 8
	{
		char *ret;

		ret = map_rewrite(map, vp, vsize, av);
		if (vp != NULL)
			free(vp);
		return ret;
	}
a2245 1
	vp = NULL;
a2254 5
		if (vp != NULL)
		{
			free(vp);
			vp = NULL;
		}
a2268 2
		if (vp != NULL)
			free(vp);
a2271 1
	free(vp);
d2412 1
a2412 1
		if (strcmp(map->map_keycolnm, COL_NAME(res,i)) == 0)
d2782 1
a2782 1
		dprintf("ldapmap_open(%s, %d): ", map->map_mname, mode);
a2812 2
		if (tTd(38, 2))
			dprintf("using cached connection\n");
a2815 3
	if (tTd(38, 2))
		dprintf("opening new connection\n");

a2861 1
	save_errno = errno;
a2943 1
# ifdef LDAP_AUTH_KRBV4
a2954 1
# endif /* LDAP_AUTH_KRBV4 */
a3000 3
	if (tTd(38, 2))
		dprintf("ldapmap_close(%s)\n", map->map_mname);

d3108 1
a3108 1
				 (int) (q - p), p, keybuf);
d3117 1
a3117 1
				 (int) (q - p), p);
d3145 1
a3145 1
				 (int) (q - p + 1), p);
d3166 1
a3166 1
				syserr("Error in ldap_search using %s in map %s",
d3169 1
a3169 1
				syserr("421 4.0.0 Error in ldap_search using %s in map %s",
a3172 11
#ifdef LDAP_SERVER_DOWN
		if (errno == LDAP_SERVER_DOWN)
		{
			int save_errno = errno;

			/* server disappeared, try reopen on next search */
			map->map_class->map_close(map);
			map->map_mflags &= ~(MF_OPEN|MF_WRITABLE);
			errno = save_errno;
		}
#endif /* LDAP_SERVER_DOWN */
a3208 4
		/* If we don't want multiple values and we have one, break */
		if (map->map_coldelim == '\0' && vp != NULL)
			break;

d3216 1
a3216 1
			char **vals = NULL;
a3226 10
# if !defined(LDAP_VERSION_MAX) && !defined(LDAP_OPT_SIZELIMIT)
			/*
			**  Reset value to prevent lingering
			**  LDAP_DECODING_ERROR due to
			**  OpenLDAP 1.X's hack (see below)
			*/

			lmap->ldap_ld->ld_errno = LDAP_SUCCESS;
# endif /* !defined(LDAP_VERSION_MAX) !defined(LDAP_OPT_SIZELIMIT) */

d3235 3
a3237 1
				if (lmap->ldap_attrsonly == LDAPMAP_FALSE)
d3239 8
a3246 4
					vals = ldap_get_values(lmap->ldap_ld,
							       entry,
							       attr);
					if (vals == NULL)
d3248 9
a3256 18
						errno = ldapmap_geterrno(lmap->ldap_ld);
						if (errno == LDAP_SUCCESS)
							continue;

						/* Must be an error */
						errno += E_LDAPBASE;
						if (!bitset(MF_OPTIONAL,
							    map->map_mflags))
						{
							if (bitset(MF_NODEFER,
								   map->map_mflags))
								syserr("Error getting LDAP values in map %s",
								       map->map_mname);
							else
								syserr("421 4.0.0 Error getting LDAP values in map %s",
								       map->map_mname);
						}
						*statp = EX_TEMPFAIL;
d3258 1
a3258 1
						ldap_memfree(attr);
d3260 4
a3263 10
						if (lmap->ldap_res != NULL)
						{
							ldap_msgfree(lmap->ldap_res);
							lmap->ldap_res = NULL;
						}
						(void) ldap_abandon(lmap->ldap_ld,
								    msgid);
						if (vp != NULL)
							free(vp);
						return NULL;
d3265 5
a3273 10
# if !defined(LDAP_VERSION_MAX) && !defined(LDAP_OPT_SIZELIMIT)
				/*
				**  Reset value to prevent lingering
				**  LDAP_DECODING_ERROR due to
				**  OpenLDAP 1.X's hack (see below)
				*/

				lmap->ldap_ld->ld_errno = LDAP_SUCCESS;
# endif /* !defined(LDAP_VERSION_MAX) !defined(LDAP_OPT_SIZELIMIT) */

a3288 9
					if (lmap->ldap_attrsonly == LDAPMAP_TRUE)
					{
						vp = newstr(attr);
# if USING_NETSCAPE_LDAP
						ldap_memfree(attr);
# endif /* USING_NETSCAPE_LDAP */
						break;
					}

d3293 1
a3293 1
						ldap_memfree(attr);
d3301 1
a3301 1
					ldap_memfree(attr);
a3305 22
				/* attributes only */
				if (lmap->ldap_attrsonly == LDAPMAP_TRUE)
				{
					if (vp == NULL)
						vp = newstr(attr);
					else
					{
						vsize = strlen(vp) +
							strlen(attr) + 2;
						tmp = xalloc(vsize);
						snprintf(tmp, vsize, "%s%c%s",
							 vp, map->map_coldelim,
							 attr);
						free(vp);
						vp = tmp;
					}
# if USING_NETSCAPE_LDAP
					ldap_memfree(attr);
# endif /* USING_NETSCAPE_LDAP */
					continue;
				}

d3331 1
a3331 1
				ldap_memfree(attr);
d3389 1
a3389 1
		if (errno != LDAP_SUCCESS && errno != LDAP_DECODING_ERROR)
d3415 4
d3470 1
a3470 1
	if (vp == NULL && !bitset(MF_MATCHONLY, map->map_mflags))
d3482 2
a3483 2
		if (vp != NULL)
			free(vp);
d3489 1
d3492 1
a3492 2
				  "ldap %.100s => %s", name,
				  vp == NULL ? "<NULL>" : vp);
a3495 2
		{
			/* vp != NULL according to test above */
d3497 1
a3497 3
		}
		if (vp != NULL)
			free(vp);
d3506 2
a3507 4
**	secret, and PID so we don't have multiple connections open to
**	the same server for different maps.  Need a separate connection
**	per PID since a parent process may close the map before the
**	child is done with it.
d3530 1
a3530 1
		8 + 1;
d3532 1
a3532 1
	snprintf(nbuf, len, "%s%c%d%c%s%c%s%d",
d3539 1
a3539 2
		 (lmap->ldap_secret == NULL ? "" : lmap->ldap_secret),
		 getpid());
a3635 1
# ifdef LDAP_AUTH_KRBV4
a3636 1
# endif /* LDAP_AUTH_KRBV4 */
d4036 1
a4036 2
						   sfd, TimeOuts.to_fileopen,
						   "ldapmap_parseargs");
a4048 1
# ifdef LDAP_AUTH_KRBV4
a4060 1
# endif /* LDAP_AUTH_KRBV4 */
d4126 1
a4126 1
			if (i >= LDAPMAP_MAX_ATTR)
a4513 17
	if (CurEnv != NULL && CurEnv->e_sendmode == SM_DEFER &&
	    bitset(MF_DEFER, map->map_mflags))
	{
		if (tTd(9, 1))
			dprintf("ph_map_open(%s) => DEFERRED\n",
				map->map_mname);

		/*
		** Unset MF_DEFER here so that map_lookup() returns
		** a temporary failure using the bogus map and
		** map->map_tapp instead of the default permanent error.
		*/

		map->map_mflags &= ~MF_DEFER;
		return FALSE;
	}

d4518 1
a4518 2
	do
	{
d4532 1
a4532 1
				errno = EAGAIN;
d4589 1
a4589 1
	if (bitset(MF_NODEFER, map->map_mflags))
d4591 1
a4591 1
		if (errno == 0)
d4593 1
a4593 2
		syserr("ph_map_open: %s: cannot connect to PH server",
		       map->map_mname);
d4595 1
a4595 1
	else if (!bitset(MF_OPTIONAL, map->map_mflags) && LogLevel > 1)
d4597 1
a4597 2
			  "ph_map_open: %s: cannot connect to PH server",
			  map->map_mname);
d4659 1
a4659 2
	do
	{
d6586 1
a6586 1
	regex_t	*regex_pattern_buf;	/* xalloc it */
a6662 1
	map_p->regex_pattern_buf = (regex_t *)xnalloc(sizeof(regex_t));
d6719 1
a6719 1
	if ((regerr = regcomp(map_p->regex_pattern_buf, p, pflags)) != 0)
d6724 1
a6724 1
		(void) regerror(regerr, map_p->regex_pattern_buf,
a6726 1
		free(map_p->regex_pattern_buf);
d6744 1
a6744 1
		substrings = map_p->regex_pattern_buf->re_nsub + 1;
a6752 1
			free(map_p->regex_pattern_buf);
d6822 1
a6822 1
	reg_res = regexec(map_p->regex_pattern_buf,
d6854 1
a6854 1
					 (int) map_p->regex_pattern_buf->re_nsub + 1) == -1)
d6878 1
a6878 2
			if (*ip >= MAX_MATCH ||
			    pmatch[*ip].rm_so < 0 || pmatch[*ip].rm_eo < 0)
d6995 1
a6995 1
	int buflen, r;
a7016 1
		*statp = EX_UNAVAILABLE;
d7019 3
a7021 9
	r = ns_lookup(ns_map, NULL, map->map_file, keybuf, NULL, buf, MAXLINE);
	if (r == NS_UNAVAIL || r == NS_TRYAGAIN)
	{
		*statp = EX_TEMPFAIL;
		return NULL;
	}
	if (r == NS_BADREQ || r == NS_NOPERM)
	{
		*statp = EX_CONFIG;
a7022 8
	}
	if (r != NS_SUCCESS)
	{
		*statp = EX_NOTFOUND;
		return NULL;
	}

	*statp = EX_OK;
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d14 4
a19 5
SM_RCSID("@@(#)$Sendmail: map.c,v 8.601 2001/09/04 22:43:03 ca Exp $")

#if LDAPMAP
# include <sm/ldap.h>
#endif /* LDAPMAP */
d21 1
a21 1
#if NDBM
d30 1
a30 1
#if NEWDB
d36 1
a36 1
#if NIS
d39 1
a39 1
# if NDBM
d44 1
a44 1
#if NEWDB
d55 9
a63 1
static bool	extract_canonname __P((char *, char *, char *, char[], int));
d66 1
a66 4
#ifdef LDAPMAP
static STAB *	ldapmap_findconn __P((SM_LDAP_STRUCT *));
#endif /* LDAPMAP */
#if NISPLUS
d69 1
a69 1
#if NIS
a76 11
/* default error message for trying to open a map in write mode */
#ifdef ENOSYS
# define SM_EMAPCANTWRITE	ENOSYS
#else /* ENOSYS */
# ifdef EFTYPE
#  define SM_EMAPCANTWRITE	EFTYPE
# else /* EFTYPE */
#  define SM_EMAPCANTWRITE	ENXIO
# endif /* EFTYPE */
#endif /* ENOSYS */

d83 2
a84 2
**		Parse the arguments from the config file.  Return true
**		if they were ok, false otherwise.  Fill in map with the
d102 3
a104 3
**		be either O_RDONLY or O_RDWR.  Return true if it
**		was opened successfully, false otherwise.  If the open
**		failed and the MF_OPTIONAL flag is not set, it should
d119 4
d129 3
d142 2
a143 2
**		true -- if everything parsed OK.
**		false -- otherwise.
d157 2
a158 2
	**  There is no check whether there is really an argument,
	**  but that's not important enough to warrant extra code.
d160 1
a160 2

	map->map_mflags |= MF_TRY0NULL|MF_TRY1NULL;
d291 1
a291 1
		return false;
d293 1
a293 1
	return true;
d310 3
d333 1
a333 1
		sm_dprintf("map_rewrite(%.*s), av =", (int) slen, s);
d335 1
a335 1
			sm_dprintf(" (nullv)");
d339 1
a339 1
				sm_dprintf("\n\t%s", *avp);
d341 1
a341 1
		sm_dprintf("\n");
d373 2
a374 2
			sm_free(buf);
		buf = sm_pmalloc_x(buflen);
d394 1
a394 1
				     break;
d419 1
a419 1
		(void) sm_strlcpy(bp, map->map_app, len);
d423 1
a423 1
		sm_dprintf("map_rewrite => %s\n", buf);
d478 1
a478 1
		sm_dprintf("map_init(%s:%s, %s)\n",
d488 1
a488 1
			sm_dprintf("\tnot rebuildable\n");
a494 1
		map->map_mflags |= MF_CLOSING;
d496 1
a496 1
		map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
d499 1
a499 1
	(void) rebuildaliases(map, false);
d510 1
d517 1
a517 1
	bool restore = false;
d523 1
a523 1
		return false;
d527 1
a527 1
		return true;
d533 3
a535 3
		restore = true;
		HoldErrs = true;
		QuickAbort = false;
d542 1
a542 1
			sm_dprintf("openmap()\t%s:%s %s: valid\n",
d550 1
a550 1
		map->map_pid = CurrentPid;
d555 1
a555 1
			sm_dprintf("openmap()\t%s:%s %s: invalid%s%s\n",
d563 1
a563 1
				errno == 0 ? "" : sm_errstring(errno));
a567 1
			map->map_orgclass = map->map_class;
d569 3
a571 2
			map->map_mflags |= MF_OPEN|MF_OPENBOGUS;
			map->map_pid = CurrentPid;
d593 1
a593 1
**		bogus -- only close bogus maps.
d600 1
a600 2
closemaps(bogus)
	bool bogus;
d602 1
a602 1
	stabapply(map_close, bogus);
d608 2
a609 2
**		s -- STAB entry: if map: try to close
**		bogus -- only close bogus maps or MCF_NOTPERSIST maps.
d617 1
a617 1
map_close(s, bogus)
d619 1
a619 1
	int bogus;	/* int because of stabapply(), used as bool */
a621 1
	extern MAPCLASS BogusMapClass;
a627 9
	/*
	**  close the map iff:
	**  it is valid and open and opened by this process
	**  and (!bogus or it's a bogus map or it is not persistent)
	**  negate this: return iff
	**  it is not valid or it is not open or not opened by this process
	**  or (bogus and it's not a bogus map and it's not not-persistent)
	*/

d630 1
a630 4
	    bitset(MF_CLOSING, map->map_mflags) ||
	    map->map_pid != CurrentPid ||
	    (bogus && map->map_class != &BogusMapClass &&
	     !bitset(MCF_NOTPERSIST, map->map_class->map_cflags)))
a632 3
	if (map->map_class == &BogusMapClass && map->map_orgclass != NULL &&
	    map->map_orgclass != &BogusMapClass)
		map->map_class = map->map_orgclass;
d634 1
a634 1
		sm_dprintf("closemaps: closing %s (%s)\n",
d638 2
a639 6
	if (!bitset(MF_OPENBOGUS, map->map_mflags))
	{
		map->map_mflags |= MF_CLOSING;
		map->map_class->map_close(map);
	}
	map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_OPENBOGUS|MF_CLOSING);
a647 1
**		pttl -- pointer to return TTL (can be NULL).
d650 2
a651 2
**		true -- if the host was found.
**		false -- otherwise.
d655 1
a655 1
getcanonname(host, hbsize, trymx, pttl)
a658 1
	int *pttl;
d662 2
a663 2
	bool found = false;
	bool got_tempfail = false;
a668 2
	if (pttl != 0)
		*pttl = SM_DEFAULT_TTL;
d674 1
a674 1
			sm_dprintf("getcanonname(%s), trying %s\n",
d680 1
a680 1
#if NIS
d686 1
a686 1
#if NISPLUS
d695 1
a695 1
			found = dns_getcanonname(host, hbsize, trymx, &status,							 pttl);
d706 1
a706 1
			found = false;
d726 1
a726 1
			got_tempfail = true;
d741 1
a741 1
			sm_dprintf("getcanonname(%s), found\n", host);
d756 2
a757 4
					(void) sm_strlcat2(host, ".", d,
							   hbsize);
				else
					(void) sm_strlcat(host, d, hbsize);
d760 1
a760 1
				return false;
d762 1
a762 1
		return true;
d766 1
a766 2
		sm_dprintf("getcanonname(%s), failed, status=%d\n", host,
			status);
d768 1
d770 1
a770 1
		SM_SET_H_ERRNO(TRY_AGAIN);
d772 2
a773 1
		SM_SET_H_ERRNO(HOST_NOT_FOUND);
d775 1
a775 1
	return false;
a781 1
**		dot -- where to reinsert '.' to get FQDN
d787 2
a788 2
**		true -- if the line matched the desired name.
**		false -- otherwise.
d792 1
a792 1
extract_canonname(name, dot, line, cbuf, cbuflen)
a793 1
	char *dot;
d800 1
a800 1
	bool found = false;
d804 1
a804 1
		return false;
d818 1
a818 11
			(void) sm_strlcpy(cbuf, p, cbuflen);
		}
		if (sm_strcasecmp(name, p) == 0)
			found = true;
		else if (dot != NULL)
		{
			/* try looking for the FQDN as well */
			*dot = '.';
			if (sm_strcasecmp(name, p) == 0)
				found = true;
			*dot = '\0';
d820 2
d833 1
a833 1
			(void) sm_strlcpy(p, domain, cbuflen - i - 1);
a837 461

/*
**  DNS modules
*/

#if NAMED_BIND
# if DNSMAP

#  include "sm_resolve.h"
#  if NETINET || NETINET6
#   include <arpa/inet.h>
#  endif /* NETINET || NETINET6 */

/*
**  DNS_MAP_OPEN -- stub to check proper value for dns map type
*/

bool
dns_map_open(map, mode)
	MAP *map;
	int mode;
{
	if (tTd(38,2))
		sm_dprintf("dns_map_open(%s, %d)\n", map->map_mname, mode);

	mode &= O_ACCMODE;
	if (mode != O_RDONLY)
	{
		/* issue a pseudo-error message */
		errno = SM_EMAPCANTWRITE;
		return false;
	}
	return true;
}

/*
**  DNS_MAP_PARSEARGS -- parse dns map definition args.
**
**	Parameters:
**		map -- pointer to MAP
**		args -- pointer to the args on the config line.
**
**	Returns:
**		true -- if everything parsed OK.
**		false -- otherwise.
*/

#  if _FFR_DNSMAP_MULTILIMIT
#   if !_FFR_DNSMAP_MULTI
  ERROR README:	You must define _FFR_DNSMAP_MULTI to use _FFR_DNSMAP_MULTILIMIT
#   endif /* ! _FFR_DNSMAP_MULTI */
#  endif /* _FFR_DNSMAP_MULTILIMIT */

#  if _FFR_DNSMAP_MULTI
#   if _FFR_DNSMAP_MULTILIMIT
#    define map_sizelimit	map_lockfd	/* overload field */
#   endif /* _FFR_DNSMAP_MULTILIMIT */
#  endif /* _FFR_DNSMAP_MULTI */

bool
dns_map_parseargs(map,args)
	MAP *map;
	char *args;
{
	register char *p = args;
	int dns_m_type;

	dns_m_type = -1;
	map->map_mflags |= MF_TRY0NULL|MF_TRY1NULL;

	for (;;)
	{
		while (isascii(*p) && isspace(*p))
			p++;
		if (*p != '-')
			break;
		switch (*++p)
		{
		  case 'N':
			map->map_mflags |= MF_INCLNULL;
			map->map_mflags &= ~MF_TRY0NULL;
			break;

		  case 'O':
			map->map_mflags &= ~MF_TRY1NULL;
			break;

		  case 'o':
			map->map_mflags |= MF_OPTIONAL;
			break;

		  case 'f':
			map->map_mflags |= MF_NOFOLDCASE;
			break;

		  case 'm':
			map->map_mflags |= MF_MATCHONLY;
			break;

		  case 'A':
			map->map_mflags |= MF_APPEND;
			break;

		  case 'q':
			map->map_mflags |= MF_KEEPQUOTES;
			break;

		  case 't':
			map->map_mflags |= MF_NODEFER;
			break;

		  case 'a':
			map->map_app = ++p;
			break;

		  case 'T':
			map->map_tapp = ++p;
			break;

		  case 'd':
			{
				char *h;

				++p;
				h = strchr(p, ' ');
				if (h != NULL)
					*h = '\0';
				map->map_timeout = convtime(p, 's');
				if (h != NULL)
					*h = ' ';
			}
			break;

		  case 'r':
			while (isascii(*++p) && isspace(*p))
				continue;
			map->map_retry = atoi(p);
			break;

#  if _FFR_DNSMAP_MULTI
		  case 'z':
			if (*++p != '\\')
				map->map_coldelim = *p;
			else
			{
				switch (*++p)
				{
				  case 'n':
					map->map_coldelim = '\n';
					break;

				  case 't':
					map->map_coldelim = '\t';
					break;

				  default:
					map->map_coldelim = '\\';
				}
			}
			break;

#   if _FFR_DNSMAP_MULTILIMIT
		  case 'Z':
			while (isascii(*++p) && isspace(*p))
				continue;
			map->map_sizelimit = atoi(p);
			break;
#   endif /* _FFR_DNSMAP_MULTILIMIT */
#  endif /* _FFR_DNSMAP_MULTI */

			/* Start of dns_map specific args */
		  case 'R':		/* search field */
			{
				char *h;

				while (isascii(*++p) && isspace(*p))
					continue;
				h = strchr(p, ' ');
				if (h != NULL)
					*h = '\0';
				dns_m_type = dns_string_to_type(p);
				if (h != NULL)
					*h = ' ';
				if (dns_m_type < 0)
					syserr("dns map %s: wrong type %s",
						map->map_mname, p);
			}
			break;

#  if _FFR_DNSMAP_BASE
		  case 'B':		/* base domain */
			{
				char *h;

				while (isascii(*++p) && isspace(*p))
					continue;
				h = strchr(p, ' ');
				if (h != NULL)
					*h = '\0';

				/*
				**  slight abuse of map->map_file; it isn't
				**	used otherwise in this map type.
				*/

				map->map_file = newstr(p);
				if (h != NULL)
					*h = ' ';
			}
			break;
#  endif /* _FFR_DNSMAP_BASE */

		}
		while (*p != '\0' && !(isascii(*p) && isspace(*p)))
			p++;
		if (*p != '\0')
			*p++ = '\0';
	}
	if (dns_m_type < 0)
		syserr("dns map %s: missing -R type", map->map_mname);
	if (map->map_app != NULL)
		map->map_app = newstr(map->map_app);
	if (map->map_tapp != NULL)
		map->map_tapp = newstr(map->map_tapp);

	/*
	**  Assumption: assert(sizeof int <= sizeof(ARBPTR_T));
	**  Even if this assumption is wrong, we use only one byte,
	**  so it doesn't really matter.
	*/

	map->map_db1 = (ARBPTR_T) dns_m_type;
	return true;
}

/*
**  DNS_MAP_LOOKUP -- perform dns map lookup.
**
**	Parameters:
**		map -- pointer to MAP
**		name -- name to lookup
**		av -- arguments to interpolate into buf.
**		statp -- pointer to status (EX_)
**
**	Returns:
**		result of lookup if succeeded.
**		NULL -- otherwise.
*/

char *
dns_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
#  if _FFR_DNSMAP_MULTI
#   if _FFR_DNSMAP_MULTILIMIT
	int resnum = 0;
#   endif /* _FFR_DNSMAP_MULTILIMIT */
#  endif /* _FFR_DNSMAP_MULTI */
	int dns_m_type = (int) map->map_db1;
	char *vp = NULL, *result = NULL;
	size_t vsize;
	RESOURCE_RECORD_T *rr = NULL;
	DNS_REPLY_T *r = NULL;
#  if NETINET6
	static char buf6[INET6_ADDRSTRLEN];
#  endif /* NETINET6 */

	if (tTd(38, 20))
		sm_dprintf("dns_map_lookup(%s, %s)\n",
			   map->map_mname, name);

#  if _FFR_DNSMAP_BASE
	if (map->map_file != NULL && *map->map_file != '\0')
	{
		size_t len;
		char *appdomain;

		len = strlen(map->map_file) + strlen(name) + 2;
		appdomain = (char *) sm_malloc(len);
		if (appdomain == NULL)
		{
			*statp = EX_UNAVAILABLE;
			return NULL;
		}
		(void) sm_strlcpyn(appdomain, len, 3, name, ".", map->map_file);
		r = dns_lookup_int(appdomain, C_IN, dns_m_type,
				   map->map_timeout, map->map_retry);
		sm_free(appdomain);
	}
	else
#  endif /* _FFR_DNSMAP_BASE */
	{
		r = dns_lookup_int(name, C_IN, dns_m_type, map->map_timeout,
				   map->map_retry);
	}

	if (r == NULL)
	{
		result = NULL;
		if (errno == ETIMEDOUT || h_errno == TRY_AGAIN ||
		    errno == ECONNREFUSED)
			*statp = EX_TEMPFAIL;
		else
			*statp = EX_NOTFOUND;
		goto cleanup;
	}
	*statp = EX_OK;
	for (rr = r->dns_r_head; rr != NULL; rr = rr->rr_next)
	{
		char *type = NULL;
		char *value = NULL;

		switch (rr->rr_type)
		{
		  case T_NS:
			type = "T_NS";
			value = rr->rr_u.rr_txt;
			break;
		  case T_CNAME:
			type = "T_CNAME";
			value = rr->rr_u.rr_txt;
			break;
		  case T_AFSDB:
			type = "T_AFSDB";
			value = rr->rr_u.rr_mx->mx_r_domain;
			break;
		  case T_SRV:
			type = "T_SRV";
			value = rr->rr_u.rr_srv->srv_r_target;
			break;
		  case T_PTR:
			type = "T_PTR";
			value = rr->rr_u.rr_txt;
			break;
		  case T_TXT:
			type = "T_TXT";
			value = rr->rr_u.rr_txt;
			break;
		  case T_MX:
			type = "T_MX";
			value = rr->rr_u.rr_mx->mx_r_domain;
			break;
#  if NETINET
		  case T_A:
			type = "T_A";
			value = inet_ntoa(*(rr->rr_u.rr_a));
			break;
#  endif /* NETINET */
#  if NETINET6
		  case T_AAAA:
			type = "T_AAAA";
			value = anynet_ntop(rr->rr_u.rr_aaaa, buf6,
					    sizeof buf6);
			break;
#  endif /* NETINET6 */
		}

		if (dns_m_type != rr->rr_type)
		{
			if (tTd(38, 40))
				sm_dprintf("\tskipping type %s (%d) value %s\n",
					   type != NULL ? type : "<UNKNOWN>",
					   rr->rr_type,
					   value != NULL ? value : "<NO VALUE>");
			continue;
		}

#  if NETINET6
		if (rr->rr_type == T_AAAA && value == NULL)
		{
			result = NULL;
			*statp = EX_DATAERR;
			if (tTd(38, 40))
				sm_dprintf("\tbad T_AAAA conversion\n");
			goto cleanup;
		}
#  endif /* NETINET6 */
		if (tTd(38, 40))
			sm_dprintf("\tfound type %s (%d) value %s\n",
				   type != NULL ? type : "<UNKNOWN>",
				   rr->rr_type,
				   value != NULL ? value : "<NO VALUE>");
#  if _FFR_DNSMAP_MULTI
		if (value != NULL &&
		    (map->map_coldelim == '\0' ||
#   if _FFR_DNSMAP_MULTILIMIT
		     map->map_sizelimit == 1 ||
#   endif /* _FFR_DNSMAP_MULTILIMIT */
		     bitset(MF_MATCHONLY, map->map_mflags)))
		{
			/* Only care about the first match */
			vp = newstr(value);
			break;
		}
		else if (vp == NULL)
		{
			/* First result */
			vp = newstr(value);
		}
		else
		{
			/* concatenate the results */
			int sz;
			char *new;

			sz = strlen(vp) + strlen(value) + 2;
			new = xalloc(sz);
			(void) sm_snprintf(new, sz, "%s%c%s",
					   vp, map->map_coldelim, value);
			sm_free(vp);
			vp = new;
#   if _FFR_DNSMAP_MULTILIMIT
			if (map->map_sizelimit > 0 &&
			    ++resnum >= map->map_sizelimit)
				break;
#   endif /* _FFR_DNSMAP_MULTILIMIT */
		}
#  else /* _FFR_DNSMAP_MULTI */
		vp = value;
		break;
#  endif /* _FFR_DNSMAP_MULTI */
	}
	if (vp == NULL)
	{
		result = NULL;
		*statp = EX_NOTFOUND;
		if (tTd(38, 40))
			sm_dprintf("\tno match found\n");
		goto cleanup;
	}

#  if _FFR_DNSMAP_MULTI
	/* Cleanly truncate for rulesets */
	truncate_at_delim(vp, PSBUFSIZE / 2, map->map_coldelim);
#  endif /* _FFR_DNSMAP_MULTI */

	vsize = strlen(vp);

	if (LogLevel > 9)
		sm_syslog(LOG_INFO, CurEnv->e_id, "dns %.100s => %s",
			  name, vp);
	if (bitset(MF_MATCHONLY, map->map_mflags))
		result = map_rewrite(map, name, strlen(name), NULL);
	else
		result = map_rewrite(map, vp, vsize, av);

  cleanup:
#  if _FFR_DNSMAP_MULTI
	if (vp != NULL)
		sm_free(vp);
#  endif /* _FFR_DNSMAP_MULTI */
	if (r != NULL)
		dns_free_data(r);
	return result;
}
# endif /* DNSMAP */
#endif /* NAMED_BIND */

d842 1
a842 1
#if NDBM
d866 1
a866 1
		sm_dprintf("ndbm_map_open(%s, %s, %d)\n",
d872 2
a873 2
	(void) sm_strlcpyn(dirfile, sizeof dirfile, 2, map->map_file, ".dir");
	(void) sm_strlcpyn(pagfile, sizeof pagfile, 2, map->map_file, ".pag");
d892 1
a892 1
		       sff, smode, &std);
d897 20
d925 1
a925 1
			sm_dprintf("\t%s map file: %d\n", prob, ret);
d929 1
a929 1
		return false;
d980 1
a980 1
			return false;
d991 1
a991 1
			return false;
d1004 1
a1004 1
			return false;
d1023 2
a1024 2
		    aliaswait(map, ".pag", false))
			return true;
d1032 1
a1032 1
		return false;
d1047 1
a1047 1
		return false;
d1062 1
a1062 1
		return false;
d1073 1
a1073 1
	if (fstat(pfd, &st) >= 0)
d1085 2
a1086 2
		    !aliaswait(map, ".pag", true))
			return false;
d1101 1
a1101 1
					  map->map_file, sm_errstring(err));
d1103 1
a1103 1
					map->map_file, sm_errstring(err));
a1104 6
#  else /* HASFCHOWN */
			sm_syslog(LOG_ALERT, NOQID,
				  "no fchown(): cannot change ownership on %s",
				  map->map_file);
			message("050 no fchown(): cannot change ownership on %s",
				map->map_file);
d1108 1
a1108 1
	return true;
d1124 1
a1124 1
	int dfd, pfd;
d1129 1
a1129 1
		sm_dprintf("ndbm_map_lookup(%s, %s)\n",
d1144 4
a1147 6
	dfd = dbm_dirfno((DBM *) map->map_db1);
	if (dfd >= 0 && !bitset(MF_LOCKED, map->map_mflags))
		(void) lockfile(dfd, map->map_file, ".dir", LOCK_SH);
	pfd = dbm_pagfno((DBM *) map->map_db1);
	if (pfd < 0 || fstat(pfd, &stbuf) < 0 ||
	    stbuf.st_mtime > map->map_mtime)
d1153 2
a1154 3
		if (dfd >= 0 && !bitset(MF_LOCKED, map->map_mflags))
			(void) lockfile(dfd, map->map_file, ".dir", LOCK_UN);
		map->map_mflags |= MF_CLOSING;
d1156 1
a1156 1
		map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
d1160 1
a1160 1
			map->map_pid = CurrentPid;
a1171 1
				map->map_orgclass = map->map_class;
d1174 1
a1174 1
				map->map_pid = CurrentPid;
d1195 2
a1196 2
	if (dfd >= 0 && !bitset(MF_LOCKED, map->map_mflags))
		(void) lockfile(dfd, map->map_file, ".dir", LOCK_UN);
d1222 1
a1222 1
		sm_dprintf("ndbm_map_store(%s, %s, %s)\n",
d1259 1
a1259 1
						   (char **) NULL, &xstat);
d1266 1
a1266 1
						(void) sm_free(buf);
d1268 1
a1268 1
					buf = sm_pmalloc_x(bufsiz);
d1270 2
a1271 2
				(void) sm_strlcpyn(buf, bufsiz, 3,
					data.dptr, ",", old.dptr);
d1275 1
a1275 1
					sm_dprintf("ndbm_map_store append=%s\n",
d1296 1
a1296 1
		sm_dprintf("ndbm_map_close(%s, %s, %lx)\n",
d1314 1
a1314 1
			(void) sm_snprintf(buf, sizeof buf, "%010ld", curtime());
d1344 1
a1344 1
#if NEWDB
d1386 1
a1386 1
		sm_dprintf("bt_map_open(%s, %s, %d)\n",
d1415 1
a1415 1
		sm_dprintf("hash_map_open(%s, %s, %d)\n",
d1458 1
a1458 1
	(void) sm_strlcpy(buf, map->map_file, sizeof buf - 3);
d1461 1
a1461 1
		(void) sm_strlcat(buf, ".db", sizeof buf);
d1485 21
d1514 1
a1514 1
			sm_dprintf("\t%s map file: %s\n", prob, sm_errstring(i));
d1519 1
a1519 1
		return false;
d1543 1
a1543 1
		return false;
d1553 1
a1553 1
		return false;
d1564 1
a1564 1
		return false;
a1625 4
#ifdef DB_OLD_VERSION
				if (ret == DB_OLD_VERSION)
					ret = EINVAL;
#endif /* DB_OLD_VERSION */
d1649 2
a1650 2
		    aliaswait(map, ".db", false))
			return true;
d1659 1
a1659 1
		return false;
d1682 1
a1682 1
		return false;
d1707 1
a1707 1
					  buf, sm_errstring(err));
d1709 1
a1709 1
					buf, sm_errstring(err));
a1710 6
#  else /* HASFCHOWN */
			sm_syslog(LOG_ALERT, NOQID,
				  "no fchown(): cannot change ownership on %s",
				  map->map_file);
			message("050 no fchown(): cannot change ownership on %s",
				map->map_file);
d1727 3
a1729 3
	    !aliaswait(map, ".db", true))
		return false;
	return true;
d1758 1
a1758 1
		sm_dprintf("db_map_lookup(%s, %s)\n",
d1764 1
a1764 1
	(void) sm_strlcpy(buf, map->map_file, i + 1);
a1792 1
		map->map_mflags |= MF_CLOSING;
d1794 1
a1794 1
		map->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
d1798 1
a1798 1
			map->map_pid = CurrentPid;
a1810 1
				map->map_orgclass = map->map_class;
d1813 1
a1813 1
				map->map_pid = CurrentPid;
d1910 1
a1910 1
		sm_dprintf("db_map_store(%s, %s, %s)\n",
d1966 1
a1966 1
						 (char **) NULL, &status);
d1970 1
a1970 1
				if (data.size + old.size + 2 > (size_t) bufsiz)
d1973 1
a1973 1
						sm_free(buf);
d1975 1
a1975 1
					buf = sm_pmalloc_x(bufsiz);
d1977 2
a1978 3
				(void) sm_strlcpyn(buf, bufsiz, 3,
					(char *) data.data, ",",
					(char *) old.data);
d1982 1
a1982 1
					sm_dprintf("db_map_store append=%s\n",
d2008 1
a2008 1
		sm_dprintf("db_map_close(%s, %s, %lx)\n",
d2040 1
a2040 2

	if (map->map_pid != CurrentPid)
d2060 1
a2060 1
#if NIS
d2081 1
a2081 1
		sm_dprintf("nis_map_open(%s, %s, %d)\n",
d2088 10
a2097 2
		errno = SM_EMAPCANTWRITE;
		return false;
d2119 1
a2119 1
			return false;
d2128 1
a2128 1
		sm_dprintf("nis_map_open: yp_match(@@, %s, %s) => %s\n",
d2131 1
a2131 1
		sm_free(vp);
d2144 1
a2144 1
		    aliaswait(map, NULL, true))
d2146 1
a2146 1
			return true;
d2155 1
a2155 1
	return false;
a2175 1
	char *SM_NONVOLATILE result = NULL;
d2178 1
a2178 1
		sm_dprintf("nis_map_lookup(%s, %s)\n",
d2199 5
a2203 1
		SM_FREE_CLR(vp);
d2215 1
a2215 1
			sm_free(vp);
d2218 7
a2224 6
	SM_TRY
		if (bitset(MF_MATCHONLY, map->map_mflags))
			result = map_rewrite(map, name, strlen(name), NULL);
		else
			result = map_rewrite(map, vp, vsize, av);
	SM_FINALLY
d2226 3
a2228 3
			sm_free(vp);
	SM_END_TRY
	return result;
d2246 2
a2247 2
	static bool try0null = true;
	static bool try1null = true;
d2254 1
a2254 1
		sm_dprintf("nis_getcanonname(%s)\n", name);
d2256 1
a2256 1
	if (sm_strlcpy(nbuf, name, sizeof nbuf) >= sizeof nbuf)
d2259 1
a2259 1
		return false;
d2261 1
a2261 1
	(void) shorten_hostname(nbuf);
d2274 1
a2274 1
			try1null = false;
d2278 5
a2282 1
		SM_FREE_CLR(vp);
d2287 1
a2287 1
			try0null = false;
d2298 2
a2299 2
			sm_free(vp);
		return false;
d2301 2
a2302 2
	(void) sm_strlcpy(host_record, vp, sizeof host_record);
	sm_free(vp);
d2304 2
a2305 2
		sm_dprintf("got record `%s'\n", host_record);
	if (!extract_canonname(nbuf, NULL, host_record, cbuf, sizeof cbuf))
d2309 1
a2309 1
		return false;
d2311 1
a2311 1
	if (sm_strlcpy(name, cbuf, hbsize) >= hbsize)
d2314 1
a2314 1
		return false;
d2316 1
d2318 1
a2318 1
	return true;
d2328 1
a2328 1
#if NISPLUS
d2354 1
a2354 1
		sm_dprintf("nisplus_map_open(%s, %s, %d)\n",
d2361 1
a2361 1
		return false;
d2372 1
a2372 1
			sm_dprintf("nisplus_map_open(%s): using domain %s\n",
d2378 1
a2378 1
		(void) sm_strlcpy(qbuf, map->map_file, sizeof qbuf);
d2383 2
a2384 2
		(void) sm_strlcpyn(qbuf, sizeof qbuf, 3,
				   map->map_file, ".", map->map_domain);
d2402 1
a2402 1
				return false;
d2416 1
a2416 1
			return false;
d2424 1
a2424 1
			sm_dprintf("nisplus_map_open: %s is not a table\n", qbuf);
d2432 1
a2432 1
		return false;
d2441 1
a2441 1
	for (i = 0; i < max_col; i++)
d2449 1
a2449 1
			sm_dprintf("nisplus_map_open(%s): can not find key column %s\n",
d2452 1
a2452 1
		return false;
d2459 1
a2459 1
		return true;
d2467 1
a2467 1
			return true;
d2472 1
a2472 1
		sm_dprintf("nisplus_map_open(%s): can not find column %s\n",
d2475 1
a2475 1
	return false;
d2499 1
a2499 1
		sm_dprintf("nisplus_map_lookup(%s, %s)\n",
d2507 1
a2507 1
			map->map_pid = CurrentPid;
d2555 1
a2555 1
		(void) sm_snprintf(qbuf, sizeof qbuf, "[%s=%s],%s.%s",
d2559 1
a2559 1
		(void) sm_snprintf(qbuf, sizeof qbuf, "[%s=%s],%s",
d2563 1
a2563 1
		sm_dprintf("qbuf=%s\n", qbuf);
d2579 1
a2579 1
				sm_dprintf("nisplus_map_lookup(%s), got %d entries, additional entries ignored\n",
d2589 1
a2589 1
			sm_dprintf("nisplus_map_lookup(%s), found %s\n",
d2612 1
a2612 1
		sm_dprintf("nisplus_map_lookup(%s), failed\n", name);
d2636 1
a2636 1
	if (sm_strlcpy(nbuf, name, sizeof nbuf) >= sizeof nbuf)
d2639 1
a2639 1
		return false;
d2641 2
a2642 1
	(void) shorten_hostname(nbuf);
d2648 1
a2648 2
		(void) sm_snprintf(qbuf, sizeof qbuf,
			"[name=%s],hosts.org_dir", nbuf);
d2654 2
a2655 2
		(void) sm_snprintf(qbuf, sizeof qbuf,
				   "[name=%s],hosts.org_dir.%s", nbuf, &p[1]);
d2660 1
a2660 1
		return false;
d2664 2
a2665 2
		sm_dprintf("\nnisplus_getcanoname(%s), qbuf=%s\n",
			   name, qbuf);
d2668 1
a2668 1
			  NULL, NULL);
d2684 2
a2685 2
				sm_dprintf("nisplus_getcanoname(%s), got %d entries, all but first ignored\n",
					   name, count);
d2689 2
a2690 2
			sm_dprintf("nisplus_getcanoname(%s), found in directory \"%s\"\n",
				   name, (NIS_RES_OBJECT(result))->zo_domain);
d2696 2
a2697 2
			sm_dprintf("nisplus_getcanonname(%s), found %s\n",
				   name, vp);
d2711 1
a2711 1
				(void) sm_strlcpy(name, vp, hbsize);
d2713 1
a2713 2
				(void) sm_snprintf(name, hbsize,
						   "%s.%s", vp, domain);
d2719 1
a2719 1
		return true;
d2731 2
a2732 2
		sm_dprintf("nisplus_getcanonname(%s), failed, status=%d, nsw_stat=%d\n",
			   name, result->status, *statp);
d2734 1
a2734 1
	return false;
d2747 1
a2747 1
	(void) sm_strlcpy(default_domain, p, sizeof default_domain);
d2762 1
a2762 1
# if PH_MAP
d2766 1
a2766 3
static char *ldapmap_dequote __P((char *));

static char *
d2792 1
a2792 1
#if LDAPMAP
d2794 1
a2794 1
static SM_LDAP_STRUCT *LDAPDefaults = NULL;
d2809 1
a2809 1
	SM_LDAP_STRUCT *lmap;
d2813 1
a2813 1
		sm_dprintf("ldapmap_open(%s, %d): ", map->map_mname, mode);
d2821 26
a2846 2
		errno = SM_EMAPCANTWRITE;
		return false;
d2849 36
a2884 1
	lmap = (SM_LDAP_STRUCT *) map->map_db1;
d2886 2
a2887 5
	s = ldapmap_findconn(lmap);
	if (s->s_lmap != NULL)
	{
		/* Already have a connection open to this LDAP server */
		lmap->ldap_ld = ((SM_LDAP_STRUCT *)s->s_lmap->map_db1)->ldap_ld;
d2889 1
a2889 3
		/* Add this map as head of linked list */
		lmap->ldap_next = s->s_lmap;
		s->s_lmap = map;
d2891 4
a2894 4
		if (tTd(38, 2))
			sm_dprintf("using cached connection\n");
		return true;
	}
d2896 9
a2904 2
	if (tTd(38, 2))
		sm_dprintf("opening new connection\n");
d2906 2
a2907 2
	/* No connection yet, connect */
	if (!sm_ldap_start(map->map_mname, lmap))
d2909 1
a2909 1
		if (errno == ETIMEDOUT)
d2915 1
d2917 5
d2923 8
d2936 1
a2936 1
				       "ldap_init/ldap_bind",
d2946 1
a2946 1
				       "ldap_init/ldap_bind",
d2954 60
a3013 1
		return false;
d3016 11
a3026 3
	/* Save connection for reuse */
	s->s_lmap = map;
	return true;
d3037 1
a3037 1
	SM_LDAP_STRUCT *lmap;
d3041 1
a3041 1
		sm_dprintf("ldapmap_close(%s)\n", map->map_mname);
d3043 1
a3043 1
	lmap = (SM_LDAP_STRUCT *) map->map_db1;
d3049 5
a3053 2
	/* Close the LDAP connection */
	sm_ldap_close(lmap);
d3055 3
a3057 2
	/* Mark all the maps that share the connection as closed */
	s = ldapmap_findconn(lmap);
d3059 1
a3059 1
	while (s->s_lmap != NULL)
d3061 1
a3061 7
		MAP *smap = s->s_lmap;

		if (tTd(38, 2) && smap != map)
			sm_dprintf("ldapmap_close(%s): closed %s (shared LDAP connection)\n",
				   map->map_mname, smap->map_mname);
		smap->map_mflags &= ~(MF_OPEN|MF_WRITABLE);
		lmap = (SM_LDAP_STRUCT *) smap->map_db1;
a3062 2
		s->s_lmap = lmap->ldap_next;
		lmap->ldap_next = NULL;
d3068 1
a3068 1
**  SUNET_ID_HASH -- Convert a string to its Sunet_id canonical form
d3072 1
a3072 1
static char *
d3116 2
a3117 1
	char *vp, *p;
d3119 1
a3119 1
	SM_LDAP_STRUCT *lmap = NULL;
d3121 1
d3124 1
a3124 1
		sm_dprintf("ldapmap_lookup(%s, %s)\n", map->map_mname, name);
d3127 2
a3128 2
	lmap = (SM_LDAP_STRUCT *) map->map_db1;
	sm_ldap_setopts(lmap->ldap_ld, lmap);
d3130 1
a3130 1
	(void) sm_strlcpy(keybuf, name, sizeof keybuf);
d3141 61
a3201 1
	msgid = sm_ldap_search(lmap, keybuf);
d3204 1
a3204 4
		int save_errno;

		errno = sm_ldap_geterrno(lmap->ldap_ld) + E_LDAPBASE;
		save_errno = errno;
d3209 1
a3209 1
				       keybuf, map->map_mname);
d3212 1
a3212 1
				       keybuf, map->map_mname);
d3215 2
a3216 2
		errno = save_errno - E_LDAPBASE;
		switch (errno)
d3218 2
a3219 5
#ifdef LDAP_SERVER_DOWN
		  case LDAP_SERVER_DOWN:
#endif /* LDAP_SERVER_DOWN */
		  case LDAP_TIMEOUT:
		  case LDAP_UNAVAILABLE:
d3221 3
a3223 2
			ldapmap_close(map);
			break;
d3225 1
a3225 1
		errno = save_errno;
d3255 1
a3255 1
					sm_free(vp); /* XXX */
d3257 1
a3257 1
					sm_dprintf("ldap search found multiple on a single match query\n");
d3309 1
a3309 1
						errno = sm_ldap_geterrno(lmap->ldap_ld);
d3338 1
a3338 1
							sm_free(vp); /* XXX */
d3388 1
a3388 12
					vsize = strlen(vals[0]) + 1;
					if (lmap->ldap_attrsep != '\0')
						vsize += strlen(attr) + 1;
					vp = xalloc(vsize);
					if (lmap->ldap_attrsep != '\0')
						sm_snprintf(vp, vsize,
							    "%s%c%s",
							    attr,
							    lmap->ldap_attrsep,
							    vals[0]);
					else
						sm_strlcpy(vp, vals[0], vsize);
d3406 4
a3409 5
						(void) sm_snprintf(tmp,
							vsize, "%s%c%s",
							vp, map->map_coldelim,
							attr);
						sm_free(vp); /* XXX */
a3425 1
				{
a3426 3
					if (lmap->ldap_attrsep != '\0')
						vsize += strlen(attr) + 1;
				}
d3433 2
a3434 8
					if (lmap->ldap_attrsep != '\0')
					{
						p += sm_strlcpy(p, attr,
								vsize - (p - vp_tmp));
						*p++ = lmap->ldap_attrsep;
					}
					p += sm_strlcpy(p, vals[i],
							vsize - (p - vp_tmp));
d3452 1
a3452 1
				(void) sm_snprintf(tmp, vsize, "%s%c%s",
d3455 2
a3456 2
				sm_free(vp); /* XXX */
				sm_free(vp_tmp); /* XXX */
d3459 1
a3459 1
			errno = sm_ldap_geterrno(lmap->ldap_ld);
d3492 1
a3492 1
					sm_free(vp); /* XXX */
d3500 1
a3500 1
		errno = sm_ldap_geterrno(lmap->ldap_ld);
d3522 1
a3522 1
				sm_free(vp); /* XXX */
d3547 1
a3547 1
				sm_free(vp); /* XXX */
d3556 1
a3556 1
		errno = sm_ldap_geterrno(lmap->ldap_ld);
d3559 1
a3559 2
		int save_errno;

a3561 2
		save_errno = errno;

d3573 3
a3575 1
			sm_free(vp); /* XXX */
d3577 2
a3578 13
		errno = save_errno - E_LDAPBASE;
		switch (errno)
		{
#ifdef LDAP_SERVER_DOWN
		  case LDAP_SERVER_DOWN:
#endif /* LDAP_SERVER_DOWN */
		  case LDAP_TIMEOUT:
		  case LDAP_UNAVAILABLE:
			/* server disappeared, try reopen on next search */
			ldapmap_close(map);
			break;
		}
		errno = save_errno;
a3579 1
	}
d3591 1
a3591 2
			sm_free(vp); /* XXX */
		*statp = EX_OK;
a3594 4
	/* Did we match anything? */
	if (vp == NULL && !bitset(MF_MATCHONLY, map->map_mflags))
		return NULL;

d3609 1
a3609 1
			sm_free(vp); /* XXX */
d3628 1
d3633 1
a3633 1
	SM_LDAP_STRUCT *lmap;
d3635 1
d3637 1
a3637 1
	STAB *SM_NONVOLATILE s = NULL;
d3639 18
a3656 17
	nbuf = sm_stringf_x("%s%c%d%c%s%c%s%d",
			    (lmap->ldap_host == NULL ? "localhost"
						     : lmap->ldap_host),
			    CONDELSE,
			    lmap->ldap_port,
			    CONDELSE,
			    (lmap->ldap_binddn == NULL ? ""
						       : lmap->ldap_binddn),
			    CONDELSE,
			    (lmap->ldap_secret == NULL ? ""
						       : lmap->ldap_secret),
			    (int) CurrentPid);
	SM_TRY
		s = stab(nbuf, ST_LMAP, ST_ENTER);
	SM_FINALLY
		sm_free(nbuf);
	SM_END_TRY
d3660 84
d3747 1
a3747 1
static struct lamvalues LDAPAuthMethods[] =
d3757 1
a3757 1
static struct ladvalues LDAPAliasDereference[] =
d3766 1
a3766 1
static struct lssvalues LDAPSearchScope[] =
d3779 1
a3779 1
	bool secretread = true;
d3782 1
a3782 1
	SM_LDAP_STRUCT *lmap;
a3785 1
	char ldapfilt[MAXLINE];
d3789 1
a3789 1
	lmap = (SM_LDAP_STRUCT *) map->map_db1;
d3794 2
a3795 2
		/* We need to alloc an SM_LDAP_STRUCT struct */
		lmap = (SM_LDAP_STRUCT *) xalloc(sizeof *lmap);
d3797 1
a3797 1
			sm_ldap_clear(lmap);
a3804 52

	/* Check if setting up an alias or file class LDAP map */
	if (bitset(MF_ALIAS, map->map_mflags))
	{
		/* Comma separate if used as an alias file */
		map->map_coldelim = ',';
		if (*args == '\0')
		{
			int n;
			char *lc;
			char jbuf[MAXHOSTNAMELEN];
			char lcbuf[MAXLINE];

			/* Get $j */
			expand("\201j", jbuf, sizeof jbuf, &BlankEnvelope);
			if (jbuf[0] == '\0')
			{
				(void) sm_strlcpy(jbuf, "localhost",
						  sizeof jbuf);
			}

			lc = macvalue(macid("{sendmailMTACluster}"), CurEnv);
			if (lc == NULL)
				lc = "";
			else
			{
				expand(lc, lcbuf, sizeof lcbuf, CurEnv);
				lc = lcbuf;
			}

			n = sm_snprintf(ldapfilt, sizeof ldapfilt,
					"(&(objectClass=sendmailMTAAliasObject)(sendmailMTAAliasGrouping=aliases)(|(sendmailMTACluster=%s)(sendmailMTAHost=%s))(sendmailMTAKey=%%0))",
					lc, jbuf);
			if (n >= sizeof ldapfilt)
			{
				syserr("%s: Default LDAP string too long",
				       map->map_mname);
				return false;
			}

			/* default args for an alias LDAP entry */
			lmap->ldap_filter = ldapfilt;
			lmap->ldap_attr[0] = "sendmailMTAAliasValue";
			lmap->ldap_attr[1] = NULL;
		}
	}
	else if (bitset(MF_FILECLASS, map->map_mflags))
	{
		/* Space separate if used as a file class file */
		map->map_coldelim = ' ';
	}

a3883 21
		  case 'V':
			if (*++p != '\\')
				lmap->ldap_attrsep = *p;
			else
			{
				switch (*++p)
				{
				  case 'n':
					lmap->ldap_attrsep = '\n';
					break;

				  case 't':
					lmap->ldap_attrsep = '\t';
					break;

				  default:
					lmap->ldap_attrsep = '\\';
				}
			}
			break;

d3918 1
a3918 1
			if (sm_strncasecmp(p, "LDAP_DEREF_", 11) == 0)
d3924 2
a3925 2
				if (sm_strncasecmp(p, lad->lad_name,
						   strlen(lad->lad_name)) == 0)
d3940 1
a3940 1
					syserr("Deref must be [never|always|search|find] (not %s) in map %s",
d3944 1
a3944 1
					return false;
d3953 1
a3953 1
			if (sm_strncasecmp(p, "LDAP_SCOPE_", 11) == 0)
d3959 2
a3960 2
				if (sm_strncasecmp(p, lss->lss_name,
						   strlen(lss->lss_name)) == 0)
d3975 1
a3975 1
					syserr("Scope must be [base|one|sub] (not %s) in map %s",
d3979 1
a3979 1
					return false;
d4025 1
a4025 1
			if (sm_strncasecmp(p, "LDAP_AUTH_", 10) == 0)
d4031 2
a4032 2
				if (sm_strncasecmp(p, lam->lam_name,
						   strlen(lam->lam_name)) == 0)
d4047 1
a4047 1
					syserr("Method for binding must be [none|simple|krbv4] (not %s) in map %s",
d4051 1
a4051 1
					return false;
d4066 1
a4066 1
			secretread = false;
d4120 1
a4120 1
		SM_FILE_T *sfd;
d4150 1
a4150 1
				return false;
d4155 1
a4155 1
			(void) sm_io_close(sfd, SM_TIME_DEFAULT);
d4175 3
a4177 4
			(void) sm_snprintf(m_tmp,
				MAXPATHLEN + LDAPMAP_MAX_PASSWD,
				"KRBTKFILE=%s",
				ldapmap_dequote(lmap->ldap_secret));
d4184 1
a4184 2
			return false;
			/* NOTREACHED */
d4214 1
a4214 1
		return true;
d4223 1
a4223 1
			return false;
d4250 1
a4250 1
				return false;
d4259 1
a4259 1
	return true;
d4262 38
d4308 1
a4314 1
	STAB *class;
d4319 2
a4320 2
		LDAPDefaults = (SM_LDAP_STRUCT *) xalloc(sizeof *LDAPDefaults);
	sm_ldap_clear(LDAPDefaults);
a4322 9

	/* look up the class */
	class = stab("ldap", ST_MAPCLASS, ST_FIND);
	if (class == NULL)
	{
		syserr("readcf: LDAPDefaultSpec: class ldap not available");
		return;
	}
	map.map_class = &class->s_mapclass;
a4323 1
	map.map_mname = "O LDAPDefaultSpec";
d4334 10
a4343 2
		SM_FREE_CLR(map.map_app);
		SM_FREE_CLR(map.map_tapp);
d4365 1
a4365 1
#if PH_MAP
d4373 2
a4374 5
/* what version of the ph map code we're running */
static char phmap_id[PH_BUF_SIZE];

/* sendmail version for phmap id string */
extern const char Version[];
d4385 3
a4387 1
	register bool done;
a4388 6
	PH_MAP_STRUCT *pmap = NULL;

	/* initialize version string */
	(void) sm_snprintf(phmap_id, sizeof phmap_id,
			   "sendmail-%s phmap-20010529 libphclient-%s",
			   Version, libphclient_version);
d4395 3
a4397 1
	pmap->ph = NULL;
a4398 1
	pmap->ph_fastclose = 0;
d4450 1
d4456 1
d4472 1
a4472 7
		  case 'v':
			sm_syslog(LOG_WARNING, NULL,
				  "ph_map_parseargs: WARNING: -v option will be removed in a future release - please use -k instead");
			/* intentional fallthrough for backward compatibility */
			/* FALLTHROUGH */

		  case 'k':		/* fields to search for */
d4509 2
d4517 1
a4517 1
		return false;
d4521 1
a4521 1
	return true;
d4524 1
d4529 2
a4530 2
void
ph_map_close(map)
d4533 1
a4536 3
	if (tTd(38, 9))
		sm_dprintf("ph_map_close(%s): pmap->ph_fastclose=%d",
			   map->map_mname, pmap->ph_fastclose);
d4538 11
a4548 2

	if (pmap->ph != NULL)
d4550 2
a4551 3
		ph_set_sendhook(pmap->ph, NULL);
		ph_set_recvhook(pmap->ph, NULL);
		ph_close(pmap->ph, pmap->ph_fastclose);
a4552 1

d4554 1
d4557 3
a4559 6
static jmp_buf  PHTimeout;

/* ARGSUSED */
static void
ph_timeout(unused)
	int unused;
d4561 1
a4561 5
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/
d4563 4
a4566 2
	errno = ETIMEDOUT;
	longjmp(PHTimeout, 1);
d4569 3
d4573 2
a4574 2
ph_map_send_debug(text)
	char *text;
d4576 1
a4576 5
	if (LogLevel > 9)
		sm_syslog(LOG_NOTICE, CurEnv->e_id,
			  "ph_map_send_debug: ==> %s", text);
	if (tTd(38, 20))
		sm_dprintf("ph_map_send_debug: ==> %s\n", text);
d4578 4
d4583 3
a4585 3
static void
ph_map_recv_debug(text)
	char *text;
d4587 6
a4592 5
	if (LogLevel > 10)
		sm_syslog(LOG_NOTICE, CurEnv->e_id,
			  "ph_map_recv_debug: <== %s", text);
	if (tTd(38, 21))
		sm_dprintf("ph_map_recv_debug: <== %s\n", text);
d4594 1
d4604 6
d4611 3
a4613 3
	register SM_EVENT *ev = NULL;
	int save_errno = 0;
	char *hostlist, *host;
d4616 1
a4616 1
		sm_dprintf("ph_map_open(%s)\n", map->map_mname);
d4622 10
a4631 2
		errno = SM_EMAPCANTWRITE;
		return false;
d4638 2
a4639 2
			sm_dprintf("ph_map_open(%s) => DEFERRED\n",
				   map->map_mname);
d4642 3
a4644 3
		**  Unset MF_DEFER here so that map_lookup() returns
		**  a temporary failure using the bogus map and
		**  map->map_tapp instead of the default permanent error.
d4648 1
a4648 1
		return false;
a4651 1
	pmap->ph_fastclose = 0;		/* refresh field for reopen */
a4652 1
	/* try each host in the list */
d4654 2
a4655 3
	for (host = strtok(hostlist, " ");
	     host != NULL;
	     host = strtok(NULL, " "))
d4657 1
a4657 1
		/* set timeout */
d4666 2
a4667 1
						  host);
d4669 3
d4674 1
a4674 1
			ev = sm_setevent(pmap->ph_timeout, ph_timeout, 0);
d4676 7
a4682 5

		/* open connection to server */
		if (!ph_open(&(pmap->ph), host, PH_ROUNDROBIN|PH_DONTID,
			     ph_map_send_debug, ph_map_recv_debug) &&
		    !ph_id(pmap->ph, phmap_id))
d4685 23
a4707 3
				sm_clrevent(ev);
			sm_free(hostlist); /* XXX */
			return true;
d4709 1
a4709 1

d4711 9
d4721 2
a4722 6
		if (ev != NULL)
			sm_clrevent(ev);
		pmap->ph_fastclose = PH_FASTCLOSE;
		ph_map_close(map);
		errno = save_errno;
	}
d4724 3
d4738 2
a4739 2
	sm_free(hostlist); /* XXX */
	return false;
d4746 4
d4757 12
a4768 2
	int i, save_errno = 0;
	register SM_EVENT *ev = NULL;
a4769 1
	char *value = NULL;
d4775 1
a4775 1
	/* set timeout */
d4785 1
d4787 3
d4793 1
a4793 1
		ev = sm_setevent(pmap->ph_timeout, ph_timeout, 0);
d4796 134
a4929 6
	/* perform lookup */
	i = ph_email_resolve(pmap->ph, key, pmap->ph_field_list, &value);
	if (i == -1)
		*pstat = EX_TEMPFAIL;
	else if (i == PH_NOMATCH || i == PH_DATAERR)
		*pstat = EX_UNAVAILABLE;
d4932 1
d4934 1
a4934 1
		sm_clrevent(ev);
d4937 1
a4937 1
	**  Close the connection if the timer popped
d4942 5
a4946 6
	{
		save_errno = errno;
		pmap->ph_fastclose = PH_FASTCLOSE;
		ph_map_close(map);
		errno = save_errno;
	}
d4950 18
d4969 1
a4969 1
			sm_dprintf("ph_map_lookup: %s => %s\n", key, value);
d4972 1
a4972 1
			return map_rewrite(map, key, strlen(key), NULL);
d4974 14
a4987 1
			return map_rewrite(map, value, strlen(value), args);
d4990 3
d4994 45
d5101 1
a5101 1
		if (sm_strncasecmp("LOG_", priority, 4) == 0)
d5105 1
a5105 1
		if (sm_strcasecmp("EMERG", priority) == 0)
d5110 1
a5110 1
		if (sm_strcasecmp("ALERT", priority) == 0)
d5115 1
a5115 1
		if (sm_strcasecmp("CRIT", priority) == 0)
d5120 1
a5120 1
		if (sm_strcasecmp("ERR", priority) == 0)
d5125 1
a5125 1
		if (sm_strcasecmp("WARNING", priority) == 0)
d5130 1
a5130 1
		if (sm_strcasecmp("NOTICE", priority) == 0)
d5135 1
a5135 1
		if (sm_strcasecmp("INFO", priority) == 0)
d5140 1
a5140 1
		if (sm_strcasecmp("DEBUG", priority) == 0)
d5147 1
a5147 1
			return false;
d5150 1
a5150 1
	return true;
d5169 1
a5169 1
			sm_dprintf("syslog_map_lookup(%s (priority %d): %s\n",
d5183 1
a5183 1
#if HESIOD
d5191 1
a5191 1
		sm_dprintf("hes_map_open(%s, %s, %d)\n",
d5197 10
a5206 2
		errno = SM_EMAPCANTWRITE;
		return false;
d5211 1
a5211 1
		return true;
d5215 2
a5216 2
			sm_errstring(errno));
	return false;
d5224 1
a5224 1
		return true;
d5230 1
a5230 1
	return false;
d5244 1
a5244 1
		sm_dprintf("hes_map_lookup(%s, %s)\n", map->map_file, name);
a5249 1
		int save_errno;
d5258 1
a5258 1
		(void) sm_strlcpy(&np[1], name, (sizeof nbuf) - 1);
a5263 1
		save_errno = errno;
d5265 1
a5265 2
			sm_free(np); /* XXX */
		errno = save_errno;
d5276 3
a5278 1
	if (hp == NULL || *hp == NULL)
d5280 1
d5287 1
a5289 1
		  case EMSGSIZE:
a5294 2
		if (hp != NULL)
			hesiod_free_list(HesiodContext, hp);
a5327 21
/*
**  HES_MAP_CLOSE -- free the Hesiod context
*/

void
hes_map_close(map)
	MAP *map;
{
	if (tTd(38, 20))
		sm_dprintf("hes_map_close(%s)\n", map->map_file);

# ifdef HESIOD_INIT
	/* Free the hesiod context */
	if (HesiodContext != NULL)
	{
		hesiod_end(HesiodContext);
		HesiodContext = NULL;
	}
# endif /* HESIOD_INIT */
}

d5348 1
a5348 1
		sm_dprintf("ni_map_open(%s, %s, %d)\n",
d5358 4
a5361 8
	if (map->map_coldelim == '\0')
	{
		if (bitset(MF_ALIAS, map->map_mflags))
			map->map_coldelim = ',';
		else if (bitset(MF_FILECLASS, map->map_mflags))
			map->map_coldelim = ' ';
	}
	return true;
d5380 1
a5380 1
		sm_dprintf("ni_map_lookup(%s, %s)\n", map->map_mname, name);
d5388 5
a5392 8
	SM_TRY
		if (bitset(MF_MATCHONLY, map->map_mflags))
			res = map_rewrite(map, name, strlen(name), NULL);
		else
			res = map_rewrite(map, propval, strlen(propval), av);
	SM_FINALLY
		sm_free(propval);
	SM_END_TRY
d5408 1
a5408 1
		sm_dprintf("ni_getcanonname(%s)\n", name);
d5410 1
a5410 1
	if (sm_strlcpy(nbuf, name, sizeof nbuf) >= sizeof nbuf)
d5413 1
a5413 1
		return false;
d5415 1
a5415 1
	(void) shorten_hostname(nbuf);
d5421 1
a5421 1
		return false;
d5430 1
a5430 1
		return false;
d5437 102
a5538 1
	if (sm_strlcpy(name, vptr, hbsize) >= hbsize)
d5540 77
a5616 3
		sm_free(vptr);
		*statp = EX_UNAVAILABLE;
		return true;
d5618 13
a5630 3
	sm_free(vptr);
	*statp = EX_OK;
	return false;
d5632 1
d5656 1
a5656 1
		sm_dprintf("text_map_open(%s, %s, %d)\n",
d5663 1
a5663 1
		return false;
d5670 1
a5670 1
		return false;
d5677 1
a5677 1
		return false;
d5692 1
a5692 1
			sm_dprintf("\tunsafe map file: %d\n", i);
d5697 1
a5697 1
		return false;
d5709 1
a5709 1
			return false;
d5723 1
a5723 1
			return false;
d5730 1
a5730 1
		sm_dprintf("text_map_open(%s, %s): delimiter = ",
d5733 1
a5733 1
			sm_dprintf("(white space)\n");
d5735 1
a5735 1
			sm_dprintf("%c\n", map->map_coldelim);
d5739 1
a5739 1
	return true;
d5757 1
a5757 1
	SM_FILE_T *f;
d5766 1
a5766 1
	found_it = false;
d5768 1
a5768 1
		sm_dprintf("text_map_lookup(%s, %s)\n", map->map_mname,  name);
d5772 1
a5772 1
		buflen = sizeof search_key - 1;	/* XXX just cut if off? */
d5787 1
a5787 1
	while (sm_io_fgets(f, SM_TIME_DEFAULT, linebuf, MAXLINE) != NULL)
d5798 1
a5798 1
		if (p != NULL && sm_strcasecmp(search_key, p) == 0)
d5800 1
a5800 1
			found_it = true;
d5804 1
a5804 1
	(void) sm_io_close(f, SM_TIME_DEFAULT);
d5835 1
a5835 2
	char *dot;
	SM_FILE_T *f;
d5841 1
a5841 1
		sm_dprintf("text_getcanonname(%s)\n", name);
d5843 1
a5843 1
	if (sm_strlcpy(nbuf, name, sizeof nbuf) >= sizeof nbuf)
d5846 1
a5846 1
		return false;
d5848 2
a5849 1
	dot = shorten_hostname(nbuf);
d5851 1
a5851 2
	f = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, HostsFile, SM_IO_RDONLY,
		       NULL);
d5855 1
a5855 1
		return false;
d5857 2
a5858 3
	found = false;
	while (!found &&
		sm_io_fgets(f, SM_TIME_DEFAULT, linebuf, MAXLINE) != NULL)
d5865 1
a5865 2
			found = extract_canonname(nbuf, dot, linebuf,
						  cbuf, sizeof cbuf);
d5867 1
a5867 1
	(void) sm_io_close(f, SM_TIME_DEFAULT);
d5871 1
a5871 1
		return false;
d5874 1
a5874 1
	if (sm_strlcpy(name, cbuf, hbsize) >= hbsize)
d5876 3
a5878 2
		*statp = EX_UNAVAILABLE;
		return false;
d5880 2
a5881 2
	*statp = EX_OK;
	return true;
d5903 1
a5903 1
		sm_dprintf("stab_lookup(%s, %s)\n",
d5944 1
a5944 1
	SM_FILE_T *af;
d5949 1
a5949 1
		sm_dprintf("stab_map_open(%s, %s, %d)\n",
d5956 1
a5956 1
		return false;
d5966 2
a5967 2
		return false;
	readaliases(map, af, false, false);
d5969 1
a5969 1
	if (fstat(sm_io_getinfo(af, SM_IO_WHAT_FD, NULL), &st) >= 0)
d5971 1
a5971 1
	(void) sm_io_close(af, SM_TIME_DEFAULT);
d5973 1
a5973 1
	return true;
d5994 1
a5994 1
		sm_dprintf("impl_map_lookup(%s, %s)\n",
d5997 1
a5997 1
#if NEWDB
d6001 1
a6001 1
#if NDBM
d6019 1
a6019 1
		sm_dprintf("impl_map_store(%s, %s, %s)\n",
d6021 1
a6021 1
#if NEWDB
d6025 1
a6025 1
#if NDBM
d6042 1
a6042 1
		sm_dprintf("impl_map_open(%s, %s, %d)\n",
d6046 1
a6046 1
#if NEWDB
d6053 1
a6053 1
			return true;
d6058 1
a6058 1
#if NDBM
d6062 1
a6062 1
		return true;
d6081 1
a6081 1
		return false;
d6094 1
a6094 1
		sm_dprintf("impl_map_close(%s, %s, %lx)\n",
d6096 1
a6096 1
#if NEWDB
d6104 1
a6104 1
#if NDBM
d6130 1
a6130 1
		sm_dprintf("user_map_open(%s, %d)\n",
d6137 10
a6146 2
		errno = SM_EMAPCANTWRITE;
		return false;
d6151 1
a6151 1
	else if (sm_strcasecmp(map->map_valcolnm, "name") == 0)
d6153 1
a6153 1
	else if (sm_strcasecmp(map->map_valcolnm, "passwd") == 0)
d6155 1
a6155 1
	else if (sm_strcasecmp(map->map_valcolnm, "uid") == 0)
d6157 1
a6157 1
	else if (sm_strcasecmp(map->map_valcolnm, "gid") == 0)
d6159 1
a6159 1
	else if (sm_strcasecmp(map->map_valcolnm, "gecos") == 0)
d6161 1
a6161 1
	else if (sm_strcasecmp(map->map_valcolnm, "dir") == 0)
d6163 1
a6163 1
	else if (sm_strcasecmp(map->map_valcolnm, "shell") == 0)
d6169 1
a6169 1
		return false;
d6171 1
a6171 1
	return true;
d6187 1
a6188 1
	SM_MBDB_T user;
d6191 1
a6191 1
		sm_dprintf("user_map_lookup(%s, %s)\n",
d6194 2
a6195 2
	*statp = finduser(key, &fuzzy, &user);
	if (*statp != EX_OK)
d6208 1
a6208 1
			rwval = user.mbdb_name;
d6212 1
a6212 1
			rwval = "x";	/* passwd no longer supported */
d6216 1
a6216 2
			(void) sm_snprintf(buf, sizeof buf, "%d",
					   (int) user.mbdb_uid);
d6221 1
a6221 2
			(void) sm_snprintf(buf, sizeof buf, "%d",
					   (int) user.mbdb_gid);
d6226 1
a6226 1
			rwval = user.mbdb_fullname;
d6230 1
a6230 1
			rwval = user.mbdb_homedir;
d6234 1
a6234 1
			rwval = user.mbdb_shell;
d6266 1
a6266 1
		sm_dprintf("prog_map_lookup(%s, %s) %s\n",
d6273 1
a6273 1
		(void) sm_strlcpy(buf, map->map_rebuild, sizeof buf);
d6285 1
a6285 1
		sm_dprintf("prog_open:");
d6287 2
a6288 2
			sm_dprintf(" %s", argv[i]);
		sm_dprintf("\n");
d6290 1
a6290 1
	(void) sm_blocksignal(SIGCHLD);
d6296 1
a6296 1
			       map->map_mname, sm_errstring(errno));
d6298 2
a6299 2
			sm_dprintf("prog_map_lookup(%s) failed (%s) -- closing",
				   map->map_mname, sm_errstring(errno));
d6308 1
a6308 1
		       map->map_mname, sm_errstring(errno));
d6314 2
a6315 2
			sm_dprintf("prog_map_lookup(%s): empty answer\n",
				   map->map_mname);
d6329 1
a6329 1
			rval = map_rewrite(map, buf, strlen(buf), av);
d6340 1
a6340 1
	(void) sm_releasesignal(SIGCHLD);
d6346 1
a6346 1
		       map->map_mname, sm_errstring(errno));
d6358 1
a6358 1
		       map->map_mname, status);
d6378 1
a6378 1
**	opened on demand.
d6393 1
a6393 1
		sm_dprintf("seq_map_parse(%s, %s)\n", map->map_mname, ap);
d6422 1
a6422 1
		else if (maxmap >= MAXMAPSTACK)
d6434 1
a6434 1
	return true;
d6437 1
d6459 1
a6459 1
		sm_dprintf("switch_map_open(%s, %s, %d)\n",
d6466 1
a6466 1
		sm_dprintf("\tswitch_map_find => %d\n", nmaps);
d6468 1
a6468 1
			sm_dprintf("\t\t%s\n", maptype[mapno]);
d6471 1
a6471 1
		return false;
d6480 2
a6481 2
		(void) sm_strlcpyn(nbuf, sizeof nbuf, 3,
				   map->map_mname, ".", maptype[mapno]);
d6492 3
a6494 4
				sm_dprintf("\tmap_stack[%d] = %s:%s\n",
					   mapno,
					   s->s_map.map_class->map_cname,
					   nbuf);
d6497 1
a6497 1
	return true;
d6500 1
a6500 1
#if 0
d6512 1
a6512 1
		sm_dprintf("seq_map_close(%s)\n", map->map_mname);
a6519 1
		mm->map_mflags |= MF_CLOSING;
d6521 1
a6521 1
		mm->map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
d6524 1
a6524 1
#endif /* 0 */
d6539 1
a6539 1
	bool tempfail = false;
d6542 1
a6542 1
		sm_dprintf("seq_map_lookup(%s, %s)\n", map->map_mname, key);
d6569 1
a6569 1
			tempfail = true;
d6581 1
d6595 1
a6595 1
		sm_dprintf("seq_map_store(%s, %s, %s)\n",
d6621 1
a6621 1
	return true;
d6653 1
d6671 3
a6673 3
	"bogus-map",		NULL,			0,
	NULL,			bogus_map_lookup,	null_map_store,
	null_map_open,		null_map_close,
d6689 1
a6689 1
		sm_dprintf("macro_map_lookup(%s, %s)\n", map->map_mname,
d6694 1
a6694 1
	    (mid = macid(name)) == 0)
d6701 1
a6701 1
		macdefine(&CurEnv->e_macro, A_PERM, mid, NULL);
d6703 1
a6703 1
		macdefine(&CurEnv->e_macro, A_TEMP, mid, av[1]);
d6712 1
a6712 1
#if MAP_REGEX
d6717 1
d6719 1
d6741 1
a6741 1
	bool lastone = false;
d6756 1
a6756 1
				lastone = true;
d6793 1
a6793 1
	static char defdstr[] = { (char) DEFAULT_DELIM, '\0' };
d6796 1
a6796 1
		sm_dprintf("regex_map_init: mapname '%s', args '%s'\n",
d6800 1
d6802 1
d6859 1
a6859 1
		sm_dprintf("regex_map_init: compile '%s' 0x%x\n", p, pflags);
d6867 5
a6871 5
			 errbuf, sizeof errbuf);
		syserr("pattern-compile-error: %s", errbuf);
		sm_free(map_p->regex_pattern_buf); /* XXX */
		sm_free(map_p); /* XXX */
		return false;
d6890 1
a6890 1
			sm_dprintf("regex_map_init: nr of substrings %d\n",
d6895 4
a6898 4
			syserr("too many substrings, %d max", MAX_MATCH);
			sm_free(map_p->regex_pattern_buf); /* XXX */
			sm_free(map_p); /* XXX */
			return false;
d6905 1
a6905 1
				return false;
d6909 1
a6911 1
			/* set default fields */
d6921 1
a6921 1
			sm_dprintf("regex_map_init: subfields");
d6923 2
a6924 2
				sm_dprintf(" %d", *ip);
			sm_dprintf("\n");
d6927 3
a6929 2
	map->map_db1 = (ARBPTR_T) map_p;	/* dirty hack */
	return true;
d6942 1
a6942 1
		return map_rewrite(map, s, slen, av);
d6960 1
a6960 1
		sm_dprintf("regex_map_lookup: key '%s'\n", name);
d6962 1
a6962 1
			sm_dprintf("regex_map_lookup: arg '%s'\n", *cpp);
d6973 1
a6973 1
			return regex_map_rewrite(map, "", (size_t) 0, av);
d6985 1
a6985 1
		bool first = true;
d6987 1
a6987 1
		bool quotemode = false, bslashmode = false;
d7019 2
a7020 1
				first = false;
d7035 1
a7035 1
						bslashmode = false;
d7042 1
a7042 1
					else switch (*dp++ = *sp)
d7044 2
a7045 2
					  case '\\':
						bslashmode = true;
d7048 1
a7048 1
					  case '(':
d7052 1
a7052 1
					  case ')':
d7056 1
a7056 1
					  case '<':
d7060 1
a7060 1
					  case '>':
d7064 1
a7064 1
					  case ' ':
d7068 1
a7068 1
					  case '"':
d7094 1
a7094 1
#if MAP_NSD
d7102 3
a7104 3
	ns_map_t		*map;		/* XXX ns_ ? */
	char			*mapname;
	struct ns_map_list	*next;
d7147 1
a7147 1
		sm_dprintf("nsd_map_lookup(%s, %s)\n", map->map_mname, name);
d7151 1
a7151 1
		buflen = sizeof keybuf - 1;	/* XXX simply cut off? */
d7161 1
a7161 1
			sm_dprintf("nsd_map_t_find failed\n");
d7171 1
a7171 5
	if (r == NS_BADREQ
# ifdef NS_NOPERM
	    || r == NS_NOPERM
# endif /* NS_NOPERM */
	    )
d7201 1
a7201 1
	bool res = false;
d7208 1
a7208 1
		sm_dprintf("arith_map_lookup: key '%s'\n", name);
d7210 1
a7210 1
			sm_dprintf("arith_map_lookup: arg '%s'\n", *cpp);
d7213 1
a7213 1
	boolres = false;
a7221 1

d7228 1
a7228 1
		switch (*name)
d7230 1
d7244 2
d7266 1
a7266 1
			boolres = true;
d7271 1
a7271 1
			boolres = true;
d7284 1
a7284 2
			(void) sm_snprintf(result, sizeof result,
				res ? "TRUE" : "FALSE");
d7286 1
a7286 1
			(void) sm_snprintf(result, sizeof result, "%ld", r);
@


