head	1.33;
access;
symbols
	OPENBSD_5_6:1.32.0.6
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.30.0.2
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.29.0.6
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.4
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.28.0.12
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.10
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.6
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.8
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.4
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.27.0.4
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.26.0.2
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.24.0.4
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.24.0.2
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.18.0.4
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2014.09.17.18.49.52;	author matthieu;	state dead;
branches;
next	1.32;
commitid	M7i5giHIoz3DMlTU;

1.32
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.30;

1.30
date	2012.12.26.11.44.12;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2011.05.17.15.54.23;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2007.04.04.14.43.49;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.22.18.43.55;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2005.04.08.16.00.51;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.16.00.21.31;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2004.09.18.04.08.35;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2004.06.24.03.59.27;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.19.01.41.13;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.17.17.31.40;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.29.19.44.00;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.03.17.31.21;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.01.19.59.23;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.12.09.00.45.36;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.15.02.23.36;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.26.04.48.55;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.03.17.25.47;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.18.00.49.28;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.10.01.17.18.30;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.11.19.02.50;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.21.16.31.45;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.01.01.01.41;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.29.01.31.15;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.28.02.43.54;	author millert;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.01.15.21.09.09;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.07.19.20.42;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.46;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.46;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.15;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.50;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.31.38;	author miod;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.31.01.47.57;	author jason;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Bye.
@
text
@/*
 * Copyright (c) 1999-2009, 2012, 2013 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>

SM_RCSID("@@(#)$Sendmail: milter.c,v 8.281 2013/11/22 20:51:56 ca Exp $")

#if MILTER
# include <sm/sendmail.h>
# include <libmilter/mfapi.h>
# include <libmilter/mfdef.h>

# include <errno.h>
# include <sm/time.h>
# include <sys/uio.h>

# if NETINET || NETINET6
#  include <arpa/inet.h>
#  if MILTER_NO_NAGLE
#   include <netinet/tcp.h>
#  endif /* MILTER_NO_NAGLE */
# endif /* NETINET || NETINET6 */

# include <sm/fdset.h>

static void	milter_connect_timeout __P((int));
static void	milter_error __P((struct milter *, ENVELOPE *));
static int	milter_open __P((struct milter *, bool, ENVELOPE *));
static void	milter_parse_timeouts __P((char *, struct milter *));
static char	*milter_sysread __P((struct milter *, char *, ssize_t, time_t,
			ENVELOPE *, const char *));
static char	*milter_read __P((struct milter *, char *, ssize_t *, time_t,
			ENVELOPE *, const char *));
static char	*milter_write __P((struct milter *, int, char *, ssize_t,
			time_t, ENVELOPE *, const char *));
static char	*milter_send_command __P((struct milter *, int, void *,
			ssize_t, ENVELOPE *, char *, const char *));
static char	*milter_command __P((int, void *, ssize_t, int,
			ENVELOPE *, char *, const char *, bool));
static char	*milter_body __P((struct milter *, ENVELOPE *, char *));
static int	milter_reopen_df __P((ENVELOPE *));
static int	milter_reset_df __P((ENVELOPE *));
static void	milter_quit_filter __P((struct milter *, ENVELOPE *));
static void	milter_abort_filter __P((struct milter *, ENVELOPE *));
static void	milter_send_macros __P((struct milter *, char **, int,
			ENVELOPE *));
static int	milter_negotiate __P((struct milter *, ENVELOPE *,
			milters_T *));
static void	milter_per_connection_check __P((ENVELOPE *));
static char	*milter_headers __P((struct milter *, ENVELOPE *, char *));
static void	milter_addheader __P((struct milter *, char *, ssize_t,
			ENVELOPE *));
static void	milter_insheader __P((struct milter *, char *, ssize_t,
			ENVELOPE *));
static void	milter_changeheader __P((struct milter *, char *, ssize_t,
			ENVELOPE *));
static void	milter_chgfrom __P((char *, ssize_t, ENVELOPE *));
static void	milter_addrcpt __P((char *, ssize_t, ENVELOPE *));
static void	milter_addrcpt_par __P((char *, ssize_t, ENVELOPE *));
static void	milter_delrcpt __P((char *, ssize_t, ENVELOPE *));
static int	milter_replbody __P((char *, ssize_t, bool, ENVELOPE *));
static int	milter_set_macros __P((char *, char **, char *, int));


/* milter states */
# define SMFS_CLOSED		'C'	/* closed for all further actions */
# define SMFS_OPEN		'O'	/* connected to remote milter filter */
# define SMFS_INMSG		'M'	/* currently servicing a message */
# define SMFS_DONE		'D'	/* done with current message */
# define SMFS_CLOSABLE		'Q'	/* done with current connection */
# define SMFS_ERROR		'E'	/* error state */
# define SMFS_READY		'R'	/* ready for action */
# define SMFS_SKIP		'S'	/* skip body */

/*
**  MilterMacros contains the milter macros for each milter and each stage.
**  indices are (in order): stages, milter-index, macro
**  milter-index == 0: "global" macros (not for a specific milter).
*/

static char *MilterMacros[SMFIM_LAST + 1][MAXFILTERS + 1][MAXFILTERMACROS + 1];
static size_t MilterMaxDataSize = MILTER_MAX_DATA_SIZE;

# define MILTER_CHECK_DONE_MSG() \
	if (*state == SMFIR_REPLYCODE || \
	    *state == SMFIR_REJECT || \
	    *state == SMFIR_DISCARD || \
	    *state == SMFIR_TEMPFAIL) \
	{ \
		/* Abort the filters to let them know we are done with msg */ \
		milter_abort(e); \
	}

/* set state in case of an error */
# define MILTER_SET_STATE	\
	if (bitnset(SMF_TEMPFAIL, m->mf_flags)) \
		*state = SMFIR_TEMPFAIL; \
	else if (bitnset(SMF_TEMPDROP, m->mf_flags)) \
		*state = SMFIR_SHUTDOWN; \
	else if (bitnset(SMF_REJECT, m->mf_flags)) \
		*state = SMFIR_REJECT

/* flow through code maybe using continue; don't wrap in do {} while */
# define MILTER_CHECK_ERROR(initial, action) \
	if (!initial && tTd(71, 100)) \
	{ \
		if (e->e_quarmsg == NULL) \
		{ \
			e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, \
							 "filter failure"); \
			macdefine(&e->e_macro, A_PERM, macid("{quarantine}"), \
				  e->e_quarmsg); \
		} \
	} \
	else if (tTd(71, 101)) \
	{ \
		if (e->e_quarmsg == NULL) \
		{ \
			e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, \
							 "filter failure"); \
			macdefine(&e->e_macro, A_PERM, macid("{quarantine}"), \
				  e->e_quarmsg); \
		} \
	} \
	else MILTER_SET_STATE;	\
	else \
		action;

# define MILTER_CHECK_REPLYCODE(default) \
	if (response == NULL || \
	    strlen(response) + 1 != (size_t) rlen || \
	    rlen < 3 || \
	    (response[0] != '4' && response[0] != '5') || \
	    !isascii(response[1]) || !isdigit(response[1]) || \
	    !isascii(response[2]) || !isdigit(response[2])) \
	{ \
		if (response != NULL) \
			sm_free(response); /* XXX */ \
		response = newstr(default); \
	} \
	else \
	{ \
		char *ptr = response; \
 \
		/* Check for unprotected %'s in the string */ \
		while (*ptr != '\0') \
		{ \
			if (*ptr == '%' && *++ptr != '%') \
			{ \
				sm_free(response); /* XXX */ \
				response = newstr(default); \
				break; \
			} \
			ptr++; \
		} \
	}

# define MILTER_DF_ERROR(msg) \
{ \
	int save_errno = errno; \
 \
	if (tTd(64, 5)) \
	{ \
		sm_dprintf(msg, dfname, sm_errstring(save_errno)); \
		sm_dprintf("\n"); \
	} \
	if (MilterLogLevel > 0) \
		sm_syslog(LOG_ERR, e->e_id, msg, dfname, sm_errstring(save_errno)); \
	if (SuperSafe == SAFE_REALLY) \
	{ \
		if (e->e_dfp != NULL) \
		{ \
			(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT); \
			e->e_dfp = NULL; \
		} \
		e->e_flags &= ~EF_HAS_DF; \
	} \
	errno = save_errno; \
}

/*
**  MILTER_TIMEOUT -- make sure socket is ready in time
**
**	Parameters:
**		routine -- routine name for debug/logging
**		secs -- number of seconds in timeout
**		write -- waiting to read or write?
**		started -- whether this is part of a previous sequence
**
**	Assumes 'm' is a milter structure for the current socket.
*/

# define MILTER_TIMEOUT(routine, secs, write, started, function) \
{ \
	int ret; \
	int save_errno; \
	fd_set fds; \
	struct timeval tv; \
 \
	if (SM_FD_SETSIZE > 0 && m->mf_sock >= SM_FD_SETSIZE) \
	{ \
		if (tTd(64, 5)) \
			sm_dprintf("milter_%s(%s): socket %d is larger than FD_SETSIZE %d\n", \
				   (routine), m->mf_name, m->mf_sock, \
				   SM_FD_SETSIZE); \
		if (MilterLogLevel > 0) \
			sm_syslog(LOG_ERR, e->e_id, \
				  "Milter (%s): socket(%s) %d is larger than FD_SETSIZE %d", \
				  m->mf_name, (routine), m->mf_sock, \
				  SM_FD_SETSIZE); \
		milter_error(m, e); \
		return NULL; \
	} \
 \
	do \
	{ \
		FD_ZERO(&fds); \
		SM_FD_SET(m->mf_sock, &fds); \
		tv.tv_sec = (secs); \
		tv.tv_usec = 0; \
		ret = select(m->mf_sock + 1, \
			     (write) ? NULL : &fds, \
			     (write) ? &fds : NULL, \
			     NULL, &tv); \
	} while (ret < 0 && errno == EINTR); \
 \
	switch (ret) \
	{ \
	  case 0: \
		if (tTd(64, 5)) \
			sm_dprintf("milter_%s(%s): timeout, where=%s\n", \
				(routine), m->mf_name, (function)); \
		if (MilterLogLevel > 0) \
			sm_syslog(LOG_ERR, e->e_id, \
				  "Milter (%s): timeout %s data %s, where=%s", \
				  m->mf_name, \
				  started ? "during" : "before", \
				  (routine), (function)); \
		milter_error(m, e); \
		return NULL; \
 \
	  case -1: \
		save_errno = errno; \
		if (tTd(64, 5)) \
			sm_dprintf("milter_%s(%s): select: %s\n", (routine), \
				   m->mf_name, sm_errstring(save_errno)); \
		if (MilterLogLevel > 0) \
		{ \
			sm_syslog(LOG_ERR, e->e_id, \
				  "Milter (%s): select(%s): %s", \
				  m->mf_name, (routine), \
				  sm_errstring(save_errno)); \
		} \
		milter_error(m, e); \
		return NULL; \
 \
	  default: \
		if (SM_FD_ISSET(m->mf_sock, &fds)) \
			break; \
		if (tTd(64, 5)) \
			sm_dprintf("milter_%s(%s): socket not ready\n", \
				(routine), m->mf_name); \
		if (MilterLogLevel > 0) \
		{ \
			sm_syslog(LOG_ERR, e->e_id, \
				  "Milter (%s): socket(%s) not ready", \
				  m->mf_name, (routine)); \
		} \
		milter_error(m, e); \
		return NULL; \
	} \
}

/*
**  Low level functions
*/

/*
**  MILTER_READ -- read from a remote milter filter
**
**	Parameters:
**		m -- milter to read from.
**		cmd -- return param for command read.
**		rlen -- return length of response string.
**		to -- timeout in seconds.
**		e -- current envelope.
**
**	Returns:
**		response string (may be NULL)
*/

static char *
milter_sysread(m, buf, sz, to, e, where)
	struct milter *m;
	char *buf;
	ssize_t sz;
	time_t to;
	ENVELOPE *e;
	const char *where;
{
	time_t readstart = 0;
	ssize_t len, curl;
	bool started = false;

	curl = 0;

	if (to > 0)
		readstart = curtime();

	for (;;)
	{
		if (to > 0)
		{
			time_t now;

			now = curtime();
			if (now - readstart >= to)
			{
				if (tTd(64, 5))
					sm_dprintf("milter_sys_read (%s): timeout %s data read in %s",
						  m->mf_name,
						  started ? "during" : "before",
						  where);
				if (MilterLogLevel > 0)
					sm_syslog(LOG_ERR, e->e_id,
						  "Milter (%s): timeout %s data read in %s",
						  m->mf_name,
						  started ? "during" : "before",
						  where);
				milter_error(m, e);
				return NULL;
			}
			to -= now - readstart;
			readstart = now;
			MILTER_TIMEOUT("read", to, false, started, where);
		}

		len = read(m->mf_sock, buf + curl, sz - curl);

		if (len < 0)
		{
			int save_errno = errno;

			if (tTd(64, 5))
				sm_dprintf("milter_sys_read(%s): read returned %ld: %s\n",
					m->mf_name, (long) len,
					sm_errstring(save_errno));
			if (MilterLogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "Milter (%s): read returned %ld: %s",
					  m->mf_name, (long) len,
					  sm_errstring(save_errno));
			milter_error(m, e);
			return NULL;
		}

		started = true;
		curl += len;
		if (len == 0 || curl >= sz)
			break;

	}

	if (curl != sz)
	{
		if (tTd(64, 5))
			sm_dprintf("milter_sys_read(%s): cmd read returned %ld, expecting %ld\n",
				m->mf_name, (long) curl, (long) sz);
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_sys_read(%s): cmd read returned %ld, expecting %ld",
				  m->mf_name, (long) curl, (long) sz);
		milter_error(m, e);
		return NULL;
	}
	return buf;
}

static char *
milter_read(m, cmd, rlen, to, e, where)
	struct milter *m;
	char *cmd;
	ssize_t *rlen;
	time_t to;
	ENVELOPE *e;
	const char *where;
{
	time_t readstart = 0;
	ssize_t expl;
	mi_int32 i;
# if MILTER_NO_NAGLE && defined(TCP_CORK)
	int cork = 0;
# endif /* MILTER_NO_NAGLE && defined(TCP_CORK) */
	char *buf;
	char data[MILTER_LEN_BYTES + 1];

	if (m->mf_sock < 0)
	{
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_read(%s): socket closed, where=%s",
				  m->mf_name, where);
		milter_error(m, e);
		return NULL;
	}

	*rlen = 0;
	*cmd = '\0';

	if (to > 0)
		readstart = curtime();

# if MILTER_NO_NAGLE && defined(TCP_CORK)
	setsockopt(m->mf_sock, IPPROTO_TCP, TCP_CORK, (char *)&cork,
		   sizeof(cork));
# endif /* MILTER_NO_NAGLE && defined(TCP_CORK) */

	if (milter_sysread(m, data, sizeof(data), to, e, where) == NULL)
		return NULL;

# if MILTER_NO_NAGLE && defined(TCP_CORK)
	cork = 1;
	setsockopt(m->mf_sock, IPPROTO_TCP, TCP_CORK, (char *)&cork,
		   sizeof(cork));
# endif /* MILTER_NO_NAGLE && defined(TCP_CORK) */

	/* reset timeout */
	if (to > 0)
	{
		time_t now;

		now = curtime();
		if (now - readstart >= to)
		{
			if (tTd(64, 5))
				sm_dprintf("milter_read(%s): timeout before data read, where=%s\n",
					m->mf_name, where);
			if (MilterLogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "Milter read(%s): timeout before data read, where=%s",
					  m->mf_name, where);
			milter_error(m, e);
			return NULL;
		}
		to -= now - readstart;
	}

	*cmd = data[MILTER_LEN_BYTES];
	data[MILTER_LEN_BYTES] = '\0';
	(void) memcpy(&i, data, MILTER_LEN_BYTES);
	expl = ntohl(i) - 1;

	if (tTd(64, 25))
		sm_dprintf("milter_read(%s): expecting %ld bytes\n",
			m->mf_name, (long) expl);

	if (expl < 0)
	{
		if (tTd(64, 5))
			sm_dprintf("milter_read(%s): read size %ld out of range, where=%s\n",
				m->mf_name, (long) expl, where);
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_read(%s): read size %ld out of range, where=%s",
				  m->mf_name, (long) expl, where);
		milter_error(m, e);
		return NULL;
	}

	if (expl == 0)
		return NULL;

	buf = (char *) xalloc(expl);

	if (milter_sysread(m, buf, expl, to, e, where) == NULL)
	{
		sm_free(buf); /* XXX */
		return NULL;
	}

	if (tTd(64, 50))
		sm_dprintf("milter_read(%s): Returning %*s\n",
			m->mf_name, (int) expl, buf);
	*rlen = expl;
	return buf;
}

/*
**  MILTER_WRITE -- write to a remote milter filter
**
**	Parameters:
**		m -- milter to read from.
**		cmd -- command to send.
**		buf -- optional command data.
**		len -- length of buf.
**		to -- timeout in seconds.
**		e -- current envelope.
**
**	Returns:
**		buf if successful, NULL otherwise
**		Not actually used anywhere but function prototype
**			must match milter_read()
*/

static char *
milter_write(m, cmd, buf, len, to, e, where)
	struct milter *m;
	int cmd;
	char *buf;
	ssize_t len;
	time_t to;
	ENVELOPE *e;
	const char *where;
{
	ssize_t sl, i;
	int num_vectors;
	mi_int32 nl;
	char command = (char) cmd;
	char data[MILTER_LEN_BYTES + 1];
	bool started = false;
	struct iovec vector[2];

	/*
	**  At most two buffers will be written, though
	**  only one may actually be used (see num_vectors).
	**  The first is the size/command and the second is the command data.
	*/

	if (len < 0 || len > MilterMaxDataSize)
	{
		if (tTd(64, 5))
		{
			sm_dprintf("milter_write(%s): length %ld out of range, cmd=%c\n",
				m->mf_name, (long) len, command);
			sm_dprintf("milter_write(%s): buf=%s\n",
				m->mf_name, str2prt(buf));
		}
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_write(%s): length %ld out of range, cmd=%c",
				  m->mf_name, (long) len, command);
		milter_error(m, e);
		return NULL;
	}
	if (m->mf_sock < 0)
	{
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_write(%s): socket closed",
				  m->mf_name);
		milter_error(m, e);
		return NULL;
	}

	if (tTd(64, 20))
		sm_dprintf("milter_write(%s): cmd %c, len %ld\n",
			   m->mf_name, command, (long) len);

	nl = htonl(len + 1);	/* add 1 for the command char */
	(void) memcpy(data, (char *) &nl, MILTER_LEN_BYTES);
	data[MILTER_LEN_BYTES] = command;
	sl = MILTER_LEN_BYTES + 1;

	/* set up the vector for the size / command */
	vector[0].iov_base = (void *) data;
	vector[0].iov_len  = sl;

	/*
	**  Determine if there is command data.  If so, there will be two
	**  vectors.  If not, there will be only one.  The vectors are set
	**  up here and 'num_vectors' and 'sl' are set appropriately.
	*/

	/* NOTE:  len<0 has already been checked for.  Pedantic */
	if (len <= 0 || buf == NULL)
	{
		/* There is no command data -- only a size / command data */
		num_vectors = 1;
	}
	else
	{
		/*
		**  There is both size / command and command data.
		**  Set up the vector for the command data.
		*/

		num_vectors = 2;
		sl += len;
		vector[1].iov_base = (void *) buf;
		vector[1].iov_len  = len;

		if (tTd(64, 50))
			sm_dprintf("milter_write(%s): Sending %*s\n",
				   m->mf_name, (int) len, buf);
	}

	if (to > 0)
		MILTER_TIMEOUT("write", to, true, started, where);

	/* write the vector(s) */
	i = writev(m->mf_sock, vector, num_vectors);
	if (i != sl)
	{
		int save_errno = errno;

		if (tTd(64, 5))
			sm_dprintf("milter_write(%s): write(%c) returned %ld, expected %ld: %s\n",
				   m->mf_name, command, (long) i, (long) sl,
				   sm_errstring(save_errno));
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): write(%c) returned %ld, expected %ld: %s",
				  m->mf_name, command, (long) i, (long) sl,
				  sm_errstring(save_errno));
		milter_error(m, e);
		return NULL;
	}
	return buf;
}

/*
**  Utility functions
*/

/*
**  MILTER_OPEN -- connect to remote milter filter
**
**	Parameters:
**		m -- milter to connect to.
**		parseonly -- parse but don't connect.
**		e -- current envelope.
**
**	Returns:
**		connected socket if successful && !parseonly,
**		0 upon parse success if parseonly,
**		-1 otherwise.
*/

static jmp_buf	MilterConnectTimeout;

static int
milter_open(m, parseonly, e)
	struct milter *m;
	bool parseonly;
	ENVELOPE *e;
{
	int sock = 0;
	SOCKADDR_LEN_T addrlen = 0;
	int addrno = 0;
	int save_errno;
	char *p;
	char *colon;
	char *at;
	struct hostent *hp = NULL;
	SOCKADDR addr;

	if (m->mf_conn == NULL || m->mf_conn[0] == '\0')
	{
		if (tTd(64, 5))
			sm_dprintf("X%s: empty or missing socket information\n",
				   m->mf_name);
		if (parseonly)
			syserr("X%s: empty or missing socket information",
			       m->mf_name);
		else if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): empty or missing socket information",
				  m->mf_name);
		milter_error(m, e);
		return -1;
	}

	/* protocol:filename or protocol:port@@host */
	memset(&addr, '\0', sizeof(addr));
	p = m->mf_conn;
	colon = strchr(p, ':');
	if (colon != NULL)
	{
		*colon = '\0';

		if (*p == '\0')
		{
# if NETUNIX
			/* default to AF_UNIX */
			addr.sa.sa_family = AF_UNIX;
# else /* NETUNIX */
#  if NETINET
			/* default to AF_INET */
			addr.sa.sa_family = AF_INET;
#  else /* NETINET */
#   if NETINET6
			/* default to AF_INET6 */
			addr.sa.sa_family = AF_INET6;
#   else /* NETINET6 */
			/* no protocols available */
			if (MilterLogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "Milter (%s): no valid socket protocols available",
					  m->mf_name);
			milter_error(m, e);
			return -1;
#   endif /* NETINET6 */
#  endif /* NETINET */
# endif /* NETUNIX */
		}
# if NETUNIX
		else if (sm_strcasecmp(p, "unix") == 0 ||
			 sm_strcasecmp(p, "local") == 0)
			addr.sa.sa_family = AF_UNIX;
# endif /* NETUNIX */
# if NETINET
		else if (sm_strcasecmp(p, "inet") == 0)
			addr.sa.sa_family = AF_INET;
# endif /* NETINET */
# if NETINET6
		else if (sm_strcasecmp(p, "inet6") == 0)
			addr.sa.sa_family = AF_INET6;
# endif /* NETINET6 */
		else
		{
# ifdef EPROTONOSUPPORT
			errno = EPROTONOSUPPORT;
# else /* EPROTONOSUPPORT */
			errno = EINVAL;
# endif /* EPROTONOSUPPORT */
			if (tTd(64, 5))
				sm_dprintf("X%s: unknown socket type %s\n",
					m->mf_name, p);
			if (parseonly)
				syserr("X%s: unknown socket type %s",
				       m->mf_name, p);
			else if (MilterLogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "Milter (%s): unknown socket type %s",
					  m->mf_name, p);
			milter_error(m, e);
			return -1;
		}
		*colon++ = ':';
	}
	else
	{
		/* default to AF_UNIX */
		addr.sa.sa_family = AF_UNIX;
		colon = p;
	}

# if NETUNIX
	if (addr.sa.sa_family == AF_UNIX)
	{
		long sff = SFF_SAFEDIRPATH|SFF_OPENASROOT|SFF_NOLINK|SFF_EXECOK;

		at = colon;
		if (strlen(colon) >= sizeof(addr.sunix.sun_path))
		{
			if (tTd(64, 5))
				sm_dprintf("X%s: local socket name %s too long\n",
					m->mf_name, colon);
			errno = EINVAL;
			if (parseonly)
				syserr("X%s: local socket name %s too long",
				       m->mf_name, colon);
			else if (MilterLogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "Milter (%s): local socket name %s too long",
					  m->mf_name, colon);
			milter_error(m, e);
			return -1;
		}
		errno = safefile(colon, RunAsUid, RunAsGid, RunAsUserName, sff,
				 S_IRUSR|S_IWUSR, NULL);

		/* if just parsing .cf file, socket doesn't need to exist */
		if (parseonly && errno == ENOENT)
		{
			if (OpMode == MD_DAEMON ||
			    OpMode == MD_FGDAEMON)
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "WARNING: X%s: local socket name %s missing\n",
						     m->mf_name, colon);
		}
		else if (errno != 0)
		{
			/* if not safe, don't create */
			save_errno = errno;
			if (tTd(64, 5))
				sm_dprintf("X%s: local socket name %s unsafe\n",
					m->mf_name, colon);
			errno = save_errno;
			if (parseonly)
			{
				if (OpMode == MD_DAEMON ||
				    OpMode == MD_FGDAEMON ||
				    OpMode == MD_SMTP)
					syserr("X%s: local socket name %s unsafe",
					       m->mf_name, colon);
			}
			else if (MilterLogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "Milter (%s): local socket name %s unsafe",
					  m->mf_name, colon);
			milter_error(m, e);
			return -1;
		}

		(void) sm_strlcpy(addr.sunix.sun_path, colon,
			       sizeof(addr.sunix.sun_path));
		addrlen = sizeof(struct sockaddr_un);
	}
	else
# endif /* NETUNIX */
# if NETINET || NETINET6
	if (false
#  if NETINET
		 || addr.sa.sa_family == AF_INET
#  endif /* NETINET */
#  if NETINET6
		 || addr.sa.sa_family == AF_INET6
#  endif /* NETINET6 */
		 )
	{
		unsigned short port;

		/* Parse port@@host */
		at = strchr(colon, '@@');
		if (at == NULL)
		{
			if (tTd(64, 5))
				sm_dprintf("X%s: bad address %s (expected port@@host)\n",
					m->mf_name, colon);
			if (parseonly)
				syserr("X%s: bad address %s (expected port@@host)",
				       m->mf_name, colon);
			else if (MilterLogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "Milter (%s): bad address %s (expected port@@host)",
					  m->mf_name, colon);
			milter_error(m, e);
			return -1;
		}
		*at = '\0';
		if (isascii(*colon) && isdigit(*colon))
			port = htons((unsigned short) atoi(colon));
		else
		{
#  ifdef NO_GETSERVBYNAME
			if (tTd(64, 5))
				sm_dprintf("X%s: invalid port number %s\n",
					m->mf_name, colon);
			if (parseonly)
				syserr("X%s: invalid port number %s",
				       m->mf_name, colon);
			else if (MilterLogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "Milter (%s): invalid port number %s",
					  m->mf_name, colon);
			milter_error(m, e);
			return -1;
#  else /* NO_GETSERVBYNAME */
			struct servent *sp;

			sp = getservbyname(colon, "tcp");
			if (sp == NULL)
			{
				save_errno = errno;
				if (tTd(64, 5))
					sm_dprintf("X%s: unknown port name %s\n",
						m->mf_name, colon);
				errno = save_errno;
				if (parseonly)
					syserr("X%s: unknown port name %s",
					       m->mf_name, colon);
				else if (MilterLogLevel > 0)
					sm_syslog(LOG_ERR, e->e_id,
						  "Milter (%s): unknown port name %s",
						  m->mf_name, colon);
				milter_error(m, e);
				return -1;
			}
			port = sp->s_port;
#  endif /* NO_GETSERVBYNAME */
		}
		*at++ = '@@';
		if (*at == '[')
		{
			char *end;

			end = strchr(at, ']');
			if (end != NULL)
			{
				bool found = false;
#  if NETINET
				unsigned long hid = INADDR_NONE;
#  endif /* NETINET */
#  if NETINET6
				struct sockaddr_in6 hid6;
#  endif /* NETINET6 */

				*end = '\0';
#  if NETINET
				if (addr.sa.sa_family == AF_INET &&
				    (hid = inet_addr(&at[1])) != INADDR_NONE)
				{
					addr.sin.sin_addr.s_addr = hid;
					addr.sin.sin_port = port;
					found = true;
				}
#  endif /* NETINET */
#  if NETINET6
				(void) memset(&hid6, '\0', sizeof(hid6));
				if (addr.sa.sa_family == AF_INET6 &&
				    anynet_pton(AF_INET6, &at[1],
						&hid6.sin6_addr) == 1)
				{
					addr.sin6.sin6_addr = hid6.sin6_addr;
					addr.sin6.sin6_port = port;
					found = true;
				}
#  endif /* NETINET6 */
				*end = ']';
				if (!found)
				{
					if (tTd(64, 5))
						sm_dprintf("X%s: Invalid numeric domain spec \"%s\"\n",
							m->mf_name, at);
					if (parseonly)
						syserr("X%s: Invalid numeric domain spec \"%s\"",
						       m->mf_name, at);
					else if (MilterLogLevel > 0)
						sm_syslog(LOG_ERR, e->e_id,
							  "Milter (%s): Invalid numeric domain spec \"%s\"",
							  m->mf_name, at);
					milter_error(m, e);
					return -1;
				}
			}
			else
			{
				if (tTd(64, 5))
					sm_dprintf("X%s: Invalid numeric domain spec \"%s\"\n",
						m->mf_name, at);
				if (parseonly)
					syserr("X%s: Invalid numeric domain spec \"%s\"",
					       m->mf_name, at);
				else if (MilterLogLevel > 0)
					sm_syslog(LOG_ERR, e->e_id,
						  "Milter (%s): Invalid numeric domain spec \"%s\"",
						  m->mf_name, at);
				milter_error(m, e);
				return -1;
			}
		}
		else
		{
			hp = sm_gethostbyname(at, addr.sa.sa_family);
			if (hp == NULL)
			{
				save_errno = errno;
				if (tTd(64, 5))
					sm_dprintf("X%s: Unknown host name %s\n",
						   m->mf_name, at);
				errno = save_errno;
				if (parseonly)
					syserr("X%s: Unknown host name %s",
					       m->mf_name, at);
				else if (MilterLogLevel > 0)
					sm_syslog(LOG_ERR, e->e_id,
						  "Milter (%s): Unknown host name %s",
						  m->mf_name, at);
				milter_error(m, e);
				return -1;
			}
			addr.sa.sa_family = hp->h_addrtype;
			switch (hp->h_addrtype)
			{
#  if NETINET
			  case AF_INET:
				memmove(&addr.sin.sin_addr,
					hp->h_addr, INADDRSZ);
				addr.sin.sin_port = port;
				addrlen = sizeof(struct sockaddr_in);
				addrno = 1;
				break;
#  endif /* NETINET */

#  if NETINET6
			  case AF_INET6:
				memmove(&addr.sin6.sin6_addr,
					hp->h_addr, IN6ADDRSZ);
				addr.sin6.sin6_port = port;
				addrlen = sizeof(struct sockaddr_in6);
				addrno = 1;
				break;
#  endif /* NETINET6 */

			  default:
				if (tTd(64, 5))
					sm_dprintf("X%s: Unknown protocol for %s (%d)\n",
						   m->mf_name, at,
						   hp->h_addrtype);
				if (parseonly)
					syserr("X%s: Unknown protocol for %s (%d)",
					       m->mf_name, at, hp->h_addrtype);
				else if (MilterLogLevel > 0)
					sm_syslog(LOG_ERR, e->e_id,
						  "Milter (%s): Unknown protocol for %s (%d)",
						  m->mf_name, at,
						  hp->h_addrtype);
				milter_error(m, e);
#  if NETINET6
				freehostent(hp);
#  endif /* NETINET6 */
				return -1;
			}
		}
	}
	else
# endif /* NETINET || NETINET6 */
	{
		if (tTd(64, 5))
			sm_dprintf("X%s: unknown socket protocol\n",
				   m->mf_name);
		if (parseonly)
			syserr("X%s: unknown socket protocol", m->mf_name);
		else if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): unknown socket protocol",
				  m->mf_name);
		milter_error(m, e);
		return -1;
	}

	/* just parsing through? */
	if (parseonly)
	{
		m->mf_state = SMFS_READY;
# if NETINET6
		if (hp != NULL)
			freehostent(hp);
# endif /* NETINET6 */
		return 0;
	}

	/* sanity check */
	if (m->mf_state != SMFS_READY &&
	    m->mf_state != SMFS_CLOSED)
	{
		/* shouldn't happen */
		if (tTd(64, 1))
			sm_dprintf("Milter (%s): Trying to open filter in state %c\n",
				   m->mf_name, (char) m->mf_state);
		milter_error(m, e);
# if NETINET6
		if (hp != NULL)
			freehostent(hp);
# endif /* NETINET6 */
		return -1;
	}

	/* nope, actually connecting */
	for (;;)
	{
		sock = socket(addr.sa.sa_family, SOCK_STREAM, 0);
		if (sock < 0)
		{
			save_errno = errno;
			if (tTd(64, 5))
				sm_dprintf("Milter (%s): error creating socket: %s\n",
					   m->mf_name,
					   sm_errstring(save_errno));
			if (MilterLogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "Milter (%s): error creating socket: %s",
					  m->mf_name, sm_errstring(save_errno));
			milter_error(m, e);
# if NETINET6
			if (hp != NULL)
				freehostent(hp);
# endif /* NETINET6 */
			return -1;
		}

		if (setjmp(MilterConnectTimeout) == 0)
		{
			SM_EVENT *ev = NULL;
			int i;

			if (m->mf_timeout[SMFTO_CONNECT] > 0)
				ev = sm_setevent(m->mf_timeout[SMFTO_CONNECT],
						 milter_connect_timeout, 0);

			i = connect(sock, (struct sockaddr *) &addr, addrlen);
			save_errno = errno;
			if (ev != NULL)
				sm_clrevent(ev);
			errno = save_errno;
			if (i >= 0)
				break;
		}

		/* couldn't connect.... try next address */
		save_errno = errno;
		p = CurHostName;
		CurHostName = at;
		if (tTd(64, 5))
			sm_dprintf("milter_open (%s): open %s failed: %s\n",
				   m->mf_name, at, sm_errstring(save_errno));
		if (MilterLogLevel > 13)
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter (%s): open %s failed: %s",
				  m->mf_name, at, sm_errstring(save_errno));
		CurHostName = p;
		(void) close(sock);

		/* try next address */
		if (hp != NULL && hp->h_addr_list[addrno] != NULL)
		{
			switch (addr.sa.sa_family)
			{
# if NETINET
			  case AF_INET:
				memmove(&addr.sin.sin_addr,
					hp->h_addr_list[addrno++],
					INADDRSZ);
				break;
# endif /* NETINET */

# if NETINET6
			  case AF_INET6:
				memmove(&addr.sin6.sin6_addr,
					hp->h_addr_list[addrno++],
					IN6ADDRSZ);
				break;
# endif /* NETINET6 */

			  default:
				if (tTd(64, 5))
					sm_dprintf("X%s: Unknown protocol for %s (%d)\n",
						   m->mf_name, at,
						   hp->h_addrtype);
				if (MilterLogLevel > 0)
					sm_syslog(LOG_ERR, e->e_id,
						  "Milter (%s): Unknown protocol for %s (%d)",
						  m->mf_name, at,
						  hp->h_addrtype);
				milter_error(m, e);
# if NETINET6
				freehostent(hp);
# endif /* NETINET6 */
				return -1;
			}
			continue;
		}
		p = CurHostName;
		CurHostName = at;
		if (tTd(64, 5))
			sm_dprintf("X%s: error connecting to filter: %s\n",
				   m->mf_name, sm_errstring(save_errno));
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): error connecting to filter: %s",
				  m->mf_name, sm_errstring(save_errno));
		CurHostName = p;
		milter_error(m, e);
# if NETINET6
		if (hp != NULL)
			freehostent(hp);
# endif /* NETINET6 */
		return -1;
	}
	m->mf_state = SMFS_OPEN;
# if NETINET6
	if (hp != NULL)
	{
		freehostent(hp);
		hp = NULL;
	}
# endif /* NETINET6 */
# if MILTER_NO_NAGLE && !defined(TCP_CORK)
	{
		int nodelay = 1;

		setsockopt(m->mf_sock, IPPROTO_TCP, TCP_NODELAY,
			   (char *)&nodelay, sizeof(nodelay));
	}
# endif /* MILTER_NO_NAGLE && !defined(TCP_CORK) */
	return sock;
}

static void
milter_connect_timeout(ignore)
	int ignore;
{
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
	longjmp(MilterConnectTimeout, 1);
}

/*
**  MILTER_SETUP -- setup structure for a mail filter
**
**	Parameters:
**		line -- the options line.
**
**	Returns:
**		none
*/

void
milter_setup(line)
	char *line;
{
	char fcode;
	char *p;
	struct milter *m;
	STAB *s;
	static int idx = 0;

	/* collect the filter name */
	for (p = line;
	     *p != '\0' && *p != ',' && !(isascii(*p) && isspace(*p));
	     p++)
		continue;
	if (*p != '\0')
		*p++ = '\0';
	if (line[0] == '\0')
	{
		syserr("name required for mail filter");
		return;
	}
	m = (struct milter *) xalloc(sizeof(*m));
	memset((char *) m, '\0', sizeof(*m));
	m->mf_name = newstr(line);
	m->mf_state = SMFS_READY;
	m->mf_sock = -1;
	m->mf_timeout[SMFTO_CONNECT] = (time_t) 300;
	m->mf_timeout[SMFTO_WRITE] = (time_t) 10;
	m->mf_timeout[SMFTO_READ] = (time_t) 10;
	m->mf_timeout[SMFTO_EOM] = (time_t) 300;
#if _FFR_MILTER_CHECK
	m->mf_mta_prot_version = SMFI_PROT_VERSION;
	m->mf_mta_prot_flags = SMFI_CURR_PROT;
	m->mf_mta_actions = SMFI_CURR_ACTS;
#endif /* _FFR_MILTER_CHECK */

	/* now scan through and assign info from the fields */
	while (*p != '\0')
	{
		char *delimptr;

		while (*p != '\0' &&
		       (*p == ',' || (isascii(*p) && isspace(*p))))
			p++;

		/* p now points to field code */
		fcode = *p;
		while (*p != '\0' && *p != '=' && *p != ',')
			p++;
		if (*p++ != '=')
		{
			syserr("X%s: `=' expected", m->mf_name);
			return;
		}
		while (isascii(*p) && isspace(*p))
			p++;

		/* p now points to the field body */
		p = munchstring(p, &delimptr, ',');

		/* install the field into the filter struct */
		switch (fcode)
		{
		  case 'S':		/* socket */
			if (p == NULL)
				m->mf_conn = NULL;
			else
				m->mf_conn = newstr(p);
			break;

		  case 'F':		/* Milter flags configured on MTA */
			for (; *p != '\0'; p++)
			{
				if (!(isascii(*p) && isspace(*p)))
					setbitn(bitidx(*p), m->mf_flags);
			}
			break;

		  case 'T':		/* timeouts */
			milter_parse_timeouts(p, m);
			break;

#if _FFR_MILTER_CHECK
		  case 'a':
			m->mf_mta_actions = strtoul(p, NULL, 0);
			break;
		  case 'f':
			m->mf_mta_prot_flags = strtoul(p, NULL, 0);
			break;
		  case 'v':
			m->mf_mta_prot_version = strtoul(p, NULL, 0);
			break;
#endif /* _FFR_MILTER_CHECK */

		  default:
			syserr("X%s: unknown filter equate %c=",
			       m->mf_name, fcode);
			break;
		}
		p = delimptr;
	}

	/* early check for errors */
	(void) milter_open(m, true, CurEnv);

	/* enter the filter into the symbol table */
	s = stab(m->mf_name, ST_MILTER, ST_ENTER);
	if (s->s_milter != NULL)
		syserr("X%s: duplicate filter definition", m->mf_name);
	else
	{
		s->s_milter = m;
		m->mf_idx = ++idx;
	}
}

/*
**  MILTER_CONFIG -- parse option list into an array and check config
**
**	Called when reading configuration file.
**
**	Parameters:
**		spec -- the filter list.
**		list -- the array to fill in.
**		max -- the maximum number of entries in list.
**
**	Returns:
**		none
*/

void
milter_config(spec, list, max)
	char *spec;
	struct milter **list;
	int max;
{
	int numitems = 0;
	char *p;

	/* leave one for the NULL signifying the end of the list */
	max--;

	for (p = spec; p != NULL; )
	{
		STAB *s;

		while (isascii(*p) && isspace(*p))
			p++;
		if (*p == '\0')
			break;
		spec = p;

		if (numitems >= max)
		{
			syserr("Too many filters defined, %d max", max);
			if (max > 0)
				list[0] = NULL;
			return;
		}
		p = strpbrk(p, ";,");
		if (p != NULL)
			*p++ = '\0';

		s = stab(spec, ST_MILTER, ST_FIND);
		if (s == NULL)
		{
			syserr("InputFilter %s not defined", spec);
			ExitStat = EX_CONFIG;
			return;
		}
		list[numitems++] = s->s_milter;
	}
	list[numitems] = NULL;

	/* if not set, set to LogLevel */
	if (MilterLogLevel == -1)
		MilterLogLevel = LogLevel;
}

/*
**  MILTER_PARSE_TIMEOUTS -- parse timeout list
**
**	Called when reading configuration file.
**
**	Parameters:
**		spec -- the timeout list.
**		m -- milter to set.
**
**	Returns:
**		none
*/

static void
milter_parse_timeouts(spec, m)
	char *spec;
	struct milter *m;
{
	char fcode;
	int tcode;
	char *p;

	p = spec;

	/* now scan through and assign info from the fields */
	while (*p != '\0')
	{
		char *delimptr;

		while (*p != '\0' &&
		       (*p == ';' || (isascii(*p) && isspace(*p))))
			p++;

		/* p now points to field code */
		fcode = *p;
		while (*p != '\0' && *p != ':')
			p++;
		if (*p++ != ':')
		{
			syserr("X%s, T=: `:' expected", m->mf_name);
			return;
		}
		while (isascii(*p) && isspace(*p))
			p++;

		/* p now points to the field body */
		p = munchstring(p, &delimptr, ';');
		tcode = -1;

		/* install the field into the filter struct */
		switch (fcode)
		{
		  case 'C':
			tcode = SMFTO_CONNECT;
			break;

		  case 'S':
			tcode = SMFTO_WRITE;
			break;

		  case 'R':
			tcode = SMFTO_READ;
			break;

		  case 'E':
			tcode = SMFTO_EOM;
			break;

		  default:
			if (tTd(64, 5))
				sm_dprintf("X%s: %c unknown\n",
					   m->mf_name, fcode);
			syserr("X%s: unknown filter timeout %c",
			       m->mf_name, fcode);
			break;
		}
		if (tcode >= 0)
		{
			m->mf_timeout[tcode] = convtime(p, 's');
			if (tTd(64, 5))
				sm_dprintf("X%s: %c=%ld\n",
					   m->mf_name, fcode,
					   (u_long) m->mf_timeout[tcode]);
		}
		p = delimptr;
	}
}

/*
**  MILTER_SET_MACROS -- set milter macros
**
**	Parameters:
**		name -- name of milter.
**		macros -- where to store macros.
**		val -- the value of the option.
**		nummac -- current number of macros
**
**	Returns:
**		new number of macros
*/

static int
milter_set_macros(name, macros, val, nummac)
	char *name;
	char **macros;
	char *val;
	int nummac;
{
	char *p;

	p = newstr(val);
	while (*p != '\0')
	{
		char *macro;

		/* Skip leading commas, spaces */
		while (*p != '\0' &&
		       (*p == ',' || (isascii(*p) && isspace(*p))))
			p++;

		if (*p == '\0')
			break;

		/* Find end of macro */
		macro = p;
		while (*p != '\0' && *p != ',' &&
		       isascii(*p) && !isspace(*p))
			p++;
		if (*p != '\0')
			*p++ = '\0';

		if (nummac >= MAXFILTERMACROS)
		{
			syserr("milter_set_option: too many macros in Milter.%s (max %d)",
			       name, MAXFILTERMACROS);
			macros[nummac] = NULL;
			return -1;
		}
		macros[nummac++] = macro;
	}
	macros[nummac] = NULL;
	return nummac;
}

/*
**  MILTER_SET_OPTION -- set an individual milter option
**
**	Parameters:
**		name -- the name of the option.
**		val -- the value of the option.
**		sticky -- if set, don't let other setoptions override
**			this value.
**
**	Returns:
**		none.
*/

/* set if Milter sub-option is stuck */
static BITMAP256	StickyMilterOpt;

static struct milteropt
{
	char		*mo_name;	/* long name of milter option */
	unsigned char	mo_code;	/* code for option */
} MilterOptTab[] =
{
	{ "macros.connect",		SMFIM_CONNECT			},
	{ "macros.helo",		SMFIM_HELO			},
	{ "macros.envfrom",		SMFIM_ENVFROM			},
	{ "macros.envrcpt",		SMFIM_ENVRCPT			},
	{ "macros.data",		SMFIM_DATA			},
	{ "macros.eom",			SMFIM_EOM			},
	{ "macros.eoh",			SMFIM_EOH			},

# define MO_LOGLEVEL			0x07
	{ "loglevel",			MO_LOGLEVEL			},
# if _FFR_MAXDATASIZE || _FFR_MDS_NEGOTIATE
#  define MO_MAXDATASIZE		0x08
	{ "maxdatasize",		MO_MAXDATASIZE			},
# endif /* _FFR_MAXDATASIZE || _FFR_MDS_NEGOTIATE */
	{ NULL,				(unsigned char)-1		},
};

void
milter_set_option(name, val, sticky)
	char *name;
	char *val;
	bool sticky;
{
	int nummac, r;
	struct milteropt *mo;
	char **macros = NULL;

	nummac = 0;
	if (tTd(37, 2) || tTd(64, 5))
		sm_dprintf("milter_set_option(%s = %s)", name, val);

	if (name == NULL)
	{
		syserr("milter_set_option: invalid Milter option, must specify suboption");
		return;
	}

	for (mo = MilterOptTab; mo->mo_name != NULL; mo++)
	{
		if (sm_strcasecmp(mo->mo_name, name) == 0)
			break;
	}

	if (mo->mo_name == NULL)
	{
		syserr("milter_set_option: invalid Milter option %s", name);
		return;
	}

	/*
	**  See if this option is preset for us.
	*/

	if (!sticky && bitnset(mo->mo_code, StickyMilterOpt))
	{
		if (tTd(37, 2) || tTd(64,5))
			sm_dprintf(" (ignored)\n");
		return;
	}

	if (tTd(37, 2) || tTd(64,5))
		sm_dprintf("\n");

	switch (mo->mo_code)
	{
	  case MO_LOGLEVEL:
		MilterLogLevel = atoi(val);
		break;

# if _FFR_MAXDATASIZE || _FFR_MDS_NEGOTIATE
	  case MO_MAXDATASIZE:
#  if _FFR_MDS_NEGOTIATE
		MilterMaxDataSize = (size_t)atol(val);
		if (MilterMaxDataSize != MILTER_MDS_64K &&
		    MilterMaxDataSize != MILTER_MDS_256K &&
		    MilterMaxDataSize != MILTER_MDS_1M)
		{
			sm_syslog(LOG_WARNING, NOQID,
				"WARNING: Milter.%s=%d, allowed are only %d, %d, and %d",
				name, MilterMaxDataSize,
				MILTER_MDS_64K, MILTER_MDS_256K,
				MILTER_MDS_1M);
			if (MilterMaxDataSize < MILTER_MDS_64K)
				MilterMaxDataSize = MILTER_MDS_64K;
			else if (MilterMaxDataSize < MILTER_MDS_256K)
				MilterMaxDataSize = MILTER_MDS_256K;
			else
				MilterMaxDataSize = MILTER_MDS_1M;
		}
#  endif /* _FFR_MDS_NEGOTIATE */
		break;
# endif /* _FFR_MAXDATASIZE || _FFR_MDS_NEGOTIATE */

	  case SMFIM_CONNECT:
	  case SMFIM_HELO:
	  case SMFIM_ENVFROM:
	  case SMFIM_ENVRCPT:
	  case SMFIM_EOH:
	  case SMFIM_EOM:
	  case SMFIM_DATA:
		macros = MilterMacros[mo->mo_code][0];

		r = milter_set_macros(name, macros, val, nummac);
		if (r >= 0)
			nummac = r;
		break;

	  default:
		syserr("milter_set_option: invalid Milter option %s", name);
		break;
	}
	if (sticky)
		setbitn(mo->mo_code, StickyMilterOpt);
}

/*
**  MILTER_REOPEN_DF -- open & truncate the data file (for replbody)
**
**	Parameters:
**		e -- current envelope.
**
**	Returns:
**		0 if succesful, -1 otherwise
*/

static int
milter_reopen_df(e)
	ENVELOPE *e;
{
	char dfname[MAXPATHLEN];

	(void) sm_strlcpy(dfname, queuename(e, DATAFL_LETTER), sizeof(dfname));

	/*
	**  In SuperSafe == SAFE_REALLY mode, e->e_dfp is a read-only FP so
	**  close and reopen writable (later close and reopen
	**  read only again).
	**
	**  In SuperSafe != SAFE_REALLY mode, e->e_dfp still points at the
	**  buffered file I/O descriptor, still open for writing so there
	**  isn't any work to do here (except checking for consistency).
	*/

	if (SuperSafe == SAFE_REALLY)
	{
		/* close read-only data file */
		if (bitset(EF_HAS_DF, e->e_flags) && e->e_dfp != NULL)
		{
			(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT);
			e->e_flags &= ~EF_HAS_DF;
		}

		/* open writable */
		if ((e->e_dfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, dfname,
					   SM_IO_RDWR_B, NULL)) == NULL)
		{
			MILTER_DF_ERROR("milter_reopen_df: sm_io_open %s: %s");
			return -1;
		}
	}
	else if (e->e_dfp == NULL)
	{
		/* shouldn't happen */
		errno = ENOENT;
		MILTER_DF_ERROR("milter_reopen_df: NULL e_dfp (%s: %s)");
		return -1;
	}
	return 0;
}

/*
**  MILTER_RESET_DF -- re-open read-only the data file (for replbody)
**
**	Parameters:
**		e -- current envelope.
**
**	Returns:
**		0 if succesful, -1 otherwise
*/

static int
milter_reset_df(e)
	ENVELOPE *e;
{
	int afd;
	char dfname[MAXPATHLEN];

	(void) sm_strlcpy(dfname, queuename(e, DATAFL_LETTER), sizeof(dfname));

	if (sm_io_flush(e->e_dfp, SM_TIME_DEFAULT) != 0 ||
	    sm_io_error(e->e_dfp))
	{
		MILTER_DF_ERROR("milter_reset_df: error writing/flushing %s: %s");
		return -1;
	}
	else if (SuperSafe != SAFE_REALLY)
	{
		/* skip next few clauses */
		/* EMPTY */
	}
	else if ((afd = sm_io_getinfo(e->e_dfp, SM_IO_WHAT_FD, NULL)) >= 0
		 && fsync(afd) < 0)
	{
		MILTER_DF_ERROR("milter_reset_df: error sync'ing %s: %s");
		return -1;
	}
	else if (sm_io_close(e->e_dfp, SM_TIME_DEFAULT) < 0)
	{
		MILTER_DF_ERROR("milter_reset_df: error closing %s: %s");
		return -1;
	}
	else if ((e->e_dfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, dfname,
					SM_IO_RDONLY_B, NULL)) == NULL)
	{
		MILTER_DF_ERROR("milter_reset_df: error reopening %s: %s");
		return -1;
	}
	else
		e->e_flags |= EF_HAS_DF;
	return 0;
}

/*
**  MILTER_QUIT_FILTER -- close down a single filter
**
**	Parameters:
**		m -- milter structure of filter to close down.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_quit_filter(m, e)
	struct milter *m;
	ENVELOPE *e;
{
	if (tTd(64, 10))
		sm_dprintf("milter_quit_filter(%s)\n", m->mf_name);
	if (MilterLogLevel > 18)
		sm_syslog(LOG_INFO, e->e_id, "Milter (%s): quit filter",
			  m->mf_name);

	/* Never replace error state */
	if (m->mf_state == SMFS_ERROR)
		return;

	if (m->mf_sock < 0 ||
	    m->mf_state == SMFS_CLOSED ||
	    m->mf_state == SMFS_READY)
	{
		m->mf_sock = -1;
		m->mf_state = SMFS_CLOSED;
		return;
	}

	(void) milter_write(m, SMFIC_QUIT, (char *) NULL, 0,
			    m->mf_timeout[SMFTO_WRITE], e, "quit_filter");
	if (m->mf_sock >= 0)
	{
		(void) close(m->mf_sock);
		m->mf_sock = -1;
	}
	if (m->mf_state != SMFS_ERROR)
		m->mf_state = SMFS_CLOSED;
}

/*
**  MILTER_ABORT_FILTER -- tell filter to abort current message
**
**	Parameters:
**		m -- milter structure of filter to abort.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_abort_filter(m, e)
	struct milter *m;
	ENVELOPE *e;
{
	if (tTd(64, 10))
		sm_dprintf("milter_abort_filter(%s)\n", m->mf_name);
	if (MilterLogLevel > 10)
		sm_syslog(LOG_INFO, e->e_id, "Milter (%s): abort filter",
			  m->mf_name);

	if (m->mf_sock < 0 ||
	    m->mf_state != SMFS_INMSG)
		return;

	(void) milter_write(m, SMFIC_ABORT, (char *) NULL, 0,
			    m->mf_timeout[SMFTO_WRITE], e, "abort_filter");
	if (m->mf_state != SMFS_ERROR)
		m->mf_state = SMFS_DONE;
}

/*
**  MILTER_SEND_MACROS -- provide macros to the filters
**
**	Parameters:
**		m -- milter to send macros to.
**		macros -- macros to send for filter smfi_getsymval().
**		cmd -- which command the macros are associated with.
**		e -- current envelope (for macro access).
**
**	Returns:
**		none
*/

static void
milter_send_macros(m, macros, cmd, e)
	struct milter *m;
	char **macros;
	int cmd;
	ENVELOPE *e;
{
	int i;
	int mid;
	char command = (char) cmd;
	char *v;
	char *buf, *bp;
	char exp[MAXLINE];
	ssize_t s;

	/* sanity check */
	if (macros == NULL || macros[0] == NULL)
		return;

	/* put together data */
	s = 1;			/* for the command character */
	for (i = 0; macros[i] != NULL; i++)
	{
		mid = macid(macros[i]);
		if (mid == 0)
			continue;
		v = macvalue(mid, e);
		if (v == NULL)
			continue;
		expand(v, exp, sizeof(exp), e);
		s += strlen(macros[i]) + 1 + strlen(exp) + 1;
	}

	if (s < 0)
		return;

	buf = (char *) xalloc(s);
	bp = buf;
	*bp++ = command;
	for (i = 0; macros[i] != NULL; i++)
	{
		mid = macid(macros[i]);
		if (mid == 0)
			continue;
		v = macvalue(mid, e);
		if (v == NULL)
			continue;
		expand(v, exp, sizeof(exp), e);

		if (tTd(64, 10))
			sm_dprintf("milter_send_macros(%s, %c): %s=%s\n",
				m->mf_name, command, macros[i], exp);

		(void) sm_strlcpy(bp, macros[i], s - (bp - buf));
		bp += strlen(bp) + 1;
		(void) sm_strlcpy(bp, exp, s - (bp - buf));
		bp += strlen(bp) + 1;
	}
	(void) milter_write(m, SMFIC_MACRO, buf, s,
			    m->mf_timeout[SMFTO_WRITE], e, "send_macros");
	sm_free(buf);
}

/*
**  MILTER_SEND_COMMAND -- send a command and return the response for a filter
**
**	Parameters:
**		m -- current milter filter
**		cmd -- command to send.
**		data -- optional command data.
**		sz -- length of buf.
**		e -- current envelope (for e->e_id).
**		state -- return state word.
**
**	Returns:
**		response string (may be NULL)
*/

static char *
milter_send_command(m, cmd, data, sz, e, state, where)
	struct milter *m;
	int cmd;
	void *data;
	ssize_t sz;
	ENVELOPE *e;
	char *state;
	const char *where;
{
	char rcmd;
	ssize_t rlen;
	unsigned long skipflag;
	unsigned long norespflag = 0;
	char command = (char) cmd;
	char *action;
	char *defresponse;
	char *response;

	if (tTd(64, 10))
		sm_dprintf("milter_send_command(%s): cmd %c len %ld\n",
			m->mf_name, (char) command, (long) sz);

	/* find skip flag and default failure */
	switch (command)
	{
	  case SMFIC_CONNECT:
		skipflag = SMFIP_NOCONNECT;
		norespflag = SMFIP_NR_CONN;
		action = "connect";
		defresponse = "554 Command rejected";
		break;

	  case SMFIC_HELO:
		skipflag = SMFIP_NOHELO;
		norespflag = SMFIP_NR_HELO;
		action = "helo";
		defresponse = "550 Command rejected";
		break;

	  case SMFIC_MAIL:
		skipflag = SMFIP_NOMAIL;
		norespflag = SMFIP_NR_MAIL;
		action = "mail";
		defresponse = "550 5.7.1 Command rejected";
		break;

	  case SMFIC_RCPT:
		skipflag = SMFIP_NORCPT;
		norespflag = SMFIP_NR_RCPT;
		action = "rcpt";
		defresponse = "550 5.7.1 Command rejected";
		break;

	  case SMFIC_HEADER:
		skipflag = SMFIP_NOHDRS;
		norespflag = SMFIP_NR_HDR;
		action = "header";
		defresponse = "550 5.7.1 Command rejected";
		break;

	  case SMFIC_BODY:
		skipflag = SMFIP_NOBODY;
		norespflag = SMFIP_NR_BODY;
		action = "body";
		defresponse = "554 5.7.1 Command rejected";
		break;

	  case SMFIC_EOH:
		skipflag = SMFIP_NOEOH;
		norespflag = SMFIP_NR_EOH;
		action = "eoh";
		defresponse = "550 5.7.1 Command rejected";
		break;

	  case SMFIC_UNKNOWN:
		skipflag = SMFIP_NOUNKNOWN;
		norespflag = SMFIP_NR_UNKN;
		action = "unknown";
		defresponse = "550 5.7.1 Command rejected";
		break;

	  case SMFIC_DATA:
		skipflag = SMFIP_NODATA;
		norespflag = SMFIP_NR_DATA;
		action = "data";
		defresponse = "550 5.7.1 Command rejected";
		break;

	  case SMFIC_BODYEOB:
	  case SMFIC_OPTNEG:
	  case SMFIC_MACRO:
	  case SMFIC_ABORT:
	  case SMFIC_QUIT:
		/* NOTE: not handled by milter_send_command() */
		/* FALLTHROUGH */

	  default:
		skipflag = 0;
		action = "default";
		defresponse = "550 5.7.1 Command rejected";
		break;
	}

	if (tTd(64, 10))
		sm_dprintf("milter_send_command(%s): skip=%lx, pflags=%x\n",
			m->mf_name, skipflag, m->mf_pflags);

	/* check if filter wants this command */
	if (skipflag != 0 && bitset(skipflag, m->mf_pflags))
		return NULL;

	/* send the command to the filter */
	(void) milter_write(m, command, data, sz,
			    m->mf_timeout[SMFTO_WRITE], e, where);
	if (m->mf_state == SMFS_ERROR)
	{
		MILTER_CHECK_ERROR(false, return NULL);
		return NULL;
	}

	/* check if filter sends response to this command */
	if (norespflag != 0 && bitset(norespflag, m->mf_pflags))
		return NULL;

	/* get the response from the filter */
	response = milter_read(m, &rcmd, &rlen,
			       m->mf_timeout[SMFTO_READ], e, where);
	if (m->mf_state == SMFS_ERROR)
	{
		MILTER_CHECK_ERROR(false, return NULL);
		return NULL;
	}

	if (tTd(64, 10))
		sm_dprintf("milter_send_command(%s): returned %c\n",
			   m->mf_name, (char) rcmd);

	switch (rcmd)
	{
	  case SMFIR_REPLYCODE:
		MILTER_CHECK_REPLYCODE(defresponse);
		if (MilterLogLevel > 10)
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, reject=%s",
				  m->mf_name, action, response);
		*state = rcmd;
		break;

	  case SMFIR_REJECT:
		if (MilterLogLevel > 10)
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, reject",
				  m->mf_name, action);
		*state = rcmd;
		break;

	  case SMFIR_DISCARD:
		if (MilterLogLevel > 10)
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, discard",
				  m->mf_name, action);
		*state = rcmd;
		break;

	  case SMFIR_TEMPFAIL:
		if (MilterLogLevel > 10)
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, tempfail",
				  m->mf_name, action);
		*state = rcmd;
		break;

	  case SMFIR_ACCEPT:
		/* this filter is done with message/connection */
		if (command == SMFIC_HELO ||
		    command == SMFIC_CONNECT)
			m->mf_state = SMFS_CLOSABLE;
		else
			m->mf_state = SMFS_DONE;
		if (MilterLogLevel > 10)
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, accepted",
				  m->mf_name, action);
		break;

	  case SMFIR_CONTINUE:
		/* if MAIL command is ok, filter is in message state */
		if (command == SMFIC_MAIL)
			m->mf_state = SMFS_INMSG;
		if (MilterLogLevel > 12)
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, continue",
				  m->mf_name, action);
		break;

	  case SMFIR_SKIP:
		if (MilterLogLevel > 12)
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, skip",
				  m->mf_name, action);
		m->mf_state = SMFS_SKIP;
		break;

	  default:
		/* Invalid response to command */
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_send_command(%s): action=%s returned bogus response %c",
				  m->mf_name, action, rcmd);
		milter_error(m, e); /* NO ERROR CHECK? */
		break;
	}

	if (*state != SMFIR_REPLYCODE && response != NULL)
	{
		sm_free(response); /* XXX */
		response = NULL;
	}
	return response;
}

/*
**  MILTER_COMMAND -- send a command and return the response for each filter
**
**	Parameters:
**		cmd -- command to send.
**		data -- optional command data.
**		sz -- length of buf.
**		stage -- index of macros to send for filter smfi_getsymval().
**		e -- current envelope (for macro access).
**		state -- return state word.
**		where -- description of calling function (logging).
**		cmd_error -- did the SMTP command cause an error?
**
**	Returns:
**		response string (may be NULL)
*/

static char *
milter_command(cmd, data, sz, stage, e, state, where, cmd_error)
	int cmd;
	void *data;
	ssize_t sz;
	int stage;
	ENVELOPE *e;
	char *state;
	const char *where;
	bool cmd_error;
{
	int i;
	char command = (char) cmd;
	char *response = NULL;
	time_t tn = 0;

	if (tTd(64, 10))
		sm_dprintf("milter_command: cmd %c len %ld\n",
			command, (long) sz);

	*state = SMFIR_CONTINUE;
	for (i = 0; InputFilters[i] != NULL; i++)
	{
		struct milter *m = InputFilters[i];

		/* previous problem? */
		if (m->mf_state == SMFS_ERROR)
		{
			MILTER_CHECK_ERROR(false, continue);
			break;
		}

		/* sanity check */
		if (m->mf_sock < 0 ||
		    (m->mf_state != SMFS_OPEN && m->mf_state != SMFS_INMSG))
			continue;

		if (stage >= SMFIM_FIRST && stage <= SMFIM_LAST)
		{
			int idx;
			char **macros;

			if ((m->mf_lflags & MI_LFLAGS_SYM(stage)) != 0)
				idx = m->mf_idx;
			else
				idx = 0;
			SM_ASSERT(idx >= 0 && idx <= MAXFILTERS);
			macros = MilterMacros[stage][idx];

			/* send macros (regardless of whether we send cmd) */
			if (macros != NULL && macros[0] != NULL)
			{
				milter_send_macros(m, macros, command, e);
				if (m->mf_state == SMFS_ERROR)
				{
					MILTER_CHECK_ERROR(false, continue);
					break;
				}
			}
		}

		if (MilterLogLevel > 21)
			tn = curtime();

		/*
		**  send the command if
		**	there is no error
		**	or it's RCPT and the client asked for it:
		**	!cmd_error ||
		**	where == "rcpt" && m->mf_pflags & SMFIP_RCPT_REJ != 0
		**  negate that condition and use continue
		*/

		if (cmd_error &&
		    (strcmp(where, "rcpt") != 0 ||
		     (m->mf_pflags & SMFIP_RCPT_REJ) == 0))
			continue;

		response = milter_send_command(m, command, data, sz, e, state,
						where);

		if (MilterLogLevel > 21)
		{
			/* log the time it took for the command per filter */
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter (%s): time command (%c), %d",
				  m->mf_name, command, (int) (tn - curtime()));
		}

		if (*state != SMFIR_CONTINUE)
			break;
	}
	return response;
}

static int milter_getsymlist __P((struct milter *, char *, int, int));

static int
milter_getsymlist(m, buf, rlen, offset)
	struct milter *m;
	char *buf;
	int rlen;
	int offset;
{
	int i, r, nummac;
	mi_int32 v;

	SM_ASSERT(m != NULL);
	SM_ASSERT(buf != NULL);

	while (offset + MILTER_LEN_BYTES < rlen)
	{
		size_t len;
		char **macros;

		nummac = 0;
		(void) memcpy((char *) &v, buf + offset, MILTER_LEN_BYTES);
		i = ntohl(v);
		if (i < SMFIM_FIRST || i > SMFIM_LAST)
			return -1;
		offset += MILTER_LEN_BYTES;
		macros = NULL;

		switch (i)
		{
		  case SMFIM_CONNECT:
		  case SMFIM_HELO:
		  case SMFIM_ENVFROM:
		  case SMFIM_ENVRCPT:
		  case SMFIM_EOH:
		  case SMFIM_EOM:
		  case SMFIM_DATA:
			SM_ASSERT(m->mf_idx > 0 && m->mf_idx < MAXFILTERS);
			macros = MilterMacros[i][m->mf_idx];
			m->mf_lflags |= MI_LFLAGS_SYM(i);
			len = strlen(buf + offset);
			if (len > 0)
			{
				r = milter_set_macros(m->mf_name, macros,
						buf + offset, nummac);
				if (r >= 0)
					nummac = r;
				if (tTd(64, 5))
					sm_dprintf("milter_getsymlist(%s, %s)=%d\n",
						m->mf_name, buf + offset, r);
			}
			break;

		  default:
			return -1;
		}
		if (len == 0)
			return -1;
		offset += len + 1;
	}

	return 0;
}

/*
**  MILTER_NEGOTIATE -- get version and flags from filter
**
**	Parameters:
**		m -- milter filter structure.
**		e -- current envelope.
**		milters -- milters structure.
**
**	Returns:
**		0 on success, -1 otherwise
*/

static int
milter_negotiate(m, e, milters)
	struct milter *m;
	ENVELOPE *e;
	milters_T *milters;
{
	char rcmd;
	mi_int32 fvers, fflags, pflags;
	mi_int32 mta_prot_vers, mta_prot_flags, mta_actions;
	ssize_t rlen;
	char *response;
	char data[MILTER_OPTLEN];

	/* sanity check */
	if (m->mf_sock < 0 || m->mf_state != SMFS_OPEN)
	{
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): negotiate, impossible state",
				  m->mf_name);
		milter_error(m, e);
		return -1;
	}

#if _FFR_MILTER_CHECK
	mta_prot_vers = m->mf_mta_prot_version;
	mta_prot_flags = m->mf_mta_prot_flags;
	mta_actions = m->mf_mta_actions;
#else /* _FFR_MILTER_CHECK */
	mta_prot_vers = SMFI_PROT_VERSION;
	mta_prot_flags = SMFI_CURR_PROT;
	mta_actions = SMFI_CURR_ACTS;
#endif /* _FFR_MILTER_CHECK */
#if _FFR_MDS_NEGOTIATE
	if (MilterMaxDataSize == MILTER_MDS_256K)
		mta_prot_flags |= SMFIP_MDS_256K;
	else if (MilterMaxDataSize == MILTER_MDS_1M)
		mta_prot_flags |= SMFIP_MDS_1M;
#endif /* _FFR_MDS_NEGOTIATE */

	fvers = htonl(mta_prot_vers);
	pflags = htonl(mta_prot_flags);
	fflags = htonl(mta_actions);
	(void) memcpy(data, (char *) &fvers, MILTER_LEN_BYTES);
	(void) memcpy(data + MILTER_LEN_BYTES,
		      (char *) &fflags, MILTER_LEN_BYTES);
	(void) memcpy(data + (MILTER_LEN_BYTES * 2),
		      (char *) &pflags, MILTER_LEN_BYTES);
	(void) milter_write(m, SMFIC_OPTNEG, data, sizeof(data),
			    m->mf_timeout[SMFTO_WRITE], e, "negotiate");

	if (m->mf_state == SMFS_ERROR)
		return -1;

	if (tTd(64, 5))
		sm_dprintf("milter_negotiate(%s): send: version %lu, fflags 0x%lx, pflags 0x%lx\n",
			m->mf_name, ntohl(fvers), ntohl(fflags), ntohl(pflags));

	response = milter_read(m, &rcmd, &rlen, m->mf_timeout[SMFTO_READ], e,
				"negotiate");
	if (m->mf_state == SMFS_ERROR)
		return -1;

	if (rcmd != SMFIC_OPTNEG)
	{
		if (tTd(64, 5))
			sm_dprintf("milter_negotiate(%s): returned %c instead of %c\n",
				m->mf_name, rcmd, SMFIC_OPTNEG);
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): negotiate: returned %c instead of %c",
				  m->mf_name, rcmd, SMFIC_OPTNEG);
		if (response != NULL)
			sm_free(response); /* XXX */
		milter_error(m, e);
		return -1;
	}

	/* Make sure we have enough bytes for the version */
	if (response == NULL || rlen < MILTER_LEN_BYTES)
	{
		if (tTd(64, 5))
			sm_dprintf("milter_negotiate(%s): did not return valid info\n",
				m->mf_name);
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): negotiate: did not return valid info",
				  m->mf_name);
		if (response != NULL)
			sm_free(response); /* XXX */
		milter_error(m, e);
		return -1;
	}

	/* extract information */
	(void) memcpy((char *) &fvers, response, MILTER_LEN_BYTES);

	/* Now make sure we have enough for the feature bitmap */
	if (rlen < MILTER_OPTLEN)
	{
		if (tTd(64, 5))
			sm_dprintf("milter_negotiate(%s): did not return enough info\n",
				m->mf_name);
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): negotiate: did not return enough info",
				  m->mf_name);
		if (response != NULL)
			sm_free(response); /* XXX */
		milter_error(m, e);
		return -1;
	}

	(void) memcpy((char *) &fflags, response + MILTER_LEN_BYTES,
		      MILTER_LEN_BYTES);
	(void) memcpy((char *) &pflags, response + (MILTER_LEN_BYTES * 2),
		      MILTER_LEN_BYTES);

	m->mf_fvers = ntohl(fvers);
	m->mf_fflags = ntohl(fflags);
	m->mf_pflags = ntohl(pflags);

	/* check for version compatibility */
	if (m->mf_fvers == 1 ||
	    m->mf_fvers > SMFI_VERSION)
	{
		if (tTd(64, 5))
			sm_dprintf("milter_negotiate(%s): version %d != MTA milter version %d\n",
				m->mf_name, m->mf_fvers, SMFI_VERSION);
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): negotiate: version %d != MTA milter version %d",
				  m->mf_name, m->mf_fvers, SMFI_VERSION);
		milter_error(m, e);
		goto error;
	}

	/* check for filter feature mismatch */
	if ((m->mf_fflags & mta_actions) != m->mf_fflags)
	{
		if (tTd(64, 5))
			sm_dprintf("milter_negotiate(%s): filter abilities 0x%x != MTA milter abilities 0x%lx\n",
				m->mf_name, m->mf_fflags,
				(unsigned long) mta_actions);
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): negotiate: filter abilities 0x%x != MTA milter abilities 0x%lx",
				  m->mf_name, m->mf_fflags,
				  (unsigned long) mta_actions);
		milter_error(m, e);
		goto error;
	}

#if _FFR_MDS_NEGOTIATE
	/* use a table instead of sequence? */
	if (bitset(SMFIP_MDS_1M, m->mf_pflags))
	{
		if (MilterMaxDataSize != MILTER_MDS_1M)
		{
			/* this should not happen... */
			sm_syslog(LOG_WARNING, NOQID,
				  "WARNING: Milter.maxdatasize: configured=%d, set by libmilter=%d",
		    		  MilterMaxDataSize, MILTER_MDS_1M);
			MilterMaxDataSize = MILTER_MDS_1M;
		}
	}
	else if (bitset(SMFIP_MDS_256K, m->mf_pflags))
	{
		if (MilterMaxDataSize != MILTER_MDS_256K)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "WARNING: Milter.maxdatasize: configured=%d, set by libmilter=%d",
		    		  MilterMaxDataSize, MILTER_MDS_256K);
			MilterMaxDataSize = MILTER_MDS_256K;
		}
	}
	else if (MilterMaxDataSize != MILTER_MDS_64K)
	{
		sm_syslog(LOG_WARNING, NOQID,
			  "WARNING: Milter.maxdatasize: configured=%d, set by libmilter=%d",
	    		  MilterMaxDataSize, MILTER_MDS_64K);
		MilterMaxDataSize = MILTER_MDS_64K;
	}
	m->mf_pflags &= ~SMFI_INTERNAL;
#endif /* _FFR_MDS_NEGOTIATE */

	/* check for protocol feature mismatch */
	if ((m->mf_pflags & mta_prot_flags) != m->mf_pflags)
	{
		if (tTd(64, 5))
			sm_dprintf("milter_negotiate(%s): protocol abilities 0x%x != MTA milter abilities 0x%lx\n",
				m->mf_name, m->mf_pflags,
				(unsigned long) mta_prot_flags);
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): negotiate: protocol abilities 0x%x != MTA milter abilities 0x%lx",
				  m->mf_name, m->mf_pflags,
				  (unsigned long) mta_prot_flags);
		milter_error(m, e);
		goto error;
	}

	if (m->mf_fvers <= 2)
		m->mf_pflags |= SMFIP_NOUNKNOWN;
	if (m->mf_fvers <= 3)
		m->mf_pflags |= SMFIP_NODATA;

	if (rlen > MILTER_OPTLEN)
	{
		milter_getsymlist(m, response, rlen, MILTER_OPTLEN);
	}

	if (bitset(SMFIF_DELRCPT, m->mf_fflags))
		milters->mis_flags |= MIS_FL_DEL_RCPT;
	if (!bitset(SMFIP_NORCPT, m->mf_pflags) &&
	    !bitset(SMFIP_NR_RCPT, m->mf_pflags))
		milters->mis_flags |= MIS_FL_REJ_RCPT;

	if (tTd(64, 5))
		sm_dprintf("milter_negotiate(%s): received: version %u, fflags 0x%x, pflags 0x%x\n",
			m->mf_name, m->mf_fvers, m->mf_fflags, m->mf_pflags);
	return 0;

  error:
	if (response != NULL)
		sm_free(response); /* XXX */
	return -1;
}

/*
**  MILTER_PER_CONNECTION_CHECK -- checks on per-connection commands
**
**	Reduce code duplication by putting these checks in one place
**
**	Parameters:
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_per_connection_check(e)
	ENVELOPE *e;
{
	int i;

	/* see if we are done with any of the filters */
	for (i = 0; InputFilters[i] != NULL; i++)
	{
		struct milter *m = InputFilters[i];

		if (m->mf_state == SMFS_CLOSABLE)
			milter_quit_filter(m, e);
	}
}

/*
**  MILTER_ERROR -- Put a milter filter into error state
**
**	Parameters:
**		m -- the broken filter.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_error(m, e)
	struct milter *m;
	ENVELOPE *e;
{
	/*
	**  We could send a quit here but we may have gotten here due to
	**  an I/O error so we don't want to try to make things worse.
	*/

	if (m->mf_sock >= 0)
	{
		(void) close(m->mf_sock);
		m->mf_sock = -1;
	}
	m->mf_state = SMFS_ERROR;

	if (MilterLogLevel > 0)
		sm_syslog(LOG_INFO, e->e_id, "Milter (%s): to error state",
			  m->mf_name);
}

/*
**  MILTER_HEADERS -- send headers to a single milter filter
**
**	Parameters:
**		m -- current filter.
**		e -- current envelope.
**		state -- return state from response.
**
**	Returns:
**		response string (may be NULL)
*/

static char *
milter_headers(m, e, state)
	struct milter *m;
	ENVELOPE *e;
	char *state;
{
	char *response = NULL;
	HDR *h;

	if (MilterLogLevel > 17)
		sm_syslog(LOG_INFO, e->e_id, "Milter (%s): headers, send",
			  m->mf_name);

	for (h = e->e_header; h != NULL; h = h->h_link)
	{
		int len_n, len_v, len_t, len_f;
		char *buf, *hv;

		/* don't send over deleted headers */
		if (h->h_value == NULL)
		{
			/* strip H_USER so not counted in milter_changeheader() */
			h->h_flags &= ~H_USER;
			continue;
		}

		/* skip auto-generated */
		if (!bitset(H_USER, h->h_flags))
			continue;

		if (tTd(64, 10))
			sm_dprintf("milter_headers: %s:%s\n",
				h->h_field, h->h_value);
		if (MilterLogLevel > 21)
			sm_syslog(LOG_INFO, e->e_id, "Milter (%s): header, %s",
				  m->mf_name, h->h_field);

		if (bitset(SMFIP_HDR_LEADSPC, m->mf_pflags)
		    || *(h->h_value) != ' ')
			hv = h->h_value;
		else
			hv = h->h_value + 1;
		len_f = strlen(h->h_field) + 1;
		len_t = len_f + strlen(hv) + 1;
		if (len_t < 0)
			continue;
		buf = (char *) xalloc(len_t);

		/*
		**  Note: currently the call to dequote_internal_chars()
		**  is not required as h_field is supposed to be 7-bit US-ASCII.
		*/

		len_n = dequote_internal_chars(h->h_field, buf, len_f);
		SM_ASSERT(len_n < len_f);
		len_v = dequote_internal_chars(hv, buf + len_n + 1,
						len_t - len_n - 1);
		SM_ASSERT(len_t >= len_n + 1 + len_v + 1);
		len_t = len_n + 1 + len_v + 1;

		/* send it over */
		response = milter_send_command(m, SMFIC_HEADER, buf,
					       len_t, e, state, "header");
		sm_free(buf);
		if (m->mf_state == SMFS_ERROR ||
		    m->mf_state == SMFS_DONE ||
		    *state != SMFIR_CONTINUE)
			break;
	}
	if (MilterLogLevel > 17)
		sm_syslog(LOG_INFO, e->e_id, "Milter (%s): headers, sent",
			  m->mf_name);
	return response;
}

/*
**  MILTER_BODY -- send the body to a filter
**
**	Parameters:
**		m -- current filter.
**		e -- current envelope.
**		state -- return state from response.
**
**	Returns:
**		response string (may be NULL)
*/

static char *
milter_body(m, e, state)
	struct milter *m;
	ENVELOPE *e;
	char *state;
{
	char bufchar = '\0';
	char prevchar = '\0';
	int c;
	char *response = NULL;
	char *bp;
	char buf[MILTER_CHUNK_SIZE];

	if (tTd(64, 10))
		sm_dprintf("milter_body\n");

	if (bfrewind(e->e_dfp) < 0)
	{
		ExitStat = EX_IOERR;
		*state = SMFIR_TEMPFAIL;
		syserr("milter_body: %s/%cf%s: rewind error",
		       qid_printqueue(e->e_qgrp, e->e_qdir),
		       DATAFL_LETTER, e->e_id);
		return NULL;
	}

	if (MilterLogLevel > 17)
		sm_syslog(LOG_INFO, e->e_id, "Milter (%s): body, send",
			  m->mf_name);
	bp = buf;
	while ((c = sm_io_getc(e->e_dfp, SM_TIME_DEFAULT)) != SM_IO_EOF)
	{
		/*  Change LF to CRLF */
		if (c == '\n')
		{
#if !_FFR_MILTER_CONVERT_ALL_LF_TO_CRLF
			/* Not a CRLF already? */
			if (prevchar != '\r')
#endif /* !_FFR_MILTER_CONVERT_ALL_LF_TO_CRLF */
			{
				/* Room for CR now? */
				if (bp + 2 > &buf[sizeof(buf)])
				{
					/* No room, buffer LF */
					bufchar = c;

					/* and send CR now */
					c = '\r';
				}
				else
				{
					/* Room to do it now */
					*bp++ = '\r';
					prevchar = '\r';
				}
			}
		}
		*bp++ = (char) c;
		prevchar = c;
		if (bp >= &buf[sizeof(buf)])
		{
			/* send chunk */
			response = milter_send_command(m, SMFIC_BODY, buf,
						       bp - buf, e, state,
							"body chunk");
			bp = buf;
			if (bufchar != '\0')
			{
				*bp++ = bufchar;
				bufchar = '\0';
				prevchar = bufchar;
			}
		}
		if (m->mf_state == SMFS_ERROR ||
		    m->mf_state == SMFS_DONE ||
		    m->mf_state == SMFS_SKIP ||
		    *state != SMFIR_CONTINUE)
			break;
	}

	/* check for read errors */
	if (sm_io_error(e->e_dfp))
	{
		ExitStat = EX_IOERR;
		if (*state == SMFIR_CONTINUE ||
		    *state == SMFIR_ACCEPT ||
		    m->mf_state == SMFS_SKIP)
		{
			*state = SMFIR_TEMPFAIL;
			if (response != NULL)
			{
				sm_free(response); /* XXX */
				response = NULL;
			}
		}
		syserr("milter_body: %s/%cf%s: read error",
		       qid_printqueue(e->e_qgrp, e->e_qdir),
		       DATAFL_LETTER, e->e_id);
		return response;
	}

	/* send last body chunk */
	if (bp > buf &&
	    m->mf_state != SMFS_ERROR &&
	    m->mf_state != SMFS_DONE &&
	    m->mf_state != SMFS_SKIP &&
	    *state == SMFIR_CONTINUE)
	{
		/* send chunk */
		response = milter_send_command(m, SMFIC_BODY, buf, bp - buf,
					       e, state, "last body chunk");
		bp = buf;
	}
	if (MilterLogLevel > 17)
		sm_syslog(LOG_INFO, e->e_id, "Milter (%s): body, sent",
			  m->mf_name);
	if (m->mf_state == SMFS_SKIP)
	{
		*state = SMFIR_CONTINUE;
		m->mf_state = SMFS_READY;
	}

	return response;
}

/*
**  Actions
*/

/*
**  ADDLEADINGSPACE -- Add a leading space to a string
**
**	Parameters:
**		str -- string
**		rp -- resource pool for allocations
**
**	Returns:
**		pointer to new string
*/

static char *addleadingspace __P((char *, SM_RPOOL_T *));

static char *
addleadingspace(str, rp)
	char *str;
	SM_RPOOL_T *rp;
{
	size_t l;
	char *new;

	SM_ASSERT(str != NULL);
	l = strlen(str);
	SM_ASSERT(l + 2 > l);
	new = sm_rpool_malloc_x(rp, l + 2);
	new[0] = ' ';
	new[1] = '\0';
	sm_strlcpy(new + 1, str, l + 1);
	return new;
}

/*
**  MILTER_ADDHEADER -- Add the supplied header to the message
**
**	Parameters:
**		m -- current filter.
**		response -- encoded form of header/value.
**		rlen -- length of response.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_addheader(m, response, rlen, e)
	struct milter *m;
	char *response;
	ssize_t rlen;
	ENVELOPE *e;
{
	int mh_v_len;
	char *val, *mh_value;
	HDR *h;

	if (tTd(64, 10))
		sm_dprintf("milter_addheader: ");

	/* sanity checks */
	if (response == NULL)
	{
		if (tTd(64, 10))
			sm_dprintf("NULL response\n");
		return;
	}

	if (rlen < 2 || strlen(response) + 1 >= (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (total len %d != rlen %d)\n",
				   (int) strlen(response), (int) (rlen - 1));
		return;
	}

	/* Find separating NUL */
	val = response + strlen(response) + 1;

	/* another sanity check */
	if (strlen(response) + strlen(val) + 2 != (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (part len)\n");
		return;
	}

	if (*response == '\0')
	{
		if (tTd(64, 10))
			sm_dprintf("empty field name\n");
		return;
	}

	for (h = e->e_header; h != NULL; h = h->h_link)
	{
		if (sm_strcasecmp(h->h_field, response) == 0 &&
		    !bitset(H_USER, h->h_flags) &&
		    !bitset(H_TRACE, h->h_flags))
			break;
	}

	mh_v_len = 0;
	mh_value = quote_internal_chars(val, NULL, &mh_v_len);

	/* add to e_msgsize */
	e->e_msgsize += strlen(response) + 2 + strlen(val);

	if (h != NULL)
	{
		if (tTd(64, 10))
			sm_dprintf("Replace default header %s value with %s\n",
				   h->h_field, mh_value);
		if (MilterLogLevel > 8)
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter change: default header %s value with %s",
				  h->h_field, mh_value);
		if (bitset(SMFIP_HDR_LEADSPC, m->mf_pflags))
			h->h_value = mh_value;
		else
		{
			h->h_value = addleadingspace(mh_value, e->e_rpool);
			SM_FREE(mh_value);
		}
		h->h_flags |= H_USER;
	}
	else
	{
		if (tTd(64, 10))
			sm_dprintf("Add %s: %s\n", response, mh_value);
		if (MilterLogLevel > 8)
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter add: header: %s: %s",
				  response, mh_value);
		addheader(newstr(response), mh_value, H_USER, e,
			!bitset(SMFIP_HDR_LEADSPC, m->mf_pflags));
		SM_FREE(mh_value);
	}
}

/*
**  MILTER_INSHEADER -- Insert the supplied header
**
**	Parameters:
**		m -- current filter.
**		response -- encoded form of header/value.
**		rlen -- length of response.
**		e -- current envelope.
**
**	Returns:
**		none
**
**	Notes:
**		Unlike milter_addheader(), this does not attempt to determine
**		if the header already exists in the envelope, even a
**		deleted version.  It just blindly inserts.
*/

static void
milter_insheader(m, response, rlen, e)
	struct milter *m;
	char *response;
	ssize_t rlen;
	ENVELOPE *e;
{
	mi_int32 idx, i;
	int mh_v_len;
	char *field, *val, *mh_value;

	if (tTd(64, 10))
		sm_dprintf("milter_insheader: ");

	/* sanity checks */
	if (response == NULL)
	{
		if (tTd(64, 10))
			sm_dprintf("NULL response\n");
		return;
	}

	if (rlen < 2 || strlen(response) + 1 >= (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (total len)\n");
		return;
	}

	/* decode */
	(void) memcpy((char *) &i, response, MILTER_LEN_BYTES);
	idx = ntohl(i);
	field = response + MILTER_LEN_BYTES;
	val = field + strlen(field) + 1;

	/* another sanity check */
	if (MILTER_LEN_BYTES + strlen(field) + 1 +
	    strlen(val) + 1 != (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (part len)\n");
		return;
	}

	if (*field == '\0')
	{
		if (tTd(64, 10))
			sm_dprintf("empty field name\n");
		return;
	}

	/* add to e_msgsize */
	e->e_msgsize += strlen(response) + 2 + strlen(val);

	if (tTd(64, 10))
		sm_dprintf("Insert (%d) %s: %s\n", idx, field, val);
	if (MilterLogLevel > 8)
		sm_syslog(LOG_INFO, e->e_id,
			  "Milter insert (%d): header: %s: %s",
			  idx, field, val);
	mh_v_len = 0;
	mh_value = quote_internal_chars(val, NULL, &mh_v_len);
	insheader(idx, newstr(field), mh_value, H_USER, e,
		!bitset(SMFIP_HDR_LEADSPC, m->mf_pflags));
	SM_FREE(mh_value);
}

/*
**  MILTER_CHANGEHEADER -- Change the supplied header in the message
**
**	Parameters:
**		m -- current filter.
**		response -- encoded form of header/index/value.
**		rlen -- length of response.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_changeheader(m, response, rlen, e)
	struct milter *m;
	char *response;
	ssize_t rlen;
	ENVELOPE *e;
{
	mi_int32 i, index;
	int mh_v_len;
	char *field, *val, *mh_value;
	HDR *h, *sysheader;

	if (tTd(64, 10))
		sm_dprintf("milter_changeheader: ");

	/* sanity checks */
	if (response == NULL)
	{
		if (tTd(64, 10))
			sm_dprintf("NULL response\n");
		return;
	}

	if (rlen < 2 || strlen(response) + 1 >= (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (total len)\n");
		return;
	}

	/* Find separating NUL */
	(void) memcpy((char *) &i, response, MILTER_LEN_BYTES);
	index = ntohl(i);
	field = response + MILTER_LEN_BYTES;
	val = field + strlen(field) + 1;

	/* another sanity check */
	if (MILTER_LEN_BYTES + strlen(field) + 1 +
	    strlen(val) + 1 != (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (part len)\n");
		return;
	}

	if (*field == '\0')
	{
		if (tTd(64, 10))
			sm_dprintf("empty field name\n");
		return;
	}

	mh_v_len = 0;
	mh_value = quote_internal_chars(val, NULL, &mh_v_len);

	sysheader = NULL;
	for (h = e->e_header; h != NULL; h = h->h_link)
	{
		if (sm_strcasecmp(h->h_field, field) == 0)
		{
			if (bitset(H_USER, h->h_flags) && --index <= 0)
			{
				sysheader = NULL;
				break;
			}
			else if (!bitset(H_USER, h->h_flags) &&
				 !bitset(H_TRACE, h->h_flags))
			{
				/*
				**  DRUMS msg-fmt draft says can only have
				**  multiple occurences of trace fields,
				**  so make sure we replace any non-trace,
				**  non-user field.
				*/

				sysheader = h;
			}
		}
	}

	/* if not found as user-provided header at index, use sysheader */
	if (h == NULL)
		h = sysheader;

	if (h == NULL)
	{
		if (*val == '\0')
		{
			if (tTd(64, 10))
				sm_dprintf("Delete (noop) %s\n", field);
			if (MilterLogLevel > 8)
				sm_syslog(LOG_INFO, e->e_id,
					"Milter delete (noop): header: %s"
					, field);
		}
		else
		{
			/* treat modify value with no existing header as add */
			if (tTd(64, 10))
				sm_dprintf("Add %s: %s\n", field, mh_value);
			if (MilterLogLevel > 8)
				sm_syslog(LOG_INFO, e->e_id,
					"Milter change (add): header: %s: %s"
					, field, mh_value);
			addheader(newstr(field), mh_value, H_USER, e,
				!bitset(SMFIP_HDR_LEADSPC, m->mf_pflags));
		}
		return;
	}

	if (tTd(64, 10))
	{
		if (*val == '\0')
		{
			sm_dprintf("Delete%s %s:%s\n",
				   h == sysheader ? " (default header)" : "",
				   field,
				   h->h_value == NULL ? "<NULL>" : h->h_value);
		}
		else
		{
			sm_dprintf("Change%s %s: from %s to %s\n",
				   h == sysheader ? " (default header)" : "",
				   field,
				   h->h_value == NULL ? "<NULL>" : h->h_value,
				   mh_value);
		}
	}

	if (MilterLogLevel > 8)
	{
		if (*val == '\0')
		{
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter delete: header%s %s:%s",
				  h == sysheader ? " (default header)" : "",
				  field,
				  h->h_value == NULL ? "<NULL>" : h->h_value);
		}
		else
		{
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter change: header%s %s: from %s to %s",
				  h == sysheader ? " (default header)" : "",
				  field,
				  h->h_value == NULL ? "<NULL>" : h->h_value,
				  mh_value);
		}
	}

	if (h != sysheader && h->h_value != NULL)
	{
		size_t l;

		l = strlen(h->h_value);
		if (l > e->e_msgsize)
			e->e_msgsize = 0;
		else
			e->e_msgsize -= l;
		/* rpool, don't free: sm_free(h->h_value); XXX */
	}

	if (*val == '\0')
	{
		/* Remove "Field: " from message size */
		if (h != sysheader)
		{
			size_t l;

			l = strlen(h->h_field) + 2;
			if (l > e->e_msgsize)
				e->e_msgsize = 0;
			else
				e->e_msgsize -= l;
		}
		h->h_value = NULL;
		SM_FREE(mh_value);
	}
	else
	{
		if (bitset(SMFIP_HDR_LEADSPC, m->mf_pflags))
			h->h_value = mh_value;
		else
		{
			h->h_value = addleadingspace(mh_value, e->e_rpool);
			SM_FREE(mh_value);
		}
		h->h_flags |= H_USER;
		e->e_msgsize += strlen(h->h_value);
	}
}

/*
**  MILTER_SPLIT_RESPONSE -- Split response into fields.
**
**	Parameters:
**		response -- encoded repsonse.
**		rlen -- length of response.
**		pargc -- number of arguments (ouput)
**
**	Returns:
**		array of pointers to the individual strings
*/

static char **milter_split_response __P((char *, ssize_t, int *));

static char **
milter_split_response(response, rlen, pargc)
	char *response;
	ssize_t rlen;
	int *pargc;
{
	char **s;
	size_t i;
	int elem, nelem;

	SM_ASSERT(response != NULL);
	SM_ASSERT(pargc != NULL);
	*pargc = 0;
	if (rlen < 2 || strlen(response) >= (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (total len %d != rlen %d)\n",
				   (int) strlen(response), (int) (rlen - 1));
		return NULL;
	}

	nelem = 0;
	for (i = 0; i < rlen; i++)
	{
		if (response[i] == '\0')
			++nelem;
	}
	if (nelem == 0)
		return NULL;

	/* last entry is only for the name */
	s = (char **)malloc((nelem + 1) * (sizeof(*s)));
	if (s == NULL)
		return NULL;
	s[0] = response;
	for (i = 0, elem = 0; i < rlen && elem < nelem; i++)
	{
		if (response[i] == '\0')
		{
			++elem;
			if (i + 1 >= rlen)
				s[elem] = NULL;
			else
				s[elem] = &(response[i + 1]);
		}
	}
	*pargc = nelem;

	if (tTd(64, 10))
	{
		for (elem = 0; elem < nelem; elem++)
			sm_dprintf("argv[%d]=\"%s\"\n", elem, s[elem]);
	}

	/* overwrite last entry (already done above, just paranoia) */
	s[elem] = NULL;
	return s;
}

/*
**  MILTER_CHGFROM -- Change the envelope sender address
**
**	Parameters:
**		response -- encoded form of recipient address.
**		rlen -- length of response.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_chgfrom(response, rlen, e)
	char *response;
	ssize_t rlen;
	ENVELOPE *e;
{
	int olderrors, argc;
	char **argv;

	if (tTd(64, 10))
		sm_dprintf("milter_chgfrom: ");

	/* sanity checks */
	if (response == NULL)
	{
		if (tTd(64, 10))
			sm_dprintf("NULL response\n");
		return;
	}

	if (*response == '\0' ||
	    strlen(response) + 1 > (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (total len %d != rlen %d)\n",
				   (int) strlen(response), (int) (rlen - 1));
		return;
	}

	if (tTd(64, 10))
		sm_dprintf("%s\n", response);
	if (MilterLogLevel > 8)
		sm_syslog(LOG_INFO, e->e_id, "Milter chgfrom: %s", response);
	argv = milter_split_response(response, rlen, &argc);
	if (argc < 1 || argc > 2)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol argc=%d\n", argc);
		return;
	}

	olderrors = Errors;
	setsender(argv[0], e, NULL, '\0', false);
	if (argc == 2)
	{
		reset_mail_esmtp_args(e);

		/*
		**  need "features" here: how to get those? via e?
		**  "fake" it for now: allow everything.
		*/

		parse_esmtp_args(e, NULL, argv[0], argv[1], "MAIL", NULL,
				mail_esmtp_args);
	}
	Errors = olderrors;
	return;
}

/*
**  MILTER_ADDRCPT_PAR -- Add the supplied recipient to the message
**
**	Parameters:
**		response -- encoded form of recipient address.
**		rlen -- length of response.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_addrcpt_par(response, rlen, e)
	char *response;
	ssize_t rlen;
	ENVELOPE *e;
{
	int olderrors, argc;
	char *delimptr;
	char **argv;
	ADDRESS *a;

	if (tTd(64, 10))
		sm_dprintf("milter_addrcpt_par: ");

	/* sanity checks */
	if (response == NULL)
	{
		if (tTd(64, 10))
			sm_dprintf("NULL response\n");
		return;
	}

	if (tTd(64, 10))
		sm_dprintf("%s\n", response);
	if (MilterLogLevel > 8)
		sm_syslog(LOG_INFO, e->e_id, "Milter add: rcpt: %s", response);

	argv = milter_split_response(response, rlen, &argc);
	if (argc < 1 || argc > 2)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol argc=%d\n", argc);
		return;
	}
	olderrors = Errors;

	/* how to set ESMTP arguments? */
	a = parseaddr(argv[0], NULLADDR, RF_COPYALL, ' ', &delimptr, e, true);

	if (a != NULL && olderrors == Errors)
	{
		parse_esmtp_args(e, a, argv[0], argv[1], "RCPT", NULL,
				rcpt_esmtp_args);
		if (olderrors == Errors)
			a = recipient(a, &e->e_sendqueue, 0, e);
		else
			sm_dprintf("olderrors=%d, Errors=%d\n",
				olderrors, Errors);
	}
	else
	{
		sm_dprintf("a=%p, olderrors=%d, Errors=%d\n",
			a, olderrors, Errors);
	}

	Errors = olderrors;
	return;
}

/*
**  MILTER_ADDRCPT -- Add the supplied recipient to the message
**
**	Parameters:
**		response -- encoded form of recipient address.
**		rlen -- length of response.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_addrcpt(response, rlen, e)
	char *response;
	ssize_t rlen;
	ENVELOPE *e;
{
	int olderrors;

	if (tTd(64, 10))
		sm_dprintf("milter_addrcpt: ");

	/* sanity checks */
	if (response == NULL)
	{
		if (tTd(64, 10))
			sm_dprintf("NULL response\n");
		return;
	}

	if (*response == '\0' ||
	    strlen(response) + 1 != (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (total len %d != rlen %d)\n",
				   (int) strlen(response), (int) (rlen - 1));
		return;
	}

	if (tTd(64, 10))
		sm_dprintf("%s\n", response);
	if (MilterLogLevel > 8)
		sm_syslog(LOG_INFO, e->e_id, "Milter add: rcpt: %s", response);
	olderrors = Errors;
	(void) sendtolist(response, NULLADDR, &e->e_sendqueue, 0, e);
	Errors = olderrors;
	return;
}

/*
**  MILTER_DELRCPT -- Delete the supplied recipient from the message
**
**	Parameters:
**		response -- encoded form of recipient address.
**		rlen -- length of response.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_delrcpt(response, rlen, e)
	char *response;
	ssize_t rlen;
	ENVELOPE *e;
{
	if (tTd(64, 10))
		sm_dprintf("milter_delrcpt: ");

	/* sanity checks */
	if (response == NULL)
	{
		if (tTd(64, 10))
			sm_dprintf("NULL response\n");
		return;
	}

	if (*response == '\0' ||
	    strlen(response) + 1 != (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (total len %d != rlen %d)\n",
				   (int) strlen(response), (int) (rlen - 1));
		return;
	}

	if (tTd(64, 10))
		sm_dprintf("%s\n", response);
	if (MilterLogLevel > 8)
		sm_syslog(LOG_INFO, e->e_id, "Milter delete: rcpt %s",
			  response);
	(void) removefromlist(response, &e->e_sendqueue, e);
	return;
}

/*
**  MILTER_REPLBODY -- Replace the current data file with new body
**
**	Parameters:
**		response -- encoded form of new body.
**		rlen -- length of response.
**		newfilter -- if first time called by a new filter
**		e -- current envelope.
**
**	Returns:
**		0 upon success, -1 upon failure
*/

static int
milter_replbody(response, rlen, newfilter, e)
	char *response;
	ssize_t rlen;
	bool newfilter;
	ENVELOPE *e;
{
	static char prevchar;
	int i;

	if (tTd(64, 10))
		sm_dprintf("milter_replbody\n");

	/* If a new filter, reset previous character and truncate data file */
	if (newfilter)
	{
		off_t prevsize;
		char dfname[MAXPATHLEN];

		(void) sm_strlcpy(dfname, queuename(e, DATAFL_LETTER),
				  sizeof(dfname));

		/* Reset prevchar */
		prevchar = '\0';

		/* Get the current data file information */
		prevsize = sm_io_getinfo(e->e_dfp, SM_IO_WHAT_SIZE, NULL);
		if (prevsize < 0)
			prevsize = 0;

		/* truncate current data file */
		if (sm_io_getinfo(e->e_dfp, SM_IO_WHAT_ISTYPE, BF_FILE_TYPE))
		{
			if (sm_io_setinfo(e->e_dfp, SM_BF_TRUNCATE, NULL) < 0)
			{
				MILTER_DF_ERROR("milter_replbody: sm_io truncate %s: %s");
				return -1;
			}
		}
		else
		{
			int err;

			err = sm_io_error(e->e_dfp);
			(void) sm_io_flush(e->e_dfp, SM_TIME_DEFAULT);

			/*
			**  Clear error if tried to fflush()
			**  a read-only file pointer and
			**  there wasn't a previous error.
			*/

			if (err == 0)
				sm_io_clearerr(e->e_dfp);

			/* errno is set implicitly by fseek() before return */
			err = sm_io_seek(e->e_dfp, SM_TIME_DEFAULT,
					 0, SEEK_SET);
			if (err < 0)
			{
				MILTER_DF_ERROR("milter_replbody: sm_io_seek %s: %s");
				return -1;
			}
# if NOFTRUNCATE
			/* XXX: Not much we can do except rewind it */
			errno = EINVAL;
			MILTER_DF_ERROR("milter_replbody: ftruncate not available on this platform (%s:%s)");
			return -1;
# else /* NOFTRUNCATE */
			err = ftruncate(sm_io_getinfo(e->e_dfp,
						      SM_IO_WHAT_FD, NULL),
					0);
			if (err < 0)
			{
				MILTER_DF_ERROR("milter_replbody: sm_io ftruncate %s: %s");
				return -1;
			}
# endif /* NOFTRUNCATE */
		}

		if (prevsize > e->e_msgsize)
			e->e_msgsize = 0;
		else
			e->e_msgsize -= prevsize;
	}

	if (newfilter && MilterLogLevel > 8)
		sm_syslog(LOG_INFO, e->e_id, "Milter message: body replaced");

	if (response == NULL)
	{
		/* Flush the buffered '\r' */
		if (prevchar == '\r')
		{
			(void) sm_io_putc(e->e_dfp, SM_TIME_DEFAULT, prevchar);
			e->e_msgsize++;
		}
		return 0;
	}

	for (i = 0; i < rlen; i++)
	{
		/* Buffered char from last chunk */
		if (i == 0 && prevchar == '\r')
		{
			/* Not CRLF, output prevchar */
			if (response[i] != '\n')
			{
				(void) sm_io_putc(e->e_dfp, SM_TIME_DEFAULT,
						  prevchar);
				e->e_msgsize++;
			}
			prevchar = '\0';
		}

		/* Turn CRLF into LF */
		if (response[i] == '\r')
		{
			/* check if at end of chunk */
			if (i + 1 < rlen)
			{
				/* If LF, strip CR */
				if (response[i + 1] == '\n')
					i++;
			}
			else
			{
				/* check next chunk */
				prevchar = '\r';
				continue;
			}
		}
		(void) sm_io_putc(e->e_dfp, SM_TIME_DEFAULT, response[i]);
		e->e_msgsize++;
	}
	return 0;
}

/*
**  MTA callouts
*/

/*
**  MILTER_INIT -- open and negotiate with all of the filters
**
**	Parameters:
**		e -- current envelope.
**		state -- return state from response.
**		milters -- milters structure.
**
**	Returns:
**		true iff at least one filter is active
*/

/* ARGSUSED */
bool
milter_init(e, state, milters)
	ENVELOPE *e;
	char *state;
	milters_T *milters;
{
	int i;

	if (tTd(64, 10))
		sm_dprintf("milter_init\n");

	memset(milters, '\0', sizeof(*milters));
	*state = SMFIR_CONTINUE;
	if (InputFilters[0] == NULL)
	{
		if (MilterLogLevel > 10)
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter: no active filter");
		return false;
	}

	for (i = 0; InputFilters[i] != NULL; i++)
	{
		struct milter *m = InputFilters[i];

		m->mf_sock = milter_open(m, false, e);
		if (m->mf_state == SMFS_ERROR)
		{
			MILTER_CHECK_ERROR(true, continue);
			break;
		}

		if (m->mf_sock < 0 ||
		    milter_negotiate(m, e, milters) < 0 ||
		    m->mf_state == SMFS_ERROR)
		{
			if (tTd(64, 5))
				sm_dprintf("milter_init(%s): failed to %s\n",
					   m->mf_name,
					   m->mf_sock < 0 ? "open" :
							    "negotiate");
			if (MilterLogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "Milter (%s): init failed to %s",
					  m->mf_name,
					  m->mf_sock < 0 ? "open" :
							   "negotiate");

			/* if negotiation failure, close socket */
			milter_error(m, e);
			MILTER_CHECK_ERROR(true, continue);
			continue;
		}
		if (MilterLogLevel > 9)
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter (%s): init success to %s",
				  m->mf_name,
				  m->mf_sock < 0 ? "open" : "negotiate");
	}

	/*
	**  If something temp/perm failed with one of the filters,
	**  we won't be using any of them, so clear any existing
	**  connections.
	*/

	if (*state != SMFIR_CONTINUE)
		milter_quit(e);

	return true;
}

/*
**  MILTER_CONNECT -- send connection info to milter filters
**
**	Parameters:
**		hostname -- hostname of remote machine.
**		addr -- address of remote machine.
**		e -- current envelope.
**		state -- return state from response.
**
**	Returns:
**		response string (may be NULL)
*/

char *
milter_connect(hostname, addr, e, state)
	char *hostname;
	SOCKADDR addr;
	ENVELOPE *e;
	char *state;
{
	char family;
	unsigned short port;
	char *buf, *bp;
	char *response;
	char *sockinfo = NULL;
	ssize_t s;
# if NETINET6
	char buf6[INET6_ADDRSTRLEN];
# endif /* NETINET6 */

	if (tTd(64, 10))
		sm_dprintf("milter_connect(%s)\n", hostname);
	if (MilterLogLevel > 9)
		sm_syslog(LOG_INFO, e->e_id, "Milter: connect to filters");

	/* gather data */
	switch (addr.sa.sa_family)
	{
# if NETUNIX
	  case AF_UNIX:
		family = SMFIA_UNIX;
		port = htons(0);
		sockinfo = addr.sunix.sun_path;
		break;
# endif /* NETUNIX */

# if NETINET
	  case AF_INET:
		family = SMFIA_INET;
		port = addr.sin.sin_port;
		sockinfo = (char *) inet_ntoa(addr.sin.sin_addr);
		break;
# endif /* NETINET */

# if NETINET6
	  case AF_INET6:
		if (IN6_IS_ADDR_V4MAPPED(&addr.sin6.sin6_addr))
			family = SMFIA_INET;
		else
			family = SMFIA_INET6;
		port = addr.sin6.sin6_port;
		sockinfo = anynet_ntop(&addr.sin6.sin6_addr, buf6,
				       sizeof(buf6));
		if (sockinfo == NULL)
			sockinfo = "";
		break;
# endif /* NETINET6 */

	  default:
		family = SMFIA_UNKNOWN;
		break;
	}

	s = strlen(hostname) + 1 + sizeof(family);
	if (family != SMFIA_UNKNOWN)
		s += sizeof(port) + strlen(sockinfo) + 1;

	buf = (char *) xalloc(s);
	bp = buf;

	/* put together data */
	(void) memcpy(bp, hostname, strlen(hostname));
	bp += strlen(hostname);
	*bp++ = '\0';
	(void) memcpy(bp, &family, sizeof(family));
	bp += sizeof(family);
	if (family != SMFIA_UNKNOWN)
	{
		(void) memcpy(bp, &port, sizeof(port));
		bp += sizeof(port);

		/* include trailing '\0' */
		(void) memcpy(bp, sockinfo, strlen(sockinfo) + 1);
	}

	response = milter_command(SMFIC_CONNECT, buf, s, SMFIM_CONNECT,
				e, state, "connect", false);
	sm_free(buf); /* XXX */

	/*
	**  If this message connection is done for,
	**  close the filters.
	*/

	if (*state != SMFIR_CONTINUE)
	{
		if (MilterLogLevel > 9)
			sm_syslog(LOG_INFO, e->e_id, "Milter: connect, ending");
		milter_quit(e);
	}
	else
		milter_per_connection_check(e);

	/*
	**  SMFIR_REPLYCODE can't work with connect due to
	**  the requirements of SMTP.  Therefore, ignore the
	**  reply code text but keep the state it would reflect.
	*/

	if (*state == SMFIR_REPLYCODE)
	{
		if (response != NULL &&
		    *response == '4')
		{
			if (strncmp(response, "421 ", 4) == 0)
				*state = SMFIR_SHUTDOWN;
			else
				*state = SMFIR_TEMPFAIL;
		}
		else
			*state = SMFIR_REJECT;
		if (response != NULL)
		{
			sm_free(response); /* XXX */
			response = NULL;
		}
	}
	return response;
}

/*
**  MILTER_HELO -- send SMTP HELO/EHLO command info to milter filters
**
**	Parameters:
**		helo -- argument to SMTP HELO/EHLO command.
**		e -- current envelope.
**		state -- return state from response.
**
**	Returns:
**		response string (may be NULL)
*/

char *
milter_helo(helo, e, state)
	char *helo;
	ENVELOPE *e;
	char *state;
{
	int i;
	char *response;

	if (tTd(64, 10))
		sm_dprintf("milter_helo(%s)\n", helo);

	/* HELO/EHLO can come at any point */
	for (i = 0; InputFilters[i] != NULL; i++)
	{
		struct milter *m = InputFilters[i];

		switch (m->mf_state)
		{
		  case SMFS_INMSG:
			/* abort in message filters */
			milter_abort_filter(m, e);
			/* FALLTHROUGH */

		  case SMFS_DONE:
			/* reset done filters */
			m->mf_state = SMFS_OPEN;
			break;
		}
	}

	response = milter_command(SMFIC_HELO, helo, strlen(helo) + 1,
				  SMFIM_HELO, e, state, "helo", false);
	milter_per_connection_check(e);
	return response;
}

/*
**  MILTER_ENVFROM -- send SMTP MAIL command info to milter filters
**
**	Parameters:
**		args -- SMTP MAIL command args (args[0] == sender).
**		e -- current envelope.
**		state -- return state from response.
**
**	Returns:
**		response string (may be NULL)
*/

char *
milter_envfrom(args, e, state)
	char **args;
	ENVELOPE *e;
	char *state;
{
	int i;
	char *buf, *bp;
	char *response;
	ssize_t s;

	if (tTd(64, 10))
	{
		sm_dprintf("milter_envfrom:");
		for (i = 0; args[i] != NULL; i++)
			sm_dprintf(" %s", args[i]);
		sm_dprintf("\n");
	}

	/* sanity check */
	if (args[0] == NULL)
	{
		*state = SMFIR_REJECT;
		if (MilterLogLevel > 10)
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter: reject, no sender");
		return NULL;
	}

	/* new message, so ... */
	for (i = 0; InputFilters[i] != NULL; i++)
	{
		struct milter *m = InputFilters[i];

		switch (m->mf_state)
		{
		  case SMFS_INMSG:
			/* abort in message filters */
			milter_abort_filter(m, e);
			/* FALLTHROUGH */

		  case SMFS_DONE:
			/* reset done filters */
			m->mf_state = SMFS_OPEN;
			break;
		}
	}

	/* put together data */
	s = 0;
	for (i = 0; args[i] != NULL; i++)
		s += strlen(args[i]) + 1;

	if (s < 0)
	{
		*state = SMFIR_TEMPFAIL;
		return NULL;
	}

	buf = (char *) xalloc(s);
	bp = buf;
	for (i = 0; args[i] != NULL; i++)
	{
		(void) sm_strlcpy(bp, args[i], s - (bp - buf));
		bp += strlen(bp) + 1;
	}

	if (MilterLogLevel > 14)
		sm_syslog(LOG_INFO, e->e_id, "Milter: sender: %s", buf);

	/* send it over */
	response = milter_command(SMFIC_MAIL, buf, s, SMFIM_ENVFROM,
				e, state, "mail", false);
	sm_free(buf); /* XXX */

	/*
	**  If filter rejects/discards a per message command,
	**  abort the other filters since we are done with the
	**  current message.
	*/

	MILTER_CHECK_DONE_MSG();
	if (MilterLogLevel > 10 && *state == SMFIR_REJECT)
		sm_syslog(LOG_INFO, e->e_id, "Milter: reject, sender");
	return response;
}

/*
**  MILTER_ENVRCPT -- send SMTP RCPT command info to milter filters
**
**	Parameters:
**		args -- SMTP MAIL command args (args[0] == recipient).
**		e -- current envelope.
**		state -- return state from response.
**		rcpt_error -- does RCPT have an error?
**
**	Returns:
**		response string (may be NULL)
*/

char *
milter_envrcpt(args, e, state, rcpt_error)
	char **args;
	ENVELOPE *e;
	char *state;
	bool rcpt_error;
{
	int i;
	char *buf, *bp;
	char *response;
	ssize_t s;

	if (tTd(64, 10))
	{
		sm_dprintf("milter_envrcpt:");
		for (i = 0; args[i] != NULL; i++)
			sm_dprintf(" %s", args[i]);
		sm_dprintf("\n");
	}

	/* sanity check */
	if (args[0] == NULL)
	{
		*state = SMFIR_REJECT;
		if (MilterLogLevel > 10)
			sm_syslog(LOG_INFO, e->e_id, "Milter: reject, no rcpt");
		return NULL;
	}

	/* put together data */
	s = 0;
	for (i = 0; args[i] != NULL; i++)
		s += strlen(args[i]) + 1;

	if (s < 0)
	{
		*state = SMFIR_TEMPFAIL;
		return NULL;
	}

	buf = (char *) xalloc(s);
	bp = buf;
	for (i = 0; args[i] != NULL; i++)
	{
		(void) sm_strlcpy(bp, args[i], s - (bp - buf));
		bp += strlen(bp) + 1;
	}

	if (MilterLogLevel > 14)
		sm_syslog(LOG_INFO, e->e_id, "Milter: rcpts: %s", buf);

	/* send it over */
	response = milter_command(SMFIC_RCPT, buf, s, SMFIM_ENVRCPT,
				e, state, "rcpt", rcpt_error);
	sm_free(buf); /* XXX */
	return response;
}

/*
**  MILTER_DATA_CMD -- send SMTP DATA command info to milter filters
**
**	Parameters:
**		e -- current envelope.
**		state -- return state from response.
**
**	Returns:
**		response string (may be NULL)
*/

char *
milter_data_cmd(e, state)
	ENVELOPE *e;
	char *state;
{
	if (tTd(64, 10))
		sm_dprintf("milter_data_cmd\n");

	/* send it over */
	return milter_command(SMFIC_DATA, NULL, 0, SMFIM_DATA,
				e, state, "data", false);
}

/*
**  MILTER_DATA -- send message headers/body and gather final message results
**
**	Parameters:
**		e -- current envelope.
**		state -- return state from response.
**
**	Returns:
**		response string (may be NULL)
**
**	Side effects:
**		- Uses e->e_dfp for access to the body
**		- Can call the various milter action routines to
**		  modify the envelope or message.
*/

/* flow through code using continue; don't wrap in do {} while */
# define MILTER_CHECK_RESULTS() \
	if (m->mf_state == SMFS_ERROR && *state == SMFIR_CONTINUE) \
	{ \
			MILTER_SET_STATE;	\
	} \
	if (*state == SMFIR_ACCEPT || \
	    m->mf_state == SMFS_DONE || \
	    m->mf_state == SMFS_ERROR) \
	{ \
		if (m->mf_state != SMFS_ERROR) \
			m->mf_state = SMFS_DONE; \
		continue;	/* to next filter */ \
	} \
	if (*state != SMFIR_CONTINUE) \
	{ \
		m->mf_state = SMFS_DONE; \
		goto finishup; \
	}

char *
milter_data(e, state)
	ENVELOPE *e;
	char *state;
{
	bool replbody = false;		/* milter_replbody() called? */
	bool replfailed = false;	/* milter_replbody() failed? */
	bool rewind = false;		/* rewind data file? */
	bool dfopen = false;		/* data file open for writing? */
	bool newfilter;			/* reset on each new filter */
	char rcmd;
	int i;
	int save_errno;
	char *response = NULL;
	time_t eomsent;
	ssize_t rlen;

	if (tTd(64, 10))
		sm_dprintf("milter_data\n");

	*state = SMFIR_CONTINUE;

	/*
	**  XXX: Should actually send body chunks to each filter
	**  a chunk at a time instead of sending the whole body to
	**  each filter in turn.  However, only if the filters don't
	**  change the body.
	*/

	for (i = 0; InputFilters[i] != NULL; i++)
	{
		int idx;
		char **macros;
		struct milter *m = InputFilters[i];

		if (*state != SMFIR_CONTINUE &&
		    *state != SMFIR_ACCEPT)
		{
			/*
			**  A previous filter has dealt with the message,
			**  safe to stop processing the filters.
			*/

			break;
		}

		/* Now reset state for later evaluation */
		*state = SMFIR_CONTINUE;
		newfilter = true;

		/* previous problem? */
		if (m->mf_state == SMFS_ERROR)
		{
			MILTER_CHECK_ERROR(false, continue);
			break;
		}

		/* sanity checks */
		if (m->mf_sock < 0 ||
		    (m->mf_state != SMFS_OPEN && m->mf_state != SMFS_INMSG))
			continue;

		m->mf_state = SMFS_INMSG;

		/* check if filter wants the headers */
		if (!bitset(SMFIP_NOHDRS, m->mf_pflags))
		{
			response = milter_headers(m, e, state);
			MILTER_CHECK_RESULTS();
		}

		/* check if filter wants EOH */
		if (!bitset(SMFIP_NOEOH, m->mf_pflags))
		{
			if (tTd(64, 10))
				sm_dprintf("milter_data: eoh\n");

			if ((m->mf_lflags & MI_LFLAGS_SYM(SMFIM_EOH)) != 0)
				idx = m->mf_idx;
			else
				idx = 0;
			SM_ASSERT(idx >= 0 && idx <= MAXFILTERS);
			macros = MilterMacros[SMFIM_EOH][idx];

			if (macros != NULL)
			{
				milter_send_macros(m, macros, SMFIC_EOH, e);
				MILTER_CHECK_RESULTS();
			}

			/* send it over */
			response = milter_send_command(m, SMFIC_EOH, NULL, 0,
						       e, state, "eoh");
			MILTER_CHECK_RESULTS();
		}

		/* check if filter wants the body */
		if (!bitset(SMFIP_NOBODY, m->mf_pflags) &&
		    e->e_dfp != NULL)
		{
			rewind = true;
			response = milter_body(m, e, state);
			MILTER_CHECK_RESULTS();
		}

		if ((m->mf_lflags & MI_LFLAGS_SYM(SMFIM_EOH)) != 0)
			idx = m->mf_idx;
		else
			idx = 0;
		SM_ASSERT(idx >= 0 && idx <= MAXFILTERS);
		macros = MilterMacros[SMFIM_EOM][idx];
		if (macros != NULL)
		{
			milter_send_macros(m, macros, SMFIC_BODYEOB, e);
			MILTER_CHECK_RESULTS();
		}

		/* send the final body chunk */
		(void) milter_write(m, SMFIC_BODYEOB, NULL, 0,
				    m->mf_timeout[SMFTO_WRITE], e, "eom");

		/* Get time EOM sent for timeout */
		eomsent = curtime();

		/* deal with the possibility of multiple responses */
		while (*state == SMFIR_CONTINUE)
		{
			/* Check total timeout from EOM to final ACK/NAK */
			if (m->mf_timeout[SMFTO_EOM] > 0 &&
			    curtime() - eomsent >= m->mf_timeout[SMFTO_EOM])
			{
				if (tTd(64, 5))
					sm_dprintf("milter_data(%s): EOM ACK/NAK timeout\n",
						m->mf_name);
				if (MilterLogLevel > 0)
					sm_syslog(LOG_ERR, e->e_id,
						  "milter_data(%s): EOM ACK/NAK timeout",
						  m->mf_name);
				milter_error(m, e);
				MILTER_CHECK_ERROR(false, break);
				break;
			}

			response = milter_read(m, &rcmd, &rlen,
					       m->mf_timeout[SMFTO_READ], e,
						"eom");
			if (m->mf_state == SMFS_ERROR)
				break;

			if (tTd(64, 10))
				sm_dprintf("milter_data(%s): state %c\n",
					   m->mf_name, (char) rcmd);

			switch (rcmd)
			{
			  case SMFIR_REPLYCODE:
				MILTER_CHECK_REPLYCODE("554 5.7.1 Command rejected");
				if (MilterLogLevel > 12)
					sm_syslog(LOG_INFO, e->e_id, "milter=%s, reject=%s",
						  m->mf_name, response);
				*state = rcmd;
				m->mf_state = SMFS_DONE;
				break;

			  case SMFIR_REJECT: /* log msg at end of function */
				if (MilterLogLevel > 12)
					sm_syslog(LOG_INFO, e->e_id, "milter=%s, reject",
						  m->mf_name);
				*state = rcmd;
				m->mf_state = SMFS_DONE;
				break;

			  case SMFIR_DISCARD:
				if (MilterLogLevel > 12)
					sm_syslog(LOG_INFO, e->e_id, "milter=%s, discard",
						  m->mf_name);
				*state = rcmd;
				m->mf_state = SMFS_DONE;
				break;

			  case SMFIR_TEMPFAIL:
				if (MilterLogLevel > 12)
					sm_syslog(LOG_INFO, e->e_id, "milter=%s, tempfail",
						  m->mf_name);
				*state = rcmd;
				m->mf_state = SMFS_DONE;
				break;

			  case SMFIR_CONTINUE:
			  case SMFIR_ACCEPT:
				/* this filter is done with message */
				if (replfailed)
					*state = SMFIR_TEMPFAIL;
				else
					*state = SMFIR_ACCEPT;
				m->mf_state = SMFS_DONE;
				break;

			  case SMFIR_PROGRESS:
				break;

			  case SMFIR_QUARANTINE:
				if (!bitset(SMFIF_QUARANTINE, m->mf_fflags))
				{
					if (MilterLogLevel > 9)
						sm_syslog(LOG_WARNING, e->e_id,
							  "milter_data(%s): lied about quarantining, honoring request anyway",
							  m->mf_name);
				}
				if (response == NULL)
					response = newstr("");
				if (MilterLogLevel > 3)
					sm_syslog(LOG_INFO, e->e_id,
						  "milter=%s, quarantine=%s",
						  m->mf_name, response);
				e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool,
								 response);
				macdefine(&e->e_macro, A_PERM,
					  macid("{quarantine}"), e->e_quarmsg);
				break;

			  case SMFIR_ADDHEADER:
				if (!bitset(SMFIF_ADDHDRS, m->mf_fflags))
				{
					if (MilterLogLevel > 9)
						sm_syslog(LOG_WARNING, e->e_id,
							  "milter_data(%s): lied about adding headers, honoring request anyway",
							  m->mf_name);
				}
				milter_addheader(m, response, rlen, e);
				break;

			  case SMFIR_INSHEADER:
				if (!bitset(SMFIF_ADDHDRS, m->mf_fflags))
				{
					if (MilterLogLevel > 9)
						sm_syslog(LOG_WARNING, e->e_id,
							  "milter_data(%s): lied about adding headers, honoring request anyway",
							  m->mf_name);
				}
				milter_insheader(m, response, rlen, e);
				break;

			  case SMFIR_CHGHEADER:
				if (!bitset(SMFIF_CHGHDRS, m->mf_fflags))
				{
					if (MilterLogLevel > 9)
						sm_syslog(LOG_WARNING, e->e_id,
							  "milter_data(%s): lied about changing headers, honoring request anyway",
							  m->mf_name);
				}
				milter_changeheader(m, response, rlen, e);
				break;

			  case SMFIR_CHGFROM:
				if (!bitset(SMFIF_CHGFROM, m->mf_fflags))
				{
					if (MilterLogLevel > 9)
						sm_syslog(LOG_WARNING, e->e_id,
							  "milter_data(%s) lied about changing sender, honoring request anyway",
							  m->mf_name);
				}
				milter_chgfrom(response, rlen, e);
				break;

			  case SMFIR_ADDRCPT:
				if (!bitset(SMFIF_ADDRCPT, m->mf_fflags))
				{
					if (MilterLogLevel > 9)
						sm_syslog(LOG_WARNING, e->e_id,
							  "milter_data(%s) lied about adding recipients, honoring request anyway",
							  m->mf_name);
				}
				milter_addrcpt(response, rlen, e);
				break;

			  case SMFIR_ADDRCPT_PAR:
				if (!bitset(SMFIF_ADDRCPT_PAR, m->mf_fflags))
				{
					if (MilterLogLevel > 9)
						sm_syslog(LOG_WARNING, e->e_id,
							  "milter_data(%s) lied about adding recipients with parameters, honoring request anyway",
							  m->mf_name);
				}
				milter_addrcpt_par(response, rlen, e);
				break;

			  case SMFIR_DELRCPT:
				if (!bitset(SMFIF_DELRCPT, m->mf_fflags))
				{
					if (MilterLogLevel > 9)
						sm_syslog(LOG_WARNING, e->e_id,
							  "milter_data(%s): lied about removing recipients, honoring request anyway",
							  m->mf_name);
				}
				milter_delrcpt(response, rlen, e);
				break;

			  case SMFIR_REPLBODY:
				if (!bitset(SMFIF_MODBODY, m->mf_fflags))
				{
					if (MilterLogLevel > 0)
						sm_syslog(LOG_ERR, e->e_id,
							  "milter_data(%s): lied about replacing body, rejecting request and tempfailing message",
							  m->mf_name);
					replfailed = true;
					break;
				}

				/* already failed in attempt */
				if (replfailed)
					break;

				if (!dfopen)
				{
					if (milter_reopen_df(e) < 0)
					{
						replfailed = true;
						break;
					}
					dfopen = true;
					rewind = true;
				}

				if (milter_replbody(response, rlen,
						    newfilter, e) < 0)
					replfailed = true;
				newfilter = false;
				replbody = true;
				break;

			  default:
				/* Invalid response to command */
				if (MilterLogLevel > 0)
					sm_syslog(LOG_ERR, e->e_id,
						  "milter_data(%s): returned bogus response %c",
						  m->mf_name, rcmd);
				milter_error(m, e);
				break;
			}
			if (rcmd != SMFIR_REPLYCODE && response != NULL)
			{
				sm_free(response); /* XXX */
				response = NULL;
			}

			if (m->mf_state == SMFS_ERROR)
				break;
		}

		if (replbody && !replfailed)
		{
			/* flush possible buffered character */
			milter_replbody(NULL, 0, !replbody, e);
			replbody = false;
		}

		if (m->mf_state == SMFS_ERROR)
		{
			MILTER_CHECK_ERROR(false, continue);
			goto finishup;
		}
	}

finishup:
	/* leave things in the expected state if we touched it */
	if (replfailed)
	{
		if (*state == SMFIR_CONTINUE ||
		    *state == SMFIR_ACCEPT)
		{
			*state = SMFIR_TEMPFAIL;
			SM_FREE_CLR(response);
		}

		if (dfopen)
		{
			(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT);
			e->e_dfp = NULL;
			e->e_flags &= ~EF_HAS_DF;
			dfopen = false;
		}
		rewind = false;
	}

	if ((dfopen && milter_reset_df(e) < 0) ||
	    (rewind && bfrewind(e->e_dfp) < 0))
	{
		save_errno = errno;
		ExitStat = EX_IOERR;

		/*
		**  If filter told us to keep message but we had
		**  an error, we can't really keep it, tempfail it.
		*/

		if (*state == SMFIR_CONTINUE ||
		    *state == SMFIR_ACCEPT)
		{
			*state = SMFIR_TEMPFAIL;
			SM_FREE_CLR(response);
		}

		errno = save_errno;
		syserr("milter_data: %s/%cf%s: read error",
		       qid_printqueue(e->e_qgrp, e->e_qdir),
		       DATAFL_LETTER, e->e_id);
	}

	MILTER_CHECK_DONE_MSG();
	if (MilterLogLevel > 10 && *state == SMFIR_REJECT)
		sm_syslog(LOG_INFO, e->e_id, "Milter: reject, data");
	return response;
}

/*
**  MILTER_UNKNOWN -- send any unrecognized or unimplemented command
**			string to milter filters
**
**	Parameters:
**		smtpcmd -- the string itself.
**		e -- current envelope.
**		state -- return state from response.
**
**
**	Returns:
**		response string (may be NULL)
*/

char *
milter_unknown(smtpcmd, e, state)
	char *smtpcmd;
	ENVELOPE *e;
	char *state;
{
	if (tTd(64, 10))
		sm_dprintf("milter_unknown(%s)\n", smtpcmd);

	return milter_command(SMFIC_UNKNOWN, smtpcmd, strlen(smtpcmd) + 1,
				SMFIM_NOMACROS, e, state, "unknown", false);
}

/*
**  MILTER_QUIT -- informs the filter(s) we are done and closes connection(s)
**
**	Parameters:
**		e -- current envelope.
**
**	Returns:
**		none
*/

void
milter_quit(e)
	ENVELOPE *e;
{
	int i;

	if (tTd(64, 10))
		sm_dprintf("milter_quit(%s)\n", e->e_id);

	for (i = 0; InputFilters[i] != NULL; i++)
		milter_quit_filter(InputFilters[i], e);
}

/*
**  MILTER_ABORT -- informs the filter(s) that we are aborting current message
**
**	Parameters:
**		e -- current envelope.
**
**	Returns:
**		none
*/

void
milter_abort(e)
	ENVELOPE *e;
{
	int i;

	if (tTd(64, 10))
		sm_dprintf("milter_abort\n");

	for (i = 0; InputFilters[i] != NULL; i++)
	{
		struct milter *m = InputFilters[i];

		/* sanity checks */
		if (m->mf_sock < 0 || m->mf_state != SMFS_INMSG)
			continue;

		milter_abort_filter(m, e);
	}
}
#endif /* MILTER */
@


1.32
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.31
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2009, 2012, 2013 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.280 2013/01/16 18:48:36 ca Exp $")
@


1.30
log
@Update to sendmail 8.14.6
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2009 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.279 2012/11/16 20:25:03 ca Exp $")
d2187 1
a2187 1
**		macros -- macros to send for filter smfi_getsymval().
a2330 1

d4050 1
a4050 1
				  SMFIM_EOH, e, state, "helo", false);
@


1.29
log
@Update to sendmail 8.14.5
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.277 2009/11/06 00:57:06 ca Exp $")
d45 1
a45 1
static char	*milter_command __P((int, void *, ssize_t, char **,
d82 7
a88 7
static char *MilterConnectMacros[MAXFILTERMACROS + 1];
static char *MilterHeloMacros[MAXFILTERMACROS + 1];
static char *MilterEnvFromMacros[MAXFILTERMACROS + 1];
static char *MilterEnvRcptMacros[MAXFILTERMACROS + 1];
static char *MilterDataMacros[MAXFILTERMACROS + 1];
static char *MilterEOMMacros[MAXFILTERMACROS + 1];
static char *MilterEOHMacros[MAXFILTERMACROS + 1];
d101 10
d132 1
a132 6
	else if (bitnset(SMF_TEMPFAIL, m->mf_flags)) \
		*state = SMFIR_TEMPFAIL; \
	else if (bitnset(SMF_TEMPDROP, m->mf_flags)) \
		*state = SMFIR_SHUTDOWN; \
	else if (bitnset(SMF_REJECT, m->mf_flags)) \
		*state = SMFIR_REJECT; \
d1229 1
d1332 1
d1334 2
d1567 7
a1573 14
# define MO_MACROS_CONNECT		SMFIM_CONNECT
	{ "macros.connect",		MO_MACROS_CONNECT		},
# define MO_MACROS_HELO			SMFIM_HELO
	{ "macros.helo",		MO_MACROS_HELO			},
# define MO_MACROS_ENVFROM		SMFIM_ENVFROM
	{ "macros.envfrom",		MO_MACROS_ENVFROM		},
# define MO_MACROS_ENVRCPT		SMFIM_ENVRCPT
	{ "macros.envrcpt",		MO_MACROS_ENVRCPT		},
# define MO_MACROS_DATA			SMFIM_DATA
	{ "macros.data",		MO_MACROS_DATA			},
# define MO_MACROS_EOM			SMFIM_EOM
	{ "macros.eom",			MO_MACROS_EOM			},
# define MO_MACROS_EOH			SMFIM_EOH
	{ "macros.eoh",			MO_MACROS_EOH			},
d1660 8
a1667 33
	  case MO_MACROS_CONNECT:
		if (macros == NULL)
			macros = MilterConnectMacros;
		/* FALLTHROUGH */

	  case MO_MACROS_HELO:
		if (macros == NULL)
			macros = MilterHeloMacros;
		/* FALLTHROUGH */

	  case MO_MACROS_ENVFROM:
		if (macros == NULL)
			macros = MilterEnvFromMacros;
		/* FALLTHROUGH */

	  case MO_MACROS_ENVRCPT:
		if (macros == NULL)
			macros = MilterEnvRcptMacros;
		/* FALLTHROUGH */

	  case MO_MACROS_EOH:
		if (macros == NULL)
			macros = MilterEOHMacros;
		/* FALLTHROUGH */

	  case MO_MACROS_EOM:
		if (macros == NULL)
			macros = MilterEOMMacros;
		/* FALLTHROUGH */

	  case MO_MACROS_DATA:
		if (macros == NULL)
			macros = MilterDataMacros;
d2168 1
a2168 1
		milter_error(m, e);
d2198 1
a2198 1
milter_command(cmd, data, sz, macros, e, state, where, cmd_error)
d2202 1
a2202 1
	char **macros;
d2234 1
a2234 2
		/* send macros (regardless of whether we send command) */
		if (macros != NULL && macros[0] != NULL)
d2236 12
a2247 2
			milter_send_macros(m, macros, command, e);
			if (m->mf_state == SMFS_ERROR)
d2249 6
a2254 2
				MILTER_CHECK_ERROR(false, continue);
				break;
d2322 9
a2330 33
		  case MO_MACROS_CONNECT:
			if (macros == NULL)
				macros = MilterConnectMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_HELO:
			if (macros == NULL)
				macros = MilterHeloMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_ENVFROM:
			if (macros == NULL)
				macros = MilterEnvFromMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_ENVRCPT:
			if (macros == NULL)
				macros = MilterEnvRcptMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_EOM:
			if (macros == NULL)
				macros = MilterEOMMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_EOH:
			if (macros == NULL)
				macros = MilterEOHMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_DATA:
			if (macros == NULL)
				macros = MilterDataMacros;
d2332 1
d2340 3
d3962 1
a3962 1
	response = milter_command(SMFIC_CONNECT, buf, s, MilterConnectMacros,
d4051 1
a4051 1
				  MilterHeloMacros, e, state, "helo", false);
d4139 1
a4139 1
	response = milter_command(SMFIC_MAIL, buf, s, MilterEnvFromMacros,
d4220 1
a4220 1
	response = milter_command(SMFIC_RCPT, buf, s, MilterEnvRcptMacros,
d4246 2
a4247 2
	return milter_command(SMFIC_DATA, NULL, 0, MilterDataMacros, e, state,
				"data", false);
d4266 1
d4268 4
d4317 2
d4363 8
a4370 1
			if (MilterEOHMacros[0] != NULL)
d4372 1
a4372 2
				milter_send_macros(m, MilterEOHMacros,
					   SMFIC_EOH, e);
d4391 7
a4397 1
		if (MilterEOMMacros[0] != NULL)
d4399 1
a4399 2
			milter_send_macros(m, MilterEOMMacros,
					   SMFIC_BODYEOB, e);
d4725 1
a4725 1
				NULL, e, state, "unknown", false);
@


1.28
log
@Update to sendmail-8.14.3
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2006 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.269 2007/06/06 17:26:12 ca Exp $")
a516 1
	time_t writestart = (time_t) 0;
d534 6
a539 2
			sm_dprintf("milter_write(%s): length %ld out of range\n",
				m->mf_name, (long) len);
d542 2
a543 2
				  "milter_write(%s): length %ld out of range",
				  m->mf_name, (long) len);
a599 2
	{
		writestart = curtime();
a600 1
	}
d1575 1
a1575 1
# if _FFR_MAXDATASIZE
d1578 1
a1578 1
# endif /* _FFR_MAXDATASIZE */
d1634 1
a1634 1
#if _FFR_MAXDATASIZE
d1636 1
d1638 17
d1656 1
a1656 1
#endif /* _FFR_MAXDATASIZE */
d2432 6
d2552 33
d3036 1
a3036 1
			h->h_value = addleadingspace (mh_value, e->e_rpool);
d3337 1
a3337 1
			h->h_value = addleadingspace (mh_value, e->e_rpool);
d3390 1
a3390 1
	s = (char **)malloc(nelem * (sizeof(*s)));
d3873 1
a3873 1
			/* if negotation failure, close socket */
d4443 1
a4443 1
						"body");
@


1.27
log
@Update to sendmail-8.14.1
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.267 2007/02/27 22:21:12 ca Exp $")
d54 2
a55 1
static int	milter_negotiate __P((struct milter *, ENVELOPE *));
a1794 35
**  MILTER_CAN_DELRCPTS -- can any milter filters delete recipients?
**
**	Parameters:
**		none
**
**	Returns:
**		true if any filter deletes recipients, false otherwise
*/

bool
milter_can_delrcpts()
{
	bool can = false;
	int i;

	if (tTd(64, 10))
		sm_dprintf("milter_can_delrcpts:");

	for (i = 0; InputFilters[i] != NULL; i++)
	{
		struct milter *m = InputFilters[i];

		if (bitset(SMFIF_DELRCPT, m->mf_fflags))
		{
			can = true;
			break;
		}
	}
	if (tTd(64, 10))
		sm_dprintf("%s\n", can ? "true" : "false");

	return can;
}

/*
d2375 1
d2382 1
a2382 1
milter_negotiate(m, e)
d2385 1
d2554 6
d3761 1
d3769 1
a3769 1
milter_init(e, state)
d3772 1
d3779 1
d3801 1
a3801 1
		    milter_negotiate(m, e) < 0 ||
@


1.26
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.266 2006/11/29 00:20:41 ca Exp $")
d1245 1
a1245 1
#if MILTER_CHECK
d1249 1
a1249 1
#endif /* MILTER_CHECK */
d1297 1
a1297 1
#if MILTER_CHECK
d1307 1
a1307 1
#endif /* MILTER_CHECK */
d2437 1
a2437 1
#if MILTER_CHECK
d2441 1
a2441 1
#else /* MILTER_CHECK */
d2445 1
a2445 1
#endif /* MILTER_CHECK */
@


1.25
log
@Update to sendmail 8.13.6
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2005 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.232 2005/08/05 21:49:04 ca Exp $")
d16 1
d26 1
a26 1
#  if _FFR_MILTER_NAGLE
d28 1
a28 1
#  endif /* _FFR_MILTER_NAGLE */
d37 43
d87 1
d194 1
a194 1
# define MILTER_TIMEOUT(routine, secs, write, started) \
d232 2
a233 2
			sm_dprintf("milter_%s(%s): timeout\n", (routine), \
				   m->mf_name); \
d236 2
a237 2
				  "Milter (%s): %s %s %s %s", \
				  m->mf_name, "timeout", \
d239 1
a239 1
				  "data", (routine)); \
d294 1
a294 1
milter_sysread(m, buf, sz, to, e)
d300 1
d321 2
a322 2
					sm_dprintf("milter_read (%s): %s %s %s",
						  m->mf_name, "timeout",
d324 1
a324 1
						  "data read");
d327 2
a328 2
						  "Milter (%s): %s %s %s",
						  m->mf_name, "timeout",
d330 1
a330 1
						  "data read");
d336 1
a336 1
			MILTER_TIMEOUT("read", to, false, started);
d346 1
a346 1
				sm_dprintf("milter_read(%s): read returned %ld: %s\n",
d368 1
a368 1
			sm_dprintf("milter_read(%s): cmd read returned %ld, expecting %ld\n",
d372 1
a372 1
				  "milter_read(%s): cmd read returned %ld, expecting %ld",
d381 1
a381 1
milter_read(m, cmd, rlen, to, e)
d387 1
d392 1
a392 2
# if _FFR_MILTER_NAGLE
#  ifdef TCP_CORK
d394 1
a394 2
#  endif
# endif /* _FFR_MILTER_NAGLE */
d402 2
a403 2
				  "milter_read(%s): socket closed",
				  m->mf_name);
d414 1
a414 2
# if _FFR_MILTER_NAGLE
#  ifdef TCP_CORK
d417 1
a417 2
#  endif
# endif /* _FFR_MILTER_NAGLE */
d419 1
a419 1
	if (milter_sysread(m, data, sizeof data, to, e) == NULL)
d422 1
a422 2
# if _FFR_MILTER_NAGLE
#  ifdef TCP_CORK
d426 1
a426 2
#  endif
# endif /* _FFR_MILTER_NAGLE */
d437 2
a438 2
				sm_dprintf("milter_read(%s): timeout before data read\n",
					m->mf_name);
d441 2
a442 2
					  "Milter read(%s): timeout before data read",
					  m->mf_name);
d461 2
a462 2
			sm_dprintf("milter_read(%s): read size %ld out of range\n",
				m->mf_name, (long) expl);
d465 2
a466 2
				  "milter_read(%s): read size %ld out of range",
				  m->mf_name, (long) expl);
d476 1
a476 1
	if (milter_sysread(m, buf, expl, to, e) == NULL)
d507 1
a507 1
milter_write(m, cmd, buf, len, to, e)
d509 1
a509 1
	char cmd;
d514 1
d520 1
d555 1
a555 1
			   m->mf_name, cmd, (long) len);
d557 1
a557 1
	nl = htonl(len + 1);	/* add 1 for the cmd char */
d559 1
a559 1
	data[MILTER_LEN_BYTES] = cmd;
d598 1
a598 1
		MILTER_TIMEOUT("write", to, true, started);
d609 1
a609 1
				   m->mf_name, cmd, (long) i, (long) sl,
d614 1
a614 1
				  m->mf_name, cmd, (long) i, (long) sl,
d675 1
a675 1
	memset(&addr, '\0', sizeof addr);
d755 1
a755 1
		if (strlen(colon) >= sizeof addr.sunix.sun_path)
d808 2
a809 2
			       sizeof addr.sunix.sun_path);
		addrlen = sizeof (struct sockaddr_un);
d861 1
a861 1
			register struct servent *sp;
d911 1
a911 1
				(void) memset(&hid6, '\0', sizeof hid6);
d982 1
a982 1
				addrlen = sizeof (struct sockaddr_in);
d992 1
a992 1
				addrlen = sizeof (struct sockaddr_in6);
d1180 1
a1180 2
# if _FFR_MILTER_NAGLE
#  ifndef TCP_CORK
d1187 1
a1187 2
#  endif /* TCP_CORK */
# endif /* _FFR_MILTER_NAGLE */
d1204 1
d1220 2
a1221 2
	register char *p;
	register struct milter *m;
d1236 2
a1237 2
	m = (struct milter *) xalloc(sizeof *m);
	memset((char *) m, '\0', sizeof *m);
d1245 5
d1297 12
d1327 1
d1349 1
a1349 1
	register char *p;
d1390 1
d1411 1
a1411 1
	register char *p;
d1478 57
d1557 1
a1557 1
# define MO_MACROS_CONNECT		0x01
d1559 1
a1559 1
# define MO_MACROS_HELO			0x02
d1561 1
a1561 1
# define MO_MACROS_ENVFROM		0x03
d1563 1
a1563 1
# define MO_MACROS_ENVRCPT		0x04
d1565 1
a1565 1
# define MO_MACROS_DATA			0x05
d1567 1
a1567 1
# define MO_MACROS_EOM			0x06
d1569 3
d1575 1
a1575 1
#  define MO_MAXDATASIZE			0x08
d1578 1
a1578 1
	{ NULL,				0				},
d1587 2
a1588 3
	int nummac = 0;
	register struct milteropt *mo;
	char *p;
d1591 1
d1659 5
d1673 3
a1675 31
		p = newstr(val);
		while (*p != '\0')
		{
			char *macro;

			/* Skip leading commas, spaces */
			while (*p != '\0' &&
			       (*p == ',' || (isascii(*p) && isspace(*p))))
				p++;

			if (*p == '\0')
				break;

			/* Find end of macro */
			macro = p;
			while (*p != '\0' && *p != ',' &&
			       isascii(*p) && !isspace(*p))
				p++;
			if (*p != '\0')
				*p++ = '\0';

			if (nummac >= MAXFILTERMACROS)
			{
				syserr("milter_set_option: too many macros in Milter.%s (max %d)",
				       name, MAXFILTERMACROS);
				macros[nummac] = NULL;
				break;
			}
			macros[nummac++] = macro;
		}
		macros[nummac] = NULL;
d1685 1
d1702 1
a1702 1
	(void) sm_strlcpy(dfname, queuename(e, DATAFL_LETTER), sizeof dfname);
d1740 1
d1758 1
a1758 1
	(void) sm_strlcpy(dfname, queuename(e, DATAFL_LETTER), sizeof dfname);
d1792 1
d1827 1
d1864 1
a1864 1
			    m->mf_timeout[SMFTO_WRITE], e);
d1873 1
d1901 1
a1901 1
			    m->mf_timeout[SMFTO_WRITE], e);
d1905 1
d1923 1
a1923 1
	char cmd;
d1928 1
d1957 1
a1957 1
	*bp++ = cmd;
d1970 1
a1970 1
				m->mf_name, cmd, macros[i], exp);
d1978 1
a1978 1
			    m->mf_timeout[SMFTO_WRITE], e);
d1987 1
a1987 1
**		command -- command to send.
d1998 1
a1998 1
milter_send_command(m, command, data, sz, e, state)
d2000 1
a2000 1
	char command;
d2005 1
a2009 1
#if _FFR_MILTER_NOHDR_RESP
d2011 1
a2011 1
#endif /* _FFR_MILTER_NOHDR_RESP */
d2025 1
d2032 1
d2039 1
d2046 1
d2053 1
a2053 3
#if _FFR_MILTER_NOHDR_RESP
		norespflag = SMFIP_NOHREPL;
#endif /* _FFR_MILTER_NOHDR_RESP */
d2060 1
d2067 1
a2071 1
#if SMFI_VERSION > 2
d2074 1
a2077 1
#endif /* SMFI_VERSION > 2 */
a2078 1
#if SMFI_VERSION > 3
d2081 1
a2084 1
#endif /* SMFI_VERSION > 3 */
d2101 4
d2106 1
a2106 2
	if (skipflag != 0 &&
	    bitset(skipflag, m->mf_pflags))
d2111 1
a2111 1
			    m->mf_timeout[SMFTO_WRITE], e);
a2117 1
#if _FFR_MILTER_NOHDR_RESP
a2120 1
#endif /* _FFR_MILTER_NOHDR_RESP */
d2124 1
a2124 1
			       m->mf_timeout[SMFTO_READ], e);
d2140 2
a2141 1
			sm_syslog(LOG_INFO, e->e_id, "milter=%s, action=%s, reject=%s",
d2148 2
a2149 1
			sm_syslog(LOG_INFO, e->e_id, "milter=%s, action=%s, reject",
d2156 2
a2157 1
			sm_syslog(LOG_INFO, e->e_id, "milter=%s, action=%s, discard",
d2164 2
a2165 1
			sm_syslog(LOG_INFO, e->e_id, "milter=%s, action=%s, tempfail",
d2178 2
a2179 1
			sm_syslog(LOG_INFO, e->e_id, "milter=%s, action=%s, accepted",
d2188 9
a2196 1
			sm_syslog(LOG_INFO, e->e_id, "milter=%s, action=%s, continue",
d2198 1
d2211 1
a2211 2
	if (*state != SMFIR_REPLYCODE &&
	    response != NULL)
d2223 1
a2223 1
**		command -- command to send.
d2229 2
d2237 2
a2238 2
milter_command(command, data, sz, macros, e, state)
	char command;
d2244 2
d2248 1
d2254 1
a2254 1
			(char) command, (long) sz);
d2287 16
a2302 1
		response = milter_send_command(m, command, data, sz, e, state);
d2317 86
d2420 2
a2421 4
	mi_int32 fvers;
	mi_int32 fflags;
	mi_int32 pflags;
	mi_int32 curr_prot;
d2437 13
a2449 14
	fvers = htonl(SMFI_VERSION);
	fflags = htonl(SMFI_CURR_ACTS);
	curr_prot = SMFI_V2_PROT
#if _FFR_MILTER_NOHDR_RESP
			| SMFIP_NOHREPL
#endif /* _FFR_MILTER_NOHDR_RESP */
#if SMFI_VERSION >= 3
			| SMFIP_NOUNKNOWN
# if SMFI_VERSION >= 4
			| SMFIP_NODATA
# endif /* SMFI_VERSION >= 4 */
#endif /* SMFI_VERSION >= 3 */
			;
	pflags = htonl(curr_prot);
d2455 2
a2456 2
	(void) milter_write(m, SMFIC_OPTNEG, data, sizeof data,
			    m->mf_timeout[SMFTO_WRITE], e);
d2461 6
a2466 1
	response = milter_read(m, &rcmd, &rlen, m->mf_timeout[SMFTO_READ], e);
d2505 1
a2505 1
	if (rlen != MILTER_OPTLEN)
a2523 2
	sm_free(response); /* XXX */
	response = NULL;
d2541 1
a2541 1
		return -1;
d2545 1
a2545 1
	if ((m->mf_fflags & SMFI_CURR_ACTS) != m->mf_fflags)
d2550 1
a2550 1
				SMFI_CURR_ACTS);
d2555 1
a2555 1
				  (unsigned long) SMFI_CURR_ACTS);
d2557 1
a2557 1
		return -1;
d2561 1
a2561 1
	if ((m->mf_pflags & curr_prot) != m->mf_pflags)
d2566 1
a2566 1
				(unsigned long) curr_prot);
d2571 1
a2571 1
				  (unsigned long) curr_prot);
d2573 1
a2573 1
		return -1;
d2581 5
d2587 1
a2587 1
		sm_dprintf("milter_negotiate(%s): version %u, fflags 0x%x, pflags 0x%x\n",
d2590 5
d2596 1
d2624 1
d2657 1
d2685 2
a2686 2
		char *buf;
		ssize_t s;
d2701 1
a2701 1
			sm_dprintf("milter_headers: %s: %s\n",
d2707 8
a2714 2
		s = strlen(h->h_field) + 1 + strlen(h->h_value) + 1;
		if (s < 0)
d2716 13
a2728 3
		buf = (char *) xalloc(s);
		(void) sm_snprintf(buf, s, "%s%c%s",
			h->h_field, '\0', h->h_value);
d2732 2
a2733 2
					       s, e, state);
		sm_free(buf); /* XXX */
d2744 1
d2792 1
d2795 1
d2798 1
a2798 1
				if (bp + 2 > &buf[sizeof buf])
d2816 1
a2816 1
		if (bp >= &buf[sizeof buf])
d2820 2
a2821 1
						       bp - buf, e, state);
d2832 1
d2842 2
a2843 1
		    *state == SMFIR_ACCEPT)
d2862 1
d2867 1
a2867 1
					       e, state);
d2873 6
d2887 31
d2921 1
d2931 2
a2932 1
milter_addheader(response, rlen, e)
d2937 2
a2938 1
	char *val;
d2955 2
a2956 1
			sm_dprintf("didn't follow protocol (total len)\n");
d2986 3
d2996 1
a2996 1
				   h->h_field, val);
d3000 8
a3007 2
				  h->h_field, val);
		h->h_value = newstr(val);
d3013 1
a3013 1
			sm_dprintf("Add %s: %s\n", response, val);
d3015 6
a3020 3
			sm_syslog(LOG_INFO, e->e_id, "Milter add: header: %s: %s",
				  response, val);
		addheader(newstr(response), val, H_USER, e);
d3023 1
d3028 1
d3043 2
a3044 1
milter_insheader(response, rlen, e)
d3050 2
a3051 2
	char *field;
	char *val;
d3097 1
a3097 1
		sm_dprintf("Insert (%d) %s: %s\n", idx, response, val);
d3102 5
a3106 1
	insheader(idx, newstr(field), val, H_USER, e);
d3108 1
d3113 1
d3123 2
a3124 1
milter_changeheader(response, rlen, e)
d3130 2
a3131 1
	char *field, *val;
d3174 3
d3182 1
a3182 2
			if (bitset(H_USER, h->h_flags) &&
			    --index <= 0)
d3221 1
a3221 1
				sm_dprintf("Add %s: %s\n", field, val);
d3225 3
a3227 2
					, field, val);
			addheader(newstr(field), val, H_USER, e);
d3236 1
a3236 1
			sm_dprintf("Delete%s %s: %s\n",
d3247 1
a3247 1
				   val);
d3256 1
a3256 1
				  "Milter delete: header%s %s: %s",
d3268 1
a3268 1
				  val);
d3298 1
d3302 7
a3308 1
		h->h_value = newstr(val);
d3313 216
d3578 1
d3612 2
a3613 1
			sm_dprintf("didn't follow protocol (total len)\n");
d3625 1
d3659 1
a3659 1
				  sizeof dfname);
d3862 1
d3925 1
a3925 1
				       sizeof buf6);
d3947 2
a3948 2
	(void) memcpy(bp, &family, sizeof family);
	bp += sizeof family;
d3951 2
a3952 2
		(void) memcpy(bp, &port, sizeof port);
		bp += sizeof port;
d3958 2
a3959 2
	response = milter_command(SMFIC_CONNECT, buf, s,
				  MilterConnectMacros, e, state);
d4002 1
d4047 1
a4047 1
				  MilterHeloMacros, e, state);
d4051 1
d4132 1
a4132 1
		sm_syslog(LOG_INFO, e->e_id, "Milter: senders: %s", buf);
d4135 2
a4136 2
	response = milter_command(SMFIC_MAIL, buf, s,
				  MilterEnvFromMacros, e, state);
d4147 1
a4147 1
		sm_syslog(LOG_INFO, e->e_id, "Milter: reject, senders");
d4158 1
d4165 1
a4165 1
milter_envrcpt(args, e, state)
d4169 1
d4216 2
a4217 2
	response = milter_command(SMFIC_RCPT, buf, s,
				  MilterEnvRcptMacros, e, state);
a4221 1
#if SMFI_VERSION > 3
d4242 2
a4243 1
	return milter_command(SMFIC_DATA, NULL, 0, MilterDataMacros, e, state);
a4244 1
#endif /* SMFI_VERSION > 3 */
d4352 7
d4361 1
a4361 1
						       e, state);
d4383 1
a4383 1
				    m->mf_timeout[SMFTO_WRITE], e);
d4408 2
a4409 1
					       m->mf_timeout[SMFTO_READ], e);
d4493 1
a4493 1
				milter_addheader(response, rlen, e);
d4504 1
a4504 1
				milter_insheader(response, rlen, e);
d4515 12
a4526 1
				milter_changeheader(response, rlen, e);
d4540 11
a4678 1
#if SMFI_VERSION > 2
d4684 1
a4684 1
**		cmd -- the string itself.
d4694 2
a4695 2
milter_unknown(cmd, e, state)
	char *cmd;
d4700 1
a4700 1
		sm_dprintf("milter_unknown(%s)\n", cmd);
d4702 2
a4703 2
	return milter_command(SMFIC_UNKNOWN, cmd, strlen(cmd) + 1,
				NULL, e, state);
a4704 1
#endif /* SMFI_VERSION > 2 */
d4728 1
@


1.24
log
@update to sendmail 8.13.4
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.229 2005/03/02 02:32:34 ca Exp $")
d20 1
a20 1
# include <sys/time.h>
d1965 1
d1971 8
d2196 2
a2198 1
	ssize_t rlen;
d2214 12
a2225 1
	pflags = htonl(SMFI_CURR_PROT);
d2334 1
a2334 1
	if ((m->mf_pflags & SMFI_CURR_PROT) != m->mf_pflags)
d2339 1
a2339 1
				(unsigned long) SMFI_CURR_PROT);
d2344 1
a2344 1
				  (unsigned long) SMFI_CURR_PROT);
d2349 5
d2718 4
a2721 4
**  	Notes:
**  		Unlike milter_addheader(), this does not attempt to determine
**  		if the header already exists in the envelope, even a
**  		deleted version.  It just blindly inserts.
d2781 1
a2781 1
		          "Milter insert (%d): header: %s: %s",
@


1.23
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2004 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.228 2004/11/09 18:54:55 ca Exp $")
d353 10
d500 9
d1874 1
a1874 1
	sm_free(buf); /* XXX */
d3782 1
d3785 2
@


1.22
log
@Update to sendmail-8.13.1
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.225 2004/07/08 21:52:20 ca Exp $")
d32 1
a32 1
static void	milter_connect_timeout __P((void));
d78 2
d1132 2
a1133 1
milter_connect_timeout()
d2346 1
d2358 2
a2359 4
	**  We could send a quit here but
	**  we may have gotten here due to
	**  an I/O error so we don't want
	**  to try to make things worse.
d2837 5
a2841 1
				sm_dprintf("Delete (noop) %s:\n", field);
d2848 4
@


1.21
log
@Update to sendmail.8.13.0
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.223 2004/06/11 05:04:04 ca Exp $")
d43 1
d476 1
a476 1
	if (len < 0 || len > MILTER_CHUNK_SIZE)
d1431 4
d1490 6
d1589 2
a1590 3
	**  buffered file I/O descriptor, still open for writing
	**  so there isn't as much work to do, just truncate it
	**  and go.
d1644 1
a1644 1
	else if (SuperSafe != SAFE_REALLY && SuperSafe != SAFE_REALLY_POSTMILTER)
@


1.20
log
@Update to sendmail 8.12.11.  I've been runninga beta version of this for
some time without problems.  See the RELEASE_NOTES for the change log.
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2003 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.197.2.10 2003/12/01 23:57:44 msk Exp $")
d21 1
d25 3
d41 1
a41 1
#if _FFR_MILTER_MACROS_EOM
a42 1
#endif /* _FFR_MILTER_MACROS_EOM */
d54 1
a54 2
# if _FFR_QUARANTINE
#  define MILTER_CHECK_ERROR(initial, action) \
a80 9
# else /* _FFR_QUARANTINE */
#  define MILTER_CHECK_ERROR(initial, action) \
	if (bitnset(SMF_TEMPFAIL, m->mf_flags)) \
		*state = SMFIR_TEMPFAIL; \
	else if (bitnset(SMF_REJECT, m->mf_flags)) \
		*state = SMFIR_REJECT; \
	else \
		action;
# endif /* _FFR_QUARANTINE */
d342 5
d356 7
d366 8
d434 1
d463 1
d467 7
d497 12
a508 1
	if (to > 0)
d510 2
a511 2
		writestart = curtime();
		MILTER_TIMEOUT("write", to, true, started);
d513 1
a513 4

	/* use writev() instead to send the whole stuff at once? */
	i = write(m->mf_sock, (void *) data, sl);
	if (i != sl)
d515 4
a518 1
		int save_errno = errno;
d520 8
a527 11
		if (tTd(64, 5))
			sm_dprintf("milter_write (%s): write(%c) returned %ld, expected %ld: %s\n",
				   m->mf_name, cmd, (long) i, (long) sl,
				   sm_errstring(save_errno));
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): write(%c) returned %ld, expected %ld: %s",
				  m->mf_name, cmd, (long) i, (long) sl,
				  sm_errstring(save_errno));
		milter_error(m, e);
		return buf;
a529 8
	if (len <= 0 || buf == NULL)
		return buf;

	if (tTd(64, 50))
		sm_dprintf("milter_write(%s): Sending %*s\n",
			   m->mf_name, (int) len, buf);
	started = true;

d532 2
a533 20
		time_t now;

		now = curtime();
		if (now - writestart >= to)
		{
			if (tTd(64, 5))
				sm_dprintf("milter_write(%s): timeout before data write\n",
					   m->mf_name);
			if (MilterLogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "Milter (%s): timeout before data write",
					  m->mf_name);
			milter_error(m, e);
			return NULL;
		}
		else
		{
			to -= now - writestart;
			MILTER_TIMEOUT("write", to, true, started);
		}
d536 3
a538 2
	i = write(m->mf_sock, (void *) buf, len);
	if (i != len)
d549 1
a549 1
				  m->mf_name, cmd, (long) i, (long) len,
d1115 10
a1287 1
#if _FFR_MILTER_PERDAEMON
a1288 3
#else /* _FFR_MILTER_PERDAEMON */
		p = strpbrk(p, ",");
#endif /* _FFR_MILTER_PERDAEMON */
d1326 1
d1354 1
d1360 1
a1360 5
			m->mf_timeout[SMFTO_CONNECT] = convtime(p, 's');
			if (tTd(64, 5))
				sm_dprintf("X%s: %c=%lu\n",
					   m->mf_name, fcode,
					   (unsigned long) m->mf_timeout[SMFTO_CONNECT]);
d1364 1
a1364 5
			m->mf_timeout[SMFTO_WRITE] = convtime(p, 's');
			if (tTd(64, 5))
				sm_dprintf("X%s: %c=%lu\n",
					   m->mf_name, fcode,
					   (unsigned long) m->mf_timeout[SMFTO_WRITE]);
d1368 1
a1368 5
			m->mf_timeout[SMFTO_READ] = convtime(p, 's');
			if (tTd(64, 5))
				sm_dprintf("X%s: %c=%lu\n",
					   m->mf_name, fcode,
					   (unsigned long) m->mf_timeout[SMFTO_READ]);
d1372 1
a1372 5
			m->mf_timeout[SMFTO_EOM] = convtime(p, 's');
			if (tTd(64, 5))
				sm_dprintf("X%s: %c=%lu\n",
					   m->mf_name, fcode,
					   (unsigned long) m->mf_timeout[SMFTO_EOM]);
d1383 8
d1424 2
a1425 3
# define MO_LOGLEVEL			0x05
	{ "loglevel",			MO_LOGLEVEL			},
#if _FFR_MILTER_MACROS_EOM
d1428 2
a1429 1
#endif /* _FFR_MILTER_MACROS_EOM */
a1502 1
#if _FFR_MILTER_MACROS_EOM
d1508 5
a1512 1
#endif /* _FFR_MILTER_MACROS_EOM */
d1634 1
a1634 1
	else if (SuperSafe != SAFE_REALLY)
d1872 3
d1912 3
d1931 7
d1967 6
d2394 1
a2394 1
			/* strip H_USER so not counted in milter_chgheader() */
d2651 78
d2861 1
a2861 1
				  "Milter delete: header %s %s: %s",
d2869 1
a2869 1
				  "Milter change: header %s %s: from %s to %s",
d2956 2
a2957 2
  	(void) sendtolist(response, NULLADDR, &e->e_sendqueue, 0, e);
 	Errors = olderrors;
d3221 1
a3364 1
#if _FFR_MILTER_421
a3367 1
#endif /* _FFR_MILTER_421 */
d3526 1
d3595 26
a3741 1
#if _FFR_MILTER_MACROS_EOM
d3743 2
a3744 2
			milter_send_macros(m, MilterEOMMacros, SMFIC_BODYEOB, e);
#endif /* _FFR_MILTER_MACROS_EOM */
a3828 1
# if _FFR_QUARANTINE
a3847 1
# endif /* _FFR_QUARANTINE */
d3860 11
d3907 1
a3907 1
					if (MilterLogLevel > 9)
d4020 30
@


1.19
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.197.2.9 2003/09/07 00:18:29 ca Exp $")
d37 3
d1421 4
d1498 7
d3610 5
@


1.18
log
@Update to sendmail 8.12.9; fixes a buffer overflow in address parsing
due to a char to int conversion problem which is potentially remotely
exploitable.
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.197.2.7 2003/03/22 18:54:25 ca Exp $")
d1572 1
a1572 1
					   SM_IO_RDWR, NULL)) == NULL)
d1629 1
a1629 1
					SM_IO_RDONLY, NULL)) == NULL)
d2810 2
d2836 3
a2838 1
	(void) sendtolist(response, NULLADDR, &e->e_sendqueue, 0, e);
@


1.17
log
@Update to Sendmail 8.12.8; fixes a buffer overflow in the envelope
comments processing which may allow an attacker to gain root privileges.
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2002 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.197.2.6 2002/12/30 05:54:00 ca Exp $")
d49 12
a60 2
#  define MILTER_CHECK_ERROR(action) \
	if (tTd(71, 101)) \
d77 1
a77 1
#  define MILTER_CHECK_ERROR(action) \
d1928 1
a1928 1
		MILTER_CHECK_ERROR(return NULL);
d1937 1
a1937 1
		MILTER_CHECK_ERROR(return NULL);
d2056 1
a2056 1
			MILTER_CHECK_ERROR(continue);
d2071 1
a2071 1
				MILTER_CHECK_ERROR(continue);
d3075 1
a3075 1
			MILTER_CHECK_ERROR(continue);
d3097 1
a3097 1
			MILTER_CHECK_ERROR(continue);
d3554 1
a3554 1
			MILTER_CHECK_ERROR(continue);
d3615 1
a3615 1
				MILTER_CHECK_ERROR(break);
d3803 1
a3803 1
			MILTER_CHECK_ERROR(continue);
@


1.16
log
@update to sendmail 8.12.7
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.197.2.5 2002/11/11 23:22:28 ca Exp $")
@


1.15
log
@From Andrushock, s/sucess/success/g
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.197.2.2 2002/08/06 22:58:38 gshapiro Exp $")
d583 1
a583 1
		else if (MilterLogLevel > 10)
d614 4
a617 3
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): no valid socket protocols available",
				  m->mf_name);
d650 1
a650 1
			else if (MilterLogLevel > 10)
d681 1
a681 1
			else if (MilterLogLevel > 10)
d716 1
a716 1
			else if (MilterLogLevel > 10)
d752 1
a752 1
			else if (MilterLogLevel > 10)
d771 1
a771 1
			else if (MilterLogLevel > 10)
d791 1
a791 1
				else if (MilterLogLevel > 10)
d847 1
a847 1
					else if (MilterLogLevel > 10)
d863 1
a863 1
				else if (MilterLogLevel > 10)
d884 1
a884 1
				else if (MilterLogLevel > 10)
d922 1
a922 1
				else if (MilterLogLevel > 10)
d943 1
a943 1
		else if (MilterLogLevel > 10)
d3230 8
a3237 1
			*state = SMFIR_TEMPFAIL;
d3735 1
a3735 1
					if (MilterLogLevel > 0)
@


1.14
log
@update to sendmail-8.12.6
@
text
@d552 1
a552 1
**		connected socket if sucessful && !parseonly,
@


1.13
log
@sendmail 8.12.5
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.197 2002/06/12 22:33:48 gshapiro Exp $")
d48 20
a67 1
# define MILTER_CHECK_ERROR(action) \
d74 1
@


1.12
log
@Update to sendmail-8.12.4
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.196 2002/04/14 03:55:07 gshapiro Exp $")
d1403 6
@


1.11
log
@update to sendmail 8.12.3
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.194 2002/03/05 00:23:47 gshapiro Exp $")
d1735 1
d1752 2
a1753 1
		s += strlen(macros[i]) + 1 + strlen(v) + 1;
d1770 1
d1774 1
a1774 1
				m->mf_name, cmd, macros[i], v);
d1778 1
a1778 1
		(void) sm_strlcpy(bp, v, s - (bp - buf));
a2900 2
# if NOFTRUNCATE
			/* XXX: Not much we can do except rewind it */
d2916 10
a2929 1
# endif /* NOFTRUNCATE */
d2935 1
@


1.10
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.185 2001/11/21 02:21:15 gshapiro Exp $")
d142 11
a152 8
	FD_ZERO(&fds); \
	SM_FD_SET(m->mf_sock, &fds); \
	tv.tv_sec = (secs); \
	tv.tv_usec = 0; \
	ret = select(m->mf_sock + 1, \
		     (write) ? NULL : &fds, \
		     (write) ? &fds : NULL, \
		     NULL, &tv); \
d572 1
d1888 1
a1888 1
		MILTER_CHECK_ERROR(/* EMPTY */;);
d1897 1
a1897 1
		MILTER_CHECK_ERROR(/* EMPTY */;);
d2173 1
a2173 1
			sm_dprintf("milter_negotiate(%s): version %lu != MTA milter version %d\n",
d2177 1
a2177 1
				  "Milter (%s): negotiate: version %ld != MTA milter version %d",
d2187 1
a2187 1
			sm_dprintf("milter_negotiate(%s): filter abilities 0x%lx != MTA milter abilities 0x%lx\n",
d2189 1
a2189 1
				(unsigned long) SMFI_CURR_ACTS);
d2192 1
a2192 1
				  "Milter (%s): negotiate: filter abilities 0x%lx != MTA milter abilities 0x%lx",
d2203 1
a2203 1
			sm_dprintf("milter_negotiate(%s): protocol abilities 0x%lx != MTA milter abilities 0x%lx\n",
d2208 1
a2208 1
				  "Milter (%s): negotiate: protocol abilities 0x%lx != MTA milter abilities 0x%lx",
d2216 1
a2216 1
		sm_dprintf("milter_negotiate(%s): version %lu, fflags 0x%lx, pflags 0x%lx\n",
d2871 1
a2871 1
		off_t prevsize = 0;
d2881 3
a2883 9
		if (bitset(EF_HAS_DF, e->e_flags) && e->e_dfp != NULL)
		{
			int afd;
			struct stat st;

			afd = sm_io_getinfo(e->e_dfp, SM_IO_WHAT_FD, NULL);
			if (afd > 0 && fstat(afd, &st) == 0)
				prevsize = st.st_size;
		}
d3118 1
a3118 1
		port = htons(addr.sin.sin_port);
d3129 1
a3129 1
		port = htons(addr.sin6.sin6_port);
d3560 1
a3560 1
				MILTER_CHECK_ERROR(continue);
@


1.9
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.180 2001/09/17 20:39:57 gshapiro Exp $")
d1806 1
d1819 1
d1825 1
d1831 1
d1837 1
d1843 1
d1849 1
d1855 1
d1869 1
d1905 5
a1909 4
		if (MilterLogLevel > 8)
			sm_syslog(LOG_INFO, e->e_id, "milter=%s, reject=%s",
				  m->mf_name, response);
		/* FALLTHROUGH */
d1912 6
d1919 6
d1926 3
d1939 3
a1941 3
		if (MilterLogLevel > 8)
			sm_syslog(LOG_INFO, e->e_id, "Milter (%s): accepted",
				  m->mf_name);
d1948 3
d1957 2
a1958 2
				  "milter_send_command(%s): returned bogus response %c",
				  m->mf_name, rcmd);
d2716 7
a2722 1
		e->e_msgsize -= strlen(h->h_value);
d2730 9
a2738 1
			e->e_msgsize -= strlen(h->h_field) + 2;
d2935 1
a2935 1
	if (MilterLogLevel > 8)
d3043 1
a3043 1
				sm_syslog(LOG_INFO, e->e_id,
d3177 1
a3177 1
		if (MilterLogLevel > 7)
d3579 1
a3579 1
				if (MilterLogLevel > 8)
d3587 7
d3595 7
d3603 3
d3634 1
a3634 1
				if (MilterLogLevel > 8)
d3636 3
a3638 3
						  "Milter: quarantine: %s",
						  response);
				e->e_holdmsg = sm_rpool_strdup_x(e->e_rpool,
d3641 1
a3641 1
					  macid("{holdmsg}"), e->e_holdmsg);
@


1.8
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.173 2001/09/04 22:43:04 ca Exp $")
d202 1
a202 1
/*
d385 1
a385 1
/*
d520 1
a520 1
/*
d1087 1
a1087 1
/*
d1192 1
a1192 1
/*
d1258 1
a1258 1
/*
d1351 1
a1351 1
/*
d1491 2
a1492 2
/*
**  MILTER_REOPEN_DF -- open & truncate the df file (for replbody)
d1507 1
a1507 1
	(void) sm_strlcpy(dfname, queuename(e, 'd'), sizeof dfname);
d1522 1
a1522 1
		/* close read-only df */
d1546 2
a1547 2
/*
**  MILTER_RESET_DF -- re-open read-only the df file (for replbody)
d1563 1
a1563 1
	(void) sm_strlcpy(dfname, queuename(e, 'd'), sizeof dfname);
d1597 1
a1597 1
/*
d1631 1
a1631 1
/*
d1676 1
a1676 1
/*
d1707 1
a1707 1
/*
d1779 1
a1779 1
/*
d1944 1
a1944 1
/*
d2022 1
a2022 1
/*
d2188 1
a2188 1
/*
d2215 1
a2215 1
/*
d2248 1
a2248 1
/*
d2318 1
a2318 1
/*
d2350 3
a2352 2
		syserr("milter_body: %s/df%s: rewind error",
		       qid_printqueue(e->e_qgrp, e->e_qdir), e->e_id);
d2420 3
a2422 2
		syserr("milter_body: %s/df%s: read error",
		       qid_printqueue(e->e_qgrp, e->e_qdir), e->e_id);
d2447 1
a2447 1
/*
d2537 1
a2537 1
/*
d2706 1
a2706 1
/*
d2751 1
a2751 1
/*
d2796 2
a2797 2
/*
**  MILTER_REPLBODY -- Replace the current df file with new body
d2822 1
a2822 1
	/* If a new filter, reset previous character and truncate df */
d2828 2
a2829 1
		(void) sm_strlcpy(dfname, queuename(e, 'd'), sizeof dfname);
d2834 1
a2834 1
		/* Get the current df information */
d2845 1
a2845 1
		/* truncate current df file */
d2949 1
a2949 1
/*
d3029 1
a3029 1
/*
d3163 1
a3163 1
/*
d3211 1
a3211 1
/*
d3309 1
a3309 1
/*
d3377 1
a3377 1
/*
d3415 2
a3416 2
	bool rewind = false;		/* rewind df file? */
	bool dfopen = false;		/* df open for writing? */
d3564 22
d3736 3
a3738 2
		syserr("milter_data: %s/df%s: read error",
		       qid_printqueue(e->e_qgrp, e->e_qdir), e->e_id);
d3746 1
a3746 1
/*
d3768 1
a3768 1
/*
@


1.7
log
@Update to sendmail 8.11.6, from the release notes:

SECURITY: Fix a possible memory access violation when specifying
	out-of-bounds debug parameters.  Problem detected by
	Cade Cairns of SecurityFocus.
Avoid leaking recipient information in unrelated DSNs.  This could
	happen if a connection is aborted, several mails had been
	scheduled for delivery via that connection, and the timeout
	is reached such that several DSNs are sent next.  Problem
	noted by Dileepan Moorkanat of Hewlett-Packard.
Fix a possible segmentation violation when specifying too many
	wildcard operators in a rule.  Problem detected by
	Werner Wiethege.
Avoid a segmentation fault on non-matching Hesiod lookups.  Problem
	noted by Russell McOrmond of flora.ca
@
text
@d11 1
a11 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: milter.c,v 8.50.4.53 2001/08/15 02:01:03 ca Exp $";
#endif /* ! lint */
d13 5
a17 1
#if _FFR_MILTER
a18 1
# include <sendmail.h>
d26 1
a26 3
#  define SM_FD_SET	FD_SET
#  define SM_FD_ISSET	FD_ISSET
#  define SM_FD_SETSIZE	FD_SETSIZE
d29 1
a29 1
static void	milter_error __P((struct milter *));
d65 1
a65 1
			sm_free(response); \
d77 1
a77 1
				sm_free(response); \
d91 2
a92 2
		dprintf(msg, dfname, errstring(save_errno)); \
		dprintf("\n"); \
d94 3
a96 3
	if (LogLevel > 0) \
		sm_syslog(LOG_ERR, e->e_id, msg, dfname, errstring(save_errno)); \
	if (SuperSafe) \
d100 1
a100 1
			(void) fclose(e->e_dfp); \
d115 1
d120 1
a120 1
# define MILTER_TIMEOUT(routine, secs, write) \
d127 1
a127 1
	if (SM_FD_SETSIZE != 0 && m->mf_sock >= SM_FD_SETSIZE) \
d130 4
a133 3
			dprintf("%s(%s): socket %d is larger than FD_SETSIZE %d\n", \
				routine, m->mf_name, m->mf_sock, SM_FD_SETSIZE); \
		if (LogLevel > 0) \
d135 4
a138 3
				  "%s(%s): socket %d is larger than FD_SETSIZE %d\n", \
				  routine, m->mf_name, m->mf_sock, SM_FD_SETSIZE); \
		milter_error(m); \
d144 1
a144 1
	tv.tv_sec = secs; \
d147 2
a148 2
		     write ? NULL : &fds, \
		     write ? &fds : NULL, \
d155 9
a163 5
			dprintf("%s(%s): timeout\n", routine, m->mf_name); \
		if (LogLevel > 0) \
			sm_syslog(LOG_ERR, e->e_id, "%s(%s): timeout\n", \
				  routine, m->mf_name); \
		milter_error(m); \
d169 4
a172 3
			dprintf("%s(%s): select: %s\n", \
				routine,  m->mf_name, errstring(save_errno)); \
		if (LogLevel > 0) \
d174 5
a178 3
				  "%s(%s): select: %s\n", \
				  routine, m->mf_name, errstring(save_errno)); \
		milter_error(m); \
d185 4
a188 3
			dprintf("%s(%s): socket not ready\n", \
				routine, m->mf_name); \
		if (LogLevel > 0) \
d190 4
a193 3
				  "%s(%s): socket not ready\n", \
				  m->mf_name, routine); \
		milter_error(m); \
d226 1
d243 5
a247 3
					dprintf("milter_read(%s): timeout before data read\n",
						m->mf_name);
				if (LogLevel > 0)
d249 5
a253 3
						  "milter_read(%s): timeout before data read\n",
						  m->mf_name);
				milter_error(m);
d258 1
a258 1
			MILTER_TIMEOUT("milter_read", to, FALSE);
d268 1
a268 1
				dprintf("milter_read(%s): read returned %ld: %s\n",
d270 2
a271 2
					errstring(save_errno));
			if (LogLevel > 0)
d273 1
a273 1
					  "milter_read(%s): read returned %ld: %s",
d275 2
a276 2
					  errstring(save_errno));
			milter_error(m);
d280 1
d290 1
a290 1
			dprintf("milter_read(%s): read returned %ld, expecting %ld\n",
d292 1
a292 1
		if (LogLevel > 0)
d294 1
a294 1
				  "milter_read(%s): read returned %ld, expecting %ld",
d296 1
a296 1
		milter_error(m);
d334 1
a334 1
				dprintf("milter_read(%s): timeout before data read\n",
d336 1
a336 1
			if (LogLevel > 0)
d338 1
a338 1
					  "milter_read(%s): timeout before data read\n",
d340 1
a340 1
			milter_error(m);
d352 1
a352 1
		dprintf("milter_read(%s): expecting %ld bytes\n",
d358 1
a358 1
			dprintf("milter_read(%s): read size %ld out of range\n",
d360 1
a360 1
		if (LogLevel > 0)
d364 1
a364 1
		milter_error(m);
d371 1
a371 1
	buf = (char *)xalloc(expl);
d375 1
a375 1
		sm_free(buf);
d380 1
a380 1
		dprintf("milter_read(%s): Returning %*s\n",
d415 1
d420 1
a420 1
			dprintf("milter_write(%s): length %ld out of range\n",
d422 1
a422 1
		if (LogLevel > 0)
d426 1
a426 1
		milter_error(m);
d431 2
a432 2
		dprintf("milter_write(%s): cmd %c, len %ld\n",
			m->mf_name, cmd, (long) len);
d442 1
a442 1
		MILTER_TIMEOUT("milter_write", to, TRUE);
d452 4
a455 4
			dprintf("milter_write(%s): write(%c) returned %ld, expected %ld: %s\n",
				m->mf_name, cmd, (long) i, (long) sl,
				errstring(save_errno));
		if (LogLevel > 0)
d457 1
a457 1
				  "milter_write(%s): write(%c) returned %ld, expected %ld: %s",
d459 2
a460 2
				  errstring(save_errno));
		milter_error(m);
d468 3
a470 2
		dprintf("milter_write(%s): Sending %*s\n",
			m->mf_name, (int) len, buf);
d480 3
a482 3
				dprintf("milter_write(%s): timeout before data send\n",
					m->mf_name);
			if (LogLevel > 0)
d484 1
a484 1
					  "milter_write(%s): timeout before data send\n",
d486 1
a486 1
			milter_error(m);
d492 1
a492 1
			MILTER_TIMEOUT("milter_write", to, TRUE);
d502 4
a505 4
			dprintf("milter_write(%s): write(%c) returned %ld, expected %ld: %s\n",
				m->mf_name, cmd, (long) i, (long) sl,
				errstring(save_errno));
		if (LogLevel > 0)
d507 1
a507 1
				  "milter_write(%s): write(%c) returned %ld, expected %ld: %s",
d509 2
a510 2
				  errstring(save_errno));
		milter_error(m);
d555 2
a556 2
			dprintf("X%s: empty or missing socket information\n",
				m->mf_name);
d560 1
a560 1
		else if (LogLevel > 10)
d562 1
a562 1
				  "X%s: empty or missing socket information",
d564 1
a564 1
		milter_error(m);
d591 1
a591 1
				  "X%s: no valid socket protocols available",
d593 1
a593 1
			milter_error(m);
d600 2
a601 2
		else if (strcasecmp(p, "unix") == 0 ||
			 strcasecmp(p, "local") == 0)
d605 1
a605 1
		else if (strcasecmp(p, "inet") == 0)
d609 1
a609 1
		else if (strcasecmp(p, "inet6") == 0)
d620 1
a620 1
				dprintf("X%s: unknown socket type %s\n",
d625 1
a625 1
			else if (LogLevel > 10)
d627 1
a627 1
					  "X%s: unknown socket type %s",
d629 1
a629 1
			milter_error(m);
d650 1
a650 1
				dprintf("X%s: local socket name %s too long\n",
d656 1
a656 1
			else if (LogLevel > 10)
d658 1
a658 1
					  "X%s: local socket name %s too long",
d660 1
a660 1
			milter_error(m);
d671 3
a673 3
				fprintf(stderr,
					"WARNING: X%s: local socket name %s missing\n",
					m->mf_name, colon);
d680 1
a680 1
				dprintf("X%s: local socket name %s unsafe\n",
d691 1
a691 1
			else if (LogLevel > 10)
d693 1
a693 1
					  "X%s: local socket name %s unsafe",
d695 1
a695 1
			milter_error(m);
d699 1
a699 1
		(void) strlcpy(addr.sunix.sun_path, colon,
d706 1
a706 1
	if (FALSE
d715 1
a715 1
		u_short port;
d722 1
a722 1
				dprintf("X%s: bad address %s (expected port@@host)\n",
d727 1
a727 1
			else if (LogLevel > 10)
d729 1
a729 1
					  "X%s: bad address %s (expected port@@host)",
d731 1
a731 1
			milter_error(m);
d736 1
a736 1
			port = htons((u_short) atoi(colon));
d741 1
a741 1
				dprintf("X%s: invalid port number %s\n",
d746 1
a746 1
			else if (LogLevel > 10)
d748 1
a748 1
					  "X%s: invalid port number %s",
d750 1
a750 1
			milter_error(m);
d760 1
a760 1
					dprintf("X%s: unknown port name %s\n",
d766 1
a766 1
				else if (LogLevel > 10)
d768 1
a768 1
						  "X%s: unknown port name %s",
d770 1
a770 1
				milter_error(m);
d784 1
a784 1
				bool found = FALSE;
d799 1
a799 1
					found = TRUE;
d805 2
a806 2
				    inet_pton(AF_INET6, &at[1],
					      &hid6.sin6_addr) == 1)
d810 1
a810 1
					found = TRUE;
d817 1
a817 1
						dprintf("X%s: Invalid numeric domain spec \"%s\"\n",
d822 1
a822 1
					else if (LogLevel > 10)
d824 1
a824 1
							  "X%s: Invalid numeric domain spec \"%s\"",
d826 1
a826 1
					milter_error(m);
d833 1
a833 1
					dprintf("X%s: Invalid numeric domain spec \"%s\"\n",
d838 1
a838 1
				else if (LogLevel > 10)
d840 1
a840 1
						  "X%s: Invalid numeric domain spec \"%s\"",
d842 1
a842 1
				milter_error(m);
d853 2
a854 2
					dprintf("X%s: Unknown host name %s\n",
						m->mf_name, at);
d859 1
a859 1
				else if (LogLevel > 10)
d861 1
a861 1
						  "X%s: Unknown host name %s",
d863 1
a863 1
				milter_error(m);
d872 1
a872 2
					hp->h_addr,
					INADDRSZ);
d882 1
a882 2
					hp->h_addr,
					IN6ADDRSZ);
d891 3
a893 3
					dprintf("X%s: Unknown protocol for %s (%d)\n",
						m->mf_name, at,
						hp->h_addrtype);
d897 1
a897 1
				else if (LogLevel > 10)
d899 1
a899 1
						  "X%s: Unknown protocol for %s (%d)",
d902 2
a903 2
				milter_error(m);
#  if _FFR_FREEHOSTENT && NETINET6
d905 1
a905 1
#  endif /* _FFR_FREEHOSTENT && NETINET6 */
d914 2
a915 1
			dprintf("X%s: unknown socket protocol\n", m->mf_name);
d918 1
a918 1
		else if (LogLevel > 10)
d920 3
a922 2
				  "X%s: unknown socket protocol", m->mf_name);
		milter_error(m);
d930 1
a930 1
# if _FFR_FREEHOSTENT && NETINET6
d933 1
a933 1
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d943 4
a946 4
			dprintf("milter_open(%s): Trying to open filter in state %c\n",
				m->mf_name, (char) m->mf_state);
		milter_error(m);
# if _FFR_FREEHOSTENT && NETINET6
d949 1
a949 1
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d961 4
a964 3
				dprintf("X%s: error creating socket: %s\n",
					m->mf_name, errstring(save_errno));
			if (LogLevel > 0)
d966 4
a969 4
					  "X%s: error creating socket: %s",
					  m->mf_name, errstring(save_errno));
			milter_error(m);
# if _FFR_FREEHOSTENT && NETINET6
d972 1
a972 1
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d978 1
a978 1
			EVENT *ev = NULL;
d982 2
a983 2
				ev = setevent(m->mf_timeout[SMFTO_CONNECT],
					      milter_connect_timeout, 0);
d988 1
a988 1
				clrevent(ev);
d999 3
a1001 3
			dprintf("milter_open(%s): %s failed: %s\n",
				m->mf_name, at, errstring(save_errno));
		if (LogLevel >= 14)
d1003 2
a1004 2
				  "milter_open(%s): %s failed: %s",
				  m->mf_name, at, errstring(save_errno));
d1031 4
a1034 4
					dprintf("X%s: Unknown protocol for %s (%d)\n",
						m->mf_name, at,
						hp->h_addrtype);
				if (LogLevel > 0)
d1036 1
a1036 1
						  "X%s: Unknown protocol for %s (%d)",
d1039 2
a1040 2
				milter_error(m);
# if _FFR_FREEHOSTENT && NETINET6
d1042 1
a1042 1
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d1050 3
a1052 3
			dprintf("X%s: error connecting to filter: %s\n",
				m->mf_name, errstring(save_errno));
		if (LogLevel > 0)
d1054 2
a1055 2
				  "X%s: error connecting to filter: %s",
				  m->mf_name, errstring(save_errno));
d1057 2
a1058 2
		milter_error(m);
# if _FFR_FREEHOSTENT && NETINET6
d1061 1
a1061 1
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d1065 1
a1065 1
# if _FFR_FREEHOSTENT && NETINET6
d1071 1
a1071 1
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d1118 1
a1118 1
	m = (struct milter *)xalloc(sizeof *m);
d1123 1
a1123 1
	m->mf_timeout[SMFTO_CONNECT] = (time_t) 0;
d1183 1
a1183 1
	(void) milter_open(m, TRUE, CurEnv);
d1193 1
a1193 1
**  MILTER_PARSE_LIST -- parse option list into an array
d1207 1
a1207 1
milter_parse_list(spec, list, max)
d1235 3
d1239 1
d1253 4
d1311 3
a1313 3
				printf("X%s: %c=%ld\n",
				       m->mf_name, fcode,
				       (u_long) m->mf_timeout[SMFTO_CONNECT]);
d1319 3
a1321 3
				printf("X%s: %c=%ld\n",
				       m->mf_name, fcode,
				       (u_long) m->mf_timeout[SMFTO_WRITE]);
d1327 3
a1329 3
				printf("X%s: %c=%ld\n",
				       m->mf_name, fcode,
				       (u_long) m->mf_timeout[SMFTO_READ]);
d1335 3
a1337 3
				printf("X%s: %c=%ld\n",
				       m->mf_name, fcode,
				       (u_long) m->mf_timeout[SMFTO_EOM]);
d1342 2
a1343 2
				printf("X%s: %c unknown\n",
				       m->mf_name, fcode);
d1369 2
a1370 2
	char	*mo_name;	/* long name of milter option */
	u_char	mo_code;	/* code for option */
d1381 2
d1398 1
a1398 1
		dprintf("milter_set_option(%s = %s)", name, val);
d1402 1
a1402 1
		if (strcasecmp(mo->mo_name, name) == 0)
d1407 1
d1409 2
d1419 1
a1419 1
			dprintf(" (ignored)\n");
d1424 1
a1424 1
		dprintf("\n");
d1428 4
a1487 1

d1507 1
a1507 1
	(void) strlcpy(dfname, queuename(e, 'd'), sizeof dfname);
d1510 1
a1510 1
	**  In SuperSafe mode, e->e_dfp is a read-only FP so
d1514 1
a1514 1
	**  In !SuperSafe mode, e->e_dfp still points at the
d1520 1
a1520 1
	if (SuperSafe)
d1525 1
a1525 1
			(void) fclose(e->e_dfp);
d1530 2
a1531 1
		if ((e->e_dfp = fopen(dfname, "w+")) == NULL)
d1533 1
a1533 1
			MILTER_DF_ERROR("milter_reopen_df: fopen %s: %s");
d1563 1
a1563 1
	(void) strlcpy(dfname, queuename(e, 'd'), sizeof dfname);
d1565 2
a1566 1
	if (fflush(e->e_dfp) != 0 || ferror(e->e_dfp))
d1571 1
a1571 1
	else if (!SuperSafe)
d1576 2
a1577 1
	else if ((afd = fileno(e->e_dfp)) >= 0 && fsync(afd) < 0)
d1582 1
a1582 1
	else if (fclose(e->e_dfp) < 0)
d1587 2
a1588 1
	else if ((e->e_dfp = fopen(dfname, "r")) == NULL)
d1604 1
a1604 1
**		TRUE if any filter deletes recipients, FALSE otherwise
d1610 1
a1610 1
	bool can = FALSE;
d1614 1
a1614 1
		dprintf("milter_can_delrcpts:");
d1622 1
a1622 1
			can = TRUE;
d1627 1
a1627 1
		dprintf("%s\n", can ? "TRUE" : "FALSE");
d1648 4
a1651 1
		dprintf("milter_quit_filter(%s)\n", m->mf_name);
d1693 4
a1696 1
		dprintf("milter_abort_filter(%s)\n", m->mf_name);
d1741 1
a1741 1
		mid = macid(macros[i], NULL);
d1750 4
a1753 1
	buf = (char *)xalloc(s);
d1758 1
a1758 1
		mid = macid(macros[i], NULL);
d1766 1
a1766 1
			dprintf("milter_send_macros(%s, %c): %s=%s\n",
d1769 1
a1769 1
		(void) strlcpy(bp, macros[i], s - (bp - buf));
d1771 1
a1771 1
		(void) strlcpy(bp, v, s - (bp - buf));
d1776 1
a1776 1
	sm_free(buf);
d1805 1
a1805 1
	u_long skipflag;
d1810 1
a1810 1
		dprintf("milter_send_command(%s): cmd %c len %ld\n",
d1870 1
a1870 1

d1879 1
d1889 2
a1890 2
		dprintf("milter_send_command(%s): returned %c\n",
			m->mf_name, (char) rcmd);
d1896 3
d1914 3
d1927 1
a1927 1
		if (LogLevel > 0)
d1931 1
a1931 1
		milter_error(m);
d1938 1
a1938 1
		sm_free(response);
d1970 1
d1973 1
a1973 1
		dprintf("milter_command: cmd %c len %ld\n",
d2004 3
d2008 9
d2049 1
a2049 1
		if (LogLevel > 0)
d2051 1
a2051 1
				  "milter_negotiate(%s): impossible state",
d2053 1
a2053 1
		milter_error(m);
d2078 1
a2078 1
			dprintf("milter_negotiate(%s): returned %c instead of %c\n",
d2080 1
a2080 1
		if (LogLevel > 0)
d2082 1
a2082 1
				  "milter_negotiate(%s): returned %c instead of %c",
d2085 2
a2086 2
			sm_free(response);
		milter_error(m);
d2094 1
a2094 1
			dprintf("milter_negotiate(%s): did not return valid info\n",
d2096 1
a2096 1
		if (LogLevel > 0)
d2098 1
a2098 1
				  "milter_negotiate(%s): did not return valid info",
d2101 2
a2102 2
			sm_free(response);
		milter_error(m);
d2113 1
a2113 1
			dprintf("milter_negotiate(%s): did not return enough info\n",
d2115 1
a2115 1
		if (LogLevel > 0)
d2117 1
a2117 1
				  "milter_negotiate(%s): did not return enough info",
d2120 2
a2121 2
			sm_free(response);
		milter_error(m);
d2129 1
a2129 1
	sm_free(response);
d2141 1
a2141 1
			dprintf("milter_negotiate(%s): version %lu != MTA milter version %d\n",
d2143 1
a2143 1
		if (LogLevel > 0)
d2145 1
a2145 1
				  "milter_negotiate(%s): version %ld != MTA milter version %d",
d2147 1
a2147 1
		milter_error(m);
d2155 1
a2155 1
			dprintf("milter_negotiate(%s): filter abilities 0x%lx != MTA milter abilities 0x%lx\n",
d2157 2
a2158 2
				(u_long) SMFI_CURR_ACTS);
		if (LogLevel > 0)
d2160 1
a2160 1
				  "milter_negotiate(%s): filter abilities 0x%lx != MTA milter abilities 0x%lx\n",
d2162 2
a2163 2
				  (u_long) SMFI_CURR_ACTS);
		milter_error(m);
d2171 1
a2171 1
			dprintf("milter_negotiate(%s): protocol abilities 0x%lx != MTA milter abilities 0x%lx\n",
d2173 2
a2174 2
				(u_long) SMFI_CURR_PROT);
		if (LogLevel > 0)
d2176 1
a2176 1
				  "milter_negotiate(%s): protocol abilities 0x%lx != MTA milter abilities 0x%lx\n",
d2178 2
a2179 2
				  (u_long) SMFI_CURR_PROT);
		milter_error(m);
d2184 1
a2184 1
		dprintf("milter_negotiate(%s): version %lu, fflags 0x%lx, pflags 0x%lx\n",
d2226 1
a2226 1
milter_error(m)
d2228 1
d2243 4
d2269 4
d2291 1
a2291 1
			dprintf("milter_headers: %s: %s\n",
d2293 3
d2297 3
a2299 2
		s = strlen(h->h_field) + 1 +
			strlen(h->h_value) + 1;
d2301 2
a2302 1
		snprintf(buf, s, "%s%c%s", h->h_field, '\0', h->h_value);
d2307 1
a2307 1
		sm_free(buf);
d2313 3
d2344 1
a2344 1
		dprintf("milter_body\n");
d2351 1
a2351 1
		       qid_printqueue(e->e_queuedir), e->e_id);
d2355 3
d2359 1
a2359 1
	while ((c = getc(e->e_dfp)) != EOF)
d2406 1
a2406 1
	if (ferror(e->e_dfp))
d2415 1
a2415 1
				sm_free(response);
d2420 1
a2420 1
		       qid_printqueue(e->e_queuedir), e->e_id);
d2435 3
d2467 1
a2467 1
		dprintf("milter_addheader: ");
d2473 1
a2473 1
			dprintf("NULL response\n");
d2480 1
a2480 1
			dprintf("didn't follow protocol (total len)\n");
d2491 1
a2491 1
			dprintf("didn't follow protocol (part len)\n");
d2498 1
a2498 1
			dprintf("empty field name\n");
d2504 1
a2504 1
		if (strcasecmp(h->h_field, response) == 0 &&
d2516 6
a2521 2
			dprintf("Replace default header %s value with %s\n",
				h->h_field, val);
d2528 5
a2532 2
			dprintf("Add %s: %s\n", response, val);
		addheader(newstr(response), val, H_USER, &e->e_header);
d2558 1
a2558 1
		dprintf("milter_changeheader: ");
d2564 1
a2564 1
			dprintf("NULL response\n");
d2571 1
a2571 1
			dprintf("didn't follow protocol (total len)\n");
d2586 1
a2586 1
			dprintf("didn't follow protocol (part len)\n");
d2593 1
a2593 1
			dprintf("empty field name\n");
d2600 1
a2600 1
		if (strcasecmp(h->h_field, field) == 0)
d2632 1
a2632 1
				dprintf("Delete (noop) %s:\n", field);
d2638 2
a2639 3
				dprintf("Add %s: %s\n",	field, val);

			addheader(newstr(field), val, H_USER, &e->e_header);
d2648 4
a2651 4
			dprintf("Delete%s %s: %s\n",
				h == sysheader ? " (default header)" : "",
				field,
				h->h_value == NULL ? "<NULL>" : h->h_value);
d2655 26
a2680 5
			dprintf("Change%s %s: from %s to %s\n",
				h == sysheader ? " (default header)" : "",
				field,
				h->h_value == NULL ? "<NULL>" : h->h_value,
				val);
d2687 1
a2687 1
		sm_free(h->h_value);
d2723 1
a2723 1
		dprintf("milter_addrcpt: ");
d2729 1
a2729 1
			dprintf("NULL response\n");
d2737 2
a2738 2
			dprintf("didn't follow protocol (total len %d != rlen %d)\n",
				strlen(response), rlen -1);
d2743 3
a2745 1
		dprintf("%s\n", response);
d2768 1
a2768 1
		dprintf("milter_delrcpt: ");
d2774 1
a2774 1
			dprintf("NULL response\n");
d2782 1
a2782 1
			dprintf("didn't follow protocol (total len)\n");
d2787 4
a2790 1
		dprintf("%s\n", response);
d2818 1
a2818 1
		dprintf("milter_replbody\n");
d2826 1
a2826 1
		(void) strlcpy(dfname, queuename(e, 'd'), sizeof dfname);
d2837 1
a2837 1
			afd = fileno(e->e_dfp);
d2843 1
a2843 1
		if (bftruncate(e->e_dfp) < 0)
d2845 5
a2849 2
			MILTER_DF_ERROR("milter_reopen_df: bftruncate %s: %s");
			return -1;
d2853 29
a2881 4
			if (prevsize > e->e_msgsize)
				e->e_msgsize = 0;
			else
				e->e_msgsize -= prevsize;
d2883 5
d2890 3
d2898 1
a2898 1
			(void) putc(prevchar, e->e_dfp);
d2912 2
a2913 1
				(void) putc(prevchar, e->e_dfp);
d2936 1
a2936 1
		(void) putc(response[i], e->e_dfp);
d2954 1
a2954 1
**		none
d2958 1
a2958 1
void
d2966 1
a2966 1
		dprintf("milter_init\n");
d2969 8
d2981 1
a2981 1
		m->mf_sock = milter_open(m, FALSE, e);
d2993 10
a3002 3
				dprintf("milter_init(%s): failed to %s\n",
					m->mf_name,
					m->mf_sock < 0 ? "open" : "negotiate");
d3005 1
a3005 1
			milter_error(m);
d3008 5
d3023 2
d3047 1
a3047 1
	u_short port;
d3057 3
a3059 1
		dprintf("milter_connect(%s)\n", hostname);
d3103 1
a3103 1
	buf = (char *)xalloc(s);
d3123 1
a3123 1
	sm_free(buf);
d3131 3
d3135 1
d3154 1
a3154 1
			sm_free(response);
d3182 1
a3182 1
		dprintf("milter_helo(%s)\n", helo);
d3184 1
a3184 1
	/* HELO/EHLO can come after encryption is negotiated */
d3233 1
a3233 1
		dprintf("milter_envfrom:");
d3235 2
a3236 2
			dprintf(" %s", args[i]);
		dprintf("\n");
d3243 3
d3272 8
a3279 1
	buf = (char *)xalloc(s);
d3283 1
a3283 1
		(void) strlcpy(bp, args[i], s - (bp - buf));
d3287 3
d3293 1
a3293 1
	sm_free(buf);
d3302 2
d3331 1
a3331 1
		dprintf("milter_envrcpt:");
d3333 2
a3334 2
			dprintf(" %s", args[i]);
		dprintf("\n");
d3341 2
d3350 8
a3357 1
	buf = (char *)xalloc(s);
d3361 1
a3361 1
		(void) strlcpy(bp, args[i], s - (bp - buf));
d3365 3
d3371 1
a3371 1
	sm_free(buf);
d3410 4
a3413 4
	bool replbody = FALSE;		/* milter_replbody() called? */
	bool replfailed = FALSE;	/* milter_replbody() failed? */
	bool rewind = FALSE;		/* rewind df file? */
	bool dfopen = FALSE;		/* df open for writing? */
d3423 1
a3423 1
		dprintf("milter_data\n");
d3451 1
a3451 1
		newfilter = TRUE;
d3478 1
a3478 1
				dprintf("milter_data: eoh\n");
d3490 1
a3490 1
			rewind = TRUE;
d3510 1
a3510 1
					dprintf("milter_data(%s): EOM ACK/NAK timeout\n",
d3512 1
a3512 1
				if (LogLevel > 0)
d3514 1
a3514 1
						  "milter_data(%s): EOM ACK/NAK timeout\n",
d3516 1
a3516 1
				milter_error(m);
d3527 2
a3528 2
				dprintf("milter_data(%s): state %c\n",
					m->mf_name, (char) rcmd);
d3534 3
d3541 1
a3541 1
			  case SMFIR_REJECT:
d3564 1
a3564 1
					if (LogLevel > 9)
d3575 1
a3575 1
					if (LogLevel > 9)
d3586 1
a3586 1
					if (LogLevel > 9)
d3597 1
a3597 1
					if (LogLevel > 9)
d3608 1
a3608 1
					if (LogLevel > 0)
d3612 1
a3612 1
					replfailed = TRUE;
d3624 1
a3624 1
						replfailed = TRUE;
d3627 2
a3628 2
					dfopen = TRUE;
					rewind = TRUE;
d3633 3
a3635 3
					replfailed = TRUE;
				newfilter = FALSE;
				replbody = TRUE;
d3640 1
a3640 1
				if (LogLevel > 0)
d3644 1
a3644 1
				milter_error(m);
d3647 1
a3647 2
			if (rcmd != SMFIR_REPLYCODE &&
			    response != NULL)
d3649 1
a3649 1
				sm_free(response);
d3661 1
a3661 1
			replbody = FALSE;
d3679 1
a3679 5
			if (response != NULL)
			{
				sm_free(response);
				response = NULL;
			}
d3684 1
a3684 1
			(void) fclose(e->e_dfp);
d3687 1
a3687 1
			dfopen = FALSE;
d3689 1
a3689 1
		rewind = FALSE;
d3707 1
a3707 5
			if (response != NULL)
			{
				sm_free(response);
				response = NULL;
			}
d3712 1
a3712 1
		       qid_printqueue(e->e_queuedir), e->e_id);
d3714 1
d3716 2
d3737 1
a3737 1
		dprintf("milter_quit\n");
d3759 1
a3759 1
		dprintf("milter_abort\n");
d3772 1
a3772 1
#endif /* _FFR_MILTER */
@


1.6
log
@update to sendmail 8.11.5
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: milter.c,v 8.50.4.51 2001/07/20 00:53:01 gshapiro Exp $";
d1103 1
a1103 1
 	m->mf_timeout[SMFTO_CONNECT] = (time_t) 0;
a1134 4
		  case 'C':
			m->mf_timeout[SMFTO_CONNECT] = convtime(p, 's');
			break;

d1280 8
@


1.5
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: milter.c,v 8.50.4.46 2001/05/11 18:11:36 gshapiro Exp $";
d29 1
d515 2
d956 17
a972 2
		if (connect(sock, (struct sockaddr *) &addr, addrlen) >= 0)
			break;
d1027 2
d1036 1
d1054 13
d1103 1
d1135 4
d2893 4
a2896 1
		family = SMFIA_INET6;
@


1.4
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: milter.c,v 8.50.4.44 2001/01/23 19:43:57 gshapiro Exp $";
d65 1
a65 1
			free(response); \
d77 1
a77 1
				free(response); \
d357 1
a357 1
		free(buf);
d1010 2
a1011 2
			dprintf("X%s: error connecting to filter\n",
				m->mf_name);
d1014 2
a1015 2
				  "X%s: error connecting to filter",
				  m->mf_name);
d1684 1
a1684 1
	free(buf);
d1839 1
a1839 1
		free(response);
d1973 1
a1973 1
			free(response);
d1989 1
a1989 1
			free(response);
d2008 1
a2008 1
			free(response);
d2017 1
a2017 1
	free(response);
d2181 1
a2181 1
		free(buf);
d2283 1
a2283 1
				free(response);
d2525 1
a2525 1
		free(h->h_value);
d2892 1
a2892 1
	free(buf);
d2919 1
a2919 1
			free(response);
d3045 1
a3045 1
	free(buf);
d3109 1
a3109 1
	free(buf);
d3385 1
a3385 1
				free(response);
d3417 1
a3417 1
				free(response);
d3449 1
a3449 1
				free(response);
@


1.4.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: milter.c,v 8.50.4.46 2001/05/11 18:11:36 gshapiro Exp $";
d65 1
a65 1
			sm_free(response); \
d77 1
a77 1
				sm_free(response); \
d357 1
a357 1
		sm_free(buf);
d1010 2
a1011 2
			dprintf("X%s: error connecting to filter: %s\n",
				m->mf_name, errstring(save_errno));
d1014 2
a1015 2
				  "X%s: error connecting to filter: %s",
				  m->mf_name, errstring(save_errno));
d1684 1
a1684 1
	sm_free(buf);
d1839 1
a1839 1
		sm_free(response);
d1973 1
a1973 1
			sm_free(response);
d1989 1
a1989 1
			sm_free(response);
d2008 1
a2008 1
			sm_free(response);
d2017 1
a2017 1
	sm_free(response);
d2181 1
a2181 1
		sm_free(buf);
d2283 1
a2283 1
				sm_free(response);
d2525 1
a2525 1
		sm_free(h->h_value);
d2892 1
a2892 1
	sm_free(buf);
d2919 1
a2919 1
			sm_free(response);
d3045 1
a3045 1
	sm_free(buf);
d3109 1
a3109 1
	sm_free(buf);
d3385 1
a3385 1
				sm_free(response);
d3417 1
a3417 1
				sm_free(response);
d3449 1
a3449 1
				sm_free(response);
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2000 Sendmail, Inc. and its suppliers.
d12 1
a12 1
static char id[] = "@@(#)$Sendmail: milter.c,v 8.50.4.41 2000/12/27 21:35:32 gshapiro Exp $";
d264 1
a264 1
		if (len == 0 || len >= sz)
d1813 5
a1817 1
		m->mf_state = SMFS_DONE;
d2099 1
a2099 1
		if (m->mf_state == SMFS_DONE)
d2943 1
d2948 19
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: milter.c,v 8.50 2000/03/16 23:15:49 gshapiro Exp $";
d25 3
a27 4
/* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX */
/* To do:                                                            */
/* - Optimize body chunk sending in milter_body()                    */
/* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX */
d30 2
d38 1
a38 1
#define MILTER_CHECK_DONE_MSG() \
d48 1
a48 1
#define MILTER_CHECK_ERROR() \
d54 1
a54 1
		continue;
d56 1
a56 1
#define MILTER_CHECK_REPLYCODE(default) \
d58 1
a58 1
	    strlen(response) + 1 != rlen || \
d85 23
d119 1
a119 1
#define MILTER_TIMEOUT(routine, secs, write) \
d126 1
a126 1
	if (m->mf_sock >= FD_SETSIZE) \
d130 1
a130 1
				routine, m->mf_name, m->mf_sock, FD_SETSIZE); \
d134 1
a134 1
				  routine, m->mf_name, m->mf_sock, FD_SETSIZE); \
d140 1
a140 1
	FD_SET(m->mf_sock, &fds); \
d172 1
a172 1
		if (FD_ISSET(m->mf_sock, &fds)) \
d205 1
a205 1
milter_read(m, cmd, rlen, to, e)
d207 2
a208 2
	char *cmd;
	ssize_t *rlen;
d212 2
a213 5
	time_t readstart = (time_t) 0;
	ssize_t len, expl;
	mi_int32 i;
	char *buf;
	char data[MILTER_LEN_BYTES + 1];
d215 1
a215 2
	*rlen = 0;
	*cmd = '\0';
a217 1
	{
a218 2
		MILTER_TIMEOUT("milter_read", to, FALSE);
	}
d220 1
a220 2
	len = read(m->mf_sock, data, sizeof data);
	if (len <= 0)
d222 44
a265 1
		int save_errno = errno;
a266 10
		if (tTd(64, 5))
			dprintf("milter_read(%s): read returned %ld: %s\n",
				m->mf_name, (long) len, errstring(save_errno));
		if (LogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_read(%s): read returned %ld: %s",
				  m->mf_name, (long) len,
				  errstring(save_errno));
		milter_error(m);
		return NULL;
d269 1
a269 1
	if (len != sizeof data)
d272 2
a273 2
			dprintf("milter_read(%s): cmd read returned %ld, expecting %ld\n",
				m->mf_name, (long) *rlen, (long) sizeof data);
d276 2
a277 3
				  "milter_read(%s): cmd read returned %ld, expecting %ld",
				  m->mf_name, (long) *rlen,
				  (long) sizeof data);
d281 2
d284 13
a296 4
	*cmd = data[MILTER_LEN_BYTES];
	data[MILTER_LEN_BYTES] = '\0';
	(void) memcpy(&i, data, MILTER_LEN_BYTES);
	expl = ntohl(i) - 1;
d298 2
a299 3
	if (tTd(64, 25))
		dprintf("milter_read(%s): expecting %ld bytes\n",
			m->mf_name, (long) expl);
d301 2
a302 12
	if (expl < 0 || expl > MILTER_CHUNK_SIZE)
	{
		if (tTd(64, 5))
			dprintf("milter_read(%s): read size %ld out of range\n",
				m->mf_name, (long) expl);
		if (LogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_read(%s): read size %ld out of range",
				  m->mf_name, (long) expl);
		milter_error(m);
		return NULL;
	}
d304 1
a304 1
	if (expl == 0)
d307 1
a307 2
	buf = (char *)xalloc(expl);

d325 1
a325 5
		else
		{
			to -= now - readstart;
			MILTER_TIMEOUT("milter_read", to, FALSE);
		}
d328 10
a337 2
	*rlen = read(m->mf_sock, buf, expl);
	if (len <= 0)
a338 2
		int save_errno = errno;

d340 2
a341 2
			dprintf("milter_read(%s): read returned %ld: %s\n",
				m->mf_name, (long) len, errstring(save_errno));
d344 2
a345 4
				  "milter_read(%s): read returned %ld: %s",
				  m->mf_name, (long) len,
				  errstring(save_errno));
		free(buf);
d349 7
a355 1
	if (*rlen != expl)
a356 7
		if (tTd(64, 5))
			dprintf("milter_read(%s): read returned %ld, expecting %ld\n",
				m->mf_name, (long) *rlen, (long) len);
		if (LogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_read(%s): read returned %ld, expecting %ld",
				  m->mf_name, (long) *rlen, (long) len);
a357 1
		milter_error(m);
d360 1
d363 2
a364 1
			m->mf_name, (int) *rlen, buf);
d514 1
a514 1
int
d622 1
a622 1
		long sff = SFF_SAFEDIRPATH|SFF_OPENASROOT|SFF_NOLINK|SFF_CREAT|SFF_MUSTOWN|SFF_EXECOK;
d644 10
a653 2
		/* if not safe, don't create */
		if (errno != 0)
d655 1
d681 1
d684 1
a684 1
	else if (FALSE
d714 1
a714 1
			port = htons(atoi(colon));
d883 3
d890 1
a891 1
	else
d908 4
d924 4
d946 4
d958 2
d967 1
d1002 3
d1017 4
d1024 7
d1034 104
d1208 1
a1208 1
void
d1242 1
a1242 1
		/* install the field into the mailer struct */
d1302 1
a1302 1
#define MO_MACROS_CONNECT		0x01
d1304 1
a1304 1
#define MO_MACROS_HELO			0x02
d1306 1
a1306 1
#define MO_MACROS_ENVFROM		0x03
d1308 1
a1308 1
#define MO_MACROS_ENVRCPT		0x04
d1413 1
a1413 1
**  MILTER_CAN_DELRCPTS -- can any milter filters delete recipients?
d1416 1
a1416 1
**		none
d1419 1
a1419 1
**		TRUE if any filter deletes recipients, FALSE otherwise
d1422 3
a1424 2
bool
milter_can_delrcpts()
d1426 14
a1439 1
	int i;
d1441 1
a1441 1
	for (i = 0; InputFilters[i] != NULL; i++)
d1443 6
a1448 1
		struct milter *m = InputFilters[i];
d1450 13
a1462 2
		if (bitset(SMFIF_DELRCPT, m->mf_fflags))
			return TRUE;
d1464 1
a1464 1
	return FALSE;
d1467 1
a1467 1
**  MILTER_QUIT_FILTER -- close down a single filter
a1469 1
**		m -- milter structure of filter to close down.
d1473 1
a1473 1
**		none
d1476 2
a1477 3
static void
milter_quit_filter(m, e)
	struct milter *m;
d1480 86
a1565 2
	if (tTd(64, 10))
		dprintf("milter_quit_filter(%s)\n", m->mf_name);
d1582 5
a1586 2
	(void) close(m->mf_sock);
	m->mf_sock = -1;
d1653 1
a1653 1
		if (mid == '\0')
d1667 1
a1667 1
		if (mid == '\0')
d1686 1
d1688 1
a1688 1
**  MILTER_COMMAND -- send a command and return the response for each filter
d1691 1
d1695 1
a1695 2
**		macros -- macros to send for filter smfi_getsymval().
**		e -- current envelope (for macro access).
d1703 2
a1704 1
milter_command(command, data, sz, macros, e, state)
a1707 1
	char **macros;
a1710 1
	int i;
d1712 1
a1713 1
	char *response = NULL;
d1715 1
a1715 1
	ssize_t rlen;
d1718 2
a1719 2
		dprintf("milter_command: cmd %c len %ld\n",
			(char) command, (long) sz);
d1725 1
a1725 1
		skipflag = SMFIF_NOCONNECT;
d1730 1
a1730 1
		skipflag = SMFIF_NOHELO;
d1735 1
a1735 1
		skipflag = SMFIF_NOMAIL;
d1740 1
a1740 1
		skipflag = SMFIF_NORCPT;
d1745 9
d1755 1
a1755 1
		skipflag = SMFIF_NOHDRS;
a1758 1
	  case SMFIC_BODY:
d1764 1
a1764 1
		/* NOTE: not handled by milter_command() */
d1773 99
d1877 7
d1895 1
a1895 1
				MILTER_CHECK_ERROR();
d1900 1
a1900 67
		/* check if filter wants this command */
		if (skipflag != 0 &&
		    bitset(skipflag, m->mf_fflags))
			continue;

		(void) milter_write(m, command, data, sz,
				    m->mf_timeout[SMFTO_WRITE], e);
		if (m->mf_state == SMFS_ERROR)
		{
			MILTER_CHECK_ERROR();
			break;
		}

		response = milter_read(m, &rcmd, &rlen,
				       m->mf_timeout[SMFTO_READ], e);
		if (m->mf_state == SMFS_ERROR)
		{
			MILTER_CHECK_ERROR();
			break;
		}

		if (tTd(64, 10))
			dprintf("milter_command(%s): returned %c%s%s\n",
				m->mf_name, (char) rcmd,
				response == NULL ? "" : ":",
				response == NULL ? "" : response);

		switch (rcmd)
		{
		  case SMFIR_REPLYCODE:
			MILTER_CHECK_REPLYCODE(defresponse);
			/* FALLTHROUGH */

		  case SMFIR_REJECT:
		  case SMFIR_DISCARD:
		  case SMFIR_TEMPFAIL:
			*state = rcmd;
			break;

		  case SMFIR_ACCEPT:
			/* this filter is done with message/connection */
			m->mf_state = SMFS_DONE;
			break;

		  case SMFIR_CONTINUE:
			/* if MAIL command is ok, filter is in message state */
			if (command == SMFIC_MAIL)
				m->mf_state = SMFS_INMSG;
			break;

		  default:
			/* Invalid response to command */
			if (LogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "milter_command(%s): returned bogus response %c",
					  m->mf_name, rcmd);
			milter_error(m);
			break;
		}

		if (*state != SMFIR_REPLYCODE &&
		    response != NULL)
		{
			free(response);
			response = NULL;
		}

d1924 3
a1926 2
	mi_int32 flags;
	char *response = NULL;
d1928 1
a1928 1
	char data[MILTER_LEN_BYTES * 2];
d1942 2
a1943 1
	flags = htonl(0);
d1946 3
a1948 1
		      (char *) &flags, MILTER_LEN_BYTES);
d1974 2
a1975 1
	if (response == NULL || rlen != MILTER_LEN_BYTES * 2)
d1992 20
a2011 1
	(void) memcpy((char *) &flags, response + MILTER_LEN_BYTES,
d2016 7
a2022 2
	/* check for version mismatch */
	if (ntohl(fvers) != SMFI_VERSION)
d2026 1
a2026 2
				m->mf_name, (u_long) ntohl(fvers),
				SMFI_VERSION);
d2030 33
a2062 2
				  m->mf_name, (u_long) ntohl(fvers),
				  SMFI_VERSION);
d2066 1
a2066 1
	m->mf_fflags = ntohl(flags);
d2068 2
a2069 2
		dprintf("milter_negotiate(%s): version %lu, flags %lx\n",
			m->mf_name, (u_long) ntohl(fvers), m->mf_fflags);
a2126 5

/*
**  Actions
*/

d2128 1
a2128 1
**  MILTER_ADDHEAER -- Add the supplied header to the message
d2131 1
a2131 2
**		response -- encoded form of header/value.
**		rlen -- length of response.
d2133 1
d2136 180
a2315 1
**		none
d2325 1
d2338 1
a2338 1
	if (rlen < 2 || strlen(response) + 1 >= rlen)
d2349 1
a2349 1
	if (strlen(response) + strlen(val) + 2 != rlen)
d2356 15
d2374 125
d2500 17
a2516 1
		dprintf("%s: %s\n", response, val);
d2518 19
a2536 1
	addheader(newstr(response), val, &e->e_header);
d2568 1
a2568 1
	    strlen(response) + 1 != rlen)
d2571 2
a2572 1
			dprintf("didn't follow protocol (total len)\n");
d2611 1
a2611 1
	    strlen(response) + 1 != rlen)
d2627 3
a2629 6
**		response -- encoded form of new body (first chunk).
**			Used to return response buffer for return rcmd.
**		rlen -- length of response.  Also return length of final
**			response.
**		rcmd -- current command (used to return new command).
**		m -- milter filter to read further chunks from.
d2637 4
a2640 5
milter_replbody(response, rlen, rcmd, m, e)
	char **response;
	ssize_t *rlen;
	char *rcmd;
	struct milter *m;
d2643 1
a2643 3
	bool failure = FALSE;
	char prevchar = '\0';
	int afd;
a2644 4
	int save_errno;
	off_t newsize = 0;
	struct stat st;
	char dfname[MAXPATHLEN];
d2647 1
a2647 4
		dprintf("milter_replbody(%s)\n", m->mf_name);

	/* save the df file name for later use */
	(void) strlcpy(dfname, queuename(e, 'd'), sizeof dfname);
d2649 2
a2650 3
	/* Get the current df information */
	if (bitset(EF_HAS_DF, e->e_flags) &&
	    e->e_dfp != NULL)
d2652 2
a2653 26
		afd = fileno(e->e_dfp);
		if (afd < 0)
		{
			save_errno = errno;
			if (tTd(64, 5))
				dprintf("milter_replbody(%s): fstat %s: %s\n",
					m->mf_name, dfname,
					errstring(save_errno));
			if (LogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "milter_replbody(%s): fstat %s: %s",
					  m->mf_name, dfname,
					  errstring(save_errno));
			failure = TRUE;
		}
		else
		{
			/* fixup e->e_msgsize */
			if (fstat(afd, &st) == 0)
			{
				newsize = e->e_msgsize - st.st_size;
				if (newsize < 0)
					newsize = 0;
			}
		}
	}
d2655 1
a2655 10
	/*
	**  In SuperSafe mode, e->e_dfp is a read-only FP so
	**  close and reopen writable (later close and reopen
	**  read only again).
	**
	**  In !SuperSafe mode, e->e_dfp still points at the
	**  buffered file I/O descriptor, still open for writing
	**  so there isn't as much work to do, just truncate it
	**  and go.
	*/
d2657 2
a2658 6
	if (SuperSafe)
	{
		/* close read-only df */
		if (bitset(EF_HAS_DF, e->e_flags) &&
		    e->e_dfp != NULL)
			(void) fclose(e->e_dfp);
d2660 2
a2661 2
		/* open writable */
		if ((e->e_dfp = fopen(dfname, "w")) == NULL)
d2663 6
a2668 12
			save_errno = errno;
			if (tTd(64, 5))
				dprintf("milter_replbody(%s): fopen %s: %s\n",
					m->mf_name, dfname,
					errstring(save_errno));
			if (LogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "milter_replbody(%s): fopen %s: %s",
					  m->mf_name, dfname,
					  errstring(save_errno));
			e->e_flags &= ~EF_HAS_DF;
			failure = TRUE;
a2669 25
	}
	else if (e->e_dfp == NULL)
	{
		/* shouldn't happen */
		if (tTd(64, 5))
			dprintf("milter_replbody(%s): NULL e_dfp (%s)\n",
				m->mf_name, dfname);
		if (LogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_replbody(%s): NULL e_dfp (%s)\n",
				  m->mf_name, dfname);
			failure = TRUE;
	}
	else if (bftruncate(e->e_dfp) < 0)
	{
		save_errno = errno;
		if (tTd(64, 5))
			dprintf("milter_replbody(%s): bftruncate %s: %s\n",
				m->mf_name, dfname, errstring(save_errno));
		if (LogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_replbody(%s): bftruncate %s: %s",
				  m->mf_name, dfname, errstring(save_errno));
		failure = TRUE;
	}
d2671 7
a2677 3
	for (;;)
	{
		if (*response != NULL)
d2679 4
a2682 49
			/*
			**  Can't simply return on failure, have to
			**  collect all data from remote filter to
			**  prevent the protocol from getting out of sync.
			**  Another way to fix this would be to have the
			**  MTA ACK/NAK each body chunk it receives.
			*/

			if (!failure)
			{
				for (i = 0; i < *rlen; i++)
				{
					/* Buffered char from last chunk */
					if (i == 0 && prevchar == '\r')
					{
						/* Not CRLF, output prevchar */
						if ((*response)[i] != '\n')
						{
							(void) putc(prevchar,
								    e->e_dfp);
							if (newsize > 0)
								newsize++;
						}
						prevchar = '\0';
					}

					/* Turn CRLF into LF */
					if ((*response)[i] == '\r')
					{
						/* check if at end of chunk */
						if (i + 1 < *rlen)
						{
							/* If LF, strip CR */
							if ((*response)[i + 1] == '\n')
								i++;
						}
						else
						{
							/* check next chunk */
							prevchar = '\r';
						}
					}
					(void) putc((*response)[i], e->e_dfp);
					if (newsize > 0)
						newsize++;
				}
			}
			free(*response);
			*response = NULL;
d2684 1
d2686 10
a2695 3
		/* Get next command (might be another body chunk) */
		*response = milter_read(m, rcmd, rlen,
					m->mf_timeout[SMFTO_READ], e);
d2697 4
a2700 1
		if (m->mf_state == SMFS_ERROR)
d2702 2
a2703 1
			if (SuperSafe)
d2705 2
a2706 3
				(void) fclose(e->e_dfp);
				e->e_dfp = NULL;
				e->e_flags &= ~EF_HAS_DF;
d2708 1
a2708 2
			failure = TRUE;
			break;
d2711 2
a2712 26
		/* If not another body chunk, save for returning */
		if (*rcmd != SMFIR_REPLBODY)
			break;

		if (tTd(64, 10))
			dprintf("milter_replbody(%s): returned %c%s%s\n",
				m->mf_name, (char) *rcmd,
				*response == NULL ? "" : ":",
				*response == NULL ? "" : *response);
	}

	/* Now it's safe to return */
	if (failure)
		return -1;

	if (fflush(e->e_dfp) != 0 || ferror(e->e_dfp))
	{
		save_errno = errno;
		if (tTd(64, 5))
			dprintf("milter_replbody(%s): error writing/flushing %s: %s\n",
				m->mf_name, dfname, errstring(save_errno));
		if (LogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_replbody(%s): error writing/flushing %s: %s",
				  m->mf_name, dfname, errstring(save_errno));
		if (SuperSafe)
d2714 13
a2726 3
			(void) fclose(e->e_dfp);
			e->e_dfp = NULL;
			e->e_flags &= ~EF_HAS_DF;
d2728 2
a2729 47
		return -1;
	}
	else if (!SuperSafe)
	{
		/* skip next few clauses */
		/* EMPTY */
	}
	else if ((afd = fileno(e->e_dfp)) >= 0 && fsync(afd) < 0)
	{
		save_errno = errno;
		if (tTd(64, 5))
			dprintf("milter_replbody(%s): error sync'ing %s: %s\n",
				m->mf_name, dfname, errstring(save_errno));
		if (LogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_replbody(%s): error sync'ing %s: %s",
				  m->mf_name, dfname, errstring(save_errno));
		(void) fclose(e->e_dfp);
		e->e_dfp = NULL;
		e->e_flags &= ~EF_HAS_DF;
		return -1;
	}
	else if (fclose(e->e_dfp) < 0)
	{
		save_errno = errno;
		if (tTd(64, 5))
			dprintf("milter_replbody(%s): error closing %s: %s\n",
				m->mf_name, dfname, errstring(save_errno));
		if (LogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_replbody(%s): error closing %s: %s",
				  m->mf_name, dfname, errstring(save_errno));
		e->e_flags &= ~EF_HAS_DF;
		return -1;
	}
	else if ((e->e_dfp = fopen(dfname, "r")) == NULL)
	{
		save_errno = errno;
		if (tTd(64, 5))
			dprintf("milter_replbody(%s): error reopening %s: %s",
				m->mf_name, dfname, errstring(save_errno));
		if (LogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_replbody(%s): error reopening %s: %s",
				  m->mf_name, dfname, errstring(save_errno));
		e->e_flags &= ~EF_HAS_DF;
		return -1;
a2730 6
	else
		e->e_flags |= EF_HAS_DF;

	/* Set the message size */
	if (newsize > 0)
		e->e_msgsize = newsize;
d2768 1
a2768 1
			MILTER_CHECK_ERROR();
a2781 5
			if (m->mf_sock >= 0)
			{
				(void) close(m->mf_sock);
				m->mf_sock = -1;
			}
d2783 1
a2783 5
			if (m->mf_state == SMFS_ERROR)
			{
				MILTER_CHECK_ERROR();
				break;
			}
d2866 1
a2866 1
		s += sizeof(port) + strlen(sockinfo);
d2881 3
a2883 1
		(void) memcpy(bp, sockinfo, strlen(sockinfo));
d3089 1
a3089 78
**  MILTER_HEADER -- send single header to milter filters
**
**	Parameters:
**		name -- header field name.
**		value -- header value (including continuation lines).
**		e -- current envelope.
**		state -- return state from response.
**
**	Returns:
**		response string (may be NULL)
*/

char *
milter_header(name, value, e, state)
	char *name;
	char *value;
	ENVELOPE *e;
	char *state;
{
	char *buf;
	char *response;
	ssize_t s;

	if (tTd(64, 10))
		dprintf("milter_header: %s: %s\n", name, value);

	s = strlen(name) + 1 + strlen(value) + 1;
	buf = (char *) xalloc(s);
	snprintf(buf, s, "%s%c%s", name, '\0', value);

	/* send it over */
	response = milter_command(SMFIC_HEADER, buf, s, (char **)NULL, e, state);
	free(buf);

	/*
	**  If filter rejects/discards a per message command,
	**  abort the other filters since we are done with the
	**  current message.
	*/

	MILTER_CHECK_DONE_MSG();
	return response;
}
/*
**  MILTER_EOH -- notify milter filters that the headers are done
**
**	Parameters:
**		e -- current envelope.
**		state -- return state from response.
**
**	Returns:
**		response string (may be NULL)
*/

char *
milter_eoh(e, state)
	ENVELOPE *e;
	char *state;
{
	char *response;

	if (tTd(64, 10))
		dprintf("milter_eoh\n");

	response = milter_command(SMFIC_EOH, (void *) NULL, 0,
				  (char **)NULL, e, state);

	/*
	**  If filter rejects/discards a per message command,
	**  abort the other filters since we are done with the
	**  current message.
	*/

	MILTER_CHECK_DONE_MSG();
	return response;
}
/*
**  MILTER_BODY -- send message body and gather final message results
d3104 15
d3120 1
a3120 1
milter_body(e, state)
d3124 5
a3128 2
	bool replfailed = FALSE;
	bool rewind = FALSE;
a3129 2
	char bufchar = '\0';
	char prevchar = '\0';
a3130 1
	int c;
a3131 1
	char *bp;
a3134 1
	char buf[MILTER_CHUNK_SIZE];
d3137 1
a3137 1
		dprintf("milter_body\n");
d3141 7
a3147 5
/*
**  XXX: Should actually send body chunks to each filter
**  a chunk at a time instead of sending the whole body to
**  each filter in turn
*/
d3165 8
a3179 1
		bp = buf;
d3181 2
a3182 2
		/* check if filter wants the body */
		if (bitset(SMFIF_NOBODY, m->mf_fflags))
d3184 2
a3185 2
			/* still need to send BODYEOB */
			goto eob;
d3188 2
a3189 1
		if (e->e_dfp == NULL)
d3191 2
a3192 3
			/* shouldn't happen */
			goto eob;
		}
d3194 4
a3197 7
		if (bfrewind(e->e_dfp) < 0)
		{
			ExitStat = EX_IOERR;
			*state = SMFIR_TEMPFAIL;
			syserr("milter_body: %s/df%s: read error",
			       qid_printqueue(e->e_queuedir), e->e_id);
			break;
d3200 3
a3202 2
		rewind = TRUE;
		while ((c = getc(e->e_dfp)) != EOF)
d3204 3
a3206 85
			/*  Change LF to CRLF */
			if (c == '\n')
			{
				/* Not a CRLF already? */
				if (prevchar != '\r')
				{
					/* Room for CR now? */
					if (bp + 2 >= &buf[sizeof buf])
					{
						/* No room, buffer LF */
						bufchar = c;

						/* and send CR now */
						c = '\r';
					}
					else
					{
						/* Room to do it all now */
						*bp++ = '\r';
						prevchar = '\r';
					}
				}
			}
			*bp++ = (char) c;
			prevchar = c;
			if (bp >= &buf[sizeof buf])
			{
				/* send chunk */
				(void) milter_write(m, SMFIC_BODY, buf,
						    bp - buf,
						    m->mf_timeout[SMFTO_WRITE],
						    e);
				if (m->mf_state == SMFS_ERROR)
					break;
				bp = buf;
				if (bufchar != '\0')
				{
					*bp++ = bufchar;
					bufchar = '\0';
					prevchar = bufchar;
				}

				/* get reply */
				response = milter_read(m, &rcmd, &rlen,
						       m->mf_timeout[SMFTO_READ],
						       e);
				if (m->mf_state == SMFS_ERROR)
					break;
				switch (rcmd)
				{
				  case SMFIR_REPLYCODE:
					MILTER_CHECK_REPLYCODE("554 5.7.1 Command rejected");
					/* FALLTHROUGH */

				  case SMFIR_REJECT:
				  case SMFIR_DISCARD:
				  case SMFIR_TEMPFAIL:
				  case SMFIR_ACCEPT:
				  case SMFIR_CONTINUE:
					*state = rcmd;
					if (*state != SMFIR_CONTINUE)
						m->mf_state = SMFS_DONE;
					break;

				  default:
					/* Invalid response to command */
					if (LogLevel > 0)
						sm_syslog(LOG_ERR, e->e_id,
							  "milter_body(%s): returned bogus response %c",
							  m->mf_name, rcmd);
					milter_error(m);
					break;
				}
				if (rcmd != SMFIR_REPLYCODE &&
				    response != NULL)
				{
					free(response);
					response = NULL;
				}
			}
			if (*state == SMFIR_ACCEPT)
				break;

			if (*state != SMFIR_CONTINUE)
				goto finishup;
d3209 3
a3211 21
		/* check for read errors */
		if (ferror(e->e_dfp))
			goto death;

		/* if filter accepted the message, move on to the next one */
		if (*state == SMFIR_ACCEPT)
			continue;

eob:
		/* Make sure there wasn't an error above before proceeding */
		if (m->mf_state != SMFS_ERROR)
		{
			/* send the final body chunk */
			(void) milter_write(m, SMFIC_BODYEOB, buf, bp - buf,
					    m->mf_timeout[SMFTO_WRITE], e);
		}
		else
		{
			MILTER_CHECK_ERROR();
			goto finishup;
		}
a3218 4
			/* From a prevous state */
			if (m->mf_state == SMFS_ERROR)
				break;

d3224 1
a3224 1
					dprintf("milter_body(%s): EOM ACK/NAK timeout\n",
d3228 1
a3228 1
						  "milter_body(%s): EOM ACK/NAK timeout\n",
d3231 1
a3231 1
				MILTER_CHECK_ERROR();
a3239 1
newstate:
d3241 2
a3242 4
				dprintf("milter_body(%s): state %c%s%s\n",
					m->mf_name, (char) rcmd,
					response == NULL ? "" : ":",
					response == NULL ? "" : response);
d3273 1
a3273 1
				if (!bitset(SMFIF_MODHDRS, m->mf_fflags))
d3277 1
a3277 1
							  "milter_body(%s): lied about adding headers, honoring request anyway",
d3283 11
d3299 1
a3299 1
							  "milter_body(%s) lied about adding recipients, honoring request anyway",
d3310 1
a3310 1
							  "milter_body(%s): lied about removing recipients, honoring request anyway",
d3321 1
a3321 1
							  "milter_body(%s): lied about replacing body, rejecting request and tempfailing message",
d3324 1
a3324 1
					goto newstate;
a3325 1
				rewind = TRUE;
d3327 5
a3331 2
				/* protect &response in next command */
				if (response == NULL)
d3333 7
a3339 2
					response = newstr("");
					rlen = 0;
d3342 2
a3343 7
				if (milter_replbody(&response, &rlen,
						    &rcmd, m, e) < 0)
				{
					if (LogLevel > 0)
						sm_syslog(LOG_ERR, e->e_id,
							  "milter_body(%s): Failed to replace body, tempfailing message",
							  m->mf_name);
d3345 3
a3347 3
					rewind = FALSE;
				}
				goto newstate;
d3353 1
a3353 1
						  "milter_body(%s): returned bogus response %c",
d3364 10
d3375 1
d3378 1
a3378 1
			MILTER_CHECK_ERROR();
d3385 25
a3409 1
	if (rewind && bfrewind(e->e_dfp) < 0)
a3410 1
death:
d3421 1
d3423 6
d3431 1
a3431 1
		syserr("milter_body: %s/df%s: read error",
d3434 1
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d12 1
a12 1
static char id[] = "@@(#)$Sendmail: milter.c,v 8.50.4.46 2001/05/11 18:11:36 gshapiro Exp $";
d25 4
a28 3
#  define SM_FD_SET	FD_SET
#  define SM_FD_ISSET	FD_ISSET
#  define SM_FD_SETSIZE	FD_SETSIZE
a30 2
static int	milter_open __P((struct milter *, bool, ENVELOPE *));
static void	milter_parse_timeouts __P((char *, struct milter *));
d37 1
a37 1
# define MILTER_CHECK_DONE_MSG() \
d47 1
a47 1
# define MILTER_CHECK_ERROR(action) \
d53 1
a53 1
		action;
d55 1
a55 1
# define MILTER_CHECK_REPLYCODE(default) \
d57 1
a57 1
	    strlen(response) + 1 != (size_t) rlen || \
d64 1
a64 1
			sm_free(response); \
d76 1
a76 1
				sm_free(response); \
a83 23
# define MILTER_DF_ERROR(msg) \
{ \
	int save_errno = errno; \
 \
	if (tTd(64, 5)) \
	{ \
		dprintf(msg, dfname, errstring(save_errno)); \
		dprintf("\n"); \
	} \
	if (LogLevel > 0) \
		sm_syslog(LOG_ERR, e->e_id, msg, dfname, errstring(save_errno)); \
	if (SuperSafe) \
	{ \
		if (e->e_dfp != NULL) \
		{ \
			(void) fclose(e->e_dfp); \
			e->e_dfp = NULL; \
		} \
		e->e_flags &= ~EF_HAS_DF; \
	} \
	errno = save_errno; \
}

d95 1
a95 1
# define MILTER_TIMEOUT(routine, secs, write) \
d102 1
a102 1
	if (SM_FD_SETSIZE != 0 && m->mf_sock >= SM_FD_SETSIZE) \
d106 1
a106 1
				routine, m->mf_name, m->mf_sock, SM_FD_SETSIZE); \
d110 1
a110 1
				  routine, m->mf_name, m->mf_sock, SM_FD_SETSIZE); \
d116 1
a116 1
	SM_FD_SET(m->mf_sock, &fds); \
d148 1
a148 1
		if (SM_FD_ISSET(m->mf_sock, &fds)) \
d181 1
a181 1
milter_sysread(m, buf, sz, to, e)
d183 2
a184 2
	char *buf;
	ssize_t sz;
d188 5
a192 2
	time_t readstart = 0;
	ssize_t len, curl;
d194 2
a195 1
	curl = 0;
d198 1
d200 2
d203 2
a204 1
	for (;;)
d206 1
a206 44
		if (to > 0)
		{
			time_t now;

			now = curtime();
			if (now - readstart >= to)
			{
				if (tTd(64, 5))
					dprintf("milter_read(%s): timeout before data read\n",
						m->mf_name);
				if (LogLevel > 0)
					sm_syslog(LOG_ERR, e->e_id,
						  "milter_read(%s): timeout before data read\n",
						  m->mf_name);
				milter_error(m);
				return NULL;
			}
			to -= now - readstart;
			readstart = now;
			MILTER_TIMEOUT("milter_read", to, FALSE);
		}

		len = read(m->mf_sock, buf + curl, sz - curl);

		if (len < 0)
		{
			int save_errno = errno;

			if (tTd(64, 5))
				dprintf("milter_read(%s): read returned %ld: %s\n",
					m->mf_name, (long) len,
					errstring(save_errno));
			if (LogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "milter_read(%s): read returned %ld: %s",
					  m->mf_name, (long) len,
					  errstring(save_errno));
			milter_error(m);
			return NULL;
		}

		curl += len;
		if (len == 0 || curl >= sz)
			break;
d208 10
d220 1
a220 1
	if (curl != sz)
d223 2
a224 2
			dprintf("milter_read(%s): read returned %ld, expecting %ld\n",
				m->mf_name, (long) curl, (long) sz);
d227 3
a229 2
				  "milter_read(%s): read returned %ld, expecting %ld",
				  m->mf_name, (long) curl, (long) sz);
a232 2
	return buf;
}
d234 4
a237 13
static char *
milter_read(m, cmd, rlen, to, e)
	struct milter *m;
	char *cmd;
	ssize_t *rlen;
	time_t to;
	ENVELOPE *e;
{
	time_t readstart = 0;
	ssize_t expl;
	mi_int32 i;
	char *buf;
	char data[MILTER_LEN_BYTES + 1];
d239 3
a241 2
	*rlen = 0;
	*cmd = '\0';
d243 12
a254 2
	if (to > 0)
		readstart = curtime();
d256 1
a256 1
	if (milter_sysread(m, data, sizeof data, to, e) == NULL)
d259 2
a260 1
	/* reset timeout */
d278 5
a282 1
		to -= now - readstart;
d285 4
a288 8
	*cmd = data[MILTER_LEN_BYTES];
	data[MILTER_LEN_BYTES] = '\0';
	(void) memcpy(&i, data, MILTER_LEN_BYTES);
	expl = ntohl(i) - 1;

	if (tTd(64, 25))
		dprintf("milter_read(%s): expecting %ld bytes\n",
			m->mf_name, (long) expl);
a289 2
	if (expl < 0)
	{
d291 2
a292 2
			dprintf("milter_read(%s): read size %ld out of range\n",
				m->mf_name, (long) expl);
d295 4
a298 2
				  "milter_read(%s): read size %ld out of range",
				  m->mf_name, (long) expl);
d302 1
a302 7

	if (expl == 0)
		return NULL;

	buf = (char *)xalloc(expl);

	if (milter_sysread(m, buf, expl, to, e) == NULL)
d304 9
a312 1
		sm_free(buf);
a314 1

d317 1
a317 2
			m->mf_name, (int) expl, buf);
	*rlen = expl;
d467 1
a467 1
static int
d575 1
a575 1
		long sff = SFF_SAFEDIRPATH|SFF_OPENASROOT|SFF_NOLINK|SFF_EXECOK;
d597 2
a598 10
		/* if just parsing .cf file, socket doesn't need to exist */
		if (parseonly && errno == ENOENT)
		{
			if (OpMode == MD_DAEMON ||
			    OpMode == MD_FGDAEMON)
				fprintf(stderr,
					"WARNING: X%s: local socket name %s missing\n",
					m->mf_name, colon);
		}
		else if (errno != 0)
a599 1
			/* if not safe, don't create */
a624 1
	else
d627 1
a627 1
	if (FALSE
d657 1
a657 1
			port = htons((u_short) atoi(colon));
a825 3
#  if _FFR_FREEHOSTENT && NETINET6
				freehostent(hp);
#  endif /* _FFR_FREEHOSTENT && NETINET6 */
d830 1
a831 1
# endif /* NETINET || NETINET6 */
a847 4
# if _FFR_FREEHOSTENT && NETINET6
		if (hp != NULL)
			freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a859 4
# if _FFR_FREEHOSTENT && NETINET6
		if (hp != NULL)
			freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a877 4
# if _FFR_FREEHOSTENT && NETINET6
			if (hp != NULL)
				freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a885 2
		p = CurHostName;
		CurHostName = at;
a892 1
		CurHostName = p;
a926 3
# if _FFR_FREEHOSTENT && NETINET6
				freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d932 2
a933 2
			dprintf("X%s: error connecting to filter: %s\n",
				m->mf_name, errstring(save_errno));
d936 2
a937 2
				  "X%s: error connecting to filter: %s",
				  m->mf_name, errstring(save_errno));
a938 4
# if _FFR_FREEHOSTENT && NETINET6
		if (hp != NULL)
			freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a941 7
# if _FFR_FREEHOSTENT && NETINET6
	if (hp != NULL)
	{
		freehostent(hp);
		hp = NULL;
	}
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a944 104
**  MILTER_SETUP -- setup structure for a mail filter
**
**	Parameters:
**		line -- the options line.
**
**	Returns:
**		none
*/

void
milter_setup(line)
	char *line;
{
	char fcode;
	register char *p;
	register struct milter *m;
	STAB *s;

	/* collect the filter name */
	for (p = line;
	     *p != '\0' && *p != ',' && !(isascii(*p) && isspace(*p));
	     p++)
		continue;
	if (*p != '\0')
		*p++ = '\0';
	if (line[0] == '\0')
	{
		syserr("name required for mail filter");
		return;
	}
	m = (struct milter *)xalloc(sizeof *m);
	memset((char *) m, '\0', sizeof *m);
	m->mf_name = newstr(line);
	m->mf_state = SMFS_READY;
	m->mf_sock = -1;
	m->mf_timeout[SMFTO_WRITE] = (time_t) 10;
	m->mf_timeout[SMFTO_READ] = (time_t) 10;
	m->mf_timeout[SMFTO_EOM] = (time_t) 300;

	/* now scan through and assign info from the fields */
	while (*p != '\0')
	{
		char *delimptr;

		while (*p != '\0' &&
		       (*p == ',' || (isascii(*p) && isspace(*p))))
			p++;

		/* p now points to field code */
		fcode = *p;
		while (*p != '\0' && *p != '=' && *p != ',')
			p++;
		if (*p++ != '=')
		{
			syserr("X%s: `=' expected", m->mf_name);
			return;
		}
		while (isascii(*p) && isspace(*p))
			p++;

		/* p now points to the field body */
		p = munchstring(p, &delimptr, ',');

		/* install the field into the filter struct */
		switch (fcode)
		{
		  case 'S':		/* socket */
			if (p == NULL)
				m->mf_conn = NULL;
			else
				m->mf_conn = newstr(p);
			break;

		  case 'F':		/* Milter flags configured on MTA */
			for (; *p != '\0'; p++)
			{
				if (!(isascii(*p) && isspace(*p)))
					setbitn(bitidx(*p), m->mf_flags);
			}
			break;

		  case 'T':		/* timeouts */
			milter_parse_timeouts(p, m);
			break;

		  default:
			syserr("X%s: unknown filter equate %c=",
			       m->mf_name, fcode);
			break;
		}
		p = delimptr;
	}

	/* early check for errors */
	(void) milter_open(m, TRUE, CurEnv);

	/* enter the filter into the symbol table */
	s = stab(m->mf_name, ST_MILTER, ST_ENTER);
	if (s->s_milter != NULL)
		syserr("X%s: duplicate filter definition", m->mf_name);
	else
		s->s_milter = m;
}
/*
d1015 1
a1015 1
static void
d1049 1
a1049 1
		/* install the field into the filter struct */
d1109 1
a1109 1
# define MO_MACROS_CONNECT		0x01
d1111 1
a1111 1
# define MO_MACROS_HELO			0x02
d1113 1
a1113 1
# define MO_MACROS_ENVFROM		0x03
d1115 1
a1115 1
# define MO_MACROS_ENVRCPT		0x04
d1220 1
a1220 1
**  MILTER_REOPEN_DF -- open & truncate the df file (for replbody)
d1223 1
a1223 1
**		e -- current envelope.
d1226 1
a1226 1
**		0 if succesful, -1 otherwise
d1229 2
a1230 3
static int
milter_reopen_df(e)
	ENVELOPE *e;
d1232 1
a1232 1
	char dfname[MAXPATHLEN];
d1234 1
a1234 14
	(void) strlcpy(dfname, queuename(e, 'd'), sizeof dfname);

	/*
	**  In SuperSafe mode, e->e_dfp is a read-only FP so
	**  close and reopen writable (later close and reopen
	**  read only again).
	**
	**  In !SuperSafe mode, e->e_dfp still points at the
	**  buffered file I/O descriptor, still open for writing
	**  so there isn't as much work to do, just truncate it
	**  and go.
	*/

	if (SuperSafe)
d1236 1
a1236 6
		/* close read-only df */
		if (bitset(EF_HAS_DF, e->e_flags) && e->e_dfp != NULL)
		{
			(void) fclose(e->e_dfp);
			e->e_flags &= ~EF_HAS_DF;
		}
d1238 2
a1239 6
		/* open writable */
		if ((e->e_dfp = fopen(dfname, "w+")) == NULL)
		{
			MILTER_DF_ERROR("milter_reopen_df: fopen %s: %s");
			return -1;
		}
d1241 1
a1241 8
	else if (e->e_dfp == NULL)
	{
		/* shouldn't happen */
		errno = ENOENT;
		MILTER_DF_ERROR("milter_reopen_df: NULL e_dfp (%s: %s)");
		return -1;
	}
	return 0;
d1244 1
a1244 1
**  MILTER_RESET_DF -- re-open read-only the df file (for replbody)
d1247 1
d1251 1
a1251 1
**		0 if succesful, -1 otherwise
d1254 3
a1256 2
static int
milter_reset_df(e)
d1259 3
a1261 87
	int afd;
	char dfname[MAXPATHLEN];

	(void) strlcpy(dfname, queuename(e, 'd'), sizeof dfname);

	if (fflush(e->e_dfp) != 0 || ferror(e->e_dfp))
	{
		MILTER_DF_ERROR("milter_reset_df: error writing/flushing %s: %s");
		return -1;
	}
	else if (!SuperSafe)
	{
		/* skip next few clauses */
		/* EMPTY */
	}
	else if ((afd = fileno(e->e_dfp)) >= 0 && fsync(afd) < 0)
	{
		MILTER_DF_ERROR("milter_reset_df: error sync'ing %s: %s");
		return -1;
	}
	else if (fclose(e->e_dfp) < 0)
	{
		MILTER_DF_ERROR("milter_reset_df: error closing %s: %s");
		return -1;
	}
	else if ((e->e_dfp = fopen(dfname, "r")) == NULL)
	{
		MILTER_DF_ERROR("milter_reset_df: error reopening %s: %s");
		return -1;
	}
	else
		e->e_flags |= EF_HAS_DF;
	return 0;
}
/*
**  MILTER_CAN_DELRCPTS -- can any milter filters delete recipients?
**
**	Parameters:
**		none
**
**	Returns:
**		TRUE if any filter deletes recipients, FALSE otherwise
*/

bool
milter_can_delrcpts()
{
	bool can = FALSE;
	int i;

	if (tTd(64, 10))
		dprintf("milter_can_delrcpts:");

	for (i = 0; InputFilters[i] != NULL; i++)
	{
		struct milter *m = InputFilters[i];

		if (bitset(SMFIF_DELRCPT, m->mf_fflags))
		{
			can = TRUE;
			break;
		}
	}
	if (tTd(64, 10))
		dprintf("%s\n", can ? "TRUE" : "FALSE");

	return can;
}
/*
**  MILTER_QUIT_FILTER -- close down a single filter
**
**	Parameters:
**		m -- milter structure of filter to close down.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_quit_filter(m, e)
	struct milter *m;
	ENVELOPE *e;
{
	if (tTd(64, 10))
		dprintf("milter_quit_filter(%s)\n", m->mf_name);

d1277 2
a1278 5
	if (m->mf_sock >= 0)
	{
		(void) close(m->mf_sock);
		m->mf_sock = -1;
	}
d1345 1
a1345 1
		if (mid == 0)
d1359 1
a1359 1
		if (mid == 0)
d1376 1
a1376 1
	sm_free(buf);
a1377 1

d1379 1
a1379 1
**  MILTER_SEND_COMMAND -- send a command and return the response for a filter
a1381 1
**		m -- current milter filter
d1385 2
a1386 1
**		e -- current envelope (for e->e_id).
d1394 1
a1394 2
milter_send_command(m, command, data, sz, e, state)
	struct milter *m;
d1398 1
d1402 1
a1403 1
	ssize_t rlen;
d1405 1
d1407 1
a1407 1
	char *response;
d1410 2
a1411 2
		dprintf("milter_send_command(%s): cmd %c len %ld\n",
			m->mf_name, (char) command, (long) sz);
d1417 1
a1417 1
		skipflag = SMFIP_NOCONNECT;
d1422 1
a1422 1
		skipflag = SMFIP_NOHELO;
d1427 1
a1427 1
		skipflag = SMFIP_NOMAIL;
d1432 1
a1432 1
		skipflag = SMFIP_NORCPT;
d1437 2
a1438 1
		skipflag = SMFIP_NOHDRS;
a1442 9
		skipflag = SMFIP_NOBODY;
		defresponse = "554 5.7.1 Command rejected";
		break;

	  case SMFIC_EOH:
		skipflag = SMFIP_NOEOH;
		defresponse = "550 5.7.1 Command rejected";
		break;

d1448 1
a1448 1
		/* NOTE: not handled by milter_send_command() */
a1456 103
	/* check if filter wants this command */
	if (skipflag != 0 &&
	    bitset(skipflag, m->mf_pflags))
		return NULL;


	(void) milter_write(m, command, data, sz,
			    m->mf_timeout[SMFTO_WRITE], e);
	if (m->mf_state == SMFS_ERROR)
	{
		MILTER_CHECK_ERROR(/* EMPTY */;);
		return NULL;
	}

	response = milter_read(m, &rcmd, &rlen,
			       m->mf_timeout[SMFTO_READ], e);
	if (m->mf_state == SMFS_ERROR)
	{
		MILTER_CHECK_ERROR(/* EMPTY */;);
		return NULL;
	}

	if (tTd(64, 10))
		dprintf("milter_send_command(%s): returned %c\n",
			m->mf_name, (char) rcmd);

	switch (rcmd)
	{
	  case SMFIR_REPLYCODE:
		MILTER_CHECK_REPLYCODE(defresponse);
		/* FALLTHROUGH */

	  case SMFIR_REJECT:
	  case SMFIR_DISCARD:
	  case SMFIR_TEMPFAIL:
		*state = rcmd;
		break;

	  case SMFIR_ACCEPT:
		/* this filter is done with message/connection */
		if (command == SMFIC_HELO ||
		    command == SMFIC_CONNECT)
			m->mf_state = SMFS_CLOSABLE;
		else
			m->mf_state = SMFS_DONE;
		break;

	  case SMFIR_CONTINUE:
		/* if MAIL command is ok, filter is in message state */
		if (command == SMFIC_MAIL)
			m->mf_state = SMFS_INMSG;
		break;

	  default:
		/* Invalid response to command */
		if (LogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_send_command(%s): returned bogus response %c",
				  m->mf_name, rcmd);
		milter_error(m);
		break;
	}

	if (*state != SMFIR_REPLYCODE &&
	    response != NULL)
	{
		sm_free(response);
		response = NULL;
	}
	return response;
}

/*
**  MILTER_COMMAND -- send a command and return the response for each filter
**
**	Parameters:
**		command -- command to send.
**		data -- optional command data.
**		sz -- length of buf.
**		macros -- macros to send for filter smfi_getsymval().
**		e -- current envelope (for macro access).
**		state -- return state word.
**
**	Returns:
**		response string (may be NULL)
*/

static char *
milter_command(command, data, sz, macros, e, state)
	char command;
	void *data;
	ssize_t sz;
	char **macros;
	ENVELOPE *e;
	char *state;
{
	int i;
	char *response = NULL;

	if (tTd(64, 10))
		dprintf("milter_command: cmd %c len %ld\n",
			(char) command, (long) sz);

a1461 7
		/* previous problem? */
		if (m->mf_state == SMFS_ERROR)
		{
			MILTER_CHECK_ERROR(continue);
			break;
		}

d1473 1
a1473 1
				MILTER_CHECK_ERROR(continue);
d1478 67
a1544 1
		response = milter_send_command(m, command, data, sz, e, state);
d1568 2
a1569 3
	mi_int32 fflags;
	mi_int32 pflags;
	char *response;
d1571 1
a1571 1
	char data[MILTER_OPTLEN];
d1585 1
a1585 2
	fflags = htonl(SMFI_CURR_ACTS);
	pflags = htonl(SMFI_CURR_PROT);
d1588 1
a1588 3
		      (char *) &fflags, MILTER_LEN_BYTES);
	(void) memcpy(data + (MILTER_LEN_BYTES * 2),
		      (char *) &pflags, MILTER_LEN_BYTES);
d1609 1
a1609 1
			sm_free(response);
d1614 1
a1614 2
	/* Make sure we have enough bytes for the version */
	if (response == NULL || rlen < MILTER_LEN_BYTES)
d1624 1
a1624 1
			sm_free(response);
d1631 1
a1631 18

	/* Now make sure we have enough for the feature bitmap */
	if (rlen != MILTER_OPTLEN)
	{
		if (tTd(64, 5))
			dprintf("milter_negotiate(%s): did not return enough info\n",
				m->mf_name);
		if (LogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_negotiate(%s): did not return enough info",
				  m->mf_name);
		if (response != NULL)
			sm_free(response);
		milter_error(m);
		return -1;
	}

	(void) memcpy((char *) &fflags, response + MILTER_LEN_BYTES,
d1633 1
a1633 3
	(void) memcpy((char *) &pflags, response + (MILTER_LEN_BYTES * 2),
		      MILTER_LEN_BYTES);
	sm_free(response);
d1636 2
a1637 7
	m->mf_fvers = ntohl(fvers);
	m->mf_fflags = ntohl(fflags);
	m->mf_pflags = ntohl(pflags);

	/* check for version compatibility */
	if (m->mf_fvers == 1 ||
	    m->mf_fvers > SMFI_VERSION)
d1641 2
a1642 1
				m->mf_name, m->mf_fvers, SMFI_VERSION);
d1646 2
a1647 33
				  m->mf_name, m->mf_fvers, SMFI_VERSION);
		milter_error(m);
		return -1;
	}

	/* check for filter feature mismatch */
	if ((m->mf_fflags & SMFI_CURR_ACTS) != m->mf_fflags)
	{
		if (tTd(64, 5))
			dprintf("milter_negotiate(%s): filter abilities 0x%lx != MTA milter abilities 0x%lx\n",
				m->mf_name, m->mf_fflags,
				(u_long) SMFI_CURR_ACTS);
		if (LogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_negotiate(%s): filter abilities 0x%lx != MTA milter abilities 0x%lx\n",
				  m->mf_name, m->mf_fflags,
				  (u_long) SMFI_CURR_ACTS);
		milter_error(m);
		return -1;
	}

	/* check for protocol feature mismatch */
	if ((m->mf_pflags & SMFI_CURR_PROT) != m->mf_pflags)
	{
		if (tTd(64, 5))
			dprintf("milter_negotiate(%s): protocol abilities 0x%lx != MTA milter abilities 0x%lx\n",
				m->mf_name, m->mf_pflags,
				(u_long) SMFI_CURR_PROT);
		if (LogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_negotiate(%s): protocol abilities 0x%lx != MTA milter abilities 0x%lx\n",
				  m->mf_name, m->mf_pflags,
				  (u_long) SMFI_CURR_PROT);
d1651 1
a1651 1

d1653 2
a1654 2
		dprintf("milter_negotiate(%s): version %lu, fflags 0x%lx, pflags 0x%lx\n",
			m->mf_name, m->mf_fvers, m->mf_fflags, m->mf_pflags);
d1680 1
a1680 1
		if (m->mf_state == SMFS_CLOSABLE)
d1712 5
d1718 1
a1718 1
**  MILTER_HEADERS -- send headers to a single milter filter
d1721 2
a1722 181
**		m -- current filter.
**		e -- current envelope.
**		state -- return state from response.
**
**	Returns:
**		response string (may be NULL)
*/

static char *
milter_headers(m, e, state)
	struct milter *m;
	ENVELOPE *e;
	char *state;
{
	char *response = NULL;
	HDR *h;

	for (h = e->e_header; h != NULL; h = h->h_link)
	{
		char *buf;
		ssize_t s;

		/* don't send over deleted headers */
		if (h->h_value == NULL)
		{
			/* strip H_USER so not counted in milter_chgheader() */
			h->h_flags &= ~H_USER;
			continue;
		}

		/* skip auto-generated */
		if (!bitset(H_USER, h->h_flags))
			continue;

		if (tTd(64, 10))
			dprintf("milter_headers: %s: %s\n",
				h->h_field, h->h_value);

		s = strlen(h->h_field) + 1 +
			strlen(h->h_value) + 1;
		buf = (char *) xalloc(s);
		snprintf(buf, s, "%s%c%s", h->h_field, '\0', h->h_value);

		/* send it over */
		response = milter_send_command(m, SMFIC_HEADER, buf,
					       s, e, state);
		sm_free(buf);
		if (m->mf_state == SMFS_ERROR ||
		    m->mf_state == SMFS_DONE ||
		    *state != SMFIR_CONTINUE)
			break;
	}
	return response;
}
/*
**  MILTER_BODY -- send the body to a filter
**
**	Parameters:
**		m -- current filter.
**		e -- current envelope.
**		state -- return state from response.
**
**	Returns:
**		response string (may be NULL)
*/

static char *
milter_body(m, e, state)
	struct milter *m;
	ENVELOPE *e;
	char *state;
{
	char bufchar = '\0';
	char prevchar = '\0';
	int c;
	char *response = NULL;
	char *bp;
	char buf[MILTER_CHUNK_SIZE];

	if (tTd(64, 10))
		dprintf("milter_body\n");

	if (bfrewind(e->e_dfp) < 0)
	{
		ExitStat = EX_IOERR;
		*state = SMFIR_TEMPFAIL;
		syserr("milter_body: %s/df%s: rewind error",
		       qid_printqueue(e->e_queuedir), e->e_id);
		return NULL;
	}

	bp = buf;
	while ((c = getc(e->e_dfp)) != EOF)
	{
		/*  Change LF to CRLF */
		if (c == '\n')
		{
			/* Not a CRLF already? */
			if (prevchar != '\r')
			{
				/* Room for CR now? */
				if (bp + 2 > &buf[sizeof buf])
				{
					/* No room, buffer LF */
					bufchar = c;

					/* and send CR now */
					c = '\r';
				}
				else
				{
					/* Room to do it now */
					*bp++ = '\r';
					prevchar = '\r';
				}
			}
		}
		*bp++ = (char) c;
		prevchar = c;
		if (bp >= &buf[sizeof buf])
		{
			/* send chunk */
			response = milter_send_command(m, SMFIC_BODY, buf,
						       bp - buf, e, state);
			bp = buf;
			if (bufchar != '\0')
			{
				*bp++ = bufchar;
				bufchar = '\0';
				prevchar = bufchar;
			}
		}
		if (m->mf_state == SMFS_ERROR ||
		    m->mf_state == SMFS_DONE ||
		    *state != SMFIR_CONTINUE)
			break;
	}

	/* check for read errors */
	if (ferror(e->e_dfp))
	{
		ExitStat = EX_IOERR;
		if (*state == SMFIR_CONTINUE ||
		    *state == SMFIR_ACCEPT)
		{
			*state = SMFIR_TEMPFAIL;
			if (response != NULL)
			{
				sm_free(response);
				response = NULL;
			}
		}
		syserr("milter_body: %s/df%s: read error",
		       qid_printqueue(e->e_queuedir), e->e_id);
		return response;
	}

	/* send last body chunk */
	if (bp > buf &&
	    m->mf_state != SMFS_ERROR &&
	    m->mf_state != SMFS_DONE &&
	    *state == SMFIR_CONTINUE)
	{
		/* send chunk */
		response = milter_send_command(m, SMFIC_BODY, buf, bp - buf,
					       e, state);
		bp = buf;
	}
	return response;
}

/*
**  Actions
*/

/*
**  MILTER_ADDHEADER -- Add the supplied header to the message
**
**	Parameters:
**		response -- encoded form of header/value.
**		rlen -- length of response.
a1735 1
	HDR *h;
d1748 1
a1748 1
	if (rlen < 2 || strlen(response) + 1 >= (size_t) rlen)
d1759 1
a1759 1
	if (strlen(response) + strlen(val) + 2 != (size_t) rlen)
a1765 15
	if (*response == '\0')
	{
		if (tTd(64, 10))
			dprintf("empty field name\n");
		return;
	}

	for (h = e->e_header; h != NULL; h = h->h_link)
	{
		if (strcasecmp(h->h_field, response) == 0 &&
		    !bitset(H_USER, h->h_flags) &&
		    !bitset(H_TRACE, h->h_flags))
			break;
	}

a1768 37
	if (h != NULL)
	{
		if (tTd(64, 10))
			dprintf("Replace default header %s value with %s\n",
				h->h_field, val);
		h->h_value = newstr(val);
		h->h_flags |= H_USER;
	}
	else
	{
		if (tTd(64, 10))
			dprintf("Add %s: %s\n", response, val);
		addheader(newstr(response), val, H_USER, &e->e_header);
	}
}
/*
**  MILTER_CHANGEHEADER -- Change the supplied header in the message
**
**	Parameters:
**		response -- encoded form of header/index/value.
**		rlen -- length of response.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_changeheader(response, rlen, e)
	char *response;
	ssize_t rlen;
	ENVELOPE *e;
{
	mi_int32 i, index;
	char *field, *val;
	HDR *h, *sysheader;

d1770 1
a1770 9
		dprintf("milter_changeheader: ");

	/* sanity checks */
	if (response == NULL)
	{
		if (tTd(64, 10))
			dprintf("NULL response\n");
		return;
	}
d1772 1
a1772 115
	if (rlen < 2 || strlen(response) + 1 >= (size_t) rlen)
	{
		if (tTd(64, 10))
			dprintf("didn't follow protocol (total len)\n");
		return;
	}

	/* Find separating NUL */
	(void) memcpy((char *) &i, response, MILTER_LEN_BYTES);
	index = ntohl(i);
	field = response + MILTER_LEN_BYTES;
	val = field + strlen(field) + 1;

	/* another sanity check */
	if (MILTER_LEN_BYTES + strlen(field) + 1 +
	    strlen(val) + 1 != (size_t) rlen)
	{
		if (tTd(64, 10))
			dprintf("didn't follow protocol (part len)\n");
		return;
	}

	if (*field == '\0')
	{
		if (tTd(64, 10))
			dprintf("empty field name\n");
		return;
	}

	sysheader = NULL;
	for (h = e->e_header; h != NULL; h = h->h_link)
	{
		if (strcasecmp(h->h_field, field) == 0)
		{
			if (bitset(H_USER, h->h_flags) &&
			    --index <= 0)
			{
				sysheader = NULL;
				break;
			}
			else if (!bitset(H_USER, h->h_flags) &&
				 !bitset(H_TRACE, h->h_flags))
			{
				/*
				**  DRUMS msg-fmt draft says can only have
				**  multiple occurences of trace fields,
				**  so make sure we replace any non-trace,
				**  non-user field.
				*/

				sysheader = h;
			}
		}
	}

	/* if not found as user-provided header at index, use sysheader */
	if (h == NULL)
		h = sysheader;

	if (h == NULL)
	{
		if (*val == '\0')
		{
			if (tTd(64, 10))
				dprintf("Delete (noop) %s:\n", field);
		}
		else
		{
			/* treat modify value with no existing header as add */
			if (tTd(64, 10))
				dprintf("Add %s: %s\n",	field, val);

			addheader(newstr(field), val, H_USER, &e->e_header);
		}
		return;
	}

	if (tTd(64, 10))
	{
		if (*val == '\0')
		{
			dprintf("Delete%s %s: %s\n",
				h == sysheader ? " (default header)" : "",
				field,
				h->h_value == NULL ? "<NULL>" : h->h_value);
		}
		else
		{
			dprintf("Change%s %s: from %s to %s\n",
				h == sysheader ? " (default header)" : "",
				field,
				h->h_value == NULL ? "<NULL>" : h->h_value,
				val);
		}
	}

	if (h != sysheader && h->h_value != NULL)
	{
		e->e_msgsize -= strlen(h->h_value);
		sm_free(h->h_value);
	}

	if (*val == '\0')
	{
		/* Remove "Field: " from message size */
		if (h != sysheader)
			e->e_msgsize -= strlen(h->h_field) + 2;
		h->h_value = NULL;
	}
	else
	{
		h->h_value = newstr(val);
		h->h_flags |= H_USER;
		e->e_msgsize += strlen(h->h_value);
	}
d1804 1
a1804 1
	    strlen(response) + 1 != (size_t) rlen)
d1807 1
a1807 2
			dprintf("didn't follow protocol (total len %d != rlen %d)\n",
				strlen(response), rlen -1);
d1846 1
a1846 1
	    strlen(response) + 1 != (size_t) rlen)
d1862 6
a1867 3
**		response -- encoded form of new body.
**		rlen -- length of response.
**		newfilter -- if first time called by a new filter
d1875 5
a1879 4
milter_replbody(response, rlen, newfilter, e)
	char *response;
	ssize_t rlen;
	bool newfilter;
d1882 3
a1884 1
	static char prevchar;
d1886 4
d1892 4
a1895 1
		dprintf("milter_replbody\n");
d1897 3
a1899 2
	/* If a new filter, reset previous character and truncate df */
	if (newfilter)
d1901 26
a1926 2
		off_t prevsize = 0;
		char dfname[MAXPATHLEN];
d1928 10
a1937 1
		(void) strlcpy(dfname, queuename(e, 'd'), sizeof dfname);
d1939 6
a1944 2
		/* Reset prevchar */
		prevchar = '\0';
d1946 2
a1947 2
		/* Get the current df information */
		if (bitset(EF_HAS_DF, e->e_flags) && e->e_dfp != NULL)
d1949 38
a1986 2
			int afd;
			struct stat st;
d1988 53
a2040 3
			afd = fileno(e->e_dfp);
			if (afd > 0 && fstat(afd, &st) == 0)
				prevsize = st.st_size;
d2043 5
a2047 2
		/* truncate current df file */
		if (bftruncate(e->e_dfp) < 0)
d2049 8
a2056 2
			MILTER_DF_ERROR("milter_reopen_df: bftruncate %s: %s");
			return -1;
d2058 31
a2088 6
		else
		{
			if (prevsize > e->e_msgsize)
				e->e_msgsize = 0;
			else
				e->e_msgsize -= prevsize;
d2090 21
d2112 1
a2112 2

	if (response == NULL)
d2114 10
a2123 7
		/* Flush the buffered '\r' */
		if (prevchar == '\r')
		{
			(void) putc(prevchar, e->e_dfp);
			e->e_msgsize++;
		}
		return 0;
d2125 1
a2125 2

	for (i = 0; i < rlen; i++)
d2127 13
a2139 11
		/* Buffered char from last chunk */
		if (i == 0 && prevchar == '\r')
		{
			/* Not CRLF, output prevchar */
			if (response[i] != '\n')
			{
				(void) putc(prevchar, e->e_dfp);
				e->e_msgsize++;
			}
			prevchar = '\0';
		}
d2141 3
a2143 20
		/* Turn CRLF into LF */
		if (response[i] == '\r')
		{
			/* check if at end of chunk */
			if (i + 1 < rlen)
			{
				/* If LF, strip CR */
				if (response[i + 1] == '\n')
					i++;
			}
			else
			{
				/* check next chunk */
				prevchar = '\r';
				continue;
			}
		}
		(void) putc(response[i], e->e_dfp);
		e->e_msgsize++;
	}
d2181 1
a2181 1
			MILTER_CHECK_ERROR(continue);
d2195 5
d2201 5
a2205 1
			MILTER_CHECK_ERROR(continue);
d2288 1
a2288 1
		s += sizeof(port) + strlen(sockinfo) + 1;
d2303 1
a2303 3

		/* include trailing '\0' */
		(void) memcpy(bp, sockinfo, strlen(sockinfo) + 1);
d2308 1
a2308 1
	sm_free(buf);
d2335 1
a2335 1
			sm_free(response);
a2358 1
	int i;
a2363 19
	/* HELO/EHLO can come after encryption is negotiated */
	for (i = 0; InputFilters[i] != NULL; i++)
	{
		struct milter *m = InputFilters[i];

		switch (m->mf_state)
		{
		  case SMFS_INMSG:
			/* abort in message filters */
			milter_abort_filter(m, e);
			/* FALLTHROUGH */

		  case SMFS_DONE:
			/* reset done filters */
			m->mf_state = SMFS_OPEN;
			break;
		}
	}

d2441 1
a2441 1
	sm_free(buf);
d2505 78
a2582 1
	sm_free(buf);
d2586 1
a2586 1
**  MILTER_DATA -- send message headers/body and gather final message results
a2600 15
# define MILTER_CHECK_RESULTS() \
	if (*state == SMFIR_ACCEPT || \
	    m->mf_state == SMFS_DONE || \
	    m->mf_state == SMFS_ERROR) \
	{ \
		if (m->mf_state != SMFS_ERROR) \
			m->mf_state = SMFS_DONE; \
		continue;	/* to next filter */ \
	} \
	if (*state != SMFIR_CONTINUE) \
	{ \
		m->mf_state = SMFS_DONE; \
		goto finishup; \
	}

d2602 1
a2602 1
milter_data(e, state)
d2606 2
a2607 5
	bool replbody = FALSE;		/* milter_replbody() called? */
	bool replfailed = FALSE;	/* milter_replbody() failed? */
	bool rewind = FALSE;		/* rewind df file? */
	bool dfopen = FALSE;		/* df open for writing? */
	bool newfilter;			/* reset on each new filter */
d2609 2
d2612 1
d2614 1
d2618 1
d2621 1
a2621 1
		dprintf("milter_data\n");
d2625 5
a2629 7
	/*
	**  XXX: Should actually send body chunks to each filter
	**  a chunk at a time instead of sending the whole body to
	**  each filter in turn.  However, only if the filters don't
	**  change the body.
	*/

a2646 8
		newfilter = TRUE;

		/* previous problem? */
		if (m->mf_state == SMFS_ERROR)
		{
			MILTER_CHECK_ERROR(continue);
			break;
		}
d2654 1
d2656 2
a2657 2
		/* check if filter wants the headers */
		if (!bitset(SMFIP_NOHDRS, m->mf_pflags))
d2659 2
a2660 2
			response = milter_headers(m, e, state);
			MILTER_CHECK_RESULTS();
d2663 1
a2663 2
		/* check if filter wants EOH */
		if (!bitset(SMFIP_NOEOH, m->mf_pflags))
d2665 3
a2667 2
			if (tTd(64, 10))
				dprintf("milter_data: eoh\n");
d2669 7
a2675 4
			/* send it over */
			response = milter_send_command(m, SMFIC_EOH, NULL, 0,
						       e, state);
			MILTER_CHECK_RESULTS();
d2678 2
a2679 3
		/* check if filter wants the body */
		if (!bitset(SMFIP_NOBODY, m->mf_pflags) &&
		    e->e_dfp != NULL)
d2681 85
a2765 3
			rewind = TRUE;
			response = milter_body(m, e, state);
			MILTER_CHECK_RESULTS();
d2768 21
a2788 3
		/* send the final body chunk */
		(void) milter_write(m, SMFIC_BODYEOB, NULL, 0,
				    m->mf_timeout[SMFTO_WRITE], e);
d2796 4
d2805 1
a2805 1
					dprintf("milter_data(%s): EOM ACK/NAK timeout\n",
d2809 1
a2809 1
						  "milter_data(%s): EOM ACK/NAK timeout\n",
d2812 1
a2812 1
				MILTER_CHECK_ERROR(continue);
d2821 1
d2823 4
a2826 2
				dprintf("milter_data(%s): state %c\n",
					m->mf_name, (char) rcmd);
d2857 1
a2857 1
				if (!bitset(SMFIF_ADDHDRS, m->mf_fflags))
d2861 1
a2861 1
							  "milter_data(%s): lied about adding headers, honoring request anyway",
a2866 11
			  case SMFIR_CHGHEADER:
				if (!bitset(SMFIF_CHGHDRS, m->mf_fflags))
				{
					if (LogLevel > 9)
						sm_syslog(LOG_WARNING, e->e_id,
							  "milter_data(%s): lied about changing headers, honoring request anyway",
							  m->mf_name);
				}
				milter_changeheader(response, rlen, e);
				break;

d2872 1
a2872 1
							  "milter_data(%s) lied about adding recipients, honoring request anyway",
d2883 1
a2883 1
							  "milter_data(%s): lied about removing recipients, honoring request anyway",
d2894 1
a2894 1
							  "milter_data(%s): lied about replacing body, rejecting request and tempfailing message",
d2897 1
a2897 1
					break;
d2899 1
d2901 2
a2902 5
				/* already failed in attempt */
				if (replfailed)
					break;

				if (!dfopen)
d2904 2
a2905 7
					if (milter_reopen_df(e) < 0)
					{
						replfailed = TRUE;
						break;
					}
					dfopen = TRUE;
					rewind = TRUE;
d2908 7
a2914 2
				if (milter_replbody(response, rlen,
						    newfilter, e) < 0)
d2916 3
a2918 3
				newfilter = FALSE;
				replbody = TRUE;
				break;
d2924 1
a2924 1
						  "milter_data(%s): returned bogus response %c",
d2932 1
a2932 1
				sm_free(response);
a2934 3

			if (m->mf_state == SMFS_ERROR)
				break;
a2935 8

		if (replbody && !replfailed)
		{
			/* flush possible buffered character */
			milter_replbody(NULL, 0, !replbody, e);
			replbody = FALSE;
		}

d2938 1
a2938 1
			MILTER_CHECK_ERROR(continue);
d2945 1
a2945 25
	if (replfailed)
	{
		if (*state == SMFIR_CONTINUE ||
		    *state == SMFIR_ACCEPT)
		{
			*state = SMFIR_TEMPFAIL;
			if (response != NULL)
			{
				sm_free(response);
				response = NULL;
			}
		}

		if (dfopen)
		{
			(void) fclose(e->e_dfp);
			e->e_dfp = NULL;
			e->e_flags &= ~EF_HAS_DF;
			dfopen = FALSE;
		}
		rewind = FALSE;
	}

	if ((dfopen && milter_reset_df(e) < 0) ||
	    (rewind && bfrewind(e->e_dfp) < 0))
d2947 1
a2957 1
		{
a2958 6
			if (response != NULL)
			{
				sm_free(response);
				response = NULL;
			}
		}
d2961 1
a2961 1
		syserr("milter_data: %s/df%s: read error",
a2963 1
	MILTER_CHECK_DONE_MSG();
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: milter.c,v 8.45 2000/02/26 07:20:48 gshapiro Exp $";
d139 1
a139 1
				routine,  m->mf_name, strerror(save_errno)); \
d143 1
a143 1
				  routine, m->mf_name, strerror(save_errno)); \
d210 1
a210 1
				m->mf_name, (long) len, strerror(save_errno));
d215 1
a215 1
				  strerror(save_errno));
d292 1
a292 1
				m->mf_name, (long) len, strerror(save_errno));
d297 1
a297 1
				  strerror(save_errno));
d388 1
a388 1
				strerror(save_errno));
d393 1
a393 1
				  strerror(save_errno));
d437 1
a437 1
				strerror(save_errno));
d442 1
a442 1
				  strerror(save_errno));
d872 1
a872 1
					m->mf_name, strerror(save_errno));
d876 1
a876 1
					  m->mf_name, strerror(save_errno));
d1275 1
a1275 1
	(void) milter_write(m, SMFIC_QUIT, NULL, 0,
d1305 1
a1305 1
	(void) milter_write(m, SMFIC_ABORT, NULL, 0,
d1640 1
a1640 1
			dprintf("milter_negotiate(%s): version %ld != MTA milter version %d\n",
d1653 1
a1653 1
		dprintf("milter_negotiate(%s): version %d, flags %x\n",
d1908 1
a1908 1
					strerror(save_errno));
d1913 1
a1913 1
					  strerror(save_errno));
d1953 1
a1953 1
					strerror(save_errno));
d1958 1
a1958 1
					  strerror(save_errno));
d1980 1
a1980 1
				m->mf_name, dfname, strerror(save_errno));
d1984 1
a1984 1
				  m->mf_name, dfname, strerror(save_errno));
d2079 1
a2079 1
				m->mf_name, dfname, strerror(save_errno));
d2083 1
a2083 1
				  m->mf_name, dfname, strerror(save_errno));
d2102 1
a2102 1
				m->mf_name, dfname, strerror(save_errno));
d2106 1
a2106 1
				  m->mf_name, dfname, strerror(save_errno));
d2117 1
a2117 1
				m->mf_name, dfname, strerror(save_errno));
d2121 1
a2121 1
				  m->mf_name, dfname, strerror(save_errno));
d2130 1
a2130 1
				m->mf_name, dfname, strerror(save_errno));
d2134 1
a2134 1
				  m->mf_name, dfname, strerror(save_errno));
d2540 1
a2540 1
	response = milter_command(SMFIC_HEADER, buf, s, NULL, e, state);
d2573 2
a2574 1
	response = milter_command(SMFIC_EOH, NULL, 0, NULL, e, state);
d2710 1
a2710 1
						    buf - bp,
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Id: milter.c,v 8.50.4.41 2000/12/27 21:35:32 gshapiro Exp $";
d25 4
a28 3
#  define SM_FD_SET	FD_SET
#  define SM_FD_ISSET	FD_ISSET
#  define SM_FD_SETSIZE	FD_SETSIZE
a30 2
static int	milter_open __P((struct milter *, bool, ENVELOPE *));
static void	milter_parse_timeouts __P((char *, struct milter *));
d37 1
a37 1
# define MILTER_CHECK_DONE_MSG() \
d47 1
a47 1
# define MILTER_CHECK_ERROR(action) \
d53 1
a53 1
		action;
d55 1
a55 1
# define MILTER_CHECK_REPLYCODE(default) \
d57 1
a57 1
	    strlen(response) + 1 != (size_t) rlen || \
a83 23
# define MILTER_DF_ERROR(msg) \
{ \
	int save_errno = errno; \
 \
	if (tTd(64, 5)) \
	{ \
		dprintf(msg, dfname, errstring(save_errno)); \
		dprintf("\n"); \
	} \
	if (LogLevel > 0) \
		sm_syslog(LOG_ERR, e->e_id, msg, dfname, errstring(save_errno)); \
	if (SuperSafe) \
	{ \
		if (e->e_dfp != NULL) \
		{ \
			(void) fclose(e->e_dfp); \
			e->e_dfp = NULL; \
		} \
		e->e_flags &= ~EF_HAS_DF; \
	} \
	errno = save_errno; \
}

d95 1
a95 1
# define MILTER_TIMEOUT(routine, secs, write) \
d102 1
a102 1
	if (SM_FD_SETSIZE != 0 && m->mf_sock >= SM_FD_SETSIZE) \
d106 1
a106 1
				routine, m->mf_name, m->mf_sock, SM_FD_SETSIZE); \
d110 1
a110 1
				  routine, m->mf_name, m->mf_sock, SM_FD_SETSIZE); \
d116 1
a116 1
	SM_FD_SET(m->mf_sock, &fds); \
d139 1
a139 1
				routine,  m->mf_name, errstring(save_errno)); \
d143 1
a143 1
				  routine, m->mf_name, errstring(save_errno)); \
d148 1
a148 1
		if (SM_FD_ISSET(m->mf_sock, &fds)) \
d181 1
a181 1
milter_sysread(m, buf, sz, to, e)
d183 2
a184 2
	char *buf;
	ssize_t sz;
d188 5
a192 2
	time_t readstart = 0;
	ssize_t len, curl;
d194 2
a195 1
	curl = 0;
d198 1
d200 2
d203 2
a204 1
	for (;;)
d206 1
a206 44
		if (to > 0)
		{
			time_t now;

			now = curtime();
			if (now - readstart >= to)
			{
				if (tTd(64, 5))
					dprintf("milter_read(%s): timeout before data read\n",
						m->mf_name);
				if (LogLevel > 0)
					sm_syslog(LOG_ERR, e->e_id,
						  "milter_read(%s): timeout before data read\n",
						  m->mf_name);
				milter_error(m);
				return NULL;
			}
			to -= now - readstart;
			readstart = now;
			MILTER_TIMEOUT("milter_read", to, FALSE);
		}

		len = read(m->mf_sock, buf + curl, sz - curl);

		if (len < 0)
		{
			int save_errno = errno;

			if (tTd(64, 5))
				dprintf("milter_read(%s): read returned %ld: %s\n",
					m->mf_name, (long) len,
					errstring(save_errno));
			if (LogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "milter_read(%s): read returned %ld: %s",
					  m->mf_name, (long) len,
					  errstring(save_errno));
			milter_error(m);
			return NULL;
		}

		curl += len;
		if (len == 0 || len >= sz)
			break;
d208 10
d220 1
a220 1
	if (curl != sz)
d223 2
a224 2
			dprintf("milter_read(%s): read returned %ld, expecting %ld\n",
				m->mf_name, (long) curl, (long) sz);
d227 3
a229 2
				  "milter_read(%s): read returned %ld, expecting %ld",
				  m->mf_name, (long) curl, (long) sz);
a232 2
	return buf;
}
d234 4
a237 13
static char *
milter_read(m, cmd, rlen, to, e)
	struct milter *m;
	char *cmd;
	ssize_t *rlen;
	time_t to;
	ENVELOPE *e;
{
	time_t readstart = 0;
	ssize_t expl;
	mi_int32 i;
	char *buf;
	char data[MILTER_LEN_BYTES + 1];
d239 3
a241 2
	*rlen = 0;
	*cmd = '\0';
d243 12
a254 2
	if (to > 0)
		readstart = curtime();
d256 1
a256 1
	if (milter_sysread(m, data, sizeof data, to, e) == NULL)
d259 2
a260 1
	/* reset timeout */
d278 5
a282 1
		to -= now - readstart;
d285 4
a288 8
	*cmd = data[MILTER_LEN_BYTES];
	data[MILTER_LEN_BYTES] = '\0';
	(void) memcpy(&i, data, MILTER_LEN_BYTES);
	expl = ntohl(i) - 1;

	if (tTd(64, 25))
		dprintf("milter_read(%s): expecting %ld bytes\n",
			m->mf_name, (long) expl);
a289 2
	if (expl < 0)
	{
d291 2
a292 2
			dprintf("milter_read(%s): read size %ld out of range\n",
				m->mf_name, (long) expl);
d295 4
a298 2
				  "milter_read(%s): read size %ld out of range",
				  m->mf_name, (long) expl);
d302 1
a302 7

	if (expl == 0)
		return NULL;

	buf = (char *)xalloc(expl);

	if (milter_sysread(m, buf, expl, to, e) == NULL)
d304 7
d312 1
a314 1

d317 1
a317 2
			m->mf_name, (int) expl, buf);
	*rlen = expl;
d388 1
a388 1
				errstring(save_errno));
d393 1
a393 1
				  errstring(save_errno));
d437 1
a437 1
				errstring(save_errno));
d442 1
a442 1
				  errstring(save_errno));
d467 1
a467 1
static int
d575 1
a575 1
		long sff = SFF_SAFEDIRPATH|SFF_OPENASROOT|SFF_NOLINK|SFF_EXECOK;
d597 2
a598 10
		/* if just parsing .cf file, socket doesn't need to exist */
		if (parseonly && errno == ENOENT)
		{
			if (OpMode == MD_DAEMON ||
			    OpMode == MD_FGDAEMON)
				fprintf(stderr,
					"WARNING: X%s: local socket name %s missing\n",
					m->mf_name, colon);
		}
		else if (errno != 0)
a599 1
			/* if not safe, don't create */
a624 1
	else
d627 1
a627 1
	if (FALSE
d657 1
a657 1
			port = htons((u_short) atoi(colon));
a825 3
#  if _FFR_FREEHOSTENT && NETINET6
				freehostent(hp);
#  endif /* _FFR_FREEHOSTENT && NETINET6 */
d830 1
a831 1
# endif /* NETINET || NETINET6 */
a847 4
# if _FFR_FREEHOSTENT && NETINET6
		if (hp != NULL)
			freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a859 4
# if _FFR_FREEHOSTENT && NETINET6
		if (hp != NULL)
			freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d872 1
a872 1
					m->mf_name, errstring(save_errno));
d876 1
a876 1
					  m->mf_name, errstring(save_errno));
a877 4
# if _FFR_FREEHOSTENT && NETINET6
			if (hp != NULL)
				freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a885 2
		p = CurHostName;
		CurHostName = at;
a892 1
		CurHostName = p;
a926 3
# if _FFR_FREEHOSTENT && NETINET6
				freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a938 4
# if _FFR_FREEHOSTENT && NETINET6
		if (hp != NULL)
			freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a941 7
# if _FFR_FREEHOSTENT && NETINET6
	if (hp != NULL)
	{
		freehostent(hp);
		hp = NULL;
	}
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a944 104
**  MILTER_SETUP -- setup structure for a mail filter
**
**	Parameters:
**		line -- the options line.
**
**	Returns:
**		none
*/

void
milter_setup(line)
	char *line;
{
	char fcode;
	register char *p;
	register struct milter *m;
	STAB *s;

	/* collect the filter name */
	for (p = line;
	     *p != '\0' && *p != ',' && !(isascii(*p) && isspace(*p));
	     p++)
		continue;
	if (*p != '\0')
		*p++ = '\0';
	if (line[0] == '\0')
	{
		syserr("name required for mail filter");
		return;
	}
	m = (struct milter *)xalloc(sizeof *m);
	memset((char *) m, '\0', sizeof *m);
	m->mf_name = newstr(line);
	m->mf_state = SMFS_READY;
	m->mf_sock = -1;
	m->mf_timeout[SMFTO_WRITE] = (time_t) 10;
	m->mf_timeout[SMFTO_READ] = (time_t) 10;
	m->mf_timeout[SMFTO_EOM] = (time_t) 300;

	/* now scan through and assign info from the fields */
	while (*p != '\0')
	{
		char *delimptr;

		while (*p != '\0' &&
		       (*p == ',' || (isascii(*p) && isspace(*p))))
			p++;

		/* p now points to field code */
		fcode = *p;
		while (*p != '\0' && *p != '=' && *p != ',')
			p++;
		if (*p++ != '=')
		{
			syserr("X%s: `=' expected", m->mf_name);
			return;
		}
		while (isascii(*p) && isspace(*p))
			p++;

		/* p now points to the field body */
		p = munchstring(p, &delimptr, ',');

		/* install the field into the filter struct */
		switch (fcode)
		{
		  case 'S':		/* socket */
			if (p == NULL)
				m->mf_conn = NULL;
			else
				m->mf_conn = newstr(p);
			break;

		  case 'F':		/* Milter flags configured on MTA */
			for (; *p != '\0'; p++)
			{
				if (!(isascii(*p) && isspace(*p)))
					setbitn(bitidx(*p), m->mf_flags);
			}
			break;

		  case 'T':		/* timeouts */
			milter_parse_timeouts(p, m);
			break;

		  default:
			syserr("X%s: unknown filter equate %c=",
			       m->mf_name, fcode);
			break;
		}
		p = delimptr;
	}

	/* early check for errors */
	(void) milter_open(m, TRUE, CurEnv);

	/* enter the filter into the symbol table */
	s = stab(m->mf_name, ST_MILTER, ST_ENTER);
	if (s->s_milter != NULL)
		syserr("X%s: duplicate filter definition", m->mf_name);
	else
		s->s_milter = m;
}
/*
d1015 1
a1015 1
static void
d1049 1
a1049 1
		/* install the field into the filter struct */
d1109 1
a1109 1
# define MO_MACROS_CONNECT		0x01
d1111 1
a1111 1
# define MO_MACROS_HELO			0x02
d1113 1
a1113 1
# define MO_MACROS_ENVFROM		0x03
d1115 1
a1115 1
# define MO_MACROS_ENVRCPT		0x04
d1220 1
a1220 1
**  MILTER_REOPEN_DF -- open & truncate the df file (for replbody)
d1223 1
a1223 1
**		e -- current envelope.
d1226 1
a1226 1
**		0 if succesful, -1 otherwise
d1229 2
a1230 3
static int
milter_reopen_df(e)
	ENVELOPE *e;
d1232 1
a1232 1
	char dfname[MAXPATHLEN];
d1234 1
a1234 14
	(void) strlcpy(dfname, queuename(e, 'd'), sizeof dfname);

	/*
	**  In SuperSafe mode, e->e_dfp is a read-only FP so
	**  close and reopen writable (later close and reopen
	**  read only again).
	**
	**  In !SuperSafe mode, e->e_dfp still points at the
	**  buffered file I/O descriptor, still open for writing
	**  so there isn't as much work to do, just truncate it
	**  and go.
	*/

	if (SuperSafe)
d1236 1
a1236 6
		/* close read-only df */
		if (bitset(EF_HAS_DF, e->e_flags) && e->e_dfp != NULL)
		{
			(void) fclose(e->e_dfp);
			e->e_flags &= ~EF_HAS_DF;
		}
d1238 2
a1239 13
		/* open writable */
		if ((e->e_dfp = fopen(dfname, "w+")) == NULL)
		{
			MILTER_DF_ERROR("milter_reopen_df: fopen %s: %s");
			return -1;
		}
	}
	else if (e->e_dfp == NULL)
	{
		/* shouldn't happen */
		errno = ENOENT;
		MILTER_DF_ERROR("milter_reopen_df: NULL e_dfp (%s: %s)");
		return -1;
d1241 1
a1241 1
	return 0;
d1244 1
a1244 1
**  MILTER_RESET_DF -- re-open read-only the df file (for replbody)
d1247 1
d1251 1
a1251 1
**		0 if succesful, -1 otherwise
d1254 3
a1256 2
static int
milter_reset_df(e)
d1259 2
a1260 2
	int afd;
	char dfname[MAXPATHLEN];
d1262 3
a1264 87
	(void) strlcpy(dfname, queuename(e, 'd'), sizeof dfname);

	if (fflush(e->e_dfp) != 0 || ferror(e->e_dfp))
	{
		MILTER_DF_ERROR("milter_reset_df: error writing/flushing %s: %s");
		return -1;
	}
	else if (!SuperSafe)
	{
		/* skip next few clauses */
		/* EMPTY */
	}
	else if ((afd = fileno(e->e_dfp)) >= 0 && fsync(afd) < 0)
	{
		MILTER_DF_ERROR("milter_reset_df: error sync'ing %s: %s");
		return -1;
	}
	else if (fclose(e->e_dfp) < 0)
	{
		MILTER_DF_ERROR("milter_reset_df: error closing %s: %s");
		return -1;
	}
	else if ((e->e_dfp = fopen(dfname, "r")) == NULL)
	{
		MILTER_DF_ERROR("milter_reset_df: error reopening %s: %s");
		return -1;
	}
	else
		e->e_flags |= EF_HAS_DF;
	return 0;
}
/*
**  MILTER_CAN_DELRCPTS -- can any milter filters delete recipients?
**
**	Parameters:
**		none
**
**	Returns:
**		TRUE if any filter deletes recipients, FALSE otherwise
*/

bool
milter_can_delrcpts()
{
	bool can = FALSE;
	int i;

	if (tTd(64, 10))
		dprintf("milter_can_delrcpts:");

	for (i = 0; InputFilters[i] != NULL; i++)
	{
		struct milter *m = InputFilters[i];

		if (bitset(SMFIF_DELRCPT, m->mf_fflags))
		{
			can = TRUE;
			break;
		}
	}
	if (tTd(64, 10))
		dprintf("%s\n", can ? "TRUE" : "FALSE");

	return can;
}
/*
**  MILTER_QUIT_FILTER -- close down a single filter
**
**	Parameters:
**		m -- milter structure of filter to close down.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_quit_filter(m, e)
	struct milter *m;
	ENVELOPE *e;
{
	if (tTd(64, 10))
		dprintf("milter_quit_filter(%s)\n", m->mf_name);

	/* Never replace error state */
	if (m->mf_state == SMFS_ERROR)
		return;
d1275 1
a1275 1
	(void) milter_write(m, SMFIC_QUIT, (char *) NULL, 0,
d1277 2
a1278 5
	if (m->mf_sock >= 0)
	{
		(void) close(m->mf_sock);
		m->mf_sock = -1;
	}
d1305 1
a1305 1
	(void) milter_write(m, SMFIC_ABORT, (char *) NULL, 0,
d1345 1
a1345 1
		if (mid == 0)
d1359 1
a1359 1
		if (mid == 0)
a1377 1

d1379 1
a1379 1
**  MILTER_SEND_COMMAND -- send a command and return the response for a filter
a1381 1
**		m -- current milter filter
d1385 2
a1386 1
**		e -- current envelope (for e->e_id).
d1394 1
a1394 2
milter_send_command(m, command, data, sz, e, state)
	struct milter *m;
d1398 1
d1402 1
a1403 1
	ssize_t rlen;
d1405 1
d1407 1
a1407 1
	char *response;
d1410 2
a1411 2
		dprintf("milter_send_command(%s): cmd %c len %ld\n",
			m->mf_name, (char) command, (long) sz);
d1417 1
a1417 1
		skipflag = SMFIP_NOCONNECT;
d1422 1
a1422 1
		skipflag = SMFIP_NOHELO;
d1427 1
a1427 1
		skipflag = SMFIP_NOMAIL;
d1432 1
a1432 1
		skipflag = SMFIP_NORCPT;
d1437 2
a1438 1
		skipflag = SMFIP_NOHDRS;
a1442 9
		skipflag = SMFIP_NOBODY;
		defresponse = "554 5.7.1 Command rejected";
		break;

	  case SMFIC_EOH:
		skipflag = SMFIP_NOEOH;
		defresponse = "550 5.7.1 Command rejected";
		break;

d1448 1
a1448 1
		/* NOTE: not handled by milter_send_command() */
a1456 99
	/* check if filter wants this command */
	if (skipflag != 0 &&
	    bitset(skipflag, m->mf_pflags))
		return NULL;


	(void) milter_write(m, command, data, sz,
			    m->mf_timeout[SMFTO_WRITE], e);
	if (m->mf_state == SMFS_ERROR)
	{
		MILTER_CHECK_ERROR(/* EMPTY */;);
		return NULL;
	}

	response = milter_read(m, &rcmd, &rlen,
			       m->mf_timeout[SMFTO_READ], e);
	if (m->mf_state == SMFS_ERROR)
	{
		MILTER_CHECK_ERROR(/* EMPTY */;);
		return NULL;
	}

	if (tTd(64, 10))
		dprintf("milter_send_command(%s): returned %c\n",
			m->mf_name, (char) rcmd);

	switch (rcmd)
	{
	  case SMFIR_REPLYCODE:
		MILTER_CHECK_REPLYCODE(defresponse);
		/* FALLTHROUGH */

	  case SMFIR_REJECT:
	  case SMFIR_DISCARD:
	  case SMFIR_TEMPFAIL:
		*state = rcmd;
		break;

	  case SMFIR_ACCEPT:
		/* this filter is done with message/connection */
		m->mf_state = SMFS_DONE;
		break;

	  case SMFIR_CONTINUE:
		/* if MAIL command is ok, filter is in message state */
		if (command == SMFIC_MAIL)
			m->mf_state = SMFS_INMSG;
		break;

	  default:
		/* Invalid response to command */
		if (LogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_send_command(%s): returned bogus response %c",
				  m->mf_name, rcmd);
		milter_error(m);
		break;
	}

	if (*state != SMFIR_REPLYCODE &&
	    response != NULL)
	{
		free(response);
		response = NULL;
	}
	return response;
}

/*
**  MILTER_COMMAND -- send a command and return the response for each filter
**
**	Parameters:
**		command -- command to send.
**		data -- optional command data.
**		sz -- length of buf.
**		macros -- macros to send for filter smfi_getsymval().
**		e -- current envelope (for macro access).
**		state -- return state word.
**
**	Returns:
**		response string (may be NULL)
*/

static char *
milter_command(command, data, sz, macros, e, state)
	char command;
	void *data;
	ssize_t sz;
	char **macros;
	ENVELOPE *e;
	char *state;
{
	int i;
	char *response = NULL;

	if (tTd(64, 10))
		dprintf("milter_command: cmd %c len %ld\n",
			(char) command, (long) sz);

a1461 7
		/* previous problem? */
		if (m->mf_state == SMFS_ERROR)
		{
			MILTER_CHECK_ERROR(continue);
			break;
		}

d1473 1
a1473 1
				MILTER_CHECK_ERROR(continue);
d1478 67
a1544 1
		response = milter_send_command(m, command, data, sz, e, state);
d1568 2
a1569 3
	mi_int32 fflags;
	mi_int32 pflags;
	char *response;
d1571 1
a1571 1
	char data[MILTER_OPTLEN];
d1585 1
a1585 2
	fflags = htonl(SMFI_CURR_ACTS);
	pflags = htonl(SMFI_CURR_PROT);
d1588 1
a1588 3
		      (char *) &fflags, MILTER_LEN_BYTES);
	(void) memcpy(data + (MILTER_LEN_BYTES * 2),
		      (char *) &pflags, MILTER_LEN_BYTES);
d1614 1
a1614 2
	/* Make sure we have enough bytes for the version */
	if (response == NULL || rlen < MILTER_LEN_BYTES)
d1631 1
a1631 20

	/* Now make sure we have enough for the feature bitmap */
	if (rlen != MILTER_OPTLEN)
	{
		if (tTd(64, 5))
			dprintf("milter_negotiate(%s): did not return enough info\n",
				m->mf_name);
		if (LogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_negotiate(%s): did not return enough info",
				  m->mf_name);
		if (response != NULL)
			free(response);
		milter_error(m);
		return -1;
	}

	(void) memcpy((char *) &fflags, response + MILTER_LEN_BYTES,
		      MILTER_LEN_BYTES);
	(void) memcpy((char *) &pflags, response + (MILTER_LEN_BYTES * 2),
d1636 2
a1637 7
	m->mf_fvers = ntohl(fvers);
	m->mf_fflags = ntohl(fflags);
	m->mf_pflags = ntohl(pflags);

	/* check for version compatibility */
	if (m->mf_fvers == 1 ||
	    m->mf_fvers > SMFI_VERSION)
d1640 3
a1642 2
			dprintf("milter_negotiate(%s): version %lu != MTA milter version %d\n",
				m->mf_name, m->mf_fvers, SMFI_VERSION);
d1646 2
a1647 33
				  m->mf_name, m->mf_fvers, SMFI_VERSION);
		milter_error(m);
		return -1;
	}

	/* check for filter feature mismatch */
	if ((m->mf_fflags & SMFI_CURR_ACTS) != m->mf_fflags)
	{
		if (tTd(64, 5))
			dprintf("milter_negotiate(%s): filter abilities 0x%lx != MTA milter abilities 0x%lx\n",
				m->mf_name, m->mf_fflags,
				(u_long) SMFI_CURR_ACTS);
		if (LogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_negotiate(%s): filter abilities 0x%lx != MTA milter abilities 0x%lx\n",
				  m->mf_name, m->mf_fflags,
				  (u_long) SMFI_CURR_ACTS);
		milter_error(m);
		return -1;
	}

	/* check for protocol feature mismatch */
	if ((m->mf_pflags & SMFI_CURR_PROT) != m->mf_pflags)
	{
		if (tTd(64, 5))
			dprintf("milter_negotiate(%s): protocol abilities 0x%lx != MTA milter abilities 0x%lx\n",
				m->mf_name, m->mf_pflags,
				(u_long) SMFI_CURR_PROT);
		if (LogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_negotiate(%s): protocol abilities 0x%lx != MTA milter abilities 0x%lx\n",
				  m->mf_name, m->mf_pflags,
				  (u_long) SMFI_CURR_PROT);
d1651 1
a1651 1

d1653 2
a1654 2
		dprintf("milter_negotiate(%s): version %lu, fflags 0x%lx, pflags 0x%lx\n",
			m->mf_name, m->mf_fvers, m->mf_fflags, m->mf_pflags);
d1712 5
d1718 1
a1718 1
**  MILTER_HEADERS -- send headers to a single milter filter
d1721 2
a1722 181
**		m -- current filter.
**		e -- current envelope.
**		state -- return state from response.
**
**	Returns:
**		response string (may be NULL)
*/

static char *
milter_headers(m, e, state)
	struct milter *m;
	ENVELOPE *e;
	char *state;
{
	char *response = NULL;
	HDR *h;

	for (h = e->e_header; h != NULL; h = h->h_link)
	{
		char *buf;
		ssize_t s;

		/* don't send over deleted headers */
		if (h->h_value == NULL)
		{
			/* strip H_USER so not counted in milter_chgheader() */
			h->h_flags &= ~H_USER;
			continue;
		}

		/* skip auto-generated */
		if (!bitset(H_USER, h->h_flags))
			continue;

		if (tTd(64, 10))
			dprintf("milter_headers: %s: %s\n",
				h->h_field, h->h_value);

		s = strlen(h->h_field) + 1 +
			strlen(h->h_value) + 1;
		buf = (char *) xalloc(s);
		snprintf(buf, s, "%s%c%s", h->h_field, '\0', h->h_value);

		/* send it over */
		response = milter_send_command(m, SMFIC_HEADER, buf,
					       s, e, state);
		free(buf);
		if (m->mf_state == SMFS_ERROR ||
		    m->mf_state == SMFS_DONE ||
		    *state != SMFIR_CONTINUE)
			break;
	}
	return response;
}
/*
**  MILTER_BODY -- send the body to a filter
**
**	Parameters:
**		m -- current filter.
**		e -- current envelope.
**		state -- return state from response.
**
**	Returns:
**		response string (may be NULL)
*/

static char *
milter_body(m, e, state)
	struct milter *m;
	ENVELOPE *e;
	char *state;
{
	char bufchar = '\0';
	char prevchar = '\0';
	int c;
	char *response = NULL;
	char *bp;
	char buf[MILTER_CHUNK_SIZE];

	if (tTd(64, 10))
		dprintf("milter_body\n");

	if (bfrewind(e->e_dfp) < 0)
	{
		ExitStat = EX_IOERR;
		*state = SMFIR_TEMPFAIL;
		syserr("milter_body: %s/df%s: rewind error",
		       qid_printqueue(e->e_queuedir), e->e_id);
		return NULL;
	}

	bp = buf;
	while ((c = getc(e->e_dfp)) != EOF)
	{
		/*  Change LF to CRLF */
		if (c == '\n')
		{
			/* Not a CRLF already? */
			if (prevchar != '\r')
			{
				/* Room for CR now? */
				if (bp + 2 > &buf[sizeof buf])
				{
					/* No room, buffer LF */
					bufchar = c;

					/* and send CR now */
					c = '\r';
				}
				else
				{
					/* Room to do it now */
					*bp++ = '\r';
					prevchar = '\r';
				}
			}
		}
		*bp++ = (char) c;
		prevchar = c;
		if (bp >= &buf[sizeof buf])
		{
			/* send chunk */
			response = milter_send_command(m, SMFIC_BODY, buf,
						       bp - buf, e, state);
			bp = buf;
			if (bufchar != '\0')
			{
				*bp++ = bufchar;
				bufchar = '\0';
				prevchar = bufchar;
			}
		}
		if (m->mf_state == SMFS_ERROR ||
		    m->mf_state == SMFS_DONE ||
		    *state != SMFIR_CONTINUE)
			break;
	}

	/* check for read errors */
	if (ferror(e->e_dfp))
	{
		ExitStat = EX_IOERR;
		if (*state == SMFIR_CONTINUE ||
		    *state == SMFIR_ACCEPT)
		{
			*state = SMFIR_TEMPFAIL;
			if (response != NULL)
			{
				free(response);
				response = NULL;
			}
		}
		syserr("milter_body: %s/df%s: read error",
		       qid_printqueue(e->e_queuedir), e->e_id);
		return response;
	}

	/* send last body chunk */
	if (bp > buf &&
	    m->mf_state != SMFS_ERROR &&
	    m->mf_state != SMFS_DONE &&
	    *state == SMFIR_CONTINUE)
	{
		/* send chunk */
		response = milter_send_command(m, SMFIC_BODY, buf, bp - buf,
					       e, state);
		bp = buf;
	}
	return response;
}

/*
**  Actions
*/

/*
**  MILTER_ADDHEADER -- Add the supplied header to the message
**
**	Parameters:
**		response -- encoded form of header/value.
**		rlen -- length of response.
a1735 1
	HDR *h;
d1748 1
a1748 1
	if (rlen < 2 || strlen(response) + 1 >= (size_t) rlen)
d1759 1
a1759 1
	if (strlen(response) + strlen(val) + 2 != (size_t) rlen)
a1765 15
	if (*response == '\0')
	{
		if (tTd(64, 10))
			dprintf("empty field name\n");
		return;
	}

	for (h = e->e_header; h != NULL; h = h->h_link)
	{
		if (strcasecmp(h->h_field, response) == 0 &&
		    !bitset(H_USER, h->h_flags) &&
		    !bitset(H_TRACE, h->h_flags))
			break;
	}

a1768 37
	if (h != NULL)
	{
		if (tTd(64, 10))
			dprintf("Replace default header %s value with %s\n",
				h->h_field, val);
		h->h_value = newstr(val);
		h->h_flags |= H_USER;
	}
	else
	{
		if (tTd(64, 10))
			dprintf("Add %s: %s\n", response, val);
		addheader(newstr(response), val, H_USER, &e->e_header);
	}
}
/*
**  MILTER_CHANGEHEADER -- Change the supplied header in the message
**
**	Parameters:
**		response -- encoded form of header/index/value.
**		rlen -- length of response.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_changeheader(response, rlen, e)
	char *response;
	ssize_t rlen;
	ENVELOPE *e;
{
	mi_int32 i, index;
	char *field, *val;
	HDR *h, *sysheader;

d1770 1
a1770 1
		dprintf("milter_changeheader: ");
d1772 1
a1772 123
	/* sanity checks */
	if (response == NULL)
	{
		if (tTd(64, 10))
			dprintf("NULL response\n");
		return;
	}

	if (rlen < 2 || strlen(response) + 1 >= (size_t) rlen)
	{
		if (tTd(64, 10))
			dprintf("didn't follow protocol (total len)\n");
		return;
	}

	/* Find separating NUL */
	(void) memcpy((char *) &i, response, MILTER_LEN_BYTES);
	index = ntohl(i);
	field = response + MILTER_LEN_BYTES;
	val = field + strlen(field) + 1;

	/* another sanity check */
	if (MILTER_LEN_BYTES + strlen(field) + 1 +
	    strlen(val) + 1 != (size_t) rlen)
	{
		if (tTd(64, 10))
			dprintf("didn't follow protocol (part len)\n");
		return;
	}

	if (*field == '\0')
	{
		if (tTd(64, 10))
			dprintf("empty field name\n");
		return;
	}

	sysheader = NULL;
	for (h = e->e_header; h != NULL; h = h->h_link)
	{
		if (strcasecmp(h->h_field, field) == 0)
		{
			if (bitset(H_USER, h->h_flags) &&
			    --index <= 0)
			{
				sysheader = NULL;
				break;
			}
			else if (!bitset(H_USER, h->h_flags) &&
				 !bitset(H_TRACE, h->h_flags))
			{
				/*
				**  DRUMS msg-fmt draft says can only have
				**  multiple occurences of trace fields,
				**  so make sure we replace any non-trace,
				**  non-user field.
				*/

				sysheader = h;
			}
		}
	}

	/* if not found as user-provided header at index, use sysheader */
	if (h == NULL)
		h = sysheader;

	if (h == NULL)
	{
		if (*val == '\0')
		{
			if (tTd(64, 10))
				dprintf("Delete (noop) %s:\n", field);
		}
		else
		{
			/* treat modify value with no existing header as add */
			if (tTd(64, 10))
				dprintf("Add %s: %s\n",	field, val);

			addheader(newstr(field), val, H_USER, &e->e_header);
		}
		return;
	}

	if (tTd(64, 10))
	{
		if (*val == '\0')
		{
			dprintf("Delete%s %s: %s\n",
				h == sysheader ? " (default header)" : "",
				field,
				h->h_value == NULL ? "<NULL>" : h->h_value);
		}
		else
		{
			dprintf("Change%s %s: from %s to %s\n",
				h == sysheader ? " (default header)" : "",
				field,
				h->h_value == NULL ? "<NULL>" : h->h_value,
				val);
		}
	}

	if (h != sysheader && h->h_value != NULL)
	{
		e->e_msgsize -= strlen(h->h_value);
		free(h->h_value);
	}

	if (*val == '\0')
	{
		/* Remove "Field: " from message size */
		if (h != sysheader)
			e->e_msgsize -= strlen(h->h_field) + 2;
		h->h_value = NULL;
	}
	else
	{
		h->h_value = newstr(val);
		h->h_flags |= H_USER;
		e->e_msgsize += strlen(h->h_value);
	}
d1804 1
a1804 1
	    strlen(response) + 1 != (size_t) rlen)
d1807 1
a1807 2
			dprintf("didn't follow protocol (total len %d != rlen %d)\n",
				strlen(response), rlen -1);
d1846 1
a1846 1
	    strlen(response) + 1 != (size_t) rlen)
d1862 6
a1867 3
**		response -- encoded form of new body.
**		rlen -- length of response.
**		newfilter -- if first time called by a new filter
d1875 5
a1879 4
milter_replbody(response, rlen, newfilter, e)
	char *response;
	ssize_t rlen;
	bool newfilter;
d1882 3
a1884 1
	static char prevchar;
d1886 4
d1892 1
a1892 1
		dprintf("milter_replbody\n");
d1894 6
a1899 2
	/* If a new filter, reset previous character and truncate df */
	if (newfilter)
d1901 26
a1926 2
		off_t prevsize = 0;
		char dfname[MAXPATHLEN];
d1928 10
a1937 1
		(void) strlcpy(dfname, queuename(e, 'd'), sizeof dfname);
d1939 6
a1944 2
		/* Reset prevchar */
		prevchar = '\0';
d1946 2
a1947 2
		/* Get the current df information */
		if (bitset(EF_HAS_DF, e->e_flags) && e->e_dfp != NULL)
d1949 12
a1960 6
			int afd;
			struct stat st;

			afd = fileno(e->e_dfp);
			if (afd > 0 && fstat(afd, &st) == 0)
				prevsize = st.st_size;
d1962 25
d1988 3
a1990 2
		/* truncate current df file */
		if (bftruncate(e->e_dfp) < 0)
d1992 49
a2040 9
			MILTER_DF_ERROR("milter_reopen_df: bftruncate %s: %s");
			return -1;
		}
		else
		{
			if (prevsize > e->e_msgsize)
				e->e_msgsize = 0;
			else
				e->e_msgsize -= prevsize;
a2041 1
	}
d2043 3
a2045 10
	if (response == NULL)
	{
		/* Flush the buffered '\r' */
		if (prevchar == '\r')
		{
			(void) putc(prevchar, e->e_dfp);
			e->e_msgsize++;
		}
		return 0;
	}
d2047 1
a2047 4
	for (i = 0; i < rlen; i++)
	{
		/* Buffered char from last chunk */
		if (i == 0 && prevchar == '\r')
d2049 1
a2049 2
			/* Not CRLF, output prevchar */
			if (response[i] != '\n')
d2051 3
a2053 2
				(void) putc(prevchar, e->e_dfp);
				e->e_msgsize++;
d2055 2
a2056 1
			prevchar = '\0';
d2059 26
a2084 2
		/* Turn CRLF into LF */
		if (response[i] == '\r')
d2086 3
a2088 13
			/* check if at end of chunk */
			if (i + 1 < rlen)
			{
				/* If LF, strip CR */
				if (response[i + 1] == '\n')
					i++;
			}
			else
			{
				/* check next chunk */
				prevchar = '\r';
				continue;
			}
d2090 47
a2136 2
		(void) putc(response[i], e->e_dfp);
		e->e_msgsize++;
d2138 6
d2181 1
a2181 1
			MILTER_CHECK_ERROR(continue);
d2195 5
d2201 5
a2205 1
			MILTER_CHECK_ERROR(continue);
d2288 1
a2288 1
		s += sizeof(port) + strlen(sockinfo) + 1;
d2303 1
a2303 3

		/* include trailing '\0' */
		(void) memcpy(bp, sockinfo, strlen(sockinfo) + 1);
d2509 77
a2585 1
**  MILTER_DATA -- send message headers/body and gather final message results
a2599 15
# define MILTER_CHECK_RESULTS() \
	if (*state == SMFIR_ACCEPT || \
	    m->mf_state == SMFS_DONE || \
	    m->mf_state == SMFS_ERROR) \
	{ \
		if (m->mf_state != SMFS_ERROR) \
			m->mf_state = SMFS_DONE; \
		continue;	/* to next filter */ \
	} \
	if (*state != SMFIR_CONTINUE) \
	{ \
		m->mf_state = SMFS_DONE; \
		goto finishup; \
	}

d2601 1
a2601 1
milter_data(e, state)
d2605 2
a2606 5
	bool replbody = FALSE;		/* milter_replbody() called? */
	bool replfailed = FALSE;	/* milter_replbody() failed? */
	bool rewind = FALSE;		/* rewind df file? */
	bool dfopen = FALSE;		/* df open for writing? */
	bool newfilter;			/* reset on each new filter */
d2608 2
d2611 1
d2613 1
d2617 1
d2620 1
a2620 1
		dprintf("milter_data\n");
d2624 5
a2628 7
	/*
	**  XXX: Should actually send body chunks to each filter
	**  a chunk at a time instead of sending the whole body to
	**  each filter in turn.  However, only if the filters don't
	**  change the body.
	*/

a2645 8
		newfilter = TRUE;

		/* previous problem? */
		if (m->mf_state == SMFS_ERROR)
		{
			MILTER_CHECK_ERROR(continue);
			break;
		}
d2653 1
d2655 2
a2656 2
		/* check if filter wants the headers */
		if (!bitset(SMFIP_NOHDRS, m->mf_pflags))
d2658 2
a2659 2
			response = milter_headers(m, e, state);
			MILTER_CHECK_RESULTS();
d2662 1
a2662 2
		/* check if filter wants EOH */
		if (!bitset(SMFIP_NOEOH, m->mf_pflags))
d2664 3
a2666 2
			if (tTd(64, 10))
				dprintf("milter_data: eoh\n");
d2668 7
a2674 4
			/* send it over */
			response = milter_send_command(m, SMFIC_EOH, NULL, 0,
						       e, state);
			MILTER_CHECK_RESULTS();
d2677 2
a2678 3
		/* check if filter wants the body */
		if (!bitset(SMFIP_NOBODY, m->mf_pflags) &&
		    e->e_dfp != NULL)
d2680 85
a2764 3
			rewind = TRUE;
			response = milter_body(m, e, state);
			MILTER_CHECK_RESULTS();
d2767 21
a2787 3
		/* send the final body chunk */
		(void) milter_write(m, SMFIC_BODYEOB, NULL, 0,
				    m->mf_timeout[SMFTO_WRITE], e);
d2795 4
d2804 1
a2804 1
					dprintf("milter_data(%s): EOM ACK/NAK timeout\n",
d2808 1
a2808 1
						  "milter_data(%s): EOM ACK/NAK timeout\n",
d2811 1
a2811 1
				MILTER_CHECK_ERROR(continue);
d2820 1
d2822 4
a2825 2
				dprintf("milter_data(%s): state %c\n",
					m->mf_name, (char) rcmd);
d2856 1
a2856 1
				if (!bitset(SMFIF_ADDHDRS, m->mf_fflags))
d2860 1
a2860 1
							  "milter_data(%s): lied about adding headers, honoring request anyway",
a2865 11
			  case SMFIR_CHGHEADER:
				if (!bitset(SMFIF_CHGHDRS, m->mf_fflags))
				{
					if (LogLevel > 9)
						sm_syslog(LOG_WARNING, e->e_id,
							  "milter_data(%s): lied about changing headers, honoring request anyway",
							  m->mf_name);
				}
				milter_changeheader(response, rlen, e);
				break;

d2871 1
a2871 1
							  "milter_data(%s) lied about adding recipients, honoring request anyway",
d2882 1
a2882 1
							  "milter_data(%s): lied about removing recipients, honoring request anyway",
d2893 1
a2893 1
							  "milter_data(%s): lied about replacing body, rejecting request and tempfailing message",
d2896 1
a2896 1
					break;
d2898 1
d2900 2
a2901 5
				/* already failed in attempt */
				if (replfailed)
					break;

				if (!dfopen)
d2903 2
a2904 7
					if (milter_reopen_df(e) < 0)
					{
						replfailed = TRUE;
						break;
					}
					dfopen = TRUE;
					rewind = TRUE;
d2907 7
a2913 2
				if (milter_replbody(response, rlen,
						    newfilter, e) < 0)
d2915 3
a2917 3
				newfilter = FALSE;
				replbody = TRUE;
				break;
d2923 1
a2923 1
						  "milter_data(%s): returned bogus response %c",
a2933 10

			if (m->mf_state == SMFS_ERROR)
				break;
		}

		if (replbody && !replfailed)
		{
			/* flush possible buffered character */
			milter_replbody(NULL, 0, !replbody, e);
			replbody = FALSE;
a2934 1

d2937 1
a2937 1
			MILTER_CHECK_ERROR(continue);
d2944 1
a2944 25
	if (replfailed)
	{
		if (*state == SMFIR_CONTINUE ||
		    *state == SMFIR_ACCEPT)
		{
			*state = SMFIR_TEMPFAIL;
			if (response != NULL)
			{
				free(response);
				response = NULL;
			}
		}

		if (dfopen)
		{
			(void) fclose(e->e_dfp);
			e->e_dfp = NULL;
			e->e_flags &= ~EF_HAS_DF;
			dfopen = FALSE;
		}
		rewind = FALSE;
	}

	if ((dfopen && milter_reset_df(e) < 0) ||
	    (rewind && bfrewind(e->e_dfp) < 0))
d2946 1
a2956 1
		{
a2957 6
			if (response != NULL)
			{
				free(response);
				response = NULL;
			}
		}
d2960 1
a2960 1
		syserr("milter_data: %s/df%s: read error",
a2962 1
	MILTER_CHECK_DONE_MSG();
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d11 3
a13 1
#include <sendmail.h>
d15 1
a15 5
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.173 2001/09/04 22:43:04 ca Exp $")

#if MILTER
# include <libmilter/mfapi.h>
# include <libmilter/mfdef.h>
d17 1
d25 3
a27 1
# include <sm/fdset.h>
d29 1
a29 2
static void	milter_connect_timeout __P((void));
static void	milter_error __P((struct milter *, ENVELOPE *));
d65 1
a65 1
			sm_free(response); /* XXX */ \
d77 1
a77 1
				sm_free(response); /* XXX */ \
d91 2
a92 2
		sm_dprintf(msg, dfname, sm_errstring(save_errno)); \
		sm_dprintf("\n"); \
d94 3
a96 3
	if (MilterLogLevel > 0) \
		sm_syslog(LOG_ERR, e->e_id, msg, dfname, sm_errstring(save_errno)); \
	if (SuperSafe == SAFE_REALLY) \
d100 1
a100 1
			(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT); \
a114 1
**		started -- whether this is part of a previous sequence
d119 1
a119 1
# define MILTER_TIMEOUT(routine, secs, write, started) \
d126 1
a126 1
	if (SM_FD_SETSIZE > 0 && m->mf_sock >= SM_FD_SETSIZE) \
d129 3
a131 4
			sm_dprintf("milter_%s(%s): socket %d is larger than FD_SETSIZE %d\n", \
				   (routine), m->mf_name, m->mf_sock, \
				   SM_FD_SETSIZE); \
		if (MilterLogLevel > 0) \
d133 3
a135 4
				  "Milter (%s): socket(%s) %d is larger than FD_SETSIZE %d", \
				  m->mf_name, (routine), m->mf_sock, \
				  SM_FD_SETSIZE); \
		milter_error(m, e); \
d141 1
a141 1
	tv.tv_sec = (secs); \
d144 2
a145 2
		     (write) ? NULL : &fds, \
		     (write) ? &fds : NULL, \
d152 5
a156 9
			sm_dprintf("milter_%s(%s): timeout\n", (routine), \
				   m->mf_name); \
		if (MilterLogLevel > 0) \
			sm_syslog(LOG_ERR, e->e_id, \
				  "Milter (%s): %s %s %s %s", \
				  m->mf_name, "timeout", \
				  started ? "during" : "before", \
				  "data", (routine)); \
		milter_error(m, e); \
d162 3
a164 4
			sm_dprintf("milter_%s(%s): select: %s\n", (routine), \
				   m->mf_name, sm_errstring(save_errno)); \
		if (MilterLogLevel > 0) \
		{ \
d166 3
a168 5
				  "Milter (%s): select(%s): %s", \
				  m->mf_name, (routine), \
				  sm_errstring(save_errno)); \
		} \
		milter_error(m, e); \
d175 3
a177 4
			sm_dprintf("milter_%s(%s): socket not ready\n", \
				(routine), m->mf_name); \
		if (MilterLogLevel > 0) \
		{ \
d179 3
a181 4
				  "Milter (%s): socket(%s) not ready", \
				  m->mf_name, (routine)); \
		} \
		milter_error(m, e); \
a213 1
	bool started = false;
d230 3
a232 5
					sm_dprintf("milter_read (%s): %s %s %s",
						  m->mf_name, "timeout",
						  started ? "during" : "before",
						  "data read");
				if (MilterLogLevel > 0)
d234 3
a236 5
						  "Milter (%s): %s %s %s",
						  m->mf_name, "timeout",
						  started ? "during" : "before",
						  "data read");
				milter_error(m, e);
d241 1
a241 1
			MILTER_TIMEOUT("read", to, false, started);
d251 1
a251 1
				sm_dprintf("milter_read(%s): read returned %ld: %s\n",
d253 2
a254 2
					sm_errstring(save_errno));
			if (MilterLogLevel > 0)
d256 1
a256 1
					  "Milter (%s): read returned %ld: %s",
d258 2
a259 2
					  sm_errstring(save_errno));
			milter_error(m, e);
a262 1
		started = true;
d264 1
a264 1
		if (len == 0 || curl >= sz)
d272 1
a272 1
			sm_dprintf("milter_read(%s): cmd read returned %ld, expecting %ld\n",
d274 1
a274 1
		if (MilterLogLevel > 0)
d276 1
a276 1
				  "milter_read(%s): cmd read returned %ld, expecting %ld",
d278 1
a278 1
		milter_error(m, e);
d316 1
a316 1
				sm_dprintf("milter_read(%s): timeout before data read\n",
d318 1
a318 1
			if (MilterLogLevel > 0)
d320 1
a320 1
					  "Milter read(%s): timeout before data read",
d322 1
a322 1
			milter_error(m, e);
d334 1
a334 1
		sm_dprintf("milter_read(%s): expecting %ld bytes\n",
d340 1
a340 1
			sm_dprintf("milter_read(%s): read size %ld out of range\n",
d342 1
a342 1
		if (MilterLogLevel > 0)
d346 1
a346 1
		milter_error(m, e);
d353 1
a353 1
	buf = (char *) xalloc(expl);
d357 1
a357 1
		sm_free(buf); /* XXX */
d362 1
a362 1
		sm_dprintf("milter_read(%s): Returning %*s\n",
a396 1
	bool started = false;
d401 1
a401 1
			sm_dprintf("milter_write(%s): length %ld out of range\n",
d403 1
a403 1
		if (MilterLogLevel > 0)
d407 1
a407 1
		milter_error(m, e);
d412 2
a413 2
		sm_dprintf("milter_write(%s): cmd %c, len %ld\n",
			   m->mf_name, cmd, (long) len);
d423 1
a423 1
		MILTER_TIMEOUT("write", to, true, started);
d433 4
a436 4
			sm_dprintf("milter_write (%s): write(%c) returned %ld, expected %ld: %s\n",
				   m->mf_name, cmd, (long) i, (long) sl,
				   sm_errstring(save_errno));
		if (MilterLogLevel > 0)
d438 1
a438 1
				  "Milter (%s): write(%c) returned %ld, expected %ld: %s",
d440 2
a441 2
				  sm_errstring(save_errno));
		milter_error(m, e);
d449 2
a450 3
		sm_dprintf("milter_write(%s): Sending %*s\n",
			   m->mf_name, (int) len, buf);
	started = true;
d460 3
a462 3
				sm_dprintf("milter_write(%s): timeout before data write\n",
					   m->mf_name);
			if (MilterLogLevel > 0)
d464 1
a464 1
					  "Milter (%s): timeout before data write",
d466 1
a466 1
			milter_error(m, e);
d472 1
a472 1
			MILTER_TIMEOUT("write", to, true, started);
d482 4
a485 4
			sm_dprintf("milter_write(%s): write(%c) returned %ld, expected %ld: %s\n",
				   m->mf_name, cmd, (long) i, (long) sl,
				   sm_errstring(save_errno));
		if (MilterLogLevel > 0)
d487 1
a487 1
				  "Milter (%s): write(%c) returned %ld, expected %ld: %s",
d489 2
a490 2
				  sm_errstring(save_errno));
		milter_error(m, e);
a513 2
static jmp_buf	MilterConnectTimeout;

d533 2
a534 2
			sm_dprintf("X%s: empty or missing socket information\n",
				   m->mf_name);
d538 1
a538 1
		else if (MilterLogLevel > 10)
d540 1
a540 1
				  "Milter (%s): empty or missing socket information",
d542 1
a542 1
		milter_error(m, e);
d569 1
a569 1
				  "Milter (%s): no valid socket protocols available",
d571 1
a571 1
			milter_error(m, e);
d578 2
a579 2
		else if (sm_strcasecmp(p, "unix") == 0 ||
			 sm_strcasecmp(p, "local") == 0)
d583 1
a583 1
		else if (sm_strcasecmp(p, "inet") == 0)
d587 1
a587 1
		else if (sm_strcasecmp(p, "inet6") == 0)
d598 1
a598 1
				sm_dprintf("X%s: unknown socket type %s\n",
d603 1
a603 1
			else if (MilterLogLevel > 10)
d605 1
a605 1
					  "Milter (%s): unknown socket type %s",
d607 1
a607 1
			milter_error(m, e);
d628 1
a628 1
				sm_dprintf("X%s: local socket name %s too long\n",
d634 1
a634 1
			else if (MilterLogLevel > 10)
d636 1
a636 1
					  "Milter (%s): local socket name %s too long",
d638 1
a638 1
			milter_error(m, e);
d649 3
a651 3
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "WARNING: X%s: local socket name %s missing\n",
						     m->mf_name, colon);
d658 1
a658 1
				sm_dprintf("X%s: local socket name %s unsafe\n",
d669 1
a669 1
			else if (MilterLogLevel > 10)
d671 1
a671 1
					  "Milter (%s): local socket name %s unsafe",
d673 1
a673 1
			milter_error(m, e);
d677 1
a677 1
		(void) sm_strlcpy(addr.sunix.sun_path, colon,
d684 1
a684 1
	if (false
d693 1
a693 1
		unsigned short port;
d700 1
a700 1
				sm_dprintf("X%s: bad address %s (expected port@@host)\n",
d705 1
a705 1
			else if (MilterLogLevel > 10)
d707 1
a707 1
					  "Milter (%s): bad address %s (expected port@@host)",
d709 1
a709 1
			milter_error(m, e);
d714 1
a714 1
			port = htons((unsigned short) atoi(colon));
d719 1
a719 1
				sm_dprintf("X%s: invalid port number %s\n",
d724 1
a724 1
			else if (MilterLogLevel > 10)
d726 1
a726 1
					  "Milter (%s): invalid port number %s",
d728 1
a728 1
			milter_error(m, e);
d738 1
a738 1
					sm_dprintf("X%s: unknown port name %s\n",
d744 1
a744 1
				else if (MilterLogLevel > 10)
d746 1
a746 1
						  "Milter (%s): unknown port name %s",
d748 1
a748 1
				milter_error(m, e);
d762 1
a762 1
				bool found = false;
d777 1
a777 1
					found = true;
d783 2
a784 2
				    anynet_pton(AF_INET6, &at[1],
						&hid6.sin6_addr) == 1)
d788 1
a788 1
					found = true;
d795 1
a795 1
						sm_dprintf("X%s: Invalid numeric domain spec \"%s\"\n",
d800 1
a800 1
					else if (MilterLogLevel > 10)
d802 1
a802 1
							  "Milter (%s): Invalid numeric domain spec \"%s\"",
d804 1
a804 1
					milter_error(m, e);
d811 1
a811 1
					sm_dprintf("X%s: Invalid numeric domain spec \"%s\"\n",
d816 1
a816 1
				else if (MilterLogLevel > 10)
d818 1
a818 1
						  "Milter (%s): Invalid numeric domain spec \"%s\"",
d820 1
a820 1
				milter_error(m, e);
d831 2
a832 2
					sm_dprintf("X%s: Unknown host name %s\n",
						   m->mf_name, at);
d837 1
a837 1
				else if (MilterLogLevel > 10)
d839 1
a839 1
						  "Milter (%s): Unknown host name %s",
d841 1
a841 1
				milter_error(m, e);
d850 2
a851 1
					hp->h_addr, INADDRSZ);
d861 2
a862 1
					hp->h_addr, IN6ADDRSZ);
d871 3
a873 3
					sm_dprintf("X%s: Unknown protocol for %s (%d)\n",
						   m->mf_name, at,
						   hp->h_addrtype);
d877 1
a877 1
				else if (MilterLogLevel > 10)
d879 1
a879 1
						  "Milter (%s): Unknown protocol for %s (%d)",
d882 2
a883 2
				milter_error(m, e);
#  if NETINET6
d885 1
a885 1
#  endif /* NETINET6 */
d894 1
a894 2
			sm_dprintf("X%s: unknown socket protocol\n",
				   m->mf_name);
d897 1
a897 1
		else if (MilterLogLevel > 10)
d899 2
a900 3
				  "Milter (%s): unknown socket protocol",
				  m->mf_name);
		milter_error(m, e);
d908 1
a908 1
# if NETINET6
d911 1
a911 1
# endif /* NETINET6 */
d921 4
a924 4
			sm_dprintf("Milter (%s): Trying to open filter in state %c\n",
				   m->mf_name, (char) m->mf_state);
		milter_error(m, e);
# if NETINET6
d927 1
a927 1
# endif /* NETINET6 */
d939 3
a941 4
				sm_dprintf("Milter (%s): error creating socket: %s\n",
					   m->mf_name,
					   sm_errstring(save_errno));
			if (MilterLogLevel > 0)
d943 4
a946 4
					  "Milter (%s): error creating socket: %s",
					  m->mf_name, sm_errstring(save_errno));
			milter_error(m, e);
# if NETINET6
d949 1
a949 1
# endif /* NETINET6 */
d953 2
a954 17
		if (setjmp(MilterConnectTimeout) == 0)
		{
			SM_EVENT *ev = NULL;
			int i;

			if (m->mf_timeout[SMFTO_CONNECT] > 0)
				ev = sm_setevent(m->mf_timeout[SMFTO_CONNECT],
						 milter_connect_timeout, 0);

			i = connect(sock, (struct sockaddr *) &addr, addrlen);
			save_errno = errno;
			if (ev != NULL)
				sm_clrevent(ev);
			errno = save_errno;
			if (i >= 0)
				break;
		}
d961 3
a963 3
			sm_dprintf("milter_open (%s): open %s failed: %s\n",
				   m->mf_name, at, sm_errstring(save_errno));
		if (MilterLogLevel > 13)
d965 2
a966 2
				  "Milter (%s): open %s failed: %s",
				  m->mf_name, at, sm_errstring(save_errno));
d993 4
a996 4
					sm_dprintf("X%s: Unknown protocol for %s (%d)\n",
						   m->mf_name, at,
						   hp->h_addrtype);
				if (MilterLogLevel > 0)
d998 1
a998 1
						  "Milter (%s): Unknown protocol for %s (%d)",
d1001 2
a1002 2
				milter_error(m, e);
# if NETINET6
d1004 1
a1004 1
# endif /* NETINET6 */
a1008 2
		p = CurHostName;
		CurHostName = at;
d1010 3
a1012 3
			sm_dprintf("X%s: error connecting to filter: %s\n",
				   m->mf_name, sm_errstring(save_errno));
		if (MilterLogLevel > 0)
d1014 4
a1017 5
				  "Milter (%s): error connecting to filter: %s",
				  m->mf_name, sm_errstring(save_errno));
		CurHostName = p;
		milter_error(m, e);
# if NETINET6
d1020 1
a1020 1
# endif /* NETINET6 */
d1024 1
a1024 1
# if NETINET6
d1030 1
a1030 1
# endif /* NETINET6 */
a1032 13

static void
milter_connect_timeout()
{
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
	longjmp(MilterConnectTimeout, 1);
}
d1064 1
a1064 1
	m = (struct milter *) xalloc(sizeof *m);
a1068 1
	m->mf_timeout[SMFTO_CONNECT] = (time_t) 300;
d1128 1
a1128 1
	(void) milter_open(m, true, CurEnv);
d1138 1
a1138 1
**  MILTER_CONFIG -- parse option list into an array and check config
d1152 1
a1152 1
milter_config(spec, list, max)
a1179 3
#if _FFR_MILTER_PERDAEMON
		p = strpbrk(p, ";,");
#else /* _FFR_MILTER_PERDAEMON */
a1180 1
#endif /* _FFR_MILTER_PERDAEMON */
a1193 4

	/* if not set, set to LogLevel */
	if (MilterLogLevel == -1)
		MilterLogLevel = LogLevel;
a1244 8
		  case 'C':
			m->mf_timeout[SMFTO_CONNECT] = convtime(p, 's');
			if (tTd(64, 5))
				sm_dprintf("X%s: %c=%lu\n",
					   m->mf_name, fcode,
					   (unsigned long) m->mf_timeout[SMFTO_CONNECT]);
			break;

d1248 3
a1250 3
				sm_dprintf("X%s: %c=%lu\n",
					   m->mf_name, fcode,
					   (unsigned long) m->mf_timeout[SMFTO_WRITE]);
d1256 3
a1258 3
				sm_dprintf("X%s: %c=%lu\n",
					   m->mf_name, fcode,
					   (unsigned long) m->mf_timeout[SMFTO_READ]);
d1264 3
a1266 3
				sm_dprintf("X%s: %c=%lu\n",
					   m->mf_name, fcode,
					   (unsigned long) m->mf_timeout[SMFTO_EOM]);
d1271 2
a1272 2
				sm_dprintf("X%s: %c unknown\n",
					   m->mf_name, fcode);
d1298 2
a1299 2
	char		*mo_name;	/* long name of milter option */
	unsigned char	mo_code;	/* code for option */
a1309 2
# define MO_LOGLEVEL			0x05
	{ "loglevel",			MO_LOGLEVEL			},
d1325 1
a1325 1
		sm_dprintf("milter_set_option(%s = %s)", name, val);
d1329 1
a1329 1
		if (sm_strcasecmp(mo->mo_name, name) == 0)
a1333 1
	{
a1334 2
		return;
	}
d1343 1
a1343 1
			sm_dprintf(" (ignored)\n");
d1348 1
a1348 1
		sm_dprintf("\n");
a1351 4
	  case MO_LOGLEVEL:
		MilterLogLevel = atoi(val);
		break;

d1408 1
d1428 1
a1428 1
	(void) sm_strlcpy(dfname, queuename(e, 'd'), sizeof dfname);
d1431 1
a1431 1
	**  In SuperSafe == SAFE_REALLY mode, e->e_dfp is a read-only FP so
d1435 1
a1435 1
	**  In SuperSafe != SAFE_REALLY mode, e->e_dfp still points at the
d1441 1
a1441 1
	if (SuperSafe == SAFE_REALLY)
d1446 1
a1446 1
			(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT);
d1451 1
a1451 2
		if ((e->e_dfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, dfname,
					   SM_IO_RDWR, NULL)) == NULL)
d1453 1
a1453 1
			MILTER_DF_ERROR("milter_reopen_df: sm_io_open %s: %s");
d1483 1
a1483 1
	(void) sm_strlcpy(dfname, queuename(e, 'd'), sizeof dfname);
d1485 1
a1485 2
	if (sm_io_flush(e->e_dfp, SM_TIME_DEFAULT) != 0 ||
	    sm_io_error(e->e_dfp))
d1490 1
a1490 1
	else if (SuperSafe != SAFE_REALLY)
d1495 1
a1495 2
	else if ((afd = sm_io_getinfo(e->e_dfp, SM_IO_WHAT_FD, NULL)) >= 0
		 && fsync(afd) < 0)
d1500 1
a1500 1
	else if (sm_io_close(e->e_dfp, SM_TIME_DEFAULT) < 0)
d1505 1
a1505 2
	else if ((e->e_dfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, dfname,
					SM_IO_RDONLY, NULL)) == NULL)
d1521 1
a1521 1
**		true if any filter deletes recipients, false otherwise
d1527 1
a1527 1
	bool can = false;
d1531 1
a1531 1
		sm_dprintf("milter_can_delrcpts:");
d1539 1
a1539 1
			can = true;
d1544 1
a1544 1
		sm_dprintf("%s\n", can ? "true" : "false");
d1565 1
a1565 4
		sm_dprintf("milter_quit_filter(%s)\n", m->mf_name);
	if (MilterLogLevel > 18)
		sm_syslog(LOG_INFO, e->e_id, "Milter (%s): quit filter",
			  m->mf_name);
d1607 1
a1607 4
		sm_dprintf("milter_abort_filter(%s)\n", m->mf_name);
	if (MilterLogLevel > 10)
		sm_syslog(LOG_INFO, e->e_id, "Milter (%s): abort filter",
			  m->mf_name);
d1652 1
a1652 1
		mid = macid(macros[i]);
d1661 1
a1661 4
	if (s < 0)
		return;

	buf = (char *) xalloc(s);
d1666 1
a1666 1
		mid = macid(macros[i]);
d1674 1
a1674 1
			sm_dprintf("milter_send_macros(%s, %c): %s=%s\n",
d1677 1
a1677 1
		(void) sm_strlcpy(bp, macros[i], s - (bp - buf));
d1679 1
a1679 1
		(void) sm_strlcpy(bp, v, s - (bp - buf));
d1684 1
a1684 1
	sm_free(buf); /* XXX */
d1713 1
a1713 1
	unsigned long skipflag;
d1718 1
a1718 1
		sm_dprintf("milter_send_command(%s): cmd %c len %ld\n",
d1778 1
a1778 1
	/* send the command to the filter */
a1786 1
	/* get the response from the filter */
d1796 2
a1797 2
		sm_dprintf("milter_send_command(%s): returned %c\n",
			   m->mf_name, (char) rcmd);
a1802 3
		if (MilterLogLevel > 8)
			sm_syslog(LOG_INFO, e->e_id, "milter=%s, reject=%s",
				  m->mf_name, response);
d1813 1
a1813 8
		if (command == SMFIC_HELO ||
		    command == SMFIC_CONNECT)
			m->mf_state = SMFS_CLOSABLE;
		else
			m->mf_state = SMFS_DONE;
		if (MilterLogLevel > 8)
			sm_syslog(LOG_INFO, e->e_id, "Milter (%s): accepted",
				  m->mf_name);
d1824 1
a1824 1
		if (MilterLogLevel > 0)
d1828 1
a1828 1
		milter_error(m, e);
d1835 1
a1835 1
		sm_free(response); /* XXX */
a1866 1
	time_t tn = 0;
d1869 1
a1869 1
		sm_dprintf("milter_command: cmd %c len %ld\n",
a1899 3
		if (MilterLogLevel > 21)
			tn = curtime();

a1900 9

		if (MilterLogLevel > 21)
		{
			/* log the time it took for the command per filter */
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter (%s): time command (%c), %d",
				  m->mf_name, command, (int) (tn - curtime()));
		}

d1933 1
a1933 1
		if (MilterLogLevel > 0)
d1935 1
a1935 1
				  "Milter (%s): negotiate, impossible state",
d1937 1
a1937 1
		milter_error(m, e);
d1962 1
a1962 1
			sm_dprintf("milter_negotiate(%s): returned %c instead of %c\n",
d1964 1
a1964 1
		if (MilterLogLevel > 0)
d1966 1
a1966 1
				  "Milter (%s): negotiate: returned %c instead of %c",
d1969 2
a1970 2
			sm_free(response); /* XXX */
		milter_error(m, e);
d1978 1
a1978 1
			sm_dprintf("milter_negotiate(%s): did not return valid info\n",
d1980 1
a1980 1
		if (MilterLogLevel > 0)
d1982 1
a1982 1
				  "Milter (%s): negotiate: did not return valid info",
d1985 2
a1986 2
			sm_free(response); /* XXX */
		milter_error(m, e);
d1997 1
a1997 1
			sm_dprintf("milter_negotiate(%s): did not return enough info\n",
d1999 1
a1999 1
		if (MilterLogLevel > 0)
d2001 1
a2001 1
				  "Milter (%s): negotiate: did not return enough info",
d2004 2
a2005 2
			sm_free(response); /* XXX */
		milter_error(m, e);
d2013 1
a2013 1
	sm_free(response); /* XXX */
d2025 1
a2025 1
			sm_dprintf("milter_negotiate(%s): version %lu != MTA milter version %d\n",
d2027 1
a2027 1
		if (MilterLogLevel > 0)
d2029 1
a2029 1
				  "Milter (%s): negotiate: version %ld != MTA milter version %d",
d2031 1
a2031 1
		milter_error(m, e);
d2039 1
a2039 1
			sm_dprintf("milter_negotiate(%s): filter abilities 0x%lx != MTA milter abilities 0x%lx\n",
d2041 2
a2042 2
				(unsigned long) SMFI_CURR_ACTS);
		if (MilterLogLevel > 0)
d2044 1
a2044 1
				  "Milter (%s): negotiate: filter abilities 0x%lx != MTA milter abilities 0x%lx",
d2046 2
a2047 2
				  (unsigned long) SMFI_CURR_ACTS);
		milter_error(m, e);
d2055 1
a2055 1
			sm_dprintf("milter_negotiate(%s): protocol abilities 0x%lx != MTA milter abilities 0x%lx\n",
d2057 2
a2058 2
				(unsigned long) SMFI_CURR_PROT);
		if (MilterLogLevel > 0)
d2060 1
a2060 1
				  "Milter (%s): negotiate: protocol abilities 0x%lx != MTA milter abilities 0x%lx",
d2062 2
a2063 2
				  (unsigned long) SMFI_CURR_PROT);
		milter_error(m, e);
d2068 1
a2068 1
		sm_dprintf("milter_negotiate(%s): version %lu, fflags 0x%lx, pflags 0x%lx\n",
d2095 1
a2095 1
		if (m->mf_state == SMFS_CLOSABLE)
d2110 1
a2110 1
milter_error(m, e)
a2111 1
	ENVELOPE *e;
a2125 4

	if (MilterLogLevel > 0)
		sm_syslog(LOG_INFO, e->e_id, "Milter (%s): to error state",
			  m->mf_name);
a2147 4
	if (MilterLogLevel > 17)
		sm_syslog(LOG_INFO, e->e_id, "Milter (%s): headers, send",
			  m->mf_name);

d2166 1
a2166 1
			sm_dprintf("milter_headers: %s: %s\n",
a2167 3
		if (MilterLogLevel > 21)
			sm_syslog(LOG_INFO, e->e_id, "Milter (%s): header, %s",
				  m->mf_name, h->h_field);
d2169 2
a2170 3
		s = strlen(h->h_field) + 1 + strlen(h->h_value) + 1;
		if (s < 0)
			continue;
d2172 1
a2172 2
		(void) sm_snprintf(buf, s, "%s%c%s",
			h->h_field, '\0', h->h_value);
d2177 1
a2177 1
		sm_free(buf); /* XXX */
a2182 3
	if (MilterLogLevel > 17)
		sm_syslog(LOG_INFO, e->e_id, "Milter (%s): headers, sent",
			  m->mf_name);
d2211 1
a2211 1
		sm_dprintf("milter_body\n");
d2218 1
a2218 1
		       qid_printqueue(e->e_qgrp, e->e_qdir), e->e_id);
a2221 3
	if (MilterLogLevel > 17)
		sm_syslog(LOG_INFO, e->e_id, "Milter (%s): body, send",
			  m->mf_name);
d2223 1
a2223 1
	while ((c = sm_io_getc(e->e_dfp, SM_TIME_DEFAULT)) != SM_IO_EOF)
d2270 1
a2270 1
	if (sm_io_error(e->e_dfp))
d2279 1
a2279 1
				sm_free(response); /* XXX */
d2284 1
a2284 1
		       qid_printqueue(e->e_qgrp, e->e_qdir), e->e_id);
a2298 3
	if (MilterLogLevel > 17)
		sm_syslog(LOG_INFO, e->e_id, "Milter (%s): body, sent",
			  m->mf_name);
d2328 1
a2328 1
		sm_dprintf("milter_addheader: ");
d2334 1
a2334 1
			sm_dprintf("NULL response\n");
d2341 1
a2341 1
			sm_dprintf("didn't follow protocol (total len)\n");
d2352 1
a2352 1
			sm_dprintf("didn't follow protocol (part len)\n");
d2359 1
a2359 1
			sm_dprintf("empty field name\n");
d2365 1
a2365 1
		if (sm_strcasecmp(h->h_field, response) == 0 &&
d2377 2
a2378 6
			sm_dprintf("Replace default header %s value with %s\n",
				   h->h_field, val);
		if (MilterLogLevel > 8)
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter change: default header %s value with %s",
				  h->h_field, val);
d2385 2
a2386 5
			sm_dprintf("Add %s: %s\n", response, val);
		if (MilterLogLevel > 8)
			sm_syslog(LOG_INFO, e->e_id, "Milter add: header: %s: %s",
				  response, val);
		addheader(newstr(response), val, H_USER, e);
d2412 1
a2412 1
		sm_dprintf("milter_changeheader: ");
d2418 1
a2418 1
			sm_dprintf("NULL response\n");
d2425 1
a2425 1
			sm_dprintf("didn't follow protocol (total len)\n");
d2440 1
a2440 1
			sm_dprintf("didn't follow protocol (part len)\n");
d2447 1
a2447 1
			sm_dprintf("empty field name\n");
d2454 1
a2454 1
		if (sm_strcasecmp(h->h_field, field) == 0)
d2486 1
a2486 1
				sm_dprintf("Delete (noop) %s:\n", field);
d2492 3
a2494 2
				sm_dprintf("Add %s: %s\n", field, val);
			addheader(newstr(field), val, H_USER, e);
d2503 4
a2506 4
			sm_dprintf("Delete%s %s: %s\n",
				   h == sysheader ? " (default header)" : "",
				   field,
				   h->h_value == NULL ? "<NULL>" : h->h_value);
d2510 5
a2514 26
			sm_dprintf("Change%s %s: from %s to %s\n",
				   h == sysheader ? " (default header)" : "",
				   field,
				   h->h_value == NULL ? "<NULL>" : h->h_value,
				   val);
		}
	}

	if (MilterLogLevel > 8)
	{
		if (*val == '\0')
		{
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter delete: header %s %s: %s",
				  h == sysheader ? " (default header)" : "",
				  field,
				  h->h_value == NULL ? "<NULL>" : h->h_value);
		}
		else
		{
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter change: header %s %s: from %s to %s",
				  h == sysheader ? " (default header)" : "",
				  field,
				  h->h_value == NULL ? "<NULL>" : h->h_value,
				  val);
d2521 1
a2521 1
		/* rpool, don't free: sm_free(h->h_value); XXX */
d2557 1
a2557 1
		sm_dprintf("milter_addrcpt: ");
d2563 1
a2563 1
			sm_dprintf("NULL response\n");
d2571 2
a2572 2
			sm_dprintf("didn't follow protocol (total len %d != rlen %d)\n",
				   (int) strlen(response), (int) (rlen - 1));
d2577 1
a2577 3
		sm_dprintf("%s\n", response);
	if (MilterLogLevel > 8)
		sm_syslog(LOG_INFO, e->e_id, "Milter add: rcpt: %s", response);
d2600 1
a2600 1
		sm_dprintf("milter_delrcpt: ");
d2606 1
a2606 1
			sm_dprintf("NULL response\n");
d2614 1
a2614 1
			sm_dprintf("didn't follow protocol (total len)\n");
d2619 1
a2619 4
		sm_dprintf("%s\n", response);
	if (MilterLogLevel > 8)
		sm_syslog(LOG_INFO, e->e_id, "Milter delete: rcpt %s",
			  response);
d2647 1
a2647 1
		sm_dprintf("milter_replbody\n");
d2655 1
a2655 1
		(void) sm_strlcpy(dfname, queuename(e, 'd'), sizeof dfname);
d2666 1
a2666 1
			afd = sm_io_getinfo(e->e_dfp, SM_IO_WHAT_FD, NULL);
d2672 1
a2672 1
		if (sm_io_getinfo(e->e_dfp, SM_IO_WHAT_ISTYPE, BF_FILE_TYPE))
d2674 2
a2675 5
			if (sm_io_setinfo(e->e_dfp, SM_BF_TRUNCATE, NULL) < 0)
			{
				MILTER_DF_ERROR("milter_replbody: sm_io truncate %s: %s");
				return -1;
			}
d2679 4
a2682 29
			int err;

# if NOFTRUNCATE
			/* XXX: Not much we can do except rewind it */
			err = sm_io_error(e->e_dfp);
			(void) sm_io_flush(e->e_dfp, SM_TIME_DEFAULT);

			/*
			**  Clear error if tried to fflush()
			**  a read-only file pointer and
			**  there wasn't a previous error.
			*/

			if (err == 0)
				sm_io_clearerr(e->e_dfp);

			/* errno is set implicitly by fseek() before return */
			err = sm_io_seek(e->e_dfp, SM_TIME_DEFAULT,
					 0, SEEK_SET);
# else /* NOFTRUNCATE */
			err = ftruncate(sm_io_getinfo(e->e_dfp,
						      SM_IO_WHAT_FD, NULL),
					0);
# endif /* NOFTRUNCATE */
			if (err < 0)
			{
				MILTER_DF_ERROR("milter_replbody: sm_io ftruncate %s: %s");
				return -1;
			}
a2683 5

		if (prevsize > e->e_msgsize)
			e->e_msgsize = 0;
		else
			e->e_msgsize -= prevsize;
a2685 3
	if (MilterLogLevel > 8)
		sm_syslog(LOG_INFO, e->e_id, "Milter message: body replaced");

d2691 1
a2691 1
			(void) sm_io_putc(e->e_dfp, SM_TIME_DEFAULT, prevchar);
d2705 1
a2705 2
				(void) sm_io_putc(e->e_dfp, SM_TIME_DEFAULT,
						  prevchar);
d2728 1
a2728 1
		(void) sm_io_putc(e->e_dfp, SM_TIME_DEFAULT, response[i]);
d2746 1
a2746 1
**		true iff at least one filter is active
d2750 1
a2750 1
bool
d2758 1
a2758 1
		sm_dprintf("milter_init\n");
a2760 8
	if (InputFilters[0] == NULL)
	{
		if (MilterLogLevel > 10)
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter: no active filter");
		return false;
	}

d2765 1
a2765 1
		m->mf_sock = milter_open(m, false, e);
d2777 3
a2779 10
				sm_dprintf("milter_init(%s): failed to %s\n",
					   m->mf_name,
					   m->mf_sock < 0 ? "open" :
							    "negotiate");
			if (MilterLogLevel > 0)
				sm_syslog(LOG_INFO, e->e_id,
					  "Milter (%s): init failed to %s",
					  m->mf_name,
					  m->mf_sock < 0 ? "open" :
							   "negotiate");
d2782 1
a2782 1
			milter_error(m, e);
a2784 5
		if (MilterLogLevel > 9)
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter (%s): init success to %s",
				  m->mf_name,
				  m->mf_sock < 0 ? "open" : "negotiate");
a2794 2

	return true;
d2817 1
a2817 1
	unsigned short port;
d2827 1
a2827 3
		sm_dprintf("milter_connect(%s)\n", hostname);
	if (MilterLogLevel > 9)
		sm_syslog(LOG_INFO, e->e_id, "Milter: connect to filters");
d2850 1
a2850 4
		if (IN6_IS_ADDR_V4MAPPED(&addr.sin6.sin6_addr))
			family = SMFIA_INET;
		else
			family = SMFIA_INET6;
d2868 1
a2868 1
	buf = (char *) xalloc(s);
d2888 1
a2888 1
	sm_free(buf); /* XXX */
a2895 3
	{
		if (MilterLogLevel > 7)
			sm_syslog(LOG_INFO, e->e_id, "Milter: connect, ending");
a2896 1
	}
d2915 1
a2915 1
			sm_free(response); /* XXX */
a2938 1
	int i;
d2942 1
a2942 20
		sm_dprintf("milter_helo(%s)\n", helo);

	/* HELO/EHLO can come at any point */
	for (i = 0; InputFilters[i] != NULL; i++)
	{
		struct milter *m = InputFilters[i];

		switch (m->mf_state)
		{
		  case SMFS_INMSG:
			/* abort in message filters */
			milter_abort_filter(m, e);
			/* FALLTHROUGH */

		  case SMFS_DONE:
			/* reset done filters */
			m->mf_state = SMFS_OPEN;
			break;
		}
	}
d2974 1
a2974 1
		sm_dprintf("milter_envfrom:");
d2976 2
a2977 2
			sm_dprintf(" %s", args[i]);
		sm_dprintf("\n");
a2983 3
		if (MilterLogLevel > 10)
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter: reject, no sender");
d3010 1
a3010 8

	if (s < 0)
	{
		*state = SMFIR_TEMPFAIL;
		return NULL;
	}

	buf = (char *) xalloc(s);
d3014 1
a3014 1
		(void) sm_strlcpy(bp, args[i], s - (bp - buf));
a3017 3
	if (MilterLogLevel > 14)
		sm_syslog(LOG_INFO, e->e_id, "Milter: senders: %s", buf);

d3021 1
a3021 1
	sm_free(buf); /* XXX */
a3029 2
	if (MilterLogLevel > 10 && *state == SMFIR_REJECT)
		sm_syslog(LOG_INFO, e->e_id, "Milter: reject, senders");
d3057 1
a3057 1
		sm_dprintf("milter_envrcpt:");
d3059 2
a3060 2
			sm_dprintf(" %s", args[i]);
		sm_dprintf("\n");
a3066 2
		if (MilterLogLevel > 10)
			sm_syslog(LOG_INFO, e->e_id, "Milter: reject, no rcpt");
d3074 1
a3074 8

	if (s < 0)
	{
		*state = SMFIR_TEMPFAIL;
		return NULL;
	}

	buf = (char *) xalloc(s);
d3078 1
a3078 1
		(void) sm_strlcpy(bp, args[i], s - (bp - buf));
a3081 3
	if (MilterLogLevel > 14)
		sm_syslog(LOG_INFO, e->e_id, "Milter: rcpts: %s", buf);

d3085 1
a3085 1
	sm_free(buf); /* XXX */
d3124 4
a3127 4
	bool replbody = false;		/* milter_replbody() called? */
	bool replfailed = false;	/* milter_replbody() failed? */
	bool rewind = false;		/* rewind df file? */
	bool dfopen = false;		/* df open for writing? */
d3137 1
a3137 1
		sm_dprintf("milter_data\n");
d3165 1
a3165 1
		newfilter = true;
d3192 1
a3192 1
				sm_dprintf("milter_data: eoh\n");
d3204 1
a3204 1
			rewind = true;
d3224 1
a3224 1
					sm_dprintf("milter_data(%s): EOM ACK/NAK timeout\n",
d3226 1
a3226 1
				if (MilterLogLevel > 0)
d3228 1
a3228 1
						  "milter_data(%s): EOM ACK/NAK timeout",
d3230 1
a3230 1
				milter_error(m, e);
d3241 2
a3242 2
				sm_dprintf("milter_data(%s): state %c\n",
					   m->mf_name, (char) rcmd);
a3247 3
				if (MilterLogLevel > 8)
					sm_syslog(LOG_INFO, e->e_id, "milter=%s, reject=%s",
						  m->mf_name, response);
d3252 1
a3252 1
			  case SMFIR_REJECT: /* log msg at end of function */
d3275 1
a3275 1
					if (MilterLogLevel > 9)
d3286 1
a3286 1
					if (MilterLogLevel > 9)
d3297 1
a3297 1
					if (MilterLogLevel > 9)
d3308 1
a3308 1
					if (MilterLogLevel > 9)
d3319 1
a3319 1
					if (MilterLogLevel > 0)
d3323 1
a3323 1
					replfailed = true;
d3335 1
a3335 1
						replfailed = true;
d3338 2
a3339 2
					dfopen = true;
					rewind = true;
d3344 3
a3346 3
					replfailed = true;
				newfilter = false;
				replbody = true;
d3351 1
a3351 1
				if (MilterLogLevel > 0)
d3355 1
a3355 1
				milter_error(m, e);
d3358 2
a3359 1
			if (rcmd != SMFIR_REPLYCODE && response != NULL)
d3361 1
a3361 1
				sm_free(response); /* XXX */
d3373 1
a3373 1
			replbody = false;
d3391 5
a3395 1
			SM_FREE_CLR(response);
d3400 1
a3400 1
			(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT);
d3403 1
a3403 1
			dfopen = false;
d3405 1
a3405 1
		rewind = false;
d3423 5
a3427 1
			SM_FREE_CLR(response);
d3432 1
a3432 1
		       qid_printqueue(e->e_qgrp, e->e_qdir), e->e_id);
a3433 1

a3434 2
	if (MilterLogLevel > 10 && *state == SMFIR_REJECT)
		sm_syslog(LOG_INFO, e->e_id, "Milter: reject, data");
d3454 1
a3454 1
		sm_dprintf("milter_quit(%s)\n", e->e_id);
d3476 1
a3476 1
		sm_dprintf("milter_abort\n");
d3489 1
a3489 1
#endif /* MILTER */
@


