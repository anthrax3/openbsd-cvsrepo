head	1.31;
access;
symbols
	OPENBSD_5_6:1.30.0.6
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.28.0.2
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.27.0.6
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.4
	OPENBSD_5_0:1.27.0.2
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.26.0.12
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.10
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.6
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.8
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.4
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.2
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.25.0.4
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.21.0.4
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.16.0.4
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2014.09.17.18.49.52;	author matthieu;	state dead;
branches;
next	1.30;
commitid	M7i5giHIoz3DMlTU;

1.30
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.28;

1.28
date	2012.12.26.11.44.12;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2011.05.17.15.54.24;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2007.04.04.14.43.49;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2006.08.13.13.01.48;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.22.18.43.55;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.08.16.00.51;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.16.00.21.31;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.24.03.59.27;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.19.01.41.14;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.17.17.31.40;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.29.19.44.01;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.03.17.31.21;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.01.19.59.23;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.09.15.02.23.36;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.26.04.48.55;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.03.17.25.47;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.18.00.49.28;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.01.17.18.30;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.11.19.02.50;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.01.01.01.41;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.29.01.31.15;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.28.02.43.54;	author millert;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.01.15.21.09.09;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.07.19.20.43;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.47;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.47;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.16;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.50;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.31.39;	author miod;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.31.01.47.57;	author jason;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2009, 2011, 2012 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>
#include <sm/sem.h>

SM_RCSID("@@(#)$Sendmail: queue.c,v 8.1000 2013/11/22 20:51:56 ca Exp $")

#include <dirent.h>

# define RELEASE_QUEUE	(void) 0
# define ST_INODE(st)	(st).st_ino

#  define sm_file_exists(errno) ((errno) == EEXIST)

# if HASFLOCK && defined(O_EXLOCK)
#   define SM_OPEN_EXLOCK 1
#   define TF_OPEN_FLAGS (O_CREAT|O_WRONLY|O_EXCL|O_EXLOCK)
# else /* HASFLOCK && defined(O_EXLOCK) */
#  define TF_OPEN_FLAGS (O_CREAT|O_WRONLY|O_EXCL)
# endif /* HASFLOCK && defined(O_EXLOCK) */

#ifndef SM_OPEN_EXLOCK
# define SM_OPEN_EXLOCK 0
#endif /* ! SM_OPEN_EXLOCK */

/*
**  Historical notes:
**	QF_VERSION == 4 was sendmail 8.10/8.11 without _FFR_QUEUEDELAY
**	QF_VERSION == 5 was sendmail 8.10/8.11 with    _FFR_QUEUEDELAY
**	QF_VERSION == 6 was sendmail 8.12      without _FFR_QUEUEDELAY
**	QF_VERSION == 7 was sendmail 8.12      with    _FFR_QUEUEDELAY
**	QF_VERSION == 8 is  sendmail 8.13
*/

#define QF_VERSION	8	/* version number of this queue format */

static char	queue_letter __P((ENVELOPE *, int));
static bool	quarantine_queue_item __P((int, int, ENVELOPE *, char *));

/* Naming convention: qgrp: index of queue group, qg: QUEUEGROUP */

/*
**  Work queue.
*/

struct work
{
	char		*w_name;	/* name of control file */
	char		*w_host;	/* name of recipient host */
	bool		w_lock;		/* is message locked? */
	bool		w_tooyoung;	/* is it too young to run? */
	long		w_pri;		/* priority of message, see below */
	time_t		w_ctime;	/* creation time */
	time_t		w_mtime;	/* modification time */
	int		w_qgrp;		/* queue group located in */
	int		w_qdir;		/* queue directory located in */
	struct work	*w_next;	/* next in queue */
};

typedef struct work	WORK;

static WORK	*WorkQ;		/* queue of things to be done */
static int	NumWorkGroups;	/* number of work groups */
static time_t	Current_LA_time = 0;

/* Get new load average every 30 seconds. */
#define GET_NEW_LA_TIME	30

#define SM_GET_LA(now)	\
	do							\
	{							\
		now = curtime();				\
		if (Current_LA_time < now - GET_NEW_LA_TIME)	\
		{						\
			sm_getla();				\
			Current_LA_time = now;			\
		}						\
	} while (0)

/*
**  DoQueueRun indicates that a queue run is needed.
**	Notice: DoQueueRun is modified in a signal handler!
*/

static bool	volatile DoQueueRun; /* non-interrupt time queue run needed */

/*
**  Work group definition structure.
**	Each work group contains one or more queue groups. This is done
**	to manage the number of queue group runners active at the same time
**	to be within the constraints of MaxQueueChildren (if it is set).
**	The number of queue groups that can be run on the next work run
**	is kept track of. The queue groups are run in a round robin.
*/

struct workgrp
{
	int		wg_numqgrp;	/* number of queue groups in work grp */
	int		wg_runners;	/* total runners */
	int		wg_curqgrp;	/* current queue group */
	QUEUEGRP	**wg_qgs;	/* array of queue groups */
	int		wg_maxact;	/* max # of active runners */
	time_t		wg_lowqintvl;	/* lowest queue interval */
	int		wg_restart;	/* needs restarting? */
	int		wg_restartcnt;	/* count of times restarted */
};

typedef struct workgrp WORKGRP;

static WORKGRP	volatile WorkGrp[MAXWORKGROUPS + 1];	/* work groups */

#if SM_HEAP_CHECK
static SM_DEBUG_T DebugLeakQ = SM_DEBUG_INITIALIZER("leak_q",
	"@@(#)$Debug: leak_q - trace memory leaks during queue processing $");
#endif /* SM_HEAP_CHECK */

/*
**  We use EmptyString instead of "" to avoid
**  'zero-length format string' warnings from gcc
*/

static const char EmptyString[] = "";

static void	grow_wlist __P((int, int));
static int	multiqueue_cache __P((char *, int, QUEUEGRP *, int, unsigned int *));
static int	gatherq __P((int, int, bool, bool *, bool *, int *));
static int	sortq __P((int));
static void	printctladdr __P((ADDRESS *, SM_FILE_T *));
static bool	readqf __P((ENVELOPE *, bool));
static void	restart_work_group __P((int));
static void	runner_work __P((ENVELOPE *, int, bool, int, int));
static void	schedule_queue_runs __P((bool, int, bool));
static char	*strrev __P((char *));
static ADDRESS	*setctluser __P((char *, int, ENVELOPE *));
#if _FFR_RHS
static int	sm_strshufflecmp __P((char *, char *));
static void	init_shuffle_alphabet __P(());
#endif /* _FFR_RHS */

/*
**  Note: workcmpf?() don't use a prototype because it will cause a conflict
**  with the qsort() call (which expects something like
**  int (*compar)(const void *, const void *), not (WORK *, WORK *))
*/

static int	workcmpf0();
static int	workcmpf1();
static int	workcmpf2();
static int	workcmpf3();
static int	workcmpf4();
static int	randi = 3;	/* index for workcmpf5() */
static int	workcmpf5();
static int	workcmpf6();
#if _FFR_RHS
static int	workcmpf7();
#endif /* _FFR_RHS */

#if RANDOMSHIFT
# define get_rand_mod(m)	((get_random() >> RANDOMSHIFT) % (m))
#else /* RANDOMSHIFT */
# define get_rand_mod(m)	(get_random() % (m))
#endif /* RANDOMSHIFT */

/*
**  File system definition.
**	Used to keep track of how much free space is available
**	on a file system in which one or more queue directories reside.
*/

typedef struct filesys_shared	FILESYS;

struct filesys_shared
{
	dev_t	fs_dev;		/* unique device id */
	long	fs_avail;	/* number of free blocks available */
	long	fs_blksize;	/* block size, in bytes */
};

/* probably kept in shared memory */
static FILESYS	FileSys[MAXFILESYS];	/* queue file systems */
static const char *FSPath[MAXFILESYS];	/* pathnames for file systems */

#if SM_CONF_SHM

/*
**  Shared memory data
**
**  Current layout:
**	size -- size of shared memory segment
**	pid -- pid of owner, should be a unique id to avoid misinterpretations
**		by other processes.
**	tag -- should be a unique id to avoid misinterpretations by others.
**		idea: hash over configuration data that will be stored here.
**	NumFileSys -- number of file systems.
**	FileSys -- (array of) structure for used file systems.
**	RSATmpCnt -- counter for number of uses of ephemeral RSA key.
**	QShm -- (array of) structure for information about queue directories.
*/

/*
**  Queue data in shared memory
*/

typedef struct queue_shared	QUEUE_SHM_T;

struct queue_shared
{
	int	qs_entries;	/* number of entries */
	/* XXX more to follow? */
};

static void	*Pshm;		/* pointer to shared memory */
static FILESYS	*PtrFileSys;	/* pointer to queue file system array */
int		ShmId = SM_SHM_NO_ID;	/* shared memory id */
static QUEUE_SHM_T	*QShm;		/* pointer to shared queue data */
static size_t shms;

# define SHM_OFF_PID(p)	(((char *) (p)) + sizeof(int))
# define SHM_OFF_TAG(p)	(((char *) (p)) + sizeof(pid_t) + sizeof(int))
# define SHM_OFF_HEAD	(sizeof(pid_t) + sizeof(int) * 2)

/* how to access FileSys */
# define FILE_SYS(i)	(PtrFileSys[i])

/* first entry is a tag, for now just the size */
# define OFF_FILE_SYS(p)	(((char *) (p)) + SHM_OFF_HEAD)

/* offset for PNumFileSys */
# define OFF_NUM_FILE_SYS(p)	(((char *) (p)) + SHM_OFF_HEAD + sizeof(FileSys))

/* offset for PRSATmpCnt */
# define OFF_RSA_TMP_CNT(p) (((char *) (p)) + SHM_OFF_HEAD + sizeof(FileSys) + sizeof(int))
int	*PRSATmpCnt;

/* offset for queue_shm */
# define OFF_QUEUE_SHM(p) (((char *) (p)) + SHM_OFF_HEAD + sizeof(FileSys) + sizeof(int) * 2)

# define QSHM_ENTRIES(i)	QShm[i].qs_entries

/* basic size of shared memory segment */
# define SM_T_SIZE	(SHM_OFF_HEAD + sizeof(FileSys) + sizeof(int) * 2)

static unsigned int	hash_q __P((char *, unsigned int));

/*
**  HASH_Q -- simple hash function
**
**	Parameters:
**		p -- string to hash.
**		h -- hash start value (from previous run).
**
**	Returns:
**		hash value.
*/

static unsigned int
hash_q(p, h)
	char *p;
	unsigned int h;
{
	int c, d;

	while (*p != '\0')
	{
		d = *p++;
		c = d;
		c ^= c<<6;
		h += (c<<11) ^ (c>>1);
		h ^= (d<<14) + (d<<7) + (d<<4) + d;
	}
	return h;
}


#else /* SM_CONF_SHM */
# define FILE_SYS(i)	FileSys[i]
#endif /* SM_CONF_SHM */

/* access to the various components of file system data */
#define FILE_SYS_NAME(i)	FSPath[i]
#define FILE_SYS_AVAIL(i)	FILE_SYS(i).fs_avail
#define FILE_SYS_BLKSIZE(i)	FILE_SYS(i).fs_blksize
#define FILE_SYS_DEV(i)	FILE_SYS(i).fs_dev


/*
**  Current qf file field assignments:
**
**	A	AUTH= parameter
**	B	body type
**	C	controlling user
**	D	data file name
**	d	data file directory name (added in 8.12)
**	E	error recipient
**	F	flag bits
**	G	free (was: queue delay algorithm if _FFR_QUEUEDELAY)
**	H	header
**	I	data file's inode number
**	K	time of last delivery attempt
**	L	Solaris Content-Length: header (obsolete)
**	M	message
**	N	number of delivery attempts
**	P	message priority
**	q	quarantine reason
**	Q	original recipient (ORCPT=)
**	r	final recipient (Final-Recipient: DSN field)
**	R	recipient
**	S	sender
**	T	init time
**	V	queue file version
**	X	free (was: character set if _FFR_SAVE_CHARSET)
**	Y	free (was: current delay if _FFR_QUEUEDELAY)
**	Z	original envelope id from ESMTP
**	!	deliver by (added in 8.12)
**	$	define macro
**	.	terminate file
*/

/*
**  QUEUEUP -- queue a message up for future transmission.
**
**	Parameters:
**		e -- the envelope to queue up.
**		announce -- if true, tell when you are queueing up.
**		msync -- if true, then fsync() if SuperSafe interactive mode.
**
**	Returns:
**		none.
**
**	Side Effects:
**		The current request is saved in a control file.
**		The queue file is left locked.
*/

void
queueup(e, announce, msync)
	register ENVELOPE *e;
	bool announce;
	bool msync;
{
	register SM_FILE_T *tfp;
	register HDR *h;
	register ADDRESS *q;
	int tfd = -1;
	int i;
	bool newid;
	register char *p;
	MAILER nullmailer;
	MCI mcibuf;
	char qf[MAXPATHLEN];
	char tf[MAXPATHLEN];
	char df[MAXPATHLEN];
	char buf[MAXLINE];

	/*
	**  Create control file.
	*/

#define OPEN_TF	do							\
		{							\
			MODE_T oldumask = 0;				\
									\
			if (bitset(S_IWGRP, QueueFileMode))		\
				oldumask = umask(002);			\
			tfd = open(tf, TF_OPEN_FLAGS, QueueFileMode);	\
			if (bitset(S_IWGRP, QueueFileMode))		\
				(void) umask(oldumask);			\
		} while (0)


	newid = (e->e_id == NULL) || !bitset(EF_INQUEUE, e->e_flags);
	(void) sm_strlcpy(tf, queuename(e, NEWQFL_LETTER), sizeof(tf));
	tfp = e->e_lockfp;
	if (tfp == NULL && newid)
	{
		/*
		**  open qf file directly: this will give an error if the file
		**  already exists and hence prevent problems if a queue-id
		**  is reused (e.g., because the clock is set back).
		*/

		(void) sm_strlcpy(tf, queuename(e, ANYQFL_LETTER), sizeof(tf));
		OPEN_TF;
		if (tfd < 0 ||
#if !SM_OPEN_EXLOCK
		    !lockfile(tfd, tf, NULL, LOCK_EX|LOCK_NB) ||
#endif /* !SM_OPEN_EXLOCK */
		    (tfp = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT,
					 (void *) &tfd, SM_IO_WRONLY,
					 NULL)) == NULL)
		{
			int save_errno = errno;

			printopenfds(true);
			errno = save_errno;
			syserr("!queueup: cannot create queue file %s, euid=%d, fd=%d, fp=%p",
				tf, (int) geteuid(), tfd, tfp);
			/* NOTREACHED */
		}
		e->e_lockfp = tfp;
		upd_qs(e, 1, 0, "queueup");
	}

	/* if newid, write the queue file directly (instead of temp file) */
	if (!newid)
	{
		/* get a locked tf file */
		for (i = 0; i < 128; i++)
		{
			if (tfd < 0)
			{
				OPEN_TF;
				if (tfd < 0)
				{
					if (errno != EEXIST)
						break;
					if (LogLevel > 0 && (i % 32) == 0)
						sm_syslog(LOG_ALERT, e->e_id,
							  "queueup: cannot create %s, euid=%d: %s",
							  tf, (int) geteuid(),
							  sm_errstring(errno));
				}
#if SM_OPEN_EXLOCK
				else
					break;
#endif /* SM_OPEN_EXLOCK */
			}
			if (tfd >= 0)
			{
#if SM_OPEN_EXLOCK
				/* file is locked by open() */
				break;
#else /* SM_OPEN_EXLOCK */
				if (lockfile(tfd, tf, NULL, LOCK_EX|LOCK_NB))
					break;
				else
#endif /* SM_OPEN_EXLOCK */
				if (LogLevel > 0 && (i % 32) == 0)
					sm_syslog(LOG_ALERT, e->e_id,
						  "queueup: cannot lock %s: %s",
						  tf, sm_errstring(errno));
				if ((i % 32) == 31)
				{
					(void) close(tfd);
					tfd = -1;
				}
			}

			if ((i % 32) == 31)
			{
				/* save the old temp file away */
				(void) rename(tf, queuename(e, TEMPQF_LETTER));
			}
			else
				(void) sleep(i % 32);
		}
		if (tfd < 0 || (tfp = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT,
						 (void *) &tfd, SM_IO_WRONLY_B,
						 NULL)) == NULL)
		{
			int save_errno = errno;

			printopenfds(true);
			errno = save_errno;
			syserr("!queueup: cannot create queue temp file %s, uid=%d",
				tf, (int) geteuid());
		}
	}

	if (tTd(40, 1))
		sm_dprintf("\n>>>>> queueing %s/%s%s >>>>>\n",
			   qid_printqueue(e->e_qgrp, e->e_qdir),
			   queuename(e, ANYQFL_LETTER),
			   newid ? " (new id)" : "");
	if (tTd(40, 3))
	{
		sm_dprintf("  e_flags=");
		printenvflags(e);
	}
	if (tTd(40, 32))
	{
		sm_dprintf("  sendq=");
		printaddr(sm_debug_file(), e->e_sendqueue, true);
	}
	if (tTd(40, 9))
	{
		sm_dprintf("  tfp=");
		dumpfd(sm_io_getinfo(tfp, SM_IO_WHAT_FD, NULL), true, false);
		sm_dprintf("  lockfp=");
		if (e->e_lockfp == NULL)
			sm_dprintf("NULL\n");
		else
			dumpfd(sm_io_getinfo(e->e_lockfp, SM_IO_WHAT_FD, NULL),
			       true, false);
	}

	/*
	**  If there is no data file yet, create one.
	*/

	(void) sm_strlcpy(df, queuename(e, DATAFL_LETTER), sizeof(df));
	if (bitset(EF_HAS_DF, e->e_flags))
	{
		if (e->e_dfp != NULL &&
		    SuperSafe != SAFE_REALLY &&
		    SuperSafe != SAFE_REALLY_POSTMILTER &&
		    sm_io_setinfo(e->e_dfp, SM_BF_COMMIT, NULL) < 0 &&
		    errno != EINVAL)
		{
			syserr("!queueup: cannot commit data file %s, uid=%d",
			       queuename(e, DATAFL_LETTER), (int) geteuid());
		}
		if (e->e_dfp != NULL &&
		    SuperSafe == SAFE_INTERACTIVE && msync)
		{
			if (tTd(40,32))
				sm_syslog(LOG_INFO, e->e_id,
					  "queueup: fsync(e->e_dfp)");

			if (fsync(sm_io_getinfo(e->e_dfp, SM_IO_WHAT_FD,
						NULL)) < 0)
			{
				if (newid)
					syserr("!552 Error writing data file %s",
					       df);
				else
					syserr("!452 Error writing data file %s",
					       df);
			}
		}
	}
	else
	{
		int dfd;
		MODE_T oldumask = 0;
		register SM_FILE_T *dfp = NULL;
		struct stat stbuf;

		if (e->e_dfp != NULL &&
		    sm_io_getinfo(e->e_dfp, SM_IO_WHAT_ISTYPE, BF_FILE_TYPE))
			syserr("committing over bf file");

		if (bitset(S_IWGRP, QueueFileMode))
			oldumask = umask(002);
		dfd = open(df, O_WRONLY|O_CREAT|O_TRUNC|QF_O_EXTRA,
			   QueueFileMode);
		if (bitset(S_IWGRP, QueueFileMode))
			(void) umask(oldumask);
		if (dfd < 0 || (dfp = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT,
						 (void *) &dfd, SM_IO_WRONLY_B,
						 NULL)) == NULL)
			syserr("!queueup: cannot create data temp file %s, uid=%d",
				df, (int) geteuid());
		if (fstat(dfd, &stbuf) < 0)
			e->e_dfino = -1;
		else
		{
			e->e_dfdev = stbuf.st_dev;
			e->e_dfino = ST_INODE(stbuf);
		}
		e->e_flags |= EF_HAS_DF;
		memset(&mcibuf, '\0', sizeof(mcibuf));
		mcibuf.mci_out = dfp;
		mcibuf.mci_mailer = FileMailer;
		(*e->e_putbody)(&mcibuf, e, NULL);

		if (SuperSafe == SAFE_REALLY ||
		    SuperSafe == SAFE_REALLY_POSTMILTER ||
		    (SuperSafe == SAFE_INTERACTIVE && msync))
		{
			if (tTd(40,32))
				sm_syslog(LOG_INFO, e->e_id,
					  "queueup: fsync(dfp)");

			if (fsync(sm_io_getinfo(dfp, SM_IO_WHAT_FD, NULL)) < 0)
			{
				if (newid)
					syserr("!552 Error writing data file %s",
					       df);
				else
					syserr("!452 Error writing data file %s",
					       df);
			}
		}

		if (sm_io_close(dfp, SM_TIME_DEFAULT) < 0)
			syserr("!queueup: cannot save data temp file %s, uid=%d",
				df, (int) geteuid());
		e->e_putbody = putbody;
	}

	/*
	**  Output future work requests.
	**	Priority and creation time should be first, since
	**	they are required by gatherq.
	*/

	/* output queue version number (must be first!) */
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "V%d\n", QF_VERSION);

	/* output creation time */
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "T%ld\n", (long) e->e_ctime);

	/* output last delivery time */
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "K%ld\n", (long) e->e_dtime);

	/* output number of delivery attempts */
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "N%d\n", e->e_ntries);

	/* output message priority */
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "P%ld\n", e->e_msgpriority);

	/*
	**  If data file is in a different directory than the queue file,
	**  output a "d" record naming the directory of the data file.
	*/

	if (e->e_dfqgrp != e->e_qgrp)
	{
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "d%s\n",
			Queue[e->e_dfqgrp]->qg_qpaths[e->e_dfqdir].qp_name);
	}

	/* output inode number of data file */
	if (e->e_dfino != -1)
	{
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "I%ld/%ld/%llu\n",
				     (long) major(e->e_dfdev),
				     (long) minor(e->e_dfdev),
				     (ULONGLONG_T) e->e_dfino);
	}

	/* output body type */
	if (e->e_bodytype != NULL)
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "B%s\n",
				     denlstring(e->e_bodytype, true, false));

	/* quarantine reason */
	if (e->e_quarmsg != NULL)
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "q%s\n",
				     denlstring(e->e_quarmsg, true, false));

	/* message from envelope, if it exists */
	if (e->e_message != NULL)
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "M%s\n",
				     denlstring(e->e_message, true, false));

	/* send various flag bits through */
	p = buf;
	if (bitset(EF_WARNING, e->e_flags))
		*p++ = 'w';
	if (bitset(EF_RESPONSE, e->e_flags))
		*p++ = 'r';
	if (bitset(EF_HAS8BIT, e->e_flags))
		*p++ = '8';
	if (bitset(EF_DELETE_BCC, e->e_flags))
		*p++ = 'b';
	if (bitset(EF_RET_PARAM, e->e_flags))
		*p++ = 'd';
	if (bitset(EF_NO_BODY_RETN, e->e_flags))
		*p++ = 'n';
	if (bitset(EF_SPLIT, e->e_flags))
		*p++ = 's';
	*p++ = '\0';
	if (buf[0] != '\0')
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "F%s\n", buf);

	/* save $={persistentMacros} macro values */
	queueup_macros(macid("{persistentMacros}"), tfp, e);

	/* output name of sender */
	if (bitnset(M_UDBENVELOPE, e->e_from.q_mailer->m_flags))
		p = e->e_sender;
	else
		p = e->e_from.q_paddr;
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "S%s\n",
			     denlstring(p, true, false));

	/* output ESMTP-supplied "original" information */
	if (e->e_envid != NULL)
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "Z%s\n",
				     denlstring(e->e_envid, true, false));

	/* output AUTH= parameter */
	if (e->e_auth_param != NULL)
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "A%s\n",
				     denlstring(e->e_auth_param, true, false));
	if (e->e_dlvr_flag != 0)
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "!%c %ld\n",
				     (char) e->e_dlvr_flag, e->e_deliver_by);

	/* output list of recipient addresses */
	printctladdr(NULL, NULL);
	for (q = e->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (!QS_IS_UNDELIVERED(q->q_state))
			continue;

		/* message for this recipient, if it exists */
		if (q->q_message != NULL)
			(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "M%s\n",
					     denlstring(q->q_message, true,
							false));

		printctladdr(q, tfp);
		if (q->q_orcpt != NULL)
			(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "Q%s\n",
					     denlstring(q->q_orcpt, true,
							false));
		if (q->q_finalrcpt != NULL)
			(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "r%s\n",
					     denlstring(q->q_finalrcpt, true,
							false));
		(void) sm_io_putc(tfp, SM_TIME_DEFAULT, 'R');
		if (bitset(QPRIMARY, q->q_flags))
			(void) sm_io_putc(tfp, SM_TIME_DEFAULT, 'P');
		if (bitset(QHASNOTIFY, q->q_flags))
			(void) sm_io_putc(tfp, SM_TIME_DEFAULT, 'N');
		if (bitset(QPINGONSUCCESS, q->q_flags))
			(void) sm_io_putc(tfp, SM_TIME_DEFAULT, 'S');
		if (bitset(QPINGONFAILURE, q->q_flags))
			(void) sm_io_putc(tfp, SM_TIME_DEFAULT, 'F');
		if (bitset(QPINGONDELAY, q->q_flags))
			(void) sm_io_putc(tfp, SM_TIME_DEFAULT, 'D');
		if (q->q_alias != NULL &&
		    bitset(QALIAS, q->q_alias->q_flags))
			(void) sm_io_putc(tfp, SM_TIME_DEFAULT, 'A');
		(void) sm_io_putc(tfp, SM_TIME_DEFAULT, ':');
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "%s\n",
				     denlstring(q->q_paddr, true, false));
		if (announce)
		{
			char *tag = "queued";

			if (e->e_quarmsg != NULL)
				tag = "quarantined";

			e->e_to = q->q_paddr;
			message(tag);
			if (LogLevel > 8)
				logdelivery(q->q_mailer, NULL, q->q_status,
					    tag, NULL, (time_t) 0, e);
			e->e_to = NULL;
		}
		if (tTd(40, 1))
		{
			sm_dprintf("queueing ");
			printaddr(sm_debug_file(), q, false);
		}
	}

	/*
	**  Output headers for this message.
	**	Expand macros completely here.  Queue run will deal with
	**	everything as absolute headers.
	**		All headers that must be relative to the recipient
	**		can be cracked later.
	**	We set up a "null mailer" -- i.e., a mailer that will have
	**	no effect on the addresses as they are output.
	*/

	memset((char *) &nullmailer, '\0', sizeof(nullmailer));
	nullmailer.m_re_rwset = nullmailer.m_rh_rwset =
			nullmailer.m_se_rwset = nullmailer.m_sh_rwset = -1;
	nullmailer.m_eol = "\n";
	memset(&mcibuf, '\0', sizeof(mcibuf));
	mcibuf.mci_mailer = &nullmailer;
	mcibuf.mci_out = tfp;

	macdefine(&e->e_macro, A_PERM, 'g', "\201f");
	for (h = e->e_header; h != NULL; h = h->h_link)
	{
		if (h->h_value == NULL)
			continue;

		/* don't output resent headers on non-resent messages */
		if (bitset(H_RESENT, h->h_flags) &&
		    !bitset(EF_RESENT, e->e_flags))
			continue;

		/* expand macros; if null, don't output header at all */
		if (bitset(H_DEFAULT, h->h_flags))
		{
			(void) expand(h->h_value, buf, sizeof(buf), e);
			if (buf[0] == '\0')
				continue;
			if (buf[0] == ' ' && buf[1] == '\0')
				continue;
		}

		/* output this header */
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "H?");

		/* output conditional macro if present */
		if (h->h_macro != '\0')
		{
			if (bitset(0200, h->h_macro))
				(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT,
						     "${%s}",
						      macname(bitidx(h->h_macro)));
			else
				(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT,
						     "$%c", h->h_macro);
		}
		else if (!bitzerop(h->h_mflags) &&
			 bitset(H_CHECK|H_ACHECK, h->h_flags))
		{
			int j;

			/* if conditional, output the set of conditions */
			for (j = '\0'; j <= '\177'; j++)
				if (bitnset(j, h->h_mflags))
					(void) sm_io_putc(tfp, SM_TIME_DEFAULT,
							  j);
		}
		(void) sm_io_putc(tfp, SM_TIME_DEFAULT, '?');

		/* output the header: expand macros, convert addresses */
		if (bitset(H_DEFAULT, h->h_flags) &&
		    !bitset(H_BINDLATE, h->h_flags))
		{
			(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "%s:%s\n",
					     h->h_field,
					     denlstring(buf, false, true));
		}
		else if (bitset(H_FROM|H_RCPT, h->h_flags) &&
			 !bitset(H_BINDLATE, h->h_flags))
		{
			bool oldstyle = bitset(EF_OLDSTYLE, e->e_flags);
			SM_FILE_T *savetrace = TrafficLogFile;

			TrafficLogFile = NULL;

			if (bitset(H_FROM, h->h_flags))
				oldstyle = false;
			commaize(h, h->h_value, oldstyle, &mcibuf, e,
				 PXLF_HEADER);

			TrafficLogFile = savetrace;
		}
		else
		{
			(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "%s:%s\n",
					     h->h_field,
					     denlstring(h->h_value, false,
							true));
		}
	}

	/*
	**  Clean up.
	**
	**	Write a terminator record -- this is to prevent
	**	scurrilous crackers from appending any data.
	*/

	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, ".\n");

	if (sm_io_flush(tfp, SM_TIME_DEFAULT) != 0 ||
	    ((SuperSafe == SAFE_REALLY ||
	      SuperSafe == SAFE_REALLY_POSTMILTER ||
	      (SuperSafe == SAFE_INTERACTIVE && msync)) &&
	     fsync(sm_io_getinfo(tfp, SM_IO_WHAT_FD, NULL)) < 0) ||
	    sm_io_error(tfp))
	{
		if (newid)
			syserr("!552 Error writing control file %s", tf);
		else
			syserr("!452 Error writing control file %s", tf);
	}

	if (!newid)
	{
		char new = queue_letter(e, ANYQFL_LETTER);

		/* rename (locked) tf to be (locked) [qh]f */
		(void) sm_strlcpy(qf, queuename(e, ANYQFL_LETTER),
				  sizeof(qf));
		if (rename(tf, qf) < 0)
			syserr("cannot rename(%s, %s), uid=%d",
				tf, qf, (int) geteuid());
		else
		{
			/*
			**  Check if type has changed and only
			**  remove the old item if the rename above
			**  succeeded.
			*/

			if (e->e_qfletter != '\0' &&
			    e->e_qfletter != new)
			{
				if (tTd(40, 5))
				{
					sm_dprintf("type changed from %c to %c\n",
						   e->e_qfletter, new);
				}

				if (unlink(queuename(e, e->e_qfletter)) < 0)
				{
					/* XXX: something more drastic? */
					if (LogLevel > 0)
						sm_syslog(LOG_ERR, e->e_id,
							  "queueup: unlink(%s) failed: %s",
							  queuename(e, e->e_qfletter),
							  sm_errstring(errno));
				}
			}
		}
		e->e_qfletter = new;

		/*
		**  fsync() after renaming to make sure metadata is
		**  written to disk on filesystems in which renames are
		**  not guaranteed.
		*/

		if (SuperSafe != SAFE_NO)
		{
			/* for softupdates */
			if (tfd >= 0 && fsync(tfd) < 0)
			{
				syserr("!queueup: cannot fsync queue temp file %s",
				       tf);
			}
			SYNC_DIR(qf, true);
		}

		/* close and unlock old (locked) queue file */
		if (e->e_lockfp != NULL)
			(void) sm_io_close(e->e_lockfp, SM_TIME_DEFAULT);
		e->e_lockfp = tfp;

		/* save log info */
		if (LogLevel > 79)
			sm_syslog(LOG_DEBUG, e->e_id, "queueup %s", qf);
	}
	else
	{
		/* save log info */
		if (LogLevel > 79)
			sm_syslog(LOG_DEBUG, e->e_id, "queueup %s", tf);

		e->e_qfletter = queue_letter(e, ANYQFL_LETTER);
	}

	errno = 0;
	e->e_flags |= EF_INQUEUE;

	if (tTd(40, 1))
		sm_dprintf("<<<<< done queueing %s <<<<<\n\n", e->e_id);
	return;
}

/*
**  PRINTCTLADDR -- print control address to file.
**
**	Parameters:
**		a -- address.
**		tfp -- file pointer.
**
**	Returns:
**		none.
**
**	Side Effects:
**		The control address (if changed) is printed to the file.
**		The last control address and uid are saved.
*/

static void
printctladdr(a, tfp)
	register ADDRESS *a;
	SM_FILE_T *tfp;
{
	char *user;
	register ADDRESS *q;
	uid_t uid;
	gid_t gid;
	static ADDRESS *lastctladdr = NULL;
	static uid_t lastuid;

	/* initialization */
	if (a == NULL || a->q_alias == NULL || tfp == NULL)
	{
		if (lastctladdr != NULL && tfp != NULL)
			(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "C\n");
		lastctladdr = NULL;
		lastuid = 0;
		return;
	}

	/* find the active uid */
	q = getctladdr(a);
	if (q == NULL)
	{
		user = NULL;
		uid = 0;
		gid = 0;
	}
	else
	{
		user = q->q_ruser != NULL ? q->q_ruser : q->q_user;
		uid = q->q_uid;
		gid = q->q_gid;
	}
	a = a->q_alias;

	/* check to see if this is the same as last time */
	if (lastctladdr != NULL && uid == lastuid &&
	    strcmp(lastctladdr->q_paddr, a->q_paddr) == 0)
		return;
	lastuid = uid;
	lastctladdr = a;

	if (uid == 0 || user == NULL || user[0] == '\0')
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "C");
	else
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "C%s:%ld:%ld",
				     denlstring(user, true, false), (long) uid,
				     (long) gid);
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, ":%s\n",
			     denlstring(a->q_paddr, true, false));
}

/*
**  RUNNERS_SIGTERM -- propagate a SIGTERM to queue runner process
**
**	This propagates the signal to the child processes that are queue
**	runners. This is for a queue runner "cleanup". After all of the
**	child queue runner processes are signaled (it should be SIGTERM
**	being the sig) then the old signal handler (Oldsh) is called
**	to handle any cleanup set for this process (provided it is not
**	SIG_DFL or SIG_IGN). The signal may not be handled immediately
**	if the BlockOldsh flag is set. If the current process doesn't
**	have a parent then handle the signal immediately, regardless of
**	BlockOldsh.
**
**	Parameters:
**		sig -- the signal number being sent
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets the NoMoreRunners boolean to true to stop more runners
**		from being started in runqueue().
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

static bool		volatile NoMoreRunners = false;
static sigfunc_t	Oldsh_term = SIG_DFL;
static sigfunc_t	Oldsh_hup = SIG_DFL;
static sigfunc_t	volatile Oldsh = SIG_DFL;
static bool		BlockOldsh = false;
static int		volatile Oldsig = 0;
static SIGFUNC_DECL	runners_sigterm __P((int));
static SIGFUNC_DECL	runners_sighup __P((int));

static SIGFUNC_DECL
runners_sigterm(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, runners_sigterm);
	errno = save_errno;
	CHECK_CRITICAL(sig);
	NoMoreRunners = true;
	Oldsh = Oldsh_term;
	Oldsig = sig;
	proc_list_signal(PROC_QUEUE, sig);

	if (!BlockOldsh || getppid() <= 1)
	{
		/* Check that a valid 'old signal handler' is callable */
		if (Oldsh_term != SIG_DFL && Oldsh_term != SIG_IGN &&
		    Oldsh_term != runners_sigterm)
			(*Oldsh_term)(sig);
	}
	errno = save_errno;
	return SIGFUNC_RETURN;
}
/*
**  RUNNERS_SIGHUP -- propagate a SIGHUP to queue runner process
**
**	This propagates the signal to the child processes that are queue
**	runners. This is for a queue runner "cleanup". After all of the
**	child queue runner processes are signaled (it should be SIGHUP
**	being the sig) then the old signal handler (Oldsh) is called to
**	handle any cleanup set for this process (provided it is not SIG_DFL
**	or SIG_IGN). The signal may not be handled immediately if the
**	BlockOldsh flag is set. If the current process doesn't have
**	a parent then handle the signal immediately, regardless of
**	BlockOldsh.
**
**	Parameters:
**		sig -- the signal number being sent
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets the NoMoreRunners boolean to true to stop more runners
**		from being started in runqueue().
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

static SIGFUNC_DECL
runners_sighup(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, runners_sighup);
	errno = save_errno;
	CHECK_CRITICAL(sig);
	NoMoreRunners = true;
	Oldsh = Oldsh_hup;
	Oldsig = sig;
	proc_list_signal(PROC_QUEUE, sig);

	if (!BlockOldsh || getppid() <= 1)
	{
		/* Check that a valid 'old signal handler' is callable */
		if (Oldsh_hup != SIG_DFL && Oldsh_hup != SIG_IGN &&
		    Oldsh_hup != runners_sighup)
			(*Oldsh_hup)(sig);
	}
	errno = save_errno;
	return SIGFUNC_RETURN;
}
/*
**  MARK_WORK_GROUP_RESTART -- mark a work group as needing a restart
**
**  Sets a workgroup for restarting.
**
**	Parameters:
**		wgrp -- the work group id to restart.
**		reason -- why (signal?), -1 to turn off restart
**
**	Returns:
**		none.
**
**	Side effects:
**		May set global RestartWorkGroup to true.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

void
mark_work_group_restart(wgrp, reason)
	int wgrp;
	int reason;
{
	if (wgrp < 0 || wgrp > NumWorkGroups)
		return;

	WorkGrp[wgrp].wg_restart = reason;
	if (reason >= 0)
		RestartWorkGroup = true;
}
/*
**  RESTART_MARKED_WORK_GROUPS -- restart work groups marked as needing restart
**
**  Restart any workgroup marked as needing a restart provided more
**  runners are allowed.
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side effects:
**		Sets global RestartWorkGroup to false.
*/

void
restart_marked_work_groups()
{
	int i;
	int wasblocked;

	if (NoMoreRunners)
		return;

	/* Block SIGCHLD so reapchild() doesn't mess with us */
	wasblocked = sm_blocksignal(SIGCHLD);

	for (i = 0; i < NumWorkGroups; i++)
	{
		if (WorkGrp[i].wg_restart >= 0)
		{
			if (LogLevel > 8)
				sm_syslog(LOG_ERR, NOQID,
					  "restart queue runner=%d due to signal 0x%x",
					  i, WorkGrp[i].wg_restart);
			restart_work_group(i);
		}
	}
	RestartWorkGroup = false;

	if (wasblocked == 0)
		(void) sm_releasesignal(SIGCHLD);
}
/*
**  RESTART_WORK_GROUP -- restart a specific work group
**
**  Restart a specific workgroup provided more runners are allowed.
**  If the requested work group has been restarted too many times log
**  this and refuse to restart.
**
**	Parameters:
**		wgrp -- the work group id to restart
**
**	Returns:
**		none.
**
**	Side Effects:
**		starts another process doing the work of wgrp
*/

#define MAX_PERSIST_RESTART	10	/* max allowed number of restarts */

static void
restart_work_group(wgrp)
	int wgrp;
{
	if (NoMoreRunners ||
	    wgrp < 0 || wgrp > NumWorkGroups)
		return;

	WorkGrp[wgrp].wg_restart = -1;
	if (WorkGrp[wgrp].wg_restartcnt < MAX_PERSIST_RESTART)
	{
		/* avoid overflow; increment here */
		WorkGrp[wgrp].wg_restartcnt++;
		(void) run_work_group(wgrp, RWG_FORK|RWG_PERSISTENT|RWG_RUNALL);
	}
	else
	{
		sm_syslog(LOG_ERR, NOQID,
			  "ERROR: persistent queue runner=%d restarted too many times, queue runner lost",
			  wgrp);
	}
}
/*
**  SCHEDULE_QUEUE_RUNS -- schedule the next queue run for a work group.
**
**	Parameters:
**		runall -- schedule even if individual bit is not set.
**		wgrp -- the work group id to schedule.
**		didit -- the queue run was performed for this work group.
**
**	Returns:
**		nothing
*/

#define INCR_MOD(v, m)	if (++v >= m)	\
				v = 0;	\
			else

static void
schedule_queue_runs(runall, wgrp, didit)
	bool runall;
	int wgrp;
	bool didit;
{
	int qgrp, cgrp, endgrp;
#if _FFR_QUEUE_SCHED_DBG
	time_t lastsched;
	bool sched;
#endif /* _FFR_QUEUE_SCHED_DBG */
	time_t now;
	time_t minqintvl;

	/*
	**  This is a bit ugly since we have to duplicate the
	**  code that "walks" through a work queue group.
	*/

	now = curtime();
	minqintvl = 0;
	cgrp = endgrp = WorkGrp[wgrp].wg_curqgrp;
	do
	{
		time_t qintvl;

#if _FFR_QUEUE_SCHED_DBG
		lastsched = 0;
		sched = false;
#endif /* _FFR_QUEUE_SCHED_DBG */
		qgrp = WorkGrp[wgrp].wg_qgs[cgrp]->qg_index;
		if (Queue[qgrp]->qg_queueintvl > 0)
			qintvl = Queue[qgrp]->qg_queueintvl;
		else if (QueueIntvl > 0)
			qintvl = QueueIntvl;
		else
			qintvl = (time_t) 0;
#if _FFR_QUEUE_SCHED_DBG
		lastsched = Queue[qgrp]->qg_nextrun;
#endif /* _FFR_QUEUE_SCHED_DBG */
		if ((runall || Queue[qgrp]->qg_nextrun <= now) && qintvl > 0)
		{
#if _FFR_QUEUE_SCHED_DBG
			sched = true;
#endif /* _FFR_QUEUE_SCHED_DBG */
			if (minqintvl == 0 || qintvl < minqintvl)
				minqintvl = qintvl;

			/*
			**  Only set a new time if a queue run was performed
			**  for this queue group.  If the queue was not run,
			**  we could starve it by setting a new time on each
			**  call.
			*/

			if (didit)
				Queue[qgrp]->qg_nextrun += qintvl;
		}
#if _FFR_QUEUE_SCHED_DBG
		if (tTd(69, 10))
			sm_syslog(LOG_INFO, NOQID,
				"sqr: wgrp=%d, cgrp=%d, qgrp=%d, intvl=%ld, QI=%ld, runall=%d, lastrun=%ld, nextrun=%ld, sched=%d",
				wgrp, cgrp, qgrp, Queue[qgrp]->qg_queueintvl,
				QueueIntvl, runall, lastsched,
				Queue[qgrp]->qg_nextrun, sched);
#endif /* _FFR_QUEUE_SCHED_DBG */
		INCR_MOD(cgrp, WorkGrp[wgrp].wg_numqgrp);
	} while (endgrp != cgrp);
	if (minqintvl > 0)
		(void) sm_setevent(minqintvl, runqueueevent, 0);
}

#if _FFR_QUEUE_RUN_PARANOIA
/*
**  CHECKQUEUERUNNER -- check whether a queue group hasn't been run.
**
**	Use this if events may get lost and hence queue runners may not
**	be started and mail will pile up in a queue.
**
**	Parameters:
**		none.
**
**	Returns:
**		true if a queue run is necessary.
**
**	Side Effects:
**		may schedule a queue run.
*/

bool
checkqueuerunner()
{
	int qgrp;
	time_t now, minqintvl;

	now = curtime();
	minqintvl = 0;
	for (qgrp = 0; qgrp < NumQueue && Queue[qgrp] != NULL; qgrp++)
	{
		time_t qintvl;

		if (Queue[qgrp]->qg_queueintvl > 0)
			qintvl = Queue[qgrp]->qg_queueintvl;
		else if (QueueIntvl > 0)
			qintvl = QueueIntvl;
		else
			qintvl = (time_t) 0;
		if (Queue[qgrp]->qg_nextrun <= now - qintvl)
		{
			if (minqintvl == 0 || qintvl < minqintvl)
				minqintvl = qintvl;
			if (LogLevel > 1)
				sm_syslog(LOG_WARNING, NOQID,
					"checkqueuerunner: queue %d should have been run at %s, queue interval %ld",
					qgrp,
					arpadate(ctime(&Queue[qgrp]->qg_nextrun)),
					qintvl);
		}
	}
	if (minqintvl > 0)
	{
		(void) sm_setevent(minqintvl, runqueueevent, 0);
		return true;
	}
	return false;
}
#endif /* _FFR_QUEUE_RUN_PARANOIA */

/*
**  RUNQUEUE -- run the jobs in the queue.
**
**	Gets the stuff out of the queue in some presumably logical
**	order and processes them.
**
**	Parameters:
**		forkflag -- true if the queue scanning should be done in
**			a child process.  We double-fork so it is not our
**			child and we don't have to clean up after it.
**			false can be ignored if we have multiple queues.
**		verbose -- if true, print out status information.
**		persistent -- persistent queue runner?
**		runall -- run all groups or only a subset (DoQueueRun)?
**
**	Returns:
**		true if the queue run successfully began.
**
**	Side Effects:
**		runs things in the mail queue using run_work_group().
**		maybe schedules next queue run.
*/

static ENVELOPE	QueueEnvelope;		/* the queue run envelope */
static time_t	LastQueueTime = 0;	/* last time a queue ID assigned */
static pid_t	LastQueuePid = -1;	/* last PID which had a queue ID */

/* values for qp_supdirs */
#define QP_NOSUB	0x0000	/* No subdirectories */
#define QP_SUBDF	0x0001	/* "df" subdirectory */
#define QP_SUBQF	0x0002	/* "qf" subdirectory */
#define QP_SUBXF	0x0004	/* "xf" subdirectory */

bool
runqueue(forkflag, verbose, persistent, runall)
	bool forkflag;
	bool verbose;
	bool persistent;
	bool runall;
{
	int i;
	bool ret = true;
	static int curnum = 0;
	sigfunc_t cursh;
#if SM_HEAP_CHECK
	SM_NONVOLATILE int oldgroup = 0;

	if (sm_debug_active(&DebugLeakQ, 1))
	{
		oldgroup = sm_heap_group();
		sm_heap_newgroup();
		sm_dprintf("runqueue() heap group #%d\n", sm_heap_group());
	}
#endif /* SM_HEAP_CHECK */

	/* queue run has been started, don't do any more this time */
	DoQueueRun = false;

	/* more than one queue or more than one directory per queue */
	if (!forkflag && !verbose &&
	    (WorkGrp[0].wg_qgs[0]->qg_numqueues > 1 || NumWorkGroups > 1 ||
	     WorkGrp[0].wg_numqgrp > 1))
		forkflag = true;

	/*
	**  For controlling queue runners via signals sent to this process.
	**  Oldsh* will get called too by runners_sig* (if it is not SIG_IGN
	**  or SIG_DFL) to preserve cleanup behavior. Now that this process
	**  will have children (and perhaps grandchildren) this handler will
	**  be left in place. This is because this process, once it has
	**  finished spinning off queue runners, may go back to doing something
	**  else (like being a daemon). And we still want on a SIG{TERM,HUP} to
	**  clean up the child queue runners. Only install 'runners_sig*' once
	**  else we'll get stuck looping forever.
	*/

	cursh = sm_signal(SIGTERM, runners_sigterm);
	if (cursh != runners_sigterm)
		Oldsh_term = cursh;
	cursh = sm_signal(SIGHUP, runners_sighup);
	if (cursh != runners_sighup)
		Oldsh_hup = cursh;

	for (i = 0; i < NumWorkGroups && !NoMoreRunners; i++)
	{
		int rwgflags = RWG_NONE;
		int wasblocked;

		/*
		**  If MaxQueueChildren active then test whether the start
		**  of the next queue group's additional queue runners (maximum)
		**  will result in MaxQueueChildren being exceeded.
		**
		**  Note: do not use continue; even though another workgroup
		**	may have fewer queue runners, this would be "unfair",
		**	i.e., this work group might "starve" then.
		*/

#if _FFR_QUEUE_SCHED_DBG
		if (tTd(69, 10))
			sm_syslog(LOG_INFO, NOQID,
				"rq: curnum=%d, MaxQueueChildren=%d, CurRunners=%d, WorkGrp[curnum].wg_maxact=%d",
				curnum, MaxQueueChildren, CurRunners,
				WorkGrp[curnum].wg_maxact);
#endif /* _FFR_QUEUE_SCHED_DBG */
		if (MaxQueueChildren > 0 &&
		    CurRunners + WorkGrp[curnum].wg_maxact > MaxQueueChildren)
			break;

		/*
		**  Pick up where we left off (curnum), in case we
		**  used up all the children last time without finishing.
		**  This give a round-robin fairness to queue runs.
		**
		**  Increment CurRunners before calling run_work_group()
		**  to avoid a "race condition" with proc_list_drop() which
		**  decrements CurRunners if the queue runners terminate.
		**  Notice: CurRunners is an upper limit, in some cases
		**  (too few jobs in the queue) this value is larger than
		**  the actual number of queue runners. The discrepancy can
		**  increase if some queue runners "hang" for a long time.
		*/

		/* don't let proc_list_drop() change CurRunners */
		wasblocked = sm_blocksignal(SIGCHLD);
		CurRunners += WorkGrp[curnum].wg_maxact;
		if (wasblocked == 0)
			(void) sm_releasesignal(SIGCHLD);
		if (forkflag)
			rwgflags |= RWG_FORK;
		if (verbose)
			rwgflags |= RWG_VERBOSE;
		if (persistent)
			rwgflags |= RWG_PERSISTENT;
		if (runall)
			rwgflags |= RWG_RUNALL;
		ret = run_work_group(curnum, rwgflags);

		/*
		**  Failure means a message was printed for ETRN
		**  and subsequent queues are likely to fail as well.
		**  Decrement CurRunners in that case because
		**  none have been started.
		*/

		if (!ret)
		{
			/* don't let proc_list_drop() change CurRunners */
			wasblocked = sm_blocksignal(SIGCHLD);
			CurRunners -= WorkGrp[curnum].wg_maxact;
			CHK_CUR_RUNNERS("runqueue", curnum,
					WorkGrp[curnum].wg_maxact);
			if (wasblocked == 0)
				(void) sm_releasesignal(SIGCHLD);
			break;
		}

		if (!persistent)
			schedule_queue_runs(runall, curnum, true);
		INCR_MOD(curnum, NumWorkGroups);
	}

	/* schedule left over queue runs */
	if (i < NumWorkGroups && !NoMoreRunners && !persistent)
	{
		int h;

		for (h = curnum; i < NumWorkGroups; i++)
		{
			schedule_queue_runs(runall, h, false);
			INCR_MOD(h, NumWorkGroups);
		}
	}


#if SM_HEAP_CHECK
	if (sm_debug_active(&DebugLeakQ, 1))
		sm_heap_setgroup(oldgroup);
#endif /* SM_HEAP_CHECK */
	return ret;
}

#if _FFR_SKIP_DOMAINS
/*
**  SKIP_DOMAINS -- Skip 'skip' number of domains in the WorkQ.
**
**  Added by Stephen Frost <sfrost@@snowman.net> to support
**  having each runner process every N'th domain instead of
**  every N'th message.
**
**	Parameters:
**		skip -- number of domains in WorkQ to skip.
**
**	Returns:
**		total number of messages skipped.
**
**	Side Effects:
**		may change WorkQ
*/

static int
skip_domains(skip)
	int skip;
{
	int n, seqjump;

	for (n = 0, seqjump = 0; n < skip && WorkQ != NULL; seqjump++)
	{
		if (WorkQ->w_next != NULL)
		{
			if (WorkQ->w_host != NULL &&
			    WorkQ->w_next->w_host != NULL)
			{
				if (sm_strcasecmp(WorkQ->w_host,
						WorkQ->w_next->w_host) != 0)
					n++;
			}
			else
			{
				if ((WorkQ->w_host != NULL &&
				     WorkQ->w_next->w_host == NULL) ||
				    (WorkQ->w_host == NULL &&
				     WorkQ->w_next->w_host != NULL))
					     n++;
			}
		}
		WorkQ = WorkQ->w_next;
	}
	return seqjump;
}
#endif /* _FFR_SKIP_DOMAINS */

/*
**  RUNNER_WORK -- have a queue runner do its work
**
**  Have a queue runner do its work a list of entries.
**  When work isn't directly being done then this process can take a signal
**  and terminate immediately (in a clean fashion of course).
**  When work is directly being done, it's not to be interrupted
**  immediately: the work should be allowed to finish at a clean point
**  before termination (in a clean fashion of course).
**
**	Parameters:
**		e -- envelope.
**		sequenceno -- 'th process to run WorkQ.
**		didfork -- did the calling process fork()?
**		skip -- process only each skip'th item.
**		njobs -- number of jobs in WorkQ.
**
**	Returns:
**		none.
**
**	Side Effects:
**		runs things in the mail queue.
*/

static void
runner_work(e, sequenceno, didfork, skip, njobs)
	register ENVELOPE *e;
	int sequenceno;
	bool didfork;
	int skip;
	int njobs;
{
	int n, seqjump;
	WORK *w;
	time_t now;

	SM_GET_LA(now);

	/*
	**  Here we temporarily block the second calling of the handlers.
	**  This allows us to handle the signal without terminating in the
	**  middle of direct work. If a signal does come, the test for
	**  NoMoreRunners will find it.
	*/

	BlockOldsh = true;
	seqjump = skip;

	/* process them once at a time */
	while (WorkQ != NULL)
	{
#if SM_HEAP_CHECK
		SM_NONVOLATILE int oldgroup = 0;

		if (sm_debug_active(&DebugLeakQ, 1))
		{
			oldgroup = sm_heap_group();
			sm_heap_newgroup();
			sm_dprintf("run_queue_group() heap group #%d\n",
				sm_heap_group());
		}
#endif /* SM_HEAP_CHECK */

		/* do no more work */
		if (NoMoreRunners)
		{
			/* Check that a valid signal handler is callable */
			if (Oldsh != SIG_DFL && Oldsh != SIG_IGN &&
			    Oldsh != runners_sighup &&
			    Oldsh != runners_sigterm)
				(*Oldsh)(Oldsig);
			break;
		}

		w = WorkQ; /* assign current work item */

		/*
		**  Set the head of the WorkQ to the next work item.
		**  It is set 'skip' ahead (the number of parallel queue
		**  runners working on WorkQ together) since each runner
		**  works on every 'skip'th (N-th) item.
#if _FFR_SKIP_DOMAINS
		**  In the case of the BYHOST Queue Sort Order, the 'item'
		**  is a domain, so we work on every 'skip'th (N-th) domain.
#endif * _FFR_SKIP_DOMAINS *
		*/

#if _FFR_SKIP_DOMAINS
		if (QueueSortOrder == QSO_BYHOST)
		{
			seqjump = 1;
			if (WorkQ->w_next != NULL)
			{
				if (WorkQ->w_host != NULL &&
				    WorkQ->w_next->w_host != NULL)
				{
					if (sm_strcasecmp(WorkQ->w_host,
							WorkQ->w_next->w_host)
								!= 0)
						seqjump = skip_domains(skip);
					else
						WorkQ = WorkQ->w_next;
				}
				else
				{
					if ((WorkQ->w_host != NULL &&
					     WorkQ->w_next->w_host == NULL) ||
					    (WorkQ->w_host == NULL &&
					     WorkQ->w_next->w_host != NULL))
						seqjump = skip_domains(skip);
					else
						WorkQ = WorkQ->w_next;
				}
			}
			else
				WorkQ = WorkQ->w_next;
		}
		else
#endif /* _FFR_SKIP_DOMAINS */
		{
			for (n = 0; n < skip && WorkQ != NULL; n++)
				WorkQ = WorkQ->w_next;
		}

		e->e_to = NULL;

		/*
		**  Ignore jobs that are too expensive for the moment.
		**
		**	Get new load average every GET_NEW_LA_TIME seconds.
		*/

		SM_GET_LA(now);
		if (shouldqueue(WkRecipFact, Current_LA_time))
		{
			char *msg = "Aborting queue run: load average too high";

			if (Verbose)
				message("%s", msg);
			if (LogLevel > 8)
				sm_syslog(LOG_INFO, NOQID, "runqueue: %s", msg);
			break;
		}
		if (shouldqueue(w->w_pri, w->w_ctime))
		{
			if (Verbose)
				message(EmptyString);
			if (QueueSortOrder == QSO_BYPRIORITY)
			{
				if (Verbose)
					message("Skipping %s/%s (sequence %d of %d) and flushing rest of queue",
						qid_printqueue(w->w_qgrp,
							       w->w_qdir),
						w->w_name + 2, sequenceno,
						njobs);
				if (LogLevel > 8)
					sm_syslog(LOG_INFO, NOQID,
						  "runqueue: Flushing queue from %s/%s (pri %ld, LA %d, %d of %d)",
						  qid_printqueue(w->w_qgrp,
								 w->w_qdir),
						  w->w_name + 2, w->w_pri,
						  CurrentLA, sequenceno,
						  njobs);
				break;
			}
			else if (Verbose)
				message("Skipping %s/%s (sequence %d of %d)",
					qid_printqueue(w->w_qgrp, w->w_qdir),
					w->w_name + 2, sequenceno, njobs);
		}
		else
		{
			if (Verbose)
			{
				message(EmptyString);
				message("Running %s/%s (sequence %d of %d)",
					qid_printqueue(w->w_qgrp, w->w_qdir),
					w->w_name + 2, sequenceno, njobs);
			}
			if (didfork && MaxQueueChildren > 0)
			{
				sm_blocksignal(SIGCHLD);
				(void) sm_signal(SIGCHLD, reapchild);
			}
			if (tTd(63, 100))
				sm_syslog(LOG_DEBUG, NOQID,
					  "runqueue %s dowork(%s)",
					  qid_printqueue(w->w_qgrp, w->w_qdir),
					  w->w_name + 2);

			(void) dowork(w->w_qgrp, w->w_qdir, w->w_name + 2,
				      ForkQueueRuns, false, e);
			errno = 0;
		}
		sm_free(w->w_name); /* XXX */
		if (w->w_host != NULL)
			sm_free(w->w_host); /* XXX */
		sm_free((char *) w); /* XXX */
		sequenceno += seqjump; /* next sequence number */
#if SM_HEAP_CHECK
		if (sm_debug_active(&DebugLeakQ, 1))
			sm_heap_setgroup(oldgroup);
#endif /* SM_HEAP_CHECK */
	}

	BlockOldsh = false;

	/* check the signals didn't happen during the revert */
	if (NoMoreRunners)
	{
		/* Check that a valid signal handler is callable */
		if (Oldsh != SIG_DFL && Oldsh != SIG_IGN &&
		    Oldsh != runners_sighup && Oldsh != runners_sigterm)
			(*Oldsh)(Oldsig);
	}

	Oldsh = SIG_DFL; /* after the NoMoreRunners check */
}
/*
**  RUN_WORK_GROUP -- run the jobs in a queue group from a work group.
**
**	Gets the stuff out of the queue in some presumably logical
**	order and processes them.
**
**	Parameters:
**		wgrp -- work group to process.
**		flags -- RWG_* flags
**
**	Returns:
**		true if the queue run successfully began.
**
**	Side Effects:
**		runs things in the mail queue.
*/

/* Minimum sleep time for persistent queue runners */
#define MIN_SLEEP_TIME	5

bool
run_work_group(wgrp, flags)
	int wgrp;
	int flags;
{
	register ENVELOPE *e;
	int njobs, qdir;
	int sequenceno = 1;
	int qgrp, endgrp, h, i;
	time_t now;
	bool full, more;
	SM_RPOOL_T *rpool;
	extern ENVELOPE BlankEnvelope;
	extern SIGFUNC_DECL reapchild __P((int));

	if (wgrp < 0)
		return false;

	/*
	**  If no work will ever be selected, don't even bother reading
	**  the queue.
	*/

	SM_GET_LA(now);

	if (!bitset(RWG_PERSISTENT, flags) &&
	    shouldqueue(WkRecipFact, Current_LA_time))
	{
		char *msg = "Skipping queue run -- load average too high";

		if (bitset(RWG_VERBOSE, flags))
			message("458 %s\n", msg);
		if (LogLevel > 8)
			sm_syslog(LOG_INFO, NOQID, "runqueue: %s", msg);
		return false;
	}

	/*
	**  See if we already have too many children.
	*/

	if (bitset(RWG_FORK, flags) &&
	    WorkGrp[wgrp].wg_lowqintvl > 0 &&
	    !bitset(RWG_PERSISTENT, flags) &&
	    MaxChildren > 0 && CurChildren >= MaxChildren)
	{
		char *msg = "Skipping queue run -- too many children";

		if (bitset(RWG_VERBOSE, flags))
			message("458 %s (%d)\n", msg, CurChildren);
		if (LogLevel > 8)
			sm_syslog(LOG_INFO, NOQID, "runqueue: %s (%d)",
				  msg, CurChildren);
		return false;
	}

	/*
	**  See if we want to go off and do other useful work.
	*/

	if (bitset(RWG_FORK, flags))
	{
		pid_t pid;

		(void) sm_blocksignal(SIGCHLD);
		(void) sm_signal(SIGCHLD, reapchild);

		pid = dofork();
		if (pid == -1)
		{
			const char *msg = "Skipping queue run -- fork() failed";
			const char *err = sm_errstring(errno);

			if (bitset(RWG_VERBOSE, flags))
				message("458 %s: %s\n", msg, err);
			if (LogLevel > 8)
				sm_syslog(LOG_INFO, NOQID, "runqueue: %s: %s",
					  msg, err);
			(void) sm_releasesignal(SIGCHLD);
			return false;
		}
		if (pid != 0)
		{
			/* parent -- pick up intermediate zombie */
			(void) sm_blocksignal(SIGALRM);

			/* wgrp only used when queue runners are persistent */
			proc_list_add(pid, "Queue runner", PROC_QUEUE,
				      WorkGrp[wgrp].wg_maxact,
				      bitset(RWG_PERSISTENT, flags) ? wgrp : -1,
				      NULL);
			(void) sm_releasesignal(SIGALRM);
			(void) sm_releasesignal(SIGCHLD);
			return true;
		}

		/* child -- clean up signals */

		/* Reset global flags */
		RestartRequest = NULL;
		RestartWorkGroup = false;
		ShutdownRequest = NULL;
		PendingSignal = 0;
		CurrentPid = getpid();
		close_sendmail_pid();

		/*
		**  Initialize exception stack and default exception
		**  handler for child process.
		*/

		sm_exc_newthread(fatal_error);
		clrcontrol();
		proc_list_clear();

		/* Add parent process as first child item */
		proc_list_add(CurrentPid, "Queue runner child process",
			      PROC_QUEUE_CHILD, 0, -1, NULL);
		(void) sm_releasesignal(SIGCHLD);
		(void) sm_signal(SIGCHLD, SIG_DFL);
		(void) sm_signal(SIGHUP, SIG_DFL);
		(void) sm_signal(SIGTERM, intsig);
	}

	/*
	**  Release any resources used by the daemon code.
	*/

	clrdaemon();

	/* force it to run expensive jobs */
	NoConnect = false;

	/* drop privileges */
	if (geteuid() == (uid_t) 0)
		(void) drop_privileges(false);

	/*
	**  Create ourselves an envelope
	*/

	CurEnv = &QueueEnvelope;
	rpool = sm_rpool_new_x(NULL);
	e = newenvelope(&QueueEnvelope, CurEnv, rpool);
	e->e_flags = BlankEnvelope.e_flags;
	e->e_parent = NULL;

	/* make sure we have disconnected from parent */
	if (bitset(RWG_FORK, flags))
	{
		disconnect(1, e);
		QuickAbort = false;
	}

	/*
	**  If we are running part of the queue, always ignore stored
	**  host status.
	*/

	if (QueueLimitId != NULL || QueueLimitSender != NULL ||
	    QueueLimitQuarantine != NULL ||
	    QueueLimitRecipient != NULL)
	{
		IgnoreHostStatus = true;
		MinQueueAge = 0;
#if _FFR_EXPDELAY
		MaxQueueAge = 0;
#endif /* _FFR_EXPDELAY */
	}

	/*
	**  Here is where we choose the queue group from the work group.
	**  The caller of the "domorework" label must setup a new envelope.
	*/

	endgrp = WorkGrp[wgrp].wg_curqgrp; /* to not spin endlessly */

  domorework:

	/*
	**  Run a queue group if:
	**  RWG_RUNALL bit is set or the bit for this group is set.
	*/

	now = curtime();
	for (;;)
	{
		/*
		**  Find the next queue group within the work group that
		**  has been marked as needing a run.
		*/

		qgrp = WorkGrp[wgrp].wg_qgs[WorkGrp[wgrp].wg_curqgrp]->qg_index;
		WorkGrp[wgrp].wg_curqgrp++; /* advance */
		WorkGrp[wgrp].wg_curqgrp %= WorkGrp[wgrp].wg_numqgrp; /* wrap */
		if (bitset(RWG_RUNALL, flags) ||
		    (Queue[qgrp]->qg_nextrun <= now &&
		     Queue[qgrp]->qg_nextrun != (time_t) -1))
			break;
		if (endgrp == WorkGrp[wgrp].wg_curqgrp)
		{
			e->e_id = NULL;
			if (bitset(RWG_FORK, flags))
				finis(true, true, ExitStat);
			return true; /* we're done */
		}
	}

	qdir = Queue[qgrp]->qg_curnum; /* round-robin init of queue position */
#if _FFR_QUEUE_SCHED_DBG
	if (tTd(69, 12))
		sm_syslog(LOG_INFO, NOQID,
			"rwg: wgrp=%d, qgrp=%d, qdir=%d, name=%s, curqgrp=%d, numgrps=%d",
			wgrp, qgrp, qdir, qid_printqueue(qgrp, qdir),
			WorkGrp[wgrp].wg_curqgrp, WorkGrp[wgrp].wg_numqgrp);
#endif /* _FFR_QUEUE_SCHED_DBG */

#if HASNICE
	/* tweak niceness of queue runs */
	if (Queue[qgrp]->qg_nice > 0)
		(void) nice(Queue[qgrp]->qg_nice);
#endif /* HASNICE */

	/* XXX running queue group... */
	sm_setproctitle(true, CurEnv, "running queue: %s",
			qid_printqueue(qgrp, qdir));

	if (LogLevel > 69 || tTd(63, 99))
		sm_syslog(LOG_DEBUG, NOQID,
			  "runqueue %s, pid=%d, forkflag=%d",
			  qid_printqueue(qgrp, qdir), (int) CurrentPid,
			  bitset(RWG_FORK, flags));

	/*
	**  Start making passes through the queue.
	**	First, read and sort the entire queue.
	**	Then, process the work in that order.
	**		But if you take too long, start over.
	*/

	for (i = 0; i < Queue[qgrp]->qg_numqueues; i++)
	{
		(void) gatherq(qgrp, qdir, false, &full, &more, &h);
#if SM_CONF_SHM
		if (ShmId != SM_SHM_NO_ID)
			QSHM_ENTRIES(Queue[qgrp]->qg_qpaths[qdir].qp_idx) = h;
#endif /* SM_CONF_SHM */
		/* If there are no more items in this queue advance */
		if (!more)
		{
			/* A round-robin advance */
			qdir++;
			qdir %= Queue[qgrp]->qg_numqueues;
		}

		/* Has the WorkList reached the limit? */
		if (full)
			break; /* don't try to gather more */
	}

	/* order the existing work requests */
	njobs = sortq(Queue[qgrp]->qg_maxlist);
	Queue[qgrp]->qg_curnum = qdir; /* update */


	if (!Verbose && bitnset(QD_FORK, Queue[qgrp]->qg_flags))
	{
		int loop, maxrunners;
		pid_t pid;

		/*
		**  For this WorkQ we want to fork off N children (maxrunners)
		**  at this point. Each child has a copy of WorkQ. Each child
		**  will process every N-th item. The parent will wait for all
		**  of the children to finish before moving on to the next
		**  queue group within the work group. This saves us forking
		**  a new runner-child for each work item.
		**  It's valid for qg_maxqrun == 0 since this may be an
		**  explicit "don't run this queue" setting.
		*/

		maxrunners = Queue[qgrp]->qg_maxqrun;

		/*
		**  If no runners are configured for this group but
		**  the queue is "forced" then lets use 1 runner.
		*/

		if (maxrunners == 0 && bitset(RWG_FORCE, flags))
			maxrunners = 1;

		/* No need to have more runners then there are jobs */
		if (maxrunners > njobs)
			maxrunners = njobs;
		for (loop = 0; loop < maxrunners; loop++)
		{
			/*
			**  Since the delivery may happen in a child and the
			**  parent does not wait, the parent may close the
			**  maps thereby removing any shared memory used by
			**  the map.  Therefore, close the maps now so the
			**  child will dynamically open them if necessary.
			*/

			closemaps(false);

			pid = fork();
			if (pid < 0)
			{
				syserr("run_work_group: cannot fork");
				return false;
			}
			else if (pid > 0)
			{
				/* parent -- clean out connection cache */
				mci_flush(false, NULL);
#if _FFR_SKIP_DOMAINS
				if (QueueSortOrder == QSO_BYHOST)
				{
					sequenceno += skip_domains(1);
				}
				else
#endif /* _FFR_SKIP_DOMAINS */
				{
					/* for the skip */
					WorkQ = WorkQ->w_next;
					sequenceno++;
				}
				proc_list_add(pid, "Queue child runner process",
					      PROC_QUEUE_CHILD, 0, -1, NULL);

				/* No additional work, no additional runners */
				if (WorkQ == NULL)
					break;
			}
			else
			{
				/* child -- Reset global flags */
				RestartRequest = NULL;
				RestartWorkGroup = false;
				ShutdownRequest = NULL;
				PendingSignal = 0;
				CurrentPid = getpid();
				close_sendmail_pid();

				/*
				**  Initialize exception stack and default
				**  exception handler for child process.
				**  When fork()'d the child now has a private
				**  copy of WorkQ at its current position.
				*/

				sm_exc_newthread(fatal_error);

				/*
				**  SMTP processes (whether -bd or -bs) set
				**  SIGCHLD to reapchild to collect
				**  children status.  However, at delivery
				**  time, that status must be collected
				**  by sm_wait() to be dealt with properly
				**  (check success of delivery based
				**  on status code, etc).  Therefore, if we
				**  are an SMTP process, reset SIGCHLD
				**  back to the default so reapchild
				**  doesn't collect status before
				**  sm_wait().
				*/

				if (OpMode == MD_SMTP ||
				    OpMode == MD_DAEMON ||
				    MaxQueueChildren > 0)
				{
					proc_list_clear();
					sm_releasesignal(SIGCHLD);
					(void) sm_signal(SIGCHLD, SIG_DFL);
				}

				/* child -- error messages to the transcript */
				QuickAbort = OnlyOneError = false;
				runner_work(e, sequenceno, true,
					    maxrunners, njobs);

				/* This child is done */
				finis(true, true, ExitStat);
				/* NOTREACHED */
			}
		}

		sm_releasesignal(SIGCHLD);

		/*
		**  Wait until all of the runners have completed before
		**  seeing if there is another queue group in the
		**  work group to process.
		**  XXX Future enhancement: don't wait() for all children
		**  here, just go ahead and make sure that overall the number
		**  of children is not exceeded.
		*/

		while (CurChildren > 0)
		{
			int status;
			pid_t ret;

			while ((ret = sm_wait(&status)) <= 0)
				continue;
			proc_list_drop(ret, status, NULL);
		}
	}
	else if (Queue[qgrp]->qg_maxqrun > 0 || bitset(RWG_FORCE, flags))
	{
		/*
		**  When current process will not fork children to do the work,
		**  it will do the work itself. The 'skip' will be 1 since
		**  there are no child runners to divide the work across.
		*/

		runner_work(e, sequenceno, false, 1, njobs);
	}

	/* free memory allocated by newenvelope() above */
	sm_rpool_free(rpool);
	QueueEnvelope.e_rpool = NULL;

	/* Are there still more queues in the work group to process? */
	if (endgrp != WorkGrp[wgrp].wg_curqgrp)
	{
		rpool = sm_rpool_new_x(NULL);
		e = newenvelope(&QueueEnvelope, CurEnv, rpool);
		e->e_flags = BlankEnvelope.e_flags;
		goto domorework;
	}

	/* No more queues in work group to process. Now check persistent. */
	if (bitset(RWG_PERSISTENT, flags))
	{
		sequenceno = 1;
		sm_setproctitle(true, NULL, "running queue: %s",
				qid_printqueue(qgrp, qdir));

		/*
		**  close bogus maps, i.e., maps which caused a tempfail,
		**	so we get fresh map connections on the next lookup.
		**  closemaps() is also called when children are started.
		*/

		closemaps(true);

		/* Close any cached connections. */
		mci_flush(true, NULL);

		/* Clean out expired related entries. */
		rmexpstab();

#if NAMED_BIND
		/* Update MX records for FallbackMX. */
		if (FallbackMX != NULL)
			(void) getfallbackmxrr(FallbackMX);
#endif /* NAMED_BIND */

#if USERDB
		/* close UserDatabase */
		_udbx_close();
#endif /* USERDB */

#if SM_HEAP_CHECK
		if (sm_debug_active(&SmHeapCheck, 2)
		    && access("memdump", F_OK) == 0
		   )
		{
			SM_FILE_T *out;

			remove("memdump");
			out = sm_io_open(SmFtStdio, SM_TIME_DEFAULT,
					 "memdump.out", SM_IO_APPEND, NULL);
			if (out != NULL)
			{
				(void) sm_io_fprintf(out, SM_TIME_DEFAULT, "----------------------\n");
				sm_heap_report(out,
					sm_debug_level(&SmHeapCheck) - 1);
				(void) sm_io_close(out, SM_TIME_DEFAULT);
			}
		}
#endif /* SM_HEAP_CHECK */

		/* let me rest for a second to catch my breath */
		if (njobs == 0 && WorkGrp[wgrp].wg_lowqintvl < MIN_SLEEP_TIME)
			sleep(MIN_SLEEP_TIME);
		else if (WorkGrp[wgrp].wg_lowqintvl <= 0)
			sleep(QueueIntvl > 0 ? QueueIntvl : MIN_SLEEP_TIME);
		else
			sleep(WorkGrp[wgrp].wg_lowqintvl);

		/*
		**  Get the LA outside the WorkQ loop if necessary.
		**  In a persistent queue runner the code is repeated over
		**  and over but gatherq() may ignore entries due to
		**  shouldqueue() (do we really have to do this twice?).
		**  Hence the queue runners would just idle around when once
		**  CurrentLA caused all entries in a queue to be ignored.
		*/

		if (njobs == 0)
			SM_GET_LA(now);
		rpool = sm_rpool_new_x(NULL);
		e = newenvelope(&QueueEnvelope, CurEnv, rpool);
		e->e_flags = BlankEnvelope.e_flags;
		goto domorework;
	}

	/* exit without the usual cleanup */
	e->e_id = NULL;
	if (bitset(RWG_FORK, flags))
		finis(true, true, ExitStat);
	/* NOTREACHED */
	return true;
}

/*
**  DOQUEUERUN -- do a queue run?
*/

bool
doqueuerun()
{
	return DoQueueRun;
}

/*
**  RUNQUEUEEVENT -- Sets a flag to indicate that a queue run should be done.
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		The invocation of this function via an alarm may interrupt
**		a set of actions. Thus errno may be set in that context.
**		We need to restore errno at the end of this function to ensure
**		that any work done here that sets errno doesn't return a
**		misleading/false errno value. Errno may	be EINTR upon entry to
**		this function because of non-restartable/continuable system
**		API was active. Iff this is true we will override errno as
**		a timeout (as a more accurate error message).
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

void
runqueueevent(ignore)
	int ignore;
{
	int save_errno = errno;

	/*
	**  Set the general bit that we want a queue run,
	**  tested in doqueuerun()
	*/

	DoQueueRun = true;
#if _FFR_QUEUE_SCHED_DBG
	if (tTd(69, 10))
		sm_syslog(LOG_INFO, NOQID, "rqe: done");
#endif /* _FFR_QUEUE_SCHED_DBG */

	errno = save_errno;
	if (errno == EINTR)
		errno = ETIMEDOUT;
}
/*
**  GATHERQ -- gather messages from the message queue(s) the work queue.
**
**	Parameters:
**		qgrp -- the index of the queue group.
**		qdir -- the index of the queue directory.
**		doall -- if set, include everything in the queue (even
**			the jobs that cannot be run because the load
**			average is too high, or MaxQueueRun is reached).
**			Otherwise, exclude those jobs.
**		full -- (optional) to be set 'true' if WorkList is full
**		more -- (optional) to be set 'true' if there are still more
**			messages in this queue not added to WorkList
**		pnentries -- (optional) total nuber of entries in queue
**
**	Returns:
**		The number of request in the queue (not necessarily
**		the number of requests in WorkList however).
**
**	Side Effects:
**		prepares available work into WorkList
*/

#define NEED_P		0001	/* 'P': priority */
#define NEED_T		0002	/* 'T': time */
#define NEED_R		0004	/* 'R': recipient */
#define NEED_S		0010	/* 'S': sender */
#define NEED_H		0020	/* host */
#define HAS_QUARANTINE	0040	/* has an unexpected 'q' line */
#define NEED_QUARANTINE	0100	/* 'q': reason */

static WORK	*WorkList = NULL;	/* list of unsort work */
static int	WorkListSize = 0;	/* current max size of WorkList */
static int	WorkListCount = 0;	/* # of work items in WorkList */

static int
gatherq(qgrp, qdir, doall, full, more, pnentries)
	int qgrp;
	int qdir;
	bool doall;
	bool *full;
	bool *more;
	int *pnentries;
{
	register struct dirent *d;
	register WORK *w;
	register char *p;
	DIR *f;
	int i, num_ent, wn, nentries;
	QUEUE_CHAR *check;
	char qd[MAXPATHLEN];
	char qf[MAXPATHLEN];

	wn = WorkListCount - 1;
	num_ent = 0;
	nentries = 0;
	if (qdir == NOQDIR)
		(void) sm_strlcpy(qd, ".", sizeof(qd));
	else
		(void) sm_strlcpyn(qd, sizeof(qd), 2,
			Queue[qgrp]->qg_qpaths[qdir].qp_name,
			(bitset(QP_SUBQF,
				Queue[qgrp]->qg_qpaths[qdir].qp_subdirs)
					? "/qf" : ""));

	if (tTd(41, 1))
	{
		sm_dprintf("gatherq:\n");

		check = QueueLimitId;
		while (check != NULL)
		{
			sm_dprintf("\tQueueLimitId = %s%s\n",
				check->queue_negate ? "!" : "",
				check->queue_match);
			check = check->queue_next;
		}

		check = QueueLimitSender;
		while (check != NULL)
		{
			sm_dprintf("\tQueueLimitSender = %s%s\n",
				check->queue_negate ? "!" : "",
				check->queue_match);
			check = check->queue_next;
		}

		check = QueueLimitRecipient;
		while (check != NULL)
		{
			sm_dprintf("\tQueueLimitRecipient = %s%s\n",
				check->queue_negate ? "!" : "",
				check->queue_match);
			check = check->queue_next;
		}

		if (QueueMode == QM_QUARANTINE)
		{
			check = QueueLimitQuarantine;
			while (check != NULL)
			{
				sm_dprintf("\tQueueLimitQuarantine = %s%s\n",
					   check->queue_negate ? "!" : "",
					   check->queue_match);
				check = check->queue_next;
			}
		}
	}

	/* open the queue directory */
	f = opendir(qd);
	if (f == NULL)
	{
		syserr("gatherq: cannot open \"%s\"",
			qid_printqueue(qgrp, qdir));
		if (full != NULL)
			*full = WorkListCount >= MaxQueueRun && MaxQueueRun > 0;
		if (more != NULL)
			*more = false;
		return 0;
	}

	/*
	**  Read the work directory.
	*/

	while ((d = readdir(f)) != NULL)
	{
		SM_FILE_T *cf;
		int qfver = 0;
		char lbuf[MAXNAME + 1];
		struct stat sbuf;

		if (tTd(41, 50))
			sm_dprintf("gatherq: checking %s..", d->d_name);

		/* is this an interesting entry? */
		if (!(((QueueMode == QM_NORMAL &&
			d->d_name[0] == NORMQF_LETTER) ||
		       (QueueMode == QM_QUARANTINE &&
			d->d_name[0] == QUARQF_LETTER) ||
		       (QueueMode == QM_LOST &&
			d->d_name[0] == LOSEQF_LETTER)) &&
		      d->d_name[1] == 'f'))
		{
			if (tTd(41, 50))
				sm_dprintf("  skipping\n");
			continue;
		}
		if (tTd(41, 50))
			sm_dprintf("\n");

		if (strlen(d->d_name) >= MAXQFNAME)
		{
			if (Verbose)
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "gatherq: %s too long, %d max characters\n",
						     d->d_name, MAXQFNAME);
			if (LogLevel > 0)
				sm_syslog(LOG_ALERT, NOQID,
					  "gatherq: %s too long, %d max characters",
					  d->d_name, MAXQFNAME);
			continue;
		}

		++nentries;
		check = QueueLimitId;
		while (check != NULL)
		{
			if (strcontainedin(false, check->queue_match,
					   d->d_name) != check->queue_negate)
				break;
			else
				check = check->queue_next;
		}
		if (QueueLimitId != NULL && check == NULL)
			continue;

		/* grow work list if necessary */
		if (++wn >= MaxQueueRun && MaxQueueRun > 0)
		{
			if (wn == MaxQueueRun && LogLevel > 0)
				sm_syslog(LOG_WARNING, NOQID,
					  "WorkList for %s maxed out at %d",
					  qid_printqueue(qgrp, qdir),
					  MaxQueueRun);
			if (doall)
				continue;	/* just count entries */
			break;
		}
		if (wn >= WorkListSize)
		{
			grow_wlist(qgrp, qdir);
			if (wn >= WorkListSize)
				continue;
		}
		SM_ASSERT(wn >= 0);
		w = &WorkList[wn];

		(void) sm_strlcpyn(qf, sizeof(qf), 3, qd, "/", d->d_name);
		if (stat(qf, &sbuf) < 0)
		{
			if (errno != ENOENT)
				sm_syslog(LOG_INFO, NOQID,
					  "gatherq: can't stat %s/%s",
					  qid_printqueue(qgrp, qdir),
					  d->d_name);
			wn--;
			continue;
		}
		if (!bitset(S_IFREG, sbuf.st_mode))
		{
			/* Yikes!  Skip it or we will hang on open! */
			if (!((d->d_name[0] == DATAFL_LETTER ||
			       d->d_name[0] == NORMQF_LETTER ||
			       d->d_name[0] == QUARQF_LETTER ||
			       d->d_name[0] == LOSEQF_LETTER ||
			       d->d_name[0] == XSCRPT_LETTER) &&
			      d->d_name[1] == 'f' && d->d_name[2] == '\0'))
				syserr("gatherq: %s/%s is not a regular file",
				       qid_printqueue(qgrp, qdir), d->d_name);
			wn--;
			continue;
		}

		/* avoid work if possible */
		if ((QueueSortOrder == QSO_BYFILENAME ||
		     QueueSortOrder == QSO_BYMODTIME ||
		     QueueSortOrder == QSO_NONE ||
		     QueueSortOrder == QSO_RANDOM) &&
		    QueueLimitQuarantine == NULL &&
		    QueueLimitSender == NULL &&
		    QueueLimitRecipient == NULL)
		{
			w->w_qgrp = qgrp;
			w->w_qdir = qdir;
			w->w_name = newstr(d->d_name);
			w->w_host = NULL;
			w->w_lock = w->w_tooyoung = false;
			w->w_pri = 0;
			w->w_ctime = 0;
			w->w_mtime = sbuf.st_mtime;
			++num_ent;
			continue;
		}

		/* open control file */
		cf = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, qf, SM_IO_RDONLY_B,
				NULL);
		if (cf == NULL && OpMode != MD_PRINT)
		{
			/* this may be some random person sending hir msgs */
			if (tTd(41, 2))
				sm_dprintf("gatherq: cannot open %s: %s\n",
					d->d_name, sm_errstring(errno));
			errno = 0;
			wn--;
			continue;
		}
		w->w_qgrp = qgrp;
		w->w_qdir = qdir;
		w->w_name = newstr(d->d_name);
		w->w_host = NULL;
		if (cf != NULL)
		{
			w->w_lock = !lockfile(sm_io_getinfo(cf, SM_IO_WHAT_FD,
							    NULL),
					      w->w_name, NULL,
					      LOCK_SH|LOCK_NB);
		}
		w->w_tooyoung = false;

		/* make sure jobs in creation don't clog queue */
		w->w_pri = 0x7fffffff;
		w->w_ctime = 0;
		w->w_mtime = sbuf.st_mtime;

		/* extract useful information */
		i = NEED_P|NEED_T;
		if (QueueSortOrder == QSO_BYHOST
#if _FFR_RHS
		    || QueueSortOrder == QSO_BYSHUFFLE
#endif /* _FFR_RHS */
		   )
		{
			/* need w_host set for host sort order */
			i |= NEED_H;
		}
		if (QueueLimitSender != NULL)
			i |= NEED_S;
		if (QueueLimitRecipient != NULL)
			i |= NEED_R;
		if (QueueLimitQuarantine != NULL)
			i |= NEED_QUARANTINE;
		while (cf != NULL && i != 0 &&
		       sm_io_fgets(cf, SM_TIME_DEFAULT, lbuf,
				   sizeof(lbuf)) >= 0)
		{
			int c;
			time_t age;

			p = strchr(lbuf, '\n');
			if (p != NULL)
				*p = '\0';
			else
			{
				/* flush rest of overly long line */
				while ((c = sm_io_getc(cf, SM_TIME_DEFAULT))
				       != SM_IO_EOF && c != '\n')
					continue;
			}

			switch (lbuf[0])
			{
			  case 'V':
				qfver = atoi(&lbuf[1]);
				break;

			  case 'P':
				w->w_pri = atol(&lbuf[1]);
				i &= ~NEED_P;
				break;

			  case 'T':
				w->w_ctime = atol(&lbuf[1]);
				i &= ~NEED_T;
				break;

			  case 'q':
				if (QueueMode != QM_QUARANTINE &&
				    QueueMode != QM_LOST)
				{
					if (tTd(41, 49))
						sm_dprintf("%s not marked as quarantined but has a 'q' line\n",
							   w->w_name);
					i |= HAS_QUARANTINE;
				}
				else if (QueueMode == QM_QUARANTINE)
				{
					if (QueueLimitQuarantine == NULL)
					{
						i &= ~NEED_QUARANTINE;
						break;
					}
					p = &lbuf[1];
					check = QueueLimitQuarantine;
					while (check != NULL)
					{
						if (strcontainedin(false,
								   check->queue_match,
								   p) !=
						    check->queue_negate)
							break;
						else
							check = check->queue_next;
					}
					if (check != NULL)
						i &= ~NEED_QUARANTINE;
				}
				break;

			  case 'R':
				if (w->w_host == NULL &&
				    (p = strrchr(&lbuf[1], '@@')) != NULL)
				{
#if _FFR_RHS
					if (QueueSortOrder == QSO_BYSHUFFLE)
						w->w_host = newstr(&p[1]);
					else
#endif /* _FFR_RHS */
						w->w_host = strrev(&p[1]);
					makelower(w->w_host);
					i &= ~NEED_H;
				}
				if (QueueLimitRecipient == NULL)
				{
					i &= ~NEED_R;
					break;
				}
				if (qfver > 0)
				{
					p = strchr(&lbuf[1], ':');
					if (p == NULL)
						p = &lbuf[1];
					else
						++p; /* skip over ':' */
				}
				else
					p = &lbuf[1];
				check = QueueLimitRecipient;
				while (check != NULL)
				{
					if (strcontainedin(true,
							   check->queue_match,
							   p) !=
					    check->queue_negate)
						break;
					else
						check = check->queue_next;
				}
				if (check != NULL)
					i &= ~NEED_R;
				break;

			  case 'S':
				check = QueueLimitSender;
				while (check != NULL)
				{
					if (strcontainedin(true,
							   check->queue_match,
							   &lbuf[1]) !=
					    check->queue_negate)
						break;
					else
						check = check->queue_next;
				}
				if (check != NULL)
					i &= ~NEED_S;
				break;

			  case 'K':
#if _FFR_EXPDELAY
				if (MaxQueueAge > 0)
				{
					time_t lasttry, delay;

					lasttry = (time_t) atol(&lbuf[1]);
					delay = MIN(lasttry - w->w_ctime,
						    MaxQueueAge);
					age = curtime() - lasttry;
					if (age < delay)
						w->w_tooyoung = true;
					break;
				}
#endif /* _FFR_EXPDELAY */

				age = curtime() - (time_t) atol(&lbuf[1]);
				if (age >= 0 && MinQueueAge > 0 &&
				    age < MinQueueAge)
					w->w_tooyoung = true;
				break;

			  case 'N':
				if (atol(&lbuf[1]) == 0)
					w->w_tooyoung = false;
				break;
			}
		}
		if (cf != NULL)
			(void) sm_io_close(cf, SM_TIME_DEFAULT);

		if ((!doall && (shouldqueue(w->w_pri, w->w_ctime) ||
		    w->w_tooyoung)) ||
		    bitset(HAS_QUARANTINE, i) ||
		    bitset(NEED_QUARANTINE, i) ||
		    bitset(NEED_R|NEED_S, i))
		{
			/* don't even bother sorting this job in */
			if (tTd(41, 49))
				sm_dprintf("skipping %s (%x)\n", w->w_name, i);
			sm_free(w->w_name); /* XXX */
			if (w->w_host != NULL)
				sm_free(w->w_host); /* XXX */
			wn--;
		}
		else
			++num_ent;
	}
	(void) closedir(f);
	wn++;

	i = wn - WorkListCount;
	WorkListCount += SM_MIN(num_ent, WorkListSize);

	if (more != NULL)
		*more = WorkListCount < wn;

	if (full != NULL)
		*full = (wn >= MaxQueueRun && MaxQueueRun > 0) ||
			(WorkList == NULL && wn > 0);

	if (pnentries != NULL)
		*pnentries = nentries;
	return i;
}
/*
**  SORTQ -- sort the work list
**
**	First the old WorkQ is cleared away. Then the WorkList is sorted
**	for all items so that important (higher sorting value) items are not
**	truncated off. Then the most important items are moved from
**	WorkList to WorkQ. The lower count of 'max' or MaxListCount items
**	are moved.
**
**	Parameters:
**		max -- maximum number of items to be placed in WorkQ
**
**	Returns:
**		the number of items in WorkQ
**
**	Side Effects:
**		WorkQ gets released and filled with new work. WorkList
**		gets released. Work items get sorted in order.
*/

static int
sortq(max)
	int max;
{
	register int i;			/* local counter */
	register WORK *w;		/* tmp item pointer */
	int wc = WorkListCount;		/* trim size for WorkQ */

	if (WorkQ != NULL)
	{
		WORK *nw;

		/* Clear out old WorkQ. */
		for (w = WorkQ; w != NULL; w = nw)
		{
			nw = w->w_next;
			sm_free(w->w_name); /* XXX */
			if (w->w_host != NULL)
				sm_free(w->w_host); /* XXX */
			sm_free((char *) w); /* XXX */
		}
		WorkQ = NULL;
	}

	if (WorkList == NULL || wc <= 0)
		return 0;

	/*
	**  The sort now takes place using all of the items in WorkList.
	**  The list gets trimmed to the most important items after the sort.
	**  If the trim were to happen before the sort then one or more
	**  important items might get truncated off -- not what we want.
	*/

	if (QueueSortOrder == QSO_BYHOST)
	{
		/*
		**  Sort the work directory for the first time,
		**  based on host name, lock status, and priority.
		*/

		qsort((char *) WorkList, wc, sizeof(*WorkList), workcmpf1);

		/*
		**  If one message to host is locked, "lock" all messages
		**  to that host.
		*/

		i = 0;
		while (i < wc)
		{
			if (!WorkList[i].w_lock)
			{
				i++;
				continue;
			}
			w = &WorkList[i];
			while (++i < wc)
			{
				if (WorkList[i].w_host == NULL &&
				    w->w_host == NULL)
					WorkList[i].w_lock = true;
				else if (WorkList[i].w_host != NULL &&
					 w->w_host != NULL &&
					 sm_strcasecmp(WorkList[i].w_host,
						       w->w_host) == 0)
					WorkList[i].w_lock = true;
				else
					break;
			}
		}

		/*
		**  Sort the work directory for the second time,
		**  based on lock status, host name, and priority.
		*/

		qsort((char *) WorkList, wc, sizeof(*WorkList), workcmpf2);
	}
	else if (QueueSortOrder == QSO_BYTIME)
	{
		/*
		**  Simple sort based on submission time only.
		*/

		qsort((char *) WorkList, wc, sizeof(*WorkList), workcmpf3);
	}
	else if (QueueSortOrder == QSO_BYFILENAME)
	{
		/*
		**  Sort based on queue filename.
		*/

		qsort((char *) WorkList, wc, sizeof(*WorkList), workcmpf4);
	}
	else if (QueueSortOrder == QSO_RANDOM)
	{
		/*
		**  Sort randomly.  To avoid problems with an instable sort,
		**  use a random index into the queue file name to start
		**  comparison.
		*/

		randi = get_rand_mod(MAXQFNAME);
		if (randi < 2)
			randi = 3;
		qsort((char *) WorkList, wc, sizeof(*WorkList), workcmpf5);
	}
	else if (QueueSortOrder == QSO_BYMODTIME)
	{
		/*
		**  Simple sort based on modification time of queue file.
		**  This puts the oldest items first.
		*/

		qsort((char *) WorkList, wc, sizeof(*WorkList), workcmpf6);
	}
#if _FFR_RHS
	else if (QueueSortOrder == QSO_BYSHUFFLE)
	{
		/*
		**  Simple sort based on shuffled host name.
		*/

		init_shuffle_alphabet();
		qsort((char *) WorkList, wc, sizeof(*WorkList), workcmpf7);
	}
#endif /* _FFR_RHS */
	else if (QueueSortOrder == QSO_BYPRIORITY)
	{
		/*
		**  Simple sort based on queue priority only.
		*/

		qsort((char *) WorkList, wc, sizeof(*WorkList), workcmpf0);
	}
	/* else don't sort at all */

	/* Check if the per queue group item limit will be exceeded */
	if (wc > max && max > 0)
		wc = max;

	/*
	**  Convert the work list into canonical form.
	**	Should be turning it into a list of envelopes here perhaps.
	**  Only take the most important items up to the per queue group
	**  maximum.
	*/

	for (i = wc; --i >= 0; )
	{
		w = (WORK *) xalloc(sizeof(*w));
		w->w_qgrp = WorkList[i].w_qgrp;
		w->w_qdir = WorkList[i].w_qdir;
		w->w_name = WorkList[i].w_name;
		w->w_host = WorkList[i].w_host;
		w->w_lock = WorkList[i].w_lock;
		w->w_tooyoung = WorkList[i].w_tooyoung;
		w->w_pri = WorkList[i].w_pri;
		w->w_ctime = WorkList[i].w_ctime;
		w->w_mtime = WorkList[i].w_mtime;
		w->w_next = WorkQ;
		WorkQ = w;
	}

	/* free the rest of the list */
	for (i = WorkListCount; --i >= wc; )
	{
		sm_free(WorkList[i].w_name);
		if (WorkList[i].w_host != NULL)
			sm_free(WorkList[i].w_host);
	}

	if (WorkList != NULL)
		sm_free(WorkList); /* XXX */
	WorkList = NULL;
	WorkListSize = 0;
	WorkListCount = 0;

	if (tTd(40, 1))
	{
		for (w = WorkQ; w != NULL; w = w->w_next)
		{
			if (w->w_host != NULL)
				sm_dprintf("%22s: pri=%ld %s\n",
					w->w_name, w->w_pri, w->w_host);
			else
				sm_dprintf("%32s: pri=%ld\n",
					w->w_name, w->w_pri);
		}
	}

	return wc; /* return number of WorkQ items */
}
/*
**  GROW_WLIST -- make the work list larger
**
**	Parameters:
**		qgrp -- the index for the queue group.
**		qdir -- the index for the queue directory.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Adds another QUEUESEGSIZE entries to WorkList if possible.
**		It can fail if there isn't enough memory, so WorkListSize
**		should be checked again upon return.
*/

static void
grow_wlist(qgrp, qdir)
	int qgrp;
	int qdir;
{
	if (tTd(41, 1))
		sm_dprintf("grow_wlist: WorkListSize=%d\n", WorkListSize);
	if (WorkList == NULL)
	{
		WorkList = (WORK *) xalloc((sizeof(*WorkList)) *
					   (QUEUESEGSIZE + 1));
		WorkListSize = QUEUESEGSIZE;
	}
	else
	{
		int newsize = WorkListSize + QUEUESEGSIZE;
		WORK *newlist = (WORK *) sm_realloc((char *) WorkList,
					  (unsigned) sizeof(WORK) * (newsize + 1));

		if (newlist != NULL)
		{
			WorkListSize = newsize;
			WorkList = newlist;
			if (LogLevel > 1)
			{
				sm_syslog(LOG_INFO, NOQID,
					  "grew WorkList for %s to %d",
					  qid_printqueue(qgrp, qdir),
					  WorkListSize);
			}
		}
		else if (LogLevel > 0)
		{
			sm_syslog(LOG_ALERT, NOQID,
				  "FAILED to grow WorkList for %s to %d",
				  qid_printqueue(qgrp, qdir), newsize);
		}
	}
	if (tTd(41, 1))
		sm_dprintf("grow_wlist: WorkListSize now %d\n", WorkListSize);
}
/*
**  WORKCMPF0 -- simple priority-only compare function.
**
**	Parameters:
**		a -- the first argument.
**		b -- the second argument.
**
**	Returns:
**		-1 if a < b
**		 0 if a == b
**		+1 if a > b
**
*/

static int
workcmpf0(a, b)
	register WORK *a;
	register WORK *b;
{
	long pa = a->w_pri;
	long pb = b->w_pri;

	if (pa == pb)
		return 0;
	else if (pa > pb)
		return 1;
	else
		return -1;
}
/*
**  WORKCMPF1 -- first compare function for ordering work based on host name.
**
**	Sorts on host name, lock status, and priority in that order.
**
**	Parameters:
**		a -- the first argument.
**		b -- the second argument.
**
**	Returns:
**		<0 if a < b
**		 0 if a == b
**		>0 if a > b
**
*/

static int
workcmpf1(a, b)
	register WORK *a;
	register WORK *b;
{
	int i;

	/* host name */
	if (a->w_host != NULL && b->w_host == NULL)
		return 1;
	else if (a->w_host == NULL && b->w_host != NULL)
		return -1;
	if (a->w_host != NULL && b->w_host != NULL &&
	    (i = sm_strcasecmp(a->w_host, b->w_host)) != 0)
		return i;

	/* lock status */
	if (a->w_lock != b->w_lock)
		return b->w_lock - a->w_lock;

	/* job priority */
	return workcmpf0(a, b);
}
/*
**  WORKCMPF2 -- second compare function for ordering work based on host name.
**
**	Sorts on lock status, host name, and priority in that order.
**
**	Parameters:
**		a -- the first argument.
**		b -- the second argument.
**
**	Returns:
**		<0 if a < b
**		 0 if a == b
**		>0 if a > b
**
*/

static int
workcmpf2(a, b)
	register WORK *a;
	register WORK *b;
{
	int i;

	/* lock status */
	if (a->w_lock != b->w_lock)
		return a->w_lock - b->w_lock;

	/* host name */
	if (a->w_host != NULL && b->w_host == NULL)
		return 1;
	else if (a->w_host == NULL && b->w_host != NULL)
		return -1;
	if (a->w_host != NULL && b->w_host != NULL &&
	    (i = sm_strcasecmp(a->w_host, b->w_host)) != 0)
		return i;

	/* job priority */
	return workcmpf0(a, b);
}
/*
**  WORKCMPF3 -- simple submission-time-only compare function.
**
**	Parameters:
**		a -- the first argument.
**		b -- the second argument.
**
**	Returns:
**		-1 if a < b
**		 0 if a == b
**		+1 if a > b
**
*/

static int
workcmpf3(a, b)
	register WORK *a;
	register WORK *b;
{
	if (a->w_ctime > b->w_ctime)
		return 1;
	else if (a->w_ctime < b->w_ctime)
		return -1;
	else
		return 0;
}
/*
**  WORKCMPF4 -- compare based on file name
**
**	Parameters:
**		a -- the first argument.
**		b -- the second argument.
**
**	Returns:
**		-1 if a < b
**		 0 if a == b
**		+1 if a > b
**
*/

static int
workcmpf4(a, b)
	register WORK *a;
	register WORK *b;
{
	return strcmp(a->w_name, b->w_name);
}
/*
**  WORKCMPF5 -- compare based on assigned random number
**
**	Parameters:
**		a -- the first argument.
**		b -- the second argument.
**
**	Returns:
**		randomly 1/-1
*/

/* ARGSUSED0 */
static int
workcmpf5(a, b)
	register WORK *a;
	register WORK *b;
{
	if (strlen(a->w_name) < randi || strlen(b->w_name) < randi)
		return -1;
	return a->w_name[randi] - b->w_name[randi];
}
/*
**  WORKCMPF6 -- simple modification-time-only compare function.
**
**	Parameters:
**		a -- the first argument.
**		b -- the second argument.
**
**	Returns:
**		-1 if a < b
**		 0 if a == b
**		+1 if a > b
**
*/

static int
workcmpf6(a, b)
	register WORK *a;
	register WORK *b;
{
	if (a->w_mtime > b->w_mtime)
		return 1;
	else if (a->w_mtime < b->w_mtime)
		return -1;
	else
		return 0;
}
#if _FFR_RHS
/*
**  WORKCMPF7 -- compare function for ordering work based on shuffled host name.
**
**	Sorts on lock status, host name, and priority in that order.
**
**	Parameters:
**		a -- the first argument.
**		b -- the second argument.
**
**	Returns:
**		<0 if a < b
**		 0 if a == b
**		>0 if a > b
**
*/

static int
workcmpf7(a, b)
	register WORK *a;
	register WORK *b;
{
	int i;

	/* lock status */
	if (a->w_lock != b->w_lock)
		return a->w_lock - b->w_lock;

	/* host name */
	if (a->w_host != NULL && b->w_host == NULL)
		return 1;
	else if (a->w_host == NULL && b->w_host != NULL)
		return -1;
	if (a->w_host != NULL && b->w_host != NULL &&
	    (i = sm_strshufflecmp(a->w_host, b->w_host)) != 0)
		return i;

	/* job priority */
	return workcmpf0(a, b);
}
#endif /* _FFR_RHS */
/*
**  STRREV -- reverse string
**
**	Returns a pointer to a new string that is the reverse of
**	the string pointed to by fwd.  The space for the new
**	string is obtained using xalloc().
**
**	Parameters:
**		fwd -- the string to reverse.
**
**	Returns:
**		the reversed string.
*/

static char *
strrev(fwd)
	char *fwd;
{
	char *rev = NULL;
	int len, cnt;

	len = strlen(fwd);
	rev = xalloc(len + 1);
	for (cnt = 0; cnt < len; ++cnt)
		rev[cnt] = fwd[len - cnt - 1];
	rev[len] = '\0';
	return rev;
}

#if _FFR_RHS

# define NASCII	128
# define NCHAR	256

static unsigned char ShuffledAlphabet[NCHAR];

void
init_shuffle_alphabet()
{
	static bool init = false;
	int i;

	if (init)
		return;

	/* fill the ShuffledAlphabet */
	for (i = 0; i < NASCII; i++)
		ShuffledAlphabet[i] = i;

	/* mix it */
	for (i = 1; i < NASCII; i++)
	{
		register int j = get_random() % NASCII;
		register int tmp;

		tmp = ShuffledAlphabet[j];
		ShuffledAlphabet[j] = ShuffledAlphabet[i];
		ShuffledAlphabet[i] = tmp;
	}

	/* make it case insensitive */
	for (i = 'A'; i <= 'Z'; i++)
		ShuffledAlphabet[i] = ShuffledAlphabet[i + 'a' - 'A'];

	/* fill the upper part */
	for (i = 0; i < NASCII; i++)
		ShuffledAlphabet[i + NASCII] = ShuffledAlphabet[i];
	init = true;
}

static int
sm_strshufflecmp(a, b)
	char *a;
	char *b;
{
	const unsigned char *us1 = (const unsigned char *) a;
	const unsigned char *us2 = (const unsigned char *) b;

	while (ShuffledAlphabet[*us1] == ShuffledAlphabet[*us2++])
	{
		if (*us1++ == '\0')
			return 0;
	}
	return (ShuffledAlphabet[*us1] - ShuffledAlphabet[*--us2]);
}
#endif /* _FFR_RHS */

/*
**  DOWORK -- do a work request.
**
**	Parameters:
**		qgrp -- the index of the queue group for the job.
**		qdir -- the index of the queue directory for the job.
**		id -- the ID of the job to run.
**		forkflag -- if set, run this in background.
**		requeueflag -- if set, reinstantiate the queue quickly.
**			This is used when expanding aliases in the queue.
**			If forkflag is also set, it doesn't wait for the
**			child.
**		e - the envelope in which to run it.
**
**	Returns:
**		process id of process that is running the queue job.
**
**	Side Effects:
**		The work request is satisfied if possible.
*/

pid_t
dowork(qgrp, qdir, id, forkflag, requeueflag, e)
	int qgrp;
	int qdir;
	char *id;
	bool forkflag;
	bool requeueflag;
	register ENVELOPE *e;
{
	register pid_t pid;
	SM_RPOOL_T *rpool;

	if (tTd(40, 1))
		sm_dprintf("dowork(%s/%s)\n", qid_printqueue(qgrp, qdir), id);

	/*
	**  Fork for work.
	*/

	if (forkflag)
	{
		/*
		**  Since the delivery may happen in a child and the
		**  parent does not wait, the parent may close the
		**  maps thereby removing any shared memory used by
		**  the map.  Therefore, close the maps now so the
		**  child will dynamically open them if necessary.
		*/

		closemaps(false);

		pid = fork();
		if (pid < 0)
		{
			syserr("dowork: cannot fork");
			return 0;
		}
		else if (pid > 0)
		{
			/* parent -- clean out connection cache */
			mci_flush(false, NULL);
		}
		else
		{
			/*
			**  Initialize exception stack and default exception
			**  handler for child process.
			*/

			/* Reset global flags */
			RestartRequest = NULL;
			RestartWorkGroup = false;
			ShutdownRequest = NULL;
			PendingSignal = 0;
			CurrentPid = getpid();
			sm_exc_newthread(fatal_error);

			/*
			**  See note above about SMTP processes and SIGCHLD.
			*/

			if (OpMode == MD_SMTP ||
			    OpMode == MD_DAEMON ||
			    MaxQueueChildren > 0)
			{
				proc_list_clear();
				sm_releasesignal(SIGCHLD);
				(void) sm_signal(SIGCHLD, SIG_DFL);
			}

			/* child -- error messages to the transcript */
			QuickAbort = OnlyOneError = false;
		}
	}
	else
	{
		pid = 0;
	}

	if (pid == 0)
	{
		/*
		**  CHILD
		**	Lock the control file to avoid duplicate deliveries.
		**		Then run the file as though we had just read it.
		**	We save an idea of the temporary name so we
		**		can recover on interrupt.
		*/

		if (forkflag)
		{
			/* Reset global flags */
			RestartRequest = NULL;
			RestartWorkGroup = false;
			ShutdownRequest = NULL;
			PendingSignal = 0;
		}

		/* set basic modes, etc. */
		sm_clear_events();
		clearstats();
		rpool = sm_rpool_new_x(NULL);
		clearenvelope(e, false, rpool);
		e->e_flags |= EF_QUEUERUN|EF_GLOBALERRS;
		set_delivery_mode(SM_DELIVER, e);
		e->e_errormode = EM_MAIL;
		e->e_id = id;
		e->e_qgrp = qgrp;
		e->e_qdir = qdir;
		GrabTo = UseErrorsTo = false;
		ExitStat = EX_OK;
		if (forkflag)
		{
			disconnect(1, e);
			set_op_mode(MD_QUEUERUN);
		}
		sm_setproctitle(true, e, "%s from queue", qid_printname(e));
		if (LogLevel > 76)
			sm_syslog(LOG_DEBUG, e->e_id, "dowork, pid=%d",
				  (int) CurrentPid);

		/* don't use the headers from sendmail.cf... */
		e->e_header = NULL;

		/* read the queue control file -- return if locked */
		if (!readqf(e, false))
		{
			if (tTd(40, 4) && e->e_id != NULL)
				sm_dprintf("readqf(%s) failed\n",
					qid_printname(e));
			e->e_id = NULL;
			if (forkflag)
				finis(false, true, EX_OK);
			else
			{
				/* adding this frees 8 bytes */
				clearenvelope(e, false, rpool);

				/* adding this frees 12 bytes */
				sm_rpool_free(rpool);
				e->e_rpool = NULL;
				return 0;
			}
		}

		e->e_flags |= EF_INQUEUE;
		eatheader(e, requeueflag, true);

		if (requeueflag)
			queueup(e, false, false);

		/* do the delivery */
		sendall(e, SM_DELIVER);

		/* finish up and exit */
		if (forkflag)
			finis(true, true, ExitStat);
		else
		{
			(void) dropenvelope(e, true, false);
			sm_rpool_free(rpool);
			e->e_rpool = NULL;
			e->e_message = NULL;
		}
	}
	e->e_id = NULL;
	return pid;
}

/*
**  DOWORKLIST -- process a list of envelopes as work requests
**
**	Similar to dowork(), except that after forking, it processes an
**	envelope and its siblings, treating each envelope as a work request.
**
**	Parameters:
**		el -- envelope to be processed including its siblings.
**		forkflag -- if set, run this in background.
**		requeueflag -- if set, reinstantiate the queue quickly.
**			This is used when expanding aliases in the queue.
**			If forkflag is also set, it doesn't wait for the
**			child.
**
**	Returns:
**		process id of process that is running the queue job.
**
**	Side Effects:
**		The work request is satisfied if possible.
*/

pid_t
doworklist(el, forkflag, requeueflag)
	ENVELOPE *el;
	bool forkflag;
	bool requeueflag;
{
	register pid_t pid;
	ENVELOPE *ei;

	if (tTd(40, 1))
		sm_dprintf("doworklist()\n");

	/*
	**  Fork for work.
	*/

	if (forkflag)
	{
		/*
		**  Since the delivery may happen in a child and the
		**  parent does not wait, the parent may close the
		**  maps thereby removing any shared memory used by
		**  the map.  Therefore, close the maps now so the
		**  child will dynamically open them if necessary.
		*/

		closemaps(false);

		pid = fork();
		if (pid < 0)
		{
			syserr("doworklist: cannot fork");
			return 0;
		}
		else if (pid > 0)
		{
			/* parent -- clean out connection cache */
			mci_flush(false, NULL);
		}
		else
		{
			/*
			**  Initialize exception stack and default exception
			**  handler for child process.
			*/

			/* Reset global flags */
			RestartRequest = NULL;
			RestartWorkGroup = false;
			ShutdownRequest = NULL;
			PendingSignal = 0;
			CurrentPid = getpid();
			sm_exc_newthread(fatal_error);

			/*
			**  See note above about SMTP processes and SIGCHLD.
			*/

			if (OpMode == MD_SMTP ||
			    OpMode == MD_DAEMON ||
			    MaxQueueChildren > 0)
			{
				proc_list_clear();
				sm_releasesignal(SIGCHLD);
				(void) sm_signal(SIGCHLD, SIG_DFL);
			}

			/* child -- error messages to the transcript */
			QuickAbort = OnlyOneError = false;
		}
	}
	else
	{
		pid = 0;
	}

	if (pid != 0)
		return pid;

	/*
	**  IN CHILD
	**	Lock the control file to avoid duplicate deliveries.
	**		Then run the file as though we had just read it.
	**	We save an idea of the temporary name so we
	**		can recover on interrupt.
	*/

	if (forkflag)
	{
		/* Reset global flags */
		RestartRequest = NULL;
		RestartWorkGroup = false;
		ShutdownRequest = NULL;
		PendingSignal = 0;
	}

	/* set basic modes, etc. */
	sm_clear_events();
	clearstats();
	GrabTo = UseErrorsTo = false;
	ExitStat = EX_OK;
	if (forkflag)
	{
		disconnect(1, el);
		set_op_mode(MD_QUEUERUN);
	}
	if (LogLevel > 76)
		sm_syslog(LOG_DEBUG, el->e_id, "doworklist, pid=%d",
			  (int) CurrentPid);

	for (ei = el; ei != NULL; ei = ei->e_sibling)
	{
		ENVELOPE e;
		SM_RPOOL_T *rpool;

		if (WILL_BE_QUEUED(ei->e_sendmode))
			continue;
		else if (QueueMode != QM_QUARANTINE &&
			 ei->e_quarmsg != NULL)
			continue;

		rpool = sm_rpool_new_x(NULL);
		clearenvelope(&e, true, rpool);
		e.e_flags |= EF_QUEUERUN|EF_GLOBALERRS;
		set_delivery_mode(SM_DELIVER, &e);
		e.e_errormode = EM_MAIL;
		e.e_id = ei->e_id;
		e.e_qgrp = ei->e_qgrp;
		e.e_qdir = ei->e_qdir;
		openxscript(&e);
		sm_setproctitle(true, &e, "%s from queue", qid_printname(&e));

		/* don't use the headers from sendmail.cf... */
		e.e_header = NULL;
		CurEnv = &e;

		/* read the queue control file -- return if locked */
		if (readqf(&e, false))
		{
			e.e_flags |= EF_INQUEUE;
			eatheader(&e, requeueflag, true);

			if (requeueflag)
				queueup(&e, false, false);

			/* do the delivery */
			sendall(&e, SM_DELIVER);
			(void) dropenvelope(&e, true, false);
		}
		else
		{
			if (tTd(40, 4) && e.e_id != NULL)
				sm_dprintf("readqf(%s) failed\n",
					qid_printname(&e));
		}
		sm_rpool_free(rpool);
		ei->e_id = NULL;
	}

	/* restore CurEnv */
	CurEnv = el;

	/* finish up and exit */
	if (forkflag)
		finis(true, true, ExitStat);
	return 0;
}
/*
**  READQF -- read queue file and set up environment.
**
**	Parameters:
**		e -- the envelope of the job to run.
**		openonly -- only open the qf (returned as e_lockfp)
**
**	Returns:
**		true if it successfully read the queue file.
**		false otherwise.
**
**	Side Effects:
**		The queue file is returned locked.
*/

static bool
readqf(e, openonly)
	register ENVELOPE *e;
	bool openonly;
{
	register SM_FILE_T *qfp;
	ADDRESS *ctladdr;
	struct stat st, stf;
	char *bp;
	int qfver = 0;
	long hdrsize = 0;
	register char *p;
	char *frcpt = NULL;
	char *orcpt = NULL;
	bool nomore = false;
	bool bogus = false;
	MODE_T qsafe;
	char *err;
	char qf[MAXPATHLEN];
	char buf[MAXLINE];
	int bufsize;

	/*
	**  Read and process the file.
	*/

	SM_REQUIRE(e != NULL);
	bp = NULL;
	(void) sm_strlcpy(qf, queuename(e, ANYQFL_LETTER), sizeof(qf));
	qfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, qf, SM_IO_RDWR_B, NULL);
	if (qfp == NULL)
	{
		int save_errno = errno;

		if (tTd(40, 8))
			sm_dprintf("readqf(%s): sm_io_open failure (%s)\n",
				qf, sm_errstring(errno));
		errno = save_errno;
		if (errno != ENOENT
		    )
			syserr("readqf: no control file %s", qf);
		RELEASE_QUEUE;
		return false;
	}

	if (!lockfile(sm_io_getinfo(qfp, SM_IO_WHAT_FD, NULL), qf, NULL,
		      LOCK_EX|LOCK_NB))
	{
		/* being processed by another queuer */
		if (Verbose)
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "%s: locked\n", e->e_id);
		if (tTd(40, 8))
			sm_dprintf("%s: locked\n", e->e_id);
		if (LogLevel > 19)
			sm_syslog(LOG_DEBUG, e->e_id, "locked");
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
		RELEASE_QUEUE;
		return false;
	}

	RELEASE_QUEUE;

	/*
	**  Prevent locking race condition.
	**
	**  Process A: readqf(): qfp = fopen(qffile)
	**  Process B: queueup(): rename(tf, qf)
	**  Process B: unlocks(tf)
	**  Process A: lockfile(qf);
	**
	**  Process A (us) has the old qf file (before the rename deleted
	**  the directory entry) and will be delivering based on old data.
	**  This can lead to multiple deliveries of the same recipients.
	**
	**  Catch this by checking if the underlying qf file has changed
	**  *after* acquiring our lock and if so, act as though the file
	**  was still locked (i.e., just return like the lockfile() case
	**  above.
	*/

	if (stat(qf, &stf) < 0 ||
	    fstat(sm_io_getinfo(qfp, SM_IO_WHAT_FD, NULL), &st) < 0)
	{
		/* must have been being processed by someone else */
		if (tTd(40, 8))
			sm_dprintf("readqf(%s): [f]stat failure (%s)\n",
				qf, sm_errstring(errno));
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
		return false;
	}

	if (st.st_nlink != stf.st_nlink ||
	    st.st_dev != stf.st_dev ||
	    ST_INODE(st) != ST_INODE(stf) ||
#if HAS_ST_GEN && 0		/* AFS returns garbage in st_gen */
	    st.st_gen != stf.st_gen ||
#endif /* HAS_ST_GEN && 0 */
	    st.st_uid != stf.st_uid ||
	    st.st_gid != stf.st_gid ||
	    st.st_size != stf.st_size)
	{
		/* changed after opened */
		if (Verbose)
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "%s: changed\n", e->e_id);
		if (tTd(40, 8))
			sm_dprintf("%s: changed\n", e->e_id);
		if (LogLevel > 19)
			sm_syslog(LOG_DEBUG, e->e_id, "changed");
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
		return false;
	}

	/*
	**  Check the queue file for plausibility to avoid attacks.
	*/

	qsafe = S_IWOTH|S_IWGRP;
	if (bitset(S_IWGRP, QueueFileMode))
		qsafe &= ~S_IWGRP;

	bogus = st.st_uid != geteuid() &&
		st.st_uid != TrustedUid &&
		geteuid() != RealUid;

	/*
	**  If this qf file results from a set-group-ID binary, then
	**  we check whether the directory is group-writable,
	**  the queue file mode contains the group-writable bit, and
	**  the groups are the same.
	**  Notice: this requires that the set-group-ID binary is used to
	**  run the queue!
	*/

	if (bogus && st.st_gid == getegid() && UseMSP)
	{
		char delim;
		struct stat dst;

		bp = SM_LAST_DIR_DELIM(qf);
		if (bp == NULL)
			delim = '\0';
		else
		{
			delim = *bp;
			*bp = '\0';
		}
		if (stat(delim == '\0' ? "." : qf, &dst) < 0)
			syserr("readqf: cannot stat directory %s",
				delim == '\0' ? "." : qf);
		else
		{
			bogus = !(bitset(S_IWGRP, QueueFileMode) &&
				  bitset(S_IWGRP, dst.st_mode) &&
				  dst.st_gid == st.st_gid);
		}
		if (delim != '\0')
			*bp = delim;
		bp = NULL;
	}
	if (!bogus)
		bogus = bitset(qsafe, st.st_mode);
	if (bogus)
	{
		if (LogLevel > 0)
		{
			sm_syslog(LOG_ALERT, e->e_id,
				  "bogus queue file, uid=%d, gid=%d, mode=%o",
				  st.st_uid, st.st_gid, st.st_mode);
		}
		if (tTd(40, 8))
			sm_dprintf("readqf(%s): bogus file\n", qf);
		e->e_flags |= EF_INQUEUE;
		if (!openonly)
			loseqfile(e, "bogus file uid/gid in mqueue");
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
		return false;
	}

	if (st.st_size == 0)
	{
		/* must be a bogus file -- if also old, just remove it */
		if (!openonly && st.st_ctime + 10 * 60 < curtime())
		{
			(void) xunlink(queuename(e, DATAFL_LETTER));
			(void) xunlink(queuename(e, ANYQFL_LETTER));
		}
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
		return false;
	}

	if (st.st_nlink == 0)
	{
		/*
		**  Race condition -- we got a file just as it was being
		**  unlinked.  Just assume it is zero length.
		*/

		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
		return false;
	}

#if _FFR_TRUSTED_QF
	/*
	**  If we don't own the file mark it as unsafe.
	**  However, allow TrustedUser to own it as well
	**  in case TrustedUser manipulates the queue.
	*/

	if (st.st_uid != geteuid() && st.st_uid != TrustedUid)
		e->e_flags |= EF_UNSAFE;
#else /* _FFR_TRUSTED_QF */
	/* If we don't own the file mark it as unsafe */
	if (st.st_uid != geteuid())
		e->e_flags |= EF_UNSAFE;
#endif /* _FFR_TRUSTED_QF */

	/* good file -- save this lock */
	e->e_lockfp = qfp;

	/* Just wanted the open file */
	if (openonly)
		return true;

	/* do basic system initialization */
	initsys(e);
	macdefine(&e->e_macro, A_PERM, 'i', e->e_id);

	LineNumber = 0;
	e->e_flags |= EF_GLOBALERRS;
	set_op_mode(MD_QUEUERUN);
	ctladdr = NULL;
	e->e_qfletter = queue_letter(e, ANYQFL_LETTER);
	e->e_dfqgrp = e->e_qgrp;
	e->e_dfqdir = e->e_qdir;
#if _FFR_QUEUE_MACRO
	macdefine(&e->e_macro, A_TEMP, macid("{queue}"),
		  qid_printqueue(e->e_qgrp, e->e_qdir));
#endif /* _FFR_QUEUE_MACRO */
	e->e_dfino = -1;
	e->e_msgsize = -1;
	while (bufsize = sizeof(buf),
	       (bp = fgetfolded(buf, &bufsize, qfp)) != NULL)
	{
		unsigned long qflags;
		ADDRESS *q;
		int r;
		time_t now;
		auto char *ep;

		if (tTd(40, 4))
			sm_dprintf("+++++ %s\n", bp);
		if (nomore)
		{
			/* hack attack */
  hackattack:
			syserr("SECURITY ALERT: extra or bogus data in queue file: %s",
			       bp);
			err = "bogus queue line";
			goto fail;
		}
		switch (bp[0])
		{
		  case 'A':		/* AUTH= parameter */
			if (!xtextok(&bp[1]))
				goto hackattack;
			e->e_auth_param = sm_rpool_strdup_x(e->e_rpool, &bp[1]);
			break;

		  case 'B':		/* body type */
			r = check_bodytype(&bp[1]);
			if (!BODYTYPE_VALID(r))
				goto hackattack;
			e->e_bodytype = sm_rpool_strdup_x(e->e_rpool, &bp[1]);
			break;

		  case 'C':		/* specify controlling user */
			ctladdr = setctluser(&bp[1], qfver, e);
			break;

		  case 'D':		/* data file name */
			/* obsolete -- ignore */
			break;

		  case 'd':		/* data file directory name */
			{
				int qgrp, qdir;

#if _FFR_MSP_PARANOIA
				/* forbid queue groups in MSP? */
				if (UseMSP)
					goto hackattack;
#endif /* _FFR_MSP_PARANOIA */
				for (qgrp = 0;
				     qgrp < NumQueue && Queue[qgrp] != NULL;
				     ++qgrp)
				{
					for (qdir = 0;
					     qdir < Queue[qgrp]->qg_numqueues;
					     ++qdir)
					{
						if (strcmp(&bp[1],
							   Queue[qgrp]->qg_qpaths[qdir].qp_name)
						    == 0)
						{
							e->e_dfqgrp = qgrp;
							e->e_dfqdir = qdir;
							goto done;
						}
					}
				}
				err = "bogus queue file directory";
				goto fail;
			  done:
				break;
			}

		  case 'E':		/* specify error recipient */
			/* no longer used */
			break;

		  case 'F':		/* flag bits */
			if (strncmp(bp, "From ", 5) == 0)
			{
				/* we are being spoofed! */
				syserr("SECURITY ALERT: bogus qf line %s", bp);
				err = "bogus queue line";
				goto fail;
			}
			for (p = &bp[1]; *p != '\0'; p++)
			{
				switch (*p)
				{
				  case '8':	/* has 8 bit data */
					e->e_flags |= EF_HAS8BIT;
					break;

				  case 'b':	/* delete Bcc: header */
					e->e_flags |= EF_DELETE_BCC;
					break;

				  case 'd':	/* envelope has DSN RET= */
					e->e_flags |= EF_RET_PARAM;
					break;

				  case 'n':	/* don't return body */
					e->e_flags |= EF_NO_BODY_RETN;
					break;

				  case 'r':	/* response */
					e->e_flags |= EF_RESPONSE;
					break;

				  case 's':	/* split */
					e->e_flags |= EF_SPLIT;
					break;

				  case 'w':	/* warning sent */
					e->e_flags |= EF_WARNING;
					break;
				}
			}
			break;

		  case 'q':		/* quarantine reason */
			e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, &bp[1]);
			macdefine(&e->e_macro, A_PERM,
				  macid("{quarantine}"), e->e_quarmsg);
			break;

		  case 'H':		/* header */

			/*
			**  count size before chompheader() destroys the line.
			**  this isn't accurate due to macro expansion, but
			**  better than before. "-3" to skip H?? at least.
			*/

			hdrsize += strlen(bp) - 3;
			(void) chompheader(&bp[1], CHHDR_QUEUE, NULL, e);
			break;

		  case 'I':		/* data file's inode number */
			/* regenerated below */
			break;

		  case 'K':		/* time of last delivery attempt */
			e->e_dtime = atol(&buf[1]);
			break;

		  case 'L':		/* Solaris Content-Length: */
		  case 'M':		/* message */
			/* ignore this; we want a new message next time */
			break;

		  case 'N':		/* number of delivery attempts */
			e->e_ntries = atoi(&buf[1]);

			/* if this has been tried recently, let it be */
			now = curtime();
			if (e->e_ntries > 0 && e->e_dtime <= now &&
			    now < e->e_dtime + MinQueueAge)
			{
				char *howlong;

				howlong = pintvl(now - e->e_dtime, true);
				if (Verbose)
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "%s: too young (%s)\n",
							     e->e_id, howlong);
				if (tTd(40, 8))
					sm_dprintf("%s: too young (%s)\n",
						e->e_id, howlong);
				if (LogLevel > 19)
					sm_syslog(LOG_DEBUG, e->e_id,
						  "too young (%s)",
						  howlong);
				e->e_id = NULL;
				unlockqueue(e);
				if (bp != buf)
					sm_free(bp);
				return false;
			}
			macdefine(&e->e_macro, A_TEMP,
				macid("{ntries}"), &buf[1]);

#if NAMED_BIND
			/* adjust BIND parameters immediately */
			if (e->e_ntries == 0)
			{
				_res.retry = TimeOuts.res_retry[RES_TO_FIRST];
				_res.retrans = TimeOuts.res_retrans[RES_TO_FIRST];
			}
			else
			{
				_res.retry = TimeOuts.res_retry[RES_TO_NORMAL];
				_res.retrans = TimeOuts.res_retrans[RES_TO_NORMAL];
			}
#endif /* NAMED_BIND */
			break;

		  case 'P':		/* message priority */
			e->e_msgpriority = atol(&bp[1]) + WkTimeFact;
			break;

		  case 'Q':		/* original recipient */
			orcpt = sm_rpool_strdup_x(e->e_rpool, &bp[1]);
			break;

		  case 'r':		/* final recipient */
			frcpt = sm_rpool_strdup_x(e->e_rpool, &bp[1]);
			break;

		  case 'R':		/* specify recipient */
			p = bp;
			qflags = 0;
			if (qfver >= 1)
			{
				/* get flag bits */
				while (*++p != '\0' && *p != ':')
				{
					switch (*p)
					{
					  case 'N':
						qflags |= QHASNOTIFY;
						break;

					  case 'S':
						qflags |= QPINGONSUCCESS;
						break;

					  case 'F':
						qflags |= QPINGONFAILURE;
						break;

					  case 'D':
						qflags |= QPINGONDELAY;
						break;

					  case 'P':
						qflags |= QPRIMARY;
						break;

					  case 'A':
						if (ctladdr != NULL)
							ctladdr->q_flags |= QALIAS;
						break;

					  default: /* ignore or complain? */
						break;
					}
				}
			}
			else
				qflags |= QPRIMARY;
			macdefine(&e->e_macro, A_PERM, macid("{addr_type}"),
				"e r");
			if (*p != '\0')
				q = parseaddr(++p, NULLADDR, RF_COPYALL, '\0',
						NULL, e, true);
			else
				q = NULL;
			if (q != NULL)
			{
				/* make sure we keep the current qgrp */
				if (ISVALIDQGRP(e->e_qgrp))
					q->q_qgrp = e->e_qgrp;
				q->q_alias = ctladdr;
				if (qfver >= 1)
					q->q_flags &= ~Q_PINGFLAGS;
				q->q_flags |= qflags;
				q->q_finalrcpt = frcpt;
				q->q_orcpt = orcpt;
				(void) recipient(q, &e->e_sendqueue, 0, e);
			}
			frcpt = NULL;
			orcpt = NULL;
			macdefine(&e->e_macro, A_PERM, macid("{addr_type}"),
				NULL);
			break;

		  case 'S':		/* sender */
			setsender(sm_rpool_strdup_x(e->e_rpool, &bp[1]),
				  e, NULL, '\0', true);
			break;

		  case 'T':		/* init time */
			e->e_ctime = atol(&bp[1]);
			break;

		  case 'V':		/* queue file version number */
			qfver = atoi(&bp[1]);
			if (qfver <= QF_VERSION)
				break;
			syserr("Version number in queue file (%d) greater than max (%d)",
				qfver, QF_VERSION);
			err = "unsupported queue file version";
			goto fail;
			/* NOTREACHED */
			break;

		  case 'Z':		/* original envelope id from ESMTP */
			e->e_envid = sm_rpool_strdup_x(e->e_rpool, &bp[1]);
			macdefine(&e->e_macro, A_PERM,
				macid("{dsn_envid}"), e->e_envid);
			break;

		  case '!':		/* deliver by */

			/* format: flag (1 char) space long-integer */
			e->e_dlvr_flag = buf[1];
			e->e_deliver_by = strtol(&buf[3], NULL, 10);

		  case '$':		/* define macro */
			{
				char *p;

				/* XXX elimate p? */
				r = macid_parse(&bp[1], &ep);
				if (r == 0)
					break;
				p = sm_rpool_strdup_x(e->e_rpool, ep);
				macdefine(&e->e_macro, A_PERM, r, p);
			}
			break;

		  case '.':		/* terminate file */
			nomore = true;
			break;

#if _FFR_QUEUEDELAY
		  case 'G':
		  case 'Y':

			/*
			**  Maintain backward compatibility for
			**  users who defined _FFR_QUEUEDELAY in
			**  previous releases.  Remove this
			**  code in 8.14 or 8.15.
			*/

			if (qfver == 5 || qfver == 7)
				break;

			/* If not qfver 5 or 7, then 'G' or 'Y' is invalid */
			/* FALLTHROUGH */
#endif /* _FFR_QUEUEDELAY */

		  default:
			syserr("readqf: %s: line %d: bad line \"%s\"",
				qf, LineNumber, shortenstring(bp, MAXSHORTSTR));
			err = "unrecognized line";
			goto fail;
		}

		if (bp != buf)
			SM_FREE(bp);
	}

	/*
	**  If we haven't read any lines, this queue file is empty.
	**  Arrange to remove it without referencing any null pointers.
	*/

	if (LineNumber == 0)
	{
		errno = 0;
		e->e_flags |= EF_CLRQUEUE|EF_FATALERRS|EF_RESPONSE;
		return true;
	}

	/* Check to make sure we have a complete queue file read */
	if (!nomore)
	{
		syserr("readqf: %s: incomplete queue file read", qf);
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
		return false;
	}

#if _FFR_QF_PARANOIA
	/* Check to make sure key fields were read */
	if (e->e_from.q_mailer == NULL)
	{
		syserr("readqf: %s: sender not specified in queue file", qf);
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
		return false;
	}
	/* other checks? */
#endif /* _FFR_QF_PARANOIA */

	/* possibly set ${dsn_ret} macro */
	if (bitset(EF_RET_PARAM, e->e_flags))
	{
		if (bitset(EF_NO_BODY_RETN, e->e_flags))
			macdefine(&e->e_macro, A_PERM,
				macid("{dsn_ret}"), "hdrs");
		else
			macdefine(&e->e_macro, A_PERM,
				macid("{dsn_ret}"), "full");
	}

	/*
	**  Arrange to read the data file.
	*/

	p = queuename(e, DATAFL_LETTER);
	e->e_dfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, p, SM_IO_RDONLY_B,
			      NULL);
	if (e->e_dfp == NULL)
	{
		syserr("readqf: cannot open %s", p);
	}
	else
	{
		e->e_flags |= EF_HAS_DF;
		if (fstat(sm_io_getinfo(e->e_dfp, SM_IO_WHAT_FD, NULL), &st)
		    >= 0)
		{
			e->e_msgsize = st.st_size + hdrsize;
			e->e_dfdev = st.st_dev;
			e->e_dfino = ST_INODE(st);
			(void) sm_snprintf(buf, sizeof(buf), "%ld",
					   PRT_NONNEGL(e->e_msgsize));
			macdefine(&e->e_macro, A_TEMP, macid("{msg_size}"),
				  buf);
		}
	}

	return true;

  fail:
	/*
	**  There was some error reading the qf file (reason is in err var.)
	**  Cleanup:
	**	close file; clear e_lockfp since it is the same as qfp,
	**	hence it is invalid (as file) after qfp is closed;
	**	the qf file is on disk, so set the flag to avoid calling
	**	queueup() with bogus data.
	*/

	if (bp != buf)
		SM_FREE(bp);
	if (qfp != NULL)
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
	e->e_lockfp = NULL;
	e->e_flags |= EF_INQUEUE;
	loseqfile(e, err);
	return false;
}
/*
**  PRTSTR -- print a string, "unprintable" characters are shown as \oct
**
**	Parameters:
**		s -- string to print
**		ml -- maximum length of output
**
**	Returns:
**		number of entries
**
**	Side Effects:
**		Prints a string on stdout.
*/

static void prtstr __P((char *, int));

static void
prtstr(s, ml)
	char *s;
	int ml;
{
	int c;

	if (s == NULL)
		return;
	while (ml-- > 0 && ((c = *s++) != '\0'))
	{
		if (c == '\\')
		{
			if (ml-- > 0)
			{
				(void) sm_io_putc(smioout, SM_TIME_DEFAULT, c);
				(void) sm_io_putc(smioout, SM_TIME_DEFAULT, c);
			}
		}
		else if (isascii(c) && isprint(c))
			(void) sm_io_putc(smioout, SM_TIME_DEFAULT, c);
		else
		{
			if ((ml -= 3) > 0)
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "\\%03o", c & 0xFF);
		}
	}
}
/*
**  PRINTNQE -- print out number of entries in the mail queue
**
**	Parameters:
**		out -- output file pointer.
**		prefix -- string to output in front of each line.
**
**	Returns:
**		none.
*/

void
printnqe(out, prefix)
	SM_FILE_T *out;
	char *prefix;
{
#if SM_CONF_SHM
	int i, k = 0, nrequests = 0;
	bool unknown = false;

	if (ShmId == SM_SHM_NO_ID)
	{
		if (prefix == NULL)
			(void) sm_io_fprintf(out, SM_TIME_DEFAULT,
					"Data unavailable: shared memory not updated\n");
		else
			(void) sm_io_fprintf(out, SM_TIME_DEFAULT,
					"%sNOTCONFIGURED:-1\r\n", prefix);
		return;
	}
	for (i = 0; i < NumQueue && Queue[i] != NULL; i++)
	{
		int j;

		k++;
		for (j = 0; j < Queue[i]->qg_numqueues; j++)
		{
			int n;

			if (StopRequest)
				stop_sendmail();

			n = QSHM_ENTRIES(Queue[i]->qg_qpaths[j].qp_idx);
			if (prefix != NULL)
				(void) sm_io_fprintf(out, SM_TIME_DEFAULT,
					"%s%s:%d\r\n",
					prefix, qid_printqueue(i, j), n);
			else if (n < 0)
			{
				(void) sm_io_fprintf(out, SM_TIME_DEFAULT,
					"%s: unknown number of entries\n",
					qid_printqueue(i, j));
				unknown = true;
			}
			else if (n == 0)
			{
				(void) sm_io_fprintf(out, SM_TIME_DEFAULT,
					"%s is empty\n",
					qid_printqueue(i, j));
			}
			else if (n > 0)
			{
				(void) sm_io_fprintf(out, SM_TIME_DEFAULT,
					"%s: entries=%d\n",
					qid_printqueue(i, j), n);
				nrequests += n;
				k++;
			}
		}
	}
	if (prefix == NULL && k > 1)
		(void) sm_io_fprintf(out, SM_TIME_DEFAULT,
				     "\t\tTotal requests: %d%s\n",
				     nrequests, unknown ? " (about)" : "");
#else /* SM_CONF_SHM */
	if (prefix == NULL)
		(void) sm_io_fprintf(out, SM_TIME_DEFAULT,
			     "Data unavailable without shared memory support\n");
	else
		(void) sm_io_fprintf(out, SM_TIME_DEFAULT,
			     "%sNOTAVAILABLE:-1\r\n", prefix);
#endif /* SM_CONF_SHM */
}
/*
**  PRINTQUEUE -- print out a representation of the mail queue
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Prints a listing of the mail queue on the standard output.
*/

void
printqueue()
{
	int i, k = 0, nrequests = 0;

	for (i = 0; i < NumQueue && Queue[i] != NULL; i++)
	{
		int j;

		k++;
		for (j = 0; j < Queue[i]->qg_numqueues; j++)
		{
			if (StopRequest)
				stop_sendmail();
			nrequests += print_single_queue(i, j);
			k++;
		}
	}
	if (k > 1)
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "\t\tTotal requests: %d\n",
				     nrequests);
}
/*
**  PRINT_SINGLE_QUEUE -- print out a representation of a single mail queue
**
**	Parameters:
**		qgrp -- the index of the queue group.
**		qdir -- the queue directory.
**
**	Returns:
**		number of requests in mail queue.
**
**	Side Effects:
**		Prints a listing of the mail queue on the standard output.
*/

int
print_single_queue(qgrp, qdir)
	int qgrp;
	int qdir;
{
	register WORK *w;
	SM_FILE_T *f;
	int nrequests;
	char qd[MAXPATHLEN];
	char qddf[MAXPATHLEN];
	char buf[MAXLINE];

	if (qdir == NOQDIR)
	{
		(void) sm_strlcpy(qd, ".", sizeof(qd));
		(void) sm_strlcpy(qddf, ".", sizeof(qddf));
	}
	else
	{
		(void) sm_strlcpyn(qd, sizeof(qd), 2,
			Queue[qgrp]->qg_qpaths[qdir].qp_name,
			(bitset(QP_SUBQF,
				Queue[qgrp]->qg_qpaths[qdir].qp_subdirs)
					? "/qf" : ""));
		(void) sm_strlcpyn(qddf, sizeof(qddf), 2,
			Queue[qgrp]->qg_qpaths[qdir].qp_name,
			(bitset(QP_SUBDF,
				Queue[qgrp]->qg_qpaths[qdir].qp_subdirs)
					? "/df" : ""));
	}

	/*
	**  Check for permission to print the queue
	*/

	if (bitset(PRIV_RESTRICTMAILQ, PrivacyFlags) && RealUid != 0)
	{
		struct stat st;
#ifdef NGROUPS_MAX
		int n;
		extern GIDSET_T InitialGidSet[NGROUPS_MAX];
#endif /* NGROUPS_MAX */

		if (stat(qd, &st) < 0)
		{
			syserr("Cannot stat %s",
				qid_printqueue(qgrp, qdir));
			return 0;
		}
#ifdef NGROUPS_MAX
		n = NGROUPS_MAX;
		while (--n >= 0)
		{
			if (InitialGidSet[n] == st.st_gid)
				break;
		}
		if (n < 0 && RealGid != st.st_gid)
#else /* NGROUPS_MAX */
		if (RealGid != st.st_gid)
#endif /* NGROUPS_MAX */
		{
			usrerr("510 You are not permitted to see the queue");
			setstat(EX_NOPERM);
			return 0;
		}
	}

	/*
	**  Read and order the queue.
	*/

	nrequests = gatherq(qgrp, qdir, true, NULL, NULL, NULL);
	(void) sortq(Queue[qgrp]->qg_maxlist);

	/*
	**  Print the work list that we have read.
	*/

	/* first see if there is anything */
	if (nrequests <= 0)
	{
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s is empty\n",
				     qid_printqueue(qgrp, qdir));
		return 0;
	}

	sm_getla();	/* get load average */

	(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "\t\t%s (%d request%s",
			     qid_printqueue(qgrp, qdir),
			     nrequests, nrequests == 1 ? "" : "s");
	if (MaxQueueRun > 0 && nrequests > MaxQueueRun)
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     ", only %d printed", MaxQueueRun);
	if (Verbose)
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
			")\n-----Q-ID----- --Size-- -Priority- ---Q-Time--- --------Sender/Recipient--------\n");
	else
		(void) sm_io_fprintf(smioout,  SM_TIME_DEFAULT,
			")\n-----Q-ID----- --Size-- -----Q-Time----- ------------Sender/Recipient-----------\n");
	for (w = WorkQ; w != NULL; w = w->w_next)
	{
		struct stat st;
		auto time_t submittime = 0;
		long dfsize;
		int flags = 0;
		int qfver;
		char quarmsg[MAXLINE];
		char statmsg[MAXLINE];
		char bodytype[MAXNAME + 1];
		char qf[MAXPATHLEN];

		if (StopRequest)
			stop_sendmail();

		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%13s",
				     w->w_name + 2);
		(void) sm_strlcpyn(qf, sizeof(qf), 3, qd, "/", w->w_name);
		f = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, qf, SM_IO_RDONLY_B,
			       NULL);
		if (f == NULL)
		{
			if (errno == EPERM)
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     " (permission denied)\n");
			else if (errno == ENOENT)
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     " (job completed)\n");
			else
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     " (%s)\n",
						     sm_errstring(errno));
			errno = 0;
			continue;
		}
		w->w_name[0] = DATAFL_LETTER;
		(void) sm_strlcpyn(qf, sizeof(qf), 3, qddf, "/", w->w_name);
		if (stat(qf, &st) >= 0)
			dfsize = st.st_size;
		else
		{
			ENVELOPE e;

			/*
			**  Maybe the df file can't be statted because
			**  it is in a different directory than the qf file.
			**  In order to find out, we must read the qf file.
			*/

			newenvelope(&e, &BlankEnvelope, sm_rpool_new_x(NULL));
			e.e_id = w->w_name + 2;
			e.e_qgrp = qgrp;
			e.e_qdir = qdir;
			dfsize = -1;
			if (readqf(&e, false))
			{
				char *df = queuename(&e, DATAFL_LETTER);
				if (stat(df, &st) >= 0)
					dfsize = st.st_size;
			}
			if (e.e_lockfp != NULL)
			{
				(void) sm_io_close(e.e_lockfp, SM_TIME_DEFAULT);
				e.e_lockfp = NULL;
			}
			clearenvelope(&e, false, e.e_rpool);
			sm_rpool_free(e.e_rpool);
		}
		if (w->w_lock)
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "*");
		else if (QueueMode == QM_LOST)
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "?");
		else if (w->w_tooyoung)
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "-");
		else if (shouldqueue(w->w_pri, w->w_ctime))
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "X");
		else
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, " ");

		errno = 0;

		quarmsg[0] = '\0';
		statmsg[0] = bodytype[0] = '\0';
		qfver = 0;
		while (sm_io_fgets(f, SM_TIME_DEFAULT, buf, sizeof(buf)) >= 0)
		{
			register int i;
			register char *p;

			if (StopRequest)
				stop_sendmail();

			fixcrlf(buf, true);
			switch (buf[0])
			{
			  case 'V':	/* queue file version */
				qfver = atoi(&buf[1]);
				break;

			  case 'M':	/* error message */
				if ((i = strlen(&buf[1])) >= sizeof(statmsg))
					i = sizeof(statmsg) - 1;
				memmove(statmsg, &buf[1], i);
				statmsg[i] = '\0';
				break;

			  case 'q':	/* quarantine reason */
				if ((i = strlen(&buf[1])) >= sizeof(quarmsg))
					i = sizeof(quarmsg) - 1;
				memmove(quarmsg, &buf[1], i);
				quarmsg[i] = '\0';
				break;

			  case 'B':	/* body type */
				if ((i = strlen(&buf[1])) >= sizeof(bodytype))
					i = sizeof(bodytype) - 1;
				memmove(bodytype, &buf[1], i);
				bodytype[i] = '\0';
				break;

			  case 'S':	/* sender name */
				if (Verbose)
				{
					(void) sm_io_fprintf(smioout,
						SM_TIME_DEFAULT,
						"%8ld %10ld%c%.12s ",
						dfsize,
						w->w_pri,
						bitset(EF_WARNING, flags)
							? '+' : ' ',
						ctime(&submittime) + 4);
					prtstr(&buf[1], 78);
				}
				else
				{
					(void) sm_io_fprintf(smioout,
						SM_TIME_DEFAULT,
						"%8ld %.16s ",
						dfsize,
						ctime(&submittime));
					prtstr(&buf[1], 39);
				}

				if (quarmsg[0] != '\0')
				{
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "\n     QUARANTINE: %.*s",
							     Verbose ? 100 : 60,
							     quarmsg);
					quarmsg[0] = '\0';
				}

				if (statmsg[0] != '\0' || bodytype[0] != '\0')
				{
					(void) sm_io_fprintf(smioout,
						SM_TIME_DEFAULT,
						"\n    %10.10s",
						bodytype);
					if (statmsg[0] != '\0')
						(void) sm_io_fprintf(smioout,
							SM_TIME_DEFAULT,
							"   (%.*s)",
							Verbose ? 100 : 60,
							statmsg);
					statmsg[0] = '\0';
				}
				break;

			  case 'C':	/* controlling user */
				if (Verbose)
					(void) sm_io_fprintf(smioout,
						SM_TIME_DEFAULT,
						"\n\t\t\t\t\t\t(---%.64s---)",
						&buf[1]);
				break;

			  case 'R':	/* recipient name */
				p = &buf[1];
				if (qfver >= 1)
				{
					p = strchr(p, ':');
					if (p == NULL)
						break;
					p++;
				}
				if (Verbose)
				{
					(void) sm_io_fprintf(smioout,
							SM_TIME_DEFAULT,
							"\n\t\t\t\t\t\t");
					prtstr(p, 71);
				}
				else
				{
					(void) sm_io_fprintf(smioout,
							SM_TIME_DEFAULT,
							"\n\t\t\t\t\t ");
					prtstr(p, 38);
				}
				if (Verbose && statmsg[0] != '\0')
				{
					(void) sm_io_fprintf(smioout,
							SM_TIME_DEFAULT,
							"\n\t\t (%.100s)",
							statmsg);
					statmsg[0] = '\0';
				}
				break;

			  case 'T':	/* creation time */
				submittime = atol(&buf[1]);
				break;

			  case 'F':	/* flag bits */
				for (p = &buf[1]; *p != '\0'; p++)
				{
					switch (*p)
					{
					  case 'w':
						flags |= EF_WARNING;
						break;
					}
				}
			}
		}
		if (submittime == (time_t) 0)
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     " (no control file)");
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "\n");
		(void) sm_io_close(f, SM_TIME_DEFAULT);
	}
	return nrequests;
}

/*
**  QUEUE_LETTER -- get the proper queue letter for the current QueueMode.
**
**	Parameters:
**		e -- envelope to build it in/from.
**		type -- the file type, used as the first character
**			of the file name.
**
**	Returns:
**		the letter to use
*/

static char
queue_letter(e, type)
	ENVELOPE *e;
	int type;
{
	/* Change type according to QueueMode */
	if (type == ANYQFL_LETTER)
	{
		if (e->e_quarmsg != NULL)
			type = QUARQF_LETTER;
		else
		{
			switch (QueueMode)
			{
			  case QM_NORMAL:
				type = NORMQF_LETTER;
				break;

			  case QM_QUARANTINE:
				type = QUARQF_LETTER;
				break;

			  case QM_LOST:
				type = LOSEQF_LETTER;
				break;

			  default:
				/* should never happen */
				abort();
				/* NOTREACHED */
			}
		}
	}
	return type;
}

/*
**  QUEUENAME -- build a file name in the queue directory for this envelope.
**
**	Parameters:
**		e -- envelope to build it in/from.
**		type -- the file type, used as the first character
**			of the file name.
**
**	Returns:
**		a pointer to the queue name (in a static buffer).
**
**	Side Effects:
**		If no id code is already assigned, queuename() will
**		assign an id code with assign_queueid().  If no queue
**		directory is assigned, one will be set with setnewqueue().
*/

char *
queuename(e, type)
	register ENVELOPE *e;
	int type;
{
	int qd, qg;
	char *sub = "/";
	char pref[3];
	static char buf[MAXPATHLEN];

	/* Assign an ID if needed */
	if (e->e_id == NULL)
	{
		if (IntSig)
			return NULL;
		assign_queueid(e);
	}
	type = queue_letter(e, type);

	/* begin of filename */
	pref[0] = (char) type;
	pref[1] = 'f';
	pref[2] = '\0';

	/* Assign a queue group/directory if needed */
	if (type == XSCRPT_LETTER)
	{
		/*
		**  We don't want to call setnewqueue() if we are fetching
		**  the pathname of the transcript file, because setnewqueue
		**  chooses a queue, and sometimes we need to write to the
		**  transcript file before we have gathered enough information
		**  to choose a queue.
		*/

		if (e->e_xfqgrp == NOQGRP || e->e_xfqdir == NOQDIR)
		{
			if (e->e_qgrp != NOQGRP && e->e_qdir != NOQDIR)
			{
				e->e_xfqgrp = e->e_qgrp;
				e->e_xfqdir = e->e_qdir;
			}
			else
			{
				e->e_xfqgrp = 0;
				if (Queue[e->e_xfqgrp]->qg_numqueues <= 1)
					e->e_xfqdir = 0;
				else
				{
					e->e_xfqdir = get_rand_mod(
					      Queue[e->e_xfqgrp]->qg_numqueues);
				}
			}
		}
		qd = e->e_xfqdir;
		qg = e->e_xfqgrp;
	}
	else
	{
		if (e->e_qgrp == NOQGRP || e->e_qdir == NOQDIR)
		{
			if (IntSig)
				return NULL;
			(void) setnewqueue(e);
		}
		if (type ==  DATAFL_LETTER)
		{
			qd = e->e_dfqdir;
			qg = e->e_dfqgrp;
		}
		else
		{
			qd = e->e_qdir;
			qg = e->e_qgrp;
		}
	}

	/* xf files always have a valid qd and qg picked above */
	if ((qd == NOQDIR || qg == NOQGRP) && type != XSCRPT_LETTER)
		(void) sm_strlcpyn(buf, sizeof(buf), 2, pref, e->e_id);
	else
	{
		switch (type)
		{
		  case DATAFL_LETTER:
			if (bitset(QP_SUBDF, Queue[qg]->qg_qpaths[qd].qp_subdirs))
				sub = "/df/";
			break;

		  case QUARQF_LETTER:
		  case TEMPQF_LETTER:
		  case NEWQFL_LETTER:
		  case LOSEQF_LETTER:
		  case NORMQF_LETTER:
			if (bitset(QP_SUBQF, Queue[qg]->qg_qpaths[qd].qp_subdirs))
				sub = "/qf/";
			break;

		  case XSCRPT_LETTER:
			if (bitset(QP_SUBXF, Queue[qg]->qg_qpaths[qd].qp_subdirs))
				sub = "/xf/";
			break;

		  default:
			if (IntSig)
				return NULL;
			sm_abort("queuename: bad queue file type %d", type);
		}

		(void) sm_strlcpyn(buf, sizeof(buf), 4,
				Queue[qg]->qg_qpaths[qd].qp_name,
				sub, pref, e->e_id);
	}

	if (tTd(7, 2))
		sm_dprintf("queuename: %s\n", buf);
	return buf;
}

/*
**  INIT_QID_ALG -- Initialize the (static) parameters that are used to
**	generate a queue ID.
**
**	This function is called by the daemon to reset
**	LastQueueTime and LastQueuePid which are used by assign_queueid().
**	Otherwise the algorithm may cause problems because
**	LastQueueTime and LastQueuePid are set indirectly by main()
**	before the daemon process is started, hence LastQueuePid is not
**	the pid of the daemon and therefore a child of the daemon can
**	actually have the same pid as LastQueuePid which means the section
**	in  assign_queueid():
**	* see if we need to get a new base time/pid *
**	is NOT triggered which will cause the same queue id to be generated.
**
**	Parameters:
**		none
**
**	Returns:
**		none.
*/

void
init_qid_alg()
{
	LastQueueTime = 0;
	LastQueuePid = -1;
}

/*
**  ASSIGN_QUEUEID -- assign a queue ID for this envelope.
**
**	Assigns an id code if one does not already exist.
**	This code assumes that nothing will remain in the queue for
**	longer than 60 years.  It is critical that files with the given
**	name do not already exist in the queue.
**	[No longer initializes e_qdir to NOQDIR.]
**
**	Parameters:
**		e -- envelope to set it in.
**
**	Returns:
**		none.
*/

static const char QueueIdChars[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
# define QIC_LEN	60
# define QIC_LEN_R	62

/*
**  Note: the length is "officially" 60 because minutes and seconds are
**	usually only 0-59.  However (Linux):
**       tm_sec The number of seconds after the minute, normally in
**		the range 0 to 59, but can be up to 61 to allow for
**		leap seconds.
**	Hence the real length of the string is 62 to take this into account.
**	Alternatively % QIC_LEN can (should) be used for access everywhere.
*/

# define queuenextid() CurrentPid
#define QIC_LEN_SQR	(QIC_LEN * QIC_LEN)

void
assign_queueid(e)
	register ENVELOPE *e;
{
	pid_t pid = queuenextid();
	static unsigned int cX = 0;
	static unsigned int random_offset;
	struct tm *tm;
	char idbuf[MAXQFNAME - 2];
	unsigned int seq;

	if (e->e_id != NULL)
		return;

	/* see if we need to get a new base time/pid */
	if (cX >= QIC_LEN_SQR || LastQueueTime == 0 || LastQueuePid != pid)
	{
		time_t then = LastQueueTime;

		/* if the first time through, pick a random offset */
		if (LastQueueTime == 0)
			random_offset = ((unsigned int)get_random())
					% QIC_LEN_SQR;

		while ((LastQueueTime = curtime()) == then &&
		       LastQueuePid == pid)
		{
			(void) sleep(1);
		}
		LastQueuePid = queuenextid();
		cX = 0;
	}

	/*
	**  Generate a new sequence number between 0 and QIC_LEN_SQR-1.
	**  This lets us generate up to QIC_LEN_SQR unique queue ids
	**  per second, per process.  With envelope splitting,
	**  a single message can consume many queue ids.
	*/

	seq = (cX + random_offset) % QIC_LEN_SQR;
	++cX;
	if (tTd(7, 50))
		sm_dprintf("assign_queueid: random_offset=%u (%u)\n",
			random_offset, seq);

	tm = gmtime(&LastQueueTime);
	idbuf[0] = QueueIdChars[tm->tm_year % QIC_LEN];
	idbuf[1] = QueueIdChars[tm->tm_mon];
	idbuf[2] = QueueIdChars[tm->tm_mday];
	idbuf[3] = QueueIdChars[tm->tm_hour];
	idbuf[4] = QueueIdChars[tm->tm_min % QIC_LEN_R];
	idbuf[5] = QueueIdChars[tm->tm_sec % QIC_LEN_R];
	idbuf[6] = QueueIdChars[seq / QIC_LEN];
	idbuf[7] = QueueIdChars[seq % QIC_LEN];
	(void) sm_snprintf(&idbuf[8], sizeof(idbuf) - 8, "%06d",
			   (int) LastQueuePid);
	e->e_id = sm_rpool_strdup_x(e->e_rpool, idbuf);
	macdefine(&e->e_macro, A_PERM, 'i', e->e_id);
#if 0
	/* XXX: inherited from MainEnvelope */
	e->e_qgrp = NOQGRP;  /* too early to do anything else */
	e->e_qdir = NOQDIR;
	e->e_xfqgrp = NOQGRP;
#endif /* 0 */

	/* New ID means it's not on disk yet */
	e->e_qfletter = '\0';

	if (tTd(7, 1))
		sm_dprintf("assign_queueid: assigned id %s, e=%p\n",
			e->e_id, e);
	if (LogLevel > 93)
		sm_syslog(LOG_DEBUG, e->e_id, "assigned id");
}
/*
**  SYNC_QUEUE_TIME -- Assure exclusive PID in any given second
**
**	Make sure one PID can't be used by two processes in any one second.
**
**		If the system rotates PIDs fast enough, may get the
**		same pid in the same second for two distinct processes.
**		This will interfere with the queue file naming system.
**
**	Parameters:
**		none
**
**	Returns:
**		none
*/

void
sync_queue_time()
{
#if FAST_PID_RECYCLE
	if (OpMode != MD_TEST &&
	    OpMode != MD_CHECKCONFIG &&
	    OpMode != MD_VERIFY &&
	    LastQueueTime > 0 &&
	    LastQueuePid == CurrentPid &&
	    curtime() == LastQueueTime)
		(void) sleep(1);
#endif /* FAST_PID_RECYCLE */
}
/*
**  UNLOCKQUEUE -- unlock the queue entry for a specified envelope
**
**	Parameters:
**		e -- the envelope to unlock.
**
**	Returns:
**		none
**
**	Side Effects:
**		unlocks the queue for `e'.
*/

void
unlockqueue(e)
	ENVELOPE *e;
{
	if (tTd(51, 4))
		sm_dprintf("unlockqueue(%s)\n",
			e->e_id == NULL ? "NOQUEUE" : e->e_id);


	/* if there is a lock file in the envelope, close it */
	if (e->e_lockfp != NULL)
		(void) sm_io_close(e->e_lockfp, SM_TIME_DEFAULT);
	e->e_lockfp = NULL;

	/* don't create a queue id if we don't already have one */
	if (e->e_id == NULL)
		return;

	/* remove the transcript */
	if (LogLevel > 87)
		sm_syslog(LOG_DEBUG, e->e_id, "unlock");
	if (!tTd(51, 104))
		(void) xunlink(queuename(e, XSCRPT_LETTER));
}
/*
**  SETCTLUSER -- create a controlling address
**
**	Create a fake "address" given only a local login name; this is
**	used as a "controlling user" for future recipient addresses.
**
**	Parameters:
**		user -- the user name of the controlling user.
**		qfver -- the version stamp of this queue file.
**		e -- envelope
**
**	Returns:
**		An address descriptor for the controlling user,
**		using storage allocated from e->e_rpool.
**
*/

static ADDRESS *
setctluser(user, qfver, e)
	char *user;
	int qfver;
	ENVELOPE *e;
{
	register ADDRESS *a;
	struct passwd *pw;
	char *p;

	/*
	**  See if this clears our concept of controlling user.
	*/

	if (user == NULL || *user == '\0')
		return NULL;

	/*
	**  Set up addr fields for controlling user.
	*/

	a = (ADDRESS *) sm_rpool_malloc_x(e->e_rpool, sizeof(*a));
	memset((char *) a, '\0', sizeof(*a));

	if (*user == ':')
	{
		p = &user[1];
		a->q_user = sm_rpool_strdup_x(e->e_rpool, p);
	}
	else
	{
		p = strtok(user, ":");
		a->q_user = sm_rpool_strdup_x(e->e_rpool, user);
		if (qfver >= 2)
		{
			if ((p = strtok(NULL, ":")) != NULL)
				a->q_uid = atoi(p);
			if ((p = strtok(NULL, ":")) != NULL)
				a->q_gid = atoi(p);
			if ((p = strtok(NULL, ":")) != NULL)
			{
				char *o;

				a->q_flags |= QGOODUID;

				/* if there is another ':': restore it */
				if ((o = strtok(NULL, ":")) != NULL && o > p)
					o[-1] = ':';
			}
		}
		else if ((pw = sm_getpwnam(user)) != NULL)
		{
			if (*pw->pw_dir == '\0')
				a->q_home = NULL;
			else if (strcmp(pw->pw_dir, "/") == 0)
				a->q_home = "";
			else
				a->q_home = sm_rpool_strdup_x(e->e_rpool, pw->pw_dir);
			a->q_uid = pw->pw_uid;
			a->q_gid = pw->pw_gid;
			a->q_flags |= QGOODUID;
		}
	}

	a->q_flags |= QPRIMARY;		/* flag as a "ctladdr" */
	a->q_mailer = LocalMailer;
	if (p == NULL)
		a->q_paddr = sm_rpool_strdup_x(e->e_rpool, a->q_user);
	else
		a->q_paddr = sm_rpool_strdup_x(e->e_rpool, p);
	return a;
}
/*
**  LOSEQFILE -- rename queue file with LOSEQF_LETTER & try to let someone know
**
**	Parameters:
**		e -- the envelope (e->e_id will be used).
**		why -- reported to whomever can hear.
**
**	Returns:
**		none.
*/

void
loseqfile(e, why)
	register ENVELOPE *e;
	char *why;
{
	bool loseit = true;
	char *p;
	char buf[MAXPATHLEN];

	if (e == NULL || e->e_id == NULL)
		return;
	p = queuename(e, ANYQFL_LETTER);
	if (sm_strlcpy(buf, p, sizeof(buf)) >= sizeof(buf))
		return;
	if (!bitset(EF_INQUEUE, e->e_flags))
		queueup(e, false, true);
	else if (QueueMode == QM_LOST)
		loseit = false;

	/* if already lost, no need to re-lose */
	if (loseit)
	{
		p = queuename(e, LOSEQF_LETTER);
		if (rename(buf, p) < 0)
			syserr("cannot rename(%s, %s), uid=%d",
			       buf, p, (int) geteuid());
		else if (LogLevel > 0)
			sm_syslog(LOG_ALERT, e->e_id,
				  "Losing %s: %s", buf, why);
	}
	if (e->e_dfp != NULL)
	{
		(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT);
		e->e_dfp = NULL;
	}
	e->e_flags &= ~EF_HAS_DF;
}
/*
**  NAME2QID -- translate a queue group name to a queue group id
**
**	Parameters:
**		queuename -- name of queue group.
**
**	Returns:
**		queue group id if found.
**		NOQGRP otherwise.
*/

int
name2qid(queuename)
	char *queuename;
{
	register STAB *s;

	s = stab(queuename, ST_QUEUE, ST_FIND);
	if (s == NULL)
		return NOQGRP;
	return s->s_quegrp->qg_index;
}
/*
**  QID_PRINTNAME -- create externally printable version of queue id
**
**	Parameters:
**		e -- the envelope.
**
**	Returns:
**		a printable version
*/

char *
qid_printname(e)
	ENVELOPE *e;
{
	char *id;
	static char idbuf[MAXQFNAME + 34];

	if (e == NULL)
		return "";

	if (e->e_id == NULL)
		id = "";
	else
		id = e->e_id;

	if (e->e_qdir == NOQDIR)
		return id;

	(void) sm_snprintf(idbuf, sizeof(idbuf), "%.32s/%s",
			   Queue[e->e_qgrp]->qg_qpaths[e->e_qdir].qp_name,
			   id);
	return idbuf;
}
/*
**  QID_PRINTQUEUE -- create full version of queue directory for data files
**
**	Parameters:
**		qgrp -- index in queue group.
**		qdir -- the short version of the queue directory
**
**	Returns:
**		the full pathname to the queue (might point to a static var)
*/

char *
qid_printqueue(qgrp, qdir)
	int qgrp;
	int qdir;
{
	char *subdir;
	static char dir[MAXPATHLEN];

	if (qdir == NOQDIR)
		return Queue[qgrp]->qg_qdir;

	if (strcmp(Queue[qgrp]->qg_qpaths[qdir].qp_name, ".") == 0)
		subdir = NULL;
	else
		subdir = Queue[qgrp]->qg_qpaths[qdir].qp_name;

	(void) sm_strlcpyn(dir, sizeof(dir), 4,
			Queue[qgrp]->qg_qdir,
			subdir == NULL ? "" : "/",
			subdir == NULL ? "" : subdir,
			(bitset(QP_SUBDF,
				Queue[qgrp]->qg_qpaths[qdir].qp_subdirs)
					? "/df" : ""));
	return dir;
}

/*
**  PICKQDIR -- Pick a queue directory from a queue group
**
**	Parameters:
**		qg -- queue group
**		fsize -- file size in bytes
**		e -- envelope, or NULL
**
**	Result:
**		NOQDIR if no queue directory in qg has enough free space to
**		hold a file of size 'fsize', otherwise the index of
**		a randomly selected queue directory which resides on a
**		file system with enough disk space.
**		XXX This could be extended to select a queuedir with
**			a few (the fewest?) number of entries. That data
**			is available if shared memory is used.
**
**	Side Effects:
**		If the request fails and e != NULL then sm_syslog is called.
*/

int
pickqdir(qg, fsize, e)
	QUEUEGRP *qg;
	long fsize;
	ENVELOPE *e;
{
	int qdir;
	int i;
	long avail = 0;

	/* Pick a random directory, as a starting point. */
	if (qg->qg_numqueues <= 1)
		qdir = 0;
	else
		qdir = get_rand_mod(qg->qg_numqueues);

#if _FFR_TESTS
	if (tTd(4, 101))
		return NOQDIR;
#endif /* _FFR_TESTS */
	if (MinBlocksFree <= 0 && fsize <= 0)
		return qdir;

	/*
	**  Now iterate over the queue directories,
	**  looking for a directory with enough space for this message.
	*/

	i = qdir;
	do
	{
		QPATHS *qp = &qg->qg_qpaths[i];
		long needed = 0;
		long fsavail = 0;

		if (fsize > 0)
			needed += fsize / FILE_SYS_BLKSIZE(qp->qp_fsysidx)
				  + ((fsize % FILE_SYS_BLKSIZE(qp->qp_fsysidx)
				      > 0) ? 1 : 0);
		if (MinBlocksFree > 0)
			needed += MinBlocksFree;
		fsavail = FILE_SYS_AVAIL(qp->qp_fsysidx);
#if SM_CONF_SHM
		if (fsavail <= 0)
		{
			long blksize;

			/*
			**  might be not correctly updated,
			**  let's try to get the info directly.
			*/

			fsavail = freediskspace(FILE_SYS_NAME(qp->qp_fsysidx),
						&blksize);
			if (fsavail < 0)
				fsavail = 0;
		}
#endif /* SM_CONF_SHM */
		if (needed <= fsavail)
			return i;
		if (avail < fsavail)
			avail = fsavail;

		if (qg->qg_numqueues > 0)
			i = (i + 1) % qg->qg_numqueues;
	} while (i != qdir);

	if (e != NULL && LogLevel > 0)
		sm_syslog(LOG_ALERT, e->e_id,
			"low on space (%s needs %ld bytes + %ld blocks in %s), max avail: %ld",
			CurHostName == NULL ? "SMTP-DAEMON" : CurHostName,
			fsize, MinBlocksFree,
			qg->qg_qdir, avail);
	return NOQDIR;
}
/*
**  SETNEWQUEUE -- Sets a new queue group and directory
**
**	Assign a queue group and directory to an envelope and store the
**	directory in e->e_qdir.
**
**	Parameters:
**		e -- envelope to assign a queue for.
**
**	Returns:
**		true if successful
**		false otherwise
**
**	Side Effects:
**		On success, e->e_qgrp and e->e_qdir are non-negative.
**		On failure (not enough disk space),
**		e->qgrp = NOQGRP, e->e_qdir = NOQDIR
**		and usrerr() is invoked (which could raise an exception).
*/

bool
setnewqueue(e)
	ENVELOPE *e;
{
	if (tTd(41, 20))
		sm_dprintf("setnewqueue: called\n");

	/* not set somewhere else */
	if (e->e_qgrp == NOQGRP)
	{
		ADDRESS *q;

		/*
		**  Use the queue group of the "first" recipient, as set by
		**  the "queuegroup" rule set.  If that is not defined, then
		**  use the queue group of the mailer of the first recipient.
		**  If that is not defined either, then use the default
		**  queue group.
		**  Notice: "first" depends on the sorting of sendqueue
		**  in recipient().
		**  To avoid problems with "bad" recipients look
		**  for a valid address first.
		*/

		q = e->e_sendqueue;
		while (q != NULL &&
		       (QS_IS_BADADDR(q->q_state) || QS_IS_DEAD(q->q_state)))
		{
			q = q->q_next;
		}
		if (q == NULL)
			e->e_qgrp = 0;
		else if (q->q_qgrp >= 0)
			e->e_qgrp = q->q_qgrp;
		else if (q->q_mailer != NULL &&
			 ISVALIDQGRP(q->q_mailer->m_qgrp))
			e->e_qgrp = q->q_mailer->m_qgrp;
		else
			e->e_qgrp = 0;
		e->e_dfqgrp = e->e_qgrp;
	}

	if (ISVALIDQDIR(e->e_qdir) && ISVALIDQDIR(e->e_dfqdir))
	{
		if (tTd(41, 20))
			sm_dprintf("setnewqueue: e_qdir already assigned (%s)\n",
				qid_printqueue(e->e_qgrp, e->e_qdir));
		return true;
	}

	filesys_update();
	e->e_qdir = pickqdir(Queue[e->e_qgrp], e->e_msgsize, e);
	if (e->e_qdir == NOQDIR)
	{
		e->e_qgrp = NOQGRP;
		if (!bitset(EF_FATALERRS, e->e_flags))
			usrerr("452 4.4.5 Insufficient disk space; try again later");
		e->e_flags |= EF_FATALERRS;
		return false;
	}

	if (tTd(41, 3))
		sm_dprintf("setnewqueue: Assigned queue directory %s\n",
			qid_printqueue(e->e_qgrp, e->e_qdir));

	if (e->e_xfqgrp == NOQGRP || e->e_xfqdir == NOQDIR)
	{
		e->e_xfqgrp = e->e_qgrp;
		e->e_xfqdir = e->e_qdir;
	}
	e->e_dfqdir = e->e_qdir;
	return true;
}
/*
**  CHKQDIR -- check a queue directory
**
**	Parameters:
**		name -- name of queue directory
**		sff -- flags for safefile()
**
**	Returns:
**		is it a queue directory?
*/

static bool chkqdir __P((char *, long));

static bool
chkqdir(name, sff)
	char *name;
	long sff;
{
	struct stat statb;
	int i;

	/* skip over . and .. directories */
	if (name[0] == '.' &&
	    (name[1] == '\0' || (name[1] == '.' && name[2] == '\0')))
		return false;
#if HASLSTAT
	if (lstat(name, &statb) < 0)
#else /* HASLSTAT */
	if (stat(name, &statb) < 0)
#endif /* HASLSTAT */
	{
		if (tTd(41, 2))
			sm_dprintf("chkqdir: stat(\"%s\"): %s\n",
				   name, sm_errstring(errno));
		return false;
	}
#if HASLSTAT
	if (S_ISLNK(statb.st_mode))
	{
		/*
		**  For a symlink we need to make sure the
		**  target is a directory
		*/

		if (stat(name, &statb) < 0)
		{
			if (tTd(41, 2))
				sm_dprintf("chkqdir: stat(\"%s\"): %s\n",
					   name, sm_errstring(errno));
			return false;
		}
	}
#endif /* HASLSTAT */

	if (!S_ISDIR(statb.st_mode))
	{
		if (tTd(41, 2))
			sm_dprintf("chkqdir: \"%s\": Not a directory\n",
				name);
		return false;
	}

	/* Print a warning if unsafe (but still use it) */
	/* XXX do this only if we want the warning? */
	i = safedirpath(name, RunAsUid, RunAsGid, NULL, sff, 0, 0);
	if (i != 0)
	{
		if (tTd(41, 2))
			sm_dprintf("chkqdir: \"%s\": Not safe: %s\n",
				   name, sm_errstring(i));
#if _FFR_CHK_QUEUE
		if (LogLevel > 8)
			sm_syslog(LOG_WARNING, NOQID,
				  "queue directory \"%s\": Not safe: %s",
				  name, sm_errstring(i));
#endif /* _FFR_CHK_QUEUE */
	}
	return true;
}
/*
**  MULTIQUEUE_CACHE -- cache a list of paths to queues.
**
**	Each potential queue is checked as the cache is built.
**	Thereafter, each is blindly trusted.
**	Note that we can be called again after a timeout to rebuild
**	(although code for that is not ready yet).
**
**	Parameters:
**		basedir -- base of all queue directories.
**		blen -- strlen(basedir).
**		qg -- queue group.
**		qn -- number of queue directories already cached.
**		phash -- pointer to hash value over queue dirs.
#if SM_CONF_SHM
**			only used if shared memory is active.
#endif * SM_CONF_SHM *
**
**	Returns:
**		new number of queue directories.
*/

#define INITIAL_SLOTS	20
#define ADD_SLOTS	10

static int
multiqueue_cache(basedir, blen, qg, qn, phash)
	char *basedir;
	int blen;
	QUEUEGRP *qg;
	int qn;
	unsigned int *phash;
{
	char *cp;
	int i, len;
	int slotsleft = 0;
	long sff = SFF_ANYFILE;
	char qpath[MAXPATHLEN];
	char subdir[MAXPATHLEN];
	char prefix[MAXPATHLEN];	/* dir relative to basedir */

	if (tTd(41, 20))
		sm_dprintf("multiqueue_cache: called\n");

	/* Initialize to current directory */
	prefix[0] = '.';
	prefix[1] = '\0';
	if (qg->qg_numqueues != 0 && qg->qg_qpaths != NULL)
	{
		for (i = 0; i < qg->qg_numqueues; i++)
		{
			if (qg->qg_qpaths[i].qp_name != NULL)
				(void) sm_free(qg->qg_qpaths[i].qp_name); /* XXX */
		}
		(void) sm_free((char *) qg->qg_qpaths); /* XXX */
		qg->qg_qpaths = NULL;
		qg->qg_numqueues = 0;
	}

	/* If running as root, allow safedirpath() checks to use privs */
	if (RunAsUid == 0)
		sff |= SFF_ROOTOK;
#if _FFR_CHK_QUEUE
	sff |= SFF_SAFEDIRPATH|SFF_NOWWFILES;
	if (!UseMSP)
		sff |= SFF_NOGWFILES;
#endif /* _FFR_CHK_QUEUE */

	if (!SM_IS_DIR_START(qg->qg_qdir))
	{
		/*
		**  XXX we could add basedir, but then we have to realloc()
		**  the string... Maybe another time.
		*/

		syserr("QueuePath %s not absolute", qg->qg_qdir);
		ExitStat = EX_CONFIG;
		return qn;
	}

	/* qpath: directory of current workgroup */
	len = sm_strlcpy(qpath, qg->qg_qdir, sizeof(qpath));
	if (len >= sizeof(qpath))
	{
		syserr("QueuePath %.256s too long (%d max)",
		       qg->qg_qdir, (int) sizeof(qpath));
		ExitStat = EX_CONFIG;
		return qn;
	}

	/* begin of qpath must be same as basedir */
	if (strncmp(basedir, qpath, blen) != 0 &&
	    (strncmp(basedir, qpath, blen - 1) != 0 || len != blen - 1))
	{
		syserr("QueuePath %s not subpath of QueueDirectory %s",
			qpath, basedir);
		ExitStat = EX_CONFIG;
		return qn;
	}

	/* Do we have a nested subdirectory? */
	if (blen < len && SM_FIRST_DIR_DELIM(qg->qg_qdir + blen) != NULL)
	{

		/* Copy subdirectory into prefix for later use */
		if (sm_strlcpy(prefix, qg->qg_qdir + blen, sizeof(prefix)) >=
		    sizeof(prefix))
		{
			syserr("QueuePath %.256s too long (%d max)",
				qg->qg_qdir, (int) sizeof(qpath));
			ExitStat = EX_CONFIG;
			return qn;
		}
		cp = SM_LAST_DIR_DELIM(prefix);
		SM_ASSERT(cp != NULL);
		*cp = '\0';	/* cut off trailing / */
	}

	/* This is guaranteed by the basedir check above */
	SM_ASSERT(len >= blen - 1);
	cp = &qpath[len - 1];
	if (*cp == '*')
	{
		register DIR *dp;
		register struct dirent *d;
		int off;
		char *delim;
		char relpath[MAXPATHLEN];

		*cp = '\0';	/* Overwrite wildcard */
		if ((cp = SM_LAST_DIR_DELIM(qpath)) == NULL)
		{
			syserr("QueueDirectory: can not wildcard relative path");
			if (tTd(41, 2))
				sm_dprintf("multiqueue_cache: \"%s*\": Can not wildcard relative path.\n",
					qpath);
			ExitStat = EX_CONFIG;
			return qn;
		}
		if (cp == qpath)
		{
			/*
			**  Special case of top level wildcard, like /foo*
			**	Change to //foo*
			*/

			(void) sm_strlcpy(qpath + 1, qpath, sizeof(qpath) - 1);
			++cp;
		}
		delim = cp;
		*(cp++) = '\0';		/* Replace / with \0 */
		len = strlen(cp);	/* Last component of queue directory */

		/*
		**  Path relative to basedir, with trailing /
		**  It will be modified below to specify the subdirectories
		**  so they can be opened without chdir().
		*/

		off = sm_strlcpyn(relpath, sizeof(relpath), 2, prefix, "/");
		SM_ASSERT(off < sizeof(relpath));

		if (tTd(41, 2))
			sm_dprintf("multiqueue_cache: prefix=\"%s%s\"\n",
				   relpath, cp);

		/* It is always basedir: we don't need to store it per group */
		/* XXX: optimize this! -> one more global? */
		qg->qg_qdir = newstr(basedir);
		qg->qg_qdir[blen - 1] = '\0';	/* cut off trailing / */

		/*
		**  XXX Should probably wrap this whole loop in a timeout
		**  in case some wag decides to NFS mount the queues.
		*/

		/* Test path to get warning messages. */
		if (qn == 0)
		{
			/*  XXX qg_runasuid and qg_runasgid for specials? */
			i = safedirpath(basedir, RunAsUid, RunAsGid, NULL,
					sff, 0, 0);
			if (i != 0 && tTd(41, 2))
				sm_dprintf("multiqueue_cache: \"%s\": Not safe: %s\n",
					   basedir, sm_errstring(i));
		}

		if ((dp = opendir(prefix)) == NULL)
		{
			syserr("can not opendir(%s/%s)", qg->qg_qdir, prefix);
			if (tTd(41, 2))
				sm_dprintf("multiqueue_cache: opendir(\"%s/%s\"): %s\n",
					   qg->qg_qdir, prefix,
					   sm_errstring(errno));
			ExitStat = EX_CONFIG;
			return qn;
		}
		while ((d = readdir(dp)) != NULL)
		{
			/* Skip . and .. directories */
			if (strcmp(d->d_name, ".") == 0 ||
			    strcmp(d->d_name, "..") == 0)
				continue;

			i = strlen(d->d_name);
			if (i < len || strncmp(d->d_name, cp, len) != 0)
			{
				if (tTd(41, 5))
					sm_dprintf("multiqueue_cache: \"%s\", skipped\n",
						d->d_name);
				continue;
			}

			/* Create relative pathname: prefix + local directory */
			i = sizeof(relpath) - off;
			if (sm_strlcpy(relpath + off, d->d_name, i) >= i)
				continue;	/* way too long */

			if (!chkqdir(relpath, sff))
				continue;

			if (qg->qg_qpaths == NULL)
			{
				slotsleft = INITIAL_SLOTS;
				qg->qg_qpaths = (QPATHS *)xalloc((sizeof(*qg->qg_qpaths)) *
								slotsleft);
				qg->qg_numqueues = 0;
			}
			else if (slotsleft < 1)
			{
				qg->qg_qpaths = (QPATHS *)sm_realloc((char *)qg->qg_qpaths,
							  (sizeof(*qg->qg_qpaths)) *
							  (qg->qg_numqueues +
							   ADD_SLOTS));
				if (qg->qg_qpaths == NULL)
				{
					(void) closedir(dp);
					return qn;
				}
				slotsleft += ADD_SLOTS;
			}

			/* check subdirs */
			qg->qg_qpaths[qg->qg_numqueues].qp_subdirs = QP_NOSUB;

#define CHKRSUBDIR(name, flag)	\
	(void) sm_strlcpyn(subdir, sizeof(subdir), 3, relpath, "/", name); \
	if (chkqdir(subdir, sff))	\
		qg->qg_qpaths[qg->qg_numqueues].qp_subdirs |= flag;	\
	else


			CHKRSUBDIR("qf", QP_SUBQF);
			CHKRSUBDIR("df", QP_SUBDF);
			CHKRSUBDIR("xf", QP_SUBXF);

			/* assert(strlen(d->d_name) < MAXPATHLEN - 14) */
			/* maybe even - 17 (subdirs) */

			if (prefix[0] != '.')
				qg->qg_qpaths[qg->qg_numqueues].qp_name =
					newstr(relpath);
			else
				qg->qg_qpaths[qg->qg_numqueues].qp_name =
					newstr(d->d_name);

			if (tTd(41, 2))
				sm_dprintf("multiqueue_cache: %d: \"%s\" cached (%x).\n",
					qg->qg_numqueues, relpath,
					qg->qg_qpaths[qg->qg_numqueues].qp_subdirs);
#if SM_CONF_SHM
			qg->qg_qpaths[qg->qg_numqueues].qp_idx = qn;
			*phash = hash_q(relpath, *phash);
#endif /* SM_CONF_SHM */
			qg->qg_numqueues++;
			++qn;
			slotsleft--;
		}
		(void) closedir(dp);

		/* undo damage */
		*delim = '/';
	}
	if (qg->qg_numqueues == 0)
	{
		qg->qg_qpaths = (QPATHS *) xalloc(sizeof(*qg->qg_qpaths));

		/* test path to get warning messages */
		i = safedirpath(qpath, RunAsUid, RunAsGid, NULL, sff, 0, 0);
		if (i == ENOENT)
		{
			syserr("can not opendir(%s)", qpath);
			if (tTd(41, 2))
				sm_dprintf("multiqueue_cache: opendir(\"%s\"): %s\n",
					   qpath, sm_errstring(i));
			ExitStat = EX_CONFIG;
			return qn;
		}

		qg->qg_qpaths[0].qp_subdirs = QP_NOSUB;
		qg->qg_numqueues = 1;

		/* check subdirs */
#define CHKSUBDIR(name, flag)	\
	(void) sm_strlcpyn(subdir, sizeof(subdir), 3, qg->qg_qdir, "/", name); \
	if (chkqdir(subdir, sff))	\
		qg->qg_qpaths[0].qp_subdirs |= flag;	\
	else

		CHKSUBDIR("qf", QP_SUBQF);
		CHKSUBDIR("df", QP_SUBDF);
		CHKSUBDIR("xf", QP_SUBXF);

		if (qg->qg_qdir[blen - 1] != '\0' &&
		    qg->qg_qdir[blen] != '\0')
		{
			/*
			**  Copy the last component into qpaths and
			**  cut off qdir
			*/

			qg->qg_qpaths[0].qp_name = newstr(qg->qg_qdir + blen);
			qg->qg_qdir[blen - 1] = '\0';
		}
		else
			qg->qg_qpaths[0].qp_name = newstr(".");

#if SM_CONF_SHM
		qg->qg_qpaths[0].qp_idx = qn;
		*phash = hash_q(qg->qg_qpaths[0].qp_name, *phash);
#endif /* SM_CONF_SHM */
		++qn;
	}
	return qn;
}

/*
**  FILESYS_FIND -- find entry in FileSys table, or add new one
**
**	Given the pathname of a directory, determine the file system
**	in which that directory resides, and return a pointer to the
**	entry in the FileSys table that describes the file system.
**	A new entry is added if necessary (and requested).
**	If the directory does not exist, -1 is returned.
**
**	Parameters:
**		name -- name of directory (must be persistent!)
**		path -- pathname of directory (name plus maybe "/df")
**		add -- add to structure if not found.
**
**	Returns:
**		>=0: found: index in file system table
**		<0: some error, i.e.,
**		FSF_TOO_MANY: too many filesystems (-> syserr())
**		FSF_STAT_FAIL: can't stat() filesystem (-> syserr())
**		FSF_NOT_FOUND: not in list
*/

static short filesys_find __P((const char *, const char *, bool));

#define FSF_NOT_FOUND	(-1)
#define FSF_STAT_FAIL	(-2)
#define FSF_TOO_MANY	(-3)

static short
filesys_find(name, path, add)
	const char *name;
	const char *path;
	bool add;
{
	struct stat st;
	short i;

	if (stat(path, &st) < 0)
	{
		syserr("cannot stat queue directory %s", path);
		return FSF_STAT_FAIL;
	}
	for (i = 0; i < NumFileSys; ++i)
	{
		if (FILE_SYS_DEV(i) == st.st_dev)
		{
			/*
			**  Make sure the file system (FS) name is set:
			**  even though the source code indicates that
			**  FILE_SYS_DEV() is only set below, it could be
			**  set via shared memory, hence we need to perform
			**  this check/assignment here.
			*/

			if (NULL == FILE_SYS_NAME(i))
				FILE_SYS_NAME(i) = name;
			return i;
		}
	}
	if (i >= MAXFILESYS)
	{
		syserr("too many queue file systems (%d max)", MAXFILESYS);
		return FSF_TOO_MANY;
	}
	if (!add)
		return FSF_NOT_FOUND;

	++NumFileSys;
	FILE_SYS_NAME(i) = name;
	FILE_SYS_DEV(i) = st.st_dev;
	FILE_SYS_AVAIL(i) = 0;
	FILE_SYS_BLKSIZE(i) = 1024; /* avoid divide by zero */
	return i;
}

/*
**  FILESYS_SETUP -- set up mapping from queue directories to file systems
**
**	This data structure is used to efficiently check the amount of
**	free space available in a set of queue directories.
**
**	Parameters:
**		add -- initialize structure if necessary.
**
**	Returns:
**		0: success
**		<0: some error, i.e.,
**		FSF_NOT_FOUND: not in list
**		FSF_STAT_FAIL: can't stat() filesystem (-> syserr())
**		FSF_TOO_MANY: too many filesystems (-> syserr())
*/

static int filesys_setup __P((bool));

static int
filesys_setup(add)
	bool add;
{
	int i, j;
	short fs;
	int ret;

	ret = 0;
	for (i = 0; i < NumQueue && Queue[i] != NULL; i++)
	{
		for (j = 0; j < Queue[i]->qg_numqueues; ++j)
		{
			QPATHS *qp = &Queue[i]->qg_qpaths[j];
			char qddf[MAXPATHLEN];

			(void) sm_strlcpyn(qddf, sizeof(qddf), 2, qp->qp_name,
					(bitset(QP_SUBDF, qp->qp_subdirs)
						? "/df" : ""));
			fs = filesys_find(qp->qp_name, qddf, add);
			if (fs >= 0)
				qp->qp_fsysidx = fs;
			else
				qp->qp_fsysidx = 0;
			if (fs < ret)
				ret = fs;
		}
	}
	return ret;
}

/*
**  FILESYS_UPDATE -- update amount of free space on all file systems
**
**	The FileSys table is used to cache the amount of free space
**	available on all queue directory file systems.
**	This function updates the cached information if it has expired.
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Updates FileSys table.
*/

void
filesys_update()
{
	int i;
	long avail, blksize;
	time_t now;
	static time_t nextupdate = 0;

#if SM_CONF_SHM
	/*
	**  Only the daemon updates the shared memory, i.e.,
	**  if shared memory is available but the pid is not the
	**  one of the daemon, then don't do anything.
	*/

	if (ShmId != SM_SHM_NO_ID && DaemonPid != CurrentPid)
		return;
#endif /* SM_CONF_SHM */
	now = curtime();
	if (now < nextupdate)
		return;
	nextupdate = now + FILESYS_UPDATE_INTERVAL;
	for (i = 0; i < NumFileSys; ++i)
	{
		FILESYS *fs = &FILE_SYS(i);

		avail = freediskspace(FILE_SYS_NAME(i), &blksize);
		if (avail < 0 || blksize <= 0)
		{
			if (LogLevel > 5)
				sm_syslog(LOG_ERR, NOQID,
					"filesys_update failed: %s, fs=%s, avail=%ld, blocksize=%ld",
					sm_errstring(errno),
					FILE_SYS_NAME(i), avail, blksize);
			fs->fs_avail = 0;
			fs->fs_blksize = 1024; /* avoid divide by zero */
			nextupdate = now + 2; /* let's do this soon again */
		}
		else
		{
			fs->fs_avail = avail;
			fs->fs_blksize = blksize;
		}
	}
}

#if _FFR_ANY_FREE_FS
/*
**  FILESYS_FREE -- check whether there is at least one fs with enough space.
**
**	Parameters:
**		fsize -- file size in bytes
**
**	Returns:
**		true iff there is one fs with more than fsize bytes free.
*/

bool
filesys_free(fsize)
	long fsize;
{
	int i;

	if (fsize <= 0)
		return true;
	for (i = 0; i < NumFileSys; ++i)
	{
		long needed = 0;

		if (FILE_SYS_AVAIL(i) < 0 || FILE_SYS_BLKSIZE(i) <= 0)
			continue;
		needed += fsize / FILE_SYS_BLKSIZE(i)
			  + ((fsize % FILE_SYS_BLKSIZE(i)
			      > 0) ? 1 : 0)
			  + MinBlocksFree;
		if (needed <= FILE_SYS_AVAIL(i))
			return true;
	}
	return false;
}
#endif /* _FFR_ANY_FREE_FS */

/*
**  DISK_STATUS -- show amount of free space in queue directories
**
**	Parameters:
**		out -- output file pointer.
**		prefix -- string to output in front of each line.
**
**	Returns:
**		none.
*/

void
disk_status(out, prefix)
	SM_FILE_T *out;
	char *prefix;
{
	int i;
	long avail, blksize;
	long free;

	for (i = 0; i < NumFileSys; ++i)
	{
		avail = freediskspace(FILE_SYS_NAME(i), &blksize);
		if (avail >= 0 && blksize > 0)
		{
			free = (long)((double) avail *
				((double) blksize / 1024));
		}
		else
			free = -1;
		(void) sm_io_fprintf(out, SM_TIME_DEFAULT,
				"%s%d/%s/%ld\r\n",
				prefix, i,
				FILE_SYS_NAME(i),
					free);
	}
}

#if SM_CONF_SHM

/*
**  INIT_SEM -- initialize semaphore system
**
**	Parameters:
**		owner -- is this the owner of semaphores?
**
**	Returns:
**		none.
*/

#if _FFR_USE_SEM_LOCKING
#if SM_CONF_SEM
static int SemId = -1;		/* Semaphore Id */
int SemKey = SM_SEM_KEY;
#endif /* SM_CONF_SEM */
#endif /* _FFR_USE_SEM_LOCKING */

static void init_sem __P((bool));

static void
init_sem(owner)
	bool owner;
{
#if _FFR_USE_SEM_LOCKING
#if SM_CONF_SEM
	SemId = sm_sem_start(SemKey, 1, 0, owner);
	if (SemId < 0)
	{
		sm_syslog(LOG_ERR, NOQID,
			"func=init_sem, sem_key=%ld, sm_sem_start=%d, error=%s",
			(long) SemKey, SemId, sm_errstring(-SemId));
		return;
	}
	if (owner && RunAsUid != 0)
	{
		int r;

		r = sm_semsetowner(SemId, RunAsUid, RunAsGid, 0660);
		if (r != 0)
			sm_syslog(LOG_ERR, NOQID,
				"key=%ld, sm_semsetowner=%d, RunAsUid=%d, RunAsGid=%d",
				(long) SemKey, r, RunAsUid, RunAsGid);
	}
#endif /* SM_CONF_SEM */
#endif /* _FFR_USE_SEM_LOCKING */
	return;
}

/*
**  STOP_SEM -- stop semaphore system
**
**	Parameters:
**		owner -- is this the owner of semaphores?
**
**	Returns:
**		none.
*/

static void stop_sem __P((bool));

static void
stop_sem(owner)
	bool owner;
{
#if _FFR_USE_SEM_LOCKING
#if SM_CONF_SEM
	if (owner && SemId >= 0)
		sm_sem_stop(SemId);
#endif /* SM_CONF_SEM */
#endif /* _FFR_USE_SEM_LOCKING */
	return;
}

/*
**  UPD_QS -- update information about queue when adding/deleting an entry
**
**	Parameters:
**		e -- envelope.
**		count -- add/remove entry (+1/0/-1: add/no change/remove)
**		space -- update the space available as well.
**			(>0/0/<0: add/no change/remove)
**		where -- caller (for logging)
**
**	Returns:
**		none.
**
**	Side Effects:
**		Modifies available space in filesystem.
**		Changes number of entries in queue directory.
*/

void
upd_qs(e, count, space, where)
	ENVELOPE *e;
	int count;
	int space;
	char *where;
{
	short fidx;
	int idx;
# if _FFR_USE_SEM_LOCKING
	int r;
# endif /* _FFR_USE_SEM_LOCKING */
	long s;

	if (ShmId == SM_SHM_NO_ID || e == NULL)
		return;
	if (e->e_qgrp == NOQGRP || e->e_qdir == NOQDIR)
		return;
	idx = Queue[e->e_qgrp]->qg_qpaths[e->e_qdir].qp_idx;
	if (tTd(73,2))
		sm_dprintf("func=upd_qs, count=%d, space=%d, where=%s, idx=%d, entries=%d\n",
			count, space, where, idx, QSHM_ENTRIES(idx));

	/* XXX in theory this needs to be protected with a mutex */
	if (QSHM_ENTRIES(idx) >= 0 && count != 0)
	{
# if _FFR_USE_SEM_LOCKING
		r = sm_sem_acq(SemId, 0, 1);
# endif /* _FFR_USE_SEM_LOCKING */
		QSHM_ENTRIES(idx) += count;
# if _FFR_USE_SEM_LOCKING
		if (r >= 0)
			r = sm_sem_rel(SemId, 0, 1);
# endif /* _FFR_USE_SEM_LOCKING */
	}

	fidx = Queue[e->e_qgrp]->qg_qpaths[e->e_qdir].qp_fsysidx;
	if (fidx < 0)
		return;

	/* update available space also?  (might be loseqfile) */
	if (space == 0)
		return;

	/* convert size to blocks; this causes rounding errors */
	s = e->e_msgsize / FILE_SYS_BLKSIZE(fidx);
	if (s == 0)
		return;

	/* XXX in theory this needs to be protected with a mutex */
	if (space > 0)
		FILE_SYS_AVAIL(fidx) += s;
	else
		FILE_SYS_AVAIL(fidx) -= s;

}

static bool write_key_file __P((char *, long));
static long read_key_file __P((char *, long));

/*
**  WRITE_KEY_FILE -- record some key into a file.
**
**	Parameters:
**		keypath -- file name.
**		key -- key to write.
**
**	Returns:
**		true iff file could be written.
**
**	Side Effects:
**		writes file.
*/

static bool
write_key_file(keypath, key)
	char *keypath;
	long key;
{
	bool ok;
	long sff;
	SM_FILE_T *keyf;

	ok = false;
	if (keypath == NULL || *keypath == '\0')
		return ok;
	sff = SFF_NOLINK|SFF_ROOTOK|SFF_REGONLY|SFF_CREAT;
	if (TrustedUid != 0 && RealUid == TrustedUid)
		sff |= SFF_OPENASROOT;
	keyf = safefopen(keypath, O_WRONLY|O_TRUNC, FileMode, sff);
	if (keyf == NULL)
	{
		sm_syslog(LOG_ERR, NOQID, "unable to write %s: %s",
			  keypath, sm_errstring(errno));
	}
	else
	{
		if (geteuid() == 0 && RunAsUid != 0)
		{
#  if HASFCHOWN
			int fd;

			fd = keyf->f_file;
			if (fd >= 0 && fchown(fd, RunAsUid, -1) < 0)
			{
				int err = errno;

				sm_syslog(LOG_ALERT, NOQID,
					  "ownership change on %s to %d failed: %s",
					  keypath, RunAsUid, sm_errstring(err));
			}
#  endif /* HASFCHOWN */
		}
		ok = sm_io_fprintf(keyf, SM_TIME_DEFAULT, "%ld\n", key) !=
		     SM_IO_EOF;
		ok = (sm_io_close(keyf, SM_TIME_DEFAULT) != SM_IO_EOF) && ok;
	}
	return ok;
}

/*
**  READ_KEY_FILE -- read a key from a file.
**
**	Parameters:
**		keypath -- file name.
**		key -- default key.
**
**	Returns:
**		key.
*/

static long
read_key_file(keypath, key)
	char *keypath;
	long key;
{
	int r;
	long sff, n;
	SM_FILE_T *keyf;

	if (keypath == NULL || *keypath == '\0')
		return key;
	sff = SFF_NOLINK|SFF_ROOTOK|SFF_REGONLY;
	if (RealUid == 0 || (TrustedUid != 0 && RealUid == TrustedUid))
		sff |= SFF_OPENASROOT;
	keyf = safefopen(keypath, O_RDONLY, FileMode, sff);
	if (keyf == NULL)
	{
		sm_syslog(LOG_ERR, NOQID, "unable to read %s: %s",
			  keypath, sm_errstring(errno));
	}
	else
	{
		r = sm_io_fscanf(keyf, SM_TIME_DEFAULT, "%ld", &n);
		if (r == 1)
			key = n;
		(void) sm_io_close(keyf, SM_TIME_DEFAULT);
	}
	return key;
}

/*
**  INIT_SHM -- initialize shared memory structure
**
**	Initialize or attach to shared memory segment.
**	Currently it is not a fatal error if this doesn't work.
**	However, it causes us to have a "fallback" storage location
**	for everything that is supposed to be in the shared memory,
**	which makes the code slightly ugly.
**
**	Parameters:
**		qn -- number of queue directories.
**		owner -- owner of shared memory.
**		hash -- identifies data that is stored in shared memory.
**
**	Returns:
**		none.
*/

static void init_shm __P((int, bool, unsigned int));

static void
init_shm(qn, owner, hash)
	int qn;
	bool owner;
	unsigned int hash;
{
	int i;
	int count;
	int save_errno;
	bool keyselect;

	PtrFileSys = &FileSys[0];
	PNumFileSys = &Numfilesys;
/* if this "key" is specified: select one yourself */
#define SEL_SHM_KEY	((key_t) -1)
#define FIRST_SHM_KEY	25

	/* This allows us to disable shared memory at runtime. */
	if (ShmKey == 0)
		return;

	count = 0;
	shms = SM_T_SIZE + qn * sizeof(QUEUE_SHM_T);
	keyselect = ShmKey == SEL_SHM_KEY;
	if (keyselect)
	{
		if (owner)
			ShmKey = FIRST_SHM_KEY;
		else
		{
			errno = 0;
			ShmKey = read_key_file(ShmKeyFile, ShmKey);
			keyselect = false;
			if (ShmKey == SEL_SHM_KEY)
			{
				save_errno = (errno != 0) ? errno : EINVAL;
				goto error;
			}
		}
	}
	for (;;)
	{
		/* allow read/write access for group? */
		Pshm = sm_shmstart(ShmKey, shms,
				SHM_R|SHM_W|(SHM_R>>3)|(SHM_W>>3),
				&ShmId, owner);
		save_errno = errno;
		if (Pshm != NULL || !sm_file_exists(save_errno))
			break;
		if (++count >= 3)
		{
			if (keyselect)
			{
				++ShmKey;

				/* back where we started? */
				if (ShmKey == SEL_SHM_KEY)
					break;
				continue;
			}
			break;
		}

		/* only sleep if we are at the first key */
		if (!keyselect || ShmKey == SEL_SHM_KEY)
			sleep(count);
	}
	if (Pshm != NULL)
	{
		int *p;

		if (keyselect)
			(void) write_key_file(ShmKeyFile, (long) ShmKey);
		if (owner && RunAsUid != 0)
		{
			i = sm_shmsetowner(ShmId, RunAsUid, RunAsGid, 0660);
			if (i != 0)
				sm_syslog(LOG_ERR, NOQID,
					"key=%ld, sm_shmsetowner=%d, RunAsUid=%d, RunAsGid=%d",
					(long) ShmKey, i, RunAsUid, RunAsGid);
		}
		p = (int *) Pshm;
		if (owner)
		{
			*p = (int) shms;
			*((pid_t *) SHM_OFF_PID(Pshm)) = CurrentPid;
			p = (int *) SHM_OFF_TAG(Pshm);
			*p = hash;
		}
		else
		{
			if (*p != (int) shms)
			{
				save_errno = EINVAL;
				cleanup_shm(false);
				goto error;
			}
			p = (int *) SHM_OFF_TAG(Pshm);
			if (*p != (int) hash)
			{
				save_errno = EINVAL;
				cleanup_shm(false);
				goto error;
			}

			/*
			**  XXX how to check the pid?
			**  Read it from the pid-file? That does
			**  not need to exist.
			**  We could disable shm if we can't confirm
			**  that it is the right one.
			*/
		}

		PtrFileSys = (FILESYS *) OFF_FILE_SYS(Pshm);
		PNumFileSys = (int *) OFF_NUM_FILE_SYS(Pshm);
		QShm = (QUEUE_SHM_T *) OFF_QUEUE_SHM(Pshm);
		PRSATmpCnt = (int *) OFF_RSA_TMP_CNT(Pshm);
		*PRSATmpCnt = 0;
		if (owner)
		{
			/* initialize values in shared memory */
			NumFileSys = 0;
			for (i = 0; i < qn; i++)
				QShm[i].qs_entries = -1;
		}
		init_sem(owner);
		return;
	}
  error:
	if (LogLevel > (owner ? 8 : 11))
	{
		sm_syslog(owner ? LOG_ERR : LOG_NOTICE, NOQID,
			  "can't %s shared memory, key=%ld: %s",
			  owner ? "initialize" : "attach to",
			  (long) ShmKey, sm_errstring(save_errno));
	}
}
#endif /* SM_CONF_SHM */


/*
**  SETUP_QUEUES -- set up all queue groups
**
**	Parameters:
**		owner -- owner of shared memory?
**
**	Returns:
**		none.
**
#if SM_CONF_SHM
**	Side Effects:
**		attaches shared memory.
#endif * SM_CONF_SHM *
*/

void
setup_queues(owner)
	bool owner;
{
	int i, qn, len;
	unsigned int hashval;
	time_t now;
	char basedir[MAXPATHLEN];
	struct stat st;

	/*
	**  Determine basedir for all queue directories.
	**  All queue directories must be (first level) subdirectories
	**  of the basedir.  The basedir is the QueueDir
	**  without wildcards, but with trailing /
	*/

	hashval = 0;
	errno = 0;
	len = sm_strlcpy(basedir, QueueDir, sizeof(basedir));

	/* Provide space for trailing '/' */
	if (len >= sizeof(basedir) - 1)
	{
		syserr("QueueDirectory: path too long: %d,  max %d",
			len, (int) sizeof(basedir) - 1);
		ExitStat = EX_CONFIG;
		return;
	}
	SM_ASSERT(len > 0);
	if (basedir[len - 1] == '*')
	{
		char *cp;

		cp = SM_LAST_DIR_DELIM(basedir);
		if (cp == NULL)
		{
			syserr("QueueDirectory: can not wildcard relative path \"%s\"",
				QueueDir);
			if (tTd(41, 2))
				sm_dprintf("setup_queues: \"%s\": Can not wildcard relative path.\n",
					QueueDir);
			ExitStat = EX_CONFIG;
			return;
		}

		/* cut off wildcard pattern */
		*++cp = '\0';
		len = cp - basedir;
	}
	else if (!SM_IS_DIR_DELIM(basedir[len - 1]))
	{
		/* append trailing slash since it is a directory */
		basedir[len] = '/';
		basedir[++len] = '\0';
	}

	/* len counts up to the last directory delimiter */
	SM_ASSERT(basedir[len - 1] == '/');

	if (chdir(basedir) < 0)
	{
		int save_errno = errno;

		syserr("can not chdir(%s)", basedir);
		if (save_errno == EACCES)
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				"Program mode requires special privileges, e.g., root or TrustedUser.\n");
		if (tTd(41, 2))
			sm_dprintf("setup_queues: \"%s\": %s\n",
				   basedir, sm_errstring(errno));
		ExitStat = EX_CONFIG;
		return;
	}
#if SM_CONF_SHM
	hashval = hash_q(basedir, hashval);
#endif /* SM_CONF_SHM */

	/* initialize for queue runs */
	DoQueueRun = false;
	now = curtime();
	for (i = 0; i < NumQueue && Queue[i] != NULL; i++)
		Queue[i]->qg_nextrun = now;


	if (UseMSP && OpMode != MD_TEST)
	{
		long sff = SFF_CREAT;

		if (stat(".", &st) < 0)
		{
			syserr("can not stat(%s)", basedir);
			if (tTd(41, 2))
				sm_dprintf("setup_queues: \"%s\": %s\n",
					   basedir, sm_errstring(errno));
			ExitStat = EX_CONFIG;
			return;
		}
		if (RunAsUid == 0)
			sff |= SFF_ROOTOK;

		/*
		**  Check queue directory permissions.
		**	Can we write to a group writable queue directory?
		*/

		if (bitset(S_IWGRP, QueueFileMode) &&
		    bitset(S_IWGRP, st.st_mode) &&
		    safefile(" ", RunAsUid, RunAsGid, RunAsUserName, sff,
			     QueueFileMode, NULL) != 0)
		{
			syserr("can not write to queue directory %s (RunAsGid=%d, required=%d)",
				basedir, (int) RunAsGid, (int) st.st_gid);
		}
		if (bitset(S_IWOTH|S_IXOTH, st.st_mode))
		{
#if _FFR_MSP_PARANOIA
			syserr("dangerous permissions=%o on queue directory %s",
				(int) st.st_mode, basedir);
#else /* _FFR_MSP_PARANOIA */
			if (LogLevel > 0)
				sm_syslog(LOG_ERR, NOQID,
					  "dangerous permissions=%o on queue directory %s",
					  (int) st.st_mode, basedir);
#endif /* _FFR_MSP_PARANOIA */
		}
#if _FFR_MSP_PARANOIA
		if (NumQueue > 1)
			syserr("can not use multiple queues for MSP");
#endif /* _FFR_MSP_PARANOIA */
	}

	/* initial number of queue directories */
	qn = 0;
	for (i = 0; i < NumQueue && Queue[i] != NULL; i++)
		qn = multiqueue_cache(basedir, len, Queue[i], qn, &hashval);

#if SM_CONF_SHM
	init_shm(qn, owner, hashval);
	i = filesys_setup(owner || ShmId == SM_SHM_NO_ID);
	if (i == FSF_NOT_FOUND)
	{
		/*
		**  We didn't get the right filesystem data
		**  This may happen if we don't have the right shared memory.
		**  So let's do this without shared memory.
		*/

		SM_ASSERT(!owner);
		cleanup_shm(false);	/* release shared memory */
		i = filesys_setup(false);
		if (i < 0)
			syserr("filesys_setup failed twice, result=%d", i);
		else if (LogLevel > 8)
			sm_syslog(LOG_WARNING, NOQID,
				  "shared memory does not contain expected data, ignored");
	}
#else /* SM_CONF_SHM */
	i = filesys_setup(true);
#endif /* SM_CONF_SHM */
	if (i < 0)
		ExitStat = EX_CONFIG;
}

#if SM_CONF_SHM
/*
**  CLEANUP_SHM -- do some cleanup work for shared memory etc
**
**	Parameters:
**		owner -- owner of shared memory?
**
**	Returns:
**		none.
**
**	Side Effects:
**		detaches shared memory.
*/

void
cleanup_shm(owner)
	bool owner;
{
	if (ShmId != SM_SHM_NO_ID)
	{
		if (sm_shmstop(Pshm, ShmId, owner) < 0 && LogLevel > 8)
			sm_syslog(LOG_INFO, NOQID, "sm_shmstop failed=%s",
				  sm_errstring(errno));
		Pshm = NULL;
		ShmId = SM_SHM_NO_ID;
	}
	stop_sem(owner);
}
#endif /* SM_CONF_SHM */

/*
**  CLEANUP_QUEUES -- do some cleanup work for queues
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
*/

void
cleanup_queues()
{
	sync_queue_time();
}
/*
**  SET_DEF_QUEUEVAL -- set default values for a queue group.
**
**	Parameters:
**		qg -- queue group
**		all -- set all values (true for default group)?
**
**	Returns:
**		none.
**
**	Side Effects:
**		sets default values for the queue group.
*/

void
set_def_queueval(qg, all)
	QUEUEGRP *qg;
	bool all;
{
	if (bitnset(QD_DEFINED, qg->qg_flags))
		return;
	if (all)
		qg->qg_qdir = QueueDir;
#if _FFR_QUEUE_GROUP_SORTORDER
	qg->qg_sortorder = QueueSortOrder;
#endif /* _FFR_QUEUE_GROUP_SORTORDER */
	qg->qg_maxqrun = all ? MaxRunnersPerQueue : -1;
	qg->qg_nice = NiceQueueRun;
}
/*
**  MAKEQUEUE -- define a new queue.
**
**	Parameters:
**		line -- description of queue.  This is in labeled fields.
**			The fields are:
**			   F -- the flags associated with the queue
**			   I -- the interval between running the queue
**			   J -- the maximum # of jobs in work list
**			   [M -- the maximum # of jobs in a queue run]
**			   N -- the niceness at which to run
**			   P -- the path to the queue
**			   S -- the queue sorting order
**			   R -- number of parallel queue runners
**			   r -- max recipients per envelope
**			The first word is the canonical name of the queue.
**		qdef -- this is a 'Q' definition from .cf
**
**	Returns:
**		none.
**
**	Side Effects:
**		enters the queue into the queue table.
*/

void
makequeue(line, qdef)
	char *line;
	bool qdef;
{
	register char *p;
	register QUEUEGRP *qg;
	register STAB *s;
	int i;
	char fcode;

	/* allocate a queue and set up defaults */
	qg = (QUEUEGRP *) xalloc(sizeof(*qg));
	memset((char *) qg, '\0', sizeof(*qg));

	if (line[0] == '\0')
	{
		syserr("name required for queue");
		return;
	}

	/* collect the queue name */
	for (p = line;
	     *p != '\0' && *p != ',' && !(isascii(*p) && isspace(*p));
	     p++)
		continue;
	if (*p != '\0')
		*p++ = '\0';
	qg->qg_name = newstr(line);

	/* set default values, can be overridden below */
	set_def_queueval(qg, false);

	/* now scan through and assign info from the fields */
	while (*p != '\0')
	{
		auto char *delimptr;

		while (*p != '\0' &&
		       (*p == ',' || (isascii(*p) && isspace(*p))))
			p++;

		/* p now points to field code */
		fcode = *p;
		while (*p != '\0' && *p != '=' && *p != ',')
			p++;
		if (*p++ != '=')
		{
			syserr("queue %s: `=' expected", qg->qg_name);
			return;
		}
		while (isascii(*p) && isspace(*p))
			p++;

		/* p now points to the field body */
		p = munchstring(p, &delimptr, ',');

		/* install the field into the queue struct */
		switch (fcode)
		{
		  case 'P':		/* pathname */
			if (*p == '\0')
				syserr("queue %s: empty path name",
					qg->qg_name);
			else
				qg->qg_qdir = newstr(p);
			break;

		  case 'F':		/* flags */
			for (; *p != '\0'; p++)
				if (!(isascii(*p) && isspace(*p)))
					setbitn(*p, qg->qg_flags);
			break;

			/*
			**  Do we need two intervals here:
			**  One for persistent queue runners,
			**  one for "normal" queue runs?
			*/

		  case 'I':	/* interval between running the queue */
			qg->qg_queueintvl = convtime(p, 'm');
			break;

		  case 'N':		/* run niceness */
			qg->qg_nice = atoi(p);
			break;

		  case 'R':		/* maximum # of runners for the group */
			i = atoi(p);

			/* can't have more runners than allowed total */
			if (MaxQueueChildren > 0 && i > MaxQueueChildren)
			{
				qg->qg_maxqrun = MaxQueueChildren;
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Q=%s: R=%d exceeds MaxQueueChildren=%d, set to MaxQueueChildren\n",
						     qg->qg_name, i,
						     MaxQueueChildren);
			}
			else
				qg->qg_maxqrun = i;
			break;

		  case 'J':		/* maximum # of jobs in work list */
			qg->qg_maxlist = atoi(p);
			break;

		  case 'r':		/* max recipients per envelope */
			qg->qg_maxrcpt = atoi(p);
			break;

#if _FFR_QUEUE_GROUP_SORTORDER
		  case 'S':		/* queue sorting order */
			switch (*p)
			{
			  case 'h':	/* Host first */
			  case 'H':
				qg->qg_sortorder = QSO_BYHOST;
				break;

			  case 'p':	/* Priority order */
			  case 'P':
				qg->qg_sortorder = QSO_BYPRIORITY;
				break;

			  case 't':	/* Submission time */
			  case 'T':
				qg->qg_sortorder = QSO_BYTIME;
				break;

			  case 'f':	/* File name */
			  case 'F':
				qg->qg_sortorder = QSO_BYFILENAME;
				break;

			  case 'm':	/* Modification time */
			  case 'M':
				qg->qg_sortorder = QSO_BYMODTIME;
				break;

			  case 'r':	/* Random */
			  case 'R':
				qg->qg_sortorder = QSO_RANDOM;
				break;

# if _FFR_RHS
			  case 's':	/* Shuffled host name */
			  case 'S':
				qg->qg_sortorder = QSO_BYSHUFFLE;
				break;
# endif /* _FFR_RHS */

			  case 'n':	/* none */
			  case 'N':
				qg->qg_sortorder = QSO_NONE;
				break;

			  default:
				syserr("Invalid queue sort order \"%s\"", p);
			}
			break;
#endif /* _FFR_QUEUE_GROUP_SORTORDER */

		  default:
			syserr("Q%s: unknown queue equate %c=",
			       qg->qg_name, fcode);
			break;
		}

		p = delimptr;
	}

#if !HASNICE
	if (qg->qg_nice != NiceQueueRun)
	{
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Q%s: Warning: N= set on system that doesn't support nice()\n",
				     qg->qg_name);
	}
#endif /* !HASNICE */

	/* do some rationality checking */
	if (NumQueue >= MAXQUEUEGROUPS)
	{
		syserr("too many queue groups defined (%d max)",
			MAXQUEUEGROUPS);
		return;
	}

	if (qg->qg_qdir == NULL)
	{
		if (QueueDir == NULL || *QueueDir == '\0')
		{
			syserr("QueueDir must be defined before queue groups");
			return;
		}
		qg->qg_qdir = newstr(QueueDir);
	}

	if (qg->qg_maxqrun > 1 && !bitnset(QD_FORK, qg->qg_flags))
	{
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: Q=%s: R=%d: multiple queue runners specified\n\tbut flag '%c' is not set\n",
				     qg->qg_name, qg->qg_maxqrun, QD_FORK);
	}

	/* enter the queue into the symbol table */
	if (tTd(37, 8))
		sm_syslog(LOG_INFO, NOQID,
			  "Adding %s to stab, path: %s", qg->qg_name,
			  qg->qg_qdir);
	s = stab(qg->qg_name, ST_QUEUE, ST_ENTER);
	if (s->s_quegrp != NULL)
	{
		i = s->s_quegrp->qg_index;

		/* XXX what about the pointers inside this struct? */
		sm_free(s->s_quegrp); /* XXX */
	}
	else
		i = NumQueue++;
	Queue[i] = s->s_quegrp = qg;
	qg->qg_index = i;

	/* set default value for max queue runners */
	if (qg->qg_maxqrun < 0)
	{
		if (MaxRunnersPerQueue > 0)
			qg->qg_maxqrun = MaxRunnersPerQueue;
		else
			qg->qg_maxqrun = 1;
	}
	if (qdef)
		setbitn(QD_DEFINED, qg->qg_flags);
}
#if 0
/*
**  HASHFQN -- calculate a hash value for a fully qualified host name
**
**	Arguments:
**		fqn -- an all lower-case host.domain string
**		buckets -- the number of buckets (queue directories)
**
**	Returns:
**		a bucket number (signed integer)
**		-1 on error
**
**	Contributed by Exactis.com, Inc.
*/

int
hashfqn(fqn, buckets)
	register char *fqn;
	int buckets;
{
	register char *p;
	register int h = 0, hash, cnt;

	if (fqn == NULL)
		return -1;

	/*
	**  A variation on the gdb hash
	**  This is the best as of Feb 19, 1996 --bcx
	*/

	p = fqn;
	h = 0x238F13AF * strlen(p);
	for (cnt = 0; *p != 0; ++p, cnt++)
	{
		h = (h + (*p << (cnt * 5 % 24))) & 0x7FFFFFFF;
	}
	h = (1103515243 * h + 12345) & 0x7FFFFFFF;
	if (buckets < 2)
		hash = 0;
	else
		hash = (h % buckets);

	return hash;
}
#endif /* 0 */

/*
**  A structure for sorting Queue according to maxqrun without
**	screwing up Queue itself.
*/

struct sortqgrp
{
	int sg_idx;		/* original index */
	int sg_maxqrun;		/* max queue runners */
};
typedef struct sortqgrp	SORTQGRP_T;
static int cmpidx __P((const void *, const void *));

static int
cmpidx(a, b)
	const void *a;
	const void *b;
{
	/* The sort is highest to lowest, so the comparison is reversed */
	if (((SORTQGRP_T *)a)->sg_maxqrun < ((SORTQGRP_T *)b)->sg_maxqrun)
		return 1;
	else if (((SORTQGRP_T *)a)->sg_maxqrun > ((SORTQGRP_T *)b)->sg_maxqrun)
		return -1;
	else
		return 0;
}

/*
**  MAKEWORKGROUP -- balance queue groups into work groups per MaxQueueChildren
**
**  Take the now defined queue groups and assign them to work groups.
**  This is done to balance out the number of concurrently active
**  queue runners such that MaxQueueChildren is not exceeded. This may
**  result in more than one queue group per work group. In such a case
**  the number of running queue groups in that work group will have no
**  more than the work group maximum number of runners (a "fair" portion
**  of MaxQueueRunners). All queue groups within a work group will get a
**  chance at running.
**
**	Parameters:
**		none.
**
**	Returns:
**		nothing.
**
**	Side Effects:
**		Sets up WorkGrp structure.
*/

void
makeworkgroups()
{
	int i, j, total_runners, dir, h;
	SORTQGRP_T si[MAXQUEUEGROUPS + 1];

	total_runners = 0;
	if (NumQueue == 1 && strcmp(Queue[0]->qg_name, "mqueue") == 0)
	{
		/*
		**  There is only the "mqueue" queue group (a default)
		**  containing all of the queues. We want to provide to
		**  this queue group the maximum allowable queue runners.
		**  To match older behavior (8.10/8.11) we'll try for
		**  1 runner per queue capping it at MaxQueueChildren.
		**  So if there are N queues, then there will be N runners
		**  for the "mqueue" queue group (where N is kept less than
		**  MaxQueueChildren).
		*/

		NumWorkGroups = 1;
		WorkGrp[0].wg_numqgrp = 1;
		WorkGrp[0].wg_qgs = (QUEUEGRP **) xalloc(sizeof(QUEUEGRP *));
		WorkGrp[0].wg_qgs[0] = Queue[0];
		if (MaxQueueChildren > 0 &&
		    Queue[0]->qg_numqueues > MaxQueueChildren)
			WorkGrp[0].wg_runners = MaxQueueChildren;
		else
			WorkGrp[0].wg_runners = Queue[0]->qg_numqueues;

		Queue[0]->qg_wgrp = 0;

		/* can't have more runners than allowed total */
		if (MaxQueueChildren > 0 &&
		    Queue[0]->qg_maxqrun > MaxQueueChildren)
			Queue[0]->qg_maxqrun = MaxQueueChildren;
		WorkGrp[0].wg_maxact = Queue[0]->qg_maxqrun;
		WorkGrp[0].wg_lowqintvl = Queue[0]->qg_queueintvl;
		return;
	}

	for (i = 0; i < NumQueue; i++)
	{
		si[i].sg_maxqrun = Queue[i]->qg_maxqrun;
		si[i].sg_idx = i;
	}
	qsort(si, NumQueue, sizeof(si[0]), cmpidx);

	NumWorkGroups = 0;
	for (i = 0; i < NumQueue; i++)
	{
		total_runners += si[i].sg_maxqrun;
		if (MaxQueueChildren <= 0 || total_runners <= MaxQueueChildren)
			NumWorkGroups++;
		else
			break;
	}

	if (NumWorkGroups < 1)
		NumWorkGroups = 1; /* gotta have one at least */
	else if (NumWorkGroups > MAXWORKGROUPS)
		NumWorkGroups = MAXWORKGROUPS; /* the limit */

	/*
	**  We now know the number of work groups to pack the queue groups
	**  into. The queue groups in 'Queue' are sorted from highest
	**  to lowest for the number of runners per queue group.
	**  We put the queue groups with the largest number of runners
	**  into work groups first. Then the smaller ones are fitted in
	**  where it looks best.
	*/

	j = 0;
	dir = 1;
	for (i = 0; i < NumQueue; i++)
	{
		/* a to-and-fro packing scheme, continue from last position */
		if (j >= NumWorkGroups)
		{
			dir = -1;
			j = NumWorkGroups - 1;
		}
		else if (j < 0)
		{
			j = 0;
			dir = 1;
		}

		if (WorkGrp[j].wg_qgs == NULL)
			WorkGrp[j].wg_qgs = (QUEUEGRP **)sm_malloc(sizeof(QUEUEGRP *) *
							(WorkGrp[j].wg_numqgrp + 1));
		else
			WorkGrp[j].wg_qgs = (QUEUEGRP **)sm_realloc(WorkGrp[j].wg_qgs,
							sizeof(QUEUEGRP *) *
							(WorkGrp[j].wg_numqgrp + 1));
		if (WorkGrp[j].wg_qgs == NULL)
		{
			syserr("!cannot allocate memory for work queues, need %d bytes",
			       (int) (sizeof(QUEUEGRP *) *
				      (WorkGrp[j].wg_numqgrp + 1)));
		}

		h = si[i].sg_idx;
		WorkGrp[j].wg_qgs[WorkGrp[j].wg_numqgrp] = Queue[h];
		WorkGrp[j].wg_numqgrp++;
		WorkGrp[j].wg_runners += Queue[h]->qg_maxqrun;
		Queue[h]->qg_wgrp = j;

		if (WorkGrp[j].wg_maxact == 0)
		{
			/* can't have more runners than allowed total */
			if (MaxQueueChildren > 0 &&
			    Queue[h]->qg_maxqrun > MaxQueueChildren)
				Queue[h]->qg_maxqrun = MaxQueueChildren;
			WorkGrp[j].wg_maxact = Queue[h]->qg_maxqrun;
		}

		/*
		**  XXX: must wg_lowqintvl be the GCD?
		**  qg1: 2m, qg2: 3m, minimum: 2m, when do queue runs for
		**  qg2 occur?
		*/

		/* keep track of the lowest interval for a persistent runner */
		if (Queue[h]->qg_queueintvl > 0 &&
		    WorkGrp[j].wg_lowqintvl < Queue[h]->qg_queueintvl)
			WorkGrp[j].wg_lowqintvl = Queue[h]->qg_queueintvl;
		j += dir;
	}
	if (tTd(41, 9))
	{
		for (i = 0; i < NumWorkGroups; i++)
		{
			sm_dprintf("Workgroup[%d]=", i);
			for (j = 0; j < WorkGrp[i].wg_numqgrp; j++)
			{
				sm_dprintf("%s, ",
					WorkGrp[i].wg_qgs[j]->qg_name);
			}
			sm_dprintf("\n");
		}
	}
}

/*
**  DUP_DF -- duplicate envelope data file
**
**	Copy the data file from the 'old' envelope to the 'new' envelope
**	in the most efficient way possible.
**
**	Create a hard link from the 'old' data file to the 'new' data file.
**	If the old and new queue directories are on different file systems,
**	then the new data file link is created in the old queue directory,
**	and the new queue file will contain a 'd' record pointing to the
**	directory containing the new data file.
**
**	Parameters:
**		old -- old envelope.
**		new -- new envelope.
**
**	Results:
**		Returns true on success, false on failure.
**
**	Side Effects:
**		On success, the new data file is created.
**		On fatal failure, EF_FATALERRS is set in old->e_flags.
*/

static bool	dup_df __P((ENVELOPE *, ENVELOPE *));

static bool
dup_df(old, new)
	ENVELOPE *old;
	ENVELOPE *new;
{
	int ofs, nfs, r;
	char opath[MAXPATHLEN];
	char npath[MAXPATHLEN];

	if (!bitset(EF_HAS_DF, old->e_flags))
	{
		/*
		**  this can happen if: SuperSafe != True
		**  and a bounce mail is sent that is split.
		*/

		queueup(old, false, true);
	}
	SM_REQUIRE(ISVALIDQGRP(old->e_qgrp) && ISVALIDQDIR(old->e_qdir));
	SM_REQUIRE(ISVALIDQGRP(new->e_qgrp) && ISVALIDQDIR(new->e_qdir));

	(void) sm_strlcpy(opath, queuename(old, DATAFL_LETTER), sizeof(opath));
	(void) sm_strlcpy(npath, queuename(new, DATAFL_LETTER), sizeof(npath));

	if (old->e_dfp != NULL)
	{
		r = sm_io_setinfo(old->e_dfp, SM_BF_COMMIT, NULL);
		if (r < 0 && errno != EINVAL)
		{
			syserr("@@can't commit %s", opath);
			old->e_flags |= EF_FATALERRS;
			return false;
		}
	}

	/*
	**  Attempt to create a hard link, if we think both old and new
	**  are on the same file system, otherwise copy the file.
	**
	**  Don't waste time attempting a hard link unless old and new
	**  are on the same file system.
	*/

	SM_REQUIRE(ISVALIDQGRP(old->e_dfqgrp) && ISVALIDQDIR(old->e_dfqdir));
	SM_REQUIRE(ISVALIDQGRP(new->e_dfqgrp) && ISVALIDQDIR(new->e_dfqdir));

	ofs = Queue[old->e_dfqgrp]->qg_qpaths[old->e_dfqdir].qp_fsysidx;
	nfs = Queue[new->e_dfqgrp]->qg_qpaths[new->e_dfqdir].qp_fsysidx;
	if (FILE_SYS_DEV(ofs) == FILE_SYS_DEV(nfs))
	{
		if (link(opath, npath) == 0)
		{
			new->e_flags |= EF_HAS_DF;
			SYNC_DIR(npath, true);
			return true;
		}
		goto error;
	}

	/*
	**  Can't link across queue directories, so try to create a hard
	**  link in the same queue directory as the old df file.
	**  The qf file will refer to the new df file using a 'd' record.
	*/

	new->e_dfqgrp = old->e_dfqgrp;
	new->e_dfqdir = old->e_dfqdir;
	(void) sm_strlcpy(npath, queuename(new, DATAFL_LETTER), sizeof(npath));
	if (link(opath, npath) == 0)
	{
		new->e_flags |= EF_HAS_DF;
		SYNC_DIR(npath, true);
		return true;
	}

  error:
	if (LogLevel > 0)
		sm_syslog(LOG_ERR, old->e_id,
			  "dup_df: can't link %s to %s, error=%s, envelope splitting failed",
			  opath, npath, sm_errstring(errno));
	return false;
}

/*
**  SPLIT_ENV -- Allocate a new envelope based on a given envelope.
**
**	Parameters:
**		e -- envelope.
**		sendqueue -- sendqueue for new envelope.
**		qgrp -- index of queue group.
**		qdir -- queue directory.
**
**	Results:
**		new envelope.
**
*/

static ENVELOPE	*split_env __P((ENVELOPE *, ADDRESS *, int, int));

static ENVELOPE *
split_env(e, sendqueue, qgrp, qdir)
	ENVELOPE *e;
	ADDRESS *sendqueue;
	int qgrp;
	int qdir;
{
	ENVELOPE *ee;

	ee = (ENVELOPE *) sm_rpool_malloc_x(e->e_rpool, sizeof(*ee));
	STRUCTCOPY(*e, *ee);
	ee->e_message = NULL;	/* XXX use original message? */
	ee->e_id = NULL;
	assign_queueid(ee);
	ee->e_sendqueue = sendqueue;
	ee->e_flags &= ~(EF_INQUEUE|EF_CLRQUEUE|EF_FATALERRS
			 |EF_SENDRECEIPT|EF_RET_PARAM|EF_HAS_DF);
	ee->e_flags |= EF_NORECEIPT;	/* XXX really? */
	ee->e_from.q_state = QS_SENDER;
	ee->e_dfp = NULL;
	ee->e_lockfp = NULL;
	if (e->e_xfp != NULL)
		ee->e_xfp = sm_io_dup(e->e_xfp);

	/* failed to dup e->e_xfp, start a new transcript */
	if (ee->e_xfp == NULL)
		openxscript(ee);

	ee->e_qgrp = ee->e_dfqgrp = qgrp;
	ee->e_qdir = ee->e_dfqdir = qdir;
	ee->e_errormode = EM_MAIL;
	ee->e_statmsg = NULL;
	if (e->e_quarmsg != NULL)
		ee->e_quarmsg = sm_rpool_strdup_x(ee->e_rpool,
						  e->e_quarmsg);

	/*
	**  XXX Not sure if this copying is necessary.
	**  sendall() does this copying, but I (dm) don't know if that is
	**  because of the storage management discipline we were using
	**  before rpools were introduced, or if it is because these lists
	**  can be modified later.
	*/

	ee->e_header = copyheader(e->e_header, ee->e_rpool);
	ee->e_errorqueue = copyqueue(e->e_errorqueue, ee->e_rpool);

	return ee;
}

/* return values from split functions, check also below! */
#define SM_SPLIT_FAIL	(0)
#define SM_SPLIT_NONE	(1)
#define SM_SPLIT_NEW(n)	(1 + (n))

/*
**  SPLIT_ACROSS_QUEUE_GROUPS
**
**	This function splits an envelope across multiple queue groups
**	based on the queue group of each recipient.
**
**	Parameters:
**		e -- envelope.
**
**	Results:
**		SM_SPLIT_FAIL on failure
**		SM_SPLIT_NONE if no splitting occurred,
**		or 1 + the number of additional envelopes created.
**
**	Side Effects:
**		On success, e->e_sibling points to a list of zero or more
**		additional envelopes, and the associated data files exist
**		on disk.  But the queue files are not created.
**
**		On failure, e->e_sibling is not changed.
**		The order of recipients in e->e_sendqueue is permuted.
**		Abandoned data files for additional envelopes that failed
**		to be created may exist on disk.
*/

static int	q_qgrp_compare __P((const void *, const void *));
static int	e_filesys_compare __P((const void *, const void *));

static int
q_qgrp_compare(p1, p2)
	const void *p1;
	const void *p2;
{
	ADDRESS **pq1 = (ADDRESS **) p1;
	ADDRESS **pq2 = (ADDRESS **) p2;

	return (*pq1)->q_qgrp - (*pq2)->q_qgrp;
}

static int
e_filesys_compare(p1, p2)
	const void *p1;
	const void *p2;
{
	ENVELOPE **pe1 = (ENVELOPE **) p1;
	ENVELOPE **pe2 = (ENVELOPE **) p2;
	int fs1, fs2;

	fs1 = Queue[(*pe1)->e_qgrp]->qg_qpaths[(*pe1)->e_qdir].qp_fsysidx;
	fs2 = Queue[(*pe2)->e_qgrp]->qg_qpaths[(*pe2)->e_qdir].qp_fsysidx;
	if (FILE_SYS_DEV(fs1) < FILE_SYS_DEV(fs2))
		return -1;
	if (FILE_SYS_DEV(fs1) > FILE_SYS_DEV(fs2))
		return 1;
	return 0;
}

static int split_across_queue_groups __P((ENVELOPE *));
static int
split_across_queue_groups(e)
	ENVELOPE *e;
{
	int naddrs, nsplits, i;
	bool changed;
	char **pvp;
	ADDRESS *q, **addrs;
	ENVELOPE *ee, *es;
	ENVELOPE *splits[MAXQUEUEGROUPS];
	char pvpbuf[PSBUFSIZE];

	SM_REQUIRE(ISVALIDQGRP(e->e_qgrp));

	/* Count addresses and assign queue groups. */
	naddrs = 0;
	changed = false;
	for (q = e->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (QS_IS_DEAD(q->q_state))
			continue;
		++naddrs;

		/* bad addresses and those already sent stay put */
		if (QS_IS_BADADDR(q->q_state) ||
		    QS_IS_SENT(q->q_state))
			q->q_qgrp = e->e_qgrp;
		else if (!ISVALIDQGRP(q->q_qgrp))
		{
			/* call ruleset which should return a queue group */
			i = rscap(RS_QUEUEGROUP, q->q_user, NULL, e, &pvp,
				  pvpbuf, sizeof(pvpbuf));
			if (i == EX_OK &&
			    pvp != NULL && pvp[0] != NULL &&
			    (pvp[0][0] & 0377) == CANONNET &&
			    pvp[1] != NULL && pvp[1][0] != '\0')
			{
				i = name2qid(pvp[1]);
				if (ISVALIDQGRP(i))
				{
					q->q_qgrp = i;
					changed = true;
					if (tTd(20, 4))
						sm_syslog(LOG_INFO, NOQID,
							"queue group name %s -> %d",
							pvp[1], i);
					continue;
				}
				else if (LogLevel > 10)
					sm_syslog(LOG_INFO, NOQID,
						"can't find queue group name %s, selection ignored",
						pvp[1]);
			}
			if (q->q_mailer != NULL &&
			    ISVALIDQGRP(q->q_mailer->m_qgrp))
			{
				changed = true;
				q->q_qgrp = q->q_mailer->m_qgrp;
			}
			else if (ISVALIDQGRP(e->e_qgrp))
				q->q_qgrp = e->e_qgrp;
			else
				q->q_qgrp = 0;
		}
	}

	/* only one address? nothing to split. */
	if (naddrs <= 1 && !changed)
		return SM_SPLIT_NONE;

	/* sort the addresses by queue group */
	addrs = sm_rpool_malloc_x(e->e_rpool, naddrs * sizeof(ADDRESS *));
	for (i = 0, q = e->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (QS_IS_DEAD(q->q_state))
			continue;
		addrs[i++] = q;
	}
	qsort(addrs, naddrs, sizeof(ADDRESS *), q_qgrp_compare);

	/* split into multiple envelopes, by queue group */
	nsplits = 0;
	es = NULL;
	e->e_sendqueue = NULL;
	for (i = 0; i < naddrs; ++i)
	{
		if (i == naddrs - 1 || addrs[i]->q_qgrp != addrs[i + 1]->q_qgrp)
			addrs[i]->q_next = NULL;
		else
			addrs[i]->q_next = addrs[i + 1];

		/* same queue group as original envelope? */
		if (addrs[i]->q_qgrp == e->e_qgrp)
		{
			if (e->e_sendqueue == NULL)
				e->e_sendqueue = addrs[i];
			continue;
		}

		/* different queue group than original envelope */
		if (es == NULL || addrs[i]->q_qgrp != es->e_qgrp)
		{
			ee = split_env(e, addrs[i], addrs[i]->q_qgrp, NOQDIR);
			es = ee;
			splits[nsplits++] = ee;
		}
	}

	/* no splits? return right now. */
	if (nsplits <= 0)
		return SM_SPLIT_NONE;

	/* assign a queue directory to each additional envelope */
	for (i = 0; i < nsplits; ++i)
	{
		es = splits[i];
#if 0
		es->e_qdir = pickqdir(Queue[es->e_qgrp], es->e_msgsize, es);
#endif /* 0 */
		if (!setnewqueue(es))
			goto failure;
	}

	/* sort the additional envelopes by queue file system */
	qsort(splits, nsplits, sizeof(ENVELOPE *), e_filesys_compare);

	/* create data files for each additional envelope */
	if (!dup_df(e, splits[0]))
	{
		i = 0;
		goto failure;
	}
	for (i = 1; i < nsplits; ++i)
	{
		/* copy or link to the previous data file */
		if (!dup_df(splits[i - 1], splits[i]))
			goto failure;
	}

	/* success: prepend the new envelopes to the e->e_sibling list */
	for (i = 0; i < nsplits; ++i)
	{
		es = splits[i];
		es->e_sibling = e->e_sibling;
		e->e_sibling = es;
	}
	return SM_SPLIT_NEW(nsplits);

	/* failure: clean up */
  failure:
	if (i > 0)
	{
		int j;

		for (j = 0; j < i; j++)
			(void) unlink(queuename(splits[j], DATAFL_LETTER));
	}
	e->e_sendqueue = addrs[0];
	for (i = 0; i < naddrs - 1; ++i)
		addrs[i]->q_next = addrs[i + 1];
	addrs[naddrs - 1]->q_next = NULL;
	return SM_SPLIT_FAIL;
}

/*
**  SPLIT_WITHIN_QUEUE
**
**	Split an envelope with multiple recipients into several
**	envelopes within the same queue directory, if the number of
**	recipients exceeds the limit for the queue group.
**
**	Parameters:
**		e -- envelope.
**
**	Results:
**		SM_SPLIT_FAIL on failure
**		SM_SPLIT_NONE if no splitting occurred,
**		or 1 + the number of additional envelopes created.
*/

#define SPLIT_LOG_LEVEL	8

static int	split_within_queue __P((ENVELOPE *));

static int
split_within_queue(e)
	ENVELOPE *e;
{
	int maxrcpt, nrcpt, ndead, nsplit, i;
	int j, l;
	char *lsplits;
	ADDRESS *q, **addrs;
	ENVELOPE *ee, *firstsibling;

	if (!ISVALIDQGRP(e->e_qgrp) || bitset(EF_SPLIT, e->e_flags))
		return SM_SPLIT_NONE;

	/* don't bother if there is no recipient limit */
	maxrcpt = Queue[e->e_qgrp]->qg_maxrcpt;
	if (maxrcpt <= 0)
		return SM_SPLIT_NONE;

	/* count recipients */
	nrcpt = 0;
	for (q = e->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (QS_IS_DEAD(q->q_state))
			continue;
		++nrcpt;
	}
	if (nrcpt <= maxrcpt)
		return SM_SPLIT_NONE;

	/*
	**  Preserve the recipient list
	**  so that we can restore it in case of error.
	**  (But we discard dead addresses.)
	*/

	addrs = sm_rpool_malloc_x(e->e_rpool, nrcpt * sizeof(ADDRESS *));
	for (i = 0, q = e->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (QS_IS_DEAD(q->q_state))
			continue;
		addrs[i++] = q;
	}

	/*
	**  Partition the recipient list so that bad and sent addresses
	**  come first. These will go with the original envelope, and
	**  do not count towards the maxrcpt limit.
	**  addrs[] does not contain QS_IS_DEAD() addresses.
	*/

	ndead = 0;
	for (i = 0; i < nrcpt; ++i)
	{
		if (QS_IS_BADADDR(addrs[i]->q_state) ||
		    QS_IS_SENT(addrs[i]->q_state) ||
		    QS_IS_DEAD(addrs[i]->q_state)) /* for paranoia's sake */
		{
			if (i > ndead)
			{
				ADDRESS *tmp = addrs[i];

				addrs[i] = addrs[ndead];
				addrs[ndead] = tmp;
			}
			++ndead;
		}
	}

	/* Check if no splitting required. */
	if (nrcpt - ndead <= maxrcpt)
		return SM_SPLIT_NONE;

	/* fix links */
	for (i = 0; i < nrcpt - 1; ++i)
		addrs[i]->q_next = addrs[i + 1];
	addrs[nrcpt - 1]->q_next = NULL;
	e->e_sendqueue = addrs[0];

	/* prepare buffer for logging */
	if (LogLevel > SPLIT_LOG_LEVEL)
	{
		l = MAXLINE;
		lsplits = sm_malloc(l);
		if (lsplits != NULL)
			*lsplits = '\0';
		j = 0;
	}
	else
	{
		/* get rid of stupid compiler warnings */
		lsplits = NULL;
		j = l = 0;
	}

	/* split the envelope */
	firstsibling = e->e_sibling;
	i = maxrcpt + ndead;
	nsplit = 0;
	for (;;)
	{
		addrs[i - 1]->q_next = NULL;
		ee = split_env(e, addrs[i], e->e_qgrp, e->e_qdir);
		if (!dup_df(e, ee))
		{

			ee = firstsibling;
			while (ee != NULL)
			{
				(void) unlink(queuename(ee, DATAFL_LETTER));
				ee = ee->e_sibling;
			}

			/* Error.  Restore e's sibling & recipient lists. */
			e->e_sibling = firstsibling;
			for (i = 0; i < nrcpt - 1; ++i)
				addrs[i]->q_next = addrs[i + 1];
			if (lsplits != NULL)
				sm_free(lsplits);
			return SM_SPLIT_FAIL;
		}

		/* prepend the new envelope to e->e_sibling */
		ee->e_sibling = e->e_sibling;
		e->e_sibling = ee;
		++nsplit;
		if (LogLevel > SPLIT_LOG_LEVEL && lsplits != NULL)
		{
			if (j >= l - strlen(ee->e_id) - 3)
			{
				char *p;

				l += MAXLINE;
				p = sm_realloc(lsplits, l);
				if (p == NULL)
				{
					/* let's try to get this done */
					sm_free(lsplits);
					lsplits = NULL;
				}
				else
					lsplits = p;
			}
			if (lsplits != NULL)
			{
				if (j == 0)
					j += sm_strlcat(lsplits + j,
							ee->e_id,
							l - j);
				else
					j += sm_strlcat2(lsplits + j,
							 "; ",
							 ee->e_id,
							 l - j);
				SM_ASSERT(j < l);
			}
		}
		if (nrcpt - i <= maxrcpt)
			break;
		i += maxrcpt;
	}
	if (LogLevel > SPLIT_LOG_LEVEL && lsplits != NULL)
	{
		if (nsplit > 0)
		{
			sm_syslog(LOG_NOTICE, e->e_id,
				  "split: maxrcpts=%d, rcpts=%d, count=%d, id%s=%s",
				  maxrcpt, nrcpt - ndead, nsplit,
				  nsplit > 1 ? "s" : "", lsplits);
		}
		sm_free(lsplits);
	}
	return SM_SPLIT_NEW(nsplit);
}
/*
**  SPLIT_BY_RECIPIENT
**
**	Split an envelope with multiple recipients into multiple
**	envelopes as required by the sendmail configuration.
**
**	Parameters:
**		e -- envelope.
**
**	Results:
**		Returns true on success, false on failure.
**
**	Side Effects:
**		see split_across_queue_groups(), split_within_queue(e)
*/

bool
split_by_recipient(e)
	ENVELOPE *e;
{
	int split, n, i, j, l;
	char *lsplits;
	ENVELOPE *ee, *next, *firstsibling;

	if (OpMode == SM_VERIFY || !ISVALIDQGRP(e->e_qgrp) ||
	    bitset(EF_SPLIT, e->e_flags))
		return true;
	n = split_across_queue_groups(e);
	if (n == SM_SPLIT_FAIL)
		return false;
	firstsibling = ee = e->e_sibling;
	if (n > 1 && LogLevel > SPLIT_LOG_LEVEL)
	{
		l = MAXLINE;
		lsplits = sm_malloc(l);
		if (lsplits != NULL)
			*lsplits = '\0';
		j = 0;
	}
	else
	{
		/* get rid of stupid compiler warnings */
		lsplits = NULL;
		j = l = 0;
	}
	for (i = 1; i < n; ++i)
	{
		next = ee->e_sibling;
		if (split_within_queue(ee) == SM_SPLIT_FAIL)
		{
			e->e_sibling = firstsibling;
			return false;
		}
		ee->e_flags |= EF_SPLIT;
		if (LogLevel > SPLIT_LOG_LEVEL && lsplits != NULL)
		{
			if (j >= l - strlen(ee->e_id) - 3)
			{
				char *p;

				l += MAXLINE;
				p = sm_realloc(lsplits, l);
				if (p == NULL)
				{
					/* let's try to get this done */
					sm_free(lsplits);
					lsplits = NULL;
				}
				else
					lsplits = p;
			}
			if (lsplits != NULL)
			{
				if (j == 0)
					j += sm_strlcat(lsplits + j,
							ee->e_id, l - j);
				else
					j += sm_strlcat2(lsplits + j, "; ",
							 ee->e_id, l - j);
				SM_ASSERT(j < l);
			}
		}
		ee = next;
	}
	if (LogLevel > SPLIT_LOG_LEVEL && lsplits != NULL && n > 1)
	{
		sm_syslog(LOG_NOTICE, e->e_id, "split: count=%d, id%s=%s",
			  n - 1, n > 2 ? "s" : "", lsplits);
		sm_free(lsplits);
	}
	split = split_within_queue(e) != SM_SPLIT_FAIL;
	if (split)
		e->e_flags |= EF_SPLIT;
	return split;
}

/*
**  QUARANTINE_QUEUE_ITEM -- {un,}quarantine a single envelope
**
**	Add/remove quarantine reason and requeue appropriately.
**
**	Parameters:
**		qgrp -- queue group for the item
**		qdir -- queue directory in the given queue group
**		e -- envelope information for the item
**		reason -- quarantine reason, NULL means unquarantine.
**
**	Results:
**		true if item changed, false otherwise
**
**	Side Effects:
**		Changes quarantine tag in queue file and renames it.
*/

static bool
quarantine_queue_item(qgrp, qdir, e, reason)
	int qgrp;
	int qdir;
	ENVELOPE *e;
	char *reason;
{
	bool dirty = false;
	bool failing = false;
	bool foundq = false;
	bool finished = false;
	int fd;
	int flags;
	int oldtype;
	int newtype;
	int save_errno;
	MODE_T oldumask = 0;
	SM_FILE_T *oldqfp, *tempqfp;
	char *bp;
	int bufsize;
	char oldqf[MAXPATHLEN];
	char tempqf[MAXPATHLEN];
	char newqf[MAXPATHLEN];
	char buf[MAXLINE];

	oldtype = queue_letter(e, ANYQFL_LETTER);
	(void) sm_strlcpy(oldqf, queuename(e, ANYQFL_LETTER), sizeof(oldqf));
	(void) sm_strlcpy(tempqf, queuename(e, NEWQFL_LETTER), sizeof(tempqf));

	/*
	**  Instead of duplicating all the open
	**  and lock code here, tell readqf() to
	**  do that work and return the open
	**  file pointer in e_lockfp.  Note that
	**  we must release the locks properly when
	**  we are done.
	*/

	if (!readqf(e, true))
	{
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Skipping %s\n", qid_printname(e));
		return false;
	}
	oldqfp = e->e_lockfp;

	/* open the new queue file */
	flags = O_CREAT|O_WRONLY|O_EXCL;
	if (bitset(S_IWGRP, QueueFileMode))
		oldumask = umask(002);
	fd = open(tempqf, flags, QueueFileMode);
	if (bitset(S_IWGRP, QueueFileMode))
		(void) umask(oldumask);
	RELEASE_QUEUE;

	if (fd < 0)
	{
		save_errno = errno;
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Skipping %s: Could not open %s: %s\n",
				     qid_printname(e), tempqf,
				     sm_errstring(save_errno));
		(void) sm_io_close(oldqfp, SM_TIME_DEFAULT);
		return false;
	}
	if (!lockfile(fd, tempqf, NULL, LOCK_EX|LOCK_NB))
	{
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Skipping %s: Could not lock %s\n",
				     qid_printname(e), tempqf);
		(void) close(fd);
		(void) sm_io_close(oldqfp, SM_TIME_DEFAULT);
		return false;
	}

	tempqfp = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT, (void *) &fd,
			     SM_IO_WRONLY_B, NULL);
	if (tempqfp == NULL)
	{
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Skipping %s: Could not lock %s\n",
				     qid_printname(e), tempqf);
		(void) close(fd);
		(void) sm_io_close(oldqfp, SM_TIME_DEFAULT);
		return false;
	}

	/* Copy the data over, changing the quarantine reason */
	while (bufsize = sizeof(buf),
	       (bp = fgetfolded(buf, &bufsize, oldqfp)) != NULL)
	{
		if (tTd(40, 4))
			sm_dprintf("+++++ %s\n", bp);
		switch (bp[0])
		{
		  case 'q':		/* quarantine reason */
			foundq = true;
			if (reason == NULL)
			{
				if (Verbose)
				{
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "%s: Removed quarantine of \"%s\"\n",
							     e->e_id, &bp[1]);
				}
				sm_syslog(LOG_INFO, e->e_id, "unquarantine");
				dirty = true;
			}
			else if (strcmp(reason, &bp[1]) == 0)
			{
				if (Verbose)
				{
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "%s: Already quarantined with \"%s\"\n",
							     e->e_id, reason);
				}
				(void) sm_io_fprintf(tempqfp, SM_TIME_DEFAULT,
						     "q%s\n", reason);
			}
			else
			{
				if (Verbose)
				{
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "%s: Quarantine changed from \"%s\" to \"%s\"\n",
							     e->e_id, &bp[1],
							     reason);
				}
				(void) sm_io_fprintf(tempqfp, SM_TIME_DEFAULT,
						     "q%s\n", reason);
				sm_syslog(LOG_INFO, e->e_id, "quarantine=%s",
					  reason);
				dirty = true;
			}
			break;

		  case 'S':
			/*
			**  If we are quarantining an unquarantined item,
			**  need to put in a new 'q' line before it's
			**  too late.
			*/

			if (!foundq && reason != NULL)
			{
				if (Verbose)
				{
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "%s: Quarantined with \"%s\"\n",
							     e->e_id, reason);
				}
				(void) sm_io_fprintf(tempqfp, SM_TIME_DEFAULT,
						     "q%s\n", reason);
				sm_syslog(LOG_INFO, e->e_id, "quarantine=%s",
					  reason);
				foundq = true;
				dirty = true;
			}

			/* Copy the line to the new file */
			(void) sm_io_fprintf(tempqfp, SM_TIME_DEFAULT,
					     "%s\n", bp);
			break;

		  case '.':
			finished = true;
			/* FALLTHROUGH */

		  default:
			/* Copy the line to the new file */
			(void) sm_io_fprintf(tempqfp, SM_TIME_DEFAULT,
					     "%s\n", bp);
			break;
		}
		if (bp != buf)
			sm_free(bp);
	}

	/* Make sure we read the whole old file */
	errno = sm_io_error(tempqfp);
	if (errno != 0 && errno != SM_IO_EOF)
	{
		save_errno = errno;
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Skipping %s: Error reading %s: %s\n",
				     qid_printname(e), oldqf,
				     sm_errstring(save_errno));
		failing = true;
	}

	if (!failing && !finished)
	{
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Skipping %s: Incomplete file: %s\n",
				     qid_printname(e), oldqf);
		failing = true;
	}

	/* Check if we actually changed anything or we can just bail now */
	if (!dirty)
	{
		/* pretend we failed, even though we technically didn't */
		failing = true;
	}

	/* Make sure we wrote things out safely */
	if (!failing &&
	    (sm_io_flush(tempqfp, SM_TIME_DEFAULT) != 0 ||
	     ((SuperSafe == SAFE_REALLY ||
	       SuperSafe == SAFE_REALLY_POSTMILTER ||
	       SuperSafe == SAFE_INTERACTIVE) &&
	      fsync(sm_io_getinfo(tempqfp, SM_IO_WHAT_FD, NULL)) < 0) ||
	     ((errno = sm_io_error(tempqfp)) != 0)))
	{
		save_errno = errno;
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Skipping %s: Error writing %s: %s\n",
				     qid_printname(e), tempqf,
				     sm_errstring(save_errno));
		failing = true;
	}


	/* Figure out the new filename */
	newtype = (reason == NULL ? NORMQF_LETTER : QUARQF_LETTER);
	if (oldtype == newtype)
	{
		/* going to rename tempqf to oldqf */
		(void) sm_strlcpy(newqf, oldqf, sizeof(newqf));
	}
	else
	{
		/* going to rename tempqf to new name based on newtype */
		(void) sm_strlcpy(newqf, queuename(e, newtype), sizeof(newqf));
	}

	save_errno = 0;

	/* rename tempqf to newqf */
	if (!failing &&
	    rename(tempqf, newqf) < 0)
		save_errno = (errno == 0) ? EINVAL : errno;

	/* Check rename() success */
	if (!failing && save_errno != 0)
	{
		sm_syslog(LOG_DEBUG, e->e_id,
			  "quarantine_queue_item: rename(%s, %s): %s",
			  tempqf, newqf, sm_errstring(save_errno));

		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Error renaming %s to %s: %s\n",
				     tempqf, newqf,
				     sm_errstring(save_errno));
		if (oldtype == newtype)
		{
			/*
			**  Bail here since we don't know the state of
			**  the filesystem and may need to keep tempqf
			**  for the user to rescue us.
			*/

			RELEASE_QUEUE;
			errno = save_errno;
			syserr("!452 Error renaming control file %s", tempqf);
			/* NOTREACHED */
		}
		else
		{
			/* remove new file (if rename() half completed) */
			if (xunlink(newqf) < 0)
			{
				save_errno = errno;
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Error removing %s: %s\n",
						     newqf,
						     sm_errstring(save_errno));
			}

			/* tempqf removed below */
			failing = true;
		}

	}

	/* If changing file types, need to remove old type */
	if (!failing && oldtype != newtype)
	{
		if (xunlink(oldqf) < 0)
		{
			save_errno = errno;
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Error removing %s: %s\n",
					     oldqf, sm_errstring(save_errno));
		}
	}

	/* see if anything above failed */
	if (failing)
	{
		/* Something failed: remove new file, old file still there */
		(void) xunlink(tempqf);
	}

	/*
	**  fsync() after file operations to make sure metadata is
	**  written to disk on filesystems in which renames are
	**  not guaranteed.  It's ok if they fail, mail won't be lost.
	*/

	if (SuperSafe != SAFE_NO)
	{
		/* for soft-updates */
		(void) fsync(sm_io_getinfo(tempqfp,
					   SM_IO_WHAT_FD, NULL));

		if (!failing)
		{
			/* for soft-updates */
			(void) fsync(sm_io_getinfo(oldqfp,
						   SM_IO_WHAT_FD, NULL));
		}

		/* for other odd filesystems */
		SYNC_DIR(tempqf, false);
	}

	/* Close up shop */
	RELEASE_QUEUE;
	if (tempqfp != NULL)
		(void) sm_io_close(tempqfp, SM_TIME_DEFAULT);
	if (oldqfp != NULL)
		(void) sm_io_close(oldqfp, SM_TIME_DEFAULT);

	/* All went well */
	return !failing;
}

/*
**  QUARANTINE_QUEUE -- {un,}quarantine matching items in the queue
**
**	Read all matching queue items, add/remove quarantine
**	reason, and requeue appropriately.
**
**	Parameters:
**		reason -- quarantine reason, "." means unquarantine.
**		qgrplimit -- limit to single queue group unless NOQGRP
**
**	Results:
**		none.
**
**	Side Effects:
**		Lots of changes to the queue.
*/

void
quarantine_queue(reason, qgrplimit)
	char *reason;
	int qgrplimit;
{
	int changed = 0;
	int qgrp;

	/* Convert internal representation of unquarantine */
	if (reason != NULL && reason[0] == '.' && reason[1] == '\0')
		reason = NULL;

	if (reason != NULL)
	{
		/* clean it */
		reason = newstr(denlstring(reason, true, true));
	}

	for (qgrp = 0; qgrp < NumQueue && Queue[qgrp] != NULL; qgrp++)
	{
		int qdir;

		if (qgrplimit != NOQGRP && qgrplimit != qgrp)
			continue;

		for (qdir = 0; qdir < Queue[qgrp]->qg_numqueues; qdir++)
		{
			int i;
			int nrequests;

			if (StopRequest)
				stop_sendmail();

			nrequests = gatherq(qgrp, qdir, true, NULL, NULL, NULL);

			/* first see if there is anything */
			if (nrequests <= 0)
			{
				if (Verbose)
				{
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT, "%s: no matches\n",
							     qid_printqueue(qgrp, qdir));
				}
				continue;
			}

			if (Verbose)
			{
				(void) sm_io_fprintf(smioout,
						     SM_TIME_DEFAULT, "Processing %s:\n",
						     qid_printqueue(qgrp, qdir));
			}

			for (i = 0; i < WorkListCount; i++)
			{
				ENVELOPE e;

				if (StopRequest)
					stop_sendmail();

				/* setup envelope */
				clearenvelope(&e, true, sm_rpool_new_x(NULL));
				e.e_id = WorkList[i].w_name + 2;
				e.e_qgrp = qgrp;
				e.e_qdir = qdir;

				if (tTd(70, 101))
				{
					sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						      "Would do %s\n", e.e_id);
					changed++;
				}
				else if (quarantine_queue_item(qgrp, qdir,
							       &e, reason))
					changed++;

				/* clean up */
				sm_rpool_free(e.e_rpool);
				e.e_rpool = NULL;
			}
			if (WorkList != NULL)
				sm_free(WorkList); /* XXX */
			WorkList = NULL;
			WorkListSize = 0;
			WorkListCount = 0;
		}
	}
	if (Verbose)
	{
		if (changed == 0)
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "No changes\n");
		else
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "%d change%s\n",
					     changed,
					     changed == 1 ? "" : "s");
	}
}
@


1.30
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.29
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2009, 2011, 2012 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.998 2013/03/12 15:24:53 ca Exp $")
d2943 1
a2943 1
**	trunctated off. Then the most important items are moved from
@


1.28
log
@Update to sendmail 8.14.6
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.997 2012/06/14 23:54:03 ca Exp $")
d2749 1
a2749 1
				   sizeof(lbuf)) != NULL)
d4984 1
a4984 1
		while (sm_io_fgets(f, SM_TIME_DEFAULT, buf, sizeof(buf)) != NULL)
@


1.27
log
@Update to sendmail 8.14.5
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2009, 2011 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.991 2011/03/15 23:14:36 ca Exp $")
d1496 1
d1533 2
d1536 2
d1557 2
d1560 4
d2045 3
d2317 1
a2317 1
		sm_setproctitle(true, CurEnv, "running queue: %s",
d2877 1
a2877 1
					time_t lasttry, delay;    
d3721 1
d4595 1
a4595 1
					   e->e_msgsize);
@


1.26
log
@Update to sendmail-8.14.3
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2007 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.977 2008/02/15 23:19:58 ca Exp $")
d137 1
a137 1
static int	gatherq __P((int, int, bool, bool *, bool *));
d206 1
a206 1
**	FileSys -- (arrary of) structure for used file systems.
a635 1
	/* XXX should probably include device major/minor too */
d2108 1
a2108 1
		h = gatherq(qgrp, qdir, false, &full, &more);
d2452 1
d2475 1
a2475 1
gatherq(qgrp, qdir, doall, full, more)
d2481 1
d2487 1
a2487 2
	int i, num_ent;
	int wn;
d2494 1
d2604 1
d2860 15
d2920 2
d3353 2
a3354 2
**		a -- the first argument (ignored).
**		b -- the second argument (ignored).
d3704 1
a3704 1
			dropenvelope(e, true, false);
d3881 1
a3881 1
			dropenvelope(&e, true, false);
d4856 1
a4856 1
	nrequests = gatherq(qgrp, qdir, true, NULL, NULL);
d5197 3
d5201 1
d5245 3
d5249 1
d5289 2
d5364 1
a5364 1

d5371 2
a5372 2
	static int cX = 0;
	static long random_offset;
d5375 1
a5375 1
	int seq;
d5381 1
a5381 2
	if (cX >= QIC_LEN * QIC_LEN || LastQueueTime == 0 ||
	    LastQueuePid != pid)
d5387 2
a5388 1
			random_offset = get_random();
d5400 2
a5401 2
	**  Generate a new sequence number between 0 and QIC_LEN*QIC_LEN-1.
	**  This lets us generate up to QIC_LEN*QIC_LEN unique queue ids
d5406 1
a5406 1
	seq = (int)((cX + random_offset) % (QIC_LEN * QIC_LEN));
d5409 1
a5409 1
		sm_dprintf("assign_queueid: random_offset = %ld (%d)\n",
d5462 1
d5773 4
d6637 10
d8873 1
a8873 1
			nrequests = gatherq(qgrp, qdir, true, NULL, NULL);
@


1.25
log
@Update to sendmail-8.14.1
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.972 2007/03/29 22:55:17 ca Exp $")
d430 1
a430 1
							  "queueup: cannot create %s, uid=%d: %s",
d848 2
a849 2

			commaize(h, h->h_value, oldstyle, &mcibuf, e);
d2150 8
d4517 1
a4517 1
 
d6599 2
a6600 2
			"func=init_sem, sem_key=%ld, sm_sem_start=%d",
			(long) SemKey, SemId);
@


1.24
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2006 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.970 2006/12/19 01:15:07 ca Exp $")
d799 2
d3915 1
d4509 11
@


1.23
log
@Update to sendmail-8.13.8
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.954.2.5 2006/07/31 21:44:18 ca Exp $")
d150 7
d192 1
a192 1
static char	*FSPath[MAXFILESYS];	/* pathnames for file systems */
d383 1
a383 1
	(void) sm_strlcpy(tf, queuename(e, NEWQFL_LETTER), sizeof tf);
d393 1
a393 1
		(void) sm_strlcpy(tf, queuename(e, ANYQFL_LETTER), sizeof tf);
d512 1
a512 1
	(void) sm_strlcpy(df, queuename(e, DATAFL_LETTER), sizeof df);
d573 1
a573 1
		memset(&mcibuf, '\0', sizeof mcibuf);
d774 1
a774 1
	memset((char *) &nullmailer, '\0', sizeof nullmailer);
d778 1
a778 1
	memset(&mcibuf, '\0', sizeof mcibuf);
d796 1
a796 1
			(void) expand(h->h_value, buf, sizeof buf, e);
d832 1
a832 1
			(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "%s: %s\n",
d853 1
a853 1
			(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "%s: %s\n",
d888 1
a888 1
				  sizeof qf);
a1879 1
	extern void rmexpstab __P((void));
d2485 1
a2485 1
		(void) sm_strlcpy(qd, ".", sizeof qd);
d2487 1
a2487 1
		(void) sm_strlcpyn(qd, sizeof qd, 2,
d2626 1
a2626 1
		(void) sm_strlcpyn(qf, sizeof qf, 3, qd, "/", d->d_name);
d2723 1
a2723 1
				   sizeof lbuf) != NULL)
d2956 1
a2956 1
		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf1);
d2992 1
a2992 1
		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf2);
d3000 1
a3000 1
		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf3);
d3008 1
a3008 1
		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf4);
d3021 1
a3021 1
		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf5);
d3030 1
a3030 1
		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf6);
d3040 1
a3040 1
		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf7);
d3049 1
a3049 1
		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf0);
d3066 1
a3066 1
		w = (WORK *) xalloc(sizeof *w);
d3134 1
a3134 1
		WorkList = (WORK *) xalloc((sizeof *WorkList) *
d3907 1
d3914 1
a3914 1
	(void) sm_strlcpy(qf, queuename(e, ANYQFL_LETTER), sizeof qf);
d4128 2
a4129 1
	while ((bp = fgetfolded(buf, sizeof buf, qfp)) != NULL)
d4307 2
d4484 1
a4484 4
		{
			sm_free(bp); /* XXX */
			bp = NULL;
		}
d4538 1
a4538 1
			(void) sm_snprintf(buf, sizeof buf, "%ld",
d4557 2
a4558 5
	if (bp != NULL && bp != buf)
	{
		sm_free(bp); /* XXX */
		bp = NULL;
	}
d4580 2
d4758 2
a4759 2
		(void) sm_strlcpy(qd, ".", sizeof qd);
		(void) sm_strlcpy(qddf, ".", sizeof qddf);
d4763 1
a4763 1
		(void) sm_strlcpyn(qd, sizeof qd, 2,
d4768 1
a4768 1
		(void) sm_strlcpyn(qddf, sizeof qddf, 2,
d4861 1
a4861 1
		(void) sm_strlcpyn(qf, sizeof qf, 3, qd, "/", w->w_name);
d4880 1
a4880 1
		(void) sm_strlcpyn(qf, sizeof qf, 3, qddf, "/", w->w_name);
d4928 1
a4928 1
		while (sm_io_fgets(f, SM_TIME_DEFAULT, buf, sizeof buf) != NULL)
d4944 2
a4945 2
				if ((i = strlen(&buf[1])) >= sizeof statmsg)
					i = sizeof statmsg - 1;
d4951 2
a4952 2
				if ((i = strlen(&buf[1])) >= sizeof quarmsg)
					i = sizeof quarmsg - 1;
d4958 2
a4959 2
				if ((i = strlen(&buf[1])) >= sizeof bodytype)
					i = sizeof bodytype - 1;
d5215 1
a5215 1
		(void) sm_strlcpyn(buf, sizeof buf, 2, pref, e->e_id);
d5243 1
a5243 1
		(void) sm_strlcpyn(buf, sizeof buf, 4,
d5370 1
a5370 1
	(void) sm_snprintf(&idbuf[8], sizeof idbuf - 8, "%06d",
d5493 2
a5494 2
	a = (ADDRESS *) sm_rpool_malloc_x(e->e_rpool, sizeof *a);
	memset((char *) a, '\0', sizeof *a);
d5567 1
a5567 1
	if (sm_strlcpy(buf, p, sizeof buf) >= sizeof buf)
d5642 1
a5642 1
	(void) sm_snprintf(idbuf, sizeof idbuf, "%.32s/%s",
d5674 1
a5674 1
	(void) sm_strlcpyn(dir, sizeof dir, 4,
d5880 2
d6029 2
a6030 2
	len = sm_strlcpy(qpath, qg->qg_qdir, sizeof qpath);
	if (len >= sizeof qpath)
d6033 1
a6033 1
		       qg->qg_qdir, (int) sizeof qpath);
d6053 2
a6054 2
		if (sm_strlcpy(prefix, qg->qg_qdir + blen, sizeof prefix) >=
		    sizeof prefix)
d6057 1
a6057 1
				qg->qg_qdir, (int) sizeof qpath);
d6094 1
a6094 1
			(void) sm_strlcpy(qpath + 1, qpath, sizeof qpath - 1);
d6107 2
a6108 2
		off = sm_strlcpyn(relpath, sizeof relpath, 2, prefix, "/");
		SM_ASSERT(off < sizeof relpath);
d6147 5
d6172 1
a6172 1
				qg->qg_qpaths = (QPATHS *)xalloc((sizeof *qg->qg_qpaths) *
d6179 1
a6179 1
							  (sizeof *qg->qg_qpaths) *
d6194 1
a6194 1
	(void) sm_strlcpyn(subdir, sizeof subdir, 3, relpath, "/", name); \
d6233 1
a6233 1
		qg->qg_qpaths = (QPATHS *) xalloc(sizeof *qg->qg_qpaths);
d6252 1
a6252 1
	(void) sm_strlcpyn(subdir, sizeof subdir, 3, qg->qg_qdir, "/", name); \
d6306 1
a6306 1
static short filesys_find __P((char *, char *, bool));
d6314 2
a6315 2
	char *name;
	char *path;
d6394 1
a6394 1
			(void) sm_strlcpyn(qddf, sizeof qddf, 2, qp->qp_name,
d6435 6
a6507 1
#if _FFR_CONTROL_MSTAT
a6544 1
#endif /* _FFR_CONTROL_MSTAT */
a6685 2
#if _FFR_SELECT_SHM

a6788 1
#endif /* _FFR_SELECT_SHM */
a6818 1
#if _FFR_SELECT_SHM
a6819 1
#endif /* _FFR_SELECT_SHM */
a6822 1
#if _FFR_SELECT_SHM
d6824 2
a6825 3
# define SEL_SHM_KEY	((key_t) -1)
# define FIRST_SHM_KEY	25
#endif /* _FFR_SELECT_SHM */
a6832 1
#if _FFR_SELECT_SHM
d6840 1
d6844 2
d6847 1
a6849 1
#endif /* _FFR_SELECT_SHM */
a6860 1
#if _FFR_SELECT_SHM
a6869 1
#endif /* _FFR_SELECT_SHM */
d6872 1
a6872 1
#if _FFR_SELECT_SHM
d6875 1
a6875 2
#endif /* _FFR_SELECT_SHM */
		sleep(count);
a6880 1
#if _FFR_SELECT_SHM
a6882 1
#endif /* _FFR_SELECT_SHM */
d6952 1
a6952 1
**  SETUP_QUEUES -- setup all queue groups
d6955 1
a6955 1
**		owner -- owner of shared memory.
d6985 1
a6985 1
	len = sm_strlcpy(basedir, QueueDir, sizeof basedir);
d6988 1
a6988 1
	if (len >= sizeof basedir - 1)
d6991 1
a6991 1
			len, (int) sizeof basedir - 1);
d7242 2
a7243 2
	qg = (QUEUEGRP *) xalloc(sizeof *qg);
	memset((char *) qg, '\0', sizeof *qg);
d7753 2
a7754 2
	(void) sm_strlcpy(opath, queuename(old, DATAFL_LETTER), sizeof opath);
	(void) sm_strlcpy(npath, queuename(new, DATAFL_LETTER), sizeof npath);
d7799 1
a7799 1
	(void) sm_strlcpy(npath, queuename(new, DATAFL_LETTER), sizeof npath);
d7840 1
a7840 1
	ee = (ENVELOPE *) sm_rpool_malloc_x(e->e_rpool, sizeof *ee);
d7943 1
d8434 1
d8441 2
a8442 2
	(void) sm_strlcpy(oldqf, queuename(e, ANYQFL_LETTER), sizeof oldqf);
	(void) sm_strlcpy(tempqf, queuename(e, NEWQFL_LETTER), sizeof tempqf);
d8503 2
a8504 1
	while ((bp = fgetfolded(buf, sizeof buf, oldqfp)) != NULL)
a8522 1
				continue;
d8593 2
d8647 1
a8647 1
		(void) sm_strlcpy(newqf, oldqf, sizeof newqf);
d8652 1
a8652 1
		(void) sm_strlcpy(newqf, queuename(e, newtype), sizeof newqf);
@


1.22
log
@Update to sendmail 8.13.6
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2005 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.951 2006/03/02 19:13:38 ca Exp $")
d2649 1
d3906 1
d4038 1
d4474 1
d4476 2
d4550 5
d5194 1
a5194 1
			setnewqueue(e);
d5208 1
a5208 1
	if (e->e_qdir == NOQDIR && type != XSCRPT_LETTER)
d6316 11
d6328 1
a6421 1
	/* only the daemon updates this structure */
@


1.21
log
@update to sendmail 8.13.4
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.944 2005/02/17 23:58:58 ca Exp $")
d2856 2
a2857 1
		if ((!doall && shouldqueue(w->w_pri, w->w_ctime)) ||
a2934 4
	/* Check if the per queue group item limit will be exceeded */
	if (wc > max && max > 0)
		wc = max;

d3046 4
d3447 1
a3447 1
	for (i = 0; i < NCHAR; i++)
d3451 1
a3451 1
	for (i = 1; i < NCHAR; i++)
d3453 1
a3453 1
		register int j = get_random() % NCHAR;
d3466 2
a3467 2
	for (i = 0; i < NCHAR; i++)
		ShuffledAlphabet[i + NCHAR] = ShuffledAlphabet[i];
d6270 2
a6271 1
**		path -- pathname of directory
d6282 1
a6282 1
static short filesys_find __P((char *, bool));
d6289 2
a6290 1
filesys_find(path, add)
d6316 1
a6316 1
	FILE_SYS_NAME(i) = path;
d6356 1
d6358 4
a6361 1
			fs = filesys_find(qp->qp_name, add);
d6689 16
d6856 1
a6856 2
	    		i = sm_shmsetowner(ShmId, RunAsUid, RunAsGid,
					0660);
d6859 2
a6860 3
		  			"key=%ld, sm_shmsetowner=%d, RunAsUid=%d, RunAsGid=%d",
		  			(long) ShmKey, i,
	    				RunAsUid, RunAsGid);
d7746 5
a7750 2
	ofs = Queue[old->e_qgrp]->qg_qpaths[old->e_qdir].qp_fsysidx;
	nfs = Queue[new->e_qgrp]->qg_qpaths[new->e_qdir].qp_fsysidx;
@


1.20
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004 Sendmail, Inc. and its suppliers.
d15 1
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.939 2004/08/03 19:57:23 ca Exp $")
d405 1
d6501 64
d6570 4
a6573 2
**		delete -- delete/add entry.
**		avail -- update the space available as well.
d6584 1
a6584 1
upd_qs(e, delete, avail)
d6586 3
a6588 2
	bool delete;
	bool avail;
d6592 3
d6602 3
d6607 1
a6607 1
	if (QSHM_ENTRIES(idx) >= 0)
d6609 8
a6616 4
		if (delete)
			--QSHM_ENTRIES(idx);
		else
			++QSHM_ENTRIES(idx);
d6624 1
a6624 1
	if (!avail)
d6633 1
a6633 1
	if (delete)
d6758 2
d6773 2
a6774 4
	if (ShmKey != 0)
	{
		int count;
		int save_errno;
d6776 2
a6777 2
		count = 0;
		shms = SM_T_SIZE + qn * sizeof(QUEUE_SHM_T);
d6779 6
a6784 2
		keyselect = ShmKey == SEL_SHM_KEY;
		if (keyselect)
d6786 4
a6789 9
			if (owner)
				ShmKey = FIRST_SHM_KEY;
			else
			{
				ShmKey = read_key_file(ShmKeyFile, ShmKey);
				keyselect = false;
				if (ShmKey == SEL_SHM_KEY)
					goto error;
			}
d6791 1
d6793 10
a6802 1
		for (;;)
d6804 2
a6805 7
			/* XXX: maybe allow read access for group? */
			Pshm = sm_shmstart(ShmKey, shms, SHM_R|SHM_W, &ShmId,
					   owner);
			save_errno = errno;
			if (Pshm != NULL || !sm_file_exists(save_errno))
				break;
			if (++count >= 3)
d6807 1
a6807 4
#if _FFR_SELECT_SHM
				if (keyselect)
				{
					++ShmKey;
d6809 5
a6813 5
					/* back where we started? */
					if (ShmKey == SEL_SHM_KEY)
						break;
					continue;
				}
d6815 2
a6816 2
				break;
			}
d6818 2
a6819 2
			/* only sleep if we are at the first key */
			if (!keyselect || ShmKey == SEL_SHM_KEY)
d6821 5
a6825 5
			sleep(count);
		}
		if (Pshm != NULL)
		{
			int *p;
d6828 2
a6829 2
			if (keyselect)
				(void) write_key_file(ShmKeyFile, (long) ShmKey);
d6831 21
a6851 2
			p = (int *) Pshm;
			if (owner)
d6853 10
a6862 4
				*p = (int) shms;
				*((pid_t *) SHM_OFF_PID(Pshm)) = CurrentPid;
				p = (int *) SHM_OFF_TAG(Pshm);
				*p = hash;
a6863 15
			else
			{
				if (*p != (int) shms)
				{
					save_errno = EINVAL;
					cleanup_shm(false);
					goto error;
				}
				p = (int *) SHM_OFF_TAG(Pshm);
				if (*p != (int) hash)
				{
					save_errno = EINVAL;
					cleanup_shm(false);
					goto error;
				}
d6865 8
a6872 8
				/*
				**  XXX how to check the pid?
				**  Read it from the pid-file? That does
				**  not need to exist.
				**  We could disable shm if we can't confirm
				**  that it is the right one.
				*/
			}
d6874 11
a6884 13
			PtrFileSys = (FILESYS *) OFF_FILE_SYS(Pshm);
			PNumFileSys = (int *) OFF_NUM_FILE_SYS(Pshm);
			QShm = (QUEUE_SHM_T *) OFF_QUEUE_SHM(Pshm);
			PRSATmpCnt = (int *) OFF_RSA_TMP_CNT(Pshm);
			*PRSATmpCnt = 0;
			if (owner)
			{
				/* initialize values in shared memory */
				NumFileSys = 0;
				for (i = 0; i < qn; i++)
					QShm[i].qs_entries = -1;
			}
			return;
d6886 3
d6890 6
a6895 7
		if (LogLevel > (owner ? 8 : 11))
		{
			sm_syslog(owner ? LOG_ERR : LOG_NOTICE, NOQID,
				  "can't %s shared memory, key=%ld: %s",
				  owner ? "initialize" : "attach to",
				  (long) ShmKey, sm_errstring(save_errno));
		}
d7106 1
@


1.19
log
@Update to sendmail.8.13.0
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.938 2004/06/03 19:02:10 ca Exp $")
d2402 2
a2403 1
runqueueevent()
@


1.18
log
@Update to sendmail 8.12.11.  I've been runninga beta version of this for
some time without problems.  See the RELEASE_NOTES for the change log.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.863.2.67 2003/12/02 23:56:01 ca Exp $")
d40 3
a42 2
**	QF_VERSION == 6 is  sendmail 8.12      without _FFR_QUEUEDELAY
**	QF_VERSION == 7 is  sendmail 8.12      with    _FFR_QUEUEDELAY
d45 2
a46 10
#if _FFR_QUEUEDELAY
# define QF_VERSION	7	/* version number of this queue format */
static time_t	queuedelay __P((ENVELOPE *));
# define queuedelay_qfver_unsupported(qfver) false
#else /* _FFR_QUEUEDELAY */
# define QF_VERSION	6	/* version number of this queue format */
# define queuedelay(e)	MinQueueAge
# define queuedelay_qfver_unsupported(qfver) ((qfver) == 5 || (qfver) == 7)
#endif /* _FFR_QUEUEDELAY */
#if _FFR_QUARANTINE
a48 1
#endif /* _FFR_QUARANTINE */
d299 1
a299 1
**	G	queue delay algorithm (_FFR_QUEUEDELAY)
d307 1
a307 1
**	q	quarantine reason (_FFR_QUARANTINE)
d315 1
a315 1
**	Y	current delay (_FFR_QUEUEDELAY)
d392 1
a392 1
					 (void *) &tfd, SM_IO_WRONLY_B,
d399 2
a400 2
			syserr("!queueup: cannot create queue file %s, euid=%d",
				tf, (int) geteuid());
d485 1
a485 1
		printaddr(e->e_sendqueue, true);
d508 1
d570 1
a606 9
#if _FFR_QUEUEDELAY
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "K%ld\n", (long) e->e_dtime);
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "G%d\n", e->e_queuealg);
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "Y%ld\n", (long) e->e_queuedelay);
	if (tTd(40, 64))
		sm_syslog(LOG_INFO, e->e_id,
			"queue alg: %d delay %ld next: %ld (now: %ld)\n",
			e->e_queuealg, e->e_queuedelay, e->e_dtime, curtime());
#else /* _FFR_QUEUEDELAY */
a607 1
#endif /* _FFR_QUEUEDELAY */
a640 1
#if _FFR_QUARANTINE
a644 1
#endif /* _FFR_QUARANTINE */
a737 1
#if _FFR_QUARANTINE
a739 1
#endif /* _FFR_QUARANTINE */
d751 1
a751 1
			printaddr(q, false);
d862 1
a874 1
#if _FFR_QUARANTINE
a875 1
#endif /* _FFR_QUARANTINE */
a882 1
# if _FFR_QUARANTINE
a911 1
# endif /* _FFR_QUARANTINE */
a944 1
#if _FFR_QUARANTINE
a945 1
#endif /* _FFR_QUARANTINE */
a1515 3
		**  This actually doesn't cause any harm, but CurRunners
		**  might become negative which is at least confusing.
		**
d1570 51
d1653 1
a1653 1
	int n;
d1667 1
d1702 4
d1708 37
a1744 2
		for (n = 0; n < skip && WorkQ != NULL; n++)
			WorkQ = WorkQ->w_next;
d1819 1
a1819 1
		sequenceno += skip; /* next sequence number */
d1949 2
a1950 1
				      bitset(RWG_PERSISTENT, flags) ? wgrp : -1);
d1964 1
d1977 1
a1977 1
			      PROC_QUEUE_CHILD, 0, -1);
a2019 1
#if _FFR_QUARANTINE
a2020 1
#endif /* _FFR_QUARANTINE */
d2165 12
a2176 2
				WorkQ = WorkQ->w_next; /* for the skip */
				sequenceno++;
d2178 1
a2178 1
					      PROC_QUEUE_CHILD, 0, -1);
d2192 1
d2304 3
a2306 3
		/* Update MX records for FallBackMX. */
		if (FallBackMX != NULL)
			(void) getfallbackmxrr(FallBackMX);
d2448 2
a2449 4
#if _FFR_QUARANTINE
# define HAS_QUARANTINE		0040	/* has an unexpected 'q' line */
# define NEED_QUARANTINE	0100	/* 'q': reason */
#endif /* _FFR_QUARANTINE */
a2514 1
#if _FFR_QUARANTINE
a2525 1
#endif /* _FFR_QUARANTINE */
a2555 1
#if _FFR_QUARANTINE
a2562 3
#else /* _FFR_QUARANTINE */
		if (d->d_name[0] != NORMQF_LETTER || d->d_name[1] != 'f')
#endif /* _FFR_QUARANTINE */
a2632 1
#if _FFR_QUARANTINE
a2634 1
#endif /* _FFR_QUARANTINE */
a2646 1
#if _FFR_QUARANTINE
a2647 1
#endif /* _FFR_QUARANTINE */
a2708 1
#if _FFR_QUARANTINE
a2710 1
#endif /* _FFR_QUARANTINE */
a2744 1
#if _FFR_QUARANTINE
a2776 1
#endif /* _FFR_QUARANTINE */
a2847 11

#if _FFR_QUEUEDELAY
/*
			  case 'G':
				queuealg = atoi(lbuf[1]);
				break;
			  case 'Y':
				queuedelay = (time_t) atol(&lbuf[1]);
				break;
*/
#endif /* _FFR_QUEUEDELAY */
a2853 1
#if _FFR_QUARANTINE
a2855 1
#endif /* _FFR_QUARANTINE */
d2914 2
d2917 1
a2917 1
		for (w = WorkQ; w != NULL; )
d2919 1
a2919 3
			register WORK *nw = w->w_next;

			WorkQ = nw;
a2923 1
			w = nw;
a2924 1
		sm_free((char *) WorkQ);
d3036 1
a3036 1
	else
d3044 1
d3068 9
a3810 1
#if _FFR_QUARANTINE
a3813 1
#endif /* _FFR_QUARANTINE */
a4104 1
#if _FFR_QUARANTINE
a4105 1
#endif /* _FFR_QUARANTINE */
a4113 4
#if _FFR_QUEUEDELAY
	e->e_queuealg = QD_LINEAR;
	e->e_queuedelay = (time_t) 0;
#endif /* _FFR_QUEUEDELAY */
a4235 7
#if _FFR_QUEUEDELAY
		  case 'G':		/* queue delay algorithm */
			e->e_queuealg = atoi(&buf[1]);
			break;
#endif /* _FFR_QUEUEDELAY */

#if _FFR_QUARANTINE
a4240 1
#endif /* _FFR_QUARANTINE */
d4273 1
a4273 1
			    now < e->e_dtime + queuedelay(e))
a4402 4
			if (queuedelay_qfver_unsupported(qfver))
				syserr("queue file version %d not supported: %s",
				       qfver,
				       "sendmail not compiled with _FFR_QUEUEDELAY");
a4411 6
#if _FFR_QUEUEDELAY
		  case 'Y':		/* current delay */
			e->e_queuedelay = (time_t) atol(&buf[1]);
			break;
#endif /* _FFR_QUEUEDELAY */

d4441 18
a4829 1
#if _FFR_QUARANTINE
a4830 1
#endif /* _FFR_QUARANTINE */
a4892 1
#if _FFR_QUARANTINE
a4894 1
#endif /* _FFR_QUARANTINE */
a4903 1
#if _FFR_QUARANTINE
a4904 1
#endif /* _FFR_QUARANTINE */
a4928 1
#if _FFR_QUARANTINE
a4934 1
#endif /* _FFR_QUARANTINE */
d4965 1
a4965 1
#if _FFR_QUARANTINE
d4975 1
a4975 1
#endif /* _FFR_QUARANTINE */
a5057 1
#if _FFR_QUARANTINE
a5104 1
#endif /* _FFR_QUARANTINE */
a5135 2

#if _FFR_QUARANTINE
a5136 1
#endif /* _FFR_QUARANTINE */
a5203 1
#if _FFR_QUARANTINE
a5204 1
#endif /* _FFR_QUARANTINE */
d5285 2
a5286 2
**              the range 0 to 59, but can be up to 61 to allow for
**              leap seconds.
d5359 1
a5359 1
#if _FFR_QUARANTINE
d5362 1
a5362 1
#endif /* _FFR_QUARANTINE */
a5549 1
#if _FFR_QUARANTINE
a5551 1
#endif /* _FFR_QUARANTINE */
d7241 5
a7370 38
#if _FFR_QUEUEDELAY
/*
**  QUEUEDELAY -- compute queue delay time
**
**	Parameters:
**		e -- the envelope to queue up.
**
**	Returns:
**		queue delay time
**
**	Side Effects:
**		may change e_queuedelay
*/

static time_t
queuedelay(e)
	ENVELOPE *e;
{
	time_t qd;

	if (e->e_queuealg == QD_EXP)
	{
		if (e->e_queuedelay == 0)
			e->e_queuedelay = QueueInitDelay;
		else
		{
			e->e_queuedelay *= 2;
			if (e->e_queuedelay > QueueMaxDelay)
				e->e_queuedelay = QueueMaxDelay;
		}
		qd = e->e_queuedelay;
	}
	else
		qd = MinQueueAge;
	return qd;
}
#endif /* _FFR_QUEUEDELAY */

a7717 1
#if _FFR_QUARANTINE
a7720 1
#endif /* _FFR_QUARANTINE */
a8250 1
#if _FFR_QUARANTINE
d8478 3
a8480 1
	     ((SuperSafe == SAFE_REALLY || SuperSafe == SAFE_INTERACTIVE) &&
a8724 1
#endif /* _FFR_QUARANTINE */
@


1.17
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.863.2.61 2003/09/03 19:58:26 ca Exp $")
d25 10
a34 1
# define TF_OPEN_FLAGS (O_CREAT|O_WRONLY|O_EXCL)
d370 12
d394 1
a394 1
		tfd = open(tf, TF_OPEN_FLAGS, FileMode);
d396 1
d398 1
d422 1
a422 8
				MODE_T oldumask = 0;

				if (bitset(S_IWGRP, QueueFileMode))
					oldumask = umask(002);
				tfd = open(tf, TF_OPEN_FLAGS, QueueFileMode);
				if (bitset(S_IWGRP, QueueFileMode))
					(void) umask(oldumask);

d433 4
d440 4
d446 3
a448 1
				else if (LogLevel > 0 && (i % 32) == 0)
d5201 30
d5247 1
a5247 1
static const char QueueIdChars[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwx";
d5249 12
d5315 2
a5316 2
	idbuf[4] = QueueIdChars[tm->tm_min];
	idbuf[5] = QueueIdChars[tm->tm_sec];
d7428 1
a7428 2
	int i, j, total_runners = 0;
	int dir;
d7431 1
d7527 2
a7528 1
		WorkGrp[j].wg_qgs[WorkGrp[j].wg_numqgrp] = Queue[si[i].sg_idx];
d7530 2
a7531 2
		WorkGrp[j].wg_runners += Queue[i]->qg_maxqrun;
		Queue[si[i].sg_idx]->qg_wgrp = j;
d7537 3
a7539 3
			    Queue[i]->qg_maxqrun > MaxQueueChildren)
				Queue[i]->qg_maxqrun = MaxQueueChildren;
			WorkGrp[j].wg_maxact = Queue[i]->qg_maxqrun;
d7549 3
a7551 3
		if (Queue[si[i].sg_idx]->qg_queueintvl > 0 &&
		    WorkGrp[j].wg_lowqintvl < Queue[si[i].sg_idx]->qg_queueintvl)
			WorkGrp[j].wg_lowqintvl = Queue[si[i].sg_idx]->qg_queueintvl;
@


1.16
log
@Update to sendmail 8.12.9; fixes a buffer overflow in address parsing
due to a char to int conversion problem which is potentially remotely
exploitable.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.863.2.30 2003/03/20 00:20:16 ca Exp $")
d23 3
d29 4
a32 4
**     QF_VERSION == 4 was sendmail 8.10/8.11 without _FFR_QUEUEDELAY
**     QF_VERSION == 5 was sendmail 8.10/8.11 with    _FFR_QUEUEDELAY
**     QF_VERSION == 6 is  sendmail 8.12      without _FFR_QUEUEDELAY
**     QF_VERSION == 7 is  sendmail 8.12      with    _FFR_QUEUEDELAY
d73 15
d364 26
a389 2
	if (tfp == NULL)
		newid = false;
a393 2
		const int flags = O_CREAT|O_WRONLY|O_EXCL;

d403 1
a403 1
				tfd = open(tf, flags, QueueFileMode);
d442 1
a442 1
						 (void *) &tfd, SM_IO_WRONLY,
d528 2
a529 1
		dfd = open(df, O_WRONLY|O_CREAT|O_TRUNC, QueueFileMode);
d533 1
a533 1
						 (void *) &dfd, SM_IO_WRONLY,
a1595 3
/* Get new load average every 30 seconds. */
#define GET_NEW_LA_TIME	30

d1606 1
a1606 1
	time_t current_la_time, now;
d1608 1
a1608 1
	current_la_time = curtime();
d1664 2
a1665 7
		now = curtime();
		if (current_la_time < now - GET_NEW_LA_TIME)
		{
			sm_getla();
			current_la_time = now;
		}
		if (shouldqueue(WkRecipFact, current_la_time))
d1779 1
a1779 1
	time_t current_la_time, now;
d1794 1
a1794 2
	sm_getla();	/* get load average */
	current_la_time = curtime();
d1797 1
a1797 1
	    shouldqueue(WkRecipFact, current_la_time))
d2070 1
a2070 1
				return 0;
d2251 2
a2252 6
		now = curtime();
		if (njobs == 0 && current_la_time < now - GET_NEW_LA_TIME)
		{
			sm_getla();
			current_la_time = now;
		}
d2576 1
a2576 1
		cf = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, qf, SM_IO_RDONLY,
d2717 2
d3825 1
a3825 1
	qfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, qf, SM_IO_RDWR, NULL);
d3857 2
a3884 1
		RELEASE_QUEUE;
a3906 1
		RELEASE_QUEUE;
a3971 1
		RELEASE_QUEUE;
a3983 1
		RELEASE_QUEUE;
a3994 1
		RELEASE_QUEUE;
d4184 1
a4184 1
			**  better than before. "+3" to skip H?? at least.
d4187 1
a4187 1
			hdrsize += strlen(bp + 3);
a4228 1
				RELEASE_QUEUE;
d4303 7
a4309 2
			q = parseaddr(++p, NULLADDR, RF_COPYALL, '\0', NULL, e,
				      true);
d4325 2
a4407 1
		RELEASE_QUEUE;
a4415 1
		RELEASE_QUEUE;
d4435 1
a4435 1
	e->e_dfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, p, SM_IO_RDONLY,
a4456 1
	RELEASE_QUEUE;
a4473 1
	RELEASE_QUEUE;
d4772 1
a4772 1
		f = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, qf, SM_IO_RDONLY,
d6623 1
a6623 1
			if (Pshm != NULL || save_errno != EEXIST)
d6713 1
d8283 1
a8283 1
			     SM_IO_WRONLY, NULL);
@


1.15
log
@Update to Sendmail 8.12.8; fixes a buffer overflow in the envelope
comments processing which may allow an attacker to gain root privileges.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.863.2.28 2003/02/11 17:17:22 ca Exp $")
d35 1
a35 1
#define queuedelay_qfver_unsupported(qfver) false
d39 1
a39 1
#define queuedelay_qfver_unsupported(qfver) ((qfver) == 5 || (qfver) == 7)
d222 1
a222 1
#define QSHM_ENTRIES(i)	QShm[i].qs_entries
d3319 2
a3320 2
#define NASCII	128
#define NCHAR	256
@


1.14
log
@update to sendmail 8.12.7
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.863.2.22 2002/12/19 18:00:39 ca Exp $")
a19 4
#if SM_CONF_SHM
# include <sm/shm.h>
#endif /* SM_CONF_SHM */

d76 1
a76 1
static bool	volatile DoQueueRun;	/* non-interrupt time queue run needed */
d1690 1
a1690 1
				      ForkQueueRuns , false, e);
a3444 1

a3630 1

d6719 3
a6721 1
	if (len >= sizeof basedir)
d6724 1
a6724 1
			len, (int) sizeof basedir);
@


1.13
log
@update to sendmail-8.12.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.863.2.6 2002/08/16 16:27:37 gshapiro Exp $")
d30 4
a33 2
**	QF_VERSION==4 was sendmail 8.10/8.11 without _FFR_QUEUEDELAY
**	QF_VERSION==5 was sendmail 8.10/8.11 with    _FFR_QUEUEDELAY
d139 1
d204 1
d262 1
d273 1
d1209 1
a1209 1
		(void) run_work_group(wgrp, true, false, true, true);
d1447 2
d1488 9
a1496 2
		ret = run_work_group(curnum, forkflag, verbose, persistent,
				     runall);
d1694 1
a1694 1
				      false, false, e);
d1729 1
a1729 6
**		forkflag -- true if the queue scanning should be done in
**			a child process.  We double-fork so it is not our
**			child and we don't have to clean up after it.
**		verbose -- if true, print out status information.
**		persistent -- persistent queue runner?
**		runall -- true: run all of the queue groups in this work group
d1742 1
a1742 1
run_work_group(wgrp, forkflag, verbose, persistent, runall)
d1744 1
a1744 4
	bool forkflag;
	bool verbose;
	bool persistent;
	bool runall;
d1768 2
a1769 1
	if (!persistent && shouldqueue(WkRecipFact, current_la_time))
d1773 1
a1773 1
		if (verbose)
d1784 3
a1786 1
	if (forkflag && WorkGrp[wgrp].wg_lowqintvl > 0 && !persistent &&
d1791 1
a1791 1
		if (verbose)
d1803 1
a1803 1
	if (forkflag)
d1816 1
a1816 1
			if (verbose)
d1832 1
a1832 1
				      persistent ? wgrp : -1);
d1889 1
a1889 1
	if (forkflag)
d1921 1
a1921 1
	**  runall is set or the bit for this group is set.
d1935 1
a1935 1
		if (runall ||
d1942 1
a1942 1
			if (forkflag)
d1971 1
a1971 1
			  forkflag);
a2027 18
#if _FFR_NONSTOP_PERSISTENCE
			/*
			**  Require a free "slot" before processing
			**  this queue runner.
			*/

			while (MaxQueueChildren > 0 &&
			       CurChildren > MaxQueueChildren)
			{
				int status;
				pid_t ret;

				while ((ret = sm_wait(&status)) <= 0)
					continue;
				proc_list_drop(ret, status, NULL);
			}
#endif /* _FFR_NONSTOP_PERSISTENCE */

a2110 1
#if !_FFR_NONSTOP_PERSISTENCE
a2128 1
#endif /* !_FFR_NONSTOP_PERSISTENCE */
d2130 1
a2130 1
	else
d2155 1
a2155 1
	if (persistent)
d2237 1
a2237 1
	if (forkflag)
d2911 3
a2913 4
		**  Sort randomly.
		**	workcmpf5() returns a random 1 or -1.
		**	As long as nobody does a verification pass over the
		**	sorted list, we should be golden.
d2916 3
d3221 3
a3223 1
	return (get_rand_mod(2)) ? 1 : -1;
d3449 1
d3636 1
d6475 1
a6475 1
	keyf = safefopen(keypath, O_WRONLY|O_TRUNC, 0644, sff);
d6485 1
a6485 1
		ok = ok && (sm_io_close(keyf, SM_TIME_DEFAULT) != SM_IO_EOF);
d6513 1
a6513 1
	if (TrustedUid != 0 && RealUid == TrustedUid)
d6515 1
a6515 1
	keyf = safefopen(keypath, O_RDONLY, 0644, sff);
a6575 1
		size_t shms;
d8010 2
d8054 1
a8054 1
	if (LogLevel > SPLIT_LOG_LEVEL && lsplits != NULL && nsplit > 0)
d8056 7
a8062 4
		sm_syslog(LOG_NOTICE, e->e_id,
			  "split: maxrcpts=%d, rcpts=%d, count=%d, id%s=%s",
			  maxrcpt, nrcpt - ndead, nsplit,
			  nsplit > 1 ? "s" : "", lsplits);
@


1.12
log
@sendmail 8.12.5
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.863.2.2 2002/06/25 21:34:31 gshapiro Exp $")
d1466 11
d1479 1
d1486 2
d1491 2
d1494 1
a1495 2
		/* Success means the runner count needs to be updated. */
		CurRunners += WorkGrp[curnum].wg_maxact;
d2018 18
d2119 1
d2138 1
d5670 2
d5673 1
a5673 1
		**  Use the queue group of the first recipient, as set by
d5678 4
d5684 7
a5690 1
		if (e->e_sendqueue == NULL)
d5692 5
a5696 5
		else if (e->e_sendqueue->q_qgrp >= 0)
			e->e_qgrp = e->e_sendqueue->q_qgrp;
		else if (e->e_sendqueue->q_mailer != NULL &&
			 ISVALIDQGRP(e->e_sendqueue->q_mailer->m_qgrp))
			e->e_qgrp = e->e_sendqueue->q_mailer->m_qgrp;
d7720 1
d7731 1
d7756 1
d7770 2
d7773 1
d7782 1
a7782 1
	if (naddrs <= 1)
@


1.11
log
@Update to sendmail-8.12.4
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.862 2002/05/09 23:51:53 ca Exp $")
d283 1
a283 1
**	M	message (obsolete)
d4206 1
a4206 1
		  case 'r':		/* original recipient */
@


1.10
log
@update to sendmail 8.12.3
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.857 2002/04/02 16:43:25 ca Exp $")
d372 1
a372 1
							  tf, geteuid(),
d408 1
a408 1
				tf, geteuid());
d452 1
a452 1
			       queuename(e, DATAFL_LETTER), geteuid());
d493 1
a493 1
				df, geteuid());
d527 1
a527 1
				df, geteuid());
d834 1
a834 1
				tf, qf, geteuid());
d4394 4
d5409 1
a5409 1
			       buf, p, geteuid());
d5749 12
a5760 3
	if (i != 0 && tTd(41, 2))
		sm_dprintf("chkqdir: \"%s\": Not safe: %s\n",
			   name, sm_errstring(i));
d5825 5
d6846 1
a6846 1
			sm_syslog(LOG_INFO, NOQID, "sh_shmstop failed=%s",
d8267 1
a8267 1
		  case 'R':
@


1.9
log
@update to sendmail-8.12.2
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.834 2002/01/08 23:04:58 ca Exp $")
d74 2
a75 4
**  use of DoQueueRun:
**	NumQueue: indicates that a queue run is needed, look at individual bits
**	0 - NumQueue-1: indicates that a queue run for this queue group
**		is needed.
d78 1
a78 1
static BITMAP256	volatile DoQueueRun;	/* non-interrupt time queue run needed */
d125 1
a125 1
static void	schedule_queue_runs __P((bool, int));
d1218 1
d1229 1
a1229 1
schedule_queue_runs(runall, wgrp)
d1232 1
d1235 6
d1247 2
d1254 4
d1265 21
a1285 2
		if ((runall || bitnset(qgrp, DoQueueRun)) && qintvl > 0)
			(void) sm_setevent(qintvl, runqueueevent, qgrp);
d1289 1
a1289 1
				"sqr: wgrp=%d, cgrp=%d, qgrp=%d, intvl=%ld, QI=%ld, runall=%d, bit=%d, sched=%d",
d1291 2
a1292 3
				QueueIntvl, runall, bitnset(qgrp, DoQueueRun),
				(runall || bitnset(qgrp, DoQueueRun)) &&
				qintvl > 0);
a1293 1
		clrbitn(qgrp, DoQueueRun);
d1296 2
d1299 57
a1376 1
**
d1412 1
a1412 1
	clrbitn(NumQueue, DoQueueRun);
d1482 1
a1482 1
			schedule_queue_runs(runall, curnum);
d1493 1
a1493 1
			schedule_queue_runs(runall, h);
d1728 1
a1728 1
	time_t current_la_time;
d1899 1
d1910 3
a1912 1
		if (runall || bitnset(qgrp, DoQueueRun))
a2131 2
		time_t now;

d2225 1
a2225 1
	return bitnset(NumQueue, DoQueueRun);
d2229 1
a2229 5
**  RUNQUEUEEVENT -- stub for use in sm_setevent
**
**  Sets the bit to indicate that on the next run this queue should be
**  processed. The work group that the queue group is a member of has its
**  count of queue's to process updated.
d2232 1
a2232 1
**		qgrp -- the index of the queue group.
a2237 2
**		The work group that the queue group is a member of has its
**		count of queues to process updated.
d2253 1
a2253 2
runqueueevent(qgrp)
	int qgrp;
a2254 1
	int i;
d2262 5
a2266 8
	setbitn(NumQueue, DoQueueRun);

	/* if it is a specific group: set that bit */
	if (qgrp != NOQGRP)
	{
		setbitn(qgrp, DoQueueRun);
		goto ret;
	}
a2267 8
	/* for all others: set the bit if it doesn't have a queue interval */
	for (i = 0; i < NumQueue; i++)
	{
		if (Queue[i]->qg_queueintvl <= 0)
			setbitn(i, DoQueueRun);
	}

  ret:
d2446 1
a2446 1
			if (strcontainedin(true, check->queue_match,
d3761 1
d4007 2
a4008 7
			(void) sm_io_close(qfp, SM_TIME_DEFAULT);

			/* the file is already on disk */
			e->e_flags |= EF_INQUEUE;
			loseqfile(e, "bogus queue line");
			RELEASE_QUEUE;
			return false;
d4060 2
a4061 3
				loseqfile(e, "bogus queue file directory");
				RELEASE_QUEUE;
				return false;
d4075 2
a4076 4
				(void) sm_io_close(qfp, SM_TIME_DEFAULT);
				loseqfile(e, "bogus queue line");
				RELEASE_QUEUE;
				return false;
d4128 8
a4136 1
			hdrsize += strlen(&bp[1]);
d4256 3
d4290 2
a4291 4
			(void) sm_io_close(qfp, SM_TIME_DEFAULT);
			loseqfile(e, "unsupported queue file version");
			RELEASE_QUEUE;
			return false;
d4333 2
a4334 4
			(void) sm_io_close(qfp, SM_TIME_DEFAULT);
			loseqfile(e, "unrecognized line");
			RELEASE_QUEUE;
			return false;
d4399 18
d5076 2
a5077 1
	if (e->e_qdir == NOQDIR)
d6379 92
d6498 3
d6504 5
d6519 15
d6543 12
d6556 5
d6567 4
d6651 1
d6721 5
a6725 2
	/* initialize map for queue runs */
	clrbitmap(DoQueueRun);
d6875 1
a6875 1
#if 0
d6877 1
a6877 1
#endif /* 0 */
d7018 1
a7018 1
#if 0
d7044 12
a7055 1
				qgrp->qg_sortorder = QSO_BYMODTIME;
d7057 1
d7063 1
a7063 1
#endif /* 0 */
d7359 7
a7365 3
		WorkGrp[j].wg_qgs = (QUEUEGRP **)sm_realloc(WorkGrp[j].wg_qgs,
						sizeof(QUEUEGRP *) *
						(WorkGrp[j].wg_numqgrp + 1));
d7368 1
a7368 1
			syserr("@@cannot allocate memory for work queues, need %d bytes",
d7449 9
a7457 1
	SM_REQUIRE(bitset(EF_HAS_DF, old->e_flags));
d7559 5
d7576 1
a7576 1
	**  sendall() does this copying, but I don't know if that is
d7703 2
@


1.8
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.788 2001/09/30 16:32:47 ca Exp $")
d43 4
a46 1

d124 1
a124 2
static int	print_single_queue __P((int, int));
static bool	readqf __P((ENVELOPE *));
a280 1
**	h	hold reason (_FFR_QUARANTINE)
d288 1
a324 1
	char *qf;
d334 1
d336 1
a336 1
	char dfname[MAXPATHLEN];
d445 1
a445 1
	(void) sm_strlcpy(dfname, queuename(e, DATAFL_LETTER), sizeof dfname);
d452 1
d454 2
a455 2
				queuename(e, DATAFL_LETTER), geteuid());

d468 1
a468 1
					       dfname);
d471 1
a471 1
					       dfname);
d488 1
a488 1
		dfd = open(dfname, O_WRONLY|O_CREAT|O_TRUNC, QueueFileMode);
d495 1
a495 1
				dfname, geteuid());
d520 1
a520 1
					       dfname);
d523 1
a523 1
					       dfname);
d529 1
a529 1
				dfname, geteuid());
d536 1
a536 1
	**	they are required by orderq.
d592 3
a594 3
	if (e->e_holdmsg != NULL)
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "h%s\n",
				     denlstring(e->e_holdmsg, true, false));
d687 7
d695 1
a695 1
			message("queued");
d698 1
a698 1
					    "queued", NULL, (time_t) 0, e);
d827 4
d832 2
a833 1
		qf = queuename(e, ANYQFL_LETTER);
a836 1

d838 1
a838 3
		/* Check if type has changed */
		if (e->e_qfletter != '\0' &&
		    e->e_qfletter != qf[0])
d840 5
a844 1
			char new = qf[0];
d846 2
a847 2
			/* If it has changed, remove the old item */
			if (tTd(40, 5))
d849 5
a853 5
				sm_dprintf("type changed from %c to %c\n",
					   e->e_qfletter, new);
				if (tTd(40, 101))
					pause();
			}
d855 9
a863 8
			qf[0] = e->e_qfletter;
			if (unlink(qf) < 0)
			{
				/* XXX: something more drastic? */
				if (LogLevel > 0)
					sm_syslog(LOG_ERR, e->e_id,
						  "queueup: unlink(%s) failed: %s",
						  qf, sm_errstring(errno));
a864 1
			qf[0] = new;
d866 1
a866 1
		e->e_qfletter = qf[0];
d890 4
d897 4
a900 1
		qf = tf;
d902 1
a902 1
		e->e_qfletter = qf[0];
a908 4
	/* save log info */
	if (LogLevel > 79)
		sm_syslog(LOG_DEBUG, e->e_id, "queueup %s", qf);

d989 1
a989 1
**	child queue runner processees are signaled (it should be SIGTERM
d1050 1
a1050 1
**	child queue runner processees are signaled (it should be SIGHUP
d1104 1
a1104 1
**		reason -- why (signal?).
d1110 1
a1110 1
**		Sets global RestartWorkGroup to true.
d1126 2
a1127 1
	RestartWorkGroup = true;
d1327 1
a1327 1
	/* more then one queue or more then one directory per queue */
d1790 1
a1790 1
	    QueueLimitReason != NULL ||
d1828 1
a1828 1
				finis(true, ExitStat);
d1842 1
d1846 1
d1944 1
a1944 1
				/* Reset global flags */
d1959 18
a1976 1
				if (MaxQueueChildren > 0)
d1987 3
a1989 1
				finis(true, ExitStat); /* This child is done */
d2012 1
a2012 1
			(void) proc_list_drop(ret, NULL, NULL);
d2104 1
a2104 1
		**  and over but orderq() may ignore entries due to
d2125 1
a2125 1
		finis(true, ExitStat);
d2225 5
a2229 5
#define NEED_P		001	/* 'P': priority */
#define NEED_T		002	/* 'T': time */
#define NEED_R		004	/* 'R': recipient */
#define NEED_S		010	/* 'S': sender */
#define NEED_H		020	/* host */
d2231 2
a2232 2
# define HAS_HOLD	040	/* has an unexpected 'h' line */
# define NEED_HOLD	100	/* 'h': reason */
d2270 1
a2270 1
		sm_dprintf("orderq:\n");
d2300 1
a2300 1
		if (QueueMode == QM_HELD)
d2302 1
a2302 1
			check = QueueLimitReason;
d2305 1
a2305 1
				sm_dprintf("\tQueueLimitReason = %s%s\n",
d2318 1
a2318 1
		syserr("orderq: cannot open \"%s\"",
d2339 1
a2339 1
			sm_dprintf("orderq: checking %s..", d->d_name);
d2345 2
a2346 2
		       (QueueMode == QM_HELD &&
			d->d_name[0] == HELDQF_LETTER) ||
d2365 1
a2365 1
						     "orderq: %s too long, %d max characters\n",
d2369 1
a2369 1
					  "orderq: %s too long, %d max characters",
d2377 2
a2378 2
			if (strcontainedin(check->queue_match, d->d_name) !=
			    check->queue_negate)
d2412 1
a2412 1
					  "orderq: can't stat %s/%s",
d2424 1
a2424 1
			       d->d_name[0] == HELDQF_LETTER ||
d2429 1
a2429 1
				syserr("orderq: %s/%s is not a regular file",
d2440 1
a2440 1
		    QueueLimitReason == NULL &&
d2464 1
a2464 1
				sm_dprintf("orderq: cannot open %s: %s\n",
d2504 2
a2505 2
		if (QueueLimitReason != NULL)
			i |= NEED_HOLD;
d2542 2
a2543 2
			  case 'h':
				if (QueueMode != QM_HELD &&
d2547 1
a2547 1
						sm_dprintf("%s not marked as held but has an 'h' line\n",
d2549 1
a2549 1
					i |= HAS_HOLD;
d2551 1
a2551 1
				else if (QueueMode == QM_HELD)
d2553 1
a2553 1
					if (QueueLimitReason == NULL)
d2555 1
a2555 1
						i &= ~NEED_HOLD;
d2559 1
a2559 1
					check = QueueLimitReason;
d2562 2
a2563 1
						if (strcontainedin(check->queue_match,
d2571 1
a2571 1
						i &= ~NEED_HOLD;
d2605 2
a2606 1
					if (strcontainedin(check->queue_match,
d2621 2
a2622 1
					if (strcontainedin(check->queue_match,
d2662 2
a2663 2
		    bitset(HAS_HOLD, i) ||
		    bitset(NEED_HOLD, i) ||
d2818 1
a2818 1
		**	workcmpf5() retuns a random 1 or -1.
d3358 8
a3365 1
			if (MaxQueueChildren > 0)
d3427 1
a3427 1
		if (!readqf(e))
d3434 1
a3434 1
				finis(false, EX_OK);
d3458 1
a3458 1
			finis(true, ExitStat);
d3544 8
a3551 1
			if (MaxQueueChildren > 0)
d3609 2
a3610 2
		else if (QueueMode != QM_HELD &&
			 ei->e_holdmsg != NULL)
d3630 1
a3630 1
		if (readqf(&e))
d3657 1
a3657 1
		finis(true, ExitStat);
d3665 1
d3676 1
a3676 1
readqf(e)
d3678 1
d3844 2
a3845 1
		loseqfile(e, "bogus file uid/gid in mqueue");
d3854 1
a3854 1
		if (st.st_ctime + 10 * 60 < curtime())
d3876 10
d3889 1
d3894 4
d3907 1
a3907 1
	e->e_qfletter = qf[0];
d4058 2
a4059 2
		  case 'h':		/* hold message */
			e->e_holdmsg = sm_rpool_strdup_x(e->e_rpool, &bp[1]);
d4061 1
a4061 1
				  macid("{holdmsg}"), &bp[1]);
d4286 9
d4351 1
a4351 1
	char c;
d4502 1
a4502 1
**		none.
d4508 1
a4508 1
static int
d4616 1
a4616 1
		char holdmsg[MAXLINE];
d4664 1
a4664 1
			if (readqf(&e))
d4678 2
d4681 1
a4681 1
		if (QueueMode == QM_LOST)
a4682 2
		else if (QueueMode == QM_HELD)
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "!");
a4683 2
		if (w->w_lock)
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "*");
d4694 1
a4694 1
		holdmsg[0] = '\0';
d4721 5
a4725 5
			  case 'h':	/* hold message */
				if ((i = strlen(&buf[1])) >= sizeof holdmsg)
					i = sizeof holdmsg - 1;
				memmove(holdmsg, &buf[1], i);
				holdmsg[i] = '\0';
d4759 1
a4759 1
				if (holdmsg[0] != '\0')
d4763 1
a4763 1
							     "\n   ON HOLD: (%.*s)",
d4765 2
a4766 2
							     holdmsg);
					holdmsg[0] = '\0';
d4850 2
d4853 1
a4853 1
**  QUEUENAME -- build a file name in the queue directory for this envelope.
d4861 1
a4861 6
**		a pointer to the queue name (in a static buffer).
**
**	Side Effects:
**		If no id code is already assigned, queuename() will
**		assign an id code with assign_queueid().  If no queue
**		directory is assigned, one will be set with setnewqueue().
d4864 3
a4866 3
char *
queuename(e, type)
	register ENVELOPE *e;
a4868 10
	int qd, qg;
	char *sub = "/";
	char pref[3];
	static char buf[MAXPATHLEN];

	/* Assign an ID if needed */
	if (e->e_id == NULL)
		assign_queueid(e);

#if _FFR_QUARANTINE
d4872 2
a4873 2
		if (e->e_holdmsg != NULL)
			type = HELDQF_LETTER;
d4882 2
a4883 2
			  case QM_HELD:
				type = HELDQF_LETTER;
d4897 37
d4942 1
a4942 1
	if (type ==  XSCRPT_LETTER)
d5002 1
a5002 1
		  case HELDQF_LETTER:
d6835 9
d7192 1
a7192 1
**		On failure, EF_FATALERRS is set in new->e_flags.
d7219 1
a7219 1
			new->e_flags |= EF_FATALERRS;
a7229 6
	**
	**  We unlink the new file if it previously existed.  This protects
	**  us from abandoned data files left behind as a result of
	**  a prior system crash.  The envelope ids of these old files
	**  can conflict with the envelope ids we are generating right now
	**  if the clock was set back.
d7242 1
a7242 15
		if (errno == EEXIST)
		{
			if (unlink(npath) < 0)
			{
				syserr("@@can't unlink %s", npath);
				new->e_flags |= EF_FATALERRS;
				return false;
			}
			if (link(opath, npath) == 0)
			{
				new->e_flags |= EF_HAS_DF;
				SYNC_DIR(npath, true);
				return true;
			}
		}
d7260 6
a7265 17
	if (errno == EEXIST)
	{
		if (unlink(npath) < 0)
		{
			syserr("@@can't unlink %s", npath);
			new->e_flags |= EF_FATALERRS;
			return false;
		}
		if (link(opath, npath) == 0)
		{
			new->e_flags |= EF_HAS_DF;
			SYNC_DIR(npath, true);
			return true;
		}
	}
	syserr("@@can't link %s to %s", opath, npath);
	new->e_flags |= EF_FATALERRS;
d7312 5
d7356 1
a7356 2
**		On failure, e->e_flags & EF_FATALERRS is set.
**		e->e_sibling is not changed.
d7514 2
d7517 1
d7536 7
a7542 1
	e->e_flags |= EF_FATALERRS;
d7674 8
d7833 475
@


1.7
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.768 2001/09/08 01:21:09 gshapiro Exp $")
d279 1
d301 1
a301 1
/*
a316 3
# define TEMPQF_LETTER 'T'
# define LOSEQF_LETTER 'Q'

d342 1
a342 1
	(void) sm_strlcpy(tf, queuename(e, 't'), sizeof tf);
d347 1
a347 1
	/* if newid, just write the qf file directly (instead of tf file) */
d400 1
a400 1
						 (void *) tfd, SM_IO_WRONLY,
d413 4
a416 3
		sm_dprintf("\n>>>>> queueing %s/qf%s%s >>>>>\n",
			qid_printqueue(e->e_qgrp, e->e_qdir), e->e_id,
			newid ? " (new id)" : "");
d443 1
a443 1
	(void) sm_strlcpy(dfname, queuename(e, 'd'), sizeof dfname);
d451 1
a451 1
				queuename(e, 'd'), geteuid());
d489 1
a489 1
						 (void *) dfd, SM_IO_WRONLY,
d562 2
a563 2
	**  If df file is in a different directory than the qf file,
	**  output a "d" record naming the directory of the df file.
d587 7
d817 2
a818 2
		/* rename (locked) tf to be (locked) qf */
		qf = queuename(e, 'q');
d823 30
d870 1
a870 1
		/* close and unlock old (locked) qf */
d876 1
d878 5
d888 1
a888 1
		sm_syslog(LOG_DEBUG, e->e_id, "queueup, qf=%s", qf);
d895 1
a895 1
/*
d965 1
a965 1
/*
d1026 1
a1026 1
/*
d1078 1
a1078 1
/*
d1109 1
a1109 1
/*
d1153 1
a1153 1
/*
d1194 1
a1194 1
/*
d1248 1
a1248 1
/*
d1398 1
a1398 1
/*
d1584 1
a1584 1
/*
d1769 3
d2162 1
a2162 1
/*
d2189 4
d2257 14
d2298 1
a2298 1
			sm_dprintf("orderq: checking %s\n", d->d_name);
d2301 14
a2314 1
		if (d->d_name[0] != 'q' || d->d_name[1] != 'f')
d2316 3
d2380 7
a2386 2
			if (!((d->d_name[0] == 'd' || d->d_name[0] == 'q' ||
			       d->d_name[0] == 'x') &&
d2398 3
d2462 4
d2500 34
d2617 4
d2649 1
a2649 1
/*
d2765 1
a2765 1
		**  Sort based on qf filename.
d2784 1
a2784 1
		**  Simple sort based on modification time of qf file.
d2853 1
a2853 1
/*
d2910 1
a2910 1
/*
d2939 1
a2939 1
/*
d2978 1
a2978 1
/*
d3017 1
a3017 1
/*
d3043 1
a3043 1
/*
d3064 1
a3064 1
/*
d3083 1
a3083 1
/*
d3110 1
a3110 1
/*
d3150 1
a3150 1
/*
d3237 1
a3237 1
/*
d3550 5
d3602 1
a3602 1
/*
d3639 1
a3639 1
	(void) sm_strlcpy(qf, queuename(e, 'q'), sizeof qf);
d3778 2
a3779 2
				  "bogus queue file, uid=%d, mode=%o",
				  st.st_uid, st.st_mode);
d3783 2
a3784 1
		loseqfile(e, "bogus file uid in mqueue");
d3795 2
a3796 2
			(void) xunlink(queuename(e, 'd'));
			(void) xunlink(queuename(e, 'q'));
d3830 3
d3849 1
a3849 1
		int mid;
d3858 3
a3860 1
			syserr("SECURITY ALERT: extra data in qf: %s", bp);
d3862 3
d3872 2
d3878 3
d3896 5
d3981 8
d4135 1
a4135 1
				syserr("qf version %d not supported: %s",
d4140 1
a4140 1
			syserr("Version number in qf (%d) greater than max (%d)",
d4143 1
a4143 1
			loseqfile(e, "unsupported qf file version");
d4172 2
a4173 2
				mid = macid_parse(&bp[1], &ep);
				if (mid == 0)
d4176 1
a4176 1
				macdefine(&e->e_macro, A_PERM, mid, p);
d4225 1
a4225 1
	p = queuename(e, 'd');
d4247 1
a4247 1
/*
d4290 1
a4290 1
/*
d4373 1
a4373 1
/*
d4409 1
a4409 1
/*
d4530 3
d4560 1
a4560 1
		w->w_name[0] = 'd';
d4581 1
a4581 1
				char *df = queuename(&e, 'd');
d4593 6
d4610 3
d4637 9
d4675 11
d4767 1
a4767 1
/*
d4798 31
d4835 1
a4835 1
	if (type ==  'x')
d4871 1
a4871 1
		if (type ==  'd')
d4889 1
a4889 1
		  case 'd':
d4894 3
d4898 1
a4898 1
		  case 't':
d4900 1
a4900 1
		  case 'q':
d4905 1
a4905 1
		  case 'x':
d4923 1
a4923 1
/*
d5009 4
d5019 1
a5019 1
/*
d5047 1
a5047 1
/*
d5082 1
a5082 1
		(void) xunlink(queuename(e, 'x'));
d5084 1
a5084 1
/*
d5092 1
a5092 1
**		qfver -- the version stamp of this qf file.
d5173 2
a5174 2
/*
**  LOSEQFILE -- save the qf as Qf and try to let someone know
d5189 1
d5195 1
a5195 1
	p = queuename(e, 'q');
d5200 16
a5215 6
	p = queuename(e, LOSEQF_LETTER);
	if (rename(buf, p) < 0)
		syserr("cannot rename(%s, %s), uid=%d", buf, p, geteuid());
	else if (LogLevel > 0)
		sm_syslog(LOG_ALERT, e->e_id,
			  "Losing %s: %s", buf, why);
d5223 1
a5223 1
/*
d5245 1
a5245 1
/*
d5278 2
a5279 2
/*
**  QID_PRINTQUEUE -- create full version of queue directory for df files
d5407 1
a5407 1
/*
d5488 1
a5488 1
/*
d5556 1
a5556 1
/*
d6124 1
a6124 1
/*
d6185 1
a6185 1
/*
d6300 1
a6300 1
/*
d6423 16
d6474 1
a6474 1
/*
d6502 1
a6502 1
/*
d6518 1
a6518 1
/*
d6547 1
a6547 1
/*
d6783 1
a6783 1
/*
d6830 1
a6830 1
/*
d7064 2
a7065 2
**	and the new qf file will contain a 'd' record pointing to the
**	directory containing the new df file.
d7094 2
a7095 2
	(void) sm_strlcpy(opath, queuename(old, 'd'), sizeof opath);
	(void) sm_strlcpy(npath, queuename(new, 'd'), sizeof npath);
d7157 1
a7157 1
	(void) sm_strlcpy(npath, queuename(new, 'd'), sizeof npath);
d7247 1
a7247 1
/*
d7264 1
a7264 1
**		on disk.  But the 'qf' files are not created.
d7632 1
a7632 1
/*
@


1.6
log
@update to sendmail 8.11.5
@
text
@d14 3
d18 5
a22 1
#include <sendmail.h>
d24 2
a25 7
#ifndef lint
# if QUEUE
static char id[] = "@@(#)$Sendmail: queue.c,v 8.343.4.62 2001/07/20 00:53:01 gshapiro Exp $ (with queueing)";
# else /* QUEUE */
static char id[] = "@@(#)$Sendmail: queue.c,v 8.343.4.62 2001/07/20 00:53:01 gshapiro Exp $ (without queueing)";
# endif /* QUEUE */
#endif /* ! lint */
a26 1
# include <dirent.h>
d28 5
a32 1
#if QUEUE
d34 2
a35 2
# if _FFR_QUEUEDELAY
#  define QF_VERSION	5	/* version number of this queue format */
d37 9
a45 4
# else /* _FFR_QUEUEDELAY */
#  define QF_VERSION	4	/* version number of this queue format */
#  define queuedelay(e)	MinQueueAge
# endif /* _FFR_QUEUEDELAY */
d58 4
a61 1
	time_t		w_ctime;	/* creation time of message */
d67 46
a112 1
static WORK	*WorkQ;			/* queue of things to be done */
d114 8
a121 4
static void	grow_wlist __P((int));
static int	orderq __P((int, bool));
static void	printctladdr __P((ADDRESS *, FILE *));
static int	print_single_queue __P((int));
d123 3
a125 2
static void	runqueueevent __P((void));
static int	run_single_queue __P((int, bool, bool));
d127 5
a131 1
static ADDRESS	*setctluser __P((char *, int));
d137 130
d275 1
d278 1
a278 1
**	G	queue delay algorithm
d287 1
d292 2
a293 2
**	X	character set (_FFR_SAVE_CHARSET)
**	Y	current delay
d295 1
d305 2
a306 1
**		announce -- if TRUE, tell when you are queueing up.
d312 1
a312 1
**		The current request are saved in a control file.
d320 1
a320 1
queueup(e, announce)
d323 1
d326 1
a326 1
	register FILE *tfp;
d336 1
d344 1
a344 3

	/* if newid, queuename will create a locked qf file in e->lockfp */
	(void) strlcpy(tf, queuename(e, 't'), sizeof tf);
d347 1
a347 1
		newid = FALSE;
d352 1
a352 3
		int flags;

		flags = O_CREAT|O_WRONLY|O_EXCL;
d359 1
a359 2
#if _FFR_QUEUE_FILE_MODE
				MODE_T oldumask;
a365 3
#else /* _FFR_QUEUE_FILE_MODE */
				tfd = open(tf, flags, FileMode);
#endif /* _FFR_QUEUE_FILE_MODE */
d374 2
a375 1
							  tf, geteuid(), errstring(errno));
d385 1
a385 1
						  tf, errstring(errno));
d401 3
a403 1
		if (tfd < 0 || (tfp = fdopen(tfd, "w")) == NULL)
d407 1
a407 1
			printopenfds(TRUE);
d415 2
a416 2
		dprintf("\n>>>>> queueing %s/qf%s%s >>>>>\n",
			qid_printqueue(e->e_queuedir), e->e_id,
d420 1
a420 1
		dprintf("  e_flags=");
d425 2
a426 2
		dprintf("  sendq=");
		printaddr(e->e_sendqueue, TRUE);
d430 3
a432 3
		dprintf("  tfp=");
		dumpfd(fileno(tfp), TRUE, FALSE);
		dprintf("  lockfp=");
d434 1
a434 1
			dprintf("NULL\n");
d436 2
a437 1
			dumpfd(fileno(e->e_lockfp), TRUE, FALSE);
d444 1
d447 4
a450 1
		if (e->e_dfp != NULL && bfcommit(e->e_dfp) < 0)
d453 19
d476 2
a477 2
		register FILE *dfp = NULL;
		char dfname[MAXPATHLEN];
d480 2
a481 1
		if (e->e_dfp != NULL && bftest(e->e_dfp))
d484 8
a491 16
		(void) strlcpy(dfname, queuename(e, 'd'), sizeof dfname);
#if _FFR_QUEUE_FILE_MODE
		{
			MODE_T oldumask;

			if (bitset(S_IWGRP, QueueFileMode))
				oldumask = umask(002);
			dfd = open(dfname, O_WRONLY|O_CREAT|O_TRUNC,
				   QueueFileMode);
			if (bitset(S_IWGRP, QueueFileMode))
				(void) umask(oldumask);
		}
#else /* _FFR_QUEUE_FILE_MODE */
		dfd = open(dfname, O_WRONLY|O_CREAT|O_TRUNC, FileMode);
#endif /* _FFR_QUEUE_FILE_MODE */
		if (dfd < 0 || (dfp = fdopen(dfd, "w")) == NULL)
d499 1
a499 1
			e->e_dfino = stbuf.st_ino;
d506 20
a525 1
		if (fclose(dfp) < 0)
d538 1
a538 1
	fprintf(tfp, "V%d\n", QF_VERSION);
d541 1
a541 1
	fprintf(tfp, "T%ld\n", (long) e->e_ctime);
d544 4
a547 4
# if _FFR_QUEUEDELAY
	fprintf(tfp, "K%ld\n", (long) e->e_dtime);
	fprintf(tfp, "G%d\n", e->e_queuealg);
	fprintf(tfp, "Y%ld\n", (long) e->e_queuedelay);
d552 3
a554 3
# else /* _FFR_QUEUEDELAY */
	fprintf(tfp, "K%ld\n", (long) e->e_dtime);
# endif /* _FFR_QUEUEDELAY */
d557 1
a557 1
	fprintf(tfp, "N%d\n", e->e_ntries);
d560 12
a571 1
	fprintf(tfp, "P%ld\n", e->e_msgpriority);
d577 4
a580 11
		/*CONSTCOND*/
		if (sizeof e->e_dfino > sizeof(long))
			fprintf(tfp, "I%ld/%ld/%s\n",
				(long) major(e->e_dfdev),
				(long) minor(e->e_dfdev),
				quad_to_string(e->e_dfino));
		else
			fprintf(tfp, "I%ld/%ld/%lu\n",
				(long) major(e->e_dfdev),
				(long) minor(e->e_dfdev),
				(unsigned long) e->e_dfino);
d585 2
a586 6
		fprintf(tfp, "B%s\n", denlstring(e->e_bodytype, TRUE, FALSE));

# if _FFR_SAVE_CHARSET
	if (e->e_charset != NULL)
		fprintf(tfp, "X%s\n", denlstring(e->e_charset, TRUE, FALSE));
# endif /* _FFR_SAVE_CHARSET */
d590 2
a591 1
		fprintf(tfp, "M%s\n", denlstring(e->e_message, TRUE, FALSE));
d607 2
d611 1
a611 1
		fprintf(tfp, "F%s\n", buf);
d614 1
a614 1
	queueup_macros(macid("{persistentMacros}", NULL), tfp, e);
d621 2
a622 1
	fprintf(tfp, "S%s\n", denlstring(p, TRUE, FALSE));
d626 2
a627 1
		fprintf(tfp, "Z%s\n", denlstring(e->e_envid, TRUE, FALSE));
d631 5
a635 2
		fprintf(tfp, "A%s\n", denlstring(e->e_auth_param,
						 TRUE, FALSE));
d644 6
d652 8
a659 4
			fprintf(tfp, "Q%s\n",
				denlstring(q->q_orcpt, TRUE, FALSE));

		(void) putc('R', tfp);
d661 1
a661 1
			(void) putc('P', tfp);
d663 1
a663 1
			(void) putc('N', tfp);
d665 1
a665 1
			(void) putc('S', tfp);
d667 1
a667 1
			(void) putc('F', tfp);
d669 1
a669 1
			(void) putc('D', tfp);
d672 4
a675 3
			(void) putc('A', tfp);
		(void) putc(':', tfp);
		(void) fprintf(tfp, "%s\n", denlstring(q->q_paddr, TRUE, FALSE));
d687 2
a688 2
			dprintf("queueing ");
			printaddr(q, FALSE);
d710 1
a710 1
	define('g', "\201f", e);
d730 1
a730 1
		fprintf(tfp, "H?");
d736 3
a738 2
				fprintf(tfp, "${%s}",
					macname(bitidx(h->h_macro)));
d740 2
a741 1
				fprintf(tfp, "$%c", h->h_macro);
d751 2
a752 1
					(void) putc(j, tfp);
d754 1
a754 1
		(void) putc('?', tfp);
d760 3
a762 3
			fprintf(tfp, "%s: %s\n",
				h->h_field,
				denlstring(buf, FALSE, TRUE));
d768 1
a768 1
			FILE *savetrace = TrafficLogFile;
d773 1
a773 1
				oldstyle = FALSE;
d781 4
a784 3
			fprintf(tfp, "%s: %s\n",
				h->h_field,
				denlstring(h->h_value, FALSE, TRUE));
d795 1
a795 1
	fprintf(tfp, ".\n");
d797 5
a801 3
	if (fflush(tfp) != 0 ||
	    (SuperSafe && fsync(fileno(tfp)) < 0) ||
	    ferror(tfp))
d816 1
d818 3
a820 4
		**  fsync() after renaming to make sure
		**  metadata is written to disk on
		**  filesystems in which renames are
		**  not guaranteed such as softupdates.
d823 10
a832 2
		if (tfd >= 0 && SuperSafe && fsync(tfd) < 0)
			syserr("!queueup: cannot fsync queue temp file %s", tf);
d836 1
a836 1
			(void) fclose(e->e_lockfp);
d849 1
a849 1
		dprintf("<<<<< done queueing %s <<<<<\n\n", e->e_id);
d853 15
d871 1
a871 1
	FILE *tfp;
d884 1
a884 1
			fprintf(tfp, "C\n");
d914 1
a914 1
		fprintf(tfp, "C");
d916 5
a920 3
		fprintf(tfp, "C%s:%ld:%ld",
			denlstring(user, TRUE, FALSE), (long) uid, (long) gid);
	fprintf(tfp, ":%s\n", denlstring(a->q_paddr, TRUE, FALSE));
d922 1
d924 1
a924 1
**  RUNQUEUE -- run the jobs in the queue.
d926 9
a934 2
**	Gets the stuff out of the queue in some presumably logical
**	order and processes them.
d937 1
a937 5
**		forkflag -- TRUE if the queue scanning should be done in
**			a child process.  We double-fork so it is not our
**			child and we don't have to clean up after it.
**			FALSE can be ignored if we have multiple queues.
**		verbose -- if TRUE, print out status information.
d940 1
a940 1
**		TRUE if the queue run successfully began.
d943 6
a948 1
**		runs things in the mail queue.
d951 60
a1010 4
static ENVELOPE	QueueEnvelope;		/* the queue run envelope */
int		NumQueues = 0;		/* number of queues */
static time_t	LastQueueTime = 0;	/* last time a queue ID assigned */
static pid_t	LastQueuePid = -1;	/* last PID which had a queue ID */
d1012 3
a1014 1
struct qpaths_s
d1016 1
a1016 3
	char	*qp_name;	/* name of queue dir */
	short	qp_subdirs;	/* use subdirs? */
};
d1018 37
a1054 1
typedef struct qpaths_s QPATHS;
d1056 7
a1062 5
/* values for qp_supdirs */
#define QP_NOSUB	0x0000	/* No subdirectories */
#define QP_SUBDF	0x0001	/* "df" subdirectory */
#define QP_SUBQF	0x0002	/* "qf" subdirectory */
#define QP_SUBXF	0x0004	/* "xf" subdirectory */
d1064 18
a1081 1
static QPATHS	*QPaths = NULL;		/* list of queue directories */
d1083 2
a1084 4
bool
runqueue(forkflag, verbose)
	bool forkflag;
	bool verbose;
d1087 1
a1087 4
	bool ret = TRUE;
	static int curnum = 0;

	DoQueueRun = FALSE;
d1089 2
d1092 2
a1093 2
	if (!forkflag && NumQueues > 1 && !verbose)
		forkflag = TRUE;
d1095 1
a1095 1
	for (i = 0; i < NumQueues; i++)
d1097 10
a1106 12
		/*
		**  Pick up where we left off, in case we
		**  used up all the children last time
		**  without finishing.
		*/

		ret = run_single_queue(curnum, forkflag, verbose);

		/*
		**  Failure means a message was printed for ETRN
		**  and subsequent queues are likely to fail as well.
		*/
d1108 2
a1109 9
		if (!ret)
			break;

		if (++curnum >= NumQueues)
			curnum = 0;
	}
	if (QueueIntvl != 0)
		(void) setevent(QueueIntvl, runqueueevent, 0);
	return ret;
d1112 1
a1112 1
**  RUN_SINGLE_QUEUE -- run the jobs in a single queue.
d1114 3
a1116 2
**	Gets the stuff out of the queue in some presumably logical
**	order and processes them.
d1119 1
a1119 5
**		queuedir -- queue to process
**		forkflag -- TRUE if the queue scanning should be done in
**			a child process.  We double-fork so it is not our
**			child and we don't have to clean up after it.
**		verbose -- if TRUE, print out status information.
d1122 1
a1122 1
**		TRUE if the queue run successfully began.
d1125 1
a1125 1
**		runs things in the mail queue.
d1128 5
a1132 5
static bool
run_single_queue(queuedir, forkflag, verbose)
	int queuedir;
	bool forkflag;
	bool verbose;
d1134 3
a1136 5
	register ENVELOPE *e;
	int njobs;
	int sequenceno = 0;
	time_t current_la_time, now;
	extern ENVELOPE BlankEnvelope;
d1138 24
a1161 4
	/*
	**  If no work will ever be selected, don't even bother reading
	**  the queue.
	*/
d1163 3
a1165 2
	CurrentLA = sm_getla(NULL);	/* get load average */
	current_la_time = curtime();
d1167 6
a1172 12
	if (shouldqueue(WkRecipFact, current_la_time))
	{
		char *msg = "Skipping queue run -- load average too high";

		if (verbose)
			message("458 %s\n", msg);
		if (LogLevel > 8)
			sm_syslog(LOG_INFO, NOQID,
				  "runqueue: %s",
				  msg);
		return FALSE;
	}
d1175 2
a1176 1
	**  See if we already have too many children.
d1179 2
a1180 2
	if (forkflag && QueueIntvl != 0 &&
	    MaxChildren > 0 && CurChildren >= MaxChildren)
d1182 1
a1182 1
		char *msg = "Skipping queue run -- too many children";
d1184 11
a1194 3
		if (verbose)
			message("458 %s (%d)\n", msg, CurChildren);
		if (LogLevel > 8)
d1196 74
a1269 4
				  "runqueue: %s (%d)",
				  msg, CurChildren);
		return FALSE;
	}
d1272 9
a1280 1
	**  See if we want to go off and do other useful work.
d1283 8
a1290 1
	if (forkflag)
d1292 9
a1300 1
		pid_t pid;
d1302 10
a1311 2
		(void) blocksignal(SIGCHLD);
		(void) setsignal(SIGCHLD, reapchild);
d1313 5
a1317 5
		pid = dofork();
		if (pid == -1)
		{
			const char *msg = "Skipping queue run -- fork() failed";
			const char *err = errstring(errno);
d1319 2
a1320 19
			if (verbose)
				message("458 %s: %s\n", msg, err);
			if (LogLevel > 8)
				sm_syslog(LOG_INFO, NOQID,
					  "runqueue: %s: %s",
					  msg, err);
			(void) releasesignal(SIGCHLD);
			return FALSE;
		}
		if (pid != 0)
		{
			/* parent -- pick up intermediate zombie */
			(void) blocksignal(SIGALRM);
			proc_list_add(pid, "Queue runner", PROC_QUEUE);
			(void) releasesignal(SIGALRM);
			(void) releasesignal(SIGCHLD);
			return TRUE;
		}
		/* child -- clean up signals */
d1322 4
a1325 4
		/* Reset global flags */
		RestartRequest = NULL;
		ShutdownRequest = NULL;
		PendingSignal = 0;
d1327 2
a1328 2
		clrcontrol();
		proc_list_clear();
d1330 5
a1334 7
		/* Add parent process as first child item */
		proc_list_add(getpid(), "Queue runner child process",
			      PROC_QUEUE_CHILD);
		(void) releasesignal(SIGCHLD);
		(void) setsignal(SIGCHLD, SIG_DFL);
		(void) setsignal(SIGHUP, SIG_DFL);
		(void) setsignal(SIGTERM, intsig);
d1337 11
a1347 2
	sm_setproctitle(TRUE, CurEnv, "running queue: %s",
			qid_printqueue(queuedir));
a1348 4
	if (LogLevel > 69 || tTd(63, 99))
		sm_syslog(LOG_DEBUG, NOQID,
			  "runqueue %s, pid=%d, forkflag=%d",
			  qid_printqueue(queuedir), (int) getpid(), forkflag);
d1350 29
a1378 3
	/*
	**  Release any resources used by the daemon code.
	*/
d1380 2
a1381 3
# if DAEMON
	clrdaemon();
# endif /* DAEMON */
d1383 11
a1393 2
	/* force it to run expensive jobs */
	NoConnect = FALSE;
d1395 1
a1395 3
	/* drop privileges */
	if (geteuid() == (uid_t) 0)
		(void) drop_privileges(FALSE);
d1398 4
a1401 1
	**  Create ourselves an envelope
d1404 1
a1404 4
	CurEnv = &QueueEnvelope;
	e = newenvelope(&QueueEnvelope, CurEnv);
	e->e_flags = BlankEnvelope.e_flags;
	e->e_parent = NULL;
d1406 2
a1407 2
	/* make sure we have disconnected from parent */
	if (forkflag)
d1409 2
a1410 3
		disconnect(1, e);
		QuickAbort = FALSE;
	}
d1412 19
a1430 4
	/*
	**  If we are running part of the queue, always ignore stored
	**  host status.
	*/
d1432 1
a1432 6
	if (QueueLimitId != NULL || QueueLimitSender != NULL ||
	    QueueLimitRecipient != NULL)
	{
		IgnoreHostStatus = TRUE;
		MinQueueAge = 0;
	}
d1434 6
a1439 9
	/*
	**  Start making passes through the queue.
	**	First, read and sort the entire queue.
	**	Then, process the work in that order.
	**		But if you take too long, start over.
	*/

	/* order the existing work requests */
	njobs = orderq(queuedir, FALSE);
d1441 2
a1442 7

	/* process them once at a time */
	while (WorkQ != NULL)
	{
		WORK *w = WorkQ;

		WorkQ = WorkQ->w_next;
d1448 1
a1448 1
		**	Get new load average every 30 seconds.
d1452 1
a1452 1
		if (current_la_time < now - 30)
d1454 1
a1454 1
			CurrentLA = sm_getla(e);
d1464 1
a1464 3
				sm_syslog(LOG_INFO, NOQID,
					  "runqueue: %s",
					  msg);
a1466 1
		sequenceno++;
d1470 1
a1470 1
				message("");
d1475 3
a1477 3
						qid_printqueue(queuedir),
						w->w_name + 2,
						sequenceno,
d1482 4
a1485 5
						  qid_printqueue(queuedir),
						  w->w_name + 2,
						  w->w_pri,
						  CurrentLA,
						  sequenceno,
d1491 2
a1492 3
					qid_printqueue(queuedir),
					w->w_name + 2,
					sequenceno, njobs);
a1495 2
			pid_t pid;

d1498 1
a1498 1
				message("");
d1500 7
a1506 3
					qid_printqueue(queuedir),
					w->w_name + 2,
					sequenceno, njobs);
d1511 1
a1511 1
					  qid_printqueue(queuedir),
d1514 2
a1515 2
			pid = dowork(queuedir, w->w_name + 2,
				     ForkQueueRuns, FALSE, e);
a1516 2
			if (pid != 0)
				(void) waitfor(pid);
d1518 9
a1526 4
		sm_free(w->w_name);
		if (w->w_host)
			sm_free(w->w_host);
		sm_free((char *) w);
d1529 1
a1529 7
	/* exit without the usual cleanup */
	e->e_id = NULL;
	if (forkflag)
		finis(TRUE, ExitStat);
	/* NOTREACHED */
	return TRUE;
}
d1531 8
a1538 13
/*
**  RUNQUEUEEVENT -- stub for use in setevent
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/
d1540 1
a1540 4
static void
runqueueevent()
{
	DoQueueRun = TRUE;
d1543 4
a1546 1
**  ORDERQ -- order the work queue.
d1549 7
a1555 5
**		queuedir -- the index of the queue directory.
**		doall -- if set, include everything in the queue (even
**			the jobs that cannot be run because the load
**			average is too high).  Otherwise, exclude those
**			jobs.
d1558 1
a1558 2
**		The number of request in the queue (not necessarily
**		the number of requests in WorkQ however).
d1561 1
a1561 1
**		Sets WorkQ to the queue of available work, in order.
d1564 2
a1565 5
# define NEED_P		001
# define NEED_T		002
# define NEED_R		004
# define NEED_S		010
# define NEED_H		020
d1567 7
a1573 7
static WORK	*WorkList = NULL;
static int	WorkListSize = 0;

static int
orderq(queuedir, doall)
	int queuedir;
	bool doall;
d1575 10
a1584 10
	register struct dirent *d;
	register WORK *w;
	register char *p;
	DIR *f;
	register int i;
	int wn = -1;
	int wc;
	QUEUE_CHAR *check;
	char qd[MAXPATHLEN];
	char qf[MAXPATHLEN];
d1586 2
a1587 6
	if (queuedir == NOQDIR)
		(void) strlcpy(qd, ".", sizeof qd);
	else
		(void) snprintf(qd, sizeof qd, "%s%s",
				QPaths[queuedir].qp_name,
				(bitset(QP_SUBQF, QPaths[queuedir].qp_subdirs) ? "/qf" : ""));
d1589 4
a1592 3
	if (tTd(41, 1))
	{
		dprintf("orderq:\n");
d1594 2
a1595 7
		check = QueueLimitId;
		while (check != NULL)
		{
			dprintf("\tQueueLimitId = %s\n",
				check->queue_match);
			check = check->queue_next;
		}
d1597 3
a1599 7
		check = QueueLimitSender;
		while (check != NULL)
		{
			dprintf("\tQueueLimitSender = %s\n",
				check->queue_match);
			check = check->queue_next;
		}
d1601 5
a1605 7
		check = QueueLimitRecipient;
		while (check != NULL)
		{
			dprintf("\tQueueLimitRecipient = %s\n",
				check->queue_match);
			check = check->queue_next;
		}
d1608 6
a1613 2
	/* clear out old WorkQ */
	for (w = WorkQ; w != NULL; )
d1615 1
a1615 1
		register WORK *nw = w->w_next;
d1617 6
a1622 14
		WorkQ = nw;
		sm_free(w->w_name);
		if (w->w_host != NULL)
			sm_free(w->w_host);
		sm_free((char *) w);
		w = nw;
	}

	/* open the queue directory */
	f = opendir(qd);
	if (f == NULL)
	{
		syserr("orderq: cannot open \"%s\"", qid_printqueue(queuedir));
		return 0;
d1626 1
a1626 1
	**  Read the work directory.
d1629 1
a1629 1
	while ((d = readdir(f)) != NULL)
d1631 1
a1631 4
		FILE *cf;
		int qfver = 0;
		char lbuf[MAXNAME + 1];
		struct stat sbuf;
d1633 2426
a4058 2
		if (tTd(41, 50))
			dprintf("orderq: checking %s\n", d->d_name);
d4060 3
a4062 3
		/* is this an interesting entry? */
		if (d->d_name[0] != 'q' || d->d_name[1] != 'f')
			continue;
d4064 12
a4075 1
		if (strlen(d->d_name) >= MAXQFNAME)
d4077 3
a4079 8
			if (Verbose)
				printf("orderq: %s too long, %d max characters\n",
					d->d_name, MAXQFNAME);
			if (LogLevel > 0)
				sm_syslog(LOG_ALERT, NOQID,
					  "orderq: %s too long, %d max characters",
					  d->d_name, MAXQFNAME);
			continue;
d4081 25
d4107 15
a4121 2
		check = QueueLimitId;
		while (check != NULL)
d4123 3
a4125 4
			if (strcontainedin(check->queue_match, d->d_name))
				break;
			else
				check = check->queue_next;
d4127 35
a4161 2
		if (QueueLimitId != NULL && check == NULL)
			continue;
d4163 2
a4164 2
		/* grow work list if necessary */
		if (++wn >= MaxQueueRun && MaxQueueRun > 0)
d4166 31
a4196 6
			if (wn == MaxQueueRun && LogLevel > 0)
				sm_syslog(LOG_WARNING, NOQID,
					  "WorkList for %s maxed out at %d",
					  qid_printqueue(queuedir),
					  MaxQueueRun);
			continue;
d4198 38
a4235 1
		if (wn >= WorkListSize)
d4237 4
a4240 3
			grow_wlist(queuedir);
			if (wn >= WorkListSize)
				continue;
d4242 62
a4303 1
		w = &WorkList[wn];
d4305 9
a4313 2
		(void) snprintf(qf, sizeof qf, "%s/%s", qd, d->d_name);
		if (stat(qf, &sbuf) < 0)
d4315 2
a4316 6
			if (errno != ENOENT)
				sm_syslog(LOG_INFO, NOQID,
					  "orderq: can't stat %s/%s",
					  qid_printqueue(queuedir), d->d_name);
			wn--;
			continue;
d4318 4
a4321 1
		if (!bitset(S_IFREG, sbuf.st_mode))
d4323 52
a4374 6
			/* Yikes!  Skip it or we will hang on open! */
			syserr("orderq: %s/%s is not a regular file",
			       qid_printqueue(queuedir), d->d_name);
			wn--;
			continue;
		}
d4376 6
a4381 4
		/* avoid work if possible */
		if (QueueSortOrder == QSO_BYFILENAME &&
		    QueueLimitSender == NULL &&
		    QueueLimitRecipient == NULL)
d4383 11
a4393 5
			w->w_name = newstr(d->d_name);
			w->w_host = NULL;
			w->w_lock = w->w_tooyoung = FALSE;
			w->w_pri = 0;
			w->w_ctime = 0;
d4396 7
d4404 5
a4408 2
		/* open control file */
		cf = fopen(qf, "r");
d4410 18
a4427 10
		if (cf == NULL)
		{
			/* this may be some random person sending hir msgs */
			/* syserr("orderq: cannot open %s", cbuf); */
			if (tTd(41, 2))
				dprintf("orderq: cannot open %s: %s\n",
					d->d_name, errstring(errno));
			errno = 0;
			wn--;
			continue;
d4429 8
a4436 4
		w->w_name = newstr(d->d_name);
		w->w_host = NULL;
		w->w_lock = !lockfile(fileno(cf), w->w_name, NULL, LOCK_SH|LOCK_NB);
		w->w_tooyoung = FALSE;
d4438 1
a4438 3
		/* make sure jobs in creation don't clog queue */
		w->w_pri = 0x7fffffff;
		w->w_ctime = 0;
d4440 3
a4442 3
		/* extract useful information */
		i = NEED_P | NEED_T;
		if (QueueSortOrder == QSO_BYHOST)
d4444 2
a4445 11
			/* need w_host set for host sort order */
			i |= NEED_H;
		}
		if (QueueLimitSender != NULL)
			i |= NEED_S;
		if (QueueLimitRecipient != NULL)
			i |= NEED_R;
		while (i != 0 && fgets(lbuf, sizeof lbuf, cf) != NULL)
		{
			int c;
			time_t age;
d4447 2
a4448 9
			p = strchr(lbuf, '\n');
			if (p != NULL)
				*p = '\0';
			else
			{
				/* flush rest of overly long line */
				while ((c = getc(cf)) != EOF && c != '\n')
					continue;
			}
d4450 2
a4451 1
			switch (lbuf[0])
d4453 2
a4454 2
			  case 'V':
				qfver = atoi(&lbuf[1]);
d4457 5
a4461 3
			  case 'P':
				w->w_pri = atol(&lbuf[1]);
				i &= ~NEED_P;
d4464 5
a4468 3
			  case 'T':
				w->w_ctime = atol(&lbuf[1]);
				i &= ~NEED_T;
d4471 14
a4484 3
			  case 'R':
				if (w->w_host == NULL &&
				    (p = strrchr(&lbuf[1], '@@')) != NULL)
d4486 6
a4491 3
					w->w_host = strrev(&p[1]);
					makelower(w->w_host);
					i &= ~NEED_H;
d4493 1
a4493 1
				if (QueueLimitRecipient == NULL)
d4495 11
a4505 2
					i &= ~NEED_R;
					break;
d4507 13
a4519 1
				if (qfver > 0)
d4521 1
a4521 1
					p = strchr(&lbuf[1], ':');
d4523 9
a4531 1
						p = &lbuf[1];
a4533 3
					p = &lbuf[1];
				check = QueueLimitRecipient;
				while (check != NULL)
d4535 4
a4538 5
					if (strcontainedin(check->queue_match,
							   p))
						break;
					else
						check = check->queue_next;
d4540 1
a4540 7
				if (check != NULL)
					i &= ~NEED_R;
				break;

			  case 'S':
				check = QueueLimitSender;
				while (check != NULL)
d4542 5
a4546 5
					if (strcontainedin(check->queue_match,
							   &lbuf[1]))
						break;
					else
						check = check->queue_next;
a4547 2
				if (check != NULL)
					i &= ~NEED_S;
d4550 2
a4551 5
			  case 'K':
				age = curtime() - (time_t) atol(&lbuf[1]);
				if (age >= 0 && MinQueueAge > 0 &&
				    age < MinQueueAge)
					w->w_tooyoung = TRUE;
d4554 10
a4563 15
			  case 'N':
				if (atol(&lbuf[1]) == 0)
					w->w_tooyoung = FALSE;
				break;

# if _FFR_QUEUEDELAY
/*
			  case 'G':
				queuealg = atoi(lbuf[1]);
				break;
			  case 'Y':
				queuedelay = (time_t) atol(&lbuf[1]);
				break;
*/
# endif /* _FFR_QUEUEDELAY */
d4566 5
a4570 13
		(void) fclose(cf);

		if ((!doall && shouldqueue(w->w_pri, w->w_ctime)) ||
		    bitset(NEED_R|NEED_S, i))
		{
			/* don't even bother sorting this job in */
			if (tTd(41, 49))
				dprintf("skipping %s (%x)\n", w->w_name, i);
			sm_free(w->w_name);
			if (w->w_host)
				sm_free(w->w_host);
			wn--;
		}
d4572 18
a4589 2
	(void) closedir(f);
	wn++;
d4591 9
a4599 6
	WorkQ = NULL;
	if (WorkList == NULL)
		return 0;
	wc = min(wn, WorkListSize);
	if (wc > MaxQueueRun && MaxQueueRun > 0)
		wc = MaxQueueRun;
d4601 3
a4603 6
	if (QueueSortOrder == QSO_BYHOST)
	{
		/*
		**  Sort the work directory for the first time,
		**  based on host name, lock status, and priority.
		*/
d4605 4
a4608 1
		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf1);
d4610 3
d4614 5
a4618 2
		**  If one message to host is locked, "lock" all messages
		**  to that host.
d4621 1
a4621 2
		i = 0;
		while (i < wc)
d4623 1
a4623 1
			if (!WorkList[i].w_lock)
d4625 2
a4626 2
				i++;
				continue;
d4628 1
a4628 2
			w = &WorkList[i];
			while (++i < wc)
d4630 3
a4632 7
				if (WorkList[i].w_host == NULL &&
				    w->w_host == NULL)
					WorkList[i].w_lock = TRUE;
				else if (WorkList[i].w_host != NULL &&
					 w->w_host != NULL &&
					 sm_strcasecmp(WorkList[i].w_host, w->w_host) == 0)
					WorkList[i].w_lock = TRUE;
d4634 4
a4637 1
					break;
d4640 2
a4641 7

		/*
		**  Sort the work directory for the second time,
		**  based on lock status, host name, and priority.
		*/

		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf2);
d4643 1
a4643 1
	else if (QueueSortOrder == QSO_BYTIME)
d4645 12
a4656 5
		/*
		**  Simple sort based on submission time only.
		*/

		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf3);
a4657 5
	else if (QueueSortOrder == QSO_BYFILENAME)
	{
		/*
		**  Sort based on qf filename.
		*/
d4659 2
a4660 2
		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf4);
	}
d4663 6
a4668 3
		/*
		**  Simple sort based on queue priority only.
		*/
d4670 7
a4676 2
		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf0);
	}
d4678 4
a4681 4
	/*
	**  Convert the work list into canonical form.
	**	Should be turning it into a list of envelopes here perhaps.
	*/
d4683 3
a4685 16
	for (i = wc; --i >= 0; )
	{
		w = (WORK *) xalloc(sizeof *w);
		w->w_name = WorkList[i].w_name;
		w->w_host = WorkList[i].w_host;
		w->w_lock = WorkList[i].w_lock;
		w->w_tooyoung = WorkList[i].w_tooyoung;
		w->w_pri = WorkList[i].w_pri;
		w->w_ctime = WorkList[i].w_ctime;
		w->w_next = WorkQ;
		WorkQ = w;
	}
	if (WorkList != NULL)
		sm_free(WorkList);
	WorkList = NULL;
	WorkListSize = 0;
d4687 3
a4689 11
	if (tTd(40, 1))
	{
		for (w = WorkQ; w != NULL; w = w->w_next)
		{
			if (w->w_host != NULL)
				dprintf("%22s: pri=%ld %s\n",
					w->w_name, w->w_pri, w->w_host);
			else
				dprintf("%32s: pri=%ld\n",
					w->w_name, w->w_pri);
		}
d4692 3
a4694 1
	return wn;
d4697 7
a4703 1
**  GROW_WLIST -- make the work list larger
d4706 1
a4706 1
**		queuedir -- the index for the queue directory.
a4709 5
**
**	Side Effects:
**		Adds another QUEUESEGSIZE entries to WorkList if possible.
**		It can fail if there isn't enough memory, so WorkListSize
**		should be checked again upon return.
d4712 8
a4719 3
static void
grow_wlist(queuedir)
	int queuedir;
d4721 13
a4733 3
	if (tTd(41, 1))
		dprintf("grow_wlist: WorkListSize=%d\n", WorkListSize);
	if (WorkList == NULL)
d4735 5
a4739 9
		WorkList = (WORK *) xalloc((sizeof *WorkList) *
					   (QUEUESEGSIZE + 1));
		WorkListSize = QUEUESEGSIZE;
	}
	else
	{
		int newsize = WorkListSize + QUEUESEGSIZE;
		WORK *newlist = (WORK *) xrealloc((char *)WorkList,
						  (unsigned)sizeof(WORK) * (newsize + 1));
d4741 2
a4742 1
		if (newlist != NULL)
d4744 1
a4744 15
			WorkListSize = newsize;
			WorkList = newlist;
			if (LogLevel > 1)
			{
				sm_syslog(LOG_INFO, NOQID,
					  "grew WorkList for %s to %d",
					  qid_printqueue(queuedir),
					  WorkListSize);
			}
		}
		else if (LogLevel > 0)
		{
			sm_syslog(LOG_ALERT, NOQID,
				  "FAILED to grow WorkList for %s to %d",
				  qid_printqueue(queuedir), newsize);
d4746 2
d4749 66
a4814 2
	if (tTd(41, 1))
		dprintf("grow_wlist: WorkListSize now %d\n", WorkListSize);
d4817 1
a4817 1
**  WORKCMPF0 -- simple priority-only compare function.
d4820 1
a4820 2
**		a -- the first argument.
**		b -- the second argument.
d4823 1
a4823 3
**		-1 if a < b
**		 0 if a == b
**		+1 if a > b
d4826 1
a4826 1
**		none.
d4829 3
a4831 4
static int
workcmpf0(a, b)
	register WORK *a;
	register WORK *b;
d4833 13
a4845 2
	long pa = a->w_pri;
	long pb = b->w_pri;
d4847 5
a4851 6
	if (pa == pb)
		return 0;
	else if (pa > pb)
		return 1;
	else
		return -1;
d4854 1
a4854 1
**  WORKCMPF1 -- first compare function for ordering work based on host name.
d4856 2
a4857 1
**	Sorts on host name, lock status, and priority in that order.
d4860 3
a4862 2
**		a -- the first argument.
**		b -- the second argument.
d4865 2
a4866 3
**		<0 if a < b
**		 0 if a == b
**		>0 if a > b
a4867 2
**	Side Effects:
**		none.
d4870 5
a4874 4
static int
workcmpf1(a, b)
	register WORK *a;
	register WORK *b;
d4876 36
a4911 1
	int i;
d4913 1
a4913 8
	/* host name */
	if (a->w_host != NULL && b->w_host == NULL)
		return 1;
	else if (a->w_host == NULL && b->w_host != NULL)
		return -1;
	if (a->w_host != NULL && b->w_host != NULL &&
	    (i = sm_strcasecmp(a->w_host, b->w_host)) != 0)
		return i;
d4915 18
a4932 3
	/* lock status */
	if (a->w_lock != b->w_lock)
		return b->w_lock - a->w_lock;
d4934 7
a4940 2
	/* job priority */
	return workcmpf0(a, b);
d4943 1
a4943 3
**  WORKCMPF2 -- second compare function for ordering work based on host name.
**
**	Sorts on lock status, host name, and priority in that order.
d4946 2
a4947 2
**		a -- the first argument.
**		b -- the second argument.
a4949 5
**		<0 if a < b
**		 0 if a == b
**		>0 if a > b
**
**	Side Effects:
d4953 4
a4956 4
static int
workcmpf2(a, b)
	register WORK *a;
	register WORK *b;
d4958 2
a4959 1
	int i;
d4961 19
a4979 15
	/* lock status */
	if (a->w_lock != b->w_lock)
		return a->w_lock - b->w_lock;

	/* host name */
	if (a->w_host != NULL && b->w_host == NULL)
		return 1;
	else if (a->w_host == NULL && b->w_host != NULL)
		return -1;
	if (a->w_host != NULL && b->w_host != NULL &&
	    (i = sm_strcasecmp(a->w_host, b->w_host)) != 0)
		return i;

	/* job priority */
	return workcmpf0(a, b);
d4982 1
a4982 1
**  WORKCMPF3 -- simple submission-time-only compare function.
d4985 1
a4985 2
**		a -- the first argument.
**		b -- the second argument.
d4988 2
a4989 6
**		-1 if a < b
**		 0 if a == b
**		+1 if a > b
**
**	Side Effects:
**		none.
d4992 3
a4994 4
static int
workcmpf3(a, b)
	register WORK *a;
	register WORK *b;
d4996 6
a5001 6
	if (a->w_ctime > b->w_ctime)
		return 1;
	else if (a->w_ctime < b->w_ctime)
		return -1;
	else
		return 0;
d5004 1
a5004 1
**  WORKCMPF4 -- compare based on file name
d5007 1
a5007 2
**		a -- the first argument.
**		b -- the second argument.
d5010 1
a5010 6
**		-1 if a < b
**		 0 if a == b
**		+1 if a > b
**
**	Side Effects:
**		none.
d5013 3
a5015 4
static int
workcmpf4(a, b)
	register WORK *a;
	register WORK *b;
d5017 18
a5034 1
	return strcmp(a->w_name, b->w_name);
d5037 1
a5037 5
**  STRREV -- reverse string
**
**	Returns a pointer to a new string that is the reverse of
**	the string pointed to by fwd.  The space for the new
**	string is obtained using xalloc().
d5040 2
a5041 1
**		fwd -- the string to reverse.
d5044 1
a5044 1
**		the reversed string.
d5047 4
a5050 3
static char *
strrev(fwd)
	char *fwd;
d5052 10
a5061 2
	char *rev = NULL;
	int len, cnt;
d5063 8
a5070 6
	len = strlen(fwd);
	rev = xalloc(len + 1);
	for (cnt = 0; cnt < len; ++cnt)
		rev[cnt] = fwd[len - cnt - 1];
	rev[len] = '\0';
	return rev;
d5072 3
a5074 2
/*
**  DOWORK -- do a work request.
d5077 12
a5088 11
**		queuedir -- the index of the queue directory for the job.
**		id -- the ID of the job to run.
**		forkflag -- if set, run this in background.
**		requeueflag -- if set, reinstantiate the queue quickly.
**			This is used when expanding aliases in the queue.
**			If forkflag is also set, it doesn't wait for the
**			child.
**		e - the envelope in which to run it.
**
**	Returns:
**		process id of process that is running the queue job.
d5091 1
a5091 1
**		The work request is satisfied if possible.
d5094 5
a5098 7
pid_t
dowork(queuedir, id, forkflag, requeueflag, e)
	int queuedir;
	char *id;
	bool forkflag;
	bool requeueflag;
	register ENVELOPE *e;
d5100 9
a5108 1
	register pid_t pid;
d5110 2
a5111 2
	if (tTd(40, 1))
		dprintf("dowork(%s/%s)\n", qid_printqueue(queuedir), id);
d5114 2
a5115 1
	**  Fork for work.
d5118 16
a5133 76
	if (forkflag)
	{
		/*
		**  Since the delivery may happen in a child and the
		**  parent does not wait, the parent may close the
		**  maps thereby removing any shared memory used by
		**  the map.  Therefore, close the maps now so the
		**  child will dynamically open them if necessary.
		*/

		closemaps();

		pid = fork();
		if (pid < 0)
		{
			syserr("dowork: cannot fork");
			return 0;
		}
		else if (pid > 0)
		{
			/* parent -- clean out connection cache */
			mci_flush(FALSE, NULL);
		}
		else
		{
			/* child -- error messages to the transcript */
			QuickAbort = OnlyOneError = FALSE;
		}
	}
	else
	{
		pid = 0;
	}

	if (pid == 0)
	{
		/*
		**  CHILD
		**	Lock the control file to avoid duplicate deliveries.
		**		Then run the file as though we had just read it.
		**	We save an idea of the temporary name so we
		**		can recover on interrupt.
		*/

		/* Reset global flags */
		RestartRequest = NULL;
		ShutdownRequest = NULL;
		PendingSignal = 0;

		/* set basic modes, etc. */
		(void) alarm(0);
		clearstats();
		clearenvelope(e, FALSE);
		e->e_flags |= EF_QUEUERUN|EF_GLOBALERRS;
		set_delivery_mode(SM_DELIVER, e);
		e->e_errormode = EM_MAIL;
		e->e_id = id;
		e->e_queuedir = queuedir;
		GrabTo = UseErrorsTo = FALSE;
		ExitStat = EX_OK;
		if (forkflag)
		{
			disconnect(1, e);
			OpMode = MD_QUEUERUN;
		}
		sm_setproctitle(TRUE, e, "%s: from queue", qid_printname(e));
		if (LogLevel > 76)
			sm_syslog(LOG_DEBUG, e->e_id,
				  "dowork, pid=%d",
				  (int) getpid());

		/* don't use the headers from sendmail.cf... */
		e->e_header = NULL;

		/* read the queue control file -- return if locked */
		if (!readqf(e))
d5135 1
a5135 9
			if (tTd(40, 4) && e->e_id != NULL)
				dprintf("readqf(%s) failed\n",
					qid_printname(e));
			e->e_id = NULL;
			if (forkflag)
				finis(FALSE, EX_OK);
			else
				return 0;
		}
d5137 4
a5140 2
		e->e_flags |= EF_INQUEUE;
		eatheader(e, requeueflag);
d5142 14
a5155 2
		if (requeueflag)
			queueup(e, FALSE);
d5157 7
a5163 11
		/* do the delivery */
		sendall(e, SM_DELIVER);

		/* finish up and exit */
		if (forkflag)
			finis(TRUE, ExitStat);
		else
			dropenvelope(e, TRUE);
	}
	e->e_id = NULL;
	return pid;
d5166 4
a5169 1
**  READQF -- read queue file and set up environment.
d5172 1
a5172 1
**		e -- the envelope of the job to run.
d5175 2
a5176 2
**		TRUE if it successfully read the queue file.
**		FALSE otherwise.
d5179 4
a5182 1
**		The queue file is returned locked.
d5185 3
a5187 3
static bool
readqf(e)
	register ENVELOPE *e;
d5189 2
a5190 16
	register FILE *qfp;
	ADDRESS *ctladdr;
	struct stat st, stf;
	char *bp;
	int qfver = 0;
	long hdrsize = 0;
	register char *p;
	char *orcpt = NULL;
	bool nomore = FALSE;
	MODE_T qsafe;
	char qf[MAXPATHLEN];
	char buf[MAXLINE];

	/*
	**  Read and process the file.
	*/
d5192 2
a5193 3
	(void) strlcpy(qf, queuename(e, 'q'), sizeof qf);
	qfp = fopen(qf, "r+");
	if (qfp == NULL)
d5195 7
a5201 1
		int save_errno = errno;
d5203 10
a5212 8
		if (tTd(40, 8))
			dprintf("readqf(%s): fopen failure (%s)\n",
				qf, errstring(errno));
		errno = save_errno;
		if (errno != ENOENT
		    )
			syserr("readqf: no control file %s", qf);
		return FALSE;
d5215 1
a5215 1
	if (!lockfile(fileno(qfp), qf, NULL, LOCK_EX|LOCK_NB))
d5217 15
a5231 9
		/* being processed by another queuer */
		if (Verbose)
			printf("%s: locked\n", e->e_id);
		if (tTd(40, 8))
			dprintf("%s: locked\n", e->e_id);
		if (LogLevel > 19)
			sm_syslog(LOG_DEBUG, e->e_id, "locked");
		(void) fclose(qfp);
		return FALSE;
d5234 3
a5236 17
	/*
	**  Prevent locking race condition.
	**
	**  Process A: readqf(): qfp = fopen(qffile)
	**  Process B: queueup(): rename(tf, qf)
	**  Process B: unlocks(tf)
	**  Process A: lockfile(qf);
	**
	**  Process A (us) has the old qf file (before the rename deleted
	**  the directory entry) and will be delivering based on old data.
	**  This can lead to multiple deliveries of the same recipients.
	**
	**  Catch this by checking if the underlying qf file has changed
	**  *after* acquiring our lock and if so, act as though the file
	**  was still locked (i.e., just return like the lockfile() case
	**  above.
	*/
d5238 1
a5238 2
	if (stat(qf, &stf) < 0 ||
	    fstat(fileno(qfp), &st) < 0)
d5240 2
a5241 6
		/* must have been being processed by someone else */
		if (tTd(40, 8))
			dprintf("readqf(%s): [f]stat failure (%s)\n",
				qf, errstring(errno));
		(void) fclose(qfp);
		return FALSE;
d5243 21
d5265 9
a5273 9
	if (st.st_nlink != stf.st_nlink ||
	    st.st_dev != stf.st_dev ||
	    st.st_ino != stf.st_ino ||
# if HAS_ST_GEN && 0		/* AFS returns garbage in st_gen */
	    st.st_gen != stf.st_gen ||
# endif /* HAS_ST_GEN && 0 */
	    st.st_uid != stf.st_uid ||
	    st.st_gid != stf.st_gid ||
	    st.st_size != stf.st_size)
d5275 4
a5278 9
		/* changed after opened */
		if (Verbose)
			printf("%s: changed\n", e->e_id);
		if (tTd(40, 8))
			dprintf("%s: changed\n", e->e_id);
		if (LogLevel > 19)
			sm_syslog(LOG_DEBUG, e->e_id, "changed");
		(void) fclose(qfp);
		return FALSE;
d5280 7
d5288 1
a5288 16
	/*
	**  Check the queue file for plausibility to avoid attacks.
	*/

	qsafe = S_IWOTH|S_IWGRP;
#if _FFR_QUEUE_FILE_MODE
	if (bitset(S_IWGRP, QueueFileMode))
		qsafe &= ~S_IWGRP;
#endif /* _FFR_QUEUE_FILE_MODE */

	if ((st.st_uid != geteuid() &&
	     st.st_uid != TrustedUid &&
	     geteuid() != RealUid) ||
	    bitset(qsafe, st.st_mode))
	{
		if (LogLevel > 0)
d5290 4
a5293 3
			sm_syslog(LOG_ALERT, e->e_id,
				  "bogus queue file, uid=%d, mode=%o",
				  st.st_uid, st.st_mode);
a5294 5
		if (tTd(40, 8))
			dprintf("readqf(%s): bogus file\n", qf);
		loseqfile(e, "bogus file uid in mqueue");
		(void) fclose(qfp);
		return FALSE;
d5296 1
d5298 1
a5298 1
	if (st.st_size == 0)
d5300 4
a5303 8
		/* must be a bogus file -- if also old, just remove it */
		if (st.st_ctime + 10 * 60 < curtime())
		{
			(void) xunlink(queuename(e, 'd'));
			(void) xunlink(queuename(e, 'q'));
		}
		(void) fclose(qfp);
		return FALSE;
d5306 29
a5334 6
	if (st.st_nlink == 0)
	{
		/*
		**  Race condition -- we got a file just as it was being
		**  unlinked.  Just assume it is zero length.
		*/
d5336 2
a5337 3
		(void) fclose(qfp);
		return FALSE;
	}
d5339 15
a5353 2
	/* good file -- save this lock */
	e->e_lockfp = qfp;
d5355 2
a5356 3
	/* do basic system initialization */
	initsys(e);
	define('i', e->e_id, e);
d5358 4
a5361 11
	LineNumber = 0;
	e->e_flags |= EF_GLOBALERRS;
	OpMode = MD_QUEUERUN;
	ctladdr = NULL;
	e->e_dfino = -1;
	e->e_msgsize = -1;
# if _FFR_QUEUEDELAY
	e->e_queuealg = QD_LINEAR;
	e->e_queuedelay = (time_t) 0;
# endif /* _FFR_QUEUEDELAY */
	while ((bp = fgetfolded(buf, sizeof buf, qfp)) != NULL)
d5363 1
a5363 9
		u_long qflags;
		ADDRESS *q;
		int mid;
		time_t now;
		auto char *ep;

		if (tTd(40, 4))
			dprintf("+++++ %s\n", bp);
		if (nomore)
d5365 2
a5366 5
			/* hack attack */
			syserr("SECURITY ALERT: extra data in qf: %s", bp);
			(void) fclose(qfp);
			loseqfile(e, "bogus queue line");
			return FALSE;
d5368 4
a5371 11
		switch (bp[0])
		{
		  case 'V':		/* queue file version number */
			qfver = atoi(&bp[1]);
			if (qfver <= QF_VERSION)
				break;
			syserr("Version number in qf (%d) greater than max (%d)",
				qfver, QF_VERSION);
			(void) fclose(qfp);
			loseqfile(e, "unsupported qf file version");
			return FALSE;
d5373 3
a5375 3
		  case 'C':		/* specify controlling user */
			ctladdr = setctluser(&bp[1], qfver);
			break;
d5377 6
a5382 29
		  case 'Q':		/* original recipient */
			orcpt = newstr(&bp[1]);
			break;

		  case 'R':		/* specify recipient */
			p = bp;
			qflags = 0;
			if (qfver >= 1)
			{
				/* get flag bits */
				while (*++p != '\0' && *p != ':')
				{
					switch (*p)
					{
					  case 'N':
						qflags |= QHASNOTIFY;
						break;

					  case 'S':
						qflags |= QPINGONSUCCESS;
						break;

					  case 'F':
						qflags |= QPINGONFAILURE;
						break;

					  case 'D':
						qflags |= QPINGONDELAY;
						break;
d5384 4
a5387 3
					  case 'P':
						qflags |= QPRIMARY;
						break;
d5389 9
a5397 21
					  case 'A':
						if (ctladdr != NULL)
							ctladdr->q_flags |= QALIAS;
						break;
					}
				}
			}
			else
				qflags |= QPRIMARY;
			q = parseaddr(++p, NULLADDR, RF_COPYALL, '\0', NULL, e);
			if (q != NULL)
			{
				q->q_alias = ctladdr;
				if (qfver >= 1)
					q->q_flags &= ~Q_PINGFLAGS;
				q->q_flags |= qflags;
				q->q_orcpt = orcpt;
				(void) recipient(q, &e->e_sendqueue, 0, e);
			}
			orcpt = NULL;
			break;
d5399 9
a5407 3
		  case 'E':		/* specify error recipient */
			/* no longer used */
			break;
d5409 3
a5411 4
		  case 'H':		/* header */
			(void) chompheader(&bp[1], CHHDR_QUEUE, NULL, e);
			hdrsize += strlen(&bp[1]);
			break;
d5413 13
a5425 4
		  case 'L':		/* Solaris Content-Length: */
		  case 'M':		/* message */
			/* ignore this; we want a new message next time */
			break;
d5427 10
a5436 3
		  case 'S':		/* sender */
			setsender(newstr(&bp[1]), e, NULL, '\0', TRUE);
			break;
d5438 16
a5453 3
		  case 'B':		/* body type */
			e->e_bodytype = newstr(&bp[1]);
			break;
d5455 6
a5460 5
# if _FFR_SAVE_CHARSET
		  case 'X':		/* character set */
			e->e_charset = newstr(&bp[1]);
			break;
# endif /* _FFR_SAVE_CHARSET */
d5462 5
a5466 3
		  case 'D':		/* data file name */
			/* obsolete -- ignore */
			break;
d5468 2
a5469 3
		  case 'T':		/* init time */
			e->e_ctime = atol(&bp[1]);
			break;
d5471 3
a5473 3
		  case 'I':		/* data file's inode number */
			/* regenerated below */
			break;
d5475 4
a5478 3
		  case 'K':		/* time of last delivery attempt */
			e->e_dtime = atol(&buf[1]);
			break;
d5480 4
a5483 8
# if _FFR_QUEUEDELAY
		  case 'G':		/* queue delay algorithm */
			e->e_queuealg = atoi(&buf[1]);
			break;
		  case 'Y':		/* current delay */
			e->e_queuedelay = (time_t) atol(&buf[1]);
			break;
# endif /* _FFR_QUEUEDELAY */
d5485 10
a5494 2
		  case 'N':		/* number of delivery attempts */
			e->e_ntries = atoi(&buf[1]);
d5496 14
a5509 4
			/* if this has been tried recently, let it be */
			now = curtime();
			if (e->e_ntries > 0 && e->e_dtime <= now &&
			    now < e->e_dtime + queuedelay(e))
d5511 4
a5514 16
				char *howlong;

				howlong = pintvl(now - e->e_dtime, TRUE);
				if (Verbose)
					printf("%s: too young (%s)\n",
					       e->e_id, howlong);
				if (tTd(40, 8))
					dprintf("%s: too young (%s)\n",
						e->e_id, howlong);
				if (LogLevel > 19)
					sm_syslog(LOG_DEBUG, e->e_id,
						  "too young (%s)",
						  howlong);
				e->e_id = NULL;
				unlockqueue(e);
				return FALSE;
a5515 1
			define(macid("{ntries}", NULL), newstr(&buf[1]), e);
d5517 4
a5520 14
# if NAMED_BIND
			/* adjust BIND parameters immediately */
			if (e->e_ntries == 0)
			{
				_res.retry = TimeOuts.res_retry[RES_TO_FIRST];
				_res.retrans = TimeOuts.res_retrans[RES_TO_FIRST];
			}
			else
			{
				_res.retry = TimeOuts.res_retry[RES_TO_NORMAL];
				_res.retrans = TimeOuts.res_retrans[RES_TO_NORMAL];
			}
# endif /* NAMED_BIND */
			break;
d5522 2
a5523 3
		  case 'P':		/* message priority */
			e->e_msgpriority = atol(&bp[1]) + WkTimeFact;
			break;
d5525 1
a5525 2
		  case 'F':		/* flag bits */
			if (strncmp(bp, "From ", 5) == 0)
d5527 4
a5530 5
				/* we are being spoofed! */
				syserr("SECURITY ALERT: bogus qf line %s", bp);
				(void) fclose(qfp);
				loseqfile(e, "bogus queue line");
				return FALSE;
d5532 1
a5532 1
			for (p = &bp[1]; *p != '\0'; p++)
d5534 5
a5538 1
				switch (*p)
d5540 5
a5544 3
				  case 'w':	/* warning sent */
					e->e_flags |= EF_WARNING;
					break;
d5546 2
a5547 3
				  case 'r':	/* response */
					e->e_flags |= EF_RESPONSE;
					break;
d5549 5
a5553 3
				  case '8':	/* has 8 bit data */
					e->e_flags |= EF_HAS8BIT;
					break;
a5554 3
				  case 'b':	/* delete Bcc: header */
					e->e_flags |= EF_DELETE_BCC;
					break;
d5556 3
a5558 3
				  case 'd':	/* envelope has DSN RET= */
					e->e_flags |= EF_RET_PARAM;
					break;
d5560 2
a5561 6
				  case 'n':	/* don't return body */
					e->e_flags |= EF_NO_BODY_RETN;
					break;
				}
			}
			break;
d5563 6
a5568 4
		  case 'Z':		/* original envelope id from ESMTP */
			e->e_envid = newstr(&bp[1]);
			define(macid("{dsn_envid}", NULL), newstr(&bp[1]), e);
			break;
d5570 13
a5582 3
		  case 'A':		/* AUTH= parameter */
			e->e_auth_param = newstr(&bp[1]);
			break;
d5584 6
a5589 3
		  case '$':		/* define macro */
			{
				char *p;
d5591 11
a5601 3
				mid = macid(&bp[1], &ep);
				if (mid == 0)
					break;
d5603 2
a5604 2
				p = newstr(ep);
				define(mid, p, e);
d5606 6
a5611 15
				/*
				**  HACK ALERT: Unfortunately, 8.10 and
				**  8.11 reused the ${if_addr} and
				**  ${if_family} macros for both the incoming
				**  interface address/family (getrequests())
				**  and the outgoing interface address/family
				**  (makeconnection()).  In order for D_BINDIF
				**  to work properly, have to preserve the
				**  incoming information in the queue file for
				**  later delivery attempts.  The original
				**  information is stored in the envelope
				**  in readqf() so it can be stored in
				**  queueup_macros().  This should be fixed
				**  in 8.12.
				*/
d5613 3
a5615 4
				if (strcmp(macname(mid), "if_addr") == 0)
					e->e_if_macros[EIF_ADDR] = p;
			}
			break;
d5617 7
a5623 3
		  case '.':		/* terminate file */
			nomore = TRUE;
			break;
d5625 2
a5626 6
		  default:
			syserr("readqf: %s: line %d: bad line \"%s\"",
				qf, LineNumber, shortenstring(bp, MAXSHORTSTR));
			(void) fclose(qfp);
			loseqfile(e, "unrecognized line");
			return FALSE;
d5628 2
d5631 5
a5635 2
		if (bp != buf)
			sm_free(bp);
d5637 23
d5661 13
a5673 4
	/*
	**  If we haven't read any lines, this queue file is empty.
	**  Arrange to remove it without referencing any null pointers.
	*/
d5675 6
a5680 1
	if (LineNumber == 0)
d5682 2
a5683 3
		errno = 0;
		e->e_flags |= EF_CLRQUEUE | EF_FATALERRS | EF_RESPONSE;
		return TRUE;
d5685 1
a5685 3

	/* possibly set ${dsn_ret} macro */
	if (bitset(EF_RET_PARAM, e->e_flags))
d5687 2
a5688 4
		if (bitset(EF_NO_BODY_RETN, e->e_flags))
			define(macid("{dsn_ret}", NULL), "hdrs", e);
		else
			define(macid("{dsn_ret}", NULL), "full", e);
d5690 29
d5720 7
a5726 3
	/*
	**  Arrange to read the data file.
	*/
d5728 2
a5729 7
	p = queuename(e, 'd');
	e->e_dfp = fopen(p, "r");
	if (e->e_dfp == NULL)
	{
		syserr("readqf: cannot open %s", p);
	}
	else
d5731 1
a5731 2
		e->e_flags |= EF_HAS_DF;
		if (fstat(fileno(e->e_dfp), &st) >= 0)
d5733 9
a5741 3
			e->e_msgsize = st.st_size + hdrsize;
			e->e_dfdev = st.st_dev;
			e->e_dfino = st.st_ino;
d5744 2
d5747 6
a5752 4
	return TRUE;
}
/*
**  PRTSTR -- print a string, "unprintable" characters are shown as \oct
d5755 1
a5755 2
**		s -- string to print
**		ml -- maximum length of output
d5761 1
a5761 1
**		Prints a string on stdout.
d5764 2
a5765 4
static void
prtstr(s, ml)
	char *s;
	int ml;
d5767 12
a5778 3
	char c;

	if (s == NULL)
d5780 2
a5781 1
	while (ml-- > 0 && ((c = *s++) != '\0'))
d5783 4
a5786 1
		if (c == '\\')
d5788 8
a5795 5
			if (ml-- > 0)
			{
				putchar(c);
				putchar(c);
			}
a5796 2
		else if (isascii(c) && isprint(c))
			putchar(c);
d5799 2
a5800 2
			if ((ml -= 3) > 0)
				printf("\\%03o", c);
d5804 4
a5807 2
/*
**  PRINTQUEUE -- print out a representation of the mail queue
d5810 1
a5810 1
**		none.
d5813 1
a5813 4
**		none.
**
**	Side Effects:
**		Prints a listing of the mail queue on the standard output.
d5816 3
a5818 2
void
printqueue()
d5820 1
a5820 1
	int i, nrequests = 0;
d5822 3
a5824 1
	for (i = 0; i < NumQueues; i++)
d5826 10
a5835 3
		if (StopRequest)
			stop_sendmail();
		nrequests += print_single_queue(i);
d5837 1
a5837 2
	if (NumQueues > 1)
		printf("\t\tTotal Requests: %d\n", nrequests);
d5839 5
a5843 2
/*
**  PRINT_SINGLE_QUEUE -- print out a representation of a single mail queue
d5846 2
a5847 1
**		queuedir -- queue directory
d5850 1
a5850 4
**		number of entries
**
**	Side Effects:
**		Prints a listing of the mail queue on the standard output.
d5853 4
a5856 3
static int
print_single_queue(queuedir)
	int queuedir;
d5858 3
a5860 25
	register WORK *w;
	FILE *f;
	int nrequests;
	char qd[MAXPATHLEN];
	char qddf[MAXPATHLEN];
	char buf[MAXLINE];

	if (queuedir == NOQDIR)
	{
		(void) strlcpy(qd, ".", sizeof qd);
		(void) strlcpy(qddf, ".", sizeof qddf);
	}
	else
	{
		(void) snprintf(qd, sizeof qd, "%s%s",
				QPaths[queuedir].qp_name,
				(bitset(QP_SUBQF, QPaths[queuedir].qp_subdirs) ? "/qf" : ""));
		(void) snprintf(qddf, sizeof qddf, "%s%s",
				QPaths[queuedir].qp_name,
				(bitset(QP_SUBDF, QPaths[queuedir].qp_subdirs) ? "/df" : ""));
	}

	/*
	**  Check for permission to print the queue
	*/
d5862 1
a5862 1
	if (bitset(PRIV_RESTRICTMAILQ, PrivacyFlags) && RealUid != 0)
d5864 2
a5865 7
		struct stat st;
# ifdef NGROUPS_MAX
		int n;
		extern GIDSET_T InitialGidSet[NGROUPS_MAX];
# endif /* NGROUPS_MAX */

		if (stat(qd, &st) < 0)
d5867 2
a5868 18
			syserr("Cannot stat %s", qid_printqueue(queuedir));
			return 0;
		}
# ifdef NGROUPS_MAX
		n = NGROUPS_MAX;
		while (--n >= 0)
		{
			if (InitialGidSet[n] == st.st_gid)
				break;
		}
		if (n < 0 && RealGid != st.st_gid)
# else /* NGROUPS_MAX */
		if (RealGid != st.st_gid)
# endif /* NGROUPS_MAX */
		{
			usrerr("510 You are not permitted to see the queue");
			setstat(EX_NOPERM);
			return 0;
d5870 7
d5878 2
d5881 16
a5896 3
	/*
	**  Read and order the queue.
	*/
d5898 9
a5906 1
	nrequests = orderq(queuedir, TRUE);
d5908 5
a5912 3
	/*
	**  Print the work list that we have read.
	*/
d5914 2
a5915 2
	/* first see if there is anything */
	if (nrequests <= 0)
d5917 4
a5920 2
		printf("%s is empty\n", qid_printqueue(queuedir));
		return 0;
d5923 3
a5925 1
	CurrentLA = sm_getla(NULL);	/* get load average */
d5927 3
a5929 18
	printf("\t\t%s (%d request%s", qid_printqueue(queuedir), nrequests,
	       nrequests == 1 ? "" : "s");
	if (MaxQueueRun > 0 && nrequests > MaxQueueRun)
		printf(", only %d printed", MaxQueueRun);
	if (Verbose)
		printf(")\n----Q-ID---- --Size-- -Priority- ---Q-Time--- ---------Sender/Recipient--------\n");
	else
		printf(")\n----Q-ID---- --Size-- -----Q-Time----- ------------Sender/Recipient------------\n");
	for (w = WorkQ; w != NULL; w = w->w_next)
	{
		struct stat st;
		auto time_t submittime = 0;
		long dfsize;
		int flags = 0;
		int qfver;
		char statmsg[MAXLINE];
		char bodytype[MAXNAME + 1];
		char qf[MAXPATHLEN];
d5931 4
a5934 2
		if (StopRequest)
			stop_sendmail();
d5936 5
a5940 24
		printf("%12s", w->w_name + 2);
		(void) snprintf(qf, sizeof qf, "%s/%s", qd, w->w_name);
		f = fopen(qf, "r");
		if (f == NULL)
		{
			printf(" (job completed)\n");
			errno = 0;
			continue;
		}
		w->w_name[0] = 'd';
		(void) snprintf(qf, sizeof qf, "%s/%s", qddf, w->w_name);
		if (stat(qf, &st) >= 0)
			dfsize = st.st_size;
		else
			dfsize = -1;
		if (w->w_lock)
			printf("*");
		else if (w->w_tooyoung)
			printf("-");
		else if (shouldqueue(w->w_pri, w->w_ctime))
			printf("X");
		else
			printf(" ");
		errno = 0;
d5942 18
a5959 6
		statmsg[0] = bodytype[0] = '\0';
		qfver = 0;
		while (fgets(buf, sizeof buf, f) != NULL)
		{
			register int i;
			register char *p;
d5961 1
a5961 2
			if (StopRequest)
				stop_sendmail();
d5963 7
a5969 6
			fixcrlf(buf, TRUE);
			switch (buf[0])
			{
			  case 'V':	/* queue file version */
				qfver = atoi(&buf[1]);
				break;
d5971 2
a5972 6
			  case 'M':	/* error message */
				if ((i = strlen(&buf[1])) >= sizeof statmsg)
					i = sizeof statmsg - 1;
				memmove(statmsg, &buf[1], i);
				statmsg[i] = '\0';
				break;
d5974 16
a5989 5
			  case 'B':	/* body type */
				if ((i = strlen(&buf[1])) >= sizeof bodytype)
					i = sizeof bodytype - 1;
				memmove(bodytype, &buf[1], i);
				bodytype[i] = '\0';
d5991 1
a5991 25

			  case 'S':	/* sender name */
				if (Verbose)
				{
					printf("%8ld %10ld%c%.12s ",
					       dfsize,
					       w->w_pri,
					       bitset(EF_WARNING, flags) ? '+' : ' ',
					       ctime(&submittime) + 4);
					prtstr(&buf[1], 78);
				}
				else
				{
					printf("%8ld %.16s ", dfsize,
					    ctime(&submittime));
					prtstr(&buf[1], 40);
				}
				if (statmsg[0] != '\0' || bodytype[0] != '\0')
				{
					printf("\n    %10.10s", bodytype);
					if (statmsg[0] != '\0')
						printf("   (%.*s)",
						       Verbose ? 100 : 60,
						       statmsg);
				}
d5993 5
d5999 11
a6009 16
			  case 'C':	/* controlling user */
				if (Verbose)
					printf("\n\t\t\t\t      (---%.74s---)",
					       &buf[1]);
				break;

			  case 'R':	/* recipient name */
				p = &buf[1];
				if (qfver >= 1)
				{
					p = strchr(p, ':');
					if (p == NULL)
						break;
					p++;
				}
				if (Verbose)
d6011 3
a6013 2
					printf("\n\t\t\t\t\t      ");
					prtstr(p, 73);
d6015 2
a6016 1
				else
d6018 3
a6020 2
					printf("\n\t\t\t\t       ");
					prtstr(p, 40);
a6021 1
				break;
d6023 8
a6030 3
			  case 'T':	/* creation time */
				submittime = atol(&buf[1]);
				break;
d6032 11
a6042 10
			  case 'F':	/* flag bits */
				for (p = &buf[1]; *p != '\0'; p++)
				{
					switch (*p)
					{
					  case 'w':
						flags |= EF_WARNING;
						break;
					}
				}
d6044 9
a6053 4
		if (submittime == (time_t) 0)
			printf(" (no control file)");
		printf("\n");
		(void) fclose(f);
a6054 1
	return nrequests;
d6056 2
d6059 1
a6059 1
**  QUEUENAME -- build a file name in the queue directory for this envelope.
d6062 1
a6062 3
**		e -- envelope to build it in/from.
**		type -- the file type, used as the first character
**			of the file name.
d6065 1
a6065 1
**		a pointer to the queue name (in a static buffer).
d6067 1
d6069 2
a6070 3
**		If no id code is already assigned, queuename() will
**		assign an id code with assign_queueid().  If no queue
**		directory is assigned, one will be set with setnewqueue().
d6073 3
a6075 4
char *
queuename(e, type)
	register ENVELOPE *e;
	int type;
d6077 4
a6080 2
	char *sub = "";
	static char buf[MAXPATHLEN];
d6082 6
a6087 3
	/* Assign an ID if needed */
	if (e->e_id == NULL)
		assign_queueid(e);
d6089 12
a6100 8
	/* Assign a queue directory if needed */
	if (e->e_queuedir == NOQDIR)
		setnewqueue(e);

	if (e->e_queuedir == NOQDIR)
		(void) snprintf(buf, sizeof buf, "%cf%s",
				type, e->e_id);
	else
d6102 4
a6105 1
		switch (type)
d6107 44
a6150 4
		  case 'd':
			if (bitset(QP_SUBDF, QPaths[e->e_queuedir].qp_subdirs))
				sub = "/df";
			break;
d6152 3
a6154 7
		  case TEMPQF_LETTER:
		  case 't':
		  case LOSEQF_LETTER:
		  case 'q':
			if (bitset(QP_SUBQF, QPaths[e->e_queuedir].qp_subdirs))
				sub = "/qf";
			break;
d6156 8
a6163 4
		  case 'x':
			if (bitset(QP_SUBXF, QPaths[e->e_queuedir].qp_subdirs))
				sub = "/xf";
			break;
d6165 2
d6168 13
a6180 3
		(void) snprintf(buf, sizeof buf, "%s%s/%cf%s",
				QPaths[e->e_queuedir].qp_name,
				sub, type, e->e_id);
d6183 30
a6212 3
	if (tTd(7, 2))
		dprintf("queuename: %s\n", buf);
	return buf;
d6214 2
d6217 1
a6217 7
**  ASSIGN_QUEUEID -- assign a queue ID for this envelope.
**
**	Assigns an id code if one does not already exist.
**	This code assumes that nothing will remain in the queue for
**	longer than 60 years.  It is critical that files with the given
**	name not already exist in the queue.
**	Also initializes e_queuedir to NOQDIR.
d6220 1
a6220 1
**		e -- envelope to set it in.
d6224 3
a6228 3
static const char QueueIdChars[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwx";
# define QIC_LEN	60

d6230 2
a6231 2
assign_queueid(e)
	register ENVELOPE *e;
d6233 1
a6233 11
	pid_t pid = getpid();
	static char cX = 0;
	static long random_offset;
	struct tm *tm;
	char idbuf[MAXQFNAME - 2];

	if (e->e_id != NULL)
		return;

	/* see if we need to get a new base time/pid */
	if (cX >= QIC_LEN || LastQueueTime == 0 || LastQueuePid != pid)
d6235 5
a6239 13
		time_t then = LastQueueTime;

		/* if the first time through, pick a random offset */
		if (LastQueueTime == 0)
			random_offset = get_random();

		while ((LastQueueTime = curtime()) == then &&
		       LastQueuePid == pid)
		{
			(void) sleep(1);
		}
		LastQueuePid = getpid();
		cX = 0;
d6241 2
a6242 3
	if (tTd(7, 50))
		dprintf("assign_queueid: random_offset = %ld (%d)\n",
			random_offset, (int)(cX + random_offset) % QIC_LEN);
a6243 19
	tm = gmtime(&LastQueueTime);
	idbuf[0] = QueueIdChars[tm->tm_year % QIC_LEN];
	idbuf[1] = QueueIdChars[tm->tm_mon];
	idbuf[2] = QueueIdChars[tm->tm_mday];
	idbuf[3] = QueueIdChars[tm->tm_hour];
	idbuf[4] = QueueIdChars[tm->tm_min];
	idbuf[5] = QueueIdChars[tm->tm_sec];
	idbuf[6] = QueueIdChars[((int)cX++ + random_offset) % QIC_LEN];
	(void) snprintf(&idbuf[7], sizeof idbuf - 7, "%05d",
			(int) LastQueuePid);
	e->e_id = newstr(idbuf);
	define('i', e->e_id, e);
	e->e_queuedir = NOQDIR;
	if (tTd(7, 1))
		dprintf("assign_queueid: assigned id %s, e=%lx\n",
			e->e_id, (u_long) e);
	if (LogLevel > 93)
		sm_syslog(LOG_DEBUG, e->e_id, "assigned id");
}
d6245 1
a6245 7
**  SYNC_QUEUE_TIME -- Assure exclusive PID in any given second
**
**	Make sure one PID can't be used by two processes in any one second.
**
**		If the system rotates PIDs fast enough, may get the
**		same pid in the same second for two distinct processes.
**		This will interfere with the queue file naming system.
d6248 1
a6248 1
**		none
d6251 2
a6252 1
**		none
d6254 1
d6256 1
a6256 1
sync_queue_time()
d6258 1
a6258 8
# if FAST_PID_RECYCLE
	if (OpMode != MD_TEST &&
	    OpMode != MD_VERIFY &&
	    LastQueueTime > 0 &&
	    LastQueuePid == getpid() &&
	    curtime() == LastQueueTime)
		(void) sleep(1);
# endif /* FAST_PID_RECYCLE */
d6261 1
a6261 1
**  UNLOCKQUEUE -- unlock the queue entry for a specified envelope
d6264 2
a6265 1
**		e -- the envelope to unlock.
d6268 1
a6268 1
**		none
d6271 1
a6271 1
**		unlocks the queue for `e'.
d6275 3
a6277 2
unlockqueue(e)
	ENVELOPE *e;
d6279 1
a6279 12
	if (tTd(51, 4))
		dprintf("unlockqueue(%s)\n",
			e->e_id == NULL ? "NOQUEUE" : e->e_id);


	/* if there is a lock file in the envelope, close it */
	if (e->e_lockfp != NULL)
		(void) fclose(e->e_lockfp);
	e->e_lockfp = NULL;

	/* don't create a queue id if we don't already have one */
	if (e->e_id == NULL)
d6281 7
a6287 7

	/* remove the transcript */
	if (LogLevel > 87)
		sm_syslog(LOG_DEBUG, e->e_id, "unlock");
	if (!tTd(51, 104))
		xunlink(queuename(e, 'x'));

d6290 1
a6290 4
**  SETCTLUSER -- create a controlling address
**
**	Create a fake "address" given only a local login name; this is
**	used as a "controlling user" for future recipient addresses.
d6293 13
a6305 2
**		user -- the user name of the controlling user.
**		qfver -- the version stamp of this qf file.
d6308 1
a6308 1
**		An address descriptor for the controlling user.
d6311 1
a6311 1
**		none.
d6314 4
a6317 4
static ADDRESS *
setctluser(user, qfver)
	char *user;
	int qfver;
d6319 5
a6323 3
	register ADDRESS *a;
	struct passwd *pw;
	char *p;
d6325 3
a6327 3
	/*
	**  See if this clears our concept of controlling user.
	*/
d6329 5
a6333 2
	if (user == NULL || *user == '\0')
		return NULL;
d6335 32
a6366 3
	/*
	**  Set up addr fields for controlling user.
	*/
d6368 2
a6369 2
	a = (ADDRESS *) xalloc(sizeof *a);
	memset((char *) a, '\0', sizeof *a);
d6371 2
a6372 15
	if (*user == '\0')
	{
		p = NULL;
		a->q_user = newstr(DefUser);
	}
	else if (*user == ':')
	{
		p = &user[1];
		a->q_user = newstr(p);
	}
	else
	{
		p = strtok(user, ":");
		a->q_user = newstr(user);
		if (qfver >= 2)
d6374 55
a6428 5
			if ((p = strtok(NULL, ":")) != NULL)
				a->q_uid = atoi(p);
			if ((p = strtok(NULL, ":")) != NULL)
				a->q_gid = atoi(p);
			if ((p = strtok(NULL, ":")) != NULL)
d6430 19
a6448 1
				char *o;
d6450 4
a6453 1
				a->q_flags |= QGOODUID;
d6455 2
a6456 3
				/* if there is another ':': restore it */
				if ((o = strtok(NULL, ":")) != NULL && o > p)
					o[-1] = ':';
d6458 7
d6466 15
a6480 1
		else if ((pw = sm_getpwnam(user)) != NULL)
d6482 2
a6483 9
			if (*pw->pw_dir == '\0')
				a->q_home = NULL;
			else if (strcmp(pw->pw_dir, "/") == 0)
				a->q_home = "";
			else
				a->q_home = newstr(pw->pw_dir);
			a->q_uid = pw->pw_uid;
			a->q_gid = pw->pw_gid;
			a->q_flags |= QGOODUID;
d6485 8
d6495 13
a6507 4
	a->q_flags |= QPRIMARY;		/* flag as a "ctladdr" */
	a->q_mailer = LocalMailer;
	if (p == NULL)
		a->q_paddr = newstr(a->q_user);
d6509 14
a6522 2
		a->q_paddr = newstr(p);
	return a;
d6524 1
d6526 1
a6526 1
**  LOSEQFILE -- save the qf as Qf and try to let someone know
d6528 3
a6530 3
**	Parameters:
**		e -- the envelope (e->e_id will be used).
**		why -- reported to whomever can hear.
d6533 4
a6536 1
**		none.
d6539 4
a6542 4
void
loseqfile(e, why)
	register ENVELOPE *e;
	char *why;
d6544 22
a6565 2
	char *p;
	char buf[MAXPATHLEN];
d6567 1
a6567 12
	if (e == NULL || e->e_id == NULL)
		return;
	p = queuename(e, 'q');
	if (strlen(p) >= (SIZE_T) sizeof buf)
		return;
	(void) strlcpy(buf, p, sizeof buf);
	p = queuename(e, LOSEQF_LETTER);
	if (rename(buf, p) < 0)
		syserr("cannot rename(%s, %s), uid=%d", buf, p, geteuid());
	else if (LogLevel > 0)
		sm_syslog(LOG_ALERT, e->e_id,
			  "Losing %s: %s", buf, why);
d6569 3
d6573 1
a6573 1
**  QID_PRINTNAME -- create externally printable version of queue id
d6576 1
a6576 1
**		e -- the envelope.
d6579 4
a6582 1
**		a printable version
d6585 2
a6586 2
char *
qid_printname(e)
d6589 1
a6589 2
	char *id;
	static char idbuf[MAXQFNAME + 34];
d6591 12
a6602 5
	if (e == NULL)
		return "";

	if (e->e_id == NULL)
		id = "";
d6604 4
a6607 1
		id = e->e_id;
d6609 3
a6611 15
	if (e->e_queuedir == NOQDIR)
		return id;

	(void) snprintf(idbuf, sizeof idbuf, "%.32s/%s",
			QPaths[e->e_queuedir].qp_name, id);
	return idbuf;
}
/*
**  QID_PRINTQUEUE -- create full version of queue directory for df files
**
**	Parameters:
**		queuedir -- the short version of the queue directory
**
**	Returns:
**		the full pathname to the queue (static)
d6614 1
a6614 3
char *
qid_printqueue(queuedir)
	int queuedir;
d6616 5
a6620 2
	char *subdir;
	static char dir[MAXPATHLEN];
d6622 10
a6631 5
	if (queuedir == NOQDIR)
		return QueueDir;

	if (strcmp(QPaths[queuedir].qp_name, ".") == 0)
		subdir = NULL;
d6633 2
a6634 1
		subdir = QPaths[queuedir].qp_name;
d6636 2
a6637 11
	(void) snprintf(dir, sizeof dir, "%s%s%s%s", QueueDir,
			subdir == NULL ? "" : "/",
			subdir == NULL ? "" : subdir,
			(bitset(QP_SUBDF, QPaths[queuedir].qp_subdirs) ? "/df" : ""));
	return dir;
}
/*
**  SETNEWQUEUE -- Sets a new queue directory
**
**	Assign a queue directory to an envelope and store the directory
**	in e->e_queuedir.  The queue is chosen at random.
d6639 8
a6646 3
**	This routine may be improved in the future to allow for more
**	elaborate queueing schemes.  Suggestions and code contributions
**	are welcome.
d6649 1
a6649 1
**		e -- envelope to assign a queue for.
d6652 4
a6655 1
**		none.
d6659 1
a6659 2
setnewqueue(e)
	ENVELOPE *e;
d6661 28
a6688 1
	int idx;
d6690 8
a6697 2
	if (tTd(41, 20))
		dprintf("setnewqueue: called\n");
d6699 1
a6699 1
	if (e->e_queuedir != NOQDIR)
d6701 2
a6702 4
		if (tTd(41, 20))
			dprintf("setnewqueue: e_queuedir already assigned (%s)\n",
				qid_printqueue(e->e_queuedir));
		return;
d6704 1
d6706 2
a6707 3
	if (NumQueues <= 1)
		idx = 0;
	else
d6709 5
a6713 9
#if RANDOMSHIFT
		/* lower bits are not random "enough", select others */
		idx = (get_random() >> RANDOMSHIFT) % NumQueues;
#else /* RANDOMSHIFT */
		idx = get_random() % NumQueues;
#endif /* RANDOMSHIFT */
		if (tTd(41, 15))
			dprintf("setnewqueue: get_random() %% %d = %d\n",
				NumQueues, idx);
d6716 79
a6794 4
	e->e_queuedir = idx;
	if (tTd(41, 3))
		dprintf("setnewqueue: Assigned queue directory %s\n",
			qid_printqueue(e->e_queuedir));
d6797 11
a6807 2
/*
**  CHKQDIR -- check a queue directory
d6810 5
a6814 2
**		name -- name of queue directory
**		sff -- flags for safefile()
d6816 3
a6818 2
**	Returns:
**		is it a queue directory?
d6821 2
d6824 3
a6826 3
chkqdir(name, sff)
	char *name;
	long sff;
d6828 68
a6895 2
	struct stat statb;
	int i;
d6897 4
a6900 9
	/* skip over . and .. directories */
	if (name[0] == '.' &&
	    (name[1] == '\0' || (name[1] == '.' && name[2] == '\0')))
		return FALSE;
# if HASLSTAT
	if (lstat(name, &statb) < 0)
# else /* HASLSTAT */
	if (stat(name, &statb) < 0)
# endif /* HASLSTAT */
d6902 3
a6904 4
		if (tTd(41, 2))
			dprintf("multiqueue_cache: stat(\"%s\"): %s\n",
				name, errstring(errno));
		return FALSE;
d6906 1
a6906 2
# if HASLSTAT
	if (S_ISLNK(statb.st_mode))
d6908 7
a6914 5
		/*
		**  For a symlink we need to make sure the
		**  target is a directory
		*/
		if (stat(name, &statb) < 0)
d6916 3
a6918 4
			if (tTd(41, 2))
				dprintf("multiqueue_cache: stat(\"%s\"): %s\n",
					name, errstring(errno));
			return FALSE;
d6921 56
a6976 1
# endif /* HASLSTAT */
d6978 2
a6979 7
	if (!S_ISDIR(statb.st_mode))
	{
		if (tTd(41, 2))
			dprintf("multiqueue_cache: \"%s\": Not a directory\n",
				name);
		return FALSE;
	}
d6981 1
a6981 6
	/* Print a warning if unsafe (but still use it) */
	i = safedirpath(name, RunAsUid, RunAsGid, NULL, sff, 0, 0);
	if (i != 0 && tTd(41, 2))
		dprintf("multiqueue_cache: \"%s\": Not safe: %s\n",
			name, errstring(i));
	return TRUE;
d6984 5
d6990 1
a6990 1
**  MULTIQUEUE_CACHE -- cache a list of paths to queues.
d6992 2
a6993 4
**	Each potential queue is checked as the cache is built.
**	Thereafter, each is blindly trusted.
**	Note that we can be called again after a timeout to rebuild
**	(although code for that is not ready yet).
d6996 6
a7001 1
**		none
d7003 10
a7012 2
**	Returns:
**		none
d7015 7
a7021 2
void
multiqueue_cache()
d7023 5
a7027 8
	register DIR *dp;
	register struct dirent *d;
	char *cp;
	int i, len;
	int slotsleft = 0;
	long sff = SFF_ANYFILE;
	char qpath[MAXPATHLEN];
	char subdir[MAXPATHLEN];
d7029 17
a7045 2
	if (tTd(41, 20))
		dprintf("multiqueue_cache: called\n");
d7047 10
a7056 11
	if (NumQueues != 0 && QPaths != NULL)
	{
		for (i = 0; i < NumQueues; i++)
		{
			if (QPaths[i].qp_name != NULL)
				sm_free(QPaths[i].qp_name);
		}
		sm_free((char *)QPaths);
		QPaths = NULL;
		NumQueues = 0;
	}
d7058 1
a7058 3
	/* If running as root, allow safedirpath() checks to use privs */
	if (RunAsUid == 0)
		sff |= SFF_ROOTOK;
d7060 3
a7062 4
	(void) snprintf(qpath, sizeof qpath, "%s", QueueDir);
	len = strlen(qpath) - 1;
	cp = &qpath[len];
	if (*cp == '*')
d7064 3
a7066 15
		*cp = '\0';
		if ((cp = strrchr(qpath, '/')) == NULL)
		{
			syserr("QueueDirectory: can not wildcard relative path");
			if (tTd(41, 2))
				dprintf("multiqueue_cache: \"%s\": Can not wildcard relative path.\n",
					qpath);
			ExitStat = EX_CONFIG;
			return;
		}
		if (cp == qpath)
		{
			/*
			**  Special case of top level wildcard, like /foo*
			*/
d7068 34
a7101 3
			(void) snprintf(qpath + 1, sizeof qpath - 1,
					"%s", qpath);
			++cp;
d7103 1
a7103 2
		*(cp++) = '\0';
		len = strlen(cp);
d7105 3
a7107 2
		if (tTd(41, 2))
			dprintf("multiqueue_cache: prefix=\"%s\"\n", cp);
d7109 9
a7117 1
		QueueDir = newstr(qpath);
d7119 10
a7128 10
		/*
		**  XXX Should probably wrap this whole loop in a timeout
		**  in case some wag decides to NFS mount the queues.
		*/

		/* test path to get warning messages */
		i= safedirpath(QueueDir, RunAsUid, RunAsGid, NULL, sff, 0, 0);
		if (i != 0 && tTd(41, 2))
			dprintf("multiqueue_cache: \"%s\": Not safe: %s\n",
				QueueDir, errstring(i));
d7130 2
a7131 1
		if (chdir(QueueDir) < 0)
d7133 3
a7135 6
			syserr("can not chdir(%s)", QueueDir);
			if (tTd(41, 2))
				dprintf("multiqueue_cache: \"%s\": %s\n",
					qpath, errstring(errno));
			ExitStat = EX_CONFIG;
			return;
d7138 2
a7139 1
		if ((dp = opendir(".")) == NULL)
d7141 3
a7143 6
			syserr("can not opendir(%s)", QueueDir);
			if (tTd(41, 2))
				dprintf("multiqueue_cache: opendir(\"%s\"): %s\n",
					QueueDir, errstring(errno));
			ExitStat = EX_CONFIG;
			return;
d7145 1
a7145 31
		while ((d = readdir(dp)) != NULL)
		{
			if (strncmp(d->d_name, cp, len) != 0)
			{
				if (tTd(41, 5))
					dprintf("multiqueue_cache: \"%s\", skipped\n",
						d->d_name);
				continue;
			}
			if (!chkqdir(d->d_name, sff))
				continue;

			if (QPaths == NULL)
			{
				slotsleft = 20;
				QPaths = (QPATHS *)xalloc((sizeof *QPaths) *
							  slotsleft);
				NumQueues = 0;
			}
			else if (slotsleft < 1)
			{
				QPaths = (QPATHS *)xrealloc((char *)QPaths,
							    (sizeof *QPaths) *
							    (NumQueues + 10));
				if (QPaths == NULL)
				{
					(void) closedir(dp);
					return;
				}
				slotsleft += 10;
			}
d7147 3
a7149 16
			/* check subdirs */
			QPaths[NumQueues].qp_subdirs = QP_NOSUB;
			(void) snprintf(subdir, sizeof subdir, "%s/%s/%s",
					qpath, d->d_name, "qf");
			if (chkqdir(subdir, sff))
				QPaths[NumQueues].qp_subdirs |= QP_SUBQF;

			(void) snprintf(subdir, sizeof subdir, "%s/%s/%s",
					qpath, d->d_name, "df");
			if (chkqdir(subdir, sff))
				QPaths[NumQueues].qp_subdirs |= QP_SUBDF;

			(void) snprintf(subdir, sizeof subdir, "%s/%s/%s",
					qpath, d->d_name, "xf");
			if (chkqdir(subdir, sff))
				QPaths[NumQueues].qp_subdirs |= QP_SUBXF;
d7151 9
a7159 11
			/* assert(strlen(d->d_name) < MAXPATHLEN - 14) */
			/* maybe even - 17 (subdirs) */
			QPaths[NumQueues].qp_name = newstr(d->d_name);
			if (tTd(41, 2))
				dprintf("multiqueue_cache: %d: \"%s\" cached (%x).\n",
					NumQueues, d->d_name,
					QPaths[NumQueues].qp_subdirs);
			NumQueues++;
			slotsleft--;
		}
		(void) closedir(dp);
a7160 9
	if (NumQueues == 0)
	{
		if (*cp != '*' && tTd(41, 2))
			dprintf("multiqueue_cache: \"%s\": No wildcard suffix character\n",
				QueueDir);
		QPaths = (QPATHS *)xalloc(sizeof *QPaths);
		QPaths[0].qp_name = newstr(".");
		QPaths[0].qp_subdirs = QP_NOSUB;
		NumQueues = 1;
d7162 2
a7163 11
		/* test path to get warning messages */
		(void) safedirpath(QueueDir, RunAsUid, RunAsGid,
				   NULL, sff, 0, 0);
		if (chdir(QueueDir) < 0)
		{
			syserr("can not chdir(%s)", QueueDir);
			if (tTd(41, 2))
				dprintf("multiqueue_cache: \"%s\": %s\n",
					QueueDir, errstring(errno));
			ExitStat = EX_CONFIG;
		}
d7165 9
a7173 4
		/* check subdirs */
		(void) snprintf(subdir, sizeof subdir, "%s/qf", QueueDir);
		if (chkqdir(subdir, sff))
			QPaths[0].qp_subdirs |= QP_SUBQF;
d7175 8
a7182 3
		(void) snprintf(subdir, sizeof subdir, "%s/df",	QueueDir);
		if (chkqdir(subdir, sff))
			QPaths[0].qp_subdirs |= QP_SUBDF;
d7184 8
a7191 4
		(void) snprintf(subdir, sizeof subdir, "%s/xf", QueueDir);
		if (chkqdir(subdir, sff))
			QPaths[0].qp_subdirs |= QP_SUBXF;
	}
d7194 2
a7195 3
# if 0
/*
**  HASHFQN -- calculate a hash value for a fully qualified host name
d7197 3
a7199 3
**	Arguments:
**		fqn -- an all lower-case host.domain string
**		buckets -- the number of buckets (queue directories)
d7201 2
a7202 3
**	Returns:
**		a bucket number (signed integer)
**		-1 on error
d7204 4
a7207 1
**	Contributed by Exactis.com, Inc.
d7210 7
a7216 4
int
hashfqn(fqn, buckets)
	register char *fqn;
	int buckets;
d7218 30
a7247 3
	register char *p;
	register int h = 0, hash, cnt;
#  define WATERINC (1000)
d7249 7
a7255 2
	if (fqn == NULL)
		return -1;
d7258 4
a7261 2
	**  A variation on the gdb hash
	**  This is the best as of Feb 19, 1996 --bcx
d7264 30
a7293 3
	p = fqn;
	h = 0x238F13AF * strlen(p);
	for (cnt = 0; *p != 0; ++p, cnt++)
d7295 5
a7299 1
		h = (h + (*p << (cnt * 5 % 24))) & 0x7FFFFFFF;
a7300 3
	h = (1103515243 * h + 12345) & 0x7FFFFFFF;
	if (buckets < 2)
		hash = 0;
d7302 32
a7333 1
		hash = (h % buckets);
d7335 38
a7372 1
	return hash;
a7373 3
# endif /* 0 */

# if _FFR_QUEUEDELAY
d7375 4
a7378 1
**  QUEUEDELAY -- compute queue delay time
d7381 1
a7381 1
**		e -- the envelope to queue up.
d7383 2
a7384 2
**	Returns:
**		queue delay time
d7387 1
a7387 1
**		may change e_queuedelay
d7390 2
a7391 2
static time_t
queuedelay(e)
d7394 26
a7419 3
	time_t qd;

	if (e->e_queuealg == QD_EXP)
d7421 8
a7428 3
		if (e->e_queuedelay == 0)
			e->e_queuedelay = QueueInitDelay;
		else
d7430 25
a7454 3
			e->e_queuedelay *= 2;
			if (e->e_queuedelay > QueueMaxDelay)
				e->e_queuedelay = QueueMaxDelay;
d7456 1
a7456 1
		qd = e->e_queuedelay;
d7458 10
a7467 3
	else
		qd = MinQueueAge;
	return qd;
a7468 2
# endif /* _FFR_QUEUEDELAY */
#endif /* QUEUE */
@


1.5
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d19 1
a19 1
static char id[] = "@@(#)$Sendmail: queue.c,v 8.343.4.55 2001/05/03 23:37:11 gshapiro Exp $ (with queueing)";
d21 1
a21 1
static char id[] = "@@(#)$Sendmail: queue.c,v 8.343.4.55 2001/05/03 23:37:11 gshapiro Exp $ (without queueing)";
d71 29
d406 1
d2184 1
a2184 1
		  case 'K':	/* time of last delivery attempt */
d2189 1
a2189 1
		  case 'G':	/* queue delay algorithm */
d2192 1
a2192 1
		  case 'Y':	/* current delay */
d2966 3
d2970 5
d3127 1
a3127 1
	if (NumQueues == 1)
@


1.4
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d19 1
a19 1
static char id[] = "@@(#)$Sendmail: queue.c,v 8.343.4.44 2001/02/22 00:55:35 ca Exp $ (with queueing)";
d21 1
a21 1
static char id[] = "@@(#)$Sendmail: queue.c,v 8.343.4.44 2001/02/22 00:55:35 ca Exp $ (without queueing)";
d510 1
a510 1
	if (fflush(tfp) < 0 ||
d796 6
d810 2
a811 2
		(void) setsignal(SIGHUP, intsig);

d820 1
a820 1
			  qid_printqueue(queuedir), getpid(), forkflag);
d962 1
a962 1
		free(w->w_name);
d964 2
a965 2
			free(w->w_host);
		free((char *) w);
d978 10
d1080 1
a1080 1
		free(w->w_name);
d1082 2
a1083 2
			free(w->w_host);
		free((char *) w);
d1331 1
a1331 1
			free(w->w_name);
d1333 1
a1333 1
				free(w->w_host);
d1434 1
a1434 1
		free(WorkList);
d1483 2
a1484 2
		WORK *newlist = (WORK *) realloc((char *)WorkList,
					  (unsigned)sizeof(WORK) * (newsize + 1));
d1781 5
d1806 1
a1806 1
				  getpid());
d1862 1
a1862 1
	struct stat st;
d1907 15
a1921 1
	**  Check the queue file for plausibility to avoid attacks.
d1924 2
a1925 1
	if (fstat(fileno(qfp), &st) < 0)
d1929 1
a1929 1
			dprintf("readqf(%s): fstat failure (%s)\n",
d1935 25
d2307 1
a2307 1
			free(bp);
d2415 3
d2419 1
d2535 3
d2570 3
d2754 2
a2755 1
static char	Base60Code[] =	"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwx";
d2771 1
a2771 1
	if (cX >= 60 || LastQueueTime == 0 || LastQueuePid != pid)
d2789 1
a2789 1
			random_offset, (int)(cX + random_offset) % 60);
d2792 7
a2798 7
	idbuf[0] = Base60Code[tm->tm_year % 60];
	idbuf[1] = Base60Code[tm->tm_mon];
	idbuf[2] = Base60Code[tm->tm_mday];
	idbuf[3] = Base60Code[tm->tm_hour];
	idbuf[4] = Base60Code[tm->tm_min];
	idbuf[5] = Base60Code[tm->tm_sec];
	idbuf[6] = Base60Code[((int)cX++ + random_offset) % 60];
d3131 1
a3131 1
	    (name[1] == '\0' || (name[2] == '.' && name[3] == '\0')))
d3212 1
a3212 1
				(void) free(QPaths[i].qp_name);
d3214 1
a3214 1
		(void) free((char *)QPaths);
d3307 3
a3309 3
				QPaths = (QPATHS *)realloc((char *)QPaths,
							  (sizeof *QPaths) *
							  (NumQueues + 10));
@


1.4.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d19 1
a19 1
static char id[] = "@@(#)$Sendmail: queue.c,v 8.343.4.55 2001/05/03 23:37:11 gshapiro Exp $ (with queueing)";
d21 1
a21 1
static char id[] = "@@(#)$Sendmail: queue.c,v 8.343.4.55 2001/05/03 23:37:11 gshapiro Exp $ (without queueing)";
d510 1
a510 1
	if (fflush(tfp) != 0 ||
a795 6

		/* Reset global flags */
		RestartRequest = NULL;
		ShutdownRequest = NULL;
		PendingSignal = 0;

d804 2
a805 2
		(void) setsignal(SIGHUP, SIG_DFL);
		(void) setsignal(SIGTERM, intsig);
d814 1
a814 1
			  qid_printqueue(queuedir), (int) getpid(), forkflag);
d956 1
a956 1
		sm_free(w->w_name);
d958 2
a959 2
			sm_free(w->w_host);
		sm_free((char *) w);
a971 10
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
d1064 1
a1064 1
		sm_free(w->w_name);
d1066 2
a1067 2
			sm_free(w->w_host);
		sm_free((char *) w);
d1315 1
a1315 1
			sm_free(w->w_name);
d1317 1
a1317 1
				sm_free(w->w_host);
d1418 1
a1418 1
		sm_free(WorkList);
d1467 2
a1468 2
		WORK *newlist = (WORK *) xrealloc((char *)WorkList,
						  (unsigned)sizeof(WORK) * (newsize + 1));
a1764 5
		/* Reset global flags */
		RestartRequest = NULL;
		ShutdownRequest = NULL;
		PendingSignal = 0;

d1785 1
a1785 1
				  (int) getpid());
d1841 1
a1841 1
	struct stat st, stf;
d1886 1
a1886 15
	**  Prevent locking race condition.
	**
	**  Process A: readqf(): qfp = fopen(qffile)
	**  Process B: queueup(): rename(tf, qf)
	**  Process B: unlocks(tf)
	**  Process A: lockfile(qf);
	**
	**  Process A (us) has the old qf file (before the rename deleted
	**  the directory entry) and will be delivering based on old data.
	**  This can lead to multiple deliveries of the same recipients.
	**
	**  Catch this by checking if the underlying qf file has changed
	**  *after* acquiring our lock and if so, act as though the file
	**  was still locked (i.e., just return like the lockfile() case
	**  above.
d1889 1
a1889 2
	if (stat(qf, &stf) < 0 ||
	    fstat(fileno(qfp), &st) < 0)
d1893 1
a1893 1
			dprintf("readqf(%s): [f]stat failure (%s)\n",
a1898 25
	if (st.st_nlink != stf.st_nlink ||
	    st.st_dev != stf.st_dev ||
	    st.st_ino != stf.st_ino ||
# if HAS_ST_GEN && 0		/* AFS returns garbage in st_gen */
	    st.st_gen != stf.st_gen ||
# endif /* HAS_ST_GEN && 0 */
	    st.st_uid != stf.st_uid ||
	    st.st_gid != stf.st_gid ||
	    st.st_size != stf.st_size)
	{
		/* changed after opened */
		if (Verbose)
			printf("%s: changed\n", e->e_id);
		if (tTd(40, 8))
			dprintf("%s: changed\n", e->e_id);
		if (LogLevel > 19)
			sm_syslog(LOG_DEBUG, e->e_id, "changed");
		(void) fclose(qfp);
		return FALSE;
	}

	/*
	**  Check the queue file for plausibility to avoid attacks.
	*/

d2246 1
a2246 1
			sm_free(bp);
a2353 3
	{
		if (StopRequest)
			stop_sendmail();
a2354 1
	}
a2469 3
		if (StopRequest)
			stop_sendmail();

a2501 3
			if (StopRequest)
				stop_sendmail();

d2683 1
a2683 2
static const char QueueIdChars[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwx";
# define QIC_LEN	60
d2699 1
a2699 1
	if (cX >= QIC_LEN || LastQueueTime == 0 || LastQueuePid != pid)
d2717 1
a2717 1
			random_offset, (int)(cX + random_offset) % QIC_LEN);
d2720 7
a2726 7
	idbuf[0] = QueueIdChars[tm->tm_year % QIC_LEN];
	idbuf[1] = QueueIdChars[tm->tm_mon];
	idbuf[2] = QueueIdChars[tm->tm_mday];
	idbuf[3] = QueueIdChars[tm->tm_hour];
	idbuf[4] = QueueIdChars[tm->tm_min];
	idbuf[5] = QueueIdChars[tm->tm_sec];
	idbuf[6] = QueueIdChars[((int)cX++ + random_offset) % QIC_LEN];
d3059 1
a3059 1
	    (name[1] == '\0' || (name[1] == '.' && name[2] == '\0')))
d3140 1
a3140 1
				sm_free(QPaths[i].qp_name);
d3142 1
a3142 1
		sm_free((char *)QPaths);
d3235 3
a3237 3
				QPaths = (QPATHS *)xrealloc((char *)QPaths,
							    (sizeof *QPaths) *
							    (NumQueues + 10));
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d19 1
a19 1
static char id[] = "@@(#)$Sendmail: queue.c,v 8.343.4.38 2000/12/08 14:33:02 ca Exp $ (with queueing)";
d21 1
a21 1
static char id[] = "@@(#)$Sendmail: queue.c,v 8.343.4.38 2000/12/08 14:33:02 ca Exp $ (without queueing)";
d838 1
d1562 1
a1562 1
	return a->w_pri - b->w_pri;
d1603 1
a1603 1
	return a->w_pri - b->w_pri;
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d14 1
d19 1
a19 1
static char id[] = "@@(#)$Sendmail: queue.c,v 8.343 2000/03/15 06:58:09 gshapiro Exp $ (with queueing)";
d21 1
a21 1
static char id[] = "@@(#)$Sendmail: queue.c,v 8.343 2000/03/15 06:58:09 gshapiro Exp $ (without queueing)";
d25 1
a25 1
#include <dirent.h>
d86 3
d122 4
d129 2
a131 1
			{
d136 1
a136 2
				tfd = open(tf, O_CREAT|O_WRONLY|O_EXCL,
					   QueueFileMode);
a138 1
			}
d140 1
a140 1
			tfd = open(tf, O_CREAT|O_WRONLY|O_EXCL, FileMode);
d143 9
a151 8
			if (tfd < 0)
			{
				if (errno != EEXIST)
					break;
				if (LogLevel > 0 && (i % 32) == 0)
					sm_syslog(LOG_ALERT, e->e_id,
						  "queueup: cannot create %s, uid=%d: %s",
						  tf, geteuid(), errstring(errno));
d153 1
a153 1
			else
d161 5
a165 1
				(void) close(tfd);
d171 1
a171 1
				(void) rename(tf, queuename(e, 'T'));
d388 3
d454 1
a454 1
					macname(h->h_macro & 0377));
a526 1

d535 1
a535 2
			syserr("!queueup: cannot fsync queue temp file %s",
			       tf);
d658 3
d718 1
a718 1
	time_t current_la_time;
a720 2
	DoQueueRun = FALSE;

d805 1
d868 1
d883 2
a884 1
		if (current_la_time < curtime() - 30)
d887 1
a887 1
			current_la_time = curtime();
d1000 1
d1064 1
a1064 1
		if (w->w_host)
d1157 3
a1159 1
		if (QueueSortOrder == QSO_BYFILENAME)
d1171 1
d1194 5
d1201 1
a1201 1
		if (QueueSortOrder == QSO_BYHOST || QueueLimitRecipient != NULL)
d1240 1
d1269 11
a1279 11
				  check = QueueLimitSender;
				  while (check != NULL)
				  {
					  if (strcontainedin(check->queue_match,
							     &lbuf[1]))
						  break;
					  else
						  check = check->queue_next;
				  }
				  if (check != NULL)
					  i &= ~NEED_S;
a1842 1
	int chompflags;
d1865 2
a1866 1
		if (errno != ENOENT)
d1967 1
d2029 5
d2057 1
a2057 2
			chompflags = 0;
			(void) chompheader(&bp[1], &chompflags, NULL, e);
d2109 3
a2111 2
			if (e->e_ntries > 0 && e->e_dtime <= curtime() &&
			    curtime() < e->e_dtime + queuedelay(e))
d2115 1
a2115 1
				howlong = pintvl(curtime() - e->e_dtime, TRUE);
d2201 29
a2229 2
			mid = macid(&bp[1], &ep);
			define(mid, newstr(ep), e);
d2364 1
a2364 1
**		none.
d2643 1
a2643 1
		  case 'T':
d2645 1
a2645 1
		  case 'Q':
d2785 1
d2867 3
a2869 1
			if (strcmp(pw->pw_dir, "/") == 0)
d2912 1
a2912 1
	p = queuename(e, 'Q');
d3056 4
d3161 1
a3161 1
					QueueDir);
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
a13 1

d18 1
a18 1
static char id[] = "@@(#)$Sendmail: queue.c,v 8.343.4.55 2001/05/03 23:37:11 gshapiro Exp $ (with queueing)";
d20 1
a20 1
static char id[] = "@@(#)$Sendmail: queue.c,v 8.343.4.55 2001/05/03 23:37:11 gshapiro Exp $ (without queueing)";
d24 1
a24 1
# include <dirent.h>
a84 3
# define TEMPQF_LETTER 'T'
# define LOSEQF_LETTER 'Q'

a117 4
		int flags;

		flags = O_CREAT|O_WRONLY|O_EXCL;

d121 1
a121 1
			if (tfd < 0)
a122 1
#if _FFR_QUEUE_FILE_MODE
d127 2
a128 1
				tfd = open(tf, flags, QueueFileMode);
d131 1
d133 1
a133 1
				tfd = open(tf, flags, FileMode);
d136 8
a143 9
				if (tfd < 0)
				{
					if (errno != EEXIST)
						break;
					if (LogLevel > 0 && (i % 32) == 0)
						sm_syslog(LOG_ALERT, e->e_id,
							  "queueup: cannot create %s, uid=%d: %s",
							  tf, geteuid(), errstring(errno));
				}
d145 1
a145 1
			if (tfd >= 0)
d153 1
a153 5
				if ((i % 32) == 31)
				{
					(void) close(tfd);
					tfd = -1;
				}
d159 1
a159 1
				(void) rename(tf, queuename(e, TEMPQF_LETTER));
a375 3
		if (q->q_alias != NULL &&
		    bitset(QALIAS, q->q_alias->q_flags))
			(void) putc('A', tfp);
d439 1
a439 1
					macname(bitidx(h->h_macro)));
d495 1
a495 1
	if (fflush(tfp) != 0 ||
d512 1
d521 2
a522 1
			syserr("!queueup: cannot fsync queue temp file %s", tf);
a644 3
	DoQueueRun = FALSE;


d702 1
a702 1
	time_t current_la_time, now;
d705 2
a781 6

		/* Reset global flags */
		RestartRequest = NULL;
		ShutdownRequest = NULL;
		PendingSignal = 0;

d790 1
a790 2
		(void) setsignal(SIGHUP, SIG_DFL);
		(void) setsignal(SIGTERM, intsig);
d799 1
a799 1
			  qid_printqueue(queuedir), (int) getpid(), forkflag);
a822 1
	e->e_parent = NULL;
a852 1

d867 1
a867 2
		now = curtime();
		if (current_la_time < now - 30)
d870 1
a870 1
			current_la_time = now;
d938 1
a938 1
		sm_free(w->w_name);
d940 2
a941 2
			sm_free(w->w_host);
		sm_free((char *) w);
a953 10
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
a982 1
# define NEED_H		020
d1045 4
a1048 4
		sm_free(w->w_name);
		if (w->w_host != NULL)
			sm_free(w->w_host);
		sm_free((char *) w);
d1139 1
a1139 3
		if (QueueSortOrder == QSO_BYFILENAME &&
		    QueueLimitSender == NULL &&
		    QueueLimitRecipient == NULL)
a1150 1

a1172 5
		if (QueueSortOrder == QSO_BYHOST)
		{
			/* need w_host set for host sort order */
			i |= NEED_H;
		}
d1175 1
a1175 1
		if (QueueLimitRecipient != NULL)
a1213 1
					i &= ~NEED_H;
d1242 11
a1252 11
				check = QueueLimitSender;
				while (check != NULL)
				{
					if (strcontainedin(check->queue_match,
							   &lbuf[1]))
						break;
					else
						check = check->queue_next;
				}
				if (check != NULL)
					i &= ~NEED_S;
d1287 1
a1287 1
			sm_free(w->w_name);
d1289 1
a1289 1
				sm_free(w->w_host);
d1390 1
a1390 1
		sm_free(WorkList);
d1439 2
a1440 2
		WORK *newlist = (WORK *) xrealloc((char *)WorkList,
						  (unsigned)sizeof(WORK) * (newsize + 1));
d1534 1
a1534 1
	return workcmpf0(a, b);
d1575 1
a1575 1
	return workcmpf0(a, b);
a1736 5
		/* Reset global flags */
		RestartRequest = NULL;
		ShutdownRequest = NULL;
		PendingSignal = 0;

d1757 1
a1757 1
				  (int) getpid());
d1813 1
a1813 1
	struct stat st, stf;
d1816 1
d1839 1
a1839 2
		if (errno != ENOENT
		    )
d1858 1
a1858 15
	**  Prevent locking race condition.
	**
	**  Process A: readqf(): qfp = fopen(qffile)
	**  Process B: queueup(): rename(tf, qf)
	**  Process B: unlocks(tf)
	**  Process A: lockfile(qf);
	**
	**  Process A (us) has the old qf file (before the rename deleted
	**  the directory entry) and will be delivering based on old data.
	**  This can lead to multiple deliveries of the same recipients.
	**
	**  Catch this by checking if the underlying qf file has changed
	**  *after* acquiring our lock and if so, act as though the file
	**  was still locked (i.e., just return like the lockfile() case
	**  above.
d1861 1
a1861 2
	if (stat(qf, &stf) < 0 ||
	    fstat(fileno(qfp), &st) < 0)
d1865 1
a1865 1
			dprintf("readqf(%s): [f]stat failure (%s)\n",
a1870 25
	if (st.st_nlink != stf.st_nlink ||
	    st.st_dev != stf.st_dev ||
	    st.st_ino != stf.st_ino ||
# if HAS_ST_GEN && 0		/* AFS returns garbage in st_gen */
	    st.st_gen != stf.st_gen ||
# endif /* HAS_ST_GEN && 0 */
	    st.st_uid != stf.st_uid ||
	    st.st_gid != stf.st_gid ||
	    st.st_size != stf.st_size)
	{
		/* changed after opened */
		if (Verbose)
			printf("%s: changed\n", e->e_id);
		if (tTd(40, 8))
			dprintf("%s: changed\n", e->e_id);
		if (LogLevel > 19)
			sm_syslog(LOG_DEBUG, e->e_id, "changed");
		(void) fclose(qfp);
		return FALSE;
	}

	/*
	**  Check the queue file for plausibility to avoid attacks.
	*/

a1939 1
		time_t now;
a2000 5

					  case 'A':
						if (ctladdr != NULL)
							ctladdr->q_flags |= QALIAS;
						break;
d2024 2
a2025 1
			(void) chompheader(&bp[1], CHHDR_QUEUE, NULL, e);
d2077 2
a2078 3
			now = curtime();
			if (e->e_ntries > 0 && e->e_dtime <= now &&
			    now < e->e_dtime + queuedelay(e))
d2082 1
a2082 1
				howlong = pintvl(now - e->e_dtime, TRUE);
d2168 2
a2169 29
			{
				char *p;

				mid = macid(&bp[1], &ep);
				if (mid == 0)
					break;

				p = newstr(ep);
				define(mid, p, e);

				/*
				**  HACK ALERT: Unfortunately, 8.10 and
				**  8.11 reused the ${if_addr} and
				**  ${if_family} macros for both the incoming
				**  interface address/family (getrequests())
				**  and the outgoing interface address/family
				**  (makeconnection()).  In order for D_BINDIF
				**  to work properly, have to preserve the
				**  incoming information in the queue file for
				**  later delivery attempts.  The original
				**  information is stored in the envelope
				**  in readqf() so it can be stored in
				**  queueup_macros().  This should be fixed
				**  in 8.12.
				*/

				if (strcmp(macname(mid), "if_addr") == 0)
					e->e_if_macros[EIF_ADDR] = p;
			}
d2185 1
a2185 1
			sm_free(bp);
a2292 3
	{
		if (StopRequest)
			stop_sendmail();
a2293 1
	}
d2304 1
a2304 1
**		number of entries
a2408 3
		if (StopRequest)
			stop_sendmail();

a2440 3
			if (StopRequest)
				stop_sendmail();

d2583 1
a2583 1
		  case TEMPQF_LETTER:
d2585 1
a2585 1
		  case LOSEQF_LETTER:
d2622 1
a2622 2
static const char QueueIdChars[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwx";
# define QIC_LEN	60
d2638 1
a2638 1
	if (cX >= QIC_LEN || LastQueueTime == 0 || LastQueuePid != pid)
d2656 1
a2656 1
			random_offset, (int)(cX + random_offset) % QIC_LEN);
d2659 7
a2665 7
	idbuf[0] = QueueIdChars[tm->tm_year % QIC_LEN];
	idbuf[1] = QueueIdChars[tm->tm_mon];
	idbuf[2] = QueueIdChars[tm->tm_mday];
	idbuf[3] = QueueIdChars[tm->tm_hour];
	idbuf[4] = QueueIdChars[tm->tm_min];
	idbuf[5] = QueueIdChars[tm->tm_sec];
	idbuf[6] = QueueIdChars[((int)cX++ + random_offset) % QIC_LEN];
a2724 1

d2806 1
a2806 3
			if (*pw->pw_dir == '\0')
				a->q_home = NULL;
			else if (strcmp(pw->pw_dir, "/") == 0)
d2849 1
a2849 1
	p = queuename(e, LOSEQF_LETTER);
a2992 4
	/* skip over . and .. directories */
	if (name[0] == '.' &&
	    (name[1] == '\0' || (name[1] == '.' && name[2] == '\0')))
		return FALSE;
d3072 1
a3072 1
				sm_free(QPaths[i].qp_name);
d3074 1
a3074 1
		sm_free((char *)QPaths);
d3094 1
a3094 1
					qpath);
d3167 3
a3169 3
				QPaths = (QPATHS *)xrealloc((char *)QPaths,
							    (sizeof *QPaths) *
							    (NumQueues + 10));
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
static char id[] = "@@(#)$Sendmail: queue.c,v 8.342 2000/02/27 01:27:44 gshapiro Exp $ (with queueing)";
d20 1
a20 1
static char id[] = "@@(#)$Sendmail: queue.c,v 8.342 2000/02/27 01:27:44 gshapiro Exp $ (without queueing)";
d1821 1
d1871 10
a1880 2
	if ((st.st_uid != geteuid() && geteuid() != RealUid) ||
	    bitset(S_IWOTH|S_IWGRP, st.st_mode))
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@a13 1

d18 1
a18 1
static char id[] = "@@(#)$Id: queue.c,v 8.343.4.38 2000/12/08 14:33:02 ca Exp $ (with queueing)";
d20 1
a20 1
static char id[] = "@@(#)$Id: queue.c,v 8.343.4.38 2000/12/08 14:33:02 ca Exp $ (without queueing)";
d24 1
a24 1
# include <dirent.h>
a84 3
# define TEMPQF_LETTER 'T'
# define LOSEQF_LETTER 'Q'

a117 4
		int flags;

		flags = O_CREAT|O_WRONLY|O_EXCL;

d121 1
a121 1
			if (tfd < 0)
a122 1
#if _FFR_QUEUE_FILE_MODE
d127 2
a128 1
				tfd = open(tf, flags, QueueFileMode);
d131 1
d133 1
a133 1
				tfd = open(tf, flags, FileMode);
d136 8
a143 9
				if (tfd < 0)
				{
					if (errno != EEXIST)
						break;
					if (LogLevel > 0 && (i % 32) == 0)
						sm_syslog(LOG_ALERT, e->e_id,
							  "queueup: cannot create %s, uid=%d: %s",
							  tf, geteuid(), errstring(errno));
				}
d145 1
a145 1
			if (tfd >= 0)
d153 1
a153 5
				if ((i % 32) == 31)
				{
					(void) close(tfd);
					tfd = -1;
				}
d159 1
a159 1
				(void) rename(tf, queuename(e, TEMPQF_LETTER));
a375 3
		if (q->q_alias != NULL &&
		    bitset(QALIAS, q->q_alias->q_flags))
			(void) putc('A', tfp);
d439 1
a439 1
					macname(bitidx(h->h_macro)));
d512 1
d521 2
a522 1
			syserr("!queueup: cannot fsync queue temp file %s", tf);
a644 3
	DoQueueRun = FALSE;


d702 1
a702 1
	time_t current_la_time, now;
d705 2
a790 1

a852 1

d867 1
a867 2
		now = curtime();
		if (current_la_time < now - 30)
d870 1
a870 1
			current_la_time = now;
a982 1
# define NEED_H		020
d1046 1
a1046 1
		if (w->w_host != NULL)
d1139 1
a1139 3
		if (QueueSortOrder == QSO_BYFILENAME &&
		    QueueLimitSender == NULL &&
		    QueueLimitRecipient == NULL)
a1150 1

a1172 5
		if (QueueSortOrder == QSO_BYHOST)
		{
			/* need w_host set for host sort order */
			i |= NEED_H;
		}
d1175 1
a1175 1
		if (QueueLimitRecipient != NULL)
a1213 1
					i &= ~NEED_H;
d1242 11
a1252 11
				check = QueueLimitSender;
				while (check != NULL)
				{
					if (strcontainedin(check->queue_match,
							   &lbuf[1]))
						break;
					else
						check = check->queue_next;
				}
				if (check != NULL)
					i &= ~NEED_S;
d1816 1
a1820 1
	MODE_T qsafe;
d1838 1
a1838 2
		if (errno != ENOENT
		    )
d1870 2
a1871 10
	qsafe = S_IWOTH|S_IWGRP;
#if _FFR_QUEUE_FILE_MODE
	if (bitset(S_IWGRP, QueueFileMode))
		qsafe &= ~S_IWGRP;
#endif /* _FFR_QUEUE_FILE_MODE */

	if ((st.st_uid != geteuid() &&
	     st.st_uid != TrustedUid &&
	     geteuid() != RealUid) ||
	    bitset(qsafe, st.st_mode))
a1930 1
		time_t now;
a1991 5

					  case 'A':
						if (ctladdr != NULL)
							ctladdr->q_flags |= QALIAS;
						break;
d2015 2
a2016 1
			(void) chompheader(&bp[1], CHHDR_QUEUE, NULL, e);
d2068 2
a2069 3
			now = curtime();
			if (e->e_ntries > 0 && e->e_dtime <= now &&
			    now < e->e_dtime + queuedelay(e))
d2073 1
a2073 1
				howlong = pintvl(now - e->e_dtime, TRUE);
d2159 2
a2160 29
			{
				char *p;

				mid = macid(&bp[1], &ep);
				if (mid == 0)
					break;

				p = newstr(ep);
				define(mid, p, e);

				/*
				**  HACK ALERT: Unfortunately, 8.10 and
				**  8.11 reused the ${if_addr} and
				**  ${if_family} macros for both the incoming
				**  interface address/family (getrequests())
				**  and the outgoing interface address/family
				**  (makeconnection()).  In order for D_BINDIF
				**  to work properly, have to preserve the
				**  incoming information in the queue file for
				**  later delivery attempts.  The original
				**  information is stored in the envelope
				**  in readqf() so it can be stored in
				**  queueup_macros().  This should be fixed
				**  in 8.12.
				*/

				if (strcmp(macname(mid), "if_addr") == 0)
					e->e_if_macros[EIF_ADDR] = p;
			}
d2295 1
a2295 1
**		number of entries
d2574 1
a2574 1
		  case TEMPQF_LETTER:
d2576 1
a2576 1
		  case LOSEQF_LETTER:
a2715 1

d2797 1
a2797 3
			if (*pw->pw_dir == '\0')
				a->q_home = NULL;
			else if (strcmp(pw->pw_dir, "/") == 0)
d2840 1
a2840 1
	p = queuename(e, LOSEQF_LETTER);
a2983 4
	/* skip over . and .. directories */
	if (name[0] == '.' &&
	    (name[1] == '\0' || (name[2] == '.' && name[3] == '\0')))
		return FALSE;
d3085 1
a3085 1
					qpath);
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d14 1
d17 7
a23 10
SM_RCSID("@@(#)$Sendmail: queue.c,v 8.768 2001/09/08 01:21:09 gshapiro Exp $")

#include <dirent.h>

#if SM_CONF_SHM
# include <sm/shm.h>
#endif /* SM_CONF_SHM */

# define RELEASE_QUEUE	(void) 0
# define ST_INODE(st)	(st).st_ino
d25 1
d27 1
a27 5
/*
**  Historical notes:
**	QF_VERSION==4 was sendmail 8.10/8.11 without _FFR_QUEUEDELAY
**	QF_VERSION==5 was sendmail 8.10/8.11 with    _FFR_QUEUEDELAY
*/
d29 2
a30 2
#if _FFR_QUEUEDELAY
# define QF_VERSION	7	/* version number of this queue format */
d32 4
a35 9
#define queuedelay_qfver_unsupported(qfver) false
#else /* _FFR_QUEUEDELAY */
# define QF_VERSION	6	/* version number of this queue format */
# define queuedelay(e)	MinQueueAge
#define queuedelay_qfver_unsupported(qfver) ((qfver) == 5 || (qfver) == 7)
#endif /* _FFR_QUEUEDELAY */


/* Naming convention: qgrp: index of queue group, qg: QUEUEGROUP */
d48 1
a48 4
	time_t		w_ctime;	/* creation time */
	time_t		w_mtime;	/* modification time */
	int		w_qgrp;		/* queue group located in */
	int		w_qdir;		/* queue directory located in */
d54 1
a54 46
static WORK	*WorkQ;		/* queue of things to be done */
static int	NumWorkGroups;	/* number of work groups */

/*
**  use of DoQueueRun:
**	NumQueue: indicates that a queue run is needed, look at individual bits
**	0 - NumQueue-1: indicates that a queue run for this queue group
**		is needed.
*/

static BITMAP256	volatile DoQueueRun;	/* non-interrupt time queue run needed */

/*
**  Work group definition structure.
**	Each work group contains one or more queue groups. This is done
**	to manage the number of queue group runners active at the same time
**	to be within the constraints of MaxQueueChildren (if it is set).
**	The number of queue groups that can be run on the next work run
**	is kept track of. The queue groups are run in a round robin.
*/

struct workgrp
{
	int		wg_numqgrp;	/* number of queue groups in work grp */
	int		wg_runners;	/* total runners */
	int		wg_curqgrp;	/* current queue group */
	QUEUEGRP	**wg_qgs;	/* array of queue groups */
	int		wg_maxact;	/* max # of active runners */
	time_t		wg_lowqintvl;	/* lowest queue interval */
	int		wg_restart;	/* needs restarting? */
	int		wg_restartcnt;	/* count of times restarted */
};

typedef struct workgrp WORKGRP;

static WORKGRP	volatile WorkGrp[MAXWORKGROUPS + 1];	/* work groups */

#if SM_HEAP_CHECK
static SM_DEBUG_T DebugLeakQ = SM_DEBUG_INITIALIZER("leak_q",
	"@@(#)$Debug: leak_q - trace memory leaks during queue processing $");
#endif /* SM_HEAP_CHECK */

/*
**  We use EmptyString instead of "" to avoid
**  'zero-length format string' warnings from gcc
*/
d56 4
a59 8
static const char EmptyString[] = "";

static void	grow_wlist __P((int, int));
static int	multiqueue_cache __P((char *, int, QUEUEGRP *, int, unsigned int *));
static int	gatherq __P((int, int, bool, bool *, bool *));
static int	sortq __P((int));
static void	printctladdr __P((ADDRESS *, SM_FILE_T *));
static int	print_single_queue __P((int, int));
d61 2
a62 3
static void	restart_work_group __P((int));
static void	runner_work __P((ENVELOPE *, int, bool, int, int));
static void	schedule_queue_runs __P((bool, int));
d64 1
a64 5
static ADDRESS	*setctluser __P((char *, int, ENVELOPE *));
#if _FFR_RHS
static int	sm_strshufflecmp __P((char *, char *));
static void	init_shuffle_alphabet __P(());
#endif /* _FFR_RHS */
a69 162
static int	workcmpf5();
static int	workcmpf6();
#if _FFR_RHS
static int	workcmpf7();
#endif /* _FFR_RHS */

#if RANDOMSHIFT
# define get_rand_mod(m)	((get_random() >> RANDOMSHIFT) % (m))
#else /* RANDOMSHIFT */
# define get_rand_mod(m)	(get_random() % (m))
#endif /* RANDOMSHIFT */

/*
**  File system definition.
**	Used to keep track of how much free space is available
**	on a file system in which one or more queue directories reside.
*/

typedef struct filesys_shared	FILESYS;

struct filesys_shared
{
	dev_t	fs_dev;		/* unique device id */
	long	fs_avail;	/* number of free blocks available */
	long	fs_blksize;	/* block size, in bytes */
};

/* probably kept in shared memory */
static FILESYS	FileSys[MAXFILESYS];	/* queue file systems */
static char	*FSPath[MAXFILESYS];	/* pathnames for file systems */

#if SM_CONF_SHM

/*
**  Shared memory data
**
**  Current layout:
**	size -- size of shared memory segment
**	pid -- pid of owner, should be a unique id to avoid misinterpretations
**		by other processes.
**	tag -- should be a unique id to avoid misinterpretations by others.
**		idea: hash over configuration data that will be stored here.
**	NumFileSys -- number of file systems.
**	FileSys -- (arrary of) structure for used file systems.
**	RSATmpCnt -- counter for number of uses of ephemeral RSA key.
**	QShm -- (array of) structure for information about queue directories.
*/

/*
**  Queue data in shared memory
*/

typedef struct queue_shared	QUEUE_SHM_T;

struct queue_shared
{
	int	qs_entries;	/* number of entries */
	/* XXX more to follow? */
};

static void	*Pshm;		/* pointer to shared memory */
static FILESYS	*PtrFileSys;	/* pointer to queue file system array */
int		ShmId = SM_SHM_NO_ID;	/* shared memory id */
static QUEUE_SHM_T	*QShm;		/* pointer to shared queue data */

# define SHM_OFF_PID(p)	(((char *) (p)) + sizeof(int))
# define SHM_OFF_TAG(p)	(((char *) (p)) + sizeof(pid_t) + sizeof(int))
# define SHM_OFF_HEAD	(sizeof(pid_t) + sizeof(int) * 2)

/* how to access FileSys */
# define FILE_SYS(i)	(PtrFileSys[i])

/* first entry is a tag, for now just the size */
# define OFF_FILE_SYS(p)	(((char *) (p)) + SHM_OFF_HEAD)

/* offset for PNumFileSys */
# define OFF_NUM_FILE_SYS(p)	(((char *) (p)) + SHM_OFF_HEAD + sizeof(FileSys))

/* offset for PRSATmpCnt */
# define OFF_RSA_TMP_CNT(p) (((char *) (p)) + SHM_OFF_HEAD + sizeof(FileSys) + sizeof(int))
int	*PRSATmpCnt;

/* offset for queue_shm */
# define OFF_QUEUE_SHM(p) (((char *) (p)) + SHM_OFF_HEAD + sizeof(FileSys) + sizeof(int) * 2)

#define QSHM_ENTRIES(i)	QShm[i].qs_entries

/* basic size of shared memory segment */
# define SM_T_SIZE	(SHM_OFF_HEAD + sizeof(FileSys) + sizeof(int) * 2)

static unsigned int	hash_q __P((char *, unsigned int));

/*
**  HASH_Q -- simple hash function
**
**	Parameters:
**		p -- string to hash.
**		h -- hash start value (from previous run).
**
**	Returns:
**		hash value.
*/

static unsigned int
hash_q(p, h)
	char *p;
	unsigned int h;
{
	int c, d;

	while (*p != '\0')
	{
		d = *p++;
		c = d;
		c ^= c<<6;
		h += (c<<11) ^ (c>>1);
		h ^= (d<<14) + (d<<7) + (d<<4) + d;
	}
	return h;
}

#else /* SM_CONF_SHM */
# define FILE_SYS(i)	FileSys[i]
#endif /* SM_CONF_SHM */

/* access to the various components of file system data */
#define FILE_SYS_NAME(i)	FSPath[i]
#define FILE_SYS_AVAIL(i)	FILE_SYS(i).fs_avail
#define FILE_SYS_BLKSIZE(i)	FILE_SYS(i).fs_blksize
#define FILE_SYS_DEV(i)	FILE_SYS(i).fs_dev

/*
**  Current qf file field assignments:
**
**	A	AUTH= parameter
**	B	body type
**	C	controlling user
**	D	data file name
**	d	data file directory name (added in 8.12)
**	E	error recipient
**	F	flag bits
**	G	queue delay algorithm (_FFR_QUEUEDELAY)
**	H	header
**	I	data file's inode number
**	K	time of last delivery attempt
**	L	Solaris Content-Length: header (obsolete)
**	M	message (obsolete)
**	N	number of delivery attempts
**	P	message priority
**	Q	original recipient (ORCPT=)
**	r	final recipient (Final-Recipient: DSN field)
**	R	recipient
**	S	sender
**	T	init time
**	V	queue file version
**	X	free (was: character set if _FFR_SAVE_CHARSET)
**	Y	current delay (_FFR_QUEUEDELAY)
**	Z	original envelope id from ESMTP
**	!	deliver by (added in 8.12)
**	$	define macro
**	.	terminate file
*/
d76 1
a76 2
**		announce -- if true, tell when you are queueing up.
**		msync -- if true, then fsync() if SuperSafe interactive mode.
d82 1
a82 1
**		The current request is saved in a control file.
d90 1
a90 1
queueup(e, announce, msync)
a92 1
	bool msync;
d95 1
a95 1
	register SM_FILE_T *tfp;
a104 1
	char dfname[MAXPATHLEN];
d112 3
a114 1
	(void) sm_strlcpy(tf, queuename(e, 't'), sizeof tf);
d117 1
a117 1
		newid = false;
d122 3
a124 1
		const int flags = O_CREAT|O_WRONLY|O_EXCL;
d131 2
a132 1
				MODE_T oldumask = 0;
d139 3
d150 1
a150 2
							  tf, geteuid(),
							  sm_errstring(errno));
d160 1
a160 1
						  tf, sm_errstring(errno));
d176 1
a176 3
		if (tfd < 0 || (tfp = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT,
						 (void *) tfd, SM_IO_WRONLY,
						 NULL)) == NULL)
d180 1
a180 1
			printopenfds(true);
d188 2
a189 2
		sm_dprintf("\n>>>>> queueing %s/qf%s%s >>>>>\n",
			qid_printqueue(e->e_qgrp, e->e_qdir), e->e_id,
d193 1
a193 1
		sm_dprintf("  e_flags=");
d198 2
a199 2
		sm_dprintf("  sendq=");
		printaddr(e->e_sendqueue, true);
d203 3
a205 3
		sm_dprintf("  tfp=");
		dumpfd(sm_io_getinfo(tfp, SM_IO_WHAT_FD, NULL), true, false);
		sm_dprintf("  lockfp=");
d207 1
a207 1
			sm_dprintf("NULL\n");
d209 1
a209 2
			dumpfd(sm_io_getinfo(e->e_lockfp, SM_IO_WHAT_FD, NULL),
			       true, false);
a215 1
	(void) sm_strlcpy(dfname, queuename(e, 'd'), sizeof dfname);
d218 1
a218 4
		if (e->e_dfp != NULL &&
		    SuperSafe != SAFE_REALLY &&
		    sm_io_setinfo(e->e_dfp, SM_BF_COMMIT, NULL) < 0 &&
		    errno != EINVAL)
a220 19

		if (e->e_dfp != NULL &&
		    SuperSafe == SAFE_INTERACTIVE && msync)
		{
			if (tTd(40,32))
				sm_syslog(LOG_INFO, e->e_id,
					  "queueup: fsync(e->e_dfp)");

			if (fsync(sm_io_getinfo(e->e_dfp, SM_IO_WHAT_FD,
						NULL)) < 0)
			{
				if (newid)
					syserr("!552 Error writing data file %s",
					       dfname);
				else
					syserr("!452 Error writing data file %s",
					       dfname);
			}
		}
d225 2
a226 2
		MODE_T oldumask = 0;
		register SM_FILE_T *dfp = NULL;
d229 1
a229 2
		if (e->e_dfp != NULL &&
		    sm_io_getinfo(e->e_dfp, SM_IO_WHAT_ISTYPE, BF_FILE_TYPE))
d232 16
a247 8
		if (bitset(S_IWGRP, QueueFileMode))
			oldumask = umask(002);
		dfd = open(dfname, O_WRONLY|O_CREAT|O_TRUNC, QueueFileMode);
		if (bitset(S_IWGRP, QueueFileMode))
			(void) umask(oldumask);
		if (dfd < 0 || (dfp = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT,
						 (void *) dfd, SM_IO_WRONLY,
						 NULL)) == NULL)
d255 1
a255 1
			e->e_dfino = ST_INODE(stbuf);
d262 1
a262 20

		if (SuperSafe == SAFE_REALLY ||
		    (SuperSafe == SAFE_INTERACTIVE && msync))
		{
			if (tTd(40,32))
				sm_syslog(LOG_INFO, e->e_id,
					  "queueup: fsync(dfp)");

			if (fsync(sm_io_getinfo(dfp, SM_IO_WHAT_FD, NULL)) < 0)
			{
				if (newid)
					syserr("!552 Error writing data file %s",
					       dfname);
				else
					syserr("!452 Error writing data file %s",
					       dfname);
			}
		}

		if (sm_io_close(dfp, SM_TIME_DEFAULT) < 0)
d275 1
a275 1
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "V%d\n", QF_VERSION);
d278 1
a278 1
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "T%ld\n", (long) e->e_ctime);
d281 4
a284 4
#if _FFR_QUEUEDELAY
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "K%ld\n", (long) e->e_dtime);
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "G%d\n", e->e_queuealg);
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "Y%ld\n", (long) e->e_queuedelay);
d289 3
a291 3
#else /* _FFR_QUEUEDELAY */
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "K%ld\n", (long) e->e_dtime);
#endif /* _FFR_QUEUEDELAY */
d294 1
a294 1
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "N%d\n", e->e_ntries);
d297 1
a297 12
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "P%ld\n", e->e_msgpriority);

	/*
	**  If df file is in a different directory than the qf file,
	**  output a "d" record naming the directory of the df file.
	*/

	if (e->e_dfqgrp != e->e_qgrp)
	{
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "d%s\n",
			Queue[e->e_dfqgrp]->qg_qpaths[e->e_dfqdir].qp_name);
	}
d303 11
a313 4
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "I%ld/%ld/%llu\n",
				     (long) major(e->e_dfdev),
				     (long) minor(e->e_dfdev),
				     (ULONGLONG_T) e->e_dfino);
d318 6
a323 2
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "B%s\n",
				     denlstring(e->e_bodytype, true, false));
d327 1
a327 2
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "M%s\n",
				     denlstring(e->e_message, true, false));
a342 2
	if (bitset(EF_SPLIT, e->e_flags))
		*p++ = 's';
d345 1
a345 1
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "F%s\n", buf);
d348 1
a348 1
	queueup_macros(macid("{persistentMacros}"), tfp, e);
d355 1
a355 2
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "S%s\n",
			     denlstring(p, true, false));
d359 1
a359 2
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "Z%s\n",
				     denlstring(e->e_envid, true, false));
d363 2
a364 5
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "A%s\n",
				     denlstring(e->e_auth_param, true, false));
	if (e->e_dlvr_flag != 0)
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "!%c %ld\n",
				     (char) e->e_dlvr_flag, e->e_deliver_by);
a372 6
		/* message for this recipient, if it exists */
		if (q->q_message != NULL)
			(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "M%s\n",
					     denlstring(q->q_message, true,
							false));

d375 3
a377 8
			(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "Q%s\n",
					     denlstring(q->q_orcpt, true,
							false));
		if (q->q_finalrcpt != NULL)
			(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "r%s\n",
					     denlstring(q->q_finalrcpt, true,
							false));
		(void) sm_io_putc(tfp, SM_TIME_DEFAULT, 'R');
d379 1
a379 1
			(void) sm_io_putc(tfp, SM_TIME_DEFAULT, 'P');
d381 1
a381 1
			(void) sm_io_putc(tfp, SM_TIME_DEFAULT, 'N');
d383 1
a383 1
			(void) sm_io_putc(tfp, SM_TIME_DEFAULT, 'S');
d385 1
a385 1
			(void) sm_io_putc(tfp, SM_TIME_DEFAULT, 'F');
d387 1
a387 1
			(void) sm_io_putc(tfp, SM_TIME_DEFAULT, 'D');
d390 3
a392 4
			(void) sm_io_putc(tfp, SM_TIME_DEFAULT, 'A');
		(void) sm_io_putc(tfp, SM_TIME_DEFAULT, ':');
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "%s\n",
				     denlstring(q->q_paddr, true, false));
d404 2
a405 2
			sm_dprintf("queueing ");
			printaddr(q, false);
d427 1
a427 1
	macdefine(&e->e_macro, A_PERM, 'g', "\201f");
d447 1
a447 1
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "H?");
d453 2
a454 3
				(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT,
						     "${%s}",
						      macname(bitidx(h->h_macro)));
d456 1
a456 2
				(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT,
						     "$%c", h->h_macro);
d466 1
a466 2
					(void) sm_io_putc(tfp, SM_TIME_DEFAULT,
							  j);
d468 1
a468 1
		(void) sm_io_putc(tfp, SM_TIME_DEFAULT, '?');
d474 3
a476 3
			(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "%s: %s\n",
					     h->h_field,
					     denlstring(buf, false, true));
d482 1
a482 1
			SM_FILE_T *savetrace = TrafficLogFile;
d487 1
a487 1
				oldstyle = false;
d495 3
a497 4
			(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "%s: %s\n",
					     h->h_field,
					     denlstring(h->h_value, false,
							true));
d508 1
a508 1
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, ".\n");
d510 3
a512 5
	if (sm_io_flush(tfp, SM_TIME_DEFAULT) != 0 ||
	    ((SuperSafe == SAFE_REALLY ||
	      (SuperSafe == SAFE_INTERACTIVE && msync)) &&
	     fsync(sm_io_getinfo(tfp, SM_IO_WHAT_FD, NULL)) < 0) ||
	    sm_io_error(tfp))
a526 1

d528 4
a531 3
		**  fsync() after renaming to make sure metadata is
		**  written to disk on filesystems in which renames are
		**  not guaranteed.
d534 2
a535 10
		if (SuperSafe != SAFE_NO)
		{
			/* for softupdates */
			if (tfd >= 0 && fsync(tfd) < 0)
			{
				syserr("!queueup: cannot fsync queue temp file %s",
				       tf);
			}
			SYNC_DIR(qf, true);
		}
d539 1
a539 1
			(void) sm_io_close(e->e_lockfp, SM_TIME_DEFAULT);
d552 1
a552 1
		sm_dprintf("<<<<< done queueing %s <<<<<\n\n", e->e_id);
a555 15
/*
**  PRINTCTLADDR -- print control address to file.
**
**	Parameters:
**		a -- address.
**		tfp -- file pointer.
**
**	Returns:
**		none.
**
**	Side Effects:
**		The control address (if changed) is printed to the file.
**		The last control address and uid are saved.
*/

d559 1
a559 1
	SM_FILE_T *tfp;
d572 1
a572 1
			(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "C\n");
d602 1
a602 231
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "C");
	else
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "C%s:%ld:%ld",
				     denlstring(user, true, false), (long) uid,
				     (long) gid);
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, ":%s\n",
			     denlstring(a->q_paddr, true, false));
}

/*
**  RUNNERS_SIGTERM -- propagate a SIGTERM to queue runner process
**
**	This propagates the signal to the child processes that are queue
**	runners. This is for a queue runner "cleanup". After all of the
**	child queue runner processees are signaled (it should be SIGTERM
**	being the sig) then the old signal handler (Oldsh) is called
**	to handle any cleanup set for this process (provided it is not
**	SIG_DFL or SIG_IGN). The signal may not be handled immediately
**	if the BlockOldsh flag is set. If the current process doesn't
**	have a parent then handle the signal immediately, regardless of
**	BlockOldsh.
**
**	Parameters:
**		sig -- the signal number being sent
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets the NoMoreRunners boolean to true to stop more runners
**		from being started in runqueue().
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

static bool		volatile NoMoreRunners = false;
static sigfunc_t	Oldsh_term = SIG_DFL;
static sigfunc_t	Oldsh_hup = SIG_DFL;
static sigfunc_t	volatile Oldsh = SIG_DFL;
static bool		BlockOldsh = false;
static int		volatile Oldsig = 0;
static SIGFUNC_DECL	runners_sigterm __P((int));
static SIGFUNC_DECL	runners_sighup __P((int));

static SIGFUNC_DECL
runners_sigterm(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, runners_sigterm);
	errno = save_errno;
	CHECK_CRITICAL(sig);
	NoMoreRunners = true;
	Oldsh = Oldsh_term;
	Oldsig = sig;
	proc_list_signal(PROC_QUEUE, sig);

	if (!BlockOldsh || getppid() <= 1)
	{
		/* Check that a valid 'old signal handler' is callable */
		if (Oldsh_term != SIG_DFL && Oldsh_term != SIG_IGN &&
		    Oldsh_term != runners_sigterm)
			(*Oldsh_term)(sig);
	}
	errno = save_errno;
	return SIGFUNC_RETURN;
}
/*
**  RUNNERS_SIGHUP -- propagate a SIGHUP to queue runner process
**
**	This propagates the signal to the child processes that are queue
**	runners. This is for a queue runner "cleanup". After all of the
**	child queue runner processees are signaled (it should be SIGHUP
**	being the sig) then the old signal handler (Oldsh) is called to
**	handle any cleanup set for this process (provided it is not SIG_DFL
**	or SIG_IGN). The signal may not be handled immediately if the
**	BlockOldsh flag is set. If the current process doesn't have
**	a parent then handle the signal immediately, regardless of
**	BlockOldsh.
**
**	Parameters:
**		sig -- the signal number being sent
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets the NoMoreRunners boolean to true to stop more runners
**		from being started in runqueue().
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

static SIGFUNC_DECL
runners_sighup(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, runners_sighup);
	errno = save_errno;
	CHECK_CRITICAL(sig);
	NoMoreRunners = true;
	Oldsh = Oldsh_hup;
	Oldsig = sig;
	proc_list_signal(PROC_QUEUE, sig);

	if (!BlockOldsh || getppid() <= 1)
	{
		/* Check that a valid 'old signal handler' is callable */
		if (Oldsh_hup != SIG_DFL && Oldsh_hup != SIG_IGN &&
		    Oldsh_hup != runners_sighup)
			(*Oldsh_hup)(sig);
	}
	errno = save_errno;
	return SIGFUNC_RETURN;
}
/*
**  MARK_WORK_GROUP_RESTART -- mark a work group as needing a restart
**
**  Sets a workgroup for restarting.
**
**	Parameters:
**		wgrp -- the work group id to restart.
**		reason -- why (signal?).
**
**	Returns:
**		none.
**
**	Side effects:
**		Sets global RestartWorkGroup to true.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

void
mark_work_group_restart(wgrp, reason)
	int wgrp;
	int reason;
{
	if (wgrp < 0 || wgrp > NumWorkGroups)
		return;

	WorkGrp[wgrp].wg_restart = reason;
	RestartWorkGroup = true;
}
/*
**  RESTART_MARKED_WORK_GROUPS -- restart work groups marked as needing restart
**
**  Restart any workgroup marked as needing a restart provided more
**  runners are allowed.
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side effects:
**		Sets global RestartWorkGroup to false.
*/

void
restart_marked_work_groups()
{
	int i;
	int wasblocked;

	if (NoMoreRunners)
		return;

	/* Block SIGCHLD so reapchild() doesn't mess with us */
	wasblocked = sm_blocksignal(SIGCHLD);

	for (i = 0; i < NumWorkGroups; i++)
	{
		if (WorkGrp[i].wg_restart >= 0)
		{
			if (LogLevel > 8)
				sm_syslog(LOG_ERR, NOQID,
					  "restart queue runner=%d due to signal 0x%x",
					  i, WorkGrp[i].wg_restart);
			restart_work_group(i);
		}
	}
	RestartWorkGroup = false;

	if (wasblocked == 0)
		(void) sm_releasesignal(SIGCHLD);
}
/*
**  RESTART_WORK_GROUP -- restart a specific work group
**
**  Restart a specific workgroup provided more runners are allowed.
**  If the requested work group has been restarted too many times log
**  this and refuse to restart.
**
**	Parameters:
**		wgrp -- the work group id to restart
**
**	Returns:
**		none.
**
**	Side Effects:
**		starts another process doing the work of wgrp
*/

#define MAX_PERSIST_RESTART	10	/* max allowed number of restarts */

static void
restart_work_group(wgrp)
	int wgrp;
{
	if (NoMoreRunners ||
	    wgrp < 0 || wgrp > NumWorkGroups)
		return;

	WorkGrp[wgrp].wg_restart = -1;
	if (WorkGrp[wgrp].wg_restartcnt < MAX_PERSIST_RESTART)
	{
		/* avoid overflow; increment here */
		WorkGrp[wgrp].wg_restartcnt++;
		(void) run_work_group(wgrp, true, false, true, true);
	}
d604 3
a606 59
	{
		sm_syslog(LOG_ERR, NOQID,
			  "ERROR: persistent queue runner=%d restarted too many times, queue runner lost",
			  wgrp);
	}
}
/*
**  SCHEDULE_QUEUE_RUNS -- schedule the next queue run for a work group.
**
**	Parameters:
**		runall -- schedule even if individual bit is not set.
**		wgrp -- the work group id to schedule.
**
**	Returns:
**		nothing
*/

#define INCR_MOD(v, m)	if (++v >= m)	\
				v = 0;	\
			else

static void
schedule_queue_runs(runall, wgrp)
	bool runall;
	int wgrp;
{
	int qgrp, cgrp, endgrp;

	/*
	**  This is a bit ugly since we have to duplicate the
	**  code that "walks" through a work queue group.
	*/

	cgrp = endgrp = WorkGrp[wgrp].wg_curqgrp;
	do
	{
		time_t qintvl;

		qgrp = WorkGrp[wgrp].wg_qgs[cgrp]->qg_index;
		if (Queue[qgrp]->qg_queueintvl > 0)
			qintvl = Queue[qgrp]->qg_queueintvl;
		else if (QueueIntvl > 0)
			qintvl = QueueIntvl;
		else
			qintvl = (time_t) 0;
		if ((runall || bitnset(qgrp, DoQueueRun)) && qintvl > 0)
			(void) sm_setevent(qintvl, runqueueevent, qgrp);
#if _FFR_QUEUE_SCHED_DBG
		if (tTd(69, 10))
			sm_syslog(LOG_INFO, NOQID,
				"sqr: wgrp=%d, cgrp=%d, qgrp=%d, intvl=%ld, QI=%ld, runall=%d, bit=%d, sched=%d",
				wgrp, cgrp, qgrp, Queue[qgrp]->qg_queueintvl,
				QueueIntvl, runall, bitnset(qgrp, DoQueueRun),
				(runall || bitnset(qgrp, DoQueueRun)) &&
				qintvl > 0);
#endif /* _FFR_QUEUE_SCHED_DBG */
		clrbitn(qgrp, DoQueueRun);
		INCR_MOD(cgrp, WorkGrp[wgrp].wg_numqgrp);
	} while (endgrp != cgrp);
d615 1
a615 1
**		forkflag -- true if the queue scanning should be done in
d618 2
a619 4
**			false can be ignored if we have multiple queues.
**		verbose -- if true, print out status information.
**		persistent -- persistent queue runner?
**		runall -- run all groups or only a subset (DoQueueRun)?
d622 1
a622 1
**		true if the queue run successfully began.
d625 1
a625 3
**		runs things in the mail queue using run_work_group().
**		maybe schedules next queue run.
**
d629 1
d633 8
d647 2
d650 1
a650 1
runqueue(forkflag, verbose, persistent, runall)
a652 2
	bool persistent;
	bool runall;
d655 1
a655 1
	bool ret = true;
a656 20
	sigfunc_t cursh;
#if SM_HEAP_CHECK
	SM_NONVOLATILE int oldgroup = 0;

	if (sm_debug_active(&DebugLeakQ, 1))
	{
		oldgroup = sm_heap_group();
		sm_heap_newgroup();
		sm_dprintf("runqueue() heap group #%d\n", sm_heap_group());
	}
#endif /* SM_HEAP_CHECK */

	/* queue run has been started, don't do any more this time */
	clrbitn(NumQueue, DoQueueRun);

	/* more then one queue or more then one directory per queue */
	if (!forkflag && !verbose &&
	    (WorkGrp[0].wg_qgs[0]->qg_numqueues > 1 || NumWorkGroups > 1 ||
	     WorkGrp[0].wg_numqgrp > 1))
		forkflag = true;
d658 2
a659 11
	/*
	**  For controlling queue runners via signals sent to this process.
	**  Oldsh* will get called too by runners_sig* (if it is not SIG_IGN
	**  or SIG_DFL) to preserve cleanup behavior. Now that this process
	**  will have children (and perhaps grandchildren) this handler will
	**  be left in place. This is because this process, once it has
	**  finished spinning off queue runners, may go back to doing something
	**  else (like being a daemon). And we still want on a SIG{TERM,HUP} to
	**  clean up the child queue runners. Only install 'runners_sig*' once
	**  else we'll get stuck looping forever.
	*/
d661 2
a662 6
	cursh = sm_signal(SIGTERM, runners_sigterm);
	if (cursh != runners_sigterm)
		Oldsh_term = cursh;
	cursh = sm_signal(SIGHUP, runners_sighup);
	if (cursh != runners_sighup)
		Oldsh_hup = cursh;
d664 1
a664 1
	for (i = 0; i < NumWorkGroups && !NoMoreRunners; i++)
d667 3
a669 24
		**  If MaxQueueChildren active then test whether the start
		**  of the next queue group's additional queue runners (maximum)
		**  will result in MaxQueueChildren being exceeded.
		**
		**  Note: do not use continue; even though another workgroup
		**	may have fewer queue runners, this would be "unfair",
		**	i.e., this work group might "starve" then.
		*/

#if _FFR_QUEUE_SCHED_DBG
		if (tTd(69, 10))
			sm_syslog(LOG_INFO, NOQID,
				"rq: curnum=%d, MaxQueueChildren=%d, CurRunners=%d, WorkGrp[curnum].wg_maxact=%d",
				curnum, MaxQueueChildren, CurRunners,
				WorkGrp[curnum].wg_maxact);
#endif /* _FFR_QUEUE_SCHED_DBG */
		if (MaxQueueChildren > 0 &&
		    CurRunners + WorkGrp[curnum].wg_maxact > MaxQueueChildren)
			break;

		/*
		**  Pick up where we left off (curnum), in case we
		**  used up all the children last time without finishing.
		**  This give a round-robin fairness to queue runs.
d672 1
a672 2
		ret = run_work_group(curnum, forkflag, verbose, persistent,
				     runall);
d682 2
a683 5
		/* Success means the runner count needs to be updated. */
		CurRunners += WorkGrp[curnum].wg_maxact;
		if (!persistent)
			schedule_queue_runs(runall, curnum);
		INCR_MOD(curnum, NumWorkGroups);
d685 6
a690 208

	/* schedule left over queue runs */
	if (i < NumWorkGroups && !NoMoreRunners && !persistent)
	{
		int h;

		for (h = curnum; i < NumWorkGroups; i++)
		{
			schedule_queue_runs(runall, h);
			INCR_MOD(h, NumWorkGroups);
		}
	}


#if SM_HEAP_CHECK
	if (sm_debug_active(&DebugLeakQ, 1))
		sm_heap_setgroup(oldgroup);
#endif /* SM_HEAP_CHECK */
	return ret;
}
/*
**  RUNNER_WORK -- have a queue runner do its work
**
**  Have a queue runner do its work a list of entries.
**  When work isn't directly being done then this process can take a signal
**  and terminate immediately (in a clean fashion of course).
**  When work is directly being done, it's not to be interrupted
**  immediately: the work should be allowed to finish at a clean point
**  before termination (in a clean fashion of course).
**
**	Parameters:
**		e -- envelope.
**		sequenceno -- 'th process to run WorkQ.
**		didfork -- did the calling process fork()?
**		skip -- process only each skip'th item.
**		njobs -- number of jobs in WorkQ.
**
**	Returns:
**		none.
**
**	Side Effects:
**		runs things in the mail queue.
*/

/* Get new load average every 30 seconds. */
#define GET_NEW_LA_TIME	30

static void
runner_work(e, sequenceno, didfork, skip, njobs)
	register ENVELOPE *e;
	int sequenceno;
	bool didfork;
	int skip;
	int njobs;
{
	int n;
	WORK *w;
	time_t current_la_time, now;

	current_la_time = curtime();

	/*
	**  Here we temporarily block the second calling of the handlers.
	**  This allows us to handle the signal without terminating in the
	**  middle of direct work. If a signal does come, the test for
	**  NoMoreRunners will find it.
	*/

	BlockOldsh = true;

	/* process them once at a time */
	while (WorkQ != NULL)
	{
#if SM_HEAP_CHECK
		SM_NONVOLATILE int oldgroup = 0;

		if (sm_debug_active(&DebugLeakQ, 1))
		{
			oldgroup = sm_heap_group();
			sm_heap_newgroup();
			sm_dprintf("run_queue_group() heap group #%d\n",
				sm_heap_group());
		}
#endif /* SM_HEAP_CHECK */

		/* do no more work */
		if (NoMoreRunners)
		{
			/* Check that a valid signal handler is callable */
			if (Oldsh != SIG_DFL && Oldsh != SIG_IGN &&
			    Oldsh != runners_sighup &&
			    Oldsh != runners_sigterm)
				(*Oldsh)(Oldsig);
			break;
		}

		w = WorkQ; /* assign current work item */

		/*
		**  Set the head of the WorkQ to the next work item.
		**  It is set 'skip' ahead (the number of parallel queue
		**  runners working on WorkQ together) since each runner
		**  works on every 'skip'th (N-th) item.
		*/

		for (n = 0; n < skip && WorkQ != NULL; n++)
			WorkQ = WorkQ->w_next;
		e->e_to = NULL;

		/*
		**  Ignore jobs that are too expensive for the moment.
		**
		**	Get new load average every GET_NEW_LA_TIME seconds.
		*/

		now = curtime();
		if (current_la_time < now - GET_NEW_LA_TIME)
		{
			sm_getla();
			current_la_time = now;
		}
		if (shouldqueue(WkRecipFact, current_la_time))
		{
			char *msg = "Aborting queue run: load average too high";

			if (Verbose)
				message("%s", msg);
			if (LogLevel > 8)
				sm_syslog(LOG_INFO, NOQID, "runqueue: %s", msg);
			break;
		}
		if (shouldqueue(w->w_pri, w->w_ctime))
		{
			if (Verbose)
				message(EmptyString);
			if (QueueSortOrder == QSO_BYPRIORITY)
			{
				if (Verbose)
					message("Skipping %s/%s (sequence %d of %d) and flushing rest of queue",
						qid_printqueue(w->w_qgrp,
							       w->w_qdir),
						w->w_name + 2, sequenceno,
						njobs);
				if (LogLevel > 8)
					sm_syslog(LOG_INFO, NOQID,
						  "runqueue: Flushing queue from %s/%s (pri %ld, LA %d, %d of %d)",
						  qid_printqueue(w->w_qgrp,
								 w->w_qdir),
						  w->w_name + 2, w->w_pri,
						  CurrentLA, sequenceno,
						  njobs);
				break;
			}
			else if (Verbose)
				message("Skipping %s/%s (sequence %d of %d)",
					qid_printqueue(w->w_qgrp, w->w_qdir),
					w->w_name + 2, sequenceno, njobs);
		}
		else
		{
			if (Verbose)
			{
				message(EmptyString);
				message("Running %s/%s (sequence %d of %d)",
					qid_printqueue(w->w_qgrp, w->w_qdir),
					w->w_name + 2, sequenceno, njobs);
			}
			if (didfork && MaxQueueChildren > 0)
			{
				sm_blocksignal(SIGCHLD);
				(void) sm_signal(SIGCHLD, reapchild);
			}
			if (tTd(63, 100))
				sm_syslog(LOG_DEBUG, NOQID,
					  "runqueue %s dowork(%s)",
					  qid_printqueue(w->w_qgrp, w->w_qdir),
					  w->w_name + 2);

			(void) dowork(w->w_qgrp, w->w_qdir, w->w_name + 2,
				      false, false, e);
			errno = 0;
		}
		sm_free(w->w_name); /* XXX */
		if (w->w_host != NULL)
			sm_free(w->w_host); /* XXX */
		sm_free((char *) w); /* XXX */
		sequenceno += skip; /* next sequence number */
#if SM_HEAP_CHECK
		if (sm_debug_active(&DebugLeakQ, 1))
			sm_heap_setgroup(oldgroup);
#endif /* SM_HEAP_CHECK */
	}

	BlockOldsh = false;

	/* check the signals didn't happen during the revert */
	if (NoMoreRunners)
	{
		/* Check that a valid signal handler is callable */
		if (Oldsh != SIG_DFL && Oldsh != SIG_IGN &&
		    Oldsh != runners_sighup && Oldsh != runners_sigterm)
			(*Oldsh)(Oldsig);
	}

	Oldsh = SIG_DFL; /* after the NoMoreRunners check */
}
/*
**  RUN_WORK_GROUP -- run the jobs in a queue group from a work group.
d696 2
a697 2
**		wgrp -- work group to process.
**		forkflag -- true if the queue scanning should be done in
d700 1
a700 3
**		verbose -- if true, print out status information.
**		persistent -- persistent queue runner?
**		runall -- true: run all of the queue groups in this work group
d703 1
a703 1
**		true if the queue run successfully began.
d709 3
a711 6
/* Minimum sleep time for persistent queue runners */
#define MIN_SLEEP_TIME	5

bool
run_work_group(wgrp, forkflag, verbose, persistent, runall)
	int wgrp;
a713 2
	bool persistent;
	bool runall;
d716 3
a718 7
	int njobs, qdir;
	int sequenceno = 1;
	int qgrp, endgrp, h, i;
	time_t current_la_time;
	bool full, more;
	SM_RPOOL_T *rpool;
	extern void rmexpstab __P((void));
a719 4
	extern SIGFUNC_DECL reapchild __P((int));

	if (wgrp < 0)
		return false;
d726 1
a726 1
	sm_getla();	/* get load average */
d729 1
a729 1
	if (!persistent && shouldqueue(WkRecipFact, current_la_time))
d736 4
a739 2
			sm_syslog(LOG_INFO, NOQID, "runqueue: %s", msg);
		return false;
d746 1
a746 1
	if (forkflag && WorkGrp[wgrp].wg_lowqintvl > 0 && !persistent &&
d754 2
a755 1
			sm_syslog(LOG_INFO, NOQID, "runqueue: %s (%d)",
d757 1
a757 1
		return false;
d768 2
a769 2
		(void) sm_blocksignal(SIGCHLD);
		(void) sm_signal(SIGCHLD, reapchild);
d775 1
a775 1
			const char *err = sm_errstring(errno);
d780 2
a781 1
				sm_syslog(LOG_INFO, NOQID, "runqueue: %s: %s",
d783 2
a784 2
			(void) sm_releasesignal(SIGCHLD);
			return false;
d789 5
a793 9
			(void) sm_blocksignal(SIGALRM);

			/* wgrp only used when queue runners are persistent */
			proc_list_add(pid, "Queue runner", PROC_QUEUE,
				      WorkGrp[wgrp].wg_maxact,
				      persistent ? wgrp : -1);
			(void) sm_releasesignal(SIGALRM);
			(void) sm_releasesignal(SIGCHLD);
			return true;
a794 1

a795 14

		/* Reset global flags */
		RestartRequest = NULL;
		RestartWorkGroup = false;
		ShutdownRequest = NULL;
		PendingSignal = 0;
		CurrentPid = getpid();

		/*
		**  Initialize exception stack and default exception
		**  handler for child process.
		*/

		sm_exc_newthread(fatal_error);
d800 6
a805 6
		proc_list_add(CurrentPid, "Queue runner child process",
			      PROC_QUEUE_CHILD, 0, -1);
		(void) sm_releasesignal(SIGCHLD);
		(void) sm_signal(SIGCHLD, SIG_DFL);
		(void) sm_signal(SIGHUP, SIG_DFL);
		(void) sm_signal(SIGTERM, intsig);
d808 8
d820 1
d822 1
d825 1
a825 1
	NoConnect = false;
d829 1
a829 1
		(void) drop_privileges(false);
d836 1
a836 2
	rpool = sm_rpool_new_x(NULL);
	e = newenvelope(&QueueEnvelope, CurEnv, rpool);
a837 1
	e->e_parent = NULL;
d843 1
a843 1
		QuickAbort = false;
d854 1
a854 1
		IgnoreHostStatus = true;
a858 58
	**  Here is where we choose the queue group from the work group.
	**  The caller of the "domorework" label must setup a new envelope.
	*/

	endgrp = WorkGrp[wgrp].wg_curqgrp; /* to not spin endlessly */

  domorework:

	/*
	**  Run a queue group if:
	**  runall is set or the bit for this group is set.
	*/

	for (;;)
	{
		/*
		**  Find the next queue group within the work group that
		**  has been marked as needing a run.
		*/

		qgrp = WorkGrp[wgrp].wg_qgs[WorkGrp[wgrp].wg_curqgrp]->qg_index;
		WorkGrp[wgrp].wg_curqgrp++; /* advance */
		WorkGrp[wgrp].wg_curqgrp %= WorkGrp[wgrp].wg_numqgrp; /* wrap */
		if (runall || bitnset(qgrp, DoQueueRun))
			break;
		if (endgrp == WorkGrp[wgrp].wg_curqgrp)
		{
			e->e_id = NULL;
			if (forkflag)
				finis(true, ExitStat);
			return true; /* we're done */
		}
	}

	qdir = Queue[qgrp]->qg_curnum; /* round-robin init of queue position */
#if _FFR_QUEUE_SCHED_DBG
	if (tTd(69, 12))
		sm_syslog(LOG_INFO, NOQID,
			"rwg: wgrp=%d, qgrp=%d, qdir=%d, name=%s, curqgrp=%d, numgrps=%d",
			wgrp, qgrp, qdir, qid_printqueue(qgrp, qdir),
			WorkGrp[wgrp].wg_curqgrp, WorkGrp[wgrp].wg_numqgrp);
#endif /* _FFR_QUEUE_SCHED_DBG */

	/* tweak niceness of queue runs */
	if (Queue[qgrp]->qg_nice > 0)
		(void) nice(Queue[qgrp]->qg_nice);

	/* XXX running queue group... */
	sm_setproctitle(true, CurEnv, "running queue: %s",
			qid_printqueue(qgrp, qdir));

	if (LogLevel > 69 || tTd(63, 99))
		sm_syslog(LOG_DEBUG, NOQID,
			  "runqueue %s, pid=%d, forkflag=%d",
			  qid_printqueue(qgrp, qdir), (int) CurrentPid,
			  forkflag);

	/*
a864 20
	for (i = 0; i < Queue[qgrp]->qg_numqueues; i++)
	{
		h = gatherq(qgrp, qdir, false, &full, &more);
#if SM_CONF_SHM
		if (ShmId != SM_SHM_NO_ID)
			QSHM_ENTRIES(Queue[qgrp]->qg_qpaths[qdir].qp_idx) = h;
#endif /* SM_CONF_SHM */
		/* If there are no more items in this queue advance */
		if (!more)
		{
			/* A round-robin advance */
			qdir++;
			qdir %= Queue[qgrp]->qg_numqueues;
		}

		/* Has the WorkList reached the limit? */
		if (full)
			break; /* don't try to gather more */
	}

d866 1
a866 2
	njobs = sortq(Queue[qgrp]->qg_maxlist);
	Queue[qgrp]->qg_curnum = qdir; /* update */
d869 2
a870 1
	if (!Verbose && bitnset(QD_FORK, Queue[qgrp]->qg_flags))
d872 4
a875 2
		int loop, maxrunners;
		pid_t pid;
d878 3
a880 8
		**  For this WorkQ we want to fork off N children (maxrunners)
		**  at this point. Each child has a copy of WorkQ. Each child
		**  will process every N-th item. The parent will wait for all
		**  of the children to finish before moving on to the next
		**  queue group within the work group. This saves us forking
		**  a new runner-child for each work item.
		**  It's valid for qg_maxqrun == 0 since this may be an
		**  explicit "don't run this queue" setting.
d883 2
a884 6
		maxrunners = Queue[qgrp]->qg_maxqrun;

		/* No need to have more runners then there are jobs */
		if (maxrunners > njobs)
			maxrunners = njobs;
		for (loop = 0; loop < maxrunners; loop++)
d886 2
a887 60
			/*
			**  Since the delivery may happen in a child and the
			**  parent does not wait, the parent may close the
			**  maps thereby removing any shared memory used by
			**  the map.  Therefore, close the maps now so the
			**  child will dynamically open them if necessary.
			*/

			closemaps(false);

			pid = fork();
			if (pid < 0)
			{
				syserr("run_work_group: cannot fork");
				return 0;
			}
			else if (pid > 0)
			{
				/* parent -- clean out connection cache */
				mci_flush(false, NULL);
				WorkQ = WorkQ->w_next; /* for the skip */
				sequenceno++;
				proc_list_add(pid, "Queue child runner process",
					      PROC_QUEUE_CHILD, 0, -1);

				/* No additional work, no additional runners */
				if (WorkQ == NULL)
					break;
			}
			else
			{
				/* Reset global flags */
				RestartRequest = NULL;
				RestartWorkGroup = false;
				ShutdownRequest = NULL;
				PendingSignal = 0;
				CurrentPid = getpid();

				/*
				**  Initialize exception stack and default
				**  exception handler for child process.
				**  When fork()'d the child now has a private
				**  copy of WorkQ at its current position.
				*/

				sm_exc_newthread(fatal_error);
				if (MaxQueueChildren > 0)
				{
					proc_list_clear();
					sm_releasesignal(SIGCHLD);
					(void) sm_signal(SIGCHLD, SIG_DFL);
				}

				/* child -- error messages to the transcript */
				QuickAbort = OnlyOneError = false;
				runner_work(e, sequenceno, true,
					    maxrunners, njobs);
				finis(true, ExitStat); /* This child is done */
				/* NOTREACHED */
			}
d889 1
a889 13

		sm_releasesignal(SIGCHLD);

		/*
		**  Wait until all of the runners have completed before
		**  seeing if there is another queue group in the
		**  work group to process.
		**  XXX Future enhancement: don't wait() for all children
		**  here, just go ahead and make sure that overall the number
		**  of children is not exceeded.
		*/

		while (CurChildren > 0)
d891 1
a891 2
			int status;
			pid_t ret;
d893 7
a899 3
			while ((ret = sm_wait(&status)) <= 0)
				continue;
			(void) proc_list_drop(ret, NULL, NULL);
d901 6
a906 70
	}
	else
	{
		/*
		**  When current process will not fork children to do the work,
		**  it will do the work itself. The 'skip' will be 1 since
		**  there are no child runners to divide the work across.
		*/

		runner_work(e, sequenceno, false, 1, njobs);
	}

	/* free memory allocated by newenvelope() above */
	sm_rpool_free(rpool);
	QueueEnvelope.e_rpool = NULL;

	/* Are there still more queues in the work group to process? */
	if (endgrp != WorkGrp[wgrp].wg_curqgrp)
	{
		rpool = sm_rpool_new_x(NULL);
		e = newenvelope(&QueueEnvelope, CurEnv, rpool);
		e->e_flags = BlankEnvelope.e_flags;
		goto domorework;
	}

	/* No more queues in work group to process. Now check persistent. */
	if (persistent)
	{
		time_t now;

		sequenceno = 1;
		sm_setproctitle(true, CurEnv, "running queue: %s",
				qid_printqueue(qgrp, qdir));

		/*
		**  close bogus maps, i.e., maps which caused a tempfail,
		**	so we get fresh map connections on the next lookup.
		**  closemaps() is also called when children are started.
		*/

		closemaps(true);

		/* Close any cached connections. */
		mci_flush(true, NULL);

		/* Clean out expired related entries. */
		rmexpstab();

#if NAMED_BIND
		/* Update MX records for FallBackMX. */
		if (FallBackMX != NULL)
			(void) getfallbackmxrr(FallBackMX);
#endif /* NAMED_BIND */

#if USERDB
		/* close UserDatabase */
		_udbx_close();
#endif /* USERDB */

#if SM_HEAP_CHECK
		if (sm_debug_active(&SmHeapCheck, 2)
		    && access("memdump", F_OK) == 0
		   )
		{
			SM_FILE_T *out;

			remove("memdump");
			out = sm_io_open(SmFtStdio, SM_TIME_DEFAULT,
					 "memdump.out", SM_IO_APPEND, NULL);
			if (out != NULL)
d908 16
a923 4
				(void) sm_io_fprintf(out, SM_TIME_DEFAULT, "----------------------\n");
				sm_heap_report(out,
					sm_debug_level(&SmHeapCheck) - 1);
				(void) sm_io_close(out, SM_TIME_DEFAULT);
d925 5
a930 7
#endif /* SM_HEAP_CHECK */

		/* let me rest for a second to catch my breath */
		if (njobs == 0 && WorkGrp[wgrp].wg_lowqintvl < MIN_SLEEP_TIME)
			sleep(MIN_SLEEP_TIME);
		else if (WorkGrp[wgrp].wg_lowqintvl <= 0)
			sleep(QueueIntvl > 0 ? QueueIntvl : MIN_SLEEP_TIME);
d932 2
a933 1
			sleep(WorkGrp[wgrp].wg_lowqintvl);
d935 13
a947 8
		/*
		**  Get the LA outside the WorkQ loop if necessary.
		**  In a persistent queue runner the code is repeated over
		**  and over but orderq() may ignore entries due to
		**  shouldqueue() (do we really have to do this twice?).
		**  Hence the queue runners would just idle around when once
		**  CurrentLA caused all entries in a queue to be ignored.
		*/
d949 5
a953 5
		now = curtime();
		if (njobs == 0 && current_la_time < now - GET_NEW_LA_TIME)
		{
			sm_getla();
			current_la_time = now;
d955 4
a958 4
		rpool = sm_rpool_new_x(NULL);
		e = newenvelope(&QueueEnvelope, CurEnv, rpool);
		e->e_flags = BlankEnvelope.e_flags;
		goto domorework;
d964 1
a964 1
		finis(true, ExitStat);
d966 1
a966 1
	return true;
d970 1
a970 1
**  DOQUEUERUN -- do a queue run?
d973 2
a974 2
bool
doqueuerun()
d976 1
a976 1
	return bitnset(NumQueue, DoQueueRun);
d978 2
a979 66

/*
**  RUNQUEUEEVENT -- stub for use in sm_setevent
**
**  Sets the bit to indicate that on the next run this queue should be
**  processed. The work group that the queue group is a member of has its
**  count of queue's to process updated.
**
**	Parameters:
**		qgrp -- the index of the queue group.
**
**	Returns:
**		none.
**
**	Side Effects:
**		The work group that the queue group is a member of has its
**		count of queues to process updated.
**		The invocation of this function via an alarm may interrupt
**		a set of actions. Thus errno may be set in that context.
**		We need to restore errno at the end of this function to ensure
**		that any work done here that sets errno doesn't return a
**		misleading/false errno value. Errno may	be EINTR upon entry to
**		this function because of non-restartable/continuable system
**		API was active. Iff this is true we will override errno as
**		a timeout (as a more accurate error message).
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

void
runqueueevent(qgrp)
	int qgrp;
{
	int i;
	int save_errno = errno;

	/*
	**  Set the general bit that we want a queue run,
	**  tested in doqueuerun()
	*/

	setbitn(NumQueue, DoQueueRun);

	/* if it is a specific group: set that bit */
	if (qgrp != NOQGRP)
	{
		setbitn(qgrp, DoQueueRun);
		goto ret;
	}

	/* for all others: set the bit if it doesn't have a queue interval */
	for (i = 0; i < NumQueue; i++)
	{
		if (Queue[i]->qg_queueintvl <= 0)
			setbitn(i, DoQueueRun);
	}

  ret:
	errno = save_errno;
	if (errno == EINTR)
		errno = ETIMEDOUT;
}
/*
**  GATHERQ -- gather messages from the message queue(s) the work queue.
d982 1
a982 2
**		qgrp -- the index of the queue group.
**		qdir -- the index of the queue directory.
d985 2
a986 5
**			average is too high, or MaxQueueRun is reached).
**			Otherwise, exclude those jobs.
**		full -- (optional) to be set 'true' if WorkList is full
**		more -- (optional) to be set 'true' if there are still more
**			messages in this queue not added to WorkList
d990 1
a990 1
**		the number of requests in WorkList however).
d993 1
a993 1
**		prepares available work into WorkList
d996 8
a1003 9
#define NEED_P		001	/* 'P': priority */
#define NEED_T		002	/* 'T': time */
#define NEED_R		004	/* 'R': recipient */
#define NEED_S		010	/* 'S': sender */
#define NEED_H		020	/* host */

static WORK	*WorkList = NULL;	/* list of unsort work */
static int	WorkListSize = 0;	/* current max size of WorkList */
static int	WorkListCount = 0;	/* # of work items in WorkList */
d1006 2
a1007 3
gatherq(qgrp, qdir, doall, full, more)
	int qgrp;
	int qdir;
a1008 2
	bool *full;
	bool *more;
d1014 3
a1016 2
	int i, num_ent;
	int wn;
d1021 2
a1022 4
	wn = WorkListCount - 1;
	num_ent = 0;
	if (qdir == NOQDIR)
		(void) sm_strlcpy(qd, ".", sizeof qd);
d1024 3
a1026 5
		(void) sm_strlcpyn(qd, sizeof qd, 2,
			Queue[qgrp]->qg_qpaths[qdir].qp_name,
			(bitset(QP_SUBQF,
				Queue[qgrp]->qg_qpaths[qdir].qp_subdirs)
					? "/qf" : ""));
d1030 1
a1030 1
		sm_dprintf("orderq:\n");
d1035 1
a1035 2
			sm_dprintf("\tQueueLimitId = %s%s\n",
				check->queue_negate ? "!" : "",
d1043 1
a1043 2
			sm_dprintf("\tQueueLimitSender = %s%s\n",
				check->queue_negate ? "!" : "",
d1051 1
a1051 2
			sm_dprintf("\tQueueLimitRecipient = %s%s\n",
				check->queue_negate ? "!" : "",
d1057 13
d1074 1
a1074 6
		syserr("orderq: cannot open \"%s\"",
			qid_printqueue(qgrp, qdir));
		if (full != NULL)
			*full = WorkListCount >= MaxQueueRun && MaxQueueRun > 0;
		if (more != NULL)
			*more = false;
d1084 1
a1084 1
		SM_FILE_T *cf;
d1090 1
a1090 1
			sm_dprintf("orderq: checking %s\n", d->d_name);
d1099 2
a1100 3
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "orderq: %s too long, %d max characters\n",
						     d->d_name, MAXQFNAME);
d1111 1
a1111 2
			if (strcontainedin(check->queue_match, d->d_name) !=
			    check->queue_negate)
d1125 1
a1125 1
					  qid_printqueue(qgrp, qdir),
d1127 1
a1127 3
			if (doall)
				continue;	/* just count entries */
			break;
d1131 1
a1131 1
			grow_wlist(qgrp, qdir);
a1134 1
		SM_ASSERT(wn >= 0);
d1137 1
a1137 1
		(void) sm_strlcpyn(qf, sizeof qf, 3, qd, "/", d->d_name);
d1143 1
a1143 2
					  qid_printqueue(qgrp, qdir),
					  d->d_name);
d1150 2
a1151 5
			if (!((d->d_name[0] == 'd' || d->d_name[0] == 'q' ||
			       d->d_name[0] == 'x') &&
			      d->d_name[1] == 'f' && d->d_name[2] == '\0'))
				syserr("orderq: %s/%s is not a regular file",
				       qid_printqueue(qgrp, qdir), d->d_name);
d1157 1
a1157 3
		if ((QueueSortOrder == QSO_BYFILENAME ||
		     QueueSortOrder == QSO_BYMODTIME ||
		     QueueSortOrder == QSO_RANDOM) &&
a1160 2
			w->w_qgrp = qgrp;
			w->w_qdir = qdir;
d1163 1
a1163 1
			w->w_lock = w->w_tooyoung = false;
a1165 2
			w->w_mtime = sbuf.st_mtime;
			++num_ent;
d1170 3
a1172 3
		cf = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, qf, SM_IO_RDONLY,
				NULL);
		if (cf == NULL && OpMode != MD_PRINT)
d1175 1
d1177 2
a1178 2
				sm_dprintf("orderq: cannot open %s: %s\n",
					d->d_name, sm_errstring(errno));
a1182 2
		w->w_qgrp = qgrp;
		w->w_qdir = qdir;
d1185 2
a1186 8
		if (cf != NULL)
		{
			w->w_lock = !lockfile(sm_io_getinfo(cf, SM_IO_WHAT_FD,
							    NULL),
					      w->w_name, NULL,
					      LOCK_SH|LOCK_NB);
		}
		w->w_tooyoung = false;
a1190 1
		w->w_mtime = sbuf.st_mtime;
d1193 2
a1194 6
		i = NEED_P|NEED_T;
		if (QueueSortOrder == QSO_BYHOST
#if _FFR_RHS
		    || QueueSortOrder == QSO_BYSHUFFLE
#endif /* _FFR_RHS */
		   )
d1203 1
a1203 3
		while (cf != NULL && i != 0 &&
		       sm_io_fgets(cf, SM_TIME_DEFAULT, lbuf,
				   sizeof lbuf) != NULL)
d1214 1
a1214 2
				while ((c = sm_io_getc(cf, SM_TIME_DEFAULT))
				       != SM_IO_EOF && c != '\n')
d1238 1
a1238 6
#if _FFR_RHS
					if (QueueSortOrder == QSO_BYSHUFFLE)
						w->w_host = newstr(&p[1]);
					else
#endif /* _FFR_RHS */
						w->w_host = strrev(&p[1]);
d1259 1
a1259 2
							   p) !=
					    check->queue_negate)
d1273 1
a1273 2
							   &lbuf[1]) !=
					    check->queue_negate)
d1286 1
a1286 1
					w->w_tooyoung = true;
d1291 1
a1291 1
					w->w_tooyoung = false;
d1294 1
a1294 1
#if _FFR_QUEUEDELAY
d1303 1
a1303 1
#endif /* _FFR_QUEUEDELAY */
d1306 1
a1306 2
		if (cf != NULL)
			(void) sm_io_close(cf, SM_TIME_DEFAULT);
d1313 4
a1316 4
				sm_dprintf("skipping %s (%x)\n", w->w_name, i);
			sm_free(w->w_name); /* XXX */
			if (w->w_host != NULL)
				sm_free(w->w_host); /* XXX */
a1318 2
		else
			++num_ent;
d1323 2
a1324 59
	i = wn - WorkListCount;
	WorkListCount += SM_MIN(num_ent, WorkListSize);

	if (more != NULL)
		*more = WorkListCount < wn;

	if (full != NULL)
		*full = (wn >= MaxQueueRun && MaxQueueRun > 0) ||
			(WorkList == NULL && wn > 0);

	return i;
}
/*
**  SORTQ -- sort the work list
**
**	First the old WorkQ is cleared away. Then the WorkList is sorted
**	for all items so that important (higher sorting value) items are not
**	trunctated off. Then the most important items are moved from
**	WorkList to WorkQ. The lower count of 'max' or MaxListCount items
**	are moved.
**
**	Parameters:
**		max -- maximum number of items to be placed in WorkQ
**
**	Returns:
**		the number of items in WorkQ
**
**	Side Effects:
**		WorkQ gets released and filled with new work. WorkList
**		gets released. Work items get sorted in order.
*/

static int
sortq(max)
	int max;
{
	register int i;			/* local counter */
	register WORK *w;		/* tmp item pointer */
	int wc = WorkListCount;		/* trim size for WorkQ */

	if (WorkQ != NULL)
	{
		/* Clear out old WorkQ. */
		for (w = WorkQ; w != NULL; )
		{
			register WORK *nw = w->w_next;

			WorkQ = nw;
			sm_free(w->w_name); /* XXX */
			if (w->w_host != NULL)
				sm_free(w->w_host); /* XXX */
			sm_free((char *) w); /* XXX */
			w = nw;
		}
		sm_free((char *) WorkQ);
		WorkQ = NULL;
	}

	if (WorkList == NULL || wc <= 0)
d1326 3
a1328 11

	/* Check if the per queue group item limit will be exceeded */
	if (wc > max && max > 0)
		wc = max;

	/*
	**  The sort now takes place using all of the items in WorkList.
	**  The list gets trimmed to the most important items after the sort.
	**  If the trim were to happen before the sort then one or more
	**  important items might get truncated off -- not what we want.
	*/
d1357 1
a1357 1
					WorkList[i].w_lock = true;
d1360 2
a1361 3
					 sm_strcasecmp(WorkList[i].w_host,
						       w->w_host) == 0)
					WorkList[i].w_lock = true;
a1389 31
	else if (QueueSortOrder == QSO_RANDOM)
	{
		/*
		**  Sort randomly.
		**	workcmpf5() retuns a random 1 or -1.
		**	As long as nobody does a verification pass over the
		**	sorted list, we should be golden.
		*/

		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf5);
	}
	else if (QueueSortOrder == QSO_BYMODTIME)
	{
		/*
		**  Simple sort based on modification time of qf file.
		**  This puts the oldest items first.
		*/

		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf6);
	}
#if _FFR_RHS
	else if (QueueSortOrder == QSO_BYSHUFFLE)
	{
		/*
		**  Simple sort based on shuffled host name.
		*/

		init_shuffle_alphabet();
		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf7);
	}
#endif /* _FFR_RHS */
a1401 2
	**  Only take the most important items up to the per queue group
	**  maximum.
a1406 2
		w->w_qgrp = WorkList[i].w_qgrp;
		w->w_qdir = WorkList[i].w_qdir;
a1412 1
		w->w_mtime = WorkList[i].w_mtime;
d1417 1
a1417 1
		sm_free(WorkList); /* XXX */
a1419 1
	WorkListCount = 0;
d1426 1
a1426 1
				sm_dprintf("%22s: pri=%ld %s\n",
d1429 1
a1429 1
				sm_dprintf("%32s: pri=%ld\n",
d1434 1
a1434 1
	return wc; /* return number of WorkQ items */
d1440 1
a1440 2
**		qgrp -- the index for the queue group.
**		qdir -- the index for the queue directory.
d1452 2
a1453 3
grow_wlist(qgrp, qdir)
	int qgrp;
	int qdir;
d1456 1
a1456 1
		sm_dprintf("grow_wlist: WorkListSize=%d\n", WorkListSize);
d1466 2
a1467 2
		WORK *newlist = (WORK *) sm_realloc((char *) WorkList,
					  (unsigned) sizeof(WORK) * (newsize + 1));
d1477 1
a1477 1
					  qid_printqueue(qgrp, qdir),
d1485 1
a1485 1
				  qid_printqueue(qgrp, qdir), newsize);
d1489 1
a1489 1
		sm_dprintf("grow_wlist: WorkListSize now %d\n", WorkListSize);
d1503 2
d1536 2
d1561 1
a1561 1
	return workcmpf0(a, b);
d1577 2
d1602 1
a1602 1
	return workcmpf0(a, b);
d1616 2
d1644 2
a1655 86
**  WORKCMPF5 -- compare based on assigned random number
**
**	Parameters:
**		a -- the first argument (ignored).
**		b -- the second argument (ignored).
**
**	Returns:
**		randomly 1/-1
*/

/* ARGSUSED0 */
static int
workcmpf5(a, b)
	register WORK *a;
	register WORK *b;
{
	return (get_rand_mod(2)) ? 1 : -1;
}
/*
**  WORKCMPF6 -- simple modification-time-only compare function.
**
**	Parameters:
**		a -- the first argument.
**		b -- the second argument.
**
**	Returns:
**		-1 if a < b
**		 0 if a == b
**		+1 if a > b
**
*/

static int
workcmpf6(a, b)
	register WORK *a;
	register WORK *b;
{
	if (a->w_mtime > b->w_mtime)
		return 1;
	else if (a->w_mtime < b->w_mtime)
		return -1;
	else
		return 0;
}
#if _FFR_RHS
/*
**  WORKCMPF7 -- compare function for ordering work based on shuffled host name.
**
**	Sorts on lock status, host name, and priority in that order.
**
**	Parameters:
**		a -- the first argument.
**		b -- the second argument.
**
**	Returns:
**		<0 if a < b
**		 0 if a == b
**		>0 if a > b
**
*/

static int
workcmpf7(a, b)
	register WORK *a;
	register WORK *b;
{
	int i;

	/* lock status */
	if (a->w_lock != b->w_lock)
		return a->w_lock - b->w_lock;

	/* host name */
	if (a->w_host != NULL && b->w_host == NULL)
		return 1;
	else if (a->w_host == NULL && b->w_host != NULL)
		return -1;
	if (a->w_host != NULL && b->w_host != NULL &&
	    (i = sm_strshufflecmp(a->w_host, b->w_host)) != 0)
		return i;

	/* job priority */
	return workcmpf0(a, b);
}
#endif /* _FFR_RHS */
/*
a1682 59

#if _FFR_RHS

#define NASCII	128
#define NCHAR	256

static unsigned char ShuffledAlphabet[NCHAR];

void
init_shuffle_alphabet()
{
	static bool init = false;
	int i;

	if (init)
		return;

	/* fill the ShuffledAlphabet */
	for (i = 0; i < NCHAR; i++)
		ShuffledAlphabet[i] = i;

	/* mix it */
	for (i = 1; i < NCHAR; i++)
	{
		register int j = get_random() % NCHAR;
		register int tmp;

		tmp = ShuffledAlphabet[j];
		ShuffledAlphabet[j] = ShuffledAlphabet[i];
		ShuffledAlphabet[i] = tmp;
	}

	/* make it case insensitive */
	for (i = 'A'; i <= 'Z'; i++)
		ShuffledAlphabet[i] = ShuffledAlphabet[i + 'a' - 'A'];

	/* fill the upper part */
	for (i = 0; i < NCHAR; i++)
		ShuffledAlphabet[i + NCHAR] = ShuffledAlphabet[i];
	init = true;
}

static int
sm_strshufflecmp(a, b)
	char *a;
	char *b;
{
	const unsigned char *us1 = (const unsigned char *) a;
	const unsigned char *us2 = (const unsigned char *) b;

	while (ShuffledAlphabet[*us1] == ShuffledAlphabet[*us2++])
	{
		if (*us1++ == '\0')
			return 0;
	}
	return (ShuffledAlphabet[*us1] - ShuffledAlphabet[*--us2]);
}
#endif /* _FFR_RHS */

d1687 1
a1687 2
**		qgrp -- the index of the queue group for the job.
**		qdir -- the index of the queue directory for the job.
d1704 2
a1705 3
dowork(qgrp, qdir, id, forkflag, requeueflag, e)
	int qgrp;
	int qdir;
a1711 1
	SM_RPOOL_T *rpool;
d1714 1
a1714 1
		sm_dprintf("dowork(%s/%s)\n", qid_printqueue(qgrp, qdir), id);
d1730 1
a1730 1
		closemaps(false);
d1741 1
a1741 1
			mci_flush(false, NULL);
a1744 19
			/*
			**  Initialize exception stack and default exception
			**  handler for child process.
			*/

			/* Reset global flags */
			RestartRequest = NULL;
			RestartWorkGroup = false;
			ShutdownRequest = NULL;
			PendingSignal = 0;
			CurrentPid = getpid();
			sm_exc_newthread(fatal_error);
			if (MaxQueueChildren > 0)
			{
				proc_list_clear();
				sm_releasesignal(SIGCHLD);
				(void) sm_signal(SIGCHLD, SIG_DFL);
			}

d1746 1
a1746 1
			QuickAbort = OnlyOneError = false;
a1763 9
		if (forkflag)
		{
			/* Reset global flags */
			RestartRequest = NULL;
			RestartWorkGroup = false;
			ShutdownRequest = NULL;
			PendingSignal = 0;
		}

d1765 1
a1765 1
		sm_clear_events();
d1767 1
a1767 2
		rpool = sm_rpool_new_x(NULL);
		clearenvelope(e, false, rpool);
d1772 2
a1773 3
		e->e_qgrp = qgrp;
		e->e_qdir = qdir;
		GrabTo = UseErrorsTo = false;
d1778 1
a1778 1
			set_op_mode(MD_QUEUERUN);
d1780 1
a1780 1
		sm_setproctitle(true, e, "%s from queue", qid_printname(e));
d1782 3
a1784 2
			sm_syslog(LOG_DEBUG, e->e_id, "dowork, pid=%d",
				  (int) CurrentPid);
d1793 1
a1793 1
				sm_dprintf("readqf(%s) failed\n",
d1797 1
a1797 1
				finis(false, EX_OK);
a1798 7
			{
				/* adding this frees 8 bytes */
				clearenvelope(e, false, rpool);

				/* adding this frees 12 bytes */
				sm_rpool_free(rpool);
				e->e_rpool = NULL;
a1799 1
			}
d1803 1
a1803 1
		eatheader(e, requeueflag, true);
d1806 1
a1806 1
			queueup(e, false, false);
d1813 1
a1813 1
			finis(true, ExitStat);
d1815 1
a1815 5
		{
			dropenvelope(e, true, false);
			sm_rpool_free(rpool);
			e->e_rpool = NULL;
		}
d1820 2
a1821 6

/*
**  DOWORKLIST -- process a list of envelopes as work requests
**
**	Similar to dowork(), except that after forking, it processes an
**	envelope and its siblings, treating each envelope as a work request.
d1824 1
a1824 6
**		el -- envelope to be processed including its siblings.
**		forkflag -- if set, run this in background.
**		requeueflag -- if set, reinstantiate the queue quickly.
**			This is used when expanding aliases in the queue.
**			If forkflag is also set, it doesn't wait for the
**			child.
d1827 2
a1828 1
**		process id of process that is running the queue job.
d1831 1
a1831 1
**		The work request is satisfied if possible.
d1834 3
a1836 5
pid_t
doworklist(el, forkflag, requeueflag)
	ENVELOPE *el;
	bool forkflag;
	bool requeueflag;
d1838 12
a1849 5
	register pid_t pid;
	ENVELOPE *ei;

	if (tTd(40, 1))
		sm_dprintf("doworklist()\n");
d1852 1
a1852 1
	**  Fork for work.
d1855 3
a1857 1
	if (forkflag)
d1859 1
a1859 7
		/*
		**  Since the delivery may happen in a child and the
		**  parent does not wait, the parent may close the
		**  maps thereby removing any shared memory used by
		**  the map.  Therefore, close the maps now so the
		**  child will dynamically open them if necessary.
		*/
d1861 8
a1868 183
		closemaps(false);

		pid = fork();
		if (pid < 0)
		{
			syserr("doworklist: cannot fork");
			return 0;
		}
		else if (pid > 0)
		{
			/* parent -- clean out connection cache */
			mci_flush(false, NULL);
		}
		else
		{
			/*
			**  Initialize exception stack and default exception
			**  handler for child process.
			*/

			/* Reset global flags */
			RestartRequest = NULL;
			RestartWorkGroup = false;
			ShutdownRequest = NULL;
			PendingSignal = 0;
			CurrentPid = getpid();
			sm_exc_newthread(fatal_error);
			if (MaxQueueChildren > 0)
			{
				proc_list_clear();
				sm_releasesignal(SIGCHLD);
				(void) sm_signal(SIGCHLD, SIG_DFL);
			}

			/* child -- error messages to the transcript */
			QuickAbort = OnlyOneError = false;
		}
	}
	else
	{
		pid = 0;
	}

	if (pid != 0)
		return pid;

	/*
	**  IN CHILD
	**	Lock the control file to avoid duplicate deliveries.
	**		Then run the file as though we had just read it.
	**	We save an idea of the temporary name so we
	**		can recover on interrupt.
	*/

	if (forkflag)
	{
		/* Reset global flags */
		RestartRequest = NULL;
		RestartWorkGroup = false;
		ShutdownRequest = NULL;
		PendingSignal = 0;
	}

	/* set basic modes, etc. */
	sm_clear_events();
	clearstats();
	GrabTo = UseErrorsTo = false;
	ExitStat = EX_OK;
	if (forkflag)
	{
		disconnect(1, el);
		set_op_mode(MD_QUEUERUN);
	}
	if (LogLevel > 76)
		sm_syslog(LOG_DEBUG, el->e_id, "doworklist, pid=%d",
			  (int) CurrentPid);

	for (ei = el; ei != NULL; ei = ei->e_sibling)
	{
		ENVELOPE e;
		SM_RPOOL_T *rpool;

		if (WILL_BE_QUEUED(ei->e_sendmode))
			continue;

		rpool = sm_rpool_new_x(NULL);
		clearenvelope(&e, true, rpool);
		e.e_flags |= EF_QUEUERUN|EF_GLOBALERRS;
		set_delivery_mode(SM_DELIVER, &e);
		e.e_errormode = EM_MAIL;
		e.e_id = ei->e_id;
		e.e_qgrp = ei->e_qgrp;
		e.e_qdir = ei->e_qdir;
		openxscript(&e);
		sm_setproctitle(true, &e, "%s from queue", qid_printname(&e));

		/* don't use the headers from sendmail.cf... */
		e.e_header = NULL;
		CurEnv = &e;

		/* read the queue control file -- return if locked */
		if (readqf(&e))
		{
			e.e_flags |= EF_INQUEUE;
			eatheader(&e, requeueflag, true);

			if (requeueflag)
				queueup(&e, false, false);

			/* do the delivery */
			sendall(&e, SM_DELIVER);
			dropenvelope(&e, true, false);
		}
		else
		{
			if (tTd(40, 4) && e.e_id != NULL)
				sm_dprintf("readqf(%s) failed\n",
					qid_printname(&e));
		}
		sm_rpool_free(rpool);
		ei->e_id = NULL;
	}

	/* restore CurEnv */
	CurEnv = el;

	/* finish up and exit */
	if (forkflag)
		finis(true, ExitStat);
	return 0;
}
/*
**  READQF -- read queue file and set up environment.
**
**	Parameters:
**		e -- the envelope of the job to run.
**
**	Returns:
**		true if it successfully read the queue file.
**		false otherwise.
**
**	Side Effects:
**		The queue file is returned locked.
*/

static bool
readqf(e)
	register ENVELOPE *e;
{
	register SM_FILE_T *qfp;
	ADDRESS *ctladdr;
	struct stat st, stf;
	char *bp;
	int qfver = 0;
	long hdrsize = 0;
	register char *p;
	char *frcpt = NULL;
	char *orcpt = NULL;
	bool nomore = false;
	bool bogus = false;
	MODE_T qsafe;
	char qf[MAXPATHLEN];
	char buf[MAXLINE];

	/*
	**  Read and process the file.
	*/

	(void) sm_strlcpy(qf, queuename(e, 'q'), sizeof qf);
	qfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, qf, SM_IO_RDWR, NULL);
	if (qfp == NULL)
	{
		int save_errno = errno;

		if (tTd(40, 8))
			sm_dprintf("readqf(%s): sm_io_open failure (%s)\n",
				qf, sm_errstring(errno));
		errno = save_errno;
		if (errno != ENOENT
		    )
			syserr("readqf: no control file %s", qf);
		RELEASE_QUEUE;
		return false;
d1871 1
a1871 2
	if (!lockfile(sm_io_getinfo(qfp, SM_IO_WHAT_FD, NULL), qf, NULL,
		      LOCK_EX|LOCK_NB))
d1875 1
a1875 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "%s: locked\n", e->e_id);
d1877 1
a1877 1
			sm_dprintf("%s: locked\n", e->e_id);
d1880 2
a1881 3
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
		RELEASE_QUEUE;
		return false;
d1885 1
a1885 15
	**  Prevent locking race condition.
	**
	**  Process A: readqf(): qfp = fopen(qffile)
	**  Process B: queueup(): rename(tf, qf)
	**  Process B: unlocks(tf)
	**  Process A: lockfile(qf);
	**
	**  Process A (us) has the old qf file (before the rename deleted
	**  the directory entry) and will be delivering based on old data.
	**  This can lead to multiple deliveries of the same recipients.
	**
	**  Catch this by checking if the underlying qf file has changed
	**  *after* acquiring our lock and if so, act as though the file
	**  was still locked (i.e., just return like the lockfile() case
	**  above.
d1888 1
a1888 2
	if (stat(qf, &stf) < 0 ||
	    fstat(sm_io_getinfo(qfp, SM_IO_WHAT_FD, NULL), &st) < 0)
d1892 4
a1895 28
			sm_dprintf("readqf(%s): [f]stat failure (%s)\n",
				qf, sm_errstring(errno));
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
		RELEASE_QUEUE;
		return false;
	}

	if (st.st_nlink != stf.st_nlink ||
	    st.st_dev != stf.st_dev ||
	    ST_INODE(st) != ST_INODE(stf) ||
#if HAS_ST_GEN && 0		/* AFS returns garbage in st_gen */
	    st.st_gen != stf.st_gen ||
#endif /* HAS_ST_GEN && 0 */
	    st.st_uid != stf.st_uid ||
	    st.st_gid != stf.st_gid ||
	    st.st_size != stf.st_size)
	{
		/* changed after opened */
		if (Verbose)
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "%s: changed\n", e->e_id);
		if (tTd(40, 8))
			sm_dprintf("%s: changed\n", e->e_id);
		if (LogLevel > 19)
			sm_syslog(LOG_DEBUG, e->e_id, "changed");
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
		RELEASE_QUEUE;
		return false;
a1897 4
	/*
	**  Check the queue file for plausibility to avoid attacks.
	*/

d1899 1
d1902 1
d1904 4
a1907 41
	bogus = st.st_uid != geteuid() &&
		st.st_uid != TrustedUid &&
		geteuid() != RealUid;

	/*
	**  If this qf file results from a set-group-ID binary, then
	**  we check whether the directory is group-writable,
	**  the queue file mode contains the group-writable bit, and
	**  the groups are the same.
	**  Notice: this requires that the set-group-ID binary is used to
	**  run the queue!
	*/

	if (bogus && st.st_gid == getegid() && UseMSP)
	{
		char delim;
		struct stat dst;

		bp = SM_LAST_DIR_DELIM(qf);
		if (bp == NULL)
			delim = '\0';
		else
		{
			delim = *bp;
			*bp = '\0';
		}
		if (stat(delim == '\0' ? "." : qf, &dst) < 0)
			syserr("readqf: cannot stat directory %s",
				delim == '\0' ? "." : qf);
		else
		{
			bogus = !(bitset(S_IWGRP, QueueFileMode) &&
				  bitset(S_IWGRP, dst.st_mode) &&
				  dst.st_gid == st.st_gid);
		}
		if (delim != '\0')
			*bp = delim;
	}
	if (!bogus)
		bogus = bitset(qsafe, st.st_mode);
	if (bogus)
d1916 1
a1916 1
			sm_dprintf("readqf(%s): bogus file\n", qf);
d1918 2
a1919 3
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
		RELEASE_QUEUE;
		return false;
d1930 2
a1931 3
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
		RELEASE_QUEUE;
		return false;
d1941 2
a1942 3
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
		RELEASE_QUEUE;
		return false;
a1944 4
	/* If we don't own the file mark it as unsafe */
	if (st.st_uid != geteuid())
		e->e_flags |= EF_UNSAFE;

d1950 1
a1950 1
	macdefine(&e->e_macro, A_PERM, 'i', e->e_id);
d1954 1
a1954 1
	set_op_mode(MD_QUEUERUN);
a1955 6
	e->e_dfqgrp = e->e_qgrp;
	e->e_dfqdir = e->e_qdir;
#if _FFR_QUEUE_MACRO
	macdefine(&e->e_macro, A_TEMP, macid("{queue}"),
		  qid_printqueue(e->e_qgrp, e->e_qdir));
#endif /* _FFR_QUEUE_MACRO */
d1958 1
a1958 1
#if _FFR_QUEUEDELAY
d1961 1
a1961 1
#endif /* _FFR_QUEUEDELAY */
d1964 1
a1964 1
		unsigned long qflags;
d1971 1
a1971 1
			sm_dprintf("+++++ %s\n", bp);
d1976 1
a1976 1
			(void) sm_io_close(qfp, SM_TIME_DEFAULT);
d1978 1
a1978 2
			RELEASE_QUEUE;
			return false;
d1982 9
a1990 7
		  case 'A':		/* AUTH= parameter */
			e->e_auth_param = sm_rpool_strdup_x(e->e_rpool, &bp[1]);
			break;

		  case 'B':		/* body type */
			e->e_bodytype = sm_rpool_strdup_x(e->e_rpool, &bp[1]);
			break;
d1993 1
a1993 1
			ctladdr = setctluser(&bp[1], qfver, e);
d1996 2
a1997 2
		  case 'D':		/* data file name */
			/* obsolete -- ignore */
d2000 4
a2003 1
		  case 'd':		/* data file directory name */
d2005 2
a2006 5
				int qgrp, qdir;

				for (qgrp = 0;
				     qgrp < NumQueue && Queue[qgrp] != NULL;
				     ++qgrp)
d2008 1
a2008 3
					for (qdir = 0;
					     qdir < Queue[qgrp]->qg_numqueues;
					     ++qdir)
d2010 24
a2033 8
						if (strcmp(&bp[1],
							   Queue[qgrp]->qg_qpaths[qdir].qp_name)
						    == 0)
						{
							e->e_dfqgrp = qgrp;
							e->e_dfqdir = qdir;
							goto done;
						}
a2035 5
				loseqfile(e, "bogus queue file directory");
				RELEASE_QUEUE;
				return false;
			  done:
				break;
d2037 14
d2056 4
a2059 17
		  case 'F':		/* flag bits */
			if (strncmp(bp, "From ", 5) == 0)
			{
				/* we are being spoofed! */
				syserr("SECURITY ALERT: bogus qf line %s", bp);
				(void) sm_io_close(qfp, SM_TIME_DEFAULT);
				loseqfile(e, "bogus queue line");
				RELEASE_QUEUE;
				return false;
			}
			for (p = &bp[1]; *p != '\0'; p++)
			{
				switch (*p)
				{
				  case '8':	/* has 8 bit data */
					e->e_flags |= EF_HAS8BIT;
					break;
d2061 4
a2064 3
				  case 'b':	/* delete Bcc: header */
					e->e_flags |= EF_DELETE_BCC;
					break;
d2066 3
a2068 3
				  case 'd':	/* envelope has DSN RET= */
					e->e_flags |= EF_RET_PARAM;
					break;
d2070 3
a2072 11
				  case 'n':	/* don't return body */
					e->e_flags |= EF_NO_BODY_RETN;
					break;

				  case 'r':	/* response */
					e->e_flags |= EF_RESPONSE;
					break;

				  case 's':	/* split */
					e->e_flags |= EF_SPLIT;
					break;
d2074 3
a2076 5
				  case 'w':	/* warning sent */
					e->e_flags |= EF_WARNING;
					break;
				}
			}
d2078 1
d2080 2
a2081 3
#if _FFR_QUEUEDELAY
		  case 'G':		/* queue delay algorithm */
			e->e_queuealg = atoi(&buf[1]);
a2082 1
#endif /* _FFR_QUEUEDELAY */
d2084 2
a2085 3
		  case 'H':		/* header */
			(void) chompheader(&bp[1], CHHDR_QUEUE, NULL, e);
			hdrsize += strlen(&bp[1]);
d2092 1
a2092 1
		  case 'K':		/* time of last delivery attempt */
d2096 6
a2101 3
		  case 'L':		/* Solaris Content-Length: */
		  case 'M':		/* message */
			/* ignore this; we want a new message next time */
d2103 1
d2115 1
a2115 1
				howlong = pintvl(now - e->e_dtime, true);
d2117 2
a2118 4
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "%s: too young (%s)\n",
							     e->e_id, howlong);
d2120 1
a2120 1
					sm_dprintf("%s: too young (%s)\n",
d2128 1
a2128 2
				RELEASE_QUEUE;
				return false;
d2130 1
a2130 2
			macdefine(&e->e_macro, A_TEMP,
				macid("{ntries}"), &buf[1]);
d2132 1
a2132 1
#if NAMED_BIND
d2144 1
a2144 1
#endif /* NAMED_BIND */
d2151 2
a2152 12
		  case 'Q':		/* original recipient */
			orcpt = sm_rpool_strdup_x(e->e_rpool, &bp[1]);
			break;

		  case 'r':		/* original recipient */
			frcpt = sm_rpool_strdup_x(e->e_rpool, &bp[1]);
			break;

		  case 'R':		/* specify recipient */
			p = bp;
			qflags = 0;
			if (qfver >= 1)
d2154 9
a2162 2
				/* get flag bits */
				while (*++p != '\0' && *p != ':')
d2164 3
a2166 5
					switch (*p)
					{
					  case 'N':
						qflags |= QHASNOTIFY;
						break;
d2168 3
a2170 3
					  case 'S':
						qflags |= QPINGONSUCCESS;
						break;
d2172 3
a2174 3
					  case 'F':
						qflags |= QPINGONFAILURE;
						break;
d2176 3
a2178 3
					  case 'D':
						qflags |= QPINGONDELAY;
						break;
d2180 3
a2182 3
					  case 'P':
						qflags |= QPRIMARY;
						break;
d2184 3
a2186 8
					  case 'A':
						if (ctladdr != NULL)
							ctladdr->q_flags |= QALIAS;
						break;

					  default: /* ignore or complain? */
						break;
					}
a2188 16
			else
				qflags |= QPRIMARY;
			q = parseaddr(++p, NULLADDR, RF_COPYALL, '\0', NULL, e,
				      true);
			if (q != NULL)
			{
				q->q_alias = ctladdr;
				if (qfver >= 1)
					q->q_flags &= ~Q_PINGFLAGS;
				q->q_flags |= qflags;
				q->q_finalrcpt = frcpt;
				q->q_orcpt = orcpt;
				(void) recipient(q, &e->e_sendqueue, 0, e);
			}
			frcpt = NULL;
			orcpt = NULL;
d2191 3
a2193 3
		  case 'S':		/* sender */
			setsender(sm_rpool_strdup_x(e->e_rpool, &bp[1]),
				  e, NULL, '\0', true);
d2196 2
a2197 31
		  case 'T':		/* init time */
			e->e_ctime = atol(&bp[1]);
			break;

		  case 'V':		/* queue file version number */
			qfver = atoi(&bp[1]);
			if (queuedelay_qfver_unsupported(qfver))
				syserr("qf version %d not supported: %s",
				       qfver,
				       "sendmail not compiled with _FFR_QUEUEDELAY");
			if (qfver <= QF_VERSION)
				break;
			syserr("Version number in qf (%d) greater than max (%d)",
				qfver, QF_VERSION);
			(void) sm_io_close(qfp, SM_TIME_DEFAULT);
			loseqfile(e, "unsupported qf file version");
			RELEASE_QUEUE;
			return false;
			/* NOTREACHED */
			break;

#if _FFR_QUEUEDELAY
		  case 'Y':		/* current delay */
			e->e_queuedelay = (time_t) atol(&buf[1]);
			break;
#endif /* _FFR_QUEUEDELAY */

		  case 'Z':		/* original envelope id from ESMTP */
			e->e_envid = sm_rpool_strdup_x(e->e_rpool, &bp[1]);
			macdefine(&e->e_macro, A_PERM,
				macid("{dsn_envid}"), e->e_envid);
a2199 6
		  case '!':		/* deliver by */

			/* format: flag (1 char) space long-integer */
			e->e_dlvr_flag = buf[1];
			e->e_deliver_by = strtol(&buf[3], NULL, 10);

d2204 1
a2204 2
				/* XXX elimate p? */
				mid = macid_parse(&bp[1], &ep);
d2207 22
a2228 2
				p = sm_rpool_strdup_x(e->e_rpool, ep);
				macdefine(&e->e_macro, A_PERM, mid, p);
d2233 1
a2233 1
			nomore = true;
d2239 1
a2239 1
			(void) sm_io_close(qfp, SM_TIME_DEFAULT);
d2241 1
a2241 2
			RELEASE_QUEUE;
			return false;
d2245 1
a2245 1
			sm_free(bp); /* XXX */
d2256 2
a2257 3
		e->e_flags |= EF_CLRQUEUE|EF_FATALERRS|EF_RESPONSE;
		RELEASE_QUEUE;
		return true;
d2264 1
a2264 2
			macdefine(&e->e_macro, A_PERM,
				macid("{dsn_ret}"), "hdrs");
d2266 1
a2266 2
			macdefine(&e->e_macro, A_PERM,
				macid("{dsn_ret}"), "full");
d2274 1
a2274 2
	e->e_dfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, p, SM_IO_RDONLY,
			      NULL);
d2282 1
a2282 2
		if (fstat(sm_io_getinfo(e->e_dfp, SM_IO_WHAT_FD, NULL), &st)
		    >= 0)
d2286 1
a2286 1
			e->e_dfino = ST_INODE(st);
d2290 1
a2290 2
	RELEASE_QUEUE;
	return true;
d2300 1
a2300 1
**		number of entries
d2321 2
a2322 2
				(void) sm_io_putc(smioout, SM_TIME_DEFAULT, c);
				(void) sm_io_putc(smioout, SM_TIME_DEFAULT, c);
d2326 1
a2326 1
			(void) sm_io_putc(smioout, SM_TIME_DEFAULT, c);
d2330 1
a2330 73
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "\\%03o", c & 0xFF);
		}
	}
}
/*
**  PRINTNQE -- print out number of entries in the mail queue
**
**	Parameters:
**		out -- output file pointer.
**		prefix -- string to output in front of each line.
**
**	Returns:
**		none.
*/

void
printnqe(out, prefix)
	SM_FILE_T *out;
	char *prefix;
{
#if SM_CONF_SHM
	int i, k = 0, nrequests = 0;
	bool unknown = false;

	if (ShmId == SM_SHM_NO_ID)
	{
		if (prefix == NULL)
			(void) sm_io_fprintf(out, SM_TIME_DEFAULT,
					"Data unavailable: shared memory not updated\n");
		else
			(void) sm_io_fprintf(out, SM_TIME_DEFAULT,
					"%sNOTCONFIGURED:-1\r\n", prefix);
		return;
	}
	for (i = 0; i < NumQueue && Queue[i] != NULL; i++)
	{
		int j;

		k++;
		for (j = 0; j < Queue[i]->qg_numqueues; j++)
		{
			int n;

			if (StopRequest)
				stop_sendmail();

			n = QSHM_ENTRIES(Queue[i]->qg_qpaths[j].qp_idx);
			if (prefix != NULL)
				(void) sm_io_fprintf(out, SM_TIME_DEFAULT,
					"%s%s:%d\r\n",
					prefix, qid_printqueue(i, j), n);
			else if (n < 0)
			{
				(void) sm_io_fprintf(out, SM_TIME_DEFAULT,
					"%s: unknown number of entries\n",
					qid_printqueue(i, j));
				unknown = true;
			}
			else if (n == 0)
			{
				(void) sm_io_fprintf(out, SM_TIME_DEFAULT,
					"%s is empty\n",
					qid_printqueue(i, j));
			}
			else if (n > 0)
			{
				(void) sm_io_fprintf(out, SM_TIME_DEFAULT,
					"%s: entries=%d\n",
					qid_printqueue(i, j), n);
				nrequests += n;
				k++;
			}
a2332 12
	if (prefix == NULL && k > 1)
		(void) sm_io_fprintf(out, SM_TIME_DEFAULT,
				     "\t\tTotal requests: %d%s\n",
				     nrequests, unknown ? " (about)" : "");
#else /* SM_CONF_SHM */
	if (prefix == NULL)
		(void) sm_io_fprintf(out, SM_TIME_DEFAULT,
			     "Data unavailable without shared memory support\n");
	else
		(void) sm_io_fprintf(out, SM_TIME_DEFAULT,
			     "%sNOTAVAILABLE:-1\r\n", prefix);
#endif /* SM_CONF_SHM */
d2350 1
a2350 5
	int i, k = 0, nrequests = 0;

	for (i = 0; i < NumQueue && Queue[i] != NULL; i++)
	{
		int j;
d2352 4
a2355 13
		k++;
		for (j = 0; j < Queue[i]->qg_numqueues; j++)
		{
			if (StopRequest)
				stop_sendmail();
			nrequests += print_single_queue(i, j);
			k++;
		}
	}
	if (k > 1)
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "\t\tTotal requests: %d\n",
				     nrequests);
d2361 1
a2361 2
**		qgrp -- the index of the queue group.
**		qdir -- the queue directory.
d2364 1
a2364 1
**		none.
d2371 2
a2372 3
print_single_queue(qgrp, qdir)
	int qgrp;
	int qdir;
d2375 1
a2375 1
	SM_FILE_T *f;
d2381 1
a2381 1
	if (qdir == NOQDIR)
d2383 2
a2384 2
		(void) sm_strlcpy(qd, ".", sizeof qd);
		(void) sm_strlcpy(qddf, ".", sizeof qddf);
d2388 6
a2393 10
		(void) sm_strlcpyn(qd, sizeof qd, 2,
			Queue[qgrp]->qg_qpaths[qdir].qp_name,
			(bitset(QP_SUBQF,
				Queue[qgrp]->qg_qpaths[qdir].qp_subdirs)
					? "/qf" : ""));
		(void) sm_strlcpyn(qddf, sizeof qddf, 2,
			Queue[qgrp]->qg_qpaths[qdir].qp_name,
			(bitset(QP_SUBDF,
				Queue[qgrp]->qg_qpaths[qdir].qp_subdirs)
					? "/df" : ""));
d2403 1
a2403 1
#ifdef NGROUPS_MAX
d2406 1
a2406 1
#endif /* NGROUPS_MAX */
d2410 1
a2410 2
			syserr("Cannot stat %s",
				qid_printqueue(qgrp, qdir));
d2413 1
a2413 1
#ifdef NGROUPS_MAX
d2421 1
a2421 1
#else /* NGROUPS_MAX */
d2423 1
a2423 1
#endif /* NGROUPS_MAX */
d2435 1
a2435 2
	nrequests = gatherq(qgrp, qdir, true, NULL, NULL);
	(void) sortq(Queue[qgrp]->qg_maxlist);
d2444 1
a2444 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s is empty\n",
				     qid_printqueue(qgrp, qdir));
d2448 1
a2448 1
	sm_getla();	/* get load average */
d2450 2
a2451 3
	(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "\t\t%s (%d request%s",
			     qid_printqueue(qgrp, qdir),
			     nrequests, nrequests == 1 ? "" : "s");
d2453 1
a2453 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     ", only %d printed", MaxQueueRun);
d2455 1
a2455 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
			")\n-----Q-ID----- --Size-- -Priority- ---Q-Time--- --------Sender/Recipient--------\n");
d2457 1
a2457 2
		(void) sm_io_fprintf(smioout,  SM_TIME_DEFAULT,
			")\n-----Q-ID----- --Size-- -----Q-Time----- ------------Sender/Recipient-----------\n");
d2469 3
a2471 8
		if (StopRequest)
			stop_sendmail();

		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%13s",
				     w->w_name + 2);
		(void) sm_strlcpyn(qf, sizeof qf, 3, qd, "/", w->w_name);
		f = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, qf, SM_IO_RDONLY,
			       NULL);
d2474 1
a2474 10
			if (errno == EPERM)
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     " (permission denied)\n");
			else if (errno == ENOENT)
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     " (job completed)\n");
			else
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     " (%s)\n",
						     sm_errstring(errno));
d2479 1
a2479 1
		(void) sm_strlcpyn(qf, sizeof qf, 3, qddf, "/", w->w_name);
a2482 13
		{
			ENVELOPE e;

			/*
			**  Maybe the df file can't be statted because
			**  it is in a different directory than the qf file.
			**  In order to find out, we must read the qf file.
			*/

			newenvelope(&e, &BlankEnvelope, sm_rpool_new_x(NULL));
			e.e_id = w->w_name + 2;
			e.e_qgrp = qgrp;
			e.e_qdir = qdir;
a2483 14
			if (readqf(&e))
			{
				char *df = queuename(&e, 'd');
				if (stat(df, &st) >= 0)
					dfsize = st.st_size;
			}
			if (e.e_lockfp != NULL)
			{
				(void) sm_io_close(e.e_lockfp, SM_TIME_DEFAULT);
				e.e_lockfp = NULL;
			}
			clearenvelope(&e, false, e.e_rpool);
			sm_rpool_free(e.e_rpool);
		}
d2485 1
a2485 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "*");
d2487 1
a2487 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "-");
d2489 1
a2489 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "X");
d2491 1
a2491 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, " ");

d2496 1
a2496 1
		while (sm_io_fgets(f, SM_TIME_DEFAULT, buf, sizeof buf) != NULL)
d2501 1
a2501 4
			if (StopRequest)
				stop_sendmail();

			fixcrlf(buf, true);
d2525 5
a2529 8
					(void) sm_io_fprintf(smioout,
						SM_TIME_DEFAULT,
						"%8ld %10ld%c%.12s ",
						dfsize,
						w->w_pri,
						bitset(EF_WARNING, flags)
							? '+' : ' ',
						ctime(&submittime) + 4);
d2534 3
a2536 6
					(void) sm_io_fprintf(smioout,
						SM_TIME_DEFAULT,
						"%8ld %.16s ",
						dfsize,
						ctime(&submittime));
					prtstr(&buf[1], 39);
d2540 1
a2540 4
					(void) sm_io_fprintf(smioout,
						SM_TIME_DEFAULT,
						"\n    %10.10s",
						bodytype);
d2542 3
a2544 6
						(void) sm_io_fprintf(smioout,
							SM_TIME_DEFAULT,
							"   (%.*s)",
							Verbose ? 100 : 60,
							statmsg);
					statmsg[0] = '\0';
d2550 2
a2551 4
					(void) sm_io_fprintf(smioout,
						SM_TIME_DEFAULT,
						"\n\t\t\t\t\t\t(---%.64s---)",
						&buf[1]);
d2565 2
a2566 4
					(void) sm_io_fprintf(smioout,
							SM_TIME_DEFAULT,
							"\n\t\t\t\t\t\t");
					prtstr(p, 71);
d2570 2
a2571 12
					(void) sm_io_fprintf(smioout,
							SM_TIME_DEFAULT,
							"\n\t\t\t\t\t ");
					prtstr(p, 38);
				}
				if (Verbose && statmsg[0] != '\0')
				{
					(void) sm_io_fprintf(smioout,
							SM_TIME_DEFAULT,
							"\n\t\t (%.100s)",
							statmsg);
					statmsg[0] = '\0';
d2592 3
a2594 4
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     " (no control file)");
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "\n");
		(void) sm_io_close(f, SM_TIME_DEFAULT);
d2620 1
a2620 3
	int qd, qg;
	char *sub = "/";
	char pref[3];
d2627 7
a2633 56
	/* begin of filename */
	pref[0] = (char) type;
	pref[1] = 'f';
	pref[2] = '\0';

	/* Assign a queue group/directory if needed */
	if (type ==  'x')
	{
		/*
		**  We don't want to call setnewqueue() if we are fetching
		**  the pathname of the transcript file, because setnewqueue
		**  chooses a queue, and sometimes we need to write to the
		**  transcript file before we have gathered enough information
		**  to choose a queue.
		*/

		if (e->e_xfqgrp == NOQGRP || e->e_xfqdir == NOQDIR)
		{
			if (e->e_qgrp != NOQGRP && e->e_qdir != NOQDIR)
			{
				e->e_xfqgrp = e->e_qgrp;
				e->e_xfqdir = e->e_qdir;
			}
			else
			{
				e->e_xfqgrp = 0;
				if (Queue[e->e_xfqgrp]->qg_numqueues <= 1)
					e->e_xfqdir = 0;
				else
				{
					e->e_xfqdir = get_rand_mod(
					      Queue[e->e_xfqgrp]->qg_numqueues);
				}
			}
		}
		qd = e->e_xfqdir;
		qg = e->e_xfqgrp;
	}
	else
	{
		if (e->e_qgrp == NOQGRP || e->e_qdir == NOQDIR)
			setnewqueue(e);
		if (type ==  'd')
		{
			qd = e->e_dfqdir;
			qg = e->e_dfqgrp;
		}
		else
		{
			qd = e->e_qdir;
			qg = e->e_qgrp;
		}
	}

	if (e->e_qdir == NOQDIR)
		(void) sm_strlcpyn(buf, sizeof buf, 2, pref, e->e_id);
d2639 2
a2640 2
			if (bitset(QP_SUBDF, Queue[qg]->qg_qpaths[qd].qp_subdirs))
				sub = "/df/";
d2647 2
a2648 2
			if (bitset(QP_SUBQF, Queue[qg]->qg_qpaths[qd].qp_subdirs))
				sub = "/qf/";
d2652 2
a2653 2
			if (bitset(QP_SUBXF, Queue[qg]->qg_qpaths[qd].qp_subdirs))
				sub = "/xf/";
a2654 3

		  default:
			sm_abort("queuename: bad queue file type %d", type);
d2657 3
a2659 3
		(void) sm_strlcpyn(buf, sizeof buf, 4,
				Queue[qg]->qg_qpaths[qd].qp_name,
				sub, pref, e->e_id);
d2663 1
a2663 1
		sm_dprintf("queuename: %s\n", buf);
d2672 2
a2673 2
**	name do not already exist in the queue.
**	[No longer initializes e_qdir to NOQDIR.]
d2682 1
a2682 4
static const char QueueIdChars[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwx";
# define QIC_LEN	60
# define queuenextid() CurrentPid

d2688 2
a2689 2
	pid_t pid = queuenextid();
	static int cX = 0;
a2692 1
	int seq;
d2698 1
a2698 2
	if (cX >= QIC_LEN * QIC_LEN || LastQueueTime == 0 ||
	    LastQueuePid != pid)
d2711 1
a2711 1
		LastQueuePid = queuenextid();
a2713 10

	/*
	**  Generate a new sequence number between 0 and QIC_LEN*QIC_LEN-1.
	**  This lets us generate up to QIC_LEN*QIC_LEN unique queue ids
	**  per second, per process.  With envelope splitting,
	**  a single message can consume many queue ids.
	*/

	seq = (int)((cX + random_offset) % (QIC_LEN * QIC_LEN));
	++cX;
d2715 2
a2716 2
		sm_dprintf("assign_queueid: random_offset = %ld (%d)\n",
			random_offset, seq);
d2719 12
a2730 18
	idbuf[0] = QueueIdChars[tm->tm_year % QIC_LEN];
	idbuf[1] = QueueIdChars[tm->tm_mon];
	idbuf[2] = QueueIdChars[tm->tm_mday];
	idbuf[3] = QueueIdChars[tm->tm_hour];
	idbuf[4] = QueueIdChars[tm->tm_min];
	idbuf[5] = QueueIdChars[tm->tm_sec];
	idbuf[6] = QueueIdChars[seq / QIC_LEN];
	idbuf[7] = QueueIdChars[seq % QIC_LEN];
	(void) sm_snprintf(&idbuf[8], sizeof idbuf - 8, "%06d",
			   (int) LastQueuePid);
	e->e_id = sm_rpool_strdup_x(e->e_rpool, idbuf);
	macdefine(&e->e_macro, A_PERM, 'i', e->e_id);
#if 0
	/* XXX: inherited from MainEnvelope */
	e->e_qgrp = NOQGRP;  /* too early to do anything else */
	e->e_qdir = NOQDIR;
	e->e_xfqgrp = NOQGRP;
#endif /* 0 */
d2732 2
a2733 2
		sm_dprintf("assign_queueid: assigned id %s, e=%p\n",
			e->e_id, e);
a2751 1

d2755 1
a2755 1
#if FAST_PID_RECYCLE
d2759 1
a2759 1
	    LastQueuePid == CurrentPid &&
d2762 1
a2762 1
#endif /* FAST_PID_RECYCLE */
d2782 1
a2782 1
		sm_dprintf("unlockqueue(%s)\n",
d2788 1
a2788 1
		(void) sm_io_close(e->e_lockfp, SM_TIME_DEFAULT);
d2799 2
a2800 1
		(void) xunlink(queuename(e, 'x'));
a2810 1
**		e -- envelope
d2813 1
a2813 2
**		An address descriptor for the controlling user,
**		using storage allocated from e->e_rpool.
d2815 2
d2820 1
a2820 1
setctluser(user, qfver, e)
a2822 1
	ENVELOPE *e;
d2839 1
a2839 1
	a = (ADDRESS *) sm_rpool_malloc_x(e->e_rpool, sizeof *a);
d2842 6
a2847 1
	if (*user == ':')
d2850 1
a2850 1
		a->q_user = sm_rpool_strdup_x(e->e_rpool, p);
d2855 1
a2855 1
		a->q_user = sm_rpool_strdup_x(e->e_rpool, user);
a2862 3
			{
				char *o;

a2863 5

				/* if there is another ':': restore it */
				if ((o = strtok(NULL, ":")) != NULL && o > p)
					o[-1] = ':';
			}
d2872 1
a2872 1
				a->q_home = sm_rpool_strdup_x(e->e_rpool, pw->pw_dir);
d2882 1
a2882 1
		a->q_paddr = sm_rpool_strdup_x(e->e_rpool, a->q_user);
d2884 1
a2884 1
		a->q_paddr = sm_rpool_strdup_x(e->e_rpool, p);
d2909 1
a2909 1
	if (sm_strlcpy(buf, p, sizeof buf) >= sizeof buf)
d2911 1
a2911 2
	if (!bitset(EF_INQUEUE, e->e_flags))
		queueup(e, false, true);
a2917 28
	if (e->e_dfp != NULL)
	{
		(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT);
		e->e_dfp = NULL;
	}
	e->e_flags &= ~EF_HAS_DF;
}
/*
**  NAME2QID -- translate a queue group name to a queue group id
**
**	Parameters:
**		queuename -- name of queue group.
**
**	Returns:
**		queue group id if found.
**		NOQGRP otherwise.
*/

int
name2qid(queuename)
	char *queuename;
{
	register STAB *s;

	s = stab(queuename, ST_QUEUE, ST_FIND);
	if (s == NULL)
		return NOQGRP;
	return s->s_quegrp->qg_index;
d2944 1
a2944 1
	if (e->e_qdir == NOQDIR)
d2947 2
a2948 3
	(void) sm_snprintf(idbuf, sizeof idbuf, "%.32s/%s",
			   Queue[e->e_qgrp]->qg_qpaths[e->e_qdir].qp_name,
			   id);
d2955 1
a2955 2
**		qgrp -- index in queue group.
**		qdir -- the short version of the queue directory
d2958 1
a2958 1
**		the full pathname to the queue (might point to a static var)
d2962 2
a2963 3
qid_printqueue(qgrp, qdir)
	int qgrp;
	int qdir;
d2968 2
a2969 2
	if (qdir == NOQDIR)
		return Queue[qgrp]->qg_qdir;
d2971 1
a2971 1
	if (strcmp(Queue[qgrp]->qg_qpaths[qdir].qp_name, ".") == 0)
d2974 1
a2974 1
		subdir = Queue[qgrp]->qg_qpaths[qdir].qp_name;
d2976 1
a2976 2
	(void) sm_strlcpyn(dir, sizeof dir, 4,
			Queue[qgrp]->qg_qdir,
d2979 1
a2979 3
			(bitset(QP_SUBDF,
				Queue[qgrp]->qg_qpaths[qdir].qp_subdirs)
					? "/df" : ""));
d2982 2
a2983 3

/*
**  PICKQDIR -- Pick a queue directory from a queue group
d2985 2
a2986 91
**	Parameters:
**		qg -- queue group
**		fsize -- file size in bytes
**		e -- envelope, or NULL
**
**	Result:
**		NOQDIR if no queue directory in qg has enough free space to
**		hold a file of size 'fsize', otherwise the index of
**		a randomly selected queue directory which resides on a
**		file system with enough disk space.
**		XXX This could be extended to select a queuedir with
**			a few (the fewest?) number of entries. That data
**			is available if shared memory is used.
**
**	Side Effects:
**		If the request fails and e != NULL then sm_syslog is called.
*/

int
pickqdir(qg, fsize, e)
	QUEUEGRP *qg;
	long fsize;
	ENVELOPE *e;
{
	int qdir;
	int i;
	long avail = 0;

	/* Pick a random directory, as a starting point. */
	if (qg->qg_numqueues <= 1)
		qdir = 0;
	else
		qdir = get_rand_mod(qg->qg_numqueues);

	if (MinBlocksFree <= 0 && fsize <= 0)
		return qdir;

	/*
	**  Now iterate over the queue directories,
	**  looking for a directory with enough space for this message.
	*/

	i = qdir;
	do
	{
		QPATHS *qp = &qg->qg_qpaths[i];
		long needed = 0;
		long fsavail = 0;

		if (fsize > 0)
			needed += fsize / FILE_SYS_BLKSIZE(qp->qp_fsysidx)
				  + ((fsize % FILE_SYS_BLKSIZE(qp->qp_fsysidx)
				      > 0) ? 1 : 0);
		if (MinBlocksFree > 0)
			needed += MinBlocksFree;
		fsavail = FILE_SYS_AVAIL(qp->qp_fsysidx);
#if SM_CONF_SHM
		if (fsavail <= 0)
		{
			long blksize;

			/*
			**  might be not correctly updated,
			**  let's try to get the info directly.
			*/

			fsavail = freediskspace(FILE_SYS_NAME(qp->qp_fsysidx),
						&blksize);
			if (fsavail < 0)
				fsavail = 0;
		}
#endif /* SM_CONF_SHM */
		if (needed <= fsavail)
			return i;
		if (avail < fsavail)
			avail = fsavail;

		if (qg->qg_numqueues > 0)
			i = (i + 1) % qg->qg_numqueues;
	} while (i != qdir);

	if (e != NULL && LogLevel > 0)
		sm_syslog(LOG_ALERT, e->e_id,
			"low on space (%s needs %ld bytes + %ld blocks in %s), max avail: %ld",
			CurHostName == NULL ? "SMTP-DAEMON" : CurHostName,
			fsize, MinBlocksFree,
			qg->qg_qdir, avail);
	return NOQDIR;
}
/*
**  SETNEWQUEUE -- Sets a new queue group and directory
d2988 3
a2990 2
**	Assign a queue group and directory to an envelope and store the
**	directory in e->e_qdir.
d2996 1
a2996 8
**		true if successful
**		false otherwise
**
**	Side Effects:
**		On success, e->e_qgrp and e->e_qdir are non-negative.
**		On failure (not enough disk space),
**		e->qgrp = NOQGRP, e->e_qdir = NOQDIR
**		and usrerr() is invoked (which could raise an exception).
d2999 1
a2999 1
bool
d3003 2
d3006 1
a3006 1
		sm_dprintf("setnewqueue: called\n");
d3008 1
a3008 2
	/* not set somewhere else */
	if (e->e_qgrp == NOQGRP)
d3010 4
a3013 18
		/*
		**  Use the queue group of the first recipient, as set by
		**  the "queuegroup" rule set.  If that is not defined, then
		**  use the queue group of the mailer of the first recipient.
		**  If that is not defined either, then use the default
		**  queue group.
		*/

		if (e->e_sendqueue == NULL)
			e->e_qgrp = 0;
		else if (e->e_sendqueue->q_qgrp >= 0)
			e->e_qgrp = e->e_sendqueue->q_qgrp;
		else if (e->e_sendqueue->q_mailer != NULL &&
			 ISVALIDQGRP(e->e_sendqueue->q_mailer->m_qgrp))
			e->e_qgrp = e->e_sendqueue->q_mailer->m_qgrp;
		else
			e->e_qgrp = 0;
		e->e_dfqgrp = e->e_qgrp;
d3016 3
a3018 1
	if (ISVALIDQDIR(e->e_qdir) && ISVALIDQDIR(e->e_dfqdir))
d3020 9
a3028 15
		if (tTd(41, 20))
			sm_dprintf("setnewqueue: e_qdir already assigned (%s)\n",
				qid_printqueue(e->e_qgrp, e->e_qdir));
		return true;
	}

	filesys_update();
	e->e_qdir = pickqdir(Queue[e->e_qgrp], e->e_msgsize, e);
	if (e->e_qdir == NOQDIR)
	{
		e->e_qgrp = NOQGRP;
		if (!bitset(EF_FATALERRS, e->e_flags))
			usrerr("452 4.4.5 Insufficient disk space; try again later");
		e->e_flags |= EF_FATALERRS;
		return false;
d3031 1
d3033 3
a3035 2
		sm_dprintf("setnewqueue: Assigned queue directory %s\n",
			qid_printqueue(e->e_qgrp, e->e_qdir));
a3036 8
	if (e->e_xfqgrp == NOQGRP || e->e_xfqdir == NOQDIR)
	{
		e->e_xfqgrp = e->e_qgrp;
		e->e_xfqdir = e->e_qdir;
	}
	e->e_dfqdir = e->e_qdir;
	return true;
}
d3058 3
a3060 3
	    (name[1] == '\0' || (name[1] == '.' && name[2] == '\0')))
		return false;
#if HASLSTAT
d3062 1
a3062 1
#else /* HASLSTAT */
d3064 1
a3064 1
#endif /* HASLSTAT */
d3067 3
a3069 3
			sm_dprintf("chkqdir: stat(\"%s\"): %s\n",
				   name, sm_errstring(errno));
		return false;
d3071 1
a3071 1
#if HASLSTAT
a3077 1

d3081 3
a3083 3
				sm_dprintf("chkqdir: stat(\"%s\"): %s\n",
					   name, sm_errstring(errno));
			return false;
d3086 1
a3086 1
#endif /* HASLSTAT */
d3091 1
a3091 1
			sm_dprintf("chkqdir: \"%s\": Not a directory\n",
d3093 1
a3093 1
		return false;
a3096 1
	/* XXX do this only if we want the warning? */
d3099 3
a3101 3
		sm_dprintf("chkqdir: \"%s\": Not safe: %s\n",
			   name, sm_errstring(i));
	return true;
d3103 1
d3113 1
a3113 8
**		basedir -- base of all queue directories.
**		blen -- strlen(basedir).
**		qg -- queue group.
**		qn -- number of queue directories already cached.
**		phash -- pointer to hash value over queue dirs.
#if SM_CONF_SHM
**			only used if shared memory is active.
#endif * SM_CONF_SHM *
d3116 1
a3116 1
**		new number of queue directories.
d3119 5
a3123 11
#define INITIAL_SLOTS	20
#define ADD_SLOTS	10

static int
multiqueue_cache(basedir, blen, qg, qn, phash)
	char *basedir;
	int blen;
	QUEUEGRP *qg;
	int qn;
	unsigned int *phash;
{
a3129 1
	char prefix[MAXPATHLEN];	/* dir relative to basedir */
d3132 1
a3132 1
		sm_dprintf("multiqueue_cache: called\n");
d3134 1
a3134 4
	/* Initialize to current directory */
	prefix[0] = '.';
	prefix[1] = '\0';
	if (qg->qg_numqueues != 0 && qg->qg_qpaths != NULL)
d3136 1
a3136 1
		for (i = 0; i < qg->qg_numqueues; i++)
d3138 2
a3139 2
			if (qg->qg_qpaths[i].qp_name != NULL)
				(void) sm_free(qg->qg_qpaths[i].qp_name); /* XXX */
d3141 3
a3143 3
		(void) sm_free((char *) qg->qg_qpaths); /* XXX */
		qg->qg_qpaths = NULL;
		qg->qg_numqueues = 0;
d3150 3
a3152 53
	if (!SM_IS_DIR_START(qg->qg_qdir))
	{
		/*
		**  XXX we could add basedir, but then we have to realloc()
		**  the string... Maybe another time.
		*/

		syserr("QueuePath %s not absolute", qg->qg_qdir);
		ExitStat = EX_CONFIG;
		return qn;
	}

	/* qpath: directory of current workgroup */
	len = sm_strlcpy(qpath, qg->qg_qdir, sizeof qpath);
	if (len >= sizeof qpath)
	{
		syserr("QueuePath %.256s too long (%d max)",
		       qg->qg_qdir, (int) sizeof qpath);
		ExitStat = EX_CONFIG;
		return qn;
	}

	/* begin of qpath must be same as basedir */
	if (strncmp(basedir, qpath, blen) != 0 &&
	    (strncmp(basedir, qpath, blen - 1) != 0 || len != blen - 1))
	{
		syserr("QueuePath %s not subpath of QueueDirectory %s",
			qpath, basedir);
		ExitStat = EX_CONFIG;
		return qn;
	}

	/* Do we have a nested subdirectory? */
	if (blen < len && SM_FIRST_DIR_DELIM(qg->qg_qdir + blen) != NULL)
	{

		/* Copy subdirectory into prefix for later use */
		if (sm_strlcpy(prefix, qg->qg_qdir + blen, sizeof prefix) >=
		    sizeof prefix)
		{
			syserr("QueuePath %.256s too long (%d max)",
				qg->qg_qdir, (int) sizeof qpath);
			ExitStat = EX_CONFIG;
			return qn;
		}
		cp = SM_LAST_DIR_DELIM(prefix);
		SM_ASSERT(cp != NULL);
		*cp = '\0';	/* cut off trailing / */
	}

	/* This is guaranteed by the basedir check above */
	SM_ASSERT(len >= blen - 1);
	cp = &qpath[len - 1];
d3155 2
a3156 8
		register DIR *dp;
		register struct dirent *d;
		int off;
		char *delim;
		char relpath[MAXPATHLEN];

		*cp = '\0';	/* Overwrite wildcard */
		if ((cp = SM_LAST_DIR_DELIM(qpath)) == NULL)
d3160 1
a3160 1
				sm_dprintf("multiqueue_cache: \"%s*\": Can not wildcard relative path.\n",
d3163 1
a3163 1
			return qn;
a3168 1
			**	Change to //foo*
d3171 2
a3172 1
			(void) sm_strlcpy(qpath + 1, qpath, sizeof qpath - 1);
d3175 2
a3176 12
		delim = cp;
		*(cp++) = '\0';		/* Replace / with \0 */
		len = strlen(cp);	/* Last component of queue directory */

		/*
		**  Path relative to basedir, with trailing /
		**  It will be modified below to specify the subdirectories
		**  so they can be opened without chdir().
		*/

		off = sm_strlcpyn(relpath, sizeof relpath, 2, prefix, "/");
		SM_ASSERT(off < sizeof relpath);
d3179 1
a3179 2
			sm_dprintf("multiqueue_cache: prefix=\"%s%s\"\n",
				   relpath, cp);
d3181 1
a3181 4
		/* It is always basedir: we don't need to store it per group */
		/* XXX: optimize this! -> one more global? */
		qg->qg_qdir = newstr(basedir);
		qg->qg_qdir[blen - 1] = '\0';	/* cut off trailing / */
d3188 7
a3194 2
		/* Test path to get warning messages. */
		if (qn == 0)
d3196 6
a3201 6
			/*  XXX qg_runasuid and qg_runasgid for specials? */
			i = safedirpath(basedir, RunAsUid, RunAsGid, NULL,
					sff, 0, 0);
			if (i != 0 && tTd(41, 2))
				sm_dprintf("multiqueue_cache: \"%s\": Not safe: %s\n",
					   basedir, sm_errstring(i));
d3204 1
a3204 1
		if ((dp = opendir(prefix)) == NULL)
d3206 1
a3206 1
			syserr("can not opendir(%s/%s)", qg->qg_qdir, prefix);
d3208 2
a3209 3
				sm_dprintf("multiqueue_cache: opendir(\"%s/%s\"): %s\n",
					   qg->qg_qdir, prefix,
					   sm_errstring(errno));
d3211 1
a3211 1
			return qn;
d3215 1
a3215 2
			i = strlen(d->d_name);
			if (i < len || strncmp(d->d_name, cp, len) != 0)
d3218 1
a3218 1
					sm_dprintf("multiqueue_cache: \"%s\", skipped\n",
d3222 1
a3222 7

			/* Create relative pathname: prefix + local directory */
			i = sizeof(relpath) - off;
			if (sm_strlcpy(relpath + off, d->d_name, i) >= i)
				continue;	/* way too long */

			if (!chkqdir(relpath, sff))
d3225 1
a3225 1
			if (qg->qg_qpaths == NULL)
d3227 4
a3230 4
				slotsleft = INITIAL_SLOTS;
				qg->qg_qpaths = (QPATHS *)xalloc((sizeof *qg->qg_qpaths) *
								slotsleft);
				qg->qg_numqueues = 0;
d3234 4
a3237 5
				qg->qg_qpaths = (QPATHS *)sm_realloc((char *)qg->qg_qpaths,
							  (sizeof *qg->qg_qpaths) *
							  (qg->qg_numqueues +
							   ADD_SLOTS));
				if (qg->qg_qpaths == NULL)
d3240 1
a3240 1
					return qn;
d3242 1
a3242 1
				slotsleft += ADD_SLOTS;
d3246 15
a3260 12
			qg->qg_qpaths[qg->qg_numqueues].qp_subdirs = QP_NOSUB;

#define CHKRSUBDIR(name, flag)	\
	(void) sm_strlcpyn(subdir, sizeof subdir, 3, relpath, "/", name); \
	if (chkqdir(subdir, sff))	\
		qg->qg_qpaths[qg->qg_numqueues].qp_subdirs |= flag;	\
	else


			CHKRSUBDIR("qf", QP_SUBQF);
			CHKRSUBDIR("df", QP_SUBDF);
			CHKRSUBDIR("xf", QP_SUBXF);
d3264 1
a3264 8

			if (prefix[0] != '.')
				qg->qg_qpaths[qg->qg_numqueues].qp_name =
					newstr(relpath);
			else
				qg->qg_qpaths[qg->qg_numqueues].qp_name =
					newstr(d->d_name);

d3266 4
a3269 9
				sm_dprintf("multiqueue_cache: %d: \"%s\" cached (%x).\n",
					qg->qg_numqueues, relpath,
					qg->qg_qpaths[qg->qg_numqueues].qp_subdirs);
#if SM_CONF_SHM
			qg->qg_qpaths[qg->qg_numqueues].qp_idx = qn;
			*phash = hash_q(relpath, *phash);
#endif /* SM_CONF_SHM */
			qg->qg_numqueues++;
			++qn;
a3272 3

		/* undo damage */
		*delim = '/';
d3274 1
a3274 1
	if (qg->qg_numqueues == 0)
d3276 7
a3282 1
		qg->qg_qpaths = (QPATHS *) xalloc(sizeof *qg->qg_qpaths);
d3285 3
a3287 2
		i = safedirpath(qpath, RunAsUid, RunAsGid, NULL, sff, 0, 0);
		if (i == ENOENT)
d3289 1
a3289 1
			syserr("can not opendir(%s)", qpath);
d3291 2
a3292 2
				sm_dprintf("multiqueue_cache: opendir(\"%s\"): %s\n",
					   qpath, sm_errstring(i));
a3293 1
			return qn;
a3295 3
		qg->qg_qpaths[0].qp_subdirs = QP_NOSUB;
		qg->qg_numqueues = 1;

d3297 3
a3299 5
#define CHKSUBDIR(name, flag)	\
	(void) sm_strlcpyn(subdir, sizeof subdir, 3, qg->qg_qdir, "/", name); \
	if (chkqdir(subdir, sff))	\
		qg->qg_qpaths[0].qp_subdirs |= flag;	\
	else
d3301 3
a3303 3
		CHKSUBDIR("qf", QP_SUBQF);
		CHKSUBDIR("df", QP_SUBDF);
		CHKSUBDIR("xf", QP_SUBXF);
d3305 3
a3307 19
		if (qg->qg_qdir[blen - 1] != '\0' &&
		    qg->qg_qdir[blen] != '\0')
		{
			/*
			**  Copy the last component into qpaths and
			**  cut off qdir
			*/

			qg->qg_qpaths[0].qp_name = newstr(qg->qg_qdir + blen);
			qg->qg_qdir[blen - 1] = '\0';
		}
		else
			qg->qg_qpaths[0].qp_name = newstr(".");

#if SM_CONF_SHM
		qg->qg_qpaths[0].qp_idx = qn;
		*phash = hash_q(qg->qg_qpaths[0].qp_name, *phash);
#endif /* SM_CONF_SHM */
		++qn;
a3308 1
	return qn;
d3311 3
a3313 2
/*
**  FILESYS_FIND -- find entry in FileSys table, or add new one
d3315 3
a3317 9
**	Given the pathname of a directory, determine the file system
**	in which that directory resides, and return a pointer to the
**	entry in the FileSys table that describes the file system.
**	A new entry is added if necessary (and requested).
**	If the directory does not exist, -1 is returned.
**
**	Parameters:
**		path -- pathname of directory
**		add -- add to structure if not found.
d3320 2
a3321 49
**		>=0: found: index in file system table
**		<0: some error, i.e.,
**		FSF_TOO_MANY: too many filesystems (-> syserr())
**		FSF_STAT_FAIL: can't stat() filesystem (-> syserr())
**		FSF_NOT_FOUND: not in list
*/

static short filesys_find __P((char *, bool));

#define FSF_NOT_FOUND	(-1)
#define FSF_STAT_FAIL	(-2)
#define FSF_TOO_MANY	(-3)

static short
filesys_find(path, add)
	char *path;
	bool add;
{
	struct stat st;
	short i;

	if (stat(path, &st) < 0)
	{
		syserr("cannot stat queue directory %s", path);
		return FSF_STAT_FAIL;
	}
	for (i = 0; i < NumFileSys; ++i)
	{
		if (FILE_SYS_DEV(i) == st.st_dev)
			return i;
	}
	if (i >= MAXFILESYS)
	{
		syserr("too many queue file systems (%d max)", MAXFILESYS);
		return FSF_TOO_MANY;
	}
	if (!add)
		return FSF_NOT_FOUND;

	++NumFileSys;
	FILE_SYS_NAME(i) = path;
	FILE_SYS_DEV(i) = st.st_dev;
	FILE_SYS_AVAIL(i) = 0;
	FILE_SYS_BLKSIZE(i) = 1024; /* avoid divide by zero */
	return i;
}

/*
**  FILESYS_SETUP -- set up mapping from queue directories to file systems
d3323 1
a3323 12
**	This data structure is used to efficiently check the amount of
**	free space available in a set of queue directories.
**
**	Parameters:
**		add -- initialize structure if necessary.
**
**	Returns:
**		0: success
**		<0: some error, i.e.,
**		FSF_NOT_FOUND: not in list
**		FSF_STAT_FAIL: can't stat() filesystem (-> syserr())
**		FSF_TOO_MANY: too many filesystems (-> syserr())
d3326 4
a3329 5
static int filesys_setup __P((bool));

static int
filesys_setup(add)
	bool add;
d3331 3
a3333 3
	int i, j;
	short fs;
	int ret;
d3335 2
a3336 6
	ret = 0;
	for (i = 0; i < NumQueue && Queue[i] != NULL; i++)
	{
		for (j = 0; j < Queue[i]->qg_numqueues; ++j)
		{
			QPATHS *qp = &Queue[i]->qg_qpaths[j];
d3338 4
a3341 11
			fs = filesys_find(qp->qp_name, add);
			if (fs >= 0)
				qp->qp_fsysidx = fs;
			else
				qp->qp_fsysidx = 0;
			if (fs < ret)
				ret = fs;
		}
	}
	return ret;
}
d3343 3
a3345 35
/*
**  FILESYS_UPDATE -- update amount of free space on all file systems
**
**	The FileSys table is used to cache the amount of free space
**	available on all queue directory file systems.
**	This function updates the cached information if it has expired.
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Updates FileSys table.
*/

void
filesys_update()
{
	int i;
	long avail, blksize;
	time_t now;
	static time_t nextupdate = 0;

#if SM_CONF_SHM
	/* only the daemon updates this structure */
	if (ShmId != SM_SHM_NO_ID && DaemonPid != CurrentPid)
		return;
#endif /* SM_CONF_SHM */
	now = curtime();
	if (now < nextupdate)
		return;
	nextupdate = now + FILESYS_UPDATE_INTERVAL;
	for (i = 0; i < NumFileSys; ++i)
d3347 1
a3347 19
		FILESYS *fs = &FILE_SYS(i);

		avail = freediskspace(FILE_SYS_NAME(i), &blksize);
		if (avail < 0 || blksize <= 0)
		{
			if (LogLevel > 5)
				sm_syslog(LOG_ERR, NOQID,
					"filesys_update failed: %s, fs=%s, avail=%ld, blocksize=%ld",
					sm_errstring(errno),
					FILE_SYS_NAME(i), avail, blksize);
			fs->fs_avail = 0;
			fs->fs_blksize = 1024; /* avoid divide by zero */
			nextupdate = now + 2; /* let's do this soon again */
		}
		else
		{
			fs->fs_avail = avail;
			fs->fs_blksize = blksize;
		}
d3349 5
a3353 1
}
d3355 1
a3355 73
#if _FFR_ANY_FREE_FS
/*
**  FILESYS_FREE -- check whether there is at least one fs with enough space.
**
**	Parameters:
**		fsize -- file size in bytes
**
**	Returns:
**		true iff there is one fs with more than fsize bytes free.
*/

bool
filesys_free(fsize)
	long fsize;
{
	int i;

	if (fsize <= 0)
		return true;
	for (i = 0; i < NumFileSys; ++i)
	{
		long needed = 0;

		if (FILE_SYS_AVAIL(i) < 0 || FILE_SYS_BLKSIZE(i) <= 0)
			continue;
		needed += fsize / FILE_SYS_BLKSIZE(i)
			  + ((fsize % FILE_SYS_BLKSIZE(i)
			      > 0) ? 1 : 0)
			  + MinBlocksFree;
		if (needed <= FILE_SYS_AVAIL(i))
			return true;
	}
	return false;
}
#endif /* _FFR_ANY_FREE_FS */

#if _FFR_CONTROL_MSTAT
/*
**  DISK_STATUS -- show amount of free space in queue directories
**
**	Parameters:
**		out -- output file pointer.
**		prefix -- string to output in front of each line.
**
**	Returns:
**		none.
*/

void
disk_status(out, prefix)
	SM_FILE_T *out;
	char *prefix;
{
	int i;
	long avail, blksize;
	long free;

	for (i = 0; i < NumFileSys; ++i)
	{
		avail = freediskspace(FILE_SYS_NAME(i), &blksize);
		if (avail >= 0 && blksize > 0)
		{
			free = (long)((double) avail *
				((double) blksize / 1024));
		}
		else
			free = -1;
		(void) sm_io_fprintf(out, SM_TIME_DEFAULT,
				"%s%d/%s/%ld\r\n",
				prefix, i,
				FILE_SYS_NAME(i),
					free);
	}
d3357 1
a3357 1
#endif /* _FFR_CONTROL_MSTAT */
d3359 1
a3359 1
#if SM_CONF_SHM
d3361 1
a3361 1
**  UPD_QS -- update information about queue when adding/deleting an entry
d3364 1
a3364 3
**		e -- envelope.
**		delete -- delete/add entry.
**		avail -- update the space available as well.
d3367 1
a3367 1
**		none.
d3370 1
a3370 2
**		Modifies available space in filesystem.
**		Changes number of entries in queue directory.
d3373 2
a3374 2
void
upd_qs(e, delete, avail)
a3375 2
	bool delete;
	bool avail;
d3377 1
a3377 3
	short fidx;
	int idx;
	long s;
d3379 1
a3379 8
	if (ShmId == SM_SHM_NO_ID || e == NULL)
		return;
	if (e->e_qgrp == NOQGRP || e->e_qdir == NOQDIR)
		return;
	idx = Queue[e->e_qgrp]->qg_qpaths[e->e_qdir].qp_idx;

	/* XXX in theory this needs to be protected with a mutex */
	if (QSHM_ENTRIES(idx) >= 0)
d3381 2
a3382 2
		if (delete)
			--QSHM_ENTRIES(idx);
a3383 76
			++QSHM_ENTRIES(idx);
	}

	fidx = Queue[e->e_qgrp]->qg_qpaths[e->e_qdir].qp_fsysidx;
	if (fidx < 0)
		return;

	/* update available space also?  (might be loseqfile) */
	if (!avail)
		return;

	/* convert size to blocks; this causes rounding errors */
	s = e->e_msgsize / FILE_SYS_BLKSIZE(fidx);
	if (s == 0)
		return;

	/* XXX in theory this needs to be protected with a mutex */
	if (delete)
		FILE_SYS_AVAIL(fidx) += s;
	else
		FILE_SYS_AVAIL(fidx) -= s;

}
/*
**  INIT_SHM -- initialize shared memory structure
**
**	Initialize or attach to shared memory segment.
**	Currently it is not a fatal error if this doesn't work.
**	However, it causes us to have a "fallback" storage location
**	for everything that is supposed to be in the shared memory,
**	which makes the code slightly ugly.
**
**	Parameters:
**		qn -- number of queue directories.
**		owner -- owner of shared memory.
**		hash -- identifies data that is stored in shared memory.
**
**	Returns:
**		none.
*/

static void init_shm __P((int, bool, unsigned int));

static void
init_shm(qn, owner, hash)
	int qn;
	bool owner;
	unsigned int hash;
{
	int i;

	PtrFileSys = &FileSys[0];
	PNumFileSys = &Numfilesys;

	/* This allows us to disable shared memory at runtime. */
	if (ShmKey != 0)
	{
		int count;
		int save_errno;
		size_t shms;

		count = 0;
		shms = SM_T_SIZE + qn * sizeof(QUEUE_SHM_T);
		for (;;)
		{
			/* XXX: maybe allow read access for group? */
			Pshm = sm_shmstart(ShmKey, shms, SHM_R|SHM_W, &ShmId,
					   owner);
			save_errno = errno;
			if (Pshm != NULL || save_errno != EEXIST)
				break;
			if (++count >= 3)
				break;
			sleep(count);
		}
		if (Pshm != NULL)
d3385 3
a3387 56
			int *p;

			p = (int *) Pshm;
			if (owner)
			{
				*p = (int) shms;
				*((pid_t *) SHM_OFF_PID(Pshm)) = CurrentPid;
				p = (int *) SHM_OFF_TAG(Pshm);
				*p = hash;
			}
			else
			{
				if (*p != (int) shms)
				{
					save_errno = EINVAL;
					cleanup_shm(false);
					goto error;
				}
				p = (int *) SHM_OFF_TAG(Pshm);
				if (*p != (int) hash)
				{
					save_errno = EINVAL;
					cleanup_shm(false);
					goto error;
				}

				/*
				**  XXX how to check the pid?
				**  Read it from the pid-file? That does
				**  not need to exist.
				**  We could disable shm if we can't confirm
				**  that it is the right one.
				*/
			}

			PtrFileSys = (FILESYS *) OFF_FILE_SYS(Pshm);
			PNumFileSys = (int *) OFF_NUM_FILE_SYS(Pshm);
			QShm = (QUEUE_SHM_T *) OFF_QUEUE_SHM(Pshm);
			PRSATmpCnt = (int *) OFF_RSA_TMP_CNT(Pshm);
			*PRSATmpCnt = 0;
			if (owner)
			{
				/* initialize values in shared memory */
				NumFileSys = 0;
				for (i = 0; i < qn; i++)
					QShm[i].qs_entries = -1;
			}
			return;
		}
  error:
		if (LogLevel > (owner ? 8 : 11))
		{
			sm_syslog(owner ? LOG_ERR : LOG_NOTICE, NOQID,
				  "can't %s shared memory, key=%ld: %s",
				  owner ? "initialize" : "attach to",
				  (long) ShmKey, sm_errstring(save_errno));
d3389 1
d3391 3
d3395 2
a3396 1413
#endif /* SM_CONF_SHM */

/*
**  SETUP_QUEUES -- setup all queue groups
**
**	Parameters:
**		owner -- owner of shared memory.
**
**	Returns:
**		none.
**
#if SM_CONF_SHM
**	Side Effects:
**		attaches shared memory.
#endif * SM_CONF_SHM *
*/

void
setup_queues(owner)
	bool owner;
{
	int i, qn, len;
	unsigned int hashval;
	char basedir[MAXPATHLEN];
	struct stat st;

	/*
	**  Determine basedir for all queue directories.
	**  All queue directories must be (first level) subdirectories
	**  of the basedir.  The basedir is the QueueDir
	**  without wildcards, but with trailing /
	*/

	hashval = 0;
	errno = 0;
	len = sm_strlcpy(basedir, QueueDir, sizeof basedir);
	if (len >= sizeof basedir)
	{
		syserr("QueueDirectory: path too long: %d,  max %d",
			len, (int) sizeof basedir);
		ExitStat = EX_CONFIG;
		return;
	}
	SM_ASSERT(len > 0);
	if (basedir[len - 1] == '*')
	{
		char *cp;

		cp = SM_LAST_DIR_DELIM(basedir);
		if (cp == NULL)
		{
			syserr("QueueDirectory: can not wildcard relative path \"%s\"",
				QueueDir);
			if (tTd(41, 2))
				sm_dprintf("setup_queues: \"%s\": Can not wildcard relative path.\n",
					QueueDir);
			ExitStat = EX_CONFIG;
			return;
		}

		/* cut off wildcard pattern */
		*++cp = '\0';
		len = cp - basedir;
	}
	else if (!SM_IS_DIR_DELIM(basedir[len - 1]))
	{
		/* append trailing slash since it is a directory */
		basedir[len] = '/';
		basedir[++len] = '\0';
	}

	/* len counts up to the last directory delimiter */
	SM_ASSERT(basedir[len - 1] == '/');

	if (chdir(basedir) < 0)
	{
		int save_errno = errno;

		syserr("can not chdir(%s)", basedir);
		if (save_errno == EACCES)
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				"Program mode requires special privileges, e.g., root or TrustedUser.\n");
		if (tTd(41, 2))
			sm_dprintf("setup_queues: \"%s\": %s\n",
				   basedir, sm_errstring(errno));
		ExitStat = EX_CONFIG;
		return;
	}
#if SM_CONF_SHM
	hashval = hash_q(basedir, hashval);
#endif /* SM_CONF_SHM */

	/* initialize map for queue runs */
	clrbitmap(DoQueueRun);


	if (UseMSP && OpMode != MD_TEST)
	{
		long sff = SFF_CREAT;

		if (stat(".", &st) < 0)
		{
			syserr("can not stat(%s)", basedir);
			if (tTd(41, 2))
				sm_dprintf("setup_queues: \"%s\": %s\n",
					   basedir, sm_errstring(errno));
			ExitStat = EX_CONFIG;
			return;
		}
		if (RunAsUid == 0)
			sff |= SFF_ROOTOK;

		/*
		**  Check queue directory permissions.
		**	Can we write to a group writable queue directory?
		*/

		if (bitset(S_IWGRP, QueueFileMode) &&
		    bitset(S_IWGRP, st.st_mode) &&
		    safefile(" ", RunAsUid, RunAsGid, RunAsUserName, sff,
			     QueueFileMode, NULL) != 0)
		{
			syserr("can not write to queue directory %s (RunAsGid=%d, required=%d)",
				basedir, (int) RunAsGid, (int) st.st_gid);
		}
	}

	/* initial number of queue directories */
	qn = 0;
	for (i = 0; i < NumQueue && Queue[i] != NULL; i++)
		qn = multiqueue_cache(basedir, len, Queue[i], qn, &hashval);

#if SM_CONF_SHM
	init_shm(qn, owner, hashval);
	i = filesys_setup(owner || ShmId == SM_SHM_NO_ID);
	if (i == FSF_NOT_FOUND)
	{
		/*
		**  We didn't get the right filesystem data
		**  This may happen if we don't have the right shared memory.
		**  So let's do this without shared memory.
		*/

		SM_ASSERT(!owner);
		cleanup_shm(false);	/* release shared memory */
		i = filesys_setup(false);
		if (i < 0)
			syserr("filesys_setup failed twice, result=%d", i);
		else if (LogLevel > 8)
			sm_syslog(LOG_WARNING, NOQID,
				  "shared memory does not contain expected data, ignored");
	}
#else /* SM_CONF_SHM */
	i = filesys_setup(true);
#endif /* SM_CONF_SHM */
	if (i < 0)
		ExitStat = EX_CONFIG;
}

#if SM_CONF_SHM
/*
**  CLEANUP_SHM -- do some cleanup work for shared memory etc
**
**	Parameters:
**		owner -- owner of shared memory?
**
**	Returns:
**		none.
**
**	Side Effects:
**		detaches shared memory.
*/

void
cleanup_shm(owner)
	bool owner;
{
	if (ShmId != SM_SHM_NO_ID)
	{
		if (sm_shmstop(Pshm, ShmId, owner) < 0 && LogLevel > 8)
			sm_syslog(LOG_INFO, NOQID, "sh_shmstop failed=%s",
				  sm_errstring(errno));
		Pshm = NULL;
		ShmId = SM_SHM_NO_ID;
	}
}
#endif /* SM_CONF_SHM */

/*
**  CLEANUP_QUEUES -- do some cleanup work for queues
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
*/

void
cleanup_queues()
{
	sync_queue_time();
}
/*
**  SET_DEF_QUEUEVAL -- set default values for a queue group.
**
**	Parameters:
**		qg -- queue group
**		all -- set all values (true for default group)?
**
**	Returns:
**		none.
**
**	Side Effects:
**		sets default values for the queue group.
*/

void
set_def_queueval(qg, all)
	QUEUEGRP *qg;
	bool all;
{
	if (bitnset(QD_DEFINED, qg->qg_flags))
		return;
	if (all)
		qg->qg_qdir = QueueDir;
#if 0
	qg->qg_sortorder = QueueSortOrder;
#endif /* 0 */
	qg->qg_maxqrun = all ? MaxRunnersPerQueue : -1;
	qg->qg_nice = NiceQueueRun;
}
/*
**  MAKEQUEUE -- define a new queue.
**
**	Parameters:
**		line -- description of queue.  This is in labeled fields.
**			The fields are:
**			   F -- the flags associated with the queue
**			   I -- the interval between running the queue
**			   J -- the maximum # of jobs in work list
**			   [M -- the maximum # of jobs in a queue run]
**			   N -- the niceness at which to run
**			   P -- the path to the queue
**			   S -- the queue sorting order
**			   R -- number of parallel queue runners
**			   r -- max recipients per envelope
**			The first word is the canonical name of the queue.
**		qdef -- this is a 'Q' definition from .cf
**
**	Returns:
**		none.
**
**	Side Effects:
**		enters the queue into the queue table.
*/

void
makequeue(line, qdef)
	char *line;
	bool qdef;
{
	register char *p;
	register QUEUEGRP *qg;
	register STAB *s;
	int i;
	char fcode;

	/* allocate a queue and set up defaults */
	qg = (QUEUEGRP *) xalloc(sizeof *qg);
	memset((char *) qg, '\0', sizeof *qg);

	if (line[0] == '\0')
	{
		syserr("name required for queue");
		return;
	}

	/* collect the queue name */
	for (p = line;
	     *p != '\0' && *p != ',' && !(isascii(*p) && isspace(*p));
	     p++)
		continue;
	if (*p != '\0')
		*p++ = '\0';
	qg->qg_name = newstr(line);

	/* set default values, can be overridden below */
	set_def_queueval(qg, false);

	/* now scan through and assign info from the fields */
	while (*p != '\0')
	{
		auto char *delimptr;

		while (*p != '\0' &&
		       (*p == ',' || (isascii(*p) && isspace(*p))))
			p++;

		/* p now points to field code */
		fcode = *p;
		while (*p != '\0' && *p != '=' && *p != ',')
			p++;
		if (*p++ != '=')
		{
			syserr("queue %s: `=' expected", qg->qg_name);
			return;
		}
		while (isascii(*p) && isspace(*p))
			p++;

		/* p now points to the field body */
		p = munchstring(p, &delimptr, ',');

		/* install the field into the queue struct */
		switch (fcode)
		{
		  case 'P':		/* pathname */
			if (*p == '\0')
				syserr("queue %s: empty path name",
					qg->qg_name);
			else
				qg->qg_qdir = newstr(p);
			break;

		  case 'F':		/* flags */
			for (; *p != '\0'; p++)
				if (!(isascii(*p) && isspace(*p)))
					setbitn(*p, qg->qg_flags);
			break;

			/*
			**  Do we need two intervals here:
			**  One for persistent queue runners,
			**  one for "normal" queue runs?
			*/

		  case 'I':	/* interval between running the queue */
			qg->qg_queueintvl = convtime(p, 'm');
			break;

		  case 'N':		/* run niceness */
			qg->qg_nice = atoi(p);
			break;

		  case 'R':		/* maximum # of runners for the group */
			i = atoi(p);

			/* can't have more runners than allowed total */
			if (MaxQueueChildren > 0 && i > MaxQueueChildren)
			{
				qg->qg_maxqrun = MaxQueueChildren;
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Q=%s: R=%d exceeds MaxQueueChildren=%d, set to MaxQueueChildren\n",
						     qg->qg_name, i,
						     MaxQueueChildren);
			}
			else
				qg->qg_maxqrun = i;
			break;

		  case 'J':		/* maximum # of jobs in work list */
			qg->qg_maxlist = atoi(p);
			break;

		  case 'r':		/* max recipients per envelope */
			qg->qg_maxrcpt = atoi(p);
			break;

#if 0
		  case 'S':		/* queue sorting order */
			switch (*p)
			{
			  case 'h':	/* Host first */
			  case 'H':
				qg->qg_sortorder = QSO_BYHOST;
				break;

			  case 'p':	/* Priority order */
			  case 'P':
				qg->qg_sortorder = QSO_BYPRIORITY;
				break;

			  case 't':	/* Submission time */
			  case 'T':
				qg->qg_sortorder = QSO_BYTIME;
				break;

			  case 'f':	/* File name */
			  case 'F':
				qg->qg_sortorder = QSO_BYFILENAME;
				break;

			  case 'm':	/* Modification time */
			  case 'M':
				qgrp->qg_sortorder = QSO_BYMODTIME;
				break;

			  default:
				syserr("Invalid queue sort order \"%s\"", p);
			}
			break;
#endif /* 0 */

		  default:
			syserr("Q%s: unknown queue equate %c=",
			       qg->qg_name, fcode);
			break;
		}

		p = delimptr;
	}

	/* do some rationality checking */
	if (NumQueue >= MAXQUEUEGROUPS)
	{
		syserr("too many queue groups defined (%d max)",
			MAXQUEUEGROUPS);
		return;
	}

	if (qg->qg_qdir == NULL)
	{
		if (QueueDir == NULL || *QueueDir == '\0')
		{
			syserr("QueueDir must be defined before queue groups");
			return;
		}
		qg->qg_qdir = newstr(QueueDir);
	}

	if (qg->qg_maxqrun > 1 && !bitnset(QD_FORK, qg->qg_flags))
	{
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: Q=%s: R=%d: multiple queue runners specified\n\tbut flag '%c' is not set\n",
				     qg->qg_name, qg->qg_maxqrun, QD_FORK);
	}

	/* enter the queue into the symbol table */
	if (tTd(37, 8))
		sm_syslog(LOG_INFO, NOQID,
			  "Adding %s to stab, path: %s", qg->qg_name,
			  qg->qg_qdir);
	s = stab(qg->qg_name, ST_QUEUE, ST_ENTER);
	if (s->s_quegrp != NULL)
	{
		i = s->s_quegrp->qg_index;

		/* XXX what about the pointers inside this struct? */
		sm_free(s->s_quegrp); /* XXX */
	}
	else
		i = NumQueue++;
	Queue[i] = s->s_quegrp = qg;
	qg->qg_index = i;

	/* set default value for max queue runners */
	if (qg->qg_maxqrun < 0)
	{
		if (MaxRunnersPerQueue > 0)
			qg->qg_maxqrun = MaxRunnersPerQueue;
		else
			qg->qg_maxqrun = 1;
	}
	if (qdef)
		setbitn(QD_DEFINED, qg->qg_flags);
}
#if 0
/*
**  HASHFQN -- calculate a hash value for a fully qualified host name
**
**	Arguments:
**		fqn -- an all lower-case host.domain string
**		buckets -- the number of buckets (queue directories)
**
**	Returns:
**		a bucket number (signed integer)
**		-1 on error
**
**	Contributed by Exactis.com, Inc.
*/

int
hashfqn(fqn, buckets)
	register char *fqn;
	int buckets;
{
	register char *p;
	register int h = 0, hash, cnt;

	if (fqn == NULL)
		return -1;

	/*
	**  A variation on the gdb hash
	**  This is the best as of Feb 19, 1996 --bcx
	*/

	p = fqn;
	h = 0x238F13AF * strlen(p);
	for (cnt = 0; *p != 0; ++p, cnt++)
	{
		h = (h + (*p << (cnt * 5 % 24))) & 0x7FFFFFFF;
	}
	h = (1103515243 * h + 12345) & 0x7FFFFFFF;
	if (buckets < 2)
		hash = 0;
	else
		hash = (h % buckets);

	return hash;
}
#endif /* 0 */

#if _FFR_QUEUEDELAY
/*
**  QUEUEDELAY -- compute queue delay time
**
**	Parameters:
**		e -- the envelope to queue up.
**
**	Returns:
**		queue delay time
**
**	Side Effects:
**		may change e_queuedelay
*/

static time_t
queuedelay(e)
	ENVELOPE *e;
{
	time_t qd;

	if (e->e_queuealg == QD_EXP)
	{
		if (e->e_queuedelay == 0)
			e->e_queuedelay = QueueInitDelay;
		else
		{
			e->e_queuedelay *= 2;
			if (e->e_queuedelay > QueueMaxDelay)
				e->e_queuedelay = QueueMaxDelay;
		}
		qd = e->e_queuedelay;
	}
	else
		qd = MinQueueAge;
	return qd;
}
#endif /* _FFR_QUEUEDELAY */

/*
**  A structure for sorting Queue according to maxqrun without
**	screwing up Queue itself.
*/

struct sortqgrp
{
	int sg_idx;		/* original index */
	int sg_maxqrun;		/* max queue runners */
};
typedef struct sortqgrp	SORTQGRP_T;
static int cmpidx __P((const void *, const void *));

static int
cmpidx(a, b)
	const void *a;
	const void *b;
{
	/* The sort is highest to lowest, so the comparison is reversed */
	if (((SORTQGRP_T *)a)->sg_maxqrun < ((SORTQGRP_T *)b)->sg_maxqrun)
		return 1;
	else if (((SORTQGRP_T *)a)->sg_maxqrun > ((SORTQGRP_T *)b)->sg_maxqrun)
		return -1;
	else
		return 0;
}

/*
**  MAKEWORKGROUP -- balance queue groups into work groups per MaxQueueChildren
**
**  Take the now defined queue groups and assign them to work groups.
**  This is done to balance out the number of concurrently active
**  queue runners such that MaxQueueChildren is not exceeded. This may
**  result in more than one queue group per work group. In such a case
**  the number of running queue groups in that work group will have no
**  more than the work group maximum number of runners (a "fair" portion
**  of MaxQueueRunners). All queue groups within a work group will get a
**  chance at running.
**
**	Parameters:
**		none.
**
**	Returns:
**		nothing.
**
**	Side Effects:
**		Sets up WorkGrp structure.
*/

void
makeworkgroups()
{
	int i, j, total_runners = 0;
	int dir;
	SORTQGRP_T si[MAXQUEUEGROUPS + 1];

	if (NumQueue == 1 && strcmp(Queue[0]->qg_name, "mqueue") == 0)
	{
		/*
		**  There is only the "mqueue" queue group (a default)
		**  containing all of the queues. We want to provide to
		**  this queue group the maximum allowable queue runners.
		**  To match older behavior (8.10/8.11) we'll try for
		**  1 runner per queue capping it at MaxQueueChildren.
		**  So if there are N queues, then there will be N runners
		**  for the "mqueue" queue group (where N is kept less than
		**  MaxQueueChildren).
		*/

		NumWorkGroups = 1;
		WorkGrp[0].wg_numqgrp = 1;
		WorkGrp[0].wg_qgs = (QUEUEGRP **) xalloc(sizeof(QUEUEGRP *));
		WorkGrp[0].wg_qgs[0] = Queue[0];
		if (MaxQueueChildren > 0 &&
		    Queue[0]->qg_numqueues > MaxQueueChildren)
			WorkGrp[0].wg_runners = MaxQueueChildren;
		else
			WorkGrp[0].wg_runners = Queue[0]->qg_numqueues;

		Queue[0]->qg_wgrp = 0;

		/* can't have more runners than allowed total */
		if (MaxQueueChildren > 0 &&
		    Queue[0]->qg_maxqrun > MaxQueueChildren)
			Queue[0]->qg_maxqrun = MaxQueueChildren;
		WorkGrp[0].wg_maxact = Queue[0]->qg_maxqrun;
		WorkGrp[0].wg_lowqintvl = Queue[0]->qg_queueintvl;
		return;
	}

	for (i = 0; i < NumQueue; i++)
	{
		si[i].sg_maxqrun = Queue[i]->qg_maxqrun;
		si[i].sg_idx = i;
	}
	qsort(si, NumQueue, sizeof(si[0]), cmpidx);

	NumWorkGroups = 0;
	for (i = 0; i < NumQueue; i++)
	{
		total_runners += si[i].sg_maxqrun;
		if (MaxQueueChildren <= 0 || total_runners <= MaxQueueChildren)
			NumWorkGroups++;
		else
			break;
	}

	if (NumWorkGroups < 1)
		NumWorkGroups = 1; /* gotta have one at least */
	else if (NumWorkGroups > MAXWORKGROUPS)
		NumWorkGroups = MAXWORKGROUPS; /* the limit */

	/*
	**  We now know the number of work groups to pack the queue groups
	**  into. The queue groups in 'Queue' are sorted from highest
	**  to lowest for the number of runners per queue group.
	**  We put the queue groups with the largest number of runners
	**  into work groups first. Then the smaller ones are fitted in
	**  where it looks best.
	*/

	j = 0;
	dir = 1;
	for (i = 0; i < NumQueue; i++)
	{
		/* a to-and-fro packing scheme, continue from last position */
		if (j >= NumWorkGroups)
		{
			dir = -1;
			j = NumWorkGroups - 1;
		}
		else if (j < 0)
		{
			j = 0;
			dir = 1;
		}

		WorkGrp[j].wg_qgs = (QUEUEGRP **)sm_realloc(WorkGrp[j].wg_qgs,
						sizeof(QUEUEGRP *) *
						(WorkGrp[j].wg_numqgrp + 1));
		if (WorkGrp[j].wg_qgs == NULL)
		{
			syserr("@@cannot allocate memory for work queues, need %d bytes",
			       (int) (sizeof(QUEUEGRP *) *
				      (WorkGrp[j].wg_numqgrp + 1)));
		}

		WorkGrp[j].wg_qgs[WorkGrp[j].wg_numqgrp] = Queue[si[i].sg_idx];
		WorkGrp[j].wg_numqgrp++;
		WorkGrp[j].wg_runners += Queue[i]->qg_maxqrun;
		Queue[si[i].sg_idx]->qg_wgrp = j;

		if (WorkGrp[j].wg_maxact == 0)
		{
			/* can't have more runners than allowed total */
			if (MaxQueueChildren > 0 &&
			    Queue[i]->qg_maxqrun > MaxQueueChildren)
				Queue[i]->qg_maxqrun = MaxQueueChildren;
			WorkGrp[j].wg_maxact = Queue[i]->qg_maxqrun;
		}

		/*
		**  XXX: must wg_lowqintvl be the GCD?
		**  qg1: 2m, qg2: 3m, minimum: 2m, when do queue runs for
		**  qg2 occur?
		*/

		/* keep track of the lowest interval for a persistent runner */
		if (Queue[si[i].sg_idx]->qg_queueintvl > 0 &&
		    WorkGrp[j].wg_lowqintvl < Queue[si[i].sg_idx]->qg_queueintvl)
			WorkGrp[j].wg_lowqintvl = Queue[si[i].sg_idx]->qg_queueintvl;
		j += dir;
	}
	if (tTd(41, 9))
	{
		for (i = 0; i < NumWorkGroups; i++)
		{
			sm_dprintf("Workgroup[%d]=", i);
			for (j = 0; j < WorkGrp[i].wg_numqgrp; j++)
			{
				sm_dprintf("%s, ",
					WorkGrp[i].wg_qgs[j]->qg_name);
			}
			sm_dprintf("\n");
		}
	}
}

/*
**  DUP_DF -- duplicate envelope data file
**
**	Copy the data file from the 'old' envelope to the 'new' envelope
**	in the most efficient way possible.
**
**	Create a hard link from the 'old' data file to the 'new' data file.
**	If the old and new queue directories are on different file systems,
**	then the new data file link is created in the old queue directory,
**	and the new qf file will contain a 'd' record pointing to the
**	directory containing the new df file.
**
**	Parameters:
**		old -- old envelope.
**		new -- new envelope.
**
**	Results:
**		Returns true on success, false on failure.
**
**	Side Effects:
**		On success, the new data file is created.
**		On failure, EF_FATALERRS is set in new->e_flags.
*/

static bool	dup_df __P((ENVELOPE *, ENVELOPE *));

static bool
dup_df(old, new)
	ENVELOPE *old;
	ENVELOPE *new;
{
	int ofs, nfs, r;
	char opath[MAXPATHLEN];
	char npath[MAXPATHLEN];

	SM_REQUIRE(bitset(EF_HAS_DF, old->e_flags));
	SM_REQUIRE(ISVALIDQGRP(old->e_qgrp) && ISVALIDQDIR(old->e_qdir));
	SM_REQUIRE(ISVALIDQGRP(new->e_qgrp) && ISVALIDQDIR(new->e_qdir));

	(void) sm_strlcpy(opath, queuename(old, 'd'), sizeof opath);
	(void) sm_strlcpy(npath, queuename(new, 'd'), sizeof npath);

	if (old->e_dfp != NULL)
	{
		r = sm_io_setinfo(old->e_dfp, SM_BF_COMMIT, NULL);
		if (r < 0 && errno != EINVAL)
		{
			syserr("@@can't commit %s", opath);
			new->e_flags |= EF_FATALERRS;
			return false;
		}
	}

	/*
	**  Attempt to create a hard link, if we think both old and new
	**  are on the same file system, otherwise copy the file.
	**
	**  Don't waste time attempting a hard link unless old and new
	**  are on the same file system.
	**
	**  We unlink the new file if it previously existed.  This protects
	**  us from abandoned data files left behind as a result of
	**  a prior system crash.  The envelope ids of these old files
	**  can conflict with the envelope ids we are generating right now
	**  if the clock was set back.
	*/

	ofs = Queue[old->e_qgrp]->qg_qpaths[old->e_qdir].qp_fsysidx;
	nfs = Queue[new->e_qgrp]->qg_qpaths[new->e_qdir].qp_fsysidx;
	if (FILE_SYS_DEV(ofs) == FILE_SYS_DEV(nfs))
	{
		if (link(opath, npath) == 0)
		{
			new->e_flags |= EF_HAS_DF;
			SYNC_DIR(npath, true);
			return true;
		}
		if (errno == EEXIST)
		{
			if (unlink(npath) < 0)
			{
				syserr("@@can't unlink %s", npath);
				new->e_flags |= EF_FATALERRS;
				return false;
			}
			if (link(opath, npath) == 0)
			{
				new->e_flags |= EF_HAS_DF;
				SYNC_DIR(npath, true);
				return true;
			}
		}
	}

	/*
	**  Can't link across queue directories, so try to create a hard
	**  link in the same queue directory as the old df file.
	**  The qf file will refer to the new df file using a 'd' record.
	*/

	new->e_dfqgrp = old->e_dfqgrp;
	new->e_dfqdir = old->e_dfqdir;
	(void) sm_strlcpy(npath, queuename(new, 'd'), sizeof npath);
	if (link(opath, npath) == 0)
	{
		new->e_flags |= EF_HAS_DF;
		SYNC_DIR(npath, true);
		return true;
	}
	if (errno == EEXIST)
	{
		if (unlink(npath) < 0)
		{
			syserr("@@can't unlink %s", npath);
			new->e_flags |= EF_FATALERRS;
			return false;
		}
		if (link(opath, npath) == 0)
		{
			new->e_flags |= EF_HAS_DF;
			SYNC_DIR(npath, true);
			return true;
		}
	}
	syserr("@@can't link %s to %s", opath, npath);
	new->e_flags |= EF_FATALERRS;
	return false;
}

/*
**  SPLIT_ENV -- Allocate a new envelope based on a given envelope.
**
**	Parameters:
**		e -- envelope.
**		sendqueue -- sendqueue for new envelope.
**		qgrp -- index of queue group.
**		qdir -- queue directory.
**
**	Results:
**		new envelope.
**
*/

static ENVELOPE	*split_env __P((ENVELOPE *, ADDRESS *, int, int));

static ENVELOPE *
split_env(e, sendqueue, qgrp, qdir)
	ENVELOPE *e;
	ADDRESS *sendqueue;
	int qgrp;
	int qdir;
{
	ENVELOPE *ee;

	ee = (ENVELOPE *) sm_rpool_malloc_x(e->e_rpool, sizeof *ee);
	STRUCTCOPY(*e, *ee);
	ee->e_message = NULL;	/* XXX use original message? */
	ee->e_id = NULL;
	assign_queueid(ee);
	ee->e_sendqueue = sendqueue;
	ee->e_flags &= ~(EF_INQUEUE|EF_CLRQUEUE|EF_FATALERRS
			 |EF_SENDRECEIPT|EF_RET_PARAM|EF_HAS_DF);
	ee->e_flags |= EF_NORECEIPT;	/* XXX really? */
	ee->e_from.q_state = QS_SENDER;
	ee->e_dfp = NULL;
	ee->e_lockfp = NULL;
	if (e->e_xfp != NULL)
		ee->e_xfp = sm_io_dup(e->e_xfp);
	ee->e_qgrp = ee->e_dfqgrp = qgrp;
	ee->e_qdir = ee->e_dfqdir = qdir;
	ee->e_errormode = EM_MAIL;
	ee->e_statmsg = NULL;

	/*
	**  XXX Not sure if this copying is necessary.
	**  sendall() does this copying, but I don't know if that is
	**  because of the storage management discipline we were using
	**  before rpools were introduced, or if it is because these lists
	**  can be modified later.
	*/

	ee->e_header = copyheader(e->e_header, ee->e_rpool);
	ee->e_errorqueue = copyqueue(e->e_errorqueue, ee->e_rpool);

	return ee;
}

/* return values from split functions, check also below! */
#define SM_SPLIT_FAIL	(0)
#define SM_SPLIT_NONE	(1)
#define SM_SPLIT_NEW(n)	(1 + (n))

/*
**  SPLIT_ACROSS_QUEUE_GROUPS
**
**	This function splits an envelope across multiple queue groups
**	based on the queue group of each recipient.
**
**	Parameters:
**		e -- envelope.
**
**	Results:
**		SM_SPLIT_FAIL on failure
**		SM_SPLIT_NONE if no splitting occurred,
**		or 1 + the number of additional envelopes created.
**
**	Side Effects:
**		On success, e->e_sibling points to a list of zero or more
**		additional envelopes, and the associated data files exist
**		on disk.  But the 'qf' files are not created.
**
**		On failure, e->e_flags & EF_FATALERRS is set.
**		e->e_sibling is not changed.
**		The order of recipients in e->e_sendqueue is permuted.
**		Abandoned data files for additional envelopes that failed
**		to be created may exist on disk.
*/

static int	q_qgrp_compare __P((const void *, const void *));
static int	e_filesys_compare __P((const void *, const void *));

static int
q_qgrp_compare(p1, p2)
	const void *p1;
	const void *p2;
{
	ADDRESS **pq1 = (ADDRESS **) p1;
	ADDRESS **pq2 = (ADDRESS **) p2;

	return (*pq1)->q_qgrp - (*pq2)->q_qgrp;
}

static int
e_filesys_compare(p1, p2)
	const void *p1;
	const void *p2;
{
	ENVELOPE **pe1 = (ENVELOPE **) p1;
	ENVELOPE **pe2 = (ENVELOPE **) p2;
	int fs1, fs2;

	fs1 = Queue[(*pe1)->e_qgrp]->qg_qpaths[(*pe1)->e_qdir].qp_fsysidx;
	fs2 = Queue[(*pe2)->e_qgrp]->qg_qpaths[(*pe2)->e_qdir].qp_fsysidx;
	if (FILE_SYS_DEV(fs1) < FILE_SYS_DEV(fs2))
		return -1;
	if (FILE_SYS_DEV(fs1) > FILE_SYS_DEV(fs2))
		return 1;
	return 0;
}

static int
split_across_queue_groups(e)
	ENVELOPE *e;
{
	int naddrs, nsplits, i;
	char **pvp;
	ADDRESS *q, **addrs;
	ENVELOPE *ee, *es;
	ENVELOPE *splits[MAXQUEUEGROUPS];
	char pvpbuf[PSBUFSIZE];

	SM_REQUIRE(ISVALIDQGRP(e->e_qgrp));

	/* Count addresses and assign queue groups. */
	naddrs = 0;
	for (q = e->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (QS_IS_DEAD(q->q_state))
			continue;
		++naddrs;

		/* bad addresses and those already sent stay put */
		if (QS_IS_BADADDR(q->q_state) ||
		    QS_IS_SENT(q->q_state))
			q->q_qgrp = e->e_qgrp;
		else if (!ISVALIDQGRP(q->q_qgrp))
		{
			/* call ruleset which should return a queue group */
			i = rscap(RS_QUEUEGROUP, q->q_user, NULL, e, &pvp,
				  pvpbuf, sizeof(pvpbuf));
			if (i == EX_OK &&
			    pvp != NULL && pvp[0] != NULL &&
			    (pvp[0][0] & 0377) == CANONNET &&
			    pvp[1] != NULL && pvp[1][0] != '\0')
			{
				i = name2qid(pvp[1]);
				if (ISVALIDQGRP(i))
				{
					q->q_qgrp = i;
					if (tTd(20, 4))
						sm_syslog(LOG_INFO, NOQID,
							"queue group name %s -> %d",
							pvp[1], i);
					continue;
				}
				else if (LogLevel > 10)
					sm_syslog(LOG_INFO, NOQID,
						"can't find queue group name %s, selection ignored",
						pvp[1]);
			}
			if (q->q_mailer != NULL &&
			    ISVALIDQGRP(q->q_mailer->m_qgrp))
				q->q_qgrp = q->q_mailer->m_qgrp;
			else
				q->q_qgrp = 0;
		}
	}

	/* only one address? nothing to split. */
	if (naddrs <= 1)
		return SM_SPLIT_NONE;

	/* sort the addresses by queue group */
	addrs = sm_rpool_malloc_x(e->e_rpool, naddrs * sizeof(ADDRESS *));
	for (i = 0, q = e->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (QS_IS_DEAD(q->q_state))
			continue;
		addrs[i++] = q;
	}
	qsort(addrs, naddrs, sizeof(ADDRESS *), q_qgrp_compare);

	/* split into multiple envelopes, by queue group */
	nsplits = 0;
	es = NULL;
	e->e_sendqueue = NULL;
	for (i = 0; i < naddrs; ++i)
	{
		if (i == naddrs - 1 || addrs[i]->q_qgrp != addrs[i + 1]->q_qgrp)
			addrs[i]->q_next = NULL;
		else
			addrs[i]->q_next = addrs[i + 1];

		/* same queue group as original envelope? */
		if (addrs[i]->q_qgrp == e->e_qgrp)
		{
			if (e->e_sendqueue == NULL)
				e->e_sendqueue = addrs[i];
			continue;
		}

		/* different queue group than original envelope */
		if (es == NULL || addrs[i]->q_qgrp != es->e_qgrp)
		{
			ee = split_env(e, addrs[i], addrs[i]->q_qgrp, NOQDIR);
			es = ee;
			splits[nsplits++] = ee;
		}
	}

	/* no splits? return right now. */
	if (nsplits <= 0)
		return SM_SPLIT_NONE;

	/* assign a queue directory to each additional envelope */
	for (i = 0; i < nsplits; ++i)
	{
		es = splits[i];
#if 0
		es->e_qdir = pickqdir(Queue[es->e_qgrp], es->e_msgsize, es);
#endif /* 0 */
		if (!setnewqueue(es))
			goto failure;
	}

	/* sort the additional envelopes by queue file system */
	qsort(splits, nsplits, sizeof(ENVELOPE *), e_filesys_compare);

	/* create data files for each additional envelope */
	if (!dup_df(e, splits[0]))
		goto failure;
	for (i = 1; i < nsplits; ++i)
	{
		/* copy or link to the previous data file */
		if (!dup_df(splits[i - 1], splits[i]))
			goto failure;
	}

	/* success: prepend the new envelopes to the e->e_sibling list */
	for (i = 0; i < nsplits; ++i)
	{
		es = splits[i];
		es->e_sibling = e->e_sibling;
		e->e_sibling = es;
	}
	return SM_SPLIT_NEW(nsplits);

	/* failure: clean up */
  failure:
	e->e_flags |= EF_FATALERRS;
	e->e_sendqueue = addrs[0];
	for (i = 0; i < naddrs - 1; ++i)
		addrs[i]->q_next = addrs[i + 1];
	addrs[naddrs - 1]->q_next = NULL;
	return SM_SPLIT_FAIL;
}

/*
**  SPLIT_WITHIN_QUEUE
**
**	Split an envelope with multiple recipients into several
**	envelopes within the same queue directory, if the number of
**	recipients exceeds the limit for the queue group.
**
**	Parameters:
**		e -- envelope.
**
**	Results:
**		SM_SPLIT_FAIL on failure
**		SM_SPLIT_NONE if no splitting occurred,
**		or 1 + the number of additional envelopes created.
*/

#define SPLIT_LOG_LEVEL	8

static int	split_within_queue __P((ENVELOPE *));

static int
split_within_queue(e)
	ENVELOPE *e;
{
	int maxrcpt, nrcpt, ndead, nsplit, i;
	int j, l;
	char *lsplits;
	ADDRESS *q, **addrs;
	ENVELOPE *ee, *firstsibling;

	if (!ISVALIDQGRP(e->e_qgrp) || bitset(EF_SPLIT, e->e_flags))
		return SM_SPLIT_NONE;

	/* don't bother if there is no recipient limit */
	maxrcpt = Queue[e->e_qgrp]->qg_maxrcpt;
	if (maxrcpt <= 0)
		return SM_SPLIT_NONE;

	/* count recipients */
	nrcpt = 0;
	for (q = e->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (QS_IS_DEAD(q->q_state))
			continue;
		++nrcpt;
	}
	if (nrcpt <= maxrcpt)
		return SM_SPLIT_NONE;

	/*
	**  Preserve the recipient list
	**  so that we can restore it in case of error.
	**  (But we discard dead addresses.)
	*/

	addrs = sm_rpool_malloc_x(e->e_rpool, nrcpt * sizeof(ADDRESS *));
	for (i = 0, q = e->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (QS_IS_DEAD(q->q_state))
			continue;
		addrs[i++] = q;
	}

	/*
	**  Partition the recipient list so that bad and sent addresses
	**  come first. These will go with the original envelope, and
	**  do not count towards the maxrcpt limit.
	**  addrs[] does not contain QS_IS_DEAD() addresses.
	*/

	ndead = 0;
	for (i = 0; i < nrcpt; ++i)
	{
		if (QS_IS_BADADDR(addrs[i]->q_state) ||
		    QS_IS_SENT(addrs[i]->q_state) ||
		    QS_IS_DEAD(addrs[i]->q_state)) /* for paranoia's sake */
		{
			if (i > ndead)
			{
				ADDRESS *tmp = addrs[i];

				addrs[i] = addrs[ndead];
				addrs[ndead] = tmp;
			}
			++ndead;
		}
	}

	/* Check if no splitting required. */
	if (nrcpt - ndead <= maxrcpt)
		return SM_SPLIT_NONE;

	/* fix links */
	for (i = 0; i < nrcpt - 1; ++i)
		addrs[i]->q_next = addrs[i + 1];
	addrs[nrcpt - 1]->q_next = NULL;
	e->e_sendqueue = addrs[0];

	/* prepare buffer for logging */
	if (LogLevel > SPLIT_LOG_LEVEL)
	{
		l = MAXLINE;
		lsplits = sm_malloc(l);
		if (lsplits != NULL)
			*lsplits = '\0';
		j = 0;
	}
	else
	{
		/* get rid of stupid compiler warnings */
		lsplits = NULL;
		j = l = 0;
	}

	/* split the envelope */
	firstsibling = e->e_sibling;
	i = maxrcpt + ndead;
	nsplit = 0;
	for (;;)
	{
		addrs[i - 1]->q_next = NULL;
		ee = split_env(e, addrs[i], e->e_qgrp, e->e_qdir);
		if (!dup_df(e, ee))
		{
			/* Error.  Restore e's sibling & recipient lists. */
			e->e_sibling = firstsibling;
			for (i = 0; i < nrcpt - 1; ++i)
				addrs[i]->q_next = addrs[i + 1];
			return SM_SPLIT_FAIL;
		}

		/* prepend the new envelope to e->e_sibling */
		ee->e_sibling = e->e_sibling;
		e->e_sibling = ee;
		++nsplit;
		if (LogLevel > SPLIT_LOG_LEVEL && lsplits != NULL)
		{
			if (j >= l - strlen(ee->e_id) - 3)
			{
				char *p;

				l += MAXLINE;
				p = sm_realloc(lsplits, l);
				if (p == NULL)
				{
					/* let's try to get this done */
					sm_free(lsplits);
					lsplits = NULL;
				}
				else
					lsplits = p;
			}
			if (lsplits != NULL)
			{
				if (j == 0)
					j += sm_strlcat(lsplits + j,
							ee->e_id,
							l - j);
				else
					j += sm_strlcat2(lsplits + j,
							 "; ",
							 ee->e_id,
							 l - j);
				SM_ASSERT(j < l);
			}
		}
		if (nrcpt - i <= maxrcpt)
			break;
		i += maxrcpt;
	}
	if (LogLevel > SPLIT_LOG_LEVEL && lsplits != NULL && nsplit > 0)
	{
		sm_syslog(LOG_NOTICE, e->e_id,
			  "split: maxrcpts=%d, rcpts=%d, count=%d, id%s=%s",
			  maxrcpt, nrcpt - ndead, nsplit,
			  nsplit > 1 ? "s" : "", lsplits);
		sm_free(lsplits);
	}
	return SM_SPLIT_NEW(nsplit);
}
/*
**  SPLIT_BY_RECIPIENT
**
**	Split an envelope with multiple recipients into multiple
**	envelopes as required by the sendmail configuration.
**
**	Parameters:
**		e -- envelope.
**
**	Results:
**		Returns true on success, false on failure.
**
**	Side Effects:
**		see split_across_queue_groups(), split_within_queue(e)
*/

bool
split_by_recipient(e)
	ENVELOPE *e;
{
	int split, n, i, j, l;
	char *lsplits;
	ENVELOPE *ee, *next, *firstsibling;

	if (OpMode == SM_VERIFY || !ISVALIDQGRP(e->e_qgrp) ||
	    bitset(EF_SPLIT, e->e_flags))
		return true;
	n = split_across_queue_groups(e);
	if (n == SM_SPLIT_FAIL)
		return false;
	firstsibling = ee = e->e_sibling;
	if (n > 1 && LogLevel > SPLIT_LOG_LEVEL)
	{
		l = MAXLINE;
		lsplits = sm_malloc(l);
		if (lsplits != NULL)
			*lsplits = '\0';
		j = 0;
	}
	else
	{
		/* get rid of stupid compiler warnings */
		lsplits = NULL;
		j = l = 0;
	}
	for (i = 1; i < n; ++i)
	{
		next = ee->e_sibling;
		if (split_within_queue(ee) == SM_SPLIT_FAIL)
		{
			e->e_sibling = firstsibling;
			return false;
		}
		ee->e_flags |= EF_SPLIT;
		if (LogLevel > SPLIT_LOG_LEVEL && lsplits != NULL)
		{
			if (j >= l - strlen(ee->e_id) - 3)
			{
				char *p;

				l += MAXLINE;
				p = sm_realloc(lsplits, l);
				if (p == NULL)
				{
					/* let's try to get this done */
					sm_free(lsplits);
					lsplits = NULL;
				}
				else
					lsplits = p;
			}
			if (lsplits != NULL)
			{
				if (j == 0)
					j += sm_strlcat(lsplits + j,
							ee->e_id, l - j);
				else
					j += sm_strlcat2(lsplits + j, "; ",
							 ee->e_id, l - j);
				SM_ASSERT(j < l);
			}
		}
		ee = next;
	}
	if (LogLevel > SPLIT_LOG_LEVEL && lsplits != NULL && n > 1)
	{
		sm_syslog(LOG_NOTICE, e->e_id, "split: count=%d, id%s=%s",
			  n - 1, n > 2 ? "s" : "", lsplits);
		sm_free(lsplits);
	}
	split = split_within_queue(e) != SM_SPLIT_FAIL;
	if (split)
		e->e_flags |= EF_SPLIT;
	return split;
}
@


