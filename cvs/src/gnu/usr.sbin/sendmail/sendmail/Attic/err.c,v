head	1.13;
access;
symbols
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.10
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.8
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.6
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.4
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.10.0.18
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.16
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.12
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.14
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.10
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.8
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.6
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.4
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.9.0.10
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.8
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.8.0.10
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.6
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.8
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.12;
commitid	M7i5giHIoz3DMlTU;

1.12
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2011.05.17.15.54.23;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.24.03.59.27;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.01.17.18.30;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.21.16.31.45;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.01.01.01.41;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.29.01.31.15;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.15.21.09.08;	author millert;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.04.02.19.05.45;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.45;	author millert;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.13;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.50;	author millert;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	2001.05.31.00.31.34;	author miod;	state Exp;
branches;
next	;

1.2.2.1
date	2001.05.31.01.47.56;	author jason;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2003, 2010 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>

SM_RCSID("@@(#)$Sendmail: err.c,v 8.206 2013/11/22 20:51:55 ca Exp $")

#if LDAPMAP
# include <lber.h>
# include <ldap.h>			/* for LDAP error codes */
#endif /* LDAPMAP */

static void	putoutmsg __P((char *, bool, bool));
static void	puterrmsg __P((char *));
static char	*fmtmsg __P((char *, const char *, const char *, const char *,
			     int, const char *, va_list));

/*
**  FATAL_ERROR -- handle a fatal exception
**
**	This function is installed as the default exception handler
**	in the main sendmail process, and in all child processes
**	that we create.  Its job is to handle exceptions that are not
**	handled at a lower level.
**
**	The theory is that unhandled exceptions will be 'fatal' class
**	exceptions (with an "F:" prefix), such as the out-of-memory
**	exception "F:sm.heap".  As such, they are handled by exiting
**	the process in exactly the same way that xalloc() in Sendmail 8.10
**	exits the process when it fails due to lack of memory:
**	we call syserr with a message beginning with "!".
**
**	Parameters:
**		exc -- exception which is terminating this process
**
**	Returns:
**		none
*/

void
fatal_error(exc)
	SM_EXC_T *exc;
{
	static char buf[256];
	SM_FILE_T f;

	/*
	**  This function may be called when the heap is exhausted.
	**  The following code writes the message for 'exc' into our
	**  static buffer without allocating memory or raising exceptions.
	*/

	sm_strio_init(&f, buf, sizeof(buf));
	sm_exc_write(exc, &f);
	(void) sm_io_flush(&f, SM_TIME_DEFAULT);

	/*
	**  Terminate the process after logging an error and cleaning up.
	**  Problems:
	**  - syserr decides what class of error this is by looking at errno.
	**    That's no good; we should look at the exc structure.
	**  - The cleanup code should be moved out of syserr
	**    and into individual exception handlers
	**    that are part of the module they clean up after.
	*/

	errno = ENOMEM;
	syserr("!%s", buf);
}

/*
**  SYSERR -- Print error message.
**
**	Prints an error message via sm_io_printf to the diagnostic output.
**
**	If the first character of the syserr message is `!' it will
**	log this as an ALERT message and exit immediately.  This can
**	leave queue files in an indeterminate state, so it should not
**	be used lightly.
**
**	If the first character of the syserr message is '!' or '@@'
**	then syserr knows that the process is about to be terminated,
**	so the SMTP reply code defaults to 421.  Otherwise, the
**	reply code defaults to 451 or 554, depending on errno.
**
**	Parameters:
**		fmt -- the format string.  An optional '!' or '@@',
**			followed by an optional three-digit SMTP
**			reply code, followed by message text.
**		(others) -- parameters
**
**	Returns:
**		none
**		Raises E:mta.quickabort if QuickAbort is set.
**
**	Side Effects:
**		increments Errors.
**		sets ExitStat.
*/

char		MsgBuf[BUFSIZ*2];	/* text of most recent message */
static char	HeldMessageBuf[sizeof(MsgBuf)];	/* for held messages */

#if NAMED_BIND && !defined(NO_DATA)
# define NO_DATA	NO_ADDRESS
#endif /* NAMED_BIND && !defined(NO_DATA) */

void
/*VARARGS1*/
#ifdef __STDC__
syserr(const char *fmt, ...)
#else /* __STDC__ */
syserr(fmt, va_alist)
	const char *fmt;
	va_dcl
#endif /* __STDC__ */
{
	register char *p;
	int save_errno = errno;
	bool panic;
	bool exiting;
	char *user;
	char *enhsc;
	char *errtxt;
	struct passwd *pw;
	char ubuf[80];
	SM_VA_LOCAL_DECL

	switch (*fmt)
	{
	  case '!':
		++fmt;
		panic = true;
		exiting = true;
		break;
	  case '@@':
		++fmt;
		panic = false;
		exiting = true;
		break;
	  default:
		panic = false;
		exiting = false;
		break;
	}

	/* format and output the error message */
	if (exiting)
	{
		/*
		**  Since we are terminating the process,
		**  we are aborting the entire SMTP session,
		**  rather than just the current transaction.
		*/

		p = "421";
		enhsc = "4.0.0";
	}
	else if (save_errno == 0)
	{
		p = "554";
		enhsc = "5.0.0";
	}
	else
	{
		p = "451";
		enhsc = "4.0.0";
	}
	SM_VA_START(ap, fmt);
	errtxt = fmtmsg(MsgBuf, (char *) NULL, p, enhsc, save_errno, fmt, ap);
	SM_VA_END(ap);
	puterrmsg(MsgBuf);

	/* save this message for mailq printing */
	if (!panic && CurEnv != NULL)
	{
		char *nmsg = sm_rpool_strdup_x(CurEnv->e_rpool, errtxt);

		if (CurEnv->e_rpool == NULL && CurEnv->e_message != NULL)
			sm_free(CurEnv->e_message);
		CurEnv->e_message = nmsg;
	}

	/* determine exit status if not already set */
	if (ExitStat == EX_OK)
	{
		if (save_errno == 0)
			ExitStat = EX_SOFTWARE;
		else
			ExitStat = EX_OSERR;
		if (tTd(54, 1))
			sm_dprintf("syserr: ExitStat = %d\n", ExitStat);
	}

	pw = sm_getpwuid(RealUid);
	if (pw != NULL)
		user = pw->pw_name;
	else
	{
		user = ubuf;
		(void) sm_snprintf(ubuf, sizeof(ubuf), "UID%d", (int) RealUid);
	}

	if (LogLevel > 0)
		sm_syslog(panic ? LOG_ALERT : LOG_CRIT,
			  CurEnv == NULL ? NOQID : CurEnv->e_id,
			  "SYSERR(%s): %.900s",
			  user, errtxt);
	switch (save_errno)
	{
	  case EBADF:
	  case ENFILE:
	  case EMFILE:
	  case ENOTTY:
#ifdef EFBIG
	  case EFBIG:
#endif /* EFBIG */
#ifdef ESPIPE
	  case ESPIPE:
#endif /* ESPIPE */
#ifdef EPIPE
	  case EPIPE:
#endif /* EPIPE */
#ifdef ENOBUFS
	  case ENOBUFS:
#endif /* ENOBUFS */
#ifdef ESTALE
	  case ESTALE:
#endif /* ESTALE */
		printopenfds(true);
		mci_dump_all(smioout, true);
		break;
	}
	if (panic)
	{
#if XLA
		xla_all_end();
#endif /* XLA */
		sync_queue_time();
		if (tTd(0, 1))
			abort();
		exit(EX_OSERR);
	}
	errno = 0;
	if (QuickAbort)
		sm_exc_raisenew_x(&EtypeQuickAbort, 2);
}
/*
**  USRERR -- Signal user error.
**
**	This is much like syserr except it is for user errors.
**
**	Parameters:
**		fmt -- the format string.  If it does not begin with
**			a three-digit SMTP reply code, 550 is assumed.
**		(others) -- sm_io_printf strings
**
**	Returns:
**		none
**		Raises E:mta.quickabort if QuickAbort is set.
**
**	Side Effects:
**		increments Errors.
*/

/*VARARGS1*/
void
#ifdef __STDC__
usrerr(const char *fmt, ...)
#else /* __STDC__ */
usrerr(fmt, va_alist)
	const char *fmt;
	va_dcl
#endif /* __STDC__ */
{
	char *enhsc;
	char *errtxt;
	SM_VA_LOCAL_DECL

	if (fmt[0] == '5' || fmt[0] == '6')
		enhsc = "5.0.0";
	else if (fmt[0] == '4' || fmt[0] == '8')
		enhsc = "4.0.0";
	else if (fmt[0] == '2')
		enhsc = "2.0.0";
	else
		enhsc = NULL;
	SM_VA_START(ap, fmt);
	errtxt = fmtmsg(MsgBuf, CurEnv->e_to, "550", enhsc, 0, fmt, ap);
	SM_VA_END(ap);

	if (SuprErrs)
		return;

	/* save this message for mailq printing */
	switch (MsgBuf[0])
	{
	  case '4':
	  case '8':
		if (CurEnv->e_message != NULL)
			break;

		/* FALLTHROUGH */

	  case '5':
	  case '6':
		if (CurEnv->e_rpool == NULL && CurEnv->e_message != NULL)
			sm_free(CurEnv->e_message);
		if (MsgBuf[0] == '6')
		{
			char buf[MAXLINE];

			(void) sm_snprintf(buf, sizeof(buf),
					   "Postmaster warning: %.*s",
					   (int) sizeof(buf) - 22, errtxt);
			CurEnv->e_message =
				sm_rpool_strdup_x(CurEnv->e_rpool, buf);
		}
		else
		{
			CurEnv->e_message =
				sm_rpool_strdup_x(CurEnv->e_rpool, errtxt);
		}
		break;
	}

	puterrmsg(MsgBuf);
	if (LogLevel > 3 && LogUsrErrs)
		sm_syslog(LOG_NOTICE, CurEnv->e_id, "%.900s", errtxt);
	if (QuickAbort)
		sm_exc_raisenew_x(&EtypeQuickAbort, 1);
}
/*
**  USRERRENH -- Signal user error.
**
**	Same as usrerr but with enhanced status code.
**
**	Parameters:
**		enhsc -- the enhanced status code.
**		fmt -- the format string.  If it does not begin with
**			a three-digit SMTP reply code, 550 is assumed.
**		(others) -- sm_io_printf strings
**
**	Returns:
**		none
**		Raises E:mta.quickabort if QuickAbort is set.
**
**	Side Effects:
**		increments Errors.
*/

/*VARARGS2*/
void
#ifdef __STDC__
usrerrenh(char *enhsc, const char *fmt, ...)
#else /* __STDC__ */
usrerrenh(enhsc, fmt, va_alist)
	char *enhsc;
	const char *fmt;
	va_dcl
#endif /* __STDC__ */
{
	char *errtxt;
	SM_VA_LOCAL_DECL

	if (enhsc == NULL || *enhsc == '\0')
	{
		if (fmt[0] == '5' || fmt[0] == '6')
			enhsc = "5.0.0";
		else if (fmt[0] == '4' || fmt[0] == '8')
			enhsc = "4.0.0";
		else if (fmt[0] == '2')
			enhsc = "2.0.0";
	}
	SM_VA_START(ap, fmt);
	errtxt = fmtmsg(MsgBuf, CurEnv->e_to, "550", enhsc, 0, fmt, ap);
	SM_VA_END(ap);

	if (SuprErrs)
		return;

	/* save this message for mailq printing */
	switch (MsgBuf[0])
	{
	  case '4':
	  case '8':
		if (CurEnv->e_message != NULL)
			break;

		/* FALLTHROUGH */

	  case '5':
	  case '6':
		if (CurEnv->e_rpool == NULL && CurEnv->e_message != NULL)
			sm_free(CurEnv->e_message);
		if (MsgBuf[0] == '6')
		{
			char buf[MAXLINE];

			(void) sm_snprintf(buf, sizeof(buf),
					   "Postmaster warning: %.*s",
					   (int) sizeof(buf) - 22, errtxt);
			CurEnv->e_message =
				sm_rpool_strdup_x(CurEnv->e_rpool, buf);
		}
		else
		{
			CurEnv->e_message =
				sm_rpool_strdup_x(CurEnv->e_rpool, errtxt);
		}
		break;
	}

	puterrmsg(MsgBuf);
	if (LogLevel > 3 && LogUsrErrs)
		sm_syslog(LOG_NOTICE, CurEnv->e_id, "%.900s", errtxt);
	if (QuickAbort)
		sm_exc_raisenew_x(&EtypeQuickAbort, 1);
}

/*
**  MESSAGE -- print message (not necessarily an error)
**
**	Parameters:
**		msg -- the message (sm_io_printf fmt) -- it can begin with
**			an SMTP reply code.  If not, 050 is assumed.
**		(others) -- sm_io_printf arguments
**
**	Returns:
**		none
**
**	Side Effects:
**		none.
*/

/*VARARGS1*/
void
#ifdef __STDC__
message(const char *msg, ...)
#else /* __STDC__ */
message(msg, va_alist)
	const char *msg;
	va_dcl
#endif /* __STDC__ */
{
	char *errtxt;
	SM_VA_LOCAL_DECL

	errno = 0;
	SM_VA_START(ap, msg);
	errtxt = fmtmsg(MsgBuf, CurEnv->e_to, "050", (char *) NULL, 0, msg, ap);
	SM_VA_END(ap);
	putoutmsg(MsgBuf, false, false);

	/* save this message for mailq printing */
	switch (MsgBuf[0])
	{
	  case '4':
	  case '8':
		if (CurEnv->e_message != NULL)
			break;
		/* FALLTHROUGH */

	  case '5':
		if (CurEnv->e_rpool == NULL && CurEnv->e_message != NULL)
			sm_free(CurEnv->e_message);
		CurEnv->e_message = sm_rpool_strdup_x(CurEnv->e_rpool, errtxt);
		break;
	}
}


/*
**  NMESSAGE -- print message (not necessarily an error)
**
**	Just like "message" except it never puts the to... tag on.
**
**	Parameters:
**		msg -- the message (sm_io_printf fmt) -- if it begins
**			with a three digit SMTP reply code, that is used,
**			otherwise 050 is assumed.
**		(others) -- sm_io_printf arguments
**
**	Returns:
**		none
**
**	Side Effects:
**		none.
*/

/*VARARGS1*/
void
#ifdef __STDC__
nmessage(const char *msg, ...)
#else /* __STDC__ */
nmessage(msg, va_alist)
	const char *msg;
	va_dcl
#endif /* __STDC__ */
{
	char *errtxt;
	SM_VA_LOCAL_DECL

	errno = 0;
	SM_VA_START(ap, msg);
	errtxt = fmtmsg(MsgBuf, (char *) NULL, "050",
			(char *) NULL, 0, msg, ap);
	SM_VA_END(ap);
	putoutmsg(MsgBuf, false, false);

	/* save this message for mailq printing */
	switch (MsgBuf[0])
	{
	  case '4':
	  case '8':
		if (CurEnv->e_message != NULL)
			break;
		/* FALLTHROUGH */

	  case '5':
		if (CurEnv->e_rpool == NULL && CurEnv->e_message != NULL)
			sm_free(CurEnv->e_message);
		CurEnv->e_message = sm_rpool_strdup_x(CurEnv->e_rpool, errtxt);
		break;
	}
}
/*
**  PUTOUTMSG -- output error message to transcript and channel
**
**	Parameters:
**		msg -- message to output (in SMTP format).
**		holdmsg -- if true, don't output a copy of the message to
**			our output channel.
**		heldmsg -- if true, this is a previously held message;
**			don't log it to the transcript file.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Outputs msg to the transcript.
**		If appropriate, outputs it to the channel.
**		Deletes SMTP reply code number as appropriate.
*/

static void
putoutmsg(msg, holdmsg, heldmsg)
	char *msg;
	bool holdmsg;
	bool heldmsg;
{
	char msgcode = msg[0];
	char *errtxt = msg;
	char *id;

	/* display for debugging */
	if (tTd(54, 8))
		sm_dprintf("--- %s%s%s\n", msg, holdmsg ? " (hold)" : "",
			heldmsg ? " (held)" : "");

	/* map warnings to something SMTP can handle */
	if (msgcode == '6')
		msg[0] = '5';
	else if (msgcode == '8')
		msg[0] = '4';
	id = (CurEnv != NULL) ? CurEnv->e_id : NULL;

	/* output to transcript if serious */
	if (!heldmsg && CurEnv != NULL && CurEnv->e_xfp != NULL &&
	    strchr("45", msg[0]) != NULL)
		(void) sm_io_fprintf(CurEnv->e_xfp, SM_TIME_DEFAULT, "%s\n",
				     msg);

	if (LogLevel > 14 && (OpMode == MD_SMTP || OpMode == MD_DAEMON))
		sm_syslog(LOG_INFO, id,
			  "--- %s%s%s", msg, holdmsg ? " (hold)" : "",
			  heldmsg ? " (held)" : "");

	if (msgcode == '8')
		msg[0] = '0';

	/* output to channel if appropriate */
	if (!Verbose && msg[0] == '0')
		return;
	if (holdmsg)
	{
		/* save for possible future display */
		msg[0] = msgcode;
		if (HeldMessageBuf[0] == '5' && msgcode == '4')
			return;
		(void) sm_strlcpy(HeldMessageBuf, msg, sizeof(HeldMessageBuf));
		return;
	}

	(void) sm_io_flush(smioout, SM_TIME_DEFAULT);

	if (OutChannel == NULL)
		return;

	/* find actual text of error (after SMTP status codes) */
	if (ISSMTPREPLY(errtxt))
	{
		int l;

		errtxt += 4;
		l = isenhsc(errtxt, ' ');
		if (l <= 0)
			l = isenhsc(errtxt, '\0');
		if (l > 0)
			errtxt += l + 1;
	}

	/* if DisConnected, OutChannel now points to the transcript */
	if (!DisConnected &&
	    (OpMode == MD_SMTP || OpMode == MD_DAEMON || OpMode == MD_ARPAFTP))
		(void) sm_io_fprintf(OutChannel, SM_TIME_DEFAULT, "%s\r\n",
				     msg);
	else
		(void) sm_io_fprintf(OutChannel, SM_TIME_DEFAULT, "%s\n",
				     errtxt);
	if (TrafficLogFile != NULL)
		(void) sm_io_fprintf(TrafficLogFile, SM_TIME_DEFAULT,
				     "%05d >>> %s\n", (int) CurrentPid,
				     (OpMode == MD_SMTP || OpMode == MD_DAEMON)
					? msg : errtxt);
#if !PIPELINING
	/* XXX can't flush here for SMTP pipelining */
	if (msg[3] == ' ')
		(void) sm_io_flush(OutChannel, SM_TIME_DEFAULT);
	if (!sm_io_error(OutChannel) || DisConnected)
		return;

	/*
	**  Error on output -- if reporting lost channel, just ignore it.
	**  Also, ignore errors from QUIT response (221 message) -- some
	**	rude servers don't read result.
	*/

	if (InChannel == NULL || sm_io_eof(InChannel) ||
	    sm_io_error(InChannel) || strncmp(msg, "221", 3) == 0)
		return;

	/* can't call syserr, 'cause we are using MsgBuf */
	HoldErrs = true;
	if (LogLevel > 0)
		sm_syslog(LOG_CRIT, id,
			  "SYSERR: putoutmsg (%s): error on output channel sending \"%s\": %s",
			  CURHOSTNAME,
			  shortenstring(msg, MAXSHORTSTR), sm_errstring(errno));
#endif /* !PIPELINING */
}
/*
**  PUTERRMSG -- like putoutmsg, but does special processing for error messages
**
**	Parameters:
**		msg -- the message to output.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets the fatal error bit in the envelope as appropriate.
*/

static void
puterrmsg(msg)
	char *msg;
{
	char msgcode = msg[0];

	/* output the message as usual */
	putoutmsg(msg, HoldErrs, false);

	/* be careful about multiple error messages */
	if (OnlyOneError)
		HoldErrs = true;

	/* signal the error */
	Errors++;

	if (CurEnv == NULL)
		return;

	if (msgcode == '6')
	{
		/* notify the postmaster */
		CurEnv->e_flags |= EF_PM_NOTIFY;
	}
	else if (msgcode == '5' && bitset(EF_GLOBALERRS, CurEnv->e_flags))
	{
		/* mark long-term fatal errors */
		CurEnv->e_flags |= EF_FATALERRS;
	}
}
/*
**  ISENHSC -- check whether a string contains an enhanced status code
**
**	Parameters:
**		s -- string with possible enhanced status code.
**		delim -- delim for enhanced status code.
**
**	Returns:
**		0  -- no enhanced status code.
**		>4 -- length of enhanced status code.
**
**	Side Effects:
**		none.
*/
int
isenhsc(s, delim)
	const char *s;
	int delim;
{
	int l, h;

	if (s == NULL)
		return 0;
	if (!((*s == '2' || *s == '4' || *s == '5') && s[1] == '.'))
		return 0;
	h = 0;
	l = 2;
	while (h < 3 && isascii(s[l + h]) && isdigit(s[l + h]))
		++h;
	if (h == 0 || s[l + h] != '.')
		return 0;
	l += h + 1;
	h = 0;
	while (h < 3 && isascii(s[l + h]) && isdigit(s[l + h]))
		++h;
	if (h == 0 || s[l + h] != delim)
		return 0;
	return l + h;
}
/*
**  EXTENHSC -- check and extract an enhanced status code
**
**	Parameters:
**		s -- string with possible enhanced status code.
**		delim -- delim for enhanced status code.
**		e -- pointer to storage for enhanced status code.
**			must be != NULL and have space for at least
**			10 characters ([245].[0-9]{1,3}.[0-9]{1,3})
**
**	Returns:
**		0  -- no enhanced status code.
**		>4 -- length of enhanced status code.
**
**	Side Effects:
**		fills e with enhanced status code.
*/

int
extenhsc(s, delim, e)
	const char *s;
	int delim;
	char *e;
{
	int l, h;

	if (s == NULL)
		return 0;
	if (!((*s == '2' || *s == '4' || *s == '5') && s[1] == '.'))
		return 0;
	h = 0;
	l = 2;
	e[0] = s[0];
	e[1] = '.';
	while (h < 3 && isascii(s[l + h]) && isdigit(s[l + h]))
	{
		e[l + h] = s[l + h];
		++h;
	}
	if (h == 0 || s[l + h] != '.')
		return 0;
	e[l + h] = '.';
	l += h + 1;
	h = 0;
	while (h < 3 && isascii(s[l + h]) && isdigit(s[l + h]))
	{
		e[l + h] = s[l + h];
		++h;
	}
	if (h == 0 || s[l + h] != delim)
		return 0;
	e[l + h] = '\0';
	return l + h;
}
/*
**  FMTMSG -- format a message into buffer.
**
**	Parameters:
**		eb -- error buffer to get result -- MUST BE MsgBuf.
**		to -- the recipient tag for this message.
**		num -- default three digit SMTP reply code.
**		enhsc -- enhanced status code.
**		en -- the error number to display.
**		fmt -- format of string.
**		ap -- arguments for fmt.
**
**	Returns:
**		pointer to error text beyond status codes.
**
**	Side Effects:
**		none.
*/

static char *
fmtmsg(eb, to, num, enhsc, eno, fmt, ap)
	register char *eb;
	const char *to;
	const char *num;
	const char *enhsc;
	int eno;
	const char *fmt;
	SM_VA_LOCAL_DECL
{
	char del;
	int l;
	int spaceleft = sizeof(MsgBuf);
	char *errtxt;

	/* output the reply code */
	if (ISSMTPCODE(fmt))
	{
		num = fmt;
		fmt += 4;
	}
	if (num[3] == '-')
		del = '-';
	else
		del = ' ';
	if (SoftBounce && num[0] == '5')
	{
		/* replace 5 by 4 */
		(void) sm_snprintf(eb, spaceleft, "4%2.2s%c", num + 1, del);
	}
	else
		(void) sm_snprintf(eb, spaceleft, "%3.3s%c", num, del);
	eb += 4;
	spaceleft -= 4;

	if ((l = isenhsc(fmt, ' ' )) > 0 && l < spaceleft - 4)
	{
		/* copy enh.status code including trailing blank */
		l++;
		(void) sm_strlcpy(eb, fmt, l + 1);
		eb += l;
		spaceleft -= l;
		fmt += l;
	}
	else if ((l = isenhsc(enhsc, '\0')) > 0 && l < spaceleft - 4)
	{
		/* copy enh.status code */
		(void) sm_strlcpy(eb, enhsc, l + 1);
		eb[l] = ' ';
		eb[++l] = '\0';
		eb += l;
		spaceleft -= l;
	}
	if (SoftBounce && eb[-l] == '5')
	{
		/* replace 5 by 4 */
		eb[-l] = '4';
	}
	errtxt = eb;

	/* output the file name and line number */
	if (FileName != NULL)
	{
		(void) sm_snprintf(eb, spaceleft, "%s: line %d: ",
				   shortenstring(FileName, 83), LineNumber);
		eb += (l = strlen(eb));
		spaceleft -= l;
	}

	/*
	**  output the "to" address only if it is defined and one of the
	**  following codes is used:
	**  050 internal notices, e.g., alias expansion
	**  250 Ok
	**  252 Cannot VRFY user, but will accept message and attempt delivery
	**  450 Requested mail action not taken: mailbox unavailable
	**  550 Requested action not taken: mailbox unavailable
	**  553 Requested action not taken: mailbox name not allowed
	**
	**  Notice: this still isn't "the right thing", this code shouldn't
	**	(indirectly) depend on CurEnv->e_to.
	*/

	if (to != NULL && to[0] != '\0' &&
	    (strncmp(num, "050", 3) == 0 ||
	     strncmp(num, "250", 3) == 0 ||
	     strncmp(num, "252", 3) == 0 ||
	     strncmp(num, "450", 3) == 0 ||
	     strncmp(num, "550", 3) == 0 ||
	     strncmp(num, "553", 3) == 0))
	{
		(void) sm_strlcpyn(eb, spaceleft, 2,
				   shortenstring(to, MAXSHORTSTR), "... ");
		spaceleft -= strlen(eb);
		while (*eb != '\0')
			*eb++ &= 0177;
	}

	/* output the message */
	(void) sm_vsnprintf(eb, spaceleft, fmt, ap);
	spaceleft -= strlen(eb);
	while (*eb != '\0')
		*eb++ &= 0177;

	/* output the error code, if any */
	if (eno != 0)
		(void) sm_strlcpyn(eb, spaceleft, 2, ": ", sm_errstring(eno));

	return errtxt;
}
/*
**  BUFFER_ERRORS -- arrange to buffer future error messages
**
**	Parameters:
**		none
**
**	Returns:
**		none.
*/

void
buffer_errors()
{
	HeldMessageBuf[0] = '\0';
	HoldErrs = true;
}
/*
**  FLUSH_ERRORS -- flush the held error message buffer
**
**	Parameters:
**		print -- if set, print the message, otherwise just
**			delete it.
**
**	Returns:
**		none.
*/

void
flush_errors(print)
	bool print;
{
	if (print && HeldMessageBuf[0] != '\0')
		putoutmsg(HeldMessageBuf, false, true);
	HeldMessageBuf[0] = '\0';
	HoldErrs = false;
}
/*
**  SM_ERRSTRING -- return string description of error code
**
**	Parameters:
**		errnum -- the error number to translate
**
**	Returns:
**		A string description of errnum.
**
**	Side Effects:
**		none.
*/

const char *
sm_errstring(errnum)
	int errnum;
{
	char *dnsmsg;
	char *bp;
	static char buf[MAXLINE];
#if HASSTRERROR
	char *err;
	char errbuf[30];
#endif /* HASSTRERROR */
#if !HASSTRERROR && !defined(ERRLIST_PREDEFINED)
	extern char *sys_errlist[];
	extern int sys_nerr;
#endif /* !HASSTRERROR && !defined(ERRLIST_PREDEFINED) */

	/*
	**  Handle special network error codes.
	**
	**	These are 4.2/4.3bsd specific; they should be in daemon.c.
	*/

	dnsmsg = NULL;
	switch (errnum)
	{
	  case ETIMEDOUT:
	  case ECONNRESET:
		bp = buf;
#if HASSTRERROR
		err = strerror(errnum);
		if (err == NULL)
		{
			(void) sm_snprintf(errbuf, sizeof(errbuf),
					   "Error %d", errnum);
			err = errbuf;
		}
		(void) sm_strlcpy(bp, err, SPACELEFT(buf, bp));
#else /* HASSTRERROR */
		if (errnum >= 0 && errnum < sys_nerr)
			(void) sm_strlcpy(bp, sys_errlist[errnum],
					  SPACELEFT(buf, bp));
		else
			(void) sm_snprintf(bp, SPACELEFT(buf, bp),
				"Error %d", errnum);
#endif /* HASSTRERROR */
		bp += strlen(bp);
		if (CurHostName != NULL)
		{
			if (errnum == ETIMEDOUT)
			{
				(void) sm_snprintf(bp, SPACELEFT(buf, bp),
					" with ");
				bp += strlen(bp);
			}
			else
			{
				bp = buf;
				(void) sm_snprintf(bp, SPACELEFT(buf, bp),
					"Connection reset by ");
				bp += strlen(bp);
			}
			(void) sm_strlcpy(bp,
					shortenstring(CurHostName, MAXSHORTSTR),
					SPACELEFT(buf, bp));
			bp += strlen(buf);
		}
		if (SmtpPhase != NULL)
		{
			(void) sm_snprintf(bp, SPACELEFT(buf, bp),
				" during %s", SmtpPhase);
		}
		return buf;

	  case EHOSTDOWN:
		if (CurHostName == NULL)
			break;
		(void) sm_snprintf(buf, sizeof(buf), "Host %s is down",
			shortenstring(CurHostName, MAXSHORTSTR));
		return buf;

	  case ECONNREFUSED:
		if (CurHostName == NULL)
			break;
		(void) sm_strlcpyn(buf, sizeof(buf), 2, "Connection refused by ",
			shortenstring(CurHostName, MAXSHORTSTR));
		return buf;

#if NAMED_BIND
	  case HOST_NOT_FOUND + E_DNSBASE:
		dnsmsg = "host not found";
		break;

	  case TRY_AGAIN + E_DNSBASE:
		dnsmsg = "host name lookup failure";
		break;

	  case NO_RECOVERY + E_DNSBASE:
		dnsmsg = "non-recoverable error";
		break;

	  case NO_DATA + E_DNSBASE:
		dnsmsg = "no data known";
		break;
#endif /* NAMED_BIND */

	  case EPERM:
		/* SunOS gives "Not owner" -- this is the POSIX message */
		return "Operation not permitted";

	/*
	**  Error messages used internally in sendmail.
	*/

	  case E_SM_OPENTIMEOUT:
		return "Timeout on file open";

	  case E_SM_NOSLINK:
		return "Symbolic links not allowed";

	  case E_SM_NOHLINK:
		return "Hard links not allowed";

	  case E_SM_REGONLY:
		return "Regular files only";

	  case E_SM_ISEXEC:
		return "Executable files not allowed";

	  case E_SM_WWDIR:
		return "World writable directory";

	  case E_SM_GWDIR:
		return "Group writable directory";

	  case E_SM_FILECHANGE:
		return "File changed after open";

	  case E_SM_WWFILE:
		return "World writable file";

	  case E_SM_GWFILE:
		return "Group writable file";

	  case E_SM_GRFILE:
		return "Group readable file";

	  case E_SM_WRFILE:
		return "World readable file";
	}

	if (dnsmsg != NULL)
	{
		bp = buf;
		bp += sm_strlcpy(bp, "Name server: ", sizeof(buf));
		if (CurHostName != NULL)
		{
			(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2,
				shortenstring(CurHostName, MAXSHORTSTR), ": ");
			bp += strlen(bp);
		}
		(void) sm_strlcpy(bp, dnsmsg, SPACELEFT(buf, bp));
		return buf;
	}

#if LDAPMAP
	if (errnum >= E_LDAPBASE)
		return ldap_err2string(errnum - E_LDAPBASE);
#endif /* LDAPMAP */

#if HASSTRERROR
	err = strerror(errnum);
	if (err == NULL)
	{
		(void) sm_snprintf(buf, sizeof(buf), "Error %d", errnum);
		return buf;
	}
	return err;
#else /* HASSTRERROR */
	if (errnum > 0 && errnum < sys_nerr)
		return sys_errlist[errnum];

	(void) sm_snprintf(buf, sizeof(buf), "Error %d", errnum);
	return buf;
#endif /* HASSTRERROR */
}
@


1.12
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.11
log
@Update to sendmail 8.14.5
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003, 2010 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: err.c,v 8.205 2010/02/03 23:22:41 ca Exp $")
@


1.10
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: err.c,v 8.196 2006/11/10 23:14:08 ca Exp $")
d362 1
a362 1
/*VARARGS1*/
d430 1
d477 1
a477 2
		CurEnv->e_message =
			sm_rpool_strdup_x(CurEnv->e_rpool, errtxt);
d481 2
@


1.9
log
@Update to sendmail.8.13.0
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: err.c,v 8.191 2003/01/10 02:16:46 ca Exp $")
d112 1
a112 1
static char	HeldMessageBuf[sizeof MsgBuf];	/* for held messages */
d211 1
a211 1
		(void) sm_snprintf(ubuf, sizeof ubuf, "UID%d", (int) RealUid);
d323 1
a323 1
			(void) sm_snprintf(buf, sizeof buf,
d325 1
a325 1
					   (int) sizeof buf - 22, errtxt);
d410 1
a410 1
			(void) sm_snprintf(buf, sizeof buf,
d412 1
a412 1
					   (int) sizeof buf - 22, errtxt);
d531 1
a531 2
		CurEnv->e_message =
			sm_rpool_strdup_x(CurEnv->e_rpool, errtxt);
d560 1
d562 1
a562 1
	char msgcode = msg[0];
d574 1
d583 1
a583 1
		sm_syslog(LOG_INFO, CurEnv->e_id,
d599 1
a599 1
		(void) sm_strlcpy(HeldMessageBuf, msg, sizeof HeldMessageBuf);
d654 1
a654 1
		sm_syslog(LOG_CRIT, CurEnv->e_id,
d827 1
a827 1
	int spaceleft = sizeof MsgBuf;
a839 1
#if _FFR_SOFT_BOUNCE
d846 1
a846 2
#endif /* _FFR_SOFT_BOUNCE */
	(void) sm_snprintf(eb, spaceleft, "%3.3s%c", num, del);
a867 1
#if _FFR_SOFT_BOUNCE
a872 1
#endif /* _FFR_SOFT_BOUNCE */
d1006 1
a1006 1
			(void) sm_snprintf(errbuf, sizeof errbuf,
d1050 1
a1050 1
		(void) sm_snprintf(buf, sizeof buf, "Host %s is down",
d1057 1
a1057 1
		(void) sm_strlcpyn(buf, sizeof buf, 2, "Connection refused by ",
d1127 1
a1127 1
		bp += sm_strlcpy(bp, "Name server: ", sizeof buf);
d1147 1
a1147 1
		(void) sm_snprintf(buf, sizeof buf, "Error %d", errnum);
d1155 1
a1155 1
	(void) sm_snprintf(buf, sizeof buf, "Error %d", errnum);
@


1.8
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: err.c,v 8.189 2002/01/09 18:52:30 ca Exp $")
d241 1
a241 1
		mci_dump_all(true);
@


1.7
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: err.c,v 8.187 2001/09/11 04:05:14 gshapiro Exp $")
d984 4
d1006 8
a1013 1
		(void) sm_strlcpy(bp, strerror(errnum), SPACELEFT(buf, bp));
d1147 7
a1153 1
	return strerror(errnum);
@


1.6
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: err.c,v 8.184 2001/09/04 22:43:03 ca Exp $")
d258 1
a258 1
/*
d343 1
a343 1
/*
d430 1
a430 1
/*
d481 1
a481 1
/*
d536 1
a536 1
/*
d659 1
a659 1
/*
d702 1
a702 1
/*
d741 1
a741 1
/*
d795 1
a795 1
/*
d928 1
a928 1
/*
d944 1
a944 1
/*
d964 1
a964 1
/*
@


1.5
log
@Update to sendmail 8.11.6, from the release notes:

SECURITY: Fix a possible memory access violation when specifying
	out-of-bounds debug parameters.  Problem detected by
	Cade Cairns of SecurityFocus.
Avoid leaking recipient information in unrelated DSNs.  This could
	happen if a connection is aborted, several mails had been
	scheduled for delivery via that connection, and the timeout
	is reached such that several DSNs are sent next.  Problem
	noted by Dileepan Moorkanat of Hewlett-Packard.
Fix a possible segmentation violation when specifying too many
	wildcard operators in a rule.  Problem detected by
	Werner Wiethege.
Avoid a segmentation fault on non-matching Hesiod lookups.  Problem
	noted by Russell McOrmond of flora.ca
@
text
@d14 3
a16 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: err.c,v 8.120.4.5 2001/08/17 22:09:40 ca Exp $";
#endif /* ! lint */
d18 1
a18 2
#include <sendmail.h>
#ifdef LDAPMAP
a22 1

d29 53
d84 1
a84 1
**	Prints an error message via printf to the diagnostic output.
d91 5
d97 3
a99 4
**		fmt -- the format string.  If it does not begin with
**			a three-digit SMTP reply code, either 554 or
**			451 is assumed depending on whether errno
**			is set.
d104 1
a104 1
**		Through TopFrame if QuickAbort is set.
d131 1
d137 1
a137 1
	VA_LOCAL_DECL
d139 1
a139 2
	panic = *fmt == '!';
	if (panic)
d141 14
a154 2
		fmt++;
		HoldErrs = FALSE;
d158 12
a169 1
	if (save_errno == 0)
d179 1
a179 1
	VA_START(fmt);
d181 1
a181 1
	VA_END;
d187 3
a189 1
		if (CurEnv->e_message != NULL)
d191 1
a191 1
		CurEnv->e_message = newstr(errtxt);
d202 1
a202 1
			dprintf("syserr: ExitStat = %d\n", ExitStat);
d211 1
a211 1
		snprintf(ubuf, sizeof ubuf, "UID%d", (int) RealUid);
d240 2
a241 2
		printopenfds(TRUE);
		mci_dump_all(TRUE);
d246 1
a246 1
#ifdef XLA
d256 1
a256 1
		longjmp(TopFrame, 2);
d265 2
a266 2
**			a three-digit SMTP reply code, 501 is assumed.
**		(others) -- printf strings
d270 1
a270 1
**		Through TopFrame if QuickAbort is set.
d288 1
a288 1
	VA_LOCAL_DECL
d298 3
a300 3
	VA_START(fmt);
	errtxt = fmtmsg(MsgBuf, CurEnv->e_to, "501", enhsc, 0, fmt, ap);
	VA_END;
d317 1
a317 1
		if (CurEnv->e_message != NULL)
d323 5
a327 3
			snprintf(buf, sizeof buf, "Postmaster warning: %.*s",
				(int) sizeof buf - 22, errtxt);
			CurEnv->e_message = newstr(buf);
d331 2
a332 1
			CurEnv->e_message = newstr(errtxt);
a337 1

a339 1

d341 1
a341 1
		longjmp(TopFrame, 1);
d351 2
a352 2
**			a three-digit SMTP reply code, 501 is assumed.
**		(others) -- printf strings
d356 1
a356 1
**		Through TopFrame if QuickAbort is set.
d374 1
a374 1
	VA_LOCAL_DECL
d385 3
a387 3
	VA_START(fmt);
	errtxt = fmtmsg(MsgBuf, CurEnv->e_to, "501", enhsc, 0, fmt, ap);
	VA_END;
d404 1
a404 1
		if (CurEnv->e_message != NULL)
d410 5
a414 3
			snprintf(buf, sizeof buf, "Postmaster warning: %.*s",
				(int) sizeof buf - 22, errtxt);
			CurEnv->e_message = newstr(buf);
d418 2
a419 1
			CurEnv->e_message = newstr(errtxt);
a424 1

a426 1

d428 1
a428 1
		longjmp(TopFrame, 1);
d434 1
a434 1
**		msg -- the message (printf fmt) -- it can begin with
d436 1
a436 1
**		(others) -- printf arguments
d456 1
a456 1
	VA_LOCAL_DECL
d459 1
a459 1
	VA_START(msg);
d461 2
a462 2
	VA_END;
	putoutmsg(MsgBuf, FALSE, FALSE);
d474 1
a474 1
		if (CurEnv->e_message != NULL)
d476 2
a477 1
		CurEnv->e_message = newstr(errtxt);
d487 1
a487 1
**		msg -- the message (printf fmt) -- if it begins
d490 1
a490 1
**		(others) -- printf arguments
d510 1
a510 1
	VA_LOCAL_DECL
d513 1
a513 1
	VA_START(msg);
d516 2
a517 2
	VA_END;
	putoutmsg(MsgBuf, FALSE, FALSE);
d529 1
a529 1
		if (CurEnv->e_message != NULL)
d531 2
a532 1
		CurEnv->e_message = newstr(errtxt);
d541 1
a541 1
**		holdmsg -- if TRUE, don't output a copy of the message to
d543 1
a543 1
**		heldmsg -- if TRUE, this is a previously held message;
d566 1
a566 1
		dprintf("--- %s%s%s\n", msg, holdmsg ? " (hold)" : "",
d578 2
a579 1
		fprintf(CurEnv->e_xfp, "%s\n", msg);
d581 1
a581 1
	if (LogLevel >= 15 && (OpMode == MD_SMTP || OpMode == MD_DAEMON))
d583 2
a584 2
			  "--> %s%s",
			  msg, holdmsg ? " (held)" : "");
d598 1
a598 1
		snprintf(HeldMessageBuf, sizeof HeldMessageBuf, "%s", msg);
d602 1
a602 1
	(void) fflush(stdout);
d623 2
a624 1
		fprintf(OutChannel, "%s\r\n", msg);
d626 2
a627 1
		fprintf(OutChannel, "%s\n", errtxt);
d629 6
a634 2
		fprintf(TrafficLogFile, "%05d >>> %s\n", (int) getpid(),
			(OpMode == MD_SMTP || OpMode == MD_DAEMON) ? msg : errtxt);
d636 2
a637 2
		(void) fflush(OutChannel);
	if (!ferror(OutChannel) || DisConnected)
d646 2
a647 2
	if (InChannel == NULL || feof(InChannel) || ferror(InChannel) ||
	    strncmp(msg, "221", 3) == 0)
d651 1
a651 1
	HoldErrs = TRUE;
d655 3
a657 2
			  CurHostName == NULL ? "NO-HOST" : CurHostName,
			  shortenstring(msg, MAXSHORTSTR), errstring(errno));
d679 1
a679 1
	putoutmsg(msg, HoldErrs, FALSE);
d683 1
a683 1
		HoldErrs = TRUE;
d758 1
d822 1
a822 1
	va_list ap;
d839 9
a847 1
	(void) snprintf(eb, spaceleft, "%3.3s%c", num, del);
d855 1
a855 1
		(void) strlcpy(eb, fmt, l + 1);
d863 1
a863 1
		(void) strlcpy(eb, enhsc, l + 1);
d869 7
d881 2
a882 2
		(void) snprintf(eb, spaceleft, "%s: line %d: ",
			shortenstring(FileName, 83), LineNumber);
d909 2
a910 2
		(void) snprintf(eb, spaceleft, "%s... ",
			shortenstring(to, MAXSHORTSTR));
d917 1
a917 1
	(void) vsnprintf(eb, spaceleft, fmt, ap);
d924 1
a924 1
		(void) snprintf(eb, spaceleft, ": %s", errstring(eno));
d942 1
a942 1
	HoldErrs = TRUE;
d960 1
a960 1
		putoutmsg(HeldMessageBuf, FALSE, TRUE);
d962 1
a962 1
	HoldErrs = FALSE;
d965 1
a965 1
**  ERRSTRING -- return string description of error code
d978 1
a978 1
errstring(errnum)
a997 1
#if defined(DAEMON) && defined(ETIMEDOUT)
d1001 3
a1003 3
# if HASSTRERROR
		snprintf(bp, SPACELEFT(buf, bp), "%s", strerror(errnum));
# else /* HASSTRERROR */
d1005 2
a1006 1
			snprintf(bp, SPACELEFT(buf, bp), "%s", sys_errlist[errnum]);
d1008 3
a1010 2
			snprintf(bp, SPACELEFT(buf, bp), "Error %d", errnum);
# endif /* HASSTRERROR */
d1016 2
a1017 1
				snprintf(bp, SPACELEFT(buf, bp), " with ");
d1023 1
a1023 1
				snprintf(bp, SPACELEFT(buf, bp),
d1027 3
a1029 2
			snprintf(bp, SPACELEFT(buf, bp), "%s",
				shortenstring(CurHostName, MAXSHORTSTR));
d1034 2
a1035 2
			snprintf(bp, SPACELEFT(buf, bp), " during %s",
				SmtpPhase);
d1042 1
a1042 1
		(void) snprintf(buf, sizeof buf, "Host %s is down",
d1049 1
a1049 1
		(void) snprintf(buf, sizeof buf, "Connection refused by %s",
a1051 1
#endif /* defined(DAEMON) && defined(ETIMEDOUT) */
d1119 1
a1119 1
		bp += strlcpy(bp, "Name server: ", sizeof buf);
d1122 2
a1123 2
			snprintf(bp, SPACELEFT(buf, bp), "%s: ",
				shortenstring(CurHostName, MAXSHORTSTR));
d1126 1
a1126 1
		snprintf(bp, SPACELEFT(buf, bp), "%s", dnsmsg);
d1130 1
a1130 1
#ifdef LDAPMAP
d1141 1
a1141 1
	(void) snprintf(buf, sizeof buf, "Error %d", errnum);
@


1.4
log
@update to sendmail 8.11.5
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: err.c,v 8.120.4.3 2001/05/30 00:22:26 gshapiro Exp $";
d779 14
a792 1
	/* output the "to" person */
d794 6
a799 2
	    strncmp(num, "551", 3) != 0 &&
	    strncmp(num, "251", 3) != 0)
@


1.3
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: err.c,v 8.120.4.2 2001/05/03 17:24:06 gshapiro Exp $";
a159 2


@


1.2
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: err.c,v 8.120.4.1 2000/05/25 18:56:15 gshapiro Exp $";
d110 1
a110 1
			free(CurEnv->e_message);
d125 1
a125 1
	pw = sm_getpwuid(getuid());
d131 1
a131 1
		snprintf(ubuf, sizeof ubuf, "UID%d", (int) getuid());
d240 1
a240 1
			free(CurEnv->e_message);
d326 1
a326 1
			free(CurEnv->e_message);
d395 1
a395 1
			free(CurEnv->e_message);
d449 1
a449 1
			free(CurEnv->e_message);
@


1.2.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: err.c,v 8.120.4.2 2001/05/03 17:24:06 gshapiro Exp $";
d110 1
a110 1
			sm_free(CurEnv->e_message);
d125 1
a125 1
	pw = sm_getpwuid(RealUid);
d131 1
a131 1
		snprintf(ubuf, sizeof ubuf, "UID%d", (int) RealUid);
d240 1
a240 1
			sm_free(CurEnv->e_message);
d326 1
a326 1
			sm_free(CurEnv->e_message);
d395 1
a395 1
			sm_free(CurEnv->e_message);
d449 1
a449 1
			sm_free(CurEnv->e_message);
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: err.c,v 8.120 2000/02/17 21:32:05 ca Exp $";
d24 1
d160 2
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.1.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: err.c,v 8.120.4.2 2001/05/03 17:24:06 gshapiro Exp $";
a23 1

d109 1
a109 1
			sm_free(CurEnv->e_message);
d124 1
a124 1
	pw = sm_getpwuid(RealUid);
d130 1
a130 1
		snprintf(ubuf, sizeof ubuf, "UID%d", (int) RealUid);
a158 2


d237 1
a237 1
			sm_free(CurEnv->e_message);
d323 1
a323 1
			sm_free(CurEnv->e_message);
d392 1
a392 1
			sm_free(CurEnv->e_message);
d446 1
a446 1
			sm_free(CurEnv->e_message);
@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Id: err.c,v 8.120.4.1 2000/05/25 18:56:15 gshapiro Exp $";
a23 1

a158 2


@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d14 4
d19 1
a19 4

SM_RCSID("@@(#)$Sendmail: err.c,v 8.184 2001/09/04 22:43:03 ca Exp $")

#if LDAPMAP
d24 1
a30 53
**  FATAL_ERROR -- handle a fatal exception
**
**	This function is installed as the default exception handler
**	in the main sendmail process, and in all child processes
**	that we create.  Its job is to handle exceptions that are not
**	handled at a lower level.
**
**	The theory is that unhandled exceptions will be 'fatal' class
**	exceptions (with an "F:" prefix), such as the out-of-memory
**	exception "F:sm.heap".  As such, they are handled by exiting
**	the process in exactly the same way that xalloc() in Sendmail 8.10
**	exits the process when it fails due to lack of memory:
**	we call syserr with a message beginning with "!".
**
**	Parameters:
**		exc -- exception which is terminating this process
**
**	Returns:
**		none
*/

void
fatal_error(exc)
	SM_EXC_T *exc;
{
	static char buf[256];
	SM_FILE_T f;

	/*
	**  This function may be called when the heap is exhausted.
	**  The following code writes the message for 'exc' into our
	**  static buffer without allocating memory or raising exceptions.
	*/

	sm_strio_init(&f, buf, sizeof(buf));
	sm_exc_write(exc, &f);
	(void) sm_io_flush(&f, SM_TIME_DEFAULT);

	/*
	**  Terminate the process after logging an error and cleaning up.
	**  Problems:
	**  - syserr decides what class of error this is by looking at errno.
	**    That's no good; we should look at the exc structure.
	**  - The cleanup code should be moved out of syserr
	**    and into individual exception handlers
	**    that are part of the module they clean up after.
	*/

	errno = ENOMEM;
	syserr("!%s", buf);
}

/*
d33 1
a33 1
**	Prints an error message via sm_io_printf to the diagnostic output.
a39 5
**	If the first character of the syserr message is '!' or '@@'
**	then syserr knows that the process is about to be terminated,
**	so the SMTP reply code defaults to 421.  Otherwise, the
**	reply code defaults to 451 or 554, depending on errno.
**
d41 4
a44 3
**		fmt -- the format string.  An optional '!' or '@@',
**			followed by an optional three-digit SMTP
**			reply code, followed by message text.
d49 1
a49 1
**		Raises E:mta.quickabort if QuickAbort is set.
a75 1
	bool exiting;
d81 1
a81 1
	SM_VA_LOCAL_DECL
d83 2
a84 1
	switch (*fmt)
d86 2
a87 14
	  case '!':
		++fmt;
		panic = true;
		exiting = true;
		break;
	  case '@@':
		++fmt;
		panic = false;
		exiting = true;
		break;
	  default:
		panic = false;
		exiting = false;
		break;
d91 1
a91 12
	if (exiting)
	{
		/*
		**  Since we are terminating the process,
		**  we are aborting the entire SMTP session,
		**  rather than just the current transaction.
		*/

		p = "421";
		enhsc = "4.0.0";
	}
	else if (save_errno == 0)
d101 1
a101 1
	SM_VA_START(ap, fmt);
d103 1
a103 1
	SM_VA_END(ap);
d109 3
a111 5
		char *nmsg = sm_rpool_strdup_x(CurEnv->e_rpool, errtxt);

		if (CurEnv->e_rpool == NULL && CurEnv->e_message != NULL)
			sm_free(CurEnv->e_message);
		CurEnv->e_message = nmsg;
d122 1
a122 1
			sm_dprintf("syserr: ExitStat = %d\n", ExitStat);
d125 1
a125 1
	pw = sm_getpwuid(RealUid);
d131 1
a131 1
		(void) sm_snprintf(ubuf, sizeof ubuf, "UID%d", (int) RealUid);
d160 4
a163 2
		printopenfds(true);
		mci_dump_all(true);
d168 1
a168 1
#if XLA
d178 1
a178 1
		sm_exc_raisenew_x(&EtypeQuickAbort, 2);
d187 2
a188 2
**			a three-digit SMTP reply code, 550 is assumed.
**		(others) -- sm_io_printf strings
d192 1
a192 1
**		Raises E:mta.quickabort if QuickAbort is set.
d210 1
a210 1
	SM_VA_LOCAL_DECL
d220 3
a222 3
	SM_VA_START(ap, fmt);
	errtxt = fmtmsg(MsgBuf, CurEnv->e_to, "550", enhsc, 0, fmt, ap);
	SM_VA_END(ap);
d239 2
a240 2
		if (CurEnv->e_rpool == NULL && CurEnv->e_message != NULL)
			sm_free(CurEnv->e_message);
d245 3
a247 5
			(void) sm_snprintf(buf, sizeof buf,
					   "Postmaster warning: %.*s",
					   (int) sizeof buf - 22, errtxt);
			CurEnv->e_message =
				sm_rpool_strdup_x(CurEnv->e_rpool, buf);
d251 1
a251 2
			CurEnv->e_message =
				sm_rpool_strdup_x(CurEnv->e_rpool, errtxt);
d257 1
d260 1
d262 1
a262 1
		sm_exc_raisenew_x(&EtypeQuickAbort, 1);
d272 2
a273 2
**			a three-digit SMTP reply code, 550 is assumed.
**		(others) -- sm_io_printf strings
d277 1
a277 1
**		Raises E:mta.quickabort if QuickAbort is set.
d295 1
a295 1
	SM_VA_LOCAL_DECL
d306 3
a308 3
	SM_VA_START(ap, fmt);
	errtxt = fmtmsg(MsgBuf, CurEnv->e_to, "550", enhsc, 0, fmt, ap);
	SM_VA_END(ap);
d325 2
a326 2
		if (CurEnv->e_rpool == NULL && CurEnv->e_message != NULL)
			sm_free(CurEnv->e_message);
d331 3
a333 5
			(void) sm_snprintf(buf, sizeof buf,
					   "Postmaster warning: %.*s",
					   (int) sizeof buf - 22, errtxt);
			CurEnv->e_message =
				sm_rpool_strdup_x(CurEnv->e_rpool, buf);
d337 1
a337 2
			CurEnv->e_message =
				sm_rpool_strdup_x(CurEnv->e_rpool, errtxt);
d343 1
d346 1
d348 1
a348 1
		sm_exc_raisenew_x(&EtypeQuickAbort, 1);
d354 1
a354 1
**		msg -- the message (sm_io_printf fmt) -- it can begin with
d356 1
a356 1
**		(others) -- sm_io_printf arguments
d376 1
a376 1
	SM_VA_LOCAL_DECL
d379 1
a379 1
	SM_VA_START(ap, msg);
d381 2
a382 2
	SM_VA_END(ap);
	putoutmsg(MsgBuf, false, false);
d394 3
a396 4
		if (CurEnv->e_rpool == NULL && CurEnv->e_message != NULL)
			sm_free(CurEnv->e_message);
		CurEnv->e_message =
			sm_rpool_strdup_x(CurEnv->e_rpool, errtxt);
d406 1
a406 1
**		msg -- the message (sm_io_printf fmt) -- if it begins
d409 1
a409 1
**		(others) -- sm_io_printf arguments
d429 1
a429 1
	SM_VA_LOCAL_DECL
d432 1
a432 1
	SM_VA_START(ap, msg);
d435 2
a436 2
	SM_VA_END(ap);
	putoutmsg(MsgBuf, false, false);
d448 3
a450 4
		if (CurEnv->e_rpool == NULL && CurEnv->e_message != NULL)
			sm_free(CurEnv->e_message);
		CurEnv->e_message =
			sm_rpool_strdup_x(CurEnv->e_rpool, errtxt);
d459 1
a459 1
**		holdmsg -- if true, don't output a copy of the message to
d461 1
a461 1
**		heldmsg -- if true, this is a previously held message;
d484 1
a484 1
		sm_dprintf("--- %s%s%s\n", msg, holdmsg ? " (hold)" : "",
d496 1
a496 2
		(void) sm_io_fprintf(CurEnv->e_xfp, SM_TIME_DEFAULT, "%s\n",
				     msg);
d498 1
a498 1
	if (LogLevel > 14 && (OpMode == MD_SMTP || OpMode == MD_DAEMON))
d500 2
a501 2
			  "--- %s%s%s", msg, holdmsg ? " (hold)" : "",
			  heldmsg ? " (held)" : "");
d515 1
a515 1
		(void) sm_strlcpy(HeldMessageBuf, msg, sizeof HeldMessageBuf);
d519 1
a519 1
	(void) sm_io_flush(smioout, SM_TIME_DEFAULT);
d540 1
a540 2
		(void) sm_io_fprintf(OutChannel, SM_TIME_DEFAULT, "%s\r\n",
				     msg);
d542 1
a542 2
		(void) sm_io_fprintf(OutChannel, SM_TIME_DEFAULT, "%s\n",
				     errtxt);
d544 2
a545 6
		(void) sm_io_fprintf(TrafficLogFile, SM_TIME_DEFAULT,
				     "%05d >>> %s\n", (int) CurrentPid,
				     (OpMode == MD_SMTP || OpMode == MD_DAEMON)
					? msg : errtxt);
#if !PIPELINING
	/* XXX can't flush here for SMTP pipelining */
d547 2
a548 2
		(void) sm_io_flush(OutChannel, SM_TIME_DEFAULT);
	if (!sm_io_error(OutChannel) || DisConnected)
d557 2
a558 2
	if (InChannel == NULL || sm_io_eof(InChannel) ||
	    sm_io_error(InChannel) || strncmp(msg, "221", 3) == 0)
d562 1
a562 1
	HoldErrs = true;
d566 2
a567 3
			  CURHOSTNAME,
			  shortenstring(msg, MAXSHORTSTR), sm_errstring(errno));
#endif /* !PIPELINING */
d589 1
a589 1
	putoutmsg(msg, HoldErrs, false);
d593 1
a593 1
		HoldErrs = true;
a667 1

d731 1
a731 1
	SM_VA_LOCAL_DECL
d748 1
a748 9
#if _FFR_SOFT_BOUNCE
	if (SoftBounce && num[0] == '5')
	{
		/* replace 5 by 4 */
		(void) sm_snprintf(eb, spaceleft, "4%2.2s%c", num + 1, del);
	}
	else
#endif /* _FFR_SOFT_BOUNCE */
	(void) sm_snprintf(eb, spaceleft, "%3.3s%c", num, del);
d756 1
a756 1
		(void) sm_strlcpy(eb, fmt, l + 1);
d764 1
a764 1
		(void) sm_strlcpy(eb, enhsc, l + 1);
a769 7
#if _FFR_SOFT_BOUNCE
	if (SoftBounce && eb[-l] == '5')
	{
		/* replace 5 by 4 */
		eb[-l] = '4';
	}
#endif /* _FFR_SOFT_BOUNCE */
d775 2
a776 2
		(void) sm_snprintf(eb, spaceleft, "%s: line %d: ",
				   shortenstring(FileName, 83), LineNumber);
d781 1
a781 14
	/*
	**  output the "to" address only if it is defined and one of the
	**  following codes is used:
	**  050 internal notices, e.g., alias expansion
	**  250 Ok
	**  252 Cannot VRFY user, but will accept message and attempt delivery
	**  450 Requested mail action not taken: mailbox unavailable
	**  550 Requested action not taken: mailbox unavailable
	**  553 Requested action not taken: mailbox name not allowed
	**
	**  Notice: this still isn't "the right thing", this code shouldn't
	**	(indirectly) depend on CurEnv->e_to.
	*/

d783 2
a784 6
	    (strncmp(num, "050", 3) == 0 ||
	     strncmp(num, "250", 3) == 0 ||
	     strncmp(num, "252", 3) == 0 ||
	     strncmp(num, "450", 3) == 0 ||
	     strncmp(num, "550", 3) == 0 ||
	     strncmp(num, "553", 3) == 0))
d786 2
a787 2
		(void) sm_strlcpyn(eb, spaceleft, 2,
				   shortenstring(to, MAXSHORTSTR), "... ");
d794 1
a794 1
	(void) sm_vsnprintf(eb, spaceleft, fmt, ap);
d801 1
a801 1
		(void) sm_strlcpyn(eb, spaceleft, 2, ": ", sm_errstring(eno));
d819 1
a819 1
	HoldErrs = true;
d837 1
a837 1
		putoutmsg(HeldMessageBuf, false, true);
d839 1
a839 1
	HoldErrs = false;
d842 1
a842 1
**  SM_ERRSTRING -- return string description of error code
d855 1
a855 1
sm_errstring(errnum)
d875 1
d879 3
a881 3
#if HASSTRERROR
		(void) sm_strlcpy(bp, strerror(errnum), SPACELEFT(buf, bp));
#else /* HASSTRERROR */
d883 1
a883 2
			(void) sm_strlcpy(bp, sys_errlist[errnum],
					  SPACELEFT(buf, bp));
d885 2
a886 3
			(void) sm_snprintf(bp, SPACELEFT(buf, bp),
				"Error %d", errnum);
#endif /* HASSTRERROR */
d892 1
a892 2
				(void) sm_snprintf(bp, SPACELEFT(buf, bp),
					" with ");
d898 1
a898 1
				(void) sm_snprintf(bp, SPACELEFT(buf, bp),
d902 2
a903 3
			(void) sm_strlcpy(bp,
					shortenstring(CurHostName, MAXSHORTSTR),
					SPACELEFT(buf, bp));
d908 2
a909 2
			(void) sm_snprintf(bp, SPACELEFT(buf, bp),
				" during %s", SmtpPhase);
d916 1
a916 1
		(void) sm_snprintf(buf, sizeof buf, "Host %s is down",
d923 1
a923 1
		(void) sm_strlcpyn(buf, sizeof buf, 2, "Connection refused by ",
d926 1
d994 1
a994 1
		bp += sm_strlcpy(bp, "Name server: ", sizeof buf);
d997 2
a998 2
			(void) sm_strlcpyn(bp, SPACELEFT(buf, bp), 2,
				shortenstring(CurHostName, MAXSHORTSTR), ": ");
d1001 1
a1001 1
		(void) sm_strlcpy(bp, dnsmsg, SPACELEFT(buf, bp));
d1005 1
a1005 1
#if LDAPMAP
d1016 1
a1016 1
	(void) sm_snprintf(buf, sizeof buf, "Error %d", errnum);
@


