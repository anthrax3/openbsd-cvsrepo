head	1.19;
access;
symbols
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.10
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.8
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.12
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.10
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.6
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.8
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.4
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.15.0.6
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.4
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.6
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.18;
commitid	M7i5giHIoz3DMlTU;

1.18
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2011.05.17.15.54.23;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2006.08.13.13.01.48;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.22.18.43.55;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.08.16.00.51;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.24.03.59.27;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.01.19.59.22;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.03.17.25.47;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.18.00.49.28;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.01.17.18.30;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.29.01.31.15;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.15.21.09.08;	author millert;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.08.02.04.10.45;	author millert;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.04.02.19.05.45;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.45;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.13;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.50;	author millert;	state Exp;
branches;
next	;

1.2.2.1
date	2001.05.31.00.31.34;	author miod;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.31.01.47.56;	author jason;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2003, 2006 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>

SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.313 2013/11/22 20:51:55 ca Exp $")

/*
**  CLRSESSENVELOPE -- clear session oriented data in an envelope
**
**	Parameters:
**		e -- the envelope to clear.
**
**	Returns:
**		none.
*/

void
clrsessenvelope(e)
	ENVELOPE *e;
{
#if SASL
	macdefine(&e->e_macro, A_PERM, macid("{auth_type}"), "");
	macdefine(&e->e_macro, A_PERM, macid("{auth_authen}"), "");
	macdefine(&e->e_macro, A_PERM, macid("{auth_author}"), "");
	macdefine(&e->e_macro, A_PERM, macid("{auth_ssf}"), "");
#endif /* SASL */
#if STARTTLS
	macdefine(&e->e_macro, A_PERM, macid("{cert_issuer}"), "");
	macdefine(&e->e_macro, A_PERM, macid("{cert_subject}"), "");
	macdefine(&e->e_macro, A_PERM, macid("{cipher_bits}"), "");
	macdefine(&e->e_macro, A_PERM, macid("{cipher}"), "");
	macdefine(&e->e_macro, A_PERM, macid("{tls_version}"), "");
	macdefine(&e->e_macro, A_PERM, macid("{verify}"), "");
# if _FFR_TLS_1
	macdefine(&e->e_macro, A_PERM, macid("{alg_bits}"), "");
	macdefine(&e->e_macro, A_PERM, macid("{cn_issuer}"), "");
	macdefine(&e->e_macro, A_PERM, macid("{cn_subject}"), "");
# endif /* _FFR_TLS_1 */
#endif /* STARTTLS */
}

/*
**  NEWENVELOPE -- fill in a new envelope
**
**	Supports inheritance.
**
**	Parameters:
**		e -- the new envelope to fill in.
**		parent -- the envelope to be the parent of e.
**		rpool -- either NULL, or a pointer to a resource pool
**			from which envelope memory is allocated, and
**			to which envelope resources are attached.
**
**	Returns:
**		e.
**
**	Side Effects:
**		none.
*/

ENVELOPE *
newenvelope(e, parent, rpool)
	register ENVELOPE *e;
	register ENVELOPE *parent;
	SM_RPOOL_T *rpool;
{
	int sendmode;

	/*
	**  This code used to read:
	**	if (e == parent && e->e_parent != NULL)
	**		parent = e->e_parent;
	**  So if e == parent && e->e_parent == NULL then we would
	**  set e->e_parent = e, which creates a loop in the e_parent chain.
	**  This meant macvalue() could go into an infinite loop.
	*/

	if (parent != NULL)
		sendmode = parent->e_sendmode;
	else
		sendmode = DM_NOTSET;

	if (e == parent)
		parent = e->e_parent;
	clearenvelope(e, true, rpool);
	if (e == CurEnv)
		memmove((char *) &e->e_from,
			(char *) &NullAddress,
			sizeof(e->e_from));
	else
		memmove((char *) &e->e_from,
			(char *) &CurEnv->e_from,
			sizeof(e->e_from));
	e->e_parent = parent;
	assign_queueid(e);
	e->e_ctime = curtime();
#if _FFR_SESSID
	e->e_sessid = e->e_id;
#endif /* _FFR_SESSID */
	if (parent != NULL)
	{
		e->e_msgpriority = parent->e_msgsize;
#if _FFR_SESSID
		if (parent->e_sessid != NULL)
			e->e_sessid = sm_rpool_strdup_x(rpool,
							parent->e_sessid);
#endif /* _FFR_SESSID */

		if (parent->e_quarmsg == NULL)
		{
			e->e_quarmsg = NULL;
			macdefine(&e->e_macro, A_PERM,
				  macid("{quarantine}"), "");
		}
		else
		{
			e->e_quarmsg = sm_rpool_strdup_x(rpool,
							 parent->e_quarmsg);
			macdefine(&e->e_macro, A_PERM,
				  macid("{quarantine}"), e->e_quarmsg);
		}
	}
	e->e_puthdr = putheader;
	e->e_putbody = putbody;
	if (CurEnv->e_xfp != NULL)
		(void) sm_io_flush(CurEnv->e_xfp, SM_TIME_DEFAULT);
	if (sendmode != DM_NOTSET)
		set_delivery_mode(sendmode, e);

	return e;
}

/* values for msg_timeout, see also IS_* below for usage (bit layout) */
#define MSG_T_O		0x01	/* normal timeout */
#define MSG_T_O_NOW	0x02	/* NOW timeout */
#define MSG_NOT_BY	0x04	/* Deliver-By time exceeded, mode R */
#define MSG_WARN	0x10	/* normal queue warning */
#define MSG_WARN_BY	0x20	/* Deliver-By time exceeded, mode N */

#define IS_MSG_ERR(x)	(((x) & 0x0f) != 0)	/* return an error */

/* immediate return */
#define IS_IMM_RET(x)	(((x) & (MSG_T_O_NOW|MSG_NOT_BY)) != 0)
#define IS_MSG_WARN(x)	(((x) & 0xf0) != 0)	/* return a warning */

/*
**  DROPENVELOPE -- deallocate an envelope.
**
**	Parameters:
**		e -- the envelope to deallocate.
**		fulldrop -- if set, do return receipts.
**		split -- if true, split by recipient if message is queued up
**
**	Returns:
**		EX_* status (currently: 0: success, EX_IOERR on panic)
**
**	Side Effects:
**		housekeeping necessary to dispose of an envelope.
**		Unlocks this queue file.
*/

int
dropenvelope(e, fulldrop, split)
	register ENVELOPE *e;
	bool fulldrop;
	bool split;
{
	bool panic = false;
	bool queueit = false;
	int msg_timeout = 0;
	bool failure_return = false;
	bool delay_return = false;
	bool success_return = false;
	bool pmnotify = bitset(EF_PM_NOTIFY, e->e_flags);
	bool done = false;
	register ADDRESS *q;
	char *id = e->e_id;
	time_t now;
	char buf[MAXLINE];

	if (tTd(50, 1))
	{
		sm_dprintf("dropenvelope %p: id=", e);
		xputs(sm_debug_file(), e->e_id);
		sm_dprintf(", flags=");
		printenvflags(e);
		if (tTd(50, 10))
		{
			sm_dprintf("sendq=");
			printaddr(sm_debug_file(), e->e_sendqueue, true);
		}
	}

	if (LogLevel > 84)
		sm_syslog(LOG_DEBUG, id,
			  "dropenvelope, e_flags=0x%lx, OpMode=%c, pid=%d",
			  e->e_flags, OpMode, (int) CurrentPid);

	/* we must have an id to remove disk files */
	if (id == NULL)
		return EX_OK;

	/* if verify-only mode, we can skip most of this */
	if (OpMode == MD_VERIFY)
		goto simpledrop;

	if (tTd(92, 2))
		sm_dprintf("dropenvelope: e_id=%s, EF_LOGSENDER=%d, LogLevel=%d\n",
			e->e_id, bitset(EF_LOGSENDER, e->e_flags), LogLevel);
	if (LogLevel > 4 && bitset(EF_LOGSENDER, e->e_flags))
		logsender(e, NULL);
	e->e_flags &= ~EF_LOGSENDER;

	/* post statistics */
	poststats(StatFile);

	/*
	**  Extract state information from dregs of send list.
	*/

	now = curtime();
	if (now >= e->e_ctime + TimeOuts.to_q_return[e->e_timeoutclass])
		msg_timeout = MSG_T_O;
	if (IS_DLVR_RETURN(e) && e->e_deliver_by > 0 &&
	    now >= e->e_ctime + e->e_deliver_by &&
	    !bitset(EF_RESPONSE, e->e_flags))
	{
		msg_timeout = MSG_NOT_BY;
		e->e_flags |= EF_FATALERRS|EF_CLRQUEUE;
	}
	else if (TimeOuts.to_q_return[e->e_timeoutclass] == NOW &&
		 !bitset(EF_RESPONSE, e->e_flags))
	{
		msg_timeout = MSG_T_O_NOW;
		e->e_flags |= EF_FATALERRS|EF_CLRQUEUE;
	}


	e->e_flags &= ~EF_QUEUERUN;
	for (q = e->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (QS_IS_UNDELIVERED(q->q_state))
			queueit = true;


		/* see if a notification is needed */
		if (bitset(QPINGONFAILURE, q->q_flags) &&
		    ((IS_MSG_ERR(msg_timeout) &&
		      QS_IS_UNDELIVERED(q->q_state)) ||
		     QS_IS_BADADDR(q->q_state) ||
		     IS_IMM_RET(msg_timeout)))
		{
			failure_return = true;
			if (!done && q->q_owner == NULL &&
			    !emptyaddr(&e->e_from))
			{
				(void) sendtolist(e->e_from.q_paddr, NULLADDR,
						  &e->e_errorqueue, 0, e);
				done = true;
			}
		}
		else if ((bitset(QPINGONSUCCESS, q->q_flags) &&
			  ((QS_IS_SENT(q->q_state) &&
			    bitnset(M_LOCALMAILER, q->q_mailer->m_flags)) ||
			   bitset(QRELAYED|QEXPANDED|QDELIVERED, q->q_flags))) ||
			  bitset(QBYTRACE, q->q_flags) ||
			  bitset(QBYNRELAY, q->q_flags))
		{
			success_return = true;
		}
	}

	if (e->e_class < 0)
		e->e_flags |= EF_NO_BODY_RETN;

	/*
	**  See if the message timed out.
	*/

	if (!queueit)
		/* EMPTY */
		/* nothing to do */ ;
	else if (IS_MSG_ERR(msg_timeout))
	{
		if (failure_return)
		{
			if (msg_timeout == MSG_NOT_BY)
			{
				(void) sm_snprintf(buf, sizeof(buf),
					"delivery time expired %lds",
					e->e_deliver_by);
			}
			else
			{
				(void) sm_snprintf(buf, sizeof(buf),
					"Cannot send message for %s",
					pintvl(TimeOuts.to_q_return[e->e_timeoutclass],
						false));
			}

			/* don't free, allocated from e_rpool */
			e->e_message = sm_rpool_strdup_x(e->e_rpool, buf);
			message(buf);
			e->e_flags |= EF_CLRQUEUE;
		}
		if (msg_timeout == MSG_NOT_BY)
		{
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
				"Delivery time (%lds) expired\n",
				e->e_deliver_by);
		}
		else
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
				"Message could not be delivered for %s\n",
				pintvl(TimeOuts.to_q_return[e->e_timeoutclass],
					false));
		(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
			"Message will be deleted from queue\n");
		for (q = e->e_sendqueue; q != NULL; q = q->q_next)
		{
			if (QS_IS_UNDELIVERED(q->q_state))
			{
				q->q_state = QS_BADADDR;
				if (msg_timeout == MSG_NOT_BY)
					q->q_status = "5.4.7";
				else
					q->q_status = "4.4.7";
			}
		}
	}
	else
	{
		if (TimeOuts.to_q_warning[e->e_timeoutclass] > 0 &&
		    now >= e->e_ctime +
				TimeOuts.to_q_warning[e->e_timeoutclass])
			msg_timeout = MSG_WARN;
		else if (IS_DLVR_NOTIFY(e) &&
			 e->e_deliver_by > 0 &&
			 now >= e->e_ctime + e->e_deliver_by)
			msg_timeout = MSG_WARN_BY;

		if (IS_MSG_WARN(msg_timeout))
		{
			if (!bitset(EF_WARNING|EF_RESPONSE, e->e_flags) &&
			    e->e_class >= 0 &&
			    e->e_from.q_paddr != NULL &&
			    strcmp(e->e_from.q_paddr, "<>") != 0 &&
			    sm_strncasecmp(e->e_from.q_paddr, "owner-", 6) != 0 &&
			    (strlen(e->e_from.q_paddr) <= 8 ||
			     sm_strcasecmp(&e->e_from.q_paddr[strlen(e->e_from.q_paddr) - 8],
					   "-request") != 0))
			{
				for (q = e->e_sendqueue; q != NULL;
				     q = q->q_next)
				{
					if (QS_IS_UNDELIVERED(q->q_state)
#if _FFR_NODELAYDSN_ON_HOLD
					    && !bitnset(M_HOLD,
							q->q_mailer->m_flags)
#endif /* _FFR_NODELAYDSN_ON_HOLD */
					   )
					{
						if (msg_timeout ==
						    MSG_WARN_BY &&
						    (bitset(QPINGONDELAY,
							    q->q_flags) ||
						    !bitset(QHASNOTIFY,
							    q->q_flags))
						   )
						{
							q->q_flags |= QBYNDELAY;
							delay_return = true;
						}
						if (bitset(QPINGONDELAY,
							   q->q_flags))
						{
							q->q_flags |= QDELAYED;
							delay_return = true;
						}
					}
				}
			}
			if (delay_return)
			{
				if (msg_timeout == MSG_WARN_BY)
				{
					(void) sm_snprintf(buf, sizeof(buf),
						"Warning: Delivery time (%lds) exceeded",
						e->e_deliver_by);
				}
				else
					(void) sm_snprintf(buf, sizeof(buf),
						"Warning: could not send message for past %s",
						pintvl(TimeOuts.to_q_warning[e->e_timeoutclass],
							false));

				/* don't free, allocated from e_rpool */
				e->e_message = sm_rpool_strdup_x(e->e_rpool,
								 buf);
				message(buf);
				e->e_flags |= EF_WARNING;
			}
			if (msg_timeout == MSG_WARN_BY)
			{
				(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
					"Warning: Delivery time (%lds) exceeded\n",
					e->e_deliver_by);
			}
			else
				(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
					"Warning: message still undelivered after %s\n",
					pintvl(TimeOuts.to_q_warning[e->e_timeoutclass],
					     false));
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
				      "Will keep trying until message is %s old\n",
				      pintvl(TimeOuts.to_q_return[e->e_timeoutclass],
					     false));
		}
	}

	if (tTd(50, 2))
		sm_dprintf("failure_return=%d delay_return=%d success_return=%d queueit=%d\n",
			failure_return, delay_return, success_return, queueit);

	/*
	**  If we had some fatal error, but no addresses are marked as
	**  bad, mark them _all_ as bad.
	*/

	if (bitset(EF_FATALERRS, e->e_flags) && !failure_return)
	{
		for (q = e->e_sendqueue; q != NULL; q = q->q_next)
		{
			if ((QS_IS_OK(q->q_state) ||
			     QS_IS_VERIFIED(q->q_state)) &&
			    bitset(QPINGONFAILURE, q->q_flags))
			{
				failure_return = true;
				q->q_state = QS_BADADDR;
			}
		}
	}

	/*
	**  Send back return receipts as requested.
	*/

	if (success_return && !failure_return && !delay_return && fulldrop &&
	    !bitset(PRIV_NORECEIPTS, PrivacyFlags) &&
	    strcmp(e->e_from.q_paddr, "<>") != 0)
	{
		auto ADDRESS *rlist = NULL;

		if (tTd(50, 8))
			sm_dprintf("dropenvelope(%s): sending return receipt\n",
				id);
		e->e_flags |= EF_SENDRECEIPT;
		(void) sendtolist(e->e_from.q_paddr, NULLADDR, &rlist, 0, e);
		(void) returntosender("Return receipt", rlist, RTSF_NO_BODY, e);
	}
	e->e_flags &= ~EF_SENDRECEIPT;

	/*
	**  Arrange to send error messages if there are fatal errors.
	*/

	if ((failure_return || delay_return) && e->e_errormode != EM_QUIET)
	{
		if (tTd(50, 8))
			sm_dprintf("dropenvelope(%s): saving mail\n", id);
		panic = savemail(e, !bitset(EF_NO_BODY_RETN, e->e_flags));
	}

	/*
	**  Arrange to send warning messages to postmaster as requested.
	*/

	if ((failure_return || pmnotify) &&
	    PostMasterCopy != NULL &&
	    !bitset(EF_RESPONSE, e->e_flags) &&
	    e->e_class >= 0)
	{
		auto ADDRESS *rlist = NULL;
		char pcopy[MAXNAME];

		if (failure_return)
		{
			expand(PostMasterCopy, pcopy, sizeof(pcopy), e);

			if (tTd(50, 8))
				sm_dprintf("dropenvelope(%s): sending postmaster copy to %s\n",
					id, pcopy);
			(void) sendtolist(pcopy, NULLADDR, &rlist, 0, e);
		}
		if (pmnotify)
			(void) sendtolist("postmaster", NULLADDR,
					  &rlist, 0, e);
		(void) returntosender(e->e_message, rlist,
				      RTSF_PM_BOUNCE|RTSF_NO_BODY, e);
	}

	/*
	**  Instantiate or deinstantiate the queue.
	*/

simpledrop:
	if (tTd(50, 8))
		sm_dprintf("dropenvelope(%s): at simpledrop, queueit=%d\n",
			id, queueit);
	if (!queueit || bitset(EF_CLRQUEUE, e->e_flags))
	{
		if (tTd(50, 1))
		{
			sm_dprintf("\n===== Dropping queue files for %s... queueit=%d, e_flags=",
				e->e_id, queueit);
			printenvflags(e);
		}
		if (!panic)
		{
			if (e->e_dfp != NULL)
			{
				(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT);
				e->e_dfp = NULL;
			}
			(void) xunlink(queuename(e, DATAFL_LETTER));
		}
		if (panic && QueueMode == QM_LOST)
		{
			/*
			**  leave the Qf file behind as
			**  the delivery attempt failed.
			*/

			/* EMPTY */
		}
		else
		if (xunlink(queuename(e, ANYQFL_LETTER)) == 0)
		{
			/* add to available space in filesystem */
			updfs(e, -1, panic ? 0 : -1, "dropenvelope");
		}

		if (e->e_ntries > 0 && LogLevel > 9)
			sm_syslog(LOG_INFO, id, "done; delay=%s, ntries=%d",
				  pintvl(curtime() - e->e_ctime, true),
				  e->e_ntries);
	}
	else if (queueit || !bitset(EF_INQUEUE, e->e_flags))
	{
		if (!split)
			queueup(e, false, true);
		else
		{
			ENVELOPE *oldsib;
			ENVELOPE *ee;

			/*
			**  Save old sibling and set it to NULL to avoid
			**  queueing up the same envelopes again.
			**  This requires that envelopes in that list have
			**  been take care of before (or at some other place).
			*/

			oldsib = e->e_sibling;
			e->e_sibling = NULL;
			if (!split_by_recipient(e) &&
			    bitset(EF_FATALERRS, e->e_flags))
			{
				syserr("!dropenvelope(%s): cannot commit data file %s, uid=%d",
					e->e_id, queuename(e, DATAFL_LETTER),
					(int) geteuid());
			}
			for (ee = e->e_sibling; ee != NULL; ee = ee->e_sibling)
				queueup(ee, false, true);
			queueup(e, false, true);

			/* clean up */
			for (ee = e->e_sibling; ee != NULL; ee = ee->e_sibling)
			{
				/* now unlock the job */
				if (tTd(50, 8))
					sm_dprintf("dropenvelope(%s): unlocking job\n",
						   ee->e_id);
				closexscript(ee);
				unlockqueue(ee);

				/* this envelope is marked unused */
				if (ee->e_dfp != NULL)
				{
					(void) sm_io_close(ee->e_dfp,
							   SM_TIME_DEFAULT);
					ee->e_dfp = NULL;
				}
				ee->e_id = NULL;
				ee->e_flags &= ~EF_HAS_DF;
			}
			e->e_sibling = oldsib;
		}
	}

	/* now unlock the job */
	if (tTd(50, 8))
		sm_dprintf("dropenvelope(%s): unlocking job\n", id);
	closexscript(e);
	unlockqueue(e);

	/* make sure that this envelope is marked unused */
	if (e->e_dfp != NULL)
	{
		(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT);
		e->e_dfp = NULL;
	}
	e->e_id = NULL;
	e->e_flags &= ~EF_HAS_DF;
	if (panic)
		return EX_IOERR;
	return EX_OK;
}

/*
**  CLEARENVELOPE -- clear an envelope without unlocking
**
**	This is normally used by a child process to get a clean
**	envelope without disturbing the parent.
**
**	Parameters:
**		e -- the envelope to clear.
**		fullclear - if set, the current envelope is total
**			garbage and should be ignored; otherwise,
**			release any resources it may indicate.
**		rpool -- either NULL, or a pointer to a resource pool
**			from which envelope memory is allocated, and
**			to which envelope resources are attached.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Closes files associated with the envelope.
**		Marks the envelope as unallocated.
*/

void
clearenvelope(e, fullclear, rpool)
	register ENVELOPE *e;
	bool fullclear;
	SM_RPOOL_T *rpool;
{
	register HDR *bh;
	register HDR **nhp;
	extern ENVELOPE BlankEnvelope;
	char **p;

	if (!fullclear)
	{
		/* clear out any file information */
		if (e->e_xfp != NULL)
			(void) sm_io_close(e->e_xfp, SM_TIME_DEFAULT);
		if (e->e_dfp != NULL)
			(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT);
		e->e_xfp = e->e_dfp = NULL;
	}

	/*
	**  Copy BlankEnvelope into *e.
	**  It is not safe to simply copy pointers to strings;
	**  the strings themselves must be copied (or set to NULL).
	**  The problem is that when we assign a new string value to
	**  a member of BlankEnvelope, we free the old string.
	**  We did not need to do this copying in sendmail 8.11 :-(
	**  and it is a potential performance hit.  Reference counted
	**  strings are one way out.
	*/

	*e = BlankEnvelope;
	e->e_message = NULL;
	e->e_qfletter = '\0';
	e->e_quarmsg = NULL;
	macdefine(&e->e_macro, A_PERM, macid("{quarantine}"), "");

	/*
	**  Copy the macro table.
	**  We might be able to avoid this by zeroing the macro table
	**  and always searching BlankEnvelope.e_macro after e->e_macro
	**  in macvalue().
	*/

	for (p = &e->e_macro.mac_table[0];
	     p <= &e->e_macro.mac_table[MAXMACROID];
	     ++p)
	{
		if (*p != NULL)
			*p = sm_rpool_strdup_x(rpool, *p);
	}

	/*
	**  XXX There are many strings in the envelope structure
	**  XXX that we are not attempting to copy here.
	**  XXX Investigate this further.
	*/

	e->e_rpool = rpool;
	e->e_macro.mac_rpool = rpool;
	if (Verbose)
		set_delivery_mode(SM_DELIVER, e);
	bh = BlankEnvelope.e_header;
	nhp = &e->e_header;
	while (bh != NULL)
	{
		*nhp = (HDR *) sm_rpool_malloc_x(rpool, sizeof(*bh));
		memmove((char *) *nhp, (char *) bh, sizeof(*bh));
		bh = bh->h_link;
		nhp = &(*nhp)->h_link;
	}
#if _FFR_MILTER_ENHSC
	e->e_enhsc[0] = '\0';
#endif /* _FFR_MILTER_ENHSC */
}
/*
**  INITSYS -- initialize instantiation of system
**
**	In Daemon mode, this is done in the child.
**
**	Parameters:
**		e -- the envelope to use.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Initializes the system macros, some global variables,
**		etc.  In particular, the current time in various
**		forms is set.
*/

void
initsys(e)
	register ENVELOPE *e;
{
	char buf[10];
#ifdef TTYNAME
	static char ybuf[60];			/* holds tty id */
	register char *p;
	extern char *ttyname();
#endif /* TTYNAME */

	/*
	**  Give this envelope a reality.
	**	I.e., an id, a transcript, and a creation time.
	**  We don't select the queue until all of the recipients are known.
	*/

	openxscript(e);
	e->e_ctime = curtime();
	e->e_qfletter = '\0';

	/*
	**  Set OutChannel to something useful if stdout isn't it.
	**	This arranges that any extra stuff the mailer produces
	**	gets sent back to the user on error (because it is
	**	tucked away in the transcript).
	*/

	if (OpMode == MD_DAEMON && bitset(EF_QUEUERUN, e->e_flags) &&
	    e->e_xfp != NULL)
		OutChannel = e->e_xfp;

	/*
	**  Set up some basic system macros.
	*/

	/* process id */
	(void) sm_snprintf(buf, sizeof(buf), "%d", (int) CurrentPid);
	macdefine(&e->e_macro, A_TEMP, 'p', buf);

	/* hop count */
	(void) sm_snprintf(buf, sizeof(buf), "%d", e->e_hopcount);
	macdefine(&e->e_macro, A_TEMP, 'c', buf);

	/* time as integer, unix time, arpa time */
	settime(e);

	/* Load average */
	sm_getla();

#ifdef TTYNAME
	/* tty name */
	if (macvalue('y', e) == NULL)
	{
		p = ttyname(2);
		if (p != NULL)
		{
			if (strrchr(p, '/') != NULL)
				p = strrchr(p, '/') + 1;
			(void) sm_strlcpy(ybuf, sizeof(ybuf), p);
			macdefine(&e->e_macro, A_PERM, 'y', ybuf);
		}
	}
#endif /* TTYNAME */
}
/*
**  SETTIME -- set the current time.
**
**	Parameters:
**		e -- the envelope in which the macros should be set.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets the various time macros -- $a, $b, $d, $t.
*/

void
settime(e)
	register ENVELOPE *e;
{
	register char *p;
	auto time_t now;
	char buf[30];
	register struct tm *tm;

	now = curtime();
	(void) sm_snprintf(buf, sizeof(buf), "%ld", (long) now);
	macdefine(&e->e_macro, A_TEMP, macid("{time}"), buf);
	tm = gmtime(&now);
	(void) sm_snprintf(buf, sizeof(buf), "%04d%02d%02d%02d%02d",
			   tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
			   tm->tm_hour, tm->tm_min);
	macdefine(&e->e_macro, A_TEMP, 't', buf);
	(void) sm_strlcpy(buf, ctime(&now), sizeof(buf));
	p = strchr(buf, '\n');
	if (p != NULL)
		*p = '\0';
	macdefine(&e->e_macro, A_TEMP, 'd', buf);
	macdefine(&e->e_macro, A_TEMP, 'b', arpadate(buf));
	if (macvalue('a', e) == NULL)
		macdefine(&e->e_macro, A_PERM, 'a', macvalue('b', e));
}
/*
**  OPENXSCRIPT -- Open transcript file
**
**	Creates a transcript file for possible eventual mailing or
**	sending back.
**
**	Parameters:
**		e -- the envelope to create the transcript in/for.
**
**	Returns:
**		none
**
**	Side Effects:
**		Creates the transcript file.
*/

#ifndef O_APPEND
# define O_APPEND	0
#endif /* ! O_APPEND */

void
openxscript(e)
	register ENVELOPE *e;
{
	register char *p;

	if (e->e_xfp != NULL)
		return;

#if 0
	if (e->e_lockfp == NULL && bitset(EF_INQUEUE, e->e_flags))
		syserr("openxscript: job not locked");
#endif /* 0 */

	p = queuename(e, XSCRPT_LETTER);
	e->e_xfp = bfopen(p, FileMode, XscriptFileBufferSize,
			  SFF_NOTEXCL|SFF_OPENASROOT);

	if (e->e_xfp == NULL)
	{
		syserr("Can't create transcript file %s", p);
		e->e_xfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT,
				      SM_PATH_DEVNULL, SM_IO_RDWR, NULL);
		if (e->e_xfp == NULL)
			syserr("!Can't open %s", SM_PATH_DEVNULL);
	}
	(void) sm_io_setvbuf(e->e_xfp, SM_TIME_DEFAULT, NULL, SM_IO_LBF, 0);
	if (tTd(46, 9))
	{
		sm_dprintf("openxscript(%s):\n  ", p);
		dumpfd(sm_io_getinfo(e->e_xfp, SM_IO_WHAT_FD, NULL), true,
		       false);
	}
}
/*
**  CLOSEXSCRIPT -- close the transcript file.
**
**	Parameters:
**		e -- the envelope containing the transcript to close.
**
**	Returns:
**		none.
**
**	Side Effects:
**		none.
*/

void
closexscript(e)
	register ENVELOPE *e;
{
	if (e->e_xfp == NULL)
		return;
#if 0
	if (e->e_lockfp == NULL)
		syserr("closexscript: job not locked");
#endif /* 0 */
	(void) sm_io_close(e->e_xfp, SM_TIME_DEFAULT);
	e->e_xfp = NULL;
}
/*
**  SETSENDER -- set the person who this message is from
**
**	Under certain circumstances allow the user to say who
**	s/he is (using -f or -r).  These are:
**	1.  The user's uid is zero (root).
**	2.  The user's login name is in an approved list (typically
**	    from a network server).
**	3.  The address the user is trying to claim has a
**	    "!" character in it (since #2 doesn't do it for
**	    us if we are dialing out for UUCP).
**	A better check to replace #3 would be if the
**	effective uid is "UUCP" -- this would require me
**	to rewrite getpwent to "grab" uucp as it went by,
**	make getname more nasty, do another passwd file
**	scan, or compile the UID of "UUCP" into the code,
**	all of which are reprehensible.
**
**	Assuming all of these fail, we figure out something
**	ourselves.
**
**	Parameters:
**		from -- the person we would like to believe this message
**			is from, as specified on the command line.
**		e -- the envelope in which we would like the sender set.
**		delimptr -- if non-NULL, set to the location of the
**			trailing delimiter.
**		delimchar -- the character that will delimit the sender
**			address.
**		internal -- set if this address is coming from an internal
**			source such as an owner alias.
**
**	Returns:
**		none.
**
**	Side Effects:
**		sets sendmail's notion of who the from person is.
*/

void
setsender(from, e, delimptr, delimchar, internal)
	char *from;
	register ENVELOPE *e;
	char **delimptr;
	int delimchar;
	bool internal;
{
	register char **pvp;
	char *realname = NULL;
	char *bp;
	char buf[MAXNAME + 2];
	char pvpbuf[PSBUFSIZE];
	extern char *FullName;

	if (tTd(45, 1))
		sm_dprintf("setsender(%s)\n", from == NULL ? "" : from);

	/* may be set from earlier calls */
	macdefine(&e->e_macro, A_PERM, 'x', "");

	/*
	**  Figure out the real user executing us.
	**	Username can return errno != 0 on non-errors.
	*/

	if (bitset(EF_QUEUERUN, e->e_flags) || OpMode == MD_SMTP ||
	    OpMode == MD_ARPAFTP || OpMode == MD_DAEMON)
		realname = from;
	if (realname == NULL || realname[0] == '\0')
		realname = username();

	if (ConfigLevel < 2)
		SuprErrs = true;

	macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), "e s");

	/* preset state for then clause in case from == NULL */
	e->e_from.q_state = QS_BADADDR;
	e->e_from.q_flags = 0;
	if (from == NULL ||
	    parseaddr(from, &e->e_from, RF_COPYALL|RF_SENDERADDR,
		      delimchar, delimptr, e, false) == NULL ||
	    QS_IS_BADADDR(e->e_from.q_state) ||
	    e->e_from.q_mailer == ProgMailer ||
	    e->e_from.q_mailer == FileMailer ||
	    e->e_from.q_mailer == InclMailer)
	{
		/* log garbage addresses for traceback */
		if (from != NULL && LogLevel > 2)
		{
			char *p;
			char ebuf[MAXNAME * 2 + 2];

			p = macvalue('_', e);
			if (p == NULL)
			{
				char *host = RealHostName;

				if (host == NULL)
					host = MyHostName;
				(void) sm_snprintf(ebuf, sizeof(ebuf),
						   "%.*s@@%.*s", MAXNAME,
						   realname, MAXNAME, host);
				p = ebuf;
			}
			sm_syslog(LOG_NOTICE, e->e_id,
				  "setsender: %s: invalid or unparsable, received from %s",
				  shortenstring(from, 83), p);
		}
		if (from != NULL)
		{
			if (!QS_IS_BADADDR(e->e_from.q_state))
			{
				/* it was a bogus mailer in the from addr */
				e->e_status = "5.1.7";
				usrerrenh(e->e_status,
					  "553 Invalid sender address");
			}
			SuprErrs = true;
		}
		if (from == realname ||
		    parseaddr(from = realname,
			      &e->e_from, RF_COPYALL|RF_SENDERADDR, ' ',
			      NULL, e, false) == NULL)
		{
			char nbuf[100];

			SuprErrs = true;
			expand("\201n", nbuf, sizeof(nbuf), e);
			from = sm_rpool_strdup_x(e->e_rpool, nbuf);
			if (parseaddr(from, &e->e_from, RF_COPYALL, ' ',
				      NULL, e, false) == NULL &&
			    parseaddr(from = "postmaster", &e->e_from,
				      RF_COPYALL, ' ', NULL, e, false) == NULL)
				syserr("553 5.3.0 setsender: can't even parse postmaster!");
		}
	}
	else
		FromFlag = true;
	e->e_from.q_state = QS_SENDER;
	if (tTd(45, 5))
	{
		sm_dprintf("setsender: QS_SENDER ");
		printaddr(sm_debug_file(), &e->e_from, false);
	}
	SuprErrs = false;

#if USERDB
	if (bitnset(M_CHECKUDB, e->e_from.q_mailer->m_flags))
	{
		register char *p;

		p = udbsender(e->e_from.q_user, e->e_rpool);
		if (p != NULL)
			from = p;
	}
#endif /* USERDB */

	if (bitnset(M_HASPWENT, e->e_from.q_mailer->m_flags))
	{
		SM_MBDB_T user;

		if (!internal)
		{
			/* if the user already given fullname don't redefine */
			if (FullName == NULL)
				FullName = macvalue('x', e);
			if (FullName != NULL)
			{
				if (FullName[0] == '\0')
					FullName = NULL;
				else
					FullName = newstr(FullName);
			}
		}

		if (e->e_from.q_user[0] != '\0' &&
		    sm_mbdb_lookup(e->e_from.q_user, &user) == EX_OK)
		{
			/*
			**  Process passwd file entry.
			*/

			/* extract home directory */
			if (*user.mbdb_homedir == '\0')
				e->e_from.q_home = NULL;
			else if (strcmp(user.mbdb_homedir, "/") == 0)
				e->e_from.q_home = "";
			else
				e->e_from.q_home = sm_rpool_strdup_x(e->e_rpool,
							user.mbdb_homedir);
			macdefine(&e->e_macro, A_PERM, 'z', e->e_from.q_home);

			/* extract user and group id */
			if (user.mbdb_uid != SM_NO_UID)
			{
				e->e_from.q_uid = user.mbdb_uid;
				e->e_from.q_gid = user.mbdb_gid;
				e->e_from.q_flags |= QGOODUID;
			}

			/* extract full name from passwd file */
			if (FullName == NULL && !internal &&
			    user.mbdb_fullname[0] != '\0' &&
			    strcmp(user.mbdb_name, e->e_from.q_user) == 0)
			{
				FullName = newstr(user.mbdb_fullname);
			}
		}
		else
		{
			e->e_from.q_home = NULL;
		}
		if (FullName != NULL && !internal)
			macdefine(&e->e_macro, A_TEMP, 'x', FullName);
	}
	else if (!internal && OpMode != MD_DAEMON && OpMode != MD_SMTP)
	{
		if (e->e_from.q_home == NULL)
		{
			e->e_from.q_home = getenv("HOME");
			if (e->e_from.q_home != NULL)
			{
				if (*e->e_from.q_home == '\0')
					e->e_from.q_home = NULL;
				else if (strcmp(e->e_from.q_home, "/") == 0)
					e->e_from.q_home++;
			}
		}
		e->e_from.q_uid = RealUid;
		e->e_from.q_gid = RealGid;
		e->e_from.q_flags |= QGOODUID;
	}

	/*
	**  Rewrite the from person to dispose of possible implicit
	**	links in the net.
	*/

	pvp = prescan(from, delimchar, pvpbuf, sizeof(pvpbuf), NULL,
			IntTokenTab, false);
	if (pvp == NULL)
	{
		/* don't need to give error -- prescan did that already */
		if (LogLevel > 2)
			sm_syslog(LOG_NOTICE, e->e_id,
				  "cannot prescan from (%s)",
				  shortenstring(from, MAXSHORTSTR));
		finis(true, true, ExitStat);
	}
	(void) REWRITE(pvp, 3, e);
	(void) REWRITE(pvp, 1, e);
	(void) REWRITE(pvp, 4, e);
	macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), NULL);
	bp = buf + 1;
	cataddr(pvp, NULL, bp, sizeof(buf) - 2, '\0', false);
	if (*bp == '@@' && !bitnset(M_NOBRACKET, e->e_from.q_mailer->m_flags))
	{
		/* heuristic: route-addr: add angle brackets */
		(void) sm_strlcat(bp, ">", sizeof(buf) - 1);
		*--bp = '<';
	}
	e->e_sender = sm_rpool_strdup_x(e->e_rpool, bp);
	macdefine(&e->e_macro, A_PERM, 'f', e->e_sender);

	/* save the domain spec if this mailer wants it */
	if (e->e_from.q_mailer != NULL &&
	    bitnset(M_CANONICAL, e->e_from.q_mailer->m_flags))
	{
		char **lastat;

		/* get rid of any pesky angle brackets */
		macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), "e s");
		(void) REWRITE(pvp, 3, e);
		(void) REWRITE(pvp, 1, e);
		(void) REWRITE(pvp, 4, e);
		macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), NULL);

		/* strip off to the last "@@" sign */
		for (lastat = NULL; *pvp != NULL; pvp++)
		{
			if (strcmp(*pvp, "@@") == 0)
				lastat = pvp;
		}
		if (lastat != NULL)
		{
			e->e_fromdomain = copyplist(lastat, true, e->e_rpool);
			if (tTd(45, 3))
			{
				sm_dprintf("Saving from domain: ");
				printav(sm_debug_file(), e->e_fromdomain);
			}
		}
	}
}
/*
**  PRINTENVFLAGS -- print envelope flags for debugging
**
**	Parameters:
**		e -- the envelope with the flags to be printed.
**
**	Returns:
**		none.
*/

struct eflags
{
	char		*ef_name;
	unsigned long	ef_bit;
};

static struct eflags	EnvelopeFlags[] =
{
	{ "OLDSTYLE",		EF_OLDSTYLE	},
	{ "INQUEUE",		EF_INQUEUE	},
	{ "NO_BODY_RETN",	EF_NO_BODY_RETN	},
	{ "CLRQUEUE",		EF_CLRQUEUE	},
	{ "SENDRECEIPT",	EF_SENDRECEIPT	},
	{ "FATALERRS",		EF_FATALERRS	},
	{ "DELETE_BCC",		EF_DELETE_BCC	},
	{ "RESPONSE",		EF_RESPONSE	},
	{ "RESENT",		EF_RESENT	},
	{ "VRFYONLY",		EF_VRFYONLY	},
	{ "WARNING",		EF_WARNING	},
	{ "QUEUERUN",		EF_QUEUERUN	},
	{ "GLOBALERRS",		EF_GLOBALERRS	},
	{ "PM_NOTIFY",		EF_PM_NOTIFY	},
	{ "METOO",		EF_METOO	},
	{ "LOGSENDER",		EF_LOGSENDER	},
	{ "NORECEIPT",		EF_NORECEIPT	},
	{ "HAS8BIT",		EF_HAS8BIT	},
	{ "NL_NOT_EOL",		EF_NL_NOT_EOL	},
	{ "CRLF_NOT_EOL",	EF_CRLF_NOT_EOL	},
	{ "RET_PARAM",		EF_RET_PARAM	},
	{ "HAS_DF",		EF_HAS_DF	},
	{ "IS_MIME",		EF_IS_MIME	},
	{ "DONT_MIME",		EF_DONT_MIME	},
	{ "DISCARD",		EF_DISCARD	},
	{ "TOOBIG",		EF_TOOBIG	},
	{ "SPLIT",		EF_SPLIT	},
	{ "UNSAFE",		EF_UNSAFE	},
	{ NULL,			0		}
};

void
printenvflags(e)
	register ENVELOPE *e;
{
	register struct eflags *ef;
	bool first = true;

	sm_dprintf("%lx", e->e_flags);
	for (ef = EnvelopeFlags; ef->ef_name != NULL; ef++)
	{
		if (!bitset(ef->ef_bit, e->e_flags))
			continue;
		if (first)
			sm_dprintf("<%s", ef->ef_name);
		else
			sm_dprintf(",%s", ef->ef_name);
		first = false;
	}
	if (!first)
		sm_dprintf(">\n");
}
@


1.18
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.17
log
@Update to sendmail 8.14.5
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003, 2006 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.312 2010/02/03 16:36:40 ca Exp $")
@


1.16
log
@Update to sendmail-8.14.3
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.305 2008/03/31 16:32:13 ca Exp $")
d166 1
a166 1
**		none.
d173 1
a173 1
void
d212 1
a212 1
		return;
d218 3
d249 1
d256 1
d626 3
d630 1
d726 3
@


1.15
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.302 2006/11/10 23:12:52 ca Exp $")
d108 3
d114 6
d139 1
a139 1
		e->e_sendmode = sendmode;
@


1.14
log
@Update to sendmail-8.13.8
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.296 2006/03/31 18:53:50 ca Exp $")
d78 1
a78 3
#if _FFR_DM_PER_DAEMON
	int		sendmode;
#endif /* _FFR_DM_PER_DAEMON */
a88 1
#if _FFR_DM_PER_DAEMON
a92 1
#endif /* _FFR_DM_PER_DAEMON */
d100 1
a100 1
			sizeof e->e_from);
d104 1
a104 1
			sizeof e->e_from);
a128 1
#if _FFR_DM_PER_DAEMON
a130 1
#endif /* _FFR_DM_PER_DAEMON */
d286 1
a286 1
				(void) sm_snprintf(buf, sizeof buf,
d292 1
a292 1
				(void) sm_snprintf(buf, sizeof buf,
d384 1
a384 1
					(void) sm_snprintf(buf, sizeof buf,
d389 1
a389 1
					(void) sm_snprintf(buf, sizeof buf,
d485 1
a485 1
			expand(PostMasterCopy, pcopy, sizeof pcopy, e);
d703 2
a704 2
		*nhp = (HDR *) sm_rpool_malloc_x(rpool, sizeof *bh);
		memmove((char *) *nhp, (char *) bh, sizeof *bh);
d763 1
a763 1
	(void) sm_snprintf(buf, sizeof buf, "%d", (int) CurrentPid);
d767 1
a767 1
	(void) sm_snprintf(buf, sizeof buf, "%d", e->e_hopcount);
d785 1
a785 1
			(void) sm_strlcpy(ybuf, sizeof ybuf, p);
d814 1
a814 1
	(void) sm_snprintf(buf, sizeof buf, "%ld", (long) now);
d817 1
a817 1
	(void) sm_snprintf(buf, sizeof buf, "%04d%02d%02d%02d%02d",
d821 1
a821 1
	(void) sm_strlcpy(buf, ctime(&now), sizeof buf);
d1010 1
a1010 1
				(void) sm_snprintf(ebuf, sizeof ebuf,
d1038 1
a1038 1
			expand("\201n", nbuf, sizeof nbuf, e);
d1149 2
a1150 1
	pvp = prescan(from, delimchar, pvpbuf, sizeof pvpbuf, NULL, NULL, false);
d1165 1
a1165 1
	cataddr(pvp, NULL, bp, sizeof buf - 2, '\0');
d1169 1
a1169 1
		(void) sm_strlcat(bp, ">", sizeof buf - 1);
@


1.13
log
@Update to sendmail 8.13.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.295 2005/06/15 20:32:18 ca Exp $")
d522 6
d529 1
@


1.12
log
@update to sendmail 8.13.4
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.294 2005/02/16 23:38:51 ca Exp $")
d78 4
d91 7
d133 4
@


1.11
log
@Update to sendmail.8.13.0
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.293 2004/02/18 00:46:18 gshapiro Exp $")
d521 1
a521 1
			updfs(e, true, !panic);
@


1.10
log
@update to sendmail 8.12.7
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.282.2.2 2002/12/04 15:44:08 ca Exp $")
a103 1
#if _FFR_QUARANTINE
a116 1
#endif /* _FFR_QUARANTINE */
d177 1
a177 1
		xputs(e->e_id);
d183 1
a183 1
			printaddr(e->e_sendqueue, true);
a507 1
#if _FFR_QUARANTINE
a517 1
#endif /* _FFR_QUARANTINE */
a653 1
#if _FFR_QUARANTINE
a656 1
#endif /* _FFR_QUARANTINE */
a728 1
#if _FFR_QUARANTINE
a729 5
#endif /* _FFR_QUARANTINE */
#if _FFR_QUEUEDELAY
	e->e_queuealg = QueueAlg;
	e->e_queuedelay = QueueInitDelay;
#endif /* _FFR_QUEUEDELAY */
d798 2
d1037 1
a1037 1
		printaddr(&e->e_from, false);
d1133 1
a1133 1
	pvp = prescan(from, delimchar, pvpbuf, sizeof pvpbuf, NULL, NULL);
d1173 1
d1176 1
d1183 1
a1183 1
				printav(e->e_fromdomain);
d1244 1
a1244 1
	(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%lx", e->e_flags);
d1250 1
a1250 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "<%s",
					     ef->ef_name);
d1252 1
a1252 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, ",%s",
					     ef->ef_name);
d1256 1
a1256 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, ">\n");
@


1.9
log
@Update to sendmail-8.12.4
@
text
@d16 36
a51 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.282 2002/05/10 15:41:11 ca Exp $")
d961 3
d1118 1
a1118 1
			macdefine(&e->e_macro, A_PERM, 'x', FullName);
@


1.8
log
@update to sendmail 8.12.3
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.281 2002/02/06 19:54:54 ca Exp $")
d521 1
a521 1
					geteuid());
@


1.7
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.279 2001/12/10 19:56:04 ca Exp $")
d1033 7
a1039 2
			if (FullName != NULL && FullName[0] == '\0')
				FullName = NULL;
@


1.6
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.274 2001/09/17 20:39:57 gshapiro Exp $")
d70 1
a70 1
		if (parent->e_holdmsg == NULL)
d72 1
a72 1
			e->e_holdmsg = NULL;
d74 1
a74 1
				  macid("{holdmsg}"), "");
d78 2
a79 2
			e->e_holdmsg = sm_rpool_strdup_x(rpool,
							 parent->e_holdmsg);
d81 1
a81 1
				  macid("{holdmsg}"), e->e_holdmsg);
d128 1
a128 1
	bool savedf = false;
d426 1
a426 1
		savedf = savemail(e, !bitset(EF_NO_BODY_RETN, e->e_flags));
d473 1
a473 1
		if (!savedf)
d475 12
d490 1
a490 1
			updfs(e, true, !savedf);
d516 7
a522 1
			(void) split_by_recipient(e);
d625 2
a626 3
	e->e_holdmsg = NULL;
	macdefine(&e->e_macro, A_PERM,
		  macid("{holdmsg}"), "");
d1108 1
a1108 1
		finis(true, ExitStat);
d1197 2
@


1.5
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.264 2001/08/31 23:03:13 gshapiro Exp $")
d67 1
d69 16
d106 1
a106 1
/*
d469 1
a469 1
			sm_dprintf("\n===== Dropping [dq]f%s... queueit=%d, e_flags=",
d474 2
a475 2
			(void) xunlink(queuename(e, 'd'));
		if (xunlink(queuename(e, 'q')) == 0)
d548 1
a548 1
/*
d605 6
d647 1
a647 1
/*
d683 3
d735 1
a735 1
/*
d772 1
a772 1
/*
d806 1
a806 1
	p = queuename(e, 'x');
d826 1
a826 1
/*
d852 1
a852 1
/*
d1136 1
a1136 1
/*
@


1.4
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@a13 4
#ifndef lint
static char id[] = "@@(#)$Sendmail: envelope.c,v 8.180.14.10 2001/05/03 17:24:06 gshapiro Exp $";
#endif /* ! lint */

d16 1
d19 1
a19 1
**  NEWENVELOPE -- allocate a new envelope
d26 3
d38 1
a38 1
newenvelope(e, parent)
d41 1
d43 10
a52 1
	if (e == parent && e->e_parent != NULL)
d54 1
a54 1
	clearenvelope(e, TRUE);
d71 1
a71 1
		(void) fflush(CurEnv->e_xfp);
d75 14
d95 1
d106 1
a106 1
dropenvelope(e, fulldrop)
d109 1
d111 6
a116 5
	bool queueit = FALSE;
	bool message_timeout = FALSE;
	bool failure_return = FALSE;
	bool delay_return = FALSE;
	bool success_return = FALSE;
d118 1
a118 1
	bool done = FALSE;
d126 1
a126 1
		dprintf("dropenvelope %lx: id=", (u_long) e);
d128 1
a128 1
		dprintf(", flags=");
d132 2
a133 2
			dprintf("sendq=");
			printaddr(e->e_sendqueue, TRUE);
d140 1
a140 1
			  e->e_flags, OpMode, getpid());
d163 3
a165 3
		message_timeout = TRUE;

	if (TimeOuts.to_q_return[e->e_timeoutclass] == NOW &&
d168 7
a174 1
		message_timeout = TRUE;
d182 1
a182 1
			queueit = TRUE;
d186 2
a187 1
		    ((message_timeout && QS_IS_UNDELIVERED(q->q_state)) ||
d189 1
a189 3
		     (TimeOuts.to_q_return[e->e_timeoutclass] == NOW &&
		      !bitset(EF_RESPONSE, e->e_flags))))

d191 1
a191 1
			failure_return = TRUE;
d197 1
a197 1
				done = TRUE;
d200 6
a205 4
		else if (bitset(QPINGONSUCCESS, q->q_flags) &&
			 ((QS_IS_SENT(q->q_state) &&
			   bitnset(M_LOCALMAILER, q->q_mailer->m_flags)) ||
			  bitset(QRELAYED|QEXPANDED|QDELIVERED, q->q_flags)))
d207 1
a207 1
			success_return = TRUE;
d221 1
a221 1
	else if (message_timeout)
d225 9
a233 1
			(void) snprintf(buf, sizeof buf,
d235 6
a240 4
					pintvl(TimeOuts.to_q_return[e->e_timeoutclass], FALSE));
			if (e->e_message != NULL)
				sm_free(e->e_message);
			e->e_message = newstr(buf);
d244 13
a256 3
		fprintf(e->e_xfp, "Message could not be delivered for %s\n",
			pintvl(TimeOuts.to_q_return[e->e_timeoutclass], FALSE));
		fprintf(e->e_xfp, "Message will be deleted from queue\n");
d262 4
a265 1
				q->q_status = "4.4.7";
d269 1
a269 2
	else if (TimeOuts.to_q_warning[e->e_timeoutclass] > 0 &&
		 now >= e->e_ctime + TimeOuts.to_q_warning[e->e_timeoutclass])
d271 10
a280 7
		if (!bitset(EF_WARNING|EF_RESPONSE, e->e_flags) &&
		    e->e_class >= 0 &&
		    e->e_from.q_paddr != NULL &&
		    strcmp(e->e_from.q_paddr, "<>") != 0 &&
		    strncasecmp(e->e_from.q_paddr, "owner-", 6) != 0 &&
		    (strlen(e->e_from.q_paddr) <= (SIZE_T) 8 ||
		     strcasecmp(&e->e_from.q_paddr[strlen(e->e_from.q_paddr) - 8], "-request") != 0))
d282 8
a289 1
			for (q = e->e_sendqueue; q != NULL; q = q->q_next)
d291 4
a294 1
				if (QS_IS_UNDELIVERED(q->q_state) &&
d296 2
a297 1
				    !bitnset(M_HOLD, q->q_mailer->m_flags) &&
d299 25
a323 1
				    bitset(QPINGONDELAY, q->q_flags))
d325 3
a327 2
					q->q_flags |= QDELAYED;
					delay_return = TRUE;
d329 11
d341 15
a356 16
		if (delay_return)
		{
			(void) snprintf(buf, sizeof buf,
				"Warning: could not send message for past %s",
				pintvl(TimeOuts.to_q_warning[e->e_timeoutclass], FALSE));
			if (e->e_message != NULL)
				sm_free(e->e_message);
			e->e_message = newstr(buf);
			message(buf);
			e->e_flags |= EF_WARNING;
		}
		fprintf(e->e_xfp,
			"Warning: message still undelivered after %s\n",
			pintvl(TimeOuts.to_q_warning[e->e_timeoutclass], FALSE));
		fprintf(e->e_xfp, "Will keep trying until message is %s old\n",
			pintvl(TimeOuts.to_q_return[e->e_timeoutclass], FALSE));
d360 1
a360 1
		dprintf("failure_return=%d delay_return=%d success_return=%d queueit=%d\n",
d376 1
a376 1
				failure_return = TRUE;
d393 1
a393 1
			dprintf("dropenvelope(%s): sending return receipt\n",
d408 2
a409 2
			dprintf("dropenvelope(%s): saving mail\n", id);
		savemail(e, !bitset(EF_NO_BODY_RETN, e->e_flags));
d429 1
a429 1
				dprintf("dropenvelope(%s): sending postmaster copy to %s\n",
d446 1
a446 1
		dprintf("dropenvelope(%s): at simpledrop, queueit=%d\n",
d452 1
a452 1
			dprintf("\n===== Dropping [dq]f%s... queueit=%d, e_flags=",
d456 7
a462 2
		xunlink(queuename(e, 'd'));
		xunlink(queuename(e, 'q'));
d466 1
a466 1
				  pintvl(curtime() - e->e_ctime, TRUE),
d471 43
a513 5
#if QUEUE
		queueup(e, FALSE);
#else /* QUEUE */
		syserr("554 5.3.0 dropenvelope: queueup");
#endif /* QUEUE */
d518 1
a518 1
		dprintf("dropenvelope(%s): unlocking job\n", id);
d524 4
a527 2
		(void) bfclose(e->e_dfp);
	e->e_dfp = NULL;
d542 3
d555 1
a555 1
clearenvelope(e, fullclear)
d558 1
d563 1
d569 1
a569 1
			(void) bfclose(e->e_xfp);
d571 1
a571 1
			(void) bfclose(e->e_dfp);
d575 12
a586 2
	/* now clear out the data */
	STRUCTCOPY(BlankEnvelope, *e);
d588 24
d618 1
a618 1
		*nhp = (HDR *) xalloc(sizeof *bh);
d645 1
a645 2
	char cbuf[5];				/* holds hop count */
	char pbuf[10];				/* holds pid */
d655 1
a657 1
	setnewqueue(e);
d681 2
a682 2
	(void) snprintf(pbuf, sizeof pbuf, "%d", (int) getpid());
	define('p', newstr(pbuf), e);
d685 2
a686 2
	(void) snprintf(cbuf, sizeof cbuf, "%d", e->e_hopcount);
	define('c', newstr(cbuf), e);
d692 1
a692 1
	(void)sm_getla(e);
d703 2
a704 2
			snprintf(ybuf, sizeof ybuf, "%s", p);
			define('y', ybuf, e);
d728 1
a728 2
	char tbuf[20];				/* holds "current" time */
	char dbuf[30];				/* holds ctime(tbuf) */
d733 6
a738 5
	(void) snprintf(tbuf, sizeof tbuf, "%04d%02d%02d%02d%02d", tm->tm_year + 1900,
			tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min);
	define('t', newstr(tbuf), e);
	(void) strlcpy(dbuf, ctime(&now), sizeof dbuf);
	p = strchr(dbuf, '\n');
d741 2
a742 3
	define('d', newstr(dbuf), e);
	p = arpadate(dbuf);
	p = newstr(p);
d744 1
a744 2
		define('a', p, e);
	define('b', p, e);
d787 2
a788 1
		e->e_xfp = fopen("/dev/null", "r+");
d790 1
a790 1
			syserr("!Can't open /dev/null");
d792 1
a792 5
#if HASSETVBUF
	(void) setvbuf(e->e_xfp, NULL, _IOLBF, 0);
#else /* HASSETVBUF */
	(void) setlinebuf(e->e_xfp);
#endif /* HASSETVBUF */
d795 3
a797 2
		dprintf("openxscript(%s):\n  ", p);
		dumpfd(fileno(e->e_xfp), TRUE, FALSE);
d823 1
a823 1
	(void) bfclose(e->e_xfp);
a874 1
	register struct passwd *pw;
d881 1
a881 1
		dprintf("setsender(%s)\n", from == NULL ? "" : from);
d895 3
a897 1
		SuprErrs = TRUE;
a898 3
#if _FFR_ADDR_TYPE
	define(macid("{addr_type}", NULL), "e s", e);
#endif /* _FFR_ADDR_TYPE */
d904 1
a904 1
		      delimchar, delimptr, e) == NULL ||
d923 3
a925 3
				(void) snprintf(ebuf, sizeof ebuf, "%.*s@@%.*s",
					MAXNAME, realname,
					MAXNAME, host);
d941 1
a941 1
			SuprErrs = TRUE;
d944 3
a946 2
		    parseaddr(from = newstr(realname), &e->e_from,
			      RF_COPYALL|RF_SENDERADDR, ' ', NULL, e) == NULL)
d950 1
a950 1
			SuprErrs = TRUE;
d952 3
a954 2
			if (parseaddr(from = newstr(nbuf), &e->e_from,
				      RF_COPYALL, ' ', NULL, e) == NULL &&
d956 1
a956 1
				      RF_COPYALL, ' ', NULL, e) == NULL)
d961 1
a961 1
		FromFlag = TRUE;
d965 2
a966 2
		dprintf("setsender: QS_SENDER ");
		printaddr(&e->e_from, FALSE);
d968 1
a968 1
	SuprErrs = FALSE;
d975 1
a975 1
		p = udbsender(e->e_from.q_user);
d983 2
d995 1
a995 1
		    (pw = sm_getpwnam(e->e_from.q_user)) != NULL)
d1002 1
a1002 1
			if (*pw->pw_dir == '\0')
d1004 2
a1005 2
			else if (strcmp(pw->pw_dir, "/") == 0)
				e->e_from.q_home = newstr("");
d1007 3
a1009 2
				e->e_from.q_home = newstr(pw->pw_dir);
			define('z', e->e_from.q_home, e);
d1012 6
a1017 3
			e->e_from.q_uid = pw->pw_uid;
			e->e_from.q_gid = pw->pw_gid;
			e->e_from.q_flags |= QGOODUID;
d1020 5
a1024 7
			if (FullName == NULL && pw->pw_gecos != NULL &&
			    strcmp(pw->pw_name, e->e_from.q_user) == 0 &&
			    !internal)
			{
				buildfname(pw->pw_gecos, e->e_from.q_user, buf, sizeof buf);
				if (buf[0] != '\0')
					FullName = newstr(buf);
d1032 1
a1032 1
			define('x', FullName, e);
d1065 1
a1065 1
		finis(TRUE, ExitStat);
d1067 4
a1070 6
	(void) rewrite(pvp, 3, 0, e);
	(void) rewrite(pvp, 1, 0, e);
	(void) rewrite(pvp, 4, 0, e);
#if _FFR_ADDR_TYPE
	define(macid("{addr_type}", NULL), NULL, e);
#endif /* _FFR_ADDR_TYPE */
d1076 1
a1076 1
		(void) strlcat(bp, ">", sizeof buf - 1);
d1079 2
a1080 2
	e->e_sender = newstr(bp);
	define('f', e->e_sender, e);
d1089 5
a1093 9
#if _FFR_ADDR_TYPE
		define(macid("{addr_type}", NULL), "e s", e);
#endif /* _FFR_ADDR_TYPE */
		(void) rewrite(pvp, 3, 0, e);
		(void) rewrite(pvp, 1, 0, e);
		(void) rewrite(pvp, 4, 0, e);
#if _FFR_ADDR_TYPE
		define(macid("{addr_type}", NULL), NULL, e);
#endif /* _FFR_ADDR_TYPE */
d1101 1
a1101 1
			e->e_fromdomain = copyplist(lastat, TRUE);
d1104 1
a1104 1
				dprintf("Saving from domain: ");
d1122 2
a1123 2
	char	*ef_name;
	u_long	ef_bit;
d1152 2
d1162 1
a1162 1
	bool first = TRUE;
d1164 1
a1164 1
	printf("%lx", e->e_flags);
d1170 2
a1171 1
			printf("<%s", ef->ef_name);
d1173 3
a1175 2
			printf(",%s", ef->ef_name);
		first = FALSE;
d1178 1
a1178 1
		printf(">\n");
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: envelope.c,v 8.180.14.6 2000/11/30 00:39:46 gshapiro Exp $";
d135 1
a135 1
	if (now > e->e_ctime + TimeOuts.to_q_return[e->e_timeoutclass])
d153 1
a153 1
		    ((message_timeout && QS_IS_QUEUEUP(q->q_state)) ||
d195 1
a195 1
				free(e->e_message);
d213 1
a213 1
		 now > e->e_ctime + TimeOuts.to_q_warning[e->e_timeoutclass])
d225 1
a225 1
				if (QS_IS_QUEUEUP(q->q_state) &&
d242 1
a242 1
				free(e->e_message);
@


1.3.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: envelope.c,v 8.180.14.10 2001/05/03 17:24:06 gshapiro Exp $";
d135 1
a135 1
	if (now >= e->e_ctime + TimeOuts.to_q_return[e->e_timeoutclass])
d153 1
a153 1
		    ((message_timeout && QS_IS_UNDELIVERED(q->q_state)) ||
d195 1
a195 1
				sm_free(e->e_message);
d213 1
a213 1
		 now >= e->e_ctime + TimeOuts.to_q_warning[e->e_timeoutclass])
d225 1
a225 1
				if (QS_IS_UNDELIVERED(q->q_state) &&
d242 1
a242 1
				sm_free(e->e_message);
@


1.2
log
@$HOME paranoia: never use getenv("HOME") w/o checking for NULL and non-zero
@
text
@d2 1
a2 1
 * Copyright (c) 1998, 1999 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: envelope.c,v 8.180 1999/12/03 03:39:44 gshapiro Exp $";
d20 1
d91 1
d94 1
d134 2
a135 1
	if (curtime() > e->e_ctime + TimeOuts.to_q_return[e->e_timeoutclass])
d154 4
a157 1
		     QS_IS_BADADDR(q->q_state)))
d160 3
a162 1
			if (q->q_owner == NULL && !emptyaddr(&e->e_from))
d165 2
d192 2
a193 2
				"Cannot send message within %s",
				pintvl(TimeOuts.to_q_return[e->e_timeoutclass], FALSE));
d213 1
a213 1
	    curtime() > e->e_ctime + TimeOuts.to_q_warning[e->e_timeoutclass])
d267 2
a268 1
			if (QS_IS_UNDELIVERED(q->q_state) &&
d597 1
d816 3
a818 1
			if (strcmp(pw->pw_dir, "/") == 0)
d970 1
a970 1
	{ NULL }
@


1.2.2.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: envelope.c,v 8.180.14.10 2001/05/03 17:24:06 gshapiro Exp $";
a19 1

a89 1
	bool done = FALSE;
a91 1
	time_t now;
d131 1
a131 2
	now = curtime();
	if (now >= e->e_ctime + TimeOuts.to_q_return[e->e_timeoutclass])
d149 2
a150 5
		    ((message_timeout && QS_IS_UNDELIVERED(q->q_state)) ||
		     QS_IS_BADADDR(q->q_state) ||
		     (TimeOuts.to_q_return[e->e_timeoutclass] == NOW &&
		      !bitset(EF_RESPONSE, e->e_flags))))

d153 1
a153 3
			if (!done && q->q_owner == NULL &&
			    !emptyaddr(&e->e_from))
			{
a155 2
				done = TRUE;
			}
d181 2
a182 2
					"Cannot send message for %s",
					pintvl(TimeOuts.to_q_return[e->e_timeoutclass], FALSE));
d184 1
a184 1
				sm_free(e->e_message);
d202 1
a202 1
		 now >= e->e_ctime + TimeOuts.to_q_warning[e->e_timeoutclass])
d214 1
a214 1
				if (QS_IS_UNDELIVERED(q->q_state) &&
d231 1
a231 1
				sm_free(e->e_message);
d256 1
a256 2
			if ((QS_IS_OK(q->q_state) ||
			     QS_IS_VERIFIED(q->q_state)) &&
a584 1

d803 1
a803 3
			if (*pw->pw_dir == '\0')
				e->e_from.q_home = NULL;
			else if (strcmp(pw->pw_dir, "/") == 0)
d955 1
a955 1
	{ NULL,			0		}
@


1.1
log
@Initial revision
@
text
@d836 7
a842 3
			if (e->e_from.q_home != NULL &&
			    strcmp(e->e_from.q_home, "/") == 0)
				e->e_from.q_home++;
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Id: envelope.c,v 8.180.14.6 2000/11/30 00:39:46 gshapiro Exp $";
a19 1

a89 1
	bool done = FALSE;
a91 1
	time_t now;
d131 1
a131 2
	now = curtime();
	if (now > e->e_ctime + TimeOuts.to_q_return[e->e_timeoutclass])
d150 1
a150 4
		     QS_IS_BADADDR(q->q_state) ||
		     (TimeOuts.to_q_return[e->e_timeoutclass] == NOW &&
		      !bitset(EF_RESPONSE, e->e_flags))))

d153 1
a153 3
			if (!done && q->q_owner == NULL &&
			    !emptyaddr(&e->e_from))
			{
a155 2
				done = TRUE;
			}
d181 2
a182 2
					"Cannot send message for %s",
					pintvl(TimeOuts.to_q_return[e->e_timeoutclass], FALSE));
d202 1
a202 1
		 now > e->e_ctime + TimeOuts.to_q_warning[e->e_timeoutclass])
d256 1
a256 2
			if ((QS_IS_OK(q->q_state) ||
			     QS_IS_VERIFIED(q->q_state)) &&
a584 1

d803 1
a803 3
			if (*pw->pw_dir == '\0')
				e->e_from.q_home = NULL;
			else if (strcmp(pw->pw_dir, "/") == 0)
d836 3
a838 7
			if (e->e_from.q_home != NULL)
			{
				if (*e->e_from.q_home == '\0')
					e->e_from.q_home = NULL;
				else if (strcmp(e->e_from.q_home, "/") == 0)
					e->e_from.q_home++;
			}
d951 1
a951 1
	{ NULL,			0		}
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d14 4
a19 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.264 2001/08/31 23:03:13 gshapiro Exp $")
d22 1
a22 1
**  NEWENVELOPE -- fill in a new envelope
a28 3
**		rpool -- either NULL, or a pointer to a resource pool
**			from which envelope memory is allocated, and
**			to which envelope resources are attached.
d38 1
a38 1
newenvelope(e, parent, rpool)
a40 1
	SM_RPOOL_T *rpool;
d42 1
a42 10
	/*
	**  This code used to read:
	**	if (e == parent && e->e_parent != NULL)
	**		parent = e->e_parent;
	**  So if e == parent && e->e_parent == NULL then we would
	**  set e->e_parent = e, which creates a loop in the e_parent chain.
	**  This meant macvalue() could go into an infinite loop.
	*/

	if (e == parent)
d44 1
a44 1
	clearenvelope(e, true, rpool);
d61 1
a61 1
		(void) sm_io_flush(CurEnv->e_xfp, SM_TIME_DEFAULT);
a64 14

/* values for msg_timeout, see also IS_* below for usage (bit layout) */
#define MSG_T_O		0x01	/* normal timeout */
#define MSG_T_O_NOW	0x02	/* NOW timeout */
#define MSG_NOT_BY	0x04	/* Deliver-By time exceeded, mode R */
#define MSG_WARN	0x10	/* normal queue warning */
#define MSG_WARN_BY	0x20	/* Deliver-By time exceeded, mode N */

#define IS_MSG_ERR(x)	(((x) & 0x0f) != 0)	/* return an error */

/* immediate return */
#define IS_IMM_RET(x)	(((x) & (MSG_T_O_NOW|MSG_NOT_BY)) != 0)
#define IS_MSG_WARN(x)	(((x) & 0xf0) != 0)	/* return a warning */

a70 1
**		split -- if true, split by recipient if message is queued up
d81 1
a81 1
dropenvelope(e, fulldrop, split)
a83 1
	bool split;
d85 5
a89 6
	bool savedf = false;
	bool queueit = false;
	int msg_timeout = 0;
	bool failure_return = false;
	bool delay_return = false;
	bool success_return = false;
d91 1
a91 1
	bool done = false;
d99 1
a99 1
		sm_dprintf("dropenvelope %p: id=", e);
d101 1
a101 1
		sm_dprintf(", flags=");
d105 2
a106 2
			sm_dprintf("sendq=");
			printaddr(e->e_sendqueue, true);
d113 1
a113 1
			  e->e_flags, OpMode, (int) CurrentPid);
d135 4
a138 4
	if (now >= e->e_ctime + TimeOuts.to_q_return[e->e_timeoutclass])
		msg_timeout = MSG_T_O;
	if (IS_DLVR_RETURN(e) && e->e_deliver_by > 0 &&
	    now >= e->e_ctime + e->e_deliver_by &&
d141 1
a141 7
		msg_timeout = MSG_NOT_BY;
		e->e_flags |= EF_FATALERRS|EF_CLRQUEUE;
	}
	else if (TimeOuts.to_q_return[e->e_timeoutclass] == NOW &&
		 !bitset(EF_RESPONSE, e->e_flags))
	{
		msg_timeout = MSG_T_O_NOW;
d149 1
a149 1
			queueit = true;
d153 1
a153 2
		    ((IS_MSG_ERR(msg_timeout) &&
		      QS_IS_UNDELIVERED(q->q_state)) ||
d155 3
a157 1
		     IS_IMM_RET(msg_timeout)))
d159 1
a159 1
			failure_return = true;
d165 1
a165 1
				done = true;
d168 4
a171 6
		else if ((bitset(QPINGONSUCCESS, q->q_flags) &&
			  ((QS_IS_SENT(q->q_state) &&
			    bitnset(M_LOCALMAILER, q->q_mailer->m_flags)) ||
			   bitset(QRELAYED|QEXPANDED|QDELIVERED, q->q_flags))) ||
			  bitset(QBYTRACE, q->q_flags) ||
			  bitset(QBYNRELAY, q->q_flags))
d173 1
a173 1
			success_return = true;
d187 1
a187 1
	else if (IS_MSG_ERR(msg_timeout))
d191 1
a191 9
			if (msg_timeout == MSG_NOT_BY)
			{
				(void) sm_snprintf(buf, sizeof buf,
					"delivery time expired %lds",
					e->e_deliver_by);
			}
			else
			{
				(void) sm_snprintf(buf, sizeof buf,
d193 4
a196 6
					pintvl(TimeOuts.to_q_return[e->e_timeoutclass],
						false));
			}

			/* don't free, allocated from e_rpool */
			e->e_message = sm_rpool_strdup_x(e->e_rpool, buf);
d200 3
a202 13
		if (msg_timeout == MSG_NOT_BY)
		{
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
				"Delivery time (%lds) expired\n",
				e->e_deliver_by);
		}
		else
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
				"Message could not be delivered for %s\n",
				pintvl(TimeOuts.to_q_return[e->e_timeoutclass],
					false));
		(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
			"Message will be deleted from queue\n");
d208 1
a208 4
				if (msg_timeout == MSG_NOT_BY)
					q->q_status = "5.4.7";
				else
					q->q_status = "4.4.7";
d212 2
a213 1
	else
d215 7
a221 10
		if (TimeOuts.to_q_warning[e->e_timeoutclass] > 0 &&
		    now >= e->e_ctime +
				TimeOuts.to_q_warning[e->e_timeoutclass])
			msg_timeout = MSG_WARN;
		else if (IS_DLVR_NOTIFY(e) &&
			 e->e_deliver_by > 0 &&
			 now >= e->e_ctime + e->e_deliver_by)
			msg_timeout = MSG_WARN_BY;

		if (IS_MSG_WARN(msg_timeout))
d223 1
a223 8
			if (!bitset(EF_WARNING|EF_RESPONSE, e->e_flags) &&
			    e->e_class >= 0 &&
			    e->e_from.q_paddr != NULL &&
			    strcmp(e->e_from.q_paddr, "<>") != 0 &&
			    sm_strncasecmp(e->e_from.q_paddr, "owner-", 6) != 0 &&
			    (strlen(e->e_from.q_paddr) <= 8 ||
			     sm_strcasecmp(&e->e_from.q_paddr[strlen(e->e_from.q_paddr) - 8],
					   "-request") != 0))
d225 1
a225 4
				for (q = e->e_sendqueue; q != NULL;
				     q = q->q_next)
				{
					if (QS_IS_UNDELIVERED(q->q_state)
d227 1
a227 2
					    && !bitnset(M_HOLD,
							q->q_mailer->m_flags)
d229 1
a229 25
					   )
					{
						if (msg_timeout ==
						    MSG_WARN_BY &&
						    (bitset(QPINGONDELAY,
							    q->q_flags) ||
						    !bitset(QHASNOTIFY,
							    q->q_flags))
						   )
						{
							q->q_flags |= QBYNDELAY;
							delay_return = true;
						}
						if (bitset(QPINGONDELAY,
							   q->q_flags))
						{
							q->q_flags |= QDELAYED;
							delay_return = true;
						}
					}
				}
			}
			if (delay_return)
			{
				if (msg_timeout == MSG_WARN_BY)
d231 2
a232 3
					(void) sm_snprintf(buf, sizeof buf,
						"Warning: Delivery time (%lds) exceeded",
						e->e_deliver_by);
a233 11
				else
					(void) sm_snprintf(buf, sizeof buf,
						"Warning: could not send message for past %s",
						pintvl(TimeOuts.to_q_warning[e->e_timeoutclass],
							false));

				/* don't free, allocated from e_rpool */
				e->e_message = sm_rpool_strdup_x(e->e_rpool,
								 buf);
				message(buf);
				e->e_flags |= EF_WARNING;
a234 15
			if (msg_timeout == MSG_WARN_BY)
			{
				(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
					"Warning: Delivery time (%lds) exceeded\n",
					e->e_deliver_by);
			}
			else
				(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
					"Warning: message still undelivered after %s\n",
					pintvl(TimeOuts.to_q_warning[e->e_timeoutclass],
					     false));
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
				      "Will keep trying until message is %s old\n",
				      pintvl(TimeOuts.to_q_return[e->e_timeoutclass],
					     false));
d236 16
d255 1
a255 1
		sm_dprintf("failure_return=%d delay_return=%d success_return=%d queueit=%d\n",
d271 1
a271 1
				failure_return = true;
d288 1
a288 1
			sm_dprintf("dropenvelope(%s): sending return receipt\n",
d303 2
a304 2
			sm_dprintf("dropenvelope(%s): saving mail\n", id);
		savedf = savemail(e, !bitset(EF_NO_BODY_RETN, e->e_flags));
d324 1
a324 1
				sm_dprintf("dropenvelope(%s): sending postmaster copy to %s\n",
d341 1
a341 1
		sm_dprintf("dropenvelope(%s): at simpledrop, queueit=%d\n",
d347 1
a347 1
			sm_dprintf("\n===== Dropping [dq]f%s... queueit=%d, e_flags=",
d351 2
a352 7
		if (!savedf)
			(void) xunlink(queuename(e, 'd'));
		if (xunlink(queuename(e, 'q')) == 0)
		{
			/* add to available space in filesystem */
			updfs(e, true, !savedf);
		}
d356 1
a356 1
				  pintvl(curtime() - e->e_ctime, true),
d361 5
a365 43
		if (!split)
			queueup(e, false, true);
		else
		{
			ENVELOPE *oldsib;
			ENVELOPE *ee;

			/*
			**  Save old sibling and set it to NULL to avoid
			**  queueing up the same envelopes again.
			**  This requires that envelopes in that list have
			**  been take care of before (or at some other place).
			*/

			oldsib = e->e_sibling;
			e->e_sibling = NULL;
			(void) split_by_recipient(e);
			for (ee = e->e_sibling; ee != NULL; ee = ee->e_sibling)
				queueup(ee, false, true);
			queueup(e, false, true);

			/* clean up */
			for (ee = e->e_sibling; ee != NULL; ee = ee->e_sibling)
			{
				/* now unlock the job */
				if (tTd(50, 8))
					sm_dprintf("dropenvelope(%s): unlocking job\n",
						   ee->e_id);
				closexscript(ee);
				unlockqueue(ee);

				/* this envelope is marked unused */
				if (ee->e_dfp != NULL)
				{
					(void) sm_io_close(ee->e_dfp,
							   SM_TIME_DEFAULT);
					ee->e_dfp = NULL;
				}
				ee->e_id = NULL;
				ee->e_flags &= ~EF_HAS_DF;
			}
			e->e_sibling = oldsib;
		}
d370 1
a370 1
		sm_dprintf("dropenvelope(%s): unlocking job\n", id);
d376 2
a377 4
	{
		(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT);
		e->e_dfp = NULL;
	}
a391 3
**		rpool -- either NULL, or a pointer to a resource pool
**			from which envelope memory is allocated, and
**			to which envelope resources are attached.
d402 1
a402 1
clearenvelope(e, fullclear, rpool)
a404 1
	SM_RPOOL_T *rpool;
a408 1
	char **p;
d414 1
a414 1
			(void) sm_io_close(e->e_xfp, SM_TIME_DEFAULT);
d416 1
a416 1
			(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT);
d420 2
a421 12
	/*
	**  Copy BlankEnvelope into *e.
	**  It is not safe to simply copy pointers to strings;
	**  the strings themselves must be copied (or set to NULL).
	**  The problem is that when we assign a new string value to
	**  a member of BlankEnvelope, we free the old string.
	**  We did not need to do this copying in sendmail 8.11 :-(
	**  and it is a potential performance hit.  Reference counted
	**  strings are one way out.
	*/

	*e = BlankEnvelope;
a422 24

	/*
	**  Copy the macro table.
	**  We might be able to avoid this by zeroing the macro table
	**  and always searching BlankEnvelope.e_macro after e->e_macro
	**  in macvalue().
	*/

	for (p = &e->e_macro.mac_table[0];
	     p <= &e->e_macro.mac_table[MAXMACROID];
	     ++p)
	{
		if (*p != NULL)
			*p = sm_rpool_strdup_x(rpool, *p);
	}

	/*
	**  XXX There are many strings in the envelope structure
	**  XXX that we are not attempting to copy here.
	**  XXX Investigate this further.
	*/

	e->e_rpool = rpool;
	e->e_macro.mac_rpool = rpool;
d429 1
a429 1
		*nhp = (HDR *) sm_rpool_malloc_x(rpool, sizeof *bh);
d456 2
a457 1
	char buf[10];
a466 1
	**  We don't select the queue until all of the recipients are known.
d469 1
d493 2
a494 2
	(void) sm_snprintf(buf, sizeof buf, "%d", (int) CurrentPid);
	macdefine(&e->e_macro, A_TEMP, 'p', buf);
d497 2
a498 2
	(void) sm_snprintf(buf, sizeof buf, "%d", e->e_hopcount);
	macdefine(&e->e_macro, A_TEMP, 'c', buf);
d504 1
a504 1
	sm_getla();
d515 2
a516 2
			(void) sm_strlcpy(ybuf, sizeof ybuf, p);
			macdefine(&e->e_macro, A_PERM, 'y', ybuf);
d540 2
a541 1
	char buf[30];
d546 5
a550 6
	(void) sm_snprintf(buf, sizeof buf, "%04d%02d%02d%02d%02d",
			   tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
			   tm->tm_hour, tm->tm_min);
	macdefine(&e->e_macro, A_TEMP, 't', buf);
	(void) sm_strlcpy(buf, ctime(&now), sizeof buf);
	p = strchr(buf, '\n');
d553 3
a555 2
	macdefine(&e->e_macro, A_TEMP, 'd', buf);
	macdefine(&e->e_macro, A_TEMP, 'b', arpadate(buf));
d557 2
a558 1
		macdefine(&e->e_macro, A_PERM, 'a', macvalue('b', e));
d601 1
a601 2
		e->e_xfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT,
				      SM_PATH_DEVNULL, SM_IO_RDWR, NULL);
d603 1
a603 1
			syserr("!Can't open %s", SM_PATH_DEVNULL);
d605 5
a609 1
	(void) sm_io_setvbuf(e->e_xfp, SM_TIME_DEFAULT, NULL, SM_IO_LBF, 0);
d612 2
a613 3
		sm_dprintf("openxscript(%s):\n  ", p);
		dumpfd(sm_io_getinfo(e->e_xfp, SM_IO_WHAT_FD, NULL), true,
		       false);
d639 1
a639 1
	(void) sm_io_close(e->e_xfp, SM_TIME_DEFAULT);
d691 1
d698 1
a698 1
		sm_dprintf("setsender(%s)\n", from == NULL ? "" : from);
d712 1
a712 3
		SuprErrs = true;

	macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), "e s");
d714 3
d722 1
a722 1
		      delimchar, delimptr, e, false) == NULL ||
d741 3
a743 3
				(void) sm_snprintf(ebuf, sizeof ebuf,
						   "%.*s@@%.*s", MAXNAME,
						   realname, MAXNAME, host);
d759 1
a759 1
			SuprErrs = true;
d762 2
a763 3
		    parseaddr(from = realname,
			      &e->e_from, RF_COPYALL|RF_SENDERADDR, ' ',
			      NULL, e, false) == NULL)
d767 1
a767 1
			SuprErrs = true;
d769 2
a770 3
			from = sm_rpool_strdup_x(e->e_rpool, nbuf);
			if (parseaddr(from, &e->e_from, RF_COPYALL, ' ',
				      NULL, e, false) == NULL &&
d772 1
a772 1
				      RF_COPYALL, ' ', NULL, e, false) == NULL)
d777 1
a777 1
		FromFlag = true;
d781 2
a782 2
		sm_dprintf("setsender: QS_SENDER ");
		printaddr(&e->e_from, false);
d784 1
a784 1
	SuprErrs = false;
d791 1
a791 1
		p = udbsender(e->e_from.q_user, e->e_rpool);
a798 2
		SM_MBDB_T user;

d809 1
a809 1
		    sm_mbdb_lookup(e->e_from.q_user, &user) == EX_OK)
d816 1
a816 1
			if (*user.mbdb_homedir == '\0')
d818 2
a819 2
			else if (strcmp(user.mbdb_homedir, "/") == 0)
				e->e_from.q_home = "";
d821 2
a822 3
				e->e_from.q_home = sm_rpool_strdup_x(e->e_rpool,
							user.mbdb_homedir);
			macdefine(&e->e_macro, A_PERM, 'z', e->e_from.q_home);
d825 3
a827 6
			if (user.mbdb_uid != SM_NO_UID)
			{
				e->e_from.q_uid = user.mbdb_uid;
				e->e_from.q_gid = user.mbdb_gid;
				e->e_from.q_flags |= QGOODUID;
			}
d830 7
a836 5
			if (FullName == NULL && !internal &&
			    user.mbdb_fullname[0] != '\0' &&
			    strcmp(user.mbdb_name, e->e_from.q_user) == 0)
			{
				FullName = newstr(user.mbdb_fullname);
d844 1
a844 1
			macdefine(&e->e_macro, A_PERM, 'x', FullName);
d877 1
a877 1
		finis(true, ExitStat);
d879 6
a884 4
	(void) REWRITE(pvp, 3, e);
	(void) REWRITE(pvp, 1, e);
	(void) REWRITE(pvp, 4, e);
	macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), NULL);
d890 1
a890 1
		(void) sm_strlcat(bp, ">", sizeof buf - 1);
d893 2
a894 2
	e->e_sender = sm_rpool_strdup_x(e->e_rpool, bp);
	macdefine(&e->e_macro, A_PERM, 'f', e->e_sender);
d903 9
a911 5
		macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), "e s");
		(void) REWRITE(pvp, 3, e);
		(void) REWRITE(pvp, 1, e);
		(void) REWRITE(pvp, 4, e);
		macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), NULL);
d919 1
a919 1
			e->e_fromdomain = copyplist(lastat, true, e->e_rpool);
d922 1
a922 1
				sm_dprintf("Saving from domain: ");
d940 2
a941 2
	char		*ef_name;
	unsigned long	ef_bit;
a969 2
	{ "DISCARD",		EF_DISCARD	},
	{ "TOOBIG",		EF_TOOBIG	},
d978 1
a978 1
	bool first = true;
d980 1
a980 1
	(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%lx", e->e_flags);
d986 1
a986 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "<%s",
					     ef->ef_name);
d988 2
a989 3
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, ",%s",
					     ef->ef_name);
		first = false;
d992 1
a992 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, ">\n");
@


