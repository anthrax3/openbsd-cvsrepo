head	1.13;
access;
symbols
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.4
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.2
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.10.0.24
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.22
	OPENBSD_5_0:1.10.0.20
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.18
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.16
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.12
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.14
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.10
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.8
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.6
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.4
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.9.0.10
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.8
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.8
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2014.09.17.18.49.52;	author matthieu;	state dead;
branches;
next	1.12;
commitid	M7i5giHIoz3DMlTU;

1.12
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2012.12.26.11.44.12;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.24.03.59.28;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.17.17.31.41;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.01.17.18.30;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.11.19.02.50;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.29.01.31.16;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.15.21.09.10;	author millert;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.10.09.23.45.01;	author millert;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.04.02.19.05.48;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.48;	author millert;	state Exp;
branches
	1.1.1.1.2.1;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.18;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.51;	author millert;	state Exp;
branches;
next	;

1.1.1.1.2.1
date	2000.10.10.05.13.40;	author jason;	state Exp;
branches;
next	;

1.2.2.1
date	2001.05.31.00.31.44;	author miod;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.31.01.47.58;	author jason;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2001, 2003 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>

SM_RCSID("@@(#)$Sendmail: stab.c,v 8.92 2013/11/22 20:51:56 ca Exp $")

/*
**  STAB -- manage the symbol table
**
**	Parameters:
**		name -- the name to be looked up or inserted.
**		type -- the type of symbol.
**		op -- what to do:
**			ST_ENTER -- enter the name if not already present.
**			ST_FIND -- find it only.
**
**	Returns:
**		pointer to a STAB entry for this name.
**		NULL if not found and not entered.
**
**	Side Effects:
**		can update the symbol table.
*/

#define STABSIZE	2003
#define SM_LOWER(c)	((isascii(c) && isupper(c)) ? tolower(c) : (c))

static STAB	*SymTab[STABSIZE];

STAB *
stab(name, type, op)
	char *name;
	int type;
	int op;
{
	register STAB *s;
	register STAB **ps;
	register int hfunc;
	register char *p;
	int len;

	if (tTd(36, 5))
		sm_dprintf("STAB: %s %d ", name, type);

	/*
	**  Compute the hashing function
	*/

	hfunc = type;
	for (p = name; *p != '\0'; p++)
		hfunc = ((hfunc << 1) ^ (SM_LOWER(*p) & 0377)) % STABSIZE;

	if (tTd(36, 9))
		sm_dprintf("(hfunc=%d) ", hfunc);

	ps = &SymTab[hfunc];
	if (type == ST_MACRO || type == ST_RULESET || type == ST_NAMECANON)
	{
		while ((s = *ps) != NULL &&
		       (s->s_symtype != type || strcmp(name, s->s_name)))
			ps = &s->s_next;
	}
	else
	{
		while ((s = *ps) != NULL &&
		       (s->s_symtype != type || sm_strcasecmp(name, s->s_name)))
			ps = &s->s_next;
	}

	/*
	**  Dispose of the entry.
	*/

	if (s != NULL || op == ST_FIND)
	{
		if (tTd(36, 5))
		{
			if (s == NULL)
				sm_dprintf("not found\n");
			else
			{
				long *lp = (long *) s->s_class;

				sm_dprintf("type %d val %lx %lx %lx %lx\n",
					s->s_symtype, lp[0], lp[1], lp[2], lp[3]);
			}
		}
		return s;
	}

	/*
	**  Make a new entry and link it in.
	*/

	if (tTd(36, 5))
		sm_dprintf("entered\n");

	/* determine size of new entry */
	switch (type)
	{
	  case ST_CLASS:
		len = sizeof(s->s_class);
		break;

	  case ST_MAILER:
		len = sizeof(s->s_mailer);
		break;

	  case ST_ALIAS:
		len = sizeof(s->s_alias);
		break;

	  case ST_MAPCLASS:
		len = sizeof(s->s_mapclass);
		break;

	  case ST_MAP:
		len = sizeof(s->s_map);
		break;

	  case ST_HOSTSIG:
		len = sizeof(s->s_hostsig);
		break;

	  case ST_NAMECANON:
		len = sizeof(s->s_namecanon);
		break;

	  case ST_MACRO:
		len = sizeof(s->s_macro);
		break;

	  case ST_RULESET:
		len = sizeof(s->s_ruleset);
		break;

	  case ST_HEADER:
		len = sizeof(s->s_header);
		break;

	  case ST_SERVICE:
		len = sizeof(s->s_service);
		break;

#if LDAPMAP
	  case ST_LMAP:
		len = sizeof(s->s_lmap);
		break;
#endif /* LDAPMAP */

#if MILTER
	  case ST_MILTER:
		len = sizeof(s->s_milter);
		break;
#endif /* MILTER */

	  case ST_QUEUE:
		len = sizeof(s->s_quegrp);
		break;

#if SOCKETMAP
	  case ST_SOCKETMAP:
		len = sizeof(s->s_socketmap);
		break;
#endif /* SOCKETMAP */

	  default:
		/*
		**  Each mailer has its own MCI stab entry:
		**
		**  s = stab(host, ST_MCI + m->m_mno, ST_ENTER);
		**
		**  Therefore, anything ST_MCI or larger is an s_mci.
		*/

		if (type >= ST_MCI)
			len = sizeof(s->s_mci);
		else
		{
			syserr("stab: unknown symbol type %d", type);
			len = sizeof(s->s_value);
		}
		break;
	}
	len += sizeof(*s) - sizeof(s->s_value);

	if (tTd(36, 15))
		sm_dprintf("size of stab entry: %d\n", len);

	/* make new entry */
	s = (STAB *) sm_pmalloc_x(len);
	memset((char *) s, '\0', len);
	s->s_name = sm_pstrdup_x(name);
	s->s_symtype = type;

	/* link it in */
	*ps = s;

	/* set a default value for rulesets */
	if (type == ST_RULESET)
		s->s_ruleset = -1;

	return s;
}
/*
**  STABAPPLY -- apply function to all stab entries
**
**	Parameters:
**		func -- the function to apply.  It will be given two
**			parameters (the stab entry and the arg).
**		arg -- an arbitrary argument, passed to func.
**
**	Returns:
**		none.
*/

void
stabapply(func, arg)
	void (*func)__P((STAB *, int));
	int arg;
{
	register STAB **shead;
	register STAB *s;

	for (shead = SymTab; shead < &SymTab[STABSIZE]; shead++)
	{
		for (s = *shead; s != NULL; s = s->s_next)
		{
			if (tTd(36, 90))
				sm_dprintf("stabapply: trying %d/%s\n",
					s->s_symtype, s->s_name);
			func(s, arg);
		}
	}
}
/*
**  QUEUEUP_MACROS -- queueup the macros in a class
**
**	Write the macros listed in the specified class into the
**	file referenced by qfp.
**
**	Parameters:
**		class -- class ID.
**		qfp -- file pointer to the queue file.
**		e -- the envelope.
**
**	Returns:
**		none.
*/

void
queueup_macros(class, qfp, e)
	int class;
	SM_FILE_T *qfp;
	ENVELOPE *e;
{
	register STAB **shead;
	register STAB *s;

	if (e == NULL)
		return;

	class = bitidx(class);
	for (shead = SymTab; shead < &SymTab[STABSIZE]; shead++)
	{
		for (s = *shead; s != NULL; s = s->s_next)
		{
			int m;
			char *p;

			if (s->s_symtype == ST_CLASS &&
			    bitnset(bitidx(class), s->s_class) &&
			    (m = macid(s->s_name)) != 0 &&
			    (p = macvalue(m, e)) != NULL)
			{
				(void) sm_io_fprintf(qfp, SM_TIME_DEFAULT,
						      "$%s%s\n",
						      s->s_name,
						      denlstring(p, true,
								 false));
			}
		}
	}
}
/*
**  COPY_CLASS -- copy class members from one class to another
**
**	Parameters:
**		src -- source class.
**		dst -- destination class.
**
**	Returns:
**		none.
*/

void
copy_class(src, dst)
	int src;
	int dst;
{
	register STAB **shead;
	register STAB *s;

	src = bitidx(src);
	dst = bitidx(dst);
	for (shead = SymTab; shead < &SymTab[STABSIZE]; shead++)
	{
		for (s = *shead; s != NULL; s = s->s_next)
		{
			if (s->s_symtype == ST_CLASS &&
			    bitnset(src, s->s_class))
				setbitn(dst, s->s_class);
		}
	}
}

/*
**  RMEXPSTAB -- remove expired entries from SymTab.
**
**	These entries need to be removed in long-running processes,
**	e.g., persistent queue runners, to avoid consuming memory.
**
**	XXX It might be useful to restrict the maximum TTL to avoid
**		caching data very long.
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		can remove entries from the symbol table.
*/

#define SM_STAB_FREE(x)	\
	do \
	{ \
		char *o = (x); \
		(x) = NULL; \
		if (o != NULL) \
			sm_free(o); \
	} while (0)

void
rmexpstab()
{
	int i;
	STAB *s, *p, *f;
	time_t now;

	now = curtime();
	for (i = 0; i < STABSIZE; i++)
	{
		p = NULL;
		s = SymTab[i];
		while (s != NULL)
		{
			switch (s->s_symtype)
			{
			  case ST_HOSTSIG:
				if (s->s_hostsig.hs_exp >= now)
					goto next;	/* not expired */
				SM_STAB_FREE(s->s_hostsig.hs_sig); /* XXX */
				break;

			  case ST_NAMECANON:
				if (s->s_namecanon.nc_exp >= now)
					goto next;	/* not expired */
				SM_STAB_FREE(s->s_namecanon.nc_cname); /* XXX */
				break;

			  default:
				if (s->s_symtype >= ST_MCI)
				{
					/* call mci_uncache? */
					SM_STAB_FREE(s->s_mci.mci_status);
					SM_STAB_FREE(s->s_mci.mci_rstatus);
					SM_STAB_FREE(s->s_mci.mci_heloname);
#if 0
					/* not dynamically allocated */
					SM_STAB_FREE(s->s_mci.mci_host);
					SM_STAB_FREE(s->s_mci.mci_tolist);
#endif /* 0 */
#if SASL
					/* should always by NULL */
					SM_STAB_FREE(s->s_mci.mci_sasl_string);
#endif /* SASL */
					if (s->s_mci.mci_rpool != NULL)
					{
						sm_rpool_free(s->s_mci.mci_rpool);
						s->s_mci.mci_macro.mac_rpool = NULL;
						s->s_mci.mci_rpool = NULL;
					}
					break;
				}
  next:
				p = s;
				s = s->s_next;
				continue;
			}

			/* remove entry */
			SM_STAB_FREE(s->s_name); /* XXX */
			f = s;
			s = s->s_next;
			sm_free(f);	/* XXX */
			if (p == NULL)
				SymTab[i] = s;
			else
				p->s_next = s;
		}
	}
}

#if SM_HEAP_CHECK
/*
**  DUMPSTAB -- dump symbol table.
**
**	For debugging.
*/

#define MAXSTTYPES	(ST_MCI + 1)

void
dumpstab()
{
	int i, t, total, types[MAXSTTYPES];
	STAB *s;
	static int prevt[MAXSTTYPES], prev = 0;

	total = 0;
	for (i = 0; i < MAXSTTYPES; i++)
		types[i] = 0;
	for (i = 0; i < STABSIZE; i++)
	{
		s = SymTab[i];
		while (s != NULL)
		{
			++total;
			t = s->s_symtype;
			if (t > MAXSTTYPES - 1)
				t = MAXSTTYPES - 1;
			types[t]++;
			s = s->s_next;
		}
	}
	sm_syslog(LOG_INFO, NOQID, "stab: total=%d (%d)", total, total - prev);
	prev = total;
	for (i = 0; i < MAXSTTYPES; i++)
	{
		if (types[i] != 0)
		{
			sm_syslog(LOG_INFO, NOQID, "stab: type[%2d]=%2d (%d)",
				i, types[i], types[i] - prevt[i]);
		}
		prevt[i] = types[i];
	}
}
#endif /* SM_HEAP_CHECK */
@


1.12
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.11
log
@Update to sendmail 8.14.6
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001, 2003 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: stab.c,v 8.91 2011/08/08 17:33:34 ca Exp $")
@


1.10
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: stab.c,v 8.89 2006/08/15 23:24:58 ca Exp $")
d68 1
a68 1
	if (type == ST_MACRO || type == ST_RULESET)
a113 4
		break;

	  case ST_ADDRESS:
		len = sizeof(s->s_address);
@


1.9
log
@Update to sendmail.8.13.0
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: stab.c,v 8.88 2003/05/21 15:36:30 ca Exp $")
d113 1
a113 1
		len = sizeof s->s_class;
d117 1
a117 1
		len = sizeof s->s_address;
d121 1
a121 1
		len = sizeof s->s_mailer;
d125 1
a125 1
		len = sizeof s->s_alias;
d129 1
a129 1
		len = sizeof s->s_mapclass;
d133 1
a133 1
		len = sizeof s->s_map;
d137 1
a137 1
		len = sizeof s->s_hostsig;
d141 1
a141 1
		len = sizeof s->s_namecanon;
d145 1
a145 1
		len = sizeof s->s_macro;
d149 1
a149 1
		len = sizeof s->s_ruleset;
d153 1
a153 1
		len = sizeof s->s_header;
d157 1
a157 1
		len = sizeof s->s_service;
d162 1
a162 1
		len = sizeof s->s_lmap;
d168 1
a168 1
		len = sizeof s->s_milter;
d173 1
a173 1
		len = sizeof s->s_quegrp;
d178 1
a178 1
		len = sizeof s->s_socketmap;
d192 1
a192 1
			len = sizeof s->s_mci;
d196 1
a196 1
			len = sizeof s->s_value;
d200 1
a200 1
	len += sizeof *s - sizeof s->s_value;
@


1.8
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: stab.c,v 8.86.4.1 2003/03/31 17:44:24 ca Exp $")
d175 6
@


1.7
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: stab.c,v 8.86 2001/12/29 04:27:56 ca Exp $")
d282 1
a282 1
			    (m = macid(s->s_name)) != '\0' &&
@


1.6
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: stab.c,v 8.84 2001/09/11 04:05:17 gshapiro Exp $")
d71 1
a71 1
		       (s->s_type != type || strcmp(name, s->s_name)))
d77 1
a77 1
		       (s->s_type != type || sm_strcasecmp(name, s->s_name)))
d96 1
a96 1
					s->s_type, lp[0], lp[1], lp[2], lp[3]);
d203 1
a203 2
	s->s_type = type;
	s->s_len = len;
d240 1
a240 1
					s->s_type, s->s_name);
d280 1
a280 1
			if (s->s_type == ST_CLASS &&
d319 1
a319 1
			if (s->s_type == ST_CLASS &&
d368 1
a368 1
			switch (s->s_type)
d383 1
a383 1
				if (s->s_type >= ST_MCI)
d450 1
a450 1
			t = s->s_type;
@


1.5
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: stab.c,v 8.80 2001/09/04 22:43:06 ca Exp $")
d215 1
a215 1
/*
d246 1
a246 1
/*
d254 1
a254 1
**		qfp -- file pointer to the qf file.
d295 1
a295 1
/*
d327 1
a327 1
/*
@


1.4
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d14 1
a14 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: stab.c,v 8.40.16.7 2001/05/07 22:06:41 gshapiro Exp $";
#endif /* ! lint */
d16 1
a16 1
#include <sendmail.h>
d25 1
a25 2
**			ST_ENTER -- enter the name if not
**				already present.
d37 1
d54 1
a54 1
		dprintf("STAB: %s %d ", name, type);
d62 1
a62 1
		hfunc = ((hfunc << 1) ^ (lower(*p) & 0377)) % STABSIZE;
d65 1
a65 1
		dprintf("(hfunc=%d) ", hfunc);
d77 1
a77 1
		       (s->s_type != type || strcasecmp(name, s->s_name)))
d90 1
a90 1
				dprintf("not found\n");
d95 1
a95 1
				dprintf("type %d val %lx %lx %lx %lx\n",
d107 1
a107 1
		dprintf("entered\n");
d160 1
a160 1
#ifdef LDAPMAP
d166 1
a166 1
#if _FFR_MILTER
d170 5
a174 1
#endif /* _FFR_MILTER */
d178 1
a178 1
		**  Each mailer has it's own MCI stab entry:
d197 1
a197 1
		dprintf("size of stab entry: %d\n", len);
d200 1
a200 1
	s = (STAB *) xalloc(len);
d202 1
a202 1
	s->s_name = newstr(name);
d219 2
a220 2
**		func -- the function to apply.  It will be given one
**			parameter (the stab entry).
d240 1
a240 1
				dprintf("stabapply: trying %d/%s\n",
d264 1
a264 1
	FILE *qfp;
d282 2
a283 2
			    bitnset(class, s->s_class) &&
			    (m = macid(s->s_name, NULL)) != '\0' &&
d286 5
a290 23
				/*
				**  HACK ALERT: Unfortunately, 8.10 and
				**  8.11 reused the ${if_addr} and
				**  ${if_family} macros for both the incoming
				**  interface address/family (getrequests())
				**  and the outgoing interface address/family
				**  (makeconnection()).  In order for D_BINDIF
				**  to work properly, have to preserve the
				**  incoming information in the queue file for
				**  later delivery attempts.  The original
				**  information is stored in the envelope
				**  in readqf() so it can be stored in
				**  queueup_macros().  This should be fixed
				**  in 8.12.
				*/

				if (e->e_if_macros[EIF_ADDR] != NULL &&
				    strcmp(s->s_name, "{if_addr}") == 0)
					p = e->e_if_macros[EIF_ADDR];

				fprintf(qfp, "$%s%s\n",
					s->s_name,
					denlstring(p, TRUE, FALSE));
d326 145
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: stab.c,v 8.40.16.3 2000/10/09 02:46:12 gshapiro Exp $";
d163 2
a164 2
	  case ST_LDAP:
		len = sizeof s->s_ldap;
@


1.3.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: stab.c,v 8.40.16.7 2001/05/07 22:06:41 gshapiro Exp $";
d163 2
a164 2
	  case ST_LMAP:
		len = sizeof s->s_lmap;
@


1.2
log
@Fix non-exploitable buffer oflow in test mode.  Also add a line to uncomment
in sendmail/Makefile to cause sendmail to drop privs in test mode.
From sendmail+gshapiro@@SENDMAIL.ORG
@
text
@d2 1
a2 1
 * Copyright (c) 1998, 1999 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: stab.c,v 8.40 1999/11/04 23:31:07 gshapiro Exp $";
d271 1
d280 1
a280 1
			    bitnset(class & 0xff, s->s_class) &&
d284 20
d330 2
a331 1
	dst = ((unsigned int)dst) & 0xff;
d337 1
a337 1
			    bitnset(src & 0xff, s->s_class))
@


1.2.2.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: stab.c,v 8.40.16.7 2001/05/07 22:06:41 gshapiro Exp $";
d163 2
a164 2
	  case ST_LMAP:
		len = sizeof s->s_lmap;
a270 1
	class = bitidx(class);
d279 1
a279 1
			    bitnset(class, s->s_class) &&
a282 20
				/*
				**  HACK ALERT: Unfortunately, 8.10 and
				**  8.11 reused the ${if_addr} and
				**  ${if_family} macros for both the incoming
				**  interface address/family (getrequests())
				**  and the outgoing interface address/family
				**  (makeconnection()).  In order for D_BINDIF
				**  to work properly, have to preserve the
				**  incoming information in the queue file for
				**  later delivery attempts.  The original
				**  information is stored in the envelope
				**  in readqf() so it can be stored in
				**  queueup_macros().  This should be fixed
				**  in 8.12.
				*/

				if (e->e_if_macros[EIF_ADDR] != NULL &&
				    strcmp(s->s_name, "{if_addr}") == 0)
					p = e->e_if_macros[EIF_ADDR];

d309 1
a309 2
	src = bitidx(src);
	dst = bitidx(dst);
d315 1
a315 1
			    bitnset(src, s->s_class))
@


1.1
log
@Initial revision
@
text
@d309 1
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Id: stab.c,v 8.40.16.3 2000/10/09 02:46:12 gshapiro Exp $";
a270 1
	class = bitidx(class);
d279 1
a279 1
			    bitnset(class, s->s_class) &&
a282 20
				/*
				**  HACK ALERT: Unfortunately, 8.10 and
				**  8.11 reused the ${if_addr} and
				**  ${if_family} macros for both the incoming
				**  interface address/family (getrequests())
				**  and the outgoing interface address/family
				**  (makeconnection()).  In order for D_BINDIF
				**  to work properly, have to preserve the
				**  incoming information in the queue file for
				**  later delivery attempts.  The original
				**  information is stored in the envelope
				**  in readqf() so it can be stored in
				**  queueup_macros().  This should be fixed
				**  in 8.12.
				*/

				if (e->e_if_macros[EIF_ADDR] != NULL &&
				    strcmp(s->s_name, "{if_addr}") == 0)
					p = e->e_if_macros[EIF_ADDR];

a308 2
	src = bitidx(src);
	dst = bitidx(dst);
d314 1
a314 1
			    bitnset(src, s->s_class))
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d14 4
a19 2
SM_RCSID("@@(#)$Sendmail: stab.c,v 8.80 2001/09/04 22:43:06 ca Exp $")

d27 2
a28 1
**			ST_ENTER -- enter the name if not already present.
a39 1
#define SM_LOWER(c)	((isascii(c) && isupper(c)) ? tolower(c) : (c))
d56 1
a56 1
		sm_dprintf("STAB: %s %d ", name, type);
d64 1
a64 1
		hfunc = ((hfunc << 1) ^ (SM_LOWER(*p) & 0377)) % STABSIZE;
d67 1
a67 1
		sm_dprintf("(hfunc=%d) ", hfunc);
d79 1
a79 1
		       (s->s_type != type || sm_strcasecmp(name, s->s_name)))
d92 1
a92 1
				sm_dprintf("not found\n");
d97 1
a97 1
				sm_dprintf("type %d val %lx %lx %lx %lx\n",
d109 1
a109 1
		sm_dprintf("entered\n");
d162 3
a164 3
#if LDAPMAP
	  case ST_LMAP:
		len = sizeof s->s_lmap;
d168 1
a168 1
#if MILTER
d172 1
a172 5
#endif /* MILTER */

	  case ST_QUEUE:
		len = sizeof s->s_quegrp;
		break;
d176 1
a176 1
		**  Each mailer has its own MCI stab entry:
d195 1
a195 1
		sm_dprintf("size of stab entry: %d\n", len);
d198 1
a198 1
	s = (STAB *) sm_pmalloc_x(len);
d200 1
a200 1
	s->s_name = sm_pstrdup_x(name);
d217 2
a218 2
**		func -- the function to apply.  It will be given two
**			parameters (the stab entry and the arg).
d238 1
a238 1
				sm_dprintf("stabapply: trying %d/%s\n",
d262 1
a262 1
	SM_FILE_T *qfp;
d280 2
a281 2
			    bitnset(bitidx(class), s->s_class) &&
			    (m = macid(s->s_name)) != '\0' &&
d284 23
a306 5
				(void) sm_io_fprintf(qfp, SM_TIME_DEFAULT,
						      "$%s%s\n",
						      s->s_name,
						      denlstring(p, true,
								 false));
a341 145

/*
**  RMEXPSTAB -- remove expired entries from SymTab.
**
**	These entries need to be removed in long-running processes,
**	e.g., persistent queue runners, to avoid consuming memory.
**
**	XXX It might be useful to restrict the maximum TTL to avoid
**		caching data very long.
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		can remove entries from the symbol table.
*/

#define SM_STAB_FREE(x)	\
	do \
	{ \
		char *o = (x); \
		(x) = NULL; \
		if (o != NULL) \
			sm_free(o); \
	} while (0)

void
rmexpstab()
{
	int i;
	STAB *s, *p, *f;
	time_t now;

	now = curtime();
	for (i = 0; i < STABSIZE; i++)
	{
		p = NULL;
		s = SymTab[i];
		while (s != NULL)
		{
			switch (s->s_type)
			{
			  case ST_HOSTSIG:
				if (s->s_hostsig.hs_exp >= now)
					goto next;	/* not expired */
				SM_STAB_FREE(s->s_hostsig.hs_sig); /* XXX */
				break;

			  case ST_NAMECANON:
				if (s->s_namecanon.nc_exp >= now)
					goto next;	/* not expired */
				SM_STAB_FREE(s->s_namecanon.nc_cname); /* XXX */
				break;

			  default:
				if (s->s_type >= ST_MCI)
				{
					/* call mci_uncache? */
					SM_STAB_FREE(s->s_mci.mci_status);
					SM_STAB_FREE(s->s_mci.mci_rstatus);
					SM_STAB_FREE(s->s_mci.mci_heloname);
#if 0
					/* not dynamically allocated */
					SM_STAB_FREE(s->s_mci.mci_host);
					SM_STAB_FREE(s->s_mci.mci_tolist);
#endif /* 0 */
#if SASL
					/* should always by NULL */
					SM_STAB_FREE(s->s_mci.mci_sasl_string);
#endif /* SASL */
					if (s->s_mci.mci_rpool != NULL)
					{
						sm_rpool_free(s->s_mci.mci_rpool);
						s->s_mci.mci_macro.mac_rpool = NULL;
						s->s_mci.mci_rpool = NULL;
					}
					break;
				}
  next:
				p = s;
				s = s->s_next;
				continue;
			}

			/* remove entry */
			SM_STAB_FREE(s->s_name); /* XXX */
			f = s;
			s = s->s_next;
			sm_free(f);	/* XXX */
			if (p == NULL)
				SymTab[i] = s;
			else
				p->s_next = s;
		}
	}
}

#if SM_HEAP_CHECK
/*
**  DUMPSTAB -- dump symbol table.
**
**	For debugging.
*/

#define MAXSTTYPES	(ST_MCI + 1)

void
dumpstab()
{
	int i, t, total, types[MAXSTTYPES];
	STAB *s;
	static int prevt[MAXSTTYPES], prev = 0;

	total = 0;
	for (i = 0; i < MAXSTTYPES; i++)
		types[i] = 0;
	for (i = 0; i < STABSIZE; i++)
	{
		s = SymTab[i];
		while (s != NULL)
		{
			++total;
			t = s->s_type;
			if (t > MAXSTTYPES - 1)
				t = MAXSTTYPES - 1;
			types[t]++;
			s = s->s_next;
		}
	}
	sm_syslog(LOG_INFO, NOQID, "stab: total=%d (%d)", total, total - prev);
	prev = total;
	for (i = 0; i < MAXSTTYPES; i++)
	{
		if (types[i] != 0)
		{
			sm_syslog(LOG_INFO, NOQID, "stab: type[%2d]=%2d (%d)",
				i, types[i], types[i] - prevt[i]);
		}
		prevt[i] = types[i];
	}
}
#endif /* SM_HEAP_CHECK */
@


1.1.1.1.2.1
log
@Pull in patch from current:
Errata:
There is a non-exploitable buffer overflow in sendmail's test mode.
Fix (millert):
Fix non-exploitable buffer oflow in test mode.  Also add a line to uncomment
in sendmail/Makefile to cause sendmail to drop privs in test mode.
From sendmail+gshapiro@@SENDMAIL.ORG
@
text
@a308 1
	dst = ((unsigned int)dst) & 0xff;
@

