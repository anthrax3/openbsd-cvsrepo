head	1.26;
access;
symbols
	OPENBSD_5_6:1.25.0.6
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.23.0.2
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.22.0.6
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.4
	OPENBSD_5_0:1.22.0.2
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.21.0.12
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.10
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.6
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.8
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.4
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.6
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.4
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.17.0.6
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.4
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2014.09.17.18.49.52;	author matthieu;	state dead;
branches;
next	1.25;
commitid	M7i5giHIoz3DMlTU;

1.25
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.23;

1.23
date	2012.12.26.11.44.12;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2011.05.17.15.54.24;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2006.08.13.13.01.48;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.22.18.43.56;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.16.00.21.31;	author millert;	state Exp;
branches
	1.17.2.1
	1.17.4.1
	1.17.6.1;
next	1.16;

1.16
date	2004.06.24.03.59.28;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.19.01.41.14;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.09.17.17.31.41;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.01.19.59.23;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.26.04.48.55;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.03.17.25.47;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.18.00.49.29;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.14.03.21.41;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.01.17.18.30;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.11.19.02.50;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.01.01.01.41;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.29.01.31.16;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.28.02.43.55;	author millert;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.01.15.21.09.11;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.07.19.20.45;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.49;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.49;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.19;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.51;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.31.46;	author miod;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.31.01.47.59;	author jason;	state Exp;
branches;
next	;

1.17.2.1
date	2006.03.24.05.42.49;	author brad;	state Exp;
branches;
next	;

1.17.4.1
date	2006.03.24.05.56.18;	author brad;	state Exp;
branches;
next	;

1.17.6.1
date	2006.03.25.01.49.38;	author brad;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2007, 2009 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>

SM_RCSID("@@(#)$Sendmail: util.c,v 8.427 2013/11/22 20:51:57 ca Exp $")

#include <sm/sendmail.h>
#include <sysexits.h>
#include <sm/xtrap.h>

/*
**  NEWSTR -- Create a copy of a C string
**
**	Parameters:
**		s -- the string to copy.
**
**	Returns:
**		pointer to newly allocated string.
*/

char *
newstr(s)
	const char *s;
{
	size_t l;
	char *n;

	l = strlen(s);
	SM_ASSERT(l + 1 > l);
	n = xalloc(l + 1);
	sm_strlcpy(n, s, l + 1);
	return n;
}

/*
**  ADDQUOTES -- Adds quotes & quote bits to a string.
**
**	Runs through a string and adds backslashes and quote bits.
**
**	Parameters:
**		s -- the string to modify.
**		rpool -- resource pool from which to allocate result
**
**	Returns:
**		pointer to quoted string.
*/

char *
addquotes(s, rpool)
	char *s;
	SM_RPOOL_T *rpool;
{
	int len = 0;
	char c;
	char *p = s, *q, *r;

	if (s == NULL)
		return NULL;

	/* Find length of quoted string */
	while ((c = *p++) != '\0')
	{
		len++;
		if (c == '\\' || c == '"')
			len++;
	}

	q = r = sm_rpool_malloc_x(rpool, len + 3);
	p = s;

	/* add leading quote */
	*q++ = '"';
	while ((c = *p++) != '\0')
	{
		/* quote \ or " */
		if (c == '\\' || c == '"')
			*q++ = '\\';
		*q++ = c;
	}
	*q++ = '"';
	*q = '\0';
	return r;
}

/*
**  STRIPBACKSLASH -- Strip all leading backslashes from a string, provided
**	the following character is alpha-numerical.
**
**	This is done in place.
**
**	Parameters:
**		s -- the string to strip.
**
**	Returns:
**		none.
*/

void
stripbackslash(s)
	char *s;
{
	char *p, *q, c;

	if (s == NULL || *s == '\0')
		return;
	p = q = s;
	while (*p == '\\' && (p[1] == '\\' || (isascii(p[1]) && isalnum(p[1]))))
		p++;
	do
	{
		c = *q++ = *p++;
	} while (c != '\0');
}

/*
**  RFC822_STRING -- Checks string for proper RFC822 string quoting.
**
**	Runs through a string and verifies RFC822 special characters
**	are only found inside comments, quoted strings, or backslash
**	escaped.  Also verified balanced quotes and parenthesis.
**
**	Parameters:
**		s -- the string to modify.
**
**	Returns:
**		true iff the string is RFC822 compliant, false otherwise.
*/

bool
rfc822_string(s)
	char *s;
{
	bool quoted = false;
	int commentlev = 0;
	char *c = s;

	if (s == NULL)
		return false;

	while (*c != '\0')
	{
		/* escaped character */
		if (*c == '\\')
		{
			c++;
			if (*c == '\0')
				return false;
		}
		else if (commentlev == 0 && *c == '"')
			quoted = !quoted;
		else if (!quoted)
		{
			if (*c == ')')
			{
				/* unbalanced ')' */
				if (commentlev == 0)
					return false;
				else
					commentlev--;
			}
			else if (*c == '(')
				commentlev++;
			else if (commentlev == 0 &&
				 strchr(MustQuoteChars, *c) != NULL)
				return false;
		}
		c++;
	}

	/* unbalanced '"' or '(' */
	return !quoted && commentlev == 0;
}

/*
**  SHORTEN_RFC822_STRING -- Truncate and rebalance an RFC822 string
**
**	Arbitrarily shorten (in place) an RFC822 string and rebalance
**	comments and quotes.
**
**	Parameters:
**		string -- the string to shorten
**		length -- the maximum size, 0 if no maximum
**
**	Returns:
**		true if string is changed, false otherwise
**
**	Side Effects:
**		Changes string in place, possibly resulting
**		in a shorter string.
*/

bool
shorten_rfc822_string(string, length)
	char *string;
	size_t length;
{
	bool backslash = false;
	bool modified = false;
	bool quoted = false;
	size_t slen;
	int parencount = 0;
	char *ptr = string;

	/*
	**  If have to rebalance an already short enough string,
	**  need to do it within allocated space.
	*/

	slen = strlen(string);
	if (length == 0 || slen < length)
		length = slen;

	while (*ptr != '\0')
	{
		if (backslash)
		{
			backslash = false;
			goto increment;
		}

		if (*ptr == '\\')
			backslash = true;
		else if (*ptr == '(')
		{
			if (!quoted)
				parencount++;
		}
		else if (*ptr == ')')
		{
			if (--parencount < 0)
				parencount = 0;
		}

		/* Inside a comment, quotes don't matter */
		if (parencount <= 0 && *ptr == '"')
			quoted = !quoted;

increment:
		/* Check for sufficient space for next character */
		if (length - (ptr - string) <= (size_t) ((backslash ? 1 : 0) +
						parencount +
						(quoted ? 1 : 0)))
		{
			/* Not enough, backtrack */
			if (*ptr == '\\')
				backslash = false;
			else if (*ptr == '(' && !quoted)
				parencount--;
			else if (*ptr == '"' && parencount == 0)
				quoted = false;
			break;
		}
		ptr++;
	}

	/* Rebalance */
	while (parencount-- > 0)
	{
		if (*ptr != ')')
		{
			modified = true;
			*ptr = ')';
		}
		ptr++;
	}
	if (quoted)
	{
		if (*ptr != '"')
		{
			modified = true;
			*ptr = '"';
		}
		ptr++;
	}
	if (*ptr != '\0')
	{
		modified = true;
		*ptr = '\0';
	}
	return modified;
}

/*
**  FIND_CHARACTER -- find an unquoted character in an RFC822 string
**
**	Find an unquoted, non-commented character in an RFC822
**	string and return a pointer to its location in the
**	string.
**
**	Parameters:
**		string -- the string to search
**		character -- the character to find
**
**	Returns:
**		pointer to the character, or
**		a pointer to the end of the line if character is not found
*/

char *
find_character(string, character)
	char *string;
	int character;
{
	bool backslash = false;
	bool quoted = false;
	int parencount = 0;

	while (string != NULL && *string != '\0')
	{
		if (backslash)
		{
			backslash = false;
			if (!quoted && character == '\\' && *string == '\\')
				break;
			string++;
			continue;
		}
		switch (*string)
		{
		  case '\\':
			backslash = true;
			break;

		  case '(':
			if (!quoted)
				parencount++;
			break;

		  case ')':
			if (--parencount < 0)
				parencount = 0;
			break;
		}

		/* Inside a comment, nothing matters */
		if (parencount > 0)
		{
			string++;
			continue;
		}

		if (*string == '"')
			quoted = !quoted;
		else if (*string == character && !quoted)
			break;
		string++;
	}

	/* Return pointer to the character */
	return string;
}

/*
**  CHECK_BODYTYPE -- check bodytype parameter
**
**	Parameters:
**		bodytype -- bodytype parameter
**
**	Returns:
**		BODYTYPE_* according to parameter
**
*/

int
check_bodytype(bodytype)
	char *bodytype;
{
	/* check body type for legality */
	if (bodytype == NULL)
		return BODYTYPE_NONE;
	if (sm_strcasecmp(bodytype, "7BIT") == 0)
		return BODYTYPE_7BIT;
	if (sm_strcasecmp(bodytype, "8BITMIME") == 0)
		return BODYTYPE_8BITMIME;
	return BODYTYPE_ILLEGAL;
}

/*
**  TRUNCATE_AT_DELIM -- truncate string at a delimiter and append "..."
**
**	Parameters:
**		str -- string to truncate
**		len -- maximum length (including '\0') (0 for unlimited)
**		delim -- delimiter character
**
**	Returns:
**		None.
*/

void
truncate_at_delim(str, len, delim)
	char *str;
	size_t len;
	int delim;
{
	char *p;

	if (str == NULL || len == 0 || strlen(str) < len)
		return;

	*(str + len - 1) = '\0';
	while ((p = strrchr(str, delim)) != NULL)
	{
		*p = '\0';
		if (p - str + 4 < len)
		{
			*p++ = (char) delim;
			*p = '\0';
			(void) sm_strlcat(str, "...", len);
			return;
		}
	}

	/* Couldn't find a place to append "..." */
	if (len > 3)
		(void) sm_strlcpy(str, "...", len);
	else
		str[0] = '\0';
}

/*
**  XALLOC -- Allocate memory, raise an exception on error
**
**	Parameters:
**		sz -- size of area to allocate.
**
**	Returns:
**		pointer to data region.
**
**	Exceptions:
**		SmHeapOutOfMemory (F:sm.heap) -- cannot allocate memory
**
**	Side Effects:
**		Memory is allocated.
*/

char *
#if SM_HEAP_CHECK
xalloc_tagged(sz, file, line)
	register int sz;
	char *file;
	int line;
#else /* SM_HEAP_CHECK */
xalloc(sz)
	register int sz;
#endif /* SM_HEAP_CHECK */
{
	register char *p;

	SM_REQUIRE(sz >= 0);

	/* some systems can't handle size zero mallocs */
	if (sz <= 0)
		sz = 1;

	/* scaffolding for testing error handling code */
	sm_xtrap_raise_x(&SmHeapOutOfMemory);

	p = sm_malloc_tagged((unsigned) sz, file, line, sm_heap_group());
	if (p == NULL)
	{
		sm_exc_raise_x(&SmHeapOutOfMemory);
	}
	return p;
}

/*
**  COPYPLIST -- copy list of pointers.
**
**	This routine is the equivalent of strdup for lists of
**	pointers.
**
**	Parameters:
**		list -- list of pointers to copy.
**			Must be NULL terminated.
**		copycont -- if true, copy the contents of the vector
**			(which must be a string) also.
**		rpool -- resource pool from which to allocate storage,
**			or NULL
**
**	Returns:
**		a copy of 'list'.
*/

char **
copyplist(list, copycont, rpool)
	char **list;
	bool copycont;
	SM_RPOOL_T *rpool;
{
	register char **vp;
	register char **newvp;

	for (vp = list; *vp != NULL; vp++)
		continue;

	vp++;

	newvp = (char **) sm_rpool_malloc_x(rpool, (vp - list) * sizeof(*vp));
	memmove((char *) newvp, (char *) list, (int) (vp - list) * sizeof(*vp));

	if (copycont)
	{
		for (vp = newvp; *vp != NULL; vp++)
			*vp = sm_rpool_strdup_x(rpool, *vp);
	}

	return newvp;
}

/*
**  COPYQUEUE -- copy address queue.
**
**	This routine is the equivalent of strdup for address queues;
**	addresses marked as QS_IS_DEAD() aren't copied
**
**	Parameters:
**		addr -- list of address structures to copy.
**		rpool -- resource pool from which to allocate storage
**
**	Returns:
**		a copy of 'addr'.
*/

ADDRESS *
copyqueue(addr, rpool)
	ADDRESS *addr;
	SM_RPOOL_T *rpool;
{
	register ADDRESS *newaddr;
	ADDRESS *ret;
	register ADDRESS **tail = &ret;

	while (addr != NULL)
	{
		if (!QS_IS_DEAD(addr->q_state))
		{
			newaddr = (ADDRESS *) sm_rpool_malloc_x(rpool,
							sizeof(*newaddr));
			STRUCTCOPY(*addr, *newaddr);
			*tail = newaddr;
			tail = &newaddr->q_next;
		}
		addr = addr->q_next;
	}
	*tail = NULL;

	return ret;
}

/*
**  LOG_SENDMAIL_PID -- record sendmail pid and command line.
**
**	Parameters:
**		e -- the current envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		writes pidfile, logs command line.
**		keeps file open and locked to prevent overwrite of active file
*/

static SM_FILE_T	*Pidf = NULL;

void
log_sendmail_pid(e)
	ENVELOPE *e;
{
	long sff;
	char pidpath[MAXPATHLEN];
	extern char *CommandLineArgs;

	/* write the pid to the log file for posterity */
	sff = SFF_NOLINK|SFF_ROOTOK|SFF_REGONLY|SFF_CREAT|SFF_NBLOCK;
	if (TrustedUid != 0 && RealUid == TrustedUid)
		sff |= SFF_OPENASROOT;
	expand(PidFile, pidpath, sizeof(pidpath), e);
	Pidf = safefopen(pidpath, O_WRONLY|O_TRUNC, FileMode, sff);
	if (Pidf == NULL)
	{
		if (errno == EWOULDBLOCK)
			sm_syslog(LOG_ERR, NOQID,
				  "unable to write pid to %s: file in use by another process",
				  pidpath);
		else
			sm_syslog(LOG_ERR, NOQID,
				  "unable to write pid to %s: %s",
				  pidpath, sm_errstring(errno));
	}
	else
	{
		PidFilePid = getpid();

		/* write the process id on line 1 */
		(void) sm_io_fprintf(Pidf, SM_TIME_DEFAULT, "%ld\n",
				     (long) PidFilePid);

		/* line 2 contains all command line flags */
		(void) sm_io_fprintf(Pidf, SM_TIME_DEFAULT, "%s\n",
				     CommandLineArgs);

		/* flush */
		(void) sm_io_flush(Pidf, SM_TIME_DEFAULT);

		/*
		**  Leave pid file open until process ends
		**  so it's not overwritten by another
		**  process.
		*/
	}
	if (LogLevel > 9)
		sm_syslog(LOG_INFO, NOQID, "started as: %s", CommandLineArgs);
}

/*
**  CLOSE_SENDMAIL_PID -- close sendmail pid file
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
*/

void
close_sendmail_pid()
{
	if (Pidf == NULL)
		return;

	(void) sm_io_close(Pidf, SM_TIME_DEFAULT);
	Pidf = NULL;
}

/*
**  SET_DELIVERY_MODE -- set and record the delivery mode
**
**	Parameters:
**		mode -- delivery mode
**		e -- the current envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		sets {deliveryMode} macro
*/

void
set_delivery_mode(mode, e)
	int mode;
	ENVELOPE *e;
{
	char buf[2];

	e->e_sendmode = (char) mode;
	buf[0] = (char) mode;
	buf[1] = '\0';
	macdefine(&e->e_macro, A_TEMP, macid("{deliveryMode}"), buf);
}

/*
**  SET_OP_MODE -- set and record the op mode
**
**	Parameters:
**		mode -- op mode
**		e -- the current envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		sets {opMode} macro
*/

void
set_op_mode(mode)
	int mode;
{
	char buf[2];
	extern ENVELOPE BlankEnvelope;

	OpMode = (char) mode;
	buf[0] = (char) mode;
	buf[1] = '\0';
	macdefine(&BlankEnvelope.e_macro, A_TEMP, MID_OPMODE, buf);
}

/*
**  PRINTAV -- print argument vector.
**
**	Parameters:
**		fp -- output file pointer.
**		av -- argument vector.
**
**	Returns:
**		none.
**
**	Side Effects:
**		prints av.
*/

void
printav(fp, av)
	SM_FILE_T *fp;
	char **av;
{
	while (*av != NULL)
	{
		if (tTd(0, 44))
			sm_dprintf("\n\t%08lx=", (unsigned long) *av);
		else
			(void) sm_io_putc(fp, SM_TIME_DEFAULT, ' ');
		if (tTd(0, 99))
			sm_dprintf("%s", str2prt(*av++));
		else
			xputs(fp, *av++);
	}
	(void) sm_io_putc(fp, SM_TIME_DEFAULT, '\n');
}

/*
**  XPUTS -- put string doing control escapes.
**
**	Parameters:
**		fp -- output file pointer.
**		s -- string to put.
**
**	Returns:
**		none.
**
**	Side Effects:
**		output to stdout
*/

void
xputs(fp, s)
	SM_FILE_T *fp;
	const char *s;
{
	int c;
	struct metamac *mp;
	bool shiftout = false;
	extern struct metamac MetaMacros[];
	static SM_DEBUG_T DebugANSI = SM_DEBUG_INITIALIZER("ANSI",
		"@@(#)$Debug: ANSI - enable reverse video in debug output $");

	/*
	**  TermEscape is set here, rather than in main(),
	**  because ANSI mode can be turned on or off at any time
	**  if we are in -bt rule testing mode.
	*/

	if (sm_debug_unknown(&DebugANSI))
	{
		if (sm_debug_active(&DebugANSI, 1))
		{
			TermEscape.te_rv_on = "\033[7m";
			TermEscape.te_normal = "\033[0m";
		}
		else
		{
			TermEscape.te_rv_on = "";
			TermEscape.te_normal = "";
		}
	}

	if (s == NULL)
	{
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "%s<null>%s",
				     TermEscape.te_rv_on, TermEscape.te_normal);
		return;
	}
	while ((c = (*s++ & 0377)) != '\0')
	{
		if (shiftout)
		{
			(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "%s",
					     TermEscape.te_normal);
			shiftout = false;
		}
		if (!isascii(c) && !tTd(84, 1))
		{
			if (c == MATCHREPL)
			{
				(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
						     "%s$",
						     TermEscape.te_rv_on);
				shiftout = true;
				if (*s == '\0')
					continue;
				c = *s++ & 0377;
				goto printchar;
			}
			if (c == MACROEXPAND || c == MACRODEXPAND)
			{
				(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
						     "%s$",
						     TermEscape.te_rv_on);
				if (c == MACRODEXPAND)
					(void) sm_io_putc(fp,
							  SM_TIME_DEFAULT, '&');
				shiftout = true;
				if (*s == '\0')
					continue;
				if (strchr("=~&?", *s) != NULL)
					(void) sm_io_putc(fp,
							  SM_TIME_DEFAULT,
							  *s++);
				if (bitset(0200, *s))
					(void) sm_io_fprintf(fp,
							     SM_TIME_DEFAULT,
							     "{%s}",
							     macname(bitidx(*s++)));
				else
					(void) sm_io_fprintf(fp,
							     SM_TIME_DEFAULT,
							     "%c",
							     *s++);
				continue;
			}
			for (mp = MetaMacros; mp->metaname != '\0'; mp++)
			{
				if (bitidx(mp->metaval) == c)
				{
					(void) sm_io_fprintf(fp,
							     SM_TIME_DEFAULT,
							     "%s$%c",
							     TermEscape.te_rv_on,
							     mp->metaname);
					shiftout = true;
					break;
				}
			}
			if (c == MATCHCLASS || c == MATCHNCLASS)
			{
				if (bitset(0200, *s))
					(void) sm_io_fprintf(fp,
							     SM_TIME_DEFAULT,
							     "{%s}",
							     macname(bitidx(*s++)));
				else if (*s != '\0')
					(void) sm_io_fprintf(fp,
							     SM_TIME_DEFAULT,
							     "%c",
							     *s++);
			}
			if (mp->metaname != '\0')
				continue;

			/* unrecognized meta character */
			(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "%sM-",
					     TermEscape.te_rv_on);
			shiftout = true;
			c &= 0177;
		}
  printchar:
		if (isascii(c) && isprint(c))
		{
			(void) sm_io_putc(fp, SM_TIME_DEFAULT, c);
			continue;
		}

		/* wasn't a meta-macro -- find another way to print it */
		switch (c)
		{
		  case '\n':
			c = 'n';
			break;

		  case '\r':
			c = 'r';
			break;

		  case '\t':
			c = 't';
			break;
		}
		if (!shiftout)
		{
			(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "%s",
					     TermEscape.te_rv_on);
			shiftout = true;
		}
		if (isascii(c) && isprint(c))
		{
			(void) sm_io_putc(fp, SM_TIME_DEFAULT, '\\');
			(void) sm_io_putc(fp, SM_TIME_DEFAULT, c);
		}
		else if (tTd(84, 2))
			(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, " %o ", c);
		else if (tTd(84, 1))
			(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, " %#x ", c);
		else if (!isascii(c) && !tTd(84, 1))
		{
			(void) sm_io_putc(fp, SM_TIME_DEFAULT, '^');
			(void) sm_io_putc(fp, SM_TIME_DEFAULT, c ^ 0100);
		}
	}
	if (shiftout)
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "%s",
				     TermEscape.te_normal);
	(void) sm_io_flush(fp, SM_TIME_DEFAULT);
}

/*
**  MAKELOWER -- Translate a line into lower case
**
**	Parameters:
**		p -- the string to translate.  If NULL, return is
**			immediate.
**
**	Returns:
**		none.
**
**	Side Effects:
**		String pointed to by p is translated to lower case.
*/

void
makelower(p)
	register char *p;
{
	register char c;

	if (p == NULL)
		return;
	for (; (c = *p) != '\0'; p++)
		if (isascii(c) && isupper(c))
			*p = tolower(c);
}

/*
**  FIXCRLF -- fix <CR><LF> in line.
**
**	Looks for the <CR><LF> combination and turns it into the
**	UNIX canonical <NL> character.  It only takes one line,
**	i.e., it is assumed that the first <NL> found is the end
**	of the line.
**
**	Parameters:
**		line -- the line to fix.
**		stripnl -- if true, strip the newline also.
**
**	Returns:
**		none.
**
**	Side Effects:
**		line is changed in place.
*/

void
fixcrlf(line, stripnl)
	char *line;
	bool stripnl;
{
	register char *p;

	p = strchr(line, '\n');
	if (p == NULL)
		return;
	if (p > line && p[-1] == '\r')
		p--;
	if (!stripnl)
		*p++ = '\n';
	*p = '\0';
}

/*
**  PUTLINE -- put a line like fputs obeying SMTP conventions
**
**	This routine always guarantees outputing a newline (or CRLF,
**	as appropriate) at the end of the string.
**
**	Parameters:
**		l -- line to put.
**		mci -- the mailer connection information.
**
**	Returns:
**		true iff line was written successfully
**
**	Side Effects:
**		output of l to mci->mci_out.
*/

bool
putline(l, mci)
	register char *l;
	register MCI *mci;
{
	return putxline(l, strlen(l), mci, PXLF_MAPFROM);
}

/*
**  PUTXLINE -- putline with flags bits.
**
**	This routine always guarantees outputing a newline (or CRLF,
**	as appropriate) at the end of the string.
**
**	Parameters:
**		l -- line to put.
**		len -- the length of the line.
**		mci -- the mailer connection information.
**		pxflags -- flag bits:
**		    PXLF_MAPFROM -- map From_ to >From_.
**		    PXLF_STRIP8BIT -- strip 8th bit.
**		    PXLF_HEADER -- map bare newline in header to newline space.
**		    PXLF_NOADDEOL -- don't add an EOL if one wasn't present.
**		    PXLF_STRIPMQUOTE -- strip METAQUOTE bytes.
**
**	Returns:
**		true iff line was written successfully
**
**	Side Effects:
**		output of l to mci->mci_out.
*/


#define PUTX(limit)							\
	do								\
	{								\
		quotenext = false;					\
		while (l < limit)					\
		{							\
			unsigned char c = (unsigned char) *l++;		\
									\
			if (bitset(PXLF_STRIPMQUOTE, pxflags) &&	\
			    !quotenext && c == METAQUOTE)		\
			{						\
				quotenext = true;			\
				continue;				\
			}						\
			quotenext = false;				\
			if (strip8bit)					\
				c &= 0177;				\
			if (sm_io_putc(mci->mci_out, SM_TIME_DEFAULT,	\
				       c) == SM_IO_EOF)			\
			{						\
				dead = true;				\
				break;					\
			}						\
			if (TrafficLogFile != NULL)			\
				(void) sm_io_putc(TrafficLogFile,	\
						  SM_TIME_DEFAULT,	\
						  c);			\
		}							\
	} while (0)

bool
putxline(l, len, mci, pxflags)
	register char *l;
	size_t len;
	register MCI *mci;
	int pxflags;
{
	register char *p, *end;
	int slop;
	bool dead, quotenext, strip8bit;

	/* strip out 0200 bits -- these can look like TELNET protocol */
	strip8bit = bitset(MCIF_7BIT, mci->mci_flags) ||
		    bitset(PXLF_STRIP8BIT, pxflags);
	dead = false;
	slop = 0;

	end = l + len;
	do
	{
		bool noeol = false;

		/* find the end of the line */
		p = memchr(l, '\n', end - l);
		if (p == NULL)
		{
			p = end;
			noeol = true;
		}

		if (TrafficLogFile != NULL)
			(void) sm_io_fprintf(TrafficLogFile, SM_TIME_DEFAULT,
					     "%05d >>> ", (int) CurrentPid);

		/* check for line overflow */
		while (mci->mci_mailer->m_linelimit > 0 &&
		       (p - l + slop) > mci->mci_mailer->m_linelimit)
		{
			register char *q = &l[mci->mci_mailer->m_linelimit - slop - 1];

			if (l[0] == '.' && slop == 0 &&
			    bitnset(M_XDOT, mci->mci_mailer->m_flags))
			{
				if (sm_io_putc(mci->mci_out, SM_TIME_DEFAULT,
					       '.') == SM_IO_EOF)
					dead = true;
				if (TrafficLogFile != NULL)
					(void) sm_io_putc(TrafficLogFile,
							  SM_TIME_DEFAULT, '.');
			}
			else if (l[0] == 'F' && slop == 0 &&
				 bitset(PXLF_MAPFROM, pxflags) &&
				 strncmp(l, "From ", 5) == 0 &&
				 bitnset(M_ESCFROM, mci->mci_mailer->m_flags))
			{
				if (sm_io_putc(mci->mci_out, SM_TIME_DEFAULT,
					       '>') == SM_IO_EOF)
					dead = true;
				if (TrafficLogFile != NULL)
					(void) sm_io_putc(TrafficLogFile,
							  SM_TIME_DEFAULT,
							  '>');
			}
			if (dead)
				break;

			PUTX(q);
			if (dead)
				break;

			if (sm_io_putc(mci->mci_out, SM_TIME_DEFAULT,
					'!') == SM_IO_EOF ||
			    sm_io_fputs(mci->mci_out, SM_TIME_DEFAULT,
					mci->mci_mailer->m_eol) == SM_IO_EOF ||
			    sm_io_putc(mci->mci_out, SM_TIME_DEFAULT,
					' ') == SM_IO_EOF)
			{
				dead = true;
				break;
			}
			if (TrafficLogFile != NULL)
			{
				(void) sm_io_fprintf(TrafficLogFile,
						     SM_TIME_DEFAULT,
						     "!\n%05d >>>  ",
						     (int) CurrentPid);
			}
			slop = 1;
		}

		if (dead)
			break;

		/* output last part */
		if (l[0] == '.' && slop == 0 &&
		    bitnset(M_XDOT, mci->mci_mailer->m_flags) &&
		    !bitset(MCIF_INLONGLINE, mci->mci_flags))
		{
			if (sm_io_putc(mci->mci_out, SM_TIME_DEFAULT, '.') ==
			    SM_IO_EOF)
			{
				dead = true;
				break;
			}
			if (TrafficLogFile != NULL)
				(void) sm_io_putc(TrafficLogFile,
						  SM_TIME_DEFAULT, '.');
		}
		else if (l[0] == 'F' && slop == 0 &&
			 bitset(PXLF_MAPFROM, pxflags) &&
			 strncmp(l, "From ", 5) == 0 &&
			 bitnset(M_ESCFROM, mci->mci_mailer->m_flags) &&
			 !bitset(MCIF_INLONGLINE, mci->mci_flags))
		{
			if (sm_io_putc(mci->mci_out, SM_TIME_DEFAULT, '>') ==
			    SM_IO_EOF)
			{
				dead = true;
				break;
			}
			if (TrafficLogFile != NULL)
				(void) sm_io_putc(TrafficLogFile,
						  SM_TIME_DEFAULT, '>');
		}
		PUTX(p);
		if (dead)
			break;

		if (TrafficLogFile != NULL)
			(void) sm_io_putc(TrafficLogFile, SM_TIME_DEFAULT,
					  '\n');
		if ((!bitset(PXLF_NOADDEOL, pxflags) || !noeol))
		{
			mci->mci_flags &= ~MCIF_INLONGLINE;
			if (sm_io_fputs(mci->mci_out, SM_TIME_DEFAULT,
					mci->mci_mailer->m_eol) == SM_IO_EOF)
			{
				dead = true;
				break;
			}
		}
		else
			mci->mci_flags |= MCIF_INLONGLINE;

		if (l < end && *l == '\n')
		{
			if (*++l != ' ' && *l != '\t' && *l != '\0' &&
			    bitset(PXLF_HEADER, pxflags))
			{
				if (sm_io_putc(mci->mci_out, SM_TIME_DEFAULT,
					       ' ') == SM_IO_EOF)
				{
					dead = true;
					break;
				}

				if (TrafficLogFile != NULL)
					(void) sm_io_putc(TrafficLogFile,
							  SM_TIME_DEFAULT, ' ');
			}
		}

	} while (l < end);
	return !dead;
}

/*
**  XUNLINK -- unlink a file, doing logging as appropriate.
**
**	Parameters:
**		f -- name of file to unlink.
**
**	Returns:
**		return value of unlink()
**
**	Side Effects:
**		f is unlinked.
*/

int
xunlink(f)
	char *f;
{
	register int i;
	int save_errno;

	if (LogLevel > 98)
		sm_syslog(LOG_DEBUG, CurEnv->e_id, "unlink %s", f);

	i = unlink(f);
	save_errno = errno;
	if (i < 0 && LogLevel > 97)
		sm_syslog(LOG_DEBUG, CurEnv->e_id, "%s: unlink-fail %d",
			  f, errno);
	if (i >= 0)
		SYNC_DIR(f, false);
	errno = save_errno;
	return i;
}

/*
**  SFGETS -- "safe" fgets -- times out and ignores random interrupts.
**
**	Parameters:
**		buf -- place to put the input line.
**		siz -- size of buf.
**		fp -- file to read from.
**		timeout -- the timeout before error occurs.
**		during -- what we are trying to read (for error messages).
**
**	Returns:
**		NULL on error (including timeout).  This may also leave
**			buf containing a null string.
**		buf otherwise.
*/


char *
sfgets(buf, siz, fp, timeout, during)
	char *buf;
	int siz;
	SM_FILE_T *fp;
	time_t timeout;
	char *during;
{
	register char *p;
	int save_errno, io_timeout, l;

	SM_REQUIRE(siz > 0);
	SM_REQUIRE(buf != NULL);

	if (fp == NULL)
	{
		buf[0] = '\0';
		errno = EBADF;
		return NULL;
	}

	/* try to read */
	l = -1;
	errno = 0;

	/* convert the timeout to sm_io notation */
	io_timeout = (timeout <= 0) ? SM_TIME_DEFAULT : timeout * 1000;
	while (!sm_io_eof(fp) && !sm_io_error(fp))
	{
		errno = 0;
		l = sm_io_fgets(fp, io_timeout, buf, siz);
		if (l < 0 && errno == EAGAIN)
		{
			/* The sm_io_fgets() call timedout */
			if (LogLevel > 1)
				sm_syslog(LOG_NOTICE, CurEnv->e_id,
					  "timeout waiting for input from %.100s during %s",
					  CURHOSTNAME,
					  during);
			buf[0] = '\0';
#if XDEBUG
			checkfd012(during);
#endif /* XDEBUG */
			if (TrafficLogFile != NULL)
				(void) sm_io_fprintf(TrafficLogFile,
						     SM_TIME_DEFAULT,
						     "%05d <<< [TIMEOUT]\n",
						     (int) CurrentPid);
			errno = ETIMEDOUT;
			return NULL;
		}
		if (l >= 0 || errno != EINTR)
			break;
		(void) sm_io_clearerr(fp);
	}
	save_errno = errno;

	/* clean up the books and exit */
	LineNumber++;
	if (l < 0)
	{
		buf[0] = '\0';
		if (TrafficLogFile != NULL)
			(void) sm_io_fprintf(TrafficLogFile, SM_TIME_DEFAULT,
					     "%05d <<< [EOF]\n",
					     (int) CurrentPid);
		errno = save_errno;
		return NULL;
	}
	if (TrafficLogFile != NULL)
		(void) sm_io_fprintf(TrafficLogFile, SM_TIME_DEFAULT,
				     "%05d <<< %s", (int) CurrentPid, buf);
	if (SevenBitInput)
	{
		for (p = buf; *p != '\0'; p++)
			*p &= ~0200;
	}
	else if (!HasEightBits)
	{
		for (p = buf; *p != '\0'; p++)
		{
			if (bitset(0200, *p))
			{
				HasEightBits = true;
				break;
			}
		}
	}
	return buf;
}

/*
**  FGETFOLDED -- like fgets, but knows about folded lines.
**
**	Parameters:
**		buf -- place to put result.
**		np -- pointer to bytes available; will be updated with
**			the actual buffer size (not number of bytes filled)
**			on return.
**		f -- file to read from.
**
**	Returns:
**		input line(s) on success, NULL on error or SM_IO_EOF.
**		This will normally be buf -- unless the line is too
**			long, when it will be sm_malloc_x()ed.
**
**	Side Effects:
**		buf gets lines from f, with continuation lines (lines
**		with leading white space) appended.  CRLF's are mapped
**		into single newlines.  Any trailing NL is stripped.
*/

char *
fgetfolded(buf, np, f)
	char *buf;
	int *np;
	SM_FILE_T *f;
{
	register char *p = buf;
	char *bp = buf;
	register int i;
	int n;

	SM_REQUIRE(np != NULL);
	n = *np;
	SM_REQUIRE(n > 0);
	SM_REQUIRE(buf != NULL);
	if (f == NULL)
	{
		buf[0] = '\0';
		errno = EBADF;
		return NULL;
	}

	n--;
	while ((i = sm_io_getc(f, SM_TIME_DEFAULT)) != SM_IO_EOF)
	{
		if (i == '\r')
		{
			i = sm_io_getc(f, SM_TIME_DEFAULT);
			if (i != '\n')
			{
				if (i != SM_IO_EOF)
					(void) sm_io_ungetc(f, SM_TIME_DEFAULT,
							    i);
				i = '\r';
			}
		}
		if (--n <= 0)
		{
			/* allocate new space */
			char *nbp;
			int nn;

			nn = (p - bp);
			if (nn < MEMCHUNKSIZE)
				nn *= 2;
			else
				nn += MEMCHUNKSIZE;
			nbp = sm_malloc_x(nn);
			memmove(nbp, bp, p - bp);
			p = &nbp[p - bp];
			if (bp != buf)
				sm_free(bp);
			bp = nbp;
			n = nn - (p - bp);
			*np = nn;
		}
		*p++ = i;
		if (i == '\n')
		{
			LineNumber++;
			i = sm_io_getc(f, SM_TIME_DEFAULT);
			if (i != SM_IO_EOF)
				(void) sm_io_ungetc(f, SM_TIME_DEFAULT, i);
			if (i != ' ' && i != '\t')
				break;
		}
	}
	if (p == bp)
		return NULL;
	if (p[-1] == '\n')
		p--;
	*p = '\0';
	return bp;
}

/*
**  CURTIME -- return current time.
**
**	Parameters:
**		none.
**
**	Returns:
**		the current time.
*/

time_t
curtime()
{
	auto time_t t;

	(void) time(&t);
	return t;
}

/*
**  ATOBOOL -- convert a string representation to boolean.
**
**	Defaults to false
**
**	Parameters:
**		s -- string to convert.  Takes "tTyY", empty, and NULL as true,
**			others as false.
**
**	Returns:
**		A boolean representation of the string.
*/

bool
atobool(s)
	register char *s;
{
	if (s == NULL || *s == '\0' || strchr("tTyY", *s) != NULL)
		return true;
	return false;
}

/*
**  ATOOCT -- convert a string representation to octal.
**
**	Parameters:
**		s -- string to convert.
**
**	Returns:
**		An integer representing the string interpreted as an
**		octal number.
*/

int
atooct(s)
	register char *s;
{
	register int i = 0;

	while (*s >= '0' && *s <= '7')
		i = (i << 3) | (*s++ - '0');
	return i;
}

/*
**  BITINTERSECT -- tell if two bitmaps intersect
**
**	Parameters:
**		a, b -- the bitmaps in question
**
**	Returns:
**		true if they have a non-null intersection
**		false otherwise
*/

bool
bitintersect(a, b)
	BITMAP256 a;
	BITMAP256 b;
{
	int i;

	for (i = BITMAPBYTES / sizeof(int); --i >= 0; )
	{
		if ((a[i] & b[i]) != 0)
			return true;
	}
	return false;
}

/*
**  BITZEROP -- tell if a bitmap is all zero
**
**	Parameters:
**		map -- the bit map to check
**
**	Returns:
**		true if map is all zero.
**		false if there are any bits set in map.
*/

bool
bitzerop(map)
	BITMAP256 map;
{
	int i;

	for (i = BITMAPBYTES / sizeof(int); --i >= 0; )
	{
		if (map[i] != 0)
			return false;
	}
	return true;
}

/*
**  STRCONTAINEDIN -- tell if one string is contained in another
**
**	Parameters:
**		icase -- ignore case?
**		a -- possible substring.
**		b -- possible superstring.
**
**	Returns:
**		true if a is contained in b (case insensitive).
**		false otherwise.
*/

bool
strcontainedin(icase, a, b)
	bool icase;
	register char *a;
	register char *b;
{
	int la;
	int lb;
	int c;

	la = strlen(a);
	lb = strlen(b);
	c = *a;
	if (icase && isascii(c) && isupper(c))
		c = tolower(c);
	for (; lb-- >= la; b++)
	{
		if (icase)
		{
			if (*b != c &&
			    isascii(*b) && isupper(*b) && tolower(*b) != c)
				continue;
			if (sm_strncasecmp(a, b, la) == 0)
				return true;
		}
		else
		{
			if (*b != c)
				continue;
			if (strncmp(a, b, la) == 0)
				return true;
		}
	}
	return false;
}

/*
**  CHECKFD012 -- check low numbered file descriptors
**
**	File descriptors 0, 1, and 2 should be open at all times.
**	This routine verifies that, and fixes it if not true.
**
**	Parameters:
**		where -- a tag printed if the assertion failed
**
**	Returns:
**		none
*/

void
checkfd012(where)
	char *where;
{
#if XDEBUG
	register int i;

	for (i = 0; i < 3; i++)
		fill_fd(i, where);
#endif /* XDEBUG */
}

/*
**  CHECKFDOPEN -- make sure file descriptor is open -- for extended debugging
**
**	Parameters:
**		fd -- file descriptor to check.
**		where -- tag to print on failure.
**
**	Returns:
**		none.
*/

void
checkfdopen(fd, where)
	int fd;
	char *where;
{
#if XDEBUG
	struct stat st;

	if (fstat(fd, &st) < 0 && errno == EBADF)
	{
		syserr("checkfdopen(%d): %s not open as expected!", fd, where);
		printopenfds(true);
	}
#endif /* XDEBUG */
}

/*
**  CHECKFDS -- check for new or missing file descriptors
**
**	Parameters:
**		where -- tag for printing.  If null, take a base line.
**
**	Returns:
**		none
**
**	Side Effects:
**		If where is set, shows changes since the last call.
*/

void
checkfds(where)
	char *where;
{
	int maxfd;
	register int fd;
	bool printhdr = true;
	int save_errno = errno;
	static BITMAP256 baseline;
	extern int DtableSize;

	if (DtableSize > BITMAPBITS)
		maxfd = BITMAPBITS;
	else
		maxfd = DtableSize;
	if (where == NULL)
		clrbitmap(baseline);

	for (fd = 0; fd < maxfd; fd++)
	{
		struct stat stbuf;

		if (fstat(fd, &stbuf) < 0 && errno != EOPNOTSUPP)
		{
			if (!bitnset(fd, baseline))
				continue;
			clrbitn(fd, baseline);
		}
		else if (!bitnset(fd, baseline))
			setbitn(fd, baseline);
		else
			continue;

		/* file state has changed */
		if (where == NULL)
			continue;
		if (printhdr)
		{
			sm_syslog(LOG_DEBUG, CurEnv->e_id,
				  "%s: changed fds:",
				  where);
			printhdr = false;
		}
		dumpfd(fd, true, true);
	}
	errno = save_errno;
}

/*
**  PRINTOPENFDS -- print the open file descriptors (for debugging)
**
**	Parameters:
**		logit -- if set, send output to syslog; otherwise
**			print for debugging.
**
**	Returns:
**		none.
*/

#if NETINET || NETINET6
# include <arpa/inet.h>
#endif /* NETINET || NETINET6 */

void
printopenfds(logit)
	bool logit;
{
	register int fd;
	extern int DtableSize;

	for (fd = 0; fd < DtableSize; fd++)
		dumpfd(fd, false, logit);
}

/*
**  DUMPFD -- dump a file descriptor
**
**	Parameters:
**		fd -- the file descriptor to dump.
**		printclosed -- if set, print a notification even if
**			it is closed; otherwise print nothing.
**		logit -- if set, use sm_syslog instead of sm_dprintf()
**
**	Returns:
**		none.
*/

void
dumpfd(fd, printclosed, logit)
	int fd;
	bool printclosed;
	bool logit;
{
	register char *p;
	char *hp;
#ifdef S_IFSOCK
	SOCKADDR sa;
#endif /* S_IFSOCK */
	auto SOCKADDR_LEN_T slen;
	int i;
#if STAT64 > 0
	struct stat64 st;
#else /* STAT64 > 0 */
	struct stat st;
#endif /* STAT64 > 0 */
	char buf[200];

	p = buf;
	(void) sm_snprintf(p, SPACELEFT(buf, p), "%3d: ", fd);
	p += strlen(p);

	if (
#if STAT64 > 0
	    fstat64(fd, &st)
#else /* STAT64 > 0 */
	    fstat(fd, &st)
#endif /* STAT64 > 0 */
	    < 0)
	{
		if (errno != EBADF)
		{
			(void) sm_snprintf(p, SPACELEFT(buf, p),
				"CANNOT STAT (%s)",
				sm_errstring(errno));
			goto printit;
		}
		else if (printclosed)
		{
			(void) sm_snprintf(p, SPACELEFT(buf, p), "CLOSED");
			goto printit;
		}
		return;
	}

	i = fcntl(fd, F_GETFL, 0);
	if (i != -1)
	{
		(void) sm_snprintf(p, SPACELEFT(buf, p), "fl=0x%x, ", i);
		p += strlen(p);
	}

	(void) sm_snprintf(p, SPACELEFT(buf, p), "mode=%o: ",
			(int) st.st_mode);
	p += strlen(p);
	switch (st.st_mode & S_IFMT)
	{
#ifdef S_IFSOCK
	  case S_IFSOCK:
		(void) sm_snprintf(p, SPACELEFT(buf, p), "SOCK ");
		p += strlen(p);
		memset(&sa, '\0', sizeof(sa));
		slen = sizeof(sa);
		if (getsockname(fd, &sa.sa, &slen) < 0)
			(void) sm_snprintf(p, SPACELEFT(buf, p), "(%s)",
				 sm_errstring(errno));
		else
		{
			hp = hostnamebyanyaddr(&sa);
			if (hp == NULL)
			{
				/* EMPTY */
				/* do nothing */
			}
# if NETINET
			else if (sa.sa.sa_family == AF_INET)
				(void) sm_snprintf(p, SPACELEFT(buf, p),
					"%s/%d", hp, ntohs(sa.sin.sin_port));
# endif /* NETINET */
# if NETINET6
			else if (sa.sa.sa_family == AF_INET6)
				(void) sm_snprintf(p, SPACELEFT(buf, p),
					"%s/%d", hp, ntohs(sa.sin6.sin6_port));
# endif /* NETINET6 */
			else
				(void) sm_snprintf(p, SPACELEFT(buf, p),
					"%s", hp);
		}
		p += strlen(p);
		(void) sm_snprintf(p, SPACELEFT(buf, p), "->");
		p += strlen(p);
		slen = sizeof(sa);
		if (getpeername(fd, &sa.sa, &slen) < 0)
			(void) sm_snprintf(p, SPACELEFT(buf, p), "(%s)",
					sm_errstring(errno));
		else
		{
			hp = hostnamebyanyaddr(&sa);
			if (hp == NULL)
			{
				/* EMPTY */
				/* do nothing */
			}
# if NETINET
			else if (sa.sa.sa_family == AF_INET)
				(void) sm_snprintf(p, SPACELEFT(buf, p),
					"%s/%d", hp, ntohs(sa.sin.sin_port));
# endif /* NETINET */
# if NETINET6
			else if (sa.sa.sa_family == AF_INET6)
				(void) sm_snprintf(p, SPACELEFT(buf, p),
					"%s/%d", hp, ntohs(sa.sin6.sin6_port));
# endif /* NETINET6 */
			else
				(void) sm_snprintf(p, SPACELEFT(buf, p),
					"%s", hp);
		}
		break;
#endif /* S_IFSOCK */

	  case S_IFCHR:
		(void) sm_snprintf(p, SPACELEFT(buf, p), "CHR: ");
		p += strlen(p);
		goto defprint;

#ifdef S_IFBLK
	  case S_IFBLK:
		(void) sm_snprintf(p, SPACELEFT(buf, p), "BLK: ");
		p += strlen(p);
		goto defprint;
#endif /* S_IFBLK */

#if defined(S_IFIFO) && (!defined(S_IFSOCK) || S_IFIFO != S_IFSOCK)
	  case S_IFIFO:
		(void) sm_snprintf(p, SPACELEFT(buf, p), "FIFO: ");
		p += strlen(p);
		goto defprint;
#endif /* defined(S_IFIFO) && (!defined(S_IFSOCK) || S_IFIFO != S_IFSOCK) */

#ifdef S_IFDIR
	  case S_IFDIR:
		(void) sm_snprintf(p, SPACELEFT(buf, p), "DIR: ");
		p += strlen(p);
		goto defprint;
#endif /* S_IFDIR */

#ifdef S_IFLNK
	  case S_IFLNK:
		(void) sm_snprintf(p, SPACELEFT(buf, p), "LNK: ");
		p += strlen(p);
		goto defprint;
#endif /* S_IFLNK */

	  default:
defprint:
		(void) sm_snprintf(p, SPACELEFT(buf, p),
			 "dev=%d/%d, ino=%llu, nlink=%d, u/gid=%d/%d, ",
			 major(st.st_dev), minor(st.st_dev),
			 (ULONGLONG_T) st.st_ino,
			 (int) st.st_nlink, (int) st.st_uid,
			 (int) st.st_gid);
		p += strlen(p);
		(void) sm_snprintf(p, SPACELEFT(buf, p), "size=%llu",
			 (ULONGLONG_T) st.st_size);
		break;
	}

printit:
	if (logit)
		sm_syslog(LOG_DEBUG, CurEnv ? CurEnv->e_id : NULL,
			  "%.800s", buf);
	else
		sm_dprintf("%s\n", buf);
}

/*
**  SHORTEN_HOSTNAME -- strip local domain information off of hostname.
**
**	Parameters:
**		host -- the host to shorten (stripped in place).
**
**	Returns:
**		place where string was truncated, NULL if not truncated.
*/

char *
shorten_hostname(host)
	char host[];
{
	register char *p;
	char *mydom;
	int i;
	bool canon = false;

	/* strip off final dot */
	i = strlen(host);
	p = &host[(i == 0) ? 0 : i - 1];
	if (*p == '.')
	{
		*p = '\0';
		canon = true;
	}

	/* see if there is any domain at all -- if not, we are done */
	p = strchr(host, '.');
	if (p == NULL)
		return NULL;

	/* yes, we have a domain -- see if it looks like us */
	mydom = macvalue('m', CurEnv);
	if (mydom == NULL)
		mydom = "";
	i = strlen(++p);
	if ((canon ? sm_strcasecmp(p, mydom)
		   : sm_strncasecmp(p, mydom, i)) == 0 &&
			(mydom[i] == '.' || mydom[i] == '\0'))
	{
		*--p = '\0';
		return p;
	}
	return NULL;
}

/*
**  PROG_OPEN -- open a program for reading
**
**	Parameters:
**		argv -- the argument list.
**		pfd -- pointer to a place to store the file descriptor.
**		e -- the current envelope.
**
**	Returns:
**		pid of the process -- -1 if it failed.
*/

pid_t
prog_open(argv, pfd, e)
	char **argv;
	int *pfd;
	ENVELOPE *e;
{
	pid_t pid;
	int save_errno;
	int sff;
	int ret;
	int fdv[2];
	char *p, *q;
	char buf[MAXPATHLEN];
	extern int DtableSize;

	if (pipe(fdv) < 0)
	{
		syserr("%s: cannot create pipe for stdout", argv[0]);
		return -1;
	}
	pid = fork();
	if (pid < 0)
	{
		syserr("%s: cannot fork", argv[0]);
		(void) close(fdv[0]);
		(void) close(fdv[1]);
		return -1;
	}
	if (pid > 0)
	{
		/* parent */
		(void) close(fdv[1]);
		*pfd = fdv[0];
		return pid;
	}

	/* Reset global flags */
	RestartRequest = NULL;
	RestartWorkGroup = false;
	ShutdownRequest = NULL;
	PendingSignal = 0;
	CurrentPid = getpid();

	/*
	**  Initialize exception stack and default exception
	**  handler for child process.
	*/

	sm_exc_newthread(fatal_error);

	/* child -- close stdin */
	(void) close(0);

	/* stdout goes back to parent */
	(void) close(fdv[0]);
	if (dup2(fdv[1], 1) < 0)
	{
		syserr("%s: cannot dup2 for stdout", argv[0]);
		_exit(EX_OSERR);
	}
	(void) close(fdv[1]);

	/* stderr goes to transcript if available */
	if (e->e_xfp != NULL)
	{
		int xfd;

		xfd = sm_io_getinfo(e->e_xfp, SM_IO_WHAT_FD, NULL);
		if (xfd >= 0 && dup2(xfd, 2) < 0)
		{
			syserr("%s: cannot dup2 for stderr", argv[0]);
			_exit(EX_OSERR);
		}
	}

	/* this process has no right to the queue file */
	if (e->e_lockfp != NULL)
	{
		int fd;

		fd = sm_io_getinfo(e->e_lockfp, SM_IO_WHAT_FD, NULL);
		if (fd >= 0)
			(void) close(fd);
		else
			syserr("%s: lockfp does not have a fd", argv[0]);
	}

	/* chroot to the program mailer directory, if defined */
	if (ProgMailer != NULL && ProgMailer->m_rootdir != NULL)
	{
		expand(ProgMailer->m_rootdir, buf, sizeof(buf), e);
		if (chroot(buf) < 0)
		{
			syserr("prog_open: cannot chroot(%s)", buf);
			exit(EX_TEMPFAIL);
		}
		if (chdir("/") < 0)
		{
			syserr("prog_open: cannot chdir(/)");
			exit(EX_TEMPFAIL);
		}
	}

	/* run as default user */
	endpwent();
	sm_mbdb_terminate();
#if _FFR_MEMSTAT
	(void) sm_memstat_close();
#endif /* _FFR_MEMSTAT */
	if (setgid(DefGid) < 0 && geteuid() == 0)
	{
		syserr("prog_open: setgid(%ld) failed", (long) DefGid);
		exit(EX_TEMPFAIL);
	}
	if (setuid(DefUid) < 0 && geteuid() == 0)
	{
		syserr("prog_open: setuid(%ld) failed", (long) DefUid);
		exit(EX_TEMPFAIL);
	}

	/* run in some directory */
	if (ProgMailer != NULL)
		p = ProgMailer->m_execdir;
	else
		p = NULL;
	for (; p != NULL; p = q)
	{
		q = strchr(p, ':');
		if (q != NULL)
			*q = '\0';
		expand(p, buf, sizeof(buf), e);
		if (q != NULL)
			*q++ = ':';
		if (buf[0] != '\0' && chdir(buf) >= 0)
			break;
	}
	if (p == NULL)
	{
		/* backup directories */
		if (chdir("/tmp") < 0)
			(void) chdir("/");
	}

	/* Check safety of program to be run */
	sff = SFF_ROOTOK|SFF_EXECOK;
	if (!bitnset(DBS_RUNWRITABLEPROGRAM, DontBlameSendmail))
		sff |= SFF_NOGWFILES|SFF_NOWWFILES;
	if (bitnset(DBS_RUNPROGRAMINUNSAFEDIRPATH, DontBlameSendmail))
		sff |= SFF_NOPATHCHECK;
	else
		sff |= SFF_SAFEDIRPATH;
	ret = safefile(argv[0], DefUid, DefGid, DefUser, sff, 0, NULL);
	if (ret != 0)
		sm_syslog(LOG_INFO, e->e_id,
			  "Warning: prog_open: program %s unsafe: %s",
			  argv[0], sm_errstring(ret));

	/* arrange for all the files to be closed */
	sm_close_on_exec(STDERR_FILENO + 1, DtableSize);

	/* now exec the process */
	(void) execve(argv[0], (ARGV_T) argv, (ARGV_T) UserEnviron);

	/* woops!  failed */
	save_errno = errno;
	syserr("%s: cannot exec", argv[0]);
	if (transienterror(save_errno))
		_exit(EX_OSERR);
	_exit(EX_CONFIG);
	return -1;	/* avoid compiler warning on IRIX */
}

/*
**  GET_COLUMN -- look up a Column in a line buffer
**
**	Parameters:
**		line -- the raw text line to search.
**		col -- the column number to fetch.
**		delim -- the delimiter between columns.  If null,
**			use white space.
**		buf -- the output buffer.
**		buflen -- the length of buf.
**
**	Returns:
**		buf if successful.
**		NULL otherwise.
*/

char *
get_column(line, col, delim, buf, buflen)
	char line[];
	int col;
	int delim;
	char buf[];
	int buflen;
{
	char *p;
	char *begin, *end;
	int i;
	char delimbuf[4];

	if ((char) delim == '\0')
		(void) sm_strlcpy(delimbuf, "\n\t ", sizeof(delimbuf));
	else
	{
		delimbuf[0] = (char) delim;
		delimbuf[1] = '\0';
	}

	p = line;
	if (*p == '\0')
		return NULL;			/* line empty */
	if (*p == (char) delim && col == 0)
		return NULL;			/* first column empty */

	begin = line;

	if (col == 0 && (char) delim == '\0')
	{
		while (*begin != '\0' && isascii(*begin) && isspace(*begin))
			begin++;
	}

	for (i = 0; i < col; i++)
	{
		if ((begin = strpbrk(begin, delimbuf)) == NULL)
			return NULL;		/* no such column */
		begin++;
		if ((char) delim == '\0')
		{
			while (*begin != '\0' && isascii(*begin) && isspace(*begin))
				begin++;
		}
	}

	end = strpbrk(begin, delimbuf);
	if (end == NULL)
		i = strlen(begin);
	else
		i = end - begin;
	if (i >= buflen)
		i = buflen - 1;
	(void) sm_strlcpy(buf, begin, i + 1);
	return buf;
}

/*
**  CLEANSTRCPY -- copy string keeping out bogus characters
**
**	Parameters:
**		t -- "to" string.
**		f -- "from" string.
**		l -- length of space available in "to" string.
**
**	Returns:
**		none.
*/

void
cleanstrcpy(t, f, l)
	register char *t;
	register char *f;
	int l;
{
	/* check for newlines and log if necessary */
	(void) denlstring(f, true, true);

	if (l <= 0)
		syserr("!cleanstrcpy: length == 0");

	l--;
	while (l > 0 && *f != '\0')
	{
		if (isascii(*f) &&
		    (isalnum(*f) || strchr("!#$%&'*+-./^_`{|}~", *f) != NULL))
		{
			l--;
			*t++ = *f;
		}
		f++;
	}
	*t = '\0';
}

/*
**  DENLSTRING -- convert newlines in a string to spaces
**
**	Parameters:
**		s -- the input string
**		strict -- if set, don't permit continuation lines.
**		logattacks -- if set, log attempted attacks.
**
**	Returns:
**		A pointer to a version of the string with newlines
**		mapped to spaces.  This should be copied.
*/

char *
denlstring(s, strict, logattacks)
	char *s;
	bool strict;
	bool logattacks;
{
	register char *p;
	int l;
	static char *bp = NULL;
	static int bl = 0;

	p = s;
	while ((p = strchr(p, '\n')) != NULL)
		if (strict || (*++p != ' ' && *p != '\t'))
			break;
	if (p == NULL)
		return s;

	l = strlen(s) + 1;
	if (bl < l)
	{
		/* allocate more space */
		char *nbp = sm_pmalloc_x(l);

		if (bp != NULL)
			sm_free(bp);
		bp = nbp;
		bl = l;
	}
	(void) sm_strlcpy(bp, s, l);
	for (p = bp; (p = strchr(p, '\n')) != NULL; )
		*p++ = ' ';

	if (logattacks)
	{
		sm_syslog(LOG_NOTICE, CurEnv ? CurEnv->e_id : NULL,
			  "POSSIBLE ATTACK from %.100s: newline in string \"%s\"",
			  RealHostName == NULL ? "[UNKNOWN]" : RealHostName,
			  shortenstring(bp, MAXSHORTSTR));
	}

	return bp;
}

/*
**  STRREPLNONPRT -- replace "unprintable" characters in a string with subst
**
**	Parameters:
**		s -- string to manipulate (in place)
**		subst -- character to use as replacement
**
**	Returns:
**		true iff string did not contain "unprintable" characters
*/

bool
strreplnonprt(s, c)
	char *s;
	int c;
{
	bool ok;

	ok = true;
	if (s == NULL)
		return ok;
	while (*s != '\0')
	{
		if (!(isascii(*s) && isprint(*s)))
		{
			*s = c;
			ok = false;
		}
		++s;
	}
	return ok;
}

/*
**  PATH_IS_DIR -- check to see if file exists and is a directory.
**
**	There are some additional checks for security violations in
**	here.  This routine is intended to be used for the host status
**	support.
**
**	Parameters:
**		pathname -- pathname to check for directory-ness.
**		createflag -- if set, create directory if needed.
**
**	Returns:
**		true -- if the indicated pathname is a directory
**		false -- otherwise
*/

bool
path_is_dir(pathname, createflag)
	char *pathname;
	bool createflag;
{
	struct stat statbuf;

#if HASLSTAT
	if (lstat(pathname, &statbuf) < 0)
#else /* HASLSTAT */
	if (stat(pathname, &statbuf) < 0)
#endif /* HASLSTAT */
	{
		if (errno != ENOENT || !createflag)
			return false;
		if (mkdir(pathname, 0755) < 0)
			return false;
		return true;
	}
	if (!S_ISDIR(statbuf.st_mode))
	{
		errno = ENOTDIR;
		return false;
	}

	/* security: don't allow writable directories */
	if (bitset(S_IWGRP|S_IWOTH, statbuf.st_mode))
	{
		errno = EACCES;
		return false;
	}
	return true;
}

/*
**  PROC_LIST_ADD -- add process id to list of our children
**
**	Parameters:
**		pid -- pid to add to list.
**		task -- task of pid.
**		type -- type of process.
**		count -- number of processes.
**		other -- other information for this type.
**
**	Returns:
**		none
**
**	Side Effects:
**		May increase CurChildren. May grow ProcList.
*/

typedef struct procs	PROCS_T;

struct procs
{
	pid_t		proc_pid;
	char		*proc_task;
	int		proc_type;
	int		proc_count;
	int		proc_other;
	SOCKADDR	proc_hostaddr;
};

static PROCS_T	*volatile ProcListVec = NULL;
static int	ProcListSize = 0;

void
proc_list_add(pid, task, type, count, other, hostaddr)
	pid_t pid;
	char *task;
	int type;
	int count;
	int other;
	SOCKADDR *hostaddr;
{
	int i;

	for (i = 0; i < ProcListSize; i++)
	{
		if (ProcListVec[i].proc_pid == NO_PID)
			break;
	}
	if (i >= ProcListSize)
	{
		/* probe the existing vector to avoid growing infinitely */
		proc_list_probe();

		/* now scan again */
		for (i = 0; i < ProcListSize; i++)
		{
			if (ProcListVec[i].proc_pid == NO_PID)
				break;
		}
	}
	if (i >= ProcListSize)
	{
		/* grow process list */
		int chldwasblocked;
		PROCS_T *npv;

		SM_ASSERT(ProcListSize < INT_MAX - PROC_LIST_SEG);
		npv = (PROCS_T *) sm_pmalloc_x((sizeof(*npv)) *
					       (ProcListSize + PROC_LIST_SEG));

		/* Block SIGCHLD so reapchild() doesn't mess with us */
		chldwasblocked = sm_blocksignal(SIGCHLD);
		if (ProcListSize > 0)
		{
			memmove(npv, ProcListVec,
				ProcListSize * sizeof(PROCS_T));
			sm_free(ProcListVec);
		}

		/* XXX just use memset() to initialize this part? */
		for (i = ProcListSize; i < ProcListSize + PROC_LIST_SEG; i++)
		{
			npv[i].proc_pid = NO_PID;
			npv[i].proc_task = NULL;
			npv[i].proc_type = PROC_NONE;
		}
		i = ProcListSize;
		ProcListSize += PROC_LIST_SEG;
		ProcListVec = npv;
		if (chldwasblocked == 0)
			(void) sm_releasesignal(SIGCHLD);
	}
	ProcListVec[i].proc_pid = pid;
	PSTRSET(ProcListVec[i].proc_task, task);
	ProcListVec[i].proc_type = type;
	ProcListVec[i].proc_count = count;
	ProcListVec[i].proc_other = other;
	if (hostaddr != NULL)
		ProcListVec[i].proc_hostaddr = *hostaddr;
	else
		memset(&ProcListVec[i].proc_hostaddr, 0,
			sizeof(ProcListVec[i].proc_hostaddr));

	/* if process adding itself, it's not a child */
	if (pid != CurrentPid)
	{
		SM_ASSERT(CurChildren < INT_MAX);
		CurChildren++;
	}
}

/*
**  PROC_LIST_SET -- set pid task in process list
**
**	Parameters:
**		pid -- pid to set
**		task -- task of pid
**
**	Returns:
**		none.
*/

void
proc_list_set(pid, task)
	pid_t pid;
	char *task;
{
	int i;

	for (i = 0; i < ProcListSize; i++)
	{
		if (ProcListVec[i].proc_pid == pid)
		{
			PSTRSET(ProcListVec[i].proc_task, task);
			break;
		}
	}
}

/*
**  PROC_LIST_DROP -- drop pid from process list
**
**	Parameters:
**		pid -- pid to drop
**		st -- process status
**		other -- storage for proc_other (return).
**
**	Returns:
**		none.
**
**	Side Effects:
**		May decrease CurChildren, CurRunners, or
**		set RestartRequest or ShutdownRequest.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

void
proc_list_drop(pid, st, other)
	pid_t pid;
	int st;
	int *other;
{
	int i;
	int type = PROC_NONE;

	for (i = 0; i < ProcListSize; i++)
	{
		if (ProcListVec[i].proc_pid == pid)
		{
			ProcListVec[i].proc_pid = NO_PID;
			type = ProcListVec[i].proc_type;
			if (other != NULL)
				*other = ProcListVec[i].proc_other;
			if (CurChildren > 0)
				CurChildren--;
			break;
		}
	}


	if (type == PROC_CONTROL && WIFEXITED(st))
	{
		/* if so, see if we need to restart or shutdown */
		if (WEXITSTATUS(st) == EX_RESTART)
			RestartRequest = "control socket";
		else if (WEXITSTATUS(st) == EX_SHUTDOWN)
			ShutdownRequest = "control socket";
	}
	else if (type == PROC_QUEUE_CHILD && !WIFSTOPPED(st) &&
		 ProcListVec[i].proc_other > -1)
	{
		/* restart this persistent runner */
		mark_work_group_restart(ProcListVec[i].proc_other, st);
	}
	else if (type == PROC_QUEUE)
	{
		CurRunners -= ProcListVec[i].proc_count;

		/* CHK_CUR_RUNNERS() can't be used here: uses syslog() */
		if (CurRunners < 0)
			CurRunners = 0;
	}
}

/*
**  PROC_LIST_CLEAR -- clear the process list
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets CurChildren to zero.
*/

void
proc_list_clear()
{
	int i;

	/* start from 1 since 0 is the daemon itself */
	for (i = 1; i < ProcListSize; i++)
		ProcListVec[i].proc_pid = NO_PID;
	CurChildren = 0;
}

/*
**  PROC_LIST_PROBE -- probe processes in the list to see if they still exist
**
**	Parameters:
**		none
**
**	Returns:
**		none
**
**	Side Effects:
**		May decrease CurChildren.
*/

void
proc_list_probe()
{
	int i, children;
	int chldwasblocked;
	pid_t pid;

	children = 0;
	chldwasblocked = sm_blocksignal(SIGCHLD);

	/* start from 1 since 0 is the daemon itself */
	for (i = 1; i < ProcListSize; i++)
	{
		pid = ProcListVec[i].proc_pid;
		if (pid == NO_PID || pid == CurrentPid)
			continue;
		if (kill(pid, 0) < 0)
		{
			if (LogLevel > 3)
				sm_syslog(LOG_DEBUG, CurEnv->e_id,
					  "proc_list_probe: lost pid %d",
					  (int) ProcListVec[i].proc_pid);
			ProcListVec[i].proc_pid = NO_PID;
			SM_FREE_CLR(ProcListVec[i].proc_task);

			if (ProcListVec[i].proc_type == PROC_QUEUE)
			{
				CurRunners -= ProcListVec[i].proc_count;
				CHK_CUR_RUNNERS("proc_list_probe", i,
						ProcListVec[i].proc_count);
			}

			CurChildren--;
		}
		else
		{
			++children;
		}
	}
	if (CurChildren < 0)
		CurChildren = 0;
	if (chldwasblocked == 0)
		(void) sm_releasesignal(SIGCHLD);
	if (LogLevel > 10 && children != CurChildren && CurrentPid == DaemonPid)
	{
		sm_syslog(LOG_ERR, NOQID,
			  "proc_list_probe: found %d children, expected %d",
			  children, CurChildren);
	}
}

/*
**  PROC_LIST_DISPLAY -- display the process list
**
**	Parameters:
**		out -- output file pointer
**		prefix -- string to output in front of each line.
**
**	Returns:
**		none.
*/

void
proc_list_display(out, prefix)
	SM_FILE_T *out;
	char *prefix;
{
	int i;

	for (i = 0; i < ProcListSize; i++)
	{
		if (ProcListVec[i].proc_pid == NO_PID)
			continue;

		(void) sm_io_fprintf(out, SM_TIME_DEFAULT, "%s%d %s%s\n",
				     prefix,
				     (int) ProcListVec[i].proc_pid,
				     ProcListVec[i].proc_task != NULL ?
				     ProcListVec[i].proc_task : "(unknown)",
				     (OpMode == MD_SMTP ||
				      OpMode == MD_DAEMON ||
				      OpMode == MD_ARPAFTP) ? "\r" : "");
	}
}

/*
**  PROC_LIST_SIGNAL -- send a signal to a type of process in the list
**
**	Parameters:
**		type -- type of process to signal
**		signal -- the type of signal to send
**
**	Results:
**		none.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

void
proc_list_signal(type, signal)
	int type;
	int signal;
{
	int chldwasblocked;
	int alrmwasblocked;
	int i;
	pid_t mypid = getpid();

	/* block these signals so that we may signal cleanly */
	chldwasblocked = sm_blocksignal(SIGCHLD);
	alrmwasblocked = sm_blocksignal(SIGALRM);

	/* Find all processes of type and send signal */
	for (i = 0; i < ProcListSize; i++)
	{
		if (ProcListVec[i].proc_pid == NO_PID ||
		    ProcListVec[i].proc_pid == mypid)
			continue;
		if (ProcListVec[i].proc_type != type)
			continue;
		(void) kill(ProcListVec[i].proc_pid, signal);
	}

	/* restore the signals */
	if (alrmwasblocked == 0)
		(void) sm_releasesignal(SIGALRM);
	if (chldwasblocked == 0)
		(void) sm_releasesignal(SIGCHLD);
}

/*
**  COUNT_OPEN_CONNECTIONS
**
**	Parameters:
**		hostaddr - ClientAddress
**
**	Returns:
**		the number of open connections for this client
**
*/

int
count_open_connections(hostaddr)
	SOCKADDR *hostaddr;
{
	int i, n;

	if (hostaddr == NULL)
		return 0;

	/*
	**  This code gets called before proc_list_add() gets called,
	**  so we (the daemon child for this connection) have not yet
	**  counted ourselves.  Hence initialize the counter to 1
	**  instead of 0 to compensate.
	*/

	n = 1;
	for (i = 0; i < ProcListSize; i++)
	{
		if (ProcListVec[i].proc_pid == NO_PID)
			continue;
		if (hostaddr->sa.sa_family !=
		    ProcListVec[i].proc_hostaddr.sa.sa_family)
			continue;
#if NETINET
		if (hostaddr->sa.sa_family == AF_INET &&
		    (hostaddr->sin.sin_addr.s_addr ==
		     ProcListVec[i].proc_hostaddr.sin.sin_addr.s_addr))
			n++;
#endif /* NETINET */
#if NETINET6
		if (hostaddr->sa.sa_family == AF_INET6 &&
		    IN6_ARE_ADDR_EQUAL(&(hostaddr->sin6.sin6_addr),
				       &(ProcListVec[i].proc_hostaddr.sin6.sin6_addr)))
			n++;
#endif /* NETINET6 */
	}
	return n;
}

@


1.25
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.24
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2007, 2009 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: util.c,v 8.426 2013/03/12 15:24:54 ca Exp $")
@


1.23
log
@Update to sendmail 8.14.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: util.c,v 8.425 2012/03/03 00:10:43 ca Exp $")
d1288 1
a1288 2
	int save_errno;
	int io_timeout;
d1301 1
a1301 1
	p = NULL;
d1309 2
a1310 2
		p = sm_io_fgets(fp, io_timeout, buf, siz);
		if (p == NULL && errno == EAGAIN)
d1330 1
a1330 1
		if (p != NULL || errno != EINTR)
d1338 1
a1338 1
	if (p == NULL)
@


1.22
log
@Update to sendmail 8.14.5
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: util.c,v 8.416 2009/12/18 17:05:26 ca Exp $")
d2641 1
d2643 5
d2711 8
d2869 1
@


1.21
log
@Update to sendmail-8.14.3
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2007 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: util.c,v 8.414 2007/11/02 17:30:38 ca Exp $")
d871 1
a871 1
		if (isprint(c))
d898 1
a898 1
		if (isprint(c))
@


1.20
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2006 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: util.c,v 8.410 2006/12/18 18:36:44 ca Exp $")
d1157 2
a1158 1
		    bitnset(M_XDOT, mci->mci_mailer->m_flags))
d1173 2
a1174 1
			 bitnset(M_ESCFROM, mci->mci_mailer->m_flags))
d1193 1
a1193 3
		if ((!bitset(PXLF_NOADDEOL, pxflags) || !noeol) &&
		    sm_io_fputs(mci->mci_out, SM_TIME_DEFAULT,
				mci->mci_mailer->m_eol) == SM_IO_EOF)
d1195 7
a1201 2
			dead = true;
			break;
d1203 3
d2824 9
a2832 1
	n = 0;
@


1.19
log
@Update to sendmail-8.13.8
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: util.c,v 8.394 2006/05/03 23:55:29 ca Exp $")
d18 1
d184 1
d293 1
a388 1
#if _FFR_BESTMX_BETTER_TRUNCATION || _FFR_DNSMAP_MULTI
d431 1
a431 1
#endif /* _FFR_BESTMX_BETTER_TRUNCATION || _FFR_DNSMAP_MULTI */
d477 1
d510 2
a511 2
	newvp = (char **) sm_rpool_malloc_x(rpool, (vp - list) * sizeof *vp);
	memmove((char *) newvp, (char *) list, (int) (vp - list) * sizeof *vp);
d521 1
d550 1
a550 1
							sizeof *newaddr);
d561 1
d590 1
a590 1
	expand(PidFile, pidpath, sizeof pidpath, e);
d674 1
d701 1
d719 1
a719 1
	register char **av;
d727 4
a730 1
		xputs(fp, *av++);
d734 1
d752 1
a752 1
	register const char *s;
d754 2
a755 2
	register int c;
	register struct metamac *mp;
d772 1
a772 1
			TermEscape.te_rv_off = "\033[0m";
d777 1
a777 1
			TermEscape.te_rv_off = "";
d784 1
a784 1
				     TermEscape.te_rv_on, TermEscape.te_rv_off);
d792 1
a792 1
					     TermEscape.te_rv_off);
d795 1
a795 1
		if (!isascii(c))
d903 5
a907 1
		else
d915 1
a915 1
				     TermEscape.te_rv_off);
d918 1
d945 1
d981 1
d1006 1
d1022 1
d1031 31
a1068 1
	bool dead = false;
d1070 2
a1071 1
	int slop = 0;
d1074 4
a1077 9
	if (bitset(MCIF_7BIT, mci->mci_flags) ||
	    bitset(PXLF_STRIP8BIT, pxflags))
	{
		register char svchar;

		for (p = l; (svchar = *p) != '\0'; ++p)
			if (bitset(0200, svchar))
				*p = svchar &~ 0200;
	}
a1099 1
			char *l_base = l;
d1128 1
a1128 9
			while (l < q)
			{
				if (sm_io_putc(mci->mci_out, SM_TIME_DEFAULT,
				       (unsigned char) *l++) == SM_IO_EOF)
				{
					dead = true;
					break;
				}
			}
d1132 2
a1133 2
			if (sm_io_putc(mci->mci_out, SM_TIME_DEFAULT, '!') ==
			    SM_IO_EOF ||
d1135 3
a1137 4
					mci->mci_mailer->m_eol) ==
			    SM_IO_EOF ||
			    sm_io_putc(mci->mci_out, SM_TIME_DEFAULT, ' ') ==
			    SM_IO_EOF)
a1143 4
				for (l = l_base; l < q; l++)
					(void) sm_io_putc(TrafficLogFile,
							  SM_TIME_DEFAULT,
							  (unsigned char)*l);
d1184 1
a1184 13
		for ( ; l < p; ++l)
		{
			if (TrafficLogFile != NULL)
				(void) sm_io_putc(TrafficLogFile,
						  SM_TIME_DEFAULT,
						  (unsigned char)*l);
			if (sm_io_putc(mci->mci_out, SM_TIME_DEFAULT,
				       (unsigned char) *l) == SM_IO_EOF)
			{
				dead = true;
				break;
			}
		}
d1253 1
d1362 1
d1368 3
a1370 1
**		n -- bytes available.
d1385 1
a1385 1
fgetfolded(buf, n, f)
d1387 1
a1387 1
	register int n;
d1393 1
d1395 2
d1438 1
d1458 1
d1477 1
d1499 1
d1521 1
d1540 1
a1540 1
	for (i = BITMAPBYTES / sizeof (int); --i >= 0; )
d1547 1
d1565 1
a1565 1
	for (i = BITMAPBYTES / sizeof (int); --i >= 0; )
d1572 1
d1621 1
d1646 1
d1673 1
d1734 1
d1760 1
d1837 2
a1838 2
		memset(&sa, '\0', sizeof sa);
		slen = sizeof sa;
d1867 1
a1867 1
		slen = sizeof sa;
d1950 1
d1998 1
d2101 1
a2101 1
		expand(ProgMailer->m_rootdir, buf, sizeof buf, e);
d2141 1
a2141 1
		expand(p, buf, sizeof buf, e);
d2182 1
d2213 1
a2213 1
		(void) sm_strlcpy(delimbuf, "\n\t ", sizeof delimbuf);
d2256 1
d2294 1
d2343 1
a2343 1
		sm_syslog(LOG_NOTICE, CurEnv->e_id,
a2385 95
**  STR2PRT -- convert "unprintable" characters in a string to \oct
**
**	Parameters:
**		s -- string to convert
**
**	Returns:
**		converted string.
**		This is a static local buffer, string must be copied
**		before this function is called again!
*/

char *
str2prt(s)
	char *s;
{
	int l;
	char c, *h;
	bool ok;
	static int len = 0;
	static char *buf = NULL;

	if (s == NULL)
		return NULL;
	ok = true;
	for (h = s, l = 1; *h != '\0'; h++, l++)
	{
		if (*h == '\\')
		{
			++l;
			ok = false;
		}
		else if (!(isascii(*h) && isprint(*h)))
		{
			l += 3;
			ok = false;
		}
	}
	if (ok)
		return s;
	if (l > len)
	{
		char *nbuf = sm_pmalloc_x(l);

		if (buf != NULL)
			sm_free(buf);
		len = l;
		buf = nbuf;
	}
	for (h = buf; *s != '\0' && l > 0; s++, l--)
	{
		c = *s;
		if (isascii(c) && isprint(c) && c != '\\')
		{
			*h++ = c;
		}
		else
		{
			*h++ = '\\';
			--l;
			switch (c)
			{
			  case '\\':
				*h++ = '\\';
				break;
			  case '\t':
				*h++ = 't';
				break;
			  case '\n':
				*h++ = 'n';
				break;
			  case '\r':
				*h++ = 'r';
				break;
			  default:
				SM_ASSERT(l >= 2);
				(void) sm_snprintf(h, l, "%03o",
					(unsigned int)((unsigned char) c));

				/*
				**  XXX since l is unsigned this may
				**  wrap around if the calculation is screwed
				**  up...
				*/

				l -= 2;
				h += 3;
				break;
			}
		}
	}
	*h = '\0';
	buf[len - 1] = '\0';
	return buf;
}
/*
d2434 1
d2498 1
d2502 1
a2502 1
		npv = (PROCS_T *) sm_pmalloc_x((sizeof *npv) *
d2504 3
d2510 1
a2510 1
				ProcListSize * sizeof (PROCS_T));
d2524 2
d2545 1
d2573 1
d2635 1
d2659 1
@


1.18
log
@Update to sendmail 8.13.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: util.c,v 8.392 2006/03/09 19:49:35 ca Exp $")
d2047 9
a2055 1
		(void) close(sm_io_getinfo(e->e_lockfp, SM_IO_WHAT_FD, NULL));
d2748 1
a2748 1
	if (LogLevel > 10 && children != CurChildren)
@


1.17
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: util.c,v 8.383 2004/08/02 18:50:59 ca Exp $")
d459 2
d975 1
a975 1
**		none
d981 1
a981 1
void
d986 1
a986 1
	putxline(l, strlen(l), mci, PXLF_MAPFROM);
d1005 1
a1005 1
**		none
d1011 1
a1011 1
void
a1062 5
				else
				{
					/* record progress for DATA timeout */
					DataProgress = true;
				}
a1074 5
				else
				{
					/* record progress for DATA timeout */
					DataProgress = true;
				}
d1086 1
a1086 1
					       (unsigned char) *l++) == SM_IO_EOF)
a1090 5
				else
				{
					/* record progress for DATA timeout */
					DataProgress = true;
				}
a1105 5
			else
			{
				/* record progress for DATA timeout */
				DataProgress = true;
			}
d1129 2
a1131 4
			else
			{
				/* record progress for DATA timeout */
				DataProgress = true;
d1144 2
a1146 4
			else
			{
				/* record progress for DATA timeout */
				DataProgress = true;
a1163 5
			else
			{
				/* record progress for DATA timeout */
				DataProgress = true;
			}
d1174 2
a1176 4
		else
		{
			/* record progress for DATA timeout */
			DataProgress = true;
d1185 2
a1187 4
				else
				{
					/* record progress for DATA timeout */
					DataProgress = true;
a1195 2
		/* record progress for DATA timeout */
		DataProgress = true;
d1197 1
d1199 1
d2068 3
d2408 1
d2645 2
a2649 2
	if (CurChildren > 0)
		CurChildren--;
d2708 6
a2713 1
	int i;
d2718 2
a2719 1
		if (ProcListVec[i].proc_pid == NO_PID)
d2721 1
a2721 1
		if (kill(ProcListVec[i].proc_pid, 0) < 0)
d2731 4
d2738 8
a2852 1

@


1.17.6.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@a458 2
	SM_REQUIRE(sz >= 0);

d973 1
a973 1
**		true iff line was written successfully
d979 1
a979 1
bool
d984 1
a984 1
	return putxline(l, strlen(l), mci, PXLF_MAPFROM);
d1003 1
a1003 1
**		true iff line was written successfully
d1009 1
a1009 1
bool
d1061 5
d1078 5
d1094 1
a1094 1
				       (unsigned char) *l++) == SM_IO_EOF)
d1099 5
d1119 5
d1147 2
d1150 2
a1151 2
				dead = true;
				break;
d1164 2
d1167 2
a1168 2
				dead = true;
				break;
d1186 5
d1201 2
d1204 2
a1205 2
			dead = true;
			break;
d1214 2
d1217 2
a1218 2
					dead = true;
					break;
d1227 2
a1229 1
	return !dead;
a1230 1

a2435 1
				SM_ASSERT(l >= 2);
@


1.17.4.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@a458 2
	SM_REQUIRE(sz >= 0);

d973 1
a973 1
**		true iff line was written successfully
d979 1
a979 1
bool
d984 1
a984 1
	return putxline(l, strlen(l), mci, PXLF_MAPFROM);
d1003 1
a1003 1
**		true iff line was written successfully
d1009 1
a1009 1
bool
d1061 5
d1078 5
d1094 1
a1094 1
				       (unsigned char) *l++) == SM_IO_EOF)
d1099 5
d1119 5
d1147 2
d1150 2
a1151 2
				dead = true;
				break;
d1164 2
d1167 2
a1168 2
				dead = true;
				break;
d1186 5
d1201 2
d1204 2
a1205 2
			dead = true;
			break;
d1214 2
d1217 2
a1218 2
					dead = true;
					break;
d1227 2
a1229 1
	return !dead;
a1230 1

a2435 1
				SM_ASSERT(l >= 2);
@


1.17.2.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@a458 2
	SM_REQUIRE(sz >= 0);

d973 1
a973 1
**		true iff line was written successfully
d979 1
a979 1
bool
d984 1
a984 1
	return putxline(l, strlen(l), mci, PXLF_MAPFROM);
d1003 1
a1003 1
**		true iff line was written successfully
d1009 1
a1009 1
bool
d1061 5
d1078 5
d1094 1
a1094 1
				       (unsigned char) *l++) == SM_IO_EOF)
d1099 5
d1119 5
d1147 2
d1150 2
a1151 2
				dead = true;
				break;
d1164 2
d1167 2
a1168 2
				dead = true;
				break;
d1186 5
d1201 2
d1204 2
a1205 2
			dead = true;
			break;
d1214 2
d1217 2
a1218 2
					dead = true;
					break;
d1227 2
a1229 1
	return !dead;
a1230 1

a2435 1
				SM_ASSERT(l >= 2);
@


1.16
log
@Update to sendmail.8.13.0
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: util.c,v 8.382 2004/03/26 19:01:10 ca Exp $")
d96 2
a97 1
**  STRIPBACKSLASH -- Strip leading backslash from a string.
@


1.15
log
@Update to sendmail 8.12.11.  I've been runninga beta version of this for
some time without problems.  See the RELEASE_NOTES for the change log.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: util.c,v 8.363.2.10 2003/10/15 17:19:14 ca Exp $")
d22 24
a94 1
#if _FFR_STRIPBACKSL
a122 1
#endif /* _FFR_STRIPBACKSL */
d565 1
d568 2
a574 1
	SM_FILE_T *pidf;
d579 1
a579 1
	sff = SFF_NOLINK|SFF_ROOTOK|SFF_REGONLY|SFF_CREAT;
d583 2
a584 2
	pidf = safefopen(pidpath, O_WRONLY|O_TRUNC, FileMode, sff);
	if (pidf == NULL)
d586 8
a593 2
		sm_syslog(LOG_ERR, NOQID, "unable to write %s: %s",
			  pidpath, sm_errstring(errno));
d597 1
a597 3
		pid_t pid;

		pid = getpid();
d600 2
a601 2
		(void) sm_io_fprintf(pidf, SM_TIME_DEFAULT, "%ld\n",
				     (long) pid);
d604 1
a604 1
		(void) sm_io_fprintf(pidf, SM_TIME_DEFAULT, "%s\n",
d607 8
a614 2
		/* flush and close */
		(void) sm_io_close(pidf, SM_TIME_DEFAULT);
d619 21
d696 1
d707 2
a708 1
printav(av)
d716 2
a717 2
			(void) sm_io_putc(smioout, SM_TIME_DEFAULT, ' ');
		xputs(*av++);
d719 1
a719 1
	(void) sm_io_putc(smioout, SM_TIME_DEFAULT, '\n');
d725 1
d736 2
a737 1
xputs(s)
d769 1
a769 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s<null>%s",
d777 1
a777 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s",
d785 1
a785 1
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d796 1
a796 1
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d800 1
a800 1
					(void) sm_io_putc(smioout,
d806 1
a806 1
					(void) sm_io_putc(smioout,
d810 1
a810 1
					(void) sm_io_fprintf(smioout,
d815 1
a815 1
					(void) sm_io_fprintf(smioout,
d825 1
a825 1
					(void) sm_io_fprintf(smioout,
d837 1
a837 1
					(void) sm_io_fprintf(smioout,
d842 1
a842 1
					(void) sm_io_fprintf(smioout,
d851 1
a851 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%sM-",
d859 1
a859 1
			(void) sm_io_putc(smioout, SM_TIME_DEFAULT, c);
d880 1
a880 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s",
d886 2
a887 2
			(void) sm_io_putc(smioout, SM_TIME_DEFAULT, '\\');
			(void) sm_io_putc(smioout, SM_TIME_DEFAULT, c);
d891 2
a892 2
			(void) sm_io_putc(smioout, SM_TIME_DEFAULT, '^');
			(void) sm_io_putc(smioout, SM_TIME_DEFAULT, c ^ 0100);
d896 1
a896 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s",
d898 1
a898 1
	(void) sm_io_flush(smioout, SM_TIME_DEFAULT);
d1759 1
a1759 1
**		logit -- if set, send output to syslog instead of stdout.
d1939 1
a1939 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s\n", buf);
a2006 1
	int i;
d2147 1
a2147 7
	for (i = 3; i < DtableSize; i++)
	{
		register int j;

		if ((j = fcntl(i, F_GETFD, 0)) != -1)
			(void) fcntl(i, F_SETFD, j | FD_CLOEXEC);
	}
d2524 6
a2529 5
	pid_t	proc_pid;
	char	*proc_task;
	int	proc_type;
	int	proc_count;
	int	proc_other;
d2536 1
a2536 1
proc_list_add(pid, task, type, count, other)
d2542 1
d2594 5
d2835 44
@


1.14
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: util.c,v 8.363.2.7 2003/06/02 03:25:39 gshapiro Exp $")
d2383 2
a2384 1
				(void) sm_snprintf(h, l, "%03o", (int) c);
@


1.13
log
@update to sendmail 8.12.7
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: util.c,v 8.363.2.5 2002/12/12 22:50:41 ca Exp $")
d393 1
a393 1
			*p++ = ':';
d2417 1
a2417 1
int
@


1.12
log
@sendmail 8.12.5
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: util.c,v 8.363.2.1 2002/06/21 20:25:25 ca Exp $")
d70 32
@


1.11
log
@Update to sendmail-8.12.4
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: util.c,v 8.363 2002/05/24 20:44:05 gshapiro Exp $")
d2242 34
@


1.10
log
@update to sendmail 8.12.3
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: util.c,v 8.360 2002/04/04 21:32:15 gshapiro Exp $")
d519 1
a519 1
	char pidpath[MAXPATHLEN + 1];
d527 1
a527 1
	pidf = safefopen(pidpath, O_WRONLY|O_TRUNC, 0644, sff);
d1922 1
a1922 1
	char buf[MAXLINE + 1];
@


1.9
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: util.c,v 8.357 2001/11/28 19:19:27 gshapiro Exp $")
d908 1
d942 2
d947 1
d949 2
d1106 2
a1107 1
		if (sm_io_fputs(mci->mci_out, SM_TIME_DEFAULT,
d1721 1
a1721 1
	i = fcntl(fd, F_GETFL, NULL);
@


1.8
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: util.c,v 8.352 2001/09/26 14:56:58 ca Exp $")
d314 1
a314 1
**		
d1150 1
d1156 1
d1162 1
d1475 1
d1485 2
a1486 1
strcontainedin(a, b)
d1497 1
a1497 1
	if (isascii(c) && isupper(c))
d1501 15
a1515 4
		if (*b != c && isascii(*b) && isupper(*b) && tolower(*b) != c)
			continue;
		if (sm_strncasecmp(a, b, la) == 0)
			return true;
d2311 7
d2506 1
a2506 1
**		count -- pointer to number of processes (return).
d2510 1
a2510 1
**		type of process
d2513 2
a2514 1
**		May decrease CurChildren.
d2521 2
a2522 2
int
proc_list_drop(pid, count, other)
d2524 1
a2524 1
	int *count;
a2535 2
			if (count != NULL)
				*count = ProcListVec[i].proc_count;
d2545 16
a2560 1
	return type;
@


1.7
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: util.c,v 8.347 2001/09/04 22:43:06 ca Exp $")
d21 1
a21 1
/*
d70 1
a70 1
/*
d128 1
a128 1
/*
d236 1
a236 1
/*
d305 26
d332 1
a332 1
/*
d375 1
a375 1
/*
d418 1
a418 1
/*
d461 1
a461 1
/*
d500 1
a500 1
/*
d553 1
a553 1
/*
d579 1
a579 1
/*
d605 1
a605 1
/*
d632 1
a632 1
/*
d809 1
a809 1
/*
d835 1
a835 1
/*
d870 1
a870 1
/*
d894 1
a894 1
/*
d1132 1
a1132 1
/*
d1162 1
a1162 1
/*
d1270 1
a1270 1
/*
d1359 1
a1359 1
/*
d1377 1
a1377 1
/*
d1398 1
a1398 1
/*
d1419 1
a1419 1
/*
d1444 1
a1444 1
/*
d1468 1
a1468 1
/*
d1503 1
a1503 1
/*
d1527 1
a1527 1
/*
d1553 1
a1553 1
/*
d1613 1
a1613 1
/*
d1638 1
a1638 1
/*
d1827 1
a1827 1
/*
d1874 1
a1874 1
/*
d2053 1
a2053 1
/*
d2126 1
a2126 1
/*
d2163 1
a2163 1
/*
d2219 1
a2219 1
/*
d2305 1
a2305 1
/*
d2354 1
a2354 1
/*
d2451 1
a2451 1
/*
d2478 1
a2478 1
/*
d2525 1
a2525 1
/*
d2548 1
a2548 1
/*
d2586 1
a2586 1
/*
@


1.6
log
@update to sendmail 8.11.5
@
text
@a13 4
#ifndef lint
static char id[] = "@@(#)$Sendmail: util.c,v 8.225.2.1.2.26 2001/06/01 08:23:25 gshapiro Exp $";
#endif /* ! lint */

a14 1
#include <sysexits.h>
d16 1
d18 2
a19 1
static void	readtimeout __P((time_t));
a21 38
**  STRIPQUOTES -- Strip quotes & quote bits from a string.
**
**	Runs through a string and strips off unquoted quote
**	characters and quote bits.  This is done in place.
**
**	Parameters:
**		s -- the string to strip.
**
**	Returns:
**		none.
**
**	Side Effects:
**		none.
*/

void
stripquotes(s)
	char *s;
{
	register char *p;
	register char *q;
	register char c;

	if (s == NULL)
		return;

	p = q = s;
	do
	{
		c = *p++;
		if (c == '\\')
			c = *p++;
		else if (c == '"')
			continue;
		*q++ = c;
	} while (c != '\0');
}
/*
d24 1
a24 1
**	Runs through a string and adds characters and quote bits.
d28 1
a31 4
**
**	Side Effects:
**		none.
**
d35 1
a35 1
addquotes(s)
d37 1
d54 1
a54 1
	q = r = xalloc(len + 3);
d81 1
a81 6
**		TRUE -- if the string is RFC822 compliant.
**		FALSE -- if the string is not RFC822 compliant.
**
**	Side Effects:
**		none.
**
d88 1
a88 1
	bool quoted = FALSE;
d93 1
a93 1
		return FALSE;
d102 1
a102 1
				return FALSE;
d112 1
a112 1
					return FALSE;
d120 1
a120 1
				return FALSE;
d124 1
d126 1
a126 4
	if (quoted || commentlev != 0)
		return FALSE;
	else
		return TRUE;
d139 1
a139 1
**		TRUE if string is changed, FALSE otherwise
d151 3
a153 3
	bool backslash = FALSE;
	bool modified = FALSE;
	bool quoted = FALSE;
d171 1
a171 1
			backslash = FALSE;
d176 1
a176 1
			backslash = TRUE;
d200 1
a200 1
				backslash = FALSE;
d204 1
a204 1
				quoted = FALSE;
d215 1
a215 1
			modified = TRUE;
d224 1
a224 1
			modified = TRUE;
d231 1
a231 1
		modified = TRUE;
d257 2
a258 2
	bool backslash = FALSE;
	bool quoted = FALSE;
d265 1
a265 1
			backslash = FALSE;
d274 1
a274 1
			backslash = TRUE;
d305 1
d307 1
a307 4
**  XALLOC -- Allocate memory and bitch wildly on failure.
**
**	THIS IS A CLUDGE.  This should be made to give a proper
**	error -- but after all, what can we do?
d310 3
a312 1
**		sz -- size of area to allocate.
d315 1
a315 4
**		pointer to data region.
**
**	Side Effects:
**		Memory is allocated.
d318 5
a322 3
char *
xalloc(sz)
	register int sz;
d324 1
a324 1
	register char *p;
d326 2
a327 3
	/* some systems can't handle size zero mallocs */
	if (sz <= 0)
		sz = 1;
d329 2
a330 4
	ENTER_CRITICAL();
	p = malloc((unsigned) sz);
	LEAVE_CRITICAL();
	if (p == NULL)
d332 9
a340 1
		syserr("!Out of memory!!");
d342 5
a346 4
		/* NOTREACHED */
		exit(EX_UNAVAILABLE);
	}
	return p;
d348 1
d350 1
a350 4
**  XREALLOC -- Reallocate memory and bitch wildly on failure.
**
**	THIS IS A CLUDGE.  This should be made to give a proper
**	error -- but after all, what can we do?
d353 1
a353 2
**		ptr -- original area.
**		sz -- size of new area to allocate.
d358 3
d366 9
a374 3
xrealloc(ptr, sz)
	void *ptr;
	size_t sz;
d382 2
a383 35
	ENTER_CRITICAL();
	p = realloc(ptr, (unsigned) sz);
	LEAVE_CRITICAL();
	if (p == NULL)
	{
		syserr("!Out of memory!!");

		/* NOTREACHED */
		exit(EX_UNAVAILABLE);
	}
	return p;
}
/*
**  XCALLOC -- Allocate memory and bitch wildly on failure.
**
**	THIS IS A CLUDGE.  This should be made to give a proper
**	error -- but after all, what can we do?
**
**	Parameters:
**		num -- number of items to allocate
**		sz -- size of new area to allocate.
**
**	Returns:
**		pointer to data region.
**
**	Side Effects:
**		Memory is allocated.
*/

char *
xcalloc(num, sz)
	size_t num;
	size_t sz;
{
	register char *p;
d385 1
a385 9
	/* some systems can't handle size zero mallocs */
	if (num <= 0)
		num = 1;
	if (sz <= 0)
		sz = 1;

	ENTER_CRITICAL();
	p = calloc((unsigned) num, (unsigned) sz);
	LEAVE_CRITICAL();
d388 1
a388 4
		syserr("!Out of memory!!");

		/* NOTREACHED */
		exit(EX_UNAVAILABLE);
a392 21
**  SM_FREE -- Free memory safely.
**
**	Parameters:
**		ptr -- area to free
**
**	Returns:
**		none.
**
**	Side Effects:
**		Memory is freed.
*/

void
sm_free(ptr)
	void *ptr;
{
	ENTER_CRITICAL();
	free(ptr);
	LEAVE_CRITICAL();
}
/*
d395 1
a395 1
**	This routine is the equivalent of newstr for lists of
d401 1
a401 1
**		copycont -- if TRUE, copy the contents of the vector
d403 2
a407 3
**
**	Side Effects:
**		none.
d411 1
a411 1
copyplist(list, copycont)
d414 1
d424 1
a424 1
	newvp = (char **) xalloc((int) (vp - list) * sizeof *vp);
d430 1
a430 1
			*vp = newstr(*vp);
d438 1
a438 1
**	This routine is the equivalent of newstr for address queues
d443 1
a446 3
**
**	Side Effects:
**		none.
d450 1
a450 1
copyqueue(addr)
d452 1
d462 2
a463 1
			newaddr = (ADDRESS *) xalloc(sizeof *newaddr);
d484 1
a484 1
**		writes pidfile.
d492 1
a492 1
	FILE *pidf;
d494 1
d505 1
a505 1
			  pidpath, errstring(errno));
a509 1
		extern char *CommandLineArgs;
d514 2
a515 1
		fprintf(pidf, "%ld\n", (long) pid);
d518 2
a519 1
		fprintf(pidf, "%s\n", CommandLineArgs);
d522 1
a522 1
		(void) fclose(pidf);
d524 2
d538 1
a538 1
**		sets $&{deliveryMode} macro
d548 2
a549 2
	e->e_sendmode = (char)mode;
	buf[0] = (char)mode;
d551 27
a577 1
	define(macid("{deliveryMode}", NULL), newstr(buf), e);
d599 1
a599 1
			dprintf("\n\t%08lx=", (u_long) *av);
d601 1
a601 1
			(void) putchar(' ');
d604 1
a604 20
	(void) putchar('\n');
}
/*
**  LOWER -- turn letter into lower case.
**
**	Parameters:
**		c -- character to turn into lower case.
**
**	Returns:
**		c, in lower case.
**
**	Side Effects:
**		none.
*/

char
lower(c)
	register int c;
{
	return ((isascii(c) && isupper(c)) ? tolower(c) : c);
d625 1
a625 1
	bool shiftout = FALSE;
d627 22
d652 2
a653 1
		printf("%s<null>%s", TermEscape.te_rv_on, TermEscape.te_rv_off);
d660 3
a662 2
			printf("%s", TermEscape.te_rv_off);
			shiftout = FALSE;
d668 4
a671 2
				printf("%s$", TermEscape.te_rv_on);
				shiftout = TRUE;
d679 3
a681 1
				printf("%s$", TermEscape.te_rv_on);
d683 3
a685 2
					(void) putchar('&');
				shiftout = TRUE;
d689 3
a691 1
					(void) putchar(*s++);
d693 4
a696 1
					printf("{%s}", macname(bitidx(*s++)));
d698 4
a701 1
					printf("%c", *s++);
d706 1
a706 1
				if ((mp->metaval & 0377) == c)
d708 6
a713 4
					printf("%s$%c",
						TermEscape.te_rv_on,
						mp->metaname);
					shiftout = TRUE;
d720 4
a723 1
					printf("{%s}", macname(*s++ & 0377));
d725 4
a728 1
					printf("%c", *s++);
d734 3
a736 2
			printf("%sM-", TermEscape.te_rv_on);
			shiftout = TRUE;
d742 1
a742 1
			(void) putchar(c);
d763 3
a765 2
			printf("%s", TermEscape.te_rv_on);
			shiftout = TRUE;
d769 2
a770 2
			(void) putchar('\\');
			(void) putchar(c);
d774 2
a775 2
			(void) putchar('^');
			(void) putchar(c ^ 0100);
d779 3
a781 2
		printf("%s", TermEscape.te_rv_off);
	(void) fflush(stdout);
a809 53
**  BUILDFNAME -- build full name from gecos style entry.
**
**	This routine interprets the strange entry that would appear
**	in the GECOS field of the password file.
**
**	Parameters:
**		p -- name to build.
**		user -- the login name of this user (for &).
**		buf -- place to put the result.
**		buflen -- length of buf.
**
**	Returns:
**		none.
**
**	Side Effects:
**		none.
*/

void
buildfname(gecos, user, buf, buflen)
	register char *gecos;
	char *user;
	char *buf;
	int buflen;
{
	register char *p;
	register char *bp = buf;

	if (*gecos == '*')
		gecos++;

	/* copy gecos, interpolating & to be full name */
	for (p = gecos; *p != '\0' && *p != ',' && *p != ';' && *p != '%'; p++)
	{
		if (bp >= &buf[buflen - 1])
		{
			/* buffer overflow -- just use login name */
			snprintf(buf, buflen, "%s", user);
			return;
		}
		if (*p == '&')
		{
			/* interpolate full name */
			snprintf(bp, buflen - (bp - buf), "%s", user);
			*bp = toupper(*bp);
			bp += strlen(bp);
		}
		else
			*bp++ = *p;
	}
	*bp = '\0';
}
/*
d858 1
a858 1
**		output of l to fp.
d887 1
a887 1
**		output of l to fp.
d897 1
a897 1
	bool dead = FALSE;
d921 2
a922 1
			fprintf(TrafficLogFile, "%05d >>> ", (int) getpid());
d934 3
a936 2
				if (putc('.', mci->mci_out) == EOF)
					dead = TRUE;
d940 1
a940 1
					DataProgress = TRUE;
d943 2
a944 1
					(void) putc('.', TrafficLogFile);
d951 3
a953 2
				if (putc('>', mci->mci_out) == EOF)
					dead = TRUE;
d957 1
a957 1
					DataProgress = TRUE;
d960 3
a962 1
					(void) putc('>', TrafficLogFile);
d969 2
a970 2
				if (putc((unsigned char) *l++, mci->mci_out) ==
				    EOF)
d972 1
a972 1
					dead = TRUE;
d978 1
a978 1
					DataProgress = TRUE;
d984 7
a990 4
			if (putc('!', mci->mci_out) == EOF ||
			    fputs(mci->mci_mailer->m_eol,
				  mci->mci_out) == EOF ||
			    putc(' ', mci->mci_out) == EOF)
d992 1
a992 1
				dead = TRUE;
d998 1
a998 1
				DataProgress = TRUE;
d1003 7
a1009 4
					(void) putc((unsigned char)*l,
						    TrafficLogFile);
				fprintf(TrafficLogFile, "!\n%05d >>>  ",
					(int) getpid());
d1021 2
a1022 1
			if (putc('.', mci->mci_out) == EOF)
d1027 1
a1027 1
				DataProgress = TRUE;
d1030 2
a1031 1
				(void) putc('.', TrafficLogFile);
d1038 2
a1039 1
			if (putc('>', mci->mci_out) == EOF)
d1044 1
a1044 1
				DataProgress = TRUE;
d1047 2
a1048 1
				(void) putc('>', TrafficLogFile);
d1053 5
a1057 2
				(void) putc((unsigned char)*l, TrafficLogFile);
			if (putc((unsigned char) *l, mci->mci_out) == EOF)
d1059 1
a1059 1
				dead = TRUE;
d1065 1
a1065 1
				DataProgress = TRUE;
d1072 4
a1075 2
			(void) putc('\n', TrafficLogFile);
		if (fputs(mci->mci_mailer->m_eol, mci->mci_out) == EOF)
d1080 1
a1080 1
			DataProgress = TRUE;
d1087 2
a1088 1
				if (putc(' ', mci->mci_out) == EOF)
d1093 1
a1093 1
					DataProgress = TRUE;
d1095 1
d1097 2
a1098 1
					(void) putc(' ', TrafficLogFile);
d1101 3
d1113 1
a1113 1
**		none.
d1119 1
a1119 1
void
d1126 1
a1126 3
		sm_syslog(LOG_DEBUG, CurEnv->e_id,
			  "unlink %s",
			  f);
d1130 1
a1130 2
		sm_syslog(LOG_DEBUG, CurEnv->e_id,
			  "%s: unlink-fail %d",
d1132 3
d1147 1
a1147 1
**		NULL on error (including timeout).  This will also leave
a1149 3
**
**	Side Effects:
**		none.
a1152 2
static jmp_buf	CtxReadTimeout;

d1157 1
a1157 1
	FILE *fp;
a1160 1
	register EVENT *ev = NULL;
d1163 4
d1171 1
d1175 7
a1181 2
	/* set the timeout */
	if (timeout != 0)
d1183 3
a1185 1
		if (setjmp(CtxReadTimeout) != 0)
d1187 1
d1191 1
a1191 1
					  CurHostName ? CurHostName : "local",
d1198 5
a1202 3
				fprintf(TrafficLogFile, "%05d <<< [TIMEOUT]\n",
					(int) getpid());
			errno = 0;
a1204 10
		ev = setevent(timeout, readtimeout, 0);
	}

	/* try to read */
	p = NULL;
	errno = 0;
	while (!feof(fp) && !ferror(fp))
	{
		errno = 0;
		p = fgets(buf, siz, fp);
d1207 1
a1207 1
		clearerr(fp);
a1210 3
	/* clear the event if it has not sprung */
	clrevent(ev);

d1217 3
a1219 1
			fprintf(TrafficLogFile, "%05d <<< [EOF]\n", (int) getpid());
d1224 2
a1225 1
		fprintf(TrafficLogFile, "%05d <<< %s", (int) getpid(), buf);
d1237 1
a1237 1
				HasEightBits = TRUE;
a1243 15

/* ARGSUSED */
static void
readtimeout(timeout)
	time_t timeout;
{
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
	longjmp(CtxReadTimeout, 1);
}
d1245 1
a1245 1
**  FGETFOLDED -- like fgets, but know about folded lines.
d1253 1
a1253 1
**		input line(s) on success, NULL on error or EOF.
d1255 1
a1255 1
**			long, when it will be xalloc()ed.
d1267 1
a1267 1
	FILE *f;
d1273 9
d1283 1
a1283 1
	while ((i = getc(f)) != EOF)
d1287 1
a1287 1
			i = getc(f);
d1290 3
a1292 2
				if (i != EOF)
					(void) ungetc(i, f);
d1307 1
a1307 1
			nbp = xalloc(nn);
d1319 3
a1321 3
			i = getc(f);
			if (i != EOF)
				(void) ungetc(i, f);
a1340 3
**
**	Side Effects:
**		none.
d1354 1
a1354 1
**	Defaults to "TRUE"
d1357 1
a1357 1
**		s -- string to convert.  Takes "tTyY" as true,
a1361 3
**
**	Side Effects:
**		none.
d1369 2
a1370 2
		return TRUE;
	return FALSE;
a1380 3
**
**	Side Effects:
**		none.
d1400 2
a1401 5
**		TRUE if they have a non-null intersection
**		FALSE otherwise
**
**	Side Effects:
**		none.
d1414 1
a1414 1
			return TRUE;
d1416 1
a1416 1
	return FALSE;
d1425 2
a1426 5
**		TRUE if map is all zero.
**		FALSE if there are any bits set in map.
**
**	Side Effects:
**		none.
d1438 1
a1438 1
			return FALSE;
d1440 1
a1440 1
	return TRUE;
d1450 2
a1451 2
**		TRUE if a is contained in b.
**		FALSE otherwise.
d1472 2
a1473 2
		if (strncasecmp(a, b, la) == 0)
			return TRUE;
d1475 1
a1475 1
	return FALSE;
d1523 1
a1523 1
		printopenfds(TRUE);
d1546 1
a1546 1
	bool printhdr = TRUE;
d1581 1
a1581 1
			printhdr = FALSE;
d1583 1
a1583 1
		dumpfd(fd, TRUE, TRUE);
d1610 1
a1610 1
		dumpfd(fd, FALSE, logit);
d1620 3
d1646 1
a1646 1
	snprintf(p, SPACELEFT(buf, p), "%3d: ", fd);
d1659 3
a1661 2
			snprintf(p, SPACELEFT(buf, p), "CANNOT STAT (%s)",
				errstring(errno));
d1666 1
a1666 1
			snprintf(p, SPACELEFT(buf, p), "CLOSED");
d1675 1
a1675 1
		snprintf(p, SPACELEFT(buf, p), "fl=0x%x, ", i);
d1679 2
a1680 1
	snprintf(p, SPACELEFT(buf, p), "mode=%o: ", (int) st.st_mode);
d1686 1
a1686 1
		snprintf(p, SPACELEFT(buf, p), "SOCK ");
d1691 2
a1692 2
			snprintf(p, SPACELEFT(buf, p), "(%s)",
				 errstring(errno));
d1703 2
a1704 2
				snprintf(p, SPACELEFT(buf, p), "%s/%d",
					 hp, ntohs(sa.sin.sin_port));
d1708 2
a1709 2
				snprintf(p, SPACELEFT(buf, p), "%s/%d",
					 hp, ntohs(sa.sin6.sin6_port));
d1712 2
a1713 1
				snprintf(p, SPACELEFT(buf, p), "%s", hp);
d1716 1
a1716 1
		snprintf(p, SPACELEFT(buf, p), "->");
d1720 2
a1721 1
			snprintf(p, SPACELEFT(buf, p), "(%s)", errstring(errno));
d1732 2
a1733 2
				snprintf(p, SPACELEFT(buf, p), "%s/%d",
					 hp, ntohs(sa.sin.sin_port));
d1737 2
a1738 2
				snprintf(p, SPACELEFT(buf, p), "%s/%d",
					 hp, ntohs(sa.sin6.sin6_port));
d1741 2
a1742 1
				snprintf(p, SPACELEFT(buf, p), "%s", hp);
d1748 1
a1748 1
		snprintf(p, SPACELEFT(buf, p), "CHR: ");
d1752 1
d1754 1
a1754 1
		snprintf(p, SPACELEFT(buf, p), "BLK: ");
d1757 1
d1761 1
a1761 1
		snprintf(p, SPACELEFT(buf, p), "FIFO: ");
d1768 1
a1768 1
		snprintf(p, SPACELEFT(buf, p), "DIR: ");
d1775 1
a1775 1
		snprintf(p, SPACELEFT(buf, p), "LNK: ");
d1782 9
a1790 22
		/*CONSTCOND*/
		if (sizeof st.st_ino > sizeof (long))
			snprintf(p, SPACELEFT(buf, p),
				 "dev=%d/%d, ino=%s, nlink=%d, u/gid=%d/%d, ",
				 major(st.st_dev), minor(st.st_dev),
				 quad_to_string(st.st_ino),
				 (int) st.st_nlink, (int) st.st_uid,
				 (int) st.st_gid);
		else
			snprintf(p, SPACELEFT(buf, p),
				 "dev=%d/%d, ino=%lu, nlink=%d, u/gid=%d/%d, ",
				 major(st.st_dev), minor(st.st_dev),
				 (unsigned long) st.st_ino,
				 (int) st.st_nlink, (int) st.st_uid,
				 (int) st.st_gid);
		/*CONSTCOND*/
		if (sizeof st.st_size > sizeof (long))
			snprintf(p, SPACELEFT(buf, p), "size=%s",
				 quad_to_string(st.st_size));
		else
			snprintf(p, SPACELEFT(buf, p), "size=%lu",
				 (unsigned long) st.st_size);
d1799 1
a1799 1
		printf("%s\n", buf);
d1808 1
a1808 1
**		place where string was trunacted, NULL if not truncated.
d1818 1
a1818 1
	bool canon = FALSE;
d1821 2
a1822 1
	p = &host[strlen(host) - 1];
d1826 1
a1826 1
		canon = TRUE;
d1839 3
a1841 2
	if ((canon ? strcasecmp(p, mydom) : strncasecmp(p, mydom, i)) == 0 &&
	    (mydom[i] == '.' || mydom[i] == '\0'))
d1869 2
a1896 3
	/* child -- close stdin */
	(void) close(0);

d1899 1
d1902 11
d1928 1
a1928 1
		xfd = fileno(e->e_xfp);
d1938 1
a1938 1
		(void) close(fileno(e->e_lockfp));
d1958 1
d1993 14
d2056 2
a2057 2
	if ((char)delim == '\0')
		(void) strlcpy(delimbuf, "\n\t ", sizeof delimbuf);
d2060 1
a2060 1
		delimbuf[0] = (char)delim;
d2067 1
a2067 1
	if (*p == (char)delim && col == 0)
d2072 1
a2072 1
	if (col == 0 && (char)delim == '\0')
d2083 1
a2083 1
		if ((char)delim == '\0')
d2097 1
a2097 1
	(void) strlcpy(buf, begin, i + 1);
d2119 1
a2119 1
	(void) denlstring(f, TRUE, TRUE);
a2136 1

d2172 2
d2176 1
a2176 1
		bp = xalloc(l);
d2179 1
a2179 1
	(void) strlcpy(bp, s, l);
d2194 86
d2291 2
a2292 2
**		TRUE -- if the indicated pathname is a directory
**		FALSE -- otherwise
d2309 1
a2309 1
			return FALSE;
d2311 2
a2312 2
			return FALSE;
		return TRUE;
d2317 1
a2317 1
		return FALSE;
d2324 1
a2324 1
		return FALSE;
d2326 1
a2326 2

	return TRUE;
d2335 2
d2340 3
d2345 13
a2357 2
static struct procs	*volatile ProcListVec = NULL;
static int		ProcListSize = 0;
d2360 1
a2360 1
proc_list_add(pid, task, type)
d2364 2
d2389 1
a2389 1
		struct procs *npv;
d2391 3
a2393 2
		npv = (struct procs *) xalloc((sizeof *npv) *
					      (ProcListSize + PROC_LIST_SEG));
d2397 1
a2397 1
				ProcListSize * sizeof (struct procs));
d2400 2
d2413 1
a2413 3
	if (ProcListVec[i].proc_task != NULL)
		sm_free(ProcListVec[i].proc_task);
	ProcListVec[i].proc_task = newstr(task);
d2415 2
d2419 3
a2421 1
	if (pid != getpid())
d2423 1
d2447 1
a2447 3
			if (ProcListVec[i].proc_task != NULL)
				sm_free(ProcListVec[i].proc_task);
			ProcListVec[i].proc_task = newstr(task);
d2457 2
d2463 3
d2472 1
a2472 1
proc_list_drop(pid)
d2474 2
d2486 4
d2507 3
a2518 1
	{
a2519 1
	}
d2530 3
d2552 1
d2559 1
d2565 1
d2572 3
a2574 2
proc_list_display(out)
	FILE *out;
d2583 8
a2590 6
		fprintf(out, "%d %s%s\n", (int) ProcListVec[i].proc_pid,
			ProcListVec[i].proc_task != NULL ?
			ProcListVec[i].proc_task : "(unknown)",
			(OpMode == MD_SMTP ||
			 OpMode == MD_DAEMON ||
			 OpMode == MD_ARPAFTP) ? "\r" : "");
d2593 3
a2595 2
/*
**  SAFEFOPEN -- do a file open with extra checking
d2598 2
a2599 4
**		fn -- the file name to open.
**		omode -- the open-style mode flags.
**		cmode -- the create-style mode flags.
**		sff -- safefile flags.
d2601 6
a2606 2
**	Returns:
**		Same as fopen.
d2609 4
a2612 6
FILE *
safefopen(fn, omode, cmode, sff)
	char *fn;
	int omode;
	int cmode;
	long sff;
d2614 4
a2617 4
	int fd;
	int save_errno;
	FILE *fp;
	char *fmode;
d2619 3
a2621 5
	switch (omode & O_ACCMODE)
	{
	  case O_RDONLY:
		fmode = "r";
		break;
d2623 2
a2624 22
	  case O_WRONLY:
		if (bitset(O_APPEND, omode))
			fmode = "a";
		else
			fmode = "w";
		break;

	  case O_RDWR:
		if (bitset(O_TRUNC, omode))
			fmode = "w+";
		else if (bitset(O_APPEND, omode))
			fmode = "a+";
		else
			fmode = "r+";
		break;

	  default:
		syserr("554 5.3.5 safefopen: unknown omode %o", omode);
		fmode = "x";
	}
	fd = safeopen(fn, omode, cmode, sff);
	if (fd < 0)
d2626 6
a2631 16
		save_errno = errno;
		if (tTd(44, 10))
			dprintf("safefopen: safeopen failed: %s\n",
				errstring(errno));
		errno = save_errno;
		return NULL;
	}
	fp = fdopen(fd, fmode);
	if (fp != NULL)
		return fp;

	save_errno = errno;
	if (tTd(44, 10))
	{
		dprintf("safefopen: fdopen(%s, %s) failed: omode=%x, sff=%lx, err=%s\n",
			fn, fmode, omode, sff, errstring(errno));
a2632 9
	(void) close(fd);
	errno = save_errno;
	return NULL;
}
/*
**  SM_STRCASECMP -- 8-bit clean version of strcasecmp
**
**	Thank you, vendors, for making this all necessary.
*/
d2634 5
a2638 109
/*
 * Copyright (c) 1987, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#if defined(LIBC_SCCS) && !defined(lint)
static char sccsid[] = "@@(#)strcasecmp.c	8.1 (Berkeley) 6/4/93";
#endif /* defined(LIBC_SCCS) && !defined(lint) */

/*
 * This array is designed for mapping upper and lower case letter
 * together for a case independent comparison.  The mappings are
 * based upon ascii character sequences.
 */
static const u_char charmap[] = {
	0000, 0001, 0002, 0003, 0004, 0005, 0006, 0007,
	0010, 0011, 0012, 0013, 0014, 0015, 0016, 0017,
	0020, 0021, 0022, 0023, 0024, 0025, 0026, 0027,
	0030, 0031, 0032, 0033, 0034, 0035, 0036, 0037,
	0040, 0041, 0042, 0043, 0044, 0045, 0046, 0047,
	0050, 0051, 0052, 0053, 0054, 0055, 0056, 0057,
	0060, 0061, 0062, 0063, 0064, 0065, 0066, 0067,
	0070, 0071, 0072, 0073, 0074, 0075, 0076, 0077,
	0100, 0141, 0142, 0143, 0144, 0145, 0146, 0147,
	0150, 0151, 0152, 0153, 0154, 0155, 0156, 0157,
	0160, 0161, 0162, 0163, 0164, 0165, 0166, 0167,
	0170, 0171, 0172, 0133, 0134, 0135, 0136, 0137,
	0140, 0141, 0142, 0143, 0144, 0145, 0146, 0147,
	0150, 0151, 0152, 0153, 0154, 0155, 0156, 0157,
	0160, 0161, 0162, 0163, 0164, 0165, 0166, 0167,
	0170, 0171, 0172, 0173, 0174, 0175, 0176, 0177,
	0200, 0201, 0202, 0203, 0204, 0205, 0206, 0207,
	0210, 0211, 0212, 0213, 0214, 0215, 0216, 0217,
	0220, 0221, 0222, 0223, 0224, 0225, 0226, 0227,
	0230, 0231, 0232, 0233, 0234, 0235, 0236, 0237,
	0240, 0241, 0242, 0243, 0244, 0245, 0246, 0247,
	0250, 0251, 0252, 0253, 0254, 0255, 0256, 0257,
	0260, 0261, 0262, 0263, 0264, 0265, 0266, 0267,
	0270, 0271, 0272, 0273, 0274, 0275, 0276, 0277,
	0300, 0301, 0302, 0303, 0304, 0305, 0306, 0307,
	0310, 0311, 0312, 0313, 0314, 0315, 0316, 0317,
	0320, 0321, 0322, 0323, 0324, 0325, 0326, 0327,
	0330, 0331, 0332, 0333, 0334, 0335, 0336, 0337,
	0340, 0341, 0342, 0343, 0344, 0345, 0346, 0347,
	0350, 0351, 0352, 0353, 0354, 0355, 0356, 0357,
	0360, 0361, 0362, 0363, 0364, 0365, 0366, 0367,
	0370, 0371, 0372, 0373, 0374, 0375, 0376, 0377,
};

int
sm_strcasecmp(s1, s2)
	const char *s1, *s2;
{
	register const u_char *cm = charmap,
			*us1 = (const u_char *)s1,
			*us2 = (const u_char *)s2;

	while (cm[*us1] == cm[*us2++])
		if (*us1++ == '\0')
			return 0;
	return (cm[*us1] - cm[*--us2]);
}

int
sm_strncasecmp(s1, s2, n)
	const char *s1, *s2;
	register size_t n;
{
	if (n != 0) {
		register const u_char *cm = charmap,
				*us1 = (const u_char *)s1,
				*us2 = (const u_char *)s2;

		do {
			if (cm[*us1] != cm[*us2++])
				return (cm[*us1] - cm[*--us2]);
			if (*us1++ == '\0')
				break;
		} while (--n != 0);
	}
	return 0;
@


1.5
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: util.c,v 8.225.2.1.2.23 2001/05/17 18:10:18 gshapiro Exp $";
d2530 75
@


1.4
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: util.c,v 8.225.2.1.2.19 2001/02/22 18:56:24 gshapiro Exp $";
d381 1
d383 1
d387 43
a429 1
		/* exit(EX_UNAVAILABLE); */
d434 63
d612 1
a612 1
		long pid;
d615 1
a615 1
		pid = (long) getpid();
d618 1
a618 1
		fprintf(pidf, "%ld\n", pid);
d1322 7
d1388 1
a1388 1
				free(bp);
d1953 1
a1953 1
int
d1959 1
a1959 1
	int pid;
d1991 5
d2241 1
a2241 1
			free(bp);
d2321 1
a2321 1
static struct procs	*ProcListVec = NULL;
d2360 1
a2360 1
			free(ProcListVec);
d2374 1
a2374 1
		free(ProcListVec[i].proc_task);
d2405 1
a2405 1
				free(ProcListVec[i].proc_task);
d2419 4
@


1.4.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: util.c,v 8.225.2.1.2.23 2001/05/17 18:10:18 gshapiro Exp $";
a380 1
	ENTER_CRITICAL();
a381 1
	LEAVE_CRITICAL();
d385 1
a385 43

		/* NOTREACHED */
		exit(EX_UNAVAILABLE);
	}
	return p;
}
/*
**  XREALLOC -- Reallocate memory and bitch wildly on failure.
**
**	THIS IS A CLUDGE.  This should be made to give a proper
**	error -- but after all, what can we do?
**
**	Parameters:
**		ptr -- original area.
**		sz -- size of new area to allocate.
**
**	Returns:
**		pointer to data region.
**
**	Side Effects:
**		Memory is allocated.
*/

char *
xrealloc(ptr, sz)
	void *ptr;
	size_t sz;
{
	register char *p;

	/* some systems can't handle size zero mallocs */
	if (sz <= 0)
		sz = 1;

	ENTER_CRITICAL();
	p = realloc(ptr, (unsigned) sz);
	LEAVE_CRITICAL();
	if (p == NULL)
	{
		syserr("!Out of memory!!");

		/* NOTREACHED */
		exit(EX_UNAVAILABLE);
a389 63
**  XCALLOC -- Allocate memory and bitch wildly on failure.
**
**	THIS IS A CLUDGE.  This should be made to give a proper
**	error -- but after all, what can we do?
**
**	Parameters:
**		num -- number of items to allocate
**		sz -- size of new area to allocate.
**
**	Returns:
**		pointer to data region.
**
**	Side Effects:
**		Memory is allocated.
*/

char *
xcalloc(num, sz)
	size_t num;
	size_t sz;
{
	register char *p;

	/* some systems can't handle size zero mallocs */
	if (num <= 0)
		num = 1;
	if (sz <= 0)
		sz = 1;

	ENTER_CRITICAL();
	p = calloc((unsigned) num, (unsigned) sz);
	LEAVE_CRITICAL();
	if (p == NULL)
	{
		syserr("!Out of memory!!");

		/* NOTREACHED */
		exit(EX_UNAVAILABLE);
	}
	return p;
}
/*
**  SM_FREE -- Free memory safely.
**
**	Parameters:
**		ptr -- area to free
**
**	Returns:
**		none.
**
**	Side Effects:
**		Memory is freed.
*/

void
sm_free(ptr)
	void *ptr;
{
	ENTER_CRITICAL();
	free(ptr);
	LEAVE_CRITICAL();
}
/*
d505 1
a505 1
		pid_t pid;
d508 1
a508 1
		pid = getpid();
d511 1
a511 1
		fprintf(pidf, "%ld\n", (long) pid);
a1214 7
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
d1274 1
a1274 1
				sm_free(bp);
d1839 1
a1839 1
pid_t
d1845 1
a1845 1
	pid_t pid;
a1876 5
	/* Reset global flags */
	RestartRequest = NULL;
	ShutdownRequest = NULL;
	PendingSignal = 0;

d2122 1
a2122 1
			sm_free(bp);
d2202 1
a2202 1
static struct procs	*volatile ProcListVec = NULL;
d2241 1
a2241 1
			sm_free(ProcListVec);
d2255 1
a2255 1
		sm_free(ProcListVec[i].proc_task);
d2286 1
a2286 1
				sm_free(ProcListVec[i].proc_task);
a2299 4
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: util.c,v 8.225.2.1.2.15 2000/10/18 23:46:07 ca Exp $";
d500 2
a501 1
		sm_syslog(LOG_ERR, NOQID, "unable to write %s", pidpath);
d1789 1
a1789 1
**		none.
d1792 1
a1792 1
void
d1812 1
a1812 1
		return;
d1821 1
d1823 3
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d2 1
a2 1
 * Copyright (c) 1998, 1999 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: util.c,v 8.225 2000/03/28 21:55:22 ca Exp $";
d21 1
d212 1
d244 1
a244 1
		if (length - (ptr - string) <= ((backslash ? 1 : 0) +
d504 1
d507 2
d510 1
a510 1
		fprintf(pidf, "%ld\n", (long) getpid());
d647 1
a647 1
					printf("{%s}", macname(*s++ & 0377));
d925 5
d940 5
d953 2
a954 1
				if (putc(*l++, mci->mci_out) == EOF)
d959 5
a963 3

				/* record progress for DATA timeout */
				DataProgress = TRUE;
d976 5
a980 4

			/* record progress for DATA timeout */
			DataProgress = TRUE;

d984 2
a985 1
					(void) putc(*l, TrafficLogFile);
d1001 5
d1016 5
d1027 2
a1028 2
				(void) putc(*l, TrafficLogFile);
			if (putc(*l, mci->mci_out) == EOF)
d1033 5
a1037 3

			/* record progress for DATA timeout */
			DataProgress = TRUE;
d1046 5
d1058 5
a1066 3

		/* record progress for DATA timeout */
		DataProgress = TRUE;
d1118 1
d1386 1
d1389 1
d1413 1
d1416 1
d1528 2
a1529 2
	if (DtableSize > 256)
		maxfd = 256;
d1903 1
d1905 2
d1908 1
d1910 2
d1917 1
d1919 2
d1922 1
d1924 2
d2315 2
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: util.c,v 8.225.2.1.2.23 2001/05/17 18:10:18 gshapiro Exp $";
a20 1

a210 1

d242 1
a242 1
		if (length - (ptr - string) <= (size_t) ((backslash ? 1 : 0) +
a378 1
	ENTER_CRITICAL();
a379 1
	LEAVE_CRITICAL();
d383 1
a383 3

		/* NOTREACHED */
		exit(EX_UNAVAILABLE);
a387 103
**  XREALLOC -- Reallocate memory and bitch wildly on failure.
**
**	THIS IS A CLUDGE.  This should be made to give a proper
**	error -- but after all, what can we do?
**
**	Parameters:
**		ptr -- original area.
**		sz -- size of new area to allocate.
**
**	Returns:
**		pointer to data region.
**
**	Side Effects:
**		Memory is allocated.
*/

char *
xrealloc(ptr, sz)
	void *ptr;
	size_t sz;
{
	register char *p;

	/* some systems can't handle size zero mallocs */
	if (sz <= 0)
		sz = 1;

	ENTER_CRITICAL();
	p = realloc(ptr, (unsigned) sz);
	LEAVE_CRITICAL();
	if (p == NULL)
	{
		syserr("!Out of memory!!");

		/* NOTREACHED */
		exit(EX_UNAVAILABLE);
	}
	return p;
}
/*
**  XCALLOC -- Allocate memory and bitch wildly on failure.
**
**	THIS IS A CLUDGE.  This should be made to give a proper
**	error -- but after all, what can we do?
**
**	Parameters:
**		num -- number of items to allocate
**		sz -- size of new area to allocate.
**
**	Returns:
**		pointer to data region.
**
**	Side Effects:
**		Memory is allocated.
*/

char *
xcalloc(num, sz)
	size_t num;
	size_t sz;
{
	register char *p;

	/* some systems can't handle size zero mallocs */
	if (num <= 0)
		num = 1;
	if (sz <= 0)
		sz = 1;

	ENTER_CRITICAL();
	p = calloc((unsigned) num, (unsigned) sz);
	LEAVE_CRITICAL();
	if (p == NULL)
	{
		syserr("!Out of memory!!");

		/* NOTREACHED */
		exit(EX_UNAVAILABLE);
	}
	return p;
}
/*
**  SM_FREE -- Free memory safely.
**
**	Parameters:
**		ptr -- area to free
**
**	Returns:
**		none.
**
**	Side Effects:
**		Memory is freed.
*/

void
sm_free(ptr)
	void *ptr;
{
	ENTER_CRITICAL();
	free(ptr);
	LEAVE_CRITICAL();
}
/*
d498 1
a498 2
		sm_syslog(LOG_ERR, NOQID, "unable to write %s: %s",
			  pidpath, errstring(errno));
a501 1
		pid_t pid;
a503 2
		pid = getpid();

d505 1
a505 1
		fprintf(pidf, "%ld\n", (long) pid);
d642 1
a642 1
					printf("{%s}", macname(bitidx(*s++)));
a919 5
				else
				{
					/* record progress for DATA timeout */
					DataProgress = TRUE;
				}
a929 5
				else
				{
					/* record progress for DATA timeout */
					DataProgress = TRUE;
				}
d938 1
a938 2
				if (putc((unsigned char) *l++, mci->mci_out) ==
				    EOF)
d943 3
a945 5
				else
				{
					/* record progress for DATA timeout */
					DataProgress = TRUE;
				}
d958 4
a961 5
			else
			{
				/* record progress for DATA timeout */
				DataProgress = TRUE;
			}
d965 1
a965 2
					(void) putc((unsigned char)*l,
						    TrafficLogFile);
a980 5
			else
			{
				/* record progress for DATA timeout */
				DataProgress = TRUE;
			}
a990 5
			else
			{
				/* record progress for DATA timeout */
				DataProgress = TRUE;
			}
d997 2
a998 2
				(void) putc((unsigned char)*l, TrafficLogFile);
			if (putc((unsigned char) *l, mci->mci_out) == EOF)
d1003 3
a1005 5
			else
			{
				/* record progress for DATA timeout */
				DataProgress = TRUE;
			}
a1013 5
		else
		{
			/* record progress for DATA timeout */
			DataProgress = TRUE;
		}
a1020 5
				else
				{
					/* record progress for DATA timeout */
					DataProgress = TRUE;
				}
d1025 3
a1078 1

a1173 7
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
d1233 1
a1233 1
				sm_free(bp);
a1345 1
	{
a1347 1
	}
a1370 1
	{
a1372 1
	}
d1484 2
a1485 2
	if (DtableSize > BITMAPBITS)
		maxfd = BITMAPBITS;
d1744 1
a1744 1
**		place where string was trunacted, NULL if not truncated.
d1747 1
a1747 1
char *
d1767 1
a1767 1
		return NULL;
a1775 1
	{
a1776 3
		return p;
	}
	return NULL;
d1790 1
a1790 1
pid_t
d1796 1
a1796 1
	pid_t pid;
a1827 5
	/* Reset global flags */
	RestartRequest = NULL;
	ShutdownRequest = NULL;
	PendingSignal = 0;

a1858 1
		{
a1859 2
			exit(EX_TEMPFAIL);
		}
a1860 1
		{
a1861 2
			exit(EX_TEMPFAIL);
		}
a1866 1
	{
a1867 2
		exit(EX_TEMPFAIL);
	}
a1868 1
	{
a1869 2
		exit(EX_TEMPFAIL);
	}
d2061 1
a2061 1
			sm_free(bp);
d2141 1
a2141 1
static struct procs	*volatile ProcListVec = NULL;
d2180 1
a2180 1
			sm_free(ProcListVec);
d2194 1
a2194 1
		sm_free(ProcListVec[i].proc_task);
d2225 1
a2225 1
				sm_free(ProcListVec[i].proc_task);
a2238 4
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
a2258 2


@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: util.c,v 8.224 1999/11/24 08:44:38 gshapiro Exp $";
d1616 1
d1619 2
a1620 1
			snprintf(p, SPACELEFT(buf, p), "(%s)", errstring(errno));
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Id: util.c,v 8.225.2.1.2.15 2000/10/18 23:46:07 ca Exp $";
a20 1

a210 1

d242 1
a242 1
		if (length - (ptr - string) <= (size_t) ((backslash ? 1 : 0) +
a501 1
		long pid;
a503 2
		pid = (long) getpid();

d505 1
a505 1
		fprintf(pidf, "%ld\n", pid);
d642 1
a642 1
					printf("{%s}", macname(bitidx(*s++)));
a919 5
				else
				{
					/* record progress for DATA timeout */
					DataProgress = TRUE;
				}
a929 5
				else
				{
					/* record progress for DATA timeout */
					DataProgress = TRUE;
				}
d938 1
a938 2
				if (putc((unsigned char) *l++, mci->mci_out) ==
				    EOF)
d943 3
a945 5
				else
				{
					/* record progress for DATA timeout */
					DataProgress = TRUE;
				}
d958 4
a961 5
			else
			{
				/* record progress for DATA timeout */
				DataProgress = TRUE;
			}
d965 1
a965 2
					(void) putc((unsigned char)*l,
						    TrafficLogFile);
a980 5
			else
			{
				/* record progress for DATA timeout */
				DataProgress = TRUE;
			}
a990 5
			else
			{
				/* record progress for DATA timeout */
				DataProgress = TRUE;
			}
d997 2
a998 2
				(void) putc((unsigned char)*l, TrafficLogFile);
			if (putc((unsigned char) *l, mci->mci_out) == EOF)
d1003 3
a1005 5
			else
			{
				/* record progress for DATA timeout */
				DataProgress = TRUE;
			}
a1013 5
		else
		{
			/* record progress for DATA timeout */
			DataProgress = TRUE;
		}
a1020 5
				else
				{
					/* record progress for DATA timeout */
					DataProgress = TRUE;
				}
d1025 3
a1078 1

a1345 1
	{
a1347 1
	}
a1370 1
	{
a1372 1
	}
d1484 2
a1485 2
	if (DtableSize > BITMAPBITS)
		maxfd = BITMAPBITS;
a1615 1
		memset(&sa, '\0', sizeof sa);
d1618 1
a1618 2
			snprintf(p, SPACELEFT(buf, p), "(%s)",
				 errstring(errno));
a1856 1
		{
a1857 2
			exit(EX_TEMPFAIL);
		}
a1858 1
		{
a1859 2
			exit(EX_TEMPFAIL);
		}
a1864 1
	{
a1865 2
		exit(EX_TEMPFAIL);
	}
a1866 1
	{
a1867 2
		exit(EX_TEMPFAIL);
	}
a2256 2


@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d14 4
d19 2
d22 25
a46 1
SM_RCSID("@@(#)$Sendmail: util.c,v 8.347 2001/09/04 22:43:06 ca Exp $")
d48 2
a49 2
#include <sysexits.h>
#include <sm/xtrap.h>
d51 11
d65 1
a65 1
**	Runs through a string and adds backslashes and quote bits.
a68 1
**		rpool -- resource pool from which to allocate result
d72 4
d79 1
a79 1
addquotes(s, rpool)
a80 1
	SM_RPOOL_T *rpool;
d97 1
a97 1
	q = r = sm_rpool_malloc_x(rpool, len + 3);
d124 6
a129 1
**		true iff the string is RFC822 compliant, false otherwise.
d136 1
a136 1
	bool quoted = false;
d141 1
a141 1
		return false;
d150 1
a150 1
				return false;
d160 1
a160 1
					return false;
d168 1
a168 1
				return false;
a171 1

d173 4
a176 1
	return !quoted && commentlev == 0;
d189 1
a189 1
**		true if string is changed, false otherwise
d201 3
a203 3
	bool backslash = false;
	bool modified = false;
	bool quoted = false;
d221 1
a221 1
			backslash = false;
d226 1
a226 1
			backslash = true;
d250 1
a250 1
				backslash = false;
d254 1
a254 1
				quoted = false;
d265 1
a265 1
			modified = true;
d274 1
a274 1
			modified = true;
d281 1
a281 1
		modified = true;
d307 2
a308 2
	bool backslash = false;
	bool quoted = false;
d315 1
a315 1
			backslash = false;
d324 1
a324 1
			backslash = true;
a354 1
#if _FFR_BESTMX_BETTER_TRUNCATION || _FFR_DNSMAP_MULTI
d356 1
a356 6
**  TRUNCATE_AT_DELIM -- truncate string at a delimiter and append "..."
**
**	Parameters:
**		str -- string to truncate
**		len -- maximum length (including '\0') (0 for unlimited)
**		delim -- delimiter character
d358 2
a359 37
**	Returns:
**		None.
*/

void
truncate_at_delim(str, len, delim)
	char *str;
	size_t len;
	int delim;
{
	char *p;

	if (str == NULL || len == 0 || strlen(str) < len)
		return;

	*(str + len - 1) = '\0';
	while ((p = strrchr(str, delim)) != NULL)
	{
		*p = '\0';
		if (p - str + 4 < len)
		{
			*p++ = ':';
			*p = '\0';
			(void) sm_strlcat(str, "...", len);
			return;
		}
	}

	/* Couldn't find a place to append "..." */
	if (len > 3)
		(void) sm_strlcpy(str, "...", len);
	else
		str[0] = '\0';
}
#endif /* _FFR_BESTMX_BETTER_TRUNCATION || _FFR_DNSMAP_MULTI */
/*
**  XALLOC -- Allocate memory, raise an exception on error
a366 3
**	Exceptions:
**		SmHeapOutOfMemory (F:sm.heap) -- cannot allocate memory
**
a371 6
#if SM_HEAP_CHECK
xalloc_tagged(sz, file, line)
	register int sz;
	char *file;
	int line;
#else /* SM_HEAP_CHECK */
a373 1
#endif /* SM_HEAP_CHECK */
d381 1
a381 4
	/* scaffolding for testing error handling code */
	sm_xtrap_raise_x(&SmHeapOutOfMemory);

	p = sm_malloc_tagged((unsigned) sz, file, line, sm_heap_group());
d384 2
a385 1
		sm_exc_raise_x(&SmHeapOutOfMemory);
d392 1
a392 1
**	This routine is the equivalent of strdup for lists of
d398 1
a398 1
**		copycont -- if true, copy the contents of the vector
a399 2
**		rpool -- resource pool from which to allocate storage,
**			or NULL
d403 3
d409 1
a409 1
copyplist(list, copycont, rpool)
a411 1
	SM_RPOOL_T *rpool;
d421 1
a421 1
	newvp = (char **) sm_rpool_malloc_x(rpool, (vp - list) * sizeof *vp);
d427 1
a427 1
			*vp = sm_rpool_strdup_x(rpool, *vp);
d435 1
a435 1
**	This routine is the equivalent of strdup for address queues;
a439 1
**		rpool -- resource pool from which to allocate storage
d443 3
d449 1
a449 1
copyqueue(addr, rpool)
a450 1
	SM_RPOOL_T *rpool;
d460 1
a460 2
			newaddr = (ADDRESS *) sm_rpool_malloc_x(rpool,
							sizeof *newaddr);
d481 1
a481 1
**		writes pidfile, logs command line.
d489 1
a489 1
	SM_FILE_T *pidf;
a490 1
	extern char *CommandLineArgs;
d500 1
a500 2
		sm_syslog(LOG_ERR, NOQID, "unable to write %s: %s",
			  pidpath, sm_errstring(errno));
d504 2
a505 1
		pid_t pid;
d507 1
a507 1
		pid = getpid();
d510 1
a510 2
		(void) sm_io_fprintf(pidf, SM_TIME_DEFAULT, "%ld\n",
				     (long) pid);
d513 1
a513 2
		(void) sm_io_fprintf(pidf, SM_TIME_DEFAULT, "%s\n",
				     CommandLineArgs);
d516 1
a516 1
		(void) sm_io_close(pidf, SM_TIME_DEFAULT);
a517 2
	if (LogLevel > 9)
		sm_syslog(LOG_INFO, NOQID, "started as: %s", CommandLineArgs);
d530 1
a530 1
**		sets {deliveryMode} macro
d540 2
a541 2
	e->e_sendmode = (char) mode;
	buf[0] = (char) mode;
d543 1
a543 1
	macdefine(&e->e_macro, A_TEMP, macid("{deliveryMode}"), buf);
d546 1
a546 1
**  SET_OP_MODE -- set and record the op mode
d549 1
a549 2
**		mode -- op mode
**		e -- the current envelope.
d555 1
a555 1
**		sets {opMode} macro
d559 2
a560 2
set_op_mode(mode)
	int mode;
d562 9
a570 7
	char buf[2];
	extern ENVELOPE BlankEnvelope;

	OpMode = (char) mode;
	buf[0] = (char) mode;
	buf[1] = '\0';
	macdefine(&BlankEnvelope.e_macro, A_TEMP, MID_OPMODE, buf);
d573 1
a573 1
**  PRINTAV -- print argument vector.
d576 1
a576 1
**		av -- argument vector.
d579 1
a579 1
**		none.
d582 1
a582 1
**		prints av.
d585 3
a587 3
void
printav(av)
	register char **av;
d589 1
a589 9
	while (*av != NULL)
	{
		if (tTd(0, 44))
			sm_dprintf("\n\t%08lx=", (unsigned long) *av);
		else
			(void) sm_io_putc(smioout, SM_TIME_DEFAULT, ' ');
		xputs(*av++);
	}
	(void) sm_io_putc(smioout, SM_TIME_DEFAULT, '\n');
d610 1
a610 1
	bool shiftout = false;
a611 22
	static SM_DEBUG_T DebugANSI = SM_DEBUG_INITIALIZER("ANSI",
		"@@(#)$Debug: ANSI - enable reverse video in debug output $");

	/*
	**  TermEscape is set here, rather than in main(),
	**  because ANSI mode can be turned on or off at any time
	**  if we are in -bt rule testing mode.
	*/

	if (sm_debug_unknown(&DebugANSI))
	{
		if (sm_debug_active(&DebugANSI, 1))
		{
			TermEscape.te_rv_on = "\033[7m";
			TermEscape.te_rv_off = "\033[0m";
		}
		else
		{
			TermEscape.te_rv_on = "";
			TermEscape.te_rv_off = "";
		}
	}
d615 1
a615 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s<null>%s",
				     TermEscape.te_rv_on, TermEscape.te_rv_off);
d622 2
a623 3
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s",
					     TermEscape.te_rv_off);
			shiftout = false;
d629 2
a630 4
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "%s$",
						     TermEscape.te_rv_on);
				shiftout = true;
d638 1
a638 3
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "%s$",
						     TermEscape.te_rv_on);
d640 2
a641 3
					(void) sm_io_putc(smioout,
							  SM_TIME_DEFAULT, '&');
				shiftout = true;
d645 1
a645 3
					(void) sm_io_putc(smioout,
							  SM_TIME_DEFAULT,
							  *s++);
d647 1
a647 4
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "{%s}",
							     macname(bitidx(*s++)));
d649 1
a649 4
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "%c",
							     *s++);
d654 1
a654 1
				if (bitidx(mp->metaval) == c)
d656 4
a659 6
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "%s$%c",
							     TermEscape.te_rv_on,
							     mp->metaname);
					shiftout = true;
d666 1
a666 4
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "{%s}",
							     macname(bitidx(*s++)));
d668 1
a668 4
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "%c",
							     *s++);
d674 2
a675 3
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%sM-",
					     TermEscape.te_rv_on);
			shiftout = true;
d681 1
a681 1
			(void) sm_io_putc(smioout, SM_TIME_DEFAULT, c);
d702 2
a703 3
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s",
					     TermEscape.te_rv_on);
			shiftout = true;
d707 2
a708 2
			(void) sm_io_putc(smioout, SM_TIME_DEFAULT, '\\');
			(void) sm_io_putc(smioout, SM_TIME_DEFAULT, c);
d712 2
a713 2
			(void) sm_io_putc(smioout, SM_TIME_DEFAULT, '^');
			(void) sm_io_putc(smioout, SM_TIME_DEFAULT, c ^ 0100);
d717 2
a718 3
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s",
				     TermEscape.te_rv_off);
	(void) sm_io_flush(smioout, SM_TIME_DEFAULT);
d747 53
d848 1
a848 1
**		output of l to mci->mci_out.
d877 1
a877 1
**		output of l to mci->mci_out.
d887 1
a887 1
	bool dead = false;
d911 1
a911 2
			(void) sm_io_fprintf(TrafficLogFile, SM_TIME_DEFAULT,
					     "%05d >>> ", (int) CurrentPid);
d923 2
a924 3
				if (sm_io_putc(mci->mci_out, SM_TIME_DEFAULT,
					       '.') == SM_IO_EOF)
					dead = true;
d928 1
a928 1
					DataProgress = true;
d931 1
a931 2
					(void) sm_io_putc(TrafficLogFile,
							  SM_TIME_DEFAULT, '.');
d938 2
a939 3
				if (sm_io_putc(mci->mci_out, SM_TIME_DEFAULT,
					       '>') == SM_IO_EOF)
					dead = true;
d943 1
a943 1
					DataProgress = true;
d946 1
a946 3
					(void) sm_io_putc(TrafficLogFile,
							  SM_TIME_DEFAULT,
							  '>');
d953 2
a954 2
				if (sm_io_putc(mci->mci_out, SM_TIME_DEFAULT,
					       (unsigned char) *l++) == SM_IO_EOF)
d956 1
a956 1
					dead = true;
d962 1
a962 1
					DataProgress = true;
d968 4
a971 7
			if (sm_io_putc(mci->mci_out, SM_TIME_DEFAULT, '!') ==
			    SM_IO_EOF ||
			    sm_io_fputs(mci->mci_out, SM_TIME_DEFAULT,
					mci->mci_mailer->m_eol) ==
			    SM_IO_EOF ||
			    sm_io_putc(mci->mci_out, SM_TIME_DEFAULT, ' ') ==
			    SM_IO_EOF)
d973 1
a973 1
				dead = true;
d979 1
a979 1
				DataProgress = true;
d984 4
a987 7
					(void) sm_io_putc(TrafficLogFile,
							  SM_TIME_DEFAULT,
							  (unsigned char)*l);
				(void) sm_io_fprintf(TrafficLogFile,
						     SM_TIME_DEFAULT,
						     "!\n%05d >>>  ",
						     (int) CurrentPid);
d999 1
a999 2
			if (sm_io_putc(mci->mci_out, SM_TIME_DEFAULT, '.') ==
			    SM_IO_EOF)
d1004 1
a1004 1
				DataProgress = true;
d1007 1
a1007 2
				(void) sm_io_putc(TrafficLogFile,
						  SM_TIME_DEFAULT, '.');
d1014 1
a1014 2
			if (sm_io_putc(mci->mci_out, SM_TIME_DEFAULT, '>') ==
			    SM_IO_EOF)
d1019 1
a1019 1
				DataProgress = true;
d1022 1
a1022 2
				(void) sm_io_putc(TrafficLogFile,
						  SM_TIME_DEFAULT, '>');
d1027 2
a1028 5
				(void) sm_io_putc(TrafficLogFile,
						  SM_TIME_DEFAULT,
						  (unsigned char)*l);
			if (sm_io_putc(mci->mci_out, SM_TIME_DEFAULT,
				       (unsigned char) *l) == SM_IO_EOF)
d1030 1
a1030 1
				dead = true;
d1036 1
a1036 1
				DataProgress = true;
d1043 2
a1044 4
			(void) sm_io_putc(TrafficLogFile, SM_TIME_DEFAULT,
					  '\n');
		if (sm_io_fputs(mci->mci_out, SM_TIME_DEFAULT,
				mci->mci_mailer->m_eol) == SM_IO_EOF)
d1049 1
a1049 1
			DataProgress = true;
d1056 1
a1056 2
				if (sm_io_putc(mci->mci_out, SM_TIME_DEFAULT,
					       ' ') == SM_IO_EOF)
d1061 1
a1061 1
					DataProgress = true;
a1062 1

d1064 1
a1064 2
					(void) sm_io_putc(TrafficLogFile,
							  SM_TIME_DEFAULT, ' ');
a1066 3

		/* record progress for DATA timeout */
		DataProgress = true;
d1076 1
a1076 1
**		return value of unlink()
d1082 1
a1082 1
int
d1089 3
a1091 1
		sm_syslog(LOG_DEBUG, CurEnv->e_id, "unlink %s", f);
d1095 2
a1096 1
		sm_syslog(LOG_DEBUG, CurEnv->e_id, "%s: unlink-fail %d",
a1097 3
	if (i >= 0)
		SYNC_DIR(f, false);
	return i;
d1110 1
a1110 1
**		NULL on error (including timeout).  This may also leave
d1113 3
d1119 2
d1125 1
a1125 1
	SM_FILE_T *fp;
d1129 1
a1131 4
	int io_timeout;

	SM_REQUIRE(siz > 0);
	SM_REQUIRE(buf != NULL);
a1135 1
		errno = EBADF;
d1139 2
a1140 7
	/* try to read */
	p = NULL;
	errno = 0;

	/* convert the timeout to sm_io notation */
	io_timeout = (timeout <= 0) ? SM_TIME_DEFAULT : timeout * 1000;
	while (!sm_io_eof(fp) && !sm_io_error(fp))
d1142 1
a1142 3
		errno = 0;
		p = sm_io_fgets(fp, io_timeout, buf, siz);
		if (p == NULL && errno == EAGAIN)
a1143 1
			/* The sm_io_fgets() call timedout */
d1147 1
a1147 1
					  CURHOSTNAME,
d1154 3
a1156 5
				(void) sm_io_fprintf(TrafficLogFile,
						     SM_TIME_DEFAULT,
						     "%05d <<< [TIMEOUT]\n",
						     (int) CurrentPid);
			errno = ETIMEDOUT;
d1159 10
d1171 1
a1171 1
		(void) sm_io_clearerr(fp);
d1175 3
d1184 1
a1184 3
			(void) sm_io_fprintf(TrafficLogFile, SM_TIME_DEFAULT,
					     "%05d <<< [EOF]\n",
					     (int) CurrentPid);
d1189 1
a1189 2
		(void) sm_io_fprintf(TrafficLogFile, SM_TIME_DEFAULT,
				     "%05d <<< %s", (int) CurrentPid, buf);
d1201 1
a1201 1
				HasEightBits = true;
d1208 8
d1217 1
a1217 1
**  FGETFOLDED -- like fgets, but knows about folded lines.
d1225 1
a1225 1
**		input line(s) on success, NULL on error or SM_IO_EOF.
d1227 1
a1227 1
**			long, when it will be sm_malloc_x()ed.
d1239 1
a1239 1
	SM_FILE_T *f;
a1244 9
	SM_REQUIRE(n > 0);
	SM_REQUIRE(buf != NULL);
	if (f == NULL)
	{
		buf[0] = '\0';
		errno = EBADF;
		return NULL;
	}

d1246 1
a1246 1
	while ((i = sm_io_getc(f, SM_TIME_DEFAULT)) != SM_IO_EOF)
d1250 1
a1250 1
			i = sm_io_getc(f, SM_TIME_DEFAULT);
d1253 2
a1254 3
				if (i != SM_IO_EOF)
					(void) sm_io_ungetc(f, SM_TIME_DEFAULT,
							    i);
d1269 1
a1269 1
			nbp = sm_malloc_x(nn);
d1273 1
a1273 1
				sm_free(bp);
d1281 3
a1283 3
			i = sm_io_getc(f, SM_TIME_DEFAULT);
			if (i != SM_IO_EOF)
				(void) sm_io_ungetc(f, SM_TIME_DEFAULT, i);
d1303 3
d1319 1
a1319 1
**	Defaults to false
d1322 1
a1322 1
**		s -- string to convert.  Takes "tTyY", empty, and NULL as true,
d1327 3
d1337 2
a1338 2
		return true;
	return false;
d1349 3
d1371 5
a1375 2
**		true if they have a non-null intersection
**		false otherwise
d1388 1
a1388 1
			return true;
d1390 1
a1390 1
	return false;
d1399 5
a1403 2
**		true if map is all zero.
**		false if there are any bits set in map.
d1415 1
a1415 1
			return false;
d1417 1
a1417 1
	return true;
d1427 2
a1428 2
**		true if a is contained in b (case insensitive).
**		false otherwise.
d1449 2
a1450 2
		if (sm_strncasecmp(a, b, la) == 0)
			return true;
d1452 1
a1452 1
	return false;
d1500 1
a1500 1
		printopenfds(true);
d1523 1
a1523 1
	bool printhdr = true;
d1558 1
a1558 1
			printhdr = false;
d1560 1
a1560 1
		dumpfd(fd, true, true);
d1587 1
a1587 1
		dumpfd(fd, false, logit);
a1596 3
**
**	Returns:
**		none.
d1620 1
a1620 1
	(void) sm_snprintf(p, SPACELEFT(buf, p), "%3d: ", fd);
d1633 2
a1634 3
			(void) sm_snprintf(p, SPACELEFT(buf, p),
				"CANNOT STAT (%s)",
				sm_errstring(errno));
d1639 1
a1639 1
			(void) sm_snprintf(p, SPACELEFT(buf, p), "CLOSED");
d1648 1
a1648 1
		(void) sm_snprintf(p, SPACELEFT(buf, p), "fl=0x%x, ", i);
d1652 1
a1652 2
	(void) sm_snprintf(p, SPACELEFT(buf, p), "mode=%o: ",
			(int) st.st_mode);
d1658 1
a1658 1
		(void) sm_snprintf(p, SPACELEFT(buf, p), "SOCK ");
d1663 2
a1664 2
			(void) sm_snprintf(p, SPACELEFT(buf, p), "(%s)",
				 sm_errstring(errno));
d1675 2
a1676 2
				(void) sm_snprintf(p, SPACELEFT(buf, p),
					"%s/%d", hp, ntohs(sa.sin.sin_port));
d1680 2
a1681 2
				(void) sm_snprintf(p, SPACELEFT(buf, p),
					"%s/%d", hp, ntohs(sa.sin6.sin6_port));
d1684 1
a1684 2
				(void) sm_snprintf(p, SPACELEFT(buf, p),
					"%s", hp);
d1687 1
a1687 1
		(void) sm_snprintf(p, SPACELEFT(buf, p), "->");
d1691 1
a1691 2
			(void) sm_snprintf(p, SPACELEFT(buf, p), "(%s)",
					sm_errstring(errno));
d1702 2
a1703 2
				(void) sm_snprintf(p, SPACELEFT(buf, p),
					"%s/%d", hp, ntohs(sa.sin.sin_port));
d1707 2
a1708 2
				(void) sm_snprintf(p, SPACELEFT(buf, p),
					"%s/%d", hp, ntohs(sa.sin6.sin6_port));
d1711 1
a1711 2
				(void) sm_snprintf(p, SPACELEFT(buf, p),
					"%s", hp);
d1717 1
a1717 1
		(void) sm_snprintf(p, SPACELEFT(buf, p), "CHR: ");
a1720 1
#ifdef S_IFBLK
d1722 1
a1722 1
		(void) sm_snprintf(p, SPACELEFT(buf, p), "BLK: ");
a1724 1
#endif /* S_IFBLK */
d1728 1
a1728 1
		(void) sm_snprintf(p, SPACELEFT(buf, p), "FIFO: ");
d1735 1
a1735 1
		(void) sm_snprintf(p, SPACELEFT(buf, p), "DIR: ");
d1742 1
a1742 1
		(void) sm_snprintf(p, SPACELEFT(buf, p), "LNK: ");
d1749 22
a1770 9
		(void) sm_snprintf(p, SPACELEFT(buf, p),
			 "dev=%d/%d, ino=%llu, nlink=%d, u/gid=%d/%d, ",
			 major(st.st_dev), minor(st.st_dev),
			 (ULONGLONG_T) st.st_ino,
			 (int) st.st_nlink, (int) st.st_uid,
			 (int) st.st_gid);
		p += strlen(p);
		(void) sm_snprintf(p, SPACELEFT(buf, p), "size=%llu",
			 (ULONGLONG_T) st.st_size);
d1779 1
a1779 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s\n", buf);
d1788 1
a1788 1
**		place where string was truncated, NULL if not truncated.
d1791 1
a1791 1
char *
d1798 1
a1798 1
	bool canon = false;
d1801 1
a1801 2
	i = strlen(host);
	p = &host[(i == 0) ? 0 : i - 1];
d1805 1
a1805 1
		canon = true;
d1811 1
a1811 1
		return NULL;
d1818 2
a1819 4
	if ((canon ? sm_strcasecmp(p, mydom)
		   : sm_strncasecmp(p, mydom, i)) == 0 &&
			(mydom[i] == '.' || mydom[i] == '\0'))
	{
a1820 3
		return p;
	}
	return NULL;
d1834 1
a1834 1
pid_t
d1840 1
a1840 1
	pid_t pid;
a1842 2
	int sff;
	int ret;
a1868 14
	/* Reset global flags */
	RestartRequest = NULL;
	RestartWorkGroup = false;
	ShutdownRequest = NULL;
	PendingSignal = 0;
	CurrentPid = getpid();

	/*
	**  Initialize exception stack and default exception
	**  handler for child process.
	*/

	sm_exc_newthread(fatal_error);

d1886 1
a1886 1
		xfd = sm_io_getinfo(e->e_xfp, SM_IO_WHAT_FD, NULL);
d1896 1
a1896 1
		(void) close(sm_io_getinfo(e->e_lockfp, SM_IO_WHAT_FD, NULL));
a1915 1
	sm_mbdb_terminate();
a1949 14
	/* Check safety of program to be run */
	sff = SFF_ROOTOK|SFF_EXECOK;
	if (!bitnset(DBS_RUNWRITABLEPROGRAM, DontBlameSendmail))
		sff |= SFF_NOGWFILES|SFF_NOWWFILES;
	if (bitnset(DBS_RUNPROGRAMINUNSAFEDIRPATH, DontBlameSendmail))
		sff |= SFF_NOPATHCHECK;
	else
		sff |= SFF_SAFEDIRPATH;
	ret = safefile(argv[0], DefUid, DefGid, DefUser, sff, 0, NULL);
	if (ret != 0)
		sm_syslog(LOG_INFO, e->e_id,
			  "Warning: prog_open: program %s unsafe: %s",
			  argv[0], sm_errstring(ret));

d1999 2
a2000 2
	if ((char) delim == '\0')
		(void) sm_strlcpy(delimbuf, "\n\t ", sizeof delimbuf);
d2003 1
a2003 1
		delimbuf[0] = (char) delim;
d2010 1
a2010 1
	if (*p == (char) delim && col == 0)
d2015 1
a2015 1
	if (col == 0 && (char) delim == '\0')
d2026 1
a2026 1
		if ((char) delim == '\0')
d2040 1
a2040 1
	(void) sm_strlcpy(buf, begin, i + 1);
d2062 1
a2062 1
	(void) denlstring(f, true, true);
d2080 1
a2115 2
		char *nbp = sm_pmalloc_x(l);

d2117 2
a2118 2
			sm_free(bp);
		bp = nbp;
d2121 1
a2121 1
	(void) sm_strlcpy(bp, s, l);
a2135 86
**  STR2PRT -- convert "unprintable" characters in a string to \oct
**
**	Parameters:
**		s -- string to convert
**
**	Returns:
**		converted string.
**		This is a static local buffer, string must be copied
**		before this function is called again!
*/

char *
str2prt(s)
	char *s;
{
	int l;
	char c, *h;
	bool ok;
	static int len = 0;
	static char *buf = NULL;

	if (s == NULL)
		return NULL;
	ok = true;
	for (h = s, l = 1; *h != '\0'; h++, l++)
	{
		if (*h == '\\')
		{
			++l;
			ok = false;
		}
		else if (!(isascii(*h) && isprint(*h)))
		{
			l += 3;
			ok = false;
		}
	}
	if (ok)
		return s;
	if (l > len)
	{
		char *nbuf = sm_pmalloc_x(l);

		if (buf != NULL)
			sm_free(buf);
		len = l;
		buf = nbuf;
	}
	for (h = buf; *s != '\0' && l > 0; s++, l--)
	{
		c = *s;
		if (isascii(c) && isprint(c) && c != '\\')
		{
			*h++ = c;
		}
		else
		{
			*h++ = '\\';
			--l;
			switch (c)
			{
			  case '\\':
				*h++ = '\\';
				break;
			  case '\t':
				*h++ = 't';
				break;
			  case '\n':
				*h++ = 'n';
				break;
			  case '\r':
				*h++ = 'r';
				break;
			  default:
				(void) sm_snprintf(h, l, "%03o", (int) c);
				l -= 2;
				h += 3;
				break;
			}
		}
	}
	*h = '\0';
	buf[len - 1] = '\0';
	return buf;
}
/*
d2147 2
a2148 2
**		true -- if the indicated pathname is a directory
**		false -- otherwise
d2165 1
a2165 1
			return false;
d2167 2
a2168 2
			return false;
		return true;
d2173 1
a2173 1
		return false;
d2180 1
a2180 1
		return false;
d2182 2
a2183 1
	return true;
a2191 2
**		count -- number of processes.
**		other -- other information for this type.
a2194 3
**
**	Side Effects:
**		May increase CurChildren. May grow ProcList.
d2197 2
a2198 13
typedef struct procs	PROCS_T;

struct procs
{
	pid_t	proc_pid;
	char	*proc_task;
	int	proc_type;
	int	proc_count;
	int	proc_other;
};

static PROCS_T	*volatile ProcListVec = NULL;
static int	ProcListSize = 0;
d2201 1
a2201 1
proc_list_add(pid, task, type, count, other)
a2204 2
	int count;
	int other;
d2228 1
a2228 1
		PROCS_T *npv;
d2230 2
a2231 3
		SM_ASSERT(ProcListSize < INT_MAX - PROC_LIST_SEG);
		npv = (PROCS_T *) sm_pmalloc_x((sizeof *npv) *
					       (ProcListSize + PROC_LIST_SEG));
d2235 2
a2236 2
				ProcListSize * sizeof (PROCS_T));
			sm_free(ProcListVec);
a2237 2

		/* XXX just use memset() to initialize this part? */
d2249 3
a2251 1
	PSTRSET(ProcListVec[i].proc_task, task);
a2252 2
	ProcListVec[i].proc_count = count;
	ProcListVec[i].proc_other = other;
d2255 1
a2255 3
	if (pid != CurrentPid)
	{
		SM_ASSERT(CurChildren < INT_MAX);
a2256 1
	}
d2280 3
a2282 1
			PSTRSET(ProcListVec[i].proc_task, task);
a2291 2
**		count -- pointer to number of processes (return).
**		other -- storage for proc_other (return).
a2294 7
**
**	Side Effects:
**		May decrease CurChildren.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
d2298 1
a2298 1
proc_list_drop(pid, count, other)
a2299 2
	int *count;
	int *other;
a2309 4
			if (count != NULL)
				*count = ProcListVec[i].proc_count;
			if (other != NULL)
				*other = ProcListVec[i].proc_other;
a2326 3
**
**	Side Effects:
**		Sets CurChildren to zero.
d2336 1
d2338 1
a2348 3
**
**	Side Effects:
**		May decrease CurChildren.
a2367 1
			SM_FREE_CLR(ProcListVec[i].proc_task);
a2373 1

a2378 1
**		prefix -- string to output in front of each line.
d2385 2
a2386 3
proc_list_display(out, prefix)
	SM_FILE_T *out;
	char *prefix;
d2395 6
a2400 8
		(void) sm_io_fprintf(out, SM_TIME_DEFAULT, "%s%d %s%s\n",
				     prefix,
				     (int) ProcListVec[i].proc_pid,
				     ProcListVec[i].proc_task != NULL ?
				     ProcListVec[i].proc_task : "(unknown)",
				     (OpMode == MD_SMTP ||
				      OpMode == MD_DAEMON ||
				      OpMode == MD_ARPAFTP) ? "\r" : "");
d2403 5
d2410 75
a2484 13
**  PROC_LIST_SIGNAL -- send a signal to a type of process in the list
**
**	Parameters:
**		type -- type of process to signal
**		signal -- the type of signal to send
**
**	Results:
**		none.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/
d2486 3
a2488 4
void
proc_list_signal(type, signal)
	int type;
	int signal;
d2490 9
a2498 4
	int chldwasblocked;
	int alrmwasblocked;
	int i;
	pid_t mypid = getpid();
d2500 16
a2515 13
	/* block these signals so that we may signal cleanly */
	chldwasblocked = sm_blocksignal(SIGCHLD);
	alrmwasblocked = sm_blocksignal(SIGALRM);

	/* Find all processes of type and send signal */
	for (i = 0; i < ProcListSize; i++)
	{
		if (ProcListVec[i].proc_pid == NO_PID ||
		    ProcListVec[i].proc_pid == mypid)
			continue;
		if (ProcListVec[i].proc_type != type)
			continue;
		(void) kill(ProcListVec[i].proc_pid, signal);
d2517 1
a2517 6

	/* restore the signals */
	if (alrmwasblocked == 0)
		(void) sm_releasesignal(SIGALRM);
	if (chldwasblocked == 0)
		(void) sm_releasesignal(SIGCHLD);
@


