head	1.14;
access;
symbols
	OPENBSD_5_6:1.13.0.6
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.10
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.8
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.6
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.4
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.11.0.18
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.16
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.12
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.14
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.10
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.8
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.6
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.4
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.8
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.6
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2014.09.17.18.49.52;	author matthieu;	state dead;
branches;
next	1.13;
commitid	M7i5giHIoz3DMlTU;

1.13
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2011.05.17.15.54.24;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.22.18.43.56;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.24.03.59.28;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.17.17.31.41;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.01.19.59.23;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.01.17.18.30;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.11.19.02.50;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.29.01.31.16;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.28.02.43.55;	author millert;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.01.15.21.09.11;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.02.19.05.48;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.48;	author millert;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.19;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.51;	author millert;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	2001.05.31.00.31.45;	author miod;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.31.01.47.58;	author jason;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2003, 2006 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>
#include "map.h"

#if USERDB
SM_RCSID("@@(#)$Sendmail: udb.c,v 8.166 2013/11/22 20:51:57 ca Exp $ (with USERDB)")
#else /* USERDB */
SM_RCSID("@@(#)$Sendmail: udb.c,v 8.166 2013/11/22 20:51:57 ca Exp $ (without USERDB)")
#endif /* USERDB */

#if USERDB

#include <sm/sendmail.h>
# if NEWDB
#  include "sm/bdb.h"
# else /* NEWDB */
#  define DBT	struct _data_base_thang_
DBT
{
	void	*data;		/* pointer to data */
	size_t	size;		/* length of data */
};
# endif /* NEWDB */

/*
**  UDB.C -- interface between sendmail and Berkeley User Data Base.
**
**	This depends on the 4.4BSD db package.
*/


struct udbent
{
	char	*udb_spec;		/* string version of spec */
	int	udb_type;		/* type of entry */
	pid_t	udb_pid;		/* PID of process which opened db */
	char	*udb_default;		/* default host for outgoing mail */
	union
	{
# if NETINET || NETINET6
		/* type UE_REMOTE -- do remote call for lookup */
		struct
		{
			SOCKADDR	_udb_addr;	/* address */
			int		_udb_timeout;	/* timeout */
		} udb_remote;
#  define udb_addr	udb_u.udb_remote._udb_addr
#  define udb_timeout	udb_u.udb_remote._udb_timeout
# endif /* NETINET || NETINET6 */

		/* type UE_FORWARD -- forward message to remote */
		struct
		{
			char	*_udb_fwdhost;	/* name of forward host */
		} udb_forward;
# define udb_fwdhost	udb_u.udb_forward._udb_fwdhost

# if NEWDB
		/* type UE_FETCH -- lookup in local database */
		struct
		{
			char	*_udb_dbname;	/* pathname of database */
			DB	*_udb_dbp;	/* open database ptr */
		} udb_lookup;
#  define udb_dbname	udb_u.udb_lookup._udb_dbname
#  define udb_dbp	udb_u.udb_lookup._udb_dbp
# endif /* NEWDB */
	} udb_u;
};

# define UDB_EOLIST	0	/* end of list */
# define UDB_SKIP	1	/* skip this entry */
# define UDB_REMOTE	2	/* look up in remote database */
# define UDB_DBFETCH	3	/* look up in local database */
# define UDB_FORWARD	4	/* forward to remote host */
# define UDB_HESIOD	5	/* look up via hesiod */

# define MAXUDBENT	10	/* maximum number of UDB entries */


struct udb_option
{
	char	*udbo_name;
	char	*udbo_val;
};

# if HESIOD
static int	hes_udb_get __P((DBT *, DBT *));
# endif /* HESIOD */
static char	*udbmatch __P((char *, char *, SM_RPOOL_T *));
static int	_udbx_init __P((ENVELOPE *));
static int	_udb_parsespec __P((char *, struct udb_option [], int));

/*
**  UDBEXPAND -- look up user in database and expand
**
**	Parameters:
**		a -- address to expand.
**		sendq -- pointer to head of sendq to put the expansions in.
**		aliaslevel -- the current alias nesting depth.
**		e -- the current envelope.
**
**	Returns:
**		EX_TEMPFAIL -- if something "odd" happened -- probably due
**			to accessing a file on an NFS server that is down.
**		EX_OK -- otherwise.
**
**	Side Effects:
**		Modifies sendq.
*/

static struct udbent	UdbEnts[MAXUDBENT + 1];
static bool		UdbInitialized = false;

int
udbexpand(a, sendq, aliaslevel, e)
	register ADDRESS *a;
	ADDRESS **sendq;
	int aliaslevel;
	register ENVELOPE *e;
{
	int i;
	DBT key;
	DBT info;
	bool breakout;
	register struct udbent *up;
	int keylen;
	int naddrs;
	char *user;
	char keybuf[MAXUDBKEY];

	memset(&key, '\0', sizeof(key));
	memset(&info, '\0', sizeof(info));

	if (tTd(28, 1))
		sm_dprintf("udbexpand(%s)\n", a->q_paddr);

	/* make certain we are supposed to send to this address */
	if (!QS_IS_SENDABLE(a->q_state))
		return EX_OK;
	e->e_to = a->q_paddr;

	/* on first call, locate the database */
	if (!UdbInitialized)
	{
		if (_udbx_init(e) == EX_TEMPFAIL)
			return EX_TEMPFAIL;
	}

	/* short circuit the process if no chance of a match */
	if (UdbSpec == NULL || UdbSpec[0] == '\0')
		return EX_OK;

	/* extract user to do userdb matching on */
	user = a->q_user;

	/* short circuit name begins with '\\' since it can't possibly match */
	/* (might want to treat this as unquoted instead) */
	if (user[0] == '\\')
		return EX_OK;

	/* if name begins with a colon, it indicates our metadata */
	if (user[0] == ':')
		return EX_OK;

	keylen = sm_strlcpyn(keybuf, sizeof(keybuf), 2, user, ":maildrop");

	/* if name is too long, assume it won't match */
	if (keylen >= sizeof(keybuf))
		return EX_OK;

	/* build actual database key */

	breakout = false;
	for (up = UdbEnts; !breakout; up++)
	{
		int usersize;
		int userleft;
		char userbuf[MEMCHUNKSIZE];
# if HESIOD && HES_GETMAILHOST
		char pobuf[MAXNAME];
# endif /* HESIOD && HES_GETMAILHOST */
# if defined(NEWDB) && DB_VERSION_MAJOR > 1
		DBC *dbc = NULL;
# endif /* defined(NEWDB) && DB_VERSION_MAJOR > 1 */

		user = userbuf;
		userbuf[0] = '\0';
		usersize = sizeof(userbuf);
		userleft = sizeof(userbuf) - 1;

		/*
		**  Select action based on entry type.
		**
		**	On dropping out of this switch, "class" should
		**	explain the type of the data, and "user" should
		**	contain the user information.
		*/

		switch (up->udb_type)
		{
# if NEWDB
		  case UDB_DBFETCH:
			key.data = keybuf;
			key.size = keylen;
			if (tTd(28, 80))
				sm_dprintf("udbexpand: trying %s (%d) via db\n",
					keybuf, keylen);
#  if DB_VERSION_MAJOR < 2
			i = (*up->udb_dbp->seq)(up->udb_dbp, &key, &info, R_CURSOR);
#  else /* DB_VERSION_MAJOR < 2 */
			i = 0;
			if (dbc == NULL &&
#   if DB_VERSION_MAJOR > 2 || DB_VERSION_MINOR >= 6
			    (errno = (*up->udb_dbp->cursor)(up->udb_dbp,
							    NULL, &dbc, 0)) != 0)
#   else /* DB_VERSION_MAJOR > 2 || DB_VERSION_MINOR >= 6 */
			    (errno = (*up->udb_dbp->cursor)(up->udb_dbp,
							    NULL, &dbc)) != 0)
#   endif /* DB_VERSION_MAJOR > 2 || DB_VERSION_MINOR >= 6 */
				i = -1;
			if (i != 0 || dbc == NULL ||
			    (errno = dbc->c_get(dbc, &key,
						&info, DB_SET)) != 0)
				i = 1;
#  endif /* DB_VERSION_MAJOR < 2 */
			if (i > 0 || info.size <= 0)
			{
				if (tTd(28, 2))
					sm_dprintf("udbexpand: no match on %s (%d)\n",
						keybuf, keylen);
#  if DB_VERSION_MAJOR > 1
				if (dbc != NULL)
				{
					(void) dbc->c_close(dbc);
					dbc = NULL;
				}
#  endif /* DB_VERSION_MAJOR > 1 */
				break;
			}
			if (tTd(28, 80))
				sm_dprintf("udbexpand: match %.*s: %.*s\n",
					(int) key.size, (char *) key.data,
					(int) info.size, (char *) info.data);

			a->q_flags &= ~QSELFREF;
			while (i == 0 && key.size == keylen &&
			       memcmp(key.data, keybuf, keylen) == 0)
			{
				char *p;

				if (bitset(EF_VRFYONLY, e->e_flags))
				{
					a->q_state = QS_VERIFIED;
#  if DB_VERSION_MAJOR > 1
					if (dbc != NULL)
					{
						(void) dbc->c_close(dbc);
						dbc = NULL;
					}
#  endif /* DB_VERSION_MAJOR > 1 */
					return EX_OK;
				}

				breakout = true;
				if (info.size >= userleft - 1)
				{
					char *nuser;
					int size = MEMCHUNKSIZE;

					if (info.size > MEMCHUNKSIZE)
						size = info.size;
					nuser = sm_malloc_x(usersize + size);

					memmove(nuser, user, usersize);
					if (user != userbuf)
						sm_free(user); /* XXX */
					user = nuser;
					usersize += size;
					userleft += size;
				}
				p = &user[strlen(user)];
				if (p != user)
				{
					*p++ = ',';
					userleft--;
				}
				memmove(p, info.data, info.size);
				p[info.size] = '\0';
				userleft -= info.size;

				/* get the next record */
#  if DB_VERSION_MAJOR < 2
				i = (*up->udb_dbp->seq)(up->udb_dbp, &key, &info, R_NEXT);
#  else /* DB_VERSION_MAJOR < 2 */
				i = 0;
				if ((errno = dbc->c_get(dbc, &key,
							&info, DB_NEXT)) != 0)
					i = 1;
#  endif /* DB_VERSION_MAJOR < 2 */
			}

#  if DB_VERSION_MAJOR > 1
			if (dbc != NULL)
			{
				(void) dbc->c_close(dbc);
				dbc = NULL;
			}
#  endif /* DB_VERSION_MAJOR > 1 */

			/* if nothing ever matched, try next database */
			if (!breakout)
				break;

			message("expanded to %s", user);
			if (LogLevel > 10)
				sm_syslog(LOG_INFO, e->e_id,
					  "expand %.100s => %s",
					  e->e_to,
					  shortenstring(user, MAXSHORTSTR));
			naddrs = sendtolist(user, a, sendq, aliaslevel + 1, e);
			if (naddrs > 0 && !bitset(QSELFREF, a->q_flags))
			{
				if (tTd(28, 5))
				{
					sm_dprintf("udbexpand: QS_EXPANDED ");
					printaddr(sm_debug_file(), a, false);
				}
				a->q_state = QS_EXPANDED;
			}
			if (i < 0)
			{
				syserr("udbexpand: db-get %.*s stat %d",
					(int) key.size, (char *) key.data, i);
				return EX_TEMPFAIL;
			}

			/*
			**  If this address has a -request address, reflect
			**  it into the envelope.
			*/

			memset(&key, '\0', sizeof(key));
			memset(&info, '\0', sizeof(info));
			(void) sm_strlcpyn(keybuf, sizeof(keybuf), 2, a->q_user,
					   ":mailsender");
			keylen = strlen(keybuf);
			key.data = keybuf;
			key.size = keylen;

#  if DB_VERSION_MAJOR < 2
			i = (*up->udb_dbp->get)(up->udb_dbp, &key, &info, 0);
#  else /* DB_VERSION_MAJOR < 2 */
			i = errno = (*up->udb_dbp->get)(up->udb_dbp, NULL,
							&key, &info, 0);
#  endif /* DB_VERSION_MAJOR < 2 */
			if (i != 0 || info.size <= 0)
				break;
			a->q_owner = sm_rpool_malloc_x(e->e_rpool,
						       info.size + 1);
			memmove(a->q_owner, info.data, info.size);
			a->q_owner[info.size] = '\0';

			/* announce delivery; NORECEIPT bit set later */
			if (e->e_xfp != NULL)
			{
				(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
						     "Message delivered to mailing list %s\n",
						     a->q_paddr);
			}
			e->e_flags |= EF_SENDRECEIPT;
			a->q_flags |= QDELIVERED|QEXPANDED;
			break;
# endif /* NEWDB */

# if HESIOD
		  case UDB_HESIOD:
			key.data = keybuf;
			key.size = keylen;
			if (tTd(28, 80))
				sm_dprintf("udbexpand: trying %s (%d) via hesiod\n",
					keybuf, keylen);
			/* look up the key via hesiod */
			i = hes_udb_get(&key, &info);
			if (i < 0)
			{
				syserr("udbexpand: hesiod-get %.*s stat %d",
					(int) key.size, (char *) key.data, i);
				return EX_TEMPFAIL;
			}
			else if (i > 0 || info.size <= 0)
			{
#  if HES_GETMAILHOST
				struct hes_postoffice *hp;
#  endif /* HES_GETMAILHOST */

				if (tTd(28, 2))
					sm_dprintf("udbexpand: no match on %s (%d)\n",
						(char *) keybuf, (int) keylen);
#  if HES_GETMAILHOST
				if (tTd(28, 8))
					sm_dprintf("  ... trying hes_getmailhost(%s)\n",
						a->q_user);
				hp = hes_getmailhost(a->q_user);
				if (hp == NULL)
				{
					if (hes_error() == HES_ER_NET)
					{
						syserr("udbexpand: hesiod-getmail %s stat %d",
							a->q_user, hes_error());
						return EX_TEMPFAIL;
					}
					if (tTd(28, 2))
						sm_dprintf("hes_getmailhost(%s): %d\n",
							a->q_user, hes_error());
					break;
				}
				if (strlen(hp->po_name) + strlen(hp->po_host) >
				    sizeof(pobuf) - 2)
				{
					if (tTd(28, 2))
						sm_dprintf("hes_getmailhost(%s): expansion too long: %.30s@@%.30s\n",
							a->q_user,
							hp->po_name,
							hp->po_host);
					break;
				}
				info.data = pobuf;
				(void) sm_snprintf(pobuf, sizeof(pobuf),
					"%s@@%s", hp->po_name, hp->po_host);
				info.size = strlen(info.data);
#  else /* HES_GETMAILHOST */
				break;
#  endif /* HES_GETMAILHOST */
			}
			if (tTd(28, 80))
				sm_dprintf("udbexpand: match %.*s: %.*s\n",
					(int) key.size, (char *) key.data,
					(int) info.size, (char *) info.data);
			a->q_flags &= ~QSELFREF;

			if (bitset(EF_VRFYONLY, e->e_flags))
			{
				a->q_state = QS_VERIFIED;
				return EX_OK;
			}

			breakout = true;
			if (info.size >= usersize)
				user = sm_malloc_x(info.size + 1);
			memmove(user, info.data, info.size);
			user[info.size] = '\0';

			message("hesioded to %s", user);
			if (LogLevel > 10)
				sm_syslog(LOG_INFO, e->e_id,
					  "hesiod %.100s => %s",
					  e->e_to,
					  shortenstring(user, MAXSHORTSTR));
			naddrs = sendtolist(user, a, sendq, aliaslevel + 1, e);

			if (naddrs > 0 && !bitset(QSELFREF, a->q_flags))
			{
				if (tTd(28, 5))
				{
					sm_dprintf("udbexpand: QS_EXPANDED ");
					printaddr(sm_debug_file(), a, false);
				}
				a->q_state = QS_EXPANDED;
			}

			/*
			**  If this address has a -request address, reflect
			**  it into the envelope.
			*/

			(void) sm_strlcpyn(keybuf, sizeof(keybuf), 2, a->q_user,
					   ":mailsender");
			keylen = strlen(keybuf);
			key.data = keybuf;
			key.size = keylen;
			i = hes_udb_get(&key, &info);
			if (i != 0 || info.size <= 0)
				break;
			a->q_owner = sm_rpool_malloc_x(e->e_rpool,
						       info.size + 1);
			memmove(a->q_owner, info.data, info.size);
			a->q_owner[info.size] = '\0';
			break;
# endif /* HESIOD */

		  case UDB_REMOTE:
			/* not yet implemented */
			break;

		  case UDB_FORWARD:
			if (bitset(EF_VRFYONLY, e->e_flags))
			{
				a->q_state = QS_VERIFIED;
				return EX_OK;
			}
			i = strlen(up->udb_fwdhost) + strlen(a->q_user) + 1;
			if (i >= usersize)
			{
				usersize = i + 1;
				user = sm_malloc_x(usersize);
			}
			(void) sm_strlcpyn(user, usersize, 3,
					a->q_user, "@@", up->udb_fwdhost);
			message("expanded to %s", user);
			a->q_flags &= ~QSELFREF;
			naddrs = sendtolist(user, a, sendq, aliaslevel + 1, e);
			if (naddrs > 0 && !bitset(QSELFREF, a->q_flags))
			{
				if (tTd(28, 5))
				{
					sm_dprintf("udbexpand: QS_EXPANDED ");
					printaddr(sm_debug_file(), a, false);
				}
				a->q_state = QS_EXPANDED;
			}
			breakout = true;
			break;

		  case UDB_EOLIST:
			breakout = true;
			break;

		  default:
			/* unknown entry type */
			break;
		}
		/* XXX if an exception occurs, there is a storage leak */
		if (user != userbuf)
			sm_free(user); /* XXX */
	}
	return EX_OK;
}
/*
**  UDBSENDER -- return canonical external name of sender, given local name
**
**	Parameters:
**		sender -- the name of the sender on the local machine.
**		rpool -- resource pool from which to allocate result
**
**	Returns:
**		The external name for this sender, if derivable from the
**			database.  Storage allocated from rpool.
**		NULL -- if nothing is changed from the database.
**
**	Side Effects:
**		none.
*/

char *
udbsender(sender, rpool)
	char *sender;
	SM_RPOOL_T *rpool;
{
	return udbmatch(sender, "mailname", rpool);
}
/*
**  UDBMATCH -- match user in field, return result of lookup.
**
**	Parameters:
**		user -- the name of the user.
**		field -- the field to lookup.
**		rpool -- resource pool from which to allocate result
**
**	Returns:
**		The external name for this sender, if derivable from the
**			database.  Storage allocated from rpool.
**		NULL -- if nothing is changed from the database.
**
**	Side Effects:
**		none.
*/

static char *
udbmatch(user, field, rpool)
	char *user;
	char *field;
	SM_RPOOL_T *rpool;
{
	register char *p;
	register struct udbent *up;
	int i;
	int keylen;
	DBT key, info;
	char keybuf[MAXUDBKEY];

	if (tTd(28, 1))
		sm_dprintf("udbmatch(%s, %s)\n", user, field);

	if (!UdbInitialized)
	{
		if (_udbx_init(CurEnv) == EX_TEMPFAIL)
			return NULL;
	}

	/* short circuit if no spec */
	if (UdbSpec == NULL || UdbSpec[0] == '\0')
		return NULL;

	/* short circuit name begins with '\\' since it can't possibly match */
	if (user[0] == '\\')
		return NULL;

	/* long names can never match and are a pain to deal with */
	i = strlen(field);
	if (i < sizeof("maildrop"))
		i = sizeof("maildrop");
	if ((strlen(user) + i) > sizeof(keybuf) - 4)
		return NULL;

	/* names beginning with colons indicate metadata */
	if (user[0] == ':')
		return NULL;

	/* build database key */
	(void) sm_strlcpyn(keybuf, sizeof(keybuf), 3, user, ":", field);
	keylen = strlen(keybuf);

	for (up = UdbEnts; up->udb_type != UDB_EOLIST; up++)
	{
		/*
		**  Select action based on entry type.
		*/

		switch (up->udb_type)
		{
# if NEWDB
		  case UDB_DBFETCH:
			memset(&key, '\0', sizeof(key));
			memset(&info, '\0', sizeof(info));
			key.data = keybuf;
			key.size = keylen;
#  if DB_VERSION_MAJOR < 2
			i = (*up->udb_dbp->get)(up->udb_dbp, &key, &info, 0);
#  else /* DB_VERSION_MAJOR < 2 */
			i = errno = (*up->udb_dbp->get)(up->udb_dbp, NULL,
							&key, &info, 0);
#  endif /* DB_VERSION_MAJOR < 2 */
			if (i != 0 || info.size <= 0)
			{
				if (tTd(28, 2))
					sm_dprintf("udbmatch: no match on %s (%d) via db\n",
						keybuf, keylen);
				continue;
			}

			p = sm_rpool_malloc_x(rpool, info.size + 1);
			memmove(p, info.data, info.size);
			p[info.size] = '\0';
			if (tTd(28, 1))
				sm_dprintf("udbmatch ==> %s\n", p);
			return p;
# endif /* NEWDB */

# if HESIOD
		  case UDB_HESIOD:
			key.data = keybuf;
			key.size = keylen;
			i = hes_udb_get(&key, &info);
			if (i != 0 || info.size <= 0)
			{
				if (tTd(28, 2))
					sm_dprintf("udbmatch: no match on %s (%d) via hesiod\n",
						keybuf, keylen);
				continue;
			}

			p = sm_rpool_malloc_x(rpool, info.size + 1);
			memmove(p, info.data, info.size);
			p[info.size] = '\0';
			if (tTd(28, 1))
				sm_dprintf("udbmatch ==> %s\n", p);
			return p;
# endif /* HESIOD */
		}
	}

	if (strcmp(field, "mailname") != 0)
		return NULL;

	/*
	**  Nothing yet.  Search again for a default case.  But only
	**  use it if we also have a forward (:maildrop) pointer already
	**  in the database.
	*/

	/* build database key */
	(void) sm_strlcpyn(keybuf, sizeof(keybuf), 2, user, ":maildrop");
	keylen = strlen(keybuf);

	for (up = UdbEnts; up->udb_type != UDB_EOLIST; up++)
	{
		switch (up->udb_type)
		{
# if NEWDB
		  case UDB_DBFETCH:
			/* get the default case for this database */
			if (up->udb_default == NULL)
			{
				memset(&key, '\0', sizeof(key));
				memset(&info, '\0', sizeof(info));
				key.data = ":default:mailname";
				key.size = strlen(key.data);
#  if DB_VERSION_MAJOR < 2
				i = (*up->udb_dbp->get)(up->udb_dbp,
							&key, &info, 0);
#  else /* DB_VERSION_MAJOR < 2 */
				i = errno = (*up->udb_dbp->get)(up->udb_dbp,
								NULL, &key,
								&info, 0);
#  endif /* DB_VERSION_MAJOR < 2 */
				if (i != 0 || info.size <= 0)
				{
					/* no default case */
					up->udb_default = "";
					continue;
				}

				/* save the default case */
				up->udb_default = sm_pmalloc_x(info.size + 1);
				memmove(up->udb_default, info.data, info.size);
				up->udb_default[info.size] = '\0';
			}
			else if (up->udb_default[0] == '\0')
				continue;

			/* we have a default case -- verify user:maildrop */
			memset(&key, '\0', sizeof(key));
			memset(&info, '\0', sizeof(info));
			key.data = keybuf;
			key.size = keylen;
#  if DB_VERSION_MAJOR < 2
			i = (*up->udb_dbp->get)(up->udb_dbp, &key, &info, 0);
#  else /* DB_VERSION_MAJOR < 2 */
			i = errno = (*up->udb_dbp->get)(up->udb_dbp, NULL,
							&key, &info, 0);
#  endif /* DB_VERSION_MAJOR < 2 */
			if (i != 0 || info.size <= 0)
			{
				/* nope -- no aliasing for this user */
				continue;
			}

			/* they exist -- build the actual address */
			i = strlen(user) + strlen(up->udb_default) + 2;
			p = sm_rpool_malloc_x(rpool, i);
			(void) sm_strlcpyn(p, i, 3, user, "@@", up->udb_default);
			if (tTd(28, 1))
				sm_dprintf("udbmatch ==> %s\n", p);
			return p;
# endif /* NEWDB */

# if HESIOD
		  case UDB_HESIOD:
			/* get the default case for this database */
			if (up->udb_default == NULL)
			{
				key.data = ":default:mailname";
				key.size = strlen(key.data);
				i = hes_udb_get(&key, &info);

				if (i != 0 || info.size <= 0)
				{
					/* no default case */
					up->udb_default = "";
					continue;
				}

				/* save the default case */
				up->udb_default = sm_pmalloc_x(info.size + 1);
				memmove(up->udb_default, info.data, info.size);
				up->udb_default[info.size] = '\0';
			}
			else if (up->udb_default[0] == '\0')
				continue;

			/* we have a default case -- verify user:maildrop */
			key.data = keybuf;
			key.size = keylen;
			i = hes_udb_get(&key, &info);
			if (i != 0 || info.size <= 0)
			{
				/* nope -- no aliasing for this user */
				continue;
			}

			/* they exist -- build the actual address */
			i = strlen(user) + strlen(up->udb_default) + 2;
			p = sm_rpool_malloc_x(rpool, i);
			(void) sm_strlcpyn(p, i, 3, user, "@@", up->udb_default);
			if (tTd(28, 1))
				sm_dprintf("udbmatch ==> %s\n", p);
			return p;
			break;
# endif /* HESIOD */
		}
	}

	/* still nothing....  too bad */
	return NULL;
}
/*
**  UDB_MAP_LOOKUP -- look up arbitrary entry in user database map
**
**	Parameters:
**		map -- the map being queried.
**		name -- the name to look up.
**		av -- arguments to the map lookup.
**		statp -- to get any error status.
**
**	Returns:
**		NULL if name not found in map.
**		The rewritten name otherwise.
*/

/* ARGSUSED3 */
char *
udb_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	char *val;
	char *key;
	char *SM_NONVOLATILE result = NULL;
	char keybuf[MAXNAME + 1];

	if (tTd(28, 20) || tTd(38, 20))
		sm_dprintf("udb_map_lookup(%s, %s)\n", map->map_mname, name);

	if (bitset(MF_NOFOLDCASE, map->map_mflags))
	{
		key = name;
	}
	else
	{
		int keysize = strlen(name);

		if (keysize > sizeof(keybuf) - 1)
			keysize = sizeof(keybuf) - 1;
		memmove(keybuf, name, keysize);
		keybuf[keysize] = '\0';
		makelower(keybuf);
		key = keybuf;
	}
	val = udbmatch(key, map->map_file, NULL);
	if (val == NULL)
		return NULL;
	SM_TRY
		if (bitset(MF_MATCHONLY, map->map_mflags))
			result = map_rewrite(map, name, strlen(name), NULL);
		else
			result = map_rewrite(map, val, strlen(val), av);
	SM_FINALLY
		sm_free(val);
	SM_END_TRY
	return result;
}
/*
**  _UDBX_INIT -- parse the UDB specification, opening any valid entries.
**
**	Parameters:
**		e -- the current envelope.
**
**	Returns:
**		EX_TEMPFAIL -- if it appeared it couldn't get hold of a
**			database due to a host being down or some similar
**			(recoverable) situation.
**		EX_OK -- otherwise.
**
**	Side Effects:
**		Fills in the UdbEnts structure from UdbSpec.
*/

# define MAXUDBOPTS	27

static int
_udbx_init(e)
	ENVELOPE *e;
{
	int ents = 0;
	register char *p;
	register struct udbent *up;

	if (UdbInitialized)
		return EX_OK;

# ifdef UDB_DEFAULT_SPEC
	if (UdbSpec == NULL)
		UdbSpec = UDB_DEFAULT_SPEC;
# endif /* UDB_DEFAULT_SPEC */

	p = UdbSpec;
	up = UdbEnts;
	while (p != NULL)
	{
		char *spec;
		int l;
		struct udb_option opts[MAXUDBOPTS + 1];

		while (*p == ' ' || *p == '\t' || *p == ',')
			p++;
		if (*p == '\0')
			break;
		spec = p;
		p = strchr(p, ',');
		if (p != NULL)
			*p++ = '\0';

		if (ents >= MAXUDBENT)
		{
			syserr("Maximum number of UDB entries exceeded");
			break;
		}

		/* extract options */
		(void) _udb_parsespec(spec, opts, MAXUDBOPTS);

		/*
		**  Decode database specification.
		**
		**	In the sendmail tradition, the leading character
		**	defines the semantics of the rest of the entry.
		**
		**	@@hostname --	forward email to the indicated host.
		**			This should be the last in the list,
		**			since it always matches the input.
		**	/dbname	 --	search the named database on the local
		**			host using the Berkeley db package.
		**	Hesiod --	search the named database with BIND
		**			using the MIT Hesiod package.
		*/

		switch (*spec)
		{
		  case '@@':	/* forward to remote host */
			up->udb_type = UDB_FORWARD;
			up->udb_pid = CurrentPid;
			up->udb_fwdhost = spec + 1;
			ents++;
			up++;
			break;

# if HESIOD
		  case 'h':	/* use hesiod */
		  case 'H':
			if (sm_strcasecmp(spec, "hesiod") != 0)
				goto badspec;
			up->udb_type = UDB_HESIOD;
			up->udb_pid = CurrentPid;
			ents++;
			up++;
			break;
# endif /* HESIOD */

# if NEWDB
		  case '/':	/* look up remote name */
			l = strlen(spec);
			if (l > 3 && strcmp(&spec[l - 3], ".db") == 0)
			{
				up->udb_dbname = spec;
			}
			else
			{
				up->udb_dbname = sm_pmalloc_x(l + 4);
				(void) sm_strlcpyn(up->udb_dbname, l + 4, 2,
						   spec, ".db");
			}
			errno = 0;
#  if DB_VERSION_MAJOR < 2
			up->udb_dbp = dbopen(up->udb_dbname, O_RDONLY,
					     0644, DB_BTREE, NULL);
#  else /* DB_VERSION_MAJOR < 2 */
			{
				int flags = DB_RDONLY;
#  if DB_VERSION_MAJOR > 2
				int ret;
#  endif /* DB_VERSION_MAJOR > 2 */

				SM_DB_FLAG_ADD(flags);
				up->udb_dbp = NULL;
#  if DB_VERSION_MAJOR > 2
				ret = db_create(&up->udb_dbp, NULL, 0);
				if (ret != 0)
				{
					(void) up->udb_dbp->close(up->udb_dbp,
								  0);
					up->udb_dbp = NULL;
				}
				else
				{
					ret = up->udb_dbp->open(up->udb_dbp,
								DBTXN
								up->udb_dbname,
								NULL,
								DB_BTREE,
								flags,
								0644);
					if (ret != 0)
					{
#ifdef DB_OLD_VERSION
						if (ret == DB_OLD_VERSION)
							ret = EINVAL;
#endif /* DB_OLD_VERSION */
						(void) up->udb_dbp->close(up->udb_dbp, 0);
						up->udb_dbp = NULL;
					}
				}
				errno = ret;
#  else /* DB_VERSION_MAJOR > 2 */
				errno = db_open(up->udb_dbname, DB_BTREE,
						flags, 0644, NULL,
						NULL, &up->udb_dbp);
#  endif /* DB_VERSION_MAJOR > 2 */
			}
#  endif /* DB_VERSION_MAJOR < 2 */
			if (up->udb_dbp == NULL)
			{
				if (tTd(28, 1))
				{
					int save_errno = errno;

#  if DB_VERSION_MAJOR < 2
					sm_dprintf("dbopen(%s): %s\n",
#  else /* DB_VERSION_MAJOR < 2 */
					sm_dprintf("db_open(%s): %s\n",
#  endif /* DB_VERSION_MAJOR < 2 */
						up->udb_dbname,
						sm_errstring(errno));
					errno = save_errno;
				}
				if (errno != ENOENT && errno != EACCES)
				{
					if (LogLevel > 2)
						sm_syslog(LOG_ERR, e->e_id,
#  if DB_VERSION_MAJOR < 2
							  "dbopen(%s): %s",
#  else /* DB_VERSION_MAJOR < 2 */
							  "db_open(%s): %s",
#  endif /* DB_VERSION_MAJOR < 2 */
							  up->udb_dbname,
							  sm_errstring(errno));
					up->udb_type = UDB_EOLIST;
					if (up->udb_dbname != spec)
						sm_free(up->udb_dbname); /* XXX */
					goto tempfail;
				}
				if (up->udb_dbname != spec)
					sm_free(up->udb_dbname); /* XXX */
				break;
			}
			if (tTd(28, 1))
			{
#  if DB_VERSION_MAJOR < 2
				sm_dprintf("_udbx_init: dbopen(%s)\n",
#  else /* DB_VERSION_MAJOR < 2 */
				sm_dprintf("_udbx_init: db_open(%s)\n",
#  endif /* DB_VERSION_MAJOR < 2 */
					up->udb_dbname);
			}
			up->udb_type = UDB_DBFETCH;
			up->udb_pid = CurrentPid;
			ents++;
			up++;
			break;
# endif /* NEWDB */

		  default:
# if HESIOD
badspec:
# endif /* HESIOD */
			syserr("Unknown UDB spec %s", spec);
			break;
		}
	}
	up->udb_type = UDB_EOLIST;

	if (tTd(28, 4))
	{
		for (up = UdbEnts; up->udb_type != UDB_EOLIST; up++)
		{
			switch (up->udb_type)
			{
			  case UDB_REMOTE:
				sm_dprintf("REMOTE: addr %s, timeo %d\n",
					   anynet_ntoa((SOCKADDR *) &up->udb_addr),
					   up->udb_timeout);
				break;

			  case UDB_DBFETCH:
# if NEWDB
				sm_dprintf("FETCH: file %s\n",
					up->udb_dbname);
# else /* NEWDB */
				sm_dprintf("FETCH\n");
# endif /* NEWDB */
				break;

			  case UDB_FORWARD:
				sm_dprintf("FORWARD: host %s\n",
					up->udb_fwdhost);
				break;

			  case UDB_HESIOD:
				sm_dprintf("HESIOD\n");
				break;

			  default:
				sm_dprintf("UNKNOWN\n");
				break;
			}
		}
	}

	UdbInitialized = true;
	errno = 0;
	return EX_OK;

	/*
	**  On temporary failure, back out anything we've already done
	*/

  tempfail:
# if NEWDB
	for (up = UdbEnts; up->udb_type != UDB_EOLIST; up++)
	{
		if (up->udb_type == UDB_DBFETCH)
		{
#  if DB_VERSION_MAJOR < 2
			(*up->udb_dbp->close)(up->udb_dbp);
#  else /* DB_VERSION_MAJOR < 2 */
			errno = (*up->udb_dbp->close)(up->udb_dbp, 0);
#  endif /* DB_VERSION_MAJOR < 2 */
			if (tTd(28, 1))
				sm_dprintf("_udbx_init: db->close(%s)\n",
					up->udb_dbname);
		}
	}
# endif /* NEWDB */
	return EX_TEMPFAIL;
}

static int
_udb_parsespec(udbspec, opt, maxopts)
	char *udbspec;
	struct udb_option opt[];
	int maxopts;
{
	register char *spec;
	register char *spec_end;
	register int optnum;

	spec_end = strchr(udbspec, ':');
	for (optnum = 0; optnum < maxopts && (spec = spec_end) != NULL; optnum++)
	{
		register char *p;

		while (isascii(*spec) && isspace(*spec))
			spec++;
		spec_end = strchr(spec, ':');
		if (spec_end != NULL)
			*spec_end++ = '\0';

		opt[optnum].udbo_name = spec;
		opt[optnum].udbo_val = NULL;
		p = strchr(spec, '=');
		if (p != NULL)
			opt[optnum].udbo_val = ++p;
	}
	return optnum;
}
/*
**  _UDBX_CLOSE -- close all file based UDB entries.
**
**	Parameters:
**		none
**
**	Returns:
**		none
*/
void
_udbx_close()
{
	struct udbent *up;

	if (!UdbInitialized)
		return;

	for (up = UdbEnts; up->udb_type != UDB_EOLIST; up++)
	{
		if (up->udb_pid != CurrentPid)
			continue;

# if NEWDB
		if (up->udb_type == UDB_DBFETCH)
		{
#  if DB_VERSION_MAJOR < 2
			(*up->udb_dbp->close)(up->udb_dbp);
#  else /* DB_VERSION_MAJOR < 2 */
			errno = (*up->udb_dbp->close)(up->udb_dbp, 0);
#  endif /* DB_VERSION_MAJOR < 2 */
		}
		if (tTd(28, 1))
			sm_dprintf("_udbx_close: db->close(%s)\n",
				up->udb_dbname);
# endif /* NEWDB */
	}
}

# if HESIOD

static int
hes_udb_get(key, info)
	DBT *key;
	DBT *info;
{
	char *name, *type;
	char **hp;
	char kbuf[MAXUDBKEY + 1];

	if (sm_strlcpy(kbuf, key->data, sizeof(kbuf)) >= sizeof(kbuf))
		return 0;
	name = kbuf;
	type = strrchr(name, ':');
	if (type == NULL)
		return 1;
	*type++ = '\0';
	if (strchr(name, '@@') != NULL)
		return 1;

	if (tTd(28, 1))
		sm_dprintf("hes_udb_get(%s, %s)\n", name, type);

	/* make the hesiod query */
#  ifdef HESIOD_INIT
	if (HesiodContext == NULL && hesiod_init(&HesiodContext) != 0)
		return -1;
	hp = hesiod_resolve(HesiodContext, name, type);
#  else /* HESIOD_INIT */
	hp = hes_resolve(name, type);
#  endif /* HESIOD_INIT */
	*--type = ':';
#  ifdef HESIOD_INIT
	if (hp == NULL)
		return 1;
	if (*hp == NULL)
	{
		hesiod_free_list(HesiodContext, hp);
		if (errno == ECONNREFUSED || errno == EMSGSIZE)
			return -1;
		return 1;
	}
#  else /* HESIOD_INIT */
	if (hp == NULL || hp[0] == NULL)
	{
		/* network problem or timeout */
		if (hes_error() == HES_ER_NET)
			return -1;

		return 1;
	}
#  endif /* HESIOD_INIT */
	else
	{
		/*
		**  If there are multiple matches, just return the
		**  first one.
		**
		**  XXX These should really be returned; for example,
		**  XXX it is legal for :maildrop to be multi-valued.
		*/

		info->data = hp[0];
		info->size = (size_t) strlen(info->data);
	}

	if (tTd(28, 80))
		sm_dprintf("hes_udb_get => %s\n", *hp);

	return 0;
}
# endif /* HESIOD */

#else /* USERDB */

int
udbexpand(a, sendq, aliaslevel, e)
	ADDRESS *a;
	ADDRESS **sendq;
	int aliaslevel;
	ENVELOPE *e;
{
	return EX_OK;
}

#endif /* USERDB */
@


1.13
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.12
log
@Update to sendmail 8.14.5
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003, 2006 Sendmail, Inc. and its suppliers.
d18 1
a18 1
SM_RCSID("@@(#)$Sendmail: udb.c,v 8.165 2010/01/10 06:22:00 ca Exp $ (with USERDB)")
d20 1
a20 1
SM_RCSID("@@(#)$Sendmail: udb.c,v 8.165 2010/01/10 06:22:00 ca Exp $ (without USERDB)")
@


1.11
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d18 1
a18 1
SM_RCSID("@@(#)$Sendmail: udb.c,v 8.164 2006/12/19 19:49:51 ca Exp $ (with USERDB)")
d20 1
a20 1
SM_RCSID("@@(#)$Sendmail: udb.c,v 8.164 2006/12/19 19:49:51 ca Exp $ (without USERDB)")
d1222 1
a1222 1
			sm_dprintf("_udbx_init: db->close(%s)\n",
@


1.10
log
@Update to sendmail 8.13.6
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d15 1
d18 1
a18 1
SM_RCSID("@@(#)$Sendmail: udb.c,v 8.161 2005/08/31 21:34:20 ca Exp $ (with USERDB)")
d20 1
a20 1
SM_RCSID("@@(#)$Sendmail: udb.c,v 8.161 2005/08/31 21:34:20 ca Exp $ (without USERDB)")
d25 1
d144 2
a145 2
	memset(&key, '\0', sizeof key);
	memset(&info, '\0', sizeof info);
d178 1
a178 1
	keylen = sm_strlcpyn(keybuf, sizeof keybuf, 2, user, ":maildrop");
d181 1
a181 1
	if (keylen >= sizeof keybuf)
d201 2
a202 2
		usersize = sizeof userbuf;
		userleft = sizeof userbuf - 1;
d355 3
a357 3
			memset(&key, '\0', sizeof key);
			memset(&info, '\0', sizeof info);
			(void) sm_strlcpyn(keybuf, sizeof keybuf, 2, a->q_user,
d431 1
a431 1
				    sizeof pobuf - 2)
d441 1
a441 1
				(void) sm_snprintf(pobuf, sizeof pobuf,
d489 1
a489 1
			(void) sm_strlcpyn(keybuf, sizeof keybuf, 2, a->q_user,
d623 3
a625 3
	if (i < sizeof "maildrop")
		i = sizeof "maildrop";
	if ((strlen(user) + i) > sizeof keybuf - 4)
d633 1
a633 1
	(void) sm_strlcpyn(keybuf, sizeof keybuf, 3, user, ":", field);
d646 2
a647 2
			memset(&key, '\0', sizeof key);
			memset(&info, '\0', sizeof info);
d705 1
a705 1
	(void) sm_strlcpyn(keybuf, sizeof keybuf, 2, user, ":maildrop");
d717 2
a718 2
				memset(&key, '\0', sizeof key);
				memset(&info, '\0', sizeof info);
d745 2
a746 2
			memset(&key, '\0', sizeof key);
			memset(&info, '\0', sizeof info);
d857 2
a858 2
		if (keysize > sizeof keybuf - 1)
			keysize = sizeof keybuf - 1;
d1239 1
a1239 1
	if (sm_strlcpy(kbuf, key->data, sizeof kbuf) >= sizeof kbuf)
@


1.9
log
@Update to sendmail.8.13.0
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: udb.c,v 8.160 2003/04/03 16:32:46 ca Exp $ (with USERDB)")
d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: udb.c,v 8.160 2003/04/03 16:32:46 ca Exp $ (without USERDB)")
d140 1
a140 1
	char keybuf[MAXKEY];
d600 1
a600 1
	char keybuf[MAXKEY];
d1235 1
a1235 1
	char kbuf[MAXKEY + 1];
@


1.8
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: udb.c,v 8.153.4.5 2003/04/03 16:31:00 ca Exp $ (with USERDB)")
d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: udb.c,v 8.153.4.5 2003/04/03 16:31:00 ca Exp $ (without USERDB)")
d337 1
a337 1
					printaddr(a, false);
d477 1
a477 1
					printaddr(a, false);
d528 1
a528 1
					printaddr(a, false);
@


1.7
log
@update to sendmail 8.12.7
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: udb.c,v 8.153.4.4 2002/12/03 17:57:41 gshapiro Exp $ (with USERDB)")
d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: udb.c,v 8.153.4.4 2002/12/03 17:57:41 gshapiro Exp $ (without USERDB)")
d179 1
a179 1
	if (keylen > sizeof keybuf)
@


1.6
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: udb.c,v 8.153 2001/09/11 04:05:17 gshapiro Exp $ (with USERDB)")
d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: udb.c,v 8.153 2001/09/11 04:05:17 gshapiro Exp $ (without USERDB)")
d25 1
a25 4
#  include <db.h>
#  ifndef DB_VERSION_MAJOR
#   define DB_VERSION_MAJOR 1
#  endif /* ! DB_VERSION_MAJOR */
d190 1
a190 1
# if defined(HESIOD) && defined(HES_GETMAILHOST)
d192 1
a192 1
# endif /* defined(HESIOD) && defined(HES_GETMAILHOST) */
d996 1
a996 4
#  if !HASFLOCK && defined(DB_FCNTL_LOCKING)
				flags |= DB_FCNTL_LOCKING;
#  endif /* !HASFLOCK && defined(DB_FCNTL_LOCKING) */

a997 1

d1009 1
@


1.5
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: udb.c,v 8.150 2001/09/04 22:54:42 ca Exp $ (with USERDB)")
d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: udb.c,v 8.150 2001/09/04 22:54:42 ca Exp $ (without USERDB)")
d552 1
a552 1
/*
d575 1
a575 1
/*
d820 1
a820 1
/*
d878 1
a878 1
/*
d1194 1
a1194 1
/*
@


1.4
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-1999, 2001 Sendmail, Inc. and its suppliers.
d16 5
a20 7
#ifndef lint
# if USERDB
static char id[] = "@@(#)$Sendmail: udb.c,v 8.111.16.2 2001/05/03 17:24:17 gshapiro Exp $ (with USERDB)";
# else /* USERDB */
static char id[] = "@@(#)$Sendmail: udb.c,v 8.111.16.2 2001/05/03 17:24:17 gshapiro Exp $ (without USERDB)";
# endif /* USERDB */
#endif /* ! lint */
d24 1
a24 1
# ifdef NEWDB
d71 1
a71 1
# ifdef NEWDB
d100 1
a100 1
# ifdef HESIOD
d103 1
a103 1
static char	*udbmatch __P((char *, char *));
d126 1
a126 1
static bool		UdbInitialized = FALSE;
d149 1
a149 1
		dprintf("udbexpand(%s)\n", a->q_paddr);
d175 2
a176 2
	/* if name is too long, assume it won't match */
	if (strlen(user) > (SIZE_T) sizeof keybuf - 12)
d179 4
a182 2
	/* if name begins with a colon, it indicates our metadata */
	if (user[0] == ':')
a185 3
	(void) strlcpy(keybuf, user, sizeof keybuf);
	(void) strlcat(keybuf, ":maildrop", sizeof keybuf);
	keylen = strlen(keybuf);
d187 1
a187 1
	breakout = FALSE;
d215 1
a215 1
# ifdef NEWDB
d220 1
a220 1
				dprintf("udbexpand: trying %s (%d) via db\n",
d243 1
a243 1
					dprintf("udbexpand: no match on %s (%d)\n",
d255 1
a255 1
				dprintf("udbexpand: match %.*s: %.*s\n",
d278 1
a278 1
				breakout = TRUE;
d286 1
a286 1
					nuser = xalloc(usersize + size);
d290 1
a290 1
						sm_free(user);
d339 2
a340 2
					dprintf("udbexpand: QS_EXPANDED ");
					printaddr(a, FALSE);
d358 2
a359 2
			(void) strlcpy(keybuf, a->q_user, sizeof keybuf);
			(void) strlcat(keybuf, ":mailsender", sizeof keybuf);
d372 2
a373 1
			a->q_owner = xalloc(info.size + 1);
d380 3
a382 3
				fprintf(e->e_xfp,
					"Message delivered to mailing list %s\n",
					a->q_paddr);
d389 1
a389 1
# ifdef HESIOD
d394 1
a394 1
				dprintf("udbexpand: trying %s (%d) via hesiod\n",
d411 1
a411 1
					dprintf("udbexpand: no match on %s (%d)\n",
d415 1
a415 1
					dprintf("  ... trying hes_getmailhost(%s)\n",
d427 1
a427 1
						dprintf("hes_getmailhost(%s): %d\n",
d435 1
a435 1
						dprintf("hes_getmailhost(%s): expansion too long: %.30s@@%.30s\n",
d442 2
a443 2
				snprintf(pobuf, sizeof pobuf, "%s@@%s",
					hp->po_name, hp->po_host);
d450 1
a450 1
				dprintf("udbexpand: match %.*s: %.*s\n",
d461 1
a461 1
			breakout = TRUE;
d463 1
a463 1
				user = xalloc(info.size + 1);
d479 2
a480 2
					dprintf("udbexpand: QS_EXPANDED ");
					printaddr(a, FALSE);
d490 2
a491 2
			(void) strlcpy(keybuf, a->q_user, sizeof keybuf);
			(void) strlcat(keybuf, ":mailsender", sizeof keybuf);
d498 2
a499 1
			a->q_owner = xalloc(info.size + 1);
d519 1
a519 1
				user = xalloc(usersize);
d521 2
a522 2
			(void) snprintf(user, usersize, "%s@@%s",
					a->q_user, up->udb_fwdhost);
d530 2
a531 2
					dprintf("udbexpand: QS_EXPANDED ");
					printaddr(a, FALSE);
d535 1
a535 1
			breakout = TRUE;
d539 1
a539 1
			breakout = TRUE;
d546 1
d548 1
a548 1
			sm_free(user);
d557 1
d561 1
a561 1
**			database.
d569 1
a569 1
udbsender(sender)
d571 1
d573 1
a573 1
	return udbmatch(sender, "mailname");
d581 1
d585 1
a585 1
**			database.
d593 1
a593 1
udbmatch(user, field)
d596 1
d606 1
a606 1
		dprintf("udbmatch(%s, %s)\n", user, field);
d634 1
a634 1
	(void) snprintf(keybuf, sizeof keybuf, "%s:%s", user, field);
d645 1
a645 1
# ifdef NEWDB
d660 1
a660 1
					dprintf("udbmatch: no match on %s (%d) via db\n",
d665 1
a665 1
			p = xalloc(info.size + 1);
d669 1
a669 1
				dprintf("udbmatch ==> %s\n", p);
d673 1
a673 1
# ifdef HESIOD
d681 1
a681 1
					dprintf("udbmatch: no match on %s (%d) via hesiod\n",
d686 1
a686 1
			p = xalloc(info.size + 1);
d690 1
a690 1
				dprintf("udbmatch ==> %s\n", p);
d706 1
a706 2
	(void) strlcpy(keybuf, user, sizeof keybuf);
	(void) strlcat(keybuf, ":maildrop", sizeof keybuf);
d713 1
a713 1
# ifdef NEWDB
d738 1
a738 1
				up->udb_default = xalloc(info.size + 1);
d764 2
a765 2
			p = xalloc(i);
			(void) snprintf(p, i, "%s@@%s", user, up->udb_default);
d767 1
a767 1
				dprintf("udbmatch ==> %s\n", p);
d771 1
a771 1
# ifdef HESIOD
d788 1
a788 1
				up->udb_default = xalloc(info.size + 1);
d807 2
a808 2
			p = xalloc(i);
			(void) snprintf(p, i, "%s@@%s", user, up->udb_default);
d810 1
a810 1
				dprintf("udbmatch ==> %s\n", p);
d844 1
d848 1
a848 1
		dprintf("udb_map_lookup(%s, %s)\n", map->map_mname, name);
d865 1
a865 1
	val = udbmatch(key, map->map_file);
d868 9
a876 4
	if (bitset(MF_MATCHONLY, map->map_mflags))
		return map_rewrite(map, name, strlen(name), NULL);
	else
		return map_rewrite(map, val, strlen(val), av);
d957 1
a957 1
			up->udb_pid = getpid();
d963 1
a963 1
# ifdef HESIOD
d966 1
a966 1
			if (strcasecmp(spec, "hesiod") != 0)
d969 1
a969 1
			up->udb_pid = getpid();
d975 1
a975 1
# ifdef NEWDB
d984 3
a986 3
				up->udb_dbname = xalloc(l + 4);
				(void) strlcpy(up->udb_dbname, spec, l + 4);
				(void) strlcat(up->udb_dbname, ".db", l + 4);
d1046 1
a1046 1
					dprintf("dbopen(%s): %s\n",
d1048 1
a1048 1
					dprintf("db_open(%s): %s\n",
d1051 1
a1051 1
						errstring(errno));
d1064 1
a1064 1
							  errstring(errno));
d1067 1
a1067 1
						sm_free(up->udb_dbname);
d1071 1
a1071 1
					sm_free(up->udb_dbname);
d1077 1
a1077 1
				dprintf("_udbx_init: dbopen(%s)\n",
d1079 1
a1079 1
				dprintf("_udbx_init: db_open(%s)\n",
d1084 1
a1084 1
			up->udb_pid = getpid();
d1091 1
a1091 1
# ifdef HESIOD
a1105 1
# if DAEMON
d1107 3
a1109 3
				dprintf("REMOTE: addr %s, timeo %d\n",
					anynet_ntoa((SOCKADDR *) &up->udb_addr),
					up->udb_timeout);
a1110 1
# endif /* DAEMON */
d1113 2
a1114 2
# ifdef NEWDB
				dprintf("FETCH: file %s\n",
d1117 1
a1117 1
				dprintf("FETCH\n");
d1122 1
a1122 1
				dprintf("FORWARD: host %s\n",
d1127 1
a1127 1
				dprintf("HESIOD\n");
d1131 1
a1131 1
				dprintf("UNKNOWN\n");
d1137 1
a1137 1
	UdbInitialized = TRUE;
d1146 1
a1146 1
# ifdef NEWDB
d1157 1
a1157 1
				dprintf("_udbx_init: db->close(%s)\n",
a1205 1
	pid_t pid;
a1210 2
	pid = getpid();

d1213 1
a1213 1
		if (up->udb_pid != pid)
d1216 1
a1216 1
# ifdef NEWDB
d1226 1
a1226 1
			dprintf("_udbx_init: db->close(%s)\n",
d1232 1
a1232 1
# ifdef HESIOD
d1243 1
a1243 1
	if (strlcpy(kbuf, key->data, sizeof kbuf) >= (SIZE_T) sizeof kbuf)
d1254 1
a1254 1
		dprintf("hes_udb_get(%s, %s)\n", name, type);
d1300 1
a1300 1
		dprintf("hes_udb_get => %s\n", *hp);
@


1.3
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d18 1
a18 1
static char id[] = "@@(#)$Sendmail: udb.c,v 8.111.16.1 2001/01/04 18:18:37 gshapiro Exp $ (with USERDB)";
d20 1
a20 1
static char id[] = "@@(#)$Sendmail: udb.c,v 8.111.16.1 2001/01/04 18:18:37 gshapiro Exp $ (without USERDB)";
d293 1
a293 1
						free(user);
d548 1
a548 1
			free(user);
d1058 1
a1058 1
						free(up->udb_dbname);
d1062 1
a1062 1
					free(up->udb_dbname);
@


1.3.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d18 1
a18 1
static char id[] = "@@(#)$Sendmail: udb.c,v 8.111.16.2 2001/05/03 17:24:17 gshapiro Exp $ (with USERDB)";
d20 1
a20 1
static char id[] = "@@(#)$Sendmail: udb.c,v 8.111.16.2 2001/05/03 17:24:17 gshapiro Exp $ (without USERDB)";
d293 1
a293 1
						sm_free(user);
d548 1
a548 1
			sm_free(user);
d1058 1
a1058 1
						sm_free(up->udb_dbname);
d1062 1
a1062 1
					sm_free(up->udb_dbname);
@


1.2
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998, 1999 Sendmail, Inc. and its suppliers.
d18 1
a18 1
static char id[] = "@@(#)$Sendmail: udb.c,v 8.111 1999/11/16 02:04:04 gshapiro Exp $ (with USERDB)";
d20 1
a20 1
static char id[] = "@@(#)$Sendmail: udb.c,v 8.111 1999/11/16 02:04:04 gshapiro Exp $ (without USERDB)";
d1014 4
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.1.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-1999, 2001 Sendmail, Inc. and its suppliers.
d18 1
a18 1
static char id[] = "@@(#)$Sendmail: udb.c,v 8.111.16.2 2001/05/03 17:24:17 gshapiro Exp $ (with USERDB)";
d20 1
a20 1
static char id[] = "@@(#)$Sendmail: udb.c,v 8.111.16.2 2001/05/03 17:24:17 gshapiro Exp $ (without USERDB)";
d293 1
a293 1
						sm_free(user);
d548 1
a548 1
			sm_free(user);
a1013 4
#ifdef DB_OLD_VERSION
						if (ret == DB_OLD_VERSION)
							ret = EINVAL;
#endif /* DB_OLD_VERSION */
d1054 1
a1054 1
						sm_free(up->udb_dbname);
d1058 1
a1058 1
					sm_free(up->udb_dbname);
@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d18 1
a18 1
static char id[] = "@@(#)$Id: udb.c,v 8.111 1999/11/16 02:04:04 gshapiro Exp $ (with USERDB)";
d20 1
a20 1
static char id[] = "@@(#)$Id: udb.c,v 8.111 1999/11/16 02:04:04 gshapiro Exp $ (without USERDB)";
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 7
a22 5
#if USERDB
SM_RCSID("@@(#)$Sendmail: udb.c,v 8.150 2001/09/04 22:54:42 ca Exp $ (with USERDB)")
#else /* USERDB */
SM_RCSID("@@(#)$Sendmail: udb.c,v 8.150 2001/09/04 22:54:42 ca Exp $ (without USERDB)")
#endif /* USERDB */
d26 1
a26 1
# if NEWDB
d73 1
a73 1
# if NEWDB
d102 1
a102 1
# if HESIOD
d105 1
a105 1
static char	*udbmatch __P((char *, char *, SM_RPOOL_T *));
d128 1
a128 1
static bool		UdbInitialized = false;
d151 1
a151 1
		sm_dprintf("udbexpand(%s)\n", a->q_paddr);
d177 4
a184 6
	keylen = sm_strlcpyn(keybuf, sizeof keybuf, 2, user, ":maildrop");

	/* if name is too long, assume it won't match */
	if (keylen > sizeof keybuf)
		return EX_OK;

d186 3
d190 1
a190 1
	breakout = false;
d218 1
a218 1
# if NEWDB
d223 1
a223 1
				sm_dprintf("udbexpand: trying %s (%d) via db\n",
d246 1
a246 1
					sm_dprintf("udbexpand: no match on %s (%d)\n",
d258 1
a258 1
				sm_dprintf("udbexpand: match %.*s: %.*s\n",
d281 1
a281 1
				breakout = true;
d289 1
a289 1
					nuser = sm_malloc_x(usersize + size);
d293 1
a293 1
						sm_free(user); /* XXX */
d342 2
a343 2
					sm_dprintf("udbexpand: QS_EXPANDED ");
					printaddr(a, false);
d361 2
a362 2
			(void) sm_strlcpyn(keybuf, sizeof keybuf, 2, a->q_user,
					   ":mailsender");
d375 1
a375 2
			a->q_owner = sm_rpool_malloc_x(e->e_rpool,
						       info.size + 1);
d382 3
a384 3
				(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
						     "Message delivered to mailing list %s\n",
						     a->q_paddr);
d391 1
a391 1
# if HESIOD
d396 1
a396 1
				sm_dprintf("udbexpand: trying %s (%d) via hesiod\n",
d413 1
a413 1
					sm_dprintf("udbexpand: no match on %s (%d)\n",
d417 1
a417 1
					sm_dprintf("  ... trying hes_getmailhost(%s)\n",
d429 1
a429 1
						sm_dprintf("hes_getmailhost(%s): %d\n",
d437 1
a437 1
						sm_dprintf("hes_getmailhost(%s): expansion too long: %.30s@@%.30s\n",
d444 2
a445 2
				(void) sm_snprintf(pobuf, sizeof pobuf,
					"%s@@%s", hp->po_name, hp->po_host);
d452 1
a452 1
				sm_dprintf("udbexpand: match %.*s: %.*s\n",
d463 1
a463 1
			breakout = true;
d465 1
a465 1
				user = sm_malloc_x(info.size + 1);
d481 2
a482 2
					sm_dprintf("udbexpand: QS_EXPANDED ");
					printaddr(a, false);
d492 2
a493 2
			(void) sm_strlcpyn(keybuf, sizeof keybuf, 2, a->q_user,
					   ":mailsender");
d500 1
a500 2
			a->q_owner = sm_rpool_malloc_x(e->e_rpool,
						       info.size + 1);
d520 1
a520 1
				user = sm_malloc_x(usersize);
d522 2
a523 2
			(void) sm_strlcpyn(user, usersize, 3,
					a->q_user, "@@", up->udb_fwdhost);
d531 2
a532 2
					sm_dprintf("udbexpand: QS_EXPANDED ");
					printaddr(a, false);
d536 1
a536 1
			breakout = true;
d540 1
a540 1
			breakout = true;
a546 1
		/* XXX if an exception occurs, there is a storage leak */
d548 1
a548 1
			sm_free(user); /* XXX */
a556 1
**		rpool -- resource pool from which to allocate result
d560 1
a560 1
**			database.  Storage allocated from rpool.
d568 1
a568 1
udbsender(sender, rpool)
a569 1
	SM_RPOOL_T *rpool;
d571 1
a571 1
	return udbmatch(sender, "mailname", rpool);
a578 1
**		rpool -- resource pool from which to allocate result
d582 1
a582 1
**			database.  Storage allocated from rpool.
d590 1
a590 1
udbmatch(user, field, rpool)
a592 1
	SM_RPOOL_T *rpool;
d602 1
a602 1
		sm_dprintf("udbmatch(%s, %s)\n", user, field);
d630 1
a630 1
	(void) sm_strlcpyn(keybuf, sizeof keybuf, 3, user, ":", field);
d641 1
a641 1
# if NEWDB
d656 1
a656 1
					sm_dprintf("udbmatch: no match on %s (%d) via db\n",
d661 1
a661 1
			p = sm_rpool_malloc_x(rpool, info.size + 1);
d665 1
a665 1
				sm_dprintf("udbmatch ==> %s\n", p);
d669 1
a669 1
# if HESIOD
d677 1
a677 1
					sm_dprintf("udbmatch: no match on %s (%d) via hesiod\n",
d682 1
a682 1
			p = sm_rpool_malloc_x(rpool, info.size + 1);
d686 1
a686 1
				sm_dprintf("udbmatch ==> %s\n", p);
d702 2
a703 1
	(void) sm_strlcpyn(keybuf, sizeof keybuf, 2, user, ":maildrop");
d710 1
a710 1
# if NEWDB
d735 1
a735 1
				up->udb_default = sm_pmalloc_x(info.size + 1);
d761 2
a762 2
			p = sm_rpool_malloc_x(rpool, i);
			(void) sm_strlcpyn(p, i, 3, user, "@@", up->udb_default);
d764 1
a764 1
				sm_dprintf("udbmatch ==> %s\n", p);
d768 1
a768 1
# if HESIOD
d785 1
a785 1
				up->udb_default = sm_pmalloc_x(info.size + 1);
d804 2
a805 2
			p = sm_rpool_malloc_x(rpool, i);
			(void) sm_strlcpyn(p, i, 3, user, "@@", up->udb_default);
d807 1
a807 1
				sm_dprintf("udbmatch ==> %s\n", p);
a840 1
	char *SM_NONVOLATILE result = NULL;
d844 1
a844 1
		sm_dprintf("udb_map_lookup(%s, %s)\n", map->map_mname, name);
d861 1
a861 1
	val = udbmatch(key, map->map_file, NULL);
d864 4
a867 9
	SM_TRY
		if (bitset(MF_MATCHONLY, map->map_mflags))
			result = map_rewrite(map, name, strlen(name), NULL);
		else
			result = map_rewrite(map, val, strlen(val), av);
	SM_FINALLY
		sm_free(val);
	SM_END_TRY
	return result;
d948 1
a948 1
			up->udb_pid = CurrentPid;
d954 1
a954 1
# if HESIOD
d957 1
a957 1
			if (sm_strcasecmp(spec, "hesiod") != 0)
d960 1
a960 1
			up->udb_pid = CurrentPid;
d966 1
a966 1
# if NEWDB
d975 3
a977 3
				up->udb_dbname = sm_pmalloc_x(l + 4);
				(void) sm_strlcpyn(up->udb_dbname, l + 4, 2,
						   spec, ".db");
a1013 4
#ifdef DB_OLD_VERSION
						if (ret == DB_OLD_VERSION)
							ret = EINVAL;
#endif /* DB_OLD_VERSION */
d1033 1
a1033 1
					sm_dprintf("dbopen(%s): %s\n",
d1035 1
a1035 1
					sm_dprintf("db_open(%s): %s\n",
d1038 1
a1038 1
						sm_errstring(errno));
d1051 1
a1051 1
							  sm_errstring(errno));
d1054 1
a1054 1
						sm_free(up->udb_dbname); /* XXX */
d1058 1
a1058 1
					sm_free(up->udb_dbname); /* XXX */
d1064 1
a1064 1
				sm_dprintf("_udbx_init: dbopen(%s)\n",
d1066 1
a1066 1
				sm_dprintf("_udbx_init: db_open(%s)\n",
d1071 1
a1071 1
			up->udb_pid = CurrentPid;
d1078 1
a1078 1
# if HESIOD
d1093 1
d1095 3
a1097 3
				sm_dprintf("REMOTE: addr %s, timeo %d\n",
					   anynet_ntoa((SOCKADDR *) &up->udb_addr),
					   up->udb_timeout);
d1099 1
d1102 2
a1103 2
# if NEWDB
				sm_dprintf("FETCH: file %s\n",
d1106 1
a1106 1
				sm_dprintf("FETCH\n");
d1111 1
a1111 1
				sm_dprintf("FORWARD: host %s\n",
d1116 1
a1116 1
				sm_dprintf("HESIOD\n");
d1120 1
a1120 1
				sm_dprintf("UNKNOWN\n");
d1126 1
a1126 1
	UdbInitialized = true;
d1135 1
a1135 1
# if NEWDB
d1146 1
a1146 1
				sm_dprintf("_udbx_init: db->close(%s)\n",
d1195 1
d1201 2
d1205 1
a1205 1
		if (up->udb_pid != CurrentPid)
d1208 1
a1208 1
# if NEWDB
d1218 1
a1218 1
			sm_dprintf("_udbx_init: db->close(%s)\n",
d1224 1
a1224 1
# if HESIOD
d1235 1
a1235 1
	if (sm_strlcpy(kbuf, key->data, sizeof kbuf) >= sizeof kbuf)
d1246 1
a1246 1
		sm_dprintf("hes_udb_get(%s, %s)\n", name, type);
d1292 1
a1292 1
		sm_dprintf("hes_udb_get => %s\n", *hp);
@


