head	1.32;
access;
symbols
	OPENBSD_5_6:1.31.0.6
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.4
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.30.0.2
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.29.0.2
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.28.0.6
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.4
	OPENBSD_5_0:1.28.0.2
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.27.0.12
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.10
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.6
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.8
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.4
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.26.0.2
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.25.0.4
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.2
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.21.0.8
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.6
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.4
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.18.0.4
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.32
date	2014.09.17.18.49.52;	author matthieu;	state dead;
branches;
next	1.31;
commitid	M7i5giHIoz3DMlTU;

1.31
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.29;

1.29
date	2012.12.26.11.44.12;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2011.05.17.15.54.23;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2008.02.20.12.41.51;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2006.08.13.13.01.48;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2006.08.07.15.41.45;	author moritz;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.22.18.43.55;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2004.06.24.03.59.27;	author millert;	state Exp;
branches
	1.21.6.1
	1.21.8.1;
next	1.20;

1.20
date	2004.01.19.01.41.13;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.17.17.31.40;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.29.19.44.00;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.03.17.31.21;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.01.19.59.22;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.15.02.23.35;	author millert;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2002.06.26.04.48.55;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.03.17.25.47;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.18.00.49.28;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.10.12.17.45.37;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.10.01.17.18.30;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.01.01.01.41;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.29.01.31.15;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.28.02.43.54;	author millert;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.01.15.21.09.08;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.09.23.45.01;	author millert;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.04.07.19.20.41;	author millert;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.04.02.19.05.45;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.45;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.14;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.50;	author millert;	state Exp;
branches;
next	;

1.2.2.1
date	2000.10.10.05.13.39;	author jason;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.31.00.31.36;	author miod;	state Exp;
branches;
next	;

1.5.2.1
date	2001.05.31.01.47.56;	author jason;	state Exp;
branches;
next	;

1.11.2.1
date	2003.03.03.17.16.59;	author miod;	state Exp;
branches;
next	;

1.15.2.1
date	2003.03.03.17.19.45;	author brad;	state Exp;
branches;
next	;

1.21.6.1
date	2006.08.08.20.33.12;	author brad;	state Exp;
branches;
next	;

1.21.8.1
date	2006.08.08.20.20.42;	author brad;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2006, 2008, 2009, 2011 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#define _DEFINE
#include <sendmail.h>
#include <sm/sendmail.h>
#include <sm/xtrap.h>
#include <sm/signal.h>

#ifndef lint
SM_UNUSED(static char copyright[]) =
"@@(#) Copyright (c) 1998-2013 Proofpoint, Inc. and its suppliers.\n\
	All rights reserved.\n\
     Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.\n\
     Copyright (c) 1988, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* ! lint */

SM_RCSID("@@(#)$Sendmail: main.c,v 8.988 2013/11/23 02:52:37 gshapiro Exp $")


#if NETINET || NETINET6
# include <arpa/inet.h>
#endif /* NETINET || NETINET6 */

/* for getcfname() */
#include <sendmail/pathnames.h>

static SM_DEBUG_T
DebugNoPRestart = SM_DEBUG_INITIALIZER("no_persistent_restart",
	"@@(#)$Debug: no_persistent_restart - don't restart, log only $");

static void	dump_class __P((STAB *, int));
static void	obsolete __P((char **));
static void	testmodeline __P((char *, ENVELOPE *));
static char	*getextenv __P((const char *));
static void	sm_printoptions __P((char **));
static SIGFUNC_DECL	intindebug __P((int));
static SIGFUNC_DECL	sighup __P((int));
static SIGFUNC_DECL	sigpipe __P((int));
static SIGFUNC_DECL	sigterm __P((int));
#ifdef SIGUSR1
static SIGFUNC_DECL	sigusr1 __P((int));
#endif /* SIGUSR1 */

/*
**  SENDMAIL -- Post mail to a set of destinations.
**
**	This is the basic mail router.  All user mail programs should
**	call this routine to actually deliver mail.  Sendmail in
**	turn calls a bunch of mail servers that do the real work of
**	delivering the mail.
**
**	Sendmail is driven by settings read in from /etc/mail/sendmail.cf
**	(read by readcf.c).
**
**	Usage:
**		/usr/lib/sendmail [flags] addr ...
**
**		See the associated documentation for details.
**
**	Authors:
**		Eric Allman, UCB/INGRES (until 10/81).
**			     Britton-Lee, Inc., purveyors of fine
**				database computers (11/81 - 10/88).
**			     International Computer Science Institute
**				(11/88 - 9/89).
**			     UCB/Mammoth Project (10/89 - 7/95).
**			     InReference, Inc. (8/95 - 1/97).
**			     Sendmail, Inc. (1/98 - 9/13).
**		The support of my employers is gratefully acknowledged.
**			Few of them (Britton-Lee in particular) have had
**			anything to gain from my involvement in this project.
**
**		Gregory Neil Shapiro,
**			Worcester Polytechnic Institute	(until 3/98).
**			Sendmail, Inc. (3/98 - 10/13).
**			Proofpoint, Inc. (10/13 - present).
**
**		Claus Assmann,
**			Sendmail, Inc. (12/98 - 10/13).
**			Proofpoint, Inc. (10/13 - present).
*/

char		*FullName;	/* sender's full name */
ENVELOPE	BlankEnvelope;	/* a "blank" envelope */
static ENVELOPE	MainEnvelope;	/* the envelope around the basic letter */
ADDRESS		NullAddress =	/* a null address */
		{ "", "", NULL, "" };
char		*CommandLineArgs;	/* command line args for pid file */
bool		Warn_Q_option = false;	/* warn about Q option use */
static int	MissingFds = 0;	/* bit map of fds missing on startup */
char		*Mbdb = "pw";	/* mailbox database defaults to /etc/passwd */

#ifdef NGROUPS_MAX
GIDSET_T	InitialGidSet[NGROUPS_MAX];
#endif /* NGROUPS_MAX */

#define MAXCONFIGLEVEL	10	/* highest config version level known */

#if SASL
static sasl_callback_t srvcallbacks[] =
{
	{	SASL_CB_VERIFYFILE,	(sasl_callback_ft)&safesaslfile,	NULL	},
	{	SASL_CB_PROXY_POLICY,	(sasl_callback_ft)&proxy_policy,	NULL	},
	{	SASL_CB_LIST_END,	NULL,		NULL	}
};
#endif /* SASL */

unsigned int	SubmitMode;
int		SyslogPrefixLen; /* estimated length of syslog prefix */
#define PIDLEN		6	/* pid length for computing SyslogPrefixLen */
#ifndef SL_FUDGE
# define SL_FUDGE	10	/* fudge offset for SyslogPrefixLen */
#endif /* ! SL_FUDGE */
#define SLDLL		8	/* est. length of default syslog label */


/* Some options are dangerous to allow users to use in non-submit mode */
#define CHECK_AGAINST_OPMODE(cmd)					\
{									\
	if (extraprivs &&						\
	    OpMode != MD_DELIVER && OpMode != MD_SMTP &&		\
	    OpMode != MD_ARPAFTP && OpMode != MD_CHECKCONFIG &&		\
	    OpMode != MD_VERIFY && OpMode != MD_TEST)			\
	{								\
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,		\
				     "WARNING: Ignoring submission mode -%c option (not in submission mode)\n", \
		       (cmd));						\
		break;							\
	}								\
	if (extraprivs && queuerun)					\
	{								\
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,		\
				     "WARNING: Ignoring submission mode -%c option with -q\n", \
		       (cmd));						\
		break;							\
	}								\
}

int
main(argc, argv, envp)
	int argc;
	char **argv;
	char **envp;
{
	register char *p;
	char **av;
	extern char Version[];
	char *ep, *from;
	STAB *st;
	register int i;
	int j;
	int dp;
	int fill_errno;
	int qgrp = NOQGRP;		/* queue group to process */
	bool safecf = true;
	BITMAP256 *p_flags = NULL;	/* daemon flags */
	bool warn_C_flag = false;
	bool auth = true;		/* whether to set e_auth_param */
	char warn_f_flag = '\0';
	bool run_in_foreground = false;	/* -bD mode */
	bool queuerun = false, debug = false;
	struct passwd *pw;
	struct hostent *hp;
	char *nullserver = NULL;
	char *authinfo = NULL;
	char *sysloglabel = NULL;	/* label for syslog */
	char *conffile = NULL;		/* name of .cf file */
	char *queuegroup = NULL;	/* queue group to process */
	char *quarantining = NULL;	/* quarantine queue items? */
	bool extraprivs;
	bool forged, negate;
	bool queuepersistent = false;	/* queue runner process runs forever */
	bool foregroundqueue = false;	/* queue run in foreground */
	bool save_val;			/* to save some bool var. */
	int cftype;			/* which cf file to use? */
	SM_FILE_T *smdebug;
	static time_t starttime = 0;	/* when was process started */
	struct stat traf_st;		/* for TrafficLog FIFO check */
	char buf[MAXLINE];
	char jbuf[MAXHOSTNAMELEN];	/* holds MyHostName */
	static char rnamebuf[MAXNAME];	/* holds RealUserName */
	char *emptyenviron[1];
#if STARTTLS
	bool tls_ok;
#endif /* STARTTLS */
	QUEUE_CHAR *new;
	ENVELOPE *e;
	extern int DtableSize;
	extern int optind;
	extern int opterr;
	extern char *optarg;
	extern char **environ;
#if SASL
	extern void sm_sasl_init __P((void));
#endif /* SASL */

#if USE_ENVIRON
	envp = environ;
#endif /* USE_ENVIRON */

	/* turn off profiling */
	SM_PROF(0);

	/* install default exception handler */
	sm_exc_newthread(fatal_error);

	/* set the default in/out channel so errors reported to screen */
	InChannel = smioin;
	OutChannel = smioout;

	/*
	**  Check to see if we reentered.
	**	This would normally happen if e_putheader or e_putbody
	**	were NULL when invoked.
	*/

	if (starttime != 0)
	{
		syserr("main: reentered!");
		abort();
	}
	starttime = curtime();

	/* avoid null pointer dereferences */
	TermEscape.te_rv_on = TermEscape.te_under_on = TermEscape.te_normal = "";

	RealUid = getuid();
	RealGid = getgid();

	/* Check if sendmail is running with extra privs */
	extraprivs = (RealUid != 0 &&
		      (geteuid() != getuid() || getegid() != getgid()));

	CurrentPid = getpid();

	/* get whatever .cf file is right for the opmode */
	cftype = SM_GET_RIGHT_CF;

	/* in 4.4BSD, the table can be huge; impose a reasonable limit */
	DtableSize = getdtsize();
	if (DtableSize > 256)
		DtableSize = 256;

	/*
	**  Be sure we have enough file descriptors.
	**	But also be sure that 0, 1, & 2 are open.
	*/

	/* reset errno and fill_errno; the latter is used way down below */
	errno = fill_errno = 0;
	fill_fd(STDIN_FILENO, NULL);
	if (errno != 0)
		fill_errno = errno;
	fill_fd(STDOUT_FILENO, NULL);
	if (errno != 0)
		fill_errno = errno;
	fill_fd(STDERR_FILENO, NULL);
	if (errno != 0)
		fill_errno = errno;

	sm_closefrom(STDERR_FILENO + 1, DtableSize);
	errno = 0;
	smdebug = NULL;

#if LOG
# ifndef SM_LOG_STR
#  define SM_LOG_STR	"sendmail"
# endif /* ! SM_LOG_STR */
#  ifdef LOG_MAIL
	openlog(SM_LOG_STR, LOG_PID, LOG_MAIL);
#  else /* LOG_MAIL */
	openlog(SM_LOG_STR, LOG_PID);
#  endif /* LOG_MAIL */
#endif /* LOG */

	/*
	**  Seed the random number generator.
	**  Used for queue file names, picking a queue directory, and
	**  MX randomization.
	*/

	seed_random();

	/* do machine-dependent initializations */
	init_md(argc, argv);


	SyslogPrefixLen = PIDLEN + (MAXQFNAME - 3) + SL_FUDGE + SLDLL;

	/* reset status from syserr() calls for missing file descriptors */
	Errors = 0;
	ExitStat = EX_OK;

	SubmitMode = SUBMIT_UNKNOWN;
#if _FFR_LOCAL_DAEMON
	LocalDaemon = false;
# if NETINET6
	V6LoopbackAddrFound = false;
# endif /* NETINET6 */
#endif /* _FFR_LOCAL_DAEMON */
#if XDEBUG
	checkfd012("after openlog");
#endif /* XDEBUG */

	tTsetup(tTdvect, sizeof(tTdvect), "0-99.1,*_trace_*.1");

#ifdef NGROUPS_MAX
	/* save initial group set for future checks */
	i = getgroups(NGROUPS_MAX, InitialGidSet);
	if (i <= 0)
	{
		InitialGidSet[0] = (GID_T) -1;
		i = 0;
	}
	while (i < NGROUPS_MAX)
		InitialGidSet[i++] = InitialGidSet[0];
#endif /* NGROUPS_MAX */

	/* drop group id privileges (RunAsUser not yet set) */
	dp = drop_privileges(false);
	setstat(dp);

#ifdef SIGUSR1
	/* Only allow root (or non-set-*-ID binaries) to use SIGUSR1 */
	if (!extraprivs)
	{
		/* arrange to dump state on user-1 signal */
		(void) sm_signal(SIGUSR1, sigusr1);
	}
	else
	{
		/* ignore user-1 signal */
		(void) sm_signal(SIGUSR1, SIG_IGN);
	}
#endif /* SIGUSR1 */

	/* initialize for setproctitle */
	initsetproctitle(argc, argv, envp);

	/* Handle any non-getoptable constructions. */
	obsolete(argv);

	/*
	**  Do a quick prescan of the argument list.
	*/


	/* find initial opMode */
	OpMode = MD_DELIVER;
	av = argv;
	p = strrchr(*av, '/');
	if (p++ == NULL)
		p = *av;
	if (strcmp(p, "newaliases") == 0)
		OpMode = MD_INITALIAS;
	else if (strcmp(p, "mailq") == 0)
		OpMode = MD_PRINT;
	else if (strcmp(p, "smtpd") == 0)
		OpMode = MD_DAEMON;
	else if (strcmp(p, "hoststat") == 0)
		OpMode = MD_HOSTSTAT;
	else if (strcmp(p, "purgestat") == 0)
		OpMode = MD_PURGESTAT;

#if defined(__osf__) || defined(_AIX3)
# define OPTIONS	"A:B:b:C:cD:d:e:F:f:Gh:IiL:M:mN:nO:o:p:Q:q:R:r:sTtV:vX:x"
#endif /* defined(__osf__) || defined(_AIX3) */
#if defined(sony_news)
# define OPTIONS	"A:B:b:C:cD:d:E:e:F:f:Gh:IiJ:L:M:mN:nO:o:p:Q:q:R:r:sTtV:vX:"
#endif /* defined(sony_news) */
#ifndef OPTIONS
# define OPTIONS	"A:B:b:C:cD:d:e:F:f:Gh:IiL:M:mN:nO:o:p:Q:q:R:r:sTtV:vX:"
#endif /* ! OPTIONS */

	/* Set to 0 to allow -b; need to check optarg before using it! */
	opterr = 0;
	while ((j = getopt(argc, argv, OPTIONS)) != -1)
	{
		switch (j)
		{
		  case 'b':	/* operations mode */
			j = (optarg == NULL) ? ' ' : *optarg;
			switch (j)
			{
			  case MD_DAEMON:
			  case MD_FGDAEMON:
			  case MD_SMTP:
			  case MD_INITALIAS:
			  case MD_DELIVER:
			  case MD_VERIFY:
			  case MD_TEST:
			  case MD_PRINT:
			  case MD_PRINTNQE:
			  case MD_HOSTSTAT:
			  case MD_PURGESTAT:
			  case MD_ARPAFTP:
#if _FFR_CHECKCONFIG
			  case MD_CHECKCONFIG:
#endif /* _FFR_CHECKCONFIG */
				OpMode = j;
				break;

#if _FFR_LOCAL_DAEMON
			  case MD_LOCAL:
				OpMode = MD_DAEMON;
				LocalDaemon = true;
				break;
#endif /* _FFR_LOCAL_DAEMON */

			  case MD_FREEZE:
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Frozen configurations unsupported\n");
				return EX_USAGE;

			  default:
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Invalid operation mode %c\n",
						     j);
				return EX_USAGE;
			}
			break;

		  case 'D':
			if (debug)
			{
				errno = 0;
				syserr("-D file must be before -d");
				ExitStat = EX_USAGE;
				break;
			}
			dp = drop_privileges(true);
			setstat(dp);
			smdebug = sm_io_open(SmFtStdio, SM_TIME_DEFAULT,
					    optarg, SM_IO_APPEND, NULL);
			if (smdebug == NULL)
			{
				syserr("cannot open %s", optarg);
				ExitStat = EX_CANTCREAT;
				break;
			}
			sm_debug_setfile(smdebug);
			break;

		  case 'd':
			debug = true;
			tTflag(optarg);
			(void) sm_io_setvbuf(sm_debug_file(), SM_TIME_DEFAULT,
					     (char *) NULL, SM_IO_NBF,
					     SM_IO_BUFSIZ);
			break;

		  case 'G':	/* relay (gateway) submission */
			SubmitMode = SUBMIT_MTA;
			break;

		  case 'L':
			if (optarg == NULL)
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "option requires an argument -- '%c'",
						     (char) j);
				return EX_USAGE;
			}
			j = SM_MIN(strlen(optarg), 32) + 1;
			sysloglabel = xalloc(j);
			(void) sm_strlcpy(sysloglabel, optarg, j);
			SyslogPrefixLen = PIDLEN + (MAXQFNAME - 3) +
					  SL_FUDGE + j;
			break;

		  case 'Q':
		  case 'q':
			/* just check if it is there */
			queuerun = true;
			break;
		}
	}
	opterr = 1;

	/* Don't leak queue information via debug flags */
	if (extraprivs && queuerun && debug)
	{
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "WARNING: Can not use -d with -q.  Disabling debugging.\n");
		sm_debug_close();
		sm_debug_setfile(NULL);
		(void) memset(tTdvect, '\0', sizeof(tTdvect));
	}

#if LOG
	if (sysloglabel != NULL)
	{
		/* Sanitize the string */
		for (p = sysloglabel; *p != '\0'; p++)
		{
			if (!isascii(*p) || !isprint(*p) || *p == '%')
				*p = '*';
		}
		closelog();
#  ifdef LOG_MAIL
		openlog(sysloglabel, LOG_PID, LOG_MAIL);
#  else /* LOG_MAIL */
		openlog(sysloglabel, LOG_PID);
#  endif /* LOG_MAIL */
	}
#endif /* LOG */

	/* set up the blank envelope */
	BlankEnvelope.e_puthdr = putheader;
	BlankEnvelope.e_putbody = putbody;
	BlankEnvelope.e_xfp = NULL;
	STRUCTCOPY(NullAddress, BlankEnvelope.e_from);
	CurEnv = &BlankEnvelope;
	STRUCTCOPY(NullAddress, MainEnvelope.e_from);

	/*
	**  Set default values for variables.
	**	These cannot be in initialized data space.
	*/

	setdefaults(&BlankEnvelope);
	initmacros(&BlankEnvelope);

	/* reset macro */
	set_op_mode(OpMode);
	if (OpMode == MD_DAEMON)
		DaemonPid = CurrentPid;	/* needed for finis() to work */

	pw = sm_getpwuid(RealUid);
	if (pw != NULL)
		(void) sm_strlcpy(rnamebuf, pw->pw_name, sizeof(rnamebuf));
	else
		(void) sm_snprintf(rnamebuf, sizeof(rnamebuf), "Unknown UID %d",
				   (int) RealUid);

	RealUserName = rnamebuf;

	if (tTd(0, 101))
	{
		sm_dprintf("Version %s\n", Version);
		finis(false, true, EX_OK);
		/* NOTREACHED */
	}

	/*
	**  if running non-set-user-ID binary as non-root, pretend
	**  we are the RunAsUid
	*/

	if (RealUid != 0 && geteuid() == RealUid)
	{
		if (tTd(47, 1))
			sm_dprintf("Non-set-user-ID binary: RunAsUid = RealUid = %d\n",
				   (int) RealUid);
		RunAsUid = RealUid;
	}
	else if (geteuid() != 0)
		RunAsUid = geteuid();

	EffGid = getegid();
	if (RealUid != 0 && EffGid == RealGid)
		RunAsGid = RealGid;

	if (tTd(47, 5))
	{
		sm_dprintf("main: e/ruid = %d/%d e/rgid = %d/%d\n",
			   (int) geteuid(), (int) getuid(),
			   (int) getegid(), (int) getgid());
		sm_dprintf("main: RunAsUser = %d:%d\n",
			   (int) RunAsUid, (int) RunAsGid);
	}

	/* save command line arguments */
	j = 0;
	for (av = argv; *av != NULL; )
		j += strlen(*av++) + 1;
	SaveArgv = (char **) xalloc(sizeof(char *) * (argc + 1));
	CommandLineArgs = xalloc(j);
	p = CommandLineArgs;
	for (av = argv, i = 0; *av != NULL; )
	{
		int h;

		SaveArgv[i++] = newstr(*av);
		if (av != argv)
			*p++ = ' ';
		(void) sm_strlcpy(p, *av++, j);
		h = strlen(p);
		p += h;
		j -= h + 1;
	}
	SaveArgv[i] = NULL;

	if (tTd(0, 1))
	{
		extern char *CompileOptions[];

		sm_dprintf("Version %s\n Compiled with:", Version);
		sm_printoptions(CompileOptions);
	}
	if (tTd(0, 10))
	{
		extern char *OsCompileOptions[];

		sm_dprintf("    OS Defines:");
		sm_printoptions(OsCompileOptions);
#ifdef _PATH_UNIX
		sm_dprintf("Kernel symbols:\t%s\n", _PATH_UNIX);
#endif /* _PATH_UNIX */

		sm_dprintf("     Conf file:\t%s (default for MSP)\n",
			   getcfname(OpMode, SubmitMode, SM_GET_SUBMIT_CF,
				     conffile));
		sm_dprintf("     Conf file:\t%s (default for MTA)\n",
			   getcfname(OpMode, SubmitMode, SM_GET_SENDMAIL_CF,
				     conffile));
		sm_dprintf("      Pid file:\t%s (default)\n", PidFile);
	}

	if (tTd(0, 12))
	{
		extern char *SmCompileOptions[];

		sm_dprintf(" libsm Defines:");
		sm_printoptions(SmCompileOptions);
	}

	if (tTd(0, 13))
	{
		extern char *FFRCompileOptions[];

		sm_dprintf("   FFR Defines:");
		sm_printoptions(FFRCompileOptions);
	}

	/* clear sendmail's environment */
	ExternalEnviron = environ;
	emptyenviron[0] = NULL;
	environ = emptyenviron;

	/*
	**  restore any original TZ setting until TimeZoneSpec has been
	**  determined - or early log messages may get bogus time stamps
	*/

	if ((p = getextenv("TZ")) != NULL)
	{
		char *tz;
		int tzlen;

		/* XXX check for reasonable length? */
		tzlen = strlen(p) + 4;
		tz = xalloc(tzlen);
		(void) sm_strlcpyn(tz, tzlen, 2, "TZ=", p);

		/* XXX check return code? */
		(void) putenv(tz);
	}

	/* prime the child environment */
	sm_setuserenv("AGENT", "sendmail");

	(void) sm_signal(SIGPIPE, SIG_IGN);
	OldUmask = umask(022);
	FullName = getextenv("NAME");
	if (FullName != NULL)
		FullName = newstr(FullName);

	/*
	**  Initialize name server if it is going to be used.
	*/

#if NAMED_BIND
	if (!bitset(RES_INIT, _res.options))
		(void) res_init();
	if (tTd(8, 8))
		_res.options |= RES_DEBUG;
	else
		_res.options &= ~RES_DEBUG;
# ifdef RES_NOALIASES
	_res.options |= RES_NOALIASES;
# endif /* RES_NOALIASES */
	TimeOuts.res_retry[RES_TO_DEFAULT] = _res.retry;
	TimeOuts.res_retry[RES_TO_FIRST] = _res.retry;
	TimeOuts.res_retry[RES_TO_NORMAL] = _res.retry;
	TimeOuts.res_retrans[RES_TO_DEFAULT] = _res.retrans;
	TimeOuts.res_retrans[RES_TO_FIRST] = _res.retrans;
	TimeOuts.res_retrans[RES_TO_NORMAL] = _res.retrans;
#endif /* NAMED_BIND */

	errno = 0;
	from = NULL;

	/* initialize some macros, etc. */
	init_vendor_macros(&BlankEnvelope);

	/* version */
	macdefine(&BlankEnvelope.e_macro, A_PERM, 'v', Version);

	/* hostname */
	hp = myhostname(jbuf, sizeof(jbuf));
	if (jbuf[0] != '\0')
	{
		struct utsname utsname;

		if (tTd(0, 4))
			sm_dprintf("Canonical name: %s\n", jbuf);
		macdefine(&BlankEnvelope.e_macro, A_TEMP, 'w', jbuf);
		macdefine(&BlankEnvelope.e_macro, A_TEMP, 'j', jbuf);
		setclass('w', jbuf);

		p = strchr(jbuf, '.');
		if (p != NULL && p[1] != '\0')
			macdefine(&BlankEnvelope.e_macro, A_TEMP, 'm', &p[1]);

		if (uname(&utsname) >= 0)
			p = utsname.nodename;
		else
		{
			if (tTd(0, 22))
				sm_dprintf("uname failed (%s)\n",
					   sm_errstring(errno));
			makelower(jbuf);
			p = jbuf;
		}
		if (tTd(0, 4))
			sm_dprintf(" UUCP nodename: %s\n", p);
		macdefine(&BlankEnvelope.e_macro, A_TEMP, 'k', p);
		setclass('k', p);
		setclass('w', p);
	}
	if (hp != NULL)
	{
		for (av = hp->h_aliases; av != NULL && *av != NULL; av++)
		{
			if (tTd(0, 4))
				sm_dprintf("\ta.k.a.: %s\n", *av);
			setclass('w', *av);
		}
#if NETINET || NETINET6
		for (i = 0; i >= 0 && hp->h_addr_list[i] != NULL; i++)
		{
# if NETINET6
			char *addr;
			char buf6[INET6_ADDRSTRLEN];
			struct in6_addr ia6;
# endif /* NETINET6 */
# if NETINET
			struct in_addr ia;
# endif /* NETINET */
			char ipbuf[103];

			ipbuf[0] = '\0';
			switch (hp->h_addrtype)
			{
# if NETINET
			  case AF_INET:
				if (hp->h_length != INADDRSZ)
					break;

				memmove(&ia, hp->h_addr_list[i], INADDRSZ);
				(void) sm_snprintf(ipbuf, sizeof(ipbuf),
						   "[%.100s]", inet_ntoa(ia));
				break;
# endif /* NETINET */

# if NETINET6
			  case AF_INET6:
				if (hp->h_length != IN6ADDRSZ)
					break;

				memmove(&ia6, hp->h_addr_list[i], IN6ADDRSZ);
				addr = anynet_ntop(&ia6, buf6, sizeof(buf6));
				if (addr != NULL)
					(void) sm_snprintf(ipbuf, sizeof(ipbuf),
							   "[%.100s]", addr);
				break;
# endif /* NETINET6 */
			}
			if (ipbuf[0] == '\0')
				break;

			if (tTd(0, 4))
				sm_dprintf("\ta.k.a.: %s\n", ipbuf);
			setclass('w', ipbuf);
		}
#endif /* NETINET || NETINET6 */
#if NETINET6
		freehostent(hp);
		hp = NULL;
#endif /* NETINET6 */
	}

	/* current time */
	macdefine(&BlankEnvelope.e_macro, A_TEMP, 'b', arpadate((char *) NULL));

	/* current load average */
	sm_getla();

	QueueLimitRecipient = (QUEUE_CHAR *) NULL;
	QueueLimitSender = (QUEUE_CHAR *) NULL;
	QueueLimitId = (QUEUE_CHAR *) NULL;
	QueueLimitQuarantine = (QUEUE_CHAR *) NULL;

	/*
	**  Crack argv.
	*/

	optind = 1;
	while ((j = getopt(argc, argv, OPTIONS)) != -1)
	{
		switch (j)
		{
		  case 'b':	/* operations mode */
			/* already done */
			break;

		  case 'A':	/* use Alternate sendmail/submit.cf */
			cftype = optarg[0] == 'c' ? SM_GET_SUBMIT_CF
						  : SM_GET_SENDMAIL_CF;
			break;

		  case 'B':	/* body type */
			CHECK_AGAINST_OPMODE(j);
			BlankEnvelope.e_bodytype = newstr(optarg);
			break;

		  case 'C':	/* select configuration file (already done) */
			if (RealUid != 0)
				warn_C_flag = true;
			conffile = newstr(optarg);
			dp = drop_privileges(true);
			setstat(dp);
			safecf = false;
			break;

		  case 'D':
		  case 'd':	/* debugging */
			/* already done */
			break;

		  case 'f':	/* from address */
		  case 'r':	/* obsolete -f flag */
			CHECK_AGAINST_OPMODE(j);
			if (from != NULL)
			{
				usrerr("More than one \"from\" person");
				ExitStat = EX_USAGE;
				break;
			}
			if (optarg[0] == '\0')
				from = newstr("<>");
			else
				from = newstr(denlstring(optarg, true, true));
			if (strcmp(RealUserName, from) != 0)
				warn_f_flag = j;
			break;

		  case 'F':	/* set full name */
			CHECK_AGAINST_OPMODE(j);
			FullName = newstr(optarg);
			break;

		  case 'G':	/* relay (gateway) submission */
			/* already set */
			CHECK_AGAINST_OPMODE(j);
			break;

		  case 'h':	/* hop count */
			CHECK_AGAINST_OPMODE(j);
			BlankEnvelope.e_hopcount = (short) strtol(optarg, &ep,
								  10);
			(void) sm_snprintf(buf, sizeof(buf), "%d",
					   BlankEnvelope.e_hopcount);
			macdefine(&BlankEnvelope.e_macro, A_TEMP, 'c', buf);

			if (*ep)
			{
				usrerr("Bad hop count (%s)", optarg);
				ExitStat = EX_USAGE;
			}
			break;

		  case 'L':	/* program label */
			/* already set */
			break;

		  case 'n':	/* don't alias */
			CHECK_AGAINST_OPMODE(j);
			NoAlias = true;
			break;

		  case 'N':	/* delivery status notifications */
			CHECK_AGAINST_OPMODE(j);
			DefaultNotify |= QHASNOTIFY;
			macdefine(&BlankEnvelope.e_macro, A_TEMP,
				macid("{dsn_notify}"), optarg);
			if (sm_strcasecmp(optarg, "never") == 0)
				break;
			for (p = optarg; p != NULL; optarg = p)
			{
				p = strchr(p, ',');
				if (p != NULL)
					*p++ = '\0';
				if (sm_strcasecmp(optarg, "success") == 0)
					DefaultNotify |= QPINGONSUCCESS;
				else if (sm_strcasecmp(optarg, "failure") == 0)
					DefaultNotify |= QPINGONFAILURE;
				else if (sm_strcasecmp(optarg, "delay") == 0)
					DefaultNotify |= QPINGONDELAY;
				else
				{
					usrerr("Invalid -N argument");
					ExitStat = EX_USAGE;
				}
			}
			break;

		  case 'o':	/* set option */
			setoption(*optarg, optarg + 1, false, true,
				  &BlankEnvelope);
			break;

		  case 'O':	/* set option (long form) */
			setoption(' ', optarg, false, true, &BlankEnvelope);
			break;

		  case 'p':	/* set protocol */
			CHECK_AGAINST_OPMODE(j);
			p = strchr(optarg, ':');
			if (p != NULL)
			{
				*p++ = '\0';
				if (*p != '\0')
				{
					i = strlen(p) + 1;
					ep = sm_malloc_x(i);
					cleanstrcpy(ep, p, i);
					macdefine(&BlankEnvelope.e_macro,
						  A_HEAP, 's', ep);
				}
			}
			if (*optarg != '\0')
			{
				i = strlen(optarg) + 1;
				ep = sm_malloc_x(i);
				cleanstrcpy(ep, optarg, i);
				macdefine(&BlankEnvelope.e_macro, A_HEAP,
					  'r', ep);
			}
			break;

		  case 'Q':	/* change quarantining on queued items */
			/* sanity check */
			if (OpMode != MD_DELIVER &&
			    OpMode != MD_QUEUERUN)
			{
				usrerr("Can not use -Q with -b%c", OpMode);
				ExitStat = EX_USAGE;
				break;
			}

			if (OpMode == MD_DELIVER)
				set_op_mode(MD_QUEUERUN);

			FullName = NULL;

			quarantining = newstr(optarg);
			break;

		  case 'q':	/* run queue files at intervals */
			/* sanity check */
			if (OpMode != MD_DELIVER &&
			    OpMode != MD_DAEMON &&
			    OpMode != MD_FGDAEMON &&
			    OpMode != MD_PRINT &&
			    OpMode != MD_PRINTNQE &&
			    OpMode != MD_QUEUERUN)
			{
				usrerr("Can not use -q with -b%c", OpMode);
				ExitStat = EX_USAGE;
				break;
			}

			/* don't override -bd, -bD or -bp */
			if (OpMode == MD_DELIVER)
				set_op_mode(MD_QUEUERUN);

			FullName = NULL;
			negate = optarg[0] == '!';
			if (negate)
			{
				/* negate meaning of pattern match */
				optarg++; /* skip '!' for next switch */
			}

			switch (optarg[0])
			{
			  case 'G': /* Limit by queue group name */
				if (negate)
				{
					usrerr("Can not use -q!G");
					ExitStat = EX_USAGE;
					break;
				}
				if (queuegroup != NULL)
				{
					usrerr("Can not use multiple -qG options");
					ExitStat = EX_USAGE;
					break;
				}
				queuegroup = newstr(&optarg[1]);
				break;

			  case 'I': /* Limit by ID */
				new = (QUEUE_CHAR *) xalloc(sizeof(*new));
				new->queue_match = newstr(&optarg[1]);
				new->queue_negate = negate;
				new->queue_next = QueueLimitId;
				QueueLimitId = new;
				break;

			  case 'R': /* Limit by recipient */
				new = (QUEUE_CHAR *) xalloc(sizeof(*new));
				new->queue_match = newstr(&optarg[1]);
				new->queue_negate = negate;
				new->queue_next = QueueLimitRecipient;
				QueueLimitRecipient = new;
				break;

			  case 'S': /* Limit by sender */
				new = (QUEUE_CHAR *) xalloc(sizeof(*new));
				new->queue_match = newstr(&optarg[1]);
				new->queue_negate = negate;
				new->queue_next = QueueLimitSender;
				QueueLimitSender = new;
				break;

			  case 'f': /* foreground queue run */
				foregroundqueue  = true;
				break;

			  case 'Q': /* Limit by quarantine message */
				if (optarg[1] != '\0')
				{
					new = (QUEUE_CHAR *) xalloc(sizeof(*new));
					new->queue_match = newstr(&optarg[1]);
					new->queue_negate = negate;
					new->queue_next = QueueLimitQuarantine;
					QueueLimitQuarantine = new;
				}
				QueueMode = QM_QUARANTINE;
				break;

			  case 'L': /* act on lost items */
				QueueMode = QM_LOST;
				break;

			  case 'p': /* Persistent queue */
				queuepersistent = true;
				if (QueueIntvl == 0)
					QueueIntvl = 1;
				if (optarg[1] == '\0')
					break;
				++optarg;
				/* FALLTHROUGH */

			  default:
				i = Errors;
				QueueIntvl = convtime(optarg, 'm');
				if (QueueIntvl < 0)
				{
					usrerr("Invalid -q value");
					ExitStat = EX_USAGE;
				}

				/* check for bad conversion */
				if (i < Errors)
					ExitStat = EX_USAGE;
				break;
			}
			break;

		  case 'R':	/* DSN RET: what to return */
			CHECK_AGAINST_OPMODE(j);
			if (bitset(EF_RET_PARAM, BlankEnvelope.e_flags))
			{
				usrerr("Duplicate -R flag");
				ExitStat = EX_USAGE;
				break;
			}
			BlankEnvelope.e_flags |= EF_RET_PARAM;
			if (sm_strcasecmp(optarg, "hdrs") == 0)
				BlankEnvelope.e_flags |= EF_NO_BODY_RETN;
			else if (sm_strcasecmp(optarg, "full") != 0)
			{
				usrerr("Invalid -R value");
				ExitStat = EX_USAGE;
			}
			macdefine(&BlankEnvelope.e_macro, A_TEMP,
				  macid("{dsn_ret}"), optarg);
			break;

		  case 't':	/* read recipients from message */
			CHECK_AGAINST_OPMODE(j);
			GrabTo = true;
			break;

		  case 'V':	/* DSN ENVID: set "original" envelope id */
			CHECK_AGAINST_OPMODE(j);
			if (!xtextok(optarg))
			{
				usrerr("Invalid syntax in -V flag");
				ExitStat = EX_USAGE;
			}
			else
			{
				BlankEnvelope.e_envid = newstr(optarg);
				macdefine(&BlankEnvelope.e_macro, A_TEMP,
					  macid("{dsn_envid}"), optarg);
			}
			break;

		  case 'X':	/* traffic log file */
			dp = drop_privileges(true);
			setstat(dp);
			if (stat(optarg, &traf_st) == 0 &&
			    S_ISFIFO(traf_st.st_mode))
				TrafficLogFile = sm_io_open(SmFtStdio,
							    SM_TIME_DEFAULT,
							    optarg,
							    SM_IO_WRONLY, NULL);
			else
				TrafficLogFile = sm_io_open(SmFtStdio,
							    SM_TIME_DEFAULT,
							    optarg,
							    SM_IO_APPEND, NULL);
			if (TrafficLogFile == NULL)
			{
				syserr("cannot open %s", optarg);
				ExitStat = EX_CANTCREAT;
				break;
			}
			(void) sm_io_setvbuf(TrafficLogFile, SM_TIME_DEFAULT,
					     NULL, SM_IO_LBF, 0);
			break;

			/* compatibility flags */
		  case 'c':	/* connect to non-local mailers */
		  case 'i':	/* don't let dot stop me */
		  case 'm':	/* send to me too */
		  case 'T':	/* set timeout interval */
		  case 'v':	/* give blow-by-blow description */
			setoption(j, "T", false, true, &BlankEnvelope);
			break;

		  case 'e':	/* error message disposition */
		  case 'M':	/* define macro */
			setoption(j, optarg, false, true, &BlankEnvelope);
			break;

		  case 's':	/* save From lines in headers */
			setoption('f', "T", false, true, &BlankEnvelope);
			break;

#ifdef DBM
		  case 'I':	/* initialize alias DBM file */
			set_op_mode(MD_INITALIAS);
			break;
#endif /* DBM */

#if defined(__osf__) || defined(_AIX3)
		  case 'x':	/* random flag that OSF/1 & AIX mailx passes */
			break;
#endif /* defined(__osf__) || defined(_AIX3) */
#if defined(sony_news)
		  case 'E':
		  case 'J':	/* ignore flags for Japanese code conversion
				   implemented on Sony NEWS */
			break;
#endif /* defined(sony_news) */

		  default:
			finis(true, true, EX_USAGE);
			/* NOTREACHED */
			break;
		}
	}

	/* if we've had errors so far, exit now */
	if ((ExitStat != EX_OK && OpMode != MD_TEST && OpMode != MD_CHECKCONFIG) ||
	    ExitStat == EX_OSERR)
	{
		finis(false, true, ExitStat);
		/* NOTREACHED */
	}

	if (bitset(SUBMIT_MTA, SubmitMode))
	{
		/* If set daemon_flags on command line, don't reset it */
		if (macvalue(macid("{daemon_flags}"), &BlankEnvelope) == NULL)
			macdefine(&BlankEnvelope.e_macro, A_PERM,
				  macid("{daemon_flags}"), "CC f");
	}
	else if (OpMode == MD_DELIVER || OpMode == MD_SMTP)
	{
		SubmitMode = SUBMIT_MSA;

		/* If set daemon_flags on command line, don't reset it */
		if (macvalue(macid("{daemon_flags}"), &BlankEnvelope) == NULL)
			macdefine(&BlankEnvelope.e_macro, A_PERM,
				  macid("{daemon_flags}"), "c u");
	}

	/*
	**  Do basic initialization.
	**	Read system control file.
	**	Extract special fields for local use.
	*/

#if XDEBUG
	checkfd012("before readcf");
#endif /* XDEBUG */
	vendor_pre_defaults(&BlankEnvelope);

	readcf(getcfname(OpMode, SubmitMode, cftype, conffile),
			 safecf, &BlankEnvelope);
#if !defined(_USE_SUN_NSSWITCH_) && !defined(_USE_DEC_SVC_CONF_)
	ConfigFileRead = true;
#endif /* !defined(_USE_SUN_NSSWITCH_) && !defined(_USE_DEC_SVC_CONF_) */
	vendor_post_defaults(&BlankEnvelope);

	/* now we can complain about missing fds */
	if (MissingFds != 0 && LogLevel > 8)
	{
		char mbuf[MAXLINE];

		mbuf[0] = '\0';
		if (bitset(1 << STDIN_FILENO, MissingFds))
			(void) sm_strlcat(mbuf, ", stdin", sizeof(mbuf));
		if (bitset(1 << STDOUT_FILENO, MissingFds))
			(void) sm_strlcat(mbuf, ", stdout", sizeof(mbuf));
		if (bitset(1 << STDERR_FILENO, MissingFds))
			(void) sm_strlcat(mbuf, ", stderr", sizeof(mbuf));

		/* Notice: fill_errno is from high above: fill_fd() */
		sm_syslog(LOG_WARNING, NOQID,
			  "File descriptors missing on startup: %s; %s",
			  &mbuf[2], sm_errstring(fill_errno));
	}

	/* Remove the ability for a normal user to send signals */
	if (RealUid != 0 && RealUid != geteuid())
	{
		uid_t new_uid = geteuid();

#if HASSETREUID
		/*
		**  Since we can differentiate between uid and euid,
		**  make the uid a different user so the real user
		**  can't send signals.  However, it doesn't need to be
		**  root (euid has root).
		*/

		if (new_uid == 0)
			new_uid = DefUid;
		if (tTd(47, 5))
			sm_dprintf("Changing real uid to %d\n", (int) new_uid);
		if (setreuid(new_uid, geteuid()) < 0)
		{
			syserr("main: setreuid(%d, %d) failed",
			       (int) new_uid, (int) geteuid());
			finis(false, true, EX_OSERR);
			/* NOTREACHED */
		}
		if (tTd(47, 10))
			sm_dprintf("Now running as e/ruid %d:%d\n",
				   (int) geteuid(), (int) getuid());
#else /* HASSETREUID */
		/*
		**  Have to change both effective and real so need to
		**  change them both to effective to keep privs.
		*/

		if (tTd(47, 5))
			sm_dprintf("Changing uid to %d\n", (int) new_uid);
		if (setuid(new_uid) < 0)
		{
			syserr("main: setuid(%d) failed", (int) new_uid);
			finis(false, true, EX_OSERR);
			/* NOTREACHED */
		}
		if (tTd(47, 10))
			sm_dprintf("Now running as e/ruid %d:%d\n",
				   (int) geteuid(), (int) getuid());
#endif /* HASSETREUID */
	}

#if NAMED_BIND
	if (FallbackMX != NULL)
		(void) getfallbackmxrr(FallbackMX);
#endif /* NAMED_BIND */

	if (SuperSafe == SAFE_INTERACTIVE && !SM_IS_INTERACTIVE(CurEnv->e_sendmode))
	{
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "WARNING: SuperSafe=interactive should only be used with\n         DeliveryMode=interactive\n");
	}

	if (UseMSP && (OpMode == MD_DAEMON || OpMode == MD_FGDAEMON))
	{
		usrerr("Mail submission program cannot be used as daemon");
		finis(false, true, EX_USAGE);
	}

	if (OpMode == MD_DELIVER || OpMode == MD_SMTP ||
	    OpMode == MD_QUEUERUN || OpMode == MD_ARPAFTP ||
	    OpMode == MD_DAEMON || OpMode == MD_FGDAEMON)
		makeworkgroups();

	/* set up the basic signal handlers */
	if (sm_signal(SIGINT, SIG_IGN) != SIG_IGN)
		(void) sm_signal(SIGINT, intsig);
	(void) sm_signal(SIGTERM, intsig);

	/* Enforce use of local time (null string overrides this) */
	if (TimeZoneSpec == NULL)
		unsetenv("TZ");
	else if (TimeZoneSpec[0] != '\0')
		sm_setuserenv("TZ", TimeZoneSpec);
	else
		sm_setuserenv("TZ", NULL);
	tzset();

	/* initialize mailbox database */
	i = sm_mbdb_initialize(Mbdb);
	if (i != EX_OK)
	{
		usrerr("Can't initialize mailbox database \"%s\": %s",
		       Mbdb, sm_strexit(i));
		ExitStat = i;
	}

	/* avoid denial-of-service attacks */
	resetlimits();

	if (OpMode == MD_TEST)
	{
		/* can't be done after readcf if RunAs* is used */
		dp = drop_privileges(true);
		if (dp != EX_OK)
		{
			finis(false, true, dp);
			/* NOTREACHED */
		}
	}
	else if (OpMode != MD_DAEMON && OpMode != MD_FGDAEMON)
	{
		/* drop privileges -- daemon mode done after socket/bind */
		dp = drop_privileges(false);
		setstat(dp);
		if (dp == EX_OK && UseMSP && (geteuid() == 0 || getuid() == 0))
		{
			usrerr("Mail submission program must have RunAsUser set to non root user");
			finis(false, true, EX_CONFIG);
			/* NOTREACHED */
		}
	}

#if NAMED_BIND
	_res.retry = TimeOuts.res_retry[RES_TO_DEFAULT];
	_res.retrans = TimeOuts.res_retrans[RES_TO_DEFAULT];
#endif /* NAMED_BIND */

	/*
	**  Find our real host name for future logging.
	*/

	authinfo = getauthinfo(STDIN_FILENO, &forged);
	macdefine(&BlankEnvelope.e_macro, A_TEMP, '_', authinfo);

	/* suppress error printing if errors mailed back or whatever */
	if (BlankEnvelope.e_errormode != EM_PRINT)
		HoldErrs = true;

	/* set up the $=m class now, after .cf has a chance to redefine $m */
	expand("\201m", jbuf, sizeof(jbuf), &BlankEnvelope);
	if (jbuf[0] != '\0')
		setclass('m', jbuf);

	/* probe interfaces and locate any additional names */
	if (DontProbeInterfaces != DPI_PROBENONE)
		load_if_names();

	if (tTd(0, 10))
	{
		char pidpath[MAXPATHLEN];

		/* Now we know which .cf file we use */
		sm_dprintf("     Conf file:\t%s (selected)\n",
			   getcfname(OpMode, SubmitMode, cftype, conffile));
		expand(PidFile, pidpath, sizeof(pidpath), &BlankEnvelope);
		sm_dprintf("      Pid file:\t%s (selected)\n", pidpath);
	}

	if (tTd(0, 1))
	{
		sm_dprintf("\n============ SYSTEM IDENTITY (after readcf) ============");
		sm_dprintf("\n      (short domain name) $w = ");
		xputs(sm_debug_file(), macvalue('w', &BlankEnvelope));
		sm_dprintf("\n  (canonical domain name) $j = ");
		xputs(sm_debug_file(), macvalue('j', &BlankEnvelope));
		sm_dprintf("\n         (subdomain name) $m = ");
		xputs(sm_debug_file(), macvalue('m', &BlankEnvelope));
		sm_dprintf("\n              (node name) $k = ");
		xputs(sm_debug_file(), macvalue('k', &BlankEnvelope));
		sm_dprintf("\n========================================================\n\n");
	}

	/*
	**  Do more command line checking -- these are things that
	**  have to modify the results of reading the config file.
	*/

	/* process authorization warnings from command line */
	if (warn_C_flag)
		auth_warning(&BlankEnvelope, "Processed by %s with -C %s",
			     RealUserName, conffile);
	if (Warn_Q_option && !wordinclass(RealUserName, 't'))
		auth_warning(&BlankEnvelope, "Processed from queue %s",
			     QueueDir);
	if (sysloglabel != NULL && !wordinclass(RealUserName, 't') &&
	    RealUid != 0 && RealUid != TrustedUid && LogLevel > 1)
		sm_syslog(LOG_WARNING, NOQID, "user %d changed syslog label",
			  (int) RealUid);

	/* check body type for legality */
	i = check_bodytype(BlankEnvelope.e_bodytype);
	if (i == BODYTYPE_ILLEGAL)
	{
		usrerr("Illegal body type %s", BlankEnvelope.e_bodytype);
		BlankEnvelope.e_bodytype = NULL;
	}
	else if (i != BODYTYPE_NONE)
		SevenBitInput = (i == BODYTYPE_7BIT);

	/* tweak default DSN notifications */
	if (DefaultNotify == 0)
		DefaultNotify = QPINGONFAILURE|QPINGONDELAY;

	/* check for sane configuration level */
	if (ConfigLevel > MAXCONFIGLEVEL)
	{
		syserr("Warning: .cf version level (%d) exceeds sendmail version %s functionality (%d)",
		       ConfigLevel, Version, MAXCONFIGLEVEL);
	}

	/* need MCI cache to have persistence */
	if (HostStatDir != NULL && MaxMciCache == 0)
	{
		HostStatDir = NULL;
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: HostStatusDirectory disabled with ConnectionCacheSize = 0\n");
	}

	/* need HostStatusDir in order to have SingleThreadDelivery */
	if (SingleThreadDelivery && HostStatDir == NULL)
	{
		SingleThreadDelivery = false;
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: HostStatusDirectory required for SingleThreadDelivery\n");
	}

#if _FFR_MEMSTAT
	j = sm_memstat_open();
	if (j < 0 && (RefuseLowMem > 0 || QueueLowMem > 0) && LogLevel > 4)
	{
		sm_syslog(LOG_WARNING, NOQID,
			  "cannot get memory statistics, settings ignored, error=%d"
			  , j);
	}
#endif /* _FFR_MEMSTAT */

	/* check for permissions */
	if (RealUid != 0 &&
	    RealUid != TrustedUid)
	{
		char *action = NULL;

		switch (OpMode)
		{
		  case MD_QUEUERUN:
			if (quarantining != NULL)
				action = "quarantine jobs";
			else
			{
				/* Normal users can do a single queue run */
				if (QueueIntvl == 0)
					break;
			}

			/* but not persistent queue runners */
			if (action == NULL)
				action = "start a queue runner daemon";
			/* FALLTHROUGH */

		  case MD_PURGESTAT:
			if (action == NULL)
				action = "purge host status";
			/* FALLTHROUGH */

		  case MD_DAEMON:
		  case MD_FGDAEMON:
			if (action == NULL)
				action = "run daemon";

			if (tTd(65, 1))
				sm_dprintf("Deny user %d attempt to %s\n",
					   (int) RealUid, action);

			if (LogLevel > 1)
				sm_syslog(LOG_ALERT, NOQID,
					  "user %d attempted to %s",
					  (int) RealUid, action);
			HoldErrs = false;
			usrerr("Permission denied (real uid not trusted)");
			finis(false, true, EX_USAGE);
			/* NOTREACHED */
			break;

		  case MD_VERIFY:
			if (bitset(PRIV_RESTRICTEXPAND, PrivacyFlags))
			{
				/*
				**  If -bv and RestrictExpand,
				**  drop privs to prevent normal
				**  users from reading private
				**  aliases/forwards/:include:s
				*/

				if (tTd(65, 1))
					sm_dprintf("Drop privs for user %d attempt to expand (RestrictExpand)\n",
						   (int) RealUid);

				dp = drop_privileges(true);

				/* Fake address safety */
				if (tTd(65, 1))
					sm_dprintf("Faking DontBlameSendmail=NonRootSafeAddr\n");
				setbitn(DBS_NONROOTSAFEADDR, DontBlameSendmail);

				if (dp != EX_OK)
				{
					if (tTd(65, 1))
						sm_dprintf("Failed to drop privs for user %d attempt to expand, exiting\n",
							   (int) RealUid);
					CurEnv->e_id = NULL;
					finis(true, true, dp);
					/* NOTREACHED */
				}
			}
			break;

		  case MD_TEST:
		  case MD_CHECKCONFIG:
		  case MD_PRINT:
		  case MD_PRINTNQE:
		  case MD_FREEZE:
		  case MD_HOSTSTAT:
			/* Nothing special to check */
			break;

		  case MD_INITALIAS:
			if (!wordinclass(RealUserName, 't'))
			{
				if (tTd(65, 1))
					sm_dprintf("Deny user %d attempt to rebuild the alias map\n",
						   (int) RealUid);
				if (LogLevel > 1)
					sm_syslog(LOG_ALERT, NOQID,
						  "user %d attempted to rebuild the alias map",
						  (int) RealUid);
				HoldErrs = false;
				usrerr("Permission denied (real uid not trusted)");
				finis(false, true, EX_USAGE);
				/* NOTREACHED */
			}
			if (UseMSP)
			{
				HoldErrs = false;
				usrerr("User %d cannot rebuild aliases in mail submission program",
				       (int) RealUid);
				finis(false, true, EX_USAGE);
				/* NOTREACHED */
			}
			/* FALLTHROUGH */

		  default:
			if (bitset(PRIV_RESTRICTEXPAND, PrivacyFlags) &&
			    Verbose != 0)
			{
				/*
				**  If -v and RestrictExpand, reset
				**  Verbose to prevent normal users
				**  from seeing the expansion of
				**  aliases/forwards/:include:s
				*/

				if (tTd(65, 1))
					sm_dprintf("Dropping verbosity for user %d (RestrictExpand)\n",
						   (int) RealUid);
				Verbose = 0;
			}
			break;
		}
	}

	if (MeToo)
		BlankEnvelope.e_flags |= EF_METOO;

	switch (OpMode)
	{
	  case MD_TEST:
		/* don't have persistent host status in test mode */
		HostStatDir = NULL;
		/* FALLTHROUGH */

	  case MD_CHECKCONFIG:
		if (Verbose == 0)
			Verbose = 2;
		BlankEnvelope.e_errormode = EM_PRINT;
		HoldErrs = false;
		break;

	  case MD_VERIFY:
		BlankEnvelope.e_errormode = EM_PRINT;
		HoldErrs = false;
		/* arrange to exit cleanly on hangup signal */
		if (sm_signal(SIGHUP, SIG_IGN) == (sigfunc_t) SIG_DFL)
			(void) sm_signal(SIGHUP, intsig);
		if (geteuid() != 0)
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Notice: -bv may give misleading output for non-privileged user\n");
		break;

	  case MD_FGDAEMON:
		run_in_foreground = true;
		set_op_mode(MD_DAEMON);
		/* FALLTHROUGH */

	  case MD_DAEMON:
		vendor_daemon_setup(&BlankEnvelope);

		/* remove things that don't make sense in daemon mode */
		FullName = NULL;
		GrabTo = false;

		/* arrange to restart on hangup signal */
		if (SaveArgv[0] == NULL || SaveArgv[0][0] != '/')
			sm_syslog(LOG_WARNING, NOQID,
				  "daemon invoked without full pathname; kill -1 won't work");
		break;

	  case MD_INITALIAS:
		Verbose = 2;
		BlankEnvelope.e_errormode = EM_PRINT;
		HoldErrs = false;
		/* FALLTHROUGH */

	  default:
		/* arrange to exit cleanly on hangup signal */
		if (sm_signal(SIGHUP, SIG_IGN) == (sigfunc_t) SIG_DFL)
			(void) sm_signal(SIGHUP, intsig);
		break;
	}

	/* special considerations for FullName */
	if (FullName != NULL)
	{
		char *full = NULL;

		/* full names can't have newlines */
		if (strchr(FullName, '\n') != NULL)
		{
			full = newstr(denlstring(FullName, true, true));
			FullName = full;
		}

		/* check for characters that may have to be quoted */
		if (!rfc822_string(FullName))
		{
			/*
			**  Quote a full name with special characters
			**  as a comment so crackaddr() doesn't destroy
			**  the name portion of the address.
			*/

			FullName = addquotes(FullName, NULL);
			if (full != NULL)
				sm_free(full);  /* XXX */
		}
	}

	/* do heuristic mode adjustment */
	if (Verbose)
	{
		/* turn off noconnect option */
		setoption('c', "F", true, false, &BlankEnvelope);

		/* turn on interactive delivery */
		setoption('d', "", true, false, &BlankEnvelope);
	}

#ifdef VENDOR_CODE
	/* check for vendor mismatch */
	if (VendorCode != VENDOR_CODE)
	{
		message("Warning: .cf file vendor code mismatch: sendmail expects vendor %s, .cf file vendor is %s",
			getvendor(VENDOR_CODE), getvendor(VendorCode));
	}
#endif /* VENDOR_CODE */

	/* check for out of date configuration level */
	if (ConfigLevel < MAXCONFIGLEVEL)
	{
		message("Warning: .cf file is out of date: sendmail %s supports version %d, .cf file is version %d",
			Version, MAXCONFIGLEVEL, ConfigLevel);
	}

	if (ConfigLevel < 3)
		UseErrorsTo = true;

	/* set options that were previous macros */
	if (SmtpGreeting == NULL)
	{
		if (ConfigLevel < 7 &&
		    (p = macvalue('e', &BlankEnvelope)) != NULL)
			SmtpGreeting = newstr(p);
		else
			SmtpGreeting = "\201j Sendmail \201v ready at \201b";
	}
	if (UnixFromLine == NULL)
	{
		if (ConfigLevel < 7 &&
		    (p = macvalue('l', &BlankEnvelope)) != NULL)
			UnixFromLine = newstr(p);
		else
			UnixFromLine = "From \201g  \201d";
	}
	SmtpError[0] = '\0';

	/* our name for SMTP codes */
	expand("\201j", jbuf, sizeof(jbuf), &BlankEnvelope);
	if (jbuf[0] == '\0')
		PSTRSET(MyHostName, "localhost");
	else
		PSTRSET(MyHostName, jbuf);
	if (strchr(MyHostName, '.') == NULL)
		message("WARNING: local host name (%s) is not qualified; see cf/README: WHO AM I?",
			MyHostName);

	/* make certain that this name is part of the $=w class */
	setclass('w', MyHostName);

	/* fill in the structure of the *default* queue */
	st = stab("mqueue", ST_QUEUE, ST_FIND);
	if (st == NULL)
		syserr("No default queue (mqueue) defined");
	else
		set_def_queueval(st->s_quegrp, true);

	/* the indices of built-in mailers */
	st = stab("local", ST_MAILER, ST_FIND);
	if (st != NULL)
		LocalMailer = st->s_mailer;
	else if (OpMode != MD_TEST || !warn_C_flag)
		syserr("No local mailer defined");

	st = stab("prog", ST_MAILER, ST_FIND);
	if (st == NULL)
		syserr("No prog mailer defined");
	else
	{
		ProgMailer = st->s_mailer;
		clrbitn(M_MUSER, ProgMailer->m_flags);
	}

	st = stab("*file*", ST_MAILER, ST_FIND);
	if (st == NULL)
		syserr("No *file* mailer defined");
	else
	{
		FileMailer = st->s_mailer;
		clrbitn(M_MUSER, FileMailer->m_flags);
	}

	st = stab("*include*", ST_MAILER, ST_FIND);
	if (st == NULL)
		syserr("No *include* mailer defined");
	else
		InclMailer = st->s_mailer;

	if (ConfigLevel < 6)
	{
		/* heuristic tweaking of local mailer for back compat */
		if (LocalMailer != NULL)
		{
			setbitn(M_ALIASABLE, LocalMailer->m_flags);
			setbitn(M_HASPWENT, LocalMailer->m_flags);
			setbitn(M_TRYRULESET5, LocalMailer->m_flags);
			setbitn(M_CHECKINCLUDE, LocalMailer->m_flags);
			setbitn(M_CHECKPROG, LocalMailer->m_flags);
			setbitn(M_CHECKFILE, LocalMailer->m_flags);
			setbitn(M_CHECKUDB, LocalMailer->m_flags);
		}
		if (ProgMailer != NULL)
			setbitn(M_RUNASRCPT, ProgMailer->m_flags);
		if (FileMailer != NULL)
			setbitn(M_RUNASRCPT, FileMailer->m_flags);
	}
	if (ConfigLevel < 7)
	{
		if (LocalMailer != NULL)
			setbitn(M_VRFY250, LocalMailer->m_flags);
		if (ProgMailer != NULL)
			setbitn(M_VRFY250, ProgMailer->m_flags);
		if (FileMailer != NULL)
			setbitn(M_VRFY250, FileMailer->m_flags);
	}

	/* MIME Content-Types that cannot be transfer encoded */
	setclass('n', "multipart/signed");

	/* MIME message/xxx subtypes that can be treated as messages */
	setclass('s', "rfc822");

	/* MIME Content-Transfer-Encodings that can be encoded */
	setclass('e', "7bit");
	setclass('e', "8bit");
	setclass('e', "binary");

#ifdef USE_B_CLASS
	/* MIME Content-Types that should be treated as binary */
	setclass('b', "image");
	setclass('b', "audio");
	setclass('b', "video");
	setclass('b', "application/octet-stream");
#endif /* USE_B_CLASS */

	/* MIME headers which have fields to check for overflow */
	setclass(macid("{checkMIMEFieldHeaders}"), "content-disposition");
	setclass(macid("{checkMIMEFieldHeaders}"), "content-type");

	/* MIME headers to check for length overflow */
	setclass(macid("{checkMIMETextHeaders}"), "content-description");

	/* MIME headers to check for overflow and rebalance */
	setclass(macid("{checkMIMEHeaders}"), "content-disposition");
	setclass(macid("{checkMIMEHeaders}"), "content-id");
	setclass(macid("{checkMIMEHeaders}"), "content-transfer-encoding");
	setclass(macid("{checkMIMEHeaders}"), "content-type");
	setclass(macid("{checkMIMEHeaders}"), "mime-version");

	/* Macros to save in the queue file -- don't remove any */
	setclass(macid("{persistentMacros}"), "r");
	setclass(macid("{persistentMacros}"), "s");
	setclass(macid("{persistentMacros}"), "_");
	setclass(macid("{persistentMacros}"), "{if_addr}");
	setclass(macid("{persistentMacros}"), "{daemon_flags}");

	/* operate in queue directory */
	if (QueueDir == NULL || *QueueDir == '\0')
	{
		if (OpMode != MD_TEST)
		{
			syserr("QueueDirectory (Q) option must be set");
			ExitStat = EX_CONFIG;
		}
	}
	else
	{
		if (OpMode != MD_TEST)
			setup_queues(OpMode == MD_DAEMON);
	}

	/* check host status directory for validity */
	if (HostStatDir != NULL && !path_is_dir(HostStatDir, false))
	{
		/* cannot use this value */
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: Cannot use HostStatusDirectory = %s: %s\n",
				     HostStatDir, sm_errstring(errno));
		HostStatDir = NULL;
	}

	if (OpMode == MD_QUEUERUN &&
	    RealUid != 0 && bitset(PRIV_RESTRICTQRUN, PrivacyFlags))
	{
		struct stat stbuf;

		/* check to see if we own the queue directory */
		if (stat(".", &stbuf) < 0)
			syserr("main: cannot stat %s", QueueDir);
		if (stbuf.st_uid != RealUid)
		{
			/* nope, really a botch */
			HoldErrs = false;
			usrerr("You do not have permission to process the queue");
			finis(false, true, EX_NOPERM);
			/* NOTREACHED */
		}
	}

#if MILTER
	/* sanity checks on milter filters */
	if (OpMode == MD_DAEMON || OpMode == MD_SMTP)
	{
		milter_config(InputFilterList, InputFilters, MAXFILTERS);
		setup_daemon_milters();
	}
#endif /* MILTER */

	/* Convert queuegroup string to qgrp number */
	if (queuegroup != NULL)
	{
		qgrp = name2qid(queuegroup);
		if (qgrp == NOQGRP)
		{
			HoldErrs = false;
			usrerr("Queue group %s unknown", queuegroup);
			finis(false, true, ExitStat);
			/* NOTREACHED */
		}
	}

	/* if checking config or have had errors so far, exit now */
	if (OpMode == MD_CHECKCONFIG || (ExitStat != EX_OK && OpMode != MD_TEST))
	{
		finis(false, true, ExitStat);
		/* NOTREACHED */
	}

#if SASL
	/* sendmail specific SASL initialization */
	sm_sasl_init();
#endif /* SASL */

#if XDEBUG
	checkfd012("before main() initmaps");
#endif /* XDEBUG */

	/*
	**  Do operation-mode-dependent initialization.
	*/

	switch (OpMode)
	{
	  case MD_PRINT:
		/* print the queue */
		HoldErrs = false;
		(void) dropenvelope(&BlankEnvelope, true, false);
		(void) sm_signal(SIGPIPE, sigpipe);
		if (qgrp != NOQGRP)
		{
			int j;

			/* Selecting a particular queue group to run */
			for (j = 0; j < Queue[qgrp]->qg_numqueues; j++)
			{
				if (StopRequest)
					stop_sendmail();
				(void) print_single_queue(qgrp, j);
			}
			finis(false, true, EX_OK);
			/* NOTREACHED */
		}
		printqueue();
		finis(false, true, EX_OK);
		/* NOTREACHED */
		break;

	  case MD_PRINTNQE:
		/* print number of entries in queue */
		(void) dropenvelope(&BlankEnvelope, true, false);
		(void) sm_signal(SIGPIPE, sigpipe);
		printnqe(smioout, NULL);
		finis(false, true, EX_OK);
		/* NOTREACHED */
		break;

	  case MD_QUEUERUN:
		/* only handle quarantining here */
		if (quarantining == NULL)
			break;

		if (QueueMode != QM_QUARANTINE &&
		    QueueMode != QM_NORMAL)
		{
			HoldErrs = false;
			usrerr("Can not use -Q with -q%c", QueueMode);
			ExitStat = EX_USAGE;
			finis(false, true, ExitStat);
			/* NOTREACHED */
		}
		quarantine_queue(quarantining, qgrp);
		finis(false, true, EX_OK);
		break;

	  case MD_HOSTSTAT:
		(void) sm_signal(SIGPIPE, sigpipe);
		(void) mci_traverse_persistent(mci_print_persistent, NULL);
		finis(false, true, EX_OK);
		/* NOTREACHED */
		break;

	  case MD_PURGESTAT:
		(void) mci_traverse_persistent(mci_purge_persistent, NULL);
		finis(false, true, EX_OK);
		/* NOTREACHED */
		break;

	  case MD_INITALIAS:
		/* initialize maps */
		initmaps();
		finis(false, true, ExitStat);
		/* NOTREACHED */
		break;

	  case MD_SMTP:
	  case MD_DAEMON:
		/* reset DSN parameters */
		DefaultNotify = QPINGONFAILURE|QPINGONDELAY;
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			  macid("{dsn_notify}"), NULL);
		BlankEnvelope.e_envid = NULL;
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			  macid("{dsn_envid}"), NULL);
		BlankEnvelope.e_flags &= ~(EF_RET_PARAM|EF_NO_BODY_RETN);
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			  macid("{dsn_ret}"), NULL);

		/* don't open maps for daemon -- done below in child */
		break;
	}

	if (tTd(0, 15))
	{
		/* print configuration table (or at least part of it) */
		if (tTd(0, 90))
			printrules();
		for (i = 0; i < MAXMAILERS; i++)
		{
			if (Mailer[i] != NULL)
				printmailer(sm_debug_file(), Mailer[i]);
		}
	}

	/*
	**  Switch to the main envelope.
	*/

	CurEnv = newenvelope(&MainEnvelope, &BlankEnvelope,
			     sm_rpool_new_x(NULL));
	MainEnvelope.e_flags = BlankEnvelope.e_flags;

	/*
	**  If test mode, read addresses from stdin and process.
	*/

	if (OpMode == MD_TEST)
	{
		if (isatty(sm_io_getinfo(smioin, SM_IO_WHAT_FD, NULL)))
			Verbose = 2;

		if (Verbose)
		{
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)\n");
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Enter <ruleset> <address>\n");
		}
		macdefine(&(MainEnvelope.e_macro), A_PERM,
			  macid("{addr_type}"), "e r");
		for (;;)
		{
			SM_TRY
			{
				(void) sm_signal(SIGINT, intindebug);
				(void) sm_releasesignal(SIGINT);
				if (Verbose == 2)
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "> ");
				(void) sm_io_flush(smioout, SM_TIME_DEFAULT);
				if (sm_io_fgets(smioin, SM_TIME_DEFAULT, buf,
						sizeof(buf)) < 0)
					testmodeline("/quit", &MainEnvelope);
				p = strchr(buf, '\n');
				if (p != NULL)
					*p = '\0';
				if (Verbose < 2)
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "> %s\n", buf);
				testmodeline(buf, &MainEnvelope);
			}
			SM_EXCEPT(exc, "[!F]*")
			{
				/*
				**  8.10 just prints \n on interrupt.
				**  I'm printing the exception here in case
				**  sendmail is extended to raise additional
				**  exceptions in this context.
				*/

				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "\n");
				sm_exc_print(exc, smioout);
			}
			SM_END_TRY
		}
	}

#if STARTTLS
	tls_ok = true;
	if (OpMode == MD_QUEUERUN || OpMode == MD_DELIVER ||
	    OpMode == MD_ARPAFTP)
	{
		/* check whether STARTTLS is turned off for the client */
		if (chkclientmodifiers(D_NOTLS))
			tls_ok = false;
	}
	else if (OpMode == MD_DAEMON || OpMode == MD_FGDAEMON ||
		 OpMode == MD_SMTP)
	{
		/* check whether STARTTLS is turned off */
		if (chkdaemonmodifiers(D_NOTLS) && chkclientmodifiers(D_NOTLS))
			tls_ok = false;
	}
	else	/* other modes don't need STARTTLS */
		tls_ok = false;

	if (tls_ok)
	{
		/* basic TLS initialization */
		tls_ok = init_tls_library(FipsMode);
		if (!tls_ok && FipsMode)
		{
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "ERROR: FIPSMode failed to initialize\n");
			exit(EX_USAGE);
		}
	}

	if (!tls_ok && (OpMode == MD_QUEUERUN || OpMode == MD_DELIVER))
	{
		/* disable TLS for client */
		setclttls(false);
	}
#endif /* STARTTLS */

	/*
	**  If collecting stuff from the queue, go start doing that.
	*/

	if (OpMode == MD_QUEUERUN && QueueIntvl == 0)
	{
		pid_t pid = -1;

#if STARTTLS
		/* init TLS for client, ignore result for now */
		(void) initclttls(tls_ok);
#endif /* STARTTLS */

		/*
		**  The parent process of the caller of runqueue() needs
		**  to stay around for a possible SIGTERM. The SIGTERM will
		**  tell this process that all of the queue runners children
		**  need to be sent SIGTERM as well. At the same time, we
		**  want to return control to the command line. So we do an
		**  extra fork().
		*/

		if (Verbose || foregroundqueue || (pid = fork()) <= 0)
		{
			/*
			**  If the fork() failed we should still try to do
			**  the queue run. If it succeeded then the child
			**  is going to start the run and wait for all
			**  of the children to finish.
			*/

			if (pid == 0)
			{
				/* Reset global flags */
				RestartRequest = NULL;
				ShutdownRequest = NULL;
				PendingSignal = 0;

				/* disconnect from terminal */
				disconnect(2, CurEnv);
			}

			CurrentPid = getpid();
			if (qgrp != NOQGRP)
			{
				int rwgflags = RWG_NONE;

				/*
				**  To run a specific queue group mark it to
				**  be run, select the work group it's in and
				**  increment the work counter.
				*/

				for (i = 0; i < NumQueue && Queue[i] != NULL;
				     i++)
					Queue[i]->qg_nextrun = (time_t) -1;
				Queue[qgrp]->qg_nextrun = 0;
				if (Verbose)
					rwgflags |= RWG_VERBOSE;
				if (queuepersistent)
					rwgflags |= RWG_PERSISTENT;
				rwgflags |= RWG_FORCE;
				(void) run_work_group(Queue[qgrp]->qg_wgrp,
						      rwgflags);
			}
			else
				(void) runqueue(false, Verbose,
						queuepersistent, true);

			/* set the title to make it easier to find */
			sm_setproctitle(true, CurEnv, "Queue control");
			(void) sm_signal(SIGCHLD, SIG_DFL);
			while (CurChildren > 0)
			{
				int status;
				pid_t ret;

				errno = 0;
				while ((ret = sm_wait(&status)) <= 0)
				{
					if (errno == ECHILD)
					{
						/*
						**  Oops... something got messed
						**  up really bad. Waiting for
						**  non-existent children
						**  shouldn't happen. Let's get
						**  out of here.
						*/

						CurChildren = 0;
						break;
					}
					continue;
				}

				/* something is really really wrong */
				if (errno == ECHILD)
				{
					sm_syslog(LOG_ERR, NOQID,
						  "queue control process: lost all children: wait returned ECHILD");
					break;
				}

				/* Only drop when a child gives status */
				if (WIFSTOPPED(status))
					continue;

				proc_list_drop(ret, status, NULL);
			}
		}
		finis(true, true, ExitStat);
		/* NOTREACHED */
	}

# if SASL
	if (OpMode == MD_SMTP || OpMode == MD_DAEMON)
	{
		/* check whether AUTH is turned off for the server */
		if (!chkdaemonmodifiers(D_NOAUTH) &&
		    (i = sasl_server_init(srvcallbacks, "Sendmail")) != SASL_OK)
			syserr("!sasl_server_init failed! [%s]",
				sasl_errstring(i, NULL, NULL));
	}
# endif /* SASL */

	if (OpMode == MD_SMTP)
	{
		proc_list_add(CurrentPid, "Sendmail SMTP Agent",
			      PROC_DAEMON, 0, -1, NULL);

		/* clean up background delivery children */
		(void) sm_signal(SIGCHLD, reapchild);
	}

	/*
	**  If a daemon, wait for a request.
	**	getrequests will always return in a child.
	**	If we should also be processing the queue, start
	**		doing it in background.
	**	We check for any errors that might have happened
	**		during startup.
	*/

	if (OpMode == MD_DAEMON || QueueIntvl > 0)
	{
		char dtype[200];

		/* avoid cleanup in finis(), DaemonPid will be set below */
		DaemonPid = 0;
		if (!run_in_foreground && !tTd(99, 100))
		{
			/* put us in background */
			i = fork();
			if (i < 0)
				syserr("daemon: cannot fork");
			if (i != 0)
			{
				finis(false, true, EX_OK);
				/* NOTREACHED */
			}

			/*
			**  Initialize exception stack and default exception
			**  handler for child process.
			*/

			/* Reset global flags */
			RestartRequest = NULL;
			RestartWorkGroup = false;
			ShutdownRequest = NULL;
			PendingSignal = 0;
			CurrentPid = getpid();

			sm_exc_newthread(fatal_error);

			/* disconnect from our controlling tty */
			disconnect(2, &MainEnvelope);
		}

		dtype[0] = '\0';
		if (OpMode == MD_DAEMON)
		{
			(void) sm_strlcat(dtype, "+SMTP", sizeof(dtype));
			DaemonPid = CurrentPid;
		}
		if (QueueIntvl > 0)
		{
			(void) sm_strlcat2(dtype,
					   queuepersistent
					   ? "+persistent-queueing@@"
					   : "+queueing@@",
					   pintvl(QueueIntvl, true),
					   sizeof(dtype));
		}
		if (tTd(0, 1))
			(void) sm_strlcat(dtype, "+debugging", sizeof(dtype));

		sm_syslog(LOG_INFO, NOQID,
			  "starting daemon (%s): %s", Version, dtype + 1);
#if XLA
		xla_create_file();
#endif /* XLA */

		/* save daemon type in a macro for possible PidFile use */
		macdefine(&BlankEnvelope.e_macro, A_TEMP,
			macid("{daemon_info}"), dtype + 1);

		/* save queue interval in a macro for possible PidFile use */
		macdefine(&MainEnvelope.e_macro, A_TEMP,
			macid("{queue_interval}"), pintvl(QueueIntvl, true));

		/* workaround: can't seem to release the signal in the parent */
		(void) sm_signal(SIGHUP, sighup);
		(void) sm_releasesignal(SIGHUP);
		(void) sm_signal(SIGTERM, sigterm);

		if (QueueIntvl > 0)
		{
#if _FFR_RUNPQG
			if (qgrp != NOQGRP)
			{
				int rwgflags = RWG_NONE;

				/*
				**  To run a specific queue group mark it to
				**  be run, select the work group it's in and
				**  increment the work counter.
				*/

				for (i = 0; i < NumQueue && Queue[i] != NULL;
				     i++)
					Queue[i]->qg_nextrun = (time_t) -1;
				Queue[qgrp]->qg_nextrun = 0;
				if (Verbose)
					rwgflags |= RWG_VERBOSE;
				if (queuepersistent)
					rwgflags |= RWG_PERSISTENT;
				rwgflags |= RWG_FORCE;
				(void) run_work_group(Queue[qgrp]->qg_wgrp,
						      rwgflags);
			}
			else
#endif /* _FFR_RUNPQG */
				(void) runqueue(true, false, queuepersistent,
						true);

			/*
			**  If queuepersistent but not in daemon mode then
			**  we're going to do the queue runner monitoring here.
			**  If in daemon mode then the monitoring will happen
			**  elsewhere.
			*/

			if (OpMode != MD_DAEMON && queuepersistent)
			{
				/*
				**  Write the pid to file
				**  XXX Overwrites sendmail.pid
				*/

				log_sendmail_pid(&MainEnvelope);

				/* set the title to make it easier to find */
				sm_setproctitle(true, CurEnv, "Queue control");
				(void) sm_signal(SIGCHLD, SIG_DFL);
				while (CurChildren > 0)
				{
					int status;
					pid_t ret;
					int group;

					CHECK_RESTART;
					errno = 0;
					while ((ret = sm_wait(&status)) <= 0)
					{
						/*
						**  Waiting for non-existent
						**  children shouldn't happen.
						**  Let's get out of here if
						**  it occurs.
						*/

						if (errno == ECHILD)
						{
							CurChildren = 0;
							break;
						}
						continue;
					}

					/* something is really really wrong */
					if (errno == ECHILD)
					{
						sm_syslog(LOG_ERR, NOQID,
							  "persistent queue runner control process: lost all children: wait returned ECHILD");
						break;
					}

					if (WIFSTOPPED(status))
						continue;

					/* Probe only on a child status */
					proc_list_drop(ret, status, &group);

					if (WIFSIGNALED(status))
					{
						if (WCOREDUMP(status))
						{
							sm_syslog(LOG_ERR, NOQID,
								  "persistent queue runner=%d core dumped, signal=%d",
								  group, WTERMSIG(status));

							/* don't restart this */
							mark_work_group_restart(
								group, -1);
							continue;
						}

						sm_syslog(LOG_ERR, NOQID,
							  "persistent queue runner=%d died, pid=%ld, signal=%d",
							  group, (long) ret,
							  WTERMSIG(status));
					}

					/*
					**  When debugging active, don't
					**  restart the persistent queues.
					**  But do log this as info.
					*/

					if (sm_debug_active(&DebugNoPRestart,
							    1))
					{
						sm_syslog(LOG_DEBUG, NOQID,
							  "persistent queue runner=%d, exited",
							  group);
						mark_work_group_restart(group,
									-1);
					}
					CHECK_RESTART;
				}
				finis(true, true, ExitStat);
				/* NOTREACHED */
			}

			if (OpMode != MD_DAEMON)
			{
				char qtype[200];

				/*
				**  Write the pid to file
				**  XXX Overwrites sendmail.pid
				*/

				log_sendmail_pid(&MainEnvelope);

				/* set the title to make it easier to find */
				qtype[0] = '\0';
				(void) sm_strlcpyn(qtype, sizeof(qtype), 4,
						   "Queue runner@@",
						   pintvl(QueueIntvl, true),
						   " for ",
						   QueueDir);
				sm_setproctitle(true, CurEnv, qtype);
				for (;;)
				{
					(void) pause();

					CHECK_RESTART;

					if (doqueuerun())
						(void) runqueue(true, false,
								false, false);
				}
			}
		}
		(void) dropenvelope(&MainEnvelope, true, false);

#if STARTTLS
		/* init TLS for server, ignore result for now */
		(void) initsrvtls(tls_ok);
#endif /* STARTTLS */

	nextreq:
		p_flags = getrequests(&MainEnvelope);

		/* drop privileges */
		(void) drop_privileges(false);

		/*
		**  Get authentication data
		**  Set _ macro in BlankEnvelope before calling newenvelope().
		*/

		authinfo = getauthinfo(sm_io_getinfo(InChannel, SM_IO_WHAT_FD,
						     NULL), &forged);
		macdefine(&BlankEnvelope.e_macro, A_TEMP, '_', authinfo);
		if (tTd(75, 9))
			sm_syslog(LOG_INFO, NOQID,
				"main: where=after_getauthinfo, RealHostAddr=%s",
				anynet_ntoa(&RealHostAddr));

		/* at this point we are in a child: reset state */
		sm_rpool_free(MainEnvelope.e_rpool);
		(void) newenvelope(&MainEnvelope, &MainEnvelope,
				   sm_rpool_new_x(NULL));
	}

	if (LogLevel > 9)
	{
		/* log connection information */
		sm_syslog(LOG_INFO, NULL, "connect from %s", authinfo);
	}

	/*
	**  If running SMTP protocol, start collecting and executing
	**  commands.  This will never return.
	*/

	if (OpMode == MD_SMTP || OpMode == MD_DAEMON)
	{
		char pbuf[20];

		/*
		**  Save some macros for check_* rulesets.
		*/

		if (forged)
		{
			char ipbuf[103];

			(void) sm_snprintf(ipbuf, sizeof(ipbuf), "[%.100s]",
					   anynet_ntoa(&RealHostAddr));
			macdefine(&BlankEnvelope.e_macro, A_TEMP,
				  macid("{client_name}"), ipbuf);
		}
		else
			macdefine(&BlankEnvelope.e_macro, A_PERM,
				  macid("{client_name}"), RealHostName);
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			  macid("{client_ptr}"), RealHostName);
		macdefine(&BlankEnvelope.e_macro, A_TEMP,
			  macid("{client_addr}"), anynet_ntoa(&RealHostAddr));
		sm_getla();

		switch (RealHostAddr.sa.sa_family)
		{
#if NETINET
		  case AF_INET:
			(void) sm_snprintf(pbuf, sizeof(pbuf), "%d",
					   RealHostAddr.sin.sin_port);
			break;
#endif /* NETINET */
#if NETINET6
		  case AF_INET6:
			(void) sm_snprintf(pbuf, sizeof(pbuf), "%d",
					   RealHostAddr.sin6.sin6_port);
			break;
#endif /* NETINET6 */
		  default:
			(void) sm_snprintf(pbuf, sizeof(pbuf), "0");
			break;
		}
		macdefine(&BlankEnvelope.e_macro, A_TEMP,
			macid("{client_port}"), pbuf);

		if (OpMode == MD_DAEMON)
		{
			ENVELOPE *saved_env;

			/* validate the connection */
			HoldErrs = true;
			saved_env = CurEnv;
			CurEnv = &BlankEnvelope;
			nullserver = validate_connection(&RealHostAddr,
						macvalue(macid("{client_name}"),
							&BlankEnvelope),
						&BlankEnvelope);
			if (bitset(EF_DISCARD, BlankEnvelope.e_flags))
				MainEnvelope.e_flags |= EF_DISCARD;
			CurEnv = saved_env;
			HoldErrs = false;
		}
		else if (p_flags == NULL)
		{
			p_flags = (BITMAP256 *) xalloc(sizeof(*p_flags));
			clrbitmap(p_flags);
		}
#if STARTTLS
		if (OpMode == MD_SMTP)
			(void) initsrvtls(tls_ok);
#endif /* STARTTLS */

		/* turn off profiling */
		SM_PROF(1);
		smtp(nullserver, *p_flags, &MainEnvelope);

		if (tTd(93, 100))
		{
			/* turn off profiling */
			SM_PROF(0);
			if (OpMode == MD_DAEMON)
				goto nextreq;
		}
	}

	sm_rpool_free(MainEnvelope.e_rpool);
	clearenvelope(&MainEnvelope, false, sm_rpool_new_x(NULL));
	if (OpMode == MD_VERIFY)
	{
		set_delivery_mode(SM_VERIFY, &MainEnvelope);
		PostMasterCopy = NULL;
	}
	else
	{
		/* interactive -- all errors are global */
		MainEnvelope.e_flags |= EF_GLOBALERRS|EF_LOGSENDER;
	}

	/*
	**  Do basic system initialization and set the sender
	*/

	initsys(&MainEnvelope);
	macdefine(&MainEnvelope.e_macro, A_PERM, macid("{ntries}"), "0");
	macdefine(&MainEnvelope.e_macro, A_PERM, macid("{nrcpts}"), "0");
	setsender(from, &MainEnvelope, NULL, '\0', false);
	if (warn_f_flag != '\0' && !wordinclass(RealUserName, 't') &&
	    (!bitnset(M_LOCALMAILER, MainEnvelope.e_from.q_mailer->m_flags) ||
	     strcmp(MainEnvelope.e_from.q_user, RealUserName) != 0))
	{
		auth_warning(&MainEnvelope, "%s set sender to %s using -%c",
			     RealUserName, from, warn_f_flag);
#if SASL
		auth = false;
#endif /* SASL */
	}
	if (auth)
	{
		char *fv;

		/* set the initial sender for AUTH= to $f@@$j */
		fv = macvalue('f', &MainEnvelope);
		if (fv == NULL || *fv == '\0')
			MainEnvelope.e_auth_param = NULL;
		else
		{
			if (strchr(fv, '@@') == NULL)
			{
				i = strlen(fv) + strlen(macvalue('j',
							&MainEnvelope)) + 2;
				p = sm_malloc_x(i);
				(void) sm_strlcpyn(p, i, 3, fv, "@@",
						   macvalue('j',
							    &MainEnvelope));
			}
			else
				p = sm_strdup_x(fv);
			MainEnvelope.e_auth_param = sm_rpool_strdup_x(MainEnvelope.e_rpool,
								      xtextify(p, "="));
			sm_free(p);  /* XXX */
		}
	}
	if (macvalue('s', &MainEnvelope) == NULL)
		macdefine(&MainEnvelope.e_macro, A_PERM, 's', RealHostName);

	av = argv + optind;
	if (*av == NULL && !GrabTo)
	{
		MainEnvelope.e_to = NULL;
		MainEnvelope.e_flags |= EF_GLOBALERRS;
		HoldErrs = false;
		SuperSafe = SAFE_NO;
		usrerr("Recipient names must be specified");

		/* collect body for UUCP return */
		if (OpMode != MD_VERIFY)
			collect(InChannel, false, NULL, &MainEnvelope, true);
		finis(true, true, EX_USAGE);
		/* NOTREACHED */
	}

	/*
	**  Scan argv and deliver the message to everyone.
	*/

	save_val = LogUsrErrs;
	LogUsrErrs = true;
	sendtoargv(av, &MainEnvelope);
	LogUsrErrs = save_val;

	/* if we have had errors sofar, arrange a meaningful exit stat */
	if (Errors > 0 && ExitStat == EX_OK)
		ExitStat = EX_USAGE;

#if _FFR_FIX_DASHT
	/*
	**  If using -t, force not sending to argv recipients, even
	**  if they are mentioned in the headers.
	*/

	if (GrabTo)
	{
		ADDRESS *q;

		for (q = MainEnvelope.e_sendqueue; q != NULL; q = q->q_next)
			q->q_state = QS_REMOVED;
	}
#endif /* _FFR_FIX_DASHT */

	/*
	**  Read the input mail.
	*/

	MainEnvelope.e_to = NULL;
	if (OpMode != MD_VERIFY || GrabTo)
	{
		int savederrors;
		unsigned long savedflags;

		/*
		**  workaround for compiler warning on Irix:
		**  do not initialize variable in the definition, but
		**  later on:
		**  warning(1548): transfer of control bypasses
		**  initialization of:
		**  variable "savederrors" (declared at line 2570)
		**  variable "savedflags" (declared at line 2571)
		**  goto giveup;
		*/

		savederrors = Errors;
		savedflags = MainEnvelope.e_flags & EF_FATALERRS;
		MainEnvelope.e_flags |= EF_GLOBALERRS;
		MainEnvelope.e_flags &= ~EF_FATALERRS;
		Errors = 0;
		buffer_errors();
		collect(InChannel, false, NULL, &MainEnvelope, true);

		/* header checks failed */
		if (Errors > 0)
		{
  giveup:
			if (!GrabTo)
			{
				/* Log who the mail would have gone to */
				logundelrcpts(&MainEnvelope,
					      MainEnvelope.e_message,
					      8, false);
			}
			flush_errors(true);
			finis(true, true, ExitStat);
			/* NOTREACHED */
			return -1;
		}

		/* bail out if message too large */
		if (bitset(EF_CLRQUEUE, MainEnvelope.e_flags))
		{
			finis(true, true, ExitStat != EX_OK ? ExitStat
							    : EX_DATAERR);
			/* NOTREACHED */
			return -1;
		}

		/* set message size */
		(void) sm_snprintf(buf, sizeof(buf), "%ld",
				   PRT_NONNEGL(MainEnvelope.e_msgsize));
		macdefine(&MainEnvelope.e_macro, A_TEMP,
			  macid("{msg_size}"), buf);

		Errors = savederrors;
		MainEnvelope.e_flags |= savedflags;
	}
	errno = 0;

	if (tTd(1, 1))
		sm_dprintf("From person = \"%s\"\n",
			   MainEnvelope.e_from.q_paddr);

	/* Check if quarantining stats should be updated */
	if (MainEnvelope.e_quarmsg != NULL)
		markstats(&MainEnvelope, NULL, STATS_QUARANTINE);

	/*
	**  Actually send everything.
	**	If verifying, just ack.
	*/

	if (Errors == 0)
	{
		if (!split_by_recipient(&MainEnvelope) &&
		    bitset(EF_FATALERRS, MainEnvelope.e_flags))
			goto giveup;
	}

	/* make sure we deliver at least the first envelope */
	i = FastSplit > 0 ? 0 : -1;
	for (e = &MainEnvelope; e != NULL; e = e->e_sibling, i++)
	{
		ENVELOPE *next;

		e->e_from.q_state = QS_SENDER;
		if (tTd(1, 5))
		{
			sm_dprintf("main[%d]: QS_SENDER ", i);
			printaddr(sm_debug_file(), &e->e_from, false);
		}
		e->e_to = NULL;
		sm_getla();
		GrabTo = false;
#if NAMED_BIND
		_res.retry = TimeOuts.res_retry[RES_TO_FIRST];
		_res.retrans = TimeOuts.res_retrans[RES_TO_FIRST];
#endif /* NAMED_BIND */
		next = e->e_sibling;
		e->e_sibling = NULL;

		/* after FastSplit envelopes: queue up */
		sendall(e, i >= FastSplit ? SM_QUEUE : SM_DEFAULT);
		e->e_sibling = next;
	}

	/*
	**  All done.
	**	Don't send return error message if in VERIFY mode.
	*/

	finis(true, true, ExitStat);
	/* NOTREACHED */
	return ExitStat;
}
/*
**  STOP_SENDMAIL -- Stop the running program
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		exits.
*/

void
stop_sendmail()
{
	/* reset uid for process accounting */
	endpwent();
	(void) setuid(RealUid);
	exit(EX_OK);
}
/*
**  FINIS -- Clean up and exit.
**
**	Parameters:
**		drop -- whether or not to drop CurEnv envelope
**		cleanup -- call exit() or _exit()?
**		exitstat -- exit status to use for exit() call
**
**	Returns:
**		never
**
**	Side Effects:
**		exits sendmail
*/

void
finis(drop, cleanup, exitstat)
	bool drop;
	bool cleanup;
	volatile int exitstat;
{
	char pidpath[MAXPATHLEN];
	pid_t pid;

	/* Still want to process new timeouts added below */
	sm_clear_events();
	(void) sm_releasesignal(SIGALRM);

	if (tTd(2, 1))
	{
		sm_dprintf("\n====finis: stat %d e_id=%s e_flags=",
			   exitstat,
			   CurEnv->e_id == NULL ? "NOQUEUE" : CurEnv->e_id);
		printenvflags(CurEnv);
	}
	if (tTd(2, 9))
		printopenfds(false);

	SM_TRY
		/*
		**  Clean up.  This might raise E:mta.quickabort
		*/

		/* clean up temp files */
		CurEnv->e_to = NULL;
		if (drop)
		{
			if (CurEnv->e_id != NULL)
			{
				int r;

				r = dropenvelope(CurEnv, true, false);
				if (exitstat == EX_OK)
					exitstat = r;
				sm_rpool_free(CurEnv->e_rpool);
				CurEnv->e_rpool = NULL;

				/* these may have pointed to the rpool */
				CurEnv->e_to = NULL;
				CurEnv->e_message = NULL;
				CurEnv->e_statmsg = NULL;
				CurEnv->e_quarmsg = NULL;
				CurEnv->e_bodytype = NULL;
				CurEnv->e_id = NULL;
				CurEnv->e_envid = NULL;
				CurEnv->e_auth_param = NULL;
			}
			else
				poststats(StatFile);
		}

		/* flush any cached connections */
		mci_flush(true, NULL);

		/* close maps belonging to this pid */
		closemaps(false);

#if USERDB
		/* close UserDatabase */
		_udbx_close();
#endif /* USERDB */

#if SASL
		stop_sasl_client();
#endif /* SASL */

#if XLA
		/* clean up extended load average stuff */
		xla_all_end();
#endif /* XLA */

	SM_FINALLY
		/*
		**  And exit.
		*/

		if (LogLevel > 78)
			sm_syslog(LOG_DEBUG, CurEnv->e_id, "finis, pid=%d",
				  (int) CurrentPid);
		if (exitstat == EX_TEMPFAIL ||
		    CurEnv->e_errormode == EM_BERKNET)
			exitstat = EX_OK;

		/* XXX clean up queues and related data structures */
		cleanup_queues();
		pid = getpid();
#if SM_CONF_SHM
		cleanup_shm(DaemonPid == pid);
#endif /* SM_CONF_SHM */

		/* close locked pid file */
		close_sendmail_pid();

		if (DaemonPid == pid || PidFilePid == pid)
		{
			/* blow away the pid file */
			expand(PidFile, pidpath, sizeof(pidpath), CurEnv);
			(void) unlink(pidpath);
		}

		/* reset uid for process accounting */
		endpwent();
		sm_mbdb_terminate();
#if _FFR_MEMSTAT
		(void) sm_memstat_close();
#endif /* _FFR_MEMSTAT */
		(void) setuid(RealUid);
#if SM_HEAP_CHECK
		/* dump the heap, if we are checking for memory leaks */
		if (sm_debug_active(&SmHeapCheck, 2))
			sm_heap_report(smioout,
				       sm_debug_level(&SmHeapCheck) - 1);
#endif /* SM_HEAP_CHECK */
		if (sm_debug_active(&SmXtrapReport, 1))
			sm_dprintf("xtrap count = %d\n", SmXtrapCount);
		if (cleanup)
			exit(exitstat);
		else
			_exit(exitstat);
	SM_END_TRY
}
/*
**  INTINDEBUG -- signal handler for SIGINT in -bt mode
**
**	Parameters:
**		sig -- incoming signal.
**
**	Returns:
**		none.
**
**	Side Effects:
**		longjmps back to test mode loop.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

/* Type of an exception generated on SIGINT during address test mode.  */
static const SM_EXC_TYPE_T EtypeInterrupt =
{
	SmExcTypeMagic,
	"S:mta.interrupt",
	"",
	sm_etype_printf,
	"interrupt",
};

/* ARGSUSED */
static SIGFUNC_DECL
intindebug(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, intindebug);
	errno = save_errno;
	CHECK_CRITICAL(sig);
	errno = save_errno;
	sm_exc_raisenew_x(&EtypeInterrupt);
	errno = save_errno;
	return SIGFUNC_RETURN;
}
/*
**  SIGTERM -- SIGTERM handler for the daemon
**
**	Parameters:
**		sig -- signal number.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets ShutdownRequest which will hopefully trigger
**		the daemon to exit.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

/* ARGSUSED */
static SIGFUNC_DECL
sigterm(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, sigterm);
	ShutdownRequest = "signal";
	errno = save_errno;
	return SIGFUNC_RETURN;
}
/*
**  SIGHUP -- handle a SIGHUP signal
**
**	Parameters:
**		sig -- incoming signal.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets RestartRequest which should cause the daemon
**		to restart.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

/* ARGSUSED */
static SIGFUNC_DECL
sighup(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, sighup);
	RestartRequest = "signal";
	errno = save_errno;
	return SIGFUNC_RETURN;
}
/*
**  SIGPIPE -- signal handler for SIGPIPE
**
**	Parameters:
**		sig -- incoming signal.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets StopRequest which should cause the mailq/hoststatus
**		display to stop.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

/* ARGSUSED */
static SIGFUNC_DECL
sigpipe(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, sigpipe);
	StopRequest = true;
	errno = save_errno;
	return SIGFUNC_RETURN;
}
/*
**  INTSIG -- clean up on interrupt
**
**	This just arranges to exit.  It pessimizes in that it
**	may resend a message.
**
**	Parameters:
**		sig -- incoming signal.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Unlocks the current job.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

/* ARGSUSED */
SIGFUNC_DECL
intsig(sig)
	int sig;
{
	bool drop = false;
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, intsig);
	errno = save_errno;
	CHECK_CRITICAL(sig);
	sm_allsignals(true);
	IntSig = true;

	FileName = NULL;

	/* Clean-up on aborted stdin message submission */
	if  (OpMode == MD_SMTP ||
	     OpMode == MD_DELIVER ||
	     OpMode == MD_ARPAFTP)
	{
		if (CurEnv->e_id != NULL)
		{
			char *fn;

			fn = queuename(CurEnv, DATAFL_LETTER);
			if (fn != NULL)
				(void) unlink(fn);
			fn = queuename(CurEnv, ANYQFL_LETTER);
			if (fn != NULL)
				(void) unlink(fn);
		}
		_exit(EX_OK);
		/* NOTREACHED */
	}

	if (sig != 0 && LogLevel > 79)
		sm_syslog(LOG_DEBUG, CurEnv->e_id, "interrupt");
	if (OpMode != MD_TEST)
		unlockqueue(CurEnv);

	finis(drop, false, EX_OK);
	/* NOTREACHED */
}
/*
**  DISCONNECT -- remove our connection with any foreground process
**
**	Parameters:
**		droplev -- how "deeply" we should drop the line.
**			0 -- ignore signals, mail back errors, make sure
**			     output goes to stdout.
**			1 -- also, make stdout go to /dev/null.
**			2 -- also, disconnect from controlling terminal
**			     (only for daemon mode).
**		e -- the current envelope.
**
**	Returns:
**		none
**
**	Side Effects:
**		Trys to insure that we are immune to vagaries of
**		the controlling tty.
*/

void
disconnect(droplev, e)
	int droplev;
	register ENVELOPE *e;
{
	int fd;

	if (tTd(52, 1))
		sm_dprintf("disconnect: In %d Out %d, e=%p\n",
			   sm_io_getinfo(InChannel, SM_IO_WHAT_FD, NULL),
			   sm_io_getinfo(OutChannel, SM_IO_WHAT_FD, NULL), e);
	if (tTd(52, 100))
	{
		sm_dprintf("don't\n");
		return;
	}
	if (LogLevel > 93)
		sm_syslog(LOG_DEBUG, e->e_id,
			  "disconnect level %d",
			  droplev);

	/* be sure we don't get nasty signals */
	(void) sm_signal(SIGINT, SIG_IGN);
	(void) sm_signal(SIGQUIT, SIG_IGN);

	/* we can't communicate with our caller, so.... */
	HoldErrs = true;
	CurEnv->e_errormode = EM_MAIL;
	Verbose = 0;
	DisConnected = true;

	/* all input from /dev/null */
	if (InChannel != smioin)
	{
		(void) sm_io_close(InChannel, SM_TIME_DEFAULT);
		InChannel = smioin;
	}
	if (sm_io_reopen(SmFtStdio, SM_TIME_DEFAULT, SM_PATH_DEVNULL,
			 SM_IO_RDONLY, NULL, smioin) == NULL)
		sm_syslog(LOG_ERR, e->e_id,
			  "disconnect: sm_io_reopen(\"%s\") failed: %s",
			  SM_PATH_DEVNULL, sm_errstring(errno));

	/*
	**  output to the transcript
	**	We also compare the fd numbers here since OutChannel
	**	might be a layer on top of smioout due to encryption
	**	(see sfsasl.c).
	*/

	if (OutChannel != smioout &&
	    sm_io_getinfo(OutChannel, SM_IO_WHAT_FD, NULL) !=
	    sm_io_getinfo(smioout, SM_IO_WHAT_FD, NULL))
	{
		(void) sm_io_close(OutChannel, SM_TIME_DEFAULT);
		OutChannel = smioout;

#if 0
		/*
		**  Has smioout been closed? Reopen it.
		**	This shouldn't happen anymore, the code is here
		**	just as a reminder.
		*/

		if (smioout->sm_magic == NULL &&
		    sm_io_reopen(SmFtStdio, SM_TIME_DEFAULT, SM_PATH_DEVNULL,
				 SM_IO_WRONLY, NULL, smioout) == NULL)
			sm_syslog(LOG_ERR, e->e_id,
				  "disconnect: sm_io_reopen(\"%s\") failed: %s",
				  SM_PATH_DEVNULL, sm_errstring(errno));
#endif /* 0 */
	}
	if (droplev > 0)
	{
		fd = open(SM_PATH_DEVNULL, O_WRONLY, 0666);
		if (fd == -1)
		{
			sm_syslog(LOG_ERR, e->e_id,
				  "disconnect: open(\"%s\") failed: %s",
				  SM_PATH_DEVNULL, sm_errstring(errno));
		}
		(void) sm_io_flush(smioout, SM_TIME_DEFAULT);
		if (fd >= 0)
		{
			(void) dup2(fd, STDOUT_FILENO);
			(void) dup2(fd, STDERR_FILENO);
			(void) close(fd);
		}
	}

	/* drop our controlling TTY completely if possible */
	if (droplev > 1)
	{
		(void) setsid();
		errno = 0;
	}

#if XDEBUG
	checkfd012("disconnect");
#endif /* XDEBUG */

	if (LogLevel > 71)
		sm_syslog(LOG_DEBUG, e->e_id, "in background, pid=%d",
			  (int) CurrentPid);

	errno = 0;
}

static void
obsolete(argv)
	char *argv[];
{
	register char *ap;
	register char *op;

	while ((ap = *++argv) != NULL)
	{
		/* Return if "--" or not an option of any form. */
		if (ap[0] != '-' || ap[1] == '-')
			return;

		/* Don't allow users to use "-Q." or "-Q ." */
		if ((ap[1] == 'Q' && ap[2] == '.') ||
		    (ap[1] == 'Q' && argv[1] != NULL &&
		     argv[1][0] == '.' && argv[1][1] == '\0'))
		{
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Can not use -Q.\n");
			exit(EX_USAGE);
		}

		/* skip over options that do have a value */
		op = strchr(OPTIONS, ap[1]);
		if (op != NULL && *++op == ':' && ap[2] == '\0' &&
		    ap[1] != 'd' &&
#if defined(sony_news)
		    ap[1] != 'E' && ap[1] != 'J' &&
#endif /* defined(sony_news) */
		    argv[1] != NULL && argv[1][0] != '-')
		{
			argv++;
			continue;
		}

		/* If -C doesn't have an argument, use sendmail.cf. */
#define __DEFPATH	"sendmail.cf"
		if (ap[1] == 'C' && ap[2] == '\0')
		{
			*argv = xalloc(sizeof(__DEFPATH) + 2);
			(void) sm_strlcpyn(argv[0], sizeof(__DEFPATH) + 2, 2,
					   "-C", __DEFPATH);
		}

		/* If -q doesn't have an argument, run it once. */
		if (ap[1] == 'q' && ap[2] == '\0')
			*argv = "-q0";

		/* If -Q doesn't have an argument, disable quarantining */
		if (ap[1] == 'Q' && ap[2] == '\0')
			*argv = "-Q.";

		/* if -d doesn't have an argument, use 0-99.1 */
		if (ap[1] == 'd' && ap[2] == '\0')
			*argv = "-d0-99.1";

#if defined(sony_news)
		/* if -E doesn't have an argument, use -EC */
		if (ap[1] == 'E' && ap[2] == '\0')
			*argv = "-EC";

		/* if -J doesn't have an argument, use -JJ */
		if (ap[1] == 'J' && ap[2] == '\0')
			*argv = "-JJ";
#endif /* defined(sony_news) */
	}
}
/*
**  AUTH_WARNING -- specify authorization warning
**
**	Parameters:
**		e -- the current envelope.
**		msg -- the text of the message.
**		args -- arguments to the message.
**
**	Returns:
**		none.
*/

void
#ifdef __STDC__
auth_warning(register ENVELOPE *e, const char *msg, ...)
#else /* __STDC__ */
auth_warning(e, msg, va_alist)
	register ENVELOPE *e;
	const char *msg;
	va_dcl
#endif /* __STDC__ */
{
	char buf[MAXLINE];
	SM_VA_LOCAL_DECL

	if (bitset(PRIV_AUTHWARNINGS, PrivacyFlags))
	{
		register char *p;
		static char hostbuf[48];

		if (hostbuf[0] == '\0')
		{
			struct hostent *hp;

			hp = myhostname(hostbuf, sizeof(hostbuf));
#if NETINET6
			if (hp != NULL)
			{
				freehostent(hp);
				hp = NULL;
			}
#endif /* NETINET6 */
		}

		(void) sm_strlcpyn(buf, sizeof(buf), 2, hostbuf, ": ");
		p = &buf[strlen(buf)];
		SM_VA_START(ap, msg);
		(void) sm_vsnprintf(p, SPACELEFT(buf, p), msg, ap);
		SM_VA_END(ap);
		addheader("X-Authentication-Warning", buf, 0, e, true);
		if (LogLevel > 3)
			sm_syslog(LOG_INFO, e->e_id,
				  "Authentication-Warning: %.400s",
				  buf);
	}
}
/*
**  GETEXTENV -- get from external environment
**
**	Parameters:
**		envar -- the name of the variable to retrieve
**
**	Returns:
**		The value, if any.
*/

static char *
getextenv(envar)
	const char *envar;
{
	char **envp;
	int l;

	l = strlen(envar);
	for (envp = ExternalEnviron; envp != NULL && *envp != NULL; envp++)
	{
		if (strncmp(*envp, envar, l) == 0 && (*envp)[l] == '=')
			return &(*envp)[l + 1];
	}
	return NULL;
}
/*
**  SM_SETUSERENV -- set an environment variable in the propagated environment
**
**	Parameters:
**		envar -- the name of the environment variable.
**		value -- the value to which it should be set.  If
**			null, this is extracted from the incoming
**			environment.  If that is not set, the call
**			to sm_setuserenv is ignored.
**
**	Returns:
**		none.
*/

void
sm_setuserenv(envar, value)
	const char *envar;
	const char *value;
{
	int i, l;
	char **evp = UserEnviron;
	char *p;

	if (value == NULL)
	{
		value = getextenv(envar);
		if (value == NULL)
			return;
	}

	/* XXX enforce reasonable size? */
	i = strlen(envar) + 1;
	l = strlen(value) + i + 1;
	p = (char *) xalloc(l);
	(void) sm_strlcpyn(p, l, 3, envar, "=", value);

	while (*evp != NULL && strncmp(*evp, p, i) != 0)
		evp++;
	if (*evp != NULL)
	{
		*evp++ = p;
	}
	else if (evp < &UserEnviron[MAXUSERENVIRON])
	{
		*evp++ = p;
		*evp = NULL;
	}

	/* make sure it is in our environment as well */
	if (putenv(p) < 0)
		syserr("sm_setuserenv: putenv(%s) failed", p);
}
/*
**  DUMPSTATE -- dump state
**
**	For debugging.
*/

void
dumpstate(when)
	char *when;
{
	register char *j = macvalue('j', CurEnv);
	int rs;
	extern int NextMacroId;

	sm_syslog(LOG_DEBUG, CurEnv->e_id,
		  "--- dumping state on %s: $j = %s ---",
		  when,
		  j == NULL ? "<NULL>" : j);
	if (j != NULL)
	{
		if (!wordinclass(j, 'w'))
			sm_syslog(LOG_DEBUG, CurEnv->e_id,
				  "*** $j not in $=w ***");
	}
	sm_syslog(LOG_DEBUG, CurEnv->e_id, "CurChildren = %d", CurChildren);
	sm_syslog(LOG_DEBUG, CurEnv->e_id, "NextMacroId = %d (Max %d)",
		  NextMacroId, MAXMACROID);
	sm_syslog(LOG_DEBUG, CurEnv->e_id, "--- open file descriptors: ---");
	printopenfds(true);
	sm_syslog(LOG_DEBUG, CurEnv->e_id, "--- connection cache: ---");
	mci_dump_all(smioout, true);
	rs = strtorwset("debug_dumpstate", NULL, ST_FIND);
	if (rs > 0)
	{
		int status;
		register char **pvp;
		char *pv[MAXATOM + 1];

		pv[0] = NULL;
		status = REWRITE(pv, rs, CurEnv);
		sm_syslog(LOG_DEBUG, CurEnv->e_id,
			  "--- ruleset debug_dumpstate returns stat %d, pv: ---",
			  status);
		for (pvp = pv; *pvp != NULL; pvp++)
			sm_syslog(LOG_DEBUG, CurEnv->e_id, "%s", *pvp);
	}
	sm_syslog(LOG_DEBUG, CurEnv->e_id, "--- end of state dump ---");
}

#ifdef SIGUSR1
/*
**  SIGUSR1 -- Signal a request to dump state.
**
**	Parameters:
**		sig -- calling signal.
**
**	Returns:
**		none.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
**
**		XXX: More work is needed for this signal handler.
*/

/* ARGSUSED */
static SIGFUNC_DECL
sigusr1(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, sigusr1);
	errno = save_errno;
	CHECK_CRITICAL(sig);
	dumpstate("user signal");
# if SM_HEAP_CHECK
	dumpstab();
# endif /* SM_HEAP_CHECK */
	errno = save_errno;
	return SIGFUNC_RETURN;
}
#endif /* SIGUSR1 */

/*
**  DROP_PRIVILEGES -- reduce privileges to those of the RunAsUser option
**
**	Parameters:
**		to_real_uid -- if set, drop to the real uid instead
**			of the RunAsUser.
**
**	Returns:
**		EX_OSERR if the setuid failed.
**		EX_OK otherwise.
*/

int
drop_privileges(to_real_uid)
	bool to_real_uid;
{
	int rval = EX_OK;
	GIDSET_T emptygidset[1];

	if (tTd(47, 1))
		sm_dprintf("drop_privileges(%d): Real[UG]id=%d:%d, get[ug]id=%d:%d, gete[ug]id=%d:%d, RunAs[UG]id=%d:%d\n",
			   (int) to_real_uid,
			   (int) RealUid, (int) RealGid,
			   (int) getuid(), (int) getgid(),
			   (int) geteuid(), (int) getegid(),
			   (int) RunAsUid, (int) RunAsGid);

	if (to_real_uid)
	{
		RunAsUserName = RealUserName;
		RunAsUid = RealUid;
		RunAsGid = RealGid;
		EffGid = RunAsGid;
	}

	/* make sure no one can grab open descriptors for secret files */
	endpwent();
	sm_mbdb_terminate();

	/* reset group permissions; these can be set later */
	emptygidset[0] = (to_real_uid || RunAsGid != 0) ? RunAsGid : getegid();

	/*
	**  Notice:  on some OS (Linux...) the setgroups() call causes
	**	a logfile entry if sendmail is not run by root.
	**	However, it is unclear (no POSIX standard) whether
	**	setgroups() can only succeed if executed by root.
	**	So for now we keep it as it is; if you want to change it, use
	**  if (geteuid() == 0 && setgroups(1, emptygidset) == -1)
	*/

	if (setgroups(1, emptygidset) == -1 && geteuid() == 0)
	{
		syserr("drop_privileges: setgroups(1, %d) failed",
		       (int) emptygidset[0]);
		rval = EX_OSERR;
	}

	/* reset primary group id */
	if (to_real_uid)
	{
		/*
		**  Drop gid to real gid.
		**  On some OS we must reset the effective[/real[/saved]] gid,
		**  and then use setgid() to finally drop all group privileges.
		**  Later on we check whether we can get back the
		**  effective gid.
		*/

#if HASSETEGID
		if (setegid(RunAsGid) < 0)
		{
			syserr("drop_privileges: setegid(%d) failed",
			       (int) RunAsGid);
			rval = EX_OSERR;
		}
#else /* HASSETEGID */
# if HASSETREGID
		if (setregid(RunAsGid, RunAsGid) < 0)
		{
			syserr("drop_privileges: setregid(%d, %d) failed",
			       (int) RunAsGid, (int) RunAsGid);
			rval = EX_OSERR;
		}
# else /* HASSETREGID */
#  if HASSETRESGID
		if (setresgid(RunAsGid, RunAsGid, RunAsGid) < 0)
		{
			syserr("drop_privileges: setresgid(%d, %d, %d) failed",
			       (int) RunAsGid, (int) RunAsGid, (int) RunAsGid);
			rval = EX_OSERR;
		}
#  endif /* HASSETRESGID */
# endif /* HASSETREGID */
#endif /* HASSETEGID */
	}
	if (rval == EX_OK && (to_real_uid || RunAsGid != 0))
	{
		if (setgid(RunAsGid) < 0 && (!UseMSP || getegid() != RunAsGid))
		{
			syserr("drop_privileges: setgid(%d) failed",
			       (int) RunAsGid);
			rval = EX_OSERR;
		}
		errno = 0;
		if (rval == EX_OK && getegid() != RunAsGid)
		{
			syserr("drop_privileges: Unable to set effective gid=%d to RunAsGid=%d",
			       (int) getegid(), (int) RunAsGid);
			rval = EX_OSERR;
		}
	}

	/* fiddle with uid */
	if (to_real_uid || RunAsUid != 0)
	{
		uid_t euid;

		/*
		**  Try to setuid(RunAsUid).
		**  euid must be RunAsUid,
		**  ruid must be RunAsUid unless (e|r)uid wasn't 0
		**	and we didn't have to drop privileges to the real uid.
		*/

		if (setuid(RunAsUid) < 0 ||
		    geteuid() != RunAsUid ||
		    (getuid() != RunAsUid &&
		     (to_real_uid || geteuid() == 0 || getuid() == 0)))
		{
#if HASSETREUID
			/*
			**  if ruid != RunAsUid, euid == RunAsUid, then
			**  try resetting just the real uid, then using
			**  setuid() to drop the saved-uid as well.
			*/

			if (geteuid() == RunAsUid)
			{
				if (setreuid(RunAsUid, -1) < 0)
				{
					syserr("drop_privileges: setreuid(%d, -1) failed",
					       (int) RunAsUid);
					rval = EX_OSERR;
				}
				if (setuid(RunAsUid) < 0)
				{
					syserr("drop_privileges: second setuid(%d) attempt failed",
					       (int) RunAsUid);
					rval = EX_OSERR;
				}
			}
			else
#endif /* HASSETREUID */
			{
				syserr("drop_privileges: setuid(%d) failed",
				       (int) RunAsUid);
				rval = EX_OSERR;
			}
		}
		euid = geteuid();
		if (RunAsUid != 0 && setuid(0) == 0)
		{
			/*
			**  Believe it or not, the Linux capability model
			**  allows a non-root process to override setuid()
			**  on a process running as root and prevent that
			**  process from dropping privileges.
			*/

			syserr("drop_privileges: setuid(0) succeeded (when it should not)");
			rval = EX_OSERR;
		}
		else if (RunAsUid != euid && setuid(euid) == 0)
		{
			/*
			**  Some operating systems will keep the saved-uid
			**  if a non-root effective-uid calls setuid(real-uid)
			**  making it possible to set it back again later.
			*/

			syserr("drop_privileges: Unable to drop non-root set-user-ID privileges");
			rval = EX_OSERR;
		}
	}

	if ((to_real_uid || RunAsGid != 0) &&
	    rval == EX_OK && RunAsGid != EffGid &&
	    getuid() != 0 && geteuid() != 0)
	{
		errno = 0;
		if (setgid(EffGid) == 0)
		{
			syserr("drop_privileges: setgid(%d) succeeded (when it should not)",
			       (int) EffGid);
			rval = EX_OSERR;
		}
	}

	if (tTd(47, 5))
	{
		sm_dprintf("drop_privileges: e/ruid = %d/%d e/rgid = %d/%d\n",
			   (int) geteuid(), (int) getuid(),
			   (int) getegid(), (int) getgid());
		sm_dprintf("drop_privileges: RunAsUser = %d:%d\n",
			   (int) RunAsUid, (int) RunAsGid);
		if (tTd(47, 10))
			sm_dprintf("drop_privileges: rval = %d\n", rval);
	}
	return rval;
}
/*
**  FILL_FD -- make sure a file descriptor has been properly allocated
**
**	Used to make sure that stdin/out/err are allocated on startup
**
**	Parameters:
**		fd -- the file descriptor to be filled.
**		where -- a string used for logging.  If NULL, this is
**			being called on startup, and logging should
**			not be done.
**
**	Returns:
**		none
**
**	Side Effects:
**		possibly changes MissingFds
*/

void
fill_fd(fd, where)
	int fd;
	char *where;
{
	int i;
	struct stat stbuf;

	if (fstat(fd, &stbuf) >= 0 || errno != EBADF)
		return;

	if (where != NULL)
		syserr("fill_fd: %s: fd %d not open", where, fd);
	else
		MissingFds |= 1 << fd;
	i = open(SM_PATH_DEVNULL, fd == 0 ? O_RDONLY : O_WRONLY, 0666);
	if (i < 0)
	{
		syserr("!fill_fd: %s: cannot open %s",
		       where == NULL ? "startup" : where, SM_PATH_DEVNULL);
	}
	if (fd != i)
	{
		(void) dup2(i, fd);
		(void) close(i);
	}
}
/*
**  SM_PRINTOPTIONS -- print options
**
**	Parameters:
**		options -- array of options.
**
**	Returns:
**		none.
*/

static void
sm_printoptions(options)
	char **options;
{
	int ll;
	char **av;

	av = options;
	ll = 7;
	while (*av != NULL)
	{
		if (ll + strlen(*av) > 63)
		{
			sm_dprintf("\n");
			ll = 0;
		}
		if (ll == 0)
			sm_dprintf("\t\t");
		else
			sm_dprintf(" ");
		sm_dprintf("%s", *av);
		ll += strlen(*av++) + 1;
	}
	sm_dprintf("\n");
}

/*
**  TO8BIT -- convert \octal sequences in a test mode input line
**
**	Parameters:
**		str -- the input line.
**
**	Returns:
**		none.
**
**	Side Effects:
**		replaces \0octal in str with octal value.
*/

static bool to8bit __P((char *));

static bool
to8bit(str)
	char *str;
{
	int c, len;
	char *out, *in;
	bool changed;

	if (str == NULL)
		return false;
	in = out = str;
	changed = false;
	len = 0;
	while ((c = (*str++ & 0377)) != '\0')
	{
		int oct, nxtc;

		++len;
		if (c == '\\' &&
		    (nxtc = (*str & 0377)) == '0')
		{
			oct = 0;
			while ((nxtc = (*str & 0377)) != '\0' &&
				isascii(nxtc) && isdigit(nxtc))
			{
				oct <<= 3;
				oct += nxtc - '0';
				++str;
				++len;
			}
			changed = true;
			c = oct;
		}
		*out++ = c;
	}
	*out++ = c;
	if (changed)
	{
		char *q;

		q = quote_internal_chars(in, in, &len);
		if (q != in)
			sm_strlcpy(in, q, len);
	}
	return changed;
}

/*
**  TESTMODELINE -- process a test mode input line
**
**	Parameters:
**		line -- the input line.
**		e -- the current environment.
**	Syntax:
**		#  a comment
**		.X process X as a configuration line
**		=X dump a configuration item (such as mailers)
**		$X dump a macro or class
**		/X try an activity
**		X  normal process through rule set X
*/

static void
testmodeline(line, e)
	char *line;
	ENVELOPE *e;
{
	register char *p;
	char *q;
	auto char *delimptr;
	int mid;
	int i, rs;
	STAB *map;
	char **s;
	struct rewrite *rw;
	ADDRESS a;
	char *lbp;
	auto int lbs;
	static int tryflags = RF_COPYNONE;
	char exbuf[MAXLINE];
	char lbuf[MAXLINE];
	extern unsigned char TokTypeNoC[];
	bool eightbit;

	/* skip leading spaces */
	while (*line == ' ')
		line++;

	lbp = NULL;
	eightbit = false;
	switch (line[0])
	{
	  case '#':
	  case '\0':
		return;

	  case '?':
		help("-bt", e);
		return;

	  case '.':		/* config-style settings */
		switch (line[1])
		{
		  case 'D':
			mid = macid_parse(&line[2], &delimptr);
			if (mid == 0)
				return;
			lbs = sizeof(lbuf);
			lbp = translate_dollars(delimptr, lbuf, &lbs);
			macdefine(&e->e_macro, A_TEMP, mid, lbp);
			if (lbp != lbuf)
				SM_FREE(lbp);
			break;

		  case 'C':
			if (line[2] == '\0')	/* not to call syserr() */
				return;

			mid = macid_parse(&line[2], &delimptr);
			if (mid == 0)
				return;
			lbs = sizeof(lbuf);
			lbp = translate_dollars(delimptr, lbuf, &lbs);
			expand(lbp, exbuf, sizeof(exbuf), e);
			if (lbp != lbuf)
				SM_FREE(lbp);
			p = exbuf;
			while (*p != '\0')
			{
				register char *wd;
				char delim;

				while (*p != '\0' && isascii(*p) && isspace(*p))
					p++;
				wd = p;
				while (*p != '\0' && !(isascii(*p) && isspace(*p)))
					p++;
				delim = *p;
				*p = '\0';
				if (wd[0] != '\0')
					setclass(mid, wd);
				*p = delim;
			}
			break;

		  case '\0':
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Usage: .[DC]macro value(s)\n");
			break;

		  default:
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Unknown \".\" command %s\n", line);
			break;
		}
		return;

	  case '=':		/* config-style settings */
		switch (line[1])
		{
		  case 'S':		/* dump rule set */
			rs = strtorwset(&line[2], NULL, ST_FIND);
			if (rs < 0)
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Undefined ruleset %s\n", &line[2]);
				return;
			}
			rw = RewriteRules[rs];
			if (rw == NULL)
				return;
			do
			{
				(void) sm_io_putc(smioout, SM_TIME_DEFAULT,
						  'R');
				s = rw->r_lhs;
				while (*s != NULL)
				{
					xputs(smioout, *s++);
					(void) sm_io_putc(smioout,
							  SM_TIME_DEFAULT, ' ');
				}
				(void) sm_io_putc(smioout, SM_TIME_DEFAULT,
						  '\t');
				(void) sm_io_putc(smioout, SM_TIME_DEFAULT,
						  '\t');
				s = rw->r_rhs;
				while (*s != NULL)
				{
					xputs(smioout, *s++);
					(void) sm_io_putc(smioout,
							  SM_TIME_DEFAULT, ' ');
				}
				(void) sm_io_putc(smioout, SM_TIME_DEFAULT,
						  '\n');
			} while ((rw = rw->r_next) != NULL);
			break;

		  case 'M':
			for (i = 0; i < MAXMAILERS; i++)
			{
				if (Mailer[i] != NULL)
					printmailer(smioout, Mailer[i]);
			}
			break;

		  case '\0':
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Usage: =Sruleset or =M\n");
			break;

		  default:
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Unknown \"=\" command %s\n", line);
			break;
		}
		return;

	  case '-':		/* set command-line-like opts */
		switch (line[1])
		{
		  case 'd':
			tTflag(&line[2]);
			break;

		  case '\0':
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Usage: -d{debug arguments}\n");
			break;

		  default:
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Unknown \"-\" command %s\n", line);
			break;
		}
		return;

	  case '$':
		if (line[1] == '=')
		{
			mid = macid(&line[2]);
			if (mid != 0)
				stabapply(dump_class, mid);
			return;
		}
		mid = macid(&line[1]);
		if (mid == 0)
			return;
		p = macvalue(mid, e);
		if (p == NULL)
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Undefined\n");
		else
		{
			xputs(smioout, p);
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "\n");
		}
		return;

	  case '/':		/* miscellaneous commands */
		p = &line[strlen(line)];
		while (--p >= line && isascii(*p) && isspace(*p))
			*p = '\0';
		p = strpbrk(line, " \t");
		if (p != NULL)
		{
			while (isascii(*p) && isspace(*p))
				*p++ = '\0';
		}
		else
			p = "";
		if (line[1] == '\0')
		{
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Usage: /[canon|map|mx|parse|try|tryflags]\n");
			return;
		}
		if (sm_strcasecmp(&line[1], "quit") == 0)
		{
			CurEnv->e_id = NULL;
			finis(true, true, ExitStat);
			/* NOTREACHED */
		}
		if (sm_strcasecmp(&line[1], "mx") == 0)
		{
#if NAMED_BIND
			/* look up MX records */
			int nmx;
			auto int rcode;
			char *mxhosts[MAXMXHOSTS + 1];

			if (*p == '\0')
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Usage: /mx address\n");
				return;
			}
			nmx = getmxrr(p, mxhosts, NULL, false, &rcode, true,
				      NULL);
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "getmxrr(%s) returns %d value(s):\n",
				p, nmx);
			for (i = 0; i < nmx; i++)
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "\t%s\n", mxhosts[i]);
#else /* NAMED_BIND */
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "No MX code compiled in\n");
#endif /* NAMED_BIND */
		}
		else if (sm_strcasecmp(&line[1], "canon") == 0)
		{
			char host[MAXHOSTNAMELEN];

			if (*p == '\0')
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Usage: /canon address\n");
				return;
			}
			else if (sm_strlcpy(host, p, sizeof(host)) >= sizeof(host))
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Name too long\n");
				return;
			}
			(void) getcanonname(host, sizeof(host), !HasWildcardMX,
					    NULL);
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "getcanonname(%s) returns %s\n",
					     p, host);
		}
		else if (sm_strcasecmp(&line[1], "map") == 0)
		{
			auto int rcode = EX_OK;
			char *av[2];

			if (*p == '\0')
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Usage: /map mapname key\n");
				return;
			}
			for (q = p; *q != '\0' && !(isascii(*q) && isspace(*q));			     q++)
				continue;
			if (*q == '\0')
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "No key specified\n");
				return;
			}
			*q++ = '\0';
			map = stab(p, ST_MAP, ST_FIND);
			if (map == NULL)
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Map named \"%s\" not found\n", p);
				return;
			}
			if (!bitset(MF_OPEN, map->s_map.map_mflags) &&
			    !openmap(&(map->s_map)))
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Map named \"%s\" not open\n", p);
				return;
			}
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "map_lookup: %s (%s) ", p, q);
			av[0] = q;
			av[1] = NULL;
			p = (*map->s_map.map_class->map_lookup)
					(&map->s_map, q, av, &rcode);
			if (p == NULL)
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "no match (%d)\n",
						     rcode);
			else
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "returns %s (%d)\n", p,
						     rcode);
		}
		else if (sm_strcasecmp(&line[1], "try") == 0)
		{
			MAILER *m;
			STAB *st;
			auto int rcode = EX_OK;

			q = strpbrk(p, " \t");
			if (q != NULL)
			{
				while (isascii(*q) && isspace(*q))
					*q++ = '\0';
			}
			if (q == NULL || *q == '\0')
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Usage: /try mailer address\n");
				return;
			}
			st = stab(p, ST_MAILER, ST_FIND);
			if (st == NULL)
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Unknown mailer %s\n", p);
				return;
			}
			m = st->s_mailer;
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Trying %s %s address %s for mailer %s\n",
				     bitset(RF_HEADERADDR, tryflags) ? "header"
							: "envelope",
				     bitset(RF_SENDERADDR, tryflags) ? "sender"
							: "recipient", q, p);
			p = remotename(q, m, tryflags, &rcode, CurEnv);
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Rcode = %d, addr = %s\n",
					     rcode, p == NULL ? "<NULL>" : p);
			e->e_to = NULL;
		}
		else if (sm_strcasecmp(&line[1], "tryflags") == 0)
		{
			if (*p == '\0')
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Usage: /tryflags [Hh|Ee][Ss|Rr]\n");
				return;
			}
			for (; *p != '\0'; p++)
			{
				switch (*p)
				{
				  case 'H':
				  case 'h':
					tryflags |= RF_HEADERADDR;
					break;

				  case 'E':
				  case 'e':
					tryflags &= ~RF_HEADERADDR;
					break;

				  case 'S':
				  case 's':
					tryflags |= RF_SENDERADDR;
					break;

				  case 'R':
				  case 'r':
					tryflags &= ~RF_SENDERADDR;
					break;
				}
			}
			exbuf[0] = bitset(RF_HEADERADDR, tryflags) ? 'h' : 'e';
			exbuf[1] = ' ';
			exbuf[2] = bitset(RF_SENDERADDR, tryflags) ? 's' : 'r';
			exbuf[3] = '\0';
			macdefine(&e->e_macro, A_TEMP,
				macid("{addr_type}"), exbuf);
		}
		else if (sm_strcasecmp(&line[1], "parse") == 0)
		{
			if (*p == '\0')
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Usage: /parse address\n");
				return;
			}
			q = crackaddr(p, e);
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Cracked address = ");
			xputs(smioout, q);
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "\nParsing %s %s address\n",
					     bitset(RF_HEADERADDR, tryflags) ?
							"header" : "envelope",
					     bitset(RF_SENDERADDR, tryflags) ?
							"sender" : "recipient");
			if (parseaddr(p, &a, tryflags, '\0', NULL, e, true)
			    == NULL)
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Cannot parse\n");
			else if (a.q_host != NULL && a.q_host[0] != '\0')
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "mailer %s, host %s, user %s\n",
						     a.q_mailer->m_name,
						     a.q_host,
						     a.q_user);
			else
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "mailer %s, user %s\n",
						     a.q_mailer->m_name,
						     a.q_user);
			e->e_to = NULL;
		}
		else if (sm_strcasecmp(&line[1], "header") == 0)
		{
			unsigned long ul;

			ul = chompheader(p, CHHDR_CHECK|CHHDR_USER, NULL, e);
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "ul = %lu\n", ul);
		}
#if NETINET || NETINET6
		else if (sm_strcasecmp(&line[1], "gethostbyname") == 0)
		{
			int family = AF_INET;

			q = strpbrk(p, " \t");
			if (q != NULL)
			{
				while (isascii(*q) && isspace(*q))
					*q++ = '\0';
# if NETINET6
				if (*q != '\0' && (strcmp(q, "inet6") == 0 ||
						   strcmp(q, "AAAA") == 0))
					family = AF_INET6;
# endif /* NETINET6 */
			}
			(void) sm_gethostbyname(p, family);
		}
#endif /* NETINET || NETINET6 */
		else
		{
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Unknown \"/\" command %s\n",
					     line);
		}
		(void) sm_io_flush(smioout, SM_TIME_DEFAULT);
		return;
	}

	for (p = line; isascii(*p) && isspace(*p); p++)
		continue;
	q = p;
	while (*p != '\0' && !(isascii(*p) && isspace(*p)))
		p++;
	if (*p == '\0')
	{
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "No address!\n");
		return;
	}
	*p = '\0';
	if (tTd(23, 101))
		eightbit = to8bit(p + 1);
	if (invalidaddr(p + 1, NULL, true))
		return;
	do
	{
		register char **pvp;
		char pvpbuf[PSBUFSIZE];

		pvp = prescan(++p, ',', pvpbuf, sizeof(pvpbuf), &delimptr,
			      ConfigLevel >= 9 ? TokTypeNoC : ExtTokenTab, false);
		if (pvp == NULL)
			continue;
		p = q;
		while (*p != '\0')
		{
			int status;

			rs = strtorwset(p, NULL, ST_FIND);
			if (rs < 0)
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Undefined ruleset %s\n",
						     p);
				break;
			}
			status = REWRITE(pvp, rs, e);
			if (status != EX_OK)
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "== Ruleset %s (%d) status %d\n",
						     p, rs, status);
			else if (eightbit)
			{
				cataddr(pvp, NULL, exbuf, sizeof(exbuf), '\0',
					true);
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "cataddr: %s\n",
						     str2prt(exbuf));
			}
			while (*p != '\0' && *p++ != ',')
				continue;
		}
	} while (*(p = delimptr) != '\0');
	(void) sm_io_flush(smioout, SM_TIME_DEFAULT);
}

static void
dump_class(s, id)
	register STAB *s;
	int id;
{
	if (s->s_symtype != ST_CLASS)
		return;
	if (bitnset(bitidx(id), s->s_class))
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "%s\n", s->s_name);
}

/*
**  An exception type used to create QuickAbort exceptions.
**  This is my first cut at converting QuickAbort from longjmp to exceptions.
**  These exceptions have a single integer argument, which is the argument
**  to longjmp in the original code (either 1 or 2).  I don't know the
**  significance of 1 vs 2: the calls to setjmp don't care.
*/

const SM_EXC_TYPE_T EtypeQuickAbort =
{
	SmExcTypeMagic,
	"E:mta.quickabort",
	"i",
	sm_etype_printf,
	"quick abort %0",
};
@


1.31
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.30
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2006, 2008, 2009, 2011 Sendmail, Inc. and its suppliers.
d22 1
a22 1
"@@(#) Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.\n\
d29 1
a29 1
SM_RCSID("@@(#)$Sendmail: main.c,v 8.983 2013/03/12 15:24:52 ca Exp $")
d80 1
a80 1
**			     Sendmail, Inc. (1/98 - present).
d87 2
a88 1
**			Sendmail, Inc. (3/98 - present).
d91 2
a92 1
**			Sendmail, Inc. (12/98 - present).
d114 2
a115 2
	{	SASL_CB_VERIFYFILE,	&safesaslfile,	NULL	},
	{	SASL_CB_PROXY_POLICY,	&proxy_policy,	NULL	},
d4489 19
@


1.29
log
@Update to sendmail 8.14.6
@
text
@d29 1
a29 1
SM_RCSID("@@(#)$Sendmail: main.c,v 8.981 2012/06/14 23:54:02 ca Exp $")
d2106 1
a2106 1
						sizeof(buf)) == NULL)
d2156 7
a2162 1
		tls_ok = init_tls_library();
@


1.28
log
@Update to sendmail 8.14.5
@
text
@d29 1
a29 1
SM_RCSID("@@(#)$Sendmail: main.c,v 8.976 2011/03/15 23:14:36 ca Exp $")
d2564 4
d2834 1
a2834 1
				   MainEnvelope.e_msgsize);
@


1.27
log
@Update to sendmail-8.14.3
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2006, 2008 Sendmail, Inc. and its suppliers.
d29 1
a29 1
SM_RCSID("@@(#)$Sendmail: main.c,v 8.967 2008/03/31 16:32:13 ca Exp $")
d132 1
a132 1
	    OpMode != MD_ARPAFTP &&					\
d307 3
d407 3
d1201 1
a1201 1
	if ((ExitStat != EX_OK && OpMode != MD_TEST) ||
d1314 1
a1314 1
	if (SuperSafe == SAFE_INTERACTIVE && CurEnv->e_sendmode != SM_DELIVER)
d1575 1
d1636 3
d1946 2
a1947 2
	/* if we've had errors so far, exit now */
	if (ExitStat != EX_OK && OpMode != MD_TEST)
d1971 1
a1971 1
		dropenvelope(&BlankEnvelope, true, false);
d1994 1
a1994 1
		dropenvelope(&BlankEnvelope, true, false);
d2146 2
a2147 2
		/* check whether STARTTLS is turned off for the server */
		if (chkdaemonmodifiers(D_NOTLS))
d2543 1
a2543 1
		dropenvelope(&MainEnvelope, true, false);
d2965 5
a2969 1
				dropenvelope(CurEnv, true, false);
d3196 1
a3196 1
**		none.
a3206 2
**
**		XXX: More work is needed for this signal handler.
d3221 1
a3222 2
	if (sig != 0 && LogLevel > 79)
		sm_syslog(LOG_DEBUG, CurEnv->e_id, "interrupt");
d3226 1
a3226 2
	if (CurEnv->e_id != NULL &&
	    (OpMode == MD_SMTP ||
d3228 1
a3228 1
	     OpMode == MD_ARPAFTP))
d3230 3
a3232 1
		register ADDRESS *q;
d3234 10
a3243 4
		/* don't return an error indication */
		CurEnv->e_to = NULL;
		CurEnv->e_flags &= ~EF_FATALERRS;
		CurEnv->e_flags |= EF_CLRQUEUE;
d3245 3
a3247 12
		/*
		**  Spin through the addresses and
		**  mark them dead to prevent bounces
		*/

		for (q = CurEnv->e_sendqueue; q != NULL; q = q->q_next)
			q->q_state = QS_DONTSEND;

		drop = true;
	}
	else if (OpMode != MD_TEST)
	{
a3248 1
	}
@


1.26
log
@Fix a use-after-free bug in the envelope code just after a port 25 fork.

From Matthew Dillon@@DragonFlyBSD

ok millert@@ dlg@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2006 Sendmail, Inc. and its suppliers.
d29 1
a29 1
SM_RCSID("@@(#)$Sendmail: main.c,v 8.962 2006/12/19 19:47:37 ca Exp $")
d305 3
d407 7
d2375 27
a2401 1
			(void) runqueue(true, false, queuepersistent, true);
d2556 3
a2558 6
		{
			SM_RPOOL_T *opool = MainEnvelope.e_rpool;
			(void) newenvelope(&MainEnvelope, &MainEnvelope,
					   sm_rpool_new_x(NULL));
			sm_rpool_free(opool);
		}
@


1.25
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d2520 6
a2525 3
		sm_rpool_free(MainEnvelope.e_rpool);
		(void) newenvelope(&MainEnvelope, &MainEnvelope,
				   sm_rpool_new_x(NULL));
@


1.24
log
@Update to sendmail-8.13.8
@
text
@d16 1
d29 1
a29 1
SM_RCSID("@@(#)$Sendmail: main.c,v 8.944.2.2 2006/08/03 22:05:03 ca Exp $")
d235 1
a235 1
	TermEscape.te_rv_on = TermEscape.te_rv_off = "";
d309 1
a309 1
	tTsetup(tTdvect, sizeof tTdvect, "0-99.1,*_trace_*.1");
d481 1
a481 1
		(void) memset(tTdvect, '\0', sizeof tTdvect);
d525 1
a525 1
		(void) sm_strlcpy(rnamebuf, pw->pw_name, sizeof rnamebuf);
d527 1
a527 1
		(void) sm_snprintf(rnamebuf, sizeof rnamebuf, "Unknown UID %d",
d571 1
a571 1
	SaveArgv = (char **) xalloc(sizeof (char *) * (argc + 1));
d695 1
a695 1
	hp = myhostname(jbuf, sizeof jbuf);
d756 1
a756 1
				(void) sm_snprintf(ipbuf, sizeof ipbuf,
d767 1
a767 1
				addr = anynet_ntop(&ia6, buf6, sizeof buf6);
d769 1
a769 1
					(void) sm_snprintf(ipbuf, sizeof ipbuf,
d867 1
a867 1
			(void) sm_snprintf(buf, sizeof buf, "%d",
d1010 1
a1010 1
				new = (QUEUE_CHAR *) xalloc(sizeof *new);
d1018 1
a1018 1
				new = (QUEUE_CHAR *) xalloc(sizeof *new);
d1026 1
a1026 1
				new = (QUEUE_CHAR *) xalloc(sizeof *new);
d1040 1
a1040 1
					new = (QUEUE_CHAR *) xalloc(sizeof *new);
d1234 1
a1234 1
			(void) sm_strlcat(mbuf, ", stdin", sizeof mbuf);
d1236 1
a1236 1
			(void) sm_strlcat(mbuf, ", stdout", sizeof mbuf);
d1238 1
a1238 1
			(void) sm_strlcat(mbuf, ", stderr", sizeof mbuf);
d1381 1
a1381 1
	expand("\201m", jbuf, sizeof jbuf, &BlankEnvelope);
d1396 1
a1396 1
		expand(PidFile, pidpath, sizeof pidpath, &BlankEnvelope);
d1743 1
a1743 1
	expand("\201j", jbuf, sizeof jbuf, &BlankEnvelope);
d2086 1
a2086 1
						sizeof buf) == NULL)
d2116 2
a2117 1
	if (OpMode == MD_QUEUERUN || OpMode == MD_DELIVER)
d2329 1
a2329 1
			(void) sm_strlcat(dtype, "+SMTP", sizeof dtype);
d2339 1
a2339 1
					   sizeof dtype);
d2342 1
a2342 1
			(void) sm_strlcat(dtype, "+debugging", sizeof dtype);
d2440 3
a2442 2
							  "persistent queue runner=%d died, signal=%d",
							  group, WTERMSIG(status));
d2460 1
d2479 1
a2479 1
				(void) sm_strlcpyn(qtype, sizeof qtype, 4,
d2548 1
a2548 1
			(void) sm_snprintf(ipbuf, sizeof ipbuf, "[%.100s]",
d2566 1
a2566 1
			(void) sm_snprintf(pbuf, sizeof pbuf, "%d",
d2572 1
a2572 1
			(void) sm_snprintf(pbuf, sizeof pbuf, "%d",
d2577 1
a2577 1
			(void) sm_snprintf(pbuf, sizeof pbuf, "0");
d2585 2
d2589 2
d2593 5
a2597 2
							&MainEnvelope),
						&MainEnvelope);
d2602 1
a2602 1
			p_flags = (BITMAP256 *) xalloc(sizeof *p_flags);
d2783 1
a2783 1
		(void) sm_snprintf(buf, sizeof buf, "%ld",
d2923 1
a2923 1
				/* this may have pointed to the rpool */
d2925 7
d2982 1
a2982 1
			expand(PidFile, pidpath, sizeof pidpath, CurEnv);
d3439 1
a3439 1
			hp = myhostname(hostbuf, sizeof hostbuf);
d3449 1
a3449 1
		(void) sm_strlcpyn(buf, sizeof buf, 2, hostbuf, ": ");
d3454 1
a3454 1
		addheader("X-Authentication-Warning", buf, 0, e);
a3609 3
# if SM_HEAP_CHECK
	extern void dumpstab __P((void));
# endif /* SM_HEAP_CHECK */
d3914 63
d4006 2
d4010 1
d4012 1
d4018 2
d4037 5
a4041 2
			translate_dollars(delimptr);
			macdefine(&e->e_macro, A_TEMP, mid, delimptr);
d4051 5
a4055 2
			translate_dollars(delimptr);
			expand(delimptr, exbuf, sizeof exbuf, e);
d4251 1
a4251 1
			else if (sm_strlcpy(host, p, sizeof host) >= sizeof host)
d4257 1
a4257 1
			(void) getcanonname(host, sizeof host, !HasWildcardMX,
d4425 8
d4439 1
d4455 2
d4464 2
a4465 2
		pvp = prescan(++p, ',', pvpbuf, sizeof pvpbuf, &delimptr,
			      ConfigLevel >= 9 ? TokTypeNoC : NULL, false);
d4486 8
d4498 1
@


1.23
log
@Fix use-after-free bug, which was triggered with too
long header lines. Diff from Claus Assmann.

ok thib@@ millert@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2005 Sendmail, Inc. and its suppliers.
d28 1
a28 1
SM_RCSID("@@(#)$Sendmail: main.c,v 8.942 2005/12/26 04:39:13 ca Exp $")
d519 2
d2292 2
d2881 1
d2911 2
d2953 1
d2955 1
a2955 1
		cleanup_shm(DaemonPid == getpid());
d2961 1
a2961 1
		if (DaemonPid == getpid() || PidFilePid == getpid())
d3287 1
d3291 1
d3293 6
a3298 3
		(void) dup2(fd, STDOUT_FILENO);
		(void) dup2(fd, STDERR_FILENO);
		(void) close(fd);
@


1.22
log
@Update to sendmail 8.13.6
@
text
@d2906 1
@


1.21
log
@Update to sendmail.8.13.0
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004 Sendmail, Inc. and its suppliers.
d28 1
a28 1
SM_RCSID("@@(#)$Sendmail: main.c,v 8.939 2004/06/17 16:39:21 ca Exp $")
d652 1
a652 1
	setuserenv("AGENT", "sendmail");
d1321 1
a1321 1
		setuserenv("TZ", TimeZoneSpec);
d1323 1
a1323 1
		setuserenv("TZ", NULL);
d1465 10
d2962 3
d3455 1
a3455 1
**  SETUSERENV -- set an environment in the propagated environment
d3462 1
a3462 1
**			to setuserenv is ignored.
d3469 1
a3469 1
setuserenv(envar, value)
d3504 1
a3504 1
		syserr("setuserenv: putenv(%s) failed", p);
@


1.21.6.1
log
@MFC:
Fix by moritz@@

Fix use-after-free bug, which was triggered with too
long header lines. Diff from Claus Assmann.
@
text
@a2895 1
				CurEnv->e_to = NULL;
@


1.21.8.1
log
@MFC:
Fix by moritz@@

Fix use-after-free bug, which was triggered with too
long header lines. Diff from Claus Assmann.
@
text
@a2895 1
				CurEnv->e_to = NULL;
@


1.20
log
@Update to sendmail 8.12.11.  I've been runninga beta version of this for
some time without problems.  See the RELEASE_NOTES for the change log.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d21 1
a21 1
"@@(#) Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.\n\
d28 1
a28 1
SM_RCSID("@@(#)$Sendmail: main.c,v 8.887.2.29 2003/11/07 00:09:31 ca Exp $")
a177 1
#if _FFR_QUARANTINE
a178 1
#endif /* _FFR_QUARANTINE */
d185 1
d270 1
a270 7
	i = DtableSize;
	while (--i > 0)
	{
		if (i != STDIN_FILENO && i != STDOUT_FILENO &&
		    i != STDERR_FILENO)
			(void) close(i);
	}
d272 1
d368 9
a376 21
#if _FFR_QUARANTINE
# if defined(__osf__) || defined(_AIX3)
#  define OPTIONS	"A:B:b:C:cd:e:F:f:Gh:IiL:M:mN:nO:o:p:q:R:r:sTtV:vX:xQ:"
# endif /* defined(__osf__) || defined(_AIX3) */
# if defined(sony_news)
#  define OPTIONS	"A:B:b:C:cd:E:e:F:f:Gh:IiJ:L:M:mN:nO:o:p:q:R:r:sTtV:vX:Q:"
# endif /* defined(sony_news) */
# ifndef OPTIONS
#  define OPTIONS	"A:B:b:C:cd:e:F:f:Gh:IiL:M:mN:nO:o:p:q:R:r:sTtV:vX:Q:"
# endif /* ! OPTIONS */
#else /* _FFR_QUARANTINE */
# if defined(__osf__) || defined(_AIX3)
#  define OPTIONS	"A:B:b:C:cd:e:F:f:Gh:IiL:M:mN:nO:o:p:q:R:r:sTtV:vX:x"
# endif /* defined(__osf__) || defined(_AIX3) */
# if defined(sony_news)
#  define OPTIONS	"A:B:b:C:cd:E:e:F:f:Gh:IiJ:L:M:mN:nO:o:p:q:R:r:sTtV:vX:"
# endif /* defined(sony_news) */
# ifndef OPTIONS
#  define OPTIONS	"A:B:b:C:cd:e:F:f:Gh:IiL:M:mN:nO:o:p:q:R:r:sTtV:vX:"
# endif /* ! OPTIONS */
#endif /* _FFR_QUARANTINE */
d416 21
d440 1
a440 1
			(void) sm_io_setvbuf(smioout, SM_TIME_DEFAULT,
d457 1
a457 1
			j = SM_MIN(strlen(optarg), 24) + 1;
a463 1
#if _FFR_QUARANTINE
a464 1
#endif /* _FFR_QUARANTINE */
d478 1
a671 2
	if (bitset(RES_NOALIASES, _res.options))
		ResNoAliases = true;
d704 2
a705 17
		if (p != NULL)
		{
			if (p[1] != '\0')
			{
				macdefine(&BlankEnvelope.e_macro, A_TEMP, 'm',
					  &p[1]);
			}
			while (p != NULL && strchr(&p[1], '.') != NULL)
			{
				*p = '\0';
				if (tTd(0, 4))
					sm_dprintf("\ta.k.a.: %s\n", jbuf);
				setclass('w', jbuf);
				*p++ = '.';
				p = strchr(p, '.');
			}
		}
a793 1
#if _FFR_QUARANTINE
a794 1
#endif /* _FFR_QUARANTINE */
d828 1
a943 1
#if _FFR_QUARANTINE
a960 1
#endif /* _FFR_QUARANTINE */
a1033 1
#if _FFR_QUARANTINE
a1048 1
#endif /* _FFR_QUARANTINE */
d1291 2
a1292 2
	if (FallBackMX != NULL)
		(void) getfallbackmxrr(FallBackMX);
d1401 1
a1401 1
		xputs(macvalue('w', &BlankEnvelope));
d1403 1
a1403 1
		xputs(macvalue('j', &BlankEnvelope));
d1405 1
a1405 1
		xputs(macvalue('m', &BlankEnvelope));
d1407 1
a1407 1
		xputs(macvalue('k', &BlankEnvelope));
a1441 4
	/* be sure we don't pick up bogus HOSTALIASES environment variable */
	if (OpMode == MD_QUEUERUN && RealUid != 0)
		(void) unsetenv("HOSTALIASES");

a1473 1
#if _FFR_QUARANTINE
d1477 5
a1481 4
#endif /* _FFR_QUARANTINE */
			/* Normal users can do a single queue run */
			if (QueueIntvl == 0)
				break;
d1736 1
a1736 1
		message("WARNING: local host name (%s) is not qualified; fix $j in config file",
a1895 1
# if _FFR_MILTER_PERDAEMON
a1896 1
# endif /* _FFR_MILTER_PERDAEMON */
a1967 1
#if _FFR_QUARANTINE
a1984 1
#endif /* _FFR_QUARANTINE */
d2031 1
a2031 1
				printmailer(Mailer[i]);
d2261 1
a2261 1
			      PROC_DAEMON, 0, -1);
d2360 7
d2470 1
d2472 1
d2538 2
d2570 3
a2572 2
							 RealHostName,
							 &MainEnvelope);
a2771 1
#if _FFR_QUARANTINE
a2774 1
#endif /* _FFR_QUARANTINE */
d2798 1
a2798 1
			printaddr(&e->e_from, false);
d2866 1
d2939 10
a3304 1
#if _FFR_QUARANTINE
a3313 1
#endif /* _FFR_QUARANTINE */
a3340 1
#if _FFR_QUARANTINE
a3343 1
#endif /* _FFR_QUARANTINE */
d3523 1
a3523 1
	mci_dump_all(true);
d3991 1
a3991 1
					xputs(*s++);
d4002 1
a4002 1
					xputs(*s++);
d4015 1
a4015 1
					printmailer(Mailer[i]);
d4067 1
a4067 1
			xputs(p);
d4284 1
a4284 1
			xputs(q);
d4336 2
a4337 2
		pvp = prescan(++p, ',', pvpbuf, sizeof pvpbuf,
			      &delimptr, ConfigLevel >= 9 ? TokTypeNoC : NULL);
@


1.19
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d28 1
a28 1
SM_RCSID("@@(#)$Sendmail: main.c,v 8.887.2.27 2003/08/04 17:23:37 ca Exp $")
d2237 1
d2239 14
d2254 9
d2398 1
d2400 13
d2414 9
@


1.18
log
@Update to sendmail 8.12.9; fixes a buffer overflow in address parsing
due to a char to int conversion problem which is potentially remotely
exploitable.
@
text
@d28 1
a28 1
SM_RCSID("@@(#)$Sendmail: main.c,v 8.887.2.22 2003/03/06 18:38:08 ca Exp $")
d943 3
a945 2
					ep = sm_malloc_x(strlen(p) + 1);
					cleanstrcpy(ep, p, MAXNAME);
d952 3
a954 2
				ep = sm_malloc_x(strlen(optarg) + 1);
				cleanstrcpy(ep, optarg, MAXNAME);
d2373 1
a2373 7
					if (ShutdownRequest != NULL)
						shutdown_daemon();
					else if (RestartRequest != NULL)
						restart_daemon();
					else if (RestartWorkGroup)
						restart_marked_work_groups();

d2391 3
a2393 2
							/* don't restart this one */
							mark_work_group_restart(group, -1);
d2414 2
a2415 1
						mark_work_group_restart(group, -1);
d2444 1
a2444 7
					if (ShutdownRequest != NULL)
						shutdown_daemon();
					else if (RestartRequest != NULL)
						restart_daemon();
					else if (RestartWorkGroup)
						restart_marked_work_groups();

d2638 1
a2638 1
			collect(InChannel, false, NULL, &MainEnvelope);
d2698 1
a2698 1
		collect(InChannel, false, NULL, &MainEnvelope);
@


1.17
log
@Update to Sendmail 8.12.8; fixes a buffer overflow in the envelope
comments processing which may allow an attacker to gain root privileges.
@
text
@d28 1
a28 1
SM_RCSID("@@(#)$Sendmail: main.c,v 8.887.2.20 2003/02/07 17:57:44 ca Exp $")
d131 1
d396 1
d447 7
@


1.16
log
@update to sendmail 8.12.7
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d28 1
a28 1
SM_RCSID("@@(#)$Sendmail: main.c,v 8.887.2.12 2002/12/05 17:38:44 ca Exp $")
d80 1
a80 1
**		The support of the my employers is gratefully acknowledged.
d4244 1
a4244 1
			q = crackaddr(p);
@


1.15
log
@update to sendmail-8.12.6
@
text
@d28 1
a28 1
SM_RCSID("@@(#)$Sendmail: main.c,v 8.887.2.1 2002/08/04 17:36:06 gshapiro Exp $")
d216 4
a615 3
	InChannel = smioin;
	OutChannel = smioout;

d849 4
a852 1
			from = newstr(denlstring(optarg, true, true));
d1397 2
d1402 2
a1403 1
		sm_dprintf("      Pid file:\t%s (selected)\n", PidFile);
d2194 2
d2206 5
d2212 1
a2212 2
						      false, Verbose,
						      queuepersistent, false);
d2456 1
a2456 1
#if PROFILING
a2457 1
#endif /* PROFILING */
d2481 1
a2481 1
		sm_syslog(LOG_INFO, NULL, "connect from %.100s", authinfo);
d2556 8
a2563 6
#if PROFILING
		/* turn off profiling */
		SM_PROF(0);
		if (OpMode == MD_DAEMON)
			goto nextreq;
#endif /* PROFILING */
d4103 1
a4103 1
			(void) getcanonname(host, sizeof host, HasWildcardMX,
@


1.15.2.1
log
@Errata #009:
A buffer overflow in the envelope comments processing in sendmail may
allow an attacker to gain root privileges.
@
text
@d4230 1
a4230 1
			q = crackaddr(p, e);
@


1.14
log
@sendmail 8.12.5
@
text
@d28 1
a28 1
SM_RCSID("@@(#)$Sendmail: main.c,v 8.887 2002/06/17 22:25:52 gshapiro Exp $")
d3383 1
a3383 1
	for (envp = ExternalEnviron; *envp != NULL; envp++)
@


1.13
log
@Update to sendmail-8.12.4
@
text
@d28 1
a28 1
SM_RCSID("@@(#)$Sendmail: main.c,v 8.882 2002/05/10 16:20:55 ca Exp $")
d1067 5
d1196 4
a1199 2
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			  macid("{daemon_flags}"), "CC f");
d1204 5
a1208 2
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			  macid("{daemon_flags}"), "c u");
d2256 1
a2256 1
	if (OpMode == MD_DAEMON || QueueIntvl != 0)
d2296 1
a2296 1
		if (QueueIntvl != 0)
d2327 1
a2327 1
		if (QueueIntvl != 0)
@


1.12
log
@update to sendmail 8.12.3
@
text
@d28 1
a28 1
SM_RCSID("@@(#)$Sendmail: main.c,v 8.876 2002/02/27 23:49:52 ca Exp $")
d645 2
d2700 7
d2812 1
@


1.11
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d28 1
a28 1
SM_RCSID("@@(#)$Sendmail: main.c,v 8.868 2001/12/29 04:54:38 ca Exp $")
d329 1
a329 1
	if (extraprivs)
d334 5
d397 2
a398 1
			switch (j = *optarg)
a552 7
	if (j < 0 || j > SM_ARG_MAX)
	{
		syserr("!Arguments too long");

		/* NOTREACHED */
		return EX_USAGE;
	}
d2181 4
a2184 1
				runqueueevent(qgrp);
d3542 1
d3626 1
a3626 1
		uid_t euid = geteuid();
d3631 2
a3632 3
		**  ruid must be RunAsUid unless it's the MSP and the euid
		**  wasn't 0 and we didn't have to drop privileges to the
		**  real uid.
d3636 3
a3638 3
		    (getuid() != RunAsUid  &&
		     (!UseMSP || euid == 0 || to_real_uid )) ||
		    geteuid() != RunAsUid)
d3647 1
a3647 1
			if (euid == RunAsUid)
d3670 1
@


1.11.2.1
log
@Errata #022:
A buffer overflow in the envelope comments processing in sendmail may
allow an attacker to gain root privileges.
@
text
@d4207 1
a4207 1
			q = crackaddr(p, e);
@


1.10
log
@Don't call syserr() just because stderr is not present.  Daemons
and programs that pipe data to sendmail may not have stderr available.
From ca @@ sendmail.
@
text
@d28 1
a28 1
SM_RCSID("@@(#)$Sendmail: main.c,v 8.831 2001/09/25 22:25:58 ca Exp $")
d161 2
a162 1
	int save_errno;
d176 4
a179 1
	char *runqueuegroup = NULL;	/* queue group to process */
d184 1
d206 4
a238 10
	/*
	**  Seed the random number generator.
	**  Used for queue file names, picking a queue directory, and
	**  MX randomization.
	*/

	seed_random();

	/* do machine-dependent initializations */
	init_md(argc, argv);
a243 1

d254 2
a255 2
	/* reset errno and save_errno; the latter is used down below */
	errno = save_errno = 0;
d258 1
a258 1
		save_errno = errno;
d261 1
a261 1
		save_errno = errno;
d264 1
a264 1
		save_errno = errno;
d286 7
a292 5
	SyslogPrefixLen = PIDLEN + (MAXQFNAME - 3) + SL_FUDGE + SLDLL;
	if (MissingFds != 0)
	{
		bool err = false;
		char mbuf[MAXLINE];
d294 2
a295 13
		mbuf[0] = '\0';
		if (bitset(1 << STDIN_FILENO, MissingFds))
		{
			err = true;
			(void) sm_strlcat(mbuf, ", stdin", sizeof mbuf);
		}
		if (bitset(1 << STDOUT_FILENO, MissingFds))
		{
			err = true;
			(void) sm_strlcat(mbuf, ", stdout", sizeof mbuf);
		}
		if (bitset(1 << STDERR_FILENO, MissingFds))
			(void) sm_strlcat(mbuf, ", stderr", sizeof mbuf);
a296 9
		/*
		**  hack for syserr(), otherwise nothing is logged because
		**  LogLevel is set later on (setdefaults()).
		**  XXX should this really be syserr()?
		**  For example, arpwatch closes std{in,out,err} as daemon
		**  and only reassigns stdin to the file it wants to mail.
		**  This causes "bogus" syserrors and dumpfd output without
		**  any explanation why this happened.
		*/
d298 1
a298 12
		errno = save_errno;
		if (err)
		{
			LogLevel = 1;
			syserr("File descriptors missing on startup: %s",
				&mbuf[2]);
		}
		else
			sm_syslog(LOG_WARNING, NOQID,
				  "File descriptors missing on startup: %s",
				  &mbuf[2]);
	}
d329 1
a329 2
	if (getuid() == 0 ||
	    (getuid() == geteuid() && getgid() == getegid()))
d364 22
a385 9
#if defined(__osf__) || defined(_AIX3)
# define OPTIONS	"A:B:b:C:cd:e:F:f:Gh:IiL:M:mN:nO:o:p:q:R:r:sTtV:vX:x"
#endif /* defined(__osf__) || defined(_AIX3) */
#if defined(sony_news)
# define OPTIONS	"A:B:b:C:cd:E:e:F:f:Gh:IiJ:L:M:mN:nO:o:p:q:R:r:sTtV:vX:"
#endif /* defined(sony_news) */
#ifndef OPTIONS
# define OPTIONS	"A:B:b:C:cd:e:F:f:Gh:IiL:M:mN:nO:o:p:q:R:r:sTtV:vX:"
#endif /* ! OPTIONS */
d410 3
a412 3
				usrerr("Frozen configurations unsupported");
				ExitStat = EX_USAGE;
				break;
d415 4
a418 3
				usrerr("Invalid operation mode %c", j);
				ExitStat = EX_USAGE;
				break;
d442 3
d511 1
a511 1
		finis(false, EX_OK);
d799 1
a799 1
	QueueLimitReason = (QUEUE_CHAR *) NULL;
d944 20
d999 7
a1005 1
				runqueuegroup = newstr(&optarg[1]);
d1037 1
a1037 1
			  case 'H': /* Limit by recipient */
d1043 2
a1044 2
					new->queue_next = QueueLimitReason;
					QueueLimitReason = new;
d1046 1
a1046 1
				QueueMode = QM_HELD;
d1174 1
a1174 1
			finis(true, EX_USAGE);
d1184 1
a1184 1
		finis(false, ExitStat);
d1218 19
d1258 1
a1258 1
			finis(false, EX_OSERR);
d1275 1
a1275 1
			finis(false, EX_OSERR);
d1298 1
a1298 1
		finis(false, EX_USAGE);
d1301 3
a1303 3
	if (OpMode == MD_DELIVER || OpMode == MD_SMTP || OpMode == MD_ARPAFTP ||
	    OpMode == MD_DAEMON || OpMode == MD_FGDAEMON ||
	    OpMode == MD_QUEUERUN)
d1338 1
a1338 1
			finis(false, dp);
d1350 1
a1350 1
			finis(false, EX_CONFIG);
d1384 1
a1384 2
			   getcfname(OpMode, SubmitMode, SM_GET_RIGHT_CF,
				     conffile));
d1421 1
a1421 4
	if (i == BODYTYPE_NONE)
		/* EMPTY */
		/* nothing */ ;
	else if (i == BODYTYPE_ILLEGAL)
d1426 2
a1427 1
	else SevenBitInput = (i == BODYTYPE_7BIT);
d1469 5
d1501 1
d1503 1
a1503 1
			finis(false, EX_USAGE);
d1534 1
a1534 1
					finis(true, dp);
d1558 1
d1560 1
a1560 1
				finis(false, EX_USAGE);
d1565 1
d1568 1
a1568 1
				finis(false, EX_USAGE);
d1862 3
a1864 3
		if (tTd(0, 2))
			sm_dprintf("Cannot use HostStatusDirectory = %s: %s\n",
				   HostStatDir, sm_errstring(errno));
d1879 1
d1881 1
a1881 1
			finis(false, EX_NOPERM);
d1897 13
d1913 1
a1913 1
		finis(false, ExitStat);
d1934 1
d1937 14
d1952 1
a1952 1
		finis(false, EX_OK);
d1961 1
a1961 1
		finis(false, EX_OK);
d1965 20
d1988 1
a1988 1
		finis(false, EX_OK);
d1994 1
a1994 1
		finis(false, EX_OK);
d2001 1
a2001 1
		finis(false, ExitStat);
d2058 2
d2065 1
a2136 1
		int qgrp = NOQGRP;
a2143 13
		if (runqueuegroup != NULL)
		{
			/* Selecting a particular queue group to run */
			qgrp = name2qid(runqueuegroup);
			if (qgrp == NOQGRP)
			{
				usrerr("Queue group %s unknown",
					runqueuegroup);
				finis(true, ExitStat);
				/* NOTREACHED */
			}
		}

d2206 1
a2206 1
				(void) proc_list_drop(ret, NULL, NULL);
d2209 1
a2209 1
		finis(true, ExitStat);
d2224 9
d2254 1
a2254 1
				finis(false, EX_OK);
d2349 1
a2349 2
					(void) proc_list_drop(ret, NULL,
							      &group);
d2360 1
d2381 1
a2381 1
						continue;
a2382 3

					/* restart this persistent runner */
					mark_work_group_restart(group, status);
d2384 1
a2384 1
				finis(true, ExitStat);
d2610 1
a2610 1
		finis(true, EX_USAGE);
d2618 2
d2621 1
d2649 2
a2650 2
		int savederrors = Errors;
		long savedflags = MainEnvelope.e_flags & EF_FATALERRS;
d2652 13
d2674 1
d2683 1
a2683 1
			finis(true, ExitStat);
d2691 2
a2692 1
			finis(true, ExitStat != EX_OK ? ExitStat : EX_DATAERR);
d2705 6
d2717 5
a2721 1
		split_by_recipient(&MainEnvelope);
d2755 1
a2755 1
	finis(true, ExitStat);
d2785 1
d2796 1
a2796 1
finis(drop, exitstat)
d2798 1
d2884 4
a2887 1
		exit(exitstat);
d3089 1
a3089 1
	finis(drop, EX_OK);
d3228 12
d3266 6
d3566 1
a3566 1
	if (to_real_uid || RunAsGid != 0)
d3569 1
a3582 1
		else
a3590 1
		else
a3598 1
		else
d3602 4
a3605 1
		if (setgid(RunAsGid) < 0)
d3611 2
a3612 5
		else if (getegid() != RunAsGid
#if !SM_CONF_CANT_SETRGID
			 || getgid() != RunAsGid
#endif /* !SM_CONF_CANT_SETRGID */
			)
d3614 2
a3615 1
			syserr("drop_privileges: Unable to drop set-group-ID privileges");
d3619 2
d3625 8
d3634 3
a3636 1
		    getuid() != RunAsUid || geteuid() != RunAsUid)
a3830 2
	macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), "e r");

d4020 1
a4020 1
			finis(true, ExitStat);
d4295 1
a4295 1
	if (s->s_type != ST_CLASS)
@


1.9
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d291 1
d296 2
d299 1
d301 2
d304 1
d319 10
a328 2
		LogLevel = 1;
		syserr("File descriptors missing on startup: %s", &mbuf[2]);
@


1.8
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d28 1
a28 1
SM_RCSID("@@(#)$Sendmail: main.c,v 8.804 2001/09/08 01:21:09 gshapiro Exp $")
d126 21
d161 1
d168 1
d176 1
d223 7
d256 2
d259 2
d262 2
d265 2
d300 13
d331 1
d333 2
d364 17
d395 30
d426 1
d445 4
d453 9
a494 1
	set_op_mode(MD_DELIVER);
d496 2
a497 2
	RealUid = getuid();
	RealGid = getgid();
d588 7
a594 6
		/* XXX This doesn't work because OpMode isn't set correctly */
		sm_dprintf(" Def Conf file:\t%s\n", getcfname(OpMode,
							      SubmitMode,
							      SM_GET_RIGHT_CF,
							      conffile));
		sm_dprintf("  Def Pid file:\t%s\n", PidFile);
d631 1
d635 2
d687 1
a687 1
			sm_dprintf("canonical name: %s\n", jbuf);
d798 3
a805 15
	av = argv;
	p = strrchr(*av, '/');
	if (p++ == NULL)
		p = *av;
	if (strcmp(p, "newaliases") == 0)
		set_op_mode(MD_INITALIAS);
	else if (strcmp(p, "mailq") == 0)
		set_op_mode(MD_PRINT);
	else if (strcmp(p, "smtpd") == 0)
		set_op_mode(MD_DAEMON);
	else if (strcmp(p, "hoststat") == 0)
		set_op_mode(MD_HOSTSTAT);
	else if (strcmp(p, "purgestat") == 0)
		set_op_mode(MD_PURGESTAT);

d812 1
a812 27
			switch (j = *optarg)
			{
			  case MD_DAEMON:
			  case MD_FGDAEMON:
			  case MD_SMTP:
			  case MD_INITALIAS:
			  case MD_DELIVER:
			  case MD_VERIFY:
			  case MD_TEST:
			  case MD_PRINT:
			  case MD_PRINTNQE:
			  case MD_HOSTSTAT:
			  case MD_PURGESTAT:
			  case MD_ARPAFTP:
				set_op_mode(j);
				break;

			  case MD_FREEZE:
				usrerr("Frozen configurations unsupported");
				ExitStat = EX_USAGE;
				break;

			  default:
				usrerr("Invalid operation mode %c", j);
				ExitStat = EX_USAGE;
				break;
			}
d821 1
d834 2
a835 1
		  case 'd':	/* debugging -- already done */
d840 1
d853 1
d859 1
d863 1
d882 1
d887 1
d922 1
a962 1

d1010 18
d1035 2
a1036 1
				/* FALL THRU */
d1049 1
d1069 1
d1074 1
d1153 8
a1160 1
	av += optind;
d1246 2
a1247 1
		printf("WARNING: SuperSafe=interactive should only be used with\n         DeliveryMode=interactive\n");
d1335 9
d1376 2
a1377 1
	if (BlankEnvelope.e_bodytype == NULL)
d1380 1
a1380 5
	else if (sm_strcasecmp(BlankEnvelope.e_bodytype, "7BIT") == 0)
		SevenBitInput = true;
	else if (sm_strcasecmp(BlankEnvelope.e_bodytype, "8BITMIME") == 0)
		SevenBitInput = false;
	else
d1385 1
d1786 1
a1786 1
	/* Macros to save in the qf file -- don't remove any */
d2504 1
d2637 1
a2637 1
/*
d2658 1
a2658 1
/*
d2763 1
a2763 1
/*
d2805 1
a2805 1
/*
d2835 1
a2835 1
/*
d2865 1
a2865 1
/*
d2895 1
a2895 1
/*
d2965 1
a2965 1
/*
d3142 1
a3142 1
/*
d3198 1
a3198 1
/*
d3223 1
a3223 1
/*
d3253 1
d3275 1
a3275 1
/*
d3325 1
a3325 1
/*
d3362 2
a3363 1
/*
d3420 2
a3421 3
	/* reset primary group and user id */
	if ((to_real_uid || RunAsGid != 0) && EffGid != RunAsGid &&
	    setgid(RunAsGid) < 0)
d3423 51
a3473 2
		syserr("drop_privileges: setgid(%d) failed", (int) RunAsGid);
		rval = EX_OSERR;
d3536 14
d3562 1
a3562 1
/*
d3607 1
a3607 1
/*
d3642 1
a3642 1
/*
@


1.7
log
@update to sendmail 8.11.5
@
text
@d14 5
d20 1
a20 1
static char copyright[] =
d28 1
a28 7
#ifndef lint
static char id[] = "@@(#)$Sendmail: main.c,v 8.485.4.65 2001/07/20 00:53:00 gshapiro Exp $";
#endif /* ! lint */

#define	_DEFINE

#include <sendmail.h>
d35 12
d48 3
a50 1
static SIGFUNC_DECL	quiesce __P((int));
d53 1
a53 5
# endif /* SIGUSR1 */
static SIGFUNC_DECL	term_daemon __P((int));
static void	dump_class __P((STAB *, int));
static void	obsolete __P((char **));
static void	testmodeline __P((char *, ENVELOPE *));
d71 1
a71 1
**	Author:
d83 7
a91 2

int		NextMailer;	/* "free" index into Mailer struct */
d98 1
a98 1
bool		Warn_Q_option = FALSE;	/* warn about Q option use */
d100 1
d106 1
a106 8
#if DAEMON && !SMTP
ERROR %%%%   Cannot have DAEMON mode without SMTP   %%%% ERROR
#endif /* DAEMON && !SMTP */
#if SMTP && !QUEUE
ERROR %%%%   Cannot have SMTP mode without QUEUE   %%%% ERROR
#endif /* SMTP && !QUEUE */

#define MAXCONFIGLEVEL	9	/* highest config version level known */
d115 1
d117 7
a123 1
#endif /* SASL */
a124 1
int SubmitMode;
d140 1
a140 1
	bool safecf = TRUE;
d142 2
a143 2
	bool warn_C_flag = FALSE;
	bool auth = TRUE;		/* whether to set e_auth_param */
d145 1
a145 2
	bool run_in_foreground = FALSE;	/* -bD mode */
	static bool reenter = FALSE;
d151 7
a157 1
	bool forged;
d159 1
d163 1
a163 1
# if STARTTLS
d165 1
a165 1
# endif /* STARTTLS */
d167 1
d173 9
d189 1
a189 1
	if (reenter)
d194 1
a194 1
	reenter = TRUE;
d209 4
d232 2
a233 1
		if (i != STDIN_FILENO && i != STDOUT_FILENO && i != STDERR_FILENO)
d239 3
d243 1
a243 1
	openlog("sendmail", LOG_PID, LOG_MAIL);
d245 1
a245 1
	openlog("sendmail", LOG_PID);
d249 1
d256 1
a256 1
			(void) strlcat(mbuf, ", stdin", sizeof mbuf);
d258 1
a258 1
			(void) strlcat(mbuf, ", stdout", sizeof mbuf);
d260 1
a260 1
			(void) strlcat(mbuf, ", stderr", sizeof mbuf);
d273 1
a273 1
	tTsetup(tTdvect, sizeof tTdvect, "0-99.1");
d278 1
a278 1
	if (i == 0)
d285 1
a285 1
	dp = drop_privileges(FALSE);
d288 1
a288 1
# ifdef SIGUSR1
d294 1
a294 1
		(void) setsignal(SIGUSR1, sigusr1);
d296 1
a296 1
# endif /* SIGUSR1 */
d310 1
a310 1
# define OPTIONS	"B:b:C:cd:e:F:f:Gh:IiL:M:mN:nO:o:p:q:R:r:sTtUV:vX:x"
d313 1
a313 1
# define OPTIONS	"B:b:C:cd:E:e:F:f:Gh:IiJ:L:M:mN:nO:o:p:q:R:r:sTtUV:vX:"
d316 1
a316 1
# define OPTIONS	"B:b:C:cd:e:F:f:Gh:IiL:M:mN:nO:o:p:q:R:r:sTtUV:vX:"
a323 7
			/* hack attack -- see if should use ANSI mode */
			if (strcmp(optarg, "ANSI") == 0)
			{
				TermEscape.te_rv_on = "\033[7m";
				TermEscape.te_rv_off = "\033[0m";
				break;
			}
d325 3
a327 1
			setbuf(stdout, (char *) NULL);
d331 1
a331 1
			SubmitMode |= SUBMIT_MTA;
d335 1
a335 1
			j = min(strlen(optarg), 24) + 1;
d337 3
a339 1
			(void) strlcpy(sysloglabel, optarg, j);
a341 3
		  case 'U':	/* initial (user) submission */
			SubmitMode |= SUBMIT_MSA;
			break;
d378 2
d386 1
a386 1
		(void) snprintf(rnamebuf, sizeof rnamebuf, "%s", pw->pw_name);
d388 2
a389 2
		(void) snprintf(rnamebuf, sizeof rnamebuf, "Unknown UID %d",
				(int) RealUid);
d395 3
a397 2
		dprintf("Version %s\n", Version);
		finis(FALSE, EX_OK);
d401 1
a401 1
	**  if running non-setuid binary as non-root, pretend
d408 2
a409 2
			dprintf("Non-setuid binary: RunAsUid = RealUid = %d\n",
				(int)RealUid);
d415 2
a416 1
	if (RealUid != 0 && getegid() == RealGid)
d421 5
a425 5
		dprintf("main: e/ruid = %d/%d e/rgid = %d/%d\n",
			(int)geteuid(), (int)getuid(),
			(int)getegid(), (int)getgid());
		dprintf("main: RunAsUser = %d:%d\n",
			(int)RunAsUid, (int)RunAsGid);
d432 7
d449 1
a449 1
		(void) strlcpy(p, *av++, j);
a457 1
		int ll;
d460 2
a461 18
		dprintf("Version %s\n Compiled with:", Version);
		av = CompileOptions;
		ll = 7;
		while (*av != NULL)
		{
			if (ll + strlen(*av) > 63)
			{
				dprintf("\n");
				ll = 0;
			}
			if (ll == 0)
				dprintf("\t\t");
			else
				dprintf(" ");
			dprintf("%s", *av);
			ll += strlen(*av++) + 1;
		}
		dprintf("\n");
a464 1
		int ll;
d467 2
a468 18
		dprintf("    OS Defines:");
		av = OsCompileOptions;
		ll = 7;
		while (*av != NULL)
		{
			if (ll + strlen(*av) > 63)
			{
				dprintf("\n");
				ll = 0;
			}
			if (ll == 0)
				dprintf("\t\t");
			else
				dprintf(" ");
			dprintf("%s", *av);
			ll += strlen(*av++) + 1;
		}
		dprintf("\n");
d470 1
a470 1
		dprintf("Kernel symbols:\t%s\n", _PATH_UNIX);
d472 23
a494 2
		dprintf(" Def Conf file:\t%s\n", getcfname());
		dprintf("  Def Pid file:\t%s\n", PidFile);
d497 2
a498 2
	InChannel = stdin;
	OutChannel = stdout;
d509 1
d517 1
a517 1
		(void) snprintf(tz, tzlen, "TZ=%s", p);
a522 1
	(void) setsignal(SIGPIPE, SIG_IGN);
d524 1
a525 1
	OpMode = MD_DELIVER;
a534 5

	/*
	**  hack to avoid crashes when debugging for the resolver is
	**  turned on and sfio is used
	*/
a535 1
# if !SFIO || SFIO_STDIO_COMPAT
a536 3
# else /* !SFIO || SFIO_STDIO_COMPAT */
		dprintf("RES_DEBUG not available due to SFIO\n");
# endif /* !SFIO || SFIO_STDIO_COMPAT */
d540 2
d556 1
a556 2
	initmacros(CurEnv);
	init_vendor_macros(CurEnv);
d559 1
a559 1
	define('v', Version, CurEnv);
d565 1
a565 1
		struct	utsname	utsname;
d568 3
a570 3
			dprintf("canonical name: %s\n", jbuf);
		define('w', newstr(jbuf), CurEnv);	/* must be new string */
		define('j', newstr(jbuf), CurEnv);
d578 2
a579 1
				define('m', newstr(&p[1]), CurEnv);
d585 1
a585 1
					dprintf("\ta.k.a.: %s\n", jbuf);
d597 2
a598 2
				dprintf("uname failed (%s)\n",
					errstring(errno));
d603 2
a604 3
			dprintf(" UUCP nodename: %s\n", p);
		p = newstr(p);
		define('k', p, CurEnv);
d613 1
a613 1
				dprintf("\ta.k.a.: %s\n", *av);
d617 1
a617 1
		for (i = 0; hp->h_addr_list[i] != NULL; i++)
d638 2
a639 2
				(void) snprintf(ipbuf,	 sizeof ipbuf,
						"[%.100s]", inet_ntoa(ia));
d651 2
a652 2
					(void) snprintf(ipbuf, sizeof ipbuf,
							"[%.100s]", addr);
d660 1
a660 1
				dprintf("\ta.k.a.: %s\n", ipbuf);
d664 1
a664 1
#if _FFR_FREEHOSTENT && NETINET6
d667 1
a667 1
#endif /* _FFR_FREEHOSTENT && NETINET6 */
d671 2
a672 1
	define('b', arpadate((char *) NULL), CurEnv);
d674 1
a674 1
	CurrentLA = sm_getla(CurEnv);
d689 1
a689 1
		OpMode = MD_INITALIAS;
d691 1
a691 1
		OpMode = MD_PRINT;
d693 1
a693 1
		OpMode = MD_DAEMON;
d695 1
a695 1
		OpMode = MD_HOSTSTAT;
d697 1
a697 1
		OpMode = MD_PURGESTAT;
a708 5
#if !DAEMON
				usrerr("Daemon mode not implemented");
				ExitStat = EX_USAGE;
				break;
#endif /* !DAEMON */
a709 6
#if !SMTP
				usrerr("I don't speak SMTP");
				ExitStat = EX_USAGE;
				break;
#endif /* !SMTP */

d715 1
d719 1
a719 1
				OpMode = j;
d734 5
d740 1
a740 1
			CurEnv->e_bodytype = newstr(optarg);
d745 3
a747 3
				warn_C_flag = TRUE;
			ConfFile = newstr(optarg);
			dp = drop_privileges(TRUE);
d749 1
a749 1
			safecf = FALSE;
d763 1
a763 1
			from = newstr(denlstring(optarg, TRUE, TRUE));
d777 6
a782 1
			CurEnv->e_hopcount = (short) strtol(optarg, &ep, 10);
d795 1
a795 1
			NoAlias = TRUE;
d800 3
a802 3
			define(macid("{dsn_notify}", NULL),
			       newstr(optarg), CurEnv);
			if (strcasecmp(optarg, "never") == 0)
d809 1
a809 1
				if (strcasecmp(optarg, "success") == 0)
d811 1
a811 1
				else if (strcasecmp(optarg, "failure") == 0)
d813 1
a813 1
				else if (strcasecmp(optarg, "delay") == 0)
d824 2
a825 1
			setoption(*optarg, optarg + 1, FALSE, TRUE, CurEnv);
d829 1
a829 1
			setoption(' ', optarg, FALSE, TRUE, CurEnv);
d839 1
a839 1
					ep = xalloc(strlen(p) + 1);
d841 2
a842 1
					define('s', ep, CurEnv);
d847 1
a847 1
				ep = xalloc(strlen(optarg) + 1);
d849 2
a850 1
				define('r', ep, CurEnv);
a854 1
#if QUEUE
d860 1
d870 1
a870 1
				OpMode = MD_QUEUERUN;
d874 7
d883 11
a893 1
			  case 'I':
d896 1
d901 1
a901 1
			  case 'R':
d904 1
d909 1
a909 1
			  case 'S':
d912 1
d917 12
a937 4
#else /* QUEUE */
			usrerr("I don't know about queues");
			ExitStat = EX_USAGE;
#endif /* QUEUE */
d941 1
a941 1
			if (bitset(EF_RET_PARAM, CurEnv->e_flags))
d947 4
a950 4
			CurEnv->e_flags |= EF_RET_PARAM;
			if (strcasecmp(optarg, "hdrs") == 0)
				CurEnv->e_flags |= EF_NO_BODY_RETN;
			else if (strcasecmp(optarg, "full") != 0)
d955 2
a956 2
			define(macid("{dsn_ret}", NULL),
			       newstr(optarg), CurEnv);
d960 1
a960 5
			GrabTo = TRUE;
			break;

		  case 'U':	/* initial (user) submission */
			/* already set */
d971 3
a973 3
				CurEnv->e_envid = newstr(optarg);
				define(macid("{dsn_envid}", NULL),
				       newstr(optarg), CurEnv);
d978 1
a978 1
			dp = drop_privileges(TRUE);
d982 4
a985 1
				TrafficLogFile = fopen(optarg, "w");
d987 4
a990 1
				TrafficLogFile = fopen(optarg, "a");
d997 2
a998 5
#if HASSETVBUF
			(void) setvbuf(TrafficLogFile, NULL, _IOLBF, 0);
#else /* HASSETVBUF */
			(void) setlinebuf(TrafficLogFile);
#endif /* HASSETVBUF */
d1007 1
a1007 1
			setoption(j, "T", FALSE, TRUE, CurEnv);
d1012 1
a1012 1
			setoption(j, optarg, FALSE, TRUE, CurEnv);
d1016 1
a1016 1
			setoption('f', "T", FALSE, TRUE, CurEnv);
d1021 1
a1021 1
			OpMode = MD_INITALIAS;
d1037 2
a1038 1
			finis(TRUE, EX_USAGE);
d1044 1
a1044 2
	if (bitset(SUBMIT_MTA, SubmitMode) &&
	    bitset(SUBMIT_MSA, SubmitMode))
d1046 2
a1047 16
		/* sanity check */
		errno = 0;	/* reset to avoid bogus error messages */
		syserr("Cannot use both -G and -U together");
	}
	else if (bitset(SUBMIT_MTA, SubmitMode))
		define(macid("{daemon_flags}", NULL), "CC f", CurEnv);
	else if (bitset(SUBMIT_MSA, SubmitMode))
	{
		define(macid("{daemon_flags}", NULL), "c u", CurEnv);

		/* check for wrong OpMode */
		if (OpMode != MD_DELIVER && OpMode != MD_SMTP)
		{
			errno = 0;	/* reset to avoid bogus error msgs */
			syserr("Cannot use -U and -b%c", OpMode);
		}
d1049 1
a1049 1
	else
d1051 3
a1053 5
#if _FFR_DEFAULT_SUBMIT_TO_MSA
		define(macid("{daemon_flags}", NULL), "c u", CurEnv);
#else /* _FFR_DEFAULT_SUBMIT_TO_MSA */
		/* EMPTY */
#endif /* _FFR_DEFAULT_SUBMIT_TO_MSA */
a1061 9
	/* set up ${opMode} for use in config file */
	{
		char mbuf[2];

		mbuf[0] = OpMode;
		mbuf[1] = '\0';
		define(MID_OPMODE, newstr(mbuf), CurEnv);
	}

d1065 1
a1065 1
	vendor_pre_defaults(CurEnv);
d1067 6
a1072 3
	readcf(getcfname(), safecf, CurEnv);
	ConfigFileRead = TRUE;
	vendor_post_defaults(CurEnv);
d1075 1
a1075 2
	if (RealUid != 0 &&
	    RealUid != geteuid())
d1090 1
a1090 1
			dprintf("Changing real uid to %d\n", (int) new_uid);
d1095 1
a1095 1
			finis(FALSE, EX_OSERR);
d1099 2
a1100 2
			dprintf("Now running as e/ruid %d:%d\n",
				(int) geteuid(), (int) getuid());
d1108 1
a1108 1
			dprintf("Changing uid to %d\n", (int) new_uid);
d1112 1
a1112 1
			finis(FALSE, EX_OSERR);
d1116 2
a1117 2
			dprintf("Now running as e/ruid %d:%d\n",
				(int) geteuid(), (int) getuid());
d1121 21
d1143 3
a1145 3
	if (setsignal(SIGINT, SIG_IGN) != SIG_IGN)
		(void) setsignal(SIGINT, intsig);
	(void) setsignal(SIGTERM, intsig);
d1156 9
d1168 11
a1178 1
	if (OpMode != MD_DAEMON && OpMode != MD_FGDAEMON)
d1181 1
a1181 1
		dp = drop_privileges(FALSE);
d1183 6
d1201 1
a1201 1
	define('_', authinfo, CurEnv);
d1204 2
a1205 2
	if (CurEnv->e_errormode != EM_PRINT)
		HoldErrs = TRUE;
d1208 1
a1208 1
	expand("\201m", jbuf, sizeof jbuf, CurEnv);
d1213 1
a1213 1
	if (!DontProbeInterfaces)
d1218 10
a1227 10
		dprintf("\n============ SYSTEM IDENTITY (after readcf) ============");
		dprintf("\n      (short domain name) $w = ");
		xputs(macvalue('w', CurEnv));
		dprintf("\n  (canonical domain name) $j = ");
		xputs(macvalue('j', CurEnv));
		dprintf("\n         (subdomain name) $m = ");
		xputs(macvalue('m', CurEnv));
		dprintf("\n              (node name) $k = ");
		xputs(macvalue('k', CurEnv));
		dprintf("\n========================================================\n\n");
d1237 2
a1238 2
		auth_warning(CurEnv, "Processed by %s with -C %s",
			RealUserName, ConfFile);
d1240 6
a1245 1
		auth_warning(CurEnv, "Processed from queue %s", QueueDir);
d1248 1
a1248 1
	if (CurEnv->e_bodytype == NULL)
d1251 4
a1254 4
	else if (strcasecmp(CurEnv->e_bodytype, "7BIT") == 0)
		SevenBitInput = TRUE;
	else if (strcasecmp(CurEnv->e_bodytype, "8BITMIME") == 0)
		SevenBitInput = FALSE;
d1257 2
a1258 2
		usrerr("Illegal body type %s", CurEnv->e_bodytype);
		CurEnv->e_bodytype = NULL;
d1273 1
a1273 1
			ConfigLevel, Version, MAXCONFIGLEVEL);
d1280 2
a1281 1
		printf("Warning: HostStatusDirectory disabled with ConnectionCacheSize = 0\n");
d1287 3
a1289 2
		SingleThreadDelivery = FALSE;
		printf("Warning: HostStatusDirectory required for SingleThreadDelivery\n");
d1293 1
a1293 4
	if ((OpMode == MD_DAEMON ||
	     OpMode == MD_FGDAEMON ||
	     OpMode == MD_PURGESTAT) &&
	    RealUid != 0 &&
d1296 119
a1414 20
		if (LogLevel > 1)
			sm_syslog(LOG_ALERT, NOQID,
				  "user %d attempted to %s",
				  RealUid,
				  OpMode != MD_PURGESTAT ? "run daemon"
							 : "purge host status");
		usrerr("Permission denied");
		finis(FALSE, EX_USAGE);
	}
	if (OpMode == MD_INITALIAS &&
	    RealUid != 0 &&
	    RealUid != TrustedUid &&
	    !wordinclass(RealUserName, 't'))
	{
		if (LogLevel > 1)
			sm_syslog(LOG_ALERT, NOQID,
				  "user %d attempted to rebuild the alias map",
				  RealUid);
		usrerr("Permission denied");
		finis(FALSE, EX_USAGE);
d1427 2
a1428 2
		CurEnv->e_errormode = EM_PRINT;
		HoldErrs = FALSE;
d1432 2
a1433 3
		CurEnv->e_errormode = EM_PRINT;
		HoldErrs = FALSE;

d1435 5
a1439 2
		if (setsignal(SIGHUP, SIG_IGN) == (sigfunc_t) SIG_DFL)
			(void) setsignal(SIGHUP, intsig);
d1443 2
a1444 2
		run_in_foreground = TRUE;
		OpMode = MD_DAEMON;
d1448 1
a1448 1
		vendor_daemon_setup(CurEnv);
d1452 1
a1452 1
		GrabTo = FALSE;
a1457 1
		(void) setsignal(SIGTERM, term_daemon);
d1462 2
a1463 2
		CurEnv->e_errormode = EM_PRINT;
		HoldErrs = FALSE;
d1468 2
a1469 2
		if (setsignal(SIGHUP, SIG_IGN) == (sigfunc_t) SIG_DFL)
			(void) setsignal(SIGHUP, intsig);
d1481 1
a1481 1
			full = newstr(denlstring(FullName, TRUE, TRUE));
d1494 1
a1494 1
			FullName = addquotes(FullName);
d1496 1
a1496 1
				sm_free(full);
d1504 1
a1504 1
		setoption('c', "F", TRUE, FALSE, CurEnv);
d1507 1
a1507 1
		setoption('d', "", TRUE, FALSE, CurEnv);
d1527 1
a1527 1
		UseErrorsTo = TRUE;
d1532 2
a1533 1
		if (ConfigLevel < 7 && (p = macvalue('e', CurEnv)) != NULL)
d1540 2
a1541 1
		if (ConfigLevel < 7 && (p = macvalue('l', CurEnv)) != NULL)
d1549 1
a1549 1
	expand("\201j", jbuf, sizeof jbuf, CurEnv);
d1551 1
a1551 1
		MyHostName = newstr("localhost");
d1553 1
a1553 1
		MyHostName = jbuf;
d1561 7
d1647 2
a1648 2
	setclass(macid("{checkMIMEFieldHeaders}", NULL), "content-disposition");
	setclass(macid("{checkMIMEFieldHeaders}", NULL), "content-type");
d1651 1
a1651 1
	setclass(macid("{checkMIMETextHeaders}", NULL), "content-description");
d1654 5
a1658 5
	setclass(macid("{checkMIMEHeaders}", NULL), "content-disposition");
	setclass(macid("{checkMIMEHeaders}", NULL), "content-id");
	setclass(macid("{checkMIMEHeaders}", NULL), "content-transfer-encoding");
	setclass(macid("{checkMIMEHeaders}", NULL), "content-type");
	setclass(macid("{checkMIMEHeaders}", NULL), "mime-version");
d1661 5
a1665 6
	setclass(macid("{persistentMacros}", NULL), "r");
	setclass(macid("{persistentMacros}", NULL), "s");
	setclass(macid("{persistentMacros}", NULL), "_");
	setclass(macid("{persistentMacros}", NULL), "{if_addr}");
	setclass(macid("{persistentMacros}", NULL), "{daemon_flags}");
	setclass(macid("{persistentMacros}", NULL), "{client_flags}");
d1668 1
a1668 1
	if (QueueDir == NULL)
a1677 6
		/*
		**  If multiple queues wildcarded, use one for
		**  the daemon's home. Note that this preconditions
		**  a wildcarded QueueDir to a real pathname.
		*/

d1679 1
a1679 1
			multiqueue_cache();
d1683 1
a1683 1
	if (HostStatDir != NULL && !path_is_dir(HostStatDir, FALSE))
d1687 2
a1688 2
			dprintf("Cannot use HostStatusDirectory = %s: %s\n",
				HostStatDir, errstring(errno));
d1692 2
a1693 3
#if QUEUE
	if (OpMode == MD_QUEUERUN && RealUid != 0 &&
	    bitset(PRIV_RESTRICTQRUN, PrivacyFlags))
d1704 2
a1705 1
			finis(FALSE, EX_NOPERM);
a1707 1
#endif /* QUEUE */
d1709 1
a1709 1
#if _FFR_MILTER
d1712 7
a1718 3
		milter_parse_list(InputFilterList, InputFilters, MAXFILTERS);
#endif /* _FFR_MILTER */

d1722 9
a1730 1
		finis(FALSE, ExitStat);
d1744 2
a1745 3
#if QUEUE
		dropenvelope(CurEnv, TRUE);
		(void) setsignal(SIGPIPE, quiesce);
d1747 11
a1757 5
		finis(FALSE, EX_OK);
#else /* QUEUE */
		usrerr("No queue to print");
		finis(FALSE, EX_UNAVAILABLE);
#endif /* QUEUE */
d1761 1
a1761 1
		(void) setsignal(SIGPIPE, quiesce);
d1763 2
a1764 1
		finis(FALSE, EX_OK);
d1769 2
a1770 1
		finis(FALSE, EX_OK);
d1776 2
a1777 1
		finis(FALSE, ExitStat);
d1784 8
a1791 5
		define(macid("{dsn_notify}", NULL), NULL, CurEnv);
		CurEnv->e_envid = NULL;
		define(macid("{dsn_envid}", NULL), NULL, CurEnv);
		CurEnv->e_flags &= ~(EF_RET_PARAM|EF_NO_BODY_RETN);
		define(macid("{dsn_ret}", NULL), NULL, CurEnv);
d1813 2
a1814 1
	CurEnv = newenvelope(&MainEnvelope, CurEnv);
d1823 1
a1823 12
		char buf[MAXLINE];

#if _FFR_TESTMODE_DROP_PRIVS
		dp = drop_privileges(TRUE);
		if (dp != EX_OK)
		{
			CurEnv->e_id = NULL;
			finis(TRUE, dp);
		}
#endif /* _FFR_TESTMODE_DROP_PRIVS */

		if (isatty(fileno(stdin)))
d1828 4
a1831 2
			printf("ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)\n");
			printf("Enter <ruleset> <address>\n");
a1832 3
		if (setjmp(TopFrame) > 0)
			printf("\n");
		(void) setsignal(SIGINT, intindebug);
d1835 34
a1868 11
			if (Verbose == 2)
				printf("> ");
			(void) fflush(stdout);
			if (fgets(buf, sizeof buf, stdin) == NULL)
				testmodeline("/quit", CurEnv);
			p = strchr(buf, '\n');
			if (p != NULL)
				*p = '\0';
			if (Verbose < 2)
				printf("> %s\n", buf);
			testmodeline(buf, CurEnv);
d1872 30
a1901 5
#if SMTP
# if STARTTLS
	tls_ok = init_tls_library();
# endif /* STARTTLS */
#endif /* SMTP */
a1902 1
#if QUEUE
d1909 88
a1996 12
# if SMTP
#  if STARTTLS
		if (tls_ok
		   )
		{
			/* init TLS for client, ignore result for now */
			(void) initclttls();
		}
#  endif /* STARTTLS */
# endif /* SMTP */
		(void) runqueue(FALSE, Verbose);
		finis(TRUE, ExitStat);
a1997 1
#endif /* QUEUE */
d2002 3
a2004 2
		/* give a syserr or just disable AUTH ? */
		if ((i = sasl_server_init(srvcallbacks, "Sendmail")) != SASL_OK)
d2006 1
a2006 1
			       sasl_errstring(i, NULL, NULL));
d2030 18
a2047 1
				finis(FALSE, EX_OK);
d2050 1
a2050 1
			disconnect(2, CurEnv);
d2055 4
a2058 1
			(void) strlcat(dtype, "+SMTP", sizeof dtype);
d2061 6
a2066 3
			(void) strlcat(dtype, "+queueing@@", sizeof dtype);
			(void) strlcat(dtype, pintvl(QueueIntvl, TRUE),
				       sizeof dtype);
d2069 1
a2069 1
			(void) strlcat(dtype, "+debugging", sizeof dtype);
d2073 1
a2073 1
#ifdef XLA
d2078 2
a2079 2
		define(macid("{daemon_info}", NULL),
		       newstr(dtype + 1), &BlankEnvelope);
d2082 7
a2088 2
		define(macid("{queue_interval}", NULL),
		       newstr(pintvl(QueueIntvl, TRUE)), CurEnv);
a2089 1
#if QUEUE
d2092 76
a2167 1
			(void) runqueue(TRUE, FALSE);
d2170 17
a2186 3
				/* write the pid to file */
				log_sendmail_pid(CurEnv);
				(void) setsignal(SIGTERM, term_daemon);
d2192 8
a2199 2
					else if (DoQueueRun)
						(void) runqueue(TRUE, FALSE);
d2203 1
a2203 2
#endif /* QUEUE */
		dropenvelope(CurEnv, TRUE);
d2205 1
a2205 2
#if DAEMON
# if STARTTLS
d2207 6
a2212 3
		(void) initsrvtls();
# endif /* STARTTLS */
		p_flags = getrequests(CurEnv);
d2215 1
a2215 4
		(void) drop_privileges(FALSE);

		/* at this point we are in a child: reset state */
		(void) newenvelope(CurEnv, CurEnv);
d2219 1
d2222 8
a2229 3
		authinfo = getauthinfo(fileno(InChannel), &forged);
		define('_', authinfo, &BlankEnvelope);
#endif /* DAEMON */
a2237 1
#if SMTP
d2255 4
a2258 6
			(void) snprintf(ipbuf, sizeof ipbuf, "[%.100s]",
					anynet_ntoa(&RealHostAddr));
			define(macid("{client_name}", NULL),
			       newstr(ipbuf), &BlankEnvelope);
			define(macid("{client_resolve}", NULL),
			       "FORGED", &BlankEnvelope);
d2261 5
a2265 5
			define(macid("{client_name}", NULL), RealHostName,
			       &BlankEnvelope);
		define(macid("{client_addr}", NULL),
		       newstr(anynet_ntoa(&RealHostAddr)), &BlankEnvelope);
		(void)sm_getla(&BlankEnvelope);
d2267 1
a2267 1
		switch(RealHostAddr.sa.sa_family)
d2269 1
a2269 1
# if NETINET
d2271 2
a2272 2
			(void) snprintf(pbuf, sizeof pbuf, "%d",
					RealHostAddr.sin.sin_port);
d2274 2
a2275 2
# endif /* NETINET */
# if NETINET6
d2277 2
a2278 2
			(void) snprintf(pbuf, sizeof pbuf, "%d",
					RealHostAddr.sin6.sin6_port);
d2280 1
a2280 1
# endif /* NETINET6 */
d2282 1
a2282 1
			(void) snprintf(pbuf, sizeof pbuf, "0");
d2285 2
a2286 2
		define(macid("{client_port}", NULL),
		       newstr(pbuf), &BlankEnvelope);
d2291 1
a2291 1
			HoldErrs = TRUE;
d2293 3
a2295 2
							 RealHostName, CurEnv);
			HoldErrs = FALSE;
d2302 1
a2302 1
# if STARTTLS
d2304 2
a2305 2
			(void) initsrvtls();
# endif /* STARTTLS */
d2307 9
a2315 2

		smtp(nullserver, *p_flags, CurEnv);
a2316 1
#endif /* SMTP */
d2318 2
a2319 1
	clearenvelope(CurEnv, FALSE);
d2322 1
a2322 1
		set_delivery_mode(SM_VERIFY, CurEnv);
d2328 1
a2328 1
		CurEnv->e_flags |= EF_GLOBALERRS|EF_LOGSENDER;
d2335 4
a2338 3
	initsys(CurEnv);
	define(macid("{ntries}", NULL), "0", CurEnv);
	setsender(from, CurEnv, NULL, '\0', FALSE);
d2340 2
a2341 2
	    (!bitnset(M_LOCALMAILER, CurEnv->e_from.q_mailer->m_flags) ||
	     strcmp(CurEnv->e_from.q_user, RealUserName) != 0))
d2343 2
a2344 2
		auth_warning(CurEnv, "%s set sender to %s using -%c",
			RealUserName, from, warn_f_flag);
d2346 1
a2346 1
		auth = FALSE;
d2354 1
a2354 1
		fv = macvalue('f', CurEnv);
d2356 1
a2356 1
			CurEnv->e_auth_param = NULL;
d2361 6
a2366 5
				i = strlen(fv) + strlen(macvalue('j', CurEnv))
				    + 2;
				p = xalloc(i);
				(void) snprintf(p, i, "%s@@%s", fv,
						macvalue('j', CurEnv));
d2369 4
a2372 2
				p = newstr(fv);
			CurEnv->e_auth_param = newstr(xtextify(p, "="));
d2375 2
a2376 2
	if (macvalue('s', CurEnv) == NULL)
		define('s', RealHostName, CurEnv);
d2380 4
a2383 4
		CurEnv->e_to = NULL;
		CurEnv->e_flags |= EF_GLOBALERRS;
		HoldErrs = FALSE;
		SuperSafe = FALSE;
d2388 3
a2390 2
			collect(InChannel, FALSE, NULL, CurEnv);
		finis(TRUE, EX_USAGE);
d2397 1
a2397 1
	sendtoargv(av, CurEnv);
d2413 1
a2413 1
		for (q = CurEnv->e_sendqueue; q != NULL; q = q->q_next)
d2422 1
a2422 1
	CurEnv->e_to = NULL;
d2426 1
a2426 1
		long savedflags = CurEnv->e_flags & EF_FATALERRS;
d2428 2
a2429 2
		CurEnv->e_flags |= EF_GLOBALERRS;
		CurEnv->e_flags &= ~EF_FATALERRS;
d2432 1
a2432 1
		collect(InChannel, FALSE, NULL, CurEnv);
d2437 6
a2442 19
			/* Log who the mail would have gone to */
			if (LogLevel > 8 && CurEnv->e_message != NULL &&
			    !GrabTo)
			{
				ADDRESS *a;

				for (a = CurEnv->e_sendqueue;
				     a != NULL;
				     a = a->q_next)
				{
					if (!QS_IS_UNDELIVERED(a->q_state))
						continue;

					CurEnv->e_to = a->q_paddr;
					logdelivery(NULL, NULL, NULL,
						    CurEnv->e_message,
						    NULL, (time_t) 0, CurEnv);
				}
				CurEnv->e_to = NULL;
d2444 2
a2445 2
			flush_errors(TRUE);
			finis(TRUE, ExitStat);
d2451 1
a2451 1
		if (bitset(EF_CLRQUEUE, CurEnv->e_flags))
d2453 1
a2453 1
			finis(TRUE, ExitStat != EX_OK ? ExitStat : EX_DATAERR);
d2458 1
a2458 1
		CurEnv->e_flags |= savedflags;
d2463 2
a2464 1
		dprintf("From person = \"%s\"\n", CurEnv->e_from.q_paddr);
d2471 6
a2476 2
	CurEnv->e_from.q_state = QS_SENDER;
	if (tTd(1, 5))
d2478 11
a2488 6
		dprintf("main: QS_SENDER ");
		printaddr(&CurEnv->e_from, FALSE);
	}
	CurEnv->e_to = NULL;
	CurrentLA = sm_getla(CurEnv);
	GrabTo = FALSE;
d2490 2
a2491 2
	_res.retry = TimeOuts.res_retry[RES_TO_FIRST];
	_res.retrans = TimeOuts.res_retrans[RES_TO_FIRST];
d2493 7
a2499 1
	sendall(CurEnv, SM_DEFAULT);
d2506 1
a2506 1
	finis(TRUE, ExitStat);
d2511 1
a2511 1
**  QUIESCE -- signal handler for SIGPIPE
d2514 1
a2514 1
**		sig -- incoming signal.
d2520 1
a2520 6
**		Sets StopRequest which should cause the mailq/hoststatus
**		display to stop.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
d2523 2
a2524 4
/* ARGSUSED */
static SIGFUNC_DECL
quiesce(sig)
	int sig;
d2526 4
a2529 6
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, quiesce);
	StopRequest = TRUE;
	errno = save_errno;
	return SIGFUNC_RETURN;
d2532 1
a2532 1
**  STOP_SENDMAIL -- Stop the running program
d2535 2
a2536 1
**		none.
d2539 1
a2539 1
**		none.
d2542 1
a2542 1
**		exits.
d2546 3
a2548 1
stop_sendmail()
d2550 85
a2634 4
	/* reset uid for process accounting */
	endpwent();
	(void) setuid(RealUid);
	exit(EX_OK);
a2635 1

a2650 2
**
**	XXX: More work is needed for this signal handler.
d2653 10
a2672 1

d2674 2
a2675 1
	longjmp(TopFrame, 1);
d2679 1
a2679 1
**  FINIS -- Clean up and exit.
d2682 1
a2682 2
**		drop -- whether or not to drop CurEnv envelope
**		exitstat -- exit status to use for exit() call
d2685 1
a2685 1
**		never
d2688 6
a2693 1
**		exits sendmail
d2696 4
a2699 4
void
finis(drop, exitstat)
	bool drop;
	volatile int exitstat;
d2701 1
a2701 3
	/* Still want to process new timeouts added below */
	clear_events();
	(void) releasesignal(SIGALRM);
d2703 4
a2706 58
	if (tTd(2, 1))
	{
		dprintf("\n====finis: stat %d e_id=%s e_flags=",
			exitstat,
			CurEnv->e_id == NULL ? "NOQUEUE" : CurEnv->e_id);
		printenvflags(CurEnv);
	}
	if (tTd(2, 9))
		printopenfds(FALSE);

	/* if we fail in finis(), just exit */
	if (setjmp(TopFrame) != 0)
	{
		/* failed -- just give it up */
		goto forceexit;
	}

	/* clean up temp files */
	CurEnv->e_to = NULL;
	if (drop)
	{
		if (CurEnv->e_id != NULL)
			dropenvelope(CurEnv, TRUE);
		else
			poststats(StatFile);
	}

	/* flush any cached connections */
	mci_flush(TRUE, NULL);

	/* close maps belonging to this pid */
	closemaps();

#if USERDB
	/* close UserDatabase */
	_udbx_close();
#endif /* USERDB */

#ifdef XLA
	/* clean up extended load average stuff */
	xla_all_end();
#endif /* XLA */

	/* and exit */
  forceexit:
	if (LogLevel > 78)
		sm_syslog(LOG_DEBUG, CurEnv->e_id,
			  "finis, pid=%d",
			  (int) getpid());
	if (exitstat == EX_TEMPFAIL || CurEnv->e_errormode == EM_BERKNET)
		exitstat = EX_OK;

	sync_queue_time();

	/* reset uid for process accounting */
	endpwent();
	(void) setuid(RealUid);
	exit(exitstat);
d2709 1
a2709 1
**  TERM_DEAMON -- SIGTERM handler for the daemon
d2712 1
a2712 1
**		sig -- signal number.
d2718 2
a2719 2
**		Sets ShutdownRequest which will hopefully trigger
**		the daemon to exit.
d2728 1
a2728 1
term_daemon(sig)
d2733 2
a2734 2
	FIX_SYSV_SIGNAL(sig, term_daemon);
	ShutdownRequest = "signal";
d2739 1
a2739 1
**  SHUTDOWN_DAEMON -- Performs a clean shutdown of the daemon
d2742 1
a2742 1
**		none.
d2748 6
a2753 1
**		closes control socket, exits.
d2756 4
a2759 2
void
shutdown_daemon()
d2761 1
a2761 1
	char *reason;
d2763 4
a2766 17
	allsignals(TRUE);

	reason = ShutdownRequest;
	ShutdownRequest = NULL;
	PendingSignal = 0;

	if (LogLevel > 79)
		sm_syslog(LOG_DEBUG, CurEnv->e_id, "interrupt (%s)",
			  reason == NULL ? "implicit call" : reason);

	FileName = NULL;
	closecontrolsocket(TRUE);
#ifdef XLA
	xla_all_end();
#endif /* XLA */

	finis(FALSE, EX_OK);
d2795 1
a2795 1
	bool drop = FALSE;
d2801 2
a2802 1
	allsignals(TRUE);
d2828 1
a2828 5
		/* and don't try to deliver the partial message either */
		if (InChild)
			ExitStat = EX_QUIT;

		drop = TRUE;
d2831 1
d2833 1
d2836 1
a2836 73
}
/*
**  INITMACROS -- initialize the macro system
**
**	This just involves defining some macros that are actually
**	used internally as metasymbols to be themselves.
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		initializes several macros to be themselves.
*/

struct metamac	MetaMacros[] =
{
	/* LHS pattern matching characters */
	{ '*', MATCHZANY },	{ '+', MATCHANY },	{ '-', MATCHONE },
	{ '=', MATCHCLASS },	{ '~', MATCHNCLASS },

	/* these are RHS metasymbols */
	{ '#', CANONNET },	{ '@@', CANONHOST },	{ ':', CANONUSER },
	{ '>', CALLSUBR },

	/* the conditional operations */
	{ '?', CONDIF },	{ '|', CONDELSE },	{ '.', CONDFI },

	/* the hostname lookup characters */
	{ '[', HOSTBEGIN },	{ ']', HOSTEND },
	{ '(', LOOKUPBEGIN },	{ ')', LOOKUPEND },

	/* miscellaneous control characters */
	{ '&', MACRODEXPAND },

	{ '\0', '\0' }
};

#define MACBINDING(name, mid) \
		stab(name, ST_MACRO, ST_ENTER)->s_macro = mid; \
		MacroName[mid] = name;

void
initmacros(e)
	register ENVELOPE *e;
{
	register struct metamac *m;
	register int c;
	char buf[5];
	extern char *MacroName[MAXMACROID + 1];

	for (m = MetaMacros; m->metaname != '\0'; m++)
	{
		buf[0] = m->metaval;
		buf[1] = '\0';
		define(m->metaname, newstr(buf), e);
	}
	buf[0] = MATCHREPL;
	buf[2] = '\0';
	for (c = '0'; c <= '9'; c++)
	{
		buf[1] = c;
		define(c, newstr(buf), e);
	}

	/* set defaults for some macros sendmail will use later */
	define('n', "MAILER-DAEMON", e);

	/* set up external names for some internal macros */
	MACBINDING("opMode", MID_OPMODE);
	/*XXX should probably add equivalents for all short macros here XXX*/
d2866 3
a2868 2
		dprintf("disconnect: In %d Out %d, e=%lx\n",
			fileno(InChannel), fileno(OutChannel), (u_long) e);
d2871 1
a2871 1
		dprintf("don't\n");
d2880 2
a2881 2
	(void) setsignal(SIGINT, SIG_IGN);
	(void) setsignal(SIGQUIT, SIG_IGN);
d2884 1
a2884 1
	HoldErrs = TRUE;
d2887 1
a2887 1
	DisConnected = TRUE;
d2890 1
a2890 1
	if (InChannel != stdin)
d2892 2
a2893 2
		(void) fclose(InChannel);
		InChannel = stdin;
d2895 2
a2896 1
	if (freopen("/dev/null", "r", stdin) == NULL)
d2898 9
a2906 2
			  "disconnect: freopen(\"/dev/null\") failed: %s",
			  errstring(errno));
d2908 3
a2910 2
	/* output to the transcript */
	if (OutChannel != stdout)
d2912 17
a2928 2
		(void) fclose(OutChannel);
		OutChannel = stdout;
d2932 1
a2932 1
		fd = open("/dev/null", O_WRONLY, 0666);
d2935 3
a2937 3
				  "disconnect: open(\"/dev/null\") failed: %s",
				  errstring(errno));
		(void) fflush(stdout);
d2955 2
a2956 3
		sm_syslog(LOG_DEBUG, e->e_id,
			  "in background, pid=%d",
			  (int) getpid());
d2988 1
a2988 1
#define	__DEFPATH	"sendmail.cf"
d2992 2
a2993 2
			(void) snprintf(argv[0], sizeof(__DEFPATH) + 2, "-C%s",
					__DEFPATH);
d3038 1
a3038 1
	VA_LOCAL_DECL
d3050 1
a3050 1
#if _FFR_FREEHOSTENT && NETINET6
d3056 1
a3056 1
#endif /* _FFR_FREEHOSTENT && NETINET6 */
d3059 1
a3059 1
		(void) snprintf(buf, sizeof buf, "%s: ", hostbuf);
d3061 4
a3064 4
		VA_START(msg);
		vsnprintf(p, SPACELEFT(buf, p), msg, ap);
		VA_END;
		addheader("X-Authentication-Warning", buf, 0, &e->e_header);
d3081 1
a3081 1
char *
d3097 1
a3097 1
**  SETUSERENV -- set an environment in the propogated environment
d3129 1
a3129 1
	(void) snprintf(p, l, "%s=%s", envar, value);
d3172 1
a3172 1
	sm_syslog(LOG_DEBUG, CurEnv->e_id, "NextMacroId = %d (Max %d)\n",
d3175 1
a3175 1
	printopenfds(TRUE);
d3177 1
a3177 1
	mci_dump_all(TRUE);
d3186 1
a3186 1
		status = rewrite(pv, rs, 0, CurEnv);
d3195 1
d3219 3
d3227 3
d3233 1
a3233 1
# endif /* SIGUSR1 */
d3254 6
a3259 3
		dprintf("drop_privileges(%d): Real[UG]id=%d:%d, RunAs[UG]id=%d:%d\n",
			(int)to_real_uid, (int)RealUid,
			(int)RealGid, (int)RunAsUid, (int)RunAsGid);
d3270 1
d3274 10
d3287 1
a3287 1
		       (int)emptygidset[0]);
d3292 2
a3293 1
	if ((to_real_uid || RunAsGid != 0) && setgid(RunAsGid) < 0)
d3295 1
a3295 1
		syserr("drop_privileges: setgid(%d) failed", (int)RunAsGid);
d3302 2
a3303 1
		if (setuid(RunAsUid) < 0)
d3305 29
a3333 3
			syserr("drop_privileges: setuid(%d) failed",
			       (int)RunAsUid);
			rval = EX_OSERR;
d3335 1
a3335 1
		else if (RunAsUid != 0 && setuid(0) == 0)
d3355 1
a3355 1
			syserr("drop_privileges: Unable to drop non-root set-user-id privileges");
d3361 5
a3365 5
		dprintf("drop_privileges: e/ruid = %d/%d e/rgid = %d/%d\n",
			(int)geteuid(), (int)getuid(),
			(int)getegid(), (int)getgid());
		dprintf("drop_privileges: RunAsUser = %d:%d\n",
			(int)RunAsUid, (int)RunAsGid);
d3367 1
a3367 1
			dprintf("drop_privileges: rval = %d\n", rval);
d3384 3
d3404 1
a3404 1
	i = open("/dev/null", fd == 0 ? O_RDONLY : O_WRONLY, 0666);
d3407 2
a3408 2
		syserr("!fill_fd: %s: cannot open /dev/null",
			where == NULL ? "startup" : where);
d3417 35
d3482 1
a3482 1
	extern u_char TokTypeNoC[];
d3484 1
a3484 3
#if _FFR_ADDR_TYPE
	define(macid("{addr_type}", NULL), "e r", e);
#endif /* _FFR_ADDR_TYPE */
d3504 1
a3504 1
			mid = macid(&line[2], &delimptr);
d3508 1
a3508 1
			define(mid, newstr(delimptr), e);
d3515 1
a3515 1
			mid = macid(&line[2], &delimptr);
d3540 2
a3541 1
			printf("Usage: .[DC]macro value(s)\n");
d3545 2
a3546 1
			printf("Unknown \".\" command %s\n", line);
d3558 2
a3559 1
				printf("Undefined ruleset %s\n", &line[2]);
d3567 2
a3568 1
				(void) putchar('R');
d3573 2
a3574 1
					(void) putchar(' ');
d3576 4
a3579 2
				(void) putchar('\t');
				(void) putchar('\t');
d3584 2
a3585 1
					(void) putchar(' ');
d3587 2
a3588 1
				(void) putchar('\n');
d3601 2
a3602 1
			printf("Usage: =Sruleset or =M\n");
d3606 2
a3607 1
			printf("Unknown \"=\" command %s\n", line);
d3620 2
a3621 1
			printf("Usage: -d{debug arguments}\n");
d3625 2
a3626 1
			printf("Unknown \"-\" command %s\n", line);
d3634 1
a3634 1
			mid = macid(&line[2], NULL);
d3639 1
a3639 1
		mid = macid(&line[1], NULL);
d3644 2
a3645 1
			printf("Undefined\n");
d3649 2
a3650 1
			printf("\n");
d3668 2
a3669 1
			printf("Usage: /[canon|map|mx|parse|try|tryflags]\n");
d3672 1
a3672 1
		if (strcasecmp(&line[1], "quit") == 0)
d3675 2
a3676 1
			finis(TRUE, ExitStat);
d3678 1
a3678 1
		if (strcasecmp(&line[1], "mx") == 0)
d3688 2
a3689 1
				printf("Usage: /mx address\n");
d3692 5
a3696 2
			nmx = getmxrr(p, mxhosts, NULL, FALSE, &rcode);
			printf("getmxrr(%s) returns %d value(s):\n", p, nmx);
d3698 2
a3699 1
				printf("\t%s\n", mxhosts[i]);
d3701 2
a3702 1
			printf("No MX code compiled in\n");
d3705 1
a3705 1
		else if (strcasecmp(&line[1], "canon") == 0)
d3711 2
a3712 1
				printf("Usage: /canon address\n");
d3715 1
a3715 1
			else if (strlcpy(host, p, sizeof host) >= sizeof host)
d3717 2
a3718 1
				printf("Name too long\n");
d3721 5
a3725 2
			(void) getcanonname(host, sizeof host, HasWildcardMX);
			printf("getcanonname(%s) returns %s\n", p, host);
d3727 1
a3727 1
		else if (strcasecmp(&line[1], "map") == 0)
d3734 2
a3735 1
				printf("Usage: /map mapname key\n");
d3738 1
a3738 1
			for (q = p; *q != '\0' && !(isascii(*q) && isspace(*q)); q++)
d3742 2
a3743 1
				printf("No key specified\n");
d3750 2
a3751 1
				printf("Map named \"%s\" not found\n", p);
d3757 2
a3758 1
				printf("Map named \"%s\" not open\n", p);
d3761 2
a3762 1
			printf("map_lookup: %s (%s) ", p, q);
d3768 3
a3770 1
				printf("no match (%d)\n", rcode);
d3772 3
a3774 1
				printf("returns %s (%d)\n", p, rcode);
d3776 1
a3776 1
		else if (strcasecmp(&line[1], "try") == 0)
d3790 2
a3791 1
				printf("Usage: /try mailer address\n");
d3797 2
a3798 1
				printf("Unknown mailer %s\n", p);
d3802 6
a3807 4
			printf("Trying %s %s address %s for mailer %s\n",
				bitset(RF_HEADERADDR, tryflags) ? "header" : "envelope",
				bitset(RF_SENDERADDR, tryflags) ? "sender" : "recipient",
				q, p);
d3809 3
a3811 2
			printf("Rcode = %d, addr = %s\n",
				rcode, p == NULL ? "<NULL>" : p);
d3814 1
a3814 1
		else if (strcasecmp(&line[1], "tryflags") == 0)
d3818 2
a3819 1
				printf("Usage: /tryflags [Hh|Ee][Ss|Rr]\n");
a3846 1
#if _FFR_ADDR_TYPE
d3851 2
a3852 2
			define(macid("{addr_type}", NULL), newstr(exbuf), e);
#endif /* _FFR_ADDR_TYPE */
d3854 1
a3854 1
		else if (strcasecmp(&line[1], "parse") == 0)
d3858 2
a3859 1
				printf("Usage: /parse address\n");
d3863 2
a3864 1
			printf("Cracked address = ");
d3866 10
a3875 5
			printf("\nParsing %s %s address\n",
				bitset(RF_HEADERADDR, tryflags) ? "header" : "envelope",
				bitset(RF_SENDERADDR, tryflags) ? "sender" : "recipient");
			if (parseaddr(p, &a, tryflags, '\0', NULL, e) == NULL)
				printf("Cannot parse\n");
d3877 5
a3881 2
				printf("mailer %s, host %s, user %s\n",
					a.q_mailer->m_name, a.q_host, a.q_user);
d3883 4
a3886 2
				printf("mailer %s, user %s\n",
					a.q_mailer->m_name, a.q_user);
d3891 3
a3893 1
			printf("Unknown \"/\" command %s\n", line);
d3905 2
a3906 1
		printf("No address!\n");
d3910 1
a3910 1
	if (invalidaddr(p + 1, NULL))
d3929 3
a3931 1
				printf("Undefined ruleset %s\n", p);
d3934 1
a3934 1
			status = rewrite(pvp, rs, 0, e);
d3936 3
a3938 2
				printf("== Ruleset %s (%d) status %d\n",
					p, rs, status);
d3953 2
a3954 1
		printf("%s\n", s->s_name);
d3956 17
@


1.6
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d24 1
a24 1
static char id[] = "@@(#)$Sendmail: main.c,v 8.485.4.60 2001/05/27 22:00:26 gshapiro Exp $";
d38 1
d40 1
d2161 1
a2161 1
	releasesignal(SIGALRM);
d2277 2
a2278 1
		sm_syslog(LOG_DEBUG, CurEnv->e_id, "interrupt");
d2353 1
a2353 1
	else
d2764 1
d2795 1
@


1.5
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d24 1
a24 1
static char id[] = "@@(#)$Sendmail: main.c,v 8.485.4.44 2001/02/08 14:06:55 ca Exp $";
d36 4
a82 1
char		**SaveArgv;	/* argument vector for re-execing */
d167 8
a231 8
	/*
	**  Seed the random number generator.
	**  Used for queue file names, picking a queue directory, and
	**  MX randomization.
	*/

	seed_random();

d248 7
a254 2
	/* arrange to dump state on user-1 signal */
	(void) setsignal(SIGUSR1, sigusr1);
d311 1
d314 6
a319 1
#if LOG
d326 1
a327 1
	}
d366 1
d489 1
a490 4
	if (setsignal(SIGINT, SIG_IGN) != SIG_IGN)
		(void) setsignal(SIGINT, intsig);
	(void) setsignal(SIGTERM, intsig);
	(void) setsignal(SIGPIPE, SIG_IGN);
d1040 53
d1252 1
d1274 1
a1274 4
		(void) setsignal(SIGHUP, sighup);

		/* workaround: can't seem to release the signal in the parent */
		(void) releasesignal(SIGHUP);
d1313 1
a1313 1
				free(full);
d1655 1
a1655 14
	/*
	**  basic TLS initialization
	**  ignore result for now
	*/
	SSL_library_init();
	SSL_load_error_strings();
#  if 0
	/* this is currently a macro for SSL_library_init */
	SSLeay_add_ssl_algorithms();
#  endif /* 0 */

	/* initialize PRNG */
	tls_ok = tls_rand_init(RandFile, 7);

d1751 1
d1755 3
a1757 1
					if (DoQueueRun)
d2052 17
d2071 1
a2071 1
SIGFUNC_DECL
d2075 27
a2101 2
	clear_events();
	finis(FALSE, EX_OK);
d2104 19
d2124 1
a2124 1
SIGFUNC_DECL
d2128 7
d2157 3
d2209 1
a2209 1
			  getpid());
d2221 65
d2299 6
d2313 1
d2315 4
a2318 1
	clear_events();
a2321 4
	closecontrolsocket(TRUE);
#ifdef XLA
	xla_all_end();
#endif /* XLA */
d2522 1
a2522 1
			  getpid());
d2761 15
a2775 1

d2778 1
a2778 1
SIGFUNC_DECL
d2782 5
d2788 1
a2789 53
}


/* ARGSUSED */
SIGFUNC_DECL
sighup(sig)
	int sig;
{
	int i;
	extern int DtableSize;

	clear_events();
	(void) alarm(0);
	if (SaveArgv[0][0] != '/')
	{
		if (LogLevel > 3)
			sm_syslog(LOG_INFO, NOQID,
				  "could not restart: need full path");
		finis(FALSE, EX_OSFILE);
	}
	if (LogLevel > 3)
		sm_syslog(LOG_INFO, NOQID, "restarting %s %s",
			  sig == 0 ? "due to control command" : "on signal",
			  SaveArgv[0]);

	/* Control socket restart? */
	if (sig != 0)
		(void) releasesignal(SIGHUP);

	closecontrolsocket(TRUE);
	if (drop_privileges(TRUE) != EX_OK)
	{
		if (LogLevel > 0)
			sm_syslog(LOG_ALERT, NOQID,
				  "could not set[ug]id(%d, %d): %m",
				  RunAsUid, RunAsGid);
		finis(FALSE, EX_OSERR);
	}

	/* arrange for all the files to be closed */
	for (i = 3; i < DtableSize; i++)
	{
		register int j;

		if ((j = fcntl(i, F_GETFD, 0)) != -1)
			(void) fcntl(i, F_SETFD, j | FD_CLOEXEC);
	}

	(void) execve(SaveArgv[0], (ARGV_T) SaveArgv, (ARGV_T) ExternalEnviron);
	if (LogLevel > 0)
		sm_syslog(LOG_ALERT, NOQID, "could not exec %s: %m",
			  SaveArgv[0]);
	finis(FALSE, EX_OSFILE);
@


1.5.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d24 1
a24 1
static char id[] = "@@(#)$Sendmail: main.c,v 8.485.4.60 2001/05/27 22:00:26 gshapiro Exp $";
a35 4
static SIGFUNC_DECL	intindebug __P((int));
static SIGFUNC_DECL	quiesce __P((int));
static SIGFUNC_DECL	sigusr1 __P((int));
static SIGFUNC_DECL	term_daemon __P((int));
d79 1
a163 8
	/*
	**  Seed the random number generator.
	**  Used for queue file names, picking a queue directory, and
	**  MX randomization.
	*/

	seed_random();

d221 8
d245 2
a246 7
	/* Only allow root (or non-set-*-ID binaries) to use SIGUSR1 */
	if (getuid() == 0 ||
	    (getuid() == geteuid() && getgid() == getegid()))
	{
		/* arrange to dump state on user-1 signal */
		(void) setsignal(SIGUSR1, sigusr1);
	}
a302 1
#if LOG
d305 1
a305 6
		/* Sanitize the string */
		for (p = sysloglabel; *p != '\0'; p++)
		{
			if (!isascii(*p) || !isprint(*p) || *p == '%')
				*p = '*';
		}
d312 1
a313 1
#endif /* LOG */
a351 1

d474 4
a478 1

a1027 53
	/* Remove the ability for a normal user to send signals */
	if (RealUid != 0 &&
	    RealUid != geteuid())
	{
		uid_t new_uid = geteuid();

#if HASSETREUID
		/*
		**  Since we can differentiate between uid and euid,
		**  make the uid a different user so the real user
		**  can't send signals.  However, it doesn't need to be
		**  root (euid has root).
		*/

		if (new_uid == 0)
			new_uid = DefUid;
		if (tTd(47, 5))
			dprintf("Changing real uid to %d\n", (int) new_uid);
		if (setreuid(new_uid, geteuid()) < 0)
		{
			syserr("main: setreuid(%d, %d) failed",
			       (int) new_uid, (int) geteuid());
			finis(FALSE, EX_OSERR);
			/* NOTREACHED */
		}
		if (tTd(47, 10))
			dprintf("Now running as e/ruid %d:%d\n",
				(int) geteuid(), (int) getuid());
#else /* HASSETREUID */
		/*
		**  Have to change both effective and real so need to
		**  change them both to effective to keep privs.
		*/

		if (tTd(47, 5))
			dprintf("Changing uid to %d\n", (int) new_uid);
		if (setuid(new_uid) < 0)
		{
			syserr("main: setuid(%d) failed", (int) new_uid);
			finis(FALSE, EX_OSERR);
			/* NOTREACHED */
		}
		if (tTd(47, 10))
			dprintf("Now running as e/ruid %d:%d\n",
				(int) geteuid(), (int) getuid());
#endif /* HASSETREUID */
	}

	/* set up the basic signal handlers */
	if (setsignal(SIGINT, SIG_IGN) != SIG_IGN)
		(void) setsignal(SIGINT, intsig);
	(void) setsignal(SIGTERM, intsig);

a1186 1

d1208 4
a1211 1
		(void) setsignal(SIGTERM, term_daemon);
d1250 1
a1250 1
				sm_free(full);
d1592 14
a1605 1
	tls_ok = init_tls_library();
a1700 1
				(void) setsignal(SIGTERM, term_daemon);
d1704 1
a1704 3
					if (ShutdownRequest != NULL)
						shutdown_daemon();
					else if (DoQueueRun)
a1998 17
/*
**  QUIESCE -- signal handler for SIGPIPE
**
**	Parameters:
**		sig -- incoming signal.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets StopRequest which should cause the mailq/hoststatus
**		display to stop.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/
d2001 1
a2001 1
static SIGFUNC_DECL
d2005 2
a2006 6
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, quiesce);
	StopRequest = TRUE;
	errno = save_errno;
	return SIGFUNC_RETURN;
a2007 40
/*
**  STOP_SENDMAIL -- Stop the running program
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		exits.
*/

void
stop_sendmail()
{
	/* reset uid for process accounting */
	endpwent();
	(void) setuid(RealUid);
	exit(EX_OK);
}

/*
**  INTINDEBUG -- signal handler for SIGINT in -bt mode
**
**	Parameters:
**		sig -- incoming signal.
**
**	Returns:
**		none.
**
**	Side Effects:
**		longjmps back to test mode loop.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
**
**	XXX: More work is needed for this signal handler.
*/
d2010 1
a2010 1
static SIGFUNC_DECL
a2013 7
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, intindebug);
	errno = save_errno;
	CHECK_CRITICAL(sig);

	errno = save_errno;
a2035 3
	/* Still want to process new timeouts added below */
	clear_events();
	releasesignal(SIGALRM);
d2085 1
a2085 1
			  (int) getpid());
a2096 65
**  TERM_DEAMON -- SIGTERM handler for the daemon
**
**	Parameters:
**		sig -- signal number.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets ShutdownRequest which will hopefully trigger
**		the daemon to exit.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

/* ARGSUSED */
static SIGFUNC_DECL
term_daemon(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, term_daemon);
	ShutdownRequest = "signal";
	errno = save_errno;
	return SIGFUNC_RETURN;
}
/*
**  SHUTDOWN_DAEMON -- Performs a clean shutdown of the daemon
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		closes control socket, exits.
*/

void
shutdown_daemon()
{
	char *reason;

	allsignals(TRUE);

	reason = ShutdownRequest;
	ShutdownRequest = NULL;
	PendingSignal = 0;

	if (LogLevel > 79)
		sm_syslog(LOG_DEBUG, CurEnv->e_id, "interrupt");

	FileName = NULL;
	closecontrolsocket(TRUE);
#ifdef XLA
	xla_all_end();
#endif /* XLA */

	finis(FALSE, EX_OK);
}
/*
a2109 6
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
**
**		XXX: More work is needed for this signal handler.
a2117 1
	int save_errno = errno;
d2119 1
a2119 4
	FIX_SYSV_SIGNAL(sig, intsig);
	errno = save_errno;
	CHECK_CRITICAL(sig);
	allsignals(TRUE);
d2123 4
d2327 1
a2327 1
			  (int) getpid());
d2566 1
a2566 15
/*
**  SIGUSR1 -- Signal a request to dump state.
**
**	Parameters:
**		sig -- calling signal.
**
**	Returns:
**		none.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
**
**		XXX: More work is needed for this signal handler.
*/
d2569 1
a2569 1
static SIGFUNC_DECL
a2572 5
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, sigusr1);
	errno = save_errno;
	CHECK_CRITICAL(sig);
a2573 1
	errno = save_errno;
d2575 53
@


1.4
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d16 1
a16 1
"@@(#) Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.\n\
d24 1
a24 1
static char id[] = "@@(#)$Sendmail: main.c,v 8.485.4.38 2000/12/19 02:50:33 gshapiro Exp $";
d1065 2
a1066 1
	setclass('m', jbuf);
d1235 2
a1236 1
			FullName = full = newstr(denlstring(FullName, TRUE, TRUE));
d1238 1
d1247 1
d1302 5
a1306 2
	MyHostName = jbuf;
	if (strchr(jbuf, '.') == NULL)
d1308 1
a1308 1
			jbuf);
d1865 1
a1865 1
			CurEnv->e_auth_param = newstr(xtextify(p, NULL));
d1876 1
@


1.3
log
@Fix non-exploitable buffer oflow in test mode.  Also add a line to uncomment
in sendmail/Makefile to cause sendmail to drop privs in test mode.
From sendmail+gshapiro@@SENDMAIL.ORG
@
text
@d24 1
a24 1
static char id[] = "@@(#)$Sendmail: main.c,v 8.485 2000/03/11 19:53:01 ca Exp $";
d30 2
d96 2
a97 1
static sasl_callback_t srvcallbacks[] = {
d102 1
d120 1
d138 3
d167 1
d191 1
a191 1
# ifdef LOG_MAIL
d193 1
a193 1
# else /* LOG_MAIL */
d195 1
a195 1
# endif /* LOG_MAIL */
d241 2
a242 1
	(void) drop_privileges(FALSE);
d244 1
a244 1
#ifdef SIGUSR1
d247 1
a247 1
#endif /* SIGUSR1 */
d259 1
d307 1
a307 1
# ifdef LOG_MAIL
d309 1
a309 1
# else /* LOG_MAIL */
d311 1
a311 1
# endif /* LOG_MAIL */
a314 1

d339 1
d490 5
d496 1
d498 3
d627 4
d707 1
a707 1
			CurEnv->e_bodytype = optarg;
d713 3
a715 2
			ConfFile = optarg;
			(void) drop_privileges(TRUE);
d744 1
a744 1
			CurEnv->e_hopcount = strtol(optarg, &ep, 10);
d913 2
a914 1
			(void) drop_privileges(TRUE);
d1043 2
a1044 1
		(void) drop_privileges(FALSE);
a1402 1
	setclass(macid("{persistentMacros}", NULL), "{if_family}");
d1461 1
d1584 16
d1610 8
d1624 10
d1706 4
d1730 1
a1730 2
		sm_syslog(LOG_INFO, CurEnv->e_id,
			  "connect from %.100s", authinfo);
a1785 6
#if SASL
		/* give a syserr or just disable AUTH ? */
		if (sasl_server_init(srvcallbacks, "Sendmail") != SASL_OK)
			syserr("!sasl_server_init failed!");
#endif /* SASL */

d1799 6
d2188 1
a2188 1
	{ '\0' }
d2202 1
a2202 1
	extern char *MacroName[256];
d2409 12
a2420 1
			(void) myhostname(hostbuf, sizeof hostbuf);
d2427 1
a2427 1
		addheader("X-Authentication-Warning", buf, &e->e_header);
d2642 2
a2643 1
			(int)to_real_uid, (int)RealUid, (int)RealGid, (int)RunAsUid, (int)RunAsGid);
d2658 3
d2662 1
d2666 2
d2669 35
a2703 2
	if ((to_real_uid || RunAsUid != 0) && setuid(RunAsUid) < 0)
		rval = EX_OSERR;
d2707 2
a2708 1
			(int)geteuid(), (int)getuid(), (int)getegid(), (int)getgid());
d2711 2
d2794 5
d2814 1
a2814 1
			if (mid == '\0')
d2825 1
a2825 1
			if (mid == '\0')
d2931 1
a2931 1
			if (mid != '\0')
d2936 1
a2936 1
		if (mid == '\0')
d3201 1
a3201 1
	if (bitnset(id & 0xff, s->s_class))
@


1.3.2.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
"@@(#) Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.\n\
d24 1
a24 1
static char id[] = "@@(#)$Sendmail: main.c,v 8.485.4.60 2001/05/27 22:00:26 gshapiro Exp $";
a29 2


a33 4
static SIGFUNC_DECL	intindebug __P((int));
static SIGFUNC_DECL	quiesce __P((int));
static SIGFUNC_DECL	sigusr1 __P((int));
static SIGFUNC_DECL	term_daemon __P((int));
d77 1
d94 1
a94 2
static sasl_callback_t srvcallbacks[] =
{
a98 1

a115 1
	int dp;
a132 3
# if STARTTLS
	bool tls_ok;
# endif /* STARTTLS */
a155 8
	/*
	**  Seed the random number generator.
	**  Used for queue file names, picking a queue directory, and
	**  MX randomization.
	*/

	seed_random();

a158 1

d182 1
a182 1
#  ifdef LOG_MAIL
d184 1
a184 1
#  else /* LOG_MAIL */
d186 1
a186 1
#  endif /* LOG_MAIL */
d212 8
d232 1
a232 2
	dp = drop_privileges(FALSE);
	setstat(dp);
d234 4
a237 9
# ifdef SIGUSR1
	/* Only allow root (or non-set-*-ID binaries) to use SIGUSR1 */
	if (getuid() == 0 ||
	    (getuid() == geteuid() && getgid() == getegid()))
	{
		/* arrange to dump state on user-1 signal */
		(void) setsignal(SIGUSR1, sigusr1);
	}
# endif /* SIGUSR1 */
a248 1

a291 1
#if LOG
d294 1
a294 6
		/* Sanitize the string */
		for (p = sysloglabel; *p != '\0'; p++)
		{
			if (!isascii(*p) || !isprint(*p) || *p == '%')
				*p = '*';
		}
d296 1
a296 1
#  ifdef LOG_MAIL
d298 1
a298 1
#  else /* LOG_MAIL */
d300 2
a301 1
#  endif /* LOG_MAIL */
d303 1
a303 1
#endif /* LOG */
a328 1

a340 1

d463 4
a467 1

a478 5

	/*
	**  hack to avoid crashes when debugging for the resolver is
	**  turned on and sfio is used
	*/
a479 1
# if !SFIO || SFIO_STDIO_COMPAT
a480 3
# else /* !SFIO || SFIO_STDIO_COMPAT */
		dprintf("RES_DEBUG not available due to SFIO\n");
# endif /* !SFIO || SFIO_STDIO_COMPAT */
a606 4
#if _FFR_FREEHOSTENT && NETINET6
		freehostent(hp);
		hp = NULL;
#endif /* _FFR_FREEHOSTENT && NETINET6 */
d683 1
a683 1
			CurEnv->e_bodytype = newstr(optarg);
d689 2
a690 3
			ConfFile = newstr(optarg);
			dp = drop_privileges(TRUE);
			setstat(dp);
d719 1
a719 1
			CurEnv->e_hopcount = (short) strtol(optarg, &ep, 10);
d888 1
a888 2
			dp = drop_privileges(TRUE);
			setstat(dp);
a1001 53
	/* Remove the ability for a normal user to send signals */
	if (RealUid != 0 &&
	    RealUid != geteuid())
	{
		uid_t new_uid = geteuid();

#if HASSETREUID
		/*
		**  Since we can differentiate between uid and euid,
		**  make the uid a different user so the real user
		**  can't send signals.  However, it doesn't need to be
		**  root (euid has root).
		*/

		if (new_uid == 0)
			new_uid = DefUid;
		if (tTd(47, 5))
			dprintf("Changing real uid to %d\n", (int) new_uid);
		if (setreuid(new_uid, geteuid()) < 0)
		{
			syserr("main: setreuid(%d, %d) failed",
			       (int) new_uid, (int) geteuid());
			finis(FALSE, EX_OSERR);
			/* NOTREACHED */
		}
		if (tTd(47, 10))
			dprintf("Now running as e/ruid %d:%d\n",
				(int) geteuid(), (int) getuid());
#else /* HASSETREUID */
		/*
		**  Have to change both effective and real so need to
		**  change them both to effective to keep privs.
		*/

		if (tTd(47, 5))
			dprintf("Changing uid to %d\n", (int) new_uid);
		if (setuid(new_uid) < 0)
		{
			syserr("main: setuid(%d) failed", (int) new_uid);
			finis(FALSE, EX_OSERR);
			/* NOTREACHED */
		}
		if (tTd(47, 10))
			dprintf("Now running as e/ruid %d:%d\n",
				(int) geteuid(), (int) getuid());
#endif /* HASSETREUID */
	}

	/* set up the basic signal handlers */
	if (setsignal(SIGINT, SIG_IGN) != SIG_IGN)
		(void) setsignal(SIGINT, intsig);
	(void) setsignal(SIGTERM, intsig);

d1017 1
a1017 2
		dp = drop_privileges(FALSE);
		setstat(dp);
d1038 1
a1038 2
	if (jbuf[0] != '\0')
		setclass('m', jbuf);
a1158 1

d1180 4
a1183 1
		(void) setsignal(SIGTERM, term_daemon);
d1207 1
a1207 2
			full = newstr(denlstring(FullName, TRUE, TRUE));
			FullName = full;
a1208 1

a1216 1

d1219 1
a1219 1
				sm_free(full);
d1271 2
a1272 5
	if (jbuf[0] == '\0')
		MyHostName = newstr("localhost");
	else
		MyHostName = jbuf;
	if (strchr(MyHostName, '.') == NULL)
d1274 1
a1274 1
			MyHostName);
d1376 1
a1434 1

a1556 3
# if STARTTLS
	tls_ok = init_tls_library();
# endif /* STARTTLS */
a1566 8
#  if STARTTLS
		if (tls_ok
		   )
		{
			/* init TLS for client, ignore result for now */
			(void) initclttls();
		}
#  endif /* STARTTLS */
a1572 10
# if SASL
	if (OpMode == MD_SMTP || OpMode == MD_DAEMON)
	{
		/* give a syserr or just disable AUTH ? */
		if ((i = sasl_server_init(srvcallbacks, "Sendmail")) != SASL_OK)
			syserr("!sasl_server_init failed! [%s]",
			       sasl_errstring(i, NULL, NULL));
	}
# endif /* SASL */

a1632 1
				(void) setsignal(SIGTERM, term_daemon);
d1636 1
a1636 3
					if (ShutdownRequest != NULL)
						shutdown_daemon();
					else if (DoQueueRun)
a1644 4
# if STARTTLS
		/* init TLS for server, ignore result for now */
		(void) initsrvtls();
# endif /* STARTTLS */
d1665 2
a1666 1
		sm_syslog(LOG_INFO, NULL, "connect from %.100s", authinfo);
d1722 6
a1740 6
# if STARTTLS
		if (OpMode == MD_SMTP)
			(void) initsrvtls();
# endif /* STARTTLS */


d1794 1
a1794 1
			CurEnv->e_auth_param = newstr(xtextify(p, "="));
a1804 1
		SuperSafe = FALSE;
a1926 17
/*
**  QUIESCE -- signal handler for SIGPIPE
**
**	Parameters:
**		sig -- incoming signal.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets StopRequest which should cause the mailq/hoststatus
**		display to stop.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/
d1929 1
a1929 1
static SIGFUNC_DECL
d1933 2
a1934 27
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, quiesce);
	StopRequest = TRUE;
	errno = save_errno;
	return SIGFUNC_RETURN;
}
/*
**  STOP_SENDMAIL -- Stop the running program
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		exits.
*/

void
stop_sendmail()
{
	/* reset uid for process accounting */
	endpwent();
	(void) setuid(RealUid);
	exit(EX_OK);
a1936 19
/*
**  INTINDEBUG -- signal handler for SIGINT in -bt mode
**
**	Parameters:
**		sig -- incoming signal.
**
**	Returns:
**		none.
**
**	Side Effects:
**		longjmps back to test mode loop.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
**
**	XXX: More work is needed for this signal handler.
*/

d1938 1
a1938 1
static SIGFUNC_DECL
a1941 7
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, intindebug);
	errno = save_errno;
	CHECK_CRITICAL(sig);

	errno = save_errno;
a1963 3
	/* Still want to process new timeouts added below */
	clear_events();
	releasesignal(SIGALRM);
d2013 1
a2013 1
			  (int) getpid());
a2024 65
**  TERM_DEAMON -- SIGTERM handler for the daemon
**
**	Parameters:
**		sig -- signal number.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets ShutdownRequest which will hopefully trigger
**		the daemon to exit.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

/* ARGSUSED */
static SIGFUNC_DECL
term_daemon(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, term_daemon);
	ShutdownRequest = "signal";
	errno = save_errno;
	return SIGFUNC_RETURN;
}
/*
**  SHUTDOWN_DAEMON -- Performs a clean shutdown of the daemon
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		closes control socket, exits.
*/

void
shutdown_daemon()
{
	char *reason;

	allsignals(TRUE);

	reason = ShutdownRequest;
	ShutdownRequest = NULL;
	PendingSignal = 0;

	if (LogLevel > 79)
		sm_syslog(LOG_DEBUG, CurEnv->e_id, "interrupt");

	FileName = NULL;
	closecontrolsocket(TRUE);
#ifdef XLA
	xla_all_end();
#endif /* XLA */

	finis(FALSE, EX_OK);
}
/*
a2037 6
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
**
**		XXX: More work is needed for this signal handler.
a2045 1
	int save_errno = errno;
d2047 1
a2047 4
	FIX_SYSV_SIGNAL(sig, intsig);
	errno = save_errno;
	CHECK_CRITICAL(sig);
	allsignals(TRUE);
d2051 4
d2124 1
a2124 1
	{ '\0', '\0' }
d2138 1
a2138 1
	extern char *MacroName[MAXMACROID + 1];
d2255 1
a2255 1
			  (int) getpid());
d2345 1
a2345 12
		{
			struct hostent *hp;

			hp = myhostname(hostbuf, sizeof hostbuf);
#if _FFR_FREEHOSTENT && NETINET6
			if (hp != NULL)
			{
				freehostent(hp);
				hp = NULL;
			}
#endif /* _FFR_FREEHOSTENT && NETINET6 */
		}
d2352 1
a2352 1
		addheader("X-Authentication-Warning", buf, 0, &e->e_header);
d2483 1
a2483 15
/*
**  SIGUSR1 -- Signal a request to dump state.
**
**	Parameters:
**		sig -- calling signal.
**
**	Returns:
**		none.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
**
**		XXX: More work is needed for this signal handler.
*/
d2486 1
a2486 1
static SIGFUNC_DECL
a2489 5
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, sigusr1);
	errno = save_errno;
	CHECK_CRITICAL(sig);
a2490 1
	errno = save_errno;
d2493 53
d2567 1
a2567 2
			(int)to_real_uid, (int)RealUid,
			(int)RealGid, (int)RunAsUid, (int)RunAsGid);
a2581 3
	{
		syserr("drop_privileges: setgroups(1, %d) failed",
		       (int)emptygidset[0]);
a2582 1
	}
a2585 2
	{
		syserr("drop_privileges: setgid(%d) failed", (int)RunAsGid);
d2587 2
a2588 35
	}
	if (to_real_uid || RunAsUid != 0)
	{
		uid_t euid = geteuid();

		if (setuid(RunAsUid) < 0)
		{
			syserr("drop_privileges: setuid(%d) failed",
			       (int)RunAsUid);
			rval = EX_OSERR;
		}
		else if (RunAsUid != 0 && setuid(0) == 0)
		{
			/*
			**  Believe it or not, the Linux capability model
			**  allows a non-root process to override setuid()
			**  on a process running as root and prevent that
			**  process from dropping privileges.
			*/

			syserr("drop_privileges: setuid(0) succeeded (when it should not)");
			rval = EX_OSERR;
		}
		else if (RunAsUid != euid && setuid(euid) == 0)
		{
			/*
			**  Some operating systems will keep the saved-uid
			**  if a non-root effective-uid calls setuid(real-uid)
			**  making it possible to set it back again later.
			*/

			syserr("drop_privileges: Unable to drop non-root set-user-id privileges");
			rval = EX_OSERR;
		}
	}
d2592 1
a2592 2
			(int)geteuid(), (int)getuid(),
			(int)getegid(), (int)getgid());
a2594 2
		if (tTd(47, 10))
			dprintf("drop_privileges: rval = %d\n", rval);
a2675 5

	/* skip leading spaces */
	while (*line == ' ')
		line++;

d2691 1
a2691 1
			if (mid == 0)
d2702 1
a2702 1
			if (mid == 0)
d2808 1
a2808 1
			if (mid != 0)
d2813 1
a2813 1
		if (mid == 0)
d3078 1
a3078 1
	if (bitnset(bitidx(id), s->s_class))
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d1520 9
@


1.2.2.1
log
@Pull in patch from current:
Errata:
There is a non-exploitable buffer overflow in sendmail's test mode.
Fix (millert):
Fix non-exploitable buffer oflow in test mode.  Also add a line to uncomment
in sendmail/Makefile to cause sendmail to drop privs in test mode.
From sendmail+gshapiro@@SENDMAIL.ORG
@
text
@a1519 9
#if _FFR_TESTMODE_DROP_PRIVS
		dp = drop_privileges(TRUE);
		if (dp != EX_OK)
		{
			CurEnv->e_id = NULL;
			finis(TRUE, dp);
		}
#endif /* _FFR_TESTMODE_DROP_PRIVS */

@


1.1
log
@Initial revision
@
text
@d24 1
a24 1
static char id[] = "@@(#)$Sendmail: main.c,v 8.483 2000/02/26 01:32:26 gshapiro Exp $";
d280 3
a282 1
			sysloglabel = optarg;
a293 2
		if (strlen(sysloglabel) > 24)
			sysloglabel[24] = '\0';
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d24 1
a24 1
static char id[] = "@@(#)$Id: main.c,v 8.485.4.38 2000/12/19 02:50:33 gshapiro Exp $";
a29 2


d94 1
a94 2
static sasl_callback_t srvcallbacks[] =
{
a98 1

a115 1
	int dp;
a132 3
# if STARTTLS
	bool tls_ok;
# endif /* STARTTLS */
a158 1

d182 1
a182 1
#  ifdef LOG_MAIL
d184 1
a184 1
#  else /* LOG_MAIL */
d186 1
a186 1
#  endif /* LOG_MAIL */
d232 1
a232 2
	dp = drop_privileges(FALSE);
	setstat(dp);
d234 1
a234 1
# ifdef SIGUSR1
d237 1
a237 1
# endif /* SIGUSR1 */
a248 1

d280 1
a280 3
			j = min(strlen(optarg), 24) + 1;
			sysloglabel = xalloc(j);
			(void) strlcpy(sysloglabel, optarg, j);
d292 2
d296 1
a296 1
#  ifdef LOG_MAIL
d298 1
a298 1
#  else /* LOG_MAIL */
d300 1
a300 1
#  endif /* LOG_MAIL */
d304 1
a328 1

a478 5

	/*
	**  hack to avoid crashes when debugging for the resolver is
	**  turned on and sfio is used
	*/
a479 1
# if !SFIO || SFIO_STDIO_COMPAT
a480 3
# else /* !SFIO || SFIO_STDIO_COMPAT */
		dprintf("RES_DEBUG not available due to SFIO\n");
# endif /* !SFIO || SFIO_STDIO_COMPAT */
a606 4
#if _FFR_FREEHOSTENT && NETINET6
		freehostent(hp);
		hp = NULL;
#endif /* _FFR_FREEHOSTENT && NETINET6 */
d683 1
a683 1
			CurEnv->e_bodytype = newstr(optarg);
d689 2
a690 3
			ConfFile = newstr(optarg);
			dp = drop_privileges(TRUE);
			setstat(dp);
d719 1
a719 1
			CurEnv->e_hopcount = (short) strtol(optarg, &ep, 10);
d888 1
a888 2
			dp = drop_privileges(TRUE);
			setstat(dp);
d1017 1
a1017 2
		dp = drop_privileges(FALSE);
		setstat(dp);
d1376 1
a1434 1

a1519 9
#if _FFR_TESTMODE_DROP_PRIVS
		dp = drop_privileges(TRUE);
		if (dp != EX_OK)
		{
			CurEnv->e_id = NULL;
			finis(TRUE, dp);
		}
#endif /* _FFR_TESTMODE_DROP_PRIVS */

a1547 16
# if STARTTLS
	/*
	**  basic TLS initialization
	**  ignore result for now
	*/
	SSL_library_init();
	SSL_load_error_strings();
#  if 0
	/* this is currently a macro for SSL_library_init */
	SSLeay_add_ssl_algorithms();
#  endif /* 0 */

	/* initialize PRNG */
	tls_ok = tls_rand_init(RandFile, 7);

# endif /* STARTTLS */
a1557 8
#  if STARTTLS
		if (tls_ok
		   )
		{
			/* init TLS for client, ignore result for now */
			(void) initclttls();
		}
#  endif /* STARTTLS */
a1563 10
# if SASL
	if (OpMode == MD_SMTP || OpMode == MD_DAEMON)
	{
		/* give a syserr or just disable AUTH ? */
		if ((i = sasl_server_init(srvcallbacks, "Sendmail")) != SASL_OK)
			syserr("!sasl_server_init failed! [%s]",
			       sasl_errstring(i, NULL, NULL));
	}
# endif /* SASL */

a1635 4
# if STARTTLS
		/* init TLS for server, ignore result for now */
		(void) initsrvtls();
# endif /* STARTTLS */
d1656 2
a1657 1
		sm_syslog(LOG_INFO, NULL, "connect from %.100s", authinfo);
d1713 6
a1731 6
# if STARTTLS
		if (OpMode == MD_SMTP)
			(void) initsrvtls();
# endif /* STARTTLS */


d2115 1
a2115 1
	{ '\0', '\0' }
d2129 1
a2129 1
	extern char *MacroName[MAXMACROID + 1];
d2336 1
a2336 12
		{
			struct hostent *hp;

			hp = myhostname(hostbuf, sizeof hostbuf);
#if _FFR_FREEHOSTENT && NETINET6
			if (hp != NULL)
			{
				freehostent(hp);
				hp = NULL;
			}
#endif /* _FFR_FREEHOSTENT && NETINET6 */
		}
d2343 1
a2343 1
		addheader("X-Authentication-Warning", buf, 0, &e->e_header);
d2558 1
a2558 2
			(int)to_real_uid, (int)RealUid,
			(int)RealGid, (int)RunAsUid, (int)RunAsGid);
a2572 3
	{
		syserr("drop_privileges: setgroups(1, %d) failed",
		       (int)emptygidset[0]);
a2573 1
	}
a2576 2
	{
		syserr("drop_privileges: setgid(%d) failed", (int)RunAsGid);
d2578 2
a2579 35
	}
	if (to_real_uid || RunAsUid != 0)
	{
		uid_t euid = geteuid();

		if (setuid(RunAsUid) < 0)
		{
			syserr("drop_privileges: setuid(%d) failed",
			       (int)RunAsUid);
			rval = EX_OSERR;
		}
		else if (RunAsUid != 0 && setuid(0) == 0)
		{
			/*
			**  Believe it or not, the Linux capability model
			**  allows a non-root process to override setuid()
			**  on a process running as root and prevent that
			**  process from dropping privileges.
			*/

			syserr("drop_privileges: setuid(0) succeeded (when it should not)");
			rval = EX_OSERR;
		}
		else if (RunAsUid != euid && setuid(euid) == 0)
		{
			/*
			**  Some operating systems will keep the saved-uid
			**  if a non-root effective-uid calls setuid(real-uid)
			**  making it possible to set it back again later.
			*/

			syserr("drop_privileges: Unable to drop non-root set-user-id privileges");
			rval = EX_OSERR;
		}
	}
d2583 1
a2583 2
			(int)geteuid(), (int)getuid(),
			(int)getegid(), (int)getgid());
a2585 2
		if (tTd(47, 10))
			dprintf("drop_privileges: rval = %d\n", rval);
a2666 5

	/* skip leading spaces */
	while (*line == ' ')
		line++;

d2682 1
a2682 1
			if (mid == 0)
d2693 1
a2693 1
			if (mid == 0)
d2799 1
a2799 1
			if (mid != 0)
d2804 1
a2804 1
		if (mid == 0)
d3069 1
a3069 1
	if (bitnset(bitidx(id), s->s_class))
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
a13 5
#define _DEFINE
#include <sendmail.h>
#include <sm/xtrap.h>
#include <sm/signal.h>

d15 2
a16 2
SM_UNUSED(static char copyright[]) =
"@@(#) Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.\n\
d23 7
a29 1
SM_RCSID("@@(#)$Sendmail: main.c,v 8.804 2001/09/08 01:21:09 gshapiro Exp $")
a35 7
/* for getcfname() */
#include <sendmail/pathnames.h>

static SM_DEBUG_T
DebugNoPRestart = SM_DEBUG_INITIALIZER("no_persistent_restart",
	"@@(#)$Debug: no_persistent_restart - don't restart, log only $");

a38 9
static char	*getextenv __P((const char *));
static void	sm_printoptions __P((char **));
static SIGFUNC_DECL	intindebug __P((int));
static SIGFUNC_DECL	sighup __P((int));
static SIGFUNC_DECL	sigpipe __P((int));
static SIGFUNC_DECL	sigterm __P((int));
#ifdef SIGUSR1
static SIGFUNC_DECL	sigusr1 __P((int));
#endif /* SIGUSR1 */
d56 1
a56 1
**	Authors:
a67 7
**
**		Gregory Neil Shapiro,
**			Worcester Polytechnic Institute	(until 3/98).
**			Sendmail, Inc. (3/98 - present).
**
**		Claus Assmann,
**			Sendmail, Inc. (12/98 - present).
d70 2
d78 2
a79 1
bool		Warn_Q_option = false;	/* warn about Q option use */
a80 1
char		*Mbdb = "pw";	/* mailbox database defaults to /etc/passwd */
d86 8
a93 1
#define MAXCONFIGLEVEL	10	/* highest config version level known */
d102 1
d105 1
a105 8
unsigned int	SubmitMode;
int		SyslogPrefixLen; /* estimated length of syslog prefix */
#define PIDLEN		6	/* pid length for computing SyslogPrefixLen */
#ifndef SL_FUDGE
# define SL_FUDGE	10	/* fudge offset for SyslogPrefixLen */
#endif /* ! SL_FUDGE */
#define SLDLL		8	/* est. length of default syslog label */

d121 1
a121 1
	bool safecf = true;
d123 2
a124 2
	bool warn_C_flag = false;
	bool auth = true;		/* whether to set e_auth_param */
d126 2
a127 1
	bool run_in_foreground = false;	/* -bD mode */
d133 1
a133 7
	char *conffile = NULL;		/* name of .cf file */
	char *runqueuegroup = NULL;	/* queue group to process */
	bool forged, negate;
	bool queuepersistent = false;	/* queue runner process runs forever */
	bool foregroundqueue = false;	/* queue run in foreground */
	int cftype;			/* which cf file to use? */
	static time_t starttime = 0;	/* when was process started */
a134 1
	char buf[MAXLINE];
d138 1
a138 1
#if STARTTLS
d140 1
a140 1
#endif /* STARTTLS */
a141 1
	ENVELOPE *e;
a146 9
#if SASL
	extern void sm_sasl_init __P((void));
#endif /* SASL */

	/* turn off profiling */
	SM_PROF(0);

	/* install default exception handler */
	sm_exc_newthread(fatal_error);
d154 1
a154 1
	if (starttime != 0)
d159 1
a159 1
	starttime = curtime();
a163 8
	/*
	**  Seed the random number generator.
	**  Used for queue file names, picking a queue directory, and
	**  MX randomization.
	*/

	seed_random();

a165 4
	CurrentPid = getpid();

	/* get whatever .cf file is right for the opmode */
	cftype = SM_GET_RIGHT_CF;
d185 1
a185 2
		if (i != STDIN_FILENO && i != STDOUT_FILENO &&
		    i != STDERR_FILENO)
a190 3
# ifndef SM_LOG_STR
#  define SM_LOG_STR	"sendmail"
# endif /* ! SM_LOG_STR */
d192 1
a192 1
	openlog(SM_LOG_STR, LOG_PID, LOG_MAIL);
d194 1
a194 1
	openlog(SM_LOG_STR, LOG_PID);
a197 1
	SyslogPrefixLen = PIDLEN + (MAXQFNAME - 3) + SL_FUDGE + SLDLL;
d204 1
a204 1
			(void) sm_strlcat(mbuf, ", stdin", sizeof mbuf);
d206 1
a206 1
			(void) sm_strlcat(mbuf, ", stdout", sizeof mbuf);
d208 1
a208 1
			(void) sm_strlcat(mbuf, ", stderr", sizeof mbuf);
d221 9
a229 1
	tTsetup(tTdvect, sizeof tTdvect, "0-99.1,*_trace_*.1");
d234 1
a234 1
	if (i <= 0)
d241 1
a241 1
	dp = drop_privileges(false);
d244 4
a247 9
#ifdef SIGUSR1
	/* Only allow root (or non-set-*-ID binaries) to use SIGUSR1 */
	if (getuid() == 0 ||
	    (getuid() == geteuid() && getgid() == getegid()))
	{
		/* arrange to dump state on user-1 signal */
		(void) sm_signal(SIGUSR1, sigusr1);
	}
#endif /* SIGUSR1 */
d261 1
a261 1
# define OPTIONS	"A:B:b:C:cd:e:F:f:Gh:IiL:M:mN:nO:o:p:q:R:r:sTtV:vX:x"
d264 1
a264 1
# define OPTIONS	"A:B:b:C:cd:E:e:F:f:Gh:IiJ:L:M:mN:nO:o:p:q:R:r:sTtV:vX:"
d267 1
a267 1
# define OPTIONS	"A:B:b:C:cd:e:F:f:Gh:IiL:M:mN:nO:o:p:q:R:r:sTtV:vX:"
d275 7
d283 1
a283 3
			(void) sm_io_setvbuf(smioout, SM_TIME_DEFAULT,
					     (char *) NULL, SM_IO_NBF,
					     SM_IO_BUFSIZ);
d287 1
a287 1
			SubmitMode = SUBMIT_MTA;
d291 1
a291 1
			j = SM_MIN(strlen(optarg), 24) + 1;
d293 1
a293 3
			(void) sm_strlcpy(sysloglabel, optarg, j);
			SyslogPrefixLen = PIDLEN + (MAXQFNAME - 3) +
					  SL_FUDGE + j;
d296 3
a302 1
#if LOG
d305 1
a305 6
		/* Sanitize the string */
		for (p = sysloglabel; *p != '\0'; p++)
		{
			if (!isascii(*p) || !isprint(*p) || *p == '%')
				*p = '*';
		}
d312 1
a313 1
#endif /* LOG */
a328 2
	initmacros(&BlankEnvelope);
	set_op_mode(MD_DELIVER);
d335 1
a335 1
		(void) sm_strlcpy(rnamebuf, pw->pw_name, sizeof rnamebuf);
d337 2
a338 2
		(void) sm_snprintf(rnamebuf, sizeof rnamebuf, "Unknown UID %d",
				   (int) RealUid);
d344 2
a345 3
		sm_dprintf("Version %s\n", Version);
		finis(false, EX_OK);
		/* NOTREACHED */
d349 1
a349 1
	**  if running non-set-user-ID binary as non-root, pretend
a351 1

d355 2
a356 2
			sm_dprintf("Non-set-user-ID binary: RunAsUid = RealUid = %d\n",
				   (int) RealUid);
d362 1
a362 2
	EffGid = getegid();
	if (RealUid != 0 && EffGid == RealGid)
d367 5
a371 5
		sm_dprintf("main: e/ruid = %d/%d e/rgid = %d/%d\n",
			   (int) geteuid(), (int) getuid(),
			   (int) getegid(), (int) getgid());
		sm_dprintf("main: RunAsUser = %d:%d\n",
			   (int) RunAsUid, (int) RunAsGid);
a377 7
	if (j < 0 || j > SM_ARG_MAX)
	{
		syserr("!Arguments too long");

		/* NOTREACHED */
		return EX_USAGE;
	}
d388 1
a388 1
		(void) sm_strlcpy(p, *av++, j);
d397 1
d400 18
a417 2
		sm_dprintf("Version %s\n Compiled with:", Version);
		sm_printoptions(CompileOptions);
d421 1
d424 18
a441 2
		sm_dprintf("    OS Defines:");
		sm_printoptions(OsCompileOptions);
d443 1
a443 1
		sm_dprintf("Kernel symbols:\t%s\n", _PATH_UNIX);
d445 2
a446 23

		/* XXX This doesn't work because OpMode isn't set correctly */
		sm_dprintf(" Def Conf file:\t%s\n", getcfname(OpMode,
							      SubmitMode,
							      SM_GET_RIGHT_CF,
							      conffile));
		sm_dprintf("  Def Pid file:\t%s\n", PidFile);
	}

	if (tTd(0, 12))
	{
		extern char *SmCompileOptions[];

		sm_dprintf(" libsm Defines:");
		sm_printoptions(SmCompileOptions);
	}

	if (tTd(0, 13))
	{
		extern char *FFRCompileOptions[];

		sm_dprintf("   FFR Defines:");
		sm_printoptions(FFRCompileOptions);
d449 2
a450 2
	InChannel = smioin;
	OutChannel = smioout;
a460 1

d468 1
a468 1
		(void) sm_strlcpyn(tz, tzlen, 2, "TZ=", p);
d475 4
a478 1
	(void) sm_signal(SIGPIPE, SIG_IGN);
d480 1
d490 5
d496 1
d498 3
a503 2
	if (bitset(RES_NOALIASES, _res.options))
		ResNoAliases = true;
d518 2
a519 1
	init_vendor_macros(&BlankEnvelope);
d522 1
a522 1
	macdefine(&BlankEnvelope.e_macro, A_PERM, 'v', Version);
d528 1
a528 1
		struct utsname utsname;
d531 3
a533 3
			sm_dprintf("canonical name: %s\n", jbuf);
		macdefine(&BlankEnvelope.e_macro, A_TEMP, 'w', jbuf);
		macdefine(&BlankEnvelope.e_macro, A_TEMP, 'j', jbuf);
d541 1
a541 2
				macdefine(&BlankEnvelope.e_macro, A_TEMP, 'm',
					  &p[1]);
d547 1
a547 1
					sm_dprintf("\ta.k.a.: %s\n", jbuf);
d559 2
a560 2
				sm_dprintf("uname failed (%s)\n",
					   sm_errstring(errno));
d565 3
a567 2
			sm_dprintf(" UUCP nodename: %s\n", p);
		macdefine(&BlankEnvelope.e_macro, A_TEMP, 'k', p);
d576 1
a576 1
				sm_dprintf("\ta.k.a.: %s\n", *av);
d580 1
a580 1
		for (i = 0; i >= 0 && hp->h_addr_list[i] != NULL; i++)
d601 2
a602 2
				(void) sm_snprintf(ipbuf, sizeof ipbuf,
						   "[%.100s]", inet_ntoa(ia));
d614 2
a615 2
					(void) sm_snprintf(ipbuf, sizeof ipbuf,
							   "[%.100s]", addr);
d623 1
a623 1
				sm_dprintf("\ta.k.a.: %s\n", ipbuf);
d627 1
a627 1
#if NETINET6
d630 1
a630 1
#endif /* NETINET6 */
d634 1
a634 2
	macdefine(&BlankEnvelope.e_macro, A_TEMP, 'b', arpadate((char *) NULL));

d636 1
a636 1
	sm_getla();
d651 1
a651 1
		set_op_mode(MD_INITALIAS);
d653 1
a653 1
		set_op_mode(MD_PRINT);
d655 1
a655 1
		set_op_mode(MD_DAEMON);
d657 1
a657 1
		set_op_mode(MD_HOSTSTAT);
d659 1
a659 1
		set_op_mode(MD_PURGESTAT);
d671 5
d677 6
a687 1
			  case MD_PRINTNQE:
d691 1
a691 1
				set_op_mode(j);
a705 5
		  case 'A':	/* use Alternate sendmail/submit.cf */
			cftype = optarg[0] == 'c' ? SM_GET_SUBMIT_CF
						  : SM_GET_SENDMAIL_CF;
			break;

d707 1
a707 1
			BlankEnvelope.e_bodytype = newstr(optarg);
d712 3
a714 3
				warn_C_flag = true;
			conffile = newstr(optarg);
			dp = drop_privileges(true);
d716 1
a716 1
			safecf = false;
d730 1
a730 1
			from = newstr(denlstring(optarg, true, true));
d744 1
a744 6
			BlankEnvelope.e_hopcount = (short) strtol(optarg, &ep,
								  10);
			(void) sm_snprintf(buf, sizeof buf, "%d",
					   BlankEnvelope.e_hopcount);
			macdefine(&BlankEnvelope.e_macro, A_TEMP, 'c', buf);

d757 1
a757 1
			NoAlias = true;
d762 3
a764 3
			macdefine(&BlankEnvelope.e_macro, A_TEMP,
				macid("{dsn_notify}"), optarg);
			if (sm_strcasecmp(optarg, "never") == 0)
d771 1
a771 1
				if (sm_strcasecmp(optarg, "success") == 0)
d773 1
a773 1
				else if (sm_strcasecmp(optarg, "failure") == 0)
d775 1
a775 1
				else if (sm_strcasecmp(optarg, "delay") == 0)
d786 1
a786 2
			setoption(*optarg, optarg + 1, false, true,
				  &BlankEnvelope);
d790 1
a790 1
			setoption(' ', optarg, false, true, &BlankEnvelope);
d800 1
a800 1
					ep = sm_malloc_x(strlen(p) + 1);
d802 1
a802 2
					macdefine(&BlankEnvelope.e_macro,
						  A_HEAP, 's', ep);
d807 1
a807 1
				ep = sm_malloc_x(strlen(optarg) + 1);
d809 1
a809 2
				macdefine(&BlankEnvelope.e_macro, A_HEAP,
					  'r', ep);
d814 1
a819 1
			    OpMode != MD_PRINTNQE &&
d829 1
a829 1
				set_op_mode(MD_QUEUERUN);
a832 7
			negate = optarg[0] == '!';
			if (negate)
			{
				/* negate meaning of pattern match */
				optarg++; /* skip '!' for next switch */
			}

d835 1
a835 11
			  case 'G': /* Limit by queue group name */
				if (negate)
				{
					usrerr("Can not use -q!G");
					ExitStat = EX_USAGE;
					break;
				}
				runqueuegroup = newstr(&optarg[1]);
				break;

			  case 'I': /* Limit by ID */
a837 1
				new->queue_negate = negate;
d842 1
a842 1
			  case 'R': /* Limit by recipient */
a844 1
				new->queue_negate = negate;
d849 1
a849 1
			  case 'S': /* Limit by sender */
a851 1
				new->queue_negate = negate;
a855 12
			  case 'f': /* foreground queue run */
				foregroundqueue  = true;
				break;

			  case 'p': /* Persistent queue */
				queuepersistent = true;
				if (QueueIntvl == 0)
					QueueIntvl = 1;
				if (optarg[1] == '\0')
					break;
				++optarg;
				/* FALL THRU */
d865 4
d872 1
a872 1
			if (bitset(EF_RET_PARAM, BlankEnvelope.e_flags))
d878 4
a881 4
			BlankEnvelope.e_flags |= EF_RET_PARAM;
			if (sm_strcasecmp(optarg, "hdrs") == 0)
				BlankEnvelope.e_flags |= EF_NO_BODY_RETN;
			else if (sm_strcasecmp(optarg, "full") != 0)
d886 2
a887 2
			macdefine(&BlankEnvelope.e_macro, A_TEMP,
				  macid("{dsn_ret}"), optarg);
d891 5
a895 1
			GrabTo = true;
d906 3
a908 3
				BlankEnvelope.e_envid = newstr(optarg);
				macdefine(&BlankEnvelope.e_macro, A_TEMP,
					  macid("{dsn_envid}"), optarg);
d913 1
a913 1
			dp = drop_privileges(true);
d917 1
a917 4
				TrafficLogFile = sm_io_open(SmFtStdio,
							    SM_TIME_DEFAULT,
							    optarg,
							    SM_IO_WRONLY, NULL);
d919 1
a919 4
				TrafficLogFile = sm_io_open(SmFtStdio,
							    SM_TIME_DEFAULT,
							    optarg,
							    SM_IO_APPEND, NULL);
d926 5
a930 2
			(void) sm_io_setvbuf(TrafficLogFile, SM_TIME_DEFAULT,
					     NULL, SM_IO_LBF, 0);
d939 1
a939 1
			setoption(j, "T", false, true, &BlankEnvelope);
d944 1
a944 1
			setoption(j, optarg, false, true, &BlankEnvelope);
d948 1
a948 1
			setoption('f', "T", false, true, &BlankEnvelope);
d953 1
a953 1
			set_op_mode(MD_INITALIAS);
d969 1
a969 2
			finis(true, EX_USAGE);
			/* NOTREACHED */
d975 10
a984 1
	if (bitset(SUBMIT_MTA, SubmitMode))
d986 8
a993 2
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			  macid("{daemon_flags}"), "CC f");
d995 1
a995 1
	else if (OpMode == MD_DELIVER || OpMode == MD_SMTP)
d997 5
a1001 3
		SubmitMode = SUBMIT_MSA;
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			  macid("{daemon_flags}"), "c u");
d1010 1
a1010 14
#if XDEBUG
	checkfd012("before readcf");
#endif /* XDEBUG */
	vendor_pre_defaults(&BlankEnvelope);

	readcf(getcfname(OpMode, SubmitMode, cftype, conffile),
			 safecf, &BlankEnvelope);
#if !defined(_USE_SUN_NSSWITCH_) && !defined(_USE_DEC_SVC_CONF_)
	ConfigFileRead = true;
#endif /* !defined(_USE_SUN_NSSWITCH_) && !defined(_USE_DEC_SVC_CONF_) */
	vendor_post_defaults(&BlankEnvelope);

	/* Remove the ability for a normal user to send signals */
	if (RealUid != 0 && RealUid != geteuid())
d1012 1
a1012 29
		uid_t new_uid = geteuid();

#if HASSETREUID
		/*
		**  Since we can differentiate between uid and euid,
		**  make the uid a different user so the real user
		**  can't send signals.  However, it doesn't need to be
		**  root (euid has root).
		*/

		if (new_uid == 0)
			new_uid = DefUid;
		if (tTd(47, 5))
			sm_dprintf("Changing real uid to %d\n", (int) new_uid);
		if (setreuid(new_uid, geteuid()) < 0)
		{
			syserr("main: setreuid(%d, %d) failed",
			       (int) new_uid, (int) geteuid());
			finis(false, EX_OSERR);
			/* NOTREACHED */
		}
		if (tTd(47, 10))
			sm_dprintf("Now running as e/ruid %d:%d\n",
				   (int) geteuid(), (int) getuid());
#else /* HASSETREUID */
		/*
		**  Have to change both effective and real so need to
		**  change them both to effective to keep privs.
		*/
d1014 3
a1016 12
		if (tTd(47, 5))
			sm_dprintf("Changing uid to %d\n", (int) new_uid);
		if (setuid(new_uid) < 0)
		{
			syserr("main: setuid(%d) failed", (int) new_uid);
			finis(false, EX_OSERR);
			/* NOTREACHED */
		}
		if (tTd(47, 10))
			sm_dprintf("Now running as e/ruid %d:%d\n",
				   (int) geteuid(), (int) getuid());
#endif /* HASSETREUID */
d1019 4
a1022 15
#if NAMED_BIND
	if (FallBackMX != NULL)
		(void) getfallbackmxrr(FallBackMX);
#endif /* NAMED_BIND */

	if (SuperSafe == SAFE_INTERACTIVE && CurEnv->e_sendmode != SM_DELIVER)
	{
		printf("WARNING: SuperSafe=interactive should only be used with\n         DeliveryMode=interactive\n");
	}

	if (UseMSP && (OpMode == MD_DAEMON || OpMode == MD_FGDAEMON))
	{
		usrerr("Mail submission program cannot be used as daemon");
		finis(false, EX_USAGE);
	}
d1024 3
a1026 9
	if (OpMode == MD_DELIVER || OpMode == MD_SMTP || OpMode == MD_ARPAFTP ||
	    OpMode == MD_DAEMON || OpMode == MD_FGDAEMON ||
	    OpMode == MD_QUEUERUN)
		makeworkgroups();

	/* set up the basic signal handlers */
	if (sm_signal(SIGINT, SIG_IGN) != SIG_IGN)
		(void) sm_signal(SIGINT, intsig);
	(void) sm_signal(SIGTERM, intsig);
a1036 9
	/* initialize mailbox database */
	i = sm_mbdb_initialize(Mbdb);
	if (i != EX_OK)
	{
		usrerr("Can't initialize mailbox database \"%s\": %s",
		       Mbdb, sm_strexit(i));
		ExitStat = i;
	}

d1040 1
a1040 11
	if (OpMode == MD_TEST)
	{
		/* can't be done after readcf if RunAs* is used */
		dp = drop_privileges(true);
		if (dp != EX_OK)
		{
			finis(false, dp);
			/* NOTREACHED */
		}
	}
	else if (OpMode != MD_DAEMON && OpMode != MD_FGDAEMON)
d1043 1
a1043 1
		dp = drop_privileges(false);
a1044 6
		if (dp == EX_OK && UseMSP && (geteuid() == 0 || getuid() == 0))
		{
			usrerr("Mail submission program must have RunAsUser set to non root user");
			finis(false, EX_CONFIG);
			/* NOTREACHED */
		}
d1057 1
a1057 1
	macdefine(&BlankEnvelope.e_macro, A_TEMP, '_', authinfo);
d1060 2
a1061 2
	if (BlankEnvelope.e_errormode != EM_PRINT)
		HoldErrs = true;
d1064 2
a1065 3
	expand("\201m", jbuf, sizeof jbuf, &BlankEnvelope);
	if (jbuf[0] != '\0')
		setclass('m', jbuf);
d1068 1
a1068 1
	if (DontProbeInterfaces != DPI_PROBENONE)
d1073 10
a1082 10
		sm_dprintf("\n============ SYSTEM IDENTITY (after readcf) ============");
		sm_dprintf("\n      (short domain name) $w = ");
		xputs(macvalue('w', &BlankEnvelope));
		sm_dprintf("\n  (canonical domain name) $j = ");
		xputs(macvalue('j', &BlankEnvelope));
		sm_dprintf("\n         (subdomain name) $m = ");
		xputs(macvalue('m', &BlankEnvelope));
		sm_dprintf("\n              (node name) $k = ");
		xputs(macvalue('k', &BlankEnvelope));
		sm_dprintf("\n========================================================\n\n");
d1092 2
a1093 2
		auth_warning(&BlankEnvelope, "Processed by %s with -C %s",
			     RealUserName, conffile);
d1095 1
a1095 6
		auth_warning(&BlankEnvelope, "Processed from queue %s",
			     QueueDir);
	if (sysloglabel != NULL && !wordinclass(RealUserName, 't') &&
	    RealUid != 0 && RealUid != TrustedUid && LogLevel > 1)
		sm_syslog(LOG_WARNING, NOQID, "user %d changed syslog label",
			  (int) RealUid);
d1098 1
a1098 1
	if (BlankEnvelope.e_bodytype == NULL)
d1101 4
a1104 4
	else if (sm_strcasecmp(BlankEnvelope.e_bodytype, "7BIT") == 0)
		SevenBitInput = true;
	else if (sm_strcasecmp(BlankEnvelope.e_bodytype, "8BITMIME") == 0)
		SevenBitInput = false;
d1107 2
a1108 2
		usrerr("Illegal body type %s", BlankEnvelope.e_bodytype);
		BlankEnvelope.e_bodytype = NULL;
d1123 1
a1123 1
		       ConfigLevel, Version, MAXCONFIGLEVEL);
d1130 1
a1130 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: HostStatusDirectory disabled with ConnectionCacheSize = 0\n");
d1136 2
a1137 3
		SingleThreadDelivery = false;
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: HostStatusDirectory required for SingleThreadDelivery\n");
d1141 4
a1144 1
	if (RealUid != 0 &&
d1147 20
a1166 119
		char *action = NULL;

		switch (OpMode)
		{
		  case MD_QUEUERUN:
			/* Normal users can do a single queue run */
			if (QueueIntvl == 0)
				break;

			/* but not persistent queue runners */
			if (action == NULL)
				action = "start a queue runner daemon";
			/* FALLTHROUGH */

		  case MD_PURGESTAT:
			if (action == NULL)
				action = "purge host status";
			/* FALLTHROUGH */

		  case MD_DAEMON:
		  case MD_FGDAEMON:
			if (action == NULL)
				action = "run daemon";

			if (tTd(65, 1))
				sm_dprintf("Deny user %d attempt to %s\n",
					   (int) RealUid, action);

			if (LogLevel > 1)
				sm_syslog(LOG_ALERT, NOQID,
					  "user %d attempted to %s",
					  (int) RealUid, action);
			usrerr("Permission denied (real uid not trusted)");
			finis(false, EX_USAGE);
			/* NOTREACHED */
			break;

		  case MD_VERIFY:
			if (bitset(PRIV_RESTRICTEXPAND, PrivacyFlags))
			{
				/*
				**  If -bv and RestrictExpand,
				**  drop privs to prevent normal
				**  users from reading private
				**  aliases/forwards/:include:s
				*/

				if (tTd(65, 1))
					sm_dprintf("Drop privs for user %d attempt to expand (RestrictExpand)\n",
						   (int) RealUid);

				dp = drop_privileges(true);

				/* Fake address safety */
				if (tTd(65, 1))
					sm_dprintf("Faking DontBlameSendmail=NonRootSafeAddr\n");
				setbitn(DBS_NONROOTSAFEADDR, DontBlameSendmail);

				if (dp != EX_OK)
				{
					if (tTd(65, 1))
						sm_dprintf("Failed to drop privs for user %d attempt to expand, exiting\n",
							   (int) RealUid);
					CurEnv->e_id = NULL;
					finis(true, dp);
					/* NOTREACHED */
				}
			}
			break;

		  case MD_TEST:
		  case MD_PRINT:
		  case MD_PRINTNQE:
		  case MD_FREEZE:
		  case MD_HOSTSTAT:
			/* Nothing special to check */
			break;

		  case MD_INITALIAS:
			if (!wordinclass(RealUserName, 't'))
			{
				if (tTd(65, 1))
					sm_dprintf("Deny user %d attempt to rebuild the alias map\n",
						   (int) RealUid);
				if (LogLevel > 1)
					sm_syslog(LOG_ALERT, NOQID,
						  "user %d attempted to rebuild the alias map",
						  (int) RealUid);
				usrerr("Permission denied (real uid not trusted)");
				finis(false, EX_USAGE);
				/* NOTREACHED */
			}
			if (UseMSP)
			{
				usrerr("User %d cannot rebuild aliases in mail submission program",
				       (int) RealUid);
				finis(false, EX_USAGE);
				/* NOTREACHED */
			}
			/* FALLTHROUGH */

		  default:
			if (bitset(PRIV_RESTRICTEXPAND, PrivacyFlags) &&
			    Verbose != 0)
			{
				/*
				**  If -v and RestrictExpand, reset
				**  Verbose to prevent normal users
				**  from seeing the expansion of
				**  aliases/forwards/:include:s
				*/

				if (tTd(65, 1))
					sm_dprintf("Dropping verbosity for user %d (RestrictExpand)\n",
						   (int) RealUid);
				Verbose = 0;
			}
			break;
		}
d1179 2
a1180 2
		BlankEnvelope.e_errormode = EM_PRINT;
		HoldErrs = false;
d1184 2
a1185 2
		BlankEnvelope.e_errormode = EM_PRINT;
		HoldErrs = false;
d1187 2
a1188 5
		if (sm_signal(SIGHUP, SIG_IGN) == (sigfunc_t) SIG_DFL)
			(void) sm_signal(SIGHUP, intsig);
		if (geteuid() != 0)
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Notice: -bv may give misleading output for non-privileged user\n");
d1192 2
a1193 2
		run_in_foreground = true;
		set_op_mode(MD_DAEMON);
d1197 1
a1197 1
		vendor_daemon_setup(&BlankEnvelope);
d1201 1
a1201 1
		GrabTo = false;
d1207 4
d1215 2
a1216 2
		BlankEnvelope.e_errormode = EM_PRINT;
		HoldErrs = false;
d1221 2
a1222 2
		if (sm_signal(SIGHUP, SIG_IGN) == (sigfunc_t) SIG_DFL)
			(void) sm_signal(SIGHUP, intsig);
d1234 1
a1234 2
			full = newstr(denlstring(FullName, true, true));
			FullName = full;
a1235 1

d1244 1
a1244 2

			FullName = addquotes(FullName, NULL);
d1246 1
a1246 1
				sm_free(full);  /* XXX */
d1254 1
a1254 1
		setoption('c', "F", true, false, &BlankEnvelope);
d1257 1
a1257 1
		setoption('d', "", true, false, &BlankEnvelope);
d1277 1
a1277 1
		UseErrorsTo = true;
d1282 1
a1282 2
		if (ConfigLevel < 7 &&
		    (p = macvalue('e', &BlankEnvelope)) != NULL)
d1289 1
a1289 2
		if (ConfigLevel < 7 &&
		    (p = macvalue('l', &BlankEnvelope)) != NULL)
d1297 3
a1299 6
	expand("\201j", jbuf, sizeof jbuf, &BlankEnvelope);
	if (jbuf[0] == '\0')
		PSTRSET(MyHostName, "localhost");
	else
		PSTRSET(MyHostName, jbuf);
	if (strchr(MyHostName, '.') == NULL)
d1301 1
a1301 1
			MyHostName);
a1305 7
	/* fill in the structure of the *default* queue */
	st = stab("mqueue", ST_QUEUE, ST_FIND);
	if (st == NULL)
		syserr("No default queue (mqueue) defined");
	else
		set_def_queueval(st->s_quegrp, true);

d1385 2
a1386 2
	setclass(macid("{checkMIMEFieldHeaders}"), "content-disposition");
	setclass(macid("{checkMIMEFieldHeaders}"), "content-type");
d1389 1
a1389 1
	setclass(macid("{checkMIMETextHeaders}"), "content-description");
d1392 5
a1396 5
	setclass(macid("{checkMIMEHeaders}"), "content-disposition");
	setclass(macid("{checkMIMEHeaders}"), "content-id");
	setclass(macid("{checkMIMEHeaders}"), "content-transfer-encoding");
	setclass(macid("{checkMIMEHeaders}"), "content-type");
	setclass(macid("{checkMIMEHeaders}"), "mime-version");
d1399 6
a1404 5
	setclass(macid("{persistentMacros}"), "r");
	setclass(macid("{persistentMacros}"), "s");
	setclass(macid("{persistentMacros}"), "_");
	setclass(macid("{persistentMacros}"), "{if_addr}");
	setclass(macid("{persistentMacros}"), "{daemon_flags}");
d1407 1
a1407 1
	if (QueueDir == NULL || *QueueDir == '\0')
d1417 6
d1424 1
a1424 1
			setup_queues(OpMode == MD_DAEMON);
d1428 1
a1428 1
	if (HostStatDir != NULL && !path_is_dir(HostStatDir, false))
d1432 2
a1433 2
			sm_dprintf("Cannot use HostStatusDirectory = %s: %s\n",
				   HostStatDir, sm_errstring(errno));
d1437 3
a1439 2
	if (OpMode == MD_QUEUERUN &&
	    RealUid != 0 && bitset(PRIV_RESTRICTQRUN, PrivacyFlags))
d1450 1
a1450 2
			finis(false, EX_NOPERM);
			/* NOTREACHED */
d1453 1
d1455 1
a1455 1
#if MILTER
d1458 3
a1460 7
	{
		milter_config(InputFilterList, InputFilters, MAXFILTERS);
# if _FFR_MILTER_PERDAEMON
		setup_daemon_milters();
# endif /* _FFR_MILTER_PERDAEMON */
	}
#endif /* MILTER */
d1464 1
a1464 9
	{
		finis(false, ExitStat);
		/* NOTREACHED */
	}

#if SASL
	/* sendmail specific SASL initialization */
	sm_sasl_init();
#endif /* SASL */
d1478 3
a1480 2
		dropenvelope(&BlankEnvelope, true, false);
		(void) sm_signal(SIGPIPE, sigpipe);
d1482 5
a1486 11
		finis(false, EX_OK);
		/* NOTREACHED */
		break;

	  case MD_PRINTNQE:
		/* print number of entries in queue */
		dropenvelope(&BlankEnvelope, true, false);
		(void) sm_signal(SIGPIPE, sigpipe);
		printnqe(smioout, NULL);
		finis(false, EX_OK);
		/* NOTREACHED */
d1490 1
a1490 1
		(void) sm_signal(SIGPIPE, sigpipe);
d1492 1
a1492 2
		finis(false, EX_OK);
		/* NOTREACHED */
d1497 1
a1497 2
		finis(false, EX_OK);
		/* NOTREACHED */
d1503 1
a1503 2
		finis(false, ExitStat);
		/* NOTREACHED */
d1510 5
a1514 8
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			  macid("{dsn_notify}"), NULL);
		BlankEnvelope.e_envid = NULL;
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			  macid("{dsn_envid}"), NULL);
		BlankEnvelope.e_flags &= ~(EF_RET_PARAM|EF_NO_BODY_RETN);
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			  macid("{dsn_ret}"), NULL);
d1536 1
a1536 2
	CurEnv = newenvelope(&MainEnvelope, &BlankEnvelope,
			     sm_rpool_new_x(NULL));
d1545 12
a1556 1
		if (isatty(sm_io_getinfo(smioin, SM_IO_WHAT_FD, NULL)))
d1561 2
a1562 4
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)\n");
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Enter <ruleset> <address>\n");
d1564 3
d1569 11
a1579 34
			SM_TRY
			{
				(void) sm_signal(SIGINT, intindebug);
				if (Verbose == 2)
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "> ");
				(void) sm_io_flush(smioout, SM_TIME_DEFAULT);
				if (sm_io_fgets(smioin, SM_TIME_DEFAULT, buf,
						sizeof buf) == NULL)
					testmodeline("/quit", &MainEnvelope);
				p = strchr(buf, '\n');
				if (p != NULL)
					*p = '\0';
				if (Verbose < 2)
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "> %s\n", buf);
				testmodeline(buf, &MainEnvelope);
			}
			SM_EXCEPT(exc, "[!F]*")
			{
				/*
				**  8.10 just prints \n on interrupt.
				**  I'm printing the exception here in case
				**  sendmail is extended to raise additional
				**  exceptions in this context.
				*/

				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "\n");
				sm_exc_print(exc, smioout);
			}
			SM_END_TRY
d1583 12
a1594 17
#if STARTTLS
	tls_ok = true;
	if (OpMode == MD_QUEUERUN || OpMode == MD_DELIVER)
	{
		/* check whether STARTTLS is turned off for the client */
		if (chkclientmodifiers(D_NOTLS))
			tls_ok = false;
	}
	else if (OpMode == MD_DAEMON || OpMode == MD_FGDAEMON ||
		 OpMode == MD_SMTP)
	{
		/* check whether STARTTLS is turned off for the server */
		if (chkdaemonmodifiers(D_NOTLS))
			tls_ok = false;
	}
	else	/* other modes don't need STARTTLS */
		tls_ok = false;
d1596 2
a1597 5
	if (tls_ok)
	{
		/* basic TLS initialization */
		tls_ok = init_tls_library();
	}
d1599 2
a1600 6
	if (!tls_ok && (OpMode == MD_QUEUERUN || OpMode == MD_DELIVER))
	{
		/* disable TLS for client */
		setclttls(false);
	}
#endif /* STARTTLS */
d1602 1
d1609 12
a1620 88
		int qgrp = NOQGRP;
		pid_t pid = -1;

#if STARTTLS
		/* init TLS for client, ignore result for now */
		(void) initclttls(tls_ok);
#endif /* STARTTLS */

		if (runqueuegroup != NULL)
		{
			/* Selecting a particular queue group to run */
			qgrp = name2qid(runqueuegroup);
			if (qgrp == NOQGRP)
			{
				usrerr("Queue group %s unknown",
					runqueuegroup);
				finis(true, ExitStat);
				/* NOTREACHED */
			}
		}

		/*
		**  The parent process of the caller of runqueue() needs
		**  to stay around for a possible SIGTERM. The SIGTERM will
		**  tell this process that all of the queue runners children
		**  need to be sent SIGTERM as well. At the same time, we
		**  want to return control to the command line. So we do an
		**  extra fork().
		*/

		if (Verbose || foregroundqueue || (pid = fork()) <= 0)
		{
			/*
			**  If the fork() failed we should still try to do
			**  the queue run. If it succeeded then the child
			**  is going to start the run and wait for all
			**  of the children to finish.
			*/

			if (pid == 0)
			{
				/* Reset global flags */
				RestartRequest = NULL;
				ShutdownRequest = NULL;
				PendingSignal = 0;

				/* disconnect from terminal */
				disconnect(2, CurEnv);
			}

			CurrentPid = getpid();
			if (qgrp != NOQGRP)
			{
				/*
				**  To run a specific queue group mark it to
				**  be run, select the work group it's in and
				**  increment the work counter.
				*/

				runqueueevent(qgrp);
				(void) run_work_group(Queue[qgrp]->qg_wgrp,
						      false, Verbose,
						      queuepersistent, false);
			}
			else
				(void) runqueue(false, Verbose,
						queuepersistent, true);

			/* set the title to make it easier to find */
			sm_setproctitle(true, CurEnv, "Queue control");
			(void) sm_signal(SIGCHLD, SIG_DFL);
			while (CurChildren > 0)
			{
				int status;
				pid_t ret;

				while ((ret = sm_wait(&status)) <= 0)
					continue;

				/* Only drop when a child gives status */
				if (WIFSTOPPED(status))
					continue;

				(void) proc_list_drop(ret, NULL, NULL);
			}
		}
		finis(true, ExitStat);
		/* NOTREACHED */
d1622 1
d1627 2
a1628 3
		/* check whether AUTH is turned off for the server */
		if (!chkdaemonmodifiers(D_NOAUTH) &&
		    (i = sasl_server_init(srvcallbacks, "Sendmail")) != SASL_OK)
d1630 1
a1630 1
				sasl_errstring(i, NULL, NULL));
d1654 1
a1654 18
			{
				finis(false, EX_OK);
				/* NOTREACHED */
			}

			/*
			**  Initialize exception stack and default exception
			**  handler for child process.
			*/

			/* Reset global flags */
			RestartRequest = NULL;
			RestartWorkGroup = false;
			ShutdownRequest = NULL;
			PendingSignal = 0;
			CurrentPid = getpid();

			sm_exc_newthread(fatal_error);
d1657 1
a1657 1
			disconnect(2, &MainEnvelope);
d1662 1
a1662 4
		{
			(void) sm_strlcat(dtype, "+SMTP", sizeof dtype);
			DaemonPid = CurrentPid;
		}
d1665 3
a1667 6
			(void) sm_strlcat2(dtype,
					   queuepersistent
					   ? "+persistent-queueing@@"
					   : "+queueing@@",
					   pintvl(QueueIntvl, true),
					   sizeof dtype);
d1670 1
a1670 1
			(void) sm_strlcat(dtype, "+debugging", sizeof dtype);
d1674 1
a1674 1
#if XLA
d1679 2
a1680 2
		macdefine(&BlankEnvelope.e_macro, A_TEMP,
			macid("{daemon_info}"), dtype + 1);
d1683 2
a1684 7
		macdefine(&MainEnvelope.e_macro, A_TEMP,
			macid("{queue_interval}"), pintvl(QueueIntvl, true));

		/* workaround: can't seem to release the signal in the parent */
		(void) sm_signal(SIGHUP, sighup);
		(void) sm_releasesignal(SIGHUP);
		(void) sm_signal(SIGTERM, sigterm);
d1686 1
d1689 2
a1690 10
			(void) runqueue(true, false, queuepersistent, true);

			/*
			**  If queuepersistent but not in daemon mode then
			**  we're going to do the queue runner monitoring here.
			**  If in daemon mode then the monitoring will happen
			**  elsewhere.
			*/

			if (OpMode != MD_DAEMON && queuepersistent)
d1692 2
a1693 84
				/* set the title to make it easier to find */
				sm_setproctitle(true, CurEnv, "Queue control");
				(void) sm_signal(SIGCHLD, SIG_DFL);
				while (CurChildren > 0)
				{
					int status;
					pid_t ret;
					int group;

					if (ShutdownRequest != NULL)
						shutdown_daemon();
					else if (RestartRequest != NULL)
						restart_daemon();
					else if (RestartWorkGroup)
						restart_marked_work_groups();

					while ((ret = sm_wait(&status)) <= 0)
						continue;

					if (WIFSTOPPED(status))
						continue;

					/* Probe only on a child status */
					(void) proc_list_drop(ret, NULL,
							      &group);

					if (WIFSIGNALED(status))
					{
						if (WCOREDUMP(status))
						{
							sm_syslog(LOG_ERR, NOQID,
								  "persistent queue runner=%d core dumped, signal=%d",
								  group, WTERMSIG(status));

							/* don't restart this one */
							continue;
						}

						sm_syslog(LOG_ERR, NOQID,
							  "persistent queue runner=%d died, signal=%d",
							  group, WTERMSIG(status));
					}

					/*
					**  When debugging active, don't
					**  restart the persistent queues.
					**  But do log this as info.
					*/

					if (sm_debug_active(&DebugNoPRestart,
							    1))
					{
						sm_syslog(LOG_DEBUG, NOQID,
							  "persistent queue runner=%d, exited",
							  group);
						continue;
					}

					/* restart this persistent runner */
					mark_work_group_restart(group, status);
				}
				finis(true, ExitStat);
				/* NOTREACHED */
			}

			if (OpMode != MD_DAEMON)
			{
				char qtype[200];

				/*
				**  Write the pid to file
				**  XXX Overwrites sendmail.pid
				*/

				log_sendmail_pid(&MainEnvelope);

				/* set the title to make it easier to find */
				qtype[0] = '\0';
				(void) sm_strlcpyn(qtype, sizeof qtype, 4,
						   "Queue runner@@",
						   pintvl(QueueIntvl, true),
						   " for ",
						   QueueDir);
				sm_setproctitle(true, CurEnv, qtype);
d1697 2
a1698 10
					if (ShutdownRequest != NULL)
						shutdown_daemon();
					else if (RestartRequest != NULL)
						restart_daemon();
					else if (RestartWorkGroup)
						restart_marked_work_groups();

					if (doqueuerun())
						(void) runqueue(true, false,
								false, false);
d1702 2
a1703 1
		dropenvelope(&MainEnvelope, true, false);
d1705 2
a1706 1
#if STARTTLS
d1708 3
a1710 6
		(void) initsrvtls(tls_ok);
#endif /* STARTTLS */
#if PROFILING
	nextreq:
#endif /* PROFILING */
		p_flags = getrequests(&MainEnvelope);
d1713 4
a1716 1
		(void) drop_privileges(false);
a1719 1
		**  Set _ macro in BlankEnvelope before calling newenvelope().
d1722 3
a1724 8
		authinfo = getauthinfo(sm_io_getinfo(InChannel, SM_IO_WHAT_FD,
						     NULL), &forged);
		macdefine(&BlankEnvelope.e_macro, A_TEMP, '_', authinfo);

		/* at this point we are in a child: reset state */
		sm_rpool_free(MainEnvelope.e_rpool);
		(void) newenvelope(&MainEnvelope, &MainEnvelope,
				   sm_rpool_new_x(NULL));
d1733 1
d1751 6
a1756 4
			(void) sm_snprintf(ipbuf, sizeof ipbuf, "[%.100s]",
					   anynet_ntoa(&RealHostAddr));
			macdefine(&BlankEnvelope.e_macro, A_TEMP,
				  macid("{client_name}"), ipbuf);
d1759 5
a1763 5
			macdefine(&BlankEnvelope.e_macro, A_PERM,
				  macid("{client_name}"), RealHostName);
		macdefine(&BlankEnvelope.e_macro, A_TEMP,
			  macid("{client_addr}"), anynet_ntoa(&RealHostAddr));
		sm_getla();
d1765 1
a1765 1
		switch (RealHostAddr.sa.sa_family)
d1767 1
a1767 1
#if NETINET
d1769 2
a1770 2
			(void) sm_snprintf(pbuf, sizeof pbuf, "%d",
					   RealHostAddr.sin.sin_port);
d1772 2
a1773 2
#endif /* NETINET */
#if NETINET6
d1775 2
a1776 2
			(void) sm_snprintf(pbuf, sizeof pbuf, "%d",
					   RealHostAddr.sin6.sin6_port);
d1778 1
a1778 1
#endif /* NETINET6 */
d1780 1
a1780 1
			(void) sm_snprintf(pbuf, sizeof pbuf, "0");
d1783 2
a1784 2
		macdefine(&BlankEnvelope.e_macro, A_TEMP,
			macid("{client_port}"), pbuf);
d1789 1
a1789 1
			HoldErrs = true;
d1791 2
a1792 3
							 RealHostName,
							 &MainEnvelope);
			HoldErrs = false;
d1799 1
a1799 1
#if STARTTLS
d1801 3
a1803 2
			(void) initsrvtls(tls_ok);
#endif /* STARTTLS */
d1805 1
a1805 9
		/* turn off profiling */
		SM_PROF(1);
		smtp(nullserver, *p_flags, &MainEnvelope);
#if PROFILING
		/* turn off profiling */
		SM_PROF(0);
		if (OpMode == MD_DAEMON)
			goto nextreq;
#endif /* PROFILING */
d1807 1
d1809 1
a1809 2
	sm_rpool_free(MainEnvelope.e_rpool);
	clearenvelope(&MainEnvelope, false, sm_rpool_new_x(NULL));
d1812 1
a1812 1
		set_delivery_mode(SM_VERIFY, &MainEnvelope);
d1818 1
a1818 1
		MainEnvelope.e_flags |= EF_GLOBALERRS|EF_LOGSENDER;
d1825 3
a1827 4
	initsys(&MainEnvelope);
	macdefine(&MainEnvelope.e_macro, A_PERM, macid("{ntries}"), "0");
	macdefine(&MainEnvelope.e_macro, A_PERM, macid("{nrcpts}"), "0");
	setsender(from, &MainEnvelope, NULL, '\0', false);
d1829 2
a1830 2
	    (!bitnset(M_LOCALMAILER, MainEnvelope.e_from.q_mailer->m_flags) ||
	     strcmp(MainEnvelope.e_from.q_user, RealUserName) != 0))
d1832 2
a1833 2
		auth_warning(&MainEnvelope, "%s set sender to %s using -%c",
			     RealUserName, from, warn_f_flag);
d1835 1
a1835 1
		auth = false;
d1843 1
a1843 1
		fv = macvalue('f', &MainEnvelope);
d1845 1
a1845 1
			MainEnvelope.e_auth_param = NULL;
d1850 5
a1854 6
				i = strlen(fv) + strlen(macvalue('j',
							&MainEnvelope)) + 2;
				p = sm_malloc_x(i);
				(void) sm_strlcpyn(p, i, 3, fv, "@@",
						   macvalue('j',
							    &MainEnvelope));
d1857 2
a1858 4
				p = sm_strdup_x(fv);
			MainEnvelope.e_auth_param = sm_rpool_strdup_x(MainEnvelope.e_rpool,
								      xtextify(p, "="));
			sm_free(p);  /* XXX */
d1861 2
a1862 2
	if (macvalue('s', &MainEnvelope) == NULL)
		macdefine(&MainEnvelope.e_macro, A_PERM, 's', RealHostName);
d1866 3
a1868 4
		MainEnvelope.e_to = NULL;
		MainEnvelope.e_flags |= EF_GLOBALERRS;
		HoldErrs = false;
		SuperSafe = SAFE_NO;
d1873 2
a1874 3
			collect(InChannel, false, NULL, &MainEnvelope);
		finis(true, EX_USAGE);
		/* NOTREACHED */
d1881 1
a1881 1
	sendtoargv(av, &MainEnvelope);
d1897 1
a1897 1
		for (q = MainEnvelope.e_sendqueue; q != NULL; q = q->q_next)
d1906 1
a1906 1
	MainEnvelope.e_to = NULL;
d1910 1
a1910 1
		long savedflags = MainEnvelope.e_flags & EF_FATALERRS;
d1912 2
a1913 2
		MainEnvelope.e_flags |= EF_GLOBALERRS;
		MainEnvelope.e_flags &= ~EF_FATALERRS;
d1916 1
a1916 1
		collect(InChannel, false, NULL, &MainEnvelope);
d1921 19
a1939 6
			if (!GrabTo)
			{
				/* Log who the mail would have gone to */
				logundelrcpts(&MainEnvelope,
					      MainEnvelope.e_message,
					      8, false);
d1941 2
a1942 2
			flush_errors(true);
			finis(true, ExitStat);
d1948 1
a1948 1
		if (bitset(EF_CLRQUEUE, MainEnvelope.e_flags))
d1950 1
a1950 1
			finis(true, ExitStat != EX_OK ? ExitStat : EX_DATAERR);
d1955 1
a1955 1
		MainEnvelope.e_flags |= savedflags;
d1960 1
a1960 2
		sm_dprintf("From person = \"%s\"\n",
			   MainEnvelope.e_from.q_paddr);
d1967 2
a1968 6
	if (Errors == 0)
		split_by_recipient(&MainEnvelope);

	/* make sure we deliver at least the first envelope */
	i = FastSplit > 0 ? 0 : -1;
	for (e = &MainEnvelope; e != NULL; e = e->e_sibling, i++)
d1970 6
a1975 11
		ENVELOPE *next;

		e->e_from.q_state = QS_SENDER;
		if (tTd(1, 5))
		{
			sm_dprintf("main[%d]: QS_SENDER ", i);
			printaddr(&e->e_from, false);
		}
		e->e_to = NULL;
		sm_getla();
		GrabTo = false;
d1977 2
a1978 2
		_res.retry = TimeOuts.res_retry[RES_TO_FIRST];
		_res.retrans = TimeOuts.res_retrans[RES_TO_FIRST];
d1980 1
a1980 7
		next = e->e_sibling;
		e->e_sibling = NULL;

		/* after FastSplit envelopes: queue up */
		sendall(e, i >= FastSplit ? SM_QUEUE : SM_DEFAULT);
		e->e_sibling = next;
	}
d1987 1
a1987 1
	finis(true, ExitStat);
a1990 12
/*
**  STOP_SENDMAIL -- Stop the running program
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		exits.
*/
d1992 13
a2004 2
void
stop_sendmail()
d2006 2
a2007 4
	/* reset uid for process accounting */
	endpwent();
	(void) setuid(RealUid);
	exit(EX_OK);
a2027 3
	/* Still want to process new timeouts added below */
	sm_clear_events();
	(void) sm_releasesignal(SIGALRM);
d2031 3
a2033 3
		sm_dprintf("\n====finis: stat %d e_id=%s e_flags=",
			   exitstat,
			   CurEnv->e_id == NULL ? "NOQUEUE" : CurEnv->e_id);
d2037 1
a2037 1
		printopenfds(false);
d2039 6
a2044 4
	SM_TRY
		/*
		**  Clean up.  This might raise E:mta.quickabort
		*/
d2046 9
a2054 13
		/* clean up temp files */
		CurEnv->e_to = NULL;
		if (drop)
		{
			if (CurEnv->e_id != NULL)
			{
				dropenvelope(CurEnv, true, false);
				sm_rpool_free(CurEnv->e_rpool);
				CurEnv->e_rpool = NULL;
			}
			else
				poststats(StatFile);
		}
d2056 2
a2057 2
		/* flush any cached connections */
		mci_flush(true, NULL);
d2059 2
a2060 2
		/* close maps belonging to this pid */
		closemaps(false);
d2063 2
a2064 2
		/* close UserDatabase */
		_udbx_close();
d2067 3
a2069 7
#if SASL
		stop_sasl_client();
#endif /* SASL */

#if XLA
		/* clean up extended load average stuff */
		xla_all_end();
d2072 8
a2079 49
	SM_FINALLY
		/*
		**  And exit.
		*/

		if (LogLevel > 78)
			sm_syslog(LOG_DEBUG, CurEnv->e_id, "finis, pid=%d",
				  (int) CurrentPid);
		if (exitstat == EX_TEMPFAIL ||
		    CurEnv->e_errormode == EM_BERKNET)
			exitstat = EX_OK;

		/* XXX clean up queues and related data structures */
		cleanup_queues();
#if SM_CONF_SHM
		cleanup_shm(DaemonPid == getpid());
#endif /* SM_CONF_SHM */

		/* reset uid for process accounting */
		endpwent();
		sm_mbdb_terminate();
		(void) setuid(RealUid);
#if SM_HEAP_CHECK
		/* dump the heap, if we are checking for memory leaks */
		if (sm_debug_active(&SmHeapCheck, 2))
			sm_heap_report(smioout,
				       sm_debug_level(&SmHeapCheck) - 1);
#endif /* SM_HEAP_CHECK */
		if (sm_debug_active(&SmXtrapReport, 1))
			sm_dprintf("xtrap count = %d\n", SmXtrapCount);
		exit(exitstat);
	SM_END_TRY
}
/*
**  INTINDEBUG -- signal handler for SIGINT in -bt mode
**
**	Parameters:
**		sig -- incoming signal.
**
**	Returns:
**		none.
**
**	Side Effects:
**		longjmps back to test mode loop.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/
d2081 1
a2081 9
/* Type of an exception generated on SIGINT during address test mode.  */
static const SM_EXC_TYPE_T EtypeInterrupt =
{
	SmExcTypeMagic,
	"S:mta.interrupt",
	"",
	sm_etype_printf,
	"interrupt",
};
d2083 4
a2086 104
/* ARGSUSED */
static SIGFUNC_DECL
intindebug(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, intindebug);
	errno = save_errno;
	CHECK_CRITICAL(sig);
	errno = save_errno;
	sm_exc_raisenew_x(&EtypeInterrupt);
	errno = save_errno;
	return SIGFUNC_RETURN;
}
/*
**  SIGTERM -- SIGTERM handler for the daemon
**
**	Parameters:
**		sig -- signal number.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets ShutdownRequest which will hopefully trigger
**		the daemon to exit.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

/* ARGSUSED */
static SIGFUNC_DECL
sigterm(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, sigterm);
	ShutdownRequest = "signal";
	errno = save_errno;
	return SIGFUNC_RETURN;
}
/*
**  SIGHUP -- handle a SIGHUP signal
**
**	Parameters:
**		sig -- incoming signal.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets RestartRequest which should cause the daemon
**		to restart.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

/* ARGSUSED */
static SIGFUNC_DECL
sighup(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, sighup);
	RestartRequest = "signal";
	errno = save_errno;
	return SIGFUNC_RETURN;
}
/*
**  SIGPIPE -- signal handler for SIGPIPE
**
**	Parameters:
**		sig -- incoming signal.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets StopRequest which should cause the mailq/hoststatus
**		display to stop.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

/* ARGSUSED */
static SIGFUNC_DECL
sigpipe(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, sigpipe);
	StopRequest = true;
	errno = save_errno;
	return SIGFUNC_RETURN;
a2101 6
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
**
**		XXX: More work is needed for this signal handler.
d2109 1
a2109 7
	bool drop = false;
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, intsig);
	errno = save_errno;
	CHECK_CRITICAL(sig);
	sm_allsignals(true);
d2111 1
d2115 4
d2141 5
a2145 1
		drop = true;
d2147 58
a2204 1
	else if (OpMode != MD_TEST)
d2206 10
a2215 1
		unlockqueue(CurEnv);
d2218 6
a2223 2
	finis(drop, EX_OK);
	/* NOTREACHED */
d2253 2
a2254 3
		sm_dprintf("disconnect: In %d Out %d, e=%p\n",
			   sm_io_getinfo(InChannel, SM_IO_WHAT_FD, NULL),
			   sm_io_getinfo(OutChannel, SM_IO_WHAT_FD, NULL), e);
d2257 1
a2257 1
		sm_dprintf("don't\n");
d2266 2
a2267 2
	(void) sm_signal(SIGINT, SIG_IGN);
	(void) sm_signal(SIGQUIT, SIG_IGN);
d2270 1
a2270 1
	HoldErrs = true;
d2273 1
a2273 1
	DisConnected = true;
d2276 1
a2276 1
	if (InChannel != smioin)
d2278 2
a2279 2
		(void) sm_io_close(InChannel, SM_TIME_DEFAULT);
		InChannel = smioin;
d2281 1
a2281 2
	if (sm_io_reopen(SmFtStdio, SM_TIME_DEFAULT, SM_PATH_DEVNULL,
			 SM_IO_RDONLY, NULL, smioin) == NULL)
d2283 2
a2284 9
			  "disconnect: sm_io_reopen(\"%s\") failed: %s",
			  SM_PATH_DEVNULL, sm_errstring(errno));

	/*
	**  output to the transcript
	**	We also compare the fd numbers here since OutChannel
	**	might be a layer on top of smioout due to encryption
	**	(see sfsasl.c).
	*/
d2286 2
a2287 3
	if (OutChannel != smioout &&
	    sm_io_getinfo(OutChannel, SM_IO_WHAT_FD, NULL) !=
	    sm_io_getinfo(smioout, SM_IO_WHAT_FD, NULL))
d2289 2
a2290 17
		(void) sm_io_close(OutChannel, SM_TIME_DEFAULT);
		OutChannel = smioout;

#if 0
		/*
		**  Has smioout been closed? Reopen it.
		**	This shouldn't happen anymore, the code is here
		**	just as a reminder.
		*/

		if (smioout->sm_magic == NULL &&
		    sm_io_reopen(SmFtStdio, SM_TIME_DEFAULT, SM_PATH_DEVNULL,
				 SM_IO_WRONLY, NULL, smioout) == NULL)
			sm_syslog(LOG_ERR, e->e_id,
				  "disconnect: sm_io_reopen(\"%s\") failed: %s",
				  SM_PATH_DEVNULL, sm_errstring(errno));
#endif /* 0 */
d2294 1
a2294 1
		fd = open(SM_PATH_DEVNULL, O_WRONLY, 0666);
d2297 3
a2299 3
				  "disconnect: open(\"%s\") failed: %s",
				  SM_PATH_DEVNULL, sm_errstring(errno));
		(void) sm_io_flush(smioout, SM_TIME_DEFAULT);
d2317 3
a2319 2
		sm_syslog(LOG_DEBUG, e->e_id, "in background, pid=%d",
			  (int) CurrentPid);
d2351 1
a2351 1
#define __DEFPATH	"sendmail.cf"
d2355 2
a2356 2
			(void) sm_strlcpyn(argv[0], sizeof(__DEFPATH) + 2, 2,
					   "-C", __DEFPATH);
d2401 1
a2401 1
	SM_VA_LOCAL_DECL
d2413 1
a2413 1
#if NETINET6
d2419 1
a2419 1
#endif /* NETINET6 */
d2422 1
a2422 1
		(void) sm_strlcpyn(buf, sizeof buf, 2, hostbuf, ": ");
d2424 4
a2427 4
		SM_VA_START(ap, msg);
		(void) sm_vsnprintf(p, SPACELEFT(buf, p), msg, ap);
		SM_VA_END(ap);
		addheader("X-Authentication-Warning", buf, 0, e);
d2444 1
a2444 1
static char *
d2460 1
a2460 1
**  SETUSERENV -- set an environment in the propagated environment
d2492 1
a2492 1
	(void) sm_strlcpyn(p, l, 3, envar, "=", value);
d2535 1
a2535 1
	sm_syslog(LOG_DEBUG, CurEnv->e_id, "NextMacroId = %d (Max %d)",
d2538 1
a2538 1
	printopenfds(true);
d2540 1
a2540 1
	mci_dump_all(true);
d2549 1
a2549 1
		status = REWRITE(pv, rs, CurEnv);
a2558 16
#ifdef SIGUSR1
/*
**  SIGUSR1 -- Signal a request to dump state.
**
**	Parameters:
**		sig -- calling signal.
**
**	Returns:
**		none.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
**
**		XXX: More work is needed for this signal handler.
*/
d2561 1
a2561 1
static SIGFUNC_DECL
a2564 8
	int save_errno = errno;
# if SM_HEAP_CHECK
	extern void dumpstab __P((void));
# endif /* SM_HEAP_CHECK */

	FIX_SYSV_SIGNAL(sig, sigusr1);
	errno = save_errno;
	CHECK_CRITICAL(sig);
a2565 4
# if SM_HEAP_CHECK
	dumpstab();
# endif /* SM_HEAP_CHECK */
	errno = save_errno;
d2568 53
a2620 1
#endif /* SIGUSR1 */
d2641 3
a2643 6
		sm_dprintf("drop_privileges(%d): Real[UG]id=%d:%d, get[ug]id=%d:%d, gete[ug]id=%d:%d, RunAs[UG]id=%d:%d\n",
			   (int) to_real_uid,
			   (int) RealUid, (int) RealGid,
			   (int) getuid(), (int) getgid(),
			   (int) geteuid(), (int) getegid(),
			   (int) RunAsUid, (int) RunAsGid);
a2653 1
	sm_mbdb_terminate();
a2656 10

	/*
	**  Notice:  on some OS (Linux...) the setgroups() call causes
	**	a logfile entry if sendmail is not run by root.
	**	However, it is unclear (no POSIX standard) whether
	**	setgroups() can only succeed if executed by root.
	**	So for now we keep it as it is; if you want to change it, use
	**  if (geteuid() == 0 && setgroups(1, emptygidset) == -1)
	*/

d2660 1
a2660 1
		       (int) emptygidset[0]);
d2665 1
a2665 2
	if ((to_real_uid || RunAsGid != 0) && EffGid != RunAsGid &&
	    setgid(RunAsGid) < 0)
d2667 1
a2667 1
		syserr("drop_privileges: setgid(%d) failed", (int) RunAsGid);
d2674 1
a2674 2
		if (setuid(RunAsUid) < 0 ||
		    getuid() != RunAsUid || geteuid() != RunAsUid)
d2676 3
a2678 29
#if HASSETREUID
			/*
			**  if ruid != RunAsUid, euid == RunAsUid, then
			**  try resetting just the real uid, then using
			**  setuid() to drop the saved-uid as well.
			*/

			if (euid == RunAsUid)
			{
				if (setreuid(RunAsUid, -1) < 0)
				{
					syserr("drop_privileges: setreuid(%d, -1) failed",
					       (int) RunAsUid);
					rval = EX_OSERR;
				}
				if (setuid(RunAsUid) < 0)
				{
					syserr("drop_privileges: second setuid(%d) attempt failed",
					       (int) RunAsUid);
					rval = EX_OSERR;
				}
			}
			else
#endif /* HASSETREUID */
			{
				syserr("drop_privileges: setuid(%d) failed",
				       (int) RunAsUid);
				rval = EX_OSERR;
			}
d2680 1
a2680 1
		if (RunAsUid != 0 && setuid(0) == 0)
d2700 1
a2700 1
			syserr("drop_privileges: Unable to drop non-root set-user-ID privileges");
d2706 5
a2710 5
		sm_dprintf("drop_privileges: e/ruid = %d/%d e/rgid = %d/%d\n",
			   (int) geteuid(), (int) getuid(),
			   (int) getegid(), (int) getgid());
		sm_dprintf("drop_privileges: RunAsUser = %d:%d\n",
			   (int) RunAsUid, (int) RunAsGid);
d2712 1
a2712 1
			sm_dprintf("drop_privileges: rval = %d\n", rval);
a2728 3
**
**	Side Effects:
**		possibly changes MissingFds
d2746 1
a2746 1
	i = open(SM_PATH_DEVNULL, fd == 0 ? O_RDONLY : O_WRONLY, 0666);
d2749 2
a2750 2
		syserr("!fill_fd: %s: cannot open %s",
		       where == NULL ? "startup" : where, SM_PATH_DEVNULL);
a2758 35
**  SM_PRINTOPTIONS -- print options
**
**	Parameters:
**		options -- array of options.
**
**	Returns:
**		none.
*/

static void
sm_printoptions(options)
	char **options;
{
	int ll;
	char **av;

	av = options;
	ll = 7;
	while (*av != NULL)
	{
		if (ll + strlen(*av) > 63)
		{
			sm_dprintf("\n");
			ll = 0;
		}
		if (ll == 0)
			sm_dprintf("\t\t");
		else
			sm_dprintf(" ");
		sm_dprintf("%s", *av);
		ll += strlen(*av++) + 1;
	}
	sm_dprintf("\n");
}
/*
d2789 1
a2789 1
	extern unsigned char TokTypeNoC[];
d2791 3
a2793 1
	macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), "e r");
d2813 1
a2813 1
			mid = macid_parse(&line[2], &delimptr);
d2817 1
a2817 1
			macdefine(&e->e_macro, A_TEMP, mid, delimptr);
d2824 1
a2824 1
			mid = macid_parse(&line[2], &delimptr);
d2849 1
a2849 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Usage: .[DC]macro value(s)\n");
d2853 1
a2853 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Unknown \".\" command %s\n", line);
d2865 1
a2865 2
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Undefined ruleset %s\n", &line[2]);
d2873 1
a2873 2
				(void) sm_io_putc(smioout, SM_TIME_DEFAULT,
						  'R');
d2878 1
a2878 2
					(void) sm_io_putc(smioout,
							  SM_TIME_DEFAULT, ' ');
d2880 2
a2881 4
				(void) sm_io_putc(smioout, SM_TIME_DEFAULT,
						  '\t');
				(void) sm_io_putc(smioout, SM_TIME_DEFAULT,
						  '\t');
d2886 1
a2886 2
					(void) sm_io_putc(smioout,
							  SM_TIME_DEFAULT, ' ');
d2888 1
a2888 2
				(void) sm_io_putc(smioout, SM_TIME_DEFAULT,
						  '\n');
d2901 1
a2901 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Usage: =Sruleset or =M\n");
d2905 1
a2905 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Unknown \"=\" command %s\n", line);
d2918 1
a2918 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Usage: -d{debug arguments}\n");
d2922 1
a2922 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Unknown \"-\" command %s\n", line);
d2930 1
a2930 1
			mid = macid(&line[2]);
d2935 1
a2935 1
		mid = macid(&line[1]);
d2940 1
a2940 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Undefined\n");
d2944 1
a2944 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "\n");
d2962 1
a2962 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Usage: /[canon|map|mx|parse|try|tryflags]\n");
d2965 1
a2965 1
		if (sm_strcasecmp(&line[1], "quit") == 0)
d2968 1
a2968 2
			finis(true, ExitStat);
			/* NOTREACHED */
d2970 1
a2970 1
		if (sm_strcasecmp(&line[1], "mx") == 0)
d2980 1
a2980 2
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Usage: /mx address\n");
d2983 2
a2984 5
			nmx = getmxrr(p, mxhosts, NULL, false, &rcode, true,
				      NULL);
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "getmxrr(%s) returns %d value(s):\n",
				p, nmx);
d2986 1
a2986 2
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "\t%s\n", mxhosts[i]);
d2988 1
a2988 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "No MX code compiled in\n");
d2991 1
a2991 1
		else if (sm_strcasecmp(&line[1], "canon") == 0)
d2997 1
a2997 2
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Usage: /canon address\n");
d3000 1
a3000 1
			else if (sm_strlcpy(host, p, sizeof host) >= sizeof host)
d3002 1
a3002 2
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Name too long\n");
d3005 2
a3006 5
			(void) getcanonname(host, sizeof host, HasWildcardMX,
					    NULL);
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "getcanonname(%s) returns %s\n",
					     p, host);
d3008 1
a3008 1
		else if (sm_strcasecmp(&line[1], "map") == 0)
d3015 1
a3015 2
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Usage: /map mapname key\n");
d3018 1
a3018 1
			for (q = p; *q != '\0' && !(isascii(*q) && isspace(*q));			     q++)
d3022 1
a3022 2
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "No key specified\n");
d3029 1
a3029 2
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Map named \"%s\" not found\n", p);
d3035 1
a3035 2
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Map named \"%s\" not open\n", p);
d3038 1
a3038 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "map_lookup: %s (%s) ", p, q);
d3044 1
a3044 3
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "no match (%d)\n",
						     rcode);
d3046 1
a3046 3
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "returns %s (%d)\n", p,
						     rcode);
d3048 1
a3048 1
		else if (sm_strcasecmp(&line[1], "try") == 0)
d3062 1
a3062 2
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Usage: /try mailer address\n");
d3068 1
a3068 2
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Unknown mailer %s\n", p);
d3072 4
a3075 6
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Trying %s %s address %s for mailer %s\n",
				     bitset(RF_HEADERADDR, tryflags) ? "header"
							: "envelope",
				     bitset(RF_SENDERADDR, tryflags) ? "sender"
							: "recipient", q, p);
d3077 2
a3078 3
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Rcode = %d, addr = %s\n",
					     rcode, p == NULL ? "<NULL>" : p);
d3081 1
a3081 1
		else if (sm_strcasecmp(&line[1], "tryflags") == 0)
d3085 1
a3085 2
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Usage: /tryflags [Hh|Ee][Ss|Rr]\n");
d3113 1
d3118 2
a3119 2
			macdefine(&e->e_macro, A_TEMP,
				macid("{addr_type}"), exbuf);
d3121 1
a3121 1
		else if (sm_strcasecmp(&line[1], "parse") == 0)
d3125 1
a3125 2
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Usage: /parse address\n");
d3129 1
a3129 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Cracked address = ");
d3131 5
a3135 10
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "\nParsing %s %s address\n",
					     bitset(RF_HEADERADDR, tryflags) ?
							"header" : "envelope",
					     bitset(RF_SENDERADDR, tryflags) ?
							"sender" : "recipient");
			if (parseaddr(p, &a, tryflags, '\0', NULL, e, true)
			    == NULL)
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Cannot parse\n");
d3137 2
a3138 5
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "mailer %s, host %s, user %s\n",
						     a.q_mailer->m_name,
						     a.q_host,
						     a.q_user);
d3140 2
a3141 4
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "mailer %s, user %s\n",
						     a.q_mailer->m_name,
						     a.q_user);
d3146 1
a3146 3
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Unknown \"/\" command %s\n",
					     line);
d3158 1
a3158 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "No address!\n");
d3162 1
a3162 1
	if (invalidaddr(p + 1, NULL, true))
d3181 1
a3181 3
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Undefined ruleset %s\n",
						     p);
d3184 1
a3184 1
			status = REWRITE(pvp, rs, e);
d3186 2
a3187 3
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "== Ruleset %s (%d) status %d\n",
						     p, rs, status);
d3202 1
a3202 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "%s\n", s->s_name);
a3203 17

/*
**  An exception type used to create QuickAbort exceptions.
**  This is my first cut at converting QuickAbort from longjmp to exceptions.
**  These exceptions have a single integer argument, which is the argument
**  to longjmp in the original code (either 1 or 2).  I don't know the
**  significance of 1 vs 2: the calls to setjmp don't care.
*/

const SM_EXC_TYPE_T EtypeQuickAbort =
{
	SmExcTypeMagic,
	"E:mta.quickabort",
	"i",
	sm_etype_printf,
	"quick abort %0",
};
@


