head	1.20;
access;
symbols
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.20
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.18
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.16
	OPENBSD_5_0:1.17.0.14
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.12
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.10
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.6
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.8
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.4
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.14.0.8
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.6
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2014.09.17.18.49.52;	author matthieu;	state dead;
branches;
next	1.19;
commitid	M7i5giHIoz3DMlTU;

1.19
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.17;

1.17
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2007.04.04.14.43.49;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.16.00.21.31;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.18.04.08.35;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.24.03.59.27;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.19.01.41.14;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.17.17.31.40;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.01.19.59.23;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.03.17.25.47;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.01.17.18.30;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.11.19.02.50;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.29.01.31.16;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.28.02.43.55;	author millert;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.01.15.21.09.09;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.02.19.05.47;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.47;	author millert;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.16;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.50;	author millert;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	2001.05.31.00.31.40;	author miod;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.31.01.47.58;	author jason;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2003, 2006 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>

SM_RCSID("@@(#)$Sendmail: recipient.c,v 8.351 2013/11/22 20:51:56 ca Exp $")

static void	includetimeout __P((int));
static ADDRESS	*self_reference __P((ADDRESS *));
static int	sortexpensive __P((ADDRESS *, ADDRESS *));
static int	sortbysignature __P((ADDRESS *, ADDRESS *));
static int	sorthost __P((ADDRESS *, ADDRESS *));

typedef int	sortfn_t __P((ADDRESS *, ADDRESS *));

/*
**  SORTHOST -- strcmp()-like func for host portion of an ADDRESS
**
**	Parameters:
**		xx -- first ADDRESS
**		yy -- second ADDRESS
**
**	Returns:
**		<0 when xx->q_host is less than yy->q_host
**		>0 when xx->q_host is greater than yy->q_host
**		0 when equal
*/

static int
sorthost(xx, yy)
	register ADDRESS *xx;
	register ADDRESS *yy;
{
#if _FFR_HOST_SORT_REVERSE
	/* XXX maybe compare hostnames from the end? */
	return sm_strrevcasecmp(xx->q_host, yy->q_host);
#else /* _FFR_HOST_SORT_REVERSE */
	return sm_strcasecmp(xx->q_host, yy->q_host);
#endif /* _FFR_HOST_SORT_REVERSE */
}

/*
**  SORTEXPENSIVE -- strcmp()-like func for expensive mailers
**
**  The mailer has been noted already as "expensive" for 'xx'. This
**  will give a result relative to 'yy'. Expensive mailers get rated
**  "greater than" non-expensive mailers because during the delivery phase
**  it will get queued -- no use it getting in the way of less expensive
**  recipients. We avoid an MX RR lookup when both 'xx' and 'yy' are
**  expensive since an MX RR lookup happens when extracted from the queue
**  later.
**
**	Parameters:
**		xx -- first ADDRESS
**		yy -- second ADDRESS
**
**	Returns:
**		<0 when xx->q_host is less than yy->q_host and both are
**			expensive
**		>0 when xx->q_host is greater than yy->q_host, or when
**			'yy' is non-expensive
**		0 when equal (by expense and q_host)
*/

static int
sortexpensive(xx, yy)
	ADDRESS *xx;
	ADDRESS *yy;
{
	if (!bitnset(M_EXPENSIVE, yy->q_mailer->m_flags))
		return 1; /* xx should go later */
#if _FFR_HOST_SORT_REVERSE
	/* XXX maybe compare hostnames from the end? */
	return sm_strrevcasecmp(xx->q_host, yy->q_host);
#else /* _FFR_HOST_SORT_REVERSE */
	return sm_strcasecmp(xx->q_host, yy->q_host);
#endif /* _FFR_HOST_SORT_REVERSE */
}

/*
**  SORTBYSIGNATURE -- a strcmp()-like func for q_mailer and q_host in ADDRESS
**
**	Parameters:
**		xx -- first ADDRESS
**		yy -- second ADDRESS
**
**	Returns:
**		0 when the "signature"'s are same
**		<0 when xx->q_signature is less than yy->q_signature
**		>0 when xx->q_signature is greater than yy->q_signature
**
**	Side Effect:
**		May set ADDRESS pointer for q_signature if not already set.
*/

static int
sortbysignature(xx, yy)
	ADDRESS *xx;
	ADDRESS *yy;
{
	register int ret;

	/* Let's avoid redoing the signature over and over again */
	if (xx->q_signature == NULL)
		xx->q_signature = hostsignature(xx->q_mailer, xx->q_host);
	if (yy->q_signature == NULL)
		yy->q_signature = hostsignature(yy->q_mailer, yy->q_host);
	ret = strcmp(xx->q_signature, yy->q_signature);

	/*
	**  If the two signatures are the same then we will return a sort
	**  value based on 'q_user'. But note that we have reversed xx and yy
	**  on purpose. This additional compare helps reduce the number of
	**  sameaddr() calls and loops in recipient() for the case when
	**  the rcpt list has been provided already in-order.
	*/

	if (ret == 0)
		return strcmp(yy->q_user, xx->q_user);
	else
		return ret;
}

/*
**  SENDTOLIST -- Designate a send list.
**
**	The parameter is a comma-separated list of people to send to.
**	This routine arranges to send to all of them.
**
**	Parameters:
**		list -- the send list.
**		ctladdr -- the address template for the person to
**			send to -- effective uid/gid are important.
**			This is typically the alias that caused this
**			expansion.
**		sendq -- a pointer to the head of a queue to put
**			these people into.
**		aliaslevel -- the current alias nesting depth -- to
**			diagnose loops.
**		e -- the envelope in which to add these recipients.
**
**	Returns:
**		The number of addresses actually on the list.
*/

/* q_flags bits inherited from ctladdr */
#define QINHERITEDBITS	(QPINGONSUCCESS|QPINGONFAILURE|QPINGONDELAY|QHASNOTIFY)

int
sendtolist(list, ctladdr, sendq, aliaslevel, e)
	char *list;
	ADDRESS *ctladdr;
	ADDRESS **sendq;
	int aliaslevel;
	register ENVELOPE *e;
{
	register char *p;
	register ADDRESS *SM_NONVOLATILE al; /* list of addresses to send to */
	SM_NONVOLATILE char delimiter;		/* the address delimiter */
	SM_NONVOLATILE int naddrs;
	SM_NONVOLATILE int i;
	char *endp;
	char *oldto = e->e_to;
	char *SM_NONVOLATILE bufp;
	char buf[MAXNAME + 1];

	if (list == NULL)
	{
		syserr("sendtolist: null list");
		return 0;
	}

	if (tTd(25, 1))
	{
		sm_dprintf("sendto: %s\n   ctladdr=", list);
		printaddr(sm_debug_file(), ctladdr, false);
	}

	/* heuristic to determine old versus new style addresses */
	if (ctladdr == NULL &&
	    (strchr(list, ',') != NULL || strchr(list, ';') != NULL ||
	     strchr(list, '<') != NULL || strchr(list, '(') != NULL))
		e->e_flags &= ~EF_OLDSTYLE;
	delimiter = ' ';
	if (!bitset(EF_OLDSTYLE, e->e_flags) || ctladdr != NULL)
		delimiter = ',';

	al = NULL;
	naddrs = 0;

	/* make sure we have enough space to copy the string */
	i = strlen(list) + 1;
	if (i <= sizeof(buf))
	{
		bufp = buf;
		i = sizeof(buf);
	}
	else
		bufp = sm_malloc_x(i);
	endp = bufp + i;

	SM_TRY
	{
		(void) sm_strlcpy(bufp, denlstring(list, false, true), i);

		macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), "e r");
		for (p = bufp; *p != '\0'; )
		{
			auto char *delimptr;
			register ADDRESS *a;

			SM_ASSERT(p < endp);

			/* parse the address */
			while ((isascii(*p) && isspace(*p)) || *p == ',')
				p++;
			SM_ASSERT(p < endp);
			a = parseaddr(p, NULLADDR, RF_COPYALL, delimiter,
				      &delimptr, e, true);
			p = delimptr;
			SM_ASSERT(p < endp);
			if (a == NULL)
				continue;
			a->q_next = al;
			a->q_alias = ctladdr;

			/* arrange to inherit attributes from parent */
			if (ctladdr != NULL)
			{
				ADDRESS *b;

				/* self reference test */
				if (sameaddr(ctladdr, a))
				{
					if (tTd(27, 5))
					{
						sm_dprintf("sendtolist: QSELFREF ");
						printaddr(sm_debug_file(), ctladdr, false);
					}
					ctladdr->q_flags |= QSELFREF;
				}

				/* check for address loops */
				b = self_reference(a);
				if (b != NULL)
				{
					b->q_flags |= QSELFREF;
					if (tTd(27, 5))
					{
						sm_dprintf("sendtolist: QSELFREF ");
						printaddr(sm_debug_file(), b, false);
					}
					if (a != b)
					{
						if (tTd(27, 5))
						{
							sm_dprintf("sendtolist: QS_DONTSEND ");
							printaddr(sm_debug_file(), a, false);
						}
						a->q_state = QS_DONTSEND;
						b->q_flags |= a->q_flags & QNOTREMOTE;
						continue;
					}
				}

				/* full name */
				if (a->q_fullname == NULL)
					a->q_fullname = ctladdr->q_fullname;

				/* various flag bits */
				a->q_flags &= ~QINHERITEDBITS;
				a->q_flags |= ctladdr->q_flags & QINHERITEDBITS;

				/* DSN recipient information */
				a->q_finalrcpt = ctladdr->q_finalrcpt;
				a->q_orcpt = ctladdr->q_orcpt;
			}

			al = a;
		}

		/* arrange to send to everyone on the local send list */
		while (al != NULL)
		{
			register ADDRESS *a = al;

			al = a->q_next;
			a = recipient(a, sendq, aliaslevel, e);
			naddrs++;
		}
	}
	SM_FINALLY
	{
		e->e_to = oldto;
		if (bufp != buf)
			sm_free(bufp);
		macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), NULL);
	}
	SM_END_TRY
	return naddrs;
}

#if MILTER
/*
**  REMOVEFROMLIST -- Remove addresses from a send list.
**
**	The parameter is a comma-separated list of recipients to remove.
**	Note that it only deletes matching addresses.  If those addresses
**	have been expanded already in the sendq, it won't mark the
**	expanded recipients as QS_REMOVED.
**
**	Parameters:
**		list -- the list to remove.
**		sendq -- a pointer to the head of a queue to remove
**			these addresses from.
**		e -- the envelope in which to remove these recipients.
**
**	Returns:
**		The number of addresses removed from the list.
**
*/

int
removefromlist(list, sendq, e)
	char *list;
	ADDRESS **sendq;
	ENVELOPE *e;
{
	SM_NONVOLATILE char delimiter;		/* the address delimiter */
	SM_NONVOLATILE int naddrs;
	SM_NONVOLATILE int i;
	char *p;
	char *oldto = e->e_to;
	char *SM_NONVOLATILE bufp;
	char buf[MAXNAME + 1];

	if (list == NULL)
	{
		syserr("removefromlist: null list");
		return 0;
	}

	if (tTd(25, 1))
		sm_dprintf("removefromlist: %s\n", list);

	/* heuristic to determine old versus new style addresses */
	if (strchr(list, ',') != NULL || strchr(list, ';') != NULL ||
	    strchr(list, '<') != NULL || strchr(list, '(') != NULL)
		e->e_flags &= ~EF_OLDSTYLE;
	delimiter = ' ';
	if (!bitset(EF_OLDSTYLE, e->e_flags))
		delimiter = ',';

	naddrs = 0;

	/* make sure we have enough space to copy the string */
	i = strlen(list) + 1;
	if (i <= sizeof(buf))
	{
		bufp = buf;
		i = sizeof(buf);
	}
	else
		bufp = sm_malloc_x(i);

	SM_TRY
	{
		(void) sm_strlcpy(bufp, denlstring(list, false, true), i);

#if _FFR_ADDR_TYPE_MODES
		if (AddrTypeModes)
			macdefine(&e->e_macro, A_PERM, macid("{addr_type}"),
				  "e r d");
		else
#endif /* _FFR_ADDR_TYPE_MODES */
		macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), "e r");
		for (p = bufp; *p != '\0'; )
		{
			ADDRESS a;	/* parsed address to be removed */
			ADDRESS *q;
			ADDRESS **pq;
			char *delimptr;

			/* parse the address */
			while ((isascii(*p) && isspace(*p)) || *p == ',')
				p++;
			if (parseaddr(p, &a, RF_COPYALL|RF_RM_ADDR,
				      delimiter, &delimptr, e, true) == NULL)
			{
				p = delimptr;
				continue;
			}
			p = delimptr;
			for (pq = sendq; (q = *pq) != NULL; pq = &q->q_next)
			{
				if (!QS_IS_DEAD(q->q_state) &&
				    (sameaddr(q, &a) ||
				     strcmp(q->q_paddr, a.q_paddr) == 0))
				{
					if (tTd(25, 5))
					{
						sm_dprintf("removefromlist: QS_REMOVED ");
						printaddr(sm_debug_file(), &a, false);
					}
					q->q_state = QS_REMOVED;
					naddrs++;
					break;
				}
			}
		}
	}
	SM_FINALLY
	{
		e->e_to = oldto;
		if (bufp != buf)
			sm_free(bufp);
		macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), NULL);
	}
	SM_END_TRY
	return naddrs;
}
#endif /* MILTER */

/*
**  RECIPIENT -- Designate a message recipient
**	Saves the named person for future mailing (after some checks).
**
**	Parameters:
**		new -- the (preparsed) address header for the recipient.
**		sendq -- a pointer to the head of a queue to put the
**			recipient in.  Duplicate suppression is done
**			in this queue.
**		aliaslevel -- the current alias nesting depth.
**		e -- the current envelope.
**
**	Returns:
**		The actual address in the queue.  This will be "a" if
**		the address is not a duplicate, else the original address.
**
*/

ADDRESS *
recipient(new, sendq, aliaslevel, e)
	register ADDRESS *new;
	register ADDRESS **sendq;
	int aliaslevel;
	register ENVELOPE *e;
{
	register ADDRESS *q;
	ADDRESS **pq;
	ADDRESS **prev;
	register struct mailer *m;
	register char *p;
	int i, buflen;
	bool quoted;		/* set if the addr has a quote bit */
	bool insert;
	int findusercount;
	bool initialdontsend;
	char *buf;
	char buf0[MAXNAME + 1];		/* unquoted image of the user name */
	sortfn_t *sortfn;

	p = NULL;
	quoted = false;
	insert = false;
	findusercount = 0;
	initialdontsend = QS_IS_DEAD(new->q_state);
	e->e_to = new->q_paddr;
	m = new->q_mailer;
	errno = 0;
	if (aliaslevel == 0)
		new->q_flags |= QPRIMARY;
	if (tTd(26, 1))
	{
		sm_dprintf("\nrecipient (%d): ", aliaslevel);
		printaddr(sm_debug_file(), new, false);
	}

	/* if this is primary, use it as original recipient */
	if (new->q_alias == NULL)
	{
		if (e->e_origrcpt == NULL)
			e->e_origrcpt = new->q_paddr;
		else if (e->e_origrcpt != new->q_paddr)
			e->e_origrcpt = "";
	}

	/* find parent recipient for finalrcpt and orcpt */
	for (q = new; q->q_alias != NULL; q = q->q_alias)
		continue;

	/* find final recipient DSN address */
	if (new->q_finalrcpt == NULL &&
	    e->e_from.q_mailer != NULL)
	{
		char frbuf[MAXLINE];

		p = e->e_from.q_mailer->m_addrtype;
		if (p == NULL)
			p = "rfc822";
		if (sm_strcasecmp(p, "rfc822") != 0)
		{
			(void) sm_snprintf(frbuf, sizeof(frbuf), "%s; %.800s",
					   q->q_mailer->m_addrtype,
					   q->q_user);
		}
		else if (strchr(q->q_user, '@@') != NULL)
		{
			(void) sm_snprintf(frbuf, sizeof(frbuf), "%s; %.800s",
					   p, q->q_user);
		}
		else if (strchr(q->q_paddr, '@@') != NULL)
		{
			char *qp;
			bool b;

			qp = q->q_paddr;

			/* strip brackets from address */
			b = false;
			if (*qp == '<')
			{
				b = qp[strlen(qp) - 1] == '>';
				if (b)
					qp[strlen(qp) - 1] = '\0';
				qp++;
			}
			(void) sm_snprintf(frbuf, sizeof(frbuf), "%s; %.800s",
					   p, qp);

			/* undo damage */
			if (b)
				qp[strlen(qp)] = '>';
		}
		else
		{
			(void) sm_snprintf(frbuf, sizeof(frbuf),
					   "%s; %.700s@@%.100s",
					   p, q->q_user, MyHostName);
		}
		new->q_finalrcpt = sm_rpool_strdup_x(e->e_rpool, frbuf);
	}

#if _FFR_GEN_ORCPT
	/* set ORCPT DSN arg if not already set */
	if (new->q_orcpt == NULL)
	{
		/* check for an existing ORCPT */
		if (q->q_orcpt != NULL)
			new->q_orcpt = q->q_orcpt;
		else
		{
			/* make our own */
			bool b = false;
			char *qp;
			char obuf[MAXLINE];

			if (e->e_from.q_mailer != NULL)
				p = e->e_from.q_mailer->m_addrtype;
			if (p == NULL)
				p = "rfc822";
			(void) sm_strlcpyn(obuf, sizeof(obuf), 2, p, ";");

			qp = q->q_paddr;

			/* FFR: Needs to strip comments from stdin addrs */

			/* strip brackets from address */
			if (*qp == '<')
			{
				b = qp[strlen(qp) - 1] == '>';
				if (b)
					qp[strlen(qp) - 1] = '\0';
				qp++;
			}

			p = xtextify(denlstring(qp, true, false), "=");

			if (sm_strlcat(obuf, p, sizeof(obuf)) >= sizeof(obuf))
			{
				/* if too big, don't use it */
				obuf[0] = '\0';
			}

			/* undo damage */
			if (b)
				qp[strlen(qp)] = '>';

			if (obuf[0] != '\0')
				new->q_orcpt =
					sm_rpool_strdup_x(e->e_rpool, obuf);
		}
	}
#endif /* _FFR_GEN_ORCPT */

	/* break aliasing loops */
	if (aliaslevel > MaxAliasRecursion)
	{
		new->q_state = QS_BADADDR;
		new->q_status = "5.4.6";
		if (new->q_alias != NULL)
		{
			new->q_alias->q_state = QS_BADADDR;
			new->q_alias->q_status = "5.4.6";
		}
		if ((SuprErrs || !LogUsrErrs) && LogLevel > 0)
		{
			sm_syslog(LOG_ERR, e->e_id,
				"aliasing/forwarding loop broken: %s (%d aliases deep; %d max)",
				FileName != NULL ? FileName : "", aliaslevel,
				MaxAliasRecursion);
		}
		usrerrenh(new->q_status,
			  "554 aliasing/forwarding loop broken (%d aliases deep; %d max)",
			  aliaslevel, MaxAliasRecursion);
		return new;
	}

	/*
	**  Finish setting up address structure.
	*/

	/* get unquoted user for file, program or user.name check */
	i = strlen(new->q_user);
	if (i >= sizeof(buf0))
	{
		buflen = i + 1;
		buf = xalloc(buflen);
	}
	else
	{
		buf = buf0;
		buflen = sizeof(buf0);
	}
	(void) sm_strlcpy(buf, new->q_user, buflen);
	for (p = buf; *p != '\0' && !quoted; p++)
	{
		if (*p == '\\')
			quoted = true;
	}
	stripquotes(buf);

	/* check for direct mailing to restricted mailers */
	if (m == ProgMailer)
	{
		if (new->q_alias == NULL || UseMSP ||
		    bitset(EF_UNSAFE, e->e_flags))
		{
			new->q_state = QS_BADADDR;
			new->q_status = "5.7.1";
			usrerrenh(new->q_status,
				  "550 Cannot mail directly to programs");
		}
		else if (bitset(QBOGUSSHELL, new->q_alias->q_flags))
		{
			new->q_state = QS_BADADDR;
			new->q_status = "5.7.1";
			if (new->q_alias->q_ruser == NULL)
				usrerrenh(new->q_status,
					  "550 UID %d is an unknown user: cannot mail to programs",
					  new->q_alias->q_uid);
			else
				usrerrenh(new->q_status,
					  "550 User %s@@%s doesn't have a valid shell for mailing to programs",
					  new->q_alias->q_ruser, MyHostName);
		}
		else if (bitset(QUNSAFEADDR, new->q_alias->q_flags))
		{
			new->q_state = QS_BADADDR;
			new->q_status = "5.7.1";
			new->q_rstatus = "550 Unsafe for mailing to programs";
			usrerrenh(new->q_status,
				  "550 Address %s is unsafe for mailing to programs",
				  new->q_alias->q_paddr);
		}
	}

	/*
	**  Look up this person in the recipient list.
	**	If they are there already, return, otherwise continue.
	**	If the list is empty, just add it.  Notice the cute
	**	hack to make from addresses suppress things correctly:
	**	the QS_DUPLICATE state will be set in the send list.
	**	[Please note: the emphasis is on "hack."]
	*/

	prev = NULL;

	/*
	**  If this message is going to the queue or FastSplit is set
	**  and it is the first try and the envelope hasn't split, then we
	**  avoid doing an MX RR lookup now because one will be done when the
	**  message is extracted from the queue later. It can go to the queue
	**  because all messages are going to the queue or this mailer of
	**  the current recipient is marked expensive.
	*/

	if (UseMSP || WILL_BE_QUEUED(e->e_sendmode) ||
	    (!bitset(EF_SPLIT, e->e_flags) && e->e_ntries == 0 &&
	     FastSplit > 0))
		sortfn = sorthost;
	else if (NoConnect && bitnset(M_EXPENSIVE, new->q_mailer->m_flags))
		sortfn = sortexpensive;
	else
		sortfn = sortbysignature;

	for (pq = sendq; (q = *pq) != NULL; pq = &q->q_next)
	{
		/*
		**  If address is "less than" it should be inserted now.
		**  If address is "greater than" current comparison it'll
		**  insert later in the list; so loop again (if possible).
		**  If address is "equal" (different equal than sameaddr()
		**  call) then check if sameaddr() will be true.
		**  Because this list is now sorted, it'll mean fewer
		**  comparisons and fewer loops which is important for more
		**  recipients.
		*/

		i = (*sortfn)(new, q);
		if (i == 0) /* equal */
		{
			/*
			**  Sortbysignature() has said that the two have
			**  equal MX RR's and the same user. Calling sameaddr()
			**  now checks if the two hosts are as identical as the
			**  MX RR's are (which might not be the case)
			**  before saying these are the identical addresses.
			*/

			if (sameaddr(q, new) &&
			    (bitset(QRCPTOK, q->q_flags) ||
			     !bitset(QPRIMARY, q->q_flags)))
			{
				if (tTd(26, 1))
				{
					sm_dprintf("%s in sendq: ",
						   new->q_paddr);
					printaddr(sm_debug_file(), q, false);
				}
				if (!bitset(QPRIMARY, q->q_flags))
				{
					if (!QS_IS_DEAD(new->q_state))
						message("duplicate suppressed");
					else
						q->q_state = QS_DUPLICATE;
					q->q_flags |= new->q_flags;
				}
				else if (bitset(QSELFREF, q->q_flags)
					 || q->q_state == QS_REMOVED)
				{
					/*
					**  If an earlier milter removed the
					**  address, a later one can still add
					**  it back.
					*/

					q->q_state = new->q_state;
					q->q_flags |= new->q_flags;
				}
				new = q;
				goto done;
			}
		}
		else if (i < 0) /* less than */
		{
			insert = true;
			break;
		}
		prev = pq;
	}

	/* pq should point to an address, never NULL */
	SM_ASSERT(pq != NULL);

	/* add address on list */
	if (insert)
	{
		/*
		**  insert before 'pq'. Only possible when at least 1
		**  ADDRESS is in the list already.
		*/

		new->q_next = *pq;
		if (prev == NULL)
			*sendq = new; /* To be the first ADDRESS */
		else
			(*prev)->q_next = new;
	}
	else
	{
		/*
		**  Place in list at current 'pq' position. Possible
		**  when there are 0 or more ADDRESS's in the list.
		*/

		new->q_next = NULL;
		*pq = new;
	}

	/* added a new address: clear split flag */
	e->e_flags &= ~EF_SPLIT;

	/*
	**  Alias the name and handle special mailer types.
	*/

  trylocaluser:
	if (tTd(29, 7))
	{
		sm_dprintf("at trylocaluser: ");
		printaddr(sm_debug_file(), new, false);
	}

	if (!QS_IS_OK(new->q_state))
	{
		if (QS_IS_UNDELIVERED(new->q_state))
			e->e_nrcpts++;
		goto testselfdestruct;
	}

	if (m == InclMailer)
	{
		new->q_state = QS_INCLUDED;
		if (new->q_alias == NULL || UseMSP ||
		    bitset(EF_UNSAFE, e->e_flags))
		{
			new->q_state = QS_BADADDR;
			new->q_status = "5.7.1";
			usrerrenh(new->q_status,
				  "550 Cannot mail directly to :include:s");
		}
		else
		{
			int ret;

			message("including file %s", new->q_user);
			ret = include(new->q_user, false, new,
				      sendq, aliaslevel, e);
			if (transienterror(ret))
			{
				if (LogLevel > 2)
					sm_syslog(LOG_ERR, e->e_id,
						  "include %s: transient error: %s",
						  shortenstring(new->q_user,
								MAXSHORTSTR),
								sm_errstring(ret));
				new->q_state = QS_QUEUEUP;
				usrerr("451 4.2.4 Cannot open %s: %s",
					shortenstring(new->q_user,
						      MAXSHORTSTR),
					sm_errstring(ret));
			}
			else if (ret != 0)
			{
				new->q_state = QS_BADADDR;
				new->q_status = "5.2.4";
				usrerrenh(new->q_status,
					  "550 Cannot open %s: %s",
					  shortenstring(new->q_user,
							MAXSHORTSTR),
					  sm_errstring(ret));
			}
		}
	}
	else if (m == FileMailer)
	{
		/* check if allowed */
		if (new->q_alias == NULL || UseMSP ||
		    bitset(EF_UNSAFE, e->e_flags))
		{
			new->q_state = QS_BADADDR;
			new->q_status = "5.7.1";
			usrerrenh(new->q_status,
				  "550 Cannot mail directly to files");
		}
		else if (bitset(QBOGUSSHELL, new->q_alias->q_flags))
		{
			new->q_state = QS_BADADDR;
			new->q_status = "5.7.1";
			if (new->q_alias->q_ruser == NULL)
				usrerrenh(new->q_status,
					  "550 UID %d is an unknown user: cannot mail to files",
					  new->q_alias->q_uid);
			else
				usrerrenh(new->q_status,
					  "550 User %s@@%s doesn't have a valid shell for mailing to files",
					  new->q_alias->q_ruser, MyHostName);
		}
		else if (bitset(QUNSAFEADDR, new->q_alias->q_flags))
		{
			new->q_state = QS_BADADDR;
			new->q_status = "5.7.1";
			new->q_rstatus = "550 Unsafe for mailing to files";
			usrerrenh(new->q_status,
				  "550 Address %s is unsafe for mailing to files",
				  new->q_alias->q_paddr);
		}
	}

	/* try aliasing */
	if (!quoted && QS_IS_OK(new->q_state) &&
	    bitnset(M_ALIASABLE, m->m_flags))
		alias(new, sendq, aliaslevel, e);

#if USERDB
	/* if not aliased, look it up in the user database */
	if (!bitset(QNOTREMOTE, new->q_flags) &&
	    QS_IS_SENDABLE(new->q_state) &&
	    bitnset(M_CHECKUDB, m->m_flags))
	{
		if (udbexpand(new, sendq, aliaslevel, e) == EX_TEMPFAIL)
		{
			new->q_state = QS_QUEUEUP;
			if (e->e_message == NULL)
				e->e_message = sm_rpool_strdup_x(e->e_rpool,
						"Deferred: user database error");
			if (new->q_message == NULL)
				new->q_message = "Deferred: user database error";
			if (LogLevel > 8)
				sm_syslog(LOG_INFO, e->e_id,
					  "deferred: udbexpand: %s",
					  sm_errstring(errno));
			message("queued (user database error): %s",
				sm_errstring(errno));
			e->e_nrcpts++;
			goto testselfdestruct;
		}
	}
#endif /* USERDB */

	/*
	**  If we have a level two config file, then pass the name through
	**  Ruleset 5 before sending it off.  Ruleset 5 has the right
	**  to rewrite it to another mailer.  This gives us a hook
	**  after local aliasing has been done.
	*/

	if (tTd(29, 5))
	{
		sm_dprintf("recipient: testing local?  cl=%d, rr5=%p\n\t",
			   ConfigLevel, RewriteRules[5]);
		printaddr(sm_debug_file(), new, false);
	}
	if (ConfigLevel >= 2 && RewriteRules[5] != NULL &&
	    bitnset(M_TRYRULESET5, m->m_flags) &&
	    !bitset(QNOTREMOTE, new->q_flags) &&
	    QS_IS_OK(new->q_state))
	{
		maplocaluser(new, sendq, aliaslevel + 1, e);
	}

	/*
	**  If it didn't get rewritten to another mailer, go ahead
	**  and deliver it.
	*/

	if (QS_IS_OK(new->q_state) &&
	    bitnset(M_HASPWENT, m->m_flags))
	{
		auto bool fuzzy;
		SM_MBDB_T user;
		int status;

		/* warning -- finduser may trash buf */
		status = finduser(buf, &fuzzy, &user);
		switch (status)
		{
		  case EX_TEMPFAIL:
			new->q_state = QS_QUEUEUP;
			new->q_status = "4.5.2";
			giveresponse(EX_TEMPFAIL, new->q_status, m, NULL,
				     new->q_alias, (time_t) 0, e, new);
			break;
		  default:
			new->q_state = QS_BADADDR;
			new->q_status = "5.1.1";
			new->q_rstatus = "550 5.1.1 User unknown";
			giveresponse(EX_NOUSER, new->q_status, m, NULL,
				     new->q_alias, (time_t) 0, e, new);
			break;
		  case EX_OK:
			if (fuzzy)
			{
				/* name was a fuzzy match */
				new->q_user = sm_rpool_strdup_x(e->e_rpool,
								user.mbdb_name);
				if (findusercount++ > 3)
				{
					new->q_state = QS_BADADDR;
					new->q_status = "5.4.6";
					usrerrenh(new->q_status,
						  "554 aliasing/forwarding loop for %s broken",
						  user.mbdb_name);
					goto done;
				}

				/* see if it aliases */
				(void) sm_strlcpy(buf, user.mbdb_name, buflen);
				goto trylocaluser;
			}
			if (*user.mbdb_homedir == '\0')
				new->q_home = NULL;
			else if (strcmp(user.mbdb_homedir, "/") == 0)
				new->q_home = "";
			else
				new->q_home = sm_rpool_strdup_x(e->e_rpool,
							user.mbdb_homedir);
			if (user.mbdb_uid != SM_NO_UID)
			{
				new->q_uid = user.mbdb_uid;
				new->q_gid = user.mbdb_gid;
				new->q_flags |= QGOODUID;
			}
			new->q_ruser = sm_rpool_strdup_x(e->e_rpool,
							 user.mbdb_name);
			if (user.mbdb_fullname[0] != '\0')
				new->q_fullname = sm_rpool_strdup_x(e->e_rpool,
							user.mbdb_fullname);
			if (!usershellok(user.mbdb_name, user.mbdb_shell))
			{
				new->q_flags |= QBOGUSSHELL;
			}
			if (bitset(EF_VRFYONLY, e->e_flags))
			{
				/* don't do any more now */
				new->q_state = QS_VERIFIED;
			}
			else if (!quoted)
				forward(new, sendq, aliaslevel, e);
		}
	}
	if (!QS_IS_DEAD(new->q_state))
		e->e_nrcpts++;

  testselfdestruct:
	new->q_flags |= QTHISPASS;
	if (tTd(26, 8))
	{
		sm_dprintf("testselfdestruct: ");
		printaddr(sm_debug_file(), new, false);
		if (tTd(26, 10))
		{
			sm_dprintf("SENDQ:\n");
			printaddr(sm_debug_file(), *sendq, true);
			sm_dprintf("----\n");
		}
	}
	if (new->q_alias == NULL && new != &e->e_from &&
	    QS_IS_DEAD(new->q_state))
	{
		for (q = *sendq; q != NULL; q = q->q_next)
		{
			if (!QS_IS_DEAD(q->q_state))
				break;
		}
		if (q == NULL)
		{
			new->q_state = QS_BADADDR;
			new->q_status = "5.4.6";
			usrerrenh(new->q_status,
				  "554 aliasing/forwarding loop broken");
		}
	}

  done:
	new->q_flags |= QTHISPASS;
	if (buf != buf0)
		sm_free(buf); /* XXX leak if above code raises exception */

	/*
	**  If we are at the top level, check to see if this has
	**  expanded to exactly one address.  If so, it can inherit
	**  the primaryness of the address.
	**
	**  While we're at it, clear the QTHISPASS bits.
	*/

	if (aliaslevel == 0)
	{
		int nrcpts = 0;
		ADDRESS *only = NULL;

		for (q = *sendq; q != NULL; q = q->q_next)
		{
			if (bitset(QTHISPASS, q->q_flags) &&
			    QS_IS_SENDABLE(q->q_state))
			{
				nrcpts++;
				only = q;
			}
			q->q_flags &= ~QTHISPASS;
		}
		if (nrcpts == 1)
		{
			/* check to see if this actually got a new owner */
			q = only;
			while ((q = q->q_alias) != NULL)
			{
				if (q->q_owner != NULL)
					break;
			}
			if (q == NULL)
				only->q_flags |= QPRIMARY;
		}
		else if (!initialdontsend && nrcpts > 0)
		{
			/* arrange for return receipt */
			e->e_flags |= EF_SENDRECEIPT;
			new->q_flags |= QEXPANDED;
			if (e->e_xfp != NULL &&
			    bitset(QPINGONSUCCESS, new->q_flags))
				(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
						     "%s... expanded to multiple addresses\n",
						     new->q_paddr);
		}
	}
	new->q_flags |= QRCPTOK;
	(void) sm_snprintf(buf0, sizeof(buf0), "%d", e->e_nrcpts);
	macdefine(&e->e_macro, A_TEMP, macid("{nrcpts}"), buf0);
	return new;
}

/*
**  FINDUSER -- find the password entry for a user.
**
**	This looks a lot like getpwnam, except that it may want to
**	do some fancier pattern matching in /etc/passwd.
**
**	This routine contains most of the time of many sendmail runs.
**	It deserves to be optimized.
**
**	Parameters:
**		name -- the name to match against.
**		fuzzyp -- an outarg that is set to true if this entry
**			was found using the fuzzy matching algorithm;
**			set to false otherwise.
**		user -- structure to fill in if user is found
**
**	Returns:
**		On success, fill in *user, set *fuzzyp and return EX_OK.
**		If the user was not found, return EX_NOUSER.
**		On error, return EX_TEMPFAIL or EX_OSERR.
**
**	Side Effects:
**		may modify name.
*/

int
finduser(name, fuzzyp, user)
	char *name;
	bool *fuzzyp;
	SM_MBDB_T *user;
{
#if MATCHGECOS
	register struct passwd *pw;
#endif /* MATCHGECOS */
	register char *p;
	bool tryagain;
	int status;

	if (tTd(29, 4))
		sm_dprintf("finduser(%s): ", name);

	*fuzzyp = false;

#if HESIOD
	/* DEC Hesiod getpwnam accepts numeric strings -- short circuit it */
	for (p = name; *p != '\0'; p++)
		if (!isascii(*p) || !isdigit(*p))
			break;
	if (*p == '\0')
	{
		if (tTd(29, 4))
			sm_dprintf("failed (numeric input)\n");
		return EX_NOUSER;
	}
#endif /* HESIOD */

	/* look up this login name using fast path */
	status = sm_mbdb_lookup(name, user);
	if (status != EX_NOUSER)
	{
		if (tTd(29, 4))
			sm_dprintf("%s (non-fuzzy)\n", sm_strexit(status));
		return status;
	}

	/* try mapping it to lower case */
	tryagain = false;
	for (p = name; *p != '\0'; p++)
	{
		if (isascii(*p) && isupper(*p))
		{
			*p = tolower(*p);
			tryagain = true;
		}
	}
	if (tryagain && (status = sm_mbdb_lookup(name, user)) != EX_NOUSER)
	{
		if (tTd(29, 4))
			sm_dprintf("%s (lower case)\n", sm_strexit(status));
		*fuzzyp = true;
		return status;
	}

#if MATCHGECOS
	/* see if fuzzy matching allowed */
	if (!MatchGecos)
	{
		if (tTd(29, 4))
			sm_dprintf("not found (fuzzy disabled)\n");
		return EX_NOUSER;
	}

	/* search for a matching full name instead */
	for (p = name; *p != '\0'; p++)
	{
		if (*p == (SpaceSub & 0177) || *p == '_')
			*p = ' ';
	}
	(void) setpwent();
	while ((pw = getpwent()) != NULL)
	{
		char buf[MAXNAME + 1];

# if 0
		if (sm_strcasecmp(pw->pw_name, name) == 0)
		{
			if (tTd(29, 4))
				sm_dprintf("found (case wrapped)\n");
			break;
		}
# endif /* 0 */

		sm_pwfullname(pw->pw_gecos, pw->pw_name, buf, sizeof(buf));
		if (strchr(buf, ' ') != NULL && sm_strcasecmp(buf, name) == 0)
		{
			if (tTd(29, 4))
				sm_dprintf("fuzzy matches %s\n", pw->pw_name);
			message("sending to login name %s", pw->pw_name);
			break;
		}
	}
	if (pw != NULL)
		*fuzzyp = true;
	else if (tTd(29, 4))
		sm_dprintf("no fuzzy match found\n");
# if DEC_OSF_BROKEN_GETPWENT	/* DEC OSF/1 3.2 or earlier */
	endpwent();
# endif /* DEC_OSF_BROKEN_GETPWENT */
	if (pw == NULL)
		return EX_NOUSER;
	sm_mbdb_frompw(user, pw);
	return EX_OK;
#else /* MATCHGECOS */
	if (tTd(29, 4))
		sm_dprintf("not found (fuzzy disabled)\n");
	return EX_NOUSER;
#endif /* MATCHGECOS */
}

/*
**  WRITABLE -- predicate returning if the file is writable.
**
**	This routine must duplicate the algorithm in sys/fio.c.
**	Unfortunately, we cannot use the access call since we
**	won't necessarily be the real uid when we try to
**	actually open the file.
**
**	Notice that ANY file with ANY execute bit is automatically
**	not writable.  This is also enforced by mailfile.
**
**	Parameters:
**		filename -- the file name to check.
**		ctladdr -- the controlling address for this file.
**		flags -- SFF_* flags to control the function.
**
**	Returns:
**		true -- if we will be able to write this file.
**		false -- if we cannot write this file.
**
**	Side Effects:
**		none.
*/

bool
writable(filename, ctladdr, flags)
	char *filename;
	ADDRESS *ctladdr;
	long flags;
{
	uid_t euid = 0;
	gid_t egid = 0;
	char *user = NULL;

	if (tTd(44, 5))
		sm_dprintf("writable(%s, 0x%lx)\n", filename, flags);

	/*
	**  File does exist -- check that it is writable.
	*/

	if (geteuid() != 0)
	{
		euid = geteuid();
		egid = getegid();
		user = NULL;
	}
	else if (ctladdr != NULL)
	{
		euid = ctladdr->q_uid;
		egid = ctladdr->q_gid;
		user = ctladdr->q_user;
	}
	else if (bitset(SFF_RUNASREALUID, flags))
	{
		euid = RealUid;
		egid = RealGid;
		user = RealUserName;
	}
	else if (FileMailer != NULL && !bitset(SFF_ROOTOK, flags))
	{
		if (FileMailer->m_uid == NO_UID)
		{
			euid = DefUid;
			user = DefUser;
		}
		else
		{
			euid = FileMailer->m_uid;
			user = NULL;
		}
		if (FileMailer->m_gid == NO_GID)
			egid = DefGid;
		else
			egid = FileMailer->m_gid;
	}
	else
	{
		euid = egid = 0;
		user = NULL;
	}
	if (!bitset(SFF_ROOTOK, flags))
	{
		if (euid == 0)
		{
			euid = DefUid;
			user = DefUser;
		}
		if (egid == 0)
			egid = DefGid;
	}
	if (geteuid() == 0 &&
	    (ctladdr == NULL || !bitset(QGOODUID, ctladdr->q_flags)))
		flags |= SFF_SETUIDOK;

	if (!bitnset(DBS_FILEDELIVERYTOSYMLINK, DontBlameSendmail))
		flags |= SFF_NOSLINK;
	if (!bitnset(DBS_FILEDELIVERYTOHARDLINK, DontBlameSendmail))
		flags |= SFF_NOHLINK;

	errno = safefile(filename, euid, egid, user, flags, S_IWRITE, NULL);
	return errno == 0;
}

/*
**  INCLUDE -- handle :include: specification.
**
**	Parameters:
**		fname -- filename to include.
**		forwarding -- if true, we are reading a .forward file.
**			if false, it's a :include: file.
**		ctladdr -- address template to use to fill in these
**			addresses -- effective user/group id are
**			the important things.
**		sendq -- a pointer to the head of the send queue
**			to put these addresses in.
**		aliaslevel -- the alias nesting depth.
**		e -- the current envelope.
**
**	Returns:
**		open error status
**
**	Side Effects:
**		reads the :include: file and sends to everyone
**		listed in that file.
**
**	Security Note:
**		If you have restricted chown (that is, you can't
**		give a file away), it is reasonable to allow programs
**		and files called from this :include: file to be to be
**		run as the owner of the :include: file.  This is bogus
**		if there is any chance of someone giving away a file.
**		We assume that pre-POSIX systems can give away files.
**
**		There is an additional restriction that if you
**		forward to a :include: file, it will not take on
**		the ownership of the :include: file.  This may not
**		be necessary, but shouldn't hurt.
*/

static jmp_buf	CtxIncludeTimeout;

int
include(fname, forwarding, ctladdr, sendq, aliaslevel, e)
	char *fname;
	bool forwarding;
	ADDRESS *ctladdr;
	ADDRESS **sendq;
	int aliaslevel;
	ENVELOPE *e;
{
	SM_FILE_T *volatile fp = NULL;
	char *oldto = e->e_to;
	char *oldfilename = FileName;
	int oldlinenumber = LineNumber;
	register SM_EVENT *ev = NULL;
	int nincludes;
	int mode;
	volatile bool maxreached = false;
	register ADDRESS *ca;
	volatile uid_t saveduid;
	volatile gid_t savedgid;
	volatile uid_t uid;
	volatile gid_t gid;
	char *volatile user;
	int rval = 0;
	volatile long sfflags = SFF_REGONLY;
	register char *p;
	bool safechown = false;
	volatile bool safedir = false;
	struct stat st;
	char buf[MAXLINE];

	if (tTd(27, 2))
		sm_dprintf("include(%s)\n", fname);
	if (tTd(27, 4))
		sm_dprintf("   ruid=%d euid=%d\n",
			(int) getuid(), (int) geteuid());
	if (tTd(27, 14))
	{
		sm_dprintf("ctladdr ");
		printaddr(sm_debug_file(), ctladdr, false);
	}

	if (tTd(27, 9))
		sm_dprintf("include: old uid = %d/%d\n",
			   (int) getuid(), (int) geteuid());

	if (forwarding)
	{
		sfflags |= SFF_MUSTOWN|SFF_ROOTOK;
		if (!bitnset(DBS_GROUPWRITABLEFORWARDFILE, DontBlameSendmail))
			sfflags |= SFF_NOGWFILES;
		if (!bitnset(DBS_WORLDWRITABLEFORWARDFILE, DontBlameSendmail))
			sfflags |= SFF_NOWWFILES;
	}
	else
	{
		if (!bitnset(DBS_GROUPWRITABLEINCLUDEFILE, DontBlameSendmail))
			sfflags |= SFF_NOGWFILES;
		if (!bitnset(DBS_WORLDWRITABLEINCLUDEFILE, DontBlameSendmail))
			sfflags |= SFF_NOWWFILES;
	}

	/*
	**  If RunAsUser set, won't be able to run programs as user
	**  so mark them as unsafe unless the administrator knows better.
	*/

	if ((geteuid() != 0 || RunAsUid != 0) &&
	    !bitnset(DBS_NONROOTSAFEADDR, DontBlameSendmail))
	{
		if (tTd(27, 4))
			sm_dprintf("include: not safe (euid=%d, RunAsUid=%d)\n",
				   (int) geteuid(), (int) RunAsUid);
		ctladdr->q_flags |= QUNSAFEADDR;
	}

	ca = getctladdr(ctladdr);
	if (ca == NULL ||
	    (ca->q_uid == DefUid && ca->q_gid == 0))
	{
		uid = DefUid;
		gid = DefGid;
		user = DefUser;
	}
	else
	{
		uid = ca->q_uid;
		gid = ca->q_gid;
		user = ca->q_user;
	}
#if MAILER_SETUID_METHOD != USE_SETUID
	saveduid = geteuid();
	savedgid = getegid();
	if (saveduid == 0)
	{
		if (!DontInitGroups)
		{
			if (initgroups(user, gid) == -1)
			{
				rval = EAGAIN;
				syserr("include: initgroups(%s, %d) failed",
					user, gid);
				goto resetuid;
			}
		}
		else
		{
			GIDSET_T gidset[1];

			gidset[0] = gid;
			if (setgroups(1, gidset) == -1)
			{
				rval = EAGAIN;
				syserr("include: setgroups() failed");
				goto resetuid;
			}
		}

		if (gid != 0 && setgid(gid) < -1)
		{
			rval = EAGAIN;
			syserr("setgid(%d) failure", gid);
			goto resetuid;
		}
		if (uid != 0)
		{
# if MAILER_SETUID_METHOD == USE_SETEUID
			if (seteuid(uid) < 0)
			{
				rval = EAGAIN;
				syserr("seteuid(%d) failure (real=%d, eff=%d)",
					uid, (int) getuid(), (int) geteuid());
				goto resetuid;
			}
# endif /* MAILER_SETUID_METHOD == USE_SETEUID */
# if MAILER_SETUID_METHOD == USE_SETREUID
			if (setreuid(0, uid) < 0)
			{
				rval = EAGAIN;
				syserr("setreuid(0, %d) failure (real=%d, eff=%d)",
					uid, (int) getuid(), (int) geteuid());
				goto resetuid;
			}
# endif /* MAILER_SETUID_METHOD == USE_SETREUID */
		}
	}
#endif /* MAILER_SETUID_METHOD != USE_SETUID */

	if (tTd(27, 9))
		sm_dprintf("include: new uid = %d/%d\n",
			   (int) getuid(), (int) geteuid());

	/*
	**  If home directory is remote mounted but server is down,
	**  this can hang or give errors; use a timeout to avoid this
	*/

	if (setjmp(CtxIncludeTimeout) != 0)
	{
		ctladdr->q_state = QS_QUEUEUP;
		errno = 0;

		/* return pseudo-error code */
		rval = E_SM_OPENTIMEOUT;
		goto resetuid;
	}
	if (TimeOuts.to_fileopen > 0)
		ev = sm_setevent(TimeOuts.to_fileopen, includetimeout, 0);
	else
		ev = NULL;


	/* check for writable parent directory */
	p = strrchr(fname, '/');
	if (p != NULL)
	{
		int ret;

		*p = '\0';
		ret = safedirpath(fname, uid, gid, user,
				  sfflags|SFF_SAFEDIRPATH, 0, 0);
		if (ret == 0)
		{
			/* in safe directory: relax chown & link rules */
			safedir = true;
			sfflags |= SFF_NOPATHCHECK;
		}
		else
		{
			if (bitnset((forwarding ?
				     DBS_FORWARDFILEINUNSAFEDIRPATH :
				     DBS_INCLUDEFILEINUNSAFEDIRPATH),
				    DontBlameSendmail))
				sfflags |= SFF_NOPATHCHECK;
			else if (bitnset((forwarding ?
					  DBS_FORWARDFILEINGROUPWRITABLEDIRPATH :
					  DBS_INCLUDEFILEINGROUPWRITABLEDIRPATH),
					 DontBlameSendmail) &&
				 ret == E_SM_GWDIR)
			{
				setbitn(DBS_GROUPWRITABLEDIRPATHSAFE,
					DontBlameSendmail);
				ret = safedirpath(fname, uid, gid, user,
						  sfflags|SFF_SAFEDIRPATH,
						  0, 0);
				clrbitn(DBS_GROUPWRITABLEDIRPATHSAFE,
					DontBlameSendmail);
				if (ret == 0)
					sfflags |= SFF_NOPATHCHECK;
				else
					sfflags |= SFF_SAFEDIRPATH;
			}
			else
				sfflags |= SFF_SAFEDIRPATH;
			if (ret > E_PSEUDOBASE &&
			    !bitnset((forwarding ?
				      DBS_FORWARDFILEINUNSAFEDIRPATHSAFE :
				      DBS_INCLUDEFILEINUNSAFEDIRPATHSAFE),
				     DontBlameSendmail))
			{
				if (LogLevel > 11)
					sm_syslog(LOG_INFO, e->e_id,
						  "%s: unsafe directory path, marked unsafe",
						  shortenstring(fname, MAXSHORTSTR));
				ctladdr->q_flags |= QUNSAFEADDR;
			}
		}
		*p = '/';
	}

	/* allow links only in unwritable directories */
	if (!safedir &&
	    !bitnset((forwarding ?
		      DBS_LINKEDFORWARDFILEINWRITABLEDIR :
		      DBS_LINKEDINCLUDEFILEINWRITABLEDIR),
		     DontBlameSendmail))
		sfflags |= SFF_NOLINK;

	rval = safefile(fname, uid, gid, user, sfflags, S_IREAD, &st);
	if (rval != 0)
	{
		/* don't use this :include: file */
		if (tTd(27, 4))
			sm_dprintf("include: not safe (uid=%d): %s\n",
				   (int) uid, sm_errstring(rval));
	}
	else if ((fp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, fname,
				  SM_IO_RDONLY, NULL)) == NULL)
	{
		rval = errno;
		if (tTd(27, 4))
			sm_dprintf("include: open: %s\n", sm_errstring(rval));
	}
	else if (filechanged(fname, sm_io_getinfo(fp,SM_IO_WHAT_FD, NULL), &st))
	{
		rval = E_SM_FILECHANGE;
		if (tTd(27, 4))
			sm_dprintf("include: file changed after open\n");
	}
	if (ev != NULL)
		sm_clrevent(ev);

resetuid:

#if HASSETREUID || USESETEUID
	if (saveduid == 0)
	{
		if (uid != 0)
		{
# if USESETEUID
			if (seteuid(0) < 0)
				syserr("!seteuid(0) failure (real=%d, eff=%d)",
				       (int) getuid(), (int) geteuid());
# else /* USESETEUID */
			if (setreuid(-1, 0) < 0)
				syserr("!setreuid(-1, 0) failure (real=%d, eff=%d)",
				       (int) getuid(), (int) geteuid());
			if (setreuid(RealUid, 0) < 0)
				syserr("!setreuid(%d, 0) failure (real=%d, eff=%d)",
				       (int) RealUid, (int) getuid(),
				       (int) geteuid());
# endif /* USESETEUID */
		}
		if (setgid(savedgid) < 0)
			syserr("!setgid(%d) failure (real=%d eff=%d)",
			       (int) savedgid, (int) getgid(),
			       (int) getegid());
	}
#endif /* HASSETREUID || USESETEUID */

	if (tTd(27, 9))
		sm_dprintf("include: reset uid = %d/%d\n",
			   (int) getuid(), (int) geteuid());

	if (rval == E_SM_OPENTIMEOUT)
		usrerr("451 4.4.1 open timeout on %s", fname);

	if (fp == NULL)
		return rval;

	if (fstat(sm_io_getinfo(fp, SM_IO_WHAT_FD, NULL), &st) < 0)
	{
		rval = errno;
		syserr("Cannot fstat %s!", fname);
		(void) sm_io_close(fp, SM_TIME_DEFAULT);
		return rval;
	}

	/* if path was writable, check to avoid file giveaway tricks */
	safechown = chownsafe(sm_io_getinfo(fp, SM_IO_WHAT_FD, NULL), safedir);
	if (tTd(27, 6))
		sm_dprintf("include: parent of %s is %s, chown is %ssafe\n",
			   fname, safedir ? "safe" : "dangerous",
			   safechown ? "" : "un");

	/* if no controlling user or coming from an alias delivery */
	if (safechown &&
	    (ca == NULL ||
	     (ca->q_uid == DefUid && ca->q_gid == 0)))
	{
		ctladdr->q_uid = st.st_uid;
		ctladdr->q_gid = st.st_gid;
		ctladdr->q_flags |= QGOODUID;
	}
	if (ca != NULL && ca->q_uid == st.st_uid)
	{
		/* optimization -- avoid getpwuid if we already have info */
		ctladdr->q_flags |= ca->q_flags & QBOGUSSHELL;
		ctladdr->q_ruser = ca->q_ruser;
	}
	else if (!forwarding)
	{
		register struct passwd *pw;

		pw = sm_getpwuid(st.st_uid);
		if (pw == NULL)
		{
			ctladdr->q_uid = st.st_uid;
			ctladdr->q_flags |= QBOGUSSHELL;
		}
		else
		{
			char *sh;

			ctladdr->q_ruser = sm_rpool_strdup_x(e->e_rpool,
							     pw->pw_name);
			if (safechown)
				sh = pw->pw_shell;
			else
				sh = "/SENDMAIL/ANY/SHELL/";
			if (!usershellok(pw->pw_name, sh))
			{
				if (LogLevel > 11)
					sm_syslog(LOG_INFO, e->e_id,
						  "%s: user %s has bad shell %s, marked %s",
						  shortenstring(fname,
								MAXSHORTSTR),
						  pw->pw_name, sh,
						  safechown ? "bogus" : "unsafe");
				if (safechown)
					ctladdr->q_flags |= QBOGUSSHELL;
				else
					ctladdr->q_flags |= QUNSAFEADDR;
			}
		}
	}

	if (bitset(EF_VRFYONLY, e->e_flags))
	{
		/* don't do any more now */
		ctladdr->q_state = QS_VERIFIED;
		e->e_nrcpts++;
		(void) sm_io_close(fp, SM_TIME_DEFAULT);
		return rval;
	}

	/*
	**  Check to see if some bad guy can write this file
	**
	**	Group write checking could be more clever, e.g.,
	**	guessing as to which groups are actually safe ("sys"
	**	may be; "user" probably is not).
	*/

	mode = S_IWOTH;
	if (!bitnset((forwarding ?
		      DBS_GROUPWRITABLEFORWARDFILESAFE :
		      DBS_GROUPWRITABLEINCLUDEFILESAFE),
		     DontBlameSendmail))
		mode |= S_IWGRP;

	if (bitset(mode, st.st_mode))
	{
		if (tTd(27, 6))
			sm_dprintf("include: %s is %s writable, marked unsafe\n",
				   shortenstring(fname, MAXSHORTSTR),
				   bitset(S_IWOTH, st.st_mode) ? "world"
							       : "group");
		if (LogLevel > 11)
			sm_syslog(LOG_INFO, e->e_id,
				  "%s: %s writable %s file, marked unsafe",
				  shortenstring(fname, MAXSHORTSTR),
				  bitset(S_IWOTH, st.st_mode) ? "world" : "group",
				  forwarding ? "forward" : ":include:");
		ctladdr->q_flags |= QUNSAFEADDR;
	}

	/* read the file -- each line is a comma-separated list. */
	FileName = fname;
	LineNumber = 0;
	ctladdr->q_flags &= ~QSELFREF;
	nincludes = 0;
	while (sm_io_fgets(fp, SM_TIME_DEFAULT, buf, sizeof(buf)) >= 0 &&
	       !maxreached)
	{
		fixcrlf(buf, true);
		LineNumber++;
		if (buf[0] == '#' || buf[0] == '\0')
			continue;

		/* <sp>#@@# introduces a comment anywhere */
		/* for Japanese character sets */
		for (p = buf; (p = strchr(++p, '#')) != NULL; )
		{
			if (p[1] == '@@' && p[2] == '#' &&
			    isascii(p[-1]) && isspace(p[-1]) &&
			    (p[3] == '\0' || (isascii(p[3]) && isspace(p[3]))))
			{
				--p;
				while (p > buf && isascii(p[-1]) &&
				       isspace(p[-1]))
					--p;
				p[0] = '\0';
				break;
			}
		}
		if (buf[0] == '\0')
			continue;

		e->e_to = NULL;
		message("%s to %s",
			forwarding ? "forwarding" : "sending", buf);
		if (forwarding && LogLevel > 10)
			sm_syslog(LOG_INFO, e->e_id,
				  "forward %.200s => %s",
				  oldto, shortenstring(buf, MAXSHORTSTR));

		nincludes += sendtolist(buf, ctladdr, sendq, aliaslevel + 1, e);

		if (forwarding &&
		    MaxForwardEntries > 0 &&
		    nincludes >= MaxForwardEntries)
		{
			/* just stop reading and processing further entries */
#if 0
			/* additional: (?) */
			ctladdr->q_state = QS_DONTSEND;
#endif /* 0 */

			syserr("Attempt to forward to more than %d addresses (in %s)!",
				MaxForwardEntries, fname);
			maxreached = true;
		}
	}

	if (sm_io_error(fp) && tTd(27, 3))
		sm_dprintf("include: read error: %s\n", sm_errstring(errno));
	if (nincludes > 0 && !bitset(QSELFREF, ctladdr->q_flags))
	{
		if (aliaslevel <= MaxAliasRecursion ||
		    ctladdr->q_state != QS_BADADDR)
		{
			ctladdr->q_state = QS_DONTSEND;
			if (tTd(27, 5))
			{
				sm_dprintf("include: QS_DONTSEND ");
				printaddr(sm_debug_file(), ctladdr, false);
			}
		}
	}

	(void) sm_io_close(fp, SM_TIME_DEFAULT);
	FileName = oldfilename;
	LineNumber = oldlinenumber;
	e->e_to = oldto;
	return rval;
}

static void
includetimeout(ignore)
	int ignore;
{
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
	longjmp(CtxIncludeTimeout, 1);
}

/*
**  SENDTOARGV -- send to an argument vector.
**
**	Parameters:
**		argv -- argument vector to send to.
**		e -- the current envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		puts all addresses on the argument vector onto the
**			send queue.
*/

void
sendtoargv(argv, e)
	register char **argv;
	register ENVELOPE *e;
{
	register char *p;

	while ((p = *argv++) != NULL)
		(void) sendtolist(p, NULLADDR, &e->e_sendqueue, 0, e);
}

/*
**  GETCTLADDR -- get controlling address from an address header.
**
**	If none, get one corresponding to the effective userid.
**
**	Parameters:
**		a -- the address to find the controller of.
**
**	Returns:
**		the controlling address.
*/

ADDRESS *
getctladdr(a)
	register ADDRESS *a;
{
	while (a != NULL && !bitset(QGOODUID, a->q_flags))
		a = a->q_alias;
	return a;
}

/*
**  SELF_REFERENCE -- check to see if an address references itself
**
**	The check is done through a chain of aliases.  If it is part of
**	a loop, break the loop at the "best" address, that is, the one
**	that exists as a real user.
**
**	This is to handle the case of:
**		awc:		Andrew.Chang
**		Andrew.Chang:	awc@@mail.server
**	which is a problem only on mail.server.
**
**	Parameters:
**		a -- the address to check.
**
**	Returns:
**		The address that should be retained.
*/

static ADDRESS *
self_reference(a)
	ADDRESS *a;
{
	ADDRESS *b;		/* top entry in self ref loop */
	ADDRESS *c;		/* entry that point to a real mail box */

	if (tTd(27, 1))
		sm_dprintf("self_reference(%s)\n", a->q_paddr);

	for (b = a->q_alias; b != NULL; b = b->q_alias)
	{
		if (sameaddr(a, b))
			break;
	}

	if (b == NULL)
	{
		if (tTd(27, 1))
			sm_dprintf("\t... no self ref\n");
		return NULL;
	}

	/*
	**  Pick the first address that resolved to a real mail box
	**  i.e has a mbdb entry.  The returned value will be marked
	**  QSELFREF in recipient(), which in turn will disable alias()
	**  from marking it as QS_IS_DEAD(), which mean it will be used
	**  as a deliverable address.
	**
	**  The 2 key thing to note here are:
	**	1) we are in a recursive call sequence:
	**		alias->sendtolist->recipient->alias
	**	2) normally, when we return back to alias(), the address
	**	   will be marked QS_EXPANDED, since alias() assumes the
	**	   expanded form will be used instead of the current address.
	**	   This behaviour is turned off if the address is marked
	**	   QSELFREF.  We set QSELFREF when we return to recipient().
	*/

	c = a;
	while (c != NULL)
	{
		if (tTd(27, 10))
			sm_dprintf("  %s", c->q_user);
		if (bitnset(M_HASPWENT, c->q_mailer->m_flags))
		{
			SM_MBDB_T user;

			if (tTd(27, 2))
				sm_dprintf("\t... getpwnam(%s)... ", c->q_user);
			if (sm_mbdb_lookup(c->q_user, &user) == EX_OK)
			{
				if (tTd(27, 2))
					sm_dprintf("found\n");

				/* ought to cache results here */
				if (sameaddr(b, c))
					return b;
				else
					return c;
			}
			if (tTd(27, 2))
				sm_dprintf("failed\n");
		}
		else
		{
			/* if local delivery, compare usernames */
			if (bitnset(M_LOCALMAILER, c->q_mailer->m_flags) &&
			    b->q_mailer == c->q_mailer)
			{
				if (tTd(27, 2))
					sm_dprintf("\t... local match (%s)\n",
						c->q_user);
				if (sameaddr(b, c))
					return b;
				else
					return c;
			}
		}
		if (tTd(27, 10))
			sm_dprintf("\n");
		c = c->q_alias;
	}

	if (tTd(27, 1))
		sm_dprintf("\t... cannot break loop for \"%s\"\n", a->q_paddr);

	return NULL;
}
@


1.19
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.18
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003, 2006 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: recipient.c,v 8.350 2013/03/12 15:24:54 ca Exp $")
@


1.17
log
@Update to sendmail-8.14.3
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: recipient.c,v 8.349 2007/07/10 17:01:22 ca Exp $")
d1827 1
a1827 1
	while (sm_io_fgets(fp, SM_TIME_DEFAULT, buf, sizeof(buf)) != NULL &&
@


1.16
log
@Update to sendmail-8.14.1
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: recipient.c,v 8.348 2007/03/19 21:33:09 ca Exp $")
d380 6
@


1.15
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: recipient.c,v 8.344 2007/02/01 05:12:14 ca Exp $")
d430 1
a430 2
**
**	Saves the named person for future mailing.
d1878 2
a1879 1
		if (tTd(27, 5))
d1881 6
a1886 2
			sm_dprintf("include: QS_DONTSEND ");
			printaddr(sm_debug_file(), ctladdr, false);
a1887 1
		ctladdr->q_state = QS_DONTSEND;
@


1.14
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: recipient.c,v 8.337 2004/08/03 19:57:23 ca Exp $")
d203 1
a203 1
	if (i <= sizeof buf)
d206 1
a206 1
		i = sizeof buf;
d312 1
d368 1
a368 1
	if (i <= sizeof buf)
d371 1
a371 1
		i = sizeof buf;
d391 1
a391 1
			if (parseaddr(p, &a, RF_COPYALL,
d427 1
d508 1
a508 1
			(void) sm_snprintf(frbuf, sizeof frbuf, "%s; %.800s",
d514 1
a514 1
			(void) sm_snprintf(frbuf, sizeof frbuf, "%s; %.800s",
d533 1
a533 1
			(void) sm_snprintf(frbuf, sizeof frbuf, "%s; %.800s",
d542 1
a542 1
			(void) sm_snprintf(frbuf, sizeof frbuf,
d567 1
a567 1
			(void) sm_strlcpyn(obuf, sizeof obuf, 2, p, ";");
d582 1
a582 1
			p = xtextify(denlstring(qp, true, false), NULL);
d584 1
a584 1
			if (sm_strlcat(obuf, p, sizeof obuf) >= sizeof obuf)
d606 12
d630 1
a630 1
	if (i >= sizeof buf0)
d638 1
a638 1
		buflen = sizeof buf0;
d921 2
a922 1
				e->e_message = "Deferred: user database error";
d1124 1
a1124 1
	(void) sm_snprintf(buf0, sizeof buf0, "%d", e->e_nrcpts);
d1128 1
d1241 1
a1241 1
		sm_pwfullname(pw->pw_gecos, pw->pw_name, buf, sizeof buf);
d1267 1
d1371 1
d1822 1
a1822 1
	while (sm_io_fgets(fp, SM_TIME_DEFAULT, buf, sizeof buf) != NULL &&
d1907 1
d1933 1
d1954 1
@


1.13
log
@Update to sendmail-8.13.1
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: recipient.c,v 8.336 2004/07/23 20:45:02 gshapiro Exp $")
d18 1
a18 1
static void	includetimeout __P((void));
d1877 2
a1878 1
includetimeout()
@


1.12
log
@Update to sendmail.8.13.0
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: recipient.c,v 8.335 2003/10/06 20:37:56 ca Exp $")
d1312 14
a1325 3
		euid = FileMailer->m_uid;
		egid = FileMailer->m_gid;
		user = NULL;
@


1.11
log
@Update to sendmail 8.12.11.  I've been runninga beta version of this for
some time without problems.  See the RELEASE_NOTES for the change log.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: recipient.c,v 8.330.2.4 2003/10/06 20:43:29 ca Exp $")
d186 1
a186 1
		printaddr(ctladdr, false);
d248 1
a248 1
						printaddr(ctladdr, false);
d261 1
a261 1
						printaddr(b, false);
d268 1
a268 1
							printaddr(a, false);
d406 1
a406 1
						printaddr(&a, false);
d479 1
a479 1
		printaddr(new, false);
d730 1
a730 1
					printaddr(q, false);
d803 1
a803 1
		printaddr(new, false);
d933 1
a933 1
		printaddr(new, false);
d1031 1
a1031 1
		printaddr(new, false);
d1035 1
a1035 1
			printaddr(*sendq, true);
d1420 1
a1420 1
		printaddr(ctladdr, false);
d1853 1
a1853 1
			printaddr(ctladdr, false);
@


1.10
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: recipient.c,v 8.330.2.2 2003/09/16 19:56:25 ca Exp $")
d400 2
a401 1
				    sameaddr(q, &a))
@


1.9
log
@update to sendmail 8.12.7
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: recipient.c,v 8.330.2.1 2002/08/27 20:21:02 gshapiro Exp $")
d172 1
d210 1
d222 2
d227 1
d231 1
@


1.8
log
@Update to sendmail-8.12.4
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: recipient.c,v 8.330 2002/05/29 18:20:03 gshapiro Exp $")
d682 1
a682 1
	if (WILL_BE_QUEUED(e->e_sendmode) ||
@


1.7
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: recipient.c,v 8.327 2001/11/20 13:59:53 ca Exp $")
d1422 1
a1422 1
		sfflags |= SFF_MUSTOWN|SFF_ROOTOK|SFF_NOWLINK;
d1505 1
a1505 1
					uid, getuid(), geteuid());
d1514 1
a1514 1
					uid, getuid(), geteuid());
d1834 1
a1834 1
				MaxForwardEntries,fname);
@


1.6
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: recipient.c,v 8.325 2001/09/11 04:05:16 gshapiro Exp $")
a153 3
**
**	Side Effects:
**		none.
d785 3
a1401 1
	bool oldsplit;
a1785 2
	oldsplit = bitset(EF_SPLIT, e->e_flags);
	e->e_flags &= ~EF_SPLIT;
d1833 1
a1833 1
			syserr("Attempt to forward to more then %d addresses (in %s)!",
a1849 4

	/* if nothing included: restore old split flag */
	if (nincludes <= 0 && oldsplit)
		e->e_flags |= EF_SPLIT;
@


1.5
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: recipient.c,v 8.322 2001/09/04 22:43:05 ca Exp $")
d310 1
a310 1
/*
d422 1
a422 1
/*
d1106 1
a1106 1
/*
d1244 1
a1244 1
/*
d1336 1
a1336 1
/*
d1877 1
a1877 1
/*
d1902 1
a1902 1
/*
d1922 1
a1922 1
/*
@


1.4
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@a13 4
#ifndef lint
static char id[] = "@@(#)$Sendmail: recipient.c,v 8.231.14.11 2001/05/03 17:24:14 gshapiro Exp $";
#endif /* ! lint */

d16 1
d20 113
d171 4
a174 4
	register ADDRESS *al;	/* list of addresses to send to */
	char delimiter;		/* the address delimiter */
	int naddrs;
	int i;
d176 1
a176 1
	char *bufp;
d187 2
a188 2
		dprintf("sendto: %s\n   ctladdr=", list);
		printaddr(ctladdr, FALSE);
d211 1
a211 2
		bufp = xalloc(i);
	(void) strlcpy(bufp, denlstring(list, FALSE, TRUE), i);
d213 3
a215 17
#if _FFR_ADDR_TYPE
	define(macid("{addr_type}", NULL), "e r", e);
#endif /* _FFR_ADDR_TYPE */
	for (p = bufp; *p != '\0'; )
	{
		auto char *delimptr;
		register ADDRESS *a;

		/* parse the address */
		while ((isascii(*p) && isspace(*p)) || *p == ',')
			p++;
		a = parseaddr(p, NULLADDR, RF_COPYALL, delimiter, &delimptr, e);
		p = delimptr;
		if (a == NULL)
			continue;
		a->q_next = al;
		a->q_alias = ctladdr;
d217 2
a218 2
		/* arrange to inherit attributes from parent */
		if (ctladdr != NULL)
d220 2
a221 1
			ADDRESS *b;
d223 13
a235 2
			/* self reference test */
			if (sameaddr(ctladdr, a))
d237 4
a240 1
				if (tTd(27, 5))
d242 6
a247 2
					dprintf("sendtolist: QSELFREF ");
					printaddr(ctladdr, FALSE);
a248 2
				ctladdr->q_flags |= QSELFREF;
			}
d250 3
a252 11
			/* check for address loops */
			b = self_reference(a);
			if (b != NULL)
			{
				b->q_flags |= QSELFREF;
				if (tTd(27, 5))
				{
					dprintf("sendtolist: QSELFREF ");
					printaddr(b, FALSE);
				}
				if (a != b)
d254 1
d257 13
a269 2
						dprintf("sendtolist: QS_DONTSEND ");
						printaddr(a, FALSE);
a270 3
					a->q_state = QS_DONTSEND;
					b->q_flags |= a->q_flags & QNOTREMOTE;
					continue;
d272 12
d286 2
a287 3
			/* full name */
			if (a->q_fullname == NULL)
				a->q_fullname = ctladdr->q_fullname;
d289 4
a292 3
			/* various flag bits */
			a->q_flags &= ~QINHERITEDBITS;
			a->q_flags |= ctladdr->q_flags & QINHERITEDBITS;
d294 3
a296 2
			/* original recipient information */
			a->q_orcpt = ctladdr->q_orcpt;
a297 2

		al = a;
d299 1
a299 3

	/* arrange to send to everyone on the local send list */
	while (al != NULL)
d301 4
a304 5
		register ADDRESS *a = al;

		al = a->q_next;
		a = recipient(a, sendq, aliaslevel, e);
		naddrs++;
d306 1
a306 7

	e->e_to = oldto;
	if (bufp != buf)
		sm_free(bufp);
#if _FFR_ADDR_TYPE
	define(macid("{addr_type}", NULL), NULL, e);
#endif /* _FFR_ADDR_TYPE */
d309 1
d315 1
a315 1
**	have been expended already in the sendq, it won't mark the
d335 3
a337 3
	char delimiter;		/* the address delimiter */
	int naddrs;
	int i;
d340 1
a340 1
	char *bufp;
d350 1
a350 1
		dprintf("removefromlist: %s\n", list);
d370 1
a370 2
		bufp = xalloc(i);
	(void) strlcpy(bufp, denlstring(list, FALSE, TRUE), i);
d372 6
a377 15
#if _FFR_ADDR_TYPE
	define(macid("{addr_type}", NULL), "e r", e);
#endif /* _FFR_ADDR_TYPE */
	for (p = bufp; *p != '\0'; )
	{
		ADDRESS a;		/* parsed address to be removed */
		ADDRESS *q;
		ADDRESS **pq;
		char *delimptr;

		/* parse the address */
		while ((isascii(*p) && isspace(*p)) || *p == ',')
			p++;
		if (parseaddr(p, &a, RF_COPYALL,
			      delimiter, &delimptr, e) == NULL)
d379 14
d394 1
a394 7
			continue;
		}
		p = delimptr;
		for (pq = sendq; (q = *pq) != NULL; pq = &q->q_next)
		{
			if (!QS_IS_DEAD(q->q_state) &&
			    sameaddr(q, &a))
d396 2
a397 1
				if (tTd(25, 5))
d399 8
a406 2
					dprintf("removefromlist: QS_REMOVED ");
					printaddr(&a, FALSE);
a407 3
				q->q_state = QS_REMOVED;
				naddrs++;
				break;
d411 8
a418 7

	e->e_to = oldto;
	if (bufp != buf)
		sm_free(bufp);
#if _FFR_ADDR_TYPE
	define(macid("{addr_type}", NULL), NULL, e);
#endif /* _FFR_ADDR_TYPE */
d421 1
d428 1
a428 1
**		a -- the (preparsed) address header for the recipient.
a438 2
**	Side Effects:
**		none.
d442 2
a443 2
recipient(a, sendq, aliaslevel, e)
	register ADDRESS *a;
d450 1
d452 1
a452 4
	register char *p = NULL;
	bool quoted = FALSE;		/* set if the addr has a quote bit */
	int findusercount = 0;
	bool initialdontsend = QS_IS_DEAD(a->q_state);
d454 4
d460 1
d462 7
a468 2
	e->e_to = a->q_paddr;
	m = a->q_mailer;
d471 1
a471 1
		a->q_flags |= QPRIMARY;
d474 2
a475 2
		dprintf("\nrecipient (%d): ", aliaslevel);
		printaddr(a, FALSE);
d478 2
a479 2
	/* if this is primary, add it to the original recipient list */
	if (a->q_alias == NULL)
d482 2
a483 2
			e->e_origrcpt = a->q_paddr;
		else if (e->e_origrcpt != a->q_paddr)
d487 56
d545 1
a545 1
	if (a->q_orcpt == NULL)
a546 3
		for (q = a; q->q_alias != NULL; q = q->q_alias)
			continue;

d549 1
a549 1
			a->q_orcpt = q->q_orcpt;
d553 1
a553 1
			bool b = FALSE;
d561 1
a561 2
			(void) strlcpy(obuf, p, sizeof obuf);
			(void) strlcat(obuf, ";", sizeof obuf);
d576 1
a576 1
			p = xtextify(denlstring(qp, TRUE, FALSE), NULL);
d578 1
a578 1
			if (strlcat(obuf, p, sizeof obuf) >= sizeof obuf)
d589 2
a590 1
				a->q_orcpt = newstr(obuf);
d598 3
a600 3
		a->q_state = QS_BADADDR;
		a->q_status = "5.4.6";
		usrerrenh(a->q_status,
d603 1
a603 1
		return a;
d611 1
a611 1
	i = strlen(a->q_user);
d622 1
a622 1
	(void) strlcpy(buf, a->q_user, buflen);
d626 1
a626 1
			quoted = TRUE;
d633 2
a634 1
		if (a->q_alias == NULL)
d636 3
a638 3
			a->q_state = QS_BADADDR;
			a->q_status = "5.7.1";
			usrerrenh(a->q_status,
d641 1
a641 1
		else if (bitset(QBOGUSSHELL, a->q_alias->q_flags))
d643 4
a646 4
			a->q_state = QS_BADADDR;
			a->q_status = "5.7.1";
			if (a->q_alias->q_ruser == NULL)
				usrerrenh(a->q_status,
d648 1
a648 1
					  a->q_alias->q_uid);
d650 1
a650 1
				usrerrenh(a->q_status,
d652 1
a652 1
					  a->q_alias->q_ruser, MyHostName);
d654 1
a654 1
		else if (bitset(QUNSAFEADDR, a->q_alias->q_flags))
d656 4
a659 4
			a->q_state = QS_BADADDR;
			a->q_status = "5.7.1";
			a->q_rstatus = newstr("550 Unsafe for mailing to programs");
			usrerrenh(a->q_status,
d661 1
a661 1
				  a->q_alias->q_paddr);
d674 20
d696 25
a720 5
		if (sameaddr(q, a) &&
		    (bitset(QRCPTOK, q->q_flags) ||
		     !bitset(QPRIMARY, q->q_flags)))
		{
			if (tTd(26, 1))
d722 28
a749 2
				dprintf("%s in sendq: ", a->q_paddr);
				printaddr(q, FALSE);
a750 25
			if (!bitset(QPRIMARY, q->q_flags))
			{
				if (!QS_IS_DEAD(a->q_state))
					message("duplicate suppressed");
				else
					q->q_state = QS_DUPLICATE;
				q->q_flags |= a->q_flags;
			}
			else if (bitset(QSELFREF, q->q_flags)
#if _FFR_MILTER
				 || q->q_state == QS_REMOVED
#endif /* _FFR_MILTER */
				 )
			{
#if _FFR_MILTER
				/*
				**  If an earlier milter removed the address,
				**  a later one can still add it back.
				*/
#endif /* _FFR_MILTER */
				q->q_state = a->q_state;
				q->q_flags |= a->q_flags;
			}
			a = q;
			goto done;
d752 6
d760 3
d764 1
a764 1
	if (pq != NULL)
d766 20
a785 2
		*pq = a;
		a->q_next = NULL;
d795 2
a796 2
		dprintf("at trylocaluser: ");
		printaddr(a, FALSE);
d799 4
a802 1
	if (!QS_IS_OK(a->q_state))
d804 1
d808 7
a814 6
		a->q_state = QS_INCLUDED;
		if (a->q_alias == NULL)
		{
			a->q_state = QS_BADADDR;
			a->q_status = "5.7.1";
			usrerrenh(a->q_status,
d821 3
a823 2
			message("including file %s", a->q_user);
			ret = include(a->q_user, FALSE, a, sendq, aliaslevel, e);
d829 4
a832 3
						  shortenstring(a->q_user, MAXSHORTSTR),
						  errstring(ret));
				a->q_state = QS_QUEUEUP;
d834 3
a836 2
					shortenstring(a->q_user, MAXSHORTSTR),
					errstring(ret));
d840 3
a842 3
				a->q_state = QS_BADADDR;
				a->q_status = "5.2.4";
				usrerrenh(a->q_status,
d844 3
a846 2
					  shortenstring(a->q_user, MAXSHORTSTR),
					  errstring(ret));
d852 7
a858 6
		/* check if writable or creatable */
		if (a->q_alias == NULL)
		{
			a->q_state = QS_BADADDR;
			a->q_status = "5.7.1";
			usrerrenh(a->q_status,
d861 1
a861 1
		else if (bitset(QBOGUSSHELL, a->q_alias->q_flags))
d863 4
a866 4
			a->q_state = QS_BADADDR;
			a->q_status = "5.7.1";
			if (a->q_alias->q_ruser == NULL)
				usrerrenh(a->q_status,
d868 1
a868 1
					  a->q_alias->q_uid);
d870 1
a870 1
				usrerrenh(a->q_status,
d872 1
a872 1
					  a->q_alias->q_ruser, MyHostName);
d874 1
a874 1
		else if (bitset(QUNSAFEADDR, a->q_alias->q_flags))
d876 4
a879 4
			a->q_state = QS_BADADDR;
			a->q_status = "5.7.1";
			a->q_rstatus = newstr("550 Unsafe for mailing to files");
			usrerrenh(a->q_status,
d881 1
a881 1
				  a->q_alias->q_paddr);
d886 1
a886 1
	if (!quoted && QS_IS_OK(a->q_state) &&
d888 1
a888 1
		alias(a, sendq, aliaslevel, e);
d892 2
a893 2
	if (!bitset(QNOTREMOTE, a->q_flags) &&
	    QS_IS_SENDABLE(a->q_state) &&
d896 1
a896 1
		if (udbexpand(a, sendq, aliaslevel, e) == EX_TEMPFAIL)
d898 1
a898 1
			a->q_state = QS_QUEUEUP;
d900 3
a902 1
				e->e_message = newstr("Deferred: user database error");
d906 1
a906 1
					  errstring(errno));
d908 1
a908 1
				errstring(errno));
d918 1
a918 1
	**  to send rewrite it to another mailer.  This gives us a hook
d924 3
a926 3
		dprintf("recipient: testing local?  cl=%d, rr5=%lx\n\t",
			ConfigLevel, (u_long) RewriteRules[5]);
		printaddr(a, FALSE);
d930 2
a931 2
	    !bitset(QNOTREMOTE, a->q_flags) &&
	    QS_IS_OK(a->q_state))
d933 1
a933 1
		maplocaluser(a, sendq, aliaslevel + 1, e);
d941 1
a941 1
	if (QS_IS_OK(a->q_state) &&
d945 2
a946 1
		register struct passwd *pw;
d949 2
a950 2
		pw = finduser(buf, &fuzzy);
		if (pw == NULL || strlen(pw->pw_name) > MAXNAME)
d952 14
a965 12
			{
				a->q_state = QS_BADADDR;
				a->q_status = "5.1.1";
				a->q_rstatus = newstr("550 5.1.1 User unknown");
				giveresponse(EX_NOUSER, a->q_status, m, NULL,
					     a->q_alias, (time_t) 0, e);
			}
		}
		else
		{
			char nbuf[MAXNAME + 1];

d969 2
a970 1
				a->q_user = newstr(pw->pw_name);
d973 3
a975 3
					a->q_state = QS_BADADDR;
					a->q_status = "5.4.6";
					usrerrenh(a->q_status,
d977 1
a977 1
						  pw->pw_name);
d982 1
a982 1
				(void) strlcpy(buf, pw->pw_name, buflen);
d985 4
a988 4
			if (*pw->pw_dir == '\0')
				a->q_home = NULL;
			else if (strcmp(pw->pw_dir, "/") == 0)
				a->q_home = "";
d990 14
a1003 9
				a->q_home = newstr(pw->pw_dir);
			a->q_uid = pw->pw_uid;
			a->q_gid = pw->pw_gid;
			a->q_ruser = newstr(pw->pw_name);
			a->q_flags |= QGOODUID;
			buildfname(pw->pw_gecos, pw->pw_name, nbuf, sizeof nbuf);
			if (nbuf[0] != '\0')
				a->q_fullname = newstr(nbuf);
			if (!usershellok(pw->pw_name, pw->pw_shell))
d1005 1
a1005 1
				a->q_flags |= QBOGUSSHELL;
d1010 1
a1010 1
				a->q_state = QS_VERIFIED;
d1013 1
a1013 1
				forward(a, sendq, aliaslevel, e);
d1016 1
a1016 1
	if (!QS_IS_DEAD(a->q_state))
d1020 1
a1020 1
	a->q_flags |= QTHISPASS;
d1023 2
a1024 2
		dprintf("testselfdestruct: ");
		printaddr(a, FALSE);
d1027 3
a1029 3
			dprintf("SENDQ:\n");
			printaddr(*sendq, TRUE);
			dprintf("----\n");
d1032 2
a1033 2
	if (a->q_alias == NULL && a != &e->e_from &&
	    QS_IS_DEAD(a->q_state))
d1042 3
a1044 3
			a->q_state = QS_BADADDR;
			a->q_status = "5.4.6";
			usrerrenh(a->q_status,
d1050 1
a1050 1
	a->q_flags |= QTHISPASS;
d1052 1
a1052 1
		sm_free(buf);
d1093 1
a1093 1
			a->q_flags |= QEXPANDED;
d1095 4
a1098 4
			    bitset(QPINGONSUCCESS, a->q_flags))
				fprintf(e->e_xfp,
					"%s... expanded to multiple addresses\n",
					a->q_paddr);
d1101 4
a1104 2
	a->q_flags |= QRCPTOK;
	return a;
d1117 1
a1117 1
**		fuzzyp -- an outarg that is set to TRUE if this entry
d1119 2
a1120 1
**			set to FALSE otherwise.
d1123 3
a1125 2
**		A pointer to a pw struct.
**		NULL if name is unknown or ambiguous.
d1131 2
a1132 2
struct passwd *
finduser(name, fuzzyp)
d1135 1
d1137 1
d1139 1
d1142 1
d1145 1
a1145 1
		dprintf("finduser(%s): ", name);
d1147 1
a1147 1
	*fuzzyp = FALSE;
d1149 1
a1149 1
#ifdef HESIOD
d1157 2
a1158 2
			dprintf("failed (numeric input)\n");
		return NULL;
d1163 2
a1164 1
	if ((pw = sm_getpwnam(name)) != NULL)
d1167 2
a1168 2
			dprintf("found (non-fuzzy)\n");
		return pw;
d1172 1
a1172 1
	tryagain = FALSE;
d1178 1
a1178 1
			tryagain = TRUE;
d1181 1
a1181 1
	if (tryagain && (pw = sm_getpwnam(name)) != NULL)
d1184 3
a1186 3
			dprintf("found (lower case)\n");
		*fuzzyp = TRUE;
		return pw;
d1194 2
a1195 2
			dprintf("not found (fuzzy disabled)\n");
		return NULL;
d1210 1
a1210 1
		if (strcasecmp(pw->pw_name, name) == 0)
d1213 1
a1213 1
				dprintf("found (case wrapped)\n");
d1218 2
a1219 2
		buildfname(pw->pw_gecos, pw->pw_name, buf, sizeof buf);
		if (strchr(buf, ' ') != NULL && strcasecmp(buf, name) == 0)
d1222 1
a1222 1
				dprintf("fuzzy matches %s\n", pw->pw_name);
d1228 1
a1228 1
		*fuzzyp = TRUE;
d1230 1
a1230 1
		dprintf("no fuzzy match found\n");
d1234 4
a1237 1
	return pw;
d1240 2
a1241 2
		dprintf("not found (fuzzy disabled)\n");
	return NULL;
d1261 2
a1262 2
**		TRUE -- if we will be able to write this file.
**		FALSE -- if we cannot write this file.
d1279 1
a1279 1
		dprintf("writable(%s, 0x%lx)\n", filename, flags);
d1341 2
a1342 2
**		forwarding -- if TRUE, we are reading a .forward file.
**			if FALSE, it's a :include: file.
d1383 1
a1383 1
	FILE *volatile fp = NULL;
d1387 1
a1387 1
	register EVENT *ev = NULL;
d1390 1
a1390 1
	volatile bool maxreached = FALSE;
d1400 3
a1402 2
	bool safechown = FALSE;
	volatile bool safedir = FALSE;
d1407 1
a1407 1
		dprintf("include(%s)\n", fname);
d1409 1
a1409 1
		dprintf("   ruid=%d euid=%d\n",
d1413 2
a1414 2
		dprintf("ctladdr ");
		printaddr(ctladdr, FALSE);
d1418 2
a1419 2
		dprintf("include: old uid = %d/%d\n",
			(int) getuid(), (int) geteuid());
a1420 1
#if _FFR_UNSAFE_WRITABLE_INCLUDE
d1423 1
a1435 4
#endif /* _FFR_UNSAFE_WRITABLE_INCLUDE */

	if (forwarding)
		sfflags |= SFF_MUSTOWN|SFF_ROOTOK|SFF_NOWLINK;
d1446 2
a1447 2
			dprintf("include: not safe (euid=%d, RunAsUid=%d)\n",
				(int) geteuid(), (int) RunAsUid);
d1524 2
a1525 2
		dprintf("include: new uid = %d/%d\n",
			(int) getuid(), (int) geteuid());
d1542 1
a1542 1
		ev = setevent(TimeOuts.to_fileopen, includetimeout, 0);
d1559 1
a1559 1
			safedir = TRUE;
d1595 1
a1595 1
				if (LogLevel >= 12)
d1618 2
a1619 2
			dprintf("include: not safe (uid=%d): %s\n",
				(int) uid, errstring(rval));
d1621 2
a1622 1
	else if ((fp = fopen(fname, "r")) == NULL)
d1626 1
a1626 1
			dprintf("include: open: %s\n", errstring(rval));
d1628 1
a1628 1
	else if (filechanged(fname, fileno(fp), &st))
d1632 1
a1632 1
			dprintf("include: file changed after open\n");
d1635 1
a1635 1
		clrevent(ev);
d1647 1
a1647 1
					getuid(), geteuid());
d1651 1
a1651 1
					getuid(), geteuid());
d1654 2
a1655 1
					RealUid, getuid(), geteuid());
d1660 2
a1661 1
			       savedgid, getgid(), getegid());
d1666 2
a1667 2
		dprintf("include: reset uid = %d/%d\n",
			(int) getuid(), (int) geteuid());
d1675 1
a1675 1
	if (fstat(fileno(fp), &st) < 0)
d1679 1
a1679 1
		(void) fclose(fp);
d1684 1
a1684 1
	safechown = chownsafe(fileno(fp), safedir);
d1686 3
a1688 4
		dprintf("include: parent of %s is %s, chown is %ssafe\n",
			fname,
			safedir ? "safe" : "dangerous",
			safechown ? "" : "un");
d1719 2
a1720 1
			ctladdr->q_ruser = newstr(pw->pw_name);
d1727 1
a1727 1
				if (LogLevel >= 12)
d1730 2
a1731 1
						  shortenstring(fname, MAXSHORTSTR),
d1747 1
a1747 1
		(void) fclose(fp);
d1769 5
a1773 4
			dprintf("include: %s is %s writable, marked unsafe\n",
				shortenstring(fname, MAXSHORTSTR),
				bitset(S_IWOTH, st.st_mode) ? "world" : "group");
		if (LogLevel >= 12)
d1787 4
a1790 1
	while (fgets(buf, sizeof buf, fp) != NULL && !maxreached)
d1792 1
a1792 1
		fixcrlf(buf, TRUE);
d1831 2
a1832 1
			/* additional: (?)
d1834 2
a1835 1
			**/
d1838 1
a1838 1
			maxreached = TRUE;
d1842 2
a1843 2
	if (ferror(fp) && tTd(27, 3))
		dprintf("include: read error: %s\n", errstring(errno));
d1848 2
a1849 2
			dprintf("include: QS_DONTSEND ");
			printaddr(ctladdr, FALSE);
d1854 5
a1858 1
	(void) fclose(fp);
a1899 1
	{
a1900 1
	}
a1911 3
**
**	Side Effects:
**		none.
d1949 1
a1949 1
		dprintf("self_reference(%s)\n", a->q_paddr);
d1960 1
a1960 1
			dprintf("\t... no self ref\n");
d1966 1
a1966 1
	**  i.e has a pw entry.  The returned value will be marked
d1973 1
a1973 1
	**		alias->sentolist->recipient->alias
d1978 1
a1978 1
	**	   QSELFREF We set QSELFREF when we return to recipient().
d1985 1
a1985 1
			dprintf("  %s", c->q_user);
d1988 2
d1991 2
a1992 2
				dprintf("\t... getpwnam(%s)... ", c->q_user);
			if (sm_getpwnam(c->q_user) != NULL)
d1995 1
a1995 1
					dprintf("found\n");
d2004 1
a2004 1
				dprintf("failed\n");
d2013 1
a2013 1
					dprintf("\t... local match (%s)\n",
d2022 1
a2022 1
			dprintf("\n");
d2027 1
a2027 1
		dprintf("\t... cannot break loop for \"%s\"\n", a->q_paddr);
@


1.3
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: recipient.c,v 8.231.14.10 2001/02/14 04:07:30 gshapiro Exp $";
d188 1
a188 1
		free(bufp);
d296 1
a296 1
		free(bufp);
d783 1
a783 1
		free(buf);
d1576 7
@


1.3.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: recipient.c,v 8.231.14.11 2001/05/03 17:24:14 gshapiro Exp $";
d188 1
a188 1
		sm_free(bufp);
d296 1
a296 1
		sm_free(bufp);
d783 1
a783 1
		sm_free(buf);
a1575 7
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
@


1.2
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: recipient.c,v 8.231.14.8 2000/09/14 23:32:27 gshapiro Exp $";
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: recipient.c,v 8.231 2000/01/05 01:40:53 gshapiro Exp $";
d20 1
d513 5
a517 1
			else if (bitset(QSELFREF, q->q_flags))
d519 6
d691 7
a697 5
			a->q_state = QS_BADADDR;
			a->q_status = "5.1.1";
			a->q_rstatus = newstr("550 5.1.1 User unknown");
			giveresponse(EX_NOUSER, a->q_status, m, NULL,
				     a->q_alias, (time_t) 0, e);
d721 3
a723 1
			if (strcmp(pw->pw_dir, "/") == 0)
d941 1
a941 1
		if (strchr(buf, ' ') != NULL && !strcasecmp(buf, name))
d993 3
a995 3
	uid_t euid;
	gid_t egid;
	char *user;
d1111 4
a1114 2
	volatile uid_t saveduid, uid;
	volatile gid_t savedgid, gid;
d1139 17
d1195 2
d1199 2
d1208 2
d1211 2
d1216 2
d1219 2
d1225 2
d1229 2
d1234 2
d1238 2
d1268 1
d1367 1
a1367 1
				syserr("seteuid(0) failure (real=%d, eff=%d)",
d1371 1
a1371 1
				syserr("setreuid(-1, 0) failure (real=%d, eff=%d)",
d1374 1
a1374 1
				syserr("setreuid(%d, 0) failure (real=%d, eff=%d)",
d1378 3
a1380 1
		(void) setgid(savedgid);
d1519 5
a1523 1
				p[-1] = '\0';
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.1.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: recipient.c,v 8.231.14.11 2001/05/03 17:24:14 gshapiro Exp $";
a19 1

d187 1
a187 1
		sm_free(bufp);
d295 1
a295 1
		sm_free(bufp);
d512 1
a512 5
			else if (bitset(QSELFREF, q->q_flags)
#if _FFR_MILTER
				 || q->q_state == QS_REMOVED
#endif /* _FFR_MILTER */
				 )
a513 6
#if _FFR_MILTER
				/*
				**  If an earlier milter removed the address,
				**  a later one can still add it back.
				*/
#endif /* _FFR_MILTER */
d680 5
a684 7
			{
				a->q_state = QS_BADADDR;
				a->q_status = "5.1.1";
				a->q_rstatus = newstr("550 5.1.1 User unknown");
				giveresponse(EX_NOUSER, a->q_status, m, NULL,
					     a->q_alias, (time_t) 0, e);
			}
d708 1
a708 3
			if (*pw->pw_dir == '\0')
				a->q_home = NULL;
			else if (strcmp(pw->pw_dir, "/") == 0)
d768 1
a768 1
		sm_free(buf);
d926 1
a926 1
		if (strchr(buf, ' ') != NULL && strcasecmp(buf, name) == 0)
d978 3
a980 3
	uid_t euid = 0;
	gid_t egid = 0;
	char *user = NULL;
d1096 2
a1097 4
	volatile uid_t saveduid;
	volatile gid_t savedgid;
	volatile uid_t uid;
	volatile gid_t gid;
a1121 17
#if _FFR_UNSAFE_WRITABLE_INCLUDE
	if (forwarding)
	{
		if (!bitnset(DBS_GROUPWRITABLEFORWARDFILE, DontBlameSendmail))
			sfflags |= SFF_NOGWFILES;
		if (!bitnset(DBS_WORLDWRITABLEFORWARDFILE, DontBlameSendmail))
			sfflags |= SFF_NOWWFILES;
	}
	else
	{
		if (!bitnset(DBS_GROUPWRITABLEINCLUDEFILE, DontBlameSendmail))
			sfflags |= SFF_NOGWFILES;
		if (!bitnset(DBS_WORLDWRITABLEINCLUDEFILE, DontBlameSendmail))
			sfflags |= SFF_NOWWFILES;
	}
#endif /* _FFR_UNSAFE_WRITABLE_INCLUDE */

a1160 2
			{
				rval = EAGAIN;
a1162 2
				goto resetuid;
			}
a1169 2
			{
				rval = EAGAIN;
a1170 2
				goto resetuid;
			}
a1173 2
		{
			rval = EAGAIN;
a1174 2
			goto resetuid;
		}
a1178 2
			{
				rval = EAGAIN;
a1180 2
				goto resetuid;
			}
a1183 2
			{
				rval = EAGAIN;
a1185 2
				goto resetuid;
			}
a1213 1

d1312 1
a1312 1
				syserr("!seteuid(0) failure (real=%d, eff=%d)",
d1316 1
a1316 1
				syserr("!setreuid(-1, 0) failure (real=%d, eff=%d)",
d1319 1
a1319 1
				syserr("!setreuid(%d, 0) failure (real=%d, eff=%d)",
d1323 1
a1323 3
		if (setgid(savedgid) < 0)
			syserr("!setgid(%d) failure (real=%d eff=%d)",
			       savedgid, getgid(), getegid());
d1462 1
a1462 5
				--p;
				while (p > buf && isascii(p[-1]) &&
				       isspace(p[-1]))
					--p;
				p[0] = '\0';
a1514 7
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Id: recipient.c,v 8.231.14.8 2000/09/14 23:32:27 gshapiro Exp $";
a19 1

d512 1
a512 5
			else if (bitset(QSELFREF, q->q_flags)
#if _FFR_MILTER
				 || q->q_state == QS_REMOVED
#endif /* _FFR_MILTER */
				 )
a513 6
#if _FFR_MILTER
				/*
				**  If an earlier milter removed the address,
				**  a later one can still add it back.
				*/
#endif /* _FFR_MILTER */
d680 5
a684 7
			{
				a->q_state = QS_BADADDR;
				a->q_status = "5.1.1";
				a->q_rstatus = newstr("550 5.1.1 User unknown");
				giveresponse(EX_NOUSER, a->q_status, m, NULL,
					     a->q_alias, (time_t) 0, e);
			}
d708 1
a708 3
			if (*pw->pw_dir == '\0')
				a->q_home = NULL;
			else if (strcmp(pw->pw_dir, "/") == 0)
d926 1
a926 1
		if (strchr(buf, ' ') != NULL && strcasecmp(buf, name) == 0)
d978 3
a980 3
	uid_t euid = 0;
	gid_t egid = 0;
	char *user = NULL;
d1096 2
a1097 4
	volatile uid_t saveduid;
	volatile gid_t savedgid;
	volatile uid_t uid;
	volatile gid_t gid;
a1121 17
#if _FFR_UNSAFE_WRITABLE_INCLUDE
	if (forwarding)
	{
		if (!bitnset(DBS_GROUPWRITABLEFORWARDFILE, DontBlameSendmail))
			sfflags |= SFF_NOGWFILES;
		if (!bitnset(DBS_WORLDWRITABLEFORWARDFILE, DontBlameSendmail))
			sfflags |= SFF_NOWWFILES;
	}
	else
	{
		if (!bitnset(DBS_GROUPWRITABLEINCLUDEFILE, DontBlameSendmail))
			sfflags |= SFF_NOGWFILES;
		if (!bitnset(DBS_WORLDWRITABLEINCLUDEFILE, DontBlameSendmail))
			sfflags |= SFF_NOWWFILES;
	}
#endif /* _FFR_UNSAFE_WRITABLE_INCLUDE */

a1160 2
			{
				rval = EAGAIN;
a1162 2
				goto resetuid;
			}
a1169 2
			{
				rval = EAGAIN;
a1170 2
				goto resetuid;
			}
a1173 2
		{
			rval = EAGAIN;
a1174 2
			goto resetuid;
		}
a1178 2
			{
				rval = EAGAIN;
a1180 2
				goto resetuid;
			}
a1183 2
			{
				rval = EAGAIN;
a1185 2
				goto resetuid;
			}
a1213 1

d1312 1
a1312 1
				syserr("!seteuid(0) failure (real=%d, eff=%d)",
d1316 1
a1316 1
				syserr("!setreuid(-1, 0) failure (real=%d, eff=%d)",
d1319 1
a1319 1
				syserr("!setreuid(%d, 0) failure (real=%d, eff=%d)",
d1323 1
a1323 3
		if (setgid(savedgid) < 0)
			syserr("!setgid(%d) failure (real=%d eff=%d)",
			       savedgid, getgid(), getegid());
d1462 1
a1462 5
				--p;
				while (p > buf && isascii(p[-1]) &&
				       isspace(p[-1]))
					--p;
				p[0] = '\0';
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d14 4
a19 1
SM_RCSID("@@(#)$Sendmail: recipient.c,v 8.322 2001/09/04 22:43:05 ca Exp $")
a22 113
static int	sortexpensive __P((ADDRESS *, ADDRESS *));
static int	sortbysignature __P((ADDRESS *, ADDRESS *));
static int	sorthost __P((ADDRESS *, ADDRESS *));

typedef int	sortfn_t __P((ADDRESS *, ADDRESS *));

/*
**  SORTHOST -- strcmp()-like func for host portion of an ADDRESS
**
**	Parameters:
**		xx -- first ADDRESS
**		yy -- second ADDRESS
**
**	Returns:
**		<0 when xx->q_host is less than yy->q_host
**		>0 when xx->q_host is greater than yy->q_host
**		0 when equal
*/

static int
sorthost(xx, yy)
	register ADDRESS *xx;
	register ADDRESS *yy;
{
#if _FFR_HOST_SORT_REVERSE
	/* XXX maybe compare hostnames from the end? */
	return sm_strrevcasecmp(xx->q_host, yy->q_host);
#else /* _FFR_HOST_SORT_REVERSE */
	return sm_strcasecmp(xx->q_host, yy->q_host);
#endif /* _FFR_HOST_SORT_REVERSE */
}

/*
**  SORTEXPENSIVE -- strcmp()-like func for expensive mailers
**
**  The mailer has been noted already as "expensive" for 'xx'. This
**  will give a result relative to 'yy'. Expensive mailers get rated
**  "greater than" non-expensive mailers because during the delivery phase
**  it will get queued -- no use it getting in the way of less expensive
**  recipients. We avoid an MX RR lookup when both 'xx' and 'yy' are
**  expensive since an MX RR lookup happens when extracted from the queue
**  later.
**
**	Parameters:
**		xx -- first ADDRESS
**		yy -- second ADDRESS
**
**	Returns:
**		<0 when xx->q_host is less than yy->q_host and both are
**			expensive
**		>0 when xx->q_host is greater than yy->q_host, or when
**			'yy' is non-expensive
**		0 when equal (by expense and q_host)
*/

static int
sortexpensive(xx, yy)
	ADDRESS *xx;
	ADDRESS *yy;
{
	if (!bitnset(M_EXPENSIVE, yy->q_mailer->m_flags))
		return 1; /* xx should go later */
#if _FFR_HOST_SORT_REVERSE
	/* XXX maybe compare hostnames from the end? */
	return sm_strrevcasecmp(xx->q_host, yy->q_host);
#else /* _FFR_HOST_SORT_REVERSE */
	return sm_strcasecmp(xx->q_host, yy->q_host);
#endif /* _FFR_HOST_SORT_REVERSE */
}

/*
**  SORTBYSIGNATURE -- a strcmp()-like func for q_mailer and q_host in ADDRESS
**
**	Parameters:
**		xx -- first ADDRESS
**		yy -- second ADDRESS
**
**	Returns:
**		0 when the "signature"'s are same
**		<0 when xx->q_signature is less than yy->q_signature
**		>0 when xx->q_signature is greater than yy->q_signature
**
**	Side Effect:
**		May set ADDRESS pointer for q_signature if not already set.
*/

static int
sortbysignature(xx, yy)
	ADDRESS *xx;
	ADDRESS *yy;
{
	register int ret;

	/* Let's avoid redoing the signature over and over again */
	if (xx->q_signature == NULL)
		xx->q_signature = hostsignature(xx->q_mailer, xx->q_host);
	if (yy->q_signature == NULL)
		yy->q_signature = hostsignature(yy->q_mailer, yy->q_host);
	ret = strcmp(xx->q_signature, yy->q_signature);

	/*
	**  If the two signatures are the same then we will return a sort
	**  value based on 'q_user'. But note that we have reversed xx and yy
	**  on purpose. This additional compare helps reduce the number of
	**  sameaddr() calls and loops in recipient() for the case when
	**  the rcpt list has been provided already in-order.
	*/

	if (ret == 0)
		return strcmp(yy->q_user, xx->q_user);
	else
		return ret;
}
d61 4
a64 4
	register ADDRESS *SM_NONVOLATILE al; /* list of addresses to send to */
	SM_NONVOLATILE char delimiter;		/* the address delimiter */
	SM_NONVOLATILE int naddrs;
	SM_NONVOLATILE int i;
d66 1
a66 1
	char *SM_NONVOLATILE bufp;
d77 2
a78 2
		sm_dprintf("sendto: %s\n   ctladdr=", list);
		printaddr(ctladdr, false);
d101 2
a102 1
		bufp = sm_malloc_x(i);
d104 17
a120 3
	SM_TRY
	{
		(void) sm_strlcpy(bufp, denlstring(list, false, true), i);
d122 2
a123 2
		macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), "e r");
		for (p = bufp; *p != '\0'; )
d125 1
a125 2
			auto char *delimptr;
			register ADDRESS *a;
d127 10
a136 10
			/* parse the address */
			while ((isascii(*p) && isspace(*p)) || *p == ',')
				p++;
			a = parseaddr(p, NULLADDR, RF_COPYALL, delimiter,
				      &delimptr, e, true);
			p = delimptr;
			if (a == NULL)
				continue;
			a->q_next = al;
			a->q_alias = ctladdr;
d138 3
a140 2
			/* arrange to inherit attributes from parent */
			if (ctladdr != NULL)
d142 2
a143 4
				ADDRESS *b;

				/* self reference test */
				if (sameaddr(ctladdr, a))
d145 2
a146 6
					if (tTd(27, 5))
					{
						sm_dprintf("sendtolist: QSELFREF ");
						printaddr(ctladdr, false);
					}
					ctladdr->q_flags |= QSELFREF;
d148 1
a148 4

				/* check for address loops */
				b = self_reference(a);
				if (b != NULL)
a149 1
					b->q_flags |= QSELFREF;
d152 2
a153 13
						sm_dprintf("sendtolist: QSELFREF ");
						printaddr(b, false);
					}
					if (a != b)
					{
						if (tTd(27, 5))
						{
							sm_dprintf("sendtolist: QS_DONTSEND ");
							printaddr(a, false);
						}
						a->q_state = QS_DONTSEND;
						b->q_flags |= a->q_flags & QNOTREMOTE;
						continue;
d155 3
d159 1
d161 3
a163 3
				/* full name */
				if (a->q_fullname == NULL)
					a->q_fullname = ctladdr->q_fullname;
d165 3
a167 3
				/* various flag bits */
				a->q_flags &= ~QINHERITEDBITS;
				a->q_flags |= ctladdr->q_flags & QINHERITEDBITS;
d169 2
a170 6
				/* DSN recipient information */
				a->q_finalrcpt = ctladdr->q_finalrcpt;
				a->q_orcpt = ctladdr->q_orcpt;
			}

			al = a;
d173 2
a174 4
		/* arrange to send to everyone on the local send list */
		while (al != NULL)
		{
			register ADDRESS *a = al;
d176 2
a177 6
			al = a->q_next;
			a = recipient(a, sendq, aliaslevel, e);
			naddrs++;
		}
	}
	SM_FINALLY
d179 5
a183 4
		e->e_to = oldto;
		if (bufp != buf)
			sm_free(bufp);
		macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), NULL);
d185 7
a191 1
	SM_END_TRY
a193 1
#if MILTER
d199 1
a199 1
**	have been expanded already in the sendq, it won't mark the
d219 3
a221 3
	SM_NONVOLATILE char delimiter;		/* the address delimiter */
	SM_NONVOLATILE int naddrs;
	SM_NONVOLATILE int i;
d224 1
a224 1
	char *SM_NONVOLATILE bufp;
d234 1
a234 1
		sm_dprintf("removefromlist: %s\n", list);
d254 2
a255 1
		bufp = sm_malloc_x(i);
d257 15
a271 6
	SM_TRY
	{
		(void) sm_strlcpy(bufp, denlstring(list, false, true), i);

		macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), "e r");
		for (p = bufp; *p != '\0'; )
a272 14
			ADDRESS a;	/* parsed address to be removed */
			ADDRESS *q;
			ADDRESS **pq;
			char *delimptr;

			/* parse the address */
			while ((isascii(*p) && isspace(*p)) || *p == ',')
				p++;
			if (parseaddr(p, &a, RF_COPYALL,
				      delimiter, &delimptr, e, true) == NULL)
			{
				p = delimptr;
				continue;
			}
d274 7
a280 1
			for (pq = sendq; (q = *pq) != NULL; pq = &q->q_next)
d282 1
a282 2
				if (!QS_IS_DEAD(q->q_state) &&
				    sameaddr(q, &a))
d284 2
a285 8
					if (tTd(25, 5))
					{
						sm_dprintf("removefromlist: QS_REMOVED ");
						printaddr(&a, false);
					}
					q->q_state = QS_REMOVED;
					naddrs++;
					break;
d287 3
d293 7
a299 8
	SM_FINALLY
	{
		e->e_to = oldto;
		if (bufp != buf)
			sm_free(bufp);
		macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), NULL);
	}
	SM_END_TRY
a301 1
#endif /* MILTER */
d308 1
a308 1
**		new -- the (preparsed) address header for the recipient.
d319 2
d324 2
a325 2
recipient(new, sendq, aliaslevel, e)
	register ADDRESS *new;
a331 1
	ADDRESS **prev;
d333 4
a336 1
	register char *p;
a337 4
	bool quoted;		/* set if the addr has a quote bit */
	bool insert;
	int findusercount;
	bool initialdontsend;
a339 1
	sortfn_t *sortfn;
d341 2
a342 7
	p = NULL;
	quoted = false;
	insert = false;
	findusercount = 0;
	initialdontsend = QS_IS_DEAD(new->q_state);
	e->e_to = new->q_paddr;
	m = new->q_mailer;
d345 1
a345 1
		new->q_flags |= QPRIMARY;
d348 2
a349 2
		sm_dprintf("\nrecipient (%d): ", aliaslevel);
		printaddr(new, false);
d352 2
a353 2
	/* if this is primary, use it as original recipient */
	if (new->q_alias == NULL)
d356 2
a357 2
			e->e_origrcpt = new->q_paddr;
		else if (e->e_origrcpt != new->q_paddr)
a360 56
	/* find parent recipient for finalrcpt and orcpt */
	for (q = new; q->q_alias != NULL; q = q->q_alias)
		continue;

	/* find final recipient DSN address */
	if (new->q_finalrcpt == NULL &&
	    e->e_from.q_mailer != NULL)
	{
		char frbuf[MAXLINE];

		p = e->e_from.q_mailer->m_addrtype;
		if (p == NULL)
			p = "rfc822";
		if (sm_strcasecmp(p, "rfc822") != 0)
		{
			(void) sm_snprintf(frbuf, sizeof frbuf, "%s; %.800s",
					   q->q_mailer->m_addrtype,
					   q->q_user);
		}
		else if (strchr(q->q_user, '@@') != NULL)
		{
			(void) sm_snprintf(frbuf, sizeof frbuf, "%s; %.800s",
					   p, q->q_user);
		}
		else if (strchr(q->q_paddr, '@@') != NULL)
		{
			char *qp;
			bool b;

			qp = q->q_paddr;

			/* strip brackets from address */
			b = false;
			if (*qp == '<')
			{
				b = qp[strlen(qp) - 1] == '>';
				if (b)
					qp[strlen(qp) - 1] = '\0';
				qp++;
			}
			(void) sm_snprintf(frbuf, sizeof frbuf, "%s; %.800s",
					   p, qp);

			/* undo damage */
			if (b)
				qp[strlen(qp)] = '>';
		}
		else
		{
			(void) sm_snprintf(frbuf, sizeof frbuf,
					   "%s; %.700s@@%.100s",
					   p, q->q_user, MyHostName);
		}
		new->q_finalrcpt = sm_rpool_strdup_x(e->e_rpool, frbuf);
	}

d363 1
a363 1
	if (new->q_orcpt == NULL)
d365 3
d370 1
a370 1
			new->q_orcpt = q->q_orcpt;
d374 1
a374 1
			bool b = false;
d382 2
a383 1
			(void) sm_strlcpyn(obuf, sizeof obuf, 2, p, ";");
d398 1
a398 1
			p = xtextify(denlstring(qp, true, false), NULL);
d400 1
a400 1
			if (sm_strlcat(obuf, p, sizeof obuf) >= sizeof obuf)
d411 1
a411 2
				new->q_orcpt =
					sm_rpool_strdup_x(e->e_rpool, obuf);
d419 3
a421 3
		new->q_state = QS_BADADDR;
		new->q_status = "5.4.6";
		usrerrenh(new->q_status,
d424 1
a424 1
		return new;
d432 1
a432 1
	i = strlen(new->q_user);
d443 1
a443 1
	(void) sm_strlcpy(buf, new->q_user, buflen);
d447 1
a447 1
			quoted = true;
d454 1
a454 2
		if (new->q_alias == NULL || UseMSP ||
		    bitset(EF_UNSAFE, e->e_flags))
d456 3
a458 3
			new->q_state = QS_BADADDR;
			new->q_status = "5.7.1";
			usrerrenh(new->q_status,
d461 1
a461 1
		else if (bitset(QBOGUSSHELL, new->q_alias->q_flags))
d463 4
a466 4
			new->q_state = QS_BADADDR;
			new->q_status = "5.7.1";
			if (new->q_alias->q_ruser == NULL)
				usrerrenh(new->q_status,
d468 1
a468 1
					  new->q_alias->q_uid);
d470 1
a470 1
				usrerrenh(new->q_status,
d472 1
a472 1
					  new->q_alias->q_ruser, MyHostName);
d474 1
a474 1
		else if (bitset(QUNSAFEADDR, new->q_alias->q_flags))
d476 4
a479 4
			new->q_state = QS_BADADDR;
			new->q_status = "5.7.1";
			new->q_rstatus = "550 Unsafe for mailing to programs";
			usrerrenh(new->q_status,
d481 1
a481 1
				  new->q_alias->q_paddr);
a493 20
	prev = NULL;

	/*
	**  If this message is going to the queue or FastSplit is set
	**  and it is the first try and the envelope hasn't split, then we
	**  avoid doing an MX RR lookup now because one will be done when the
	**  message is extracted from the queue later. It can go to the queue
	**  because all messages are going to the queue or this mailer of
	**  the current recipient is marked expensive.
	*/

	if (WILL_BE_QUEUED(e->e_sendmode) ||
	    (!bitset(EF_SPLIT, e->e_flags) && e->e_ntries == 0 &&
	     FastSplit > 0))
		sortfn = sorthost;
	else if (NoConnect && bitnset(M_EXPENSIVE, new->q_mailer->m_flags))
		sortfn = sortexpensive;
	else
		sortfn = sortbysignature;

d496 10
a505 25
		/*
		**  If address is "less than" it should be inserted now.
		**  If address is "greater than" current comparison it'll
		**  insert later in the list; so loop again (if possible).
		**  If address is "equal" (different equal than sameaddr()
		**  call) then check if sameaddr() will be true.
		**  Because this list is now sorted, it'll mean fewer
		**  comparisons and fewer loops which is important for more
		**  recipients.
		*/

		i = (*sortfn)(new, q);
		if (i == 0) /* equal */
		{
			/*
			**  Sortbysignature() has said that the two have
			**  equal MX RR's and the same user. Calling sameaddr()
			**  now checks if the two hosts are as identical as the
			**  MX RR's are (which might not be the case)
			**  before saying these are the identical addresses.
			*/

			if (sameaddr(q, new) &&
			    (bitset(QRCPTOK, q->q_flags) ||
			     !bitset(QPRIMARY, q->q_flags)))
d507 20
a526 28
				if (tTd(26, 1))
				{
					sm_dprintf("%s in sendq: ",
						   new->q_paddr);
					printaddr(q, false);
				}
				if (!bitset(QPRIMARY, q->q_flags))
				{
					if (!QS_IS_DEAD(new->q_state))
						message("duplicate suppressed");
					else
						q->q_state = QS_DUPLICATE;
					q->q_flags |= new->q_flags;
				}
				else if (bitset(QSELFREF, q->q_flags)
					 || q->q_state == QS_REMOVED)
				{
					/*
					**  If an earlier milter removed the
					**  address, a later one can still add
					**  it back.
					*/

					q->q_state = new->q_state;
					q->q_flags |= new->q_flags;
				}
				new = q;
				goto done;
d528 2
a530 6
		else if (i < 0) /* less than */
		{
			insert = true;
			break;
		}
		prev = pq;
a532 3
	/* pq should point to an address, never NULL */
	SM_ASSERT(pq != NULL);

d534 1
a534 14
	if (insert)
	{
		/*
		**  insert before 'pq'. Only possible when at least 1
		**  ADDRESS is in the list already.
		*/

		new->q_next = *pq;
		if (prev == NULL)
			*sendq = new; /* To be the first ADDRESS */
		else
			(*prev)->q_next = new;
	}
	else
d536 2
a537 7
		/*
		**  Place in list at current 'pq' position. Possible
		**  when there are 0 or more ADDRESS's in the list.
		*/

		new->q_next = NULL;
		*pq = new;
d547 2
a548 2
		sm_dprintf("at trylocaluser: ");
		printaddr(new, false);
d551 1
a551 4
	if (!QS_IS_OK(new->q_state))
	{
		if (QS_IS_UNDELIVERED(new->q_state))
			e->e_nrcpts++;
a552 1
	}
d556 6
a561 7
		new->q_state = QS_INCLUDED;
		if (new->q_alias == NULL || UseMSP ||
		    bitset(EF_UNSAFE, e->e_flags))
		{
			new->q_state = QS_BADADDR;
			new->q_status = "5.7.1";
			usrerrenh(new->q_status,
d568 2
a569 3
			message("including file %s", new->q_user);
			ret = include(new->q_user, false, new,
				      sendq, aliaslevel, e);
d575 3
a577 4
						  shortenstring(new->q_user,
								MAXSHORTSTR),
								sm_errstring(ret));
				new->q_state = QS_QUEUEUP;
d579 2
a580 3
					shortenstring(new->q_user,
						      MAXSHORTSTR),
					sm_errstring(ret));
d584 3
a586 3
				new->q_state = QS_BADADDR;
				new->q_status = "5.2.4";
				usrerrenh(new->q_status,
d588 2
a589 3
					  shortenstring(new->q_user,
							MAXSHORTSTR),
					  sm_errstring(ret));
d595 6
a600 7
		/* check if allowed */
		if (new->q_alias == NULL || UseMSP ||
		    bitset(EF_UNSAFE, e->e_flags))
		{
			new->q_state = QS_BADADDR;
			new->q_status = "5.7.1";
			usrerrenh(new->q_status,
d603 1
a603 1
		else if (bitset(QBOGUSSHELL, new->q_alias->q_flags))
d605 4
a608 4
			new->q_state = QS_BADADDR;
			new->q_status = "5.7.1";
			if (new->q_alias->q_ruser == NULL)
				usrerrenh(new->q_status,
d610 1
a610 1
					  new->q_alias->q_uid);
d612 1
a612 1
				usrerrenh(new->q_status,
d614 1
a614 1
					  new->q_alias->q_ruser, MyHostName);
d616 1
a616 1
		else if (bitset(QUNSAFEADDR, new->q_alias->q_flags))
d618 4
a621 4
			new->q_state = QS_BADADDR;
			new->q_status = "5.7.1";
			new->q_rstatus = "550 Unsafe for mailing to files";
			usrerrenh(new->q_status,
d623 1
a623 1
				  new->q_alias->q_paddr);
d628 1
a628 1
	if (!quoted && QS_IS_OK(new->q_state) &&
d630 1
a630 1
		alias(new, sendq, aliaslevel, e);
d634 2
a635 2
	if (!bitset(QNOTREMOTE, new->q_flags) &&
	    QS_IS_SENDABLE(new->q_state) &&
d638 1
a638 1
		if (udbexpand(new, sendq, aliaslevel, e) == EX_TEMPFAIL)
d640 1
a640 1
			new->q_state = QS_QUEUEUP;
d642 1
a642 3
				e->e_message = "Deferred: user database error";
			if (new->q_message == NULL)
				new->q_message = "Deferred: user database error";
d646 1
a646 1
					  sm_errstring(errno));
d648 1
a648 1
				sm_errstring(errno));
d658 1
a658 1
	**  to rewrite it to another mailer.  This gives us a hook
d664 3
a666 3
		sm_dprintf("recipient: testing local?  cl=%d, rr5=%p\n\t",
			   ConfigLevel, RewriteRules[5]);
		printaddr(new, false);
d670 2
a671 2
	    !bitset(QNOTREMOTE, new->q_flags) &&
	    QS_IS_OK(new->q_state))
d673 1
a673 1
		maplocaluser(new, sendq, aliaslevel + 1, e);
d681 1
a681 1
	if (QS_IS_OK(new->q_state) &&
d685 1
a685 2
		SM_MBDB_T user;
		int status;
d688 12
a699 2
		status = finduser(buf, &fuzzy, &user);
		switch (status)
d701 2
a702 14
		  case EX_TEMPFAIL:
			new->q_state = QS_QUEUEUP;
			new->q_status = "4.5.2";
			giveresponse(EX_TEMPFAIL, new->q_status, m, NULL,
				     new->q_alias, (time_t) 0, e, new);
			break;
		  default:
			new->q_state = QS_BADADDR;
			new->q_status = "5.1.1";
			new->q_rstatus = "550 5.1.1 User unknown";
			giveresponse(EX_NOUSER, new->q_status, m, NULL,
				     new->q_alias, (time_t) 0, e, new);
			break;
		  case EX_OK:
d706 1
a706 2
				new->q_user = sm_rpool_strdup_x(e->e_rpool,
								user.mbdb_name);
d709 3
a711 3
					new->q_state = QS_BADADDR;
					new->q_status = "5.4.6";
					usrerrenh(new->q_status,
d713 1
a713 1
						  user.mbdb_name);
d718 1
a718 1
				(void) sm_strlcpy(buf, user.mbdb_name, buflen);
d721 4
a724 4
			if (*user.mbdb_homedir == '\0')
				new->q_home = NULL;
			else if (strcmp(user.mbdb_homedir, "/") == 0)
				new->q_home = "";
d726 9
a734 14
				new->q_home = sm_rpool_strdup_x(e->e_rpool,
							user.mbdb_homedir);
			if (user.mbdb_uid != SM_NO_UID)
			{
				new->q_uid = user.mbdb_uid;
				new->q_gid = user.mbdb_gid;
				new->q_flags |= QGOODUID;
			}
			new->q_ruser = sm_rpool_strdup_x(e->e_rpool,
							 user.mbdb_name);
			if (user.mbdb_fullname[0] != '\0')
				new->q_fullname = sm_rpool_strdup_x(e->e_rpool,
							user.mbdb_fullname);
			if (!usershellok(user.mbdb_name, user.mbdb_shell))
d736 1
a736 1
				new->q_flags |= QBOGUSSHELL;
d741 1
a741 1
				new->q_state = QS_VERIFIED;
d744 1
a744 1
				forward(new, sendq, aliaslevel, e);
d747 1
a747 1
	if (!QS_IS_DEAD(new->q_state))
d751 1
a751 1
	new->q_flags |= QTHISPASS;
d754 2
a755 2
		sm_dprintf("testselfdestruct: ");
		printaddr(new, false);
d758 3
a760 3
			sm_dprintf("SENDQ:\n");
			printaddr(*sendq, true);
			sm_dprintf("----\n");
d763 2
a764 2
	if (new->q_alias == NULL && new != &e->e_from &&
	    QS_IS_DEAD(new->q_state))
d773 3
a775 3
			new->q_state = QS_BADADDR;
			new->q_status = "5.4.6";
			usrerrenh(new->q_status,
d781 1
a781 1
	new->q_flags |= QTHISPASS;
d783 1
a783 1
		sm_free(buf); /* XXX leak if above code raises exception */
d824 1
a824 1
			new->q_flags |= QEXPANDED;
d826 4
a829 4
			    bitset(QPINGONSUCCESS, new->q_flags))
				(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
						     "%s... expanded to multiple addresses\n",
						     new->q_paddr);
d832 2
a833 4
	new->q_flags |= QRCPTOK;
	(void) sm_snprintf(buf0, sizeof buf0, "%d", e->e_nrcpts);
	macdefine(&e->e_macro, A_TEMP, macid("{nrcpts}"), buf0);
	return new;
d846 1
a846 1
**		fuzzyp -- an outarg that is set to true if this entry
d848 1
a848 2
**			set to false otherwise.
**		user -- structure to fill in if user is found
d851 2
a852 3
**		On success, fill in *user, set *fuzzyp and return EX_OK.
**		If the user was not found, return EX_NOUSER.
**		On error, return EX_TEMPFAIL or EX_OSERR.
d858 2
a859 2
int
finduser(name, fuzzyp, user)
a861 1
	SM_MBDB_T *user;
a862 1
#if MATCHGECOS
a863 1
#endif /* MATCHGECOS */
a865 1
	int status;
d868 1
a868 1
		sm_dprintf("finduser(%s): ", name);
d870 1
a870 1
	*fuzzyp = false;
d872 1
a872 1
#if HESIOD
d880 2
a881 2
			sm_dprintf("failed (numeric input)\n");
		return EX_NOUSER;
d886 1
a886 2
	status = sm_mbdb_lookup(name, user);
	if (status != EX_NOUSER)
d889 2
a890 2
			sm_dprintf("%s (non-fuzzy)\n", sm_strexit(status));
		return status;
d894 1
a894 1
	tryagain = false;
d900 1
a900 1
			tryagain = true;
d903 1
a903 1
	if (tryagain && (status = sm_mbdb_lookup(name, user)) != EX_NOUSER)
d906 3
a908 3
			sm_dprintf("%s (lower case)\n", sm_strexit(status));
		*fuzzyp = true;
		return status;
d916 2
a917 2
			sm_dprintf("not found (fuzzy disabled)\n");
		return EX_NOUSER;
d932 1
a932 1
		if (sm_strcasecmp(pw->pw_name, name) == 0)
d935 1
a935 1
				sm_dprintf("found (case wrapped)\n");
d940 2
a941 2
		sm_pwfullname(pw->pw_gecos, pw->pw_name, buf, sizeof buf);
		if (strchr(buf, ' ') != NULL && sm_strcasecmp(buf, name) == 0)
d944 1
a944 1
				sm_dprintf("fuzzy matches %s\n", pw->pw_name);
d950 1
a950 1
		*fuzzyp = true;
d952 1
a952 1
		sm_dprintf("no fuzzy match found\n");
d956 1
a956 4
	if (pw == NULL)
		return EX_NOUSER;
	sm_mbdb_frompw(user, pw);
	return EX_OK;
d959 2
a960 2
		sm_dprintf("not found (fuzzy disabled)\n");
	return EX_NOUSER;
d980 2
a981 2
**		true -- if we will be able to write this file.
**		false -- if we cannot write this file.
d998 1
a998 1
		sm_dprintf("writable(%s, 0x%lx)\n", filename, flags);
d1060 2
a1061 2
**		forwarding -- if true, we are reading a .forward file.
**			if false, it's a :include: file.
d1102 1
a1102 1
	SM_FILE_T *volatile fp = NULL;
d1106 1
a1106 1
	register SM_EVENT *ev = NULL;
d1109 1
a1109 1
	volatile bool maxreached = false;
d1119 2
a1120 3
	bool safechown = false;
	volatile bool safedir = false;
	bool oldsplit;
d1125 1
a1125 1
		sm_dprintf("include(%s)\n", fname);
d1127 1
a1127 1
		sm_dprintf("   ruid=%d euid=%d\n",
d1131 2
a1132 2
		sm_dprintf("ctladdr ");
		printaddr(ctladdr, false);
d1136 2
a1137 2
		sm_dprintf("include: old uid = %d/%d\n",
			   (int) getuid(), (int) geteuid());
d1139 1
a1141 1
		sfflags |= SFF_MUSTOWN|SFF_ROOTOK|SFF_NOWLINK;
d1154 4
d1168 2
a1169 2
			sm_dprintf("include: not safe (euid=%d, RunAsUid=%d)\n",
				   (int) geteuid(), (int) RunAsUid);
d1246 2
a1247 2
		sm_dprintf("include: new uid = %d/%d\n",
			   (int) getuid(), (int) geteuid());
d1264 1
a1264 1
		ev = sm_setevent(TimeOuts.to_fileopen, includetimeout, 0);
d1281 1
a1281 1
			safedir = true;
d1317 1
a1317 1
				if (LogLevel > 11)
d1340 2
a1341 2
			sm_dprintf("include: not safe (uid=%d): %s\n",
				   (int) uid, sm_errstring(rval));
d1343 1
a1343 2
	else if ((fp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, fname,
				  SM_IO_RDONLY, NULL)) == NULL)
d1347 1
a1347 1
			sm_dprintf("include: open: %s\n", sm_errstring(rval));
d1349 1
a1349 1
	else if (filechanged(fname, sm_io_getinfo(fp,SM_IO_WHAT_FD, NULL), &st))
d1353 1
a1353 1
			sm_dprintf("include: file changed after open\n");
d1356 1
a1356 1
		sm_clrevent(ev);
d1368 1
a1368 1
				       (int) getuid(), (int) geteuid());
d1372 1
a1372 1
				       (int) getuid(), (int) geteuid());
d1375 1
a1375 2
				       (int) RealUid, (int) getuid(),
				       (int) geteuid());
d1380 1
a1380 2
			       (int) savedgid, (int) getgid(),
			       (int) getegid());
d1385 2
a1386 2
		sm_dprintf("include: reset uid = %d/%d\n",
			   (int) getuid(), (int) geteuid());
d1394 1
a1394 1
	if (fstat(sm_io_getinfo(fp, SM_IO_WHAT_FD, NULL), &st) < 0)
d1398 1
a1398 1
		(void) sm_io_close(fp, SM_TIME_DEFAULT);
d1403 1
a1403 1
	safechown = chownsafe(sm_io_getinfo(fp, SM_IO_WHAT_FD, NULL), safedir);
d1405 4
a1408 3
		sm_dprintf("include: parent of %s is %s, chown is %ssafe\n",
			   fname, safedir ? "safe" : "dangerous",
			   safechown ? "" : "un");
d1439 1
a1439 2
			ctladdr->q_ruser = sm_rpool_strdup_x(e->e_rpool,
							     pw->pw_name);
d1446 1
a1446 1
				if (LogLevel > 11)
d1449 1
a1449 2
						  shortenstring(fname,
								MAXSHORTSTR),
d1465 1
a1465 1
		(void) sm_io_close(fp, SM_TIME_DEFAULT);
d1487 4
a1490 5
			sm_dprintf("include: %s is %s writable, marked unsafe\n",
				   shortenstring(fname, MAXSHORTSTR),
				   bitset(S_IWOTH, st.st_mode) ? "world"
							       : "group");
		if (LogLevel > 11)
d1504 1
a1504 4
	oldsplit = bitset(EF_SPLIT, e->e_flags);
	e->e_flags &= ~EF_SPLIT;
	while (sm_io_fgets(fp, SM_TIME_DEFAULT, buf, sizeof buf) != NULL &&
	       !maxreached)
d1506 1
a1506 1
		fixcrlf(buf, true);
d1545 1
a1545 2
#if 0
			/* additional: (?) */
d1547 1
a1547 2
#endif /* 0 */

d1550 1
a1550 1
			maxreached = true;
d1554 2
a1555 2
	if (sm_io_error(fp) && tTd(27, 3))
		sm_dprintf("include: read error: %s\n", sm_errstring(errno));
d1560 2
a1561 2
			sm_dprintf("include: QS_DONTSEND ");
			printaddr(ctladdr, false);
d1566 1
a1566 5
	/* if nothing included: restore old split flag */
	if (nincludes <= 0 && oldsplit)
		e->e_flags |= EF_SPLIT;

	(void) sm_io_close(fp, SM_TIME_DEFAULT);
a1575 7
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
d1601 1
d1603 1
d1615 3
d1655 1
a1655 1
		sm_dprintf("self_reference(%s)\n", a->q_paddr);
d1666 1
a1666 1
			sm_dprintf("\t... no self ref\n");
d1672 1
a1672 1
	**  i.e has a mbdb entry.  The returned value will be marked
d1679 1
a1679 1
	**		alias->sendtolist->recipient->alias
d1684 1
a1684 1
	**	   QSELFREF.  We set QSELFREF when we return to recipient().
d1691 1
a1691 1
			sm_dprintf("  %s", c->q_user);
a1693 2
			SM_MBDB_T user;

d1695 2
a1696 2
				sm_dprintf("\t... getpwnam(%s)... ", c->q_user);
			if (sm_mbdb_lookup(c->q_user, &user) == EX_OK)
d1699 1
a1699 1
					sm_dprintf("found\n");
d1708 1
a1708 1
				sm_dprintf("failed\n");
d1717 1
a1717 1
					sm_dprintf("\t... local match (%s)\n",
d1726 1
a1726 1
			sm_dprintf("\n");
d1731 1
a1731 1
		sm_dprintf("\t... cannot break loop for \"%s\"\n", a->q_paddr);
@


