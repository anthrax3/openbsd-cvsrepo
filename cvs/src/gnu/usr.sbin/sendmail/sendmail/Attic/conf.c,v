head	1.39;
access;
symbols
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.37.0.4
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.35.0.2
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.34.0.2
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.33.0.6
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.4
	OPENBSD_5_0:1.33.0.2
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.32.0.12
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.10
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.6
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.8
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.4
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.2
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.31.0.2
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.26.0.4
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.19.0.4
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.39
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.38;
commitid	M7i5giHIoz3DMlTU;

1.38
date	2014.06.05.08.33.31;	author jasper;	state Exp;
branches;
next	1.37;
commitid	Xgju3JhWQ1gE8Sdz;

1.37
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches
	1.37.4.1;
next	1.36;

1.36
date	2013.10.24.19.53.26;	author fgsch;	state Exp;
branches;
next	1.35;

1.35
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2012.12.26.11.44.12;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2011.05.17.15.54.23;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2008.01.25.16.23.12;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2007.04.04.14.43.48;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2006.08.13.13.01.48;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2006.03.22.18.43.55;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.08.16.00.50;	author millert;	state Exp;
branches
	1.26.2.1
	1.26.4.1;
next	1.25;

1.25
date	2005.01.12.18.15.46;	author millert;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2004.12.16.00.21.30;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2004.09.18.04.08.34;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2004.06.24.03.59.26;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.19.01.41.13;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.09.17.17.31.40;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.29.19.44.00;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.03.17.31.21;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.01.19.59.22;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.15.02.23.35;	author millert;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2002.06.26.04.48.55;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.03.17.25.46;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.04.18.00.49.28;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.25.19.16.07;	author millert;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.01.01.01.41;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.29.01.31.14;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.28.02.43.53;	author millert;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.01.15.21.09.07;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.22.21.07.03;	author millert;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2000.04.07.19.20.38;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.02.19.48.35;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.02.19.05.43;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.43;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.12;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.50;	author millert;	state Exp;
branches;
next	;

1.4.4.1
date	2001.05.31.00.31.31;	author miod;	state Exp;
branches;
next	;

1.6.2.1
date	2001.05.31.01.47.55;	author jason;	state Exp;
branches;
next	;

1.12.2.1
date	2003.03.31.07.07.07;	author miod;	state Exp;
branches;
next	;

1.16.2.1
date	2003.03.31.01.01.47;	author margarida;	state Exp;
branches;
next	;

1.25.2.1
date	2006.03.24.05.42.48;	author brad;	state Exp;
branches;
next	;

1.26.2.1
date	2006.03.24.05.56.17;	author brad;	state Exp;
branches;
next	;

1.26.4.1
date	2006.03.25.01.49.37;	author brad;	state Exp;
branches;
next	;

1.35.2.1
date	2014.06.05.16.33.00;	author jasper;	state Exp;
branches;
next	;
commitid	YwJwSTT0PITtuk9A;

1.37.4.1
date	2014.06.05.16.33.17;	author jasper;	state Exp;
branches;
next	;
commitid	vzbBfkQ2kWV37YsP;


desc
@@


1.39
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2013 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>

SM_RCSID("@@(#)$Sendmail: conf.c,v 8.1191 2014/01/08 17:03:14 ca Exp $")

#include <sm/sendmail.h>
#include <sendmail/pathnames.h>
#if NEWDB
# include "sm/bdb.h"
#endif /* NEWDB */

#include <daemon.h>
#include "map.h"

#ifdef DEC
# if NETINET6
/* for the IPv6 device lookup */
#  define _SOCKADDR_LEN
#  include <macros.h>
# endif /* NETINET6 */
#endif /* DEC */

# include <sys/ioctl.h>
# include <sys/param.h>

#include <limits.h>
#if NETINET || NETINET6
# include <arpa/inet.h>
#endif /* NETINET || NETINET6 */
#if HASULIMIT && defined(HPUX11)
# include <ulimit.h>
#endif /* HASULIMIT && defined(HPUX11) */

static void	setupmaps __P((void));
static void	setupmailers __P((void));
static void	setupqueues __P((void));
static int	get_num_procs_online __P((void));
static int	add_hostnames __P((SOCKADDR *));

#if NETINET6 && NEEDSGETIPNODE
static struct hostent *sm_getipnodebyname __P((const char *, int, int, int *));
static struct hostent *sm_getipnodebyaddr __P((const void *, size_t, int, int *));
#else /* NETINET6 && NEEDSGETIPNODE */
#define sm_getipnodebyname getipnodebyname
#define sm_getipnodebyaddr getipnodebyaddr
#endif /* NETINET6 && NEEDSGETIPNODE */


/*
**  CONF.C -- Sendmail Configuration Tables.
**
**	Defines the configuration of this installation.
**
**	Configuration Variables:
**		HdrInfo -- a table describing well-known header fields.
**			Each entry has the field name and some flags,
**			which are described in sendmail.h.
**
**	Notes:
**		I have tried to put almost all the reasonable
**		configuration information into the configuration
**		file read at runtime.  My intent is that anything
**		here is a function of the version of UNIX you
**		are running, or is really static -- for example
**		the headers are a superset of widely used
**		protocols.  If you find yourself playing with
**		this file too much, you may be making a mistake!
*/


/*
**  Header info table
**	Final (null) entry contains the flags used for any other field.
**
**	Not all of these are actually handled specially by sendmail
**	at this time.  They are included as placeholders, to let
**	you know that "someday" I intend to have sendmail do
**	something with them.
*/

struct hdrinfo	HdrInfo[] =
{
		/* originator fields, most to least significant */
	{ "resent-sender",		H_FROM|H_RESENT,	NULL	},
	{ "resent-from",		H_FROM|H_RESENT,	NULL	},
	{ "resent-reply-to",		H_FROM|H_RESENT,	NULL	},
	{ "sender",			H_FROM,			NULL	},
	{ "from",			H_FROM,			NULL	},
	{ "reply-to",			H_FROM,			NULL	},
	{ "errors-to",			H_FROM|H_ERRORSTO,	NULL	},
	{ "full-name",			H_ACHECK,		NULL	},
	{ "return-receipt-to",		H_RECEIPTTO,		NULL	},
	{ "delivery-receipt-to",	H_RECEIPTTO,		NULL	},
	{ "disposition-notification-to",	H_FROM,		NULL	},

		/* destination fields */
	{ "to",				H_RCPT,			NULL	},
	{ "resent-to",			H_RCPT|H_RESENT,	NULL	},
	{ "cc",				H_RCPT,			NULL	},
	{ "resent-cc",			H_RCPT|H_RESENT,	NULL	},
	{ "bcc",			H_RCPT|H_BCC,		NULL	},
	{ "resent-bcc",			H_RCPT|H_BCC|H_RESENT,	NULL	},
	{ "apparently-to",		H_RCPT,			NULL	},

		/* message identification and control */
	{ "message-id",			0,			NULL	},
	{ "resent-message-id",		H_RESENT,		NULL	},
	{ "message",			H_EOH,			NULL	},
	{ "text",			H_EOH,			NULL	},

		/* date fields */
	{ "date",			0,			NULL	},
	{ "resent-date",		H_RESENT,		NULL	},

		/* trace fields */
	{ "received",			H_TRACE|H_FORCE,	NULL	},
	{ "x400-received",		H_TRACE|H_FORCE,	NULL	},
	{ "via",			H_TRACE|H_FORCE,	NULL	},
	{ "mail-from",			H_TRACE|H_FORCE,	NULL	},

		/* miscellaneous fields */
	{ "comments",			H_FORCE|H_ENCODABLE,	NULL	},
	{ "return-path",		H_FORCE|H_ACHECK|H_BINDLATE,	NULL	},
	{ "content-transfer-encoding",	H_CTE,			NULL	},
	{ "content-type",		H_CTYPE,		NULL	},
	{ "content-length",		H_ACHECK,		NULL	},
	{ "subject",			H_ENCODABLE,		NULL	},
	{ "x-authentication-warning",	H_FORCE,		NULL	},

	{ NULL,				0,			NULL	}
};



/*
**  Privacy values
*/

struct prival PrivacyValues[] =
{
	{ "public",		PRIV_PUBLIC		},
	{ "needmailhelo",	PRIV_NEEDMAILHELO	},
	{ "needexpnhelo",	PRIV_NEEDEXPNHELO	},
	{ "needvrfyhelo",	PRIV_NEEDVRFYHELO	},
	{ "noexpn",		PRIV_NOEXPN		},
	{ "novrfy",		PRIV_NOVRFY		},
	{ "restrictexpand",	PRIV_RESTRICTEXPAND	},
	{ "restrictmailq",	PRIV_RESTRICTMAILQ	},
	{ "restrictqrun",	PRIV_RESTRICTQRUN	},
	{ "noetrn",		PRIV_NOETRN		},
	{ "noverb",		PRIV_NOVERB		},
	{ "authwarnings",	PRIV_AUTHWARNINGS	},
	{ "noreceipts",		PRIV_NORECEIPTS		},
	{ "nobodyreturn",	PRIV_NOBODYRETN		},
	{ "goaway",		PRIV_GOAWAY		},
	{ "noactualrecipient",	PRIV_NOACTUALRECIPIENT	},
	{ NULL,			0			}
};

/*
**  DontBlameSendmail values
*/

struct dbsval DontBlameSendmailValues[] =
{
	{ "safe",			DBS_SAFE			},
	{ "assumesafechown",		DBS_ASSUMESAFECHOWN		},
	{ "groupwritabledirpathsafe",	DBS_GROUPWRITABLEDIRPATHSAFE	},
	{ "groupwritableforwardfilesafe",
					DBS_GROUPWRITABLEFORWARDFILESAFE },
	{ "groupwritableincludefilesafe",
					DBS_GROUPWRITABLEINCLUDEFILESAFE },
	{ "groupwritablealiasfile",	DBS_GROUPWRITABLEALIASFILE	},
	{ "worldwritablealiasfile",	DBS_WORLDWRITABLEALIASFILE	},
	{ "forwardfileinunsafedirpath",	DBS_FORWARDFILEINUNSAFEDIRPATH	},
	{ "includefileinunsafedirpath",	DBS_INCLUDEFILEINUNSAFEDIRPATH	},
	{ "mapinunsafedirpath",		DBS_MAPINUNSAFEDIRPATH	},
	{ "linkedaliasfileinwritabledir",
					DBS_LINKEDALIASFILEINWRITABLEDIR },
	{ "linkedclassfileinwritabledir",
					DBS_LINKEDCLASSFILEINWRITABLEDIR },
	{ "linkedforwardfileinwritabledir",
					DBS_LINKEDFORWARDFILEINWRITABLEDIR },
	{ "linkedincludefileinwritabledir",
					DBS_LINKEDINCLUDEFILEINWRITABLEDIR },
	{ "linkedmapinwritabledir",	DBS_LINKEDMAPINWRITABLEDIR	},
	{ "linkedserviceswitchfileinwritabledir",
					DBS_LINKEDSERVICESWITCHFILEINWRITABLEDIR },
	{ "filedeliverytohardlink",	DBS_FILEDELIVERYTOHARDLINK	},
	{ "filedeliverytosymlink",	DBS_FILEDELIVERYTOSYMLINK	},
	{ "writemaptohardlink",		DBS_WRITEMAPTOHARDLINK		},
	{ "writemaptosymlink",		DBS_WRITEMAPTOSYMLINK		},
	{ "writestatstohardlink",	DBS_WRITESTATSTOHARDLINK	},
	{ "writestatstosymlink",	DBS_WRITESTATSTOSYMLINK		},
	{ "forwardfileingroupwritabledirpath",
					DBS_FORWARDFILEINGROUPWRITABLEDIRPATH },
	{ "includefileingroupwritabledirpath",
					DBS_INCLUDEFILEINGROUPWRITABLEDIRPATH },
	{ "classfileinunsafedirpath",	DBS_CLASSFILEINUNSAFEDIRPATH	},
	{ "errorheaderinunsafedirpath",	DBS_ERRORHEADERINUNSAFEDIRPATH	},
	{ "helpfileinunsafedirpath",	DBS_HELPFILEINUNSAFEDIRPATH	},
	{ "forwardfileinunsafedirpathsafe",
					DBS_FORWARDFILEINUNSAFEDIRPATHSAFE },
	{ "includefileinunsafedirpathsafe",
					DBS_INCLUDEFILEINUNSAFEDIRPATHSAFE },
	{ "runprograminunsafedirpath",	DBS_RUNPROGRAMINUNSAFEDIRPATH	},
	{ "runwritableprogram",		DBS_RUNWRITABLEPROGRAM		},
	{ "nonrootsafeaddr",		DBS_NONROOTSAFEADDR		},
	{ "truststickybit",		DBS_TRUSTSTICKYBIT		},
	{ "dontwarnforwardfileinunsafedirpath",
					DBS_DONTWARNFORWARDFILEINUNSAFEDIRPATH },
	{ "insufficiententropy",	DBS_INSUFFICIENTENTROPY },
	{ "groupreadablesasldbfile",	DBS_GROUPREADABLESASLDBFILE	},
	{ "groupwritablesasldbfile",	DBS_GROUPWRITABLESASLDBFILE	},
	{ "groupwritableforwardfile",	DBS_GROUPWRITABLEFORWARDFILE	},
	{ "groupwritableincludefile",	DBS_GROUPWRITABLEINCLUDEFILE	},
	{ "worldwritableforwardfile",	DBS_WORLDWRITABLEFORWARDFILE	},
	{ "worldwritableincludefile",	DBS_WORLDWRITABLEINCLUDEFILE	},
	{ "groupreadablekeyfile",	DBS_GROUPREADABLEKEYFILE	},
#if _FFR_GROUPREADABLEAUTHINFOFILE
	{ "groupreadableadefaultauthinfofile",
					DBS_GROUPREADABLEAUTHINFOFILE	},
#endif /* _FFR_GROUPREADABLEAUTHINFOFILE */
	{ NULL,				0				}
};

/*
**  Miscellaneous stuff.
*/

int	DtableSize =	50;		/* max open files; reset in 4.2bsd */
/*
**  SETDEFAULTS -- set default values
**
**	Some of these must be initialized using direct code since they
**	depend on run-time values. So let's do all of them this way.
**
**	Parameters:
**		e -- the default envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Initializes a bunch of global variables to their
**		default values.
*/

#define MINUTES		* 60
#define HOURS		* 60 MINUTES
#define DAYS		* 24 HOURS

#ifndef MAXRULERECURSION
# define MAXRULERECURSION	50	/* max ruleset recursion depth */
#endif /* ! MAXRULERECURSION */

void
setdefaults(e)
	register ENVELOPE *e;
{
	int i;
	int numprocs;
	struct passwd *pw;

	numprocs = get_num_procs_online();
	SpaceSub = ' ';				/* option B */
	QueueLA = 8 * numprocs;			/* option x */
	RefuseLA = 12 * numprocs;		/* option X */
	WkRecipFact = 30000L;			/* option y */
	WkClassFact = 1800L;			/* option z */
	WkTimeFact = 90000L;			/* option Z */
	QueueFactor = WkRecipFact * 20;		/* option q */
	QueueMode = QM_NORMAL;		/* what queue items to act upon */
	FileMode = (RealUid != geteuid()) ? 0644 : 0600;
						/* option F */
	QueueFileMode = (RealUid != geteuid()) ? 0644 : 0600;
						/* option QueueFileMode */

	if (((pw = sm_getpwnam("mailnull")) != NULL && pw->pw_uid != 0) ||
	    ((pw = sm_getpwnam("sendmail")) != NULL && pw->pw_uid != 0) ||
	    ((pw = sm_getpwnam("daemon")) != NULL && pw->pw_uid != 0))
	{
		DefUid = pw->pw_uid;		/* option u */
		DefGid = pw->pw_gid;		/* option g */
		DefUser = newstr(pw->pw_name);
	}
	else
	{
		DefUid = 1;			/* option u */
		DefGid = 1;			/* option g */
		setdefuser();
	}
	TrustedUid = 0;
	if (tTd(37, 4))
		sm_dprintf("setdefaults: DefUser=%s, DefUid=%d, DefGid=%d\n",
			DefUser != NULL ? DefUser : "<1:1>",
			(int) DefUid, (int) DefGid);
	CheckpointInterval = 10;		/* option C */
	MaxHopCount = 25;			/* option h */
	set_delivery_mode(SM_FORK, e);		/* option d */
	e->e_errormode = EM_PRINT;		/* option e */
	e->e_qgrp = NOQGRP;
	e->e_qdir = NOQDIR;
	e->e_xfqgrp = NOQGRP;
	e->e_xfqdir = NOQDIR;
	e->e_ctime = curtime();
	SevenBitInput = false;			/* option 7 */
	MaxMciCache = 1;			/* option k */
	MciCacheTimeout = 5 MINUTES;		/* option K */
	LogLevel = 9;				/* option L */
#if MILTER
	MilterLogLevel = -1;
#endif /* MILTER */
	inittimeouts(NULL, false);		/* option r */
	PrivacyFlags = PRIV_PUBLIC;		/* option p */
	MeToo = true;				/* option m */
	SendMIMEErrors = true;			/* option f */
	SuperSafe = SAFE_REALLY;		/* option s */
	clrbitmap(DontBlameSendmail);		/* DontBlameSendmail option */
#if MIME8TO7
	MimeMode = MM_CVTMIME|MM_PASS8BIT;	/* option 8 */
#else /* MIME8TO7 */
	MimeMode = MM_PASS8BIT;
#endif /* MIME8TO7 */
	for (i = 0; i < MAXTOCLASS; i++)
	{
		TimeOuts.to_q_return[i] = 5 DAYS;	/* option T */
		TimeOuts.to_q_warning[i] = 0;		/* option T */
	}
	ServiceSwitchFile = "/etc/mail/service.switch";
	ServiceCacheMaxAge = (time_t) 10;
	HostsFile = _PATH_HOSTS;
	PidFile = newstr(_PATH_SENDMAILPID);
	MustQuoteChars = "@@,;:\\()[].'";
	MciInfoTimeout = 30 MINUTES;
	MaxRuleRecursion = MAXRULERECURSION;
	MaxAliasRecursion = 10;
	MaxMacroRecursion = 10;
	ColonOkInAddr = true;
	DontLockReadFiles = true;
	DontProbeInterfaces = DPI_PROBEALL;
	DoubleBounceAddr = "postmaster";
	MaxHeadersLength = MAXHDRSLEN;
	MaxMimeHeaderLength = MAXLINE;
	MaxMimeFieldLength = MaxMimeHeaderLength / 2;
	MaxForwardEntries = 0;
	FastSplit = 1;
	MaxNOOPCommands = MAXNOOPCOMMANDS;
#if SASL
	AuthMechanisms = newstr(AUTH_MECHANISMS);
	AuthRealm = NULL;
	MaxSLBits = INT_MAX;
#endif /* SASL */
#if STARTTLS
	TLS_Srv_Opts = TLS_I_SRV;
#endif /* STARTTLS */
#ifdef HESIOD_INIT
	HesiodContext = NULL;
#endif /* HESIOD_INIT */
#if NETINET6
	/* Detect if IPv6 is available at run time */
	i = socket(AF_INET6, SOCK_STREAM, 0);
	if (i >= 0)
	{
		InetMode = AF_INET6;
		(void) close(i);
	}
	else
		InetMode = AF_INET;
#else /* NETINET6 */
	InetMode = AF_INET;
#endif /* NETINET6 */
	ControlSocketName = NULL;
	memset(&ConnectOnlyTo, '\0', sizeof(ConnectOnlyTo));
	DataFileBufferSize = 4096;
	XscriptFileBufferSize = 4096;
	for (i = 0; i < MAXRWSETS; i++)
		RuleSetNames[i] = NULL;
#if MILTER
	InputFilters[0] = NULL;
#endif /* MILTER */
	RejectLogInterval = 3 HOURS;
#if REQUIRES_DIR_FSYNC
	RequiresDirfsync = true;
#endif /* REQUIRES_DIR_FSYNC */
#if _FFR_RCPTTHROTDELAY
	BadRcptThrottleDelay = 1;
#endif /* _FFR_RCPTTHROTDELAY */
	ConnectionRateWindowSize = 60;
	setupmaps();
	setupqueues();
	setupmailers();
	setupheaders();
}


/*
**  SETDEFUSER -- set/reset DefUser using DefUid (for initgroups())
*/

void
setdefuser()
{
	struct passwd *defpwent;
	static char defuserbuf[40];

	DefUser = defuserbuf;
	defpwent = sm_getpwuid(DefUid);
	(void) sm_strlcpy(defuserbuf,
			  (defpwent == NULL || defpwent->pw_name == NULL)
			   ? "nobody" : defpwent->pw_name,
			  sizeof(defuserbuf));
	if (tTd(37, 4))
		sm_dprintf("setdefuser: DefUid=%d, DefUser=%s\n",
			   (int) DefUid, DefUser);
}
/*
**  SETUPQUEUES -- initialize default queues
**
**	The mqueue QUEUE structure gets filled in after readcf() but
**	we need something to point to now for the mailer setup,
**	which use "mqueue" as default queue.
*/

static void
setupqueues()
{
	char buf[100];

	MaxRunnersPerQueue = 1;
	(void) sm_strlcpy(buf, "mqueue, P=/var/spool/mqueue", sizeof(buf));
	makequeue(buf, false);
}
/*
**  SETUPMAILERS -- initialize default mailers
*/

static void
setupmailers()
{
	char buf[100];

	(void) sm_strlcpy(buf, "prog, P=/bin/sh, F=lsouDq9, T=X-Unix/X-Unix/X-Unix, A=sh -c \201u",
			sizeof(buf));
	makemailer(buf);

	(void) sm_strlcpy(buf, "*file*, P=[FILE], F=lsDFMPEouq9, T=X-Unix/X-Unix/X-Unix, A=FILE \201u",
			sizeof(buf));
	makemailer(buf);

	(void) sm_strlcpy(buf, "*include*, P=/dev/null, F=su, A=INCLUDE \201u",
			sizeof(buf));
	makemailer(buf);
	initerrmailers();
}
/*
**  SETUPMAPS -- set up map classes
*/

#define MAPDEF(name, ext, flags, parse, open, close, lookup, store) \
	{ \
		extern bool parse __P((MAP *, char *)); \
		extern bool open __P((MAP *, int)); \
		extern void close __P((MAP *)); \
		extern char *lookup __P((MAP *, char *, char **, int *)); \
		extern void store __P((MAP *, char *, char *)); \
		s = stab(name, ST_MAPCLASS, ST_ENTER); \
		s->s_mapclass.map_cname = name; \
		s->s_mapclass.map_ext = ext; \
		s->s_mapclass.map_cflags = flags; \
		s->s_mapclass.map_parse = parse; \
		s->s_mapclass.map_open = open; \
		s->s_mapclass.map_close = close; \
		s->s_mapclass.map_lookup = lookup; \
		s->s_mapclass.map_store = store; \
	}

static void
setupmaps()
{
	register STAB *s;

#if NEWDB
# if DB_VERSION_MAJOR > 1
	int major_v, minor_v, patch_v;

	(void) db_version(&major_v, &minor_v, &patch_v);
	if (major_v != DB_VERSION_MAJOR || minor_v != DB_VERSION_MINOR)
	{
		errno = 0;
		syserr("Berkeley DB version mismatch: compiled against %d.%d.%d, run-time linked against %d.%d.%d",
		  DB_VERSION_MAJOR, DB_VERSION_MINOR, DB_VERSION_PATCH,
		  major_v, minor_v, patch_v);
	}
# endif /* DB_VERSION_MAJOR > 1 */

	MAPDEF("hash", ".db", MCF_ALIASOK|MCF_REBUILDABLE,
		map_parseargs, hash_map_open, db_map_close,
		db_map_lookup, db_map_store);

	MAPDEF("btree", ".db", MCF_ALIASOK|MCF_REBUILDABLE,
		map_parseargs, bt_map_open, db_map_close,
		db_map_lookup, db_map_store);
#endif /* NEWDB */

#if NDBM
	MAPDEF("dbm", ".dir", MCF_ALIASOK|MCF_REBUILDABLE,
		map_parseargs, ndbm_map_open, ndbm_map_close,
		ndbm_map_lookup, ndbm_map_store);
#endif /* NDBM */

#if NIS
	MAPDEF("nis", NULL, MCF_ALIASOK,
		map_parseargs, nis_map_open, null_map_close,
		nis_map_lookup, null_map_store);
#endif /* NIS */

#if NISPLUS
	MAPDEF("nisplus", NULL, MCF_ALIASOK,
		map_parseargs, nisplus_map_open, null_map_close,
		nisplus_map_lookup, null_map_store);
#endif /* NISPLUS */

#if LDAPMAP
	MAPDEF("ldap", NULL, MCF_ALIASOK|MCF_NOTPERSIST,
		ldapmap_parseargs, ldapmap_open, ldapmap_close,
		ldapmap_lookup, null_map_store);
#endif /* LDAPMAP */

#if PH_MAP
	MAPDEF("ph", NULL, MCF_NOTPERSIST,
		ph_map_parseargs, ph_map_open, ph_map_close,
		ph_map_lookup, null_map_store);
#endif /* PH_MAP */

#if MAP_NSD
	/* IRIX 6.5 nsd support */
	MAPDEF("nsd", NULL, MCF_ALIASOK,
	       map_parseargs, null_map_open, null_map_close,
	       nsd_map_lookup, null_map_store);
#endif /* MAP_NSD */

#if HESIOD
	MAPDEF("hesiod", NULL, MCF_ALIASOK|MCF_ALIASONLY,
		map_parseargs, hes_map_open, hes_map_close,
		hes_map_lookup, null_map_store);
#endif /* HESIOD */

#if NETINFO
	MAPDEF("netinfo", NULL, MCF_ALIASOK,
		map_parseargs, ni_map_open, null_map_close,
		ni_map_lookup, null_map_store);
#endif /* NETINFO */

#if 0
	MAPDEF("dns", NULL, 0,
		dns_map_init, null_map_open, null_map_close,
		dns_map_lookup, null_map_store);
#endif /* 0 */

#if NAMED_BIND
# if DNSMAP
#  if _FFR_DNSMAP_ALIASABLE
	MAPDEF("dns", NULL, MCF_ALIASOK,
	       dns_map_parseargs, dns_map_open, null_map_close,
	       dns_map_lookup, null_map_store);
#  else /* _FFR_DNSMAP_ALIASABLE */
	MAPDEF("dns", NULL, 0,
	       dns_map_parseargs, dns_map_open, null_map_close,
	       dns_map_lookup, null_map_store);
#  endif /* _FFR_DNSMAP_ALIASABLE */
# endif /* DNSMAP */
#endif /* NAMED_BIND */

#if NAMED_BIND
	/* best MX DNS lookup */
	MAPDEF("bestmx", NULL, MCF_OPTFILE,
		map_parseargs, null_map_open, null_map_close,
		bestmx_map_lookup, null_map_store);
#endif /* NAMED_BIND */

	MAPDEF("host", NULL, 0,
		host_map_init, null_map_open, null_map_close,
		host_map_lookup, null_map_store);

	MAPDEF("text", NULL, MCF_ALIASOK,
		map_parseargs, text_map_open, null_map_close,
		text_map_lookup, null_map_store);

	MAPDEF("stab", NULL, MCF_ALIASOK|MCF_ALIASONLY,
		map_parseargs, stab_map_open, null_map_close,
		stab_map_lookup, stab_map_store);

	MAPDEF("implicit", NULL, MCF_ALIASOK|MCF_ALIASONLY|MCF_REBUILDABLE,
		map_parseargs, impl_map_open, impl_map_close,
		impl_map_lookup, impl_map_store);

	/* access to system passwd file */
	MAPDEF("user", NULL, MCF_OPTFILE,
		map_parseargs, user_map_open, null_map_close,
		user_map_lookup, null_map_store);

	/* dequote map */
	MAPDEF("dequote", NULL, 0,
		dequote_init, null_map_open, null_map_close,
		dequote_map, null_map_store);

#if MAP_REGEX
	MAPDEF("regex", NULL, 0,
		regex_map_init, null_map_open, null_map_close,
		regex_map_lookup, null_map_store);
#endif /* MAP_REGEX */

#if USERDB
	/* user database */
	MAPDEF("userdb", ".db", 0,
		map_parseargs, null_map_open, null_map_close,
		udb_map_lookup, null_map_store);
#endif /* USERDB */

	/* arbitrary programs */
	MAPDEF("program", NULL, MCF_ALIASOK,
		map_parseargs, null_map_open, null_map_close,
		prog_map_lookup, null_map_store);

	/* sequenced maps */
	MAPDEF("sequence", NULL, MCF_ALIASOK,
		seq_map_parse, null_map_open, null_map_close,
		seq_map_lookup, seq_map_store);

	/* switched interface to sequenced maps */
	MAPDEF("switch", NULL, MCF_ALIASOK,
		map_parseargs, switch_map_open, null_map_close,
		seq_map_lookup, seq_map_store);

	/* null map lookup -- really for internal use only */
	MAPDEF("null", NULL, MCF_ALIASOK|MCF_OPTFILE,
		map_parseargs, null_map_open, null_map_close,
		null_map_lookup, null_map_store);

	/* syslog map -- logs information to syslog */
	MAPDEF("syslog", NULL, 0,
		syslog_map_parseargs, null_map_open, null_map_close,
		syslog_map_lookup, null_map_store);

	/* macro storage map -- rulesets can set macros */
	MAPDEF("macro", NULL, 0,
		dequote_init, null_map_open, null_map_close,
		macro_map_lookup, null_map_store);

	/* arithmetic map -- add/subtract/compare */
	MAPDEF("arith", NULL, 0,
		dequote_init, null_map_open, null_map_close,
		arith_map_lookup, null_map_store);

#if _FFR_ARPA_MAP
	/* "arpa" map -- IP -> arpa */
	MAPDEF("arpa", NULL, 0,
		dequote_init, null_map_open, null_map_close,
		arpa_map_lookup, null_map_store);
#endif /* _FFR_ARPA_MAP */

#if SOCKETMAP
	/* arbitrary daemons */
	MAPDEF("socket", NULL, MCF_ALIASOK,
		map_parseargs, socket_map_open, socket_map_close,
		socket_map_lookup, null_map_store);
#endif /* SOCKETMAP */

#if _FFR_DPRINTF_MAP
	/* dprintf map -- logs information to syslog */
	MAPDEF("dprintf", NULL, 0,
		dprintf_map_parseargs, null_map_open, null_map_close,
		dprintf_map_lookup, null_map_store);
#endif /* _FFR_DPRINTF_MAP */

	if (tTd(38, 2))
	{
		/* bogus map -- always return tempfail */
		MAPDEF("bogus",	NULL, MCF_ALIASOK|MCF_OPTFILE,
		       map_parseargs, null_map_open, null_map_close,
		       bogus_map_lookup, null_map_store);
	}
}

#undef MAPDEF
/*
**  INITHOSTMAPS -- initial host-dependent maps
**
**	This should act as an interface to any local service switch
**	provided by the host operating system.
**
**	Parameters:
**		none
**
**	Returns:
**		none
**
**	Side Effects:
**		Should define maps "host" and "users" as necessary
**		for this OS.  If they are not defined, they will get
**		a default value later.  It should check to make sure
**		they are not defined first, since it's possible that
**		the config file has provided an override.
*/

void
inithostmaps()
{
	register int i;
	int nmaps;
	char *maptype[MAXMAPSTACK];
	short mapreturn[MAXMAPACTIONS];
	char buf[MAXLINE];

	/*
	**  Make sure we have a host map.
	*/

	if (stab("host", ST_MAP, ST_FIND) == NULL)
	{
		/* user didn't initialize: set up host map */
		(void) sm_strlcpy(buf, "host host", sizeof(buf));
#if NAMED_BIND
		if (ConfigLevel >= 2)
			(void) sm_strlcat(buf, " -a. -D", sizeof(buf));
#endif /* NAMED_BIND */
		(void) makemapentry(buf);
	}

	/*
	**  Set up default aliases maps
	*/

	nmaps = switch_map_find("aliases", maptype, mapreturn);
	for (i = 0; i < nmaps; i++)
	{
		if (strcmp(maptype[i], "files") == 0 &&
		    stab("aliases.files", ST_MAP, ST_FIND) == NULL)
		{
			(void) sm_strlcpy(buf, "aliases.files null",
					  sizeof(buf));
			(void) makemapentry(buf);
		}
#if NISPLUS
		else if (strcmp(maptype[i], "nisplus") == 0 &&
			 stab("aliases.nisplus", ST_MAP, ST_FIND) == NULL)
		{
			(void) sm_strlcpy(buf, "aliases.nisplus nisplus -kalias -vexpansion mail_aliases.org_dir",
				sizeof(buf));
			(void) makemapentry(buf);
		}
#endif /* NISPLUS */
#if NIS
		else if (strcmp(maptype[i], "nis") == 0 &&
			 stab("aliases.nis", ST_MAP, ST_FIND) == NULL)
		{
			(void) sm_strlcpy(buf, "aliases.nis nis mail.aliases",
				sizeof(buf));
			(void) makemapentry(buf);
		}
#endif /* NIS */
#if NETINFO
		else if (strcmp(maptype[i], "netinfo") == 0 &&
			 stab("aliases.netinfo", ST_MAP, ST_FIND) == NULL)
		{
			(void) sm_strlcpy(buf, "aliases.netinfo netinfo -z, /aliases",
				sizeof(buf));
			(void) makemapentry(buf);
		}
#endif /* NETINFO */
#if HESIOD
		else if (strcmp(maptype[i], "hesiod") == 0 &&
			 stab("aliases.hesiod", ST_MAP, ST_FIND) == NULL)
		{
			(void) sm_strlcpy(buf, "aliases.hesiod hesiod aliases",
				sizeof(buf));
			(void) makemapentry(buf);
		}
#endif /* HESIOD */
#if LDAPMAP && defined(SUN_EXTENSIONS) && \
    defined(SUN_SIMPLIFIED_LDAP) && HASLDAPGETALIASBYNAME
		else if (strcmp(maptype[i], "ldap") == 0 &&
		    stab("aliases.ldap", ST_MAP, ST_FIND) == NULL)
		{
			(void) sm_strlcpy(buf, "aliases.ldap ldap -b . -h localhost -k mail=%0 -v mailgroup",
				sizeof buf);
			(void) makemapentry(buf);
		}
#endif /* LDAPMAP && defined(SUN_EXTENSIONS) && ... */
	}
	if (stab("aliases", ST_MAP, ST_FIND) == NULL)
	{
		(void) sm_strlcpy(buf, "aliases switch aliases", sizeof(buf));
		(void) makemapentry(buf);
	}
}

/*
**  SWITCH_MAP_FIND -- find the list of types associated with a map
**
**	This is the system-dependent interface to the service switch.
**
**	Parameters:
**		service -- the name of the service of interest.
**		maptype -- an out-array of strings containing the types
**			of access to use for this service.  There can
**			be at most MAXMAPSTACK types for a single service.
**		mapreturn -- an out-array of return information bitmaps
**			for the map.
**
**	Returns:
**		The number of map types filled in, or -1 for failure.
**
**	Side effects:
**		Preserves errno so nothing in the routine clobbers it.
*/

#if defined(SOLARIS) || (defined(sony_news) && defined(__svr4))
# define _USE_SUN_NSSWITCH_
#endif /* defined(SOLARIS) || (defined(sony_news) && defined(__svr4)) */

#if _FFR_HPUX_NSSWITCH
# ifdef __hpux
#  define _USE_SUN_NSSWITCH_
# endif /* __hpux */
#endif /* _FFR_HPUX_NSSWITCH */

#ifdef _USE_SUN_NSSWITCH_
# include <nsswitch.h>
#endif /* _USE_SUN_NSSWITCH_ */

#if defined(ultrix) || (defined(__osf__) && defined(__alpha))
# define _USE_DEC_SVC_CONF_
#endif /* defined(ultrix) || (defined(__osf__) && defined(__alpha)) */

#ifdef _USE_DEC_SVC_CONF_
# include <sys/svcinfo.h>
#endif /* _USE_DEC_SVC_CONF_ */

int
switch_map_find(service, maptype, mapreturn)
	char *service;
	char *maptype[MAXMAPSTACK];
	short mapreturn[MAXMAPACTIONS];
{
	int svcno = 0;
	int save_errno = errno;

#ifdef _USE_SUN_NSSWITCH_
	struct __nsw_switchconfig *nsw_conf;
	enum __nsw_parse_err pserr;
	struct __nsw_lookup *lk;
	static struct __nsw_lookup lkp0 =
		{ "files", {1, 0, 0, 0}, NULL, NULL };
	static struct __nsw_switchconfig lkp_default =
		{ 0, "sendmail", 3, &lkp0 };

	for (svcno = 0; svcno < MAXMAPACTIONS; svcno++)
		mapreturn[svcno] = 0;

	if ((nsw_conf = __nsw_getconfig(service, &pserr)) == NULL)
		lk = lkp_default.lookups;
	else
		lk = nsw_conf->lookups;
	svcno = 0;
	while (lk != NULL && svcno < MAXMAPSTACK)
	{
		maptype[svcno] = lk->service_name;
		if (lk->actions[__NSW_NOTFOUND] == __NSW_RETURN)
			mapreturn[MA_NOTFOUND] |= 1 << svcno;
		if (lk->actions[__NSW_TRYAGAIN] == __NSW_RETURN)
			mapreturn[MA_TRYAGAIN] |= 1 << svcno;
		if (lk->actions[__NSW_UNAVAIL] == __NSW_RETURN)
			mapreturn[MA_TRYAGAIN] |= 1 << svcno;
		svcno++;
		lk = lk->next;
	}
	errno = save_errno;
	return svcno;
#endif /* _USE_SUN_NSSWITCH_ */

#ifdef _USE_DEC_SVC_CONF_
	struct svcinfo *svcinfo;
	int svc;

	for (svcno = 0; svcno < MAXMAPACTIONS; svcno++)
		mapreturn[svcno] = 0;

	svcinfo = getsvc();
	if (svcinfo == NULL)
		goto punt;
	if (strcmp(service, "hosts") == 0)
		svc = SVC_HOSTS;
	else if (strcmp(service, "aliases") == 0)
		svc = SVC_ALIASES;
	else if (strcmp(service, "passwd") == 0)
		svc = SVC_PASSWD;
	else
	{
		errno = save_errno;
		return -1;
	}
	for (svcno = 0; svcno < SVC_PATHSIZE && svcno < MAXMAPSTACK; svcno++)
	{
		switch (svcinfo->svcpath[svc][svcno])
		{
		  case SVC_LOCAL:
			maptype[svcno] = "files";
			break;

		  case SVC_YP:
			maptype[svcno] = "nis";
			break;

		  case SVC_BIND:
			maptype[svcno] = "dns";
			break;

# ifdef SVC_HESIOD
		  case SVC_HESIOD:
			maptype[svcno] = "hesiod";
			break;
# endif /* SVC_HESIOD */

		  case SVC_LAST:
			errno = save_errno;
			return svcno;
		}
	}
	errno = save_errno;
	return svcno;
#endif /* _USE_DEC_SVC_CONF_ */

#if !defined(_USE_SUN_NSSWITCH_) && !defined(_USE_DEC_SVC_CONF_)
	/*
	**  Fall-back mechanism.
	*/

	STAB *st;
	static time_t servicecachetime;	/* time service switch was cached */
	time_t now = curtime();

	for (svcno = 0; svcno < MAXMAPACTIONS; svcno++)
		mapreturn[svcno] = 0;

	if ((now - servicecachetime) > (time_t) ServiceCacheMaxAge)
	{
		/* (re)read service switch */
		register SM_FILE_T *fp;
		long sff = SFF_REGONLY|SFF_OPENASROOT|SFF_NOLOCK;

		if (!bitnset(DBS_LINKEDSERVICESWITCHFILEINWRITABLEDIR,
			    DontBlameSendmail))
			sff |= SFF_NOWLINK;

		if (ConfigFileRead)
			servicecachetime = now;
		fp = safefopen(ServiceSwitchFile, O_RDONLY, 0, sff);
		if (fp != NULL)
		{
			char buf[MAXLINE];

			while (sm_io_fgets(fp, SM_TIME_DEFAULT, buf,
					   sizeof(buf)) >= 0)
			{
				register char *p;

				p = strpbrk(buf, "#\n");
				if (p != NULL)
					*p = '\0';
#ifndef SM_NSSWITCH_DELIMS
# define SM_NSSWITCH_DELIMS	" \t"
#endif /* SM_NSSWITCH_DELIMS */
				p = strpbrk(buf, SM_NSSWITCH_DELIMS);
				if (p != NULL)
					*p++ = '\0';
				if (buf[0] == '\0')
					continue;
				if (p == NULL)
				{
					sm_syslog(LOG_ERR, NOQID,
						  "Bad line on %.100s: %.100s",
						  ServiceSwitchFile,
						  buf);
					continue;
				}
				while (isascii(*p) && isspace(*p))
					p++;
				if (*p == '\0')
					continue;

				/*
				**  Find/allocate space for this service entry.
				**	Space for all of the service strings
				**	are allocated at once.  This means
				**	that we only have to free the first
				**	one to free all of them.
				*/

				st = stab(buf, ST_SERVICE, ST_ENTER);
				if (st->s_service[0] != NULL)
					sm_free((void *) st->s_service[0]); /* XXX */
				p = newstr(p);
				for (svcno = 0; svcno < MAXMAPSTACK; )
				{
					if (*p == '\0')
						break;
					st->s_service[svcno++] = p;
					p = strpbrk(p, " \t");
					if (p == NULL)
						break;
					*p++ = '\0';
					while (isascii(*p) && isspace(*p))
						p++;
				}
				if (svcno < MAXMAPSTACK)
					st->s_service[svcno] = NULL;
			}
			(void) sm_io_close(fp, SM_TIME_DEFAULT);
		}
	}

	/* look up entry in cache */
	st = stab(service, ST_SERVICE, ST_FIND);
	if (st != NULL && st->s_service[0] != NULL)
	{
		/* extract data */
		svcno = 0;
		while (svcno < MAXMAPSTACK)
		{
			maptype[svcno] = st->s_service[svcno];
			if (maptype[svcno++] == NULL)
				break;
		}
		errno = save_errno;
		return --svcno;
	}
#endif /* !defined(_USE_SUN_NSSWITCH_) && !defined(_USE_DEC_SVC_CONF_) */

#if !defined(_USE_SUN_NSSWITCH_)
	/* if the service file doesn't work, use an absolute fallback */
# ifdef _USE_DEC_SVC_CONF_
  punt:
# endif /* _USE_DEC_SVC_CONF_ */
	for (svcno = 0; svcno < MAXMAPACTIONS; svcno++)
		mapreturn[svcno] = 0;
	svcno = 0;
	if (strcmp(service, "aliases") == 0)
	{
		maptype[svcno++] = "files";
# if defined(AUTO_NETINFO_ALIASES) && defined (NETINFO)
		maptype[svcno++] = "netinfo";
# endif /* defined(AUTO_NETINFO_ALIASES) && defined (NETINFO) */
# ifdef AUTO_NIS_ALIASES
#  if NISPLUS
		maptype[svcno++] = "nisplus";
#  endif /* NISPLUS */
#  if NIS
		maptype[svcno++] = "nis";
#  endif /* NIS */
# endif /* AUTO_NIS_ALIASES */
		errno = save_errno;
		return svcno;
	}
	if (strcmp(service, "hosts") == 0)
	{
# if NAMED_BIND
		maptype[svcno++] = "dns";
# else /* NAMED_BIND */
#  if defined(sun) && !defined(BSD)
		/* SunOS */
		maptype[svcno++] = "nis";
#  endif /* defined(sun) && !defined(BSD) */
# endif /* NAMED_BIND */
# if defined(AUTO_NETINFO_HOSTS) && defined (NETINFO)
		maptype[svcno++] = "netinfo";
# endif /* defined(AUTO_NETINFO_HOSTS) && defined (NETINFO) */
		maptype[svcno++] = "files";
		errno = save_errno;
		return svcno;
	}
	errno = save_errno;
	return -1;
#endif /* !defined(_USE_SUN_NSSWITCH_) */
}
/*
**  USERNAME -- return the user id of the logged in user.
**
**	Parameters:
**		none.
**
**	Returns:
**		The login name of the logged in user.
**
**	Side Effects:
**		none.
**
**	Notes:
**		The return value is statically allocated.
*/

char *
username()
{
	static char *myname = NULL;
	extern char *getlogin();
	register struct passwd *pw;

	/* cache the result */
	if (myname == NULL)
	{
		myname = getlogin();
		if (myname == NULL || myname[0] == '\0')
		{
			pw = sm_getpwuid(RealUid);
			if (pw != NULL)
				myname = pw->pw_name;
		}
		else
		{
			uid_t uid = RealUid;

			if ((pw = sm_getpwnam(myname)) == NULL ||
			      (uid != 0 && uid != pw->pw_uid))
			{
				pw = sm_getpwuid(uid);
				if (pw != NULL)
					myname = pw->pw_name;
			}
		}
		if (myname == NULL || myname[0] == '\0')
		{
			syserr("554 5.3.0 Who are you?");
			myname = "postmaster";
		}
		else if (strpbrk(myname, ",;:/|\"\\") != NULL)
			myname = addquotes(myname, NULL);
		else
			myname = sm_pstrdup_x(myname);
	}
	return myname;
}
/*
**  TTYPATH -- Get the path of the user's tty
**
**	Returns the pathname of the user's tty.  Returns NULL if
**	the user is not logged in or if s/he has write permission
**	denied.
**
**	Parameters:
**		none
**
**	Returns:
**		pathname of the user's tty.
**		NULL if not logged in or write permission denied.
**
**	Side Effects:
**		none.
**
**	WARNING:
**		Return value is in a local buffer.
**
**	Called By:
**		savemail
*/

char *
ttypath()
{
	struct stat stbuf;
	register char *pathn;
	extern char *ttyname();
	extern char *getlogin();

	/* compute the pathname of the controlling tty */
	if ((pathn = ttyname(2)) == NULL && (pathn = ttyname(1)) == NULL &&
	    (pathn = ttyname(0)) == NULL)
	{
		errno = 0;
		return NULL;
	}

	/* see if we have write permission */
	if (stat(pathn, &stbuf) < 0 || !bitset(S_IWOTH, stbuf.st_mode))
	{
		errno = 0;
		return NULL;
	}

	/* see if the user is logged in */
	if (getlogin() == NULL)
		return NULL;

	/* looks good */
	return pathn;
}
/*
**  CHECKCOMPAT -- check for From and To person compatible.
**
**	This routine can be supplied on a per-installation basis
**	to determine whether a person is allowed to send a message.
**	This allows restriction of certain types of internet
**	forwarding or registration of users.
**
**	If the hosts are found to be incompatible, an error
**	message should be given using "usrerr" and an EX_ code
**	should be returned.  You can also set to->q_status to
**	a DSN-style status code.
**
**	EF_NO_BODY_RETN can be set in e->e_flags to suppress the
**	body during the return-to-sender function; this should be done
**	on huge messages.  This bit may already be set by the ESMTP
**	protocol.
**
**	Parameters:
**		to -- the person being sent to.
**
**	Returns:
**		an exit status
**
**	Side Effects:
**		none (unless you include the usrerr stuff)
*/

int
checkcompat(to, e)
	register ADDRESS *to;
	register ENVELOPE *e;
{
	if (tTd(49, 1))
		sm_dprintf("checkcompat(to=%s, from=%s)\n",
			to->q_paddr, e->e_from.q_paddr);

#ifdef EXAMPLE_CODE
	/* this code is intended as an example only */
	register STAB *s;

	s = stab("arpa", ST_MAILER, ST_FIND);
	if (s != NULL && strcmp(e->e_from.q_mailer->m_name, "local") != 0 &&
	    to->q_mailer == s->s_mailer)
	{
		usrerr("553 No ARPA mail through this machine: see your system administration");
		/* e->e_flags |= EF_NO_BODY_RETN; to suppress body on return */
		to->q_status = "5.7.1";
		return EX_UNAVAILABLE;
	}
#endif /* EXAMPLE_CODE */
	return EX_OK;
}

#ifdef SUN_EXTENSIONS
static void
init_md_sun()
{
	struct stat sbuf;

	/* Check for large file descriptor */
	if (fstat(fileno(stdin), &sbuf) < 0)
	{
		if (errno == EOVERFLOW)
		{
			perror("stdin");
			exit(EX_NOINPUT);
		}
	}
}
#endif /* SUN_EXTENSIONS */

/*
**  INIT_MD -- do machine dependent initializations
**
**	Systems that have global modes that should be set should do
**	them here rather than in main.
*/

#ifdef _AUX_SOURCE
# include <compat.h>
#endif /* _AUX_SOURCE */

#if SHARE_V1
# include <shares.h>
#endif /* SHARE_V1 */

void
init_md(argc, argv)
	int argc;
	char **argv;
{
#ifdef _AUX_SOURCE
	setcompat(getcompat() | COMPAT_BSDPROT);
#endif /* _AUX_SOURCE */

#ifdef SUN_EXTENSIONS
	init_md_sun();
#endif /* SUN_EXTENSIONS */

#if _CONVEX_SOURCE
	/* keep gethostby*() from stripping the local domain name */
	set_domain_trim_off();
#endif /* _CONVEX_SOURCE */
#if defined(__QNX__) && !defined(__QNXNTO__)
	/*
	**  Due to QNX's network distributed nature, you can target a tcpip
	**  stack on a different node in the qnx network; this patch lets
	**  this feature work.  The __sock_locate() must be done before the
	**  environment is clear.
	*/
	__sock_locate();
#endif /* __QNX__ */
#if SECUREWARE || defined(_SCO_unix_)
	set_auth_parameters(argc, argv);

# ifdef _SCO_unix_
	/*
	**  This is required for highest security levels (the kernel
	**  won't let it call set*uid() or run setuid binaries without
	**  it).  It may be necessary on other SECUREWARE systems.
	*/

	if (getluid() == -1)
		setluid(0);
# endif /* _SCO_unix_ */
#endif /* SECUREWARE || defined(_SCO_unix_) */


#ifdef VENDOR_DEFAULT
	VendorCode = VENDOR_DEFAULT;
#else /* VENDOR_DEFAULT */
	VendorCode = VENDOR_BERKELEY;
#endif /* VENDOR_DEFAULT */
}
/*
**  INIT_VENDOR_MACROS -- vendor-dependent macro initializations
**
**	Called once, on startup.
**
**	Parameters:
**		e -- the global envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		vendor-dependent.
*/

void
init_vendor_macros(e)
	register ENVELOPE *e;
{
}
/*
**  GETLA -- get the current load average
**
**	This code stolen from la.c.
**
**	Parameters:
**		none.
**
**	Returns:
**		The current load average as an integer.
**
**	Side Effects:
**		none.
*/

/* try to guess what style of load average we have */
#define LA_ZERO		1	/* always return load average as zero */
#define LA_INT		2	/* read kmem for avenrun; interpret as long */
#define LA_FLOAT	3	/* read kmem for avenrun; interpret as float */
#define LA_SUBR		4	/* call getloadavg */
#define LA_MACH		5	/* MACH load averages (as on NeXT boxes) */
#define LA_SHORT	6	/* read kmem for avenrun; interpret as short */
#define LA_PROCSTR	7	/* read string ("1.17") from /proc/loadavg */
#define LA_READKSYM	8	/* SVR4: use MIOC_READKSYM ioctl call */
#define LA_DGUX		9	/* special DGUX implementation */
#define LA_HPUX		10	/* special HPUX implementation */
#define LA_IRIX6	11	/* special IRIX 6.2 implementation */
#define LA_KSTAT	12	/* special Solaris kstat(3k) implementation */
#define LA_DEVSHORT	13	/* read short from a device */
#define LA_ALPHAOSF	14	/* Digital UNIX (OSF/1 on Alpha) table() call */
#define LA_PSET		15	/* Solaris per-processor-set load average */
#define LA_LONGLONG	17 /* read kmem for avenrun; interpret as long long */

/* do guesses based on general OS type */
#ifndef LA_TYPE
# define LA_TYPE	LA_ZERO
#endif /* ! LA_TYPE */

#ifndef FSHIFT
# if defined(unixpc)
#  define FSHIFT	5
# endif /* defined(unixpc) */

# if defined(__alpha) || defined(IRIX)
#  define FSHIFT	10
# endif /* defined(__alpha) || defined(IRIX) */

#endif /* ! FSHIFT */

#ifndef FSHIFT
# define FSHIFT		8
#endif /* ! FSHIFT */

#ifndef FSCALE
# define FSCALE		(1 << FSHIFT)
#endif /* ! FSCALE */

#ifndef LA_AVENRUN
# ifdef SYSTEM5
#  define LA_AVENRUN	"avenrun"
# else /* SYSTEM5 */
#  define LA_AVENRUN	"_avenrun"
# endif /* SYSTEM5 */
#endif /* ! LA_AVENRUN */

/* _PATH_KMEM should be defined in <paths.h> */
#ifndef _PATH_KMEM
# define _PATH_KMEM	"/dev/kmem"
#endif /* ! _PATH_KMEM */

#if (LA_TYPE == LA_INT) || (LA_TYPE == LA_FLOAT) || (LA_TYPE == LA_SHORT) || (LA_TYPE == LA_LONGLONG)

# include <nlist.h>

/* _PATH_UNIX should be defined in <paths.h> */
# ifndef _PATH_UNIX
#  if defined(SYSTEM5)
#   define _PATH_UNIX	"/unix"
#  else /* defined(SYSTEM5) */
#   define _PATH_UNIX	"/vmunix"
#  endif /* defined(SYSTEM5) */
# endif /* ! _PATH_UNIX */

# ifdef _AUX_SOURCE
struct nlist	Nl[2];
# else /* _AUX_SOURCE */
struct nlist	Nl[] =
{
	{ LA_AVENRUN },
	{ 0 },
};
# endif /* _AUX_SOURCE */
# define X_AVENRUN	0

int
getla()
{
	int j;
	static int kmem = -1;
# if LA_TYPE == LA_INT
	long avenrun[3];
# else /* LA_TYPE == LA_INT */
#  if LA_TYPE == LA_SHORT
	short avenrun[3];
#  else
#   if LA_TYPE == LA_LONGLONG
	long long avenrun[3];
#   else /* LA_TYPE == LA_LONGLONG */
	double avenrun[3];
#   endif /* LA_TYPE == LA_LONGLONG */
#  endif /* LA_TYPE == LA_SHORT */
# endif /* LA_TYPE == LA_INT */
	extern off_t lseek();

	if (kmem < 0)
	{
# ifdef _AUX_SOURCE
		(void) sm_strlcpy(Nl[X_AVENRUN].n_name, LA_AVENRUN,
			       sizeof(Nl[X_AVENRUN].n_name));
		Nl[1].n_name[0] = '\0';
# endif /* _AUX_SOURCE */

# if defined(_AIX3) || defined(_AIX4)
		if (knlist(Nl, 1, sizeof(Nl[0])) < 0)
# else /* defined(_AIX3) || defined(_AIX4) */
		if (nlist(_PATH_UNIX, Nl) < 0)
# endif /* defined(_AIX3) || defined(_AIX4) */
		{
			if (tTd(3, 1))
				sm_dprintf("getla: nlist(%s): %s\n", _PATH_UNIX,
					   sm_errstring(errno));
			return -1;
		}
		if (Nl[X_AVENRUN].n_value == 0)
		{
			if (tTd(3, 1))
				sm_dprintf("getla: nlist(%s, %s) ==> 0\n",
					_PATH_UNIX, LA_AVENRUN);
			return -1;
		}
# ifdef NAMELISTMASK
		Nl[X_AVENRUN].n_value &= NAMELISTMASK;
# endif /* NAMELISTMASK */

		kmem = open(_PATH_KMEM, 0, 0);
		if (kmem < 0)
		{
			if (tTd(3, 1))
				sm_dprintf("getla: open(/dev/kmem): %s\n",
					   sm_errstring(errno));
			return -1;
		}
		if ((j = fcntl(kmem, F_GETFD, 0)) < 0 ||
		    fcntl(kmem, F_SETFD, j | FD_CLOEXEC) < 0)
		{
			if (tTd(3, 1))
				sm_dprintf("getla: fcntl(/dev/kmem, FD_CLOEXEC): %s\n",
					   sm_errstring(errno));
			(void) close(kmem);
			kmem = -1;
			return -1;
		}
	}
	if (tTd(3, 20))
		sm_dprintf("getla: symbol address = %#lx\n",
			(unsigned long) Nl[X_AVENRUN].n_value);
	if (lseek(kmem, (off_t) Nl[X_AVENRUN].n_value, SEEK_SET) == -1 ||
	    read(kmem, (char *) avenrun, sizeof(avenrun)) != sizeof(avenrun))
	{
		/* thank you Ian */
		if (tTd(3, 1))
			sm_dprintf("getla: lseek or read: %s\n",
				   sm_errstring(errno));
		return -1;
	}
# if (LA_TYPE == LA_INT) || (LA_TYPE == LA_SHORT) || (LA_TYPE == LA_LONGLONG)
	if (tTd(3, 5))
	{
#  if LA_TYPE == LA_SHORT
		sm_dprintf("getla: avenrun = %d", avenrun[0]);
		if (tTd(3, 15))
			sm_dprintf(", %d, %d", avenrun[1], avenrun[2]);
#  else /* LA_TYPE == LA_SHORT */
#   if LA_TYPE == LA_LONGLONG
		sm_dprintf("getla: avenrun = %lld", avenrun[0]);
		if (tTd(3, 15))
			sm_dprintf(", %lld, %lld", avenrun[1], avenrun[2]);
#   else /* LA_TYPE == LA_LONGLONG */
		sm_dprintf("getla: avenrun = %ld", avenrun[0]);
		if (tTd(3, 15))
			sm_dprintf(", %ld, %ld", avenrun[1], avenrun[2]);
#   endif /* LA_TYPE == LA_LONGLONG */
#  endif /* LA_TYPE == LA_SHORT */
		sm_dprintf("\n");
	}
	if (tTd(3, 1))
		sm_dprintf("getla: %d\n",
			(int) (avenrun[0] + FSCALE/2) >> FSHIFT);
	return ((int) (avenrun[0] + FSCALE/2) >> FSHIFT);
# else /* (LA_TYPE == LA_INT) || (LA_TYPE == LA_SHORT) || (LA_TYPE == LA_LONGLONG) */
	if (tTd(3, 5))
	{
		sm_dprintf("getla: avenrun = %g", avenrun[0]);
		if (tTd(3, 15))
			sm_dprintf(", %g, %g", avenrun[1], avenrun[2]);
		sm_dprintf("\n");
	}
	if (tTd(3, 1))
		sm_dprintf("getla: %d\n", (int) (avenrun[0] +0.5));
	return ((int) (avenrun[0] + 0.5));
# endif /* (LA_TYPE == LA_INT) || (LA_TYPE == LA_SHORT) || (LA_TYPE == LA_LONGLONG) */
}

#endif /* (LA_TYPE == LA_INT) || (LA_TYPE == LA_FLOAT) || (LA_TYPE == LA_SHORT) || (LA_TYPE == LA_LONGLONG) */

#if LA_TYPE == LA_READKSYM

# include <sys/ksym.h>

int
getla()
{
	int j;
	static int kmem = -1;
	long avenrun[3];
	struct mioc_rksym mirk;

	if (kmem < 0)
	{
		kmem = open("/dev/kmem", 0, 0);
		if (kmem < 0)
		{
			if (tTd(3, 1))
				sm_dprintf("getla: open(/dev/kmem): %s\n",
					   sm_errstring(errno));
			return -1;
		}
		if ((j = fcntl(kmem, F_GETFD, 0)) < 0 ||
		    fcntl(kmem, F_SETFD, j | FD_CLOEXEC) < 0)
		{
			if (tTd(3, 1))
				sm_dprintf("getla: fcntl(/dev/kmem, FD_CLOEXEC): %s\n",
					   sm_errstring(errno));
			(void) close(kmem);
			kmem = -1;
			return -1;
		}
	}
	mirk.mirk_symname = LA_AVENRUN;
	mirk.mirk_buf = avenrun;
	mirk.mirk_buflen = sizeof(avenrun);
	if (ioctl(kmem, MIOC_READKSYM, &mirk) < 0)
	{
		if (tTd(3, 1))
			sm_dprintf("getla: ioctl(MIOC_READKSYM) failed: %s\n",
				   sm_errstring(errno));
		return -1;
	}
	if (tTd(3, 5))
	{
		sm_dprintf("getla: avenrun = %d", avenrun[0]);
		if (tTd(3, 15))
			sm_dprintf(", %d, %d", avenrun[1], avenrun[2]);
		sm_dprintf("\n");
	}
	if (tTd(3, 1))
		sm_dprintf("getla: %d\n",
			(int) (avenrun[0] + FSCALE/2) >> FSHIFT);
	return ((int) (avenrun[0] + FSCALE/2) >> FSHIFT);
}

#endif /* LA_TYPE == LA_READKSYM */

#if LA_TYPE == LA_DGUX

# include <sys/dg_sys_info.h>

int
getla()
{
	struct dg_sys_info_load_info load_info;

	dg_sys_info((long *)&load_info,
		DG_SYS_INFO_LOAD_INFO_TYPE, DG_SYS_INFO_LOAD_VERSION_0);

	if (tTd(3, 1))
		sm_dprintf("getla: %d\n", (int) (load_info.one_minute + 0.5));

	return ((int) (load_info.one_minute + 0.5));
}

#endif /* LA_TYPE == LA_DGUX */

#if LA_TYPE == LA_HPUX

/* forward declarations to keep gcc from complaining */
struct pst_dynamic;
struct pst_status;
struct pst_static;
struct pst_vminfo;
struct pst_diskinfo;
struct pst_processor;
struct pst_lv;
struct pst_swapinfo;

# include <sys/param.h>
# include <sys/pstat.h>

int
getla()
{
	struct pst_dynamic pstd;

	if (pstat_getdynamic(&pstd, sizeof(struct pst_dynamic),
			     (size_t) 1, 0) == -1)
		return 0;

	if (tTd(3, 1))
		sm_dprintf("getla: %d\n", (int) (pstd.psd_avg_1_min + 0.5));

	return (int) (pstd.psd_avg_1_min + 0.5);
}

#endif /* LA_TYPE == LA_HPUX */

#if LA_TYPE == LA_SUBR

int
getla()
{
	double avenrun[3];

	if (getloadavg(avenrun, sizeof(avenrun) / sizeof(avenrun[0])) < 0)
	{
		if (tTd(3, 1))
			sm_dprintf("getla: getloadavg failed: %s",
				   sm_errstring(errno));
		return -1;
	}
	if (tTd(3, 1))
		sm_dprintf("getla: %d\n", (int) (avenrun[0] +0.5));
	return ((int) (avenrun[0] + 0.5));
}

#endif /* LA_TYPE == LA_SUBR */

#if LA_TYPE == LA_MACH

/*
**  This has been tested on NEXTSTEP release 2.1/3.X.
*/

# if defined(NX_CURRENT_COMPILER_RELEASE) && NX_CURRENT_COMPILER_RELEASE > NX_COMPILER_RELEASE_3_0
#  include <mach/mach.h>
# else /* defined(NX_CURRENT_COMPILER_RELEASE) && NX_CURRENT_COMPILER_RELEASE > NX_COMPILER_RELEASE_3_0 */
#  include <mach.h>
# endif /* defined(NX_CURRENT_COMPILER_RELEASE) && NX_CURRENT_COMPILER_RELEASE > NX_COMPILER_RELEASE_3_0 */

int
getla()
{
	processor_set_t default_set;
	kern_return_t error;
	unsigned int info_count;
	struct processor_set_basic_info info;
	host_t host;

	error = processor_set_default(host_self(), &default_set);
	if (error != KERN_SUCCESS)
	{
		if (tTd(3, 1))
			sm_dprintf("getla: processor_set_default failed: %s",
				   sm_errstring(errno));
		return -1;
	}
	info_count = PROCESSOR_SET_BASIC_INFO_COUNT;
	if (processor_set_info(default_set, PROCESSOR_SET_BASIC_INFO,
			       &host, (processor_set_info_t)&info,
			       &info_count) != KERN_SUCCESS)
	{
		if (tTd(3, 1))
			sm_dprintf("getla: processor_set_info failed: %s",
				   sm_errstring(errno));
		return -1;
	}
	if (tTd(3, 1))
		sm_dprintf("getla: %d\n",
			(int) ((info.load_average + (LOAD_SCALE / 2)) /
			       LOAD_SCALE));
	return (int) (info.load_average + (LOAD_SCALE / 2)) / LOAD_SCALE;
}

#endif /* LA_TYPE == LA_MACH */

#if LA_TYPE == LA_PROCSTR
# if SM_CONF_BROKEN_STRTOD
	ERROR: This OS has most likely a broken strtod() implemenentation.
	ERROR: The function is required for getla().
	ERROR: Check the compilation options _LA_PROCSTR and
	ERROR: _SM_CONF_BROKEN_STRTOD (without the leading _).
# endif /* SM_CONF_BROKEN_STRTOD */

/*
**  Read /proc/loadavg for the load average.  This is assumed to be
**  in a format like "0.15 0.12 0.06".
**
**	Initially intended for Linux.  This has been in the kernel
**	since at least 0.99.15.
*/

# ifndef _PATH_LOADAVG
#  define _PATH_LOADAVG	"/proc/loadavg"
# endif /* ! _PATH_LOADAVG */

int
getla()
{
	double avenrun;
	register int result;
	SM_FILE_T *fp;

	fp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, _PATH_LOADAVG, SM_IO_RDONLY,
			NULL);
	if (fp == NULL)
	{
		if (tTd(3, 1))
			sm_dprintf("getla: sm_io_open(%s): %s\n",
				   _PATH_LOADAVG, sm_errstring(errno));
		return -1;
	}
	result = sm_io_fscanf(fp, SM_TIME_DEFAULT, "%lf", &avenrun);
	(void) sm_io_close(fp, SM_TIME_DEFAULT);
	if (result != 1)
	{
		if (tTd(3, 1))
			sm_dprintf("getla: sm_io_fscanf() = %d: %s\n",
				   result, sm_errstring(errno));
		return -1;
	}

	if (tTd(3, 1))
		sm_dprintf("getla(): %.2f\n", avenrun);

	return ((int) (avenrun + 0.5));
}

#endif /* LA_TYPE == LA_PROCSTR */

#if LA_TYPE == LA_IRIX6

# include <sys/sysmp.h>

# ifdef _UNICOSMP
#  define CAST_SYSMP(x)	(x)
# else /* _UNICOSMP */
#  define CAST_SYSMP(x)	((x) & 0x7fffffff)
# endif /* _UNICOSMP */

int
getla(void)
{
	int j;
	static int kmem = -1;
	int avenrun[3];

	if (kmem < 0)
	{
		kmem = open(_PATH_KMEM, 0, 0);
		if (kmem < 0)
		{
			if (tTd(3, 1))
				sm_dprintf("getla: open(%s): %s\n", _PATH_KMEM,
					   sm_errstring(errno));
			return -1;
		}
		if ((j = fcntl(kmem, F_GETFD, 0)) < 0 ||
		    fcntl(kmem, F_SETFD, j | FD_CLOEXEC) < 0)
		{
			if (tTd(3, 1))
				sm_dprintf("getla: fcntl(/dev/kmem, FD_CLOEXEC): %s\n",
					   sm_errstring(errno));
			(void) close(kmem);
			kmem = -1;
			return -1;
		}
	}

	if (lseek(kmem, CAST_SYSMP(sysmp(MP_KERNADDR, MPKA_AVENRUN)), SEEK_SET)
		== -1 ||
	    read(kmem, (char *) avenrun, sizeof(avenrun)) != sizeof(avenrun))
	{
		if (tTd(3, 1))
			sm_dprintf("getla: lseek or read: %s\n",
				   sm_errstring(errno));
		return -1;
	}
	if (tTd(3, 5))
	{
		sm_dprintf("getla: avenrun = %ld", (long int) avenrun[0]);
		if (tTd(3, 15))
			sm_dprintf(", %ld, %ld",
				(long int) avenrun[1], (long int) avenrun[2]);
		sm_dprintf("\n");
	}

	if (tTd(3, 1))
		sm_dprintf("getla: %d\n",
			(int) (avenrun[0] + FSCALE/2) >> FSHIFT);
	return ((int) (avenrun[0] + FSCALE/2) >> FSHIFT);

}
#endif /* LA_TYPE == LA_IRIX6 */

#if LA_TYPE == LA_KSTAT

# include <kstat.h>

int
getla()
{
	static kstat_ctl_t *kc = NULL;
	static kstat_t *ksp = NULL;
	kstat_named_t *ksn;
	int la;

	if (kc == NULL)		/* if not initialized before */
		kc = kstat_open();
	if (kc == NULL)
	{
		if (tTd(3, 1))
			sm_dprintf("getla: kstat_open(): %s\n",
				   sm_errstring(errno));
		return -1;
	}
	if (ksp == NULL)
		ksp = kstat_lookup(kc, "unix", 0, "system_misc");
	if (ksp == NULL)
	{
		if (tTd(3, 1))
			sm_dprintf("getla: kstat_lookup(): %s\n",
				   sm_errstring(errno));
		return -1;
	}
	if (kstat_read(kc, ksp, NULL) < 0)
	{
		if (tTd(3, 1))
			sm_dprintf("getla: kstat_read(): %s\n",
				   sm_errstring(errno));
		return -1;
	}
	ksn = (kstat_named_t *) kstat_data_lookup(ksp, "avenrun_1min");
	la = ((double) ksn->value.ul + FSCALE/2) / FSCALE;
	/* kstat_close(kc); /o do not close for fast access */
	return la;
}

#endif /* LA_TYPE == LA_KSTAT */

#if LA_TYPE == LA_DEVSHORT

/*
**  Read /dev/table/avenrun for the load average.  This should contain
**  three shorts for the 1, 5, and 15 minute loads.  We only read the
**  first, since that's all we care about.
**
**	Intended for SCO OpenServer 5.
*/

# ifndef _PATH_AVENRUN
#  define _PATH_AVENRUN	"/dev/table/avenrun"
# endif /* ! _PATH_AVENRUN */

int
getla()
{
	static int afd = -1;
	short avenrun;
	int loadav;
	int r;

	errno = EBADF;

	if (afd == -1 || lseek(afd, 0L, SEEK_SET) == -1)
	{
		if (errno != EBADF)
			return -1;
		afd = open(_PATH_AVENRUN, O_RDONLY|O_SYNC);
		if (afd < 0)
		{
			sm_syslog(LOG_ERR, NOQID,
				"can't open %s: %s",
				_PATH_AVENRUN, sm_errstring(errno));
			return -1;
		}
	}

	r = read(afd, &avenrun, sizeof(avenrun));
	if (r != sizeof(avenrun))
	{
		sm_syslog(LOG_ERR, NOQID,
			"can't read %s: %s", _PATH_AVENRUN,
			r == -1 ? sm_errstring(errno) : "short read");
		return -1;
	}

	if (tTd(3, 5))
		sm_dprintf("getla: avenrun = %d\n", avenrun);
	loadav = (int) (avenrun + FSCALE/2) >> FSHIFT;
	if (tTd(3, 1))
		sm_dprintf("getla: %d\n", loadav);
	return loadav;
}

#endif /* LA_TYPE == LA_DEVSHORT */

#if LA_TYPE == LA_ALPHAOSF
struct rtentry;
struct mbuf;
# include <sys/table.h>

int
getla()
{
	int ave = 0;
	struct tbl_loadavg tab;

	if (table(TBL_LOADAVG, 0, &tab, 1, sizeof(tab)) == -1)
	{
		if (tTd(3, 1))
			sm_dprintf("getla: table %s\n", sm_errstring(errno));
		return -1;
	}

	if (tTd(3, 1))
		sm_dprintf("getla: scale = %d\n", tab.tl_lscale);

	if (tab.tl_lscale)
		ave = ((tab.tl_avenrun.l[2] + (tab.tl_lscale/2)) /
		       tab.tl_lscale);
	else
		ave = (int) (tab.tl_avenrun.d[2] + 0.5);

	if (tTd(3, 1))
		sm_dprintf("getla: %d\n", ave);

	return ave;
}

#endif /* LA_TYPE == LA_ALPHAOSF */

#if LA_TYPE == LA_PSET

int
getla()
{
	double avenrun[3];

	if (pset_getloadavg(PS_MYID, avenrun,
			    sizeof(avenrun) / sizeof(avenrun[0])) < 0)
	{
		if (tTd(3, 1))
			sm_dprintf("getla: pset_getloadavg failed: %s",
				   sm_errstring(errno));
		return -1;
	}
	if (tTd(3, 1))
		sm_dprintf("getla: %d\n", (int) (avenrun[0] +0.5));
	return ((int) (avenrun[0] + 0.5));
}

#endif /* LA_TYPE == LA_PSET */

#if LA_TYPE == LA_ZERO

int
getla()
{
	if (tTd(3, 1))
		sm_dprintf("getla: ZERO\n");
	return 0;
}

#endif /* LA_TYPE == LA_ZERO */

/*
 * Copyright 1989 Massachusetts Institute of Technology
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of M.I.T. not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  M.I.T. makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * M.I.T. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL M.I.T.
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Authors:  Many and varied...
 */

/* Non Apollo stuff removed by Don Lewis 11/15/93 */
#ifndef lint
SM_UNUSED(static char  rcsid[]) = "@@(#)$OrigId: getloadavg.c,v 1.16 1991/06/21 12:51:15 paul Exp $";
#endif /* ! lint */

#ifdef apollo
# undef volatile
# include <apollo/base.h>

/* ARGSUSED */
int getloadavg( call_data )
	caddr_t call_data;	/* pointer to (double) return value */
{
	double *avenrun = (double *) call_data;
	int i;
	status_$t      st;
	long loadav[3];

	proc1_$get_loadav(loadav, &st);
	*avenrun = loadav[0] / (double) (1 << 16);
	return 0;
}
#endif /* apollo */
/*
**  SM_GETLA -- get the current load average
**
**	Parameters:
**		none
**
**	Returns:
**		none
**
**	Side Effects:
**		Set CurrentLA to the current load average.
**		Set {load_avg} in GlobalMacros to the current load average.
*/

void
sm_getla()
{
	char labuf[8];

	CurrentLA = getla();
	(void) sm_snprintf(labuf, sizeof(labuf), "%d", CurrentLA);
	macdefine(&GlobalMacros, A_TEMP, macid("{load_avg}"), labuf);
}
/*
**  SHOULDQUEUE -- should this message be queued or sent?
**
**	Compares the message cost to the load average to decide.
**
**	Note: Do NOT change this API! It is documented in op.me
**		and theoretically the user can change this function...
**
**	Parameters:
**		pri -- the priority of the message in question.
**		ct -- the message creation time (unused, but see above).
**
**	Returns:
**		true -- if this message should be queued up for the
**			time being.
**		false -- if the load is low enough to send this message.
**
**	Side Effects:
**		none.
*/

/* ARGSUSED1 */
bool
shouldqueue(pri, ct)
	long pri;
	time_t ct;
{
	bool rval;
#if _FFR_MEMSTAT
	long memfree;
#endif /* _FFR_MEMSTAT */

	if (tTd(3, 30))
		sm_dprintf("shouldqueue: CurrentLA=%d, pri=%ld: ",
			CurrentLA, pri);

#if _FFR_MEMSTAT
	if (QueueLowMem > 0 &&
	    sm_memstat_get(MemoryResource, &memfree) >= 0 &&
	    memfree < QueueLowMem)
	{
		if (tTd(3, 30))
			sm_dprintf("true (memfree=%ld < QueueLowMem=%ld)\n",
				memfree, QueueLowMem);
		return true;
	}
#endif /* _FFR_MEMSTAT */
	if (CurrentLA < QueueLA)
	{
		if (tTd(3, 30))
			sm_dprintf("false (CurrentLA < QueueLA)\n");
		return false;
	}
	rval = pri > (QueueFactor / (CurrentLA - QueueLA + 1));
	if (tTd(3, 30))
		sm_dprintf("%s (by calculation)\n", rval ? "true" : "false");
	return rval;
}

/*
**  REFUSECONNECTIONS -- decide if connections should be refused
**
**	Parameters:
**		e -- the current envelope.
**		dn -- number of daemon.
**		active -- was this daemon actually active?
**
**	Returns:
**		true if incoming SMTP connections should be refused
**			(for now).
**		false if we should accept new work.
**
**	Side Effects:
**		Sets process title when it is rejecting connections.
*/

bool
refuseconnections(e, dn, active)
	ENVELOPE *e;
	int dn;
	bool active;
{
	static time_t lastconn[MAXDAEMONS];
	static int conncnt[MAXDAEMONS];
	static time_t firstrejtime[MAXDAEMONS];
	static time_t nextlogtime[MAXDAEMONS];
	int limit;
#if _FFR_MEMSTAT
	long memfree;
#endif /* _FFR_MEMSTAT */

#if XLA
	if (!xla_smtp_ok())
		return true;
#endif /* XLA */

	SM_ASSERT(dn >= 0);
	SM_ASSERT(dn < MAXDAEMONS);
	if (ConnRateThrottle > 0)
	{
		time_t now;

		now = curtime();
		if (active)
		{
			if (now != lastconn[dn])
			{
				lastconn[dn] = now;
				conncnt[dn] = 1;
			}
			else if (conncnt[dn]++ > ConnRateThrottle)
			{
#define D_MSG_CRT "deferring connections on daemon %s: %d per second"
				/* sleep to flatten out connection load */
				sm_setproctitle(true, e, D_MSG_CRT,
						Daemons[dn].d_name,
						ConnRateThrottle);
				if (LogLevel > 8)
					sm_syslog(LOG_INFO, NOQID, D_MSG_CRT,
						  Daemons[dn].d_name,
						  ConnRateThrottle);
				(void) sleep(1);
			}
		}
		else if (now != lastconn[dn])
			conncnt[dn] = 0;
	}


#if _FFR_MEMSTAT
	if (RefuseLowMem > 0 &&
	    sm_memstat_get(MemoryResource, &memfree) >= 0 &&
	    memfree < RefuseLowMem)
	{
# define R_MSG_LM "rejecting connections on daemon %s: free memory: %ld"
		sm_setproctitle(true, e, R_MSG_LM, Daemons[dn].d_name, memfree);
		if (LogLevel > 8)
			sm_syslog(LOG_NOTICE, NOQID, R_MSG_LM,
				Daemons[dn].d_name, memfree);
		return true;
	}
#endif /* _FFR_MEMSTAT */
	sm_getla();
	limit = (Daemons[dn].d_refuseLA != DPO_NOTSET) ?
		Daemons[dn].d_refuseLA : RefuseLA;
	if (limit > 0 && CurrentLA >= limit)
	{
		time_t now;

# define R_MSG_LA "rejecting connections on daemon %s: load average: %d"
# define R2_MSG_LA "have been rejecting connections on daemon %s for %s"
		sm_setproctitle(true, e, R_MSG_LA, Daemons[dn].d_name,
				CurrentLA);
		if (LogLevel > 8)
			sm_syslog(LOG_NOTICE, NOQID, R_MSG_LA,
				Daemons[dn].d_name, CurrentLA);
		now = curtime();
		if (firstrejtime[dn] == 0)
		{
			firstrejtime[dn] = now;
			nextlogtime[dn] = now + RejectLogInterval;
		}
		else if (nextlogtime[dn] < now)
		{
			sm_syslog(LOG_ERR, NOQID, R2_MSG_LA, Daemons[dn].d_name,
				  pintvl(now - firstrejtime[dn], true));
			nextlogtime[dn] = now + RejectLogInterval;
		}
		return true;
	}
	else
		firstrejtime[dn] = 0;

	limit = (Daemons[dn].d_delayLA != DPO_NOTSET) ?
		Daemons[dn].d_delayLA : DelayLA;
	if (limit > 0 && CurrentLA >= limit)
	{
		time_t now;
		static time_t log_delay = (time_t) 0;

# define MIN_DELAY_LOG	90	/* wait before logging this again */
# define D_MSG_LA "delaying connections on daemon %s: load average=%d >= %d"
		/* sleep to flatten out connection load */
		sm_setproctitle(true, e, D_MSG_LA, Daemons[dn].d_name,
			        CurrentLA, limit);
		if (LogLevel > 8 && (now = curtime()) > log_delay)
		{
			sm_syslog(LOG_INFO, NOQID, D_MSG_LA,
				  Daemons[dn].d_name, CurrentLA, limit);
			log_delay = now + MIN_DELAY_LOG;
		}
		(void) sleep(1);
	}

	limit = (Daemons[dn].d_maxchildren != DPO_NOTSET) ?
		Daemons[dn].d_maxchildren : MaxChildren;
	if (limit > 0 && CurChildren >= limit)
	{
		proc_list_probe();
		if (CurChildren >= limit)
		{
#define R_MSG_CHILD "rejecting connections on daemon %s: %d children, max %d"
			sm_setproctitle(true, e, R_MSG_CHILD,
					Daemons[dn].d_name, CurChildren,
					limit);
			if (LogLevel > 8)
				sm_syslog(LOG_INFO, NOQID, R_MSG_CHILD,
					Daemons[dn].d_name, CurChildren,
					limit);
			return true;
		}
	}
	return false;
}

/*
**  SETPROCTITLE -- set process title for ps
**
**	Parameters:
**		fmt -- a printf style format string.
**		a, b, c -- possible parameters to fmt.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Clobbers argv of our main procedure so ps(1) will
**		display the title.
*/

#define SPT_NONE	0	/* don't use it at all */
#define SPT_REUSEARGV	1	/* cover argv with title information */
#define SPT_BUILTIN	2	/* use libc builtin */
#define SPT_PSTAT	3	/* use pstat(PSTAT_SETCMD, ...) */
#define SPT_PSSTRINGS	4	/* use PS_STRINGS->... */
#define SPT_SYSMIPS	5	/* use sysmips() supported by NEWS-OS 6 */
#define SPT_SCO		6	/* write kernel u. area */
#define SPT_CHANGEARGV	7	/* write our own strings into argv[] */

#ifndef SPT_TYPE
# define SPT_TYPE	SPT_REUSEARGV
#endif /* ! SPT_TYPE */


#if SPT_TYPE != SPT_NONE && SPT_TYPE != SPT_BUILTIN

# if SPT_TYPE == SPT_PSTAT
#  include <sys/pstat.h>
# endif /* SPT_TYPE == SPT_PSTAT */
# if SPT_TYPE == SPT_PSSTRINGS
#  include <machine/vmparam.h>
#  include <sys/exec.h>
#  ifndef PS_STRINGS	/* hmmmm....  apparently not available after all */
#   undef SPT_TYPE
#   define SPT_TYPE	SPT_REUSEARGV
#  else /* ! PS_STRINGS */
#   ifndef NKPDE			/* FreeBSD 2.0 */
#    define NKPDE 63
typedef unsigned int	*pt_entry_t;
#   endif /* ! NKPDE */
#  endif /* ! PS_STRINGS */
# endif /* SPT_TYPE == SPT_PSSTRINGS */

# if SPT_TYPE == SPT_PSSTRINGS || SPT_TYPE == SPT_CHANGEARGV
#  define SETPROC_STATIC	static
# else /* SPT_TYPE == SPT_PSSTRINGS || SPT_TYPE == SPT_CHANGEARGV */
#  define SETPROC_STATIC
# endif /* SPT_TYPE == SPT_PSSTRINGS || SPT_TYPE == SPT_CHANGEARGV */

# if SPT_TYPE == SPT_SYSMIPS
#  include <sys/sysmips.h>
#  include <sys/sysnews.h>
# endif /* SPT_TYPE == SPT_SYSMIPS */

# if SPT_TYPE == SPT_SCO
#  include <sys/immu.h>
#  include <sys/dir.h>
#  include <sys/user.h>
#  include <sys/fs/s5param.h>
#  if PSARGSZ > MAXLINE
#   define SPT_BUFSIZE	PSARGSZ
#  endif /* PSARGSZ > MAXLINE */
# endif /* SPT_TYPE == SPT_SCO */

# ifndef SPT_PADCHAR
#  define SPT_PADCHAR	' '
# endif /* ! SPT_PADCHAR */

#endif /* SPT_TYPE != SPT_NONE && SPT_TYPE != SPT_BUILTIN */

#ifndef SPT_BUFSIZE
# define SPT_BUFSIZE	MAXLINE
#endif /* ! SPT_BUFSIZE */

#if _FFR_SPT_ALIGN

/*
**  It looks like the Compaq Tru64 5.1A now aligns argv and envp to
**  64 bit alignment, so unless each piece of argv and envp is a multiple
**  of 8 bytes (including terminating NULL), initsetproctitle() won't use
**  any of the space beyond argv[0].  Be sure to set SPT_ALIGN_SIZE if
**  you use this FFR.
*/

# ifdef SPT_ALIGN_SIZE
#  define SPT_ALIGN(x, align)	(((((x) + SPT_ALIGN_SIZE) >> (align)) << (align)) - 1)
# else /* SPT_ALIGN_SIZE */
#  define SPT_ALIGN(x, align)	(x)
# endif /* SPT_ALIGN_SIZE */
#else /* _FFR_SPT_ALIGN */
# define SPT_ALIGN(x, align)	(x)
#endif /* _FFR_SPT_ALIGN */

/*
**  Pointers for setproctitle.
**	This allows "ps" listings to give more useful information.
*/

static char	**Argv = NULL;		/* pointer to argument vector */
static char	*LastArgv = NULL;	/* end of argv */
#if SPT_TYPE != SPT_BUILTIN
static void	setproctitle __P((const char *, ...));
#endif /* SPT_TYPE != SPT_BUILTIN */

void
initsetproctitle(argc, argv, envp)
	int argc;
	char **argv;
	char **envp;
{
	register int i;
	int align;
	extern char **environ;

	/*
	**  Move the environment so setproctitle can use the space at
	**  the top of memory.
	*/

	if (envp != NULL)
	{
		for (i = 0; envp[i] != NULL; i++)
			continue;
		environ = (char **) xalloc(sizeof(char *) * (i + 1));
		for (i = 0; envp[i] != NULL; i++)
			environ[i] = newstr(envp[i]);
		environ[i] = NULL;
	}

	/*
	**  Save start and extent of argv for setproctitle.
	*/

	Argv = argv;

	/*
	**  Determine how much space we can use for setproctitle.
	**  Use all contiguous argv and envp pointers starting at argv[0]
	*/

	align = -1;
# if _FFR_SPT_ALIGN
#  ifdef SPT_ALIGN_SIZE
	for (i = SPT_ALIGN_SIZE; i > 0; i >>= 1)
		align++;
#  endif /* SPT_ALIGN_SIZE */
# endif /* _FFR_SPT_ALIGN */

	for (i = 0; i < argc; i++)
	{
		if (i == 0 || LastArgv + 1 == argv[i])
			LastArgv = argv[i] + SPT_ALIGN(strlen(argv[i]), align);
	}
	for (i = 0; LastArgv != NULL && envp != NULL && envp[i] != NULL; i++)
	{
		if (LastArgv + 1 == envp[i])
			LastArgv = envp[i] + SPT_ALIGN(strlen(envp[i]), align);
	}
}

#if SPT_TYPE != SPT_BUILTIN

/*VARARGS1*/
static void
# ifdef __STDC__
setproctitle(const char *fmt, ...)
# else /* __STDC__ */
setproctitle(fmt, va_alist)
	const char *fmt;
	va_dcl
# endif /* __STDC__ */
{
# if SPT_TYPE != SPT_NONE
	register int i;
	register char *p;
	SETPROC_STATIC char buf[SPT_BUFSIZE];
	SM_VA_LOCAL_DECL
#  if SPT_TYPE == SPT_PSTAT
	union pstun pst;
#  endif /* SPT_TYPE == SPT_PSTAT */
#  if SPT_TYPE == SPT_SCO
	int j;
	off_t seek_off;
	static int kmem = -1;
	static pid_t kmempid = -1;
	struct user u;
#  endif /* SPT_TYPE == SPT_SCO */

	p = buf;

	/* print sendmail: heading for grep */
	(void) sm_strlcpy(p, "sendmail: ", SPACELEFT(buf, p));
	p += strlen(p);

	/* print the argument string */
	SM_VA_START(ap, fmt);
	(void) sm_vsnprintf(p, SPACELEFT(buf, p), fmt, ap);
	SM_VA_END(ap);

	i = (int) strlen(buf);
	if (i < 0)
		return;

#  if SPT_TYPE == SPT_PSTAT
	pst.pst_command = buf;
	pstat(PSTAT_SETCMD, pst, i, 0, 0);
#  endif /* SPT_TYPE == SPT_PSTAT */
#  if SPT_TYPE == SPT_PSSTRINGS
	PS_STRINGS->ps_nargvstr = 1;
	PS_STRINGS->ps_argvstr = buf;
#  endif /* SPT_TYPE == SPT_PSSTRINGS */
#  if SPT_TYPE == SPT_SYSMIPS
	sysmips(SONY_SYSNEWS, NEWS_SETPSARGS, buf);
#  endif /* SPT_TYPE == SPT_SYSMIPS */
#  if SPT_TYPE == SPT_SCO
	if (kmem < 0 || kmempid != CurrentPid)
	{
		if (kmem >= 0)
			(void) close(kmem);
		kmem = open(_PATH_KMEM, O_RDWR, 0);
		if (kmem < 0)
			return;
		if ((j = fcntl(kmem, F_GETFD, 0)) < 0 ||
		    fcntl(kmem, F_SETFD, j | FD_CLOEXEC) < 0)
		{
			(void) close(kmem);
			kmem = -1;
			return;
		}
		kmempid = CurrentPid;
	}
	buf[PSARGSZ - 1] = '\0';
	seek_off = UVUBLK + (off_t) u.u_psargs - (off_t) &u;
	if (lseek(kmem, (off_t) seek_off, SEEK_SET) == seek_off)
		(void) write(kmem, buf, PSARGSZ);
#  endif /* SPT_TYPE == SPT_SCO */
#  if SPT_TYPE == SPT_REUSEARGV
	if (LastArgv == NULL)
		return;

	if (i > LastArgv - Argv[0] - 2)
	{
		i = LastArgv - Argv[0] - 2;
		buf[i] = '\0';
	}
	(void) sm_strlcpy(Argv[0], buf, i + 1);
	p = &Argv[0][i];
	while (p < LastArgv)
		*p++ = SPT_PADCHAR;
	Argv[1] = NULL;
#  endif /* SPT_TYPE == SPT_REUSEARGV */
#  if SPT_TYPE == SPT_CHANGEARGV
	Argv[0] = buf;
	Argv[1] = 0;
#  endif /* SPT_TYPE == SPT_CHANGEARGV */
# endif /* SPT_TYPE != SPT_NONE */
}

#endif /* SPT_TYPE != SPT_BUILTIN */
/*
**  SM_SETPROCTITLE -- set process task and set process title for ps
**
**	Possibly set process status and call setproctitle() to
**	change the ps display.
**
**	Parameters:
**		status -- whether or not to store as process status
**		e -- the current envelope.
**		fmt -- a printf style format string.
**		a, b, c -- possible parameters to fmt.
**
**	Returns:
**		none.
*/

/*VARARGS3*/
void
#ifdef __STDC__
sm_setproctitle(bool status, ENVELOPE *e, const char *fmt, ...)
#else /* __STDC__ */
sm_setproctitle(status, e, fmt, va_alist)
	bool status;
	ENVELOPE *e;
	const char *fmt;
	va_dcl
#endif /* __STDC__ */
{
	char buf[SPT_BUFSIZE];
	SM_VA_LOCAL_DECL

	/* print the argument string */
	SM_VA_START(ap, fmt);
	(void) sm_vsnprintf(buf, sizeof(buf), fmt, ap);
	SM_VA_END(ap);

	if (status)
		proc_list_set(CurrentPid, buf);

	if (ProcTitlePrefix != NULL)
	{
		char prefix[SPT_BUFSIZE];

		expand(ProcTitlePrefix, prefix, sizeof(prefix), e);
		setproctitle("%s: %s", prefix, buf);
	}
	else
		setproctitle("%s", buf);
}
/*
**  WAITFOR -- wait for a particular process id.
**
**	Parameters:
**		pid -- process id to wait for.
**
**	Returns:
**		status of pid.
**		-1 if pid never shows up.
**
**	Side Effects:
**		none.
*/

int
waitfor(pid)
	pid_t pid;
{
	int st;
	pid_t i;

	do
	{
		errno = 0;
		i = sm_wait(&st);
		if (i > 0)
			proc_list_drop(i, st, NULL);
	} while ((i >= 0 || errno == EINTR) && i != pid);
	if (i < 0)
		return -1;
	return st;
}
/*
**  SM_WAIT -- wait
**
**	Parameters:
**		status -- pointer to status (return value)
**
**	Returns:
**		pid
*/

pid_t
sm_wait(status)
	int *status;
{
# ifdef WAITUNION
	union wait st;
# else /* WAITUNION */
	auto int st;
# endif /* WAITUNION */
	pid_t i;
# if defined(ISC_UNIX) || defined(_SCO_unix_)
	int savesig;
# endif /* defined(ISC_UNIX) || defined(_SCO_unix_) */

# if defined(ISC_UNIX) || defined(_SCO_unix_)
	savesig = sm_releasesignal(SIGCHLD);
# endif /* defined(ISC_UNIX) || defined(_SCO_unix_) */
	i = wait(&st);
# if defined(ISC_UNIX) || defined(_SCO_unix_)
	if (savesig > 0)
		sm_blocksignal(SIGCHLD);
# endif /* defined(ISC_UNIX) || defined(_SCO_unix_) */
# ifdef WAITUNION
	*status = st.w_status;
# else /* WAITUNION */
	*status = st;
# endif /* WAITUNION */
	return i;
}
/*
**  REAPCHILD -- pick up the body of my child, lest it become a zombie
**
**	Parameters:
**		sig -- the signal that got us here (unused).
**
**	Returns:
**		none.
**
**	Side Effects:
**		Picks up extant zombies.
**		Control socket exits may restart/shutdown daemon.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

/* ARGSUSED0 */
SIGFUNC_DECL
reapchild(sig)
	int sig;
{
	int save_errno = errno;
	int st;
	pid_t pid;
# if HASWAITPID
	auto int status;
	int count;

	count = 0;
	while ((pid = waitpid(-1, &status, WNOHANG)) > 0)
	{
		st = status;
		if (count++ > 1000)
			break;
# else /* HASWAITPID */
#  ifdef WNOHANG
	union wait status;

	while ((pid = wait3(&status, WNOHANG, (struct rusage *) NULL)) > 0)
	{
		st = status.w_status;
#  else /* WNOHANG */
	auto int status;

	/*
	**  Catch one zombie -- we will be re-invoked (we hope) if there
	**  are more.  Unreliable signals probably break this, but this
	**  is the "old system" situation -- waitpid or wait3 are to be
	**  strongly preferred.
	*/

	if ((pid = wait(&status)) > 0)
	{
		st = status;
#  endif /* WNOHANG */
# endif /* HASWAITPID */
		/* Drop PID and check if it was a control socket child */
		proc_list_drop(pid, st, NULL);
	}
	FIX_SYSV_SIGNAL(sig, reapchild);
	errno = save_errno;
	return SIGFUNC_RETURN;
}
/*
**  GETDTABLESIZE -- return number of file descriptors
**
**	Only on non-BSD systems
**
**	Parameters:
**		none
**
**	Returns:
**		size of file descriptor table
**
**	Side Effects:
**		none
*/

#ifdef SOLARIS
# include <sys/resource.h>
#endif /* SOLARIS */

int
getdtsize()
{
# ifdef RLIMIT_NOFILE
	struct rlimit rl;

	if (getrlimit(RLIMIT_NOFILE, &rl) >= 0)
		return rl.rlim_cur;
# endif /* RLIMIT_NOFILE */

# if HASGETDTABLESIZE
	return getdtablesize();
# else /* HASGETDTABLESIZE */
#  ifdef _SC_OPEN_MAX
	return sysconf(_SC_OPEN_MAX);
#  else /* _SC_OPEN_MAX */
	return NOFILE;
#  endif /* _SC_OPEN_MAX */
# endif /* HASGETDTABLESIZE */
}
/*
**  UNAME -- get the UUCP name of this system.
*/

#if !HASUNAME

int
uname(name)
	struct utsname *name;
{
	SM_FILE_T *file;
	char *n;

	name->nodename[0] = '\0';

	/* try /etc/whoami -- one line with the node name */
	if ((file = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, "/etc/whoami",
			       SM_IO_RDONLY, NULL)) != NULL)
	{
		(void) sm_io_fgets(file, SM_TIME_DEFAULT, name->nodename,
				   NODE_LENGTH + 1);
		(void) sm_io_close(file, SM_TIME_DEFAULT);
		n = strchr(name->nodename, '\n');
		if (n != NULL)
			*n = '\0';
		if (name->nodename[0] != '\0')
			return 0;
	}

	/* try /usr/include/whoami.h -- has a #define somewhere */
	if ((file = sm_io_open(SmFtStdio, SM_TIME_DEFAULT,
			       "/usr/include/whoami.h", SM_IO_RDONLY, NULL))
	    != NULL)
	{
		char buf[MAXLINE];

		while (sm_io_fgets(file, SM_TIME_DEFAULT,
				   buf, sizeof(buf)) >= 0)
		{
			if (sm_io_sscanf(buf, "#define sysname \"%*[^\"]\"",
					NODE_LENGTH, name->nodename) > 0)
				break;
		}
		(void) sm_io_close(file, SM_TIME_DEFAULT);
		if (name->nodename[0] != '\0')
			return 0;
	}

	return -1;
}
#endif /* !HASUNAME */
/*
**  INITGROUPS -- initialize groups
**
**	Stub implementation for System V style systems
*/

#if !HASINITGROUPS

initgroups(name, basegid)
	char *name;
	int basegid;
{
	return 0;
}

#endif /* !HASINITGROUPS */
/*
**  SETGROUPS -- set group list
**
**	Stub implementation for systems that don't have group lists
*/

#ifndef NGROUPS_MAX

int
setgroups(ngroups, grouplist)
	int ngroups;
	GIDSET_T grouplist[];
{
	return 0;
}

#endif /* ! NGROUPS_MAX */
/*
**  SETSID -- set session id (for non-POSIX systems)
*/

#if !HASSETSID

pid_t
setsid __P ((void))
{
#  ifdef TIOCNOTTY
	int fd;

	fd = open("/dev/tty", O_RDWR, 0);
	if (fd >= 0)
	{
		(void) ioctl(fd, TIOCNOTTY, (char *) 0);
		(void) close(fd);
	}
#  endif /* TIOCNOTTY */
#  ifdef SYS5SETPGRP
	return setpgrp();
#  else /* SYS5SETPGRP */
	return setpgid(0, CurrentPid);
#  endif /* SYS5SETPGRP */
}

#endif /* !HASSETSID */
/*
**  FSYNC -- dummy fsync
*/

#if NEEDFSYNC

fsync(fd)
	int fd;
{
# ifdef O_SYNC
	return fcntl(fd, F_SETFL, O_SYNC);
# else /* O_SYNC */
	/* nothing we can do */
	return 0;
# endif /* O_SYNC */
}

#endif /* NEEDFSYNC */
/*
**  DGUX_INET_ADDR -- inet_addr for DG/UX
**
**	Data General DG/UX version of inet_addr returns a struct in_addr
**	instead of a long.  This patches things.  Only needed on versions
**	prior to 5.4.3.
*/

#ifdef DGUX_5_4_2

# undef inet_addr

long
dgux_inet_addr(host)
	char *host;
{
	struct in_addr haddr;

	haddr = inet_addr(host);
	return haddr.s_addr;
}

#endif /* DGUX_5_4_2 */
/*
**  GETOPT -- for old systems or systems with bogus implementations
*/

#if !SM_CONF_GETOPT

/*
 * Copyright (c) 1985 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 */


/*
**  this version hacked to add `atend' flag to allow state machine
**  to reset if invoked by the program to scan args for a 2nd time
*/

# if defined(LIBC_SCCS) && !defined(lint)
static char sccsid[] = "@@(#)getopt.c	4.3 (Berkeley) 3/9/86";
# endif /* defined(LIBC_SCCS) && !defined(lint) */

/*
**  get option letter from argument vector
*/
# ifdef _CONVEX_SOURCE
extern int	optind, opterr, optopt;
extern char	*optarg;
# else /* _CONVEX_SOURCE */
int	opterr = 1;		/* if error message should be printed */
int	optind = 1;		/* index into parent argv vector */
int	optopt = 0;		/* character checked for validity */
char	*optarg = NULL;		/* argument associated with option */
# endif /* _CONVEX_SOURCE */

# define BADCH	(int)'?'
# define EMSG	""
# define tell(s)	if (opterr) \
			{sm_io_fputs(smioerr, SM_TIME_DEFAULT, *nargv); \
			(void) sm_io_fputs(smioerr, SM_TIME_DEFAULT, s); \
			(void) sm_io_putc(smioerr, SM_TIME_DEFAULT, optopt); \
			(void) sm_io_putc(smioerr, SM_TIME_DEFAULT, '\n'); \
			return BADCH;}

int
getopt(nargc,nargv,ostr)
	int		nargc;
	char *const	*nargv;
	const char	*ostr;
{
	static char	*place = EMSG;	/* option letter processing */
	static char	atend = 0;
	register char	*oli = NULL;	/* option letter list index */

	if (atend) {
		atend = 0;
		place = EMSG;
	}
	if(!*place) {			/* update scanning pointer */
		if (optind >= nargc || *(place = nargv[optind]) != '-' || !*++place) {
			atend++;
			return -1;
		}
		if (*place == '-') {	/* found "--" */
			++optind;
			atend++;
			return -1;
		}
	}				/* option letter okay? */
	if ((optopt = (int)*place++) == (int)':' || !(oli = strchr(ostr,optopt))) {
		if (!*place) ++optind;
		tell(": illegal option -- ");
	}
	if (oli && *++oli != ':') {		/* don't need argument */
		optarg = NULL;
		if (!*place) ++optind;
	}
	else {				/* need an argument */
		if (*place) optarg = place;	/* no white space */
		else if (nargc <= ++optind) {	/* no arg */
			place = EMSG;
			tell(": option requires an argument -- ");
		}
		else optarg = nargv[optind];	/* white space */
		place = EMSG;
		++optind;
	}
	return optopt;			/* dump back option letter */
}

#endif /* !SM_CONF_GETOPT */
/*
**  USERSHELLOK -- tell if a user's shell is ok for unrestricted use
**
**	Parameters:
**		user -- the name of the user we are checking.
**		shell -- the user's shell from /etc/passwd
**
**	Returns:
**		true -- if it is ok to use this for unrestricted access.
**		false -- if the shell is restricted.
*/

#if !HASGETUSERSHELL

# ifndef _PATH_SHELLS
#  define _PATH_SHELLS	"/etc/shells"
# endif /* ! _PATH_SHELLS */

# if defined(_AIX3) || defined(_AIX4)
#  include <userconf.h>
#  if _AIX4 >= 40200
#   include <userpw.h>
#  endif /* _AIX4 >= 40200 */
#  include <usersec.h>
# endif /* defined(_AIX3) || defined(_AIX4) */

static char	*DefaultUserShells[] =
{
	"/bin/sh",		/* standard shell */
# ifdef MPE
	"/SYS/PUB/CI",
# else /* MPE */
	"/usr/bin/sh",
	"/bin/csh",		/* C shell */
	"/usr/bin/csh",
# endif /* MPE */
# ifdef __hpux
#  ifdef V4FS
	"/usr/bin/rsh",		/* restricted Bourne shell */
	"/usr/bin/ksh",		/* Korn shell */
	"/usr/bin/rksh",	/* restricted Korn shell */
	"/usr/bin/pam",
	"/usr/bin/keysh",	/* key shell (extended Korn shell) */
	"/usr/bin/posix/sh",
#  else /* V4FS */
	"/bin/rsh",		/* restricted Bourne shell */
	"/bin/ksh",		/* Korn shell */
	"/bin/rksh",		/* restricted Korn shell */
	"/bin/pam",
	"/usr/bin/keysh",	/* key shell (extended Korn shell) */
	"/bin/posix/sh",
	"/sbin/sh",
#  endif /* V4FS */
# endif /* __hpux */
# if defined(_AIX3) || defined(_AIX4)
	"/bin/ksh",		/* Korn shell */
	"/usr/bin/ksh",
	"/bin/tsh",		/* trusted shell */
	"/usr/bin/tsh",
	"/bin/bsh",		/* Bourne shell */
	"/usr/bin/bsh",
# endif /* defined(_AIX3) || defined(_AIX4) */
# if defined(__svr4__) || defined(__svr5__)
	"/bin/ksh",		/* Korn shell */
	"/usr/bin/ksh",
# endif /* defined(__svr4__) || defined(__svr5__) */
# ifdef sgi
	"/sbin/sh",		/* SGI's shells really live in /sbin */
	"/usr/bin/sh",
	"/sbin/bsh",		/* classic Bourne shell */
	"/bin/bsh",
	"/usr/bin/bsh",
	"/sbin/csh",		/* standard csh */
	"/bin/csh",
	"/usr/bin/csh",
	"/sbin/jsh",		/* classic Bourne shell w/ job control*/
	"/bin/jsh",
	"/usr/bin/jsh",
	"/bin/ksh",		/* Korn shell */
	"/sbin/ksh",
	"/usr/bin/ksh",
	"/sbin/tcsh",		/* Extended csh */
	"/bin/tcsh",
	"/usr/bin/tcsh",
# endif /* sgi */
	NULL
};

#endif /* !HASGETUSERSHELL */

#define WILDCARD_SHELL	"/SENDMAIL/ANY/SHELL/"

bool
usershellok(user, shell)
	char *user;
	char *shell;
{
# if HASGETUSERSHELL
	register char *p;
	extern char *getusershell();

	if (shell == NULL || shell[0] == '\0' || wordinclass(user, 't') ||
	    ConfigLevel <= 1)
		return true;

	setusershell();
	while ((p = getusershell()) != NULL)
		if (strcmp(p, shell) == 0 || strcmp(p, WILDCARD_SHELL) == 0)
			break;
	endusershell();
	return p != NULL;
# else /* HASGETUSERSHELL */
#  if USEGETCONFATTR
	auto char *v;
#  endif /* USEGETCONFATTR */
	register SM_FILE_T *shellf;
	char buf[MAXLINE];

	if (shell == NULL || shell[0] == '\0' || wordinclass(user, 't') ||
	    ConfigLevel <= 1)
		return true;

#  if USEGETCONFATTR
	/*
	**  Naturally IBM has a "better" idea.....
	**
	**	What a crock.  This interface isn't documented, it is
	**	considered part of the security library (-ls), and it
	**	only works if you are running as root (since the list
	**	of valid shells is obviously a source of great concern).
	**	I recommend that you do NOT define USEGETCONFATTR,
	**	especially since you are going to have to set up an
	**	/etc/shells anyhow to handle the cases where getconfattr
	**	fails.
	*/

	if (getconfattr(SC_SYS_LOGIN, SC_SHELLS, &v, SEC_LIST) == 0 && v != NULL)
	{
		while (*v != '\0')
		{
			if (strcmp(v, shell) == 0 || strcmp(v, WILDCARD_SHELL) == 0)
				return true;
			v += strlen(v) + 1;
		}
		return false;
	}
#  endif /* USEGETCONFATTR */

	shellf = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, _PATH_SHELLS,
			    SM_IO_RDONLY, NULL);
	if (shellf == NULL)
	{
		/* no /etc/shells; see if it is one of the std shells */
		char **d;

		if (errno != ENOENT && LogLevel > 3)
			sm_syslog(LOG_ERR, NOQID,
				  "usershellok: cannot open %s: %s",
				  _PATH_SHELLS, sm_errstring(errno));

		for (d = DefaultUserShells; *d != NULL; d++)
		{
			if (strcmp(shell, *d) == 0)
				return true;
		}
		return false;
	}

	while (sm_io_fgets(shellf, SM_TIME_DEFAULT, buf, sizeof(buf)) >= 0)
	{
		register char *p, *q;

		p = buf;
		while (*p != '\0' && *p != '#' && *p != '/')
			p++;
		if (*p == '#' || *p == '\0')
			continue;
		q = p;
		while (*p != '\0' && *p != '#' && !(isascii(*p) && isspace(*p)))
			p++;
		*p = '\0';
		if (strcmp(shell, q) == 0 || strcmp(WILDCARD_SHELL, q) == 0)
		{
			(void) sm_io_close(shellf, SM_TIME_DEFAULT);
			return true;
		}
	}
	(void) sm_io_close(shellf, SM_TIME_DEFAULT);
	return false;
# endif /* HASGETUSERSHELL */
}
/*
**  FREEDISKSPACE -- see how much free space is on the queue filesystem
**
**	Only implemented if you have statfs.
**
**	Parameters:
**		dir -- the directory in question.
**		bsize -- a variable into which the filesystem
**			block size is stored.
**
**	Returns:
**		The number of blocks free on the queue filesystem.
**		-1 if the statfs call fails.
**
**	Side effects:
**		Puts the filesystem block size into bsize.
*/

/* statfs types */
# define SFS_NONE	0	/* no statfs implementation */
# define SFS_USTAT	1	/* use ustat */
# define SFS_4ARGS	2	/* use four-argument statfs call */
# define SFS_VFS	3	/* use <sys/vfs.h> implementation */
# define SFS_MOUNT	4	/* use <sys/mount.h> implementation */
# define SFS_STATFS	5	/* use <sys/statfs.h> implementation */
# define SFS_STATVFS	6	/* use <sys/statvfs.h> implementation */

# ifndef SFS_TYPE
#  define SFS_TYPE	SFS_NONE
# endif /* ! SFS_TYPE */

# if SFS_TYPE == SFS_USTAT
#  include <ustat.h>
# endif /* SFS_TYPE == SFS_USTAT */
# if SFS_TYPE == SFS_4ARGS || SFS_TYPE == SFS_STATFS
#  include <sys/statfs.h>
# endif /* SFS_TYPE == SFS_4ARGS || SFS_TYPE == SFS_STATFS */
# if SFS_TYPE == SFS_VFS
#  include <sys/vfs.h>
# endif /* SFS_TYPE == SFS_VFS */
# if SFS_TYPE == SFS_MOUNT
#  include <sys/mount.h>
# endif /* SFS_TYPE == SFS_MOUNT */
# if SFS_TYPE == SFS_STATVFS
#  include <sys/statvfs.h>
# endif /* SFS_TYPE == SFS_STATVFS */

long
freediskspace(dir, bsize)
	const char *dir;
	long *bsize;
{
# if SFS_TYPE == SFS_NONE
	if (bsize != NULL)
		*bsize = 4096L;

	/* assume free space is plentiful */
	return (long) LONG_MAX;
# else /* SFS_TYPE == SFS_NONE */
#  if SFS_TYPE == SFS_USTAT
	struct ustat fs;
	struct stat statbuf;
#   define FSBLOCKSIZE	DEV_BSIZE
#   define SFS_BAVAIL	f_tfree
#  else /* SFS_TYPE == SFS_USTAT */
#   if defined(ultrix)
	struct fs_data fs;
#    define SFS_BAVAIL	fd_bfreen
#    define FSBLOCKSIZE	1024L
#   else /* defined(ultrix) */
#    if SFS_TYPE == SFS_STATVFS
	struct statvfs fs;
#     define FSBLOCKSIZE	fs.f_frsize
#    else /* SFS_TYPE == SFS_STATVFS */
	struct statfs fs;
#     define FSBLOCKSIZE	fs.f_bsize
#    endif /* SFS_TYPE == SFS_STATVFS */
#   endif /* defined(ultrix) */
#  endif /* SFS_TYPE == SFS_USTAT */
#  ifndef SFS_BAVAIL
#   define SFS_BAVAIL f_bavail
#  endif /* ! SFS_BAVAIL */

#  if SFS_TYPE == SFS_USTAT
	if (stat(dir, &statbuf) == 0 && ustat(statbuf.st_dev, &fs) == 0)
#  else /* SFS_TYPE == SFS_USTAT */
#   if SFS_TYPE == SFS_4ARGS
	if (statfs(dir, &fs, sizeof(fs), 0) == 0)
#   else /* SFS_TYPE == SFS_4ARGS */
#    if SFS_TYPE == SFS_STATVFS
	if (statvfs(dir, &fs) == 0)
#    else /* SFS_TYPE == SFS_STATVFS */
#     if defined(ultrix)
	if (statfs(dir, &fs) > 0)
#     else /* defined(ultrix) */
	if (statfs(dir, &fs) == 0)
#     endif /* defined(ultrix) */
#    endif /* SFS_TYPE == SFS_STATVFS */
#   endif /* SFS_TYPE == SFS_4ARGS */
#  endif /* SFS_TYPE == SFS_USTAT */
	{
		if (bsize != NULL)
			*bsize = FSBLOCKSIZE;
		if (fs.SFS_BAVAIL <= 0)
			return 0;
		else if (fs.SFS_BAVAIL > LONG_MAX)
			return (long) LONG_MAX;
		else
			return (long) fs.SFS_BAVAIL;
	}
	return -1;
# endif /* SFS_TYPE == SFS_NONE */
}
/*
**  ENOUGHDISKSPACE -- is there enough free space on the queue file systems?
**
**	Parameters:
**		msize -- the size to check against.  If zero, we don't yet
**		know how big the message will be, so just check for
**		a "reasonable" amount.
**		e -- envelope, or NULL -- controls logging
**
**	Returns:
**		true if in every queue group there is at least one
**		queue directory whose file system contains enough free space.
**		false otherwise.
**
**	Side Effects:
**		If there is not enough disk space and e != NULL
**		then sm_syslog is called.
*/

bool
enoughdiskspace(msize, e)
	long msize;
	ENVELOPE *e;
{
	int i;

#if _FFR_TESTS
	if (tTd(4, 101))
		return false;
#endif /* _FFR_TESTS */
	if (MinBlocksFree <= 0 && msize <= 0)
	{
		if (tTd(4, 80))
			sm_dprintf("enoughdiskspace: no threshold\n");
		return true;
	}

	filesys_update();
	for (i = 0; i < NumQueue; ++i)
	{
		if (pickqdir(Queue[i], msize, e) < 0)
			return false;
	}
	return true;
}
/*
**  TRANSIENTERROR -- tell if an error code indicates a transient failure
**
**	This looks at an errno value and tells if this is likely to
**	go away if retried later.
**
**	Parameters:
**		err -- the errno code to classify.
**
**	Returns:
**		true if this is probably transient.
**		false otherwise.
*/

bool
transienterror(err)
	int err;
{
	switch (err)
	{
	  case EIO:			/* I/O error */
	  case ENXIO:			/* Device not configured */
	  case EAGAIN:			/* Resource temporarily unavailable */
	  case ENOMEM:			/* Cannot allocate memory */
	  case ENODEV:			/* Operation not supported by device */
	  case ENFILE:			/* Too many open files in system */
	  case EMFILE:			/* Too many open files */
	  case ENOSPC:			/* No space left on device */
	  case ETIMEDOUT:		/* Connection timed out */
#ifdef ESTALE
	  case ESTALE:			/* Stale NFS file handle */
#endif /* ESTALE */
#ifdef ENETDOWN
	  case ENETDOWN:		/* Network is down */
#endif /* ENETDOWN */
#ifdef ENETUNREACH
	  case ENETUNREACH:		/* Network is unreachable */
#endif /* ENETUNREACH */
#ifdef ENETRESET
	  case ENETRESET:		/* Network dropped connection on reset */
#endif /* ENETRESET */
#ifdef ECONNABORTED
	  case ECONNABORTED:		/* Software caused connection abort */
#endif /* ECONNABORTED */
#ifdef ECONNRESET
	  case ECONNRESET:		/* Connection reset by peer */
#endif /* ECONNRESET */
#ifdef ENOBUFS
	  case ENOBUFS:			/* No buffer space available */
#endif /* ENOBUFS */
#ifdef ESHUTDOWN
	  case ESHUTDOWN:		/* Can't send after socket shutdown */
#endif /* ESHUTDOWN */
#ifdef ECONNREFUSED
	  case ECONNREFUSED:		/* Connection refused */
#endif /* ECONNREFUSED */
#ifdef EHOSTDOWN
	  case EHOSTDOWN:		/* Host is down */
#endif /* EHOSTDOWN */
#ifdef EHOSTUNREACH
	  case EHOSTUNREACH:		/* No route to host */
#endif /* EHOSTUNREACH */
#ifdef EDQUOT
	  case EDQUOT:			/* Disc quota exceeded */
#endif /* EDQUOT */
#ifdef EPROCLIM
	  case EPROCLIM:		/* Too many processes */
#endif /* EPROCLIM */
#ifdef EUSERS
	  case EUSERS:			/* Too many users */
#endif /* EUSERS */
#ifdef EDEADLK
	  case EDEADLK:			/* Resource deadlock avoided */
#endif /* EDEADLK */
#ifdef EISCONN
	  case EISCONN:			/* Socket already connected */
#endif /* EISCONN */
#ifdef EINPROGRESS
	  case EINPROGRESS:		/* Operation now in progress */
#endif /* EINPROGRESS */
#ifdef EALREADY
	  case EALREADY:		/* Operation already in progress */
#endif /* EALREADY */
#ifdef EADDRINUSE
	  case EADDRINUSE:		/* Address already in use */
#endif /* EADDRINUSE */
#ifdef EADDRNOTAVAIL
	  case EADDRNOTAVAIL:		/* Can't assign requested address */
#endif /* EADDRNOTAVAIL */
#ifdef ETXTBSY
	  case ETXTBSY:			/* (Apollo) file locked */
#endif /* ETXTBSY */
#if defined(ENOSR) && (!defined(ENOBUFS) || (ENOBUFS != ENOSR))
	  case ENOSR:			/* Out of streams resources */
#endif /* defined(ENOSR) && (!defined(ENOBUFS) || (ENOBUFS != ENOSR)) */
#ifdef ENOLCK
	  case ENOLCK:			/* No locks available */
#endif /* ENOLCK */
	  case E_SM_OPENTIMEOUT:	/* PSEUDO: open timed out */
		return true;
	}

	/* nope, must be permanent */
	return false;
}
/*
**  LOCKFILE -- lock a file using flock or (shudder) fcntl locking
**
**	Parameters:
**		fd -- the file descriptor of the file.
**		filename -- the file name (for error messages).
**		ext -- the filename extension.
**		type -- type of the lock.  Bits can be:
**			LOCK_EX -- exclusive lock.
**			LOCK_NB -- non-blocking.
**			LOCK_UN -- unlock.
**
**	Returns:
**		true if the lock was acquired.
**		false otherwise.
*/

bool
lockfile(fd, filename, ext, type)
	int fd;
	char *filename;
	char *ext;
	int type;
{
	int i;
	int save_errno;
# if !HASFLOCK
	int action;
	struct flock lfd;

	if (ext == NULL)
		ext = "";

	memset(&lfd, '\0', sizeof(lfd));
	if (bitset(LOCK_UN, type))
		lfd.l_type = F_UNLCK;
	else if (bitset(LOCK_EX, type))
		lfd.l_type = F_WRLCK;
	else
		lfd.l_type = F_RDLCK;

	if (bitset(LOCK_NB, type))
		action = F_SETLK;
	else
		action = F_SETLKW;

	if (tTd(55, 60))
		sm_dprintf("lockfile(%s%s, action=%d, type=%d): ",
			filename, ext, action, lfd.l_type);

	while ((i = fcntl(fd, action, &lfd)) < 0 && errno == EINTR)
		continue;
	if (i >= 0)
	{
		if (tTd(55, 60))
			sm_dprintf("SUCCESS\n");
		return true;
	}
	save_errno = errno;

	if (tTd(55, 60))
		sm_dprintf("(%s) ", sm_errstring(save_errno));

	/*
	**  On SunOS, if you are testing using -oQ/tmp/mqueue or
	**  -oA/tmp/aliases or anything like that, and /tmp is mounted
	**  as type "tmp" (that is, served from swap space), the
	**  previous fcntl will fail with "Invalid argument" errors.
	**  Since this is fairly common during testing, we will assume
	**  that this indicates that the lock is successfully grabbed.
	*/

	if (save_errno == EINVAL)
	{
		if (tTd(55, 60))
			sm_dprintf("SUCCESS\n");
		return true;
	}

	if (!bitset(LOCK_NB, type) ||
	    (save_errno != EACCES && save_errno != EAGAIN))
	{
		int omode = fcntl(fd, F_GETFL, 0);
		uid_t euid = geteuid();

		errno = save_errno;
		syserr("cannot lockf(%s%s, fd=%d, type=%o, omode=%o, euid=%d)",
		       filename, ext, fd, type, omode, euid);
		dumpfd(fd, true, true);
	}
# else /* !HASFLOCK */
	if (ext == NULL)
		ext = "";

	if (tTd(55, 60))
		sm_dprintf("lockfile(%s%s, type=%o): ", filename, ext, type);

	while ((i = flock(fd, type)) < 0 && errno == EINTR)
		continue;
	if (i >= 0)
	{
		if (tTd(55, 60))
			sm_dprintf("SUCCESS\n");
		return true;
	}
	save_errno = errno;

	if (tTd(55, 60))
		sm_dprintf("(%s) ", sm_errstring(save_errno));

	if (!bitset(LOCK_NB, type) || save_errno != EWOULDBLOCK)
	{
		int omode = fcntl(fd, F_GETFL, 0);
		uid_t euid = geteuid();

		errno = save_errno;
		syserr("cannot flock(%s%s, fd=%d, type=%o, omode=%o, euid=%d)",
			filename, ext, fd, type, omode, euid);
		dumpfd(fd, true, true);
	}
# endif /* !HASFLOCK */
	if (tTd(55, 60))
		sm_dprintf("FAIL\n");
	errno = save_errno;
	return false;
}
/*
**  CHOWNSAFE -- tell if chown is "safe" (executable only by root)
**
**	Unfortunately, given that we can't predict other systems on which
**	a remote mounted (NFS) filesystem will be mounted, the answer is
**	almost always that this is unsafe.
**
**	Note also that many operating systems have non-compliant
**	implementations of the _POSIX_CHOWN_RESTRICTED variable and the
**	fpathconf() routine.  According to IEEE 1003.1-1990, if
**	_POSIX_CHOWN_RESTRICTED is defined and not equal to -1, then
**	no non-root process can give away the file.  However, vendors
**	don't take NFS into account, so a comfortable value of
**	_POSIX_CHOWN_RESTRICTED tells us nothing.
**
**	Also, some systems (e.g., IRIX 6.2) return 1 from fpathconf()
**	even on files where chown is not restricted.  Many systems get
**	this wrong on NFS-based filesystems (that is, they say that chown
**	is restricted [safe] on NFS filesystems where it may not be, since
**	other systems can access the same filesystem and do file giveaway;
**	only the NFS server knows for sure!)  Hence, it is important to
**	get the value of SAFENFSPATHCONF correct -- it should be defined
**	_only_ after testing (see test/t_pathconf.c) a system on an unsafe
**	NFS-based filesystem to ensure that you can get meaningful results.
**	If in doubt, assume unsafe!
**
**	You may also need to tweak IS_SAFE_CHOWN -- it should be a
**	condition indicating whether the return from pathconf indicates
**	that chown is safe (typically either > 0 or >= 0 -- there isn't
**	even any agreement about whether a zero return means that a file
**	is or is not safe).  It defaults to "> 0".
**
**	If the parent directory is safe (writable only by owner back
**	to the root) then we can relax slightly and trust fpathconf
**	in more circumstances.  This is really a crock -- if this is an
**	NFS mounted filesystem then we really know nothing about the
**	underlying implementation.  However, most systems pessimize and
**	return an error (EINVAL or EOPNOTSUPP) on NFS filesystems, which
**	we interpret as unsafe, as we should.  Thus, this heuristic gets
**	us into a possible problem only on systems that have a broken
**	pathconf implementation and which are also poorly configured
**	(have :include: files in group- or world-writable directories).
**
**	Parameters:
**		fd -- the file descriptor to check.
**		safedir -- set if the parent directory is safe.
**
**	Returns:
**		true -- if the chown(2) operation is "safe" -- that is,
**			only root can chown the file to an arbitrary user.
**		false -- if an arbitrary user can give away a file.
*/

#ifndef IS_SAFE_CHOWN
# define IS_SAFE_CHOWN	> 0
#endif /* ! IS_SAFE_CHOWN */

bool
chownsafe(fd, safedir)
	int fd;
	bool safedir;
{
# if (!defined(_POSIX_CHOWN_RESTRICTED) || _POSIX_CHOWN_RESTRICTED != -1) && \
    (defined(_PC_CHOWN_RESTRICTED) || defined(_GNU_TYPES_H))
	int rval;

	/* give the system administrator a chance to override */
	if (bitnset(DBS_ASSUMESAFECHOWN, DontBlameSendmail))
		return true;

	/*
	**  Some systems (e.g., SunOS) seem to have the call and the
	**  #define _PC_CHOWN_RESTRICTED, but don't actually implement
	**  the call.  This heuristic checks for that.
	*/

	errno = 0;
	rval = fpathconf(fd, _PC_CHOWN_RESTRICTED);
#  if SAFENFSPATHCONF
	return errno == 0 && rval IS_SAFE_CHOWN;
#  else /* SAFENFSPATHCONF */
	return safedir && errno == 0 && rval IS_SAFE_CHOWN;
#  endif /* SAFENFSPATHCONF */
# else /* (!defined(_POSIX_CHOWN_RESTRICTED) || _POSIX_CHOWN_RESTRICTED != -1) && ... */
	return bitnset(DBS_ASSUMESAFECHOWN, DontBlameSendmail);
# endif /* (!defined(_POSIX_CHOWN_RESTRICTED) || _POSIX_CHOWN_RESTRICTED != -1) && ... */
}
/*
**  RESETLIMITS -- reset system controlled resource limits
**
**	This is to avoid denial-of-service attacks
**
**	Parameters:
**		none
**
**	Returns:
**		none
*/

#if HASSETRLIMIT
# ifdef RLIMIT_NEEDS_SYS_TIME_H
#  include <sm/time.h>
# endif /* RLIMIT_NEEDS_SYS_TIME_H */
# include <sys/resource.h>
#endif /* HASSETRLIMIT */

void
resetlimits()
{
#if HASSETRLIMIT
	struct rlimit lim;

	lim.rlim_cur = lim.rlim_max = RLIM_INFINITY;
	(void) setrlimit(RLIMIT_CPU, &lim);
	(void) setrlimit(RLIMIT_FSIZE, &lim);
# ifdef RLIMIT_NOFILE
	lim.rlim_cur = lim.rlim_max = FD_SETSIZE;
	(void) setrlimit(RLIMIT_NOFILE, &lim);
# endif /* RLIMIT_NOFILE */
#else /* HASSETRLIMIT */
# if HASULIMIT
	(void) ulimit(2, 0x3fffff);
	(void) ulimit(4, FD_SETSIZE);
# endif /* HASULIMIT */
#endif /* HASSETRLIMIT */
	errno = 0;
}
/*
**  SETVENDOR -- process vendor code from V configuration line
**
**	Parameters:
**		vendor -- string representation of vendor.
**
**	Returns:
**		true -- if ok.
**		false -- if vendor code could not be processed.
**
**	Side Effects:
**		It is reasonable to set mode flags here to tweak
**		processing in other parts of the code if necessary.
**		For example, if you are a vendor that uses $%y to
**		indicate YP lookups, you could enable that here.
*/

bool
setvendor(vendor)
	char *vendor;
{
	if (sm_strcasecmp(vendor, "Berkeley") == 0)
	{
		VendorCode = VENDOR_BERKELEY;
		return true;
	}

	/* add vendor extensions here */

#ifdef SUN_EXTENSIONS
	if (sm_strcasecmp(vendor, "Sun") == 0)
	{
		VendorCode = VENDOR_SUN;
		return true;
	}
#endif /* SUN_EXTENSIONS */
#ifdef DEC
	if (sm_strcasecmp(vendor, "Digital") == 0)
	{
		VendorCode = VENDOR_DEC;
		return true;
	}
#endif /* DEC */

#if defined(VENDOR_NAME) && defined(VENDOR_CODE)
	if (sm_strcasecmp(vendor, VENDOR_NAME) == 0)
	{
		VendorCode = VENDOR_CODE;
		return true;
	}
#endif /* defined(VENDOR_NAME) && defined(VENDOR_CODE) */

	return false;
}
/*
**  GETVENDOR -- return vendor name based on vendor code
**
**	Parameters:
**		vendorcode -- numeric representation of vendor.
**
**	Returns:
**		string containing vendor name.
*/

char *
getvendor(vendorcode)
	int vendorcode;
{
#if defined(VENDOR_NAME) && defined(VENDOR_CODE)
	/*
	**  Can't have the same switch case twice so need to
	**  handle VENDOR_CODE outside of switch.  It might
	**  match one of the existing VENDOR_* codes.
	*/

	if (vendorcode == VENDOR_CODE)
		return VENDOR_NAME;
#endif /* defined(VENDOR_NAME) && defined(VENDOR_CODE) */

	switch (vendorcode)
	{
	  case VENDOR_BERKELEY:
		return "Berkeley";

	  case VENDOR_SUN:
		return "Sun";

	  case VENDOR_HP:
		return "HP";

	  case VENDOR_IBM:
		return "IBM";

	  case VENDOR_SENDMAIL:
		return "Sendmail";

	  default:
		return "Unknown";
	}
}
/*
**  VENDOR_PRE_DEFAULTS, VENDOR_POST_DEFAULTS -- set vendor-specific defaults
**
**	Vendor_pre_defaults is called before reading the configuration
**	file; vendor_post_defaults is called immediately after.
**
**	Parameters:
**		e -- the global environment to initialize.
**
**	Returns:
**		none.
*/

#if SHARE_V1
int	DefShareUid;	/* default share uid to run as -- unused??? */
#endif /* SHARE_V1 */

void
vendor_pre_defaults(e)
	ENVELOPE *e;
{
#if SHARE_V1
	/* OTHERUID is defined in shares.h, do not be alarmed */
	DefShareUid = OTHERUID;
#endif /* SHARE_V1 */
#if defined(SUN_EXTENSIONS) && defined(SUN_DEFAULT_VALUES)
	sun_pre_defaults(e);
#endif /* defined(SUN_EXTENSIONS) && defined(SUN_DEFAULT_VALUES) */
#ifdef apollo
	/*
	**  stupid domain/os can't even open
	**  /etc/mail/sendmail.cf without this
	*/

	sm_setuserenv("ISP", NULL);
	sm_setuserenv("SYSTYPE", NULL);
#endif /* apollo */
}


void
vendor_post_defaults(e)
	ENVELOPE *e;
{
#ifdef __QNX__
	/* Makes sure the SOCK environment variable remains */
	sm_setuserenv("SOCK", NULL);
#endif /* __QNX__ */
#if defined(SUN_EXTENSIONS) && defined(SUN_DEFAULT_VALUES)
	sun_post_defaults(e);
#endif /* defined(SUN_EXTENSIONS) && defined(SUN_DEFAULT_VALUES) */
}
/*
**  VENDOR_DAEMON_SETUP -- special vendor setup needed for daemon mode
*/

void
vendor_daemon_setup(e)
	ENVELOPE *e;
{
#if HASSETLOGIN
	(void) setlogin(RunAsUserName);
#endif /* HASSETLOGIN */
#if SECUREWARE
	if (getluid() != -1)
	{
		usrerr("Daemon cannot have LUID");
		finis(false, true, EX_USAGE);
	}
#endif /* SECUREWARE */
}
/*
**  VENDOR_SET_UID -- do setup for setting a user id
**
**	This is called when we are still root.
**
**	Parameters:
**		uid -- the uid we are about to become.
**
**	Returns:
**		none.
*/

void
vendor_set_uid(uid)
	UID_T uid;
{
	/*
	**  We need to setup the share groups (lnodes)
	**  and add auditing information (luid's)
	**  before we loose our ``root''ness.
	*/
#if SHARE_V1
	if (setupshares(uid, syserr) != 0)
		syserr("Unable to set up shares");
#endif /* SHARE_V1 */
#if SECUREWARE
	(void) setup_secure(uid);
#endif /* SECUREWARE */
}
/*
**  VALIDATE_CONNECTION -- check connection for rationality
**
**	If the connection is rejected, this routine should log an
**	appropriate message -- but should never issue any SMTP protocol.
**
**	Parameters:
**		sap -- a pointer to a SOCKADDR naming the peer.
**		hostname -- the name corresponding to sap.
**		e -- the current envelope.
**
**	Returns:
**		error message from rejection.
**		NULL if not rejected.
*/

#if TCPWRAPPERS
# include <tcpd.h>

/* tcpwrappers does no logging, but you still have to declare these -- ugh */
int	allow_severity	= LOG_INFO;
int	deny_severity	= LOG_NOTICE;
#endif /* TCPWRAPPERS */

char *
validate_connection(sap, hostname, e)
	SOCKADDR *sap;
	char *hostname;
	ENVELOPE *e;
{
#if TCPWRAPPERS
	char *host;
	char *addr;
	extern int hosts_ctl();
#endif /* TCPWRAPPERS */

	if (tTd(48, 3))
		sm_dprintf("validate_connection(%s, %s)\n",
			hostname, anynet_ntoa(sap));

	connection_rate_check(sap, e);
	if (rscheck("check_relay", hostname, anynet_ntoa(sap),
		    e, RSF_RMCOMM|RSF_COUNT, 3, NULL, NOQID, NULL) != EX_OK)
	{
		static char reject[BUFSIZ*2];
		extern char MsgBuf[];

		if (tTd(48, 4))
			sm_dprintf("  ... validate_connection: BAD (rscheck)\n");

		if (strlen(MsgBuf) >= 3)
			(void) sm_strlcpy(reject, MsgBuf, sizeof(reject));
		else
			(void) sm_strlcpy(reject, "Access denied", sizeof(reject));

		return reject;
	}

#if TCPWRAPPERS
	if (hostname[0] == '[' && hostname[strlen(hostname) - 1] == ']')
		host = "unknown";
	else
		host = hostname;
	addr = anynet_ntoa(sap);

# if NETINET6
	/* TCP/Wrappers don't want the IPv6: protocol label */
	if (addr != NULL && sm_strncasecmp(addr, "IPv6:", 5) == 0)
		addr += 5;
# endif /* NETINET6 */

	if (!hosts_ctl("sendmail", host, addr, STRING_UNKNOWN))
	{
		if (tTd(48, 4))
			sm_dprintf("  ... validate_connection: BAD (tcpwrappers)\n");
		if (LogLevel > 3)
			sm_syslog(LOG_NOTICE, e->e_id,
				  "tcpwrappers (%s, %s) rejection",
				  host, addr);
		return "Access denied";
	}
#endif /* TCPWRAPPERS */
	if (tTd(48, 4))
		sm_dprintf("  ... validate_connection: OK\n");
	return NULL;
}

/*
**  STRTOL -- convert string to long integer
**
**	For systems that don't have it in the C library.
**
**	This is taken verbatim from the 4.4-Lite C library.
*/

#if NEEDSTRTOL

# if defined(LIBC_SCCS) && !defined(lint)
static char sccsid[] = "@@(#)strtol.c	8.1 (Berkeley) 6/4/93";
# endif /* defined(LIBC_SCCS) && !defined(lint) */

/*
**  Convert a string to a long integer.
**
**  Ignores `locale' stuff.  Assumes that the upper and lower case
**  alphabets and digits are each contiguous.
*/

long
strtol(nptr, endptr, base)
	const char *nptr;
	char **endptr;
	register int base;
{
	register const char *s = nptr;
	register unsigned long acc;
	register int c;
	register unsigned long cutoff;
	register int neg = 0, any, cutlim;

	/*
	**  Skip white space and pick up leading +/- sign if any.
	**  If base is 0, allow 0x for hex and 0 for octal, else
	**  assume decimal; if base is already 16, allow 0x.
	*/
	do {
		c = *s++;
	} while (isascii(c) && isspace(c));
	if (c == '-') {
		neg = 1;
		c = *s++;
	} else if (c == '+')
		c = *s++;
	if ((base == 0 || base == 16) &&
	    c == '0' && (*s == 'x' || *s == 'X')) {
		c = s[1];
		s += 2;
		base = 16;
	}
	if (base == 0)
		base = c == '0' ? 8 : 10;

	/*
	**  Compute the cutoff value between legal numbers and illegal
	**  numbers.  That is the largest legal value, divided by the
	**  base.  An input number that is greater than this value, if
	**  followed by a legal input character, is too big.  One that
	**  is equal to this value may be valid or not; the limit
	**  between valid and invalid numbers is then based on the last
	**  digit.  For instance, if the range for longs is
	**  [-2147483648..2147483647] and the input base is 10,
	**  cutoff will be set to 214748364 and cutlim to either
	**  7 (neg==0) or 8 (neg==1), meaning that if we have accumulated
	**  a value > 214748364, or equal but the next digit is > 7 (or 8),
	**  the number is too big, and we will return a range error.
	**
	**  Set any if any `digits' consumed; make it negative to indicate
	**  overflow.
	*/
	cutoff = neg ? -(unsigned long) LONG_MIN : LONG_MAX;
	cutlim = cutoff % (unsigned long) base;
	cutoff /= (unsigned long) base;
	for (acc = 0, any = 0;; c = *s++) {
		if (isascii(c) && isdigit(c))
			c -= '0';
		else if (isascii(c) && isalpha(c))
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
		else
			break;
		if (c >= base)
			break;
		if (any < 0 || acc > cutoff || acc == cutoff && c > cutlim)
			any = -1;
		else {
			any = 1;
			acc *= base;
			acc += c;
		}
	}
	if (any < 0) {
		acc = neg ? LONG_MIN : LONG_MAX;
		errno = ERANGE;
	} else if (neg)
		acc = -acc;
	if (endptr != 0)
		*endptr = (char *)(any ? s - 1 : nptr);
	return acc;
}

#endif /* NEEDSTRTOL */
/*
**  STRSTR -- find first substring in string
**
**	Parameters:
**		big -- the big (full) string.
**		little -- the little (sub) string.
**
**	Returns:
**		A pointer to the first instance of little in big.
**		big if little is the null string.
**		NULL if little is not contained in big.
*/

#if NEEDSTRSTR

char *
strstr(big, little)
	char *big;
	char *little;
{
	register char *p = big;
	int l;

	if (*little == '\0')
		return big;
	l = strlen(little);

	while ((p = strchr(p, *little)) != NULL)
	{
		if (strncmp(p, little, l) == 0)
			return p;
		p++;
	}
	return NULL;
}

#endif /* NEEDSTRSTR */
/*
**  SM_GETHOSTBY{NAME,ADDR} -- compatibility routines for gethostbyXXX
**
**	Some operating systems have weird problems with the gethostbyXXX
**	routines.  For example, Solaris versions at least through 2.3
**	don't properly deliver a canonical h_name field.  This tries to
**	work around these problems.
**
**	Support IPv6 as well as IPv4.
*/

#if NETINET6 && NEEDSGETIPNODE

# ifndef AI_DEFAULT
#  define AI_DEFAULT	0	/* dummy */
# endif /* ! AI_DEFAULT */
# ifndef AI_ADDRCONFIG
#  define AI_ADDRCONFIG	0	/* dummy */
# endif /* ! AI_ADDRCONFIG */
# ifndef AI_V4MAPPED
#  define AI_V4MAPPED	0	/* dummy */
# endif /* ! AI_V4MAPPED */
# ifndef AI_ALL
#  define AI_ALL	0	/* dummy */
# endif /* ! AI_ALL */

static struct hostent *
sm_getipnodebyname(name, family, flags, err)
	const char *name;
	int family;
	int flags;
	int *err;
{
	struct hostent *h;
# if HAS_GETHOSTBYNAME2

	h = gethostbyname2(name, family);
	if (h == NULL)
		*err = h_errno;
	return h;

# else /* HAS_GETHOSTBYNAME2 */
	bool resv6 = true;

	if (family == AF_INET6)
	{
		/* From RFC2133, section 6.1 */
		resv6 = bitset(RES_USE_INET6, _res.options);
		_res.options |= RES_USE_INET6;
	}
	SM_SET_H_ERRNO(0);
	h = gethostbyname(name);
	if (!resv6)
		_res.options &= ~RES_USE_INET6;

	/* the function is supposed to return only the requested family */
	if (h != NULL && h->h_addrtype != family)
	{
#  if NETINET6
		freehostent(h);
#  endif /* NETINET6 */
		h = NULL;
		*err = NO_DATA;
	}
	else
		*err = h_errno;
	return h;
# endif /* HAS_GETHOSTBYNAME2 */
}

static struct hostent *
sm_getipnodebyaddr(addr, len, family, err)
	const void *addr;
	size_t len;
	int family;
	int *err;
{
	struct hostent *h;

	SM_SET_H_ERRNO(0);
	h = gethostbyaddr(addr, len, family);
	*err = h_errno;
	return h;
}

void
freehostent(h)
	struct hostent *h;
{
	/*
	**  Stub routine -- if they don't have getipnodeby*(),
	**  they probably don't have the free routine either.
	*/

	return;
}
#endif /* NETINET6 && NEEDSGETIPNODE */

struct hostent *
sm_gethostbyname(name, family)
	char *name;
	int family;
{
	int save_errno;
	struct hostent *h = NULL;
#if (SOLARIS > 10000 && SOLARIS < 20400) || (defined(SOLARIS) && SOLARIS < 204) || (defined(sony_news) && defined(__svr4))
# if SOLARIS == 20300 || SOLARIS == 203
	static struct hostent hp;
	static char buf[1000];
	extern struct hostent *_switch_gethostbyname_r();

	if (tTd(61, 10))
		sm_dprintf("_switch_gethostbyname_r(%s)... ", name);
	h = _switch_gethostbyname_r(name, &hp, buf, sizeof(buf), &h_errno);
	save_errno = errno;
# else /* SOLARIS == 20300 || SOLARIS == 203 */
	extern struct hostent *__switch_gethostbyname();

	if (tTd(61, 10))
		sm_dprintf("__switch_gethostbyname(%s)... ", name);
	h = __switch_gethostbyname(name);
	save_errno = errno;
# endif /* SOLARIS == 20300 || SOLARIS == 203 */
#else /* (SOLARIS > 10000 && SOLARIS < 20400) || (defined(SOLARIS) && SOLARIS < 204) || (defined(sony_news) && defined(__svr4)) */
	int nmaps;
# if NETINET6
#  ifndef SM_IPNODEBYNAME_FLAGS
    /* For IPv4-mapped addresses, use: AI_DEFAULT|AI_ALL */
#   define SM_IPNODEBYNAME_FLAGS	AI_ADDRCONFIG
#  endif /* SM_IPNODEBYNAME_FLAGS */

	int flags = SM_IPNODEBYNAME_FLAGS;
	int err;
# endif /* NETINET6 */
	char *maptype[MAXMAPSTACK];
	short mapreturn[MAXMAPACTIONS];
	char hbuf[MAXNAME];

	if (tTd(61, 10))
		sm_dprintf("sm_gethostbyname(%s, %d)... ", name, family);

# if NETINET6
#  if ADDRCONFIG_IS_BROKEN
	flags &= ~AI_ADDRCONFIG;
#  endif /* ADDRCONFIG_IS_BROKEN */
	h = sm_getipnodebyname(name, family, flags, &err);
	SM_SET_H_ERRNO(err);
# else /* NETINET6 */
	h = gethostbyname(name);
# endif /* NETINET6 */

	save_errno = errno;
	if (h == NULL)
	{
		if (tTd(61, 10))
			sm_dprintf("failure\n");

		nmaps = switch_map_find("hosts", maptype, mapreturn);
		while (--nmaps >= 0)
		{
			if (strcmp(maptype[nmaps], "nis") == 0 ||
			    strcmp(maptype[nmaps], "files") == 0)
				break;
		}

		if (nmaps >= 0)
		{
			/* try short name */
			if (strlen(name) > sizeof(hbuf) - 1)
			{
				errno = save_errno;
				return NULL;
			}
			(void) sm_strlcpy(hbuf, name, sizeof(hbuf));
			(void) shorten_hostname(hbuf);

			/* if it hasn't been shortened, there's no point */
			if (strcmp(hbuf, name) != 0)
			{
				if (tTd(61, 10))
					sm_dprintf("sm_gethostbyname(%s, %d)... ",
					       hbuf, family);

# if NETINET6
				h = sm_getipnodebyname(hbuf, family, flags, &err);
				SM_SET_H_ERRNO(err);
				save_errno = errno;
# else /* NETINET6 */
				h = gethostbyname(hbuf);
				save_errno = errno;
# endif /* NETINET6 */
			}
		}
	}
#endif /* (SOLARIS > 10000 && SOLARIS < 20400) || (defined(SOLARIS) && SOLARIS < 204) || (defined(sony_news) && defined(__svr4)) */

	/* the function is supposed to return only the requested family */
	if (h != NULL && h->h_addrtype != family)
	{
# if NETINET6
		freehostent(h);
# endif /* NETINET6 */
		h = NULL;
		SM_SET_H_ERRNO(NO_DATA);
	}

	if (tTd(61, 10))
	{
		if (h == NULL)
			sm_dprintf("failure\n");
		else
		{
			sm_dprintf("%s\n", h->h_name);
			if (tTd(61, 11))
			{
				struct in_addr ia;
				size_t i;
#if NETINET6
				struct in6_addr ia6;
				char buf6[INET6_ADDRSTRLEN];
#endif /* NETINET6 */

				if (h->h_aliases != NULL)
					for (i = 0; h->h_aliases[i] != NULL;
					     i++)
						sm_dprintf("\talias: %s\n",
							h->h_aliases[i]);
				for (i = 0; h->h_addr_list[i] != NULL; i++)
				{
					char *addr;

					addr = NULL;
#if NETINET6
					if (h->h_addrtype == AF_INET6)
					{
						memmove(&ia6, h->h_addr_list[i],
							IN6ADDRSZ);
						addr = anynet_ntop(&ia6,
							buf6, sizeof(buf6));
					}
					else
#endif /* NETINET6 */
					/* "else" in #if code above */
					{
						memmove(&ia, h->h_addr_list[i],
							INADDRSZ);
						addr = (char *) inet_ntoa(ia);
					}
					if (addr != NULL)
						sm_dprintf("\taddr: %s\n", addr);
				}
			}
		}
	}
	errno = save_errno;
	return h;
}

struct hostent *
sm_gethostbyaddr(addr, len, type)
	char *addr;
	int len;
	int type;
{
	struct hostent *hp;

#if NETINET6
	if (type == AF_INET6 &&
	    IN6_IS_ADDR_UNSPECIFIED((struct in6_addr *) addr))
	{
		/* Avoid reverse lookup for IPv6 unspecified address */
		SM_SET_H_ERRNO(HOST_NOT_FOUND);
		return NULL;
	}
#endif /* NETINET6 */

#if (SOLARIS > 10000 && SOLARIS < 20400) || (defined(SOLARIS) && SOLARIS < 204)
# if SOLARIS == 20300 || SOLARIS == 203
	{
		static struct hostent he;
		static char buf[1000];
		extern struct hostent *_switch_gethostbyaddr_r();

		hp = _switch_gethostbyaddr_r(addr, len, type, &he,
					     buf, sizeof(buf), &h_errno);
	}
# else /* SOLARIS == 20300 || SOLARIS == 203 */
	{
		extern struct hostent *__switch_gethostbyaddr();

		hp = __switch_gethostbyaddr(addr, len, type);
	}
# endif /* SOLARIS == 20300 || SOLARIS == 203 */
#else /* (SOLARIS > 10000 && SOLARIS < 20400) || (defined(SOLARIS) && SOLARIS < 204) */
# if NETINET6
	{
		int err;

		hp = sm_getipnodebyaddr(addr, len, type, &err);
		SM_SET_H_ERRNO(err);
	}
# else /* NETINET6 */
	hp = gethostbyaddr(addr, len, type);
# endif /* NETINET6 */
#endif /* (SOLARIS > 10000 && SOLARIS < 20400) || (defined(SOLARIS) && SOLARIS < 204) */
	return hp;
}
/*
**  SM_GETPW{NAM,UID} -- wrapper for getpwnam and getpwuid
*/

struct passwd *
sm_getpwnam(user)
	char *user;
{
#ifdef _AIX4
	extern struct passwd *_getpwnam_shadow(const char *, const int);

	return _getpwnam_shadow(user, 0);
#else /* _AIX4 */
	return getpwnam(user);
#endif /* _AIX4 */
}

struct passwd *
sm_getpwuid(uid)
	UID_T uid;
{
#if defined(_AIX4) && 0
	extern struct passwd *_getpwuid_shadow(const int, const int);

	return _getpwuid_shadow(uid,0);
#else /* defined(_AIX4) && 0 */
	return getpwuid(uid);
#endif /* defined(_AIX4) && 0 */
}
/*
**  SECUREWARE_SETUP_SECURE -- Convex SecureWare setup
**
**	Set up the trusted computing environment for C2 level security
**	under SecureWare.
**
**	Parameters:
**		uid -- uid of the user to initialize in the TCB
**
**	Returns:
**		none
**
**	Side Effects:
**		Initialized the user in the trusted computing base
*/

#if SECUREWARE

# include <sys/security.h>
# include <prot.h>

void
secureware_setup_secure(uid)
	UID_T uid;
{
	int rc;

	if (getluid() != -1)
		return;

	if ((rc = set_secure_info(uid)) != SSI_GOOD_RETURN)
	{
		switch (rc)
		{
		  case SSI_NO_PRPW_ENTRY:
			syserr("No protected passwd entry, uid = %d",
			       (int) uid);
			break;

		  case SSI_LOCKED:
			syserr("Account has been disabled, uid = %d",
			       (int) uid);
			break;

		  case SSI_RETIRED:
			syserr("Account has been retired, uid = %d",
			       (int) uid);
			break;

		  case SSI_BAD_SET_LUID:
			syserr("Could not set LUID, uid = %d", (int) uid);
			break;

		  case SSI_BAD_SET_PRIVS:
			syserr("Could not set kernel privs, uid = %d",
			       (int) uid);

		  default:
			syserr("Unknown return code (%d) from set_secure_info(%d)",
				rc, (int) uid);
			break;
		}
		finis(false, true, EX_NOPERM);
	}
}
#endif /* SECUREWARE */
/*
**  ADD_HOSTNAMES -- Add a hostname to class 'w' based on IP address
**
**	Add hostnames to class 'w' based on the IP address read from
**	the network interface.
**
**	Parameters:
**		sa -- a pointer to a SOCKADDR containing the address
**
**	Returns:
**		0 if successful, -1 if host lookup fails.
*/

static int
add_hostnames(sa)
	SOCKADDR *sa;
{
	struct hostent *hp;
	char **ha;
	char hnb[MAXHOSTNAMELEN];

	/* lookup name with IP address */
	switch (sa->sa.sa_family)
	{
#if NETINET
	  case AF_INET:
		hp = sm_gethostbyaddr((char *) &sa->sin.sin_addr,
				      sizeof(sa->sin.sin_addr),
				      sa->sa.sa_family);
		break;
#endif /* NETINET */

#if NETINET6
	  case AF_INET6:
		hp = sm_gethostbyaddr((char *) &sa->sin6.sin6_addr,
				      sizeof(sa->sin6.sin6_addr),
				      sa->sa.sa_family);
		break;
#endif /* NETINET6 */

	  default:
		/* Give warning about unsupported family */
		if (LogLevel > 3)
			sm_syslog(LOG_WARNING, NOQID,
				  "Unsupported address family %d: %.100s",
				  sa->sa.sa_family, anynet_ntoa(sa));
		return -1;
	}

	if (hp == NULL)
	{
		int save_errno = errno;

		if (LogLevel > 3 &&
#if NETINET && defined(IN_LINKLOCAL)
		    !(sa->sa.sa_family == AF_INET &&
		      IN_LINKLOCAL(ntohl(sa->sin.sin_addr.s_addr))) &&
#endif /* NETINET && defined(IN_LINKLOCAL) */
#if NETINET6
		    !(sa->sa.sa_family == AF_INET6 &&
		      IN6_IS_ADDR_LINKLOCAL(&sa->sin6.sin6_addr)) &&
#endif /* NETINET6 */
		    true)
			sm_syslog(LOG_WARNING, NOQID,
				  "gethostbyaddr(%.100s) failed: %d",
				  anynet_ntoa(sa),
#if NAMED_BIND
				  h_errno
#else /* NAMED_BIND */
				  -1
#endif /* NAMED_BIND */
				 );
		errno = save_errno;
		return -1;
	}

	/* save its cname */
	if (!wordinclass((char *) hp->h_name, 'w'))
	{
		setclass('w', (char *) hp->h_name);
		if (tTd(0, 4))
			sm_dprintf("\ta.k.a.: %s\n", hp->h_name);

		if (sm_snprintf(hnb, sizeof(hnb), "[%s]", hp->h_name) <
								sizeof(hnb)
		    && !wordinclass((char *) hnb, 'w'))
			setclass('w', hnb);
	}
	else
	{
		if (tTd(0, 43))
			sm_dprintf("\ta.k.a.: %s (already in $=w)\n", hp->h_name);
	}

	/* save all it aliases name */
	for (ha = hp->h_aliases; ha != NULL && *ha != NULL; ha++)
	{
		if (!wordinclass(*ha, 'w'))
		{
			setclass('w', *ha);
			if (tTd(0, 4))
				sm_dprintf("\ta.k.a.: %s\n", *ha);
			if (sm_snprintf(hnb, sizeof(hnb),
				     "[%s]", *ha) < sizeof(hnb) &&
			    !wordinclass((char *) hnb, 'w'))
				setclass('w', hnb);
		}
		else
		{
			if (tTd(0, 43))
				sm_dprintf("\ta.k.a.: %s (already in $=w)\n",
					*ha);
		}
	}
#if NETINET6
	freehostent(hp);
#endif /* NETINET6 */
	return 0;
}
/*
**  LOAD_IF_NAMES -- load interface-specific names into $=w
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Loads $=w with the names of all the interfaces.
*/

#if !NETINET
# define SIOCGIFCONF_IS_BROKEN	1 /* XXX */
#endif /* !NETINET */

#if defined(SIOCGIFCONF) && !SIOCGIFCONF_IS_BROKEN
struct rtentry;
struct mbuf;
# ifndef SUNOS403
#  include <sm/time.h>
# endif /* ! SUNOS403 */
# if (_AIX4 >= 40300) && !defined(_NET_IF_H)
#  undef __P
# endif /* (_AIX4 >= 40300) && !defined(_NET_IF_H) */
# include <net/if.h>
#endif /* defined(SIOCGIFCONF) && !SIOCGIFCONF_IS_BROKEN */

void
load_if_names()
{
# if NETINET6 && defined(SIOCGLIFCONF)
#  ifdef __hpux

    /*
    **  Unfortunately, HP has changed all of the structures,
    **  making life difficult for implementors.
    */

#   define lifconf	if_laddrconf
#   define lifc_len	iflc_len
#   define lifc_buf	iflc_buf
#   define lifreq	if_laddrreq
#   define lifr_addr	iflr_addr
#   define lifr_name	iflr_name
#   define lifr_flags	iflr_flags
#   define ss_family	sa_family
#   undef SIOCGLIFNUM
#  endif /* __hpux */

	int s;
	int i;
	size_t len;
	int numifs;
	char *buf;
	struct lifconf lifc;
#  ifdef SIOCGLIFNUM
	struct lifnum lifn;
#  endif /* SIOCGLIFNUM */

	s = socket(InetMode, SOCK_DGRAM, 0);
	if (s == -1)
		return;

	/* get the list of known IP address from the kernel */
#  ifdef __hpux
	i = ioctl(s, SIOCGIFNUM, (char *) &numifs);
#  endif /* __hpux */
#  ifdef SIOCGLIFNUM
	lifn.lifn_family = AF_UNSPEC;
	lifn.lifn_flags = 0;
	i = ioctl(s, SIOCGLIFNUM, (char *)&lifn);
	numifs = lifn.lifn_count;
#  endif /* SIOCGLIFNUM */

#  if defined(__hpux) || defined(SIOCGLIFNUM)
	if (i < 0)
	{
		/* can't get number of interfaces -- fall back */
		if (tTd(0, 4))
			sm_dprintf("SIOCGLIFNUM failed: %s\n",
				   sm_errstring(errno));
		numifs = -1;
	}
	else if (tTd(0, 42))
		sm_dprintf("system has %d interfaces\n", numifs);
	if (numifs < 0)
#  endif /* defined(__hpux) || defined(SIOCGLIFNUM) */
		numifs = MAXINTERFACES;

	if (numifs <= 0)
	{
		(void) close(s);
		return;
	}

	len = lifc.lifc_len = numifs * sizeof(struct lifreq);
	buf = lifc.lifc_buf = xalloc(lifc.lifc_len);
#  ifndef __hpux
	lifc.lifc_family = AF_UNSPEC;
	lifc.lifc_flags = 0;
#  endif /* ! __hpux */
	if (ioctl(s, SIOCGLIFCONF, (char *)&lifc) < 0)
	{
		if (tTd(0, 4))
			sm_dprintf("SIOCGLIFCONF failed: %s\n",
				   sm_errstring(errno));
		(void) close(s);
		sm_free(buf);
		return;
	}

	/* scan the list of IP address */
	if (tTd(0, 40))
		sm_dprintf("scanning for interface specific names, lifc_len=%ld\n",
			   (long) len);

	for (i = 0; i < len && i >= 0; )
	{
		int flags;
		struct lifreq *ifr = (struct lifreq *)&buf[i];
		SOCKADDR *sa = (SOCKADDR *) &ifr->lifr_addr;
		int af = ifr->lifr_addr.ss_family;
		char *addr;
		char *name;
		struct in6_addr ia6;
		struct in_addr ia;
#  ifdef SIOCGLIFFLAGS
		struct lifreq ifrf;
#  endif /* SIOCGLIFFLAGS */
		char ip_addr[256];
		char buf6[INET6_ADDRSTRLEN];

		/*
		**  We must close and recreate the socket each time
		**  since we don't know what type of socket it is now
		**  (each status function may change it).
		*/

		(void) close(s);

		s = socket(af, SOCK_DGRAM, 0);
		if (s == -1)
		{
			sm_free(buf); /* XXX */
			return;
		}

		/*
		**  If we don't have a complete ifr structure,
		**  don't try to use it.
		*/

		if ((len - i) < sizeof(*ifr))
			break;

#  ifdef BSD4_4_SOCKADDR
		if (sa->sa.sa_len > sizeof(ifr->lifr_addr))
			i += sizeof(ifr->lifr_name) + sa->sa.sa_len;
		else
#  endif /* BSD4_4_SOCKADDR */
#  ifdef DEC
			/* fix for IPv6  size differences */
			i += sizeof(ifr->ifr_name) +
			     max(sizeof(ifr->ifr_addr), ifr->ifr_addr.sa_len);
#   else /* DEC */
			i += sizeof(*ifr);
#   endif /* DEC */

		if (tTd(0, 20))
			sm_dprintf("%s\n", anynet_ntoa(sa));

		if (af != AF_INET && af != AF_INET6)
			continue;

#  ifdef SIOCGLIFFLAGS
		memset(&ifrf, '\0', sizeof(struct lifreq));
		(void) sm_strlcpy(ifrf.lifr_name, ifr->lifr_name,
				  sizeof(ifrf.lifr_name));
		if (ioctl(s, SIOCGLIFFLAGS, (char *) &ifrf) < 0)
		{
			if (tTd(0, 4))
				sm_dprintf("SIOCGLIFFLAGS failed: %s\n",
					   sm_errstring(errno));
			continue;
		}

		name = ifr->lifr_name;
		flags = ifrf.lifr_flags;

		if (tTd(0, 41))
			sm_dprintf("\tflags: %lx\n", (unsigned long) flags);

		if (!bitset(IFF_UP, flags))
			continue;
#  endif /* SIOCGLIFFLAGS */

		ip_addr[0] = '\0';

		/* extract IP address from the list*/
		switch (af)
		{
		  case AF_INET6:
			SETV6LOOPBACKADDRFOUND(*sa);
#  ifdef __KAME__
			/* convert into proper scoped address */
			if ((IN6_IS_ADDR_LINKLOCAL(&sa->sin6.sin6_addr) ||
			     IN6_IS_ADDR_SITELOCAL(&sa->sin6.sin6_addr)) &&
			    sa->sin6.sin6_scope_id == 0)
			{
				struct in6_addr *ia6p;

				ia6p = &sa->sin6.sin6_addr;
				sa->sin6.sin6_scope_id = ntohs(ia6p->s6_addr[3] |
							       ((unsigned int)ia6p->s6_addr[2] << 8));
				ia6p->s6_addr[2] = ia6p->s6_addr[3] = 0;
			}
#  endif /* __KAME__ */
			ia6 = sa->sin6.sin6_addr;
			if (IN6_IS_ADDR_UNSPECIFIED(&ia6))
			{
				addr = anynet_ntop(&ia6, buf6, sizeof(buf6));
				message("WARNING: interface %s is UP with %s address",
					name, addr == NULL ? "(NULL)" : addr);
				continue;
			}

			/* save IP address in text from */
			addr = anynet_ntop(&ia6, buf6, sizeof(buf6));
			if (addr != NULL)
				(void) sm_snprintf(ip_addr, sizeof(ip_addr),
						   "[%.*s]",
						   (int) sizeof(ip_addr) - 3,
						   addr);
			break;

		  case AF_INET:
			ia = sa->sin.sin_addr;
			if (ia.s_addr == INADDR_ANY ||
			    ia.s_addr == INADDR_NONE)
			{
				message("WARNING: interface %s is UP with %s address",
					name, inet_ntoa(ia));
				continue;
			}

			/* save IP address in text from */
			(void) sm_snprintf(ip_addr, sizeof(ip_addr), "[%.*s]",
					(int) sizeof(ip_addr) - 3, inet_ntoa(ia));
			break;
		}

		if (*ip_addr == '\0')
			continue;

		if (!wordinclass(ip_addr, 'w'))
		{
			setclass('w', ip_addr);
			if (tTd(0, 4))
				sm_dprintf("\ta.k.a.: %s\n", ip_addr);
		}

#  ifdef SIOCGLIFFLAGS
		/* skip "loopback" interface "lo" */
		if (DontProbeInterfaces == DPI_SKIPLOOPBACK &&
		    bitset(IFF_LOOPBACK, flags))
			continue;
#  endif /* SIOCGLIFFLAGS */
		(void) add_hostnames(sa);
	}
	sm_free(buf); /* XXX */
	(void) close(s);
# else /* NETINET6 && defined(SIOCGLIFCONF) */
#  if defined(SIOCGIFCONF) && !SIOCGIFCONF_IS_BROKEN
	int s;
	int i;
	struct ifconf ifc;
	int numifs;

	s = socket(AF_INET, SOCK_DGRAM, 0);
	if (s == -1)
		return;

	/* get the list of known IP address from the kernel */
#   if defined(SIOCGIFNUM) && !SIOCGIFNUM_IS_BROKEN
	if (ioctl(s, SIOCGIFNUM, (char *) &numifs) < 0)
	{
		/* can't get number of interfaces -- fall back */
		if (tTd(0, 4))
			sm_dprintf("SIOCGIFNUM failed: %s\n",
				   sm_errstring(errno));
		numifs = -1;
	}
	else if (tTd(0, 42))
		sm_dprintf("system has %d interfaces\n", numifs);
	if (numifs < 0)
#   endif /* defined(SIOCGIFNUM) && !SIOCGIFNUM_IS_BROKEN */
		numifs = MAXINTERFACES;

	if (numifs <= 0)
	{
		(void) close(s);
		return;
	}
	ifc.ifc_len = numifs * sizeof(struct ifreq);
	ifc.ifc_buf = xalloc(ifc.ifc_len);
	if (ioctl(s, SIOCGIFCONF, (char *)&ifc) < 0)
	{
		if (tTd(0, 4))
			sm_dprintf("SIOCGIFCONF failed: %s\n",
				   sm_errstring(errno));
		(void) close(s);
		return;
	}

	/* scan the list of IP address */
	if (tTd(0, 40))
		sm_dprintf("scanning for interface specific names, ifc_len=%d\n",
			ifc.ifc_len);

	for (i = 0; i < ifc.ifc_len && i >= 0; )
	{
		int af;
		struct ifreq *ifr = (struct ifreq *) &ifc.ifc_buf[i];
		SOCKADDR *sa = (SOCKADDR *) &ifr->ifr_addr;
#   if NETINET6
		char *addr;
		struct in6_addr ia6;
#   endif /* NETINET6 */
		struct in_addr ia;
#   ifdef SIOCGIFFLAGS
		struct ifreq ifrf;
#   endif /* SIOCGIFFLAGS */
		char ip_addr[256];
#   if NETINET6
		char buf6[INET6_ADDRSTRLEN];
#   endif /* NETINET6 */

		/*
		**  If we don't have a complete ifr structure,
		**  don't try to use it.
		*/

		if ((ifc.ifc_len - i) < sizeof(*ifr))
			break;

#   ifdef BSD4_4_SOCKADDR
		if (sa->sa.sa_len > sizeof(ifr->ifr_addr))
			i += sizeof(ifr->ifr_name) + sa->sa.sa_len;
		else
#   endif /* BSD4_4_SOCKADDR */
			i += sizeof(*ifr);

		if (tTd(0, 20))
			sm_dprintf("%s\n", anynet_ntoa(sa));

		af = ifr->ifr_addr.sa_family;
		if (af != AF_INET
#   if NETINET6
		    && af != AF_INET6
#   endif /* NETINET6 */
		    )
			continue;

#   ifdef SIOCGIFFLAGS
		memset(&ifrf, '\0', sizeof(struct ifreq));
		(void) sm_strlcpy(ifrf.ifr_name, ifr->ifr_name,
			       sizeof(ifrf.ifr_name));
		(void) ioctl(s, SIOCGIFFLAGS, (char *) &ifrf);
		if (tTd(0, 41))
			sm_dprintf("\tflags: %lx\n",
				(unsigned long) ifrf.ifr_flags);
#    define IFRFREF ifrf
#   else /* SIOCGIFFLAGS */
#    define IFRFREF (*ifr)
#   endif /* SIOCGIFFLAGS */

		if (!bitset(IFF_UP, IFRFREF.ifr_flags))
			continue;

		ip_addr[0] = '\0';

		/* extract IP address from the list*/
		switch (af)
		{
		  case AF_INET:
			ia = sa->sin.sin_addr;
			if (ia.s_addr == INADDR_ANY ||
			    ia.s_addr == INADDR_NONE)
			{
				message("WARNING: interface %s is UP with %s address",
					ifr->ifr_name, inet_ntoa(ia));
				continue;
			}

			/* save IP address in text from */
			(void) sm_snprintf(ip_addr, sizeof(ip_addr), "[%.*s]",
					(int) sizeof(ip_addr) - 3,
					inet_ntoa(ia));
			break;

#   if NETINET6
		  case AF_INET6:
			SETV6LOOPBACKADDRFOUND(*sa);
#    ifdef __KAME__
			/* convert into proper scoped address */
			if ((IN6_IS_ADDR_LINKLOCAL(&sa->sin6.sin6_addr) ||
			     IN6_IS_ADDR_SITELOCAL(&sa->sin6.sin6_addr)) &&
			    sa->sin6.sin6_scope_id == 0)
			{
				struct in6_addr *ia6p;

				ia6p = &sa->sin6.sin6_addr;
				sa->sin6.sin6_scope_id = ntohs(ia6p->s6_addr[3] |
							       ((unsigned int)ia6p->s6_addr[2] << 8));
				ia6p->s6_addr[2] = ia6p->s6_addr[3] = 0;
			}
#    endif /* __KAME__ */
			ia6 = sa->sin6.sin6_addr;
			if (IN6_IS_ADDR_UNSPECIFIED(&ia6))
			{
				addr = anynet_ntop(&ia6, buf6, sizeof(buf6));
				message("WARNING: interface %s is UP with %s address",
					ifr->ifr_name,
					addr == NULL ? "(NULL)" : addr);
				continue;
			}

			/* save IP address in text from */
			addr = anynet_ntop(&ia6, buf6, sizeof(buf6));
			if (addr != NULL)
				(void) sm_snprintf(ip_addr, sizeof(ip_addr),
						   "[%.*s]",
						   (int) sizeof(ip_addr) - 3,
						   addr);
			break;

#   endif /* NETINET6 */
		}

		if (ip_addr[0] == '\0')
			continue;

		if (!wordinclass(ip_addr, 'w'))
		{
			setclass('w', ip_addr);
			if (tTd(0, 4))
				sm_dprintf("\ta.k.a.: %s\n", ip_addr);
		}

		/* skip "loopback" interface "lo" */
		if (DontProbeInterfaces == DPI_SKIPLOOPBACK &&
		    bitset(IFF_LOOPBACK, IFRFREF.ifr_flags))
			continue;

		(void) add_hostnames(sa);
	}
	sm_free(ifc.ifc_buf); /* XXX */
	(void) close(s);
#   undef IFRFREF
#  endif /* defined(SIOCGIFCONF) && !SIOCGIFCONF_IS_BROKEN */
# endif /* NETINET6 && defined(SIOCGLIFCONF) */
}
/*
**  ISLOOPBACK -- is socket address in the loopback net?
**
**	Parameters:
**		sa -- socket address.
**
**	Returns:
**		true -- is socket address in the loopback net?
**		false -- otherwise
**
*/

bool
isloopback(sa)
	SOCKADDR sa;
{
#if NETINET6
	if (IN6_IS_ADDR_LOOPBACK(&sa.sin6.sin6_addr))
		return true;
#else /* NETINET6 */
	/* XXX how to correctly extract IN_LOOPBACKNET part? */
	if (((ntohl(sa.sin.sin_addr.s_addr) & IN_CLASSA_NET)
	     >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET)
		return true;
#endif /* NETINET6 */
	return false;
}
/*
**  GET_NUM_PROCS_ONLINE -- return the number of processors currently online
**
**	Parameters:
**		none.
**
**	Returns:
**		The number of processors online.
*/

static int
get_num_procs_online()
{
	int nproc = 0;

#ifdef USESYSCTL
# if defined(CTL_HW) && defined(HW_NCPU)
	size_t sz;
	int mib[2];

	mib[0] = CTL_HW;
	mib[1] = HW_NCPU;
	sz = (size_t) sizeof(nproc);
	(void) sysctl(mib, 2, &nproc, &sz, NULL, 0);
# endif /* defined(CTL_HW) && defined(HW_NCPU) */
#else /* USESYSCTL */
# ifdef _SC_NPROCESSORS_ONLN
	nproc = (int) sysconf(_SC_NPROCESSORS_ONLN);
# else /* _SC_NPROCESSORS_ONLN */
#  ifdef __hpux
#   include <sys/pstat.h>
	struct pst_dynamic psd;

	if (pstat_getdynamic(&psd, sizeof(psd), (size_t)1, 0) != -1)
		nproc = psd.psd_proc_cnt;
#  endif /* __hpux */
# endif /* _SC_NPROCESSORS_ONLN */
#endif /* USESYSCTL */

	if (nproc <= 0)
		nproc = 1;
	return nproc;
}
/*
**  SM_CLOSEFROM -- close file descriptors
**
**	Parameters:
**		lowest -- first fd to close
**		highest -- last fd + 1 to close
**
**	Returns:
**		none
*/

void
sm_closefrom(lowest, highest)
	int lowest, highest;
{
#if HASCLOSEFROM
	closefrom(lowest);
#else /* HASCLOSEFROM */
	int i;

	for (i = lowest; i < highest; i++)
		(void) close(i);
#endif /* HASCLOSEFROM */
}
#if HASFDWALK
/*
**  CLOSEFD_WALK -- walk fd's arranging to close them
**	Callback for fdwalk()
**
**	Parameters:
**		lowest -- first fd to arrange to be closed
**		fd -- fd to arrange to be closed
**
**	Returns:
**		zero
*/

static int
closefd_walk(lowest, fd)
	void *lowest;
	int fd;
{
	if (fd >= *(int *)lowest)
		(void) fcntl(fd, F_SETFD, FD_CLOEXEC);
	return 0;
}
#endif /* HASFDWALK */
/*
**  SM_CLOSE_ON_EXEC -- arrange for file descriptors to be closed
**
**	Parameters:
**		lowest -- first fd to arrange to be closed
**		highest -- last fd + 1 to arrange to be closed
**
**	Returns:
**		none
*/

void
sm_close_on_exec(lowest, highest)
	int lowest, highest;
{
#if HASFDWALK
	(void) fdwalk(closefd_walk, &lowest);
#else /* HASFDWALK */
	int i, j;

	for (i = lowest; i < highest; i++)
	{
		if ((j = fcntl(i, F_GETFD, 0)) != -1)
			(void) fcntl(i, F_SETFD, j | FD_CLOEXEC);
	}
#endif /* HASFDWALK */
}
/*
**  SEED_RANDOM -- seed the random number generator
**
**	Parameters:
**		none
**
**	Returns:
**		none
*/

void
seed_random()
{
#if HASSRANDOMDEV
	srandomdev();
#else /* HASSRANDOMDEV */
	long seed;
	struct timeval t;

	seed = (long) CurrentPid;
	if (gettimeofday(&t, NULL) >= 0)
		seed += t.tv_sec + t.tv_usec;

# if HASRANDOM
	(void) srandom(seed);
# else /* HASRANDOM */
	(void) srand((unsigned int) seed);
# endif /* HASRANDOM */
#endif /* HASSRANDOMDEV */
}
/*
**  SM_SYSLOG -- syslog wrapper to keep messages under SYSLOG_BUFSIZE
**
**	Parameters:
**		level -- syslog level
**		id -- envelope ID or NULL (NOQUEUE)
**		fmt -- format string
**		arg... -- arguments as implied by fmt.
**
**	Returns:
**		none
*/

/* VARARGS3 */
void
#ifdef __STDC__
sm_syslog(int level, const char *id, const char *fmt, ...)
#else /* __STDC__ */
sm_syslog(level, id, fmt, va_alist)
	int level;
	const char *id;
	const char *fmt;
	va_dcl
#endif /* __STDC__ */
{
	char *buf;
	size_t bufsize;
	char *begin, *end;
	int save_errno;
	int seq = 1;
	int idlen;
	char buf0[MAXLINE];
	char *newstring;
	extern int SyslogPrefixLen;
	SM_VA_LOCAL_DECL

	save_errno = errno;
	if (id == NULL)
		id = "NOQUEUE";
	idlen = strlen(id) + SyslogPrefixLen;

	buf = buf0;
	bufsize = sizeof(buf0);

	for (;;)
	{
		int n;

		/* print log message into buf */
		SM_VA_START(ap, fmt);
		n = sm_vsnprintf(buf, bufsize, fmt, ap);
		SM_VA_END(ap);
		SM_ASSERT(n > 0);
		if (n < bufsize)
			break;

		/* String too small, redo with correct size */
		bufsize = n + 1;
		if (buf != buf0)
		{
			sm_free(buf);
			buf = NULL;
		}
		buf = sm_malloc_x(bufsize);
	}

	/* clean up buf after it has been expanded with args */
	newstring = str2prt(buf);
	if ((strlen(newstring) + idlen + 1) < SYSLOG_BUFSIZE)
	{
#if LOG
		if (*id == '\0')
		{
			if (tTd(89, 10))
			{
				struct timeval tv;

				gettimeofday(&tv, NULL);
				sm_dprintf("%ld.%06ld %s\n", (long) tv.tv_sec,
					(long) tv.tv_usec, newstring);
			}
			else if (tTd(89, 8))
				sm_dprintf("%s\n", newstring);
			else
				syslog(level, "%s", newstring);
		}
		else
		{
			if (tTd(89, 10))
			{
				struct timeval tv;

				gettimeofday(&tv, NULL);
				sm_dprintf("%ld.%06ld %s: %s\n", (long) tv.tv_sec,
					(long) tv.tv_usec, id, newstring);
			}
			else if (tTd(89, 8))
				sm_dprintf("%s: %s\n", id, newstring);
			else
				syslog(level, "%s: %s", id, newstring);
		}
#else /* LOG */
		/*XXX should do something more sensible */
		if (*id == '\0')
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT, "%s\n",
					     newstring);
		else
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
					     "%s: %s\n", id, newstring);
#endif /* LOG */
		if (buf != buf0)
			sm_free(buf);
		errno = save_errno;
		return;
	}

/*
**  additional length for splitting: " ..." + 3, where 3 is magic to
**  have some data for the next entry.
*/

#define SL_SPLIT 7

	begin = newstring;
	idlen += 5;	/* strlen("[999]"), see below */
	while (*begin != '\0' &&
	       (strlen(begin) + idlen) > SYSLOG_BUFSIZE)
	{
		char save;

		if (seq >= 999)
		{
			/* Too many messages */
			break;
		}
		end = begin + SYSLOG_BUFSIZE - idlen - SL_SPLIT;
		while (end > begin)
		{
			/* Break on comma or space */
			if (*end == ',' || *end == ' ')
			{
				end++;	  /* Include separator */
				break;
			}
			end--;
		}
		/* No separator, break midstring... */
		if (end == begin)
			end = begin + SYSLOG_BUFSIZE - idlen - SL_SPLIT;
		save = *end;
		*end = 0;
#if LOG
		if (tTd(89, 8))
			sm_dprintf("%s[%d]: %s ...\n", id, seq++, begin);
		else
			syslog(level, "%s[%d]: %s ...", id, seq++, begin);
#else /* LOG */
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				     "%s[%d]: %s ...\n", id, seq++, begin);
#endif /* LOG */
		*end = save;
		begin = end;
	}
	if (seq >= 999)
	{
#if LOG
		if (tTd(89, 8))
			sm_dprintf("%s[%d]: log terminated, too many parts\n",
				id, seq);
		else
			syslog(level, "%s[%d]: log terminated, too many parts",
				id, seq);
#else /* LOG */
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
			      "%s[%d]: log terminated, too many parts\n", id, seq);
#endif /* LOG */
	}
	else if (*begin != '\0')
	{
#if LOG
		if (tTd(89, 8))
			sm_dprintf("%s[%d]: %s\n", id, seq, begin);
		else
			syslog(level, "%s[%d]: %s", id, seq, begin);
#else /* LOG */
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				     "%s[%d]: %s\n", id, seq, begin);
#endif /* LOG */
	}
	if (buf != buf0)
		sm_free(buf);
	errno = save_errno;
}
/*
**  HARD_SYSLOG -- call syslog repeatedly until it works
**
**	Needed on HP-UX, which apparently doesn't guarantee that
**	syslog succeeds during interrupt handlers.
*/

#if defined(__hpux) && !defined(HPUX11)

# define MAXSYSLOGTRIES	100
# undef syslog
# ifdef V4FS
#  define XCNST	const
#  define CAST	(const char *)
# else /* V4FS */
#  define XCNST
#  define CAST
# endif /* V4FS */

void
# ifdef __STDC__
hard_syslog(int pri, XCNST char *msg, ...)
# else /* __STDC__ */
hard_syslog(pri, msg, va_alist)
	int pri;
	XCNST char *msg;
	va_dcl
# endif /* __STDC__ */
{
	int i;
	char buf[SYSLOG_BUFSIZE];
	SM_VA_LOCAL_DECL

	SM_VA_START(ap, msg);
	(void) sm_vsnprintf(buf, sizeof(buf), msg, ap);
	SM_VA_END(ap);

	for (i = MAXSYSLOGTRIES; --i >= 0 && syslog(pri, CAST "%s", buf) < 0; )
		continue;
}

# undef CAST
#endif /* defined(__hpux) && !defined(HPUX11) */
#if NEEDLOCAL_HOSTNAME_LENGTH
/*
**  LOCAL_HOSTNAME_LENGTH
**
**	This is required to get sendmail to compile against BIND 4.9.x
**	on Ultrix.
**
**	Unfortunately, a Compaq Y2K patch kit provides it without
**	bumping __RES in /usr/include/resolv.h so we can't automatically
**	figure out whether it is needed.
*/

int
local_hostname_length(hostname)
	char *hostname;
{
	size_t len_host, len_domain;

	if (!*_res.defdname)
		res_init();
	len_host = strlen(hostname);
	len_domain = strlen(_res.defdname);
	if (len_host > len_domain &&
	    (sm_strcasecmp(hostname + len_host - len_domain,
			_res.defdname) == 0) &&
	    hostname[len_host - len_domain - 1] == '.')
		return len_host - len_domain - 1;
	else
		return 0;
}
#endif /* NEEDLOCAL_HOSTNAME_LENGTH */

#if NEEDLINK
/*
**  LINK -- clone a file
**
**	Some OS's lacks link() and hard links.  Since sendmail is using
**	link() as an efficient way to clone files, this implementation
**	will simply do a file copy.
**
**	NOTE: This link() replacement is not a generic replacement as it
**	does not handle all of the semantics of the real link(2).
**
**	Parameters:
**		source -- pathname of existing file.
**		target -- pathname of link (clone) to be created.
**
**	Returns:
**		0 -- success.
**		-1 -- failure, see errno for details.
*/

int
link(source, target)
	const char *source;
	const char *target;
{
	int save_errno;
	int sff;
	int src = -1, dst = -1;
	ssize_t readlen;
	ssize_t writelen;
	char buf[BUFSIZ];
	struct stat st;

	sff = SFF_REGONLY|SFF_OPENASROOT;
	if (DontLockReadFiles)
		sff |= SFF_NOLOCK;

	/* Open the original file */
	src = safeopen((char *)source, O_RDONLY, 0, sff);
	if (src < 0)
		goto fail;

	/* Obtain the size and the mode */
	if (fstat(src, &st) < 0)
		goto fail;

	/* Create the duplicate copy */
	sff &= ~SFF_NOLOCK;
	sff |= SFF_CREAT;
	dst = safeopen((char *)target, O_CREAT|O_EXCL|O_WRONLY,
		       st.st_mode, sff);
	if (dst < 0)
		goto fail;

	/* Copy all of the bytes one buffer at a time */
	while ((readlen = read(src, &buf, sizeof(buf))) > 0)
	{
		ssize_t left = readlen;
		char *p = buf;

		while (left > 0 &&
		       (writelen = write(dst, p, (size_t) left)) >= 0)
		{
			left -= writelen;
			p += writelen;
		}
		if (writelen < 0)
			break;
	}

	/* Any trouble reading? */
	if (readlen < 0 || writelen < 0)
		goto fail;

	/* Close the input file */
	if (close(src) < 0)
	{
		src = -1;
		goto fail;
	}
	src = -1;

	/* Close the output file */
	if (close(dst) < 0)
	{
		/* don't set dst = -1 here so we unlink the file */
		goto fail;
	}

	/* Success */
	return 0;

 fail:
	save_errno = errno;
	if (src >= 0)
		(void) close(src);
	if (dst >= 0)
	{
		(void) unlink(target);
		(void) close(dst);
	}
	errno = save_errno;
	return -1;
}
#endif /* NEEDLINK */

/*
**  Compile-Time options
*/

char	*CompileOptions[] =
{
#if ALLOW_255
	"ALLOW_255",
#endif /* ALLOW_255 */
#if NAMED_BIND
# if DNSMAP
	"DNSMAP",
# endif /* DNSMAP */
#endif /* NAMED_BIND */
#if EGD
	"EGD",
#endif /* EGD */
#if HESIOD
	"HESIOD",
#endif /* HESIOD */
#if HES_GETMAILHOST
	"HES_GETMAILHOST",
#endif /* HES_GETMAILHOST */
#if LDAPMAP
	"LDAPMAP",
#endif /* LDAPMAP */
#if LDAP_REFERRALS
	"LDAP_REFERRALS",
#endif /* LDAP_REFERRALS */
#if LOG
	"LOG",
#endif /* LOG */
#if MAP_NSD
	"MAP_NSD",
#endif /* MAP_NSD */
#if MAP_REGEX
	"MAP_REGEX",
#endif /* MAP_REGEX */
#if MATCHGECOS
	"MATCHGECOS",
#endif /* MATCHGECOS */
#if MILTER
	"MILTER",
#endif /* MILTER */
#if MIME7TO8
	"MIME7TO8",
#endif /* MIME7TO8 */
#if MIME7TO8_OLD
	"MIME7TO8_OLD",
#endif /* MIME7TO8_OLD */
#if MIME8TO7
	"MIME8TO7",
#endif /* MIME8TO7 */
#if NAMED_BIND
	"NAMED_BIND",
#endif /* NAMED_BIND */
#if NDBM
	"NDBM",
#endif /* NDBM */
#if NETINET
	"NETINET",
#endif /* NETINET */
#if NETINET6
	"NETINET6",
#endif /* NETINET6 */
#if NETINFO
	"NETINFO",
#endif /* NETINFO */
#if NETISO
	"NETISO",
#endif /* NETISO */
#if NETNS
	"NETNS",
#endif /* NETNS */
#if NETUNIX
	"NETUNIX",
#endif /* NETUNIX */
#if NETX25
	"NETX25",
#endif /* NETX25 */
#if NEWDB
	"NEWDB",
#endif /* NEWDB */
#if NIS
	"NIS",
#endif /* NIS */
#if NISPLUS
	"NISPLUS",
#endif /* NISPLUS */
#if NO_DH
	"NO_DH",
#endif /* NO_DH */
#if PH_MAP
	"PH_MAP",
#endif /* PH_MAP */
#ifdef PICKY_HELO_CHECK
	"PICKY_HELO_CHECK",
#endif /* PICKY_HELO_CHECK */
#if PIPELINING
	"PIPELINING",
#endif /* PIPELINING */
#if SASL
# if SASL >= 20000
	"SASLv2",
# else /* SASL >= 20000 */
	"SASL",
# endif /* SASL >= 20000 */
#endif /* SASL */
#if SCANF
	"SCANF",
#endif /* SCANF */
#if SM_LDAP_ERROR_ON_MISSING_ARGS
	"SM_LDAP_ERROR_ON_MISSING_ARGS",
#endif /* SM_LDAP_ERROR_ON_MISSING_ARGS */
#if SMTPDEBUG
	"SMTPDEBUG",
#endif /* SMTPDEBUG */
#if SOCKETMAP
	"SOCKETMAP",
#endif /* SOCKETMAP */
#if STARTTLS
	"STARTTLS",
#endif /* STARTTLS */
#if SUID_ROOT_FILES_OK
	"SUID_ROOT_FILES_OK",
#endif /* SUID_ROOT_FILES_OK */
#if TCPWRAPPERS
	"TCPWRAPPERS",
#endif /* TCPWRAPPERS */
#if TLS_NO_RSA
	"TLS_NO_RSA",
#endif /* TLS_NO_RSA */
#if TLS_VRFY_PER_CTX
	"TLS_VRFY_PER_CTX",
#endif /* TLS_VRFY_PER_CTX */
#if USERDB
	"USERDB",
#endif /* USERDB */
#if USE_LDAP_INIT
	"USE_LDAP_INIT",
#endif /* USE_LDAP_INIT */
#if USE_TTYPATH
	"USE_TTYPATH",
#endif /* USE_TTYPATH */
#if XDEBUG
	"XDEBUG",
#endif /* XDEBUG */
#if XLA
	"XLA",
#endif /* XLA */
	NULL
};


/*
**  OS compile options.
*/

char	*OsCompileOptions[] =
{
#if ADDRCONFIG_IS_BROKEN
	"ADDRCONFIG_IS_BROKEN",
#endif /* ADDRCONFIG_IS_BROKEN */
#ifdef AUTO_NETINFO_HOSTS
	"AUTO_NETINFO_HOSTS",
#endif /* AUTO_NETINFO_HOSTS */
#ifdef AUTO_NIS_ALIASES
	"AUTO_NIS_ALIASES",
#endif /* AUTO_NIS_ALIASES */
#if BROKEN_RES_SEARCH
	"BROKEN_RES_SEARCH",
#endif /* BROKEN_RES_SEARCH */
#ifdef BSD4_4_SOCKADDR
	"BSD4_4_SOCKADDR",
#endif /* BSD4_4_SOCKADDR */
#if BOGUS_O_EXCL
	"BOGUS_O_EXCL",
#endif /* BOGUS_O_EXCL */
#if DEC_OSF_BROKEN_GETPWENT
	"DEC_OSF_BROKEN_GETPWENT",
#endif /* DEC_OSF_BROKEN_GETPWENT */
#if FAST_PID_RECYCLE
	"FAST_PID_RECYCLE",
#endif /* FAST_PID_RECYCLE */
#if HASCLOSEFROM
	"HASCLOSEFROM",
#endif /* HASCLOSEFROM */
#if HASFCHOWN
	"HASFCHOWN",
#endif /* HASFCHOWN */
#if HASFCHMOD
	"HASFCHMOD",
#endif /* HASFCHMOD */
#if HASFDWALK
	"HASFDWALK",
#endif /* HASFDWALK */
#if HASFLOCK
	"HASFLOCK",
#endif /* HASFLOCK */
#if HASGETDTABLESIZE
	"HASGETDTABLESIZE",
#endif /* HASGETDTABLESIZE */
#if HASGETUSERSHELL
	"HASGETUSERSHELL",
#endif /* HASGETUSERSHELL */
#if HASINITGROUPS
	"HASINITGROUPS",
#endif /* HASINITGROUPS */
#if HASLDAPGETALIASBYNAME
	"HASLDAPGETALIASBYNAME",
#endif /* HASLDAPGETALIASBYNAME */
#if HASLSTAT
	"HASLSTAT",
#endif /* HASLSTAT */
#if HASNICE
	"HASNICE",
#endif /* HASNICE */
#if HASRANDOM
	"HASRANDOM",
#endif /* HASRANDOM */
#if HASRRESVPORT
	"HASRRESVPORT",
#endif /* HASRRESVPORT */
#if HASSETEGID
	"HASSETEGID",
#endif /* HASSETEGID */
#if HASSETLOGIN
	"HASSETLOGIN",
#endif /* HASSETLOGIN */
#if HASSETREGID
	"HASSETREGID",
#endif /* HASSETREGID */
#if HASSETRESGID
	"HASSETRESGID",
#endif /* HASSETRESGID */
#if HASSETREUID
	"HASSETREUID",
#endif /* HASSETREUID */
#if HASSETRLIMIT
	"HASSETRLIMIT",
#endif /* HASSETRLIMIT */
#if HASSETSID
	"HASSETSID",
#endif /* HASSETSID */
#if HASSETUSERCONTEXT
	"HASSETUSERCONTEXT",
#endif /* HASSETUSERCONTEXT */
#if HASSETVBUF
	"HASSETVBUF",
#endif /* HASSETVBUF */
#if HAS_ST_GEN
	"HAS_ST_GEN",
#endif /* HAS_ST_GEN */
#if HASSRANDOMDEV
	"HASSRANDOMDEV",
#endif /* HASSRANDOMDEV */
#if HASURANDOMDEV
	"HASURANDOMDEV",
#endif /* HASURANDOMDEV */
#if HASSTRERROR
	"HASSTRERROR",
#endif /* HASSTRERROR */
#if HASULIMIT
	"HASULIMIT",
#endif /* HASULIMIT */
#if HASUNAME
	"HASUNAME",
#endif /* HASUNAME */
#if HASUNSETENV
	"HASUNSETENV",
#endif /* HASUNSETENV */
#if HASWAITPID
	"HASWAITPID",
#endif /* HASWAITPID */
#if HAVE_NANOSLEEP
	"HAVE_NANOSLEEP",
#endif /* HAVE_NANOSLEEP */
#if IDENTPROTO
	"IDENTPROTO",
#endif /* IDENTPROTO */
#if IP_SRCROUTE
	"IP_SRCROUTE",
#endif /* IP_SRCROUTE */
#if O_EXLOCK && HASFLOCK && !BOGUS_O_EXCL
	"LOCK_ON_OPEN",
#endif /* O_EXLOCK && HASFLOCK && !BOGUS_O_EXCL */
#if MILTER_NO_NAGLE
	"MILTER_NO_NAGLE ",
#endif /* MILTER_NO_NAGLE */
#if NEEDFSYNC
	"NEEDFSYNC",
#endif /* NEEDFSYNC */
#if NEEDLINK
	"NEEDLINK",
#endif /* NEEDLINK */
#if NEEDLOCAL_HOSTNAME_LENGTH
	"NEEDLOCAL_HOSTNAME_LENGTH",
#endif /* NEEDLOCAL_HOSTNAME_LENGTH */
#if NEEDSGETIPNODE
	"NEEDSGETIPNODE",
#endif /* NEEDSGETIPNODE */
#if NEEDSTRSTR
	"NEEDSTRSTR",
#endif /* NEEDSTRSTR */
#if NEEDSTRTOL
	"NEEDSTRTOL",
#endif /* NEEDSTRTOL */
#ifdef NO_GETSERVBYNAME
	"NO_GETSERVBYNAME",
#endif /* NO_GETSERVBYNAME */
#if NOFTRUNCATE
	"NOFTRUNCATE",
#endif /* NOFTRUNCATE */
#if REQUIRES_DIR_FSYNC
	"REQUIRES_DIR_FSYNC",
#endif /* REQUIRES_DIR_FSYNC */
#if RLIMIT_NEEDS_SYS_TIME_H
	"RLIMIT_NEEDS_SYS_TIME_H",
#endif /* RLIMIT_NEEDS_SYS_TIME_H */
#if SAFENFSPATHCONF
	"SAFENFSPATHCONF",
#endif /* SAFENFSPATHCONF */
#if SECUREWARE
	"SECUREWARE",
#endif /* SECUREWARE */
#if SFS_TYPE == SFS_4ARGS
	"SFS_4ARGS",
#elif SFS_TYPE == SFS_MOUNT
	"SFS_MOUNT",
#elif SFS_TYPE == SFS_NONE
	"SFS_NONE",
#elif SFS_TYPE == SFS_NT
	"SFS_NT",
#elif SFS_TYPE == SFS_STATFS
	"SFS_STATFS",
#elif SFS_TYPE == SFS_STATVFS
	"SFS_STATVFS",
#elif SFS_TYPE == SFS_USTAT
	"SFS_USTAT",
#elif SFS_TYPE == SFS_VFS
	"SFS_VFS",
#endif
#if SHARE_V1
	"SHARE_V1",
#endif /* SHARE_V1 */
#if SIOCGIFCONF_IS_BROKEN
	"SIOCGIFCONF_IS_BROKEN",
#endif /* SIOCGIFCONF_IS_BROKEN */
#if SIOCGIFNUM_IS_BROKEN
	"SIOCGIFNUM_IS_BROKEN",
#endif /* SIOCGIFNUM_IS_BROKEN */
#if SNPRINTF_IS_BROKEN
	"SNPRINTF_IS_BROKEN",
#endif /* SNPRINTF_IS_BROKEN */
#if SO_REUSEADDR_IS_BROKEN
	"SO_REUSEADDR_IS_BROKEN",
#endif /* SO_REUSEADDR_IS_BROKEN */
#if SYS5SETPGRP
	"SYS5SETPGRP",
#endif /* SYS5SETPGRP */
#if SYSTEM5
	"SYSTEM5",
#endif /* SYSTEM5 */
#if USE_DOUBLE_FORK
	"USE_DOUBLE_FORK",
#endif /* USE_DOUBLE_FORK */
#if USE_ENVIRON
	"USE_ENVIRON",
#endif /* USE_ENVIRON */
#if USE_SA_SIGACTION
	"USE_SA_SIGACTION",
#endif /* USE_SA_SIGACTION */
#if USE_SIGLONGJMP
	"USE_SIGLONGJMP",
#endif /* USE_SIGLONGJMP */
#if USEGETCONFATTR
	"USEGETCONFATTR",
#endif /* USEGETCONFATTR */
#if USESETEUID
	"USESETEUID",
#endif /* USESETEUID */
#ifdef USESYSCTL
	"USESYSCTL",
#endif /* USESYSCTL */
#if USE_OPENSSL_ENGINE
	"USE_OPENSSL_ENGINE",
#endif /* USE_OPENSSL_ENGINE */
#if USING_NETSCAPE_LDAP
	"USING_NETSCAPE_LDAP",
#endif /* USING_NETSCAPE_LDAP */
#ifdef WAITUNION
	"WAITUNION",
#endif /* WAITUNION */
	NULL
};

/*
**  FFR compile options.
*/

char	*FFRCompileOptions[] =
{
#if _FFR_ADDR_TYPE_MODES
	/* more info in {addr_type}, requires m4 changes! */
	"_FFR_ADDR_TYPE_MODES",
#endif /* _FFR_ADDR_TYPE_MODES */
#if _FFR_ALLOW_SASLINFO
	/* DefaultAuthInfo can be specified by user. */
	/* DefaultAuthInfo doesn't really work in 8.13 anymore. */
	"_FFR_ALLOW_SASLINFO",
#endif /* _FFR_ALLOW_SASLINFO */
#if _FFR_ARPA_MAP
	/* arpa map to reverse an IPv(4,6) address */
	"_FFR_ARPA_MAP",
#endif /* _FFR_ARPA_MAP */
#if _FFR_BADRCPT_SHUTDOWN
	/* shut down connection (421) if there are too many bad RCPTs */
	"_FFR_BADRCPT_SHUTDOWN",
#endif /* _FFR_BADRCPT_SHUTDOWN */
#if _FFR_BESTMX_BETTER_TRUNCATION
	/* Better truncation of list of MX records for dns map. */
	"_FFR_BESTMX_BETTER_TRUNCATION",
#endif /* _FFR_BESTMX_BETTER_TRUNCATION */
#if _FFR_CATCH_BROKEN_MTAS
	/* Deal with MTAs that send a reply during the DATA phase. */
	"_FFR_CATCH_BROKEN_MTAS",
#endif /* _FFR_CATCH_BROKEN_MTAS */
#if _FFR_CHECKCONFIG
	/* New OpMode to check the configuration file */
	"_FFR_CHECKCONFIG",
#endif /* _FFR_CHECKCONFIG */
#if _FFR_CHK_QUEUE
	/* Stricter checks about queue directory permissions. */
	"_FFR_CHK_QUEUE",
#endif /* _FFR_CHK_QUEUE */
#if _FFR_CLIENT_SIZE
	/* Don't try to send mail if its size exceeds SIZE= of server. */
	"_FFR_CLIENT_SIZE",
#endif /* _FFR_CLIENT_SIZE */
#if _FFR_CRLPATH
	/* CRLPath; needs documentation; Al Smith */
	"_FFR_CRLPATH",
#endif /* _FFR_CRLPATH */
#if _FFR_DAEMON_NETUNIX
	/* Allow local (not just TCP) socket connection to server. */
	"_FFR_DAEMON_NETUNIX",
#endif /* _FFR_DAEMON_NETUNIX */
#if _FFR_DEPRECATE_MAILER_FLAG_I
	/* What it says :-) */
	"_FFR_DEPRECATE_MAILER_FLAG_I",
#endif /* _FFR_DEPRECATE_MAILER_FLAG_I */
#if _FFR_DM_ONE
	/* deliver first TA in background, then queue */
	"_FFR_DM_ONE",
#endif /* _FFR_DM_ONE */
#if _FFR_DIGUNIX_SAFECHOWN
	/* Properly set SAFECHOWN (include/sm/conf.h) for Digital UNIX */
/* Problem noted by Anne Bennett of Concordia University */
	"_FFR_DIGUNIX_SAFECHOWN",
#endif /* _FFR_DIGUNIX_SAFECHOWN */
#if _FFR_DNSMAP_ALIASABLE
	/* Allow dns map type to be used for aliases. */
/* Don Lewis of TDK */
	"_FFR_DNSMAP_ALIASABLE",
#endif /* _FFR_DNSMAP_ALIASABLE */
#if _FFR_DONTLOCKFILESFORREAD_OPTION
	/* Enable DontLockFilesForRead option. */
	"_FFR_DONTLOCKFILESFORREAD_OPTION",
#endif /* _FFR_DONTLOCKFILESFORREAD_OPTION */
#if _FFR_DOTTED_USERNAMES
	/* Allow usernames with '.' */
	"_FFR_DOTTED_USERNAMES",
#endif /* _FFR_DOTTED_USERNAMES */
#if _FFR_DPO_CS
	/*
	**  Make DaemonPortOptions case sensitive.
	**  For some unknown reasons the code converted every option
	**  to uppercase (first letter only, as that's the only one that
	**  is actually checked). This prevented all new lower case options
	**  from working...
	**  The documentation doesn't say anything about case (in)sensitivity,
	**  which means it should be case sensitive by default,
	**  but it's not a good idea to change this within a patch release,
	**  so let's delay this to 8.15.
	*/

	"_FFR_DPO_CS",
#endif /* _FFR_DPO_CS */
#if _FFR_DPRINTF_MAP
	/* dprintf map for logging */
	"_FFR_DPRINTF_MAP",
#endif /* _FFR_DPRINTF_MAP */
#if _FFR_DROP_TRUSTUSER_WARNING
	/*
	**  Don't issue this warning:
	**  "readcf: option TrustedUser may cause problems on systems
	**  which do not support fchown() if UseMSP is not set.
	*/

	"_FFR_DROP_TRUSTUSER_WARNING",
#endif /* _FFR_DROP_TRUSTUSER_WARNING */
#if _FFR_EIGHT_BIT_ADDR_OK
	/* EightBitAddrOK: allow 8-bit e-mail addresses */
	"_FFR_EIGHT_BIT_ADDR_OK",
#endif /* _FFR_EIGHT_BIT_ADDR_OK */
#if _FFR_EXPDELAY
	/* exponential queue delay */
	"_FFR_EXPDELAY",
#endif /* _FFR_EXPDELAY */
#if _FFR_EXTRA_MAP_CHECK
	/* perform extra checks on $( $) in R lines */
	"_FFR_EXTRA_MAP_CHECK",
#endif /* _FFR_EXTRA_MAP_CHECK */
#if _FFR_GETHBN_ExFILE
	/*
	**  According to Motonori Nakamura some gethostbyname()
	**  implementations (TurboLinux?) may (temporarily) fail
	**  due to a lack of file discriptors. Enabling this FFR
	**  will check errno for EMFILE and ENFILE and in case of a match
	**  cause a temporary error instead of a permanent error.
	**  The right solution is of course to file a bug against those
	**  systems such that they actually set h_errno = TRY_AGAIN.
	*/

	"_FFR_GETHBN_ExFILE",
#endif /* _FFR_GETHBN_ExFILE */
#if _FFR_FIPSMODE
	/* FIPSMode (if supported by OpenSSL library) */
	"_FFR_FIPSMODE",
#endif /* _FFR_FIPSMODE */
#if _FFR_FIX_DASHT
	/*
	**  If using -t, force not sending to argv recipients, even
	**  if they are mentioned in the headers.
	*/

	"_FFR_FIX_DASHT",
#endif /* _FFR_FIX_DASHT */
#if _FFR_FORWARD_SYSERR
	/* Cause a "syserr" if forward file isn't "safe". */
	"_FFR_FORWARD_SYSERR",
#endif /* _FFR_FORWARD_SYSERR */
#if _FFR_GEN_ORCPT
	/* Generate a ORCPT DSN arg if not already provided */
	"_FFR_GEN_ORCPT",
#endif /* _FFR_GEN_ORCPT */
#if _FFR_GROUPREADABLEAUTHINFOFILE
	/* Allow group readable DefaultAuthInfo file. */
	"_FFR_GROUPREADABLEAUTHINFOFILE",
#endif /* _FFR_GROUPREADABLEAUTHINFOFILE */
#if _FFR_HANDLE_ISO8859_GECOS
	/*
	**  Allow ISO 8859 characters in GECOS field: replace them
	**  ith ASCII "equivalent".
	*/

/* Peter Eriksson of Linkopings universitet */
	"_FFR_HANDLE_ISO8859_GECOS",
#endif /* _FFR_HANDLE_ISO8859_GECOS */
#if _FFR_HPUX_NSSWITCH
	/* Use nsswitch on HP-UX */
	"_FFR_HPUX_NSSWITCH",
#endif /* _FFR_HPUX_NSSWITCH */
#if _FFR_IGNORE_BOGUS_ADDR
	/* Ignore addresses for which prescan() failed */
	"_FFR_IGNORE_BOGUS_ADDR",
#endif /* _FFR_IGNORE_BOGUS_ADDR */
#if _FFR_IGNORE_EXT_ON_HELO
	/* Ignore extensions offered in response to HELO */
	"_FFR_IGNORE_EXT_ON_HELO",
#endif /* _FFR_IGNORE_EXT_ON_HELO */
#if _FFR_IPV6_FULL
	/* Use uncompressed IPv6 address format (no "::") */
	"_FFR_IPV6_FULL",
#endif /* _FFR_IPV6_FULL */
#if _FFR_LINUX_MHNL
	/* Set MAXHOSTNAMELEN to 256 (Linux) */
	"_FFR_LINUX_MHNL",
#endif /* _FFR_LINUX_MHNL */
#if _FFR_LOCAL_DAEMON
	/* Local daemon mode (-bl) which only accepts loopback connections */
	"_FFR_LOCAL_DAEMON",
#endif /* _FFR_LOCAL_DAEMON */
#if _FFR_MAIL_MACRO
	"_FFR_MAIL_MACRO",
#endif /* _FFR_MAIL_MACRO */
#if _FFR_MAXDATASIZE
	/*
	**  It is possible that a header is larger than MILTER_CHUNK_SIZE,
	**  hence this shouldn't be used as limit for milter communication.
	**  see also libmilter/comm.c
	**  Gurusamy Sarathy of ActiveState
	*/

	"_FFR_MAXDATASIZE",
#endif /* _FFR_MAXDATASIZE */
#if _FFR_MAX_FORWARD_ENTRIES
	/* Try to limit number of .forward entries */
	/* (doesn't work) */
/* Randall S. Winchester of the University of Maryland */
	"_FFR_MAX_FORWARD_ENTRIES",
#endif /* _FFR_MAX_FORWARD_ENTRIES */
#if _FFR_MAX_SLEEP_TIME
	/* Limit sleep(2) time in libsm/clock.c */
	"_FFR_MAX_SLEEP_TIME",
#endif /* _FFR_MAX_SLEEP_TIME */
#if _FFR_MDS_NEGOTIATE
	/* MaxDataSize negotation with libmilter */
	"_FFR_MDS_NEGOTIATE",
#endif /* _FFR_MDS_NEGOTIATE */
#if _FFR_MEMSTAT
	/* Check free memory */
	"_FFR_MEMSTAT",
#endif /* _FFR_MEMSTAT */
#if _FFR_MILTER_CHECK
	"_FFR_MILTER_CHECK",
#endif /* _FFR_MILTER_CHECK */
#if _FFR_MILTER_CONVERT_ALL_LF_TO_CRLF
	/*
	**  milter_body() uses the same conversion algorithm as putbody()
	**  to translate the "local" df format (\n) to SMTP format (\r\n).
	**  However, putbody() and mime8to7() use different conversion
	**  algorithms.
	**  If the input date does not follow the SMTP standard
	**  (e.g., if it has "naked \r"s), then the output from putbody()
	**  and mime8to7() will most likely be different.
	**  By turning on this FFR milter_body() will try to "imitate"
	**  mime8to7().
	**  Note: there is no (simple) way to deal with both conversions
	**  in a consistent manner. Moreover, as the "GiGo" principle applies,
	**  it's not really worth to fix it.
	*/

	"_FFR_MILTER_CONVERT_ALL_LF_TO_CRLF",
#endif /* _FFR_MILTER_CONVERT_ALL_LF_TO_CRLF */
#if _FFR_MILTER_CHECK_REJECTIONS_TOO
	/*
	**  Also send RCPTs that are rejected by check_rcpt to a milter
	**  (if requested during option negotiation).
	*/

	"_FFR_MILTER_CHECK_REJECTIONS_TOO",
#endif /* _FFR_MILTER_CHECK_REJECTIONS_TOO */
#if _FFR_MILTER_ENHSC
	/* extract enhanced status code from milter replies for dsn= logging */
	"_FFR_MILTER_ENHSC",
#endif /* _FFR_MILTER_ENHSC */
#if _FFR_MIME7TO8_OLD
	/* Old mime7to8 code, the new is broken for at least one example. */
	"_FFR_MIME7TO8_OLD",
#endif /* _FFR_MAX_SLEEP_TIME */
#if _FFR_MORE_MACROS
	/* allow more long macro names ("unprintable" characters). */
	"_FFR_MORE_MACROS",
#endif /* _FFR_MORE_MACROS */
#if _FFR_MSG_ACCEPT
	/* allow to override "Message accepted for delivery" */
	"_FFR_MSG_ACCEPT",
#endif /* _FFR_MSG_ACCEPT */
#if _FFR_NODELAYDSN_ON_HOLD
	/* Do not issue a DELAY DSN for mailers that use the hold flag. */
/* Steven Pitzl */
	"_FFR_NODELAYDSN_ON_HOLD",
#endif /* _FFR_NODELAYDSN_ON_HOLD */
#if _FFR_NO_PIPE
	/* Disable PIPELINING, delay client if used. */
	"_FFR_NO_PIPE",
#endif /* _FFR_NO_PIPE */
#if _FFR_LDAP_NETWORK_TIMEOUT
	/* set LDAP_OPT_NETWORK_TIMEOUT if available (-c) */
	"_FFR_LDAP_NETWORK_TIMEOUT",
#endif /* _FFR_LDAP_NETWORK_TIMEOUT */
#if _FFR_LOG_NTRIES
	/* log ntries=, from Nik Clayton of FreeBSD */
	"_FFR_LOG_NTRIES",
#endif /* _FFR_LOG_NTRIES */
#if _FFR_QF_PARANOIA
	"_FFR_QF_PARANOIA",
#endif /* _FFR_QF_PARANOIA */
#if _FFR_QUEUEDELAY
	/* Exponential queue delay; disabled in 8.13 since it isn't used. */
	"_FFR_QUEUEDELAY",
#endif /* _FFR_QUEUEDELAY */
#if _FFR_QUEUE_GROUP_SORTORDER
	/* Allow QueueSortOrder per queue group. */
/* XXX: Still need to actually use qgrp->qg_sortorder */
	"_FFR_QUEUE_GROUP_SORTORDER",
#endif /* _FFR_QUEUE_GROUP_SORTORDER */
#if _FFR_QUEUE_MACRO
	/* Define {queue} macro. */
	"_FFR_QUEUE_MACRO",
#endif /* _FFR_QUEUE_MACRO */
#if _FFR_QUEUE_RUN_PARANOIA
	/* Additional checks when doing queue runs; interval of checks */
	"_FFR_QUEUE_RUN_PARANOIA",
#endif /* _FFR_QUEUE_RUN_PARANOIA */
#if _FFR_QUEUE_SCHED_DBG
	/* Debug output for the queue scheduler. */
	"_FFR_QUEUE_SCHED_DBG",
#endif /* _FFR_QUEUE_SCHED_DBG */
#if _FFR_RCPTTHROTDELAY
	/* configurable delay for BadRcptThrottle */
	"_FFR_RCPTTHROTDELAY",
#endif /* _FFR_RCPTTHROTDELAY */
#if _FFR_REDIRECTEMPTY
	/*
	**  envelope <> can't be sent to mailing lists, only owner-
	**  send spam of this type to owner- of the list
	**  ----  to stop spam from going to mailing lists.
	*/

	"_FFR_REDIRECTEMPTY",
#endif /* _FFR_REDIRECTEMPTY */
#if _FFR_REJECT_NUL_BYTE
	/* reject NUL bytes in body */
	"_FFR_REJECT_NUL_BYTE",
#endif /* _FFR_REJECT_NUL_BYTE */
#if _FFR_RESET_MACRO_GLOBALS
	/* Allow macro 'j' to be set dynamically via rulesets. */
	"_FFR_RESET_MACRO_GLOBALS",
#endif /* _FFR_RESET_MACRO_GLOBALS */
#if _FFR_RHS
	/* Random shuffle for queue sorting. */
	"_FFR_RHS",
#endif /* _FFR_RHS */
#if _FFR_RUNPQG
	/*
	**  allow -qGqueue_group -qp to work, i.e.,
	**  restrict a persistent queue runner to a queue group.
	*/

	"_FFR_RUNPQG",
#endif /* _FFR_RUNPQG */
#if _FFR_SESSID
	/* session id (for logging) */
	"_FFR_SESSID",
#endif /* _FFR_SESSID */
#if _FFR_SHM_STATUS
	/* Donated code (unused). */
	"_FFR_SHM_STATUS",
#endif /* _FFR_SHM_STATUS */
#if _FFR_LDAP_SINGLEDN
	/*
	**  The LDAP database map code in Sendmail 8.12.10, when
	**  given the -1 switch, would match only a single DN,
	**  but was able to return multiple attributes for that
	**  DN.  In Sendmail 8.13 this "bug" was corrected to
	**  only return if exactly one attribute matched.
	**
	**  Unfortunately, our configuration uses the former
	**  behaviour.  Attached is a relatively simple patch
	**  to 8.13.4 which adds a -2 switch (for lack of a
	**  better option) which returns the single dn/multiple
	**  attributes.
	**
	** Jeffrey T. Eaton, Carnegie-Mellon University
	*/

	"_FFR_LDAP_SINGLEDN",
#endif /* _FFR_LDAP_SINGLEDN */
#if _FFR_SKIP_DOMAINS
	/* process every N'th domain instead of every N'th message */
	"_FFR_SKIP_DOMAINS",
#endif /* _FFR_SKIP_DOMAINS */
#if _FFR_SLEEP_USE_SELECT
	/* Use select(2) in libsm/clock.c to emulate sleep(2) */
	"_FFR_SLEEP_USE_SELECT ",
#endif /* _FFR_SLEEP_USE_SELECT */
#if _FFR_SPT_ALIGN
	/*
	**  It looks like the Compaq Tru64 5.1A now aligns argv and envp to 64
	**  bit alignment, so unless each piece of argv and envp is a multiple
	**  of 8 bytes (including terminating NULL), initsetproctitle() won't
	**  use any of the space beyond argv[0]. Be sure to set SPT_ALIGN_SIZE
	**  if you use this FFR.
	*/

/* Chris Adams of HiWAAY Informations Services */
	"_FFR_SPT_ALIGN",
#endif /* _FFR_SPT_ALIGN */
#if _FFR_SS_PER_DAEMON
	/* SuperSafe per DaemonPortOptions: 'T' (better letter?) */
	"_FFR_SS_PER_DAEMON",
#endif /* _FFR_SS_PER_DAEMON */
#if _FFR_TESTS
	/* enable some test code */
	"_FFR_TESTS",
#endif /* _FFR_TESTS */
#if _FFR_TIMERS
	/* Donated code (unused). */
	"_FFR_TIMERS",
#endif /* _FFR_TIMERS */
#if _FFR_TLS_1
	/* More STARTTLS options, e.g., secondary certs. */
	"_FFR_TLS_1",
#endif /* _FFR_TLS_1 */
#if _FFR_TLS_EC
	"_FFR_TLS_EC",
#endif /* _FFR_TLS_EC */
#if _FFR_TRUSTED_QF
	/*
	**  If we don't own the file mark it as unsafe.
	**  However, allow TrustedUser to own it as well
	**  in case TrustedUser manipulates the queue.
	*/

	"_FFR_TRUSTED_QF",
#endif /* _FFR_TRUSTED_QF */
#if _FFR_USE_GETPWNAM_ERRNO
	/*
	**  See libsm/mbdb.c: only enable this on OSs
	**  that implement the correct (POSIX) semantics.
	**  This will need to become an OS-specific #if
	**  enabled in include/sm/os/*.h.
	*/

	"_FFR_USE_GETPWNAM_ERRNO",
#endif /* _FFR_USE_GETPWNAM_ERRNO */
#if _FFR_USE_SEM_LOCKING
	"_FFR_USE_SEM_LOCKING",
#endif /* _FFR_USE_SEM_LOCKING */
#if _FFR_USE_SETLOGIN
	/* Use setlogin() */
/* Peter Philipp */
	"_FFR_USE_SETLOGIN",
#endif /* _FFR_USE_SETLOGIN */
	NULL
};

@


1.38
log
@Fix sendmail improper close-on-exec flag handling (CVE-2014-3956)
From FreeBSD SA-14:11

ok millert@@
@
text
@@


1.37
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@d5312 2
a5313 2
sm_close_on_exec(highest, lowest)
	int highest, lowest;
@


1.37.4.1
log
@Fix sendmail improper close-on-exec flag handling (CVE-2014-3956)
From FreeBSD SA-14:11

ok millert@@
@
text
@d5312 2
a5313 2
sm_close_on_exec(lowest, highest)
	int lowest, highest;
@


1.36
log
@f_bavail has been 64bits for some time now so revert 1.12.
Makes sendmail happy on fs with large enough f_bavail values.
millert@@ ok
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2013 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.1182 2013/04/05 17:39:09 ca Exp $")
d668 7
d4231 9
a4240 1
	struct hostent *h;
d4252 12
a4263 1
	*err = h_errno;
d4265 1
d4393 11
d4413 2
a4417 2
#else /* NETINET6 */
				struct in_addr ia;
a4418 1
				size_t i;
d4429 1
d4431 8
a4438 8
					memmove(&ia6, h->h_addr_list[i],
						IN6ADDRSZ);
					addr = anynet_ntop(&ia6,
							   buf6, sizeof(buf6));
#else /* NETINET6 */
					memmove(&ia, h->h_addr_list[i],
						INADDRSZ);
					addr = (char *) inet_ntoa(ia);
d4440 6
d6142 4
d6302 4
d6527 3
d6539 10
@


1.35
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@a3352 1
#ifndef __OpenBSD__
a3354 1
#endif
@


1.35.2.1
log
@Fix sendmail improper close-on-exec flag handling (CVE-2014-3956)
From FreeBSD SA-14:11

ok millert@@
@
text
@d5270 2
a5271 2
sm_close_on_exec(lowest, highest)
	int lowest, highest;
@


1.34
log
@Update to sendmail 8.14.6
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2012 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.1176 2012/12/07 03:59:54 ca Exp $")
d970 1
a970 1
					   sizeof(buf)) != NULL)
d2851 1
a2851 1
				   buf, sizeof(buf)) != NULL)
d3225 1
a3225 1
	while (sm_io_fgets(shellf, SM_TIME_DEFAULT, buf, sizeof(buf)) != NULL)
d4299 6
a4304 1
	int flags = AI_DEFAULT|AI_ALL;
d6014 17
d6211 4
d6394 4
@


1.33
log
@Update to sendmail 8.14.5
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2010 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.1168 2011/01/25 18:31:30 ca Exp $")
d56 1
a56 1
#define sm_getipnodebyname getipnodebyname 
d4607 4
d5383 9
a5391 1
			if (tTd(89, 8))
d5398 9
a5406 1
			if (tTd(89, 8))
@


1.32
log
@Update to sendmail-8.14.3
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2008 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.1141 2008/04/14 02:09:35 ca Exp $")
d53 5
a57 2
static struct hostent *getipnodebyname __P((char *, int, int, int *));
static struct hostent *getipnodebyaddr __P((char *, int, int, int *));
d398 3
d791 1
a791 1
			(void) strlcpy(buf, "aliases.ldap ldap -b . -h localhost -k mail=%0 -v mailgroup",
d977 4
a980 1
				p = strpbrk(buf, " \t");
d993 1
a993 1
				while (isspace(*p))
d1019 1
a1019 1
					while (isspace(*p))
d2294 2
a2295 1
		sm_setproctitle(true, e, D_MSG_LA, Daemons[dn].d_name, limit);
d2606 1
a2606 1
/*VARARGS2*/
d3389 4
d4093 1
a4093 1
	} while (isspace(c));
d4129 1
a4129 1
		if (isdigit(c))
d4131 1
a4131 1
		else if (isalpha(c))
d4196 1
a4196 1
**	Some operating systems have wierd problems with the gethostbyXXX
d4220 2
a4221 2
getipnodebyname(name, family, flags, err)
	char *name;
d4244 3
a4246 3
getipnodebyaddr(addr, len, family, err)
	char *addr;
	int len;
d4313 1
a4313 1
	h = getipnodebyname(name, family, flags, &err);
d4352 1
a4352 1
				h = getipnodebyname(hbuf, family, flags, &err);
d4449 1
a4449 1
		hp = getipnodebyaddr(addr, len, type, &err);
d4872 1
d5072 1
d5938 3
d6031 3
d6070 4
d6148 4
d6210 4
d6218 3
d6241 4
d6278 4
d6335 4
d6415 4
@


1.31
log
@"read(..., ..., sizeof Y) < sizeof Y" is a dangerous idiom because it
does an unsigned comparison and read() can return -1. Use '!=' instead
of '<' since read() can't return more than 'sizeof Y'. Not perfect
(that would require a separate test for -1) but a very common usage.

We don't actually compile this code so there is no functional change.

Diff fixed & ok millert@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2007 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.1128 2007/04/03 21:32:29 ca Exp $")
a5327 1
	{
d5329 1
a5329 9
		idlen = strlen(id) + SyslogPrefixLen;
	}
	else if (strcmp(id, NOQID) == 0)
	{
		id = "";
		idlen = SyslogPrefixLen;
	}
	else
		idlen = strlen(id) + SyslogPrefixLen;
d6027 4
d6036 4
d6105 4
d6180 4
d6241 4
d6258 4
d6307 12
@


1.30
log
@Update to sendmail-8.14.1
@
text
@d1516 1
a1516 1
	    read(kmem, (char *) avenrun, sizeof(avenrun)) < sizeof(avenrun))
d1838 1
a1838 1
	    read(kmem, (char *) avenrun, sizeof(avenrun)) < sizeof(avenrun))
d1946 7
@


1.29
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2006 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.1119 2006/12/19 00:58:56 ca Exp $")
d1298 1
a1298 1
#ifdef __QNX__
a3889 2
	char *p;

d3891 1
a3891 2
	if (p = getextenv("SOCK"))
		sm_setuserenv("SOCK", p);
d6084 15
d6194 3
d6215 8
d6244 3
@


1.28
log
@Update to sendmail-8.13.8
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.1082 2006/03/22 22:49:33 ca Exp $")
d18 1
d24 3
a164 1
#if _FFR_PRIV_NOACTUALRECIPIENT
a165 1
#endif /* _FFR_PRIV_NOACTUALRECIPIENT */
d383 1
a383 1
	memset(&ConnectOnlyTo, '\0', sizeof ConnectOnlyTo);
d418 1
a418 1
			  sizeof defuserbuf);
d437 1
a437 1
	(void) sm_strlcpy(buf, "mqueue, P=/var/spool/mqueue", sizeof buf);
d450 1
a450 1
			sizeof buf);
d454 1
a454 1
			sizeof buf);
d458 1
a458 1
			sizeof buf);
d669 7
a715 53
	**  Set up default hosts maps.
	*/

#if 0
	nmaps = switch_map_find("hosts", maptype, mapreturn);
	for (i = 0; i < nmaps; i++)
	{
		if (strcmp(maptype[i], "files") == 0 &&
		    stab("hosts.files", ST_MAP, ST_FIND) == NULL)
		{
			(void) sm_strlcpy(buf, "hosts.files text -k 0 -v 1 /etc/hosts",
				sizeof buf);
			(void) makemapentry(buf);
		}
# if NAMED_BIND
		else if (strcmp(maptype[i], "dns") == 0 &&
			 stab("hosts.dns", ST_MAP, ST_FIND) == NULL)
		{
			(void) sm_strlcpy(buf, "hosts.dns dns A", sizeof buf);
			(void) makemapentry(buf);
		}
# endif /* NAMED_BIND */
# if NISPLUS
		else if (strcmp(maptype[i], "nisplus") == 0 &&
			 stab("hosts.nisplus", ST_MAP, ST_FIND) == NULL)
		{
			(void) sm_strlcpy(buf, "hosts.nisplus nisplus -k name -v address hosts.org_dir",
				sizeof buf);
			(void) makemapentry(buf);
		}
# endif /* NISPLUS */
# if NIS
		else if (strcmp(maptype[i], "nis") == 0 &&
			 stab("hosts.nis", ST_MAP, ST_FIND) == NULL)
		{
			(void) sm_strlcpy(buf, "hosts.nis nis -k 0 -v 1 hosts.byname",
				sizeof buf);
			(void) makemapentry(buf);
		}
# endif /* NIS */
# if NETINFO
		else if (strcmp(maptype[i], "netinfo") == 0 &&
			 stab("hosts.netinfo", ST_MAP, ST_FIND) == NULL)
		{
			(void) sm_strlcpy(buf, "hosts.netinfo netinfo -v name /machines",
				sizeof buf);
			(void) makemapentry(buf);
		}
# endif /* NETINFO */
	}
#endif /* 0 */

	/*
d722 1
a722 1
		(void) sm_strlcpy(buf, "host host", sizeof buf);
d725 1
a725 1
			(void) sm_strlcat(buf, " -a. -D", sizeof buf);
d741 1
a741 1
					  sizeof buf);
d749 1
a749 1
				sizeof buf);
d758 1
a758 1
				sizeof buf);
d767 1
a767 1
				sizeof buf);
d776 1
a776 1
				sizeof buf);
d780 4
a783 17
	}
	if (stab("aliases", ST_MAP, ST_FIND) == NULL)
	{
		(void) sm_strlcpy(buf, "aliases switch aliases", sizeof buf);
		(void) makemapentry(buf);
	}

#if 0		/* "user" map class is a better choice */
	/*
	**  Set up default users maps.
	*/

	nmaps = switch_map_find("passwd", maptype, mapreturn);
	for (i = 0; i < nmaps; i++)
	{
		if (strcmp(maptype[i], "files") == 0 &&
		    stab("users.files", ST_MAP, ST_FIND) == NULL)
d785 1
a785 1
			(void) sm_strlcpy(buf, "users.files text -m -z: -k0 -v6 /etc/passwd",
d789 1
a789 26
# if NISPLUS
		else if (strcmp(maptype[i], "nisplus") == 0 &&
		    stab("users.nisplus", ST_MAP, ST_FIND) == NULL)
		{
			(void) sm_strlcpy(buf, "users.nisplus nisplus -m -kname -vhome passwd.org_dir",
				sizeof buf);
			(void) makemapentry(buf);
		}
# endif /* NISPLUS */
# if NIS
		else if (strcmp(maptype[i], "nis") == 0 &&
		    stab("users.nis", ST_MAP, ST_FIND) == NULL)
		{
			(void) sm_strlcpy(buf, "users.nis nis -m passwd.byname",
				sizeof buf);
			(void) makemapentry(buf);
		}
# endif /* NIS */
# if HESIOD
		else if (strcmp(maptype[i], "hesiod") == 0 &&
			 stab("users.hesiod", ST_MAP, ST_FIND) == NULL)
		{
			(void) sm_strlcpy(buf, "users.hesiod hesiod", sizeof buf);
			(void) makemapentry(buf);
		}
# endif /* HESIOD */
d791 1
a791 1
	if (stab("users", ST_MAP, ST_FIND) == NULL)
d793 1
a793 1
		(void) sm_strlcpy(buf, "users switch -m passwd", sizeof buf);
a795 1
#endif /* 0 */
d797 1
d964 1
a964 1
					   sizeof buf) != NULL)
d1247 19
d1467 1
a1467 1
			       sizeof Nl[X_AVENRUN].n_name);
d1472 1
a1472 1
		if (knlist(Nl, 1, sizeof Nl[0]) < 0)
d1945 1
a1945 1
	r = read(afd, &avenrun, sizeof avenrun);
d2092 1
a2092 1
	(void) sm_snprintf(labuf, sizeof labuf, "%d", CurrentLA);
a2147 8
# if 0	/* this code is reported to cause oscillation around RefuseLA */
	if (CurrentLA >= RefuseLA && QueueLA < RefuseLA)
	{
		if (tTd(3, 30))
			sm_dprintf("TRUE (CurrentLA >= RefuseLA)\n");
		return true;
	}
# endif /* 0 */
d2153 1
a2157 1
**		name -- daemon name (for error messages only)
d2159 1
a2159 1
**		d -- number of daemon
d2172 1
a2172 2
refuseconnections(name, e, d, active)
	char *name;
d2174 1
a2174 1
	int d;
d2181 1
d2191 2
a2192 2
	SM_ASSERT(d >= 0);
	SM_ASSERT(d < MAXDAEMONS);
d2200 1
a2200 1
			if (now != lastconn[d])
d2202 2
a2203 2
				lastconn[d] = now;
				conncnt[d] = 1;
d2205 1
a2205 1
			else if (conncnt[d]++ > ConnRateThrottle)
d2210 2
a2211 1
						name, ConnRateThrottle);
d2214 2
a2215 1
						  name, ConnRateThrottle);
d2219 2
a2220 2
		else if (now != lastconn[d])
			conncnt[d] = 0;
d2230 1
a2230 1
		sm_setproctitle(true, e, R_MSG_LM, name, memfree);
d2232 2
a2233 1
			sm_syslog(LOG_NOTICE, NOQID, R_MSG_LM, name, memfree);
d2238 3
a2240 1
	if (RefuseLA > 0 && CurrentLA >= RefuseLA)
d2246 2
a2247 1
		sm_setproctitle(true, e, R_MSG_LA, name, CurrentLA);
d2249 2
a2250 1
			sm_syslog(LOG_NOTICE, NOQID, R_MSG_LA, name, CurrentLA);
d2252 1
a2252 1
		if (firstrejtime[d] == 0)
d2254 2
a2255 2
			firstrejtime[d] = now;
			nextlogtime[d] = now + RejectLogInterval;
d2257 1
a2257 1
		else if (nextlogtime[d] < now)
d2259 3
a2261 3
			sm_syslog(LOG_ERR, NOQID, R2_MSG_LA, name,
				  pintvl(now - firstrejtime[d], true));
			nextlogtime[d] = now + RejectLogInterval;
d2266 1
a2266 1
		firstrejtime[d] = 0;
d2268 3
a2270 1
	if (DelayLA > 0 && CurrentLA >= DelayLA)
d2278 1
a2278 1
		sm_setproctitle(true, e, D_MSG_LA, name, DelayLA);
d2282 1
a2282 1
				  name, CurrentLA, DelayLA);
d2288 3
a2290 1
	if (MaxChildren > 0 && CurChildren >= MaxChildren)
d2293 1
a2293 1
		if (CurChildren >= MaxChildren)
d2297 2
a2298 1
					name, CurChildren, MaxChildren);
d2301 2
a2302 1
					name, CurChildren, MaxChildren);
d2308 1
d2437 1
a2437 1
		environ = (char **) xalloc(sizeof (char *) * (i + 1));
d2606 1
a2606 1
	(void) sm_vsnprintf(buf, sizeof buf, fmt, ap);
d2616 1
a2616 1
		expand(ProcTitlePrefix, prefix, sizeof prefix, e);
d2834 1
a2834 1
				   buf, sizeof buf) != NULL)
d3208 1
a3208 1
	while (sm_io_fgets(shellf, SM_TIME_DEFAULT, buf, sizeof buf) != NULL)
d3280 1
a3280 1
	char *dir;
d3318 1
a3318 1
	if (statfs(dir, &fs, sizeof fs, 0) == 0)
d3525 1
a3525 1
	memset(&lfd, '\0', sizeof lfd);
d3990 1
a3990 1
		    e, RSF_RMCOMM|RSF_COUNT, 3, NULL, NOQID) != EX_OK)
d3999 1
a3999 1
			(void) sm_strlcpy(reject, MsgBuf, sizeof reject);
d4001 1
a4001 1
			(void) sm_strlcpy(reject, "Access denied", sizeof reject);
d4318 1
a4318 1
			if (strlen(name) > sizeof hbuf - 1)
d4323 1
a4323 1
			(void) sm_strlcpy(hbuf, name, sizeof hbuf);
d4375 1
a4375 1
							   buf6, sizeof buf6);
d4614 2
a4615 1
		if (sm_snprintf(hnb, sizeof hnb, "[%s]", hp->h_name) < sizeof hnb
d4633 2
a4634 2
			if (sm_snprintf(hnb, sizeof hnb,
				     "[%s]", *ha) < sizeof hnb &&
d4747 1
a4747 1
	len = lifc.lifc_len = numifs * sizeof (struct lifreq);
d4804 1
a4804 1
		if ((len - i) < sizeof *ifr)
d4808 2
a4809 2
		if (sa->sa.sa_len > sizeof ifr->lifr_addr)
			i += sizeof ifr->lifr_name + sa->sa.sa_len;
d4814 1
a4814 1
			i += sizeof ifr->ifr_name +
d4817 1
a4817 1
			i += sizeof *ifr;
d4871 1
a4871 1
				addr = anynet_ntop(&ia6, buf6, sizeof buf6);
d4878 1
a4878 1
			addr = anynet_ntop(&ia6, buf6, sizeof buf6);
d4880 1
a4880 1
				(void) sm_snprintf(ip_addr, sizeof ip_addr,
d4882 1
a4882 1
						   (int) sizeof ip_addr - 3,
d4897 2
a4898 2
			(void) sm_snprintf(ip_addr, sizeof ip_addr, "[%.*s]",
					(int) sizeof ip_addr - 3, inet_ntoa(ia));
d4954 1
a4954 1
	ifc.ifc_len = numifs * sizeof (struct ifreq);
d4993 1
a4993 1
		if ((ifc.ifc_len - i) < sizeof *ifr)
d4997 2
a4998 2
		if (sa->sa.sa_len > sizeof ifr->ifr_addr)
			i += sizeof ifr->ifr_name + sa->sa.sa_len;
d5001 1
a5001 1
			i += sizeof *ifr;
d5046 2
a5047 2
			(void) sm_snprintf(ip_addr, sizeof ip_addr, "[%.*s]",
					(int) sizeof ip_addr - 3,
d5070 1
a5070 1
				addr = anynet_ntop(&ia6, buf6, sizeof buf6);
d5078 1
a5078 1
			addr = anynet_ntop(&ia6, buf6, sizeof buf6);
d5080 1
a5080 1
				(void) sm_snprintf(ip_addr, sizeof ip_addr,
d5082 1
a5082 1
						   (int) sizeof ip_addr - 3,
d5161 1
a5161 1
	sz = (size_t) sizeof nproc;
d5337 1
a5337 1
	bufsize = sizeof buf0;
d5367 6
a5372 1
			syslog(level, "%s", newstring);
d5374 6
a5379 1
			syslog(level, "%s: %s", id, newstring);
d5431 4
a5434 1
		syslog(level, "%s[%d]: %s ...", id, seq++, begin);
d5443 1
d5445 6
a5450 2
		syslog(level, "%s[%d]: log terminated, too many parts",
			id, seq);
d5455 1
d5457 1
d5459 4
a5462 1
		syslog(level, "%s[%d]: %s", id, seq, begin);
d5467 1
d5506 1
a5506 1
	(void) sm_vsnprintf(buf, sizeof buf, msg, ap);
d5764 3
d5861 3
d5936 3
a6040 8
#if _FFR_BLOCK_PROXIES
	/*
	**  Try to deal with open HTTP proxies that are used to send spam
	**  by recognizing some commands from them.
	*/

	"_FFR_BLOCK_PROXIES",
#endif /* _FFR_BLOCK_PROXIES */
a6044 4
#if _FFR_CHECK_EOM
	/* Enable check_eom ruleset */
	"_FFR_CHECK_EOM",
#endif /* _FFR_CHECK_EOM */
a6052 4
#if _FFR_CONTROL_MSTAT
	/* Extended daemon status. */
	"_FFR_CONTROL_MSTAT",
#endif /* _FFR_CONTROL_MSTAT */
a6073 4
#if _FFR_DM_PER_DAEMON
	/* DeliveryMode per DaemonPortOptions: 'D' */
	"_FFR_DM_PER_DAEMON",
#endif /* _FFR_DM_PER_DAEMON */
a6078 12
#if _FFR_DNSMAP_BASE
	/* Specify a "base" domain for DNS lookups. */
	"_FFR_DNSMAP_BASE",
#endif /* _FFR_DNSMAP_BASE */
#if _FFR_DNSMAP_MULTI
	/* Allow multiple return values for DNS map. */
	"_FFR_DNSMAP_MULTI",
# if _FFR_DNSMAP_MULTILIMIT
	/* Limit number of return values for DNS map. */
	"_FFR_DNSMAP_MULTILIMIT",
# endif /* _FFR_DNSMAP_MULTILIMIT */
#endif /* _FFR_DNSMAP_MULTI */
d6096 4
d6104 13
a6132 4
#if _FFR_LOG_GREET_PAUSE
	/* log time for greet_pause delay; from Nik Clayton */
	"_FFR_LOG_GREET_PAUSE",
#endif /* _FFR_LOG_GREET_PAUSE */
a6145 8
#if _FFR_HDR_TYPE
	/* Set 'h' in {addr_type} for headers. */
	"_FFR_HDR_TYPE",
#endif /* _FFR_HDR_TYPE */
#if _FFR_HELONAME
	/* option to set heloname; Nik Clayton of FreeBSD */
	"_FFR_HELONAME",
#endif /* _FFR_HELONAME */
a6173 8
#if _FFR_MAXKEY
	/* increase key size for LDAP lookups, see conf.h */
	"_FFR_MAXKEY",
#endif /* _FFR_MAXKEY */
#if _FFR_MAXNOOPCOMMANDS
	/* runtime option for "MaxNOOPCommands" */
	"_FFR_MAXNOOPCOMMANDS",
#endif /* _FFR_MAXNOOPCOMMANDS */
d6182 18
a6199 10
#if _FFR_MILTER_NAGLE
	/* milter: turn off Nagle ("cork" on Linux) */
	/* John Gardiner Myers of Proofpoint */
	"_FFR_MILTER_NAGLE ",
#endif /* _FFR_MILTER_NAGLE */
#if _FFR_MILTER_NOHDR_RESP
	/* milter: no response expected when sending headers */
	/* John Gardiner Myers of Proofpoint */
	"_FFR_MILTER_NOHDR_RESP",
#endif /* _FFR_MILTER_NOHDR_RESP */
a6220 9
#if _FFR_PRIV_NOACTUALRECIPIENT
	/*
	**  PrivacyOptions=noactualrecipient stops sendmail from putting
	**  X-Actual-Recipient lines in DSNs revealing the actual
	**  account that addresses map to.  Patch from Dan Harkless.
	*/

	"_FFR_PRIV_NOACTUALRECIPIENT",
#endif /* _FFR_PRIV_NOACTUALRECIPIENT */
a6258 4
#if _FFR_SELECT_SHM
	/* Auto-select of shared memory key */
	"_FFR_SELECT_SHM",
#endif /* _FFR_SELECT_SHM */
a6289 4
#if _FFR_SOFT_BOUNCE
	/* Turn all errors into temporary errors. */
	"_FFR_SOFT_BOUNCE",
#endif /* _FFR_SOFT_BOUNCE */
@


1.27
log
@Update to sendmail 8.13.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.1081 2006/02/24 02:21:53 ca Exp $")
d2200 1
a2200 1
			sm_dprintf("true (memfree=%ld < QueueLowMem)\n",
@


1.26
log
@update to sendmail 8.13.4
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2005 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.1061 2005/03/07 17:18:44 ca Exp $")
d23 8
d355 1
d2186 3
d2193 12
d2253 3
d2292 13
d3776 1
a3776 1
#  include <sys/time.h>
d3838 7
d3936 2
a3937 2
	setuserenv("ISP", NULL);
	setuserenv("SYSTYPE", NULL);
d3951 1
a3951 1
		setuserenv("SOCK", p);
d4727 1
a4727 1
#  include <sys/time.h>
d4868 5
d4874 1
d5367 2
a5368 2
	static char *buf = NULL;
	static size_t bufsize;
d5392 2
a5393 5
	if (buf == NULL)
	{
		buf = buf0;
		bufsize = sizeof buf0;
	}
d5435 2
a5436 2
		if (buf == buf0)
			buf = NULL;
d5500 2
a5501 2
	if (buf == buf0)
		buf = NULL;
d5711 3
d6104 4
d6171 4
d6224 8
d6236 4
d6254 4
d6273 3
a6275 3
	** PrivacyOptions=noactualrecipient stops sendmail from putting 
	** X-Actual-Recipient lines in DSNs revealing the actual 
	** account that addresses map to.  Patch from Dan Harkless.
d6294 1
a6294 1
	/* Additional checks when doing queue runs. */
d6326 19
@


1.26.4.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@d5314 2
a5315 2
	char *buf;
	size_t bufsize;
d5339 5
a5343 2
	buf = buf0;
	bufsize = sizeof buf0;
d5385 2
a5386 2
		if (buf != buf0)
			sm_free(buf);
d5450 2
a5451 2
	if (buf != buf0)
		sm_free(buf);
@


1.26.2.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@d5314 2
a5315 2
	char *buf;
	size_t bufsize;
d5339 5
a5343 2
	buf = buf0;
	bufsize = sizeof buf0;
d5385 2
a5386 2
		if (buf != buf0)
			sm_free(buf);
d5450 2
a5451 2
	if (buf != buf0)
		sm_free(buf);
@


1.25
log
@update to sendmail 8.13.3
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.1052 2004/12/15 22:45:55 ca Exp $")
d1434 1
d1473 1
a1473 1
#if (LA_TYPE == LA_INT) || (LA_TYPE == LA_FLOAT) || (LA_TYPE == LA_SHORT)
d1507 4
a1510 1
#  else /* LA_TYPE == LA_SHORT */
d1512 1
d1578 1
a1578 1
# if (LA_TYPE == LA_INT) || (LA_TYPE == LA_SHORT)
d1586 5
d1594 1
d1602 1
a1602 1
# else /* (LA_TYPE == LA_INT) || (LA_TYPE == LA_SHORT) */
d1613 1
a1613 1
# endif /* (LA_TYPE == LA_INT) || (LA_TYPE == LA_SHORT) */
d1616 1
a1616 1
#endif /* (LA_TYPE == LA_INT) || (LA_TYPE == LA_FLOAT) || (LA_TYPE == LA_SHORT) */
d6056 4
d6190 4
d6201 1
a6201 1
	"_FFR_PRIV_NOACTUALRECIPIENT"
d6273 4
d6294 3
@


1.25.2.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@d5303 2
a5304 2
	char *buf;
	size_t bufsize;
d5328 5
a5332 2
	buf = buf0;
	bufsize = sizeof buf0;
d5374 2
a5375 2
		if (buf != buf0)
			sm_free(buf);
d5439 2
a5440 2
	if (buf != buf0)
		sm_free(buf);
@


1.24
log
@Update to sendmail-8.13.2
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.1051 2004/10/06 21:36:06 ca Exp $")
a6035 4
#if _FFR_DEAL_WITH_ERROR_SSL
	/* Deal with SSL errors by recognizing them as EOF. */
	"_FFR_DEAL_WITH_ERROR_SSL",
#endif /* _FFR_DEAL_WITH_ERROR_SSL */
@


1.23
log
@Update to sendmail-8.13.1
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.1047 2004/07/14 21:54:23 ca Exp $")
d38 6
d153 3
d6144 1
a6144 1
	"_FFR_MAXDATASIZE"
d6179 9
d6236 1
a6236 1
	"_FFR_SKIP_DOMAINS"
@


1.22
log
@Update to sendmail.8.13.0
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.1044 2004/06/11 21:38:16 ca Exp $")
d6019 4
d6111 4
d6127 10
@


1.21
log
@Update to sendmail 8.12.11.  I've been runninga beta version of this for
some time without problems.  See the RELEASE_NOTES for the change log.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.972.2.54 2004/01/08 21:54:55 ca Exp $")
d84 1
a262 1
#if _FFR_QUARANTINE
a263 1
#endif /* _FFR_QUARANTINE */
d340 1
a370 1
#if _FFR_REJECT_LOG
d372 1
a372 2
#endif /* _FFR_REJECT_LOG */
#if _FFR_REQ_DIR_FSYNC_OPT
d374 2
a375 1
#endif /* _FFR_REQ_DIR_FSYNC_OPT */
d642 7
a1500 1
	extern int errno;
a1607 1
	extern int errno;
d1835 6
d1870 2
a1871 1
	if (lseek(kmem, (sysmp(MP_KERNADDR, MPKA_AVENRUN) & 0x7fffffff), SEEK_SET) == -1 ||
a2206 1
#if _FFR_REJECT_LOG
a2208 1
#endif /* _FFR_REJECT_LOG */
d2215 2
a2247 1
# if _FFR_REJECT_LOG
a2249 2
#  define R2_MSG_LA "have been rejecting connections on daemon %s for %s"
# endif /* _FFR_REJECT_LOG */
d2251 1
a2254 1
# if _FFR_REJECT_LOG
a2266 1
# endif /* _FFR_REJECT_LOG */
a2268 1
# if _FFR_REJECT_LOG
a2270 1
# endif /* _FFR_REJECT_LOG */
d3978 1
d5166 74
d5621 3
d5726 3
d5750 3
a5771 3
#if ALLOW_255
	"ALLOW_255",
#endif /* ALLOW_255 */
d5793 3
d5802 3
a5981 5
#if _FFR_ADAPTIVE_EOL
	/* tries to be smart about \r\n versus \n from broken clients */
	/* known to be broken, do not use */
	"_FFR_ADAPTIVE_EOL",
#endif /* _FFR_ADAPTIVE_EOL */
d5984 1
a5984 1
	/* DefaultAuthInfo doesn't really work in 8.12 anymore. */
a5986 4
#if _FFR_ALLOW_S0_ERROR_4XX
	/* Allow for tempfail from S0 (ruleset 0). */
	"_FFR_ALLOW_S0_ERROR_4XX",
#endif /* _FFR_ALLOW_S0_ERROR_4XX */
a5998 5
#if _FFR_CACHE_LPC
	/* Cache connections to LCP based mailers */
/* Christophe Wolfhugel of France Telecom Oleane */
	"_FFR_CACHE_LPC",
#endif /* _FFR_CACHE_LPC */
a6002 4
#if _FFR_CATCH_LONG_STRINGS
	/* Report long address strings instead of silently ignoring them. */
	"_FFR_CATCH_LONG_STRINGS",
#endif /* _FFR_CATCH_LONG_STRINGS */
a6056 5
#if _FFR_DONT_STOP_LOOKING
	/* Continue with DNS lookups on ECONNREFUSED and TRY_AGAIN. */
/* Noted by Neil Rickert of Northern Illinois University */
	"_FFR_DONT_STOP_LOOKING",
#endif /* _FFR_DONT_STOP_LOOKING */
a6118 13
#if _FFR_LDAP_RECURSION
	/* Support LDAP recursion in LDAP responses */
/* Andrew Baucom */
	"_FFR_LDAP_RECURSION",
#endif /* _FFR_LDAP_RECURSION */
#if _FFR_LDAP_SETVERSION
	/* New LDAP map option for setting LDAP protocol version */
	"_FFR_LDAP_SETVERSION",
#endif /* _FFR_LDAP_SETVERSION */
#if _FFR_LDAP_URI
	/* Support LDAP URI form of specifying host/port (and allows ldaps) */
	"_FFR_LDAP_URI",
#endif /* _FFR_LDAP_URI */
d6129 14
a6142 18
#if _FFR_MESSAGEID_MACRO
	/* stick the message ID header's value in a macro */
	"_FFR_MESSAGEID_MACRO",
#endif /* _FFR_MESSAGEID_MACRO */
#if MILTER
# if _FFR_MILTER_421
	/* If a filter returns 421, close the SMTP connection */
	"_FFR_MILTER_421",
# endif /* _FFR_MILTER_421 */
# if _FFR_MILTER_MACROS_EOM
	/* Add an EOM macro set for milter */
	"_FFR_MILTER_MACROS_EOM",
# endif /* _FFR_MILTER_MACROS_EOM */
# if _FFR_MILTER_PERDAEMON
	/* Per DaemonPortOptions InputMailFilter lists */
	"_FFR_MILTER_PERDAEMON",
# endif /* _FFR_MILTER_PERDAEMON */
#endif /* MILTER */
a6151 4
#if _FFR_QUARANTINE
	/* Quarantine items in the queue */
	"_FFR_QUARANTINE",
#endif /* _FFR_QUARANTINE */
a6164 10
#if _FFR_QUEUERETURN_DSN
	/*
	**  Provide an option for different Timeout.queue{warn,return} for
	**  DSN messages.  These days, queues are filled with bounces for
	**  spam that will never make it to the sender and therefore slow
	**  down queue runs until they timeout.
	*/

	"_FFR_QUEUERETURN_DSN",
#endif /* _FFR_QUEUERETURN_DSN */
a6181 8
#if _FFR_REJECT_LOG
	/* Log when we start/stop rejecting connections due to load, etc */
	"_FFR_REJECT_LOG",
#endif /* _FFR_REJECT_LOG */
#if _FFR_REQ_DIR_FSYNC_OPT
	/* Add cf option to fsync() directories */
	"_FFR_REQ_DIR_FSYNC_OPT",
#endif /* _FFR_REQ_DIR_FSYNC_OPT */
a6185 4
#if _FFR_RESPOND_ALL
	/* in vacation: respond to every message, not just once per interval */
	"_FFR_RESPOND_ALL",
#endif /* _FFR_RESPOND_ALL */
a6189 4
#if _FFR_SASL_OPT_M
	/* Support SASL's SASL_SEC_MUTUAL_AUTH option */
	"_FFR_SASL_OPT_M",
#endif /* _FFR_SASL_OPT_M */
d6198 4
a6205 8
#if _FFR_SMFI_OPENSOCKET
	/* libmilter: smfi_opensocket() to force the socket open early */
	"_FFR_SMFI_OPENSOCKET",
#endif /* _FFR_SMFI_OPENSOCKET */
#if _FFR_SMTP_SSL
	/* Support for smtps (SMTP over SSL) */
	"_FFR_SMTP_SSL",
#endif /* _FFR_SMTP_SSL */
a6221 8
#if _FFR_STRIPBACKSL
	/*
	**  Strip backslash from addresses (so sender doesn't
	**  decide to ignore forward)
	*/

	"_FFR_STRIPBACKSL",
#endif /* _FFR_STRIPBACKSL */
@


1.20
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.972.2.50 2003/09/03 21:37:03 ca Exp $")
d5576 3
d6073 4
d6082 4
@


1.19
log
@Update to sendmail 8.12.9; fixes a buffer overflow in address parsing
due to a char to int conversion problem which is potentially remotely
exploitable.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.972.2.35 2003/03/28 05:46:09 ca Exp $")
d19 3
d471 13
d2246 1
a2246 1
#if _FFR_REJECT_LOG
d2259 1
a2259 1
#endif /* _FFR_REJECT_LOG */
d2262 1
a2262 1
#if _FFR_REJECT_LOG
d2265 1
a2265 1
#endif /* _FFR_REJECT_LOG */
d2447 2
a2448 2
#if _FFR_SPT_ALIGN
# ifdef SPT_ALIGN_SIZE
d2451 2
a2452 2
# endif /* SPT_ALIGN_SIZE */
#endif /* _FFR_SPT_ALIGN */
a2836 19
#  if 0
	/*
	**  Popen is known to have security holes.
	*/

	/* try uuname -l to return local name */
	if ((file = popen("uuname -l", "r")) != NULL)
	{
		(void) sm_io_fgets(file, SM_TIME_DEFAULT, name,
				   NODE_LENGTH + 1);
		(void) pclose(file);
		n = strchr(name, '\n');
		if (n != NULL)
			*n = '\0';
		if (name->nodename[0] != '\0')
			return 0;
	}
#  endif /* 0 */

d4735 1
a4735 1
#  endif /* __hpux */
d5680 3
d5934 4
d5998 4
d6039 4
d6066 4
d6075 1
a6075 1
# if  _FFR_MILTER_PERDAEMON
d6165 4
@


1.18
log
@Update to Sendmail 8.12.8; fixes a buffer overflow in the envelope
comments processing which may allow an attacker to gain root privileges.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.972.2.27 2003/01/15 19:17:14 ca Exp $")
d332 2
d3086 1
a3086 1
	"/sbin/sh"
d5888 2
d5893 2
d5898 1
d5902 1
d5905 8
d5914 1
d5919 1
d5923 1
d5927 1
d5931 1
d5935 1
d5939 1
d5943 1
d5947 1
d5951 1
d5956 1
d5961 1
d5965 1
d5968 1
d5973 1
d5976 2
a5977 1
# if _FFR_DONT_STOP_LOOKING
d5980 1
a5980 1
# endif /* _FFR_DONT_STOP_LOOKING */
d5982 1
d5986 6
d5995 5
d6003 1
d6007 1
d6011 1
d6015 5
d6024 1
d6028 1
d6032 1
d6036 1
d6041 1
d6045 1
d6049 2
d6056 1
d6060 1
d6065 1
d6070 1
d6074 1
d6078 1
d6082 1
d6087 1
d6090 10
d6101 1
d6105 1
d6109 6
d6118 1
d6122 1
d6126 1
d6130 1
a6130 1
	/* in vacation */
d6134 1
d6138 1
d6142 1
d6146 1
d6150 1
d6154 1
d6158 1
d6162 8
d6174 5
d6182 1
d6186 1
d6190 6
d6199 1
@


1.17
log
@update to sendmail 8.12.7
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.972.2.25 2002/12/12 21:19:29 ca Exp $")
@


1.16
log
@update to sendmail-8.12.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.972.2.5 2002/08/16 14:56:01 ca Exp $")
a30 1

d366 6
d2178 4
d2219 5
d2227 15
a2241 1
			sm_syslog(LOG_INFO, NOQID, R_MSG_LA, name, CurrentLA);
d2244 4
d3102 1
a3102 1
	"/sbin/bsh",		/* classic borne shell */
d3108 1
a3108 1
	"/sbin/jsh",		/* classic borne shell w/ job control*/
a3715 3
#ifndef FD_SETSIZE
# define FD_SETSIZE	256
#endif /* ! FD_SETSIZE */
d5919 3
d5995 3
a6005 4
#if _FFR_NONSTOP_PERSISTENCE
/* Suggested by Jan Krueger of digitalanswers communications consulting gmbh. */
	"_FFR_NONSTOP_PERSISTENCE",
#endif /* _FFR_NONSTOP_PERSISTENCE */
d6031 6
d6069 3
@


1.16.2.1
log
@Errata #14
Fix by millert@@
Fix a buffer overflow in address parsing due to a char to int conversion
problem which is potentially remotely exploitable.
@
text
@a332 2
	MaxMimeHeaderLength = MAXLINE;
	MaxMimeFieldLength = MaxMimeHeaderLength / 2;
@


1.15
log
@sendmail 8.12.5
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.972 2002/06/18 16:11:44 ca Exp $")
d2375 9
a2383 6
	for (i = 0; envp[i] != NULL; i++)
		continue;
	environ = (char **) xalloc(sizeof (char *) * (i + 1));
	for (i = 0; envp[i] != NULL; i++)
		environ[i] = newstr(envp[i]);
	environ[i] = NULL;
d2409 1
a2409 1
	for (i = 0; LastArgv != NULL && envp[i] != NULL; i++)
a2657 1
	int m = 0;
a2694 1
		CurRunners -= m; /* Update */
d3069 10
a3078 1
	"/sbin/csh",
d3082 2
a3083 1
	"/bin/tcsh",		/* Extended csh */
d3946 1
a3946 1
		    e, true, true, 3, NULL, NOQID) != EX_OK)
d5971 4
@


1.14
log
@Update to sendmail-8.12.4
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.969 2002/05/24 23:48:55 gshapiro Exp $")
d2341 1
a2341 1
#  define SPT_ALIGN(x, align)	((((x) + SPT_ALIGN_SIZE) >> (align)) << (align))
@


1.13
log
@update to sendmail 8.12.3
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.961 2002/04/04 21:32:14 gshapiro Exp $")
d2330 19
d2367 1
d2392 9
d2404 1
a2404 1
			LastArgv = argv[i] + strlen(argv[i]);
d2409 1
a2409 1
			LastArgv = envp[i] + strlen(envp[i]);
d2774 2
a2775 1
		while (sm_io_fgets(file, SM_TIME_DEFAULT, buf, MAXLINE) != NULL)
d5589 3
d5593 1
d5870 3
d5988 4
d5995 3
d6004 3
d6013 4
@


1.12
log
@#ifdef out useless test on OpenBSD.  f_bavail is a 32bit int and
so can never be > LONG_MAX.  This test is probably useless on most
other operating systems too but on our LP64 platforms it generates
a compiler warning.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.939 2002/01/09 17:26:28 gshapiro Exp $")
d527 5
d535 1
d3021 1
d3494 3
a3496 3
		int omode = -1;
#  ifdef F_GETFL
		(void) fcntl(fd, F_GETFL, &omode);
a3497 1
#  endif /* F_GETFL */
d3499 1
a3499 1
			filename, ext, fd, type, omode, geteuid());
d3524 3
a3526 3
		int omode = -1;
#  ifdef F_GETFL
		(void) fcntl(fd, F_GETFL, &omode);
a3527 1
#  endif /* F_GETFL */
d3529 1
a3529 1
			filename, ext, fd, type, omode, geteuid());
d5426 1
a5426 1
		if (writeln < 0)
d5585 3
d5817 3
d5830 3
d5845 8
d5865 4
d5887 4
d5901 1
d5904 6
d5932 4
d5939 3
d5954 3
d5975 4
@


1.12.2.1
log
@Errata #027 (millert)
Fix a buffer overflow in address parsing due to a char to int conversion
problem which is potentially remotely exploitable.
@
text
@a332 2
	MaxMimeHeaderLength = MAXLINE;
	MaxMimeFieldLength = MaxMimeHeaderLength / 2;
@


1.11
log
@update to sendmail-8.12.2
@
text
@d3249 1
d3252 1
@


1.10
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.914 2001/09/23 03:05:34 ca Exp $")
d670 1
a670 1
		    stab("hosts.dns", ST_MAP, ST_FIND) == NULL)
d678 1
a678 1
		    stab("hosts.nisplus", ST_MAP, ST_FIND) == NULL)
d687 1
a687 1
		    stab("hosts.nis", ST_MAP, ST_FIND) == NULL)
d695 2
a696 2
		else if (strcmp(maptype[i], "netinfo") == 0) &&
		    stab("hosts.netinfo", ST_MAP, ST_FIND) == NULL)
d732 1
a732 1
				sizeof buf);
d737 1
a737 1
		    stab("aliases.nisplus", ST_MAP, ST_FIND) == NULL)
d746 1
a746 1
		    stab("aliases.nis", ST_MAP, ST_FIND) == NULL)
d755 1
a755 1
		    stab("aliases.netinfo", ST_MAP, ST_FIND) == NULL)
d764 1
a764 1
		    stab("aliases.hesiod", ST_MAP, ST_FIND) == NULL)
d812 2
a813 2
		else if (strcmp(maptype[i], "hesiod") == 0) &&
		    stab("users.hesiod", ST_MAP, ST_FIND) == NULL)
d851 6
d1934 1
a1934 1
				_PATH_AVENRUN, strerror(errno));
d2544 1
a2544 5
# ifdef WAITUNION
	union wait st;
# else /* WAITUNION */
	auto int st;
# endif /* WAITUNION */
a2545 3
# if defined(ISC_UNIX) || defined(_SCO_unix_)
	int savesig;
# endif /* defined(ISC_UNIX) || defined(_SCO_unix_) */
d2550 1
a2550 8
# if defined(ISC_UNIX) || defined(_SCO_unix_)
		savesig = sm_releasesignal(SIGCHLD);
# endif /* defined(ISC_UNIX) || defined(_SCO_unix_) */
		i = wait(&st);
# if defined(ISC_UNIX) || defined(_SCO_unix_)
		if (savesig > 0)
			sm_blocksignal(SIGCHLD);
# endif /* defined(ISC_UNIX) || defined(_SCO_unix_) */
d2552 1
a2552 1
			(void) proc_list_drop(i, NULL, NULL);
a2555 3
# ifdef WAITUNION
	return st.w_status;
# else /* WAITUNION */
a2556 1
# endif /* WAITUNION */
a2620 1
	int pld, wgrp;
d2657 1
a2657 16
		pld = proc_list_drop(pid, &m, &wgrp);
		if (pld == PROC_CONTROL && WIFEXITED(st))
		{
			/* if so, see if we need to restart or shutdown */
			if (WEXITSTATUS(st) == EX_RESTART)
				RestartRequest = "control socket";
			else if (WEXITSTATUS(st) == EX_SHUTDOWN)
				ShutdownRequest = "control socket";
		}
		if (pld == PROC_QUEUE_CHILD && !WIFSTOPPED(st) && wgrp > -1)
		{
			/* restart this persistent runner */
			mark_work_group_restart(wgrp, st);
		}
		else if (pld == PROC_NONE)
			m = 0;
d2993 3
d2999 1
d3196 7
a3202 1
# if SFS_TYPE != SFS_NONE
a3253 1
# endif /* SFS_TYPE != SFS_NONE */
d3255 1
d3824 1
a3824 1
		finis(false, EX_USAGE);
d4439 1
a4439 1
		finis(false, EX_NOPERM);
d4590 18
d4610 3
d4614 1
d4616 1
a4616 1
	int numifs;
d4623 3
d4629 6
a4634 1
	if (ioctl(s, SIOCGLIFNUM, (char *)&lifn) < 0)
d4642 2
a4643 6
	else
	{
		numifs = lifn.lifn_count;
		if (tTd(0, 42))
			sm_dprintf("system has %d interfaces\n", numifs);
	}
d4645 1
a4645 1
#  endif /* SIOCGLIFNUM */
d4653 4
a4656 2
	lifc.lifc_len = numifs * sizeof (struct lifreq);
	lifc.lifc_buf = xalloc(lifc.lifc_len);
d4659 1
d4666 1
a4666 1
		sm_free(lifc.lifc_buf);
d4672 2
a4673 2
		sm_dprintf("scanning for interface specific names, lifc_len=%d\n",
			lifc.lifc_len);
d4675 1
a4675 1
	for (i = 0; i < lifc.lifc_len && i >= 0; )
d4677 2
a4678 1
		struct lifreq *ifr = (struct lifreq *)&lifc.lifc_buf[i];
d4680 1
d4682 1
a4689 1
		int af = ifr->lifr_addr.ss_family;
d4702 1
a4702 1
			sm_free(lifc.lifc_buf); /* XXX */
d4711 1
a4711 1
		if ((lifc.lifc_len - i) < sizeof *ifr)
d4730 1
a4730 1
			       sizeof(ifrf.lifr_name));
a4737 3
		else if (tTd(0, 41))
			sm_dprintf("\tflags: %lx\n",
				(unsigned long) ifrf.lifr_flags);
d4739 7
a4745 1
		if (!bitset(IFF_UP, ifrf.lifr_flags))
d4774 1
a4774 2
					ifr->lifr_name,
					addr == NULL ? "(NULL)" : addr);
d4793 1
a4793 1
					ifr->lifr_name, inet_ntoa(ia));
d4816 1
a4816 1
		    bitset(IFF_LOOPBACK, ifrf.lifr_flags))
d4821 1
a4821 1
	sm_free(lifc.lifc_buf); /* XXX */
d5353 106
d5639 3
d5645 3
d5711 3
d5765 6
d5811 1
d5841 6
d5862 3
d5868 3
d5872 1
d5881 1
a5907 3
#if _FFR_SAVE_CHARSET
	"_FFR_SAVE_CHARSET",
#endif /* _FFR_SAVE_CHARSET */
d5923 3
@


1.9
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: conf.c,v 8.907 2001/09/04 22:43:02 ca Exp $")
d219 1
a219 1
/*
d260 3
d394 1
a394 1
/*
d411 1
a411 1
/*
d433 1
a433 1
/*
d624 1
a624 1
/*
d827 1
a827 1
/*
d1106 1
a1106 1
/*
d1163 1
a1163 1
/*
d1217 1
a1217 1
/*
d1270 1
a1270 1
/*
d1333 1
a1333 1
/*
d1353 1
a1353 1
/*
d2060 1
a2060 1
/*
d2083 1
a2083 1
/*
d2134 1
a2134 1
/*
d2239 1
a2239 1
/*
d2471 1
a2471 1
/*
d2520 1
a2520 1
/*
d2570 1
a2570 1
/*
d2609 1
a2609 1
/*
d2632 2
a2633 1
	int m = 0, pld, wgrp;
d2692 1
a2692 1
/*
d2731 1
a2731 1
/*
d2800 1
a2800 1
/*
d2816 1
a2816 1
/*
d2833 1
a2833 1
/*
d2860 1
a2860 1
/*
d2878 1
a2878 1
/*
d2901 1
a2901 1
/*
d2992 1
a2992 1
/*
d3168 1
a3168 1
/*
d3275 1
a3275 1
/*
d3316 1
a3316 1
/*
d3421 1
a3421 1
/*
d3549 1
a3549 1
/*
d3636 1
a3636 1
/*
d3679 1
a3679 1
/*
d3726 1
a3726 1
/*
d3772 1
a3772 1
/*
d3827 1
a3827 1
/*
d3846 1
a3846 1
/*
d3875 1
a3875 1
/*
d3961 1
a3961 1
/*
d4064 1
a4064 1
/*
d4101 1
a4101 1
/*
d4366 1
a4366 1
/*
d4395 1
a4395 1
/*
d4461 1
a4461 1
/*
d4575 1
a4575 1
/*
d4998 1
a4998 1
/*
d5025 1
a5025 1
/*
d5068 1
a5068 1
/*
d5098 1
a5098 1
/*
d5263 1
a5263 1
/*
d5307 1
a5307 1
/*
d5338 1
a5338 1
/*
d5521 3
d5527 6
d5736 3
@


1.8
log
@update to sendmail 8.11.5
@
text
@d14 3
a16 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: conf.c,v 8.646.2.2.2.87 2001/07/20 23:56:52 gshapiro Exp $";
#endif /* ! lint */
a17 1
#include <sendmail.h>
d34 1
d82 1
d135 1
d150 1
d200 2
a201 4
#if _FFR_UNSAFE_SASL
	{ "groupreadablesaslfile",	DBS_GROUPREADABLESASLFILE	},
#endif /* _FFR_UNSAFE_SASL */
#if _FFR_UNSAFE_WRITABLE_INCLUDE
d206 5
a210 1
#endif /* _FFR_UNSAFE_WRITABLE_INCLUDE */
a213 1

d222 2
a223 2
**	Because of the way freezing is done, these must be initialized
**	using direct code.
a261 1
#if _FFR_QUEUE_FILE_MODE
a263 1
#endif /* _FFR_QUEUE_FILE_MODE */
d281 1
a281 1
		dprintf("setdefaults: DefUser=%s, DefUid=%d, DefGid=%d\n",
d288 4
a291 1
	e->e_queuedir = NOQDIR;
d293 1
a293 1
	SevenBitInput = FALSE;			/* option 7 */
d297 4
a300 1
	inittimeouts(NULL, FALSE);		/* option r */
d302 3
a304 3
	MeToo = TRUE;				/* option m */
	SendMIMEErrors = TRUE;			/* option f */
	SuperSafe = TRUE;			/* option s */
d325 3
a327 2
	ColonOkInAddr = TRUE;
	DontLockReadFiles = TRUE;
d331 1
d334 1
d336 3
d361 1
a361 1
#if _FFR_MILTER
d363 1
a363 1
#endif /* _FFR_MILTER */
d365 1
d383 4
a386 2
	snprintf(defuserbuf, sizeof defuserbuf, "%s",
		defpwent == NULL ? "nobody" : defpwent->pw_name);
d388 19
a406 2
		dprintf("setdefuser: DefUid=%d, DefUser=%s\n",
		       (int) DefUid, DefUser);
d417 2
a418 2
	(void) strlcpy(buf, "prog, P=/bin/sh, F=lsouDq9, T=X-Unix/X-Unix/X-Unix, A=sh -c \201u",
		sizeof buf);
d421 2
a422 2
	(void) strlcpy(buf, "*file*, P=[FILE], F=lsDFMPEouq9, T=X-Unix/X-Unix/X-Unix, A=FILE \201u",
		sizeof buf);
d425 2
a426 2
	(void) strlcpy(buf, "*include*, P=/dev/null, F=su, A=INCLUDE \201u",
		sizeof buf);
d457 1
a457 1
#ifdef NEWDB
d467 1
a467 1
#ifdef NDBM
d473 1
a473 1
#ifdef NIS
d479 1
a479 1
#ifdef NISPLUS
d485 2
a486 2
#ifdef LDAPMAP
	MAPDEF("ldap", NULL, MCF_ALIASOK,
a488 5

	/* Deprecated */
	MAPDEF("ldapx", NULL, MCF_ALIASOK,
		ldapx_map_parseargs, ldapmap_open, ldapmap_close,
		ldapmap_lookup, null_map_store);
d491 2
a492 2
#ifdef PH_MAP
	MAPDEF("ph", NULL, 0,
d504 1
a504 1
#ifdef HESIOD
d506 1
a506 1
		map_parseargs, hes_map_open, null_map_close,
d523 8
d563 1
a563 1
#ifdef MAP_REGEX
d661 1
a661 1
			(void) strlcpy(buf, "hosts.files text -k 0 -v 1 /etc/hosts",
d669 1
a669 1
			(void) strlcpy(buf, "hosts.dns dns A", sizeof buf);
d673 1
a673 1
# ifdef NISPLUS
d677 1
a677 1
			(void) strlcpy(buf, "hosts.nisplus nisplus -k name -v address hosts.org_dir",
d682 1
a682 1
# ifdef NIS
d686 1
a686 1
			(void) strlcpy(buf, "hosts.nis nis -k 0 -v 1 hosts.byname",
d695 1
a695 1
			(void) strlcpy(buf, "hosts.netinfo netinfo -v name /machines",
d710 1
a710 1
		(void) strlcpy(buf, "host host", sizeof buf);
d713 1
a713 1
			(void) strlcat(buf, " -a. -D", sizeof buf);
d728 2
a729 1
			(void) strlcpy(buf, "aliases.files null", sizeof buf);
d732 1
a732 1
#ifdef NISPLUS
d736 1
a736 1
			(void) strlcpy(buf, "aliases.nisplus nisplus -kalias -vexpansion mail_aliases.org_dir",
d741 1
a741 1
#ifdef NIS
d745 1
a745 1
			(void) strlcpy(buf, "aliases.nis nis mail.aliases",
d754 1
a754 1
			(void) strlcpy(buf, "aliases.netinfo netinfo -z, /aliases",
d759 1
a759 1
#ifdef HESIOD
d763 1
a763 1
			(void) strlcpy(buf, "aliases.hesiod hesiod aliases",
d771 1
a771 1
		(void) strlcpy(buf, "aliases switch aliases", sizeof buf);
d786 1
a786 1
			(void) strlcpy(buf, "users.files text -m -z: -k0 -v6 /etc/passwd",
d790 1
a790 1
# ifdef NISPLUS
d794 1
a794 1
			(void) strlcpy(buf, "users.nisplus nisplus -m -kname -vhome passwd.org_dir",
d799 1
a799 1
# ifdef NIS
d803 1
a803 1
			(void) strlcpy(buf, "users.nis nis -m passwd.byname",
d808 1
a808 1
# ifdef HESIOD
d812 1
a812 1
			(void) strlcpy(buf, "users.hesiod hesiod", sizeof buf);
d819 1
a819 1
		(void) strlcpy(buf, "users switch -m passwd", sizeof buf);
d960 1
d966 1
a966 1
	if ((now - ServiceCacheTime) > (time_t) ServiceCacheMaxAge)
d969 1
a969 1
		register FILE *fp;
d977 1
a977 1
			ServiceCacheTime = now;
d983 2
a984 1
			while (fgets(buf, sizeof buf, fp) != NULL)
d1019 1
a1019 1
					sm_free((void *) st->s_service[0]);
d1036 1
a1036 1
			(void) fclose(fp);
d1072 1
a1072 1
#  ifdef NISPLUS
d1075 1
a1075 1
#  ifdef NIS
d1134 1
a1134 1
				myname = newstr(pw->pw_name);
a1139 1
			myname = newstr(myname);
d1145 1
a1145 1
					myname = newstr(pw->pw_name);
d1153 4
a1157 1

d1248 1
a1248 1
		dprintf("checkcompat(to=%s, from=%s)\n",
a1267 248
**  SETSIGNAL -- set a signal handler
**
**	This is essentially old BSD "signal(3)".
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

sigfunc_t
setsignal(sig, handler)
	int sig;
	sigfunc_t handler;
{
# if defined(SA_RESTART) || (!defined(SYS5SIGNALS) && !defined(BSD4_3))
	struct sigaction n, o;
# endif /* defined(SA_RESTART) || (!defined(SYS5SIGNALS) && !defined(BSD4_3)) */

	/*
	**  First, try for modern signal calls
	**  and restartable syscalls
	*/

# ifdef SA_RESTART
	memset(&n, '\0', sizeof n);
#  if USE_SA_SIGACTION
	n.sa_sigaction = (void(*)(int, siginfo_t *, void *)) handler;
	n.sa_flags = SA_RESTART|SA_SIGINFO;
#  else /* USE_SA_SIGACTION */
	n.sa_handler = handler;
	n.sa_flags = SA_RESTART;
#  endif /* USE_SA_SIGACTION */
	if (sigaction(sig, &n, &o) < 0)
		return SIG_ERR;
	return o.sa_handler;
# else /* SA_RESTART */

	/*
	**  Else check for SYS5SIGNALS or
	**  BSD4_3 signals
	*/

#  if defined(SYS5SIGNALS) || defined(BSD4_3)
#   ifdef BSD4_3
	return signal(sig, handler);
#   else /* BSD4_3 */
	return sigset(sig, handler);
#   endif /* BSD4_3 */
#  else /* defined(SYS5SIGNALS) || defined(BSD4_3) */

	/*
	**  Finally, if nothing else is available,
	**  go for a default
	*/

	memset(&n, '\0', sizeof n);
	n.sa_handler = handler;
	if (sigaction(sig, &n, &o) < 0)
		return SIG_ERR;
	return o.sa_handler;
#  endif /* defined(SYS5SIGNALS) || defined(BSD4_3) */
# endif /* SA_RESTART */
}
/*
**  ALLSIGNALS -- act on all signals
**
**	Parameters:
**		block -- whether to block or release all signals.
**
**	Returns:
**		none.
*/

void
allsignals(block)
	bool block;
{
# ifdef BSD4_3
#  ifndef sigmask
#   define sigmask(s)	(1 << ((s) - 1))
#  endif /* ! sigmask */
	if (block)
	{
		int mask = 0;

		mask |= sigmask(SIGALRM);
		mask |= sigmask(SIGCHLD);
		mask |= sigmask(SIGHUP);
		mask |= sigmask(SIGINT);
		mask |= sigmask(SIGTERM);
		mask |= sigmask(SIGUSR1);

		(void) sigblock(mask);
	}
	else
		sigsetmask(0);
# else /* BSD4_3 */
#  ifdef ALTOS_SYSTEM_V
	if (block)
	{
		(void) sigset(SIGALRM, SIG_HOLD);
		(void) sigset(SIGCHLD, SIG_HOLD);
		(void) sigset(SIGHUP, SIG_HOLD);
		(void) sigset(SIGINT, SIG_HOLD);
		(void) sigset(SIGTERM, SIG_HOLD);
		(void) sigset(SIGUSR1, SIG_HOLD);
	}
	else
	{
		(void) sigset(SIGALRM, SIG_DFL);
		(void) sigset(SIGCHLD, SIG_DFL);
		(void) sigset(SIGHUP, SIG_DFL);
		(void) sigset(SIGINT, SIG_DFL);
		(void) sigset(SIGTERM, SIG_DFL);
		(void) sigset(SIGUSR1, SIG_DFL);
	}
#  else /* ALTOS_SYSTEM_V */
	sigset_t sset;

	(void) sigemptyset(&sset);
	(void) sigaddset(&sset, SIGALRM);
	(void) sigaddset(&sset, SIGCHLD);
	(void) sigaddset(&sset, SIGHUP);
	(void) sigaddset(&sset, SIGINT);
	(void) sigaddset(&sset, SIGTERM);
	(void) sigaddset(&sset, SIGUSR1);
	(void) sigprocmask(block ? SIG_BLOCK : SIG_UNBLOCK, &sset, NULL);
#  endif /* ALTOS_SYSTEM_V */
# endif /* BSD4_3 */
}
/*
**  BLOCKSIGNAL -- hold a signal to prevent delivery
**
**	Parameters:
**		sig -- the signal to block.
**
**	Returns:
**		1 signal was previously blocked
**		0 signal was not previously blocked
**		-1 on failure.
*/

int
blocksignal(sig)
	int sig;
{
# ifdef BSD4_3
#  ifndef sigmask
#   define sigmask(s)	(1 << ((s) - 1))
#  endif /* ! sigmask */
	return (sigblock(sigmask(sig)) & sigmask(sig)) != 0;
# else /* BSD4_3 */
#  ifdef ALTOS_SYSTEM_V
	sigfunc_t handler;

	handler = sigset(sig, SIG_HOLD);
	if (handler == SIG_ERR)
		return -1;
	else
		return handler == SIG_HOLD;
#  else /* ALTOS_SYSTEM_V */
	sigset_t sset, oset;

	(void) sigemptyset(&sset);
	(void) sigaddset(&sset, sig);
	if (sigprocmask(SIG_BLOCK, &sset, &oset) < 0)
		return -1;
	else
		return sigismember(&oset, sig);
#  endif /* ALTOS_SYSTEM_V */
# endif /* BSD4_3 */
}
/*
**  RELEASESIGNAL -- release a held signal
**
**	Parameters:
**		sig -- the signal to release.
**
**	Returns:
**		1 signal was previously blocked
**		0 signal was not previously blocked
**		-1 on failure.
*/

int
releasesignal(sig)
	int sig;
{
# ifdef BSD4_3
	return (sigsetmask(sigblock(0) & ~sigmask(sig)) & sigmask(sig)) != 0;
# else /* BSD4_3 */
#  ifdef ALTOS_SYSTEM_V
	sigfunc_t handler;

	handler = sigset(sig, SIG_HOLD);
	if (sigrelse(sig) < 0)
		return -1;
	else
		return handler == SIG_HOLD;
#  else /* ALTOS_SYSTEM_V */
	sigset_t sset, oset;

	(void) sigemptyset(&sset);
	(void) sigaddset(&sset, sig);
	if (sigprocmask(SIG_UNBLOCK, &sset, &oset) < 0)
		return -1;
	else
		return sigismember(&oset, sig);
#  endif /* ALTOS_SYSTEM_V */
# endif /* BSD4_3 */
}
/*
**  HOLDSIGS -- arrange to hold all signals
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Arranges that signals are held.
*/

void
holdsigs()
{
}
/*
**  RLSESIGS -- arrange to release all signals
**
**	This undoes the effect of holdsigs.
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Arranges that signals are released.
*/

void
rlsesigs()
{
}
/*
d1443 1
a1443 1
static int
d1446 1
d1463 1
a1463 1
		(void) strlcpy(Nl[X_AVENRUN].n_name, LA_AVENRUN,
d1475 2
a1476 2
				dprintf("getla: nlist(%s): %s\n", _PATH_UNIX,
					errstring(errno));
d1482 1
a1482 1
				dprintf("getla: nlist(%s, %s) ==> 0\n",
d1494 12
a1505 2
				dprintf("getla: open(/dev/kmem): %s\n",
					errstring(errno));
a1507 1
		(void) fcntl(kmem, F_SETFD, FD_CLOEXEC);
d1510 2
a1511 2
		dprintf("getla: symbol address = %#lx\n",
			(u_long) Nl[X_AVENRUN].n_value);
d1517 2
a1518 2
			dprintf("getla: lseek or read: %s\n",
				errstring(errno));
d1525 1
a1525 1
		dprintf("getla: avenrun = %d", avenrun[0]);
d1527 1
a1527 1
			dprintf(", %d, %d", avenrun[1], avenrun[2]);
d1529 1
a1529 1
		dprintf("getla: avenrun = %ld", avenrun[0]);
d1531 1
a1531 1
			dprintf(", %ld, %ld", avenrun[1], avenrun[2]);
d1533 1
a1533 1
		dprintf("\n");
d1536 1
a1536 1
		dprintf("getla: %d\n",
d1542 1
a1542 1
		dprintf("getla: avenrun = %g", avenrun[0]);
d1544 2
a1545 2
			dprintf(", %g, %g", avenrun[1], avenrun[2]);
		dprintf("\n");
d1548 1
a1548 1
		dprintf("getla: %d\n", (int) (avenrun[0] +0.5));
d1559 1
a1559 1
static int
d1562 1
d1574 12
a1585 2
				dprintf("getla: open(/dev/kmem): %s\n",
					errstring(errno));
a1587 1
		(void) fcntl(kmem, F_SETFD, FD_CLOEXEC);
d1595 2
a1596 2
			dprintf("getla: ioctl(MIOC_READKSYM) failed: %s\n",
				errstring(errno));
d1601 1
a1601 1
		dprintf("getla: avenrun = %d", avenrun[0]);
d1603 2
a1604 2
			dprintf(", %d, %d", avenrun[1], avenrun[2]);
		dprintf("\n");
d1607 1
a1607 1
		dprintf("getla: %d\n",
d1618 1
a1618 1
static int
d1627 1
a1627 1
		dprintf("getla: %d\n", (int) (load_info.one_minute + 0.5));
d1649 1
a1649 1
static int
d1659 1
a1659 1
		dprintf("getla: %d\n", (int) (pstd.psd_avg_1_min + 0.5));
d1668 1
a1668 1
static int
d1676 2
a1677 2
			dprintf("getla: getloadavg failed: %s",
				errstring(errno));
d1681 1
a1681 1
		dprintf("getla: %d\n", (int) (avenrun[0] +0.5));
d1699 1
a1699 1
static int
d1712 2
a1713 2
			dprintf("getla: processor_set_default failed: %s",
				errstring(errno));
d1722 2
a1723 2
			dprintf("getla: processor_set_info failed: %s",
				errstring(errno));
d1727 1
a1727 1
		dprintf("getla: %d\n",
d1736 6
d1755 1
a1755 1
static int
d1760 1
a1760 1
	FILE *fp;
d1762 2
a1763 1
	fp = fopen(_PATH_LOADAVG, "r");
d1767 2
a1768 2
			dprintf("getla: fopen(%s): %s\n",
				_PATH_LOADAVG, errstring(errno));
d1771 2
a1772 2
	result = fscanf(fp, "%lf", &avenrun);
	(void) fclose(fp);
d1776 2
a1777 2
			dprintf("getla: fscanf() = %d: %s\n",
				result, errstring(errno));
d1782 1
a1782 1
		dprintf("getla(): %.2f\n", avenrun);
d1793 2
a1794 1
int getla(void)
d1796 1
d1806 12
a1817 2
				dprintf("getla: open(%s): %s\n", _PATH_KMEM,
					errstring(errno));
a1819 1
		(void) fcntl(kmem, F_SETFD, FD_CLOEXEC);
d1823 1
a1823 1
	    read(kmem, (char *)avenrun, sizeof(avenrun)) < sizeof(avenrun))
d1826 2
a1827 2
			dprintf("getla: lseek or read: %s\n",
				errstring(errno));
d1832 1
a1832 1
		dprintf("getla: avenrun = %ld", (long int) avenrun[0]);
d1834 1
a1834 1
			dprintf(", %ld, %ld",
d1836 1
a1836 1
		dprintf("\n");
d1840 1
a1840 1
		dprintf("getla: %d\n",
d1851 1
a1851 1
static int
d1864 2
a1865 2
			dprintf("getla: kstat_open(): %s\n",
				errstring(errno));
d1873 2
a1874 2
			dprintf("getla: kstat_lookup(): %s\n",
				errstring(errno));
d1880 2
a1881 2
			dprintf("getla: kstat_read(): %s\n",
				errstring(errno));
d1885 1
a1885 1
	la = ((double)ksn->value.ul + FSCALE/2) / FSCALE;
d1906 1
a1906 1
static int
d1924 2
a1925 2
				"can't open %s: %m",
				_PATH_AVENRUN);
d1933 1
a1933 1
		dprintf("getla: avenrun = %d\n", avenrun);
d1936 1
a1936 1
		dprintf("getla: %d\n", loadav);
d1947 2
a1948 1
int getla()
d1956 1
a1956 1
			dprintf("getla: table %s\n", errstring(errno));
d1961 1
a1961 1
		dprintf("getla: scale = %d\n", tab.tl_lscale);
d1970 1
a1970 1
		dprintf("getla: %d\n", ave);
d1979 1
a1979 1
static int
d1988 2
a1989 2
			dprintf("getla: pset_getloadavg failed: %s",
				errstring(errno));
d1993 1
a1993 1
		dprintf("getla: %d\n", (int) (avenrun[0] +0.5));
d2001 1
a2001 1
static int
d2005 1
a2005 1
		dprintf("getla: ZERO\n");
d2036 1
a2036 1
static char  rcsid[] = "@@(#)$OrigId: getloadavg.c,v 1.16 1991/06/21 12:51:15 paul Exp $";
d2045 1
a2045 1
     caddr_t	call_data;	/* pointer to (double) return value */
d2047 8
a2054 7
     double *avenrun = (double *) call_data;
     int i;
     status_$t      st;
     long loadav[3];
     proc1_$get_loadav(loadav, &st);
     *avenrun = loadav[0] / (double) (1 << 16);
     return 0;
d2058 1
a2058 1
**  SM_GETLA -- get the current load average and set macro
d2061 1
a2061 1
**		e -- the envelope for the load average macro.
d2064 1
a2064 1
**		The current load average as an integer.
d2067 2
a2068 2
**		Sets the load average macro ({load_avg}) if
**		envelope e is not NULL.
d2071 2
a2072 3
int
sm_getla(e)
	ENVELOPE *e;
d2074 1
a2074 6
	register int la;

	la = getla();
	if (e != NULL)
	{
		char labuf[8];
d2076 3
a2078 4
		snprintf(labuf, sizeof labuf, "%d", la);
		define(macid("{load_avg}", NULL), newstr(labuf), e);
	}
	return la;
a2079 1

d2085 3
d2090 1
a2090 1
**		ct -- the message creation time.
d2093 1
a2093 1
**		TRUE -- if this message should be queued up for the
d2095 1
a2095 1
**		FALSE -- if the load is low enough to send this message.
d2110 1
a2110 1
		dprintf("shouldqueue: CurrentLA=%d, pri=%ld: ",
d2115 2
a2116 2
			dprintf("FALSE (CurrentLA < QueueLA)\n");
		return FALSE;
d2118 1
a2118 1
#if 0	/* this code is reported to cause oscillation around RefuseLA */
d2122 2
a2123 2
			dprintf("TRUE (CurrentLA >= RefuseLA)\n");
		return TRUE;
d2125 1
a2125 1
#endif /* 0 */
d2128 1
a2128 1
		dprintf("%s (by calculation)\n", rval ? "TRUE" : "FALSE");
d2138 1
d2141 1
a2141 1
**		TRUE if incoming SMTP connections should be refused
d2143 1
a2143 1
**		FALSE if we should accept new work.
d2150 1
a2150 1
refuseconnections(name, e, d)
d2154 1
d2156 4
a2159 1
#ifdef XLA
d2161 1
a2161 1
		return TRUE;
d2164 29
a2192 1
	CurrentLA = sm_getla(NULL);
d2195 23
a2217 7
		sm_setproctitle(TRUE, e, "rejecting connections on daemon %s: load average: %d",
				name, CurrentLA);
		if (LogLevel >= 9)
			sm_syslog(LOG_INFO, NOQID,
				"rejecting connections on daemon %s: load average: %d",
				name, CurrentLA);
		return TRUE;
d2225 2
a2226 1
			sm_setproctitle(TRUE, e, "rejecting connections on daemon %s: %d children, max %d",
d2228 2
a2229 3
			if (LogLevel >= 9)
				sm_syslog(LOG_INFO, NOQID,
					"rejecting connections on daemon %s: %d children, max %d",
d2231 1
a2231 1
			return TRUE;
d2234 1
a2234 2

	return FALSE;
d2332 1
a2332 1
	register int i, envpsize = 0;
d2341 1
a2341 1
		envpsize += strlen(envp[i]) + 1;
d2385 1
a2385 1
	VA_LOCAL_DECL
d2390 1
d2400 1
a2400 1
	(void) strlcpy(p, "sendmail: ", SPACELEFT(buf, p));
d2404 3
a2406 3
	VA_START(fmt);
	(void) vsnprintf(p, SPACELEFT(buf, p), fmt, ap);
	VA_END;
d2408 3
a2410 1
	i = strlen(buf);
d2424 1
a2424 1
	if (kmem < 0 || kmempid != getpid())
d2431 8
a2438 2
		(void) fcntl(kmem, F_SETFD, FD_CLOEXEC);
		kmempid = getpid();
d2454 1
a2454 1
	(void) strlcpy(Argv[0], buf, i + 1);
d2497 1
a2497 1
	VA_LOCAL_DECL
d2500 3
a2502 3
	VA_START(fmt);
	(void) vsnprintf(buf, sizeof buf, fmt, ap);
	VA_END;
d2505 1
a2505 1
		proc_list_set(getpid(), buf);
d2549 1
a2549 1
		savesig = releasesignal(SIGCHLD);
d2554 1
a2554 1
			blocksignal(SIGCHLD);
d2557 1
a2557 1
			(void) proc_list_drop(i);
d2568 39
d2629 1
a2635 7
# else /* HASWAITPID */
#  ifdef WNOHANG
	union wait status;
#  else /* WNOHANG */
	auto int status;
#  endif /* WNOHANG */
# endif /* HASWAITPID */
a2636 1
# if HASWAITPID
d2645 2
d2651 2
d2666 2
a2667 2
		if (proc_list_drop(pid) == PROC_CONTROL &&
		    WIFEXITED(st))
a2670 1
			{
a2671 1
			}
a2672 2
			{
				/* emulate a SIGTERM shutdown */
a2673 2
				/* NOTREACHED */
			}
d2675 8
a2688 143
**  PUTENV -- emulation of putenv() in terms of setenv()
**
**	Not needed on Posix-compliant systems.
**	This doesn't have full Posix semantics, but it's good enough
**		for sendmail.
**
**	Parameter:
**		env -- the environment to put.
**
**	Returns:
**		none.
*/

#if NEEDPUTENV

# if NEEDPUTENV == 2		/* no setenv(3) call available */

int
putenv(str)
	char *str;
{
	char **current;
	int matchlen, envlen = 0;
	char *tmp;
	char **newenv;
	static bool first = TRUE;
	extern char **environ;

	/*
	 * find out how much of str to match when searching
	 * for a string to replace.
	 */
	if ((tmp = strchr(str, '=')) == NULL || tmp == str)
		matchlen = strlen(str);
	else
		matchlen = (int) (tmp - str);
	++matchlen;

	/*
	 * Search for an existing string in the environment and find the
	 * length of environ.  If found, replace and exit.
	 */
	for (current = environ; *current; current++)
	{
		++envlen;

		if (strncmp(str, *current, matchlen) == 0)
		{
			/* found it, now insert the new version */
			*current = (char *)str;
			return 0;
		}
	}

	/*
	 * There wasn't already a slot so add space for a new slot.
	 * If this is our first time through, use malloc(), else realloc().
	 */
	if (first)
	{
		newenv = (char **) xalloc(sizeof(char *) * (envlen + 2));
		first = FALSE;
		(void) memcpy(newenv, environ, sizeof(char *) * envlen);
	}
	else
	{
		newenv = (char **) xrealloc((char *)environ,
					    sizeof(char *) * (envlen + 2));
	}

	/* actually add in the new entry */
	environ = newenv;
	environ[envlen] = (char *)str;
	environ[envlen + 1] = NULL;

	return 0;
}

# else /* NEEDPUTENV == 2 */

int
putenv(env)
	char *env;
{
	char *p;
	int l;
	char nbuf[100];

	p = strchr(env, '=');
	if (p == NULL)
		return 0;
	l = p - env;
	if (l > sizeof nbuf - 1)
		l = sizeof nbuf - 1;
	memmove(nbuf, env, l);
	nbuf[l] = '\0';
	return setenv(nbuf, ++p, 1);
}

# endif /* NEEDPUTENV == 2 */
#endif /* NEEDPUTENV */
/*
**  UNSETENV -- remove a variable from the environment
**
**	Not needed on newer systems.
**
**	Parameters:
**		name -- the string name of the environment variable to be
**			deleted from the current environment.
**
**	Returns:
**		none.
**
**	Globals:
**		environ -- a pointer to the current environment.
**
**	Side Effects:
**		Modifies environ.
*/

#if !HASUNSETENV

void
unsetenv(name)
	char *name;
{
	extern char **environ;
	register char **pp;
	int len = strlen(name);

	for (pp = environ; *pp != NULL; pp++)
	{
		if (strncmp(name, *pp, len) == 0 &&
		    ((*pp)[len] == '=' || (*pp)[len] == '\0'))
			break;
	}

	for (; *pp != NULL; pp++)
		*pp = pp[1];
}

#endif /* !HASUNSETENV */
/*
d2737 1
a2737 1
	FILE *file;
d2743 2
a2744 1
	if ((file = fopen("/etc/whoami", "r")) != NULL)
d2746 3
a2748 2
		(void) fgets(name->nodename, NODE_LENGTH + 1, file);
		(void) fclose(file);
d2757 3
a2759 1
	if ((file = fopen("/usr/include/whoami.h", "r")) != NULL)
d2763 1
a2763 1
		while (fgets(buf, MAXLINE, file) != NULL)
d2765 1
a2765 1
			if (sscanf(buf, "#define sysname \"%*[^\"]\"",
d2769 1
a2769 1
		(void) fclose(file);
d2782 2
a2783 1
		(void) fgets(name, NODE_LENGTH + 1, file);
d2851 1
a2851 1
	return setpgid(0, getpid());
d2901 1
a2901 1
#if NEEDGETOPT
d2920 2
a2921 2
 * get option letter from argument vector
 */
d2934 6
a2939 2
# define tell(s)	if (opterr) {fputs(*nargv,stderr);fputs(s,stderr); \
			fputc(optopt,stderr);fputc('\n',stderr);return(BADCH);}
d2984 1
a2984 1
	return(optopt);			/* dump back option letter */
d2987 1
a2987 42
#endif /* NEEDGETOPT */
/*
**  VFPRINTF, VSPRINTF -- for old 4.3 BSD systems missing a real version
*/

#if NEEDVPRINTF

# define MAXARG	16

vfprintf(fp, fmt, ap)
	FILE *fp;
	char *fmt;
	char **ap;
{
	char *bp[MAXARG];
	int i = 0;

	while (*ap && i < MAXARG)
		bp[i++] = *ap++;
	fprintf(fp, fmt, bp[0], bp[1], bp[2], bp[3],
			 bp[4], bp[5], bp[6], bp[7],
			 bp[8], bp[9], bp[10], bp[11],
			 bp[12], bp[13], bp[14], bp[15]);
}

vsprintf(s, fmt, ap)
	char *s;
	char *fmt;
	char **ap;
{
	char *bp[MAXARG];
	int i = 0;

	while (*ap && i < MAXARG)
		bp[i++] = *ap++;
	sprintf(s, fmt, bp[0], bp[1], bp[2], bp[3],
			bp[4], bp[5], bp[6], bp[7],
			bp[8], bp[9], bp[10], bp[11],
			bp[12], bp[13], bp[14], bp[15]);
}

#endif /* NEEDVPRINTF */
d2996 2
a2997 2
**		TRUE -- if it is ok to use this for unrestricted access.
**		FALSE -- if the shell is restricted.
d3076 1
a3076 1
		return TRUE;
d3088 1
a3088 1
	register FILE *shellf;
d3093 1
a3093 1
		return TRUE;
d3114 1
a3114 1
				return TRUE;
d3117 1
a3117 1
		return FALSE;
d3121 2
a3122 1
	shellf = fopen(_PATH_SHELLS, "r");
d3131 1
a3131 1
				  _PATH_SHELLS, errstring(errno));
d3136 1
a3136 1
				return TRUE;
d3138 1
a3138 1
		return FALSE;
d3141 1
a3141 1
	while (fgets(buf, sizeof buf, shellf) != NULL)
d3156 2
a3157 2
			(void) fclose(shellf);
			return TRUE;
d3160 2
a3161 2
	(void) fclose(shellf);
	return FALSE;
d3183 27
a3209 27
#define SFS_NONE	0	/* no statfs implementation */
#define SFS_USTAT	1	/* use ustat */
#define SFS_4ARGS	2	/* use four-argument statfs call */
#define SFS_VFS		3	/* use <sys/vfs.h> implementation */
#define SFS_MOUNT	4	/* use <sys/mount.h> implementation */
#define SFS_STATFS	5	/* use <sys/statfs.h> implementation */
#define SFS_STATVFS	6	/* use <sys/statvfs.h> implementation */

#ifndef SFS_TYPE
# define SFS_TYPE	SFS_NONE
#endif /* ! SFS_TYPE */

#if SFS_TYPE == SFS_USTAT
# include <ustat.h>
#endif /* SFS_TYPE == SFS_USTAT */
#if SFS_TYPE == SFS_4ARGS || SFS_TYPE == SFS_STATFS
# include <sys/statfs.h>
#endif /* SFS_TYPE == SFS_4ARGS || SFS_TYPE == SFS_STATFS */
#if SFS_TYPE == SFS_VFS
# include <sys/vfs.h>
#endif /* SFS_TYPE == SFS_VFS */
#if SFS_TYPE == SFS_MOUNT
# include <sys/mount.h>
#endif /* SFS_TYPE == SFS_MOUNT */
#if SFS_TYPE == SFS_STATVFS
# include <sys/statvfs.h>
#endif /* SFS_TYPE == SFS_STATVFS */
d3272 1
a3272 3
**  ENOUGHDISKSPACE -- is there enough free space on the queue fs?
**
**	Only implemented if you have statfs.
d3278 1
a3278 1
**		log -- log message?
d3281 7
a3287 2
**		TRUE if there is enough space.
**		FALSE otherwise.
d3291 1
a3291 1
enoughdiskspace(msize, log)
d3293 1
a3293 1
	bool log;
d3295 1
a3295 2
	long bfree;
	long bsize;
d3300 2
a3301 2
			dprintf("enoughdiskspace: no threshold\n");
		return TRUE;
d3304 2
a3305 2
	bfree = freediskspace(QueueDir, &bsize);
	if (bfree >= 0)
d3307 4
a3310 24
		if (tTd(4, 80))
			dprintf("enoughdiskspace: bavail=%ld, need=%ld\n",
				bfree, msize);

		/* convert msize to block count */
		msize = msize / bsize + 1;
		if (MinBlocksFree >= 0)
			msize += MinBlocksFree;

		if (bfree < msize)
		{
			if (log && LogLevel > 0)
				sm_syslog(LOG_ALERT, CurEnv->e_id,
					"low on space (have %ld, %s needs %ld in %s)",
					bfree,
					CurHostName == NULL ? "SMTP-DAEMON" : CurHostName,
					msize, QueueDir);
			return FALSE;
		}
	}
	else if (tTd(4, 80))
		dprintf("enoughdiskspace failure: min=%ld, need=%ld: %s\n",
			MinBlocksFree, msize, errstring(errno));
	return TRUE;
d3322 2
a3323 2
**		TRUE if this is probably transient.
**		FALSE otherwise.
a3339 1
#ifdef ETIMEDOUT
a3340 1
#endif /* ETIMEDOUT */
d3411 1
a3411 1
		return TRUE;
d3415 1
a3415 1
	return FALSE;
d3430 2
a3431 2
**		TRUE if the lock was acquired.
**		FALSE otherwise.
d3464 1
a3464 1
		dprintf("lockfile(%s%s, action=%d, type=%d): ",
d3472 2
a3473 2
			dprintf("SUCCESS\n");
		return TRUE;
d3478 1
a3478 1
		dprintf("(%s) ", errstring(save_errno));
d3492 2
a3493 2
			dprintf("SUCCESS\n");
		return TRUE;
d3506 1
a3506 1
		dumpfd(fd, TRUE, TRUE);
d3513 1
a3513 1
		dprintf("lockfile(%s%s, type=%o): ", filename, ext, type);
d3520 2
a3521 2
			dprintf("SUCCESS\n");
		return TRUE;
d3526 1
a3526 1
		dprintf("(%s) ", errstring(save_errno));
d3537 1
a3537 1
		dumpfd(fd, TRUE, TRUE);
d3541 1
a3541 1
		dprintf("FAIL\n");
d3543 1
a3543 1
	return FALSE;
d3593 1
a3593 1
**		TRUE -- if the chown(2) operation is "safe" -- that is,
d3595 1
a3595 1
**		FALSE -- if an arbitrary user can give away a file.
d3613 1
a3613 1
		return TRUE;
d3628 1
a3628 1
# else /* (!defined(_POSIX_CHOWN_RESTRICTED) || _POSIX_CHOWN_RESTRICTED != -1) && \ */
d3630 1
a3630 1
# endif /* (!defined(_POSIX_CHOWN_RESTRICTED) || _POSIX_CHOWN_RESTRICTED != -1) && \ */
a3675 25
**  GETCFNAME -- return the name of the .cf file.
**
**	Some systems (e.g., NeXT) determine this dynamically.
*/

char *
getcfname()
{

	if (ConfFile != NULL)
		return ConfFile;
#if NETINFO
	{
		char *cflocation;

		cflocation = ni_propval("/locations", NULL, "sendmail",
					"sendmail.cf", '\0');
		if (cflocation != NULL)
			return cflocation;
	}
#endif /* NETINFO */

	return _PATH_SENDMAILCF;
}
/*
d3682 2
a3683 2
**		TRUE -- if ok.
**		FALSE -- if vendor code could not be processed.
d3696 1
a3696 1
	if (strcasecmp(vendor, "Berkeley") == 0)
d3699 1
a3699 1
		return TRUE;
d3705 1
a3705 1
	if (strcasecmp(vendor, "Sun") == 0)
d3708 1
a3708 1
		return TRUE;
d3713 1
a3713 1
	if (strcasecmp(vendor, VENDOR_NAME) == 0)
d3716 1
a3716 1
		return TRUE;
d3720 1
a3720 1
	return FALSE;
d3749 2
a3750 2
		case VENDOR_BERKELEY:
			return "Berkeley";
d3752 2
a3753 2
		case VENDOR_SUN:
			return "Sun";
d3755 2
a3756 2
		case VENDOR_HP:
			return "HP";
d3758 2
a3759 2
		case VENDOR_IBM:
			return "IBM";
d3761 2
a3762 2
		case VENDOR_SENDMAIL:
			return "Sendmail";
d3764 2
a3765 2
		default:
			return "Unknown";
d3838 1
a3838 1
		finis(FALSE, EX_USAGE);
a3894 1
#if DAEMON
d3901 1
a3901 1
# if TCPWRAPPERS
d3903 3
a3905 1
# endif /* TCPWRAPPERS */
d3908 1
a3908 1
		dprintf("validate_connection(%s, %s)\n",
d3912 1
a3912 1
		    e, TRUE, TRUE, 4, NULL) != EX_OK)
d3918 1
a3918 1
			dprintf("  ... validate_connection: BAD (rscheck)\n");
d3921 1
a3921 1
			(void) strlcpy(reject, MsgBuf, sizeof reject);
d3923 1
a3923 1
			(void) strlcpy(reject, "Access denied", sizeof reject);
d3928 1
a3928 1
# if TCPWRAPPERS
d3933 9
a3941 1
	if (!hosts_ctl("sendmail", host, anynet_ntoa(sap), STRING_UNKNOWN))
d3944 2
a3945 2
			dprintf("  ... validate_connection: BAD (tcpwrappers)\n");
		if (LogLevel >= 4)
d3947 2
a3948 2
				"tcpwrappers (%s, %s) rejection",
				host, anynet_ntoa(sap));
d3951 1
a3951 1
# endif /* TCPWRAPPERS */
d3953 1
a3953 1
		dprintf("  ... validate_connection: OK\n");
a3956 1
#endif /* DAEMON */
d3972 5
a3976 5
 * Convert a string to a long integer.
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
d3991 4
a3994 4
	 * Skip white space and pick up leading +/- sign if any.
	 * If base is 0, allow 0x for hex and 0 for octal, else
	 * assume decimal; if base is already 16, allow 0x.
	 */
d4013 19
a4031 19
	 * Compute the cutoff value between legal numbers and illegal
	 * numbers.  That is the largest legal value, divided by the
	 * base.  An input number that is greater than this value, if
	 * followed by a legal input character, is too big.  One that
	 * is equal to this value may be valid or not; the limit
	 * between valid and invalid numbers is then based on the last
	 * digit.  For instance, if the range for longs is
	 * [-2147483648..2147483647] and the input base is 10,
	 * cutoff will be set to 214748364 and cutlim to either
	 * 7 (neg==0) or 8 (neg==1), meaning that if we have accumulated
	 * a value > 214748364, or equal but the next digit is > 7 (or 8),
	 * the number is too big, and we will return a range error.
	 *
	 * Set any if any `digits' consumed; make it negative to indicate
	 * overflow.
	 */
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
	cutlim = cutoff % (unsigned long)base;
	cutoff /= (unsigned long)base;
d4130 1
a4130 1
	bool resv6 = TRUE;
d4141 2
a4143 2
	if (family == AF_INET6 && !resv6)
		_res.options &= ~RES_USE_INET6;
a4161 1
# if _FFR_FREEHOSTENT
d4173 1
a4173 2
# endif /* _FFR_FREEHOSTENT */
#endif /* NEEDSGETIPNODE && NETINET6 */
d4189 1
a4189 1
		dprintf("_switch_gethostbyname_r(%s)... ", name);
d4196 1
a4196 1
		dprintf("__switch_gethostbyname(%s)... ", name);
d4211 1
a4211 1
		dprintf("sm_gethostbyname(%s, %d)... ", name, family);
d4227 1
a4227 1
			dprintf("failure\n");
d4240 1
a4240 1
			if (strlen(name) > (SIZE_T) sizeof hbuf - 1)
d4245 1
a4245 1
			(void) strlcpy(hbuf, name, sizeof hbuf);
d4252 1
a4252 1
					dprintf("sm_gethostbyname(%s, %d)... ",
d4270 1
a4270 1
			dprintf("failure\n");
d4273 1
a4273 1
			dprintf("%s\n", h->h_name);
d4282 1
a4282 1
				int i;
d4287 1
a4287 1
						dprintf("\talias: %s\n",
d4304 1
a4304 1
						dprintf("\taddr: %s\n", addr);
a4365 1

d4370 1
a4370 1
# ifdef _AIX4
d4374 1
a4374 1
# else /* _AIX4 */
d4376 1
a4376 1
# endif /* _AIX4 */
d4383 1
a4383 1
# if defined(_AIX4) && 0
d4387 1
a4387 1
# else /* defined(_AIX4) && 0 */
d4389 1
a4389 1
# endif /* defined(_AIX4) && 0 */
d4426 2
a4427 1
			syserr("No protected passwd entry, uid = %d", uid);
d4431 2
a4432 1
			syserr("Account has been disabled, uid = %d", uid);
d4436 2
a4437 1
			syserr("Account has been retired, uid = %d", uid);
d4441 1
a4441 1
			syserr("Could not set LUID, uid = %d", uid);
d4445 2
a4446 1
			syserr("Could not set kernel privs, uid = %d", uid);
d4450 1
a4450 1
				rc, uid);
d4453 1
a4453 1
		finis(FALSE, EX_NOPERM);
d4482 5
a4486 5
		case AF_INET:
			hp = sm_gethostbyaddr((char *) &sa->sin.sin_addr,
					      sizeof(sa->sin.sin_addr),
					      sa->sa.sa_family);
			break;
d4490 5
a4494 5
		case AF_INET6:
			hp = sm_gethostbyaddr((char *) &sa->sin6.sin6_addr,
					      sizeof(sa->sin6.sin6_addr),
					      sa->sa.sa_family);
			break;
d4497 7
a4503 7
		default:
			/* Give warning about unsupported family */
			if (LogLevel > 3)
				sm_syslog(LOG_WARNING, NOQID,
					  "Unsupported address family %d: %.100s",
					  sa->sa.sa_family, anynet_ntoa(sa));
			return -1;
d4515 1
a4515 1
		    TRUE)
d4517 2
a4518 2
				"gethostbyaddr(%.100s) failed: %d\n",
				anynet_ntoa(sa),
d4520 1
a4520 1
				h_errno
d4522 1
a4522 1
				-1
d4524 1
a4524 1
				);
d4534 1
a4534 1
			dprintf("\ta.k.a.: %s\n", hp->h_name);
d4536 1
a4536 1
		if (snprintf(hnb, sizeof hnb, "[%s]", hp->h_name) < sizeof hnb
d4543 1
a4543 1
			dprintf("\ta.k.a.: %s (already in $=w)\n", hp->h_name);
d4553 2
a4554 2
				dprintf("\ta.k.a.: %s\n", *ha);
			if (snprintf(hnb, sizeof hnb,
d4562 1
a4562 1
				dprintf("\ta.k.a.: %s (already in $=w)\n",
d4566 1
a4566 1
#if _FFR_FREEHOSTENT && NETINET6
d4568 1
a4568 1
#endif /* _FFR_FREEHOSTENT && NETINET6 */
d4603 1
a4603 1
#if NETINET6 && defined(SIOCGLIFCONF)
d4615 1
a4615 1
#   ifdef SIOCGLIFNUM
d4622 2
a4623 1
			dprintf("SIOCGLIFNUM failed: %s\n", errstring(errno));
d4630 1
a4630 1
			dprintf("system has %d interfaces\n", numifs);
d4633 1
a4633 1
#   endif /* SIOCGLIFNUM */
d4648 2
a4649 1
			dprintf("SIOCGLIFCONF failed: %s\n", errstring(errno));
d4657 1
a4657 1
		dprintf("scanning for interface specific names, lifc_len=%d\n",
d4660 1
a4660 1
	for (i = 0; i < lifc.lifc_len; )
d4667 1
a4667 1
#   ifdef SIOCGLIFFLAGS
d4669 1
a4669 1
#   endif /* SIOCGLIFFLAGS */
d4685 1
a4685 1
			sm_free(lifc.lifc_buf);
d4697 1
a4697 1
#   ifdef BSD4_4_SOCKADDR
d4701 1
a4701 1
#   endif /* BSD4_4_SOCKADDR */
d4705 1
a4705 1
			dprintf("%s\n", anynet_ntoa(sa));
d4710 1
a4710 1
#   ifdef SIOCGLIFFLAGS
d4712 1
a4712 1
		(void) strlcpy(ifrf.lifr_name, ifr->lifr_name,
d4717 2
a4718 2
				dprintf("SIOCGLIFFLAGS failed: %s\n",
					errstring(errno));
d4722 2
a4723 2
			dprintf("\tflags: %lx\n",
				(unsigned long)ifrf.lifr_flags);
d4727 1
a4727 1
#   endif /* SIOCGLIFFLAGS */
d4762 4
a4765 3
				(void) snprintf(ip_addr, sizeof ip_addr,
						"[%.*s]",
						(int) sizeof ip_addr - 3, addr);
d4779 1
a4779 1
			(void) snprintf(ip_addr, sizeof ip_addr, "[%.*s]",
d4791 1
a4791 1
				dprintf("\ta.k.a.: %s\n", ip_addr);
d4794 1
a4794 1
#   ifdef SIOCGLIFFLAGS
d4796 2
a4797 1
		if (bitset(IFF_LOOPBACK, ifrf.lifr_flags))
d4799 1
a4799 1
#   endif /* SIOCGLIFFLAGS */
d4802 1
a4802 1
	sm_free(lifc.lifc_buf);
d4804 2
a4805 2
#else /* NETINET6 && defined(SIOCGLIFCONF) */
# if defined(SIOCGIFCONF) && !SIOCGIFCONF_IS_BROKEN
d4816 1
a4816 1
#  if defined(SIOCGIFNUM) && !SIOCGIFNUM_IS_BROKEN
d4821 2
a4822 1
			dprintf("SIOCGIFNUM failed: %s\n", errstring(errno));
d4826 1
a4826 1
		dprintf("system has %d interfaces\n", numifs);
d4828 1
a4828 1
#  endif /* defined(SIOCGIFNUM) && !SIOCGIFNUM_IS_BROKEN */
d4841 2
a4842 1
			dprintf("SIOCGIFCONF failed: %s\n", errstring(errno));
a4843 1
		sm_free(ifc.ifc_buf);
d4849 1
a4849 1
		dprintf("scanning for interface specific names, ifc_len=%d\n",
d4852 1
a4852 1
	for (i = 0; i < ifc.ifc_len; )
d4886 1
a4886 1
			dprintf("%s\n", anynet_ntoa(sa));
d4898 1
a4898 1
		(void) strlcpy(ifrf.ifr_name, ifr->ifr_name,
d4902 1
a4902 1
			dprintf("\tflags: %lx\n",
d4928 1
a4928 1
			(void) snprintf(ip_addr, sizeof ip_addr, "[%.*s]",
d4962 4
a4965 3
				(void) snprintf(ip_addr, sizeof ip_addr,
						"[%.*s]",
						(int) sizeof ip_addr - 3, addr);
d4978 1
a4978 1
				dprintf("\ta.k.a.: %s\n", ip_addr);
d4982 2
a4983 1
		if (bitset(IFF_LOOPBACK, IFRFREF.ifr_flags))
d4988 1
a4988 1
	sm_free(ifc.ifc_buf);
d4990 3
a4992 3
#  undef IFRFREF
# endif /* defined(SIOCGIFCONF) && !SIOCGIFCONF_IS_BROKEN */
#endif /* NETINET6 && defined(SIOCGLIFCONF) */
d5001 2
a5002 2
**		TRUE -- is socket address in the loopback net?
**		FALSE -- otherwise
d5012 1
a5012 1
		return TRUE;
d5017 1
a5017 1
		return TRUE;
d5019 1
a5019 1
	return FALSE;
d5045 1
a5045 1
# endif /* defined(CTL_HW) && defined(HW_NCPUS) */
d5083 1
a5083 1
	seed = (long) getpid();
d5126 3
a5128 4
	extern int SnprfOverflow;
	extern int SyslogErrno;
	extern char *DoprEnd;
	VA_LOCAL_DECL
d5130 1
a5130 1
	save_errno = SyslogErrno = errno;
d5132 1
d5134 2
d5137 1
d5139 4
a5142 1
	idlen = strlen(id);
d5152 1
a5152 9
		/* do a virtual vsnprintf into buf */
		VA_START(fmt);
		buf[0] = 0;
		DoprEnd = buf + bufsize - 1;
		SnprfOverflow = 0;
		sm_dopr(buf, fmt, ap);
		*DoprEnd = '\0';
		VA_END;
		/* end of virtual vsnprintf */
d5154 6
a5159 1
		if (SnprfOverflow == 0)
d5163 1
a5163 1
		bufsize += SnprfOverflow + 1;
d5165 1
d5167 3
a5169 1
		buf = xalloc(bufsize * sizeof (char));
d5171 4
a5174 1
	if ((strlen(buf) + idlen + 1) < SYSLOG_BUFSIZE)
d5178 1
a5178 1
			syslog(level, "%s", buf);
d5180 1
a5180 1
			syslog(level, "%s: %s", id, buf);
d5184 2
a5185 1
			fprintf(stderr, "%s\n", buf);
d5187 2
a5188 1
			fprintf(stderr, "%s: %s\n", id, buf);
d5196 9
a5204 1
	begin = buf;
d5206 1
a5206 1
	       (strlen(begin) + idlen + 5) > SYSLOG_BUFSIZE)
d5210 1
a5210 1
		if (seq == 999)
d5215 1
a5215 1
		end = begin + SYSLOG_BUFSIZE - idlen - 12;
d5228 1
a5228 1
			end = begin + SYSLOG_BUFSIZE - idlen - 12;
d5234 2
a5235 1
		fprintf(stderr, "%s[%d]: %s ...\n", id, seq++, begin);
d5240 1
a5240 1
	if (seq == 999)
d5245 2
a5246 2
		fprintf(stderr, "%s[%d]: log terminated, too many parts\n",
			id, seq);
d5252 2
a5253 1
		fprintf(stderr, "%s[%d]: %s\n", id, seq, begin);
d5290 1
a5290 1
	VA_LOCAL_DECL;
d5292 3
a5294 3
	VA_START(msg);
	vsnprintf(buf, sizeof buf, msg, ap);
	VA_END;
d5318 1
a5318 1
	int len_host, len_domain;
d5325 1
a5325 1
	    (strcasecmp(hostname + len_host - len_domain,
d5340 5
d5348 1
a5348 1
#ifdef HESIOD
d5354 1
a5354 1
#ifdef LDAPMAP
d5357 4
a5360 1
#ifdef MAP_NSD
d5363 1
a5363 1
#ifdef MAP_REGEX
a5365 3
#if LOG
	"LOG",
#endif /* LOG */
d5369 3
d5381 1
a5381 1
#ifdef NDBM
d5405 1
a5405 1
#ifdef NEWDB
d5408 1
a5408 1
#ifdef NIS
d5411 1
a5411 1
#ifdef NISPLUS
d5414 4
a5417 1
#ifdef PH_MAP
d5420 6
a5425 3
#if QUEUE
	"QUEUE",
#endif /* QUEUE */
a5431 6
#if SFIO
	"SFIO",
#endif /* SFIO */
#if SMTP
	"SMTP",
#endif /* SMTP */
d5438 1
a5438 1
#ifdef SUID_ROOT_FILES_OK
d5444 6
d5456 1
a5456 1
#ifdef XLA
d5469 15
d5487 3
a5534 3
#if HASSNPRINTF
	"HASSNPRINTF",
#endif /* HASSNPRINTF */
d5571 15
d5589 3
d5628 3
d5634 125
@


1.7
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: conf.c,v 8.646.2.2.2.86 2001/05/17 18:18:40 ca Exp $";
d4545 1
a4545 3
				h = getipnodebyname(hbuf, family,
						    AI_V4MAPPED|AI_ALL,
						    &err);
@


1.6
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: conf.c,v 8.646.2.2.2.69 2001/02/27 19:50:11 gshapiro Exp $";
d979 1
a979 1
					free((void *) st->s_service[0]);
d1229 4
d1240 4
a1249 2
	struct sigaction n, o;

a1280 2
	struct sigaction n, o;

d1290 67
d2515 1
a2515 1
	static int kmempid = -1;
d2693 4
d2707 1
a2707 1
#if HASWAITPID
d2710 7
d2718 1
a2723 5
		{
			if (LogLevel > 0)
				sm_syslog(LOG_ALERT, NOQID,
					"reapchild: waitpid loop: pid=%d, status=%x",
					pid, status);
d2725 2
a2726 5
		}
#else /* HASWAITPID */
# ifdef WNOHANG
	union wait status;

d2730 1
a2730 3
# else /* WNOHANG */
	auto int status;

d2741 2
a2742 2
# endif /* WNOHANG */
#endif /* HASWAITPID */
d2750 1
a2750 3
				/* emulate a SIGHUP restart */
				sighup(0);
				/* NOTREACHED */
d2755 1
a2755 1
				intsig(0);
d2760 1
a2760 3
#ifdef SYS5SIGNALS
	(void) setsignal(SIGCHLD, reapchild);
#endif /* SYS5SIGNALS */
d2825 1
a2825 4
		newenv = (char **) malloc(sizeof(char *) * (envlen + 2));
		if (newenv == NULL)
			return -1;

d2831 2
a2832 3
		newenv = (char **) realloc((char *)environ, sizeof(char *) * (envlen + 2));
		if (newenv == NULL)
			return -1;
d4395 1
a4395 1
#if NETINET6 && NEEDSGETIPNODE && __RES < 19990909
d4462 1
a4462 1
#endif /* NEEDSGETIPNODE && NETINET6 && __RES < 19990909 */
d4650 1
a4651 1
#endif /* (SOLARIS > 10000 && SOLARIS < 20400) || (defined(SOLARIS) && SOLARIS < 204) */
d4937 1
a4937 1
		free(lifc.lifc_buf);
d4971 1
a4971 1
			free(lifc.lifc_buf);
d5086 1
a5086 1
	free(lifc.lifc_buf);
d5126 1
a5126 1
		free(ifc.ifc_buf);
d5269 1
a5269 1
	free(ifc.ifc_buf);
d5443 1
a5443 1
			free(buf);
d5600 3
@


1.6.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: conf.c,v 8.646.2.2.2.86 2001/05/17 18:18:40 ca Exp $";
d979 1
a979 1
					sm_free((void *) st->s_service[0]);
a1228 4
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
a1235 4
# if defined(SA_RESTART) || (!defined(SYS5SIGNALS) && !defined(BSD4_3))
	struct sigaction n, o;
# endif /* defined(SA_RESTART) || (!defined(SYS5SIGNALS) && !defined(BSD4_3)) */

d1242 2
d1275 2
a1285 67
**  ALLSIGNALS -- act on all signals
**
**	Parameters:
**		block -- whether to block or release all signals.
**
**	Returns:
**		none.
*/

void
allsignals(block)
	bool block;
{
# ifdef BSD4_3
#  ifndef sigmask
#   define sigmask(s)	(1 << ((s) - 1))
#  endif /* ! sigmask */
	if (block)
	{
		int mask = 0;

		mask |= sigmask(SIGALRM);
		mask |= sigmask(SIGCHLD);
		mask |= sigmask(SIGHUP);
		mask |= sigmask(SIGINT);
		mask |= sigmask(SIGTERM);
		mask |= sigmask(SIGUSR1);

		(void) sigblock(mask);
	}
	else
		sigsetmask(0);
# else /* BSD4_3 */
#  ifdef ALTOS_SYSTEM_V
	if (block)
	{
		(void) sigset(SIGALRM, SIG_HOLD);
		(void) sigset(SIGCHLD, SIG_HOLD);
		(void) sigset(SIGHUP, SIG_HOLD);
		(void) sigset(SIGINT, SIG_HOLD);
		(void) sigset(SIGTERM, SIG_HOLD);
		(void) sigset(SIGUSR1, SIG_HOLD);
	}
	else
	{
		(void) sigset(SIGALRM, SIG_DFL);
		(void) sigset(SIGCHLD, SIG_DFL);
		(void) sigset(SIGHUP, SIG_DFL);
		(void) sigset(SIGINT, SIG_DFL);
		(void) sigset(SIGTERM, SIG_DFL);
		(void) sigset(SIGUSR1, SIG_DFL);
	}
#  else /* ALTOS_SYSTEM_V */
	sigset_t sset;

	(void) sigemptyset(&sset);
	(void) sigaddset(&sset, SIGALRM);
	(void) sigaddset(&sset, SIGCHLD);
	(void) sigaddset(&sset, SIGHUP);
	(void) sigaddset(&sset, SIGINT);
	(void) sigaddset(&sset, SIGTERM);
	(void) sigaddset(&sset, SIGUSR1);
	(void) sigprocmask(block ? SIG_BLOCK : SIG_UNBLOCK, &sset, NULL);
#  endif /* ALTOS_SYSTEM_V */
# endif /* BSD4_3 */
}
/*
d2444 1
a2444 1
	static pid_t kmempid = -1;
a2621 4
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
d2632 1
a2632 1
# if HASWAITPID
a2634 7
# else /* HASWAITPID */
#  ifdef WNOHANG
	union wait status;
#  else /* WNOHANG */
	auto int status;
#  endif /* WNOHANG */
# endif /* HASWAITPID */
a2635 1
# if HASWAITPID
d2641 5
d2647 5
a2651 2
# else /* HASWAITPID */
#  ifdef WNOHANG
d2655 3
a2657 1
#  else /* WNOHANG */
d2668 2
a2669 2
#  endif /* WNOHANG */
# endif /* HASWAITPID */
d2677 3
a2679 1
				RestartRequest = "control socket";
d2684 1
a2684 1
				ShutdownRequest = "control socket";
d2689 3
a2691 1
	FIX_SYSV_SIGNAL(sig, reapchild);
d2756 4
a2759 1
		newenv = (char **) xalloc(sizeof(char *) * (envlen + 2));
d2765 3
a2767 2
		newenv = (char **) xrealloc((char *)environ,
					    sizeof(char *) * (envlen + 2));
d4330 1
a4330 1
#if NETINET6 && NEEDSGETIPNODE
d4397 1
a4397 1
#endif /* NEEDSGETIPNODE && NETINET6 */
d4585 1
a4586 1
	return hp;
d4872 1
a4872 1
		sm_free(lifc.lifc_buf);
d4906 1
a4906 1
			sm_free(lifc.lifc_buf);
d5021 1
a5021 1
	sm_free(lifc.lifc_buf);
d5061 1
a5061 1
		sm_free(ifc.ifc_buf);
d5204 1
a5204 1
	sm_free(ifc.ifc_buf);
d5378 1
a5378 1
			sm_free(buf);
a5534 3
#if EGD
	"EGD",
#endif /* EGD */
@


1.5
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: conf.c,v 8.646.2.2.2.61 2000/12/28 23:46:41 gshapiro Exp $";
d4361 1
a4361 1
	h_errno = 0;
d4378 1
a4378 1
	h_errno = 0;
d4404 1
d4415 1
d4422 1
a4429 1
	int save_errno;
d4442 1
a4442 1
	h_errno = err;
d4470 1
a4470 1
			shorten_hostname(hbuf);
d4483 1
a4483 1
				h_errno = err;
d4546 11
d4559 4
a4562 3
	static struct hostent he;
	static char buf[1000];
	extern struct hostent *_switch_gethostbyaddr_r();
d4564 3
a4566 1
	hp = _switch_gethostbyaddr_r(addr, len, type, &he, buf, sizeof(buf), &h_errno);
d4568 2
a4569 1
	extern struct hostent *__switch_gethostbyaddr();
d4571 2
a4572 1
	hp = __switch_gethostbyaddr(addr, len, type);
d4576 2
a4577 2
	int err;
# endif /* NETINET6 */
d4579 3
a4581 3
# if NETINET6
	hp = getipnodebyaddr(addr, len, type, &err);
	h_errno = err;
d4956 4
a4959 5
			ia6 = sa->sin6.sin6_addr;
#   ifdef __KAME__
			/* convert into proper scoped address - */
			if ((IN6_IS_ADDR_LINKLOCAL(&ia6) ||
			     IN6_IS_ADDR_SITELOCAL(&ia6)) &&
d4962 6
a4967 3
				sa->sin6.sin6_scope_id = ntohs(ia6.s6_addr[3] |
					((unsigned int) ia6.s6_addr[2] << 8));
				ia6.s6_addr[2] = ia6.s6_addr[3] = 0;
d4969 2
a4970 1
#   endif /* __KAME__ */
d5153 14
@


1.4
log
@Sendmail didn't buy back the arc4random() changes so just use
srandomdev() which seeds itself from arc4random().  Sendmail doesn't
really need crypto-strength random numbers.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: conf.c,v 8.646 2000/03/21 19:31:53 ca Exp $";
d20 4
a23 2
#include <sys/ioctl.h>
#include <sys/param.h>
d32 1
d196 1
d200 6
d383 1
a383 1
	(void) strlcpy(buf, "prog, P=/bin/sh, F=lsoDq9, T=X-Unix/X-Unix/X-Unix, A=sh -c \201u",
d828 1
a828 1
	int svcno;
d848 1
a848 1
	while (lk != NULL)
d885 1
a885 1
	for (svcno = 0; svcno < SVC_PATHSIZE; svcno++)
d1241 1
a1241 1
#ifdef SA_RESTART
d1245 1
a1245 1
# if USE_SA_SIGACTION
d1248 1
a1248 1
# else /* USE_SA_SIGACTION */
d1251 1
a1251 1
# endif /* USE_SA_SIGACTION */
d1255 1
a1255 1
#else /* SA_RESTART */
d1262 2
a1263 2
# if defined(SYS5SIGNALS) || defined(BSD4_3)
#  ifdef BSD4_3
d1265 1
a1265 1
#  else /* BSD4_3 */
d1267 2
a1268 2
#  endif /* BSD4_3 */
# else /* defined(SYS5SIGNALS) || defined(BSD4_3) */
d1282 2
a1283 2
# endif /* defined(SYS5SIGNALS) || defined(BSD4_3) */
#endif /* SA_RESTART */
d1301 4
a1304 4
#ifdef BSD4_3
# ifndef sigmask
#  define sigmask(s)	(1 << ((s) - 1))
# endif /* ! sigmask */
d1306 2
a1307 2
#else /* BSD4_3 */
# ifdef ALTOS_SYSTEM_V
d1315 1
a1315 1
# else /* ALTOS_SYSTEM_V */
d1324 2
a1325 2
# endif /* ALTOS_SYSTEM_V */
#endif /* BSD4_3 */
d1343 1
a1343 1
#ifdef BSD4_3
d1345 2
a1346 2
#else /* BSD4_3 */
# ifdef ALTOS_SYSTEM_V
d1354 1
a1354 1
# else /* ALTOS_SYSTEM_V */
d1363 2
a1364 2
# endif /* ALTOS_SYSTEM_V */
#endif /* BSD4_3 */
d1458 1
d1515 1
d2073 22
d2177 1
a2177 1
		snprintf(labuf, sizeof labuf, "%d", CurrentLA);
a2253 4
	time_t now;
	static time_t lastconn[MAXDAEMONS];
	static int conncnt[MAXDAEMONS];

d2259 1
a2259 19
	now = curtime();
	if (now != lastconn[d])
	{
		lastconn[d] = now;
		conncnt[d] = 0;
	}
	else if (conncnt[d]++ > ConnRateThrottle && ConnRateThrottle > 0)
	{
		/* sleep to flatten out connection load */
		sm_setproctitle(TRUE, e, "deferring connections on daemon %s: %d per second",
				name, ConnRateThrottle);
		if (LogLevel >= 9)
			sm_syslog(LOG_INFO, NOQID,
				"deferring connections on daemon %s: %d per second",
				name, ConnRateThrottle);
		(void) sleep(1);
	}

	CurrentLA = getla();
d2316 1
d2476 1
a2476 1
			close(kmem);
d2578 1
a2578 1
#ifdef WAITUNION
d2580 1
a2580 1
#else /* WAITUNION */
d2582 1
a2582 1
#endif /* WAITUNION */
d2584 1
a2584 1
#if defined(ISC_UNIX) || defined(_SCO_unix_)
d2586 1
a2586 1
#endif /* defined(ISC_UNIX) || defined(_SCO_unix_) */
d2591 1
a2591 1
#if defined(ISC_UNIX) || defined(_SCO_unix_)
d2593 1
a2593 1
#endif /* defined(ISC_UNIX) || defined(_SCO_unix_) */
d2595 1
a2595 1
#if defined(ISC_UNIX) || defined(_SCO_unix_)
d2598 1
a2598 1
#endif /* defined(ISC_UNIX) || defined(_SCO_unix_) */
d2604 1
a2604 1
#ifdef WAITUNION
d2606 1
a2606 1
#else /* WAITUNION */
d2608 1
a2608 1
#endif /* WAITUNION */
d2864 1
a2864 1
#ifdef RLIMIT_NOFILE
d2869 1
a2869 1
#endif /* RLIMIT_NOFILE */
d2871 1
a2871 1
#if HASGETDTABLESIZE
d2873 2
a2874 2
#else /* HASGETDTABLESIZE */
# ifdef _SC_OPEN_MAX
d2876 1
a2876 1
# else /* _SC_OPEN_MAX */
d2878 2
a2879 2
# endif /* _SC_OPEN_MAX */
#endif /* HASGETDTABLESIZE */
d2924 1
a2924 1
# if 0
d2940 1
a2940 1
# endif /* 0 */
d2987 1
a2987 1
# ifdef TIOCNOTTY
d2993 1
a2993 1
		(void) ioctl(fd, (int) TIOCNOTTY, (char *) 0);
d2996 2
a2997 2
# endif /* TIOCNOTTY */
# ifdef SYS5SETPGRP
d2999 1
a2999 1
# else /* SYS5SETPGRP */
d3001 1
a3001 1
# endif /* SYS5SETPGRP */
d3256 1
a3256 1
#if HASGETUSERSHELL
d3270 2
a3271 2
#else /* HASGETUSERSHELL */
# if USEGETCONFATTR
d3273 1
a3273 1
# endif /* USEGETCONFATTR */
d3281 1
a3281 1
# if USEGETCONFATTR
d3305 1
a3305 1
# endif /* USEGETCONFATTR */
d3347 1
a3347 1
#endif /* HASGETUSERSHELL */
d3360 1
a3360 1
**		The number of bytes free on the queue filesystem.
d3401 2
a3402 2
#if SFS_TYPE != SFS_NONE
# if SFS_TYPE == SFS_USTAT
d3405 4
a3408 4
#  define FSBLOCKSIZE	DEV_BSIZE
#  define SFS_BAVAIL	f_tfree
# else /* SFS_TYPE == SFS_USTAT */
#  if defined(ultrix)
d3410 4
a3413 4
#   define SFS_BAVAIL	fd_bfreen
#   define FSBLOCKSIZE	1024L
#  else /* defined(ultrix) */
#   if SFS_TYPE == SFS_STATVFS
d3415 2
a3416 2
#    define FSBLOCKSIZE	fs.f_frsize
#   else /* SFS_TYPE == SFS_STATVFS */
d3418 7
a3424 7
#    define FSBLOCKSIZE	fs.f_bsize
#   endif /* SFS_TYPE == SFS_STATVFS */
#  endif /* defined(ultrix) */
# endif /* SFS_TYPE == SFS_USTAT */
# ifndef SFS_BAVAIL
#  define SFS_BAVAIL f_bavail
# endif /* ! SFS_BAVAIL */
d3426 1
a3426 1
# if SFS_TYPE == SFS_USTAT
d3428 2
a3429 2
# else /* SFS_TYPE == SFS_USTAT */
#  if SFS_TYPE == SFS_4ARGS
d3431 2
a3432 2
#  else /* SFS_TYPE == SFS_4ARGS */
#   if SFS_TYPE == SFS_STATVFS
d3434 2
a3435 2
#   else /* SFS_TYPE == SFS_STATVFS */
#    if defined(ultrix)
d3437 1
a3437 1
#    else /* defined(ultrix) */
d3439 4
a3442 4
#    endif /* defined(ultrix) */
#   endif /* SFS_TYPE == SFS_STATVFS */
#  endif /* SFS_TYPE == SFS_4ARGS */
# endif /* SFS_TYPE == SFS_USTAT */
d3453 1
a3453 1
#endif /* SFS_TYPE != SFS_NONE */
d3477 2
a3478 1
	long bfree, bsize;
d3487 2
a3488 1
	if ((bfree = freediskspace(QueueDir, &bsize)) >= 0)
d3632 1
d3648 1
a3648 1
#if !HASFLOCK
d3705 1
a3705 1
# ifdef F_GETFL
d3708 1
a3708 1
# endif /* F_GETFL */
d3713 1
a3713 1
#else /* !HASFLOCK */
d3736 1
a3736 1
# ifdef F_GETFL
d3739 1
a3739 1
# endif /* F_GETFL */
d3744 1
a3744 1
#endif /* !HASFLOCK */
d3812 1
a3812 1
#if (!defined(_POSIX_CHOWN_RESTRICTED) || _POSIX_CHOWN_RESTRICTED != -1) && \
d3828 1
a3828 1
# if SAFENFSPATHCONF
d3830 1
a3830 1
# else /* SAFENFSPATHCONF */
d3832 2
a3833 2
# endif /* SAFENFSPATHCONF */
#else /* (!defined(_POSIX_CHOWN_RESTRICTED) || _POSIX_CHOWN_RESTRICTED != -1) && \ */
d3835 1
a3835 1
#endif /* (!defined(_POSIX_CHOWN_RESTRICTED) || _POSIX_CHOWN_RESTRICTED != -1) && \ */
d4140 2
a4141 2
	if (rscheck("check_relay", hostname, anynet_ntoa(sap), e, TRUE, TRUE, 4)
	    != EX_OK)
d4149 2
a4150 16
		if (strlen(MsgBuf) > 5)
		{
			if (ISSMTPCODE(MsgBuf))
			{
				int off;

				if ((off = isenhsc(MsgBuf + 4, ' ')) > 0)
					off += 5;
				else
					off = 4;
				(void) strlcpy(reject, &MsgBuf[off],
					       sizeof reject);
			}
			else
				(void) strlcpy(reject, MsgBuf, sizeof reject);
		}
d4332 6
d4383 14
d4424 1
d4436 4
a4439 1
	h = getipnodebyname(name, family, AI_V4MAPPED|AI_ALL, &err);
d4453 1
d4457 2
d4689 2
a4690 1
				sizeof(sa->sin.sin_addr), sa->sa.sa_family);
d4697 2
a4698 1
				sizeof(sa->sin6.sin6_addr), sa->sa.sa_family);
d4771 3
d4820 1
a4820 1
# ifdef SIOCGLIFNUM
d4837 1
a4837 1
# endif /* SIOCGLIFNUM */
d4842 1
a4842 1
		close(s);
d4853 2
a4854 1
		close(s);
d4870 1
a4870 1
# ifdef SIOCGLIFFLAGS
d4872 1
a4872 1
# endif /* SIOCGLIFFLAGS */
d4887 2
d4890 1
d4900 1
a4900 1
# ifdef BSD4_4_SOCKADDR
d4904 1
a4904 1
# endif /* BSD4_4_SOCKADDR */
d4913 1
a4913 1
# ifdef SIOCGLIFFLAGS
d4930 1
a4930 1
# endif /* SIOCGLIFFLAGS */
d4939 12
a4950 1
			if (ia6.s6_addr == in6addr_any.s6_addr)
d4964 1
a4964 1
						sizeof ip_addr - 3, addr);
d4979 1
a4979 1
					sizeof ip_addr - 3, inet_ntoa(ia));
d4993 1
a4993 1
# ifdef SIOCGLIFFLAGS
d4997 1
a4997 1
# endif /* SIOCGLIFFLAGS */
d5001 1
a5001 1
	close(s);
d5040 1
d5051 1
d5054 4
d5059 1
a5059 1
#  ifdef SIOCGIFFLAGS
d5061 1
a5061 1
#  endif /* SIOCGIFFLAGS */
d5063 3
d5075 1
a5075 1
#  ifdef BSD4_4_SOCKADDR
d5079 1
a5079 1
#  endif /* BSD4_4_SOCKADDR */
d5085 6
a5090 1
		if (ifr->ifr_addr.sa_family != AF_INET)
d5093 1
a5093 1
#  ifdef SIOCGIFFLAGS
d5101 5
a5105 4
#   define IFRFREF ifrf
#  else /* SIOCGIFFLAGS */
#   define IFRFREF (*ifr)
#  endif /* SIOCGIFFLAGS */
d5109 2
d5112 1
a5112 2
		ia = sa->sin.sin_addr;
		if (ia.s_addr == INADDR_ANY || ia.s_addr == INADDR_NONE)
d5114 37
a5150 3
			message("WARNING: interface %s is UP with %s address",
				ifr->ifr_name, inet_ntoa(ia));
			continue;
d5153 2
a5154 3
		/* save IP address in text from */
		(void) snprintf(ip_addr, sizeof ip_addr, "[%.*s]",
				(int) sizeof ip_addr - 3, inet_ntoa(ia));
d5231 7
a5237 3
#  ifdef MPC_GETNUMSPUS
	nproc = mpctl(MPC_GETNUMSPUS, 0, 0);
#  endif /* MPC_GETNUMSPUS */
d5303 1
d5312 1
a5312 1
	SyslogErrno = errno;
d5362 1
d5417 1
d5575 3
d5584 3
d5669 3
d5720 6
d5743 1
@


1.4.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: conf.c,v 8.646.2.2.2.86 2001/05/17 18:18:40 ca Exp $";
d20 2
a21 4

# include <sys/ioctl.h>
# include <sys/param.h>

a29 1

a192 1
	{ "insufficiententropy",	DBS_INSUFFICIENTENTROPY },
a195 6
#if _FFR_UNSAFE_WRITABLE_INCLUDE
	{ "groupwritableforwardfile",	DBS_GROUPWRITABLEFORWARDFILE	},
	{ "groupwritableincludefile",	DBS_GROUPWRITABLEINCLUDEFILE	},
	{ "worldwritableforwardfile",	DBS_WORLDWRITABLEFORWARDFILE	},
	{ "worldwritableincludefile",	DBS_WORLDWRITABLEINCLUDEFILE	},
#endif /* _FFR_UNSAFE_WRITABLE_INCLUDE */
d373 1
a373 1
	(void) strlcpy(buf, "prog, P=/bin/sh, F=lsouDq9, T=X-Unix/X-Unix/X-Unix, A=sh -c \201u",
d818 1
a818 1
	int svcno = 0;
d838 1
a838 1
	while (lk != NULL && svcno < MAXMAPSTACK)
d875 1
a875 1
	for (svcno = 0; svcno < SVC_PATHSIZE && svcno < MAXMAPSTACK; svcno++)
d969 1
a969 1
					sm_free((void *) st->s_service[0]);
a1218 4
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
a1225 4
# if defined(SA_RESTART) || (!defined(SYS5SIGNALS) && !defined(BSD4_3))
	struct sigaction n, o;
# endif /* defined(SA_RESTART) || (!defined(SYS5SIGNALS) && !defined(BSD4_3)) */

d1231 3
a1233 1
# ifdef SA_RESTART
d1235 1
a1235 1
#  if USE_SA_SIGACTION
d1238 1
a1238 1
#  else /* USE_SA_SIGACTION */
d1241 1
a1241 1
#  endif /* USE_SA_SIGACTION */
d1245 1
a1245 1
# else /* SA_RESTART */
d1252 2
a1253 2
#  if defined(SYS5SIGNALS) || defined(BSD4_3)
#   ifdef BSD4_3
d1255 1
a1255 1
#   else /* BSD4_3 */
d1257 2
a1258 2
#   endif /* BSD4_3 */
#  else /* defined(SYS5SIGNALS) || defined(BSD4_3) */
d1265 2
d1272 2
a1273 69
#  endif /* defined(SYS5SIGNALS) || defined(BSD4_3) */
# endif /* SA_RESTART */
}
/*
**  ALLSIGNALS -- act on all signals
**
**	Parameters:
**		block -- whether to block or release all signals.
**
**	Returns:
**		none.
*/

void
allsignals(block)
	bool block;
{
# ifdef BSD4_3
#  ifndef sigmask
#   define sigmask(s)	(1 << ((s) - 1))
#  endif /* ! sigmask */
	if (block)
	{
		int mask = 0;

		mask |= sigmask(SIGALRM);
		mask |= sigmask(SIGCHLD);
		mask |= sigmask(SIGHUP);
		mask |= sigmask(SIGINT);
		mask |= sigmask(SIGTERM);
		mask |= sigmask(SIGUSR1);

		(void) sigblock(mask);
	}
	else
		sigsetmask(0);
# else /* BSD4_3 */
#  ifdef ALTOS_SYSTEM_V
	if (block)
	{
		(void) sigset(SIGALRM, SIG_HOLD);
		(void) sigset(SIGCHLD, SIG_HOLD);
		(void) sigset(SIGHUP, SIG_HOLD);
		(void) sigset(SIGINT, SIG_HOLD);
		(void) sigset(SIGTERM, SIG_HOLD);
		(void) sigset(SIGUSR1, SIG_HOLD);
	}
	else
	{
		(void) sigset(SIGALRM, SIG_DFL);
		(void) sigset(SIGCHLD, SIG_DFL);
		(void) sigset(SIGHUP, SIG_DFL);
		(void) sigset(SIGINT, SIG_DFL);
		(void) sigset(SIGTERM, SIG_DFL);
		(void) sigset(SIGUSR1, SIG_DFL);
	}
#  else /* ALTOS_SYSTEM_V */
	sigset_t sset;

	(void) sigemptyset(&sset);
	(void) sigaddset(&sset, SIGALRM);
	(void) sigaddset(&sset, SIGCHLD);
	(void) sigaddset(&sset, SIGHUP);
	(void) sigaddset(&sset, SIGINT);
	(void) sigaddset(&sset, SIGTERM);
	(void) sigaddset(&sset, SIGUSR1);
	(void) sigprocmask(block ? SIG_BLOCK : SIG_UNBLOCK, &sset, NULL);
#  endif /* ALTOS_SYSTEM_V */
# endif /* BSD4_3 */
d1291 4
a1294 4
# ifdef BSD4_3
#  ifndef sigmask
#   define sigmask(s)	(1 << ((s) - 1))
#  endif /* ! sigmask */
d1296 2
a1297 2
# else /* BSD4_3 */
#  ifdef ALTOS_SYSTEM_V
d1305 1
a1305 1
#  else /* ALTOS_SYSTEM_V */
d1314 2
a1315 2
#  endif /* ALTOS_SYSTEM_V */
# endif /* BSD4_3 */
d1333 1
a1333 1
# ifdef BSD4_3
d1335 2
a1336 2
# else /* BSD4_3 */
#  ifdef ALTOS_SYSTEM_V
d1344 1
a1344 1
#  else /* ALTOS_SYSTEM_V */
d1353 2
a1354 2
#  endif /* ALTOS_SYSTEM_V */
# endif /* BSD4_3 */
a1447 1

a1503 1
#define LA_PSET		15	/* Solaris per-processor-set load average */
a2060 22
#if LA_TYPE == LA_PSET

static int
getla()
{
	double avenrun[3];

	if (pset_getloadavg(PS_MYID, avenrun,
			    sizeof(avenrun) / sizeof(avenrun[0])) < 0)
	{
		if (tTd(3, 1))
			dprintf("getla: pset_getloadavg failed: %s",
				errstring(errno));
		return -1;
	}
	if (tTd(3, 1))
		dprintf("getla: %d\n", (int) (avenrun[0] +0.5));
	return ((int) (avenrun[0] + 0.5));
}

#endif /* LA_TYPE == LA_PSET */

d2143 1
a2143 1
		snprintf(labuf, sizeof labuf, "%d", la);
d2220 4
d2229 19
a2247 1
	CurrentLA = sm_getla(NULL);
a2303 1

d2431 1
a2431 1
	static pid_t kmempid = -1;
d2463 1
a2463 1
			(void) close(kmem);
d2565 1
a2565 1
# ifdef WAITUNION
d2567 1
a2567 1
# else /* WAITUNION */
d2569 1
a2569 1
# endif /* WAITUNION */
d2571 1
a2571 1
# if defined(ISC_UNIX) || defined(_SCO_unix_)
d2573 1
a2573 1
# endif /* defined(ISC_UNIX) || defined(_SCO_unix_) */
d2578 1
a2578 1
# if defined(ISC_UNIX) || defined(_SCO_unix_)
d2580 1
a2580 1
# endif /* defined(ISC_UNIX) || defined(_SCO_unix_) */
d2582 1
a2582 1
# if defined(ISC_UNIX) || defined(_SCO_unix_)
d2585 1
a2585 1
# endif /* defined(ISC_UNIX) || defined(_SCO_unix_) */
d2591 1
a2591 1
# ifdef WAITUNION
d2593 1
a2593 1
# else /* WAITUNION */
d2595 1
a2595 1
# endif /* WAITUNION */
a2608 4
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
d2619 1
a2619 1
# if HASWAITPID
a2621 7
# else /* HASWAITPID */
#  ifdef WNOHANG
	union wait status;
#  else /* WNOHANG */
	auto int status;
#  endif /* WNOHANG */
# endif /* HASWAITPID */
a2622 1
# if HASWAITPID
d2628 5
d2634 5
a2638 2
# else /* HASWAITPID */
#  ifdef WNOHANG
d2642 3
a2644 1
#  else /* WNOHANG */
d2655 2
a2656 2
#  endif /* WNOHANG */
# endif /* HASWAITPID */
d2664 3
a2666 1
				RestartRequest = "control socket";
d2671 1
a2671 1
				ShutdownRequest = "control socket";
d2676 3
a2678 1
	FIX_SYSV_SIGNAL(sig, reapchild);
d2743 4
a2746 1
		newenv = (char **) xalloc(sizeof(char *) * (envlen + 2));
d2752 3
a2754 2
		newenv = (char **) xrealloc((char *)environ,
					    sizeof(char *) * (envlen + 2));
d2851 1
a2851 1
# ifdef RLIMIT_NOFILE
d2856 1
a2856 1
# endif /* RLIMIT_NOFILE */
d2858 1
a2858 1
# if HASGETDTABLESIZE
d2860 2
a2861 2
# else /* HASGETDTABLESIZE */
#  ifdef _SC_OPEN_MAX
d2863 1
a2863 1
#  else /* _SC_OPEN_MAX */
d2865 2
a2866 2
#  endif /* _SC_OPEN_MAX */
# endif /* HASGETDTABLESIZE */
d2911 1
a2911 1
#  if 0
d2927 1
a2927 1
#  endif /* 0 */
d2974 1
a2974 1
#  ifdef TIOCNOTTY
d2980 1
a2980 1
		(void) ioctl(fd, TIOCNOTTY, (char *) 0);
d2983 2
a2984 2
#  endif /* TIOCNOTTY */
#  ifdef SYS5SETPGRP
d2986 1
a2986 1
#  else /* SYS5SETPGRP */
d2988 1
a2988 1
#  endif /* SYS5SETPGRP */
d3243 1
a3243 1
# if HASGETUSERSHELL
d3257 2
a3258 2
# else /* HASGETUSERSHELL */
#  if USEGETCONFATTR
d3260 1
a3260 1
#  endif /* USEGETCONFATTR */
d3268 1
a3268 1
#  if USEGETCONFATTR
d3292 1
a3292 1
#  endif /* USEGETCONFATTR */
d3334 1
a3334 1
# endif /* HASGETUSERSHELL */
d3347 1
a3347 1
**		The number of blocks free on the queue filesystem.
d3388 2
a3389 2
# if SFS_TYPE != SFS_NONE
#  if SFS_TYPE == SFS_USTAT
d3392 4
a3395 4
#   define FSBLOCKSIZE	DEV_BSIZE
#   define SFS_BAVAIL	f_tfree
#  else /* SFS_TYPE == SFS_USTAT */
#   if defined(ultrix)
d3397 4
a3400 4
#    define SFS_BAVAIL	fd_bfreen
#    define FSBLOCKSIZE	1024L
#   else /* defined(ultrix) */
#    if SFS_TYPE == SFS_STATVFS
d3402 2
a3403 2
#     define FSBLOCKSIZE	fs.f_frsize
#    else /* SFS_TYPE == SFS_STATVFS */
d3405 7
a3411 7
#     define FSBLOCKSIZE	fs.f_bsize
#    endif /* SFS_TYPE == SFS_STATVFS */
#   endif /* defined(ultrix) */
#  endif /* SFS_TYPE == SFS_USTAT */
#  ifndef SFS_BAVAIL
#   define SFS_BAVAIL f_bavail
#  endif /* ! SFS_BAVAIL */
d3413 1
a3413 1
#  if SFS_TYPE == SFS_USTAT
d3415 2
a3416 2
#  else /* SFS_TYPE == SFS_USTAT */
#   if SFS_TYPE == SFS_4ARGS
d3418 2
a3419 2
#   else /* SFS_TYPE == SFS_4ARGS */
#    if SFS_TYPE == SFS_STATVFS
d3421 2
a3422 2
#    else /* SFS_TYPE == SFS_STATVFS */
#     if defined(ultrix)
d3424 1
a3424 1
#     else /* defined(ultrix) */
d3426 4
a3429 4
#     endif /* defined(ultrix) */
#    endif /* SFS_TYPE == SFS_STATVFS */
#   endif /* SFS_TYPE == SFS_4ARGS */
#  endif /* SFS_TYPE == SFS_USTAT */
d3440 1
a3440 1
# endif /* SFS_TYPE != SFS_NONE */
d3464 1
a3464 2
	long bfree;
	long bsize;
d3473 1
a3473 2
	bfree = freediskspace(QueueDir, &bsize);
	if (bfree >= 0)
a3616 1
**			LOCK_UN -- unlock.
d3632 1
a3632 1
# if !HASFLOCK
d3689 1
a3689 1
#  ifdef F_GETFL
d3692 1
a3692 1
#  endif /* F_GETFL */
d3697 1
a3697 1
# else /* !HASFLOCK */
d3720 1
a3720 1
#  ifdef F_GETFL
d3723 1
a3723 1
#  endif /* F_GETFL */
d3728 1
a3728 1
# endif /* !HASFLOCK */
d3796 1
a3796 1
# if (!defined(_POSIX_CHOWN_RESTRICTED) || _POSIX_CHOWN_RESTRICTED != -1) && \
d3812 1
a3812 1
#  if SAFENFSPATHCONF
d3814 1
a3814 1
#  else /* SAFENFSPATHCONF */
d3816 2
a3817 2
#  endif /* SAFENFSPATHCONF */
# else /* (!defined(_POSIX_CHOWN_RESTRICTED) || _POSIX_CHOWN_RESTRICTED != -1) && \ */
d3819 1
a3819 1
# endif /* (!defined(_POSIX_CHOWN_RESTRICTED) || _POSIX_CHOWN_RESTRICTED != -1) && \ */
d4124 2
a4125 2
	if (rscheck("check_relay", hostname, anynet_ntoa(sap),
		    e, TRUE, TRUE, 4, NULL) != EX_OK)
d4133 16
a4148 2
		if (strlen(MsgBuf) >= 3)
			(void) strlcpy(reject, MsgBuf, sizeof reject);
d4328 1
a4328 1
#if NETINET6 && NEEDSGETIPNODE
a4329 6
# ifndef AI_DEFAULT
#  define AI_DEFAULT	0	/* dummy */
# endif /* ! AI_DEFAULT */
# ifndef AI_ADDRCONFIG
#  define AI_ADDRCONFIG	0	/* dummy */
# endif /* ! AI_ADDRCONFIG */
d4353 1
a4353 1
	SM_SET_H_ERRNO(0);
d4370 1
a4370 1
	SM_SET_H_ERRNO(0);
d4375 1
a4375 15

# if _FFR_FREEHOSTENT
void
freehostent(h)
	struct hostent *h;
{
	/*
	**  Stub routine -- if they don't have getipnodeby*(),
	**  they probably don't have the free routine either.
	*/

	return;
}
# endif /* _FFR_FREEHOSTENT */
#endif /* NEEDSGETIPNODE && NETINET6 */
a4381 1
	int save_errno;
a4391 1
	save_errno = errno;
a4397 1
	save_errno = errno;
a4401 1
	int flags = AI_DEFAULT|AI_ALL;
d4404 1
d4413 2
a4414 5
#  if ADDRCONFIG_IS_BROKEN
	flags &= ~AI_ADDRCONFIG;
#  endif /* ADDRCONFIG_IS_BROKEN */
	h = getipnodebyname(name, family, flags, &err);
	SM_SET_H_ERRNO(err);
a4426 1
		{
a4429 2
		}

d4439 1
a4439 1
			(void) shorten_hostname(hbuf);
d4452 1
a4452 1
				SM_SET_H_ERRNO(err);
a4514 11

#if NETINET6
	if (type == AF_INET6 &&
	    IN6_IS_ADDR_UNSPECIFIED((struct in6_addr *) addr))
	{
		/* Avoid reverse lookup for IPv6 unspecified address */
		SM_SET_H_ERRNO(HOST_NOT_FOUND);
		return NULL;
	}
#endif /* NETINET6 */

d4517 3
a4519 4
	{
		static struct hostent he;
		static char buf[1000];
		extern struct hostent *_switch_gethostbyaddr_r();
d4521 1
a4521 3
		hp = _switch_gethostbyaddr_r(addr, len, type, &he,
					     buf, sizeof(buf), &h_errno);
	}
d4523 1
a4523 2
	{
		extern struct hostent *__switch_gethostbyaddr();
d4525 1
a4525 2
		hp = __switch_gethostbyaddr(addr, len, type);
	}
d4529 2
a4530 2
	{
		int err;
d4532 3
a4534 3
		hp = getipnodebyaddr(addr, len, type, &err);
		SM_SET_H_ERRNO(err);
	}
d4538 1
a4539 1
	return hp;
d4660 1
a4660 2
					      sizeof(sa->sin.sin_addr),
					      sa->sa.sa_family);
d4667 1
a4667 2
					      sizeof(sa->sin6.sin6_addr),
					      sa->sa.sa_family);
a4739 3
#if _FFR_FREEHOSTENT && NETINET6
	freehostent(hp);
#endif /* _FFR_FREEHOSTENT && NETINET6 */
d4786 1
a4786 1
#   ifdef SIOCGLIFNUM
d4803 1
a4803 1
#   endif /* SIOCGLIFNUM */
d4808 1
a4808 1
		(void) close(s);
d4819 1
a4819 2
		(void) close(s);
		sm_free(lifc.lifc_buf);
d4835 1
a4835 1
#   ifdef SIOCGLIFFLAGS
d4837 1
a4837 1
#   endif /* SIOCGLIFFLAGS */
a4851 2
		{
			sm_free(lifc.lifc_buf);
a4852 1
		}
d4862 1
a4862 1
#   ifdef BSD4_4_SOCKADDR
d4866 1
a4866 1
#   endif /* BSD4_4_SOCKADDR */
d4875 1
a4875 1
#   ifdef SIOCGLIFFLAGS
d4892 1
a4892 1
#   endif /* SIOCGLIFFLAGS */
a4899 14
#  ifdef __KAME__
			/* convert into proper scoped address */
			if ((IN6_IS_ADDR_LINKLOCAL(&sa->sin6.sin6_addr) ||
			     IN6_IS_ADDR_SITELOCAL(&sa->sin6.sin6_addr)) &&
			    sa->sin6.sin6_scope_id == 0)
			{
				struct in6_addr *ia6p;

				ia6p = &sa->sin6.sin6_addr;
				sa->sin6.sin6_scope_id = ntohs(ia6p->s6_addr[3] |
							       ((unsigned int)ia6p->s6_addr[2] << 8));
				ia6p->s6_addr[2] = ia6p->s6_addr[3] = 0;
			}
#  endif /* __KAME__ */
d4901 1
a4901 1
			if (IN6_IS_ADDR_UNSPECIFIED(&ia6))
d4915 1
a4915 1
						(int) sizeof ip_addr - 3, addr);
d4930 1
a4930 1
					(int) sizeof ip_addr - 3, inet_ntoa(ia));
d4944 1
a4944 1
#   ifdef SIOCGLIFFLAGS
d4948 1
a4948 1
#   endif /* SIOCGLIFFLAGS */
d4951 2
a4952 2
	sm_free(lifc.lifc_buf);
	(void) close(s);
a4990 1
		sm_free(ifc.ifc_buf);
a5000 1
		int af;
a5002 4
#   if NETINET6
		char *addr;
		struct in6_addr ia6;
#   endif /* NETINET6 */
d5004 1
a5004 1
#   ifdef SIOCGIFFLAGS
d5006 1
a5006 1
#   endif /* SIOCGIFFLAGS */
a5007 3
#   if NETINET6
		char buf6[INET6_ADDRSTRLEN];
#   endif /* NETINET6 */
d5017 1
a5017 1
#   ifdef BSD4_4_SOCKADDR
d5021 1
a5021 1
#   endif /* BSD4_4_SOCKADDR */
d5027 1
a5027 6
		af = ifr->ifr_addr.sa_family;
		if (af != AF_INET
#   if NETINET6
		    && af != AF_INET6
#   endif /* NETINET6 */
		    )
d5030 1
a5030 1
#   ifdef SIOCGIFFLAGS
d5038 4
a5041 5
#    define IFRFREF ifrf
#   else /* SIOCGIFFLAGS */
#    define IFRFREF (*ifr)
#   endif /* SIOCGIFFLAGS */

a5044 2
		ip_addr[0] = '\0';

d5046 2
a5047 1
		switch (af)
d5049 3
a5051 51
		  case AF_INET:
			ia = sa->sin.sin_addr;
			if (ia.s_addr == INADDR_ANY ||
			    ia.s_addr == INADDR_NONE)
			{
				message("WARNING: interface %s is UP with %s address",
					ifr->ifr_name, inet_ntoa(ia));
				continue;
			}

			/* save IP address in text from */
			(void) snprintf(ip_addr, sizeof ip_addr, "[%.*s]",
					(int) sizeof ip_addr - 3,
					inet_ntoa(ia));
			break;

#   if NETINET6
		  case AF_INET6:
#    ifdef __KAME__
			/* convert into proper scoped address */
			if ((IN6_IS_ADDR_LINKLOCAL(&sa->sin6.sin6_addr) ||
			     IN6_IS_ADDR_SITELOCAL(&sa->sin6.sin6_addr)) &&
			    sa->sin6.sin6_scope_id == 0)
			{
				struct in6_addr *ia6p;

				ia6p = &sa->sin6.sin6_addr;
				sa->sin6.sin6_scope_id = ntohs(ia6p->s6_addr[3] |
							       ((unsigned int)ia6p->s6_addr[2] << 8));
				ia6p->s6_addr[2] = ia6p->s6_addr[3] = 0;
			}
#    endif /* __KAME__ */
			ia6 = sa->sin6.sin6_addr;
			if (IN6_IS_ADDR_UNSPECIFIED(&ia6))
			{
				addr = anynet_ntop(&ia6, buf6, sizeof buf6);
				message("WARNING: interface %s is UP with %s address",
					ifr->ifr_name,
					addr == NULL ? "(NULL)" : addr);
				continue;
			}

			/* save IP address in text from */
			addr = anynet_ntop(&ia6, buf6, sizeof buf6);
			if (addr != NULL)
				(void) snprintf(ip_addr, sizeof ip_addr,
						"[%.*s]",
						(int) sizeof ip_addr - 3, addr);
			break;

#   endif /* NETINET6 */
d5054 3
a5056 2
		if (ip_addr[0] == '\0')
			continue;
d5071 1
a5071 1
	sm_free(ifc.ifc_buf);
d5133 3
a5135 7
#  ifdef __hpux
#   include <sys/pstat.h>
	struct pst_dynamic psd;

	if (pstat_getdynamic(&psd, sizeof(psd), (size_t)1, 0) != -1)
		nproc = psd.psd_proc_cnt;
#  endif /* __hpux */
a5200 1
	int save_errno;
d5209 1
a5209 1
	save_errno = SyslogErrno = errno;
d5240 1
a5240 1
			sm_free(buf);
a5258 1
		errno = save_errno;
a5312 1
	errno = save_errno;
a5394 3
#if EGD
	"EGD",
#endif /* EGD */
a5469 3
#if SFIO
	"SFIO",
#endif /* SFIO */
a5475 3
#if STARTTLS
	"STARTTLS",
#endif /* STARTTLS */
a5557 3
#if HASURANDOMDEV
	"HASURANDOMDEV",
#endif /* HASURANDOMDEV */
a5605 6
#if SNPRINTF_IS_BROKEN
	"SNPRINTF_IS_BROKEN",
#endif /* SNPRINTF_IS_BROKEN */
#if SO_REUSEADDR_IS_BROKEN
	"SO_REUSEADDR_IS_BROKEN",
#endif /* SO_REUSEADDR_IS_BROKEN */
a5622 1

@


1.3
log
@Update to sendmail-8.10.1
@
text
@d5156 1
a5156 4
#if HASARC4RANDOM
	arc4random_stir();
#else /* HASARC4RANDOM */
# if HASSRANDOMDEV
d5158 1
a5158 1
# else /* HASSRANDOMDEV */
d5166 1
a5166 1
#  if HASRANDOM
d5168 1
a5168 1
#  else /* HASRANDOM */
d5170 2
a5171 3
#  endif /* HASRANDOM */
# endif /* HASSRANDOMDEV */
#endif /* HASARC4RANDOM */
a5506 3
#if HASARC4RANDOM
	"HASARC4RANDOM",
#endif /* HASARC4RANDOM */
@


1.2
log
@Remove sendmail's `Build' scaffolding and add real Makefiles
praliases should be in section 1, not 8
Use arc4random(3) instead of random(3)
Add some sample OpenBSD .mc files
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: conf.c,v 8.643 2000/02/26 06:37:31 gshapiro Exp $";
d4124 1
a4124 1
	if (rscheck("check_relay", hostname, anynet_ntoa(sap), e, TRUE, TRUE)
@


1.1
log
@Initial revision
@
text
@d5156 4
a5159 1
#if HASSRANDOMDEV
d5161 1
a5161 1
#else /* HASSRANDOMDEV */
d5169 1
a5169 1
# if HASRANDOM
d5171 1
a5171 1
# else /* HASRANDOM */
d5173 3
a5175 2
# endif /* HASRANDOM */
#endif /* HASSRANDOMDEV */
d5511 3
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Id: conf.c,v 8.646.2.2.2.61 2000/12/28 23:46:41 gshapiro Exp $";
d20 2
a21 4

# include <sys/ioctl.h>
# include <sys/param.h>

a29 1

a192 1
	{ "insufficiententropy",	DBS_INSUFFICIENTENTROPY },
a195 6
#if _FFR_UNSAFE_WRITABLE_INCLUDE
	{ "groupwritableforwardfile",	DBS_GROUPWRITABLEFORWARDFILE	},
	{ "groupwritableincludefile",	DBS_GROUPWRITABLEINCLUDEFILE	},
	{ "worldwritableforwardfile",	DBS_WORLDWRITABLEFORWARDFILE	},
	{ "worldwritableincludefile",	DBS_WORLDWRITABLEINCLUDEFILE	},
#endif /* _FFR_UNSAFE_WRITABLE_INCLUDE */
d373 1
a373 1
	(void) strlcpy(buf, "prog, P=/bin/sh, F=lsouDq9, T=X-Unix/X-Unix/X-Unix, A=sh -c \201u",
d818 1
a818 1
	int svcno = 0;
d838 1
a838 1
	while (lk != NULL && svcno < MAXMAPSTACK)
d875 1
a875 1
	for (svcno = 0; svcno < SVC_PATHSIZE && svcno < MAXMAPSTACK; svcno++)
d1231 1
a1231 1
# ifdef SA_RESTART
d1235 1
a1235 1
#  if USE_SA_SIGACTION
d1238 1
a1238 1
#  else /* USE_SA_SIGACTION */
d1241 1
a1241 1
#  endif /* USE_SA_SIGACTION */
d1245 1
a1245 1
# else /* SA_RESTART */
d1252 2
a1253 2
#  if defined(SYS5SIGNALS) || defined(BSD4_3)
#   ifdef BSD4_3
d1255 1
a1255 1
#   else /* BSD4_3 */
d1257 2
a1258 2
#   endif /* BSD4_3 */
#  else /* defined(SYS5SIGNALS) || defined(BSD4_3) */
d1272 2
a1273 2
#  endif /* defined(SYS5SIGNALS) || defined(BSD4_3) */
# endif /* SA_RESTART */
d1291 4
a1294 4
# ifdef BSD4_3
#  ifndef sigmask
#   define sigmask(s)	(1 << ((s) - 1))
#  endif /* ! sigmask */
d1296 2
a1297 2
# else /* BSD4_3 */
#  ifdef ALTOS_SYSTEM_V
d1305 1
a1305 1
#  else /* ALTOS_SYSTEM_V */
d1314 2
a1315 2
#  endif /* ALTOS_SYSTEM_V */
# endif /* BSD4_3 */
d1333 1
a1333 1
# ifdef BSD4_3
d1335 2
a1336 2
# else /* BSD4_3 */
#  ifdef ALTOS_SYSTEM_V
d1344 1
a1344 1
#  else /* ALTOS_SYSTEM_V */
d1353 2
a1354 2
#  endif /* ALTOS_SYSTEM_V */
# endif /* BSD4_3 */
a1447 1

a1503 1
#define LA_PSET		15	/* Solaris per-processor-set load average */
a2060 22
#if LA_TYPE == LA_PSET

static int
getla()
{
	double avenrun[3];

	if (pset_getloadavg(PS_MYID, avenrun,
			    sizeof(avenrun) / sizeof(avenrun[0])) < 0)
	{
		if (tTd(3, 1))
			dprintf("getla: pset_getloadavg failed: %s",
				errstring(errno));
		return -1;
	}
	if (tTd(3, 1))
		dprintf("getla: %d\n", (int) (avenrun[0] +0.5));
	return ((int) (avenrun[0] + 0.5));
}

#endif /* LA_TYPE == LA_PSET */

d2143 1
a2143 1
		snprintf(labuf, sizeof labuf, "%d", la);
d2220 4
d2229 19
a2247 1
	CurrentLA = sm_getla(NULL);
a2303 1

d2463 1
a2463 1
			(void) close(kmem);
d2565 1
a2565 1
# ifdef WAITUNION
d2567 1
a2567 1
# else /* WAITUNION */
d2569 1
a2569 1
# endif /* WAITUNION */
d2571 1
a2571 1
# if defined(ISC_UNIX) || defined(_SCO_unix_)
d2573 1
a2573 1
# endif /* defined(ISC_UNIX) || defined(_SCO_unix_) */
d2578 1
a2578 1
# if defined(ISC_UNIX) || defined(_SCO_unix_)
d2580 1
a2580 1
# endif /* defined(ISC_UNIX) || defined(_SCO_unix_) */
d2582 1
a2582 1
# if defined(ISC_UNIX) || defined(_SCO_unix_)
d2585 1
a2585 1
# endif /* defined(ISC_UNIX) || defined(_SCO_unix_) */
d2591 1
a2591 1
# ifdef WAITUNION
d2593 1
a2593 1
# else /* WAITUNION */
d2595 1
a2595 1
# endif /* WAITUNION */
d2851 1
a2851 1
# ifdef RLIMIT_NOFILE
d2856 1
a2856 1
# endif /* RLIMIT_NOFILE */
d2858 1
a2858 1
# if HASGETDTABLESIZE
d2860 2
a2861 2
# else /* HASGETDTABLESIZE */
#  ifdef _SC_OPEN_MAX
d2863 1
a2863 1
#  else /* _SC_OPEN_MAX */
d2865 2
a2866 2
#  endif /* _SC_OPEN_MAX */
# endif /* HASGETDTABLESIZE */
d2911 1
a2911 1
#  if 0
d2927 1
a2927 1
#  endif /* 0 */
d2974 1
a2974 1
#  ifdef TIOCNOTTY
d2980 1
a2980 1
		(void) ioctl(fd, TIOCNOTTY, (char *) 0);
d2983 2
a2984 2
#  endif /* TIOCNOTTY */
#  ifdef SYS5SETPGRP
d2986 1
a2986 1
#  else /* SYS5SETPGRP */
d2988 1
a2988 1
#  endif /* SYS5SETPGRP */
d3243 1
a3243 1
# if HASGETUSERSHELL
d3257 2
a3258 2
# else /* HASGETUSERSHELL */
#  if USEGETCONFATTR
d3260 1
a3260 1
#  endif /* USEGETCONFATTR */
d3268 1
a3268 1
#  if USEGETCONFATTR
d3292 1
a3292 1
#  endif /* USEGETCONFATTR */
d3334 1
a3334 1
# endif /* HASGETUSERSHELL */
d3347 1
a3347 1
**		The number of blocks free on the queue filesystem.
d3388 2
a3389 2
# if SFS_TYPE != SFS_NONE
#  if SFS_TYPE == SFS_USTAT
d3392 4
a3395 4
#   define FSBLOCKSIZE	DEV_BSIZE
#   define SFS_BAVAIL	f_tfree
#  else /* SFS_TYPE == SFS_USTAT */
#   if defined(ultrix)
d3397 4
a3400 4
#    define SFS_BAVAIL	fd_bfreen
#    define FSBLOCKSIZE	1024L
#   else /* defined(ultrix) */
#    if SFS_TYPE == SFS_STATVFS
d3402 2
a3403 2
#     define FSBLOCKSIZE	fs.f_frsize
#    else /* SFS_TYPE == SFS_STATVFS */
d3405 7
a3411 7
#     define FSBLOCKSIZE	fs.f_bsize
#    endif /* SFS_TYPE == SFS_STATVFS */
#   endif /* defined(ultrix) */
#  endif /* SFS_TYPE == SFS_USTAT */
#  ifndef SFS_BAVAIL
#   define SFS_BAVAIL f_bavail
#  endif /* ! SFS_BAVAIL */
d3413 1
a3413 1
#  if SFS_TYPE == SFS_USTAT
d3415 2
a3416 2
#  else /* SFS_TYPE == SFS_USTAT */
#   if SFS_TYPE == SFS_4ARGS
d3418 2
a3419 2
#   else /* SFS_TYPE == SFS_4ARGS */
#    if SFS_TYPE == SFS_STATVFS
d3421 2
a3422 2
#    else /* SFS_TYPE == SFS_STATVFS */
#     if defined(ultrix)
d3424 1
a3424 1
#     else /* defined(ultrix) */
d3426 4
a3429 4
#     endif /* defined(ultrix) */
#    endif /* SFS_TYPE == SFS_STATVFS */
#   endif /* SFS_TYPE == SFS_4ARGS */
#  endif /* SFS_TYPE == SFS_USTAT */
d3440 1
a3440 1
# endif /* SFS_TYPE != SFS_NONE */
d3464 1
a3464 2
	long bfree;
	long bsize;
d3473 1
a3473 2
	bfree = freediskspace(QueueDir, &bsize);
	if (bfree >= 0)
a3616 1
**			LOCK_UN -- unlock.
d3632 1
a3632 1
# if !HASFLOCK
d3689 1
a3689 1
#  ifdef F_GETFL
d3692 1
a3692 1
#  endif /* F_GETFL */
d3697 1
a3697 1
# else /* !HASFLOCK */
d3720 1
a3720 1
#  ifdef F_GETFL
d3723 1
a3723 1
#  endif /* F_GETFL */
d3728 1
a3728 1
# endif /* !HASFLOCK */
d3796 1
a3796 1
# if (!defined(_POSIX_CHOWN_RESTRICTED) || _POSIX_CHOWN_RESTRICTED != -1) && \
d3812 1
a3812 1
#  if SAFENFSPATHCONF
d3814 1
a3814 1
#  else /* SAFENFSPATHCONF */
d3816 2
a3817 2
#  endif /* SAFENFSPATHCONF */
# else /* (!defined(_POSIX_CHOWN_RESTRICTED) || _POSIX_CHOWN_RESTRICTED != -1) && \ */
d3819 1
a3819 1
# endif /* (!defined(_POSIX_CHOWN_RESTRICTED) || _POSIX_CHOWN_RESTRICTED != -1) && \ */
d4124 2
a4125 2
	if (rscheck("check_relay", hostname, anynet_ntoa(sap),
		    e, TRUE, TRUE, 4, NULL) != EX_OK)
d4133 16
a4148 2
		if (strlen(MsgBuf) >= 3)
			(void) strlcpy(reject, MsgBuf, sizeof reject);
a4329 6
# ifndef AI_DEFAULT
#  define AI_DEFAULT	0	/* dummy */
# endif /* ! AI_DEFAULT */
# ifndef AI_ADDRCONFIG
#  define AI_ADDRCONFIG	0	/* dummy */
# endif /* ! AI_ADDRCONFIG */
a4374 14

# if _FFR_FREEHOSTENT
void
freehostent(h)
	struct hostent *h;
{
	/*
	**  Stub routine -- if they don't have getipnodeby*(),
	**  they probably don't have the free routine either.
	*/

	return;
}
# endif /* _FFR_FREEHOSTENT */
a4401 1
	int flags = AI_DEFAULT|AI_ALL;
d4413 1
a4413 4
#  if ADDRCONFIG_IS_BROKEN
	flags &= ~AI_ADDRCONFIG;
#  endif /* ADDRCONFIG_IS_BROKEN */
	h = getipnodebyname(name, family, flags, &err);
a4426 1
		{
a4429 2
		}

d4660 1
a4660 2
					      sizeof(sa->sin.sin_addr),
					      sa->sa.sa_family);
d4667 1
a4667 2
					      sizeof(sa->sin6.sin6_addr),
					      sa->sa.sa_family);
a4739 3
#if _FFR_FREEHOSTENT && NETINET6
	freehostent(hp);
#endif /* _FFR_FREEHOSTENT && NETINET6 */
d4786 1
a4786 1
#   ifdef SIOCGLIFNUM
d4803 1
a4803 1
#   endif /* SIOCGLIFNUM */
d4808 1
a4808 1
		(void) close(s);
d4819 1
a4819 2
		(void) close(s);
		free(lifc.lifc_buf);
d4835 1
a4835 1
#   ifdef SIOCGLIFFLAGS
d4837 1
a4837 1
#   endif /* SIOCGLIFFLAGS */
a4851 2
		{
			free(lifc.lifc_buf);
a4852 1
		}
d4862 1
a4862 1
#   ifdef BSD4_4_SOCKADDR
d4866 1
a4866 1
#   endif /* BSD4_4_SOCKADDR */
d4875 1
a4875 1
#   ifdef SIOCGLIFFLAGS
d4892 1
a4892 1
#   endif /* SIOCGLIFFLAGS */
d4901 1
a4901 12
#   ifdef __KAME__
			/* convert into proper scoped address - */
			if ((IN6_IS_ADDR_LINKLOCAL(&ia6) ||
			     IN6_IS_ADDR_SITELOCAL(&ia6)) &&
			    sa->sin6.sin6_scope_id == 0)
			{
				sa->sin6.sin6_scope_id = ntohs(ia6.s6_addr[3] |
					((unsigned int) ia6.s6_addr[2] << 8));
				ia6.s6_addr[2] = ia6.s6_addr[3] = 0;
			}
#   endif /* __KAME__ */
			if (IN6_IS_ADDR_UNSPECIFIED(&ia6))
d4915 1
a4915 1
						(int) sizeof ip_addr - 3, addr);
d4930 1
a4930 1
					(int) sizeof ip_addr - 3, inet_ntoa(ia));
d4944 1
a4944 1
#   ifdef SIOCGLIFFLAGS
d4948 1
a4948 1
#   endif /* SIOCGLIFFLAGS */
d4952 1
a4952 1
	(void) close(s);
a4990 1
		free(ifc.ifc_buf);
a5000 1
		int af;
a5002 4
#   if NETINET6
		char *addr;
		struct in6_addr ia6;
#   endif /* NETINET6 */
d5004 1
a5004 1
#   ifdef SIOCGIFFLAGS
d5006 1
a5006 1
#   endif /* SIOCGIFFLAGS */
a5007 3
#   if NETINET6
		char buf6[INET6_ADDRSTRLEN];
#   endif /* NETINET6 */
d5017 1
a5017 1
#   ifdef BSD4_4_SOCKADDR
d5021 1
a5021 1
#   endif /* BSD4_4_SOCKADDR */
d5027 1
a5027 6
		af = ifr->ifr_addr.sa_family;
		if (af != AF_INET
#   if NETINET6
		    && af != AF_INET6
#   endif /* NETINET6 */
		    )
d5030 1
a5030 1
#   ifdef SIOCGIFFLAGS
d5038 4
a5041 5
#    define IFRFREF ifrf
#   else /* SIOCGIFFLAGS */
#    define IFRFREF (*ifr)
#   endif /* SIOCGIFFLAGS */

a5044 2
		ip_addr[0] = '\0';

d5046 2
a5047 1
		switch (af)
d5049 3
a5051 37
		  case AF_INET:
			ia = sa->sin.sin_addr;
			if (ia.s_addr == INADDR_ANY ||
			    ia.s_addr == INADDR_NONE)
			{
				message("WARNING: interface %s is UP with %s address",
					ifr->ifr_name, inet_ntoa(ia));
				continue;
			}

			/* save IP address in text from */
			(void) snprintf(ip_addr, sizeof ip_addr, "[%.*s]",
					(int) sizeof ip_addr - 3,
					inet_ntoa(ia));
			break;

#   if NETINET6
		  case AF_INET6:
			ia6 = sa->sin6.sin6_addr;
			if (IN6_IS_ADDR_UNSPECIFIED(&ia6))
			{
				addr = anynet_ntop(&ia6, buf6, sizeof buf6);
				message("WARNING: interface %s is UP with %s address",
					ifr->ifr_name,
					addr == NULL ? "(NULL)" : addr);
				continue;
			}

			/* save IP address in text from */
			addr = anynet_ntop(&ia6, buf6, sizeof buf6);
			if (addr != NULL)
				(void) snprintf(ip_addr, sizeof ip_addr,
						"[%.*s]",
						(int) sizeof ip_addr - 3, addr);
			break;

#   endif /* NETINET6 */
d5054 3
a5056 2
		if (ip_addr[0] == '\0')
			continue;
d5133 3
a5135 7
#  ifdef __hpux
#   include <sys/pstat.h>
	struct pst_dynamic psd;

	if (pstat_getdynamic(&psd, sizeof(psd), (size_t)1, 0) != -1)
		nproc = psd.psd_proc_cnt;
#  endif /* __hpux */
a5200 1
	int save_errno;
d5209 1
a5209 1
	save_errno = SyslogErrno = errno;
a5258 1
		errno = save_errno;
a5312 1
	errno = save_errno;
a5469 3
#if SFIO
	"SFIO",
#endif /* SFIO */
a5475 3
#if STARTTLS
	"STARTTLS",
#endif /* STARTTLS */
a5557 3
#if HASURANDOMDEV
	"HASURANDOMDEV",
#endif /* HASURANDOMDEV */
a5605 6
#if SNPRINTF_IS_BROKEN
	"SNPRINTF_IS_BROKEN",
#endif /* SNPRINTF_IS_BROKEN */
#if SO_REUSEADDR_IS_BROKEN
	"SO_REUSEADDR_IS_BROKEN",
#endif /* SO_REUSEADDR_IS_BROKEN */
a5622 1

@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d14 4
a18 3

SM_RCSID("@@(#)$Sendmail: conf.c,v 8.907 2001/09/04 22:43:02 ca Exp $")

a34 1
static void	setupqueues __P((void));
a81 1
	{ "disposition-notification-to",	H_FROM,		NULL	},
a133 1
	{ "restrictexpand",	PRIV_RESTRICTEXPAND	},
a147 1

d197 4
a200 2
	{ "groupreadablesasldbfile",	DBS_GROUPREADABLESASLDBFILE	},
	{ "groupwritablesasldbfile",	DBS_GROUPWRITABLESASLDBFILE	},
d205 1
a205 5
	{ "groupreadablekeyfile",	DBS_GROUPREADABLEKEYFILE	},
#if _FFR_GROUPREADABLEAUTHINFOFILE
	{ "groupreadableadefaultauthinfofile",
					DBS_GROUPREADABLEAUTHINFOFILE	},
#endif /* _FFR_GROUPREADABLEAUTHINFOFILE */
d209 1
d218 2
a219 2
**	Some of these must be initialized using direct code since they
**	depend on run-time values. So let's do all of them this way.
d258 1
d261 1
d279 1
a279 1
		sm_dprintf("setdefaults: DefUser=%s, DefUid=%d, DefGid=%d\n",
d286 1
a286 4
	e->e_qgrp = NOQGRP;
	e->e_qdir = NOQDIR;
	e->e_xfqgrp = NOQGRP;
	e->e_xfqdir = NOQDIR;
d288 1
a288 1
	SevenBitInput = false;			/* option 7 */
d292 1
a292 4
#if MILTER
	MilterLogLevel = -1;
#endif /* MILTER */
	inittimeouts(NULL, false);		/* option r */
d294 3
a296 3
	MeToo = true;				/* option m */
	SendMIMEErrors = true;			/* option f */
	SuperSafe = SAFE_REALLY;		/* option s */
d317 2
a318 3
	ColonOkInAddr = true;
	DontLockReadFiles = true;
	DontProbeInterfaces = DPI_PROBEALL;
a321 1
	FastSplit = 1;
a323 1
	MaxSLBits = INT_MAX;
a324 3
#if STARTTLS
	TLS_Srv_Opts = TLS_I_SRV;
#endif /* STARTTLS */
d347 1
a347 1
#if MILTER
d349 1
a349 1
#endif /* MILTER */
a350 1
	setupqueues();
d368 2
a369 4
	(void) sm_strlcpy(defuserbuf,
			  (defpwent == NULL || defpwent->pw_name == NULL)
			   ? "nobody" : defpwent->pw_name,
			  sizeof defuserbuf);
d371 2
a372 19
		sm_dprintf("setdefuser: DefUid=%d, DefUser=%s\n",
			   (int) DefUid, DefUser);
}
/*
**  SETUPQUEUES -- initialize default queues
**
**	The mqueue QUEUE structure gets filled in after readcf() but
**	we need something to point to now for the mailer setup,
**	which use "mqueue" as default queue.
*/

static void
setupqueues()
{
	char buf[100];

	MaxRunnersPerQueue = 1;
	(void) sm_strlcpy(buf, "mqueue, P=/var/spool/mqueue", sizeof buf);
	makequeue(buf, false);
d383 2
a384 2
	(void) sm_strlcpy(buf, "prog, P=/bin/sh, F=lsouDq9, T=X-Unix/X-Unix/X-Unix, A=sh -c \201u",
			sizeof buf);
d387 2
a388 2
	(void) sm_strlcpy(buf, "*file*, P=[FILE], F=lsDFMPEouq9, T=X-Unix/X-Unix/X-Unix, A=FILE \201u",
			sizeof buf);
d391 2
a392 2
	(void) sm_strlcpy(buf, "*include*, P=/dev/null, F=su, A=INCLUDE \201u",
			sizeof buf);
d423 1
a423 1
#if NEWDB
d433 1
a433 1
#if NDBM
d439 1
a439 1
#if NIS
d445 1
a445 1
#if NISPLUS
d451 2
a452 2
#if LDAPMAP
	MAPDEF("ldap", NULL, MCF_ALIASOK|MCF_NOTPERSIST,
d455 5
d462 2
a463 2
#if PH_MAP
	MAPDEF("ph", NULL, MCF_NOTPERSIST,
d475 1
a475 1
#if HESIOD
d477 1
a477 1
		map_parseargs, hes_map_open, hes_map_close,
a493 8
# if DNSMAP
	MAPDEF("dns", NULL, 0,
	       dns_map_parseargs, dns_map_open, null_map_close,
	       dns_map_lookup, null_map_store);
# endif /* DNSMAP */
#endif /* NAMED_BIND */

#if NAMED_BIND
d526 1
a526 1
#if MAP_REGEX
d624 1
a624 1
			(void) sm_strlcpy(buf, "hosts.files text -k 0 -v 1 /etc/hosts",
d632 1
a632 1
			(void) sm_strlcpy(buf, "hosts.dns dns A", sizeof buf);
d636 1
a636 1
# if NISPLUS
d640 1
a640 1
			(void) sm_strlcpy(buf, "hosts.nisplus nisplus -k name -v address hosts.org_dir",
d645 1
a645 1
# if NIS
d649 1
a649 1
			(void) sm_strlcpy(buf, "hosts.nis nis -k 0 -v 1 hosts.byname",
d658 1
a658 1
			(void) sm_strlcpy(buf, "hosts.netinfo netinfo -v name /machines",
d673 1
a673 1
		(void) sm_strlcpy(buf, "host host", sizeof buf);
d676 1
a676 1
			(void) sm_strlcat(buf, " -a. -D", sizeof buf);
d691 1
a691 2
			(void) sm_strlcpy(buf, "aliases.files null",
				sizeof buf);
d694 1
a694 1
#if NISPLUS
d698 1
a698 1
			(void) sm_strlcpy(buf, "aliases.nisplus nisplus -kalias -vexpansion mail_aliases.org_dir",
d703 1
a703 1
#if NIS
d707 1
a707 1
			(void) sm_strlcpy(buf, "aliases.nis nis mail.aliases",
d716 1
a716 1
			(void) sm_strlcpy(buf, "aliases.netinfo netinfo -z, /aliases",
d721 1
a721 1
#if HESIOD
d725 1
a725 1
			(void) sm_strlcpy(buf, "aliases.hesiod hesiod aliases",
d733 1
a733 1
		(void) sm_strlcpy(buf, "aliases switch aliases", sizeof buf);
d748 1
a748 1
			(void) sm_strlcpy(buf, "users.files text -m -z: -k0 -v6 /etc/passwd",
d752 1
a752 1
# if NISPLUS
d756 1
a756 1
			(void) sm_strlcpy(buf, "users.nisplus nisplus -m -kname -vhome passwd.org_dir",
d761 1
a761 1
# if NIS
d765 1
a765 1
			(void) sm_strlcpy(buf, "users.nis nis -m passwd.byname",
d770 1
a770 1
# if HESIOD
d774 1
a774 1
			(void) sm_strlcpy(buf, "users.hesiod hesiod", sizeof buf);
d781 1
a781 1
		(void) sm_strlcpy(buf, "users switch -m passwd", sizeof buf);
a921 1
	static time_t servicecachetime;	/* time service switch was cached */
d927 1
a927 1
	if ((now - servicecachetime) > (time_t) ServiceCacheMaxAge)
d930 1
a930 1
		register SM_FILE_T *fp;
d938 1
a938 1
			servicecachetime = now;
d944 1
a944 2
			while (sm_io_fgets(fp, SM_TIME_DEFAULT, buf,
					   sizeof buf) != NULL)
d979 1
a979 1
					sm_free((void *) st->s_service[0]); /* XXX */
d996 1
a996 1
			(void) sm_io_close(fp, SM_TIME_DEFAULT);
d1032 1
a1032 1
#  if NISPLUS
d1035 1
a1035 1
#  if NIS
d1094 1
a1094 1
				myname = pw->pw_name;
d1100 1
d1106 1
a1106 1
					myname = pw->pw_name;
a1113 4
		else if (strpbrk(myname, ",;:/|\"\\") != NULL)
			myname = addquotes(myname, NULL);
		else
			myname = sm_pstrdup_x(myname);
d1115 1
d1206 1
a1206 1
		sm_dprintf("checkcompat(to=%s, from=%s)\n",
d1226 177
d1578 1
a1578 1
int
a1580 1
	int j;
d1597 1
a1597 1
		(void) sm_strlcpy(Nl[X_AVENRUN].n_name, LA_AVENRUN,
d1609 2
a1610 2
				sm_dprintf("getla: nlist(%s): %s\n", _PATH_UNIX,
					   sm_errstring(errno));
d1616 1
a1616 1
				sm_dprintf("getla: nlist(%s, %s) ==> 0\n",
d1628 2
a1629 12
				sm_dprintf("getla: open(/dev/kmem): %s\n",
					   sm_errstring(errno));
			return -1;
		}
		if ((j = fcntl(kmem, F_GETFD, 0)) < 0 ||
		    fcntl(kmem, F_SETFD, j | FD_CLOEXEC) < 0)
		{
			if (tTd(3, 1))
				sm_dprintf("getla: fcntl(/dev/kmem, FD_CLOEXEC): %s\n",
					   sm_errstring(errno));
			(void) close(kmem);
			kmem = -1;
d1632 1
d1635 2
a1636 2
		sm_dprintf("getla: symbol address = %#lx\n",
			(unsigned long) Nl[X_AVENRUN].n_value);
d1642 2
a1643 2
			sm_dprintf("getla: lseek or read: %s\n",
				   sm_errstring(errno));
d1650 1
a1650 1
		sm_dprintf("getla: avenrun = %d", avenrun[0]);
d1652 1
a1652 1
			sm_dprintf(", %d, %d", avenrun[1], avenrun[2]);
d1654 1
a1654 1
		sm_dprintf("getla: avenrun = %ld", avenrun[0]);
d1656 1
a1656 1
			sm_dprintf(", %ld, %ld", avenrun[1], avenrun[2]);
d1658 1
a1658 1
		sm_dprintf("\n");
d1661 1
a1661 1
		sm_dprintf("getla: %d\n",
d1667 1
a1667 1
		sm_dprintf("getla: avenrun = %g", avenrun[0]);
d1669 2
a1670 2
			sm_dprintf(", %g, %g", avenrun[1], avenrun[2]);
		sm_dprintf("\n");
d1673 1
a1673 1
		sm_dprintf("getla: %d\n", (int) (avenrun[0] +0.5));
d1684 1
a1684 1
int
a1686 1
	int j;
d1698 2
a1699 12
				sm_dprintf("getla: open(/dev/kmem): %s\n",
					   sm_errstring(errno));
			return -1;
		}
		if ((j = fcntl(kmem, F_GETFD, 0)) < 0 ||
		    fcntl(kmem, F_SETFD, j | FD_CLOEXEC) < 0)
		{
			if (tTd(3, 1))
				sm_dprintf("getla: fcntl(/dev/kmem, FD_CLOEXEC): %s\n",
					   sm_errstring(errno));
			(void) close(kmem);
			kmem = -1;
d1702 1
d1710 2
a1711 2
			sm_dprintf("getla: ioctl(MIOC_READKSYM) failed: %s\n",
				   sm_errstring(errno));
d1716 1
a1716 1
		sm_dprintf("getla: avenrun = %d", avenrun[0]);
d1718 2
a1719 2
			sm_dprintf(", %d, %d", avenrun[1], avenrun[2]);
		sm_dprintf("\n");
d1722 1
a1722 1
		sm_dprintf("getla: %d\n",
d1733 1
a1733 1
int
d1742 1
a1742 1
		sm_dprintf("getla: %d\n", (int) (load_info.one_minute + 0.5));
d1764 1
a1764 1
int
d1774 1
a1774 1
		sm_dprintf("getla: %d\n", (int) (pstd.psd_avg_1_min + 0.5));
d1783 1
a1783 1
int
d1791 2
a1792 2
			sm_dprintf("getla: getloadavg failed: %s",
				   sm_errstring(errno));
d1796 1
a1796 1
		sm_dprintf("getla: %d\n", (int) (avenrun[0] +0.5));
d1814 1
a1814 1
int
d1827 2
a1828 2
			sm_dprintf("getla: processor_set_default failed: %s",
				   sm_errstring(errno));
d1837 2
a1838 2
			sm_dprintf("getla: processor_set_info failed: %s",
				   sm_errstring(errno));
d1842 1
a1842 1
		sm_dprintf("getla: %d\n",
a1850 6
# if SM_CONF_BROKEN_STRTOD
	ERROR: This OS has most likely a broken strtod() implemenentation.
	ERROR: The function is required for getla().
	ERROR: Check the compilation options _LA_PROCSTR and
	ERROR: _SM_CONF_BROKEN_STRTOD (without the leading _).
# endif /* SM_CONF_BROKEN_STRTOD */
d1864 1
a1864 1
int
d1869 1
a1869 1
	SM_FILE_T *fp;
d1871 1
a1871 2
	fp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, _PATH_LOADAVG, SM_IO_RDONLY,
			NULL);
d1875 2
a1876 2
			sm_dprintf("getla: sm_io_open(%s): %s\n",
				   _PATH_LOADAVG, sm_errstring(errno));
d1879 2
a1880 2
	result = sm_io_fscanf(fp, SM_TIME_DEFAULT, "%lf", &avenrun);
	(void) sm_io_close(fp, SM_TIME_DEFAULT);
d1884 2
a1885 2
			sm_dprintf("getla: sm_io_fscanf() = %d: %s\n",
				   result, sm_errstring(errno));
d1890 1
a1890 1
		sm_dprintf("getla(): %.2f\n", avenrun);
d1901 1
a1901 2
int
getla(void)
a1902 1
	int j;
d1912 2
a1913 12
				sm_dprintf("getla: open(%s): %s\n", _PATH_KMEM,
					   sm_errstring(errno));
			return -1;
		}
		if ((j = fcntl(kmem, F_GETFD, 0)) < 0 ||
		    fcntl(kmem, F_SETFD, j | FD_CLOEXEC) < 0)
		{
			if (tTd(3, 1))
				sm_dprintf("getla: fcntl(/dev/kmem, FD_CLOEXEC): %s\n",
					   sm_errstring(errno));
			(void) close(kmem);
			kmem = -1;
d1916 1
d1920 1
a1920 1
	    read(kmem, (char *) avenrun, sizeof(avenrun)) < sizeof(avenrun))
d1923 2
a1924 2
			sm_dprintf("getla: lseek or read: %s\n",
				   sm_errstring(errno));
d1929 1
a1929 1
		sm_dprintf("getla: avenrun = %ld", (long int) avenrun[0]);
d1931 1
a1931 1
			sm_dprintf(", %ld, %ld",
d1933 1
a1933 1
		sm_dprintf("\n");
d1937 1
a1937 1
		sm_dprintf("getla: %d\n",
d1948 1
a1948 1
int
d1961 2
a1962 2
			sm_dprintf("getla: kstat_open(): %s\n",
				   sm_errstring(errno));
d1970 2
a1971 2
			sm_dprintf("getla: kstat_lookup(): %s\n",
				   sm_errstring(errno));
d1977 2
a1978 2
			sm_dprintf("getla: kstat_read(): %s\n",
				   sm_errstring(errno));
d1982 1
a1982 1
	la = ((double) ksn->value.ul + FSCALE/2) / FSCALE;
d2003 1
a2003 1
int
d2021 2
a2022 2
				"can't open %s: %s",
				_PATH_AVENRUN, strerror(errno));
d2030 1
a2030 1
		sm_dprintf("getla: avenrun = %d\n", avenrun);
d2033 1
a2033 1
		sm_dprintf("getla: %d\n", loadav);
d2044 1
a2044 2
int
getla()
d2052 1
a2052 1
			sm_dprintf("getla: table %s\n", sm_errstring(errno));
d2057 1
a2057 1
		sm_dprintf("getla: scale = %d\n", tab.tl_lscale);
d2066 1
a2066 1
		sm_dprintf("getla: %d\n", ave);
d2075 1
a2075 1
int
d2084 2
a2085 2
			sm_dprintf("getla: pset_getloadavg failed: %s",
				   sm_errstring(errno));
d2089 1
a2089 1
		sm_dprintf("getla: %d\n", (int) (avenrun[0] +0.5));
d2097 1
a2097 1
int
d2101 1
a2101 1
		sm_dprintf("getla: ZERO\n");
d2132 1
a2132 1
SM_UNUSED(static char  rcsid[]) = "@@(#)$OrigId: getloadavg.c,v 1.16 1991/06/21 12:51:15 paul Exp $";
d2141 1
a2141 1
	caddr_t call_data;	/* pointer to (double) return value */
d2143 7
a2149 8
	double *avenrun = (double *) call_data;
	int i;
	status_$t      st;
	long loadav[3];

	proc1_$get_loadav(loadav, &st);
	*avenrun = loadav[0] / (double) (1 << 16);
	return 0;
d2153 1
a2153 1
**  SM_GETLA -- get the current load average
d2156 1
a2156 1
**		none
d2159 1
a2159 1
**		none
d2162 2
a2163 2
**		Set CurrentLA to the current load average.
**		Set {load_avg} in GlobalMacros to the current load average.
d2166 3
a2168 2
void
sm_getla()
d2170 1
a2170 1
	char labuf[8];
d2172 9
a2180 3
	CurrentLA = getla();
	(void) sm_snprintf(labuf, sizeof labuf, "%d", CurrentLA);
	macdefine(&GlobalMacros, A_TEMP, macid("{load_avg}"), labuf);
d2182 1
a2187 3
**	Note: Do NOT change this API! It is documented in op.me
**		and theoretically the user can change this function...
**
d2190 1
a2190 1
**		ct -- the message creation time (unused, but see above).
d2193 1
a2193 1
**		true -- if this message should be queued up for the
d2195 1
a2195 1
**		false -- if the load is low enough to send this message.
d2210 1
a2210 1
		sm_dprintf("shouldqueue: CurrentLA=%d, pri=%ld: ",
d2215 2
a2216 2
			sm_dprintf("false (CurrentLA < QueueLA)\n");
		return false;
d2218 1
a2218 1
# if 0	/* this code is reported to cause oscillation around RefuseLA */
d2222 2
a2223 2
			sm_dprintf("TRUE (CurrentLA >= RefuseLA)\n");
		return true;
d2225 1
a2225 1
# endif /* 0 */
d2228 1
a2228 1
		sm_dprintf("%s (by calculation)\n", rval ? "true" : "false");
a2237 1
**		active -- was this daemon actually active?
d2240 1
a2240 1
**		true if incoming SMTP connections should be refused
d2242 1
a2242 1
**		false if we should accept new work.
d2249 1
a2249 1
refuseconnections(name, e, d, active)
a2252 1
	bool active;
d2254 1
a2254 4
	static time_t lastconn[MAXDAEMONS];
	static int conncnt[MAXDAEMONS];

#if XLA
d2256 1
a2256 1
		return true;
d2259 1
a2259 29
	if (ConnRateThrottle > 0)
	{
		time_t now;

		now = curtime();
		if (active)
		{
			if (now != lastconn[d])
			{
				lastconn[d] = now;
				conncnt[d] = 1;
			}
			else if (conncnt[d]++ > ConnRateThrottle)
			{
#define D_MSG_CRT "deferring connections on daemon %s: %d per second"
				/* sleep to flatten out connection load */
				sm_setproctitle(true, e, D_MSG_CRT,
						name, ConnRateThrottle);
				if (LogLevel > 8)
					sm_syslog(LOG_INFO, NOQID, D_MSG_CRT,
						  name, ConnRateThrottle);
				(void) sleep(1);
			}
		}
		else if (now != lastconn[d])
			conncnt[d] = 0;
	}

	sm_getla();
d2262 7
a2268 23
# define R_MSG_LA "rejecting connections on daemon %s: load average: %d"
		sm_setproctitle(true, e, R_MSG_LA, name, CurrentLA);
		if (LogLevel > 8)
			sm_syslog(LOG_INFO, NOQID, R_MSG_LA, name, CurrentLA);
		return true;
	}

	if (DelayLA > 0 && CurrentLA >= DelayLA)
	{
		time_t now;
		static time_t log_delay = (time_t) 0;

# define MIN_DELAY_LOG	90	/* wait before logging this again */
# define D_MSG_LA "delaying connections on daemon %s: load average=%d >= %d"
		/* sleep to flatten out connection load */
		sm_setproctitle(true, e, D_MSG_LA, name, DelayLA);
		if (LogLevel > 8 && (now = curtime()) > log_delay)
		{
			sm_syslog(LOG_INFO, NOQID, D_MSG_LA,
				  name, CurrentLA, DelayLA);
			log_delay = now + MIN_DELAY_LOG;
		}
		(void) sleep(1);
d2276 1
a2276 2
#define R_MSG_CHILD "rejecting connections on daemon %s: %d children, max %d"
			sm_setproctitle(true, e, R_MSG_CHILD,
d2278 3
a2280 2
			if (LogLevel > 8)
				sm_syslog(LOG_INFO, NOQID, R_MSG_CHILD,
d2282 1
a2282 1
			return true;
d2285 2
a2286 1
	return false;
d2384 1
a2384 1
	register int i;
d2393 1
a2393 1
		continue;
d2437 1
a2437 1
	SM_VA_LOCAL_DECL
a2441 1
	int j;
d2444 1
a2444 1
	static pid_t kmempid = -1;
d2451 1
a2451 1
	(void) sm_strlcpy(p, "sendmail: ", SPACELEFT(buf, p));
d2455 3
a2457 3
	SM_VA_START(ap, fmt);
	(void) sm_vsnprintf(p, SPACELEFT(buf, p), fmt, ap);
	SM_VA_END(ap);
d2459 1
a2459 3
	i = (int) strlen(buf);
	if (i < 0)
		return;
d2473 1
a2473 1
	if (kmem < 0 || kmempid != CurrentPid)
d2480 2
a2481 8
		if ((j = fcntl(kmem, F_GETFD, 0)) < 0 ||
		    fcntl(kmem, F_SETFD, j | FD_CLOEXEC) < 0)
		{
			(void) close(kmem);
			kmem = -1;
			return;
		}
		kmempid = CurrentPid;
d2497 1
a2497 1
	(void) sm_strlcpy(Argv[0], buf, i + 1);
d2540 1
a2540 1
	SM_VA_LOCAL_DECL
d2543 3
a2545 3
	SM_VA_START(ap, fmt);
	(void) sm_vsnprintf(buf, sizeof buf, fmt, ap);
	SM_VA_END(ap);
d2548 1
a2548 1
		proc_list_set(CurrentPid, buf);
d2592 1
a2592 1
		savesig = sm_releasesignal(SIGCHLD);
d2597 1
a2597 1
			sm_blocksignal(SIGCHLD);
d2600 1
a2600 1
			(void) proc_list_drop(i, NULL, NULL);
a2610 39
**  SM_WAIT -- wait
**
**	Parameters:
**		status -- pointer to status (return value)
**
**	Returns:
**		pid
*/

pid_t
sm_wait(status)
	int *status;
{
# ifdef WAITUNION
	union wait st;
# else /* WAITUNION */
	auto int st;
# endif /* WAITUNION */
	pid_t i;
# if defined(ISC_UNIX) || defined(_SCO_unix_)
	int savesig;
# endif /* defined(ISC_UNIX) || defined(_SCO_unix_) */

# if defined(ISC_UNIX) || defined(_SCO_unix_)
	savesig = sm_releasesignal(SIGCHLD);
# endif /* defined(ISC_UNIX) || defined(_SCO_unix_) */
	i = wait(&st);
# if defined(ISC_UNIX) || defined(_SCO_unix_)
	if (savesig > 0)
		sm_blocksignal(SIGCHLD);
# endif /* defined(ISC_UNIX) || defined(_SCO_unix_) */
# ifdef WAITUNION
	*status = st.w_status;
# else /* WAITUNION */
	*status = st;
# endif /* WAITUNION */
	return i;
}
/*
a2621 4
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
a2628 1
	int m = 0, pld, wgrp;
d2632 1
a2632 1
# if HASWAITPID
d2641 5
d2647 3
a2649 2
# else /* HASWAITPID */
#  ifdef WNOHANG
d2655 1
a2655 1
#  else /* WNOHANG */
d2668 2
a2669 2
#  endif /* WNOHANG */
# endif /* HASWAITPID */
d2671 2
a2672 2
		pld = proc_list_drop(pid, &m, &wgrp);
		if (pld == PROC_CONTROL && WIFEXITED(st))
d2676 5
a2680 1
				RestartRequest = "control socket";
d2682 5
a2686 1
				ShutdownRequest = "control socket";
d2688 55
a2742 1
		if (pld == PROC_QUEUE_CHILD && !WIFSTOPPED(st) && wgrp > -1)
d2744 3
a2746 2
			/* restart this persistent runner */
			mark_work_group_restart(wgrp, st);
a2747 3
		else if (pld == PROC_NONE)
			m = 0;
		CurRunners -= m; /* Update */
d2749 90
a2838 3
	FIX_SYSV_SIGNAL(sig, reapchild);
	errno = save_errno;
	return SIGFUNC_RETURN;
d2840 2
d2891 1
a2891 1
	SM_FILE_T *file;
d2897 1
a2897 2
	if ((file = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, "/etc/whoami",
			       SM_IO_RDONLY, NULL)) != NULL)
d2899 2
a2900 3
		(void) sm_io_fgets(file, SM_TIME_DEFAULT, name->nodename,
				   NODE_LENGTH + 1);
		(void) sm_io_close(file, SM_TIME_DEFAULT);
d2909 1
a2909 3
	if ((file = sm_io_open(SmFtStdio, SM_TIME_DEFAULT,
			       "/usr/include/whoami.h", SM_IO_RDONLY, NULL))
	    != NULL)
d2913 1
a2913 1
		while (sm_io_fgets(file, SM_TIME_DEFAULT, buf, MAXLINE) != NULL)
d2915 1
a2915 1
			if (sm_io_sscanf(buf, "#define sysname \"%*[^\"]\"",
d2919 1
a2919 1
		(void) sm_io_close(file, SM_TIME_DEFAULT);
d2932 1
a2932 2
		(void) sm_io_fgets(file, SM_TIME_DEFAULT, name,
				   NODE_LENGTH + 1);
d3000 1
a3000 1
	return setpgid(0, CurrentPid);
d3050 1
a3050 1
#if !SM_CONF_GETOPT
d3069 2
a3070 2
**  get option letter from argument vector
*/
d3083 2
a3084 6
# define tell(s)	if (opterr) \
			{sm_io_fputs(smioerr, SM_TIME_DEFAULT, *nargv); \
			(void) sm_io_fputs(smioerr, SM_TIME_DEFAULT, s); \
			(void) sm_io_putc(smioerr, SM_TIME_DEFAULT, optopt); \
			(void) sm_io_putc(smioerr, SM_TIME_DEFAULT, '\n'); \
			return BADCH;}
d3129 1
a3129 1
	return optopt;			/* dump back option letter */
d3132 42
a3173 1
#endif /* !SM_CONF_GETOPT */
d3182 2
a3183 2
**		true -- if it is ok to use this for unrestricted access.
**		false -- if the shell is restricted.
d3262 1
a3262 1
		return true;
d3274 1
a3274 1
	register SM_FILE_T *shellf;
d3279 1
a3279 1
		return true;
d3300 1
a3300 1
				return true;
d3303 1
a3303 1
		return false;
d3307 1
a3307 2
	shellf = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, _PATH_SHELLS,
			    SM_IO_RDONLY, NULL);
d3316 1
a3316 1
				  _PATH_SHELLS, sm_errstring(errno));
d3321 1
a3321 1
				return true;
d3323 1
a3323 1
		return false;
d3326 1
a3326 1
	while (sm_io_fgets(shellf, SM_TIME_DEFAULT, buf, sizeof buf) != NULL)
d3341 2
a3342 2
			(void) sm_io_close(shellf, SM_TIME_DEFAULT);
			return true;
d3345 2
a3346 2
	(void) sm_io_close(shellf, SM_TIME_DEFAULT);
	return false;
d3368 27
a3394 27
# define SFS_NONE	0	/* no statfs implementation */
# define SFS_USTAT	1	/* use ustat */
# define SFS_4ARGS	2	/* use four-argument statfs call */
# define SFS_VFS	3	/* use <sys/vfs.h> implementation */
# define SFS_MOUNT	4	/* use <sys/mount.h> implementation */
# define SFS_STATFS	5	/* use <sys/statfs.h> implementation */
# define SFS_STATVFS	6	/* use <sys/statvfs.h> implementation */

# ifndef SFS_TYPE
#  define SFS_TYPE	SFS_NONE
# endif /* ! SFS_TYPE */

# if SFS_TYPE == SFS_USTAT
#  include <ustat.h>
# endif /* SFS_TYPE == SFS_USTAT */
# if SFS_TYPE == SFS_4ARGS || SFS_TYPE == SFS_STATFS
#  include <sys/statfs.h>
# endif /* SFS_TYPE == SFS_4ARGS || SFS_TYPE == SFS_STATFS */
# if SFS_TYPE == SFS_VFS
#  include <sys/vfs.h>
# endif /* SFS_TYPE == SFS_VFS */
# if SFS_TYPE == SFS_MOUNT
#  include <sys/mount.h>
# endif /* SFS_TYPE == SFS_MOUNT */
# if SFS_TYPE == SFS_STATVFS
#  include <sys/statvfs.h>
# endif /* SFS_TYPE == SFS_STATVFS */
d3457 3
a3459 1
**  ENOUGHDISKSPACE -- is there enough free space on the queue file systems?
d3465 1
a3465 1
**		e -- envelope, or NULL -- controls logging
d3468 2
a3469 7
**		true if in every queue group there is at least one
**		queue directory whose file system contains enough free space.
**		false otherwise.
**
**	Side Effects:
**		If there is not enough disk space and e != NULL
**		then sm_syslog is called.
d3473 1
a3473 1
enoughdiskspace(msize, e)
d3475 1
a3475 1
	ENVELOPE *e;
d3477 2
a3478 1
	int i;
d3483 2
a3484 2
			sm_dprintf("enoughdiskspace: no threshold\n");
		return true;
d3487 2
a3488 2
	filesys_update();
	for (i = 0; i < NumQueue; ++i)
d3490 24
a3513 4
		if (pickqdir(Queue[i], msize, e) < 0)
			return false;
	}
	return true;
d3525 2
a3526 2
**		true if this is probably transient.
**		false otherwise.
d3543 1
d3545 1
d3616 1
a3616 1
		return true;
d3620 1
a3620 1
	return false;
d3635 2
a3636 2
**		true if the lock was acquired.
**		false otherwise.
d3669 1
a3669 1
		sm_dprintf("lockfile(%s%s, action=%d, type=%d): ",
d3677 2
a3678 2
			sm_dprintf("SUCCESS\n");
		return true;
d3683 1
a3683 1
		sm_dprintf("(%s) ", sm_errstring(save_errno));
d3697 2
a3698 2
			sm_dprintf("SUCCESS\n");
		return true;
d3711 1
a3711 1
		dumpfd(fd, true, true);
d3718 1
a3718 1
		sm_dprintf("lockfile(%s%s, type=%o): ", filename, ext, type);
d3725 2
a3726 2
			sm_dprintf("SUCCESS\n");
		return true;
d3731 1
a3731 1
		sm_dprintf("(%s) ", sm_errstring(save_errno));
d3742 1
a3742 1
		dumpfd(fd, true, true);
d3746 1
a3746 1
		sm_dprintf("FAIL\n");
d3748 1
a3748 1
	return false;
d3798 1
a3798 1
**		true -- if the chown(2) operation is "safe" -- that is,
d3800 1
a3800 1
**		false -- if an arbitrary user can give away a file.
d3818 1
a3818 1
		return true;
d3833 1
a3833 1
# else /* (!defined(_POSIX_CHOWN_RESTRICTED) || _POSIX_CHOWN_RESTRICTED != -1) && ... */
d3835 1
a3835 1
# endif /* (!defined(_POSIX_CHOWN_RESTRICTED) || _POSIX_CHOWN_RESTRICTED != -1) && ... */
d3881 25
d3912 2
a3913 2
**		true -- if ok.
**		false -- if vendor code could not be processed.
d3926 1
a3926 1
	if (sm_strcasecmp(vendor, "Berkeley") == 0)
d3929 1
a3929 1
		return true;
d3935 1
a3935 1
	if (sm_strcasecmp(vendor, "Sun") == 0)
d3938 1
a3938 1
		return true;
d3943 1
a3943 1
	if (sm_strcasecmp(vendor, VENDOR_NAME) == 0)
d3946 1
a3946 1
		return true;
d3950 1
a3950 1
	return false;
d3979 2
a3980 2
	  case VENDOR_BERKELEY:
		return "Berkeley";
d3982 2
a3983 2
	  case VENDOR_SUN:
		return "Sun";
d3985 2
a3986 2
	  case VENDOR_HP:
		return "HP";
d3988 2
a3989 2
	  case VENDOR_IBM:
		return "IBM";
d3991 2
a3992 2
	  case VENDOR_SENDMAIL:
		return "Sendmail";
d3994 2
a3995 2
	  default:
		return "Unknown";
d4068 1
a4068 1
		finis(false, EX_USAGE);
d4125 1
d4132 1
a4132 1
#if TCPWRAPPERS
d4134 1
a4134 3
	char *addr;
	extern int hosts_ctl();
#endif /* TCPWRAPPERS */
d4137 1
a4137 1
		sm_dprintf("validate_connection(%s, %s)\n",
d4141 1
a4141 1
		    e, true, true, 3, NULL, NOQID) != EX_OK)
d4147 1
a4147 1
			sm_dprintf("  ... validate_connection: BAD (rscheck)\n");
d4150 1
a4150 1
			(void) sm_strlcpy(reject, MsgBuf, sizeof reject);
d4152 1
a4152 1
			(void) sm_strlcpy(reject, "Access denied", sizeof reject);
d4157 1
a4157 1
#if TCPWRAPPERS
d4162 1
a4162 9
	addr = anynet_ntoa(sap);

# if NETINET6
	/* TCP/Wrappers don't want the IPv6: protocol label */
	if (addr != NULL && sm_strncasecmp(addr, "IPv6:", 5) == 0)
		addr += 5;
# endif /* NETINET6 */

	if (!hosts_ctl("sendmail", host, addr, STRING_UNKNOWN))
d4165 2
a4166 2
			sm_dprintf("  ... validate_connection: BAD (tcpwrappers)\n");
		if (LogLevel > 3)
d4168 2
a4169 2
				  "tcpwrappers (%s, %s) rejection",
				  host, addr);
d4172 1
a4172 1
#endif /* TCPWRAPPERS */
d4174 1
a4174 1
		sm_dprintf("  ... validate_connection: OK\n");
d4178 1
d4194 5
a4198 5
**  Convert a string to a long integer.
**
**  Ignores `locale' stuff.  Assumes that the upper and lower case
**  alphabets and digits are each contiguous.
*/
d4213 4
a4216 4
	**  Skip white space and pick up leading +/- sign if any.
	**  If base is 0, allow 0x for hex and 0 for octal, else
	**  assume decimal; if base is already 16, allow 0x.
	*/
d4235 19
a4253 19
	**  Compute the cutoff value between legal numbers and illegal
	**  numbers.  That is the largest legal value, divided by the
	**  base.  An input number that is greater than this value, if
	**  followed by a legal input character, is too big.  One that
	**  is equal to this value may be valid or not; the limit
	**  between valid and invalid numbers is then based on the last
	**  digit.  For instance, if the range for longs is
	**  [-2147483648..2147483647] and the input base is 10,
	**  cutoff will be set to 214748364 and cutlim to either
	**  7 (neg==0) or 8 (neg==1), meaning that if we have accumulated
	**  a value > 214748364, or equal but the next digit is > 7 (or 8),
	**  the number is too big, and we will return a range error.
	**
	**  Set any if any `digits' consumed; make it negative to indicate
	**  overflow.
	*/
	cutoff = neg ? -(unsigned long) LONG_MIN : LONG_MAX;
	cutlim = cutoff % (unsigned long) base;
	cutoff /= (unsigned long) base;
d4330 1
a4330 1
#if NETINET6 && NEEDSGETIPNODE
d4352 1
a4352 1
	bool resv6 = true;
d4361 1
a4361 1
	SM_SET_H_ERRNO(0);
d4363 2
a4364 1
	if (!resv6)
a4365 1
	*err = h_errno;
d4378 1
a4378 1
	SM_SET_H_ERRNO(0);
d4384 1
d4396 2
a4397 1
#endif /* NETINET6 && NEEDSGETIPNODE */
a4403 1
	int save_errno;
d4412 1
a4412 1
		sm_dprintf("_switch_gethostbyname_r(%s)... ", name);
a4413 1
	save_errno = errno;
d4418 1
a4418 1
		sm_dprintf("__switch_gethostbyname(%s)... ", name);
a4419 1
	save_errno = errno;
d4427 1
d4433 1
a4433 1
		sm_dprintf("sm_gethostbyname(%s, %d)... ", name, family);
d4440 1
a4440 1
	SM_SET_H_ERRNO(err);
d4449 1
a4449 1
			sm_dprintf("failure\n");
d4462 1
a4462 1
			if (strlen(name) > sizeof hbuf - 1)
d4467 2
a4468 2
			(void) sm_strlcpy(hbuf, name, sizeof hbuf);
			(void) shorten_hostname(hbuf);
d4474 1
a4474 1
					sm_dprintf("sm_gethostbyname(%s, %d)... ",
d4478 4
a4481 2
				h = getipnodebyname(hbuf, family, flags, &err);
				SM_SET_H_ERRNO(err);
d4494 1
a4494 1
			sm_dprintf("failure\n");
d4497 1
a4497 1
			sm_dprintf("%s\n", h->h_name);
d4506 1
a4506 1
				size_t i;
d4511 1
a4511 1
						sm_dprintf("\talias: %s\n",
d4528 1
a4528 1
						sm_dprintf("\taddr: %s\n", addr);
a4543 11

#if NETINET6
	if (type == AF_INET6 &&
	    IN6_IS_ADDR_UNSPECIFIED((struct in6_addr *) addr))
	{
		/* Avoid reverse lookup for IPv6 unspecified address */
		SM_SET_H_ERRNO(HOST_NOT_FOUND);
		return NULL;
	}
#endif /* NETINET6 */

d4546 3
a4548 4
	{
		static struct hostent he;
		static char buf[1000];
		extern struct hostent *_switch_gethostbyaddr_r();
d4550 1
a4550 3
		hp = _switch_gethostbyaddr_r(addr, len, type, &he,
					     buf, sizeof(buf), &h_errno);
	}
d4552 1
a4552 2
	{
		extern struct hostent *__switch_gethostbyaddr();
d4554 1
a4554 2
		hp = __switch_gethostbyaddr(addr, len, type);
	}
d4558 2
a4559 2
	{
		int err;
d4561 3
a4563 3
		hp = getipnodebyaddr(addr, len, type, &err);
		SM_SET_H_ERRNO(err);
	}
d4567 1
a4568 1
	return hp;
d4574 1
d4579 1
a4579 1
#ifdef _AIX4
d4583 1
a4583 1
#else /* _AIX4 */
d4585 1
a4585 1
#endif /* _AIX4 */
d4592 1
a4592 1
#if defined(_AIX4) && 0
d4596 1
a4596 1
#else /* defined(_AIX4) && 0 */
d4598 1
a4598 1
#endif /* defined(_AIX4) && 0 */
d4635 1
a4635 2
			syserr("No protected passwd entry, uid = %d",
			       (int) uid);
d4639 1
a4639 2
			syserr("Account has been disabled, uid = %d",
			       (int) uid);
d4643 1
a4643 2
			syserr("Account has been retired, uid = %d",
			       (int) uid);
d4647 1
a4647 1
			syserr("Could not set LUID, uid = %d", (int) uid);
d4651 1
a4651 2
			syserr("Could not set kernel privs, uid = %d",
			       (int) uid);
d4655 1
a4655 1
				rc, (int) uid);
d4658 1
a4658 1
		finis(false, EX_NOPERM);
d4687 5
a4691 5
	  case AF_INET:
		hp = sm_gethostbyaddr((char *) &sa->sin.sin_addr,
				      sizeof(sa->sin.sin_addr),
				      sa->sa.sa_family);
		break;
d4695 5
a4699 5
	  case AF_INET6:
		hp = sm_gethostbyaddr((char *) &sa->sin6.sin6_addr,
				      sizeof(sa->sin6.sin6_addr),
				      sa->sa.sa_family);
		break;
d4702 7
a4708 7
	  default:
		/* Give warning about unsupported family */
		if (LogLevel > 3)
			sm_syslog(LOG_WARNING, NOQID,
				  "Unsupported address family %d: %.100s",
				  sa->sa.sa_family, anynet_ntoa(sa));
		return -1;
d4720 1
a4720 1
		    true)
d4722 2
a4723 2
				  "gethostbyaddr(%.100s) failed: %d",
				  anynet_ntoa(sa),
d4725 1
a4725 1
				  h_errno
d4727 1
a4727 1
				  -1
d4729 1
a4729 1
				 );
d4739 1
a4739 1
			sm_dprintf("\ta.k.a.: %s\n", hp->h_name);
d4741 1
a4741 1
		if (sm_snprintf(hnb, sizeof hnb, "[%s]", hp->h_name) < sizeof hnb
d4748 1
a4748 1
			sm_dprintf("\ta.k.a.: %s (already in $=w)\n", hp->h_name);
d4758 2
a4759 2
				sm_dprintf("\ta.k.a.: %s\n", *ha);
			if (sm_snprintf(hnb, sizeof hnb,
d4767 1
a4767 1
				sm_dprintf("\ta.k.a.: %s (already in $=w)\n",
d4771 1
a4771 1
#if NETINET6
d4773 1
a4773 1
#endif /* NETINET6 */
d4808 1
a4808 1
# if NETINET6 && defined(SIOCGLIFCONF)
d4820 1
a4820 1
#  ifdef SIOCGLIFNUM
d4827 1
a4827 2
			sm_dprintf("SIOCGLIFNUM failed: %s\n",
				   sm_errstring(errno));
d4834 1
a4834 1
			sm_dprintf("system has %d interfaces\n", numifs);
d4837 1
a4837 1
#  endif /* SIOCGLIFNUM */
d4852 1
a4852 2
			sm_dprintf("SIOCGLIFCONF failed: %s\n",
				   sm_errstring(errno));
d4854 1
a4854 1
		sm_free(lifc.lifc_buf);
d4860 1
a4860 1
		sm_dprintf("scanning for interface specific names, lifc_len=%d\n",
d4863 1
a4863 1
	for (i = 0; i < lifc.lifc_len && i >= 0; )
d4870 1
a4870 1
#  ifdef SIOCGLIFFLAGS
d4872 1
a4872 1
#  endif /* SIOCGLIFFLAGS */
d4888 1
a4888 1
			sm_free(lifc.lifc_buf); /* XXX */
d4900 1
a4900 1
#  ifdef BSD4_4_SOCKADDR
d4904 1
a4904 1
#  endif /* BSD4_4_SOCKADDR */
d4908 1
a4908 1
			sm_dprintf("%s\n", anynet_ntoa(sa));
d4913 1
a4913 1
#  ifdef SIOCGLIFFLAGS
d4915 1
a4915 1
		(void) sm_strlcpy(ifrf.lifr_name, ifr->lifr_name,
d4920 2
a4921 2
				sm_dprintf("SIOCGLIFFLAGS failed: %s\n",
					   sm_errstring(errno));
d4925 2
a4926 2
			sm_dprintf("\tflags: %lx\n",
				(unsigned long) ifrf.lifr_flags);
d4930 1
a4930 1
#  endif /* SIOCGLIFFLAGS */
d4938 5
a4942 4
#  ifdef __KAME__
			/* convert into proper scoped address */
			if ((IN6_IS_ADDR_LINKLOCAL(&sa->sin6.sin6_addr) ||
			     IN6_IS_ADDR_SITELOCAL(&sa->sin6.sin6_addr)) &&
d4945 3
a4947 6
				struct in6_addr *ia6p;

				ia6p = &sa->sin6.sin6_addr;
				sa->sin6.sin6_scope_id = ntohs(ia6p->s6_addr[3] |
							       ((unsigned int)ia6p->s6_addr[2] << 8));
				ia6p->s6_addr[2] = ia6p->s6_addr[3] = 0;
d4949 1
a4949 2
#  endif /* __KAME__ */
			ia6 = sa->sin6.sin6_addr;
d4962 3
a4964 4
				(void) sm_snprintf(ip_addr, sizeof ip_addr,
						   "[%.*s]",
						   (int) sizeof ip_addr - 3,
						   addr);
d4978 1
a4978 1
			(void) sm_snprintf(ip_addr, sizeof ip_addr, "[%.*s]",
d4990 1
a4990 1
				sm_dprintf("\ta.k.a.: %s\n", ip_addr);
d4993 1
a4993 1
#  ifdef SIOCGLIFFLAGS
d4995 1
a4995 2
		if (DontProbeInterfaces == DPI_SKIPLOOPBACK &&
		    bitset(IFF_LOOPBACK, ifrf.lifr_flags))
d4997 1
a4997 1
#  endif /* SIOCGLIFFLAGS */
d5000 1
a5000 1
	sm_free(lifc.lifc_buf); /* XXX */
d5002 2
a5003 2
# else /* NETINET6 && defined(SIOCGLIFCONF) */
#  if defined(SIOCGIFCONF) && !SIOCGIFCONF_IS_BROKEN
d5014 1
a5014 1
#   if defined(SIOCGIFNUM) && !SIOCGIFNUM_IS_BROKEN
d5019 1
a5019 2
			sm_dprintf("SIOCGIFNUM failed: %s\n",
				   sm_errstring(errno));
d5023 1
a5023 1
		sm_dprintf("system has %d interfaces\n", numifs);
d5025 1
a5025 1
#   endif /* defined(SIOCGIFNUM) && !SIOCGIFNUM_IS_BROKEN */
d5038 1
a5038 2
			sm_dprintf("SIOCGIFCONF failed: %s\n",
				   sm_errstring(errno));
d5040 1
d5046 1
a5046 1
		sm_dprintf("scanning for interface specific names, ifc_len=%d\n",
d5049 1
a5049 1
	for (i = 0; i < ifc.ifc_len && i >= 0; )
d5083 1
a5083 1
			sm_dprintf("%s\n", anynet_ntoa(sa));
d5095 1
a5095 1
		(void) sm_strlcpy(ifrf.ifr_name, ifr->ifr_name,
d5099 1
a5099 1
			sm_dprintf("\tflags: %lx\n",
d5125 1
a5125 1
			(void) sm_snprintf(ip_addr, sizeof ip_addr, "[%.*s]",
a5131 14
#    ifdef __KAME__
			/* convert into proper scoped address */
			if ((IN6_IS_ADDR_LINKLOCAL(&sa->sin6.sin6_addr) ||
			     IN6_IS_ADDR_SITELOCAL(&sa->sin6.sin6_addr)) &&
			    sa->sin6.sin6_scope_id == 0)
			{
				struct in6_addr *ia6p;

				ia6p = &sa->sin6.sin6_addr;
				sa->sin6.sin6_scope_id = ntohs(ia6p->s6_addr[3] |
							       ((unsigned int)ia6p->s6_addr[2] << 8));
				ia6p->s6_addr[2] = ia6p->s6_addr[3] = 0;
			}
#    endif /* __KAME__ */
d5145 3
a5147 4
				(void) sm_snprintf(ip_addr, sizeof ip_addr,
						   "[%.*s]",
						   (int) sizeof ip_addr - 3,
						   addr);
d5160 1
a5160 1
				sm_dprintf("\ta.k.a.: %s\n", ip_addr);
d5164 1
a5164 2
		if (DontProbeInterfaces == DPI_SKIPLOOPBACK &&
		    bitset(IFF_LOOPBACK, IFRFREF.ifr_flags))
d5169 1
a5169 1
	sm_free(ifc.ifc_buf); /* XXX */
d5171 3
a5173 3
#   undef IFRFREF
#  endif /* defined(SIOCGIFCONF) && !SIOCGIFCONF_IS_BROKEN */
# endif /* NETINET6 && defined(SIOCGLIFCONF) */
d5182 2
a5183 2
**		true -- is socket address in the loopback net?
**		false -- otherwise
d5193 1
a5193 1
		return true;
d5198 1
a5198 1
		return true;
d5200 1
a5200 1
	return false;
d5226 1
a5226 1
# endif /* defined(CTL_HW) && defined(HW_NCPU) */
d5264 1
a5264 1
	seed = (long) CurrentPid;
d5307 4
a5310 3
	char *newstring;
	extern int SyslogPrefixLen;
	SM_VA_LOCAL_DECL
d5312 1
a5312 1
	save_errno = errno;
a5313 1
	{
a5314 2
		idlen = strlen(id) + SyslogPrefixLen;
	}
a5315 1
	{
d5317 1
a5317 4
		idlen = SyslogPrefixLen;
	}
	else
		idlen = strlen(id) + SyslogPrefixLen;
d5327 9
a5335 1
		int n;
d5337 1
a5337 6
		/* print log message into buf */
		SM_VA_START(ap, fmt);
		n = sm_vsnprintf(buf, bufsize, fmt, ap);
		SM_VA_END(ap);
		SM_ASSERT(n > 0);
		if (n < bufsize)
d5341 1
a5341 1
		bufsize = n + 1;
d5343 2
a5344 5
		{
			sm_free(buf);
			buf = NULL;
		}
		buf = sm_malloc_x(bufsize);
d5346 1
a5346 4

	/* clean up buf after it has been expanded with args */
	newstring = str2prt(buf);
	if ((strlen(newstring) + idlen + 1) < SYSLOG_BUFSIZE)
d5350 1
a5350 1
			syslog(level, "%s", newstring);
d5352 1
a5352 1
			syslog(level, "%s: %s", id, newstring);
d5356 1
a5356 2
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT, "%s\n",
					     newstring);
d5358 1
a5358 2
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
					     "%s: %s\n", id, newstring);
d5366 1
a5366 9
/*
**  additional length for splitting: " ..." + 3, where 3 is magic to
**  have some data for the next entry.
*/

#define SL_SPLIT 7

	begin = newstring;
	idlen += 5;	/* strlen("[999]"), see below */
d5368 1
a5368 1
	       (strlen(begin) + idlen) > SYSLOG_BUFSIZE)
d5372 1
a5372 1
		if (seq >= 999)
d5377 1
a5377 1
		end = begin + SYSLOG_BUFSIZE - idlen - SL_SPLIT;
d5390 1
a5390 1
			end = begin + SYSLOG_BUFSIZE - idlen - SL_SPLIT;
d5396 1
a5396 2
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				     "%s[%d]: %s ...\n", id, seq++, begin);
d5401 1
a5401 1
	if (seq >= 999)
d5406 2
a5407 2
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
			      "%s[%d]: log terminated, too many parts\n", id, seq);
d5413 1
a5413 2
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				     "%s[%d]: %s\n", id, seq, begin);
d5450 1
a5450 1
	SM_VA_LOCAL_DECL
d5452 3
a5454 3
	SM_VA_START(ap, msg);
	(void) sm_vsnprintf(buf, sizeof buf, msg, ap);
	SM_VA_END(ap);
d5478 1
a5478 1
	size_t len_host, len_domain;
d5485 1
a5485 1
	    (sm_strcasecmp(hostname + len_host - len_domain,
d5500 1
a5500 9
#if NAMED_BIND
# if DNSMAP
	"DNSMAP",
# endif /* DNSMAP */
#endif /* NAMED_BIND */
#if EGD
	"EGD",
#endif /* EGD */
#if HESIOD
d5506 1
a5506 1
#if LDAPMAP
d5509 1
a5509 4
#if LOG
	"LOG",
#endif /* LOG */
#if MAP_NSD
d5512 1
a5512 1
#if MAP_REGEX
d5515 3
a5520 3
#if MILTER
	"MILTER",
#endif /* MILTER */
d5530 1
a5530 1
#if NDBM
d5554 1
a5554 1
#if NEWDB
d5557 1
a5557 1
#if NIS
d5560 1
a5560 1
#if NISPLUS
d5563 1
a5563 4
#if NO_DH
	"NO_DH",
#endif /* NO_DH */
#if PH_MAP
d5566 3
a5568 6
#ifdef PICKY_HELO_CHECK
	"PICKY_HELO_CHECK",
#endif /* PICKY_HELO_CHECK */
#if PIPELINING
	"PIPELINING",
#endif /* PIPELINING */
d5575 6
d5587 1
a5587 1
#if SUID_ROOT_FILES_OK
a5592 6
#if TLS_NO_RSA
	"TLS_NO_RSA",
#endif /* TLS_NO_RSA */
#if TLS_VRFY_PER_CTX
	"TLS_VRFY_PER_CTX",
#endif /* TLS_VRFY_PER_CTX */
d5599 1
a5599 1
#if XLA
a5611 15
#if ADDRCONFIG_IS_BROKEN
	"ADDRCONFIG_IS_BROKEN",
#endif /* ADDRCONFIG_IS_BROKEN */
#ifdef AUTO_NETINFO_HOSTS
	"AUTO_NETINFO_HOSTS",
#endif /* AUTO_NETINFO_HOSTS */
#ifdef AUTO_NIS_ALIASES
	"AUTO_NIS_ALIASES",
#endif /* AUTO_NIS_ALIASES */
#if BROKEN_RES_SEARCH
	"BROKEN_RES_SEARCH",
#endif /* BROKEN_RES_SEARCH */
#ifdef BSD4_4_SOCKADDR
	"BSD4_4_SOCKADDR",
#endif /* BSD4_4_SOCKADDR */
a5614 3
#if DEC_OSF_BROKEN_GETPWENT
	"DEC_OSF_BROKEN_GETPWENT",
#endif /* DEC_OSF_BROKEN_GETPWENT */
d5660 3
a5698 15
#if NEEDLOCAL_HOSTNAME_LENGTH
	"NEEDLOCAL_HOSTNAME_LENGTH",
#endif /* NEEDLOCAL_HOSTNAME_LENGTH */
#if NEEDSGETIPNODE
	"NEEDSGETIPNODE",
#endif /* NEEDSGETIPNODE */
#if NEEDSTRSTR
	"NEEDSTRSTR",
#endif /* NEEDSTRSTR */
#if NEEDSTRTOL
	"NEEDSTRTOL",
#endif /* NEEDSTRTOL */
#ifdef NO_GETSERVBYNAME
	"NO_GETSERVBYNAME",
#endif /* NO_GETSERVBYNAME */
a5701 3
#if REQUIRES_DIR_FSYNC
	"REQUIRES_DIR_FSYNC",
#endif /* REQUIRES_DIR_FSYNC */
a5737 3
#if USEGETCONFATTR
	"USEGETCONFATTR",
#endif /* USEGETCONFATTR */
a5740 125
#ifdef USESYSCTL
	"USESYSCTL",
#endif /* USESYSCTL */
#if USING_NETSCAPE_LDAP
	"USING_NETSCAPE_LDAP",
#endif /* USING_NETSCAPE_LDAP */
#ifdef WAITUNION
	"WAITUNION",
#endif /* WAITUNION */
	NULL
};

/*
**  FFR compile options.
*/

char	*FFRCompileOptions[] =
{
#if _FFR_ADAPTIVE_EOL
	"_FFR_ADAPTIVE_EOL",
#endif /* _FFR_ADAPTIVE_EOL */
#if _FFR_ALLOW_SASLINFO
	"_FFR_ALLOW_SASLINFO",
#endif /* _FFR_ALLOW_SASLINFO */
#if _FFR_BESTMX_BETTER_TRUNCATION
	"_FFR_BESTMX_BETTER_TRUNCATION",
#endif /* _FFR_BESTMX_BETTER_TRUNCATION */
#if _FFR_CACHE_LPC
	"_FFR_CACHE_LPC",
#endif /* _FFR_CACHE_LPC */
#if _FFR_CATCH_BROKEN_MTAS
	"_FFR_CATCH_BROKEN_MTAS",
#endif /* _FFR_CATCH_BROKEN_MTAS */
#if _FFR_CHECK_EOM
	"_FFR_CHECK_EOM",
#endif /* _FFR_CHECK_EOM */
#if _FFR_CONTROL_MSTAT
	"_FFR_CONTROL_MSTAT",
#endif /* _FFR_CONTROL_MSTAT */
#if _FFR_DAEMON_NETUNIX
	"_FFR_DAEMON_NETUNIX",
#endif /* _FFR_DAEMON_NETUNIX */
#if _FFR_DEPRECATE_MAILER_FLAG_I
	"_FFR_DEPRECATE_MAILER_FLAG_I",
#endif /* _FFR_DEPRECATE_MAILER_FLAG_I */
#if _FFR_DNSMAP_BASE
	"_FFR_DNSMAP_BASE",
#endif /* _FFR_DNSMAP_BASE */
#if _FFR_DNSMAP_MULTI
	"_FFR_DNSMAP_MULTI",
# if _FFR_DNSMAP_MULTILIMIT
	"_FFR_DNSMAP_MULTILIMIT",
# endif /* _FFR_DNSMAP_MULTILIMIT */
#endif /* _FFR_DNSMAP_MULTI */
#if _FFR_DONTLOCKFILESFORREAD_OPTION
	"_FFR_DONTLOCKFILESFORREAD_OPTION",
#endif /* _FFR_DONTLOCKFILESFORREAD_OPTION */
#if _FFR_FIX_DASHT
	"_FFR_FIX_DASHT",
#endif /* _FFR_FIX_DASHT */
#if _FFR_FORWARD_SYSERR
	"_FFR_FORWARD_SYSERR",
#endif /* _FFR_FORWARD_SYSERR */
#if _FFR_GEN_ORCPT
	"_FFR_GEN_ORCPT",
#endif /* _FFR_GEN_ORCPT */
#if _FFR_GROUPREADABLEAUTHINFOFILE
	"_FFR_GROUPREADABLEAUTHINFOFILE",
#endif /* _FFR_GROUPREADABLEAUTHINFOFILE */
#if _FFR_HDR_TYPE
	"_FFR_HDR_TYPE",
#endif /* _FFR_HDR_TYPE */
#if _FFR_IGNORE_EXT_ON_HELO
	"_FFR_IGNORE_EXT_ON_HELO",
#endif /* _FFR_IGNORE_EXT_ON_HELO */
#if _FFR_MAX_FORWARD_ENTRIES
	"_FFR_MAX_FORWARD_ENTRIES",
#endif /* _FFR_MAX_FORWARD_ENTRIES */
#if MILTER
# if  _FFR_MILTER_PERDAEMON
	"_FFR_MILTER_PERDAEMON",
# endif /* _FFR_MILTER_PERDAEMON */
#endif /* MILTER */
#if _FFR_NODELAYDSN_ON_HOLD
	"_FFR_NODELAYDSN_ON_HOLD",
#endif /* _FFR_NODELAYDSN_ON_HOLD */
#if _FFR_NO_PIPE
	"_FFR_NO_PIPE",
#endif /* _FFR_NO_PIPE */
#if _FFR_QUEUEDELAY
	"_FFR_QUEUEDELAY",
#endif /* _FFR_QUEUEDELAY */
#if _FFR_QUEUE_MACRO
	"_FFR_QUEUE_MACRO",
#endif /* _FFR_QUEUE_MACRO */
#if _FFR_QUEUE_SCHED_DBG
	"_FFR_QUEUE_SCHED_DBG",
#endif /* _FFR_QUEUE_SCHED_DBG */
#if _FFR_REDIRECTEMPTY
	"_FFR_REDIRECTEMPTY",
#endif /* _FFR_REDIRECTEMPTY */
#if _FFR_RESET_MACRO_GLOBALS
	"_FFR_RESET_MACRO_GLOBALS",
#endif /* _FFR_RESET_MACRO_GLOBALS */
#if _FFR_RHS
	"_FFR_RHS",
#endif /* _FFR_RHS */
#if _FFR_SAVE_CHARSET
	"_FFR_SAVE_CHARSET",
#endif /* _FFR_SAVE_CHARSET */
#if _FFR_SHM_STATUS
	"_FFR_SHM_STATUS",
#endif /* _FFR_SHM_STATUS */
#if _FFR_SMTP_SSL
	"_FFR_SMTP_SSL",
#endif /* _FFR_SMTP_SSL */
#if _FFR_SOFT_BOUNCE
	"_FFR_SOFT_BOUNCE",
#endif /* _FFR_SOFT_BOUNCE */
#if _FFR_TIMERS
	"_FFR_TIMERS",
#endif /* _FFR_TIMERS */
#if _FFR_TLS_1
	"_FFR_TLS_1",
#endif /* _FFR_TLS_1 */
@


