head	1.31;
access;
symbols
	OPENBSD_5_6:1.30.0.6
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.29.0.4
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.2
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.28.0.6
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.4
	OPENBSD_5_0:1.28.0.2
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.27.0.12
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.10
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.6
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.8
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.4
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.26.0.4
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.2
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.25.0.2
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.22.0.4
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.30;
commitid	M7i5giHIoz3DMlTU;

1.30
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2012.12.26.11.44.12;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2011.05.17.15.54.23;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2007.04.04.14.43.48;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2006.08.13.13.01.48;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.22.18.43.55;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.08.16.00.50;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.16.00.21.30;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2004.09.18.04.08.34;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.24.03.59.27;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.19.01.41.13;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.17.17.31.40;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.03.17.31.21;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.01.19.59.22;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.26.04.48.55;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.03.17.25.47;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.18.00.49.28;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.01.01.01.41;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.29.01.31.14;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.28.02.43.53;	author millert;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.01.16.01.38.37;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.15.21.09.08;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.18.00.04.21;	author itojun;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.04.07.19.20.40;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.02.19.05.44;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.44;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.13;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.50;	author millert;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.31.00.31.32;	author miod;	state Exp;
branches;
next	;

1.6.2.1
date	2001.05.31.01.47.56;	author jason;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2007, 2009, 2010 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>
#include "map.h"

SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.698 2013/11/22 20:51:55 ca Exp $")

#if defined(SOCK_STREAM) || defined(__GNU_LIBRARY__)
# define USE_SOCK_STREAM	1
#endif /* defined(SOCK_STREAM) || defined(__GNU_LIBRARY__) */

#if defined(USE_SOCK_STREAM)
# if NETINET || NETINET6
#  include <arpa/inet.h>
# endif /* NETINET || NETINET6 */
# if NAMED_BIND
#  ifndef NO_DATA
#   define NO_DATA	NO_ADDRESS
#  endif /* ! NO_DATA */
# endif /* NAMED_BIND */
#endif /* defined(USE_SOCK_STREAM) */

#if STARTTLS
#  include <openssl/rand.h>
#endif /* STARTTLS */

#include <sm/time.h>

#if IP_SRCROUTE && NETINET
# include <netinet/in_systm.h>
# include <netinet/ip.h>
# if HAS_IN_H
#  include <netinet/in.h>
#  ifndef IPOPTION
#   define IPOPTION	ip_opts
#   define IP_LIST	ip_opts
#   define IP_DST	ip_dst
#  endif /* ! IPOPTION */
# else /* HAS_IN_H */
#  include <netinet/ip_var.h>
#  ifndef IPOPTION
#   define IPOPTION	ipoption
#   define IP_LIST	ipopt_list
#   define IP_DST	ipopt_dst
#  endif /* ! IPOPTION */
# endif /* HAS_IN_H */
#endif /* IP_SRCROUTE && NETINET */

#include <sm/fdset.h>

#define DAEMON_C 1
#include <daemon.h>

static void		connecttimeout __P((int));
static int		opendaemonsocket __P((DAEMON_T *, bool));
static unsigned short	setupdaemon __P((SOCKADDR *));
static void		getrequests_checkdiskspace __P((ENVELOPE *e));
static void		setsockaddroptions __P((char *, DAEMON_T *));
static void		printdaemonflags __P((DAEMON_T *));
static int		addr_family __P((char *));
static int		addrcmp __P((struct hostent *, char *, SOCKADDR *));
static void		authtimeout __P((int));

/*
**  DAEMON.C -- routines to use when running as a daemon.
**
**	This entire file is highly dependent on the 4.2 BSD
**	interprocess communication primitives.  No attempt has
**	been made to make this file portable to Version 7,
**	Version 6, MPX files, etc.  If you should try such a
**	thing yourself, I recommend chucking the entire file
**	and starting from scratch.  Basic semantics are:
**
**	getrequests(e)
**		Opens a port and initiates a connection.
**		Returns in a child.  Must set InChannel and
**		OutChannel appropriately.
**	clrdaemon()
**		Close any open files associated with getting
**		the connection; this is used when running the queue,
**		etc., to avoid having extra file descriptors during
**		the queue run and to avoid confusing the network
**		code (if it cares).
**	makeconnection(host, port, mci, e, enough)
**		Make a connection to the named host on the given
**		port. Returns zero on success, else an exit status
**		describing the error.
**	host_map_lookup(map, hbuf, avp, pstat)
**		Convert the entry in hbuf into a canonical form.
*/

static int	NDaemons = 0;			/* actual number of daemons */

static time_t	NextDiskSpaceCheck = 0;

/*
**  GETREQUESTS -- open mail IPC port and get requests.
**
**	Parameters:
**		e -- the current envelope.
**
**	Returns:
**		pointer to flags.
**
**	Side Effects:
**		Waits until some interesting activity occurs.  When
**		it does, a child is created to process it, and the
**		parent waits for completion.  Return from this
**		routine is always in the child.  The file pointers
**		"InChannel" and "OutChannel" should be set to point
**		to the communication channel.
**		May restart persistent queue runners if they have ended
**		for some reason.
*/

BITMAP256 *
getrequests(e)
	ENVELOPE *e;
{
	int t;
	int idx, curdaemon = -1;
	int i, olddaemon = 0;
#if XDEBUG
	bool j_has_dot;
#endif /* XDEBUG */
	char status[MAXLINE];
	SOCKADDR sa;
	SOCKADDR_LEN_T len = sizeof(sa);
#if _FFR_QUEUE_RUN_PARANOIA
	time_t lastrun;
#endif /* _FFR_QUEUE_RUN_PARANOIA */
# if NETUNIX
	extern int ControlSocket;
# endif /* NETUNIX */
	extern ENVELOPE BlankEnvelope;


	/* initialize data for function that generates queue ids */
	init_qid_alg();
	for (idx = 0; idx < NDaemons; idx++)
	{
		Daemons[idx].d_port = setupdaemon(&(Daemons[idx].d_addr));
		Daemons[idx].d_firsttime = true;
		Daemons[idx].d_refuse_connections_until = (time_t) 0;
	}

	/*
	**  Try to actually open the connection.
	*/

	if (tTd(15, 1))
	{
		for (idx = 0; idx < NDaemons; idx++)
		{
			sm_dprintf("getrequests: daemon %s: port %d\n",
				   Daemons[idx].d_name,
				   ntohs(Daemons[idx].d_port));
		}
	}

	/* get a socket for the SMTP connection */
	for (idx = 0; idx < NDaemons; idx++)
		Daemons[idx].d_socksize = opendaemonsocket(&Daemons[idx], true);

	if (opencontrolsocket() < 0)
		sm_syslog(LOG_WARNING, NOQID,
			  "daemon could not open control socket %s: %s",
			  ControlSocketName, sm_errstring(errno));

	/* If there are any queue runners released reapchild() co-ord's */
	(void) sm_signal(SIGCHLD, reapchild);

	/* write the pid to file, command line args to syslog */
	log_sendmail_pid(e);

#if XDEBUG
	{
		char jbuf[MAXHOSTNAMELEN];

		expand("\201j", jbuf, sizeof(jbuf), e);
		j_has_dot = strchr(jbuf, '.') != NULL;
	}
#endif /* XDEBUG */

	/* Add parent process as first item */
	proc_list_add(CurrentPid, "Sendmail daemon", PROC_DAEMON, 0, -1, NULL);

	if (tTd(15, 1))
	{
		for (idx = 0; idx < NDaemons; idx++)
			sm_dprintf("getrequests: daemon %s: socket %d\n",
				Daemons[idx].d_name,
				Daemons[idx].d_socket);
	}

	for (;;)
	{
		register pid_t pid;
		auto SOCKADDR_LEN_T lotherend;
		bool timedout = false;
		bool control = false;
		int save_errno;
		int pipefd[2];
		time_t now;
#if STARTTLS
		long seed;
#endif /* STARTTLS */

		/* see if we are rejecting connections */
		(void) sm_blocksignal(SIGALRM);
		CHECK_RESTART;

		for (idx = 0; idx < NDaemons; idx++)
		{
			/*
			**  XXX do this call outside the loop?
			**	no: refuse_connections may sleep().
			*/

			now = curtime();
			if (now < Daemons[idx].d_refuse_connections_until)
				continue;
			if (bitnset(D_DISABLE, Daemons[idx].d_flags))
				continue;
			if (refuseconnections(e, idx, curdaemon == idx))
			{
				if (Daemons[idx].d_socket >= 0)
				{
					/* close socket so peer fails quickly */
					(void) close(Daemons[idx].d_socket);
					Daemons[idx].d_socket = -1;
				}

				/* refuse connections for next 15 seconds */
				Daemons[idx].d_refuse_connections_until = now + 15;
			}
			else if (Daemons[idx].d_socket < 0 ||
				 Daemons[idx].d_firsttime)
			{
				if (!Daemons[idx].d_firsttime && LogLevel > 8)
					sm_syslog(LOG_INFO, NOQID,
						"accepting connections again for daemon %s",
						Daemons[idx].d_name);

				/* arrange to (re)open the socket if needed */
				(void) opendaemonsocket(&Daemons[idx], false);
				Daemons[idx].d_firsttime = false;
			}
		}

		/* May have been sleeping above, check again */
		CHECK_RESTART;

		getrequests_checkdiskspace(e);

#if XDEBUG
		/* check for disaster */
		{
			char jbuf[MAXHOSTNAMELEN];

			expand("\201j", jbuf, sizeof(jbuf), e);
			if (!wordinclass(jbuf, 'w'))
			{
				dumpstate("daemon lost $j");
				sm_syslog(LOG_ALERT, NOQID,
					  "daemon process doesn't have $j in $=w; see syslog");
				abort();
			}
			else if (j_has_dot && strchr(jbuf, '.') == NULL)
			{
				dumpstate("daemon $j lost dot");
				sm_syslog(LOG_ALERT, NOQID,
					  "daemon process $j lost dot; see syslog");
				abort();
			}
		}
#endif /* XDEBUG */

#if 0
		/*
		**  Andrew Sun <asun@@ieps-sun.ml.com> claims that this will
		**  fix the SVr4 problem.  But it seems to have gone away,
		**  so is it worth doing this?
		*/

		if (DaemonSocket >= 0 &&
		    SetNonBlocking(DaemonSocket, false) < 0)
			log an error here;
#endif /* 0 */
		(void) sm_releasesignal(SIGALRM);

		for (;;)
		{
			bool setproc = false;
			int highest = -1;
			fd_set readfds;
			struct timeval timeout;

			CHECK_RESTART;
			FD_ZERO(&readfds);
			for (idx = 0; idx < NDaemons; idx++)
			{
				/* wait for a connection */
				if (Daemons[idx].d_socket >= 0)
				{
					if (!setproc &&
					    !bitnset(D_ETRNONLY,
						     Daemons[idx].d_flags))
					{
						sm_setproctitle(true, e,
								"accepting connections");
						setproc = true;
					}
					if (Daemons[idx].d_socket > highest)
						highest = Daemons[idx].d_socket;
					SM_FD_SET(Daemons[idx].d_socket,
						  &readfds);
				}
			}

#if NETUNIX
			if (ControlSocket >= 0)
			{
				if (ControlSocket > highest)
					highest = ControlSocket;
				SM_FD_SET(ControlSocket, &readfds);
			}
#endif /* NETUNIX */

			timeout.tv_sec = 5;
			timeout.tv_usec = 0;

			t = select(highest + 1, FDSET_CAST &readfds,
				   NULL, NULL, &timeout);

			/* Did someone signal while waiting? */
			CHECK_RESTART;

			curdaemon = -1;
			if (doqueuerun())
			{
				(void) runqueue(true, false, false, false);
#if _FFR_QUEUE_RUN_PARANOIA
				lastrun = now;
#endif /* _FFR_QUEUE_RUN_PARANOIA */
			}
#if _FFR_QUEUE_RUN_PARANOIA
			else if (CheckQueueRunners > 0 && QueueIntvl > 0 &&
				 lastrun + QueueIntvl + CheckQueueRunners < now)
			{

				/*
				**  set lastrun unconditionally to avoid
				**  calling checkqueuerunner() all the time.
				**  That's also why we currently ignore the
				**  result of the function call.
				*/

				(void) checkqueuerunner();
				lastrun = now;
			}
#endif /* _FFR_QUEUE_RUN_PARANOIA */

			if (t <= 0)
			{
				timedout = true;
				break;
			}

			control = false;
			errno = 0;

			/* look "round-robin" for an active socket */
			if ((idx = olddaemon + 1) >= NDaemons)
				idx = 0;
			for (i = 0; i < NDaemons; i++)
			{
				if (Daemons[idx].d_socket >= 0 &&
				    SM_FD_ISSET(Daemons[idx].d_socket,
						&readfds))
				{
					lotherend = Daemons[idx].d_socksize;
					memset(&RealHostAddr, '\0',
					       sizeof(RealHostAddr));
					t = accept(Daemons[idx].d_socket,
						   (struct sockaddr *)&RealHostAddr,
						   &lotherend);

					/*
					**  If remote side closes before
					**  accept() finishes, sockaddr
					**  might not be fully filled in.
					*/

					if (t >= 0 &&
					    (lotherend == 0 ||
# ifdef BSD4_4_SOCKADDR
					     RealHostAddr.sa.sa_len == 0 ||
# endif /* BSD4_4_SOCKADDR */
					     RealHostAddr.sa.sa_family != Daemons[idx].d_addr.sa.sa_family))
					{
						(void) close(t);
						t = -1;
						errno = EINVAL;
					}
					olddaemon = curdaemon = idx;
					break;
				}
				if (++idx >= NDaemons)
					idx = 0;
			}
#if NETUNIX
			if (curdaemon == -1 && ControlSocket >= 0 &&
			    SM_FD_ISSET(ControlSocket, &readfds))
			{
				struct sockaddr_un sa_un;

				lotherend = sizeof(sa_un);
				memset(&sa_un, '\0', sizeof(sa_un));
				t = accept(ControlSocket,
					   (struct sockaddr *)&sa_un,
					   &lotherend);

				/*
				**  If remote side closes before
				**  accept() finishes, sockaddr
				**  might not be fully filled in.
				*/

				if (t >= 0 &&
				    (lotherend == 0 ||
# ifdef BSD4_4_SOCKADDR
				     sa_un.sun_len == 0 ||
# endif /* BSD4_4_SOCKADDR */
				     sa_un.sun_family != AF_UNIX))
				{
					(void) close(t);
					t = -1;
					errno = EINVAL;
				}
				if (t >= 0)
					control = true;
			}
#else /* NETUNIX */
			if (curdaemon == -1)
			{
				/* No daemon to service */
				continue;
			}
#endif /* NETUNIX */
			if (t >= 0 || errno != EINTR)
				break;
		}
		if (timedout)
		{
			timedout = false;
			continue;
		}
		save_errno = errno;
		(void) sm_blocksignal(SIGALRM);
		if (t < 0)
		{
			errno = save_errno;

			/* let's ignore these temporary errors */
			if (save_errno == EINTR
#ifdef EAGAIN
			    || save_errno == EAGAIN
#endif /* EAGAIN */
#ifdef ECONNABORTED
			    || save_errno == ECONNABORTED
#endif /* ECONNABORTED */
#ifdef EWOULDBLOCK
			    || save_errno == EWOULDBLOCK
#endif /* EWOULDBLOCK */
			   )
				continue;

			syserr("getrequests: accept");

			if (curdaemon >= 0)
			{
				/* arrange to re-open socket next time around */
				(void) close(Daemons[curdaemon].d_socket);
				Daemons[curdaemon].d_socket = -1;
#if SO_REUSEADDR_IS_BROKEN
				/*
				**  Give time for bound socket to be released.
				**  This creates a denial-of-service if you can
				**  force accept() to fail on affected systems.
				*/

				Daemons[curdaemon].d_refuse_connections_until =
					curtime() + 15;
#endif /* SO_REUSEADDR_IS_BROKEN */
			}
			continue;
		}

		if (!control)
		{
			/* set some daemon related macros */
			switch (Daemons[curdaemon].d_addr.sa.sa_family)
			{
			  case AF_UNSPEC:
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{daemon_family}"), "unspec");
				break;
#if _FFR_DAEMON_NETUNIX
# if NETUNIX
			  case AF_UNIX:
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{daemon_family}"), "local");
				break;
# endif /* NETUNIX */
#endif /* _FFR_DAEMON_NETUNIX */
#if NETINET
			  case AF_INET:
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{daemon_family}"), "inet");
				break;
#endif /* NETINET */
#if NETINET6
			  case AF_INET6:
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{daemon_family}"), "inet6");
				break;
#endif /* NETINET6 */
#if NETISO
			  case AF_ISO:
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{daemon_family}"), "iso");
				break;
#endif /* NETISO */
#if NETNS
			  case AF_NS:
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{daemon_family}"), "ns");
				break;
#endif /* NETNS */
#if NETX25
			  case AF_CCITT:
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{daemon_family}"), "x.25");
				break;
#endif /* NETX25 */
			}
			macdefine(&BlankEnvelope.e_macro, A_PERM,
				macid("{daemon_name}"),
				Daemons[curdaemon].d_name);
			if (Daemons[curdaemon].d_mflags != NULL)
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{daemon_flags}"),
					Daemons[curdaemon].d_mflags);
			else
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{daemon_flags}"), "");
		}

		/*
		**  If connection rate is exceeded here, connection shall be
		**  refused later by a new call after fork() by the
		**  validate_connection() function. Closing the connection
		**  at this point violates RFC 2821.
		**  Do NOT remove this call, its side effects are needed.
		*/

		connection_rate_check(&RealHostAddr, NULL);

		/*
		**  Create a subprocess to process the mail.
		*/

		if (tTd(15, 2))
			sm_dprintf("getrequests: forking (fd = %d)\n", t);

		/*
		**  Advance state of PRNG.
		**  This is necessary because otherwise all child processes
		**  will produce the same PRN sequence and hence the selection
		**  of a queue directory (and other things, e.g., MX selection)
		**  are not "really" random.
		*/
#if STARTTLS
		/* XXX get some better "random" data? */
		seed = get_random();
		RAND_seed((void *) &NextDiskSpaceCheck,
			  sizeof(NextDiskSpaceCheck));
		RAND_seed((void *) &now, sizeof(now));
		RAND_seed((void *) &seed, sizeof(seed));
#else /* STARTTLS */
		(void) get_random();
#endif /* STARTTLS */

#if NAMED_BIND
		/*
		**  Update MX records for FallbackMX.
		**  Let's hope this is fast otherwise we screw up the
		**  response time.
		*/

		if (FallbackMX != NULL)
			(void) getfallbackmxrr(FallbackMX);
#endif /* NAMED_BIND */

		if (tTd(93, 100))
		{
			/* don't fork, handle connection in this process */
			pid = 0;
			pipefd[0] = pipefd[1] = -1;
		}
		else
		{
			/*
			**  Create a pipe to keep the child from writing to
			**  the socket until after the parent has closed
			**  it.  Otherwise the parent may hang if the child
			**  has closed it first.
			*/

			if (pipe(pipefd) < 0)
				pipefd[0] = pipefd[1] = -1;

			(void) sm_blocksignal(SIGCHLD);
			pid = fork();
			if (pid < 0)
			{
				syserr("daemon: cannot fork");
				if (pipefd[0] != -1)
				{
					(void) close(pipefd[0]);
					(void) close(pipefd[1]);
				}
				(void) sm_releasesignal(SIGCHLD);
				(void) sleep(10);
				(void) close(t);
				continue;
			}
		}

		if (pid == 0)
		{
			char *p;
			SM_FILE_T *inchannel, *outchannel = NULL;

			/*
			**  CHILD -- return to caller.
			**	Collect verified idea of sending host.
			**	Verify calling user id if possible here.
			*/

			/* Reset global flags */
			RestartRequest = NULL;
			RestartWorkGroup = false;
			ShutdownRequest = NULL;
			PendingSignal = 0;
			CurrentPid = getpid();
			close_sendmail_pid();

			(void) sm_releasesignal(SIGALRM);
			(void) sm_releasesignal(SIGCHLD);
			(void) sm_signal(SIGCHLD, SIG_DFL);
			(void) sm_signal(SIGHUP, SIG_DFL);
			(void) sm_signal(SIGTERM, intsig);

			/* turn on profiling */
			/* SM_PROF(0); */

			/*
			**  Initialize exception stack and default exception
			**  handler for child process.
			*/

			sm_exc_newthread(fatal_error);

			if (!control)
			{
				macdefine(&BlankEnvelope.e_macro, A_TEMP,
					macid("{daemon_addr}"),
					anynet_ntoa(&Daemons[curdaemon].d_addr));
				(void) sm_snprintf(status, sizeof(status), "%d",
						ntohs(Daemons[curdaemon].d_port));
				macdefine(&BlankEnvelope.e_macro, A_TEMP,
					macid("{daemon_port}"), status);
			}

			for (idx = 0; idx < NDaemons; idx++)
			{
				if (Daemons[idx].d_socket >= 0)
					(void) close(Daemons[idx].d_socket);
				Daemons[idx].d_socket = -1;
			}
			clrcontrol();

			/* Avoid SMTP daemon actions if control command */
			if (control)
			{
				/* Add control socket process */
				proc_list_add(CurrentPid,
					      "console socket child",
					      PROC_CONTROL_CHILD, 0, -1, NULL);
			}
			else
			{
				proc_list_clear();

				/* clean up background delivery children */
				(void) sm_signal(SIGCHLD, reapchild);

				/* Add parent process as first child item */
				proc_list_add(CurrentPid, "daemon child",
					      PROC_DAEMON_CHILD, 0, -1, NULL);
				/* don't schedule queue runs if ETRN */
				QueueIntvl = 0;

				/*
				**  Hack: override global variables if
				**	the corresponding DaemonPortOption
				**	is set.
				*/
#if _FFR_SS_PER_DAEMON
				if (Daemons[curdaemon].d_supersafe !=
				    DPO_NOTSET)
					SuperSafe = Daemons[curdaemon].
								d_supersafe;
#endif /* _FFR_SS_PER_DAEMON */
				if (Daemons[curdaemon].d_dm != DM_NOTSET)
					set_delivery_mode(
						Daemons[curdaemon].d_dm, e);

				if (Daemons[curdaemon].d_refuseLA !=
				    DPO_NOTSET)
					RefuseLA = Daemons[curdaemon].
								d_refuseLA;
				if (Daemons[curdaemon].d_queueLA != DPO_NOTSET)
					QueueLA = Daemons[curdaemon].d_queueLA;
				if (Daemons[curdaemon].d_delayLA != DPO_NOTSET)
					DelayLA = Daemons[curdaemon].d_delayLA;
				if (Daemons[curdaemon].d_maxchildren !=
				    DPO_NOTSET)
					MaxChildren = Daemons[curdaemon].
								d_maxchildren;

				sm_setproctitle(true, e, "startup with %s",
						anynet_ntoa(&RealHostAddr));
			}

			if (pipefd[0] != -1)
			{
				auto char c;

				/*
				**  Wait for the parent to close the write end
				**  of the pipe, which we will see as an EOF.
				**  This guarantees that we won't write to the
				**  socket until after the parent has closed
				**  the pipe.
				*/

				/* close the write end of the pipe */
				(void) close(pipefd[1]);

				/* we shouldn't be interrupted, but ... */
				while (read(pipefd[0], &c, 1) < 0 &&
				       errno == EINTR)
					continue;
				(void) close(pipefd[0]);
			}

			/* control socket processing */
			if (control)
			{
				control_command(t, e);
				/* NOTREACHED */
				exit(EX_SOFTWARE);
			}

			/* determine host name */
			p = hostnamebyanyaddr(&RealHostAddr);
			if (strlen(p) > MAXNAME) /* XXX  - 1 ? */
				p[MAXNAME] = '\0';
			RealHostName = newstr(p);
			if (RealHostName[0] == '[')
			{
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{client_resolve}"),
					h_errno == TRY_AGAIN ? "TEMP" : "FAIL");
			}
			else
			{
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					  macid("{client_resolve}"), "OK");
			}
			sm_setproctitle(true, e, "startup with %s", p);
			markstats(e, NULL, STATS_CONNECT);

			if ((inchannel = sm_io_open(SmFtStdiofd,
						    SM_TIME_DEFAULT,
						    (void *) &t,
						    SM_IO_RDONLY_B,
						    NULL)) == NULL ||
			    (t = dup(t)) < 0 ||
			    (outchannel = sm_io_open(SmFtStdiofd,
						     SM_TIME_DEFAULT,
						     (void *) &t,
						     SM_IO_WRONLY_B,
						     NULL)) == NULL)
			{
				syserr("cannot open SMTP server channel, fd=%d",
					t);
				finis(false, true, EX_OK);
			}
			sm_io_automode(inchannel, outchannel);

			InChannel = inchannel;
			OutChannel = outchannel;
			DisConnected = false;


#if XLA
			if (!xla_host_ok(RealHostName))
			{
				message("421 4.4.5 Too many SMTP sessions for this host");
				finis(false, true, EX_OK);
			}
#endif /* XLA */
			/* find out name for interface of connection */
			if (getsockname(sm_io_getinfo(InChannel, SM_IO_WHAT_FD,
						      NULL), &sa.sa, &len) == 0)
			{
				p = hostnamebyanyaddr(&sa);
				if (tTd(15, 9))
					sm_dprintf("getreq: got name %s\n", p);
				macdefine(&BlankEnvelope.e_macro, A_TEMP,
					macid("{if_name}"), p);

				/*
				**  Do this only if it is not the loopback
				**  interface.
				*/

				if (!isloopback(sa))
				{
					char *addr;
					char family[5];

					addr = anynet_ntoa(&sa);
					(void) sm_snprintf(family,
						sizeof(family),
						"%d", sa.sa.sa_family);
					macdefine(&BlankEnvelope.e_macro,
						A_TEMP,
						macid("{if_addr}"), addr);
					macdefine(&BlankEnvelope.e_macro,
						A_TEMP,
						macid("{if_family}"), family);
					if (tTd(15, 7))
						sm_dprintf("getreq: got addr %s and family %s\n",
							addr, family);
				}
				else
				{
					macdefine(&BlankEnvelope.e_macro,
						A_PERM,
						macid("{if_addr}"), NULL);
					macdefine(&BlankEnvelope.e_macro,
						A_PERM,
						macid("{if_family}"), NULL);
				}
			}
			else
			{
				if (tTd(15, 7))
					sm_dprintf("getreq: getsockname failed\n");
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{if_name}"), NULL);
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{if_addr}"), NULL);
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{if_family}"), NULL);
			}
			break;
		}

		/* parent -- keep track of children */
		if (control)
		{
			(void) sm_snprintf(status, sizeof(status),
					   "control socket server child");
			proc_list_add(pid, status, PROC_CONTROL, 0, -1, NULL);
		}
		else
		{
			(void) sm_snprintf(status, sizeof(status),
					   "SMTP server child for %s",
					   anynet_ntoa(&RealHostAddr));
			proc_list_add(pid, status, PROC_DAEMON, 0, -1,
					&RealHostAddr);
		}
		(void) sm_releasesignal(SIGCHLD);

		/* close the read end of the synchronization pipe */
		if (pipefd[0] != -1)
		{
			(void) close(pipefd[0]);
			pipefd[0] = -1;
		}

		/* close the port so that others will hang (for a while) */
		(void) close(t);

		/* release the child by closing the read end of the sync pipe */
		if (pipefd[1] != -1)
		{
			(void) close(pipefd[1]);
			pipefd[1] = -1;
		}
	}
	if (tTd(15, 2))
		sm_dprintf("getreq: returning\n");

#if MILTER
	/* set the filters for this daemon */
	if (Daemons[curdaemon].d_inputfilterlist != NULL)
	{
		for (i = 0;
		     (i < MAXFILTERS &&
		      Daemons[curdaemon].d_inputfilters[i] != NULL);
		     i++)
		{
			InputFilters[i] = Daemons[curdaemon].d_inputfilters[i];
		}
		if (i < MAXFILTERS)
			InputFilters[i] = NULL;
	}
#endif /* MILTER */
	return &Daemons[curdaemon].d_flags;
}

/*
**  GETREQUESTS_CHECKDISKSPACE -- check available diskspace.
**
**	Parameters:
**		e -- envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Modifies Daemon flags (D_ETRNONLY) if not enough disk space.
*/

static void
getrequests_checkdiskspace(e)
	ENVELOPE *e;
{
	bool logged = false;
	int idx;
	time_t now;

	now = curtime();
	if (now < NextDiskSpaceCheck)
		return;

	/* Check if there is available disk space in all queue groups. */
	if (!enoughdiskspace(0, NULL))
	{
		for (idx = 0; idx < NDaemons; ++idx)
		{
			if (bitnset(D_ETRNONLY, Daemons[idx].d_flags))
				continue;

			/* log only if not logged before */
			if (!logged)
			{
				if (LogLevel > 8)
					sm_syslog(LOG_INFO, NOQID,
						  "rejecting new messages: min free: %ld",
						  MinBlocksFree);
				sm_setproctitle(true, e,
						"rejecting new messages: min free: %ld",
						MinBlocksFree);
				logged = true;
			}
			setbitn(D_ETRNONLY, Daemons[idx].d_flags);
		}
	}
	else
	{
		for (idx = 0; idx < NDaemons; ++idx)
		{
			if (!bitnset(D_ETRNONLY, Daemons[idx].d_flags))
				continue;

			/* log only if not logged before */
			if (!logged)
			{
				if (LogLevel > 8)
					sm_syslog(LOG_INFO, NOQID,
						  "accepting new messages (again)");
				logged = true;
			}

			/* title will be set later */
			clrbitn(D_ETRNONLY, Daemons[idx].d_flags);
		}
	}

	/* only check disk space once a minute */
	NextDiskSpaceCheck = now + 60;
}

/*
**  OPENDAEMONSOCKET -- open SMTP socket
**
**	Deals with setting all appropriate options.
**
**	Parameters:
**		d -- the structure for the daemon to open.
**		firsttime -- set if this is the initial open.
**
**	Returns:
**		Size in bytes of the daemon socket addr.
**
**	Side Effects:
**		Leaves DaemonSocket set to the open socket.
**		Exits if the socket cannot be created.
*/

#define MAXOPENTRIES	10	/* maximum number of tries to open connection */

static int
opendaemonsocket(d, firsttime)
	DAEMON_T *d;
	bool firsttime;
{
	int on = 1;
	int fdflags;
	SOCKADDR_LEN_T socksize = 0;
	int ntries = 0;
	int save_errno;

	if (tTd(15, 2))
		sm_dprintf("opendaemonsocket(%s)\n", d->d_name);

	do
	{
		if (ntries > 0)
			(void) sleep(5);
		if (firsttime || d->d_socket < 0)
		{
#if _FFR_DAEMON_NETUNIX
# if NETUNIX
			if (d->d_addr.sa.sa_family == AF_UNIX)
			{
				int rval;
				long sff = SFF_SAFEDIRPATH|SFF_OPENASROOT|SFF_NOLINK|SFF_ROOTOK|SFF_EXECOK|SFF_CREAT;

				/* if not safe, don't use it */
				rval = safefile(d->d_addr.sunix.sun_path,
						RunAsUid, RunAsGid,
						RunAsUserName, sff,
						S_IRUSR|S_IWUSR, NULL);
				if (rval != 0)
				{
					save_errno = errno;
					syserr("opendaemonsocket: daemon %s: unsafe domain socket %s",
					       d->d_name,
					       d->d_addr.sunix.sun_path);
					goto fail;
				}

				/* Don't try to overtake an existing socket */
				(void) unlink(d->d_addr.sunix.sun_path);
			}
# endif /* NETUNIX */
#endif /* _FFR_DOMAIN_NETUNIX */
			d->d_socket = socket(d->d_addr.sa.sa_family,
					     SOCK_STREAM, 0);
			if (d->d_socket < 0)
			{
				save_errno = errno;
				syserr("opendaemonsocket: daemon %s: can't create server SMTP socket",
				       d->d_name);
			  fail:
				if (bitnset(D_OPTIONAL, d->d_flags) &&
				    (!transienterror(save_errno) ||
				     ntries >= MAXOPENTRIES - 1))
				{
					syserr("opendaemonsocket: daemon %s: optional socket disabled",
					       d->d_name);
					setbitn(D_DISABLE, d->d_flags);
					d->d_socket = -1;
					return -1;
				}
			  severe:
				if (LogLevel > 0)
					sm_syslog(LOG_ALERT, NOQID,
						  "daemon %s: problem creating SMTP socket",
						  d->d_name);
				d->d_socket = -1;
				continue;
			}

			if (SM_FD_SETSIZE > 0 && d->d_socket >= SM_FD_SETSIZE)
			{
				save_errno = EINVAL;
				syserr("opendaemonsocket: daemon %s: server SMTP socket (%d) too large",
				       d->d_name, d->d_socket);
				goto fail;
			}

			/* turn on network debugging? */
			if (tTd(15, 101))
				(void) setsockopt(d->d_socket, SOL_SOCKET,
						  SO_DEBUG, (char *)&on,
						  sizeof(on));

			(void) setsockopt(d->d_socket, SOL_SOCKET,
					  SO_REUSEADDR, (char *)&on, sizeof(on));
			(void) setsockopt(d->d_socket, SOL_SOCKET,
					  SO_KEEPALIVE, (char *)&on, sizeof(on));

#ifdef SO_RCVBUF
			if (d->d_tcprcvbufsize > 0)
			{
				if (setsockopt(d->d_socket, SOL_SOCKET,
					       SO_RCVBUF,
					       (char *) &d->d_tcprcvbufsize,
					       sizeof(d->d_tcprcvbufsize)) < 0)
					syserr("opendaemonsocket: daemon %s: setsockopt(SO_RCVBUF)", d->d_name);
			}
#endif /* SO_RCVBUF */
#ifdef SO_SNDBUF
			if (d->d_tcpsndbufsize > 0)
			{
				if (setsockopt(d->d_socket, SOL_SOCKET,
					       SO_SNDBUF,
					       (char *) &d->d_tcpsndbufsize,
					       sizeof(d->d_tcpsndbufsize)) < 0)
					syserr("opendaemonsocket: daemon %s: setsockopt(SO_SNDBUF)", d->d_name);
			}
#endif /* SO_SNDBUF */

			if ((fdflags = fcntl(d->d_socket, F_GETFD, 0)) == -1 ||
			    fcntl(d->d_socket, F_SETFD,
				  fdflags | FD_CLOEXEC) == -1)
			{
				save_errno = errno;
				syserr("opendaemonsocket: daemon %s: failed to %s close-on-exec flag: %s",
				       d->d_name,
				       fdflags == -1 ? "get" : "set",
				       sm_errstring(save_errno));
				(void) close(d->d_socket);
				goto severe;
			}

			switch (d->d_addr.sa.sa_family)
			{
#if _FFR_DAEMON_NETUNIX
# ifdef NETUNIX
			  case AF_UNIX:
				socksize = sizeof(d->d_addr.sunix);
				break;
# endif /* NETUNIX */
#endif /* _FFR_DAEMON_NETUNIX */
#if NETINET
			  case AF_INET:
				socksize = sizeof(d->d_addr.sin);
				break;
#endif /* NETINET */

#if NETINET6
			  case AF_INET6:
				socksize = sizeof(d->d_addr.sin6);
				break;
#endif /* NETINET6 */

#if NETISO
			  case AF_ISO:
				socksize = sizeof(d->d_addr.siso);
				break;
#endif /* NETISO */

			  default:
				socksize = sizeof(d->d_addr);
				break;
			}

			if (bind(d->d_socket, &d->d_addr.sa, socksize) < 0)
			{
				/* probably another daemon already */
				save_errno = errno;
				syserr("opendaemonsocket: daemon %s: cannot bind",
				       d->d_name);
				(void) close(d->d_socket);
				goto fail;
			}
		}
		if (!firsttime &&
		    listen(d->d_socket, d->d_listenqueue) < 0)
		{
			save_errno = errno;
			syserr("opendaemonsocket: daemon %s: cannot listen",
			       d->d_name);
			(void) close(d->d_socket);
			goto severe;
		}
		return socksize;
	} while (ntries++ < MAXOPENTRIES && transienterror(save_errno));
	syserr("!opendaemonsocket: daemon %s: server SMTP socket wedged: exiting",
	       d->d_name);
	/* NOTREACHED */
	return -1;  /* avoid compiler warning on IRIX */
}
/*
**  SETUPDAEMON -- setup socket for daemon
**
**	Parameters:
**		daemonaddr -- socket for daemon
**
**	Returns:
**		port number on which daemon should run
**
*/

static unsigned short
setupdaemon(daemonaddr)
	SOCKADDR *daemonaddr;
{
	unsigned short port;

	/*
	**  Set up the address for the mailer.
	*/

	if (daemonaddr->sa.sa_family == AF_UNSPEC)
	{
		memset(daemonaddr, '\0', sizeof(*daemonaddr));
#if NETINET
		daemonaddr->sa.sa_family = AF_INET;
#endif /* NETINET */
	}

	switch (daemonaddr->sa.sa_family)
	{
#if NETINET
	  case AF_INET:
		if (daemonaddr->sin.sin_addr.s_addr == 0)
			daemonaddr->sin.sin_addr.s_addr =
			    LocalDaemon ? htonl(INADDR_LOOPBACK) : INADDR_ANY;
		port = daemonaddr->sin.sin_port;
		break;
#endif /* NETINET */

#if NETINET6
	  case AF_INET6:
		if (IN6_IS_ADDR_UNSPECIFIED(&daemonaddr->sin6.sin6_addr))
			daemonaddr->sin6.sin6_addr =
			    (LocalDaemon && V6LoopbackAddrFound) ?
			    in6addr_loopback : in6addr_any;
		port = daemonaddr->sin6.sin6_port;
		break;
#endif /* NETINET6 */

	  default:
		/* unknown protocol */
		port = 0;
		break;
	}
	if (port == 0)
	{
#ifdef NO_GETSERVBYNAME
		port = htons(25);
#else /* NO_GETSERVBYNAME */
		{
			register struct servent *sp;

			sp = getservbyname("smtp", "tcp");
			if (sp == NULL)
			{
				syserr("554 5.3.5 service \"smtp\" unknown");
				port = htons(25);
			}
			else
				port = sp->s_port;
		}
#endif /* NO_GETSERVBYNAME */
	}

	switch (daemonaddr->sa.sa_family)
	{
#if NETINET
	  case AF_INET:
		daemonaddr->sin.sin_port = port;
		break;
#endif /* NETINET */

#if NETINET6
	  case AF_INET6:
		daemonaddr->sin6.sin6_port = port;
		break;
#endif /* NETINET6 */

	  default:
		/* unknown protocol */
		break;
	}
	return port;
}
/*
**  CLRDAEMON -- reset the daemon connection
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		releases any resources used by the passive daemon.
*/

void
clrdaemon()
{
	int i;

	for (i = 0; i < NDaemons; i++)
	{
		if (Daemons[i].d_socket >= 0)
			(void) close(Daemons[i].d_socket);
		Daemons[i].d_socket = -1;
	}
}

/*
**  GETMODIFIERS -- get modifier flags
**
**	Parameters:
**		v -- the modifiers (input text line).
**		modifiers -- pointer to flag field to represent modifiers.
**
**	Returns:
**		(xallocat()ed) string representation of modifiers.
**
**	Side Effects:
**		fills in modifiers.
*/

char *
getmodifiers(v, modifiers)
	char *v;
	BITMAP256 modifiers;
{
	int l;
	char *h, *f, *flags;

	/* maximum length of flags: upper case Option -> "OO " */
	l = 3 * strlen(v) + 3;

	/* is someone joking? */
	if (l < 0 || l > 256)
	{
		if (LogLevel > 2)
			sm_syslog(LOG_ERR, NOQID,
				  "getmodifiers too long, ignored");
		return NULL;
	}
	flags = xalloc(l);
	f = flags;
	clrbitmap(modifiers);
	for (h = v; *h != '\0'; h++)
	{
		if (isascii(*h) && !isspace(*h) && isprint(*h))
		{
			setbitn(*h, modifiers);
			if (flags != f)
				*flags++ = ' ';
			*flags++ = *h;
			if (isupper(*h))
				*flags++ = *h;
		}
	}
	*flags++ = '\0';
	return f;
}

/*
**  CHKDAEMONMODIFIERS -- check whether all daemons have set a flag.
**
**	Parameters:
**		flag -- the flag to test.
**
**	Returns:
**		true iff all daemons have set flag.
*/

bool
chkdaemonmodifiers(flag)
	int flag;
{
	int i;

	for (i = 0; i < NDaemons; i++)
		if (!bitnset((char) flag, Daemons[i].d_flags))
			return false;
	return true;
}

/*
**  SETSOCKADDROPTIONS -- set options for SOCKADDR (daemon or client)
**
**	Parameters:
**		p -- the options line.
**		d -- the daemon structure to fill in.
**
**	Returns:
**		none.
*/

static void
setsockaddroptions(p, d)
	char *p;
	DAEMON_T *d;
{
#if NETISO
	short portno;
#endif /* NETISO */
	char *port = NULL;
	char *addr = NULL;

#if NETINET
	if (d->d_addr.sa.sa_family == AF_UNSPEC)
		d->d_addr.sa.sa_family = AF_INET;
#endif /* NETINET */
#if _FFR_SS_PER_DAEMON
	d->d_supersafe = DPO_NOTSET;
#endif /* _FFR_SS_PER_DAEMON */
	d->d_dm = DM_NOTSET;
	d->d_refuseLA = DPO_NOTSET;
	d->d_queueLA = DPO_NOTSET;
	d->d_delayLA = DPO_NOTSET;
	d->d_maxchildren = DPO_NOTSET;

	while (p != NULL)
	{
		register char *f;
		register char *v;

		while (isascii(*p) && isspace(*p))
			p++;
		if (*p == '\0')
			break;
		f = p;
		p = strchr(p, ',');
		if (p != NULL)
			*p++ = '\0';
		v = strchr(f, '=');
		if (v == NULL)
			continue;
		while (isascii(*++v) && isspace(*v))
			continue;

		switch (*f)
		{
		  case 'A':		/* address */
#if !_FFR_DPO_CS
		  case 'a':
#endif /* !_FFR_DPO_CS */
			addr = v;
			break;

		  case 'c':
			d->d_maxchildren = atoi(v);
			break;

		  case 'D':		/* DeliveryMode */
			switch (*v)
			{
			  case SM_QUEUE:
			  case SM_DEFER:
			  case SM_DELIVER:
			  case SM_FORK:
				d->d_dm = *v;
				break;
			  default:
				syserr("554 5.3.5 Unknown delivery mode %c",
					*v);
				break;
			}
			break;

		  case 'd':		/* delayLA */
			d->d_delayLA = atoi(v);
			break;

		  case 'F':		/* address family */
#if !_FFR_DPO_CS
		  case 'f':
#endif /* !_FFR_DPO_CS */
			if (isascii(*v) && isdigit(*v))
				d->d_addr.sa.sa_family = atoi(v);
#if _FFR_DAEMON_NETUNIX
# ifdef NETUNIX
			else if (sm_strcasecmp(v, "unix") == 0 ||
				 sm_strcasecmp(v, "local") == 0)
				d->d_addr.sa.sa_family = AF_UNIX;
# endif /* NETUNIX */
#endif /* _FFR_DAEMON_NETUNIX */
#if NETINET
			else if (sm_strcasecmp(v, "inet") == 0)
				d->d_addr.sa.sa_family = AF_INET;
#endif /* NETINET */
#if NETINET6
			else if (sm_strcasecmp(v, "inet6") == 0)
				d->d_addr.sa.sa_family = AF_INET6;
#endif /* NETINET6 */
#if NETISO
			else if (sm_strcasecmp(v, "iso") == 0)
				d->d_addr.sa.sa_family = AF_ISO;
#endif /* NETISO */
#if NETNS
			else if (sm_strcasecmp(v, "ns") == 0)
				d->d_addr.sa.sa_family = AF_NS;
#endif /* NETNS */
#if NETX25
			else if (sm_strcasecmp(v, "x.25") == 0)
				d->d_addr.sa.sa_family = AF_CCITT;
#endif /* NETX25 */
			else
				syserr("554 5.3.5 Unknown address family %s in Family=option",
				       v);
			break;

#if MILTER
		  case 'I':
# if !_FFR_DPO_CS
		  case 'i':
# endif /* !_FFR_DPO_CS */
			d->d_inputfilterlist = v;
			break;
#endif /* MILTER */

		  case 'L':		/* listen queue size */
#if !_FFR_DPO_CS
		  case 'l':
#endif /* !_FFR_DPO_CS */
			d->d_listenqueue = atoi(v);
			break;

		  case 'M':		/* modifiers (flags) */
#if !_FFR_DPO_CS
		  case 'm':
#endif /* !_FFR_DPO_CS */
			d->d_mflags = getmodifiers(v, d->d_flags);
			break;

		  case 'N':		/* name */
#if !_FFR_DPO_CS
		  case 'n':
#endif /* !_FFR_DPO_CS */
			d->d_name = v;
			break;

		  case 'P':		/* port */
#if !_FFR_DPO_CS
		  case 'p':
#endif /* !_FFR_DPO_CS */
			port = v;
			break;

		  case 'q':
			d->d_queueLA = atoi(v);
			break;

		  case 'R':		/* receive buffer size */
			d->d_tcprcvbufsize = atoi(v);
			break;

		  case 'r':
			d->d_refuseLA = atoi(v);
			break;

		  case 'S':		/* send buffer size */
#if !_FFR_DPO_CS
		  case 's':
#endif /* !_FFR_DPO_CS */
			d->d_tcpsndbufsize = atoi(v);
			break;

#if _FFR_SS_PER_DAEMON
		  case 'T':		/* SuperSafe */
			if (tolower(*v) == 'i')
				d->d_supersafe = SAFE_INTERACTIVE;
			else if (tolower(*v) == 'p')
# if MILTER
				d->d_supersafe = SAFE_REALLY_POSTMILTER;
# else /* MILTER */
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					"Warning: SuperSafe=PostMilter requires Milter support (-DMILTER)\n");
# endif /* MILTER */
			else
				d->d_supersafe = atobool(v) ? SAFE_REALLY
							: SAFE_NO;
			break;
#endif /* _FFR_SS_PER_DAEMON */

		  default:
			syserr("554 5.3.5 PortOptions parameter \"%s\" unknown",
			       f);
		}
	}

	/* Check addr and port after finding family */
	if (addr != NULL)
	{
		switch (d->d_addr.sa.sa_family)
		{
#if _FFR_DAEMON_NETUNIX
# if NETUNIX
		  case AF_UNIX:
			if (strlen(addr) >= sizeof(d->d_addr.sunix.sun_path))
			{
				errno = ENAMETOOLONG;
				syserr("setsockaddroptions: domain socket name too long: %s > %d",
				       addr, sizeof(d->d_addr.sunix.sun_path));
				break;
			}

			/* file safety check done in opendaemonsocket() */
			(void) memset(&d->d_addr.sunix.sun_path, '\0',
				      sizeof(d->d_addr.sunix.sun_path));
			(void) sm_strlcpy((char *)&d->d_addr.sunix.sun_path,
					  addr,
					  sizeof(d->d_addr.sunix.sun_path));
			break;
# endif /* NETUNIX */
#endif	/* _FFR_DAEMON_NETUNIX */
#if NETINET
		  case AF_INET:
			if (!isascii(*addr) || !isdigit(*addr) ||
			    ((d->d_addr.sin.sin_addr.s_addr = inet_addr(addr))
			     == INADDR_NONE))
			{
				register struct hostent *hp;

				hp = sm_gethostbyname(addr, AF_INET);
				if (hp == NULL)
					syserr("554 5.3.0 host \"%s\" unknown",
					       addr);
				else
				{
					while (*(hp->h_addr_list) != NULL &&
					       hp->h_addrtype != AF_INET)
						hp->h_addr_list++;
					if (*(hp->h_addr_list) == NULL)
						syserr("554 5.3.0 host \"%s\" unknown",
						       addr);
					else
						memmove(&d->d_addr.sin.sin_addr,
							*(hp->h_addr_list),
							INADDRSZ);
# if NETINET6
					freehostent(hp);
					hp = NULL;
# endif /* NETINET6 */
				}
			}
			break;
#endif /* NETINET */

#if NETINET6
		  case AF_INET6:
			if (anynet_pton(AF_INET6, addr,
					&d->d_addr.sin6.sin6_addr) != 1)
			{
				register struct hostent *hp;

				hp = sm_gethostbyname(addr, AF_INET6);
				if (hp == NULL)
					syserr("554 5.3.0 host \"%s\" unknown",
					       addr);
				else
				{
					while (*(hp->h_addr_list) != NULL &&
					       hp->h_addrtype != AF_INET6)
						hp->h_addr_list++;
					if (*(hp->h_addr_list) == NULL)
						syserr("554 5.3.0 host \"%s\" unknown",
						       addr);
					else
						memmove(&d->d_addr.sin6.sin6_addr,
							*(hp->h_addr_list),
							IN6ADDRSZ);
					freehostent(hp);
					hp = NULL;
				}
			}
			break;
#endif /* NETINET6 */

		  default:
			syserr("554 5.3.5 address= option unsupported for family %d",
			       d->d_addr.sa.sa_family);
			break;
		}
	}

	if (port != NULL)
	{
		switch (d->d_addr.sa.sa_family)
		{
#if NETINET
		  case AF_INET:
			if (isascii(*port) && isdigit(*port))
				d->d_addr.sin.sin_port = htons((unsigned short)
						     atoi((const char *) port));
			else
			{
# ifdef NO_GETSERVBYNAME
				syserr("554 5.3.5 invalid port number: %s",
				       port);
# else /* NO_GETSERVBYNAME */
				register struct servent *sp;

				sp = getservbyname(port, "tcp");
				if (sp == NULL)
					syserr("554 5.3.5 service \"%s\" unknown",
					       port);
				else
					d->d_addr.sin.sin_port = sp->s_port;
# endif /* NO_GETSERVBYNAME */
			}
			break;
#endif /* NETINET */

#if NETINET6
		  case AF_INET6:
			if (isascii(*port) && isdigit(*port))
				d->d_addr.sin6.sin6_port = htons((unsigned short)
								  atoi(port));
			else
			{
# ifdef NO_GETSERVBYNAME
				syserr("554 5.3.5 invalid port number: %s",
				       port);
# else /* NO_GETSERVBYNAME */
				register struct servent *sp;

				sp = getservbyname(port, "tcp");
				if (sp == NULL)
					syserr("554 5.3.5 service \"%s\" unknown",
					       port);
				else
					d->d_addr.sin6.sin6_port = sp->s_port;
# endif /* NO_GETSERVBYNAME */
			}
			break;
#endif /* NETINET6 */

#if NETISO
		  case AF_ISO:
			/* assume two byte transport selector */
			if (isascii(*port) && isdigit(*port))
				portno = htons((unsigned short) atoi(port));
			else
			{
# ifdef NO_GETSERVBYNAME
				syserr("554 5.3.5 invalid port number: %s",
				       port);
# else /* NO_GETSERVBYNAME */
				register struct servent *sp;

				sp = getservbyname(port, "tcp");
				if (sp == NULL)
					syserr("554 5.3.5 service \"%s\" unknown",
					       port);
				else
					portno = sp->s_port;
# endif /* NO_GETSERVBYNAME */
			}
			memmove(TSEL(&d->d_addr.siso),
				(char *) &portno, 2);
			break;
#endif /* NETISO */

		  default:
			syserr("554 5.3.5 Port= option unsupported for family %d",
			       d->d_addr.sa.sa_family);
			break;
		}
	}
}
/*
**  SETDAEMONOPTIONS -- set options for running the MTA daemon
**
**	Parameters:
**		p -- the options line.
**
**	Returns:
**		true if successful, false otherwise.
**
**	Side Effects:
**		increments number of daemons.
*/

#define DEF_LISTENQUEUE	10

struct dflags
{
	char	*d_name;
	int	d_flag;
};

static struct dflags	DaemonFlags[] =
{
	{ "AUTHREQ",		D_AUTHREQ	},
	{ "BINDIF",		D_BINDIF	},
	{ "CANONREQ",		D_CANONREQ	},
	{ "IFNHELO",		D_IFNHELO	},
	{ "FQMAIL",		D_FQMAIL	},
	{ "FQRCPT",		D_FQRCPT	},
	{ "SMTPS",		D_SMTPS		},
	{ "UNQUALOK",		D_UNQUALOK	},
	{ "NOAUTH",		D_NOAUTH	},
	{ "NOCANON",		D_NOCANON	},
	{ "NOETRN",		D_NOETRN	},
	{ "NOTLS",		D_NOTLS		},
	{ "ETRNONLY",		D_ETRNONLY	},
	{ "OPTIONAL",		D_OPTIONAL	},
	{ "DISABLE",		D_DISABLE	},
	{ "ISSET",		D_ISSET		},
	{ NULL,			0		}
};

static void
printdaemonflags(d)
	DAEMON_T *d;
{
	register struct dflags *df;
	bool first = true;

	for (df = DaemonFlags; df->d_name != NULL; df++)
	{
		if (!bitnset(df->d_flag, d->d_flags))
			continue;
		if (first)
			sm_dprintf("<%s", df->d_name);
		else
			sm_dprintf(",%s", df->d_name);
		first = false;
	}
	if (!first)
		sm_dprintf(">");
}

bool
setdaemonoptions(p)
	register char *p;
{
	if (NDaemons >= MAXDAEMONS)
		return false;
	Daemons[NDaemons].d_socket = -1;
	Daemons[NDaemons].d_listenqueue = DEF_LISTENQUEUE;
	clrbitmap(Daemons[NDaemons].d_flags);
	setsockaddroptions(p, &Daemons[NDaemons]);

#if MILTER
	if (Daemons[NDaemons].d_inputfilterlist != NULL)
		Daemons[NDaemons].d_inputfilterlist = newstr(Daemons[NDaemons].d_inputfilterlist);
#endif /* MILTER */

	if (Daemons[NDaemons].d_name != NULL)
		Daemons[NDaemons].d_name = newstr(Daemons[NDaemons].d_name);
	else
	{
		char num[30];

		(void) sm_snprintf(num, sizeof(num), "Daemon%d", NDaemons);
		Daemons[NDaemons].d_name = newstr(num);
	}

	if (tTd(37, 1))
	{
		sm_dprintf("Daemon %s flags: ", Daemons[NDaemons].d_name);
		printdaemonflags(&Daemons[NDaemons]);
		sm_dprintf("\n");
	}
	++NDaemons;
	return true;
}
/*
**  INITDAEMON -- initialize daemon if not yet done.
**
**	Parameters:
**		none
**
**	Returns:
**		none
**
**	Side Effects:
**		initializes structure for one daemon.
*/

void
initdaemon()
{
	if (NDaemons == 0)
	{
		Daemons[NDaemons].d_socket = -1;
		Daemons[NDaemons].d_listenqueue = DEF_LISTENQUEUE;
		Daemons[NDaemons].d_name = "Daemon0";
		NDaemons = 1;
	}
}
/*
**  SETCLIENTOPTIONS -- set options for running the client
**
**	Parameters:
**		p -- the options line.
**
**	Returns:
**		none.
*/

static DAEMON_T	ClientSettings[AF_MAX + 1];

void
setclientoptions(p)
	register char *p;
{
	int family;
	DAEMON_T d;

	memset(&d, '\0', sizeof(d));
	setsockaddroptions(p, &d);

	/* grab what we need */
	family = d.d_addr.sa.sa_family;
	STRUCTCOPY(d, ClientSettings[family]);
	setbitn(D_ISSET, ClientSettings[family].d_flags); /* mark as set */
	if (d.d_name != NULL)
		ClientSettings[family].d_name = newstr(d.d_name);
	else
	{
		char num[30];

		(void) sm_snprintf(num, sizeof(num), "Client%d", family);
		ClientSettings[family].d_name = newstr(num);
	}
}
/*
**  ADDR_FAMILY -- determine address family from address
**
**	Parameters:
**		addr -- the string representation of the address
**
**	Returns:
**		AF_INET, AF_INET6 or AF_UNSPEC
**
**	Side Effects:
**		none.
*/

static int
addr_family(addr)
	char *addr;
{
#if NETINET6
	SOCKADDR clt_addr;
#endif /* NETINET6 */

#if NETINET
	if (inet_addr(addr) != INADDR_NONE)
	{
		if (tTd(16, 9))
			sm_dprintf("addr_family(%s): INET\n", addr);
		return AF_INET;
	}
#endif /* NETINET */
#if NETINET6
	if (anynet_pton(AF_INET6, addr, &clt_addr.sin6.sin6_addr) == 1)
	{
		if (tTd(16, 9))
			sm_dprintf("addr_family(%s): INET6\n", addr);
		return AF_INET6;
	}
#endif /* NETINET6 */
#if _FFR_DAEMON_NETUNIX
# if NETUNIX
	if (*addr == '/')
	{
		if (tTd(16, 9))
			sm_dprintf("addr_family(%s): LOCAL\n", addr);
		return AF_UNIX;
	}
# endif /* NETUNIX */
#endif	/* _FFR_DAEMON_NETUNIX */
	if (tTd(16, 9))
		sm_dprintf("addr_family(%s): UNSPEC\n", addr);
	return AF_UNSPEC;
}

/*
**  CHKCLIENTMODIFIERS -- check whether all clients have set a flag.
**
**	Parameters:
**		flag -- the flag to test.
**
**	Returns:
**		true iff all configured clients have set the flag.
*/

bool
chkclientmodifiers(flag)
	int flag;
{
	int i;
	bool flagisset;

	flagisset = false;
	for (i = 0; i < AF_MAX; i++)
	{
		if (bitnset(D_ISSET, ClientSettings[i].d_flags))
		{
			if (!bitnset((char) flag, ClientSettings[i].d_flags))
				return false;
			flagisset = true;
		}
	}
	return flagisset;
}

#if MILTER
/*
**  SETUP_DAEMON_FILTERS -- Parse per-socket filters
**
**	Parameters:
**		none
**
**	Returns:
**		none
*/

void
setup_daemon_milters()
{
	int idx;

	if (OpMode == MD_SMTP)
	{
		/* no need to configure the daemons */
		return;
	}

	for (idx = 0; idx < NDaemons; idx++)
	{
		if (Daemons[idx].d_inputfilterlist != NULL)
		{
			milter_config(Daemons[idx].d_inputfilterlist,
				      Daemons[idx].d_inputfilters,
				      MAXFILTERS);
		}
	}
}
#endif /* MILTER */
/*
**  MAKECONNECTION -- make a connection to an SMTP socket on a machine.
**
**	Parameters:
**		host -- the name of the host.
**		port -- the port number to connect to.
**		mci -- a pointer to the mail connection information
**			structure to be filled in.
**		e -- the current envelope.
**		enough -- time at which to stop further connection attempts.
**			(0 means no limit)
**
**	Returns:
**		An exit code telling whether the connection could be
**			made and if not why not.
**
**	Side Effects:
**		none.
*/

static jmp_buf	CtxConnectTimeout;

SOCKADDR	CurHostAddr;		/* address of current host */

int
makeconnection(host, port, mci, e, enough)
	char *host;
	volatile unsigned int port;
	register MCI *mci;
	ENVELOPE *e;
	time_t enough;
{
	register volatile int addrno = 0;
	volatile int s;
	register struct hostent *volatile hp = (struct hostent *) NULL;
	SOCKADDR addr;
	SOCKADDR clt_addr;
	int save_errno = 0;
	volatile SOCKADDR_LEN_T addrlen;
	volatile bool firstconnect = true;
	SM_EVENT *volatile ev = NULL;
#if NETINET6
	volatile bool v6found = false;
#endif /* NETINET6 */
	volatile int family = InetMode;
	SOCKADDR_LEN_T len;
	volatile SOCKADDR_LEN_T socksize = 0;
	volatile bool clt_bind;
	BITMAP256 d_flags;
	char *p;
	extern ENVELOPE BlankEnvelope;

	/* retranslate {daemon_flags} into bitmap */
	clrbitmap(d_flags);
	if ((p = macvalue(macid("{daemon_flags}"), e)) != NULL)
	{
		for (; *p != '\0'; p++)
		{
			if (!(isascii(*p) && isspace(*p)))
				setbitn(bitidx(*p), d_flags);
		}
	}

#if NETINET6
 v4retry:
#endif /* NETINET6 */
	clt_bind = false;

	/* Set up the address for outgoing connection. */
	if (bitnset(D_BINDIF, d_flags) &&
	    (p = macvalue(macid("{if_addr}"), e)) != NULL &&
	    *p != '\0')
	{
#if NETINET6
		char p6[INET6_ADDRSTRLEN];
#endif /* NETINET6 */

		memset(&clt_addr, '\0', sizeof(clt_addr));

		/* infer the address family from the address itself */
		clt_addr.sa.sa_family = addr_family(p);
		switch (clt_addr.sa.sa_family)
		{
#if NETINET
		  case AF_INET:
			clt_addr.sin.sin_addr.s_addr = inet_addr(p);
			if (clt_addr.sin.sin_addr.s_addr != INADDR_NONE &&
			    clt_addr.sin.sin_addr.s_addr !=
				htonl(INADDR_LOOPBACK))
			{
				clt_bind = true;
				socksize = sizeof(struct sockaddr_in);
			}
			break;
#endif /* NETINET */

#if NETINET6
		  case AF_INET6:
			if (inet_addr(p) != INADDR_NONE)
				(void) sm_snprintf(p6, sizeof(p6),
						   "IPv6:::ffff:%s", p);
			else
				(void) sm_strlcpy(p6, p, sizeof(p6));
			if (anynet_pton(AF_INET6, p6,
					&clt_addr.sin6.sin6_addr) == 1 &&
			    !IN6_IS_ADDR_LOOPBACK(&clt_addr.sin6.sin6_addr))
			{
				clt_bind = true;
				socksize = sizeof(struct sockaddr_in6);
			}
			break;
#endif /* NETINET6 */

#if 0
		  default:
			syserr("554 5.3.5 Address= option unsupported for family %d",
			       clt_addr.sa.sa_family);
			break;
#endif /* 0 */
		}
		if (clt_bind)
			family = clt_addr.sa.sa_family;
	}

	/* D_BINDIF not set or not available, fallback to ClientPortOptions */
	if (!clt_bind)
	{
		STRUCTCOPY(ClientSettings[family].d_addr, clt_addr);
		switch (clt_addr.sa.sa_family)
		{
#if NETINET
		  case AF_INET:
			if (clt_addr.sin.sin_addr.s_addr == 0)
				clt_addr.sin.sin_addr.s_addr = LocalDaemon ?
					htonl(INADDR_LOOPBACK) : INADDR_ANY;
			else
				clt_bind = true;
			if (clt_addr.sin.sin_port != 0)
				clt_bind = true;
			socksize = sizeof(struct sockaddr_in);
			break;
#endif /* NETINET */
#if NETINET6
		  case AF_INET6:
			if (IN6_IS_ADDR_UNSPECIFIED(&clt_addr.sin6.sin6_addr))
				clt_addr.sin6.sin6_addr =
					(LocalDaemon && V6LoopbackAddrFound) ?
					in6addr_loopback : in6addr_any;
			else
				clt_bind = true;
			socksize = sizeof(struct sockaddr_in6);
			if (clt_addr.sin6.sin6_port != 0)
				clt_bind = true;
			break;
#endif /* NETINET6 */
#if NETISO
		  case AF_ISO:
			socksize = sizeof(clt_addr.siso);
			clt_bind = true;
			break;
#endif /* NETISO */
		  default:
			break;
		}
	}

	/*
	**  Set up the address for the mailer.
	**	Accept "[a.b.c.d]" syntax for host name.
	*/

	SM_SET_H_ERRNO(0);
	errno = 0;
	memset(&CurHostAddr, '\0', sizeof(CurHostAddr));
	memset(&addr, '\0', sizeof(addr));
	SmtpPhase = mci->mci_phase = "initial connection";
	CurHostName = host;

	if (host[0] == '[')
	{
		p = strchr(host, ']');
		if (p != NULL)
		{
#if NETINET
			unsigned long hid = INADDR_NONE;
#endif /* NETINET */
#if NETINET6
			struct sockaddr_in6 hid6;
#endif /* NETINET6 */

			*p = '\0';
#if NETINET6
			memset(&hid6, '\0', sizeof(hid6));
#endif /* NETINET6 */
#if NETINET
			if (family == AF_INET &&
			    (hid = inet_addr(&host[1])) != INADDR_NONE)
			{
				addr.sin.sin_family = AF_INET;
				addr.sin.sin_addr.s_addr = hid;
			}
			else
#endif /* NETINET */
#if NETINET6
			if (family == AF_INET6 &&
			    anynet_pton(AF_INET6, &host[1],
					&hid6.sin6_addr) == 1)
			{
				addr.sin6.sin6_family = AF_INET6;
				addr.sin6.sin6_addr = hid6.sin6_addr;
			}
			else
#endif /* NETINET6 */
			{
				/* try it as a host name (avoid MX lookup) */
				hp = sm_gethostbyname(&host[1], family);
				if (hp == NULL && p[-1] == '.')
				{
#if NAMED_BIND
					int oldopts = _res.options;

					_res.options &= ~(RES_DEFNAMES|RES_DNSRCH);
#endif /* NAMED_BIND */
					p[-1] = '\0';
					hp = sm_gethostbyname(&host[1],
							      family);
					p[-1] = '.';
#if NAMED_BIND
					_res.options = oldopts;
#endif /* NAMED_BIND */
				}
				*p = ']';
				goto gothostent;
			}
			*p = ']';
		}
		if (p == NULL)
		{
			extern char MsgBuf[];

			usrerrenh("5.1.2",
				  "553 Invalid numeric domain spec \"%s\"",
				  host);
			mci_setstat(mci, EX_NOHOST, "5.1.2", MsgBuf);
			errno = EINVAL;
			return EX_NOHOST;
		}
	}
	else
	{
		/* contortion to get around SGI cc complaints */
		{
			p = &host[strlen(host) - 1];
			hp = sm_gethostbyname(host, family);
			if (hp == NULL && *p == '.')
			{
#if NAMED_BIND
				int oldopts = _res.options;

				_res.options &= ~(RES_DEFNAMES|RES_DNSRCH);
#endif /* NAMED_BIND */
				*p = '\0';
				hp = sm_gethostbyname(host, family);
				*p = '.';
#if NAMED_BIND
				_res.options = oldopts;
#endif /* NAMED_BIND */
			}
		}
gothostent:
		if (hp == NULL || hp->h_addr == NULL)
		{
#if NAMED_BIND
			/* check for name server timeouts */
# if NETINET6
			if (WorkAroundBrokenAAAA && family == AF_INET6 &&
			    (h_errno == TRY_AGAIN || errno == ETIMEDOUT))
			{
				/*
				**  An attempt with family AF_INET may
				**  succeed. By skipping the next section
				**  of code, we will try AF_INET before
				**  failing.
				*/

				if (tTd(16, 10))
					sm_dprintf("makeconnection: WorkAroundBrokenAAAA: Trying AF_INET lookup (AF_INET6 failed)\n");
			}
			else
# endif /* NETINET6 */
			{
				if (errno == ETIMEDOUT ||
# if _FFR_GETHBN_ExFILE
#  ifdef EMFILE
				   errno == EMFILE ||
#  endif /* EMFILE */
#  ifdef ENFILE
				   errno == ENFILE ||
#  endif /* ENFILE */
# endif /* _FFR_GETHBN_ExFILE */
				    h_errno == TRY_AGAIN ||
				    (errno == ECONNREFUSED && UseNameServer))
				{
					save_errno = errno;
					mci_setstat(mci, EX_TEMPFAIL,
						    "4.4.3", NULL);
					errno = save_errno;
					return EX_TEMPFAIL;
				}
			}
#endif /* NAMED_BIND */
#if NETINET6
			/*
			**  Try v6 first, then fall back to v4.
			**  If we found a v6 address, but no v4
			**  addresses, then TEMPFAIL.
			*/

			if (family == AF_INET6)
			{
				family = AF_INET;
				goto v4retry;
			}
			if (v6found)
				goto v6tempfail;
#endif /* NETINET6 */
			save_errno = errno;
			mci_setstat(mci, EX_NOHOST, "5.1.2", NULL);
			errno = save_errno;
			return EX_NOHOST;
		}
		addr.sa.sa_family = hp->h_addrtype;
		switch (hp->h_addrtype)
		{
#if NETINET
		  case AF_INET:
			memmove(&addr.sin.sin_addr,
				hp->h_addr,
				INADDRSZ);
			break;
#endif /* NETINET */

#if NETINET6
		  case AF_INET6:
			memmove(&addr.sin6.sin6_addr,
				hp->h_addr,
				IN6ADDRSZ);
			break;
#endif /* NETINET6 */

		  default:
			if (hp->h_length > sizeof(addr.sa.sa_data))
			{
				syserr("makeconnection: long sa_data: family %d len %d",
					hp->h_addrtype, hp->h_length);
				mci_setstat(mci, EX_NOHOST, "5.1.2", NULL);
				errno = EINVAL;
				return EX_NOHOST;
			}
			memmove(addr.sa.sa_data, hp->h_addr, hp->h_length);
			break;
		}
		addrno = 1;
	}

	/*
	**  Determine the port number.
	*/

	if (port == 0)
	{
#ifdef NO_GETSERVBYNAME
		port = htons(25);
#else /* NO_GETSERVBYNAME */
		register struct servent *sp = getservbyname("smtp", "tcp");

		if (sp == NULL)
		{
			if (LogLevel > 2)
				sm_syslog(LOG_ERR, NOQID,
					  "makeconnection: service \"smtp\" unknown");
			port = htons(25);
		}
		else
			port = sp->s_port;
#endif /* NO_GETSERVBYNAME */
	}

#if NETINET6
	if (addr.sa.sa_family == AF_INET6 &&
	    IN6_IS_ADDR_V4MAPPED(&addr.sin6.sin6_addr) &&
	    ClientSettings[AF_INET].d_addr.sa.sa_family != 0)
	{
		/*
		**  Ignore mapped IPv4 address since
		**  there is a ClientPortOptions setting
		**  for IPv4.
		*/

		goto nextaddr;
	}
#endif /* NETINET6 */

	switch (addr.sa.sa_family)
	{
#if NETINET
	  case AF_INET:
		addr.sin.sin_port = port;
		addrlen = sizeof(struct sockaddr_in);
		break;
#endif /* NETINET */

#if NETINET6
	  case AF_INET6:
		addr.sin6.sin6_port = port;
		addrlen = sizeof(struct sockaddr_in6);
		break;
#endif /* NETINET6 */

#if NETISO
	  case AF_ISO:
		/* assume two byte transport selector */
		memmove(TSEL((struct sockaddr_iso *) &addr), (char *) &port, 2);
		addrlen = sizeof(struct sockaddr_iso);
		break;
#endif /* NETISO */

	  default:
		syserr("Can't connect to address family %d", addr.sa.sa_family);
		mci_setstat(mci, EX_NOHOST, "5.1.2", NULL);
		errno = EINVAL;
#if NETINET6
		if (hp != NULL)
			freehostent(hp);
#endif /* NETINET6 */
		return EX_NOHOST;
	}

	/*
	**  Try to actually open the connection.
	*/

#if XLA
	/* if too many connections, don't bother trying */
	if (!xla_noqueue_ok(host))
	{
# if NETINET6
		if (hp != NULL)
			freehostent(hp);
# endif /* NETINET6 */
		return EX_TEMPFAIL;
	}
#endif /* XLA */

	for (;;)
	{
		if (tTd(16, 1))
			sm_dprintf("makeconnection (%s [%s].%d (%d))\n",
				   host, anynet_ntoa(&addr), ntohs(port),
				   (int) addr.sa.sa_family);

		/* save for logging */
		CurHostAddr = addr;

#if HASRRESVPORT
		if (bitnset(M_SECURE_PORT, mci->mci_mailer->m_flags))
		{
			int rport = IPPORT_RESERVED - 1;

			s = rresvport(&rport);
		}
		else
#endif /* HASRRESVPORT */
		{
			s = socket(addr.sa.sa_family, SOCK_STREAM, 0);
		}
		if (s < 0)
		{
			save_errno = errno;
			syserr("makeconnection: cannot create socket");
#if XLA
			xla_host_end(host);
#endif /* XLA */
			mci_setstat(mci, EX_TEMPFAIL, "4.4.5", NULL);
#if NETINET6
			if (hp != NULL)
				freehostent(hp);
#endif /* NETINET6 */
			errno = save_errno;
			return EX_TEMPFAIL;
		}

#ifdef SO_SNDBUF
		if (ClientSettings[family].d_tcpsndbufsize > 0)
		{
			if (setsockopt(s, SOL_SOCKET, SO_SNDBUF,
				       (char *) &ClientSettings[family].d_tcpsndbufsize,
				       sizeof(ClientSettings[family].d_tcpsndbufsize)) < 0)
				syserr("makeconnection: setsockopt(SO_SNDBUF)");
		}
#endif /* SO_SNDBUF */
#ifdef SO_RCVBUF
		if (ClientSettings[family].d_tcprcvbufsize > 0)
		{
			if (setsockopt(s, SOL_SOCKET, SO_RCVBUF,
				       (char *) &ClientSettings[family].d_tcprcvbufsize,
				       sizeof(ClientSettings[family].d_tcprcvbufsize)) < 0)
				syserr("makeconnection: setsockopt(SO_RCVBUF)");
		}
#endif /* SO_RCVBUF */

		if (tTd(16, 1))
			sm_dprintf("makeconnection: fd=%d\n", s);

		/* turn on network debugging? */
		if (tTd(16, 101))
		{
			int on = 1;

			(void) setsockopt(s, SOL_SOCKET, SO_DEBUG,
					  (char *)&on, sizeof(on));
		}
		if (e->e_xfp != NULL)	/* for debugging */
			(void) sm_io_flush(e->e_xfp, SM_TIME_DEFAULT);
		errno = 0;		/* for debugging */

		if (clt_bind)
		{
			int on = 1;

			switch (clt_addr.sa.sa_family)
			{
#if NETINET
			  case AF_INET:
				if (clt_addr.sin.sin_port != 0)
					(void) setsockopt(s, SOL_SOCKET,
							  SO_REUSEADDR,
							  (char *) &on,
							  sizeof(on));
				break;
#endif /* NETINET */

#if NETINET6
			  case AF_INET6:
				if (clt_addr.sin6.sin6_port != 0)
					(void) setsockopt(s, SOL_SOCKET,
							  SO_REUSEADDR,
							  (char *) &on,
							  sizeof(on));
				break;
#endif /* NETINET6 */
			}

			if (bind(s, &clt_addr.sa, socksize) < 0)
			{
				save_errno = errno;
				(void) close(s);
				errno = save_errno;
				syserr("makeconnection: cannot bind socket [%s]",
				       anynet_ntoa(&clt_addr));
#if NETINET6
				if (hp != NULL)
					freehostent(hp);
#endif /* NETINET6 */
				errno = save_errno;
				return EX_TEMPFAIL;
			}
		}

		/*
		**  Linux seems to hang in connect for 90 minutes (!!!).
		**  Time out the connect to avoid this problem.
		*/

		if (setjmp(CtxConnectTimeout) == 0)
		{
			int i;

			if (e->e_ntries <= 0 && TimeOuts.to_iconnect != 0)
				ev = sm_setevent(TimeOuts.to_iconnect,
						 connecttimeout, 0);
			else if (TimeOuts.to_connect != 0)
				ev = sm_setevent(TimeOuts.to_connect,
						 connecttimeout, 0);
			else
				ev = NULL;

			switch (ConnectOnlyTo.sa.sa_family)
			{
#if NETINET
			  case AF_INET:
				addr.sin.sin_addr.s_addr = ConnectOnlyTo.sin.sin_addr.s_addr;
				addr.sa.sa_family = ConnectOnlyTo.sa.sa_family;
				break;
#endif /* NETINET */

#if NETINET6
			  case AF_INET6:
				memmove(&addr.sin6.sin6_addr,
					&ConnectOnlyTo.sin6.sin6_addr,
					IN6ADDRSZ);
				break;
#endif /* NETINET6 */
			}
			if (tTd(16, 1))
				sm_dprintf("Connecting to [%s]...\n", anynet_ntoa(&addr));
			i = connect(s, (struct sockaddr *) &addr, addrlen);
			save_errno = errno;
			if (ev != NULL)
				sm_clrevent(ev);
			if (i >= 0)
				break;
		}
		else
			save_errno = errno;

		/* couldn't connect.... figure out why */
		(void) close(s);

		/* if running demand-dialed connection, try again */
		if (DialDelay > 0 && firstconnect &&
		    bitnset(M_DIALDELAY, mci->mci_mailer->m_flags))
		{
			if (tTd(16, 1))
				sm_dprintf("Connect failed (%s); trying again...\n",
					   sm_errstring(save_errno));
			firstconnect = false;
			(void) sleep(DialDelay);
			continue;
		}

		if (LogLevel > 13)
			sm_syslog(LOG_INFO, e->e_id,
				  "makeconnection (%s [%s]) failed: %s",
				  host, anynet_ntoa(&addr),
				  sm_errstring(save_errno));

#if NETINET6
nextaddr:
#endif /* NETINET6 */
		if (hp != NULL && hp->h_addr_list[addrno] != NULL &&
		    (enough == 0 || curtime() < enough))
		{
			if (tTd(16, 1))
				sm_dprintf("Connect failed (%s); trying new address....\n",
					   sm_errstring(save_errno));
			switch (addr.sa.sa_family)
			{
#if NETINET
			  case AF_INET:
				memmove(&addr.sin.sin_addr,
					hp->h_addr_list[addrno++],
					INADDRSZ);
				break;
#endif /* NETINET */

#if NETINET6
			  case AF_INET6:
				memmove(&addr.sin6.sin6_addr,
					hp->h_addr_list[addrno++],
					IN6ADDRSZ);
				break;
#endif /* NETINET6 */

			  default:
				memmove(addr.sa.sa_data,
					hp->h_addr_list[addrno++],
					hp->h_length);
				break;
			}
			continue;
		}
		errno = save_errno;

#if NETINET6
		if (family == AF_INET6)
		{
			if (tTd(16, 1))
				sm_dprintf("Connect failed (%s); retrying with AF_INET....\n",
					   sm_errstring(save_errno));
			v6found = true;
			family = AF_INET;
			if (hp != NULL)
			{
				freehostent(hp);
				hp = NULL;
			}
			goto v4retry;
		}
	v6tempfail:
#endif /* NETINET6 */
		/* couldn't open connection */
#if NETINET6
		/* Don't clobber an already saved errno from v4retry */
		if (errno > 0)
#endif /* NETINET6 */
			save_errno = errno;
		if (tTd(16, 1))
			sm_dprintf("Connect failed (%s)\n",
				   sm_errstring(save_errno));
#if XLA
		xla_host_end(host);
#endif /* XLA */
		mci_setstat(mci, EX_TEMPFAIL, "4.4.1", NULL);
#if NETINET6
		if (hp != NULL)
			freehostent(hp);
#endif /* NETINET6 */
		errno = save_errno;
		return EX_TEMPFAIL;
	}

#if NETINET6
	if (hp != NULL)
	{
		freehostent(hp);
		hp = NULL;
	}
#endif /* NETINET6 */

	/* connection ok, put it into canonical form */
	mci->mci_out = NULL;
	if ((mci->mci_out = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT,
				       (void *) &s,
				       SM_IO_WRONLY_B, NULL)) == NULL ||
	    (s = dup(s)) < 0 ||
	    (mci->mci_in = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT,
				      (void *) &s,
				      SM_IO_RDONLY_B, NULL)) == NULL)
	{
		save_errno = errno;
		syserr("cannot open SMTP client channel, fd=%d", s);
		mci_setstat(mci, EX_TEMPFAIL, "4.4.5", NULL);
		if (mci->mci_out != NULL)
			(void) sm_io_close(mci->mci_out, SM_TIME_DEFAULT);
		(void) close(s);
		errno = save_errno;
		return EX_TEMPFAIL;
	}
	sm_io_automode(mci->mci_out, mci->mci_in);

	/* set {client_flags} */
	if (ClientSettings[addr.sa.sa_family].d_mflags != NULL)
	{
		macdefine(&mci->mci_macro, A_PERM,
			  macid("{client_flags}"),
			  ClientSettings[addr.sa.sa_family].d_mflags);
	}
	else
		macdefine(&mci->mci_macro, A_PERM,
			  macid("{client_flags}"), "");

	/* "add" {client_flags} to bitmap */
	if (bitnset(D_IFNHELO, ClientSettings[addr.sa.sa_family].d_flags))
	{
		/* look for just this one flag */
		setbitn(D_IFNHELO, d_flags);
	}

	/* find out name for Interface through which we connect */
	len = sizeof(addr);
	if (getsockname(s, &addr.sa, &len) == 0)
	{
		char *name;
		char family[5];

		macdefine(&BlankEnvelope.e_macro, A_TEMP,
			macid("{if_addr_out}"), anynet_ntoa(&addr));
		(void) sm_snprintf(family, sizeof(family), "%d",
			addr.sa.sa_family);
		macdefine(&BlankEnvelope.e_macro, A_TEMP,
			macid("{if_family_out}"), family);

		name = hostnamebyanyaddr(&addr);
		macdefine(&BlankEnvelope.e_macro, A_TEMP,
			macid("{if_name_out}"), name);
		if (LogLevel > 11)
		{
			/* log connection information */
			sm_syslog(LOG_INFO, e->e_id,
				  "SMTP outgoing connect on %.40s", name);
		}
		if (bitnset(D_IFNHELO, d_flags))
		{
			if (name[0] != '[' && strchr(name, '.') != NULL)
				mci->mci_heloname = newstr(name);
		}
	}
	else
	{
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			macid("{if_name_out}"), NULL);
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			macid("{if_addr_out}"), NULL);
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			macid("{if_family_out}"), NULL);
	}

	/* Use the configured HeloName as appropriate */
	if (HeloName != NULL && HeloName[0] != '\0')
	{
		SM_FREE_CLR(mci->mci_heloname);
		mci->mci_heloname = newstr(HeloName);
	}

	mci_setstat(mci, EX_OK, NULL, NULL);
	return EX_OK;
}

static void
connecttimeout(ignore)
	int ignore;
{
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
	longjmp(CtxConnectTimeout, 1);
}
/*
**  MAKECONNECTION_DS -- make a connection to a domain socket.
**
**	Parameters:
**		mux_path -- the path of the socket to connect to.
**		mci -- a pointer to the mail connection information
**			structure to be filled in.
**
**	Returns:
**		An exit code telling whether the connection could be
**			made and if not why not.
**
**	Side Effects:
**		none.
*/

#if NETUNIX
int
makeconnection_ds(mux_path, mci)
	char *mux_path;
	register MCI *mci;
{
	int sock;
	int rval, save_errno;
	long sff = SFF_SAFEDIRPATH|SFF_OPENASROOT|SFF_NOLINK|SFF_ROOTOK|SFF_EXECOK;
	struct sockaddr_un unix_addr;

	/* if not safe, don't connect */
	rval = safefile(mux_path, RunAsUid, RunAsGid, RunAsUserName,
			sff, S_IRUSR|S_IWUSR, NULL);

	if (rval != 0)
	{
		syserr("makeconnection_ds: unsafe domain socket %s",
			mux_path);
		mci_setstat(mci, EX_TEMPFAIL, "4.3.5", NULL);
		errno = rval;
		return EX_TEMPFAIL;
	}

	/* prepare address structure */
	memset(&unix_addr, '\0', sizeof(unix_addr));
	unix_addr.sun_family = AF_UNIX;

	if (strlen(mux_path) >= sizeof(unix_addr.sun_path))
	{
		syserr("makeconnection_ds: domain socket name %s too long",
			mux_path);

		/* XXX why TEMPFAIL but 5.x.y ? */
		mci_setstat(mci, EX_TEMPFAIL, "5.3.5", NULL);
		errno = ENAMETOOLONG;
		return EX_UNAVAILABLE;
	}
	(void) sm_strlcpy(unix_addr.sun_path, mux_path,
			  sizeof(unix_addr.sun_path));

	/* initialize domain socket */
	sock = socket(AF_UNIX, SOCK_STREAM, 0);
	if (sock == -1)
	{
		save_errno = errno;
		syserr("makeconnection_ds: could not create domain socket %s",
			mux_path);
		mci_setstat(mci, EX_TEMPFAIL, "4.4.5", NULL);
		errno = save_errno;
		return EX_TEMPFAIL;
	}

	/* connect to server */
	if (connect(sock, (struct sockaddr *) &unix_addr,
		    sizeof(unix_addr)) == -1)
	{
		save_errno = errno;
		syserr("Could not connect to socket %s", mux_path);
		mci_setstat(mci, EX_TEMPFAIL, "4.4.1", NULL);
		(void) close(sock);
		errno = save_errno;
		return EX_TEMPFAIL;
	}

	/* connection ok, put it into canonical form */
	mci->mci_out = NULL;
	if ((mci->mci_out = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT,
				       (void *) &sock, SM_IO_WRONLY_B, NULL))
					== NULL
	    || (sock = dup(sock)) < 0 ||
	    (mci->mci_in = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT,
				      (void *) &sock, SM_IO_RDONLY_B, NULL))
					== NULL)
	{
		save_errno = errno;
		syserr("cannot open SMTP client channel, fd=%d", sock);
		mci_setstat(mci, EX_TEMPFAIL, "4.4.5", NULL);
		if (mci->mci_out != NULL)
			(void) sm_io_close(mci->mci_out, SM_TIME_DEFAULT);
		(void) close(sock);
		errno = save_errno;
		return EX_TEMPFAIL;
	}
	sm_io_automode(mci->mci_out, mci->mci_in);

	mci_setstat(mci, EX_OK, NULL, NULL);
	errno = 0;
	return EX_OK;
}
#endif /* NETUNIX */
/*
**  SHUTDOWN_DAEMON -- Performs a clean shutdown of the daemon
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		closes control socket, exits.
*/

void
shutdown_daemon()
{
	int i;
	char *reason;

	sm_allsignals(true);

	reason = ShutdownRequest;
	ShutdownRequest = NULL;
	PendingSignal = 0;

	if (LogLevel > 9)
		sm_syslog(LOG_INFO, CurEnv->e_id, "stopping daemon, reason=%s",
			  reason == NULL ? "implicit call" : reason);

	FileName = NULL;
	closecontrolsocket(true);
#if XLA
	xla_all_end();
#endif /* XLA */

	for (i = 0; i < NDaemons; i++)
	{
		if (Daemons[i].d_socket >= 0)
		{
			(void) close(Daemons[i].d_socket);
			Daemons[i].d_socket = -1;

#if _FFR_DAEMON_NETUNIX
# if NETUNIX
			/* Remove named sockets */
			if (Daemons[i].d_addr.sa.sa_family == AF_UNIX)
			{
				int rval;
				long sff = SFF_SAFEDIRPATH|SFF_OPENASROOT|SFF_NOLINK|SFF_MUSTOWN|SFF_EXECOK|SFF_CREAT;

				/* if not safe, don't use it */
				rval = safefile(Daemons[i].d_addr.sunix.sun_path,
						RunAsUid, RunAsGid,
						RunAsUserName, sff,
						S_IRUSR|S_IWUSR, NULL);
				if (rval == 0 &&
				    unlink(Daemons[i].d_addr.sunix.sun_path) < 0)
				{
					sm_syslog(LOG_WARNING, NOQID,
						  "Could not remove daemon %s socket: %s: %s",
						  Daemons[i].d_name,
						  Daemons[i].d_addr.sunix.sun_path,
						  sm_errstring(errno));
				}
			}
# endif /* NETUNIX */
#endif	/* _FFR_DAEMON_NETUNIX */
		}
	}

	finis(false, true, EX_OK);
}
/*
**  RESTART_DAEMON -- Performs a clean restart of the daemon
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		restarts the daemon or exits if restart fails.
*/

/* Make a non-DFL/IGN signal a noop */
#define SM_NOOP_SIGNAL(sig, old)				\
do								\
{								\
	(old) = sm_signal((sig), sm_signal_noop);		\
	if ((old) == SIG_IGN || (old) == SIG_DFL)		\
		(void) sm_signal((sig), (old));			\
} while (0)

void
restart_daemon()
{
	bool drop;
	int save_errno;
	char *reason;
	sigfunc_t ignore, oalrm, ousr1;
	extern int DtableSize;

	/* clear the events to turn off SIGALRMs */
	sm_clear_events();
	sm_allsignals(true);

	reason = RestartRequest;
	RestartRequest = NULL;
	PendingSignal = 0;

	if (SaveArgv[0][0] != '/')
	{
		if (LogLevel > 3)
			sm_syslog(LOG_INFO, NOQID,
				  "could not restart: need full path");
		finis(false, true, EX_OSFILE);
		/* NOTREACHED */
	}
	if (LogLevel > 3)
		sm_syslog(LOG_INFO, NOQID, "restarting %s due to %s",
			  SaveArgv[0],
			  reason == NULL ? "implicit call" : reason);

	closecontrolsocket(true);
#if SM_CONF_SHM
	cleanup_shm(DaemonPid == getpid());
#endif /* SM_CONF_SHM */

	/* close locked pid file */
	close_sendmail_pid();

	/*
	**  Want to drop to the user who started the process in all cases
	**  *but* when running as "smmsp" for the clientmqueue queue run
	**  daemon.  In that case, UseMSP will be true, RunAsUid should not
	**  be root, and RealUid should be either 0 or RunAsUid.
	*/

	drop = !(UseMSP && RunAsUid != 0 &&
		 (RealUid == 0 || RealUid == RunAsUid));

	if (drop_privileges(drop) != EX_OK)
	{
		if (LogLevel > 0)
			sm_syslog(LOG_ALERT, NOQID,
				  "could not drop privileges: %s",
				  sm_errstring(errno));
		finis(false, true, EX_OSERR);
		/* NOTREACHED */
	}

	sm_close_on_exec(STDERR_FILENO + 1, DtableSize);

	/*
	**  Need to allow signals before execve() to make them "harmless".
	**  However, the default action can be "terminate", so it isn't
	**  really harmless.  Setting signals to IGN will cause them to be
	**  ignored in the new process to, so that isn't a good alternative.
	*/

	SM_NOOP_SIGNAL(SIGALRM, oalrm);
	SM_NOOP_SIGNAL(SIGCHLD, ignore);
	SM_NOOP_SIGNAL(SIGHUP, ignore);
	SM_NOOP_SIGNAL(SIGINT, ignore);
	SM_NOOP_SIGNAL(SIGPIPE, ignore);
	SM_NOOP_SIGNAL(SIGTERM, ignore);
#ifdef SIGUSR1
	SM_NOOP_SIGNAL(SIGUSR1, ousr1);
#endif /* SIGUSR1 */

	/* Turn back on signals */
	sm_allsignals(false);

	(void) execve(SaveArgv[0], (ARGV_T) SaveArgv, (ARGV_T) ExternalEnviron);
	save_errno = errno;

	/* block signals again and restore needed signals */
	sm_allsignals(true);

	/* For finis() events */
	(void) sm_signal(SIGALRM, oalrm);

#ifdef SIGUSR1
	/* For debugging finis() */
	(void) sm_signal(SIGUSR1, ousr1);
#endif /* SIGUSR1 */

	errno = save_errno;
	if (LogLevel > 0)
		sm_syslog(LOG_ALERT, NOQID, "could not exec %s: %s",
			  SaveArgv[0], sm_errstring(errno));
	finis(false, true, EX_OSFILE);
	/* NOTREACHED */
}
/*
**  MYHOSTNAME -- return the name of this host.
**
**	Parameters:
**		hostbuf -- a place to return the name of this host.
**		size -- the size of hostbuf.
**
**	Returns:
**		A list of aliases for this host.
**
**	Side Effects:
**		Adds numeric codes to $=w.
*/

struct hostent *
myhostname(hostbuf, size)
	char hostbuf[];
	int size;
{
	register struct hostent *hp;

	if (gethostname(hostbuf, size) < 0 || hostbuf[0] == '\0')
		(void) sm_strlcpy(hostbuf, "localhost", size);
	hp = sm_gethostbyname(hostbuf, InetMode);
#if NETINET && NETINET6
	if (hp == NULL && InetMode == AF_INET6)
	{
		/*
		**  It's possible that this IPv6 enabled machine doesn't
		**  actually have any IPv6 interfaces and, therefore, no
		**  IPv6 addresses.  Fall back to AF_INET.
		*/

		hp = sm_gethostbyname(hostbuf, AF_INET);
	}
#endif /* NETINET && NETINET6 */
	if (hp == NULL)
		return NULL;
	if (strchr(hp->h_name, '.') != NULL || strchr(hostbuf, '.') == NULL)
		(void) cleanstrcpy(hostbuf, hp->h_name, size);

#if NETINFO
	if (strchr(hostbuf, '.') == NULL)
	{
		char *domainname;

		domainname = ni_propval("/locations", NULL, "resolver",
					"domain", '\0');
		if (domainname != NULL &&
		    strlen(domainname) + strlen(hostbuf) + 1 < size)
			(void) sm_strlcat2(hostbuf, ".", domainname, size);
	}
#endif /* NETINFO */

	/*
	**  If there is still no dot in the name, try looking for a
	**  dotted alias.
	*/

	if (strchr(hostbuf, '.') == NULL)
	{
		char **ha;

		for (ha = hp->h_aliases; ha != NULL && *ha != NULL; ha++)
		{
			if (strchr(*ha, '.') != NULL)
			{
				(void) cleanstrcpy(hostbuf, *ha, size - 1);
				hostbuf[size - 1] = '\0';
				break;
			}
		}
	}

	/*
	**  If _still_ no dot, wait for a while and try again -- it is
	**  possible that some service is starting up.  This can result
	**  in excessive delays if the system is badly configured, but
	**  there really isn't a way around that, particularly given that
	**  the config file hasn't been read at this point.
	**  All in all, a bit of a mess.
	*/

	if (strchr(hostbuf, '.') == NULL &&
	    !getcanonname(hostbuf, size, true, NULL))
	{
		sm_syslog(LocalDaemon ? LOG_WARNING : LOG_CRIT, NOQID,
			  "My unqualified host name (%s) unknown; sleeping for retry",
			  hostbuf);
		message("My unqualified host name (%s) unknown; sleeping for retry",
			hostbuf);
		(void) sleep(60);
		if (!getcanonname(hostbuf, size, true, NULL))
		{
			sm_syslog(LocalDaemon ? LOG_WARNING : LOG_ALERT, NOQID,
				  "unable to qualify my own domain name (%s) -- using short name",
				  hostbuf);
			message("WARNING: unable to qualify my own domain name (%s) -- using short name",
				hostbuf);
		}
	}
	return hp;
}
/*
**  ADDRCMP -- compare two host addresses
**
**	Parameters:
**		hp -- hostent structure for the first address
**		ha -- actual first address
**		sa -- second address
**
**	Returns:
**		0 -- if ha and sa match
**		else -- they don't match
*/

static int
addrcmp(hp, ha, sa)
	struct hostent *hp;
	char *ha;
	SOCKADDR *sa;
{
#if NETINET6
	unsigned char *a;
#endif /* NETINET6 */

	switch (sa->sa.sa_family)
	{
#if NETINET
	  case AF_INET:
		if (hp->h_addrtype == AF_INET)
			return memcmp(ha, (char *) &sa->sin.sin_addr, INADDRSZ);
		break;
#endif /* NETINET */

#if NETINET6
	  case AF_INET6:
		a = (unsigned char *) &sa->sin6.sin6_addr;

		/* Straight binary comparison */
		if (hp->h_addrtype == AF_INET6)
			return memcmp(ha, a, IN6ADDRSZ);

		/* If IPv4-mapped IPv6 address, compare the IPv4 section */
		if (hp->h_addrtype == AF_INET &&
		    IN6_IS_ADDR_V4MAPPED(&sa->sin6.sin6_addr))
			return memcmp(a + IN6ADDRSZ - INADDRSZ, ha, INADDRSZ);
		break;
#endif /* NETINET6 */
	}
	return -1;
}
/*
**  GETAUTHINFO -- get the real host name associated with a file descriptor
**
**	Uses RFC1413 protocol to try to get info from the other end.
**
**	Parameters:
**		fd -- the descriptor
**		may_be_forged -- an outage that is set to true if the
**			forward lookup of RealHostName does not match
**			RealHostAddr; set to false if they do match.
**
**	Returns:
**		The user@@host information associated with this descriptor.
*/

static jmp_buf	CtxAuthTimeout;

static void
authtimeout(ignore)
	int ignore;
{
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
	longjmp(CtxAuthTimeout, 1);
}

char *
getauthinfo(fd, may_be_forged)
	int fd;
	bool *may_be_forged;
{
	unsigned short SM_NONVOLATILE port = 0;
	SOCKADDR_LEN_T falen;
	register char *volatile p = NULL;
	SOCKADDR la;
	SOCKADDR_LEN_T lalen;
#ifndef NO_GETSERVBYNAME
	register struct servent *sp;
# if NETINET
	static unsigned short port4 = 0;
# endif /* NETINET */
# if NETINET6
	static unsigned short port6 = 0;
# endif /* NETINET6 */
#endif /* ! NO_GETSERVBYNAME */
	volatile int s;
	int i = 0;
	size_t len;
	SM_EVENT *ev;
	int nleft;
	struct hostent *hp;
	char *ostype = NULL;
	char **ha;
	char ibuf[MAXNAME + 1];
	static char hbuf[MAXNAME + MAXAUTHINFO + 11];

	*may_be_forged = false;
	falen = sizeof(RealHostAddr);
	if (isatty(fd) || (i = getpeername(fd, &RealHostAddr.sa, &falen)) < 0 ||
	    falen <= 0 || RealHostAddr.sa.sa_family == 0)
	{
		if (i < 0)
		{
			/*
			**  ENOTSOCK is OK: bail on anything else, but reset
			**  errno in this case, so a mis-report doesn't
			**  happen later.
			*/

			if (errno != ENOTSOCK)
				return NULL;
			errno = 0;
		}
		(void) sm_strlcpyn(hbuf, sizeof(hbuf), 2, RealUserName,
				   "@@localhost");
		if (tTd(9, 1))
			sm_dprintf("getauthinfo: %s\n", hbuf);
		return hbuf;
	}

	if (RealHostName == NULL)
	{
		/* translate that to a host name */
		RealHostName = newstr(hostnamebyanyaddr(&RealHostAddr));
		if (strlen(RealHostName) > MAXNAME)
			RealHostName[MAXNAME] = '\0'; /* XXX - 1 ? */
	}

	/* cross check RealHostName with forward DNS lookup */
	if (anynet_ntoa(&RealHostAddr)[0] != '[' &&
	    RealHostName[0] != '[')
	{
		int family;

		family = RealHostAddr.sa.sa_family;
#if NETINET6 && NEEDSGETIPNODE
		/*
		**  If RealHostAddr is an IPv6 connection with an
		**  IPv4-mapped address, we need RealHostName's IPv4
		**  address(es) for addrcmp() to compare against
		**  RealHostAddr.
		**
		**  Actually, we only need to do this for systems
		**  which NEEDSGETIPNODE since the real getipnodebyname()
		**  already does V4MAPPED address via the AI_V4MAPPEDCFG
		**  flag.  A better fix to this problem is to add this
		**  functionality to our stub getipnodebyname().
		*/

		if (family == AF_INET6 &&
		    IN6_IS_ADDR_V4MAPPED(&RealHostAddr.sin6.sin6_addr))
			family = AF_INET;
#endif /* NETINET6 && NEEDSGETIPNODE */

		/* try to match the reverse against the forward lookup */
		hp = sm_gethostbyname(RealHostName, family);
		if (hp == NULL)
		{
			/* XXX: Could be a temporary error on forward lookup */
			*may_be_forged = true;
		}
		else
		{
			for (ha = hp->h_addr_list; *ha != NULL; ha++)
			{
				if (addrcmp(hp, *ha, &RealHostAddr) == 0)
					break;
			}
			*may_be_forged = *ha == NULL;
#if NETINET6
			freehostent(hp);
			hp = NULL;
#endif /* NETINET6 */
		}
	}

	if (TimeOuts.to_ident == 0)
		goto noident;

	lalen = sizeof(la);
	switch (RealHostAddr.sa.sa_family)
	{
#if NETINET
	  case AF_INET:
		if (getsockname(fd, &la.sa, &lalen) < 0 ||
		    lalen <= 0 ||
		    la.sa.sa_family != AF_INET)
		{
			/* no ident info */
			goto noident;
		}
		port = RealHostAddr.sin.sin_port;

		/* create ident query */
		(void) sm_snprintf(ibuf, sizeof(ibuf), "%d,%d\r\n",
				ntohs(RealHostAddr.sin.sin_port),
				ntohs(la.sin.sin_port));

		/* create local address */
		la.sin.sin_port = 0;

		/* create foreign address */
# ifdef NO_GETSERVBYNAME
		RealHostAddr.sin.sin_port = htons(113);
# else /* NO_GETSERVBYNAME */

		/*
		**  getservbyname() consumes about 5% of the time
		**  when receiving a small message (almost all of the time
		**  spent in this routine).
		**  Hence we store the port in a static variable
		**  to save this time.
		**  The portnumber shouldn't change very often...
		**  This code makes the assumption that the port number
		**  is not 0.
		*/

		if (port4 == 0)
		{
			sp = getservbyname("auth", "tcp");
			if (sp != NULL)
				port4 = sp->s_port;
			else
				port4 = htons(113);
		}
		RealHostAddr.sin.sin_port = port4;
		break;
# endif /* NO_GETSERVBYNAME */
#endif /* NETINET */

#if NETINET6
	  case AF_INET6:
		if (getsockname(fd, &la.sa, &lalen) < 0 ||
		    lalen <= 0 ||
		    la.sa.sa_family != AF_INET6)
		{
			/* no ident info */
			goto noident;
		}
		port = RealHostAddr.sin6.sin6_port;

		/* create ident query */
		(void) sm_snprintf(ibuf, sizeof(ibuf), "%d,%d\r\n",
				ntohs(RealHostAddr.sin6.sin6_port),
				ntohs(la.sin6.sin6_port));

		/* create local address */
		la.sin6.sin6_port = 0;

		/* create foreign address */
# ifdef NO_GETSERVBYNAME
		RealHostAddr.sin6.sin6_port = htons(113);
# else /* NO_GETSERVBYNAME */
		if (port6 == 0)
		{
			sp = getservbyname("auth", "tcp");
			if (sp != NULL)
				port6 = sp->s_port;
			else
				port6 = htons(113);
		}
		RealHostAddr.sin6.sin6_port = port6;
		break;
# endif /* NO_GETSERVBYNAME */
#endif /* NETINET6 */
	  default:
		/* no ident info */
		goto noident;
	}

	s = -1;
	if (setjmp(CtxAuthTimeout) != 0)
	{
		if (s >= 0)
			(void) close(s);
		goto noident;
	}

	/* put a timeout around the whole thing */
	ev = sm_setevent(TimeOuts.to_ident, authtimeout, 0);

	/* connect to foreign IDENT server using same address as SMTP socket */
	s = socket(la.sa.sa_family, SOCK_STREAM, 0);
	if (s < 0)
	{
		sm_clrevent(ev);
		goto noident;
	}
	if (bind(s, &la.sa, lalen) < 0 ||
	    connect(s, &RealHostAddr.sa, lalen) < 0)
		goto closeident;

	if (tTd(9, 10))
		sm_dprintf("getauthinfo: sent %s", ibuf);

	/* send query */
	if (write(s, ibuf, strlen(ibuf)) < 0)
		goto closeident;

	/* get result */
	p = &ibuf[0];
	nleft = sizeof(ibuf) - 1;
	while ((i = read(s, p, nleft)) > 0)
	{
		char *s;

		p += i;
		nleft -= i;
		*p = '\0';
		if ((s = strchr(ibuf, '\n')) != NULL)
		{
			if (p > s + 1)
			{
				p = s + 1;
				*p = '\0';
			}
			break;
		}
		if (nleft <= 0)
			break;
	}
	(void) close(s);
	sm_clrevent(ev);
	if (i < 0 || p == &ibuf[0])
		goto noident;

	if (p >= &ibuf[2] && *--p == '\n' && *--p == '\r')
		p--;
	*++p = '\0';

	if (tTd(9, 3))
		sm_dprintf("getauthinfo:  got %s\n", ibuf);

	/* parse result */
	p = strchr(ibuf, ':');
	if (p == NULL)
	{
		/* malformed response */
		goto noident;
	}
	while (isascii(*++p) && isspace(*p))
		continue;
	if (sm_strncasecmp(p, "userid", 6) != 0)
	{
		/* presumably an error string */
		goto noident;
	}
	p += 6;
	while (isascii(*p) && isspace(*p))
		p++;
	if (*p++ != ':')
	{
		/* either useridxx or malformed response */
		goto noident;
	}

	/* p now points to the OSTYPE field */
	while (isascii(*p) && isspace(*p))
		p++;
	ostype = p;
	p = strchr(p, ':');
	if (p == NULL)
	{
		/* malformed response */
		goto noident;
	}
	else
	{
		char *charset;

		*p = '\0';
		charset = strchr(ostype, ',');
		if (charset != NULL)
			*charset = '\0';
	}

	/* 1413 says don't do this -- but it's broken otherwise */
	while (isascii(*++p) && isspace(*p))
		continue;

	/* p now points to the authenticated name -- copy carefully */
	if (sm_strncasecmp(ostype, "other", 5) == 0 &&
	    (ostype[5] == ' ' || ostype[5] == '\0'))
	{
		(void) sm_strlcpy(hbuf, "IDENT:", sizeof(hbuf));
		cleanstrcpy(&hbuf[6], p, MAXAUTHINFO);
	}
	else
		cleanstrcpy(hbuf, p, MAXAUTHINFO);
	len = strlen(hbuf);
	(void) sm_strlcpyn(&hbuf[len], sizeof(hbuf) - len, 2, "@@",
			   RealHostName == NULL ? "localhost" : RealHostName);
	goto postident;

closeident:
	(void) close(s);
	sm_clrevent(ev);

noident:
	/* put back the original incoming port */
	switch (RealHostAddr.sa.sa_family)
	{
#if NETINET
	  case AF_INET:
		if (port > 0)
			RealHostAddr.sin.sin_port = port;
		break;
#endif /* NETINET */

#if NETINET6
	  case AF_INET6:
		if (port > 0)
			RealHostAddr.sin6.sin6_port = port;
		break;
#endif /* NETINET6 */
	}

	if (RealHostName == NULL)
	{
		if (tTd(9, 1))
			sm_dprintf("getauthinfo: NULL\n");
		return NULL;
	}
	(void) sm_strlcpy(hbuf, RealHostName, sizeof(hbuf));

postident:
#if IP_SRCROUTE
# ifndef GET_IPOPT_DST
#  define GET_IPOPT_DST(dst)	(dst)
# endif /* ! GET_IPOPT_DST */
	/*
	**  Extract IP source routing information.
	**
	**	Format of output for a connection from site a through b
	**	through c to d:
	**		loose:      @@site-c@@site-b:site-a
	**		strict:	   !@@site-c@@site-b:site-a
	**
	**	o - pointer within ipopt_list structure.
	**	q - pointer within ls/ss rr route data
	**	p - pointer to hbuf
	*/

	if (RealHostAddr.sa.sa_family == AF_INET)
	{
		SOCKOPT_LEN_T ipoptlen;
		int j;
		unsigned char *q;
		unsigned char *o;
		int l;
		struct IPOPTION ipopt;

		ipoptlen = sizeof(ipopt);
		if (getsockopt(fd, IPPROTO_IP, IP_OPTIONS,
			       (char *) &ipopt, &ipoptlen) < 0)
			goto noipsr;
		if (ipoptlen == 0)
			goto noipsr;
		o = (unsigned char *) ipopt.IP_LIST;
		while (o != NULL && o < (unsigned char *) &ipopt + ipoptlen)
		{
			switch (*o)
			{
			  case IPOPT_EOL:
				o = NULL;
				break;

			  case IPOPT_NOP:
				o++;
				break;

			  case IPOPT_SSRR:
			  case IPOPT_LSRR:
				/*
				**  Source routing.
				**	o[0] is the option type (loose/strict).
				**	o[1] is the length of this option,
				**		including option type and
				**		length.
				**	o[2] is the pointer into the route
				**		data.
				**	o[3] begins the route data.
				*/

				p = &hbuf[strlen(hbuf)];
				l = sizeof(hbuf) - (hbuf - p) - 6;
				(void) sm_snprintf(p, SPACELEFT(hbuf, p),
					" [%s@@%.*s",
					*o == IPOPT_SSRR ? "!" : "",
					l > 240 ? 120 : l / 2,
					inet_ntoa(GET_IPOPT_DST(ipopt.IP_DST)));
				i = strlen(p);
				p += i;
				l -= strlen(p);

				j = o[1] / sizeof(struct in_addr) - 1;

				/* q skips length and router pointer to data */
				q = &o[3];
				for ( ; j >= 0; j--)
				{
					struct in_addr addr;

					memcpy(&addr, q, sizeof(addr));
					(void) sm_snprintf(p,
						SPACELEFT(hbuf, p),
						"%c%.*s",
						j != 0 ? '@@' : ':',
						l > 240 ? 120 :
							j == 0 ? l : l / 2,
						inet_ntoa(addr));
					i = strlen(p);
					p += i;
					l -= i + 1;
					q += sizeof(struct in_addr);
				}
				o += o[1];
				break;

			  default:
				/* Skip over option */
				o += o[1];
				break;
			}
		}
		(void) sm_snprintf(p, SPACELEFT(hbuf, p), "]");
		goto postipsr;
	}

noipsr:
#endif /* IP_SRCROUTE */
	if (RealHostName != NULL && RealHostName[0] != '[')
	{
		p = &hbuf[strlen(hbuf)];
		(void) sm_snprintf(p, SPACELEFT(hbuf, p), " [%.100s]",
				   anynet_ntoa(&RealHostAddr));
	}
	if (*may_be_forged)
	{
		p = &hbuf[strlen(hbuf)];
		(void) sm_strlcpy(p, " (may be forged)", SPACELEFT(hbuf, p));
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			  macid("{client_resolve}"), "FORGED");
	}

#if IP_SRCROUTE
postipsr:
#endif /* IP_SRCROUTE */

	/* put back the original incoming port */
	switch (RealHostAddr.sa.sa_family)
	{
#if NETINET
	  case AF_INET:
		if (port > 0)
			RealHostAddr.sin.sin_port = port;
		break;
#endif /* NETINET */

#if NETINET6
	  case AF_INET6:
		if (port > 0)
			RealHostAddr.sin6.sin6_port = port;
		break;
#endif /* NETINET6 */
	}

	if (tTd(9, 1))
		sm_dprintf("getauthinfo: %s\n", hbuf);
	return hbuf;
}
/*
**  HOST_MAP_LOOKUP -- turn a hostname into canonical form
**
**	Parameters:
**		map -- a pointer to this map.
**		name -- the (presumably unqualified) hostname.
**		av -- unused -- for compatibility with other mapping
**			functions.
**		statp -- an exit status (out parameter) -- set to
**			EX_TEMPFAIL if the name server is unavailable.
**
**	Returns:
**		The mapping, if found.
**		NULL if no mapping found.
**
**	Side Effects:
**		Looks up the host specified in hbuf.  If it is not
**		the canonical name for that host, return the canonical
**		name (unless MF_MATCHONLY is set, which will cause the
**		status only to be returned).
*/

char *
host_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	register struct hostent *hp;
#if NETINET
	struct in_addr in_addr;
#endif /* NETINET */
#if NETINET6
	struct in6_addr in6_addr;
#endif /* NETINET6 */
	char *cp, *ans = NULL;
	register STAB *s;
	time_t now;
#if NAMED_BIND
	time_t SM_NONVOLATILE retrans = 0;
	int SM_NONVOLATILE retry = 0;
#endif /* NAMED_BIND */
	char hbuf[MAXNAME + 1];

	/*
	**  See if we have already looked up this name.  If so, just
	**  return it (unless expired).
	*/

	now = curtime();
	s = stab(name, ST_NAMECANON, ST_ENTER);
	if (bitset(NCF_VALID, s->s_namecanon.nc_flags) &&
	    s->s_namecanon.nc_exp >= now)
	{
		if (tTd(9, 1))
			sm_dprintf("host_map_lookup(%s) => CACHE %s\n",
				    name,
				    s->s_namecanon.nc_cname == NULL
					? "NULL"
					: s->s_namecanon.nc_cname);
		errno = s->s_namecanon.nc_errno;
		SM_SET_H_ERRNO(s->s_namecanon.nc_herrno);
		*statp = s->s_namecanon.nc_stat;
		if (*statp == EX_TEMPFAIL)
		{
			CurEnv->e_status = "4.4.3";
			message("851 %s: Name server timeout",
				shortenstring(name, 33));
		}
		if (*statp != EX_OK)
			return NULL;
		if (s->s_namecanon.nc_cname == NULL)
		{
			syserr("host_map_lookup(%s): bogus NULL cache entry, errno=%d, h_errno=%d",
			       name,
			       s->s_namecanon.nc_errno,
			       s->s_namecanon.nc_herrno);
			return NULL;
		}
		if (bitset(MF_MATCHONLY, map->map_mflags))
			cp = map_rewrite(map, name, strlen(name), NULL);
		else
			cp = map_rewrite(map,
					 s->s_namecanon.nc_cname,
					 strlen(s->s_namecanon.nc_cname),
					 av);
		return cp;
	}

	/*
	**  If we are running without a regular network connection (usually
	**  dial-on-demand) and we are just queueing, we want to avoid DNS
	**  lookups because those could try to connect to a server.
	*/

	if (CurEnv->e_sendmode == SM_DEFER &&
	    bitset(MF_DEFER, map->map_mflags))
	{
		if (tTd(9, 1))
			sm_dprintf("host_map_lookup(%s) => DEFERRED\n", name);
		*statp = EX_TEMPFAIL;
		return NULL;
	}

	/*
	**  If first character is a bracket, then it is an address
	**  lookup.  Address is copied into a temporary buffer to
	**  strip the brackets and to preserve name if address is
	**  unknown.
	*/

	if (tTd(9, 1))
		sm_dprintf("host_map_lookup(%s) => ", name);
#if NAMED_BIND
	if (map->map_timeout > 0)
	{
		retrans = _res.retrans;
		_res.retrans = map->map_timeout;
	}
	if (map->map_retry > 0)
	{
		retry = _res.retry;
		_res.retry = map->map_retry;
	}
#endif /* NAMED_BIND */

	/* set default TTL */
	s->s_namecanon.nc_exp = now + SM_DEFAULT_TTL;
	if (*name != '[')
	{
		int ttl;

		(void) sm_strlcpy(hbuf, name, sizeof(hbuf));
		if (getcanonname(hbuf, sizeof(hbuf) - 1, !HasWildcardMX, &ttl))
		{
			ans = hbuf;
			if (ttl > 0)
				s->s_namecanon.nc_exp = now + SM_MIN(ttl,
								SM_DEFAULT_TTL);
		}
	}
	else
	{
		if ((cp = strchr(name, ']')) == NULL)
		{
			if (tTd(9, 1))
				sm_dprintf("FAILED\n");
			return NULL;
		}
		*cp = '\0';

		hp = NULL;
#if NETINET
		if ((in_addr.s_addr = inet_addr(&name[1])) != INADDR_NONE)
			hp = sm_gethostbyaddr((char *)&in_addr,
					      INADDRSZ, AF_INET);
#endif /* NETINET */
#if NETINET6
		if (hp == NULL &&
		    anynet_pton(AF_INET6, &name[1], &in6_addr) == 1)
			hp = sm_gethostbyaddr((char *)&in6_addr,
					      IN6ADDRSZ, AF_INET6);
#endif /* NETINET6 */
		*cp = ']';

		if (hp != NULL)
		{
			/* found a match -- copy out */
			ans = denlstring((char *) hp->h_name, true, true);
#if NETINET6
			if (ans == hp->h_name)
			{
				static char n[MAXNAME + 1];

				/* hp->h_name is about to disappear */
				(void) sm_strlcpy(n, ans, sizeof(n));
				ans = n;
			}
			freehostent(hp);
			hp = NULL;
#endif /* NETINET6 */
		}
	}
#if NAMED_BIND
	if (map->map_timeout > 0)
		_res.retrans = retrans;
	if (map->map_retry > 0)
		_res.retry = retry;
#endif /* NAMED_BIND */

	s->s_namecanon.nc_flags |= NCF_VALID;	/* will be soon */

	/* Found an answer */
	if (ans != NULL)
	{
		s->s_namecanon.nc_stat = *statp = EX_OK;
		if (s->s_namecanon.nc_cname != NULL)
			sm_free(s->s_namecanon.nc_cname);
		s->s_namecanon.nc_cname = sm_strdup_x(ans);
		if (bitset(MF_MATCHONLY, map->map_mflags))
			cp = map_rewrite(map, name, strlen(name), NULL);
		else
			cp = map_rewrite(map, ans, strlen(ans), av);
		if (tTd(9, 1))
			sm_dprintf("FOUND %s\n", ans);
		return cp;
	}


	/* No match found */
	s->s_namecanon.nc_errno = errno;
#if NAMED_BIND
	s->s_namecanon.nc_herrno = h_errno;
	if (tTd(9, 1))
		sm_dprintf("FAIL (%d)\n", h_errno);
	switch (h_errno)
	{
	  case TRY_AGAIN:
		if (UseNameServer)
		{
			CurEnv->e_status = "4.4.3";
			message("851 %s: Name server timeout",
				shortenstring(name, 33));
		}
		*statp = EX_TEMPFAIL;
		break;

	  case HOST_NOT_FOUND:
	  case NO_DATA:
		*statp = EX_NOHOST;
		break;

	  case NO_RECOVERY:
		*statp = EX_SOFTWARE;
		break;

	  default:
		*statp = EX_UNAVAILABLE;
		break;
	}
#else /* NAMED_BIND */
	if (tTd(9, 1))
		sm_dprintf("FAIL\n");
	*statp = EX_NOHOST;
#endif /* NAMED_BIND */
	s->s_namecanon.nc_stat = *statp;
	return NULL;
}
/*
**  HOST_MAP_INIT -- initialize host class structures
**
**	Parameters:
**		map -- a pointer to this map.
**		args -- argument string.
**
**	Returns:
**		true.
*/

bool
host_map_init(map, args)
	MAP *map;
	char *args;
{
	register char *p = args;

	for (;;)
	{
		while (isascii(*p) && isspace(*p))
			p++;
		if (*p != '-')
			break;
		switch (*++p)
		{
		  case 'a':
			map->map_app = ++p;
			break;

		  case 'T':
			map->map_tapp = ++p;
			break;

		  case 'm':
			map->map_mflags |= MF_MATCHONLY;
			break;

		  case 't':
			map->map_mflags |= MF_NODEFER;
			break;

		  case 'S':	/* only for consistency */
			map->map_spacesub = *++p;
			break;

		  case 'D':
			map->map_mflags |= MF_DEFER;
			break;

		  case 'd':
			{
				char *h;

				while (isascii(*++p) && isspace(*p))
					continue;
				h = strchr(p, ' ');
				if (h != NULL)
					*h = '\0';
				map->map_timeout = convtime(p, 's');
				if (h != NULL)
					*h = ' ';
			}
			break;

		  case 'r':
			while (isascii(*++p) && isspace(*p))
				continue;
			map->map_retry = atoi(p);
			break;
		}
		while (*p != '\0' && !(isascii(*p) && isspace(*p)))
			p++;
		if (*p != '\0')
			*p++ = '\0';
	}
	if (map->map_app != NULL)
		map->map_app = newstr(map->map_app);
	if (map->map_tapp != NULL)
		map->map_tapp = newstr(map->map_tapp);
	return true;
}

#if NETINET6
/*
**  ANYNET_NTOP -- convert an IPv6 network address to printable form.
**
**	Parameters:
**		s6a -- a pointer to an in6_addr structure.
**		dst -- buffer to store result in
**		dst_len -- size of dst buffer
**
**	Returns:
**		A printable version of that structure.
*/

char *
anynet_ntop(s6a, dst, dst_len)
	struct in6_addr *s6a;
	char *dst;
	size_t dst_len;
{
	register char *ap;

	if (IN6_IS_ADDR_V4MAPPED(s6a))
		ap = (char *) inet_ntop(AF_INET,
					&s6a->s6_addr[IN6ADDRSZ - INADDRSZ],
					dst, dst_len);
	else
	{
		char *d;
		size_t sz;

		/* Save pointer to beginning of string */
		d = dst;

		/* Add IPv6: protocol tag */
		sz = sm_strlcpy(dst, "IPv6:", dst_len);
		if (sz >= dst_len)
			return NULL;
		dst += sz;
		dst_len -= sz;
# if _FFR_IPV6_FULL
		ap = sm_inet6_ntop(s6a, dst, dst_len);
# else /* _FFR_IPV6_FULL */
		ap = (char *) inet_ntop(AF_INET6, s6a, dst, dst_len);
# endif /* _FFR_IPV6_FULL */

		/* Restore pointer to beginning of string */
		if (ap != NULL)
			ap = d;
	}
	return ap;
}

/*
**  ANYNET_PTON -- convert printed form to network address.
**
**	Wrapper for inet_pton() which handles IPv6: labels.
**
**	Parameters:
**		family -- address family
**		src -- string
**		dst -- destination address structure
**
**	Returns:
**		1 if the address was valid
**		0 if the address wasn't parseable
**		-1 if error
*/

int
anynet_pton(family, src, dst)
	int family;
	const char *src;
	void *dst;
{
	if (family == AF_INET6 && sm_strncasecmp(src, "IPv6:", 5) == 0)
		src += 5;
	return inet_pton(family, src, dst);
}
#endif /* NETINET6 */
/*
**  ANYNET_NTOA -- convert a network address to printable form.
**
**	Parameters:
**		sap -- a pointer to a sockaddr structure.
**
**	Returns:
**		A printable version of that sockaddr.
*/

#ifdef USE_SOCK_STREAM

# if NETLINK
#  include <net/if_dl.h>
# endif /* NETLINK */

char *
anynet_ntoa(sap)
	register SOCKADDR *sap;
{
	register char *bp;
	register char *ap;
	int l;
	static char buf[100];

	/* check for null/zero family */
	if (sap == NULL)
		return "NULLADDR";
	if (sap->sa.sa_family == 0)
		return "0";

	switch (sap->sa.sa_family)
	{
# if NETUNIX
	  case AF_UNIX:
		if (sap->sunix.sun_path[0] != '\0')
			(void) sm_snprintf(buf, sizeof(buf), "[UNIX: %.64s]",
					   sap->sunix.sun_path);
		else
			(void) sm_strlcpy(buf, "[UNIX: localhost]", sizeof(buf));
		return buf;
# endif /* NETUNIX */

# if NETINET
	  case AF_INET:
		return (char *) inet_ntoa(sap->sin.sin_addr);
# endif /* NETINET */

# if NETINET6
	  case AF_INET6:
		ap = anynet_ntop(&sap->sin6.sin6_addr, buf, sizeof(buf));
		if (ap != NULL)
			return ap;
		break;
# endif /* NETINET6 */

# if NETLINK
	  case AF_LINK:
		(void) sm_snprintf(buf, sizeof(buf), "[LINK: %s]",
				   link_ntoa((struct sockaddr_dl *) &sap->sa));
		return buf;
# endif /* NETLINK */
	  default:
		/* this case is needed when nothing is #defined */
		/* in order to keep the switch syntactically correct */
		break;
	}

	/* unknown family -- just dump bytes */
	(void) sm_snprintf(buf, sizeof(buf), "Family %d: ", sap->sa.sa_family);
	bp = &buf[strlen(buf)];
	ap = sap->sa.sa_data;
	for (l = sizeof(sap->sa.sa_data); --l >= 0; )
	{
		(void) sm_snprintf(bp, SPACELEFT(buf, bp), "%02x:",
				   *ap++ & 0377);
		bp += 3;
	}
	*--bp = '\0';
	return buf;
}
/*
**  HOSTNAMEBYANYADDR -- return name of host based on address
**
**	Parameters:
**		sap -- SOCKADDR pointer
**
**	Returns:
**		text representation of host name.
**
**	Side Effects:
**		none.
*/

char *
hostnamebyanyaddr(sap)
	register SOCKADDR *sap;
{
	register struct hostent *hp;
# if NAMED_BIND
	int saveretry;
# endif /* NAMED_BIND */
# if NETINET6
	struct in6_addr in6_addr;
# endif /* NETINET6 */

# if NAMED_BIND
	/* shorten name server timeout to avoid higher level timeouts */
	saveretry = _res.retry;
	if (_res.retry * _res.retrans > 20)
		_res.retry = 20 / _res.retrans;
	if (_res.retry == 0)
		_res.retry = 1;
# endif /* NAMED_BIND */

	switch (sap->sa.sa_family)
	{
# if NETINET
	  case AF_INET:
		hp = sm_gethostbyaddr((char *) &sap->sin.sin_addr,
				      INADDRSZ, AF_INET);
		break;
# endif /* NETINET */

# if NETINET6
	  case AF_INET6:
		hp = sm_gethostbyaddr((char *) &sap->sin6.sin6_addr,
				      IN6ADDRSZ, AF_INET6);
		break;
# endif /* NETINET6 */

# if NETISO
	  case AF_ISO:
		hp = sm_gethostbyaddr((char *) &sap->siso.siso_addr,
				      sizeof(sap->siso.siso_addr), AF_ISO);
		break;
# endif /* NETISO */

# if NETUNIX
	  case AF_UNIX:
		hp = NULL;
		break;
# endif /* NETUNIX */

	  default:
		hp = sm_gethostbyaddr(sap->sa.sa_data, sizeof(sap->sa.sa_data),
				      sap->sa.sa_family);
		break;
	}

# if NAMED_BIND
	_res.retry = saveretry;
# endif /* NAMED_BIND */

# if NETINET || NETINET6
	if (hp != NULL && hp->h_name[0] != '['
#  if NETINET6
	    && inet_pton(AF_INET6, hp->h_name, &in6_addr) != 1
#  endif /* NETINET6 */
#  if NETINET
	    && inet_addr(hp->h_name) == INADDR_NONE
#  endif /* NETINET */
	    )
	{
		char *name;

		name = denlstring((char *) hp->h_name, true, true);
#  if NETINET6
		if (name == hp->h_name)
		{
			static char n[MAXNAME + 1];

			/* Copy the string, hp->h_name is about to disappear */
			(void) sm_strlcpy(n, name, sizeof(n));
			name = n;
		}
		freehostent(hp);
#  endif /* NETINET6 */
		return name;
	}
# endif /* NETINET || NETINET6 */

# if NETINET6
	if (hp != NULL)
	{
		freehostent(hp);
		hp = NULL;
	}
# endif /* NETINET6 */

# if NETUNIX
	if (sap->sa.sa_family == AF_UNIX && sap->sunix.sun_path[0] == '\0')
		return "localhost";
# endif /* NETUNIX */
	{
		static char buf[203];

		(void) sm_snprintf(buf, sizeof(buf), "[%.200s]",
				   anynet_ntoa(sap));
		return buf;
	}
}
#endif /* USE_SOCK_STREAM */
@


1.30
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.29
log
@Update to sendmail 8.14.6
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2007, 2009, 2010 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.694 2012/03/03 00:10:42 ca Exp $")
d2355 1
a2355 1
			    errno == ETIMEDOUT)
d2359 1
a2359 1
				**  succeed By skipping the next section
d4262 3
d4266 1
@


1.28
log
@Update to sendmail 8.14.5
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.691 2011/01/25 18:31:30 ca Exp $")
d830 1
d4409 2
@


1.27
log
@Update to sendmail-8.14.3
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2007 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.680 2008/02/14 00:20:26 ca Exp $")
d202 1
a202 1
			sm_dprintf("getrequests: daemon %s: %d\n",
d1270 2
a1271 1
			    LocalDaemon ? in6addr_loopback : in6addr_any;
d2165 2
a2166 1
			    clt_addr.sin.sin_addr.s_addr != INADDR_LOOPBACK)
d2223 2
a2224 1
				clt_addr.sin6.sin6_addr = LocalDaemon ?
d2348 1
a2348 1
		if (hp == NULL)
d2670 1
d2878 2
d2881 1
@


1.26
log
@Update to sendmail-8.14.1
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.678 2007/03/08 00:33:40 ca Exp $")
d1260 2
a1261 1
			daemonaddr->sin.sin_addr.s_addr = INADDR_ANY;
d1269 2
a1270 1
			daemonaddr->sin6.sin6_addr = in6addr_any;
d2209 2
a2210 1
				clt_addr.sin.sin_addr.s_addr = INADDR_ANY;
d2221 2
a2222 1
				clt_addr.sin6.sin6_addr = in6addr_any;
d3281 1
a3281 1
		sm_syslog(LOG_CRIT, NOQID,
d3289 1
a3289 1
			sm_syslog(LOG_ALERT, NOQID,
@


1.25
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2006 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.676 2006/12/19 01:15:06 ca Exp $")
a1470 2
		if (isascii(*f) && islower(*f))
			*f = toupper(*f);
d1475 3
d1506 3
d1545 3
d1553 3
d1560 3
d1567 3
d1574 3
d1593 3
@


1.24
log
@Update to sendmail-8.13.8
@
text
@d15 1
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.666 2006/04/18 01:23:42 ca Exp $")
d62 2
a63 31
/* structure to describe a daemon or a client */
struct daemon
{
	int		d_socket;	/* fd for socket */
	SOCKADDR	d_addr;		/* socket for incoming */
	unsigned short	d_port;		/* port number */
	int		d_listenqueue;	/* size of listen queue */
	int		d_tcprcvbufsize;	/* size of TCP receive buffer */
	int		d_tcpsndbufsize;	/* size of TCP send buffer */
	time_t		d_refuse_connections_until;
	bool		d_firsttime;
	int		d_socksize;
	BITMAP256	d_flags;	/* flags; see sendmail.h */
	char		*d_mflags;	/* flags for use in macro */
	char		*d_name;	/* user-supplied name */
#if MILTER
	char		*d_inputfilterlist;
	struct milter	*d_inputfilters[MAXFILTERS];
#endif /* MILTER */
#if _FFR_SS_PER_DAEMON
	int		d_supersafe;
#endif /* _FFR_SS_PER_DAEMON */
#if _FFR_DM_PER_DAEMON
	int		d_dm;	/* DeliveryMode */
#endif /* _FFR_DM_PER_DAEMON */
};

typedef struct daemon DAEMON_T;

#define SAFE_NOTSET	(-1)	/* SuperSafe (per daemon) option not set */
/* see also sendmail.h: SuperSafe values */
a102 1
static DAEMON_T	Daemons[MAXDAEMONS];
d139 1
a139 1
	SOCKADDR_LEN_T len = sizeof sa;
a146 1
	extern bool refuseconnections __P((char *, ENVELOPE *, int, bool));
d191 1
a191 1
		expand("\201j", jbuf, sizeof jbuf, e);
d236 1
a236 2
			if (refuseconnections(Daemons[idx].d_name, e, idx,
					      curdaemon == idx))
d272 1
a272 1
			expand("\201j", jbuf, sizeof jbuf, e);
d395 1
a395 1
					       sizeof RealHostAddr);
d429 2
a430 2
				lotherend = sizeof sa_un;
				memset(&sa_un, '\0', sizeof sa_un);
d599 3
a601 3
			  sizeof NextDiskSpaceCheck);
		RAND_seed((void *) &now, sizeof now);
		RAND_seed((void *) &seed, sizeof seed);
d692 1
a692 1
				(void) sm_snprintf(status, sizeof status, "%d",
a723 1

d726 6
d734 3
a736 2
				    SAFE_NOTSET)
					SuperSafe = Daemons[curdaemon].d_supersafe;
a737 1
#if _FFR_DM_PER_DAEMON
d741 13
a753 1
#endif /* _FFR_DM_PER_DAEMON */
d898 1
a898 1
			(void) sm_snprintf(status, sizeof status,
d904 1
a904 1
			(void) sm_snprintf(status, sizeof status,
d1127 1
a1127 1
						  sizeof on);
d1130 1
a1130 1
					  SO_REUSEADDR, (char *)&on, sizeof on);
d1132 1
a1132 1
					  SO_KEEPALIVE, (char *)&on, sizeof on);
d1173 1
a1173 1
				socksize = sizeof d->d_addr.sunix;
d1179 1
a1179 1
				socksize = sizeof d->d_addr.sin;
d1185 1
a1185 1
				socksize = sizeof d->d_addr.sin6;
d1191 1
a1191 1
				socksize = sizeof d->d_addr.siso;
d1196 1
a1196 1
				socksize = sizeof d->d_addr;
d1249 1
a1249 1
		memset(daemonaddr, '\0', sizeof *daemonaddr);
d1445 1
a1445 1
	d->d_supersafe = SAFE_NOTSET;
a1446 1
#if _FFR_DM_PER_DAEMON
d1448 4
a1451 1
#endif /* _FFR_DM_PER_DAEMON */
d1480 4
a1483 1
#if _FFR_DM_PER_DAEMON
d1499 4
a1502 1
#endif /* _FFR_DM_PER_DAEMON */
d1561 4
d1569 4
d1865 1
a1865 1
		(void) sm_snprintf(num, sizeof num, "Daemon%d", NDaemons);
d1921 1
a1921 1
	memset(&d, '\0', sizeof d);
d1934 1
a1934 1
		(void) sm_snprintf(num, sizeof num, "Client%d", family);
d2130 1
a2130 1
		memset(&clt_addr, '\0', sizeof clt_addr);
d2143 1
a2143 1
				socksize = sizeof (struct sockaddr_in);
d2151 1
a2151 1
				(void) sm_snprintf(p6, sizeof p6,
d2154 1
a2154 1
				(void) sm_strlcpy(p6, p, sizeof p6);
d2160 1
a2160 1
				socksize = sizeof (struct sockaddr_in6);
d2190 1
a2190 1
			socksize = sizeof (struct sockaddr_in);
d2199 1
a2199 1
			socksize = sizeof (struct sockaddr_in6);
d2206 1
a2206 1
			socksize = sizeof clt_addr.siso;
d2222 2
a2223 2
	memset(&CurHostAddr, '\0', sizeof CurHostAddr);
	memset(&addr, '\0', sizeof addr);
d2241 1
a2241 1
			memset(&hid6, '\0', sizeof hid6);
d2341 8
d2400 1
a2400 1
			if (hp->h_length > sizeof addr.sa.sa_data)
d2457 1
a2457 1
		addrlen = sizeof (struct sockaddr_in);
d2464 1
a2464 1
		addrlen = sizeof (struct sockaddr_in6);
d2472 1
a2472 1
		addrlen = sizeof (struct sockaddr_iso);
d2569 1
a2569 1
					  (char *)&on, sizeof on);
d2587 1
a2587 1
							  sizeof on);
d2597 1
a2597 1
							  sizeof on);
d2808 1
a2808 1
	len = sizeof addr;
a2845 1
#if _FFR_HELONAME
a2848 1
#endif /* _FFR_HELONAME */
d2908 1
a2908 1
	memset(&unix_addr, '\0', sizeof unix_addr);
d2911 1
a2911 1
	if (strlen(mux_path) >= sizeof unix_addr.sun_path)
d2922 1
a2922 1
			  sizeof unix_addr.sun_path);
d3383 1
a3383 1
	falen = sizeof RealHostAddr;
d3399 1
a3399 1
		(void) sm_strlcpyn(hbuf, sizeof hbuf, 2, RealUserName,
d3465 1
a3465 1
	lalen = sizeof la;
d3480 1
a3480 1
		(void) sm_snprintf(ibuf, sizeof ibuf, "%d,%d\r\n",
d3528 1
a3528 1
		(void) sm_snprintf(ibuf, sizeof ibuf, "%d,%d\r\n",
d3587 1
a3587 1
	nleft = sizeof ibuf - 1;
d3670 1
a3670 1
		(void) sm_strlcpy(hbuf, "IDENT:", sizeof hbuf);
d3676 1
a3676 1
	(void) sm_strlcpyn(&hbuf[len], sizeof hbuf - len, 2, "@@",
d3709 1
a3709 1
	(void) sm_strlcpy(hbuf, RealHostName, sizeof hbuf);
d3738 1
a3738 1
		ipoptlen = sizeof ipopt;
d3771 1
a3771 1
				l = sizeof hbuf - (hbuf - p) - 6;
d3990 2
a3991 2
		(void) sm_strlcpy(hbuf, name, sizeof hbuf);
		if (getcanonname(hbuf, sizeof hbuf - 1, !HasWildcardMX, &ttl))
d4033 1
a4033 1
				(void) sm_strlcpy(n, ans, sizeof n);
d4300 1
a4300 1
			(void) sm_snprintf(buf, sizeof buf, "[UNIX: %.64s]",
d4303 1
a4303 1
			(void) sm_strlcpy(buf, "[UNIX: localhost]", sizeof buf);
d4314 1
a4314 1
		ap = anynet_ntop(&sap->sin6.sin6_addr, buf, sizeof buf);
d4322 1
a4322 1
		(void) sm_snprintf(buf, sizeof buf, "[LINK: %s]",
d4333 1
a4333 1
	(void) sm_snprintf(buf, sizeof buf, "Family %d: ", sap->sa.sa_family);
d4336 1
a4336 1
	for (l = sizeof sap->sa.sa_data; --l >= 0; )
d4396 1
a4396 1
				      sizeof sap->siso.siso_addr, AF_ISO);
d4407 1
a4407 1
		hp = sm_gethostbyaddr(sap->sa.sa_data, sizeof sap->sa.sa_data,
d4435 1
a4435 1
			(void) sm_strlcpy(n, name, sizeof n);
d4459 1
a4459 1
		(void) sm_snprintf(buf, sizeof buf, "[%.200s]",
@


1.23
log
@Update to sendmail 8.13.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.665 2006/03/02 19:12:00 ca Exp $")
d523 5
a527 3
			/* arrange to re-open the socket next time around */
			(void) close(Daemons[curdaemon].d_socket);
			Daemons[curdaemon].d_socket = -1;
d529 5
a533 5
			/*
			**  Give time for bound socket to be released.
			**  This creates a denial-of-service if you can
			**  force accept() to fail on affected systems.
			*/
d535 2
a536 1
			Daemons[curdaemon].d_refuse_connections_until = curtime() + 15;
d538 1
d2090 1
a2090 1
	volatile bool firstconnect;
a2492 1
	firstconnect = true;
@


1.22
log
@update to sendmail 8.13.4
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2005 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.658 2005/02/02 18:19:28 ca Exp $")
d37 1
a37 1
#include <sys/time.h>
a92 3
#define DM_NOTSET	(-1)	/* DeliveryMode (per daemon) option not set */
/* see also sendmail.h: values for e_sendmode -- send modes */

d390 2
a391 2
			else if (QueueIntvl > 0 &&
				 lastrun + QueueIntvl + 60 < now)
a763 1
					
d1454 6
a1480 6
#if _FFR_SS_PER_DAEMON
		d->d_supersafe = SAFE_NOTSET;
#endif /* _FFR_SS_PER_DAEMON */
#if _FFR_DM_PER_DAEMON
		d->d_dm = DM_NOTSET;
#endif /* _FFR_DM_PER_DAEMON */
d1495 1
a1495 1
			  case SM_FORK:	
@


1.21
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.653 2004/11/18 23:45:01 ca Exp $")
d80 6
d90 6
d757 11
d1479 6
d1488 22
a1544 4
		  case 'A':		/* address */
			addr = v;
			break;

a1550 4
		  case 'P':		/* port */
			port = v;
			break;

d1559 6
a1564 2
		  case 'S':		/* send buffer size */
			d->d_tcpsndbufsize = atoi(v);
d1571 18
a1588 2
		  case 'N':		/* name */
			d->d_name = v;
d1590 1
@


1.20
log
@Update to sendmail-8.13.1
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.649 2004/07/14 21:57:52 ca Exp $")
d84 1
a84 1
static void		connecttimeout __P((void));
d88 5
d1422 1
a1422 1
	register char *p;
d2579 2
d2784 2
a2785 1
connecttimeout()
d3268 2
a3269 1
authtimeout()
@


1.19
log
@Update to sendmail.8.13.0
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.647 2004/06/17 16:29:47 ca Exp $")
d2765 7
@


1.18
log
@Update to sendmail 8.12.11.  I've been runninga beta version of this for
some time without problems.  See the RELEASE_NOTES for the change log.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.613.2.20 2003/11/25 19:02:24 ca Exp $")
a76 1
# if _FFR_MILTER_PERDAEMON
a78 1
# endif /* _FFR_MILTER_PERDAEMON */
d213 1
a213 1
	proc_list_add(CurrentPid, "Sendmail daemon", PROC_DAEMON, 0, -1);
d281 1
d492 15
d585 10
d621 1
a621 1
		**  Update MX records for FallBackMX.
d626 2
a627 2
		if (FallBackMX != NULL)
			(void) getfallbackmxrr(FallBackMX);
d682 1
d725 1
a725 1
					      PROC_CONTROL_CHILD, 0, -1);
d736 1
a736 1
					      PROC_DAEMON_CHILD, 0, -1);
d787 1
d789 2
a790 1
					macid("{client_resolve}"), "OK");
d797 1
a797 1
						    SM_IO_RDONLY,
d803 1
a803 1
						     SM_IO_WRONLY,
d886 1
a886 1
			proc_list_add(pid, status, PROC_CONTROL, 0, -1);
d893 2
a894 1
			proc_list_add(pid, status, PROC_DAEMON, 0, -1);
a918 1
# if _FFR_MILTER_PERDAEMON
a931 1
# endif /* _FFR_MILTER_PERDAEMON */
a1493 1
# if _FFR_MILTER_PERDAEMON
a1496 1
# endif /* _FFR_MILTER_PERDAEMON */
a1737 1
#if _FFR_SMTP_SSL
a1738 1
#endif /* _FFR_SMTP_SSL */
d1763 1
a1763 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "<%s",
					     df->d_name);
d1765 1
a1765 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, ",%s",
					     df->d_name);
d1769 1
a1769 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, ">");
a1783 1
# if _FFR_MILTER_PERDAEMON
a1785 1
# endif /* _FFR_MILTER_PERDAEMON */
a1949 1
# if _FFR_MILTER_PERDAEMON
a1980 1
# endif /* _FFR_MILTER_PERDAEMON */
d2692 1
a2692 1
				       SM_IO_WRONLY, NULL)) == NULL ||
d2696 1
a2696 1
				      SM_IO_RDONLY, NULL)) == NULL)
d2814 2
a2815 1
		syserr("makeconnection_ds: unsafe domain socket");
d2827 2
a2828 1
		syserr("makeconnection_ds: domain socket name too long");
d2843 2
a2844 1
		syserr("makeconnection_ds: could not create domain socket");
d2865 1
a2865 1
				       (void *) &sock, SM_IO_WRONLY, NULL))
d2869 1
a2869 1
				      (void *) &sock, SM_IO_RDONLY, NULL))
d2913 2
a2914 2
	if (LogLevel > 79)
		sm_syslog(LOG_DEBUG, CurEnv->e_id, "interrupt (%s)",
a2985 1
	int i;
d3017 3
d3040 1
a3040 8
	/* arrange for all the files to be closed */
	for (i = 3; i < DtableSize; i++)
	{
		register int j;

		if ((j = fcntl(i, F_GETFD, 0)) != -1)
			(void) fcntl(i, F_SETFD, j | FD_CLOEXEC);
	}
d3357 1
d3844 1
a3844 1
			syserr("host_map_lookup(%s): bogus NULL cache entry, errno = %d, h_errno = %d",
@


1.17
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.613.2.17 2003/07/30 20:17:04 ca Exp $")
d167 2
a367 1

d3488 2
d3493 10
a3502 1
		if (strchr(ibuf, '\n') != NULL || nleft <= 0)
@


1.16
log
@Update to Sendmail 8.12.8; fixes a buffer overflow in the envelope
comments processing which may allow an attacker to gain root privileges.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.613.2.14 2003/02/11 17:17:22 ca Exp $")
d238 1
a238 7

		if (ShutdownRequest != NULL)
			shutdown_daemon();
		else if (RestartRequest != NULL)
			restart_daemon();
		else if (RestartWorkGroup)
			restart_marked_work_groups();
d280 1
a280 7
		if (ShutdownRequest != NULL)
			shutdown_daemon();
		else if (RestartRequest != NULL)
			restart_daemon();
		else if (RestartWorkGroup)
			restart_marked_work_groups();

d326 1
a326 7
			if (ShutdownRequest != NULL)
				shutdown_daemon();
			else if (RestartRequest != NULL)
				restart_daemon();
			else if (RestartWorkGroup)
				restart_marked_work_groups();

a327 1

d364 1
a364 7
			if (ShutdownRequest != NULL)
				shutdown_daemon();
			else if (RestartRequest != NULL)
				restart_daemon();
			else if (RestartWorkGroup)
				restart_marked_work_groups();

d3341 1
d3343 1
@


1.15
log
@update to sendmail 8.12.7
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.613.2.11 2002/12/05 16:13:52 ca Exp $")
d3521 1
a3521 1
	if (*--p == '\n' && *--p == '\r')
@


1.14
log
@sendmail 8.12.5
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.613 2002/06/05 21:26:35 gshapiro Exp $")
d630 14
a643 6
#if !PROFILING
		/*
		**  Create a pipe to keep the child from writing to the
		**  socket until after the parent has closed it.  Otherwise
		**  the parent may hang if the child has closed it first.
		*/
d645 2
a646 2
		if (pipe(pipefd) < 0)
			pipefd[0] = pipefd[1] = -1;
d648 3
a650 6
		(void) sm_blocksignal(SIGCHLD);
		pid = fork();
		if (pid < 0)
		{
			syserr("daemon: cannot fork");
			if (pipefd[0] != -1)
d652 10
a661 2
				(void) close(pipefd[0]);
				(void) close(pipefd[1]);
a662 4
			(void) sm_releasesignal(SIGCHLD);
			(void) sleep(10);
			(void) close(t);
			continue;
a664 4
#else /* !PROFILING */
		pid = 0;
#endif /* !PROFILING */

a743 1
#if !PROFILING
a764 1
#endif /* !PROFILING */
d920 2
a921 2
		     (Daemons[curdaemon].d_inputfilters[i] != NULL &&
		      i < MAXFILTERS);
d1099 8
d3303 1
a3303 1
	static char hbuf[MAXNAME * 2 + 11];
a3486 1

d3580 1
a3580 1
		cleanstrcpy(&hbuf[6], p, MAXNAME);
d3583 1
a3583 1
		cleanstrcpy(hbuf, p, MAXNAME);
@


1.13
log
@Update to sendmail-8.12.4
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.612 2002/05/02 19:40:52 ca Exp $")
d1713 52
d1796 1
a1796 4
		if (bitnset(D_ETRNONLY, Daemons[NDaemons].d_flags))
			sm_dprintf("ETRNONLY ");
		if (bitnset(D_NOETRN, Daemons[NDaemons].d_flags))
			sm_dprintf("NOETRN ");
@


1.12
log
@update to sendmail 8.12.3
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.611 2002/03/18 23:08:50 gshapiro Exp $")
d2959 3
a2990 3
#if SM_CONF_SHM
	cleanup_shm(DaemonPid == getpid());
#endif /* SM_CONF_SHM */
@


1.11
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.603 2001/12/31 19:46:38 gshapiro Exp $")
d157 3
d394 1
d396 20
d786 1
d2532 3
a2546 3
		/* couldn't connect.... figure out why */
		(void) close(s);

d3008 2
@


1.10
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.595 2001/09/25 05:03:54 gshapiro Exp $")
d194 1
a194 1
	/* If there are any queue runners releated reapchild() co-ord's */
d701 3
d777 1
a777 1
				finis(false, EX_OK);
d789 1
a789 1
				finis(false, EX_OK);
d1023 2
a1024 1
				long sff = SFF_SAFEDIRPATH|SFF_OPENASROOT|SFF_NOLINK|SFF_ROOTOK|SFF_EXECOK;
d1509 1
a1509 9
			/* if not safe, don't use it */
			if (safefile(addr, RunAsUid, RunAsGid,
				     RunAsUserName,
				     SFF_SAFEDIRPATH|SFF_OPENASROOT|SFF_NOLINK|SFF_ROOTOK|SFF_EXECOK,
				     S_IRUSR|S_IWUSR, NULL) != 0)
			{
				syserr("setsockaddroptions: unsafe domain socket");
				break;
			}
d1553 1
a1553 2
			if (!isascii(*addr) || !isxdigit(*addr) ||
			    anynet_pton(AF_INET6, addr,
d2358 1
d2366 1
d2824 1
d2843 36
a2878 1
	finis(false, EX_OK);
d2925 1
a2925 1
		finis(false, EX_OSFILE);
d2951 1
a2951 1
		finis(false, EX_OSERR);
d3003 1
a3003 1
	finis(false, EX_OSFILE);
@


1.9
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.588 2001/09/05 15:08:00 ca Exp $")
d124 1
a124 1
/*
d762 4
a765 3
						    (void *) t,
						    SM_IO_RDONLY, NULL)) == NULL
			    || (t = dup(t)) < 0 ||
d768 3
a770 3
						     (void *) t,
						     SM_IO_WRONLY, NULL))
			    == NULL)
d976 1
a976 1
/*
d1170 1
a1170 1
/*
d1262 1
a1262 1
/*
d1288 1
a1288 1
/*
d1312 9
d1326 1
a1326 1
		if (!(isascii(*h) && isspace(*h)))
d1340 1
a1340 1
/*
d1362 1
a1362 1
/*
d1678 1
a1678 1
/*
d1733 1
a1733 1
/*
d1757 1
a1757 1
/*
d1793 1
a1793 1
/*
d1845 1
a1845 1
/*
d1877 1
a1877 1
/*
d1910 1
a1910 1
/*
d1943 1
a1943 1
	register volatile int s;
d2180 3
a2182 2
			if (errno == ETIMEDOUT || h_errno == TRY_AGAIN ||
			    (errno == ECONNREFUSED && UseNameServer))
d2184 23
a2206 4
				save_errno = errno;
				mci_setstat(mci, EX_TEMPFAIL, "4.4.3", NULL);
				errno = save_errno;
				return EX_TEMPFAIL;
d2358 1
a2358 1
				   addr.sa.sa_family);
d2616 2
a2617 1
	if ((mci->mci_out = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT, (void *) s,
d2620 2
a2621 1
	    (mci->mci_in = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT, (void *) s,
d2707 1
a2707 1
/*
d2788 1
a2788 1
				       (void *) sock, SM_IO_WRONLY, NULL))
d2792 1
a2792 1
				      (void *) sock, SM_IO_RDONLY, NULL))
d2811 1
a2811 1
/*
d2847 1
a2847 1
/*
d2973 1
a2973 1
/*
d3076 1
a3076 1
/*
d3125 1
a3125 1
/*
d3647 1
a3647 1
/*
d3896 1
a3896 1
/*
d3978 1
a3978 1

d4027 1
a4027 1
/*
d4054 1
a4054 1
/*
d4135 1
a4135 1
/*
@


1.8
log
@update to sendmail 8.11.5
@
text
@d16 1
a16 8

#ifndef lint
# ifdef DAEMON
static char id[] = "@@(#)$Sendmail: daemon.c,v 8.401.4.68 2001/07/20 18:45:58 gshapiro Exp $ (with daemon mode)";
# else /* DAEMON */
static char id[] = "@@(#)$Sendmail: daemon.c,v 8.401.4.68 2001/07/20 18:45:58 gshapiro Exp $ (without daemon mode)";
# endif /* DAEMON */
#endif /* ! lint */
d22 1
a22 1
#if DAEMON || defined(USE_SOCK_STREAM)
d31 1
a31 1
#endif /* DAEMON || defined(USE_SOCK_STREAM) */
d33 25
a57 1
#if DAEMON
d59 1
a59 25
# if STARTTLS
#    include <openssl/rand.h>
# endif /* STARTTLS */

# include <sys/time.h>

# if IP_SRCROUTE && NETINET
#  include <netinet/in_systm.h>
#  include <netinet/ip.h>
#  if HAS_IN_H
#   include <netinet/in.h>
#   ifndef IPOPTION
#    define IPOPTION	ip_opts
#    define IP_LIST	ip_opts
#    define IP_DST	ip_dst
#   endif /* ! IPOPTION */
#  else /* HAS_IN_H */
#   include <netinet/ip_var.h>
#   ifndef IPOPTION
#    define IPOPTION	ipoption
#    define IP_LIST	ipopt_list
#    define IP_DST	ipopt_dst
#   endif /* ! IPOPTION */
#  endif /* HAS_IN_H */
# endif /* IP_SRCROUTE && NETINET */
d61 1
a61 1
/* structure to describe a daemon */
d66 1
a66 1
	u_short		d_port;		/* port number */
d76 6
d86 4
a89 5
static void	connecttimeout __P((void));
static int	opendaemonsocket __P((struct daemon *, bool));
static u_short	setupdaemon __P((SOCKADDR *));
static SIGFUNC_DECL	sighup __P((int));
static void	restart_daemon __P((void));
d111 1
a111 1
**	makeconnection(host, port, outfile, infile, e)
d113 2
a114 4
**		port.  Set *outfile and *infile to the files
**		appropriate for communication.  Returns zero on
**		success, else an exit status describing the
**		error.
d120 1
a120 1
static int	ndaemons = 0;			/* actual number of daemons */
d122 1
a122 3
/* options for client */
static int	TcpRcvBufferSize = 0;	/* size of TCP receive buffer */
static int	TcpSndBufferSize = 0;	/* size of TCP send buffer */
d140 2
a148 1
	time_t last_disk_space_check = 0;
d151 1
a151 1
# if XDEBUG
d153 1
a153 1
# endif /* XDEBUG */
d161 1
d164 1
a164 1
	for (idx = 0; idx < ndaemons; idx++)
d167 1
a167 1
		Daemons[idx].d_firsttime = TRUE;
d177 1
a177 1
		for (idx = 0; idx < ndaemons; idx++)
d179 3
a181 3
			dprintf("getrequests: daemon %s: port %d\n",
				Daemons[idx].d_name,
				ntohs(Daemons[idx].d_port));
d186 2
a187 2
	for (idx = 0; idx < ndaemons; idx++)
		Daemons[idx].d_socksize = opendaemonsocket(&Daemons[idx], TRUE);
d192 1
a192 1
			  ControlSocketName, errstring(errno));
d194 2
a195 2
	(void) setsignal(SIGCHLD, reapchild);
	(void) setsignal(SIGHUP, sighup);
d197 1
a197 4
	/* workaround: can't seem to release the signal in the parent */
	(void) releasesignal(SIGHUP);

	/* write the pid to file */
d200 1
a200 1
# if XDEBUG
d207 1
a207 1
# endif /* XDEBUG */
d210 1
a210 1
	proc_list_add(getpid(), "Sendmail daemon", PROC_DAEMON);
d214 2
a215 2
		for (idx = 0; idx < ndaemons; idx++)
			dprintf("getrequests: daemon %s: %d\n",
d224 2
a225 2
		bool timedout = FALSE;
		bool control = FALSE;
d228 2
a229 2
		time_t timenow;
# if STARTTLS
d231 1
a231 2
# endif /* STARTTLS */
		extern bool refuseconnections __P((char *, ENVELOPE *, int));
d234 1
a234 1
		(void) blocksignal(SIGALRM);
d240 2
d243 1
a243 8
		timenow = curtime();

		/*
		**  Use ConnRateThrottle only if the
		**  last pass was for a connection
		*/

		if (ConnRateThrottle > 0 && curdaemon >= 0)
d245 4
a248 2
			static int conncnt = 0;
			static time_t lastconn = 0;
d250 2
a251 22
			if (timenow != lastconn)
			{
				lastconn = timenow;
				conncnt = 1;
			}
			else if (++conncnt > ConnRateThrottle)
			{
				/* sleep to flatten out connection load */
				sm_setproctitle(TRUE, e,
						"deferring connections: %d per second",
						ConnRateThrottle);
				if (LogLevel >= 9)
					sm_syslog(LOG_INFO, NOQID,
						  "deferring connections: %d per second",
						  ConnRateThrottle);
				(void) sleep(1);
			}
		}

		for (idx = 0; idx < ndaemons; idx++)
		{
			if (timenow < Daemons[idx].d_refuse_connections_until)
d255 2
a256 1
			if (refuseconnections(Daemons[idx].d_name, e, idx))
d266 1
a266 1
				Daemons[idx].d_refuse_connections_until = timenow + 15;
d271 1
a271 1
				if (!Daemons[idx].d_firsttime && LogLevel >= 9)
d277 2
a278 2
				(void) opendaemonsocket(&Daemons[idx], FALSE);
				Daemons[idx].d_firsttime = FALSE;
d287 2
d290 1
a290 3
		if (timenow >= last_disk_space_check)
		{
			bool logged = FALSE;
d292 1
a292 47
			if (!enoughdiskspace(MinBlocksFree + 1, FALSE))
			{
				for (idx = 0; idx < ndaemons; idx++)
				{
					if (!bitnset(D_ETRNONLY, Daemons[idx].d_flags))
					{
						/* log only if not logged before */
						if (!logged)
						{
							if (LogLevel >= 9)
								sm_syslog(LOG_INFO, NOQID,
									  "rejecting new messages: min free: %ld",
									  MinBlocksFree);
							logged = TRUE;
							sm_setproctitle(TRUE, e,
									"rejecting new messages: min free: %ld",
									MinBlocksFree);
						}
						setbitn(D_ETRNONLY, Daemons[idx].d_flags);
					}
				}
			}
			else
			{
				for (idx = 0; idx < ndaemons; idx++)
				{
					if (bitnset(D_ETRNONLY, Daemons[idx].d_flags))
					{
						/* log only if not logged before */
						if (!logged)
						{
							if (LogLevel >= 9)
								sm_syslog(LOG_INFO, NOQID,
									  "accepting new messages (again)");
							logged = TRUE;
						}

						/* title will be set below */
						clrbitn(D_ETRNONLY, Daemons[idx].d_flags);
					}
				}
			}
			/* only check disk space once a minute */
			last_disk_space_check = timenow + 60;
		}

# if XDEBUG
d313 1
a313 1
# endif /* XDEBUG */
d315 1
a315 1
# if 0
d323 1
a323 1
		    SetNonBlocking(DaemonSocket, FALSE) < 0)
d325 2
a326 2
# endif /* 0 */
		(void) releasesignal(SIGALRM);
d330 1
a330 1
			bool setproc = FALSE;
d339 2
d344 1
a344 1
			for (idx = 0; idx < ndaemons; idx++)
d353 1
a353 1
						sm_setproctitle(TRUE, e,
d355 1
a355 1
						setproc = TRUE;
d359 2
a360 1
					FD_SET((u_int)Daemons[idx].d_socket, &readfds);
d364 1
a364 1
# if NETUNIX
d369 1
a369 1
				FD_SET(ControlSocket, &readfds);
d371 1
a371 1
# endif /* NETUNIX */
d384 2
d389 3
a391 2
			if (DoQueueRun)
				(void) runqueue(TRUE, FALSE);
a392 1
			curdaemon = -1;
d395 1
a395 1
				timedout = TRUE;
d399 1
a399 1
			control = FALSE;
d403 1
a403 1
			if ((idx = olddaemon + 1) >= ndaemons)
d405 1
a405 1
			for (i = 0; i < ndaemons; i++)
d408 2
a409 1
				    FD_ISSET(Daemons[idx].d_socket, &readfds))
d438 1
a438 1
				if (++idx >= ndaemons)
d441 1
a441 1
# if NETUNIX
d443 1
a443 1
			    FD_ISSET(ControlSocket, &readfds))
d471 1
a471 1
					control = TRUE;
d473 1
a473 1
# else /* NETUNIX */
d479 1
a479 1
# endif /* NETUNIX */
d485 1
a485 1
			timedout = FALSE;
d489 1
a489 2
		timenow = curtime();
		(void) blocksignal(SIGALRM);
d498 1
a498 1
# if SO_REUSEADDR_IS_BROKEN
d505 2
a506 2
			Daemons[curdaemon].d_refuse_connections_until = timenow + 15;
# endif /* SO_REUSEADDR_IS_BROKEN */
d516 2
a517 2
				define(macid("{daemon_family}", NULL),
				       "unspec", &BlankEnvelope);
d519 9
a527 1
# if NETINET
d529 2
a530 2
				define(macid("{daemon_family}", NULL),
				       "inet", &BlankEnvelope);
d532 2
a533 2
# endif /* NETINET */
# if NETINET6
d535 2
a536 2
				define(macid("{daemon_family}", NULL),
				       "inet6", &BlankEnvelope);
d538 2
a539 2
# endif /* NETINET6 */
# if NETISO
d541 2
a542 2
				define(macid("{daemon_family}", NULL),
				       "iso", &BlankEnvelope);
d544 2
a545 2
# endif /* NETISO */
# if NETNS
d547 2
a548 2
				define(macid("{daemon_family}", NULL),
				       "ns", &BlankEnvelope);
d550 2
a551 2
# endif /* NETNS */
# if NETX25
d553 2
a554 2
				define(macid("{daemon_family}", NULL),
				       "x.25", &BlankEnvelope);
d556 1
a556 1
# endif /* NETX25 */
d558 3
a560 2
			define(macid("{daemon_name}", NULL),
			       Daemons[curdaemon].d_name, &BlankEnvelope);
d562 3
a564 3
				define(macid("{daemon_flags}", NULL),
				       Daemons[curdaemon].d_mflags,
				       &BlankEnvelope);
d566 2
a567 2
				define(macid("{daemon_flags}", NULL),
				       "", &BlankEnvelope);
d575 1
a575 1
			dprintf("getrequests: forking (fd = %d)\n", t);
d578 2
a579 2
		**  advance state of PRNG
		**  this is necessary because otherwise all child processes
d584 2
a585 1
# if STARTTLS
d587 3
a589 3
		RAND_seed((void *) &last_disk_space_check,
			sizeof last_disk_space_check);
		RAND_seed((void *) &timenow, sizeof timenow);
d591 1
a591 1
# else /* STARTTLS */
d593 12
a604 1
# endif /* STARTTLS */
d606 1
a606 1
#ifndef DEBUG_NO_FORK
d616 1
a616 1
		(void) blocksignal(SIGCHLD);
d626 1
a626 1
			(void) releasesignal(SIGCHLD);
d631 2
a632 1
#else /* ! DEBUG_NO_FORK */
d634 1
a634 1
#endif /* ! DEBUG_NO_FORK */
d639 1
a639 1
			FILE *inchannel, *outchannel = NULL;
d649 1
d652 15
d668 1
a668 5
			(void) releasesignal(SIGALRM);
			(void) releasesignal(SIGCHLD);
			(void) setsignal(SIGCHLD, SIG_DFL);
			(void) setsignal(SIGHUP, SIG_DFL);
			(void) setsignal(SIGTERM, intsig);
d672 4
a675 4
				define(macid("{daemon_addr}", NULL),
				       newstr(anynet_ntoa(&Daemons[curdaemon].d_addr)),
				       &BlankEnvelope);
				(void) snprintf(status, sizeof status, "%d",
d677 2
a678 2
				define(macid("{daemon_port}", NULL),
				       newstr(status), &BlankEnvelope);
d681 1
a681 1
			for (idx = 0; idx < ndaemons; idx++)
d693 3
a695 2
				proc_list_add(getpid(), "console socket child",
					PROC_CONTROL_CHILD);
d702 2
a703 2
				proc_list_add(getpid(), "daemon child",
					      PROC_DAEMON_CHILD);
d708 1
a708 1
				sm_setproctitle(TRUE, e, "startup with %s",
d712 1
a712 1
#ifndef DEBUG_NO_FORK
d734 1
a734 1
#endif /* ! DEBUG_NO_FORK */
a739 1

d746 1
a746 1
			if (strlen(p) > (SIZE_T) MAXNAME)
d751 3
a753 4
				/* TEMP, FAIL: which one? */
				define(macid("{client_resolve}", NULL),
				       (h_errno == TRY_AGAIN) ? "TEMP" : "FAIL",
				       &BlankEnvelope);
d756 18
a773 10
				define(macid("{client_resolve}", NULL), "OK",
				       &BlankEnvelope);
			sm_setproctitle(TRUE, e, "startup with %s", p);

			if ((inchannel = fdopen(t, "r")) == NULL ||
			    (t = dup(t)) < 0 ||
			    (outchannel = fdopen(t, "w")) == NULL)
			{
				syserr("cannot open SMTP server channel, fd=%d", t);
				finis(FALSE, EX_OK);
d775 1
d779 1
a779 1
			DisConnected = FALSE;
d781 1
a781 1
# ifdef XLA
d785 1
a785 1
				finis(FALSE, EX_OK);
d787 1
a787 1
# endif /* XLA */
d789 2
a790 2
			if (getsockname(fileno(InChannel), &sa.sa,
					&len) == 0)
d794 8
a801 3
					dprintf("getreq: got name %s\n", p);
				define(macid("{if_name}", NULL),
				       newstr(p), &BlankEnvelope);
a802 2
				/* do this only if it is not the loopback */
				/* interface: how to figure out? XXX */
d805 13
a817 7
					define(macid("{if_addr}", NULL),
					       newstr(anynet_ntoa(&sa)),
					       &BlankEnvelope);
					p = xalloc(5);
					snprintf(p, 4, "%d", sa.sa.sa_family);
					define(macid("{if_family}", NULL), p,
					       &BlankEnvelope);
d819 2
a820 5
						dprintf("getreq: got addr %s and family %s\n",
							macvalue(macid("{if_addr}", NULL),
								 &BlankEnvelope),
							macvalue(macid("{if_addr}", NULL),
								 &BlankEnvelope));
d824 6
a829 4
					define(macid("{if_addr}", NULL), NULL,
					       &BlankEnvelope);
					define(macid("{if_family}", NULL), NULL,
					       &BlankEnvelope);
d835 7
a841 7
					dprintf("getreq: getsockname failed\n");
				define(macid("{if_name}", NULL), NULL,
				       &BlankEnvelope);
				define(macid("{if_addr}", NULL), NULL,
				       &BlankEnvelope);
				define(macid("{if_family}", NULL), NULL,
				       &BlankEnvelope);
d849 3
a851 2
			snprintf(status, sizeof status, "control socket server child");
			proc_list_add(pid, status, PROC_CONTROL);
d855 4
a858 4
			snprintf(status, sizeof status,
				 "SMTP server child for %s",
				 anynet_ntoa(&RealHostAddr));
			proc_list_add(pid, status, PROC_DAEMON);
d860 1
a860 1
		(void) releasesignal(SIGCHLD);
d879 2
d882 17
a898 2
	if (tTd(15, 2))
		dprintf("getreq: returning\n");
d901 74
d992 1
a992 1
# define MAXOPENTRIES	10	/* maximum number of tries to open connection */
d996 1
a996 1
	struct daemon *d;
d1006 1
a1006 1
		dprintf("opendaemonsocket(%s)\n", d->d_name);
d1014 25
d1044 3
a1046 1
				syserr("opendaemonsocket: daemon %s: can't create server SMTP socket", d->d_name);
d1048 2
a1049 2
				    (save_errno == EAFNOSUPPORT ||
				     save_errno == EPROTONOSUPPORT))
d1051 2
a1052 1
					syserr("opendaemonsocket: daemon %s: optional socket disabled", d->d_name);
d1054 1
d1060 2
a1061 1
						  "daemon %s: problem creating SMTP socket", d->d_name);
d1077 1
a1077 1
# ifdef SO_RCVBUF
d1086 2
a1087 2
# endif /* SO_RCVBUF */
# ifdef SO_SNDBUF
d1096 1
a1096 1
# endif /* SO_SNDBUF */
d1106 1
a1106 1
				       errstring(save_errno));
d1113 8
a1120 1
# if NETINET
d1124 1
a1124 1
# endif /* NETINET */
d1126 1
a1126 1
# if NETINET6
d1130 1
a1130 1
# endif /* NETINET6 */
d1132 1
a1132 1
# if NETISO
d1136 1
a1136 1
# endif /* NETISO */
d1150 1
a1150 1
				goto severe;
a1173 1
**		daemon -- number of daemon
d1179 2
a1180 1
static u_short
d1184 1
a1184 1
	u_short port;
d1193 1
a1193 1
# if NETINET
d1195 1
a1195 1
# endif /* NETINET */
d1200 1
a1200 1
# if NETINET
d1206 1
a1206 1
# endif /* NETINET */
d1208 1
a1208 1
# if NETINET6
d1214 1
a1214 1
# endif /* NETINET6 */
d1223 1
a1223 1
# ifdef NO_GETSERVBYNAME
d1225 1
a1225 1
# else /* NO_GETSERVBYNAME */
d1238 1
a1238 1
# endif /* NO_GETSERVBYNAME */
d1243 1
a1243 1
# if NETINET
d1247 1
a1247 1
# endif /* NETINET */
d1249 1
a1249 1
# if NETINET6
d1253 1
a1253 1
# endif /* NETINET6 */
d1259 1
a1259 1
	return(port);
d1279 1
a1279 1
	for (i = 0; i < ndaemons; i++)
d1286 66
d1366 1
a1366 1
	struct daemon *d;
d1368 1
a1368 1
# if NETISO
d1370 1
a1370 3
# endif /* NETISO */
	int l;
	char *h, *flags;
d1374 1
a1374 1
# if NETINET
d1377 1
a1377 1
# endif /* NETINET */
d1405 9
a1413 2
# if NETINET
			else if (strcasecmp(v, "inet") == 0)
d1415 3
a1417 3
# endif /* NETINET */
# if NETINET6
			else if (strcasecmp(v, "inet6") == 0)
d1419 3
a1421 3
# endif /* NETINET6 */
# if NETISO
			else if (strcasecmp(v, "iso") == 0)
d1423 3
a1425 3
# endif /* NETISO */
# if NETNS
			else if (strcasecmp(v, "ns") == 0)
d1427 3
a1429 3
# endif /* NETNS */
# if NETX25
			else if (strcasecmp(v, "x.25") == 0)
d1431 1
a1431 1
# endif /* NETX25 */
d1441 8
d1458 1
a1458 19
			l = 3 * strlen(v) + 3;
			h = v;
			flags = xalloc(l);
			d->d_mflags = flags;
			for (; *h != '\0'; h++)
			{
				if (!(isascii(*h) && isspace(*h)))
				{
					if (flags != d->d_mflags)
						*flags++ = ' ';
					*flags++ = *h;
					if (isupper(*h))
						*flags++ = *h;
				}
			}
			*flags++ = '\0';
			for (; *v != '\0'; v++)
				if (!(isascii(*v) && isspace(*v)))
					setbitn(bitidx(*v), d->d_flags);
d1484 29
a1512 1
# if NETINET
d1515 2
a1516 1
			    ((d->d_addr.sin.sin_addr.s_addr = inet_addr(addr)) == INADDR_NONE))
d1536 1
a1536 1
#  if _FFR_FREEHOSTENT && NETINET6
d1539 1
a1539 1
#  endif /* _FFR_FREEHOSTENT && NETINET6 */
d1543 1
a1543 1
# endif /* NETINET */
d1545 1
a1545 1
# if NETINET6
d1547 3
a1549 4
			if (!isascii(*addr) ||
			    (!isxdigit(*addr) && *addr != ':') ||
			    inet_pton(AF_INET6, addr,
				      &d->d_addr.sin6.sin6_addr) != 1)
a1568 1
#  if _FFR_FREEHOSTENT
a1570 1
#  endif /* _FFR_FREEHOSTENT */
d1574 1
a1574 1
# endif /* NETINET6 */
d1587 1
a1587 1
# if NETINET
d1590 2
a1591 1
				d->d_addr.sin.sin_port = htons((u_short)atoi((const char *)port));
d1594 1
a1594 1
#  ifdef NO_GETSERVBYNAME
d1597 1
a1597 1
#  else /* NO_GETSERVBYNAME */
d1606 1
a1606 1
#  endif /* NO_GETSERVBYNAME */
d1609 1
a1609 1
# endif /* NETINET */
d1611 1
a1611 1
# if NETINET6
d1614 2
a1615 1
				d->d_addr.sin6.sin6_port = htons((u_short)atoi(port));
d1618 1
a1618 1
#  ifdef NO_GETSERVBYNAME
d1621 1
a1621 1
#  else /* NO_GETSERVBYNAME */
d1630 1
a1630 1
#  endif /* NO_GETSERVBYNAME */
d1633 1
a1633 1
# endif /* NETINET6 */
d1635 1
a1635 1
# if NETISO
d1639 1
a1639 1
				portno = htons((u_short)atoi(port));
d1642 1
a1642 1
#  ifdef NO_GETSERVBYNAME
d1645 1
a1645 1
#  else /* NO_GETSERVBYNAME */
d1654 1
a1654 1
#  endif /* NO_GETSERVBYNAME */
d1659 1
a1659 1
# endif /* NETISO */
d1675 4
a1678 1
**		TRUE if successful, FALSE otherwise.
d1681 2
d1687 13
a1699 6
	if (ndaemons >= MAXDAEMONS)
		return FALSE;
	Daemons[ndaemons].d_socket = -1;
	Daemons[ndaemons].d_listenqueue = 10;
	clrbitmap(Daemons[ndaemons].d_flags);
	setsockaddroptions(p, &Daemons[ndaemons]);
d1701 2
a1702 2
	if (Daemons[ndaemons].d_name != NULL)
		Daemons[ndaemons].d_name = newstr(Daemons[ndaemons].d_name);
d1707 2
a1708 2
		snprintf(num, sizeof num, "Daemon%d", ndaemons);
		Daemons[ndaemons].d_name = newstr(num);
d1713 6
a1718 6
		dprintf("Daemon %s flags: ", Daemons[ndaemons].d_name);
		if (bitnset(D_ETRNONLY, Daemons[ndaemons].d_flags))
			dprintf("ETRNONLY ");
		if (bitnset(D_NOETRN, Daemons[ndaemons].d_flags))
			dprintf("NOETRN ");
		dprintf("\n");
d1720 2
a1721 2
	++ndaemons;
	return TRUE;
d1735 1
d1739 1
a1739 1
	if (ndaemons == 0)
d1741 4
a1744 4
		Daemons[ndaemons].d_socket = -1;
		Daemons[ndaemons].d_listenqueue = 10;
		Daemons[ndaemons].d_name = "Daemon0";
		ndaemons = 1;
d1757 1
a1757 1
static SOCKADDR	ClientAddr;		/* address for client */
d1763 2
a1764 2
	struct daemon d;
	extern ENVELOPE BlankEnvelope;
d1770 5
a1774 6
	memcpy(&ClientAddr, &d.d_addr, sizeof ClientAddr);
	TcpSndBufferSize = d.d_tcpsndbufsize;
	TcpRcvBufferSize = d.d_tcprcvbufsize;
	if (d.d_mflags != NULL)
		define(macid("{client_flags}", NULL), d.d_mflags,
		       &BlankEnvelope);
d1776 6
a1781 1
		define(macid("{client_flags}", NULL), "", &BlankEnvelope);
d1800 1
a1800 1
# if NETINET6
d1802 1
a1802 1
# endif /* NETINET6 */
d1804 1
a1804 1
# if NETINET
d1808 1
a1808 1
			printf("addr_family(%s): INET\n", addr);
d1811 3
a1813 3
# endif /* NETINET */
# if NETINET6
	if (inet_pton(AF_INET6, addr, &clt_addr.sin6.sin6_addr) == 1)
d1816 1
a1816 1
			printf("addr_family(%s): INET6\n", addr);
d1819 11
a1829 1
# endif /* NETINET6 */
d1831 1
a1831 1
		printf("addr_family(%s): UNSPEC\n", addr);
d1834 66
d1909 2
d1925 1
a1925 1
makeconnection(host, port, mci, e)
d1927 1
a1927 1
	volatile u_int port;
d1930 1
d1934 1
a1934 1
	register struct hostent *volatile hp = (struct hostent *)NULL;
d1940 4
a1943 4
	EVENT *volatile ev = NULL;
# if NETINET6
	volatile bool v6found = FALSE;
# endif /* NETINET6 */
d1952 1
a1952 1
	/* retranslate ${daemon_flags} into bitmap */
d1954 1
a1954 1
	if ((p = macvalue(macid("{daemon_flags}", NULL), e)) != NULL)
d1963 1
a1963 15
	/* "add" ${client_flags} to bitmap */
	if ((p = macvalue(macid("{client_flags}", NULL), e)) != NULL)
	{
		for (; *p != '\0'; p++)
		{
			/* look for just this one flag */
			if (*p == D_IFNHELO)
			{
				setbitn(bitidx(*p), d_flags);
				break;
			}
		}
	}

# if NETINET6
d1965 2
a1966 2
# endif /* NETINET6 */
	clt_bind = FALSE;
d1970 1
a1970 1
	    (p = macvalue(macid("{if_addr}", NULL), e)) != NULL &&
d1973 1
a1973 1
# if NETINET6
d1975 1
a1975 1
# endif /* NETINET6 */
d1983 1
a1983 1
# if NETINET
d1989 1
a1989 1
				clt_bind = TRUE;
d1993 1
a1993 1
# endif /* NETINET */
d1995 1
a1995 1
# if NETINET6
d1998 2
a1999 1
				snprintf(p6, sizeof p6, "::ffff:%s", p);
d2001 3
a2003 3
				strlcpy(p6, p, sizeof p6);
			if (inet_pton(AF_INET6, p6,
				      &clt_addr.sin6.sin6_addr) == 1 &&
d2006 1
a2006 1
				clt_bind = TRUE;
d2010 1
a2010 1
# endif /* NETINET6 */
d2012 1
a2012 1
# if 0
d2017 1
a2017 1
# endif /* 0 */
d2022 3
a2024 1
	else
d2026 1
a2026 3
		STRUCTCOPY(ClientAddr, clt_addr);
		if (clt_addr.sa.sa_family == AF_UNSPEC)
			clt_addr.sa.sa_family = family;
d2029 1
a2029 1
# if NETINET
d2034 1
a2034 1
				clt_bind = TRUE;
d2036 1
a2036 1
				clt_bind = TRUE;
d2039 2
a2040 2
# endif /* NETINET */
# if NETINET6
d2045 1
a2045 1
				clt_bind = TRUE;
d2048 1
a2048 1
				clt_bind = TRUE;
d2050 2
a2051 2
# endif /* NETINET6 */
# if NETISO
d2054 1
a2054 1
			clt_bind = TRUE;
d2056 1
a2056 1
# endif /* NETISO */
a2066 1
# if NAMED_BIND
a2067 1
# endif /* NAMED_BIND */
d2079 1
a2079 1
# if NETINET
d2081 2
a2082 2
# endif /* NETINET */
# if NETINET6
d2084 1
a2084 1
# endif /* NETINET6 */
d2087 1
a2087 1
# if NETINET6
d2089 2
a2090 2
# endif /* NETINET6 */
# if NETINET
d2098 2
a2099 2
# endif /* NETINET */
# if NETINET6
d2101 2
a2102 2
			    inet_pton(AF_INET6, &host[1],
				      &hid6.sin6_addr) == 1)
d2108 1
a2108 1
# endif /* NETINET6 */
d2114 1
a2114 1
# if NAMED_BIND
d2118 1
a2118 1
# endif /* NAMED_BIND */
d2123 1
a2123 1
# if NAMED_BIND
d2125 1
a2125 1
# endif /* NAMED_BIND */
d2152 1
a2152 1
# if NAMED_BIND
d2156 1
a2156 1
# endif /* NAMED_BIND */
d2160 1
a2160 1
# if NAMED_BIND
d2162 1
a2162 1
# endif /* NAMED_BIND */
d2168 1
a2168 1
# if NAMED_BIND
d2178 2
a2179 2
# endif /* NAMED_BIND */
# if NETINET6
d2193 1
a2193 1
# endif /* NETINET6 */
d2202 1
a2202 1
# if NETINET
d2208 1
a2208 1
# endif /* NETINET */
d2210 1
a2210 1
# if NETINET6
d2216 1
a2216 1
# endif /* NETINET6 */
d2227 1
a2227 3
			memmove(addr.sa.sa_data,
				hp->h_addr,
				hp->h_length);
d2239 1
a2239 1
# ifdef NO_GETSERVBYNAME
d2241 1
a2241 1
# else /* NO_GETSERVBYNAME */
d2253 15
a2267 1
# endif /* NO_GETSERVBYNAME */
d2269 1
d2273 1
a2273 1
# if NETINET
d2278 1
a2278 1
# endif /* NETINET */
d2280 1
a2280 1
# if NETINET6
d2285 1
a2285 1
# endif /* NETINET6 */
d2287 1
a2287 1
# if NETISO
d2293 1
a2293 1
# endif /* NETISO */
d2299 1
a2299 1
# if _FFR_FREEHOSTENT && NETINET6
d2302 1
a2302 1
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d2310 1
a2310 1
# ifdef XLA
d2314 1
a2314 1
#  if _FFR_FREEHOSTENT && NETINET6
d2317 1
a2317 1
#  endif /* _FFR_FREEHOSTENT && NETINET6 */
d2320 1
a2320 1
# endif /* XLA */
d2322 1
a2322 1
	firstconnect = TRUE;
d2326 3
a2328 3
			dprintf("makeconnection (%s [%s].%d (%d))\n",
				host, anynet_ntoa(&addr), ntohs(port),
				addr.sa.sa_family);
d2341 1
a2341 1
			s = socket(clt_addr.sa.sa_family, SOCK_STREAM, 0);
d2347 1
a2347 1
# ifdef XLA
d2349 1
a2349 1
# endif /* XLA */
d2351 1
a2351 1
# if _FFR_FREEHOSTENT && NETINET6
d2354 1
a2354 1
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d2359 2
a2360 2
# ifdef SO_SNDBUF
		if (TcpSndBufferSize > 0)
d2363 2
a2364 2
				       (char *) &TcpSndBufferSize,
				       sizeof(TcpSndBufferSize)) < 0)
d2367 3
a2369 3
# endif /* SO_SNDBUF */
# ifdef SO_RCVBUF
		if (TcpRcvBufferSize > 0)
d2372 2
a2373 2
				       (char *) &TcpRcvBufferSize,
				       sizeof(TcpRcvBufferSize)) < 0)
d2376 1
a2376 2
# endif /* SO_RCVBUF */

d2379 1
a2379 1
			dprintf("makeconnection: fd=%d\n", s);
d2389 3
a2391 3
		if (e->e_xfp != NULL)
			(void) fflush(e->e_xfp);	/* for debugging */
		errno = 0;				/* for debugging */
d2399 1
a2399 1
# if NETINET
d2407 1
a2407 1
# endif /* NETINET */
d2409 1
a2409 1
# if NETINET6
d2417 1
a2417 1
# endif /* NETINET6 */
d2427 1
a2427 1
# if _FFR_FREEHOSTENT && NETINET6
d2430 1
a2430 1
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d2446 2
a2447 2
				ev = setevent(TimeOuts.to_iconnect,
					      connecttimeout, 0);
d2449 2
a2450 2
				ev = setevent(TimeOuts.to_connect,
					      connecttimeout, 0);
d2456 1
a2456 1
# if NETINET
d2460 1
a2460 1
# endif /* NETINET */
d2462 1
a2462 1
# if NETINET6
d2468 1
a2468 1
# endif /* NETINET6 */
d2473 1
a2473 1
				clrevent(ev);
d2481 2
a2482 1
		if (DialDelay > 0 && firstconnect)
d2485 3
a2487 3
				dprintf("Connect failed (%s); trying again...\n",
					errstring(save_errno));
			firstconnect = FALSE;
d2495 1
a2495 1
		if (LogLevel >= 14)
d2499 1
a2499 1
				  errstring(save_errno));
d2501 5
a2505 1
		if (hp != NULL && hp->h_addr_list[addrno] != NULL)
d2508 2
a2509 2
				dprintf("Connect failed (%s); trying new address....\n",
					errstring(save_errno));
d2512 1
a2512 1
# if NETINET
d2518 1
a2518 1
# endif /* NETINET */
d2520 1
a2520 1
# if NETINET6
d2526 1
a2526 1
# endif /* NETINET6 */
d2538 1
a2538 1
# if NETINET6
d2542 3
a2544 3
				dprintf("Connect failed (%s); retrying with AF_INET....\n",
					errstring(save_errno));
			v6found = TRUE;
a2545 1
#  if _FFR_FREEHOSTENT
a2550 1
#  endif /* _FFR_FREEHOSTENT */
d2554 1
a2554 1
# endif /* NETINET6 */
d2556 1
a2556 1
# if NETINET6
d2559 1
a2559 1
# endif /* NETINET6 */
d2562 3
a2564 2
			dprintf("Connect failed (%s)\n", errstring(save_errno));
# ifdef XLA
d2566 1
a2566 1
# endif /* XLA */
d2568 1
a2568 1
# if _FFR_FREEHOSTENT && NETINET6
d2571 1
a2571 1
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d2576 1
a2576 1
# if _FFR_FREEHOSTENT && NETINET6
d2582 1
a2582 1
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d2586 2
a2587 1
	if ((mci->mci_out = fdopen(s, "w")) == NULL ||
d2589 2
a2590 1
	    (mci->mci_in = fdopen(s, "r")) == NULL)
d2596 1
a2596 1
			(void) fclose(mci->mci_out);
d2601 19
d2626 1
a2626 1
		char *p;
d2628 6
a2633 5
		define(macid("{if_addr}", NULL), newstr(anynet_ntoa(&addr)),
		       &BlankEnvelope);
		p = xalloc(5);
		snprintf(p, 4, "%d", addr.sa.sa_family);
		define(macid("{if_family}", NULL), p, &BlankEnvelope);
d2636 2
a2637 1
		define(macid("{if_name}", NULL), newstr(name), &BlankEnvelope);
d2652 6
a2657 3
		define(macid("{if_name}", NULL), NULL, &BlankEnvelope);
		define(macid("{if_addr}", NULL), NULL, &BlankEnvelope);
		define(macid("{if_family}", NULL), NULL, &BlankEnvelope);
d2691 3
a2693 2
# if NETUNIX
int makeconnection_ds(mux_path, mci)
d2721 2
a2722 1
		/* XXX why TEMPFAIL ? */
d2727 2
a2728 1
	(void) strlcpy(unix_addr.sun_path, mux_path, sizeof unix_addr.sun_path);
d2755 7
a2761 3
	if ((mci->mci_out = fdopen(sock, "w")) == NULL ||
	    (sock = dup(sock)) < 0 ||
	    (mci->mci_in = fdopen(sock, "r")) == NULL)
d2767 1
a2767 1
			(void) fclose(mci->mci_out);
d2772 1
d2778 1
a2778 1
# endif /* NETUNIX */
d2780 1
a2780 1
**  SIGHUP -- handle a SIGHUP signal
d2783 1
a2783 1
**		sig -- incoming signal.
d2789 1
a2789 6
**		Sets RestartRequest which should cause the daemon
**		to restart.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
d2792 2
a2793 4
/* ARGSUSED */
static SIGFUNC_DECL
sighup(sig)
	int sig;
d2795 7
a2801 1
	int save_errno = errno;
d2803 11
a2813 4
	FIX_SYSV_SIGNAL(sig, sighup);
	RestartRequest = "signal";
	errno = save_errno;
	return SIGFUNC_RETURN;
d2832 1
a2832 1
	(old) = setsignal((sig), sm_signal_noop);		\
d2834 1
a2834 1
		(void) setsignal((sig), (old));			\
d2837 1
a2837 1
static void
d2840 1
d2848 2
a2849 2
	clear_events();
	allsignals(TRUE);
d2860 2
a2861 1
		finis(FALSE, EX_OSFILE);
d2868 13
a2880 2
	closecontrolsocket(TRUE);
	if (drop_privileges(TRUE) != EX_OK)
d2884 4
a2887 3
				  "could not set[ug]id(%d, %d): %m",
				  RunAsUid, RunAsGid);
		finis(FALSE, EX_OSERR);
d2898 3
d2918 1
a2918 1
	allsignals(FALSE);
d2924 1
a2924 1
	allsignals(TRUE);
d2927 1
a2927 1
	(void) setsignal(SIGALRM, oalrm);
d2931 1
a2931 1
	(void) setsignal(SIGUSR1, ousr1);
d2936 4
a2939 3
		sm_syslog(LOG_ALERT, NOQID, "could not exec %s: %m",
			  SaveArgv[0]);
	finis(FALSE, EX_OSFILE);
d2963 1
a2963 1
		(void) strlcpy(hostbuf, "localhost", size);
d2965 1
a2965 1
# if NETINET && NETINET6
d2976 1
a2976 2
# endif /* NETINET && NETINET6 */

d2982 1
a2982 1
# if NETINFO
d2991 1
a2991 4
		{
			(void) strlcat(hostbuf, ".", size);
			(void) strlcat(hostbuf, domainname, size);
		}
d2993 1
a2993 1
# endif /* NETINFO */
d3025 1
a3025 1
	    !getcanonname(hostbuf, size, TRUE))
d3033 1
a3033 1
		if (!getcanonname(hostbuf, size, TRUE))
d3063 3
a3065 3
# if NETINET6
	u_char *a;
# endif /* NETINET6 */
d3069 1
a3069 1
# if NETINET
d3074 1
a3074 1
# endif /* NETINET */
d3076 1
a3076 1
# if NETINET6
d3078 1
a3078 1
		a = (u_char *) &sa->sin6.sin6_addr;
d3089 1
a3089 1
# endif /* NETINET6 */
d3100 1
a3100 1
**		may_be_forged -- an outage that is set to TRUE if the
d3102 1
a3102 1
**			RealHostAddr; set to FALSE if they do match.
d3128 1
a3128 1
	volatile u_short port = 0;
d3133 1
d3135 7
d3144 2
a3145 1
	EVENT *ev;
d3153 1
a3153 1
	*may_be_forged = FALSE;
d3165 1
d3170 2
a3171 2
		(void) snprintf(hbuf, sizeof hbuf, "%s@@localhost",
				RealUserName);
d3173 1
a3173 1
			dprintf("getauthinfo: %s\n", hbuf);
d3182 1
a3182 1
			RealHostName[MAXNAME] = '\0';
d3186 2
a3187 10
	if (anynet_ntoa(&RealHostAddr)[0] == '[' ||
	    RealHostName[0] == '[')
	{
		/*
		**  address is not a socket or have an
		**  IP address with no forward lookup
		*/
		*may_be_forged = FALSE;
	}
	else
d3192 1
a3192 1
# if NETINET6 && NEEDSGETIPNODE
d3209 1
a3209 1
# endif /* NETINET6 && NEEDSGETIPNODE */
d3214 1
a3214 1
			*may_be_forged = TRUE;
d3218 1
d3221 1
d3223 1
a3223 1
# if _FFR_FREEHOSTENT && NETINET6
d3226 1
a3226 1
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d3236 1
a3236 1
# if NETINET
d3248 1
a3248 1
		(void) snprintf(ibuf, sizeof ibuf, "%d,%d\r\n",
d3256 1
a3256 1
#  ifdef NO_GETSERVBYNAME
d3258 22
a3279 6
#  else /* NO_GETSERVBYNAME */
		sp = getservbyname("auth", "tcp");
		if (sp != NULL)
			RealHostAddr.sin.sin_port = sp->s_port;
		else
			RealHostAddr.sin.sin_port = htons(113);
d3281 2
a3282 2
#  endif /* NO_GETSERVBYNAME */
# endif /* NETINET */
d3284 1
a3284 1
# if NETINET6
d3296 1
a3296 1
		(void) snprintf(ibuf, sizeof ibuf, "%d,%d\r\n",
d3304 1
a3304 1
#  ifdef NO_GETSERVBYNAME
d3306 10
a3315 6
#  else /* NO_GETSERVBYNAME */
		sp = getservbyname("auth", "tcp");
		if (sp != NULL)
			RealHostAddr.sin6.sin6_port = sp->s_port;
		else
			RealHostAddr.sin6.sin6_port = htons(113);
d3317 2
a3318 2
#  endif /* NO_GETSERVBYNAME */
# endif /* NETINET6 */
d3333 1
a3333 1
	ev = setevent(TimeOuts.to_ident, authtimeout, 0);
d3340 1
a3340 1
		clrevent(ev);
a3344 1
	{
a3345 1
	}
d3348 1
a3348 1
		dprintf("getauthinfo: sent %s", ibuf);
d3362 1
a3362 1
		if (strchr(ibuf, '\n') != NULL)
d3366 1
a3366 1
	clrevent(ev);
d3375 1
a3375 1
		dprintf("getauthinfo:  got %s\n", ibuf);
d3386 1
a3386 1
	if (strncasecmp(p, "userid", 6) != 0)
d3425 1
a3425 1
	if (strncasecmp(ostype, "other", 5) == 0 &&
d3428 1
a3428 1
		snprintf(hbuf, sizeof hbuf, "IDENT:");
d3433 3
a3435 3
	i = strlen(hbuf);
	snprintf(&hbuf[i], sizeof hbuf - i, "@@%s",
		 RealHostName == NULL ? "localhost" : RealHostName);
d3440 1
a3440 1
	clrevent(ev);
d3446 1
a3446 1
# if NETINET
d3451 1
a3451 1
# endif /* NETINET */
d3453 1
a3453 1
# if NETINET6
d3458 1
a3458 1
# endif /* NETINET6 */
d3464 1
a3464 1
			dprintf("getauthinfo: NULL\n");
d3467 1
a3467 1
	snprintf(hbuf, sizeof hbuf, "%s", RealHostName);
d3470 4
a3473 4
# if IP_SRCROUTE
#  ifndef GET_IPOPT_DST
#   define GET_IPOPT_DST(dst)	(dst)
#  endif /* ! GET_IPOPT_DST */
d3491 2
a3492 2
		u_char *q;
		u_char *o;
d3502 2
a3503 2
		o = (u_char *) ipopt.IP_LIST;
		while (o != NULL && o < (u_char *) &ipopt + ipoptlen)
d3530 5
a3534 4
				snprintf(p, SPACELEFT(hbuf, p), " [%s@@%.*s",
				    *o == IPOPT_SSRR ? "!" : "",
				    l > 240 ? 120 : l / 2,
				    inet_ntoa(GET_IPOPT_DST(ipopt.IP_DST)));
d3548 7
a3554 6
					snprintf(p, SPACELEFT(hbuf, p),
						 "%c%.*s",
						 j != 0 ? '@@' : ':',
						 l > 240 ? 120 :
						 j == 0 ? l : l / 2,
						 inet_ntoa(addr));
d3569 1
a3569 1
		snprintf(p, SPACELEFT(hbuf, p), "]");
d3574 1
a3574 1
# endif /* IP_SRCROUTE */
d3578 2
a3579 2
		(void) snprintf(p, SPACELEFT(hbuf, p), " [%.100s]",
			anynet_ntoa(&RealHostAddr));
d3584 3
a3586 1
		(void) snprintf(p, SPACELEFT(hbuf, p), " (may be forged)");
d3589 1
a3589 1
# if IP_SRCROUTE
d3591 1
a3591 3
# endif /* IP_SRCROUTE */
	if (tTd(9, 1))
		dprintf("getauthinfo: %s\n", hbuf);
d3596 1
a3596 1
# if NETINET
d3601 1
a3601 1
# endif /* NETINET */
d3603 1
a3603 1
# if NETINET6
d3608 1
a3608 1
# endif /* NETINET6 */
d3611 2
d3645 1
a3645 1
# if NETINET
d3647 2
a3648 2
# endif /* NETINET */
# if NETINET6
d3650 1
a3650 1
# endif /* NETINET6 */
d3653 5
d3662 1
a3662 1
	**  return it.
d3665 1
d3667 2
a3668 1
	if (bitset(NCF_VALID, s->s_namecanon.nc_flags))
d3671 3
a3673 3
			dprintf("host_map_lookup(%s) => CACHE %s\n",
				name,
				s->s_namecanon.nc_cname == NULL
a3676 1
# if NAMED_BIND
a3677 1
# endif /* NAMED_BIND */
d3715 1
a3715 1
			dprintf("host_map_lookup(%s) => DEFERRED\n", name);
d3728 16
a3743 1
		dprintf("host_map_lookup(%s) => ", name);
d3746 5
a3750 2
		snprintf(hbuf, sizeof hbuf, "%s", name);
		if (getcanonname(hbuf, sizeof hbuf - 1, !HasWildcardMX))
d3752 4
d3762 1
a3762 1
				dprintf("FAILED\n");
d3768 1
a3768 1
# if NETINET
d3772 2
a3773 2
# endif /* NETINET */
# if NETINET6
d3775 1
a3775 1
		    inet_pton(AF_INET6, &name[1], &in6_addr) == 1)
d3778 1
a3778 1
# endif /* NETINET6 */
d3784 10
a3793 2
			ans = denlstring((char *) hp->h_name, TRUE, TRUE);
# if _FFR_FREEHOSTENT && NETINET6
d3796 1
a3796 1
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d3799 6
d3812 3
a3814 1
		s->s_namecanon.nc_cname = newstr(ans);
d3820 1
a3820 1
			dprintf("FOUND %s\n", ans);
d3827 1
a3827 1
# if NAMED_BIND
d3830 1
a3830 1
		dprintf("FAIL (%d)\n", h_errno);
d3856 1
a3856 1
# else /* NAMED_BIND */
d3858 1
a3858 1
		dprintf("FAIL\n");
d3860 1
a3860 1
# endif /* NAMED_BIND */
a3863 30
#else /* DAEMON */
/* code for systems without sophisticated networking */

/*
**  MYHOSTNAME -- stub version for case of no daemon code.
**
**	Can't convert to upper case here because might be a UUCP name.
**
**	Mark, you can change this to be anything you want......
*/

char **
myhostname(hostbuf, size)
	char hostbuf[];
	int size;
{
	register FILE *f;

	hostbuf[0] = '\0';
	f = fopen("/usr/include/whoami", "r");
	if (f != NULL)
	{
		(void) fgets(hostbuf, size, f);
		fixcrlf(hostbuf, TRUE);
		(void) fclose(f);
	}
	if (hostbuf[0] == '\0')
		(void) strlcpy(hostbuf, "localhost", size);
	return NULL;
}
d3865 1
a3865 1
**  GETAUTHINFO -- get the real host name associated with a file descriptor
d3868 2
a3869 30
**		fd -- the descriptor
**		may_be_forged -- an outage that is set to TRUE if the
**			forward lookup of RealHostName does not match
**			RealHostAddr; set to FALSE if they do match.
**
**	Returns:
**		The host name associated with this descriptor, if it can
**			be determined.
**		NULL otherwise.
**
**	Side Effects:
**		none
*/

char *
getauthinfo(fd, may_be_forged)
	int fd;
	bool *may_be_forged;
{
	*may_be_forged = FALSE;
	return NULL;
}
/*
**  HOST_MAP_LOOKUP -- turn a hostname into canonical form
**
**	Parameters:
**		map -- a pointer to the database map.
**		name -- a buffer containing a hostname.
**		avp -- a pointer to a (cf file defined) argument vector.
**		statp -- an exit status (out parameter).
d3872 1
a3872 72
**		mapped host name
**		FALSE otherwise.
**
**	Side Effects:
**		Looks up the host specified in name.  If it is not
**		the canonical name for that host, replace it with
**		the canonical name.  If the name is unknown, or it
**		is already the canonical name, leave it unchanged.
*/

/*ARGSUSED*/
char *
host_map_lookup(map, name, avp, statp)
	MAP *map;
	char *name;
	char **avp;
	char *statp;
{
	register struct hostent *hp = NULL;
	char *cp;

	hp = sm_gethostbyname(name, InetMode);
	if (hp == NULL && InetMode != AF_INET)
		hp = sm_gethostbyname(name, AF_INET);
	if (hp == NULL)
	{
# if NAMED_BIND
		if (tTd(9, 1))
			dprintf("FAIL (%d)\n", h_errno);
		switch (h_errno)
		{
		  case TRY_AGAIN:
			if (UseNameServer)
			{
				CurEnv->e_status = "4.4.3";
				message("851 %s: Name server timeout",
					shortenstring(name, 33));
			}
			*statp = EX_TEMPFAIL;
			break;

		  case HOST_NOT_FOUND:
		  case NO_DATA:
			*statp = EX_NOHOST;
			break;

		  case NO_RECOVERY:
			*statp = EX_SOFTWARE;
			break;

		  default:
			*statp = EX_UNAVAILABLE;
			break;
		}
#else /* NAMED_BIND */
		*statp = EX_NOHOST;
#endif /* NAMED_BIND */
		return NULL;
	}
	if (bitset(MF_MATCHONLY, map->map_mflags))
		cp = map_rewrite(map, name, strlen(name), NULL);
	else
		cp = map_rewrite(map, hp->h_name, strlen(hp->h_name), avp);
# if _FFR_FREEHOSTENT && NETINET6
	freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
	return cp;
}

#endif /* DAEMON */
/*
**  HOST_MAP_INIT -- initialize host class structures
d3913 21
d3944 1
a3944 1
	return TRUE;
d3959 1
d3973 13
d3987 5
d3994 27
d4058 2
a4059 2
			snprintf(buf, sizeof buf, "[UNIX: %.64s]",
				sap->sunix.sun_path);
d4061 1
a4061 1
			snprintf(buf, sizeof buf, "[UNIX: localhost]");
d4080 2
a4081 2
		snprintf(buf, sizeof buf, "[LINK: %s]",
			link_ntoa((struct sockaddr_dl *) &sap->sa));
d4091 1
a4091 1
	(void) snprintf(buf, sizeof buf, "Family %d: ", sap->sa.sa_family);
d4096 2
a4097 1
		(void) snprintf(bp, SPACELEFT(buf, bp), "%02x:", *ap++ & 0377);
d4140 1
a4140 2
			INADDRSZ,
			AF_INET);
d4147 1
a4147 2
				      IN6ADDRSZ,
				      AF_INET6);
d4154 1
a4154 2
			sizeof sap->siso.siso_addr,
			AF_ISO);
d4165 2
a4166 3
		hp = sm_gethostbyaddr(sap->sa.sa_data,
			   sizeof sap->sa.sa_data,
			   sap->sa.sa_family);
d4186 2
a4187 3
		name = denlstring((char *) hp->h_name, TRUE, TRUE);

#  if _FFR_FREEHOSTENT && NETINET6
d4193 1
a4193 1
			strlcpy(n, name, sizeof n);
a4195 1

d4197 1
a4197 1
#  endif /* _FFR_FREEHOSTENT && NETINET6 */
d4202 1
a4202 1
# if _FFR_FREEHOSTENT && NETINET6
d4208 1
a4208 1
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d4217 2
a4218 1
		(void) snprintf(buf, sizeof buf, "[%.200s]", anynet_ntoa(sap));
@


1.7
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d19 1
a19 1
static char id[] = "@@(#)$Sendmail: daemon.c,v 8.401.4.61 2001/05/27 22:14:40 gshapiro Exp $ (with daemon mode)";
d21 1
a21 1
static char id[] = "@@(#)$Sendmail: daemon.c,v 8.401.4.61 2001/05/27 22:14:40 gshapiro Exp $ (without daemon mode)";
a706 1

d722 1
d2494 9
d2509 1
a2509 1
	sigfunc_t oalrm, ochld, ohup, oint, opipe, oterm, ousr1;
d2512 2
d2551 16
a2566 8
	/* need to allow signals before execve() so make them harmless */
	oalrm = setsignal(SIGALRM, SIG_DFL);
	ochld = setsignal(SIGCHLD, SIG_DFL);
	ohup = setsignal(SIGHUP, SIG_DFL);
	oint = setsignal(SIGINT, SIG_DFL);
	opipe = setsignal(SIGPIPE, SIG_DFL);
	oterm = setsignal(SIGTERM, SIG_DFL);
	ousr1 = setsignal(SIGUSR1, SIG_DFL);
d2572 1
a2572 1
	/* restore signals */
d2574 2
d2577 3
a2579 5
	(void) setsignal(SIGCHLD, ochld);
	(void) setsignal(SIGHUP, ohup);
	(void) setsignal(SIGINT, oint);
	(void) setsignal(SIGPIPE, opipe);
	(void) setsignal(SIGTERM, oterm);
d2581 1
d2613 13
d2839 22
d2862 1
a2862 3
		hp = sm_gethostbyname(RealHostName,
				      RealHostAddr.sa.sa_family);

@


1.6
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d19 1
a19 1
static char id[] = "@@(#)$Sendmail: daemon.c,v 8.401.4.51 2001/02/23 18:57:27 geir Exp $ (with daemon mode)";
d21 1
a21 1
static char id[] = "@@(#)$Sendmail: daemon.c,v 8.401.4.51 2001/02/23 18:57:27 geir Exp $ (without daemon mode)";
d90 2
d199 4
d244 5
d312 6
d411 5
d446 1
a446 13
			/*
			**  if one socket is closed, set the timeout
			**  to 5 seconds (so it might get reopened soon),
			**  otherwise (all sockets open) 60.
			*/

			idx = 0;
			while (idx < ndaemons && Daemons[idx].d_socket >= 0)
				idx++;
			if (idx < ndaemons)
				timeout.tv_sec = 5;
			else
				timeout.tv_sec = 60;
d452 6
d696 12
a718 4
			(void) releasesignal(SIGALRM);
			(void) releasesignal(SIGCHLD);
			(void) setsignal(SIGCHLD, SIG_DFL);
			(void) setsignal(SIGHUP, intsig);
d1746 1
a1746 1
			clt_addr.sa.sa_family = InetMode;
d2035 3
a2037 2
			dprintf("makeconnection (%s [%s])\n",
				host, anynet_ntoa(&addr));
d2050 1
a2050 1
			s = socket(addr.sa.sa_family, SOCK_STREAM, 0);
d2156 2
a2157 1
				ev = setevent(TimeOuts.to_iconnect, connecttimeout, 0);
d2159 2
a2160 1
				ev = setevent(TimeOuts.to_connect, connecttimeout, 0);
d2346 6
d2452 118
d2732 7
@


1.6.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d19 1
a19 1
static char id[] = "@@(#)$Sendmail: daemon.c,v 8.401.4.61 2001/05/27 22:14:40 gshapiro Exp $ (with daemon mode)";
d21 1
a21 1
static char id[] = "@@(#)$Sendmail: daemon.c,v 8.401.4.61 2001/05/27 22:14:40 gshapiro Exp $ (without daemon mode)";
a89 2
static SIGFUNC_DECL	sighup __P((int));
static void	restart_daemon __P((void));
a196 4
	(void) setsignal(SIGHUP, sighup);

	/* workaround: can't seem to release the signal in the parent */
	(void) releasesignal(SIGHUP);
a237 5
		if (ShutdownRequest != NULL)
			shutdown_daemon();
		else if (RestartRequest != NULL)
			restart_daemon();

a300 6
		/* May have been sleeping above, check again */
		if (ShutdownRequest != NULL)
			shutdown_daemon();
		else if (RestartRequest != NULL)
			restart_daemon();

a393 5
			if (ShutdownRequest != NULL)
				shutdown_daemon();
			else if (RestartRequest != NULL)
				restart_daemon();

d424 13
a436 1
			timeout.tv_sec = 5;
a441 6
			/* Did someone signal while waiting? */
			if (ShutdownRequest != NULL)
				shutdown_daemon();
			else if (RestartRequest != NULL)
				restart_daemon();

a679 12
			/* Reset global flags */
			RestartRequest = NULL;
			ShutdownRequest = NULL;
			PendingSignal = 0;

			(void) releasesignal(SIGALRM);
			(void) releasesignal(SIGCHLD);
			(void) setsignal(SIGCHLD, SIG_DFL);
			(void) setsignal(SIGHUP, SIG_DFL);
			(void) setsignal(SIGTERM, intsig);


d691 4
d1722 1
a1722 1
			clt_addr.sa.sa_family = family;
d2011 2
a2012 3
			dprintf("makeconnection (%s [%s].%d (%d))\n",
				host, anynet_ntoa(&addr), ntohs(port),
				addr.sa.sa_family);
d2025 1
a2025 1
			s = socket(clt_addr.sa.sa_family, SOCK_STREAM, 0);
d2131 1
a2131 2
				ev = setevent(TimeOuts.to_iconnect,
					      connecttimeout, 0);
d2133 1
a2133 2
				ev = setevent(TimeOuts.to_connect,
					      connecttimeout, 0);
a2318 6
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

a2418 118
**  SIGHUP -- handle a SIGHUP signal
**
**	Parameters:
**		sig -- incoming signal.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets RestartRequest which should cause the daemon
**		to restart.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

/* ARGSUSED */
static SIGFUNC_DECL
sighup(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, sighup);
	RestartRequest = "signal";
	errno = save_errno;
	return SIGFUNC_RETURN;
}
/*
**  RESTART_DAEMON -- Performs a clean restart of the daemon
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		restarts the daemon or exits if restart fails.
*/

static void
restart_daemon()
{
	int i;
	int save_errno;
	char *reason;
	sigfunc_t oalrm, ochld, ohup, oint, opipe, oterm, ousr1;
	extern int DtableSize;

	allsignals(TRUE);

	reason = RestartRequest;
	RestartRequest = NULL;
	PendingSignal = 0;

	if (SaveArgv[0][0] != '/')
	{
		if (LogLevel > 3)
			sm_syslog(LOG_INFO, NOQID,
				  "could not restart: need full path");
		finis(FALSE, EX_OSFILE);
	}
	if (LogLevel > 3)
		sm_syslog(LOG_INFO, NOQID, "restarting %s due to %s",
			  SaveArgv[0],
			  reason == NULL ? "implicit call" : reason);

	closecontrolsocket(TRUE);
	if (drop_privileges(TRUE) != EX_OK)
	{
		if (LogLevel > 0)
			sm_syslog(LOG_ALERT, NOQID,
				  "could not set[ug]id(%d, %d): %m",
				  RunAsUid, RunAsGid);
		finis(FALSE, EX_OSERR);
	}

	/* arrange for all the files to be closed */
	for (i = 3; i < DtableSize; i++)
	{
		register int j;

		if ((j = fcntl(i, F_GETFD, 0)) != -1)
			(void) fcntl(i, F_SETFD, j | FD_CLOEXEC);
	}

	/* need to allow signals before execve() so make them harmless */
	oalrm = setsignal(SIGALRM, SIG_DFL);
	ochld = setsignal(SIGCHLD, SIG_DFL);
	ohup = setsignal(SIGHUP, SIG_DFL);
	oint = setsignal(SIGINT, SIG_DFL);
	opipe = setsignal(SIGPIPE, SIG_DFL);
	oterm = setsignal(SIGTERM, SIG_DFL);
	ousr1 = setsignal(SIGUSR1, SIG_DFL);
	allsignals(FALSE);

	(void) execve(SaveArgv[0], (ARGV_T) SaveArgv, (ARGV_T) ExternalEnviron);
	save_errno = errno;

	/* restore signals */
	allsignals(TRUE);
	(void) setsignal(SIGALRM, oalrm);
	(void) setsignal(SIGCHLD, ochld);
	(void) setsignal(SIGHUP, ohup);
	(void) setsignal(SIGINT, oint);
	(void) setsignal(SIGPIPE, opipe);
	(void) setsignal(SIGTERM, oterm);
	(void) setsignal(SIGUSR1, ousr1);

	errno = save_errno;
	if (LogLevel > 0)
		sm_syslog(LOG_ALERT, NOQID, "could not exec %s: %m",
			  SaveArgv[0]);
	finis(FALSE, EX_OSFILE);
}
/*
a2580 7
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
@


1.5
log
@pull 8.12.x change (or equivalent to),
which can mark certain DaemonPortOptions as "optional".
now we can ship single sendmail.cf for both IPv4-only and IPv4/v6 kernels.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d19 1
a19 1
static char id[] = "@@(#)$Sendmail: daemon.c,v 8.401.4.41 2000/12/28 23:46:43 gshapiro Exp $ (with daemon mode)";
d21 1
a21 1
static char id[] = "@@(#)$Sendmail: daemon.c,v 8.401.4.41 2000/12/28 23:46:43 gshapiro Exp $ (without daemon mode)";
d466 2
d471 18
d502 1
d506 20
a525 1
				control = TRUE;
d1667 2
a1668 1
	    (p = macvalue(macid("{if_addr}", NULL), e)) != NULL)
d1682 3
a1684 2
			if ((clt_addr.sin.sin_addr.s_addr = inet_addr(p))
			    != INADDR_NONE)
a1688 6
			else if (clt_addr.sin.sin_port != 0)
			{
				clt_addr.sin.sin_addr.s_addr = INADDR_ANY;
				clt_bind = TRUE;
				socksize = sizeof (struct sockaddr_in);
			}
d1699 2
a1700 6
				      &clt_addr.sin6.sin6_addr) == 1)
			{
				clt_bind = TRUE;
				socksize = sizeof (struct sockaddr_in6);
			}
			else if (clt_addr.sin6.sin6_port != 0)
a1701 2
				if (IN6_IS_ADDR_UNSPECIFIED(&clt_addr.sin6.sin6_addr))
					clt_addr.sin6.sin6_addr = in6addr_any;
d1764 1
a1764 1
	h_errno = 0;
d2439 1
a2439 2
	if (gethostname(hostbuf, size) < 0)
	{
a2440 1
	}
d3086 1
a3086 1
		h_errno = s->s_namecanon.nc_herrno;
d3262 2
@


1.4
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d273 2
d885 8
@


1.3
log
@enable IPv6 support in sendmail.  by default, listens AF_INET only
(need DaemonPortOptions line to listen to AF_INET6 socket)

default address family handling is from 8.11.0beta3.
@
text
@d16 1
d19 1
a19 1
static char id[] = "@@(#)$Sendmail: daemon.c,v 8.401 2000/03/11 20:52:46 gshapiro Exp $ (with daemon mode)";
d21 1
a21 1
static char id[] = "@@(#)$Sendmail: daemon.c,v 8.401 2000/03/11 20:52:46 gshapiro Exp $ (without daemon mode)";
d42 4
a164 1
#define D(x,idx)	x[idx]
d172 1
d180 1
d184 1
d229 5
d238 31
d271 1
a271 1
			if (curtime() < Daemons[idx].d_refuse_connections_until)
d277 3
a279 3
				       /* close socket so peer fails quickly */
				       (void) close(Daemons[idx].d_socket);
				       Daemons[idx].d_socket = -1;
d283 1
a283 1
				Daemons[idx].d_refuse_connections_until = curtime() + 15;
d288 4
a291 4
			      if (!Daemons[idx].d_firsttime && LogLevel >= 9)
				sm_syslog(LOG_INFO, NOQID,
					  "accepting connections again for daemon %s",
					  Daemons[idx].d_name);
d293 3
a295 3
			      /* arrange to (re)open the socket if needed */
			      (void) opendaemonsocket(&Daemons[idx], FALSE);
			      Daemons[idx].d_firsttime = FALSE;
d298 2
a299 1
		if (curtime() >= last_disk_space_check)
d301 2
d305 1
a305 1
				if (!bitnset(D_ETRNONLY, Daemons[idx].d_flags))
d307 16
a322 9
					/* log only if not logged before */
					if (LogLevel >= 9)
						sm_syslog(LOG_INFO, NOQID,
							  "rejecting new messages: min free: %d",
							  MinBlocksFree);
					sm_setproctitle(TRUE, e,
							"rejecting new messages: min free: %d",
							 MinBlocksFree);
					setbitn(D_ETRNONLY, Daemons[idx].d_flags);
d325 1
a325 1
			else if (bitnset(D_ETRNONLY, Daemons[idx].d_flags))
d327 17
a343 6
				/* log only if not logged before */
				if (LogLevel >= 9)
					sm_syslog(LOG_INFO, NOQID,
						  "accepting new messages (again)");
				/* title will be set below */
				clrbitn(D_ETRNONLY, Daemons[idx].d_flags);
d346 1
a346 1
			last_disk_space_check = curtime() + 60;
d387 1
d399 3
a401 1
					if (!bitnset(D_ETRNONLY, Daemons[idx].d_flags))
d405 1
d409 1
a409 1
					FD_SET(Daemons[idx].d_socket, &readfds);
d427 1
d440 2
d444 2
a453 1
			curdaemon = -1;
d475 1
a475 1
				 FD_ISSET(ControlSocket, &readfds))
d485 6
d501 1
d511 9
d588 7
d596 1
d598 1
d623 3
d665 1
a665 1
					      PROC_CONTROL_CHILD);
d682 1
d704 1
d710 1
d804 1
a804 2
			snprintf(status, sizeof status,
				 "control socket server child");
d818 1
d820 2
d828 1
d830 2
d833 1
d1121 1
a1121 1
	short port;
d1125 2
d1185 1
a1185 64
			switch (d->d_addr.sa.sa_family)
			{
# if NETINET
			  case AF_INET:
				if (!isascii(*v) || !isdigit(*v) ||
				    ((d->d_addr.sin.sin_addr.s_addr = inet_addr(v)) == INADDR_NONE))
				{
					register struct hostent *hp;

					hp = sm_gethostbyname(v, AF_INET);
					if (hp == NULL)
						syserr("554 5.3.0 host \"%s\" unknown",
						       v);
					else
					{
						while (*(hp->h_addr_list) &&
						       hp->h_addrtype != AF_INET)
							hp->h_addr_list++;
						if (*(hp->h_addr_list) == NULL)
							syserr("554 5.3.0 host \"%s\" unknown",
							       v);
						else
							memmove(&d->d_addr.sin.sin_addr,
								*(hp->h_addr_list),
								INADDRSZ);
					}
				}
				break;
# endif /* NETINET */

# if NETINET6
			  case AF_INET6:
				if (!isascii(*v) || !isxdigit(*v) ||
				    inet_pton(AF_INET6, v,
					      &d->d_addr.sin6.sin6_addr) != 1)
				{
					register struct hostent *hp;

					hp = sm_gethostbyname(v, AF_INET6);
					if (hp == NULL)
						syserr("554 5.3.0 host \"%s\" unknown",
						       v);
					else
					{
						while (*(hp->h_addr_list) &&
						       hp->h_addrtype != AF_INET6)
							hp->h_addr_list++;
						if (*(hp->h_addr_list) == NULL)
							syserr("554 5.3.0 host \"%s\" unknown",
							       v);
						else
							memmove(&d->d_addr.sin6.sin6_addr,
								*(hp->h_addr_list),
								IN6ADDRSZ);
					}
				}
				break;
# endif /* NETINET6 */

			  default:
				syserr("554 5.3.5 address= option unsupported for family %d",
				       d->d_addr.sa.sa_family);
				break;
			}
d1189 1
a1189 79
			switch (d->d_addr.sa.sa_family)
			{
# if NETINET
			  case AF_INET:
				if (isascii(*v) && isdigit(*v))
					d->d_addr.sin.sin_port = htons(atoi(v));
				else
				{
#  ifdef NO_GETSERVBYNAME
					syserr("554 5.3.5 invalid port number: %s",
					       v);
#  else /* NO_GETSERVBYNAME */
					register struct servent *sp;

					sp = getservbyname(v, "tcp");
					if (sp == NULL)
						syserr("554 5.3.5 service \"%s\" unknown",
						       v);
					else
						d->d_addr.sin.sin_port = sp->s_port;
#  endif /* NO_GETSERVBYNAME */
				}
				break;
# endif /* NETINET */

# if NETINET6
			  case AF_INET6:
				if (isascii(*v) && isdigit(*v))
					d->d_addr.sin6.sin6_port = htons(atoi(v));
				else
				{
#  ifdef NO_GETSERVBYNAME
					syserr("554 5.3.5 invalid port number: %s",
					       v);
#  else /* NO_GETSERVBYNAME */
					register struct servent *sp;

					sp = getservbyname(v, "tcp");
					if (sp == NULL)
						syserr("554 5.3.5 service \"%s\" unknown",
						       v);
					else
						d->d_addr.sin6.sin6_port = sp->s_port;
#  endif /* NO_GETSERVBYNAME */
				}
				break;
# endif /* NETINET6 */

# if NETISO
			  case AF_ISO:
				/* assume two byte transport selector */
				if (isascii(*v) && isdigit(*v))
					port = htons(atoi(v));
				else
				{
#  ifdef NO_GETSERVBYNAME
					syserr("554 5.3.5 invalid port number: %s",
					       v);
#  else /* NO_GETSERVBYNAME */
					register struct servent *sp;

					sp = getservbyname(v, "tcp");
					if (sp == NULL)
						syserr("554 5.3.5 service \"%s\" unknown",
						       v);
					else
						port = sp->s_port;
#  endif /* NO_GETSERVBYNAME */
				}
				memmove(TSEL(&d->d_addr.siso),
					(char *) &port, 2);
				break;
# endif /* NETISO */

			  default:
				syserr("554 5.3.5 Port= option unsupported for family %d",
				       d->d_addr.sa.sa_family);
				break;
			}
d1206 1
a1206 1
						*f++ = ' ';
d1215 1
a1215 1
					setbitn(*v, d->d_flags);
d1235 161
d1496 41
d1592 1
a1592 1
				setbitn(*p, d_flags);
d1604 1
a1604 1
				setbitn(*p, d_flags);
a1618 1
		char *f;
d1625 2
a1626 5
		/* XXX set all necessary values... */
		if ((f = macvalue(macid("{if_family}", NULL), e)) != NULL)
			clt_addr.sa.sa_family = atoi(f);
		else
			clt_addr.sa.sa_family = family;
d1675 2
d1944 4
d1958 5
d1964 1
d1995 4
d2072 4
d2174 1
d2184 7
d2207 4
d2215 8
d2244 1
d2248 4
d2270 1
d2551 1
d2584 1
a2584 1
			RealUserName);
d2622 4
d2644 1
d2676 1
d2714 1
d2824 18
d2971 19
d3110 3
d3114 1
d3135 4
d3153 2
d3325 3
d3580 19
a3598 1
		return denlstring((char *) hp->h_name, TRUE, TRUE);
d3600 9
@


1.3.2.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
a15 1

d18 1
a18 1
static char id[] = "@@(#)$Sendmail: daemon.c,v 8.401.4.61 2001/05/27 22:14:40 gshapiro Exp $ (with daemon mode)";
d20 1
a20 1
static char id[] = "@@(#)$Sendmail: daemon.c,v 8.401.4.61 2001/05/27 22:14:40 gshapiro Exp $ (without daemon mode)";
a40 4
# if STARTTLS
#    include <openssl/rand.h>
# endif /* STARTTLS */

a84 2
static SIGFUNC_DECL	sighup __P((int));
static void	restart_daemon __P((void));
d160 1
a167 1

a174 1
		{
a177 1
		}
a189 4
	(void) setsignal(SIGHUP, sighup);

	/* workaround: can't seem to release the signal in the parent */
	(void) releasesignal(SIGHUP);
a221 5
		time_t timenow;
# if STARTTLS
		long seed;
# endif /* STARTTLS */
		extern bool refuseconnections __P((char *, ENVELOPE *, int));
a225 36
		if (ShutdownRequest != NULL)
			shutdown_daemon();
		else if (RestartRequest != NULL)
			restart_daemon();

		timenow = curtime();

		/*
		**  Use ConnRateThrottle only if the
		**  last pass was for a connection
		*/

		if (ConnRateThrottle > 0 && curdaemon >= 0)
		{
			static int conncnt = 0;
			static time_t lastconn = 0;

			if (timenow != lastconn)
			{
				lastconn = timenow;
				conncnt = 1;
			}
			else if (++conncnt > ConnRateThrottle)
			{
				/* sleep to flatten out connection load */
				sm_setproctitle(TRUE, e,
						"deferring connections: %d per second",
						ConnRateThrottle);
				if (LogLevel >= 9)
					sm_syslog(LOG_INFO, NOQID,
						  "deferring connections: %d per second",
						  ConnRateThrottle);
				(void) sleep(1);
			}
		}

d228 1
a228 3
			if (timenow < Daemons[idx].d_refuse_connections_until)
				continue;
			if (bitnset(D_DISABLE, Daemons[idx].d_flags))
d234 3
a236 3
					/* close socket so peer fails quickly */
					(void) close(Daemons[idx].d_socket);
					Daemons[idx].d_socket = -1;
d240 1
a240 1
				Daemons[idx].d_refuse_connections_until = timenow + 15;
d245 4
a248 4
				if (!Daemons[idx].d_firsttime && LogLevel >= 9)
					sm_syslog(LOG_INFO, NOQID,
						"accepting connections again for daemon %s",
						Daemons[idx].d_name);
d250 3
a252 3
				/* arrange to (re)open the socket if needed */
				(void) opendaemonsocket(&Daemons[idx], FALSE);
				Daemons[idx].d_firsttime = FALSE;
d255 1
a255 8

		/* May have been sleeping above, check again */
		if (ShutdownRequest != NULL)
			shutdown_daemon();
		else if (RestartRequest != NULL)
			restart_daemon();

		if (timenow >= last_disk_space_check)
a256 2
			bool logged = FALSE;

d259 1
a259 1
				for (idx = 0; idx < ndaemons; idx++)
d261 9
a269 16
					if (!bitnset(D_ETRNONLY, Daemons[idx].d_flags))
					{
						/* log only if not logged before */
						if (!logged)
						{
							if (LogLevel >= 9)
								sm_syslog(LOG_INFO, NOQID,
									  "rejecting new messages: min free: %ld",
									  MinBlocksFree);
							logged = TRUE;
							sm_setproctitle(TRUE, e,
									"rejecting new messages: min free: %ld",
									MinBlocksFree);
						}
						setbitn(D_ETRNONLY, Daemons[idx].d_flags);
					}
d272 1
a272 1
			else
d274 6
a279 17
				for (idx = 0; idx < ndaemons; idx++)
				{
					if (bitnset(D_ETRNONLY, Daemons[idx].d_flags))
					{
						/* log only if not logged before */
						if (!logged)
						{
							if (LogLevel >= 9)
								sm_syslog(LOG_INFO, NOQID,
									  "accepting new messages (again)");
							logged = TRUE;
						}

						/* title will be set below */
						clrbitn(D_ETRNONLY, Daemons[idx].d_flags);
					}
				}
d282 1
a282 1
			last_disk_space_check = timenow + 60;
a322 1
			bool setproc = FALSE;
a326 5
			if (ShutdownRequest != NULL)
				shutdown_daemon();
			else if (RestartRequest != NULL)
				restart_daemon();

d334 1
a334 3
					if (!setproc &&
					    !bitnset(D_ETRNONLY,
						     Daemons[idx].d_flags))
a337 1
						setproc = TRUE;
d341 1
a341 1
					FD_SET((u_int)Daemons[idx].d_socket, &readfds);
d354 12
a365 1
			timeout.tv_sec = 5;
a370 8
			/* Did someone signal while waiting? */
			if (ShutdownRequest != NULL)
				shutdown_daemon();
			else if (RestartRequest != NULL)
				restart_daemon();



a372 2

			curdaemon = -1;
d381 1
a391 2
					memset(&RealHostAddr, '\0',
					       sizeof RealHostAddr);
a394 18

					/*
					**  If remote side closes before
					**  accept() finishes, sockaddr
					**  might not be fully filled in.
					*/

					if (t >= 0 &&
					    (lotherend == 0 ||
# ifdef BSD4_4_SOCKADDR
					     RealHostAddr.sa.sa_len == 0 ||
# endif /* BSD4_4_SOCKADDR */
					     RealHostAddr.sa.sa_family != Daemons[idx].d_addr.sa.sa_family))
					{
						(void) close(t);
						t = -1;
						errno = EINVAL;
					}
d403 1
a403 1
			    FD_ISSET(ControlSocket, &readfds))
a407 1
				memset(&sa_un, '\0', sizeof sa_un);
d411 1
a411 26

				/*
				**  If remote side closes before
				**  accept() finishes, sockaddr
				**  might not be fully filled in.
				*/

				if (t >= 0 &&
				    (lotherend == 0 ||
# ifdef BSD4_4_SOCKADDR
				     sa_un.sun_len == 0 ||
# endif /* BSD4_4_SOCKADDR */
				     sa_un.sun_family != AF_UNIX))
				{
					(void) close(t);
					t = -1;
					errno = EINVAL;
				}
				if (t >= 0)
					control = TRUE;
			}
# else /* NETUNIX */
			if (curdaemon == -1)
			{
				/* No daemon to service */
				continue;
a422 1
		timenow = curtime();
a431 9
# if SO_REUSEADDR_IS_BROKEN
			/*
			**  Give time for bound socket to be released.
			**  This creates a denial-of-service if you can
			**  force accept() to fail on affected systems.
			*/

			Daemons[curdaemon].d_refuse_connections_until = timenow + 15;
# endif /* SO_REUSEADDR_IS_BROKEN */
a499 7
# if STARTTLS
		seed = get_random();
		RAND_seed((void *) &last_disk_space_check,
			sizeof last_disk_space_check);
		RAND_seed((void *) &timenow, sizeof timenow);
		RAND_seed((void *) &seed, sizeof seed);
# else /* STARTTLS */
a500 1
# endif /* STARTTLS */
a501 1
#ifndef DEBUG_NO_FORK
a525 3
#else /* ! DEBUG_NO_FORK */
		pid = 0;
#endif /* ! DEBUG_NO_FORK */
a537 12
			/* Reset global flags */
			RestartRequest = NULL;
			ShutdownRequest = NULL;
			PendingSignal = 0;

			(void) releasesignal(SIGALRM);
			(void) releasesignal(SIGCHLD);
			(void) setsignal(SIGCHLD, SIG_DFL);
			(void) setsignal(SIGHUP, SIG_DFL);
			(void) setsignal(SIGTERM, intsig);


d549 4
d565 1
a565 1
					PROC_CONTROL_CHILD);
a581 1
#ifndef DEBUG_NO_FORK
a602 1
#endif /* ! DEBUG_NO_FORK */
a607 1

d701 2
a702 1
			snprintf(status, sizeof status, "control socket server child");
a715 1
		{
a716 2
			pipefd[0] = -1;
		}
a722 1
		{
a723 2
			pipefd[1] = -1;
		}
a724 1

a773 8
				if (bitnset(D_OPTIONAL, d->d_flags) &&
				    (save_errno == EAFNOSUPPORT ||
				     save_errno == EPROTONOSUPPORT))
				{
					syserr("opendaemonsocket: daemon %s: optional socket disabled", d->d_name);
					setbitn(D_DISABLE, d->d_flags);
					return -1;
				}
d1012 1
a1012 1
	short portno;
a1015 2
	char *port = NULL;
	char *addr = NULL;
d1074 64
a1137 1
			addr = v;
d1141 79
a1219 1
			port = v;
d1236 1
a1236 1
						*flags++ = ' ';
d1245 1
a1245 1
					setbitn(bitidx(*v), d->d_flags);
a1264 161

	/* Check addr and port after finding family */
	if (addr != NULL)
	{
		switch (d->d_addr.sa.sa_family)
		{
# if NETINET
		  case AF_INET:
			if (!isascii(*addr) || !isdigit(*addr) ||
			    ((d->d_addr.sin.sin_addr.s_addr = inet_addr(addr)) == INADDR_NONE))
			{
				register struct hostent *hp;

				hp = sm_gethostbyname(addr, AF_INET);
				if (hp == NULL)
					syserr("554 5.3.0 host \"%s\" unknown",
					       addr);
				else
				{
					while (*(hp->h_addr_list) != NULL &&
					       hp->h_addrtype != AF_INET)
						hp->h_addr_list++;
					if (*(hp->h_addr_list) == NULL)
						syserr("554 5.3.0 host \"%s\" unknown",
						       addr);
					else
						memmove(&d->d_addr.sin.sin_addr,
							*(hp->h_addr_list),
							INADDRSZ);
#  if _FFR_FREEHOSTENT && NETINET6
					freehostent(hp);
					hp = NULL;
#  endif /* _FFR_FREEHOSTENT && NETINET6 */
				}
			}
			break;
# endif /* NETINET */

# if NETINET6
		  case AF_INET6:
			if (!isascii(*addr) ||
			    (!isxdigit(*addr) && *addr != ':') ||
			    inet_pton(AF_INET6, addr,
				      &d->d_addr.sin6.sin6_addr) != 1)
			{
				register struct hostent *hp;

				hp = sm_gethostbyname(addr, AF_INET6);
				if (hp == NULL)
					syserr("554 5.3.0 host \"%s\" unknown",
					       addr);
				else
				{
					while (*(hp->h_addr_list) != NULL &&
					       hp->h_addrtype != AF_INET6)
						hp->h_addr_list++;
					if (*(hp->h_addr_list) == NULL)
						syserr("554 5.3.0 host \"%s\" unknown",
						       addr);
					else
						memmove(&d->d_addr.sin6.sin6_addr,
							*(hp->h_addr_list),
							IN6ADDRSZ);
#  if _FFR_FREEHOSTENT
					freehostent(hp);
					hp = NULL;
#  endif /* _FFR_FREEHOSTENT */
				}
			}
			break;
# endif /* NETINET6 */

		  default:
			syserr("554 5.3.5 address= option unsupported for family %d",
			       d->d_addr.sa.sa_family);
			break;
		}
	}

	if (port != NULL)
	{
		switch (d->d_addr.sa.sa_family)
		{
# if NETINET
		  case AF_INET:
			if (isascii(*port) && isdigit(*port))
				d->d_addr.sin.sin_port = htons((u_short)atoi((const char *)port));
			else
			{
#  ifdef NO_GETSERVBYNAME
				syserr("554 5.3.5 invalid port number: %s",
				       port);
#  else /* NO_GETSERVBYNAME */
				register struct servent *sp;

				sp = getservbyname(port, "tcp");
				if (sp == NULL)
					syserr("554 5.3.5 service \"%s\" unknown",
					       port);
				else
					d->d_addr.sin.sin_port = sp->s_port;
#  endif /* NO_GETSERVBYNAME */
			}
			break;
# endif /* NETINET */

# if NETINET6
		  case AF_INET6:
			if (isascii(*port) && isdigit(*port))
				d->d_addr.sin6.sin6_port = htons((u_short)atoi(port));
			else
			{
#  ifdef NO_GETSERVBYNAME
				syserr("554 5.3.5 invalid port number: %s",
				       port);
#  else /* NO_GETSERVBYNAME */
				register struct servent *sp;

				sp = getservbyname(port, "tcp");
				if (sp == NULL)
					syserr("554 5.3.5 service \"%s\" unknown",
					       port);
				else
					d->d_addr.sin6.sin6_port = sp->s_port;
#  endif /* NO_GETSERVBYNAME */
			}
			break;
# endif /* NETINET6 */

# if NETISO
		  case AF_ISO:
			/* assume two byte transport selector */
			if (isascii(*port) && isdigit(*port))
				portno = htons((u_short)atoi(port));
			else
			{
#  ifdef NO_GETSERVBYNAME
				syserr("554 5.3.5 invalid port number: %s",
				       port);
#  else /* NO_GETSERVBYNAME */
				register struct servent *sp;

				sp = getservbyname(port, "tcp");
				if (sp == NULL)
					syserr("554 5.3.5 service \"%s\" unknown",
					       port);
				else
					portno = sp->s_port;
#  endif /* NO_GETSERVBYNAME */
			}
			memmove(TSEL(&d->d_addr.siso),
				(char *) &portno, 2);
			break;
# endif /* NETISO */

		  default:
			syserr("554 5.3.5 Port= option unsupported for family %d",
			       d->d_addr.sa.sa_family);
			break;
		}
	}
a1364 41
**  ADDR_FAMILY -- determine address family from address
**
**	Parameters:
**		addr -- the string representation of the address
**
**	Returns:
**		AF_INET, AF_INET6 or AF_UNSPEC
**
**	Side Effects:
**		none.
*/

static int
addr_family(addr)
	char *addr;
{
# if NETINET6
	SOCKADDR clt_addr;
# endif /* NETINET6 */

# if NETINET
	if (inet_addr(addr) != INADDR_NONE)
	{
		if (tTd(16, 9))
			printf("addr_family(%s): INET\n", addr);
		return AF_INET;
	}
# endif /* NETINET */
# if NETINET6
	if (inet_pton(AF_INET6, addr, &clt_addr.sin6.sin6_addr) == 1)
	{
		if (tTd(16, 9))
			printf("addr_family(%s): INET6\n", addr);
		return AF_INET6;
	}
# endif /* NETINET6 */
	if (tTd(16, 9))
		printf("addr_family(%s): UNSPEC\n", addr);
	return AF_UNSPEC;
}
/*
d1420 1
a1420 1
				setbitn(bitidx(*p), d_flags);
d1432 1
a1432 1
				setbitn(bitidx(*p), d_flags);
d1445 1
a1445 2
	    (p = macvalue(macid("{if_addr}", NULL), e)) != NULL &&
	    *p != '\0')
d1447 1
d1454 5
a1458 2
		/* infer the address family from the address itself */
		clt_addr.sa.sa_family = addr_family(p);
d1463 2
a1464 3
			clt_addr.sin.sin_addr.s_addr = inet_addr(p);
			if (clt_addr.sin.sin_addr.s_addr != INADDR_NONE &&
			    clt_addr.sin.sin_addr.s_addr != INADDR_LOOPBACK)
d1469 6
d1485 6
a1490 2
				      &clt_addr.sin6.sin6_addr) == 1 &&
			    !IN6_IS_ADDR_LOOPBACK(&clt_addr.sin6.sin6_addr))
d1492 2
a1506 2
		if (clt_bind)
			family = clt_addr.sa.sa_family;
d1512 1
a1512 1
			clt_addr.sa.sa_family = family;
d1554 1
a1554 1
	SM_SET_H_ERRNO(0);
a1773 4
# if _FFR_FREEHOSTENT && NETINET6
		if (hp != NULL)
			freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a1783 5
	{
#  if _FFR_FREEHOSTENT && NETINET6
		if (hp != NULL)
			freehostent(hp);
#  endif /* _FFR_FREEHOSTENT && NETINET6 */
a1784 1
	}
d1791 2
a1792 3
			dprintf("makeconnection (%s [%s].%d (%d))\n",
				host, anynet_ntoa(&addr), ntohs(port),
				addr.sa.sa_family);
d1805 1
a1805 1
			s = socket(clt_addr.sa.sa_family, SOCK_STREAM, 0);
a1814 4
# if _FFR_FREEHOSTENT && NETINET6
			if (hp != NULL)
				freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a1887 4
# if _FFR_FREEHOSTENT && NETINET6
				if (hp != NULL)
					freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d1903 1
a1903 2
				ev = setevent(TimeOuts.to_iconnect,
					      connecttimeout, 0);
d1905 1
a1905 2
				ev = setevent(TimeOuts.to_connect,
					      connecttimeout, 0);
a1985 1
		errno = save_errno;
a1994 7
#  if _FFR_FREEHOSTENT
			if (hp != NULL)
			{
				freehostent(hp);
				hp = NULL;
			}
#  endif /* _FFR_FREEHOSTENT */
a2010 4
# if _FFR_FREEHOSTENT && NETINET6
		if (hp != NULL)
			freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a2014 8
# if _FFR_FREEHOSTENT && NETINET6
	if (hp != NULL)
	{
		freehostent(hp);
		hp = NULL;
	}
# endif /* _FFR_FREEHOSTENT && NETINET6 */

a2035 1
		char *p;
a2038 4
		p = xalloc(5);
		snprintf(p, 4, "%d", addr.sa.sa_family);
		define(macid("{if_family}", NULL), p, &BlankEnvelope);

a2056 1
		define(macid("{if_family}", NULL), NULL, &BlankEnvelope);
a2064 6
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

a2164 118
**  SIGHUP -- handle a SIGHUP signal
**
**	Parameters:
**		sig -- incoming signal.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets RestartRequest which should cause the daemon
**		to restart.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

/* ARGSUSED */
static SIGFUNC_DECL
sighup(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, sighup);
	RestartRequest = "signal";
	errno = save_errno;
	return SIGFUNC_RETURN;
}
/*
**  RESTART_DAEMON -- Performs a clean restart of the daemon
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		restarts the daemon or exits if restart fails.
*/

static void
restart_daemon()
{
	int i;
	int save_errno;
	char *reason;
	sigfunc_t oalrm, ochld, ohup, oint, opipe, oterm, ousr1;
	extern int DtableSize;

	allsignals(TRUE);

	reason = RestartRequest;
	RestartRequest = NULL;
	PendingSignal = 0;

	if (SaveArgv[0][0] != '/')
	{
		if (LogLevel > 3)
			sm_syslog(LOG_INFO, NOQID,
				  "could not restart: need full path");
		finis(FALSE, EX_OSFILE);
	}
	if (LogLevel > 3)
		sm_syslog(LOG_INFO, NOQID, "restarting %s due to %s",
			  SaveArgv[0],
			  reason == NULL ? "implicit call" : reason);

	closecontrolsocket(TRUE);
	if (drop_privileges(TRUE) != EX_OK)
	{
		if (LogLevel > 0)
			sm_syslog(LOG_ALERT, NOQID,
				  "could not set[ug]id(%d, %d): %m",
				  RunAsUid, RunAsGid);
		finis(FALSE, EX_OSERR);
	}

	/* arrange for all the files to be closed */
	for (i = 3; i < DtableSize; i++)
	{
		register int j;

		if ((j = fcntl(i, F_GETFD, 0)) != -1)
			(void) fcntl(i, F_SETFD, j | FD_CLOEXEC);
	}

	/* need to allow signals before execve() so make them harmless */
	oalrm = setsignal(SIGALRM, SIG_DFL);
	ochld = setsignal(SIGCHLD, SIG_DFL);
	ohup = setsignal(SIGHUP, SIG_DFL);
	oint = setsignal(SIGINT, SIG_DFL);
	opipe = setsignal(SIGPIPE, SIG_DFL);
	oterm = setsignal(SIGTERM, SIG_DFL);
	ousr1 = setsignal(SIGUSR1, SIG_DFL);
	allsignals(FALSE);

	(void) execve(SaveArgv[0], (ARGV_T) SaveArgv, (ARGV_T) ExternalEnviron);
	save_errno = errno;

	/* restore signals */
	allsignals(TRUE);
	(void) setsignal(SIGALRM, oalrm);
	(void) setsignal(SIGCHLD, ochld);
	(void) setsignal(SIGHUP, ohup);
	(void) setsignal(SIGINT, oint);
	(void) setsignal(SIGPIPE, opipe);
	(void) setsignal(SIGTERM, oterm);
	(void) setsignal(SIGUSR1, ousr1);

	errno = save_errno;
	if (LogLevel > 0)
		sm_syslog(LOG_ALERT, NOQID, "could not exec %s: %m",
			  SaveArgv[0]);
	finis(FALSE, EX_OSFILE);
}
/*
d2185 2
a2186 1
	if (gethostname(hostbuf, size) < 0 || hostbuf[0] == '\0')
d2188 1
a2328 7
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
a2336 1
	volatile u_short port = 0;
d2369 1
a2369 1
				RealUserName);
a2406 4
# if _FFR_FREEHOSTENT && NETINET6
			freehostent(hp);
			hp = NULL;
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a2424 1
		port = RealHostAddr.sin.sin_port;
a2455 1
		port = RealHostAddr.sin6.sin6_port;
a2492 1

a2601 18
	/* put back the original incoming port */
	switch (RealHostAddr.sa.sa_family)
	{
# if NETINET
	  case AF_INET:
		if (port > 0)
			RealHostAddr.sin.sin_port = port;
		break;
# endif /* NETINET */

# if NETINET6
	  case AF_INET6:
		if (port > 0)
			RealHostAddr.sin6.sin6_port = port;
		break;
# endif /* NETINET6 */
	}

a2730 19

	/* put back the original incoming port */
	switch (RealHostAddr.sa.sa_family)
	{
# if NETINET
	  case AF_INET:
		if (port > 0)
			RealHostAddr.sin.sin_port = port;
		break;
# endif /* NETINET */

# if NETINET6
	  case AF_INET6:
		if (port > 0)
			RealHostAddr.sin6.sin6_port = port;
		break;
# endif /* NETINET6 */
	}

d2789 1
a2789 1
		SM_SET_H_ERRNO(s->s_namecanon.nc_herrno);
a2850 3
		{
			if (tTd(9, 1))
				dprintf("FAILED\n");
a2851 1
		}
a2871 4
# if _FFR_FREEHOSTENT && NETINET6
			freehostent(hp);
			hp = NULL;
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a2885 2
		if (tTd(9, 1))
			dprintf("FOUND %s\n", ans);
a2954 2
	if (hostbuf[0] == '\0')
		(void) strlcpy(hostbuf, "localhost", size);
a3055 3
# if _FFR_FREEHOSTENT && NETINET6
	freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d3308 1
a3308 19
	{
		char *name;

		name = denlstring((char *) hp->h_name, TRUE, TRUE);

#  if _FFR_FREEHOSTENT && NETINET6
		if (name == hp->h_name)
		{
			static char n[MAXNAME + 1];

			/* Copy the string, hp->h_name is about to disappear */
			strlcpy(n, name, sizeof n);
			name = n;
		}

		freehostent(hp);
#  endif /* _FFR_FREEHOSTENT && NETINET6 */
		return name;
	}
a3309 9

# if _FFR_FREEHOSTENT && NETINET6
	if (hp != NULL)
	{
		freehostent(hp);
		hp = NULL;
	}
# endif /* _FFR_FREEHOSTENT && NETINET6 */

@


1.2
log
@Update to sendmail-8.10.1
@
text
@d902 3
a904 1
		daemonaddr->sa.sa_family = InetMode;
d1017 1
d1019 2
a1020 1
		d->d_addr.sa.sa_family = InetMode;
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
static char id[] = "@@(#)$Sendmail: daemon.c,v 8.399 2000/03/01 18:14:06 gshapiro Exp $ (with daemon mode)";
d20 1
a20 1
static char id[] = "@@(#)$Sendmail: daemon.c,v 8.399 2000/03/01 18:14:06 gshapiro Exp $ (without daemon mode)";
d822 1
a822 1
				       strerror(save_errno));
d2353 11
a2363 2
		if (i < 0 && errno != ENOTSOCK)
			return NULL;
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@a15 1

d18 1
a18 1
static char id[] = "@@(#)$Id: daemon.c,v 8.401.4.41 2000/12/28 23:46:43 gshapiro Exp $ (with daemon mode)";
d20 1
a20 1
static char id[] = "@@(#)$Id: daemon.c,v 8.401.4.41 2000/12/28 23:46:43 gshapiro Exp $ (without daemon mode)";
a40 4
# if STARTTLS
#    include <openssl/rand.h>
# endif /* STARTTLS */

d160 1
a167 1

a174 1
		{
a177 1
		}
a221 5
		time_t timenow;
# if STARTTLS
		long seed;
# endif /* STARTTLS */
		extern bool refuseconnections __P((char *, ENVELOPE *, int));
a225 31
		timenow = curtime();

		/*
		**  Use ConnRateThrottle only if the
		**  last pass was for a connection
		*/

		if (ConnRateThrottle > 0 && curdaemon >= 0)
		{
			static int conncnt = 0;
			static time_t lastconn = 0;

			if (timenow != lastconn)
			{
				lastconn = timenow;
				conncnt = 1;
			}
			else if (++conncnt > ConnRateThrottle)
			{
				/* sleep to flatten out connection load */
				sm_setproctitle(TRUE, e,
						"deferring connections: %d per second",
						ConnRateThrottle);
				if (LogLevel >= 9)
					sm_syslog(LOG_INFO, NOQID,
						  "deferring connections: %d per second",
						  ConnRateThrottle);
				(void) sleep(1);
			}
		}

d228 1
a228 1
			if (timenow < Daemons[idx].d_refuse_connections_until)
d234 3
a236 3
					/* close socket so peer fails quickly */
					(void) close(Daemons[idx].d_socket);
					Daemons[idx].d_socket = -1;
d240 1
a240 1
				Daemons[idx].d_refuse_connections_until = timenow + 15;
d245 4
a248 4
				if (!Daemons[idx].d_firsttime && LogLevel >= 9)
					sm_syslog(LOG_INFO, NOQID,
						"accepting connections again for daemon %s",
						Daemons[idx].d_name);
d250 3
a252 3
				/* arrange to (re)open the socket if needed */
				(void) opendaemonsocket(&Daemons[idx], FALSE);
				Daemons[idx].d_firsttime = FALSE;
d255 1
a255 2

		if (timenow >= last_disk_space_check)
a256 2
			bool logged = FALSE;

d259 1
a259 1
				for (idx = 0; idx < ndaemons; idx++)
d261 9
a269 16
					if (!bitnset(D_ETRNONLY, Daemons[idx].d_flags))
					{
						/* log only if not logged before */
						if (!logged)
						{
							if (LogLevel >= 9)
								sm_syslog(LOG_INFO, NOQID,
									  "rejecting new messages: min free: %ld",
									  MinBlocksFree);
							logged = TRUE;
							sm_setproctitle(TRUE, e,
									"rejecting new messages: min free: %ld",
									MinBlocksFree);
						}
						setbitn(D_ETRNONLY, Daemons[idx].d_flags);
					}
d272 1
a272 1
			else
d274 6
a279 17
				for (idx = 0; idx < ndaemons; idx++)
				{
					if (bitnset(D_ETRNONLY, Daemons[idx].d_flags))
					{
						/* log only if not logged before */
						if (!logged)
						{
							if (LogLevel >= 9)
								sm_syslog(LOG_INFO, NOQID,
									  "accepting new messages (again)");
							logged = TRUE;
						}

						/* title will be set below */
						clrbitn(D_ETRNONLY, Daemons[idx].d_flags);
					}
				}
d282 1
a282 1
			last_disk_space_check = timenow + 60;
a322 1
			bool setproc = FALSE;
d334 1
a334 3
					if (!setproc &&
					    !bitnset(D_ETRNONLY,
						     Daemons[idx].d_flags))
a337 1
						setproc = TRUE;
d341 1
a341 1
					FD_SET((u_int)Daemons[idx].d_socket, &readfds);
a358 1

a370 2


a372 2

			curdaemon = -1;
d381 1
d403 1
a403 1
			    FD_ISSET(ControlSocket, &readfds))
a412 6
# else /* NETUNIX */
			if (curdaemon == -1)
			{
				/* No daemon to service */
				continue;
			}
a422 1
		timenow = curtime();
a431 9
# if SO_REUSEADDR_IS_BROKEN
			/*
			**  Give time for bound socket to be released.
			**  This creates a denial-of-service if you can
			**  force accept() to fail on affected systems.
			*/

			Daemons[curdaemon].d_refuse_connections_until = timenow + 15;
# endif /* SO_REUSEADDR_IS_BROKEN */
a499 7
# if STARTTLS
		seed = get_random();
		RAND_seed((void *) &last_disk_space_check,
			sizeof last_disk_space_check);
		RAND_seed((void *) &timenow, sizeof timenow);
		RAND_seed((void *) &seed, sizeof seed);
# else /* STARTTLS */
a500 1
# endif /* STARTTLS */
a501 1
#ifndef DEBUG_NO_FORK
a525 3
#else /* ! DEBUG_NO_FORK */
		pid = 0;
#endif /* ! DEBUG_NO_FORK */
d565 1
a565 1
					PROC_CONTROL_CHILD);
a581 1
#ifndef DEBUG_NO_FORK
a602 1
#endif /* ! DEBUG_NO_FORK */
a607 1

d701 2
a702 1
			snprintf(status, sizeof status, "control socket server child");
a715 1
		{
a716 2
			pipefd[0] = -1;
		}
a722 1
		{
a723 2
			pipefd[1] = -1;
		}
a724 1

d822 1
a822 1
				       errstring(save_errno));
d902 1
a902 3
# if NETINET
		daemonaddr->sa.sa_family = AF_INET;
# endif /* NETINET */
d1010 1
a1010 1
	short portno;
a1013 2
	char *port = NULL;
	char *addr = NULL;
a1014 1
# if NETINET
d1016 1
a1016 2
		d->d_addr.sa.sa_family = AF_INET;
# endif /* NETINET */
d1070 64
a1133 1
			addr = v;
d1137 79
a1215 1
			port = v;
d1232 1
a1232 1
						*flags++ = ' ';
d1241 1
a1241 1
					setbitn(bitidx(*v), d->d_flags);
a1260 161

	/* Check addr and port after finding family */
	if (addr != NULL)
	{
		switch (d->d_addr.sa.sa_family)
		{
# if NETINET
		  case AF_INET:
			if (!isascii(*addr) || !isdigit(*addr) ||
			    ((d->d_addr.sin.sin_addr.s_addr = inet_addr(addr)) == INADDR_NONE))
			{
				register struct hostent *hp;

				hp = sm_gethostbyname(addr, AF_INET);
				if (hp == NULL)
					syserr("554 5.3.0 host \"%s\" unknown",
					       addr);
				else
				{
					while (*(hp->h_addr_list) != NULL &&
					       hp->h_addrtype != AF_INET)
						hp->h_addr_list++;
					if (*(hp->h_addr_list) == NULL)
						syserr("554 5.3.0 host \"%s\" unknown",
						       addr);
					else
						memmove(&d->d_addr.sin.sin_addr,
							*(hp->h_addr_list),
							INADDRSZ);
#  if _FFR_FREEHOSTENT && NETINET6
					freehostent(hp);
					hp = NULL;
#  endif /* _FFR_FREEHOSTENT && NETINET6 */
				}
			}
			break;
# endif /* NETINET */

# if NETINET6
		  case AF_INET6:
			if (!isascii(*addr) ||
			    (!isxdigit(*addr) && *addr != ':') ||
			    inet_pton(AF_INET6, addr,
				      &d->d_addr.sin6.sin6_addr) != 1)
			{
				register struct hostent *hp;

				hp = sm_gethostbyname(addr, AF_INET6);
				if (hp == NULL)
					syserr("554 5.3.0 host \"%s\" unknown",
					       addr);
				else
				{
					while (*(hp->h_addr_list) != NULL &&
					       hp->h_addrtype != AF_INET6)
						hp->h_addr_list++;
					if (*(hp->h_addr_list) == NULL)
						syserr("554 5.3.0 host \"%s\" unknown",
						       addr);
					else
						memmove(&d->d_addr.sin6.sin6_addr,
							*(hp->h_addr_list),
							IN6ADDRSZ);
#  if _FFR_FREEHOSTENT
					freehostent(hp);
					hp = NULL;
#  endif /* _FFR_FREEHOSTENT */
				}
			}
			break;
# endif /* NETINET6 */

		  default:
			syserr("554 5.3.5 address= option unsupported for family %d",
			       d->d_addr.sa.sa_family);
			break;
		}
	}

	if (port != NULL)
	{
		switch (d->d_addr.sa.sa_family)
		{
# if NETINET
		  case AF_INET:
			if (isascii(*port) && isdigit(*port))
				d->d_addr.sin.sin_port = htons((u_short)atoi((const char *)port));
			else
			{
#  ifdef NO_GETSERVBYNAME
				syserr("554 5.3.5 invalid port number: %s",
				       port);
#  else /* NO_GETSERVBYNAME */
				register struct servent *sp;

				sp = getservbyname(port, "tcp");
				if (sp == NULL)
					syserr("554 5.3.5 service \"%s\" unknown",
					       port);
				else
					d->d_addr.sin.sin_port = sp->s_port;
#  endif /* NO_GETSERVBYNAME */
			}
			break;
# endif /* NETINET */

# if NETINET6
		  case AF_INET6:
			if (isascii(*port) && isdigit(*port))
				d->d_addr.sin6.sin6_port = htons((u_short)atoi(port));
			else
			{
#  ifdef NO_GETSERVBYNAME
				syserr("554 5.3.5 invalid port number: %s",
				       port);
#  else /* NO_GETSERVBYNAME */
				register struct servent *sp;

				sp = getservbyname(port, "tcp");
				if (sp == NULL)
					syserr("554 5.3.5 service \"%s\" unknown",
					       port);
				else
					d->d_addr.sin6.sin6_port = sp->s_port;
#  endif /* NO_GETSERVBYNAME */
			}
			break;
# endif /* NETINET6 */

# if NETISO
		  case AF_ISO:
			/* assume two byte transport selector */
			if (isascii(*port) && isdigit(*port))
				portno = htons((u_short)atoi(port));
			else
			{
#  ifdef NO_GETSERVBYNAME
				syserr("554 5.3.5 invalid port number: %s",
				       port);
#  else /* NO_GETSERVBYNAME */
				register struct servent *sp;

				sp = getservbyname(port, "tcp");
				if (sp == NULL)
					syserr("554 5.3.5 service \"%s\" unknown",
					       port);
				else
					portno = sp->s_port;
#  endif /* NO_GETSERVBYNAME */
			}
			memmove(TSEL(&d->d_addr.siso),
				(char *) &portno, 2);
			break;
# endif /* NETISO */

		  default:
			syserr("554 5.3.5 Port= option unsupported for family %d",
			       d->d_addr.sa.sa_family);
			break;
		}
	}
a1360 41
**  ADDR_FAMILY -- determine address family from address
**
**	Parameters:
**		addr -- the string representation of the address
**
**	Returns:
**		AF_INET, AF_INET6 or AF_UNSPEC
**
**	Side Effects:
**		none.
*/

static int
addr_family(addr)
	char *addr;
{
# if NETINET6
	SOCKADDR clt_addr;
# endif /* NETINET6 */

# if NETINET
	if (inet_addr(addr) != INADDR_NONE)
	{
		if (tTd(16, 9))
			printf("addr_family(%s): INET\n", addr);
		return AF_INET;
	}
# endif /* NETINET */
# if NETINET6
	if (inet_pton(AF_INET6, addr, &clt_addr.sin6.sin6_addr) == 1)
	{
		if (tTd(16, 9))
			printf("addr_family(%s): INET6\n", addr);
		return AF_INET6;
	}
# endif /* NETINET6 */
	if (tTd(16, 9))
		printf("addr_family(%s): UNSPEC\n", addr);
	return AF_UNSPEC;
}
/*
d1416 1
a1416 1
				setbitn(bitidx(*p), d_flags);
d1428 1
a1428 1
				setbitn(bitidx(*p), d_flags);
d1443 1
d1450 5
a1454 2
		/* infer the address family from the address itself */
		clt_addr.sa.sa_family = addr_family(p);
a1502 2
		if (clt_bind)
			family = clt_addr.sa.sa_family;
a1769 4
# if _FFR_FREEHOSTENT && NETINET6
		if (hp != NULL)
			freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a1779 5
	{
#  if _FFR_FREEHOSTENT && NETINET6
		if (hp != NULL)
			freehostent(hp);
#  endif /* _FFR_FREEHOSTENT && NETINET6 */
a1780 1
	}
a1810 4
# if _FFR_FREEHOSTENT && NETINET6
			if (hp != NULL)
				freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a1883 4
# if _FFR_FREEHOSTENT && NETINET6
				if (hp != NULL)
					freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a1981 1
		errno = save_errno;
a1990 7
#  if _FFR_FREEHOSTENT
			if (hp != NULL)
			{
				freehostent(hp);
				hp = NULL;
			}
#  endif /* _FFR_FREEHOSTENT */
a2006 4
# if _FFR_FREEHOSTENT && NETINET6
		if (hp != NULL)
			freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a2010 8
# if _FFR_FREEHOSTENT && NETINET6
	if (hp != NULL)
	{
		freehostent(hp);
		hp = NULL;
	}
# endif /* _FFR_FREEHOSTENT && NETINET6 */

a2031 1
		char *p;
a2034 4
		p = xalloc(5);
		snprintf(p, 4, "%d", addr.sa.sa_family);
		define(macid("{if_family}", NULL), p, &BlankEnvelope);

a2052 1
		define(macid("{if_family}", NULL), NULL, &BlankEnvelope);
a2332 1
	volatile u_short port = 0;
d2353 2
a2354 11
		if (i < 0)
		{
			/*
			**  ENOTSOCK is OK: bail on anything else, but reset
			**  errno in this case, so a mis-report doesn't
			**  happen later.
			*/
			if (errno != ENOTSOCK)
				return NULL;
			errno = 0;
		}
d2356 1
a2356 1
				RealUserName);
a2393 4
# if _FFR_FREEHOSTENT && NETINET6
			freehostent(hp);
			hp = NULL;
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a2411 1
		port = RealHostAddr.sin.sin_port;
a2442 1
		port = RealHostAddr.sin6.sin6_port;
a2479 1

a2588 18
	/* put back the original incoming port */
	switch (RealHostAddr.sa.sa_family)
	{
# if NETINET
	  case AF_INET:
		if (port > 0)
			RealHostAddr.sin.sin_port = port;
		break;
# endif /* NETINET */

# if NETINET6
	  case AF_INET6:
		if (port > 0)
			RealHostAddr.sin6.sin6_port = port;
		break;
# endif /* NETINET6 */
	}

a2717 19

	/* put back the original incoming port */
	switch (RealHostAddr.sa.sa_family)
	{
# if NETINET
	  case AF_INET:
		if (port > 0)
			RealHostAddr.sin.sin_port = port;
		break;
# endif /* NETINET */

# if NETINET6
	  case AF_INET6:
		if (port > 0)
			RealHostAddr.sin6.sin6_port = port;
		break;
# endif /* NETINET6 */
	}

a2837 3
		{
			if (tTd(9, 1))
				dprintf("FAILED\n");
a2838 1
		}
a2858 4
# if _FFR_FREEHOSTENT && NETINET6
			freehostent(hp);
			hp = NULL;
# endif /* _FFR_FREEHOSTENT && NETINET6 */
a2872 2
		if (tTd(9, 1))
			dprintf("FOUND %s\n", ans);
a3042 3
# if _FFR_FREEHOSTENT && NETINET6
	freehostent(hp);
# endif /* _FFR_FREEHOSTENT && NETINET6 */
d3295 1
a3295 19
	{
		char *name;

		name = denlstring((char *) hp->h_name, TRUE, TRUE);

#  if _FFR_FREEHOSTENT && NETINET6
		if (name == hp->h_name)
		{
			static char n[MAXNAME + 1];

			/* Copy the string, hp->h_name is about to disappear */
			strlcpy(n, name, sizeof n);
			name = n;
		}

		freehostent(hp);
#  endif /* _FFR_FREEHOSTENT && NETINET6 */
		return name;
	}
a3296 9

# if _FFR_FREEHOSTENT && NETINET6
	if (hp != NULL)
	{
		freehostent(hp);
		hp = NULL;
	}
# endif /* _FFR_FREEHOSTENT && NETINET6 */

@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 8
a23 1
SM_RCSID("@@(#)$Sendmail: daemon.c,v 8.588 2001/09/05 15:08:00 ca Exp $")
d29 1
a29 1
#if defined(USE_SOCK_STREAM)
d38 1
a38 1
#endif /* defined(USE_SOCK_STREAM) */
d40 1
a40 25
#if STARTTLS
#  include <openssl/rand.h>
#endif /* STARTTLS */

#include <sys/time.h>

#if IP_SRCROUTE && NETINET
# include <netinet/in_systm.h>
# include <netinet/ip.h>
# if HAS_IN_H
#  include <netinet/in.h>
#  ifndef IPOPTION
#   define IPOPTION	ip_opts
#   define IP_LIST	ip_opts
#   define IP_DST	ip_dst
#  endif /* ! IPOPTION */
# else /* HAS_IN_H */
#  include <netinet/ip_var.h>
#  ifndef IPOPTION
#   define IPOPTION	ipoption
#   define IP_LIST	ipopt_list
#   define IP_DST	ipopt_dst
#  endif /* ! IPOPTION */
# endif /* HAS_IN_H */
#endif /* IP_SRCROUTE && NETINET */
d42 25
a66 1
#include <sm/fdset.h>
d68 1
a68 1
/* structure to describe a daemon or a client */
d73 1
a73 1
	unsigned short	d_port;		/* port number */
a82 6
#if MILTER
# if _FFR_MILTER_PERDAEMON
	char		*d_inputfilterlist;
	struct milter	*d_inputfilters[MAXFILTERS];
# endif /* _FFR_MILTER_PERDAEMON */
#endif /* MILTER */
d87 3
a89 4
static void		connecttimeout __P((void));
static int		opendaemonsocket __P((DAEMON_T *, bool));
static unsigned short	setupdaemon __P((SOCKADDR *));
static void		getrequests_checkdiskspace __P((ENVELOPE *e));
d111 1
a111 1
**	makeconnection(host, port, mci, e, enough)
d113 4
a116 2
**		port. Returns zero on success, else an exit status
**		describing the error.
d122 1
a122 1
static int	NDaemons = 0;			/* actual number of daemons */
d124 3
a126 1
static time_t	NextDiskSpaceCheck = 0;
a143 2
**		May restart persistent queue runners if they have ended
**		for some reason.
d151 1
d154 1
a154 1
#if XDEBUG
d156 1
a156 1
#endif /* XDEBUG */
a163 1
	extern bool refuseconnections __P((char *, ENVELOPE *, int, bool));
d166 1
a166 1
	for (idx = 0; idx < NDaemons; idx++)
d169 1
a169 1
		Daemons[idx].d_firsttime = true;
d179 1
a179 1
		for (idx = 0; idx < NDaemons; idx++)
d181 3
a183 3
			sm_dprintf("getrequests: daemon %s: port %d\n",
				   Daemons[idx].d_name,
				   ntohs(Daemons[idx].d_port));
d188 2
a189 2
	for (idx = 0; idx < NDaemons; idx++)
		Daemons[idx].d_socksize = opendaemonsocket(&Daemons[idx], true);
d194 1
a194 1
			  ControlSocketName, sm_errstring(errno));
d196 1
a196 2
	/* If there are any queue runners releated reapchild() co-ord's */
	(void) sm_signal(SIGCHLD, reapchild);
d198 1
a198 1
	/* write the pid to file, command line args to syslog */
d201 1
a201 1
#if XDEBUG
d208 1
a208 1
#endif /* XDEBUG */
d211 1
a211 1
	proc_list_add(CurrentPid, "Sendmail daemon", PROC_DAEMON, 0, -1);
d215 2
a216 2
		for (idx = 0; idx < NDaemons; idx++)
			sm_dprintf("getrequests: daemon %s: %d\n",
d225 2
a226 2
		bool timedout = false;
		bool control = false;
d229 2
a230 2
		time_t now;
#if STARTTLS
d232 2
a233 1
#endif /* STARTTLS */
d236 1
a236 1
		(void) sm_blocksignal(SIGALRM);
d238 6
a243 6
		if (ShutdownRequest != NULL)
			shutdown_daemon();
		else if (RestartRequest != NULL)
			restart_daemon();
		else if (RestartWorkGroup)
			restart_marked_work_groups();
d245 1
a245 1
		for (idx = 0; idx < NDaemons; idx++)
d247 21
a267 4
			/*
			**  XXX do this call outside the loop?
			**	no: refuse_connections may sleep().
			*/
d269 3
a271 4
			now = curtime();
			if (now < Daemons[idx].d_refuse_connections_until)
				continue;
			if (bitnset(D_DISABLE, Daemons[idx].d_flags))
d273 1
a273 2
			if (refuseconnections(Daemons[idx].d_name, e, idx,
					      curdaemon == idx))
d283 1
a283 1
				Daemons[idx].d_refuse_connections_until = now + 15;
d288 1
a288 1
				if (!Daemons[idx].d_firsttime && LogLevel > 8)
d294 2
a295 2
				(void) opendaemonsocket(&Daemons[idx], false);
				Daemons[idx].d_firsttime = false;
d299 40
a338 7
		/* May have been sleeping above, check again */
		if (ShutdownRequest != NULL)
			shutdown_daemon();
		else if (RestartRequest != NULL)
			restart_daemon();
		else if (RestartWorkGroup)
			restart_marked_work_groups();
d340 8
a347 1
		getrequests_checkdiskspace(e);
d349 1
a349 1
#if XDEBUG
d370 1
a370 1
#endif /* XDEBUG */
d372 1
a372 1
#if 0
d380 1
a380 1
		    SetNonBlocking(DaemonSocket, false) < 0)
d382 2
a383 2
#endif /* 0 */
		(void) sm_releasesignal(SIGALRM);
d387 1
a387 1
			bool setproc = false;
a391 7
			if (ShutdownRequest != NULL)
				shutdown_daemon();
			else if (RestartRequest != NULL)
				restart_daemon();
			else if (RestartWorkGroup)
				restart_marked_work_groups();

d394 1
a394 1
			for (idx = 0; idx < NDaemons; idx++)
d403 1
a403 1
						sm_setproctitle(true, e,
d405 1
a405 1
						setproc = true;
d409 1
a409 2
					SM_FD_SET(Daemons[idx].d_socket,
						  &readfds);
d413 1
a413 1
#if NETUNIX
d418 1
a418 1
				SM_FD_SET(ControlSocket, &readfds);
d420 7
a426 1
#endif /* NETUNIX */
d428 7
a434 1
			timeout.tv_sec = 5;
a439 7
			/* Did someone signal while waiting? */
			if (ShutdownRequest != NULL)
				shutdown_daemon();
			else if (RestartRequest != NULL)
				restart_daemon();
			else if (RestartWorkGroup)
				restart_marked_work_groups();
d442 2
a445 3
			if (doqueuerun())
				(void) runqueue(true, false, false, false);

d448 1
a448 1
				timedout = true;
d452 1
a452 1
			control = false;
d456 1
a456 1
			if ((idx = olddaemon + 1) >= NDaemons)
d458 1
a458 1
			for (i = 0; i < NDaemons; i++)
d461 1
a461 2
				    SM_FD_ISSET(Daemons[idx].d_socket,
						&readfds))
a463 2
					memset(&RealHostAddr, '\0',
					       sizeof RealHostAddr);
a466 18

					/*
					**  If remote side closes before
					**  accept() finishes, sockaddr
					**  might not be fully filled in.
					*/

					if (t >= 0 &&
					    (lotherend == 0 ||
# ifdef BSD4_4_SOCKADDR
					     RealHostAddr.sa.sa_len == 0 ||
# endif /* BSD4_4_SOCKADDR */
					     RealHostAddr.sa.sa_family != Daemons[idx].d_addr.sa.sa_family))
					{
						(void) close(t);
						t = -1;
						errno = EINVAL;
					}
d470 1
a470 1
				if (++idx >= NDaemons)
d473 1
a473 1
#if NETUNIX
d475 1
a475 1
			    SM_FD_ISSET(ControlSocket, &readfds))
a479 1
				memset(&sa_un, '\0', sizeof sa_un);
d483 1
a483 20

				/*
				**  If remote side closes before
				**  accept() finishes, sockaddr
				**  might not be fully filled in.
				*/

				if (t >= 0 &&
				    (lotherend == 0 ||
# ifdef BSD4_4_SOCKADDR
				     sa_un.sun_len == 0 ||
# endif /* BSD4_4_SOCKADDR */
				     sa_un.sun_family != AF_UNIX))
				{
					(void) close(t);
					t = -1;
					errno = EINVAL;
				}
				if (t >= 0)
					control = true;
d485 1
a485 1
#else /* NETUNIX */
d491 1
a491 1
#endif /* NETUNIX */
d497 1
a497 1
			timedout = false;
d501 2
a502 1
		(void) sm_blocksignal(SIGALRM);
d511 1
a511 1
#if SO_REUSEADDR_IS_BROKEN
d518 2
a519 2
			Daemons[curdaemon].d_refuse_connections_until = curtime() + 15;
#endif /* SO_REUSEADDR_IS_BROKEN */
d529 2
a530 2
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{daemon_family}"), "unspec");
d532 1
a532 9
#if _FFR_DAEMON_NETUNIX
# if NETUNIX
			  case AF_UNIX:
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{daemon_family}"), "local");
				break;
# endif /* NETUNIX */
#endif /* _FFR_DAEMON_NETUNIX */
#if NETINET
d534 2
a535 2
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{daemon_family}"), "inet");
d537 2
a538 2
#endif /* NETINET */
#if NETINET6
d540 2
a541 2
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{daemon_family}"), "inet6");
d543 2
a544 2
#endif /* NETINET6 */
#if NETISO
d546 2
a547 2
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{daemon_family}"), "iso");
d549 2
a550 2
#endif /* NETISO */
#if NETNS
d552 2
a553 2
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{daemon_family}"), "ns");
d555 2
a556 2
#endif /* NETNS */
#if NETX25
d558 2
a559 2
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{daemon_family}"), "x.25");
d561 1
a561 1
#endif /* NETX25 */
d563 2
a564 3
			macdefine(&BlankEnvelope.e_macro, A_PERM,
				macid("{daemon_name}"),
				Daemons[curdaemon].d_name);
d566 3
a568 3
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{daemon_flags}"),
					Daemons[curdaemon].d_mflags);
d570 2
a571 2
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{daemon_flags}"), "");
d579 1
a579 1
			sm_dprintf("getrequests: forking (fd = %d)\n", t);
d582 2
a583 2
		**  Advance state of PRNG.
		**  This is necessary because otherwise all child processes
d588 1
a588 2
#if STARTTLS
		/* XXX get some better "random" data? */
d590 3
a592 3
		RAND_seed((void *) &NextDiskSpaceCheck,
			  sizeof NextDiskSpaceCheck);
		RAND_seed((void *) &now, sizeof now);
d594 1
a594 1
#else /* STARTTLS */
d596 1
a596 12
#endif /* STARTTLS */

#if NAMED_BIND
		/*
		**  Update MX records for FallBackMX.
		**  Let's hope this is fast otherwise we screw up the
		**  response time.
		*/

		if (FallBackMX != NULL)
			(void) getfallbackmxrr(FallBackMX);
#endif /* NAMED_BIND */
d598 1
a598 1
#if !PROFILING
d608 1
a608 1
		(void) sm_blocksignal(SIGCHLD);
d618 1
a618 1
			(void) sm_releasesignal(SIGCHLD);
d623 1
a623 2

#else /* !PROFILING */
d625 1
a625 1
#endif /* !PROFILING */
d630 1
a630 1
			SM_FILE_T *inchannel, *outchannel = NULL;
a637 23
			/* Reset global flags */
			RestartRequest = NULL;
			RestartWorkGroup = false;
			ShutdownRequest = NULL;
			PendingSignal = 0;
			CurrentPid = getpid();

			(void) sm_releasesignal(SIGALRM);
			(void) sm_releasesignal(SIGCHLD);
			(void) sm_signal(SIGCHLD, SIG_DFL);
			(void) sm_signal(SIGHUP, SIG_DFL);
			(void) sm_signal(SIGTERM, intsig);

			/* turn on profiling */
			/* SM_PROF(0); */

			/*
			**  Initialize exception stack and default exception
			**  handler for child process.
			*/

			sm_exc_newthread(fatal_error);

d640 4
a643 4
				macdefine(&BlankEnvelope.e_macro, A_TEMP,
					macid("{daemon_addr}"),
					anynet_ntoa(&Daemons[curdaemon].d_addr));
				(void) sm_snprintf(status, sizeof status, "%d",
d645 2
a646 2
				macdefine(&BlankEnvelope.e_macro, A_TEMP,
					macid("{daemon_port}"), status);
d649 5
a653 1
			for (idx = 0; idx < NDaemons; idx++)
a656 1
				Daemons[idx].d_socket = -1;
d664 2
a665 3
				proc_list_add(CurrentPid,
					      "console socket child",
					      PROC_CONTROL_CHILD, 0, -1);
d672 2
a673 2
				proc_list_add(CurrentPid, "daemon child",
					      PROC_DAEMON_CHILD, 0, -1);
d678 1
a678 1
				sm_setproctitle(true, e, "startup with %s",
d682 1
a682 1
#if !PROFILING
d704 1
a704 1
#endif /* !PROFILING */
d710 1
d717 1
a717 1
			if (strlen(p) > MAXNAME) /* XXX  - 1 ? */
d722 4
a725 3
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{client_resolve}"),
					h_errno == TRY_AGAIN ? "TEMP" : "FAIL");
d728 10
a737 18
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{client_resolve}"), "OK");
			sm_setproctitle(true, e, "startup with %s", p);

			if ((inchannel = sm_io_open(SmFtStdiofd,
						    SM_TIME_DEFAULT,
						    (void *) t,
						    SM_IO_RDONLY, NULL)) == NULL
			    || (t = dup(t)) < 0 ||
			    (outchannel = sm_io_open(SmFtStdiofd,
						     SM_TIME_DEFAULT,
						     (void *) t,
						     SM_IO_WRONLY, NULL))
			    == NULL)
			{
				syserr("cannot open SMTP server channel, fd=%d",
					t);
				finis(false, EX_OK);
a738 1
			sm_io_automode(inchannel, outchannel);
d742 1
a742 1
			DisConnected = false;
d744 1
a744 1
#if XLA
d748 1
a748 1
				finis(false, EX_OK);
d750 1
a750 1
#endif /* XLA */
d752 2
a753 2
			if (getsockname(sm_io_getinfo(InChannel, SM_IO_WHAT_FD,
						      NULL), &sa.sa, &len) == 0)
d757 3
a759 8
					sm_dprintf("getreq: got name %s\n", p);
				macdefine(&BlankEnvelope.e_macro, A_TEMP,
					macid("{if_name}"), p);

				/*
				**  Do this only if it is not the loopback
				**  interface.
				*/
d761 2
d765 7
a771 13
					char *addr;
					char family[5];

					addr = anynet_ntoa(&sa);
					(void) sm_snprintf(family,
						sizeof(family),
						"%d", sa.sa.sa_family);
					macdefine(&BlankEnvelope.e_macro,
						A_TEMP,
						macid("{if_addr}"), addr);
					macdefine(&BlankEnvelope.e_macro,
						A_TEMP,
						macid("{if_family}"), family);
d773 5
a777 2
						sm_dprintf("getreq: got addr %s and family %s\n",
							addr, family);
d781 4
a784 6
					macdefine(&BlankEnvelope.e_macro,
						A_PERM,
						macid("{if_addr}"), NULL);
					macdefine(&BlankEnvelope.e_macro,
						A_PERM,
						macid("{if_family}"), NULL);
d790 7
a796 7
					sm_dprintf("getreq: getsockname failed\n");
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{if_name}"), NULL);
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{if_addr}"), NULL);
				macdefine(&BlankEnvelope.e_macro, A_PERM,
					macid("{if_family}"), NULL);
d804 2
a805 3
			(void) sm_snprintf(status, sizeof status,
					   "control socket server child");
			proc_list_add(pid, status, PROC_CONTROL, 0, -1);
d809 4
a812 4
			(void) sm_snprintf(status, sizeof status,
					   "SMTP server child for %s",
					   anynet_ntoa(&RealHostAddr));
			proc_list_add(pid, status, PROC_DAEMON, 0, -1);
d814 1
a814 1
		(void) sm_releasesignal(SIGCHLD);
d833 1
d835 1
a835 19
		sm_dprintf("getreq: returning\n");

#if MILTER
# if _FFR_MILTER_PERDAEMON
	/* set the filters for this daemon */
	if (Daemons[curdaemon].d_inputfilterlist != NULL)
	{
		for (i = 0;
		     (Daemons[curdaemon].d_inputfilters[i] != NULL &&
		      i < MAXFILTERS);
		     i++)
		{
			InputFilters[i] = Daemons[curdaemon].d_inputfilters[i];
		}
		if (i < MAXFILTERS)
			InputFilters[i] = NULL;
	}
# endif /* _FFR_MILTER_PERDAEMON */
#endif /* MILTER */
a837 74

/*
**  GETREQUESTS_CHECKDISKSPACE -- check available diskspace.
**
**	Parameters:
**		e -- envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Modifies Daemon flags (D_ETRNONLY) if not enough disk space.
*/

static void
getrequests_checkdiskspace(e)
	ENVELOPE *e;
{
	bool logged = false;
	int idx;
	time_t now;

	now = curtime();
	if (now < NextDiskSpaceCheck)
		return;

	/* Check if there is available disk space in all queue groups. */
	if (!enoughdiskspace(0, NULL))
	{
		for (idx = 0; idx < NDaemons; ++idx)
		{
			if (bitnset(D_ETRNONLY, Daemons[idx].d_flags))
				continue;

			/* log only if not logged before */
			if (!logged)
			{
				if (LogLevel > 8)
					sm_syslog(LOG_INFO, NOQID,
						  "rejecting new messages: min free: %ld",
						  MinBlocksFree);
				sm_setproctitle(true, e,
						"rejecting new messages: min free: %ld",
						MinBlocksFree);
				logged = true;
			}
			setbitn(D_ETRNONLY, Daemons[idx].d_flags);
		}
	}
	else
	{
		for (idx = 0; idx < NDaemons; ++idx)
		{
			if (!bitnset(D_ETRNONLY, Daemons[idx].d_flags))
				continue;

			/* log only if not logged before */
			if (!logged)
			{
				if (LogLevel > 8)
					sm_syslog(LOG_INFO, NOQID,
						  "accepting new messages (again)");
				logged = true;
			}

			/* title will be set later */
			clrbitn(D_ETRNONLY, Daemons[idx].d_flags);
		}
	}

	/* only check disk space once a minute */
	NextDiskSpaceCheck = now + 60;
}

d855 1
a855 1
#define MAXOPENTRIES	10	/* maximum number of tries to open connection */
d859 1
a859 1
	DAEMON_T *d;
d869 1
a869 1
		sm_dprintf("opendaemonsocket(%s)\n", d->d_name);
a876 25
#if _FFR_DAEMON_NETUNIX
# if NETUNIX
			if (d->d_addr.sa.sa_family == AF_UNIX)
			{
				int rval;
				long sff = SFF_SAFEDIRPATH|SFF_OPENASROOT|SFF_NOLINK|SFF_ROOTOK|SFF_EXECOK;
				/* if not safe, don't use it */
				rval = safefile(d->d_addr.sunix.sun_path,
						RunAsUid, RunAsGid,
						RunAsUserName, sff,
						S_IRUSR|S_IWUSR, NULL);
				if (rval != 0)
				{
					save_errno = errno;
					syserr("opendaemonsocket: daemon %s: unsafe domain socket %s",
					       d->d_name,
					       d->d_addr.sunix.sun_path);
					goto fail;
				}

				/* Don't try to overtake an existing socket */
				(void) unlink(d->d_addr.sunix.sun_path);
			}
# endif /* NETUNIX */
#endif /* _FFR_DOMAIN_NETUNIX */
d882 1
a882 13
				syserr("opendaemonsocket: daemon %s: can't create server SMTP socket",
				       d->d_name);
			  fail:
				if (bitnset(D_OPTIONAL, d->d_flags) &&
				    (!transienterror(save_errno) ||
				     ntries >= MAXOPENTRIES - 1))
				{
					syserr("opendaemonsocket: daemon %s: optional socket disabled",
					       d->d_name);
					setbitn(D_DISABLE, d->d_flags);
					d->d_socket = -1;
					return -1;
				}
d886 1
a886 2
						  "daemon %s: problem creating SMTP socket",
						  d->d_name);
d902 1
a902 1
#ifdef SO_RCVBUF
d911 2
a912 2
#endif /* SO_RCVBUF */
#ifdef SO_SNDBUF
d921 1
a921 1
#endif /* SO_SNDBUF */
d931 1
a931 1
				       sm_errstring(save_errno));
d938 1
a938 8
#if _FFR_DAEMON_NETUNIX
# ifdef NETUNIX
			  case AF_UNIX:
				socksize = sizeof d->d_addr.sunix;
				break;
# endif /* NETUNIX */
#endif /* _FFR_DAEMON_NETUNIX */
#if NETINET
d942 1
a942 1
#endif /* NETINET */
d944 1
a944 1
#if NETINET6
d948 1
a948 1
#endif /* NETINET6 */
d950 1
a950 1
#if NETISO
d954 1
a954 1
#endif /* NETISO */
d968 1
a968 1
				goto fail;
d992 1
d998 1
a998 2

static unsigned short
d1002 1
a1002 1
	unsigned short port;
d1011 1
a1011 1
#if NETINET
d1013 1
a1013 1
#endif /* NETINET */
d1018 1
a1018 1
#if NETINET
d1024 1
a1024 1
#endif /* NETINET */
d1026 1
a1026 1
#if NETINET6
d1032 1
a1032 1
#endif /* NETINET6 */
d1041 1
a1041 1
#ifdef NO_GETSERVBYNAME
d1043 1
a1043 1
#else /* NO_GETSERVBYNAME */
d1056 1
a1056 1
#endif /* NO_GETSERVBYNAME */
d1061 1
a1061 1
#if NETINET
d1065 1
a1065 1
#endif /* NETINET */
d1067 1
a1067 1
#if NETINET6
d1071 1
a1071 1
#endif /* NETINET6 */
d1077 1
a1077 1
	return port;
d1097 1
a1097 1
	for (i = 0; i < NDaemons; i++)
a1103 66

/*
**  GETMODIFIERS -- get modifier flags
**
**	Parameters:
**		v -- the modifiers (input text line).
**		modifiers -- pointer to flag field to represent modifiers.
**
**	Returns:
**		(xallocat()ed) string representation of modifiers.
**
**	Side Effects:
**		fills in modifiers.
*/

char *
getmodifiers(v, modifiers)
	char *v;
	BITMAP256 modifiers;
{
	int l;
	char *h, *f, *flags;

	/* maximum length of flags: upper case Option -> "OO " */
	l = 3 * strlen(v) + 3;
	flags = xalloc(l);
	f = flags;
	clrbitmap(modifiers);
	for (h = v; *h != '\0'; h++)
	{
		if (!(isascii(*h) && isspace(*h)))
		{
			setbitn(*h, modifiers);
			if (flags != f)
				*flags++ = ' ';
			*flags++ = *h;
			if (isupper(*h))
				*flags++ = *h;
		}
	}
	*flags++ = '\0';
	return f;
}

/*
**  CHKDAEMONMODIFIERS -- check whether all daemons have set a flag.
**
**	Parameters:
**		flag -- the flag to test.
**
**	Returns:
**		true iff all daemons have set flag.
*/

bool
chkdaemonmodifiers(flag)
	int flag;
{
	int i;

	for (i = 0; i < NDaemons; i++)
		if (!bitnset((char) flag, Daemons[i].d_flags))
			return false;
	return true;
}

d1118 1
a1118 1
	DAEMON_T *d;
d1120 1
a1120 1
#if NETISO
d1122 3
a1124 1
#endif /* NETISO */
d1128 1
a1128 1
#if NETINET
d1131 1
a1131 1
#endif /* NETINET */
d1159 2
a1160 9
#if _FFR_DAEMON_NETUNIX
# ifdef NETUNIX
			else if (sm_strcasecmp(v, "unix") == 0 ||
				 sm_strcasecmp(v, "local") == 0)
				d->d_addr.sa.sa_family = AF_UNIX;
# endif /* NETUNIX */
#endif /* _FFR_DAEMON_NETUNIX */
#if NETINET
			else if (sm_strcasecmp(v, "inet") == 0)
d1162 3
a1164 3
#endif /* NETINET */
#if NETINET6
			else if (sm_strcasecmp(v, "inet6") == 0)
d1166 3
a1168 3
#endif /* NETINET6 */
#if NETISO
			else if (sm_strcasecmp(v, "iso") == 0)
d1170 3
a1172 3
#endif /* NETISO */
#if NETNS
			else if (sm_strcasecmp(v, "ns") == 0)
d1174 3
a1176 3
#endif /* NETNS */
#if NETX25
			else if (sm_strcasecmp(v, "x.25") == 0)
d1178 1
a1178 1
#endif /* NETX25 */
a1187 8
#if MILTER
# if _FFR_MILTER_PERDAEMON
		  case 'I':
			d->d_inputfilterlist = v;
			break;
# endif /* _FFR_MILTER_PERDAEMON */
#endif /* MILTER */

d1197 19
a1215 1
			d->d_mflags = getmodifiers(v, d->d_flags);
d1241 1
a1241 29
#if _FFR_DAEMON_NETUNIX
# if NETUNIX
		  case AF_UNIX:
			if (strlen(addr) >= sizeof(d->d_addr.sunix.sun_path))
			{
				errno = ENAMETOOLONG;
				syserr("setsockaddroptions: domain socket name too long: %s > %d",
				       addr, sizeof(d->d_addr.sunix.sun_path));
				break;
			}

			/* if not safe, don't use it */
			if (safefile(addr, RunAsUid, RunAsGid,
				     RunAsUserName,
				     SFF_SAFEDIRPATH|SFF_OPENASROOT|SFF_NOLINK|SFF_ROOTOK|SFF_EXECOK,
				     S_IRUSR|S_IWUSR, NULL) != 0)
			{
				syserr("setsockaddroptions: unsafe domain socket");
				break;
			}
			(void) memset(&d->d_addr.sunix.sun_path, '\0',
				      sizeof(d->d_addr.sunix.sun_path));
			(void) sm_strlcpy((char *)&d->d_addr.sunix.sun_path,
					  addr,
					  sizeof(d->d_addr.sunix.sun_path));
			break;
# endif /* NETUNIX */
#endif	/* _FFR_DAEMON_NETUNIX */
#if NETINET
d1244 1
a1244 2
			    ((d->d_addr.sin.sin_addr.s_addr = inet_addr(addr))
			     == INADDR_NONE))
d1264 1
a1264 1
# if NETINET6
d1267 1
a1267 1
# endif /* NETINET6 */
d1271 1
a1271 1
#endif /* NETINET */
d1273 1
a1273 1
#if NETINET6
d1275 4
a1278 3
			if (!isascii(*addr) || !isxdigit(*addr) ||
			    anynet_pton(AF_INET6, addr,
					&d->d_addr.sin6.sin6_addr) != 1)
d1298 1
d1301 1
d1305 1
a1305 1
#endif /* NETINET6 */
d1318 1
a1318 1
#if NETINET
d1321 1
a1321 2
				d->d_addr.sin.sin_port = htons((unsigned short)
						     atoi((const char *) port));
d1324 1
a1324 1
# ifdef NO_GETSERVBYNAME
d1327 1
a1327 1
# else /* NO_GETSERVBYNAME */
d1336 1
a1336 1
# endif /* NO_GETSERVBYNAME */
d1339 1
a1339 1
#endif /* NETINET */
d1341 1
a1341 1
#if NETINET6
d1344 1
a1344 2
				d->d_addr.sin6.sin6_port = htons((unsigned short)
								  atoi(port));
d1347 1
a1347 1
# ifdef NO_GETSERVBYNAME
d1350 1
a1350 1
# else /* NO_GETSERVBYNAME */
d1359 1
a1359 1
# endif /* NO_GETSERVBYNAME */
d1362 1
a1362 1
#endif /* NETINET6 */
d1364 1
a1364 1
#if NETISO
d1368 1
a1368 1
				portno = htons((unsigned short) atoi(port));
d1371 1
a1371 1
# ifdef NO_GETSERVBYNAME
d1374 1
a1374 1
# else /* NO_GETSERVBYNAME */
d1383 1
a1383 1
# endif /* NO_GETSERVBYNAME */
d1388 1
a1388 1
#endif /* NETISO */
d1404 1
a1404 4
**		true if successful, false otherwise.
**
**	Side Effects:
**		increments number of daemons.
a1406 2
#define DEF_LISTENQUEUE	10

d1411 6
a1416 13
	if (NDaemons >= MAXDAEMONS)
		return false;
	Daemons[NDaemons].d_socket = -1;
	Daemons[NDaemons].d_listenqueue = DEF_LISTENQUEUE;
	clrbitmap(Daemons[NDaemons].d_flags);
	setsockaddroptions(p, &Daemons[NDaemons]);

#if MILTER
# if _FFR_MILTER_PERDAEMON
	if (Daemons[NDaemons].d_inputfilterlist != NULL)
		Daemons[NDaemons].d_inputfilterlist = newstr(Daemons[NDaemons].d_inputfilterlist);
# endif /* _FFR_MILTER_PERDAEMON */
#endif /* MILTER */
d1418 2
a1419 2
	if (Daemons[NDaemons].d_name != NULL)
		Daemons[NDaemons].d_name = newstr(Daemons[NDaemons].d_name);
d1424 2
a1425 2
		(void) sm_snprintf(num, sizeof num, "Daemon%d", NDaemons);
		Daemons[NDaemons].d_name = newstr(num);
d1430 6
a1435 6
		sm_dprintf("Daemon %s flags: ", Daemons[NDaemons].d_name);
		if (bitnset(D_ETRNONLY, Daemons[NDaemons].d_flags))
			sm_dprintf("ETRNONLY ");
		if (bitnset(D_NOETRN, Daemons[NDaemons].d_flags))
			sm_dprintf("NOETRN ");
		sm_dprintf("\n");
d1437 2
a1438 2
	++NDaemons;
	return true;
a1451 1

d1455 1
a1455 1
	if (NDaemons == 0)
d1457 4
a1460 4
		Daemons[NDaemons].d_socket = -1;
		Daemons[NDaemons].d_listenqueue = DEF_LISTENQUEUE;
		Daemons[NDaemons].d_name = "Daemon0";
		NDaemons = 1;
d1473 1
a1473 1
static DAEMON_T	ClientSettings[AF_MAX + 1];
d1479 2
a1480 2
	int family;
	DAEMON_T d;
d1486 6
a1491 5
	family = d.d_addr.sa.sa_family;
	STRUCTCOPY(d, ClientSettings[family]);
	setbitn(D_ISSET, ClientSettings[family].d_flags); /* mark as set */
	if (d.d_name != NULL)
		ClientSettings[family].d_name = newstr(d.d_name);
d1493 2
a1494 7
	{
		char num[30];

		(void) sm_snprintf(num, sizeof num, "Client%d", family);
		ClientSettings[family].d_name = newstr(num);
	}
}
d1512 1
a1512 1
#if NETINET6
d1514 1
a1514 1
#endif /* NETINET6 */
d1516 1
a1516 1
#if NETINET
d1520 1
a1520 1
			sm_dprintf("addr_family(%s): INET\n", addr);
d1523 3
a1525 3
#endif /* NETINET */
#if NETINET6
	if (anynet_pton(AF_INET6, addr, &clt_addr.sin6.sin6_addr) == 1)
d1528 1
a1528 1
			sm_dprintf("addr_family(%s): INET6\n", addr);
d1531 1
a1531 11
#endif /* NETINET6 */
#if _FFR_DAEMON_NETUNIX
# if NETUNIX
	if (*addr == '/')
	{
		if (tTd(16, 9))
			sm_dprintf("addr_family(%s): LOCAL\n", addr);
		return AF_UNIX;
	}
# endif /* NETUNIX */
#endif	/* _FFR_DAEMON_NETUNIX */
d1533 1
a1533 1
		sm_dprintf("addr_family(%s): UNSPEC\n", addr);
a1535 66

/*
**  CHKCLIENTMODIFIERS -- check whether all clients have set a flag.
**
**	Parameters:
**		flag -- the flag to test.
**
**	Returns:
**		true iff all configured clients have set the flag.
*/

bool
chkclientmodifiers(flag)
	int flag;
{
	int i;
	bool flagisset;

	flagisset = false;
	for (i = 0; i < AF_MAX; i++)
	{
		if (bitnset(D_ISSET, ClientSettings[i].d_flags))
		{
			if (!bitnset((char) flag, ClientSettings[i].d_flags))
				return false;
			flagisset = true;
		}
	}
	return flagisset;
}

#if MILTER
# if _FFR_MILTER_PERDAEMON
/*
**  SETUP_DAEMON_FILTERS -- Parse per-socket filters
**
**	Parameters:
**		none
**
**	Returns:
**		none
*/

void
setup_daemon_milters()
{
	int idx;

	if (OpMode == MD_SMTP)
	{
		/* no need to configure the daemons */
		return;
	}

	for (idx = 0; idx < NDaemons; idx++)
	{
		if (Daemons[idx].d_inputfilterlist != NULL)
		{
			milter_config(Daemons[idx].d_inputfilterlist,
				      Daemons[idx].d_inputfilters,
				      MAXFILTERS);
		}
	}
}
# endif /* _FFR_MILTER_PERDAEMON */
#endif /* MILTER */
a1544 2
**		enough -- time at which to stop further connection attempts.
**			(0 means no limit)
d1559 1
a1559 1
makeconnection(host, port, mci, e, enough)
d1561 1
a1561 1
	volatile unsigned int port;
a1563 1
	time_t enough;
d1567 1
a1567 1
	register struct hostent *volatile hp = (struct hostent *) NULL;
d1573 4
a1576 4
	SM_EVENT *volatile ev = NULL;
#if NETINET6
	volatile bool v6found = false;
#endif /* NETINET6 */
d1585 1
a1585 1
	/* retranslate {daemon_flags} into bitmap */
d1587 1
a1587 1
	if ((p = macvalue(macid("{daemon_flags}"), e)) != NULL)
d1596 15
a1610 1
#if NETINET6
d1612 2
a1613 2
#endif /* NETINET6 */
	clt_bind = false;
d1617 1
a1617 2
	    (p = macvalue(macid("{if_addr}"), e)) != NULL &&
	    *p != '\0')
d1619 1
a1619 1
#if NETINET6
d1621 1
a1621 1
#endif /* NETINET6 */
d1629 1
a1629 1
#if NETINET
d1631 7
a1637 3
			clt_addr.sin.sin_addr.s_addr = inet_addr(p);
			if (clt_addr.sin.sin_addr.s_addr != INADDR_NONE &&
			    clt_addr.sin.sin_addr.s_addr != INADDR_LOOPBACK)
d1639 2
a1640 1
				clt_bind = true;
d1644 1
a1644 1
#endif /* NETINET */
d1646 1
a1646 1
#if NETINET6
d1649 1
a1649 2
				(void) sm_snprintf(p6, sizeof p6,
						   "IPv6:::ffff:%s", p);
d1651 3
a1653 4
				(void) sm_strlcpy(p6, p, sizeof p6);
			if (anynet_pton(AF_INET6, p6,
					&clt_addr.sin6.sin6_addr) == 1 &&
			    !IN6_IS_ADDR_LOOPBACK(&clt_addr.sin6.sin6_addr))
d1655 8
a1662 1
				clt_bind = true;
d1666 1
a1666 1
#endif /* NETINET6 */
d1668 1
a1668 1
#if 0
d1673 1
a1673 1
#endif /* 0 */
d1678 1
a1678 3

	/* D_BINDIF not set or not available, fallback to ClientPortOptions */
	if (!clt_bind)
d1680 3
a1682 1
		STRUCTCOPY(ClientSettings[family].d_addr, clt_addr);
d1685 1
a1685 1
#if NETINET
d1690 1
a1690 1
				clt_bind = true;
d1692 1
a1692 1
				clt_bind = true;
d1695 2
a1696 2
#endif /* NETINET */
#if NETINET6
d1701 1
a1701 1
				clt_bind = true;
d1704 1
a1704 1
				clt_bind = true;
d1706 2
a1707 2
#endif /* NETINET6 */
#if NETISO
d1710 1
a1710 1
			clt_bind = true;
d1712 1
a1712 1
#endif /* NETISO */
d1723 3
a1725 1
	SM_SET_H_ERRNO(0);
d1737 1
a1737 1
#if NETINET
d1739 2
a1740 2
#endif /* NETINET */
#if NETINET6
d1742 1
a1742 1
#endif /* NETINET6 */
d1745 1
a1745 1
#if NETINET6
d1747 2
a1748 2
#endif /* NETINET6 */
#if NETINET
d1756 2
a1757 2
#endif /* NETINET */
#if NETINET6
d1759 2
a1760 2
			    anynet_pton(AF_INET6, &host[1],
					&hid6.sin6_addr) == 1)
d1766 1
a1766 1
#endif /* NETINET6 */
d1772 1
a1772 1
#if NAMED_BIND
d1776 1
a1776 1
#endif /* NAMED_BIND */
d1781 1
a1781 1
#if NAMED_BIND
d1783 1
a1783 1
#endif /* NAMED_BIND */
d1810 1
a1810 1
#if NAMED_BIND
d1814 1
a1814 1
#endif /* NAMED_BIND */
d1818 1
a1818 1
#if NAMED_BIND
d1820 1
a1820 1
#endif /* NAMED_BIND */
d1826 1
a1826 1
#if NAMED_BIND
d1836 2
a1837 2
#endif /* NAMED_BIND */
#if NETINET6
d1851 1
a1851 1
#endif /* NETINET6 */
d1860 1
a1860 1
#if NETINET
d1866 1
a1866 1
#endif /* NETINET */
d1868 1
a1868 1
#if NETINET6
d1874 1
a1874 1
#endif /* NETINET6 */
d1885 3
a1887 1
			memmove(addr.sa.sa_data, hp->h_addr, hp->h_length);
d1899 1
a1899 1
#ifdef NO_GETSERVBYNAME
d1901 1
a1901 1
#else /* NO_GETSERVBYNAME */
d1913 1
a1913 15
#endif /* NO_GETSERVBYNAME */
	}

#if NETINET6
	if (addr.sa.sa_family == AF_INET6 &&
	    IN6_IS_ADDR_V4MAPPED(&addr.sin6.sin6_addr) &&
	    ClientSettings[AF_INET].d_addr.sa.sa_family != 0)
	{
		/*
		**  Ignore mapped IPv4 address since
		**  there is a ClientPortOptions setting
		**  for IPv4.
		*/

		goto nextaddr;
a1914 1
#endif /* NETINET6 */
d1918 1
a1918 1
#if NETINET
d1923 1
a1923 1
#endif /* NETINET */
d1925 1
a1925 1
#if NETINET6
d1930 1
a1930 1
#endif /* NETINET6 */
d1932 1
a1932 1
#if NETISO
d1938 1
a1938 1
#endif /* NETISO */
d1944 1
a1944 1
#if NETINET6
d1947 1
a1947 1
#endif /* NETINET6 */
d1955 1
a1955 1
#if XLA
d1959 1
a1959 1
# if NETINET6
d1962 1
a1962 1
# endif /* NETINET6 */
d1965 1
a1965 1
#endif /* XLA */
d1967 1
a1967 1
	firstconnect = true;
d1971 2
a1972 3
			sm_dprintf("makeconnection (%s [%s].%d (%d))\n",
				   host, anynet_ntoa(&addr), ntohs(port),
				   addr.sa.sa_family);
d1991 1
a1991 1
#if XLA
d1993 1
a1993 1
#endif /* XLA */
d1995 1
a1995 1
#if NETINET6
d1998 1
a1998 1
#endif /* NETINET6 */
d2003 2
a2004 2
#ifdef SO_SNDBUF
		if (ClientSettings[family].d_tcpsndbufsize > 0)
d2007 2
a2008 2
				       (char *) &ClientSettings[family].d_tcpsndbufsize,
				       sizeof(ClientSettings[family].d_tcpsndbufsize)) < 0)
d2011 3
a2013 3
#endif /* SO_SNDBUF */
#ifdef SO_RCVBUF
		if (ClientSettings[family].d_tcprcvbufsize > 0)
d2016 2
a2017 2
				       (char *) &ClientSettings[family].d_tcprcvbufsize,
				       sizeof(ClientSettings[family].d_tcprcvbufsize)) < 0)
d2020 2
a2021 1
#endif /* SO_RCVBUF */
d2024 1
a2024 1
			sm_dprintf("makeconnection: fd=%d\n", s);
d2034 3
a2036 3
		if (e->e_xfp != NULL)	/* for debugging */
			(void) sm_io_flush(e->e_xfp, SM_TIME_DEFAULT);
		errno = 0;		/* for debugging */
d2044 1
a2044 1
#if NETINET
d2052 1
a2052 1
#endif /* NETINET */
d2054 1
a2054 1
#if NETINET6
d2062 1
a2062 1
#endif /* NETINET6 */
d2072 1
a2072 1
#if NETINET6
d2075 1
a2075 1
#endif /* NETINET6 */
d2091 1
a2091 2
				ev = sm_setevent(TimeOuts.to_iconnect,
						 connecttimeout, 0);
d2093 1
a2093 2
				ev = sm_setevent(TimeOuts.to_connect,
						 connecttimeout, 0);
d2099 1
a2099 1
#if NETINET
d2103 1
a2103 1
#endif /* NETINET */
d2105 1
a2105 1
#if NETINET6
d2111 1
a2111 1
#endif /* NETINET6 */
d2116 1
a2116 1
				sm_clrevent(ev);
d2124 1
a2124 2
		if (DialDelay > 0 && firstconnect &&
		    bitnset(M_DIALDELAY, mci->mci_mailer->m_flags))
d2127 3
a2129 3
				sm_dprintf("Connect failed (%s); trying again...\n",
					   sm_errstring(save_errno));
			firstconnect = false;
d2137 1
a2137 1
		if (LogLevel > 13)
d2141 1
a2141 1
				  sm_errstring(save_errno));
d2143 1
a2143 5
#if NETINET6
nextaddr:
#endif /* NETINET6 */
		if (hp != NULL && hp->h_addr_list[addrno] != NULL &&
		    (enough == 0 || curtime() < enough))
d2146 2
a2147 2
				sm_dprintf("Connect failed (%s); trying new address....\n",
					   sm_errstring(save_errno));
d2150 1
a2150 1
#if NETINET
d2156 1
a2156 1
#endif /* NETINET */
d2158 1
a2158 1
#if NETINET6
d2164 1
a2164 1
#endif /* NETINET6 */
d2176 1
a2176 1
#if NETINET6
d2180 3
a2182 3
				sm_dprintf("Connect failed (%s); retrying with AF_INET....\n",
					   sm_errstring(save_errno));
			v6found = true;
d2184 1
d2190 1
d2194 1
a2194 1
#endif /* NETINET6 */
d2196 1
a2196 1
#if NETINET6
d2199 1
a2199 1
#endif /* NETINET6 */
d2202 2
a2203 3
			sm_dprintf("Connect failed (%s)\n",
				   sm_errstring(save_errno));
#if XLA
d2205 1
a2205 1
#endif /* XLA */
d2207 1
a2207 1
#if NETINET6
d2210 1
a2210 1
#endif /* NETINET6 */
d2215 1
a2215 1
#if NETINET6
d2221 1
a2221 1
#endif /* NETINET6 */
d2225 1
a2225 2
	if ((mci->mci_out = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT, (void *) s,
				       SM_IO_WRONLY, NULL)) == NULL ||
d2227 1
a2227 2
	    (mci->mci_in = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT, (void *) s,
				      SM_IO_RDONLY, NULL)) == NULL)
d2233 1
a2233 1
			(void) sm_io_close(mci->mci_out, SM_TIME_DEFAULT);
a2237 19
	sm_io_automode(mci->mci_out, mci->mci_in);

	/* set {client_flags} */
	if (ClientSettings[addr.sa.sa_family].d_mflags != NULL)
	{
		macdefine(&mci->mci_macro, A_PERM,
			  macid("{client_flags}"),
			  ClientSettings[addr.sa.sa_family].d_mflags);
	}
	else
		macdefine(&mci->mci_macro, A_PERM,
			  macid("{client_flags}"), "");

	/* "add" {client_flags} to bitmap */
	if (bitnset(D_IFNHELO, ClientSettings[addr.sa.sa_family].d_flags))
	{
		/* look for just this one flag */
		setbitn(D_IFNHELO, d_flags);
	}
d2244 1
a2244 1
		char family[5];
d2246 5
a2250 6
		macdefine(&BlankEnvelope.e_macro, A_TEMP,
			macid("{if_addr_out}"), anynet_ntoa(&addr));
		(void) sm_snprintf(family, sizeof(family), "%d",
			addr.sa.sa_family);
		macdefine(&BlankEnvelope.e_macro, A_TEMP,
			macid("{if_family_out}"), family);
d2253 1
a2253 2
		macdefine(&BlankEnvelope.e_macro, A_TEMP,
			macid("{if_name_out}"), name);
d2268 3
a2270 6
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			macid("{if_name_out}"), NULL);
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			macid("{if_addr_out}"), NULL);
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			macid("{if_family_out}"), NULL);
a2278 6
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

d2298 2
a2299 3
#if NETUNIX
int
makeconnection_ds(mux_path, mci)
d2327 1
a2327 2

		/* XXX why TEMPFAIL but 5.x.y ? */
d2332 1
a2332 2
	(void) sm_strlcpy(unix_addr.sun_path, mux_path,
			  sizeof unix_addr.sun_path);
d2359 3
a2361 7
	if ((mci->mci_out = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT,
				       (void *) sock, SM_IO_WRONLY, NULL))
					== NULL
	    || (sock = dup(sock)) < 0 ||
	    (mci->mci_in = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT,
				      (void *) sock, SM_IO_RDONLY, NULL))
					== NULL)
d2367 1
a2367 1
			(void) sm_io_close(mci->mci_out, SM_TIME_DEFAULT);
a2371 1
	sm_io_automode(mci->mci_out, mci->mci_in);
d2377 1
a2377 163
#endif /* NETUNIX */
/*
**  SHUTDOWN_DAEMON -- Performs a clean shutdown of the daemon
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		closes control socket, exits.
*/

void
shutdown_daemon()
{
	char *reason;

	sm_allsignals(true);

	reason = ShutdownRequest;
	ShutdownRequest = NULL;
	PendingSignal = 0;

	if (LogLevel > 79)
		sm_syslog(LOG_DEBUG, CurEnv->e_id, "interrupt (%s)",
			  reason == NULL ? "implicit call" : reason);

	FileName = NULL;
	closecontrolsocket(true);
#if XLA
	xla_all_end();
#endif /* XLA */

	finis(false, EX_OK);
}
/*
**  RESTART_DAEMON -- Performs a clean restart of the daemon
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		restarts the daemon or exits if restart fails.
*/

/* Make a non-DFL/IGN signal a noop */
#define SM_NOOP_SIGNAL(sig, old)				\
do								\
{								\
	(old) = sm_signal((sig), sm_signal_noop);		\
	if ((old) == SIG_IGN || (old) == SIG_DFL)		\
		(void) sm_signal((sig), (old));			\
} while (0)

void
restart_daemon()
{
	bool drop;
	int i;
	int save_errno;
	char *reason;
	sigfunc_t ignore, oalrm, ousr1;
	extern int DtableSize;

	/* clear the events to turn off SIGALRMs */
	sm_clear_events();
	sm_allsignals(true);

	reason = RestartRequest;
	RestartRequest = NULL;
	PendingSignal = 0;

	if (SaveArgv[0][0] != '/')
	{
		if (LogLevel > 3)
			sm_syslog(LOG_INFO, NOQID,
				  "could not restart: need full path");
		finis(false, EX_OSFILE);
		/* NOTREACHED */
	}
	if (LogLevel > 3)
		sm_syslog(LOG_INFO, NOQID, "restarting %s due to %s",
			  SaveArgv[0],
			  reason == NULL ? "implicit call" : reason);

	closecontrolsocket(true);

	/*
	**  Want to drop to the user who started the process in all cases
	**  *but* when running as "smmsp" for the clientmqueue queue run
	**  daemon.  In that case, UseMSP will be true, RunAsUid should not
	**  be root, and RealUid should be either 0 or RunAsUid.
	*/

	drop = !(UseMSP && RunAsUid != 0 &&
		 (RealUid == 0 || RealUid == RunAsUid));

	if (drop_privileges(drop) != EX_OK)
	{
		if (LogLevel > 0)
			sm_syslog(LOG_ALERT, NOQID,
				  "could not drop privileges: %s",
				  sm_errstring(errno));
		finis(false, EX_OSERR);
		/* NOTREACHED */
	}

	/* arrange for all the files to be closed */
	for (i = 3; i < DtableSize; i++)
	{
		register int j;

		if ((j = fcntl(i, F_GETFD, 0)) != -1)
			(void) fcntl(i, F_SETFD, j | FD_CLOEXEC);
	}
#if SM_CONF_SHM
	cleanup_shm(DaemonPid == getpid());
#endif /* SM_CONF_SHM */

	/*
	**  Need to allow signals before execve() to make them "harmless".
	**  However, the default action can be "terminate", so it isn't
	**  really harmless.  Setting signals to IGN will cause them to be
	**  ignored in the new process to, so that isn't a good alternative.
	*/

	SM_NOOP_SIGNAL(SIGALRM, oalrm);
	SM_NOOP_SIGNAL(SIGCHLD, ignore);
	SM_NOOP_SIGNAL(SIGHUP, ignore);
	SM_NOOP_SIGNAL(SIGINT, ignore);
	SM_NOOP_SIGNAL(SIGPIPE, ignore);
	SM_NOOP_SIGNAL(SIGTERM, ignore);
#ifdef SIGUSR1
	SM_NOOP_SIGNAL(SIGUSR1, ousr1);
#endif /* SIGUSR1 */
	sm_allsignals(false);

	(void) execve(SaveArgv[0], (ARGV_T) SaveArgv, (ARGV_T) ExternalEnviron);
	save_errno = errno;

	/* block signals again and restore needed signals */
	sm_allsignals(true);

	/* For finis() events */
	(void) sm_signal(SIGALRM, oalrm);

#ifdef SIGUSR1
	/* For debugging finis() */
	(void) sm_signal(SIGUSR1, ousr1);
#endif /* SIGUSR1 */

	errno = save_errno;
	if (LogLevel > 0)
		sm_syslog(LOG_ALERT, NOQID, "could not exec %s: %s",
			  SaveArgv[0], sm_errstring(errno));
	finis(false, EX_OSFILE);
	/* NOTREACHED */
}
d2399 1
a2399 5
	if (gethostname(hostbuf, size) < 0 || hostbuf[0] == '\0')
		(void) sm_strlcpy(hostbuf, "localhost", size);
	hp = sm_gethostbyname(hostbuf, InetMode);
#if NETINET && NETINET6
	if (hp == NULL && InetMode == AF_INET6)
d2401 1
a2401 7
		/*
		**  It's possible that this IPv6 enabled machine doesn't
		**  actually have any IPv6 interfaces and, therefore, no
		**  IPv6 addresses.  Fall back to AF_INET.
		*/

		hp = sm_gethostbyname(hostbuf, AF_INET);
d2403 1
a2403 1
#endif /* NETINET && NETINET6 */
d2409 1
a2409 1
#if NETINFO
d2418 4
a2421 1
			(void) sm_strlcat2(hostbuf, ".", domainname, size);
d2423 1
a2423 1
#endif /* NETINFO */
d2455 1
a2455 1
	    !getcanonname(hostbuf, size, true, NULL))
d2463 1
a2463 1
		if (!getcanonname(hostbuf, size, true, NULL))
d2493 3
a2495 3
#if NETINET6
	unsigned char *a;
#endif /* NETINET6 */
d2499 1
a2499 1
#if NETINET
d2504 1
a2504 1
#endif /* NETINET */
d2506 1
a2506 1
#if NETINET6
d2508 1
a2508 1
		a = (unsigned char *) &sa->sin6.sin6_addr;
d2519 1
a2519 1
#endif /* NETINET6 */
d2530 1
a2530 1
**		may_be_forged -- an outage that is set to true if the
d2532 1
a2532 1
**			RealHostAddr; set to false if they do match.
a2542 7
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
d2551 1
a2551 1
	unsigned short SM_NONVOLATILE port = 0;
a2555 1
#ifndef NO_GETSERVBYNAME
a2556 7
# if NETINET
	static unsigned short port4 = 0;
# endif /* NETINET */
# if NETINET6
	static unsigned short port6 = 0;
# endif /* NETINET6 */
#endif /* ! NO_GETSERVBYNAME */
d2559 1
a2559 2
	size_t len;
	SM_EVENT *ev;
d2567 1
a2567 1
	*may_be_forged = false;
a2578 1

d2583 2
a2584 2
		(void) sm_strlcpyn(hbuf, sizeof hbuf, 2, RealUserName,
				   "@@localhost");
d2586 1
a2586 1
			sm_dprintf("getauthinfo: %s\n", hbuf);
d2595 1
a2595 1
			RealHostName[MAXNAME] = '\0'; /* XXX - 1 ? */
d2599 2
a2600 2
	if (anynet_ntoa(&RealHostAddr)[0] != '[' &&
	    RealHostName[0] != '[')
a2601 4
		int family;

		family = RealHostAddr.sa.sa_family;
#if NETINET6 && NEEDSGETIPNODE
d2603 2
a2604 10
		**  If RealHostAddr is an IPv6 connection with an
		**  IPv4-mapped address, we need RealHostName's IPv4
		**  address(es) for addrcmp() to compare against
		**  RealHostAddr.
		**
		**  Actually, we only need to do this for systems
		**  which NEEDSGETIPNODE since the real getipnodebyname()
		**  already does V4MAPPED address via the AI_V4MAPPEDCFG
		**  flag.  A better fix to this problem is to add this
		**  functionality to our stub getipnodebyname().
d2606 7
a2613 7
		if (family == AF_INET6 &&
		    IN6_IS_ADDR_V4MAPPED(&RealHostAddr.sin6.sin6_addr))
			family = AF_INET;
#endif /* NETINET6 && NEEDSGETIPNODE */

		/* try to match the reverse against the forward lookup */
		hp = sm_gethostbyname(RealHostName, family);
d2615 1
a2615 1
			*may_be_forged = true;
a2618 1
			{
a2620 1
			}
d2622 1
a2622 1
#if NETINET6
d2625 1
a2625 1
#endif /* NETINET6 */
d2635 1
a2635 1
#if NETINET
d2647 1
a2647 1
		(void) sm_snprintf(ibuf, sizeof ibuf, "%d,%d\r\n",
d2655 1
a2655 1
# ifdef NO_GETSERVBYNAME
d2657 6
a2662 22
# else /* NO_GETSERVBYNAME */

		/*
		**  getservbyname() consumes about 5% of the time
		**  when receiving a small message (almost all of the time
		**  spent in this routine).
		**  Hence we store the port in a static variable
		**  to save this time.
		**  The portnumber shouldn't change very often...
		**  This code makes the assumption that the port number
		**  is not 0.
		*/

		if (port4 == 0)
		{
			sp = getservbyname("auth", "tcp");
			if (sp != NULL)
				port4 = sp->s_port;
			else
				port4 = htons(113);
		}
		RealHostAddr.sin.sin_port = port4;
d2664 2
a2665 2
# endif /* NO_GETSERVBYNAME */
#endif /* NETINET */
d2667 1
a2667 1
#if NETINET6
d2679 1
a2679 1
		(void) sm_snprintf(ibuf, sizeof ibuf, "%d,%d\r\n",
d2687 1
a2687 1
# ifdef NO_GETSERVBYNAME
d2689 6
a2694 10
# else /* NO_GETSERVBYNAME */
		if (port6 == 0)
		{
			sp = getservbyname("auth", "tcp");
			if (sp != NULL)
				port6 = sp->s_port;
			else
				port6 = htons(113);
		}
		RealHostAddr.sin6.sin6_port = port6;
d2696 2
a2697 2
# endif /* NO_GETSERVBYNAME */
#endif /* NETINET6 */
d2712 1
a2712 1
	ev = sm_setevent(TimeOuts.to_ident, authtimeout, 0);
d2719 1
a2719 1
		sm_clrevent(ev);
d2724 1
d2726 1
d2729 1
a2729 1
		sm_dprintf("getauthinfo: sent %s", ibuf);
d2743 1
a2743 1
		if (strchr(ibuf, '\n') != NULL || nleft <= 0)
d2747 1
a2747 1
	sm_clrevent(ev);
d2756 1
a2756 1
		sm_dprintf("getauthinfo:  got %s\n", ibuf);
d2767 1
a2767 1
	if (sm_strncasecmp(p, "userid", 6) != 0)
d2806 1
a2806 1
	if (sm_strncasecmp(ostype, "other", 5) == 0 &&
d2809 1
a2809 1
		(void) sm_strlcpy(hbuf, "IDENT:", sizeof hbuf);
d2814 3
a2816 3
	len = strlen(hbuf);
	(void) sm_strlcpyn(&hbuf[len], sizeof hbuf - len, 2, "@@",
			   RealHostName == NULL ? "localhost" : RealHostName);
d2821 1
a2821 1
	sm_clrevent(ev);
d2827 1
a2827 1
#if NETINET
d2832 1
a2832 1
#endif /* NETINET */
d2834 1
a2834 1
#if NETINET6
d2839 1
a2839 1
#endif /* NETINET6 */
d2845 1
a2845 1
			sm_dprintf("getauthinfo: NULL\n");
d2848 1
a2848 1
	(void) sm_strlcpy(hbuf, RealHostName, sizeof hbuf);
d2851 4
a2854 4
#if IP_SRCROUTE
# ifndef GET_IPOPT_DST
#  define GET_IPOPT_DST(dst)	(dst)
# endif /* ! GET_IPOPT_DST */
d2872 2
a2873 2
		unsigned char *q;
		unsigned char *o;
d2883 2
a2884 2
		o = (unsigned char *) ipopt.IP_LIST;
		while (o != NULL && o < (unsigned char *) &ipopt + ipoptlen)
d2911 4
a2914 5
				(void) sm_snprintf(p, SPACELEFT(hbuf, p),
					" [%s@@%.*s",
					*o == IPOPT_SSRR ? "!" : "",
					l > 240 ? 120 : l / 2,
					inet_ntoa(GET_IPOPT_DST(ipopt.IP_DST)));
d2928 6
a2933 7
					(void) sm_snprintf(p,
						SPACELEFT(hbuf, p),
						"%c%.*s",
						j != 0 ? '@@' : ':',
						l > 240 ? 120 :
							j == 0 ? l : l / 2,
						inet_ntoa(addr));
d2948 1
a2948 1
		(void) sm_snprintf(p, SPACELEFT(hbuf, p), "]");
d2953 1
a2953 1
#endif /* IP_SRCROUTE */
d2957 2
a2958 2
		(void) sm_snprintf(p, SPACELEFT(hbuf, p), " [%.100s]",
				   anynet_ntoa(&RealHostAddr));
d2963 1
a2963 3
		(void) sm_strlcpy(p, " (may be forged)", SPACELEFT(hbuf, p));
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			  macid("{client_resolve}"), "FORGED");
d2966 1
a2966 1
#if IP_SRCROUTE
d2968 3
a2970 1
#endif /* IP_SRCROUTE */
d2975 1
a2975 1
#if NETINET
d2980 1
a2980 1
#endif /* NETINET */
d2982 1
a2982 1
#if NETINET6
d2987 1
a2987 1
#endif /* NETINET6 */
a2989 2
	if (tTd(9, 1))
		sm_dprintf("getauthinfo: %s\n", hbuf);
d3022 1
a3022 1
#if NETINET
d3024 2
a3025 2
#endif /* NETINET */
#if NETINET6
d3027 1
a3027 1
#endif /* NETINET6 */
a3029 5
	time_t now;
#if NAMED_BIND
	time_t SM_NONVOLATILE retrans = 0;
	int SM_NONVOLATILE retry = 0;
#endif /* NAMED_BIND */
d3034 1
a3034 1
	**  return it (unless expired).
a3036 1
	now = curtime();
d3038 1
a3038 2
	if (bitset(NCF_VALID, s->s_namecanon.nc_flags) &&
	    s->s_namecanon.nc_exp >= now)
d3041 3
a3043 3
			sm_dprintf("host_map_lookup(%s) => CACHE %s\n",
				    name,
				    s->s_namecanon.nc_cname == NULL
d3047 3
a3049 1
		SM_SET_H_ERRNO(s->s_namecanon.nc_herrno);
d3087 1
a3087 1
			sm_dprintf("host_map_lookup(%s) => DEFERRED\n", name);
d3100 1
a3100 16
		sm_dprintf("host_map_lookup(%s) => ", name);
#if NAMED_BIND
	if (map->map_timeout > 0)
	{
		retrans = _res.retrans;
		_res.retrans = map->map_timeout;
	}
	if (map->map_retry > 0)
	{
		retry = _res.retry;
		_res.retry = map->map_retry;
	}
#endif /* NAMED_BIND */

	/* set default TTL */
	s->s_namecanon.nc_exp = now + SM_DEFAULT_TTL;
d3103 2
a3104 5
		int ttl;

		(void) sm_strlcpy(hbuf, name, sizeof hbuf);
		if (getcanonname(hbuf, sizeof hbuf - 1, !HasWildcardMX, &ttl))
		{
a3105 4
			if (ttl > 0)
				s->s_namecanon.nc_exp = now + SM_MIN(ttl,
								SM_DEFAULT_TTL);
		}
d3112 1
a3112 1
				sm_dprintf("FAILED\n");
d3118 1
a3118 1
#if NETINET
d3122 2
a3123 2
#endif /* NETINET */
#if NETINET6
d3125 1
a3125 1
		    anynet_pton(AF_INET6, &name[1], &in6_addr) == 1)
d3128 1
a3128 1
#endif /* NETINET6 */
d3134 2
a3135 10
			ans = denlstring((char *) hp->h_name, true, true);
#if NETINET6
			if (ans == hp->h_name)
			{
				static char n[MAXNAME + 1];

				/* hp->h_name is about to disappear */
				(void) sm_strlcpy(n, ans, sizeof n);
				ans = n;
			}
d3138 1
a3138 1
#endif /* NETINET6 */
a3140 6
#if NAMED_BIND
	if (map->map_timeout > 0)
		_res.retrans = retrans;
	if (map->map_retry > 0)
		_res.retry = retry;
#endif /* NAMED_BIND */
d3148 1
a3148 3
		if (s->s_namecanon.nc_cname != NULL)
			sm_free(s->s_namecanon.nc_cname);
		s->s_namecanon.nc_cname = sm_strdup_x(ans);
d3154 1
a3154 1
			sm_dprintf("FOUND %s\n", ans);
d3161 1
a3161 1
#if NAMED_BIND
d3164 1
a3164 1
		sm_dprintf("FAIL (%d)\n", h_errno);
d3190 1
a3190 1
#else /* NAMED_BIND */
d3192 1
a3192 1
		sm_dprintf("FAIL\n");
d3194 1
a3194 1
#endif /* NAMED_BIND */
d3198 54
d3253 1
a3253 1
**  HOST_MAP_INIT -- initialize host class structures
d3256 4
a3259 2
**		map -- a pointer to this map.
**		args -- argument string.
d3262 72
a3333 1
**		true.
a3373 21

		  case 'd':
			{
				char *h;

				while (isascii(*++p) && isspace(*p))
					continue;
				h = strchr(p, ' ');
				if (h != NULL)
					*h = '\0';
				map->map_timeout = convtime(p, 's');
				if (h != NULL)
					*h = ' ';
			}
			break;

		  case 'r':
			while (isascii(*++p) && isspace(*p))
				continue;
			map->map_retry = atoi(p);
			break;
d3384 1
a3384 1
	return true;
a3398 1

a3411 13
	{
		char *d;
		size_t sz;

		/* Save pointer to beginning of string */
		d = dst;

		/* Add IPv6: protocol tag */
		sz = sm_strlcpy(dst, "IPv6:", dst_len);
		if (sz >= dst_len)
			return NULL;
		dst += sz;
		dst_len -= sz;
a3412 5

		/* Restore pointer to beginning of string */
		if (ap != NULL)
			ap = d;
	}
a3414 27

/*
**  ANYNET_PTON -- convert printed form to network address.
**
**	Wrapper for inet_pton() which handles IPv6: labels.
**
**	Parameters:
**		family -- address family
**		src -- string
**		dst -- destination address structure
**
**	Returns:
**		1 if the address was valid
**		0 if the address wasn't parseable
**		-1 if error
*/

int
anynet_pton(family, src, dst)
	int family;
	const char *src;
	void *dst;
{
	if (family == AF_INET6 && sm_strncasecmp(src, "IPv6:", 5) == 0)
		src += 5;
	return inet_pton(family, src, dst);
}
d3452 2
a3453 2
			(void) sm_snprintf(buf, sizeof buf, "[UNIX: %.64s]",
					   sap->sunix.sun_path);
d3455 1
a3455 1
			(void) sm_strlcpy(buf, "[UNIX: localhost]", sizeof buf);
d3474 2
a3475 2
		(void) sm_snprintf(buf, sizeof buf, "[LINK: %s]",
				   link_ntoa((struct sockaddr_dl *) &sap->sa));
d3485 1
a3485 1
	(void) sm_snprintf(buf, sizeof buf, "Family %d: ", sap->sa.sa_family);
d3490 1
a3490 2
		(void) sm_snprintf(bp, SPACELEFT(buf, bp), "%02x:",
				   *ap++ & 0377);
d3533 2
a3534 1
				      INADDRSZ, AF_INET);
d3541 2
a3542 1
				      IN6ADDRSZ, AF_INET6);
d3549 2
a3550 1
				      sizeof sap->siso.siso_addr, AF_ISO);
d3561 3
a3563 2
		hp = sm_gethostbyaddr(sap->sa.sa_data, sizeof sap->sa.sa_data,
				      sap->sa.sa_family);
d3583 3
a3585 2
		name = denlstring((char *) hp->h_name, true, true);
#  if NETINET6
d3591 1
a3591 1
			(void) sm_strlcpy(n, name, sizeof n);
d3594 1
d3596 1
a3596 1
#  endif /* NETINET6 */
d3601 1
a3601 1
# if NETINET6
d3607 1
a3607 1
# endif /* NETINET6 */
d3616 1
a3616 2
		(void) sm_snprintf(buf, sizeof buf, "[%.200s]",
				   anynet_ntoa(sap));
@


