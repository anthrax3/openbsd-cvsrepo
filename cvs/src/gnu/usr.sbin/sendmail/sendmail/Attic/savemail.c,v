head	1.20;
access;
symbols
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.16.0.6
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.4
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.15.0.18
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.16
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.12
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.14
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.10
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.8
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.6
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.4
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.6
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2014.09.17.18.49.52;	author matthieu;	state dead;
branches;
next	1.19;
commitid	M7i5giHIoz3DMlTU;

1.19
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.17;

1.17
date	2012.12.26.11.44.12;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2011.05.17.15.54.24;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2006.08.13.13.01.48;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.22.18.43.56;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.16.00.21.31;	author millert;	state Exp;
branches
	1.12.2.1
	1.12.4.1
	1.12.6.1;
next	1.11;

1.11
date	2004.06.24.03.59.27;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.01.19.59.23;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.03.17.25.47;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.01.17.18.30;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.11.19.02.50;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.29.01.31.16;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.28.02.43.55;	author millert;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.01.15.21.09.10;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.07.19.20.43;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.47;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.47;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.16;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.50;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.31.41;	author miod;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.31.01.47.58;	author jason;	state Exp;
branches;
next	;

1.12.2.1
date	2006.03.24.05.42.48;	author brad;	state Exp;
branches;
next	;

1.12.4.1
date	2006.03.24.05.56.18;	author brad;	state Exp;
branches;
next	;

1.12.6.1
date	2006.03.25.01.49.38;	author brad;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2003, 2006, 2012, 2013 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>

SM_RCSID("@@(#)$Sendmail: savemail.c,v 8.319 2013/11/22 20:51:56 ca Exp $")

static bool	errbody __P((MCI *, ENVELOPE *, char *));
static bool	pruneroute __P((char *));

/*
**  SAVEMAIL -- Save mail on error
**
**	If mailing back errors, mail it back to the originator
**	together with an error message; otherwise, just put it in
**	dead.letter in the user's home directory (if he exists on
**	this machine).
**
**	Parameters:
**		e -- the envelope containing the message in error.
**		sendbody -- if true, also send back the body of the
**			message; otherwise just send the header.
**
**	Returns:
**		true if savemail panic'ed, (i.e., the data file should
**		be preserved by dropenvelope())
**
**	Side Effects:
**		Saves the letter, by writing or mailing it back to the
**		sender, or by putting it in dead.letter in her home
**		directory.
*/

/* defines for state machine */
#define ESM_REPORT		0	/* report to sender's terminal */
#define ESM_MAIL		1	/* mail back to sender */
#define ESM_QUIET		2	/* mail has already been returned */
#define ESM_DEADLETTER		3	/* save in ~/dead.letter */
#define ESM_POSTMASTER		4	/* return to postmaster */
#define ESM_DEADLETTERDROP	5	/* save in DeadLetterDrop */
#define ESM_PANIC		6	/* call loseqfile() */
#define ESM_DONE		7	/* message is successfully delivered */

bool
savemail(e, sendbody)
	register ENVELOPE *e;
	bool sendbody;
{
	register SM_FILE_T *fp;
	bool panic = false;
	int state;
	auto ADDRESS *q = NULL;
	register char *p;
	MCI mcibuf;
	int flags;
	long sff;
	char buf[MAXLINE + 1];
	char dlbuf[MAXPATHLEN];
	SM_MBDB_T user;


	if (tTd(6, 1))
	{
		sm_dprintf("\nsavemail, errormode = %c, id = %s, ExitStat = %d\n  e_from=",
			e->e_errormode, e->e_id == NULL ? "NONE" : e->e_id,
			ExitStat);
		printaddr(sm_debug_file(), &e->e_from, false);
	}

	if (e->e_id == NULL)
	{
		/* can't return a message with no id */
		return panic;
	}

	/*
	**  In the unhappy event we don't know who to return the mail
	**  to, make someone up.
	*/

	if (e->e_from.q_paddr == NULL)
	{
		e->e_sender = "Postmaster";
		if (parseaddr(e->e_sender, &e->e_from,
			      RF_COPYPARSE|RF_SENDERADDR,
			      '\0', NULL, e, false) == NULL)
		{
			syserr("553 5.3.5 Cannot parse Postmaster!");
			finis(true, true, EX_SOFTWARE);
		}
	}
	e->e_to = NULL;

	/*
	**  Basic state machine.
	**
	**	This machine runs through the following states:
	**
	**	ESM_QUIET	Errors have already been printed iff the
	**			sender is local.
	**	ESM_REPORT	Report directly to the sender's terminal.
	**	ESM_MAIL	Mail response to the sender.
	**	ESM_DEADLETTER	Save response in ~/dead.letter.
	**	ESM_POSTMASTER	Mail response to the postmaster.
	**	ESM_DEADLETTERDROP
	**			If DeadLetterDrop set, save it there.
	**	ESM_PANIC	Save response anywhere possible.
	*/

	/* determine starting state */
	switch (e->e_errormode)
	{
	  case EM_WRITE:
		state = ESM_REPORT;
		break;

	  case EM_BERKNET:
	  case EM_MAIL:
		state = ESM_MAIL;
		break;

	  case EM_PRINT:
	  case '\0':
		state = ESM_QUIET;
		break;

	  case EM_QUIET:
		/* no need to return anything at all */
		return panic;

	  default:
		syserr("554 5.3.0 savemail: bogus errormode x%x",
		       e->e_errormode);
		state = ESM_MAIL;
		break;
	}

	/* if this is already an error response, send to postmaster */
	if (bitset(EF_RESPONSE, e->e_flags))
	{
		if (e->e_parent != NULL &&
		    bitset(EF_RESPONSE, e->e_parent->e_flags))
		{
			/* got an error sending a response -- can it */
			return panic;
		}
		state = ESM_POSTMASTER;
	}

	while (state != ESM_DONE)
	{
		if (tTd(6, 5))
			sm_dprintf("  state %d\n", state);

		switch (state)
		{
		  case ESM_QUIET:
			if (bitnset(M_LOCALMAILER, e->e_from.q_mailer->m_flags))
				state = ESM_DEADLETTER;
			else
				state = ESM_MAIL;
			break;

		  case ESM_REPORT:

			/*
			**  If the user is still logged in on the same terminal,
			**  then write the error messages back to hir (sic).
			*/

#if USE_TTYPATH
			p = ttypath();
#else /* USE_TTYPATH */
			p = NULL;
#endif /* USE_TTYPATH */

			if (p == NULL || sm_io_reopen(SmFtStdio,
						      SM_TIME_DEFAULT,
						      p, SM_IO_WRONLY, NULL,
						      smioout) == NULL)
			{
				state = ESM_MAIL;
				break;
			}

			expand("\201n", buf, sizeof(buf), e);
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "\r\nMessage from %s...\r\n", buf);
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Errors occurred while sending mail.\r\n");
			if (e->e_xfp != NULL)
			{
				(void) bfrewind(e->e_xfp);
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Transcript follows:\r\n");
				while (sm_io_fgets(e->e_xfp, SM_TIME_DEFAULT,
						   buf, sizeof(buf)) >= 0 &&
				       !sm_io_error(smioout))
					(void) sm_io_fputs(smioout,
							   SM_TIME_DEFAULT,
							   buf);
			}
			else
			{
				syserr("Cannot open %s",
				       queuename(e, XSCRPT_LETTER));
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Transcript of session is unavailable.\r\n");
			}
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Original message will be saved in dead.letter.\r\n");
			state = ESM_DEADLETTER;
			break;

		  case ESM_MAIL:
			/*
			**  If mailing back, do it.
			**	Throw away all further output.  Don't alias,
			**	since this could cause loops, e.g., if joe
			**	mails to joe@@x, and for some reason the network
			**	for @@x is down, then the response gets sent to
			**	joe@@x, which gives a response, etc.  Also force
			**	the mail to be delivered even if a version of
			**	it has already been sent to the sender.
			**
			**  If this is a configuration or local software
			**	error, send to the local postmaster as well,
			**	since the originator can't do anything
			**	about it anyway.  Note that this is a full
			**	copy of the message (intentionally) so that
			**	the Postmaster can forward things along.
			*/

			if (ExitStat == EX_CONFIG || ExitStat == EX_SOFTWARE)
			{
				(void) sendtolist("postmaster", NULLADDR,
						  &e->e_errorqueue, 0, e);
			}
			if (!emptyaddr(&e->e_from))
			{
				char from[TOBUFSIZE];

				if (sm_strlcpy(from, e->e_from.q_paddr,
						sizeof(from)) >= sizeof(from))
				{
					state = ESM_POSTMASTER;
					break;
				}

				if (!DontPruneRoutes)
					(void) pruneroute(from);

				(void) sendtolist(from, NULLADDR,
						  &e->e_errorqueue, 0, e);
			}

			/*
			**  Deliver a non-delivery report to the
			**  Postmaster-designate (not necessarily
			**  Postmaster).  This does not include the
			**  body of the message, for privacy reasons.
			**  You really shouldn't need this.
			*/

			e->e_flags |= EF_PM_NOTIFY;

			/* check to see if there are any good addresses */
			for (q = e->e_errorqueue; q != NULL; q = q->q_next)
			{
				if (QS_IS_SENDABLE(q->q_state))
					break;
			}
			if (q == NULL)
			{
				/* this is an error-error */
				state = ESM_POSTMASTER;
				break;
			}
			if (returntosender(e->e_message, e->e_errorqueue,
					   sendbody ? RTSF_SEND_BODY
						    : RTSF_NO_BODY,
					   e) == 0)
			{
				state = ESM_DONE;
				break;
			}

			/* didn't work -- return to postmaster */
			state = ESM_POSTMASTER;
			break;

		  case ESM_POSTMASTER:
			/*
			**  Similar to previous case, but to system postmaster.
			*/

			q = NULL;
			expand(DoubleBounceAddr, buf, sizeof(buf), e);

			/*
			**  Just drop it on the floor if DoubleBounceAddr
			**  expands to an empty string.
			*/

			if (*buf == '\0')
			{
				state = ESM_DONE;
				break;
			}
			if (sendtolist(buf, NULLADDR, &q, 0, e) <= 0)
			{
				syserr("553 5.3.0 cannot parse %s!", buf);
				ExitStat = EX_SOFTWARE;
				state = ESM_DEADLETTERDROP;
				break;
			}
			flags = RTSF_PM_BOUNCE;
			if (sendbody)
				flags |= RTSF_SEND_BODY;
			if (returntosender(e->e_message, q, flags, e) == 0)
			{
				state = ESM_DONE;
				break;
			}

			/* didn't work -- last resort */
			state = ESM_DEADLETTERDROP;
			break;

		  case ESM_DEADLETTER:
			/*
			**  Save the message in dead.letter.
			**	If we weren't mailing back, and the user is
			**	local, we should save the message in
			**	~/dead.letter so that the poor person doesn't
			**	have to type it over again -- and we all know
			**	what poor typists UNIX users are.
			*/

			p = NULL;
			if (bitnset(M_HASPWENT, e->e_from.q_mailer->m_flags))
			{
				if (e->e_from.q_home != NULL)
					p = e->e_from.q_home;
				else if (sm_mbdb_lookup(e->e_from.q_user, &user)
					 == EX_OK &&
					 *user.mbdb_homedir != '\0')
					p = user.mbdb_homedir;
			}
			if (p == NULL || e->e_dfp == NULL)
			{
				/* no local directory or no data file */
				state = ESM_MAIL;
				break;
			}

			/* we have a home directory; write dead.letter */
			macdefine(&e->e_macro, A_TEMP, 'z', p);

			/* get the sender for the UnixFromLine */
			p = macvalue('g', e);
			macdefine(&e->e_macro, A_PERM, 'g', e->e_sender);

			expand("\201z/dead.letter", dlbuf, sizeof(dlbuf), e);
			sff = SFF_CREAT|SFF_REGONLY|SFF_RUNASREALUID;
			if (RealUid == 0)
				sff |= SFF_ROOTOK;
			e->e_to = dlbuf;
			if (writable(dlbuf, NULL, sff) &&
			    mailfile(dlbuf, FileMailer, NULL, sff, e) == EX_OK)
			{
				int oldverb = Verbose;

				if (OpMode != MD_DAEMON && OpMode != MD_SMTP)
					Verbose = 1;
				if (Verbose > 0)
					message("Saved message in %s", dlbuf);
				Verbose = oldverb;
				macdefine(&e->e_macro, A_PERM, 'g', p);
				state = ESM_DONE;
				break;
			}
			macdefine(&e->e_macro, A_PERM, 'g', p);
			state = ESM_MAIL;
			break;

		  case ESM_DEADLETTERDROP:
			/*
			**  Log the mail in DeadLetterDrop file.
			*/

			if (e->e_class < 0)
			{
				state = ESM_DONE;
				break;
			}

			if ((SafeFileEnv != NULL && SafeFileEnv[0] != '\0') ||
			    DeadLetterDrop == NULL ||
			    DeadLetterDrop[0] == '\0')
			{
				state = ESM_PANIC;
				break;
			}

			sff = SFF_CREAT|SFF_REGONLY|SFF_ROOTOK|SFF_OPENASROOT|SFF_MUSTOWN;
			if (!writable(DeadLetterDrop, NULL, sff) ||
			    (fp = safefopen(DeadLetterDrop, O_WRONLY|O_APPEND,
					    FileMode, sff)) == NULL)
			{
				state = ESM_PANIC;
				break;
			}

			memset(&mcibuf, '\0', sizeof(mcibuf));
			mcibuf.mci_out = fp;
			mcibuf.mci_mailer = FileMailer;
			if (bitnset(M_7BITS, FileMailer->m_flags))
				mcibuf.mci_flags |= MCIF_7BIT;

			/* get the sender for the UnixFromLine */
			p = macvalue('g', e);
			macdefine(&e->e_macro, A_PERM, 'g', e->e_sender);

			if (!putfromline(&mcibuf, e) ||
			    !(*e->e_puthdr)(&mcibuf, e->e_header, e,
					M87F_OUTER) ||
			    !(*e->e_putbody)(&mcibuf, e, NULL) ||
			    !putline("\n", &mcibuf) ||
			    sm_io_flush(fp, SM_TIME_DEFAULT) == SM_IO_EOF ||
			    sm_io_error(fp) ||
			    sm_io_close(fp, SM_TIME_DEFAULT) < 0)
				state = ESM_PANIC;
			else
			{
				int oldverb = Verbose;

				if (OpMode != MD_DAEMON && OpMode != MD_SMTP)
					Verbose = 1;
				if (Verbose > 0)
					message("Saved message in %s",
						DeadLetterDrop);
				Verbose = oldverb;
				if (LogLevel > 3)
					sm_syslog(LOG_NOTICE, e->e_id,
						  "Saved message in %s",
						  DeadLetterDrop);
				state = ESM_DONE;
			}
			macdefine(&e->e_macro, A_PERM, 'g', p);
			break;

		  default:
			syserr("554 5.3.5 savemail: unknown state %d", state);
			/* FALLTHROUGH */

		  case ESM_PANIC:
			/* leave the locked queue & transcript files around */
			loseqfile(e, "savemail panic");
			panic = true;
			errno = 0;
			syserr("554 savemail: cannot save rejected email anywhere");
			state = ESM_DONE;
			break;
		}
	}
	return panic;
}
/*
**  RETURNTOSENDER -- return a message to the sender with an error.
**
**	Parameters:
**		msg -- the explanatory message.
**		returnq -- the queue of people to send the message to.
**		flags -- flags tweaking the operation:
**			RTSF_SENDBODY -- include body of message (otherwise
**				just send the header).
**			RTSF_PMBOUNCE -- this is a postmaster bounce.
**		e -- the current envelope.
**
**	Returns:
**		zero -- if everything went ok.
**		else -- some error.
**
**	Side Effects:
**		Returns the current message to the sender via mail.
*/

#define MAXRETURNS	6	/* max depth of returning messages */
#define ERRORFUDGE	1024	/* nominal size of error message text */

int
returntosender(msg, returnq, flags, e)
	char *msg;
	ADDRESS *returnq;
	int flags;
	register ENVELOPE *e;
{
	int ret;
	register ENVELOPE *ee;
	ENVELOPE *oldcur = CurEnv;
	ENVELOPE errenvelope;
	static int returndepth = 0;
	register ADDRESS *q;
	char *p;
	char buf[MAXNAME + 1];

	if (returnq == NULL)
		return -1;

	if (msg == NULL)
		msg = "Unable to deliver mail";

	if (tTd(6, 1))
	{
		sm_dprintf("\n*** Return To Sender: msg=\"%s\", depth=%d, e=%p, returnq=",
			msg, returndepth, e);
		printaddr(sm_debug_file(), returnq, true);
		if (tTd(6, 20))
		{
			sm_dprintf("Sendq=");
			printaddr(sm_debug_file(), e->e_sendqueue, true);
		}
	}

	if (++returndepth >= MAXRETURNS)
	{
		if (returndepth != MAXRETURNS)
			syserr("554 5.3.0 returntosender: infinite recursion on %s",
			       returnq->q_paddr);
		/* don't "unrecurse" and fake a clean exit */
		/* returndepth--; */
		return 0;
	}

	macdefine(&e->e_macro, A_PERM, 'g', e->e_sender);
	macdefine(&e->e_macro, A_PERM, 'u', NULL);

	/* initialize error envelope */
	ee = newenvelope(&errenvelope, e, sm_rpool_new_x(NULL));
	macdefine(&ee->e_macro, A_PERM, 'a', "\201b");
	macdefine(&ee->e_macro, A_PERM, 'r', "");
	macdefine(&ee->e_macro, A_PERM, 's', "localhost");
	macdefine(&ee->e_macro, A_PERM, '_', "localhost");
	clrsessenvelope(ee);

	ee->e_puthdr = putheader;
	ee->e_putbody = errbody;
	ee->e_flags |= EF_RESPONSE|EF_METOO;
	if (!bitset(EF_OLDSTYLE, e->e_flags))
		ee->e_flags &= ~EF_OLDSTYLE;
	if (bitset(EF_DONT_MIME, e->e_flags))
	{
		ee->e_flags |= EF_DONT_MIME;

		/*
		**  If we can't convert to MIME and we don't pass
		**  8-bit, we can't send the body.
		*/

		if (bitset(EF_HAS8BIT, e->e_flags) &&
		    !bitset(MM_PASS8BIT, MimeMode))
			flags &= ~RTSF_SEND_BODY;
	}

	ee->e_sendqueue = returnq;
	ee->e_msgsize = 0;
	if (bitset(RTSF_SEND_BODY, flags) &&
	    !bitset(PRIV_NOBODYRETN, PrivacyFlags))
		ee->e_msgsize = ERRORFUDGE + e->e_msgsize;
	else
		ee->e_flags |= EF_NO_BODY_RETN;

	if (!setnewqueue(ee))
	{
		syserr("554 5.3.0 returntosender: cannot select queue for %s",
			       returnq->q_paddr);
		ExitStat = EX_UNAVAILABLE;
		returndepth--;
		return -1;
	}
	initsys(ee);

#if NAMED_BIND
	_res.retry = TimeOuts.res_retry[RES_TO_FIRST];
	_res.retrans = TimeOuts.res_retrans[RES_TO_FIRST];
#endif /* NAMED_BIND */
	for (q = returnq; q != NULL; q = q->q_next)
	{
		if (QS_IS_BADADDR(q->q_state))
			continue;

		q->q_flags &= ~(QHASNOTIFY|Q_PINGFLAGS);
		q->q_flags |= QPINGONFAILURE;

		if (!QS_IS_DEAD(q->q_state))
			ee->e_nrcpts++;

		if (q->q_alias == NULL)
			addheader("To", q->q_paddr, 0, ee, true);
	}

	if (LogLevel > 5)
	{
		if (bitset(EF_RESPONSE, e->e_flags))
			p = "return to sender";
		else if (bitset(EF_WARNING, e->e_flags))
			p = "sender notify";
		else if (bitset(RTSF_PM_BOUNCE, flags))
			p = "postmaster notify";
		else
			p = "DSN";
		sm_syslog(LOG_INFO, e->e_id, "%s: %s: %s",
			  ee->e_id, p, shortenstring(msg, MAXSHORTSTR));
	}

	if (SendMIMEErrors)
	{
		addheader("MIME-Version", "1.0", 0, ee, true);
		(void) sm_snprintf(buf, sizeof(buf), "%s.%ld/%.100s",
				ee->e_id, (long)curtime(), MyHostName);
		ee->e_msgboundary = sm_rpool_strdup_x(ee->e_rpool, buf);
		(void) sm_snprintf(buf, sizeof(buf),
#if DSN
				"multipart/report; report-type=delivery-status;\n\tboundary=\"%s\"",
#else /* DSN */
				"multipart/mixed; boundary=\"%s\"",
#endif /* DSN */
				ee->e_msgboundary);
		addheader("Content-Type", buf, 0, ee, true);

		p = hvalue("Content-Transfer-Encoding", e->e_header);
		if (p != NULL && sm_strcasecmp(p, "binary") != 0)
			p = NULL;
		if (p == NULL && bitset(EF_HAS8BIT, e->e_flags))
			p = "8bit";
		if (p != NULL)
			addheader("Content-Transfer-Encoding", p, 0, ee, true);
	}
	if (strncmp(msg, "Warning:", 8) == 0)
	{
		addheader("Subject", msg, 0, ee, true);
		p = "warning-timeout";
	}
	else if (strncmp(msg, "Postmaster warning:", 19) == 0)
	{
		addheader("Subject", msg, 0, ee, true);
		p = "postmaster-warning";
	}
	else if (strcmp(msg, "Return receipt") == 0)
	{
		addheader("Subject", msg, 0, ee, true);
		p = "return-receipt";
	}
	else if (bitset(RTSF_PM_BOUNCE, flags))
	{
		(void) sm_snprintf(buf, sizeof(buf),
			 "Postmaster notify: see transcript for details");
		addheader("Subject", buf, 0, ee, true);
		p = "postmaster-notification";
	}
	else
	{
		(void) sm_snprintf(buf, sizeof(buf),
			 "Returned mail: see transcript for details");
		addheader("Subject", buf, 0, ee, true);
		p = "failure";
	}
	(void) sm_snprintf(buf, sizeof(buf), "auto-generated (%s)", p);
	addheader("Auto-Submitted", buf, 0, ee, true);

	/* fake up an address header for the from person */
	expand("\201n", buf, sizeof(buf), e);
	if (parseaddr(buf, &ee->e_from,
		      RF_COPYALL|RF_SENDERADDR, '\0', NULL, e, false) == NULL)
	{
		syserr("553 5.3.5 Can't parse myself!");
		ExitStat = EX_SOFTWARE;
		returndepth--;
		return -1;
	}
	ee->e_from.q_flags &= ~(QHASNOTIFY|Q_PINGFLAGS);
	ee->e_from.q_flags |= QPINGONFAILURE;
	ee->e_sender = ee->e_from.q_paddr;

	/* push state into submessage */
	CurEnv = ee;
	macdefine(&ee->e_macro, A_PERM, 'f', "\201n");
	macdefine(&ee->e_macro, A_PERM, 'x', "Mail Delivery Subsystem");
	eatheader(ee, true, true);

	/* mark statistics */
	markstats(ee, NULLADDR, STATS_NORMAL);

	/* actually deliver the error message */
	sendall(ee, SM_DELIVER);
	(void) dropenvelope(ee, true, false);

	/* check for delivery errors */
	ret = -1;
	if (ee->e_parent == NULL ||
	    !bitset(EF_RESPONSE, ee->e_parent->e_flags))
	{
		ret = 0;
	}
	else
	{
		for (q = ee->e_sendqueue; q != NULL; q = q->q_next)
		{
			if (QS_IS_ATTEMPTED(q->q_state))
			{
				ret = 0;
				break;
			}
		}
	}

	/* restore state */
	sm_rpool_free(ee->e_rpool);
	CurEnv = oldcur;
	returndepth--;

	return ret;
}

/*
**  ERRBODY -- output the body of an error message.
**
**	Typically this is a copy of the transcript plus a copy of the
**	original offending message.
**
**	Parameters:
**		mci -- the mailer connection information.
**		e -- the envelope we are working in.
**		separator -- any possible MIME separator (unused).
**
**	Returns:
**		true iff body was written successfully
**
**	Side Effects:
**		Outputs the body of an error message.
*/

/* ARGSUSED2 */
static bool
errbody(mci, e, separator)
	register MCI *mci;
	register ENVELOPE *e;
	char *separator;
{
	bool printheader;
	bool sendbody;
	bool pm_notify;
	int save_errno;
	register SM_FILE_T *xfile;
	char *p;
	register ADDRESS *q = NULL;
	char actual[MAXLINE];
	char buf[MAXLINE];

	if (bitset(MCIF_INHEADER, mci->mci_flags))
	{
		if (!putline("", mci))
			goto writeerr;
		mci->mci_flags &= ~MCIF_INHEADER;
	}
	if (e->e_parent == NULL)
	{
		syserr("errbody: null parent");
		if (!putline("   ----- Original message lost -----\n", mci))
			goto writeerr;
		return true;
	}

	/*
	**  Output MIME header.
	*/

	if (e->e_msgboundary != NULL)
	{
		(void) sm_strlcpyn(buf, sizeof(buf), 2, "--", e->e_msgboundary);
		if (!putline("This is a MIME-encapsulated message", mci) ||
		    !putline("", mci) ||
		    !putline(buf, mci) ||
		    !putline("", mci))
			goto writeerr;
	}

	/*
	**  Output introductory information.
	*/

	pm_notify = false;
	p = hvalue("subject", e->e_header);
	if (p != NULL && strncmp(p, "Postmaster ", 11) == 0)
		pm_notify = true;
	else
	{
		for (q = e->e_parent->e_sendqueue; q != NULL; q = q->q_next)
		{
			if (QS_IS_BADADDR(q->q_state))
				break;
		}
	}
	if (!pm_notify && q == NULL &&
	    !bitset(EF_FATALERRS|EF_SENDRECEIPT, e->e_parent->e_flags))
	{
		if (!putline("    **********************************************",
			mci) ||
		    !putline("    **      THIS IS A WARNING MESSAGE ONLY      **",
			mci) ||
		    !putline("    **  YOU DO NOT NEED TO RESEND YOUR MESSAGE  **",
			mci) ||
		    !putline("    **********************************************",
			mci) ||
		    !putline("", mci))
			goto writeerr;
	}
	(void) sm_snprintf(buf, sizeof(buf),
		"The original message was received at %s",
		arpadate(ctime(&e->e_parent->e_ctime)));
	if (!putline(buf, mci))
		goto writeerr;
	expand("from \201_", buf, sizeof(buf), e->e_parent);
	if (!putline(buf, mci))
		goto writeerr;

	/* include id in postmaster copies */
	if (pm_notify && e->e_parent->e_id != NULL)
	{
		(void) sm_strlcpyn(buf, sizeof(buf), 2, "with id ",
			e->e_parent->e_id);
		if (!putline(buf, mci))
			goto writeerr;
	}
	if (!putline("", mci))
		goto writeerr;

	/*
	**  Output error message header (if specified and available).
	*/

	if (ErrMsgFile != NULL &&
	    !bitset(EF_SENDRECEIPT, e->e_parent->e_flags))
	{
		if (*ErrMsgFile == '/')
		{
			long sff = SFF_ROOTOK|SFF_REGONLY;

			if (DontLockReadFiles)
				sff |= SFF_NOLOCK;
			if (!bitnset(DBS_ERRORHEADERINUNSAFEDIRPATH,
				     DontBlameSendmail))
				sff |= SFF_SAFEDIRPATH;
			xfile = safefopen(ErrMsgFile, O_RDONLY, 0444, sff);
			if (xfile != NULL)
			{
				while (sm_io_fgets(xfile, SM_TIME_DEFAULT, buf,
						   sizeof(buf)) >= 0)
				{
					int lbs;
					bool putok;
					char *lbp;

					lbs = sizeof(buf);
					lbp = translate_dollars(buf, buf, &lbs);
					expand(lbp, lbp, lbs, e);
					putok = putline(lbp, mci);
					if (lbp != buf)
						sm_free(lbp);
					if (!putok)
						goto writeerr;
				}
				(void) sm_io_close(xfile, SM_TIME_DEFAULT);
				if (!putline("\n", mci))
					goto writeerr;
			}
		}
		else
		{
			expand(ErrMsgFile, buf, sizeof(buf), e);
			if (!putline(buf, mci) || !putline("", mci))
				goto writeerr;
		}
	}

	/*
	**  Output message introduction
	*/

	/* permanent fatal errors */
	printheader = true;
	for (q = e->e_parent->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (!QS_IS_BADADDR(q->q_state) ||
		    !bitset(QPINGONFAILURE, q->q_flags))
			continue;

		if (printheader)
		{
			if (!putline("   ----- The following addresses had permanent fatal errors -----",
					mci))
				goto writeerr;
			printheader = false;
		}

		(void) sm_strlcpy(buf, shortenstring(q->q_paddr, MAXSHORTSTR),
				  sizeof(buf));
		if (!putline(buf, mci))
			goto writeerr;
		if (q->q_rstatus != NULL)
		{
			(void) sm_snprintf(buf, sizeof(buf),
				"    (reason: %s)",
				shortenstring(exitstat(q->q_rstatus),
					      MAXSHORTSTR));
			if (!putline(buf, mci))
				goto writeerr;
		}
		if (q->q_alias != NULL)
		{
			(void) sm_snprintf(buf, sizeof(buf),
				"    (expanded from: %s)",
				shortenstring(q->q_alias->q_paddr,
					      MAXSHORTSTR));
			if (!putline(buf, mci))
				goto writeerr;
		}
	}
	if (!printheader && !putline("", mci))
		goto writeerr;

	/* transient non-fatal errors */
	printheader = true;
	for (q = e->e_parent->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (QS_IS_BADADDR(q->q_state) ||
		    !bitset(QPRIMARY, q->q_flags) ||
		    !bitset(QBYNDELAY, q->q_flags) ||
		    !bitset(QDELAYED, q->q_flags))
			continue;

		if (printheader)
		{
			if (!putline("   ----- The following addresses had transient non-fatal errors -----",
					mci))
				goto writeerr;
			printheader = false;
		}

		(void) sm_strlcpy(buf, shortenstring(q->q_paddr, MAXSHORTSTR),
				  sizeof(buf));
		if (!putline(buf, mci))
			goto writeerr;
		if (q->q_alias != NULL)
		{
			(void) sm_snprintf(buf, sizeof(buf),
				"    (expanded from: %s)",
				shortenstring(q->q_alias->q_paddr,
					      MAXSHORTSTR));
			if (!putline(buf, mci))
				goto writeerr;
		}
	}
	if (!printheader && !putline("", mci))
		goto writeerr;

	/* successful delivery notifications */
	printheader = true;
	for (q = e->e_parent->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (QS_IS_BADADDR(q->q_state) ||
		    !bitset(QPRIMARY, q->q_flags) ||
		    bitset(QBYNDELAY, q->q_flags) ||
		    bitset(QDELAYED, q->q_flags))
			continue;
		else if (bitset(QBYNRELAY, q->q_flags))
			p = "Deliver-By notify: relayed";
		else if (bitset(QBYTRACE, q->q_flags))
			p = "Deliver-By trace: relayed";
		else if (!bitset(QPINGONSUCCESS, q->q_flags))
			continue;
		else if (bitset(QRELAYED, q->q_flags))
			p = "relayed to non-DSN-aware mailer";
		else if (bitset(QDELIVERED, q->q_flags))
		{
			if (bitset(QEXPANDED, q->q_flags))
				p = "successfully delivered to mailing list";
			else
				p = "successfully delivered to mailbox";
		}
		else if (bitset(QEXPANDED, q->q_flags))
			p = "expanded by alias";
		else
			continue;

		if (printheader)
		{
			if (!putline("   ----- The following addresses had successful delivery notifications -----",
					mci))
				goto writeerr;
			printheader = false;
		}

		(void) sm_snprintf(buf, sizeof(buf), "%s  (%s)",
			 shortenstring(q->q_paddr, MAXSHORTSTR), p);
		if (!putline(buf, mci))
			goto writeerr;
		if (q->q_alias != NULL)
		{
			(void) sm_snprintf(buf, sizeof(buf),
				"    (expanded from: %s)",
				shortenstring(q->q_alias->q_paddr,
					      MAXSHORTSTR));
			if (!putline(buf, mci))
				goto writeerr;
		}
	}
	if (!printheader && !putline("", mci))
		goto writeerr;

	/*
	**  Output transcript of errors
	*/

	(void) sm_io_flush(smioout, SM_TIME_DEFAULT);
	if (e->e_parent->e_xfp == NULL)
	{
		if (!putline("   ----- Transcript of session is unavailable -----\n",
				mci))
			goto writeerr;
	}
	else
	{
		int blen;

		printheader = true;
		(void) bfrewind(e->e_parent->e_xfp);
		if (e->e_xfp != NULL)
			(void) sm_io_flush(e->e_xfp, SM_TIME_DEFAULT);
		while ((blen = sm_io_fgets(e->e_parent->e_xfp, SM_TIME_DEFAULT,
					buf, sizeof(buf))) >= 0)
		{
			if (printheader && !putline("   ----- Transcript of session follows -----\n",
						mci))
				goto writeerr;
			printheader = false;
			if (!putxline(buf, blen, mci, PXLF_MAPFROM))
				goto writeerr;
		}
	}
	errno = 0;

#if DSN
	/*
	**  Output machine-readable version.
	*/

	if (e->e_msgboundary != NULL)
	{
		(void) sm_strlcpyn(buf, sizeof(buf), 2, "--", e->e_msgboundary);
		if (!putline("", mci) ||
		    !putline(buf, mci) ||
		    !putline("Content-Type: message/delivery-status", mci) ||
		    !putline("", mci))
			goto writeerr;

		/*
		**  Output per-message information.
		*/

		/* original envelope id from MAIL FROM: line */
		if (e->e_parent->e_envid != NULL)
		{
			(void) sm_snprintf(buf, sizeof(buf),
					"Original-Envelope-Id: %.800s",
					xuntextify(e->e_parent->e_envid));
			if (!putline(buf, mci))
				goto writeerr;
		}

		/* Reporting-MTA: is us (required) */
		(void) sm_snprintf(buf, sizeof(buf),
				   "Reporting-MTA: dns; %.800s", MyHostName);
		if (!putline(buf, mci))
			goto writeerr;

		/* DSN-Gateway: not relevant since we are not translating */

		/* Received-From-MTA: shows where we got this message from */
		if (RealHostName != NULL)
		{
			/* XXX use $s for type? */
			if (e->e_parent->e_from.q_mailer == NULL ||
			    (p = e->e_parent->e_from.q_mailer->m_mtatype) == NULL)
				p = "dns";
			(void) sm_snprintf(buf, sizeof(buf),
					"Received-From-MTA: %s; %.800s",
					p, RealHostName);
			if (!putline(buf, mci))
				goto writeerr;
		}

		/* Arrival-Date: -- when it arrived here */
		(void) sm_strlcpyn(buf, sizeof(buf), 2, "Arrival-Date: ",
				arpadate(ctime(&e->e_parent->e_ctime)));
		if (!putline(buf, mci))
			goto writeerr;

		/* Deliver-By-Date: -- when it should have been delivered */
		if (IS_DLVR_BY(e->e_parent))
		{
			time_t dbyd;

			dbyd = e->e_parent->e_ctime + e->e_parent->e_deliver_by;
			(void) sm_strlcpyn(buf, sizeof(buf), 2,
					"Deliver-By-Date: ",
					arpadate(ctime(&dbyd)));
			if (!putline(buf, mci))
				goto writeerr;
		}

		/*
		**  Output per-address information.
		*/

		for (q = e->e_parent->e_sendqueue; q != NULL; q = q->q_next)
		{
			char *action;

			if (QS_IS_BADADDR(q->q_state))
			{
				/* RFC 1891, 6.2.6 (b) */
				if (bitset(QHASNOTIFY, q->q_flags) &&
				    !bitset(QPINGONFAILURE, q->q_flags))
					continue;
				action = "failed";
			}
			else if (!bitset(QPRIMARY, q->q_flags))
				continue;
			else if (bitset(QDELIVERED, q->q_flags))
			{
				if (bitset(QEXPANDED, q->q_flags))
					action = "delivered (to mailing list)";
				else
					action = "delivered (to mailbox)";
			}
			else if (bitset(QRELAYED, q->q_flags))
				action = "relayed (to non-DSN-aware mailer)";
			else if (bitset(QEXPANDED, q->q_flags))
				action = "expanded (to multi-recipient alias)";
			else if (bitset(QDELAYED, q->q_flags))
				action = "delayed";
			else if (bitset(QBYTRACE, q->q_flags))
				action = "relayed (Deliver-By trace mode)";
			else if (bitset(QBYNDELAY, q->q_flags))
				action = "delayed (Deliver-By notify mode)";
			else if (bitset(QBYNRELAY, q->q_flags))
				action = "relayed (Deliver-By notify mode)";
			else
				continue;

			if (!putline("", mci))
				goto writeerr;

			/* Original-Recipient: -- passed from on high */
			if (q->q_orcpt != NULL)
			{
				p = strchr(q->q_orcpt, ';');

				/*
				**  p == NULL shouldn't happen due to
				**  check in srvrsmtp.c
				**  we could log an error in this case.
				*/

				if (p != NULL)
				{
					*p = '\0';
					(void) sm_snprintf(buf, sizeof(buf),
						"Original-Recipient: %.100s;%.700s",
						q->q_orcpt, xuntextify(p + 1));
					*p = ';';
					if (!putline(buf, mci))
						goto writeerr;
				}
			}

			/* Figure out actual recipient */
			actual[0] = '\0';
			if (q->q_user[0] != '\0')
			{
				if (q->q_mailer != NULL &&
				    q->q_mailer->m_addrtype != NULL)
					p = q->q_mailer->m_addrtype;
				else
					p = "rfc822";

				if (sm_strcasecmp(p, "rfc822") == 0 &&
				    strchr(q->q_user, '@@') == NULL)
				{
					(void) sm_snprintf(actual,
							   sizeof(actual),
							   "%s; %.700s@@%.100s",
							   p, q->q_user,
							   MyHostName);
				}
				else
				{
					(void) sm_snprintf(actual,
							   sizeof(actual),
							   "%s; %.800s",
							   p, q->q_user);
				}
			}

			/* Final-Recipient: -- the name from the RCPT command */
			if (q->q_finalrcpt == NULL)
			{
				/* should never happen */
				sm_syslog(LOG_ERR, e->e_id,
					  "returntosender: q_finalrcpt is NULL");

				/* try to fall back to the actual recipient */
				if (actual[0] != '\0')
					q->q_finalrcpt = sm_rpool_strdup_x(e->e_rpool,
									   actual);
			}

			if (q->q_finalrcpt != NULL)
			{
				(void) sm_snprintf(buf, sizeof(buf),
						   "Final-Recipient: %s",
						   q->q_finalrcpt);
				if (!putline(buf, mci))
					goto writeerr;
			}

			/* X-Actual-Recipient: -- the real problem address */
			if (actual[0] != '\0' &&
			    q->q_finalrcpt != NULL &&
			    !bitset(PRIV_NOACTUALRECIPIENT, PrivacyFlags) &&
			    strcmp(actual, q->q_finalrcpt) != 0)
			{
				(void) sm_snprintf(buf, sizeof(buf),
						   "X-Actual-Recipient: %s",
						   actual);
				if (!putline(buf, mci))
					goto writeerr;
			}

			/* Action: -- what happened? */
			(void) sm_strlcpyn(buf, sizeof(buf), 2, "Action: ",
				action);
			if (!putline(buf, mci))
				goto writeerr;

			/* Status: -- what _really_ happened? */
			if (q->q_status != NULL)
				p = q->q_status;
			else if (QS_IS_BADADDR(q->q_state))
				p = "5.0.0";
			else if (QS_IS_QUEUEUP(q->q_state))
				p = "4.0.0";
			else
				p = "2.0.0";
			(void) sm_strlcpyn(buf, sizeof(buf), 2, "Status: ", p);
			if (!putline(buf, mci))
				goto writeerr;

			/* Remote-MTA: -- who was I talking to? */
			if (q->q_statmta != NULL)
			{
				if (q->q_mailer == NULL ||
				    (p = q->q_mailer->m_mtatype) == NULL)
					p = "dns";
				(void) sm_snprintf(buf, sizeof(buf),
						"Remote-MTA: %s; %.800s",
						p, q->q_statmta);
				p = &buf[strlen(buf) - 1];
				if (*p == '.')
					*p = '\0';
				if (!putline(buf, mci))
					goto writeerr;
			}

			/* Diagnostic-Code: -- actual result from other end */
			if (q->q_rstatus != NULL)
			{
				if (q->q_mailer == NULL ||
				    (p = q->q_mailer->m_diagtype) == NULL)
					p = "smtp";
				(void) sm_snprintf(buf, sizeof(buf),
						"Diagnostic-Code: %s; %.800s",
						p, q->q_rstatus);
				if (!putline(buf, mci))
					goto writeerr;
			}

			/* Last-Attempt-Date: -- fine granularity */
			if (q->q_statdate == (time_t) 0L)
				q->q_statdate = curtime();
			(void) sm_strlcpyn(buf, sizeof(buf), 2,
					"Last-Attempt-Date: ",
					arpadate(ctime(&q->q_statdate)));
			if (!putline(buf, mci))
				goto writeerr;

			/* Will-Retry-Until: -- for delayed messages only */
			if (QS_IS_QUEUEUP(q->q_state))
			{
				time_t xdate;

				xdate = e->e_parent->e_ctime +
					TimeOuts.to_q_return[e->e_parent->e_timeoutclass];
				(void) sm_strlcpyn(buf, sizeof(buf), 2,
					 "Will-Retry-Until: ",
					 arpadate(ctime(&xdate)));
				if (!putline(buf, mci))
					goto writeerr;
			}
		}
	}
#endif /* DSN */

	/*
	**  Output text of original message
	*/

	if (!putline("", mci))
		goto writeerr;
	if (bitset(EF_HAS_DF, e->e_parent->e_flags))
	{
		sendbody = !bitset(EF_NO_BODY_RETN, e->e_parent->e_flags) &&
			   !bitset(EF_NO_BODY_RETN, e->e_flags);

		if (e->e_msgboundary == NULL)
		{
			if (!putline(
				sendbody
				? "   ----- Original message follows -----\n"
				: "   ----- Message header follows -----\n",
				mci))
			{
				goto writeerr;
			}
		}
		else
		{
			(void) sm_strlcpyn(buf, sizeof(buf), 2, "--",
					e->e_msgboundary);

			if (!putline(buf, mci))
				goto writeerr;
			(void) sm_strlcpyn(buf, sizeof(buf), 2, "Content-Type: ",
					sendbody ? "message/rfc822"
						 : "text/rfc822-headers");
			if (!putline(buf, mci))
				goto writeerr;

			p = hvalue("Content-Transfer-Encoding",
				   e->e_parent->e_header);
			if (p != NULL && sm_strcasecmp(p, "binary") != 0)
				p = NULL;
			if (p == NULL &&
			    bitset(EF_HAS8BIT, e->e_parent->e_flags))
				p = "8bit";
			if (p != NULL)
			{
				(void) sm_snprintf(buf, sizeof(buf),
						"Content-Transfer-Encoding: %s",
						p);
				if (!putline(buf, mci))
					goto writeerr;
			}
		}
		if (!putline("", mci))
			goto writeerr;
		save_errno = errno;
		if (!putheader(mci, e->e_parent->e_header, e->e_parent,
				M87F_OUTER))
			goto writeerr;
		errno = save_errno;
		if (sendbody)
		{
			if (!putbody(mci, e->e_parent, e->e_msgboundary))
				goto writeerr;
		}
		else if (e->e_msgboundary == NULL)
		{
			if (!putline("", mci) ||
			    !putline("   ----- Message body suppressed -----",
					mci))
			{
				goto writeerr;
			}
		}
	}
	else if (e->e_msgboundary == NULL)
	{
		if (!putline("  ----- No message was collected -----\n", mci))
			goto writeerr;
	}

	if (e->e_msgboundary != NULL)
	{
		(void) sm_strlcpyn(buf, sizeof(buf), 3, "--", e->e_msgboundary,
				   "--");
		if (!putline("", mci) || !putline(buf, mci))
			goto writeerr;
	}
	if (!putline("", mci) ||
	    sm_io_flush(mci->mci_out, SM_TIME_DEFAULT) == SM_IO_EOF)
			goto writeerr;

	/*
	**  Cleanup and exit
	*/

	if (errno != 0)
	{
  writeerr:
		syserr("errbody: I/O error");
		return false;
	}
	return true;
}

/*
**  SMTPTODSN -- convert SMTP to DSN status code
**
**	Parameters:
**		smtpstat -- the smtp status code (e.g., 550).
**
**	Returns:
**		The DSN version of the status code.
**
**	Storage Management:
**		smtptodsn() returns a pointer to a character string literal,
**		which will remain valid forever, and thus does not need to
**		be copied.  Current code relies on this property.
*/

char *
smtptodsn(smtpstat)
	int smtpstat;
{
	if (smtpstat < 0)
		return "4.4.2";

	switch (smtpstat)
	{
	  case 450:	/* Req mail action not taken: mailbox unavailable */
		return "4.2.0";

	  case 451:	/* Req action aborted: local error in processing */
		return "4.3.0";

	  case 452:	/* Req action not taken: insufficient sys storage */
		return "4.3.1";

	  case 500:	/* Syntax error, command unrecognized */
		return "5.5.2";

	  case 501:	/* Syntax error in parameters or arguments */
		return "5.5.4";

	  case 502:	/* Command not implemented */
		return "5.5.1";

	  case 503:	/* Bad sequence of commands */
		return "5.5.1";

	  case 504:	/* Command parameter not implemented */
		return "5.5.4";

	  case 550:	/* Req mail action not taken: mailbox unavailable */
		return "5.2.0";

	  case 551:	/* User not local; please try <...> */
		return "5.1.6";

	  case 552:	/* Req mail action aborted: exceeded storage alloc */
		return "5.2.2";

	  case 553:	/* Req action not taken: mailbox name not allowed */
		return "5.1.0";

	  case 554:	/* Transaction failed */
		return "5.0.0";
	}

	if (REPLYTYPE(smtpstat) == 2)
		return "2.0.0";
	if (REPLYTYPE(smtpstat) == 4)
		return "4.0.0";
	return "5.0.0";
}
/*
**  XTEXTIFY -- take regular text and turn it into DSN-style xtext
**
**	Parameters:
**		t -- the text to convert.
**		taboo -- additional characters that must be encoded.
**
**	Returns:
**		The xtext-ified version of the same string.
*/

char *
xtextify(t, taboo)
	register char *t;
	char *taboo;
{
	register char *p;
	int l;
	int nbogus;
	static char *bp = NULL;
	static int bplen = 0;

	if (taboo == NULL)
		taboo = "";

	/* figure out how long this xtext will have to be */
	nbogus = l = 0;
	for (p = t; *p != '\0'; p++)
	{
		register int c = (*p & 0xff);

		/* ASCII dependence here -- this is the way the spec words it */
		if (c < '!' || c > '~' || c == '+' || c == '\\' || c == '(' ||
		    strchr(taboo, c) != NULL)
			nbogus++;
		l++;
	}
	if (nbogus < 0)
	{
		/* since nbogus is ssize_t and wrapped, 2 * size_t would wrap */
		syserr("!xtextify string too long");
	}
	if (nbogus == 0)
		return t;
	l += nbogus * 2 + 1;

	/* now allocate space if necessary for the new string */
	if (l > bplen)
	{
		if (bp != NULL)
			sm_free(bp); /* XXX */
		bp = sm_pmalloc_x(l);
		bplen = l;
	}

	/* ok, copy the text with byte expansion */
	for (p = bp; *t != '\0'; )
	{
		register int c = (*t++ & 0xff);

		/* ASCII dependence here -- this is the way the spec words it */
		if (c < '!' || c > '~' || c == '+' || c == '\\' || c == '(' ||
		    strchr(taboo, c) != NULL)
		{
			*p++ = '+';
			*p++ = "0123456789ABCDEF"[c >> 4];
			*p++ = "0123456789ABCDEF"[c & 0xf];
		}
		else
			*p++ = c;
	}
	*p = '\0';
	return bp;
}
/*
**  XUNTEXTIFY -- take xtext and turn it into plain text
**
**	Parameters:
**		t -- the xtextified text.
**
**	Returns:
**		The decoded text.  No attempt is made to deal with
**		null strings in the resulting text.
*/

char *
xuntextify(t)
	register char *t;
{
	register char *p;
	int l;
	static char *bp = NULL;
	static int bplen = 0;

	/* heuristic -- if no plus sign, just return the input */
	if (strchr(t, '+') == NULL)
		return t;

	/* xtext is always longer than decoded text */
	l = strlen(t);
	if (l > bplen)
	{
		if (bp != NULL)
			sm_free(bp); /* XXX */
		bp = xalloc(l);
		bplen = l;
	}

	/* ok, copy the text with byte compression */
	for (p = bp; *t != '\0'; t++)
	{
		register int c = *t & 0xff;

		if (c != '+')
		{
			*p++ = c;
			continue;
		}

		c = *++t & 0xff;
		if (!isascii(c) || !isxdigit(c))
		{
			/* error -- first digit is not hex */
			usrerr("bogus xtext: +%c", c);
			t--;
			continue;
		}
		if (isdigit(c))
			c -= '0';
		else if (isupper(c))
			c -= 'A' - 10;
		else
			c -= 'a' - 10;
		*p = c << 4;

		c = *++t & 0xff;
		if (!isascii(c) || !isxdigit(c))
		{
			/* error -- second digit is not hex */
			usrerr("bogus xtext: +%x%c", *p >> 4, c);
			t--;
			continue;
		}
		if (isdigit(c))
			c -= '0';
		else if (isupper(c))
			c -= 'A' - 10;
		else
			c -= 'a' - 10;
		*p++ |= c;
	}
	*p = '\0';
	return bp;
}
/*
**  XTEXTOK -- check if a string is legal xtext
**
**	Xtext is used in Delivery Status Notifications.  The spec was
**	taken from RFC 1891, ``SMTP Service Extension for Delivery
**	Status Notifications''.
**
**	Parameters:
**		s -- the string to check.
**
**	Returns:
**		true -- if 's' is legal xtext.
**		false -- if it has any illegal characters in it.
*/

bool
xtextok(s)
	char *s;
{
	int c;

	while ((c = *s++) != '\0')
	{
		if (c == '+')
		{
			c = *s++;
			if (!isascii(c) || !isxdigit(c))
				return false;
			c = *s++;
			if (!isascii(c) || !isxdigit(c))
				return false;
		}
		else if (c < '!' || c > '~' || c == '=')
			return false;
	}
	return true;
}

/*
**  ISATOM -- check if a string is an "atom"
**
**	Parameters:
**		s -- the string to check.
**
**	Returns:
**		true -- iff s is an atom
*/

bool
isatom(s)
	const char *s;
{
	int c;

	if (s == NULL || *s == '\0')
		return false;
	while ((c = *s++) != '\0')
	{
		if (strchr("()<>@@,;:\\.[]\"", c) != NULL)
			return false;
		if (c < '!' || c > '~')
			return false;
	}
	return true;
}
/*
**  PRUNEROUTE -- prune an RFC-822 source route
**
**	Trims down a source route to the last internet-registered hop.
**	This is encouraged by RFC 1123 section 5.3.3.
**
**	Parameters:
**		addr -- the address
**
**	Returns:
**		true -- address was modified
**		false -- address could not be pruned
**
**	Side Effects:
**		modifies addr in-place
*/

static bool
pruneroute(addr)
	char *addr;
{
#if NAMED_BIND
	char *start, *at, *comma;
	char c;
	int braclev;
	int rcode;
	int i;
	char hostbuf[BUFSIZ];
	char *mxhosts[MAXMXHOSTS + 1];

	/* check to see if this is really a route-addr */
	if (*addr != '<' || addr[1] != '@@' || addr[strlen(addr) - 1] != '>')
		return false;

	/*
	**  Can't simply find the first ':' is the address might be in the
	**  form:  "<@@[IPv6:::1]:user@@host>" and the first ':' in inside
	**  the IPv6 address.
	*/

	start = addr;
	braclev = 0;
	while (*start != '\0')
	{
		if (*start == ':' && braclev <= 0)
			break;
		else if (*start == '[')
			braclev++;
		else if (*start == ']' && braclev > 0)
			braclev--;
		start++;
	}
	if (braclev > 0 || *start != ':')
		return false;

	at = strrchr(addr, '@@');
	if (at == NULL || at < start)
		return false;

	/* slice off the angle brackets */
	i = strlen(at + 1);
	if (i >= sizeof(hostbuf))
		return false;
	(void) sm_strlcpy(hostbuf, at + 1, sizeof(hostbuf));
	hostbuf[i - 1] = '\0';

	while (start != NULL)
	{
		if (getmxrr(hostbuf, mxhosts, NULL, false,
			    &rcode, true, NULL) > 0)
		{
			(void) sm_strlcpy(addr + 1, start + 1,
					  strlen(addr) - 1);
			return true;
		}
		c = *start;
		*start = '\0';
		comma = strrchr(addr, ',');
		if (comma != NULL && comma[1] == '@@' &&
		    strlen(comma + 2) < sizeof(hostbuf))
			(void) sm_strlcpy(hostbuf, comma + 2, sizeof(hostbuf));
		else
			comma = NULL;
		*start = c;
		start = comma;
	}
#endif /* NAMED_BIND */
	return false;
}
@


1.19
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.18
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003, 2006, 2012, 2013 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: savemail.c,v 8.318 2013/03/12 15:24:54 ca Exp $")
@


1.17
log
@Update to sendmail 8.14.6
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003, 2006 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: savemail.c,v 8.315 2012/02/27 17:43:03 gshapiro Exp $")
d207 1
a207 1
						   buf, sizeof(buf)) != NULL &&
d869 1
a869 1
						   sizeof(buf)) != NULL)
d1045 2
d1051 2
a1052 2
		while (sm_io_fgets(e->e_parent->e_xfp, SM_TIME_DEFAULT, buf,
				   sizeof(buf)) != NULL)
d1058 1
a1058 1
			if (!putline(buf, mci))
d1179 18
a1196 5
				(void) sm_snprintf(buf, sizeof(buf),
						"Original-Recipient: %.800s",
						q->q_orcpt);
				if (!putline(buf, mci))
					goto writeerr;
d1696 28
@


1.16
log
@Update to sendmail 8.14.5
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: savemail.c,v 8.314 2009/12/18 17:08:01 ca Exp $")
d509 1
a706 2

	/* restore state */
a707 3
	sm_rpool_free(ee->e_rpool);
	CurEnv = oldcur;
	returndepth--;
d710 1
a712 2
		return 0;
	for (q = ee->e_sendqueue; q != NULL; q = q->q_next)
d714 1
a714 2
		if (QS_IS_ATTEMPTED(q->q_state))
			return 0;
d716 18
a733 1
	return -1;
d735 1
@


1.15
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: savemail.c,v 8.313 2006/11/29 00:20:41 ca Exp $")
d708 1
a708 1
	dropenvelope(ee, true, false);
@


1.14
log
@Update to sendmail-8.13.8
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: savemail.c,v 8.308 2006/04/18 01:31:33 ca Exp $")
d196 1
a196 1
			expand("\201n", buf, sizeof buf, e);
d207 1
a207 1
						   buf, sizeof buf) != NULL &&
d254 1
a254 1
						sizeof from) >= sizeof from)
d308 1
a308 1
			expand(DoubleBounceAddr, buf, sizeof buf, e);
d374 1
a374 1
			expand("\201z/dead.letter", dlbuf, sizeof dlbuf, e);
d425 1
a425 1
			memset(&mcibuf, '\0', sizeof mcibuf);
d609 1
a609 1
			addheader("To", q->q_paddr, 0, ee);
d628 2
a629 2
		addheader("MIME-Version", "1.0", 0, ee);
		(void) sm_snprintf(buf, sizeof buf, "%s.%ld/%.100s",
d632 1
a632 1
		(void) sm_snprintf(buf, sizeof buf,
d639 1
a639 1
		addheader("Content-Type", buf, 0, ee);
d647 1
a647 1
			addheader("Content-Transfer-Encoding", p, 0, ee);
d651 1
a651 1
		addheader("Subject", msg, 0, ee);
d656 1
a656 1
		addheader("Subject", msg, 0, ee);
d661 1
a661 1
		addheader("Subject", msg, 0, ee);
d666 1
a666 1
		(void) sm_snprintf(buf, sizeof buf,
d668 1
a668 1
		addheader("Subject", buf, 0, ee);
d673 1
a673 1
		(void) sm_snprintf(buf, sizeof buf,
d675 1
a675 1
		addheader("Subject", buf, 0, ee);
d678 2
a679 2
	(void) sm_snprintf(buf, sizeof buf, "auto-generated (%s)", p);
	addheader("Auto-Submitted", buf, 0, ee);
d682 1
a682 1
	expand("\201n", buf, sizeof buf, e);
d779 1
a779 1
		(void) sm_strlcpyn(buf, sizeof buf, 2, "--", e->e_msgboundary);
d817 1
a817 1
	(void) sm_snprintf(buf, sizeof buf,
d822 1
a822 1
	expand("from \201_", buf, sizeof buf, e->e_parent);
d829 1
a829 1
		(void) sm_strlcpyn(buf, sizeof buf, 2, "with id ",
d857 1
a857 1
						   sizeof buf) != NULL)
d859 11
a869 3
					translate_dollars(buf);
					expand(buf, buf, sizeof buf, e);
					if (!putline(buf, mci))
d879 1
a879 1
			expand(ErrMsgFile, buf, sizeof buf, e);
d906 1
a906 1
				  sizeof buf);
d911 1
a911 1
			(void) sm_snprintf(buf, sizeof buf,
d920 1
a920 1
			(void) sm_snprintf(buf, sizeof buf,
d950 1
a950 1
				  sizeof buf);
d955 1
a955 1
			(void) sm_snprintf(buf, sizeof buf,
d1003 1
a1003 1
		(void) sm_snprintf(buf, sizeof buf, "%s  (%s)",
d1009 1
a1009 1
			(void) sm_snprintf(buf, sizeof buf,
d1038 1
a1038 1
				   sizeof buf) != NULL)
d1057 1
a1057 1
		(void) sm_strlcpyn(buf, sizeof buf, 2, "--", e->e_msgboundary);
d1071 1
a1071 1
			(void) sm_snprintf(buf, sizeof buf,
d1079 1
a1079 1
		(void) sm_snprintf(buf, sizeof buf,
d1093 1
a1093 1
			(void) sm_snprintf(buf, sizeof buf,
d1101 1
a1101 1
		(void) sm_strlcpyn(buf, sizeof buf, 2, "Arrival-Date: ",
d1112 1
a1112 1
			(void) sm_strlcpyn(buf, sizeof buf, 2,
d1165 1
a1165 1
				(void) sm_snprintf(buf, sizeof buf,
d1186 1
a1186 1
							   sizeof actual,
d1194 1
a1194 1
							   sizeof actual,
d1215 1
a1215 1
				(void) sm_snprintf(buf, sizeof buf,
a1224 1
#if _FFR_PRIV_NOACTUALRECIPIENT
a1225 1
#endif /* _FFR_PRIV_NOACTUALRECIPIENT */
d1228 1
a1228 1
				(void) sm_snprintf(buf, sizeof buf,
d1236 1
a1236 1
			(void) sm_strlcpyn(buf, sizeof buf, 2, "Action: ",
d1250 1
a1250 1
			(void) sm_strlcpyn(buf, sizeof buf, 2, "Status: ", p);
d1260 1
a1260 1
				(void) sm_snprintf(buf, sizeof buf,
d1276 1
a1276 1
				(void) sm_snprintf(buf, sizeof buf,
d1286 1
a1286 1
			(void) sm_strlcpyn(buf, sizeof buf, 2,
d1299 1
a1299 1
				(void) sm_strlcpyn(buf, sizeof buf, 2,
d1333 1
a1333 1
			(void) sm_strlcpyn(buf, sizeof buf, 2, "--",
d1338 1
a1338 1
			(void) sm_strlcpyn(buf, sizeof buf, 2, "Content-Type: ",
d1353 1
a1353 1
				(void) sm_snprintf(buf, sizeof buf,
d1390 1
a1390 1
		(void) sm_strlcpyn(buf, sizeof buf, 3, "--", e->e_msgboundary,
d1734 1
a1734 1
	if (i >= sizeof hostbuf)
d1736 1
a1736 1
	(void) sm_strlcpy(hostbuf, at + 1, sizeof hostbuf);
d1752 2
a1753 2
		    strlen(comma + 2) < sizeof hostbuf)
			(void) sm_strlcpy(hostbuf, comma + 2, sizeof hostbuf);
@


1.13
log
@Update to sendmail 8.13.6
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: savemail.c,v 8.306 2006/02/25 02:16:53 ca Exp $")
d736 1
a736 1
**		success
d1267 2
a1268 2
				p = q->q_mailer->m_diagtype;
				if (p == NULL)
@


1.12
log
@Update to sendmail-8.13.2
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: savemail.c,v 8.304 2004/10/06 21:36:06 ca Exp $")
d18 1
a18 1
static void	errbody __P((MCI *, ENVELOPE *, char *));
d435 7
a441 6
			putfromline(&mcibuf, e);
			(*e->e_puthdr)(&mcibuf, e->e_header, e, M87F_OUTER);
			(*e->e_putbody)(&mcibuf, e, NULL);
			putline("\n", &mcibuf); /* XXX EOL from FileMailer? */
			(void) sm_io_flush(fp, SM_TIME_DEFAULT);
			if (sm_io_error(fp) ||
d736 1
a736 1
**		none
d743 1
a743 1
static void
d761 2
a762 1
		putline("", mci);
d768 3
a770 2
		putline("   ----- Original message lost -----\n", mci);
		return;
a778 2
		putline("This is a MIME-encapsulated message", mci);
		putline("", mci);
d780 5
a784 2
		putline(buf, mci);
		putline("", mci);
d806 10
a815 9
		putline("    **********************************************",
			mci);
		putline("    **      THIS IS A WARNING MESSAGE ONLY      **",
			mci);
		putline("    **  YOU DO NOT NEED TO RESEND YOUR MESSAGE  **",
			mci);
		putline("    **********************************************",
			mci);
		putline("", mci);
d820 2
a821 1
	putline(buf, mci);
d823 2
a824 1
	putline(buf, mci);
d831 2
a832 1
		putline(buf, mci);
d834 2
a835 1
	putline("", mci);
d861 2
a862 1
					putline(buf, mci);
d865 2
a866 1
				putline("\n", mci);
d872 2
a873 2
			putline(buf, mci);
			putline("", mci);
d891 3
a893 2
			putline("   ----- The following addresses had permanent fatal errors -----",
				mci);
d899 2
a900 1
		putline(buf, mci);
d907 2
a908 1
			putline(buf, mci);
d916 2
a917 1
			putline(buf, mci);
d920 2
a921 2
	if (!printheader)
		putline("", mci);
d935 3
a937 2
			putline("   ----- The following addresses had transient non-fatal errors -----",
				mci);
d943 2
a944 1
		putline(buf, mci);
d951 2
a952 1
			putline(buf, mci);
d955 2
a956 2
	if (!printheader)
		putline("", mci);
d989 3
a991 2
			putline("   ----- The following addresses had successful delivery notifications -----",
				mci);
d997 2
a998 1
		putline(buf, mci);
d1005 2
a1006 1
			putline(buf, mci);
d1009 2
a1010 2
	if (!printheader)
		putline("", mci);
d1019 3
a1021 2
		putline("   ----- Transcript of session is unavailable -----\n",
			mci);
d1032 3
a1034 3
			if (printheader)
				putline("   ----- Transcript of session follows -----\n",
					mci);
d1036 2
a1037 1
			putline(buf, mci);
a1048 1
		putline("", mci);
d1050 5
a1054 3
		putline(buf, mci);
		putline("Content-Type: message/delivery-status", mci);
		putline("", mci);
d1066 2
a1067 1
			putline(buf, mci);
d1073 2
a1074 1
		putline(buf, mci);
d1088 2
a1089 1
			putline(buf, mci);
d1095 2
a1096 1
		putline(buf, mci);
d1107 2
a1108 1
			putline(buf, mci);
d1151 2
a1152 1
			putline("", mci);
d1160 2
a1161 1
				putline(buf, mci);
d1210 2
a1211 1
				putline(buf, mci);
d1225 2
a1226 1
				putline(buf, mci);
d1232 2
a1233 1
			putline(buf, mci);
d1245 2
a1246 1
			putline(buf, mci);
d1260 2
a1261 1
				putline(buf, mci);
d1273 2
a1274 1
				putline(buf, mci);
d1283 2
a1284 1
			putline(buf, mci);
d1296 2
a1297 1
				putline(buf, mci);
d1307 2
a1308 1
	putline("", mci);
d1316 8
a1323 4
			if (sendbody)
				putline("   ----- Original message follows -----\n", mci);
			else
				putline("   ----- Message header follows -----\n", mci);
d1330 2
a1331 1
			putline(buf, mci);
d1335 2
a1336 1
			putline(buf, mci);
d1350 2
a1351 1
				putline(buf, mci);
d1354 2
a1355 1
		putline("", mci);
d1357 3
a1359 1
		putheader(mci, e->e_parent->e_header, e->e_parent, M87F_OUTER);
d1362 4
a1365 1
			putbody(mci, e->e_parent, e->e_msgboundary);
d1368 6
a1373 2
			putline("", mci);
			putline("   ----- Message body suppressed -----", mci);
d1378 2
a1379 1
		putline("  ----- No message was collected -----\n", mci);
a1383 1
		putline("", mci);
d1386 2
a1387 1
		putline(buf, mci);
d1389 3
a1391 2
	putline("", mci);
	(void) sm_io_flush(mci->mci_out, SM_TIME_DEFAULT);
d1398 2
d1401 3
d1405 1
d1470 1
a1470 1
	if ((smtpstat / 100) == 2)
d1472 1
a1472 1
	if ((smtpstat / 100) == 4)
@


1.12.6.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@d18 1
a18 1
static bool	errbody __P((MCI *, ENVELOPE *, char *));
d435 6
a440 7
			if (!putfromline(&mcibuf, e) ||
			    !(*e->e_puthdr)(&mcibuf, e->e_header, e,
					M87F_OUTER) ||
			    !(*e->e_putbody)(&mcibuf, e, NULL) ||
			    !putline("\n", &mcibuf) ||
			    sm_io_flush(fp, SM_TIME_DEFAULT) == SM_IO_EOF ||
			    sm_io_error(fp) ||
d735 1
a735 1
**		success
d742 1
a742 1
static bool
d760 1
a760 2
		if (!putline("", mci))
			goto writeerr;
d766 2
a767 3
		if (!putline("   ----- Original message lost -----\n", mci))
			goto writeerr;
		return true;
d776 2
d779 2
a780 5
		if (!putline("This is a MIME-encapsulated message", mci) ||
		    !putline("", mci) ||
		    !putline(buf, mci) ||
		    !putline("", mci))
			goto writeerr;
d802 9
a810 10
		if (!putline("    **********************************************",
			mci) ||
		    !putline("    **      THIS IS A WARNING MESSAGE ONLY      **",
			mci) ||
		    !putline("    **  YOU DO NOT NEED TO RESEND YOUR MESSAGE  **",
			mci) ||
		    !putline("    **********************************************",
			mci) ||
		    !putline("", mci))
			goto writeerr;
d815 1
a815 2
	if (!putline(buf, mci))
		goto writeerr;
d817 1
a817 2
	if (!putline(buf, mci))
		goto writeerr;
d824 1
a824 2
		if (!putline(buf, mci))
			goto writeerr;
d826 1
a826 2
	if (!putline("", mci))
		goto writeerr;
d852 1
a852 2
					if (!putline(buf, mci))
						goto writeerr;
d855 1
a855 2
				if (!putline("\n", mci))
					goto writeerr;
d861 2
a862 2
			if (!putline(buf, mci) || !putline("", mci))
				goto writeerr;
d880 2
a881 3
			if (!putline("   ----- The following addresses had permanent fatal errors -----",
					mci))
				goto writeerr;
d887 1
a887 2
		if (!putline(buf, mci))
			goto writeerr;
d894 1
a894 2
			if (!putline(buf, mci))
				goto writeerr;
d902 1
a902 2
			if (!putline(buf, mci))
				goto writeerr;
d905 2
a906 2
	if (!printheader && !putline("", mci))
		goto writeerr;
d920 2
a921 3
			if (!putline("   ----- The following addresses had transient non-fatal errors -----",
					mci))
				goto writeerr;
d927 1
a927 2
		if (!putline(buf, mci))
			goto writeerr;
d934 1
a934 2
			if (!putline(buf, mci))
				goto writeerr;
d937 2
a938 2
	if (!printheader && !putline("", mci))
		goto writeerr;
d971 2
a972 3
			if (!putline("   ----- The following addresses had successful delivery notifications -----",
					mci))
				goto writeerr;
d978 1
a978 2
		if (!putline(buf, mci))
			goto writeerr;
d985 1
a985 2
			if (!putline(buf, mci))
				goto writeerr;
d988 2
a989 2
	if (!printheader && !putline("", mci))
		goto writeerr;
d998 2
a999 3
		if (!putline("   ----- Transcript of session is unavailable -----\n",
				mci))
			goto writeerr;
d1010 3
a1012 3
			if (printheader && !putline("   ----- Transcript of session follows -----\n",
						mci))
				goto writeerr;
d1014 1
a1014 2
			if (!putline(buf, mci))
				goto writeerr;
d1026 1
d1028 3
a1030 5
		if (!putline("", mci) ||
		    !putline(buf, mci) ||
		    !putline("Content-Type: message/delivery-status", mci) ||
		    !putline("", mci))
			goto writeerr;
d1042 1
a1042 2
			if (!putline(buf, mci))
				goto writeerr;
d1048 1
a1048 2
		if (!putline(buf, mci))
			goto writeerr;
d1062 1
a1062 2
			if (!putline(buf, mci))
				goto writeerr;
d1068 1
a1068 2
		if (!putline(buf, mci))
			goto writeerr;
d1079 1
a1079 2
			if (!putline(buf, mci))
				goto writeerr;
d1122 1
a1122 2
			if (!putline("", mci))
				goto writeerr;
d1130 1
a1130 2
				if (!putline(buf, mci))
					goto writeerr;
d1179 1
a1179 2
				if (!putline(buf, mci))
					goto writeerr;
d1193 1
a1193 2
				if (!putline(buf, mci))
					goto writeerr;
d1199 1
a1199 2
			if (!putline(buf, mci))
				goto writeerr;
d1211 1
a1211 2
			if (!putline(buf, mci))
				goto writeerr;
d1225 1
a1225 2
				if (!putline(buf, mci))
					goto writeerr;
d1237 1
a1237 2
				if (!putline(buf, mci))
					goto writeerr;
d1246 1
a1246 2
			if (!putline(buf, mci))
				goto writeerr;
d1258 1
a1258 2
				if (!putline(buf, mci))
					goto writeerr;
d1268 1
a1268 2
	if (!putline("", mci))
		goto writeerr;
d1276 4
a1279 8
			if (!putline(
				sendbody
				? "   ----- Original message follows -----\n"
				: "   ----- Message header follows -----\n",
				mci))
			{
				goto writeerr;
			}
d1286 1
a1286 2
			if (!putline(buf, mci))
				goto writeerr;
d1290 1
a1290 2
			if (!putline(buf, mci))
				goto writeerr;
d1304 1
a1304 2
				if (!putline(buf, mci))
					goto writeerr;
d1307 1
a1307 2
		if (!putline("", mci))
			goto writeerr;
d1309 1
a1309 3
		if (!putheader(mci, e->e_parent->e_header, e->e_parent,
				M87F_OUTER))
			goto writeerr;
d1312 1
a1312 4
		{
			if (!putbody(mci, e->e_parent, e->e_msgboundary))
				goto writeerr;
		}
d1315 2
a1316 6
			if (!putline("", mci) ||
			    !putline("   ----- Message body suppressed -----",
					mci))
			{
				goto writeerr;
			}
d1321 1
a1321 2
		if (!putline("  ----- No message was collected -----\n", mci))
			goto writeerr;
d1326 1
d1329 1
a1329 2
		if (!putline("", mci) || !putline(buf, mci))
			goto writeerr;
d1331 2
a1332 3
	if (!putline("", mci) ||
	    sm_io_flush(mci->mci_out, SM_TIME_DEFAULT) == SM_IO_EOF)
			goto writeerr;
a1338 2
	{
  writeerr:
a1339 3
		return false;
	}
	return true;
a1340 1

@


1.12.4.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@d18 1
a18 1
static bool	errbody __P((MCI *, ENVELOPE *, char *));
d435 6
a440 7
			if (!putfromline(&mcibuf, e) ||
			    !(*e->e_puthdr)(&mcibuf, e->e_header, e,
					M87F_OUTER) ||
			    !(*e->e_putbody)(&mcibuf, e, NULL) ||
			    !putline("\n", &mcibuf) ||
			    sm_io_flush(fp, SM_TIME_DEFAULT) == SM_IO_EOF ||
			    sm_io_error(fp) ||
d735 1
a735 1
**		success
d742 1
a742 1
static bool
d760 1
a760 2
		if (!putline("", mci))
			goto writeerr;
d766 2
a767 3
		if (!putline("   ----- Original message lost -----\n", mci))
			goto writeerr;
		return true;
d776 2
d779 2
a780 5
		if (!putline("This is a MIME-encapsulated message", mci) ||
		    !putline("", mci) ||
		    !putline(buf, mci) ||
		    !putline("", mci))
			goto writeerr;
d802 9
a810 10
		if (!putline("    **********************************************",
			mci) ||
		    !putline("    **      THIS IS A WARNING MESSAGE ONLY      **",
			mci) ||
		    !putline("    **  YOU DO NOT NEED TO RESEND YOUR MESSAGE  **",
			mci) ||
		    !putline("    **********************************************",
			mci) ||
		    !putline("", mci))
			goto writeerr;
d815 1
a815 2
	if (!putline(buf, mci))
		goto writeerr;
d817 1
a817 2
	if (!putline(buf, mci))
		goto writeerr;
d824 1
a824 2
		if (!putline(buf, mci))
			goto writeerr;
d826 1
a826 2
	if (!putline("", mci))
		goto writeerr;
d852 1
a852 2
					if (!putline(buf, mci))
						goto writeerr;
d855 1
a855 2
				if (!putline("\n", mci))
					goto writeerr;
d861 2
a862 2
			if (!putline(buf, mci) || !putline("", mci))
				goto writeerr;
d880 2
a881 3
			if (!putline("   ----- The following addresses had permanent fatal errors -----",
					mci))
				goto writeerr;
d887 1
a887 2
		if (!putline(buf, mci))
			goto writeerr;
d894 1
a894 2
			if (!putline(buf, mci))
				goto writeerr;
d902 1
a902 2
			if (!putline(buf, mci))
				goto writeerr;
d905 2
a906 2
	if (!printheader && !putline("", mci))
		goto writeerr;
d920 2
a921 3
			if (!putline("   ----- The following addresses had transient non-fatal errors -----",
					mci))
				goto writeerr;
d927 1
a927 2
		if (!putline(buf, mci))
			goto writeerr;
d934 1
a934 2
			if (!putline(buf, mci))
				goto writeerr;
d937 2
a938 2
	if (!printheader && !putline("", mci))
		goto writeerr;
d971 2
a972 3
			if (!putline("   ----- The following addresses had successful delivery notifications -----",
					mci))
				goto writeerr;
d978 1
a978 2
		if (!putline(buf, mci))
			goto writeerr;
d985 1
a985 2
			if (!putline(buf, mci))
				goto writeerr;
d988 2
a989 2
	if (!printheader && !putline("", mci))
		goto writeerr;
d998 2
a999 3
		if (!putline("   ----- Transcript of session is unavailable -----\n",
				mci))
			goto writeerr;
d1010 3
a1012 3
			if (printheader && !putline("   ----- Transcript of session follows -----\n",
						mci))
				goto writeerr;
d1014 1
a1014 2
			if (!putline(buf, mci))
				goto writeerr;
d1026 1
d1028 3
a1030 5
		if (!putline("", mci) ||
		    !putline(buf, mci) ||
		    !putline("Content-Type: message/delivery-status", mci) ||
		    !putline("", mci))
			goto writeerr;
d1042 1
a1042 2
			if (!putline(buf, mci))
				goto writeerr;
d1048 1
a1048 2
		if (!putline(buf, mci))
			goto writeerr;
d1062 1
a1062 2
			if (!putline(buf, mci))
				goto writeerr;
d1068 1
a1068 2
		if (!putline(buf, mci))
			goto writeerr;
d1079 1
a1079 2
			if (!putline(buf, mci))
				goto writeerr;
d1122 1
a1122 2
			if (!putline("", mci))
				goto writeerr;
d1130 1
a1130 2
				if (!putline(buf, mci))
					goto writeerr;
d1179 1
a1179 2
				if (!putline(buf, mci))
					goto writeerr;
d1193 1
a1193 2
				if (!putline(buf, mci))
					goto writeerr;
d1199 1
a1199 2
			if (!putline(buf, mci))
				goto writeerr;
d1211 1
a1211 2
			if (!putline(buf, mci))
				goto writeerr;
d1225 1
a1225 2
				if (!putline(buf, mci))
					goto writeerr;
d1237 1
a1237 2
				if (!putline(buf, mci))
					goto writeerr;
d1246 1
a1246 2
			if (!putline(buf, mci))
				goto writeerr;
d1258 1
a1258 2
				if (!putline(buf, mci))
					goto writeerr;
d1268 1
a1268 2
	if (!putline("", mci))
		goto writeerr;
d1276 4
a1279 8
			if (!putline(
				sendbody
				? "   ----- Original message follows -----\n"
				: "   ----- Message header follows -----\n",
				mci))
			{
				goto writeerr;
			}
d1286 1
a1286 2
			if (!putline(buf, mci))
				goto writeerr;
d1290 1
a1290 2
			if (!putline(buf, mci))
				goto writeerr;
d1304 1
a1304 2
				if (!putline(buf, mci))
					goto writeerr;
d1307 1
a1307 2
		if (!putline("", mci))
			goto writeerr;
d1309 1
a1309 3
		if (!putheader(mci, e->e_parent->e_header, e->e_parent,
				M87F_OUTER))
			goto writeerr;
d1312 1
a1312 4
		{
			if (!putbody(mci, e->e_parent, e->e_msgboundary))
				goto writeerr;
		}
d1315 2
a1316 6
			if (!putline("", mci) ||
			    !putline("   ----- Message body suppressed -----",
					mci))
			{
				goto writeerr;
			}
d1321 1
a1321 2
		if (!putline("  ----- No message was collected -----\n", mci))
			goto writeerr;
d1326 1
d1329 1
a1329 2
		if (!putline("", mci) || !putline(buf, mci))
			goto writeerr;
d1331 2
a1332 3
	if (!putline("", mci) ||
	    sm_io_flush(mci->mci_out, SM_TIME_DEFAULT) == SM_IO_EOF)
			goto writeerr;
a1338 2
	{
  writeerr:
a1339 3
		return false;
	}
	return true;
a1340 1

@


1.12.2.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@d18 1
a18 1
static bool	errbody __P((MCI *, ENVELOPE *, char *));
d435 6
a440 7
			if (!putfromline(&mcibuf, e) ||
			    !(*e->e_puthdr)(&mcibuf, e->e_header, e,
					M87F_OUTER) ||
			    !(*e->e_putbody)(&mcibuf, e, NULL) ||
			    !putline("\n", &mcibuf) ||
			    sm_io_flush(fp, SM_TIME_DEFAULT) == SM_IO_EOF ||
			    sm_io_error(fp) ||
d735 1
a735 1
**		success
d742 1
a742 1
static bool
d760 1
a760 2
		if (!putline("", mci))
			goto writeerr;
d766 2
a767 3
		if (!putline("   ----- Original message lost -----\n", mci))
			goto writeerr;
		return true;
d776 2
d779 2
a780 5
		if (!putline("This is a MIME-encapsulated message", mci) ||
		    !putline("", mci) ||
		    !putline(buf, mci) ||
		    !putline("", mci))
			goto writeerr;
d802 9
a810 10
		if (!putline("    **********************************************",
			mci) ||
		    !putline("    **      THIS IS A WARNING MESSAGE ONLY      **",
			mci) ||
		    !putline("    **  YOU DO NOT NEED TO RESEND YOUR MESSAGE  **",
			mci) ||
		    !putline("    **********************************************",
			mci) ||
		    !putline("", mci))
			goto writeerr;
d815 1
a815 2
	if (!putline(buf, mci))
		goto writeerr;
d817 1
a817 2
	if (!putline(buf, mci))
		goto writeerr;
d824 1
a824 2
		if (!putline(buf, mci))
			goto writeerr;
d826 1
a826 2
	if (!putline("", mci))
		goto writeerr;
d852 1
a852 2
					if (!putline(buf, mci))
						goto writeerr;
d855 1
a855 2
				if (!putline("\n", mci))
					goto writeerr;
d861 2
a862 2
			if (!putline(buf, mci) || !putline("", mci))
				goto writeerr;
d880 2
a881 3
			if (!putline("   ----- The following addresses had permanent fatal errors -----",
					mci))
				goto writeerr;
d887 1
a887 2
		if (!putline(buf, mci))
			goto writeerr;
d894 1
a894 2
			if (!putline(buf, mci))
				goto writeerr;
d902 1
a902 2
			if (!putline(buf, mci))
				goto writeerr;
d905 2
a906 2
	if (!printheader && !putline("", mci))
		goto writeerr;
d920 2
a921 3
			if (!putline("   ----- The following addresses had transient non-fatal errors -----",
					mci))
				goto writeerr;
d927 1
a927 2
		if (!putline(buf, mci))
			goto writeerr;
d934 1
a934 2
			if (!putline(buf, mci))
				goto writeerr;
d937 2
a938 2
	if (!printheader && !putline("", mci))
		goto writeerr;
d971 2
a972 3
			if (!putline("   ----- The following addresses had successful delivery notifications -----",
					mci))
				goto writeerr;
d978 1
a978 2
		if (!putline(buf, mci))
			goto writeerr;
d985 1
a985 2
			if (!putline(buf, mci))
				goto writeerr;
d988 2
a989 2
	if (!printheader && !putline("", mci))
		goto writeerr;
d998 2
a999 3
		if (!putline("   ----- Transcript of session is unavailable -----\n",
				mci))
			goto writeerr;
d1010 3
a1012 3
			if (printheader && !putline("   ----- Transcript of session follows -----\n",
						mci))
				goto writeerr;
d1014 1
a1014 2
			if (!putline(buf, mci))
				goto writeerr;
d1026 1
d1028 3
a1030 5
		if (!putline("", mci) ||
		    !putline(buf, mci) ||
		    !putline("Content-Type: message/delivery-status", mci) ||
		    !putline("", mci))
			goto writeerr;
d1042 1
a1042 2
			if (!putline(buf, mci))
				goto writeerr;
d1048 1
a1048 2
		if (!putline(buf, mci))
			goto writeerr;
d1062 1
a1062 2
			if (!putline(buf, mci))
				goto writeerr;
d1068 1
a1068 2
		if (!putline(buf, mci))
			goto writeerr;
d1079 1
a1079 2
			if (!putline(buf, mci))
				goto writeerr;
d1122 1
a1122 2
			if (!putline("", mci))
				goto writeerr;
d1130 1
a1130 2
				if (!putline(buf, mci))
					goto writeerr;
d1179 1
a1179 2
				if (!putline(buf, mci))
					goto writeerr;
d1193 1
a1193 2
				if (!putline(buf, mci))
					goto writeerr;
d1199 1
a1199 2
			if (!putline(buf, mci))
				goto writeerr;
d1211 1
a1211 2
			if (!putline(buf, mci))
				goto writeerr;
d1225 1
a1225 2
				if (!putline(buf, mci))
					goto writeerr;
d1237 1
a1237 2
				if (!putline(buf, mci))
					goto writeerr;
d1246 1
a1246 2
			if (!putline(buf, mci))
				goto writeerr;
d1258 1
a1258 2
				if (!putline(buf, mci))
					goto writeerr;
d1268 1
a1268 2
	if (!putline("", mci))
		goto writeerr;
d1276 4
a1279 8
			if (!putline(
				sendbody
				? "   ----- Original message follows -----\n"
				: "   ----- Message header follows -----\n",
				mci))
			{
				goto writeerr;
			}
d1286 1
a1286 2
			if (!putline(buf, mci))
				goto writeerr;
d1290 1
a1290 2
			if (!putline(buf, mci))
				goto writeerr;
d1304 1
a1304 2
				if (!putline(buf, mci))
					goto writeerr;
d1307 1
a1307 2
		if (!putline("", mci))
			goto writeerr;
d1309 1
a1309 3
		if (!putheader(mci, e->e_parent->e_header, e->e_parent,
				M87F_OUTER))
			goto writeerr;
d1312 1
a1312 4
		{
			if (!putbody(mci, e->e_parent, e->e_msgboundary))
				goto writeerr;
		}
d1315 2
a1316 6
			if (!putline("", mci) ||
			    !putline("   ----- Message body suppressed -----",
					mci))
			{
				goto writeerr;
			}
d1321 1
a1321 2
		if (!putline("  ----- No message was collected -----\n", mci))
			goto writeerr;
d1326 1
d1329 1
a1329 2
		if (!putline("", mci) || !putline(buf, mci))
			goto writeerr;
d1331 2
a1332 3
	if (!putline("", mci) ||
	    sm_io_flush(mci->mci_out, SM_TIME_DEFAULT) == SM_IO_EOF)
			goto writeerr;
a1338 2
	{
  writeerr:
a1339 3
		return false;
	}
	return true;
a1340 1

@


1.11
log
@Update to sendmail.8.13.0
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: savemail.c,v 8.303 2004/01/14 02:56:51 ca Exp $")
d1185 3
@


1.10
log
@update to sendmail 8.12.7
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: savemail.c,v 8.299.2.1 2002/10/23 15:08:47 ca Exp $")
d77 1
a77 1
		printaddr(&e->e_from, false);
d181 1
d183 4
d526 1
a526 1
		printaddr(returnq, true);
d530 1
a530 1
			printaddr(e->e_sendqueue, true);
@


1.9
log
@Update to sendmail-8.12.4
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: savemail.c,v 8.299 2002/05/24 20:50:17 gshapiro Exp $")
d548 1
a548 19
#if SASL
	macdefine(&ee->e_macro, A_PERM, macid("{auth_type}"), "");
	macdefine(&ee->e_macro, A_PERM, macid("{auth_authen}"), "");
	macdefine(&ee->e_macro, A_PERM, macid("{auth_author}"), "");
	macdefine(&ee->e_macro, A_PERM, macid("{auth_ssf}"), "");
#endif /* SASL */
#if STARTTLS
	macdefine(&ee->e_macro, A_PERM, macid("{cert_issuer}"), "");
	macdefine(&ee->e_macro, A_PERM, macid("{cert_subject}"), "");
	macdefine(&ee->e_macro, A_PERM, macid("{cipher_bits}"), "");
	macdefine(&ee->e_macro, A_PERM, macid("{cipher}"), "");
	macdefine(&ee->e_macro, A_PERM, macid("{tls_version}"), "");
	macdefine(&ee->e_macro, A_PERM, macid("{verify}"), "");
# if _FFR_TLS_1
	macdefine(&ee->e_macro, A_PERM, macid("{alg_bits}"), "");
	macdefine(&ee->e_macro, A_PERM, macid("{cn_issuer}"), "");
	macdefine(&ee->e_macro, A_PERM, macid("{cn_subject}"), "");
# endif /* _FFR_TLS_1 */
#endif /* STARTTLS */
@


1.8
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: savemail.c,v 8.297 2001/12/28 22:32:19 ca Exp $")
d68 1
d369 1
a369 1
			expand("\201z/dead.letter", buf, sizeof buf, e);
d373 3
a375 3
			e->e_to = buf;
			if (writable(buf, NULL, sff) &&
			    mailfile(buf, FileMailer, NULL, sff, e) == EX_OK)
d382 1
a382 1
					message("Saved message in %s", buf);
@


1.7
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: savemail.c,v 8.291 2001/09/11 04:05:16 gshapiro Exp $")
d35 2
a36 1
**		true if the data file should be preserved by dropenvelope()
d60 1
a60 1
	bool savedf = false;
d82 1
a82 1
		return savedf;
d98 1
a98 1
			finis(true, EX_SOFTWARE);
d138 1
a138 1
		return savedf;
d141 1
a141 1
		syserr("554 5.3.0 savemail: bogus errormode x%x\n",
d154 1
a154 1
			return savedf;
d254 2
a255 3
				if (!DontPruneRoutes && pruneroute(from))
				{
					ADDRESS *a;
a256 7
					for (a = e->e_errorqueue; a != NULL;
					     a = a->q_next)
					{
						if (sameaddr(a, &e->e_from))
							a->q_state = QS_DUPLICATE;
					}
				}
d463 1
a463 1
			savedf = true;
d470 1
a470 1
	return savedf;
d493 1
a493 1
#define ERRORFUDGE	100	/* nominal size of error message text */
d587 1
a587 1
	ee->e_msgsize = ERRORFUDGE;
d590 1
a590 1
		ee->e_msgsize += e->e_msgsize;
d713 1
a713 1
	markstats(ee, NULLADDR, false);
@


1.6
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: savemail.c,v 8.287 2001/09/04 22:43:05 ca Exp $")
d35 1
a35 1
**		true if the df file should be preserved by dropenvelope()
d208 2
a209 1
				syserr("Cannot open %s", queuename(e, 'x'));
d479 1
a479 1
/*
d742 1
a742 1
/*
d1357 1
a1357 1
/*
d1427 1
a1427 1
/*
d1501 1
a1501 1
/*
d1581 1
a1581 1
/*
d1618 1
a1618 1
/*
@


1.5
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@a13 4
#ifndef lint
static char id[] = "@@(#)$Sendmail: savemail.c,v 8.212.4.13 2001/05/03 17:24:15 gshapiro Exp $";
#endif /* ! lint */

d16 1
d31 1
a31 1
**		sendbody -- if TRUE, also send back the body of the
d35 1
a35 1
**		none
d53 1
a53 2

void
d58 2
a59 2
	register struct passwd *pw;
	register FILE *fp;
d67 2
d72 1
a72 1
		dprintf("\nsavemail, errormode = %c, id = %s, ExitStat = %d\n  e_from=",
d75 1
a75 1
		printaddr(&e->e_from, FALSE);
d81 1
a81 1
		return;
d93 2
a94 1
			      RF_COPYPARSE|RF_SENDERADDR, '\0', NULL, e) == NULL)
d97 1
a97 1
			finis(TRUE, EX_SOFTWARE);
d137 1
a137 1
		return;
d153 1
a153 1
			return;
d161 1
a161 1
			dprintf("  state %d\n", state);
d180 4
a183 1
			if (p == NULL || freopen(p, "w", stdout) == NULL)
d190 4
a193 2
			printf("\r\nMessage from %s...\r\n", buf);
			printf("Errors occurred while sending mail.\r\n");
d197 8
a204 4
				printf("Transcript follows:\r\n");
				while (fgets(buf, sizeof buf, e->e_xfp) != NULL &&
				       !ferror(stdout))
					(void) fputs(buf, stdout);
d209 2
a210 1
				printf("Transcript of session is unavailable.\r\n");
d212 2
a213 1
			printf("Original message will be saved in dead.letter.\r\n");
d238 2
a239 2
				(void) sendtolist("postmaster",
					  NULLADDR, &e->e_errorqueue, 0, e);
d245 2
a246 1
				if (strlen(e->e_from.q_paddr) >= sizeof from)
a250 2
				(void) strlcpy(from, e->e_from.q_paddr,
					       sizeof from);
d309 11
d355 4
a358 3
				else if ((pw = sm_getpwnam(e->e_from.q_user)) != NULL &&
					 *pw->pw_dir != '\0')
					p = pw->pw_dir;
d368 1
a368 1
			define('z', p, e);
d372 1
a372 1
			define('g', e->e_sender, e);
d389 1
a389 1
				define('g', p, e);
d393 1
a393 1
			define('g', p, e);
d433 1
a433 1
			define('g', e->e_sender, e);
d438 4
a441 4
			putline("\n", &mcibuf);
			(void) fflush(fp);
			if (ferror(fp) ||
			    fclose(fp) < 0)
d459 1
a459 1
			define('g', p, e);
a463 1

d469 1
d471 3
a473 1
			syserr("!554 savemail: cannot save rejected email anywhere");
d476 1
d495 1
a495 2
**		Returns the current message to the sender via
**		mail.
d524 3
a526 3
		dprintf("\n*** Return To Sender: msg=\"%s\", depth=%d, e=%lx, returnq=",
			msg, returndepth, (u_long) e);
		printaddr(returnq, TRUE);
d529 2
a530 2
			dprintf("Sendq=");
			printaddr(e->e_sendqueue, TRUE);
d544 2
a545 2
	define('g', e->e_sender, e);
	define('u', NULL, e);
d548 5
a552 5
	ee = newenvelope(&errenvelope, e);
	define('a', "\201b", ee);
	define('r', "", ee);
	define('s', "localhost", ee);
	define('_', "localhost", ee);
d554 4
a557 4
	define(macid("{auth_type}", NULL), "", ee);
	define(macid("{auth_authen}", NULL), "", ee);
	define(macid("{auth_author}", NULL), "", ee);
	define(macid("{auth_ssf}", NULL), "", ee);
d560 6
a565 6
	define(macid("{cert_issuer}", NULL), "", ee);
	define(macid("{cert_subject}", NULL), "", ee);
	define(macid("{cipher_bits}", NULL), "", ee);
	define(macid("{cipher}", NULL), "", ee);
	define(macid("{tls_version}", NULL), "", ee);
	define(macid("{verify}", NULL), "", ee);
d567 3
a569 3
	define(macid("{alg_bits}", NULL), "", ee);
	define(macid("{cn_issuer}", NULL), "", ee);
	define(macid("{cn_subject}", NULL), "", ee);
d599 9
d626 1
a626 1
			addheader("To", q->q_paddr, 0, &ee->e_header);
d639 1
a639 2
		sm_syslog(LOG_INFO, e->e_id,
			  "%s: %s: %s",
d645 5
a649 6
		addheader("MIME-Version", "1.0", 0, &ee->e_header);

		(void) snprintf(buf, sizeof buf, "%s.%ld/%.100s",
				ee->e_id, (long) curtime(), MyHostName);
		ee->e_msgboundary = newstr(buf);
		(void) snprintf(buf, sizeof buf,
d656 1
a656 1
		addheader("Content-Type", buf, 0, &ee->e_header);
d659 1
a659 1
		if (p != NULL && strcasecmp(p, "binary") != 0)
d664 1
a664 2
			addheader("Content-Transfer-Encoding",
				  p, 0, &ee->e_header);
d668 1
a668 1
		addheader("Subject", msg, 0, &ee->e_header);
d673 1
a673 1
		addheader("Subject", msg, 0, &ee->e_header);
d678 1
a678 1
		addheader("Subject", msg, 0, &ee->e_header);
d683 1
a683 1
		snprintf(buf, sizeof buf,
d685 1
a685 1
		addheader("Subject", buf, 0, &ee->e_header);
d690 1
a690 1
		snprintf(buf, sizeof buf,
d692 1
a692 1
		addheader("Subject", buf, 0, &ee->e_header);
d695 2
a696 2
	(void) snprintf(buf, sizeof buf, "auto-generated (%s)", p);
	addheader("Auto-Submitted", buf, 0, &ee->e_header);
d701 1
a701 1
		      RF_COPYALL|RF_SENDERADDR, '\0', NULL, e) == NULL)
d714 3
a716 3
	define('f', "\201n", ee);
	define('x', "Mail Delivery Subsystem", ee);
	eatheader(ee, TRUE);
d719 1
a719 1
	markstats(ee, NULLADDR, FALSE);
d725 2
a726 1
	dropenvelope(ee, TRUE);
d750 1
a750 1
**		separator -- any possible MIME separator.
d770 1
a770 1
	register FILE *xfile;
d773 1
d796 1
a796 1
		(void) snprintf(buf, sizeof buf, "--%s", e->e_msgboundary);
d805 1
a805 1
	pm_notify = FALSE;
d808 1
a808 1
		pm_notify = TRUE;
d830 3
a832 2
	snprintf(buf, sizeof buf, "The original message was received at %s",
		 arpadate(ctime(&e->e_parent->e_ctime)));
d840 2
a841 1
		snprintf(buf, sizeof buf, "with id %s", e->e_parent->e_id);
d865 2
a866 1
				while (fgets(buf, sizeof buf, xfile) != NULL)
d872 1
a872 1
				(void) fclose(xfile);
d888 2
a889 1
	printheader = TRUE;
d900 1
a900 1
			printheader = FALSE;
d903 2
a904 2
		snprintf(buf, sizeof buf, "%s",
			 shortenstring(q->q_paddr, MAXSHORTSTR));
d908 4
a911 3
			snprintf(buf, sizeof buf, "    (reason: %s)",
				 shortenstring(exitstat(q->q_rstatus),
					       MAXSHORTSTR));
d916 4
a919 3
			snprintf(buf, sizeof buf, "    (expanded from: %s)",
				 shortenstring(q->q_alias->q_paddr,
					       MAXSHORTSTR));
d926 2
a927 1
	printheader = TRUE;
d932 1
d940 1
a940 1
			printheader = FALSE;
d943 2
a944 2
		snprintf(buf, sizeof buf, "%s",
			 shortenstring(q->q_paddr, MAXSHORTSTR));
d948 4
a951 3
			snprintf(buf, sizeof buf, "    (expanded from: %s)",
				 shortenstring(q->q_alias->q_paddr,
					       MAXSHORTSTR));
d958 2
a959 1
	printheader = TRUE;
d964 1
d967 4
d991 1
a991 1
			printheader = FALSE;
d994 1
a994 1
		snprintf(buf, sizeof buf, "%s  (%s)",
d999 4
a1002 3
			snprintf(buf, sizeof buf, "    (expanded from: %s)",
				 shortenstring(q->q_alias->q_paddr,
					       MAXSHORTSTR));
d1013 1
a1013 1
	(void) fflush(stdout);
d1021 1
a1021 1
		printheader = TRUE;
d1024 3
a1026 2
			(void) fflush(e->e_xfp);
		while (fgets(buf, sizeof buf, e->e_parent->e_xfp) != NULL)
d1031 1
a1031 1
			printheader = FALSE;
a1043 2
		time_t now = curtime();

d1045 1
a1045 1
		(void) snprintf(buf, sizeof buf, "--%s", e->e_msgboundary);
d1057 1
a1057 1
			(void) snprintf(buf, sizeof buf,
d1064 2
a1065 2
		(void) snprintf(buf, sizeof buf, "Reporting-MTA: dns; %.800s",
				MyHostName);
d1077 1
a1077 1
			(void) snprintf(buf, sizeof buf,
d1084 1
a1084 1
		(void) snprintf(buf, sizeof buf, "Arrival-Date: %s",
d1088 12
a1105 1
			register ADDRESS *r;
d1131 6
d1145 1
a1145 1
				(void) snprintf(buf, sizeof buf,
d1151 3
a1153 51
			/* Final-Recipient: -- the name from the RCPT command */
			p = e->e_parent->e_from.q_mailer->m_addrtype;
			if (p == NULL)
				p = "rfc822";
			for (r = q; r->q_alias != NULL; r = r->q_alias)
				continue;
			if (strcasecmp(p, "rfc822") != 0)
			{
				(void) snprintf(buf, sizeof buf,
						"Final-Recipient: %s; %.800s",
						r->q_mailer->m_addrtype,
						r->q_user);
			}
			else if (strchr(r->q_user, '@@') != NULL)
			{
				(void) snprintf(buf, sizeof buf,
						"Final-Recipient: %s; %.800s",
						p, r->q_user);
			}
			else if (strchr(r->q_paddr, '@@') != NULL)
			{
				char *qp;
				bool b;

				qp = r->q_paddr;
				/* strip brackets from address */
				b = FALSE;
				if (*qp == '<')
				{
					b = qp[strlen(qp) - 1]  == '>';
					if (b)
						qp[strlen(qp) - 1] = '\0';
					qp++;
				}
				(void) snprintf(buf, sizeof buf,
						"Final-Recipient: %s; %.800s",
						p, qp);
				/* undo damage */
				if (b)
					qp[strlen(qp)] = '>';
			}
			else
			{
				(void) snprintf(buf, sizeof buf,
						"Final-Recipient: %s; %.700s@@%.100s",
						p, r->q_user, MyHostName);
			}
			putline(buf, mci);

			/* X-Actual-Recipient: -- the real problem address */
			if (r != q && q->q_user[0] != '\0')
d1161 1
a1161 1
				if (strcasecmp(p, "rfc822") == 0 &&
d1164 5
a1168 4
					(void) snprintf(buf, sizeof buf,
							"X-Actual-Recipient: %s; %.700s@@%.100s",
							p, q->q_user,
							MyHostName);
d1172 4
a1175 3
					(void) snprintf(buf, sizeof buf,
							"X-Actual-Recipient: %s; %.800s",
							p, q->q_user);
d1177 31
d1212 2
a1213 1
			snprintf(buf, sizeof buf, "Action: %s", action);
d1225 1
a1225 1
			snprintf(buf, sizeof buf, "Status: %s", p);
d1234 1
a1234 1
				(void) snprintf(buf, sizeof buf,
d1249 1
a1249 1
				(void) snprintf(buf, sizeof buf,
d1257 3
a1259 3
				q->q_statdate = now;
			(void) snprintf(buf, sizeof buf,
					"Last-Attempt-Date: %s",
d1270 2
a1271 2
				snprintf(buf, sizeof buf,
					 "Will-Retry-Until: %s",
d1298 1
a1298 1
			(void) snprintf(buf, sizeof buf, "--%s",
d1302 1
a1302 1
			(void) snprintf(buf, sizeof buf, "Content-Type: %s",
d1309 1
a1309 1
			if (p != NULL && strcasecmp(p, "binary") != 0)
d1316 1
a1316 1
				(void) snprintf(buf, sizeof buf,
d1342 2
a1343 1
		(void) snprintf(buf, sizeof buf, "--%s--", e->e_msgboundary);
d1347 1
a1347 1
	(void) fflush(mci->mci_out);
d1364 5
d1463 5
d1476 2
a1477 2
			sm_free(bp);
		bp = xalloc(l);
d1529 1
a1529 1
			sm_free(bp);
d1591 2
a1592 2
**		TRUE -- if 's' is legal xtext.
**		FALSE -- if it has any illegal characters in it.
d1607 1
a1607 1
				return FALSE;
d1610 1
a1610 1
				return FALSE;
d1613 1
a1613 1
			return FALSE;
d1615 1
a1615 1
	return TRUE;
d1627 2
a1628 2
**		TRUE -- address was modified
**		FALSE -- address could not be pruned
d1641 1
d1649 23
a1671 2
		return FALSE;
	start = strchr(addr, ':');
d1673 2
a1674 2
	if (start == NULL || at == NULL || at < start)
		return FALSE;
d1678 3
a1680 3
	if (i >= (SIZE_T) sizeof hostbuf)
		return FALSE;
	(void) strlcpy(hostbuf, at + 1, sizeof hostbuf);
d1683 1
a1683 1
	while (start)
d1685 2
a1686 1
		if (getmxrr(hostbuf, mxhosts, NULL, FALSE, &rcode) > 0)
d1688 3
a1690 2
			(void) strlcpy(addr + 1, start + 1, strlen(addr) - 1);
			return TRUE;
d1696 2
a1697 2
		    strlen(comma + 2) < (SIZE_T) sizeof hostbuf)
			(void) strlcpy(hostbuf, comma + 2, sizeof hostbuf);
d1704 1
a1704 1
	return FALSE;
@


1.4
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: savemail.c,v 8.212.4.12 2001/01/07 19:31:05 gshapiro Exp $";
d1416 1
a1416 1
			free(bp);
d1469 1
a1469 1
			free(bp);
@


1.4.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: savemail.c,v 8.212.4.13 2001/05/03 17:24:15 gshapiro Exp $";
d1416 1
a1416 1
			sm_free(bp);
d1469 1
a1469 1
			sm_free(bp);
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: savemail.c,v 8.212.4.11 2000/12/18 18:00:44 ca Exp $";
d1018 2
a1019 1
		(void) snprintf(buf, sizeof buf, "Reporting-MTA: dns; %.800s", MyHostName);
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: savemail.c,v 8.212 2000/03/13 22:56:51 ca Exp $";
d20 1
d335 2
a336 1
				else if ((pw = sm_getpwnam(e->e_from.q_user)) != NULL)
d449 1
d534 1
d536 13
d594 1
a594 1
			addheader("To", q->q_paddr, &ee->e_header);
d614 1
a614 1
		addheader("MIME-Version", "1.0", &ee->e_header);
d617 1
a617 1
				ee->e_id, curtime(), MyHostName);
d626 1
a626 1
		addheader("Content-Type", buf, &ee->e_header);
d635 1
a635 1
				  p, &ee->e_header);
d639 1
a639 1
		addheader("Subject", msg, &ee->e_header);
d644 1
a644 1
		addheader("Subject", msg, &ee->e_header);
d649 1
a649 1
		addheader("Subject", msg, &ee->e_header);
d656 1
a656 1
		addheader("Subject", buf, &ee->e_header);
d663 1
a663 1
		addheader("Subject", buf, &ee->e_header);
d667 1
a667 1
	addheader("Auto-Submitted", buf, &ee->e_header);
d996 2
d1051 5
d1057 1
d1207 1
a1207 1
				q->q_statdate = curtime();
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: savemail.c,v 8.212.4.13 2001/05/03 17:24:15 gshapiro Exp $";
a19 1

d334 1
a334 2
				else if ((pw = sm_getpwnam(e->e_from.q_user)) != NULL &&
					 *pw->pw_dir != '\0')
a446 1
			errno = 0;
a530 1
	define(macid("{auth_ssf}", NULL), "", ee);
a531 13
#if STARTTLS
	define(macid("{cert_issuer}", NULL), "", ee);
	define(macid("{cert_subject}", NULL), "", ee);
	define(macid("{cipher_bits}", NULL), "", ee);
	define(macid("{cipher}", NULL), "", ee);
	define(macid("{tls_version}", NULL), "", ee);
	define(macid("{verify}", NULL), "", ee);
# if _FFR_TLS_1
	define(macid("{alg_bits}", NULL), "", ee);
	define(macid("{cn_issuer}", NULL), "", ee);
	define(macid("{cn_subject}", NULL), "", ee);
# endif /* _FFR_TLS_1 */
#endif /* STARTTLS */
d577 1
a577 1
			addheader("To", q->q_paddr, 0, &ee->e_header);
d597 1
a597 1
		addheader("MIME-Version", "1.0", 0, &ee->e_header);
d600 1
a600 1
				ee->e_id, (long) curtime(), MyHostName);
d609 1
a609 1
		addheader("Content-Type", buf, 0, &ee->e_header);
d618 1
a618 1
				  p, 0, &ee->e_header);
d622 1
a622 1
		addheader("Subject", msg, 0, &ee->e_header);
d627 1
a627 1
		addheader("Subject", msg, 0, &ee->e_header);
d632 1
a632 1
		addheader("Subject", msg, 0, &ee->e_header);
d639 1
a639 1
		addheader("Subject", buf, 0, &ee->e_header);
d646 1
a646 1
		addheader("Subject", buf, 0, &ee->e_header);
d650 1
a650 1
	addheader("Auto-Submitted", buf, 0, &ee->e_header);
a978 2
		time_t now = curtime();

d999 1
a999 2
		(void) snprintf(buf, sizeof buf, "Reporting-MTA: dns; %.800s",
				MyHostName);
a1031 5
			{
				/* RFC 1891, 6.2.6 (b) */
				if (bitset(QHASNOTIFY, q->q_flags) &&
				    !bitset(QPINGONFAILURE, q->q_flags))
					continue;
a1032 1
			}
d1182 1
a1182 1
				q->q_statdate = now;
d1390 1
a1390 1
			sm_free(bp);
d1443 1
a1443 1
			sm_free(bp);
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: savemail.c,v 8.211 2000/02/01 05:49:56 gshapiro Exp $";
d527 6
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Id: savemail.c,v 8.212.4.11 2000/12/18 18:00:44 ca Exp $";
a19 1

d334 1
a334 2
				else if ((pw = sm_getpwnam(e->e_from.q_user)) != NULL &&
					 *pw->pw_dir != '\0')
a446 1
			errno = 0;
a526 20
#if SASL
	define(macid("{auth_type}", NULL), "", ee);
	define(macid("{auth_authen}", NULL), "", ee);
	define(macid("{auth_author}", NULL), "", ee);
	define(macid("{auth_ssf}", NULL), "", ee);
#endif /* SASL */
#if STARTTLS
	define(macid("{cert_issuer}", NULL), "", ee);
	define(macid("{cert_subject}", NULL), "", ee);
	define(macid("{cipher_bits}", NULL), "", ee);
	define(macid("{cipher}", NULL), "", ee);
	define(macid("{tls_version}", NULL), "", ee);
	define(macid("{verify}", NULL), "", ee);
# if _FFR_TLS_1
	define(macid("{alg_bits}", NULL), "", ee);
	define(macid("{cn_issuer}", NULL), "", ee);
	define(macid("{cn_subject}", NULL), "", ee);
# endif /* _FFR_TLS_1 */
#endif /* STARTTLS */

d571 1
a571 1
			addheader("To", q->q_paddr, 0, &ee->e_header);
d591 1
a591 1
		addheader("MIME-Version", "1.0", 0, &ee->e_header);
d594 1
a594 1
				ee->e_id, (long) curtime(), MyHostName);
d603 1
a603 1
		addheader("Content-Type", buf, 0, &ee->e_header);
d612 1
a612 1
				  p, 0, &ee->e_header);
d616 1
a616 1
		addheader("Subject", msg, 0, &ee->e_header);
d621 1
a621 1
		addheader("Subject", msg, 0, &ee->e_header);
d626 1
a626 1
		addheader("Subject", msg, 0, &ee->e_header);
d633 1
a633 1
		addheader("Subject", buf, 0, &ee->e_header);
d640 1
a640 1
		addheader("Subject", buf, 0, &ee->e_header);
d644 1
a644 1
	addheader("Auto-Submitted", buf, 0, &ee->e_header);
a972 2
		time_t now = curtime();

a1025 5
			{
				/* RFC 1891, 6.2.6 (b) */
				if (bitset(QHASNOTIFY, q->q_flags) &&
				    !bitset(QPINGONFAILURE, q->q_flags))
					continue;
a1026 1
			}
d1176 1
a1176 1
				q->q_statdate = now;
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d14 4
a19 1
SM_RCSID("@@(#)$Sendmail: savemail.c,v 8.287 2001/09/04 22:43:05 ca Exp $")
d34 1
a34 1
**		sendbody -- if true, also send back the body of the
d38 1
a38 1
**		true if the df file should be preserved by dropenvelope()
d56 2
a57 1
bool
d62 2
a63 2
	register SM_FILE_T *fp;
	bool savedf = false;
a70 2
	SM_MBDB_T user;

d74 1
a74 1
		sm_dprintf("\nsavemail, errormode = %c, id = %s, ExitStat = %d\n  e_from=",
d77 1
a77 1
		printaddr(&e->e_from, false);
d83 1
a83 1
		return savedf;
d95 1
a95 2
			      RF_COPYPARSE|RF_SENDERADDR,
			      '\0', NULL, e, false) == NULL)
d98 1
a98 1
			finis(true, EX_SOFTWARE);
d138 1
a138 1
		return savedf;
d154 1
a154 1
			return savedf;
d162 1
a162 1
			sm_dprintf("  state %d\n", state);
d181 1
a181 4
			if (p == NULL || sm_io_reopen(SmFtStdio,
						      SM_TIME_DEFAULT,
						      p, SM_IO_WRONLY, NULL,
						      smioout) == NULL)
d188 2
a189 4
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "\r\nMessage from %s...\r\n", buf);
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Errors occurred while sending mail.\r\n");
d193 4
a196 8
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Transcript follows:\r\n");
				while (sm_io_fgets(e->e_xfp, SM_TIME_DEFAULT,
						   buf, sizeof buf) != NULL &&
				       !sm_io_error(smioout))
					(void) sm_io_fputs(smioout,
							   SM_TIME_DEFAULT,
							   buf);
d201 1
a201 2
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Transcript of session is unavailable.\r\n");
d203 1
a203 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Original message will be saved in dead.letter.\r\n");
d228 2
a229 2
				(void) sendtolist("postmaster", NULLADDR,
						  &e->e_errorqueue, 0, e);
d235 1
a235 2
				if (sm_strlcpy(from, e->e_from.q_paddr,
						sizeof from) >= sizeof from)
d240 2
a299 11

			/*
			**  Just drop it on the floor if DoubleBounceAddr
			**  expands to an empty string.
			*/

			if (*buf == '\0')
			{
				state = ESM_DONE;
				break;
			}
d335 3
a337 4
				else if (sm_mbdb_lookup(e->e_from.q_user, &user)
					 == EX_OK &&
					 *user.mbdb_homedir != '\0')
					p = user.mbdb_homedir;
d347 1
a347 1
			macdefine(&e->e_macro, A_TEMP, 'z', p);
d351 1
a351 1
			macdefine(&e->e_macro, A_PERM, 'g', e->e_sender);
d368 1
a368 1
				macdefine(&e->e_macro, A_PERM, 'g', p);
d372 1
a372 1
			macdefine(&e->e_macro, A_PERM, 'g', p);
d412 1
a412 1
			macdefine(&e->e_macro, A_PERM, 'g', e->e_sender);
d417 4
a420 4
			putline("\n", &mcibuf); /* XXX EOL from FileMailer? */
			(void) sm_io_flush(fp, SM_TIME_DEFAULT);
			if (sm_io_error(fp) ||
			    sm_io_close(fp, SM_TIME_DEFAULT) < 0)
d438 1
a438 1
			macdefine(&e->e_macro, A_PERM, 'g', p);
d443 1
a448 1
			savedf = true;
d450 1
a450 3
			syserr("554 savemail: cannot save rejected email anywhere");
			state = ESM_DONE;
			break;
a452 1
	return savedf;
d471 2
a472 1
**		Returns the current message to the sender via mail.
d501 3
a503 3
		sm_dprintf("\n*** Return To Sender: msg=\"%s\", depth=%d, e=%p, returnq=",
			msg, returndepth, e);
		printaddr(returnq, true);
d506 2
a507 2
			sm_dprintf("Sendq=");
			printaddr(e->e_sendqueue, true);
d521 2
a522 2
	macdefine(&e->e_macro, A_PERM, 'g', e->e_sender);
	macdefine(&e->e_macro, A_PERM, 'u', NULL);
d525 5
a529 5
	ee = newenvelope(&errenvelope, e, sm_rpool_new_x(NULL));
	macdefine(&ee->e_macro, A_PERM, 'a', "\201b");
	macdefine(&ee->e_macro, A_PERM, 'r', "");
	macdefine(&ee->e_macro, A_PERM, 's', "localhost");
	macdefine(&ee->e_macro, A_PERM, '_', "localhost");
d531 4
a534 4
	macdefine(&ee->e_macro, A_PERM, macid("{auth_type}"), "");
	macdefine(&ee->e_macro, A_PERM, macid("{auth_authen}"), "");
	macdefine(&ee->e_macro, A_PERM, macid("{auth_author}"), "");
	macdefine(&ee->e_macro, A_PERM, macid("{auth_ssf}"), "");
d537 6
a542 6
	macdefine(&ee->e_macro, A_PERM, macid("{cert_issuer}"), "");
	macdefine(&ee->e_macro, A_PERM, macid("{cert_subject}"), "");
	macdefine(&ee->e_macro, A_PERM, macid("{cipher_bits}"), "");
	macdefine(&ee->e_macro, A_PERM, macid("{cipher}"), "");
	macdefine(&ee->e_macro, A_PERM, macid("{tls_version}"), "");
	macdefine(&ee->e_macro, A_PERM, macid("{verify}"), "");
d544 3
a546 3
	macdefine(&ee->e_macro, A_PERM, macid("{alg_bits}"), "");
	macdefine(&ee->e_macro, A_PERM, macid("{cn_issuer}"), "");
	macdefine(&ee->e_macro, A_PERM, macid("{cn_subject}"), "");
a575 9

	if (!setnewqueue(ee))
	{
		syserr("554 5.3.0 returntosender: cannot select queue for %s",
			       returnq->q_paddr);
		ExitStat = EX_UNAVAILABLE;
		returndepth--;
		return -1;
	}
d594 1
a594 1
			addheader("To", q->q_paddr, 0, ee);
d607 2
a608 1
		sm_syslog(LOG_INFO, e->e_id, "%s: %s: %s",
d614 6
a619 5
		addheader("MIME-Version", "1.0", 0, ee);
		(void) sm_snprintf(buf, sizeof buf, "%s.%ld/%.100s",
				ee->e_id, (long)curtime(), MyHostName);
		ee->e_msgboundary = sm_rpool_strdup_x(ee->e_rpool, buf);
		(void) sm_snprintf(buf, sizeof buf,
d626 1
a626 1
		addheader("Content-Type", buf, 0, ee);
d629 1
a629 1
		if (p != NULL && sm_strcasecmp(p, "binary") != 0)
d634 2
a635 1
			addheader("Content-Transfer-Encoding", p, 0, ee);
d639 1
a639 1
		addheader("Subject", msg, 0, ee);
d644 1
a644 1
		addheader("Subject", msg, 0, ee);
d649 1
a649 1
		addheader("Subject", msg, 0, ee);
d654 1
a654 1
		(void) sm_snprintf(buf, sizeof buf,
d656 1
a656 1
		addheader("Subject", buf, 0, ee);
d661 1
a661 1
		(void) sm_snprintf(buf, sizeof buf,
d663 1
a663 1
		addheader("Subject", buf, 0, ee);
d666 2
a667 2
	(void) sm_snprintf(buf, sizeof buf, "auto-generated (%s)", p);
	addheader("Auto-Submitted", buf, 0, ee);
d672 1
a672 1
		      RF_COPYALL|RF_SENDERADDR, '\0', NULL, e, false) == NULL)
d685 3
a687 3
	macdefine(&ee->e_macro, A_PERM, 'f', "\201n");
	macdefine(&ee->e_macro, A_PERM, 'x', "Mail Delivery Subsystem");
	eatheader(ee, true, true);
d690 1
a690 1
	markstats(ee, NULLADDR, false);
d696 1
a696 2
	dropenvelope(ee, true, false);
	sm_rpool_free(ee->e_rpool);
d720 1
a720 1
**		separator -- any possible MIME separator (unused).
d740 1
a740 1
	register SM_FILE_T *xfile;
a742 1
	char actual[MAXLINE];
d765 1
a765 1
		(void) sm_strlcpyn(buf, sizeof buf, 2, "--", e->e_msgboundary);
d774 1
a774 1
	pm_notify = false;
d777 1
a777 1
		pm_notify = true;
d799 2
a800 3
	(void) sm_snprintf(buf, sizeof buf,
		"The original message was received at %s",
		arpadate(ctime(&e->e_parent->e_ctime)));
d808 1
a808 2
		(void) sm_strlcpyn(buf, sizeof buf, 2, "with id ",
			e->e_parent->e_id);
d832 1
a832 2
				while (sm_io_fgets(xfile, SM_TIME_DEFAULT, buf,
						   sizeof buf) != NULL)
d838 1
a838 1
				(void) sm_io_close(xfile, SM_TIME_DEFAULT);
d854 1
a854 2
	/* permanent fatal errors */
	printheader = true;
d865 1
a865 1
			printheader = false;
d868 2
a869 2
		(void) sm_strlcpy(buf, shortenstring(q->q_paddr, MAXSHORTSTR),
				  sizeof buf);
d873 3
a875 4
			(void) sm_snprintf(buf, sizeof buf,
				"    (reason: %s)",
				shortenstring(exitstat(q->q_rstatus),
					      MAXSHORTSTR));
d880 3
a882 4
			(void) sm_snprintf(buf, sizeof buf,
				"    (expanded from: %s)",
				shortenstring(q->q_alias->q_paddr,
					      MAXSHORTSTR));
d889 1
a889 2
	/* transient non-fatal errors */
	printheader = true;
a893 1
		    !bitset(QBYNDELAY, q->q_flags) ||
d901 1
a901 1
			printheader = false;
d904 2
a905 2
		(void) sm_strlcpy(buf, shortenstring(q->q_paddr, MAXSHORTSTR),
				  sizeof buf);
d909 3
a911 4
			(void) sm_snprintf(buf, sizeof buf,
				"    (expanded from: %s)",
				shortenstring(q->q_alias->q_paddr,
					      MAXSHORTSTR));
d918 1
a918 2
	/* successful delivery notifications */
	printheader = true;
a922 1
		    bitset(QBYNDELAY, q->q_flags) ||
a924 4
		else if (bitset(QBYNRELAY, q->q_flags))
			p = "Deliver-By notify: relayed";
		else if (bitset(QBYTRACE, q->q_flags))
			p = "Deliver-By trace: relayed";
d945 1
a945 1
			printheader = false;
d948 1
a948 1
		(void) sm_snprintf(buf, sizeof buf, "%s  (%s)",
d953 3
a955 4
			(void) sm_snprintf(buf, sizeof buf,
				"    (expanded from: %s)",
				shortenstring(q->q_alias->q_paddr,
					      MAXSHORTSTR));
d966 1
a966 1
	(void) sm_io_flush(smioout, SM_TIME_DEFAULT);
d974 1
a974 1
		printheader = true;
d977 2
a978 3
			(void) sm_io_flush(e->e_xfp, SM_TIME_DEFAULT);
		while (sm_io_fgets(e->e_parent->e_xfp, SM_TIME_DEFAULT, buf,
				   sizeof buf) != NULL)
d983 1
a983 1
			printheader = false;
d996 2
d999 1
a999 1
		(void) sm_strlcpyn(buf, sizeof buf, 2, "--", e->e_msgboundary);
d1011 1
a1011 1
			(void) sm_snprintf(buf, sizeof buf,
d1018 1
a1018 2
		(void) sm_snprintf(buf, sizeof buf,
				   "Reporting-MTA: dns; %.800s", MyHostName);
d1030 1
a1030 1
			(void) sm_snprintf(buf, sizeof buf,
d1037 1
a1037 1
		(void) sm_strlcpyn(buf, sizeof buf, 2, "Arrival-Date: ",
a1040 12
		/* Deliver-By-Date: -- when it should have been delivered */
		if (IS_DLVR_BY(e->e_parent))
		{
			time_t dbyd;

			dbyd = e->e_parent->e_ctime + e->e_parent->e_deliver_by;
			(void) sm_strlcpyn(buf, sizeof buf, 2,
					"Deliver-By-Date: ",
					arpadate(ctime(&dbyd)));
			putline(buf, mci);
		}

d1047 1
a1072 6
			else if (bitset(QBYTRACE, q->q_flags))
				action = "relayed (Deliver-By trace mode)";
			else if (bitset(QBYNDELAY, q->q_flags))
				action = "delayed (Deliver-By notify mode)";
			else if (bitset(QBYNRELAY, q->q_flags))
				action = "relayed (Deliver-By notify mode)";
d1081 1
a1081 1
				(void) sm_snprintf(buf, sizeof buf,
d1087 51
a1137 3
			/* Figure out actual recipient */
			actual[0] = '\0';
			if (q->q_user[0] != '\0')
d1145 1
a1145 1
				if (sm_strcasecmp(p, "rfc822") == 0 &&
d1148 4
a1151 5
					(void) sm_snprintf(actual,
							   sizeof actual,
							   "%s; %.700s@@%.100s",
							   p, q->q_user,
							   MyHostName);
d1155 3
a1157 4
					(void) sm_snprintf(actual,
							   sizeof actual,
							   "%s; %.800s",
							   p, q->q_user);
a1158 31
			}

			/* Final-Recipient: -- the name from the RCPT command */
			if (q->q_finalrcpt == NULL)
			{
				/* should never happen */
				sm_syslog(LOG_ERR, e->e_id,
					  "returntosender: q_finalrcpt is NULL");

				/* try to fall back to the actual recipient */
				if (actual[0] != '\0')
					q->q_finalrcpt = sm_rpool_strdup_x(e->e_rpool,
									   actual);
			}

			if (q->q_finalrcpt != NULL)
			{
				(void) sm_snprintf(buf, sizeof buf,
						   "Final-Recipient: %s",
						   q->q_finalrcpt);
				putline(buf, mci);
			}

			/* X-Actual-Recipient: -- the real problem address */
			if (actual[0] != '\0' &&
			    q->q_finalrcpt != NULL &&
			    strcmp(actual, q->q_finalrcpt) != 0)
			{
				(void) sm_snprintf(buf, sizeof buf,
						   "X-Actual-Recipient: %s",
						   actual);
d1163 1
a1163 2
			(void) sm_strlcpyn(buf, sizeof buf, 2, "Action: ",
				action);
d1175 1
a1175 1
			(void) sm_strlcpyn(buf, sizeof buf, 2, "Status: ", p);
d1184 1
a1184 1
				(void) sm_snprintf(buf, sizeof buf,
d1199 1
a1199 1
				(void) sm_snprintf(buf, sizeof buf,
d1207 3
a1209 3
				q->q_statdate = curtime();
			(void) sm_strlcpyn(buf, sizeof buf, 2,
					"Last-Attempt-Date: ",
d1220 2
a1221 2
				(void) sm_strlcpyn(buf, sizeof buf, 2,
					 "Will-Retry-Until: ",
d1248 1
a1248 1
			(void) sm_strlcpyn(buf, sizeof buf, 2, "--",
d1252 1
a1252 1
			(void) sm_strlcpyn(buf, sizeof buf, 2, "Content-Type: ",
d1259 1
a1259 1
			if (p != NULL && sm_strcasecmp(p, "binary") != 0)
d1266 1
a1266 1
				(void) sm_snprintf(buf, sizeof buf,
d1292 1
a1292 2
		(void) sm_strlcpyn(buf, sizeof buf, 3, "--", e->e_msgboundary,
				   "--");
d1296 1
a1296 1
	(void) sm_io_flush(mci->mci_out, SM_TIME_DEFAULT);
a1312 5
**
**	Storage Management:
**		smtptodsn() returns a pointer to a character string literal,
**		which will remain valid forever, and thus does not need to
**		be copied.  Current code relies on this property.
a1406 5
	if (nbogus < 0)
	{
		/* since nbogus is ssize_t and wrapped, 2 * size_t would wrap */
		syserr("!xtextify string too long");
	}
d1415 2
a1416 2
			sm_free(bp); /* XXX */
		bp = sm_pmalloc_x(l);
d1468 1
a1468 1
			sm_free(bp); /* XXX */
d1530 2
a1531 2
**		true -- if 's' is legal xtext.
**		false -- if it has any illegal characters in it.
d1546 1
a1546 1
				return false;
d1549 1
a1549 1
				return false;
d1552 1
a1552 1
			return false;
d1554 1
a1554 1
	return true;
d1566 2
a1567 2
**		true -- address was modified
**		false -- address could not be pruned
a1579 1
	int braclev;
d1587 2
a1588 23
		return false;

	/*
	**  Can't simply find the first ':' is the address might be in the
	**  form:  "<@@[IPv6:::1]:user@@host>" and the first ':' in inside
	**  the IPv6 address.
	*/

	start = addr;
	braclev = 0;
	while (*start != '\0')
	{
		if (*start == ':' && braclev <= 0)
			break;
		else if (*start == '[')
			braclev++;
		else if (*start == ']' && braclev > 0)
			braclev--;
		start++;
	}
	if (braclev > 0 || *start != ':')
		return false;

d1590 2
a1591 2
	if (at == NULL || at < start)
		return false;
d1595 3
a1597 3
	if (i >= sizeof hostbuf)
		return false;
	(void) sm_strlcpy(hostbuf, at + 1, sizeof hostbuf);
d1600 1
a1600 1
	while (start != NULL)
d1602 1
a1602 2
		if (getmxrr(hostbuf, mxhosts, NULL, false,
			    &rcode, true, NULL) > 0)
d1604 2
a1605 3
			(void) sm_strlcpy(addr + 1, start + 1,
					  strlen(addr) - 1);
			return true;
d1611 2
a1612 2
		    strlen(comma + 2) < sizeof hostbuf)
			(void) sm_strlcpy(hostbuf, comma + 2, sizeof hostbuf);
d1619 1
a1619 1
	return false;
@


