head	1.33;
access;
symbols
	OPENBSD_5_6:1.32.0.6
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.30.0.2
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.29.0.6
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.4
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.28.0.12
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.10
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.6
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.8
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.4
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.27.0.4
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.26.0.2
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.23.0.4
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.16.0.4
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2014.09.17.18.49.52;	author matthieu;	state dead;
branches;
next	1.32;
commitid	M7i5giHIoz3DMlTU;

1.32
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.30;

1.30
date	2012.12.26.11.44.12;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2011.05.17.15.54.24;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2007.04.04.14.43.49;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2006.08.13.13.01.48;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.22.18.43.56;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2005.04.08.16.00.51;	author millert;	state Exp;
branches
	1.23.2.1
	1.23.4.1;
next	1.22;

1.22
date	2004.12.16.00.21.31;	author millert;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2004.09.18.04.08.35;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.24.03.59.27;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.11.19.44.08;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.19.01.41.14;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.17.17.31.41;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.29.19.44.01;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.03.17.31.21;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.01.19.59.23;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.09.15.02.23.36;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.26.04.48.55;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.03.17.25.47;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.18.00.49.28;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.01.17.18.30;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.11.19.02.50;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.01.01.01.41;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.29.01.31.16;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.28.02.43.55;	author millert;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.01.15.21.09.10;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.07.19.20.44;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.48;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.48;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.18;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.51;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.31.43;	author miod;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.31.01.47.58;	author jason;	state Exp;
branches;
next	;

1.22.2.1
date	2006.03.24.05.42.48;	author brad;	state Exp;
branches;
next	;

1.23.2.1
date	2006.03.24.05.56.18;	author brad;	state Exp;
branches;
next	;

1.23.4.1
date	2006.03.25.01.49.38;	author brad;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2010, 2012, 2013 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>
#if MILTER
# include <libmilter/mfapi.h>
# include <libmilter/mfdef.h>
#endif /* MILTER */

SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.1016 2013/11/22 20:51:56 ca Exp $")

#include <sm/time.h>
#include <sm/fdset.h>

#if SASL || STARTTLS
# include "sfsasl.h"
#endif /* SASL || STARTTLS */
#if SASL
# define ENC64LEN(l)	(((l) + 2) * 4 / 3 + 1)
static int saslmechs __P((sasl_conn_t *, char **));
#endif /* SASL */
#if STARTTLS
#  include <openssl/err.h>
# include <sysexits.h>

static SSL_CTX	*srv_ctx = NULL;	/* TLS server context */
static SSL	*srv_ssl = NULL;	/* per connection context */

static bool	tls_ok_srv = false;

# define TLS_VERIFY_CLIENT() tls_set_verify(srv_ctx, srv_ssl, \
				bitset(SRV_VRFY_CLT, features))
#endif /* STARTTLS */

#if _FFR_DM_ONE
static bool	NotFirstDelivery = false;
#endif /* _FFR_DM_ONE */

/* server features */
#define SRV_NONE	0x0000	/* none... */
#define SRV_OFFER_TLS	0x0001	/* offer STARTTLS */
#define SRV_VRFY_CLT	0x0002	/* request a cert */
#define SRV_OFFER_AUTH	0x0004	/* offer AUTH */
#define SRV_OFFER_ETRN	0x0008	/* offer ETRN */
#define SRV_OFFER_VRFY	0x0010	/* offer VRFY (not yet used) */
#define SRV_OFFER_EXPN	0x0020	/* offer EXPN */
#define SRV_OFFER_VERB	0x0040	/* offer VERB */
#define SRV_OFFER_DSN	0x0080	/* offer DSN */
#if PIPELINING
# define SRV_OFFER_PIPE	0x0100	/* offer PIPELINING */
# if _FFR_NO_PIPE
#  define SRV_NO_PIPE	0x0200	/* disable PIPELINING, sleep if used */
# endif /* _FFR_NO_PIPE */
#endif /* PIPELINING */
#define SRV_REQ_AUTH	0x0400	/* require AUTH */
#define SRV_REQ_SEC	0x0800	/* require security - equiv to AuthOptions=p */
#define SRV_TMP_FAIL	0x1000	/* ruleset caused a temporary failure */

static unsigned int	srvfeatures __P((ENVELOPE *, char *, unsigned int));

#define	STOP_ATTACK	((time_t) -1)
static time_t	checksmtpattack __P((volatile unsigned int *, unsigned int,
				     bool, char *, ENVELOPE *));
static void	printvrfyaddr __P((ADDRESS *, bool, bool));
static char	*skipword __P((char *volatile, char *));
static void	setup_smtpd_io __P((void));

#if SASL
# if SASL >= 20000
static int reset_saslconn __P((sasl_conn_t **_conn, char *_hostname,
				char *_remoteip, char *_localip,
				char *_auth_id, sasl_ssf_t *_ext_ssf));

# define RESET_SASLCONN	\
	do							\
	{							\
		result = reset_saslconn(&conn, AuthRealm, remoteip, \
					localip, auth_id, &ext_ssf); \
		if (result != SASL_OK)				\
			sasl_ok = false;			\
	} while (0)

# else /* SASL >= 20000 */
static int reset_saslconn __P((sasl_conn_t **_conn, char *_hostname,
				struct sockaddr_in *_saddr_r,
				struct sockaddr_in *_saddr_l,
				sasl_external_properties_t *_ext_ssf));
# define RESET_SASLCONN	\
	do							\
	{							\
		result = reset_saslconn(&conn, AuthRealm, &saddr_r, \
					&saddr_l, &ext_ssf);	\
		if (result != SASL_OK)				\
			sasl_ok = false;			\
	} while (0)

# endif /* SASL >= 20000 */
#endif /* SASL */

extern ENVELOPE	BlankEnvelope;

#define NBADRCPTS						\
	do							\
	{							\
		char buf[16];					\
		(void) sm_snprintf(buf, sizeof(buf), "%d",	\
			BadRcptThrottle > 0 && n_badrcpts > BadRcptThrottle \
				? n_badrcpts - 1 : n_badrcpts);	\
		macdefine(&e->e_macro, A_TEMP, macid("{nbadrcpts}"), buf); \
	} while (0)

#define SKIP_SPACE(s)	while (isascii(*s) && isspace(*s))	\
				(s)++

/*
**  PARSE_ESMTP_ARGS -- parse EMSTP arguments (for MAIL, RCPT)
**
**	Parameters:
**		e -- the envelope
**		addr_st -- address (RCPT only)
**		p -- read buffer
**		delimptr -- current position in read buffer
**		which -- MAIL/RCPT
**		args -- arguments (output)
**		esmtp_args -- function to process a single ESMTP argument
**
**	Returns:
**		none
*/

void
parse_esmtp_args(e, addr_st, p, delimptr, which, args, esmtp_args)
	ENVELOPE *e;
	ADDRESS *addr_st;
	char *p;
	char *delimptr;
	char *which;
	char *args[];
	esmtp_args_F esmtp_args;
{
	int argno;

	argno = 0;
	if (args != NULL)
		args[argno++] = p;
	p = delimptr;
	while (p != NULL && *p != '\0')
	{
		char *kp;
		char *vp = NULL;
		char *equal = NULL;

		/* locate the beginning of the keyword */
		SKIP_SPACE(p);
		if (*p == '\0')
			break;
		kp = p;

		/* skip to the value portion */
		while ((isascii(*p) && isalnum(*p)) || *p == '-')
			p++;
		if (*p == '=')
		{
			equal = p;
			*p++ = '\0';
			vp = p;

			/* skip to the end of the value */
			while (*p != '\0' && *p != ' ' &&
			       !(isascii(*p) && iscntrl(*p)) &&
			       *p != '=')
				p++;
		}

		if (*p != '\0')
			*p++ = '\0';

		if (tTd(19, 1))
			sm_dprintf("%s: got arg %s=\"%s\"\n", which, kp,
				vp == NULL ? "<null>" : vp);

		esmtp_args(addr_st, kp, vp, e);
		if (equal != NULL)
			*equal = '=';
		if (args != NULL)
			args[argno] = kp;
		argno++;
		if (argno >= MAXSMTPARGS - 1)
			usrerr("501 5.5.4 Too many parameters");
		if (Errors > 0)
			break;
	}
	if (args != NULL)
		args[argno] = NULL;
}

/*
**  SMTP -- run the SMTP protocol.
**
**	Parameters:
**		nullserver -- if non-NULL, rejection message for
**			(almost) all SMTP commands.
**		d_flags -- daemon flags
**		e -- the envelope.
**
**	Returns:
**		never.
**
**	Side Effects:
**		Reads commands from the input channel and processes them.
*/

/*
**  Notice: The smtp server doesn't have a session context like the client
**	side has (mci). Therefore some data (session oriented) is allocated
**	or assigned to the "wrong" structure (esp. STARTTLS, AUTH).
**	This should be fixed in a successor version.
*/

struct cmd
{
	char	*cmd_name;	/* command name */
	int	cmd_code;	/* internal code, see below */
};

/* values for cmd_code */
#define CMDERROR	0	/* bad command */
#define CMDMAIL	1	/* mail -- designate sender */
#define CMDRCPT	2	/* rcpt -- designate recipient */
#define CMDDATA	3	/* data -- send message text */
#define CMDRSET	4	/* rset -- reset state */
#define CMDVRFY	5	/* vrfy -- verify address */
#define CMDEXPN	6	/* expn -- expand address */
#define CMDNOOP	7	/* noop -- do nothing */
#define CMDQUIT	8	/* quit -- close connection and die */
#define CMDHELO	9	/* helo -- be polite */
#define CMDHELP	10	/* help -- give usage info */
#define CMDEHLO	11	/* ehlo -- extended helo (RFC 1425) */
#define CMDETRN	12	/* etrn -- flush queue */
#if SASL
# define CMDAUTH	13	/* auth -- SASL authenticate */
#endif /* SASL */
#if STARTTLS
# define CMDSTLS	14	/* STARTTLS -- start TLS session */
#endif /* STARTTLS */
/* non-standard commands */
#define CMDVERB	17	/* verb -- go into verbose mode */
/* unimplemented commands from RFC 821 */
#define CMDUNIMPL	19	/* unimplemented rfc821 commands */
/* use this to catch and log "door handle" attempts on your system */
#define CMDLOGBOGUS	23	/* bogus command that should be logged */
/* debugging-only commands, only enabled if SMTPDEBUG is defined */
#define CMDDBGQSHOW	24	/* showq -- show send queue */
#define CMDDBGDEBUG	25	/* debug -- set debug mode */

/*
**  Note: If you change this list, remember to update 'helpfile'
*/

static struct cmd	CmdTab[] =
{
	{ "mail",	CMDMAIL		},
	{ "rcpt",	CMDRCPT		},
	{ "data",	CMDDATA		},
	{ "rset",	CMDRSET		},
	{ "vrfy",	CMDVRFY		},
	{ "expn",	CMDEXPN		},
	{ "help",	CMDHELP		},
	{ "noop",	CMDNOOP		},
	{ "quit",	CMDQUIT		},
	{ "helo",	CMDHELO		},
	{ "ehlo",	CMDEHLO		},
	{ "etrn",	CMDETRN		},
	{ "verb",	CMDVERB		},
	{ "send",	CMDUNIMPL	},
	{ "saml",	CMDUNIMPL	},
	{ "soml",	CMDUNIMPL	},
	{ "turn",	CMDUNIMPL	},
#if SASL
	{ "auth",	CMDAUTH,	},
#endif /* SASL */
#if STARTTLS
	{ "starttls",	CMDSTLS,	},
#endif /* STARTTLS */
    /* remaining commands are here only to trap and log attempts to use them */
	{ "showq",	CMDDBGQSHOW	},
	{ "debug",	CMDDBGDEBUG	},
	{ "wiz",	CMDLOGBOGUS	},

	{ NULL,		CMDERROR	}
};

static char	*CurSmtpClient;		/* who's at the other end of channel */

#ifndef MAXBADCOMMANDS
# define MAXBADCOMMANDS 25	/* maximum number of bad commands */
#endif /* ! MAXBADCOMMANDS */
#ifndef MAXHELOCOMMANDS
# define MAXHELOCOMMANDS 3	/* max HELO/EHLO commands before slowdown */
#endif /* ! MAXHELOCOMMANDS */
#ifndef MAXVRFYCOMMANDS
# define MAXVRFYCOMMANDS 6	/* max VRFY/EXPN commands before slowdown */
#endif /* ! MAXVRFYCOMMANDS */
#ifndef MAXETRNCOMMANDS
# define MAXETRNCOMMANDS 8	/* max ETRN commands before slowdown */
#endif /* ! MAXETRNCOMMANDS */
#ifndef MAXTIMEOUT
# define MAXTIMEOUT (4 * 60)	/* max timeout for bad commands */
#endif /* ! MAXTIMEOUT */

/*
**  Maximum shift value to compute timeout for bad commands.
**  This introduces an upper limit of 2^MAXSHIFT for the timeout.
*/

#ifndef MAXSHIFT
# define MAXSHIFT 8
#endif /* ! MAXSHIFT */
#if MAXSHIFT > 31
 ERROR _MAXSHIFT > 31 is invalid
#endif /* MAXSHIFT */


#if MAXBADCOMMANDS > 0
# define STOP_IF_ATTACK(r)	do		\
	{					\
		if ((r) == STOP_ATTACK)		\
			goto stopattack;	\
	} while (0)

#else /* MAXBADCOMMANDS > 0 */
# define STOP_IF_ATTACK(r)	r
#endif /* MAXBADCOMMANDS > 0 */


#if SM_HEAP_CHECK
static SM_DEBUG_T DebugLeakSmtp = SM_DEBUG_INITIALIZER("leak_smtp",
	"@@(#)$Debug: leak_smtp - trace memory leaks during SMTP processing $");
#endif /* SM_HEAP_CHECK */

typedef struct
{
	bool		sm_gotmail;	/* mail command received */
	unsigned int	sm_nrcpts;	/* number of successful RCPT commands */
	bool		sm_discard;
#if MILTER
	bool		sm_milterize;
	bool		sm_milterlist;	/* any filters in the list? */
	milters_T	sm_milters;

	/* e_nrcpts from envelope before recipient() call */
	unsigned int	sm_e_nrcpts_orig;
#endif /* MILTER */
	char		*sm_quarmsg;	/* carry quarantining across messages */
} SMTP_T;

static bool	smtp_data __P((SMTP_T *, ENVELOPE *));

#define MSG_TEMPFAIL "451 4.3.2 Please try again later"

#if MILTER
# define MILTER_ABORT(e)	milter_abort((e))

# define MILTER_REPLY(str)						\
	{								\
		int savelogusrerrs = LogUsrErrs;			\
									\
		milter_cmd_fail = true;					\
		switch (state)						\
		{							\
		  case SMFIR_SHUTDOWN:					\
			if (MilterLogLevel > 3)				\
			{						\
				sm_syslog(LOG_INFO, e->e_id,		\
					  "Milter: %s=%s, reject=421, errormode=4",	\
					  str, addr);			\
				LogUsrErrs = false;			\
			}						\
			{						\
				bool tsave = QuickAbort;		\
									\
				QuickAbort = false;			\
				usrerr("421 4.3.0 closing connection");	\
				QuickAbort = tsave;			\
				e->e_sendqueue = NULL;			\
				goto doquit;				\
			}						\
			break;						\
		  case SMFIR_REPLYCODE:					\
			if (MilterLogLevel > 3)				\
			{						\
				sm_syslog(LOG_INFO, e->e_id,		\
					  "Milter: %s=%s, reject=%s",	\
					  str, addr, response);		\
				LogUsrErrs = false;			\
			}						\
			if (strncmp(response, "421 ", 4) == 0		\
			    || strncmp(response, "421-", 4) == 0)	\
			{						\
				bool tsave = QuickAbort;		\
									\
				QuickAbort = false;			\
				usrerr(response);			\
				QuickAbort = tsave;			\
				e->e_sendqueue = NULL;			\
				goto doquit;				\
			}						\
			else						\
				usrerr(response);			\
			break;						\
									\
		  case SMFIR_REJECT:					\
			if (MilterLogLevel > 3)				\
			{						\
				sm_syslog(LOG_INFO, e->e_id,		\
					  "Milter: %s=%s, reject=550 5.7.1 Command rejected", \
					  str, addr);			\
				LogUsrErrs = false;			\
			}						\
			usrerr("550 5.7.1 Command rejected");		\
			break;						\
									\
		  case SMFIR_DISCARD:					\
			if (MilterLogLevel > 3)				\
				sm_syslog(LOG_INFO, e->e_id,		\
					  "Milter: %s=%s, discard",	\
					  str, addr);			\
			e->e_flags |= EF_DISCARD;			\
			milter_cmd_fail = false;			\
			break;						\
									\
		  case SMFIR_TEMPFAIL:					\
			if (MilterLogLevel > 3)				\
			{						\
				sm_syslog(LOG_INFO, e->e_id,		\
					  "Milter: %s=%s, reject=%s",	\
					  str, addr, MSG_TEMPFAIL);	\
				LogUsrErrs = false;			\
			}						\
			usrerr(MSG_TEMPFAIL);				\
			break;						\
		  default:						\
			milter_cmd_fail = false;			\
			break;						\
		}							\
		LogUsrErrs = savelogusrerrs;				\
		if (response != NULL)					\
			sm_free(response); /* XXX */			\
	}

#else /* MILTER */
# define MILTER_ABORT(e)
#endif /* MILTER */

/* clear all SMTP state (for HELO/EHLO/RSET) */
#define CLEAR_STATE(cmd)					\
do								\
{								\
	/* abort milter filters */				\
	MILTER_ABORT(e);					\
								\
	if (smtp.sm_nrcpts > 0)					\
	{							\
		logundelrcpts(e, cmd, 10, false);		\
		smtp.sm_nrcpts = 0;				\
		macdefine(&e->e_macro, A_PERM,			\
			  macid("{nrcpts}"), "0");		\
	}							\
								\
	e->e_sendqueue = NULL;					\
	e->e_flags |= EF_CLRQUEUE;				\
								\
	if (tTd(92, 2))						\
		sm_dprintf("CLEAR_STATE: e_id=%s, EF_LOGSENDER=%d, LogLevel=%d\n",\
			e->e_id, bitset(EF_LOGSENDER, e->e_flags), LogLevel);\
	if (LogLevel > 4 && bitset(EF_LOGSENDER, e->e_flags))	\
		logsender(e, NULL);				\
	e->e_flags &= ~EF_LOGSENDER;				\
								\
	/* clean up a bit */					\
	smtp.sm_gotmail = false;				\
	SuprErrs = true;					\
	(void) dropenvelope(e, true, false);			\
	sm_rpool_free(e->e_rpool);				\
	e = newenvelope(e, CurEnv, sm_rpool_new_x(NULL));	\
	CurEnv = e;						\
	e->e_features = features;				\
								\
	/* put back discard bit */				\
	if (smtp.sm_discard)					\
		e->e_flags |= EF_DISCARD;			\
								\
	/* restore connection quarantining */			\
	if (smtp.sm_quarmsg == NULL)				\
	{							\
		e->e_quarmsg = NULL;				\
		macdefine(&e->e_macro, A_PERM,			\
			macid("{quarantine}"), "");		\
	}							\
	else							\
	{							\
		e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool,	\
						smtp.sm_quarmsg);	\
		macdefine(&e->e_macro, A_PERM, macid("{quarantine}"),	\
			  e->e_quarmsg);			\
	}							\
} while (0)

/* sleep to flatten out connection load */
#define MIN_DELAY_LOG	15	/* wait before logging this again */

/* is it worth setting the process title for 1s? */
#define DELAY_CONN(cmd)						\
	if (DelayLA > 0 && (CurrentLA = getla()) >= DelayLA)	\
	{							\
		time_t dnow;					\
								\
		sm_setproctitle(true, e,			\
				"%s: %s: delaying %s: load average: %d", \
				qid_printname(e), CurSmtpClient,	\
				cmd, DelayLA);	\
		if (LogLevel > 8 && (dnow = curtime()) > log_delay)	\
		{						\
			sm_syslog(LOG_INFO, e->e_id,		\
				  "delaying=%s, load average=%d >= %d",	\
				  cmd, CurrentLA, DelayLA);		\
			log_delay = dnow + MIN_DELAY_LOG;	\
		}						\
		(void) sleep(1);				\
		sm_setproctitle(true, e, "%s %s: %.80s",	\
				qid_printname(e), CurSmtpClient, inp);	\
	}

static bool SevenBitInput_Saved;	/* saved version of SevenBitInput */

void
smtp(nullserver, d_flags, e)
	char *volatile nullserver;
	BITMAP256 d_flags;
	register ENVELOPE *volatile e;
{
	register char *volatile p;
	register struct cmd *volatile c = NULL;
	char *cmd;
	auto ADDRESS *vrfyqueue;
	ADDRESS *a;
	volatile bool gothello;		/* helo command received */
	bool vrfy;			/* set if this is a vrfy command */
	char *volatile protocol;	/* sending protocol */
	char *volatile sendinghost;	/* sending hostname */
	char *volatile peerhostname;	/* name of SMTP peer or "localhost" */
	auto char *delimptr;
	char *id;
	volatile unsigned int n_badcmds = 0;	/* count of bad commands */
	volatile unsigned int n_badrcpts = 0;	/* number of rejected RCPT */
	volatile unsigned int n_verifies = 0;	/* count of VRFY/EXPN */
	volatile unsigned int n_etrn = 0;	/* count of ETRN */
	volatile unsigned int n_noop = 0;	/* count of NOOP/VERB/etc */
	volatile unsigned int n_helo = 0;	/* count of HELO/EHLO */
	bool ok;
	volatile bool first;
	volatile bool tempfail = false;
	volatile time_t wt;		/* timeout after too many commands */
	volatile time_t previous;	/* time after checksmtpattack() */
	volatile bool lognullconnection = true;
	register char *q;
	SMTP_T smtp;
	char *addr;
	char *greetcode = "220";
	char *hostname;			/* my hostname ($j) */
	QUEUE_CHAR *new;
	char *args[MAXSMTPARGS];
	char inp[MAXINPLINE];
#if MAXINPLINE < MAXLINE
 ERROR _MAXINPLINE must NOT be less than _MAXLINE: MAXINPLINE < MAXLINE
#endif /* MAXINPLINE < MAXLINE */
	char cmdbuf[MAXLINE];
#if SASL
	sasl_conn_t *conn;
	volatile bool sasl_ok;
	volatile unsigned int n_auth = 0;	/* count of AUTH commands */
	bool ismore;
	int result;
	volatile int authenticating;
	char *user;
	char *in, *out2;
# if SASL >= 20000
	char *auth_id = NULL;
	const char *out;
	sasl_ssf_t ext_ssf;
	char localip[60], remoteip[60];
# else /* SASL >= 20000 */
	char *out;
	const char *errstr;
	sasl_external_properties_t ext_ssf;
	struct sockaddr_in saddr_l;
	struct sockaddr_in saddr_r;
# endif /* SASL >= 20000 */
	sasl_security_properties_t ssp;
	sasl_ssf_t *ssf;
	unsigned int inlen, out2len;
	unsigned int outlen;
	char *volatile auth_type;
	char *mechlist;
	volatile unsigned int n_mechs;
	unsigned int len;
#else /* SASL */
#endif /* SASL */
	int r;
#if STARTTLS
	int rfd, wfd;
	volatile bool tls_active = false;
	volatile bool smtps = bitnset(D_SMTPS, d_flags);
	bool saveQuickAbort;
	bool saveSuprErrs;
	time_t tlsstart;
#endif /* STARTTLS */
	volatile unsigned int features;
#if PIPELINING
# if _FFR_NO_PIPE
	int np_log = 0;
# endif /* _FFR_NO_PIPE */
#endif /* PIPELINING */
	volatile time_t log_delay = (time_t) 0;
#if MILTER
	volatile bool milter_cmd_done, milter_cmd_safe;
	volatile bool milter_rcpt_added, milter_cmd_fail;
	ADDRESS addr_st;
# define p_addr_st	&addr_st
#else /* MILTER */
# define p_addr_st	NULL
#endif /* MILTER */
	size_t inplen;
#if _FFR_BADRCPT_SHUTDOWN
	int n_badrcpts_adj;
#endif /* _FFR_BADRCPT_SHUTDOWN */

	SevenBitInput_Saved = SevenBitInput;
	smtp.sm_nrcpts = 0;
#if MILTER
	smtp.sm_milterize = (nullserver == NULL);
	smtp.sm_milterlist = false;
	addr = NULL;
#endif /* MILTER */

	/* setup I/O fd correctly for the SMTP server */
	setup_smtpd_io();

#if SM_HEAP_CHECK
	if (sm_debug_active(&DebugLeakSmtp, 1))
	{
		sm_heap_newgroup();
		sm_dprintf("smtp() heap group #%d\n", sm_heap_group());
	}
#endif /* SM_HEAP_CHECK */

	/* XXX the rpool should be set when e is initialized in main() */
	e->e_rpool = sm_rpool_new_x(NULL);
	e->e_macro.mac_rpool = e->e_rpool;

	settime(e);
	sm_getla();
	peerhostname = RealHostName;
	if (peerhostname == NULL)
		peerhostname = "localhost";
	CurHostName = peerhostname;
	CurSmtpClient = macvalue('_', e);
	if (CurSmtpClient == NULL)
		CurSmtpClient = CurHostName;

	/* check_relay may have set discard bit, save for later */
	smtp.sm_discard = bitset(EF_DISCARD, e->e_flags);

#if PIPELINING
	/* auto-flush output when reading input */
	(void) sm_io_autoflush(InChannel, OutChannel);
#endif /* PIPELINING */

	sm_setproctitle(true, e, "server %s startup", CurSmtpClient);

	/* Set default features for server. */
	features = ((bitset(PRIV_NOETRN, PrivacyFlags) ||
		     bitnset(D_NOETRN, d_flags)) ? SRV_NONE : SRV_OFFER_ETRN)
		| (bitnset(D_AUTHREQ, d_flags) ? SRV_REQ_AUTH : SRV_NONE)
		| (bitset(PRIV_NOEXPN, PrivacyFlags) ? SRV_NONE
			: (SRV_OFFER_EXPN
			  | (bitset(PRIV_NOVERB, PrivacyFlags)
			     ? SRV_NONE : SRV_OFFER_VERB)))
		| ((bitset(PRIV_NORECEIPTS, PrivacyFlags) || !SendMIMEErrors)
			 ? SRV_NONE : SRV_OFFER_DSN)
#if SASL
		| (bitnset(D_NOAUTH, d_flags) ? SRV_NONE : SRV_OFFER_AUTH)
		| (bitset(SASL_SEC_NOPLAINTEXT, SASLOpts) ? SRV_REQ_SEC
							  : SRV_NONE)
#endif /* SASL */
#if PIPELINING
		| SRV_OFFER_PIPE
#endif /* PIPELINING */
#if STARTTLS
		| (bitnset(D_NOTLS, d_flags) ? SRV_NONE : SRV_OFFER_TLS)
		| (bitset(TLS_I_NO_VRFY, TLS_Srv_Opts) ? SRV_NONE
						       : SRV_VRFY_CLT)
#endif /* STARTTLS */
		;
	if (nullserver == NULL)
	{
		features = srvfeatures(e, CurSmtpClient, features);
		if (bitset(SRV_TMP_FAIL, features))
		{
			if (LogLevel > 4)
				sm_syslog(LOG_ERR, NOQID,
					  "ERROR: srv_features=tempfail, relay=%.100s, access temporarily disabled",
					  CurSmtpClient);
			nullserver = "450 4.3.0 Please try again later.";
		}
		else
		{
#if PIPELINING
# if _FFR_NO_PIPE
			if (bitset(SRV_NO_PIPE, features))
			{
				/* for consistency */
				features &= ~SRV_OFFER_PIPE;
			}
# endif /* _FFR_NO_PIPE */
#endif /* PIPELINING */
#if SASL
			if (bitset(SRV_REQ_SEC, features))
				SASLOpts |= SASL_SEC_NOPLAINTEXT;
			else
				SASLOpts &= ~SASL_SEC_NOPLAINTEXT;
#endif /* SASL */
		}
	}
	else if (strncmp(nullserver, "421 ", 4) == 0)
	{
		message(nullserver);
		goto doquit;
	}

	e->e_features = features;
	hostname = macvalue('j', e);
#if SASL
	if (AuthRealm == NULL)
		AuthRealm = hostname;
	sasl_ok = bitset(SRV_OFFER_AUTH, features);
	n_mechs = 0;
	authenticating = SASL_NOT_AUTH;

	/* SASL server new connection */
	if (sasl_ok)
	{
# if SASL >= 20000
		result = sasl_server_new("smtp", AuthRealm, NULL, NULL, NULL,
					 NULL, 0, &conn);
# elif SASL > 10505
		/* use empty realm: only works in SASL > 1.5.5 */
		result = sasl_server_new("smtp", AuthRealm, "", NULL, 0, &conn);
# else /* SASL >= 20000 */
		/* use no realm -> realm is set to hostname by SASL lib */
		result = sasl_server_new("smtp", AuthRealm, NULL, NULL, 0,
					 &conn);
# endif /* SASL >= 20000 */
		sasl_ok = result == SASL_OK;
		if (!sasl_ok)
		{
			if (LogLevel > 9)
				sm_syslog(LOG_WARNING, NOQID,
					  "AUTH error: sasl_server_new failed=%d",
					  result);
		}
	}
	if (sasl_ok)
	{
		/*
		**  SASL set properties for sasl
		**  set local/remote IP
		**  XXX Cyrus SASL v1 only supports IPv4
		**
		**  XXX where exactly are these used/required?
		**  Kerberos_v4
		*/

# if SASL >= 20000
		localip[0] = remoteip[0] = '\0';
#  if NETINET || NETINET6
		in = macvalue(macid("{daemon_family}"), e);
		if (in != NULL && (
#   if NETINET6
		    strcmp(in, "inet6") == 0 ||
#   endif /* NETINET6 */
		    strcmp(in, "inet") == 0))
		{
			SOCKADDR_LEN_T addrsize;
			SOCKADDR saddr_l;
			SOCKADDR saddr_r;

			addrsize = sizeof(saddr_r);
			if (getpeername(sm_io_getinfo(InChannel, SM_IO_WHAT_FD,
						      NULL),
					(struct sockaddr *) &saddr_r,
					&addrsize) == 0)
			{
				if (iptostring(&saddr_r, addrsize,
					       remoteip, sizeof(remoteip)))
				{
					sasl_setprop(conn, SASL_IPREMOTEPORT,
						     remoteip);
				}
				addrsize = sizeof(saddr_l);
				if (getsockname(sm_io_getinfo(InChannel,
							      SM_IO_WHAT_FD,
							      NULL),
						(struct sockaddr *) &saddr_l,
						&addrsize) == 0)
				{
					if (iptostring(&saddr_l, addrsize,
						       localip,
						       sizeof(localip)))
					{
						sasl_setprop(conn,
							     SASL_IPLOCALPORT,
							     localip);
					}
				}
			}
		}
#  endif /* NETINET || NETINET6 */
# else /* SASL >= 20000 */
#  if NETINET
		in = macvalue(macid("{daemon_family}"), e);
		if (in != NULL && strcmp(in, "inet") == 0)
		{
			SOCKADDR_LEN_T addrsize;

			addrsize = sizeof(struct sockaddr_in);
			if (getpeername(sm_io_getinfo(InChannel, SM_IO_WHAT_FD,
						      NULL),
					(struct sockaddr *)&saddr_r,
					&addrsize) == 0)
			{
				sasl_setprop(conn, SASL_IP_REMOTE, &saddr_r);
				addrsize = sizeof(struct sockaddr_in);
				if (getsockname(sm_io_getinfo(InChannel,
							      SM_IO_WHAT_FD,
							      NULL),
						(struct sockaddr *)&saddr_l,
						&addrsize) == 0)
					sasl_setprop(conn, SASL_IP_LOCAL,
						     &saddr_l);
			}
		}
#  endif /* NETINET */
# endif /* SASL >= 20000 */

		auth_type = NULL;
		mechlist = NULL;
		user = NULL;
# if 0
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			macid("{auth_author}"), NULL);
# endif /* 0 */

		/* set properties */
		(void) memset(&ssp, '\0', sizeof(ssp));

		/* XXX should these be options settable via .cf ? */
		/* ssp.min_ssf = 0; is default due to memset() */
		ssp.max_ssf = MaxSLBits;
		ssp.maxbufsize = MAXOUTLEN;
		ssp.security_flags = SASLOpts & SASL_SEC_MASK;
		sasl_ok = sasl_setprop(conn, SASL_SEC_PROPS, &ssp) == SASL_OK;

		if (sasl_ok)
		{
			/*
			**  external security strength factor;
			**	currently we have none so zero
			*/

# if SASL >= 20000
			ext_ssf = 0;
			auth_id = NULL;
			sasl_ok = ((sasl_setprop(conn, SASL_SSF_EXTERNAL,
						 &ext_ssf) == SASL_OK) &&
				   (sasl_setprop(conn, SASL_AUTH_EXTERNAL,
						 auth_id) == SASL_OK));
# else /* SASL >= 20000 */
			ext_ssf.ssf = 0;
			ext_ssf.auth_id = NULL;
			sasl_ok = sasl_setprop(conn, SASL_SSF_EXTERNAL,
					       &ext_ssf) == SASL_OK;
# endif /* SASL >= 20000 */
		}
		if (sasl_ok)
			n_mechs = saslmechs(conn, &mechlist);
	}
#endif /* SASL */

#if STARTTLS


	set_tls_rd_tmo(TimeOuts.to_nextcommand);
#endif /* STARTTLS */

#if MILTER
	if (smtp.sm_milterize)
	{
		char state;

		/* initialize mail filter connection */
		smtp.sm_milterlist = milter_init(e, &state, &smtp.sm_milters);
		switch (state)
		{
		  case SMFIR_REJECT:
			if (MilterLogLevel > 3)
				sm_syslog(LOG_INFO, e->e_id,
					  "Milter: initialization failed, rejecting commands");
			greetcode = "554";
			nullserver = "Command rejected";
			smtp.sm_milterize = false;
			break;

		  case SMFIR_TEMPFAIL:
			if (MilterLogLevel > 3)
				sm_syslog(LOG_INFO, e->e_id,
					  "Milter: initialization failed, temp failing commands");
			tempfail = true;
			smtp.sm_milterize = false;
			break;

		  case SMFIR_SHUTDOWN:
			if (MilterLogLevel > 3)
				sm_syslog(LOG_INFO, e->e_id,
					  "Milter: initialization failed, closing connection");
			tempfail = true;
			smtp.sm_milterize = false;
			message("421 4.7.0 %s closing connection",
					MyHostName);

			/* arrange to ignore send list */
			e->e_sendqueue = NULL;
			lognullconnection = false;
			goto doquit;
		}
	}

	if (smtp.sm_milterlist && smtp.sm_milterize &&
	    !bitset(EF_DISCARD, e->e_flags))
	{
		char state;
		char *response;

		q = macvalue(macid("{client_name}"), e);
		SM_ASSERT(q != NULL || OpMode == MD_SMTP);
		if (q == NULL)
			q = "localhost";
		response = milter_connect(q, RealHostAddr, e, &state);
		switch (state)
		{
		  case SMFIR_REPLYCODE:	/* REPLYCODE shouldn't happen */
		  case SMFIR_REJECT:
			if (MilterLogLevel > 3)
				sm_syslog(LOG_INFO, e->e_id,
					  "Milter: connect: host=%s, addr=%s, rejecting commands",
					  peerhostname,
					  anynet_ntoa(&RealHostAddr));
			greetcode = "554";
			nullserver = "Command rejected";
			smtp.sm_milterize = false;
			break;

		  case SMFIR_TEMPFAIL:
			if (MilterLogLevel > 3)
				sm_syslog(LOG_INFO, e->e_id,
					  "Milter: connect: host=%s, addr=%s, temp failing commands",
					  peerhostname,
					  anynet_ntoa(&RealHostAddr));
			tempfail = true;
			smtp.sm_milterize = false;
			break;

		  case SMFIR_SHUTDOWN:
			if (MilterLogLevel > 3)
				sm_syslog(LOG_INFO, e->e_id,
					  "Milter: connect: host=%s, addr=%s, shutdown",
					  peerhostname,
					  anynet_ntoa(&RealHostAddr));
			tempfail = true;
			smtp.sm_milterize = false;
			message("421 4.7.0 %s closing connection",
					MyHostName);

			/* arrange to ignore send list */
			e->e_sendqueue = NULL;
			goto doquit;
		}
		if (response != NULL)
			sm_free(response); /* XXX */
	}
#endif /* MILTER */

	/*
	**  Broken proxies and SMTP slammers
	**  push data without waiting, catch them
	*/

	if (
#if STARTTLS
	    !smtps &&
#endif /* STARTTLS */
	    *greetcode == '2' && nullserver == NULL)
	{
		time_t msecs = 0;
		char **pvp;
		char pvpbuf[PSBUFSIZE];

		/* Ask the rulesets how long to pause */
		pvp = NULL;
		r = rscap("greet_pause", peerhostname,
			  anynet_ntoa(&RealHostAddr), e,
			  &pvp, pvpbuf, sizeof(pvpbuf));
		if (r == EX_OK && pvp != NULL && pvp[0] != NULL &&
		    (pvp[0][0] & 0377) == CANONNET && pvp[1] != NULL)
		{
			msecs = strtol(pvp[1], NULL, 10);
		}

		if (msecs > 0)
		{
			int fd;
			fd_set readfds;
			struct timeval timeout;
			struct timeval bp, ep, tp; /* {begin,end,total}pause */
			int eoftest;

			/* pause for a moment */
			timeout.tv_sec = msecs / 1000;
			timeout.tv_usec = (msecs % 1000) * 1000;

			/* Obey RFC 2821: 4.3.5.2: 220 timeout of 5 minutes */
			if (timeout.tv_sec >= 300)
			{
				timeout.tv_sec = 300;
				timeout.tv_usec = 0;
			}

			/* check if data is on the socket during the pause */
			fd = sm_io_getinfo(InChannel, SM_IO_WHAT_FD, NULL);
			FD_ZERO(&readfds);
			SM_FD_SET(fd, &readfds);
			gettimeofday(&bp, NULL);
			if (select(fd + 1, FDSET_CAST &readfds,
			    NULL, NULL, &timeout) > 0 &&
			    FD_ISSET(fd, &readfds) &&
			    (eoftest = sm_io_getc(InChannel, SM_TIME_DEFAULT))
			    != SM_IO_EOF)
			{
				sm_io_ungetc(InChannel, SM_TIME_DEFAULT,
					     eoftest);
				gettimeofday(&ep, NULL);
				timersub(&ep, &bp, &tp);
				greetcode = "554";
				nullserver = "Command rejected";
				sm_syslog(LOG_INFO, e->e_id,
					  "rejecting commands from %s [%s] due to pre-greeting traffic after %d seconds",
					  peerhostname,
					  anynet_ntoa(&RealHostAddr),
					  (int) tp.tv_sec +
						(tp.tv_usec >= 500000 ? 1 : 0)
					 );
			}
		}
	}

#if STARTTLS
	/* If this an smtps connection, start TLS now */
	if (smtps)
	{
		Errors = 0;
		goto starttls;
	}

  greeting:

#endif /* STARTTLS */

	/* output the first line, inserting "ESMTP" as second word */
	if (*greetcode == '5')
		(void) sm_snprintf(inp, sizeof(inp),
				"%s not accepting messages", hostname);
	else
		expand(SmtpGreeting, inp, sizeof(inp), e);

	p = strchr(inp, '\n');
	if (p != NULL)
		*p++ = '\0';
	id = strchr(inp, ' ');
	if (id == NULL)
		id = &inp[strlen(inp)];
	if (p == NULL)
		(void) sm_snprintf(cmdbuf, sizeof(cmdbuf),
			 "%s %%.*s ESMTP%%s", greetcode);
	else
		(void) sm_snprintf(cmdbuf, sizeof(cmdbuf),
			 "%s-%%.*s ESMTP%%s", greetcode);
	message(cmdbuf, (int) (id - inp), inp, id);

	/* output remaining lines */
	while ((id = p) != NULL && (p = strchr(id, '\n')) != NULL)
	{
		*p++ = '\0';
		if (isascii(*id) && isspace(*id))
			id++;
		(void) sm_strlcpyn(cmdbuf, sizeof(cmdbuf), 2, greetcode, "-%s");
		message(cmdbuf, id);
	}
	if (id != NULL)
	{
		if (isascii(*id) && isspace(*id))
			id++;
		(void) sm_strlcpyn(cmdbuf, sizeof(cmdbuf), 2, greetcode, " %s");
		message(cmdbuf, id);
	}

	protocol = NULL;
	sendinghost = macvalue('s', e);

	/* If quarantining by a connect/ehlo action, save between messages */
	if (e->e_quarmsg == NULL)
		smtp.sm_quarmsg = NULL;
	else
		smtp.sm_quarmsg = newstr(e->e_quarmsg);

	/* sendinghost's storage must outlive the current envelope */
	if (sendinghost != NULL)
		sendinghost = sm_strdup_x(sendinghost);
	first = true;
	gothello = false;
	smtp.sm_gotmail = false;
	for (;;)
	{
	    SM_TRY
	    {
		QuickAbort = false;
		HoldErrs = false;
		SuprErrs = false;
		LogUsrErrs = false;
		OnlyOneError = true;
		e->e_flags &= ~(EF_VRFYONLY|EF_GLOBALERRS);
#if MILTER
		milter_cmd_fail = false;
#endif /* MILTER */

		/* setup for the read */
		e->e_to = NULL;
		Errors = 0;
		FileName = NULL;
		(void) sm_io_flush(smioout, SM_TIME_DEFAULT);

		/* read the input line */
		SmtpPhase = "server cmd read";
		sm_setproctitle(true, e, "server %s cmd read", CurSmtpClient);

		/* handle errors */
		if (sm_io_error(OutChannel) ||
		    (p = sfgets(inp, sizeof(inp), InChannel,
				TimeOuts.to_nextcommand, SmtpPhase)) == NULL)
		{
			char *d;

			d = macvalue(macid("{daemon_name}"), e);
			if (d == NULL)
				d = "stdin";
			/* end of file, just die */
			disconnect(1, e);

#if MILTER
			/* close out milter filters */
			milter_quit(e);
#endif /* MILTER */

			message("421 4.4.1 %s Lost input channel from %s",
				MyHostName, CurSmtpClient);
			if (LogLevel > (smtp.sm_gotmail ? 1 : 19))
				sm_syslog(LOG_NOTICE, e->e_id,
					  "lost input channel from %s to %s after %s",
					  CurSmtpClient, d,
					  (c == NULL || c->cmd_name == NULL) ? "startup" : c->cmd_name);
			/*
			**  If have not accepted mail (DATA), do not bounce
			**  bad addresses back to sender.
			*/

			if (bitset(EF_CLRQUEUE, e->e_flags))
				e->e_sendqueue = NULL;
			goto doquit;
		}

		/* also used by "proxy" check below */
		inplen = strlen(inp);
#if SASL
		/*
		**  SMTP AUTH requires accepting any length,
		**  at least for challenge/response. However, not imposing
		**  a limit is a bad idea (denial of service).
		*/

		if (authenticating != SASL_PROC_AUTH
		    && sm_strncasecmp(inp, "AUTH ", 5) != 0
		    && inplen > MAXLINE)
		{
			message("421 4.7.0 %s Command too long, possible attack %s",
				MyHostName, CurSmtpClient);
			sm_syslog(LOG_INFO, e->e_id,
				  "%s: SMTP violation, input too long: %lu",
				  CurSmtpClient, (unsigned long) inplen);
			goto doquit;
		}
#endif /* SASL */

		if (first)
		{
			size_t cmdlen;
			int idx;
			char *http_cmd;
			static char *http_cmds[] = { "GET", "POST",
						     "CONNECT", "USER", NULL };

			for (idx = 0; (http_cmd = http_cmds[idx]) != NULL;
			     idx++)
			{
				cmdlen = strlen(http_cmd);
				if (cmdlen < inplen &&
				    sm_strncasecmp(inp, http_cmd, cmdlen) == 0 &&
				    isascii(inp[cmdlen]) && isspace(inp[cmdlen]))
				{
					/* Open proxy, drop it */
					message("421 4.7.0 %s Rejecting open proxy %s",
						MyHostName, CurSmtpClient);
					sm_syslog(LOG_INFO, e->e_id,
						  "%s: probable open proxy: command=%.40s",
						  CurSmtpClient, inp);
					goto doquit;
				}
			}
			first = false;
		}

		/* clean up end of line */
		fixcrlf(inp, true);

#if PIPELINING
# if _FFR_NO_PIPE
		/*
		**  if there is more input and pipelining is disabled:
		**	delay ... (and maybe discard the input?)
		**  XXX this doesn't really work, at least in tests using
		**  telnet SM_IO_IS_READABLE only returns 1 if there were
		**  more than 2 input lines available.
		*/

		if (bitset(SRV_NO_PIPE, features) &&
		    sm_io_getinfo(InChannel, SM_IO_IS_READABLE, NULL) > 0)
		{
			if (++np_log < 3)
				sm_syslog(LOG_INFO, NOQID,
					  "unauthorized PIPELINING, sleeping, relay=%.100s",
					   CurSmtpClient);
			sleep(1);
		}

# endif /* _FFR_NO_PIPE */
#endif /* PIPELINING */

#if SASL
		if (authenticating == SASL_PROC_AUTH)
		{
# if 0
			if (*inp == '\0')
			{
				authenticating = SASL_NOT_AUTH;
				message("501 5.5.2 missing input");
				RESET_SASLCONN;
				continue;
			}
# endif /* 0 */
			if (*inp == '*' && *(inp + 1) == '\0')
			{
				authenticating = SASL_NOT_AUTH;

				/* RFC 2554 4. */
				message("501 5.0.0 AUTH aborted");
				RESET_SASLCONN;
				continue;
			}

			/* could this be shorter? XXX */
# if SASL >= 20000
			in = xalloc(strlen(inp) + 1);
			result = sasl_decode64(inp, strlen(inp), in,
					       strlen(inp), &inlen);
# else /* SASL >= 20000 */
			out = xalloc(strlen(inp));
			result = sasl_decode64(inp, strlen(inp), out, &outlen);
# endif /* SASL >= 20000 */
			if (result != SASL_OK)
			{
				authenticating = SASL_NOT_AUTH;

				/* RFC 2554 4. */
				message("501 5.5.4 cannot decode AUTH parameter %s",
					inp);
# if SASL >= 20000
				sm_free(in);
# endif /* SASL >= 20000 */
				RESET_SASLCONN;
				continue;
			}

# if SASL >= 20000
			result = sasl_server_step(conn,	in, inlen,
						  &out, &outlen);
			sm_free(in);
# else /* SASL >= 20000 */
			result = sasl_server_step(conn,	out, outlen,
						  &out, &outlen, &errstr);
# endif /* SASL >= 20000 */

			/* get an OK if we're done */
			if (result == SASL_OK)
			{
  authenticated:
				message("235 2.0.0 OK Authenticated");
				authenticating = SASL_IS_AUTH;
				macdefine(&BlankEnvelope.e_macro, A_TEMP,
					macid("{auth_type}"), auth_type);

# if SASL >= 20000
				user = macvalue(macid("{auth_authen}"), e);

				/* get security strength (features) */
				result = sasl_getprop(conn, SASL_SSF,
						      (const void **) &ssf);
# else /* SASL >= 20000 */
				result = sasl_getprop(conn, SASL_USERNAME,
						      (void **)&user);
				if (result != SASL_OK)
				{
					user = "";
					macdefine(&BlankEnvelope.e_macro,
						  A_PERM,
						  macid("{auth_authen}"), NULL);
				}
				else
				{
					macdefine(&BlankEnvelope.e_macro,
						  A_TEMP,
						  macid("{auth_authen}"),
						  xtextify(user, "<>\")"));
				}

# if 0
				/* get realm? */
				sasl_getprop(conn, SASL_REALM, (void **) &data);
# endif /* 0 */

				/* get security strength (features) */
				result = sasl_getprop(conn, SASL_SSF,
						      (void **) &ssf);
# endif /* SASL >= 20000 */
				if (result != SASL_OK)
				{
					macdefine(&BlankEnvelope.e_macro,
						  A_PERM,
						  macid("{auth_ssf}"), "0");
					ssf = NULL;
				}
				else
				{
					char pbuf[8];

					(void) sm_snprintf(pbuf, sizeof(pbuf),
							   "%u", *ssf);
					macdefine(&BlankEnvelope.e_macro,
						  A_TEMP,
						  macid("{auth_ssf}"), pbuf);
					if (tTd(95, 8))
						sm_dprintf("AUTH auth_ssf: %u\n",
							   *ssf);
				}

				/*
				**  Only switch to encrypted connection
				**  if a security layer has been negotiated
				*/

				if (ssf != NULL && *ssf > 0)
				{
					int tmo;

					/*
					**  Convert I/O layer to use SASL.
					**  If the call fails, the connection
					**  is aborted.
					*/

					tmo = TimeOuts.to_datablock * 1000;
					if (sfdcsasl(&InChannel, &OutChannel,
						     conn, tmo) == 0)
					{
						/* restart dialogue */
						n_helo = 0;
# if PIPELINING
						(void) sm_io_autoflush(InChannel,
								       OutChannel);
# endif /* PIPELINING */
					}
					else
						syserr("503 5.3.3 SASL TLS failed");
				}

				/* NULL pointer ok since it's our function */
				if (LogLevel > 8)
					sm_syslog(LOG_INFO, NOQID,
						  "AUTH=server, relay=%s, authid=%.128s, mech=%.16s, bits=%d",
						  CurSmtpClient,
						  shortenstring(user, 128),
						  auth_type, *ssf);
			}
			else if (result == SASL_CONTINUE)
			{
				len = ENC64LEN(outlen);
				out2 = xalloc(len);
				result = sasl_encode64(out, outlen, out2, len,
						       &out2len);
				if (result != SASL_OK)
				{
					/* correct code? XXX */
					/* 454 Temp. authentication failure */
					message("454 4.5.4 Internal error: unable to encode64");
					if (LogLevel > 5)
						sm_syslog(LOG_WARNING, e->e_id,
							  "AUTH encode64 error [%d for \"%s\"], relay=%.100s",
							  result, out,
							  CurSmtpClient);
					/* start over? */
					authenticating = SASL_NOT_AUTH;
				}
				else
				{
					message("334 %s", out2);
					if (tTd(95, 2))
						sm_dprintf("AUTH continue: msg='%s' len=%u\n",
							   out2, out2len);
				}
# if SASL >= 20000
				sm_free(out2);
# endif /* SASL >= 20000 */
			}
			else
			{
				/* not SASL_OK or SASL_CONT */
				message("535 5.7.0 authentication failed");
				if (LogLevel > 9)
					sm_syslog(LOG_WARNING, e->e_id,
						  "AUTH failure (%s): %s (%d) %s, relay=%.100s",
						  auth_type,
						  sasl_errstring(result, NULL,
								 NULL),
						  result,
# if SASL >= 20000
						  sasl_errdetail(conn),
# else /* SASL >= 20000 */
						  errstr == NULL ? "" : errstr,
# endif /* SASL >= 20000 */
						  CurSmtpClient);
				RESET_SASLCONN;
				authenticating = SASL_NOT_AUTH;
			}
		}
		else
		{
			/* don't want to do any of this if authenticating */
#endif /* SASL */

		/* echo command to transcript */
		if (e->e_xfp != NULL)
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
					     "<<< %s\n", inp);

		if (LogLevel > 14)
			sm_syslog(LOG_INFO, e->e_id, "<-- %s", inp);

		/* break off command */
		for (p = inp; isascii(*p) && isspace(*p); p++)
			continue;
		cmd = cmdbuf;
		while (*p != '\0' &&
		       !(isascii(*p) && isspace(*p)) &&
		       cmd < &cmdbuf[sizeof(cmdbuf) - 2])
			*cmd++ = *p++;
		*cmd = '\0';

		/* throw away leading whitespace */
		SKIP_SPACE(p);

		/* decode command */
		for (c = CmdTab; c->cmd_name != NULL; c++)
		{
			if (sm_strcasecmp(c->cmd_name, cmdbuf) == 0)
				break;
		}

		/* reset errors */
		errno = 0;

		/* check whether a "non-null" command has been used */
		switch (c->cmd_code)
		{
#if SASL
		  case CMDAUTH:
			/* avoid information leak; take first two words? */
			q = "AUTH";
			break;
#endif /* SASL */

		  case CMDMAIL:
		  case CMDEXPN:
		  case CMDVRFY:
		  case CMDETRN:
			lognullconnection = false;
			/* FALLTHROUGH */
		  default:
			q = inp;
			break;
		}

		if (e->e_id == NULL)
			sm_setproctitle(true, e, "%s: %.80s",
					CurSmtpClient, q);
		else
			sm_setproctitle(true, e, "%s %s: %.80s",
					qid_printname(e),
					CurSmtpClient, q);

		/*
		**  Process command.
		**
		**	If we are running as a null server, return 550
		**	to almost everything.
		*/

		if (nullserver != NULL || bitnset(D_ETRNONLY, d_flags))
		{
			switch (c->cmd_code)
			{
			  case CMDQUIT:
			  case CMDHELO:
			  case CMDEHLO:
			  case CMDNOOP:
			  case CMDRSET:
			  case CMDERROR:
				/* process normally */
				break;

			  case CMDETRN:
				if (bitnset(D_ETRNONLY, d_flags) &&
				    nullserver == NULL)
					break;
				DELAY_CONN("ETRN");
				/* FALLTHROUGH */

			  default:
#if MAXBADCOMMANDS > 0
				/* theoretically this could overflow */
				if (nullserver != NULL &&
				    ++n_badcmds > MAXBADCOMMANDS)
				{
					message("421 4.7.0 %s Too many bad commands; closing connection",
						MyHostName);

					/* arrange to ignore send list */
					e->e_sendqueue = NULL;
					goto doquit;
				}
#endif /* MAXBADCOMMANDS > 0 */
				if (nullserver != NULL)
				{
					if (ISSMTPREPLY(nullserver))
						usrerr(nullserver);
					else
						usrerr("550 5.0.0 %s",
						       nullserver);
				}
				else
					usrerr("452 4.4.5 Insufficient disk space; try again later");
				continue;
			}
		}

		switch (c->cmd_code)
		{
#if SASL
		  case CMDAUTH: /* sasl */
			DELAY_CONN("AUTH");
			if (!sasl_ok || n_mechs <= 0)
			{
				message("503 5.3.3 AUTH not available");
				break;
			}
			if (authenticating == SASL_IS_AUTH)
			{
				message("503 5.5.0 Already Authenticated");
				break;
			}
			if (smtp.sm_gotmail)
			{
				message("503 5.5.0 AUTH not permitted during a mail transaction");
				break;
			}
			if (tempfail)
			{
				if (LogLevel > 9)
					sm_syslog(LOG_INFO, e->e_id,
						  "SMTP AUTH command (%.100s) from %s tempfailed (due to previous checks)",
						  p, CurSmtpClient);
				usrerr("454 4.3.0 Please try again later");
				break;
			}

			ismore = false;

			/* crude way to avoid crack attempts */
			STOP_IF_ATTACK(checksmtpattack(&n_auth, n_mechs + 1,
							true, "AUTH", e));

			/* make sure mechanism (p) is a valid string */
			for (q = p; *q != '\0' && isascii(*q); q++)
			{
				if (isspace(*q))
				{
					*q = '\0';
					while (*++q != '\0' &&
					       isascii(*q) && isspace(*q))
						continue;
					*(q - 1) = '\0';
					ismore = (*q != '\0');
					break;
				}
			}

			if (*p == '\0')
			{
				message("501 5.5.2 AUTH mechanism must be specified");
				break;
			}

			/* check whether mechanism is available */
			if (iteminlist(p, mechlist, " ") == NULL)
			{
				message("504 5.3.3 AUTH mechanism %.32s not available",
					p);
				break;
			}

			/*
			**  RFC 2554 4.
			**  Unlike a zero-length client answer to a
			**  334 reply, a zero- length initial response
			**  is sent as a single equals sign ("=").
			*/

			if (ismore && *q == '=' && *(q + 1) == '\0')
			{
				/* will be free()d, don't use in=""; */
				in = xalloc(1);
				*in = '\0';
				inlen = 0;
			}
			else if (ismore)
			{
				/* could this be shorter? XXX */
# if SASL >= 20000
				in = xalloc(strlen(q) + 1);
				result = sasl_decode64(q, strlen(q), in,
						       strlen(q), &inlen);
# else /* SASL >= 20000 */
				in = sm_rpool_malloc(e->e_rpool, strlen(q));
				result = sasl_decode64(q, strlen(q), in,
						       &inlen);
# endif /* SASL >= 20000 */
				if (result != SASL_OK)
				{
					message("501 5.5.4 cannot BASE64 decode '%s'",
						q);
					if (LogLevel > 5)
						sm_syslog(LOG_WARNING, e->e_id,
							  "AUTH decode64 error [%d for \"%s\"], relay=%.100s",
							  result, q,
							  CurSmtpClient);
					/* start over? */
					authenticating = SASL_NOT_AUTH;
# if SASL >= 20000
					sm_free(in);
# endif /* SASL >= 20000 */
					in = NULL;
					inlen = 0;
					break;
				}
			}
			else
			{
				in = NULL;
				inlen = 0;
			}

			/* see if that auth type exists */
# if SASL >= 20000
			result = sasl_server_start(conn, p, in, inlen,
						   &out, &outlen);
			if (in != NULL)
				sm_free(in);
# else /* SASL >= 20000 */
			result = sasl_server_start(conn, p, in, inlen,
						   &out, &outlen, &errstr);
# endif /* SASL >= 20000 */

			if (result != SASL_OK && result != SASL_CONTINUE)
			{
				message("535 5.7.0 authentication failed");
				if (LogLevel > 9)
					sm_syslog(LOG_ERR, e->e_id,
						  "AUTH failure (%s): %s (%d) %s, relay=%.100s",
						  p,
						  sasl_errstring(result, NULL,
								 NULL),
						  result,
# if SASL >= 20000
						  sasl_errdetail(conn),
# else /* SASL >= 20000 */
						  errstr,
# endif /* SASL >= 20000 */
						  CurSmtpClient);
				RESET_SASLCONN;
				break;
			}
			auth_type = newstr(p);

			if (result == SASL_OK)
			{
				/* ugly, but same code */
				goto authenticated;
				/* authenticated by the initial response */
			}

			/* len is at least 2 */
			len = ENC64LEN(outlen);
			out2 = xalloc(len);
			result = sasl_encode64(out, outlen, out2, len,
					       &out2len);

			if (result != SASL_OK)
			{
				message("454 4.5.4 Temporary authentication failure");
				if (LogLevel > 5)
					sm_syslog(LOG_WARNING, e->e_id,
						  "AUTH encode64 error [%d for \"%s\"]",
						  result, out);

				/* start over? */
				authenticating = SASL_NOT_AUTH;
				RESET_SASLCONN;
			}
			else
			{
				message("334 %s", out2);
				authenticating = SASL_PROC_AUTH;
			}
# if SASL >= 20000
			sm_free(out2);
# endif /* SASL >= 20000 */
			break;
#endif /* SASL */

#if STARTTLS
		  case CMDSTLS: /* starttls */
			DELAY_CONN("STARTTLS");
			if (*p != '\0')
			{
				message("501 5.5.2 Syntax error (no parameters allowed)");
				break;
			}
			if (!bitset(SRV_OFFER_TLS, features))
			{
				message("503 5.5.0 TLS not available");
				break;
			}
			if (!tls_ok_srv)
			{
				message("454 4.3.3 TLS not available after start");
				break;
			}
			if (smtp.sm_gotmail)
			{
				message("503 5.5.0 TLS not permitted during a mail transaction");
				break;
			}
			if (tempfail)
			{
				if (LogLevel > 9)
					sm_syslog(LOG_INFO, e->e_id,
						  "SMTP STARTTLS command (%.100s) from %s tempfailed (due to previous checks)",
						  p, CurSmtpClient);
				usrerr("454 4.7.0 Please try again later");
				break;
			}
  starttls:
# if USE_OPENSSL_ENGINE
			if (!SSLEngineInitialized)
			{
				if (!SSL_set_engine(NULL))
				{
					sm_syslog(LOG_ERR, NOQID,
						  "STARTTLS=server, SSL_set_engine=failed");
					tls_ok_srv = false;
					message("454 4.3.3 TLS not available right now");
					break;
				}
				else
					SSLEngineInitialized = true;
			}
# endif /* USE_OPENSSL_ENGINE */
# if TLS_NO_RSA
			/*
			**  XXX do we need a temp key ?
			*/
# else /* TLS_NO_RSA */
# endif /* TLS_NO_RSA */

# if TLS_VRFY_PER_CTX
			/*
			**  Note: this sets the verification globally
			**  (per SSL_CTX)
			**  it's ok since it applies only to one transaction
			*/

			TLS_VERIFY_CLIENT();
# endif /* TLS_VRFY_PER_CTX */

			if (srv_ssl != NULL)
				SSL_clear(srv_ssl);
			else if ((srv_ssl = SSL_new(srv_ctx)) == NULL)
			{
				message("454 4.3.3 TLS not available: error generating SSL handle");
				if (LogLevel > 8)
					tlslogerr(LOG_WARNING, "server");
				goto tls_done;
			}

# if !TLS_VRFY_PER_CTX
			/*
			**  this could be used if it were possible to set
			**  verification per SSL (connection)
			**  not just per SSL_CTX (global)
			*/

			TLS_VERIFY_CLIENT();
# endif /* !TLS_VRFY_PER_CTX */

			rfd = sm_io_getinfo(InChannel, SM_IO_WHAT_FD, NULL);
			wfd = sm_io_getinfo(OutChannel, SM_IO_WHAT_FD, NULL);

			if (rfd < 0 || wfd < 0 ||
			    SSL_set_rfd(srv_ssl, rfd) <= 0 ||
			    SSL_set_wfd(srv_ssl, wfd) <= 0)
			{
				message("454 4.3.3 TLS not available: error set fd");
				SSL_free(srv_ssl);
				srv_ssl = NULL;
				goto tls_done;
			}
			if (!smtps)
				message("220 2.0.0 Ready to start TLS");
# if PIPELINING
			(void) sm_io_flush(OutChannel, SM_TIME_DEFAULT);
# endif /* PIPELINING */

			SSL_set_accept_state(srv_ssl);

#  define SSL_ACC(s)	SSL_accept(s)

			tlsstart = curtime();
  ssl_retry:
			if ((r = SSL_ACC(srv_ssl)) <= 0)
			{
				int i, ssl_err;

				ssl_err = SSL_get_error(srv_ssl, r);
				i = tls_retry(srv_ssl, rfd, wfd, tlsstart,
						TimeOuts.to_starttls, ssl_err,
						"server");
				if (i > 0)
					goto ssl_retry;

				if (LogLevel > 5)
				{
					unsigned long l;
					const char *sr;

					l = ERR_peek_error();
					sr = ERR_reason_error_string(l);
					sm_syslog(LOG_WARNING, NOQID,
						  "STARTTLS=server, error: accept failed=%d, reason=%s, SSL_error=%d, errno=%d, retry=%d, relay=%.100s",
						  r, sr == NULL ? "unknown"
								: sr,
						  ssl_err, errno, i,
						  CurSmtpClient);
					if (LogLevel > 9)
						tlslogerr(LOG_WARNING, "server");
				}
				tls_ok_srv = false;
				SSL_free(srv_ssl);
				srv_ssl = NULL;

				/*
				**  according to the next draft of
				**  RFC 2487 the connection should be dropped
				*/

				/* arrange to ignore any current send list */
				e->e_sendqueue = NULL;
				goto doquit;
			}

			/* ignore return code for now, it's in {verify} */
			(void) tls_get_info(srv_ssl, true,
					    CurSmtpClient,
					    &BlankEnvelope.e_macro,
					    bitset(SRV_VRFY_CLT, features));

			/*
			**  call Stls_client to find out whether
			**  to accept the connection from the client
			*/

			saveQuickAbort = QuickAbort;
			saveSuprErrs = SuprErrs;
			SuprErrs = true;
			QuickAbort = false;
			if (rscheck("tls_client",
				     macvalue(macid("{verify}"), e),
				     "STARTTLS", e,
				     RSF_RMCOMM|RSF_COUNT,
				     5, NULL, NOQID, NULL) != EX_OK ||
			    Errors > 0)
			{
				extern char MsgBuf[];

				if (MsgBuf[0] != '\0' && ISSMTPREPLY(MsgBuf))
					nullserver = newstr(MsgBuf);
				else
					nullserver = "503 5.7.0 Authentication required.";
			}
			QuickAbort = saveQuickAbort;
			SuprErrs = saveSuprErrs;

			tls_ok_srv = false;	/* don't offer STARTTLS again */
			n_helo = 0;
# if SASL
			if (sasl_ok)
			{
				int cipher_bits;
				bool verified;
				char *s, *v, *c;

				s = macvalue(macid("{cipher_bits}"), e);
				v = macvalue(macid("{verify}"), e);
				c = macvalue(macid("{cert_subject}"), e);
				verified = (v != NULL && strcmp(v, "OK") == 0);
				if (s != NULL && (cipher_bits = atoi(s)) > 0)
				{
#  if SASL >= 20000
					ext_ssf = cipher_bits;
					auth_id = verified ? c : NULL;
					sasl_ok = ((sasl_setprop(conn,
							SASL_SSF_EXTERNAL,
							&ext_ssf) == SASL_OK) &&
						   (sasl_setprop(conn,
							SASL_AUTH_EXTERNAL,
							auth_id) == SASL_OK));
#  else /* SASL >= 20000 */
					ext_ssf.ssf = cipher_bits;
					ext_ssf.auth_id = verified ? c : NULL;
					sasl_ok = sasl_setprop(conn,
							SASL_SSF_EXTERNAL,
							&ext_ssf) == SASL_OK;
#  endif /* SASL >= 20000 */
					mechlist = NULL;
					if (sasl_ok)
						n_mechs = saslmechs(conn,
								    &mechlist);
				}
			}
# endif /* SASL */

			/* switch to secure connection */
			if (sfdctls(&InChannel, &OutChannel, srv_ssl) == 0)
			{
				tls_active = true;
# if PIPELINING
				(void) sm_io_autoflush(InChannel, OutChannel);
# endif /* PIPELINING */
			}
			else
			{
				/*
				**  XXX this is an internal error
				**  how to deal with it?
				**  we can't generate an error message
				**  since the other side switched to an
				**  encrypted layer, but we could not...
				**  just "hang up"?
				*/

				nullserver = "454 4.3.3 TLS not available: can't switch to encrypted layer";
				syserr("STARTTLS: can't switch to encrypted layer");
			}
		  tls_done:
			if (smtps)
			{
				if (tls_active)
					goto greeting;
				else
					goto doquit;
			}
			break;
#endif /* STARTTLS */

		  case CMDHELO:		/* hello -- introduce yourself */
		  case CMDEHLO:		/* extended hello */
			DELAY_CONN("EHLO");
			if (c->cmd_code == CMDEHLO)
			{
				protocol = "ESMTP";
				SmtpPhase = "server EHLO";
			}
			else
			{
				protocol = "SMTP";
				SmtpPhase = "server HELO";
			}

			/* avoid denial-of-service */
			STOP_IF_ATTACK(checksmtpattack(&n_helo, MAXHELOCOMMANDS,
							true, "HELO/EHLO", e));

#if 0
			/* RFC2821 4.1.4 allows duplicate HELO/EHLO */
			/* check for duplicate HELO/EHLO per RFC 1651 4.2 */
			if (gothello)
			{
				usrerr("503 %s Duplicate HELO/EHLO",
				       MyHostName);
				break;
			}
#endif /* 0 */

			/* check for valid domain name (re 1123 5.2.5) */
			if (*p == '\0' && !AllowBogusHELO)
			{
				usrerr("501 %s requires domain address",
					cmdbuf);
				break;
			}

			/* check for long domain name (hides Received: info) */
			if (strlen(p) > MAXNAME)
			{
				usrerr("501 Invalid domain name");
				if (LogLevel > 9)
					sm_syslog(LOG_INFO, CurEnv->e_id,
						  "invalid domain name (too long) from %s",
						  CurSmtpClient);
				break;
			}

			ok = true;
			for (q = p; *q != '\0'; q++)
			{
				if (!isascii(*q))
					break;
				if (isalnum(*q))
					continue;
				if (isspace(*q))
				{
					*q = '\0';

					/* only complain if strict check */
					ok = AllowBogusHELO;

					/* allow trailing whitespace */
					while (!ok && *++q != '\0' &&
					       isspace(*q))
						;
					if (*q == '\0')
						ok = true;
					break;
				}
				if (strchr("[].-_#:", *q) == NULL)
					break;
			}

			if (*q == '\0' && ok)
			{
				q = "pleased to meet you";
				sendinghost = sm_strdup_x(p);
			}
			else if (!AllowBogusHELO)
			{
				usrerr("501 Invalid domain name");
				if (LogLevel > 9)
					sm_syslog(LOG_INFO, CurEnv->e_id,
						  "invalid domain name (%s) from %.100s",
						  p, CurSmtpClient);
				break;
			}
			else
			{
				q = "accepting invalid domain name";
			}

			if (gothello || smtp.sm_gotmail)
				CLEAR_STATE(cmdbuf);

#if MILTER
			if (smtp.sm_milterlist && smtp.sm_milterize &&
			    !bitset(EF_DISCARD, e->e_flags))
			{
				char state;
				char *response;

				response = milter_helo(p, e, &state);
				switch (state)
				{
				  case SMFIR_REJECT:
					if (MilterLogLevel > 3)
						sm_syslog(LOG_INFO, e->e_id,
							  "Milter: helo=%s, reject=Command rejected",
							  p);
					nullserver = "Command rejected";
					smtp.sm_milterize = false;
					break;

				  case SMFIR_TEMPFAIL:
					if (MilterLogLevel > 3)
						sm_syslog(LOG_INFO, e->e_id,
							  "Milter: helo=%s, reject=%s",
							  p, MSG_TEMPFAIL);
					tempfail = true;
					smtp.sm_milterize = false;
					break;

				  case SMFIR_REPLYCODE:
					if (MilterLogLevel > 3)
						sm_syslog(LOG_INFO, e->e_id,
							  "Milter: helo=%s, reject=%s",
							  p, response);
					if (strncmp(response, "421 ", 4) != 0
					    && strncmp(response, "421-", 4) != 0)
					{
						nullserver = newstr(response);
						smtp.sm_milterize = false;
						break;
					}
					/* FALLTHROUGH */

				  case SMFIR_SHUTDOWN:
					if (MilterLogLevel > 3 &&
					    response == NULL)
						sm_syslog(LOG_INFO, e->e_id,
							  "Milter: helo=%s, reject=421 4.7.0 %s closing connection",
							  p, MyHostName);
					tempfail = true;
					smtp.sm_milterize = false;
					if (response != NULL)
						usrerr(response);
					else
						message("421 4.7.0 %s closing connection",
							MyHostName);
					/* arrange to ignore send list */
					e->e_sendqueue = NULL;
					lognullconnection = false;
					goto doquit;
				}
				if (response != NULL)
					sm_free(response);

				/*
				**  If quarantining by a connect/ehlo action,
				**  save between messages
				*/

				if (smtp.sm_quarmsg == NULL &&
				    e->e_quarmsg != NULL)
					smtp.sm_quarmsg = newstr(e->e_quarmsg);
			}
#endif /* MILTER */
			gothello = true;

			/* print HELO response message */
			if (c->cmd_code != CMDEHLO)
			{
				message("250 %s Hello %s, %s",
					MyHostName, CurSmtpClient, q);
				break;
			}

			message("250-%s Hello %s, %s",
				MyHostName, CurSmtpClient, q);

			/* offer ENHSC even for nullserver */
			if (nullserver != NULL)
			{
				message("250 ENHANCEDSTATUSCODES");
				break;
			}

			/*
			**  print EHLO features list
			**
			**  Note: If you change this list,
			**	  remember to update 'helpfile'
			*/

			message("250-ENHANCEDSTATUSCODES");
#if PIPELINING
			if (bitset(SRV_OFFER_PIPE, features))
				message("250-PIPELINING");
#endif /* PIPELINING */
			if (bitset(SRV_OFFER_EXPN, features))
			{
				message("250-EXPN");
				if (bitset(SRV_OFFER_VERB, features))
					message("250-VERB");
			}
#if MIME8TO7
			message("250-8BITMIME");
#endif /* MIME8TO7 */
			if (MaxMessageSize > 0)
				message("250-SIZE %ld", MaxMessageSize);
			else
				message("250-SIZE");
#if DSN
			if (SendMIMEErrors && bitset(SRV_OFFER_DSN, features))
				message("250-DSN");
#endif /* DSN */
			if (bitset(SRV_OFFER_ETRN, features))
				message("250-ETRN");
#if SASL
			if (sasl_ok && mechlist != NULL && *mechlist != '\0')
				message("250-AUTH %s", mechlist);
#endif /* SASL */
#if STARTTLS
			if (tls_ok_srv && bitset(SRV_OFFER_TLS, features))
				message("250-STARTTLS");
#endif /* STARTTLS */
			if (DeliverByMin > 0)
				message("250-DELIVERBY %ld",
					(long) DeliverByMin);
			else if (DeliverByMin == 0)
				message("250-DELIVERBY");

			/* < 0: no deliver-by */

			message("250 HELP");
			break;

		  case CMDMAIL:		/* mail -- designate sender */
			SmtpPhase = "server MAIL";
			DELAY_CONN("MAIL");

			/* check for validity of this command */
			if (!gothello && bitset(PRIV_NEEDMAILHELO, PrivacyFlags))
			{
				usrerr("503 5.0.0 Polite people say HELO first");
				break;
			}
			if (smtp.sm_gotmail)
			{
				usrerr("503 5.5.0 Sender already specified");
				break;
			}
#if SASL
			if (bitset(SRV_REQ_AUTH, features) &&
			    authenticating != SASL_IS_AUTH)
			{
				usrerr("530 5.7.0 Authentication required");
				break;
			}
#endif /* SASL */

			p = skipword(p, "from");
			if (p == NULL)
				break;
			if (tempfail)
			{
				if (LogLevel > 9)
					sm_syslog(LOG_INFO, e->e_id,
						  "SMTP MAIL command (%.100s) from %s tempfailed (due to previous checks)",
						  p, CurSmtpClient);
				usrerr(MSG_TEMPFAIL);
				break;
			}

			/* make sure we know who the sending host is */
			if (sendinghost == NULL)
				sendinghost = peerhostname;


#if SM_HEAP_CHECK
			if (sm_debug_active(&DebugLeakSmtp, 1))
			{
				sm_heap_newgroup();
				sm_dprintf("smtp() heap group #%d\n",
					sm_heap_group());
			}
#endif /* SM_HEAP_CHECK */

			if (Errors > 0)
				goto undo_no_pm;
			if (!gothello)
			{
				auth_warning(e, "%s didn't use HELO protocol",
					     CurSmtpClient);
			}
#ifdef PICKY_HELO_CHECK
			if (sm_strcasecmp(sendinghost, peerhostname) != 0 &&
			    (sm_strcasecmp(peerhostname, "localhost") != 0 ||
			     sm_strcasecmp(sendinghost, MyHostName) != 0))
			{
				auth_warning(e, "Host %s claimed to be %s",
					     CurSmtpClient, sendinghost);
			}
#endif /* PICKY_HELO_CHECK */

			if (protocol == NULL)
				protocol = "SMTP";
			macdefine(&e->e_macro, A_PERM, 'r', protocol);
			macdefine(&e->e_macro, A_PERM, 's', sendinghost);

			if (Errors > 0)
				goto undo_no_pm;
			smtp.sm_nrcpts = 0;
			n_badrcpts = 0;
			macdefine(&e->e_macro, A_PERM, macid("{ntries}"), "0");
			macdefine(&e->e_macro, A_PERM, macid("{nrcpts}"), "0");
			macdefine(&e->e_macro, A_PERM, macid("{nbadrcpts}"),
				"0");
			e->e_flags |= EF_CLRQUEUE;
			sm_setproctitle(true, e, "%s %s: %.80s",
					qid_printname(e),
					CurSmtpClient, inp);

			/* do the processing */
		    SM_TRY
		    {
			extern char *FullName;

			QuickAbort = true;
			SM_FREE_CLR(FullName);

			/* must parse sender first */
			delimptr = NULL;
			setsender(p, e, &delimptr, ' ', false);
			if (delimptr != NULL && *delimptr != '\0')
				*delimptr++ = '\0';
			if (Errors > 0)
				sm_exc_raisenew_x(&EtypeQuickAbort, 1);

			/* Successfully set e_from, allow logging */
			e->e_flags |= EF_LOGSENDER;

			/* put resulting triple from parseaddr() into macros */
			if (e->e_from.q_mailer != NULL)
				 macdefine(&e->e_macro, A_PERM,
					macid("{mail_mailer}"),
					e->e_from.q_mailer->m_name);
			else
				 macdefine(&e->e_macro, A_PERM,
					macid("{mail_mailer}"), NULL);
			if (e->e_from.q_host != NULL)
				macdefine(&e->e_macro, A_PERM,
					macid("{mail_host}"),
					e->e_from.q_host);
			else
				macdefine(&e->e_macro, A_PERM,
					macid("{mail_host}"), "localhost");
			if (e->e_from.q_user != NULL)
				macdefine(&e->e_macro, A_PERM,
					macid("{mail_addr}"),
					e->e_from.q_user);
			else
				macdefine(&e->e_macro, A_PERM,
					macid("{mail_addr}"), NULL);
			if (Errors > 0)
				sm_exc_raisenew_x(&EtypeQuickAbort, 1);

			/* check for possible spoofing */
			if (RealUid != 0 && OpMode == MD_SMTP &&
			    !wordinclass(RealUserName, 't') &&
			    (!bitnset(M_LOCALMAILER,
				      e->e_from.q_mailer->m_flags) ||
			     strcmp(e->e_from.q_user, RealUserName) != 0))
			{
				auth_warning(e, "%s owned process doing -bs",
					RealUserName);
			}

			/* reset to default value */
			SevenBitInput = SevenBitInput_Saved;

			/* now parse ESMTP arguments */
			e->e_msgsize = 0;
			addr = p;
			parse_esmtp_args(e, NULL, p, delimptr, "MAIL", args,
					mail_esmtp_args);
			if (Errors > 0)
				sm_exc_raisenew_x(&EtypeQuickAbort, 1);

#if SASL
# if _FFR_AUTH_PASSING
			/* set the default AUTH= if the sender didn't */
			if (e->e_auth_param == NULL)
			{
				/* XXX only do this for an MSA? */
				e->e_auth_param = macvalue(macid("{auth_authen}"),
							   e);
				if (e->e_auth_param == NULL)
					e->e_auth_param = "<>";

				/*
				**  XXX should we invoke Strust_auth now?
				**  authorizing as the client that just
				**  authenticated, so we'll trust implicitly
				*/
			}
# endif /* _FFR_AUTH_PASSING */
#endif /* SASL */

			/* do config file checking of the sender */
			macdefine(&e->e_macro, A_PERM,
				macid("{addr_type}"), "e s");
#if _FFR_MAIL_MACRO
			/* make the "real" sender address available */
			macdefine(&e->e_macro, A_TEMP, macid("{mail_from}"),
				  e->e_from.q_paddr);
#endif /* _FFR_MAIL_MACRO */
			if (rscheck("check_mail", addr,
				    NULL, e, RSF_RMCOMM|RSF_COUNT, 3,
				    NULL, e->e_id, NULL) != EX_OK ||
			    Errors > 0)
				sm_exc_raisenew_x(&EtypeQuickAbort, 1);
			macdefine(&e->e_macro, A_PERM,
				  macid("{addr_type}"), NULL);

			if (MaxMessageSize > 0 &&
			    (e->e_msgsize > MaxMessageSize ||
			     e->e_msgsize < 0))
			{
				usrerr("552 5.2.3 Message size exceeds fixed maximum message size (%ld)",
					MaxMessageSize);
				sm_exc_raisenew_x(&EtypeQuickAbort, 1);
			}

			/*
			**  XXX always check whether there is at least one fs
			**  with enough space?
			**  However, this may not help much: the queue group
			**  selection may later on select a FS that hasn't
			**  enough space.
			*/

			if ((NumFileSys == 1 || NumQueue == 1) &&
			    !enoughdiskspace(e->e_msgsize, e)
#if _FFR_ANY_FREE_FS
			    && !filesys_free(e->e_msgsize)
#endif /* _FFR_ANY_FREE_FS */
			   )
			{
				/*
				**  We perform this test again when the
				**  queue directory is selected, in collect.
				*/

				usrerr("452 4.4.5 Insufficient disk space; try again later");
				sm_exc_raisenew_x(&EtypeQuickAbort, 1);
			}
			if (Errors > 0)
				sm_exc_raisenew_x(&EtypeQuickAbort, 1);

			LogUsrErrs = true;
#if MILTER
			if (smtp.sm_milterlist && smtp.sm_milterize &&
			    !bitset(EF_DISCARD, e->e_flags))
			{
				char state;
				char *response;

				response = milter_envfrom(args, e, &state);
				MILTER_REPLY("from");
			}
#endif /* MILTER */
			if (Errors > 0)
				sm_exc_raisenew_x(&EtypeQuickAbort, 1);

			message("250 2.1.0 Sender ok");
			smtp.sm_gotmail = true;
		    }
		    SM_EXCEPT(exc, "[!F]*")
		    {
			/*
			**  An error occurred while processing a MAIL command.
			**  Jump to the common error handling code.
			*/

			sm_exc_free(exc);
			goto undo_no_pm;
		    }
		    SM_END_TRY
			break;

		  undo_no_pm:
			e->e_flags &= ~EF_PM_NOTIFY;
		  undo:
			break;

		  case CMDRCPT:		/* rcpt -- designate recipient */
			DELAY_CONN("RCPT");
			macdefine(&e->e_macro, A_PERM,
				macid("{rcpt_mailer}"), NULL);
			macdefine(&e->e_macro, A_PERM,
				macid("{rcpt_host}"), NULL);
			macdefine(&e->e_macro, A_PERM,
				macid("{rcpt_addr}"), NULL);
#if MILTER
			(void) memset(&addr_st, '\0', sizeof(addr_st));
			a = NULL;
			milter_rcpt_added = false;
			smtp.sm_e_nrcpts_orig = e->e_nrcpts;
#endif
#if _FFR_BADRCPT_SHUTDOWN
			/*
			**  hack to deal with hack, see below:
			**  n_badrcpts is increased if limit is reached.
			*/

			n_badrcpts_adj = (BadRcptThrottle > 0 &&
					  n_badrcpts > BadRcptThrottle &&
					  LogLevel > 5)
					  ? n_badrcpts - 1 : n_badrcpts;
			if (BadRcptShutdown > 0 &&
			    n_badrcpts_adj >= BadRcptShutdown &&
			    (BadRcptShutdownGood == 0 ||
			     smtp.sm_nrcpts == 0 ||
			     (n_badrcpts_adj * 100 /
			      (smtp.sm_nrcpts + n_badrcpts) >=
			      BadRcptShutdownGood)))
			{
				if (LogLevel > 5)
					sm_syslog(LOG_INFO, e->e_id,
						  "%s: Possible SMTP RCPT flood, shutting down connection.",
						  CurSmtpClient);
				message("421 4.7.0 %s Too many bad recipients; closing connection",
				MyHostName);

				/* arrange to ignore any current send list */
				e->e_sendqueue = NULL;
				goto doquit;
			}
#endif /* _FFR_BADRCPT_SHUTDOWN */
			if (BadRcptThrottle > 0 &&
			    n_badrcpts >= BadRcptThrottle)
			{
				if (LogLevel > 5 &&
				    n_badrcpts == BadRcptThrottle)
				{
					sm_syslog(LOG_INFO, e->e_id,
						  "%s: Possible SMTP RCPT flood, throttling.",
						  CurSmtpClient);

					/* To avoid duplicated message */
					n_badrcpts++;
				}
				NBADRCPTS;

				/*
				**  Don't use exponential backoff for now.
				**  Some systems will open more connections
				**  and actually overload the receiver even
				**  more.
				*/

				(void) sleep(BadRcptThrottleDelay);
			}
			if (!smtp.sm_gotmail)
			{
				usrerr("503 5.0.0 Need MAIL before RCPT");
				break;
			}
			SmtpPhase = "server RCPT";
		    SM_TRY
		    {
			QuickAbort = true;
			LogUsrErrs = true;

			/* limit flooding of our machine */
			if (MaxRcptPerMsg > 0 &&
			    smtp.sm_nrcpts >= MaxRcptPerMsg)
			{
				/* sleep(1); / * slow down? */
				usrerr("452 4.5.3 Too many recipients");
				goto rcpt_done;
			}

			if (!SM_IS_INTERACTIVE(e->e_sendmode)
#if _FFR_DM_ONE
			    && (NotFirstDelivery || SM_DM_ONE != e->e_sendmode)
#endif /* _FFR_DM_ONE */
			   )
				e->e_flags |= EF_VRFYONLY;

#if MILTER
			/*
			**  Do not expand recipients at RCPT time (in the call
			**  to recipient()) if a milter can delete or reject
			**  a RCPT.  If they are expanded, it is impossible
			**  for removefromlist() to figure out the expanded
			**  members of the original recipient and mark them
			**  as QS_DONTSEND.
			*/

			if (!(smtp.sm_milterlist && smtp.sm_milterize &&
			      !bitset(EF_DISCARD, e->e_flags)) &&
			    (smtp.sm_milters.mis_flags &
			     (MIS_FL_DEL_RCPT|MIS_FL_REJ_RCPT)) != 0)
				e->e_flags |= EF_VRFYONLY;
			milter_cmd_done = false;
			milter_cmd_safe = false;
#endif /* MILTER */

			p = skipword(p, "to");
			if (p == NULL)
				goto rcpt_done;
			macdefine(&e->e_macro, A_PERM,
				macid("{addr_type}"), "e r");
			a = parseaddr(p, NULLADDR, RF_COPYALL, ' ', &delimptr,
				      e, true);
			macdefine(&e->e_macro, A_PERM,
				macid("{addr_type}"), NULL);
			if (Errors > 0)
				goto rcpt_done;
			if (a == NULL)
			{
				usrerr("501 5.0.0 Missing recipient");
				goto rcpt_done;
			}

			if (delimptr != NULL && *delimptr != '\0')
				*delimptr++ = '\0';

			/* put resulting triple from parseaddr() into macros */
			if (a->q_mailer != NULL)
				macdefine(&e->e_macro, A_PERM,
					macid("{rcpt_mailer}"),
					a->q_mailer->m_name);
			else
				macdefine(&e->e_macro, A_PERM,
					macid("{rcpt_mailer}"), NULL);
			if (a->q_host != NULL)
				macdefine(&e->e_macro, A_PERM,
					macid("{rcpt_host}"), a->q_host);
			else
				macdefine(&e->e_macro, A_PERM,
					macid("{rcpt_host}"), "localhost");
			if (a->q_user != NULL)
				macdefine(&e->e_macro, A_PERM,
					macid("{rcpt_addr}"), a->q_user);
			else
				macdefine(&e->e_macro, A_PERM,
					macid("{rcpt_addr}"), NULL);
			if (Errors > 0)
				goto rcpt_done;

			/* now parse ESMTP arguments */
			addr = p;
			parse_esmtp_args(e, a, p, delimptr, "RCPT", args,
					rcpt_esmtp_args);
			if (Errors > 0)
				goto rcpt_done;

#if MILTER
			/*
			**  rscheck() can trigger an "exception"
			**  in which case the execution continues at
			**  SM_EXCEPT(exc, "[!F]*")
			**  This means milter_cmd_safe is not set
			**  and hence milter is not invoked.
			**  Would it be "safe" to change that, i.e., use
			**  milter_cmd_safe = true;
			**  here so a milter is informed (if requested)
			**  about RCPTs that are rejected by check_rcpt?
			*/
# if _FFR_MILTER_CHECK_REJECTIONS_TOO
			milter_cmd_safe = true;
# endif
#endif

			/* do config file checking of the recipient */
			macdefine(&e->e_macro, A_PERM,
				macid("{addr_type}"), "e r");
			if (rscheck("check_rcpt", addr,
				    NULL, e, RSF_RMCOMM|RSF_COUNT, 3,
				    NULL, e->e_id, p_addr_st) != EX_OK ||
			    Errors > 0)
				goto rcpt_done;
			macdefine(&e->e_macro, A_PERM,
				macid("{addr_type}"), NULL);

			/* If discarding, don't bother to verify user */
			if (bitset(EF_DISCARD, e->e_flags))
				a->q_state = QS_VERIFIED;
#if MILTER
			milter_cmd_safe = true;
#endif

			/* save in recipient list after ESMTP mods */
			a = recipient(a, &e->e_sendqueue, 0, e);
			/* may trigger exception... */

#if MILTER
			milter_rcpt_added = true;
#endif

			if(!(Errors > 0) && QS_IS_BADADDR(a->q_state))
			{
				/* punt -- should keep message in ADDRESS.... */
				usrerr("550 5.1.1 Addressee unknown");
			}

#if MILTER
		rcpt_done:
			if (smtp.sm_milterlist && smtp.sm_milterize &&
			    !bitset(EF_DISCARD, e->e_flags))
			{
				char state;
				char *response;

				/* how to get the error codes? */
				if (Errors > 0)
				{
					macdefine(&e->e_macro, A_PERM,
						macid("{rcpt_mailer}"),
						"error");
					if (a != NULL &&
					    a->q_status != NULL &&
					    a->q_rstatus != NULL)
					{
						macdefine(&e->e_macro, A_PERM,
							macid("{rcpt_host}"),
							a->q_status);
						macdefine(&e->e_macro, A_PERM,
							macid("{rcpt_addr}"),
							a->q_rstatus);
					}
					else
					{
						if (addr_st.q_host != NULL)
							macdefine(&e->e_macro,
								A_PERM,
								macid("{rcpt_host}"),
								addr_st.q_host);
						if (addr_st.q_user != NULL)
							macdefine(&e->e_macro,
								A_PERM,
								macid("{rcpt_addr}"),
								addr_st.q_user);
					}
				}

				response = milter_envrcpt(args, e, &state,
							Errors > 0);
				milter_cmd_done = true;
				MILTER_REPLY("to");
			}
#endif /* MILTER */

			/* no errors during parsing, but might be a duplicate */
			e->e_to = a->q_paddr;
			if (!(Errors > 0) && !QS_IS_BADADDR(a->q_state))
			{
				if (smtp.sm_nrcpts == 0)
					initsys(e);
				message("250 2.1.5 Recipient ok%s",
					QS_IS_QUEUEUP(a->q_state) ?
						" (will queue)" : "");
				smtp.sm_nrcpts++;
			}

			/* Is this needed? */
#if !MILTER
		rcpt_done:
#endif /* !MILTER */
			macdefine(&e->e_macro, A_PERM,
				macid("{rcpt_mailer}"), NULL);
			macdefine(&e->e_macro, A_PERM,
				macid("{rcpt_host}"), NULL);
			macdefine(&e->e_macro, A_PERM,
				macid("{rcpt_addr}"), NULL);
			macdefine(&e->e_macro, A_PERM,
				macid("{dsn_notify}"), NULL);

			if (Errors > 0)
			{
				++n_badrcpts;
				NBADRCPTS;
			}
		    }
		    SM_EXCEPT(exc, "[!F]*")
		    {
			/* An exception occurred while processing RCPT */
			e->e_flags &= ~(EF_FATALERRS|EF_PM_NOTIFY);
			++n_badrcpts;
			NBADRCPTS;
#if MILTER
			if (smtp.sm_milterlist && smtp.sm_milterize &&
			    !bitset(EF_DISCARD, e->e_flags) &&
			    !milter_cmd_done && milter_cmd_safe)
			{
				char state;
				char *response;

				macdefine(&e->e_macro, A_PERM,
					macid("{rcpt_mailer}"), "error");

				/* how to get the error codes? */
				if (addr_st.q_host != NULL)
					macdefine(&e->e_macro, A_PERM,
						macid("{rcpt_host}"),
						addr_st.q_host);
				else if (a != NULL && a->q_status != NULL)
					macdefine(&e->e_macro, A_PERM,
						macid("{rcpt_host}"),
						a->q_status);

				if (addr_st.q_user != NULL)
					macdefine(&e->e_macro, A_PERM,
						macid("{rcpt_addr}"),
						addr_st.q_user);
				else if (a != NULL && a->q_rstatus != NULL)
					macdefine(&e->e_macro, A_PERM,
						macid("{rcpt_addr}"),
						a->q_rstatus);

				response = milter_envrcpt(args, e, &state,
							true);
				milter_cmd_done = true;
				MILTER_REPLY("to");
				macdefine(&e->e_macro, A_PERM,
					macid("{rcpt_mailer}"), NULL);
				macdefine(&e->e_macro, A_PERM,
					macid("{rcpt_host}"), NULL);
				macdefine(&e->e_macro, A_PERM,
					macid("{rcpt_addr}"), NULL);
			}
			if (smtp.sm_milterlist && smtp.sm_milterize &&
			    milter_rcpt_added && milter_cmd_done &&
			    milter_cmd_fail)
			{
				(void) removefromlist(addr, &e->e_sendqueue, e);
				milter_cmd_fail = false;
				if (smtp.sm_e_nrcpts_orig < e->e_nrcpts)
					e->e_nrcpts = smtp.sm_e_nrcpts_orig;
			}
#endif /* MILTER */
		    }
		    SM_END_TRY
			break;

		  case CMDDATA:		/* data -- text of mail */
			DELAY_CONN("DATA");
			if (!smtp_data(&smtp, e))
				goto doquit;
			break;

		  case CMDRSET:		/* rset -- reset state */
			if (tTd(94, 100))
				message("451 4.0.0 Test failure");
			else
				message("250 2.0.0 Reset state");
			CLEAR_STATE(cmdbuf);
			break;

		  case CMDVRFY:		/* vrfy -- verify address */
		  case CMDEXPN:		/* expn -- expand address */
			vrfy = c->cmd_code == CMDVRFY;
			DELAY_CONN(vrfy ? "VRFY" : "EXPN");
			if (tempfail)
			{
				if (LogLevel > 9)
					sm_syslog(LOG_INFO, e->e_id,
						  "SMTP %s command (%.100s) from %s tempfailed (due to previous checks)",
						  vrfy ? "VRFY" : "EXPN",
						  p, CurSmtpClient);

				/* RFC 821 doesn't allow 4xy reply code */
				usrerr("550 5.7.1 Please try again later");
				break;
			}
			wt = checksmtpattack(&n_verifies, MAXVRFYCOMMANDS,
					     false, vrfy ? "VRFY" : "EXPN", e);
			STOP_IF_ATTACK(wt);
			previous = curtime();
			if ((vrfy && bitset(PRIV_NOVRFY, PrivacyFlags)) ||
			    (!vrfy && !bitset(SRV_OFFER_EXPN, features)))
			{
				if (vrfy)
					message("252 2.5.2 Cannot VRFY user; try RCPT to attempt delivery (or try finger)");
				else
					message("502 5.7.0 Sorry, we do not allow this operation");
				if (LogLevel > 5)
					sm_syslog(LOG_INFO, e->e_id,
						  "%s: %s [rejected]",
						  CurSmtpClient,
						  shortenstring(inp, MAXSHORTSTR));
				break;
			}
			else if (!gothello &&
				 bitset(vrfy ? PRIV_NEEDVRFYHELO : PRIV_NEEDEXPNHELO,
						PrivacyFlags))
			{
				usrerr("503 5.0.0 I demand that you introduce yourself first");
				break;
			}
			if (Errors > 0)
				break;
			if (LogLevel > 5)
				sm_syslog(LOG_INFO, e->e_id, "%s: %s",
					  CurSmtpClient,
					  shortenstring(inp, MAXSHORTSTR));
		    SM_TRY
		    {
			QuickAbort = true;
			vrfyqueue = NULL;
			if (vrfy)
				e->e_flags |= EF_VRFYONLY;
			while (*p != '\0' && isascii(*p) && isspace(*p))
				p++;
			if (*p == '\0')
			{
				usrerr("501 5.5.2 Argument required");
			}
			else
			{
				/* do config file checking of the address */
				if (rscheck(vrfy ? "check_vrfy" : "check_expn",
					    p, NULL, e, RSF_RMCOMM,
					    3, NULL, NOQID, NULL) != EX_OK ||
				    Errors > 0)
					sm_exc_raisenew_x(&EtypeQuickAbort, 1);
				(void) sendtolist(p, NULLADDR, &vrfyqueue, 0, e);
			}
			if (wt > 0)
			{
				time_t t;

				t = wt - (curtime() - previous);
				if (t > 0)
					(void) sleep(t);
			}
			if (Errors > 0)
				sm_exc_raisenew_x(&EtypeQuickAbort, 1);
			if (vrfyqueue == NULL)
			{
				usrerr("554 5.5.2 Nothing to %s", vrfy ? "VRFY" : "EXPN");
			}
			while (vrfyqueue != NULL)
			{
				if (!QS_IS_UNDELIVERED(vrfyqueue->q_state))
				{
					vrfyqueue = vrfyqueue->q_next;
					continue;
				}

				/* see if there is more in the vrfy list */
				a = vrfyqueue;
				while ((a = a->q_next) != NULL &&
				       (!QS_IS_UNDELIVERED(a->q_state)))
					continue;
				printvrfyaddr(vrfyqueue, a == NULL, vrfy);
				vrfyqueue = a;
			}
		    }
		    SM_EXCEPT(exc, "[!F]*")
		    {
			/*
			**  An exception occurred while processing VRFY/EXPN
			*/

			sm_exc_free(exc);
			goto undo;
		    }
		    SM_END_TRY
			break;

		  case CMDETRN:		/* etrn -- force queue flush */
			DELAY_CONN("ETRN");

			/* Don't leak queue information via debug flags */
			if (!bitset(SRV_OFFER_ETRN, features) || UseMSP ||
			    (RealUid != 0 && RealUid != TrustedUid &&
			     OpMode == MD_SMTP))
			{
				/* different message for MSA ? */
				message("502 5.7.0 Sorry, we do not allow this operation");
				if (LogLevel > 5)
					sm_syslog(LOG_INFO, e->e_id,
						  "%s: %s [rejected]",
						  CurSmtpClient,
						  shortenstring(inp, MAXSHORTSTR));
				break;
			}
			if (tempfail)
			{
				if (LogLevel > 9)
					sm_syslog(LOG_INFO, e->e_id,
						  "SMTP ETRN command (%.100s) from %s tempfailed (due to previous checks)",
						  p, CurSmtpClient);
				usrerr(MSG_TEMPFAIL);
				break;
			}

			if (strlen(p) <= 0)
			{
				usrerr("500 5.5.2 Parameter required");
				break;
			}

			/* crude way to avoid denial-of-service attacks */
			STOP_IF_ATTACK(checksmtpattack(&n_etrn, MAXETRNCOMMANDS,
							true, "ETRN", e));

			/*
			**  Do config file checking of the parameter.
			**  Even though we have srv_features now, we still
			**  need this ruleset because the former is called
			**  when the connection has been established, while
			**  this ruleset is called when the command is
			**  actually issued and therefore has all information
			**  available to make a decision.
			*/

			if (rscheck("check_etrn", p, NULL, e,
				    RSF_RMCOMM, 3, NULL, NOQID, NULL)
								!= EX_OK ||
			    Errors > 0)
				break;

			if (LogLevel > 5)
				sm_syslog(LOG_INFO, e->e_id,
					  "%s: ETRN %s", CurSmtpClient,
					  shortenstring(p, MAXSHORTSTR));

			id = p;
			if (*id == '#')
			{
				int i, qgrp;

				id++;
				qgrp = name2qid(id);
				if (!ISVALIDQGRP(qgrp))
				{
					usrerr("459 4.5.4 Queue %s unknown",
					       id);
					break;
				}
				for (i = 0; i < NumQueue && Queue[i] != NULL;
				     i++)
					Queue[i]->qg_nextrun = (time_t) -1;
				Queue[qgrp]->qg_nextrun = 0;
				ok = run_work_group(Queue[qgrp]->qg_wgrp,
						    RWG_FORK|RWG_FORCE);
				if (ok && Errors == 0)
					message("250 2.0.0 Queuing for queue group %s started", id);
				break;
			}

			if (*id == '@@')
				id++;
			else
				*--id = '@@';

			new = (QUEUE_CHAR *) sm_malloc(sizeof(QUEUE_CHAR));
			if (new == NULL)
			{
				syserr("500 5.5.0 ETRN out of memory");
				break;
			}
			new->queue_match = id;
			new->queue_negate = false;
			new->queue_next = NULL;
			QueueLimitRecipient = new;
			ok = runqueue(true, false, false, true);
			sm_free(QueueLimitRecipient); /* XXX */
			QueueLimitRecipient = NULL;
			if (ok && Errors == 0)
				message("250 2.0.0 Queuing for node %s started", p);
			break;

		  case CMDHELP:		/* help -- give user info */
			DELAY_CONN("HELP");
			help(p, e);
			break;

		  case CMDNOOP:		/* noop -- do nothing */
			DELAY_CONN("NOOP");
			STOP_IF_ATTACK(checksmtpattack(&n_noop, MaxNOOPCommands,
							true, "NOOP", e));
			message("250 2.0.0 OK");
			break;

		  case CMDQUIT:		/* quit -- leave mail */
			message("221 2.0.0 %s closing connection", MyHostName);
#if PIPELINING
			(void) sm_io_flush(OutChannel, SM_TIME_DEFAULT);
#endif /* PIPELINING */

			if (smtp.sm_nrcpts > 0)
				logundelrcpts(e, "aborted by sender", 9, false);

			/* arrange to ignore any current send list */
			e->e_sendqueue = NULL;

#if STARTTLS
			/* shutdown TLS connection */
			if (tls_active)
			{
				(void) endtls(srv_ssl, "server");
				tls_active = false;
			}
#endif /* STARTTLS */
#if SASL
			if (authenticating == SASL_IS_AUTH)
			{
				sasl_dispose(&conn);
				authenticating = SASL_NOT_AUTH;
				/* XXX sasl_done(); this is a child */
			}
#endif /* SASL */

doquit:
			/* avoid future 050 messages */
			disconnect(1, e);

#if MILTER
			/* close out milter filters */
			milter_quit(e);
#endif /* MILTER */

			if (tTd(92, 2))
				sm_dprintf("QUIT: e_id=%s, EF_LOGSENDER=%d, LogLevel=%d\n",
					e->e_id,
					bitset(EF_LOGSENDER, e->e_flags),
					LogLevel);
			if (LogLevel > 4 && bitset(EF_LOGSENDER, e->e_flags))
				logsender(e, NULL);
			e->e_flags &= ~EF_LOGSENDER;

			if (lognullconnection && LogLevel > 5 &&
			    nullserver == NULL)
			{
				char *d;

				d = macvalue(macid("{daemon_name}"), e);
				if (d == NULL)
					d = "stdin";

				/*
				**  even though this id is "bogus", it makes
				**  it simpler to "grep" related events, e.g.,
				**  timeouts for the same connection.
				*/

				sm_syslog(LOG_INFO, e->e_id,
					  "%s did not issue MAIL/EXPN/VRFY/ETRN during connection to %s",
					  CurSmtpClient, d);
			}
			if (tTd(93, 100))
			{
				/* return to handle next connection */
				return;
			}
			finis(true, true, ExitStat);
			/* NOTREACHED */

			/* just to avoid bogus warning from some compilers */
			exit(EX_OSERR);

		  case CMDVERB:		/* set verbose mode */
			DELAY_CONN("VERB");
			if (!bitset(SRV_OFFER_EXPN, features) ||
			    !bitset(SRV_OFFER_VERB, features))
			{
				/* this would give out the same info */
				message("502 5.7.0 Verbose unavailable");
				break;
			}
			STOP_IF_ATTACK(checksmtpattack(&n_noop, MaxNOOPCommands,
							true, "VERB", e));
			Verbose = 1;
			set_delivery_mode(SM_DELIVER, e);
			message("250 2.0.0 Verbose mode");
			break;

#if SMTPDEBUG
		  case CMDDBGQSHOW:	/* show queues */
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Send Queue=");
			printaddr(smioout, e->e_sendqueue, true);
			break;

		  case CMDDBGDEBUG:	/* set debug mode */
			tTsetup(tTdvect, sizeof(tTdvect), "0-99.1");
			tTflag(p);
			message("200 2.0.0 Debug set");
			break;

#else /* SMTPDEBUG */
		  case CMDDBGQSHOW:	/* show queues */
		  case CMDDBGDEBUG:	/* set debug mode */
#endif /* SMTPDEBUG */
		  case CMDLOGBOGUS:	/* bogus command */
			DELAY_CONN("Bogus");
			if (LogLevel > 0)
				sm_syslog(LOG_CRIT, e->e_id,
					  "\"%s\" command from %s (%.100s)",
					  c->cmd_name, CurSmtpClient,
					  anynet_ntoa(&RealHostAddr));
			/* FALLTHROUGH */

		  case CMDERROR:	/* unknown command */
#if MAXBADCOMMANDS > 0
			if (++n_badcmds > MAXBADCOMMANDS)
			{
  stopattack:
				message("421 4.7.0 %s Too many bad commands; closing connection",
					MyHostName);

				/* arrange to ignore any current send list */
				e->e_sendqueue = NULL;
				goto doquit;
			}
#endif /* MAXBADCOMMANDS > 0 */

#if MILTER && SMFI_VERSION > 2
			if (smtp.sm_milterlist && smtp.sm_milterize &&
			    !bitset(EF_DISCARD, e->e_flags))
			{
				char state;
				char *response;

				if (MilterLogLevel > 9)
					sm_syslog(LOG_INFO, e->e_id,
						"Sending \"%s\" to Milter", inp);
				response = milter_unknown(inp, e, &state);
				MILTER_REPLY("unknown");
				if (state == SMFIR_REPLYCODE ||
				    state == SMFIR_REJECT ||
				    state == SMFIR_TEMPFAIL ||
				    state == SMFIR_SHUTDOWN)
				{
					/* MILTER_REPLY already gave an error */
					break;
				}
			}
#endif /* MILTER && SMFI_VERSION > 2 */

			usrerr("500 5.5.1 Command unrecognized: \"%s\"",
			       shortenstring(inp, MAXSHORTSTR));
			break;

		  case CMDUNIMPL:
			DELAY_CONN("Unimpl");
			usrerr("502 5.5.1 Command not implemented: \"%s\"",
			       shortenstring(inp, MAXSHORTSTR));
			break;

		  default:
			DELAY_CONN("default");
			errno = 0;
			syserr("500 5.5.0 smtp: unknown code %d", c->cmd_code);
			break;
		}
#if SASL
		}
#endif /* SASL */
	    }
	    SM_EXCEPT(exc, "[!F]*")
	    {
		/*
		**  The only possible exception is "E:mta.quickabort".
		**  There is nothing to do except fall through and loop.
		*/
	    }
	    SM_END_TRY
	}
}
/*
**  SMTP_DATA -- implement the SMTP DATA command.
**
**	Parameters:
**		smtp -- status of SMTP connection.
**		e -- envelope.
**
**	Returns:
**		true iff SMTP session can continue.
**
**	Side Effects:
**		possibly sends message.
*/

static bool
smtp_data(smtp, e)
	SMTP_T *smtp;
	ENVELOPE *e;
{
#if MILTER
	bool milteraccept;
#endif /* MILTER */
	bool aborting;
	bool doublequeue;
	bool rv = true;
	ADDRESS *a;
	ENVELOPE *ee;
	char *id;
	char *oldid;
	unsigned int features;
	char buf[32];

	SmtpPhase = "server DATA";
	if (!smtp->sm_gotmail)
	{
		usrerr("503 5.0.0 Need MAIL command");
		return true;
	}
	else if (smtp->sm_nrcpts <= 0)
	{
		usrerr("503 5.0.0 Need RCPT (recipient)");
		return true;
	}
	(void) sm_snprintf(buf, sizeof(buf), "%u", smtp->sm_nrcpts);
	if (rscheck("check_data", buf, NULL, e,
		    RSF_RMCOMM|RSF_UNSTRUCTURED|RSF_COUNT, 3, NULL,
		    e->e_id, NULL) != EX_OK)
		return true;

#if MILTER && SMFI_VERSION > 3
	if (smtp->sm_milterlist && smtp->sm_milterize &&
	    !bitset(EF_DISCARD, e->e_flags))
	{
		char state;
		char *response;
		int savelogusrerrs = LogUsrErrs;

		response = milter_data_cmd(e, &state);
		switch (state)
		{
		  case SMFIR_REPLYCODE:
			if (MilterLogLevel > 3)
			{
				sm_syslog(LOG_INFO, e->e_id,
					  "Milter: cmd=data, reject=%s",
					  response);
				LogUsrErrs = false;
			}
#if _FFR_MILTER_ENHSC
			if (ISSMTPCODE(response))
				(void) extenhsc(response + 4, ' ', e->e_enhsc);
#endif /* _FFR_MILTER_ENHSC */

			usrerr(response);
			if (strncmp(response, "421 ", 4) == 0
			    || strncmp(response, "421-", 4) == 0)
			{
				e->e_sendqueue = NULL;
				return false;
			}
			return true;

		  case SMFIR_REJECT:
			if (MilterLogLevel > 3)
			{
				sm_syslog(LOG_INFO, e->e_id,
					  "Milter: cmd=data, reject=550 5.7.1 Command rejected");
				LogUsrErrs = false;
			}
#if _FFR_MILTER_ENHSC
			(void) sm_strlcpy(e->e_enhsc, "5.7.1",
					 sizeof(e->e_enhsc));
#endif /* _FFR_MILTER_ENHSC */
			usrerr("550 5.7.1 Command rejected");
			return true;

		  case SMFIR_DISCARD:
			if (MilterLogLevel > 3)
				sm_syslog(LOG_INFO, e->e_id,
					  "Milter: cmd=data, discard");
			e->e_flags |= EF_DISCARD;
			break;

		  case SMFIR_TEMPFAIL:
			if (MilterLogLevel > 3)
			{
				sm_syslog(LOG_INFO, e->e_id,
					  "Milter: cmd=data, reject=%s",
					  MSG_TEMPFAIL);
				LogUsrErrs = false;
			}
#if _FFR_MILTER_ENHSC
			(void) extenhsc(MSG_TEMPFAIL + 4, ' ', e->e_enhsc);
#endif /* _FFR_MILTER_ENHSC */
			usrerr(MSG_TEMPFAIL);
			return true;

		  case SMFIR_SHUTDOWN:
			if (MilterLogLevel > 3)
			{
				sm_syslog(LOG_INFO, e->e_id,
					  "Milter: cmd=data, reject=421 4.7.0 %s closing connection",
					  MyHostName);
				LogUsrErrs = false;
			}
			usrerr("421 4.7.0 %s closing connection", MyHostName);
			e->e_sendqueue = NULL;
			return false;
		}
		LogUsrErrs = savelogusrerrs;
		if (response != NULL)
			sm_free(response); /* XXX */
	}
#endif /* MILTER && SMFI_VERSION > 3 */

	/* put back discard bit */
	if (smtp->sm_discard)
		e->e_flags |= EF_DISCARD;

	/* check to see if we need to re-expand aliases */
	/* also reset QS_BADADDR on already-diagnosted addrs */
	doublequeue = false;
	for (a = e->e_sendqueue; a != NULL; a = a->q_next)
	{
		if (QS_IS_VERIFIED(a->q_state) &&
		    !bitset(EF_DISCARD, e->e_flags))
		{
			/* need to re-expand aliases */
			doublequeue = true;
		}
		if (QS_IS_BADADDR(a->q_state))
		{
			/* make this "go away" */
			a->q_state = QS_DONTSEND;
		}
	}

	/* collect the text of the message */
	SmtpPhase = "collect";
	buffer_errors();

	collect(InChannel, true, NULL, e, true);

	/* redefine message size */
	(void) sm_snprintf(buf, sizeof(buf), "%ld", PRT_NONNEGL(e->e_msgsize));
	macdefine(&e->e_macro, A_TEMP, macid("{msg_size}"), buf);

	/* rscheck() will set Errors or EF_DISCARD if it trips */
	(void) rscheck("check_eom", buf, NULL, e, RSF_UNSTRUCTURED|RSF_COUNT,
		       3, NULL, e->e_id, NULL);

#if MILTER
	milteraccept = true;
	if (smtp->sm_milterlist && smtp->sm_milterize &&
	    Errors <= 0 &&
	    !bitset(EF_DISCARD, e->e_flags))
	{
		char state;
		char *response;

		response = milter_data(e, &state);
		switch (state)
		{
		  case SMFIR_REPLYCODE:
			if (MilterLogLevel > 3)
				sm_syslog(LOG_INFO, e->e_id,
					  "Milter: data, reject=%s",
					  response);
			milteraccept = false;
#if _FFR_MILTER_ENHSC
			if (ISSMTPCODE(response))
				(void) extenhsc(response + 4, ' ', e->e_enhsc);
#endif /* _FFR_MILTER_ENHSC */
			usrerr(response);
			if (strncmp(response, "421 ", 4) == 0
			    || strncmp(response, "421-", 4) == 0)
				rv = false;
			break;

		  case SMFIR_REJECT:
			milteraccept = false;
			if (MilterLogLevel > 3)
				sm_syslog(LOG_INFO, e->e_id,
					  "Milter: data, reject=554 5.7.1 Command rejected");
			usrerr("554 5.7.1 Command rejected");
			break;

		  case SMFIR_DISCARD:
			if (MilterLogLevel > 3)
				sm_syslog(LOG_INFO, e->e_id,
					  "Milter: data, discard");
			milteraccept = false;
			e->e_flags |= EF_DISCARD;
			break;

		  case SMFIR_TEMPFAIL:
			if (MilterLogLevel > 3)
				sm_syslog(LOG_INFO, e->e_id,
					  "Milter: data, reject=%s",
					  MSG_TEMPFAIL);
			milteraccept = false;
#if _FFR_MILTER_ENHSC
			(void) extenhsc(MSG_TEMPFAIL + 4, ' ', e->e_enhsc);
#endif /* _FFR_MILTER_ENHSC */
			usrerr(MSG_TEMPFAIL);
			break;

		  case SMFIR_SHUTDOWN:
			if (MilterLogLevel > 3)
				sm_syslog(LOG_INFO, e->e_id,
					  "Milter: data, reject=421 4.7.0 %s closing connection",
					  MyHostName);
			milteraccept = false;
			usrerr("421 4.7.0 %s closing connection", MyHostName);
			rv = false;
			break;
		}
		if (response != NULL)
			sm_free(response);
	}

	/* Milter may have changed message size */
	(void) sm_snprintf(buf, sizeof(buf), "%ld", PRT_NONNEGL(e->e_msgsize));
	macdefine(&e->e_macro, A_TEMP, macid("{msg_size}"), buf);

	/* abort message filters that didn't get the body & log msg is OK */
	if (smtp->sm_milterlist && smtp->sm_milterize)
	{
		milter_abort(e);
		if (milteraccept && MilterLogLevel > 9)
			sm_syslog(LOG_INFO, e->e_id, "Milter accept: message");
	}

	/*
	**  If SuperSafe is SAFE_REALLY_POSTMILTER, and we don't have milter or
	**  milter accepted message, sync it now
	**
	**  XXX This is almost a copy of the code in collect(): put it into
	**	a function that is called from both places?
	*/

	if (milteraccept && SuperSafe == SAFE_REALLY_POSTMILTER)
	{
		int afd;
		SM_FILE_T *volatile df;
		char *dfname;

		df = e->e_dfp;
		dfname = queuename(e, DATAFL_LETTER);
		if (sm_io_setinfo(df, SM_BF_COMMIT, NULL) < 0
		    && errno != EINVAL)
		{
			int save_errno;

			save_errno = errno;
			if (save_errno == EEXIST)
			{
				struct stat st;
				int dfd;

				if (stat(dfname, &st) < 0)
					st.st_size = -1;
				errno = EEXIST;
				syserr("@@collect: bfcommit(%s): already on disk, size=%ld",
				       dfname, (long) st.st_size);
				dfd = sm_io_getinfo(df, SM_IO_WHAT_FD, NULL);
				if (dfd >= 0)
					dumpfd(dfd, true, true);
			}
			errno = save_errno;
			dferror(df, "bfcommit", e);
			flush_errors(true);
			finis(save_errno != EEXIST, true, ExitStat);
		}
		else if ((afd = sm_io_getinfo(df, SM_IO_WHAT_FD, NULL)) < 0)
		{
			dferror(df, "sm_io_getinfo", e);
			flush_errors(true);
			finis(true, true, ExitStat);
			/* NOTREACHED */
		}
		else if (fsync(afd) < 0)
		{
			dferror(df, "fsync", e);
			flush_errors(true);
			finis(true, true, ExitStat);
			/* NOTREACHED */
		}
		else if (sm_io_close(df, SM_TIME_DEFAULT) < 0)
		{
			dferror(df, "sm_io_close", e);
			flush_errors(true);
			finis(true, true, ExitStat);
			/* NOTREACHED */
		}

		/* Now reopen the df file */
		e->e_dfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, dfname,
					SM_IO_RDONLY, NULL);
		if (e->e_dfp == NULL)
		{
			/* we haven't acked receipt yet, so just chuck this */
			syserr("@@Cannot reopen %s", dfname);
			finis(true, true, ExitStat);
			/* NOTREACHED */
		}
	}
#endif /* MILTER */

	/* Check if quarantining stats should be updated */
	if (e->e_quarmsg != NULL)
		markstats(e, NULL, STATS_QUARANTINE);

	/*
	**  If a header/body check (header checks or milter)
	**  set EF_DISCARD, don't queueup the message --
	**  that would lose the EF_DISCARD bit and deliver
	**  the message.
	*/

	if (bitset(EF_DISCARD, e->e_flags))
		doublequeue = false;

	aborting = Errors > 0;
	if (!(aborting || bitset(EF_DISCARD, e->e_flags)) &&
	    (QueueMode == QM_QUARANTINE || e->e_quarmsg == NULL) &&
	    !split_by_recipient(e))
		aborting = bitset(EF_FATALERRS, e->e_flags);

	if (aborting)
	{
		ADDRESS *q;

		/* Log who the mail would have gone to */
		logundelrcpts(e, e->e_message, 8, false);

		/*
		**  If something above refused the message, we still haven't
		**  accepted responsibility for it.  Don't send DSNs.
		*/

		for (q = e->e_sendqueue; q != NULL; q = q->q_next)
			q->q_flags &= ~Q_PINGFLAGS;

		flush_errors(true);
		buffer_errors();
		goto abortmessage;
	}

	/* from now on, we have to operate silently */
	buffer_errors();

#if 0
	/*
	**  Clear message, it may contain an error from the SMTP dialogue.
	**  This error must not show up in the queue.
	**	Some error message should show up, e.g., alias database
	**	not available, but others shouldn't, e.g., from check_rcpt.
	*/

	e->e_message = NULL;
#endif /* 0 */

	/*
	**  Arrange to send to everyone.
	**	If sending to multiple people, mail back
	**		errors rather than reporting directly.
	**	In any case, don't mail back errors for
	**		anything that has happened up to
	**		now (the other end will do this).
	**	Truncate our transcript -- the mail has gotten
	**		to us successfully, and if we have
	**		to mail this back, it will be easier
	**		on the reader.
	**	Then send to everyone.
	**	Finally give a reply code.  If an error has
	**		already been given, don't mail a
	**		message back.
	**	We goose error returns by clearing error bit.
	*/

	SmtpPhase = "delivery";
	(void) sm_io_setinfo(e->e_xfp, SM_BF_TRUNCATE, NULL);
	id = e->e_id;

#if NAMED_BIND
	_res.retry = TimeOuts.res_retry[RES_TO_FIRST];
	_res.retrans = TimeOuts.res_retrans[RES_TO_FIRST];
#endif /* NAMED_BIND */


	for (ee = e; ee != NULL; ee = ee->e_sibling)
	{
		/* make sure we actually do delivery */
		ee->e_flags &= ~EF_CLRQUEUE;

		/* from now on, operate silently */
		ee->e_errormode = EM_MAIL;

		if (doublequeue)
		{
			/* make sure it is in the queue */
			queueup(ee, false, true);
		}
		else
		{
			int mode;

			/* send to all recipients */
			mode = SM_DEFAULT;
#if _FFR_DM_ONE
			if (SM_DM_ONE == e->e_sendmode)
			{
				if (NotFirstDelivery)
				{
					mode = SM_QUEUE;
					e->e_sendmode = SM_QUEUE;
				}
				else
				{
					mode = SM_FORK;
					NotFirstDelivery = true;
				}
			}
#endif /* _FFR_DM_ONE */
			sendall(ee, mode);
		}
		ee->e_to = NULL;
	}

	/* put back id for SMTP logging in putoutmsg() */
	oldid = CurEnv->e_id;
	CurEnv->e_id = id;

		/* issue success message */
#if _FFR_MSG_ACCEPT
		if (MessageAccept != NULL && *MessageAccept != '\0')
		{
			char msg[MAXLINE];

			expand(MessageAccept, msg, sizeof(msg), e);
			message("250 2.0.0 %s", msg);
		}
		else
#endif /* _FFR_MSG_ACCEPT */
		message("250 2.0.0 %s Message accepted for delivery", id);
	CurEnv->e_id = oldid;

	/* if we just queued, poke it */
	if (doublequeue)
	{
		bool anything_to_send = false;

		sm_getla();
		for (ee = e; ee != NULL; ee = ee->e_sibling)
		{
			if (WILL_BE_QUEUED(ee->e_sendmode))
				continue;
			if (shouldqueue(ee->e_msgpriority, ee->e_ctime))
			{
				ee->e_sendmode = SM_QUEUE;
				continue;
			}
			else if (QueueMode != QM_QUARANTINE &&
				 ee->e_quarmsg != NULL)
			{
				ee->e_sendmode = SM_QUEUE;
				continue;
			}
			anything_to_send = true;

			/* close all the queue files */
			closexscript(ee);
			if (ee->e_dfp != NULL)
			{
				(void) sm_io_close(ee->e_dfp, SM_TIME_DEFAULT);
				ee->e_dfp = NULL;
			}
			unlockqueue(ee);
		}
		if (anything_to_send)
		{
#if PIPELINING
			/*
			**  XXX if we don't do this, we get 250 twice
			**	because it is also flushed in the child.
			*/

			(void) sm_io_flush(OutChannel, SM_TIME_DEFAULT);
#endif /* PIPELINING */
			(void) doworklist(e, true, true);
		}
	}

  abortmessage:
	if (tTd(92, 2))
		sm_dprintf("abortmessage: e_id=%s, EF_LOGSENDER=%d, LogLevel=%d\n",
			e->e_id, bitset(EF_LOGSENDER, e->e_flags), LogLevel);
	if (LogLevel > 4 && bitset(EF_LOGSENDER, e->e_flags))
		logsender(e, NULL);
	e->e_flags &= ~EF_LOGSENDER;

	/* clean up a bit */
	smtp->sm_gotmail = false;

	/*
	**  Call dropenvelope if and only if the envelope is *not*
	**  being processed by the child process forked by doworklist().
	*/

	if (aborting || bitset(EF_DISCARD, e->e_flags))
		(void) dropenvelope(e, true, false);
	else
	{
		for (ee = e; ee != NULL; ee = ee->e_sibling)
		{
			if (!doublequeue &&
			    QueueMode != QM_QUARANTINE &&
			    ee->e_quarmsg != NULL)
			{
				(void) dropenvelope(ee, true, false);
				continue;
			}
			if (WILL_BE_QUEUED(ee->e_sendmode))
				(void) dropenvelope(ee, true, false);
		}
	}

	CurEnv = e;
	features = e->e_features;
	sm_rpool_free(e->e_rpool);
	newenvelope(e, e, sm_rpool_new_x(NULL));
	e->e_flags = BlankEnvelope.e_flags;
	e->e_features = features;

	/* restore connection quarantining */
	if (smtp->sm_quarmsg == NULL)
	{
		e->e_quarmsg = NULL;
		macdefine(&e->e_macro, A_PERM, macid("{quarantine}"), "");
	}
	else
	{
		e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, smtp->sm_quarmsg);
		macdefine(&e->e_macro, A_PERM,
			  macid("{quarantine}"), e->e_quarmsg);
	}
	return rv;
}
/*
**  LOGUNDELRCPTS -- log undelivered (or all) recipients.
**
**	Parameters:
**		e -- envelope.
**		msg -- message for Stat=
**		level -- log level.
**		all -- log all recipients.
**
**	Returns:
**		none.
**
**	Side Effects:
**		logs undelivered (or all) recipients
*/

void
logundelrcpts(e, msg, level, all)
	ENVELOPE *e;
	char *msg;
	int level;
	bool all;
{
	ADDRESS *a;

	if (LogLevel <= level || msg == NULL || *msg == '\0')
		return;

	/* Clear $h so relay= doesn't get mislogged by logdelivery() */
	macdefine(&e->e_macro, A_PERM, 'h', NULL);

	/* Log who the mail would have gone to */
	for (a = e->e_sendqueue; a != NULL; a = a->q_next)
	{
		if (!QS_IS_UNDELIVERED(a->q_state) && !all)
			continue;
		e->e_to = a->q_paddr;
		logdelivery(NULL, NULL,
#if _FFR_MILTER_ENHSC
			    (a->q_status == NULL && e->e_enhsc[0] != '\0')
			    ? e->e_enhsc :
#endif /* _FFR_MILTER_ENHSC */
			    a->q_status,
			    msg, NULL, (time_t) 0, e);
	}
	e->e_to = NULL;
}
/*
**  CHECKSMTPATTACK -- check for denial-of-service attack by repetition
**
**	Parameters:
**		pcounter -- pointer to a counter for this command.
**		maxcount -- maximum value for this counter before we
**			slow down.
**		waitnow -- sleep now (in this routine)?
**		cname -- command name for logging.
**		e -- the current envelope.
**
**	Returns:
**		time to wait,
**		STOP_ATTACK if twice as many commands as allowed and
**			MaxChildren > 0.
**
**	Side Effects:
**		Slows down if we seem to be under attack.
*/

static time_t
checksmtpattack(pcounter, maxcount, waitnow, cname, e)
	volatile unsigned int *pcounter;
	unsigned int maxcount;
	bool waitnow;
	char *cname;
	ENVELOPE *e;
{
	if (maxcount <= 0)	/* no limit */
		return (time_t) 0;

	if (++(*pcounter) >= maxcount)
	{
		unsigned int shift;
		time_t s;

		if (*pcounter == maxcount && LogLevel > 5)
		{
			sm_syslog(LOG_INFO, e->e_id,
				  "%s: possible SMTP attack: command=%.40s, count=%u",
				  CurSmtpClient, cname, *pcounter);
		}
		shift = *pcounter - maxcount;
		s = 1 << shift;
		if (shift > MAXSHIFT || s >= MAXTIMEOUT || s <= 0)
			s = MAXTIMEOUT;

#define IS_ATTACK(s)	((MaxChildren > 0 && *pcounter >= maxcount * 2)	\
				? STOP_ATTACK : (time_t) s)

		/* sleep at least 1 second before returning */
		(void) sleep(*pcounter / maxcount);
		s -= *pcounter / maxcount;
		if (s >= MAXTIMEOUT || s < 0)
			s = MAXTIMEOUT;
		if (waitnow && s > 0)
		{
			(void) sleep(s);
			return IS_ATTACK(0);
		}
		return IS_ATTACK(s);
	}
	return (time_t) 0;
}
/*
**  SETUP_SMTPD_IO -- setup I/O fd correctly for the SMTP server
**
**	Parameters:
**		none.
**
**	Returns:
**		nothing.
**
**	Side Effects:
**		may change I/O fd.
*/

static void
setup_smtpd_io()
{
	int inchfd, outchfd, outfd;

	inchfd = sm_io_getinfo(InChannel, SM_IO_WHAT_FD, NULL);
	outchfd  = sm_io_getinfo(OutChannel, SM_IO_WHAT_FD, NULL);
	outfd = sm_io_getinfo(smioout, SM_IO_WHAT_FD, NULL);
	if (outchfd != outfd)
	{
		/* arrange for debugging output to go to remote host */
		(void) dup2(outchfd, outfd);
	}

	/*
	**  if InChannel and OutChannel are stdin/stdout
	**  and connected to ttys
	**  and fcntl(STDIN, F_SETFL, O_NONBLOCKING) also changes STDOUT,
	**  then "chain" them together.
	*/

	if (inchfd == STDIN_FILENO && outchfd == STDOUT_FILENO &&
	    isatty(inchfd) && isatty(outchfd))
	{
		int inmode, outmode;

		inmode = fcntl(inchfd, F_GETFL, 0);
		if (inmode == -1)
		{
			if (LogLevel > 11)
				sm_syslog(LOG_INFO, NOQID,
					"fcntl(inchfd, F_GETFL) failed: %s",
					sm_errstring(errno));
			return;
		}
		outmode = fcntl(outchfd, F_GETFL, 0);
		if (outmode == -1)
		{
			if (LogLevel > 11)
				sm_syslog(LOG_INFO, NOQID,
					"fcntl(outchfd, F_GETFL) failed: %s",
					sm_errstring(errno));
			return;
		}
		if (bitset(O_NONBLOCK, inmode) ||
		    bitset(O_NONBLOCK, outmode) ||
		    fcntl(inchfd, F_SETFL, inmode | O_NONBLOCK) == -1)
			return;
		outmode = fcntl(outchfd, F_GETFL, 0);
		if (outmode != -1 && bitset(O_NONBLOCK, outmode))
		{
			/* changing InChannel also changes OutChannel */
			sm_io_automode(OutChannel, InChannel);
			if (tTd(97, 4) && LogLevel > 9)
				sm_syslog(LOG_INFO, NOQID,
					  "set automode for I (%d)/O (%d) in SMTP server",
					  inchfd, outchfd);
		}

		/* undo change of inchfd */
		(void) fcntl(inchfd, F_SETFL, inmode);
	}
}
/*
**  SKIPWORD -- skip a fixed word.
**
**	Parameters:
**		p -- place to start looking.
**		w -- word to skip.
**
**	Returns:
**		p following w.
**		NULL on error.
**
**	Side Effects:
**		clobbers the p data area.
*/

static char *
skipword(p, w)
	register char *volatile p;
	char *w;
{
	register char *q;
	char *firstp = p;

	/* find beginning of word */
	SKIP_SPACE(p);
	q = p;

	/* find end of word */
	while (*p != '\0' && *p != ':' && !(isascii(*p) && isspace(*p)))
		p++;
	while (isascii(*p) && isspace(*p))
		*p++ = '\0';
	if (*p != ':')
	{
	  syntax:
		usrerr("501 5.5.2 Syntax error in parameters scanning \"%s\"",
			shortenstring(firstp, MAXSHORTSTR));
		return NULL;
	}
	*p++ = '\0';
	SKIP_SPACE(p);

	if (*p == '\0')
		goto syntax;

	/* see if the input word matches desired word */
	if (sm_strcasecmp(q, w))
		goto syntax;

	return p;
}

/*
**  RESET_MAIL_ESMTP_ARGS -- process ESMTP arguments from MAIL line
**
**	Parameters:
**		e -- the envelope.
**
**	Returns:
**		none.
*/

void
reset_mail_esmtp_args(e)
	ENVELOPE *e;
{
	/* "size": no reset */

	/* "body" */
	SevenBitInput = SevenBitInput_Saved;
	e->e_bodytype = NULL;

	/* "envid" */
	e->e_envid = NULL;
	macdefine(&e->e_macro, A_PERM, macid("{dsn_envid}"), NULL);

	/* "ret" */
	e->e_flags &= ~(EF_RET_PARAM|EF_NO_BODY_RETN);
	macdefine(&e->e_macro, A_TEMP, macid("{dsn_ret}"), NULL);

#if SASL
	/* "auth" */
	macdefine(&e->e_macro, A_TEMP, macid("{auth_author}"), NULL);
	e->e_auth_param = "";
# if _FFR_AUTH_PASSING
	macdefine(&BlankEnvelope.e_macro, A_PERM,
				  macid("{auth_author}"), NULL);
# endif /* _FFR_AUTH_PASSING */
#endif /* SASL */

	/* "by" */
	e->e_deliver_by = 0;
	e->e_dlvr_flag = 0;
}

/*
**  MAIL_ESMTP_ARGS -- process ESMTP arguments from MAIL line
**
**	Parameters:
**		a -- address (unused, for compatibility with rcpt_esmtp_args)
**		kp -- the parameter key.
**		vp -- the value of that parameter.
**		e -- the envelope.
**
**	Returns:
**		none.
*/

void
mail_esmtp_args(a, kp, vp, e)
	ADDRESS *a;
	char *kp;
	char *vp;
	ENVELOPE *e;
{
	if (sm_strcasecmp(kp, "size") == 0)
	{
		if (vp == NULL)
		{
			usrerr("501 5.5.2 SIZE requires a value");
			/* NOTREACHED */
		}
		macdefine(&e->e_macro, A_TEMP, macid("{msg_size}"), vp);
		errno = 0;
		e->e_msgsize = strtol(vp, (char **) NULL, 10);
		if (e->e_msgsize == LONG_MAX && errno == ERANGE)
		{
			usrerr("552 5.2.3 Message size exceeds maximum value");
			/* NOTREACHED */
		}
		if (e->e_msgsize < 0)
		{
			usrerr("552 5.2.3 Message size invalid");
			/* NOTREACHED */
		}
	}
	else if (sm_strcasecmp(kp, "body") == 0)
	{
		if (vp == NULL)
		{
			usrerr("501 5.5.2 BODY requires a value");
			/* NOTREACHED */
		}
		else if (sm_strcasecmp(vp, "8bitmime") == 0)
		{
			SevenBitInput = false;
		}
		else if (sm_strcasecmp(vp, "7bit") == 0)
		{
			SevenBitInput = true;
		}
		else
		{
			usrerr("501 5.5.4 Unknown BODY type %s", vp);
			/* NOTREACHED */
		}
		e->e_bodytype = sm_rpool_strdup_x(e->e_rpool, vp);
	}
	else if (sm_strcasecmp(kp, "envid") == 0)
	{
		if (!bitset(SRV_OFFER_DSN, e->e_features))
		{
			usrerr("504 5.7.0 Sorry, ENVID not supported, we do not allow DSN");
			/* NOTREACHED */
		}
		if (vp == NULL)
		{
			usrerr("501 5.5.2 ENVID requires a value");
			/* NOTREACHED */
		}
		if (!xtextok(vp))
		{
			usrerr("501 5.5.4 Syntax error in ENVID parameter value");
			/* NOTREACHED */
		}
		if (e->e_envid != NULL)
		{
			usrerr("501 5.5.0 Duplicate ENVID parameter");
			/* NOTREACHED */
		}
		e->e_envid = sm_rpool_strdup_x(e->e_rpool, vp);
		macdefine(&e->e_macro, A_PERM,
			macid("{dsn_envid}"), e->e_envid);
	}
	else if (sm_strcasecmp(kp, "ret") == 0)
	{
		if (!bitset(SRV_OFFER_DSN, e->e_features))
		{
			usrerr("504 5.7.0 Sorry, RET not supported, we do not allow DSN");
			/* NOTREACHED */
		}
		if (vp == NULL)
		{
			usrerr("501 5.5.2 RET requires a value");
			/* NOTREACHED */
		}
		if (bitset(EF_RET_PARAM, e->e_flags))
		{
			usrerr("501 5.5.0 Duplicate RET parameter");
			/* NOTREACHED */
		}
		e->e_flags |= EF_RET_PARAM;
		if (sm_strcasecmp(vp, "hdrs") == 0)
			e->e_flags |= EF_NO_BODY_RETN;
		else if (sm_strcasecmp(vp, "full") != 0)
		{
			usrerr("501 5.5.2 Bad argument \"%s\" to RET", vp);
			/* NOTREACHED */
		}
		macdefine(&e->e_macro, A_TEMP, macid("{dsn_ret}"), vp);
	}
#if SASL
	else if (sm_strcasecmp(kp, "auth") == 0)
	{
		int len;
		char *q;
		char *auth_param;	/* the value of the AUTH=x */
		bool saveQuickAbort = QuickAbort;
		bool saveSuprErrs = SuprErrs;
		bool saveExitStat = ExitStat;

		if (vp == NULL)
		{
			usrerr("501 5.5.2 AUTH= requires a value");
			/* NOTREACHED */
		}
		if (e->e_auth_param != NULL)
		{
			usrerr("501 5.5.0 Duplicate AUTH parameter");
			/* NOTREACHED */
		}
		if ((q = strchr(vp, ' ')) != NULL)
			len = q - vp + 1;
		else
			len = strlen(vp) + 1;
		auth_param = xalloc(len);
		(void) sm_strlcpy(auth_param, vp, len);
		if (!xtextok(auth_param))
		{
			usrerr("501 5.5.4 Syntax error in AUTH parameter value");
			/* just a warning? */
			/* NOTREACHED */
		}

		/* XXX define this always or only if trusted? */
		macdefine(&e->e_macro, A_TEMP, macid("{auth_author}"),
			  auth_param);

		/*
		**  call Strust_auth to find out whether
		**  auth_param is acceptable (trusted)
		**  we shouldn't trust it if not authenticated
		**  (required by RFC, leave it to ruleset?)
		*/

		SuprErrs = true;
		QuickAbort = false;
		if (strcmp(auth_param, "<>") != 0 &&
		     (rscheck("trust_auth", auth_param, NULL, e, RSF_RMCOMM,
			      9, NULL, NOQID, NULL) != EX_OK || Errors > 0))
		{
			if (tTd(95, 8))
			{
				q = e->e_auth_param;
				sm_dprintf("auth=\"%.100s\" not trusted user=\"%.100s\"\n",
					auth_param, (q == NULL) ? "" : q);
			}

			/* not trusted */
			e->e_auth_param = "<>";
# if _FFR_AUTH_PASSING
			macdefine(&BlankEnvelope.e_macro, A_PERM,
				  macid("{auth_author}"), NULL);
# endif /* _FFR_AUTH_PASSING */
		}
		else
		{
			if (tTd(95, 8))
				sm_dprintf("auth=\"%.100s\" trusted\n", auth_param);
			e->e_auth_param = sm_rpool_strdup_x(e->e_rpool,
							    auth_param);
		}
		sm_free(auth_param); /* XXX */

		/* reset values */
		Errors = 0;
		QuickAbort = saveQuickAbort;
		SuprErrs = saveSuprErrs;
		ExitStat = saveExitStat;
	}
#endif /* SASL */
#define PRTCHAR(c)	((isascii(c) && isprint(c)) ? (c) : '?')

	/*
	**  "by" is only accepted if DeliverByMin >= 0.
	**  We maybe could add this to the list of server_features.
	*/

	else if (sm_strcasecmp(kp, "by") == 0 && DeliverByMin >= 0)
	{
		char *s;

		if (vp == NULL)
		{
			usrerr("501 5.5.2 BY= requires a value");
			/* NOTREACHED */
		}
		errno = 0;
		e->e_deliver_by = strtol(vp, &s, 10);
		if (e->e_deliver_by == LONG_MIN ||
		    e->e_deliver_by == LONG_MAX ||
		    e->e_deliver_by > 999999999l ||
		    e->e_deliver_by < -999999999l)
		{
			usrerr("501 5.5.2 BY=%s out of range", vp);
			/* NOTREACHED */
		}
		if (s == NULL || *s != ';')
		{
			usrerr("501 5.5.2 BY= missing ';'");
			/* NOTREACHED */
		}
		e->e_dlvr_flag = 0;
		++s;	/* XXX: spaces allowed? */
		SKIP_SPACE(s);
		switch (tolower(*s))
		{
		  case 'n':
			e->e_dlvr_flag = DLVR_NOTIFY;
			break;
		  case 'r':
			e->e_dlvr_flag = DLVR_RETURN;
			if (e->e_deliver_by <= 0)
			{
				usrerr("501 5.5.4 mode R requires BY time > 0");
				/* NOTREACHED */
			}
			if (DeliverByMin > 0 && e->e_deliver_by > 0 &&
			    e->e_deliver_by < DeliverByMin)
			{
				usrerr("555 5.5.2 time %ld less than %ld",
					e->e_deliver_by, (long) DeliverByMin);
				/* NOTREACHED */
			}
			break;
		  default:
			usrerr("501 5.5.2 illegal by-mode '%c'", PRTCHAR(*s));
			/* NOTREACHED */
		}
		++s;	/* XXX: spaces allowed? */
		SKIP_SPACE(s);
		switch (tolower(*s))
		{
		  case 't':
			e->e_dlvr_flag |= DLVR_TRACE;
			break;
		  case '\0':
			break;
		  default:
			usrerr("501 5.5.2 illegal by-trace '%c'", PRTCHAR(*s));
			/* NOTREACHED */
		}

		/* XXX: check whether more characters follow? */
	}
	else
	{
		usrerr("555 5.5.4 %s parameter unrecognized", kp);
		/* NOTREACHED */
	}
}

/*
**  RCPT_ESMTP_ARGS -- process ESMTP arguments from RCPT line
**
**	Parameters:
**		a -- the address corresponding to the To: parameter.
**		kp -- the parameter key.
**		vp -- the value of that parameter.
**		e -- the envelope.
**
**	Returns:
**		none.
*/

void
rcpt_esmtp_args(a, kp, vp, e)
	ADDRESS *a;
	char *kp;
	char *vp;
	ENVELOPE *e;
{
	if (sm_strcasecmp(kp, "notify") == 0)
	{
		char *p;

		if (!bitset(SRV_OFFER_DSN, e->e_features))
		{
			usrerr("504 5.7.0 Sorry, NOTIFY not supported, we do not allow DSN");
			/* NOTREACHED */
		}
		if (vp == NULL)
		{
			usrerr("501 5.5.2 NOTIFY requires a value");
			/* NOTREACHED */
		}
		a->q_flags &= ~(QPINGONSUCCESS|QPINGONFAILURE|QPINGONDELAY);
		a->q_flags |= QHASNOTIFY;
		macdefine(&e->e_macro, A_TEMP, macid("{dsn_notify}"), vp);

		if (sm_strcasecmp(vp, "never") == 0)
			return;
		for (p = vp; p != NULL; vp = p)
		{
			char *s;

			s = p = strchr(p, ',');
			if (p != NULL)
				*p++ = '\0';
			if (sm_strcasecmp(vp, "success") == 0)
				a->q_flags |= QPINGONSUCCESS;
			else if (sm_strcasecmp(vp, "failure") == 0)
				a->q_flags |= QPINGONFAILURE;
			else if (sm_strcasecmp(vp, "delay") == 0)
				a->q_flags |= QPINGONDELAY;
			else
			{
				usrerr("501 5.5.4 Bad argument \"%s\"  to NOTIFY",
					vp);
				/* NOTREACHED */
			}
			if (s != NULL)
				*s = ',';
		}
	}
	else if (sm_strcasecmp(kp, "orcpt") == 0)
	{
		char *p;

		if (!bitset(SRV_OFFER_DSN, e->e_features))
		{
			usrerr("504 5.7.0 Sorry, ORCPT not supported, we do not allow DSN");
			/* NOTREACHED */
		}
		if (vp == NULL)
		{
			usrerr("501 5.5.2 ORCPT requires a value");
			/* NOTREACHED */
		}
		if (a->q_orcpt != NULL)
		{
			usrerr("501 5.5.0 Duplicate ORCPT parameter");
			/* NOTREACHED */
		}
		p = strchr(vp, ';');
		if (p == NULL)
		{
			usrerr("501 5.5.4 Syntax error in ORCPT parameter value");
			/* NOTREACHED */
		}
		*p = '\0';
		if (!isatom(vp) || !xtextok(p + 1))
		{
			*p = ';';
			usrerr("501 5.5.4 Syntax error in ORCPT parameter value");
			/* NOTREACHED */
		}
		*p = ';';
		a->q_orcpt = sm_rpool_strdup_x(e->e_rpool, vp);
	}
	else
	{
		usrerr("555 5.5.4 %s parameter unrecognized", kp);
		/* NOTREACHED */
	}
}
/*
**  PRINTVRFYADDR -- print an entry in the verify queue
**
**	Parameters:
**		a -- the address to print.
**		last -- set if this is the last one.
**		vrfy -- set if this is a VRFY command.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Prints the appropriate 250 codes.
*/
#define OFFF	(3 + 1 + 5 + 1)	/* offset in fmt: SMTP reply + enh. code */

static void
printvrfyaddr(a, last, vrfy)
	register ADDRESS *a;
	bool last;
	bool vrfy;
{
	char fmtbuf[30];

	if (vrfy && a->q_mailer != NULL &&
	    !bitnset(M_VRFY250, a->q_mailer->m_flags))
		(void) sm_strlcpy(fmtbuf, "252", sizeof(fmtbuf));
	else
		(void) sm_strlcpy(fmtbuf, "250", sizeof(fmtbuf));
	fmtbuf[3] = last ? ' ' : '-';
	(void) sm_strlcpy(&fmtbuf[4], "2.1.5 ", sizeof(fmtbuf) - 4);
	if (a->q_fullname == NULL)
	{
		if ((a->q_mailer == NULL ||
		     a->q_mailer->m_addrtype == NULL ||
		     sm_strcasecmp(a->q_mailer->m_addrtype, "rfc822") == 0) &&
		    strchr(a->q_user, '@@') == NULL)
			(void) sm_strlcpy(&fmtbuf[OFFF], "<%s@@%s>",
				       sizeof(fmtbuf) - OFFF);
		else
			(void) sm_strlcpy(&fmtbuf[OFFF], "<%s>",
				       sizeof(fmtbuf) - OFFF);
		message(fmtbuf, a->q_user, MyHostName);
	}
	else
	{
		if ((a->q_mailer == NULL ||
		     a->q_mailer->m_addrtype == NULL ||
		     sm_strcasecmp(a->q_mailer->m_addrtype, "rfc822") == 0) &&
		    strchr(a->q_user, '@@') == NULL)
			(void) sm_strlcpy(&fmtbuf[OFFF], "%s <%s@@%s>",
				       sizeof(fmtbuf) - OFFF);
		else
			(void) sm_strlcpy(&fmtbuf[OFFF], "%s <%s>",
				       sizeof(fmtbuf) - OFFF);
		message(fmtbuf, a->q_fullname, a->q_user, MyHostName);
	}
}

#if SASL
/*
**  SASLMECHS -- get list of possible AUTH mechanisms
**
**	Parameters:
**		conn -- SASL connection info.
**		mechlist -- output parameter for list of mechanisms.
**
**	Returns:
**		number of mechs.
*/

static int
saslmechs(conn, mechlist)
	sasl_conn_t *conn;
	char **mechlist;
{
	int len, num, result;

	/* "user" is currently unused */
# if SASL >= 20000
	result = sasl_listmech(conn, NULL,
			       "", " ", "", (const char **) mechlist,
			       (unsigned int *)&len, &num);
# else /* SASL >= 20000 */
	result = sasl_listmech(conn, "user", /* XXX */
			       "", " ", "", mechlist,
			       (unsigned int *)&len, (unsigned int *)&num);
# endif /* SASL >= 20000 */
	if (result != SASL_OK)
	{
		if (LogLevel > 9)
			sm_syslog(LOG_WARNING, NOQID,
				  "AUTH error: listmech=%d, num=%d",
				  result, num);
		num = 0;
	}
	if (num > 0)
	{
		if (LogLevel > 11)
			sm_syslog(LOG_INFO, NOQID,
				  "AUTH: available mech=%s, allowed mech=%s",
				  *mechlist, AuthMechanisms);
		*mechlist = intersect(AuthMechanisms, *mechlist, NULL);
	}
	else
	{
		*mechlist = NULL;	/* be paranoid... */
		if (result == SASL_OK && LogLevel > 9)
			sm_syslog(LOG_WARNING, NOQID,
				  "AUTH warning: no mechanisms");
	}
	return num;
}

# if SASL >= 20000
/*
**  PROXY_POLICY -- define proxy policy for AUTH
**
**	Parameters:
**		conn -- unused.
**		context -- unused.
**		requested_user -- authorization identity.
**		rlen -- authorization identity length.
**		auth_identity -- authentication identity.
**		alen -- authentication identity length.
**		def_realm -- default user realm.
**		urlen -- user realm length.
**		propctx -- unused.
**
**	Returns:
**		ok?
**
**	Side Effects:
**		sets {auth_authen} macro.
*/

int
proxy_policy(conn, context, requested_user, rlen, auth_identity, alen,
	     def_realm, urlen, propctx)
	sasl_conn_t *conn;
	void *context;
	const char *requested_user;
	unsigned rlen;
	const char *auth_identity;
	unsigned alen;
	const char *def_realm;
	unsigned urlen;
	struct propctx *propctx;
{
	if (auth_identity == NULL)
		return SASL_FAIL;

	macdefine(&BlankEnvelope.e_macro, A_TEMP,
		  macid("{auth_authen}"),
		  xtextify((char *) auth_identity, "=<>\")"));

	return SASL_OK;
}
# else /* SASL >= 20000 */

/*
**  PROXY_POLICY -- define proxy policy for AUTH
**
**	Parameters:
**		context -- unused.
**		auth_identity -- authentication identity.
**		requested_user -- authorization identity.
**		user -- allowed user (output).
**		errstr -- possible error string (output).
**
**	Returns:
**		ok?
*/

int
proxy_policy(context, auth_identity, requested_user, user, errstr)
	void *context;
	const char *auth_identity;
	const char *requested_user;
	const char **user;
	const char **errstr;
{
	if (user == NULL || auth_identity == NULL)
		return SASL_FAIL;
	*user = newstr(auth_identity);
	return SASL_OK;
}
# endif /* SASL >= 20000 */
#endif /* SASL */

#if STARTTLS
/*
**  INITSRVTLS -- initialize server side TLS
**
**	Parameters:
**		tls_ok -- should tls initialization be done?
**
**	Returns:
**		succeeded?
**
**	Side Effects:
**		sets tls_ok_srv which is a static variable in this module.
**		Do NOT remove assignments to it!
*/

bool
initsrvtls(tls_ok)
	bool tls_ok;
{
	if (!tls_ok)
		return false;

	/* do NOT remove assignment */
	tls_ok_srv = inittls(&srv_ctx, TLS_Srv_Opts, Srv_SSL_Options, true,
			     SrvCertFile, SrvKeyFile,
			     CACertPath, CACertFile, DHParams);
	return tls_ok_srv;
}
#endif /* STARTTLS */
/*
**  SRVFEATURES -- get features for SMTP server
**
**	Parameters:
**		e -- envelope (should be session context).
**		clientname -- name of client.
**		features -- default features for this invocation.
**
**	Returns:
**		server features.
*/

/* table with options: it uses just one character, how about strings? */
static struct
{
	char		srvf_opt;
	unsigned int	srvf_flag;
} srv_feat_table[] =
{
	{ 'A',	SRV_OFFER_AUTH	},
	{ 'B',	SRV_OFFER_VERB	},
	{ 'C',	SRV_REQ_SEC	},
	{ 'D',	SRV_OFFER_DSN	},
	{ 'E',	SRV_OFFER_ETRN	},
	{ 'L',	SRV_REQ_AUTH	},
#if PIPELINING
# if _FFR_NO_PIPE
	{ 'N',	SRV_NO_PIPE	},
# endif /* _FFR_NO_PIPE */
	{ 'P',	SRV_OFFER_PIPE	},
#endif /* PIPELINING */
	{ 'R',	SRV_VRFY_CLT	},	/* same as V; not documented */
	{ 'S',	SRV_OFFER_TLS	},
/*	{ 'T',	SRV_TMP_FAIL	},	*/
	{ 'V',	SRV_VRFY_CLT	},
	{ 'X',	SRV_OFFER_EXPN	},
/*	{ 'Y',	SRV_OFFER_VRFY	},	*/
	{ '\0',	SRV_NONE	}
};

static unsigned int
srvfeatures(e, clientname, features)
	ENVELOPE *e;
	char *clientname;
	unsigned int features;
{
	int r, i, j;
	char **pvp, c, opt;
	char pvpbuf[PSBUFSIZE];

	pvp = NULL;
	r = rscap("srv_features", clientname, "", e, &pvp, pvpbuf,
		  sizeof(pvpbuf));
	if (r != EX_OK)
		return features;
	if (pvp == NULL || pvp[0] == NULL || (pvp[0][0] & 0377) != CANONNET)
		return features;
	if (pvp[1] != NULL && sm_strncasecmp(pvp[1], "temp", 4) == 0)
		return SRV_TMP_FAIL;

	/*
	**  General rule (see sendmail.h, d_flags):
	**  lower case: required/offered, upper case: Not required/available
	**
	**  Since we can change some features per daemon, we have both
	**  cases here: turn on/off a feature.
	*/

	for (i = 1; pvp[i] != NULL; i++)
	{
		c = pvp[i][0];
		j = 0;
		for (;;)
		{
			if ((opt = srv_feat_table[j].srvf_opt) == '\0')
			{
				if (LogLevel > 9)
					sm_syslog(LOG_WARNING, e->e_id,
						  "srvfeatures: unknown feature %s",
						  pvp[i]);
				break;
			}
			if (c == opt)
			{
				features &= ~(srv_feat_table[j].srvf_flag);
				break;
			}
			if (c == tolower(opt))
			{
				features |= srv_feat_table[j].srvf_flag;
				break;
			}
			++j;
		}
	}
	return features;
}

/*
**  HELP -- implement the HELP command.
**
**	Parameters:
**		topic -- the topic we want help for.
**		e -- envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		outputs the help file to message output.
*/
#define HELPVSTR	"#vers	"
#define HELPVERSION	2

void
help(topic, e)
	char *topic;
	ENVELOPE *e;
{
	register SM_FILE_T *hf;
	register char *p;
	int len;
	bool noinfo;
	bool first = true;
	long sff = SFF_OPENASROOT|SFF_REGONLY;
	char buf[MAXLINE];
	char inp[MAXLINE];
	static int foundvers = -1;
	extern char Version[];

	if (DontLockReadFiles)
		sff |= SFF_NOLOCK;
	if (!bitnset(DBS_HELPFILEINUNSAFEDIRPATH, DontBlameSendmail))
		sff |= SFF_SAFEDIRPATH;

	if (HelpFile == NULL ||
	    (hf = safefopen(HelpFile, O_RDONLY, 0444, sff)) == NULL)
	{
		/* no help */
		errno = 0;
		message("502 5.3.0 Sendmail %s -- HELP not implemented",
			Version);
		return;
	}

	if (topic == NULL || *topic == '\0')
	{
		topic = "smtp";
		noinfo = false;
	}
	else
	{
		makelower(topic);
		noinfo = true;
	}

	len = strlen(topic);

	while (sm_io_fgets(hf, SM_TIME_DEFAULT, buf, sizeof(buf)) >= 0)
	{
		if (buf[0] == '#')
		{
			if (foundvers < 0 &&
			    strncmp(buf, HELPVSTR, strlen(HELPVSTR)) == 0)
			{
				int h;

				if (sm_io_sscanf(buf + strlen(HELPVSTR), "%d",
						 &h) == 1)
					foundvers = h;
			}
			continue;
		}
		if (strncmp(buf, topic, len) == 0)
		{
			if (first)
			{
				first = false;

				/* print version if no/old vers# in file */
				if (foundvers < 2 && !noinfo)
					message("214-2.0.0 This is Sendmail version %s", Version);
			}
			p = strpbrk(buf, " \t");
			if (p == NULL)
				p = buf + strlen(buf) - 1;
			else
				p++;
			fixcrlf(p, true);
			if (foundvers >= 2)
			{
				char *lbp;
				int lbs = sizeof(buf) - (p - buf);

				lbp = translate_dollars(p, p, &lbs);
				expand(lbp, inp, sizeof(inp), e);
				if (p != lbp)
					sm_free(lbp);
				p = inp;
			}
			message("214-2.0.0 %s", p);
			noinfo = false;
		}
	}

	if (noinfo)
		message("504 5.3.0 HELP topic \"%.10s\" unknown", topic);
	else
		message("214 2.0.0 End of HELP info");

	if (foundvers != 0 && foundvers < HELPVERSION)
	{
		if (LogLevel > 1)
			sm_syslog(LOG_WARNING, e->e_id,
				  "%s too old (require version %d)",
				  HelpFile, HELPVERSION);

		/* avoid log next time */
		foundvers = 0;
	}

	(void) sm_io_close(hf, SM_TIME_DEFAULT);
}

#if SASL
/*
**  RESET_SASLCONN -- reset SASL connection data
**
**	Parameters:
**		conn -- SASL connection context
**		hostname -- host name
**		various connection data
**
**	Returns:
**		SASL result
*/

static int
reset_saslconn(sasl_conn_t **conn, char *hostname,
# if SASL >= 20000
	       char *remoteip, char *localip,
	       char *auth_id, sasl_ssf_t * ext_ssf)
# else /* SASL >= 20000 */
	       struct sockaddr_in *saddr_r, struct sockaddr_in *saddr_l,
	       sasl_external_properties_t * ext_ssf)
# endif /* SASL >= 20000 */
{
	int result;

	sasl_dispose(conn);
# if SASL >= 20000
	result = sasl_server_new("smtp", hostname, NULL, NULL, NULL,
				 NULL, 0, conn);
# elif SASL > 10505
	/* use empty realm: only works in SASL > 1.5.5 */
	result = sasl_server_new("smtp", hostname, "", NULL, 0, conn);
# else /* SASL >= 20000 */
	/* use no realm -> realm is set to hostname by SASL lib */
	result = sasl_server_new("smtp", hostname, NULL, NULL, 0,
				 conn);
# endif /* SASL >= 20000 */
	if (result != SASL_OK)
		return result;

# if SASL >= 20000
#  if NETINET || NETINET6
	if (remoteip != NULL && *remoteip != '\0')
		result = sasl_setprop(*conn, SASL_IPREMOTEPORT, remoteip);
	if (result != SASL_OK)
		return result;

	if (localip != NULL && *localip != '\0')
		result = sasl_setprop(*conn, SASL_IPLOCALPORT, localip);
	if (result != SASL_OK)
		return result;
#  endif /* NETINET || NETINET6 */

	result = sasl_setprop(*conn, SASL_SSF_EXTERNAL, ext_ssf);
	if (result != SASL_OK)
		return result;

	result = sasl_setprop(*conn, SASL_AUTH_EXTERNAL, auth_id);
	if (result != SASL_OK)
		return result;
# else /* SASL >= 20000 */
#  if NETINET
	if (saddr_r != NULL)
		result = sasl_setprop(*conn, SASL_IP_REMOTE, saddr_r);
	if (result != SASL_OK)
		return result;

	if (saddr_l != NULL)
		result = sasl_setprop(*conn, SASL_IP_LOCAL, saddr_l);
	if (result != SASL_OK)
		return result;
#  endif /* NETINET */

	result = sasl_setprop(*conn, SASL_SSF_EXTERNAL, ext_ssf);
	if (result != SASL_OK)
		return result;
# endif /* SASL >= 20000 */
	return SASL_OK;
}
#endif /* SASL */
@


1.32
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.31
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2010, 2012, 2013 Sendmail, Inc. and its suppliers.
d20 1
a20 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.1015 2013/03/12 15:24:54 ca Exp $")
@


1.30
log
@Update to sendmail 8.14.6
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2010, 2012 Sendmail, Inc. and its suppliers.
d20 1
a20 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.1011 2012/12/19 02:49:21 ca Exp $")
d1867 1
a1867 1
					tlslogerr("server");
d1930 1
a1930 1
						tlslogerr("server");
d4521 2
d4533 7
a4539 1
		if (strchr(vp, ';') == NULL || !xtextok(vp))
d4544 2
a4545 1
		if (a->q_orcpt != NULL)
d4547 2
a4548 1
			usrerr("501 5.5.0 Duplicate ORCPT parameter");
d4551 1
d4919 2
a4920 1
		message("502 5.3.0 HELP not implemented");
d4937 1
a4937 1
	while (sm_io_fgets(hf, SM_TIME_DEFAULT, buf, sizeof(buf)) != NULL)
@


1.29
log
@Update to sendmail 8.14.5
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2010 Sendmail, Inc. and its suppliers.
d20 1
a20 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.1008 2011/01/12 23:52:59 ca Exp $")
d33 1
d1918 5
d1924 4
a1927 2
						  "STARTTLS=server, error: accept failed=%d, SSL_error=%d, errno=%d, retry=%d, relay=%.100s",
						  r, ssl_err, errno, i,
d1929 1
a1929 1
					if (LogLevel > 8)
d3492 1
a3492 1
	(void) sm_snprintf(buf, sizeof(buf), "%ld", e->e_msgsize);
d3570 1
a3570 1
	(void) sm_snprintf(buf, sizeof(buf), "%ld", e->e_msgsize);
@


1.28
log
@Update to sendmail-8.14.3
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2008 Sendmail, Inc. and its suppliers.
d20 1
a20 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.975 2008/03/31 16:32:13 ca Exp $")
d482 3
d492 1
a492 1
	dropenvelope(e, true, false);				\
d878 2
a879 4
		{
			ssp.max_ssf = MaxSLBits;
			ssp.maxbufsize = MAXOUTLEN;
		}
d911 1
d1277 2
a1278 1
					  "unauthorized PIPELINING, sleeping");
d1453 3
a1455 2
							  "AUTH encode64 error [%d for \"%s\"]",
							  result, out);
d1476 1
a1476 1
						  "AUTH failure (%s): %s (%d) %s",
d1482 1
a1482 1
						  sasl_errdetail(conn));
d1484 1
a1484 1
						  errstr == NULL ? "" : errstr);
d1486 1
d1708 3
a1710 2
							  "AUTH decode64 error [%d for \"%s\"]",
							  result, q);
d1743 1
a1743 1
						  "AUTH failure (%s): %s (%d) %s",
d1749 1
a1749 1
						  sasl_errdetail(conn));
d1751 1
a1751 1
						  errstr);
d1753 1
d1828 15
d1918 3
a1920 2
						  "STARTTLS=server, error: accept failed=%d, SSL_error=%d, errno=%d, retry=%d",
						  r, ssl_err, errno, i);
d2267 1
a2267 2
			if (tls_ok_srv &&
			    bitset(SRV_OFFER_TLS, features))
d2557 1
a2557 1
			**  n_badrcpts is increased is limit is reached.
d2601 1
a2601 1
				**  Some servers will open more connections
d2606 1
a2606 1
				(void) sleep(1);
d2628 1
a2628 1
			if (e->e_sendmode != SM_DELIVER
d3172 5
d3388 5
d3409 4
d3431 3
d3509 4
d3514 3
d3541 3
d3730 1
d3774 1
a3774 1
	/* issue success message */
d3776 3
a3778 3
	if (MessageAccept != NULL && *MessageAccept != '\0')
	{
		char msg[MAXLINE];
d3780 4
a3783 4
		expand(MessageAccept, msg, sizeof(msg), e);
		message("250 2.0.0 %s", msg);
	}
	else
d3785 1
a3785 1
	message("250 2.0.0 %s Message accepted for delivery", id);
d3835 3
d3851 1
a3851 1
		dropenvelope(e, true, false);
d3860 1
a3860 1
				dropenvelope(ee, true, false);
d3864 1
a3864 1
				dropenvelope(ee, true, false);
d3926 7
a3932 2
		logdelivery(NULL, NULL, a->q_status, msg, NULL,
			    (time_t) 0, e);
d4694 2
a4695 1
		  macid("{auth_authen}"), (char *) auth_identity);
d4754 3
a4756 2
	tls_ok_srv = inittls(&srv_ctx, TLS_Srv_Opts, true, SrvCertFile,
			     SrvKeyFile, CACertPath, CACertFile, DHParams);
@


1.27
log
@Update to sendmail-8.14.1
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2006 Sendmail, Inc. and its suppliers.
d20 1
a20 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.960 2007/02/07 20:18:47 ca Exp $")
d352 3
a354 3
	bool	sm_gotmail;	/* mail command received */
	unsigned int sm_nrcpts;	/* number of successful RCPT commands */
	bool	sm_discard;
d356 6
a361 2
	bool	sm_milterize;
	bool	sm_milterlist;	/* any filters in the list? */
d363 1
a363 1
	char	*sm_quarmsg;	/* carry quarantining across messages */
d640 3
d909 2
d919 1
a919 1
		smtp.sm_milterlist = milter_init(e, &state);
d950 1
d1063 1
a1063 1
			    (eoftest = sm_io_getc(InChannel, SM_TIME_DEFAULT)) 
d1066 1
a1066 1
				sm_io_ungetc(InChannel, SM_TIME_DEFAULT, 
d1298 1
a1298 1
				/* rfc 2254 4. */
d1317 1
a1317 1
				/* rfc 2254 4. */
d1671 15
a1685 1
			if (ismore)
d2530 1
d2532 30
d2616 5
a2620 4
			**  to recipient()).  If they are expanded, it
			**  is impossible for removefromlist() to figure
			**  out the expanded members of the original
			**  recipient and mark them as QS_DONTSEND.
d2623 5
a2627 1
			e->e_flags |= EF_VRFYONLY;
d2862 2
d3622 2
d3626 9
a3813 8
	sm_rpool_free(e->e_rpool);

	/*
	**  At this point, e == &MainEnvelope, but if we did splitting,
	**  then CurEnv may point to an envelope structure that was just
	**  freed with the rpool.  So reset CurEnv *before* calling
	**  newenvelope.
	*/
d3817 1
d4095 1
a4095 2
	e->e_flags &= EF_RET_PARAM;
	e->e_flags &= EF_NO_BODY_RETN;
@


1.26
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d20 1
a20 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.957 2006/12/19 01:15:07 ca Exp $")
d373 1
d434 1
d447 3
d629 1
d1148 3
d2505 1
d2560 1
a2560 2
			**  If the filter will be deleting recipients,
			**  don't expand them at RCPT time (in the call
d2567 1
a2567 2
			if (milter_can_delrcpts())
				e->e_flags |= EF_VRFYONLY;
d2622 17
d2661 4
d2795 7
@


1.25
log
@Update to sendmail-8.13.8
@
text
@d20 1
a20 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.924.2.5 2006/07/07 16:29:39 ca Exp $")
a38 3
#if _FFR_DM_ONE
static bool	NotFirstDelivery = false;
#endif /* _FFR_DM_ONE */
a39 1
extern void	tls_set_verify __P((SSL_CTX *, SSL *, bool));
d44 4
a72 1
static void	mail_esmtp_args __P((char *, char *, ENVELOPE *, unsigned int));
a73 2
static void	rcpt_esmtp_args __P((ADDRESS *, char *, char *, ENVELOPE *,
				unsigned int));
d115 1
a115 1
		(void) sm_snprintf(buf, sizeof buf, "%d",	\
d125 82
d484 1
d531 1
a556 1
	volatile int save_sevenbitinput;
a557 1
#if _FFR_BLOCK_PROXIES
a558 1
#endif /* _FFR_BLOCK_PROXIES */
a568 1
	int argno;
d570 4
a573 1
	char inp[MAXLINE];
d585 1
a585 1
	char *auth_id;
d604 1
d622 8
d631 1
a631 1
	save_sevenbitinput = SevenBitInput;
d636 1
d734 1
d798 1
a798 1
					       remoteip, sizeof remoteip))
d812 1
a812 1
						       sizeof localip))
d858 1
a858 1
		(void) memset(&ssp, '\0', sizeof ssp);
d946 3
a948 1
		SM_ASSERT(q != NULL);
d1003 1
a1003 1
	    *greetcode == '2')
a1024 1
#if _FFR_LOG_GREET_PAUSE
d1026 1
a1026 1
#endif /* _FFR_LOG_GREET_PAUSE */
a1042 1
#if _FFR_LOG_GREET_PAUSE
a1043 1
#endif /* _FFR_LOG_GREET_PAUSE */
d1046 3
a1048 1
			    FD_ISSET(fd, &readfds))
d1050 2
a1051 1
#if _FFR_LOG_GREET_PAUSE
a1053 1
#endif /* _FFR_LOG_GREET_PAUSE */
d1057 1
a1057 5
#if _FFR_LOG_GREET_PAUSE
					  "rejecting commands from %s [%s] after %d seconds due to pre-greeting traffic",
#else /* _FFR_LOG_GREET_PAUSE */
					  "rejecting commands from %s [%s] due to pre-greeting traffic",
#endif /* _FFR_LOG_GREET_PAUSE */
d1059 2
a1060 3
					  anynet_ntoa(&RealHostAddr)
#if _FFR_LOG_GREET_PAUSE
					  , (int) tp.tv_sec +
a1061 1
#endif /* _FFR_LOG_GREET_PAUSE */
d1081 2
a1082 2
		(void) sm_snprintf(inp, sizeof inp, "%s not accepting messages",
				   hostname);
d1084 1
a1084 1
		expand(SmtpGreeting, inp, sizeof inp, e);
d1093 1
a1093 1
		(void) sm_snprintf(cmdbuf, sizeof cmdbuf,
d1096 1
a1096 1
		(void) sm_snprintf(cmdbuf, sizeof cmdbuf,
d1106 1
a1106 1
		(void) sm_strlcpyn(cmdbuf, sizeof cmdbuf, 2, greetcode, "-%s");
d1113 1
a1113 1
		(void) sm_strlcpyn(cmdbuf, sizeof cmdbuf, 2, greetcode, " %s");
a1128 1
#if _FFR_BLOCK_PROXIES
a1129 1
#endif /* _FFR_BLOCK_PROXIES */
a1151 6
#if SASL
		/*
		**  XXX SMTP AUTH requires accepting any length,
		**	at least for challenge/response
		*/
#endif /* SASL */
d1155 1
a1155 1
		    (p = sfgets(inp, sizeof inp, InChannel,
d1188 22
a1209 1
#if _FFR_BLOCK_PROXIES
d1212 1
a1212 1
			size_t inplen, cmdlen;
a1217 1
			inplen = strlen(inp);
a1236 1
#endif /* _FFR_BLOCK_PROXIES */
d1370 1
a1370 1
					(void) sm_snprintf(pbuf, sizeof pbuf,
d1486 1
a1486 1
		       cmd < &cmdbuf[sizeof cmdbuf - 2])
d1901 1
a1901 1
				     5, NULL, NOQID) != EX_OK ||
a2091 9
				  case SMFIR_REPLYCODE:
					if (MilterLogLevel > 3)
						sm_syslog(LOG_INFO, e->e_id,
							  "Milter: helo=%s, reject=%s",
							  p, response);
					nullserver = newstr(response);
					smtp.sm_milterize = false;
					break;

d2110 14
d2125 2
a2126 1
					if (MilterLogLevel > 3)
d2132 5
a2136 2
					message("421 4.7.0 %s closing connection",
						MyHostName);
d2139 1
d2368 1
a2368 1
			SevenBitInput = save_sevenbitinput;
d2373 2
a2374 48
			argno = 0;
			args[argno++] = p;
			p = delimptr;
			while (p != NULL && *p != '\0')
			{
				char *kp;
				char *vp = NULL;
				char *equal = NULL;

				/* locate the beginning of the keyword */
				SKIP_SPACE(p);
				if (*p == '\0')
					break;
				kp = p;

				/* skip to the value portion */
				while ((isascii(*p) && isalnum(*p)) || *p == '-')
					p++;
				if (*p == '=')
				{
					equal = p;
					*p++ = '\0';
					vp = p;

					/* skip to the end of the value */
					while (*p != '\0' && *p != ' ' &&
					       !(isascii(*p) && iscntrl(*p)) &&
					       *p != '=')
						p++;
				}

				if (*p != '\0')
					*p++ = '\0';

				if (tTd(19, 1))
					sm_dprintf("MAIL: got arg %s=\"%s\"\n", kp,
						vp == NULL ? "<null>" : vp);

				mail_esmtp_args(kp, vp, e, features);
				if (equal != NULL)
					*equal = '=';
				args[argno++] = kp;
				if (argno >= MAXSMTPARGS - 1)
					usrerr("501 5.5.4 Too many parameters");
				if (Errors > 0)
					sm_exc_raisenew_x(&EtypeQuickAbort, 1);
			}
			args[argno] = NULL;
d2408 1
a2408 1
				    NULL, e->e_id) != EX_OK ||
d2487 10
d2560 2
d2609 2
a2610 48
			argno = 0;
			args[argno++] = p;
			p = delimptr;
			while (p != NULL && *p != '\0')
			{
				char *kp;
				char *vp = NULL;
				char *equal = NULL;

				/* locate the beginning of the keyword */
				SKIP_SPACE(p);
				if (*p == '\0')
					break;
				kp = p;

				/* skip to the value portion */
				while ((isascii(*p) && isalnum(*p)) || *p == '-')
					p++;
				if (*p == '=')
				{
					equal = p;
					*p++ = '\0';
					vp = p;

					/* skip to the end of the value */
					while (*p != '\0' && *p != ' ' &&
					       !(isascii(*p) && iscntrl(*p)) &&
					       *p != '=')
						p++;
				}

				if (*p != '\0')
					*p++ = '\0';

				if (tTd(19, 1))
					sm_dprintf("RCPT: got arg %s=\"%s\"\n", kp,
						vp == NULL ? "<null>" : vp);

				rcpt_esmtp_args(a, kp, vp, e, features);
				if (equal != NULL)
					*equal = '=';
				args[argno++] = kp;
				if (argno >= MAXSMTPARGS - 1)
					usrerr("501 5.5.4 Too many parameters");
				if (Errors > 0)
					break;
			}
			args[argno] = NULL;
d2619 1
a2619 1
				    NULL, e->e_id) != EX_OK ||
d2628 13
d2643 1
d2650 35
a2684 1
				response = milter_envrcpt(args, e, &state);
a2688 16
			macdefine(&e->e_macro, A_PERM,
				macid("{rcpt_mailer}"), NULL);
			macdefine(&e->e_macro, A_PERM,
				macid("{rcpt_host}"), NULL);
			macdefine(&e->e_macro, A_PERM,
				macid("{rcpt_addr}"), NULL);
			macdefine(&e->e_macro, A_PERM,
				macid("{dsn_notify}"), NULL);
			if (Errors > 0)
				goto rcpt_done;

			/* save in recipient list after ESMTP mods */
			a = recipient(a, &e->e_sendqueue, 0, e);
			if (Errors > 0)
				goto rcpt_done;

d2691 1
a2691 1
			if (!QS_IS_BADADDR(a->q_state))
d2700 14
a2713 6
			else
			{
				/* punt -- should keep message in ADDRESS.... */
				usrerr("550 5.1.1 Addressee unknown");
			}
		    rcpt_done:
d2726 42
d2850 1
a2850 1
					    3, NULL, NOQID) != EX_OK ||
d2946 2
a2947 1
				    RSF_RMCOMM, 3, NULL, NOQID) != EX_OK ||
d3110 1
a3110 1
			tTsetup(tTdvect, sizeof tTdvect, "0-99.1");
d3219 1
d3224 1
a3225 1
	bool rv = true;
d3238 1
a3238 1
	(void) sm_snprintf(buf, sizeof buf, "%u", smtp->sm_nrcpts);
d3241 1
a3241 1
		    e->e_id) != EX_OK)
d3347 1
a3347 1
	(void) sm_snprintf(buf, sizeof buf, "%ld", e->e_msgsize);
a3349 1
#if _FFR_CHECK_EOM
d3352 1
a3352 2
		       3, NULL, e->e_id);
#endif /* _FFR_CHECK_EOM */
d3415 1
a3415 1
	(void) sm_snprintf(buf, sizeof buf, "%ld", e->e_msgsize);
d3621 1
a3621 1
		expand(MessageAccept, msg, sizeof msg, e);
d3715 1
d3718 1
d3969 44
d4016 1
a4019 1
**		features -- current server features
d4025 3
a4027 2
static void
mail_esmtp_args(kp, vp, e, features)
a4030 1
	unsigned int features;
d4077 1
a4077 1
		if (!bitset(SRV_OFFER_DSN, features))
d4103 1
a4103 1
		if (!bitset(SRV_OFFER_DSN, features))
d4176 1
a4176 1
			      9, NULL, NOQID) != EX_OK || Errors > 0))
d4288 1
a4296 1
**		features -- current server features
d4302 2
a4303 2
static void
rcpt_esmtp_args(a, kp, vp, e, features)
a4307 1
	unsigned int features;
d4313 1
a4313 1
		if (!bitset(SRV_OFFER_DSN, features))
d4354 1
a4354 1
		if (!bitset(SRV_OFFER_DSN, features))
d4408 1
a4408 1
		(void) sm_strlcpy(fmtbuf, "252", sizeof fmtbuf);
d4410 1
a4410 1
		(void) sm_strlcpy(fmtbuf, "250", sizeof fmtbuf);
d4412 1
a4412 1
	(void) sm_strlcpy(&fmtbuf[4], "2.1.5 ", sizeof fmtbuf - 4);
d4420 1
a4420 1
				       sizeof fmtbuf - OFFF);
d4423 1
a4423 1
				       sizeof fmtbuf - OFFF);
d4433 1
a4433 1
				       sizeof fmtbuf - OFFF);
d4436 1
a4436 1
				       sizeof fmtbuf - OFFF);
d4756 1
a4756 1
	while (sm_io_fgets(hf, SM_TIME_DEFAULT, buf, sizeof buf) != NULL)
d4789 7
a4795 2
				translate_dollars(p);
				expand(p, inp, sizeof inp, e);
@


1.24
log
@Update to sendmail 8.13.6
@
text
@d20 1
a20 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.922 2006/02/28 00:42:13 ca Exp $")
d73 1
a73 1
static void	mail_esmtp_args __P((char *, char *, ENVELOPE *));
d75 2
a76 1
static void	rcpt_esmtp_args __P((ADDRESS *, char *, char *, ENVELOPE *));
d592 2
a593 2
		| (bitset(PRIV_NORECEIPTS, PrivacyFlags) ? SRV_NONE
							 : SRV_OFFER_DSN)
d854 3
a856 2
		response = milter_connect(peerhostname, RealHostAddr,
					  e, &state);
d1290 2
d1298 1
d1300 1
a1300 1
						     conn) == 0)
d2025 1
a2025 1
							  "Milter: Milter: helo=%s, reject=421 4.7.0 %s closing connection",
d2304 1
a2304 1
				mail_esmtp_args(kp, vp, e);
d2574 1
a2574 1
				rcpt_esmtp_args(a, kp, vp, e);
d3856 1
d3864 1
d3871 1
a3871 1
mail_esmtp_args(kp, vp, e)
d3875 1
d3922 1
a3922 1
		if (bitset(PRIV_NORECEIPTS, PrivacyFlags))
d3948 1
a3948 1
		if (bitset(PRIV_NORECEIPTS, PrivacyFlags))
d4141 1
d4148 1
a4148 1
rcpt_esmtp_args(a, kp, vp, e)
d4153 1
d4159 1
a4159 1
		if (bitset(PRIV_NORECEIPTS, PrivacyFlags))
d4200 1
a4200 1
		if (bitset(PRIV_NORECEIPTS, PrivacyFlags))
@


1.23
log
@update to sendmail 8.13.4
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2005 Sendmail, Inc. and its suppliers.
d20 1
a20 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.906 2005/03/16 00:36:09 ca Exp $")
d22 1
a22 1
#include <sys/time.h>
d39 3
a226 3
#ifndef MAXNOOPCOMMANDS
# define MAXNOOPCOMMANDS 20	/* max "noise" commands before slowdown */
#endif /* ! MAXNOOPCOMMANDS */
d295 18
d321 2
a322 1
			if (strncmp(response, "421 ", 4) == 0)		\
a525 1
	int fdfl;
d831 13
d930 3
d949 3
d956 4
d963 3
d967 1
d969 6
a974 1
					  anynet_ntoa(&RealHostAddr));
a1745 3
			fdfl = fcntl(rfd, F_GETFL);
			if (fdfl != -1)
				fcntl(rfd, F_SETFL, fdfl|O_NONBLOCK);
d1749 1
a1749 5
				int i;
				bool timedout;
				time_t left;
				time_t now = curtime();
				struct timeval tv;
d1751 6
a1756 61
				/* what to do in this case? */
				i = SSL_get_error(srv_ssl, r);

				/*
				**  For SSL_ERROR_WANT_{READ,WRITE}:
				**  There is no SSL record available yet
				**  or there is only a partial SSL record
				**  removed from the network (socket) buffer
				**  into the SSL buffer. The SSL_accept will
				**  only succeed when a full SSL record is
				**  available (assuming a "real" error
				**  doesn't happen). To handle when a "real"
				**  error does happen the select is set for
				**  exceptions too.
				**  The connection may be re-negotiated
				**  during this time so both read and write
				**  "want errors" need to be handled.
				**  A select() exception loops back so that
				**  a proper SSL error message can be gotten.
				*/

				left = TimeOuts.to_starttls - (now - tlsstart);
				timedout = left <= 0;
				if (!timedout)
				{
					tv.tv_sec = left;
					tv.tv_usec = 0;
				}

				if (!timedout && FD_SETSIZE > 0 &&
				    (rfd >= FD_SETSIZE ||
				     (i == SSL_ERROR_WANT_WRITE &&
				      wfd >= FD_SETSIZE)))
				{
					if (LogLevel > 5)
					{
						sm_syslog(LOG_ERR, NOQID,
							  "STARTTLS=server, error: fd %d/%d too large",
							  rfd, wfd);
						if (LogLevel > 8)
							tlslogerr("server");
					}
					goto tlsfail;
				}

				/* XXX what about SSL_pending() ? */
				if (!timedout && i == SSL_ERROR_WANT_READ)
				{
					fd_set ssl_maskr, ssl_maskx;

					FD_ZERO(&ssl_maskr);
					FD_SET(rfd, &ssl_maskr);
					FD_ZERO(&ssl_maskx);
					FD_SET(rfd, &ssl_maskx);
					if (select(rfd + 1, &ssl_maskr, NULL,
						   &ssl_maskx, &tv) > 0)
						goto ssl_retry;
				}
				if (!timedout && i == SSL_ERROR_WANT_WRITE)
				{
					fd_set ssl_maskw, ssl_maskx;
a1757 8
					FD_ZERO(&ssl_maskw);
					FD_SET(wfd, &ssl_maskw);
					FD_ZERO(&ssl_maskx);
					FD_SET(rfd, &ssl_maskx);
					if (select(wfd + 1, NULL, &ssl_maskw,
						   &ssl_maskx, &tv) > 0)
						goto ssl_retry;
				}
d1761 2
a1762 2
						  "STARTTLS=server, error: accept failed=%d, SSL_error=%d, timedout=%d, errno=%d",
						  r, i, (int) timedout, errno);
a1765 1
tlsfail:
a1779 3
			if (fdfl != -1)
				fcntl(rfd, F_SETFL, fdfl);

d1977 1
a1977 2
			if (gothello)
			{
a1978 1
			}
d2016 13
d2465 5
a2469 1
			if (e->e_sendmode != SM_DELIVER)
d2894 1
a2894 1
			STOP_IF_ATTACK(checksmtpattack(&n_noop, MAXNOOPCOMMANDS,
d2968 3
d2980 1
a2980 1
			STOP_IF_ATTACK(checksmtpattack(&n_noop, MAXNOOPCOMMANDS,
d3041 2
a3042 1
				    state == SMFIR_TEMPFAIL)
d3109 1
d3148 2
a3149 1
			if (strncmp(response, "421 ", 4) == 0)
d3183 12
d3285 10
d3473 2
d3476 17
a3492 1
			sendall(ee, SM_DEFAULT);
d3502 10
d3616 1
a3616 1
	return true;
@


1.23.4.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@d507 1
d1696 3
d1702 5
a1706 1
				int i, ssl_err;
d1708 2
a1709 6
				ssl_err = SSL_get_error(srv_ssl, r);
				i = tls_retry(srv_ssl, rfd, wfd, tlsstart,
						TimeOuts.to_starttls, ssl_err,
						"server");
				if (i > 0)
					goto ssl_retry;
d1711 67
d1781 2
a1782 2
						  "STARTTLS=server, error: accept failed=%d, SSL_error=%d, errno=%d, retry=%d",
						  r, ssl_err, errno, i);
d1786 1
d1800 3
@


1.23.2.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@d507 1
d1696 3
d1702 5
a1706 1
				int i, ssl_err;
d1708 2
a1709 6
				ssl_err = SSL_get_error(srv_ssl, r);
				i = tls_retry(srv_ssl, rfd, wfd, tlsstart,
						TimeOuts.to_starttls, ssl_err,
						"server");
				if (i > 0)
					goto ssl_retry;
d1711 67
d1781 2
a1782 2
						  "STARTTLS=server, error: accept failed=%d, SSL_error=%d, errno=%d, retry=%d",
						  r, ssl_err, errno, i);
d1786 1
d1800 3
@


1.22
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004 Sendmail, Inc. and its suppliers.
d20 1
a20 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.902 2004/11/18 21:46:01 ca Exp $")
d83 7
a89 7
	result = reset_saslconn(&conn, AuthRealm, remoteip, localip, auth_id, \
				&ext_ssf);	\
	if (result != SASL_OK)			\
	{					\
		/* This is pretty fatal */	\
		goto doquit;			\
	}
d97 7
a103 6
	result = reset_saslconn(&conn, AuthRealm, &saddr_r, &saddr_l, &ext_ssf); \
	if (result != SASL_OK)			\
	{					\
		/* This is pretty fatal */	\
		goto doquit;			\
	}
d668 1
a751 2
# if STARTTLS
# endif /* STARTTLS */
d4620 1
a4620 1
reset_saslconn(sasl_conn_t ** conn, char *hostname,
d4625 1
a4625 1
	       struct sockaddr_in * saddr_r, struct sockaddr_in * saddr_l,
d4648 1
a4648 1
	if (remoteip != NULL)
d4653 1
a4653 1
	if (localip != NULL)
@


1.22.2.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@d506 1
d1696 3
d1702 5
a1706 1
				int i, ssl_err;
d1708 2
a1709 6
				ssl_err = SSL_get_error(srv_ssl, r);
				i = tls_retry(srv_ssl, rfd, wfd, tlsstart,
						TimeOuts.to_starttls, ssl_err,
						"server");
				if (i > 0)
					goto ssl_retry;
d1711 67
d1781 2
a1782 2
						  "STARTTLS=server, error: accept failed=%d, SSL_error=%d, errno=%d, retry=%d",
						  r, ssl_err, errno, i);
d1786 1
d1800 3
@


1.21
log
@Update to sendmail-8.13.1
@
text
@d20 1
a20 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.900 2004/07/08 23:29:33 ca Exp $")
d1969 7
d4120 3
a4122 1
			p = strchr(p, ',');
d4137 2
@


1.20
log
@Update to sendmail.8.13.0
@
text
@d20 1
a20 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.898 2004/06/17 17:30:09 ca Exp $")
d114 1
a114 1
			n_badrcpts > BadRcptThrottle		\
d357 1
d388 16
a403 1
}
a1996 16

				/* restore connection quarantining */
				if (smtp.sm_quarmsg == NULL)
				{
					e->e_quarmsg = NULL;
					macdefine(&e->e_macro, A_PERM,
						  macid("{quarantine}"), "");
				}
				else
				{
					e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool,
									 smtp.sm_quarmsg);
					macdefine(&e->e_macro, A_PERM,
						  macid("{quarantine}"),
						  e->e_quarmsg);
				}
a2671 15

			/* restore connection quarantining */
			if (smtp.sm_quarmsg == NULL)
			{
				e->e_quarmsg = NULL;
				macdefine(&e->e_macro, A_PERM,
					  macid("{quarantine}"), "");
			}
			else
			{
				e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool,
								 smtp.sm_quarmsg);
				macdefine(&e->e_macro, A_PERM,
					  macid("{quarantine}"), e->e_quarmsg);
			}
@


1.19
log
@If no help file is present don't print the sendmail version--we
may be trying to keep the version hidden.  From Alexey E. Suslikov.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d16 1
d20 4
a23 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.829.2.34 2004/01/14 19:13:46 ca Exp $")
a25 1
# include <sys/time.h>
d62 1
d67 3
a69 2
static time_t	checksmtpattack __P((volatile unsigned int *, int, bool,
				     char *, ENVELOPE *));
d83 1
a83 1
	result = reset_saslconn(&conn, hostname, remoteip, localip, auth_id, \
d97 1
a97 1
	result = reset_saslconn(&conn, hostname, &saddr_r, &saddr_l, &ext_ssf); \
d109 10
d239 25
a272 4
#if _FFR_ADAPTIVE_EOL
WARNING: do NOT use this FFR, it is most likely broken
	bool	sm_crlf;	/* input in CRLF form? */
#endif /* _FFR_ADAPTIVE_EOL */
a277 1
#if _FFR_QUARANTINE
a278 1
#endif /* _FFR_QUARANTINE */
d281 1
a281 1
static void	smtp_data __P((SMTP_T *, ENVELOPE *));
d283 1
a283 1
#define MSG_TEMPFAIL "451 4.7.1 Please try again later"
a287 11
#if _FFR_MILTER_421
# define MILTER_SHUTDOWN						\
			if (strncmp(response, "421 ", 4) == 0)		\
			{						\
				e->e_sendqueue = NULL;			\
				goto doquit;				\
			}
#else /* _FFR_MILTER_421 */
# define MILTER_SHUTDOWN
#endif /* _FFR_MILTER_421 */

d302 12
a313 2
			usrerr(response);				\
			MILTER_SHUTDOWN					\
d383 4
d441 1
a441 1
#if _FFR_BLOCK_PROXIES || _FFR_ADAPTIVE_EOL
d443 1
a443 1
#endif /* _FFR_BLOCK_PROXIES || _FFR_ADAPTIVE_EOL */
d488 1
d490 1
a490 1
	int r;
d493 1
a493 3
# if _FFR_SMTP_SSL
	volatile bool smtps = false;
# endif /* _FFR_SMTP_SSL */
d560 2
d583 2
d587 5
a591 5
		else if (bitset(SRV_NO_PIPE, features))
		{
			/* for consistency */
			features &= ~SRV_OFFER_PIPE;
		}
d594 12
d610 2
d620 1
a620 1
		result = sasl_server_new("smtp", hostname, NULL, NULL, NULL,
d624 1
a624 1
		result = sasl_server_new("smtp", hostname, "", NULL, 0, &conn);
d627 1
a627 1
		result = sasl_server_new("smtp", hostname, NULL, NULL, 0,
a831 1
#if _FFR_MILTER_421
a845 1
#endif /* _FFR_MILTER_421 */
a847 1

d852 61
a913 1
# if _FFR_SMTP_SSL
a914 1
	smtps = bitnset(D_SMTPS, d_flags);
a922 1
# endif /* _FFR_SMTP_SSL */
a965 1
#if _FFR_QUARANTINE
a970 1
#endif /* _FFR_QUARANTINE */
d975 1
a975 1
#if _FFR_BLOCK_PROXIES || _FFR_ADAPTIVE_EOL
d977 1
a977 1
#endif /* _FFR_BLOCK_PROXIES || _FFR_ADAPTIVE_EOL */
d1042 1
a1042 1
#if _FFR_BLOCK_PROXIES || _FFR_ADAPTIVE_EOL
a1044 1
#if _FFR_BLOCK_PROXIES
a1068 18
#endif /* _FFR_BLOCK_PROXIES */
#if _FFR_ADAPTIVE_EOL
			char *p;

			smtp.sm_crlf = true;
			p = strchr(inp, '\n');
			if (p == NULL || p <= inp || p[-1] != '\r')
			{
				smtp.sm_crlf = false;
				if (tTd(66, 1) && LogLevel > 8)
				{
					/* how many bad guys are there? */
					sm_syslog(LOG_INFO, NOQID,
						  "%s did not use CRLF",
						  CurSmtpClient);
				}
			}
#endif /* _FFR_ADAPTIVE_EOL */
d1071 1
a1071 1
#endif /* _FFR_BLOCK_PROXIES || _FFR_ADAPTIVE_EOL */
d1181 2
a1182 1
						  macid("{auth_authen}"), user);
d1445 1
a1445 1
				usrerr("454 4.7.1 Please try again later");
d1452 2
a1453 2
			(void) checksmtpattack(&n_auth, n_mechs + 1, true,
					       "AUTH", e);
d1616 1
a1616 1
				usrerr("454 4.7.1 Please try again later");
a1618 1
# if _FFR_SMTP_SSL
a1619 1
# endif /* _FFR_SMTP_SSL */
a1643 1
# if _FFR_SMTP_SSL
a1644 3
# else /* _FFR_SMTP_SSL */
				break;
# endif /* _FFR_SMTP_SSL */
a1666 1
# if _FFR_SMTP_SSL
a1667 3
# else /* _FFR_SMTP_SSL */
				break;
# endif /* _FFR_SMTP_SSL */
a1668 1
# if _FFR_SMTP_SSL
a1669 1
# endif /* _FFR_SMTP_SSL */
d1680 3
d1785 3
d1825 3
a1827 1
				char *s;
d1830 5
d1836 8
a1843 8
				if (s != NULL && (ext_ssf = atoi(s)) > 0)
				{
					auth_id = macvalue(macid("{cert_subject}"),
								   e);
					sasl_ok = ((sasl_setprop(conn, SASL_SSF_EXTERNAL,
								 &ext_ssf) == SASL_OK) &&
						   (sasl_setprop(conn, SASL_AUTH_EXTERNAL,
								 auth_id) == SASL_OK));
d1845 5
a1849 6
				if (s != NULL && (ext_ssf.ssf = atoi(s)) > 0)
				{
					ext_ssf.auth_id = macvalue(macid("{cert_subject}"),
								   e);
					sasl_ok = sasl_setprop(conn, SASL_SSF_EXTERNAL,
							       &ext_ssf) == SASL_OK;
a1880 1
# if _FFR_SMTP_SSL
a1888 1
# endif /* _FFR_SMTP_SSL */
d1907 2
a1908 2
			(void) checksmtpattack(&n_helo, MAXHELOCOMMANDS, true,
					       "HELO/EHLO", e);
a1981 1
#if _FFR_QUARANTINE
a1996 1
#endif /* _FFR_QUARANTINE */
a2038 1
# if _FFR_QUARANTINE
a2046 1
# endif /* _FFR_QUARANTINE */
d2199 2
d2440 1
d2645 1
d2647 2
d2655 1
d2662 2
a2663 1
			smtp_data(&smtp, e);
d2672 1
a2672 1
#if _FFR_QUARANTINE
a2686 1
#endif /* _FFR_QUARANTINE */
d2707 1
d2835 2
a2836 2
			(void) checksmtpattack(&n_etrn, MAXETRNCOMMANDS, true,
					     "ETRN", e);
d2911 2
a2912 2
			(void) checksmtpattack(&n_noop, MAXNOOPCOMMANDS, true,
					       "NOOP", e);
d2994 2
a2995 2
			(void) checksmtpattack(&n_noop, MAXNOOPCOMMANDS, true,
					       "VERB", e);
d3005 1
a3005 1
			printaddr(e->e_sendqueue, true);
d3031 1
d3041 22
d3101 1
a3101 1
**		none.
d3107 1
a3107 1
static void
d3127 1
a3127 1
		return;
d3132 1
a3132 1
		return;
d3138 62
a3199 1
		return;
a3226 6
#if _FFR_ADAPTIVE_EOL
	/* triggers error in collect, disabled for now */
	if (smtp->sm_crlf)
		e->e_flags |= EF_NL_NOT_EOL;
#endif /* _FFR_ADAPTIVE_EOL */

d3300 75
a3376 1
#if _FFR_QUARANTINE
a3379 1
#endif /* _FFR_QUARANTINE */
a3392 1
#if _FFR_QUARANTINE
a3393 1
#endif /* _FFR_QUARANTINE */
a3490 1
#if _FFR_QUARANTINE
a3496 1
#endif /* _FFR_QUARANTINE */
a3540 1
#if _FFR_QUARANTINE
a3547 1
#endif /* _FFR_QUARANTINE */
a3564 1
#if _FFR_QUARANTINE
d3577 1
a3577 1
#endif /* _FFR_QUARANTINE */
d3633 3
a3635 1
**		time to wait.
d3644 1
a3644 1
	int maxcount;
d3654 1
d3663 3
a3665 2
		s = 1 << (*pcounter - maxcount);
		if (s >= MAXTIMEOUT || s <= 0)
d3668 3
d3674 3
a3676 1
		if (waitnow)
d3679 1
a3679 1
			return 0;
d3681 1
a3681 1
		return s;
a3934 1
		char pbuf[256];
a3958 4
		/* XXX this might be cut off */
		(void) sm_strlcpy(pbuf, xuntextify(auth_param), sizeof pbuf);
		/* xalloc() the buffer instead? */

d3960 2
a3961 1
		macdefine(&e->e_macro, A_TEMP, macid("{auth_author}"), pbuf);
d3973 1
a3973 1
		     (rscheck("trust_auth", pbuf, NULL, e, RSF_RMCOMM,
d3980 1
a3980 1
					pbuf, (q == NULL) ? "" : q);
d3993 1
a3993 1
				sm_dprintf("auth=\"%.100s\" trusted\n", pbuf);
d4412 5
a4416 4
	{ 'B',	SRV_OFFER_VERB	},	/* FFR; not documented in 8.12 */
	{ 'D',	SRV_OFFER_DSN	},	/* FFR; not documented in 8.12 */
	{ 'E',	SRV_OFFER_ETRN	},	/* FFR; not documented in 8.12 */
	{ 'L',	SRV_REQ_AUTH	},	/* FFR; not documented in 8.12 */
d4423 1
a4423 1
	{ 'R',	SRV_VRFY_CLT	},	/* FFR; not documented in 8.12 */
d4427 1
a4427 1
	{ 'X',	SRV_OFFER_EXPN	},	/* FFR; not documented in 8.12 */
@


1.18
log
@Update to sendmail 8.12.11.  I've been runninga beta version of this for
some time without problems.  See the RELEASE_NOTES for the change log.
@
text
@d4291 1
a4291 2
		message("502 5.3.0 Sendmail %s -- HELP not implemented",
			Version);
@


1.17
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.829.2.31 2003/07/01 17:30:01 ca Exp $")
d1291 1
d2342 23
a2410 23
			if (BadRcptThrottle > 0 &&
			    n_badrcpts >= BadRcptThrottle)
			{
				if (LogLevel > 5 &&
				    n_badrcpts == BadRcptThrottle)
				{
					sm_syslog(LOG_INFO, e->e_id,
						  "%s: Possible SMTP RCPT flood, throttling.",
						  CurSmtpClient);

					/* To avoid duplicated message */
					n_badrcpts++;
				}

				/*
				**  Don't use exponential backoff for now.
				**  Some servers will open more connections
				**  and actually overload the receiver even
				**  more.
				*/

				(void) sleep(1);
			}
d3150 1
a3150 1
	if (!aborting &&
@


1.16
log
@Update to sendmail 8.12.9; fixes a buffer overflow in address parsing
due to a char to int conversion problem which is potentially remotely
exploitable.
@
text
@d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.829.2.22 2003/02/19 02:45:40 ca Exp $")
d70 32
d402 1
d434 1
d439 2
d470 1
a607 1
			char localip[60], remoteip[60];
a645 2
			struct sockaddr_in saddr_l;
			struct sockaddr_in saddr_r;
d715 3
d806 2
d809 1
d1018 1
d1028 1
d1051 1
d1206 1
d1456 1
d1484 1
d1554 2
d1867 1
a1867 1
				if (strchr("[].-_#", *q) == NULL)
d2175 3
d3057 1
a3057 1
	collect(InChannel, true, NULL, e);
d4016 1
a4016 1
			       (unsigned int *)&len, (unsigned int *)&num);
d4368 81
@


1.15
log
@Update to Sendmail 8.12.8; fixes a buffer overflow in the envelope
comments processing which may allow an attacker to gain root privileges.
@
text
@d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.829.2.21 2003/01/15 19:17:14 ca Exp $")
a519 2


@


1.14
log
@update to sendmail 8.12.7
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.829.2.17 2002/12/09 16:46:18 ca Exp $")
d1638 2
a1639 2
						  "STARTTLS=server, error: accept failed=%d, SSL_error=%d, timedout=%d",
						  r, i, (int) timedout);
d2720 1
a2720 1
				int wgrp;
d2723 2
a2724 2
				wgrp = name2qid(id);
				if (!ISVALIDQGRP(wgrp))
d2730 6
a2735 1
				ok = run_work_group(wgrp, RWG_FORK|RWG_RUNALL);
@


1.13
log
@update to sendmail-8.12.6
@
text
@d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.829.2.4 2002/08/16 14:56:01 ca Exp $")
d221 12
d248 1
d371 1
a371 1
#if _FFR_ADAPTIVE_EOL
d373 1
a373 1
#endif /* _FFR_ADAPTIVE_EOL */
d742 17
d830 1
a830 1
#if _FFR_ADAPTIVE_EOL
d832 1
a832 1
#endif /* _FFR_ADAPTIVE_EOL */
d884 1
a884 1
					  "lost input channel from %.100s to %s after %s",
d897 1
a897 1
#if _FFR_ADAPTIVE_EOL
d900 27
d938 1
a938 1
						  "%.100s did not use CRLF",
d942 1
d945 1
a945 1
#endif /* _FFR_ADAPTIVE_EOL */
d961 1
a961 1
		    sm_io_getinfo(InChannel, SM_IO_IS_READABLE, NULL))
d1115 1
a1115 1
						  "AUTH=server, relay=%.100s, authid=%.128s, mech=%.16s, bits=%d",
d1311 1
a1311 1
						  "SMTP AUTH command (%.100s) from %.100s tempfailed (due to previous checks)",
d1480 1
a1480 1
						  "SMTP STARTTLS command (%.100s) from %.100s tempfailed (due to previous checks)",
d1594 16
d1643 1
d1801 1
a1801 1
						  "invalid domain name (too long) from %.100s",
d1835 1
a1835 1
						  "invalid domain name (%.100s) from %.100s",
d2021 1
a2021 1
						  "SMTP MAIL command (%.100s) from %.100s tempfailed (due to previous checks)",
d2345 1
a2345 1
						  "%.100s: Possible SMTP RCPT flood, throttling.",
d2557 1
a2557 1
						  "SMTP %s command (%.100s) from %.100s tempfailed (due to previous checks)",
d2568 2
a2569 2
			if (bitset(vrfy ? PRIV_NOVRFY : PRIV_NOEXPN,
				   PrivacyFlags))
d2577 1
a2577 1
						  "%.100s: %s [rejected]",
d2592 1
a2592 1
				sm_syslog(LOG_INFO, e->e_id, "%.100s: %s",
d2672 1
a2672 1
						  "%.100s: %s [rejected]",
d2681 1
a2681 1
						  "SMTP ETRN command (%.100s) from %.100s tempfailed (due to previous checks)",
d2714 1
a2714 1
					  "%.100s: ETRN %s", CurSmtpClient,
d2730 1
a2730 2
				ok = run_work_group(wgrp, true, false,
						    false, true);
d2828 1
a2828 1
					  "%.100s did not issue MAIL/EXPN/VRFY/ETRN during connection to %s",
d2831 5
a2835 3
#if PROFILING
			return;
#endif /* PROFILING */
d2841 2
a2842 3
			if (bitset(PRIV_NOEXPN, PrivacyFlags) ||
			    !bitset(SRV_OFFER_VERB, features) ||
			    bitset(PRIV_NOVERB, PrivacyFlags))
d2876 1
a2876 1
					  "\"%s\" command from %.100s (%.100s)",
d3367 1
a3367 1
				  "%.100s: possible SMTP attack: command=%.40s, count=%u",
d4092 2
a4093 2
	tls_ok_srv = inittls(&srv_ctx, TLS_Srv_Opts, true, SrvCERTfile,
			     Srvkeyfile, CACERTpath, CACERTfile, DHParams);
d4117 4
a4120 4
	{ 'B',	SRV_OFFER_VERB	},
	{ 'D',	SRV_OFFER_DSN	},
	{ 'E',	SRV_OFFER_ETRN	},
	{ 'L',	SRV_REQ_AUTH	},	/* not documented in 8.12 */
d4127 1
a4127 1
	{ 'R',	SRV_VRFY_CLT	},
d4131 1
a4131 1
	{ 'X',	SRV_OFFER_EXPN	},
@


1.12
log
@sendmail 8.12.5
@
text
@d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.829 2002/06/17 21:54:57 gshapiro Exp $")
d385 1
a385 1
 	char *auth_id;
d387 1
a387 1
 	sasl_ssf_t ext_ssf;
d657 1
a657 1
 						 auth_id) == SASL_OK));
d1299 1
a1299 1
  				result = sasl_decode64(q, strlen(q), in,
d1332 1
a1332 1
  			result = sasl_server_start(conn, p, in, inlen,
d1600 3
a1602 2
				     "STARTTLS", e, true, true, 5,
				     NULL, NOQID) != EX_OK ||
d1625 1
a1625 1
  				{
d1627 1
a1627 1
  								   e);
d2137 2
a2138 2
				    NULL, e, true, true, 3, NULL,
				    e->e_id) != EX_OK ||
d2377 2
a2378 2
				    NULL, e, true, true, 3, NULL,
				    e->e_id) != EX_OK ||
d2384 4
d2536 2
a2537 2
					    p, NULL, e, true, false, 3, NULL,
					    NOQID) != EX_OK ||
d2632 3
a2634 2
			if (rscheck("check_etrn", p, NULL, e, true, false, 3,
				    NULL, NOQID) != EX_OK || Errors > 0)
d2892 2
a2893 1
		    true, false, 3, NULL, e->e_id) != EX_OK)
d2936 2
a2937 2
	(void) rscheck("check_eom", buf, NULL, e, false,
		       true, 3, NULL, e->e_id);
d3603 2
a3604 2
		     (rscheck("trust_auth", pbuf, NULL, e, true, false, 9,
			      NULL, NOQID) != EX_OK || Errors > 0))
@


1.11
log
@Update to sendmail-8.12.4
@
text
@d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.827 2002/05/28 14:29:57 ca Exp $")
d1899 2
a1900 1
			if (tls_ok_srv && bitset(SRV_OFFER_TLS, features))
@


1.10
log
@update to sendmail 8.12.3
@
text
@d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.819 2002/04/02 03:51:02 ca Exp $")
d383 7
a389 1
	char *in, *out, *out2;
d391 4
a400 3
	sasl_security_properties_t ssp;
	sasl_external_properties_t ext_ssf;
	sasl_ssf_t *ssf;
d517 4
a520 1
# if SASL > 10505
d523 1
a523 1
# else /* SASL > 10505 */
d527 1
a527 1
# endif /* SASL > 10505 */
d542 1
a542 1
		**  XXX only IPv4: Cyrus SASL doesn't support anything else
d548 47
a594 1
# if NETINET
d619 2
a620 1
# endif /* NETINET */
d651 8
d663 1
d935 5
d942 1
d950 3
d956 5
d963 1
d974 7
d1005 1
d1087 3
d1094 1
a1094 1
				message("500 5.7.0 authentication failed");
d1102 3
d1106 1
d1280 6
d1289 1
a1289 1
				message("503 5.3.3 AUTH mechanism %.32s not available",
d1297 5
d1305 1
d1316 3
d1331 6
d1339 1
d1343 1
a1343 1
				message("500 5.7.0 authentication failed");
d1351 3
d1355 1
d1389 3
d1622 10
d1638 1
d1730 1
d1740 3
d1749 1
a1749 1
			if (*q == '\0')
d2397 1
a2397 1
				macid("{rcpt_relay}"), NULL);
d2731 2
a2732 1
			if (lognullconnection && LogLevel > 5)
d2869 1
d3090 4
d3096 1
d3876 5
d3884 1
d3910 46
d3983 1
@


1.9
log
@update to sendmail-8.12.2
@
text
@d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.814 2002/01/08 00:56:22 ca Exp $")
d175 1
a175 1
#endif
d178 1
a178 1
#endif
d181 1
a181 1
#endif
d184 1
a184 1
#endif
d187 1
a187 1
#endif
d190 1
a190 1
#endif
d538 1
a538 1
#if NETINET
d563 1
a563 1
#endif /* NETINET */
d578 2
a579 2
#  if STARTTLS
#  endif /* STARTTLS */
d616 1
a616 1
					  "Milter: inititalization failed, rejecting commands");
d625 1
a625 1
					  "Milter: inititalization failed, temp failing commands");
d956 1
a956 1
#if PIPELINING
d959 1
a959 1
#endif /* PIPELINING */
d1691 1
a1691 1
#if _FFR_QUARANTINE
d1700 1
a1700 1
#endif /* _FFR_QUARANTINE */
a1729 1

d1860 2
d1863 1
@


1.8
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.795 2001/09/25 19:57:10 gshapiro Exp $")
d200 1
a200 1
	unsigned int sm_nrcpts;	/* number of RCPT commands */
d202 1
d211 1
a211 1
	char	*sm_holdmsg;	/* carry quarantining across messages */
a356 1
	volatile unsigned int delay = 1;	/* timeout for bad commands */
d500 2
d614 3
d623 3
d644 5
d655 5
d665 1
d725 2
a726 2
	if (e->e_holdmsg == NULL)
		smtp.sm_holdmsg = NULL;
d728 1
a728 1
		smtp.sm_holdmsg = newstr(e->e_holdmsg);
a1026 8
		if (e->e_id == NULL)
			sm_setproctitle(true, e, "%s: %.80s",
					CurSmtpClient, inp);
		else
			sm_setproctitle(true, e, "%s %s: %.80s",
					qid_printname(e),
					CurSmtpClient, inp);

d1053 7
d1065 4
d1071 8
d1108 2
a1109 1
				if (++n_badcmds > MAXBADCOMMANDS)
d1111 6
a1116 4
					delay *= 2;
					if (delay >= MAXTIMEOUT)
						delay = MAXTIMEOUT;
					(void) sleep(delay);
d1634 1
a1634 1
				if (smtp.sm_holdmsg == NULL)
d1636 1
a1636 1
					e->e_holdmsg = NULL;
d1638 1
a1638 1
						  macid("{holdmsg}"), "");
d1642 2
a1643 2
					e->e_holdmsg = sm_rpool_strdup_x(e->e_rpool,
									 smtp.sm_holdmsg);
d1645 2
a1646 2
						  macid("{holdmsg}"),
						  e->e_holdmsg);
d1662 4
d1671 4
d1680 4
d1697 3
a1699 3
				if (smtp.sm_holdmsg == NULL &&
				    e->e_holdmsg != NULL)
					smtp.sm_holdmsg = newstr(e->e_holdmsg);
d1964 20
d2310 1
a2310 1
			if (smtp.sm_holdmsg == NULL)
d2312 1
a2312 1
				e->e_holdmsg = NULL;
d2314 1
a2314 1
					  macid("{holdmsg}"), "");
d2318 2
a2319 2
				e->e_holdmsg = sm_rpool_strdup_x(e->e_rpool,
								 smtp.sm_holdmsg);
d2321 1
a2321 1
					  macid("{holdmsg}"), e->e_holdmsg);
d2610 1
a2610 1
			finis(true, ExitStat);
d2801 4
d2811 1
a2811 1
			if (MilterLogLevel > 8)
d2813 1
a2813 1
					  "Milter: reject, message data");
d2818 3
d2826 4
d2851 6
d2868 1
a2868 2
	if (!aborting)
	{
d2870 1
a2870 1
		if (QueueMode == QM_HELD || e->e_holdmsg == NULL)
d2872 2
a2873 2
			aborting = !split_by_recipient(e);
	}
a2937 8
#if _FFR_QUARANTINE
		else if (QueueMode != QM_HELD &&
			 ee->e_holdmsg != NULL)
		{
			/* make sure it is in the queue */
			queueup(ee, false, true);
		}
#endif /* _FFR_QUARANTINE */
d2965 2
a2966 2
			else if (QueueMode != QM_HELD &&
				 ee->e_holdmsg != NULL)
d3018 2
a3019 2
			    QueueMode != QM_HELD &&
			    ee->e_holdmsg != NULL)
d3044 1
a3044 1
	if (smtp->sm_holdmsg == NULL)
d3046 2
a3047 2
		e->e_holdmsg = NULL;
		macdefine(&e->e_macro, A_PERM, macid("{holdmsg}"), "");
d3051 1
a3051 1
		e->e_holdmsg = sm_rpool_strdup_x(e->e_rpool, smtp->sm_holdmsg);
d3053 1
a3053 1
			  macid("{holdmsg}"), e->e_holdmsg);
d3307 1
d3314 5
d3458 4
d3495 1
d3747 1
d3749 4
@


1.7
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d19 1
a19 1
SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.778 2001/09/04 22:43:06 ca Exp $")
d209 3
d628 1
d630 2
a631 1
		(void) milter_connect(peerhostname, RealHostAddr, e, &state);
d646 2
d704 8
d949 3
a951 2
						  "AUTH=server, relay=%.100s, authid=%.32s, mech=%.16s, bits=%d",
						  CurSmtpClient, user,
d1596 1
d1599 19
d1629 1
a1629 1
					nullserver = response;
d1643 13
d1922 5
d1933 1
a1933 1
				macid("{addr_type}"), NULL);
d2243 16
d2374 5
a2378 1
			if (!bitset(SRV_OFFER_ETRN, features) || UseMSP)
d2634 1
a2634 1
/*
d2787 6
a2792 1
		aborting = !split_by_recipient(e);
d2857 8
d2891 8
d2943 9
d2968 15
d2984 1
a2984 1
/*
d3026 1
a3026 1
/*
d3081 1
a3081 1
/*
d3157 1
a3157 1
/*
d3208 1
a3208 1
/*
d3475 1
a3475 1
/*
d3564 1
a3564 1
/*
d3624 1
a3624 1
/*
d3666 1
a3666 1
/*
d3696 1
a3696 1
/*
d3723 1
a3723 1
/*
d3820 1
a3820 1
/*
@


1.6
log
@update to sendmail 8.11.5
@
text
@a13 1

d15 45
d61 1
a61 36
#ifndef lint
# if SMTP
static char id[] = "@@(#)$Sendmail: srvrsmtp.c,v 8.471.2.2.2.78 2001/06/26 18:52:21 gshapiro Exp $ (with SMTP)";
# else /* SMTP */
static char id[] = "@@(#)$Sendmail: srvrsmtp.c,v 8.471.2.2.2.78 2001/06/26 18:52:21 gshapiro Exp $ (without SMTP)";
# endif /* SMTP */
#endif /* ! lint */

#if SMTP
# if SASL || STARTTLS
#  include "sfsasl.h"
# endif /* SASL || STARTTLS */
# if SASL
#  define ENC64LEN(l)	(((l) + 2) * 4 / 3 + 1)
static int saslmechs __P((sasl_conn_t *, char **));
# endif /* SASL */
# if STARTTLS
#  include <sysexits.h>
#   include <openssl/err.h>
#   include <openssl/bio.h>
#   include <openssl/pem.h>
#   ifndef HASURANDOMDEV
#    include <openssl/rand.h>
#   endif /* !HASURANDOMDEV */

static SSL	*srv_ssl = NULL;
static SSL_CTX	*srv_ctx = NULL;
#  if !TLS_NO_RSA
static RSA	*rsa = NULL;
#  endif /* !TLS_NO_RSA */
static bool	tls_ok_srv = FALSE;
static int	tls_verify_cb __P((X509_STORE_CTX *));
#  if !TLS_NO_RSA
#   define RSA_KEYLENGTH	512
#  endif /* !TLS_NO_RSA */
# endif /* STARTTLS */
d63 1
a63 1
static time_t	checksmtpattack __P((volatile int *, int, bool,
a67 1
static int	runinchild __P((char *, ENVELOPE *));
d69 1
d72 3
d80 2
a81 1
**			all SMTP commands.
d88 8
a95 2
**		Reads commands from the input channel and processes
**			them.
d105 19
a123 19
# define CMDERROR	0	/* bad command */
# define CMDMAIL	1	/* mail -- designate sender */
# define CMDRCPT	2	/* rcpt -- designate recipient */
# define CMDDATA	3	/* data -- send message text */
# define CMDRSET	4	/* rset -- reset state */
# define CMDVRFY	5	/* vrfy -- verify address */
# define CMDEXPN	6	/* expn -- expand address */
# define CMDNOOP	7	/* noop -- do nothing */
# define CMDQUIT	8	/* quit -- close connection and die */
# define CMDHELO	9	/* helo -- be polite */
# define CMDHELP	10	/* help -- give usage info */
# define CMDEHLO	11	/* ehlo -- extended helo (RFC 1425) */
# define CMDETRN	12	/* etrn -- flush queue */
# if SASL
#  define CMDAUTH	13	/* auth -- SASL authenticate */
# endif /* SASL */
# if STARTTLS
#  define CMDSTLS	14	/* STARTTLS -- start TLS session */
# endif /* STARTTLS */
d125 1
a125 3
# define CMDONEX	16	/* onex -- sending one transaction only */
# define CMDVERB	17	/* verb -- go into verbose mode */
# define CMDXUSR	18	/* xusr -- initial (user) submission */
d127 1
a127 1
# define CMDUNIMPL	19	/* unimplemented rfc821 commands */
d129 1
a129 1
# define CMDLOGBOGUS	23	/* bogus command that should be logged */
d131 2
a132 2
# define CMDDBGQSHOW	24	/* showq -- show send queue */
# define CMDDBGDEBUG	25	/* debug -- set debug mode */
d135 1
a135 2
**  Note: If you change this list,
**        remember to update 'helpfile'
a152 2
	{ "onex",	CMDONEX		},
	{ "xusr",	CMDXUSR		},
d157 1
a157 1
# if SASL
d159 2
a160 2
# endif /* SASL */
# if STARTTLS
d162 1
a162 1
# endif /* STARTTLS */
a170 1
static bool	OneXact = FALSE;	/* one xaction only this run */
d173 155
a327 11
# define MAXBADCOMMANDS		25	/* maximum number of bad commands */
# define MAXNOOPCOMMANDS	20	/* max "noise" commands before slowdown */
# define MAXHELOCOMMANDS	3	/* max HELO/EHLO commands before slowdown */
# define MAXVRFYCOMMANDS	6	/* max VRFY/EXPN commands before slowdown */
# define MAXETRNCOMMANDS	8	/* max ETRN commands before slowdown */
# define MAXTIMEOUT	(4 * 60)	/* max timeout for bad commands */

/* runinchild() returns */
# define RIC_INCHILD		0	/* in a child process */
# define RIC_INPARENT		1	/* still in parent process */
# define RIC_TEMPFAIL		2	/* temporary failure occurred */
a339 1
	volatile bool gotmail;		/* mail command received */
d347 7
a353 10
	volatile int nrcpts = 0;	/* number of RCPT commands */
	int ric;
	bool doublequeue;
	volatile bool discard;
	volatile int badcommands = 0;	/* count of bad commands */
	volatile int nverifies = 0;	/* count of VRFY/EXPN commands */
	volatile int n_etrn = 0;	/* count of ETRN commands */
	volatile int n_noop = 0;	/* count of NOOP/VERB/ONEX etc cmds */
	volatile int n_helo = 0;	/* count of HELO/EHLO commands */
	volatile int delay = 1;		/* timeout for bad commands */
d355 4
a358 4
	volatile bool tempfail = FALSE;
# if _FFR_MILTER
	volatile bool milterize = (nullserver == NULL);
# endif /* _FFR_MILTER */
d361 1
a361 1
	volatile bool lognullconnection = TRUE;
d363 1
d366 1
d372 1
a372 1
# if SASL
d375 1
a375 1
	volatile int n_auth = 0;	/* count of AUTH commands */
a378 1
	char *hostname;
d382 1
a382 1
	int inlen, out2len;
d386 2
a387 2
	volatile int n_mechs;
	int len;
a389 1
#  if SFIO
d391 2
a392 3
#  endif /* SFIO */
# endif /* SASL */
# if STARTTLS
d395 4
a398 2
	volatile bool usetls = TRUE;
	volatile bool tls_active = FALSE;
d401 30
a430 7
# endif /* STARTTLS */

	if (fileno(OutChannel) != fileno(stdout))
	{
		/* arrange for debugging output to go to remote host */
		(void) dup2(fileno(OutChannel), fileno(stdout));
	}
d433 1
a433 1
	(void)sm_getla(e);
d443 1
a443 1
	discard = bitset(EF_DISCARD, e->e_flags);
d445 50
a494 1
	sm_setproctitle(TRUE, e, "server %s startup", CurSmtpClient);
d496 3
a498 2
# if SASL
	sasl_ok = FALSE;	/* SASL can't be used (yet) */
d500 1
d503 20
a522 9
	hostname = macvalue('j', e);
#  if SASL > 10505
	/* use empty realm: only works in SASL > 1.5.5 */
	result = sasl_server_new("smtp", hostname, "", NULL, 0, &conn);
#  else /* SASL > 10505 */
	/* use no realm -> realm is set to hostname by SASL lib */
	result = sasl_server_new("smtp", hostname, NULL, NULL, 0, &conn);
#  endif /* SASL > 10505 */
	if (result == SASL_OK)
a523 2
		sasl_ok = TRUE;

d533 2
a534 2
# if NETINET
		in = macvalue(macid("{daemon_family}", NULL), e);
d542 2
a543 1
			if (getpeername(fileno(InChannel),
d549 3
a551 1
				if (getsockname(fileno(InChannel),
d558 1
a558 1
# endif /* NETINET */
a559 1
		authenticating = SASL_NOT_AUTH;
d563 4
a566 3
#  if 0
		define(macid("{auth_author}", NULL), NULL, &BlankEnvelope);
#  endif /* 0 */
d570 1
a570 1
#  if SFIO
d573 2
d576 1
a576 1
			ssp.max_ssf = INT_MAX;
a578 2
#  endif /* SFIO */
#  if _FFR_SASL_OPTS
a579 1
#  endif /* _FFR_SASL_OPTS */
d586 1
a586 5
			**  we have none so zero
#   if STARTTLS
			**  we may have to change this for STARTTLS
			**  (dynamically)
#   endif
d588 1
a594 1
		{
a595 9
			sasl_ok = n_mechs > 0;
		}
	}
	else
	{
		if (LogLevel > 9)
			sm_syslog(LOG_WARNING, NOQID,
				  "SASL error: sasl_server_new failed=%d",
				  result);
d597 1
a597 1
# endif /* SASL */
d599 2
a600 16
# if STARTTLS
#  if _FFR_TLS_O_T
	saveQuickAbort = QuickAbort;
	saveSuprErrs = SuprErrs;
	SuprErrs = TRUE;
	QuickAbort = FALSE;
	if (rscheck("offer_tls", CurSmtpClient, "", e, TRUE, FALSE, 8,
		    NULL) != EX_OK || Errors > 0)
		usetls = FALSE;
	QuickAbort = saveQuickAbort;
	SuprErrs = saveSuprErrs;
#  endif /* _FFR_TLS_O_T */
# endif /* STARTTLS */

# if _FFR_MILTER
	if (milterize)
d605 1
a605 1
		milter_init(e, &state);
d611 1
a611 1
			milterize = FALSE;
d615 2
a616 2
			tempfail = TRUE;
			milterize = FALSE;
d621 2
a622 1
	if (milterize && !bitset(EF_DISCARD, e->e_flags))
d626 1
a626 2
		(void) milter_connect(peerhostname, RealHostAddr,
				      e, &state);
d633 1
a633 1
			milterize = FALSE;
d637 2
a638 2
			tempfail = TRUE;
			milterize = FALSE;
d642 13
a654 1
# endif /* _FFR_MILTER */
d657 6
a662 1
	expand(SmtpGreeting, inp, sizeof inp, e);
d670 1
a670 1
		snprintf(cmdbuf, sizeof cmdbuf,
d673 1
a673 1
		snprintf(cmdbuf, sizeof cmdbuf,
d683 1
a683 1
		(void) snprintf(cmdbuf, sizeof cmdbuf, "%s-%%s", greetcode);
d690 1
a690 1
		(void) snprintf(cmdbuf, sizeof cmdbuf, "%s %%s", greetcode);
d696 9
a704 2
	gothello = FALSE;
	gotmail = FALSE;
d707 7
a713 7
		/* arrange for backout */
		(void) setjmp(TopFrame);
		QuickAbort = FALSE;
		HoldErrs = FALSE;
		SuprErrs = FALSE;
		LogUsrErrs = FALSE;
		OnlyOneError = TRUE;
d720 1
a720 1
		(void) fflush(stdout);
d724 2
a725 2
		sm_setproctitle(TRUE, e, "server %s cmd read", CurSmtpClient);
# if SASL
d727 2
a728 3
		**  SMTP AUTH requires accepting any length,
		**  at least for challenge/response
		**  XXX
d730 1
a730 1
# endif /* SASL */
d733 1
a733 1
		if (ferror(OutChannel) ||
d739 1
a739 1
			d = macvalue(macid("{daemon_name}", NULL), e);
d745 1
a745 1
# if _FFR_MILTER
d748 1
a748 1
# endif /* _FFR_MILTER */
d752 1
a752 1
			if (LogLevel > (gotmail ? 1 : 19))
d767 22
d790 20
a809 1
		fixcrlf(inp, TRUE);
d811 4
a814 1
# if SASL
d817 1
a817 1
#  if 0
d824 1
a824 1
#  endif /* 0 */
d856 2
a857 2
				define(macid("{auth_type}", NULL),
				       newstr(auth_type), &BlankEnvelope);
d864 3
a866 2
					define(macid("{auth_authen}", NULL),
					       NULL, &BlankEnvelope);
d870 3
a872 2
					define(macid("{auth_authen}", NULL),
					       newstr(user), &BlankEnvelope);
d875 1
a875 1
#  if 0
d878 1
a878 1
#  endif /* 0 */
a879 2

#  if SFIO
d885 3
a887 2
					define(macid("{auth_ssf}", NULL),
					       "0", &BlankEnvelope);
d894 5
a898 3
					snprintf(pbuf, sizeof pbuf, "%u", *ssf);
					define(macid("{auth_ssf}", NULL),
					       newstr(pbuf), &BlankEnvelope);
d900 2
a901 2
						dprintf("SASL auth_ssf: %u\n",
							*ssf);
d903 1
d905 1
a905 1
				**  only switch to encrypted connection
d908 1
d912 3
a914 7
					**  convert sfio stuff to use SASL
					**  check return values
					**  if the call fails,
					**  fall back to unencrypted version
					**  unless some cf option requires
					**  encryption then the connection must
					**  be aborted
d916 3
a918 2
					if (sfdcsasl(InChannel, OutChannel,
					    conn) == 0)
a920 2
						gothello = FALSE;
						OneXact = TRUE;
d922 4
a928 7
					if (LogLevel > 9)
						sm_syslog(LOG_INFO,
							  NOQID,
							  "SASL: connection from %.64s: mech=%.16s, id=%.64s, bits=%d",
							  CurSmtpClient,
							  auth_type, user,
							  *ssf);
d930 3
a932 2
#  else /* SFIO */
				if (LogLevel > 9)
d934 3
a936 4
						  "SASL: connection from %.64s: mech=%.16s, id=%.64s",
						  CurSmtpClient, auth_type,
						  user);
#  endif /* SFIO */
d943 1
a943 1
						       (u_int *)&out2len);
d951 1
a951 1
							  "SASL encode64 error [%d for \"%s\"]",
d960 2
a961 2
						dprintf("SASL continue: msg='%s' len=%d\n",
							out2, out2len);
d970 1
a970 1
						  "AUTH failure (%s): %s (%d)",
d974 2
a975 1
						  result);
d982 1
a982 1
# endif /* SASL */
d986 2
a987 1
			fprintf(e->e_xfp, "<<< %s\n", inp);
d989 2
a990 4
		if (LogLevel >= 15)
			sm_syslog(LOG_INFO, e->e_id,
				  "<-- %s",
				  inp);
d993 1
a993 1
			sm_setproctitle(TRUE, e, "%s: %.80s",
d996 1
a996 1
			sm_setproctitle(TRUE, e, "%s %s: %.80s",
d1011 1
a1011 2
		while (isascii(*p) && isspace(*p))
			p++;
d1016 1
a1016 1
			if (strcasecmp(c->cmd_name, cmdbuf) == 0)
d1023 10
d1037 1
a1037 1
		**	to everything.
d1056 1
d1060 3
a1062 1
				if (++badcommands > MAXBADCOMMANDS)
d1069 1
d1075 2
a1076 1
						usrerr("550 5.0.0 %s", nullserver);
a1083 1
		/* non-null server */
d1086 1
a1086 10
		  case CMDMAIL:
		  case CMDEXPN:
		  case CMDVRFY:
		  case CMDETRN:
			lognullconnection = FALSE;
		}

		switch (c->cmd_code)
		{
# if SASL
d1088 2
a1089 1
			if (!sasl_ok)
d1099 1
a1099 1
			if (gotmail)
d1114 1
a1114 1
			ismore = FALSE;
d1117 1
a1117 1
			(void) checksmtpattack(&n_auth, n_mechs + 1, TRUE,
d1120 1
a1120 1
			/* make sure it's a valid string */
d1138 1
a1138 1
				message("503 5.3.3 AUTH mechanism %s not available",
d1146 1
a1146 1
				in = xalloc(strlen(q));
d1148 1
a1148 1
						       (u_int *)&inlen);
d1155 1
a1155 1
							  "SASL decode64 error [%d for \"%s\"]",
a1162 17
#  if 0
				if (tTd(95, 99))
				{
					int i;

					dprintf("AUTH: more \"");
					for (i = 0; i < inlen; i++)
					{
						if (isascii(in[i]) &&
						    isprint(in[i]))
							dprintf("%c", in[i]);
						else
							dprintf("_");
					}
					dprintf("\"\n");
				}
#  endif /* 0 */
d1179 1
a1179 1
						  "AUTH failure (%s): %s (%d)",
d1183 2
a1184 1
						  result);
d1200 1
a1200 1
					       (u_int *)&out2len);
d1207 1
a1207 1
						  "SASL encode64 error [%d for \"%s\"]",
a1217 1

d1219 1
a1219 1
# endif /* SASL */
d1221 1
a1221 1
# if STARTTLS
d1223 1
d1229 1
a1229 1
			if (!usetls)
d1239 1
a1239 1
			if (gotmail)
d1253 3
a1260 11
			if (SSL_CTX_need_tmp_RSA(srv_ctx) &&
			   !SSL_CTX_set_tmp_rsa(srv_ctx,
				(rsa = RSA_generate_key(RSA_KEYLENGTH, RSA_F4,
							NULL, NULL)))
			  )
			{
				message("454 4.3.3 TLS not available: error generating RSA temp key");
				if (rsa != NULL)
					RSA_free(rsa);
				break;
			}
d1262 11
d1278 3
d1282 1
d1284 14
a1297 2
			rfd = fileno(InChannel);
			wfd = fileno(OutChannel);
d1305 14
a1318 3
				break;
			}
			message("220 2.0.0 Ready to start TLS");
d1322 3
d1328 4
d1335 52
d1389 5
a1393 5
					sm_syslog(LOG_WARNING, e->e_id,
						  "TLS: error: accept failed=%d (%d)",
						  r, i);
					if (LogLevel > 9)
						tlslogerr();
d1395 1
a1395 1
				tls_ok_srv = FALSE;
d1410 4
a1413 2
			(void) tls_get_info(srv_ssl, &BlankEnvelope, TRUE,
					    CurSmtpClient, TRUE);
d1422 2
a1423 2
			SuprErrs = TRUE;
			QuickAbort = FALSE;
d1425 4
a1428 3
				     macvalue(macid("{verify}", NULL), e),
				     "STARTTLS", e, TRUE, TRUE, 6, NULL) !=
			    EX_OK || Errors > 0)
d1440 1
a1440 2
			tls_ok_srv = FALSE;	/* don't offer STARTTLS again */
			gothello = FALSE;	/* discard info */
d1442 1
a1442 2
			OneXact = TRUE;	/* only one xaction this run */
#  if SASL
d1447 2
a1448 2
				if ((s = macvalue(macid("{cipher_bits}", NULL), e)) != NULL &&
				    (ext_ssf.ssf = atoi(s)) > 0)
d1450 1
a1450 3
#  if _FFR_EXT_MECH
					ext_ssf.auth_id = macvalue(macid("{cert_subject}",
									 NULL),
a1451 1
#  endif /* _FFR_EXT_MECH */
a1453 2
					if (mechlist != NULL)
						sm_free(mechlist);
a1455 1
					{
a1457 2
						sasl_ok = n_mechs > 0;
					}
d1460 1
a1460 1
#  endif /* SASL */
d1463 7
a1469 9
#if SFIO
			r = sfdctls(InChannel, OutChannel, srv_ssl);
#else /* SFIO */
# if _FFR_TLS_TOREK
			r = sfdctls(&InChannel, &OutChannel, srv_ssl);
# endif /* _FFR_TLS_TOREK */
#endif /* SFIO */
			if (r == 0)
				tls_active = TRUE;
d1480 1
d1482 1
a1482 1
				syserr("TLS: can't switch to encrypted layer");
d1484 10
d1495 1
a1495 1
# endif /* STARTTLS */
d1499 1
d1512 1
a1512 1
			(void) checksmtpattack(&n_helo, MAXHELOCOMMANDS, TRUE,
d1515 2
d1524 1
d1563 1
a1563 1
				sendinghost = newstr(p);
d1579 2
a1580 1
			gothello = TRUE;
d1582 3
a1584 2
# if _FFR_MILTER
			if (milterize && !bitset(EF_DISCARD, e->e_flags))
d1594 1
a1594 1
					milterize = FALSE;
d1599 1
a1599 1
					milterize = FALSE;
d1603 2
a1604 2
					tempfail = TRUE;
					milterize = FALSE;
d1608 2
a1609 1
# endif /* _FFR_MILTER */
d1633 1
a1633 1
			**        remember to update 'helpfile'
d1638 5
a1642 1
			if (!bitset(PRIV_NOEXPN, PrivacyFlags))
d1645 1
a1645 1
				if (!bitset(PRIV_NOVERB, PrivacyFlags))
d1648 1
a1648 1
# if MIME8TO7
d1650 1
a1650 1
# endif /* MIME8TO7 */
d1655 2
a1656 3
# if DSN
			if (SendMIMEErrors &&
			    !bitset(PRIV_NORECEIPTS, PrivacyFlags))
d1658 2
a1659 4
# endif /* DSN */
			message("250-ONEX");
			if (!bitset(PRIV_NOETRN, PrivacyFlags) &&
			    !bitnset(D_NOETRN, d_flags))
d1661 1
a1661 3
			message("250-XUSR");

# if SASL
d1664 3
a1666 3
# endif /* SASL */
# if STARTTLS
			if (tls_ok_srv && usetls)
d1668 9
a1676 1
# endif /* STARTTLS */
d1682 1
d1690 1
a1690 1
			if (gotmail)
d1695 2
a1696 8
			if (InChild)
			{
				errno = 0;
				syserr("503 5.5.0 Nested MAIL command: MAIL %s", p);
				finis(TRUE, ExitStat);
			}
# if SASL
			if (bitnset(D_AUTHREQ, d_flags) &&
d1702 1
a1702 1
# endif /* SASL */
d1713 1
a1713 1
				usrerr("451 4.7.1 Please try again later");
d1722 8
a1729 8
			/* fork a subprocess to process this command */
			ric = runinchild("SMTP-MAIL", e);

			/* Catch a problem and stop processing */
			if (ric == RIC_TEMPFAIL && nullserver == NULL)
				nullserver = "452 4.3.0 Internal software error";
			if (ric != RIC_INCHILD)
				break;
d1732 1
a1732 1
				goto undo_subproc_no_pm;
d1735 7
a1741 8
				auth_warning(e,
					"%s didn't use HELO protocol",
					CurSmtpClient);
			}
# ifdef PICKY_HELO_CHECK
			if (strcasecmp(sendinghost, peerhostname) != 0 &&
			    (strcasecmp(peerhostname, "localhost") != 0 ||
			     strcasecmp(sendinghost, MyHostName) != 0))
d1744 1
a1744 1
					CurSmtpClient, sendinghost);
d1746 1
a1746 1
# endif /* PICKY_HELO_CHECK */
d1750 2
a1751 2
			define('r', protocol, e);
			define('s', sendinghost, e);
d1754 5
a1758 3
				goto undo_subproc_no_pm;
			nrcpts = 0;
			define(macid("{ntries}", NULL), "0", e);
d1760 1
a1760 1
			sm_setproctitle(TRUE, e, "%s %s: %.80s",
d1764 4
a1767 23
			/* child -- go do the processing */
			if (setjmp(TopFrame) > 0)
			{
				/* this failed -- undo work */
 undo_subproc_no_pm:
				e->e_flags &= ~EF_PM_NOTIFY;
 undo_subproc:
				if (InChild)
				{
					QuickAbort = FALSE;
					SuprErrs = TRUE;
					e->e_flags &= ~EF_FATALERRS;

					if (LogLevel > 4 &&
					    bitset(EF_LOGSENDER, e->e_flags))
						logsender(e, NULL);
					e->e_flags &= ~EF_LOGSENDER;

					finis(TRUE, ExitStat);
				}
				break;
			}
			QuickAbort = TRUE;
d1771 1
a1771 1
			setsender(p, e, &delimptr, ' ', FALSE);
d1775 1
a1775 1
				goto undo_subproc_no_pm;
d1782 3
a1784 2
				 define(macid("{mail_mailer}", NULL),
					e->e_from.q_mailer->m_name, e);
d1786 2
a1787 2
				 define(macid("{mail_mailer}", NULL),
					NULL, e);
d1789 3
a1791 2
				define(macid("{mail_host}", NULL),
				       e->e_from.q_host, e);
d1793 2
a1794 2
				define(macid("{mail_host}", NULL),
				       "localhost", e);
d1796 3
a1798 2
				define(macid("{mail_addr}", NULL),
				       e->e_from.q_user, e);
d1800 2
a1801 2
				define(macid("{mail_addr}", NULL),
				       NULL, e);
d1803 1
a1803 1
			  goto undo_subproc_no_pm;
d1829 1
a1829 2
				while (isascii(*p) && isspace(*p))
					p++;
d1854 1
a1854 1
					dprintf("MAIL: got arg %s=\"%s\"\n", kp,
d1864 1
a1864 1
					goto undo_subproc_no_pm;
d1868 1
a1868 1
				goto undo_subproc_no_pm;
d1871 2
d1874 2
a1875 1
				    NULL, e, TRUE, TRUE, 4, NULL) != EX_OK ||
d1877 3
a1879 1
				goto undo_subproc_no_pm;
d1887 1
a1887 1
				goto undo_subproc_no_pm;
d1890 14
a1903 1
			if (!enoughdiskspace(e->e_msgsize, TRUE))
d1905 5
d1911 1
a1911 1
				goto undo_subproc_no_pm;
d1914 1
a1914 1
				goto undo_subproc_no_pm;
d1916 4
a1919 3
# if _FFR_MILTER
			LogUsrErrs = TRUE;
			if (milterize && !bitset(EF_DISCARD, e->e_flags))
d1925 1
a1925 20
				switch (state)
				{
				  case SMFIR_REPLYCODE:
					usrerr(response);
					break;

				  case SMFIR_REJECT:
					usrerr("550 5.7.1 Command rejected");
					break;

				  case SMFIR_DISCARD:
					e->e_flags |= EF_DISCARD;
					break;

				  case SMFIR_TEMPFAIL:
					usrerr("451 4.7.1 Please try again later");
					break;
				}
				if (response != NULL)
					sm_free(response);
d1927 1
a1927 1
# endif /* _FFR_MILTER */
d1929 1
a1929 1
				goto undo_subproc_no_pm;
d1932 18
a1949 1
			gotmail = TRUE;
d1953 2
a1954 1
			if (!gotmail)
d1960 4
a1963 7
			if (setjmp(TopFrame) > 0)
			{
				e->e_flags &= ~(EF_FATALERRS|EF_PM_NOTIFY);
				break;
			}
			QuickAbort = TRUE;
			LogUsrErrs = TRUE;
d1966 2
a1967 1
			if (MaxRcptPerMsg > 0 && nrcpts >= MaxRcptPerMsg)
d1969 1
d1971 1
a1971 1
				break;
d1977 1
a1977 1
# if _FFR_MILTER
d1989 1
a1989 1
# endif /* _FFR_MILTER */
d1993 30
a2022 8
				break;
# if _FFR_ADDR_TYPE
			define(macid("{addr_type}", NULL), "e r", e);
# endif /* _FFR_ADDR_TYPE */
			a = parseaddr(p, NULLADDR, RF_COPYALL, ' ', &delimptr, e);
#if _FFR_ADDR_TYPE
			define(macid("{addr_type}", NULL), NULL, e);
#endif /* _FFR_ADDR_TYPE */
d2024 1
a2024 1
				break;
d2028 1
a2028 1
				break;
d2036 3
a2038 2
				define(macid("{rcpt_mailer}", NULL),
				       a->q_mailer->m_name, e);
d2040 2
a2041 2
				define(macid("{rcpt_mailer}", NULL),
				       NULL, e);
d2043 2
a2044 2
				define(macid("{rcpt_host}", NULL),
				       a->q_host, e);
d2046 2
a2047 2
				define(macid("{rcpt_host}", NULL),
				       "localhost", e);
d2049 2
a2050 2
				define(macid("{rcpt_addr}", NULL),
				       a->q_user, e);
d2052 2
a2053 2
				define(macid("{rcpt_addr}", NULL),
				       NULL, e);
d2055 1
a2055 1
				break;
d2069 1
a2069 2
				while (isascii(*p) && isspace(*p))
					p++;
d2094 1
a2094 1
					dprintf("RCPT: got arg %s=\"%s\"\n", kp,
d2108 1
a2108 1
				break;
d2111 2
d2114 2
a2115 1
				    NULL, e, TRUE, TRUE, 4, NULL) != EX_OK ||
d2117 3
a2119 1
				break;
d2121 3
a2123 2
# if _FFR_MILTER
			if (milterize && !bitset(EF_DISCARD, e->e_flags))
d2129 1
a2129 20
				switch (state)
				{
				  case SMFIR_REPLYCODE:
					usrerr(response);
					break;

				  case SMFIR_REJECT:
					usrerr("550 5.7.1 Command rejected");
					break;

				  case SMFIR_DISCARD:
					e->e_flags |= EF_DISCARD;
					break;

				  case SMFIR_TEMPFAIL:
					usrerr("451 4.7.1 Please try again later");
					break;
				}
				if (response != NULL)
					sm_free(response);
d2131 1
a2131 1
# endif /* _FFR_MILTER */
d2133 8
a2140 4
			define(macid("{rcpt_mailer}", NULL), NULL, e);
			define(macid("{rcpt_relay}", NULL), NULL, e);
			define(macid("{rcpt_addr}", NULL), NULL, e);
			define(macid("{dsn_notify}", NULL), NULL, e);
d2142 1
a2142 1
				break;
d2147 1
a2147 1
				break;
d2153 1
a2153 1
				if (e->e_queuedir == NOQDIR)
d2158 1
a2158 1
				nrcpts++;
d2165 11
d2179 17
a2195 2
			SmtpPhase = "server DATA";
			if (!gotmail)
d2197 8
a2204 1
				usrerr("503 5.0.0 Need MAIL command");
d2207 5
a2211 1
			else if (nrcpts <= 0)
d2213 1
a2213 244
				usrerr("503 5.0.0 Need RCPT (recipient)");
				break;
			}

			/* put back discard bit */
			if (discard)
				e->e_flags |= EF_DISCARD;

			/* check to see if we need to re-expand aliases */
			/* also reset QS_BADADDR on already-diagnosted addrs */
			doublequeue = FALSE;
			for (a = e->e_sendqueue; a != NULL; a = a->q_next)
			{
				if (QS_IS_VERIFIED(a->q_state) &&
				    !bitset(EF_DISCARD, e->e_flags))
				{
					/* need to re-expand aliases */
					doublequeue = TRUE;
				}
				if (QS_IS_BADADDR(a->q_state))
				{
					/* make this "go away" */
					a->q_state = QS_DONTSEND;
				}
			}

			/* collect the text of the message */
			SmtpPhase = "collect";
			buffer_errors();
			collect(InChannel, TRUE, NULL, e);

# if _FFR_MILTER
			if (milterize &&
			    Errors <= 0 &&
			    !bitset(EF_DISCARD, e->e_flags))
			{
				char state;
				char *response;

				response = milter_data(e, &state);
				switch (state)
				{
				  case SMFIR_REPLYCODE:
					usrerr(response);
					break;

				  case SMFIR_REJECT:
					usrerr("554 5.7.1 Command rejected");
					break;

				  case SMFIR_DISCARD:
					e->e_flags |= EF_DISCARD;
					break;

				  case SMFIR_TEMPFAIL:
					usrerr("451 4.7.1 Please try again later");
					break;
				}
				if (response != NULL)
					sm_free(response);
			}

			/* abort message filters that didn't get the body */
			if (milterize)
				milter_abort(e);
# endif /* _FFR_MILTER */

			/* redefine message size */
			if ((q = macvalue(macid("{msg_size}", NULL), e))
			    != NULL)
				sm_free(q);
			snprintf(inp, sizeof inp, "%ld", e->e_msgsize);
			define(macid("{msg_size}", NULL), newstr(inp), e);
			if (Errors > 0)
			{
				/* Log who the mail would have gone to */
				if (LogLevel > 8 &&
				    e->e_message != NULL)
				{
					for (a = e->e_sendqueue;
					     a != NULL;
					     a = a->q_next)
					{
						if (!QS_IS_UNDELIVERED(a->q_state))
							continue;

						e->e_to = a->q_paddr;
						logdelivery(NULL, NULL,
							    a->q_status,
							    e->e_message,
							    NULL,
							    (time_t) 0, e);
					}
					e->e_to = NULL;
				}
				flush_errors(TRUE);
				buffer_errors();
				goto abortmessage;
			}

			/* make sure we actually do delivery */
			e->e_flags &= ~EF_CLRQUEUE;

			/* from now on, we have to operate silently */
			buffer_errors();
			e->e_errormode = EM_MAIL;

			/*
			**  Arrange to send to everyone.
			**	If sending to multiple people, mail back
			**		errors rather than reporting directly.
			**	In any case, don't mail back errors for
			**		anything that has happened up to
			**		now (the other end will do this).
			**	Truncate our transcript -- the mail has gotten
			**		to us successfully, and if we have
			**		to mail this back, it will be easier
			**		on the reader.
			**	Then send to everyone.
			**	Finally give a reply code.  If an error has
			**		already been given, don't mail a
			**		message back.
			**	We goose error returns by clearing error bit.
			*/

			SmtpPhase = "delivery";
			(void) bftruncate(e->e_xfp);
			id = e->e_id;

			/*
			**  If a header/body check (header checks or milter)
			**  set EF_DISCARD, don't queueup the message --
			**  that would lose the EF_DISCARD bit and deliver
			**  the message.
			*/

			if (bitset(EF_DISCARD, e->e_flags))
				doublequeue = FALSE;

			if (doublequeue)
			{
				/* make sure it is in the queue */
				queueup(e, FALSE);
			}
			else
			{
				/* send to all recipients */
# if NAMED_BIND
				_res.retry = TimeOuts.res_retry[RES_TO_FIRST];
				_res.retrans = TimeOuts.res_retrans[RES_TO_FIRST];
# endif /* NAMED_BIND */
				sendall(e, SM_DEFAULT);
			}
			e->e_to = NULL;

			/* issue success message */
			message("250 2.0.0 %s Message accepted for delivery", id);

			/* if we just queued, poke it */
			if (doublequeue &&
			    e->e_sendmode != SM_QUEUE &&
			    e->e_sendmode != SM_DEFER)
			{
				CurrentLA = sm_getla(e);

				if (!shouldqueue(e->e_msgpriority, e->e_ctime))
				{
					/* close all the queue files */
					closexscript(e);
					if (e->e_dfp != NULL)
						(void) bfclose(e->e_dfp);
					e->e_dfp = NULL;
					unlockqueue(e);

					(void) dowork(e->e_queuedir, id,
						      TRUE, TRUE, e);
				}
			}

  abortmessage:
			if (LogLevel > 4 && bitset(EF_LOGSENDER, e->e_flags))
				logsender(e, NULL);
			e->e_flags &= ~EF_LOGSENDER;

			/* if in a child, pop back to our parent */
			if (InChild)
				finis(TRUE, ExitStat);

			/* clean up a bit */
			gotmail = FALSE;
			dropenvelope(e, TRUE);
			CurEnv = e = newenvelope(e, CurEnv);
			e->e_flags = BlankEnvelope.e_flags;
			break;

		  case CMDRSET:		/* rset -- reset state */
# if _FFR_MILTER
			/* abort milter filters */
			milter_abort(e);
# endif /* _FFR_MILTER */

			if (tTd(94, 100))
				message("451 4.0.0 Test failure");
			else
				message("250 2.0.0 Reset state");

			/* arrange to ignore any current send list */
			e->e_sendqueue = NULL;
			e->e_flags |= EF_CLRQUEUE;

			if (LogLevel > 4 && bitset(EF_LOGSENDER, e->e_flags))
				logsender(e, NULL);
			e->e_flags &= ~EF_LOGSENDER;

			if (InChild)
				finis(TRUE, ExitStat);

			/* clean up a bit */
			gotmail = FALSE;
			SuprErrs = TRUE;
			dropenvelope(e, TRUE);
			CurEnv = e = newenvelope(e, CurEnv);
			break;

		  case CMDVRFY:		/* vrfy -- verify address */
		  case CMDEXPN:		/* expn -- expand address */
			if (tempfail)
			{
				if (LogLevel > 9)
					sm_syslog(LOG_INFO, e->e_id,
						  "SMTP %s command (%.100s) from %.100s tempfailed (due to previous checks)",
						  c->cmd_code == CMDVRFY ? "VRFY" : "EXPN",
						  p, CurSmtpClient);
				usrerr("550 5.7.1 Please try again later");
				break;
			}
			wt = checksmtpattack(&nverifies, MAXVRFYCOMMANDS, FALSE,
				c->cmd_code == CMDVRFY ? "VRFY" : "EXPN", e);
			previous = curtime();
			vrfy = c->cmd_code == CMDVRFY;
			if (bitset(vrfy ? PRIV_NOVRFY : PRIV_NOEXPN,
						PrivacyFlags))
			{
				if (vrfy)
d2231 1
a2231 1
			if (runinchild(vrfy ? "SMTP-VRFY" : "SMTP-EXPN", e) > 0)
a2232 2
			if (Errors > 0)
				goto undo_subproc;
d2234 1
a2234 2
				sm_syslog(LOG_INFO, e->e_id,
					  "%.100s: %s",
d2237 3
a2239 3
			if (setjmp(TopFrame) > 0)
				goto undo_subproc;
			QuickAbort = TRUE;
d2253 4
a2256 3
					    p, NULL, e, TRUE, FALSE, 4, NULL)
				    != EX_OK || Errors > 0)
					goto undo_subproc;
d2268 1
a2268 1
				goto undo_subproc;
d2289 11
a2299 2
			if (InChild)
				finis(TRUE, ExitStat);
d2303 2
a2304 2
			if (bitset(PRIV_NOETRN, PrivacyFlags) ||
			    bitnset(D_NOETRN, d_flags))
d2321 1
a2321 1
				usrerr("451 4.7.1 Please try again later");
d2332 1
a2332 1
			(void) checksmtpattack(&n_etrn, MAXETRNCOMMANDS, TRUE,
d2335 12
a2346 3
			/* do config file checking of the parameter */
			if (rscheck("check_etrn", p, NULL, e, TRUE, FALSE, 4,
				    NULL) != EX_OK || Errors > 0)
d2351 1
a2351 2
					  "%.100s: ETRN %s",
					  CurSmtpClient,
d2355 19
d2379 6
a2384 1
			new = (QUEUE_CHAR *)xalloc(sizeof(QUEUE_CHAR));
d2386 1
d2389 2
a2390 2
			ok = runqueue(TRUE, FALSE);
			sm_free(QueueLimitRecipient);
d2397 1
d2402 2
a2403 1
			(void) checksmtpattack(&n_noop, MAXNOOPCOMMANDS, TRUE,
d2410 6
d2420 1
a2420 1
# if STARTTLS
d2425 1
a2425 1
				tls_active = FALSE;
d2427 2
a2428 2
# endif /* STARTTLS */
# if SASL
d2433 1
d2435 1
a2435 1
# endif /* SASL */
d2441 1
a2441 1
# if _FFR_MILTER
d2444 1
a2444 4
# endif /* _FFR_MILTER */

			if (InChild)
				ExitStat = EX_QUIT;
d2454 1
a2454 1
				d = macvalue(macid("{daemon_name}", NULL), e);
d2457 9
a2465 2
				sm_syslog(LOG_INFO, NULL,
					 "%.100s did not issue MAIL/EXPN/VRFY/ETRN during connection to %s",
d2468 4
a2471 1
			finis(TRUE, ExitStat);
d2475 1
d2477 1
d2484 1
a2484 1
			(void) checksmtpattack(&n_noop, MAXNOOPCOMMANDS, TRUE,
d2491 1
a2491 15
		  case CMDONEX:		/* doing one transaction only */
			(void) checksmtpattack(&n_noop, MAXNOOPCOMMANDS, TRUE,
					       "ONEX", e);
			OneXact = TRUE;
			message("250 2.0.0 Only one transaction");
			break;

		  case CMDXUSR:		/* initial (user) submission */
			(void) checksmtpattack(&n_noop, MAXNOOPCOMMANDS, TRUE,
					       "XUSR", e);
			define(macid("{daemon_flags}", NULL), "c u", CurEnv);
			message("250 2.0.0 Initial submission");
			break;

# if SMTPDEBUG
d2493 3
a2495 2
			printf("Send Queue=");
			printaddr(e->e_sendqueue, TRUE);
d2504 1
a2504 1
# else /* SMTPDEBUG */
d2507 1
a2507 1
# endif /* SMTPDEBUG */
d2509 1
d2518 2
a2519 1
			if (++badcommands > MAXBADCOMMANDS)
d2528 1
d2535 1
d2541 1
d2546 1
a2546 1
# if SASL
d2548 10
a2557 1
# endif /* SASL */
a2558 1

d2561 1
a2561 1
**  CHECKSMTPATTACK -- check for denial-of-service attack by repetition
d2564 2
a2565 6
**		pcounter -- pointer to a counter for this command.
**		maxcount -- maximum value for this counter before we
**			slow down.
**		waitnow -- sleep now (in this routine)?
**		cname -- command name for logging.
**		e -- the current envelope.
d2568 1
a2568 1
**		time to wait.
d2571 1
a2571 1
**		Slows down if we seem to be under attack.
d2574 3
a2576 6
static time_t
checksmtpattack(pcounter, maxcount, waitnow, cname, e)
	volatile int *pcounter;
	int maxcount;
	bool waitnow;
	char *cname;
d2579 17
a2595 1
	if (++(*pcounter) >= maxcount)
d2597 11
a2607 1
		time_t s;
d2609 7
a2615 1
		if (*pcounter == maxcount && LogLevel > 5)
d2617 2
a2618 3
			sm_syslog(LOG_INFO, e->e_id,
				  "%.100s: possible SMTP attack: command=%.40s, count=%d",
				  CurSmtpClient, cname, *pcounter);
d2620 1
a2620 7
		s = 1 << (*pcounter - maxcount);
		if (s >= MAXTIMEOUT)
			s = MAXTIMEOUT;
		/* sleep at least 1 second before returning */
		(void) sleep(*pcounter / maxcount);
		s -= *pcounter / maxcount;
		if (waitnow)
d2622 2
a2623 2
			(void) sleep(s);
			return(0);
a2624 1
		return(s);
a2625 16
	return((time_t) 0);
}
/*
**  SKIPWORD -- skip a fixed word.
**
**	Parameters:
**		p -- place to start looking.
**		w -- word to skip.
**
**	Returns:
**		p following w.
**		NULL on error.
**
**	Side Effects:
**		clobbers the p data area.
*/
d2627 60
a2686 7
static char *
skipword(p, w)
	register char *volatile p;
	char *w;
{
	register char *q;
	char *firstp = p;
d2688 3
a2690 4
	/* find beginning of word */
	while (isascii(*p) && isspace(*p))
		p++;
	q = p;
d2692 2
a2693 6
	/* find end of word */
	while (*p != '\0' && *p != ':' && !(isascii(*p) && isspace(*p)))
		p++;
	while (isascii(*p) && isspace(*p))
		*p++ = '\0';
	if (*p != ':')
d2695 3
a2697 4
	  syntax:
		usrerr("501 5.5.2 Syntax error in parameters scanning \"%s\"",
			shortenstring(firstp, MAXSHORTSTR));
		return NULL;
d2699 15
a2713 3
	*p++ = '\0';
	while (isascii(*p) && isspace(*p))
		p++;
d2715 8
a2722 2
	if (*p == '\0')
		goto syntax;
d2724 362
a3085 3
	/* see if the input word matches desired word */
	if (strcasecmp(q, w))
		goto syntax;
d3107 1
a3107 1
	if (strcasecmp(kp, "size") == 0)
d3114 1
a3114 1
		define(macid("{msg_size}", NULL), newstr(vp), e);
d3122 1
a3122 1
	else if (strcasecmp(kp, "body") == 0)
d3129 1
a3129 1
		else if (strcasecmp(vp, "8bitmime") == 0)
d3131 1
a3131 1
			SevenBitInput = FALSE;
d3133 1
a3133 1
		else if (strcasecmp(vp, "7bit") == 0)
d3135 1
a3135 1
			SevenBitInput = TRUE;
d3139 1
a3139 2
			usrerr("501 5.5.4 Unknown BODY type %s",
				vp);
d3142 1
a3142 1
		e->e_bodytype = newstr(vp);
d3144 1
a3144 1
	else if (strcasecmp(kp, "envid") == 0)
d3166 3
a3168 2
		e->e_envid = newstr(vp);
		define(macid("{dsn_envid}", NULL), newstr(vp), e);
d3170 1
a3170 1
	else if (strcasecmp(kp, "ret") == 0)
d3188 1
a3188 1
		if (strcasecmp(vp, "hdrs") == 0)
d3190 1
a3190 1
		else if (strcasecmp(vp, "full") != 0)
d3195 1
a3195 1
		define(macid("{dsn_ret}", NULL), newstr(vp), e);
d3197 2
a3198 2
# if SASL
	else if (strcasecmp(kp, "auth") == 0)
d3205 1
d3223 1
a3223 1
		(void) strlcpy(auth_param, vp, len);
d3232 1
a3232 1
		snprintf(pbuf, sizeof pbuf, "%s", xuntextify(auth_param));
d3236 1
a3236 1
		define(macid("{auth_author}", NULL), newstr(pbuf), e);
d3245 2
a3246 2
		SuprErrs = TRUE;
		QuickAbort = FALSE;
d3248 2
a3249 2
		     (rscheck("trust_auth", pbuf, NULL, e, TRUE, FALSE, 10,
			      NULL) != EX_OK || Errors > 0))
d3254 1
a3254 1
				dprintf("auth=\"%.100s\" not trusted user=\"%.100s\"\n",
d3257 1
d3259 1
a3259 1
			e->e_auth_param = newstr("<>");
d3264 3
a3266 2
				dprintf("auth=\"%.100s\" trusted\n", pbuf);
			e->e_auth_param = newstr(auth_param);
d3268 1
a3268 1
		sm_free(auth_param);
d3274 75
a3349 1
# endif /* SASL */
d3376 1
a3376 1
	if (strcasecmp(kp, "notify") == 0)
d3392 1
a3392 1
		define(macid("{dsn_notify}", NULL), newstr(vp), e);
d3394 1
a3394 1
		if (strcasecmp(vp, "never") == 0)
d3401 1
a3401 1
			if (strcasecmp(vp, "success") == 0)
d3403 1
a3403 1
			else if (strcasecmp(vp, "failure") == 0)
d3405 1
a3405 1
			else if (strcasecmp(vp, "delay") == 0)
d3415 1
a3415 1
	else if (strcasecmp(kp, "orcpt") == 0)
d3437 1
a3437 1
		a->q_orcpt = newstr(vp);
d3449 1
a3449 1
**		a -- the address to print
d3471 1
a3471 1
		(void) strlcpy(fmtbuf, "252", sizeof fmtbuf);
d3473 1
a3473 1
		(void) strlcpy(fmtbuf, "250", sizeof fmtbuf);
d3475 1
a3475 1
	(void) strlcpy(&fmtbuf[4], "2.1.5 ", sizeof fmtbuf - 4);
d3480 1
a3480 1
		     strcasecmp(a->q_mailer->m_addrtype, "rfc822") == 0) &&
d3482 1
a3482 1
			(void) strlcpy(&fmtbuf[OFFF], "<%s@@%s>",
d3485 1
a3485 1
			(void) strlcpy(&fmtbuf[OFFF], "<%s>",
d3493 1
a3493 1
		     strcasecmp(a->q_mailer->m_addrtype, "rfc822") == 0) &&
d3495 1
a3495 1
			(void) strlcpy(&fmtbuf[OFFF], "%s <%s@@%s>",
d3498 1
a3498 1
			(void) strlcpy(&fmtbuf[OFFF], "%s <%s>",
d3503 2
d3506 1
a3506 1
**  RUNINCHILD -- return twice -- once in the child, then in the parent again
d3509 2
a3510 1
**		label -- a string used in error messages
d3513 1
a3513 6
**		RIC_INCHILD in the child
**		RIC_INPARENT in the parent
**		RIC_TEMPFAIL tempfail condition
**
**	Side Effects:
**		none.
d3517 3
a3519 3
runinchild(label, e)
	char *label;
	register ENVELOPE *e;
d3521 1
a3521 1
	pid_t childpid;
d3523 5
a3527 1
	if (!OneXact)
d3529 5
a3533 72
		extern int NumQueues;

		/*
		**  advance state of PRNG
		**  this is necessary because otherwise all child processes
		**  will produce the same PRN sequence and hence the selection
		**  of a queue directory is not "really" random.
		*/
		if (NumQueues > 1)
			(void) get_random();

		/*
		**  Disable child process reaping, in case ETRN has preceded
		**  MAIL command, and then fork.
		*/

		(void) blocksignal(SIGCHLD);


		childpid = dofork();
		if (childpid < 0)
		{
			syserr("451 4.3.0 %s: cannot fork", label);
			(void) releasesignal(SIGCHLD);
			return RIC_INPARENT;
		}
		if (childpid > 0)
		{
			auto int st;

			/* parent -- wait for child to complete */
			sm_setproctitle(TRUE, e, "server %s child wait",
					CurSmtpClient);
			st = waitfor(childpid);
			if (st == -1)
				syserr("451 4.3.0 %s: lost child", label);
			else if (!WIFEXITED(st))
			{
				syserr("451 4.3.0 %s: died on signal %d",
				       label, st & 0177);
				return RIC_TEMPFAIL;
			}

			/* if exited on a QUIT command, complete the process */
			if (WEXITSTATUS(st) == EX_QUIT)
			{
				disconnect(1, e);
				finis(TRUE, ExitStat);
			}

			/* restore the child signal */
			(void) releasesignal(SIGCHLD);

			return RIC_INPARENT;
		}
		else
		{
			/* child */
			InChild = TRUE;
			QuickAbort = FALSE;

			/* Reset global flags */
			RestartRequest = NULL;
			ShutdownRequest = NULL;
			PendingSignal = 0;

			clearstats();
			clearenvelope(e, FALSE);
			assign_queueid(e);
			(void) setsignal(SIGCHLD, SIG_DFL);
			(void) releasesignal(SIGCHLD);
		}
d3535 1
a3535 28
	return RIC_INCHILD;
}

# if SASL

/*
**  SASLMECHS -- get list of possible AUTH mechanisms
**
**	Parameters:
**		conn -- SASL connection info
**		mechlist -- output parameter for list of mechanisms
**
**	Returns:
**		number of mechs
*/

static int
saslmechs(conn, mechlist)
	sasl_conn_t *conn;
	char **mechlist;
{
	int len, num, result;

	/* "user" is currently unused */
	result = sasl_listmech(conn, "user", /* XXX */
			       "", " ", "", mechlist,
			       (u_int *)&len, (u_int *)&num);
	if (result == SASL_OK && num > 0)
d3539 1
a3539 1
				  "SASL: available mech=%s, allowed mech=%s",
d3541 1
a3541 1
		*mechlist = intersect(AuthMechanisms, *mechlist);
d3544 1
a3544 7
	{
		if (LogLevel > 9)
			sm_syslog(LOG_WARNING, NOQID,
				  "SASL error: listmech=%d, num=%d",
				  result, num);
		num = 0;
	}
a3546 1

d3551 5
a3555 5
**		conntext -- unused
**		auth_identity -- authentication identity
**		requested_user -- authorization identity
**		user -- allowed user (output)
**		errstr -- possible error string (output)
d3574 1
d3576 1
a3576 40
# endif /* SASL */

# if STARTTLS
#  if !TLS_NO_RSA
RSA *rsa_tmp;	/* temporary RSA key */
static RSA * tmp_rsa_key __P((SSL *, int, int));
#  endif /* !TLS_NO_RSA */

# if !NO_DH
static DH *get_dh512 __P((void));

static unsigned char dh512_p[] =
{
	0xDA,0x58,0x3C,0x16,0xD9,0x85,0x22,0x89,0xD0,0xE4,0xAF,0x75,
	0x6F,0x4C,0xCA,0x92,0xDD,0x4B,0xE5,0x33,0xB8,0x04,0xFB,0x0F,
	0xED,0x94,0xEF,0x9C,0x8A,0x44,0x03,0xED,0x57,0x46,0x50,0xD3,
	0x69,0x99,0xDB,0x29,0xD7,0x76,0x27,0x6B,0xA2,0xD3,0xD4,0x12,
	0xE2,0x18,0xF4,0xDD,0x1E,0x08,0x4C,0xF6,0xD8,0x00,0x3E,0x7C,
	0x47,0x74,0xE8,0x33
};
static unsigned char dh512_g[] =
{
	0x02
};

static DH *
get_dh512()
{
	DH *dh = NULL;

	if ((dh = DH_new()) == NULL)
		return(NULL);
	dh->p = BN_bin2bn(dh512_p, sizeof(dh512_p), NULL);
	dh->g = BN_bin2bn(dh512_g, sizeof(dh512_g), NULL);
	if ((dh->p == NULL) || (dh->g == NULL))
		return(NULL);
	return(dh);
}
# endif /* !NO_DH */

d3578 1
a3578 319
**  TLS_RAND_INIT -- initialize STARTTLS random generator
**
**	Parameters:
**		randfile -- name of file with random data
**		logl -- loglevel
**
**	Returns:
**		success/failure
**
**	Side Effects:
**		initializes PRNG for tls library.
*/

#define MIN_RAND_BYTES	16	/* 128 bits */

bool
tls_rand_init(randfile, logl)
	char *randfile;
	int logl;
{
# ifndef HASURANDOMDEV
	/* not required if /dev/urandom exists, OpenSSL does it internally */
#define RF_OK		0	/* randfile OK */
#define RF_MISS		1	/* randfile == NULL || *randfile == '\0' */
#define RF_UNKNOWN	2	/* unknown prefix for randfile */

#define RI_NONE		0	/* no init yet */
#define RI_SUCCESS	1	/* init was successful */
#define RI_FAIL		2	/* init failed */

	bool ok;
	int randdef;
	static int done = RI_NONE;

	/*
	**  initialize PRNG
	*/

	/* did we try this before? if yes: return old value */
	if (done != RI_NONE)
		return done == RI_SUCCESS;

	/* set default values */
	ok = FALSE;
	done = RI_FAIL;
	randdef = (randfile == NULL || *randfile == '\0') ? RF_MISS : RF_OK;
#    if EGD
	if (randdef == RF_OK && strncasecmp(randfile, "egd:", 4) == 0)
	{
		randfile += 4;
		if (RAND_egd(randfile) < 0)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: RAND_egd(%s) failed: random number generator not seeded",
				   randfile);
		}
		else
			ok = TRUE;
	}
	else
#    endif /* EGD */
	if (randdef == RF_OK && strncasecmp(randfile, "file:", 5) == 0)
	{
		int fd;
		long sff;
		struct stat st;

		randfile += 5;
		sff = SFF_SAFEDIRPATH | SFF_NOWLINK
		      | SFF_NOGWFILES | SFF_NOWWFILES
		      | SFF_NOGRFILES | SFF_NOWRFILES
		      | SFF_MUSTOWN | SFF_ROOTOK | SFF_OPENASROOT;
		if ((fd = safeopen(randfile, O_RDONLY, 0, sff)) >= 0)
		{
			if (fstat(fd, &st) < 0)
			{
				if (LogLevel > logl)
					sm_syslog(LOG_ERR, NOQID,
						  "TLS: can't fstat(%s)",
						  randfile);
			}
			else
			{
				bool use, problem;

				use = TRUE;
				problem = FALSE;
				if (st.st_mtime + 600 < curtime())
				{
					use = bitnset(DBS_INSUFFICIENTENTROPY,
						      DontBlameSendmail);
					problem = TRUE;
					if (LogLevel > logl)
						sm_syslog(LOG_ERR, NOQID,
							  "TLS: RandFile %s too old: %s",
							  randfile,
							  use ? "unsafe" :
								"unusable");
				}
				if (use && st.st_size < MIN_RAND_BYTES)
				{
					use = bitnset(DBS_INSUFFICIENTENTROPY,
						      DontBlameSendmail);
					problem = TRUE;
					if (LogLevel > logl)
						sm_syslog(LOG_ERR, NOQID,
							  "TLS: size(%s) < %d: %s",
							  randfile,
							  MIN_RAND_BYTES,
							  use ? "unsafe" :
								"unusable");
				}
				if (use)
					ok = RAND_load_file(randfile, -1) >=
					     MIN_RAND_BYTES;
				if (use && !ok)
				{
					if (LogLevel > logl)
						sm_syslog(LOG_WARNING,
							  NOQID,
							  "TLS: RAND_load_file(%s) failed: random number generator not seeded",
							  randfile);
				}
				if (problem)
					ok = FALSE;
			}
			if (ok || bitnset(DBS_INSUFFICIENTENTROPY,
					  DontBlameSendmail))
			{
				/* add this even if fstat() failed */
				RAND_seed((void *) &st, sizeof st);
			}
			(void) close(fd);
		}
		else
		{
			if (LogLevel > logl)
				sm_syslog(LOG_WARNING, NOQID,
					  "TLS: Warning: safeopen(%s) failed",
					  randfile);
		}
	}
	else if (randdef == RF_OK)
	{
		if (LogLevel > logl)
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: Error: no proper random file definition %s",
				  randfile);
		randdef = RF_UNKNOWN;
	}
	if (randdef == RF_MISS)
	{
		if (LogLevel > logl)
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: Error: missing random file definition");
	}
	if (!ok && bitnset(DBS_INSUFFICIENTENTROPY, DontBlameSendmail))
	{
		int i;
		long r;
		unsigned char buf[MIN_RAND_BYTES];

		/* assert((MIN_RAND_BYTES % sizeof(long)) == 0); */
		for (i = 0; i <= sizeof(buf) - sizeof(long); i += sizeof(long))
		{
			r = get_random();
			(void) memcpy(buf + i, (void *) &r, sizeof(long));
		}
		RAND_seed(buf, sizeof buf);
		if (LogLevel > logl)
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: Warning: random number generator not properly seeded");
		ok = TRUE;
	}
	done = ok ? RI_SUCCESS : RI_FAIL;
	return ok;
# else /* !HASURANDOMDEV */
	return TRUE;
# endif /* !HASURANDOMDEV */
}

/*
**  status in initialization
**  these flags keep track of the status of the initialization
**  i.e., whether a file exists (_EX) and whether it can be used (_OK)
**  [due to permissions]
*/
#define TLS_S_NONE	0x00000000	/* none yet  */
#define TLS_S_CERT_EX	0x00000001	/* CERT file exists */
#define TLS_S_CERT_OK	0x00000002	/* CERT file is ok */
#define TLS_S_KEY_EX	0x00000004	/* KEY file exists */
#define TLS_S_KEY_OK	0x00000008	/* KEY file is ok */
#define TLS_S_CERTP_EX	0x00000010	/* CA CERT PATH exists */
#define TLS_S_CERTP_OK	0x00000020	/* CA CERT PATH is ok */
#define TLS_S_CERTF_EX	0x00000040	/* CA CERT FILE exists */
#define TLS_S_CERTF_OK	0x00000080	/* CA CERT FILE is ok */

# if _FFR_TLS_1
#define TLS_S_CERT2_EX	0x00001000	/* 2nd CERT file exists */
#define TLS_S_CERT2_OK	0x00002000	/* 2nd CERT file is ok */
#define TLS_S_KEY2_EX	0x00004000	/* 2nd KEY file exists */
#define TLS_S_KEY2_OK	0x00008000	/* 2nd KEY file is ok */
# endif /* _FFR_TLS_1 */

#define TLS_S_DH_OK	0x00200000	/* DH cert is ok */
#define TLS_S_DHPAR_EX	0x00400000	/* DH param file exists */
#define TLS_S_DHPAR_OK	0x00800000	/* DH param file is ok to use */

/*
**  TLS_OK_F -- can var be an absolute filename?
**
**	Parameters:
**		var -- filename
**		fn -- what is the filename used for?
**
**	Returns:
**		ok?
*/

static bool
tls_ok_f(var, fn)
	char *var;
	char *fn;
{
	/* must be absolute pathname */
	if (var != NULL && *var == '/')
		return TRUE;
	if (LogLevel > 12)
		sm_syslog(LOG_WARNING, NOQID, "TLS: file %s missing", fn);
	return FALSE;
}

/*
**  TLS_SAFE_F -- is a file safe to use?
**
**	Parameters:
**		var -- filename
**		sff -- flags for safefile()
**
**	Returns:
**		ok?
*/

static bool
tls_safe_f(var, sff)
	char *var;
	long sff;
{
	int ret;

	if ((ret = safefile(var, RunAsUid, RunAsGid, RunAsUserName, sff,
			    S_IRUSR, NULL)) == 0)
		return TRUE;
	if (LogLevel > 7)
		sm_syslog(LOG_WARNING, NOQID, "TLS: file %s unsafe: %s",
			  var, errstring(ret));
	return FALSE;
}

/*
**  TLS_OK_F -- macro to simplify calls to tls_ok_f
**
**	Parameters:
**		var -- filename
**		fn -- what is the filename used for?
**		req -- is the file required?
**		st -- status bit to set if ok
**
**	Side Effects:
**		uses r, ok; may change ok and status.
**
*/

#define TLS_OK_F(var, fn, req, st) if (ok) \
	{ \
		r = tls_ok_f(var, fn); \
		if (r) \
			status |= st; \
		else if (req) \
			ok = FALSE; \
	}

/*
**  TLS_UNR -- macro to return whether a file should be unreadable
**
**	Parameters:
**		bit -- flag to test
**		req -- flags
**
**	Returns:
**		0/SFF_NORFILES
*/
#define TLS_UNR(bit, req)	(bitset(bit, req) ? SFF_NORFILES : 0)

/*
**  TLS_SAFE_F -- macro to simplify calls to tls_safe_f
**
**	Parameters:
**		var -- filename
**		sff -- flags for safefile()
**		req -- is the file required?
**		ex -- does the file exist?
**		st -- status bit to set if ok
**
**	Side Effects:
**		uses r, ok, ex; may change ok and status.
**
*/

#define TLS_SAFE_F(var, sff, req, ex, st) if (ex && ok) \
	{ \
		r = tls_safe_f(var, sff); \
		if (r) \
			status |= st;	\
		else if (req) \
			ok = FALSE;	\
	}
/*
**  INIT_TLS_LIBRARY -- calls functions which setup TLS library for global use
d3581 1
a3581 1
**		none.
d3587 2
a3588 1
**		Sets tls_ok_srv static, even when called from main()
d3592 2
a3593 1
init_tls_library()
d3595 2
a3596 14
	/*
	**  basic TLS initialization
	**  ignore result for now
	*/

	SSL_library_init();
	SSL_load_error_strings();
# if 0
	/* this is currently a macro for SSL_library_init */
	SSLeay_add_ssl_algorithms();
# endif /* 0 */

	/* initialize PRNG */
	tls_ok_srv = tls_rand_init(RandFile, 7);
d3598 3
d3603 1
d3605 1
a3605 1
**  INITTLS -- initialize TLS
d3608 34
a3641 12
**		ctx -- pointer to context
**		req -- requirements for initialization (see sendmail.h)
**		srv -- server side?
**		certfile -- filename of certificate
**		keyfile -- filename of private key
**		cacertpath -- path to CAs
**		cacertfile -- file with CA
**		dhparam -- parameters for DH
**
**	Returns:
**		succeeded?
*/
d3643 5
a3647 6
bool
inittls(ctx, req, srv, certfile, keyfile, cacertpath, cacertfile, dhparam)
	SSL_CTX **ctx;
	u_long req;
	bool srv;
	char *certfile, *keyfile, *cacertpath, *cacertfile, *dhparam;
d3649 13
a3661 46
# if !NO_DH
	static DH *dh = NULL;
# endif /* !NO_DH */
	int r;
	bool ok;
	long sff, status;
	char *who;
# if _FFR_TLS_1
	char *cf2, *kf2;
# endif /* _FFR_TLS_1 */

	status = TLS_S_NONE;
	who = srv ? "srv" : "clt";
	if (ctx == NULL)
		syserr("TLS: %s:inittls: ctx == NULL", who);

	/* already initialized? (we could re-init...) */
	if (*ctx != NULL)
		return TRUE;

	/* PRNG seeded? */
	if (!tls_rand_init(RandFile, 10))
		return FALSE;

	/* let's start with the assumption it will work */
	ok = TRUE;

# if _FFR_TLS_1
	/*
	**  look for a second filename: it must be separated by a ','
	**  no blanks allowed (they won't be skipped).
	**  we change a global variable here! this change will be undone
	**  before return from the function but only if it returns TRUE.
	**  this isn't a problem since in a failure case this function
	**  won't be called again with the same (overwritten) values.
	**  otherwise each return must be replaced with a goto endinittls.
	*/
	cf2 = NULL;
	kf2 = NULL;
	if (certfile != NULL && (cf2 = strchr(certfile, ',')) != NULL)
	{
		*cf2++ = '\0';
		if (keyfile != NULL && (kf2 = strchr(keyfile, ',')) != NULL)
			*kf2++ = '\0';
	}
# endif /* _FFR_TLS_1 */
d3664 5
a3668 3
	**  what do we require from the client?
	**  must it have CERTs?
	**  introduce an option and decide based on that
d3671 1
a3671 16
	TLS_OK_F(certfile, "CertFile", bitset(TLS_I_CERT_EX, req),
		 TLS_S_CERT_EX);
	TLS_OK_F(keyfile, "KeyFile", bitset(TLS_I_KEY_EX, req),
		 TLS_S_KEY_EX);
	TLS_OK_F(cacertpath, "CACERTPath", bitset(TLS_I_CERTP_EX, req),
		 TLS_S_CERTP_EX);
	TLS_OK_F(cacertfile, "CACERTFile", bitset(TLS_I_CERTF_EX, req),
		 TLS_S_CERTF_EX);

# if _FFR_TLS_1
	if (cf2 != NULL)
	{
		TLS_OK_F(cf2, "CertFile", bitset(TLS_I_CERT_EX, req),
			 TLS_S_CERT2_EX);
	}
	if (kf2 != NULL)
d3673 3
a3675 16
		TLS_OK_F(kf2, "KeyFile", bitset(TLS_I_KEY_EX, req),
			 TLS_S_KEY2_EX);
	}
# endif /* _FFR_TLS_1 */

	/*
	**  valid values for dhparam are (only the first char is checked)
	**  none	no parameters: don't use DH
	**  512		generate 512 bit parameters (fixed)
	**  1024	generate 1024 bit parameters
	**  /file/name	read parameters from /file/name
	**  default is: 1024 for server, 512 for client (OK? XXX)
	*/
	if (bitset(TLS_I_TRY_DH, req))
	{
		if (dhparam != NULL)
d3677 1
a3677 7
			char c = *dhparam;

			if (c == '1')
				req |= TLS_I_DH1024;
			else if (c == '5')
				req |= TLS_I_DH512;
			else if (c != 'n' && c != 'N' && c != '/')
d3679 5
a3683 240
				if (LogLevel > 12)
					sm_syslog(LOG_WARNING, NOQID,
						  "TLS: error: illegal value '%s' for DHParam",
						  dhparam);
				dhparam = NULL;
			}
		}
		if (dhparam == NULL)
			dhparam = srv ? "1" : "5";
		else if (*dhparam == '/')
		{
			TLS_OK_F(dhparam, "DHParameters",
				 bitset(TLS_I_DHPAR_EX, req),
				 TLS_S_DHPAR_EX);
		}
	}
	if (!ok)
		return ok;

	/* certfile etc. must be "safe". */
	sff = SFF_REGONLY | SFF_SAFEDIRPATH | SFF_NOWLINK
	     | SFF_NOGWFILES | SFF_NOWWFILES
	     | SFF_MUSTOWN | SFF_ROOTOK | SFF_OPENASROOT;
	if (DontLockReadFiles)
		sff |= SFF_NOLOCK;

	TLS_SAFE_F(certfile, sff | TLS_UNR(TLS_I_CERT_UNR, req),
		   bitset(TLS_I_CERT_EX, req),
		   bitset(TLS_S_CERT_EX, status), TLS_S_CERT_OK);
	TLS_SAFE_F(keyfile, sff | TLS_UNR(TLS_I_KEY_UNR, req),
		   bitset(TLS_I_KEY_EX, req),
		   bitset(TLS_S_KEY_EX, status), TLS_S_KEY_OK);
	TLS_SAFE_F(cacertfile, sff | TLS_UNR(TLS_I_CERTF_UNR, req),
		   bitset(TLS_I_CERTF_EX, req),
		   bitset(TLS_S_CERTF_EX, status), TLS_S_CERTF_OK);
	TLS_SAFE_F(dhparam, sff | TLS_UNR(TLS_I_DHPAR_UNR, req),
		   bitset(TLS_I_DHPAR_EX, req),
		   bitset(TLS_S_DHPAR_EX, status), TLS_S_DHPAR_OK);
	if (!ok)
		return ok;
# if _FFR_TLS_1
	if (cf2 != NULL)
	{
		TLS_SAFE_F(cf2, sff | TLS_UNR(TLS_I_CERT_UNR, req),
			   bitset(TLS_I_CERT_EX, req),
			   bitset(TLS_S_CERT2_EX, status), TLS_S_CERT2_OK);
	}
	if (kf2 != NULL)
	{
		TLS_SAFE_F(kf2, sff | TLS_UNR(TLS_I_KEY_UNR, req),
			   bitset(TLS_I_KEY_EX, req),
			   bitset(TLS_S_KEY2_EX, status), TLS_S_KEY2_OK);
	}
# endif /* _FFR_TLS_1 */

	/* create a method and a new context */
	if (srv)
	{
		if ((*ctx = SSL_CTX_new(SSLv23_server_method())) == NULL)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					  "TLS: error: SSL_CTX_new(SSLv23_server_method()) failed");
			if (LogLevel > 9)
				tlslogerr();
			return FALSE;
		}
	}
	else
	{
		if ((*ctx = SSL_CTX_new(SSLv23_client_method())) == NULL)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					  "TLS: error: SSL_CTX_new(SSLv23_client_method()) failed");
			if (LogLevel > 9)
				tlslogerr();
			return FALSE;
		}
	}

#  if TLS_NO_RSA
	/* turn off backward compatibility, required for no-rsa */
	SSL_CTX_set_options(*ctx, SSL_OP_NO_SSLv2);
#  endif /* TLS_NO_RSA */


#  if !TLS_NO_RSA
	/*
	**  Create a temporary RSA key
	**  XXX  Maybe we shouldn't create this always (even though it
	**  is only at startup).
	**  It is a time-consuming operation and it is not always necessary.
	**  maybe we should do it only on demand...
	*/
	if (bitset(TLS_I_RSA_TMP, req) &&
	    (rsa_tmp = RSA_generate_key(RSA_KEYLENGTH, RSA_F4, NULL,
					NULL)) == NULL
	   )
	{
		if (LogLevel > 7)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: error: %s: RSA_generate_key failed",
				  who);
			if (LogLevel > 9)
				tlslogerr();
		}
		return FALSE;
	}
#  endif /* !TLS_NO_RSA */

	/*
	**  load private key
	**  XXX change this for DSA-only version
	*/
	if (bitset(TLS_S_KEY_OK, status) &&
	    SSL_CTX_use_PrivateKey_file(*ctx, keyfile,
					 SSL_FILETYPE_PEM) <= 0)
	{
		if (LogLevel > 7)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: error: %s: SSL_CTX_use_PrivateKey_file(%s) failed",
				  who, keyfile);
			if (LogLevel > 9)
				tlslogerr();
		}
		if (bitset(TLS_I_USE_KEY, req))
			return FALSE;
	}

	/* get the certificate file */
	if (bitset(TLS_S_CERT_OK, status) &&
	    SSL_CTX_use_certificate_file(*ctx, certfile,
					 SSL_FILETYPE_PEM) <= 0)
	{
		if (LogLevel > 7)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: error: %s: SSL_CTX_use_certificate_file(%s) failed",
				  who, certfile);
			if (LogLevel > 9)
				tlslogerr();
		}
		if (bitset(TLS_I_USE_CERT, req))
			return FALSE;
	}

	/* check the private key */
	if (bitset(TLS_S_KEY_OK, status) &&
	    (r = SSL_CTX_check_private_key(*ctx)) <= 0)
	{
		/* Private key does not match the certificate public key */
		if (LogLevel > 5)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: error: %s: SSL_CTX_check_private_key failed(%s): %d",
				  who, keyfile, r);
			if (LogLevel > 9)
				tlslogerr();
		}
		if (bitset(TLS_I_USE_KEY, req))
			return FALSE;
	}

# if _FFR_TLS_1
	/* XXX this code is pretty much duplicated from above! */

	/* load private key */
	if (bitset(TLS_S_KEY2_OK, status) &&
	    SSL_CTX_use_PrivateKey_file(*ctx, kf2, SSL_FILETYPE_PEM) <= 0)
	{
		if (LogLevel > 7)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: error: %s: SSL_CTX_use_PrivateKey_file(%s) failed",
				  who, kf2);
			if (LogLevel > 9)
				tlslogerr();
		}
	}

	/* get the certificate file */
	if (bitset(TLS_S_CERT2_OK, status) &&
	    SSL_CTX_use_certificate_file(*ctx, cf2, SSL_FILETYPE_PEM) <= 0)
	{
		if (LogLevel > 7)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: error: %s: SSL_CTX_use_certificate_file(%s) failed",
				  who, cf2);
			if (LogLevel > 9)
				tlslogerr();
		}
	}

	/* we should also check the private key: */
	if (bitset(TLS_S_KEY2_OK, status) &&
	    (r = SSL_CTX_check_private_key(*ctx)) <= 0)
	{
		/* Private key does not match the certificate public key */
		if (LogLevel > 5)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: error: %s: SSL_CTX_check_private_key 2 failed: %d",
				  who, r);
			if (LogLevel > 9)
				tlslogerr();
		}
	}
# endif /* _FFR_TLS_1 */

	/* SSL_CTX_set_quiet_shutdown(*ctx, 1); violation of standard? */
	SSL_CTX_set_options(*ctx, SSL_OP_ALL);	/* XXX bug compatibility? */

# if !NO_DH
	/* Diffie-Hellman initialization */
	if (bitset(TLS_I_TRY_DH, req))
	{
		if (bitset(TLS_S_DHPAR_OK, status))
		{
			BIO *bio;

			if ((bio = BIO_new_file(dhparam, "r")) != NULL)
			{
				dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);
				BIO_free(bio);
				if (dh == NULL && LogLevel > 7)
				{
					u_long err;

					err = ERR_get_error();
					sm_syslog(LOG_WARNING, NOQID,
						  "TLS: error: %s: cannot read DH parameters(%s): %s",
						  who, dhparam,
						  ERR_error_string(err, NULL));
					if (LogLevel > 9)
						tlslogerr();
				}
d3685 1
a3685 1
			else
d3687 2
a3688 8
				if (LogLevel > 5)
				{
					sm_syslog(LOG_WARNING, NOQID,
						  "TLS: error: %s: BIO_new_file(%s) failed",
						  who, dhparam);
					if (LogLevel > 9)
						tlslogerr();
				}
d3690 1
a3690 18
		}
		if (dh == NULL && bitset(TLS_I_DH1024, req))
		{
			DSA *dsa;

			/* this takes a while! (7-130s on a 450MHz AMD K6-2) */
			dsa = DSA_generate_parameters(1024, NULL, 0, NULL,
						      NULL, 0, NULL);
			dh = DSA_dup_DH(dsa);
			DSA_free(dsa);
		}
		else
		if (dh == NULL && bitset(TLS_I_DH512, req))
			dh = get_dh512();

		if (dh == NULL)
		{
			if (LogLevel > 9)
d3692 2
a3693 7
				u_long err;

				err = ERR_get_error();
				sm_syslog(LOG_WARNING, NOQID,
					  "TLS: error: %s: cannot read or set DH parameters(%s): %s",
					  who, dhparam,
					  ERR_error_string(err, NULL));
d3695 1
a3695 367
			if (bitset(TLS_I_REQ_DH, req))
				return FALSE;
		}
		else
		{
			SSL_CTX_set_tmp_dh(*ctx, dh);

			/* important to avoid small subgroup attacks */
			SSL_CTX_set_options(*ctx, SSL_OP_SINGLE_DH_USE);
			if (LogLevel > 12)
				sm_syslog(LOG_INFO, NOQID,
					  "TLS: %s: Diffie-Hellman init, key=%d bit (%c)",
					  who, 8 * DH_size(dh), *dhparam);
			DH_free(dh);
		}
	}
# endif /* !NO_DH */


	/* XXX do we need this cache here? */
	if (bitset(TLS_I_CACHE, req))
		SSL_CTX_sess_set_cache_size(*ctx, 128);
	/* timeout? SSL_CTX_set_timeout(*ctx, TimeOut...); */

	/* load certificate locations and default CA paths */
	if (bitset(TLS_S_CERTP_EX, status) && bitset(TLS_S_CERTF_EX, status))
	{
		if ((r = SSL_CTX_load_verify_locations(*ctx, cacertfile,
						       cacertpath)) == 1)
		{
#  if !TLS_NO_RSA
			if (bitset(TLS_I_RSA_TMP, req))
				SSL_CTX_set_tmp_rsa_callback(*ctx, tmp_rsa_key);
#  endif /* !TLS_NO_RSA */

			/* ask to verify the peer */
			SSL_CTX_set_verify(*ctx, SSL_VERIFY_PEER, NULL);

			/* install verify callback */
			SSL_CTX_set_cert_verify_callback(*ctx, tls_verify_cb,
							 NULL);
			SSL_CTX_set_client_CA_list(*ctx,
				SSL_load_client_CA_file(cacertfile));
		}
		else
		{
			/*
			**  can't load CA data; do we care?
			**  the data is necessary to authenticate the client,
			**  which in turn would be necessary
			**  if we want to allow relaying based on it.
			*/
			if (LogLevel > 5)
			{
				sm_syslog(LOG_WARNING, NOQID,
					  "TLS: error: %s: %d load verify locs %s, %s",
					  who, r, cacertpath, cacertfile);
				if (LogLevel > 9)
					tlslogerr();
			}
			if (bitset(TLS_I_VRFY_LOC, req))
				return FALSE;
		}
	}

	/* XXX: make this dependent on an option? */
	if (tTd(96, 9))
		SSL_CTX_set_info_callback(*ctx, apps_ssl_info_cb);

#  if _FFR_TLS_1
	/*
	**  XXX install our own cipher list: option?
	*/
	if (CipherList != NULL && *CipherList != '\0')
	{
		if (SSL_CTX_set_cipher_list(*ctx, CipherList) <= 0)
		{
			if (LogLevel > 7)
			{
				sm_syslog(LOG_WARNING, NOQID,
					  "TLS: error: %s: SSL_CTX_set_cipher_list(%s) failed, list ignored",
					  who, CipherList);

				if (LogLevel > 9)
					tlslogerr();
			}
			/* failure if setting to this list is required? */
		}
	}
#  endif /* _FFR_TLS_1 */
	if (LogLevel > 12)
		sm_syslog(LOG_INFO, NOQID, "TLS: init(%s)=%d", who, ok);

# if _FFR_TLS_1
#  if 0
	/*
	**  this label is required if we want to have a "clean" exit
	**  see the comments above at the initialization of cf2
	*/
    endinittls:
#  endif /* 0 */

	/* undo damage to global variables */
	if (cf2 != NULL)
		*--cf2 = ',';
	if (kf2 != NULL)
		*--kf2 = ',';
# endif /* _FFR_TLS_1 */

	return ok;
}
/*
**  INITSRVTLS -- initialize server side TLS
**
**	Parameters:
**		none.
**
**	Returns:
**		succeeded?
**
**	Side Effects:
**		sets tls_ok_srv static, even when called from main()
*/

bool
initsrvtls()
{

	tls_ok_srv = inittls(&srv_ctx, TLS_I_SRV, TRUE, SrvCERTfile,
			     Srvkeyfile, CACERTpath, CACERTfile, DHParams);
	return tls_ok_srv;
}
/*
**  TLS_GET_INFO -- get information about TLS connection
**
**	Parameters:
**		ssl -- SSL connection structure
**		e -- current envelope
**		srv -- server or client
**		host -- hostname of other side
**		log -- log connection information?
**
**	Returns:
**		result of authentication.
**
**	Side Effects:
**		sets ${cipher}, ${tls_version}, ${verify}, ${cipher_bits},
**		${cert}
*/

int
tls_get_info(ssl, e, srv, host, log)
	SSL *ssl;
	ENVELOPE *e;
	bool srv;
	char *host;
	bool log;
{
	SSL_CIPHER *c;
	int b, r;
	char *s;
	char bitstr[16];
	X509 *cert;

	c = SSL_get_current_cipher(ssl);
	define(macid("{cipher}", NULL), newstr(SSL_CIPHER_get_name(c)), e);
	b = SSL_CIPHER_get_bits(c, &r);
	(void) snprintf(bitstr, sizeof bitstr, "%d", b);
	define(macid("{cipher_bits}", NULL), newstr(bitstr), e);
# if _FFR_TLS_1
	(void) snprintf(bitstr, sizeof bitstr, "%d", r);
	define(macid("{alg_bits}", NULL), newstr(bitstr), e);
# endif /* _FFR_TLS_1 */
	s = SSL_CIPHER_get_version(c);
	if (s == NULL)
		s = "UNKNOWN";
	define(macid("{tls_version}", NULL), newstr(s), e);

	cert = SSL_get_peer_certificate(ssl);
	if (log && LogLevel >= 14)
		sm_syslog(LOG_INFO, e->e_id,
			  "TLS: get_verify in %s: %ld get_peer: 0x%lx",
			  srv ? "srv" : "clt",
			  SSL_get_verify_result(ssl), (u_long) cert);
	if (cert != NULL)
	{
		char buf[MAXNAME];

		X509_NAME_oneline(X509_get_subject_name(cert),
				  buf, sizeof buf);
		define(macid("{cert_subject}", NULL),
			       newstr(xtextify(buf, "<>\")")), e);
		X509_NAME_oneline(X509_get_issuer_name(cert),
				  buf, sizeof buf);
		define(macid("{cert_issuer}", NULL),
		       newstr(xtextify(buf, "<>\")")), e);
# if _FFR_TLS_1
		X509_NAME_get_text_by_NID(X509_get_subject_name(cert),
					  NID_commonName, buf, sizeof buf);
		define(macid("{cn_subject}", NULL),
		       newstr(xtextify(buf, "<>\")")), e);
		X509_NAME_get_text_by_NID(X509_get_issuer_name(cert),
					  NID_commonName, buf, sizeof buf);
		define(macid("{cn_issuer}", NULL),
		       newstr(xtextify(buf, "<>\")")), e);
# endif /* _FFR_TLS_1 */
	}
	else
	{
		define(macid("{cert_subject}", NULL), "", e);
		define(macid("{cert_issuer}", NULL), "", e);
# if _FFR_TLS_1
		define(macid("{cn_subject}", NULL), "", e);
		define(macid("{cn_issuer}", NULL), "", e);
# endif /* _FFR_TLS_1 */
	}
	switch(SSL_get_verify_result(ssl))
	{
	  case X509_V_OK:
		if (cert != NULL)
		{
			s = "OK";
			r = TLS_AUTH_OK;
		}
		else
		{
			s = "NO";
			r = TLS_AUTH_NO;
		}
		break;
	  default:
		s = "FAIL";
		r = TLS_AUTH_FAIL;
		break;
	}
	define(macid("{verify}", NULL), newstr(s), e);
	if (cert != NULL)
		X509_free(cert);

	/* do some logging */
	if (log && LogLevel > 9)
	{
		char *vers, *s1, *s2, *bits;

		vers = macvalue(macid("{tls_version}", NULL), e);
		bits = macvalue(macid("{cipher_bits}", NULL), e);
		s1 = macvalue(macid("{verify}", NULL), e);
		s2 = macvalue(macid("{cipher}", NULL), e);
		sm_syslog(LOG_INFO, NOQID,
			  "TLS: connection %s %.64s, version=%.16s, verify=%.16s, cipher=%.64s, bits=%.6s",
			  srv ? "from" : "to",
			  host == NULL ? "none" : host,
			  vers == NULL ? "none" : vers,
			  s1 == NULL ? "none" : s1,
			  s2 == NULL ? "none" : s2,
			  bits == NULL ? "0" : bits);
		if (LogLevel > 11)
		{
			/*
			**  maybe run xuntextify on the strings?
			**  that is easier to read but makes it maybe a bit
			**  more complicated to figure out the right values
			**  for the access map...
			*/
			s1 = macvalue(macid("{cert_subject}", NULL), e);
			s2 = macvalue(macid("{cert_issuer}", NULL), e);
			sm_syslog(LOG_INFO, NOQID,
				  "TLS: %s cert subject:%.128s, cert issuer=%.128s",
				  srv ? "client" : "server",
				  s1 == NULL ? "none" : s1,
				  s2 == NULL ? "none" : s2);
		}
	}

	return r;
}

# if !TLS_NO_RSA
/*
**  TMP_RSA_KEY -- return temporary RSA key
**
**	Parameters:
**		s -- SSL connection structure
**		export --
**		keylength --
**
**	Returns:
**		temporary RSA key.
*/

/* ARGUSED0 */
static RSA *
tmp_rsa_key(s, export, keylength)
	SSL *s;
	int export;
	int keylength;
{
	return rsa_tmp;
}
# endif /* !TLS_NO_RSA */
/*
**  APPS_SSL_INFO_CB -- info callback for TLS connections
**
**	Parameters:
**		s -- SSL connection structure
**		where --
**		ret --
**
**	Returns:
**		none.
*/

void
apps_ssl_info_cb(s, where, ret)
	SSL *s;
	int where;
	int ret;
{
	char *str;
	int w;
	BIO *bio_err = NULL;

	if (LogLevel > 14)
		sm_syslog(LOG_INFO, NOQID,
			  "info_callback where 0x%x ret %d", where, ret);

	w = where & ~SSL_ST_MASK;
	if (bio_err == NULL)
		bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);

	if (w & SSL_ST_CONNECT)
		str = "SSL_connect";
	else if (w & SSL_ST_ACCEPT)
		str = "SSL_accept";
	else
		str = "undefined";

	if (where & SSL_CB_LOOP)
	{
		if (LogLevel > 12)
			sm_syslog(LOG_NOTICE, NOQID,
			"%s:%s\n", str, SSL_state_string_long(s));
	}
	else if (where & SSL_CB_ALERT)
	{
		str = (where & SSL_CB_READ) ? "read" : "write";
		if (LogLevel > 12)
			sm_syslog(LOG_NOTICE, NOQID,
		"SSL3 alert %s:%s:%s\n",
			   str, SSL_alert_type_string_long(ret),
			   SSL_alert_desc_string_long(ret));
	}
	else if (where & SSL_CB_EXIT)
	{
		if (ret == 0)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					"%s:failed in %s\n",
					str, SSL_state_string_long(s));
		}
		else if (ret < 0)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					"%s:error in %s\n",
					str, SSL_state_string_long(s));
d3698 1
a3698 100
}
/*
**  TLS_VERIFY_LOG -- log verify error for TLS certificates
**
**	Parameters:
**		ok -- verify ok?
**		ctx -- x509 context
**
**	Returns:
**		0 -- fatal error
**		1 -- ok
*/

static int
tls_verify_log(ok, ctx)
	int ok;
	X509_STORE_CTX *ctx;
{
	SSL *ssl;
	X509 *cert;
	int reason, depth;
	char buf[512];

	cert = X509_STORE_CTX_get_current_cert(ctx);
	reason = X509_STORE_CTX_get_error(ctx);
	depth = X509_STORE_CTX_get_error_depth(ctx);
	ssl = (SSL *)X509_STORE_CTX_get_ex_data(ctx,
			SSL_get_ex_data_X509_STORE_CTX_idx());

	if (ssl == NULL)
	{
		/* internal error */
		sm_syslog(LOG_ERR, NOQID,
			  "TLS: internal error: tls_verify_cb: ssl == NULL");
		return 0;
	}

	X509_NAME_oneline(X509_get_subject_name(cert), buf, sizeof buf);
	sm_syslog(LOG_INFO, NOQID,
		  "TLS cert verify: depth=%d %s, state=%d, reason=%s\n",
		  depth, buf, ok, X509_verify_cert_error_string(reason));
	return 1;
}

/*
**  TLS_VERIFY_CB -- verify callback for TLS certificates
**
**	Parameters:
**		ctx -- x509 context
**
**	Returns:
**		accept connection?
**		currently: always yes.
*/

static int
tls_verify_cb(ctx)
	X509_STORE_CTX *ctx;
{
	int ok;

	ok = X509_verify_cert(ctx);
	if (ok == 0)
	{
		if (LogLevel > 13)
			return tls_verify_log(ok, ctx);
		return 1;	/* override it */
	}
	return ok;
}


/*
**  TLSLOGERR -- log the errors from the TLS error stack
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
*/

void
tlslogerr()
{
	unsigned long l;
	int line, flags;
	unsigned long es;
	char *file, *data;
	char buf[256];
#define CP (const char **)

	es = CRYPTO_thread_id();
	while ((l = ERR_get_error_line_data(CP &file, &line, CP &data, &flags))
		!= 0)
	{
		sm_syslog(LOG_WARNING, NOQID,
			 "TLS: %lu:%s:%s:%d:%s\n", es, ERR_error_string(l, buf),
			 file, line, (flags & ERR_TXT_STRING) ? data : "");
	}
a3700 2
# endif /* STARTTLS */
#endif /* SMTP */
d3706 1
a3706 1
**		e -- envelope
d3722 1
a3722 1
	register FILE *hf;
d3726 1
a3726 1
	bool first = TRUE;
d3751 1
a3751 1
		noinfo = FALSE;
d3756 1
a3756 1
		noinfo = TRUE;
d3761 1
a3761 1
	while (fgets(buf, sizeof buf, hf) != NULL)
d3770 2
a3771 2
				if (sscanf(buf + strlen(HELPVSTR), "%d",
					   &h) == 1)
d3780 1
a3780 1
				first = FALSE;
d3791 1
a3791 1
			fixcrlf(p, TRUE);
d3799 1
a3799 1
			noinfo = FALSE;
d3819 1
a3819 1
	(void) fclose(hf);
@


1.5
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d19 1
a19 1
static char id[] = "@@(#)$Sendmail: srvrsmtp.c,v 8.471.2.2.2.77 2001/05/27 22:20:30 gshapiro Exp $ (with SMTP)";
d21 1
a21 1
static char id[] = "@@(#)$Sendmail: srvrsmtp.c,v 8.471.2.2.2.77 2001/05/27 22:20:30 gshapiro Exp $ (without SMTP)";
d771 1
a771 1
				continue;
@


1.4
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d19 1
a19 1
static char id[] = "@@(#)$Sendmail: srvrsmtp.c,v 8.471.2.2.2.67 2001/01/07 19:31:05 gshapiro Exp $ (with SMTP)";
d21 1
a21 1
static char id[] = "@@(#)$Sendmail: srvrsmtp.c,v 8.471.2.2.2.67 2001/01/07 19:31:05 gshapiro Exp $ (without SMTP)";
d47 1
a47 1
static bool	tls_ok = FALSE;
d969 1
a969 1
			if (!tls_ok)
d1041 1
a1041 1
				tls_ok = FALSE;
d1083 1
a1083 1
			tls_ok = FALSE;	/* don't offer STARTTLS again */
d1103 1
a1103 1
						free(mechlist);
d1304 1
a1304 1
			if (tls_ok && usetls)
d1528 2
a1529 1
			   (e->e_msgsize > MaxMessageSize || e->e_msgsize < 0))
d1571 1
a1571 1
					free(response);
d1749 1
a1749 1
					free(response);
d1851 1
a1851 1
					free(response);
d1862 1
a1862 1
				free(q);
d2167 1
a2167 5
			if ((new = (QUEUE_CHAR *)malloc(sizeof(QUEUE_CHAR))) == NULL)
			{
				syserr("500 5.5.0 ETRN out of memory");
				break;
			}
d2172 1
a2172 1
			free(QueueLimitRecipient);
d2357 2
a2358 2
				  "%.100s: %.40s attack?",
				  CurSmtpClient, cname);
d2604 2
a2605 1
		free(auth_param);
d2849 6
a2998 1

d3023 1
a3023 1
#   if EGD
d3037 1
a3037 1
#   endif /* EGD */
d3294 30
d3325 2
d3509 2
d3521 2
d3844 3
d3853 3
a3855 3
	tls_ok = inittls(&srv_ctx, TLS_I_SRV, TRUE, SrvCERTfile, Srvkeyfile,
			 CACERTpath, CACERTfile, DHParams);
	return tls_ok;
@


1.4.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d19 1
a19 1
static char id[] = "@@(#)$Sendmail: srvrsmtp.c,v 8.471.2.2.2.77 2001/05/27 22:20:30 gshapiro Exp $ (with SMTP)";
d21 1
a21 1
static char id[] = "@@(#)$Sendmail: srvrsmtp.c,v 8.471.2.2.2.77 2001/05/27 22:20:30 gshapiro Exp $ (without SMTP)";
d47 1
a47 1
static bool	tls_ok_srv = FALSE;
d969 1
a969 1
			if (!tls_ok_srv)
d1041 1
a1041 1
				tls_ok_srv = FALSE;
d1083 1
a1083 1
			tls_ok_srv = FALSE;	/* don't offer STARTTLS again */
d1103 1
a1103 1
						sm_free(mechlist);
d1304 1
a1304 1
			if (tls_ok_srv && usetls)
d1528 1
a1528 2
			    (e->e_msgsize > MaxMessageSize ||
			     e->e_msgsize < 0))
d1570 1
a1570 1
					sm_free(response);
d1748 1
a1748 1
					sm_free(response);
d1850 1
a1850 1
					sm_free(response);
d1861 1
a1861 1
				sm_free(q);
d2166 5
a2170 1
			new = (QUEUE_CHAR *)xalloc(sizeof(QUEUE_CHAR));
d2175 1
a2175 1
			sm_free(QueueLimitRecipient);
d2360 2
a2361 2
				  "%.100s: possible SMTP attack: command=%.40s, count=%d",
				  CurSmtpClient, cname, *pcounter);
d2607 1
a2607 2
		sm_free(auth_param);

a2850 6

			/* Reset global flags */
			RestartRequest = NULL;
			ShutdownRequest = NULL;
			PendingSignal = 0;

d2995 1
d3020 1
a3020 1
#    if EGD
d3034 1
a3034 1
#    endif /* EGD */
a3290 30
/*
**  INIT_TLS_LIBRARY -- calls functions which setup TLS library for global use
**
**	Parameters:
**		none.
**
**	Returns:
**		succeeded?
**
**	Side Effects:
**		Sets tls_ok_srv static, even when called from main()
*/

bool
init_tls_library()
{
	/*
	**  basic TLS initialization
	**  ignore result for now
	*/

	SSL_library_init();
	SSL_load_error_strings();
# if 0
	/* this is currently a macro for SSL_library_init */
	SSLeay_add_ssl_algorithms();
# endif /* 0 */

	/* initialize PRNG */
	tls_ok_srv = tls_rand_init(RandFile, 7);
a3291 2
	return tls_ok_srv;
}
a3473 2
			if (LogLevel > 9)
				tlslogerr();
a3483 2
			if (LogLevel > 9)
				tlslogerr();
a3804 3
**
**	Side Effects:
**		sets tls_ok_srv static, even when called from main()
d3811 3
a3813 3
	tls_ok_srv = inittls(&srv_ctx, TLS_I_SRV, TRUE, SrvCERTfile,
			     Srvkeyfile, CACERTpath, CACERTfile, DHParams);
	return tls_ok_srv;
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d19 1
a19 1
static char id[] = "@@(#)$Sendmail: srvrsmtp.c,v 8.471.2.2.2.66 2000/12/18 18:00:44 ca Exp $ (with SMTP)";
d21 1
a21 1
static char id[] = "@@(#)$Sendmail: srvrsmtp.c,v 8.471.2.2.2.66 2000/12/18 18:00:44 ca Exp $ (without SMTP)";
d1162 1
a1162 1
					MyHostName);
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d14 1
d19 1
a19 1
static char id[] = "@@(#)$Sendmail: srvrsmtp.c,v 8.471 2000/04/06 08:39:58 gshapiro Exp $ (with SMTP)";
d21 1
a21 1
static char id[] = "@@(#)$Sendmail: srvrsmtp.c,v 8.471 2000/04/06 08:39:58 gshapiro Exp $ (without SMTP)";
d26 3
d33 20
d102 3
d117 5
d146 3
d167 5
d192 1
d208 1
a208 1
	volatile int lognullconnection = TRUE;
d236 3
d240 8
d277 1
a277 1
	/* use empty realm: doesn't work in SASL <= 1.5.5 */
d330 8
d348 4
d373 14
a423 5
		  case SMFIR_DISCARD:
			e->e_flags |= EF_DISCARD;
			milterize = FALSE;
			break;

d446 1
a446 1
	message(cmdbuf, id - inp, inp, id);
d600 55
d660 1
d741 1
a741 1
			if (!strcasecmp(c->cmd_name, cmdbuf))
d823 10
d950 1
a950 1
				message("334 %s", *out2 == '\0' ? "=" : out2);
d957 183
d1219 2
a1226 1
				ok = TRUE;
d1231 1
a1232 2
					ok = FALSE;
					usrerr(response);
a1235 1
					ok = FALSE;
a1237 6
					usrerr("550 HELO/EHLO rejected");
					break;

				  case SMFIR_DISCARD:
					e->e_flags |= EF_DISCARD;
					milterize = FALSE;
a1240 1
					ok = FALSE;
a1244 4
				if (response != NULL)
					free(response);
				if (!ok)
					break;
a1247 2
			gothello = TRUE;

d1266 8
a1273 1
			/* print EHLO features list */
d1303 4
d1339 3
d1346 2
a1347 2
						  "MAIL From:<%.100s> from %.100s tempfailed (from previous HELO/EHLO check)",
						  args[0], CurSmtpClient);
d1351 1
a1355 3
			p = skipword(p, "from");
			if (p == NULL)
				break;
d1358 6
a1363 1
			if (runinchild("SMTP-MAIL", e) > 0)
d1365 1
d1523 1
a1523 1
				    NULL, e, TRUE, TRUE, 4) != EX_OK ||
d1527 2
a1528 1
			if (MaxMessageSize > 0 && e->e_msgsize > MaxMessageSize)
d1544 1
d1566 1
a1566 1
					usrerr("451 4.7.1 Try again later");
d1718 1
a1718 1
				    NULL, e, TRUE, TRUE, 4) != EX_OK ||
d1744 1
a1744 1
					usrerr("451 4.7.1 Try again later");
d1830 1
a1830 1
				response = milter_body(e, &state);
d1846 1
a1846 1
					usrerr("451 4.7.1 Try again later");
d2017 10
d2077 1
a2077 1
					    p, NULL, e, TRUE, FALSE, 4)
d2083 7
a2089 1
				(void) sleep(wt - (curtime() - previous));
d2107 1
a2107 1
				       (!QS_IS_UNDELIVERED(vrfyqueue->q_state)))
d2129 9
d2150 2
a2151 2
			if (rscheck("check_etrn", p, NULL, e, TRUE, FALSE, 4)
			    != EX_OK || Errors > 0)
d2197 8
d2339 1
a2339 1
**		none.
a2456 3
# if defined(__STDC__) && !defined(BROKEN_ANSI_LIBRARY)
		e->e_msgsize = strtoul(vp, (char **) NULL, 10);
# else /* defined(__STDC__) && !defined(BROKEN_ANSI_LIBRARY) */
d2458 5
a2462 1
# endif /* defined(__STDC__) && !defined(BROKEN_ANSI_LIBRARY) */
d2589 2
a2590 2
		     (rscheck("trust_auth", pbuf, NULL, e, TRUE, FALSE, 10)
		      != EX_OK || Errors > 0))
d2616 1
a2616 1
		usrerr("501 5.5.4 %s parameter unrecognized", kp);
d2705 1
a2705 1
		usrerr("501 5.5.4 %s parameter unrecognized", kp);
d2774 3
a2776 2
**		zero in the child
**		one in the parent
d2809 1
d2815 1
a2815 1
			return 1;
d2828 1
d2830 3
a2832 1
					label, st & 0177);
d2834 1
a2834 1
			/* if we exited on a QUIT command, complete the process */
d2844 1
a2844 1
			return 1;
d2858 1
a2858 1
	return 0;
d2873 1
d2899 1
d2917 1
d2934 1221
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
a13 1

d18 1
a18 1
static char id[] = "@@(#)$Sendmail: srvrsmtp.c,v 8.471.2.2.2.77 2001/05/27 22:20:30 gshapiro Exp $ (with SMTP)";
d20 1
a20 1
static char id[] = "@@(#)$Sendmail: srvrsmtp.c,v 8.471.2.2.2.77 2001/05/27 22:20:30 gshapiro Exp $ (without SMTP)";
a24 3
# if SASL || STARTTLS
#  include "sfsasl.h"
# endif /* SASL || STARTTLS */
a28 20
# if STARTTLS
#  include <sysexits.h>
#   include <openssl/err.h>
#   include <openssl/bio.h>
#   include <openssl/pem.h>
#   ifndef HASURANDOMDEV
#    include <openssl/rand.h>
#   endif /* !HASURANDOMDEV */

static SSL	*srv_ssl = NULL;
static SSL_CTX	*srv_ctx = NULL;
#  if !TLS_NO_RSA
static RSA	*rsa = NULL;
#  endif /* !TLS_NO_RSA */
static bool	tls_ok_srv = FALSE;
static int	tls_verify_cb __P((X509_STORE_CTX *));
#  if !TLS_NO_RSA
#   define RSA_KEYLENGTH	512
#  endif /* !TLS_NO_RSA */
# endif /* STARTTLS */
a77 3
# if STARTTLS
#  define CMDSTLS	14	/* STARTTLS -- start TLS session */
# endif /* STARTTLS */
a89 5
/*
**  Note: If you change this list,
**        remember to update 'helpfile'
*/

a113 3
# if STARTTLS
	{ "starttls",	CMDSTLS,	},
# endif /* STARTTLS */
a131 5
/* runinchild() returns */
# define RIC_INCHILD		0	/* in a child process */
# define RIC_INPARENT		1	/* still in parent process */
# define RIC_TEMPFAIL		2	/* temporary failure occurred */

a151 1
	int ric;
d167 1
a167 1
	volatile bool lognullconnection = TRUE;
a194 3
#  if SFIO
	sasl_ssf_t *ssf;
#  endif /* SFIO */
a195 8
# if STARTTLS
	int r;
	int rfd, wfd;
	volatile bool usetls = TRUE;
	volatile bool tls_active = FALSE;
	bool saveQuickAbort;
	bool saveSuprErrs;
# endif /* STARTTLS */
d225 1
a225 1
	/* use empty realm: only works in SASL > 1.5.5 */
a277 8
#  if SFIO
		/* XXX should these be options settable via .cf ? */
		/* ssp.min_ssf = 0; is default due to memset() */
		{
			ssp.max_ssf = INT_MAX;
			ssp.maxbufsize = MAXOUTLEN;
		}
#  endif /* SFIO */
a287 4
#   if STARTTLS
			**  we may have to change this for STARTTLS
			**  (dynamically)
#   endif
a308 14
# if STARTTLS
#  if _FFR_TLS_O_T
	saveQuickAbort = QuickAbort;
	saveSuprErrs = SuprErrs;
	SuprErrs = TRUE;
	QuickAbort = FALSE;
	if (rscheck("offer_tls", CurSmtpClient, "", e, TRUE, FALSE, 8,
		    NULL) != EX_OK || Errors > 0)
		usetls = FALSE;
	QuickAbort = saveQuickAbort;
	SuprErrs = saveSuprErrs;
#  endif /* _FFR_TLS_O_T */
# endif /* STARTTLS */

d346 5
d373 1
a373 1
	message(cmdbuf, (int) (id - inp), inp, id);
a526 55
#  if SFIO
				/* get security strength (features) */
				result = sasl_getprop(conn, SASL_SSF,
						      (void **) &ssf);
				if (result != SASL_OK)
				{
					define(macid("{auth_ssf}", NULL),
					       "0", &BlankEnvelope);
					ssf = NULL;
				}
				else
				{
					char pbuf[8];

					snprintf(pbuf, sizeof pbuf, "%u", *ssf);
					define(macid("{auth_ssf}", NULL),
					       newstr(pbuf), &BlankEnvelope);
					if (tTd(95, 8))
						dprintf("SASL auth_ssf: %u\n",
							*ssf);
				}
				/*
				**  only switch to encrypted connection
				**  if a security layer has been negotiated
				*/
				if (ssf != NULL && *ssf > 0)
				{
					/*
					**  convert sfio stuff to use SASL
					**  check return values
					**  if the call fails,
					**  fall back to unencrypted version
					**  unless some cf option requires
					**  encryption then the connection must
					**  be aborted
					*/
					if (sfdcsasl(InChannel, OutChannel,
					    conn) == 0)
					{
						/* restart dialogue */
						gothello = FALSE;
						OneXact = TRUE;
						n_helo = 0;
					}
					else
						syserr("503 5.3.3 SASL TLS failed");
					if (LogLevel > 9)
						sm_syslog(LOG_INFO,
							  NOQID,
							  "SASL: connection from %.64s: mech=%.16s, id=%.64s, bits=%d",
							  CurSmtpClient,
							  auth_type, user,
							  *ssf);
				}
#  else /* SFIO */
a531 1
#  endif /* SFIO */
d612 1
a612 1
			if (strcasecmp(c->cmd_name, cmdbuf) == 0)
a693 10
			if (tempfail)
			{
				if (LogLevel > 9)
					sm_syslog(LOG_INFO, e->e_id,
						  "SMTP AUTH command (%.100s) from %.100s tempfailed (due to previous checks)",
						  p, CurSmtpClient);
				usrerr("454 4.7.1 Please try again later");
				break;
			}

d811 1
a811 1
				message("334 %s", out2);
a817 183
# if STARTTLS
		  case CMDSTLS: /* starttls */
			if (*p != '\0')
			{
				message("501 5.5.2 Syntax error (no parameters allowed)");
				break;
			}
			if (!usetls)
			{
				message("503 5.5.0 TLS not available");
				break;
			}
			if (!tls_ok_srv)
			{
				message("454 4.3.3 TLS not available after start");
				break;
			}
			if (gotmail)
			{
				message("503 5.5.0 TLS not permitted during a mail transaction");
				break;
			}
			if (tempfail)
			{
				if (LogLevel > 9)
					sm_syslog(LOG_INFO, e->e_id,
						  "SMTP STARTTLS command (%.100s) from %.100s tempfailed (due to previous checks)",
						  p, CurSmtpClient);
				usrerr("454 4.7.1 Please try again later");
				break;
			}
# if TLS_NO_RSA
			/*
			**  XXX do we need a temp key ?
			*/
# else /* TLS_NO_RSA */
			if (SSL_CTX_need_tmp_RSA(srv_ctx) &&
			   !SSL_CTX_set_tmp_rsa(srv_ctx,
				(rsa = RSA_generate_key(RSA_KEYLENGTH, RSA_F4,
							NULL, NULL)))
			  )
			{
				message("454 4.3.3 TLS not available: error generating RSA temp key");
				if (rsa != NULL)
					RSA_free(rsa);
				break;
			}
# endif /* TLS_NO_RSA */
			if (srv_ssl != NULL)
				SSL_clear(srv_ssl);
			else if ((srv_ssl = SSL_new(srv_ctx)) == NULL)
			{
				message("454 4.3.3 TLS not available: error generating SSL handle");
				break;
			}
			rfd = fileno(InChannel);
			wfd = fileno(OutChannel);
			if (rfd < 0 || wfd < 0 ||
			    SSL_set_rfd(srv_ssl, rfd) <= 0 ||
			    SSL_set_wfd(srv_ssl, wfd) <= 0)
			{
				message("454 4.3.3 TLS not available: error set fd");
				SSL_free(srv_ssl);
				srv_ssl = NULL;
				break;
			}
			message("220 2.0.0 Ready to start TLS");
			SSL_set_accept_state(srv_ssl);

#  define SSL_ACC(s)	SSL_accept(s)
			if ((r = SSL_ACC(srv_ssl)) <= 0)
			{
				int i;

				/* what to do in this case? */
				i = SSL_get_error(srv_ssl, r);
				if (LogLevel > 5)
				{
					sm_syslog(LOG_WARNING, e->e_id,
						  "TLS: error: accept failed=%d (%d)",
						  r, i);
					if (LogLevel > 9)
						tlslogerr();
				}
				tls_ok_srv = FALSE;
				SSL_free(srv_ssl);
				srv_ssl = NULL;

				/*
				**  according to the next draft of
				**  RFC 2487 the connection should be dropped
				*/

				/* arrange to ignore any current send list */
				e->e_sendqueue = NULL;
				goto doquit;
			}

			/* ignore return code for now, it's in {verify} */
			(void) tls_get_info(srv_ssl, &BlankEnvelope, TRUE,
					    CurSmtpClient, TRUE);

			/*
			**  call Stls_client to find out whether
			**  to accept the connection from the client
			*/

			saveQuickAbort = QuickAbort;
			saveSuprErrs = SuprErrs;
			SuprErrs = TRUE;
			QuickAbort = FALSE;
			if (rscheck("tls_client",
				     macvalue(macid("{verify}", NULL), e),
				     "STARTTLS", e, TRUE, TRUE, 6, NULL) !=
			    EX_OK || Errors > 0)
			{
				extern char MsgBuf[];

				if (MsgBuf[0] != '\0' && ISSMTPREPLY(MsgBuf))
					nullserver = newstr(MsgBuf);
				else
					nullserver = "503 5.7.0 Authentication required.";
			}
			QuickAbort = saveQuickAbort;
			SuprErrs = saveSuprErrs;

			tls_ok_srv = FALSE;	/* don't offer STARTTLS again */
			gothello = FALSE;	/* discard info */
			n_helo = 0;
			OneXact = TRUE;	/* only one xaction this run */
#  if SASL
			if (sasl_ok)
			{
				char *s;

				if ((s = macvalue(macid("{cipher_bits}", NULL), e)) != NULL &&
				    (ext_ssf.ssf = atoi(s)) > 0)
				{
#  if _FFR_EXT_MECH
					ext_ssf.auth_id = macvalue(macid("{cert_subject}",
									 NULL),
								   e);
#  endif /* _FFR_EXT_MECH */
					sasl_ok = sasl_setprop(conn, SASL_SSF_EXTERNAL,
							       &ext_ssf) == SASL_OK;
					if (mechlist != NULL)
						sm_free(mechlist);
					mechlist = NULL;
					if (sasl_ok)
					{
						n_mechs = saslmechs(conn,
								    &mechlist);
						sasl_ok = n_mechs > 0;
					}
				}
			}
#  endif /* SASL */

			/* switch to secure connection */
#if SFIO
			r = sfdctls(InChannel, OutChannel, srv_ssl);
#else /* SFIO */
# if _FFR_TLS_TOREK
			r = sfdctls(&InChannel, &OutChannel, srv_ssl);
# endif /* _FFR_TLS_TOREK */
#endif /* SFIO */
			if (r == 0)
				tls_active = TRUE;
			else
			{
				/*
				**  XXX this is an internal error
				**  how to deal with it?
				**  we can't generate an error message
				**  since the other side switched to an
				**  encrypted layer, but we could not...
				**  just "hang up"?
				*/
				nullserver = "454 4.3.3 TLS not available: can't switch to encrypted layer";
				syserr("TLS: can't switch to encrypted layer");
			}
			break;
# endif /* STARTTLS */
d840 1
a840 1
				       MyHostName);
a896 2
			gothello = TRUE;

d903 1
a907 1
					nullserver = response;
d909 2
d914 1
d917 6
d926 1
d931 4
d938 2
d958 1
a958 8
			/*
			**  print EHLO features list
			**
			**  Note: If you change this list,
			**        remember to update 'helpfile'
			*/


a987 4
# if STARTTLS
			if (tls_ok_srv && usetls)
				message("250-STARTTLS");
# endif /* STARTTLS */
a1019 3
			p = skipword(p, "from");
			if (p == NULL)
				break;
d1024 2
a1025 2
						  "SMTP MAIL command (%.100s) from %.100s tempfailed (due to previous checks)",
						  p, CurSmtpClient);
a1028 1

d1033 3
d1038 1
a1038 6
			ric = runinchild("SMTP-MAIL", e);

			/* Catch a problem and stop processing */
			if (ric == RIC_TEMPFAIL && nullserver == NULL)
				nullserver = "452 4.3.0 Internal software error";
			if (ric != RIC_INCHILD)
a1039 1

d1197 1
a1197 1
				    NULL, e, TRUE, TRUE, 4, NULL) != EX_OK ||
d1201 1
a1201 3
			if (MaxMessageSize > 0 &&
			    (e->e_msgsize > MaxMessageSize ||
			     e->e_msgsize < 0))
a1216 1
			LogUsrErrs = TRUE;
d1238 1
a1238 1
					usrerr("451 4.7.1 Please try again later");
d1242 1
a1242 1
					sm_free(response);
d1390 1
a1390 1
				    NULL, e, TRUE, TRUE, 4, NULL) != EX_OK ||
d1416 1
a1416 1
					usrerr("451 4.7.1 Please try again later");
d1420 1
a1420 1
					sm_free(response);
d1502 1
a1502 1
				response = milter_data(e, &state);
d1518 1
a1518 1
					usrerr("451 4.7.1 Please try again later");
d1522 1
a1522 1
					sm_free(response);
d1533 1
a1533 1
				sm_free(q);
a1688 10
			if (tempfail)
			{
				if (LogLevel > 9)
					sm_syslog(LOG_INFO, e->e_id,
						  "SMTP %s command (%.100s) from %.100s tempfailed (due to previous checks)",
						  c->cmd_code == CMDVRFY ? "VRFY" : "EXPN",
						  p, CurSmtpClient);
				usrerr("550 5.7.1 Please try again later");
				break;
			}
d1739 1
a1739 1
					    p, NULL, e, TRUE, FALSE, 4, NULL)
d1745 1
a1745 7
			{
				time_t t;

				t = wt - (curtime() - previous);
				if (t > 0)
					(void) sleep(t);
			}
d1763 1
a1763 1
				       (!QS_IS_UNDELIVERED(a->q_state)))
a1784 9
			if (tempfail)
			{
				if (LogLevel > 9)
					sm_syslog(LOG_INFO, e->e_id,
						  "SMTP ETRN command (%.100s) from %.100s tempfailed (due to previous checks)",
						  p, CurSmtpClient);
				usrerr("451 4.7.1 Please try again later");
				break;
			}
d1797 2
a1798 2
			if (rscheck("check_etrn", p, NULL, e, TRUE, FALSE, 4,
				    NULL) != EX_OK || Errors > 0)
d1813 5
a1817 1
			new = (QUEUE_CHAR *)xalloc(sizeof(QUEUE_CHAR));
d1822 1
a1822 1
			sm_free(QueueLimitRecipient);
a1843 8
# if STARTTLS
			/* shutdown TLS connection */
			if (tls_active)
			{
				(void) endtls(srv_ssl, "server");
				tls_active = FALSE;
			}
# endif /* STARTTLS */
d1978 1
a1978 1
**		time to wait.
d1999 2
a2000 2
				  "%.100s: possible SMTP attack: command=%.40s, count=%d",
				  CurSmtpClient, cname, *pcounter);
d2096 3
d2100 1
a2100 5
		if (e->e_msgsize == LONG_MAX && errno == ERANGE)
		{
			usrerr("552 5.2.3 Message size exceeds maximum value");
			/* NOTREACHED */
		}
d2227 2
a2228 2
		     (rscheck("trust_auth", pbuf, NULL, e, TRUE, FALSE, 10,
			      NULL) != EX_OK || Errors > 0))
d2245 1
a2245 2
		sm_free(auth_param);

d2254 1
a2254 1
		usrerr("555 5.5.4 %s parameter unrecognized", kp);
d2343 1
a2343 1
		usrerr("555 5.5.4 %s parameter unrecognized", kp);
d2412 2
a2413 3
**		RIC_INCHILD in the child
**		RIC_INPARENT in the parent
**		RIC_TEMPFAIL tempfail condition
a2445 1

d2451 1
a2451 1
			return RIC_INPARENT;
a2463 1
			{
d2465 1
a2465 3
				       label, st & 0177);
				return RIC_TEMPFAIL;
			}
d2467 1
a2467 1
			/* if exited on a QUIT command, complete the process */
d2477 1
a2477 1
			return RIC_INPARENT;
a2483 6

			/* Reset global flags */
			RestartRequest = NULL;
			ShutdownRequest = NULL;
			PendingSignal = 0;

d2491 1
a2491 1
	return RIC_INCHILD;
a2505 1

a2530 1
		num = 0;
a2547 1

a2563 1259
# if STARTTLS
#  if !TLS_NO_RSA
RSA *rsa_tmp;	/* temporary RSA key */
static RSA * tmp_rsa_key __P((SSL *, int, int));
#  endif /* !TLS_NO_RSA */

# if !NO_DH
static DH *get_dh512 __P((void));

static unsigned char dh512_p[] =
{
	0xDA,0x58,0x3C,0x16,0xD9,0x85,0x22,0x89,0xD0,0xE4,0xAF,0x75,
	0x6F,0x4C,0xCA,0x92,0xDD,0x4B,0xE5,0x33,0xB8,0x04,0xFB,0x0F,
	0xED,0x94,0xEF,0x9C,0x8A,0x44,0x03,0xED,0x57,0x46,0x50,0xD3,
	0x69,0x99,0xDB,0x29,0xD7,0x76,0x27,0x6B,0xA2,0xD3,0xD4,0x12,
	0xE2,0x18,0xF4,0xDD,0x1E,0x08,0x4C,0xF6,0xD8,0x00,0x3E,0x7C,
	0x47,0x74,0xE8,0x33
};
static unsigned char dh512_g[] =
{
	0x02
};

static DH *
get_dh512()
{
	DH *dh = NULL;

	if ((dh = DH_new()) == NULL)
		return(NULL);
	dh->p = BN_bin2bn(dh512_p, sizeof(dh512_p), NULL);
	dh->g = BN_bin2bn(dh512_g, sizeof(dh512_g), NULL);
	if ((dh->p == NULL) || (dh->g == NULL))
		return(NULL);
	return(dh);
}
# endif /* !NO_DH */

/*
**  TLS_RAND_INIT -- initialize STARTTLS random generator
**
**	Parameters:
**		randfile -- name of file with random data
**		logl -- loglevel
**
**	Returns:
**		success/failure
**
**	Side Effects:
**		initializes PRNG for tls library.
*/

#define MIN_RAND_BYTES	16	/* 128 bits */

bool
tls_rand_init(randfile, logl)
	char *randfile;
	int logl;
{
# ifndef HASURANDOMDEV
	/* not required if /dev/urandom exists, OpenSSL does it internally */
#define RF_OK		0	/* randfile OK */
#define RF_MISS		1	/* randfile == NULL || *randfile == '\0' */
#define RF_UNKNOWN	2	/* unknown prefix for randfile */

#define RI_NONE		0	/* no init yet */
#define RI_SUCCESS	1	/* init was successful */
#define RI_FAIL		2	/* init failed */

	bool ok;
	int randdef;
	static int done = RI_NONE;

	/*
	**  initialize PRNG
	*/

	/* did we try this before? if yes: return old value */
	if (done != RI_NONE)
		return done == RI_SUCCESS;

	/* set default values */
	ok = FALSE;
	done = RI_FAIL;
	randdef = (randfile == NULL || *randfile == '\0') ? RF_MISS : RF_OK;
#    if EGD
	if (randdef == RF_OK && strncasecmp(randfile, "egd:", 4) == 0)
	{
		randfile += 4;
		if (RAND_egd(randfile) < 0)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: RAND_egd(%s) failed: random number generator not seeded",
				   randfile);
		}
		else
			ok = TRUE;
	}
	else
#    endif /* EGD */
	if (randdef == RF_OK && strncasecmp(randfile, "file:", 5) == 0)
	{
		int fd;
		long sff;
		struct stat st;

		randfile += 5;
		sff = SFF_SAFEDIRPATH | SFF_NOWLINK
		      | SFF_NOGWFILES | SFF_NOWWFILES
		      | SFF_NOGRFILES | SFF_NOWRFILES
		      | SFF_MUSTOWN | SFF_ROOTOK | SFF_OPENASROOT;
		if ((fd = safeopen(randfile, O_RDONLY, 0, sff)) >= 0)
		{
			if (fstat(fd, &st) < 0)
			{
				if (LogLevel > logl)
					sm_syslog(LOG_ERR, NOQID,
						  "TLS: can't fstat(%s)",
						  randfile);
			}
			else
			{
				bool use, problem;

				use = TRUE;
				problem = FALSE;
				if (st.st_mtime + 600 < curtime())
				{
					use = bitnset(DBS_INSUFFICIENTENTROPY,
						      DontBlameSendmail);
					problem = TRUE;
					if (LogLevel > logl)
						sm_syslog(LOG_ERR, NOQID,
							  "TLS: RandFile %s too old: %s",
							  randfile,
							  use ? "unsafe" :
								"unusable");
				}
				if (use && st.st_size < MIN_RAND_BYTES)
				{
					use = bitnset(DBS_INSUFFICIENTENTROPY,
						      DontBlameSendmail);
					problem = TRUE;
					if (LogLevel > logl)
						sm_syslog(LOG_ERR, NOQID,
							  "TLS: size(%s) < %d: %s",
							  randfile,
							  MIN_RAND_BYTES,
							  use ? "unsafe" :
								"unusable");
				}
				if (use)
					ok = RAND_load_file(randfile, -1) >=
					     MIN_RAND_BYTES;
				if (use && !ok)
				{
					if (LogLevel > logl)
						sm_syslog(LOG_WARNING,
							  NOQID,
							  "TLS: RAND_load_file(%s) failed: random number generator not seeded",
							  randfile);
				}
				if (problem)
					ok = FALSE;
			}
			if (ok || bitnset(DBS_INSUFFICIENTENTROPY,
					  DontBlameSendmail))
			{
				/* add this even if fstat() failed */
				RAND_seed((void *) &st, sizeof st);
			}
			(void) close(fd);
		}
		else
		{
			if (LogLevel > logl)
				sm_syslog(LOG_WARNING, NOQID,
					  "TLS: Warning: safeopen(%s) failed",
					  randfile);
		}
	}
	else if (randdef == RF_OK)
	{
		if (LogLevel > logl)
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: Error: no proper random file definition %s",
				  randfile);
		randdef = RF_UNKNOWN;
	}
	if (randdef == RF_MISS)
	{
		if (LogLevel > logl)
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: Error: missing random file definition");
	}
	if (!ok && bitnset(DBS_INSUFFICIENTENTROPY, DontBlameSendmail))
	{
		int i;
		long r;
		unsigned char buf[MIN_RAND_BYTES];

		/* assert((MIN_RAND_BYTES % sizeof(long)) == 0); */
		for (i = 0; i <= sizeof(buf) - sizeof(long); i += sizeof(long))
		{
			r = get_random();
			(void) memcpy(buf + i, (void *) &r, sizeof(long));
		}
		RAND_seed(buf, sizeof buf);
		if (LogLevel > logl)
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: Warning: random number generator not properly seeded");
		ok = TRUE;
	}
	done = ok ? RI_SUCCESS : RI_FAIL;
	return ok;
# else /* !HASURANDOMDEV */
	return TRUE;
# endif /* !HASURANDOMDEV */
}

/*
**  status in initialization
**  these flags keep track of the status of the initialization
**  i.e., whether a file exists (_EX) and whether it can be used (_OK)
**  [due to permissions]
*/
#define TLS_S_NONE	0x00000000	/* none yet  */
#define TLS_S_CERT_EX	0x00000001	/* CERT file exists */
#define TLS_S_CERT_OK	0x00000002	/* CERT file is ok */
#define TLS_S_KEY_EX	0x00000004	/* KEY file exists */
#define TLS_S_KEY_OK	0x00000008	/* KEY file is ok */
#define TLS_S_CERTP_EX	0x00000010	/* CA CERT PATH exists */
#define TLS_S_CERTP_OK	0x00000020	/* CA CERT PATH is ok */
#define TLS_S_CERTF_EX	0x00000040	/* CA CERT FILE exists */
#define TLS_S_CERTF_OK	0x00000080	/* CA CERT FILE is ok */

# if _FFR_TLS_1
#define TLS_S_CERT2_EX	0x00001000	/* 2nd CERT file exists */
#define TLS_S_CERT2_OK	0x00002000	/* 2nd CERT file is ok */
#define TLS_S_KEY2_EX	0x00004000	/* 2nd KEY file exists */
#define TLS_S_KEY2_OK	0x00008000	/* 2nd KEY file is ok */
# endif /* _FFR_TLS_1 */

#define TLS_S_DH_OK	0x00200000	/* DH cert is ok */
#define TLS_S_DHPAR_EX	0x00400000	/* DH param file exists */
#define TLS_S_DHPAR_OK	0x00800000	/* DH param file is ok to use */

/*
**  TLS_OK_F -- can var be an absolute filename?
**
**	Parameters:
**		var -- filename
**		fn -- what is the filename used for?
**
**	Returns:
**		ok?
*/

static bool
tls_ok_f(var, fn)
	char *var;
	char *fn;
{
	/* must be absolute pathname */
	if (var != NULL && *var == '/')
		return TRUE;
	if (LogLevel > 12)
		sm_syslog(LOG_WARNING, NOQID, "TLS: file %s missing", fn);
	return FALSE;
}

/*
**  TLS_SAFE_F -- is a file safe to use?
**
**	Parameters:
**		var -- filename
**		sff -- flags for safefile()
**
**	Returns:
**		ok?
*/

static bool
tls_safe_f(var, sff)
	char *var;
	long sff;
{
	int ret;

	if ((ret = safefile(var, RunAsUid, RunAsGid, RunAsUserName, sff,
			    S_IRUSR, NULL)) == 0)
		return TRUE;
	if (LogLevel > 7)
		sm_syslog(LOG_WARNING, NOQID, "TLS: file %s unsafe: %s",
			  var, errstring(ret));
	return FALSE;
}

/*
**  TLS_OK_F -- macro to simplify calls to tls_ok_f
**
**	Parameters:
**		var -- filename
**		fn -- what is the filename used for?
**		req -- is the file required?
**		st -- status bit to set if ok
**
**	Side Effects:
**		uses r, ok; may change ok and status.
**
*/

#define TLS_OK_F(var, fn, req, st) if (ok) \
	{ \
		r = tls_ok_f(var, fn); \
		if (r) \
			status |= st; \
		else if (req) \
			ok = FALSE; \
	}

/*
**  TLS_UNR -- macro to return whether a file should be unreadable
**
**	Parameters:
**		bit -- flag to test
**		req -- flags
**
**	Returns:
**		0/SFF_NORFILES
*/
#define TLS_UNR(bit, req)	(bitset(bit, req) ? SFF_NORFILES : 0)

/*
**  TLS_SAFE_F -- macro to simplify calls to tls_safe_f
**
**	Parameters:
**		var -- filename
**		sff -- flags for safefile()
**		req -- is the file required?
**		ex -- does the file exist?
**		st -- status bit to set if ok
**
**	Side Effects:
**		uses r, ok, ex; may change ok and status.
**
*/

#define TLS_SAFE_F(var, sff, req, ex, st) if (ex && ok) \
	{ \
		r = tls_safe_f(var, sff); \
		if (r) \
			status |= st;	\
		else if (req) \
			ok = FALSE;	\
	}
/*
**  INIT_TLS_LIBRARY -- calls functions which setup TLS library for global use
**
**	Parameters:
**		none.
**
**	Returns:
**		succeeded?
**
**	Side Effects:
**		Sets tls_ok_srv static, even when called from main()
*/

bool
init_tls_library()
{
	/*
	**  basic TLS initialization
	**  ignore result for now
	*/

	SSL_library_init();
	SSL_load_error_strings();
# if 0
	/* this is currently a macro for SSL_library_init */
	SSLeay_add_ssl_algorithms();
# endif /* 0 */

	/* initialize PRNG */
	tls_ok_srv = tls_rand_init(RandFile, 7);

	return tls_ok_srv;
}
/*
**  INITTLS -- initialize TLS
**
**	Parameters:
**		ctx -- pointer to context
**		req -- requirements for initialization (see sendmail.h)
**		srv -- server side?
**		certfile -- filename of certificate
**		keyfile -- filename of private key
**		cacertpath -- path to CAs
**		cacertfile -- file with CA
**		dhparam -- parameters for DH
**
**	Returns:
**		succeeded?
*/

bool
inittls(ctx, req, srv, certfile, keyfile, cacertpath, cacertfile, dhparam)
	SSL_CTX **ctx;
	u_long req;
	bool srv;
	char *certfile, *keyfile, *cacertpath, *cacertfile, *dhparam;
{
# if !NO_DH
	static DH *dh = NULL;
# endif /* !NO_DH */
	int r;
	bool ok;
	long sff, status;
	char *who;
# if _FFR_TLS_1
	char *cf2, *kf2;
# endif /* _FFR_TLS_1 */

	status = TLS_S_NONE;
	who = srv ? "srv" : "clt";
	if (ctx == NULL)
		syserr("TLS: %s:inittls: ctx == NULL", who);

	/* already initialized? (we could re-init...) */
	if (*ctx != NULL)
		return TRUE;

	/* PRNG seeded? */
	if (!tls_rand_init(RandFile, 10))
		return FALSE;

	/* let's start with the assumption it will work */
	ok = TRUE;

# if _FFR_TLS_1
	/*
	**  look for a second filename: it must be separated by a ','
	**  no blanks allowed (they won't be skipped).
	**  we change a global variable here! this change will be undone
	**  before return from the function but only if it returns TRUE.
	**  this isn't a problem since in a failure case this function
	**  won't be called again with the same (overwritten) values.
	**  otherwise each return must be replaced with a goto endinittls.
	*/
	cf2 = NULL;
	kf2 = NULL;
	if (certfile != NULL && (cf2 = strchr(certfile, ',')) != NULL)
	{
		*cf2++ = '\0';
		if (keyfile != NULL && (kf2 = strchr(keyfile, ',')) != NULL)
			*kf2++ = '\0';
	}
# endif /* _FFR_TLS_1 */

	/*
	**  what do we require from the client?
	**  must it have CERTs?
	**  introduce an option and decide based on that
	*/

	TLS_OK_F(certfile, "CertFile", bitset(TLS_I_CERT_EX, req),
		 TLS_S_CERT_EX);
	TLS_OK_F(keyfile, "KeyFile", bitset(TLS_I_KEY_EX, req),
		 TLS_S_KEY_EX);
	TLS_OK_F(cacertpath, "CACERTPath", bitset(TLS_I_CERTP_EX, req),
		 TLS_S_CERTP_EX);
	TLS_OK_F(cacertfile, "CACERTFile", bitset(TLS_I_CERTF_EX, req),
		 TLS_S_CERTF_EX);

# if _FFR_TLS_1
	if (cf2 != NULL)
	{
		TLS_OK_F(cf2, "CertFile", bitset(TLS_I_CERT_EX, req),
			 TLS_S_CERT2_EX);
	}
	if (kf2 != NULL)
	{
		TLS_OK_F(kf2, "KeyFile", bitset(TLS_I_KEY_EX, req),
			 TLS_S_KEY2_EX);
	}
# endif /* _FFR_TLS_1 */

	/*
	**  valid values for dhparam are (only the first char is checked)
	**  none	no parameters: don't use DH
	**  512		generate 512 bit parameters (fixed)
	**  1024	generate 1024 bit parameters
	**  /file/name	read parameters from /file/name
	**  default is: 1024 for server, 512 for client (OK? XXX)
	*/
	if (bitset(TLS_I_TRY_DH, req))
	{
		if (dhparam != NULL)
		{
			char c = *dhparam;

			if (c == '1')
				req |= TLS_I_DH1024;
			else if (c == '5')
				req |= TLS_I_DH512;
			else if (c != 'n' && c != 'N' && c != '/')
			{
				if (LogLevel > 12)
					sm_syslog(LOG_WARNING, NOQID,
						  "TLS: error: illegal value '%s' for DHParam",
						  dhparam);
				dhparam = NULL;
			}
		}
		if (dhparam == NULL)
			dhparam = srv ? "1" : "5";
		else if (*dhparam == '/')
		{
			TLS_OK_F(dhparam, "DHParameters",
				 bitset(TLS_I_DHPAR_EX, req),
				 TLS_S_DHPAR_EX);
		}
	}
	if (!ok)
		return ok;

	/* certfile etc. must be "safe". */
	sff = SFF_REGONLY | SFF_SAFEDIRPATH | SFF_NOWLINK
	     | SFF_NOGWFILES | SFF_NOWWFILES
	     | SFF_MUSTOWN | SFF_ROOTOK | SFF_OPENASROOT;
	if (DontLockReadFiles)
		sff |= SFF_NOLOCK;

	TLS_SAFE_F(certfile, sff | TLS_UNR(TLS_I_CERT_UNR, req),
		   bitset(TLS_I_CERT_EX, req),
		   bitset(TLS_S_CERT_EX, status), TLS_S_CERT_OK);
	TLS_SAFE_F(keyfile, sff | TLS_UNR(TLS_I_KEY_UNR, req),
		   bitset(TLS_I_KEY_EX, req),
		   bitset(TLS_S_KEY_EX, status), TLS_S_KEY_OK);
	TLS_SAFE_F(cacertfile, sff | TLS_UNR(TLS_I_CERTF_UNR, req),
		   bitset(TLS_I_CERTF_EX, req),
		   bitset(TLS_S_CERTF_EX, status), TLS_S_CERTF_OK);
	TLS_SAFE_F(dhparam, sff | TLS_UNR(TLS_I_DHPAR_UNR, req),
		   bitset(TLS_I_DHPAR_EX, req),
		   bitset(TLS_S_DHPAR_EX, status), TLS_S_DHPAR_OK);
	if (!ok)
		return ok;
# if _FFR_TLS_1
	if (cf2 != NULL)
	{
		TLS_SAFE_F(cf2, sff | TLS_UNR(TLS_I_CERT_UNR, req),
			   bitset(TLS_I_CERT_EX, req),
			   bitset(TLS_S_CERT2_EX, status), TLS_S_CERT2_OK);
	}
	if (kf2 != NULL)
	{
		TLS_SAFE_F(kf2, sff | TLS_UNR(TLS_I_KEY_UNR, req),
			   bitset(TLS_I_KEY_EX, req),
			   bitset(TLS_S_KEY2_EX, status), TLS_S_KEY2_OK);
	}
# endif /* _FFR_TLS_1 */

	/* create a method and a new context */
	if (srv)
	{
		if ((*ctx = SSL_CTX_new(SSLv23_server_method())) == NULL)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					  "TLS: error: SSL_CTX_new(SSLv23_server_method()) failed");
			if (LogLevel > 9)
				tlslogerr();
			return FALSE;
		}
	}
	else
	{
		if ((*ctx = SSL_CTX_new(SSLv23_client_method())) == NULL)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					  "TLS: error: SSL_CTX_new(SSLv23_client_method()) failed");
			if (LogLevel > 9)
				tlslogerr();
			return FALSE;
		}
	}

#  if TLS_NO_RSA
	/* turn off backward compatibility, required for no-rsa */
	SSL_CTX_set_options(*ctx, SSL_OP_NO_SSLv2);
#  endif /* TLS_NO_RSA */


#  if !TLS_NO_RSA
	/*
	**  Create a temporary RSA key
	**  XXX  Maybe we shouldn't create this always (even though it
	**  is only at startup).
	**  It is a time-consuming operation and it is not always necessary.
	**  maybe we should do it only on demand...
	*/
	if (bitset(TLS_I_RSA_TMP, req) &&
	    (rsa_tmp = RSA_generate_key(RSA_KEYLENGTH, RSA_F4, NULL,
					NULL)) == NULL
	   )
	{
		if (LogLevel > 7)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: error: %s: RSA_generate_key failed",
				  who);
			if (LogLevel > 9)
				tlslogerr();
		}
		return FALSE;
	}
#  endif /* !TLS_NO_RSA */

	/*
	**  load private key
	**  XXX change this for DSA-only version
	*/
	if (bitset(TLS_S_KEY_OK, status) &&
	    SSL_CTX_use_PrivateKey_file(*ctx, keyfile,
					 SSL_FILETYPE_PEM) <= 0)
	{
		if (LogLevel > 7)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: error: %s: SSL_CTX_use_PrivateKey_file(%s) failed",
				  who, keyfile);
			if (LogLevel > 9)
				tlslogerr();
		}
		if (bitset(TLS_I_USE_KEY, req))
			return FALSE;
	}

	/* get the certificate file */
	if (bitset(TLS_S_CERT_OK, status) &&
	    SSL_CTX_use_certificate_file(*ctx, certfile,
					 SSL_FILETYPE_PEM) <= 0)
	{
		if (LogLevel > 7)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: error: %s: SSL_CTX_use_certificate_file(%s) failed",
				  who, certfile);
			if (LogLevel > 9)
				tlslogerr();
		}
		if (bitset(TLS_I_USE_CERT, req))
			return FALSE;
	}

	/* check the private key */
	if (bitset(TLS_S_KEY_OK, status) &&
	    (r = SSL_CTX_check_private_key(*ctx)) <= 0)
	{
		/* Private key does not match the certificate public key */
		if (LogLevel > 5)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: error: %s: SSL_CTX_check_private_key failed(%s): %d",
				  who, keyfile, r);
			if (LogLevel > 9)
				tlslogerr();
		}
		if (bitset(TLS_I_USE_KEY, req))
			return FALSE;
	}

# if _FFR_TLS_1
	/* XXX this code is pretty much duplicated from above! */

	/* load private key */
	if (bitset(TLS_S_KEY2_OK, status) &&
	    SSL_CTX_use_PrivateKey_file(*ctx, kf2, SSL_FILETYPE_PEM) <= 0)
	{
		if (LogLevel > 7)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: error: %s: SSL_CTX_use_PrivateKey_file(%s) failed",
				  who, kf2);
			if (LogLevel > 9)
				tlslogerr();
		}
	}

	/* get the certificate file */
	if (bitset(TLS_S_CERT2_OK, status) &&
	    SSL_CTX_use_certificate_file(*ctx, cf2, SSL_FILETYPE_PEM) <= 0)
	{
		if (LogLevel > 7)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: error: %s: SSL_CTX_use_certificate_file(%s) failed",
				  who, cf2);
			if (LogLevel > 9)
				tlslogerr();
		}
	}

	/* we should also check the private key: */
	if (bitset(TLS_S_KEY2_OK, status) &&
	    (r = SSL_CTX_check_private_key(*ctx)) <= 0)
	{
		/* Private key does not match the certificate public key */
		if (LogLevel > 5)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: error: %s: SSL_CTX_check_private_key 2 failed: %d",
				  who, r);
			if (LogLevel > 9)
				tlslogerr();
		}
	}
# endif /* _FFR_TLS_1 */

	/* SSL_CTX_set_quiet_shutdown(*ctx, 1); violation of standard? */
	SSL_CTX_set_options(*ctx, SSL_OP_ALL);	/* XXX bug compatibility? */

# if !NO_DH
	/* Diffie-Hellman initialization */
	if (bitset(TLS_I_TRY_DH, req))
	{
		if (bitset(TLS_S_DHPAR_OK, status))
		{
			BIO *bio;

			if ((bio = BIO_new_file(dhparam, "r")) != NULL)
			{
				dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);
				BIO_free(bio);
				if (dh == NULL && LogLevel > 7)
				{
					u_long err;

					err = ERR_get_error();
					sm_syslog(LOG_WARNING, NOQID,
						  "TLS: error: %s: cannot read DH parameters(%s): %s",
						  who, dhparam,
						  ERR_error_string(err, NULL));
					if (LogLevel > 9)
						tlslogerr();
				}
			}
			else
			{
				if (LogLevel > 5)
				{
					sm_syslog(LOG_WARNING, NOQID,
						  "TLS: error: %s: BIO_new_file(%s) failed",
						  who, dhparam);
					if (LogLevel > 9)
						tlslogerr();
				}
			}
		}
		if (dh == NULL && bitset(TLS_I_DH1024, req))
		{
			DSA *dsa;

			/* this takes a while! (7-130s on a 450MHz AMD K6-2) */
			dsa = DSA_generate_parameters(1024, NULL, 0, NULL,
						      NULL, 0, NULL);
			dh = DSA_dup_DH(dsa);
			DSA_free(dsa);
		}
		else
		if (dh == NULL && bitset(TLS_I_DH512, req))
			dh = get_dh512();

		if (dh == NULL)
		{
			if (LogLevel > 9)
			{
				u_long err;

				err = ERR_get_error();
				sm_syslog(LOG_WARNING, NOQID,
					  "TLS: error: %s: cannot read or set DH parameters(%s): %s",
					  who, dhparam,
					  ERR_error_string(err, NULL));
			}
			if (bitset(TLS_I_REQ_DH, req))
				return FALSE;
		}
		else
		{
			SSL_CTX_set_tmp_dh(*ctx, dh);

			/* important to avoid small subgroup attacks */
			SSL_CTX_set_options(*ctx, SSL_OP_SINGLE_DH_USE);
			if (LogLevel > 12)
				sm_syslog(LOG_INFO, NOQID,
					  "TLS: %s: Diffie-Hellman init, key=%d bit (%c)",
					  who, 8 * DH_size(dh), *dhparam);
			DH_free(dh);
		}
	}
# endif /* !NO_DH */


	/* XXX do we need this cache here? */
	if (bitset(TLS_I_CACHE, req))
		SSL_CTX_sess_set_cache_size(*ctx, 128);
	/* timeout? SSL_CTX_set_timeout(*ctx, TimeOut...); */

	/* load certificate locations and default CA paths */
	if (bitset(TLS_S_CERTP_EX, status) && bitset(TLS_S_CERTF_EX, status))
	{
		if ((r = SSL_CTX_load_verify_locations(*ctx, cacertfile,
						       cacertpath)) == 1)
		{
#  if !TLS_NO_RSA
			if (bitset(TLS_I_RSA_TMP, req))
				SSL_CTX_set_tmp_rsa_callback(*ctx, tmp_rsa_key);
#  endif /* !TLS_NO_RSA */

			/* ask to verify the peer */
			SSL_CTX_set_verify(*ctx, SSL_VERIFY_PEER, NULL);

			/* install verify callback */
			SSL_CTX_set_cert_verify_callback(*ctx, tls_verify_cb,
							 NULL);
			SSL_CTX_set_client_CA_list(*ctx,
				SSL_load_client_CA_file(cacertfile));
		}
		else
		{
			/*
			**  can't load CA data; do we care?
			**  the data is necessary to authenticate the client,
			**  which in turn would be necessary
			**  if we want to allow relaying based on it.
			*/
			if (LogLevel > 5)
			{
				sm_syslog(LOG_WARNING, NOQID,
					  "TLS: error: %s: %d load verify locs %s, %s",
					  who, r, cacertpath, cacertfile);
				if (LogLevel > 9)
					tlslogerr();
			}
			if (bitset(TLS_I_VRFY_LOC, req))
				return FALSE;
		}
	}

	/* XXX: make this dependent on an option? */
	if (tTd(96, 9))
		SSL_CTX_set_info_callback(*ctx, apps_ssl_info_cb);

#  if _FFR_TLS_1
	/*
	**  XXX install our own cipher list: option?
	*/
	if (CipherList != NULL && *CipherList != '\0')
	{
		if (SSL_CTX_set_cipher_list(*ctx, CipherList) <= 0)
		{
			if (LogLevel > 7)
			{
				sm_syslog(LOG_WARNING, NOQID,
					  "TLS: error: %s: SSL_CTX_set_cipher_list(%s) failed, list ignored",
					  who, CipherList);

				if (LogLevel > 9)
					tlslogerr();
			}
			/* failure if setting to this list is required? */
		}
	}
#  endif /* _FFR_TLS_1 */
	if (LogLevel > 12)
		sm_syslog(LOG_INFO, NOQID, "TLS: init(%s)=%d", who, ok);

# if _FFR_TLS_1
#  if 0
	/*
	**  this label is required if we want to have a "clean" exit
	**  see the comments above at the initialization of cf2
	*/
    endinittls:
#  endif /* 0 */

	/* undo damage to global variables */
	if (cf2 != NULL)
		*--cf2 = ',';
	if (kf2 != NULL)
		*--kf2 = ',';
# endif /* _FFR_TLS_1 */

	return ok;
}
/*
**  INITSRVTLS -- initialize server side TLS
**
**	Parameters:
**		none.
**
**	Returns:
**		succeeded?
**
**	Side Effects:
**		sets tls_ok_srv static, even when called from main()
*/

bool
initsrvtls()
{

	tls_ok_srv = inittls(&srv_ctx, TLS_I_SRV, TRUE, SrvCERTfile,
			     Srvkeyfile, CACERTpath, CACERTfile, DHParams);
	return tls_ok_srv;
}
/*
**  TLS_GET_INFO -- get information about TLS connection
**
**	Parameters:
**		ssl -- SSL connection structure
**		e -- current envelope
**		srv -- server or client
**		host -- hostname of other side
**		log -- log connection information?
**
**	Returns:
**		result of authentication.
**
**	Side Effects:
**		sets ${cipher}, ${tls_version}, ${verify}, ${cipher_bits},
**		${cert}
*/

int
tls_get_info(ssl, e, srv, host, log)
	SSL *ssl;
	ENVELOPE *e;
	bool srv;
	char *host;
	bool log;
{
	SSL_CIPHER *c;
	int b, r;
	char *s;
	char bitstr[16];
	X509 *cert;

	c = SSL_get_current_cipher(ssl);
	define(macid("{cipher}", NULL), newstr(SSL_CIPHER_get_name(c)), e);
	b = SSL_CIPHER_get_bits(c, &r);
	(void) snprintf(bitstr, sizeof bitstr, "%d", b);
	define(macid("{cipher_bits}", NULL), newstr(bitstr), e);
# if _FFR_TLS_1
	(void) snprintf(bitstr, sizeof bitstr, "%d", r);
	define(macid("{alg_bits}", NULL), newstr(bitstr), e);
# endif /* _FFR_TLS_1 */
	s = SSL_CIPHER_get_version(c);
	if (s == NULL)
		s = "UNKNOWN";
	define(macid("{tls_version}", NULL), newstr(s), e);

	cert = SSL_get_peer_certificate(ssl);
	if (log && LogLevel >= 14)
		sm_syslog(LOG_INFO, e->e_id,
			  "TLS: get_verify in %s: %ld get_peer: 0x%lx",
			  srv ? "srv" : "clt",
			  SSL_get_verify_result(ssl), (u_long) cert);
	if (cert != NULL)
	{
		char buf[MAXNAME];

		X509_NAME_oneline(X509_get_subject_name(cert),
				  buf, sizeof buf);
		define(macid("{cert_subject}", NULL),
			       newstr(xtextify(buf, "<>\")")), e);
		X509_NAME_oneline(X509_get_issuer_name(cert),
				  buf, sizeof buf);
		define(macid("{cert_issuer}", NULL),
		       newstr(xtextify(buf, "<>\")")), e);
# if _FFR_TLS_1
		X509_NAME_get_text_by_NID(X509_get_subject_name(cert),
					  NID_commonName, buf, sizeof buf);
		define(macid("{cn_subject}", NULL),
		       newstr(xtextify(buf, "<>\")")), e);
		X509_NAME_get_text_by_NID(X509_get_issuer_name(cert),
					  NID_commonName, buf, sizeof buf);
		define(macid("{cn_issuer}", NULL),
		       newstr(xtextify(buf, "<>\")")), e);
# endif /* _FFR_TLS_1 */
	}
	else
	{
		define(macid("{cert_subject}", NULL), "", e);
		define(macid("{cert_issuer}", NULL), "", e);
# if _FFR_TLS_1
		define(macid("{cn_subject}", NULL), "", e);
		define(macid("{cn_issuer}", NULL), "", e);
# endif /* _FFR_TLS_1 */
	}
	switch(SSL_get_verify_result(ssl))
	{
	  case X509_V_OK:
		if (cert != NULL)
		{
			s = "OK";
			r = TLS_AUTH_OK;
		}
		else
		{
			s = "NO";
			r = TLS_AUTH_NO;
		}
		break;
	  default:
		s = "FAIL";
		r = TLS_AUTH_FAIL;
		break;
	}
	define(macid("{verify}", NULL), newstr(s), e);
	if (cert != NULL)
		X509_free(cert);

	/* do some logging */
	if (log && LogLevel > 9)
	{
		char *vers, *s1, *s2, *bits;

		vers = macvalue(macid("{tls_version}", NULL), e);
		bits = macvalue(macid("{cipher_bits}", NULL), e);
		s1 = macvalue(macid("{verify}", NULL), e);
		s2 = macvalue(macid("{cipher}", NULL), e);
		sm_syslog(LOG_INFO, NOQID,
			  "TLS: connection %s %.64s, version=%.16s, verify=%.16s, cipher=%.64s, bits=%.6s",
			  srv ? "from" : "to",
			  host == NULL ? "none" : host,
			  vers == NULL ? "none" : vers,
			  s1 == NULL ? "none" : s1,
			  s2 == NULL ? "none" : s2,
			  bits == NULL ? "0" : bits);
		if (LogLevel > 11)
		{
			/*
			**  maybe run xuntextify on the strings?
			**  that is easier to read but makes it maybe a bit
			**  more complicated to figure out the right values
			**  for the access map...
			*/
			s1 = macvalue(macid("{cert_subject}", NULL), e);
			s2 = macvalue(macid("{cert_issuer}", NULL), e);
			sm_syslog(LOG_INFO, NOQID,
				  "TLS: %s cert subject:%.128s, cert issuer=%.128s",
				  srv ? "client" : "server",
				  s1 == NULL ? "none" : s1,
				  s2 == NULL ? "none" : s2);
		}
	}

	return r;
}

# if !TLS_NO_RSA
/*
**  TMP_RSA_KEY -- return temporary RSA key
**
**	Parameters:
**		s -- SSL connection structure
**		export --
**		keylength --
**
**	Returns:
**		temporary RSA key.
*/

/* ARGUSED0 */
static RSA *
tmp_rsa_key(s, export, keylength)
	SSL *s;
	int export;
	int keylength;
{
	return rsa_tmp;
}
# endif /* !TLS_NO_RSA */
/*
**  APPS_SSL_INFO_CB -- info callback for TLS connections
**
**	Parameters:
**		s -- SSL connection structure
**		where --
**		ret --
**
**	Returns:
**		none.
*/

void
apps_ssl_info_cb(s, where, ret)
	SSL *s;
	int where;
	int ret;
{
	char *str;
	int w;
	BIO *bio_err = NULL;

	if (LogLevel > 14)
		sm_syslog(LOG_INFO, NOQID,
			  "info_callback where 0x%x ret %d", where, ret);

	w = where & ~SSL_ST_MASK;
	if (bio_err == NULL)
		bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);

	if (w & SSL_ST_CONNECT)
		str = "SSL_connect";
	else if (w & SSL_ST_ACCEPT)
		str = "SSL_accept";
	else
		str = "undefined";

	if (where & SSL_CB_LOOP)
	{
		if (LogLevel > 12)
			sm_syslog(LOG_NOTICE, NOQID,
			"%s:%s\n", str, SSL_state_string_long(s));
	}
	else if (where & SSL_CB_ALERT)
	{
		str = (where & SSL_CB_READ) ? "read" : "write";
		if (LogLevel > 12)
			sm_syslog(LOG_NOTICE, NOQID,
		"SSL3 alert %s:%s:%s\n",
			   str, SSL_alert_type_string_long(ret),
			   SSL_alert_desc_string_long(ret));
	}
	else if (where & SSL_CB_EXIT)
	{
		if (ret == 0)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					"%s:failed in %s\n",
					str, SSL_state_string_long(s));
		}
		else if (ret < 0)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					"%s:error in %s\n",
					str, SSL_state_string_long(s));
		}
	}
}
/*
**  TLS_VERIFY_LOG -- log verify error for TLS certificates
**
**	Parameters:
**		ok -- verify ok?
**		ctx -- x509 context
**
**	Returns:
**		0 -- fatal error
**		1 -- ok
*/

static int
tls_verify_log(ok, ctx)
	int ok;
	X509_STORE_CTX *ctx;
{
	SSL *ssl;
	X509 *cert;
	int reason, depth;
	char buf[512];

	cert = X509_STORE_CTX_get_current_cert(ctx);
	reason = X509_STORE_CTX_get_error(ctx);
	depth = X509_STORE_CTX_get_error_depth(ctx);
	ssl = (SSL *)X509_STORE_CTX_get_ex_data(ctx,
			SSL_get_ex_data_X509_STORE_CTX_idx());

	if (ssl == NULL)
	{
		/* internal error */
		sm_syslog(LOG_ERR, NOQID,
			  "TLS: internal error: tls_verify_cb: ssl == NULL");
		return 0;
	}

	X509_NAME_oneline(X509_get_subject_name(cert), buf, sizeof buf);
	sm_syslog(LOG_INFO, NOQID,
		  "TLS cert verify: depth=%d %s, state=%d, reason=%s\n",
		  depth, buf, ok, X509_verify_cert_error_string(reason));
	return 1;
}

/*
**  TLS_VERIFY_CB -- verify callback for TLS certificates
**
**	Parameters:
**		ctx -- x509 context
**
**	Returns:
**		accept connection?
**		currently: always yes.
*/

static int
tls_verify_cb(ctx)
	X509_STORE_CTX *ctx;
{
	int ok;

	ok = X509_verify_cert(ctx);
	if (ok == 0)
	{
		if (LogLevel > 13)
			return tls_verify_log(ok, ctx);
		return 1;	/* override it */
	}
	return ok;
}


/*
**  TLSLOGERR -- log the errors from the TLS error stack
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
*/

void
tlslogerr()
{
	unsigned long l;
	int line, flags;
	unsigned long es;
	char *file, *data;
	char buf[256];
#define CP (const char **)

	es = CRYPTO_thread_id();
	while ((l = ERR_get_error_line_data(CP &file, &line, CP &data, &flags))
		!= 0)
	{
		sm_syslog(LOG_WARNING, NOQID,
			 "TLS: %lu:%s:%s:%d:%s\n", es, ERR_error_string(l, buf),
			 file, line, (flags & ERR_TXT_STRING) ? data : "");
	}
}

# endif /* STARTTLS */
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
static char id[] = "@@(#)$Sendmail: srvrsmtp.c,v 8.457 2000/02/26 07:24:59 gshapiro Exp $ (with SMTP)";
d20 1
a20 1
static char id[] = "@@(#)$Sendmail: srvrsmtp.c,v 8.457 2000/02/26 07:24:59 gshapiro Exp $ (without SMTP)";
d27 1
a27 1
static bool saslmechs __P((sasl_conn_t *, char **, bool));
d125 1
a125 1
# define MAXBADCOMMANDS	25	/* maximum number of bad commands */
d179 1
d191 1
d220 1
d278 3
d295 4
a298 1
			sasl_ok = saslmechs(conn, &mechlist, sasl_ok);
a333 1
		char *response;
d335 2
a336 2
		response = milter_connect(peerhostname, RealHostAddr,
					  e, &state);
d696 4
d811 1
a811 1
				message("334 %s", out2);
d1197 1
a1197 1
				    NULL, e, TRUE, TRUE) != EX_OK ||
d1390 1
a1390 1
				    NULL, e, TRUE, TRUE) != EX_OK ||
d1592 10
d1739 2
a1740 2
					    p, NULL, e, TRUE, FALSE) != EX_OK ||
				    Errors > 0)
d1797 1
a1797 1
			if (rscheck("check_etrn", p, NULL, e, TRUE, FALSE)
d2227 1
a2227 1
		     (rscheck("trust_auth", pbuf, NULL, e, TRUE, FALSE)
d2496 12
a2507 2
static bool
saslmechs(conn, mechlist, sasl_ok)
a2509 1
	bool sasl_ok;
d2513 13
a2525 1
	if (sasl_ok)
d2527 4
a2530 20
		/* "user" is currently unused */
		result = sasl_listmech(conn, "user", /* XXX */
				       "", " ", "", mechlist,
				       (u_int *)&len, (u_int *)&num);
		if (result == SASL_OK && num > 0)
		{
			if (LogLevel > 11)
				sm_syslog(LOG_INFO, NOQID,
					  "SASL: available mech=%s, allowed mech=%s",
					  *mechlist, AuthMechanisms);
			*mechlist = intersect(AuthMechanisms, *mechlist);
		}
		else
		{
			sasl_ok = FALSE;
			if (LogLevel > 9)
				sm_syslog(LOG_WARNING, NOQID,
					  "SASL error: listmech=%d, num=%d",
					  result, num);
		}
d2532 1
a2532 1
	return sasl_ok;
d2535 13
d2556 4
a2559 6
	if (user != NULL)
	{
		*user = newstr(auth_identity);
		return SASL_OK;
	}
	return SASL_FAIL;
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@a13 1

d18 1
a18 1
static char id[] = "@@(#)$Id: srvrsmtp.c,v 8.471.2.2.2.66 2000/12/18 18:00:44 ca Exp $ (with SMTP)";
d20 1
a20 1
static char id[] = "@@(#)$Id: srvrsmtp.c,v 8.471.2.2.2.66 2000/12/18 18:00:44 ca Exp $ (without SMTP)";
a24 3
# if SASL || STARTTLS
#  include "sfsasl.h"
# endif /* SASL || STARTTLS */
d27 1
a27 1
static int saslmechs __P((sasl_conn_t *, char **));
a28 20
# if STARTTLS
#  include <sysexits.h>
#   include <openssl/err.h>
#   include <openssl/bio.h>
#   include <openssl/pem.h>
#   ifndef HASURANDOMDEV
#    include <openssl/rand.h>
#   endif /* !HASURANDOMDEV */

static SSL	*srv_ssl = NULL;
static SSL_CTX	*srv_ctx = NULL;
#  if !TLS_NO_RSA
static RSA	*rsa = NULL;
#  endif /* !TLS_NO_RSA */
static bool	tls_ok = FALSE;
static int	tls_verify_cb __P((X509_STORE_CTX *));
#  if !TLS_NO_RSA
#   define RSA_KEYLENGTH	512
#  endif /* !TLS_NO_RSA */
# endif /* STARTTLS */
a77 3
# if STARTTLS
#  define CMDSTLS	14	/* STARTTLS -- start TLS session */
# endif /* STARTTLS */
a89 5
/*
**  Note: If you change this list,
**        remember to update 'helpfile'
*/

a113 3
# if STARTTLS
	{ "starttls",	CMDSTLS,	},
# endif /* STARTTLS */
d125 1
a125 1
# define MAXBADCOMMANDS		25	/* maximum number of bad commands */
a131 5
/* runinchild() returns */
# define RIC_INCHILD		0	/* in a child process */
# define RIC_INPARENT		1	/* still in parent process */
# define RIC_TEMPFAIL		2	/* temporary failure occurred */

a151 1
	int ric;
d167 1
a167 1
	volatile bool lognullconnection = TRUE;
a178 1
	volatile int n_auth = 0;	/* count of AUTH commands */
a189 1
	volatile int n_mechs;
a192 3
#  if SFIO
	sasl_ssf_t *ssf;
#  endif /* SFIO */
a193 8
# if STARTTLS
	int r;
	int rfd, wfd;
	volatile bool usetls = TRUE;
	volatile bool tls_active = FALSE;
	bool saveQuickAbort;
	bool saveSuprErrs;
# endif /* STARTTLS */
a217 1
	n_mechs = 0;
d222 1
a222 1
	/* use empty realm: only works in SASL > 1.5.5 */
a274 11
#  if SFIO
		/* XXX should these be options settable via .cf ? */
		/* ssp.min_ssf = 0; is default due to memset() */
		{
			ssp.max_ssf = INT_MAX;
			ssp.maxbufsize = MAXOUTLEN;
		}
#  endif /* SFIO */
#  if _FFR_SASL_OPTS
		ssp.security_flags = SASLOpts & SASL_SEC_MASK;
#  endif /* _FFR_SASL_OPTS */
a281 4
#   if STARTTLS
			**  we may have to change this for STARTTLS
			**  (dynamically)
#   endif
d289 1
a289 4
		{
			n_mechs = saslmechs(conn, &mechlist);
			sasl_ok = n_mechs > 0;
		}
a299 14
# if STARTTLS
#  if _FFR_TLS_O_T
	saveQuickAbort = QuickAbort;
	saveSuprErrs = SuprErrs;
	SuprErrs = TRUE;
	QuickAbort = FALSE;
	if (rscheck("offer_tls", CurSmtpClient, "", e, TRUE, FALSE, 8,
		    NULL) != EX_OK || Errors > 0)
		usetls = FALSE;
	QuickAbort = saveQuickAbort;
	SuprErrs = saveSuprErrs;
#  endif /* _FFR_TLS_O_T */
# endif /* STARTTLS */

d325 1
d327 2
a328 2
		(void) milter_connect(peerhostname, RealHostAddr,
				      e, &state);
d338 5
d365 1
a365 1
	message(cmdbuf, (int) (id - inp), inp, id);
a518 55
#  if SFIO
				/* get security strength (features) */
				result = sasl_getprop(conn, SASL_SSF,
						      (void **) &ssf);
				if (result != SASL_OK)
				{
					define(macid("{auth_ssf}", NULL),
					       "0", &BlankEnvelope);
					ssf = NULL;
				}
				else
				{
					char pbuf[8];

					snprintf(pbuf, sizeof pbuf, "%u", *ssf);
					define(macid("{auth_ssf}", NULL),
					       newstr(pbuf), &BlankEnvelope);
					if (tTd(95, 8))
						dprintf("SASL auth_ssf: %u\n",
							*ssf);
				}
				/*
				**  only switch to encrypted connection
				**  if a security layer has been negotiated
				*/
				if (ssf != NULL && *ssf > 0)
				{
					/*
					**  convert sfio stuff to use SASL
					**  check return values
					**  if the call fails,
					**  fall back to unencrypted version
					**  unless some cf option requires
					**  encryption then the connection must
					**  be aborted
					*/
					if (sfdcsasl(InChannel, OutChannel,
					    conn) == 0)
					{
						/* restart dialogue */
						gothello = FALSE;
						OneXact = TRUE;
						n_helo = 0;
					}
					else
						syserr("503 5.3.3 SASL TLS failed");
					if (LogLevel > 9)
						sm_syslog(LOG_INFO,
							  NOQID,
							  "SASL: connection from %.64s: mech=%.16s, id=%.64s, bits=%d",
							  CurSmtpClient,
							  auth_type, user,
							  *ssf);
				}
#  else /* SFIO */
a523 1
#  endif /* SFIO */
d604 1
a604 1
			if (strcasecmp(c->cmd_name, cmdbuf) == 0)
a685 10
			if (tempfail)
			{
				if (LogLevel > 9)
					sm_syslog(LOG_INFO, e->e_id,
						  "SMTP AUTH command (%.100s) from %.100s tempfailed (due to previous checks)",
						  p, CurSmtpClient);
				usrerr("454 4.7.1 Please try again later");
				break;
			}

a687 4
			/* crude way to avoid crack attempts */
			(void) checksmtpattack(&n_auth, n_mechs + 1, TRUE,
					       "AUTH", e);

a805 183
# if STARTTLS
		  case CMDSTLS: /* starttls */
			if (*p != '\0')
			{
				message("501 5.5.2 Syntax error (no parameters allowed)");
				break;
			}
			if (!usetls)
			{
				message("503 5.5.0 TLS not available");
				break;
			}
			if (!tls_ok)
			{
				message("454 4.3.3 TLS not available after start");
				break;
			}
			if (gotmail)
			{
				message("503 5.5.0 TLS not permitted during a mail transaction");
				break;
			}
			if (tempfail)
			{
				if (LogLevel > 9)
					sm_syslog(LOG_INFO, e->e_id,
						  "SMTP STARTTLS command (%.100s) from %.100s tempfailed (due to previous checks)",
						  p, CurSmtpClient);
				usrerr("454 4.7.1 Please try again later");
				break;
			}
# if TLS_NO_RSA
			/*
			**  XXX do we need a temp key ?
			*/
# else /* TLS_NO_RSA */
			if (SSL_CTX_need_tmp_RSA(srv_ctx) &&
			   !SSL_CTX_set_tmp_rsa(srv_ctx,
				(rsa = RSA_generate_key(RSA_KEYLENGTH, RSA_F4,
							NULL, NULL)))
			  )
			{
				message("454 4.3.3 TLS not available: error generating RSA temp key");
				if (rsa != NULL)
					RSA_free(rsa);
				break;
			}
# endif /* TLS_NO_RSA */
			if (srv_ssl != NULL)
				SSL_clear(srv_ssl);
			else if ((srv_ssl = SSL_new(srv_ctx)) == NULL)
			{
				message("454 4.3.3 TLS not available: error generating SSL handle");
				break;
			}
			rfd = fileno(InChannel);
			wfd = fileno(OutChannel);
			if (rfd < 0 || wfd < 0 ||
			    SSL_set_rfd(srv_ssl, rfd) <= 0 ||
			    SSL_set_wfd(srv_ssl, wfd) <= 0)
			{
				message("454 4.3.3 TLS not available: error set fd");
				SSL_free(srv_ssl);
				srv_ssl = NULL;
				break;
			}
			message("220 2.0.0 Ready to start TLS");
			SSL_set_accept_state(srv_ssl);

#  define SSL_ACC(s)	SSL_accept(s)
			if ((r = SSL_ACC(srv_ssl)) <= 0)
			{
				int i;

				/* what to do in this case? */
				i = SSL_get_error(srv_ssl, r);
				if (LogLevel > 5)
				{
					sm_syslog(LOG_WARNING, e->e_id,
						  "TLS: error: accept failed=%d (%d)",
						  r, i);
					if (LogLevel > 9)
						tlslogerr();
				}
				tls_ok = FALSE;
				SSL_free(srv_ssl);
				srv_ssl = NULL;

				/*
				**  according to the next draft of
				**  RFC 2487 the connection should be dropped
				*/

				/* arrange to ignore any current send list */
				e->e_sendqueue = NULL;
				goto doquit;
			}

			/* ignore return code for now, it's in {verify} */
			(void) tls_get_info(srv_ssl, &BlankEnvelope, TRUE,
					    CurSmtpClient, TRUE);

			/*
			**  call Stls_client to find out whether
			**  to accept the connection from the client
			*/

			saveQuickAbort = QuickAbort;
			saveSuprErrs = SuprErrs;
			SuprErrs = TRUE;
			QuickAbort = FALSE;
			if (rscheck("tls_client",
				     macvalue(macid("{verify}", NULL), e),
				     "STARTTLS", e, TRUE, TRUE, 6, NULL) !=
			    EX_OK || Errors > 0)
			{
				extern char MsgBuf[];

				if (MsgBuf[0] != '\0' && ISSMTPREPLY(MsgBuf))
					nullserver = newstr(MsgBuf);
				else
					nullserver = "503 5.7.0 Authentication required.";
			}
			QuickAbort = saveQuickAbort;
			SuprErrs = saveSuprErrs;

			tls_ok = FALSE;	/* don't offer STARTTLS again */
			gothello = FALSE;	/* discard info */
			n_helo = 0;
			OneXact = TRUE;	/* only one xaction this run */
#  if SASL
			if (sasl_ok)
			{
				char *s;

				if ((s = macvalue(macid("{cipher_bits}", NULL), e)) != NULL &&
				    (ext_ssf.ssf = atoi(s)) > 0)
				{
#  if _FFR_EXT_MECH
					ext_ssf.auth_id = macvalue(macid("{cert_subject}",
									 NULL),
								   e);
#  endif /* _FFR_EXT_MECH */
					sasl_ok = sasl_setprop(conn, SASL_SSF_EXTERNAL,
							       &ext_ssf) == SASL_OK;
					if (mechlist != NULL)
						free(mechlist);
					mechlist = NULL;
					if (sasl_ok)
					{
						n_mechs = saslmechs(conn,
								    &mechlist);
						sasl_ok = n_mechs > 0;
					}
				}
			}
#  endif /* SASL */

			/* switch to secure connection */
#if SFIO
			r = sfdctls(InChannel, OutChannel, srv_ssl);
#else /* SFIO */
# if _FFR_TLS_TOREK
			r = sfdctls(&InChannel, &OutChannel, srv_ssl);
# endif /* _FFR_TLS_TOREK */
#endif /* SFIO */
			if (r == 0)
				tls_active = TRUE;
			else
			{
				/*
				**  XXX this is an internal error
				**  how to deal with it?
				**  we can't generate an error message
				**  since the other side switched to an
				**  encrypted layer, but we could not...
				**  just "hang up"?
				*/
				nullserver = "454 4.3.3 TLS not available: can't switch to encrypted layer";
				syserr("TLS: can't switch to encrypted layer");
			}
			break;
# endif /* STARTTLS */
a884 2
			gothello = TRUE;

d891 1
a895 1
					nullserver = response;
d897 2
d902 1
d905 6
d914 1
d919 4
d926 2
d946 1
a946 8
			/*
			**  print EHLO features list
			**
			**  Note: If you change this list,
			**        remember to update 'helpfile'
			*/


a975 4
# if STARTTLS
			if (tls_ok && usetls)
				message("250-STARTTLS");
# endif /* STARTTLS */
a1007 3
			p = skipword(p, "from");
			if (p == NULL)
				break;
d1012 2
a1013 2
						  "SMTP MAIL command (%.100s) from %.100s tempfailed (due to previous checks)",
						  p, CurSmtpClient);
a1016 1

d1021 3
d1026 1
a1026 6
			ric = runinchild("SMTP-MAIL", e);

			/* Catch a problem and stop processing */
			if (ric == RIC_TEMPFAIL && nullserver == NULL)
				nullserver = "452 4.3.0 Internal software error";
			if (ric != RIC_INCHILD)
a1027 1

d1185 1
a1185 1
				    NULL, e, TRUE, TRUE, 4, NULL) != EX_OK ||
d1189 1
a1189 2
			if (MaxMessageSize > 0 &&
			   (e->e_msgsize > MaxMessageSize || e->e_msgsize < 0))
a1204 1
			LogUsrErrs = TRUE;
d1226 1
a1226 1
					usrerr("451 4.7.1 Please try again later");
d1378 1
a1378 1
				    NULL, e, TRUE, TRUE, 4, NULL) != EX_OK ||
d1404 1
a1404 1
					usrerr("451 4.7.1 Please try again later");
d1490 1
a1490 1
				response = milter_data(e, &state);
d1506 1
a1506 1
					usrerr("451 4.7.1 Please try again later");
a1579 10
			/*
			**  If a header/body check (header checks or milter)
			**  set EF_DISCARD, don't queueup the message --
			**  that would lose the EF_DISCARD bit and deliver
			**  the message.
			*/

			if (bitset(EF_DISCARD, e->e_flags))
				doublequeue = FALSE;

a1666 10
			if (tempfail)
			{
				if (LogLevel > 9)
					sm_syslog(LOG_INFO, e->e_id,
						  "SMTP %s command (%.100s) from %.100s tempfailed (due to previous checks)",
						  c->cmd_code == CMDVRFY ? "VRFY" : "EXPN",
						  p, CurSmtpClient);
				usrerr("550 5.7.1 Please try again later");
				break;
			}
d1717 2
a1718 2
					    p, NULL, e, TRUE, FALSE, 4, NULL)
				    != EX_OK || Errors > 0)
d1723 1
a1723 7
			{
				time_t t;

				t = wt - (curtime() - previous);
				if (t > 0)
					(void) sleep(t);
			}
d1741 1
a1741 1
				       (!QS_IS_UNDELIVERED(a->q_state)))
a1762 9
			if (tempfail)
			{
				if (LogLevel > 9)
					sm_syslog(LOG_INFO, e->e_id,
						  "SMTP ETRN command (%.100s) from %.100s tempfailed (due to previous checks)",
						  p, CurSmtpClient);
				usrerr("451 4.7.1 Please try again later");
				break;
			}
d1775 2
a1776 2
			if (rscheck("check_etrn", p, NULL, e, TRUE, FALSE, 4,
				    NULL) != EX_OK || Errors > 0)
a1821 8
# if STARTTLS
			/* shutdown TLS connection */
			if (tls_active)
			{
				(void) endtls(srv_ssl, "server");
				tls_active = FALSE;
			}
# endif /* STARTTLS */
d1956 1
a1956 1
**		time to wait.
d2074 3
d2078 1
a2078 5
		if (e->e_msgsize == LONG_MAX && errno == ERANGE)
		{
			usrerr("552 5.2.3 Message size exceeds maximum value");
			/* NOTREACHED */
		}
d2205 2
a2206 2
		     (rscheck("trust_auth", pbuf, NULL, e, TRUE, FALSE, 10,
			      NULL) != EX_OK || Errors > 0))
d2232 1
a2232 1
		usrerr("555 5.5.4 %s parameter unrecognized", kp);
d2321 1
a2321 1
		usrerr("555 5.5.4 %s parameter unrecognized", kp);
d2390 2
a2391 3
**		RIC_INCHILD in the child
**		RIC_INPARENT in the parent
**		RIC_TEMPFAIL tempfail condition
a2423 1

d2429 1
a2429 1
			return RIC_INPARENT;
a2441 1
			{
d2443 1
a2443 3
				       label, st & 0177);
				return RIC_TEMPFAIL;
			}
d2445 1
a2445 1
			/* if exited on a QUIT command, complete the process */
d2455 1
a2455 1
			return RIC_INPARENT;
d2469 1
a2469 1
	return RIC_INCHILD;
d2474 2
a2475 13
/*
**  SASLMECHS -- get list of possible AUTH mechanisms
**
**	Parameters:
**		conn -- SASL connection info
**		mechlist -- output parameter for list of mechanisms
**
**	Returns:
**		number of mechs
*/

static int
saslmechs(conn, mechlist)
d2478 1
d2482 1
a2482 5
	/* "user" is currently unused */
	result = sasl_listmech(conn, "user", /* XXX */
			       "", " ", "", mechlist,
			       (u_int *)&len, (u_int *)&num);
	if (result == SASL_OK && num > 0)
d2484 20
a2503 13
		if (LogLevel > 11)
			sm_syslog(LOG_INFO, NOQID,
				  "SASL: available mech=%s, allowed mech=%s",
				  *mechlist, AuthMechanisms);
		*mechlist = intersect(AuthMechanisms, *mechlist);
	}
	else
	{
		if (LogLevel > 9)
			sm_syslog(LOG_WARNING, NOQID,
				  "SASL error: listmech=%d, num=%d",
				  result, num);
		num = 0;
d2505 1
a2505 1
	return num;
a2507 14
/*
**  PROXY_POLICY -- define proxy policy for AUTH
**
**	Parameters:
**		conntext -- unused
**		auth_identity -- authentication identity
**		requested_user -- authorization identity
**		user -- allowed user (output)
**		errstr -- possible error string (output)
**
**	Returns:
**		ok?
*/

d2516 6
a2521 4
	if (user == NULL || auth_identity == NULL)
		return SASL_FAIL;
	*user = newstr(auth_identity);
	return SASL_OK;
a2525 1221
# if STARTTLS
#  if !TLS_NO_RSA
RSA *rsa_tmp;	/* temporary RSA key */
static RSA * tmp_rsa_key __P((SSL *, int, int));
#  endif /* !TLS_NO_RSA */

# if !NO_DH
static DH *get_dh512 __P((void));

static unsigned char dh512_p[] =
{
	0xDA,0x58,0x3C,0x16,0xD9,0x85,0x22,0x89,0xD0,0xE4,0xAF,0x75,
	0x6F,0x4C,0xCA,0x92,0xDD,0x4B,0xE5,0x33,0xB8,0x04,0xFB,0x0F,
	0xED,0x94,0xEF,0x9C,0x8A,0x44,0x03,0xED,0x57,0x46,0x50,0xD3,
	0x69,0x99,0xDB,0x29,0xD7,0x76,0x27,0x6B,0xA2,0xD3,0xD4,0x12,
	0xE2,0x18,0xF4,0xDD,0x1E,0x08,0x4C,0xF6,0xD8,0x00,0x3E,0x7C,
	0x47,0x74,0xE8,0x33
};
static unsigned char dh512_g[] =
{
	0x02
};

static DH *
get_dh512()
{
	DH *dh = NULL;

	if ((dh = DH_new()) == NULL)
		return(NULL);
	dh->p = BN_bin2bn(dh512_p, sizeof(dh512_p), NULL);
	dh->g = BN_bin2bn(dh512_g, sizeof(dh512_g), NULL);
	if ((dh->p == NULL) || (dh->g == NULL))
		return(NULL);
	return(dh);
}
# endif /* !NO_DH */

/*
**  TLS_RAND_INIT -- initialize STARTTLS random generator
**
**	Parameters:
**		randfile -- name of file with random data
**		logl -- loglevel
**
**	Returns:
**		success/failure
**
**	Side Effects:
**		initializes PRNG for tls library.
*/

#define MIN_RAND_BYTES	16	/* 128 bits */

bool
tls_rand_init(randfile, logl)
	char *randfile;
	int logl;
{
# ifndef HASURANDOMDEV
	/* not required if /dev/urandom exists, OpenSSL does it internally */

#define RF_OK		0	/* randfile OK */
#define RF_MISS		1	/* randfile == NULL || *randfile == '\0' */
#define RF_UNKNOWN	2	/* unknown prefix for randfile */

#define RI_NONE		0	/* no init yet */
#define RI_SUCCESS	1	/* init was successful */
#define RI_FAIL		2	/* init failed */

	bool ok;
	int randdef;
	static int done = RI_NONE;

	/*
	**  initialize PRNG
	*/

	/* did we try this before? if yes: return old value */
	if (done != RI_NONE)
		return done == RI_SUCCESS;

	/* set default values */
	ok = FALSE;
	done = RI_FAIL;
	randdef = (randfile == NULL || *randfile == '\0') ? RF_MISS : RF_OK;
#   if EGD
	if (randdef == RF_OK && strncasecmp(randfile, "egd:", 4) == 0)
	{
		randfile += 4;
		if (RAND_egd(randfile) < 0)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: RAND_egd(%s) failed: random number generator not seeded",
				   randfile);
		}
		else
			ok = TRUE;
	}
	else
#   endif /* EGD */
	if (randdef == RF_OK && strncasecmp(randfile, "file:", 5) == 0)
	{
		int fd;
		long sff;
		struct stat st;

		randfile += 5;
		sff = SFF_SAFEDIRPATH | SFF_NOWLINK
		      | SFF_NOGWFILES | SFF_NOWWFILES
		      | SFF_NOGRFILES | SFF_NOWRFILES
		      | SFF_MUSTOWN | SFF_ROOTOK | SFF_OPENASROOT;
		if ((fd = safeopen(randfile, O_RDONLY, 0, sff)) >= 0)
		{
			if (fstat(fd, &st) < 0)
			{
				if (LogLevel > logl)
					sm_syslog(LOG_ERR, NOQID,
						  "TLS: can't fstat(%s)",
						  randfile);
			}
			else
			{
				bool use, problem;

				use = TRUE;
				problem = FALSE;
				if (st.st_mtime + 600 < curtime())
				{
					use = bitnset(DBS_INSUFFICIENTENTROPY,
						      DontBlameSendmail);
					problem = TRUE;
					if (LogLevel > logl)
						sm_syslog(LOG_ERR, NOQID,
							  "TLS: RandFile %s too old: %s",
							  randfile,
							  use ? "unsafe" :
								"unusable");
				}
				if (use && st.st_size < MIN_RAND_BYTES)
				{
					use = bitnset(DBS_INSUFFICIENTENTROPY,
						      DontBlameSendmail);
					problem = TRUE;
					if (LogLevel > logl)
						sm_syslog(LOG_ERR, NOQID,
							  "TLS: size(%s) < %d: %s",
							  randfile,
							  MIN_RAND_BYTES,
							  use ? "unsafe" :
								"unusable");
				}
				if (use)
					ok = RAND_load_file(randfile, -1) >=
					     MIN_RAND_BYTES;
				if (use && !ok)
				{
					if (LogLevel > logl)
						sm_syslog(LOG_WARNING,
							  NOQID,
							  "TLS: RAND_load_file(%s) failed: random number generator not seeded",
							  randfile);
				}
				if (problem)
					ok = FALSE;
			}
			if (ok || bitnset(DBS_INSUFFICIENTENTROPY,
					  DontBlameSendmail))
			{
				/* add this even if fstat() failed */
				RAND_seed((void *) &st, sizeof st);
			}
			(void) close(fd);
		}
		else
		{
			if (LogLevel > logl)
				sm_syslog(LOG_WARNING, NOQID,
					  "TLS: Warning: safeopen(%s) failed",
					  randfile);
		}
	}
	else if (randdef == RF_OK)
	{
		if (LogLevel > logl)
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: Error: no proper random file definition %s",
				  randfile);
		randdef = RF_UNKNOWN;
	}
	if (randdef == RF_MISS)
	{
		if (LogLevel > logl)
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: Error: missing random file definition");
	}
	if (!ok && bitnset(DBS_INSUFFICIENTENTROPY, DontBlameSendmail))
	{
		int i;
		long r;
		unsigned char buf[MIN_RAND_BYTES];

		/* assert((MIN_RAND_BYTES % sizeof(long)) == 0); */
		for (i = 0; i <= sizeof(buf) - sizeof(long); i += sizeof(long))
		{
			r = get_random();
			(void) memcpy(buf + i, (void *) &r, sizeof(long));
		}
		RAND_seed(buf, sizeof buf);
		if (LogLevel > logl)
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: Warning: random number generator not properly seeded");
		ok = TRUE;
	}
	done = ok ? RI_SUCCESS : RI_FAIL;
	return ok;
# else /* !HASURANDOMDEV */
	return TRUE;
# endif /* !HASURANDOMDEV */
}

/*
**  status in initialization
**  these flags keep track of the status of the initialization
**  i.e., whether a file exists (_EX) and whether it can be used (_OK)
**  [due to permissions]
*/
#define TLS_S_NONE	0x00000000	/* none yet  */
#define TLS_S_CERT_EX	0x00000001	/* CERT file exists */
#define TLS_S_CERT_OK	0x00000002	/* CERT file is ok */
#define TLS_S_KEY_EX	0x00000004	/* KEY file exists */
#define TLS_S_KEY_OK	0x00000008	/* KEY file is ok */
#define TLS_S_CERTP_EX	0x00000010	/* CA CERT PATH exists */
#define TLS_S_CERTP_OK	0x00000020	/* CA CERT PATH is ok */
#define TLS_S_CERTF_EX	0x00000040	/* CA CERT FILE exists */
#define TLS_S_CERTF_OK	0x00000080	/* CA CERT FILE is ok */

# if _FFR_TLS_1
#define TLS_S_CERT2_EX	0x00001000	/* 2nd CERT file exists */
#define TLS_S_CERT2_OK	0x00002000	/* 2nd CERT file is ok */
#define TLS_S_KEY2_EX	0x00004000	/* 2nd KEY file exists */
#define TLS_S_KEY2_OK	0x00008000	/* 2nd KEY file is ok */
# endif /* _FFR_TLS_1 */

#define TLS_S_DH_OK	0x00200000	/* DH cert is ok */
#define TLS_S_DHPAR_EX	0x00400000	/* DH param file exists */
#define TLS_S_DHPAR_OK	0x00800000	/* DH param file is ok to use */

/*
**  TLS_OK_F -- can var be an absolute filename?
**
**	Parameters:
**		var -- filename
**		fn -- what is the filename used for?
**
**	Returns:
**		ok?
*/

static bool
tls_ok_f(var, fn)
	char *var;
	char *fn;
{
	/* must be absolute pathname */
	if (var != NULL && *var == '/')
		return TRUE;
	if (LogLevel > 12)
		sm_syslog(LOG_WARNING, NOQID, "TLS: file %s missing", fn);
	return FALSE;
}

/*
**  TLS_SAFE_F -- is a file safe to use?
**
**	Parameters:
**		var -- filename
**		sff -- flags for safefile()
**
**	Returns:
**		ok?
*/

static bool
tls_safe_f(var, sff)
	char *var;
	long sff;
{
	int ret;

	if ((ret = safefile(var, RunAsUid, RunAsGid, RunAsUserName, sff,
			    S_IRUSR, NULL)) == 0)
		return TRUE;
	if (LogLevel > 7)
		sm_syslog(LOG_WARNING, NOQID, "TLS: file %s unsafe: %s",
			  var, errstring(ret));
	return FALSE;
}

/*
**  TLS_OK_F -- macro to simplify calls to tls_ok_f
**
**	Parameters:
**		var -- filename
**		fn -- what is the filename used for?
**		req -- is the file required?
**		st -- status bit to set if ok
**
**	Side Effects:
**		uses r, ok; may change ok and status.
**
*/

#define TLS_OK_F(var, fn, req, st) if (ok) \
	{ \
		r = tls_ok_f(var, fn); \
		if (r) \
			status |= st; \
		else if (req) \
			ok = FALSE; \
	}

/*
**  TLS_UNR -- macro to return whether a file should be unreadable
**
**	Parameters:
**		bit -- flag to test
**		req -- flags
**
**	Returns:
**		0/SFF_NORFILES
*/
#define TLS_UNR(bit, req)	(bitset(bit, req) ? SFF_NORFILES : 0)

/*
**  TLS_SAFE_F -- macro to simplify calls to tls_safe_f
**
**	Parameters:
**		var -- filename
**		sff -- flags for safefile()
**		req -- is the file required?
**		ex -- does the file exist?
**		st -- status bit to set if ok
**
**	Side Effects:
**		uses r, ok, ex; may change ok and status.
**
*/

#define TLS_SAFE_F(var, sff, req, ex, st) if (ex && ok) \
	{ \
		r = tls_safe_f(var, sff); \
		if (r) \
			status |= st;	\
		else if (req) \
			ok = FALSE;	\
	}

/*
**  INITTLS -- initialize TLS
**
**	Parameters:
**		ctx -- pointer to context
**		req -- requirements for initialization (see sendmail.h)
**		srv -- server side?
**		certfile -- filename of certificate
**		keyfile -- filename of private key
**		cacertpath -- path to CAs
**		cacertfile -- file with CA
**		dhparam -- parameters for DH
**
**	Returns:
**		succeeded?
*/

bool
inittls(ctx, req, srv, certfile, keyfile, cacertpath, cacertfile, dhparam)
	SSL_CTX **ctx;
	u_long req;
	bool srv;
	char *certfile, *keyfile, *cacertpath, *cacertfile, *dhparam;
{
# if !NO_DH
	static DH *dh = NULL;
# endif /* !NO_DH */
	int r;
	bool ok;
	long sff, status;
	char *who;
# if _FFR_TLS_1
	char *cf2, *kf2;
# endif /* _FFR_TLS_1 */

	status = TLS_S_NONE;
	who = srv ? "srv" : "clt";
	if (ctx == NULL)
		syserr("TLS: %s:inittls: ctx == NULL", who);

	/* already initialized? (we could re-init...) */
	if (*ctx != NULL)
		return TRUE;

	/* PRNG seeded? */
	if (!tls_rand_init(RandFile, 10))
		return FALSE;

	/* let's start with the assumption it will work */
	ok = TRUE;

# if _FFR_TLS_1
	/*
	**  look for a second filename: it must be separated by a ','
	**  no blanks allowed (they won't be skipped).
	**  we change a global variable here! this change will be undone
	**  before return from the function but only if it returns TRUE.
	**  this isn't a problem since in a failure case this function
	**  won't be called again with the same (overwritten) values.
	**  otherwise each return must be replaced with a goto endinittls.
	*/
	cf2 = NULL;
	kf2 = NULL;
	if (certfile != NULL && (cf2 = strchr(certfile, ',')) != NULL)
	{
		*cf2++ = '\0';
		if (keyfile != NULL && (kf2 = strchr(keyfile, ',')) != NULL)
			*kf2++ = '\0';
	}
# endif /* _FFR_TLS_1 */

	/*
	**  what do we require from the client?
	**  must it have CERTs?
	**  introduce an option and decide based on that
	*/

	TLS_OK_F(certfile, "CertFile", bitset(TLS_I_CERT_EX, req),
		 TLS_S_CERT_EX);
	TLS_OK_F(keyfile, "KeyFile", bitset(TLS_I_KEY_EX, req),
		 TLS_S_KEY_EX);
	TLS_OK_F(cacertpath, "CACERTPath", bitset(TLS_I_CERTP_EX, req),
		 TLS_S_CERTP_EX);
	TLS_OK_F(cacertfile, "CACERTFile", bitset(TLS_I_CERTF_EX, req),
		 TLS_S_CERTF_EX);

# if _FFR_TLS_1
	if (cf2 != NULL)
	{
		TLS_OK_F(cf2, "CertFile", bitset(TLS_I_CERT_EX, req),
			 TLS_S_CERT2_EX);
	}
	if (kf2 != NULL)
	{
		TLS_OK_F(kf2, "KeyFile", bitset(TLS_I_KEY_EX, req),
			 TLS_S_KEY2_EX);
	}
# endif /* _FFR_TLS_1 */

	/*
	**  valid values for dhparam are (only the first char is checked)
	**  none	no parameters: don't use DH
	**  512		generate 512 bit parameters (fixed)
	**  1024	generate 1024 bit parameters
	**  /file/name	read parameters from /file/name
	**  default is: 1024 for server, 512 for client (OK? XXX)
	*/
	if (bitset(TLS_I_TRY_DH, req))
	{
		if (dhparam != NULL)
		{
			char c = *dhparam;

			if (c == '1')
				req |= TLS_I_DH1024;
			else if (c == '5')
				req |= TLS_I_DH512;
			else if (c != 'n' && c != 'N' && c != '/')
			{
				if (LogLevel > 12)
					sm_syslog(LOG_WARNING, NOQID,
						  "TLS: error: illegal value '%s' for DHParam",
						  dhparam);
				dhparam = NULL;
			}
		}
		if (dhparam == NULL)
			dhparam = srv ? "1" : "5";
		else if (*dhparam == '/')
		{
			TLS_OK_F(dhparam, "DHParameters",
				 bitset(TLS_I_DHPAR_EX, req),
				 TLS_S_DHPAR_EX);
		}
	}
	if (!ok)
		return ok;

	/* certfile etc. must be "safe". */
	sff = SFF_REGONLY | SFF_SAFEDIRPATH | SFF_NOWLINK
	     | SFF_NOGWFILES | SFF_NOWWFILES
	     | SFF_MUSTOWN | SFF_ROOTOK | SFF_OPENASROOT;
	if (DontLockReadFiles)
		sff |= SFF_NOLOCK;

	TLS_SAFE_F(certfile, sff | TLS_UNR(TLS_I_CERT_UNR, req),
		   bitset(TLS_I_CERT_EX, req),
		   bitset(TLS_S_CERT_EX, status), TLS_S_CERT_OK);
	TLS_SAFE_F(keyfile, sff | TLS_UNR(TLS_I_KEY_UNR, req),
		   bitset(TLS_I_KEY_EX, req),
		   bitset(TLS_S_KEY_EX, status), TLS_S_KEY_OK);
	TLS_SAFE_F(cacertfile, sff | TLS_UNR(TLS_I_CERTF_UNR, req),
		   bitset(TLS_I_CERTF_EX, req),
		   bitset(TLS_S_CERTF_EX, status), TLS_S_CERTF_OK);
	TLS_SAFE_F(dhparam, sff | TLS_UNR(TLS_I_DHPAR_UNR, req),
		   bitset(TLS_I_DHPAR_EX, req),
		   bitset(TLS_S_DHPAR_EX, status), TLS_S_DHPAR_OK);
	if (!ok)
		return ok;
# if _FFR_TLS_1
	if (cf2 != NULL)
	{
		TLS_SAFE_F(cf2, sff | TLS_UNR(TLS_I_CERT_UNR, req),
			   bitset(TLS_I_CERT_EX, req),
			   bitset(TLS_S_CERT2_EX, status), TLS_S_CERT2_OK);
	}
	if (kf2 != NULL)
	{
		TLS_SAFE_F(kf2, sff | TLS_UNR(TLS_I_KEY_UNR, req),
			   bitset(TLS_I_KEY_EX, req),
			   bitset(TLS_S_KEY2_EX, status), TLS_S_KEY2_OK);
	}
# endif /* _FFR_TLS_1 */

	/* create a method and a new context */
	if (srv)
	{
		if ((*ctx = SSL_CTX_new(SSLv23_server_method())) == NULL)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					  "TLS: error: SSL_CTX_new(SSLv23_server_method()) failed");
			return FALSE;
		}
	}
	else
	{
		if ((*ctx = SSL_CTX_new(SSLv23_client_method())) == NULL)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					  "TLS: error: SSL_CTX_new(SSLv23_client_method()) failed");
			return FALSE;
		}
	}

#  if TLS_NO_RSA
	/* turn off backward compatibility, required for no-rsa */
	SSL_CTX_set_options(*ctx, SSL_OP_NO_SSLv2);
#  endif /* TLS_NO_RSA */


#  if !TLS_NO_RSA
	/*
	**  Create a temporary RSA key
	**  XXX  Maybe we shouldn't create this always (even though it
	**  is only at startup).
	**  It is a time-consuming operation and it is not always necessary.
	**  maybe we should do it only on demand...
	*/
	if (bitset(TLS_I_RSA_TMP, req) &&
	    (rsa_tmp = RSA_generate_key(RSA_KEYLENGTH, RSA_F4, NULL,
					NULL)) == NULL
	   )
	{
		if (LogLevel > 7)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: error: %s: RSA_generate_key failed",
				  who);
			if (LogLevel > 9)
				tlslogerr();
		}
		return FALSE;
	}
#  endif /* !TLS_NO_RSA */

	/*
	**  load private key
	**  XXX change this for DSA-only version
	*/
	if (bitset(TLS_S_KEY_OK, status) &&
	    SSL_CTX_use_PrivateKey_file(*ctx, keyfile,
					 SSL_FILETYPE_PEM) <= 0)
	{
		if (LogLevel > 7)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: error: %s: SSL_CTX_use_PrivateKey_file(%s) failed",
				  who, keyfile);
			if (LogLevel > 9)
				tlslogerr();
		}
		if (bitset(TLS_I_USE_KEY, req))
			return FALSE;
	}

	/* get the certificate file */
	if (bitset(TLS_S_CERT_OK, status) &&
	    SSL_CTX_use_certificate_file(*ctx, certfile,
					 SSL_FILETYPE_PEM) <= 0)
	{
		if (LogLevel > 7)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: error: %s: SSL_CTX_use_certificate_file(%s) failed",
				  who, certfile);
			if (LogLevel > 9)
				tlslogerr();
		}
		if (bitset(TLS_I_USE_CERT, req))
			return FALSE;
	}

	/* check the private key */
	if (bitset(TLS_S_KEY_OK, status) &&
	    (r = SSL_CTX_check_private_key(*ctx)) <= 0)
	{
		/* Private key does not match the certificate public key */
		if (LogLevel > 5)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: error: %s: SSL_CTX_check_private_key failed(%s): %d",
				  who, keyfile, r);
			if (LogLevel > 9)
				tlslogerr();
		}
		if (bitset(TLS_I_USE_KEY, req))
			return FALSE;
	}

# if _FFR_TLS_1
	/* XXX this code is pretty much duplicated from above! */

	/* load private key */
	if (bitset(TLS_S_KEY2_OK, status) &&
	    SSL_CTX_use_PrivateKey_file(*ctx, kf2, SSL_FILETYPE_PEM) <= 0)
	{
		if (LogLevel > 7)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: error: %s: SSL_CTX_use_PrivateKey_file(%s) failed",
				  who, kf2);
			if (LogLevel > 9)
				tlslogerr();
		}
	}

	/* get the certificate file */
	if (bitset(TLS_S_CERT2_OK, status) &&
	    SSL_CTX_use_certificate_file(*ctx, cf2, SSL_FILETYPE_PEM) <= 0)
	{
		if (LogLevel > 7)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: error: %s: SSL_CTX_use_certificate_file(%s) failed",
				  who, cf2);
			if (LogLevel > 9)
				tlslogerr();
		}
	}

	/* we should also check the private key: */
	if (bitset(TLS_S_KEY2_OK, status) &&
	    (r = SSL_CTX_check_private_key(*ctx)) <= 0)
	{
		/* Private key does not match the certificate public key */
		if (LogLevel > 5)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "TLS: error: %s: SSL_CTX_check_private_key 2 failed: %d",
				  who, r);
			if (LogLevel > 9)
				tlslogerr();
		}
	}
# endif /* _FFR_TLS_1 */

	/* SSL_CTX_set_quiet_shutdown(*ctx, 1); violation of standard? */
	SSL_CTX_set_options(*ctx, SSL_OP_ALL);	/* XXX bug compatibility? */

# if !NO_DH
	/* Diffie-Hellman initialization */
	if (bitset(TLS_I_TRY_DH, req))
	{
		if (bitset(TLS_S_DHPAR_OK, status))
		{
			BIO *bio;

			if ((bio = BIO_new_file(dhparam, "r")) != NULL)
			{
				dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);
				BIO_free(bio);
				if (dh == NULL && LogLevel > 7)
				{
					u_long err;

					err = ERR_get_error();
					sm_syslog(LOG_WARNING, NOQID,
						  "TLS: error: %s: cannot read DH parameters(%s): %s",
						  who, dhparam,
						  ERR_error_string(err, NULL));
					if (LogLevel > 9)
						tlslogerr();
				}
			}
			else
			{
				if (LogLevel > 5)
				{
					sm_syslog(LOG_WARNING, NOQID,
						  "TLS: error: %s: BIO_new_file(%s) failed",
						  who, dhparam);
					if (LogLevel > 9)
						tlslogerr();
				}
			}
		}
		if (dh == NULL && bitset(TLS_I_DH1024, req))
		{
			DSA *dsa;

			/* this takes a while! (7-130s on a 450MHz AMD K6-2) */
			dsa = DSA_generate_parameters(1024, NULL, 0, NULL,
						      NULL, 0, NULL);
			dh = DSA_dup_DH(dsa);
			DSA_free(dsa);
		}
		else
		if (dh == NULL && bitset(TLS_I_DH512, req))
			dh = get_dh512();

		if (dh == NULL)
		{
			if (LogLevel > 9)
			{
				u_long err;

				err = ERR_get_error();
				sm_syslog(LOG_WARNING, NOQID,
					  "TLS: error: %s: cannot read or set DH parameters(%s): %s",
					  who, dhparam,
					  ERR_error_string(err, NULL));
			}
			if (bitset(TLS_I_REQ_DH, req))
				return FALSE;
		}
		else
		{
			SSL_CTX_set_tmp_dh(*ctx, dh);

			/* important to avoid small subgroup attacks */
			SSL_CTX_set_options(*ctx, SSL_OP_SINGLE_DH_USE);
			if (LogLevel > 12)
				sm_syslog(LOG_INFO, NOQID,
					  "TLS: %s: Diffie-Hellman init, key=%d bit (%c)",
					  who, 8 * DH_size(dh), *dhparam);
			DH_free(dh);
		}
	}
# endif /* !NO_DH */


	/* XXX do we need this cache here? */
	if (bitset(TLS_I_CACHE, req))
		SSL_CTX_sess_set_cache_size(*ctx, 128);
	/* timeout? SSL_CTX_set_timeout(*ctx, TimeOut...); */

	/* load certificate locations and default CA paths */
	if (bitset(TLS_S_CERTP_EX, status) && bitset(TLS_S_CERTF_EX, status))
	{
		if ((r = SSL_CTX_load_verify_locations(*ctx, cacertfile,
						       cacertpath)) == 1)
		{
#  if !TLS_NO_RSA
			if (bitset(TLS_I_RSA_TMP, req))
				SSL_CTX_set_tmp_rsa_callback(*ctx, tmp_rsa_key);
#  endif /* !TLS_NO_RSA */

			/* ask to verify the peer */
			SSL_CTX_set_verify(*ctx, SSL_VERIFY_PEER, NULL);

			/* install verify callback */
			SSL_CTX_set_cert_verify_callback(*ctx, tls_verify_cb,
							 NULL);
			SSL_CTX_set_client_CA_list(*ctx,
				SSL_load_client_CA_file(cacertfile));
		}
		else
		{
			/*
			**  can't load CA data; do we care?
			**  the data is necessary to authenticate the client,
			**  which in turn would be necessary
			**  if we want to allow relaying based on it.
			*/
			if (LogLevel > 5)
			{
				sm_syslog(LOG_WARNING, NOQID,
					  "TLS: error: %s: %d load verify locs %s, %s",
					  who, r, cacertpath, cacertfile);
				if (LogLevel > 9)
					tlslogerr();
			}
			if (bitset(TLS_I_VRFY_LOC, req))
				return FALSE;
		}
	}

	/* XXX: make this dependent on an option? */
	if (tTd(96, 9))
		SSL_CTX_set_info_callback(*ctx, apps_ssl_info_cb);

#  if _FFR_TLS_1
	/*
	**  XXX install our own cipher list: option?
	*/
	if (CipherList != NULL && *CipherList != '\0')
	{
		if (SSL_CTX_set_cipher_list(*ctx, CipherList) <= 0)
		{
			if (LogLevel > 7)
			{
				sm_syslog(LOG_WARNING, NOQID,
					  "TLS: error: %s: SSL_CTX_set_cipher_list(%s) failed, list ignored",
					  who, CipherList);

				if (LogLevel > 9)
					tlslogerr();
			}
			/* failure if setting to this list is required? */
		}
	}
#  endif /* _FFR_TLS_1 */
	if (LogLevel > 12)
		sm_syslog(LOG_INFO, NOQID, "TLS: init(%s)=%d", who, ok);

# if _FFR_TLS_1
#  if 0
	/*
	**  this label is required if we want to have a "clean" exit
	**  see the comments above at the initialization of cf2
	*/
    endinittls:
#  endif /* 0 */

	/* undo damage to global variables */
	if (cf2 != NULL)
		*--cf2 = ',';
	if (kf2 != NULL)
		*--kf2 = ',';
# endif /* _FFR_TLS_1 */

	return ok;
}
/*
**  INITSRVTLS -- initialize server side TLS
**
**	Parameters:
**		none.
**
**	Returns:
**		succeeded?
*/

bool
initsrvtls()
{

	tls_ok = inittls(&srv_ctx, TLS_I_SRV, TRUE, SrvCERTfile, Srvkeyfile,
			 CACERTpath, CACERTfile, DHParams);
	return tls_ok;
}
/*
**  TLS_GET_INFO -- get information about TLS connection
**
**	Parameters:
**		ssl -- SSL connection structure
**		e -- current envelope
**		srv -- server or client
**		host -- hostname of other side
**		log -- log connection information?
**
**	Returns:
**		result of authentication.
**
**	Side Effects:
**		sets ${cipher}, ${tls_version}, ${verify}, ${cipher_bits},
**		${cert}
*/

int
tls_get_info(ssl, e, srv, host, log)
	SSL *ssl;
	ENVELOPE *e;
	bool srv;
	char *host;
	bool log;
{
	SSL_CIPHER *c;
	int b, r;
	char *s;
	char bitstr[16];
	X509 *cert;

	c = SSL_get_current_cipher(ssl);
	define(macid("{cipher}", NULL), newstr(SSL_CIPHER_get_name(c)), e);
	b = SSL_CIPHER_get_bits(c, &r);
	(void) snprintf(bitstr, sizeof bitstr, "%d", b);
	define(macid("{cipher_bits}", NULL), newstr(bitstr), e);
# if _FFR_TLS_1
	(void) snprintf(bitstr, sizeof bitstr, "%d", r);
	define(macid("{alg_bits}", NULL), newstr(bitstr), e);
# endif /* _FFR_TLS_1 */
	s = SSL_CIPHER_get_version(c);
	if (s == NULL)
		s = "UNKNOWN";
	define(macid("{tls_version}", NULL), newstr(s), e);

	cert = SSL_get_peer_certificate(ssl);
	if (log && LogLevel >= 14)
		sm_syslog(LOG_INFO, e->e_id,
			  "TLS: get_verify in %s: %ld get_peer: 0x%lx",
			  srv ? "srv" : "clt",
			  SSL_get_verify_result(ssl), (u_long) cert);
	if (cert != NULL)
	{
		char buf[MAXNAME];

		X509_NAME_oneline(X509_get_subject_name(cert),
				  buf, sizeof buf);
		define(macid("{cert_subject}", NULL),
			       newstr(xtextify(buf, "<>\")")), e);
		X509_NAME_oneline(X509_get_issuer_name(cert),
				  buf, sizeof buf);
		define(macid("{cert_issuer}", NULL),
		       newstr(xtextify(buf, "<>\")")), e);
# if _FFR_TLS_1
		X509_NAME_get_text_by_NID(X509_get_subject_name(cert),
					  NID_commonName, buf, sizeof buf);
		define(macid("{cn_subject}", NULL),
		       newstr(xtextify(buf, "<>\")")), e);
		X509_NAME_get_text_by_NID(X509_get_issuer_name(cert),
					  NID_commonName, buf, sizeof buf);
		define(macid("{cn_issuer}", NULL),
		       newstr(xtextify(buf, "<>\")")), e);
# endif /* _FFR_TLS_1 */
	}
	else
	{
		define(macid("{cert_subject}", NULL), "", e);
		define(macid("{cert_issuer}", NULL), "", e);
# if _FFR_TLS_1
		define(macid("{cn_subject}", NULL), "", e);
		define(macid("{cn_issuer}", NULL), "", e);
# endif /* _FFR_TLS_1 */
	}
	switch(SSL_get_verify_result(ssl))
	{
	  case X509_V_OK:
		if (cert != NULL)
		{
			s = "OK";
			r = TLS_AUTH_OK;
		}
		else
		{
			s = "NO";
			r = TLS_AUTH_NO;
		}
		break;
	  default:
		s = "FAIL";
		r = TLS_AUTH_FAIL;
		break;
	}
	define(macid("{verify}", NULL), newstr(s), e);
	if (cert != NULL)
		X509_free(cert);

	/* do some logging */
	if (log && LogLevel > 9)
	{
		char *vers, *s1, *s2, *bits;

		vers = macvalue(macid("{tls_version}", NULL), e);
		bits = macvalue(macid("{cipher_bits}", NULL), e);
		s1 = macvalue(macid("{verify}", NULL), e);
		s2 = macvalue(macid("{cipher}", NULL), e);
		sm_syslog(LOG_INFO, NOQID,
			  "TLS: connection %s %.64s, version=%.16s, verify=%.16s, cipher=%.64s, bits=%.6s",
			  srv ? "from" : "to",
			  host == NULL ? "none" : host,
			  vers == NULL ? "none" : vers,
			  s1 == NULL ? "none" : s1,
			  s2 == NULL ? "none" : s2,
			  bits == NULL ? "0" : bits);
		if (LogLevel > 11)
		{
			/*
			**  maybe run xuntextify on the strings?
			**  that is easier to read but makes it maybe a bit
			**  more complicated to figure out the right values
			**  for the access map...
			*/
			s1 = macvalue(macid("{cert_subject}", NULL), e);
			s2 = macvalue(macid("{cert_issuer}", NULL), e);
			sm_syslog(LOG_INFO, NOQID,
				  "TLS: %s cert subject:%.128s, cert issuer=%.128s",
				  srv ? "client" : "server",
				  s1 == NULL ? "none" : s1,
				  s2 == NULL ? "none" : s2);
		}
	}

	return r;
}

# if !TLS_NO_RSA
/*
**  TMP_RSA_KEY -- return temporary RSA key
**
**	Parameters:
**		s -- SSL connection structure
**		export --
**		keylength --
**
**	Returns:
**		temporary RSA key.
*/

/* ARGUSED0 */
static RSA *
tmp_rsa_key(s, export, keylength)
	SSL *s;
	int export;
	int keylength;
{
	return rsa_tmp;
}
# endif /* !TLS_NO_RSA */
/*
**  APPS_SSL_INFO_CB -- info callback for TLS connections
**
**	Parameters:
**		s -- SSL connection structure
**		where --
**		ret --
**
**	Returns:
**		none.
*/

void
apps_ssl_info_cb(s, where, ret)
	SSL *s;
	int where;
	int ret;
{
	char *str;
	int w;
	BIO *bio_err = NULL;

	if (LogLevel > 14)
		sm_syslog(LOG_INFO, NOQID,
			  "info_callback where 0x%x ret %d", where, ret);

	w = where & ~SSL_ST_MASK;
	if (bio_err == NULL)
		bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);

	if (w & SSL_ST_CONNECT)
		str = "SSL_connect";
	else if (w & SSL_ST_ACCEPT)
		str = "SSL_accept";
	else
		str = "undefined";

	if (where & SSL_CB_LOOP)
	{
		if (LogLevel > 12)
			sm_syslog(LOG_NOTICE, NOQID,
			"%s:%s\n", str, SSL_state_string_long(s));
	}
	else if (where & SSL_CB_ALERT)
	{
		str = (where & SSL_CB_READ) ? "read" : "write";
		if (LogLevel > 12)
			sm_syslog(LOG_NOTICE, NOQID,
		"SSL3 alert %s:%s:%s\n",
			   str, SSL_alert_type_string_long(ret),
			   SSL_alert_desc_string_long(ret));
	}
	else if (where & SSL_CB_EXIT)
	{
		if (ret == 0)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					"%s:failed in %s\n",
					str, SSL_state_string_long(s));
		}
		else if (ret < 0)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					"%s:error in %s\n",
					str, SSL_state_string_long(s));
		}
	}
}
/*
**  TLS_VERIFY_LOG -- log verify error for TLS certificates
**
**	Parameters:
**		ok -- verify ok?
**		ctx -- x509 context
**
**	Returns:
**		0 -- fatal error
**		1 -- ok
*/

static int
tls_verify_log(ok, ctx)
	int ok;
	X509_STORE_CTX *ctx;
{
	SSL *ssl;
	X509 *cert;
	int reason, depth;
	char buf[512];

	cert = X509_STORE_CTX_get_current_cert(ctx);
	reason = X509_STORE_CTX_get_error(ctx);
	depth = X509_STORE_CTX_get_error_depth(ctx);
	ssl = (SSL *)X509_STORE_CTX_get_ex_data(ctx,
			SSL_get_ex_data_X509_STORE_CTX_idx());

	if (ssl == NULL)
	{
		/* internal error */
		sm_syslog(LOG_ERR, NOQID,
			  "TLS: internal error: tls_verify_cb: ssl == NULL");
		return 0;
	}

	X509_NAME_oneline(X509_get_subject_name(cert), buf, sizeof buf);
	sm_syslog(LOG_INFO, NOQID,
		  "TLS cert verify: depth=%d %s, state=%d, reason=%s\n",
		  depth, buf, ok, X509_verify_cert_error_string(reason));
	return 1;
}

/*
**  TLS_VERIFY_CB -- verify callback for TLS certificates
**
**	Parameters:
**		ctx -- x509 context
**
**	Returns:
**		accept connection?
**		currently: always yes.
*/

static int
tls_verify_cb(ctx)
	X509_STORE_CTX *ctx;
{
	int ok;

	ok = X509_verify_cert(ctx);
	if (ok == 0)
	{
		if (LogLevel > 13)
			return tls_verify_log(ok, ctx);
		return 1;	/* override it */
	}
	return ok;
}


/*
**  TLSLOGERR -- log the errors from the TLS error stack
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
*/

void
tlslogerr()
{
	unsigned long l;
	int line, flags;
	unsigned long es;
	char *file, *data;
	char buf[256];
#define CP (const char **)

	es = CRYPTO_thread_id();
	while ((l = ERR_get_error_line_data(CP &file, &line, CP &data, &flags))
		!= 0)
	{
		sm_syslog(LOG_WARNING, NOQID,
			 "TLS: %lu:%s:%s:%d:%s\n", es, ERR_error_string(l, buf),
			 file, line, (flags & ERR_TXT_STRING) ? data : "");
	}
}

# endif /* STARTTLS */
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d14 1
d16 15
a30 12
#if MILTER
# include <libmilter/mfdef.h>
#endif /* MILTER */

SM_RCSID("@@(#)$Sendmail: srvrsmtp.c,v 8.778 2001/09/04 22:43:06 ca Exp $")

#if SASL || STARTTLS
# include <sys/time.h>
# include "sfsasl.h"
#endif /* SASL || STARTTLS */
#if SASL
# define ENC64LEN(l)	(((l) + 2) * 4 / 3 + 1)
d32 21
a52 32
#endif /* SASL */
#if STARTTLS
# include <sysexits.h>

static SSL_CTX	*srv_ctx = NULL;	/* TLS server context */
static SSL	*srv_ssl = NULL;	/* per connection context */

static bool	tls_ok_srv = false;

extern void	tls_set_verify __P((SSL_CTX *, SSL *, bool));
# define TLS_VERIFY_CLIENT() tls_set_verify(srv_ctx, srv_ssl, \
				bitset(SRV_VRFY_CLT, features))
#endif /* STARTTLS */

/* server features */
#define SRV_NONE	0x0000	/* none... */
#define SRV_OFFER_TLS	0x0001	/* offer STARTTLS */
#define SRV_VRFY_CLT	0x0002	/* request a cert */
#define SRV_OFFER_AUTH	0x0004	/* offer AUTH */
#define SRV_OFFER_ETRN	0x0008	/* offer ETRN */
#define SRV_OFFER_VRFY	0x0010	/* offer VRFY (not yet used) */
#define SRV_OFFER_EXPN	0x0020	/* offer EXPN */
#define SRV_OFFER_VERB	0x0040	/* offer VERB */
#define SRV_OFFER_DSN	0x0080	/* offer DSN */
#if PIPELINING
# define SRV_OFFER_PIPE	0x0100	/* offer PIPELINING */
# if _FFR_NO_PIPE
#  define SRV_NO_PIPE	0x0200	/* disable PIPELINING, sleep if used */
# endif /* _FFR_NO_PIPE */
#endif /* PIPELINING */
#define SRV_REQ_AUTH	0x0400	/* require AUTH */
#define SRV_TMP_FAIL	0x1000	/* ruleset caused a temporary failure */
d54 1
a54 3
static unsigned int	srvfeatures __P((ENVELOPE *, char *, unsigned int));

static time_t	checksmtpattack __P((volatile unsigned int *, int, bool,
d59 1
a60 1
static void	setup_smtpd_io __P((void));
a62 3
#define SKIP_SPACE(s)	while (isascii(*s) && isspace(*s))	\
				(s)++

d68 1
a68 2
**			(almost) all SMTP commands.
**		d_flags -- daemon flags
d75 2
a76 8
**		Reads commands from the input channel and processes them.
*/

/*
**  Notice: The smtp server doesn't have a session context like the client
**	side has (mci). Therefore some data (session oriented) is allocated
**	or assigned to the "wrong" structure (esp. STARTTLS, AUTH).
**	This should be fixed in a successor version.
d86 19
a104 19
#define CMDERROR	0	/* bad command */
#define CMDMAIL	1	/* mail -- designate sender */
#define CMDRCPT	2	/* rcpt -- designate recipient */
#define CMDDATA	3	/* data -- send message text */
#define CMDRSET	4	/* rset -- reset state */
#define CMDVRFY	5	/* vrfy -- verify address */
#define CMDEXPN	6	/* expn -- expand address */
#define CMDNOOP	7	/* noop -- do nothing */
#define CMDQUIT	8	/* quit -- close connection and die */
#define CMDHELO	9	/* helo -- be polite */
#define CMDHELP	10	/* help -- give usage info */
#define CMDEHLO	11	/* ehlo -- extended helo (RFC 1425) */
#define CMDETRN	12	/* etrn -- flush queue */
#if SASL
# define CMDAUTH	13	/* auth -- SASL authenticate */
#endif /* SASL */
#if STARTTLS
# define CMDSTLS	14	/* STARTTLS -- start TLS session */
#endif /* STARTTLS */
d106 3
a108 1
#define CMDVERB	17	/* verb -- go into verbose mode */
d110 1
a110 1
#define CMDUNIMPL	19	/* unimplemented rfc821 commands */
d112 1
a112 1
#define CMDLOGBOGUS	23	/* bogus command that should be logged */
d114 2
a115 2
#define CMDDBGQSHOW	24	/* showq -- show send queue */
#define CMDDBGDEBUG	25	/* debug -- set debug mode */
d118 2
a119 1
**  Note: If you change this list, remember to update 'helpfile'
d137 2
d143 1
a143 1
#if SASL
d145 2
a146 2
#endif /* SASL */
#if STARTTLS
d148 1
a148 1
#endif /* STARTTLS */
d157 1
d160 11
a170 155
#ifndef MAXBADCOMMANDS
# define MAXBADCOMMANDS 25	/* maximum number of bad commands */
#endif
#ifndef MAXNOOPCOMMANDS
# define MAXNOOPCOMMANDS 20	/* max "noise" commands before slowdown */
#endif
#ifndef MAXHELOCOMMANDS
# define MAXHELOCOMMANDS 3	/* max HELO/EHLO commands before slowdown */
#endif
#ifndef MAXVRFYCOMMANDS
# define MAXVRFYCOMMANDS 6	/* max VRFY/EXPN commands before slowdown */
#endif
#ifndef MAXETRNCOMMANDS
# define MAXETRNCOMMANDS 8	/* max ETRN commands before slowdown */
#endif
#ifndef MAXTIMEOUT
# define MAXTIMEOUT (4 * 60)	/* max timeout for bad commands */
#endif

#if SM_HEAP_CHECK
static SM_DEBUG_T DebugLeakSmtp = SM_DEBUG_INITIALIZER("leak_smtp",
	"@@(#)$Debug: leak_smtp - trace memory leaks during SMTP processing $");
#endif /* SM_HEAP_CHECK */

typedef struct
{
	bool	sm_gotmail;	/* mail command received */
	unsigned int sm_nrcpts;	/* number of RCPT commands */
#if _FFR_ADAPTIVE_EOL
	bool	sm_crlf;	/* input in CRLF form? */
#endif /* _FFR_ADAPTIVE_EOL */
	bool	sm_discard;
#if MILTER
	bool	sm_milterize;
	bool	sm_milterlist;	/* any filters in the list? */
#endif /* MILTER */
} SMTP_T;

static void	smtp_data __P((SMTP_T *, ENVELOPE *));

#define MSG_TEMPFAIL "451 4.7.1 Please try again later"

#if MILTER
# define MILTER_ABORT(e)	milter_abort((e))
# define MILTER_REPLY(str)						\
	{								\
		int savelogusrerrs = LogUsrErrs;			\
									\
		switch (state)						\
		{							\
		  case SMFIR_REPLYCODE:					\
			if (MilterLogLevel > 3)				\
			{						\
				sm_syslog(LOG_INFO, e->e_id,		\
					  "Milter: %s=%s, reject=%s",	\
					  str, addr, response);		\
				LogUsrErrs = false;			\
			}						\
			usrerr(response);				\
			break;						\
									\
		  case SMFIR_REJECT:					\
			if (MilterLogLevel > 3)				\
			{						\
				sm_syslog(LOG_INFO, e->e_id,		\
					  "Milter: %s=%s, reject=550 5.7.1 Command rejected", \
					  str, addr);			\
				LogUsrErrs = false;			\
			}						\
			usrerr("550 5.7.1 Command rejected");		\
			break;						\
									\
		  case SMFIR_DISCARD:					\
			if (MilterLogLevel > 3)				\
				sm_syslog(LOG_INFO, e->e_id,		\
					  "Milter: %s=%s, discard",	\
					  str, addr);			\
			e->e_flags |= EF_DISCARD;			\
			break;						\
									\
		  case SMFIR_TEMPFAIL:					\
			if (MilterLogLevel > 3)				\
			{						\
				sm_syslog(LOG_INFO, e->e_id,		\
					  "Milter: %s=%s, reject=%s",	\
					  str, addr, MSG_TEMPFAIL);	\
				LogUsrErrs = false;			\
			}						\
			usrerr(MSG_TEMPFAIL);				\
			break;						\
		}							\
		LogUsrErrs = savelogusrerrs;				\
		if (response != NULL)					\
			sm_free(response); /* XXX */			\
	}

#else /* MILTER */
# define MILTER_ABORT(e)
#endif /* MILTER */

/* clear all SMTP state (for HELO/EHLO/RSET) */
#define CLEAR_STATE(cmd)					\
{								\
	/* abort milter filters */				\
	MILTER_ABORT(e);					\
								\
	if (smtp.sm_nrcpts > 0)					\
	{							\
		logundelrcpts(e, cmd, 10, false);		\
		smtp.sm_nrcpts = 0;				\
		macdefine(&e->e_macro, A_PERM,			\
			  macid("{nrcpts}"), "0");		\
	}							\
								\
	e->e_sendqueue = NULL;					\
	e->e_flags |= EF_CLRQUEUE;				\
								\
	if (LogLevel > 4 && bitset(EF_LOGSENDER, e->e_flags))	\
		logsender(e, NULL);				\
	e->e_flags &= ~EF_LOGSENDER;				\
								\
	/* clean up a bit */					\
	smtp.sm_gotmail = false;				\
	SuprErrs = true;					\
	dropenvelope(e, true, false);				\
	sm_rpool_free(e->e_rpool);				\
	e = newenvelope(e, CurEnv, sm_rpool_new_x(NULL));	\
	CurEnv = e;						\
}

/* sleep to flatten out connection load */
#define MIN_DELAY_LOG	15	/* wait before logging this again */

/* is it worth setting the process title for 1s? */
#define DELAY_CONN(cmd)						\
	if (DelayLA > 0 && (CurrentLA = getla()) >= DelayLA)	\
	{							\
		time_t dnow;					\
								\
		sm_setproctitle(true, e,			\
				"%s: %s: delaying %s: load average: %d", \
				qid_printname(e), CurSmtpClient,	\
				cmd, DelayLA);	\
		if (LogLevel > 8 && (dnow = curtime()) > log_delay)	\
		{						\
			sm_syslog(LOG_INFO, e->e_id,		\
				  "delaying=%s, load average=%d >= %d",	\
				  cmd, CurrentLA, DelayLA);		\
			log_delay = dnow + MIN_DELAY_LOG;	\
		}						\
		(void) sleep(1);				\
		sm_setproctitle(true, e, "%s %s: %.80s",	\
				qid_printname(e), CurSmtpClient, inp);	\
	}

d183 1
d191 10
a200 7
	volatile unsigned int n_badcmds = 0;	/* count of bad commands */
	volatile unsigned int n_badrcpts = 0;	/* number of rejected RCPT */
	volatile unsigned int n_verifies = 0;	/* count of VRFY/EXPN */
	volatile unsigned int n_etrn = 0;	/* count of ETRN */
	volatile unsigned int n_noop = 0;	/* count of NOOP/VERB/etc */
	volatile unsigned int n_helo = 0;	/* count of HELO/EHLO */
	volatile unsigned int delay = 1;	/* timeout for bad commands */
d202 4
a205 4
#if _FFR_ADAPTIVE_EOL
	volatile bool first;
#endif /* _FFR_ADAPTIVE_EOL */
	volatile bool tempfail = false;
d208 1
a208 1
	volatile bool lognullconnection = true;
a209 1
	SMTP_T smtp;
a211 1
	char *hostname;			/* my hostname ($j) */
d217 1
a217 1
#if SASL
d220 1
a220 1
	volatile unsigned int n_auth = 0;	/* count of AUTH commands */
d224 1
d228 1
a228 1
	unsigned int inlen, out2len;
d232 2
a233 2
	volatile unsigned int n_mechs;
	unsigned int len;
d236 1
d238 3
a240 2
#endif /* SASL */
#if STARTTLS
d243 2
a244 4
	volatile bool tls_active = false;
# if _FFR_SMTP_SSL
	volatile bool smtps = false;
# endif /* _FFR_SMTP_SSL */
d247 7
a253 30
	time_t tlsstart;
#endif /* STARTTLS */
	volatile unsigned int features;
#if PIPELINING
# if _FFR_NO_PIPE
	int np_log = 0;
# endif /* _FFR_NO_PIPE */
#endif /* PIPELINING */
	volatile time_t log_delay = (time_t) 0;

	smtp.sm_nrcpts = 0;
#if MILTER
	smtp.sm_milterize = (nullserver == NULL);
	smtp.sm_milterlist = false;
#endif /* MILTER */

	/* setup I/O fd correctly for the SMTP server */
	setup_smtpd_io();

#if SM_HEAP_CHECK
	if (sm_debug_active(&DebugLeakSmtp, 1))
	{
		sm_heap_newgroup();
		sm_dprintf("smtp() heap group #%d\n", sm_heap_group());
	}
#endif /* SM_HEAP_CHECK */

	/* XXX the rpool should be set when e is initialized in main() */
	e->e_rpool = sm_rpool_new_x(NULL);
	e->e_macro.mac_rpool = e->e_rpool;
d256 1
a256 1
	sm_getla();
d266 1
a266 1
	smtp.sm_discard = bitset(EF_DISCARD, e->e_flags);
d268 1
a268 50
#if PIPELINING
	/* auto-flush output when reading input */
	(void) sm_io_autoflush(InChannel, OutChannel);
#endif /* PIPELINING */

	sm_setproctitle(true, e, "server %s startup", CurSmtpClient);

	/* Set default features for server. */
	features = ((bitset(PRIV_NOETRN, PrivacyFlags) ||
		     bitnset(D_NOETRN, d_flags)) ? SRV_NONE : SRV_OFFER_ETRN)
		| (bitnset(D_AUTHREQ, d_flags) ? SRV_REQ_AUTH : SRV_NONE)
		| (bitset(PRIV_NOEXPN, PrivacyFlags) ? SRV_NONE
			: (SRV_OFFER_EXPN
			  | (bitset(PRIV_NOVERB, PrivacyFlags)
			     ? SRV_NONE : SRV_OFFER_VERB)))
		| (bitset(PRIV_NORECEIPTS, PrivacyFlags) ? SRV_NONE
							 : SRV_OFFER_DSN)
#if SASL
		| (bitnset(D_NOAUTH, d_flags) ? SRV_NONE : SRV_OFFER_AUTH)
#endif /* SASL */
#if PIPELINING
		| SRV_OFFER_PIPE
#endif /* PIPELINING */
#if STARTTLS
		| (bitnset(D_NOTLS, d_flags) ? SRV_NONE : SRV_OFFER_TLS)
		| (bitset(TLS_I_NO_VRFY, TLS_Srv_Opts) ? SRV_NONE
						       : SRV_VRFY_CLT)
#endif /* STARTTLS */
		;
	if (nullserver == NULL)
	{
		features = srvfeatures(e, CurSmtpClient, features);
		if (bitset(SRV_TMP_FAIL, features))
		{
			if (LogLevel > 4)
				sm_syslog(LOG_ERR, NOQID,
					  "ERROR: srv_features=tempfail, relay=%.100s, access temporarily disabled",
					  CurSmtpClient);
			nullserver = "450 4.3.0 Please try again later.";
		}
#if PIPELINING
# if _FFR_NO_PIPE
		else if (bitset(SRV_NO_PIPE, features))
		{
			/* for consistency */
			features &= ~SRV_OFFER_PIPE;
		}
# endif /* _FFR_NO_PIPE */
#endif /* PIPELINING */
	}
d270 2
a271 3
	hostname = macvalue('j', e);
#if SASL
	sasl_ok = bitset(SRV_OFFER_AUTH, features);
a272 1
	authenticating = SASL_NOT_AUTH;
d275 9
a283 20
	if (sasl_ok)
	{
# if SASL > 10505
		/* use empty realm: only works in SASL > 1.5.5 */
		result = sasl_server_new("smtp", hostname, "", NULL, 0, &conn);
# else /* SASL > 10505 */
		/* use no realm -> realm is set to hostname by SASL lib */
		result = sasl_server_new("smtp", hostname, NULL, NULL, 0,
					 &conn);
# endif /* SASL > 10505 */
		sasl_ok = result == SASL_OK;
		if (!sasl_ok)
		{
			if (LogLevel > 9)
				sm_syslog(LOG_WARNING, NOQID,
					  "AUTH error: sasl_server_new failed=%d",
					  result);
		}
	}
	if (sasl_ok)
d285 2
d296 2
a297 2
#if NETINET
		in = macvalue(macid("{daemon_family}"), e);
d305 1
a305 2
			if (getpeername(sm_io_getinfo(InChannel, SM_IO_WHAT_FD,
						      NULL),
d311 1
a311 3
				if (getsockname(sm_io_getinfo(InChannel,
							      SM_IO_WHAT_FD,
							      NULL),
d318 1
a318 1
#endif /* NETINET */
d320 1
d324 3
a326 4
# if 0
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			macid("{auth_author}"), NULL);
# endif /* 0 */
d330 1
a330 1

a332 2
#  if STARTTLS
#  endif /* STARTTLS */
d334 1
a334 1
			ssp.max_ssf = MaxSLBits;
d337 2
d340 1
d347 5
a351 1
			**	currently we have none so zero
a352 1

d359 1
d361 2
d364 8
a371 1
#endif /* SASL */
d373 16
a388 2
#if MILTER
	if (smtp.sm_milterize)
d393 1
a393 1
		smtp.sm_milterlist = milter_init(e, &state);
d399 1
a399 1
			smtp.sm_milterize = false;
d403 2
a404 2
			tempfail = true;
			smtp.sm_milterize = false;
d409 1
a409 2
	if (smtp.sm_milterlist && smtp.sm_milterize &&
	    !bitset(EF_DISCARD, e->e_flags))
d413 2
a414 1
		(void) milter_connect(peerhostname, RealHostAddr, e, &state);
d421 1
a421 1
			smtp.sm_milterize = false;
d425 2
a426 2
			tempfail = true;
			smtp.sm_milterize = false;
d430 1
a430 13
#endif /* MILTER */

#if STARTTLS
# if _FFR_SMTP_SSL
	/* If this an smtps connection, start TLS now */
	smtps = bitnset(D_SMTPS, d_flags);
	if (smtps)
		goto starttls;

  greeting:

# endif /* _FFR_SMTP_SSL */
#endif /* STARTTLS */
d433 1
a433 6
	if (*greetcode == '5')
		(void) sm_snprintf(inp, sizeof inp, "%s not accepting messages",
				   hostname);
	else
		expand(SmtpGreeting, inp, sizeof inp, e);

d441 1
a441 1
		(void) sm_snprintf(cmdbuf, sizeof cmdbuf,
d444 1
a444 1
		(void) sm_snprintf(cmdbuf, sizeof cmdbuf,
d454 1
a454 1
		(void) sm_strlcpyn(cmdbuf, sizeof cmdbuf, 2, greetcode, "-%s");
d461 1
a461 1
		(void) sm_strlcpyn(cmdbuf, sizeof cmdbuf, 2, greetcode, " %s");
d467 2
a468 9

	/* sendinghost's storage must outlive the current envelope */
	if (sendinghost != NULL)
		sendinghost = sm_strdup_x(sendinghost);
#if _FFR_ADAPTIVE_EOL
	first = true;
#endif /* _FFR_ADAPTIVE_EOL */
	gothello = false;
	smtp.sm_gotmail = false;
d471 7
a477 7
	    SM_TRY
	    {
		QuickAbort = false;
		HoldErrs = false;
		SuprErrs = false;
		LogUsrErrs = false;
		OnlyOneError = true;
d484 1
a484 1
		(void) sm_io_flush(smioout, SM_TIME_DEFAULT);
d488 2
a489 2
		sm_setproctitle(true, e, "server %s cmd read", CurSmtpClient);
#if SASL
d491 3
a493 2
		**  XXX SMTP AUTH requires accepting any length,
		**	at least for challenge/response
d495 1
a495 1
#endif /* SASL */
d498 1
a498 1
		if (sm_io_error(OutChannel) ||
d504 1
a504 1
			d = macvalue(macid("{daemon_name}"), e);
d510 1
a510 1
#if MILTER
d513 1
a513 1
#endif /* MILTER */
d517 1
a517 1
			if (LogLevel > (smtp.sm_gotmail ? 1 : 19))
a531 22
#if _FFR_ADAPTIVE_EOL
		if (first)
		{
			char *p;

			smtp.sm_crlf = true;
			p = strchr(inp, '\n');
			if (p == NULL || p <= inp || p[-1] != '\r')
			{
				smtp.sm_crlf = false;
				if (tTd(66, 1) && LogLevel > 8)
				{
					/* how many bad guys are there? */
					sm_syslog(LOG_INFO, NOQID,
						  "%.100s did not use CRLF",
						  CurSmtpClient);
				}
			}
			first = false;
		}
#endif /* _FFR_ADAPTIVE_EOL */

d533 1
a533 1
		fixcrlf(inp, true);
d535 1
a535 23
#if PIPELINING
# if _FFR_NO_PIPE
		/*
		**  if there is more input and pipelining is disabled:
		**	delay ... (and maybe discard the input?)
		**  XXX this doesn't really work, at least in tests using
		**  telnet SM_IO_IS_READABLE only returns 1 if there were
		**  more than 2 input lines available.
		*/

		if (bitset(SRV_NO_PIPE, features) &&
		    sm_io_getinfo(InChannel, SM_IO_IS_READABLE, NULL))
		{
			if (++np_log < 3)
				sm_syslog(LOG_INFO, NOQID,
					  "unauthorized PIPELINING, sleeping");
			sleep(1);
		}

# endif /* _FFR_NO_PIPE */
#endif /* PIPELINING */

#if SASL
d538 1
a538 1
# if 0
d545 1
a545 1
# endif /* 0 */
d577 2
a578 2
				macdefine(&BlankEnvelope.e_macro, A_TEMP,
					macid("{auth_type}"), auth_type);
d585 2
a586 3
					macdefine(&BlankEnvelope.e_macro,
						  A_PERM,
						  macid("{auth_authen}"), NULL);
d590 2
a591 3
					macdefine(&BlankEnvelope.e_macro,
						  A_TEMP,
						  macid("{auth_authen}"), user);
d594 1
a594 1
# if 0
d597 1
a597 1
# endif /* 0 */
d599 2
d606 2
a607 3
					macdefine(&BlankEnvelope.e_macro,
						  A_PERM,
						  macid("{auth_ssf}"), "0");
d614 3
a616 5
					(void) sm_snprintf(pbuf, sizeof pbuf,
							   "%u", *ssf);
					macdefine(&BlankEnvelope.e_macro,
						  A_TEMP,
						  macid("{auth_ssf}"), pbuf);
d618 2
a619 2
						sm_dprintf("AUTH auth_ssf: %u\n",
							   *ssf);
a620 1

d622 1
a622 1
				**  Only switch to encrypted connection
a624 1

d628 7
a634 3
					**  Convert I/O layer to use SASL.
					**  If the call fails, the connection
					**  is aborted.
d636 2
a637 3

					if (sfdcsasl(&InChannel, &OutChannel,
						     conn) == 0)
d640 2
a642 4
#if PIPELINING
						(void) sm_io_autoflush(InChannel,
								       OutChannel);
#endif /* PIPELINING */
d646 7
d654 2
a655 3

				/* NULL pointer ok since it's our function */
				if (LogLevel > 8)
d657 4
a660 3
						  "AUTH=server, relay=%.100s, authid=%.32s, mech=%.16s, bits=%d",
						  CurSmtpClient, user,
						  auth_type, *ssf);
d667 1
a667 1
						       &out2len);
d675 1
a675 1
							  "AUTH encode64 error [%d for \"%s\"]",
d684 2
a685 2
						sm_dprintf("AUTH continue: msg='%s' len=%u\n",
							   out2, out2len);
d694 1
a694 1
						  "AUTH failure (%s): %s (%d) %s",
d698 1
a698 2
						  result,
						  errstr == NULL ? "" : errstr);
d705 1
a705 1
#endif /* SASL */
d709 1
a709 2
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
					     "<<< %s\n", inp);
d711 4
a714 2
		if (LogLevel > 14)
			sm_syslog(LOG_INFO, e->e_id, "<-- %s", inp);
d717 1
a717 1
			sm_setproctitle(true, e, "%s: %.80s",
d720 1
a720 1
			sm_setproctitle(true, e, "%s %s: %.80s",
d735 2
a736 1
		SKIP_SPACE(p);
d741 1
a741 1
			if (sm_strcasecmp(c->cmd_name, cmdbuf) == 0)
a747 10
		/* check whether a "non-null" command has been used */
		switch (c->cmd_code)
		{
		  case CMDMAIL:
		  case CMDEXPN:
		  case CMDVRFY:
		  case CMDETRN:
			lognullconnection = false;
		}

d752 1
a752 1
		**	to almost everything.
d771 1
a771 2
				DELAY_CONN("ETRN");
				/* FALLTHROUGH */
d774 1
a774 3
#if MAXBADCOMMANDS > 0
				/* theoretically this could overflow */
				if (++n_badcmds > MAXBADCOMMANDS)
a780 1
#endif /* MAXBADCOMMANDS > 0 */
d786 1
a786 2
						usrerr("550 5.0.0 %s",
						       nullserver);
d794 10
d806 1
a806 1
#if SASL
d808 1
a808 2
			DELAY_CONN("AUTH");
			if (!sasl_ok || n_mechs <= 0)
d818 1
a818 1
			if (smtp.sm_gotmail)
d833 1
a833 1
			ismore = false;
d836 1
a836 1
			(void) checksmtpattack(&n_auth, n_mechs + 1, true,
d839 1
a839 1
			/* make sure mechanism (p) is a valid string */
d857 1
a857 1
				message("503 5.3.3 AUTH mechanism %.32s not available",
d865 1
a865 1
				in = sm_rpool_malloc(e->e_rpool, strlen(q));
d867 1
a867 1
						       &inlen);
d874 1
a874 1
							  "AUTH decode64 error [%d for \"%s\"]",
d882 17
d915 1
a915 1
						  "AUTH failure (%s): %s (%d) %s",
d919 1
a919 2
						  result,
						  errstr);
d935 1
a935 1
					       &out2len);
d942 1
a942 1
						  "AUTH encode64 error [%d for \"%s\"]",
d953 1
d955 1
a955 1
#endif /* SASL */
d957 1
a957 1
#if STARTTLS
a958 1
			DELAY_CONN("STARTTLS");
d964 1
a964 1
			if (!bitset(SRV_OFFER_TLS, features))
d969 1
a969 1
			if (!tls_ok_srv)
d974 1
a974 1
			if (smtp.sm_gotmail)
a987 3
# if _FFR_SMTP_SSL
  starttls:
# endif /* _FFR_SMTP_SSL */
d993 11
a1004 11

# if TLS_VRFY_PER_CTX
			/*
			**  Note: this sets the verification globally
			**  (per SSL_CTX)
			**  it's ok since it applies only to one transaction
			*/

			TLS_VERIFY_CLIENT();
# endif /* TLS_VRFY_PER_CTX */

a1009 3
# if _FFR_SMTP_SSL
				goto tls_done;
# else /* _FFR_SMTP_SSL */
a1010 1
# endif /* _FFR_SMTP_SSL */
d1012 2
a1013 14

# if !TLS_VRFY_PER_CTX
			/*
			**  this could be used if it were possible to set
			**  verification per SSL (connection)
			**  not just per SSL_CTX (global)
			*/

			TLS_VERIFY_CLIENT();
# endif /* !TLS_VRFY_PER_CTX */

			rfd = sm_io_getinfo(InChannel, SM_IO_WHAT_FD, NULL);
			wfd = sm_io_getinfo(OutChannel, SM_IO_WHAT_FD, NULL);

d1021 3
a1023 14
# if _FFR_SMTP_SSL
				goto tls_done;
# else /* _FFR_SMTP_SSL */
				break;
# endif /* _FFR_SMTP_SSL */
			}
# if _FFR_SMTP_SSL
			if (!smtps)
# endif /* _FFR_SMTP_SSL */
				message("220 2.0.0 Ready to start TLS");
# if PIPELINING
			(void) sm_io_flush(OutChannel, SM_TIME_DEFAULT);
# endif /* PIPELINING */

a1026 3

			tlsstart = curtime();
  ssl_retry:
a1029 4
				bool timedout;
				time_t left;
				time_t now = curtime();
				struct timeval tv;
a1032 52

				/*
				**  For SSL_ERROR_WANT_{READ,WRITE}:
				**  There is no SSL record available yet
				**  or there is only a partial SSL record
				**  removed from the network (socket) buffer
				**  into the SSL buffer. The SSL_accept will
				**  only succeed when a full SSL record is
				**  available (assuming a "real" error
				**  doesn't happen). To handle when a "real"
				**  error does happen the select is set for
				**  exceptions too.
				**  The connection may be re-negotiated
				**  during this time so both read and write
				**  "want errors" need to be handled.
				**  A select() exception loops back so that
				**  a proper SSL error message can be gotten.
				*/

				left = TimeOuts.to_starttls - (now - tlsstart);
				timedout = left <= 0;
				if (!timedout)
				{
					tv.tv_sec = left;
					tv.tv_usec = 0;
				}

				/* XXX what about SSL_pending() ? */
				if (!timedout && i == SSL_ERROR_WANT_READ)
				{
					fd_set ssl_maskr, ssl_maskx;

					FD_ZERO(&ssl_maskr);
					FD_SET(rfd, &ssl_maskr);
					FD_ZERO(&ssl_maskx);
					FD_SET(rfd, &ssl_maskx);
					if (select(rfd + 1, &ssl_maskr, NULL,
						   &ssl_maskx, &tv) > 0)
						goto ssl_retry;
				}
				if (!timedout && i == SSL_ERROR_WANT_WRITE)
				{
					fd_set ssl_maskw, ssl_maskx;

					FD_ZERO(&ssl_maskw);
					FD_SET(wfd, &ssl_maskw);
					FD_ZERO(&ssl_maskx);
					FD_SET(rfd, &ssl_maskx);
					if (select(wfd + 1, NULL, &ssl_maskw,
						   &ssl_maskx, &tv) > 0)
						goto ssl_retry;
				}
d1035 5
a1039 5
					sm_syslog(LOG_WARNING, NOQID,
						  "STARTTLS=server, error: accept failed=%d, SSL_error=%d, timedout=%d",
						  r, i, (int) timedout);
					if (LogLevel > 8)
						tlslogerr("server");
d1041 1
a1041 1
				tls_ok_srv = false;
d1056 2
a1057 4
			(void) tls_get_info(srv_ssl, true,
					    CurSmtpClient,
					    &BlankEnvelope.e_macro,
					    bitset(SRV_VRFY_CLT, features));
d1066 2
a1067 2
			SuprErrs = true;
			QuickAbort = false;
d1069 3
a1071 4
				     macvalue(macid("{verify}"), e),
				     "STARTTLS", e, true, true, 5,
				     NULL, NOQID) != EX_OK ||
			    Errors > 0)
d1083 2
a1084 1
			tls_ok_srv = false;	/* don't offer STARTTLS again */
d1086 2
a1087 1
# if SASL
d1092 2
a1093 2
				s = macvalue(macid("{cipher_bits}"), e);
				if (s != NULL && (ext_ssf.ssf = atoi(s)) > 0)
d1095 3
a1097 1
					ext_ssf.auth_id = macvalue(macid("{cert_subject}"),
d1099 1
d1102 2
d1106 1
d1109 2
d1113 1
a1113 1
# endif /* SASL */
d1116 9
a1124 7
			if (sfdctls(&InChannel, &OutChannel, srv_ssl) == 0)
			{
				tls_active = true;
# if PIPELINING
				(void) sm_io_autoflush(InChannel, OutChannel);
# endif /* PIPELINING */
			}
a1134 1

d1136 1
a1136 10
				syserr("STARTTLS: can't switch to encrypted layer");
			}
# if _FFR_SMTP_SSL
		  tls_done:
			if (smtps)
			{
				if (tls_active)
					goto greeting;
				else
					goto doquit;
a1137 1
# endif /* _FFR_SMTP_SSL */
d1139 1
a1139 1
#endif /* STARTTLS */
a1142 1
			DELAY_CONN("EHLO");
d1155 1
a1155 1
			(void) checksmtpattack(&n_helo, MAXHELOCOMMANDS, true,
a1157 2
#if 0
			/* RFC2821 4.1.4 allows duplicate HELO/EHLO */
d1162 1
a1162 1
				       MyHostName);
a1164 1
#endif /* 0 */
d1203 1
a1203 1
				sendinghost = sm_strdup_x(p);
d1219 1
a1219 2
			if (gothello)
				CLEAR_STATE(cmdbuf);
d1221 2
a1222 3
#if MILTER
			if (smtp.sm_milterlist && smtp.sm_milterize &&
			    !bitset(EF_DISCARD, e->e_flags))
d1232 1
a1232 1
					smtp.sm_milterize = false;
d1237 1
a1237 1
					smtp.sm_milterize = false;
d1241 2
a1242 2
					tempfail = true;
					smtp.sm_milterize = false;
d1246 1
a1246 2
#endif /* MILTER */
			gothello = true;
d1270 1
a1270 1
			**	  remember to update 'helpfile'
d1275 1
a1275 5
#if PIPELINING
			if (bitset(SRV_OFFER_PIPE, features))
				message("250-PIPELINING");
#endif /* PIPELINING */
			if (bitset(SRV_OFFER_EXPN, features))
d1278 1
a1278 1
				if (bitset(SRV_OFFER_VERB, features))
d1281 1
a1281 1
#if MIME8TO7
d1283 1
a1283 1
#endif /* MIME8TO7 */
d1288 3
a1290 2
#if DSN
			if (SendMIMEErrors && bitset(SRV_OFFER_DSN, features))
d1292 4
a1295 2
#endif /* DSN */
			if (bitset(SRV_OFFER_ETRN, features))
d1297 3
a1299 1
#if SASL
d1302 3
a1304 3
#endif /* SASL */
#if STARTTLS
			if (tls_ok_srv && bitset(SRV_OFFER_TLS, features))
d1306 1
a1306 9
#endif /* STARTTLS */
			if (DeliverByMin > 0)
				message("250-DELIVERBY %ld",
					(long) DeliverByMin);
			else if (DeliverByMin == 0)
				message("250-DELIVERBY");

			/* < 0: no deliver-by */

a1311 1
			DELAY_CONN("MAIL");
d1319 1
a1319 1
			if (smtp.sm_gotmail)
d1324 8
a1331 2
#if SASL
			if (bitset(SRV_REQ_AUTH, features) &&
d1337 1
a1337 1
#endif /* SASL */
d1348 1
a1348 1
				usrerr(MSG_TEMPFAIL);
d1357 8
a1364 8
#if SM_HEAP_CHECK
			if (sm_debug_active(&DebugLeakSmtp, 1))
			{
				sm_heap_newgroup();
				sm_dprintf("smtp() heap group #%d\n",
					sm_heap_group());
			}
#endif /* SM_HEAP_CHECK */
d1367 1
a1367 1
				goto undo_no_pm;
d1370 8
a1377 7
				auth_warning(e, "%s didn't use HELO protocol",
					     CurSmtpClient);
			}
#ifdef PICKY_HELO_CHECK
			if (sm_strcasecmp(sendinghost, peerhostname) != 0 &&
			    (sm_strcasecmp(peerhostname, "localhost") != 0 ||
			     sm_strcasecmp(sendinghost, MyHostName) != 0))
d1380 1
a1380 1
					     CurSmtpClient, sendinghost);
d1382 1
a1382 1
#endif /* PICKY_HELO_CHECK */
d1386 2
a1387 2
			macdefine(&e->e_macro, A_PERM, 'r', protocol);
			macdefine(&e->e_macro, A_PERM, 's', sendinghost);
d1390 3
a1392 5
				goto undo_no_pm;
			smtp.sm_nrcpts = 0;
			n_badrcpts = 0;
			macdefine(&e->e_macro, A_PERM, macid("{ntries}"), "0");
			macdefine(&e->e_macro, A_PERM, macid("{nrcpts}"), "0");
d1394 1
a1394 1
			sm_setproctitle(true, e, "%s %s: %.80s",
d1398 23
a1420 4
			/* do the processing */
		    SM_TRY
		    {
			QuickAbort = true;
d1424 1
a1424 1
			setsender(p, e, &delimptr, ' ', false);
d1428 1
a1428 1
				sm_exc_raisenew_x(&EtypeQuickAbort, 1);
d1435 2
a1436 3
				 macdefine(&e->e_macro, A_PERM,
					macid("{mail_mailer}"),
					e->e_from.q_mailer->m_name);
d1438 2
a1439 2
				 macdefine(&e->e_macro, A_PERM,
					macid("{mail_mailer}"), NULL);
d1441 2
a1442 3
				macdefine(&e->e_macro, A_PERM,
					macid("{mail_host}"),
					e->e_from.q_host);
d1444 2
a1445 2
				macdefine(&e->e_macro, A_PERM,
					macid("{mail_host}"), "localhost");
d1447 2
a1448 3
				macdefine(&e->e_macro, A_PERM,
					macid("{mail_addr}"),
					e->e_from.q_user);
d1450 2
a1451 2
				macdefine(&e->e_macro, A_PERM,
					macid("{mail_addr}"), NULL);
d1453 1
a1453 1
				sm_exc_raisenew_x(&EtypeQuickAbort, 1);
d1479 2
a1480 1
				SKIP_SPACE(p);
d1505 1
a1505 1
					sm_dprintf("MAIL: got arg %s=\"%s\"\n", kp,
d1515 1
a1515 1
					sm_exc_raisenew_x(&EtypeQuickAbort, 1);
d1519 1
a1519 1
				sm_exc_raisenew_x(&EtypeQuickAbort, 1);
a1521 2
			macdefine(&e->e_macro, A_PERM,
				macid("{addr_type}"), "e s");
d1523 1
a1523 2
				    NULL, e, true, true, 3, NULL,
				    e->e_id) != EX_OK ||
d1525 1
a1525 3
				sm_exc_raisenew_x(&EtypeQuickAbort, 1);
			macdefine(&e->e_macro, A_PERM,
				macid("{addr_type}"), NULL);
d1528 1
a1528 2
			    (e->e_msgsize > MaxMessageSize ||
			     e->e_msgsize < 0))
d1532 1
a1532 1
				sm_exc_raisenew_x(&EtypeQuickAbort, 1);
d1535 1
a1535 14
			/*
			**  XXX always check whether there is at least one fs
			**  with enough space?
			**  However, this may not help much: the queue group
			**  selection may later on select a FS that hasn't
			**  enough space.
			*/

			if ((NumFileSys == 1 || NumQueue == 1) &&
			    !enoughdiskspace(e->e_msgsize, e)
#if _FFR_ANY_FREE_FS
			    && !filesys_free(e->e_msgsize)
#endif /* _FFR_ANY_FREE_FS */
			   )
a1536 5
				/*
				**  We perform this test again when the
				**  queue directory is selected, in collect.
				*/

d1538 1
a1538 1
				sm_exc_raisenew_x(&EtypeQuickAbort, 1);
d1541 1
a1541 1
				sm_exc_raisenew_x(&EtypeQuickAbort, 1);
d1543 3
a1545 4
			LogUsrErrs = true;
#if MILTER
			if (smtp.sm_milterlist && smtp.sm_milterize &&
			    !bitset(EF_DISCARD, e->e_flags))
d1551 20
a1570 1
				MILTER_REPLY("from");
d1572 1
a1572 1
#endif /* MILTER */
d1574 1
a1574 1
				sm_exc_raisenew_x(&EtypeQuickAbort, 1);
d1577 1
a1577 18
			smtp.sm_gotmail = true;
		    }
		    SM_EXCEPT(exc, "[!F]*")
		    {
			/*
			**  An error occurred while processing a MAIL command.
			**  Jump to the common error handling code.
			*/

			sm_exc_free(exc);
			goto undo_no_pm;
		    }
		    SM_END_TRY
			break;

		  undo_no_pm:
			e->e_flags &= ~EF_PM_NOTIFY;
		  undo:
d1581 1
a1581 2
			DELAY_CONN("RCPT");
			if (!smtp.sm_gotmail)
d1587 7
a1593 4
		    SM_TRY
		    {
			QuickAbort = true;
			LogUsrErrs = true;
d1596 1
a1596 2
			if (MaxRcptPerMsg > 0 &&
			    smtp.sm_nrcpts >= MaxRcptPerMsg)
a1597 1
				/* sleep(1); / * slow down? */
d1599 1
a1599 1
				goto rcpt_done;
d1605 1
a1605 1
#if MILTER
d1617 1
a1617 1
#endif /* MILTER */
d1621 8
a1628 30
				goto rcpt_done;
			macdefine(&e->e_macro, A_PERM,
				macid("{addr_type}"), "e r");
			a = parseaddr(p, NULLADDR, RF_COPYALL, ' ', &delimptr,
				      e, true);
			macdefine(&e->e_macro, A_PERM,
				macid("{addr_type}"), NULL);
			if (BadRcptThrottle > 0 &&
			    n_badrcpts >= BadRcptThrottle)
			{
				if (LogLevel > 5 &&
				    n_badrcpts == BadRcptThrottle)
				{
					sm_syslog(LOG_INFO, e->e_id,
						  "%.100s: Possible SMTP RCPT flood, throttling.",
						  CurSmtpClient);

					/* To avoid duplicated message */
					n_badrcpts++;
				}

				/*
				**  Don't use exponential backoff for now.
				**  Some servers will open more connections
				**  and actually overload the receiver even
				**  more.
				*/

				(void) sleep(1);
			}
d1630 1
a1630 1
				goto rcpt_done;
d1634 1
a1634 1
				goto rcpt_done;
d1642 2
a1643 3
				macdefine(&e->e_macro, A_PERM,
					macid("{rcpt_mailer}"),
					a->q_mailer->m_name);
d1645 2
a1646 2
				macdefine(&e->e_macro, A_PERM,
					macid("{rcpt_mailer}"), NULL);
d1648 2
a1649 2
				macdefine(&e->e_macro, A_PERM,
					macid("{rcpt_host}"), a->q_host);
d1651 2
a1652 2
				macdefine(&e->e_macro, A_PERM,
					macid("{rcpt_host}"), "localhost");
d1654 2
a1655 2
				macdefine(&e->e_macro, A_PERM,
					macid("{rcpt_addr}"), a->q_user);
d1657 2
a1658 2
				macdefine(&e->e_macro, A_PERM,
					macid("{rcpt_addr}"), NULL);
d1660 1
a1660 1
				goto rcpt_done;
d1674 2
a1675 1
				SKIP_SPACE(p);
d1700 1
a1700 1
					sm_dprintf("RCPT: got arg %s=\"%s\"\n", kp,
d1714 1
a1714 1
				goto rcpt_done;
a1716 2
			macdefine(&e->e_macro, A_PERM,
				macid("{addr_type}"), "e r");
d1718 1
a1718 2
				    NULL, e, true, true, 3, NULL,
				    e->e_id) != EX_OK ||
d1720 1
a1720 3
				goto rcpt_done;
			macdefine(&e->e_macro, A_PERM,
				macid("{addr_type}"), NULL);
d1722 2
a1723 3
#if MILTER
			if (smtp.sm_milterlist && smtp.sm_milterize &&
			    !bitset(EF_DISCARD, e->e_flags))
d1729 20
a1748 1
				MILTER_REPLY("to");
d1750 1
a1750 1
#endif /* MILTER */
d1752 4
a1755 8
			macdefine(&e->e_macro, A_PERM,
				macid("{rcpt_mailer}"), NULL);
			macdefine(&e->e_macro, A_PERM,
				macid("{rcpt_relay}"), NULL);
			macdefine(&e->e_macro, A_PERM,
				macid("{rcpt_addr}"), NULL);
			macdefine(&e->e_macro, A_PERM,
				macid("{dsn_notify}"), NULL);
d1757 1
a1757 1
				goto rcpt_done;
d1762 1
a1762 1
				goto rcpt_done;
d1768 1
a1768 1
				if (smtp.sm_nrcpts == 0)
d1773 1
a1773 1
				smtp.sm_nrcpts++;
a1779 11
		    rcpt_done:
			if (Errors > 0)
				++n_badrcpts;
		    }
		    SM_EXCEPT(exc, "[!F]*")
		    {
			/* An exception occurred while processing RCPT */
			e->e_flags &= ~(EF_FATALERRS|EF_PM_NOTIFY);
			++n_badrcpts;
		    }
		    SM_END_TRY
d1783 11
a1793 3
			DELAY_CONN("DATA");
			smtp_data(&smtp, e);
			break;
d1795 3
a1797 7
		  case CMDRSET:		/* rset -- reset state */
			if (tTd(94, 100))
				message("451 4.0.0 Test failure");
			else
				message("250 2.0.0 Reset state");
			CLEAR_STATE(cmdbuf);
			break;
d1799 4
a1802 5
		  case CMDVRFY:		/* vrfy -- verify address */
		  case CMDEXPN:		/* expn -- expand address */
			vrfy = c->cmd_code == CMDVRFY;
			DELAY_CONN(vrfy ? "VRFY" : "EXPN");
			if (tempfail)
d1804 12
a1815 5
				if (LogLevel > 9)
					sm_syslog(LOG_INFO, e->e_id,
						  "SMTP %s command (%.100s) from %.100s tempfailed (due to previous checks)",
						  vrfy ? "VRFY" : "EXPN",
						  p, CurSmtpClient);
d1817 207
a2023 1
				/* RFC 821 doesn't allow 4xy reply code */
d2027 2
a2028 2
			wt = checksmtpattack(&n_verifies, MAXVRFYCOMMANDS,
					     false, vrfy ? "VRFY" : "EXPN", e);
d2030 1
d2032 1
a2032 1
				   PrivacyFlags))
d2052 2
d2055 1
a2055 1
				break;
d2057 2
a2058 1
				sm_syslog(LOG_INFO, e->e_id, "%.100s: %s",
d2061 3
a2063 3
		    SM_TRY
		    {
			QuickAbort = true;
d2077 3
a2079 4
					    p, NULL, e, true, false, 3, NULL,
					    NOQID) != EX_OK ||
				    Errors > 0)
					sm_exc_raisenew_x(&EtypeQuickAbort, 1);
d2091 1
a2091 1
				sm_exc_raisenew_x(&EtypeQuickAbort, 1);
d2112 2
a2113 11
		    }
		    SM_EXCEPT(exc, "[!F]*")
		    {
			/*
			**  An exception occurred while processing VRFY/EXPN
			*/

			sm_exc_free(exc);
			goto undo;
		    }
		    SM_END_TRY
d2117 2
a2118 2
			DELAY_CONN("ETRN");
			if (!bitset(SRV_OFFER_ETRN, features) || UseMSP)
d2135 1
a2135 1
				usrerr(MSG_TEMPFAIL);
d2146 1
a2146 1
			(void) checksmtpattack(&n_etrn, MAXETRNCOMMANDS, true,
d2149 3
a2151 12
			/*
			**  Do config file checking of the parameter.
			**  Even though we have srv_features now, we still
			**  need this ruleset because the former is called
			**  when the connection has been established, while
			**  this ruleset is called when the command is
			**  actually issued and therefore has all information
			**  available to make a decision.
			*/

			if (rscheck("check_etrn", p, NULL, e, true, false, 3,
				    NULL, NOQID) != EX_OK || Errors > 0)
d2156 2
a2157 1
					  "%.100s: ETRN %s", CurSmtpClient,
a2160 19
			if (*id == '#')
			{
				int wgrp;

				id++;
				wgrp = name2qid(id);
				if (!ISVALIDQGRP(wgrp))
				{
					usrerr("459 4.5.4 Queue %s unknown",
					       id);
					break;
				}
				ok = run_work_group(wgrp, true, false,
						    false, true);
				if (ok && Errors == 0)
					message("250 2.0.0 Queuing for queue group %s started", id);
				break;
			}

d2166 1
a2166 2
			new = (QUEUE_CHAR *) sm_malloc(sizeof(QUEUE_CHAR));
			if (new == NULL)
a2171 1
			new->queue_negate = false;
d2174 2
a2175 2
			ok = runqueue(true, false, false, true);
			sm_free(QueueLimitRecipient); /* XXX */
a2181 1
			DELAY_CONN("HELP");
d2186 1
a2186 2
			DELAY_CONN("NOOP");
			(void) checksmtpattack(&n_noop, MAXNOOPCOMMANDS, true,
a2192 6
#if PIPELINING
			(void) sm_io_flush(OutChannel, SM_TIME_DEFAULT);
#endif /* PIPELINING */

			if (smtp.sm_nrcpts > 0)
				logundelrcpts(e, "aborted by sender", 9, false);
d2197 1
a2197 1
#if STARTTLS
d2202 1
a2202 1
				tls_active = false;
d2204 2
a2205 2
#endif /* STARTTLS */
#if SASL
a2209 1
				/* XXX sasl_done(); this is a child */
d2211 1
a2211 1
#endif /* SASL */
d2217 1
a2217 1
#if MILTER
d2220 4
a2223 1
#endif /* MILTER */
d2233 1
a2233 1
				d = macvalue(macid("{daemon_name}"), e);
d2236 2
a2237 9

				/*
				**  even though this id is "bogus", it makes
				**  it simpler to "grep" related events, e.g.,
				**  timeouts for the same connection.
				*/

				sm_syslog(LOG_INFO, e->e_id,
					  "%.100s did not issue MAIL/EXPN/VRFY/ETRN during connection to %s",
d2240 1
a2240 4
#if PROFILING
			return;
#endif /* PROFILING */
			finis(true, ExitStat);
a2243 1
			DELAY_CONN("VERB");
a2244 1
			    !bitset(SRV_OFFER_VERB, features) ||
d2251 1
a2251 1
			(void) checksmtpattack(&n_noop, MAXNOOPCOMMANDS, true,
d2258 15
a2272 1
#if SMTPDEBUG
d2274 2
a2275 3
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Send Queue=");
			printaddr(e->e_sendqueue, true);
d2284 1
a2284 1
#else /* SMTPDEBUG */
d2287 1
a2287 1
#endif /* SMTPDEBUG */
a2288 1
			DELAY_CONN("Bogus");
d2297 1
a2297 2
#if MAXBADCOMMANDS > 0
			if (++n_badcmds > MAXBADCOMMANDS)
a2305 1
#endif /* MAXBADCOMMANDS > 0 */
a2311 1
			DELAY_CONN("Unimpl");
a2316 1
			DELAY_CONN("default");
d2321 1
a2321 1
#if SASL
d2323 1
a2323 10
#endif /* SASL */
	    }
	    SM_EXCEPT(exc, "[!F]*")
	    {
		/*
		**  The only possible exception is "E:mta.quickabort".
		**  There is nothing to do except fall through and loop.
		*/
	    }
	    SM_END_TRY
d2325 1
d2328 1
a2328 1
**  SMTP_DATA -- implement the SMTP DATA command.
d2331 6
a2336 2
**		smtp -- status of SMTP connection.
**		e -- envelope.
d2339 1
a2339 1
**		none.
d2342 1
a2342 1
**		possibly sends message.
d2345 6
a2350 3
static void
smtp_data(smtp, e)
	SMTP_T *smtp;
d2353 1
a2353 12
#if MILTER
	bool milteraccept;
#endif /* MILTER */
	bool aborting;
	bool doublequeue;
	ADDRESS *a;
	ENVELOPE *ee;
	char *id;
	char buf[32];

	SmtpPhase = "server DATA";
	if (!smtp->sm_gotmail)
d2355 1
a2355 12
		usrerr("503 5.0.0 Need MAIL command");
		return;
	}
	else if (smtp->sm_nrcpts <= 0)
	{
		usrerr("503 5.0.0 Need RCPT (recipient)");
		return;
	}
	(void) sm_snprintf(buf, sizeof buf, "%u", smtp->sm_nrcpts);
	if (rscheck("check_data", buf, NULL, e,
		    true, false, 3, NULL, e->e_id) != EX_OK)
		return;
d2357 1
a2357 11
	/* put back discard bit */
	if (smtp->sm_discard)
		e->e_flags |= EF_DISCARD;

	/* check to see if we need to re-expand aliases */
	/* also reset QS_BADADDR on already-diagnosted addrs */
	doublequeue = false;
	for (a = e->e_sendqueue; a != NULL; a = a->q_next)
	{
		if (QS_IS_VERIFIED(a->q_state) &&
		    !bitset(EF_DISCARD, e->e_flags))
d2359 3
a2361 2
			/* need to re-expand aliases */
			doublequeue = true;
d2363 7
a2369 1
		if (QS_IS_BADADDR(a->q_state))
d2371 2
a2372 2
			/* make this "go away" */
			a->q_state = QS_DONTSEND;
d2374 1
d2376 24
d2401 4
a2404 3
	/* collect the text of the message */
	SmtpPhase = "collect";
	buffer_errors();
d2406 15
a2420 5
#if _FFR_ADAPTIVE_EOL
	/* triggers error in collect, disabled for now */
	if (smtp->sm_crlf)
		e->e_flags |= EF_NL_NOT_EOL;
#endif /* _FFR_ADAPTIVE_EOL */
d2422 2
a2423 1
	collect(InChannel, true, NULL, e);
d2425 3
a2427 3
	/* redefine message size */
	(void) sm_snprintf(buf, sizeof buf, "%ld", e->e_msgsize);
	macdefine(&e->e_macro, A_TEMP, macid("{msg_size}"), buf);
d2429 13
a2441 5
#if _FFR_CHECK_EOM
	/* rscheck() will set Errors or EF_DISCARD if it trips */
	(void) rscheck("check_eom", buf, NULL, e, false,
		       true, 3, NULL, e->e_id);
#endif /* _FFR_CHECK_EOM */
d2443 7
a2449 5
#if MILTER
	milteraccept = true;
	if (smtp->sm_milterlist && smtp->sm_milterize &&
	    Errors <= 0 &&
	    !bitset(EF_DISCARD, e->e_flags))
d2451 8
a2458 5
		char state;
		char *response;

		response = milter_data(e, &state);
		switch (state)
d2460 2
a2461 22
		  case SMFIR_REPLYCODE:
			milteraccept = false;
			usrerr(response);
			break;

		  case SMFIR_REJECT:
			milteraccept = false;
			if (MilterLogLevel > 8)
				sm_syslog(LOG_INFO, e->e_id,
					  "Milter: reject, message data");
			usrerr("554 5.7.1 Command rejected");
			break;

		  case SMFIR_DISCARD:
			milteraccept = false;
			e->e_flags |= EF_DISCARD;
			break;

		  case SMFIR_TEMPFAIL:
			milteraccept = false;
			usrerr(MSG_TEMPFAIL);
			break;
a2462 2
		if (response != NULL)
			sm_free(response);
d2464 1
a2464 7

	/* Milter may have changed message size */
	(void) sm_snprintf(buf, sizeof buf, "%ld", e->e_msgsize);
	macdefine(&e->e_macro, A_TEMP, macid("{msg_size}"), buf);

	/* abort message filters that didn't get the body & log msg is OK */
	if (smtp->sm_milterlist && smtp->sm_milterize)
d2466 6
a2471 259
		milter_abort(e);
		if (milteraccept && MilterLogLevel > 9)
			sm_syslog(LOG_INFO, e->e_id, "Milter accept: message");
	}
#endif /* MILTER */

	/*
	**  If a header/body check (header checks or milter)
	**  set EF_DISCARD, don't queueup the message --
	**  that would lose the EF_DISCARD bit and deliver
	**  the message.
	*/

	if (bitset(EF_DISCARD, e->e_flags))
		doublequeue = false;

	aborting = Errors > 0;
	if (!aborting)
		aborting = !split_by_recipient(e);

	if (aborting)
	{
		/* Log who the mail would have gone to */
		logundelrcpts(e, e->e_message, 8, false);
		flush_errors(true);
		buffer_errors();
		goto abortmessage;
	}

	/* from now on, we have to operate silently */
	buffer_errors();

#if 0
	/*
	**  Clear message, it may contain an error from the SMTP dialogue.
	**  This error must not show up in the queue.
	**	Some error message should show up, e.g., alias database
	**	not available, but others shouldn't, e.g., from check_rcpt.
	*/

	e->e_message = NULL;
#endif /* 0 */

	/*
	**  Arrange to send to everyone.
	**	If sending to multiple people, mail back
	**		errors rather than reporting directly.
	**	In any case, don't mail back errors for
	**		anything that has happened up to
	**		now (the other end will do this).
	**	Truncate our transcript -- the mail has gotten
	**		to us successfully, and if we have
	**		to mail this back, it will be easier
	**		on the reader.
	**	Then send to everyone.
	**	Finally give a reply code.  If an error has
	**		already been given, don't mail a
	**		message back.
	**	We goose error returns by clearing error bit.
	*/

	SmtpPhase = "delivery";
	(void) sm_io_setinfo(e->e_xfp, SM_BF_TRUNCATE, NULL);
	id = e->e_id;

#if NAMED_BIND
	_res.retry = TimeOuts.res_retry[RES_TO_FIRST];
	_res.retrans = TimeOuts.res_retrans[RES_TO_FIRST];
#endif /* NAMED_BIND */

	for (ee = e; ee != NULL; ee = ee->e_sibling)
	{
		/* make sure we actually do delivery */
		ee->e_flags &= ~EF_CLRQUEUE;

		/* from now on, operate silently */
		ee->e_errormode = EM_MAIL;

		if (doublequeue)
		{
			/* make sure it is in the queue */
			queueup(ee, false, true);
		}
		else
		{
			/* send to all recipients */
			sendall(ee, SM_DEFAULT);
		}
		ee->e_to = NULL;
	}

	/* issue success message */
	message("250 2.0.0 %s Message accepted for delivery", id);

	/* if we just queued, poke it */
	if (doublequeue)
	{
		bool anything_to_send = false;

		sm_getla();
		for (ee = e; ee != NULL; ee = ee->e_sibling)
		{
			if (WILL_BE_QUEUED(ee->e_sendmode))
				continue;
			if (shouldqueue(ee->e_msgpriority, ee->e_ctime))
			{
				ee->e_sendmode = SM_QUEUE;
				continue;
			}
			anything_to_send = true;

			/* close all the queue files */
			closexscript(ee);
			if (ee->e_dfp != NULL)
			{
				(void) sm_io_close(ee->e_dfp, SM_TIME_DEFAULT);
				ee->e_dfp = NULL;
			}
			unlockqueue(ee);
		}
		if (anything_to_send)
		{
#if PIPELINING
			/*
			**  XXX if we don't do this, we get 250 twice
			**	because it is also flushed in the child.
			*/

			(void) sm_io_flush(OutChannel, SM_TIME_DEFAULT);
#endif /* PIPELINING */
			(void) doworklist(e, true, true);
		}
	}

  abortmessage:
	if (LogLevel > 4 && bitset(EF_LOGSENDER, e->e_flags))
		logsender(e, NULL);
	e->e_flags &= ~EF_LOGSENDER;

	/* clean up a bit */
	smtp->sm_gotmail = false;

	/*
	**  Call dropenvelope if and only if the envelope is *not*
	**  being processed by the child process forked by doworklist().
	*/

	if (aborting || bitset(EF_DISCARD, e->e_flags))
		dropenvelope(e, true, false);
	else
	{
		for (ee = e; ee != NULL; ee = ee->e_sibling)
		{
			if (WILL_BE_QUEUED(ee->e_sendmode))
				dropenvelope(ee, true, false);
		}
	}
	sm_rpool_free(e->e_rpool);

	/*
	**  At this point, e == &MainEnvelope, but if we did splitting,
	**  then CurEnv may point to an envelope structure that was just
	**  freed with the rpool.  So reset CurEnv *before* calling
	**  newenvelope.
	*/

	CurEnv = e;
	newenvelope(e, e, sm_rpool_new_x(NULL));
	e->e_flags = BlankEnvelope.e_flags;
}
/*
**  LOGUNDELRCPTS -- log undelivered (or all) recipients.
**
**	Parameters:
**		e -- envelope.
**		msg -- message for Stat=
**		level -- log level.
**		all -- log all recipients.
**
**	Returns:
**		none.
**
**	Side Effects:
**		logs undelivered (or all) recipients
*/

void
logundelrcpts(e, msg, level, all)
	ENVELOPE *e;
	char *msg;
	int level;
	bool all;
{
	ADDRESS *a;

	if (LogLevel <= level || msg == NULL || *msg == '\0')
		return;

	/* Clear $h so relay= doesn't get mislogged by logdelivery() */
	macdefine(&e->e_macro, A_PERM, 'h', NULL);

	/* Log who the mail would have gone to */
	for (a = e->e_sendqueue; a != NULL; a = a->q_next)
	{
		if (!QS_IS_UNDELIVERED(a->q_state) && !all)
			continue;
		e->e_to = a->q_paddr;
		logdelivery(NULL, NULL, a->q_status, msg, NULL,
			    (time_t) 0, e);
	}
	e->e_to = NULL;
}
/*
**  CHECKSMTPATTACK -- check for denial-of-service attack by repetition
**
**	Parameters:
**		pcounter -- pointer to a counter for this command.
**		maxcount -- maximum value for this counter before we
**			slow down.
**		waitnow -- sleep now (in this routine)?
**		cname -- command name for logging.
**		e -- the current envelope.
**
**	Returns:
**		time to wait.
**
**	Side Effects:
**		Slows down if we seem to be under attack.
*/

static time_t
checksmtpattack(pcounter, maxcount, waitnow, cname, e)
	volatile unsigned int *pcounter;
	int maxcount;
	bool waitnow;
	char *cname;
	ENVELOPE *e;
{
	if (maxcount <= 0)	/* no limit */
		return (time_t) 0;

	if (++(*pcounter) >= maxcount)
	{
		time_t s;

		if (*pcounter == maxcount && LogLevel > 5)
		{
			sm_syslog(LOG_INFO, e->e_id,
				  "%.100s: possible SMTP attack: command=%.40s, count=%u",
				  CurSmtpClient, cname, *pcounter);
		}
		s = 1 << (*pcounter - maxcount);
		if (s >= MAXTIMEOUT || s <= 0)
			s = MAXTIMEOUT;

		/* sleep at least 1 second before returning */
		(void) sleep(*pcounter / maxcount);
		s -= *pcounter / maxcount;
		if (waitnow)
d2473 1
a2473 158
			(void) sleep(s);
			return 0;
		}
		return s;
	}
	return (time_t) 0;
}
/*
**  SETUP_SMTPD_IO -- setup I/O fd correctly for the SMTP server
**
**	Parameters:
**		none.
**
**	Returns:
**		nothing.
**
**	Side Effects:
**		may change I/O fd.
*/

static void
setup_smtpd_io()
{
	int inchfd, outchfd, outfd;

	inchfd = sm_io_getinfo(InChannel, SM_IO_WHAT_FD, NULL);
	outchfd  = sm_io_getinfo(OutChannel, SM_IO_WHAT_FD, NULL);
	outfd = sm_io_getinfo(smioout, SM_IO_WHAT_FD, NULL);
	if (outchfd != outfd)
	{
		/* arrange for debugging output to go to remote host */
		(void) dup2(outchfd, outfd);
	}

	/*
	**  if InChannel and OutChannel are stdin/stdout
	**  and connected to ttys
	**  and fcntl(STDIN, F_SETFL, O_NONBLOCKING) also changes STDOUT,
	**  then "chain" them together.
	*/

	if (inchfd == STDIN_FILENO && outchfd == STDOUT_FILENO &&
	    isatty(inchfd) && isatty(outchfd))
	{
		int inmode, outmode;

		inmode = fcntl(inchfd, F_GETFL, 0);
		if (inmode == -1)
		{
			if (LogLevel > 11)
				sm_syslog(LOG_INFO, NOQID,
					"fcntl(inchfd, F_GETFL) failed: %s",
					sm_errstring(errno));
			return;
		}
		outmode = fcntl(outchfd, F_GETFL, 0);
		if (outmode == -1)
		{
			if (LogLevel > 11)
				sm_syslog(LOG_INFO, NOQID,
					"fcntl(outchfd, F_GETFL) failed: %s",
					sm_errstring(errno));
			return;
		}
		if (bitset(O_NONBLOCK, inmode) ||
		    bitset(O_NONBLOCK, outmode) ||
		    fcntl(inchfd, F_SETFL, inmode | O_NONBLOCK) == -1)
			return;
		outmode = fcntl(outchfd, F_GETFL, 0);
		if (outmode != -1 && bitset(O_NONBLOCK, outmode))
		{
			/* changing InChannel also changes OutChannel */
			sm_io_automode(OutChannel, InChannel);
			if (tTd(97, 4) && LogLevel > 9)
				sm_syslog(LOG_INFO, NOQID,
					  "set automode for I (%d)/O (%d) in SMTP server",
					  inchfd, outchfd);
		}

		/* undo change of inchfd */
		(void) fcntl(inchfd, F_SETFL, inmode);
	}
}
/*
**  SKIPWORD -- skip a fixed word.
**
**	Parameters:
**		p -- place to start looking.
**		w -- word to skip.
**
**	Returns:
**		p following w.
**		NULL on error.
**
**	Side Effects:
**		clobbers the p data area.
*/

static char *
skipword(p, w)
	register char *volatile p;
	char *w;
{
	register char *q;
	char *firstp = p;

	/* find beginning of word */
	SKIP_SPACE(p);
	q = p;

	/* find end of word */
	while (*p != '\0' && *p != ':' && !(isascii(*p) && isspace(*p)))
		p++;
	while (isascii(*p) && isspace(*p))
		*p++ = '\0';
	if (*p != ':')
	{
	  syntax:
		usrerr("501 5.5.2 Syntax error in parameters scanning \"%s\"",
			shortenstring(firstp, MAXSHORTSTR));
		return NULL;
	}
	*p++ = '\0';
	SKIP_SPACE(p);

	if (*p == '\0')
		goto syntax;

	/* see if the input word matches desired word */
	if (sm_strcasecmp(q, w))
		goto syntax;

	return p;
}
/*
**  MAIL_ESMTP_ARGS -- process ESMTP arguments from MAIL line
**
**	Parameters:
**		kp -- the parameter key.
**		vp -- the value of that parameter.
**		e -- the envelope.
**
**	Returns:
**		none.
*/

static void
mail_esmtp_args(kp, vp, e)
	char *kp;
	char *vp;
	ENVELOPE *e;
{
	if (sm_strcasecmp(kp, "size") == 0)
	{
		if (vp == NULL)
		{
			usrerr("501 5.5.2 SIZE requires a value");
			/* NOTREACHED */
d2475 1
a2475 20
		macdefine(&e->e_macro, A_TEMP, macid("{msg_size}"), vp);
		e->e_msgsize = strtol(vp, (char **) NULL, 10);
		if (e->e_msgsize == LONG_MAX && errno == ERANGE)
		{
			usrerr("552 5.2.3 Message size exceeds maximum value");
			/* NOTREACHED */
		}
	}
	else if (sm_strcasecmp(kp, "body") == 0)
	{
		if (vp == NULL)
		{
			usrerr("501 5.5.2 BODY requires a value");
			/* NOTREACHED */
		}
		else if (sm_strcasecmp(vp, "8bitmime") == 0)
		{
			SevenBitInput = false;
		}
		else if (sm_strcasecmp(vp, "7bit") == 0)
d2477 1
a2477 1
			SevenBitInput = true;
d2481 2
a2482 1
			usrerr("501 5.5.4 Unknown BODY type %s", vp);
d2485 1
a2485 1
		e->e_bodytype = sm_rpool_strdup_x(e->e_rpool, vp);
d2487 1
a2487 1
	else if (sm_strcasecmp(kp, "envid") == 0)
d2509 2
a2510 3
		e->e_envid = sm_rpool_strdup_x(e->e_rpool, vp);
		macdefine(&e->e_macro, A_PERM,
			macid("{dsn_envid}"), e->e_envid);
d2512 1
a2512 1
	else if (sm_strcasecmp(kp, "ret") == 0)
d2530 1
a2530 1
		if (sm_strcasecmp(vp, "hdrs") == 0)
d2532 1
a2532 1
		else if (sm_strcasecmp(vp, "full") != 0)
d2537 1
a2537 1
		macdefine(&e->e_macro, A_TEMP, macid("{dsn_ret}"), vp);
d2539 2
a2540 2
#if SASL
	else if (sm_strcasecmp(kp, "auth") == 0)
a2546 1
		bool saveExitStat = ExitStat;
d2564 1
a2564 1
		(void) sm_strlcpy(auth_param, vp, len);
d2573 1
a2573 1
		(void) sm_strlcpy(pbuf, xuntextify(auth_param), sizeof pbuf);
d2577 1
a2577 1
		macdefine(&e->e_macro, A_TEMP, macid("{auth_author}"), pbuf);
d2586 2
a2587 2
		SuprErrs = true;
		QuickAbort = false;
d2589 2
a2590 2
		     (rscheck("trust_auth", pbuf, NULL, e, true, false, 9,
			      NULL, NOQID) != EX_OK || Errors > 0))
d2595 1
a2595 1
				sm_dprintf("auth=\"%.100s\" not trusted user=\"%.100s\"\n",
a2597 1

d2599 1
a2599 1
			e->e_auth_param = "<>";
d2604 2
a2605 3
				sm_dprintf("auth=\"%.100s\" trusted\n", pbuf);
			e->e_auth_param = sm_rpool_strdup_x(e->e_rpool,
							    auth_param);
d2607 1
a2607 2
		sm_free(auth_param); /* XXX */

a2611 75
		ExitStat = saveExitStat;
	}
#endif /* SASL */
#define PRTCHAR(c)	((isascii(c) && isprint(c)) ? (c) : '?')

	/*
	**  "by" is only accepted if DeliverByMin >= 0.
	**  We maybe could add this to the list of server_features.
	*/

	else if (sm_strcasecmp(kp, "by") == 0 && DeliverByMin >= 0)
	{
		char *s;

		if (vp == NULL)
		{
			usrerr("501 5.5.2 BY= requires a value");
			/* NOTREACHED */
		}
		e->e_deliver_by = strtol(vp, &s, 10);
		if (e->e_deliver_by == LONG_MIN ||
		    e->e_deliver_by == LONG_MAX ||
		    e->e_deliver_by > 999999999l ||
		    e->e_deliver_by < -999999999l)
		{
			usrerr("501 5.5.2 BY=%s out of range", vp);
			/* NOTREACHED */
		}
		if (s == NULL || *s != ';')
		{
			usrerr("501 5.5.2 BY= missing ';'");
			/* NOTREACHED */
		}
		e->e_dlvr_flag = 0;
		++s;	/* XXX: spaces allowed? */
		SKIP_SPACE(s);
		switch (tolower(*s))
		{
		  case 'n':
			e->e_dlvr_flag = DLVR_NOTIFY;
			break;
		  case 'r':
			e->e_dlvr_flag = DLVR_RETURN;
			if (e->e_deliver_by <= 0)
			{
				usrerr("501 5.5.4 mode R requires BY time > 0");
				/* NOTREACHED */
			}
			if (DeliverByMin > 0 && e->e_deliver_by > 0 &&
			    e->e_deliver_by < DeliverByMin)
			{
				usrerr("555 5.5.2 time %ld less than %ld",
					e->e_deliver_by, (long) DeliverByMin);
				/* NOTREACHED */
			}
			break;
		  default:
			usrerr("501 5.5.2 illegal by-mode '%c'", PRTCHAR(*s));
			/* NOTREACHED */
		}
		++s;	/* XXX: spaces allowed? */
		SKIP_SPACE(s);
		switch (tolower(*s))
		{
		  case 't':
			e->e_dlvr_flag |= DLVR_TRACE;
			break;
		  case '\0':
			break;
		  default:
			usrerr("501 5.5.2 illegal by-trace '%c'", PRTCHAR(*s));
			/* NOTREACHED */
		}

		/* XXX: check whether more characters follow? */
d2613 1
d2640 1
a2640 1
	if (sm_strcasecmp(kp, "notify") == 0)
d2656 1
a2656 1
		macdefine(&e->e_macro, A_TEMP, macid("{dsn_notify}"), vp);
d2658 1
a2658 1
		if (sm_strcasecmp(vp, "never") == 0)
d2665 1
a2665 1
			if (sm_strcasecmp(vp, "success") == 0)
d2667 1
a2667 1
			else if (sm_strcasecmp(vp, "failure") == 0)
d2669 1
a2669 1
			else if (sm_strcasecmp(vp, "delay") == 0)
d2679 1
a2679 1
	else if (sm_strcasecmp(kp, "orcpt") == 0)
d2701 1
a2701 1
		a->q_orcpt = sm_rpool_strdup_x(e->e_rpool, vp);
d2713 1
a2713 1
**		a -- the address to print.
d2735 1
a2735 1
		(void) sm_strlcpy(fmtbuf, "252", sizeof fmtbuf);
d2737 1
a2737 1
		(void) sm_strlcpy(fmtbuf, "250", sizeof fmtbuf);
d2739 1
a2739 1
	(void) sm_strlcpy(&fmtbuf[4], "2.1.5 ", sizeof fmtbuf - 4);
d2744 1
a2744 1
		     sm_strcasecmp(a->q_mailer->m_addrtype, "rfc822") == 0) &&
d2746 1
a2746 1
			(void) sm_strlcpy(&fmtbuf[OFFF], "<%s@@%s>",
d2749 1
a2749 1
			(void) sm_strlcpy(&fmtbuf[OFFF], "<%s>",
d2757 1
a2757 1
		     sm_strcasecmp(a->q_mailer->m_addrtype, "rfc822") == 0) &&
d2759 1
a2759 1
			(void) sm_strlcpy(&fmtbuf[OFFF], "%s <%s@@%s>",
d2762 1
a2762 1
			(void) sm_strlcpy(&fmtbuf[OFFF], "%s <%s>",
d2767 95
a2862 1
#if SASL
d2867 2
a2868 2
**		conn -- SASL connection info.
**		mechlist -- output parameter for list of mechanisms.
d2871 1
a2871 1
**		number of mechs.
d2884 10
a2893 2
			       (unsigned int *)&len, (unsigned int *)&num);
	if (result != SASL_OK)
d2897 1
a2897 1
				  "AUTH error: listmech=%d, num=%d",
a2900 10
	if (num > 0)
	{
		if (LogLevel > 11)
			sm_syslog(LOG_INFO, NOQID,
				  "AUTH: available mech=%s, allowed mech=%s",
				  *mechlist, AuthMechanisms);
		*mechlist = intersect(AuthMechanisms, *mechlist, NULL);
	}
	else
		*mechlist = NULL;	/* be paranoid... */
d2903 1
d2908 5
a2912 5
**		context -- unused.
**		auth_identity -- authentication identity.
**		requested_user -- authorization identity.
**		user -- allowed user (output).
**		errstr -- possible error string (output).
a2930 1
#endif /* SASL */
d2932 40
a2971 1
#if STARTTLS
d2973 1
a2973 1
**  INITSRVTLS -- initialize server side TLS
d2976 2
a2977 1
**		tls_ok -- should tls initialization be done?
d2980 1
a2980 1
**		succeeded?
d2983 1
a2983 2
**		sets tls_ok_srv which is a static variable in this module.
**		Do NOT remove assignments to it!
d2986 2
d2989 208
a3196 2
initsrvtls(tls_ok)
	bool tls_ok;
d3198 7
a3204 2
	if (!tls_ok)
		return false;
d3206 25
a3230 4
	/* do NOT remove assignment */
	tls_ok_srv = inittls(&srv_ctx, TLS_Srv_Opts, true, SrvCERTfile,
			     Srvkeyfile, CACERTpath, CACERTfile, DHParams);
	return tls_ok_srv;
d3232 60
a3291 1
#endif /* STARTTLS */
d3293 1
a3293 1
**  SRVFEATURES -- get features for SMTP server
d3296 12
a3307 34
**		e -- envelope (should be session context).
**		clientname -- name of client.
**		features -- default features for this invocation.
**
**	Returns:
**		server features.
*/

/* table with options: it uses just one character, how about strings? */
static struct
{
	char		srvf_opt;
	unsigned int	srvf_flag;
} srv_feat_table[] =
{
	{ 'A',	SRV_OFFER_AUTH	},
	{ 'B',	SRV_OFFER_VERB	},
	{ 'D',	SRV_OFFER_DSN	},
	{ 'E',	SRV_OFFER_ETRN	},
	{ 'L',	SRV_REQ_AUTH	},	/* not documented in 8.12 */
#if PIPELINING
# if _FFR_NO_PIPE
	{ 'N',	SRV_NO_PIPE	},
# endif /* _FFR_NO_PIPE */
	{ 'P',	SRV_OFFER_PIPE	},
#endif /* PIPELINING */
	{ 'R',	SRV_VRFY_CLT	},
	{ 'S',	SRV_OFFER_TLS	},
/*	{ 'T',	SRV_TMP_FAIL	},	*/
	{ 'V',	SRV_VRFY_CLT	},
	{ 'X',	SRV_OFFER_EXPN	},
/*	{ 'Y',	SRV_OFFER_VRFY	},	*/
	{ '\0',	SRV_NONE	}
};
d3309 6
a3314 5
static unsigned int
srvfeatures(e, clientname, features)
	ENVELOPE *e;
	char *clientname;
	unsigned int features;
d3316 202
a3517 13
	int r, i, j;
	char **pvp, c, opt;
	char pvpbuf[PSBUFSIZE];

	pvp = NULL;
	r = rscap("srv_features", clientname, "", e, &pvp, pvpbuf,
		  sizeof(pvpbuf));
	if (r != EX_OK)
		return features;
	if (pvp == NULL || pvp[0] == NULL || (pvp[0][0] & 0377) != CANONNET)
		return features;
	if (pvp[1] != NULL && sm_strncasecmp(pvp[1], "temp", 4) == 0)
		return SRV_TMP_FAIL;
d3520 2
a3521 5
	**  General rule (see sendmail.h, d_flags):
	**  lower case: required/offered, upper case: Not required/available
	**
	**  Since we can change some features per daemon, we have both
	**  cases here: turn on/off a feature.
d3523 15
d3539 4
a3542 1
	for (i = 1; pvp[i] != NULL; i++)
d3544 1
a3544 3
		c = pvp[i][0];
		j = 0;
		for (;;)
d3546 103
a3648 1
			if ((opt = srv_feat_table[j].srvf_opt) == '\0')
d3650 35
a3684 5
				if (LogLevel > 9)
					sm_syslog(LOG_WARNING, e->e_id,
						  "srvfeatures: unknown feature %s",
						  pvp[i]);
				break;
d3686 53
a3738 1
			if (c == opt)
d3740 5
a3744 2
				features &= ~(srv_feat_table[j].srvf_flag);
				break;
d3746 18
a3763 1
			if (c == tolower(opt))
d3765 6
a3770 2
				features |= srv_feat_table[j].srvf_flag;
				break;
d3772 1
a3772 1
			++j;
d3775 377
a4151 1
	return features;
d4154 2
d4161 1
a4161 1
**		e -- envelope.
d4177 1
a4177 1
	register SM_FILE_T *hf;
d4181 1
a4181 1
	bool first = true;
d4206 1
a4206 1
		noinfo = false;
d4211 1
a4211 1
		noinfo = true;
d4216 1
a4216 1
	while (sm_io_fgets(hf, SM_TIME_DEFAULT, buf, sizeof buf) != NULL)
d4225 2
a4226 2
				if (sm_io_sscanf(buf + strlen(HELPVSTR), "%d",
						 &h) == 1)
d4235 1
a4235 1
				first = false;
d4246 1
a4246 1
			fixcrlf(p, true);
d4254 1
a4254 1
			noinfo = false;
d4274 1
a4274 1
	(void) sm_io_close(hf, SM_TIME_DEFAULT);
@


