head	1.18;
access;
symbols
	OPENBSD_5_6:1.17.0.6
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.15.0.20
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.18
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.16
	OPENBSD_5_0:1.15.0.14
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.12
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.10
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.6
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.8
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.4
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.6
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.4
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2014.09.17.18.49.52;	author matthieu;	state dead;
branches;
next	1.17;
commitid	M7i5giHIoz3DMlTU;

1.17
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.15;

1.15
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2006.08.13.13.01.48;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.14.17.53.02;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.22.18.43.55;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.16.00.21.31;	author millert;	state Exp;
branches
	1.10.2.1
	1.10.4.1
	1.10.6.1;
next	1.9;

1.9
date	2004.06.24.03.59.27;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.19.01.41.14;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.17.17.31.40;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.03.17.25.47;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.18.00.49.28;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.01.17.18.30;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.11.19.02.50;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.15.21.09.09;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.02.19.05.46;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.46;	author millert;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.15;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.50;	author millert;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	2001.05.31.00.31.38;	author miod;	state Exp;
branches;
next	;

1.10.2.1
date	2006.03.24.05.42.48;	author brad;	state Exp;
branches;
next	;

1.10.4.1
date	2006.03.24.05.56.18;	author brad;	state Exp;
branches;
next	1.10.4.2;

1.10.4.2
date	2006.06.15.02.57.36;	author brad;	state Exp;
branches;
next	;

1.10.6.1
date	2006.03.25.01.49.38;	author brad;	state Exp;
branches;
next	1.10.6.2;

1.10.6.2
date	2006.06.15.02.46.09;	author brad;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2003, 2006, 2013 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1994, 1996-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>
#include <string.h>

SM_RCSID("@@(#)$Sendmail: mime.c,v 8.149 2013/11/22 20:51:56 ca Exp $")

/*
**  MIME support.
**
**	I am indebted to John Beck of Hewlett-Packard, who contributed
**	his code to me for inclusion.  As it turns out, I did not use
**	his code since he used a "minimum change" approach that used
**	several temp files, and I wanted a "minimum impact" approach
**	that would avoid copying.  However, looking over his code
**	helped me cement my understanding of the problem.
**
**	I also looked at, but did not directly use, Nathaniel
**	Borenstein's "code.c" module.  Again, it functioned as
**	a file-to-file translator, which did not fit within my
**	design bounds, but it was a useful base for understanding
**	the problem.
*/

/* use "old" mime 7 to 8 algorithm by default */
#ifndef MIME7TO8_OLD
# define MIME7TO8_OLD	1
#endif /* ! MIME7TO8_OLD */

#if MIME8TO7
static int	isboundary __P((char *, char **));
static int	mimeboundary __P((char *, char **));
static int	mime_getchar __P((SM_FILE_T *, char **, int *));
static int	mime_getchar_crlf __P((SM_FILE_T *, char **, int *));

/* character set for hex and base64 encoding */
static char	Base16Code[] =	"0123456789ABCDEF";
static char	Base64Code[] =	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

/* types of MIME boundaries */
# define MBT_SYNTAX	0	/* syntax error */
# define MBT_NOTSEP	1	/* not a boundary */
# define MBT_INTERMED	2	/* intermediate boundary (no trailing --) */
# define MBT_FINAL	3	/* final boundary (trailing -- included) */

static char	*MimeBoundaryNames[] =
{
	"SYNTAX",	"NOTSEP",	"INTERMED",	"FINAL"
};

static bool	MapNLtoCRLF;

/*
**  MIME8TO7 -- output 8 bit body in 7 bit format
**
**	The header has already been output -- this has to do the
**	8 to 7 bit conversion.  It would be easy if we didn't have
**	to deal with nested formats (multipart/xxx and message/rfc822).
**
**	We won't be called if we don't have to do a conversion, and
**	appropriate MIME-Version: and Content-Type: fields have been
**	output.  Any Content-Transfer-Encoding: field has not been
**	output, and we can add it here.
**
**	Parameters:
**		mci -- mailer connection information.
**		header -- the header for this body part.
**		e -- envelope.
**		boundaries -- the currently pending message boundaries.
**			NULL if we are processing the outer portion.
**		flags -- to tweak processing.
**		level -- recursion level.
**
**	Returns:
**		An indicator of what terminated the message part:
**		  MBT_FINAL -- the final boundary
**		  MBT_INTERMED -- an intermediate boundary
**		  MBT_NOTSEP -- an end of file
**		  SM_IO_EOF -- I/O error occurred
*/

struct args
{
	char	*a_field;	/* name of field */
	char	*a_value;	/* value of that field */
};

int
mime8to7(mci, header, e, boundaries, flags, level)
	register MCI *mci;
	HDR *header;
	register ENVELOPE *e;
	char **boundaries;
	int flags;
	int level;
{
	register char *p;
	int linelen;
	int blen;
	int bt;
	off_t offset;
	size_t sectionsize, sectionhighbits;
	int i;
	char *type;
	char *subtype;
	char *cte;
	char **pvp;
	int argc = 0;
	char *bp;
	bool use_qp = false;
	struct args argv[MAXMIMEARGS];
	char bbuf[128];
	char buf[MAXLINE];
	char pvpbuf[MAXLINE];
	extern unsigned char MimeTokenTab[256];

	if (level > MAXMIMENESTING)
	{
		if (!bitset(EF_TOODEEP, e->e_flags))
		{
			if (tTd(43, 4))
				sm_dprintf("mime8to7: too deep, level=%d\n",
					   level);
			usrerr("mime8to7: recursion level %d exceeded",
				level);
			e->e_flags |= EF_DONT_MIME|EF_TOODEEP;
		}
	}
	if (tTd(43, 1))
	{
		sm_dprintf("mime8to7: flags = %x, boundaries =", flags);
		if (boundaries[0] == NULL)
			sm_dprintf(" <none>");
		else
		{
			for (i = 0; boundaries[i] != NULL; i++)
				sm_dprintf(" %s", boundaries[i]);
		}
		sm_dprintf("\n");
	}
	MapNLtoCRLF = true;
	p = hvalue("Content-Transfer-Encoding", header);
	if (p == NULL ||
	    (pvp = prescan(p, '\0', pvpbuf, sizeof(pvpbuf), NULL,
			   MimeTokenTab, false)) == NULL ||
	    pvp[0] == NULL)
	{
		cte = NULL;
	}
	else
	{
		cataddr(pvp, NULL, buf, sizeof(buf), '\0', false);
		cte = sm_rpool_strdup_x(e->e_rpool, buf);
	}

	type = subtype = NULL;
	p = hvalue("Content-Type", header);
	if (p == NULL)
	{
		if (bitset(M87F_DIGEST, flags))
			p = "message/rfc822";
		else
			p = "text/plain";
	}
	if (p != NULL &&
	    (pvp = prescan(p, '\0', pvpbuf, sizeof(pvpbuf), NULL,
			   MimeTokenTab, false)) != NULL &&
	    pvp[0] != NULL)
	{
		if (tTd(43, 40))
		{
			for (i = 0; pvp[i] != NULL; i++)
				sm_dprintf("pvp[%d] = \"%s\"\n", i, pvp[i]);
		}
		type = *pvp++;
		if (*pvp != NULL && strcmp(*pvp, "/") == 0 &&
		    *++pvp != NULL)
		{
			subtype = *pvp++;
		}

		/* break out parameters */
		while (*pvp != NULL && argc < MAXMIMEARGS)
		{
			/* skip to semicolon separator */
			while (*pvp != NULL && strcmp(*pvp, ";") != 0)
				pvp++;
			if (*pvp++ == NULL || *pvp == NULL)
				break;

			/* complain about empty values */
			if (strcmp(*pvp, ";") == 0)
			{
				usrerr("mime8to7: Empty parameter in Content-Type header");

				/* avoid bounce loops */
				e->e_flags |= EF_DONT_MIME;
				continue;
			}

			/* extract field name */
			argv[argc].a_field = *pvp++;

			/* see if there is a value */
			if (*pvp != NULL && strcmp(*pvp, "=") == 0 &&
			    (*++pvp == NULL || strcmp(*pvp, ";") != 0))
			{
				argv[argc].a_value = *pvp;
				argc++;
			}
		}
	}

	/* check for disaster cases */
	if (type == NULL)
		type = "-none-";
	if (subtype == NULL)
		subtype = "-none-";

	/* don't propagate some flags more than one level into the message */
	flags &= ~M87F_DIGEST;

	/*
	**  Check for cases that can not be encoded.
	**
	**	For example, you can't encode certain kinds of types
	**	or already-encoded messages.  If we find this case,
	**	just copy it through.
	*/

	(void) sm_snprintf(buf, sizeof(buf), "%.100s/%.100s", type, subtype);
	if (wordinclass(buf, 'n') || (cte != NULL && !wordinclass(cte, 'e')))
		flags |= M87F_NO8BIT;

# ifdef USE_B_CLASS
	if (wordinclass(buf, 'b') || wordinclass(type, 'b'))
		MapNLtoCRLF = false;
# endif /* USE_B_CLASS */
	if (wordinclass(buf, 'q') || wordinclass(type, 'q'))
		use_qp = true;

	/*
	**  Multipart requires special processing.
	**
	**	Do a recursive descent into the message.
	*/

	if (sm_strcasecmp(type, "multipart") == 0 &&
	    (!bitset(M87F_NO8BIT, flags) || bitset(M87F_NO8TO7, flags)) &&
	    !bitset(EF_TOODEEP, e->e_flags)
	   )
	{

		if (sm_strcasecmp(subtype, "digest") == 0)
			flags |= M87F_DIGEST;

		for (i = 0; i < argc; i++)
		{
			if (sm_strcasecmp(argv[i].a_field, "boundary") == 0)
				break;
		}
		if (i >= argc || argv[i].a_value == NULL)
		{
			usrerr("mime8to7: Content-Type: \"%s\": %s boundary",
				i >= argc ? "missing" : "bogus", p);
			p = "---";

			/* avoid bounce loops */
			e->e_flags |= EF_DONT_MIME;
		}
		else
		{
			p = argv[i].a_value;
			stripquotes(p);
		}
		if (sm_strlcpy(bbuf, p, sizeof(bbuf)) >= sizeof(bbuf))
		{
			usrerr("mime8to7: multipart boundary \"%s\" too long",
				p);

			/* avoid bounce loops */
			e->e_flags |= EF_DONT_MIME;
		}

		if (tTd(43, 1))
			sm_dprintf("mime8to7: multipart boundary \"%s\"\n",
				bbuf);
		for (i = 0; i < MAXMIMENESTING; i++)
		{
			if (boundaries[i] == NULL)
				break;
		}
		if (i >= MAXMIMENESTING)
		{
			if (tTd(43, 4))
				sm_dprintf("mime8to7: too deep, i=%d\n", i);
			if (!bitset(EF_TOODEEP, e->e_flags))
				usrerr("mime8to7: multipart nesting boundary too deep");

			/* avoid bounce loops */
			e->e_flags |= EF_DONT_MIME|EF_TOODEEP;
		}
		else
		{
			boundaries[i] = bbuf;
			boundaries[i + 1] = NULL;
		}
		mci->mci_flags |= MCIF_INMIME;

		/* skip the early "comment" prologue */
		if (!putline("", mci))
			goto writeerr;
		mci->mci_flags &= ~MCIF_INHEADER;
		bt = MBT_FINAL;
		while ((blen = sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf,
					sizeof(buf))) >= 0)
		{
			bt = mimeboundary(buf, boundaries);
			if (bt != MBT_NOTSEP)
				break;
			if (!putxline(buf, blen, mci,
					PXLF_MAPFROM|PXLF_STRIP8BIT))
				goto writeerr;
			if (tTd(43, 99))
				sm_dprintf("  ...%s", buf);
		}
		if (sm_io_eof(e->e_dfp))
			bt = MBT_FINAL;
		while (bt != MBT_FINAL)
		{
			auto HDR *hdr = NULL;

			(void) sm_strlcpyn(buf, sizeof(buf), 2, "--", bbuf);
			if (!putline(buf, mci))
				goto writeerr;
			if (tTd(43, 35))
				sm_dprintf("  ...%s\n", buf);
			collect(e->e_dfp, false, &hdr, e, false);
			if (tTd(43, 101))
				putline("+++after collect", mci);
			if (!putheader(mci, hdr, e, flags))
				goto writeerr;
			if (tTd(43, 101))
				putline("+++after putheader", mci);
			bt = mime8to7(mci, hdr, e, boundaries, flags,
				      level + 1);
			if (bt == SM_IO_EOF)
				goto writeerr;
		}
		(void) sm_strlcpyn(buf, sizeof(buf), 3, "--", bbuf, "--");
		if (!putline(buf, mci))
			goto writeerr;
		if (tTd(43, 35))
			sm_dprintf("  ...%s\n", buf);
		boundaries[i] = NULL;
		mci->mci_flags &= ~MCIF_INMIME;

		/* skip the late "comment" epilogue */
		while ((blen = sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf,
					sizeof(buf))) >= 0)
		{
			bt = mimeboundary(buf, boundaries);
			if (bt != MBT_NOTSEP)
				break;
			if (!putxline(buf, blen, mci,
					PXLF_MAPFROM|PXLF_STRIP8BIT))
				goto writeerr;
			if (tTd(43, 99))
				sm_dprintf("  ...%s", buf);
		}
		if (sm_io_eof(e->e_dfp))
			bt = MBT_FINAL;
		if (tTd(43, 3))
			sm_dprintf("\t\t\tmime8to7=>%s (multipart)\n",
				MimeBoundaryNames[bt]);
		return bt;
	}

	/*
	**  Message/xxx types -- recurse exactly once.
	**
	**	Class 's' is predefined to have "rfc822" only.
	*/

	if (sm_strcasecmp(type, "message") == 0)
	{
		if (!wordinclass(subtype, 's') ||
		    bitset(EF_TOODEEP, e->e_flags))
		{
			flags |= M87F_NO8BIT;
		}
		else
		{
			auto HDR *hdr = NULL;

			if (!putline("", mci))
				goto writeerr;

			mci->mci_flags |= MCIF_INMIME;
			collect(e->e_dfp, false, &hdr, e, false);
			if (tTd(43, 101))
				putline("+++after collect", mci);
			if (!putheader(mci, hdr, e, flags))
				goto writeerr;
			if (tTd(43, 101))
				putline("+++after putheader", mci);
			if (hvalue("MIME-Version", hdr) == NULL &&
			    !bitset(M87F_NO8TO7, flags) &&
			    !putline("MIME-Version: 1.0", mci))
				goto writeerr;
			bt = mime8to7(mci, hdr, e, boundaries, flags,
				      level + 1);
			mci->mci_flags &= ~MCIF_INMIME;
			return bt;
		}
	}

	/*
	**  Non-compound body type
	**
	**	Compute the ratio of seven to eight bit characters;
	**	use that as a heuristic to decide how to do the
	**	encoding.
	*/

	sectionsize = sectionhighbits = 0;
	if (!bitset(M87F_NO8BIT|M87F_NO8TO7, flags))
	{
		/* remember where we were */
		offset = sm_io_tell(e->e_dfp, SM_TIME_DEFAULT);
		if (offset == -1)
			syserr("mime8to7: cannot sm_io_tell on %cf%s",
			       DATAFL_LETTER, e->e_id);

		/* do a scan of this body type to count character types */
		while ((blen = sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf,
					sizeof(buf))) >= 0)
		{
			if (mimeboundary(buf, boundaries) != MBT_NOTSEP)
				break;
			for (i = 0; i < blen; i++)
			{
				/* count bytes with the high bit set */
				sectionsize++;
				if (bitset(0200, buf[i]))
					sectionhighbits++;
			}

			/*
			**  Heuristic: if 1/4 of the first 4K bytes are 8-bit,
			**  assume base64.  This heuristic avoids double-reading
			**  large graphics or video files.
			*/

			if (sectionsize >= 4096 &&
			    sectionhighbits > sectionsize / 4)
				break;
		}

		/* return to the original offset for processing */
		/* XXX use relative seeks to handle >31 bit file sizes? */
		if (sm_io_seek(e->e_dfp, SM_TIME_DEFAULT, offset, SEEK_SET) < 0)
			syserr("mime8to7: cannot sm_io_fseek on %cf%s",
			       DATAFL_LETTER, e->e_id);
		else
			sm_io_clearerr(e->e_dfp);
	}

	/*
	**  Heuristically determine encoding method.
	**	If more than 1/8 of the total characters have the
	**	eighth bit set, use base64; else use quoted-printable.
	**	However, only encode binary encoded data as base64,
	**	since otherwise the NL=>CRLF mapping will be a problem.
	*/

	if (tTd(43, 8))
	{
		sm_dprintf("mime8to7: %ld high bit(s) in %ld byte(s), cte=%s, type=%s/%s\n",
			(long) sectionhighbits, (long) sectionsize,
			cte == NULL ? "[none]" : cte,
			type == NULL ? "[none]" : type,
			subtype == NULL ? "[none]" : subtype);
	}
	if (cte != NULL && sm_strcasecmp(cte, "binary") == 0)
		sectionsize = sectionhighbits;
	linelen = 0;
	bp = buf;
	if (sectionhighbits == 0)
	{
		/* no encoding necessary */
		if (cte != NULL &&
		    bitset(MCIF_CVT8TO7|MCIF_CVT7TO8|MCIF_INMIME,
			   mci->mci_flags) &&
		    !bitset(M87F_NO8TO7, flags))
		{
			/*
			**  Skip _unless_ in MIME mode and potentially
			**  converting from 8 bit to 7 bit MIME.  See
			**  putheader() for the counterpart where the
			**  CTE header is skipped in the opposite
			**  situation.
			*/

			(void) sm_snprintf(buf, sizeof(buf),
				"Content-Transfer-Encoding: %.200s", cte);
			if (!putline(buf, mci))
				goto writeerr;
			if (tTd(43, 36))
				sm_dprintf("  ...%s\n", buf);
		}
		if (!putline("", mci))
			goto writeerr;
		mci->mci_flags &= ~MCIF_INHEADER;
		while ((blen = sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf,
					sizeof(buf))) >= 0)
		{
			if (!bitset(MCIF_INLONGLINE, mci->mci_flags))
			{
				bt = mimeboundary(buf, boundaries);
				if (bt != MBT_NOTSEP)
					break;
			}
			if (!putxline(buf, blen, mci,
				      PXLF_MAPFROM|PXLF_NOADDEOL))
				goto writeerr;
		}
		if (sm_io_eof(e->e_dfp))
			bt = MBT_FINAL;
	}
	else if (!MapNLtoCRLF ||
		 (sectionsize / 8 < sectionhighbits && !use_qp))
	{
		/* use base64 encoding */
		int c1, c2;

		if (tTd(43, 36))
			sm_dprintf("  ...Content-Transfer-Encoding: base64\n");
		if (!putline("Content-Transfer-Encoding: base64", mci))
			goto writeerr;
		(void) sm_snprintf(buf, sizeof(buf),
			"X-MIME-Autoconverted: from 8bit to base64 by %s id %s",
			MyHostName, e->e_id);
		if (!putline(buf, mci) || !putline("", mci))
			goto writeerr;
		mci->mci_flags &= ~MCIF_INHEADER;
		while ((c1 = mime_getchar_crlf(e->e_dfp, boundaries, &bt)) !=
			SM_IO_EOF)
		{
			if (linelen > 71)
			{
				*bp = '\0';
				if (!putline(buf, mci))
					goto writeerr;
				linelen = 0;
				bp = buf;
			}
			linelen += 4;
			*bp++ = Base64Code[(c1 >> 2)];
			c1 = (c1 & 0x03) << 4;
			c2 = mime_getchar_crlf(e->e_dfp, boundaries, &bt);
			if (c2 == SM_IO_EOF)
			{
				*bp++ = Base64Code[c1];
				*bp++ = '=';
				*bp++ = '=';
				break;
			}
			c1 |= (c2 >> 4) & 0x0f;
			*bp++ = Base64Code[c1];
			c1 = (c2 & 0x0f) << 2;
			c2 = mime_getchar_crlf(e->e_dfp, boundaries, &bt);
			if (c2 == SM_IO_EOF)
			{
				*bp++ = Base64Code[c1];
				*bp++ = '=';
				break;
			}
			c1 |= (c2 >> 6) & 0x03;
			*bp++ = Base64Code[c1];
			*bp++ = Base64Code[c2 & 0x3f];
		}
		*bp = '\0';
		if (!putline(buf, mci))
			goto writeerr;
	}
	else
	{
		/* use quoted-printable encoding */
		int c1, c2;
		int fromstate;
		BITMAP256 badchars;

		/* set up map of characters that must be mapped */
		clrbitmap(badchars);
		for (c1 = 0x00; c1 < 0x20; c1++)
			setbitn(c1, badchars);
		clrbitn('\t', badchars);
		for (c1 = 0x7f; c1 < 0x100; c1++)
			setbitn(c1, badchars);
		setbitn('=', badchars);
		if (bitnset(M_EBCDIC, mci->mci_mailer->m_flags))
			for (p = "!\"#$@@[\\]^`{|}~"; *p != '\0'; p++)
				setbitn(*p, badchars);

		if (tTd(43, 36))
			sm_dprintf("  ...Content-Transfer-Encoding: quoted-printable\n");
		if (!putline("Content-Transfer-Encoding: quoted-printable",
				mci))
			goto writeerr;
		(void) sm_snprintf(buf, sizeof(buf),
			"X-MIME-Autoconverted: from 8bit to quoted-printable by %s id %s",
			MyHostName, e->e_id);
		if (!putline(buf, mci) || !putline("", mci))
			goto writeerr;
		mci->mci_flags &= ~MCIF_INHEADER;
		fromstate = 0;
		c2 = '\n';
		while ((c1 = mime_getchar(e->e_dfp, boundaries, &bt)) !=
			SM_IO_EOF)
		{
			if (c1 == '\n')
			{
				if (c2 == ' ' || c2 == '\t')
				{
					*bp++ = '=';
					*bp++ = Base16Code[(c2 >> 4) & 0x0f];
					*bp++ = Base16Code[c2 & 0x0f];
				}
				if (buf[0] == '.' && bp == &buf[1])
				{
					buf[0] = '=';
					*bp++ = Base16Code[('.' >> 4) & 0x0f];
					*bp++ = Base16Code['.' & 0x0f];
				}
				*bp = '\0';
				if (!putline(buf, mci))
					goto writeerr;
				linelen = fromstate = 0;
				bp = buf;
				c2 = c1;
				continue;
			}
			if (c2 == ' ' && linelen == 4 && fromstate == 4 &&
			    bitnset(M_ESCFROM, mci->mci_mailer->m_flags))
			{
				*bp++ = '=';
				*bp++ = '2';
				*bp++ = '0';
				linelen += 3;
			}
			else if (c2 == ' ' || c2 == '\t')
			{
				*bp++ = c2;
				linelen++;
			}
			if (linelen > 72 &&
			    (linelen > 75 || c1 != '.' ||
			     (linelen > 73 && c2 == '.')))
			{
				if (linelen > 73 && c2 == '.')
					bp--;
				else
					c2 = '\n';
				*bp++ = '=';
				*bp = '\0';
				if (!putline(buf, mci))
					goto writeerr;
				linelen = fromstate = 0;
				bp = buf;
				if (c2 == '.')
				{
					*bp++ = '.';
					linelen++;
				}
			}
			if (bitnset(bitidx(c1), badchars))
			{
				*bp++ = '=';
				*bp++ = Base16Code[(c1 >> 4) & 0x0f];
				*bp++ = Base16Code[c1 & 0x0f];
				linelen += 3;
			}
			else if (c1 != ' ' && c1 != '\t')
			{
				if (linelen < 4 && c1 == "From"[linelen])
					fromstate++;
				*bp++ = c1;
				linelen++;
			}
			c2 = c1;
		}

		/* output any saved character */
		if (c2 == ' ' || c2 == '\t')
		{
			*bp++ = '=';
			*bp++ = Base16Code[(c2 >> 4) & 0x0f];
			*bp++ = Base16Code[c2 & 0x0f];
			linelen += 3;
		}

		if (linelen > 0 || boundaries[0] != NULL)
		{
			*bp = '\0';
			if (!putline(buf, mci))
				goto writeerr;
		}

	}
	if (tTd(43, 3))
		sm_dprintf("\t\t\tmime8to7=>%s (basic)\n", MimeBoundaryNames[bt]);
	return bt;

  writeerr:
	return SM_IO_EOF;
}
/*
**  MIME_GETCHAR -- get a character for MIME processing
**
**	Treats boundaries as SM_IO_EOF.
**
**	Parameters:
**		fp -- the input file.
**		boundaries -- the current MIME boundaries.
**		btp -- if the return value is SM_IO_EOF, *btp is set to
**			the type of the boundary.
**
**	Returns:
**		The next character in the input stream.
*/

static int
mime_getchar(fp, boundaries, btp)
	register SM_FILE_T *fp;
	char **boundaries;
	int *btp;
{
	int c;
	static unsigned char *bp = NULL;
	static int buflen = 0;
	static bool atbol = true;	/* at beginning of line */
	static int bt = MBT_SYNTAX;	/* boundary type of next SM_IO_EOF */
	static unsigned char buf[128];	/* need not be a full line */
	int start = 0;			/* indicates position of - in buffer */

	if (buflen == 1 && *bp == '\n')
	{
		/* last \n in buffer may be part of next MIME boundary */
		c = *bp;
	}
	else if (buflen > 0)
	{
		buflen--;
		return *bp++;
	}
	else
		c = sm_io_getc(fp, SM_TIME_DEFAULT);
	bp = buf;
	buflen = 0;
	if (c == '\n')
	{
		/* might be part of a MIME boundary */
		*bp++ = c;
		atbol = true;
		c = sm_io_getc(fp, SM_TIME_DEFAULT);
		if (c == '\n')
		{
			(void) sm_io_ungetc(fp, SM_TIME_DEFAULT, c);
			return c;
		}
		start = 1;
	}
	if (c != SM_IO_EOF)
		*bp++ = c;
	else
		bt = MBT_FINAL;
	if (atbol && c == '-')
	{
		/* check for a message boundary */
		c = sm_io_getc(fp, SM_TIME_DEFAULT);
		if (c != '-')
		{
			if (c != SM_IO_EOF)
				*bp++ = c;
			else
				bt = MBT_FINAL;
			buflen = bp - buf - 1;
			bp = buf;
			return *bp++;
		}

		/* got "--", now check for rest of separator */
		*bp++ = '-';
		while (bp < &buf[sizeof(buf) - 2] &&
		       (c = sm_io_getc(fp, SM_TIME_DEFAULT)) != SM_IO_EOF &&
		       c != '\n')
		{
			*bp++ = c;
		}
		*bp = '\0';	/* XXX simply cut off? */
		bt = mimeboundary((char *) &buf[start], boundaries);
		switch (bt)
		{
		  case MBT_FINAL:
		  case MBT_INTERMED:
			/* we have a message boundary */
			buflen = 0;
			*btp = bt;
			return SM_IO_EOF;
		}

		if (bp < &buf[sizeof(buf) - 2] && c != SM_IO_EOF)
			*bp++ = c;
	}

	atbol = c == '\n';
	buflen = bp - buf - 1;
	if (buflen < 0)
	{
		*btp = bt;
		return SM_IO_EOF;
	}
	bp = buf;
	return *bp++;
}
/*
**  MIME_GETCHAR_CRLF -- do mime_getchar, but translate NL => CRLF
**
**	Parameters:
**		fp -- the input file.
**		boundaries -- the current MIME boundaries.
**		btp -- if the return value is SM_IO_EOF, *btp is set to
**			the type of the boundary.
**
**	Returns:
**		The next character in the input stream.
*/

static int
mime_getchar_crlf(fp, boundaries, btp)
	register SM_FILE_T *fp;
	char **boundaries;
	int *btp;
{
	static bool sendlf = false;
	int c;

	if (sendlf)
	{
		sendlf = false;
		return '\n';
	}
	c = mime_getchar(fp, boundaries, btp);
	if (c == '\n' && MapNLtoCRLF)
	{
		sendlf = true;
		return '\r';
	}
	return c;
}
/*
**  MIMEBOUNDARY -- determine if this line is a MIME boundary & its type
**
**	Parameters:
**		line -- the input line.
**		boundaries -- the set of currently pending boundaries.
**
**	Returns:
**		MBT_NOTSEP -- if this is not a separator line
**		MBT_INTERMED -- if this is an intermediate separator
**		MBT_FINAL -- if this is a final boundary
**		MBT_SYNTAX -- if this is a boundary for the wrong
**			enclosure -- i.e., a syntax error.
*/

static int
mimeboundary(line, boundaries)
	register char *line;
	char **boundaries;
{
	int type = MBT_NOTSEP;
	int i;
	int savec;

	if (line[0] != '-' || line[1] != '-' || boundaries == NULL)
		return MBT_NOTSEP;
	i = strlen(line);
	if (i > 0 && line[i - 1] == '\n')
		i--;

	/* strip off trailing whitespace */
	while (i > 0 && (line[i - 1] == ' ' || line[i - 1] == '\t'
#if _FFR_MIME_CR_OK
		|| line[i - 1] == '\r'
#endif /* _FFR_MIME_CR_OK */
	       ))
		i--;
	savec = line[i];
	line[i] = '\0';

	if (tTd(43, 5))
		sm_dprintf("mimeboundary: line=\"%s\"... ", line);

	/* check for this as an intermediate boundary */
	if (isboundary(&line[2], boundaries) >= 0)
		type = MBT_INTERMED;
	else if (i > 2 && strncmp(&line[i - 2], "--", 2) == 0)
	{
		/* check for a final boundary */
		line[i - 2] = '\0';
		if (isboundary(&line[2], boundaries) >= 0)
			type = MBT_FINAL;
		line[i - 2] = '-';
	}

	line[i] = savec;
	if (tTd(43, 5))
		sm_dprintf("%s\n", MimeBoundaryNames[type]);
	return type;
}
/*
**  DEFCHARSET -- return default character set for message
**
**	The first choice for character set is for the mailer
**	corresponding to the envelope sender.  If neither that
**	nor the global configuration file has a default character
**	set defined, return "unknown-8bit" as recommended by
**	RFC 1428 section 3.
**
**	Parameters:
**		e -- the envelope for this message.
**
**	Returns:
**		The default character set for that mailer.
*/

char *
defcharset(e)
	register ENVELOPE *e;
{
	if (e != NULL && e->e_from.q_mailer != NULL &&
	    e->e_from.q_mailer->m_defcharset != NULL)
		return e->e_from.q_mailer->m_defcharset;
	if (DefaultCharSet != NULL)
		return DefaultCharSet;
	return "unknown-8bit";
}
/*
**  ISBOUNDARY -- is a given string a currently valid boundary?
**
**	Parameters:
**		line -- the current input line.
**		boundaries -- the list of valid boundaries.
**
**	Returns:
**		The index number in boundaries if the line is found.
**		-1 -- otherwise.
**
*/

static int
isboundary(line, boundaries)
	char *line;
	char **boundaries;
{
	register int i;

	for (i = 0; i <= MAXMIMENESTING && boundaries[i] != NULL; i++)
	{
		if (strcmp(line, boundaries[i]) == 0)
			return i;
	}
	return -1;
}
#endif /* MIME8TO7 */

#if MIME7TO8
static int	mime_fromqp __P((unsigned char *, unsigned char **, int));

/*
**  MIME7TO8 -- output 7 bit encoded MIME body in 8 bit format
**
**  This is a hack. Supports translating the two 7-bit body-encodings
**  (quoted-printable and base64) to 8-bit coded bodies.
**
**  There is not much point in supporting multipart here, as the UA
**  will be able to deal with encoded MIME bodies if it can parse MIME
**  multipart messages.
**
**  Note also that we won't be called unless it is a text/plain MIME
**  message, encoded base64 or QP and mailer flag '9' has been defined
**  on mailer.
**
**  Contributed by Marius Olaffson <marius@@rhi.hi.is>.
**
**	Parameters:
**		mci -- mailer connection information.
**		header -- the header for this body part.
**		e -- envelope.
**
**	Returns:
**		true iff body was written successfully
*/

static char index_64[128] =
{
	-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
	-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
	-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,62, -1,-1,-1,63,
	52,53,54,55, 56,57,58,59, 60,61,-1,-1, -1,-1,-1,-1,
	-1, 0, 1, 2,  3, 4, 5, 6,  7, 8, 9,10, 11,12,13,14,
	15,16,17,18, 19,20,21,22, 23,24,25,-1, -1,-1,-1,-1,
	-1,26,27,28, 29,30,31,32, 33,34,35,36, 37,38,39,40,
	41,42,43,44, 45,46,47,48, 49,50,51,-1, -1,-1,-1,-1
};

# define CHAR64(c)  (((c) < 0 || (c) > 127) ? -1 : index_64[(c)])

bool
mime7to8(mci, header, e)
	register MCI *mci;
	HDR *header;
	register ENVELOPE *e;
{
	int pxflags, blen;
	register char *p;
	char *cte;
	char **pvp;
	unsigned char *fbufp;
	char buf[MAXLINE];
	unsigned char fbuf[MAXLINE + 1];
	char pvpbuf[MAXLINE];
	extern unsigned char MimeTokenTab[256];

	p = hvalue("Content-Transfer-Encoding", header);
	if (p == NULL ||
	    (pvp = prescan(p, '\0', pvpbuf, sizeof(pvpbuf), NULL,
			   MimeTokenTab, false)) == NULL ||
	    pvp[0] == NULL)
	{
		/* "can't happen" -- upper level should have caught this */
		syserr("mime7to8: unparsable CTE %s", p == NULL ? "<NULL>" : p);

		/* avoid bounce loops */
		e->e_flags |= EF_DONT_MIME;

		/* cheap failsafe algorithm -- should work on text/plain */
		if (p != NULL)
		{
			(void) sm_snprintf(buf, sizeof(buf),
				"Content-Transfer-Encoding: %s", p);
			if (!putline(buf, mci))
				goto writeerr;
		}
		if (!putline("", mci))
			goto writeerr;
		mci->mci_flags &= ~MCIF_INHEADER;
		while ((blen = sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf,
					sizeof(buf))) >= 0)
		{
			if (!putxline(buf, blen, mci, PXLF_MAPFROM))
				goto writeerr;
		}
		return true;
	}
	cataddr(pvp, NULL, buf, sizeof(buf), '\0', false);
	cte = sm_rpool_strdup_x(e->e_rpool, buf);

	mci->mci_flags |= MCIF_INHEADER;
	if (!putline("Content-Transfer-Encoding: 8bit", mci))
		goto writeerr;
	(void) sm_snprintf(buf, sizeof(buf),
		"X-MIME-Autoconverted: from %.200s to 8bit by %s id %s",
		cte, MyHostName, e->e_id);
	if (!putline(buf, mci) || !putline("", mci))
		goto writeerr;
	mci->mci_flags &= ~MCIF_INHEADER;

	/*
	**  Translate body encoding to 8-bit.  Supports two types of
	**  encodings; "base64" and "quoted-printable". Assume qp if
	**  it is not base64.
	*/

	pxflags = PXLF_MAPFROM;
	if (sm_strcasecmp(cte, "base64") == 0)
	{
		int c1, c2, c3, c4;

		fbufp = fbuf;
		while ((c1 = sm_io_getc(e->e_dfp, SM_TIME_DEFAULT)) !=
			SM_IO_EOF)
		{
			if (isascii(c1) && isspace(c1))
				continue;

			do
			{
				c2 = sm_io_getc(e->e_dfp, SM_TIME_DEFAULT);
			} while (isascii(c2) && isspace(c2));
			if (c2 == SM_IO_EOF)
				break;

			do
			{
				c3 = sm_io_getc(e->e_dfp, SM_TIME_DEFAULT);
			} while (isascii(c3) && isspace(c3));
			if (c3 == SM_IO_EOF)
				break;

			do
			{
				c4 = sm_io_getc(e->e_dfp, SM_TIME_DEFAULT);
			} while (isascii(c4) && isspace(c4));
			if (c4 == SM_IO_EOF)
				break;

			if (c1 == '=' || c2 == '=')
				continue;
			c1 = CHAR64(c1);
			c2 = CHAR64(c2);

#if MIME7TO8_OLD
#define CHK_EOL if (*--fbufp != '\n' || (fbufp > fbuf && *--fbufp != '\r')) \
			++fbufp;
#else /* MIME7TO8_OLD */
#define CHK_EOL if (*--fbufp != '\n' || (fbufp > fbuf && *--fbufp != '\r')) \
		{					\
			++fbufp;			\
			pxflags |= PXLF_NOADDEOL;	\
		}
#endif /* MIME7TO8_OLD */

#define PUTLINE64	\
	do		\
	{		\
		if (*fbufp++ == '\n' || fbufp >= &fbuf[MAXLINE])	\
		{							\
			CHK_EOL;					\
			if (!putxline((char *) fbuf, fbufp - fbuf, mci, pxflags)) \
				goto writeerr;				\
			pxflags &= ~PXLF_NOADDEOL;			\
			fbufp = fbuf;					\
		}	\
	} while (0)

			*fbufp = (c1 << 2) | ((c2 & 0x30) >> 4);
			PUTLINE64;
			if (c3 == '=')
				continue;
			c3 = CHAR64(c3);
			*fbufp = ((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2);
			PUTLINE64;
			if (c4 == '=')
				continue;
			c4 = CHAR64(c4);
			*fbufp = ((c3 & 0x03) << 6) | c4;
			PUTLINE64;
		}
	}
	else
	{
		int off;

		/* quoted-printable */
		pxflags |= PXLF_NOADDEOL;
		fbufp = fbuf;
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf,
				   sizeof(buf)) >= 0)
		{
			off = mime_fromqp((unsigned char *) buf, &fbufp,
					  &fbuf[MAXLINE] - fbufp);
again:
			if (off < -1)
				continue;

			if (fbufp - fbuf > 0)
			{
				if (!putxline((char *) fbuf, fbufp - fbuf - 1,
						mci, pxflags))
					goto writeerr;
			}
			fbufp = fbuf;
			if (off >= 0 && buf[off] != '\0')
			{
				off = mime_fromqp((unsigned char *) (buf + off),
						  &fbufp,
						  &fbuf[MAXLINE] - fbufp);
				goto again;
			}
		}
	}

	/* force out partial last line */
	if (fbufp > fbuf)
	{
		*fbufp = '\0';
		if (!putxline((char *) fbuf, fbufp - fbuf, mci, pxflags))
			goto writeerr;
	}

	/*
	**  The decoded text may end without an EOL.  Since this function
	**  is only called for text/plain MIME messages, it is safe to
	**  add an extra one at the end just in case.  This is a hack,
	**  but so is auto-converting MIME in the first place.
	*/

	if (!putline("", mci))
		goto writeerr;

	if (tTd(43, 3))
		sm_dprintf("\t\t\tmime7to8 => %s to 8bit done\n", cte);
	return true;

  writeerr:
	return false;
}
/*
**  The following is based on Borenstein's "codes.c" module, with simplifying
**  changes as we do not deal with multipart, and to do the translation in-core,
**  with an attempt to prevent overrun of output buffers.
**
**  What is needed here are changes to defend this code better against
**  bad encodings. Questionable to always return 0xFF for bad mappings.
*/

static char index_hex[128] =
{
	-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
	-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
	-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
	0, 1, 2, 3,  4, 5, 6, 7,  8, 9,-1,-1, -1,-1,-1,-1,
	-1,10,11,12, 13,14,15,-1, -1,-1,-1,-1, -1,-1,-1,-1,
	-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
	-1,10,11,12, 13,14,15,-1, -1,-1,-1,-1, -1,-1,-1,-1,
	-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1
};

# define HEXCHAR(c)  (((c) < 0 || (c) > 127) ? -1 : index_hex[(c)])

/*
**  MIME_FROMQP -- decode quoted printable string
**
**	Parameters:
**		infile -- input (encoded) string
**		outfile -- output string
**		maxlen -- size of output buffer
**
**	Returns:
**		-2 if decoding failure
**		-1 if infile completely decoded into outfile
**		>= 0 is the position in infile decoding
**			reached before maxlen was reached
*/

static int
mime_fromqp(infile, outfile, maxlen)
	unsigned char *infile;
	unsigned char **outfile;
	int maxlen;		/* Max # of chars allowed in outfile */
{
	int c1, c2;
	int nchar = 0;
	unsigned char *b;

	/* decrement by one for trailing '\0', at least one other char */
	if (--maxlen < 1)
		return 0;

	b = infile;
	while ((c1 = *infile++) != '\0' && nchar < maxlen)
	{
		if (c1 == '=')
		{
			if ((c1 = *infile++) == '\0')
				break;

			if (c1 == '\n' || (c1 = HEXCHAR(c1)) == -1)
			{
				/* ignore it and the rest of the buffer */
				return -2;
			}
			else
			{
				do
				{
					if ((c2 = *infile++) == '\0')
					{
						c2 = -1;
						break;
					}
				} while ((c2 = HEXCHAR(c2)) == -1);

				if (c2 == -1)
					break;
				nchar++;
				*(*outfile)++ = c1 << 4 | c2;
			}
		}
		else
		{
			nchar++;
			*(*outfile)++ = c1;
			if (c1 == '\n')
				break;
		}
	}
	*(*outfile)++ = '\0';
	if (nchar >= maxlen)
		return (infile - b - 1);
	return -1;
}
#endif /* MIME7TO8 */
@


1.17
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.16
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003, 2006, 2013 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.148 2013/03/12 15:24:53 ca Exp $")
@


1.15
log
@Update to sendmail-8.14.3
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003, 2006 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.147 2007/09/26 23:29:11 ca Exp $")
d110 1
d326 2
a327 2
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof(buf))
			!= NULL)
d332 1
a332 1
			if (!putxline(buf, strlen(buf), mci,
d370 2
a371 2
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof(buf))
			!= NULL)
d376 1
a376 1
			if (!putxline(buf, strlen(buf), mci,
d447 2
a448 2
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof(buf))
			!= NULL)
d452 1
a452 1
			for (p = buf; *p != '\0'; p++)
d456 1
a456 1
				if (bitset(0200, *p))
d526 2
a527 2
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof(buf))
			!= NULL)
d535 1
a535 1
			if (!putxline(buf, strlen(buf), mci,
d1037 1
a1037 1
	int pxflags;
d1070 2
a1071 2
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof(buf))
			!= NULL)
d1073 1
a1073 1
			if (!putline(buf, mci))
d1181 1
a1181 1
				   sizeof(buf)) != NULL)
@


1.14
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.146 2006/08/16 16:52:11 ca Exp $")
d528 8
a535 4
			bt = mimeboundary(buf, boundaries);
			if (bt != MBT_NOTSEP)
				break;
			if (!putline(buf, mci))
@


1.13
log
@Update to sendmail-8.13.8
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.142.2.1 2006/05/23 01:32:08 ca Exp $")
d154 1
a154 1
	    (pvp = prescan(p, '\0', pvpbuf, sizeof pvpbuf, NULL,
d162 1
a162 1
		cataddr(pvp, NULL, buf, sizeof buf, '\0');
d176 1
a176 1
	    (pvp = prescan(p, '\0', pvpbuf, sizeof pvpbuf, NULL,
d241 1
a241 1
	(void) sm_snprintf(buf, sizeof buf, "%.100s/%.100s", type, subtype);
d286 1
a286 1
		if (sm_strlcpy(bbuf, p, sizeof bbuf) >= sizeof bbuf)
d325 1
a325 1
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof buf)
d343 1
a343 1
			(void) sm_strlcpyn(buf, sizeof buf, 2, "--", bbuf);
d360 1
a360 1
		(void) sm_strlcpyn(buf, sizeof buf, 3, "--", bbuf, "--");
d369 1
a369 1
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof buf)
d446 1
a446 1
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof buf)
d515 1
a515 1
			(void) sm_snprintf(buf, sizeof buf,
d525 1
a525 1
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof buf)
d547 1
a547 1
		(void) sm_snprintf(buf, sizeof buf,
d617 1
a617 1
		(void) sm_snprintf(buf, sizeof buf,
d801 1
a801 1
		while (bp < &buf[sizeof buf - 2] &&
d819 1
a819 1
		if (bp < &buf[sizeof buf - 2] && c != SM_IO_EOF)
d1044 1
a1044 1
	    (pvp = prescan(p, '\0', pvpbuf, sizeof pvpbuf, NULL,
d1057 1
a1057 1
			(void) sm_snprintf(buf, sizeof buf,
d1065 1
a1065 1
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof buf)
d1073 1
a1073 1
	cataddr(pvp, NULL, buf, sizeof buf, '\0');
d1079 1
a1079 1
	(void) sm_snprintf(buf, sizeof buf,
d1176 1
a1176 1
				   sizeof buf) != NULL)
@


1.12
log
@fix bug which would make very deeply nested mime cause (essentially)
a stack overflow and thus make sendmail queue processing crash.  not
really exploitable to gain anything except denial of service.  vu#146718
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.139 2006/03/01 18:07:45 ca Exp $")
d230 1
a230 1
	/* don't propogate some flags more than one level into the message */
@


1.11
log
@Update to sendmail 8.13.6
@
text
@d83 1
d100 1
a100 1
mime8to7(mci, header, e, boundaries, flags)
d106 1
d127 12
d259 3
a261 1
	    (!bitset(M87F_NO8BIT, flags) || bitset(M87F_NO8TO7, flags)))
d305 4
a308 1
			usrerr("mime8to7: multipart nesting boundary too deep");
d311 1
a311 1
			e->e_flags |= EF_DONT_MIME;
d355 2
a356 1
			bt = mime8to7(mci, hdr, e, boundaries, flags);
d397 2
a398 1
		if (!wordinclass(subtype, 's'))
d421 2
a422 1
			bt = mime8to7(mci, hdr, e, boundaries, flags);
@


1.10
log
@Update to sendmail-8.13.2
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.137 2004/09/02 21:37:26 ca Exp $")
d89 1
d302 2
a303 1
		putline("", mci);
d312 3
a314 2
			putxline(buf, strlen(buf), mci,
				 PXLF_MAPFROM|PXLF_STRIP8BIT);
d325 2
a326 1
			putline(buf, mci);
d332 2
a333 1
			putheader(mci, hdr, e, flags);
d337 2
d341 2
a342 1
		putline(buf, mci);
d355 3
a357 2
			putxline(buf, strlen(buf), mci,
				 PXLF_MAPFROM|PXLF_STRIP8BIT);
d385 2
a386 1
			putline("", mci);
d392 2
a393 1
			putheader(mci, hdr, e, flags);
d397 3
a399 2
			    !bitset(M87F_NO8TO7, flags))
				putline("MIME-Version: 1.0", mci);
d495 2
a496 1
			putline(buf, mci);
d500 2
a501 1
		putline("", mci);
d509 2
a510 1
			putline(buf, mci);
d523 2
a524 1
		putline("Content-Transfer-Encoding: base64", mci);
d528 2
a529 2
		putline(buf, mci);
		putline("", mci);
d537 2
a538 1
				putline(buf, mci);
d568 2
a569 1
		putline(buf, mci);
d592 3
a594 1
		putline("Content-Transfer-Encoding: quoted-printable", mci);
d598 2
a599 2
		putline(buf, mci);
		putline("", mci);
d621 2
a622 1
				putline(buf, mci);
d651 2
a652 1
				putline(buf, mci);
d690 2
a691 1
			putline(buf, mci);
d698 3
d987 1
a987 1
**		none.
d1004 1
a1004 1
void
d1037 2
a1038 1
			putline(buf, mci);
d1040 2
a1041 1
		putline("", mci);
d1045 5
a1049 2
			putline(buf, mci);
		return;
d1055 2
a1056 1
	putline("Content-Transfer-Encoding: 8bit", mci);
d1060 2
a1061 2
	putline(buf, mci);
	putline("", mci);
d1125 2
a1126 1
			putxline((char *) fbuf, fbufp - fbuf, mci, pxflags); \
d1163 5
a1167 2
				putxline((char *) fbuf, fbufp - fbuf - 1, mci,
					 pxflags);
d1183 2
a1184 1
		putxline((char *) fbuf, fbufp - fbuf, mci, pxflags);
d1194 2
a1195 1
	putline("", mci);
d1199 4
@


1.10.6.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@a88 1
**		  SM_IO_EOF -- I/O error occurred
d301 1
a301 2
		if (!putline("", mci))
			goto writeerr;
d310 2
a311 3
			if (!putxline(buf, strlen(buf), mci,
					PXLF_MAPFROM|PXLF_STRIP8BIT))
				goto writeerr;
d322 1
a322 2
			if (!putline(buf, mci))
				goto writeerr;
d328 1
a328 2
			if (!putheader(mci, hdr, e, flags))
				goto writeerr;
a331 2
			if (bt == SM_IO_EOF)
				goto writeerr;
d334 1
a334 2
		if (!putline(buf, mci))
			goto writeerr;
d347 2
a348 3
			if (!putxline(buf, strlen(buf), mci,
					PXLF_MAPFROM|PXLF_STRIP8BIT))
				goto writeerr;
d376 1
a376 2
			if (!putline("", mci))
				goto writeerr;
d382 1
a382 2
			if (!putheader(mci, hdr, e, flags))
				goto writeerr;
d386 2
a387 3
			    !bitset(M87F_NO8TO7, flags) &&
			    !putline("MIME-Version: 1.0", mci))
				goto writeerr;
d483 1
a483 2
			if (!putline(buf, mci))
				goto writeerr;
d487 1
a487 2
		if (!putline("", mci))
			goto writeerr;
d495 1
a495 2
			if (!putline(buf, mci))
				goto writeerr;
d508 1
a508 2
		if (!putline("Content-Transfer-Encoding: base64", mci))
			goto writeerr;
d512 2
a513 2
		if (!putline(buf, mci) || !putline("", mci))
			goto writeerr;
d521 1
a521 2
				if (!putline(buf, mci))
					goto writeerr;
d551 1
a551 2
		if (!putline(buf, mci))
			goto writeerr;
d574 1
a574 3
		if (!putline("Content-Transfer-Encoding: quoted-printable",
				mci))
			goto writeerr;
d578 2
a579 2
		if (!putline(buf, mci) || !putline("", mci))
			goto writeerr;
d601 1
a601 2
				if (!putline(buf, mci))
					goto writeerr;
d630 1
a630 2
				if (!putline(buf, mci))
					goto writeerr;
d668 1
a668 2
			if (!putline(buf, mci))
				goto writeerr;
a674 3

  writeerr:
	return SM_IO_EOF;
d961 1
a961 1
**		true iff body was written successfully
d978 1
a978 1
bool
d1011 1
a1011 2
			if (!putline(buf, mci))
				goto writeerr;
d1013 1
a1013 2
		if (!putline("", mci))
			goto writeerr;
d1017 2
a1018 5
		{
			if (!putline(buf, mci))
				goto writeerr;
		}
		return true;
d1024 1
a1024 2
	if (!putline("Content-Transfer-Encoding: 8bit", mci))
		goto writeerr;
d1028 2
a1029 2
	if (!putline(buf, mci) || !putline("", mci))
		goto writeerr;
d1093 1
a1093 2
			if (!putxline((char *) fbuf, fbufp - fbuf, mci, pxflags)) \
				goto writeerr;				\
d1130 2
a1131 5
			{
				if (!putxline((char *) fbuf, fbufp - fbuf - 1,
						mci, pxflags))
					goto writeerr;
			}
d1147 1
a1147 2
		if (!putxline((char *) fbuf, fbufp - fbuf, mci, pxflags))
			goto writeerr;
d1157 1
a1157 2
	if (!putline("", mci))
		goto writeerr;
a1160 4
	return true;

  writeerr:
	return false;
@


1.10.6.2
log
@MFC:
Fix by deraadt@@

fix bug which would make very deeply nested mime cause (essentially)
a stack overflow and thus make sendmail queue processing crash.  not
really exploitable to gain anything except denial of service.  vu#146718
@
text
@a82 1
**		level -- recursion level.
d99 1
a99 1
mime8to7(mci, header, e, boundaries, flags, level)
a104 1
	int level;
a124 12
	if (level > MAXMIMENESTING)
	{
		if (!bitset(EF_TOODEEP, e->e_flags))
		{
			if (tTd(43, 4))
				sm_dprintf("mime8to7: too deep, level=%d\n",
					   level);
			usrerr("mime8to7: recursion level %d exceeded",
				level);
			e->e_flags |= EF_DONT_MIME|EF_TOODEEP;
		}
	}
d245 1
a245 3
	    (!bitset(M87F_NO8BIT, flags) || bitset(M87F_NO8TO7, flags)) &&
	    !bitset(EF_TOODEEP, e->e_flags)
	   )
d289 1
a289 4
			if (tTd(43, 4))
				sm_dprintf("mime8to7: too deep, i=%d\n", i);
			if (!bitset(EF_TOODEEP, e->e_flags))
				usrerr("mime8to7: multipart nesting boundary too deep");
d292 1
a292 1
			e->e_flags |= EF_DONT_MIME|EF_TOODEEP;
d336 1
a336 2
			bt = mime8to7(mci, hdr, e, boundaries, flags,
				      level + 1);
d377 1
a377 2
		if (!wordinclass(subtype, 's') ||
		    bitset(EF_TOODEEP, e->e_flags))
d400 1
a400 2
			bt = mime8to7(mci, hdr, e, boundaries, flags,
				      level + 1);
@


1.10.4.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@a88 1
**		  SM_IO_EOF -- I/O error occurred
d301 1
a301 2
		if (!putline("", mci))
			goto writeerr;
d310 2
a311 3
			if (!putxline(buf, strlen(buf), mci,
					PXLF_MAPFROM|PXLF_STRIP8BIT))
				goto writeerr;
d322 1
a322 2
			if (!putline(buf, mci))
				goto writeerr;
d328 1
a328 2
			if (!putheader(mci, hdr, e, flags))
				goto writeerr;
a331 2
			if (bt == SM_IO_EOF)
				goto writeerr;
d334 1
a334 2
		if (!putline(buf, mci))
			goto writeerr;
d347 2
a348 3
			if (!putxline(buf, strlen(buf), mci,
					PXLF_MAPFROM|PXLF_STRIP8BIT))
				goto writeerr;
d376 1
a376 2
			if (!putline("", mci))
				goto writeerr;
d382 1
a382 2
			if (!putheader(mci, hdr, e, flags))
				goto writeerr;
d386 2
a387 3
			    !bitset(M87F_NO8TO7, flags) &&
			    !putline("MIME-Version: 1.0", mci))
				goto writeerr;
d483 1
a483 2
			if (!putline(buf, mci))
				goto writeerr;
d487 1
a487 2
		if (!putline("", mci))
			goto writeerr;
d495 1
a495 2
			if (!putline(buf, mci))
				goto writeerr;
d508 1
a508 2
		if (!putline("Content-Transfer-Encoding: base64", mci))
			goto writeerr;
d512 2
a513 2
		if (!putline(buf, mci) || !putline("", mci))
			goto writeerr;
d521 1
a521 2
				if (!putline(buf, mci))
					goto writeerr;
d551 1
a551 2
		if (!putline(buf, mci))
			goto writeerr;
d574 1
a574 3
		if (!putline("Content-Transfer-Encoding: quoted-printable",
				mci))
			goto writeerr;
d578 2
a579 2
		if (!putline(buf, mci) || !putline("", mci))
			goto writeerr;
d601 1
a601 2
				if (!putline(buf, mci))
					goto writeerr;
d630 1
a630 2
				if (!putline(buf, mci))
					goto writeerr;
d668 1
a668 2
			if (!putline(buf, mci))
				goto writeerr;
a674 3

  writeerr:
	return SM_IO_EOF;
d961 1
a961 1
**		true iff body was written successfully
d978 1
a978 1
bool
d1011 1
a1011 2
			if (!putline(buf, mci))
				goto writeerr;
d1013 1
a1013 2
		if (!putline("", mci))
			goto writeerr;
d1017 2
a1018 5
		{
			if (!putline(buf, mci))
				goto writeerr;
		}
		return true;
d1024 1
a1024 2
	if (!putline("Content-Transfer-Encoding: 8bit", mci))
		goto writeerr;
d1028 2
a1029 2
	if (!putline(buf, mci) || !putline("", mci))
		goto writeerr;
d1093 1
a1093 2
			if (!putxline((char *) fbuf, fbufp - fbuf, mci, pxflags)) \
				goto writeerr;				\
d1130 2
a1131 5
			{
				if (!putxline((char *) fbuf, fbufp - fbuf - 1,
						mci, pxflags))
					goto writeerr;
			}
d1147 1
a1147 2
		if (!putxline((char *) fbuf, fbufp - fbuf, mci, pxflags))
			goto writeerr;
d1157 1
a1157 2
	if (!putline("", mci))
		goto writeerr;
a1160 4
	return true;

  writeerr:
	return false;
@


1.10.4.2
log
@MFC:
Fix by deraadt@@

fix bug which would make very deeply nested mime cause (essentially)
a stack overflow and thus make sendmail queue processing crash.  not
really exploitable to gain anything except denial of service.  vu#146718
@
text
@a82 1
**		level -- recursion level.
d99 1
a99 1
mime8to7(mci, header, e, boundaries, flags, level)
a104 1
	int level;
a124 12
	if (level > MAXMIMENESTING)
	{
		if (!bitset(EF_TOODEEP, e->e_flags))
		{
			if (tTd(43, 4))
				sm_dprintf("mime8to7: too deep, level=%d\n",
					   level);
			usrerr("mime8to7: recursion level %d exceeded",
				level);
			e->e_flags |= EF_DONT_MIME|EF_TOODEEP;
		}
	}
d245 1
a245 3
	    (!bitset(M87F_NO8BIT, flags) || bitset(M87F_NO8TO7, flags)) &&
	    !bitset(EF_TOODEEP, e->e_flags)
	   )
d289 1
a289 4
			if (tTd(43, 4))
				sm_dprintf("mime8to7: too deep, i=%d\n", i);
			if (!bitset(EF_TOODEEP, e->e_flags))
				usrerr("mime8to7: multipart nesting boundary too deep");
d292 1
a292 1
			e->e_flags |= EF_DONT_MIME|EF_TOODEEP;
d336 1
a336 2
			bt = mime8to7(mci, hdr, e, boundaries, flags,
				      level + 1);
d377 1
a377 2
		if (!wordinclass(subtype, 's') ||
		    bitset(EF_TOODEEP, e->e_flags))
d400 1
a400 2
			bt = mime8to7(mci, hdr, e, boundaries, flags,
				      level + 1);
@


1.10.2.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@a88 1
**		  SM_IO_EOF -- I/O error occurred
d301 1
a301 2
		if (!putline("", mci))
			goto writeerr;
d310 2
a311 3
			if (!putxline(buf, strlen(buf), mci,
					PXLF_MAPFROM|PXLF_STRIP8BIT))
				goto writeerr;
d322 1
a322 2
			if (!putline(buf, mci))
				goto writeerr;
d328 1
a328 2
			if (!putheader(mci, hdr, e, flags))
				goto writeerr;
a331 2
			if (bt == SM_IO_EOF)
				goto writeerr;
d334 1
a334 2
		if (!putline(buf, mci))
			goto writeerr;
d347 2
a348 3
			if (!putxline(buf, strlen(buf), mci,
					PXLF_MAPFROM|PXLF_STRIP8BIT))
				goto writeerr;
d376 1
a376 2
			if (!putline("", mci))
				goto writeerr;
d382 1
a382 2
			if (!putheader(mci, hdr, e, flags))
				goto writeerr;
d386 2
a387 3
			    !bitset(M87F_NO8TO7, flags) &&
			    !putline("MIME-Version: 1.0", mci))
				goto writeerr;
d483 1
a483 2
			if (!putline(buf, mci))
				goto writeerr;
d487 1
a487 2
		if (!putline("", mci))
			goto writeerr;
d495 1
a495 2
			if (!putline(buf, mci))
				goto writeerr;
d508 1
a508 2
		if (!putline("Content-Transfer-Encoding: base64", mci))
			goto writeerr;
d512 2
a513 2
		if (!putline(buf, mci) || !putline("", mci))
			goto writeerr;
d521 1
a521 2
				if (!putline(buf, mci))
					goto writeerr;
d551 1
a551 2
		if (!putline(buf, mci))
			goto writeerr;
d574 1
a574 3
		if (!putline("Content-Transfer-Encoding: quoted-printable",
				mci))
			goto writeerr;
d578 2
a579 2
		if (!putline(buf, mci) || !putline("", mci))
			goto writeerr;
d601 1
a601 2
				if (!putline(buf, mci))
					goto writeerr;
d630 1
a630 2
				if (!putline(buf, mci))
					goto writeerr;
d668 1
a668 2
			if (!putline(buf, mci))
				goto writeerr;
a674 3

  writeerr:
	return SM_IO_EOF;
d961 1
a961 1
**		true iff body was written successfully
d978 1
a978 1
bool
d1011 1
a1011 2
			if (!putline(buf, mci))
				goto writeerr;
d1013 1
a1013 2
		if (!putline("", mci))
			goto writeerr;
d1017 2
a1018 5
		{
			if (!putline(buf, mci))
				goto writeerr;
		}
		return true;
d1024 1
a1024 2
	if (!putline("Content-Transfer-Encoding: 8bit", mci))
		goto writeerr;
d1028 2
a1029 2
	if (!putline(buf, mci) || !putline("", mci))
		goto writeerr;
d1093 1
a1093 2
			if (!putxline((char *) fbuf, fbufp - fbuf, mci, pxflags)) \
				goto writeerr;				\
d1130 2
a1131 5
			{
				if (!putxline((char *) fbuf, fbufp - fbuf - 1,
						mci, pxflags))
					goto writeerr;
			}
d1147 1
a1147 2
		if (!putxline((char *) fbuf, fbufp - fbuf, mci, pxflags))
			goto writeerr;
d1157 1
a1157 2
	if (!putline("", mci))
		goto writeerr;
a1160 4
	return true;

  writeerr:
	return false;
@


1.9
log
@Update to sendmail.8.13.0
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.136 2004/03/22 18:21:34 ca Exp $")
d851 5
a855 1
	while (i > 0 && (line[i - 1] == ' ' || line[i - 1] == '\t'))
@


1.8
log
@Update to sendmail 8.12.11.  I've been runninga beta version of this for
some time without problems.  See the RELEASE_NOTES for the change log.
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.130.2.3 2004/01/08 21:42:56 ca Exp $")
d140 1
a140 1
			   MimeTokenTab)) == NULL ||
d162 1
a162 1
			   MimeTokenTab)) != NULL &&
d771 1
a771 2
		atbol = c == '\n';
		if (c != SM_IO_EOF)
d775 1
d993 1
a993 1
			   MimeTokenTab)) == NULL ||
@


1.7
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.130.2.1 2003/04/15 01:05:59 ca Exp $")
d36 5
d1072 23
d1096 1
a1096 13
			if (*fbufp++ == '\n' || fbufp >= &fbuf[MAXLINE])
			{
				if (*--fbufp != '\n' ||
				    (fbufp > fbuf && *--fbufp != '\r'))
				{
					pxflags |= PXLF_NOADDEOL;
					fbufp++;
				}
				putxline((char *) fbuf, fbufp - fbuf,
					 mci, pxflags);
				pxflags &= ~PXLF_NOADDEOL;
				fbufp = fbuf;
			}
d1101 1
a1101 13
			if (*fbufp++ == '\n' || fbufp >= &fbuf[MAXLINE])
			{
				if (*--fbufp != '\n' ||
				    (fbufp > fbuf && *--fbufp != '\r'))
				{
					pxflags |= PXLF_NOADDEOL;
					fbufp++;
				}
				putxline((char *) fbuf, fbufp - fbuf,
					 mci, pxflags);
				pxflags &= ~PXLF_NOADDEOL;
				fbufp = fbuf;
			}
d1106 1
a1106 13
			if (*fbufp++ == '\n' || fbufp >= &fbuf[MAXLINE])
			{
				if (*--fbufp != '\n' ||
				    (fbufp > fbuf && *--fbufp != '\r'))
				{
					pxflags |= PXLF_NOADDEOL;
					fbufp++;
				}
				putxline((char *) fbuf, fbufp - fbuf,
					 mci, pxflags);
				pxflags &= ~PXLF_NOADDEOL;
				fbufp = fbuf;
			}
@


1.6
log
@Update to sendmail-8.12.4
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.130 2002/05/21 03:39:34 ca Exp $")
d320 1
a320 1
			collect(e->e_dfp, false, &hdr, e);
d374 1
a374 1
			collect(e->e_dfp, false, &hdr, e);
@


1.5
log
@update to sendmail 8.12.3
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.129 2002/03/13 07:28:05 gshapiro Exp $")
d380 2
a381 1
			if (hvalue("MIME-Version", hdr) == NULL)
@


1.4
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.125 2001/09/11 04:05:15 gshapiro Exp $")
d927 1
a927 1
static int	mime_fromqp __P((unsigned char *, unsigned char **, int, int));
d939 1
a939 1
**  Note also that we wont be called unless it is a text/plain MIME
d974 1
d1028 1
d1071 2
d1074 1
d1076 2
a1077 1
					 mci, PXLF_MAPFROM);
d1088 2
d1091 1
d1093 2
a1094 1
					 mci, PXLF_MAPFROM);
d1105 2
d1108 1
d1110 2
a1111 1
					 mci, PXLF_MAPFROM);
d1118 2
d1121 1
d1123 2
a1124 2
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof buf)
			!= NULL)
d1126 4
a1129 2
			if (mime_fromqp((unsigned char *) buf, &fbufp, 0,
					&fbuf[MAXLINE] - fbufp) == 0)
d1134 1
a1134 1
					 PXLF_MAPFROM);
d1136 7
d1150 1
a1150 1
		putxline((char *) fbuf, fbufp - fbuf, mci, PXLF_MAPFROM);
d1152 10
d1188 15
d1204 1
a1204 1
mime_fromqp(infile, outfile, state, maxlen)
a1206 1
	int state;		/* Decoding body (0) or header (1) */
d1211 1
d1213 2
a1214 1
	if (maxlen < 0)
d1217 2
a1218 1
	while ((c1 = *infile++) != '\0')
d1222 1
a1222 1
			if ((c1 = *infile++) == 0)
d1227 2
a1228 3
				/* ignore it */
				if (state == 0)
					return 0;
d1241 1
a1241 1
				if (c2 == -1 || ++nchar > maxlen)
d1243 1
a1243 1

d1249 1
a1249 6
			if (state == 1 && c1 == '_')
				c1 = ' ';

			if (++nchar > maxlen)
				break;

a1250 1

d1256 3
a1258 1
	return 1;
@


1.3
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.121 2001/09/04 22:43:04 ca Exp $")
d59 1
a59 1
/*
d402 2
a403 1
			syserr("mime8to7: cannot sm_io_tell on df%s", e->e_id);
d433 2
a434 1
			syserr("mime8to7: cannot sm_io_fseek on df%s", e->e_id);
d670 1
a670 1
/*
d779 1
a779 1
/*
d814 1
a814 1
/*
d870 1
a870 1
/*
d897 1
a897 1
/*
d925 1
a925 1

d1129 1
a1129 1
/*
@


1.2
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d17 1
a17 9
#ifndef lint
static char id[] = "@@(#)$Sendmail: mime.c,v 8.94.16.3 2000/10/09 02:46:10 gshapiro Exp $";
#endif /* ! lint */

static int	isboundary __P((char *, char **));
static int	mimeboundary __P((char *, char **));
static int	mime_fromqp __P((u_char *, u_char **, int, int));
static int	mime_getchar __P((FILE *, char **, int *));
static int	mime_getchar_crlf __P((FILE *, char **, int *));
d37 4
d112 1
a112 1
	bool use_qp = FALSE;
d117 1
a117 1
	extern u_char MimeTokenTab[256];
d121 1
a121 1
		dprintf("mime8to7: flags = %x, boundaries =", flags);
d123 1
a123 1
			dprintf(" <none>");
d127 1
a127 1
				dprintf(" %s", boundaries[i]);
d129 1
a129 1
		dprintf("\n");
d131 1
a131 1
	MapNLtoCRLF = TRUE;
d143 1
a143 1
		cte = newstr(buf);
d163 1
a163 1
				dprintf("pvp[%d] = \"%s\"\n", i, pvp[i]);
d221 1
a221 1
	snprintf(buf, sizeof buf, "%.100s/%.100s", type, subtype);
d227 1
a227 1
		MapNLtoCRLF = FALSE;
d230 1
a230 1
		use_qp = TRUE;
d238 1
a238 1
	if (strcasecmp(type, "multipart") == 0 &&
d242 1
a242 1
		if (strcasecmp(subtype, "digest") == 0)
d247 1
a247 1
			if (strcasecmp(argv[i].a_field, "boundary") == 0)
d264 1
a264 1
		if (strlcpy(bbuf, p, sizeof bbuf) >= sizeof bbuf)
d274 2
a275 1
			dprintf("mime8to7: multipart boundary \"%s\"\n", bbuf);
d299 2
a300 1
		while (fgets(buf, sizeof buf, e->e_dfp) != NULL)
d305 2
a306 1
			putxline(buf, strlen(buf), mci, PXLF_MAPFROM|PXLF_STRIP8BIT);
d308 1
a308 1
				dprintf("  ...%s", buf);
d310 1
a310 1
		if (feof(e->e_dfp))
d316 1
a316 1
			snprintf(buf, sizeof buf, "--%s", bbuf);
d319 2
a320 2
				dprintf("  ...%s\n", buf);
			collect(e->e_dfp, FALSE, &hdr, e);
d328 1
a328 1
		snprintf(buf, sizeof buf, "--%s--", bbuf);
d331 1
a331 1
			dprintf("  ...%s\n", buf);
d336 2
a337 1
		while (fgets(buf, sizeof buf, e->e_dfp) != NULL)
d342 2
a343 1
			putxline(buf, strlen(buf), mci, PXLF_MAPFROM|PXLF_STRIP8BIT);
d345 1
a345 1
				dprintf("  ...%s", buf);
d347 1
a347 1
		if (feof(e->e_dfp))
d350 1
a350 1
			dprintf("\t\t\tmime8to7=>%s (multipart)\n",
d361 1
a361 1
	if (strcasecmp(type, "message") == 0)
d374 1
a374 1
			collect(e->e_dfp, FALSE, &hdr, e);
d400 1
a400 1
		offset = ftell(e->e_dfp);
d402 1
a402 1
			syserr("mime8to7: cannot ftell on df%s", e->e_id);
d405 2
a406 1
		while (fgets(buf, sizeof buf, e->e_dfp) != NULL)
d431 2
a432 2
		if (fseek(e->e_dfp, offset, SEEK_SET) < 0)
			syserr("mime8to7: cannot fseek on df%s", e->e_id);
d434 1
a434 1
			clearerr(e->e_dfp);
d447 1
a447 1
		dprintf("mime8to7: %ld high bit(s) in %ld byte(s), cte=%s, type=%s/%s\n",
d453 1
a453 1
	if (cte != NULL && strcasecmp(cte, "binary") == 0)
d473 1
a473 1
			snprintf(buf, sizeof buf,
d477 1
a477 1
				dprintf("  ...%s\n", buf);
d481 2
a482 1
		while (fgets(buf, sizeof buf, e->e_dfp) != NULL)
d489 1
a489 1
		if (feof(e->e_dfp))
d499 1
a499 1
			dprintf("  ...Content-Transfer-Encoding: base64\n");
d501 1
a501 1
		snprintf(buf, sizeof buf,
d507 2
a508 1
		while ((c1 = mime_getchar_crlf(e->e_dfp, boundaries, &bt)) != EOF)
d521 1
a521 1
			if (c2 == EOF)
d532 1
a532 1
			if (c2 == EOF)
d565 1
a565 1
			dprintf("  ...Content-Transfer-Encoding: quoted-printable\n");
d567 1
a567 1
		snprintf(buf, sizeof buf,
d575 2
a576 1
		while ((c1 = mime_getchar(e->e_dfp, boundaries, &bt)) != EOF)
d665 1
a665 1
		dprintf("\t\t\tmime8to7=>%s (basic)\n", MimeBoundaryNames[bt]);
d671 1
a671 1
**	Treats boundaries as EOF.
d676 1
a676 1
**		btp -- if the return value is EOF, *btp is set to
d685 1
a685 1
	register FILE *fp;
d690 1
a690 1
	static u_char *bp = NULL;
d692 3
a694 3
	static bool atbol = TRUE;	/* at beginning of line */
	static int bt = MBT_SYNTAX;	/* boundary type of next EOF */
	static u_char buf[128];		/* need not be a full line */
d708 1
a708 1
		c = getc(fp);
d715 2
a716 2
		atbol = TRUE;
		c = getc(fp);
d719 1
a719 1
			(void) ungetc(c, fp);
d724 1
a724 1
	if (c != EOF)
d731 1
a731 1
		c = getc(fp);
d734 1
a734 1
			if (c != EOF)
d746 2
a747 1
		       (c = getc(fp)) != EOF && c != '\n')
d751 1
a751 1
		*bp = '\0';
d760 1
a760 1
			return EOF;
d764 1
a764 1
		if (c != EOF)
d772 1
a772 1
		return EOF;
d783 1
a783 1
**		btp -- if the return value is EOF, *btp is set to
d792 1
a792 1
	register FILE *fp;
d796 1
a796 1
	static bool sendlf = FALSE;
d801 1
a801 1
		sendlf = FALSE;
d807 1
a807 1
		sendlf = TRUE;
d849 1
a849 1
		dprintf("mimeboundary: line=\"%s\"... ", line);
d865 1
a865 1
		dprintf("%s\n", MimeBoundaryNames[type]);
d925 1
d975 1
a975 1
	u_char *fbufp;
d977 1
a977 1
	u_char fbuf[MAXLINE + 1];
d979 1
a979 1
	extern u_char MimeTokenTab[256];
d996 1
a996 1
			snprintf(buf, sizeof buf,
d1002 2
a1003 1
		while (fgets(buf, sizeof buf, e->e_dfp) != NULL)
d1008 1
a1008 1
	cte = newstr(buf);
d1012 1
a1012 1
	snprintf(buf, sizeof buf,
d1025 1
a1025 1
	if (strcasecmp(cte, "base64") == 0)
d1030 2
a1031 1
		while ((c1 = fgetc(e->e_dfp)) != EOF)
d1038 1
a1038 1
				c2 = fgetc(e->e_dfp);
d1040 1
a1040 1
			if (c2 == EOF)
d1045 1
a1045 1
				c3 = fgetc(e->e_dfp);
d1047 1
a1047 1
			if (c3 == EOF)
d1052 1
a1052 1
				c4 = fgetc(e->e_dfp);
d1054 1
a1054 1
			if (c4 == EOF)
d1104 2
a1105 1
		while (fgets(buf, sizeof buf, e->e_dfp) != NULL)
d1107 1
a1107 1
			if (mime_fromqp((u_char *) buf, &fbufp, 0,
d1125 1
a1125 1
		dprintf("\t\t\tmime7to8 => %s to 8bit done\n", cte);
d1132 1
a1132 1
**  What is needed here are changes to defned this code better against
d1152 2
a1153 2
	u_char *infile;
	u_char **outfile;
d1159 3
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1998, 1999 Sendmail, Inc. and its suppliers.
d18 1
a18 1
static char id[] = "@@(#)$Sendmail: mime.c,v 8.94 1999/10/17 17:35:58 ca Exp $";
d280 1
d283 1
d626 1
a626 1
			if (bitnset(c1 & 0xff, badchars))
d833 1
a833 1
	if (line[i - 1] == '\n')
d837 1
a837 1
	while (line[i - 1] == ' ' || line[i - 1] == '\t')
d909 1
a909 1
	for (i = 0; boundaries[i] != NULL; i++)
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.1.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d18 1
a18 1
static char id[] = "@@(#)$Sendmail: mime.c,v 8.94.16.3 2000/10/09 02:46:10 gshapiro Exp $";
a279 1
		{
a281 1
		}
d624 1
a624 1
			if (bitnset(bitidx(c1), badchars))
d831 1
a831 1
	if (i > 0 && line[i - 1] == '\n')
d835 1
a835 1
	while (i > 0 && (line[i - 1] == ' ' || line[i - 1] == '\t'))
d907 1
a907 1
	for (i = 0; i <= MAXMIMENESTING && boundaries[i] != NULL; i++)
@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d18 1
a18 1
static char id[] = "@@(#)$Id: mime.c,v 8.94.16.3 2000/10/09 02:46:10 gshapiro Exp $";
a279 1
		{
a281 1
		}
d624 1
a624 1
			if (bitnset(bitidx(c1), badchars))
d831 1
a831 1
	if (i > 0 && line[i - 1] == '\n')
d835 1
a835 1
	while (i > 0 && (line[i - 1] == ' ' || line[i - 1] == '\t'))
d907 1
a907 1
	for (i = 0; i <= MAXMIMENESTING && boundaries[i] != NULL; i++)
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d17 9
a25 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.121 2001/09/04 22:43:04 ca Exp $")
a44 4
static int	isboundary __P((char *, char **));
static int	mimeboundary __P((char *, char **));
static int	mime_getchar __P((SM_FILE_T *, char **, int *));
static int	mime_getchar_crlf __P((SM_FILE_T *, char **, int *));
d116 1
a116 1
	bool use_qp = false;
d121 1
a121 1
	extern unsigned char MimeTokenTab[256];
d125 1
a125 1
		sm_dprintf("mime8to7: flags = %x, boundaries =", flags);
d127 1
a127 1
			sm_dprintf(" <none>");
d131 1
a131 1
				sm_dprintf(" %s", boundaries[i]);
d133 1
a133 1
		sm_dprintf("\n");
d135 1
a135 1
	MapNLtoCRLF = true;
d147 1
a147 1
		cte = sm_rpool_strdup_x(e->e_rpool, buf);
d167 1
a167 1
				sm_dprintf("pvp[%d] = \"%s\"\n", i, pvp[i]);
d225 1
a225 1
	(void) sm_snprintf(buf, sizeof buf, "%.100s/%.100s", type, subtype);
d231 1
a231 1
		MapNLtoCRLF = false;
d234 1
a234 1
		use_qp = true;
d242 1
a242 1
	if (sm_strcasecmp(type, "multipart") == 0 &&
d246 1
a246 1
		if (sm_strcasecmp(subtype, "digest") == 0)
d251 1
a251 1
			if (sm_strcasecmp(argv[i].a_field, "boundary") == 0)
d268 1
a268 1
		if (sm_strlcpy(bbuf, p, sizeof bbuf) >= sizeof bbuf)
d278 1
a278 2
			sm_dprintf("mime8to7: multipart boundary \"%s\"\n",
				bbuf);
d302 1
a302 2
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof buf)
			!= NULL)
d307 1
a307 2
			putxline(buf, strlen(buf), mci,
				 PXLF_MAPFROM|PXLF_STRIP8BIT);
d309 1
a309 1
				sm_dprintf("  ...%s", buf);
d311 1
a311 1
		if (sm_io_eof(e->e_dfp))
d317 1
a317 1
			(void) sm_strlcpyn(buf, sizeof buf, 2, "--", bbuf);
d320 2
a321 2
				sm_dprintf("  ...%s\n", buf);
			collect(e->e_dfp, false, &hdr, e);
d329 1
a329 1
		(void) sm_strlcpyn(buf, sizeof buf, 3, "--", bbuf, "--");
d332 1
a332 1
			sm_dprintf("  ...%s\n", buf);
d337 1
a337 2
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof buf)
			!= NULL)
d342 1
a342 2
			putxline(buf, strlen(buf), mci,
				 PXLF_MAPFROM|PXLF_STRIP8BIT);
d344 1
a344 1
				sm_dprintf("  ...%s", buf);
d346 1
a346 1
		if (sm_io_eof(e->e_dfp))
d349 1
a349 1
			sm_dprintf("\t\t\tmime8to7=>%s (multipart)\n",
d360 1
a360 1
	if (sm_strcasecmp(type, "message") == 0)
d373 1
a373 1
			collect(e->e_dfp, false, &hdr, e);
d399 1
a399 1
		offset = sm_io_tell(e->e_dfp, SM_TIME_DEFAULT);
d401 1
a401 1
			syserr("mime8to7: cannot sm_io_tell on df%s", e->e_id);
d404 1
a404 2
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof buf)
			!= NULL)
d429 2
a430 2
		if (sm_io_seek(e->e_dfp, SM_TIME_DEFAULT, offset, SEEK_SET) < 0)
			syserr("mime8to7: cannot sm_io_fseek on df%s", e->e_id);
d432 1
a432 1
			sm_io_clearerr(e->e_dfp);
d445 1
a445 1
		sm_dprintf("mime8to7: %ld high bit(s) in %ld byte(s), cte=%s, type=%s/%s\n",
d451 1
a451 1
	if (cte != NULL && sm_strcasecmp(cte, "binary") == 0)
d471 1
a471 1
			(void) sm_snprintf(buf, sizeof buf,
d475 1
a475 1
				sm_dprintf("  ...%s\n", buf);
d479 1
a479 2
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof buf)
			!= NULL)
d486 1
a486 1
		if (sm_io_eof(e->e_dfp))
d496 1
a496 1
			sm_dprintf("  ...Content-Transfer-Encoding: base64\n");
d498 1
a498 1
		(void) sm_snprintf(buf, sizeof buf,
d504 1
a504 2
		while ((c1 = mime_getchar_crlf(e->e_dfp, boundaries, &bt)) !=
			SM_IO_EOF)
d517 1
a517 1
			if (c2 == SM_IO_EOF)
d528 1
a528 1
			if (c2 == SM_IO_EOF)
d561 1
a561 1
			sm_dprintf("  ...Content-Transfer-Encoding: quoted-printable\n");
d563 1
a563 1
		(void) sm_snprintf(buf, sizeof buf,
d571 1
a571 2
		while ((c1 = mime_getchar(e->e_dfp, boundaries, &bt)) !=
			SM_IO_EOF)
d660 1
a660 1
		sm_dprintf("\t\t\tmime8to7=>%s (basic)\n", MimeBoundaryNames[bt]);
d666 1
a666 1
**	Treats boundaries as SM_IO_EOF.
d671 1
a671 1
**		btp -- if the return value is SM_IO_EOF, *btp is set to
d680 1
a680 1
	register SM_FILE_T *fp;
d685 1
a685 1
	static unsigned char *bp = NULL;
d687 3
a689 3
	static bool atbol = true;	/* at beginning of line */
	static int bt = MBT_SYNTAX;	/* boundary type of next SM_IO_EOF */
	static unsigned char buf[128];	/* need not be a full line */
d703 1
a703 1
		c = sm_io_getc(fp, SM_TIME_DEFAULT);
d710 2
a711 2
		atbol = true;
		c = sm_io_getc(fp, SM_TIME_DEFAULT);
d714 1
a714 1
			(void) sm_io_ungetc(fp, SM_TIME_DEFAULT, c);
d719 1
a719 1
	if (c != SM_IO_EOF)
d726 1
a726 1
		c = sm_io_getc(fp, SM_TIME_DEFAULT);
d729 1
a729 1
			if (c != SM_IO_EOF)
d741 1
a741 2
		       (c = sm_io_getc(fp, SM_TIME_DEFAULT)) != SM_IO_EOF &&
		       c != '\n')
d745 1
a745 1
		*bp = '\0';	/* XXX simply cut off? */
d754 1
a754 1
			return SM_IO_EOF;
d758 1
a758 1
		if (c != SM_IO_EOF)
d766 1
a766 1
		return SM_IO_EOF;
d777 1
a777 1
**		btp -- if the return value is SM_IO_EOF, *btp is set to
d786 1
a786 1
	register SM_FILE_T *fp;
d790 1
a790 1
	static bool sendlf = false;
d795 1
a795 1
		sendlf = false;
d801 1
a801 1
		sendlf = true;
d843 1
a843 1
		sm_dprintf("mimeboundary: line=\"%s\"... ", line);
d859 1
a859 1
		sm_dprintf("%s\n", MimeBoundaryNames[type]);
a918 1
static int	mime_fromqp __P((unsigned char *, unsigned char **, int, int));
d968 1
a968 1
	unsigned char *fbufp;
d970 1
a970 1
	unsigned char fbuf[MAXLINE + 1];
d972 1
a972 1
	extern unsigned char MimeTokenTab[256];
d989 1
a989 1
			(void) sm_snprintf(buf, sizeof buf,
d995 1
a995 2
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof buf)
			!= NULL)
d1000 1
a1000 1
	cte = sm_rpool_strdup_x(e->e_rpool, buf);
d1004 1
a1004 1
	(void) sm_snprintf(buf, sizeof buf,
d1017 1
a1017 1
	if (sm_strcasecmp(cte, "base64") == 0)
d1022 1
a1022 2
		while ((c1 = sm_io_getc(e->e_dfp, SM_TIME_DEFAULT)) !=
			SM_IO_EOF)
d1029 1
a1029 1
				c2 = sm_io_getc(e->e_dfp, SM_TIME_DEFAULT);
d1031 1
a1031 1
			if (c2 == SM_IO_EOF)
d1036 1
a1036 1
				c3 = sm_io_getc(e->e_dfp, SM_TIME_DEFAULT);
d1038 1
a1038 1
			if (c3 == SM_IO_EOF)
d1043 1
a1043 1
				c4 = sm_io_getc(e->e_dfp, SM_TIME_DEFAULT);
d1045 1
a1045 1
			if (c4 == SM_IO_EOF)
d1095 1
a1095 2
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof buf)
			!= NULL)
d1097 1
a1097 1
			if (mime_fromqp((unsigned char *) buf, &fbufp, 0,
d1115 1
a1115 1
		sm_dprintf("\t\t\tmime7to8 => %s to 8bit done\n", cte);
d1122 1
a1122 1
**  What is needed here are changes to defend this code better against
d1142 2
a1143 2
	unsigned char *infile;
	unsigned char **outfile;
a1148 3

	if (maxlen < 0)
		return 0;
@


