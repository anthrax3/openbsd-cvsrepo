head	1.30;
access;
symbols
	OPENBSD_5_6:1.29.0.6
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.2
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.26.0.6
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.4
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.25.0.12
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.10
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.6
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.8
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.4
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.24.0.6
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.4
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.21.0.4
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2014.09.17.18.49.52;	author matthieu;	state dead;
branches;
next	1.29;
commitid	M7i5giHIoz3DMlTU;

1.29
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.27;

1.27
date	2012.12.26.11.44.12;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2011.05.17.15.54.24;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2006.08.13.13.01.48;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.22.18.43.55;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.08.16.00.51;	author millert;	state Exp;
branches
	1.21.2.1
	1.21.4.1;
next	1.20;

1.20
date	2004.12.16.00.21.31;	author millert;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2004.06.24.03.59.27;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.09.17.17.31.40;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.16.18.34.50;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.29.19.44.01;	author millert;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2003.03.03.17.31.21;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.01.19.59.23;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.09.15.02.23.36;	author millert;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2002.06.26.04.48.55;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.18.00.49.28;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.10.01.20.18.19;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.01.17.18.30;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.11.19.02.50;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.21.16.31.45;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.29.01.31.15;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.28.02.43.54;	author millert;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.01.15.21.09.09;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.07.19.20.42;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.46;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.46;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.16;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.50;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.31.39;	author miod;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.31.01.47.57;	author jason;	state Exp;
branches;
next	;

1.10.2.1
date	2003.03.03.17.16.59;	author miod;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2003.03.31.07.07.07;	author miod;	state Exp;
branches;
next	;

1.13.2.1
date	2003.03.03.17.19.45;	author brad;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2003.03.31.01.01.47;	author margarida;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2003.09.17.17.36.33;	author brad;	state Exp;
branches;
next	;

1.16.2.1
date	2003.09.17.17.46.15;	author brad;	state Exp;
branches;
next	;

1.20.2.1
date	2006.03.24.05.42.48;	author brad;	state Exp;
branches;
next	;

1.21.2.1
date	2006.03.24.05.56.18;	author brad;	state Exp;
branches;
next	;

1.21.4.1
date	2006.03.25.01.49.38;	author brad;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2006 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>

SM_RCSID("@@(#)$Sendmail: parseaddr.c,v 8.407 2013/11/22 20:51:56 ca Exp $")

#include <sm/sendmail.h>
#include "map.h"

static void	allocaddr __P((ADDRESS *, int, char *, ENVELOPE *));
static int	callsubr __P((char**, int, ENVELOPE *));
static char	*map_lookup __P((STAB *, char *, char **, int *, ENVELOPE *));
static ADDRESS	*buildaddr __P((char **, ADDRESS *, int, ENVELOPE *));
static bool	hasctrlchar __P((register char *, bool, bool));

/* replacement for illegal characters in addresses */
#define BAD_CHAR_REPLACEMENT	'?'

/*
**  PARSEADDR -- Parse an address
**
**	Parses an address and breaks it up into three parts: a
**	net to transmit the message on, the host to transmit it
**	to, and a user on that host.  These are loaded into an
**	ADDRESS header with the values squirreled away if necessary.
**	The "user" part may not be a real user; the process may
**	just reoccur on that machine.  For example, on a machine
**	with an arpanet connection, the address
**		csvax.bill@@berkeley
**	will break up to a "user" of 'csvax.bill' and a host
**	of 'berkeley' -- to be transmitted over the arpanet.
**
**	Parameters:
**		addr -- the address to parse.
**		a -- a pointer to the address descriptor buffer.
**			If NULL, an address will be created.
**		flags -- describe detail for parsing.  See RF_ definitions
**			in sendmail.h.
**		delim -- the character to terminate the address, passed
**			to prescan.
**		delimptr -- if non-NULL, set to the location of the
**			delim character that was found.
**		e -- the envelope that will contain this address.
**		isrcpt -- true if the address denotes a recipient; false
**			indicates a sender.
**
**	Returns:
**		A pointer to the address descriptor header (`a' if
**			`a' is non-NULL).
**		NULL on error.
**
**	Side Effects:
**		e->e_to = addr
*/

/* following delimiters are inherent to the internal algorithms */
#define DELIMCHARS	"()<>,;\r\n"	/* default word delimiters */

ADDRESS *
parseaddr(addr, a, flags, delim, delimptr, e, isrcpt)
	char *addr;
	register ADDRESS *a;
	int flags;
	int delim;
	char **delimptr;
	register ENVELOPE *e;
	bool isrcpt;
{
	char **pvp;
	auto char *delimptrbuf;
	bool qup;
	char pvpbuf[PSBUFSIZE];

	/*
	**  Initialize and prescan address.
	*/

	e->e_to = addr;
	if (tTd(20, 1))
		sm_dprintf("\n--parseaddr(%s)\n", addr);

	if (delimptr == NULL)
		delimptr = &delimptrbuf;

	pvp = prescan(addr, delim, pvpbuf, sizeof(pvpbuf), delimptr,
			ExtTokenTab, false);
	if (pvp == NULL)
	{
		if (tTd(20, 1))
			sm_dprintf("parseaddr-->NULL\n");
		return NULL;
	}

	if (invalidaddr(addr, delim == '\0' ? NULL : *delimptr, isrcpt))
	{
		if (tTd(20, 1))
			sm_dprintf("parseaddr-->bad address\n");
		return NULL;
	}

	/*
	**  Save addr if we are going to have to.
	**
	**	We have to do this early because there is a chance that
	**	the map lookups in the rewriting rules could clobber
	**	static memory somewhere.
	*/

	if (bitset(RF_COPYPADDR, flags) && addr != NULL)
	{
		char savec = **delimptr;

		if (savec != '\0')
			**delimptr = '\0';
		e->e_to = addr = sm_rpool_strdup_x(e->e_rpool, addr);
		if (savec != '\0')
			**delimptr = savec;
	}

	/*
	**  Apply rewriting rules.
	**	Ruleset 0 does basic parsing.  It must resolve.
	*/

	qup = false;
	if (REWRITE(pvp, 3, e) == EX_TEMPFAIL)
		qup = true;
	if (REWRITE(pvp, 0, e) == EX_TEMPFAIL)
		qup = true;

	/*
	**  Build canonical address from pvp.
	*/

	a = buildaddr(pvp, a, flags, e);

	if (hasctrlchar(a->q_user, isrcpt, true))
	{
		if (tTd(20, 1))
			sm_dprintf("parseaddr-->bad q_user\n");

		/*
		**  Just mark the address as bad so DSNs work.
		**  hasctrlchar() has to make sure that the address
		**  has been sanitized, e.g., shortened.
		*/

		a->q_state = QS_BADADDR;
	}

	/*
	**  Make local copies of the host & user and then
	**  transport them out.
	*/

	allocaddr(a, flags, addr, e);
	if (QS_IS_BADADDR(a->q_state))
	{
		/* weed out bad characters in the printable address too */
		(void) hasctrlchar(a->q_paddr, isrcpt, false);
		return a;
	}

	/*
	**  Select a queue directory for recipient addresses.
	**	This is done here and in split_across_queue_groups(),
	**	but the latter applies to addresses after aliasing,
	**	and only if splitting is done.
	*/

	if ((a->q_qgrp == NOAQGRP || a->q_qgrp == ENVQGRP) &&
	    !bitset(RF_SENDERADDR|RF_HEADERADDR|RF_RM_ADDR, flags) &&
	    OpMode != MD_INITALIAS)
	{
		int r;

		/* call ruleset which should return a queue group name */
		r = rscap(RS_QUEUEGROUP, a->q_user, NULL, e, &pvp, pvpbuf,
			  sizeof(pvpbuf));
		if (r == EX_OK &&
		    pvp != NULL && pvp[0] != NULL &&
		    (pvp[0][0] & 0377) == CANONNET &&
		    pvp[1] != NULL && pvp[1][0] != '\0')
		{
			r = name2qid(pvp[1]);
			if (r == NOQGRP && LogLevel > 10)
				sm_syslog(LOG_INFO, NOQID,
					"can't find queue group name %s, selection ignored",
					pvp[1]);
			if (tTd(20, 4) && r != NOQGRP)
				sm_syslog(LOG_INFO, NOQID,
					"queue group name %s -> %d",
					pvp[1], r);
			a->q_qgrp = r == NOQGRP ? ENVQGRP : r;
		}
	}

	/*
	**  If there was a parsing failure, mark it for queueing.
	*/

	if (qup && OpMode != MD_INITALIAS)
	{
		char *msg = "Transient parse error -- message queued for future delivery";

		if (e->e_sendmode == SM_DEFER)
			msg = "Deferring message until queue run";
		if (tTd(20, 1))
			sm_dprintf("parseaddr: queueing message\n");
		message(msg);
		if (e->e_message == NULL && e->e_sendmode != SM_DEFER)
			e->e_message = sm_rpool_strdup_x(e->e_rpool, msg);
		a->q_state = QS_QUEUEUP;
		a->q_status = "4.4.3";
	}

	/*
	**  Compute return value.
	*/

	if (tTd(20, 1))
	{
		sm_dprintf("parseaddr-->");
		printaddr(sm_debug_file(), a, false);
	}

	return a;
}
/*
**  INVALIDADDR -- check for address containing characters used for macros
**
**	Parameters:
**		addr -- the address to check.
**		  note: this is the complete address (including display part)
**		delimptr -- if non-NULL: end of address to check, i.e.,
**			a pointer in the address string.
**		isrcpt -- true iff the address is for a recipient.
**
**	Returns:
**		true -- if the address has characters that are reservered
**			for macros or is too long.
**		false -- otherwise.
*/

bool
invalidaddr(addr, delimptr, isrcpt)
	register char *addr;
	char *delimptr;
	bool isrcpt;
{
	bool result = false;
	char savedelim = '\0';
	char *b = addr;
	int len = 0;

	if (delimptr != NULL)
	{
		/* delimptr points to the end of the address to test */
		savedelim = *delimptr;
		if (savedelim != '\0')	/* if that isn't '\0' already: */
			*delimptr = '\0';	/* set it */
	}
	for (; *addr != '\0'; addr++)
	{
		if (!EightBitAddrOK && (*addr & 0340) == 0200)
		{
			setstat(EX_USAGE);
			result = true;
			*addr = BAD_CHAR_REPLACEMENT;
		}
		if (++len > MAXNAME - 1)
		{
			char saved = *addr;

			*addr = '\0';
			usrerr("553 5.1.0 Address \"%s\" too long (%d bytes max)",
			       b, MAXNAME - 1);
			*addr = saved;
			result = true;
			goto delim;
		}
	}
	if (result)
	{
		if (isrcpt)
			usrerr("501 5.1.3 8-bit character in mailbox address \"%s\"",
			       b);
		else
			usrerr("501 5.1.7 8-bit character in mailbox address \"%s\"",
			       b);
	}
delim:
	if (delimptr != NULL && savedelim != '\0')
		*delimptr = savedelim;	/* restore old character at delimptr */
	return result;
}
/*
**  HASCTRLCHAR -- check for address containing meta-characters
**
**  Checks that the address contains no meta-characters, and contains
**  no "non-printable" characters unless they are quoted or escaped.
**  Quoted or escaped characters are literals.
**
**	Parameters:
**		addr -- the address to check.
**		isrcpt -- true if the address is for a recipient; false
**			indicates a from.
**		complain -- true if an error should issued if the address
**			is invalid and should be "repaired".
**
**	Returns:
**		true -- if the address has any "weird" characters or
**			non-printable characters or if a quote is unbalanced.
**		false -- otherwise.
*/

static bool
hasctrlchar(addr, isrcpt, complain)
	register char *addr;
	bool isrcpt, complain;
{
	bool quoted = false;
	int len = 0;
	char *result = NULL;
	char *b = addr;

	if (addr == NULL)
		return false;
	for (; *addr != '\0'; addr++)
	{
		if (++len > MAXNAME - 1)
		{
			if (complain)
			{
				(void) shorten_rfc822_string(b, MAXNAME - 1);
				usrerr("553 5.1.0 Address \"%s\" too long (%d bytes max)",
				       b, MAXNAME - 1);
				return true;
			}
			result = "too long";
		}
		if (!EightBitAddrOK && !quoted && (*addr < 32 || *addr == 127))
		{
			result = "non-printable character";
			*addr = BAD_CHAR_REPLACEMENT;
			continue;
		}
		if (*addr == '"')
			quoted = !quoted;
		else if (*addr == '\\')
		{
			/* XXX Generic problem: no '\0' in strings. */
			if (*++addr == '\0')
			{
				result = "trailing \\ character";
				*--addr = BAD_CHAR_REPLACEMENT;
				break;
			}
		}
		if (!EightBitAddrOK && (*addr & 0340) == 0200)
		{
			setstat(EX_USAGE);
			result = "8-bit character";
			*addr = BAD_CHAR_REPLACEMENT;
			continue;
		}
	}
	if (quoted)
		result = "unbalanced quote"; /* unbalanced quote */
	if (result != NULL && complain)
	{
		if (isrcpt)
			usrerr("501 5.1.3 Syntax error in mailbox address \"%s\" (%s)",
			       b, result);
		else
			usrerr("501 5.1.7 Syntax error in mailbox address \"%s\" (%s)",
			       b, result);
	}
	return result != NULL;
}
/*
**  ALLOCADDR -- do local allocations of address on demand.
**
**	Also lowercases the host name if requested.
**
**	Parameters:
**		a -- the address to reallocate.
**		flags -- the copy flag (see RF_ definitions in sendmail.h
**			for a description).
**		paddr -- the printname of the address.
**		e -- envelope
**
**	Returns:
**		none.
**
**	Side Effects:
**		Copies portions of a into local buffers as requested.
*/

static void
allocaddr(a, flags, paddr, e)
	register ADDRESS *a;
	int flags;
	char *paddr;
	ENVELOPE *e;
{
	if (tTd(24, 4))
		sm_dprintf("allocaddr(flags=%x, paddr=%s)\n", flags, paddr);

	a->q_paddr = paddr;

	if (a->q_user == NULL)
		a->q_user = "";
	if (a->q_host == NULL)
		a->q_host = "";

	if (bitset(RF_COPYPARSE, flags))
	{
		a->q_host = sm_rpool_strdup_x(e->e_rpool, a->q_host);
		if (a->q_user != a->q_paddr)
			a->q_user = sm_rpool_strdup_x(e->e_rpool, a->q_user);
	}

	if (a->q_paddr == NULL)
		a->q_paddr = sm_rpool_strdup_x(e->e_rpool, a->q_user);
	a->q_qgrp = NOAQGRP;
}

/*
**  PRESCAN -- Prescan name and make it canonical
**
**	Scans a name and turns it into a set of tokens.  This process
**	deletes blanks and comments (in parentheses) (if the token type
**	for left paren is SPC).
**
**	This routine knows about quoted strings and angle brackets.
**
**	There are certain subtleties to this routine.  The one that
**	comes to mind now is that backslashes on the ends of names
**	are silently stripped off; this is intentional.  The problem
**	is that some versions of sndmsg (like at LBL) set the kill
**	character to something other than @@ when reading addresses;
**	so people type "csvax.eric\@@berkeley" -- which screws up the
**	berknet mailer.
**
**	Parameters:
**		addr -- the name to chomp.
**		delim -- the delimiter for the address, normally
**			'\0' or ','; \0 is accepted in any case.
**			If '\t' then we are reading the .cf file.
**		pvpbuf -- place to put the saved text -- note that
**			the pointers are static.
**		pvpbsize -- size of pvpbuf.
**		delimptr -- if non-NULL, set to the location of the
**			terminating delimiter.
**		toktab -- if set, a token table to use for parsing.
**			If NULL, use the default table.
**		ignore -- if true, ignore unbalanced addresses
**
**	Returns:
**		A pointer to a vector of tokens.
**		NULL on error.
*/

/* states and character types */
#define OPR		0	/* operator */
#define ATM		1	/* atom */
#define QST		2	/* in quoted string */
#define SPC		3	/* chewing up spaces */
#define ONE		4	/* pick up one character */
#define ILL		5	/* illegal character */

#define NSTATES	6	/* number of states */
#define TYPE		017	/* mask to select state type */

/* meta bits for table */
#define M		020	/* meta character; don't pass through */
#define B		040	/* cause a break */
#define MB		M|B	/* meta-break */

static short StateTab[NSTATES][NSTATES] =
{
   /*	oldst	chtype>	OPR	ATM	QST	SPC	ONE	ILL	*/
	/*OPR*/	{	OPR|B,	ATM|B,	QST|B,	SPC|MB,	ONE|B,	ILL|MB	},
	/*ATM*/	{	OPR|B,	ATM,	QST|B,	SPC|MB,	ONE|B,	ILL|MB	},
	/*QST*/	{	QST,	QST,	OPR,	QST,	QST,	QST	},
	/*SPC*/	{	OPR,	ATM,	QST,	SPC|M,	ONE,	ILL|MB	},
	/*ONE*/	{	OPR,	OPR,	OPR,	OPR,	OPR,	ILL|MB	},
	/*ILL*/	{	OPR|B,	ATM|B,	QST|B,	SPC|MB,	ONE|B,	ILL|M	}
};

/* these all get modified with the OperatorChars */

/* token type table for external strings */
unsigned char	ExtTokenTab[256] =
{
    /*	nul soh stx etx eot enq ack bel  bs  ht  nl  vt  np  cr  so  si   */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,SPC,SPC,SPC,SPC,SPC,ATM,ATM,
    /*	dle dc1 dc2 dc3 dc4 nak syn etb  can em  sub esc fs  gs  rs  us   */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*  sp  !   "   #   $   %   &   '    (   )   *   +   ,   -   .   /    */
	SPC,ATM,QST,ATM,ATM,ATM,ATM,ATM, SPC,SPC,ATM,ATM,ATM,ATM,ATM,ATM,
    /*	0   1   2   3   4   5   6   7    8   9   :   ;   <   =   >   ?    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*	@@   A   B   C   D   E   F   G    H   I   J   K   L   M   N   O    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*  P   Q   R   S   T   U   V   W    X   Y   Z   [   \   ]   ^   _    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*	`   a   b   c   d   e   f   g    h   i   j   k   l   m   n   o    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*  p   q   r   s   t   u   v   w    x   y   z   {   |   }   ~   del  */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,

    /*	nul soh stx etx eot enq ack bel  bs  ht  nl  vt  np  cr  so  si   */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*	dle dc1 dc2 dc3 dc4 nak syn etb  can em  sub esc fs  gs  rs  us   */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*  sp  !   "   #   $   %   &   '    (   )   *   +   ,   -   .   /    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*	0   1   2   3   4   5   6   7    8   9   :   ;   <   =   >   ?    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*	@@   A   B   C   D   E   F   G    H   I   J   K   L   M   N   O    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*  P   Q   R   S   T   U   V   W    X   Y   Z   [   \   ]   ^   _    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*	`   a   b   c   d   e   f   g    h   i   j   k   l   m   n   o    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*  p   q   r   s   t   u   v   w    x   y   z   {   |   }   ~   del  */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM
};

/* token type table for internal strings */
unsigned char	IntTokenTab[256] =
{
    /*	nul soh stx etx eot enq ack bel  bs  ht  nl  vt  np  cr  so  si   */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,SPC,SPC,SPC,SPC,SPC,ATM,ATM,
    /*	dle dc1 dc2 dc3 dc4 nak syn etb  can em  sub esc fs  gs  rs  us   */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*  sp  !   "   #   $   %   &   '    (   )   *   +   ,   -   .   /    */
	SPC,ATM,QST,ATM,ATM,ATM,ATM,ATM, SPC,SPC,ATM,ATM,ATM,ATM,ATM,ATM,
    /*	0   1   2   3   4   5   6   7    8   9   :   ;   <   =   >   ?    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*	@@   A   B   C   D   E   F   G    H   I   J   K   L   M   N   O    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*  P   Q   R   S   T   U   V   W    X   Y   Z   [   \   ]   ^   _    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*	`   a   b   c   d   e   f   g    h   i   j   k   l   m   n   o    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*  p   q   r   s   t   u   v   w    x   y   z   {   |   }   ~   del  */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,

    /*	nul soh stx etx eot enq ack bel  bs  ht  nl  vt  np  cr  so  si   */
	OPR,OPR,ONE,OPR,OPR,OPR,OPR,OPR, OPR,OPR,OPR,OPR,OPR,OPR,OPR,OPR,
    /*	dle dc1 dc2 dc3 dc4 nak syn etb  can em  sub esc fs  gs  rs  us   */
	OPR,OPR,OPR,ONE,ONE,ONE,OPR,OPR, OPR,OPR,OPR,OPR,OPR,OPR,OPR,OPR,
    /*  sp  !   "   #   $   %   &   '    (   )   *   +   ,   -   .   /    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*	0   1   2   3   4   5   6   7    8   9   :   ;   <   =   >   ?    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*	@@   A   B   C   D   E   F   G    H   I   J   K   L   M   N   O    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*  P   Q   R   S   T   U   V   W    X   Y   Z   [   \   ]   ^   _    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*	`   a   b   c   d   e   f   g    h   i   j   k   l   m   n   o    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*  p   q   r   s   t   u   v   w    x   y   z   {   |   }   ~   del  */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ONE
};

/* token type table for MIME parsing */
unsigned char	MimeTokenTab[256] =
{
    /*	nul soh stx etx eot enq ack bel  bs  ht  nl  vt  np  cr  so  si   */
	ILL,ILL,ILL,ILL,ILL,ILL,ILL,ILL, ILL,SPC,SPC,SPC,SPC,SPC,ILL,ILL,
    /*	dle dc1 dc2 dc3 dc4 nak syn etb  can em  sub esc fs  gs  rs  us   */
	ILL,ILL,ILL,ILL,ILL,ILL,ILL,ILL, ILL,ILL,ILL,ILL,ILL,ILL,ILL,ILL,
    /*  sp  !   "   #   $   %   &   '    (   )   *   +   ,   -   .   /    */
	SPC,ATM,QST,ATM,ATM,ATM,ATM,ATM, SPC,SPC,ATM,ATM,OPR,ATM,ATM,OPR,
    /*	0   1   2   3   4   5   6   7    8   9   :   ;   <   =   >   ?    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,OPR,OPR,OPR,OPR,OPR,OPR,
    /*	@@   A   B   C   D   E   F   G    H   I   J   K   L   M   N   O    */
	OPR,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*  P   Q   R   S   T   U   V   W    X   Y   Z   [   \   ]   ^   _    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,OPR,OPR,OPR,ATM,ATM,
    /*	`   a   b   c   d   e   f   g    h   i   j   k   l   m   n   o    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*  p   q   r   s   t   u   v   w    x   y   z   {   |   }   ~   del  */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,

    /*	nul soh stx etx eot enq ack bel  bs  ht  nl  vt  np  cr  so  si   */
	ILL,ILL,ILL,ILL,ILL,ILL,ILL,ILL, ILL,ILL,ILL,ILL,ILL,ILL,ILL,ILL,
    /*	dle dc1 dc2 dc3 dc4 nak syn etb  can em  sub esc fs  gs  rs  us   */
	ILL,ILL,ILL,ILL,ILL,ILL,ILL,ILL, ILL,ILL,ILL,ILL,ILL,ILL,ILL,ILL,
    /*  sp  !   "   #   $   %   &   '    (   )   *   +   ,   -   .   /    */
	ILL,ILL,ILL,ILL,ILL,ILL,ILL,ILL, ILL,ILL,ILL,ILL,ILL,ILL,ILL,ILL,
    /*	0   1   2   3   4   5   6   7    8   9   :   ;   <   =   >   ?    */
	ILL,ILL,ILL,ILL,ILL,ILL,ILL,ILL, ILL,ILL,ILL,ILL,ILL,ILL,ILL,ILL,
    /*	@@   A   B   C   D   E   F   G    H   I   J   K   L   M   N   O    */
	ILL,ILL,ILL,ILL,ILL,ILL,ILL,ILL, ILL,ILL,ILL,ILL,ILL,ILL,ILL,ILL,
    /*  P   Q   R   S   T   U   V   W    X   Y   Z   [   \   ]   ^   _    */
	ILL,ILL,ILL,ILL,ILL,ILL,ILL,ILL, ILL,ILL,ILL,ILL,ILL,ILL,ILL,ILL,
    /*	`   a   b   c   d   e   f   g    h   i   j   k   l   m   n   o    */
	ILL,ILL,ILL,ILL,ILL,ILL,ILL,ILL, ILL,ILL,ILL,ILL,ILL,ILL,ILL,ILL,
    /*  p   q   r   s   t   u   v   w    x   y   z   {   |   }   ~   del  */
	ILL,ILL,ILL,ILL,ILL,ILL,ILL,ILL, ILL,ILL,ILL,ILL,ILL,ILL,ILL,ONE
};

/* token type table: don't strip comments */
unsigned char	TokTypeNoC[256] =
{
    /*	nul soh stx etx eot enq ack bel  bs  ht  nl  vt  np  cr  so  si   */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,SPC,SPC,SPC,SPC,SPC,ATM,ATM,
    /*	dle dc1 dc2 dc3 dc4 nak syn etb  can em  sub esc fs  gs  rs  us   */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*  sp  !   "   #   $   %   &   '    (   )   *   +   ,   -   .   /    */
	SPC,ATM,QST,ATM,ATM,ATM,ATM,ATM, OPR,OPR,ATM,ATM,ATM,ATM,ATM,ATM,
    /*	0   1   2   3   4   5   6   7    8   9   :   ;   <   =   >   ?    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*	@@   A   B   C   D   E   F   G    H   I   J   K   L   M   N   O    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*  P   Q   R   S   T   U   V   W    X   Y   Z   [   \   ]   ^   _    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*	`   a   b   c   d   e   f   g    h   i   j   k   l   m   n   o    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*  p   q   r   s   t   u   v   w    x   y   z   {   |   }   ~   del  */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,

    /*	nul soh stx etx eot enq ack bel  bs  ht  nl  vt  np  cr  so  si   */
	OPR,OPR,ONE,OPR,OPR,OPR,OPR,OPR, OPR,OPR,OPR,OPR,OPR,OPR,OPR,OPR,
    /*	dle dc1 dc2 dc3 dc4 nak syn etb  can em  sub esc fs  gs  rs  us   */
	OPR,OPR,OPR,ONE,ONE,ONE,OPR,OPR, OPR,OPR,OPR,OPR,OPR,OPR,OPR,OPR,
    /*  sp  !   "   #   $   %   &   '    (   )   *   +   ,   -   .   /    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*	0   1   2   3   4   5   6   7    8   9   :   ;   <   =   >   ?    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*	@@   A   B   C   D   E   F   G    H   I   J   K   L   M   N   O    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*  P   Q   R   S   T   U   V   W    X   Y   Z   [   \   ]   ^   _    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*	`   a   b   c   d   e   f   g    h   i   j   k   l   m   n   o    */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
    /*  p   q   r   s   t   u   v   w    x   y   z   {   |   }   ~   del  */
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ONE
};


#define NOCHAR		(-1)	/* signal nothing in lookahead token */

char **
prescan(addr, delim, pvpbuf, pvpbsize, delimptr, toktab, ignore)
	char *addr;
	int delim;
	char pvpbuf[];
	int pvpbsize;
	char **delimptr;
	unsigned char *toktab;
	bool ignore;
{
	register char *p;
	register char *q;
	register int c;
	char **avp;
	bool bslashmode;
	bool route_syntax;
	int cmntcnt;
	int anglecnt;
	char *tok;
	int state;
	int newstate;
	char *saveto = CurEnv->e_to;
	static char *av[MAXATOM + 1];
	static bool firsttime = true;

	if (firsttime)
	{
		/* initialize the token type table */
		char obuf[50];

		firsttime = false;
		if (OperatorChars == NULL)
		{
			if (ConfigLevel < 7)
				OperatorChars = macvalue('o', CurEnv);
			if (OperatorChars == NULL)
				OperatorChars = ".:@@[]";
		}
		expand(OperatorChars, obuf, sizeof(obuf) - sizeof(DELIMCHARS),
		       CurEnv);
		(void) sm_strlcat(obuf, DELIMCHARS, sizeof(obuf));
		for (p = obuf; *p != '\0'; p++)
		{
			if (IntTokenTab[*p & 0xff] == ATM)
				IntTokenTab[*p & 0xff] = OPR;
			if (ExtTokenTab[*p & 0xff] == ATM)
				ExtTokenTab[*p & 0xff] = OPR;
			if (TokTypeNoC[*p & 0xff] == ATM)
				TokTypeNoC[*p & 0xff] = OPR;
		}
	}
	if (toktab == NULL)
		toktab = ExtTokenTab;

	/* make sure error messages don't have garbage on them */
	errno = 0;

	q = pvpbuf;
	bslashmode = false;
	route_syntax = false;
	cmntcnt = 0;
	anglecnt = 0;
	avp = av;
	state = ATM;
	c = NOCHAR;
	p = addr;
	CurEnv->e_to = p;
	if (tTd(22, 11))
	{
		sm_dprintf("prescan: ");
		xputs(sm_debug_file(), p);
		sm_dprintf("\n");
	}

	do
	{
		/* read a token */
		tok = q;
		for (;;)
		{
			/* store away any old lookahead character */
			if (c != NOCHAR && !bslashmode)
			{
				/* see if there is room */
				if (q >= &pvpbuf[pvpbsize - 5])
				{
	addrtoolong:
					usrerr("553 5.1.1 Address too long");
					if (strlen(addr) > MAXNAME)
						addr[MAXNAME] = '\0';
	returnnull:
					if (delimptr != NULL)
					{
						if (p > addr)
							--p;
						*delimptr = p;
					}
					CurEnv->e_to = saveto;
					return NULL;
				}

				/* squirrel it away */
#if !ALLOW_255
				if ((char) c == (char) -1 && !tTd(82, 101) &&
				    !EightBitAddrOK)
					c &= 0x7f;
#endif /* !ALLOW_255 */
				*q++ = c;
			}

			/* read a new input character */
			c = (*p++) & 0x00ff;
			if (c == '\0')
			{
				/* diagnose and patch up bad syntax */
				if (ignore)
					break;
				else if (state == QST)
				{
					usrerr("553 Unbalanced '\"'");
					c = '"';
				}
				else if (cmntcnt > 0)
				{
					usrerr("553 Unbalanced '('");
					c = ')';
				}
				else if (anglecnt > 0)
				{
					c = '>';
					usrerr("553 Unbalanced '<'");
				}
				else
					break;

				p--;
			}
			else if (c == delim && cmntcnt <= 0 && state != QST)
			{
				if (anglecnt <= 0)
					break;

				/* special case for better error management */
				if (delim == ',' && !route_syntax && !ignore)
				{
					usrerr("553 Unbalanced '<'");
					c = '>';
					p--;
				}
			}

			if (tTd(22, 101))
				sm_dprintf("c=%c, s=%d; ", c, state);

			/* chew up special characters */
			*q = '\0';
			if (bslashmode)
			{
				bslashmode = false;

				/* kludge \! for naive users */
				if (cmntcnt > 0)
				{
					c = NOCHAR;
					continue;
				}
				else if (c != '!' || state == QST)
				{
					/* see if there is room */
					if (q >= &pvpbuf[pvpbsize - 5])
						goto addrtoolong;
					*q++ = '\\';
					continue;
				}
			}

			if (c == '\\')
			{
				bslashmode = true;
			}
			else if (state == QST)
			{
				/* EMPTY */
				/* do nothing, just avoid next clauses */
			}
			else if (c == '(' && toktab['('] == SPC)
			{
				cmntcnt++;
				c = NOCHAR;
			}
			else if (c == ')' && toktab['('] == SPC)
			{
				if (cmntcnt <= 0)
				{
					if (!ignore)
					{
						usrerr("553 Unbalanced ')'");
						c = NOCHAR;
					}
				}
				else
					cmntcnt--;
			}
			else if (cmntcnt > 0)
			{
				c = NOCHAR;
			}
			else if (c == '<')
			{
				char *ptr = p;

				anglecnt++;
				while (isascii(*ptr) && isspace(*ptr))
					ptr++;
				if (*ptr == '@@')
					route_syntax = true;
			}
			else if (c == '>')
			{
				if (anglecnt <= 0)
				{
					if (!ignore)
					{
						usrerr("553 Unbalanced '>'");
						c = NOCHAR;
					}
				}
				else
					anglecnt--;
				route_syntax = false;
			}
			else if (delim == ' ' && isascii(c) && isspace(c))
				c = ' ';

			if (c == NOCHAR)
				continue;

			/* see if this is end of input */
			if (c == delim && anglecnt <= 0 && state != QST)
				break;

			newstate = StateTab[state][toktab[c & 0xff]];
			if (tTd(22, 101))
				sm_dprintf("ns=%02o\n", newstate);
			state = newstate & TYPE;
			if (state == ILL)
			{
				if (isascii(c) && isprint(c))
					usrerr("553 Illegal character %c", c);
				else
					usrerr("553 Illegal character 0x%02x",
					       c & 0x0ff);
			}
			if (bitset(M, newstate))
				c = NOCHAR;
			if (bitset(B, newstate))
				break;
		}

		/* new token */
		if (tok != q)
		{
			/* see if there is room */
			if (q >= &pvpbuf[pvpbsize - 5])
				goto addrtoolong;
			*q++ = '\0';
			if (tTd(22, 36))
			{
				sm_dprintf("tok=");
				xputs(sm_debug_file(), tok);
				sm_dprintf("\n");
			}
			if (avp >= &av[MAXATOM])
			{
				usrerr("553 5.1.0 prescan: too many tokens");
				goto returnnull;
			}
			if (q - tok > MAXNAME)
			{
				usrerr("553 5.1.0 prescan: token too long");
				goto returnnull;
			}
			*avp++ = tok;
		}
	} while (c != '\0' && (c != delim || anglecnt > 0));
	*avp = NULL;
	if (delimptr != NULL)
	{
		if (p > addr)
			p--;
		*delimptr = p;
	}
	if (tTd(22, 12))
	{
		sm_dprintf("prescan==>");
		printav(sm_debug_file(), av);
	}
	CurEnv->e_to = saveto;
	if (av[0] == NULL)
	{
		if (tTd(22, 1))
			sm_dprintf("prescan: null leading token\n");
		return NULL;
	}
	return av;
}
/*
**  REWRITE -- apply rewrite rules to token vector.
**
**	This routine is an ordered production system.  Each rewrite
**	rule has a LHS (called the pattern) and a RHS (called the
**	rewrite); 'rwr' points the the current rewrite rule.
**
**	For each rewrite rule, 'avp' points the address vector we
**	are trying to match against, and 'pvp' points to the pattern.
**	If pvp points to a special match value (MATCHZANY, MATCHANY,
**	MATCHONE, MATCHCLASS, MATCHNCLASS) then the address in avp
**	matched is saved away in the match vector (pointed to by 'mvp').
**
**	When a match between avp & pvp does not match, we try to
**	back out.  If we back up over MATCHONE, MATCHCLASS, or MATCHNCLASS
**	we must also back out the match in mvp.  If we reach a
**	MATCHANY or MATCHZANY we just extend the match and start
**	over again.
**
**	When we finally match, we rewrite the address vector
**	and try over again.
**
**	Parameters:
**		pvp -- pointer to token vector.
**		ruleset -- the ruleset to use for rewriting.
**		reclevel -- recursion level (to catch loops).
**		e -- the current envelope.
**		maxatom -- maximum length of buffer (usually MAXATOM)
**
**	Returns:
**		A status code.  If EX_TEMPFAIL, higher level code should
**			attempt recovery.
**
**	Side Effects:
**		pvp is modified.
*/

struct match
{
	char	**match_first;		/* first token matched */
	char	**match_last;		/* last token matched */
	char	**match_pattern;	/* pointer to pattern */
};

int
rewrite(pvp, ruleset, reclevel, e, maxatom)
	char **pvp;
	int ruleset;
	int reclevel;
	register ENVELOPE *e;
	int maxatom;
{
	register char *ap;		/* address pointer */
	register char *rp;		/* rewrite pointer */
	register char *rulename;	/* ruleset name */
	register char *prefix;
	register char **avp;		/* address vector pointer */
	register char **rvp;		/* rewrite vector pointer */
	register struct match *mlp;	/* cur ptr into mlist */
	register struct rewrite *rwr;	/* pointer to current rewrite rule */
	int ruleno;			/* current rule number */
	int rstat = EX_OK;		/* return status */
	int loopcount;
	struct match mlist[MAXMATCH];	/* stores match on LHS */
	char *npvp[MAXATOM + 1];	/* temporary space for rebuild */
	char buf[MAXLINE];
	char name[6];

	/*
	**  mlp will not exceed mlist[] because readcf enforces
	**	the upper limit of entries when reading rulesets.
	*/

	if (ruleset < 0 || ruleset >= MAXRWSETS)
	{
		syserr("554 5.3.5 rewrite: illegal ruleset number %d", ruleset);
		return EX_CONFIG;
	}
	rulename = RuleSetNames[ruleset];
	if (rulename == NULL)
	{
		(void) sm_snprintf(name, sizeof(name), "%d", ruleset);
		rulename = name;
	}
	if (OpMode == MD_TEST)
		prefix = "";
	else
		prefix = "rewrite: ruleset ";
	if (OpMode == MD_TEST)
	{
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "%s%-16.16s   input:", prefix, rulename);
		printav(smioout, pvp);
	}
	else if (tTd(21, 1))
	{
		sm_dprintf("%s%-16.16s   input:", prefix, rulename);
		printav(sm_debug_file(), pvp);
	}
	if (reclevel++ > MaxRuleRecursion)
	{
		syserr("rewrite: excessive recursion (max %d), ruleset %s",
			MaxRuleRecursion, rulename);
		return EX_CONFIG;
	}
	if (pvp == NULL)
		return EX_USAGE;
	if (maxatom <= 0)
		return EX_USAGE;

	/*
	**  Run through the list of rewrite rules, applying
	**	any that match.
	*/

	ruleno = 1;
	loopcount = 0;
	for (rwr = RewriteRules[ruleset]; rwr != NULL; )
	{
		int status;

		/* if already canonical, quit now */
		if (pvp[0] != NULL && (pvp[0][0] & 0377) == CANONNET)
			break;

		if (tTd(21, 12))
		{
			if (tTd(21, 15))
				sm_dprintf("-----trying rule (line %d):",
				       rwr->r_line);
			else
				sm_dprintf("-----trying rule:");
			printav(sm_debug_file(), rwr->r_lhs);
		}

		/* try to match on this rule */
		mlp = mlist;
		rvp = rwr->r_lhs;
		avp = pvp;
		if (++loopcount > 100)
		{
			syserr("554 5.3.5 Infinite loop in ruleset %s, rule %d",
				rulename, ruleno);
			if (tTd(21, 1))
			{
				sm_dprintf("workspace: ");
				printav(sm_debug_file(), pvp);
			}
			break;
		}

		while ((ap = *avp) != NULL || *rvp != NULL)
		{
			rp = *rvp;
			if (tTd(21, 35))
			{
				sm_dprintf("ADVANCE rp=");
				xputs(sm_debug_file(), rp);
				sm_dprintf(", ap=");
				xputs(sm_debug_file(), ap);
				sm_dprintf("\n");
			}
			if (rp == NULL)
			{
				/* end-of-pattern before end-of-address */
				goto backup;
			}
			if (ap == NULL &&
			    (rp[0] & 0377) != MATCHZANY &&
			    (rp[0] & 0377) != MATCHZERO)
			{
				/* end-of-input with patterns left */
				goto backup;
			}

			switch (rp[0] & 0377)
			{
			  case MATCHCLASS:
				/* match any phrase in a class */
				mlp->match_pattern = rvp;
				mlp->match_first = avp;
	extendclass:
				ap = *avp;
				if (ap == NULL)
					goto backup;
				mlp->match_last = avp++;
				cataddr(mlp->match_first, mlp->match_last,
					buf, sizeof(buf), '\0', true);
				if (!wordinclass(buf, rp[1]))
				{
					if (tTd(21, 36))
					{
						sm_dprintf("EXTEND  rp=");
						xputs(sm_debug_file(), rp);
						sm_dprintf(", ap=");
						xputs(sm_debug_file(), ap);
						sm_dprintf("\n");
					}
					goto extendclass;
				}
				if (tTd(21, 36))
					sm_dprintf("CLMATCH\n");
				mlp++;
				break;

			  case MATCHNCLASS:
				/* match any token not in a class */
				if (wordinclass(ap, rp[1]))
					goto backup;

				/* FALLTHROUGH */

			  case MATCHONE:
			  case MATCHANY:
				/* match exactly one token */
				mlp->match_pattern = rvp;
				mlp->match_first = avp;
				mlp->match_last = avp++;
				mlp++;
				break;

			  case MATCHZANY:
				/* match zero or more tokens */
				mlp->match_pattern = rvp;
				mlp->match_first = avp;
				mlp->match_last = avp - 1;
				mlp++;
				break;

			  case MATCHZERO:
				/* match zero tokens */
				break;

			  case MACRODEXPAND:
				/*
				**  Match against run-time macro.
				**  This algorithm is broken for the
				**  general case (no recursive macros,
				**  improper tokenization) but should
				**  work for the usual cases.
				*/

				ap = macvalue(rp[1], e);
				mlp->match_first = avp;
				if (tTd(21, 2))
					sm_dprintf("rewrite: LHS $&{%s} => \"%s\"\n",
						macname(rp[1]),
						ap == NULL ? "(NULL)" : ap);

				if (ap == NULL)
					break;
				while (*ap != '\0')
				{
					if (*avp == NULL ||
					    sm_strncasecmp(ap, *avp,
							   strlen(*avp)) != 0)
					{
						/* no match */
						avp = mlp->match_first;
						goto backup;
					}
					ap += strlen(*avp++);
				}

				/* match */
				break;

			  default:
				/* must have exact match */
				if (sm_strcasecmp(rp, ap))
					goto backup;
				avp++;
				break;
			}

			/* successful match on this token */
			rvp++;
			continue;

	  backup:
			/* match failed -- back up */
			while (--mlp >= mlist)
			{
				rvp = mlp->match_pattern;
				rp = *rvp;
				avp = mlp->match_last + 1;
				ap = *avp;

				if (tTd(21, 36))
				{
					sm_dprintf("BACKUP  rp=");
					xputs(sm_debug_file(), rp);
					sm_dprintf(", ap=");
					xputs(sm_debug_file(), ap);
					sm_dprintf("\n");
				}

				if (ap == NULL)
				{
					/* run off the end -- back up again */
					continue;
				}

				if ((rp[0] & 0377) == MATCHANY ||
				    (rp[0] & 0377) == MATCHZANY)
				{
					/* extend binding and continue */
					mlp->match_last = avp++;
					rvp++;
					mlp++;
					break;
				}
				if ((rp[0] & 0377) == MATCHCLASS)
				{
					/* extend binding and try again */
					mlp->match_last = avp;
					goto extendclass;
				}
			}

			if (mlp < mlist)
			{
				/* total failure to match */
				break;
			}
		}

		/*
		**  See if we successfully matched
		*/

		if (mlp < mlist || *rvp != NULL)
		{
			if (tTd(21, 10))
				sm_dprintf("----- rule fails\n");
			rwr = rwr->r_next;
			ruleno++;
			loopcount = 0;
			continue;
		}

		rvp = rwr->r_rhs;
		if (tTd(21, 12))
		{
			sm_dprintf("-----rule matches:");
			printav(sm_debug_file(), rvp);
		}

		rp = *rvp;
		if (rp != NULL)
		{
			if ((rp[0] & 0377) == CANONUSER)
			{
				rvp++;
				rwr = rwr->r_next;
				ruleno++;
				loopcount = 0;
			}
			else if ((rp[0] & 0377) == CANONHOST)
			{
				rvp++;
				rwr = NULL;
			}
		}

		/* substitute */
		for (avp = npvp; *rvp != NULL; rvp++)
		{
			register struct match *m;
			register char **pp;

			rp = *rvp;
			if ((rp[0] & 0377) == MATCHREPL)
			{
				/* substitute from LHS */
				m = &mlist[rp[1] - '1'];
				if (m < mlist || m >= mlp)
				{
					syserr("554 5.3.5 rewrite: ruleset %s: replacement $%c out of bounds",
						rulename, rp[1]);
					return EX_CONFIG;
				}
				if (tTd(21, 15))
				{
					sm_dprintf("$%c:", rp[1]);
					pp = m->match_first;
					while (pp <= m->match_last)
					{
						sm_dprintf(" %p=\"", *pp);
						sm_dflush();
						sm_dprintf("%s\"", *pp++);
					}
					sm_dprintf("\n");
				}
				pp = m->match_first;
				while (pp <= m->match_last)
				{
					if (avp >= &npvp[maxatom])
						goto toolong;
					*avp++ = *pp++;
				}
			}
			else
			{
				/* some sort of replacement */
				if (avp >= &npvp[maxatom])
				{
	toolong:
					syserr("554 5.3.0 rewrite: expansion too long");
					if (LogLevel > 9)
						sm_syslog(LOG_ERR, e->e_id,
							"rewrite: expansion too long, ruleset=%s, ruleno=%d",
							rulename, ruleno);
					return EX_DATAERR;
				}
				if ((rp[0] & 0377) != MACRODEXPAND)
				{
					/* vanilla replacement from RHS */
					*avp++ = rp;
				}
				else
				{
					/* $&{x} replacement */
					char *mval = macvalue(rp[1], e);
					char **xpvp;
					size_t trsize = 0;
					static size_t pvpb1_size = 0;
					static char **pvpb1 = NULL;
					char pvpbuf[PSBUFSIZE];

					if (tTd(21, 2))
						sm_dprintf("rewrite: RHS $&{%s} => \"%s\"\n",
							macname(rp[1]),
							mval == NULL ? "(NULL)" : mval);
					if (mval == NULL || *mval == '\0')
						continue;

					/* save the remainder of the input */
					for (xpvp = pvp; *xpvp != NULL; xpvp++)
						trsize += sizeof(*xpvp);
					if (trsize > pvpb1_size)
					{
						if (pvpb1 != NULL)
							sm_free(pvpb1);
						pvpb1 = (char **)
							sm_pmalloc_x(trsize);
						pvpb1_size = trsize;
					}

					memmove((char *) pvpb1,
						(char *) pvp,
						trsize);

					/* scan the new replacement */
					xpvp = prescan(mval, '\0', pvpbuf,
						       sizeof(pvpbuf), NULL,
						       NULL, false);
					if (xpvp == NULL)
					{
						/* prescan pre-printed error */
						return EX_DATAERR;
					}

					/* insert it into the output stream */
					while (*xpvp != NULL)
					{
						if (tTd(21, 19))
							sm_dprintf(" ... %s\n",
								*xpvp);
						*avp++ = sm_rpool_strdup_x(
							e->e_rpool, *xpvp);
						if (avp >= &npvp[maxatom])
							goto toolong;
						xpvp++;
					}
					if (tTd(21, 19))
						sm_dprintf(" ... DONE\n");

					/* restore the old trailing input */
					memmove((char *) pvp,
						(char *) pvpb1,
						trsize);
				}
			}
		}
		*avp++ = NULL;

		/*
		**  Check for any hostname/keyword lookups.
		*/

		for (rvp = npvp; *rvp != NULL; rvp++)
		{
			char **hbrvp;
			char **xpvp;
			size_t trsize;
			char *replac;
			int endtoken;
			bool external;
			STAB *map;
			char *mapname;
			char **key_rvp;
			char **arg_rvp;
			char **default_rvp;
			char cbuf[MAXKEY];
			char *pvpb1[MAXATOM + 1];
			char *argvect[MAX_MAP_ARGS];
			char pvpbuf[PSBUFSIZE];
			char *nullpvp[1];

			hbrvp = rvp;
			if ((rvp[0][0] & 0377) == HOSTBEGIN)
			{
				endtoken = HOSTEND;
				mapname = "host";
			}
			else if ((rvp[0][0] & 0377) == LOOKUPBEGIN)
			{
				endtoken = LOOKUPEND;
				mapname = *++rvp;
				if (mapname == NULL)
				{
					syserr("554 5.3.0 rewrite: missing mapname");
					/* NOTREACHED */
					SM_ASSERT(0);
				}
			}
			else
				continue;

			/*
			**  Got a hostname/keyword lookup.
			**
			**	This could be optimized fairly easily.
			*/

			map = stab(mapname, ST_MAP, ST_FIND);
			if (map == NULL)
				syserr("554 5.3.0 rewrite: map %s not found",
					mapname);

			/* extract the match part */
			key_rvp = ++rvp;
			if (key_rvp == NULL)
			{
				syserr("554 5.3.0 rewrite: missing key for map %s",
					mapname);
				/* NOTREACHED */
				SM_ASSERT(0);
			}
			default_rvp = NULL;
			arg_rvp = argvect;
			xpvp = NULL;
			replac = pvpbuf;
			while (*rvp != NULL && ((rvp[0][0] & 0377) != endtoken))
			{
				int nodetype = rvp[0][0] & 0377;

				if (nodetype != CANONHOST &&
				    nodetype != CANONUSER)
				{
					rvp++;
					continue;
				}

				*rvp++ = NULL;

				if (xpvp != NULL)
				{
					cataddr(xpvp, NULL, replac,
						&pvpbuf[sizeof(pvpbuf)] - replac,
						'\0', false);
					if (arg_rvp <
					    &argvect[MAX_MAP_ARGS - 1])
						*++arg_rvp = replac;
					replac += strlen(replac) + 1;
					xpvp = NULL;
				}
				switch (nodetype)
				{
				  case CANONHOST:
					xpvp = rvp;
					break;

				  case CANONUSER:
					default_rvp = rvp;
					break;
				}
			}
			if (*rvp != NULL)
				*rvp++ = NULL;
			if (xpvp != NULL)
			{
				cataddr(xpvp, NULL, replac,
					&pvpbuf[sizeof(pvpbuf)] - replac,
					'\0', false);
				if (arg_rvp < &argvect[MAX_MAP_ARGS - 1])
					*++arg_rvp = replac;
			}
			if (arg_rvp >= &argvect[MAX_MAP_ARGS - 1])
				argvect[MAX_MAP_ARGS - 1] = NULL;
			else
				*++arg_rvp = NULL;

			/* save the remainder of the input string */
			trsize = (avp - rvp + 1) * sizeof(*rvp);
			memmove((char *) pvpb1, (char *) rvp, trsize);

			/* look it up */
			cataddr(key_rvp, NULL, cbuf, sizeof(cbuf),
				map == NULL ? '\0' : map->s_map.map_spacesub,
				true);
			argvect[0] = cbuf;
			replac = map_lookup(map, cbuf, argvect, &rstat, e);
			external = replac != NULL;

			/* if no replacement, use default */
			if (replac == NULL && default_rvp != NULL)
			{
				/* create the default */
				cataddr(default_rvp, NULL, cbuf, sizeof(cbuf),
					'\0', false);
				replac = cbuf;
			}

			if (replac == NULL)
			{
				xpvp = key_rvp;
			}
			else if (*replac == '\0')
			{
				/* null replacement */
				nullpvp[0] = NULL;
				xpvp = nullpvp;
			}
			else
			{
				/* scan the new replacement */
				xpvp = prescan(replac, '\0', pvpbuf,
					       sizeof(pvpbuf), NULL,
					       external ? NULL : IntTokenTab,
					       false);
				if (xpvp == NULL)
				{
					/* prescan already printed error */
					return EX_DATAERR;
				}
			}

			/* append it to the token list */
			for (avp = hbrvp; *xpvp != NULL; xpvp++)
			{
				*avp++ = sm_rpool_strdup_x(e->e_rpool, *xpvp);
				if (avp >= &npvp[maxatom])
					goto toolong;
			}

			/* restore the old trailing information */
			rvp = avp - 1;
			for (xpvp = pvpb1; (*avp++ = *xpvp++) != NULL; )
				if (avp >= &npvp[maxatom])
					goto toolong;
		}

		/*
		**  Check for subroutine calls.
		*/

		status = callsubr(npvp, reclevel, e);
		if (rstat == EX_OK || status == EX_TEMPFAIL)
			rstat = status;

		/* copy vector back into original space. */
		for (avp = npvp; *avp++ != NULL;)
			continue;
		memmove((char *) pvp, (char *) npvp,
		      (int) (avp - npvp) * sizeof(*avp));

		if (tTd(21, 4))
		{
			sm_dprintf("rewritten as:");
			printav(sm_debug_file(), pvp);
		}
	}

	if (OpMode == MD_TEST)
	{
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "%s%-16.16s returns:", prefix, rulename);
		printav(smioout, pvp);
	}
	else if (tTd(21, 1))
	{
		sm_dprintf("%s%-16.16s returns:", prefix, rulename);
		printav(sm_debug_file(), pvp);
	}
	return rstat;
}
/*
**  CALLSUBR -- call subroutines in rewrite vector
**
**	Parameters:
**		pvp -- pointer to token vector.
**		reclevel -- the current recursion level.
**		e -- the current envelope.
**
**	Returns:
**		The status from the subroutine call.
**
**	Side Effects:
**		pvp is modified.
*/

static int
callsubr(pvp, reclevel, e)
	char **pvp;
	int reclevel;
	ENVELOPE *e;
{
	char **avp;
	register int i;
	int subr, j;
	int nsubr;
	int status;
	int rstat = EX_OK;
#define MAX_SUBR	16
	int subrnumber[MAX_SUBR];
	int subrindex[MAX_SUBR];

	nsubr = 0;

	/*
	**  Look for subroutine calls in pvp, collect them into subr*[]
	**  We will perform the calls in the next loop, because we will
	**  call the "last" subroutine first to avoid recursive calls
	**  and too much copying.
	*/

	for (avp = pvp, j = 0; *avp != NULL; avp++, j++)
	{
		if ((avp[0][0] & 0377) == CALLSUBR && avp[1] != NULL)
		{
			stripquotes(avp[1]);
			subr = strtorwset(avp[1], NULL, ST_FIND);
			if (subr < 0)
			{
				syserr("554 5.3.5 Unknown ruleset %s", avp[1]);
				return EX_CONFIG;
			}

			/*
			**  XXX instead of doing this we could optimize
			**  the rules after reading them: just remove
			**  calls to empty rulesets
			*/

			/* subroutine is an empty ruleset?  don't call it */
			if (RewriteRules[subr] == NULL)
			{
				if (tTd(21, 3))
					sm_dprintf("-----skip subr %s (%d)\n",
						avp[1], subr);
				for (i = 2; avp[i] != NULL; i++)
					avp[i - 2] = avp[i];
				avp[i - 2] = NULL;
				continue;
			}
			if (++nsubr >= MAX_SUBR)
			{
				syserr("554 5.3.0 Too many subroutine calls (%d max)",
					MAX_SUBR);
				return EX_CONFIG;
			}
			subrnumber[nsubr] = subr;
			subrindex[nsubr] = j;
		}
	}

	/*
	**  Perform the actual subroutines calls, "last" one first, i.e.,
	**  go from the right to the left through all calls,
	**  do the rewriting in place.
	*/

	for (; nsubr > 0; nsubr--)
	{
		subr = subrnumber[nsubr];
		avp = pvp + subrindex[nsubr];

		/* remove the subroutine call and name */
		for (i = 2; avp[i] != NULL; i++)
			avp[i - 2] = avp[i];
		avp[i - 2] = NULL;

		/*
		**  Now we need to call the ruleset specified for
		**  the subroutine. We can do this in place since
		**  we call the "last" subroutine first.
		*/

		status = rewrite(avp, subr, reclevel, e,
				MAXATOM - subrindex[nsubr]);
		if (status != EX_OK && status != EX_TEMPFAIL)
			return status;
		if (rstat == EX_OK || status == EX_TEMPFAIL)
			rstat = status;
	}
	return rstat;
}
/*
**  MAP_LOOKUP -- do lookup in map
**
**	Parameters:
**		smap -- the map to use for the lookup.
**		key -- the key to look up.
**		argvect -- arguments to pass to the map lookup.
**		pstat -- a pointer to an integer in which to store the
**			status from the lookup.
**		e -- the current envelope.
**
**	Returns:
**		The result of the lookup.
**		NULL -- if there was no data for the given key.
*/

static char *
map_lookup(smap, key, argvect, pstat, e)
	STAB *smap;
	char key[];
	char **argvect;
	int *pstat;
	ENVELOPE *e;
{
	auto int status = EX_OK;
	MAP *map;
	char *replac;

	if (smap == NULL)
		return NULL;

	map = &smap->s_map;
	DYNOPENMAP(map);

	if (e->e_sendmode == SM_DEFER &&
	    bitset(MF_DEFER, map->map_mflags))
	{
		/* don't do any map lookups */
		if (tTd(60, 1))
			sm_dprintf("map_lookup(%s, %s) => DEFERRED\n",
				smap->s_name, key);
		*pstat = EX_TEMPFAIL;
		return NULL;
	}

	if (!bitset(MF_KEEPQUOTES, map->map_mflags))
		stripquotes(key);

	if (tTd(60, 1))
	{
		sm_dprintf("map_lookup(%s, ", smap->s_name);
		xputs(sm_debug_file(), key);
		if (tTd(60, 5))
		{
			int i;

			for (i = 0; argvect[i] != NULL; i++)
				sm_dprintf(", %%%d=%s", i, argvect[i]);
		}
		sm_dprintf(") => ");
	}
	replac = (*map->map_class->map_lookup)(map, key, argvect, &status);
	if (tTd(60, 1))
		sm_dprintf("%s (%d)\n",
			replac != NULL ? replac : "NOT FOUND",
			status);

	/* should recover if status == EX_TEMPFAIL */
	if (status == EX_TEMPFAIL && !bitset(MF_NODEFER, map->map_mflags))
	{
		*pstat = EX_TEMPFAIL;
		if (tTd(60, 1))
			sm_dprintf("map_lookup(%s, %s) tempfail: errno=%d\n",
				smap->s_name, key, errno);
		if (e->e_message == NULL)
		{
			char mbuf[320];

			(void) sm_snprintf(mbuf, sizeof(mbuf),
				"%.80s map: lookup (%s): deferred",
				smap->s_name,
				shortenstring(key, MAXSHORTSTR));
			e->e_message = sm_rpool_strdup_x(e->e_rpool, mbuf);
		}
	}
	if (status == EX_TEMPFAIL && map->map_tapp != NULL)
	{
		size_t i = strlen(key) + strlen(map->map_tapp) + 1;
		static char *rwbuf = NULL;
		static size_t rwbuflen = 0;

		if (i > rwbuflen)
		{
			if (rwbuf != NULL)
				sm_free(rwbuf);
			rwbuflen = i;
			rwbuf = (char *) sm_pmalloc_x(rwbuflen);
		}
		(void) sm_strlcpyn(rwbuf, rwbuflen, 2, key, map->map_tapp);
		if (tTd(60, 4))
			sm_dprintf("map_lookup tempfail: returning \"%s\"\n",
				rwbuf);
		return rwbuf;
	}
	return replac;
}
/*
**  INITERRMAILERS -- initialize error and discard mailers
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		initializes error and discard mailers.
*/

static MAILER discardmailer;
static MAILER errormailer;
static char *discardargv[] = { "DISCARD", NULL };
static char *errorargv[] = { "ERROR", NULL };

void
initerrmailers()
{
	if (discardmailer.m_name == NULL)
	{
		/* initialize the discard mailer */
		discardmailer.m_name = "*discard*";
		discardmailer.m_mailer = "DISCARD";
		discardmailer.m_argv = discardargv;
	}
	if (errormailer.m_name == NULL)
	{
		/* initialize the bogus mailer */
		errormailer.m_name = "*error*";
		errormailer.m_mailer = "ERROR";
		errormailer.m_argv = errorargv;
	}
}
/*
**  BUILDADDR -- build address from token vector.
**
**	Parameters:
**		tv -- token vector.
**		a -- pointer to address descriptor to fill.
**			If NULL, one will be allocated.
**		flags -- info regarding whether this is a sender or
**			a recipient.
**		e -- the current envelope.
**
**	Returns:
**		NULL if there was an error.
**		'a' otherwise.
**
**	Side Effects:
**		fills in 'a'
*/

static struct errcodes
{
	char	*ec_name;		/* name of error code */
	int	ec_code;		/* numeric code */
} ErrorCodes[] =
{
	{ "usage",		EX_USAGE	},
	{ "nouser",		EX_NOUSER	},
	{ "nohost",		EX_NOHOST	},
	{ "unavailable",	EX_UNAVAILABLE	},
	{ "software",		EX_SOFTWARE	},
	{ "tempfail",		EX_TEMPFAIL	},
	{ "protocol",		EX_PROTOCOL	},
	{ "config",		EX_CONFIG	},
	{ NULL,			EX_UNAVAILABLE	}
};

static ADDRESS *
buildaddr(tv, a, flags, e)
	register char **tv;
	register ADDRESS *a;
	int flags;
	register ENVELOPE *e;
{
	bool tempfail = false;
	int maxatom;
	struct mailer **mp;
	register struct mailer *m;
	register char *p;
	char *mname;
	char **hostp;
	char hbuf[MAXNAME + 1];
	static char ubuf[MAXNAME + 2];

	if (tTd(24, 5))
	{
		sm_dprintf("buildaddr, flags=%x, tv=", flags);
		printav(sm_debug_file(), tv);
	}

	maxatom = MAXATOM;
	if (a == NULL)
		a = (ADDRESS *) sm_rpool_malloc_x(e->e_rpool, sizeof(*a));
	memset((char *) a, '\0', sizeof(*a));
	hbuf[0] = '\0';

	/* set up default error return flags */
	a->q_flags |= DefaultNotify;

	/* figure out what net/mailer to use */
	if (*tv == NULL || (**tv & 0377) != CANONNET)
	{
		syserr("554 5.3.5 buildaddr: no mailer in parsed address");
badaddr:
		/*
		**  ExitStat may have been set by an earlier map open
		**  failure (to a permanent error (EX_OSERR) in syserr())
		**  so we also need to check if this particular $#error
		**  return wanted a 4XX failure.
		**
		**  XXX the real fix is probably to set ExitStat correctly,
		**  i.e., to EX_TEMPFAIL if the map open is just a temporary
		**  error.
		*/

		if (ExitStat == EX_TEMPFAIL || tempfail)
			a->q_state = QS_QUEUEUP;
		else
		{
			a->q_state = QS_BADADDR;
			a->q_mailer = &errormailer;
		}
		return a;
	}
	mname = *++tv;
	--maxatom;

	/* extract host and user portions */
	if (*++tv != NULL && (**tv & 0377) == CANONHOST)
	{
		hostp = ++tv;
		--maxatom;
	}
	else
		hostp = NULL;
	--maxatom;
	while (*tv != NULL && (**tv & 0377) != CANONUSER)
	{
		tv++;
		--maxatom;
	}
	if (*tv == NULL)
	{
		syserr("554 5.3.5 buildaddr: no user");
		goto badaddr;
	}
	if (tv == hostp)
		hostp = NULL;
	else if (hostp != NULL)
		cataddr(hostp, tv - 1, hbuf, sizeof(hbuf), '\0', false);
	cataddr(++tv, NULL, ubuf, sizeof(ubuf), ' ', false);
	--maxatom;

	/* save away the host name */
	if (sm_strcasecmp(mname, "error") == 0)
	{
		/* Set up triplet for use by -bv */
		a->q_mailer = &errormailer;
		a->q_user = sm_rpool_strdup_x(e->e_rpool, ubuf);
		/* XXX wrong place? */

		if (hostp != NULL)
		{
			register struct errcodes *ep;

			a->q_host = sm_rpool_strdup_x(e->e_rpool, hbuf);
			if (strchr(hbuf, '.') != NULL)
			{
				a->q_status = sm_rpool_strdup_x(e->e_rpool,
								hbuf);
				setstat(dsntoexitstat(hbuf));
			}
			else if (isascii(hbuf[0]) && isdigit(hbuf[0]))
			{
				setstat(atoi(hbuf));
			}
			else
			{
				for (ep = ErrorCodes; ep->ec_name != NULL; ep++)
					if (sm_strcasecmp(ep->ec_name, hbuf) == 0)
						break;
				setstat(ep->ec_code);
			}
		}
		else
		{
			a->q_host = NULL;
			setstat(EX_UNAVAILABLE);
		}
		stripquotes(ubuf);
		if (ISSMTPCODE(ubuf) && ubuf[3] == ' ')
		{
			char fmt[16];
			int off;

			if ((off = isenhsc(ubuf + 4, ' ')) > 0)
			{
				ubuf[off + 4] = '\0';
				off += 5;
			}
			else
			{
				off = 4;
				ubuf[3] = '\0';
			}
			(void) sm_strlcpyn(fmt, sizeof(fmt), 2, ubuf, " %s");
			if (off > 4)
				usrerr(fmt, ubuf + off);
			else if (isenhsc(hbuf, '\0') > 0)
				usrerrenh(hbuf, fmt, ubuf + off);
			else
				usrerr(fmt, ubuf + off);
			/* XXX ubuf[off - 1] = ' '; */
			if (ubuf[0] == '4')
				tempfail = true;
		}
		else
		{
			usrerr("553 5.3.0 %s", ubuf);
		}
		goto badaddr;
	}

	for (mp = Mailer; (m = *mp++) != NULL; )
	{
		if (sm_strcasecmp(m->m_name, mname) == 0)
			break;
	}
	if (m == NULL)
	{
		syserr("554 5.3.5 buildaddr: unknown mailer %s", mname);
		goto badaddr;
	}
	a->q_mailer = m;

	/* figure out what host (if any) */
	if (hostp == NULL)
	{
		if (!bitnset(M_LOCALMAILER, m->m_flags))
		{
			syserr("554 5.3.5 buildaddr: no host");
			goto badaddr;
		}
		a->q_host = NULL;
	}
	else
		a->q_host = sm_rpool_strdup_x(e->e_rpool, hbuf);

	/* figure out the user */
	p = ubuf;
	if (bitnset(M_CHECKUDB, m->m_flags) && *p == '@@')
	{
		p++;
		tv++;
		--maxatom;
		a->q_flags |= QNOTREMOTE;
	}

	/* do special mapping for local mailer */
	if (*p == '"')
		p++;
	if (*p == '|' && bitnset(M_CHECKPROG, m->m_flags))
		a->q_mailer = m = ProgMailer;
	else if (*p == '/' && bitnset(M_CHECKFILE, m->m_flags))
		a->q_mailer = m = FileMailer;
	else if (*p == ':' && bitnset(M_CHECKINCLUDE, m->m_flags))
	{
		/* may be :include: */
		stripquotes(ubuf);
		if (sm_strncasecmp(ubuf, ":include:", 9) == 0)
		{
			/* if :include:, don't need further rewriting */
			a->q_mailer = m = InclMailer;
			a->q_user = sm_rpool_strdup_x(e->e_rpool, &ubuf[9]);
			return a;
		}
	}

	/* rewrite according recipient mailer rewriting rules */
	macdefine(&e->e_macro, A_PERM, 'h', a->q_host);

	if (ConfigLevel >= 10 ||
	    !bitset(RF_SENDERADDR|RF_HEADERADDR, flags))
	{
		/* sender addresses done later */
		(void) rewrite(tv, 2, 0, e, maxatom);
		if (m->m_re_rwset > 0)
		       (void) rewrite(tv, m->m_re_rwset, 0, e, maxatom);
	}
	(void) rewrite(tv, 4, 0, e, maxatom);

	/* save the result for the command line/RCPT argument */
	cataddr(tv, NULL, ubuf, sizeof(ubuf), '\0', true);
	a->q_user = sm_rpool_strdup_x(e->e_rpool, ubuf);

	/*
	**  Do mapping to lower case as requested by mailer
	*/

	if (a->q_host != NULL && !bitnset(M_HST_UPPER, m->m_flags))
		makelower(a->q_host);
	if (!bitnset(M_USR_UPPER, m->m_flags))
		makelower(a->q_user);

	if (tTd(24, 6))
	{
		sm_dprintf("buildaddr => ");
		printaddr(sm_debug_file(), a, false);
	}
	return a;
}

/*
**  CATADDR -- concatenate pieces of addresses (putting in <LWSP> subs)
**
**	Parameters:
**		pvp -- parameter vector to rebuild.
**		evp -- last parameter to include.  Can be NULL to
**			use entire pvp.
**		buf -- buffer to build the string into.
**		sz -- size of buf.
**		spacesub -- the space separator character; if '\0',
**			use SpaceSub.
**		external -- convert to external form?
**			(no metacharacters; METAQUOTEs removed, see below)
**
**	Returns:
**		none.
**
**	Side Effects:
**		Destroys buf.
**
**	Notes:
**	There are two formats for strings: internal and external.
**	The external format is just an eight-bit clean string (no
**	null bytes, everything else OK).  The internal format can
**	include sendmail metacharacters.  The special character
**	METAQUOTE essentially quotes the character following, stripping
**	it of all special semantics.
**
**	The cataddr routine needs to be aware of whether it is producing
**	an internal or external form as output (it only takes internal
**	form as input).
**
**	The parseaddr routine has a similar issue on input, but that
**	is flagged on the basis of which token table is passed in.
*/

void
cataddr(pvp, evp, buf, sz, spacesub, external)
	char **pvp;
	char **evp;
	char *buf;
	register int sz;
	int spacesub;
	bool external;
{
	bool oatomtok, natomtok;
	char *p;

	oatomtok = natomtok = false;
	if (tTd(59, 14))
	{
		sm_dprintf("cataddr(%d) <==", external);
		printav(sm_debug_file(), pvp);
	}

	if (sz <= 0)
		return;

	if (spacesub == '\0')
		spacesub = SpaceSub;

	if (pvp == NULL)
	{
		*buf = '\0';
		return;
	}
	p = buf;
	sz -= 2;
	while (*pvp != NULL && sz > 0)
	{
		char *q;

		natomtok = (IntTokenTab[**pvp & 0xff] == ATM);
		if (oatomtok && natomtok)
		{
			*p++ = spacesub;
			if (--sz <= 0)
				break;
		}
		for (q = *pvp; *q != '\0'; )
		{
			int c;

			if (--sz <= 0)
				break;
			*p++ = c = *q++;

			/*
			**  If the current character (c) is METAQUOTE and we
			**  want the "external" form and the next character
			**  is not NUL, then overwrite METAQUOTE with that
			**  character (i.e., METAQUOTE ch is changed to
			**  ch).  p[-1] is used because p is advanced (above).
			*/

			if ((c & 0377) == METAQUOTE && external && *q != '\0')
				p[-1] = *q++;
		}
		if (sz <= 0)
			break;
		oatomtok = natomtok;
		if (pvp++ == evp)
			break;
	}

#if 0
	/*
	**  Silently truncate long strings: even though this doesn't
	**  seem like a good idea it is necessary because header checks
	**  send the whole header value to rscheck() and hence rewrite().
	**  The latter however sometimes uses a "short" buffer (e.g.,
	**  cbuf[MAXNAME + 1]) to call cataddr() which then triggers this
	**  error function.  One possible fix to the problem is to pass
	**  flags to rscheck() and rewrite() to distinguish the various
	**  calls and only trigger the error if necessary.  For now just
	**  undo the change from 8.13.0.
	*/

	if (sz <= 0)
		usrerr("cataddr: string too long");
#endif
	*p = '\0';

	if (tTd(59, 14))
		sm_dprintf("  cataddr => %s\n", str2prt(buf));
}

/*
**  SAMEADDR -- Determine if two addresses are the same
**
**	This is not just a straight comparison -- if the mailer doesn't
**	care about the host we just ignore it, etc.
**
**	Parameters:
**		a, b -- pointers to the internal forms to compare.
**
**	Returns:
**		true -- they represent the same mailbox.
**		false -- they don't.
**
**	Side Effects:
**		none.
*/

bool
sameaddr(a, b)
	register ADDRESS *a;
	register ADDRESS *b;
{
	register ADDRESS *ca, *cb;

	/* if they don't have the same mailer, forget it */
	if (a->q_mailer != b->q_mailer)
		return false;

	/*
	**  Addresses resolving to error mailer
	**  should not be considered identical
	*/

	if (a->q_mailer == &errormailer)
		return false;

	/* if the user isn't the same, we can drop out */
	if (strcmp(a->q_user, b->q_user) != 0)
		return false;

	/* if we have good uids for both but they differ, these are different */
	if (a->q_mailer == ProgMailer)
	{
		ca = getctladdr(a);
		cb = getctladdr(b);
		if (ca != NULL && cb != NULL &&
		    bitset(QGOODUID, ca->q_flags & cb->q_flags) &&
		    ca->q_uid != cb->q_uid)
			return false;
	}

	/* otherwise compare hosts (but be careful for NULL ptrs) */
	if (a->q_host == b->q_host)
	{
		/* probably both null pointers */
		return true;
	}
	if (a->q_host == NULL || b->q_host == NULL)
	{
		/* only one is a null pointer */
		return false;
	}
	if (strcmp(a->q_host, b->q_host) != 0)
		return false;

	return true;
}
/*
**  PRINTADDR -- print address (for debugging)
**
**	Parameters:
**		a -- the address to print
**		follow -- follow the q_next chain.
**
**	Returns:
**		none.
**
**	Side Effects:
**		none.
*/

struct qflags
{
	char		*qf_name;
	unsigned long	qf_bit;
};

static struct qflags	AddressFlags[] =
{
	{ "QGOODUID",		QGOODUID	},
	{ "QPRIMARY",		QPRIMARY	},
	{ "QNOTREMOTE",		QNOTREMOTE	},
	{ "QSELFREF",		QSELFREF	},
	{ "QBOGUSSHELL",	QBOGUSSHELL	},
	{ "QUNSAFEADDR",	QUNSAFEADDR	},
	{ "QPINGONSUCCESS",	QPINGONSUCCESS	},
	{ "QPINGONFAILURE",	QPINGONFAILURE	},
	{ "QPINGONDELAY",	QPINGONDELAY	},
	{ "QHASNOTIFY",		QHASNOTIFY	},
	{ "QRELAYED",		QRELAYED	},
	{ "QEXPANDED",		QEXPANDED	},
	{ "QDELIVERED",		QDELIVERED	},
	{ "QDELAYED",		QDELAYED	},
	{ "QTHISPASS",		QTHISPASS	},
	{ "QRCPTOK",		QRCPTOK		},
	{ NULL,			0		}
};

void
printaddr(fp, a, follow)
	SM_FILE_T *fp;
	register ADDRESS *a;
	bool follow;
{
	register MAILER *m;
	MAILER pseudomailer;
	register struct qflags *qfp;
	bool firstone;

	if (a == NULL)
	{
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "[NULL]\n");
		return;
	}

	while (a != NULL)
	{
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "%p=", a);
		(void) sm_io_flush(fp, SM_TIME_DEFAULT);

		/* find the mailer -- carefully */
		m = a->q_mailer;
		if (m == NULL)
		{
			m = &pseudomailer;
			m->m_mno = -1;
			m->m_name = "NULL";
		}

		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
				     "%s:\n\tmailer %d (%s), host `%s'\n",
				     a->q_paddr == NULL ? "<null>" : a->q_paddr,
				     m->m_mno, m->m_name,
				     a->q_host == NULL ? "<null>" : a->q_host);
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
				     "\tuser `%s', ruser `%s'\n",
				     a->q_user,
				     a->q_ruser == NULL ? "<null>" : a->q_ruser);
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "\tstate=");
		switch (a->q_state)
		{
		  case QS_OK:
			(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "OK");
			break;

		  case QS_DONTSEND:
			(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
					     "DONTSEND");
			break;

		  case QS_BADADDR:
			(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
					     "BADADDR");
			break;

		  case QS_QUEUEUP:
			(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
					     "QUEUEUP");
			break;

		  case QS_RETRY:
			(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "RETRY");
			break;

		  case QS_SENT:
			(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "SENT");
			break;

		  case QS_VERIFIED:
			(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
					     "VERIFIED");
			break;

		  case QS_EXPANDED:
			(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
					     "EXPANDED");
			break;

		  case QS_SENDER:
			(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
					     "SENDER");
			break;

		  case QS_CLONED:
			(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
					     "CLONED");
			break;

		  case QS_DISCARDED:
			(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
					     "DISCARDED");
			break;

		  case QS_REPLACED:
			(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
					     "REPLACED");
			break;

		  case QS_REMOVED:
			(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
					     "REMOVED");
			break;

		  case QS_DUPLICATE:
			(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
					     "DUPLICATE");
			break;

		  case QS_INCLUDED:
			(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
					     "INCLUDED");
			break;

		  default:
			(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
					     "%d", a->q_state);
			break;
		}
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
				     ", next=%p, alias %p, uid %d, gid %d\n",
				     a->q_next, a->q_alias,
				     (int) a->q_uid, (int) a->q_gid);
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "\tflags=%lx<",
				     a->q_flags);
		firstone = true;
		for (qfp = AddressFlags; qfp->qf_name != NULL; qfp++)
		{
			if (!bitset(qfp->qf_bit, a->q_flags))
				continue;
			if (!firstone)
				(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
						     ",");
			firstone = false;
			(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "%s",
					     qfp->qf_name);
		}
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, ">\n");
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
				     "\towner=%s, home=\"%s\", fullname=\"%s\"\n",
				     a->q_owner == NULL ? "(none)" : a->q_owner,
				     a->q_home == NULL ? "(none)" : a->q_home,
				     a->q_fullname == NULL ? "(none)" : a->q_fullname);
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
				     "\torcpt=\"%s\", statmta=%s, status=%s\n",
				     a->q_orcpt == NULL ? "(none)" : a->q_orcpt,
				     a->q_statmta == NULL ? "(none)" : a->q_statmta,
				     a->q_status == NULL ? "(none)" : a->q_status);
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
				     "\tfinalrcpt=\"%s\"\n",
				     a->q_finalrcpt == NULL ? "(none)" : a->q_finalrcpt);
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
				     "\trstatus=\"%s\"\n",
				     a->q_rstatus == NULL ? "(none)" : a->q_rstatus);
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
				     "\tstatdate=%s\n",
				     a->q_statdate == 0 ? "(none)" : ctime(&a->q_statdate));

		if (!follow)
			return;
		a = a->q_next;
	}
}
/*
**  EMPTYADDR -- return true if this address is empty (``<>'')
**
**	Parameters:
**		a -- pointer to the address
**
**	Returns:
**		true -- if this address is "empty" (i.e., no one should
**			ever generate replies to it.
**		false -- if it is a "regular" (read: replyable) address.
*/

bool
emptyaddr(a)
	register ADDRESS *a;
{
	return a->q_paddr == NULL || strcmp(a->q_paddr, "<>") == 0 ||
	       a->q_user == NULL || strcmp(a->q_user, "<>") == 0;
}
/*
**  REMOTENAME -- return the name relative to the current mailer
**
**	Parameters:
**		name -- the name to translate.
**		m -- the mailer that we want to do rewriting relative to.
**		flags -- fine tune operations.
**		pstat -- pointer to status word.
**		e -- the current envelope.
**
**	Returns:
**		the text string representing this address relative to
**			the receiving mailer.
**
**	Side Effects:
**		none.
**
**	Warnings:
**		The text string returned is tucked away locally;
**			copy it if you intend to save it.
*/

char *
remotename(name, m, flags, pstat, e)
	char *name;
	struct mailer *m;
	int flags;
	int *pstat;
	register ENVELOPE *e;
{
	register char **pvp;
	char *SM_NONVOLATILE fancy;
	char *oldg;
	int rwset;
	static char buf[MAXNAME + 1];
	char lbuf[MAXNAME + 1];
	char pvpbuf[PSBUFSIZE];
	char addrtype[4];

	if (tTd(12, 1))
	{
		sm_dprintf("remotename(");
		xputs(sm_debug_file(), name);
		sm_dprintf(")\n");
	}

	/* don't do anything if we are tagging it as special */
	if (bitset(RF_SENDERADDR, flags))
	{
		rwset = bitset(RF_HEADERADDR, flags) ? m->m_sh_rwset
						     : m->m_se_rwset;
		addrtype[2] = 's';
	}
	else
	{
		rwset = bitset(RF_HEADERADDR, flags) ? m->m_rh_rwset
						     : m->m_re_rwset;
		addrtype[2] = 'r';
	}
	if (rwset < 0)
		return name;
	addrtype[1] = ' ';
	addrtype[3] = '\0';
	addrtype[0] = bitset(RF_HEADERADDR, flags) ? 'h' : 'e';
	macdefine(&e->e_macro, A_TEMP, macid("{addr_type}"), addrtype);

	/*
	**  Do a heuristic crack of this name to extract any comment info.
	**	This will leave the name as a comment and a $g macro.
	*/

	if (bitset(RF_CANONICAL, flags) || bitnset(M_NOCOMMENT, m->m_flags))
		fancy = "\201g";
	else
		fancy = crackaddr(name, e);

	/*
	**  Turn the name into canonical form.
	**	Normally this will be RFC 822 style, i.e., "user@@domain".
	**	If this only resolves to "user", and the "C" flag is
	**	specified in the sending mailer, then the sender's
	**	domain will be appended.
	*/

	pvp = prescan(name, '\0', pvpbuf, sizeof(pvpbuf), NULL, NULL, false);
	if (pvp == NULL)
		return name;
	if (REWRITE(pvp, 3, e) == EX_TEMPFAIL)
		*pstat = EX_TEMPFAIL;
	if (bitset(RF_ADDDOMAIN, flags) && e->e_fromdomain != NULL)
	{
		/* append from domain to this address */
		register char **pxp = pvp;
		int l = MAXATOM;	/* size of buffer for pvp */

		/* see if there is an "@@domain" in the current name */
		while (*pxp != NULL && strcmp(*pxp, "@@") != 0)
		{
			pxp++;
			--l;
		}
		if (*pxp == NULL)
		{
			/* no.... append the "@@domain" from the sender */
			register char **qxq = e->e_fromdomain;

			while ((*pxp++ = *qxq++) != NULL)
			{
				if (--l <= 0)
				{
					*--pxp = NULL;
					usrerr("553 5.1.0 remotename: too many tokens");
					*pstat = EX_UNAVAILABLE;
					break;
				}
			}
			if (REWRITE(pvp, 3, e) == EX_TEMPFAIL)
				*pstat = EX_TEMPFAIL;
		}
	}

	/*
	**  Do more specific rewriting.
	**	Rewrite using ruleset 1 or 2 depending on whether this is
	**		a sender address or not.
	**	Then run it through any receiving-mailer-specific rulesets.
	*/

	if (bitset(RF_SENDERADDR, flags))
	{
		if (REWRITE(pvp, 1, e) == EX_TEMPFAIL)
			*pstat = EX_TEMPFAIL;
	}
	else
	{
		if (REWRITE(pvp, 2, e) == EX_TEMPFAIL)
			*pstat = EX_TEMPFAIL;
	}
	if (rwset > 0)
	{
		if (REWRITE(pvp, rwset, e) == EX_TEMPFAIL)
			*pstat = EX_TEMPFAIL;
	}

	/*
	**  Do any final sanitation the address may require.
	**	This will normally be used to turn internal forms
	**	(e.g., user@@host.LOCAL) into external form.  This
	**	may be used as a default to the above rules.
	*/

	if (REWRITE(pvp, 4, e) == EX_TEMPFAIL)
		*pstat = EX_TEMPFAIL;

	/*
	**  Now restore the comment information we had at the beginning.
	*/

	cataddr(pvp, NULL, lbuf, sizeof(lbuf), '\0', false);
	oldg = macget(&e->e_macro, 'g');
	macset(&e->e_macro, 'g', lbuf);

	SM_TRY
		/* need to make sure route-addrs have <angle brackets> */
		if (bitset(RF_CANONICAL, flags) && lbuf[0] == '@@')
			expand("<\201g>", buf, sizeof(buf), e);
		else
			expand(fancy, buf, sizeof(buf), e);
	SM_FINALLY
		macset(&e->e_macro, 'g', oldg);
	SM_END_TRY

	if (tTd(12, 1))
	{
		sm_dprintf("remotename => `");
		xputs(sm_debug_file(), buf);
		sm_dprintf("'\n");
	}
	return buf;
}
/*
**  MAPLOCALUSER -- run local username through ruleset 5 for final redirection
**
**	Parameters:
**		a -- the address to map (but just the user name part).
**		sendq -- the sendq in which to install any replacement
**			addresses.
**		aliaslevel -- the alias nesting depth.
**		e -- the envelope.
**
**	Returns:
**		none.
*/

#define Q_COPYFLAGS	(QPRIMARY|QBOGUSSHELL|QUNSAFEADDR|\
			 Q_PINGFLAGS|QHASNOTIFY|\
			 QRELAYED|QEXPANDED|QDELIVERED|QDELAYED|\
			 QBYTRACE|QBYNDELAY|QBYNRELAY)

void
maplocaluser(a, sendq, aliaslevel, e)
	register ADDRESS *a;
	ADDRESS **sendq;
	int aliaslevel;
	ENVELOPE *e;
{
	register char **pvp;
	register ADDRESS *SM_NONVOLATILE a1 = NULL;
	char pvpbuf[PSBUFSIZE];

	if (tTd(29, 1))
	{
		sm_dprintf("maplocaluser: ");
		printaddr(sm_debug_file(), a, false);
	}
	pvp = prescan(a->q_user, '\0', pvpbuf, sizeof(pvpbuf), NULL, NULL,
			false);
	if (pvp == NULL)
	{
		if (tTd(29, 9))
			sm_dprintf("maplocaluser: cannot prescan %s\n",
				a->q_user);
		return;
	}

	macdefine(&e->e_macro, A_PERM, 'h', a->q_host);
	macdefine(&e->e_macro, A_PERM, 'u', a->q_user);
	macdefine(&e->e_macro, A_PERM, 'z', a->q_home);

	macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), "e r");
	if (REWRITE(pvp, 5, e) == EX_TEMPFAIL)
	{
		if (tTd(29, 9))
			sm_dprintf("maplocaluser: rewrite tempfail\n");
		a->q_state = QS_QUEUEUP;
		a->q_status = "4.4.3";
		return;
	}
	if (pvp[0] == NULL || (pvp[0][0] & 0377) != CANONNET)
	{
		if (tTd(29, 9))
			sm_dprintf("maplocaluser: doesn't resolve\n");
		return;
	}

	SM_TRY
		a1 = buildaddr(pvp, NULL, 0, e);
	SM_EXCEPT(exc, "E:mta.quickabort")

		/*
		**  mark address as bad, S5 returned an error
		**	and we gave that back to the SMTP client.
		*/

		a->q_state = QS_DONTSEND;
		sm_exc_raisenew_x(&EtypeQuickAbort, 2);
	SM_END_TRY

	/* if non-null, mailer destination specified -- has it changed? */
	if (a1 == NULL || sameaddr(a, a1))
	{
		if (tTd(29, 9))
			sm_dprintf("maplocaluser: address unchanged\n");
		return;
	}

	/* make new address take on flags and print attributes of old */
	a1->q_flags &= ~Q_COPYFLAGS;
	a1->q_flags |= a->q_flags & Q_COPYFLAGS;
	a1->q_paddr = sm_rpool_strdup_x(e->e_rpool, a->q_paddr);
	a1->q_finalrcpt = a->q_finalrcpt;
	a1->q_orcpt = a->q_orcpt;

	/* mark old address as dead; insert new address */
	a->q_state = QS_REPLACED;
	if (tTd(29, 5))
	{
		sm_dprintf("maplocaluser: QS_REPLACED ");
		printaddr(sm_debug_file(), a, false);
	}
	a1->q_alias = a;
	allocaddr(a1, RF_COPYALL, sm_rpool_strdup_x(e->e_rpool, a->q_paddr), e);
	(void) recipient(a1, sendq, aliaslevel, e);
}
/*
**  DEQUOTE_INIT -- initialize dequote map
**
**	Parameters:
**		map -- the internal map structure.
**		args -- arguments.
**
**	Returns:
**		true.
*/

bool
dequote_init(map, args)
	MAP *map;
	char *args;
{
	register char *p = args;

	/* there is no check whether there is really an argument */
	map->map_mflags |= MF_KEEPQUOTES;
	for (;;)
	{
		while (isascii(*p) && isspace(*p))
			p++;
		if (*p != '-')
			break;
		switch (*++p)
		{
		  case 'a':
			map->map_app = ++p;
			break;

		  case 'D':
			map->map_mflags |= MF_DEFER;
			break;

		  case 'S':
		  case 's':
			map->map_spacesub = *++p;
			break;
		}
		while (*p != '\0' && !(isascii(*p) && isspace(*p)))
			p++;
		if (*p != '\0')
			*p = '\0';
	}
	if (map->map_app != NULL)
		map->map_app = newstr(map->map_app);

	return true;
}
/*
**  DEQUOTE_MAP -- unquote an address
**
**	Parameters:
**		map -- the internal map structure (ignored).
**		name -- the name to dequote.
**		av -- arguments (ignored).
**		statp -- pointer to status out-parameter.
**
**	Returns:
**		NULL -- if there were no quotes, or if the resulting
**			unquoted buffer would not be acceptable to prescan.
**		else -- The dequoted buffer.
*/

/* ARGSUSED2 */
char *
dequote_map(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	register char *p;
	register char *q;
	register char c;
	int anglecnt = 0;
	int cmntcnt = 0;
	int quotecnt = 0;
	int spacecnt = 0;
	bool quotemode = false;
	bool bslashmode = false;
	char spacesub = map->map_spacesub;

	for (p = q = name; (c = *p++) != '\0'; )
	{
		if (bslashmode)
		{
			bslashmode = false;
			*q++ = c;
			continue;
		}

		if (c == ' ' && spacesub != '\0')
			c = spacesub;

		switch (c)
		{
		  case '\\':
			bslashmode = true;
			break;

		  case '(':
			cmntcnt++;
			break;

		  case ')':
			if (cmntcnt-- <= 0)
				return NULL;
			break;

		  case ' ':
		  case '\t':
			spacecnt++;
			break;
		}

		if (cmntcnt > 0)
		{
			*q++ = c;
			continue;
		}

		switch (c)
		{
		  case '"':
			quotemode = !quotemode;
			quotecnt++;
			continue;

		  case '<':
			anglecnt++;
			break;

		  case '>':
			if (anglecnt-- <= 0)
				return NULL;
			break;
		}
		*q++ = c;
	}

	if (anglecnt != 0 || cmntcnt != 0 || bslashmode ||
	    quotemode || quotecnt <= 0 || spacecnt != 0)
		return NULL;
	*q++ = '\0';
	return map_rewrite(map, name, strlen(name), NULL);
}
/*
**  RSCHECK -- check string(s) for validity using rewriting sets
**
**	Parameters:
**		rwset -- the rewriting set to use.
**		p1 -- the first string to check.
**		p2 -- the second string to check -- may be null.
**		e -- the current envelope.
**		flags -- control some behavior, see RSF_ in sendmail.h
**		logl -- logging level.
**		host -- NULL or relay host.
**		logid -- id for sm_syslog.
**		addr -- if not NULL and ruleset returns $#error:
**				store mailer triple here.
**
**	Returns:
**		EX_OK -- if the rwset doesn't resolve to $#error
**		else -- the failure status (message printed)
*/

int
rscheck(rwset, p1, p2, e, flags, logl, host, logid, addr)
	char *rwset;
	char *p1;
	char *p2;
	ENVELOPE *e;
	int flags;
	int logl;
	char *host;
	char *logid;
	ADDRESS *addr;
{
	char *volatile buf;
	size_t bufsize;
	int saveexitstat;
	int volatile rstat = EX_OK;
	char **pvp;
	int rsno;
	bool volatile discard = false;
	bool saveQuickAbort = QuickAbort;
	bool saveSuprErrs = SuprErrs;
	bool quarantine = false;
	char ubuf[BUFSIZ * 2];
	char buf0[MAXLINE];
	char pvpbuf[PSBUFSIZE];
	extern char MsgBuf[];

	if (tTd(48, 2))
		sm_dprintf("rscheck(%s, %s, %s)\n", rwset, p1,
			p2 == NULL ? "(NULL)" : p2);

	rsno = strtorwset(rwset, NULL, ST_FIND);
	if (rsno < 0)
		return EX_OK;

	if (p2 != NULL)
	{
		bufsize = strlen(p1) + strlen(p2) + 2;
		if (bufsize > sizeof(buf0))
			buf = sm_malloc_x(bufsize);
		else
		{
			buf = buf0;
			bufsize = sizeof(buf0);
		}
		(void) sm_snprintf(buf, bufsize, "%s%c%s", p1, CONDELSE, p2);
	}
	else
	{
		bufsize = strlen(p1) + 1;
		if (bufsize > sizeof(buf0))
			buf = sm_malloc_x(bufsize);
		else
		{
			buf = buf0;
			bufsize = sizeof(buf0);
		}
		(void) sm_strlcpy(buf, p1, bufsize);
	}
	SM_TRY
	{
		SuprErrs = true;
		QuickAbort = false;
		pvp = prescan(buf, '\0', pvpbuf, sizeof(pvpbuf), NULL,
			      bitset(RSF_RMCOMM, flags) ?
					IntTokenTab : TokTypeNoC,
			      bitset(RSF_RMCOMM, flags) ? false : true);
		SuprErrs = saveSuprErrs;
		if (pvp == NULL)
		{
			if (tTd(48, 2))
				sm_dprintf("rscheck: cannot prescan input\n");
	/*
			syserr("rscheck: cannot prescan input: \"%s\"",
				shortenstring(buf, MAXSHORTSTR));
			rstat = EX_DATAERR;
	*/
			goto finis;
		}
		if (bitset(RSF_UNSTRUCTURED, flags))
			SuprErrs = true;
		(void) REWRITE(pvp, rsno, e);
		if (bitset(RSF_UNSTRUCTURED, flags))
			SuprErrs = saveSuprErrs;
		if (pvp[0] == NULL || (pvp[0][0] & 0377) != CANONNET ||
		    pvp[1] == NULL || (strcmp(pvp[1], "error") != 0 &&
				       strcmp(pvp[1], "discard") != 0))
		{
			goto finis;
		}

		if (strcmp(pvp[1], "discard") == 0)
		{
			if (tTd(48, 2))
				sm_dprintf("rscheck: discard mailer selected\n");
			e->e_flags |= EF_DISCARD;
			discard = true;
		}
		else if (strcmp(pvp[1], "error") == 0 &&
			 pvp[2] != NULL && (pvp[2][0] & 0377) == CANONHOST &&
			 pvp[3] != NULL && strcmp(pvp[3], "quarantine") == 0)
		{
			if (pvp[4] == NULL ||
			    (pvp[4][0] & 0377) != CANONUSER ||
			    pvp[5] == NULL)
				e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool,
								 rwset);
			else
			{
				cataddr(&(pvp[5]), NULL, ubuf,
					sizeof(ubuf), ' ', true);
				e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool,
								 ubuf);
			}
			macdefine(&e->e_macro, A_PERM,
				  macid("{quarantine}"), e->e_quarmsg);
			quarantine = true;
		}
		else
		{
			auto ADDRESS a1;
			int savelogusrerrs = LogUsrErrs;
			static bool logged = false;

			/* got an error -- process it */
			saveexitstat = ExitStat;
			LogUsrErrs = false;
			(void) buildaddr(pvp, &a1, 0, e);
			if (addr != NULL)
			{
				addr->q_mailer = a1.q_mailer;
				addr->q_user = a1.q_user;
				addr->q_host = a1.q_host;
			}
			LogUsrErrs = savelogusrerrs;
			rstat = ExitStat;
			ExitStat = saveexitstat;
			if (!logged)
			{
				if (bitset(RSF_COUNT, flags))
					markstats(e, &a1, STATS_REJECT);
				logged = true;
			}
		}

		if (LogLevel > logl)
		{
			char *relay;
			char *p;
			char lbuf[MAXLINE];

			p = lbuf;
			if (p2 != NULL)
			{
				(void) sm_snprintf(p, SPACELEFT(lbuf, p),
					", arg2=%s",
					p2);
				p += strlen(p);
			}

			if (host != NULL)
				relay = host;
			else
				relay = macvalue('_', e);
			if (relay != NULL)
			{
				(void) sm_snprintf(p, SPACELEFT(lbuf, p),
					", relay=%s", relay);
				p += strlen(p);
			}
			*p = '\0';
			if (discard)
				sm_syslog(LOG_NOTICE, logid,
					  "ruleset=%s, arg1=%s%s, discard",
					  rwset, p1, lbuf);
			else if (quarantine)
				sm_syslog(LOG_NOTICE, logid,
					  "ruleset=%s, arg1=%s%s, quarantine=%s",
					  rwset, p1, lbuf, ubuf);
			else
				sm_syslog(LOG_NOTICE, logid,
					  "ruleset=%s, arg1=%s%s, reject=%s",
					  rwset, p1, lbuf, MsgBuf);
		}

	 finis: ;
	}
	SM_FINALLY
	{
		/* clean up */
		if (buf != buf0)
			sm_free(buf);
		QuickAbort = saveQuickAbort;
	}
	SM_END_TRY

	setstat(rstat);

	/* rulesets don't set errno */
	errno = 0;
	if (rstat != EX_OK && QuickAbort)
		sm_exc_raisenew_x(&EtypeQuickAbort, 2);
	return rstat;
}
/*
**  RSCAP -- call rewriting set to return capabilities
**
**	Parameters:
**		rwset -- the rewriting set to use.
**		p1 -- the first string to check.
**		p2 -- the second string to check -- may be null.
**		e -- the current envelope.
**		pvp -- pointer to token vector.
**		pvpbuf -- buffer space.
**		size -- size of buffer space.
**
**	Returns:
**		EX_UNAVAILABLE -- ruleset doesn't exist.
**		EX_DATAERR -- prescan() failed.
**		EX_OK -- rewrite() was successful.
**		else -- return status from rewrite().
*/

int
rscap(rwset, p1, p2, e, pvp, pvpbuf, size)
	char *rwset;
	char *p1;
	char *p2;
	ENVELOPE *e;
	char ***pvp;
	char *pvpbuf;
	int size;
{
	char *volatile buf;
	size_t bufsize;
	int volatile rstat = EX_OK;
	int rsno;
	bool saveQuickAbort = QuickAbort;
	bool saveSuprErrs = SuprErrs;
	char buf0[MAXLINE];
	extern char MsgBuf[];

	if (tTd(48, 2))
		sm_dprintf("rscap(%s, %s, %s)\n", rwset, p1,
			p2 == NULL ? "(NULL)" : p2);

	SM_REQUIRE(pvp != NULL);
	rsno = strtorwset(rwset, NULL, ST_FIND);
	if (rsno < 0)
		return EX_UNAVAILABLE;

	if (p2 != NULL)
	{
		bufsize = strlen(p1) + strlen(p2) + 2;
		if (bufsize > sizeof(buf0))
			buf = sm_malloc_x(bufsize);
		else
		{
			buf = buf0;
			bufsize = sizeof(buf0);
		}
		(void) sm_snprintf(buf, bufsize, "%s%c%s", p1, CONDELSE, p2);
	}
	else
	{
		bufsize = strlen(p1) + 1;
		if (bufsize > sizeof(buf0))
			buf = sm_malloc_x(bufsize);
		else
		{
			buf = buf0;
			bufsize = sizeof(buf0);
		}
		(void) sm_strlcpy(buf, p1, bufsize);
	}
	SM_TRY
	{
		SuprErrs = true;
		QuickAbort = false;
		*pvp = prescan(buf, '\0', pvpbuf, size, NULL, IntTokenTab,
				false);
		if (*pvp != NULL)
			rstat = rewrite(*pvp, rsno, 0, e, size);
		else
		{
			if (tTd(48, 2))
				sm_dprintf("rscap: cannot prescan input\n");
			rstat = EX_DATAERR;
		}
	}
	SM_FINALLY
	{
		/* clean up */
		if (buf != buf0)
			sm_free(buf);
		SuprErrs = saveSuprErrs;
		QuickAbort = saveQuickAbort;

		/* prevent information leak, this may contain rewrite error */
		MsgBuf[0] = '\0';
	}
	SM_END_TRY
	return rstat;
}
@


1.29
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.28
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2006 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: parseaddr.c,v 8.406 2013/04/17 16:53:01 ca Exp $")
@


1.27
log
@Update to sendmail 8.14.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: parseaddr.c,v 8.405 2012/02/27 22:49:08 ca Exp $")
d2351 8
@


1.26
log
@Update to sendmail 8.14.5
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: parseaddr.c,v 8.404 2010/07/27 03:35:42 ca Exp $")
d245 1
@


1.25
log
@Update to sendmail-8.14.3
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: parseaddr.c,v 8.403 2008/02/08 02:27:35 ca Exp $")
d322 1
a322 1
**		true -- if the address has any "wierd" characters or
@


1.24
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: parseaddr.c,v 8.400 2006/12/21 00:24:06 ca Exp $")
d220 1
a220 1
			sm_dprintf("parseaddr: queuing message\n");
d1463 1
d1579 1
d1604 2
a1605 1
					       sizeof(pvpbuf), NULL, NULL,
d2269 1
a2269 1
		natomtok = (ExtTokenTab[**pvp & 0xff] == ATM);
@


1.23
log
@Update to sendmail-8.13.8
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2005 Sendmail, Inc. and its suppliers.
d16 4
a19 1
SM_RCSID("@@(#)$Sendmail: parseaddr.c,v 8.384 2006/04/18 01:28:47 ca Exp $")
d96 2
a97 1
	pvp = prescan(addr, delim, pvpbuf, sizeof pvpbuf, delimptr, NULL, false);
d183 1
a183 1
	    !bitset(RF_SENDERADDR|RF_HEADERADDR, flags) &&
d275 1
a275 1
		if ((*addr & 0340) == 0200)
d352 1
a352 1
		if (!quoted && (*addr < 32 || *addr == 127))
d370 1
a370 1
		if ((*addr & 0340) == 0200)
d438 1
d499 1
a499 1
	/*ILL*/	{	OPR|B,	ATM|B,	QST|B,	SPC|MB,	ONE|B,	ILL|M	},
d502 42
a543 2
/* token type table -- it gets modified with $o characters */
static unsigned char	TokTypeTab[256] =
d577 1
a577 1
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
d615 1
a615 1
	ILL,ILL,ILL,ILL,ILL,ILL,ILL,ILL, ILL,ILL,ILL,ILL,ILL,ILL,ILL,ILL,
d653 1
a653 1
	ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM, ATM,ATM,ATM,ATM,ATM,ATM,ATM,ATM,
d697 1
a697 1
		expand(OperatorChars, obuf, sizeof obuf - sizeof DELIMCHARS,
d699 1
a699 1
		(void) sm_strlcat(obuf, DELIMCHARS, sizeof obuf);
d702 4
a705 2
			if (TokTypeTab[*p & 0xff] == ATM)
				TokTypeTab[*p & 0xff] = OPR;
d711 1
a711 1
		toktab = TokTypeTab;
d762 2
a763 1
				if ((char) c == (char) -1 && !tTd(82, 101))
d1046 1
a1046 1
		(void) sm_snprintf(name, sizeof name, "%d", ruleset);
d1132 3
a1134 2
			if (ap == NULL && (*rp & 0377) != MATCHZANY &&
			    (*rp & 0377) != MATCHZERO)
d1140 1
a1140 1
			switch (*rp & 0377)
d1152 1
a1152 1
					buf, sizeof buf, '\0');
d1267 3
a1269 2
				if ((*rp & 0377) == MATCHANY ||
				    (*rp & 0377) == MATCHZANY)
d1277 1
a1277 1
				if ((*rp & 0377) == MATCHCLASS)
d1316 1
a1316 1
			if ((*rp & 0377) == CANONUSER)
d1323 1
a1323 1
			else if ((*rp & 0377) == CANONHOST)
d1337 1
a1337 1
			if ((*rp & 0377) == MATCHREPL)
d1380 1
a1380 1
				if ((*rp & 0377) != MACRODEXPAND)
d1382 1
a1382 1
					/* vanilla replacement */
d1404 1
a1404 1
						trsize += sizeof *xpvp;
d1420 1
a1420 1
						       sizeof pvpbuf, NULL,
a1473 10
			if ((**rvp & 0377) != HOSTBEGIN &&
			    (**rvp & 0377) != LOOKUPBEGIN)
				continue;

			/*
			**  Got a hostname/keyword lookup.
			**
			**	This could be optimized fairly easily.
			*/

d1475 1
a1475 1
			if ((**rvp & 0377) == HOSTBEGIN)
d1480 1
a1480 1
			else
d1491 9
d1518 1
a1518 1
			while (*rvp != NULL && (**rvp & 0377) != endtoken)
d1520 1
a1520 1
				int nodetype = **rvp & 0377;
d1534 2
a1535 2
						&pvpbuf[sizeof pvpbuf] - replac,
						'\0');
d1558 2
a1559 2
					&pvpbuf[sizeof pvpbuf] - replac,
					'\0');
d1569 1
a1569 1
			trsize = (avp - rvp + 1) * sizeof *rvp;
d1573 3
a1575 2
			cataddr(key_rvp, NULL, cbuf, sizeof cbuf,
				map == NULL ? '\0' : map->s_map.map_spacesub);
d1583 2
a1584 2
				cataddr(default_rvp, NULL, cbuf, sizeof cbuf,
					'\0');
d1602 2
a1603 1
					       sizeof pvpbuf, NULL, NULL, false);
d1638 1
a1638 1
		      (int) (avp - npvp) * sizeof *avp);
d1702 1
a1702 1
		if ((**avp & 0377) == CALLSUBR && avp[1] != NULL)
d1821 2
a1822 1
		sm_dprintf("map_lookup(%s, %s", smap->s_name, key);
d1849 1
a1849 1
			(void) sm_snprintf(mbuf, sizeof mbuf,
d1974 2
a1975 2
		a = (ADDRESS *) sm_rpool_malloc_x(e->e_rpool, sizeof *a);
	memset((char *) a, '\0', sizeof *a);
d2031 2
a2032 2
		cataddr(hostp, tv - 1, hbuf, sizeof hbuf, '\0');
	cataddr(++tv, NULL, ubuf, sizeof ubuf, ' ');
d2087 1
a2087 1
			(void) sm_strlcpyn(fmt, sizeof fmt, 2, ubuf, " %s");
d2174 1
a2174 1
	cataddr(tv, NULL, ubuf, sizeof ubuf, '\0');
d2205 2
d2213 15
d2231 1
a2231 1
cataddr(pvp, evp, buf, sz, spacesub)
d2237 1
d2239 9
a2247 4
	bool oatomtok = false;
	bool natomtok = false;
	register int i;
	register char *p;
d2264 3
a2266 1
		natomtok = (TokTypeTab[**pvp & 0xff] == ATM);
d2273 19
a2291 2
		i = sm_strlcpy(p, *pvp, sz);
		sz -= i;
a2294 1
		p += i;
d2316 3
d2320 1
d2644 5
a2648 1
		sm_dprintf("remotename(%s)\n", name);
d2688 1
a2688 1
	pvp = prescan(name, '\0', pvpbuf, sizeof pvpbuf, NULL, NULL, false);
d2762 1
a2762 1
	cataddr(pvp, NULL, lbuf, sizeof lbuf, '\0');
d2769 1
a2769 1
			expand("<\201g>", buf, sizeof buf, e);
d2771 1
a2771 1
			expand(fancy, buf, sizeof buf, e);
d2777 5
a2781 1
		sm_dprintf("remotename => `%s'\n", buf);
d2819 2
a2820 1
	pvp = prescan(a->q_user, '\0', pvpbuf, sizeof pvpbuf, NULL, NULL, false);
d3049 2
d3058 1
a3058 1
rscheck(rwset, p1, p2, e, flags, logl, host, logid)
d3067 1
a3075 1
	auto ADDRESS a1;
d3095 1
a3095 1
		if (bufsize > sizeof buf0)
d3100 1
a3100 1
			bufsize = sizeof buf0;
d3107 1
a3107 1
		if (bufsize > sizeof buf0)
d3112 1
a3112 1
			bufsize = sizeof buf0;
d3120 3
a3122 2
		pvp = prescan(buf, '\0', pvpbuf, sizeof pvpbuf, NULL,
			      bitset(RSF_RMCOMM, flags) ? NULL : TokTypeNoC,
d3167 1
a3167 1
					sizeof ubuf, ' ');
d3177 1
d3185 6
d3311 1
a3311 1
		if (bufsize > sizeof buf0)
d3316 1
a3316 1
			bufsize = sizeof buf0;
d3323 1
a3323 1
		if (bufsize > sizeof buf0)
d3328 1
a3328 1
			bufsize = sizeof buf0;
d3336 2
a3337 1
		*pvp = prescan(buf, '\0', pvpbuf, size, NULL, NULL, false);
@


1.22
log
@Update to sendmail 8.13.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: parseaddr.c,v 8.383 2006/02/01 19:46:11 ca Exp $")
d706 1
a706 1
							p--;
d1445 1
d1447 3
d1459 1
d1462 3
d1533 2
a1534 1
				cataddr(default_rvp, NULL, cbuf, sizeof cbuf, '\0');
d3187 1
a3187 2
	if (pvp != NULL)
		*pvp = NULL;
@


1.21
log
@update to sendmail 8.13.4
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: parseaddr.c,v 8.381 2005/02/04 22:01:45 ca Exp $")
d1340 1
a1340 1
					int trsize = 0;
d1355 1
a1355 1
					if ((size_t) trsize > pvpb1_size)
d1410 1
a1410 1
			int trsize;
d1418 1
a1418 1
			char cbuf[MAXNAME + 1];
d1512 1
a1512 1
			trsize = (int) (avp - rvp + 1) * sizeof *rvp;
d2952 1
a2952 1
	int bufsize;
d3166 1
a3166 1
	int bufsize;
@


1.21.4.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@d1340 1
a1340 1
					size_t trsize = 0;
d1355 1
a1355 1
					if (trsize > pvpb1_size)
d1410 1
a1410 1
			size_t trsize;
d1512 1
a1512 1
			trsize = (avp - rvp + 1) * sizeof *rvp;
d2952 1
a2952 1
	size_t bufsize;
d3166 1
a3166 1
	size_t bufsize;
@


1.21.2.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@d1340 1
a1340 1
					size_t trsize = 0;
d1355 1
a1355 1
					if (trsize > pvpb1_size)
d1410 1
a1410 1
			size_t trsize;
d1512 1
a1512 1
			trsize = (avp - rvp + 1) * sizeof *rvp;
d2952 1
a2952 1
	size_t bufsize;
d3166 1
a3166 1
	size_t bufsize;
@


1.20
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: parseaddr.c,v 8.379 2004/08/06 22:19:36 ca Exp $")
d2197 13
a2209 1
	/* Don't silently truncate long strings */
d2212 1
@


1.20.2.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@d1340 1
a1340 1
					size_t trsize = 0;
d1355 1
a1355 1
					if (trsize > pvpb1_size)
d1410 1
a1410 1
			size_t trsize;
d1512 1
a1512 1
			trsize = (avp - rvp + 1) * sizeof *rvp;
d2939 1
a2939 1
	size_t bufsize;
d3153 1
a3153 1
	size_t bufsize;
@


1.19
log
@Update to sendmail.8.13.0
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: parseaddr.c,v 8.378 2004/05/18 20:01:54 ca Exp $")
d2199 1
a2199 1
		syserr("cataddr: string too long");
@


1.18
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: parseaddr.c,v 8.359.2.9 2003/09/16 18:07:50 ca Exp $")
d93 1
a93 1
	pvp = prescan(addr, delim, pvpbuf, sizeof pvpbuf, delimptr, NULL);
d231 1
a231 1
		printaddr(a, false);
d463 1
d615 1
a615 1
prescan(addr, delim, pvpbuf, pvpbsize, delimptr, toktab)
d622 1
a637 1
	extern int errno;
d682 1
a682 1
		xputs(p);
d726 3
a728 1
				if (state == QST)
d754 1
a754 1
				if (delim == ',' && !route_syntax)
d805 5
a809 2
					usrerr("553 Unbalanced ')'");
					c = NOCHAR;
d832 5
a836 2
					usrerr("553 Unbalanced '>'");
					c = NOCHAR;
d880 1
a880 1
				xputs(tok);
d906 1
a906 1
		printav(av);
d1009 1
a1009 1
		printav(pvp);
d1014 1
a1014 1
		printav(pvp);
d1049 1
a1049 1
			printav(rwr->r_lhs);
d1063 1
a1063 1
				printav(pvp);
d1074 1
a1074 1
				xputs(rp);
d1076 1
a1076 1
				xputs(ap);
d1109 1
a1109 1
						xputs(rp);
d1111 1
a1111 1
						xputs(ap);
d1207 1
a1207 1
					xputs(rp);
d1209 1
a1209 1
					xputs(ap);
d1260 1
a1260 1
			printav(rvp);
d1371 1
a1371 1
						       NULL);
d1543 1
a1543 1
					       sizeof pvpbuf, NULL, NULL);
d1583 1
a1583 1
			printav(pvp);
d1591 1
a1591 1
		printav(pvp);
d1596 1
a1596 1
		printav(pvp);
d1908 1
a1908 1
		printav(tv);
a1924 1
#if _FFR_ALLOW_S0_ERROR_4XX
a1933 3
		**
		**  tempfail is tested here even if _FFR_ALLOW_S0_ERROR_4XX
		**  is not set; that's ok because it is initialized to false.
a1934 1
#endif /* _FFR_ALLOW_S0_ERROR_4XX */
a2033 1
#if _FFR_ALLOW_S0_ERROR_4XX
a2035 1
#endif /* _FFR_ALLOW_S0_ERROR_4XX */
d2128 1
a2128 1
		printaddr(a, false);
d2187 3
a2189 1
		if ((i = sm_strlcpy(p, *pvp, sz)) >= sz)
a2192 1
		sz -= i;
d2196 3
a2198 3
#if _FFR_CATCH_LONG_STRINGS
	/* Don't silently truncate long strings; broken for evp != NULL */
	if (*pvp != NULL)
a2199 1
#endif /* _FFR_CATCH_LONG_STRINGS */
d2303 2
a2304 1
printaddr(a, follow)
d2315 1
a2315 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "[NULL]\n");
d2321 2
a2322 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%p=", a);
		(void) sm_io_flush(smioout, SM_TIME_DEFAULT);
d2333 1
a2333 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d2338 1
a2338 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d2342 1
a2342 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "\tstate=");
d2346 1
a2346 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "OK");
d2350 1
a2350 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d2355 1
a2355 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d2360 1
a2360 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d2365 1
a2365 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "RETRY");
d2369 1
a2369 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "SENT");
d2373 1
a2373 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d2378 1
a2378 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d2383 1
a2383 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d2388 1
a2388 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d2393 1
a2393 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d2398 1
a2398 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d2403 1
a2403 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d2408 1
a2408 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d2413 1
a2413 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d2418 1
a2418 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d2422 1
a2422 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d2426 1
a2426 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "\tflags=%lx<",
d2434 1
a2434 1
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d2437 1
a2437 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s",
d2440 2
a2441 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, ">\n");
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d2446 1
a2446 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d2451 1
a2451 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d2454 1
a2454 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d2457 1
a2457 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d2565 1
a2565 1
	pvp = prescan(name, '\0', pvpbuf, sizeof pvpbuf, NULL, NULL);
d2690 1
a2690 1
		printaddr(a, false);
d2692 1
a2692 1
	pvp = prescan(a->q_user, '\0', pvpbuf, sizeof pvpbuf, NULL, NULL);
d2754 1
a2754 1
		printaddr(a, false);
a2947 1
#if _FFR_QUARANTINE
a2949 1
#endif /* _FFR_QUARANTINE */
d2991 2
a2992 1
			      bitset(RSF_RMCOMM, flags) ? NULL : TokTypeNoC);
a3023 1
#if _FFR_QUARANTINE
a3043 1
#endif /* _FFR_QUARANTINE */
a3093 1
#if _FFR_QUARANTINE
a3097 1
#endif /* _FFR_QUARANTINE */
d3199 1
a3199 1
		*pvp = prescan(buf, '\0', pvpbuf, size, NULL, NULL);
@


1.17
log
@from millert
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: parseaddr.c,v 8.359.2.6 2003/03/27 02:39:53 ca Exp $")
a887 1
	p--;
d889 3
d893 1
d976 5
d1015 2
d1304 1
a1304 10
					{
						syserr("554 5.3.0 rewrite: expansion too long");
						if (LogLevel > 9)
							sm_syslog(LOG_ERR,
								e->e_id,
								"rewrite: expansion too long, ruleset=%s, ruleno=%d",
								rulename,
								ruleno);
						return EX_DATAERR;
					}
d1411 1
a1411 1
			char *argvect[10];
d1435 2
d1440 2
a1441 1
				syserr("554 5.3.0 rewrite: map %s not found", mapname);
d1445 3
d1456 2
a1457 1
				if (nodetype != CANONHOST && nodetype != CANONUSER)
d1470 3
a1472 1
					*++arg_rvp = replac;
d1494 2
a1495 1
				*++arg_rvp = replac;
d1497 4
a1500 1
			*++arg_rvp = NULL;
d1689 1
a1689 1
		**  the subroutine. we can do this inplace since
d1887 1
d1902 1
d1942 1
d1946 1
d1948 2
d1952 1
d1954 1
d1956 2
d1968 1
d2073 1
d2104 1
a2104 1
		(void) REWRITE(tv, 2, e);
d2106 1
a2106 1
		       (void) REWRITE(tv, m->m_re_rwset, e);
d2108 1
a2108 1
	(void) REWRITE(tv, 4, e);
d2194 1
a2194 1
	/* Don't silently truncate long strings */
d2487 1
a2487 2
**		m -- the mailer that we want to do rewriting relative
**			to.
a2681 1
	auto char *delimptr;
d2689 1
a2689 1
	pvp = prescan(a->q_user, '\0', pvpbuf, sizeof pvpbuf, &delimptr, NULL);
d3135 1
d3203 1
a3203 1
			rstat = REWRITE(*pvp, rsno, e);
@


1.16
log
@Update to sendmail 8.12.9; fixes a buffer overflow in address parsing
due to a char to int conversion problem which is potentially remotely
exploitable.
@
text
@d703 3
d707 1
@


1.16.2.1
log
@second rev of sendmail patch
@
text
@a702 3
					{
						if (p > addr)
							p--;
a703 1
					}
a1002 2
	if (maxatom <= 0)
		return EX_USAGE;
a1868 1
	int maxatom;
a1882 1
	maxatom = MAXATOM;
a1921 1
	--maxatom;
a1924 1
	{
a1925 2
		--maxatom;
	}
a1927 1
	--maxatom;
a1928 1
	{
a1929 2
		--maxatom;
	}
a1939 1
	--maxatom;
a2043 1
		--maxatom;
d2074 1
a2074 1
		(void) rewrite(tv, 2, 0, e, maxatom);
d2076 1
a2076 1
		       (void) rewrite(tv, m->m_re_rwset, 0, e, maxatom);
d2078 1
a2078 1
	(void) rewrite(tv, 4, 0, e, maxatom);
@


1.15
log
@Update to Sendmail 8.12.8; fixes a buffer overflow in the envelope
comments processing which may allow an attacker to gain root privileges.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: parseaddr.c,v 8.359.2.4 2003/01/18 00:41:48 gshapiro Exp $")
d611 1
a611 1
#define NOCHAR		-1	/* signal nothing in lookahead token */
d697 1
d709 4
d717 1
a717 1
			c = *p++;
d772 3
d860 3
@


1.14
log
@update to sendmail 8.12.7
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: parseaddr.c,v 8.359.2.3 2002/09/26 23:03:39 gshapiro Exp $")
d2512 1
a2512 1
		fancy = crackaddr(name);
@


1.13
log
@update to sendmail-8.12.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: parseaddr.c,v 8.359.2.2 2002/08/16 14:56:01 ca Exp $")
d2089 1
@


1.13.2.1
log
@Errata #009:
A buffer overflow in the envelope comments processing in sendmail may
allow an attacker to gain root privileges.
@
text
@d2511 1
a2511 1
		fancy = crackaddr(name, e);
@


1.13.2.2
log
@Errata #14
Fix by millert@@
Fix a buffer overflow in address parsing due to a char to int conversion
problem which is potentially remotely exploitable.
@
text
@d611 1
a611 1
#define NOCHAR		(-1)	/* signal nothing in lookahead token */
a696 1
	addrtoolong:
a707 4
#if !ALLOW_255
				if ((char) c == (char) -1 && !tTd(82, 101))
					c &= 0x7f;
#endif /* !ALLOW_255 */
d712 1
a712 1
			c = (*p++) & 0x00ff;
a766 3
					/* see if there is room */
					if (q >= &pvpbuf[pvpbsize - 5])
						goto addrtoolong;
a851 3
			/* see if there is room */
			if (q >= &pvpbuf[pvpbsize - 5])
				goto addrtoolong;
@


1.13.2.3
log
@second rev of sendmail patch
@
text
@a702 3
					{
						if (p > addr)
							p--;
a703 1
					}
a1002 2
	if (maxatom <= 0)
		return EX_USAGE;
a1868 1
	int maxatom;
a1882 1
	maxatom = MAXATOM;
a1921 1
	--maxatom;
a1924 1
	{
a1925 2
		--maxatom;
	}
a1927 1
	--maxatom;
a1928 1
	{
a1929 2
		--maxatom;
	}
a1939 1
	--maxatom;
a2043 1
		--maxatom;
d2074 1
a2074 1
		(void) rewrite(tv, 2, 0, e, maxatom);
d2076 1
a2076 1
		       (void) rewrite(tv, m->m_re_rwset, 0, e, maxatom);
d2078 1
a2078 1
	(void) rewrite(tv, 4, 0, e, maxatom);
@


1.12
log
@sendmail 8.12.5
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: parseaddr.c,v 8.359.2.1 2002/06/19 18:24:26 gshapiro Exp $")
d2874 1
a2874 2
**		rmcomm -- remove comments?
**		cnt -- count rejections (statistics)?
d2885 1
a2885 1
rscheck(rwset, p1, p2, e, rmcomm, cnt, logl, host, logid)
d2890 1
a2890 1
	bool rmcomm, cnt;
d2950 1
a2950 1
			      rmcomm ? NULL : TokTypeNoC);
d2963 2
d2966 2
d3018 1
a3018 1
				if (cnt)
@


1.11
log
@update to sendmail 8.12.3
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: parseaddr.c,v 8.359 2002/03/29 16:20:47 ca Exp $")
d1127 1
a1127 1
					sm_dprintf("rewrite: LHS $&%s => \"%s\"\n",
d1312 1
a1312 1
					/* $&x replacement */
d1321 1
a1321 1
						sm_dprintf("rewrite: RHS $&%s => \"%s\"\n",
@


1.10
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: parseaddr.c,v 8.349 2001/12/12 02:50:22 gshapiro Exp $")
d22 4
a25 1
static bool	hasctrlchar __P((register char *, bool));
d144 1
a144 1
	if (hasctrlchar(a->q_user, isrcpt))
d148 8
a155 1
		return NULL;
d165 3
d169 1
d259 1
d275 1
a275 1
			break;
d279 6
a284 2
			usrerr("553 5.1.0 Address too long (%d bytes max)",
			       MAXNAME - 1);
d292 2
a293 1
			usrerr("501 5.1.3 Syntax error in mailbox address");
d295 2
a296 1
			usrerr("501 5.1.7 Syntax error in mailbox address");
d314 2
d324 1
a324 1
hasctrlchar(addr, isrcpt)
d326 1
a326 1
	bool isrcpt;
d328 1
a328 1
	bool result = false;
d330 2
a331 1
	bool quoted = false;
d337 11
d350 3
a352 2
			result = true;	/* a non-printable */
			break;
d361 2
a362 1
				result = true;
d369 3
a371 8
			result = true;
			break;
		}
		if (++len > MAXNAME - 1)
		{
			usrerr("553 5.1.0 Address too long (%d bytes max)",
			       MAXNAME - 1);
			return true;
d375 2
a376 2
		result = true; /* unbalanced quote */
	if (result)
d379 2
a380 1
			usrerr("501 5.1.3 Syntax error in mailbox address");
d382 2
a383 1
			usrerr("501 5.1.7 Syntax error in mailbox address");
d385 1
a385 1
	return result;
d1857 1
d1885 17
a1901 1
		if (ExitStat == EX_TEMPFAIL)
d1990 4
d2151 5
@


1.10.2.1
log
@Errata #022:
A buffer overflow in the envelope comments processing in sendmail may
allow an attacker to gain root privileges.
@
text
@d2451 1
a2451 1
		fancy = crackaddr(name, e);
@


1.10.2.2
log
@Errata #027 (millert)
Fix a buffer overflow in address parsing due to a char to int conversion
problem which is potentially remotely exploitable.
@
text
@d577 1
a577 1
#define NOCHAR		(-1)	/* signal nothing in lookahead token */
a662 1
	addrtoolong:
a673 4
#if !ALLOW_255
				if ((char) c == (char) -1 && !tTd(82, 101))
					c &= 0x7f;
#endif /* !ALLOW_255 */
d678 1
a678 1
			c = (*p++) & 0x00ff;
a732 3
					/* see if there is room */
					if (q >= &pvpbuf[pvpbsize - 5])
						goto addrtoolong;
a817 3
			/* see if there is room */
			if (q >= &pvpbuf[pvpbsize - 5])
				goto addrtoolong;
@


1.9
log
@Enable the volatiles that keep gcc from complaining about variables
that may possibly be clobbered by longjmp().
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: parseaddr.c,v 8.344 2001/09/20 23:08:06 gshapiro Exp $")
d806 2
a807 1
					usrerr("553 Illegal character 0x%02x", c);
d2927 1
a2927 1
				e->e_holdmsg = sm_rpool_strdup_x(e->e_rpool,
d2933 1
a2933 1
				e->e_holdmsg = sm_rpool_strdup_x(e->e_rpool,
d2937 1
a2937 1
				  macid("{holdmsg}"), e->e_holdmsg);
d2956 1
a2956 1
					markstats(e, &a1, true);
d3015 3
@


1.8
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d2579 1
a2579 1
	register ADDRESS *a1 = NULL;
@


1.7
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: parseaddr.c,v 8.340 2001/09/04 22:43:04 ca Exp $")
d222 1
a222 1
/*
d282 1
a282 1
/*
d353 1
a353 1
/*
d400 1
a400 1
/*
d855 1
a855 1
/*
d1527 1
a1527 1
/*
d1638 1
a1638 1
/*
d1743 1
a1743 1
/*
d1779 1
a1779 1
/*
d2033 1
a2033 1
/*
d2097 1
a2097 1
/*
d2156 1
a2156 1
/*
d2360 1
a2360 1
/*
d2379 1
a2379 1
/*
d2552 1
a2552 1
/*
d2656 1
a2656 1
/*
d2707 1
a2707 1
/*
d2805 1
a2805 1
/*
d2845 4
d2918 22
d2990 6
d3018 1
a3018 1
/*
@


1.6
log
@Update to sendmail 8.11.6, from the release notes:

SECURITY: Fix a possible memory access violation when specifying
	out-of-bounds debug parameters.  Problem detected by
	Cade Cairns of SecurityFocus.
Avoid leaking recipient information in unrelated DSNs.  This could
	happen if a connection is aborted, several mails had been
	scheduled for delivery via that connection, and the timeout
	is reached such that several DSNs are sent next.  Problem
	noted by Dileepan Moorkanat of Hewlett-Packard.
Fix a possible segmentation violation when specifying too many
	wildcard operators in a rule.  Problem detected by
	Werner Wiethege.
Avoid a segmentation fault on non-matching Hesiod lookups.  Problem
	noted by Russell McOrmond of flora.ca
@
text
@d14 1
a14 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: parseaddr.c,v 8.234.4.13 2001/08/14 23:08:13 ca Exp $";
#endif /* ! lint */
d16 1
a16 1
#include <sendmail.h>
d18 1
a18 1
static void	allocaddr __P((ADDRESS *, int, char *));
d22 1
d41 1
a41 1
**			If NULL, a header will be created.
d49 2
d58 1
a58 1
**		none
d65 1
a65 1
parseaddr(addr, a, flags, delim, delimptr, e)
d72 1
d74 1
a74 1
	register char **pvp;
d85 1
a85 1
		dprintf("\n--parseaddr(%s)\n", addr);
d94 1
a94 1
			dprintf("parseaddr-->NULL\n");
d98 1
a98 1
	if (invalidaddr(addr, delim == '\0' ? NULL : *delimptr))
d101 1
a101 1
			dprintf("parseaddr-->bad address\n");
d119 1
a119 1
		e->e_to = addr = newstr(addr);
d129 5
a133 6
	qup = FALSE;
	if (rewrite(pvp, 3, 0, e) == EX_TEMPFAIL)
		qup = TRUE;
	if (rewrite(pvp, 0, 0, e) == EX_TEMPFAIL)
		qup = TRUE;

d141 7
d153 1
a153 1
	allocaddr(a, flags, addr);
d158 34
d202 1
a202 1
			dprintf("parseaddr: queuing message\n");
d205 1
a205 1
			e->e_message = newstr(msg);
d216 2
a217 2
		dprintf("parseaddr-->");
		printaddr(a, FALSE);
d223 1
a223 1
**  INVALIDADDR -- check for address containing meta-characters
d227 3
d232 3
a234 2
**		TRUE -- if the address has any "wierd" characters
**		FALSE -- otherwise.
d238 1
a238 1
invalidaddr(addr, delimptr)
d241 1
d243 1
d245 1
d249 1
d251 2
a252 2
		if (savedelim != '\0')
			*delimptr = '\0';
d254 1
a254 1
	if (strlen(addr) > MAXNAME - 1)
d256 20
a275 3
		usrerr("553 5.1.1 Address too long (%d bytes max)",
		       MAXNAME - 1);
		goto failure;
d277 34
d313 16
d330 3
d334 7
d342 3
a344 1
	if (*addr == '\0')
d346 6
a351 10
		if (delimptr != NULL && savedelim != '\0')
			*delimptr = savedelim;
		return FALSE;
	}
	setstat(EX_USAGE);
	usrerr("553 5.1.1 Address contained invalid control characters");
failure:
	if (delimptr != NULL && savedelim != '\0')
		*delimptr = savedelim;
	return TRUE;
d363 1
d373 1
a373 1
allocaddr(a, flags, paddr)
d377 1
d380 1
a380 1
		dprintf("allocaddr(flags=%x, paddr=%s)\n", flags, paddr);
d385 1
a385 1
		a->q_user = newstr("");
d387 1
a387 1
		a->q_host = newstr("");
d391 1
a391 1
		a->q_host = newstr(a->q_host);
d393 1
a393 1
			a->q_user = newstr(a->q_user);
d397 2
a398 1
		a->q_paddr = newstr(a->q_user);
d463 1
a463 1
static u_char	TokTypeTab[256] =
d501 1
a501 1
u_char	MimeTokenTab[256] =
d539 1
a539 1
u_char	TokTypeNoC[256] =
d586 1
a586 1
	u_char *toktab;
d601 1
a601 1
	static char firsttime = TRUE;
d609 1
a609 1
		firsttime = FALSE;
d619 1
a619 1
		(void) strlcat(obuf, DELIMCHARS, sizeof obuf);
d635 2
a636 2
	bslashmode = FALSE;
	route_syntax = FALSE;
d646 1
a646 1
		dprintf("prescan: ");
d648 1
a648 1
		dprintf("\n");
d664 1
a664 1
					if (strlen(addr) > (SIZE_T) MAXNAME)
d684 1
a684 1
					usrerr("653 Unbalanced '\"'");
d689 1
a689 1
					usrerr("653 Unbalanced '('");
d695 1
a695 1
					usrerr("653 Unbalanced '<'");
d710 1
a710 1
					usrerr("653 Unbalanced '<'");
d717 1
a717 1
				dprintf("c=%c, s=%d; ", c, state);
d723 1
a723 1
				bslashmode = FALSE;
d740 1
a740 1
				bslashmode = TRUE;
d756 1
a756 1
					usrerr("653 Unbalanced ')'");
d774 1
a774 1
					route_syntax = TRUE;
d780 1
a780 1
					usrerr("653 Unbalanced '>'");
d785 1
a785 1
				route_syntax = FALSE;
d799 1
a799 1
				dprintf("ns=%02o\n", newstate);
d804 1
a804 1
					usrerr("653 Illegal character %c", c);
d806 1
a806 1
					usrerr("653 Illegal character 0x%02x", c);
d820 1
a820 1
				dprintf("tok=");
d822 1
a822 1
				dprintf("\n");
d843 1
a843 1
		dprintf("prescan==>");
d850 1
a850 1
			dprintf("prescan: null leading token\n");
d882 1
d900 1
a900 1
rewrite(pvp, ruleset, reclevel, e)
d905 1
d931 1
a931 1
		snprintf(name, sizeof name, "%d", ruleset);
d940 2
a941 1
		printf("%s%-16.16s   input:", prefix, rulename);
d946 1
a946 1
		dprintf("%s%-16.16s   input:", prefix, rulename);
d976 1
a976 1
				dprintf("-----trying rule (line %d):",
d979 1
a979 1
				dprintf("-----trying rule:");
d993 1
a993 1
				dprintf("workspace: ");
d1004 1
a1004 1
				dprintf("ADVANCE rp=");
d1006 1
a1006 1
				dprintf(", ap=");
d1008 1
a1008 1
				dprintf("\n");
d1039 1
a1039 1
						dprintf("EXTEND  rp=");
d1041 1
a1041 1
						dprintf(", ap=");
d1043 1
a1043 1
						dprintf("\n");
d1048 1
a1048 1
					dprintf("CLMATCH\n");
d1092 1
a1092 1
					dprintf("rewrite: LHS $&%s => \"%s\"\n",
d1101 2
a1102 1
					    strncasecmp(ap, *avp, strlen(*avp)) != 0)
d1137 1
a1137 1
					dprintf("BACKUP  rp=");
d1139 1
a1139 1
					dprintf(", ap=");
d1141 1
a1141 1
					dprintf("\n");
d1180 1
a1180 1
				dprintf("----- rule fails\n");
d1190 1
a1190 1
			dprintf("-----rule matches:");
d1230 1
a1230 1
					dprintf("$%c:", rp[1]);
d1234 3
a1236 4
						dprintf(" %lx=\"",
							(u_long) *pp);
						(void) dflush();
						dprintf("%s\"", *pp++);
d1238 1
a1238 1
					dprintf("\n");
d1243 1
a1243 1
					if (avp >= &npvp[MAXATOM])
d1246 6
d1260 1
a1260 1
				if (avp >= &npvp[MAXATOM])
d1264 4
d1286 1
a1286 1
						dprintf("rewrite: RHS $&%s => \"%s\"\n",
d1299 2
a1300 1
						pvpb1 = (char **)xalloc(trsize);
d1322 1
a1322 1
							dprintf(" ... %s\n",
d1324 3
a1326 2
						*avp++ = newstr(*xpvp);
						if (avp >= &npvp[MAXATOM])
d1331 1
a1331 1
						dprintf(" ... DONE\n");
d1481 2
a1482 2
				*avp++ = newstr(*xpvp);
				if (avp >= &npvp[MAXATOM])
d1489 1
a1489 1
				if (avp >= &npvp[MAXATOM])
d1509 1
a1509 1
			dprintf("rewritten as:");
d1516 2
a1517 1
		printf("%s%-16.16s returns:", prefix, rulename);
d1522 1
a1522 1
		dprintf("%s%-16.16s returns:", prefix, rulename);
a1548 1
	char **rvp;
d1550 2
a1551 1
	int subr;
d1554 5
a1558 1
	char *tpvp[MAXATOM + 1];
d1560 8
a1567 1
	for (avp = pvp; *avp != NULL; avp++)
d1575 1
a1575 1
				syserr("Unknown ruleset %s", avp[1]);
a1578 4
			if (tTd(21, 3))
				dprintf("-----callsubr %s (%d)\n",
					avp[1], subr);

d1580 3
a1582 4
			**  Take care of possible inner calls first.
			**  use a full size temporary buffer to avoid
			**  overflows in rewrite, but strip off the
			**  subroutine call.
d1585 9
a1593 28
			for (i = 2; avp[i] != NULL; i++)
				tpvp[i - 2] = avp[i];
			tpvp[i - 2] = NULL;

			status = callsubr(tpvp, reclevel, e);
			if (rstat == EX_OK || status == EX_TEMPFAIL)
				rstat = status;

			/*
			**  Now we need to call the ruleset specified for
			**  the subroutine. we can do this with the
			**  temporary buffer that we set up earlier,
			**  since it has all the data we want to rewrite.
			*/

			status = rewrite(tpvp, subr, reclevel, e);
			if (rstat == EX_OK || status == EX_TEMPFAIL)
				rstat = status;

			/*
			**  Find length of tpvp and current offset into
			**  pvp, if the total is greater than MAXATOM,
			**  then it would overflow the buffer if we copied
			**  it back in to pvp, in which case we throw a
			**  fit.
			*/

			for (rvp = tpvp; *rvp != NULL; rvp++)
d1595 2
a1596 1
			if (((rvp - tpvp) + (avp - pvp)) > MAXATOM)
d1598 3
a1600 2
				syserr("554 5.3.0 callsubr: expansion too long");
				return EX_DATAERR;
d1602 10
d1613 4
a1616 4
			/*
			**  Now we can copy the rewritten code over
			**  the initial subroutine call in the buffer.
			*/
d1618 4
a1621 3
			for (i = 0; tpvp[i] != NULL; i++)
				avp[i] = tpvp[i];
			avp[i] = NULL;
d1623 5
a1627 5
			/*
			**  If we got this far, we've processed the left
			**  most subroutine, and recursively called ourselves
			**  to handle any other subroutines.  We're done.
			*/
d1629 6
a1634 2
			break;
		}
d1642 1
a1642 1
**		map -- the map to use for the lookup.
d1677 1
a1677 1
			dprintf("map_lookup(%s, %s) => DEFERRED\n",
d1688 1
a1688 1
		dprintf("map_lookup(%s, %s", smap->s_name, key);
d1694 1
a1694 1
				dprintf(", %%%d=%s", i, argvect[i]);
d1696 1
a1696 1
		dprintf(") => ");
d1700 1
a1700 1
		dprintf("%s (%d)\n",
d1709 1
a1709 1
			dprintf("map_lookup(%s, %s) tempfail: errno=%d\n",
d1715 1
a1715 1
			snprintf(mbuf, sizeof mbuf,
d1719 1
a1719 1
			e->e_message = newstr(mbuf);
d1733 1
a1733 1
			rwbuf = (char *) xalloc(rwbuflen);
d1735 1
a1735 1
		snprintf(rwbuf, rwbuflen, "%s%s", key, map->map_tapp);
d1737 1
a1737 1
			dprintf("map_lookup tempfail: returning \"%s\"\n",
a1810 1
#ifdef EX_CONFIG
a1811 1
#endif /* EX_CONFIG */
a1814 1

d1832 1
a1832 1
		dprintf("buildaddr, flags=%x, tv=", flags);
d1837 1
a1837 1
		a = (ADDRESS *) xalloc(sizeof *a);
d1879 1
a1879 1
	if (strcasecmp(mname, "error") == 0)
d1883 2
a1884 1
		a->q_user = newstr(ubuf);
d1890 1
a1890 1
			a->q_host = newstr(hbuf);
d1893 2
a1894 1
				a->q_status = newstr(hbuf);
d1904 1
a1904 1
					if (strcasecmp(ep->ec_name, hbuf) == 0)
d1930 1
a1930 1
			(void) snprintf(fmt, sizeof fmt, "%s %%s", ubuf);
d1948 1
a1948 1
		if (strcasecmp(m->m_name, mname) == 0)
d1969 1
a1969 1
		a->q_host = newstr(hbuf);
d1991 1
a1991 1
		if (strncasecmp(ubuf, ":include:", 9) == 0)
d1995 1
a1995 1
			a->q_user = newstr(&ubuf[9]);
d2001 1
a2001 1
	define('h', a->q_host, e);
d2003 1
a2003 7
#if _FFR_ADDR_TYPE
	/*
	**  Note, change the 9 to a 10 before removing #if FFR check
	**  in a future version.
	*/

	if (ConfigLevel >= 9 ||
a2004 3
#else /* _FFR_ADDR_TYPE */
	if (!bitset(RF_SENDERADDR|RF_HEADERADDR, flags))
#endif /* _FFR_ADDR_TYPE */
d2007 1
a2007 1
		(void) rewrite(tv, 2, 0, e);
d2009 1
a2009 1
		       (void) rewrite(tv, m->m_re_rwset, 0, e);
d2011 1
a2011 1
	(void) rewrite(tv, 4, 0, e);
d2015 1
a2015 1
	a->q_user = newstr(ubuf);
d2028 2
a2029 2
		dprintf("buildaddr => ");
		printaddr(a, FALSE);
d2042 1
a2042 1
**		spacesub -- the space separator character; if null,
d2060 2
a2061 2
	bool oatomtok = FALSE;
	bool natomtok = FALSE;
d2078 1
a2078 1
	while (*pvp != NULL && (i = strlen(*pvp)) < sz - 1)
d2084 2
a2085 1
			--sz;
d2087 2
a2088 1
		(void) strlcpy(p, *pvp, sz);
d2107 2
a2108 2
**		TRUE -- they represent the same mailbox.
**		FALSE -- they don't.
d2123 1
a2123 1
		return FALSE;
d2127 1
a2127 1
		return FALSE;
d2137 1
a2137 1
			return FALSE;
d2144 1
a2144 1
		return TRUE;
d2149 1
a2149 1
		return FALSE;
d2152 1
a2152 1
		return FALSE;
d2154 1
a2154 1
	return TRUE;
d2172 2
a2173 2
	char	*qf_name;
	u_long	qf_bit;
d2209 1
a2209 1
		printf("[NULL]\n");
d2215 2
a2216 2
		printf("%lx=", (u_long) a);
		(void) fflush(stdout);
d2227 10
a2236 8
		printf("%s:\n\tmailer %d (%s), host `%s'\n",
		       a->q_paddr == NULL ? "<null>" : a->q_paddr,
		       m->m_mno, m->m_name,
		       a->q_host == NULL ? "<null>" : a->q_host);
		printf("\tuser `%s', ruser `%s'\n",
		       a->q_user,
		       a->q_ruser == NULL ? "<null>" : a->q_ruser);
		printf("\tstate=");
d2240 1
a2240 1
			printf("OK");
d2244 2
a2245 1
			printf("DONTSEND");
d2249 2
a2250 1
			printf("BADADDR");
d2254 6
a2259 1
			printf("QUEUEUP");
d2263 1
a2263 1
			printf("SENT");
d2267 2
a2268 1
			printf("VERIFIED");
d2272 2
a2273 1
			printf("EXPANDED");
d2277 2
a2278 1
			printf("SENDER");
d2282 2
a2283 1
			printf("CLONED");
d2287 2
a2288 1
			printf("DISCARDED");
d2292 2
a2293 1
			printf("REPLACED");
d2297 2
a2298 1
			printf("REMOVED");
d2302 2
a2303 1
			printf("DUPLICATE");
d2307 2
a2308 1
			printf("INCLUDED");
d2312 2
a2313 1
			printf("%d", a->q_state);
d2316 7
a2322 5
		printf(", next=%lx, alias %lx, uid %d, gid %d\n",
		       (u_long) a->q_next, (u_long) a->q_alias,
		       (int) a->q_uid, (int) a->q_gid);
		printf("\tflags=%lx<", a->q_flags);
		firstone = TRUE;
d2328 26
a2353 18
				printf(",");
			firstone = FALSE;
			printf("%s", qfp->qf_name);
		}
		printf(">\n");
		printf("\towner=%s, home=\"%s\", fullname=\"%s\"\n",
		       a->q_owner == NULL ? "(none)" : a->q_owner,
		       a->q_home == NULL ? "(none)" : a->q_home,
		       a->q_fullname == NULL ? "(none)" : a->q_fullname);
		printf("\torcpt=\"%s\", statmta=%s, status=%s\n",
		       a->q_orcpt == NULL ? "(none)" : a->q_orcpt,
		       a->q_statmta == NULL ? "(none)" : a->q_statmta,
		       a->q_status == NULL ? "(none)" : a->q_status);
		printf("\trstatus=\"%s\"\n",
		       a->q_rstatus == NULL ? "(none)" : a->q_rstatus);
		printf("\tspecificity=%d, statdate=%s\n",
		       a->q_specificity,
		       a->q_statdate == 0 ? "(none)" : ctime(&a->q_statdate));
d2361 1
a2361 1
**  EMPTYADDR -- return TRUE if this address is empty (``<>'')
d2367 1
a2367 1
**		TRUE -- if this address is "empty" (i.e., no one should
d2369 1
a2369 1
**		FALSE -- if it is a "regular" (read: replyable) address.
d2411 2
a2412 2
	char *fancy;
	char *oldg = macvalue('g', e);
a2416 1
#if _FFR_ADDR_TYPE
a2417 1
#endif /* _FFR_ADDR_TYPE */
d2420 1
a2420 1
		dprintf("remotename(%s)\n", name);
a2426 1
#if _FFR_ADDR_TYPE
a2427 1
#endif /* _FFR_ADDR_TYPE */
a2432 1
#if _FFR_ADDR_TYPE
a2433 1
#endif /* _FFR_ADDR_TYPE */
a2436 1
#if _FFR_ADDR_TYPE
d2440 1
a2440 2
	define(macid("{addr_type}", NULL), addrtype, e);
#endif /* _FFR_ADDR_TYPE */
d2463 1
a2463 1
	if (rewrite(pvp, 3, 0, e) == EX_TEMPFAIL)
d2492 1
a2492 1
			if (rewrite(pvp, 3, 0, e) == EX_TEMPFAIL)
d2506 1
a2506 1
		if (rewrite(pvp, 1, 0, e) == EX_TEMPFAIL)
d2511 1
a2511 1
		if (rewrite(pvp, 2, 0, e) == EX_TEMPFAIL)
d2516 1
a2516 1
		if (rewrite(pvp, rwset, 0, e) == EX_TEMPFAIL)
d2527 1
a2527 1
	if (rewrite(pvp, 4, 0, e) == EX_TEMPFAIL)
d2535 2
a2536 1
	define('g', lbuf, e);
d2538 9
a2546 7
	/* need to make sure route-addrs have <angle brackets> */
	if (bitset(RF_CANONICAL, flags) && lbuf[0] == '@@')
		expand("<\201g>", buf, sizeof buf, e);
	else
		expand(fancy, buf, sizeof buf, e);

	define('g', oldg, e);
d2549 1
a2549 1
		dprintf("remotename => `%s'\n", buf);
d2568 2
a2569 1
			 QRELAYED|QEXPANDED|QDELIVERED|QDELAYED)
d2585 2
a2586 2
		dprintf("maplocaluser: ");
		printaddr(a, FALSE);
d2592 1
a2592 1
			dprintf("maplocaluser: cannot prescan %s\n",
d2597 6
a2602 8
	define('h', a->q_host, e);
	define('u', a->q_user, e);
	define('z', a->q_home, e);

#if _FFR_ADDR_TYPE
	define(macid("{addr_type}", NULL), "e r", e);
#endif /* _FFR_ADDR_TYPE */
	if (rewrite(pvp, 5, 0, e) == EX_TEMPFAIL)
d2605 1
a2605 1
			dprintf("maplocaluser: rewrite tempfail\n");
d2613 1
a2613 1
			dprintf("maplocaluser: doesn't resolve\n");
d2617 13
a2630 1
	a1 = buildaddr(pvp, NULL, 0, e);
d2634 1
a2634 3
			dprintf("maplocaluser: address unchanged\n");
		if (a1 != NULL)
			sm_free(a1);
d2641 2
a2642 1
	a1->q_paddr = newstr(a->q_paddr);
d2649 2
a2650 2
		dprintf("maplocaluser: QS_REPLACED ");
		printaddr(a, FALSE);
d2653 1
a2653 1
	allocaddr(a1, RF_COPYALL, newstr(a->q_paddr));
a2658 2
**	This is a no-op.
**
d2664 1
a2664 1
**		TRUE.
d2705 1
a2705 1
	return TRUE;
d2737 2
a2738 2
	bool quotemode = FALSE;
	bool bslashmode = FALSE;
d2745 1
a2745 1
			bslashmode = FALSE;
d2756 1
a2756 1
			bslashmode = TRUE;
d2815 1
a2815 1
**		logl -- logging level
d2817 1
d2825 1
a2825 1
rscheck(rwset, p1, p2, e, rmcomm, cnt, logl, host)
d2833 1
d2835 1
a2835 1
	char *buf;
d2838 1
a2838 1
	int rstat = EX_OK;
d2841 1
a2841 1
	bool discard = FALSE;
d2850 1
a2850 1
		dprintf("rscheck(%s, %s, %s)\n", rwset, p1,
d2861 1
a2861 1
			buf = xalloc(bufsize);
d2867 1
a2867 1
		(void) snprintf(buf, bufsize, "%s%c%s", p1, CONDELSE, p2);
d2873 1
a2873 1
			buf = xalloc(bufsize);
d2879 1
a2879 1
		(void) snprintf(buf, bufsize, "%s", p1);
d2881 1
a2881 6
	SuprErrs = TRUE;
	QuickAbort = FALSE;
	pvp = prescan(buf, '\0', pvpbuf, sizeof pvpbuf, NULL,
		      rmcomm ? NULL : TokTypeNoC);
	SuprErrs = saveSuprErrs;
	if (pvp == NULL)
d2883 88
a2970 8
		if (tTd(48, 2))
			dprintf("rscheck: cannot prescan input\n");
/*
		syserr("rscheck: cannot prescan input: \"%s\"",
			shortenstring(buf, MAXSHORTSTR));
		rstat = EX_DATAERR;
*/
		goto finis;
d2972 1
a2972 4

	MapOpenErr = FALSE;
	(void) rewrite(pvp, rsno, 0, e);
	if (MapOpenErr)
d2974 4
a2977 3
  		usrerrenh("4.3.0", "451 Temporary failure");
		rstat = EX_TEMPFAIL;
		goto finis;
d2979 1
d2981 51
a3031 6
	if (pvp[0] == NULL || (pvp[0][0] & 0377) != CANONNET ||
	    pvp[1] == NULL || (strcmp(pvp[1], "error") != 0 &&
			       strcmp(pvp[1], "discard") != 0))
	{
		goto finis;
	}
d3033 1
a3033 1
	if (strcmp(pvp[1], "discard") == 0)
d3035 9
a3043 4
		if (tTd(48, 2))
			dprintf("rscheck: discard mailer selected\n");
		e->e_flags |= EF_DISCARD;
		discard = TRUE;
d3047 4
a3050 11
		int savelogusrerrs = LogUsrErrs;
		static bool logged = FALSE;

		/* got an error -- process it */
		saveexitstat = ExitStat;
		LogUsrErrs = FALSE;
		(void) buildaddr(pvp, &a1, 0, e);
		LogUsrErrs = savelogusrerrs;
		rstat = ExitStat;
		ExitStat = saveexitstat;
		if (!logged)
d3052 2
a3053 3
			if (cnt)
				markstats(e, &a1, TRUE);
			logged = TRUE;
d3055 1
d3057 1
a3057 2

	if (LogLevel >= logl)
d3059 6
a3064 6
		char *relay;
		char *p;
		char lbuf[MAXLINE];

		p = lbuf;
		if (p2 != NULL)
d3066 3
a3068 4
			snprintf(p, SPACELEFT(lbuf, p),
				", arg2=%s",
				p2);
			p += strlen(p);
d3070 8
d3079 2
a3080 19
		if (host != NULL)
			relay = host;
		else
			relay = macvalue('_', e);
		if (relay != NULL)
		{
			snprintf(p, SPACELEFT(lbuf, p),
				", relay=%s", relay);
			p += strlen(p);
		}
		*p = '\0';
		if (discard)
			sm_syslog(LOG_NOTICE, e->e_id,
				  "ruleset=%s, arg1=%s%s, discard",
				  rwset, p1, lbuf);
		else
			sm_syslog(LOG_NOTICE, e->e_id,
				  "ruleset=%s, arg1=%s%s, reject=%s",
				  rwset, p1, lbuf, MsgBuf);
d3082 1
a3082 10

 finis:
	/* clean up */
	QuickAbort = saveQuickAbort;
	setstat(rstat);
	if (buf != buf0)
		sm_free(buf);

	if (rstat != EX_OK && QuickAbort)
		longjmp(TopFrame, 2);
@


1.5
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: parseaddr.c,v 8.234.4.12 2001/05/03 17:24:11 gshapiro Exp $";
a768 3

#define MAXMATCH	9	/* max params per rewrite */

@


1.4
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: parseaddr.c,v 8.234.4.11 2001/02/14 04:07:27 gshapiro Exp $";
d1160 1
a1160 1
							free(pvpb1);
d1586 1
a1586 1
				free(rwbuf);
d2464 1
a2464 1
			free(a1);
d2811 1
a2811 1
		free(buf);
@


1.4.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: parseaddr.c,v 8.234.4.12 2001/05/03 17:24:11 gshapiro Exp $";
d1160 1
a1160 1
							sm_free(pvpb1);
d1586 1
a1586 1
				sm_free(rwbuf);
d2464 1
a2464 1
			sm_free(a1);
d2811 1
a2811 1
		sm_free(buf);
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: parseaddr.c,v 8.234.4.9 2000/10/09 03:14:48 gshapiro Exp $";
d2730 5
a2734 1
		usrerrenh("4.3.0", "451 Temporary failure");
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: parseaddr.c,v 8.234 2000/03/17 07:32:48 gshapiro Exp $";
d1157 1
a1157 1
					if (trsize > pvpb1_size)
d2057 1
a2057 1
	{ NULL }
d2647 1
d2655 1
a2655 1
rscheck(rwset, p1, p2, e, rmcomm, cnt, logl)
d2662 1
d2726 2
d2729 3
d2780 6
a2785 1
		if ((relay = macvalue('_', e)) != NULL)
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: parseaddr.c,v 8.234.4.12 2001/05/03 17:24:11 gshapiro Exp $";
d1157 1
a1157 1
					if ((size_t) trsize > pvpb1_size)
d1160 1
a1160 1
							sm_free(pvpb1);
d1586 1
a1586 1
				sm_free(rwbuf);
d2057 1
a2057 1
	{ NULL,			0		}
d2464 1
a2464 1
			sm_free(a1);
a2646 1
**		host -- NULL or relay host.
d2654 1
a2654 1
rscheck(rwset, p1, p2, e, rmcomm, cnt, logl, host)
a2660 1
	char *host;
a2723 2

	MapOpenErr = FALSE;
a2724 7
	if (MapOpenErr)
	{
  		usrerrenh("4.3.0", "451 Temporary failure");
		rstat = EX_TEMPFAIL;
		goto finis;
	}

d2773 1
a2773 6

		if (host != NULL)
			relay = host;
		else
			relay = macvalue('_', e);
		if (relay != NULL)
d2795 1
a2795 1
		sm_free(buf);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1998, 1999 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: parseaddr.c,v 8.231 1999/12/06 21:48:51 ca Exp $";
d1066 1
a1066 1
		if ((*rp & 0377) == CANONUSER)
d1068 12
a1079 9
			rvp++;
			rwr = rwr->r_next;
			ruleno++;
			loopcount = 0;
		}
		else if ((*rp & 0377) == CANONHOST)
		{
			rvp++;
			rwr = NULL;
d2646 1
d2654 1
a2654 1
rscheck(rwset, p1, p2, e, rmcomm, cnt)
d2660 1
d2759 1
a2759 1
	if (LogLevel >= 4)
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Id: parseaddr.c,v 8.234.4.9 2000/10/09 03:14:48 gshapiro Exp $";
d1066 1
a1066 1
		if (rp != NULL)
d1068 9
a1076 12
			if ((*rp & 0377) == CANONUSER)
			{
				rvp++;
				rwr = rwr->r_next;
				ruleno++;
				loopcount = 0;
			}
			else if ((*rp & 0377) == CANONHOST)
			{
				rvp++;
				rwr = NULL;
			}
d1154 1
a1154 1
					if ((size_t) trsize > pvpb1_size)
d2054 1
a2054 1
	{ NULL,			0		}
a2642 2
**		logl -- logging level
**		host -- NULL or relay host.
d2650 1
a2650 1
rscheck(rwset, p1, p2, e, rmcomm, cnt, logl, host)
a2655 2
	int logl;
	char *host;
a2718 2

	MapOpenErr = FALSE;
a2719 3
	if (MapOpenErr)
		usrerrenh("4.3.0", "451 Temporary failure");

d2754 1
a2754 1
	if (LogLevel >= logl)
d2768 1
a2768 6

		if (host != NULL)
			relay = host;
		else
			relay = macvalue('_', e);
		if (relay != NULL)
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d14 4
d20 1
a20 3
SM_RCSID("@@(#)$Sendmail: parseaddr.c,v 8.340 2001/09/04 22:43:04 ca Exp $")

static void	allocaddr __P((ADDRESS *, int, char *, ENVELOPE *));
a23 1
static bool	hasctrlchar __P((register char *, bool));
d42 1
a42 1
**			If NULL, an address will be created.
a49 2
**		isrcpt -- true if the address denotes a recipient; false
**			indicates a sender.
d57 1
a57 1
**		e->e_to = addr
d64 1
a64 1
parseaddr(addr, a, flags, delim, delimptr, e, isrcpt)
a70 1
	bool isrcpt;
d72 1
a72 1
	char **pvp;
d83 1
a83 1
		sm_dprintf("\n--parseaddr(%s)\n", addr);
d92 1
a92 1
			sm_dprintf("parseaddr-->NULL\n");
d96 1
a96 1
	if (invalidaddr(addr, delim == '\0' ? NULL : *delimptr, isrcpt))
d99 1
a99 1
			sm_dprintf("parseaddr-->bad address\n");
d117 1
a117 1
		e->e_to = addr = sm_rpool_strdup_x(e->e_rpool, addr);
d127 6
a132 5
	qup = false;
	if (REWRITE(pvp, 3, e) == EX_TEMPFAIL)
		qup = true;
	if (REWRITE(pvp, 0, e) == EX_TEMPFAIL)
		qup = true;
a139 7
	if (hasctrlchar(a->q_user, isrcpt))
	{
		if (tTd(20, 1))
			sm_dprintf("parseaddr-->bad q_user\n");
		return NULL;
	}

d145 1
a145 1
	allocaddr(a, flags, addr, e);
a149 34
	**  Select a queue directory for recipient addresses.
	**	This is done here and in split_across_queue_groups(),
	**	but the latter applies to addresses after aliasing,
	**	and only if splitting is done.
	*/

	if ((a->q_qgrp == NOAQGRP || a->q_qgrp == ENVQGRP) &&
	    !bitset(RF_SENDERADDR|RF_HEADERADDR, flags) &&
	    OpMode != MD_INITALIAS)
	{
		int r;

		/* call ruleset which should return a queue group name */
		r = rscap(RS_QUEUEGROUP, a->q_user, NULL, e, &pvp, pvpbuf,
			  sizeof(pvpbuf));
		if (r == EX_OK &&
		    pvp != NULL && pvp[0] != NULL &&
		    (pvp[0][0] & 0377) == CANONNET &&
		    pvp[1] != NULL && pvp[1][0] != '\0')
		{
			r = name2qid(pvp[1]);
			if (r == NOQGRP && LogLevel > 10)
				sm_syslog(LOG_INFO, NOQID,
					"can't find queue group name %s, selection ignored",
					pvp[1]);
			if (tTd(20, 4) && r != NOQGRP)
				sm_syslog(LOG_INFO, NOQID,
					"queue group name %s -> %d",
					pvp[1], r);
			a->q_qgrp = r == NOQGRP ? ENVQGRP : r;
		}
	}

	/*
d160 1
a160 1
			sm_dprintf("parseaddr: queuing message\n");
d163 1
a163 1
			e->e_message = sm_rpool_strdup_x(e->e_rpool, msg);
d174 2
a175 2
		sm_dprintf("parseaddr-->");
		printaddr(a, false);
d181 1
a181 1
**  INVALIDADDR -- check for address containing characters used for macros
a184 3
**		delimptr -- if non-NULL: end of address to check, i.e.,
**			a pointer in the address string.
**		isrcpt -- true iff the address is for a recipient.
d187 2
a188 3
**		true -- if the address has characters that are reservered
**			for macros or is too long.
**		false -- otherwise.
d192 1
a192 1
invalidaddr(addr, delimptr, isrcpt)
a194 1
	bool isrcpt;
a195 1
	bool result = false;
a196 1
	int len = 0;
a199 1
		/* delimptr points to the end of the address to test */
d201 2
a202 2
		if (savedelim != '\0')	/* if that isn't '\0' already: */
			*delimptr = '\0';	/* set it */
d204 1
a204 1
	for (; *addr != '\0'; addr++)
d206 3
a208 20
		if ((*addr & 0340) == 0200)
		{
			setstat(EX_USAGE);
			result = true;
			break;
		}
		if (++len > MAXNAME - 1)
		{
			usrerr("553 5.1.0 Address too long (%d bytes max)",
			       MAXNAME - 1);
			result = true;
			goto delim;
		}
	}
	if (result)
	{
		if (isrcpt)
			usrerr("501 5.1.3 Syntax error in mailbox address");
		else
			usrerr("501 5.1.7 Syntax error in mailbox address");
a209 34
delim:
	if (delimptr != NULL && savedelim != '\0')
		*delimptr = savedelim;	/* restore old character at delimptr */
	return result;
}
/*
**  HASCTRLCHAR -- check for address containing meta-characters
**
**  Checks that the address contains no meta-characters, and contains
**  no "non-printable" characters unless they are quoted or escaped.
**  Quoted or escaped characters are literals.
**
**	Parameters:
**		addr -- the address to check.
**		isrcpt -- true if the address is for a recipient; false
**			indicates a from.
**
**	Returns:
**		true -- if the address has any "wierd" characters or
**			non-printable characters or if a quote is unbalanced.
**		false -- otherwise.
*/

static bool
hasctrlchar(addr, isrcpt)
	register char *addr;
	bool isrcpt;
{
	bool result = false;
	int len = 0;
	bool quoted = false;

	if (addr == NULL)
		return false;
a211 16
		if (!quoted && (*addr < 32 || *addr == 127))
		{
			result = true;	/* a non-printable */
			break;
		}
		if (*addr == '"')
			quoted = !quoted;
		else if (*addr == '\\')
		{
			/* XXX Generic problem: no '\0' in strings. */
			if (*++addr == '\0')
			{
				result = true;
				break;
			}
		}
a212 3
		{
			setstat(EX_USAGE);
			result = true;
a213 7
		}
		if (++len > MAXNAME - 1)
		{
			usrerr("553 5.1.0 Address too long (%d bytes max)",
			       MAXNAME - 1);
			return true;
		}
d215 1
a215 3
	if (quoted)
		result = true; /* unbalanced quote */
	if (result)
d217 10
a226 6
		if (isrcpt)
			usrerr("501 5.1.3 Syntax error in mailbox address");
		else
			usrerr("501 5.1.7 Syntax error in mailbox address");
	}
	return result;
a237 1
**		e -- envelope
d247 1
a247 1
allocaddr(a, flags, paddr, e)
a250 1
	ENVELOPE *e;
d253 1
a253 1
		sm_dprintf("allocaddr(flags=%x, paddr=%s)\n", flags, paddr);
d258 1
a258 1
		a->q_user = "";
d260 1
a260 1
		a->q_host = "";
d264 1
a264 1
		a->q_host = sm_rpool_strdup_x(e->e_rpool, a->q_host);
d266 1
a266 1
			a->q_user = sm_rpool_strdup_x(e->e_rpool, a->q_user);
d270 1
a270 2
		a->q_paddr = sm_rpool_strdup_x(e->e_rpool, a->q_user);
	a->q_qgrp = NOAQGRP;
d335 1
a335 1
static unsigned char	TokTypeTab[256] =
d373 1
a373 1
unsigned char	MimeTokenTab[256] =
d411 1
a411 1
unsigned char	TokTypeNoC[256] =
d458 1
a458 1
	unsigned char *toktab;
d473 1
a473 1
	static bool firsttime = true;
d481 1
a481 1
		firsttime = false;
d491 1
a491 1
		(void) sm_strlcat(obuf, DELIMCHARS, sizeof obuf);
d507 2
a508 2
	bslashmode = false;
	route_syntax = false;
d518 1
a518 1
		sm_dprintf("prescan: ");
d520 1
a520 1
		sm_dprintf("\n");
d536 1
a536 1
					if (strlen(addr) > MAXNAME)
d556 1
a556 1
					usrerr("553 Unbalanced '\"'");
d561 1
a561 1
					usrerr("553 Unbalanced '('");
d567 1
a567 1
					usrerr("553 Unbalanced '<'");
d582 1
a582 1
					usrerr("553 Unbalanced '<'");
d589 1
a589 1
				sm_dprintf("c=%c, s=%d; ", c, state);
d595 1
a595 1
				bslashmode = false;
d612 1
a612 1
				bslashmode = true;
d628 1
a628 1
					usrerr("553 Unbalanced ')'");
d646 1
a646 1
					route_syntax = true;
d652 1
a652 1
					usrerr("553 Unbalanced '>'");
d657 1
a657 1
				route_syntax = false;
d671 1
a671 1
				sm_dprintf("ns=%02o\n", newstate);
d676 1
a676 1
					usrerr("553 Illegal character %c", c);
d678 1
a678 1
					usrerr("553 Illegal character 0x%02x", c);
d692 1
a692 1
				sm_dprintf("tok=");
d694 1
a694 1
				sm_dprintf("\n");
d715 1
a715 1
		sm_dprintf("prescan==>");
d722 1
a722 1
			sm_dprintf("prescan: null leading token\n");
a753 1
**		maxatom -- maximum length of buffer (usually MAXATOM)
d770 3
d774 1
a774 1
rewrite(pvp, ruleset, reclevel, e, maxatom)
a778 1
	int maxatom;
d804 1
a804 1
		(void) sm_snprintf(name, sizeof name, "%d", ruleset);
d813 1
a813 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "%s%-16.16s   input:", prefix, rulename);
d818 1
a818 1
		sm_dprintf("%s%-16.16s   input:", prefix, rulename);
d848 1
a848 1
				sm_dprintf("-----trying rule (line %d):",
d851 1
a851 1
				sm_dprintf("-----trying rule:");
d865 1
a865 1
				sm_dprintf("workspace: ");
d876 1
a876 1
				sm_dprintf("ADVANCE rp=");
d878 1
a878 1
				sm_dprintf(", ap=");
d880 1
a880 1
				sm_dprintf("\n");
d911 1
a911 1
						sm_dprintf("EXTEND  rp=");
d913 1
a913 1
						sm_dprintf(", ap=");
d915 1
a915 1
						sm_dprintf("\n");
d920 1
a920 1
					sm_dprintf("CLMATCH\n");
d964 1
a964 1
					sm_dprintf("rewrite: LHS $&%s => \"%s\"\n",
d973 1
a973 2
					    sm_strncasecmp(ap, *avp,
							   strlen(*avp)) != 0)
d1008 1
a1008 1
					sm_dprintf("BACKUP  rp=");
d1010 1
a1010 1
					sm_dprintf(", ap=");
d1012 1
a1012 1
					sm_dprintf("\n");
d1051 1
a1051 1
				sm_dprintf("----- rule fails\n");
d1061 1
a1061 1
			sm_dprintf("-----rule matches:");
d1101 1
a1101 1
					sm_dprintf("$%c:", rp[1]);
d1105 4
a1108 3
						sm_dprintf(" %p=\"", *pp);
						sm_dflush();
						sm_dprintf("%s\"", *pp++);
d1110 1
a1110 1
					sm_dprintf("\n");
d1115 1
a1115 1
					if (avp >= &npvp[maxatom])
a1117 6
						if (LogLevel > 9)
							sm_syslog(LOG_ERR,
								e->e_id,
								"rewrite: expansion too long, ruleset=%s, ruleno=%d",
								rulename,
								ruleno);
d1126 1
a1126 1
				if (avp >= &npvp[maxatom])
a1129 4
					if (LogLevel > 9)
						sm_syslog(LOG_ERR, e->e_id,
							"rewrite: expansion too long, ruleset=%s, ruleno=%d",
							rulename, ruleno);
d1148 1
a1148 1
						sm_dprintf("rewrite: RHS $&%s => \"%s\"\n",
d1160 2
a1161 3
							sm_free(pvpb1);
						pvpb1 = (char **)
							sm_pmalloc_x(trsize);
d1183 1
a1183 1
							sm_dprintf(" ... %s\n",
d1185 2
a1186 3
						*avp++ = sm_rpool_strdup_x(
							e->e_rpool, *xpvp);
						if (avp >= &npvp[maxatom])
d1191 1
a1191 1
						sm_dprintf(" ... DONE\n");
d1341 2
a1342 2
				*avp++ = sm_rpool_strdup_x(e->e_rpool, *xpvp);
				if (avp >= &npvp[maxatom])
d1349 1
a1349 1
				if (avp >= &npvp[maxatom])
d1369 1
a1369 1
			sm_dprintf("rewritten as:");
d1376 1
a1376 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "%s%-16.16s returns:", prefix, rulename);
d1381 1
a1381 1
		sm_dprintf("%s%-16.16s returns:", prefix, rulename);
d1408 1
d1410 1
a1410 2
	int subr, j;
	int nsubr;
d1413 1
a1413 3
#define MAX_SUBR	16
	int subrnumber[MAX_SUBR];
	int subrindex[MAX_SUBR];
d1415 1
a1415 10
	nsubr = 0;

	/*
	**  Look for subroutine calls in pvp, collect them into subr*[]
	**  We will perform the calls in the next loop, because we will
	**  call the "last" subroutine first to avoid recursive calls
	**  and too much copying.
	*/

	for (avp = pvp, j = 0; *avp != NULL; avp++, j++)
d1423 1
a1423 1
				syserr("554 5.3.5 Unknown ruleset %s", avp[1]);
d1427 4
d1432 4
a1435 3
			**  XXX instead of doing this we could optimize
			**  the rules after reading them: just remove
			**  calls to empty rulesets
d1438 28
a1465 9
			/* subroutine is an empty ruleset?  don't call it */
			if (RewriteRules[subr] == NULL)
			{
				if (tTd(21, 3))
					sm_dprintf("-----skip subr %s (%d)\n",
						avp[1], subr);
				for (i = 2; avp[i] != NULL; i++)
					avp[i - 2] = avp[i];
				avp[i - 2] = NULL;
d1467 1
a1467 2
			}
			if (++nsubr >= MAX_SUBR)
d1469 2
a1470 3
				syserr("554 5.3.0 Too many subroutine calls (%d max)",
					MAX_SUBR);
				return EX_CONFIG;
a1471 4
			subrnumber[nsubr] = subr;
			subrindex[nsubr] = j;
		}
	}
d1473 4
a1476 5
	/*
	**  Perform the actual subroutines calls, "last" one first, i.e.,
	**  go from the right to the left through all calls,
	**  do the rewriting in place.
	*/
d1478 3
a1480 4
	for (; nsubr > 0; nsubr--)
	{
		subr = subrnumber[nsubr];
		avp = pvp + subrindex[nsubr];
d1482 5
a1486 4
		/* remove the subroutine call and name */
		for (i = 2; avp[i] != NULL; i++)
			avp[i - 2] = avp[i];
		avp[i - 2] = NULL;
d1488 2
a1489 12
		/*
		**  Now we need to call the ruleset specified for
		**  the subroutine. we can do this inplace since
		**  we call the "last" subroutine first.
		*/

		status = rewrite(avp, subr, reclevel, e,
				MAXATOM - subrindex[nsubr]);
		if (status != EX_OK && status != EX_TEMPFAIL)
			return status;
		if (rstat == EX_OK || status == EX_TEMPFAIL)
			rstat = status;
d1497 1
a1497 1
**		smap -- the map to use for the lookup.
d1532 1
a1532 1
			sm_dprintf("map_lookup(%s, %s) => DEFERRED\n",
d1543 1
a1543 1
		sm_dprintf("map_lookup(%s, %s", smap->s_name, key);
d1549 1
a1549 1
				sm_dprintf(", %%%d=%s", i, argvect[i]);
d1551 1
a1551 1
		sm_dprintf(") => ");
d1555 1
a1555 1
		sm_dprintf("%s (%d)\n",
d1564 1
a1564 1
			sm_dprintf("map_lookup(%s, %s) tempfail: errno=%d\n",
d1570 1
a1570 1
			(void) sm_snprintf(mbuf, sizeof mbuf,
d1574 1
a1574 1
			e->e_message = sm_rpool_strdup_x(e->e_rpool, mbuf);
d1586 1
a1586 1
				sm_free(rwbuf);
d1588 1
a1588 1
			rwbuf = (char *) sm_pmalloc_x(rwbuflen);
d1590 1
a1590 1
		(void) sm_strlcpyn(rwbuf, rwbuflen, 2, key, map->map_tapp);
d1592 1
a1592 1
			sm_dprintf("map_lookup tempfail: returning \"%s\"\n",
d1666 1
d1668 1
d1672 1
d1690 1
a1690 1
		sm_dprintf("buildaddr, flags=%x, tv=", flags);
d1695 1
a1695 1
		a = (ADDRESS *) sm_rpool_malloc_x(e->e_rpool, sizeof *a);
d1737 1
a1737 1
	if (sm_strcasecmp(mname, "error") == 0)
d1741 1
a1741 2
		a->q_user = sm_rpool_strdup_x(e->e_rpool, ubuf);
		/* XXX wrong place? */
d1747 1
a1747 1
			a->q_host = sm_rpool_strdup_x(e->e_rpool, hbuf);
d1750 1
a1750 2
				a->q_status = sm_rpool_strdup_x(e->e_rpool,
								hbuf);
d1760 1
a1760 1
					if (sm_strcasecmp(ep->ec_name, hbuf) == 0)
d1786 1
a1786 1
			(void) sm_strlcpyn(fmt, sizeof fmt, 2, ubuf, " %s");
d1804 1
a1804 1
		if (sm_strcasecmp(m->m_name, mname) == 0)
d1825 1
a1825 1
		a->q_host = sm_rpool_strdup_x(e->e_rpool, hbuf);
d1847 1
a1847 1
		if (sm_strncasecmp(ubuf, ":include:", 9) == 0)
d1851 1
a1851 1
			a->q_user = sm_rpool_strdup_x(e->e_rpool, &ubuf[9]);
d1857 7
a1863 1
	macdefine(&e->e_macro, A_PERM, 'h', a->q_host);
d1865 1
a1865 1
	if (ConfigLevel >= 10 ||
d1867 3
d1872 1
a1872 1
		(void) REWRITE(tv, 2, e);
d1874 1
a1874 1
		       (void) REWRITE(tv, m->m_re_rwset, e);
d1876 1
a1876 1
	(void) REWRITE(tv, 4, e);
d1880 1
a1880 1
	a->q_user = sm_rpool_strdup_x(e->e_rpool, ubuf);
d1893 2
a1894 2
		sm_dprintf("buildaddr => ");
		printaddr(a, false);
d1907 1
a1907 1
**		spacesub -- the space separator character; if '\0',
d1925 2
a1926 2
	bool oatomtok = false;
	bool natomtok = false;
d1943 1
a1943 1
	while (*pvp != NULL && sz > 0)
d1949 1
a1949 2
			if (--sz <= 0)
				break;
d1951 1
a1951 2
		if ((i = sm_strlcpy(p, *pvp, sz)) >= sz)
			break;
d1970 2
a1971 2
**		true -- they represent the same mailbox.
**		false -- they don't.
d1986 1
a1986 1
		return false;
d1990 1
a1990 1
		return false;
d2000 1
a2000 1
			return false;
d2007 1
a2007 1
		return true;
d2012 1
a2012 1
		return false;
d2015 1
a2015 1
		return false;
d2017 1
a2017 1
	return true;
d2035 2
a2036 2
	char		*qf_name;
	unsigned long	qf_bit;
d2072 1
a2072 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "[NULL]\n");
d2078 2
a2079 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%p=", a);
		(void) sm_io_flush(smioout, SM_TIME_DEFAULT);
d2090 8
a2097 10
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "%s:\n\tmailer %d (%s), host `%s'\n",
				     a->q_paddr == NULL ? "<null>" : a->q_paddr,
				     m->m_mno, m->m_name,
				     a->q_host == NULL ? "<null>" : a->q_host);
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "\tuser `%s', ruser `%s'\n",
				     a->q_user,
				     a->q_ruser == NULL ? "<null>" : a->q_ruser);
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "\tstate=");
d2101 1
a2101 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "OK");
d2105 1
a2105 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "DONTSEND");
d2109 1
a2109 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "BADADDR");
d2113 1
a2113 6
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "QUEUEUP");
			break;

		  case QS_RETRY:
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "RETRY");
d2117 1
a2117 1
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "SENT");
d2121 1
a2121 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "VERIFIED");
d2125 1
a2125 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "EXPANDED");
d2129 1
a2129 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "SENDER");
d2133 1
a2133 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "CLONED");
d2137 1
a2137 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "DISCARDED");
d2141 1
a2141 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "REPLACED");
d2145 1
a2145 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "REMOVED");
d2149 1
a2149 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "DUPLICATE");
d2153 1
a2153 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "INCLUDED");
d2157 1
a2157 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "%d", a->q_state);
d2160 5
a2164 7
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     ", next=%p, alias %p, uid %d, gid %d\n",
				     a->q_next, a->q_alias,
				     (int) a->q_uid, (int) a->q_gid);
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "\tflags=%lx<",
				     a->q_flags);
		firstone = true;
d2170 18
a2187 26
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     ",");
			firstone = false;
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s",
					     qfp->qf_name);
		}
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, ">\n");
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "\towner=%s, home=\"%s\", fullname=\"%s\"\n",
				     a->q_owner == NULL ? "(none)" : a->q_owner,
				     a->q_home == NULL ? "(none)" : a->q_home,
				     a->q_fullname == NULL ? "(none)" : a->q_fullname);
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "\torcpt=\"%s\", statmta=%s, status=%s\n",
				     a->q_orcpt == NULL ? "(none)" : a->q_orcpt,
				     a->q_statmta == NULL ? "(none)" : a->q_statmta,
				     a->q_status == NULL ? "(none)" : a->q_status);
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "\tfinalrcpt=\"%s\"\n",
				     a->q_finalrcpt == NULL ? "(none)" : a->q_finalrcpt);
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "\trstatus=\"%s\"\n",
				     a->q_rstatus == NULL ? "(none)" : a->q_rstatus);
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "\tstatdate=%s\n",
				     a->q_statdate == 0 ? "(none)" : ctime(&a->q_statdate));
d2195 1
a2195 1
**  EMPTYADDR -- return true if this address is empty (``<>'')
d2201 1
a2201 1
**		true -- if this address is "empty" (i.e., no one should
d2203 1
a2203 1
**		false -- if it is a "regular" (read: replyable) address.
d2245 2
a2246 2
	char *SM_NONVOLATILE fancy;
	char *oldg;
d2251 1
d2253 1
d2256 1
a2256 1
		sm_dprintf("remotename(%s)\n", name);
d2263 1
d2265 1
d2271 1
d2273 1
d2277 1
d2281 2
a2282 1
	macdefine(&e->e_macro, A_TEMP, macid("{addr_type}"), addrtype);
d2305 1
a2305 1
	if (REWRITE(pvp, 3, e) == EX_TEMPFAIL)
d2334 1
a2334 1
			if (REWRITE(pvp, 3, e) == EX_TEMPFAIL)
d2348 1
a2348 1
		if (REWRITE(pvp, 1, e) == EX_TEMPFAIL)
d2353 1
a2353 1
		if (REWRITE(pvp, 2, e) == EX_TEMPFAIL)
d2358 1
a2358 1
		if (REWRITE(pvp, rwset, e) == EX_TEMPFAIL)
d2369 1
a2369 1
	if (REWRITE(pvp, 4, e) == EX_TEMPFAIL)
d2377 1
a2377 2
	oldg = macget(&e->e_macro, 'g');
	macset(&e->e_macro, 'g', lbuf);
d2379 7
a2385 9
	SM_TRY
		/* need to make sure route-addrs have <angle brackets> */
		if (bitset(RF_CANONICAL, flags) && lbuf[0] == '@@')
			expand("<\201g>", buf, sizeof buf, e);
		else
			expand(fancy, buf, sizeof buf, e);
	SM_FINALLY
		macset(&e->e_macro, 'g', oldg);
	SM_END_TRY
d2388 1
a2388 1
		sm_dprintf("remotename => `%s'\n", buf);
d2407 1
a2407 2
			 QRELAYED|QEXPANDED|QDELIVERED|QDELAYED|\
			 QBYTRACE|QBYNDELAY|QBYNRELAY)
d2423 2
a2424 2
		sm_dprintf("maplocaluser: ");
		printaddr(a, false);
d2430 1
a2430 1
			sm_dprintf("maplocaluser: cannot prescan %s\n",
d2435 8
a2442 6
	macdefine(&e->e_macro, A_PERM, 'h', a->q_host);
	macdefine(&e->e_macro, A_PERM, 'u', a->q_user);
	macdefine(&e->e_macro, A_PERM, 'z', a->q_home);

	macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), "e r");
	if (REWRITE(pvp, 5, e) == EX_TEMPFAIL)
d2445 1
a2445 1
			sm_dprintf("maplocaluser: rewrite tempfail\n");
d2453 1
a2453 1
			sm_dprintf("maplocaluser: doesn't resolve\n");
a2456 13
	SM_TRY
		a1 = buildaddr(pvp, NULL, 0, e);
	SM_EXCEPT(exc, "E:mta.quickabort")

		/*
		**  mark address as bad, S5 returned an error
		**	and we gave that back to the SMTP client.
		*/

		a->q_state = QS_DONTSEND;
		sm_exc_raisenew_x(&EtypeQuickAbort, 2);
	SM_END_TRY

d2458 1
d2462 3
a2464 1
			sm_dprintf("maplocaluser: address unchanged\n");
d2471 1
a2471 2
	a1->q_paddr = sm_rpool_strdup_x(e->e_rpool, a->q_paddr);
	a1->q_finalrcpt = a->q_finalrcpt;
d2478 2
a2479 2
		sm_dprintf("maplocaluser: QS_REPLACED ");
		printaddr(a, false);
d2482 1
a2482 1
	allocaddr(a1, RF_COPYALL, sm_rpool_strdup_x(e->e_rpool, a->q_paddr), e);
d2488 2
d2495 1
a2495 1
**		true.
d2536 1
a2536 1
	return true;
d2568 2
a2569 2
	bool quotemode = false;
	bool bslashmode = false;
d2576 1
a2576 1
			bslashmode = false;
d2587 1
a2587 1
			bslashmode = true;
d2646 1
a2646 1
**		logl -- logging level.
a2647 1
**		logid -- id for sm_syslog.
d2655 1
a2655 1
rscheck(rwset, p1, p2, e, rmcomm, cnt, logl, host, logid)
a2662 1
	char *logid;
d2664 1
a2664 1
	char *volatile buf;
d2667 1
a2667 1
	int volatile rstat = EX_OK;
d2670 1
a2670 1
	bool volatile discard = false;
d2679 1
a2679 1
		sm_dprintf("rscheck(%s, %s, %s)\n", rwset, p1,
d2690 1
a2690 1
			buf = sm_malloc_x(bufsize);
d2696 1
a2696 1
		(void) sm_snprintf(buf, bufsize, "%s%c%s", p1, CONDELSE, p2);
d2702 1
a2702 1
			buf = sm_malloc_x(bufsize);
d2708 1
a2708 1
		(void) sm_strlcpy(buf, p1, bufsize);
d2710 6
a2715 1
	SM_TRY
d2717 9
a2725 23
		SuprErrs = true;
		QuickAbort = false;
		pvp = prescan(buf, '\0', pvpbuf, sizeof pvpbuf, NULL,
			      rmcomm ? NULL : TokTypeNoC);
		SuprErrs = saveSuprErrs;
		if (pvp == NULL)
		{
			if (tTd(48, 2))
				sm_dprintf("rscheck: cannot prescan input\n");
	/*
			syserr("rscheck: cannot prescan input: \"%s\"",
				shortenstring(buf, MAXSHORTSTR));
			rstat = EX_DATAERR;
	*/
			goto finis;
		}
		(void) REWRITE(pvp, rsno, e);
		if (pvp[0] == NULL || (pvp[0][0] & 0377) != CANONNET ||
		    pvp[1] == NULL || (strcmp(pvp[1], "error") != 0 &&
				       strcmp(pvp[1], "discard") != 0))
		{
			goto finis;
		}
d2727 4
a2730 11
		if (strcmp(pvp[1], "discard") == 0)
		{
			if (tTd(48, 2))
				sm_dprintf("rscheck: discard mailer selected\n");
			e->e_flags |= EF_DISCARD;
			discard = true;
		}
		else
		{
			int savelogusrerrs = LogUsrErrs;
			static bool logged = false;
d2732 3
a2734 54
			/* got an error -- process it */
			saveexitstat = ExitStat;
			LogUsrErrs = false;
			(void) buildaddr(pvp, &a1, 0, e);
			LogUsrErrs = savelogusrerrs;
			rstat = ExitStat;
			ExitStat = saveexitstat;
			if (!logged)
			{
				if (cnt)
					markstats(e, &a1, true);
				logged = true;
			}
		}

		if (LogLevel > logl)
		{
			char *relay;
			char *p;
			char lbuf[MAXLINE];

			p = lbuf;
			if (p2 != NULL)
			{
				(void) sm_snprintf(p, SPACELEFT(lbuf, p),
					", arg2=%s",
					p2);
				p += strlen(p);
			}

			if (host != NULL)
				relay = host;
			else
				relay = macvalue('_', e);
			if (relay != NULL)
			{
				(void) sm_snprintf(p, SPACELEFT(lbuf, p),
					", relay=%s", relay);
				p += strlen(p);
			}
			*p = '\0';
			if (discard)
				sm_syslog(LOG_NOTICE, logid,
					  "ruleset=%s, arg1=%s%s, discard",
					  rwset, p1, lbuf);
			else
				sm_syslog(LOG_NOTICE, logid,
					  "ruleset=%s, arg1=%s%s, reject=%s",
					  rwset, p1, lbuf, MsgBuf);
		}

	 finis: ;
	}
	SM_FINALLY
d2736 1
a2736 4
		/* clean up */
		if (buf != buf0)
			sm_free(buf);
		QuickAbort = saveQuickAbort;
a2737 1
	SM_END_TRY
d2739 1
a2739 53
	setstat(rstat);
	if (rstat != EX_OK && QuickAbort)
		sm_exc_raisenew_x(&EtypeQuickAbort, 2);
	return rstat;
}
/*
**  RSCAP -- call rewriting set to return capabilities
**
**	Parameters:
**		rwset -- the rewriting set to use.
**		p1 -- the first string to check.
**		p2 -- the second string to check -- may be null.
**		e -- the current envelope.
**		pvp -- pointer to token vector.
**		pvpbuf -- buffer space.
**
**	Returns:
**		EX_UNAVAILABLE -- ruleset doesn't exist.
**		EX_DATAERR -- prescan() failed.
**		EX_OK -- rewrite() was successful.
**		else -- return status from rewrite().
*/

int
rscap(rwset, p1, p2, e, pvp, pvpbuf, size)
	char *rwset;
	char *p1;
	char *p2;
	ENVELOPE *e;
	char ***pvp;
	char *pvpbuf;
	int size;
{
	char *volatile buf;
	int bufsize;
	int volatile rstat = EX_OK;
	int rsno;
	bool saveQuickAbort = QuickAbort;
	bool saveSuprErrs = SuprErrs;
	char buf0[MAXLINE];
	extern char MsgBuf[];

	if (tTd(48, 2))
		sm_dprintf("rscap(%s, %s, %s)\n", rwset, p1,
			p2 == NULL ? "(NULL)" : p2);

	if (pvp != NULL)
		*pvp = NULL;
	rsno = strtorwset(rwset, NULL, ST_FIND);
	if (rsno < 0)
		return EX_UNAVAILABLE;

	if (p2 != NULL)
d2741 4
a2744 9
		bufsize = strlen(p1) + strlen(p2) + 2;
		if (bufsize > sizeof buf0)
			buf = sm_malloc_x(bufsize);
		else
		{
			buf = buf0;
			bufsize = sizeof buf0;
		}
		(void) sm_snprintf(buf, bufsize, "%s%c%s", p1, CONDELSE, p2);
d2748 11
a2758 4
		bufsize = strlen(p1) + 1;
		if (bufsize > sizeof buf0)
			buf = sm_malloc_x(bufsize);
		else
d2760 3
a2762 2
			buf = buf0;
			bufsize = sizeof buf0;
a2763 1
		(void) sm_strlcpy(buf, p1, bufsize);
d2765 2
a2766 1
	SM_TRY
d2768 15
a2782 5
		SuprErrs = true;
		QuickAbort = false;
		*pvp = prescan(buf, '\0', pvpbuf, size, NULL, NULL);
		if (*pvp != NULL)
			rstat = REWRITE(*pvp, rsno, e);
d2784 2
d2787 13
a2799 4
			if (tTd(48, 2))
				sm_dprintf("rscap: cannot prescan input\n");
			rstat = EX_DATAERR;
		}
a2800 7
	SM_FINALLY
	{
		/* clean up */
		if (buf != buf0)
			sm_free(buf);
		SuprErrs = saveSuprErrs;
		QuickAbort = saveQuickAbort;
d2802 9
a2810 4
		/* prevent information leak, this may contain rewrite error */
		MsgBuf[0] = '\0';
	}
	SM_END_TRY
@


