head	1.29;
access;
symbols
	OPENBSD_5_6:1.28.0.6
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.8
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.6
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.4
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.25.0.12
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.10
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.6
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.8
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.4
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.24.0.6
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.4
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.22.0.6
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.4
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.17.0.4
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2014.09.17.18.49.52;	author matthieu;	state dead;
branches;
next	1.28;
commitid	M7i5giHIoz3DMlTU;

1.28
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.26;

1.26
date	2011.05.17.15.54.24;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.22.18.43.56;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.16.00.21.31;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2004.09.18.04.08.35;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.24.03.59.27;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.19.01.41.14;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.09.17.17.31.40;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.29.19.44.01;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.01.19.59.23;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.15.02.23.36;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.26.04.48.55;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.03.17.25.47;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.18.00.49.28;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.01.17.18.30;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.11.19.02.50;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.21.16.31.45;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.01.01.01.41;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.29.01.31.16;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.28.02.43.55;	author millert;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.01.15.21.09.09;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.09.23.45.01;	author millert;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.04.07.19.20.43;	author millert;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.04.02.19.05.47;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.47;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.16;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.50;	author millert;	state Exp;
branches;
next	;

1.2.2.1
date	2000.10.10.05.13.39;	author jason;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.31.00.31.39;	author miod;	state Exp;
branches;
next	;

1.5.2.1
date	2001.05.31.01.47.57;	author jason;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2006, 2008-2010, 2013 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>
#include <sm/sendmail.h>

SM_RCSID("@@(#)$Sendmail: readcf.c,v 8.692 2013/11/22 20:51:56 ca Exp $")

#if NETINET || NETINET6
# include <arpa/inet.h>
#endif /* NETINET || NETINET6 */


#define SECONDS
#define MINUTES	* 60
#define HOUR	* 3600
#define HOURS	HOUR

static void	fileclass __P((int, char *, char *, bool, bool, bool));
static char	**makeargv __P((char *));
static void	settimeout __P((char *, char *, bool));
static void	toomany __P((int, int));
static char	*extrquotstr __P((char *, char **, char *, bool *));
static void	parse_class_words __P((int, char *));

/*
**  READCF -- read configuration file.
**
**	This routine reads the configuration file and builds the internal
**	form.
**
**	The file is formatted as a sequence of lines, each taken
**	atomically.  The first character of each line describes how
**	the line is to be interpreted.  The lines are:
**		Dxval		Define macro x to have value val.
**		Cxword		Put word into class x.
**		Fxfile [fmt]	Read file for lines to put into
**				class x.  Use scanf string 'fmt'
**				or "%s" if not present.  Fmt should
**				only produce one string-valued result.
**		Hname: value	Define header with field-name 'name'
**				and value as specified; this will be
**				macro expanded immediately before
**				use.
**		Sn		Use rewriting set n.
**		Rlhs rhs	Rewrite addresses that match lhs to
**				be rhs.
**		Mn arg=val...	Define mailer.  n is the internal name.
**				Args specify mailer parameters.
**		Oxvalue		Set option x to value.
**		O option value	Set option (long name) to value.
**		Pname=value	Set precedence name to value.
**		Qn arg=val...	Define queue groups.  n is the internal name.
**				Args specify queue parameters.
**		Vversioncode[/vendorcode]
**				Version level/vendor name of
**				configuration syntax.
**		Kmapname mapclass arguments....
**				Define keyed lookup of a given class.
**				Arguments are class dependent.
**		Eenvar=value	Set the environment value to the given value.
**
**	Parameters:
**		cfname -- configuration file name.
**		safe -- true if this is the system config file;
**			false otherwise.
**		e -- the main envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Builds several internal tables.
*/

void
readcf(cfname, safe, e)
	char *cfname;
	bool safe;
	register ENVELOPE *e;
{
	SM_FILE_T *cf;
	int ruleset = -1;
	char *q;
	struct rewrite *rwp = NULL;
	char *bp;
	auto char *ep;
	int nfuzzy;
	char *file;
	bool optional;
	bool ok;
	bool ismap;
	int mid;
	register char *p;
	long sff = SFF_OPENASROOT;
	struct stat statb;
	char buf[MAXLINE];
	int bufsize;
	char exbuf[MAXLINE];
	char pvpbuf[MAXLINE + MAXATOM];
	static char *null_list[1] = { NULL };
	extern unsigned char TokTypeNoC[];

	FileName = cfname;
	LineNumber = 0;

#if STARTTLS
	Srv_SSL_Options = SSL_OP_ALL;
	Clt_SSL_Options = SSL_OP_ALL
#ifdef SSL_OP_NO_SSLv2
		| SSL_OP_NO_SSLv2
#endif
#ifdef SSL_OP_NO_TICKET
		| SSL_OP_NO_TICKET
#endif
		;
#endif /* STARTTLS */
	if (DontLockReadFiles)
		sff |= SFF_NOLOCK;
	cf = safefopen(cfname, O_RDONLY, 0444, sff);
	if (cf == NULL)
	{
		syserr("cannot open");
		finis(false, true, EX_OSFILE);
	}

	if (fstat(sm_io_getinfo(cf, SM_IO_WHAT_FD, NULL), &statb) < 0)
	{
		syserr("cannot fstat");
		finis(false, true, EX_OSFILE);
	}

	if (!S_ISREG(statb.st_mode))
	{
		syserr("not a plain file");
		finis(false, true, EX_OSFILE);
	}

	if (OpMode != MD_TEST && bitset(S_IWGRP|S_IWOTH, statb.st_mode))
	{
		if (OpMode == MD_DAEMON || OpMode == MD_INITALIAS || OpMode == MD_CHECKCONFIG)
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
					     "%s: WARNING: dangerous write permissions\n",
					     FileName);
		if (LogLevel > 0)
			sm_syslog(LOG_CRIT, NOQID,
				  "%s: WARNING: dangerous write permissions",
				  FileName);
	}

#if XLA
	xla_zero();
#endif /* XLA */

	while (bufsize = sizeof(buf),
	       (bp = fgetfolded(buf, &bufsize, cf)) != NULL)
	{
		char *nbp;

		if (bp[0] == '#')
		{
			if (bp != buf)
				sm_free(bp); /* XXX */
			continue;
		}

		/* do macro expansion mappings */
		nbp = translate_dollars(bp, bp, &bufsize);
		if (nbp != bp && bp != buf)
			sm_free(bp);
		bp = nbp;

		/* interpret this line */
		errno = 0;
		switch (bp[0])
		{
		  case '\0':
		  case '#':		/* comment */
			break;

		  case 'R':		/* rewriting rule */
			if (ruleset < 0)
			{
				syserr("missing valid ruleset for \"%s\"", bp);
				break;
			}
			for (p = &bp[1]; *p != '\0' && *p != '\t'; p++)
				continue;

			if (*p == '\0')
			{
				syserr("invalid rewrite line \"%s\" (tab expected)", bp);
				break;
			}

			/* allocate space for the rule header */
			if (rwp == NULL)
			{
				RewriteRules[ruleset] = rwp =
					(struct rewrite *) xalloc(sizeof(*rwp));
			}
			else
			{
				rwp->r_next = (struct rewrite *) xalloc(sizeof(*rwp));
				rwp = rwp->r_next;
			}
			rwp->r_next = NULL;

			/* expand and save the LHS */
			*p = '\0';
			expand(&bp[1], exbuf, sizeof(exbuf), e);
			rwp->r_lhs = prescan(exbuf, '\t', pvpbuf,
					     sizeof(pvpbuf), NULL,
					     ConfigLevel >= 9 ? TokTypeNoC : IntTokenTab,
					     true);
			nfuzzy = 0;
			if (rwp->r_lhs != NULL)
			{
				register char **ap;

				rwp->r_lhs = copyplist(rwp->r_lhs, true, NULL);

				/* count the number of fuzzy matches in LHS */
				for (ap = rwp->r_lhs; *ap != NULL; ap++)
				{
					char *botch;

					botch = NULL;
					switch (ap[0][0] & 0377)
					{
					  case MATCHZANY:
					  case MATCHANY:
					  case MATCHONE:
					  case MATCHCLASS:
					  case MATCHNCLASS:
						nfuzzy++;
						break;

					  case MATCHREPL:
						botch = "$1-$9";
						break;

					  case CANONUSER:
						botch = "$:";
						break;

					  case CALLSUBR:
						botch = "$>";
						break;

					  case CONDIF:
						botch = "$?";
						break;

					  case CONDFI:
						botch = "$.";
						break;

					  case HOSTBEGIN:
						botch = "$[";
						break;

					  case HOSTEND:
						botch = "$]";
						break;

					  case LOOKUPBEGIN:
						botch = "$(";
						break;

					  case LOOKUPEND:
						botch = "$)";
						break;
					}
					if (botch != NULL)
						syserr("Inappropriate use of %s on LHS",
							botch);
				}
				rwp->r_line = LineNumber;
			}
			else
			{
				syserr("R line: null LHS");
				rwp->r_lhs = null_list;
			}
			if (nfuzzy > MAXMATCH)
			{
				syserr("R line: too many wildcards");
				rwp->r_lhs = null_list;
			}

			/* expand and save the RHS */
			while (*++p == '\t')
				continue;
			q = p;
			while (*p != '\0' && *p != '\t')
				p++;
			*p = '\0';
			expand(q, exbuf, sizeof(exbuf), e);
			rwp->r_rhs = prescan(exbuf, '\t', pvpbuf,
					     sizeof(pvpbuf), NULL,
					     ConfigLevel >= 9 ? TokTypeNoC : IntTokenTab,
					     true);
			if (rwp->r_rhs != NULL)
			{
				register char **ap;
				int args, endtoken;
#if _FFR_EXTRA_MAP_CHECK
				int nexttoken;
#endif /* _FFR_EXTRA_MAP_CHECK */
				bool inmap;

				rwp->r_rhs = copyplist(rwp->r_rhs, true, NULL);

				/* check no out-of-bounds replacements */
				nfuzzy += '0';
				inmap = false;
				args = 0;
				endtoken = 0;
				for (ap = rwp->r_rhs; *ap != NULL; ap++)
				{
					char *botch;

					botch = NULL;
					switch (ap[0][0] & 0377)
					{
					  case MATCHREPL:
						if (ap[0][1] <= '0' ||
						    ap[0][1] > nfuzzy)
						{
							syserr("replacement $%c out of bounds",
								ap[0][1]);
						}
						break;

					  case MATCHZANY:
						botch = "$*";
						break;

					  case MATCHANY:
						botch = "$+";
						break;

					  case MATCHONE:
						botch = "$-";
						break;

					  case MATCHCLASS:
						botch = "$=";
						break;

					  case MATCHNCLASS:
						botch = "$~";
						break;

					  case CANONHOST:
						if (!inmap)
							break;
						if (++args >= MAX_MAP_ARGS)
							syserr("too many arguments for map lookup");
						break;

					  case HOSTBEGIN:
						endtoken = HOSTEND;
						/* FALLTHROUGH */
					  case LOOKUPBEGIN:
						/* see above... */
						if ((ap[0][0] & 0377) == LOOKUPBEGIN)
							endtoken = LOOKUPEND;
						if (inmap)
							syserr("cannot nest map lookups");
						inmap = true;
						args = 0;
#if _FFR_EXTRA_MAP_CHECK
						if (ap[1] == NULL)
						{
							syserr("syntax error in map lookup");
							break;
						}
						nexttoken = ap[1][0] & 0377;
						if (nexttoken == CANONHOST ||
						    nexttoken == CANONUSER ||
						    nexttoken == endtoken))
						{
							syserr("missing map name for lookup");
							break;
						}
						if (ap[2] == NULL)
						{
							syserr("syntax error in map lookup");
							break;
						}
						if (ap[0][0] == HOSTBEGIN)
							break;
						nexttoken = ap[2][0] & 0377;
						if (nexttoken == CANONHOST ||
						    nexttoken == CANONUSER ||
						    nexttoken == endtoken)
						{
							syserr("missing key name for lookup");
							break;
						}
#endif /* _FFR_EXTRA_MAP_CHECK */
						break;

					  case HOSTEND:
					  case LOOKUPEND:
						if ((ap[0][0] & 0377) != endtoken)
							break;
						inmap = false;
						endtoken = 0;
						break;


#if 0
/*
**  This doesn't work yet as there are maps defined *after* the cf
**  is read such as host, user, and alias.  So for now, it's removed.
**  When it comes back, the RELEASE_NOTES entry will be:
**	Emit warnings for unknown maps when reading the .cf file.  Based on
**		patch from Robert Harker of Harker Systems.
*/

					  case LOOKUPBEGIN:
						/*
						**  Got a database lookup,
						**  check if map is defined.
						*/

						ep = ap[1];
						if ((ep[0] & 0377) != MACRODEXPAND &&
						    stab(ep, ST_MAP, ST_FIND) == NULL)
						{
							(void) sm_io_fprintf(smioout,
									     SM_TIME_DEFAULT,
									     "Warning: %s: line %d: map %s not found\n",
									     FileName,
									     LineNumber,
									     ep);
						}
						break;
#endif /* 0 */
					}
					if (botch != NULL)
						syserr("Inappropriate use of %s on RHS",
							botch);
				}
				if (inmap)
					syserr("missing map closing token");
			}
			else
			{
				syserr("R line: null RHS");
				rwp->r_rhs = null_list;
			}
			break;

		  case 'S':		/* select rewriting set */
			expand(&bp[1], exbuf, sizeof(exbuf), e);
			ruleset = strtorwset(exbuf, NULL, ST_ENTER);
			if (ruleset < 0)
				break;

			rwp = RewriteRules[ruleset];
			if (rwp != NULL)
			{
				if (OpMode == MD_TEST || OpMode == MD_CHECKCONFIG)
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "WARNING: Ruleset %s has multiple definitions\n",
							    &bp[1]);
				if (tTd(37, 1))
					sm_dprintf("WARNING: Ruleset %s has multiple definitions\n",
						   &bp[1]);
				while (rwp->r_next != NULL)
					rwp = rwp->r_next;
			}
			break;

		  case 'D':		/* macro definition */
			mid = macid_parse(&bp[1], &ep);
			if (mid == 0)
				break;
			p = munchstring(ep, NULL, '\0');
			macdefine(&e->e_macro, A_TEMP, mid, p);
			break;

		  case 'H':		/* required header line */
			(void) chompheader(&bp[1], CHHDR_DEF, NULL, e);
			break;

		  case 'C':		/* word class */
		  case 'T':		/* trusted user (set class `t') */
			if (bp[0] == 'C')
			{
				mid = macid_parse(&bp[1], &ep);
				if (mid == 0)
					break;
				expand(ep, exbuf, sizeof(exbuf), e);
				p = exbuf;
			}
			else
			{
				mid = 't';
				p = &bp[1];
			}
			while (*p != '\0')
			{
				register char *wd;
				char delim;

				while (*p != '\0' && isascii(*p) && isspace(*p))
					p++;
				wd = p;
				while (*p != '\0' && !(isascii(*p) && isspace(*p)))
					p++;
				delim = *p;
				*p = '\0';
				if (wd[0] != '\0')
					setclass(mid, wd);
				*p = delim;
			}
			break;

		  case 'F':		/* word class from file */
			mid = macid_parse(&bp[1], &ep);
			if (mid == 0)
				break;
			for (p = ep; isascii(*p) && isspace(*p); )
				p++;
			if (p[0] == '-' && p[1] == 'o')
			{
				optional = true;
				while (*p != '\0' &&
				       !(isascii(*p) && isspace(*p)))
					p++;
				while (isascii(*p) && isspace(*p))
					p++;
			}
			else
				optional = false;

			/* check if [key]@@map:spec */
			ismap = false;
			if (!SM_IS_DIR_DELIM(*p) &&
			    *p != '|' &&
			    (q = strchr(p, '@@')) != NULL)
			{
				q++;

				/* look for @@LDAP or @@map: in string */
				if (strcmp(q, "LDAP") == 0 ||
				    (*q != ':' &&
				     strchr(q, ':') != NULL))
					ismap = true;
			}

			if (ismap)
			{
				/* use entire spec */
				file = p;
			}
			else
			{
				file = extrquotstr(p, &q, " ", &ok);
				if (!ok)
				{
					syserr("illegal filename '%s'", p);
					break;
				}
			}

			if (*file == '|' || ismap)
				p = "%s";
			else
			{
				p = q;
				if (*p == '\0')
					p = "%s";
				else
				{
					*p = '\0';
					while (isascii(*++p) && isspace(*p))
						continue;
				}
			}
			fileclass(mid, file, p, ismap, safe, optional);
			break;

#if XLA
		  case 'L':		/* extended load average description */
			xla_init(&bp[1]);
			break;
#endif /* XLA */

#if defined(SUN_EXTENSIONS) && defined(SUN_LOOKUP_MACRO)
		  case 'L':		/* lookup macro */
		  case 'G':		/* lookup class */
			/* reserved for Sun -- NIS+ database lookup */
			if (VendorCode != VENDOR_SUN)
				goto badline;
			sun_lg_config_line(bp, e);
			break;
#endif /* defined(SUN_EXTENSIONS) && defined(SUN_LOOKUP_MACRO) */

		  case 'M':		/* define mailer */
			makemailer(&bp[1]);
			break;

		  case 'O':		/* set option */
			setoption(bp[1], &bp[2], safe, false, e);
			break;

		  case 'P':		/* set precedence */
			if (NumPriorities >= MAXPRIORITIES)
			{
				toomany('P', MAXPRIORITIES);
				break;
			}
			for (p = &bp[1]; *p != '\0' && *p != '='; p++)
				continue;
			if (*p == '\0')
				goto badline;
			*p = '\0';
			Priorities[NumPriorities].pri_name = newstr(&bp[1]);
			Priorities[NumPriorities].pri_val = atoi(++p);
			NumPriorities++;
			break;

		  case 'Q':		/* define queue */
			makequeue(&bp[1], true);
			break;

		  case 'V':		/* configuration syntax version */
			for (p = &bp[1]; isascii(*p) && isspace(*p); p++)
				continue;
			if (!isascii(*p) || !isdigit(*p))
			{
				syserr("invalid argument to V line: \"%.20s\"",
					&bp[1]);
				break;
			}
			ConfigLevel = strtol(p, &ep, 10);

			/*
			**  Do heuristic tweaking for back compatibility.
			*/

			if (ConfigLevel >= 5)
			{
				/* level 5 configs have short name in $w */
				p = macvalue('w', e);
				if (p != NULL && (p = strchr(p, '.')) != NULL)
				{
					*p = '\0';
					macdefine(&e->e_macro, A_TEMP, 'w',
						  macvalue('w', e));
				}
			}
			if (ConfigLevel >= 6)
			{
				ColonOkInAddr = false;
			}

			/*
			**  Look for vendor code.
			*/

			if (*ep++ == '/')
			{
				/* extract vendor code */
				for (p = ep; isascii(*p) && isalpha(*p); )
					p++;
				*p = '\0';

				if (!setvendor(ep))
					syserr("invalid V line vendor code: \"%s\"",
						ep);
			}
			break;

		  case 'K':
			expand(&bp[1], exbuf, sizeof(exbuf), e);
			(void) makemapentry(exbuf);
			break;

		  case 'E':
			p = strchr(bp, '=');
			if (p != NULL)
				*p++ = '\0';
			sm_setuserenv(&bp[1], p);
			break;

		  case 'X':		/* mail filter */
#if MILTER
			milter_setup(&bp[1]);
#else /* MILTER */
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Warning: Filter usage ('X') requires Milter support (-DMILTER)\n");
#endif /* MILTER */
			break;

		  default:
		  badline:
			syserr("unknown configuration line \"%s\"", bp);
		}
		if (bp != buf)
			sm_free(bp); /* XXX */
	}
	if (sm_io_error(cf))
	{
		syserr("I/O read error");
		finis(false, true, EX_OSFILE);
	}
	(void) sm_io_close(cf, SM_TIME_DEFAULT);
	FileName = NULL;

	/* initialize host maps from local service tables */
	inithostmaps();

	/* initialize daemon (if not defined yet) */
	initdaemon();

	/* determine if we need to do special name-server frotz */
	{
		int nmaps;
		char *maptype[MAXMAPSTACK];
		short mapreturn[MAXMAPACTIONS];

		nmaps = switch_map_find("hosts", maptype, mapreturn);
		UseNameServer = false;
		if (nmaps > 0 && nmaps <= MAXMAPSTACK)
		{
			register int mapno;

			for (mapno = 0; mapno < nmaps && !UseNameServer;
			     mapno++)
			{
				if (strcmp(maptype[mapno], "dns") == 0)
					UseNameServer = true;
			}
		}
	}
}

/*
**  TRANSLATE_DOLLARS -- convert $x into internal form
**
**	Actually does all appropriate pre-processing of a config line
**	to turn it into internal form.
**
**	Parameters:
**		ibp -- the buffer to translate.
**		obp -- where to put the translation; may be the same as obp
**		bsp -- a pointer to the size of obp; will be updated if
**			the buffer needs to be replaced.
**
**	Returns:
**		The buffer pointer; may differ from obp if the expansion
**		is larger then *bsp, in which case this will point to
**		malloc()ed memory which must be free()d by the caller.
*/

char *
translate_dollars(ibp, obp, bsp)
	char *ibp;
	char *obp;
	int *bsp;
{
	register char *p;
	auto char *ep;
	char *bp;

	if (tTd(37, 53))
	{
		sm_dprintf("translate_dollars(");
		xputs(sm_debug_file(), ibp);
		sm_dprintf(")\n");
	}

	bp = quote_internal_chars(ibp, obp, bsp);

	for (p = bp; *p != '\0'; p++)
	{
		if (*p == '#' && p > bp && ConfigLevel >= 3)
		{
			register char *e;

			switch (*--p & 0377)
			{
			  case MACROEXPAND:
				/* it's from $# -- let it go through */
				p++;
				break;

			  case '\\':
				/* it's backslash escaped */
				(void) sm_strlcpy(p, p + 1, strlen(p));
				break;

			  default:
				/* delete leading white space */
				while (isascii(*p) && isspace(*p) &&
				       *p != '\n' && p > bp)
				{
					p--;
				}
				if ((e = strchr(++p, '\n')) != NULL)
					(void) sm_strlcpy(p, e, strlen(p));
				else
					*p-- = '\0';
				break;
			}
			continue;
		}

		if (*p != '$' || p[1] == '\0')
			continue;

		if (p[1] == '$')
		{
			/* actual dollar sign.... */
			(void) sm_strlcpy(p, p + 1, strlen(p));
			continue;
		}

		/* convert to macro expansion character */
		*p++ = MACROEXPAND;

		/* special handling for $=, $~, $&, and $? */
		if (*p == '=' || *p == '~' || *p == '&' || *p == '?')
			p++;

		/* convert macro name to code */
		*p = macid_parse(p, &ep);
		if (ep != p + 1)
			(void) sm_strlcpy(p + 1, ep, strlen(p + 1));
	}

	/* strip trailing white space from the line */
	while (--p > bp && isascii(*p) && isspace(*p))
		*p = '\0';

	if (tTd(37, 53))
	{
		sm_dprintf("  translate_dollars => ");
		xputs(sm_debug_file(), bp);
		sm_dprintf("\n");
	}

	return bp;
}
/*
**  TOOMANY -- signal too many of some option
**
**	Parameters:
**		id -- the id of the error line
**		maxcnt -- the maximum possible values
**
**	Returns:
**		none.
**
**	Side Effects:
**		gives a syserr.
*/

static void
toomany(id, maxcnt)
	int id;
	int maxcnt;
{
	syserr("too many %c lines, %d max", id, maxcnt);
}
/*
**  FILECLASS -- read members of a class from a file
**
**	Parameters:
**		class -- class to define.
**		filename -- name of file to read.
**		fmt -- scanf string to use for match.
**		ismap -- if set, this is a map lookup.
**		safe -- if set, this is a safe read.
**		optional -- if set, it is not an error for the file to
**			not exist.
**
**	Returns:
**		none
**
**	Side Effects:
**		puts all lines in filename that match a scanf into
**			the named class.
*/

/*
**  Break up the match into words and add to class.
*/

static void
parse_class_words(class, line)
	int class;
	char *line;
{
	while (line != NULL && *line != '\0')
	{
		register char *q;

		/* strip leading spaces */
		while (isascii(*line) && isspace(*line))
			line++;
		if (*line == '\0')
			break;

		/* find the end of the word */
		q = line;
		while (*line != '\0' && !(isascii(*line) && isspace(*line)))
			line++;
		if (*line != '\0')
			*line++ = '\0';

		/* enter the word in the symbol table */
		setclass(class, q);
	}
}

static void
fileclass(class, filename, fmt, ismap, safe, optional)
	int class;
	char *filename;
	char *fmt;
	bool ismap;
	bool safe;
	bool optional;
{
	SM_FILE_T *f;
	long sff;
	pid_t pid;
	register char *p;
	char buf[MAXLINE];

	if (tTd(37, 2))
		sm_dprintf("fileclass(%s, fmt=%s)\n", filename, fmt);

	if (*filename == '\0')
	{
		syserr("fileclass: missing file name");
		return;
	}
	else if (ismap)
	{
		int status = 0;
		char *key;
		char *mn;
		char *cl, *spec;
		STAB *mapclass;
		MAP map;

		mn = newstr(macname(class));

		key = filename;

		/* skip past key */
		if ((p = strchr(filename, '@@')) == NULL)
		{
			/* should not happen */
			syserr("fileclass: bogus map specification");
			sm_free(mn);
			return;
		}

		/* skip past '@@' */
		*p++ = '\0';
		cl = p;

#if LDAPMAP
		if (strcmp(cl, "LDAP") == 0)
		{
			int n;
			char *lc;
			char jbuf[MAXHOSTNAMELEN];
			char lcbuf[MAXLINE];

			/* Get $j */
			expand("\201j", jbuf, sizeof(jbuf), &BlankEnvelope);
			if (jbuf[0] == '\0')
			{
				(void) sm_strlcpy(jbuf, "localhost",
						  sizeof(jbuf));
			}

			/* impose the default schema */
			lc = macvalue(macid("{sendmailMTACluster}"), CurEnv);
			if (lc == NULL)
				lc = "";
			else
			{
				expand(lc, lcbuf, sizeof(lcbuf), CurEnv);
				lc = lcbuf;
			}

			cl = "ldap";
			n = sm_snprintf(buf, sizeof(buf),
					"-k (&(objectClass=sendmailMTAClass)(sendmailMTAClassName=%s)(|(sendmailMTACluster=%s)(sendmailMTAHost=%s))) -v sendmailMTAClassValue,sendmailMTAClassSearch:FILTER:sendmailMTAClass,sendmailMTAClassURL:URL:sendmailMTAClass",
					mn, lc, jbuf);
			if (n >= sizeof(buf))
			{
				syserr("fileclass: F{%s}: Default LDAP string too long",
				       mn);
				sm_free(mn);
				return;
			}
			spec = buf;
		}
		else
#endif /* LDAPMAP */
		{
			if ((spec = strchr(cl, ':')) == NULL)
			{
				syserr("fileclass: F{%s}: missing map class",
				       mn);
				sm_free(mn);
				return;
			}
			*spec++ ='\0';
		}

		/* set up map structure */
		mapclass = stab(cl, ST_MAPCLASS, ST_FIND);
		if (mapclass == NULL)
		{
			syserr("fileclass: F{%s}: class %s not available",
			       mn, cl);
			sm_free(mn);
			return;
		}
		memset(&map, '\0', sizeof(map));
		map.map_class = &mapclass->s_mapclass;
		map.map_mname = mn;
		map.map_mflags |= MF_FILECLASS;

		if (tTd(37, 5))
			sm_dprintf("fileclass: F{%s}: map class %s, key %s, spec %s\n",
				   mn, cl, key, spec);


		/* parse map spec */
		if (!map.map_class->map_parse(&map, spec))
		{
			/* map_parse() showed the error already */
			sm_free(mn);
			return;
		}
		map.map_mflags |= MF_VALID;

		/* open map */
		if (map.map_class->map_open(&map, O_RDONLY))
		{
			map.map_mflags |= MF_OPEN;
			map.map_pid = getpid();
		}
		else
		{
			if (!optional &&
			    !bitset(MF_OPTIONAL, map.map_mflags))
				syserr("fileclass: F{%s}: map open failed",
				       mn);
			sm_free(mn);
			return;
		}

		/* lookup */
		p = (*map.map_class->map_lookup)(&map, key, NULL, &status);
		if (status != EX_OK && status != EX_NOTFOUND)
		{
			if (!optional)
				syserr("fileclass: F{%s}: map lookup failed",
				       mn);
			p = NULL;
		}

		/* use the results */
		if (p != NULL)
			parse_class_words(class, p);

		/* close map */
		map.map_mflags |= MF_CLOSING;
		map.map_class->map_close(&map);
		map.map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
		sm_free(mn);
		return;
	}
	else if (filename[0] == '|')
	{
		auto int fd;
		int i;
		char *argv[MAXPV + 1];

		i = 0;
		for (p = strtok(&filename[1], " \t");
		     p != NULL && i < MAXPV;
		     p = strtok(NULL, " \t"))
			argv[i++] = p;
		argv[i] = NULL;
		pid = prog_open(argv, &fd, CurEnv);
		if (pid < 0)
			f = NULL;
		else
			f = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT,
				       (void *) &fd, SM_IO_RDONLY, NULL);
	}
	else
	{
		pid = -1;
		sff = SFF_REGONLY;
		if (!bitnset(DBS_CLASSFILEINUNSAFEDIRPATH, DontBlameSendmail))
			sff |= SFF_SAFEDIRPATH;
		if (!bitnset(DBS_LINKEDCLASSFILEINWRITABLEDIR,
			     DontBlameSendmail))
			sff |= SFF_NOWLINK;
		if (safe)
			sff |= SFF_OPENASROOT;
		else if (RealUid == 0)
			sff |= SFF_ROOTOK;
		if (DontLockReadFiles)
			sff |= SFF_NOLOCK;
		f = safefopen(filename, O_RDONLY, 0, sff);
	}
	if (f == NULL)
	{
		if (!optional)
			syserr("fileclass: cannot open '%s'", filename);
		return;
	}

	while (sm_io_fgets(f, SM_TIME_DEFAULT, buf, sizeof(buf)) >= 0)
	{
#if SCANF
		char wordbuf[MAXLINE + 1];
#endif /* SCANF */

		if (buf[0] == '#')
			continue;
#if SCANF
		if (sm_io_sscanf(buf, fmt, wordbuf) != 1)
			continue;
		p = wordbuf;
#else /* SCANF */
		p = buf;
#endif /* SCANF */

		parse_class_words(class, p);

		/*
		**  If anything else is added here,
		**  check if the '@@' map case above
		**  needs the code as well.
		*/
	}

	(void) sm_io_close(f, SM_TIME_DEFAULT);
	if (pid > 0)
		(void) waitfor(pid);
}
/*
**  MAKEMAILER -- define a new mailer.
**
**	Parameters:
**		line -- description of mailer.  This is in labeled
**			fields.  The fields are:
**			   A -- the argv for this mailer
**			   C -- the character set for MIME conversions
**			   D -- the directory to run in
**			   E -- the eol string
**			   F -- the flags associated with the mailer
**			   L -- the maximum line length
**			   M -- the maximum message size
**			   N -- the niceness at which to run
**			   P -- the path to the mailer
**			   Q -- the queue group for the mailer
**			   R -- the recipient rewriting set
**			   S -- the sender rewriting set
**			   T -- the mailer type (for DSNs)
**			   U -- the uid to run as
**			   W -- the time to wait at the end
**			   m -- maximum messages per connection
**			   r -- maximum number of recipients per message
**			   / -- new root directory
**			The first word is the canonical name of the mailer.
**
**	Returns:
**		none.
**
**	Side Effects:
**		enters the mailer into the mailer table.
*/

void
makemailer(line)
	char *line;
{
	register char *p;
	register struct mailer *m;
	register STAB *s;
	int i;
	char fcode;
	auto char *endp;
	static int nextmailer = 0;	/* "free" index into Mailer struct */

	/* allocate a mailer and set up defaults */
	m = (struct mailer *) xalloc(sizeof(*m));
	memset((char *) m, '\0', sizeof(*m));
	errno = 0; /* avoid bogus error text */

	/* collect the mailer name */
	for (p = line;
	     *p != '\0' && *p != ',' && !(isascii(*p) && isspace(*p));
	     p++)
		continue;
	if (*p != '\0')
		*p++ = '\0';
	if (line[0] == '\0')
	{
		syserr("name required for mailer");
		return;
	}
	m->m_name = newstr(line);
	m->m_qgrp = NOQGRP;
	m->m_uid = NO_UID;
	m->m_gid = NO_GID;

	/* now scan through and assign info from the fields */
	while (*p != '\0')
	{
		auto char *delimptr;

		while (*p != '\0' &&
		       (*p == ',' || (isascii(*p) && isspace(*p))))
			p++;

		/* p now points to field code */
		fcode = *p;
		while (*p != '\0' && *p != '=' && *p != ',')
			p++;
		if (*p++ != '=')
		{
			syserr("mailer %s: `=' expected", m->m_name);
			return;
		}
		while (isascii(*p) && isspace(*p))
			p++;

		/* p now points to the field body */
		p = munchstring(p, &delimptr, ',');

		/* install the field into the mailer struct */
		switch (fcode)
		{
		  case 'P':		/* pathname */
			if (*p != '\0')	/* error is issued below */
				m->m_mailer = newstr(p);
			break;

		  case 'F':		/* flags */
			for (; *p != '\0'; p++)
			{
				if (!(isascii(*p) && isspace(*p)))
				{
#if _FFR_DEPRECATE_MAILER_FLAG_I
					if (*p == M_INTERNAL)
						sm_syslog(LOG_WARNING, NOQID,
							  "WARNING: mailer=%s, flag=%c deprecated",
							  m->m_name, *p);
#endif /* _FFR_DEPRECATE_MAILER_FLAG_I */
					setbitn(bitidx(*p), m->m_flags);
				}
			}
			break;

		  case 'S':		/* sender rewriting ruleset */
		  case 'R':		/* recipient rewriting ruleset */
			i = strtorwset(p, &endp, ST_ENTER);
			if (i < 0)
				return;
			if (fcode == 'S')
				m->m_sh_rwset = m->m_se_rwset = i;
			else
				m->m_rh_rwset = m->m_re_rwset = i;

			p = endp;
			if (*p++ == '/')
			{
				i = strtorwset(p, NULL, ST_ENTER);
				if (i < 0)
					return;
				if (fcode == 'S')
					m->m_sh_rwset = i;
				else
					m->m_rh_rwset = i;
			}
			break;

		  case 'E':		/* end of line string */
			if (*p == '\0')
				syserr("mailer %s: null end-of-line string",
					m->m_name);
			else
				m->m_eol = newstr(p);
			break;

		  case 'A':		/* argument vector */
			if (*p != '\0')	/* error is issued below */
				m->m_argv = makeargv(p);
			break;

		  case 'M':		/* maximum message size */
			m->m_maxsize = atol(p);
			break;

		  case 'm':		/* maximum messages per connection */
			m->m_maxdeliveries = atoi(p);
			break;

		  case 'r':		/* max recipient per envelope */
			m->m_maxrcpt = atoi(p);
			break;

		  case 'L':		/* maximum line length */
			m->m_linelimit = atoi(p);
			if (m->m_linelimit < 0)
				m->m_linelimit = 0;
			break;

		  case 'N':		/* run niceness */
			m->m_nice = atoi(p);
			break;

		  case 'D':		/* working directory */
			if (*p == '\0')
				syserr("mailer %s: null working directory",
					m->m_name);
			else
				m->m_execdir = newstr(p);
			break;

		  case 'C':		/* default charset */
			if (*p == '\0')
				syserr("mailer %s: null charset", m->m_name);
			else
				m->m_defcharset = newstr(p);
			break;

		  case 'Q':		/* queue for this mailer */
			if (*p == '\0')
			{
				syserr("mailer %s: null queue", m->m_name);
				break;
			}
			s = stab(p, ST_QUEUE, ST_FIND);
			if (s == NULL)
				syserr("mailer %s: unknown queue %s",
					m->m_name, p);
			else
				m->m_qgrp = s->s_quegrp->qg_index;
			break;

		  case 'T':		/* MTA-Name/Address/Diagnostic types */
			/* extract MTA name type; default to "dns" */
			m->m_mtatype = newstr(p);
			p = strchr(m->m_mtatype, '/');
			if (p != NULL)
			{
				*p++ = '\0';
				if (*p == '\0')
					p = NULL;
			}
			if (*m->m_mtatype == '\0')
				m->m_mtatype = "dns";

			/* extract address type; default to "rfc822" */
			m->m_addrtype = p;
			if (p != NULL)
				p = strchr(p, '/');
			if (p != NULL)
			{
				*p++ = '\0';
				if (*p == '\0')
					p = NULL;
			}
			if (m->m_addrtype == NULL || *m->m_addrtype == '\0')
				m->m_addrtype = "rfc822";

			/* extract diagnostic type; default to "smtp" */
			m->m_diagtype = p;
			if (m->m_diagtype == NULL || *m->m_diagtype == '\0')
				m->m_diagtype = "smtp";
			break;

		  case 'U':		/* user id */
			if (isascii(*p) && !isdigit(*p))
			{
				char *q = p;
				struct passwd *pw;

				while (*p != '\0' && isascii(*p) &&
				       (isalnum(*p) || strchr("-_", *p) != NULL))
					p++;
				while (isascii(*p) && isspace(*p))
					*p++ = '\0';
				if (*p != '\0')
					*p++ = '\0';
				if (*q == '\0')
				{
					syserr("mailer %s: null user name",
						m->m_name);
					break;
				}
				pw = sm_getpwnam(q);
				if (pw == NULL)
				{
					syserr("readcf: mailer U= flag: unknown user %s", q);
					break;
				}
				else
				{
					m->m_uid = pw->pw_uid;
					m->m_gid = pw->pw_gid;
				}
			}
			else
			{
				auto char *q;

				m->m_uid = strtol(p, &q, 0);
				p = q;
				while (isascii(*p) && isspace(*p))
					p++;
				if (*p != '\0')
					p++;
			}
			while (isascii(*p) && isspace(*p))
				p++;
			if (*p == '\0')
				break;
			if (isascii(*p) && !isdigit(*p))
			{
				char *q = p;
				struct group *gr;

				while (isascii(*p) && isalnum(*p))
					p++;
				*p++ = '\0';
				if (*q == '\0')
				{
					syserr("mailer %s: null group name",
						m->m_name);
					break;
				}
				gr = getgrnam(q);
				if (gr == NULL)
				{
					syserr("readcf: mailer U= flag: unknown group %s", q);
					break;
				}
				else
					m->m_gid = gr->gr_gid;
			}
			else
			{
				m->m_gid = strtol(p, NULL, 0);
			}
			break;

		  case 'W':		/* wait timeout */
			m->m_wait = convtime(p, 's');
			break;

		  case '/':		/* new root directory */
			if (*p == '\0')
				syserr("mailer %s: null root directory",
					m->m_name);
			else
				m->m_rootdir = newstr(p);
			break;

		  default:
			syserr("M%s: unknown mailer equate %c=",
			       m->m_name, fcode);
			break;
		}

		p = delimptr;
	}

#if !HASRRESVPORT
	if (bitnset(M_SECURE_PORT, m->m_flags))
	{
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "M%s: Warning: F=%c set on system that doesn't support rresvport()\n",
				     m->m_name, M_SECURE_PORT);
	}
#endif /* !HASRRESVPORT */

#if !HASNICE
	if (m->m_nice != 0)
	{
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "M%s: Warning: N= set on system that doesn't support nice()\n",
				     m->m_name);
	}
#endif /* !HASNICE */

	/* do some rationality checking */
	if (m->m_argv == NULL)
	{
		syserr("M%s: A= argument required", m->m_name);
		return;
	}
	if (m->m_mailer == NULL)
	{
		syserr("M%s: P= argument required", m->m_name);
		return;
	}

	if (nextmailer >= MAXMAILERS)
	{
		syserr("too many mailers defined (%d max)", MAXMAILERS);
		return;
	}

	if (m->m_maxrcpt <= 0)
		m->m_maxrcpt = DEFAULT_MAX_RCPT;

	/* do some heuristic cleanup for back compatibility */
	if (bitnset(M_LIMITS, m->m_flags))
	{
		if (m->m_linelimit == 0)
			m->m_linelimit = SMTPLINELIM;
		if (ConfigLevel < 2)
			setbitn(M_7BITS, m->m_flags);
	}

	if (strcmp(m->m_mailer, "[TCP]") == 0)
	{
		syserr("M%s: P=[TCP] must be replaced by P=[IPC]", m->m_name);
		return;
	}

	if (strcmp(m->m_mailer, "[IPC]") == 0)
	{
		/* Use the second argument for host or path to socket */
		if (m->m_argv[0] == NULL || m->m_argv[1] == NULL ||
		    m->m_argv[1][0] == '\0')
		{
			syserr("M%s: too few parameters for %s mailer",
			       m->m_name, m->m_mailer);
			return;
		}
		if (strcmp(m->m_argv[0], "TCP") != 0
#if NETUNIX
		    && strcmp(m->m_argv[0], "FILE") != 0
#endif /* NETUNIX */
		    )
		{
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "M%s: Warning: first argument in %s mailer must be %s\n",
					     m->m_name, m->m_mailer,
#if NETUNIX
					     "TCP or FILE"
#else /* NETUNIX */
					     "TCP"
#endif /* NETUNIX */
				     );
		}
		if (m->m_mtatype == NULL)
			m->m_mtatype = "dns";
		if (m->m_addrtype == NULL)
			m->m_addrtype = "rfc822";
		if (m->m_diagtype == NULL)
		{
			if (m->m_argv[0] != NULL &&
			    strcmp(m->m_argv[0], "FILE") == 0)
				m->m_diagtype = "x-unix";
			else
				m->m_diagtype = "smtp";
		}
	}
	else if (strcmp(m->m_mailer, "[FILE]") == 0)
	{
		/* Use the second argument for filename */
		if (m->m_argv[0] == NULL || m->m_argv[1] == NULL ||
		    m->m_argv[2] != NULL)
		{
			syserr("M%s: too %s parameters for [FILE] mailer",
			       m->m_name,
			       (m->m_argv[0] == NULL ||
				m->m_argv[1] == NULL) ? "few" : "many");
			return;
		}
		else if (strcmp(m->m_argv[0], "FILE") != 0)
		{
			syserr("M%s: first argument in [FILE] mailer must be FILE",
			       m->m_name);
			return;
		}
	}

	if (m->m_eol == NULL)
	{
		char **pp;

		/* default for SMTP is \r\n; use \n for local delivery */
		for (pp = m->m_argv; *pp != NULL; pp++)
		{
			for (p = *pp; *p != '\0'; )
			{
				if ((*p++ & 0377) == MACROEXPAND && *p == 'u')
					break;
			}
			if (*p != '\0')
				break;
		}
		if (*pp == NULL)
			m->m_eol = "\r\n";
		else
			m->m_eol = "\n";
	}

	/* enter the mailer into the symbol table */
	s = stab(m->m_name, ST_MAILER, ST_ENTER);
	if (s->s_mailer != NULL)
	{
		i = s->s_mailer->m_mno;
		sm_free(s->s_mailer); /* XXX */
	}
	else
	{
		i = nextmailer++;
	}
	Mailer[i] = s->s_mailer = m;
	m->m_mno = i;
}
/*
**  MUNCHSTRING -- translate a string into internal form.
**
**	Parameters:
**		p -- the string to munch.
**		delimptr -- if non-NULL, set to the pointer of the
**			field delimiter character.
**		delim -- the delimiter for the field.
**
**	Returns:
**		the munched string.
**
**	Side Effects:
**		the munched string is a local static buffer.
**		it must be copied before the function is called again.
*/

char *
munchstring(p, delimptr, delim)
	register char *p;
	char **delimptr;
	int delim;
{
	register char *q;
	bool backslash = false;
	bool quotemode = false;
	static char buf[MAXLINE];

	for (q = buf; *p != '\0' && q < &buf[sizeof(buf) - 1]; p++)
	{
		if (backslash)
		{
			/* everything is roughly literal */
			backslash = false;
			switch (*p)
			{
			  case 'r':		/* carriage return */
				*q++ = '\r';
				continue;

			  case 'n':		/* newline */
				*q++ = '\n';
				continue;

			  case 'f':		/* form feed */
				*q++ = '\f';
				continue;

			  case 'b':		/* backspace */
				*q++ = '\b';
				continue;
			}
			*q++ = *p;
		}
		else
		{
			if (*p == '\\')
				backslash = true;
			else if (*p == '"')
				quotemode = !quotemode;
			else if (quotemode || *p != delim)
				*q++ = *p;
			else
				break;
		}
	}

	if (delimptr != NULL)
		*delimptr = p;
	*q++ = '\0';
	return buf;
}
/*
**  EXTRQUOTSTR -- extract a (quoted) string.
**
**	This routine deals with quoted (") strings and escaped
**	spaces (\\ ).
**
**	Parameters:
**		p -- source string.
**		delimptr -- if non-NULL, set to the pointer of the
**			field delimiter character.
**		delimbuf -- delimiters for the field.
**		st -- if non-NULL, store the return value (whether the
**			string was correctly quoted) here.
**
**	Returns:
**		the extracted string.
**
**	Side Effects:
**		the returned string is a local static buffer.
**		it must be copied before the function is called again.
*/

static char *
extrquotstr(p, delimptr, delimbuf, st)
	register char *p;
	char **delimptr;
	char *delimbuf;
	bool *st;
{
	register char *q;
	bool backslash = false;
	bool quotemode = false;
	static char buf[MAXLINE];

	for (q = buf; *p != '\0' && q < &buf[sizeof(buf) - 1]; p++)
	{
		if (backslash)
		{
			backslash = false;
			if (*p != ' ')
				*q++ = '\\';
		}
		if (*p == '\\')
			backslash = true;
		else if (*p == '"')
			quotemode = !quotemode;
		else if (quotemode ||
			 strchr(delimbuf, (int) *p) == NULL)
			*q++ = *p;
		else
			break;
	}

	if (delimptr != NULL)
		*delimptr = p;
	*q++ = '\0';
	if (st != NULL)
		*st = !(quotemode || backslash);
	return buf;
}
/*
**  MAKEARGV -- break up a string into words
**
**	Parameters:
**		p -- the string to break up.
**
**	Returns:
**		a char **argv (dynamically allocated)
**
**	Side Effects:
**		munges p.
*/

static char **
makeargv(p)
	register char *p;
{
	char *q;
	int i;
	char **avp;
	char *argv[MAXPV + 1];

	/* take apart the words */
	i = 0;
	while (*p != '\0' && i < MAXPV)
	{
		q = p;
		while (*p != '\0' && !(isascii(*p) && isspace(*p)))
			p++;
		while (isascii(*p) && isspace(*p))
			*p++ = '\0';
		argv[i++] = newstr(q);
	}
	argv[i++] = NULL;

	/* now make a copy of the argv */
	avp = (char **) xalloc(sizeof(*avp) * i);
	memmove((char *) avp, (char *) argv, sizeof(*avp) * i);

	return avp;
}
/*
**  PRINTRULES -- print rewrite rules (for debugging)
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		prints rewrite rules.
*/

void
printrules()
{
	register struct rewrite *rwp;
	register int ruleset;

	for (ruleset = 0; ruleset < 10; ruleset++)
	{
		if (RewriteRules[ruleset] == NULL)
			continue;
		sm_dprintf("\n----Rule Set %d:", ruleset);

		for (rwp = RewriteRules[ruleset]; rwp != NULL; rwp = rwp->r_next)
		{
			sm_dprintf("\nLHS:");
			printav(sm_debug_file(), rwp->r_lhs);
			sm_dprintf("RHS:");
			printav(sm_debug_file(), rwp->r_rhs);
		}
	}
}
/*
**  PRINTMAILER -- print mailer structure (for debugging)
**
**	Parameters:
**		fp -- output file
**		m -- the mailer to print
**
**	Returns:
**		none.
*/

void
printmailer(fp, m)
	SM_FILE_T *fp;
	register MAILER *m;
{
	int j;

	(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
			     "mailer %d (%s): P=%s S=", m->m_mno, m->m_name,
			     m->m_mailer);
	if (RuleSetNames[m->m_se_rwset] == NULL)
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "%d/",
				     m->m_se_rwset);
	else
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "%s/",
				     RuleSetNames[m->m_se_rwset]);
	if (RuleSetNames[m->m_sh_rwset] == NULL)
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "%d R=",
				     m->m_sh_rwset);
	else
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "%s R=",
				     RuleSetNames[m->m_sh_rwset]);
	if (RuleSetNames[m->m_re_rwset] == NULL)
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "%d/",
				     m->m_re_rwset);
	else
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "%s/",
				     RuleSetNames[m->m_re_rwset]);
	if (RuleSetNames[m->m_rh_rwset] == NULL)
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "%d ",
				     m->m_rh_rwset);
	else
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "%s ",
				     RuleSetNames[m->m_rh_rwset]);
	(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "M=%ld U=%d:%d F=",
			     m->m_maxsize, (int) m->m_uid, (int) m->m_gid);
	for (j = '\0'; j <= '\177'; j++)
		if (bitnset(j, m->m_flags))
			(void) sm_io_putc(fp, SM_TIME_DEFAULT, j);
	(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, " L=%d E=",
			     m->m_linelimit);
	xputs(fp, m->m_eol);
	if (m->m_defcharset != NULL)
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, " C=%s",
				     m->m_defcharset);
	(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, " T=%s/%s/%s",
			     m->m_mtatype == NULL
				? "<undefined>" : m->m_mtatype,
			     m->m_addrtype == NULL
				? "<undefined>" : m->m_addrtype,
			     m->m_diagtype == NULL
				? "<undefined>" : m->m_diagtype);
	(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, " r=%d", m->m_maxrcpt);
	if (m->m_argv != NULL)
	{
		char **a = m->m_argv;

		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, " A=");
		while (*a != NULL)
		{
			if (a != m->m_argv)
				(void) sm_io_fprintf(fp, SM_TIME_DEFAULT,
						     " ");
			xputs(fp, *a++);
		}
	}
	(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "\n");
}
/*
**  SETOPTION -- set global processing option
**
**	Parameters:
**		opt -- option name.
**		val -- option value (as a text string).
**		safe -- set if this came from a configuration file.
**			Some options (if set from the command line) will
**			reset the user id to avoid security problems.
**		sticky -- if set, don't let other setoptions override
**			this value.
**		e -- the main envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets options as implied by the arguments.
*/

static BITMAP256	StickyOpt;		/* set if option is stuck */

#if NAMED_BIND

static struct resolverflags
{
	char	*rf_name;	/* name of the flag */
	long	rf_bits;	/* bits to set/clear */
} ResolverFlags[] =
{
	{ "debug",	RES_DEBUG	},
	{ "aaonly",	RES_AAONLY	},
	{ "usevc",	RES_USEVC	},
	{ "primary",	RES_PRIMARY	},
	{ "igntc",	RES_IGNTC	},
	{ "recurse",	RES_RECURSE	},
	{ "defnames",	RES_DEFNAMES	},
	{ "stayopen",	RES_STAYOPEN	},
	{ "dnsrch",	RES_DNSRCH	},
# ifdef RES_USE_INET6
	{ "use_inet6",	RES_USE_INET6	},
# endif /* RES_USE_INET6 */
	{ "true",	0		},	/* avoid error on old syntax */
	{ NULL,		0		}
};

#endif /* NAMED_BIND */

#define OI_NONE		0	/* no special treatment */
#define OI_SAFE		0x0001	/* safe for random people to use */
#define OI_SUBOPT	0x0002	/* option has suboptions */

static struct optioninfo
{
	char		*o_name;	/* long name of option */
	unsigned char	o_code;		/* short name of option */
	unsigned short	o_flags;	/* option flags */
} OptionTab[] =
{
#if defined(SUN_EXTENSIONS) && defined(REMOTE_MODE)
	{ "RemoteMode",			'>',		OI_NONE	},
#endif /* defined(SUN_EXTENSIONS) && defined(REMOTE_MODE) */
	{ "SevenBitInput",		'7',		OI_SAFE	},
	{ "EightBitMode",		'8',		OI_SAFE	},
	{ "AliasFile",			'A',		OI_NONE	},
	{ "AliasWait",			'a',		OI_NONE	},
	{ "BlankSub",			'B',		OI_NONE	},
	{ "MinFreeBlocks",		'b',		OI_SAFE	},
	{ "CheckpointInterval",		'C',		OI_SAFE	},
	{ "HoldExpensive",		'c',		OI_NONE	},
	{ "DeliveryMode",		'd',		OI_SAFE	},
	{ "ErrorHeader",		'E',		OI_NONE	},
	{ "ErrorMode",			'e',		OI_SAFE	},
	{ "TempFileMode",		'F',		OI_NONE	},
	{ "SaveFromLine",		'f',		OI_NONE	},
	{ "MatchGECOS",			'G',		OI_NONE	},

	/* no long name, just here to avoid problems in setoption */
	{ "",				'g',		OI_NONE	},
	{ "HelpFile",			'H',		OI_NONE	},
	{ "MaxHopCount",		'h',		OI_NONE	},
	{ "ResolverOptions",		'I',		OI_NONE	},
	{ "IgnoreDots",			'i',		OI_SAFE	},
	{ "ForwardPath",		'J',		OI_NONE	},
	{ "SendMimeErrors",		'j',		OI_SAFE	},
	{ "ConnectionCacheSize",	'k',		OI_NONE	},
	{ "ConnectionCacheTimeout",	'K',		OI_NONE	},
	{ "UseErrorsTo",		'l',		OI_NONE	},
	{ "LogLevel",			'L',		OI_SAFE	},
	{ "MeToo",			'm',		OI_SAFE	},

	/* no long name, just here to avoid problems in setoption */
	{ "",				'M',		OI_NONE	},
	{ "CheckAliases",		'n',		OI_NONE	},
	{ "OldStyleHeaders",		'o',		OI_SAFE	},
	{ "DaemonPortOptions",		'O',		OI_NONE	},
	{ "PrivacyOptions",		'p',		OI_SAFE	},
	{ "PostmasterCopy",		'P',		OI_NONE	},
	{ "QueueFactor",		'q',		OI_NONE	},
	{ "QueueDirectory",		'Q',		OI_NONE	},
	{ "DontPruneRoutes",		'R',		OI_NONE	},
	{ "Timeout",			'r',		OI_SUBOPT },
	{ "StatusFile",			'S',		OI_NONE	},
	{ "SuperSafe",			's',		OI_SAFE	},
	{ "QueueTimeout",		'T',		OI_NONE	},
	{ "TimeZoneSpec",		't',		OI_NONE	},
	{ "UserDatabaseSpec",		'U',		OI_NONE	},
	{ "DefaultUser",		'u',		OI_NONE	},
	{ "FallbackMXhost",		'V',		OI_NONE	},
	{ "Verbose",			'v',		OI_SAFE	},
	{ "TryNullMXList",		'w',		OI_NONE	},
	{ "QueueLA",			'x',		OI_NONE	},
	{ "RefuseLA",			'X',		OI_NONE	},
	{ "RecipientFactor",		'y',		OI_NONE	},
	{ "ForkEachJob",		'Y',		OI_NONE	},
	{ "ClassFactor",		'z',		OI_NONE	},
	{ "RetryFactor",		'Z',		OI_NONE	},
#define O_QUEUESORTORD	0x81
	{ "QueueSortOrder",		O_QUEUESORTORD,	OI_SAFE	},
#define O_HOSTSFILE	0x82
	{ "HostsFile",			O_HOSTSFILE,	OI_NONE	},
#define O_MQA		0x83
	{ "MinQueueAge",		O_MQA,		OI_SAFE	},
#define O_DEFCHARSET	0x85
	{ "DefaultCharSet",		O_DEFCHARSET,	OI_SAFE	},
#define O_SSFILE	0x86
	{ "ServiceSwitchFile",		O_SSFILE,	OI_NONE	},
#define O_DIALDELAY	0x87
	{ "DialDelay",			O_DIALDELAY,	OI_SAFE	},
#define O_NORCPTACTION	0x88
	{ "NoRecipientAction",		O_NORCPTACTION,	OI_SAFE	},
#define O_SAFEFILEENV	0x89
	{ "SafeFileEnvironment",	O_SAFEFILEENV,	OI_NONE	},
#define O_MAXMSGSIZE	0x8a
	{ "MaxMessageSize",		O_MAXMSGSIZE,	OI_NONE	},
#define O_COLONOKINADDR	0x8b
	{ "ColonOkInAddr",		O_COLONOKINADDR, OI_SAFE },
#define O_MAXQUEUERUN	0x8c
	{ "MaxQueueRunSize",		O_MAXQUEUERUN,	OI_SAFE	},
#define O_MAXCHILDREN	0x8d
	{ "MaxDaemonChildren",		O_MAXCHILDREN,	OI_NONE	},
#define O_KEEPCNAMES	0x8e
	{ "DontExpandCnames",		O_KEEPCNAMES,	OI_NONE	},
#define O_MUSTQUOTE	0x8f
	{ "MustQuoteChars",		O_MUSTQUOTE,	OI_NONE	},
#define O_SMTPGREETING	0x90
	{ "SmtpGreetingMessage",	O_SMTPGREETING,	OI_NONE	},
#define O_UNIXFROM	0x91
	{ "UnixFromLine",		O_UNIXFROM,	OI_NONE	},
#define O_OPCHARS	0x92
	{ "OperatorChars",		O_OPCHARS,	OI_NONE	},
#define O_DONTINITGRPS	0x93
	{ "DontInitGroups",		O_DONTINITGRPS,	OI_NONE	},
#define O_SLFH		0x94
	{ "SingleLineFromHeader",	O_SLFH,		OI_SAFE	},
#define O_ABH		0x95
	{ "AllowBogusHELO",		O_ABH,		OI_SAFE	},
#define O_CONNTHROT	0x97
	{ "ConnectionRateThrottle",	O_CONNTHROT,	OI_NONE	},
#define O_UGW		0x99
	{ "UnsafeGroupWrites",		O_UGW,		OI_NONE	},
#define O_DBLBOUNCE	0x9a
	{ "DoubleBounceAddress",	O_DBLBOUNCE,	OI_NONE	},
#define O_HSDIR		0x9b
	{ "HostStatusDirectory",	O_HSDIR,	OI_NONE	},
#define O_SINGTHREAD	0x9c
	{ "SingleThreadDelivery",	O_SINGTHREAD,	OI_NONE	},
#define O_RUNASUSER	0x9d
	{ "RunAsUser",			O_RUNASUSER,	OI_NONE	},
#define O_DSN_RRT	0x9e
	{ "RrtImpliesDsn",		O_DSN_RRT,	OI_NONE	},
#define O_PIDFILE	0x9f
	{ "PidFile",			O_PIDFILE,	OI_NONE	},
#define O_DONTBLAMESENDMAIL	0xa0
	{ "DontBlameSendmail",		O_DONTBLAMESENDMAIL,	OI_NONE	},
#define O_DPI		0xa1
	{ "DontProbeInterfaces",	O_DPI,		OI_NONE	},
#define O_MAXRCPT	0xa2
	{ "MaxRecipientsPerMessage",	O_MAXRCPT,	OI_SAFE	},
#define O_DEADLETTER	0xa3
	{ "DeadLetterDrop",		O_DEADLETTER,	OI_NONE	},
#if _FFR_DONTLOCKFILESFORREAD_OPTION
# define O_DONTLOCK	0xa4
	{ "DontLockFilesForRead",	O_DONTLOCK,	OI_NONE	},
#endif /* _FFR_DONTLOCKFILESFORREAD_OPTION */
#define O_MAXALIASRCSN	0xa5
	{ "MaxAliasRecursion",		O_MAXALIASRCSN,	OI_NONE	},
#define O_CNCTONLYTO	0xa6
	{ "ConnectOnlyTo",		O_CNCTONLYTO,	OI_NONE	},
#define O_TRUSTUSER	0xa7
	{ "TrustedUser",		O_TRUSTUSER,	OI_NONE	},
#define O_MAXMIMEHDRLEN	0xa8
	{ "MaxMimeHeaderLength",	O_MAXMIMEHDRLEN,	OI_NONE	},
#define O_CONTROLSOCKET	0xa9
	{ "ControlSocketName",		O_CONTROLSOCKET,	OI_NONE	},
#define O_MAXHDRSLEN	0xaa
	{ "MaxHeadersLength",		O_MAXHDRSLEN,	OI_NONE	},
#if _FFR_MAX_FORWARD_ENTRIES
# define O_MAXFORWARD	0xab
	{ "MaxForwardEntries",		O_MAXFORWARD,	OI_NONE	},
#endif /* _FFR_MAX_FORWARD_ENTRIES */
#define O_PROCTITLEPREFIX	0xac
	{ "ProcessTitlePrefix",		O_PROCTITLEPREFIX,	OI_NONE	},
#define O_SASLINFO	0xad
#if _FFR_ALLOW_SASLINFO
	{ "DefaultAuthInfo",		O_SASLINFO,	OI_SAFE	},
#else /* _FFR_ALLOW_SASLINFO */
	{ "DefaultAuthInfo",		O_SASLINFO,	OI_NONE	},
#endif /* _FFR_ALLOW_SASLINFO */
#define O_SASLMECH	0xae
	{ "AuthMechanisms",		O_SASLMECH,	OI_NONE	},
#define O_CLIENTPORT	0xaf
	{ "ClientPortOptions",		O_CLIENTPORT,	OI_NONE	},
#define O_DF_BUFSIZE	0xb0
	{ "DataFileBufferSize",		O_DF_BUFSIZE,	OI_NONE	},
#define O_XF_BUFSIZE	0xb1
	{ "XscriptFileBufferSize",	O_XF_BUFSIZE,	OI_NONE	},
#define O_LDAPDEFAULTSPEC	0xb2
	{ "LDAPDefaultSpec",		O_LDAPDEFAULTSPEC,	OI_NONE	},
#define O_SRVCERTFILE	0xb4
	{ "ServerCertFile",		O_SRVCERTFILE,	OI_NONE	},
#define O_SRVKEYFILE	0xb5
	{ "ServerKeyFile",		O_SRVKEYFILE,	OI_NONE	},
#define O_CLTCERTFILE	0xb6
	{ "ClientCertFile",		O_CLTCERTFILE,	OI_NONE	},
#define O_CLTKEYFILE	0xb7
	{ "ClientKeyFile",		O_CLTKEYFILE,	OI_NONE	},
#define O_CACERTFILE	0xb8
	{ "CACertFile",			O_CACERTFILE,	OI_NONE	},
#define O_CACERTPATH	0xb9
	{ "CACertPath",			O_CACERTPATH,	OI_NONE	},
#define O_DHPARAMS	0xba
	{ "DHParameters",		O_DHPARAMS,	OI_NONE	},
#define O_INPUTMILTER	0xbb
	{ "InputMailFilters",		O_INPUTMILTER,	OI_NONE	},
#define O_MILTER	0xbc
	{ "Milter",			O_MILTER,	OI_SUBOPT	},
#define O_SASLOPTS	0xbd
	{ "AuthOptions",		O_SASLOPTS,	OI_NONE	},
#define O_QUEUE_FILE_MODE	0xbe
	{ "QueueFileMode",		O_QUEUE_FILE_MODE, OI_NONE	},
#if _FFR_TLS_1
# define O_DHPARAMS5	0xbf
	{ "DHParameters512",		O_DHPARAMS5,	OI_NONE	},
# define O_CIPHERLIST	0xc0
	{ "CipherList",			O_CIPHERLIST,	OI_NONE	},
#endif /* _FFR_TLS_1 */
#define O_RANDFILE	0xc1
	{ "RandFile",			O_RANDFILE,	OI_NONE	},
#define O_TLS_SRV_OPTS	0xc2
	{ "TLSSrvOptions",		O_TLS_SRV_OPTS,	OI_NONE	},
#define O_RCPTTHROT	0xc3
	{ "BadRcptThrottle",		O_RCPTTHROT,	OI_SAFE	},
#define O_DLVR_MIN	0xc4
	{ "DeliverByMin",		O_DLVR_MIN,	OI_NONE	},
#define O_MAXQUEUECHILDREN	0xc5
	{ "MaxQueueChildren",		O_MAXQUEUECHILDREN,	OI_NONE	},
#define O_MAXRUNNERSPERQUEUE	0xc6
	{ "MaxRunnersPerQueue",		O_MAXRUNNERSPERQUEUE,	OI_NONE },
#define O_DIRECTSUBMODIFIERS	0xc7
	{ "DirectSubmissionModifiers",	O_DIRECTSUBMODIFIERS,	OI_NONE },
#define O_NICEQUEUERUN	0xc8
	{ "NiceQueueRun",		O_NICEQUEUERUN,	OI_NONE	},
#define O_SHMKEY	0xc9
	{ "SharedMemoryKey",		O_SHMKEY,	OI_NONE	},
#define O_SASLBITS	0xca
	{ "AuthMaxBits",		O_SASLBITS,	OI_NONE	},
#define O_MBDB		0xcb
	{ "MailboxDatabase",		O_MBDB,		OI_NONE	},
#define O_MSQ		0xcc
	{ "UseMSP",	O_MSQ,		OI_NONE	},
#define O_DELAY_LA	0xcd
	{ "DelayLA",	O_DELAY_LA,	OI_NONE	},
#define O_FASTSPLIT	0xce
	{ "FastSplit",	O_FASTSPLIT,	OI_NONE	},
#define O_SOFTBOUNCE	0xcf
	{ "SoftBounce",	O_SOFTBOUNCE,	OI_NONE	},
#define O_SHMKEYFILE	0xd0
	{ "SharedMemoryKeyFile",	O_SHMKEYFILE,	OI_NONE	},
#define O_REJECTLOGINTERVAL	0xd1
	{ "RejectLogInterval",	O_REJECTLOGINTERVAL,	OI_NONE	},
#define O_REQUIRES_DIR_FSYNC	0xd2
	{ "RequiresDirfsync",	O_REQUIRES_DIR_FSYNC,	OI_NONE	},
#define O_CONNECTION_RATE_WINDOW_SIZE	0xd3
	{ "ConnectionRateWindowSize", O_CONNECTION_RATE_WINDOW_SIZE, OI_NONE },
#define O_CRLFILE	0xd4
	{ "CRLFile",		O_CRLFILE,	OI_NONE	},
#define O_FALLBACKSMARTHOST	0xd5
	{ "FallbackSmartHost",		O_FALLBACKSMARTHOST,	OI_NONE	},
#define O_SASLREALM	0xd6
	{ "AuthRealm",		O_SASLREALM,	OI_NONE	},
#if _FFR_CRLPATH
# define O_CRLPATH	0xd7
	{ "CRLPath",		O_CRLPATH,	OI_NONE	},
#endif /* _FFR_CRLPATH */
#define O_HELONAME 0xd8
	{ "HeloName",   O_HELONAME,     OI_NONE },
#if _FFR_MEMSTAT
# define O_REFUSELOWMEM	0xd9
	{ "RefuseLowMem",	O_REFUSELOWMEM,	OI_NONE },
# define O_QUEUELOWMEM	0xda
	{ "QueueLowMem",	O_QUEUELOWMEM,	OI_NONE },
# define O_MEMRESOURCE	0xdb
	{ "MemoryResource",	O_MEMRESOURCE,	OI_NONE },
#endif /* _FFR_MEMSTAT */
#define O_MAXNOOPCOMMANDS 0xdc
	{ "MaxNOOPCommands",	O_MAXNOOPCOMMANDS,	OI_NONE },
#if _FFR_MSG_ACCEPT
# define O_MSG_ACCEPT 0xdd
	{ "MessageAccept",	O_MSG_ACCEPT,	OI_NONE },
#endif /* _FFR_MSG_ACCEPT */
#if _FFR_QUEUE_RUN_PARANOIA
# define O_CHK_Q_RUNNERS 0xde
	{ "CheckQueueRunners",	O_CHK_Q_RUNNERS,	OI_NONE },
#endif /* _FFR_QUEUE_RUN_PARANOIA */
#if _FFR_EIGHT_BIT_ADDR_OK
# if !ALLOW_255
#  ERROR FFR_EIGHT_BIT_ADDR_OK requires _ALLOW_255
# endif /* !ALLOW_255 */
# define O_EIGHT_BIT_ADDR_OK	0xdf
	{ "EightBitAddrOK",	O_EIGHT_BIT_ADDR_OK,	OI_NONE },
#endif /* _FFR_EIGHT_BIT_ADDR_OK */
#if _FFR_ADDR_TYPE_MODES
# define O_ADDR_TYPE_MODES	0xe0
	{ "AddrTypeModes",	O_ADDR_TYPE_MODES,	OI_NONE },
#endif /* _FFR_ADDR_TYPE_MODES */
#if _FFR_BADRCPT_SHUTDOWN
# define O_RCPTSHUTD	0xe1
	{ "BadRcptShutdown",		O_RCPTSHUTD,	OI_SAFE },
# define O_RCPTSHUTDG	0xe2
	{ "BadRcptShutdownGood",	O_RCPTSHUTDG,	OI_SAFE	},
#endif /* _FFR_BADRCPT_SHUTDOWN */
#if STARTTLS && _FFR_TLS_1
# define O_SRV_SSL_OPTIONS	0xe3
	{ "ServerSSLOptions",		O_SRV_SSL_OPTIONS,	OI_NONE	},
# define O_CLT_SSL_OPTIONS	0xe4
	{ "ClientSSLOptions",		O_CLT_SSL_OPTIONS,	OI_NONE	},
#endif /* STARTTLS && _FFR_TLS_1 */
#if _FFR_EXPDELAY
# define O_MAX_QUEUE_AGE	0xe5
	{ "MaxQueueAge",	O_MAX_QUEUE_AGE,	OI_NONE },
#endif /* _FFR_EXPDELAY */
#if _FFR_RCPTTHROTDELAY
# define O_RCPTTHROTDELAY	0xe6
	{ "BadRcptThrottleDelay",	O_RCPTTHROTDELAY,	OI_SAFE	},
#endif /* _FFR_RCPTTHROTDELAY */
#if 0 && _FFR_QOS && defined(SOL_IP) && defined(IP_TOS)
# define O_INETQOS	0xe7	/* reserved for FFR_QOS */
	{ "InetQoS",			O_INETQOS,	OI_NONE },
#endif
#if STARTTLS && _FFR_FIPSMODE
# define O_FIPSMODE	0xe8
	{ "FIPSMode",		O_FIPSMODE,	OI_NONE	},
#endif /* STARTTLS && _FFR_FIPSMODE  */
#if _FFR_REJECT_NUL_BYTE
# define O_REJECTNUL	0xe9
	{ "RejectNUL",	O_REJECTNUL,	OI_SAFE	},
#endif /* _FFR_REJECT_NUL_BYTE */

	{ NULL,				'\0',		OI_NONE	}
};

#if STARTTLS && _FFR_TLS_1
static struct ssl_options
{
	const char	*sslopt_name;	/* name of the flag */
	long		sslopt_bits;	/* bits to set/clear */
} SSL_Option[] =
{
/* Workaround for bugs are turned on by default (as well as some others) */
#ifdef SSL_OP_MICROSOFT_SESS_ID_BUG
	{ "SSL_OP_MICROSOFT_SESS_ID_BUG",	SSL_OP_MICROSOFT_SESS_ID_BUG	},
#endif
#ifdef SSL_OP_NETSCAPE_CHALLENGE_BUG
	{ "SSL_OP_NETSCAPE_CHALLENGE_BUG",	SSL_OP_NETSCAPE_CHALLENGE_BUG	},
#endif
#ifdef SSL_OP_LEGACY_SERVER_CONNECT
	{ "SSL_OP_LEGACY_SERVER_CONNECT",	SSL_OP_LEGACY_SERVER_CONNECT	},
#endif
#ifdef SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG
	{ "SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG",	SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG	},
#endif
#ifdef SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG
	{ "SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG",	SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG	},
#endif
#ifdef SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER
	{ "SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER",	SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER	},
#endif
#ifdef SSL_OP_MSIE_SSLV2_RSA_PADDING
	{ "SSL_OP_MSIE_SSLV2_RSA_PADDING",	SSL_OP_MSIE_SSLV2_RSA_PADDING	},
#endif
#ifdef SSL_OP_SSLEAY_080_CLIENT_DH_BUG
	{ "SSL_OP_SSLEAY_080_CLIENT_DH_BUG",	SSL_OP_SSLEAY_080_CLIENT_DH_BUG	},
#endif
#ifdef SSL_OP_TLS_D5_BUG
	{ "SSL_OP_TLS_D5_BUG",	SSL_OP_TLS_D5_BUG	},
#endif
#ifdef SSL_OP_TLS_BLOCK_PADDING_BUG
	{ "SSL_OP_TLS_BLOCK_PADDING_BUG",	SSL_OP_TLS_BLOCK_PADDING_BUG	},
#endif
#ifdef SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
	{ "SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS",	SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS	},
#endif
#ifdef SSL_OP_ALL
	{ "SSL_OP_ALL",	SSL_OP_ALL	},
#endif
#ifdef SSL_OP_NO_QUERY_MTU
	{ "SSL_OP_NO_QUERY_MTU",	SSL_OP_NO_QUERY_MTU	},
#endif
#ifdef SSL_OP_COOKIE_EXCHANGE
	{ "SSL_OP_COOKIE_EXCHANGE",	SSL_OP_COOKIE_EXCHANGE	},
#endif
#ifdef SSL_OP_NO_TICKET
	{ "SSL_OP_NO_TICKET",	SSL_OP_NO_TICKET	},
#endif
#ifdef SSL_OP_CISCO_ANYCONNECT
	{ "SSL_OP_CISCO_ANYCONNECT",	SSL_OP_CISCO_ANYCONNECT	},
#endif
#ifdef SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION
	{ "SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION",	SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION	},
#endif
#ifdef SSL_OP_NO_COMPRESSION
	{ "SSL_OP_NO_COMPRESSION",	SSL_OP_NO_COMPRESSION	},
#endif
#ifdef SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION
	{ "SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION",	SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION	},
#endif
#ifdef SSL_OP_SINGLE_ECDH_USE
	{ "SSL_OP_SINGLE_ECDH_USE",	SSL_OP_SINGLE_ECDH_USE	},
#endif
#ifdef SSL_OP_SINGLE_DH_USE
	{ "SSL_OP_SINGLE_DH_USE",	SSL_OP_SINGLE_DH_USE	},
#endif
#ifdef SSL_OP_EPHEMERAL_RSA
	{ "SSL_OP_EPHEMERAL_RSA",	SSL_OP_EPHEMERAL_RSA	},
#endif
#ifdef SSL_OP_CIPHER_SERVER_PREFERENCE
	{ "SSL_OP_CIPHER_SERVER_PREFERENCE",	SSL_OP_CIPHER_SERVER_PREFERENCE	},
#endif
#ifdef SSL_OP_TLS_ROLLBACK_BUG
	{ "SSL_OP_TLS_ROLLBACK_BUG",	SSL_OP_TLS_ROLLBACK_BUG	},
#endif
#ifdef SSL_OP_NO_SSLv2
	{ "SSL_OP_NO_SSLv2",	SSL_OP_NO_SSLv2	},
#endif
#ifdef SSL_OP_NO_SSLv3
	{ "SSL_OP_NO_SSLv3",	SSL_OP_NO_SSLv3	},
#endif
#ifdef SSL_OP_NO_TLSv1
	{ "SSL_OP_NO_TLSv1",	SSL_OP_NO_TLSv1	},
#endif
#ifdef SSL_OP_NO_TLSv1_2
	{ "SSL_OP_NO_TLSv1_2",	SSL_OP_NO_TLSv1_2	},
#endif
#ifdef SSL_OP_NO_TLSv1_1
	{ "SSL_OP_NO_TLSv1_1",	SSL_OP_NO_TLSv1_1	},
#endif
#ifdef SSL_OP_PKCS1_CHECK_1
	{ "SSL_OP_PKCS1_CHECK_1",	SSL_OP_PKCS1_CHECK_1	},
#endif
#ifdef SSL_OP_PKCS1_CHECK_2
	{ "SSL_OP_PKCS1_CHECK_2",	SSL_OP_PKCS1_CHECK_2	},
#endif
#ifdef SSL_OP_NETSCAPE_CA_DN_BUG
	{ "SSL_OP_NETSCAPE_CA_DN_BUG",	SSL_OP_NETSCAPE_CA_DN_BUG	},
#endif
#ifdef SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG
	{ "SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG",	SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG	},
#endif
#ifdef SSL_OP_CRYPTOPRO_TLSEXT_BUG
	{ "SSL_OP_CRYPTOPRO_TLSEXT_BUG",	SSL_OP_CRYPTOPRO_TLSEXT_BUG	},
#endif
	{ NULL,		0		}
};
#endif /* STARTTLS && _FFR_TLS_1 */


# define CANONIFY(val)

# define SET_OPT_DEFAULT(opt, val)	opt = val

/* set a string option by expanding the value and assigning it */
/* WARNING this belongs ONLY into a case statement! */
#define SET_STRING_EXP(str)	\
		expand(val, exbuf, sizeof(exbuf), e);	\
		newval = sm_pstrdup_x(exbuf);		\
		if (str != NULL)	\
			sm_free(str);	\
		CANONIFY(newval);	\
		str = newval;		\
		break

#define OPTNAME	o->o_name == NULL ? "<unknown>" : o->o_name

void
setoption(opt, val, safe, sticky, e)
	int opt;
	char *val;
	bool safe;
	bool sticky;
	register ENVELOPE *e;
{
	register char *p;
	register struct optioninfo *o;
	char *subopt;
	int mid;
	bool can_setuid = RunAsUid == 0;
	auto char *ep;
	char buf[50];
	extern bool Warn_Q_option;
#if _FFR_ALLOW_SASLINFO
	extern unsigned int SubmitMode;
#endif /* _FFR_ALLOW_SASLINFO */
#if STARTTLS || SM_CONF_SHM
	char *newval;
	char exbuf[MAXLINE];
#endif /* STARTTLS || SM_CONF_SHM */
#if STARTTLS && _FFR_TLS_1
	long *pssloptions = NULL;
#endif /* STARTTLS && _FFR_TLS_1 */

	errno = 0;
	if (opt == ' ')
	{
		/* full word options */
		struct optioninfo *sel;

		p = strchr(val, '=');
		if (p == NULL)
			p = &val[strlen(val)];
		while (*--p == ' ')
			continue;
		while (*++p == ' ')
			*p = '\0';
		if (p == val)
		{
			syserr("readcf: null option name");
			return;
		}
		if (*p == '=')
			*p++ = '\0';
		while (*p == ' ')
			p++;
		subopt = strchr(val, '.');
		if (subopt != NULL)
			*subopt++ = '\0';
		sel = NULL;
		for (o = OptionTab; o->o_name != NULL; o++)
		{
			if (sm_strncasecmp(o->o_name, val, strlen(val)) != 0)
				continue;
			if (strlen(o->o_name) == strlen(val))
			{
				/* completely specified -- this must be it */
				sel = NULL;
				break;
			}
			if (sel != NULL)
				break;
			sel = o;
		}
		if (sel != NULL && o->o_name == NULL)
			o = sel;
		else if (o->o_name == NULL)
		{
			syserr("readcf: unknown option name %s", val);
			return;
		}
		else if (sel != NULL)
		{
			syserr("readcf: ambiguous option name %s (matches %s and %s)",
				val, sel->o_name, o->o_name);
			return;
		}
		if (strlen(val) != strlen(o->o_name))
		{
			int oldVerbose = Verbose;

			Verbose = 1;
			message("Option %s used as abbreviation for %s",
				val, o->o_name);
			Verbose = oldVerbose;
		}
		opt = o->o_code;
		val = p;
	}
	else
	{
		for (o = OptionTab; o->o_name != NULL; o++)
		{
			if (o->o_code == opt)
				break;
		}
		if (o->o_name == NULL)
		{
			syserr("readcf: unknown option name 0x%x", opt & 0xff);
			return;
		}
		subopt = NULL;
	}

	if (subopt != NULL && !bitset(OI_SUBOPT, o->o_flags))
	{
		if (tTd(37, 1))
			sm_dprintf("setoption: %s does not support suboptions, ignoring .%s\n",
				   OPTNAME, subopt);
		subopt = NULL;
	}

	if (tTd(37, 1))
	{
		sm_dprintf(isascii(opt) && isprint(opt) ?
			   "setoption %s (%c)%s%s=" :
			   "setoption %s (0x%x)%s%s=",
			   OPTNAME, opt, subopt == NULL ? "" : ".",
			   subopt == NULL ? "" : subopt);
		xputs(sm_debug_file(), val);
	}

	/*
	**  See if this option is preset for us.
	*/

	if (!sticky && bitnset(opt, StickyOpt))
	{
		if (tTd(37, 1))
			sm_dprintf(" (ignored)\n");
		return;
	}

	/*
	**  Check to see if this option can be specified by this user.
	*/

	if (!safe && RealUid == 0)
		safe = true;
	if (!safe && !bitset(OI_SAFE, o->o_flags))
	{
		if (opt != 'M' || (val[0] != 'r' && val[0] != 's'))
		{
			int dp;

			if (tTd(37, 1))
				sm_dprintf(" (unsafe)");
			dp = drop_privileges(true);
			setstat(dp);
		}
	}
	if (tTd(37, 1))
		sm_dprintf("\n");

	switch (opt & 0xff)
	{
	  case '7':		/* force seven-bit input */
		SevenBitInput = atobool(val);
		break;

	  case '8':		/* handling of 8-bit input */
#if MIME8TO7
		switch (*val)
		{
		  case 'p':		/* pass 8 bit, convert MIME */
			MimeMode = MM_CVTMIME|MM_PASS8BIT;
			break;

		  case 'm':		/* convert 8-bit, convert MIME */
			MimeMode = MM_CVTMIME|MM_MIME8BIT;
			break;

		  case 's':		/* strict adherence */
			MimeMode = MM_CVTMIME;
			break;

# if 0
		  case 'r':		/* reject 8-bit, don't convert MIME */
			MimeMode = 0;
			break;

		  case 'j':		/* "just send 8" */
			MimeMode = MM_PASS8BIT;
			break;

		  case 'a':		/* encode 8 bit if available */
			MimeMode = MM_MIME8BIT|MM_PASS8BIT|MM_CVTMIME;
			break;

		  case 'c':		/* convert 8 bit to MIME, never 7 bit */
			MimeMode = MM_MIME8BIT;
			break;
# endif /* 0 */

		  default:
			syserr("Unknown 8-bit mode %c", *val);
			finis(false, true, EX_USAGE);
		}
#else /* MIME8TO7 */
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: Option: %s requires MIME8TO7 support\n",
				     OPTNAME);
#endif /* MIME8TO7 */
		break;

	  case 'A':		/* set default alias file */
		if (val[0] == '\0')
		{
			char *al;

			SET_OPT_DEFAULT(al, "aliases");
			setalias(al);
		}
		else
			setalias(val);
		break;

	  case 'a':		/* look N minutes for "@@:@@" in alias file */
		if (val[0] == '\0')
			SafeAlias = 5 MINUTES;
		else
			SafeAlias = convtime(val, 'm');
		break;

	  case 'B':		/* substitution for blank character */
		SpaceSub = val[0];
		if (SpaceSub == '\0')
			SpaceSub = ' ';
		break;

	  case 'b':		/* min blocks free on queue fs/max msg size */
		p = strchr(val, '/');
		if (p != NULL)
		{
			*p++ = '\0';
			MaxMessageSize = atol(p);
		}
		MinBlocksFree = atol(val);
		break;

	  case 'c':		/* don't connect to "expensive" mailers */
		NoConnect = atobool(val);
		break;

	  case 'C':		/* checkpoint every N addresses */
		if (safe || CheckpointInterval > atoi(val))
			CheckpointInterval = atoi(val);
		break;

	  case 'd':		/* delivery mode */
		switch (*val)
		{
		  case '\0':
			set_delivery_mode(SM_DELIVER, e);
			break;

		  case SM_QUEUE:	/* queue only */
		  case SM_DEFER:	/* queue only and defer map lookups */
		  case SM_DELIVER:	/* do everything */
		  case SM_FORK:		/* fork after verification */
#if _FFR_DM_ONE
		/* deliver first TA in background, then queue */
		  case SM_DM_ONE:
#endif /* _FFR_DM_ONE */
			set_delivery_mode(*val, e);
			break;


		  default:
			syserr("Unknown delivery mode %c", *val);
			finis(false, true, EX_USAGE);
		}
		break;

	  case 'E':		/* error message header/header file */
		if (*val != '\0')
			ErrMsgFile = newstr(val);
		break;

	  case 'e':		/* set error processing mode */
		switch (*val)
		{
		  case EM_QUIET:	/* be silent about it */
		  case EM_MAIL:		/* mail back */
		  case EM_BERKNET:	/* do berknet error processing */
		  case EM_WRITE:	/* write back (or mail) */
		  case EM_PRINT:	/* print errors normally (default) */
			e->e_errormode = *val;
			break;
		}
		break;

	  case 'F':		/* file mode */
		FileMode = atooct(val) & 0777;
		break;

	  case 'f':		/* save Unix-style From lines on front */
		SaveFrom = atobool(val);
		break;

	  case 'G':		/* match recipients against GECOS field */
		MatchGecos = atobool(val);
		break;

	  case 'g':		/* default gid */
  g_opt:
		if (isascii(*val) && isdigit(*val))
			DefGid = atoi(val);
		else
		{
			register struct group *gr;

			DefGid = -1;
			gr = getgrnam(val);
			if (gr == NULL)
				syserr("readcf: option %c: unknown group %s",
					opt, val);
			else
				DefGid = gr->gr_gid;
		}
		break;

	  case 'H':		/* help file */
		if (val[0] == '\0')
		{
			SET_OPT_DEFAULT(HelpFile, "helpfile");
		}
		else
		{
			CANONIFY(val);
			HelpFile = newstr(val);
		}
		break;

	  case 'h':		/* maximum hop count */
		MaxHopCount = atoi(val);
		break;

	  case 'I':		/* use internet domain name server */
#if NAMED_BIND
		for (p = val; *p != 0; )
		{
			bool clearmode;
			char *q;
			struct resolverflags *rfp;

			while (*p == ' ')
				p++;
			if (*p == '\0')
				break;
			clearmode = false;
			if (*p == '-')
				clearmode = true;
			else if (*p != '+')
				p--;
			p++;
			q = p;
			while (*p != '\0' && !(isascii(*p) && isspace(*p)))
				p++;
			if (*p != '\0')
				*p++ = '\0';
			if (sm_strcasecmp(q, "HasWildcardMX") == 0)
			{
				HasWildcardMX = !clearmode;
				continue;
			}
			if (sm_strcasecmp(q, "WorkAroundBrokenAAAA") == 0)
			{
				WorkAroundBrokenAAAA = !clearmode;
				continue;
			}
			for (rfp = ResolverFlags; rfp->rf_name != NULL; rfp++)
			{
				if (sm_strcasecmp(q, rfp->rf_name) == 0)
					break;
			}
			if (rfp->rf_name == NULL)
				syserr("readcf: I option value %s unrecognized", q);
			else if (clearmode)
				_res.options &= ~rfp->rf_bits;
			else
				_res.options |= rfp->rf_bits;
		}
		if (tTd(8, 2))
			sm_dprintf("_res.options = %x, HasWildcardMX = %d\n",
				   (unsigned int) _res.options, HasWildcardMX);
#else /* NAMED_BIND */
		usrerr("name server (I option) specified but BIND not compiled in");
#endif /* NAMED_BIND */
		break;

	  case 'i':		/* ignore dot lines in message */
		IgnrDot = atobool(val);
		break;

	  case 'j':		/* send errors in MIME (RFC 1341) format */
		SendMIMEErrors = atobool(val);
		break;

	  case 'J':		/* .forward search path */
		CANONIFY(val);
		ForwardPath = newstr(val);
		break;

	  case 'k':		/* connection cache size */
		MaxMciCache = atoi(val);
		if (MaxMciCache < 0)
			MaxMciCache = 0;
		break;

	  case 'K':		/* connection cache timeout */
		MciCacheTimeout = convtime(val, 'm');
		break;

	  case 'l':		/* use Errors-To: header */
		UseErrorsTo = atobool(val);
		break;

	  case 'L':		/* log level */
		if (safe || LogLevel < atoi(val))
			LogLevel = atoi(val);
		break;

	  case 'M':		/* define macro */
		sticky = false;
		mid = macid_parse(val, &ep);
		if (mid == 0)
			break;
		p = newstr(ep);
		if (!safe)
			cleanstrcpy(p, p, strlen(p) + 1);
		macdefine(&CurEnv->e_macro, A_TEMP, mid, p);
		break;

	  case 'm':		/* send to me too */
		MeToo = atobool(val);
		break;

	  case 'n':		/* validate RHS in newaliases */
		CheckAliases = atobool(val);
		break;

	    /* 'N' available -- was "net name" */

	  case 'O':		/* daemon options */
		if (!setdaemonoptions(val))
			syserr("too many daemons defined (%d max)", MAXDAEMONS);
		break;

	  case 'o':		/* assume old style headers */
		if (atobool(val))
			CurEnv->e_flags |= EF_OLDSTYLE;
		else
			CurEnv->e_flags &= ~EF_OLDSTYLE;
		break;

	  case 'p':		/* select privacy level */
		p = val;
		for (;;)
		{
			register struct prival *pv;
			extern struct prival PrivacyValues[];

			while (isascii(*p) && (isspace(*p) || ispunct(*p)))
				p++;
			if (*p == '\0')
				break;
			val = p;
			while (isascii(*p) && isalnum(*p))
				p++;
			if (*p != '\0')
				*p++ = '\0';

			for (pv = PrivacyValues; pv->pv_name != NULL; pv++)
			{
				if (sm_strcasecmp(val, pv->pv_name) == 0)
					break;
			}
			if (pv->pv_name == NULL)
				syserr("readcf: Op line: %s unrecognized", val);
			else
				PrivacyFlags |= pv->pv_flag;
		}
		sticky = false;
		break;

	  case 'P':		/* postmaster copy address for returned mail */
		PostMasterCopy = newstr(val);
		break;

	  case 'q':		/* slope of queue only function */
		QueueFactor = atoi(val);
		break;

	  case 'Q':		/* queue directory */
		if (val[0] == '\0')
		{
			QueueDir = "mqueue";
		}
		else
		{
			QueueDir = newstr(val);
		}
		if (RealUid != 0 && !safe)
			Warn_Q_option = true;
		break;

	  case 'R':		/* don't prune routes */
		DontPruneRoutes = atobool(val);
		break;

	  case 'r':		/* read timeout */
		if (subopt == NULL)
			inittimeouts(val, sticky);
		else
			settimeout(subopt, val, sticky);
		break;

	  case 'S':		/* status file */
		if (val[0] == '\0')
		{
			SET_OPT_DEFAULT(StatFile, "statistics");
		}
		else
		{
			CANONIFY(val);
			StatFile = newstr(val);
		}
		break;

	  case 's':		/* be super safe, even if expensive */
		if (tolower(*val) == 'i')
			SuperSafe = SAFE_INTERACTIVE;
		else if (tolower(*val) == 'p')
#if MILTER
			SuperSafe = SAFE_REALLY_POSTMILTER;
#else /* MILTER */
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				"Warning: SuperSafe=PostMilter requires Milter support (-DMILTER)\n");
#endif /* MILTER */
		else
			SuperSafe = atobool(val) ? SAFE_REALLY : SAFE_NO;
		break;

	  case 'T':		/* queue timeout */
		p = strchr(val, '/');
		if (p != NULL)
		{
			*p++ = '\0';
			settimeout("queuewarn", p, sticky);
		}
		settimeout("queuereturn", val, sticky);
		break;

	  case 't':		/* time zone name */
		TimeZoneSpec = newstr(val);
		break;

	  case 'U':		/* location of user database */
		UdbSpec = newstr(val);
		break;

	  case 'u':		/* set default uid */
		for (p = val; *p != '\0'; p++)
		{
# if _FFR_DOTTED_USERNAMES
			if (*p == '/' || *p == ':')
# else /* _FFR_DOTTED_USERNAMES */
			if (*p == '.' || *p == '/' || *p == ':')
# endif /* _FFR_DOTTED_USERNAMES */
			{
				*p++ = '\0';
				break;
			}
		}
		if (isascii(*val) && isdigit(*val))
		{
			DefUid = atoi(val);
			setdefuser();
		}
		else
		{
			register struct passwd *pw;

			DefUid = -1;
			pw = sm_getpwnam(val);
			if (pw == NULL)
			{
				syserr("readcf: option u: unknown user %s", val);
				break;
			}
			else
			{
				DefUid = pw->pw_uid;
				DefGid = pw->pw_gid;
				DefUser = newstr(pw->pw_name);
			}
		}

# ifdef UID_MAX
		if (DefUid > UID_MAX)
		{
			syserr("readcf: option u: uid value (%ld) > UID_MAX (%ld); ignored",
				(long)DefUid, (long)UID_MAX);
			break;
		}
# endif /* UID_MAX */

		/* handle the group if it is there */
		if (*p == '\0')
			break;
		val = p;
		goto g_opt;

	  case 'V':		/* fallback MX host */
		if (val[0] != '\0')
			FallbackMX = newstr(val);
		break;

	  case 'v':		/* run in verbose mode */
		Verbose = atobool(val) ? 1 : 0;
		break;

	  case 'w':		/* if we are best MX, try host directly */
		TryNullMXList = atobool(val);
		break;

	    /* 'W' available -- was wizard password */

	  case 'x':		/* load avg at which to auto-queue msgs */
		QueueLA = atoi(val);
		break;

	  case 'X':	/* load avg at which to auto-reject connections */
		RefuseLA = atoi(val);
		break;

	  case O_DELAY_LA:	/* load avg at which to delay connections */
		DelayLA = atoi(val);
		break;

	  case 'y':		/* work recipient factor */
		WkRecipFact = atoi(val);
		break;

	  case 'Y':		/* fork jobs during queue runs */
		ForkQueueRuns = atobool(val);
		break;

	  case 'z':		/* work message class factor */
		WkClassFact = atoi(val);
		break;

	  case 'Z':		/* work time factor */
		WkTimeFact = atoi(val);
		break;


#if _FFR_QUEUE_GROUP_SORTORDER
	/* coordinate this with makequeue() */
#endif /* _FFR_QUEUE_GROUP_SORTORDER */
	  case O_QUEUESORTORD:	/* queue sorting order */
		switch (*val)
		{
		  case 'f':	/* File Name */
		  case 'F':
			QueueSortOrder = QSO_BYFILENAME;
			break;

		  case 'h':	/* Host first */
		  case 'H':
			QueueSortOrder = QSO_BYHOST;
			break;

		  case 'm':	/* Modification time */
		  case 'M':
			QueueSortOrder = QSO_BYMODTIME;
			break;

		  case 'p':	/* Priority order */
		  case 'P':
			QueueSortOrder = QSO_BYPRIORITY;
			break;

		  case 't':	/* Submission time */
		  case 'T':
			QueueSortOrder = QSO_BYTIME;
			break;

		  case 'r':	/* Random */
		  case 'R':
			QueueSortOrder = QSO_RANDOM;
			break;

#if _FFR_RHS
		  case 's':	/* Shuffled host name */
		  case 'S':
			QueueSortOrder = QSO_BYSHUFFLE;
			break;
#endif /* _FFR_RHS */

		  case 'n':	/* none */
		  case 'N':
			QueueSortOrder = QSO_NONE;
			break;

		  default:
			syserr("Invalid queue sort order \"%s\"", val);
		}
		break;

	  case O_HOSTSFILE:	/* pathname of /etc/hosts file */
		CANONIFY(val);
		HostsFile = newstr(val);
		break;

	  case O_MQA:		/* minimum queue age between deliveries */
		MinQueueAge = convtime(val, 'm');
		break;

#if _FFR_EXPDELAY
	  case O_MAX_QUEUE_AGE:
		MaxQueueAge = convtime(val, 'm');
		break;
#endif /* _FFR_EXPDELAY */

	  case O_DEFCHARSET:	/* default character set for mimefying */
		DefaultCharSet = newstr(denlstring(val, true, true));
		break;

	  case O_SSFILE:	/* service switch file */
		CANONIFY(val);
		ServiceSwitchFile = newstr(val);
		break;

	  case O_DIALDELAY:	/* delay for dial-on-demand operation */
		DialDelay = convtime(val, 's');
		break;

	  case O_NORCPTACTION:	/* what to do if no recipient */
		if (sm_strcasecmp(val, "none") == 0)
			NoRecipientAction = NRA_NO_ACTION;
		else if (sm_strcasecmp(val, "add-to") == 0)
			NoRecipientAction = NRA_ADD_TO;
		else if (sm_strcasecmp(val, "add-apparently-to") == 0)
			NoRecipientAction = NRA_ADD_APPARENTLY_TO;
		else if (sm_strcasecmp(val, "add-bcc") == 0)
			NoRecipientAction = NRA_ADD_BCC;
		else if (sm_strcasecmp(val, "add-to-undisclosed") == 0)
			NoRecipientAction = NRA_ADD_TO_UNDISCLOSED;
		else
			syserr("Invalid NoRecipientAction: %s", val);
		break;

	  case O_SAFEFILEENV:	/* chroot() environ for writing to files */
		if (*val == '\0')
			break;

		/* strip trailing slashes */
		p = val + strlen(val) - 1;
		while (p >= val && *p == '/')
			*p-- = '\0';

		if (*val == '\0')
			break;

		SafeFileEnv = newstr(val);
		break;

	  case O_MAXMSGSIZE:	/* maximum message size */
		MaxMessageSize = atol(val);
		break;

	  case O_COLONOKINADDR:	/* old style handling of colon addresses */
		ColonOkInAddr = atobool(val);
		break;

	  case O_MAXQUEUERUN:	/* max # of jobs in a single queue run */
		MaxQueueRun = atoi(val);
		break;

	  case O_MAXCHILDREN:	/* max # of children of daemon */
		MaxChildren = atoi(val);
		break;

	  case O_MAXQUEUECHILDREN: /* max # of children of daemon */
		MaxQueueChildren = atoi(val);
		break;

	  case O_MAXRUNNERSPERQUEUE: /* max # runners in a queue group */
		MaxRunnersPerQueue = atoi(val);
		break;

	  case O_NICEQUEUERUN:		/* nice queue runs */
#if !HASNICE
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: NiceQueueRun set on system that doesn't support nice()\n");
#endif /* !HASNICE */

		/* XXX do we want to check the range? > 0 ? */
		NiceQueueRun = atoi(val);
		break;

	  case O_SHMKEY:		/* shared memory key */
#if SM_CONF_SHM
		ShmKey = atol(val);
#else /* SM_CONF_SHM */
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: Option: %s requires shared memory support (-DSM_CONF_SHM)\n",
				     OPTNAME);
#endif /* SM_CONF_SHM */
		break;

	  case O_SHMKEYFILE:		/* shared memory key file */
#if SM_CONF_SHM
		SET_STRING_EXP(ShmKeyFile);
#else /* SM_CONF_SHM */
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: Option: %s requires shared memory support (-DSM_CONF_SHM)\n",
				     OPTNAME);
		break;
#endif /* SM_CONF_SHM */

#if _FFR_MAX_FORWARD_ENTRIES
	  case O_MAXFORWARD:	/* max # of forward entries */
		MaxForwardEntries = atoi(val);
		break;
#endif /* _FFR_MAX_FORWARD_ENTRIES */

	  case O_KEEPCNAMES:	/* don't expand CNAME records */
		DontExpandCnames = atobool(val);
		break;

	  case O_MUSTQUOTE:	/* must quote these characters in phrases */
		(void) sm_strlcpy(buf, "@@,;:\\()[]", sizeof(buf));
		if (strlen(val) < sizeof(buf) - 10)
			(void) sm_strlcat(buf, val, sizeof(buf));
		else
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Warning: MustQuoteChars too long, ignored.\n");
		MustQuoteChars = newstr(buf);
		break;

	  case O_SMTPGREETING:	/* SMTP greeting message (old $e macro) */
		SmtpGreeting = newstr(munchstring(val, NULL, '\0'));
		break;

	  case O_UNIXFROM:	/* UNIX From_ line (old $l macro) */
		UnixFromLine = newstr(munchstring(val, NULL, '\0'));
		break;

	  case O_OPCHARS:	/* operator characters (old $o macro) */
		if (OperatorChars != NULL)
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Warning: OperatorChars is being redefined.\n         It should only be set before ruleset definitions.\n");
		OperatorChars = newstr(munchstring(val, NULL, '\0'));
		break;

	  case O_DONTINITGRPS:	/* don't call initgroups(3) */
		DontInitGroups = atobool(val);
		break;

	  case O_SLFH:		/* make sure from fits on one line */
		SingleLineFromHeader = atobool(val);
		break;

	  case O_ABH:		/* allow HELO commands with syntax errors */
		AllowBogusHELO = atobool(val);
		break;

	  case O_CONNTHROT:	/* connection rate throttle */
		ConnRateThrottle = atoi(val);
		break;

	  case O_UGW:		/* group writable files are unsafe */
		if (!atobool(val))
		{
			setbitn(DBS_GROUPWRITABLEFORWARDFILESAFE,
				DontBlameSendmail);
			setbitn(DBS_GROUPWRITABLEINCLUDEFILESAFE,
				DontBlameSendmail);
		}
		break;

	  case O_DBLBOUNCE:	/* address to which to send double bounces */
		DoubleBounceAddr = newstr(val);
		break;

	  case O_HSDIR:		/* persistent host status directory */
		if (val[0] != '\0')
		{
			CANONIFY(val);
			HostStatDir = newstr(val);
		}
		break;

	  case O_SINGTHREAD:	/* single thread deliveries (requires hsdir) */
		SingleThreadDelivery = atobool(val);
		break;

	  case O_RUNASUSER:	/* run bulk of code as this user */
		for (p = val; *p != '\0'; p++)
		{
# if _FFR_DOTTED_USERNAMES
			if (*p == '/' || *p == ':')
# else /* _FFR_DOTTED_USERNAMES */
			if (*p == '.' || *p == '/' || *p == ':')
# endif /* _FFR_DOTTED_USERNAMES */
			{
				*p++ = '\0';
				break;
			}
		}
		if (isascii(*val) && isdigit(*val))
		{
			if (can_setuid)
				RunAsUid = atoi(val);
		}
		else
		{
			register struct passwd *pw;

			pw = sm_getpwnam(val);
			if (pw == NULL)
			{
				syserr("readcf: option RunAsUser: unknown user %s", val);
				break;
			}
			else if (can_setuid)
			{
				if (*p == '\0')
					RunAsUserName = newstr(val);
				RunAsUid = pw->pw_uid;
				RunAsGid = pw->pw_gid;
			}
			else if (EffGid == pw->pw_gid)
				RunAsGid = pw->pw_gid;
			else if (UseMSP && *p == '\0')
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "WARNING: RunAsUser for MSP ignored, check group ids (egid=%d, want=%d)\n",
						     (int) EffGid,
						     (int) pw->pw_gid);
		}
# ifdef UID_MAX
		if (RunAsUid > UID_MAX)
		{
			syserr("readcf: option RunAsUser: uid value (%ld) > UID_MAX (%ld); ignored",
				(long) RunAsUid, (long) UID_MAX);
			break;
		}
# endif /* UID_MAX */
		if (*p != '\0')
		{
			if (isascii(*p) && isdigit(*p))
			{
				gid_t runasgid;

				runasgid = (gid_t) atoi(p);
				if (can_setuid || EffGid == runasgid)
					RunAsGid = runasgid;
				else if (UseMSP)
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "WARNING: RunAsUser for MSP ignored, check group ids (egid=%d, want=%d)\n",
							     (int) EffGid,
							     (int) runasgid);
			}
			else
			{
				register struct group *gr;

				gr = getgrnam(p);
				if (gr == NULL)
					syserr("readcf: option RunAsUser: unknown group %s",
						p);
				else if (can_setuid || EffGid == gr->gr_gid)
					RunAsGid = gr->gr_gid;
				else if (UseMSP)
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "WARNING: RunAsUser for MSP ignored, check group ids (egid=%d, want=%d)\n",
							     (int) EffGid,
							     (int) gr->gr_gid);
			}
		}
		if (tTd(47, 5))
			sm_dprintf("readcf: RunAsUser = %d:%d\n",
				   (int) RunAsUid, (int) RunAsGid);
		break;

	  case O_DSN_RRT:
		RrtImpliesDsn = atobool(val);
		break;

	  case O_PIDFILE:
		PSTRSET(PidFile, val);
		break;

	  case O_DONTBLAMESENDMAIL:
		p = val;
		for (;;)
		{
			register struct dbsval *dbs;
			extern struct dbsval DontBlameSendmailValues[];

			while (isascii(*p) && (isspace(*p) || ispunct(*p)))
				p++;
			if (*p == '\0')
				break;
			val = p;
			while (isascii(*p) && isalnum(*p))
				p++;
			if (*p != '\0')
				*p++ = '\0';

			for (dbs = DontBlameSendmailValues;
			     dbs->dbs_name != NULL; dbs++)
			{
				if (sm_strcasecmp(val, dbs->dbs_name) == 0)
					break;
			}
			if (dbs->dbs_name == NULL)
				syserr("readcf: DontBlameSendmail option: %s unrecognized", val);
			else if (dbs->dbs_flag == DBS_SAFE)
				clrbitmap(DontBlameSendmail);
			else
				setbitn(dbs->dbs_flag, DontBlameSendmail);
		}
		sticky = false;
		break;

	  case O_DPI:
		if (sm_strcasecmp(val, "loopback") == 0)
			DontProbeInterfaces = DPI_SKIPLOOPBACK;
		else if (atobool(val))
			DontProbeInterfaces = DPI_PROBENONE;
		else
			DontProbeInterfaces = DPI_PROBEALL;
		break;

	  case O_MAXRCPT:
		MaxRcptPerMsg = atoi(val);
		break;

	  case O_RCPTTHROT:
		BadRcptThrottle = atoi(val);
		break;

#if _FFR_RCPTTHROTDELAY
	  case O_RCPTTHROTDELAY:
		BadRcptThrottleDelay = atoi(val);
		break;
#endif /* _FFR_RCPTTHROTDELAY */

	  case O_DEADLETTER:
		CANONIFY(val);
		PSTRSET(DeadLetterDrop, val);
		break;

#if _FFR_DONTLOCKFILESFORREAD_OPTION
	  case O_DONTLOCK:
		DontLockReadFiles = atobool(val);
		break;
#endif /* _FFR_DONTLOCKFILESFORREAD_OPTION */

	  case O_MAXALIASRCSN:
		MaxAliasRecursion = atoi(val);
		break;

	  case O_CNCTONLYTO:
		/* XXX should probably use gethostbyname */
#if NETINET || NETINET6
		ConnectOnlyTo.sa.sa_family = AF_UNSPEC;
# if NETINET6
		if (anynet_pton(AF_INET6, val,
				&ConnectOnlyTo.sin6.sin6_addr) == 1)
			ConnectOnlyTo.sa.sa_family = AF_INET6;
		else
# endif /* NETINET6 */
# if NETINET
		{
			ConnectOnlyTo.sin.sin_addr.s_addr = inet_addr(val);
			if (ConnectOnlyTo.sin.sin_addr.s_addr != INADDR_NONE)
				ConnectOnlyTo.sa.sa_family = AF_INET;
		}

# endif /* NETINET */
		if (ConnectOnlyTo.sa.sa_family == AF_UNSPEC)
		{
			syserr("readcf: option ConnectOnlyTo: invalid IP address %s",
			       val);
			break;
		}
#endif /* NETINET || NETINET6 */
		break;

	  case O_TRUSTUSER:
# if !HASFCHOWN && !defined(_FFR_DROP_TRUSTUSER_WARNING)
		if (!UseMSP)
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "readcf: option TrustedUser may cause problems on systems\n        which do not support fchown() if UseMSP is not set.\n");
# endif /* !HASFCHOWN && !defined(_FFR_DROP_TRUSTUSER_WARNING) */
		if (isascii(*val) && isdigit(*val))
			TrustedUid = atoi(val);
		else
		{
			register struct passwd *pw;

			TrustedUid = 0;
			pw = sm_getpwnam(val);
			if (pw == NULL)
			{
				syserr("readcf: option TrustedUser: unknown user %s", val);
				break;
			}
			else
				TrustedUid = pw->pw_uid;
		}

# ifdef UID_MAX
		if (TrustedUid > UID_MAX)
		{
			syserr("readcf: option TrustedUser: uid value (%ld) > UID_MAX (%ld)",
				(long) TrustedUid, (long) UID_MAX);
			TrustedUid = 0;
		}
# endif /* UID_MAX */
		break;

	  case O_MAXMIMEHDRLEN:
		p = strchr(val, '/');
		if (p != NULL)
			*p++ = '\0';
		MaxMimeHeaderLength = atoi(val);
		if (p != NULL && *p != '\0')
			MaxMimeFieldLength = atoi(p);
		else
			MaxMimeFieldLength = MaxMimeHeaderLength / 2;

		if (MaxMimeHeaderLength <= 0)
			MaxMimeHeaderLength = 0;
		else if (MaxMimeHeaderLength < 128)
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Warning: MaxMimeHeaderLength: header length limit set lower than 128\n");

		if (MaxMimeFieldLength <= 0)
			MaxMimeFieldLength = 0;
		else if (MaxMimeFieldLength < 40)
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Warning: MaxMimeHeaderLength: field length limit set lower than 40\n");

		/*
		**  Headers field values now include leading space, so let's
		**  adjust the values to be "backward compatible".
		*/

		if (MaxMimeHeaderLength > 0)
			MaxMimeHeaderLength++;
		if (MaxMimeFieldLength > 0)
			MaxMimeFieldLength++;
		break;

	  case O_CONTROLSOCKET:
		PSTRSET(ControlSocketName, val);
		break;

	  case O_MAXHDRSLEN:
		MaxHeadersLength = atoi(val);

		if (MaxHeadersLength > 0 &&
		    MaxHeadersLength < (MAXHDRSLEN / 2))
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Warning: MaxHeadersLength: headers length limit set lower than %d\n",
					     (MAXHDRSLEN / 2));
		break;

	  case O_PROCTITLEPREFIX:
		PSTRSET(ProcTitlePrefix, val);
		break;

#if SASL
	  case O_SASLINFO:
# if _FFR_ALLOW_SASLINFO
		/*
		**  Allow users to select their own authinfo file
		**  under certain circumstances, otherwise just ignore
		**  the option.  If the option isn't ignored, several
		**  commands don't work very well, e.g., mailq.
		**  However, this is not a "perfect" solution.
		**  If mail is queued, the authentication info
		**  will not be used in subsequent delivery attempts.
		**  If we really want to support this, then it has
		**  to be stored in the queue file.
		*/
		if (!bitset(SUBMIT_MSA, SubmitMode) && RealUid != 0 &&
		    RunAsUid != RealUid)
			break;
# endif /* _FFR_ALLOW_SASLINFO */
		PSTRSET(SASLInfo, val);
		break;

	  case O_SASLMECH:
		if (AuthMechanisms != NULL)
			sm_free(AuthMechanisms); /* XXX */
		if (*val != '\0')
			AuthMechanisms = newstr(val);
		else
			AuthMechanisms = NULL;
		break;

	  case O_SASLREALM:
		if (AuthRealm != NULL)
			sm_free(AuthRealm);
		if (*val != '\0')
			AuthRealm = newstr(val);
		else
			AuthRealm = NULL;
		break;

	  case O_SASLOPTS:
		while (val != NULL && *val != '\0')
		{
			switch (*val)
			{
			  case 'A':
				SASLOpts |= SASL_AUTH_AUTH;
				break;

			  case 'a':
				SASLOpts |= SASL_SEC_NOACTIVE;
				break;

			  case 'c':
				SASLOpts |= SASL_SEC_PASS_CREDENTIALS;
				break;

			  case 'd':
				SASLOpts |= SASL_SEC_NODICTIONARY;
				break;

			  case 'f':
				SASLOpts |= SASL_SEC_FORWARD_SECRECY;
				break;

#  if SASL >= 20101
			  case 'm':
				SASLOpts |= SASL_SEC_MUTUAL_AUTH;
				break;
#  endif /* SASL >= 20101 */

			  case 'p':
				SASLOpts |= SASL_SEC_NOPLAINTEXT;
				break;

			  case 'y':
				SASLOpts |= SASL_SEC_NOANONYMOUS;
				break;

			  case ' ':	/* ignore */
			  case '\t':	/* ignore */
			  case ',':	/* ignore */
				break;

			  default:
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Warning: Option: %s unknown parameter '%c'\n",
						     OPTNAME,
						     (isascii(*val) &&
							isprint(*val))
							? *val : '?');
				break;
			}
			++val;
			val = strpbrk(val, ", \t");
			if (val != NULL)
				++val;
		}
		break;

	  case O_SASLBITS:
		MaxSLBits = atoi(val);
		break;

#else /* SASL */
	  case O_SASLINFO:
	  case O_SASLMECH:
	  case O_SASLREALM:
	  case O_SASLOPTS:
	  case O_SASLBITS:
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: Option: %s requires SASL support (-DSASL)\n",
				     OPTNAME);
		break;
#endif /* SASL */

#if STARTTLS
	  case O_SRVCERTFILE:
		SET_STRING_EXP(SrvCertFile);
	  case O_SRVKEYFILE:
		SET_STRING_EXP(SrvKeyFile);
	  case O_CLTCERTFILE:
		SET_STRING_EXP(CltCertFile);
	  case O_CLTKEYFILE:
		SET_STRING_EXP(CltKeyFile);
	  case O_CACERTFILE:
		SET_STRING_EXP(CACertFile);
	  case O_CACERTPATH:
		SET_STRING_EXP(CACertPath);
	  case O_DHPARAMS:
		SET_STRING_EXP(DHParams);
# if _FFR_TLS_1
	  case O_DHPARAMS5:
		SET_STRING_EXP(DHParams5);
	  case O_CIPHERLIST:
		SET_STRING_EXP(CipherList);
	  case O_SRV_SSL_OPTIONS:
		pssloptions = &Srv_SSL_Options;
	  case O_CLT_SSL_OPTIONS:
		if (pssloptions == NULL)
			pssloptions = &Clt_SSL_Options;
		for (p = val; *p != 0; )
		{
			bool clearmode;
			char *q;
			struct ssl_options *sslopts;

			while (*p == ' ')
				p++;
			if (*p == '\0')
				break;
			clearmode = false;
			if (*p == '-' || *p == '+')
				clearmode = *p++ == '-';
			q = p;
			while (*p != '\0' && !(isascii(*p) && isspace(*p)))
				p++;
			if (*p != '\0')
				*p++ = '\0';
			for (sslopts = SSL_Option;
			     sslopts->sslopt_name != NULL; sslopts++)
			{
				if (sm_strcasecmp(q, sslopts->sslopt_name) == 0)
					break;
			}
			if (sslopts->sslopt_name == NULL)
			{
				errno = 0;
				syserr("readcf: %s option value %s unrecognized",
					o->o_name, q);
			}
			else if (clearmode)
				*pssloptions &= ~sslopts->sslopt_bits;
			else
				*pssloptions |= sslopts->sslopt_bits;
		}
		pssloptions = NULL;
		break;

# endif /* _FFR_TLS_1 */

	  case O_CRLFILE:
# if OPENSSL_VERSION_NUMBER > 0x00907000L
		SET_STRING_EXP(CRLFile);
# else /* OPENSSL_VERSION_NUMBER > 0x00907000L */
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: Option: %s requires at least OpenSSL 0.9.7\n",
				     OPTNAME);
		break;
# endif /* OPENSSL_VERSION_NUMBER > 0x00907000L */

# if _FFR_CRLPATH
	  case O_CRLPATH:
#  if OPENSSL_VERSION_NUMBER > 0x00907000L
		SET_STRING_EXP(CRLPath);
#  else /* OPENSSL_VERSION_NUMBER > 0x00907000L */
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: Option: %s requires at least OpenSSL 0.9.7\n",
				     OPTNAME);
		break;
#  endif /* OPENSSL_VERSION_NUMBER > 0x00907000L */
# endif /* _FFR_CRLPATH */

	/*
	**  XXX How about options per daemon/client instead of globally?
	**  This doesn't work well for some options, e.g., no server cert,
	**  but fine for others.
	**
	**  XXX Some people may want different certs per server.
	**
	**  See also srvfeatures()
	*/

	  case O_TLS_SRV_OPTS:
		while (val != NULL && *val != '\0')
		{
			switch (*val)
			{
			  case 'V':
				TLS_Srv_Opts |= TLS_I_NO_VRFY;
				break;
# if _FFR_TLS_1
			/*
			**  Server without a cert? That works only if
			**  AnonDH is enabled as cipher, which is not in the
			**  default list. Hence the CipherList option must
			**  be available. Moreover: which clients support this
			**  besides sendmail with this setting?
			*/

			  case 'C':
				TLS_Srv_Opts &= ~TLS_I_SRV_CERT;
				break;
# endif /* _FFR_TLS_1 */
			  case ' ':	/* ignore */
			  case '\t':	/* ignore */
			  case ',':	/* ignore */
				break;
			  default:
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Warning: Option: %s unknown parameter '%c'\n",
						     OPTNAME,
						     (isascii(*val) &&
							isprint(*val))
							? *val : '?');
				break;
			}
			++val;
			val = strpbrk(val, ", \t");
			if (val != NULL)
				++val;
		}
		break;

	  case O_RANDFILE:
		PSTRSET(RandFile, val);
		break;

#else /* STARTTLS */
	  case O_SRVCERTFILE:
	  case O_SRVKEYFILE:
	  case O_CLTCERTFILE:
	  case O_CLTKEYFILE:
	  case O_CACERTFILE:
	  case O_CACERTPATH:
	  case O_DHPARAMS:
# if _FFR_TLS_1
	  case O_DHPARAMS5:
	  case O_CIPHERLIST:
# endif /* _FFR_TLS_1 */
	  case O_CRLFILE:
# if _FFR_CRLPATH
	  case O_CRLPATH:
# endif /* _FFR_CRLPATH */
	  case O_RANDFILE:
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: Option: %s requires TLS support\n",
				     OPTNAME);
		break;

#endif /* STARTTLS */
#if STARTTLS && _FFR_FIPSMODE
	  case O_FIPSMODE:
		FipsMode = atobool(val);
		break;
#endif /* STARTTLS && _FFR_FIPSMODE  */

	  case O_CLIENTPORT:
		setclientoptions(val);
		break;

	  case O_DF_BUFSIZE:
		DataFileBufferSize = atoi(val);
		break;

	  case O_XF_BUFSIZE:
		XscriptFileBufferSize = atoi(val);
		break;

	  case O_LDAPDEFAULTSPEC:
#if LDAPMAP
		ldapmap_set_defaults(val);
#else /* LDAPMAP */
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: Option: %s requires LDAP support (-DLDAPMAP)\n",
				     OPTNAME);
#endif /* LDAPMAP */
		break;

	  case O_INPUTMILTER:
#if MILTER
		InputFilterList = newstr(val);
#else /* MILTER */
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: Option: %s requires Milter support (-DMILTER)\n",
				     OPTNAME);
#endif /* MILTER */
		break;

	  case O_MILTER:
#if MILTER
		milter_set_option(subopt, val, sticky);
#else /* MILTER */
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: Option: %s requires Milter support (-DMILTER)\n",
				     OPTNAME);
#endif /* MILTER */
		break;

	  case O_QUEUE_FILE_MODE:	/* queue file mode */
		QueueFileMode = atooct(val) & 0777;
		break;

	  case O_DLVR_MIN:	/* deliver by minimum time */
		DeliverByMin = convtime(val, 's');
		break;

	  /* modifiers {daemon_flags} for direct submissions */
	  case O_DIRECTSUBMODIFIERS:
		{
			BITMAP256 m;	/* ignored */
			extern ENVELOPE BlankEnvelope;

			macdefine(&BlankEnvelope.e_macro, A_PERM,
				  macid("{daemon_flags}"),
				  getmodifiers(val, m));
		}
		break;

	  case O_FASTSPLIT:
		FastSplit = atoi(val);
		break;

	  case O_MBDB:
		Mbdb = newstr(val);
		break;

	  case O_MSQ:
		UseMSP = atobool(val);
		break;

	  case O_SOFTBOUNCE:
		SoftBounce = atobool(val);
		break;

	  case O_REJECTLOGINTERVAL:	/* time btwn log msgs while refusing */
		RejectLogInterval = convtime(val, 'h');
		break;

	  case O_REQUIRES_DIR_FSYNC:
#if REQUIRES_DIR_FSYNC
		RequiresDirfsync = atobool(val);
#else /* REQUIRES_DIR_FSYNC */
		/* silently ignored... required for cf file option */
#endif /* REQUIRES_DIR_FSYNC */
		break;

	  case O_CONNECTION_RATE_WINDOW_SIZE:
		ConnectionRateWindowSize = convtime(val, 's');
		break;

	  case O_FALLBACKSMARTHOST:	/* fallback smart host */
		if (val[0] != '\0')
			FallbackSmartHost = newstr(val);
		break;

	  case O_HELONAME:
		HeloName = newstr(val);
		break;

#if _FFR_MEMSTAT
	  case O_REFUSELOWMEM:
		RefuseLowMem = atoi(val);
		break;
	  case O_QUEUELOWMEM:
		QueueLowMem = atoi(val);
		break;
	  case O_MEMRESOURCE:
		MemoryResource = newstr(val);
		break;
#endif /* _FFR_MEMSTAT */

	  case O_MAXNOOPCOMMANDS:
		MaxNOOPCommands = atoi(val);
		break;

#if _FFR_MSG_ACCEPT
	  case O_MSG_ACCEPT:
		MessageAccept = newstr(val);
		break;
#endif /* _FFR_MSG_ACCEPT */

#if _FFR_QUEUE_RUN_PARANOIA
	  case O_CHK_Q_RUNNERS:
		CheckQueueRunners = atoi(val);
		break;
#endif /* _FFR_QUEUE_RUN_PARANOIA */

#if _FFR_EIGHT_BIT_ADDR_OK
	  case O_EIGHT_BIT_ADDR_OK:
		EightBitAddrOK = atobool(val);
		break;
#endif /* _FFR_EIGHT_BIT_ADDR_OK */

#if _FFR_ADDR_TYPE_MODES
	  case O_ADDR_TYPE_MODES:
		AddrTypeModes = atobool(val);
		break;
#endif /* _FFR_ADDR_TYPE_MODES */

#if _FFR_BADRCPT_SHUTDOWN
	  case O_RCPTSHUTD:
		BadRcptShutdown = atoi(val);
		break;

	  case O_RCPTSHUTDG:
		BadRcptShutdownGood = atoi(val);
		break;
#endif /* _FFR_BADRCPT_SHUTDOWN */

#if _FFR_REJECT_NUL_BYTE
	  case O_REJECTNUL:
		RejectNUL = atobool(val);
		break;
#endif /* _FFR_REJECT_NUL_BYTE */

	  default:
		if (tTd(37, 1))
		{
			if (isascii(opt) && isprint(opt))
				sm_dprintf("Warning: option %c unknown\n", opt);
			else
				sm_dprintf("Warning: option 0x%x unknown\n", opt);
		}
		break;
	}

	/*
	**  Options with suboptions are responsible for taking care
	**  of sticky-ness (e.g., that a command line setting is kept
	**  when reading in the sendmail.cf file).  This has to be done
	**  when the suboptions are parsed since each suboption must be
	**  sticky, not the root option.
	*/

	if (sticky && !bitset(OI_SUBOPT, o->o_flags))
		setbitn(opt, StickyOpt);
}
/*
**  SETCLASS -- set a string into a class
**
**	Parameters:
**		class -- the class to put the string in.
**		str -- the string to enter
**
**	Returns:
**		none.
**
**	Side Effects:
**		puts the word into the symbol table.
*/

void
setclass(class, str)
	int class;
	char *str;
{
	register STAB *s;

	if ((str[0] & 0377) == MATCHCLASS)
	{
		int mid;

		str++;
		mid = macid(str);
		if (mid == 0)
			return;

		if (tTd(37, 8))
			sm_dprintf("setclass(%s, $=%s)\n",
				   macname(class), macname(mid));
		copy_class(mid, class);
	}
	else
	{
		if (tTd(37, 8))
			sm_dprintf("setclass(%s, %s)\n", macname(class), str);

		s = stab(str, ST_CLASS, ST_ENTER);
		setbitn(bitidx(class), s->s_class);
	}
}
/*
**  MAKEMAPENTRY -- create a map entry
**
**	Parameters:
**		line -- the config file line
**
**	Returns:
**		A pointer to the map that has been created.
**		NULL if there was a syntax error.
**
**	Side Effects:
**		Enters the map into the dictionary.
*/

MAP *
makemapentry(line)
	char *line;
{
	register char *p;
	char *mapname;
	char *classname;
	register STAB *s;
	STAB *class;

	for (p = line; isascii(*p) && isspace(*p); p++)
		continue;
	if (!(isascii(*p) && isalnum(*p)))
	{
		syserr("readcf: config K line: no map name");
		return NULL;
	}

	mapname = p;
	while ((isascii(*++p) && isalnum(*p)) || *p == '_' || *p == '.')
		continue;
	if (*p != '\0')
		*p++ = '\0';
	while (isascii(*p) && isspace(*p))
		p++;
	if (!(isascii(*p) && isalnum(*p)))
	{
		syserr("readcf: config K line, map %s: no map class", mapname);
		return NULL;
	}
	classname = p;
	while (isascii(*++p) && isalnum(*p))
		continue;
	if (*p != '\0')
		*p++ = '\0';
	while (isascii(*p) && isspace(*p))
		p++;

	/* look up the class */
	class = stab(classname, ST_MAPCLASS, ST_FIND);
	if (class == NULL)
	{
		syserr("readcf: map %s: class %s not available", mapname,
			classname);
		return NULL;
	}

	/* enter the map */
	s = stab(mapname, ST_MAP, ST_ENTER);
	s->s_map.map_class = &class->s_mapclass;
	s->s_map.map_mname = newstr(mapname);

	if (class->s_mapclass.map_parse(&s->s_map, p))
		s->s_map.map_mflags |= MF_VALID;

	if (tTd(37, 5))
	{
		sm_dprintf("map %s, class %s, flags %lx, file %s,\n",
			   s->s_map.map_mname, s->s_map.map_class->map_cname,
			   s->s_map.map_mflags, s->s_map.map_file);
		sm_dprintf("\tapp %s, domain %s, rebuild %s\n",
			   s->s_map.map_app, s->s_map.map_domain,
			   s->s_map.map_rebuild);
	}
	return &s->s_map;
}
/*
**  STRTORWSET -- convert string to rewriting set number
**
**	Parameters:
**		p -- the pointer to the string to decode.
**		endp -- if set, store the trailing delimiter here.
**		stabmode -- ST_ENTER to create this entry, ST_FIND if
**			it must already exist.
**
**	Returns:
**		The appropriate ruleset number.
**		-1 if it is not valid (error already printed)
*/

int
strtorwset(p, endp, stabmode)
	char *p;
	char **endp;
	int stabmode;
{
	int ruleset;
	static int nextruleset = MAXRWSETS;

	while (isascii(*p) && isspace(*p))
		p++;
	if (!isascii(*p))
	{
		syserr("invalid ruleset name: \"%.20s\"", p);
		return -1;
	}
	if (isdigit(*p))
	{
		ruleset = strtol(p, endp, 10);
		if (ruleset >= MAXRWSETS / 2 || ruleset < 0)
		{
			syserr("bad ruleset %d (%d max)",
				ruleset, MAXRWSETS / 2);
			ruleset = -1;
		}
	}
	else
	{
		STAB *s;
		char delim;
		char *q = NULL;

		q = p;
		while (*p != '\0' && isascii(*p) && (isalnum(*p) || *p == '_'))
			p++;
		if (q == p || !(isascii(*q) && isalpha(*q)))
		{
			/* no valid characters */
			syserr("invalid ruleset name: \"%.20s\"", q);
			return -1;
		}
		while (isascii(*p) && isspace(*p))
			*p++ = '\0';
		delim = *p;
		if (delim != '\0')
			*p = '\0';
		s = stab(q, ST_RULESET, stabmode);
		if (delim != '\0')
			*p = delim;

		if (s == NULL)
			return -1;

		if (stabmode == ST_ENTER && delim == '=')
		{
			while (isascii(*++p) && isspace(*p))
				continue;
			if (!(isascii(*p) && isdigit(*p)))
			{
				syserr("bad ruleset definition \"%s\" (number required after `=')", q);
				ruleset = -1;
			}
			else
			{
				ruleset = strtol(p, endp, 10);
				if (ruleset >= MAXRWSETS / 2 || ruleset < 0)
				{
					syserr("bad ruleset number %d in \"%s\" (%d max)",
						ruleset, q, MAXRWSETS / 2);
					ruleset = -1;
				}
			}
		}
		else
		{
			if (endp != NULL)
				*endp = p;
			if (s->s_ruleset >= 0)
				ruleset = s->s_ruleset;
			else if ((ruleset = --nextruleset) < MAXRWSETS / 2)
			{
				syserr("%s: too many named rulesets (%d max)",
					q, MAXRWSETS / 2);
				ruleset = -1;
			}
		}
		if (s->s_ruleset >= 0 &&
		    ruleset >= 0 &&
		    ruleset != s->s_ruleset)
		{
			syserr("%s: ruleset changed value (old %d, new %d)",
				q, s->s_ruleset, ruleset);
			ruleset = s->s_ruleset;
		}
		else if (ruleset >= 0)
		{
			s->s_ruleset = ruleset;
		}
		if (stabmode == ST_ENTER && ruleset >= 0)
		{
			char *h = NULL;

			if (RuleSetNames[ruleset] != NULL)
				sm_free(RuleSetNames[ruleset]); /* XXX */
			if (delim != '\0' && (h = strchr(q, delim)) != NULL)
				*h = '\0';
			RuleSetNames[ruleset] = newstr(q);
			if (delim == '/' && h != NULL)
				*h = delim;	/* put back delim */
		}
	}
	return ruleset;
}
/*
**  SETTIMEOUT -- set an individual timeout
**
**	Parameters:
**		name -- the name of the timeout.
**		val -- the value of the timeout.
**		sticky -- if set, don't let other setoptions override
**			this value.
**
**	Returns:
**		none.
*/

/* set if Timeout sub-option is stuck */
static BITMAP256	StickyTimeoutOpt;

static struct timeoutinfo
{
	char		*to_name;	/* long name of timeout */
	unsigned char	to_code;	/* code for option */
} TimeOutTab[] =
{
#define TO_INITIAL			0x01
	{ "initial",			TO_INITIAL			},
#define TO_MAIL				0x02
	{ "mail",			TO_MAIL				},
#define TO_RCPT				0x03
	{ "rcpt",			TO_RCPT				},
#define TO_DATAINIT			0x04
	{ "datainit",			TO_DATAINIT			},
#define TO_DATABLOCK			0x05
	{ "datablock",			TO_DATABLOCK			},
#define TO_DATAFINAL			0x06
	{ "datafinal",			TO_DATAFINAL			},
#define TO_COMMAND			0x07
	{ "command",			TO_COMMAND			},
#define TO_RSET				0x08
	{ "rset",			TO_RSET				},
#define TO_HELO				0x09
	{ "helo",			TO_HELO				},
#define TO_QUIT				0x0A
	{ "quit",			TO_QUIT				},
#define TO_MISC				0x0B
	{ "misc",			TO_MISC				},
#define TO_IDENT			0x0C
	{ "ident",			TO_IDENT			},
#define TO_FILEOPEN			0x0D
	{ "fileopen",			TO_FILEOPEN			},
#define TO_CONNECT			0x0E
	{ "connect",			TO_CONNECT			},
#define TO_ICONNECT			0x0F
	{ "iconnect",			TO_ICONNECT			},
#define TO_QUEUEWARN			0x10
	{ "queuewarn",			TO_QUEUEWARN			},
	{ "queuewarn.*",		TO_QUEUEWARN			},
#define TO_QUEUEWARN_NORMAL		0x11
	{ "queuewarn.normal",		TO_QUEUEWARN_NORMAL		},
#define TO_QUEUEWARN_URGENT		0x12
	{ "queuewarn.urgent",		TO_QUEUEWARN_URGENT		},
#define TO_QUEUEWARN_NON_URGENT		0x13
	{ "queuewarn.non-urgent",	TO_QUEUEWARN_NON_URGENT		},
#define TO_QUEUERETURN			0x14
	{ "queuereturn",		TO_QUEUERETURN			},
	{ "queuereturn.*",		TO_QUEUERETURN			},
#define TO_QUEUERETURN_NORMAL		0x15
	{ "queuereturn.normal",		TO_QUEUERETURN_NORMAL		},
#define TO_QUEUERETURN_URGENT		0x16
	{ "queuereturn.urgent",		TO_QUEUERETURN_URGENT		},
#define TO_QUEUERETURN_NON_URGENT	0x17
	{ "queuereturn.non-urgent",	TO_QUEUERETURN_NON_URGENT	},
#define TO_HOSTSTATUS			0x18
	{ "hoststatus",			TO_HOSTSTATUS			},
#define TO_RESOLVER_RETRANS		0x19
	{ "resolver.retrans",		TO_RESOLVER_RETRANS		},
#define TO_RESOLVER_RETRANS_NORMAL	0x1A
	{ "resolver.retrans.normal",	TO_RESOLVER_RETRANS_NORMAL	},
#define TO_RESOLVER_RETRANS_FIRST	0x1B
	{ "resolver.retrans.first",	TO_RESOLVER_RETRANS_FIRST	},
#define TO_RESOLVER_RETRY		0x1C
	{ "resolver.retry",		TO_RESOLVER_RETRY		},
#define TO_RESOLVER_RETRY_NORMAL	0x1D
	{ "resolver.retry.normal",	TO_RESOLVER_RETRY_NORMAL	},
#define TO_RESOLVER_RETRY_FIRST		0x1E
	{ "resolver.retry.first",	TO_RESOLVER_RETRY_FIRST		},
#define TO_CONTROL			0x1F
	{ "control",			TO_CONTROL			},
#define TO_LHLO				0x20
	{ "lhlo",			TO_LHLO				},
#define TO_AUTH				0x21
	{ "auth",			TO_AUTH				},
#define TO_STARTTLS			0x22
	{ "starttls",			TO_STARTTLS			},
#define TO_ACONNECT			0x23
	{ "aconnect",			TO_ACONNECT			},
#define TO_QUEUEWARN_DSN		0x24
	{ "queuewarn.dsn",		TO_QUEUEWARN_DSN		},
#define TO_QUEUERETURN_DSN		0x25
	{ "queuereturn.dsn",		TO_QUEUERETURN_DSN		},
	{ NULL,				0				},
};


static void
settimeout(name, val, sticky)
	char *name;
	char *val;
	bool sticky;
{
	register struct timeoutinfo *to;
	int i, addopts;
	time_t toval;

	if (tTd(37, 2))
		sm_dprintf("settimeout(%s = %s)", name, val);

	for (to = TimeOutTab; to->to_name != NULL; to++)
	{
		if (sm_strcasecmp(to->to_name, name) == 0)
			break;
	}

	if (to->to_name == NULL)
	{
		errno = 0; /* avoid bogus error text */
		syserr("settimeout: invalid timeout %s", name);
		return;
	}

	/*
	**  See if this option is preset for us.
	*/

	if (!sticky && bitnset(to->to_code, StickyTimeoutOpt))
	{
		if (tTd(37, 2))
			sm_dprintf(" (ignored)\n");
		return;
	}

	if (tTd(37, 2))
		sm_dprintf("\n");

	toval = convtime(val, 'm');
	addopts = 0;

	switch (to->to_code)
	{
	  case TO_INITIAL:
		TimeOuts.to_initial = toval;
		break;

	  case TO_MAIL:
		TimeOuts.to_mail = toval;
		break;

	  case TO_RCPT:
		TimeOuts.to_rcpt = toval;
		break;

	  case TO_DATAINIT:
		TimeOuts.to_datainit = toval;
		break;

	  case TO_DATABLOCK:
		TimeOuts.to_datablock = toval;
		break;

	  case TO_DATAFINAL:
		TimeOuts.to_datafinal = toval;
		break;

	  case TO_COMMAND:
		TimeOuts.to_nextcommand = toval;
		break;

	  case TO_RSET:
		TimeOuts.to_rset = toval;
		break;

	  case TO_HELO:
		TimeOuts.to_helo = toval;
		break;

	  case TO_QUIT:
		TimeOuts.to_quit = toval;
		break;

	  case TO_MISC:
		TimeOuts.to_miscshort = toval;
		break;

	  case TO_IDENT:
		TimeOuts.to_ident = toval;
		break;

	  case TO_FILEOPEN:
		TimeOuts.to_fileopen = toval;
		break;

	  case TO_CONNECT:
		TimeOuts.to_connect = toval;
		break;

	  case TO_ICONNECT:
		TimeOuts.to_iconnect = toval;
		break;

	  case TO_ACONNECT:
		TimeOuts.to_aconnect = toval;
		break;

	  case TO_QUEUEWARN:
		toval = convtime(val, 'h');
		TimeOuts.to_q_warning[TOC_NORMAL] = toval;
		TimeOuts.to_q_warning[TOC_URGENT] = toval;
		TimeOuts.to_q_warning[TOC_NONURGENT] = toval;
		TimeOuts.to_q_warning[TOC_DSN] = toval;
		addopts = 2;
		break;

	  case TO_QUEUEWARN_NORMAL:
		toval = convtime(val, 'h');
		TimeOuts.to_q_warning[TOC_NORMAL] = toval;
		break;

	  case TO_QUEUEWARN_URGENT:
		toval = convtime(val, 'h');
		TimeOuts.to_q_warning[TOC_URGENT] = toval;
		break;

	  case TO_QUEUEWARN_NON_URGENT:
		toval = convtime(val, 'h');
		TimeOuts.to_q_warning[TOC_NONURGENT] = toval;
		break;

	  case TO_QUEUEWARN_DSN:
		toval = convtime(val, 'h');
		TimeOuts.to_q_warning[TOC_DSN] = toval;
		break;

	  case TO_QUEUERETURN:
		toval = convtime(val, 'd');
		TimeOuts.to_q_return[TOC_NORMAL] = toval;
		TimeOuts.to_q_return[TOC_URGENT] = toval;
		TimeOuts.to_q_return[TOC_NONURGENT] = toval;
		TimeOuts.to_q_return[TOC_DSN] = toval;
		addopts = 2;
		break;

	  case TO_QUEUERETURN_NORMAL:
		toval = convtime(val, 'd');
		TimeOuts.to_q_return[TOC_NORMAL] = toval;
		break;

	  case TO_QUEUERETURN_URGENT:
		toval = convtime(val, 'd');
		TimeOuts.to_q_return[TOC_URGENT] = toval;
		break;

	  case TO_QUEUERETURN_NON_URGENT:
		toval = convtime(val, 'd');
		TimeOuts.to_q_return[TOC_NONURGENT] = toval;
		break;

	  case TO_QUEUERETURN_DSN:
		toval = convtime(val, 'd');
		TimeOuts.to_q_return[TOC_DSN] = toval;
		break;

	  case TO_HOSTSTATUS:
		MciInfoTimeout = toval;
		break;

	  case TO_RESOLVER_RETRANS:
		toval = convtime(val, 's');
		TimeOuts.res_retrans[RES_TO_DEFAULT] = toval;
		TimeOuts.res_retrans[RES_TO_FIRST] = toval;
		TimeOuts.res_retrans[RES_TO_NORMAL] = toval;
		addopts = 2;
		break;

	  case TO_RESOLVER_RETRY:
		i = atoi(val);
		TimeOuts.res_retry[RES_TO_DEFAULT] = i;
		TimeOuts.res_retry[RES_TO_FIRST] = i;
		TimeOuts.res_retry[RES_TO_NORMAL] = i;
		addopts = 2;
		break;

	  case TO_RESOLVER_RETRANS_NORMAL:
		TimeOuts.res_retrans[RES_TO_NORMAL] = convtime(val, 's');
		break;

	  case TO_RESOLVER_RETRY_NORMAL:
		TimeOuts.res_retry[RES_TO_NORMAL] = atoi(val);
		break;

	  case TO_RESOLVER_RETRANS_FIRST:
		TimeOuts.res_retrans[RES_TO_FIRST] = convtime(val, 's');
		break;

	  case TO_RESOLVER_RETRY_FIRST:
		TimeOuts.res_retry[RES_TO_FIRST] = atoi(val);
		break;

	  case TO_CONTROL:
		TimeOuts.to_control = toval;
		break;

	  case TO_LHLO:
		TimeOuts.to_lhlo = toval;
		break;

#if SASL
	  case TO_AUTH:
		TimeOuts.to_auth = toval;
		break;
#endif /* SASL */

#if STARTTLS
	  case TO_STARTTLS:
		TimeOuts.to_starttls = toval;
		break;
#endif /* STARTTLS */

	  default:
		syserr("settimeout: invalid timeout %s", name);
		break;
	}

	if (sticky)
	{
		for (i = 0; i <= addopts; i++)
			setbitn(to->to_code + i, StickyTimeoutOpt);
	}
}
/*
**  INITTIMEOUTS -- parse and set timeout values
**
**	Parameters:
**		val -- a pointer to the values.  If NULL, do initial
**			settings.
**		sticky -- if set, don't let other setoptions override
**			this suboption value.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Initializes the TimeOuts structure
*/

void
inittimeouts(val, sticky)
	register char *val;
	bool sticky;
{
	register char *p;

	if (tTd(37, 2))
		sm_dprintf("inittimeouts(%s)\n", val == NULL ? "<NULL>" : val);
	if (val == NULL)
	{
		TimeOuts.to_connect = (time_t) 0 SECONDS;
		TimeOuts.to_aconnect = (time_t) 0 SECONDS;
		TimeOuts.to_iconnect = (time_t) 0 SECONDS;
		TimeOuts.to_initial = (time_t) 5 MINUTES;
		TimeOuts.to_helo = (time_t) 5 MINUTES;
		TimeOuts.to_mail = (time_t) 10 MINUTES;
		TimeOuts.to_rcpt = (time_t) 1 HOUR;
		TimeOuts.to_datainit = (time_t) 5 MINUTES;
		TimeOuts.to_datablock = (time_t) 1 HOUR;
		TimeOuts.to_datafinal = (time_t) 1 HOUR;
		TimeOuts.to_rset = (time_t) 5 MINUTES;
		TimeOuts.to_quit = (time_t) 2 MINUTES;
		TimeOuts.to_nextcommand = (time_t) 1 HOUR;
		TimeOuts.to_miscshort = (time_t) 2 MINUTES;
#if IDENTPROTO
		TimeOuts.to_ident = (time_t) 5 SECONDS;
#else /* IDENTPROTO */
		TimeOuts.to_ident = (time_t) 0 SECONDS;
#endif /* IDENTPROTO */
		TimeOuts.to_fileopen = (time_t) 60 SECONDS;
		TimeOuts.to_control = (time_t) 2 MINUTES;
		TimeOuts.to_lhlo = (time_t) 2 MINUTES;
#if SASL
		TimeOuts.to_auth = (time_t) 10 MINUTES;
#endif /* SASL */
#if STARTTLS
		TimeOuts.to_starttls = (time_t) 1 HOUR;
#endif /* STARTTLS */
		if (tTd(37, 5))
		{
			sm_dprintf("Timeouts:\n");
			sm_dprintf("  connect = %ld\n",
				   (long) TimeOuts.to_connect);
			sm_dprintf("  aconnect = %ld\n",
				   (long) TimeOuts.to_aconnect);
			sm_dprintf("  initial = %ld\n",
				   (long) TimeOuts.to_initial);
			sm_dprintf("  helo = %ld\n", (long) TimeOuts.to_helo);
			sm_dprintf("  mail = %ld\n", (long) TimeOuts.to_mail);
			sm_dprintf("  rcpt = %ld\n", (long) TimeOuts.to_rcpt);
			sm_dprintf("  datainit = %ld\n",
				   (long) TimeOuts.to_datainit);
			sm_dprintf("  datablock = %ld\n",
				   (long) TimeOuts.to_datablock);
			sm_dprintf("  datafinal = %ld\n",
				   (long) TimeOuts.to_datafinal);
			sm_dprintf("  rset = %ld\n", (long) TimeOuts.to_rset);
			sm_dprintf("  quit = %ld\n", (long) TimeOuts.to_quit);
			sm_dprintf("  nextcommand = %ld\n",
				   (long) TimeOuts.to_nextcommand);
			sm_dprintf("  miscshort = %ld\n",
				   (long) TimeOuts.to_miscshort);
			sm_dprintf("  ident = %ld\n", (long) TimeOuts.to_ident);
			sm_dprintf("  fileopen = %ld\n",
				   (long) TimeOuts.to_fileopen);
			sm_dprintf("  lhlo = %ld\n",
				   (long) TimeOuts.to_lhlo);
			sm_dprintf("  control = %ld\n",
				   (long) TimeOuts.to_control);
		}
		return;
	}

	for (;; val = p)
	{
		while (isascii(*val) && isspace(*val))
			val++;
		if (*val == '\0')
			break;
		for (p = val; *p != '\0' && *p != ','; p++)
			continue;
		if (*p != '\0')
			*p++ = '\0';

		if (isascii(*val) && isdigit(*val))
		{
			/* old syntax -- set everything */
			TimeOuts.to_mail = convtime(val, 'm');
			TimeOuts.to_rcpt = TimeOuts.to_mail;
			TimeOuts.to_datainit = TimeOuts.to_mail;
			TimeOuts.to_datablock = TimeOuts.to_mail;
			TimeOuts.to_datafinal = TimeOuts.to_mail;
			TimeOuts.to_nextcommand = TimeOuts.to_mail;
			if (sticky)
			{
				setbitn(TO_MAIL, StickyTimeoutOpt);
				setbitn(TO_RCPT, StickyTimeoutOpt);
				setbitn(TO_DATAINIT, StickyTimeoutOpt);
				setbitn(TO_DATABLOCK, StickyTimeoutOpt);
				setbitn(TO_DATAFINAL, StickyTimeoutOpt);
				setbitn(TO_COMMAND, StickyTimeoutOpt);
			}
			continue;
		}
		else
		{
			register char *q = strchr(val, ':');

			if (q == NULL && (q = strchr(val, '=')) == NULL)
			{
				/* syntax error */
				continue;
			}
			*q++ = '\0';
			settimeout(val, q, sticky);
		}
	}
}
@


1.28
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.27
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2006, 2008-2010, 2013 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: readcf.c,v 8.690 2013/03/15 17:54:12 ca Exp $")
d2306 1
a2306 1
/* these are turned on by default */
d2313 3
d2352 3
d2358 6
d2388 6
d2405 3
@


1.26
log
@Update to sendmail 8.14.5
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2006, 2008-2010 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: readcf.c,v 8.684 2011/03/15 17:29:29 guenther Exp $")
d1144 1
a1144 1
	while (sm_io_fgets(f, SM_TIME_DEFAULT, buf, sizeof(buf)) != NULL)
d2287 8
d3873 5
d4031 6
@


1.25
log
@Update to sendmail-8.14.3
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2006, 2008 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: readcf.c,v 8.666 2008/02/14 17:25:14 ca Exp $")
d23 1
d117 11
d151 1
a151 1
		if (OpMode == MD_DAEMON || OpMode == MD_INITALIAS)
d477 1
a477 1
				if (OpMode == MD_TEST)
a548 1
				file = p;
d2269 18
d2291 94
d2425 3
d2672 1
d3125 6
d3453 6
d3480 1
a3480 1
				&ConnectOnlyTo.sin6.sin6_addr) != 1)
d3720 43
d3764 1
d4212 1
a4212 2
		while (*p != '\0' && isascii(*p) &&
		       (isalnum(*p) || *p == '_'))
@


1.24
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2006 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: readcf.c,v 8.663 2006/10/05 20:58:59 ca Exp $")
d2248 10
d3819 16
@


1.23
log
@Update to sendmail 8.13.6
@
text
@d15 1
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: readcf.c,v 8.651 2006/03/02 19:17:09 ca Exp $")
d107 1
d153 2
a154 1
	while ((bp = fgetfolded(buf, sizeof buf, cf)) != NULL)
d156 2
d166 4
a169 1
		translate_dollars(bp);
d198 1
a198 1
					(struct rewrite *) xalloc(sizeof *rwp);
d202 1
a202 1
				rwp->r_next = (struct rewrite *) xalloc(sizeof *rwp);
d209 1
a209 1
			expand(&bp[1], exbuf, sizeof exbuf, e);
d211 2
a212 2
					     sizeof pvpbuf, NULL,
					     ConfigLevel >= 9 ? TokTypeNoC : NULL,
d227 1
a227 1
					switch (**ap & 0377)
d238 1
a238 1
						botch = "$0-$9";
d297 1
a297 1
			expand(q, exbuf, sizeof exbuf, e);
d299 2
a300 2
					     sizeof pvpbuf, NULL,
					     ConfigLevel >= 9 ? TokTypeNoC : NULL,
d323 1
a323 1
					switch (**ap & 0377)
d326 2
a327 1
						if ((*ap)[1] <= '0' || (*ap)[1] > nfuzzy)
d330 1
a330 1
								(*ap)[1]);
d366 1
a366 1
						if ((**ap & 0377) == LOOKUPBEGIN)
d373 1
a373 1
						if (*(ap + 1) == NULL)
d378 1
a378 1
						nexttoken = **(ap + 1) & 0377;
d381 1
a381 1
						    nexttoken == endtoken)
d386 1
a386 1
						if (*(ap + 2) == NULL)
d391 1
a391 1
						if ((**ap & 0377) == HOSTBEGIN)
d393 1
a393 1
						nexttoken = **(ap + 2) & 0377;
d406 1
a406 1
						if ((**ap & 0377) != endtoken)
d428 3
a430 4
						ep = *(ap + 1);
						if ((*ep & 0377) != MACRODEXPAND &&
						    stab(ep, ST_MAP,
							 ST_FIND) == NULL)
d457 1
a457 1
			expand(&bp[1], exbuf, sizeof exbuf, e);
d497 1
a497 1
				expand(ep, exbuf, sizeof exbuf, e);
d682 1
a682 1
			expand(&bp[1], exbuf, sizeof exbuf, e);
d744 1
d752 4
a755 1
**		bp -- the buffer to translate.
d758 3
a760 3
**		None.  The buffer is translated in place.  Since the
**		translations always make the buffer shorter, this is
**		safe without a size parameter.
d763 5
a767 3
void
translate_dollars(bp)
	char *bp;
d771 10
d804 1
d806 1
d842 9
d982 1
a982 1
			expand("\201j", jbuf, sizeof jbuf, &BlankEnvelope);
d986 1
a986 1
						  sizeof jbuf);
d995 1
a995 1
				expand(lc, lcbuf, sizeof lcbuf, CurEnv);
d1000 1
a1000 1
			n = sm_snprintf(buf, sizeof buf,
d1003 1
a1003 1
			if (n >= sizeof buf)
d1034 1
a1034 1
		memset(&map, '\0', sizeof map);
d1133 1
a1133 1
	while (sm_io_fgets(f, SM_TIME_DEFAULT, buf, sizeof buf) != NULL)
d1208 2
a1209 2
	m = (struct mailer *) xalloc(sizeof *m);
	memset((char *) m, '\0', sizeof *m);
d1668 1
a1668 1
	for (q = buf; *p != '\0' && q < &buf[sizeof buf - 1]; p++)
d1746 1
a1746 1
	for (q = buf; *p != '\0' && q < &buf[sizeof buf - 1]; p++)
d1808 2
a1809 2
	avp = (char **) xalloc(sizeof *avp * i);
	memmove((char *) avp, (char *) argv, sizeof *avp * i);
d2201 1
a2201 2
#if _FFR_SOFT_BOUNCE
# define O_SOFTBOUNCE	0xcf
d2203 1
a2203 3
#endif /* _FFR_SOFT_BOUNCE */
#if _FFR_SELECT_SHM
# define O_SHMKEYFILE	0xd0
a2204 1
#endif /* _FFR_SELECT_SHM */
d2221 1
a2221 2
#if _FFR_HELONAME
# define O_HELONAME 0xd8
a2222 1
#endif /* _FFR_HELONAME */
d2231 1
a2231 2
#if _FFR_MAXNOOPCOMMANDS
# define O_MAXNOOPCOMMANDS 0xdc
a2232 1
#endif /* _FFR_MAXNOOPCOMMANDS */
d2241 7
d2259 1
a2259 1
		expand(val, exbuf, sizeof exbuf, e);	\
d2288 1
a2288 1
#if STARTTLS || (_FFR_SELECT_SHM && SM_CONF_SHM)
d2291 1
a2291 1
#endif /* STARTTLS || (_FFR_SELECT_SHM && SM_CONF_SHM) */
a3074 1
#if _FFR_SELECT_SHM
d3076 1
a3076 1
# if SM_CONF_SHM
d3078 1
a3078 1
# else /* SM_CONF_SHM */
d3083 1
a3083 2
# endif /* SM_CONF_SHM */
#endif /* _FFR_SELECT_SHM */
d3096 3
a3098 3
		(void) sm_strlcpy(buf, "@@,;:\\()[]", sizeof buf);
		if (strlen(val) < sizeof buf - 10)
			(void) sm_strlcat(buf, val, sizeof buf);
d3406 10
a3746 1
#if _FFR_SOFT_BOUNCE
a3749 1
#endif /* _FFR_SOFT_BOUNCE */
a3771 1
#if _FFR_HELONAME
d3775 1
a3775 1
#endif /* _FFR_HELONAME */
a3787 1
#if _FFR_MAXNOOPCOMMANDS
a3790 1
#endif /* _FFR_MAXNOOPCOMMANDS */
d3804 6
d3853 1
a3853 1
	if ((*str & 0377) == MATCHCLASS)
@


1.22
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: readcf.c,v 8.642 2004/08/04 21:17:57 ca Exp $")
d682 1
a682 1
			setuserenv(&bp[1], p);
d2194 20
d2254 1
a2254 1
#if STARTTLS
d2257 1
a2257 1
#endif /* STARTTLS */
d2495 4
d3734 2
a3735 2
	        HeloName = newstr(val);
	        break;
d3737 29
@


1.21
log
@Update to sendmail-8.13.1
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: readcf.c,v 8.641 2004/07/23 20:45:02 gshapiro Exp $")
d32 1
@


1.20
log
@Update to sendmail.8.13.0
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: readcf.c,v 8.638 2004/06/02 22:48:51 ca Exp $")
d1190 2
d2185 8
d3515 12
d3595 3
d3706 6
@


1.19
log
@Update to sendmail 8.12.11.  I've been runninga beta version of this for
some time without problems.  See the RELEASE_NOTES for the change log.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: readcf.c,v 8.607.2.12 2003/10/07 17:45:28 ca Exp $")
d203 2
a204 1
					     ConfigLevel >= 9 ? TokTypeNoC : NULL);
d291 2
a292 1
					     ConfigLevel >= 9 ? TokTypeNoC : NULL);
d965 1
a965 1
					"-k (&(objectClass=sendmailMTAClass)(sendmailMTAClassName=%s)(|(sendmailMTACluster=%s)(sendmailMTAHost=%s))) -v sendmailMTAClassValue",
d1798 1
a1798 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "\n----Rule Set %d:", ruleset);
d1802 4
a1805 6
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "\nLHS:");
			printav(rwp->r_lhs);
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "RHS:");
			printav(rwp->r_rhs);
d1813 1
d1821 2
a1822 1
printmailer(m)
d1827 1
a1827 1
	(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d1831 1
a1831 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%d/",
d1834 1
a1834 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s/",
d1837 1
a1837 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%d R=",
d1840 1
a1840 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s R=",
d1843 1
a1843 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%d/",
d1846 1
a1846 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s/",
d1849 1
a1849 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%d ",
d1852 1
a1852 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s ",
d1854 1
a1854 1
	(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "M=%ld U=%d:%d F=",
d1858 2
a1859 2
			(void) sm_io_putc(smioout, SM_TIME_DEFAULT, j);
	(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, " L=%d E=",
d1861 1
a1861 1
	xputs(m->m_eol);
d1863 1
a1863 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, " C=%s",
d1865 1
a1865 1
	(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, " T=%s/%s/%s",
d1872 1
a1872 1
	(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, " r=%d", m->m_maxrcpt);
d1877 1
a1877 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, " A=");
d1881 1
a1881 1
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
d1883 1
a1883 1
			xputs(*a++);
d1886 1
a1886 1
	(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "\n");
a2106 4
#if _FFR_QUEUEDELAY
# define O_QUEUEDELAY	0xb3
	{ "QueueDelay",			O_QUEUEDELAY,	OI_NONE	},
#endif /* _FFR_QUEUEDELAY */
d2171 1
a2171 2
#if _FFR_REJECT_LOG
# define O_REJECTLOGINTERVAL	0xd1
d2173 1
a2173 3
#endif /* _FFR_REJECT_LOG */
#if _FFR_REQ_DIR_FSYNC_OPT
# define O_REQUIRES_DIR_FSYNC	0xd2
d2175 9
a2183 1
#endif /* _FFR_REQ_DIR_FSYNC_OPT */
d2323 1
a2323 1
		xputs(val);
d2449 2
a2450 1
		CheckpointInterval = atoi(val);
d2732 7
d2815 1
a2815 1
			FallBackMX = newstr(val);
d2900 3
a2902 34
		  default:
			syserr("Invalid queue sort order \"%s\"", val);
		}
		break;

#if _FFR_QUEUEDELAY
	  case O_QUEUEDELAY:	/* queue delay algorithm */
		switch (*val)
		{
		  case 'e':	/* exponential */
		  case 'E':
			QueueAlg = QD_EXP;
			QueueInitDelay = 10 MINUTES;
			QueueMaxDelay = 2 HOURS;
			p = strchr(val, '/');
			if (p != NULL)
			{
				char *q;

				*p++ = '\0';
				q = strchr(p, '/');
				if (q != NULL)
					*q++ = '\0';
				QueueInitDelay = convtime(p, 's');
				if (q != NULL)
				{
					QueueMaxDelay = convtime(q, 's');
				}
			}
			break;

		  case 'l':	/* linear */
		  case 'L':
			QueueAlg = QD_LINEAR;
d2906 1
a2906 1
			syserr("Invalid queue delay algorithm \"%s\"", val);
a2908 1
#endif /* _FFR_QUEUEDELAY */
d3389 9
a3422 2
# if _FFR_SASL_OPT_M
/* to be activated in 8.13 */
a3427 1
# endif /* _FFR_SASL_OPT_M */
d3465 1
d3495 9
d3572 1
a3660 1
#if _FFR_REJECT_LOG
a3663 1
#endif /* _FFR_REJECT_LOG */
a3664 1
#if _FFR_REQ_DIR_FSYNC_OPT
d3666 1
a3666 1
# if REQUIRES_DIR_FSYNC
d3668 1
a3668 1
# else /* REQUIRES_DIR_FSYNC */
d3670 10
a3679 1
# endif /* REQUIRES_DIR_FSYNC */
a3680 1
#endif /* _FFR_REQ_DIR_FSYNC_OPT */
d4050 1
a4050 2
#if _FFR_QUEUERETURN_DSN
# define TO_QUEUEWARN_DSN		0x24
d4052 1
a4052 1
# define TO_QUEUERETURN_DSN		0x25
a4053 1
#endif /* _FFR_QUEUERETURN_DSN */
a4171 1
#if _FFR_QUEUERETURN_DSN
a4172 1
#endif /* _FFR_QUEUERETURN_DSN */
a4190 1
#if _FFR_QUEUERETURN_DSN
a4194 1
#endif /* _FFR_QUEUERETURN_DSN */
a4200 1
#if _FFR_QUEUERETURN_DSN
a4201 1
#endif /* _FFR_QUEUERETURN_DSN */
a4219 1
#if _FFR_QUEUERETURN_DSN
a4223 1
#endif /* _FFR_QUEUERETURN_DSN */
@


1.18
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: readcf.c,v 8.607.2.11 2003/04/03 23:04:06 ca Exp $")
d3156 1
a3156 1
						     "WARNING: RunAsGid for MSP ignored, check group ids (egid=%d, want=%d)\n",
d3180 1
a3180 1
							     "WARNING: RunAsGid for MSP ignored, check group ids (egid=%d, want=%d)\n",
d3197 1
a3197 1
							     "WARNING: RunAsGid for MSP ignored, check group ids (egid=%d, want=%d)\n",
@


1.17
log
@Update to sendmail 8.12.9; fixes a buffer overflow in address parsing
due to a char to int conversion problem which is potentially remotely
exploitable.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: readcf.c,v 8.607.2.8 2003/03/12 22:42:52 gshapiro Exp $")
d294 5
d304 3
d342 59
d435 2
d935 1
d975 1
d2626 1
a2626 1
			cleanstrcpy(p, p, MAXNAME);
d3350 1
a3350 1
		if (MaxMimeHeaderLength < 0)
d3356 1
a3356 1
		if (MaxMimeFieldLength < 0)
@


1.16
log
@update to sendmail 8.12.7
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: readcf.c,v 8.607.2.7 2002/11/10 19:13:11 ca Exp $")
d3979 6
d4103 3
d4124 7
d4136 3
d4156 7
@


1.15
log
@update to sendmail-8.12.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: readcf.c,v 8.607.2.2 2002/08/19 21:50:49 gshapiro Exp $")
d2048 1
a2048 1
	{ "CACERTFile",			O_CACERTFILE,	OI_NONE	},
d2050 1
a2050 1
	{ "CACERTPath",			O_CACERTPATH,	OI_NONE	},
d2103 8
d3348 1
d3352 1
d3356 1
d3360 1
d3364 1
d3373 1
d3377 1
d3381 1
d3386 1
d3402 1
d3420 1
a3420 1
		SET_STRING_EXP(SrvCERTfile);
d3422 1
a3422 1
		SET_STRING_EXP(Srvkeyfile);
d3424 1
a3424 1
		SET_STRING_EXP(CltCERTfile);
d3426 1
a3426 1
		SET_STRING_EXP(Cltkeyfile);
d3428 1
a3428 1
		SET_STRING_EXP(CACERTfile);
d3430 1
a3430 1
		SET_STRING_EXP(CACERTpath);
d3594 16
@


1.14
log
@sendmail 8.12.5
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: readcf.c,v 8.607 2002/06/14 16:57:32 ca Exp $")
d2042 1
a2042 1
	{ "Serverkeyfile",		O_SRVKEYFILE,	OI_NONE	},
d2046 1
a2046 1
	{ "Clientkeyfile",		O_CLTKEYFILE,	OI_NONE	},
a4102 1

@


1.13
log
@Update to sendmail-8.12.4
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: readcf.c,v 8.606 2002/05/09 21:09:01 ca Exp $")
d2952 1
a2952 2
		CANONIFY(val);
		ShmKeyFile = newstr(val);
d2957 1
a2958 1
		break;
@


1.12
log
@update to sendmail 8.12.3
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: readcf.c,v 8.604 2002/04/02 16:43:25 ca Exp $")
d3353 8
@


1.11
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: readcf.c,v 8.594 2001/12/14 00:43:17 gshapiro Exp $")
d27 1
a27 1
static void	fileclass __P((int, char *, char *, bool, bool));
d99 1
d462 16
a477 1
			if (*p == '@@')
d492 1
a492 1
			if (*file == '|' || *file == '@@')
d506 1
a506 1
			fileclass(mid, file, p, safe, optional);
d773 1
d818 1
a818 1
fileclass(class, filename, fmt, safe, optional)
d822 1
d840 1
a840 2
	else if (!SM_IS_DIR_DELIM(*filename) && *filename != '|' &&
		 (p = strchr(filename, '@@')) != NULL)
d853 9
d930 5
d1116 1
d2099 4
d2675 1
a2675 1
#if _FFR_DOTTED_USERNAMES
d2677 1
a2677 1
#else /* _FFR_DOTTED_USERNAMES */
d2679 1
a2679 1
#endif /* _FFR_DOTTED_USERNAMES */
d2768 3
d2891 11
d2939 1
a2939 1
	  case O_SHMKEY	:		/* shared memory key */
d2949 13
d3042 1
a3042 1
#if _FFR_DOTTED_USERNAMES
d3044 1
a3044 1
#else /* _FFR_DOTTED_USERNAMES */
d3046 1
a3046 1
#endif /* _FFR_DOTTED_USERNAMES */
d4194 1
@


1.10
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: readcf.c,v 8.587 2001/09/22 20:48:35 ca Exp $")
d118 1
a118 1
		finis(false, EX_OSFILE);
d124 1
a124 1
		finis(false, EX_OSFILE);
d130 1
a130 1
		finis(false, EX_OSFILE);
d616 1
a616 1
		finis(false, EX_OSFILE);
d980 2
d1349 18
d1399 1
a1399 2
		syserr("M%s: P=[TCP] must be replaced by P=[IPC]\n",
		       m->m_name);
d1860 3
d1874 3
d2283 1
a2283 1
			finis(false, EX_USAGE);
d2351 1
a2351 1
			finis(false, EX_USAGE);
d2639 3
d2643 1
d2880 4
d2979 3
d2983 1
d3167 1
a3167 1
# if !HASFCHOWN
d3171 1
a3171 1
# endif /* !HASFCHOWN */
@


1.9
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: readcf.c,v 8.582 2001/09/04 22:43:05 ca Exp $")
d648 1
a648 1
/*
d729 1
a729 1
/*
d750 1
a750 1
/*
d967 1
a967 1
				       (void *) fd, SM_IO_RDONLY, NULL);
d1020 1
a1020 1
/*
d1478 1
a1478 1
/*
d1550 1
a1550 1
/*
d1610 1
a1610 1
/*
d1651 1
a1651 1
/*
d1688 1
a1688 1
/*
d1765 1
a1765 1
/*
d2158 5
d3492 1
a3492 1
/*
d3536 1
a3536 1
/*
d3616 1
a3616 1
/*
d3744 1
a3744 1
/*
d4065 1
a4065 1
/*
@


1.8
log
@Update to sendmail 8.11.6, from the release notes:

SECURITY: Fix a possible memory access violation when specifying
	out-of-bounds debug parameters.  Problem detected by
	Cade Cairns of SecurityFocus.
Avoid leaking recipient information in unrelated DSNs.  This could
	happen if a connection is aborted, several mails had been
	scheduled for delivery via that connection, and the timeout
	is reached such that several DSNs are sent next.  Problem
	noted by Dileepan Moorkanat of Hewlett-Packard.
Fix a possible segmentation violation when specifying too many
	wildcard operators in a rule.  Problem detected by
	Werner Wiethege.
Avoid a segmentation fault on non-matching Hesiod lookups.  Problem
	noted by Russell McOrmond of flora.ca
@
text
@a13 4
#ifndef lint
static char id[] = "@@(#)$Sendmail: readcf.c,v 8.382.4.43 2001/08/14 23:08:13 ca Exp $";
#endif /* ! lint */

d16 1
d31 1
d58 1
d60 2
d72 2
a73 2
**		safe -- TRUE if this is the system config file;
**			FALSE otherwise.
d89 1
a89 1
	FILE *cf;
d98 1
d107 1
a107 1
	extern u_char TokTypeNoC[];
d118 1
a118 1
		finis(FALSE, EX_OSFILE);
d121 1
a121 1
	if (fstat(fileno(cf), &statb) < 0)
d124 1
a124 1
		finis(FALSE, EX_OSFILE);
d130 1
a130 1
		finis(FALSE, EX_OSFILE);
d136 3
a138 2
			fprintf(stderr, "%s: WARNING: dangerous write permissions\n",
				FileName);
d145 1
a145 1
#ifdef XLA
d154 1
a154 1
				sm_free(bp);
d208 1
a208 1
				rwp->r_lhs = copyplist(rwp->r_lhs, TRUE);
d294 1
a294 1
				rwp->r_rhs = copyplist(rwp->r_rhs, TRUE);
d332 30
d385 4
a388 2
					printf("WARNING: Ruleset %s has multiple definitions\n",
					       &bp[1]);
d390 2
a391 2
					dprintf("WARNING: Ruleset %s has multiple definitions\n",
						&bp[1]);
d398 1
a398 1
			mid = macid(&bp[1], &ep);
d402 1
a402 1
			define(mid, newstr(p), e);
d413 1
a413 1
				mid = macid(&bp[1], &ep);
d443 1
a443 1
			mid = macid(&bp[1], &ep);
d450 3
a452 2
				optional = TRUE;
				while (*p != '\0' && !(isascii(*p) && isspace(*p)))
d456 9
d467 8
a474 1
				optional = FALSE;
d476 1
a476 5
			file = p;
			q = p;
			while (*q != '\0' && !(isascii(*q) && isspace(*q)))
				q++;
			if (*file == '|')
d493 1
a493 1
#ifdef XLA
d514 1
a514 1
			setoption(bp[1], &bp[2], safe, FALSE, e);
d533 4
d557 1
d559 3
a561 1
				define('w', macvalue('w', e), e);
d565 1
a565 1
				ColonOkInAddr = FALSE;
a596 1
#if _FFR_MILTER
d598 1
d600 4
a604 1
#endif /* _FFR_MILTER */
d611 1
a611 1
			sm_free(bp);
d613 1
a613 1
	if (ferror(cf))
d616 1
a616 1
		finis(FALSE, EX_OSFILE);
d618 1
a618 1
	(void) fclose(cf);
d634 1
a634 1
		UseNameServer = FALSE;
d639 2
a640 1
			for (mapno = 0; mapno < nmaps && !UseNameServer; mapno++)
d643 1
a643 1
					UseNameServer = TRUE;
a645 15

#ifdef HESIOD
		nmaps = switch_map_find("passwd", maptype, mapreturn);
		UseHesiod = FALSE;
		if (nmaps > 0 && nmaps <= MAXMAPSTACK)
		{
			register int mapno;

			for (mapno = 0; mapno < nmaps && !UseHesiod; mapno++)
			{
				if (strcmp(maptype[mapno], "hesiod") == 0)
					UseHesiod = TRUE;
			}
		}
#endif /* HESIOD */
a673 1
			/* this is an on-line comment */
d685 1
a685 1
				(void) strlcpy(p, p + 1, strlen(p));
d694 1
a694 1
					(void) strlcpy(p, e, strlen(p));
d708 1
a708 1
			(void) strlcpy(p, p + 1, strlen(p));
d720 1
a720 1
		*p = macid(p, &ep);
d722 1
a722 1
			(void) strlcpy(p + 1, ep, strlen(p + 1));
a764 1
**
d769 31
d808 1
a808 1
	FILE *f;
d815 113
a927 1
		dprintf("fileclass(%s, fmt=%s)\n", filename, fmt);
d929 22
a950 1
	if (filename[0] == '|')
d957 3
a959 4
		for (p = strtok(&filename[1], " \t"); p != NULL; p = strtok(NULL, " \t"))
		{
			if (i >= MAXPV)
				break;
a960 1
		}
d966 2
a967 1
			f = fdopen(fd, "r");
d991 1
a991 1
	while (fgets(buf, sizeof buf, f) != NULL)
d1000 1
a1000 1
		if (sscanf(buf, fmt, wordbuf) != 1)
d1007 2
d1010 3
a1012 1
		**  Break up the match into words.
a1013 21

		while (*p != '\0')
		{
			register char *q;

			/* strip leading spaces */
			while (isascii(*p) && isspace(*p))
				p++;
			if (*p == '\0')
				break;

			/* find the end of the word */
			q = p;
			while (*p != '\0' && !(isascii(*p) && isspace(*p)))
				p++;
			if (*p != '\0')
				*p++ = '\0';

			/* enter the word in the symbol table */
			setclass(class, q);
		}
d1016 1
a1016 1
	(void) fclose(f);
d1035 1
d1042 1
d1063 1
a1063 1
	extern int NextMailer;
d1068 1
d1071 3
a1073 1
	for (p = line; *p != '\0' && *p != ',' && !(isascii(*p) && isspace(*p)); p++)
d1089 2
a1090 1
		while (*p != '\0' && (*p == ',' || (isascii(*p) && isspace(*p))))
d1112 1
a1112 3
			if (*p == '\0')
				syserr("mailer %s: empty path name", m->m_name);
			else
d1118 1
d1120 7
d1128 2
d1164 1
a1164 4
			if (*p == '\0')
				syserr("mailer %s: null argument vector",
					m->m_name);
			else
a1175 1
#if _FFR_DYNAMIC_TOBUF
a1178 1
#endif /* _FFR_DYNAMIC_TOBUF */
d1205 14
d1359 1
a1359 1
	if (NextMailer >= MAXMAILERS)
a1364 1
#if _FFR_DYNAMIC_TOBUF
a1366 1
#endif /* _FFR_DYNAMIC_TOBUF */
d1379 1
a1379 2
#if _FFR_REMOVE_TCP_MAILER_PATH
		syserr("M%s: P=[TCP] is deprecated, use P=[IPC] instead\n",
a1381 4
#else /* _FFR_REMOVE_TCP_MAILER_PATH */
		printf("M%s: Warning: P=[TCP] is deprecated, use P=[IPC] instead\n",
		       m->m_name);
#endif /* _FFR_REMOVE_TCP_MAILER_PATH */
d1384 1
a1384 5
	if (strcmp(m->m_mailer, "[IPC]") == 0
#if !_FFR_REMOVE_TCP_MAILER_PATH
	    || strcmp(m->m_mailer, "[TCP]") == 0
#endif /* !_FFR_REMOVE_TCP_MAILER_PATH */
	    )
a1397 3
#if !_FFR_DEPRECATE_IPC_MAILER_ARG
		    && strcmp(m->m_argv[0], "IPC") != 0
#endif /* !_FFR_DEPRECATE_IPC_MAILER_ARG */
d1400 3
a1402 2
			printf("M%s: Warning: first argument in %s mailer must be %s\n",
			       m->m_name, m->m_mailer,
d1404 1
a1404 1
			       "TCP or FILE"
d1406 1
a1406 1
			       "TCP"
d1408 13
a1420 1
			       );
a1421 1

a1442 17
	if (strcmp(m->m_mailer, "[IPC]") == 0 ||
	    strcmp(m->m_mailer, "[TCP]") == 0)
	{
		if (m->m_mtatype == NULL)
			m->m_mtatype = "dns";
		if (m->m_addrtype == NULL)
			m->m_addrtype = "rfc822";
		if (m->m_diagtype == NULL)
		{
			if (m->m_argv[0] != NULL &&
			    strcmp(m->m_argv[0], "FILE") == 0)
				m->m_diagtype = "x-unix";
			else
				m->m_diagtype = "smtp";
		}
	}

d1469 1
a1469 1
		sm_free(s->s_mailer);
d1473 1
a1473 1
		i = NextMailer++;
d1502 2
a1503 2
	bool backslash = FALSE;
	bool quotemode = FALSE;
d1511 1
a1511 1
			backslash = FALSE;
d1535 1
a1535 1
				backslash = TRUE;
d1551 60
d1674 2
a1675 1
		printf("\n----Rule Set %d:", ruleset);
d1679 2
a1680 1
			printf("\nLHS:");
d1682 2
a1683 1
			printf("RHS:");
d1704 3
a1706 1
	printf("mailer %d (%s): P=%s S=", m->m_mno, m->m_name, m->m_mailer);
d1708 2
a1709 1
		printf("%d/", m->m_se_rwset);
d1711 2
a1712 1
		printf("%s/", RuleSetNames[m->m_se_rwset]);
d1714 2
a1715 1
		printf("%d R=", m->m_sh_rwset);
d1717 2
a1718 1
		printf("%s R=", RuleSetNames[m->m_sh_rwset]);
d1720 2
a1721 1
		printf("%d/", m->m_re_rwset);
d1723 2
a1724 1
		printf("%s/", RuleSetNames[m->m_re_rwset]);
d1726 2
a1727 1
		printf("%d ", m->m_rh_rwset);
d1729 4
a1732 3
		printf("%s ", RuleSetNames[m->m_rh_rwset]);
	printf("M=%ld U=%d:%d F=", m->m_maxsize,
	       (int) m->m_uid, (int) m->m_gid);
d1735 3
a1737 2
			(void) putchar(j);
	printf(" L=%d E=", m->m_linelimit);
d1740 10
a1749 8
		printf(" C=%s", m->m_defcharset);
	printf(" T=%s/%s/%s",
		m->m_mtatype == NULL ? "<undefined>" : m->m_mtatype,
		m->m_addrtype == NULL ? "<undefined>" : m->m_addrtype,
		m->m_diagtype == NULL ? "<undefined>" : m->m_diagtype);
#if _FFR_DYNAMIC_TOBUF
	printf(" r=%d", m->m_maxrcpt);
#endif /* _FFR_DYNAMIC_TOBUF */
d1754 1
a1754 1
		printf(" A=");
d1758 2
a1759 1
				printf(" ");
d1763 1
a1763 1
	printf("\n");
d1804 3
d1819 3
a1821 3
	char	*o_name;	/* long name of option */
	u_char	o_code;		/* short name of option */
	u_short	o_flags;	/* option flags */
a1834 3
#if !_FFR_REMOVE_AUTOREBUILD
	{ "AutoRebuildAliases",		'D',		OI_NONE	},
#endif /* !_FFR_REMOVE_AUTOREBUILD */
d1976 1
a1976 1
# define O_LDAPDEFAULTSPEC	0xb2
d1979 1
a1979 1
#define O_QUEUEDELAY	0xb3
d1982 1
a1982 1
# define O_SRVCERTFILE	0xb4
d1984 1
a1984 1
# define O_SRVKEYFILE	0xb5
d1986 1
a1986 1
# define O_CLTCERTFILE	0xb6
d1988 1
a1988 1
# define O_CLTKEYFILE	0xb7
d1990 1
a1990 1
# define O_CACERTFILE	0xb8
d1992 1
a1992 1
# define O_CACERTPATH	0xb9
d1994 1
a1994 1
# define O_DHPARAMS	0xba
a1995 1
#if _FFR_MILTER
a1999 1
#endif /* _FFR_MILTER */
a2001 1
#if _FFR_QUEUE_FILE_MODE
d2004 1
a2004 2
#endif /* _FFR_QUEUE_FILE_MODE */
# if _FFR_TLS_1
d2009 2
a2010 2
# endif /* _FFR_TLS_1 */
# define O_RANDFILE	0xc1
d2012 30
d2045 17
d2079 1
a2079 1
	extern int SubmitMode;
d2081 4
d2114 1
a2114 1
			if (strncasecmp(o->o_name, val, strlen(val)) != 0)
d2164 2
a2165 3
			dprintf("setoption: %s does not support suboptions, ignoring .%s\n",
				o->o_name == NULL ? "<unknown>" : o->o_name,
				subopt);
d2171 5
a2175 7
		dprintf(isascii(opt) && isprint(opt) ?
			"setoption %s (%c)%s%s=" :
			"setoption %s (0x%x)%s%s=",
			o->o_name == NULL ? "<unknown>" : o->o_name,
			opt,
			subopt == NULL ? "" : ".",
			subopt == NULL ? "" : subopt);
d2186 1
a2186 1
			dprintf(" (ignored)\n");
d2195 1
a2195 1
		safe = TRUE;
d2203 2
a2204 2
				dprintf(" (unsafe)");
			dp = drop_privileges(TRUE);
d2209 1
a2209 1
		dprintf("\n");
d2221 4
a2228 4
		  case 'p':		/* pass 8 bit, convert MIME */
			MimeMode = MM_CVTMIME|MM_PASS8BIT;
			break;

d2253 1
a2253 1
			finis(FALSE, EX_USAGE);
d2256 3
a2258 1
		printf("Warning: Option EightBitMode requires MIME8TO7 support\n");
d2264 6
a2269 1
			setalias("aliases");
d2276 1
a2276 1
			SafeAlias = 5 * 60;		/* five minutes */
a2313 6
#if !QUEUE
			syserr("need QUEUE to set -odqueue or -oddefer");
			break;
#endif /* !QUEUE */
			/* FALLTHROUGH */

d2321 1
a2321 1
			finis(FALSE, EX_USAGE);
a2324 6
#if !_FFR_REMOVE_AUTOREBUILD
	  case 'D':		/* rebuild alias database as needed */
		AutoRebuild = atobool(val);
		break;
#endif /* !_FFR_REMOVE_AUTOREBUILD */

d2375 3
a2377 1
			HelpFile = "helpfile";
d2380 1
d2401 1
a2401 1
			clearmode = FALSE;
d2403 1
a2403 1
				clearmode = TRUE;
d2412 1
a2412 1
			if (strcasecmp(q, "HasWildcardMX") == 0)
a2416 1
#if _FFR_WORKAROUND_BROKEN_NAMESERVERS
a2421 1
#endif /* _FFR_WORKAROUND_BROKEN_NAMESERVERS */
d2424 1
a2424 1
				if (strcasecmp(q, rfp->rf_name) == 0)
d2435 2
a2436 2
			dprintf("_res.options = %x, HasWildcardMX = %d\n",
				(u_int) _res.options, HasWildcardMX);
d2451 1
d2475 2
a2476 2
		sticky = FALSE;
		mid = macid(val, &ep);
d2482 1
a2482 1
		define(mid, p, CurEnv);
a2495 1
#if DAEMON
a2497 3
#else /* DAEMON */
		syserr("DaemonPortOptions (O option) set but DAEMON not compiled in");
#endif /* DAEMON */
d2526 1
a2526 1
				if (strcasecmp(val, pv->pv_name) == 0)
d2534 1
a2534 1
		sticky = FALSE;
d2555 1
a2555 1
			Warn_Q_option = TRUE;
d2571 3
a2573 1
			StatFile = "statistics";
d2576 1
d2582 4
a2585 1
		SuperSafe = atobool(val);
d2639 1
a2639 1
#ifdef UID_MAX
d2643 1
a2643 1
				(long) DefUid, (long) UID_MAX);
d2646 1
a2646 1
#endif /* UID_MAX */
d2673 1
a2673 1
	  case 'X':		/* load avg at which to auto-reject connections */
d2677 4
d2701 5
d2711 5
d2726 9
a2734 3
		  case 'f':	/* File Name */
		  case 'F':
			QueueSortOrder = QSO_BYFILENAME;
d2736 1
d2781 1
d2790 1
a2790 1
		DefaultCharSet = newstr(denlstring(val, TRUE, TRUE));
d2794 1
d2803 1
a2803 1
		if (strcasecmp(val, "none") == 0)
d2805 1
a2805 1
		else if (strcasecmp(val, "add-to") == 0)
d2807 1
a2807 1
		else if (strcasecmp(val, "add-apparently-to") == 0)
d2809 1
a2809 1
		else if (strcasecmp(val, "add-bcc") == 0)
d2811 1
a2811 1
		else if (strcasecmp(val, "add-to-undisclosed") == 0)
d2830 1
a2830 1
		MaxQueueRun = atol(val);
d2837 24
d2872 3
a2874 3
		(void) strlcpy(buf, "@@,;:\\()[]", sizeof buf);
		if (strlen(val) < (SIZE_T) sizeof buf - 10)
			(void) strlcat(buf, val, sizeof buf);
d2876 2
a2877 1
			printf("Warning: MustQuoteChars too long, ignored.\n");
d2891 2
a2892 1
			printf("Warning: OperatorChars is being redefined.\n         It should only be set before ruleset definitions.\n");
d2923 1
a2923 4
		if (val[0] != '\0')
			DoubleBounceAddr = newstr(val);
		else
			syserr("readcf: option DoubleBounceAddress: value required");
d2929 1
d2969 7
d2977 1
a2977 1
#ifdef UID_MAX
d2984 1
a2984 1
#endif /* UID_MAX */
d2989 11
a2999 2
				if (can_setuid)
					RunAsGid = atoi(p);
d3009 1
a3009 1
				else if (can_setuid)
d3011 6
d3020 2
a3021 2
			dprintf("readcf: RunAsUser = %d:%d\n",
				(int)RunAsUid, (int)RunAsGid);
d3029 1
a3029 3
		if (PidFile != NULL)
			sm_free(PidFile);
		PidFile = newstr(val);
d3032 1
a3032 1
	case O_DONTBLAMESENDMAIL:
d3052 1
a3052 1
				if (strcasecmp(val, dbs->dbs_name) == 0)
d3062 1
a3062 1
		sticky = FALSE;
d3066 6
a3071 1
		DontProbeInterfaces = atobool(val);
d3078 4
d3083 2
a3084 3
		if (DeadLetterDrop != NULL)
			sm_free(DeadLetterDrop);
		DeadLetterDrop = newstr(val);
d3100 1
d3102 2
a3103 2
		if (inet_addr(val) == INADDR_NONE)
		{
a3104 5
			if (inet_pton(AF_INET6, val,
				      &ConnectOnlyTo.sin6.sin6_addr) != 1)
				syserr("readcf: option ConnectOnlyTo: invalid IP address %s",
				       val);
		}
d3107 1
a3108 1
			ConnectOnlyTo.sa.sa_family = AF_INET;
d3110 10
d3125 5
a3129 1
#if HASFCHOWN
a3154 3
#else /* HASFCHOWN */
		syserr("readcf: option TrustedUser: can not be used on systems which do not support fchown()");
#endif /* HASFCHOWN */
d3170 2
a3171 1
			printf("Warning: MaxMimeHeaderLength: header length limit set lower than 128\n");
d3176 2
a3177 1
			printf("Warning: MaxMimeHeaderLength: field length limit set lower than 40\n");
d3181 1
a3181 3
		if (ControlSocketName != NULL)
			sm_free(ControlSocketName);
		ControlSocketName = newstr(val);
d3189 3
a3191 1
			printf("Warning: MaxHeadersLength: headers length limit set lower than %d\n", (MAXHDRSLEN / 2));
d3195 1
a3195 3
		if (ProcTitlePrefix != NULL)
			sm_free(ProcTitlePrefix);
		ProcTitlePrefix = newstr(val);
d3200 1
a3200 1
#if _FFR_ALLOW_SASLINFO
d3202 4
a3205 1
		**  Allow users to select their own authinfo file.
a3213 5
		{
			errno = 0;
			syserr("Error: %s only allowed with -U\n",
				o->o_name == NULL ? "<unknown>" : o->o_name);
			ExitStat = EX_USAGE;
d3215 2
a3216 5
		}
#endif /* _FFR_ALLOW_SASLINFO */
		if (SASLInfo != NULL)
			sm_free(SASLInfo);
		SASLInfo = newstr(val);
d3221 1
a3221 1
			sm_free(AuthMechanisms);
d3231 1
a3231 1
			switch(*val)
a3235 1
# if _FFR_SASL_OPTS
d3254 4
a3257 1
# endif /* _FFR_SASL_OPTS */
d3259 6
a3264 5
				printf("Warning: Option: %s unknown parameter '%c'\n",
					o->o_name == NULL ? "<unknown>"
							  : o->o_name,
					(isascii(*val) && isprint(*val)) ? *val
									 : '?');
d3273 3
d3281 4
a3284 2
		printf("Warning: Option: %s requires SASL support (-DSASL)\n",
			o->o_name == NULL ? "<unknown>" : o->o_name);
d3290 1
a3290 5
		if (SrvCERTfile != NULL)
			sm_free(SrvCERTfile);
		SrvCERTfile = newstr(val);
		break;

d3292 1
a3292 5
		if (Srvkeyfile != NULL)
			sm_free(Srvkeyfile);
		Srvkeyfile = newstr(val);
		break;

d3294 1
a3294 5
		if (CltCERTfile != NULL)
			sm_free(CltCERTfile);
		CltCERTfile = newstr(val);
		break;

d3296 1
a3296 5
		if (Cltkeyfile != NULL)
			sm_free(Cltkeyfile);
		Cltkeyfile = newstr(val);
		break;

d3298 1
a3298 5
		if (CACERTfile != NULL)
			sm_free(CACERTfile);
		CACERTfile = newstr(val);
		break;

d3300 9
a3308 4
		if (CACERTpath != NULL)
			sm_free(CACERTpath);
		CACERTpath = newstr(val);
		break;
d3310 9
a3318 5
	  case O_DHPARAMS:
		if (DHParams != NULL)
			sm_free(DHParams);
		DHParams = newstr(val);
		break;
d3320 16
a3335 6
#  if _FFR_TLS_1
	  case O_DHPARAMS5:
		if (DHParams5 != NULL)
			sm_free(DHParams5);
		DHParams5 = newstr(val);
		break;
d3337 22
a3358 4
	  case O_CIPHERLIST:
		if (CipherList != NULL)
			sm_free(CipherList);
		CipherList = newstr(val);
a3359 1
#  endif /* _FFR_TLS_1 */
d3362 1
a3362 3
		if (RandFile != NULL)
			sm_free(RandFile);
		RandFile= newstr(val);
d3365 1
a3365 1
# else /* STARTTLS */
d3373 1
a3373 1
#  if _FFR_TLS_1
d3376 1
a3376 1
#  endif /* _FFR_TLS_1 */
d3378 3
a3380 2
		printf("Warning: Option: %s requires TLS support\n",
			o->o_name == NULL ? "<unknown>" : o->o_name);
d3383 1
a3383 1
# endif /* STARTTLS */
a3385 1
#if DAEMON
a3386 3
#else /* DAEMON */
		syserr("ClientPortOptions (O option) set but DAEMON not compiled in");
#endif /* DAEMON */
d3398 1
a3398 1
#ifdef LDAPMAP
d3401 3
a3403 2
		printf("Warning: Option: %s requires LDAP support (-DLDAPMAP)\n",
			o->o_name == NULL ? "<unknown>" : o->o_name);
a3406 1
#if _FFR_MILTER
d3408 1
d3410 5
d3418 1
d3420 5
a3425 1
#endif /* _FFR_MILTER */
a3426 1
#if _FFR_QUEUE_FILE_MODE
d3430 34
a3463 1
#endif /* _FFR_QUEUE_FILE_MODE */
d3469 1
a3469 1
				dprintf("Warning: option %c unknown\n", opt);
d3471 1
a3471 1
				dprintf("Warning: option 0x%x unknown\n", opt);
d3513 1
a3513 1
		mid = macid(str, NULL);
d3518 2
a3519 2
			dprintf("setclass(%s, $=%s)\n",
				macname(class), macname(mid));
d3525 1
a3525 1
			dprintf("setclass(%s, %s)\n", macname(class), str);
d3587 2
a3588 1
		syserr("readcf: map %s: class %s not available", mapname, classname);
d3602 6
a3607 8
		dprintf("map %s, class %s, flags %lx, file %s,\n",
			s->s_map.map_mname, s->s_map.map_class->map_cname,
			s->s_map.map_mflags,
			s->s_map.map_file == NULL ? "(null)" : s->s_map.map_file);
		dprintf("\tapp %s, domain %s, rebuild %s\n",
			s->s_map.map_app == NULL ? "(null)" : s->s_map.map_app,
			s->s_map.map_domain == NULL ? "(null)" : s->s_map.map_domain,
			s->s_map.map_rebuild == NULL ? "(null)" : s->s_map.map_rebuild);
a3608 1

d3729 1
a3729 1
				sm_free(RuleSetNames[ruleset]);
d3757 2
a3758 2
	char	*to_name;	/* long name of timeout */
	u_char	to_code;	/* code for option */
d3825 8
d3844 1
a3844 2
	int i;
	int addopts;
d3848 1
a3848 1
		dprintf("settimeout(%s = %s)", name, val);
d3852 1
a3852 1
		if (strcasecmp(to->to_name, name) == 0)
d3870 1
a3870 1
			dprintf(" (ignored)\n");
d3875 1
a3875 1
		dprintf("\n");
d3942 4
d4033 16
d4084 1
a4084 1
		dprintf("inittimeouts(%s)\n", val == NULL ? "<NULL>" : val);
d4088 1
d4107 7
d4116 29
a4144 16
			dprintf("Timeouts:\n");
			dprintf("  connect = %ld\n", (long)TimeOuts.to_connect);
			dprintf("  initial = %ld\n", (long)TimeOuts.to_initial);
			dprintf("  helo = %ld\n", (long)TimeOuts.to_helo);
			dprintf("  mail = %ld\n", (long)TimeOuts.to_mail);
			dprintf("  rcpt = %ld\n", (long)TimeOuts.to_rcpt);
			dprintf("  datainit = %ld\n", (long)TimeOuts.to_datainit);
			dprintf("  datablock = %ld\n", (long)TimeOuts.to_datablock);
			dprintf("  datafinal = %ld\n", (long)TimeOuts.to_datafinal);
			dprintf("  rset = %ld\n", (long)TimeOuts.to_rset);
			dprintf("  quit = %ld\n", (long)TimeOuts.to_quit);
			dprintf("  nextcommand = %ld\n", (long)TimeOuts.to_nextcommand);
			dprintf("  miscshort = %ld\n", (long)TimeOuts.to_miscshort);
			dprintf("  ident = %ld\n", (long)TimeOuts.to_ident);
			dprintf("  fileopen = %ld\n", (long)TimeOuts.to_fileopen);
			dprintf("  control = %ld\n", (long)TimeOuts.to_control);
@


1.7
log
@update to sendmail 8.11.5
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: readcf.c,v 8.382.4.42 2001/07/31 22:30:24 gshapiro Exp $";
d268 5
@


1.6
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: readcf.c,v 8.382.4.40 2001/05/03 17:24:13 gshapiro Exp $";
d3383 1
d3417 1
d3486 1
d3509 1
d3537 1
d3545 1
d3574 4
a3577 1
		setbitn(to->to_code, StickyTimeoutOpt);
@


1.5
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: readcf.c,v 8.382.4.38 2001/02/17 00:05:12 geir Exp $";
d151 1
a151 1
				free(bp);
d548 1
a548 1
			free(bp);
d1272 1
a1272 1
		free(s->s_mailer);
a1550 1
#if MIME8TO7
a1551 1
#endif /* MIME8TO7 */
d1899 1
a1900 1
	  case '8':		/* handling of 8-bit input */
d1937 3
a1940 1
#endif /* MIME8TO7 */
d2644 1
a2644 1
			free(PidFile);
d2691 1
a2691 1
			free(DeadLetterDrop);
d2781 1
a2781 1
			free(ControlSocketName);
d2795 1
a2795 1
			free(ProcTitlePrefix);
d2821 1
a2821 1
			free(SASLInfo);
d2827 1
a2827 1
			free(AuthMechanisms);
d2889 1
a2889 1
			free(SrvCERTfile);
d2895 1
a2895 1
			free(Srvkeyfile);
d2901 1
a2901 1
			free(CltCERTfile);
d2907 1
a2907 1
			free(Cltkeyfile);
d2913 1
a2913 1
			free(CACERTfile);
d2919 1
a2919 1
			free(CACERTpath);
d2925 1
a2925 1
			free(DHParams);
d2932 1
a2932 1
			free(DHParams5);
d2938 1
a2938 1
			free(CipherList);
d2945 1
a2945 1
			free(RandFile);
d3275 1
a3275 1
				free(RuleSetNames[ruleset]);
@


1.5.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: readcf.c,v 8.382.4.40 2001/05/03 17:24:13 gshapiro Exp $";
d151 1
a151 1
				sm_free(bp);
d548 1
a548 1
			sm_free(bp);
d1272 1
a1272 1
		sm_free(s->s_mailer);
d1551 1
d1553 1
d1901 1
a1902 1
#if MIME8TO7
d1939 1
a1939 2
#else /* MIME8TO7 */
		printf("Warning: Option EightBitMode requires MIME8TO7 support\n");
a1940 1
		break;
d2644 1
a2644 1
			sm_free(PidFile);
d2691 1
a2691 1
			sm_free(DeadLetterDrop);
d2781 1
a2781 1
			sm_free(ControlSocketName);
d2795 1
a2795 1
			sm_free(ProcTitlePrefix);
d2821 1
a2821 1
			sm_free(SASLInfo);
d2827 1
a2827 1
			sm_free(AuthMechanisms);
d2889 1
a2889 1
			sm_free(SrvCERTfile);
d2895 1
a2895 1
			sm_free(Srvkeyfile);
d2901 1
a2901 1
			sm_free(CltCERTfile);
d2907 1
a2907 1
			sm_free(Cltkeyfile);
d2913 1
a2913 1
			sm_free(CACERTfile);
d2919 1
a2919 1
			sm_free(CACERTpath);
d2925 1
a2925 1
			sm_free(DHParams);
d2932 1
a2932 1
			sm_free(DHParams5);
d2938 1
a2938 1
			sm_free(CipherList);
d2945 1
a2945 1
			sm_free(RandFile);
d3275 1
a3275 1
				sm_free(RuleSetNames[ruleset]);
@


1.4
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: readcf.c,v 8.382.4.31 2000/12/18 18:00:43 ca Exp $";
d847 2
d2064 1
d2066 1
d2101 7
d2262 1
d2264 1
d2565 1
d2567 1
@


1.3
log
@Fix non-exploitable buffer oflow in test mode.  Also add a line to uncomment
in sendmail/Makefile to cause sendmail to drop privs in test mode.
From sendmail+gshapiro@@SENDMAIL.ORG
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: readcf.c,v 8.382 2000/04/06 18:02:33 gshapiro Exp $";
d19 2
a33 3
#if _FFR_MILTER
static void	milter_setup __P((char *));
#endif /* _FFR_MILTER */
a97 1
	int chompflags;
d359 2
d366 1
a366 2
			chompflags = CHHDR_DEF;
			(void) chompheader(&bp[1], &chompflags, NULL, e);
d374 2
d404 2
d418 1
d420 3
d427 1
a427 2
				while (*p != '\0' && !(isascii(*p) && isspace(*p)))
					p++;
d777 1
a777 1
			syserr("fileclass: cannot open %s", filename);
a826 106
#if _FFR_MILTER
/*
**  MILTER_SETUP -- setup structure for a mail filter
**
**	Parameters:
**		line -- the options line.
**
**	Returns:
**		none
*/

static void
milter_setup(line)
	char *line;
{
	char fcode;
	register char *p;
	register struct milter *m;
	STAB *s;

	/* collect the mailer name */
	for (p = line;
	     *p != '\0' && *p != ',' && !(isascii(*p) && isspace(*p));
	     p++)
		continue;
	if (*p != '\0')
		*p++ = '\0';
	if (line[0] == '\0')
	{
		syserr("name required for mail filter");
		return;
	}
	m = (struct milter *)xalloc(sizeof *m);
	memset((char *) m, '\0', sizeof *m);
	m->mf_name = newstr(line);
	m->mf_state = SMFS_READY;
	m->mf_sock = -1;
	m->mf_timeout[SMFTO_WRITE] = (time_t) 10;
	m->mf_timeout[SMFTO_READ] = (time_t) 10;
	m->mf_timeout[SMFTO_EOM] = (time_t) 5 MINUTES;

	/* now scan through and assign info from the fields */
	while (*p != '\0')
	{
		char *delimptr;

		while (*p != '\0' &&
		       (*p == ',' || (isascii(*p) && isspace(*p))))
			p++;

		/* p now points to field code */
		fcode = *p;
		while (*p != '\0' && *p != '=' && *p != ',')
			p++;
		if (*p++ != '=')
		{
			syserr("X%s: `=' expected", m->mf_name);
			return;
		}
		while (isascii(*p) && isspace(*p))
			p++;

		/* p now points to the field body */
		p = munchstring(p, &delimptr, ',');

		/* install the field into the mailer struct */
		switch (fcode)
		{
		  case 'S':		/* socket */
			if (p == NULL)
				m->mf_conn = NULL;
			else
				m->mf_conn = newstr(p);

			/* early check for errors */
			(void) milter_open(m, TRUE, CurEnv);
			break;

		  case 'F':		/* Milter flags configured on MTA */
			for (; *p != '\0'; p++)
			{
				if (!(isascii(*p) && isspace(*p)))
					setbitn(*p, m->mf_flags);
			}
			break;

		  case 'T':		/* timeouts */
			milter_parse_timeouts(p, m);
			break;

		  default:
			syserr("X%s: unknown filter equate %c=",
			       m->mf_name, fcode);
			break;
		}
		p = delimptr;
	}

	/* enter the mailer into the symbol table */
	s = stab(m->mf_name, ST_MILTER, ST_ENTER);
	if (s->s_milter != NULL)
		syserr("X%s: duplicate filter definition", m->mf_name);
	else
		s->s_milter = m;
}
#endif /* _FFR_MILTER */
d878 1
d880 2
d913 2
a914 1
			m->m_mailer = newstr(p);
d920 1
a920 1
					setbitn(*p, m->m_flags);
d950 2
a951 1
			m->m_eol = newstr(p);
d958 2
a959 1
			m->m_argv = makeargv(p);
d970 6
d990 2
a991 1
			m->m_execdir = newstr(p);
d997 2
a998 1
			m->m_defcharset = newstr(p);
d1047 1
d1050 2
d1054 1
d1056 2
d1088 1
d1091 2
d1095 1
d1097 2
d1147 5
d1163 1
a1163 1
#if _FFR_REMOVE_TCP_PATH
d1166 2
a1167 1
#else /* _FFR_REMOVE_TCP_PATH */
d1170 1
a1170 1
#endif /* _FFR_REMOVE_TCP_PATH */
d1173 1
a1173 1
	if (strcmp(m->m_mailer, "[IPC]") == 0 ||
d1175 1
a1175 1
	    strcmp(m->m_mailer, "[TCP]") == 0
d1185 1
d1187 1
a1187 1
		if (strcmp(m->m_argv[0], "TCP") != 0 &&
d1189 1
a1189 1
		    strcmp(m->m_argv[0], "FILE") != 0 &&
d1192 1
a1192 1
		    strcmp(m->m_argv[0], "IPC") != 0
d1217 1
d1223 1
d1290 4
d1472 3
d1708 14
d1734 8
d1882 2
d1886 2
a1887 1
			(void) drop_privileges(TRUE);
d1989 1
d2149 1
d2151 2
a2156 1
		sticky = FALSE;
a2171 1
		{
a2172 1
		}
d2209 2
a2210 1
			PrivacyFlags |= pv->pv_flag;
d2225 1
d2227 1
d2229 1
d2231 1
d2297 1
d2299 2
d2313 2
a2314 1
				DefUid, UID_MAX);
d2363 1
d2579 1
d2581 2
d2595 2
a2596 1
				RunAsUid, UID_MAX);
d2722 1
d2724 2
d2734 1
a2734 1
				TrustedUid, UID_MAX);
d2820 1
a2820 1
		while (*val != '\0')
d2856 3
d2871 81
d3043 1
a3043 1
		if (mid == '\0')
d3057 1
a3057 1
		setbitn(((unsigned int)class) & 0xff, s->s_class);
d3255 1
a3255 1
		if (stabmode == ST_ENTER)
d3380 2
d3383 2
@


1.3.2.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: readcf.c,v 8.382.4.40 2001/05/03 17:24:13 gshapiro Exp $";
a18 2


d32 3
d99 1
d153 1
a153 1
				sm_free(bp);
a360 2
			if (mid == 0)
				break;
d366 2
a367 1
			(void) chompheader(&bp[1], CHHDR_DEF, NULL, e);
a374 2
				if (mid == 0)
					break;
a402 2
			if (mid == 0)
				break;
a414 1

a415 3
			q = p;
			while (*q != '\0' && !(isascii(*q) && isspace(*q)))
				q++;
d420 2
a421 1
				p = q;
d542 1
a542 1
			sm_free(bp);
d771 1
a771 1
			syserr("fileclass: cannot open '%s'", filename);
d821 106
a946 2
**			   m -- maximum messages per connection
**			   / -- new root directory
a977 1
	{
a978 2
		return;
	}
d1010 1
a1010 2
			else
				m->m_mailer = newstr(p);
d1016 1
a1016 1
					setbitn(bitidx(*p), m->m_flags);
d1046 1
a1046 2
			else
				m->m_eol = newstr(p);
d1053 1
a1053 2
			else
				m->m_argv = makeargv(p);
a1063 6
#if _FFR_DYNAMIC_TOBUF
		  case 'r':		/* max recipient per envelope */
			m->m_maxrcpt = atoi(p);
			break;
#endif /* _FFR_DYNAMIC_TOBUF */

d1078 1
a1078 2
			else
				m->m_execdir = newstr(p);
d1084 1
a1084 2
			else
				m->m_defcharset = newstr(p);
a1132 1
				{
a1134 2
					break;
				}
a1136 1
				{
a1137 2
					break;
				}
a1167 1
				{
a1169 2
					break;
				}
a1171 1
				{
a1172 2
					break;
				}
a1220 5
#if _FFR_DYNAMIC_TOBUF
	if (m->m_maxrcpt <= 0)
		m->m_maxrcpt = DEFAULT_MAX_RCPT;
#endif /* _FFR_DYNAMIC_TOBUF */

d1232 1
a1232 1
#if _FFR_REMOVE_TCP_MAILER_PATH
d1235 1
a1235 2
		return;
#else /* _FFR_REMOVE_TCP_MAILER_PATH */
d1238 1
a1238 1
#endif /* _FFR_REMOVE_TCP_MAILER_PATH */
d1241 1
a1241 1
	if (strcmp(m->m_mailer, "[IPC]") == 0
d1243 1
a1243 1
	    || strcmp(m->m_mailer, "[TCP]") == 0
a1252 1
			return;
d1254 1
a1254 1
		if (strcmp(m->m_argv[0], "TCP") != 0
d1256 1
a1256 1
		    && strcmp(m->m_argv[0], "FILE") != 0
d1259 1
a1259 1
		    && strcmp(m->m_argv[0], "IPC") != 0
a1283 1
			return;
a1288 1
			return;
d1335 1
a1335 1
		sm_free(s->s_mailer);
a1354 4
**
**	Side Effects:
**		the munched string is a local static buffer.
**		it must be copied before the function is called again.
a1532 3
#if _FFR_DYNAMIC_TOBUF
	printf(" r=%d", m->m_maxrcpt);
#endif /* _FFR_DYNAMIC_TOBUF */
d1607 1
d1609 1
a1765 14
# define O_SRVCERTFILE	0xb4
	{ "ServerCertFile",		O_SRVCERTFILE,	OI_NONE	},
# define O_SRVKEYFILE	0xb5
	{ "Serverkeyfile",		O_SRVKEYFILE,	OI_NONE	},
# define O_CLTCERTFILE	0xb6
	{ "ClientCertFile",		O_CLTCERTFILE,	OI_NONE	},
# define O_CLTKEYFILE	0xb7
	{ "Clientkeyfile",		O_CLTKEYFILE,	OI_NONE	},
# define O_CACERTFILE	0xb8
	{ "CACERTFile",			O_CACERTFILE,	OI_NONE	},
# define O_CACERTPATH	0xb9
	{ "CACERTPath",			O_CACERTPATH,	OI_NONE	},
# define O_DHPARAMS	0xba
	{ "DHParameters",		O_DHPARAMS,	OI_NONE	},
a1777 8
# if _FFR_TLS_1
# define O_DHPARAMS5	0xbf
	{ "DHParameters512",		O_DHPARAMS5,	OI_NONE	},
# define O_CIPHERLIST	0xc0
	{ "CipherList",			O_CIPHERLIST,	OI_NONE	},
# endif /* _FFR_TLS_1 */
# define O_RANDFILE	0xc1
	{ "RandFile",			O_RANDFILE,	OI_NONE	},
a1917 2
			int dp;

d1920 1
a1920 2
			dp = drop_privileges(TRUE);
			setstat(dp);
d1932 1
a1933 1
#if MIME8TO7
d1970 1
a1970 2
#else /* MIME8TO7 */
		printf("Warning: Option EightBitMode requires MIME8TO7 support\n");
a1971 1
		break;
a2021 1
			break;
a2093 1
		{
a2094 1
		}
a2128 7
#if _FFR_WORKAROUND_BROKEN_NAMESERVERS
			if (sm_strcasecmp(q, "WorkAroundBrokenAAAA") == 0)
			{
				WorkAroundBrokenAAAA = !clearmode;
				continue;
			}
#endif /* _FFR_WORKAROUND_BROKEN_NAMESERVERS */
a2180 1
		sticky = FALSE;
a2181 2
		if (mid == 0)
			break;
d2186 1
d2202 1
d2204 1
d2241 1
a2241 2
			else
				PrivacyFlags |= pv->pv_flag;
a2255 1
		{
a2256 1
		}
a2257 1
		{
a2258 1
		}
a2277 1
		{
a2278 1
		}
a2323 1
			{
a2324 2
				break;
			}
d2337 1
a2337 2
				(long) DefUid, (long) UID_MAX);
			break;
a2385 1

a2573 1
		{
a2574 1
		}
a2600 1
			{
a2601 2
				break;
			}
d2614 1
a2614 2
				(long) RunAsUid, (long) UID_MAX);
			break;
d2647 1
a2647 1
			sm_free(PidFile);
d2694 1
a2694 1
			sm_free(DeadLetterDrop);
a2739 1
			{
a2740 2
				break;
			}
d2749 1
a2749 1
				(long) TrustedUid, (long) UID_MAX);
d2781 1
a2781 1
			sm_free(ControlSocketName);
d2795 1
a2795 1
			sm_free(ProcTitlePrefix);
d2821 1
a2821 1
			sm_free(SASLInfo);
d2827 1
a2827 1
			sm_free(AuthMechanisms);
d2835 1
a2835 1
		while (val != NULL && *val != '\0')
a2870 3
			val = strpbrk(val, ", \t");
			if (val != NULL)
				++val;
a2882 81
#if STARTTLS
	  case O_SRVCERTFILE:
		if (SrvCERTfile != NULL)
			sm_free(SrvCERTfile);
		SrvCERTfile = newstr(val);
		break;

	  case O_SRVKEYFILE:
		if (Srvkeyfile != NULL)
			sm_free(Srvkeyfile);
		Srvkeyfile = newstr(val);
		break;

	  case O_CLTCERTFILE:
		if (CltCERTfile != NULL)
			sm_free(CltCERTfile);
		CltCERTfile = newstr(val);
		break;

	  case O_CLTKEYFILE:
		if (Cltkeyfile != NULL)
			sm_free(Cltkeyfile);
		Cltkeyfile = newstr(val);
		break;

	  case O_CACERTFILE:
		if (CACERTfile != NULL)
			sm_free(CACERTfile);
		CACERTfile = newstr(val);
		break;

	  case O_CACERTPATH:
		if (CACERTpath != NULL)
			sm_free(CACERTpath);
		CACERTpath = newstr(val);
		break;

	  case O_DHPARAMS:
		if (DHParams != NULL)
			sm_free(DHParams);
		DHParams = newstr(val);
		break;

#  if _FFR_TLS_1
	  case O_DHPARAMS5:
		if (DHParams5 != NULL)
			sm_free(DHParams5);
		DHParams5 = newstr(val);
		break;

	  case O_CIPHERLIST:
		if (CipherList != NULL)
			sm_free(CipherList);
		CipherList = newstr(val);
		break;
#  endif /* _FFR_TLS_1 */

	  case O_RANDFILE:
		if (RandFile != NULL)
			sm_free(RandFile);
		RandFile= newstr(val);
		break;

# else /* STARTTLS */
	  case O_SRVCERTFILE:
	  case O_SRVKEYFILE:
	  case O_CLTCERTFILE:
	  case O_CLTKEYFILE:
	  case O_CACERTFILE:
	  case O_CACERTPATH:
	  case O_DHPARAMS:
#  if _FFR_TLS_1
	  case O_DHPARAMS5:
	  case O_CIPHERLIST:
#  endif /* _FFR_TLS_1 */
	  case O_RANDFILE:
		printf("Warning: Option: %s requires TLS support\n",
			o->o_name == NULL ? "<unknown>" : o->o_name);
		break;

# endif /* STARTTLS */
d2974 1
a2974 1
		if (mid == 0)
d2988 1
a2988 1
		setbitn(bitidx(class), s->s_class);
d3186 1
a3186 1
		if (stabmode == ST_ENTER && ruleset >= 0)
d3191 1
a3191 1
				sm_free(RuleSetNames[ruleset]);
a3310 2
	{
		errno = 0; /* avoid bogus error text */
a3311 2
		return;
	}
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d2988 1
a2988 1
		setbitn(class, s->s_class);
@


1.2.2.1
log
@Pull in patch from current:
Errata:
There is a non-exploitable buffer overflow in sendmail's test mode.
Fix (millert):
Fix non-exploitable buffer oflow in test mode.  Also add a line to uncomment
in sendmail/Makefile to cause sendmail to drop privs in test mode.
From sendmail+gshapiro@@SENDMAIL.ORG
@
text
@d2988 1
a2988 1
		setbitn(((unsigned int)class) & 0xff, s->s_class);
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: readcf.c,v 8.380 2000/02/16 00:44:17 ca Exp $";
d2835 1
a2835 1
		if (*val == '\0')
d2837 34
a2870 3
			printf("Warning: Option: %s requires parameter(s)\n",
				o->o_name == NULL ? "<unknown>" : o->o_name);
			break;
a2871 6
		if (*val == 'A' || *val == 'a')
			SASLTryAuth = SASL_AUTH_AUTH;
		else
			printf("Warning: Option: %s unknown parameter '%c'\n",
				o->o_name == NULL ? "<unknown>" : o->o_name,
				(isascii(*val) && isprint(*val)) ? *val : '?');
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Id: readcf.c,v 8.382.4.31 2000/12/18 18:00:43 ca Exp $";
a18 2


d32 3
d99 1
a360 2
			if (mid == 0)
				break;
d366 2
a367 1
			(void) chompheader(&bp[1], CHHDR_DEF, NULL, e);
a374 2
				if (mid == 0)
					break;
a402 2
			if (mid == 0)
				break;
a414 1

a415 3
			q = p;
			while (*q != '\0' && !(isascii(*q) && isspace(*q)))
				q++;
d420 2
a421 1
				p = q;
d771 1
a771 1
			syserr("fileclass: cannot open '%s'", filename);
d821 106
a977 1
	{
a978 2
		return;
	}
d1010 1
a1010 2
			else
				m->m_mailer = newstr(p);
d1016 1
a1016 1
					setbitn(bitidx(*p), m->m_flags);
d1046 1
a1046 2
			else
				m->m_eol = newstr(p);
d1053 1
a1053 2
			else
				m->m_argv = makeargv(p);
a1063 6
#if _FFR_DYNAMIC_TOBUF
		  case 'r':		/* max recipient per envelope */
			m->m_maxrcpt = atoi(p);
			break;
#endif /* _FFR_DYNAMIC_TOBUF */

d1078 1
a1078 2
			else
				m->m_execdir = newstr(p);
d1084 1
a1084 2
			else
				m->m_defcharset = newstr(p);
a1132 1
				{
a1134 2
					break;
				}
a1136 1
				{
a1137 2
					break;
				}
a1167 1
				{
a1169 2
					break;
				}
a1171 1
				{
a1172 2
					break;
				}
a1220 5
#if _FFR_DYNAMIC_TOBUF
	if (m->m_maxrcpt <= 0)
		m->m_maxrcpt = DEFAULT_MAX_RCPT;
#endif /* _FFR_DYNAMIC_TOBUF */

d1232 1
a1232 1
#if _FFR_REMOVE_TCP_MAILER_PATH
d1235 1
a1235 2
		return;
#else /* _FFR_REMOVE_TCP_MAILER_PATH */
d1238 1
a1238 1
#endif /* _FFR_REMOVE_TCP_MAILER_PATH */
d1241 1
a1241 1
	if (strcmp(m->m_mailer, "[IPC]") == 0
d1243 1
a1243 1
	    || strcmp(m->m_mailer, "[TCP]") == 0
a1252 1
			return;
d1254 1
a1254 1
		if (strcmp(m->m_argv[0], "TCP") != 0
d1256 1
a1256 1
		    && strcmp(m->m_argv[0], "FILE") != 0
d1259 1
a1259 1
		    && strcmp(m->m_argv[0], "IPC") != 0
a1283 1
			return;
a1288 1
			return;
a1354 4
**
**	Side Effects:
**		the munched string is a local static buffer.
**		it must be copied before the function is called again.
a1532 3
#if _FFR_DYNAMIC_TOBUF
	printf(" r=%d", m->m_maxrcpt);
#endif /* _FFR_DYNAMIC_TOBUF */
a1765 14
# define O_SRVCERTFILE	0xb4
	{ "ServerCertFile",		O_SRVCERTFILE,	OI_NONE	},
# define O_SRVKEYFILE	0xb5
	{ "Serverkeyfile",		O_SRVKEYFILE,	OI_NONE	},
# define O_CLTCERTFILE	0xb6
	{ "ClientCertFile",		O_CLTCERTFILE,	OI_NONE	},
# define O_CLTKEYFILE	0xb7
	{ "Clientkeyfile",		O_CLTKEYFILE,	OI_NONE	},
# define O_CACERTFILE	0xb8
	{ "CACERTFile",			O_CACERTFILE,	OI_NONE	},
# define O_CACERTPATH	0xb9
	{ "CACERTPath",			O_CACERTPATH,	OI_NONE	},
# define O_DHPARAMS	0xba
	{ "DHParameters",		O_DHPARAMS,	OI_NONE	},
a1777 8
# if _FFR_TLS_1
# define O_DHPARAMS5	0xbf
	{ "DHParameters512",		O_DHPARAMS5,	OI_NONE	},
# define O_CIPHERLIST	0xc0
	{ "CipherList",			O_CIPHERLIST,	OI_NONE	},
# endif /* _FFR_TLS_1 */
# define O_RANDFILE	0xc1
	{ "RandFile",			O_RANDFILE,	OI_NONE	},
a1917 2
			int dp;

d1920 1
a1920 2
			dp = drop_privileges(TRUE);
			setstat(dp);
a2021 1
			break;
a2180 1
		sticky = FALSE;
a2181 2
		if (mid == 0)
			break;
d2186 1
d2202 1
d2204 1
d2241 1
a2241 2
			else
				PrivacyFlags |= pv->pv_flag;
a2255 1
		{
a2256 1
		}
a2257 1
		{
a2258 1
		}
a2323 1
			{
a2324 2
				break;
			}
d2337 1
a2337 2
				(long) DefUid, (long) UID_MAX);
			break;
a2385 1

a2600 1
			{
a2601 2
				break;
			}
d2614 1
a2614 2
				(long) RunAsUid, (long) UID_MAX);
			break;
a2739 1
			{
a2740 2
				break;
			}
d2749 1
a2749 1
				(long) TrustedUid, (long) UID_MAX);
d2835 1
a2835 1
		while (val != NULL && *val != '\0')
d2837 3
a2839 37
			switch(*val)
			{
			  case 'A':
				SASLOpts |= SASL_AUTH_AUTH;
				break;
# if _FFR_SASL_OPTS
			  case 'a':
				SASLOpts |= SASL_SEC_NOACTIVE;
				break;
			  case 'c':
				SASLOpts |= SASL_SEC_PASS_CREDENTIALS;
				break;
			  case 'd':
				SASLOpts |= SASL_SEC_NODICTIONARY;
				break;
			  case 'f':
				SASLOpts |= SASL_SEC_FORWARD_SECRECY;
				break;
			  case 'p':
				SASLOpts |= SASL_SEC_NOPLAINTEXT;
				break;
			  case 'y':
				SASLOpts |= SASL_SEC_NOANONYMOUS;
				break;
# endif /* _FFR_SASL_OPTS */
			  default:
				printf("Warning: Option: %s unknown parameter '%c'\n",
					o->o_name == NULL ? "<unknown>"
							  : o->o_name,
					(isascii(*val) && isprint(*val)) ? *val
									 : '?');
				break;
			}
			++val;
			val = strpbrk(val, ", \t");
			if (val != NULL)
				++val;
d2841 6
a2857 81
#if STARTTLS
	  case O_SRVCERTFILE:
		if (SrvCERTfile != NULL)
			free(SrvCERTfile);
		SrvCERTfile = newstr(val);
		break;

	  case O_SRVKEYFILE:
		if (Srvkeyfile != NULL)
			free(Srvkeyfile);
		Srvkeyfile = newstr(val);
		break;

	  case O_CLTCERTFILE:
		if (CltCERTfile != NULL)
			free(CltCERTfile);
		CltCERTfile = newstr(val);
		break;

	  case O_CLTKEYFILE:
		if (Cltkeyfile != NULL)
			free(Cltkeyfile);
		Cltkeyfile = newstr(val);
		break;

	  case O_CACERTFILE:
		if (CACERTfile != NULL)
			free(CACERTfile);
		CACERTfile = newstr(val);
		break;

	  case O_CACERTPATH:
		if (CACERTpath != NULL)
			free(CACERTpath);
		CACERTpath = newstr(val);
		break;

	  case O_DHPARAMS:
		if (DHParams != NULL)
			free(DHParams);
		DHParams = newstr(val);
		break;

#  if _FFR_TLS_1
	  case O_DHPARAMS5:
		if (DHParams5 != NULL)
			free(DHParams5);
		DHParams5 = newstr(val);
		break;

	  case O_CIPHERLIST:
		if (CipherList != NULL)
			free(CipherList);
		CipherList = newstr(val);
		break;
#  endif /* _FFR_TLS_1 */

	  case O_RANDFILE:
		if (RandFile != NULL)
			free(RandFile);
		RandFile= newstr(val);
		break;

# else /* STARTTLS */
	  case O_SRVCERTFILE:
	  case O_SRVKEYFILE:
	  case O_CLTCERTFILE:
	  case O_CLTKEYFILE:
	  case O_CACERTFILE:
	  case O_CACERTPATH:
	  case O_DHPARAMS:
#  if _FFR_TLS_1
	  case O_DHPARAMS5:
	  case O_CIPHERLIST:
#  endif /* _FFR_TLS_1 */
	  case O_RANDFILE:
		printf("Warning: Option: %s requires TLS support\n",
			o->o_name == NULL ? "<unknown>" : o->o_name);
		break;

# endif /* STARTTLS */
d2949 1
a2949 1
		if (mid == 0)
d2963 1
a2963 1
		setbitn(bitidx(class), s->s_class);
d3161 1
a3161 1
		if (stabmode == ST_ENTER && ruleset >= 0)
a3285 2
	{
		errno = 0; /* avoid bogus error text */
a3286 2
		return;
	}
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d14 4
a19 1
SM_RCSID("@@(#)$Sendmail: readcf.c,v 8.582 2001/09/04 22:43:05 ca Exp $")
a33 1
static char	*extrquotstr __P((char *, char **, char *, bool *));
a59 1
**		O option value	Set option (long name) to value.
a60 2
**		Qn arg=val...	Define queue groups.  n is the internal name.
**				Args specify queue parameters.
d71 2
a72 2
**		safe -- true if this is the system config file;
**			false otherwise.
d88 1
a88 1
	SM_FILE_T *cf;
a96 1
	bool ok;
d105 1
a105 1
	extern unsigned char TokTypeNoC[];
d116 1
a116 1
		finis(false, EX_OSFILE);
d119 1
a119 1
	if (fstat(sm_io_getinfo(cf, SM_IO_WHAT_FD, NULL), &statb) < 0)
d122 1
a122 1
		finis(false, EX_OSFILE);
d128 1
a128 1
		finis(false, EX_OSFILE);
d134 2
a135 3
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
					     "%s: WARNING: dangerous write permissions\n",
					     FileName);
d142 1
a142 1
#if XLA
d151 1
a151 1
				sm_free(bp); /* XXX */
d205 1
a205 1
				rwp->r_lhs = copyplist(rwp->r_lhs, true, NULL);
a269 5
			if (nfuzzy > MAXMATCH)
			{
				syserr("R line: too many wildcards");
				rwp->r_lhs = null_list;
			}
d286 1
a286 1
				rwp->r_rhs = copyplist(rwp->r_rhs, true, NULL);
a323 30

#if 0
/*
**  This doesn't work yet as there are maps defined *after* the cf
**  is read such as host, user, and alias.  So for now, it's removed.
**  When it comes back, the RELEASE_NOTES entry will be:
**	Emit warnings for unknown maps when reading the .cf file.  Based on
**		patch from Robert Harker of Harker Systems.
*/

					  case LOOKUPBEGIN:
						/*
						**  Got a database lookup,
						**  check if map is defined.
						*/

						ep = *(ap + 1);
						if ((*ep & 0377) != MACRODEXPAND &&
						    stab(ep, ST_MAP,
							 ST_FIND) == NULL)
						{
							(void) sm_io_fprintf(smioout,
									     SM_TIME_DEFAULT,
									     "Warning: %s: line %d: map %s not found\n",
									     FileName,
									     LineNumber,
									     ep);
						}
						break;
#endif /* 0 */
d347 2
a348 4
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "WARNING: Ruleset %s has multiple definitions\n",
							    &bp[1]);
d350 2
a351 2
					sm_dprintf("WARNING: Ruleset %s has multiple definitions\n",
						   &bp[1]);
d358 1
a358 1
			mid = macid_parse(&bp[1], &ep);
d362 1
a362 1
			macdefine(&e->e_macro, A_TEMP, mid, p);
d373 1
a373 1
				mid = macid_parse(&bp[1], &ep);
d403 1
a403 1
			mid = macid_parse(&bp[1], &ep);
d410 2
a411 3
				optional = true;
				while (*p != '\0' &&
				       !(isascii(*p) && isspace(*p)))
a414 1
				file = p;
d417 1
a417 1
				optional = false;
d419 5
a423 16
			if (*p == '@@')
			{
				/* use entire spec */
				file = p;
			}
			else
			{
				file = extrquotstr(p, &q, " ", &ok);
				if (!ok)
				{
					syserr("illegal filename '%s'", p);
					break;
				}
			}

			if (*file == '|' || *file == '@@')
d440 1
a440 1
#if XLA
d461 1
a461 1
			setoption(bp[1], &bp[2], safe, false, e);
a479 4
		  case 'Q':		/* define queue */
			makequeue(&bp[1], true);
			break;

a499 1
				{
d501 1
a501 3
					macdefine(&e->e_macro, A_TEMP, 'w',
						  macvalue('w', e));
				}
d505 1
a505 1
				ColonOkInAddr = false;
d537 1
a538 1
#if MILTER
a539 4
#else /* MILTER */
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Warning: Filter usage ('X') requires Milter support (-DMILTER)\n");
#endif /* MILTER */
d541 1
d548 1
a548 1
			sm_free(bp); /* XXX */
d550 1
a550 1
	if (sm_io_error(cf))
d553 1
a553 1
		finis(false, EX_OSFILE);
d555 1
a555 1
	(void) sm_io_close(cf, SM_TIME_DEFAULT);
d571 1
a571 1
		UseNameServer = false;
d576 1
a576 2
			for (mapno = 0; mapno < nmaps && !UseNameServer;
			     mapno++)
d579 15
a593 1
					UseNameServer = true;
d596 1
d625 1
d637 1
a637 1
				(void) sm_strlcpy(p, p + 1, strlen(p));
d646 1
a646 1
					(void) sm_strlcpy(p, e, strlen(p));
d660 1
a660 1
			(void) sm_strlcpy(p, p + 1, strlen(p));
d672 1
a672 1
		*p = macid_parse(p, &ep);
d674 1
a674 1
			(void) sm_strlcpy(p + 1, ep, strlen(p + 1));
d717 1
a721 31
/*
**  Break up the match into words and add to class.
*/

static void
parse_class_words(class, line)
	int class;
	char *line;
{
	while (line != NULL && *line != '\0')
	{
		register char *q;

		/* strip leading spaces */
		while (isascii(*line) && isspace(*line))
			line++;
		if (*line == '\0')
			break;

		/* find the end of the word */
		q = line;
		while (*line != '\0' && !(isascii(*line) && isspace(*line)))
			line++;
		if (*line != '\0')
			*line++ = '\0';

		/* enter the word in the symbol table */
		setclass(class, q);
	}
}

d730 1
a730 1
	SM_FILE_T *f;
d737 1
a737 123
		sm_dprintf("fileclass(%s, fmt=%s)\n", filename, fmt);

	if (*filename == '\0')
	{
		syserr("fileclass: missing file name");
		return;
	}
	else if (!SM_IS_DIR_DELIM(*filename) && *filename != '|' &&
		 (p = strchr(filename, '@@')) != NULL)
	{
		int status = 0;
		char *key;
		char *mn;
		char *cl, *spec;
		STAB *mapclass;
		MAP map;

		mn = newstr(macname(class));

		key = filename;

		/* skip past '@@' */
		*p++ = '\0';
		cl = p;

		if (strcmp(cl, "LDAP") == 0)
		{
			int n;
			char *lc;
			char jbuf[MAXHOSTNAMELEN];
			char lcbuf[MAXLINE];

			/* Get $j */
			expand("\201j", jbuf, sizeof jbuf, &BlankEnvelope);
			if (jbuf[0] == '\0')
			{
				(void) sm_strlcpy(jbuf, "localhost",
						  sizeof jbuf);
			}

			/* impose the default schema */
			lc = macvalue(macid("{sendmailMTACluster}"), CurEnv);
			if (lc == NULL)
				lc = "";
			else
			{
				expand(lc, lcbuf, sizeof lcbuf, CurEnv);
				lc = lcbuf;
			}

			cl = "ldap";
			n = sm_snprintf(buf, sizeof buf,
					"-k (&(objectClass=sendmailMTAClass)(sendmailMTAClassName=%s)(|(sendmailMTACluster=%s)(sendmailMTAHost=%s))) -v sendmailMTAClassValue",
					mn, lc, jbuf);
			if (n >= sizeof buf)
			{
				syserr("fileclass: F{%s}: Default LDAP string too long",
				       mn);
				sm_free(mn);
				return;
			}
			spec = buf;
		}
		else
		{
			if ((spec = strchr(cl, ':')) == NULL)
			{
				syserr("fileclass: F{%s}: missing map class",
				       mn);
				sm_free(mn);
				return;
			}
			*spec++ ='\0';
		}

		/* set up map structure */
		mapclass = stab(cl, ST_MAPCLASS, ST_FIND);
		if (mapclass == NULL)
		{
			syserr("fileclass: F{%s}: class %s not available",
			       mn, cl);
			sm_free(mn);
			return;
		}
		memset(&map, '\0', sizeof map);
		map.map_class = &mapclass->s_mapclass;
		map.map_mname = mn;
		map.map_mflags |= MF_FILECLASS;

		/* parse map spec */
		if (!map.map_class->map_parse(&map, spec))
		{
			/* map_parse() showed the error already */
			sm_free(mn);
			return;
		}
		map.map_mflags |= MF_VALID;

		/* open map */
		if (map.map_class->map_open(&map, O_RDONLY))
		{
			map.map_mflags |= MF_OPEN;
			map.map_pid = getpid();
		}
		else
		{
			if (!optional &&
			    !bitset(MF_OPTIONAL, map.map_mflags))
				syserr("fileclass: F{%s}: map open failed",
				       mn);
			sm_free(mn);
			return;
		}

		/* lookup */
		p = (*map.map_class->map_lookup)(&map, key, NULL, &status);
		if (status != EX_OK && status != EX_NOTFOUND)
		{
			if (!optional)
				syserr("fileclass: F{%s}: map lookup failed",
				       mn);
			p = NULL;
		}
d739 1
a739 12
		/* use the results */
		if (p != NULL)
			parse_class_words(class, p);

		/* close map */
		map.map_mflags |= MF_CLOSING;
		map.map_class->map_close(&map);
		map.map_mflags &= ~(MF_OPEN|MF_WRITABLE|MF_CLOSING);
		sm_free(mn);
		return;
	}
	else if (filename[0] == '|')
d746 4
a749 3
		for (p = strtok(&filename[1], " \t");
		     p != NULL && i < MAXPV;
		     p = strtok(NULL, " \t"))
d751 1
d757 1
a757 2
			f = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT,
				       (void *) fd, SM_IO_RDONLY, NULL);
d781 1
a781 1
	while (sm_io_fgets(f, SM_TIME_DEFAULT, buf, sizeof buf) != NULL)
d790 1
a790 1
		if (sm_io_sscanf(buf, fmt, wordbuf) != 1)
a796 2
		parse_class_words(class, p);

d798 1
a798 3
		**  If anything else is added here,
		**  check if the '@@' map case above
		**  needs the code as well.
d800 21
d823 1
a823 1
	(void) sm_io_close(f, SM_TIME_DEFAULT);
a841 1
**			   Q -- the queue group for the mailer
a846 3
**			   m -- maximum messages per connection
**			   r -- maximum number of recipients per message
**			   / -- new root directory
d866 1
a866 1
	static int nextmailer = 0;	/* "free" index into Mailer struct */
a870 1
	errno = 0; /* avoid bogus error text */
d873 1
a873 3
	for (p = line;
	     *p != '\0' && *p != ',' && !(isascii(*p) && isspace(*p));
	     p++)
d889 1
a889 2
		while (*p != '\0' &&
		       (*p == ',' || (isascii(*p) && isspace(*p))))
d911 3
a913 1
			if (*p != '\0')	/* error is issued below */
a918 1
			{
a919 7
				{
#if _FFR_DEPRECATE_MAILER_FLAG_I
					if (*p == M_INTERNAL)
						sm_syslog(LOG_WARNING, NOQID,
							  "WARNING: mailer=%s, flag=%c deprecated",
							  m->m_name, *p);
#endif /* _FFR_DEPRECATE_MAILER_FLAG_I */
a920 2
				}
			}
d955 4
a958 1
			if (*p != '\0')	/* error is issued below */
d970 1
d974 1
a1000 14
		  case 'Q':		/* queue for this mailer */
			if (*p == '\0')
			{
				syserr("mailer %s: null queue", m->m_name);
				break;
			}
			s = stab(p, ST_QUEUE, ST_FIND);
			if (s == NULL)
				syserr("mailer %s: unknown queue %s",
					m->m_name, p);
			else
				m->m_qgrp = s->s_quegrp->qg_index;
			break;

d1141 1
a1141 1
	if (nextmailer >= MAXMAILERS)
d1147 1
d1150 1
d1163 2
a1164 1
		syserr("M%s: P=[TCP] must be replaced by P=[IPC]\n",
d1167 4
d1173 5
a1177 1
	if (strcmp(m->m_mailer, "[IPC]") == 0)
d1191 3
d1196 2
a1197 3
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "M%s: Warning: first argument in %s mailer must be %s\n",
					     m->m_name, m->m_mailer,
d1199 1
a1199 1
					     "TCP or FILE"
d1201 1
a1201 1
					     "TCP"
d1203 1
a1203 13
				     );
		}
		if (m->m_mtatype == NULL)
			m->m_mtatype = "dns";
		if (m->m_addrtype == NULL)
			m->m_addrtype = "rfc822";
		if (m->m_diagtype == NULL)
		{
			if (m->m_argv[0] != NULL &&
			    strcmp(m->m_argv[0], "FILE") == 0)
				m->m_diagtype = "x-unix";
			else
				m->m_diagtype = "smtp";
d1205 1
d1227 17
d1270 1
a1270 1
		sm_free(s->s_mailer); /* XXX */
d1274 1
a1274 1
		i = nextmailer++;
d1303 2
a1304 2
	bool backslash = false;
	bool quotemode = false;
d1312 1
a1312 1
			backslash = false;
d1336 1
a1336 1
				backslash = true;
a1351 60
**  EXTRQUOTSTR -- extract a (quoted) string.
**
**	This routine deals with quoted (") strings and escaped
**	spaces (\\ ).
**
**	Parameters:
**		p -- source string.
**		delimptr -- if non-NULL, set to the pointer of the
**			field delimiter character.
**		delimbuf -- delimiters for the field.
**		st -- if non-NULL, store the return value (whether the
**			string was correctly quoted) here.
**
**	Returns:
**		the extracted string.
**
**	Side Effects:
**		the returned string is a local static buffer.
**		it must be copied before the function is called again.
*/

static char *
extrquotstr(p, delimptr, delimbuf, st)
	register char *p;
	char **delimptr;
	char *delimbuf;
	bool *st;
{
	register char *q;
	bool backslash = false;
	bool quotemode = false;
	static char buf[MAXLINE];

	for (q = buf; *p != '\0' && q < &buf[sizeof buf - 1]; p++)
	{
		if (backslash)
		{
			backslash = false;
			if (*p != ' ')
				*q++ = '\\';
		}
		if (*p == '\\')
			backslash = true;
		else if (*p == '"')
			quotemode = !quotemode;
		else if (quotemode ||
			 strchr(delimbuf, (int) *p) == NULL)
			*q++ = *p;
		else
			break;
	}

	if (delimptr != NULL)
		*delimptr = p;
	*q++ = '\0';
	if (st != NULL)
		*st = !(quotemode || backslash);
	return buf;
}
/*
d1415 1
a1415 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "\n----Rule Set %d:", ruleset);
d1419 1
a1419 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "\nLHS:");
d1421 1
a1421 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "RHS:");
d1442 1
a1442 3
	(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
			     "mailer %d (%s): P=%s S=", m->m_mno, m->m_name,
			     m->m_mailer);
d1444 1
a1444 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%d/",
				     m->m_se_rwset);
d1446 1
a1446 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s/",
				     RuleSetNames[m->m_se_rwset]);
d1448 1
a1448 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%d R=",
				     m->m_sh_rwset);
d1450 1
a1450 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s R=",
				     RuleSetNames[m->m_sh_rwset]);
d1452 1
a1452 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%d/",
				     m->m_re_rwset);
d1454 1
a1454 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s/",
				     RuleSetNames[m->m_re_rwset]);
d1456 1
a1456 2
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%d ",
				     m->m_rh_rwset);
d1458 3
a1460 4
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%s ",
				     RuleSetNames[m->m_rh_rwset]);
	(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "M=%ld U=%d:%d F=",
			     m->m_maxsize, (int) m->m_uid, (int) m->m_gid);
d1463 2
a1464 3
			(void) sm_io_putc(smioout, SM_TIME_DEFAULT, j);
	(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, " L=%d E=",
			     m->m_linelimit);
d1467 8
a1474 10
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, " C=%s",
				     m->m_defcharset);
	(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, " T=%s/%s/%s",
			     m->m_mtatype == NULL
				? "<undefined>" : m->m_mtatype,
			     m->m_addrtype == NULL
				? "<undefined>" : m->m_addrtype,
			     m->m_diagtype == NULL
				? "<undefined>" : m->m_diagtype);
	(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, " r=%d", m->m_maxrcpt);
d1479 1
a1479 1
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, " A=");
d1483 1
a1483 2
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     " ");
d1487 1
a1487 1
	(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "\n");
a1527 3
# ifdef RES_USE_INET6
	{ "use_inet6",	RES_USE_INET6	},
# endif /* RES_USE_INET6 */
d1540 3
a1542 3
	char		*o_name;	/* long name of option */
	unsigned char	o_code;		/* short name of option */
	unsigned short	o_flags;	/* option flags */
d1549 1
d1551 1
d1558 3
d1702 1
a1702 1
#define O_LDAPDEFAULTSPEC	0xb2
d1705 1
a1705 1
# define O_QUEUEDELAY	0xb3
d1708 1
a1708 1
#define O_SRVCERTFILE	0xb4
d1710 1
a1710 1
#define O_SRVKEYFILE	0xb5
d1712 1
a1712 1
#define O_CLTCERTFILE	0xb6
d1714 1
a1714 1
#define O_CLTKEYFILE	0xb7
d1716 1
a1716 1
#define O_CACERTFILE	0xb8
d1718 1
a1718 1
#define O_CACERTPATH	0xb9
d1720 1
a1720 1
#define O_DHPARAMS	0xba
d1722 1
d1727 1
d1730 1
d1733 2
a1734 1
#if _FFR_TLS_1
d1739 2
a1740 2
#endif /* _FFR_TLS_1 */
#define O_RANDFILE	0xc1
a1741 30
#define O_TLS_SRV_OPTS	0xc2
	{ "TLSSrvOptions",		O_TLS_SRV_OPTS,	OI_NONE	},
#define O_RCPTTHROT	0xc3
	{ "BadRcptThrottle",		O_RCPTTHROT,	OI_SAFE	},
#define O_DLVR_MIN	0xc4
	{ "DeliverByMin",		O_DLVR_MIN,	OI_NONE	},
#define O_MAXQUEUECHILDREN	0xc5
	{ "MaxQueueChildren",		O_MAXQUEUECHILDREN,	OI_NONE	},
#define O_MAXRUNNERSPERQUEUE	0xc6
	{ "MaxRunnersPerQueue",		O_MAXRUNNERSPERQUEUE,	OI_NONE },
#define O_DIRECTSUBMODIFIERS	0xc7
	{ "DirectSubmissionModifiers",	O_DIRECTSUBMODIFIERS,	OI_NONE },
#define O_NICEQUEUERUN	0xc8
	{ "NiceQueueRun",		O_NICEQUEUERUN,	OI_NONE	},
#define O_SHMKEY	0xc9
	{ "SharedMemoryKey",		O_SHMKEY,	OI_NONE	},
#define O_SASLBITS	0xca
	{ "AuthMaxBits",		O_SASLBITS,	OI_NONE	},
#define O_MBDB		0xcb
	{ "MailboxDatabase",		O_MBDB,		OI_NONE	},
#define O_MSQ		0xcc
	{ "UseMSP",	O_MSQ,		OI_NONE	},
#define O_DELAY_LA	0xcd
	{ "DelayLA",	O_DELAY_LA,	OI_NONE	},
#define O_FASTSPLIT	0xce
	{ "FastSplit",	O_FASTSPLIT,	OI_NONE	},
#if _FFR_SOFT_BOUNCE
# define O_SOFTBOUNCE	0xcf
	{ "SoftBounce",	O_SOFTBOUNCE,	OI_NONE	},
#endif /* _FFR_SOFT_BOUNCE */
a1744 17
# define CANONIFY(val)

# define SET_OPT_DEFAULT(opt, val)	opt = val

/* set a string option by expanding the value and assigning it */
/* WARNING this belongs ONLY into a case statement! */
#define SET_STRING_EXP(str)	\
		expand(val, exbuf, sizeof exbuf, e);	\
		newval = sm_pstrdup_x(exbuf);		\
		if (str != NULL)	\
			sm_free(str);	\
		CANONIFY(newval);	\
		str = newval;		\
		break

#define OPTNAME	o->o_name == NULL ? "<unknown>" : o->o_name

d1762 1
a1762 1
	extern unsigned int SubmitMode;
a1763 4
#if STARTTLS
	char *newval;
	char exbuf[MAXLINE];
#endif /* STARTTLS */
d1793 1
a1793 1
			if (sm_strncasecmp(o->o_name, val, strlen(val)) != 0)
d1843 3
a1845 2
			sm_dprintf("setoption: %s does not support suboptions, ignoring .%s\n",
				   OPTNAME, subopt);
d1851 7
a1857 5
		sm_dprintf(isascii(opt) && isprint(opt) ?
			   "setoption %s (%c)%s%s=" :
			   "setoption %s (0x%x)%s%s=",
			   OPTNAME, opt, subopt == NULL ? "" : ".",
			   subopt == NULL ? "" : subopt);
d1868 1
a1868 1
			sm_dprintf(" (ignored)\n");
d1877 1
a1877 1
		safe = true;
d1885 2
a1886 2
				sm_dprintf(" (unsafe)");
			dp = drop_privileges(true);
d1891 1
a1891 1
		sm_dprintf("\n");
d1899 1
a1900 1
#if MIME8TO7
d1903 4
a1910 4
		  case 'm':		/* convert 8-bit, convert MIME */
			MimeMode = MM_CVTMIME|MM_MIME8BIT;
			break;

d1935 1
a1935 1
			finis(false, EX_USAGE);
d1937 1
a1937 4
#else /* MIME8TO7 */
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: Option: %s requires MIME8TO7 support\n",
				     OPTNAME);
a1938 1
		break;
d1942 1
a1942 6
		{
			char *al;

			SET_OPT_DEFAULT(al, "aliases");
			setalias(al);
		}
d1949 1
a1949 1
			SafeAlias = 5 MINUTES;
d1987 6
d2000 1
a2000 1
			finis(false, EX_USAGE);
d2004 6
d2060 1
a2060 3
		{
			SET_OPT_DEFAULT(HelpFile, "helpfile");
		}
a2061 2
		{
			CANONIFY(val);
a2062 1
		}
d2081 1
a2081 1
			clearmode = false;
d2083 1
a2083 1
				clearmode = true;
d2092 1
a2092 1
			if (sm_strcasecmp(q, "HasWildcardMX") == 0)
a2096 5
			if (sm_strcasecmp(q, "WorkAroundBrokenAAAA") == 0)
			{
				WorkAroundBrokenAAAA = !clearmode;
				continue;
			}
d2099 1
a2099 1
				if (sm_strcasecmp(q, rfp->rf_name) == 0)
d2110 2
a2111 2
			sm_dprintf("_res.options = %x, HasWildcardMX = %d\n",
				   (unsigned int) _res.options, HasWildcardMX);
a2125 1
		CANONIFY(val);
d2149 2
a2150 2
		sticky = false;
		mid = macid_parse(val, &ep);
d2156 1
a2156 1
		macdefine(&CurEnv->e_macro, A_TEMP, mid, p);
d2170 1
d2173 3
d2204 1
a2204 1
				if (sm_strcasecmp(val, pv->pv_name) == 0)
d2212 1
a2212 1
		sticky = false;
d2233 1
a2233 1
			Warn_Q_option = true;
d2249 1
a2249 3
		{
			SET_OPT_DEFAULT(StatFile, "statistics");
		}
a2250 2
		{
			CANONIFY(val);
a2251 1
		}
d2255 1
a2255 4
		if (tolower(*val) == 'i')
			SuperSafe = SAFE_INTERACTIVE;
		else
			SuperSafe = atobool(val) ? SAFE_REALLY : SAFE_NO;
d2309 1
a2309 1
# ifdef UID_MAX
d2313 1
a2313 1
				(long)DefUid, (long)UID_MAX);
d2316 1
a2316 1
# endif /* UID_MAX */
d2343 1
a2343 1
	  case 'X':	/* load avg at which to auto-reject connections */
a2346 4
	  case O_DELAY_LA:	/* load avg at which to delay connections */
		DelayLA = atoi(val);
		break;

a2366 5
		  case 'f':	/* File Name */
		  case 'F':
			QueueSortOrder = QSO_BYFILENAME;
			break;

a2371 5
		  case 'm':	/* Modification time */
		  case 'M':
			QueueSortOrder = QSO_BYMODTIME;
			break;

d2382 3
a2384 9
		  case 'r':	/* Random */
		  case 'R':
			QueueSortOrder = QSO_RANDOM;
			break;

#if _FFR_RHS
		  case 's':	/* Shuffled host name */
		  case 'S':
			QueueSortOrder = QSO_BYSHUFFLE;
a2385 1
#endif /* _FFR_RHS */
a2429 1
		CANONIFY(val);
d2438 1
a2438 1
		DefaultCharSet = newstr(denlstring(val, true, true));
a2441 1
		CANONIFY(val);
d2450 1
a2450 1
		if (sm_strcasecmp(val, "none") == 0)
d2452 1
a2452 1
		else if (sm_strcasecmp(val, "add-to") == 0)
d2454 1
a2454 1
		else if (sm_strcasecmp(val, "add-apparently-to") == 0)
d2456 1
a2456 1
		else if (sm_strcasecmp(val, "add-bcc") == 0)
d2458 1
a2458 1
		else if (sm_strcasecmp(val, "add-to-undisclosed") == 0)
d2477 1
a2477 1
		MaxQueueRun = atoi(val);
a2483 24
	  case O_MAXQUEUECHILDREN: /* max # of children of daemon */
		MaxQueueChildren = atoi(val);
		break;

	  case O_MAXRUNNERSPERQUEUE: /* max # runners in a queue group */
		MaxRunnersPerQueue = atoi(val);
		break;

	  case O_NICEQUEUERUN:		/* nice queue runs */

		/* XXX do we want to check the range? > 0 ? */
		NiceQueueRun = atoi(val);
		break;

	  case O_SHMKEY	:		/* shared memory key */
#if SM_CONF_SHM
		ShmKey = atol(val);
#else /* SM_CONF_SHM */
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: Option: %s requires shared memory support (-DSM_CONF_SHM)\n",
				     OPTNAME);
#endif /* SM_CONF_SHM */
		break;

d2495 3
a2497 3
		(void) sm_strlcpy(buf, "@@,;:\\()[]", sizeof buf);
		if (strlen(val) < sizeof buf - 10)
			(void) sm_strlcat(buf, val, sizeof buf);
d2499 1
a2499 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Warning: MustQuoteChars too long, ignored.\n");
d2513 1
a2513 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Warning: OperatorChars is being redefined.\n         It should only be set before ruleset definitions.\n");
d2544 4
a2547 1
		DoubleBounceAddr = newstr(val);
a2551 2
		{
			CANONIFY(val);
a2552 1
		}
a2589 7
			else if (EffGid == pw->pw_gid)
				RunAsGid = pw->pw_gid;
			else if (UseMSP && *p == '\0')
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "WARNING: RunAsGid for MSP ignored, check group ids (egid=%d, want=%d)\n",
						     (int) EffGid,
						     (int) pw->pw_gid);
d2591 1
a2591 1
# ifdef UID_MAX
d2598 1
a2598 1
# endif /* UID_MAX */
d2603 2
a2604 11
				gid_t runasgid;

				runasgid = (gid_t) atoi(p);
				if (can_setuid || EffGid == runasgid)
					RunAsGid = runasgid;
				else if (UseMSP)
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "WARNING: RunAsGid for MSP ignored, check group ids (egid=%d, want=%d)\n",
							     (int) EffGid,
							     (int) runasgid);
d2614 1
a2614 1
				else if (can_setuid || EffGid == gr->gr_gid)
a2615 6
				else if (UseMSP)
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "WARNING: RunAsGid for MSP ignored, check group ids (egid=%d, want=%d)\n",
							     (int) EffGid,
							     (int) gr->gr_gid);
d2619 2
a2620 2
			sm_dprintf("readcf: RunAsUser = %d:%d\n",
				   (int) RunAsUid, (int) RunAsGid);
d2628 3
a2630 1
		PSTRSET(PidFile, val);
d2633 1
a2633 1
	  case O_DONTBLAMESENDMAIL:
d2653 1
a2653 1
				if (sm_strcasecmp(val, dbs->dbs_name) == 0)
d2663 1
a2663 1
		sticky = false;
d2667 1
a2667 6
		if (sm_strcasecmp(val, "loopback") == 0)
			DontProbeInterfaces = DPI_SKIPLOOPBACK;
		else if (atobool(val))
			DontProbeInterfaces = DPI_PROBENONE;
		else
			DontProbeInterfaces = DPI_PROBEALL;
a2673 4
	  case O_RCPTTHROT:
		BadRcptThrottle = atoi(val);
		break;

d2675 3
a2677 2
		CANONIFY(val);
		PSTRSET(DeadLetterDrop, val);
a2692 1
		ConnectOnlyTo.sa.sa_family = AF_UNSPEC;
d2694 2
a2695 2
		if (anynet_pton(AF_INET6, val,
				&ConnectOnlyTo.sin6.sin6_addr) != 1)
d2697 5
a2703 1
# if NETINET
d2705 1
a2706 10
			if (ConnectOnlyTo.sin.sin_addr.s_addr != INADDR_NONE)
				ConnectOnlyTo.sa.sa_family = AF_INET;
		}

# endif /* NETINET */
		if (ConnectOnlyTo.sa.sa_family == AF_UNSPEC)
		{
			syserr("readcf: option ConnectOnlyTo: invalid IP address %s",
			       val);
			break;
d2712 1
a2712 5
# if !HASFCHOWN
		if (!UseMSP)
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "readcf: option TrustedUser may cause problems on systems\n        which do not support fchown() if UseMSP is not set.\n");
# endif /* !HASFCHOWN */
d2738 3
d2756 1
a2756 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Warning: MaxMimeHeaderLength: header length limit set lower than 128\n");
d2761 1
a2761 2
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Warning: MaxMimeHeaderLength: field length limit set lower than 40\n");
d2765 3
a2767 1
		PSTRSET(ControlSocketName, val);
d2775 1
a2775 3
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Warning: MaxHeadersLength: headers length limit set lower than %d\n",
					     (MAXHDRSLEN / 2));
d2779 3
a2781 1
		PSTRSET(ProcTitlePrefix, val);
d2786 1
a2786 1
# if _FFR_ALLOW_SASLINFO
d2788 1
a2788 4
		**  Allow users to select their own authinfo file
		**  under certain circumstances, otherwise just ignore
		**  the option.  If the option isn't ignored, several
		**  commands don't work very well, e.g., mailq.
d2797 5
d2803 5
a2807 2
# endif /* _FFR_ALLOW_SASLINFO */
		PSTRSET(SASLInfo, val);
d2812 1
a2812 1
			sm_free(AuthMechanisms); /* XXX */
d2822 1
a2822 1
			switch (*val)
d2827 1
d2846 1
a2846 4
			  case ' ':	/* ignore */
			  case '\t':	/* ignore */
			  case ',':	/* ignore */
				break;
d2848 5
a2852 6
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Warning: Option: %s unknown parameter '%c'\n",
						     OPTNAME,
						     (isascii(*val) &&
							isprint(*val))
							? *val : '?');
a2860 3
	  case O_SASLBITS:
		MaxSLBits = atoi(val);
		break;
d2866 2
a2867 4
	  case O_SASLBITS:
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: Option: %s requires SASL support (-DSASL)\n",
				     OPTNAME);
d2873 5
a2877 1
		SET_STRING_EXP(SrvCERTfile);
d2879 5
a2883 1
		SET_STRING_EXP(Srvkeyfile);
d2885 5
a2889 1
		SET_STRING_EXP(CltCERTfile);
d2891 5
a2895 1
		SET_STRING_EXP(Cltkeyfile);
d2897 5
a2901 1
		SET_STRING_EXP(CACERTfile);
d2903 5
a2907 1
		SET_STRING_EXP(CACERTpath);
d2909 6
a2914 2
		SET_STRING_EXP(DHParams);
# if _FFR_TLS_1
d2916 5
a2920 1
		SET_STRING_EXP(DHParams5);
d2922 3
a2924 52
		SET_STRING_EXP(CipherList);
# endif /* _FFR_TLS_1 */

	/*
	**  XXX How about options per daemon/client instead of globally?
	**  This doesn't work well for some options, e.g., no server cert,
	**  but fine for others.
	**
	**  XXX Some people may want different certs per server.
	**
	**  See also srvfeatures()
	*/

	  case O_TLS_SRV_OPTS:
		while (val != NULL && *val != '\0')
		{
			switch (*val)
			{
			  case 'V':
				TLS_Srv_Opts |= TLS_I_NO_VRFY;
				break;
# if _FFR_TLS_1
			/*
			**  Server without a cert? That works only if
			**  AnonDH is enabled as cipher, which is not in the
			**  default list. Hence the CipherList option must
			**  be available. Moreover: which clients support this
			**  besides sendmail with this setting?
			*/

			  case 'C':
				TLS_Srv_Opts &= ~TLS_I_SRV_CERT;
				break;
# endif /* _FFR_TLS_1 */
			  case ' ':	/* ignore */
			  case '\t':	/* ignore */
			  case ',':	/* ignore */
				break;
			  default:
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Warning: Option: %s unknown parameter '%c'\n",
						     OPTNAME,
						     (isascii(*val) &&
							isprint(*val))
							? *val : '?');
				break;
			}
			++val;
			val = strpbrk(val, ", \t");
			if (val != NULL)
				++val;
		}
d2926 1
d2929 3
a2931 1
		PSTRSET(RandFile, val);
d2934 1
a2934 1
#else /* STARTTLS */
d2942 1
a2942 1
# if _FFR_TLS_1
d2945 1
a2945 1
# endif /* _FFR_TLS_1 */
d2947 2
a2948 3
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: Option: %s requires TLS support\n",
				     OPTNAME);
d2951 1
a2951 1
#endif /* STARTTLS */
d2954 1
d2956 3
d2970 1
a2970 1
#if LDAPMAP
d2973 2
a2974 3
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: Option: %s requires LDAP support (-DLDAPMAP)\n",
				     OPTNAME);
d2978 1
a2979 1
#if MILTER
a2980 5
#else /* MILTER */
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: Option: %s requires Milter support (-DMILTER)\n",
				     OPTNAME);
#endif /* MILTER */
a2983 1
#if MILTER
a2984 5
#else /* MILTER */
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: Option: %s requires Milter support (-DMILTER)\n",
				     OPTNAME);
#endif /* MILTER */
d2986 1
d2988 1
d2992 1
a2992 34

	  case O_DLVR_MIN:	/* deliver by minimum time */
		DeliverByMin = convtime(val, 's');
		break;

	  /* modifiers {daemon_flags} for direct submissions */
	  case O_DIRECTSUBMODIFIERS:
		{
			BITMAP256 m;	/* ignored */
			extern ENVELOPE BlankEnvelope;

			macdefine(&BlankEnvelope.e_macro, A_PERM,
				  macid("{daemon_flags}"),
				  getmodifiers(val, m));
		}
		break;

	  case O_FASTSPLIT:
		FastSplit = atoi(val);
		break;

	  case O_MBDB:
		Mbdb = newstr(val);
		break;

	  case O_MSQ:
		UseMSP = atobool(val);
		break;

#if _FFR_SOFT_BOUNCE
	  case O_SOFTBOUNCE:
		SoftBounce = atobool(val);
		break;
#endif /* _FFR_SOFT_BOUNCE */
d2998 1
a2998 1
				sm_dprintf("Warning: option %c unknown\n", opt);
d3000 1
a3000 1
				sm_dprintf("Warning: option 0x%x unknown\n", opt);
d3042 1
a3042 1
		mid = macid(str);
d3047 2
a3048 2
			sm_dprintf("setclass(%s, $=%s)\n",
				   macname(class), macname(mid));
d3054 1
a3054 1
			sm_dprintf("setclass(%s, %s)\n", macname(class), str);
d3116 1
a3116 2
		syserr("readcf: map %s: class %s not available", mapname,
			classname);
d3130 8
a3137 6
		sm_dprintf("map %s, class %s, flags %lx, file %s,\n",
			   s->s_map.map_mname, s->s_map.map_class->map_cname,
			   s->s_map.map_mflags, s->s_map.map_file);
		sm_dprintf("\tapp %s, domain %s, rebuild %s\n",
			   s->s_map.map_app, s->s_map.map_domain,
			   s->s_map.map_rebuild);
d3139 1
d3260 1
a3260 1
				sm_free(RuleSetNames[ruleset]); /* XXX */
d3288 2
a3289 2
	char		*to_name;	/* long name of timeout */
	unsigned char	to_code;	/* code for option */
a3355 8
#define TO_LHLO				0x20
	{ "lhlo",			TO_LHLO				},
#define TO_AUTH				0x21
	{ "auth",			TO_AUTH				},
#define TO_STARTTLS			0x22
	{ "starttls",			TO_STARTTLS			},
#define TO_ACONNECT			0x23
	{ "aconnect",			TO_ACONNECT			},
d3367 1
a3367 1
	int i, addopts;
d3371 1
a3371 1
		sm_dprintf("settimeout(%s = %s)", name, val);
d3375 1
a3375 1
		if (sm_strcasecmp(to->to_name, name) == 0)
d3393 1
a3393 1
			sm_dprintf(" (ignored)\n");
d3398 1
a3398 1
		sm_dprintf("\n");
a3400 1
	addopts = 0;
a3463 4
	  case TO_ACONNECT:
		TimeOuts.to_aconnect = toval;
		break;

a3468 1
		addopts = 2;
a3490 1
		addopts = 2;
a3517 1
		addopts = 2;
a3524 1
		addopts = 2;
a3546 16
	  case TO_LHLO:
		TimeOuts.to_lhlo = toval;
		break;

#if SASL
	  case TO_AUTH:
		TimeOuts.to_auth = toval;
		break;
#endif /* SASL */

#if STARTTLS
	  case TO_STARTTLS:
		TimeOuts.to_starttls = toval;
		break;
#endif /* STARTTLS */

d3553 1
a3553 4
	{
		for (i = 0; i <= addopts; i++)
			setbitn(to->to_code + i, StickyTimeoutOpt);
	}
d3579 1
a3579 1
		sm_dprintf("inittimeouts(%s)\n", val == NULL ? "<NULL>" : val);
a3582 1
		TimeOuts.to_aconnect = (time_t) 0 SECONDS;
a3600 7
		TimeOuts.to_lhlo = (time_t) 2 MINUTES;
#if SASL
		TimeOuts.to_auth = (time_t) 10 MINUTES;
#endif /* SASL */
#if STARTTLS
		TimeOuts.to_starttls = (time_t) 1 HOUR;
#endif /* STARTTLS */
d3603 16
a3618 29
			sm_dprintf("Timeouts:\n");
			sm_dprintf("  connect = %ld\n",
				   (long) TimeOuts.to_connect);
			sm_dprintf("  aconnect = %ld\n",
				   (long) TimeOuts.to_aconnect);
			sm_dprintf("  initial = %ld\n",
				   (long) TimeOuts.to_initial);
			sm_dprintf("  helo = %ld\n", (long) TimeOuts.to_helo);
			sm_dprintf("  mail = %ld\n", (long) TimeOuts.to_mail);
			sm_dprintf("  rcpt = %ld\n", (long) TimeOuts.to_rcpt);
			sm_dprintf("  datainit = %ld\n",
				   (long) TimeOuts.to_datainit);
			sm_dprintf("  datablock = %ld\n",
				   (long) TimeOuts.to_datablock);
			sm_dprintf("  datafinal = %ld\n",
				   (long) TimeOuts.to_datafinal);
			sm_dprintf("  rset = %ld\n", (long) TimeOuts.to_rset);
			sm_dprintf("  quit = %ld\n", (long) TimeOuts.to_quit);
			sm_dprintf("  nextcommand = %ld\n",
				   (long) TimeOuts.to_nextcommand);
			sm_dprintf("  miscshort = %ld\n",
				   (long) TimeOuts.to_miscshort);
			sm_dprintf("  ident = %ld\n", (long) TimeOuts.to_ident);
			sm_dprintf("  fileopen = %ld\n",
				   (long) TimeOuts.to_fileopen);
			sm_dprintf("  lhlo = %ld\n",
				   (long) TimeOuts.to_lhlo);
			sm_dprintf("  control = %ld\n",
				   (long) TimeOuts.to_control);
@


