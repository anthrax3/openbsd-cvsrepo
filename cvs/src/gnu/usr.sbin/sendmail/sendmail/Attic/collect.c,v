head	1.28;
access;
symbols
	OPENBSD_5_6:1.27.0.6
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.4
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.24.0.6
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.4
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.23.0.12
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.10
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.6
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.8
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.4
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.22.0.6
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.4
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.19.0.4
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.4
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.27;
commitid	M7i5giHIoz3DMlTU;

1.27
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.25;

1.25
date	2012.12.26.11.44.12;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2011.05.17.15.54.23;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2006.08.13.13.01.48;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.22.18.43.55;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.08.16.00.50;	author millert;	state Exp;
branches
	1.19.2.1
	1.19.4.1;
next	1.18;

1.18
date	2004.12.16.00.21.30;	author millert;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2004.06.24.03.59.26;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.09.17.17.31.40;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.29.19.44.00;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.01.19.59.22;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.09.15.02.23.35;	author millert;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2002.06.03.17.25.46;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.18.00.49.28;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.08.16.15.47;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.01.01.01.41;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.29.01.31.14;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.28.02.43.53;	author millert;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.01.15.21.09.07;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.07.19.20.38;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.43;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.43;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.11;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.50;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.31.30;	author miod;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.31.01.47.55;	author jason;	state Exp;
branches;
next	;

1.10.2.1
date	2003.03.31.07.07.07;	author miod;	state Exp;
branches;
next	;

1.13.2.1
date	2003.03.31.01.01.47;	author margarida;	state Exp;
branches;
next	;

1.18.2.1
date	2006.03.24.05.42.48;	author brad;	state Exp;
branches;
next	;

1.19.2.1
date	2006.03.24.05.56.17;	author brad;	state Exp;
branches;
next	;

1.19.4.1
date	2006.03.25.01.49.37;	author brad;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2006, 2008 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>

SM_RCSID("@@(#)$Sendmail: collect.c,v 8.287 2013/11/22 20:51:55 ca Exp $")

static void	eatfrom __P((char *volatile, ENVELOPE *));
static void	collect_doheader __P((ENVELOPE *));
static SM_FILE_T *collect_dfopen __P((ENVELOPE *));
static SM_FILE_T *collect_eoh __P((ENVELOPE *, int, int));

/*
**  COLLECT_EOH -- end-of-header processing in collect()
**
**	Called by collect() when it encounters the blank line
**	separating the header from the message body, or when it
**	encounters EOF in a message that contains only a header.
**
**	Parameters:
**		e -- envelope
**		numhdrs -- number of headers
**		hdrslen -- length of headers
**
**	Results:
**		NULL, or handle to open data file
**
**	Side Effects:
**		end-of-header check ruleset is invoked.
**		envelope state is updated.
**		headers may be added and deleted.
**		selects the queue.
**		opens the data file.
*/

static SM_FILE_T *
collect_eoh(e, numhdrs, hdrslen)
	ENVELOPE *e;
	int numhdrs;
	int hdrslen;
{
	char hnum[16];
	char hsize[16];

	/* call the end-of-header check ruleset */
	(void) sm_snprintf(hnum, sizeof(hnum), "%d", numhdrs);
	(void) sm_snprintf(hsize, sizeof(hsize), "%d", hdrslen);
	if (tTd(30, 10))
		sm_dprintf("collect: rscheck(\"check_eoh\", \"%s $| %s\")\n",
			   hnum, hsize);
	(void) rscheck("check_eoh", hnum, hsize, e, RSF_UNSTRUCTURED|RSF_COUNT,
			3, NULL, e->e_id, NULL);

	/*
	**  Process the header,
	**  select the queue, open the data file.
	*/

	collect_doheader(e);
	return collect_dfopen(e);
}

/*
**  COLLECT_DOHEADER -- process header in collect()
**
**	Called by collect() after it has finished parsing the header,
**	but before it selects the queue and creates the data file.
**	The results of processing the header will affect queue selection.
**
**	Parameters:
**		e -- envelope
**
**	Results:
**		none.
**
**	Side Effects:
**		envelope state is updated.
**		headers may be added and deleted.
*/

static void
collect_doheader(e)
	ENVELOPE *e;
{
	/*
	**  Find out some information from the headers.
	**	Examples are who is the from person & the date.
	*/

	eatheader(e, true, false);

	if (GrabTo && e->e_sendqueue == NULL)
		usrerr("No recipient addresses found in header");

	/*
	**  If we have a Return-Receipt-To:, turn it into a DSN.
	*/

	if (RrtImpliesDsn && hvalue("return-receipt-to", e->e_header) != NULL)
	{
		ADDRESS *q;

		for (q = e->e_sendqueue; q != NULL; q = q->q_next)
			if (!bitset(QHASNOTIFY, q->q_flags))
				q->q_flags |= QHASNOTIFY|QPINGONSUCCESS;
	}

	/*
	**  Add an appropriate recipient line if we have none.
	*/

	if (hvalue("to", e->e_header) != NULL ||
	    hvalue("cc", e->e_header) != NULL ||
	    hvalue("apparently-to", e->e_header) != NULL)
	{
		/* have a valid recipient header -- delete Bcc: headers */
		e->e_flags |= EF_DELETE_BCC;
	}
	else if (hvalue("bcc", e->e_header) == NULL)
	{
		/* no valid recipient headers */
		register ADDRESS *q;
		char *hdr = NULL;

		/* create a recipient field */
		switch (NoRecipientAction)
		{
		  case NRA_ADD_APPARENTLY_TO:
			hdr = "Apparently-To";
			break;

		  case NRA_ADD_TO:
			hdr = "To";
			break;

		  case NRA_ADD_BCC:
			addheader("Bcc", " ", 0, e, true);
			break;

		  case NRA_ADD_TO_UNDISCLOSED:
			addheader("To", "undisclosed-recipients:;", 0, e, true);
			break;
		}

		if (hdr != NULL)
		{
			for (q = e->e_sendqueue; q != NULL; q = q->q_next)
			{
				if (q->q_alias != NULL)
					continue;
				if (tTd(30, 3))
					sm_dprintf("Adding %s: %s\n",
						hdr, q->q_paddr);
				addheader(hdr, q->q_paddr, 0, e, true);
			}
		}
	}
}

/*
**  COLLECT_DFOPEN -- open the message data file
**
**	Called by collect() after it has finished processing the header.
**	Queue selection occurs at this point, possibly based on the
**	envelope's recipient list and on header information.
**
**	Parameters:
**		e -- envelope
**
**	Results:
**		NULL, or a pointer to an open data file,
**		into which the message body will be written by collect().
**
**	Side Effects:
**		Calls syserr, sets EF_FATALERRS and returns NULL
**		if there is insufficient disk space.
**		Aborts process if data file could not be opened.
**		Otherwise, the queue is selected,
**		e->e_{dfino,dfdev,msgsize,flags} are updated,
**		and a pointer to an open data file is returned.
*/

static SM_FILE_T *
collect_dfopen(e)
	ENVELOPE *e;
{
	MODE_T oldumask = 0;
	int dfd;
	struct stat stbuf;
	SM_FILE_T *df;
	char *dfname;

	if (!setnewqueue(e))
		return NULL;

	dfname = queuename(e, DATAFL_LETTER);
	if (bitset(S_IWGRP, QueueFileMode))
		oldumask = umask(002);
	df = bfopen(dfname, QueueFileMode, DataFileBufferSize,
		    SFF_OPENASROOT);
	if (bitset(S_IWGRP, QueueFileMode))
		(void) umask(oldumask);
	if (df == NULL)
	{
		syserr("@@Cannot create %s", dfname);
		e->e_flags |= EF_NO_BODY_RETN;
		flush_errors(true);
		finis(false, true, ExitStat);
		/* NOTREACHED */
	}
	dfd = sm_io_getinfo(df, SM_IO_WHAT_FD, NULL);
	if (dfd < 0 || fstat(dfd, &stbuf) < 0)
		e->e_dfino = -1;
	else
	{
		e->e_dfdev = stbuf.st_dev;
		e->e_dfino = stbuf.st_ino;
	}
	e->e_flags |= EF_HAS_DF;
	return df;
}

/*
**  COLLECT -- read & parse message header & make temp file.
**
**	Creates a temporary file name and copies the standard
**	input to that file.  Leading UNIX-style "From" lines are
**	stripped off (after important information is extracted).
**
**	Parameters:
**		fp -- file to read.
**		smtpmode -- if set, we are running SMTP: give an RFC821
**			style message to say we are ready to collect
**			input, and never ignore a single dot to mean
**			end of message.
**		hdrp -- the location to stash the header.
**		e -- the current envelope.
**		rsetsize -- reset e_msgsize?
**
**	Returns:
**		none.
**
**	Side Effects:
**		If successful,
**		- Data file is created and filled, and e->e_dfp is set.
**		- The from person may be set.
**		If the "enough disk space" check fails,
**		- syserr is called.
**		- e->e_dfp is NULL.
**		- e->e_flags & EF_FATALERRS is set.
**		- collect() returns.
**		If data file cannot be created, the process is terminated.
*/

/* values for input state machine */
#define IS_NORM		0	/* middle of line */
#define IS_BOL		1	/* beginning of line */
#define IS_DOT		2	/* read a dot at beginning of line */
#define IS_DOTCR	3	/* read ".\r" at beginning of line */
#define IS_CR		4	/* read a carriage return */

/* values for message state machine */
#define MS_UFROM	0	/* reading Unix from line */
#define MS_HEADER	1	/* reading message header */
#define MS_BODY		2	/* reading message body */
#define MS_DISCARD	3	/* discarding rest of message */

void
collect(fp, smtpmode, hdrp, e, rsetsize)
	SM_FILE_T *fp;
	bool smtpmode;
	HDR **hdrp;
	register ENVELOPE *e;
	bool rsetsize;
{
	register SM_FILE_T *df;
	bool ignrdot;
	int dbto;
	register char *bp;
	int c;
	bool inputerr;
	bool headeronly;
	char *buf;
	int buflen;
	int istate;
	int mstate;
	int hdrslen;
	int numhdrs;
	int afd;
	unsigned char *pbp;
	unsigned char peekbuf[8];
	char bufbuf[MAXLINE];
#if _FFR_REJECT_NUL_BYTE
	bool hasNUL;		/* has at least one NUL input byte */
#endif /* _FFR_REJECT_NUL_BYTE */

	df = NULL;
	ignrdot = smtpmode ? false : IgnrDot;

	/* timeout for I/O functions is in milliseconds */
	dbto = smtpmode ? ((int) TimeOuts.to_datablock * 1000)
			: SM_TIME_FOREVER;
	sm_io_setinfo(fp, SM_IO_WHAT_TIMEOUT, &dbto);
	set_tls_rd_tmo(TimeOuts.to_datablock);
	c = SM_IO_EOF;
	inputerr = false;
	headeronly = hdrp != NULL;
	hdrslen = 0;
	numhdrs = 0;
	HasEightBits = false;
#if _FFR_REJECT_NUL_BYTE
	hasNUL = false;
#endif /* _FFR_REJECT_NUL_BYTE */
	buf = bp = bufbuf;
	buflen = sizeof(bufbuf);
	pbp = peekbuf;
	istate = IS_BOL;
	mstate = SaveFrom ? MS_HEADER : MS_UFROM;

	/*
	**  Tell ARPANET to go ahead.
	*/

	if (smtpmode)
		message("354 Enter mail, end with \".\" on a line by itself");

	/* simulate an I/O timeout when used as sink */
	if (tTd(83, 101))
		sleep(319);

	if (tTd(30, 2))
		sm_dprintf("collect\n");

	/*
	**  Read the message.
	**
	**	This is done using two interleaved state machines.
	**	The input state machine is looking for things like
	**	hidden dots; the message state machine is handling
	**	the larger picture (e.g., header versus body).
	*/

	if (rsetsize)
		e->e_msgsize = 0;
	for (;;)
	{
		if (tTd(30, 35))
			sm_dprintf("top, istate=%d, mstate=%d\n", istate,
				   mstate);
		for (;;)
		{
			if (pbp > peekbuf)
				c = *--pbp;
			else
			{
				while (!sm_io_eof(fp) && !sm_io_error(fp))
				{
					errno = 0;
					c = sm_io_getc(fp, SM_TIME_DEFAULT);
					if (c == SM_IO_EOF && errno == EINTR)
					{
						/* Interrupted, retry */
						sm_io_clearerr(fp);
						continue;
					}

					/* timeout? */
					if (c == SM_IO_EOF && errno == EAGAIN
					    && smtpmode)
					{
						/*
						**  Override e_message in
						**  usrerr() as this is the
						**  reason for failure that
						**  should be logged for
						**  undelivered recipients.
						*/

						e->e_message = NULL;
						errno = 0;
						inputerr = true;
						goto readabort;
					}
					break;
				}
				if (TrafficLogFile != NULL && !headeronly)
				{
					if (istate == IS_BOL)
						(void) sm_io_fprintf(TrafficLogFile,
							SM_TIME_DEFAULT,
							"%05d <<< ",
							(int) CurrentPid);
					if (c == SM_IO_EOF)
						(void) sm_io_fprintf(TrafficLogFile,
							SM_TIME_DEFAULT,
							"[EOF]\n");
					else
						(void) sm_io_putc(TrafficLogFile,
							SM_TIME_DEFAULT,
							c);
				}
#if _FFR_REJECT_NUL_BYTE
				if (c == '\0')
					hasNUL = true;
#endif /* _FFR_REJECT_NUL_BYTE */
				if (c == SM_IO_EOF)
					goto readerr;
				if (SevenBitInput)
					c &= 0x7f;
				else
					HasEightBits |= bitset(0x80, c);
			}
			if (tTd(30, 94))
				sm_dprintf("istate=%d, c=%c (0x%x)\n",
					istate, (char) c, c);
			switch (istate)
			{
			  case IS_BOL:
				if (c == '.')
				{
					istate = IS_DOT;
					continue;
				}
				break;

			  case IS_DOT:
				if (c == '\n' && !ignrdot &&
				    !bitset(EF_NL_NOT_EOL, e->e_flags))
					goto readerr;
				else if (c == '\r' &&
					 !bitset(EF_CRLF_NOT_EOL, e->e_flags))
				{
					istate = IS_DOTCR;
					continue;
				}
				else if (ignrdot ||
					 (c != '.' &&
					  OpMode != MD_SMTP &&
					  OpMode != MD_DAEMON &&
					  OpMode != MD_ARPAFTP))

				{
					SM_ASSERT(pbp < peekbuf +
							sizeof(peekbuf));
					*pbp++ = c;
					c = '.';
				}
				break;

			  case IS_DOTCR:
				if (c == '\n' && !ignrdot)
					goto readerr;
				else
				{
					/* push back the ".\rx" */
					SM_ASSERT(pbp < peekbuf +
							sizeof(peekbuf));
					*pbp++ = c;
					if (OpMode != MD_SMTP &&
					    OpMode != MD_DAEMON &&
					    OpMode != MD_ARPAFTP)
					{
						SM_ASSERT(pbp < peekbuf +
							 sizeof(peekbuf));
						*pbp++ = '\r';
						c = '.';
					}
					else
						c = '\r';
				}
				break;

			  case IS_CR:
				if (c == '\n')
					istate = IS_BOL;
				else
				{
					(void) sm_io_ungetc(fp, SM_TIME_DEFAULT,
							    c);
					c = '\r';
					istate = IS_NORM;
				}
				goto bufferchar;
			}

			if (c == '\r' && !bitset(EF_CRLF_NOT_EOL, e->e_flags))
			{
				istate = IS_CR;
				continue;
			}
			else if (c == '\n' && !bitset(EF_NL_NOT_EOL,
						      e->e_flags))
				istate = IS_BOL;
			else
				istate = IS_NORM;

bufferchar:
			if (!headeronly)
			{
				/* no overflow? */
				if (e->e_msgsize >= 0)
				{
					e->e_msgsize++;
					if (MaxMessageSize > 0 &&
					    !bitset(EF_TOOBIG, e->e_flags) &&
					    e->e_msgsize > MaxMessageSize)
						 e->e_flags |= EF_TOOBIG;
				}
			}
			switch (mstate)
			{
			  case MS_BODY:
				/* just put the character out */
				if (!bitset(EF_TOOBIG, e->e_flags))
					(void) sm_io_putc(df, SM_TIME_DEFAULT,
							  c);

				/* FALLTHROUGH */

			  case MS_DISCARD:
				continue;
			}

			SM_ASSERT(mstate == MS_UFROM || mstate == MS_HEADER);

			/* header -- buffer up */
			if (bp >= &buf[buflen - 2])
			{
				char *obuf;

				/* out of space for header */
				obuf = buf;
				if (buflen < MEMCHUNKSIZE)
					buflen *= 2;
				else
					buflen += MEMCHUNKSIZE;
				if (buflen <= 0)
				{
					sm_syslog(LOG_NOTICE, e->e_id,
						  "header overflow from %s during message collect",
						  CURHOSTNAME);
					errno = 0;
					e->e_flags |= EF_CLRQUEUE;
					e->e_status = "5.6.0";
					usrerrenh(e->e_status,
						  "552 Headers too large");
					goto discard;
				}
				buf = xalloc(buflen);
				memmove(buf, obuf, bp - obuf);
				bp = &buf[bp - obuf];
				if (obuf != bufbuf)
					sm_free(obuf);  /* XXX */
			}

			if (c != '\0')
			{
				*bp++ = c;
				++hdrslen;
				if (!headeronly &&
				    MaxHeadersLength > 0 &&
				    hdrslen > MaxHeadersLength)
				{
					sm_syslog(LOG_NOTICE, e->e_id,
						  "headers too large (%d max) from %s during message collect",
						  MaxHeadersLength,
						  CURHOSTNAME);
					errno = 0;
					e->e_flags |= EF_CLRQUEUE;
					e->e_status = "5.6.0";
					usrerrenh(e->e_status,
						  "552 Headers too large (%d max)",
						  MaxHeadersLength);
  discard:
					mstate = MS_DISCARD;
				}
			}
			if (istate == IS_BOL)
				break;
		}
		*bp = '\0';

nextstate:
		if (tTd(30, 35))
			sm_dprintf("nextstate, istate=%d, mstate=%d, line=\"%s\"\n",
				istate, mstate, buf);
		switch (mstate)
		{
		  case MS_UFROM:
			mstate = MS_HEADER;
#ifndef NOTUNIX
			if (strncmp(buf, "From ", 5) == 0)
			{
				bp = buf;
				eatfrom(buf, e);
				continue;
			}
#endif /* ! NOTUNIX */
			/* FALLTHROUGH */

		  case MS_HEADER:
			if (!isheader(buf))
			{
				mstate = MS_BODY;
				goto nextstate;
			}

			/* check for possible continuation line */
			do
			{
				sm_io_clearerr(fp);
				errno = 0;
				c = sm_io_getc(fp, SM_TIME_DEFAULT);

				/* timeout? */
				if (c == SM_IO_EOF && errno == EAGAIN
				    && smtpmode)
				{
					/*
					**  Override e_message in
					**  usrerr() as this is the
					**  reason for failure that
					**  should be logged for
					**  undelivered recipients.
					*/

					e->e_message = NULL;
					errno = 0;
					inputerr = true;
					goto readabort;
				}
			} while (c == SM_IO_EOF && errno == EINTR);
			if (c != SM_IO_EOF)
				(void) sm_io_ungetc(fp, SM_TIME_DEFAULT, c);
			if (c == ' ' || c == '\t')
			{
				/* yep -- defer this */
				continue;
			}

			SM_ASSERT(bp > buf);

			/* guaranteed by isheader(buf) */
			SM_ASSERT(*(bp - 1) != '\n' || bp > buf + 1);

			/* trim off trailing CRLF or NL */
			if (*--bp != '\n' || *--bp != '\r')
				bp++;
			*bp = '\0';

			if (bitset(H_EOH, chompheader(buf,
						      CHHDR_CHECK | CHHDR_USER,
						      hdrp, e)))
			{
				mstate = MS_BODY;
				goto nextstate;
			}
			numhdrs++;
			break;

		  case MS_BODY:
			if (tTd(30, 1))
				sm_dprintf("EOH\n");

			if (headeronly)
				goto readerr;

			df = collect_eoh(e, numhdrs, hdrslen);
			if (df == NULL)
				e->e_flags |= EF_TOOBIG;

			bp = buf;

			/* toss blank line */
			if ((!bitset(EF_CRLF_NOT_EOL, e->e_flags) &&
				bp[0] == '\r' && bp[1] == '\n') ||
			    (!bitset(EF_NL_NOT_EOL, e->e_flags) &&
				bp[0] == '\n'))
			{
				break;
			}

			/* if not a blank separator, write it out */
			if (!bitset(EF_TOOBIG, e->e_flags))
			{
				while (*bp != '\0')
					(void) sm_io_putc(df, SM_TIME_DEFAULT,
							  *bp++);
			}
			break;
		}
		bp = buf;
	}

readerr:
	if ((sm_io_eof(fp) && smtpmode) || sm_io_error(fp))
	{
		const char *errmsg;

		if (sm_io_eof(fp))
			errmsg = "unexpected close";
		else
			errmsg = sm_errstring(errno);
		if (tTd(30, 1))
			sm_dprintf("collect: premature EOM: %s\n", errmsg);
		if (LogLevel > 1)
			sm_syslog(LOG_WARNING, e->e_id,
				"collect: premature EOM: %s", errmsg);
		inputerr = true;
	}

	if (headeronly)
		return;

	if (mstate != MS_BODY)
	{
		/* no body or discard, so we never opened the data file */
		SM_ASSERT(df == NULL);
		df = collect_eoh(e, numhdrs, hdrslen);
	}

	if (df == NULL)
	{
		/* skip next few clauses */
		/* EMPTY */
	}
	else if (sm_io_flush(df, SM_TIME_DEFAULT) != 0 || sm_io_error(df))
	{
		dferror(df, "sm_io_flush||sm_io_error", e);
		flush_errors(true);
		finis(true, true, ExitStat);
		/* NOTREACHED */
	}
	else if (SuperSafe == SAFE_NO ||
		 SuperSafe == SAFE_INTERACTIVE ||
		 (SuperSafe == SAFE_REALLY_POSTMILTER && smtpmode))
	{
		/* skip next few clauses */
		/* EMPTY */
		/* Note: updfs() is not called in this case! */
	}
	else if (sm_io_setinfo(df, SM_BF_COMMIT, NULL) < 0 && errno != EINVAL)
	{
		int save_errno = errno;

		if (save_errno == EEXIST)
		{
			char *dfile;
			struct stat st;
			int dfd;

			dfile = queuename(e, DATAFL_LETTER);
			if (stat(dfile, &st) < 0)
				st.st_size = -1;
			errno = EEXIST;
			syserr("@@collect: bfcommit(%s): already on disk, size=%ld",
			       dfile, (long) st.st_size);
			dfd = sm_io_getinfo(df, SM_IO_WHAT_FD, NULL);
			if (dfd >= 0)
				dumpfd(dfd, true, true);
		}
		errno = save_errno;
		dferror(df, "bfcommit", e);
		flush_errors(true);
		finis(save_errno != EEXIST, true, ExitStat);
	}
	else if ((afd = sm_io_getinfo(df, SM_IO_WHAT_FD, NULL)) < 0)
	{
		dferror(df, "sm_io_getinfo", e);
		flush_errors(true);
		finis(true, true, ExitStat);
		/* NOTREACHED */
	}
	else if (fsync(afd) < 0)
	{
		dferror(df, "fsync", e);
		flush_errors(true);
		finis(true, true, ExitStat);
		/* NOTREACHED */
	}
	else if (sm_io_close(df, SM_TIME_DEFAULT) < 0)
	{
		dferror(df, "sm_io_close", e);
		flush_errors(true);
		finis(true, true, ExitStat);
		/* NOTREACHED */
	}
	else
	{
		/* everything is happily flushed to disk */
		df = NULL;

		/* remove from available space in filesystem */
		updfs(e, 0, 1, "collect");
	}

	/* An EOF when running SMTP is an error */
  readabort:
	if (inputerr && (OpMode == MD_SMTP || OpMode == MD_DAEMON))
	{
		char *host;
		char *problem;
		ADDRESS *q;

		host = RealHostName;
		if (host == NULL)
			host = "localhost";

		if (sm_io_eof(fp))
			problem = "unexpected close";
		else if (sm_io_error(fp))
			problem = "I/O error";
		else
			problem = "read timeout";
		if (LogLevel > 0 && sm_io_eof(fp))
			sm_syslog(LOG_NOTICE, e->e_id,
				"collect: %s on connection from %.100s, sender=%s",
				problem, host,
				shortenstring(e->e_from.q_paddr, MAXSHORTSTR));
		if (sm_io_eof(fp))
			usrerr("421 4.4.1 collect: %s on connection from %s, from=%s",
				problem, host,
				shortenstring(e->e_from.q_paddr, MAXSHORTSTR));
		else
			syserr("421 4.4.1 collect: %s on connection from %s, from=%s",
				problem, host,
				shortenstring(e->e_from.q_paddr, MAXSHORTSTR));
		flush_errors(true);

		/* don't return an error indication */
		e->e_to = NULL;
		e->e_flags &= ~EF_FATALERRS;
		e->e_flags |= EF_CLRQUEUE;

		/* Don't send any message notification to sender */
		for (q = e->e_sendqueue; q != NULL; q = q->q_next)
		{
			if (QS_IS_DEAD(q->q_state))
				continue;
			q->q_state = QS_FATALERR;
		}

		(void) sm_io_close(df, SM_TIME_DEFAULT);
		df = NULL;
		finis(true, true, ExitStat);
		/* NOTREACHED */
	}

	/* Log collection information. */
	if (tTd(92, 2))
		sm_dprintf("collect: e_id=%s, EF_LOGSENDER=%d, LogLevel=%d\n",
			e->e_id, bitset(EF_LOGSENDER, e->e_flags), LogLevel);
	if (bitset(EF_LOGSENDER, e->e_flags) && LogLevel > 4)
	{
		logsender(e, e->e_msgid);
		e->e_flags &= ~EF_LOGSENDER;
	}

	/* check for message too large */
	if (bitset(EF_TOOBIG, e->e_flags))
	{
		e->e_flags |= EF_NO_BODY_RETN|EF_CLRQUEUE;
		if (!bitset(EF_FATALERRS, e->e_flags))
		{
			e->e_status = "5.2.3";
			usrerrenh(e->e_status,
				"552 Message exceeds maximum fixed size (%ld)",
				MaxMessageSize);
			if (LogLevel > 6)
				sm_syslog(LOG_NOTICE, e->e_id,
					"message size (%ld) exceeds maximum (%ld)",
					PRT_NONNEGL(e->e_msgsize),
					MaxMessageSize);
		}
	}

	/* check for illegal 8-bit data */
	if (HasEightBits)
	{
		e->e_flags |= EF_HAS8BIT;
		if (!bitset(MM_PASS8BIT|MM_MIME8BIT, MimeMode) &&
		    !bitset(EF_IS_MIME, e->e_flags))
		{
			e->e_status = "5.6.1";
			usrerrenh(e->e_status, "554 Eight bit data not allowed");
		}
	}
	else
	{
		/* if it claimed to be 8 bits, well, it lied.... */
		if (e->e_bodytype != NULL &&
		    sm_strcasecmp(e->e_bodytype, "8BITMIME") == 0)
			e->e_bodytype = "7BIT";
	}

#if _FFR_REJECT_NUL_BYTE
	if (hasNUL && RejectNUL)
	{
		e->e_status = "5.6.1";
		usrerrenh(e->e_status, "554 NUL byte not allowed");
	}
#endif /* _FFR_REJECT_NUL_BYTE */

	if (SuperSafe == SAFE_REALLY && !bitset(EF_FATALERRS, e->e_flags))
	{
		char *dfname = queuename(e, DATAFL_LETTER);
		if ((e->e_dfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, dfname,
					   SM_IO_RDONLY_B, NULL)) == NULL)
		{
			/* we haven't acked receipt yet, so just chuck this */
			syserr("@@Cannot reopen %s", dfname);
			finis(true, true, ExitStat);
			/* NOTREACHED */
		}
	}
	else
		e->e_dfp = df;

	/* collect statistics */
	if (OpMode != MD_VERIFY)
	{
		/*
		**  Recalculate e_msgpriority, it is done at in eatheader()
		**  which is called (in 8.12) after the header is collected,
		**  hence e_msgsize is (most likely) incorrect.
		*/

		e->e_msgpriority = e->e_msgsize
				 - e->e_class * WkClassFact
				 + e->e_nrcpts * WkRecipFact;
		markstats(e, (ADDRESS *) NULL, STATS_NORMAL);
	}
}

/*
**  DFERROR -- signal error on writing the data file.
**
**	Called by collect().  Collect() always terminates the process
**	immediately after calling dferror(), which means that the SMTP
**	session will be terminated, which means that any error message
**	issued by dferror must be a 421 error, as per RFC 821.
**
**	Parameters:
**		df -- the file pointer for the data file.
**		msg -- detailed message.
**		e -- the current envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Gives an error message.
**		Arranges for following output to go elsewhere.
*/

void
dferror(df, msg, e)
	SM_FILE_T *volatile df;
	char *msg;
	register ENVELOPE *e;
{
	char *dfname;

	dfname = queuename(e, DATAFL_LETTER);
	setstat(EX_IOERR);
	if (errno == ENOSPC)
	{
#if STAT64 > 0
		struct stat64 st;
#else /* STAT64 > 0 */
		struct stat st;
#endif /* STAT64 > 0 */
		long avail;
		long bsize;

		e->e_flags |= EF_NO_BODY_RETN;

		if (
#if STAT64 > 0
		    fstat64(sm_io_getinfo(df, SM_IO_WHAT_FD, NULL), &st)
#else /* STAT64 > 0 */
		    fstat(sm_io_getinfo(df, SM_IO_WHAT_FD, NULL), &st)
#endif /* STAT64 > 0 */
		    < 0)
		  st.st_size = 0;
		(void) sm_io_reopen(SmFtStdio, SM_TIME_DEFAULT, dfname,
				    SM_IO_WRONLY_B, NULL, df);
		if (st.st_size <= 0)
			(void) sm_io_fprintf(df, SM_TIME_DEFAULT,
				"\n*** Mail could not be accepted");
		else
			(void) sm_io_fprintf(df, SM_TIME_DEFAULT,
				"\n*** Mail of at least %llu bytes could not be accepted\n",
				(ULONGLONG_T) st.st_size);
		(void) sm_io_fprintf(df, SM_TIME_DEFAULT,
			"*** at %s due to lack of disk space for temp file.\n",
			MyHostName);
		avail = freediskspace(qid_printqueue(e->e_qgrp, e->e_qdir),
				      &bsize);
		if (avail > 0)
		{
			if (bsize > 1024)
				avail *= bsize / 1024;
			else if (bsize < 1024)
				avail /= 1024 / bsize;
			(void) sm_io_fprintf(df, SM_TIME_DEFAULT,
				"*** Currently, %ld kilobytes are available for mail temp files.\n",
				avail);
		}
#if 0
		/* Wrong response code; should be 421. */
		e->e_status = "4.3.1";
		usrerrenh(e->e_status, "452 Out of disk space for temp file");
#else /* 0 */
		syserr("421 4.3.1 Out of disk space for temp file");
#endif /* 0 */
	}
	else
		syserr("421 4.3.0 collect: Cannot write %s (%s, uid=%d, gid=%d)",
			dfname, msg, (int) geteuid(), (int) getegid());
	if (sm_io_reopen(SmFtStdio, SM_TIME_DEFAULT, SM_PATH_DEVNULL,
			 SM_IO_WRONLY, NULL, df) == NULL)
		sm_syslog(LOG_ERR, e->e_id,
			  "dferror: sm_io_reopen(\"/dev/null\") failed: %s",
			  sm_errstring(errno));
}
/*
**  EATFROM -- chew up a UNIX style from line and process
**
**	This does indeed make some assumptions about the format
**	of UNIX messages.
**
**	Parameters:
**		fm -- the from line.
**		e -- envelope
**
**	Returns:
**		none.
**
**	Side Effects:
**		extracts what information it can from the header,
**		such as the date.
*/

#ifndef NOTUNIX

static char	*DowList[] =
{
	"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", NULL
};

static char	*MonthList[] =
{
	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
	NULL
};

static void
eatfrom(fm, e)
	char *volatile fm;
	register ENVELOPE *e;
{
	register char *p;
	register char **dt;

	if (tTd(30, 2))
		sm_dprintf("eatfrom(%s)\n", fm);

	/* find the date part */
	p = fm;
	while (*p != '\0')
	{
		/* skip a word */
		while (*p != '\0' && *p != ' ')
			p++;
		while (*p == ' ')
			p++;
		if (strlen(p) < 17)
		{
			/* no room for the date */
			return;
		}
		if (!(isascii(*p) && isupper(*p)) ||
		    p[3] != ' ' || p[13] != ':' || p[16] != ':')
			continue;

		/* we have a possible date */
		for (dt = DowList; *dt != NULL; dt++)
			if (strncmp(*dt, p, 3) == 0)
				break;
		if (*dt == NULL)
			continue;

		for (dt = MonthList; *dt != NULL; dt++)
		{
			if (strncmp(*dt, &p[4], 3) == 0)
				break;
		}
		if (*dt != NULL)
			break;
	}

	if (*p != '\0')
	{
		char *q, buf[25];

		/* we have found a date */
		(void) sm_strlcpy(buf, p, sizeof(buf));
		q = arpadate(buf);
		macdefine(&e->e_macro, A_TEMP, 'a', q);
	}
}
#endif /* ! NOTUNIX */
@


1.27
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.26
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2006, 2008 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: collect.c,v 8.286 2013/03/15 17:54:12 ca Exp $")
@


1.25
log
@Update to sendmail 8.14.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: collect.c,v 8.285 2012/06/14 23:54:02 ca Exp $")
d303 3
d321 3
d412 4
d905 8
@


1.24
log
@Update to sendmail 8.14.5
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: collect.c,v 8.284 2008/08/06 05:26:24 ca Exp $")
d872 2
a873 1
					e->e_msgsize, MaxMessageSize);
@


1.23
log
@Update to sendmail-8.14.3
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: collect.c,v 8.282 2008/01/31 18:48:29 ca Exp $")
d850 3
@


1.22
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2006 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: collect.c,v 8.280 2006/11/29 00:20:40 ca Exp $")
d311 1
@


1.21
log
@Update to sendmail-8.13.8
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: collect.c,v 8.273 2006/03/31 18:51:47 ca Exp $")
d56 2
a57 2
	(void) sm_snprintf(hnum, sizeof hnum, "%d", numhdrs);
	(void) sm_snprintf(hsize, sizeof hsize, "%d", hdrslen);
d62 1
a62 1
			3, NULL, e->e_id);
d147 1
a147 1
			addheader("Bcc", " ", 0, e);
d151 1
a151 1
			addheader("To", "undisclosed-recipients:;", 0, e);
d164 1
a164 1
				addheader(hdr, q->q_paddr, 0, e);
d318 1
a318 1
	buflen = sizeof bufbuf;
d555 1
a555 19
			/*
			**  XXX Notice: the logic here is broken.
			**  An input to sendmail that doesn't contain a
			**  header but starts immediately with the body whose
			**  first line contain characters which match the
			**  following "if" will cause problems: those
			**  characters will NOT appear in the output...
			**  Do we care?
			*/

			if (c >= 0200 && c <= 0237)
			{
#if 0	/* causes complaints -- figure out something for 8.n+1 */
				usrerr("Illegal character 0x%x in header", c);
#else /* 0 */
				/* EMPTY */
#endif /* 0 */
			}
			else if (c != '\0')
d584 1
a584 1
			sm_dprintf("nextstate, istate=%d, mstate=%d, line = \"%s\"\n",
@


1.20
log
@Update to sendmail 8.13.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: collect.c,v 8.272 2006/03/02 19:09:26 ca Exp $")
d860 2
@


1.19
log
@update to sendmail 8.13.4
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: collect.c,v 8.261 2005/02/16 23:38:51 ca Exp $")
a17 1
static void	collecttimeout __P((int));
a264 4
static jmp_buf	CtxCollectTimeout;
static bool	volatile CollectProgress;
static SM_EVENT	*volatile CollectTimeout = NULL;

d286 6
a291 6
	register SM_FILE_T *volatile df;
	volatile bool ignrdot;
	volatile int dbto;
	register char *volatile bp;
	volatile int c;
	volatile bool inputerr;
d293 8
a300 8
	char *volatile buf;
	volatile int buflen;
	volatile int istate;
	volatile int mstate;
	volatile int hdrslen;
	volatile int numhdrs;
	volatile int afd;
	unsigned char *volatile pbp;
d306 5
a310 1
	dbto = smtpmode ? (int) TimeOuts.to_datablock : 0;
a321 1
	CollectProgress = false;
d330 4
a345 26
	if (dbto != 0)
	{
		/* handle possible input timeout */
		if (setjmp(CtxCollectTimeout) != 0)
		{
			if (LogLevel > 2)
				sm_syslog(LOG_NOTICE, e->e_id,
					  "timeout waiting for input from %s during message collect",
					  CURHOSTNAME);
			errno = 0;
			if (smtpmode)
			{
				/*
				**  Override e_message in usrerr() as this
				**  is the reason for failure that should
				**  be logged for undelivered recipients.
				*/

				e->e_message = NULL;
			}
			usrerr("451 4.4.1 timeout waiting for input during message collect");
			goto readerr;
		}
		CollectTimeout = sm_setevent(dbto, collecttimeout, dbto);
	}

d369 18
a388 1
				CollectProgress = true;
d442 2
a443 1
					SM_ASSERT(pbp < peekbuf + sizeof(peekbuf));
d455 2
a456 1
					SM_ASSERT(pbp < peekbuf + sizeof(peekbuf));
d536 12
d591 1
d631 18
d658 5
a663 1
			SM_ASSERT(bp > buf);
a728 4
	/* reset global timer */
	if (CollectTimeout != NULL)
		sm_clrevent(CollectTimeout);

d815 1
d838 1
a838 1
			usrerr("451 4.4.1 collect: %s on connection from %s, from=%s",
d842 1
a842 1
			syserr("451 4.4.1 collect: %s on connection from %s, from=%s",
d845 1
a937 33
static void
collecttimeout(timeout)
	int timeout;
{
	int save_errno = errno;

	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	if (CollectProgress)
	{
		/* reset the timeout */
		CollectTimeout = sm_sigsafe_setevent(timeout, collecttimeout,
						     timeout);
		CollectProgress = false;
	}
	else
	{
		/* event is done */
		CollectTimeout = NULL;
	}

	/* if no progress was made or problem resetting event, die now */
	if (CollectTimeout == NULL)
	{
		errno = ETIMEDOUT;
		longjmp(CtxCollectTimeout, 1);
	}
	errno = save_errno;
}
@


1.19.4.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@d18 1
d266 4
d291 6
a296 6
	register SM_FILE_T *df;
	bool ignrdot;
	int dbto;
	register char *bp;
	int c;
	bool inputerr;
d298 8
a305 8
	char *buf;
	int buflen;
	int istate;
	int mstate;
	int hdrslen;
	int numhdrs;
	int afd;
	unsigned char *pbp;
d311 1
a311 5

	/* timeout for I/O functions is in milliseconds */
	dbto = smtpmode ? ((int) TimeOuts.to_datablock * 1000)
			: SM_TIME_FOREVER;
	sm_io_setinfo(fp, SM_IO_WHAT_TIMEOUT, &dbto);
d323 1
d344 26
a392 18

					/* timeout? */
					if (c == SM_IO_EOF && errno == EAGAIN
					    && smtpmode)
					{
						/*
						**  Override e_message in
						**  usrerr() as this is the
						**  reason for failure that
						**  should be logged for
						**  undelivered recipients.
						*/

						e->e_message = NULL;
						errno = 0;
						inputerr = true;
						goto readabort;
					}
d395 1
a540 12
				if (buflen <= 0)
				{
					sm_syslog(LOG_NOTICE, e->e_id,
						  "header overflow from %s during message collect",
						  CURHOSTNAME);
					errno = 0;
					e->e_flags |= EF_CLRQUEUE;
					e->e_status = "5.6.0";
					usrerrenh(e->e_status,
						  "552 Headers too large");
					goto discard;
				}
a583 1
  discard:
a622 18

				/* timeout? */
				if (c == SM_IO_EOF && errno == EAGAIN
				    && smtpmode)
				{
					/*
					**  Override e_message in
					**  usrerr() as this is the
					**  reason for failure that
					**  should be logged for
					**  undelivered recipients.
					*/

					e->e_message = NULL;
					errno = 0;
					inputerr = true;
					goto readabort;
				}
d632 1
a633 5

			/* guaranteed by isheader(buf) */
			SM_ASSERT(*(bp - 1) != '\n' || bp > buf + 1);

			/* trim off trailing CRLF or NL */
d699 4
a788 1
  readabort:
d811 1
a811 1
			usrerr("421 4.4.1 collect: %s on connection from %s, from=%s",
d815 1
a815 1
			syserr("421 4.4.1 collect: %s on connection from %s, from=%s",
a817 1
		flush_errors(true);
d910 33
@


1.19.2.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@d18 1
d266 4
d291 6
a296 6
	register SM_FILE_T *df;
	bool ignrdot;
	int dbto;
	register char *bp;
	int c;
	bool inputerr;
d298 8
a305 8
	char *buf;
	int buflen;
	int istate;
	int mstate;
	int hdrslen;
	int numhdrs;
	int afd;
	unsigned char *pbp;
d311 1
a311 5

	/* timeout for I/O functions is in milliseconds */
	dbto = smtpmode ? ((int) TimeOuts.to_datablock * 1000)
			: SM_TIME_FOREVER;
	sm_io_setinfo(fp, SM_IO_WHAT_TIMEOUT, &dbto);
d323 1
d344 26
a392 18

					/* timeout? */
					if (c == SM_IO_EOF && errno == EAGAIN
					    && smtpmode)
					{
						/*
						**  Override e_message in
						**  usrerr() as this is the
						**  reason for failure that
						**  should be logged for
						**  undelivered recipients.
						*/

						e->e_message = NULL;
						errno = 0;
						inputerr = true;
						goto readabort;
					}
d395 1
a540 12
				if (buflen <= 0)
				{
					sm_syslog(LOG_NOTICE, e->e_id,
						  "header overflow from %s during message collect",
						  CURHOSTNAME);
					errno = 0;
					e->e_flags |= EF_CLRQUEUE;
					e->e_status = "5.6.0";
					usrerrenh(e->e_status,
						  "552 Headers too large");
					goto discard;
				}
a583 1
  discard:
a622 18

				/* timeout? */
				if (c == SM_IO_EOF && errno == EAGAIN
				    && smtpmode)
				{
					/*
					**  Override e_message in
					**  usrerr() as this is the
					**  reason for failure that
					**  should be logged for
					**  undelivered recipients.
					*/

					e->e_message = NULL;
					errno = 0;
					inputerr = true;
					goto readabort;
				}
d632 1
a633 5

			/* guaranteed by isheader(buf) */
			SM_ASSERT(*(bp - 1) != '\n' || bp > buf + 1);

			/* trim off trailing CRLF or NL */
d699 4
a788 1
  readabort:
d811 1
a811 1
			usrerr("421 4.4.1 collect: %s on connection from %s, from=%s",
d815 1
a815 1
			syserr("421 4.4.1 collect: %s on connection from %s, from=%s",
a817 1
		flush_errors(true);
d910 33
@


1.18
log
@Update to sendmail-8.13.2
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: collect.c,v 8.260 2004/11/30 23:29:15 ca Exp $")
d731 1
d785 1
a785 1
		updfs(e, false, true);
@


1.18.2.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@d18 1
d266 4
d291 6
a296 6
	register SM_FILE_T *df;
	bool ignrdot;
	int dbto;
	register char *bp;
	int c;
	bool inputerr;
d298 8
a305 8
	char *buf;
	int buflen;
	int istate;
	int mstate;
	int hdrslen;
	int numhdrs;
	int afd;
	unsigned char *pbp;
d311 1
a311 5

	/* timeout for I/O functions is in milliseconds */
	dbto = smtpmode ? ((int) TimeOuts.to_datablock * 1000)
			: SM_TIME_FOREVER;
	sm_io_setinfo(fp, SM_IO_WHAT_TIMEOUT, &dbto);
d323 1
d344 26
a392 18

					/* timeout? */
					if (c == SM_IO_EOF && errno == EAGAIN
					    && smtpmode)
					{
						/*
						**  Override e_message in
						**  usrerr() as this is the
						**  reason for failure that
						**  should be logged for
						**  undelivered recipients.
						*/

						e->e_message = NULL;
						errno = 0;
						inputerr = true;
						goto readabort;
					}
d395 1
a540 12
				if (buflen <= 0)
				{
					sm_syslog(LOG_NOTICE, e->e_id,
						  "header overflow from %s during message collect",
						  CURHOSTNAME);
					errno = 0;
					e->e_flags |= EF_CLRQUEUE;
					e->e_status = "5.6.0";
					usrerrenh(e->e_status,
						  "552 Headers too large");
					goto discard;
				}
a583 1
  discard:
a622 18

				/* timeout? */
				if (c == SM_IO_EOF && errno == EAGAIN
				    && smtpmode)
				{
					/*
					**  Override e_message in
					**  usrerr() as this is the
					**  reason for failure that
					**  should be logged for
					**  undelivered recipients.
					*/

					e->e_message = NULL;
					errno = 0;
					inputerr = true;
					goto readabort;
				}
d632 1
a633 5

			/* guaranteed by isheader(buf) */
			SM_ASSERT(*(bp - 1) != '\n' || bp > buf + 1);

			/* trim off trailing CRLF or NL */
d699 4
a787 1
  readabort:
d810 1
a810 1
			usrerr("421 4.4.1 collect: %s on connection from %s, from=%s",
d814 1
a814 1
			syserr("421 4.4.1 collect: %s on connection from %s, from=%s",
a816 1
		flush_errors(true);
d909 33
@


1.17
log
@Update to sendmail.8.13.0
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: collect.c,v 8.254 2004/04/05 18:41:38 ca Exp $")
d18 1
a18 1
static void	collecttimeout __P((time_t));
d293 1
a293 1
	volatile time_t dbto;
d311 1
a311 1
	dbto = smtpmode ? TimeOuts.to_datablock : 0;
d528 2
a534 3
				if (mstate != MS_HEADER)
					break;

d911 1
a911 1
	time_t timeout;
@


1.16
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: collect.c,v 8.242.2.8 2003/07/08 01:16:35 ca Exp $")
a18 1
static void	dferror __P((SM_FILE_T *volatile, char *, ENVELOPE *));
d726 3
a728 1
	else if (SuperSafe != SAFE_REALLY)
d747 1
a747 1
			syserr("@@collect: bfcommit(%s): already on disk, size = %ld",
d758 8
a765 2
	else if ((afd = sm_io_getinfo(df, SM_IO_WHAT_FD, NULL)) >= 0 &&
		 fsync(afd) < 0)
d883 1
a883 1
					   SM_IO_RDONLY, NULL)) == NULL)
a905 4
		if (tTd(90, 1))
			sm_syslog(LOG_INFO, e->e_id,
				"collect: at end: msgsize=%ld, msgpriority=%ld",
				e->e_msgsize, e->e_msgpriority);
d964 1
a964 1
static void
d995 1
a995 1
				    SM_IO_WRONLY, NULL, df);
@


1.15
log
@Update to sendmail 8.12.9; fixes a buffer overflow in address parsing
due to a char to int conversion problem which is potentially remotely
exploitable.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: collect.c,v 8.242.2.4 2003/03/28 17:34:39 ca Exp $")
d220 1
a220 1
		finis(true, true, ExitStat);
d250 1
d285 1
a285 1
collect(fp, smtpmode, hdrp, e)
d290 1
d371 2
a372 1
	e->e_msgsize = 0;
d889 14
d904 1
d1040 1
@


1.14
log
@update to sendmail 8.12.7
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: collect.c,v 8.242.2.3 2002/12/03 17:06:30 gshapiro Exp $")
d447 1
d459 1
d465 2
d632 1
@


1.13
log
@update to sendmail-8.12.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: collect.c,v 8.242.2.2 2002/08/16 14:56:01 ca Exp $")
d353 10
@


1.13.2.1
log
@Errata #14
Fix by millert@@
Fix a buffer overflow in address parsing due to a char to int conversion
problem which is potentially remotely exploitable.
@
text
@a436 1
					SM_ASSERT(pbp < peekbuf + sizeof(peekbuf));
a447 1
					SM_ASSERT(pbp < peekbuf + sizeof(peekbuf));
a617 1
			SM_ASSERT(bp > buf);
@


1.12
log
@Update to sendmail-8.12.4
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: collect.c,v 8.242 2002/05/10 15:40:09 ca Exp $")
d63 2
a64 2
	(void) rscheck("check_eoh", hnum, hsize, e, false, true, 3, NULL,
			e->e_id);
d768 1
d798 8
@


1.11
log
@update to sendmail 8.12.3
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: collect.c,v 8.241 2002/03/15 01:32:47 gshapiro Exp $")
d983 1
a983 1
			dfname, msg, geteuid(), getegid());
@


1.10
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: collect.c,v 8.237 2001/12/10 19:56:03 ca Exp $")
a106 4
	/* collect statistics */
	if (OpMode != MD_VERIFY)
		markstats(e, (ADDRESS *) NULL, STATS_NORMAL);

d430 3
a432 2
				else if (c != '.' ||
					 (OpMode != MD_SMTP &&
d435 1
d449 9
a457 2
					*pbp++ = '\r';
					c = '.';
d859 4
@


1.10.2.1
log
@Errata #027 (millert)
Fix a buffer overflow in address parsing due to a char to int conversion
problem which is potentially remotely exploitable.
@
text
@a438 1
					SM_ASSERT(pbp < peekbuf + sizeof(peekbuf));
a449 1
					SM_ASSERT(pbp < peekbuf + sizeof(peekbuf));
a612 1
			SM_ASSERT(bp > buf);
@


1.9
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: collect.c,v 8.232 2001/09/11 04:05:12 gshapiro Exp $")
d109 1
a109 1
		markstats(e, (ADDRESS *) NULL, false);
d224 1
a224 1
		finis(true, ExitStat);
a234 1
	e->e_msgsize = 0;
d363 1
d527 11
d701 1
a701 1
		finis(true, ExitStat);
d732 1
a732 1
		finis(save_errno != EEXIST, ExitStat);
d739 1
a739 1
		finis(true, ExitStat);
d746 1
a746 1
		finis(true, ExitStat);
d793 1
a793 1
		finis(true, ExitStat);
d848 1
a848 1
			finis(true, ExitStat);
@


1.8
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: collect.c,v 8.228 2001/09/04 22:43:02 ca Exp $")
d212 1
a212 1
	dfname = queuename(e, 'd');
d240 1
a240 1
/*
d708 1
a708 1
			dfile = queuename(e, 'd');
d831 1
a831 1
		char *dfname = queuename(e, 'd');
d878 1
a878 1
/*
d907 1
a907 1
	dfname = queuename(e, 'd');
d970 1
a970 1
/*
@


1.7
log
@Prevent logging strerror(0) on EOF; patch sent to sendmail-bugs@@sendmail.ORG
@
text
@a13 4
#ifndef lint
static char id[] = "@@(#)$Sendmail: collect.c,v 8.136.4.22 2001/06/07 21:01:02 ca Exp $";
#endif /* ! lint */

d16 1
d19 1
a19 1
static void	dferror __P((FILE *volatile, char *, ENVELOPE *));
d21 218
d260 9
a268 2
**		Temp file is created and filled.
**		The from person may be set.
d273 1
a273 1
static EVENT	*volatile CollectTimeout = NULL;
d290 1
a290 1
	FILE *fp;
d295 3
a297 3
	register FILE *volatile df;
	volatile bool ignrdot = smtpmode ? FALSE : IgnrDot;
	volatile time_t dbto = smtpmode ? TimeOuts.to_datablock : 0;
d299 2
a300 2
	volatile int c = EOF;
	volatile bool inputerr = FALSE;
d306 5
a310 9
	volatile int hdrslen = 0;
	volatile int numhdrs = 0;
	volatile int dfd;
	volatile int rstat = EX_OK;
	u_char *volatile pbp;
	u_char peekbuf[8];
	char hsize[16];
	char hnum[16];
	char dfname[MAXPATHLEN];
d313 5
d319 9
a327 49

	/*
	**  Create the temp file name and create the file.
	*/

	if (!headeronly)
	{
		struct stat stbuf;
		long sff = SFF_OPENASROOT;


		(void) strlcpy(dfname, queuename(e, 'd'), sizeof dfname);
#if _FFR_QUEUE_FILE_MODE
		{
			MODE_T oldumask;

			if (bitset(S_IWGRP, QueueFileMode))
				oldumask = umask(002);
			df = bfopen(dfname, QueueFileMode,
				    DataFileBufferSize, sff);
			if (bitset(S_IWGRP, QueueFileMode))
				(void) umask(oldumask);
		}
#else /* _FFR_QUEUE_FILE_MODE */
		df = bfopen(dfname, FileMode, DataFileBufferSize, sff);
#endif /* _FFR_QUEUE_FILE_MODE */
		if (df == NULL)
		{
			HoldErrs = FALSE;
			if (smtpmode)
				syserr("421 4.3.5 Unable to create data file");
			else
				syserr("Cannot create %s", dfname);
			e->e_flags |= EF_NO_BODY_RETN;
			finis(TRUE, ExitStat);
			/* NOTREACHED */
		}
		dfd = fileno(df);
		if (dfd < 0 || fstat(dfd, &stbuf) < 0)
			e->e_dfino = -1;
		else
		{
			e->e_dfdev = stbuf.st_dev;
			e->e_dfino = stbuf.st_ino;
		}
		HasEightBits = FALSE;
		e->e_msgsize = 0;
		e->e_flags |= EF_HAS_DF;
	}
d337 1
a337 1
		dprintf("collect\n");
a347 7
	buf = bp = bufbuf;
	buflen = sizeof bufbuf;
	pbp = peekbuf;
	istate = IS_BOL;
	mstate = SaveFrom ? MS_HEADER : MS_UFROM;
	CollectProgress = FALSE;

d355 2
a356 2
				    "timeout waiting for input from %s during message collect",
				    CurHostName ? CurHostName : "<local machine>");
d361 1
a361 1
		CollectTimeout = setevent(dbto, collecttimeout, dbto);
d367 2
a368 1
			dprintf("top, istate=%d, mstate=%d\n", istate, mstate);
d375 1
a375 1
				while (!feof(fp) && !ferror(fp))
d378 2
a379 3
					c = getc(fp);

					if (c == EOF && errno == EINTR)
d382 1
a382 1
						clearerr(fp);
d387 1
a387 1
				CollectProgress = TRUE;
d391 8
a398 6
						(void) fprintf(TrafficLogFile,
							       "%05d <<< ",
							       (int) getpid());
					if (c == EOF)
						(void) fprintf(TrafficLogFile,
							       "[EOF]\n");
d400 3
a402 1
						(void) putc(c, TrafficLogFile);
d404 1
a404 1
				if (c == EOF)
d412 1
a412 1
				dprintf("istate=%d, c=%c (0x%x)\n",
d461 2
a462 1
					(void) ungetc(c, fp);
d474 2
a475 1
			else if (c == '\n' && !bitset(EF_NL_NOT_EOL, e->e_flags))
d498 3
a500 1
					(void) putc(c, df);
d525 1
a525 1
					sm_free(obuf);
d529 1
a529 1
#if 0	/* causes complaints -- figure out something for 8.11 */
d538 1
a538 1
				hdrslen++;
d546 1
a546 1
						  CurHostName != NULL ? CurHostName : "localhost");
d563 1
a563 1
			dprintf("nextstate, istate=%d, mstate=%d, line = \"%s\"\n",
d589 1
a589 1
				clearerr(fp);
d591 4
a594 4
				c = getc(fp);
			} while (c == EOF && errno == EINTR);
			if (c != EOF)
				(void) ungetc(c, fp);
d618 1
a618 1
				dprintf("EOH\n");
d623 3
a625 8
			/* call the end-of-header check ruleset */
			snprintf(hnum, sizeof hnum, "%d", numhdrs);
			snprintf(hsize, sizeof hsize, "%d", hdrslen);
			if (tTd(30, 10))
				dprintf("collect: rscheck(\"check_eoh\", \"%s $| %s\")\n",
					hnum, hsize);
			rstat = rscheck("check_eoh", hnum, hsize, e, FALSE,
					TRUE, 4, NULL);
d642 2
a643 1
					(void) putc(*bp++, df);
d651 1
a651 1
	if ((feof(fp) && smtpmode) || ferror(fp))
d655 1
a655 1
		if (feof(fp))
d658 1
a658 2
			errmsg = errstring(errno);

d660 2
a661 2
			dprintf("collect: premature EOM: %s\n", errmsg);
		if (LogLevel >= 2)
d664 1
a664 1
		inputerr = TRUE;
d669 1
a669 1
		clrevent(CollectTimeout);
d674 7
d686 1
a686 1
	else if (fflush(df) != 0 || ferror(df))
d688 3
a690 3
		dferror(df, "fflush||ferror", e);
		flush_errors(TRUE);
		finis(TRUE, ExitStat);
d693 1
a693 1
	else if (!SuperSafe)
d698 1
a698 1
	else if (bfcommit(df) < 0)
d706 1
d712 1
a712 1
			syserr("collect: bfcommit(%s): already on disk, size = %ld",
d714 1
a714 1
			dfd = fileno(df);
d716 1
a716 1
				dumpfd(dfd, TRUE, TRUE);
d720 1
a720 1
		flush_errors(TRUE);
d723 2
a724 1
	else if (bffsync(df) < 0)
d726 3
a728 3
		dferror(df, "bffsync", e);
		flush_errors(TRUE);
		finis(TRUE, ExitStat);
d731 1
a731 1
	else if (bfclose(df) < 0)
d733 3
a735 3
		dferror(df, "bfclose", e);
		flush_errors(TRUE);
		finis(TRUE, ExitStat);
d742 3
d757 1
a757 1
		if (feof(fp))
d759 1
a759 1
		else if (ferror(fp))
d763 1
a763 1
		if (LogLevel > 0 && feof(fp))
d765 4
a768 4
			    "collect: %s on connection from %.100s, sender=%s",
			    problem, host,
			    shortenstring(e->e_from.q_paddr, MAXSHORTSTR));
		if (feof(fp))
d782 1
a782 4
		/* and don't try to deliver the partial message either */
		if (InChild)
			ExitStat = EX_QUIT;
		finis(TRUE, ExitStat);
d786 2
a787 34
	/*
	**  Find out some information from the headers.
	**	Examples are who is the from person & the date.
	*/

	eatheader(e, TRUE);

	if (GrabTo && e->e_sendqueue == NULL)
		usrerr("No recipient addresses found in header");

	/* collect statistics */
	if (OpMode != MD_VERIFY)
		markstats(e, (ADDRESS *) NULL, FALSE);

	/*
	**  If we have a Return-Receipt-To:, turn it into a DSN.
	*/

	if (RrtImpliesDsn && hvalue("return-receipt-to", e->e_header) != NULL)
	{
		ADDRESS *q;

		for (q = e->e_sendqueue; q != NULL; q = q->q_next)
			if (!bitset(QHASNOTIFY, q->q_flags))
				q->q_flags |= QHASNOTIFY|QPINGONSUCCESS;
	}

	/*
	**  Add an Apparently-To: line if we have no recipient lines.
	*/

	if (hvalue("to", e->e_header) != NULL ||
	    hvalue("cc", e->e_header) != NULL ||
	    hvalue("apparently-to", e->e_header) != NULL)
d789 2
a790 42
		/* have a valid recipient header -- delete Bcc: headers */
		e->e_flags |= EF_DELETE_BCC;
	}
	else if (hvalue("bcc", e->e_header) == NULL)
	{
		/* no valid recipient headers */
		register ADDRESS *q;
		char *hdr = NULL;

		/* create an Apparently-To: field */
		/*    that or reject the message.... */
		switch (NoRecipientAction)
		{
		  case NRA_ADD_APPARENTLY_TO:
			hdr = "Apparently-To";
			break;

		  case NRA_ADD_TO:
			hdr = "To";
			break;

		  case NRA_ADD_BCC:
			addheader("Bcc", " ", 0, &e->e_header);
			break;

		  case NRA_ADD_TO_UNDISCLOSED:
			addheader("To", "undisclosed-recipients:;", 0, &e->e_header);
			break;
		}

		if (hdr != NULL)
		{
			for (q = e->e_sendqueue; q != NULL; q = q->q_next)
			{
				if (q->q_alias != NULL)
					continue;
				if (tTd(30, 3))
					dprintf("Adding %s: %s\n",
						hdr, q->q_paddr);
				addheader(hdr, q->q_paddr, 0, &e->e_header);
			}
		}
d797 11
a807 8
		e->e_status = "5.2.3";
		usrerrenh(e->e_status,
			  "552 Message exceeds maximum fixed size (%ld)",
			  MaxMessageSize);
		if (LogLevel > 6)
			sm_syslog(LOG_NOTICE, e->e_id,
				"message size (%ld) exceeds maximum (%ld)",
				e->e_msgsize, MaxMessageSize);
d825 1
a825 1
		    strcasecmp(e->e_bodytype, "8BITMIME") == 0)
d829 1
a829 1
	if (SuperSafe)
d831 3
a833 1
		if ((e->e_dfp = fopen(dfname, "r")) == NULL)
d836 2
a837 2
			syserr("Cannot reopen %s", dfname);
			finis(TRUE, ExitStat);
a842 2
	if (e->e_dfp == NULL)
		syserr("!collect: no e_dfp");
a844 1

d860 3
a862 3
		CollectTimeout = sigsafe_setevent(timeout, collecttimeout,
						  timeout);
		CollectProgress = FALSE;
a875 1

d881 5
d901 1
a901 1
	FILE *volatile df;
d923 1
a923 1
		    fstat64(fileno(df), &st)
d925 1
a925 1
		    fstat(fileno(df), &st)
d929 2
a930 1
		(void) freopen(dfname, "w", df);
d932 2
a933 5
			fprintf(df, "\n*** Mail could not be accepted");
		/*CONSTCOND*/
		else if (sizeof st.st_size > sizeof (long))
			fprintf(df, "\n*** Mail of at least %s bytes could not be accepted\n",
				quad_to_string(st.st_size));
d935 5
a939 3
			fprintf(df, "\n*** Mail of at least %lu bytes could not be accepted\n",
				(unsigned long) st.st_size);
		fprintf(df, "*** at %s due to lack of disk space for temp file.\n",
d941 2
a942 1
		avail = freediskspace(qid_printqueue(e->e_queuedir), &bsize);
d949 2
a950 1
			fprintf(df, "*** Currently, %ld kilobytes are available for mail temp files.\n",
d953 2
d957 3
d962 4
a965 3
		syserr("collect: Cannot write %s (%s, uid=%d)",
			dfname, msg, geteuid());
	if (freopen("/dev/null", "w", df) == NULL)
d967 2
a968 2
			  "dferror: freopen(\"/dev/null\") failed: %s",
			  errstring(errno));
d1010 1
a1010 1
		dprintf("eatfrom(%s)\n", fm);
d1048 1
a1048 1
		char *q;
d1051 3
a1053 4
		q = xalloc(25);
		(void) strlcpy(q, p, 25);
		q = arpadate(q);
		define('a', newstr(q), e);
@


1.6
log
@update to sendmail 8.11.5
@
text
@d473 6
a478 1
		const char *errmsg = errstring(errno);
d574 1
a574 1
			    "collect: %s on connection from %.100s, sender=%s: %s",
d576 1
a576 2
			    shortenstring(e->e_from.q_paddr, MAXSHORTSTR),
			    errstring(errno));
@


1.5
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: collect.c,v 8.136.4.21 2001/05/17 18:10:14 gshapiro Exp $";
d355 2
a356 1
				if (MaxHeadersLength > 0 &&
@


1.4
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: collect.c,v 8.136.4.15 2001/02/21 01:05:59 gshapiro Exp $";
d50 2
a51 2
static bool	CollectProgress;
static EVENT	*CollectTimeout;
d215 3
a217 2
						(void) fprintf(TrafficLogFile, "%05d <<< ",
							(int) getpid());
d219 2
a220 1
						(void) fprintf(TrafficLogFile, "[EOF]\n");
a316 1

d341 1
a341 1
					free(obuf);
d483 2
a484 1
	clrevent(CollectTimeout);
d726 25
a750 2
	/* if no progress was made, die now */
	if (!CollectProgress)
d752 1
d754 1
a754 3
	/* otherwise reset the timeout */
	CollectTimeout = setevent(timeout, collecttimeout, timeout);
	CollectProgress = FALSE;
d756 1
a756 1
/*
@


1.4.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: collect.c,v 8.136.4.21 2001/05/17 18:10:14 gshapiro Exp $";
d50 2
a51 2
static bool	volatile CollectProgress;
static EVENT	*volatile CollectTimeout = NULL;
d215 2
a216 3
						(void) fprintf(TrafficLogFile,
							       "%05d <<< ",
							       (int) getpid());
d218 1
a218 2
						(void) fprintf(TrafficLogFile,
							       "[EOF]\n");
d315 1
d340 1
a340 1
					sm_free(obuf);
d482 1
a482 2
	if (CollectTimeout != NULL)
		clrevent(CollectTimeout);
d724 2
a725 25
	int save_errno = errno;

	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	if (CollectProgress)
	{
		/* reset the timeout */
		CollectTimeout = sigsafe_setevent(timeout, collecttimeout,
						  timeout);
		CollectProgress = FALSE;
	}
	else
	{
		/* event is done */
		CollectTimeout = NULL;
	}

	/* if no progress was made or problem resetting event, die now */
	if (CollectTimeout == NULL)
	{
		errno = ETIMEDOUT;
a726 1
	}
d728 3
a730 1
	errno = save_errno;
d732 1
a732 1
/*
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: collect.c,v 8.136.4.8 2000/10/09 00:50:04 gshapiro Exp $";
a86 1
	volatile int afd;
d104 2
d114 2
a115 2
			df = bfopen(dfname, QueueFileMode, DataFileBufferSize,
				    SFF_OPENASROOT);
d120 1
a120 2
		df = bfopen(dfname, FileMode, DataFileBufferSize,
			    SFF_OPENASROOT);
d124 5
a128 1
			syserr("Cannot create %s", dfname);
d353 1
d355 1
a355 1
				    ++hdrslen > MaxHeadersLength)
a503 7
	else if ((afd = fileno(df)) >= 0 && fsync(afd) < 0)
	{
		dferror(df, "fsync", e);
		flush_errors(TRUE);
		finis(TRUE, ExitStat);
		/* NOTREACHED */
	}
d527 7
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: collect.c,v 8.136 2000/03/15 21:47:27 ca Exp $";
d20 1
a65 35
#if _FFR_MILTER
# define MILTER_EOH() \
{ \
	if (bitset(CHHDR_MILTER, chompflags) && \
	    rstat == EX_OK && \
	    !bitset(EF_DISCARD, e->e_flags)) \
	{ \
		char state; \
		char *response; \
 \
		response = milter_eoh(e, &state); \
		chompflags &= ~CHHDR_MILTER; \
		switch (state) \
		{ \
		  case SMFIR_REPLYCODE: \
			usrerr(response); \
			break; \
 \
		  case SMFIR_REJECT: \
			usrerr("554 5.7.1 Message rejected"); \
			break; \
 \
		  case SMFIR_DISCARD: \
			e->e_flags |= EF_DISCARD; \
			break; \
 \
		  case SMFIR_TEMPFAIL: \
			usrerr("451 4.7.1 Try again later"); \
			break; \
		} \
	} \
}
# endif /* _FFR_MILTER */


a87 1
	volatile int chompflags = CHHDR_CHECK|CHHDR_USER;
a146 1
	{
a147 4
#if _FFR_MILTER
		chompflags |= CHHDR_MILTER;
# endif /* _FFR_MILTER */
	}
d198 8
a205 3
					if (errno != EINTR)
						break;
					clearerr(fp);
d294 11
a304 1
				e->e_msgsize++;
d309 1
a309 2
				if (MaxMessageSize <= 0 ||
				    e->e_msgsize <= MaxMessageSize)
d401 1
a401 1
			} while (errno == EINTR);
d415 2
a416 1
			if (bitset(H_EOH, chompheader(buf, (int *)&chompflags,
d439 1
a439 12
					TRUE, 4);

#if _FFR_MILTER
			/*
			**  see if a header check already rejected
			**  this message or if the check_eoh call
			**  resulted in an error.  Also, don't call
			**  filters if we are discarding the message.
			*/

			MILTER_EOH();
# endif /* _FFR_MILTER */
d453 1
a453 2
			if (MaxMessageSize <= 0 ||
			    e->e_msgsize <= MaxMessageSize)
a475 9
#if _FFR_MILTER
	/*
	**  If the message was completely empty (no headers, no body),
	**  milter hasn't been sent the EOH so do it now.
	*/

	MILTER_EOH();
# endif /* _FFR_MILTER */

d520 1
a520 1
			       dfile, st.st_size);
d643 1
a643 1
			addheader("Bcc", " ", &e->e_header);
d647 1
a647 1
			addheader("To", "undisclosed-recipients:;", &e->e_header);
d660 1
a660 1
				addheader(hdr, q->q_paddr, &e->e_header);
d666 1
a666 1
	if (MaxMessageSize > 0 && e->e_msgsize > MaxMessageSize)
d857 5
d874 1
d877 1
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: collect.c,v 8.136.4.21 2001/05/17 18:10:14 gshapiro Exp $";
a19 1

d49 2
a50 2
static bool	volatile CollectProgress;
static EVENT	*volatile CollectTimeout = NULL;
d65 35
d121 2
a139 2
		long sff = SFF_OPENASROOT;

d148 2
a149 2
			df = bfopen(dfname, QueueFileMode,
				    DataFileBufferSize, sff);
d154 2
a155 1
		df = bfopen(dfname, FileMode, DataFileBufferSize, sff);
d159 1
a159 5
			HoldErrs = FALSE;
			if (smtpmode)
				syserr("421 4.3.5 Unable to create data file");
			else
				syserr("Cannot create %s", dfname);
d182 1
d184 4
d238 3
a240 8

					if (c == EOF && errno == EINTR)
					{
						/* Interrupted, retry */
						clearerr(fp);
						continue;
					}
					break;
d246 2
a247 3
						(void) fprintf(TrafficLogFile,
							       "%05d <<< ",
							       (int) getpid());
d249 1
a249 2
						(void) fprintf(TrafficLogFile,
							       "[EOF]\n");
d329 1
a329 11
			{
				/* no overflow? */
				if (e->e_msgsize >= 0)
				{
					e->e_msgsize++;
					if (MaxMessageSize > 0 &&
					    !bitset(EF_TOOBIG, e->e_flags) &&
					    e->e_msgsize > MaxMessageSize)
						 e->e_flags |= EF_TOOBIG;
				}
			}
d334 2
a335 1
				if (!bitset(EF_TOOBIG, e->e_flags))
d337 1
d362 1
a362 1
					sm_free(obuf);
a374 1
				hdrslen++;
d376 1
a376 1
				    hdrslen > MaxHeadersLength)
d427 1
a427 1
			} while (c == EOF && errno == EINTR);
d441 1
a441 2
			if (bitset(H_EOH, chompheader(buf,
						      CHHDR_CHECK | CHHDR_USER,
d464 12
a475 1
					TRUE, 4, NULL);
d489 2
a490 1
			if (!bitset(EF_TOOBIG, e->e_flags))
d513 9
d523 1
a523 2
	if (CollectTimeout != NULL)
		clrevent(CollectTimeout);
d545 7
d566 1
a566 1
			       dfile, (long) st.st_size);
a575 7
	else if (bffsync(df) < 0)
	{
		dferror(df, "bffsync", e);
		flush_errors(TRUE);
		finis(TRUE, ExitStat);
		/* NOTREACHED */
	}
d689 1
a689 1
			addheader("Bcc", " ", 0, &e->e_header);
d693 1
a693 1
			addheader("To", "undisclosed-recipients:;", 0, &e->e_header);
d706 1
a706 1
				addheader(hdr, q->q_paddr, 0, &e->e_header);
d712 1
a712 1
	if (bitset(EF_TOOBIG, e->e_flags))
d765 2
a766 25
	int save_errno = errno;

	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	if (CollectProgress)
	{
		/* reset the timeout */
		CollectTimeout = sigsafe_setevent(timeout, collecttimeout,
						  timeout);
		CollectProgress = FALSE;
	}
	else
	{
		/* event is done */
		CollectTimeout = NULL;
	}

	/* if no progress was made or problem resetting event, die now */
	if (CollectTimeout == NULL)
	{
		errno = ETIMEDOUT;
a767 1
	}
d769 3
a771 1
	errno = save_errno;
d773 1
a773 1
/*
a902 5
		if (strlen(p) < 17)
		{
			/* no room for the date */
			return;
		}
a914 1
		{
a916 1
		}
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: collect.c,v 8.135 2000/02/27 01:27:43 gshapiro Exp $";
d464 1
a464 1
					TRUE);
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Id: collect.c,v 8.136.4.8 2000/10/09 00:50:04 gshapiro Exp $";
a19 1

d65 35
d122 1
d182 1
d184 4
d238 3
a240 8

					if (c == EOF && errno == EINTR)
					{
						/* Interrupted, retry */
						clearerr(fp);
						continue;
					}
					break;
d329 1
a329 11
			{
				/* no overflow? */
				if (e->e_msgsize >= 0)
				{
					e->e_msgsize++;
					if (MaxMessageSize > 0 &&
					    !bitset(EF_TOOBIG, e->e_flags) &&
					    e->e_msgsize > MaxMessageSize)
						 e->e_flags |= EF_TOOBIG;
				}
			}
d334 2
a335 1
				if (!bitset(EF_TOOBIG, e->e_flags))
d427 1
a427 1
			} while (c == EOF && errno == EINTR);
d441 1
a441 2
			if (bitset(H_EOH, chompheader(buf,
						      CHHDR_CHECK | CHHDR_USER,
d464 12
a475 1
					TRUE, 4, NULL);
d489 2
a490 1
			if (!bitset(EF_TOOBIG, e->e_flags))
d513 9
d566 1
a566 1
			       dfile, (long) st.st_size);
d689 1
a689 1
			addheader("Bcc", " ", 0, &e->e_header);
d693 1
a693 1
			addheader("To", "undisclosed-recipients:;", 0, &e->e_header);
d706 1
a706 1
				addheader(hdr, q->q_paddr, 0, &e->e_header);
d712 1
a712 1
	if (bitset(EF_TOOBIG, e->e_flags))
a902 5
		if (strlen(p) < 17)
		{
			/* no room for the date */
			return;
		}
a914 1
		{
a916 1
		}
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d14 4
a19 1
SM_RCSID("@@(#)$Sendmail: collect.c,v 8.228 2001/09/04 22:43:02 ca Exp $")
d22 1
a22 1
static void	dferror __P((SM_FILE_T *volatile, char *, ENVELOPE *));
a23 218
static void	collect_doheader __P((ENVELOPE *));
static SM_FILE_T *collect_dfopen __P((ENVELOPE *));
static SM_FILE_T *collect_eoh __P((ENVELOPE *, int, int));

/*
**  COLLECT_EOH -- end-of-header processing in collect()
**
**	Called by collect() when it encounters the blank line
**	separating the header from the message body, or when it
**	encounters EOF in a message that contains only a header.
**
**	Parameters:
**		e -- envelope
**		numhdrs -- number of headers
**		hdrslen -- length of headers
**
**	Results:
**		NULL, or handle to open data file
**
**	Side Effects:
**		end-of-header check ruleset is invoked.
**		envelope state is updated.
**		headers may be added and deleted.
**		selects the queue.
**		opens the data file.
*/

static SM_FILE_T *
collect_eoh(e, numhdrs, hdrslen)
	ENVELOPE *e;
	int numhdrs;
	int hdrslen;
{
	char hnum[16];
	char hsize[16];

	/* call the end-of-header check ruleset */
	(void) sm_snprintf(hnum, sizeof hnum, "%d", numhdrs);
	(void) sm_snprintf(hsize, sizeof hsize, "%d", hdrslen);
	if (tTd(30, 10))
		sm_dprintf("collect: rscheck(\"check_eoh\", \"%s $| %s\")\n",
			   hnum, hsize);
	(void) rscheck("check_eoh", hnum, hsize, e, false, true, 3, NULL,
			e->e_id);

	/*
	**  Process the header,
	**  select the queue, open the data file.
	*/

	collect_doheader(e);
	return collect_dfopen(e);
}

/*
**  COLLECT_DOHEADER -- process header in collect()
**
**	Called by collect() after it has finished parsing the header,
**	but before it selects the queue and creates the data file.
**	The results of processing the header will affect queue selection.
**
**	Parameters:
**		e -- envelope
**
**	Results:
**		none.
**
**	Side Effects:
**		envelope state is updated.
**		headers may be added and deleted.
*/

static void
collect_doheader(e)
	ENVELOPE *e;
{
	/*
	**  Find out some information from the headers.
	**	Examples are who is the from person & the date.
	*/

	eatheader(e, true, false);

	if (GrabTo && e->e_sendqueue == NULL)
		usrerr("No recipient addresses found in header");

	/* collect statistics */
	if (OpMode != MD_VERIFY)
		markstats(e, (ADDRESS *) NULL, false);

	/*
	**  If we have a Return-Receipt-To:, turn it into a DSN.
	*/

	if (RrtImpliesDsn && hvalue("return-receipt-to", e->e_header) != NULL)
	{
		ADDRESS *q;

		for (q = e->e_sendqueue; q != NULL; q = q->q_next)
			if (!bitset(QHASNOTIFY, q->q_flags))
				q->q_flags |= QHASNOTIFY|QPINGONSUCCESS;
	}

	/*
	**  Add an appropriate recipient line if we have none.
	*/

	if (hvalue("to", e->e_header) != NULL ||
	    hvalue("cc", e->e_header) != NULL ||
	    hvalue("apparently-to", e->e_header) != NULL)
	{
		/* have a valid recipient header -- delete Bcc: headers */
		e->e_flags |= EF_DELETE_BCC;
	}
	else if (hvalue("bcc", e->e_header) == NULL)
	{
		/* no valid recipient headers */
		register ADDRESS *q;
		char *hdr = NULL;

		/* create a recipient field */
		switch (NoRecipientAction)
		{
		  case NRA_ADD_APPARENTLY_TO:
			hdr = "Apparently-To";
			break;

		  case NRA_ADD_TO:
			hdr = "To";
			break;

		  case NRA_ADD_BCC:
			addheader("Bcc", " ", 0, e);
			break;

		  case NRA_ADD_TO_UNDISCLOSED:
			addheader("To", "undisclosed-recipients:;", 0, e);
			break;
		}

		if (hdr != NULL)
		{
			for (q = e->e_sendqueue; q != NULL; q = q->q_next)
			{
				if (q->q_alias != NULL)
					continue;
				if (tTd(30, 3))
					sm_dprintf("Adding %s: %s\n",
						hdr, q->q_paddr);
				addheader(hdr, q->q_paddr, 0, e);
			}
		}
	}
}

/*
**  COLLECT_DFOPEN -- open the message data file
**
**	Called by collect() after it has finished processing the header.
**	Queue selection occurs at this point, possibly based on the
**	envelope's recipient list and on header information.
**
**	Parameters:
**		e -- envelope
**
**	Results:
**		NULL, or a pointer to an open data file,
**		into which the message body will be written by collect().
**
**	Side Effects:
**		Calls syserr, sets EF_FATALERRS and returns NULL
**		if there is insufficient disk space.
**		Aborts process if data file could not be opened.
**		Otherwise, the queue is selected,
**		e->e_{dfino,dfdev,msgsize,flags} are updated,
**		and a pointer to an open data file is returned.
*/

static SM_FILE_T *
collect_dfopen(e)
	ENVELOPE *e;
{
	MODE_T oldumask = 0;
	int dfd;
	struct stat stbuf;
	SM_FILE_T *df;
	char *dfname;

	if (!setnewqueue(e))
		return NULL;

	dfname = queuename(e, 'd');
	if (bitset(S_IWGRP, QueueFileMode))
		oldumask = umask(002);
	df = bfopen(dfname, QueueFileMode, DataFileBufferSize,
		    SFF_OPENASROOT);
	if (bitset(S_IWGRP, QueueFileMode))
		(void) umask(oldumask);
	if (df == NULL)
	{
		syserr("@@Cannot create %s", dfname);
		e->e_flags |= EF_NO_BODY_RETN;
		flush_errors(true);
		finis(true, ExitStat);
		/* NOTREACHED */
	}
	dfd = sm_io_getinfo(df, SM_IO_WHAT_FD, NULL);
	if (dfd < 0 || fstat(dfd, &stbuf) < 0)
		e->e_dfino = -1;
	else
	{
		e->e_dfdev = stbuf.st_dev;
		e->e_dfino = stbuf.st_ino;
	}
	e->e_msgsize = 0;
	e->e_flags |= EF_HAS_DF;
	return df;
}
d45 2
a46 9
**		If successful,
**		- Data file is created and filled, and e->e_dfp is set.
**		- The from person may be set.
**		If the "enough disk space" check fails,
**		- syserr is called.
**		- e->e_dfp is NULL.
**		- e->e_flags & EF_FATALERRS is set.
**		- collect() returns.
**		If data file cannot be created, the process is terminated.
d50 2
a51 2
static bool	volatile CollectProgress;
static SM_EVENT	*volatile CollectTimeout = NULL;
d68 1
a68 1
	SM_FILE_T *fp;
d73 3
a75 3
	register SM_FILE_T *volatile df;
	volatile bool ignrdot;
	volatile time_t dbto;
d77 2
a78 2
	volatile int c;
	volatile bool inputerr;
d84 3
a86 2
	volatile int hdrslen;
	volatile int numhdrs;
d88 6
a93 2
	unsigned char *volatile pbp;
	unsigned char peekbuf[8];
a95 5
	df = NULL;
	ignrdot = smtpmode ? false : IgnrDot;
	dbto = smtpmode ? TimeOuts.to_datablock : 0;
	c = SM_IO_EOF;
	inputerr = false;
d97 44
a140 9
	hdrslen = 0;
	numhdrs = 0;
	HasEightBits = false;
	buf = bp = bufbuf;
	buflen = sizeof bufbuf;
	pbp = peekbuf;
	istate = IS_BOL;
	mstate = SaveFrom ? MS_HEADER : MS_UFROM;
	CollectProgress = false;
d150 1
a150 1
		sm_dprintf("collect\n");
d161 7
d175 2
a176 2
					  "timeout waiting for input from %s during message collect",
					  CURHOSTNAME);
d181 1
a181 1
		CollectTimeout = sm_setevent(dbto, collecttimeout, dbto);
d187 1
a187 2
			sm_dprintf("top, istate=%d, mstate=%d\n", istate,
				   mstate);
d194 1
a194 1
				while (!sm_io_eof(fp) && !sm_io_error(fp))
d197 3
a199 2
					c = sm_io_getc(fp, SM_TIME_DEFAULT);
					if (c == SM_IO_EOF && errno == EINTR)
d202 1
a202 1
						sm_io_clearerr(fp);
d207 1
a207 1
				CollectProgress = true;
d211 4
a214 8
						(void) sm_io_fprintf(TrafficLogFile,
							SM_TIME_DEFAULT,
							"%05d <<< ",
							(int) CurrentPid);
					if (c == SM_IO_EOF)
						(void) sm_io_fprintf(TrafficLogFile,
							SM_TIME_DEFAULT,
							"[EOF]\n");
d216 1
a216 3
						(void) sm_io_putc(TrafficLogFile,
							SM_TIME_DEFAULT,
							c);
d218 1
a218 1
				if (c == SM_IO_EOF)
d226 1
a226 1
				sm_dprintf("istate=%d, c=%c (0x%x)\n",
d275 1
a275 2
					(void) sm_io_ungetc(fp, SM_TIME_DEFAULT,
							    c);
d287 1
a287 2
			else if (c == '\n' && !bitset(EF_NL_NOT_EOL,
						      e->e_flags))
d310 1
a310 2
					(void) sm_io_putc(df, SM_TIME_DEFAULT,
							  c);
d336 1
a336 1
					sm_free(obuf);  /* XXX */
d340 1
a340 1
#if 0	/* causes complaints -- figure out something for 8.n+1 */
d349 2
a350 4
				++hdrslen;
				if (!headeronly &&
				    MaxHeadersLength > 0 &&
				    hdrslen > MaxHeadersLength)
d355 1
a355 1
						  CURHOSTNAME);
d372 1
a372 1
			sm_dprintf("nextstate, istate=%d, mstate=%d, line = \"%s\"\n",
d398 1
a398 1
				sm_io_clearerr(fp);
d400 4
a403 4
				c = sm_io_getc(fp, SM_TIME_DEFAULT);
			} while (c == SM_IO_EOF && errno == EINTR);
			if (c != SM_IO_EOF)
				(void) sm_io_ungetc(fp, SM_TIME_DEFAULT, c);
d427 1
a427 1
				sm_dprintf("EOH\n");
d432 8
a439 3
			df = collect_eoh(e, numhdrs, hdrslen);
			if (df == NULL)
				e->e_flags |= EF_TOOBIG;
d456 1
a456 2
					(void) sm_io_putc(df, SM_TIME_DEFAULT,
							  *bp++);
d464 1
a464 1
	if ((sm_io_eof(fp) && smtpmode) || sm_io_error(fp))
d466 1
a466 1
		const char *errmsg;
a467 4
		if (sm_io_eof(fp))
			errmsg = "unexpected close";
		else
			errmsg = sm_errstring(errno);
d469 2
a470 2
			sm_dprintf("collect: premature EOM: %s\n", errmsg);
		if (LogLevel > 1)
d473 1
a473 1
		inputerr = true;
d477 1
a477 2
	if (CollectTimeout != NULL)
		sm_clrevent(CollectTimeout);
a481 7
	if (mstate != MS_BODY)
	{
		/* no body or discard, so we never opened the data file */
		SM_ASSERT(df == NULL);
		df = collect_eoh(e, numhdrs, hdrslen);
	}

d487 1
a487 1
	else if (sm_io_flush(df, SM_TIME_DEFAULT) != 0 || sm_io_error(df))
d489 3
a491 3
		dferror(df, "sm_io_flush||sm_io_error", e);
		flush_errors(true);
		finis(true, ExitStat);
d494 1
a494 1
	else if (SuperSafe != SAFE_REALLY)
d499 8
a506 1
	else if (sm_io_setinfo(df, SM_BF_COMMIT, NULL) < 0 && errno != EINVAL)
a513 1
			int dfd;
d519 1
a519 1
			syserr("@@collect: bfcommit(%s): already on disk, size = %ld",
d521 1
a521 1
			dfd = sm_io_getinfo(df, SM_IO_WHAT_FD, NULL);
d523 1
a523 1
				dumpfd(dfd, true, true);
d527 1
a527 1
		flush_errors(true);
d530 1
a530 2
	else if ((afd = sm_io_getinfo(df, SM_IO_WHAT_FD, NULL)) >= 0 &&
		 fsync(afd) < 0)
d532 3
a534 10
		dferror(df, "fsync", e);
		flush_errors(true);
		finis(true, ExitStat);
		/* NOTREACHED */
	}
	else if (sm_io_close(df, SM_TIME_DEFAULT) < 0)
	{
		dferror(df, "sm_io_close", e);
		flush_errors(true);
		finis(true, ExitStat);
a540 3

		/* remove from available space in filesystem */
		updfs(e, false, true);
d553 1
a553 1
		if (sm_io_eof(fp))
d555 1
a555 1
		else if (sm_io_error(fp))
d559 1
a559 1
		if (LogLevel > 0 && sm_io_eof(fp))
d561 5
a565 4
				"collect: %s on connection from %.100s, sender=%s",
				problem, host,
				shortenstring(e->e_from.q_paddr, MAXSHORTSTR));
		if (sm_io_eof(fp))
d579 4
a582 1
		finis(true, ExitStat);
d586 34
a619 2
	/* Log collection information. */
	if (bitset(EF_LOGSENDER, e->e_flags) && LogLevel > 4)
d621 42
a662 2
		logsender(e, e->e_msgid);
		e->e_flags &= ~EF_LOGSENDER;
d669 8
a676 11
		if (!bitset(EF_FATALERRS, e->e_flags))
		{
			e->e_status = "5.2.3";
			usrerrenh(e->e_status,
				"552 Message exceeds maximum fixed size (%ld)",
				MaxMessageSize);
			if (LogLevel > 6)
				sm_syslog(LOG_NOTICE, e->e_id,
					"message size (%ld) exceeds maximum (%ld)",
					e->e_msgsize, MaxMessageSize);
		}
d694 1
a694 1
		    sm_strcasecmp(e->e_bodytype, "8BITMIME") == 0)
d698 1
a698 1
	if (SuperSafe == SAFE_REALLY && !bitset(EF_FATALERRS, e->e_flags))
d700 1
a700 3
		char *dfname = queuename(e, 'd');
		if ((e->e_dfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, dfname,
					   SM_IO_RDONLY, NULL)) == NULL)
d703 2
a704 2
			syserr("@@Cannot reopen %s", dfname);
			finis(true, ExitStat);
d710 2
d714 1
d719 3
a721 20
	int save_errno = errno;

	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	if (CollectProgress)
	{
		/* reset the timeout */
		CollectTimeout = sm_sigsafe_setevent(timeout, collecttimeout,
						     timeout);
		CollectProgress = false;
	}
	else
	{
		/* event is done */
		CollectTimeout = NULL;
	}
d723 3
a725 7
	/* if no progress was made or problem resetting event, die now */
	if (CollectTimeout == NULL)
	{
		errno = ETIMEDOUT;
		longjmp(CtxCollectTimeout, 1);
	}
	errno = save_errno;
d727 1
a727 1
/*
a729 5
**	Called by collect().  Collect() always terminates the process
**	immediately after calling dferror(), which means that the SMTP
**	session will be terminated, which means that any error message
**	issued by dferror must be a 421 error, as per RFC 821.
**
d745 1
a745 1
	SM_FILE_T *volatile df;
d767 1
a767 1
		    fstat64(sm_io_getinfo(df, SM_IO_WHAT_FD, NULL), &st)
d769 1
a769 1
		    fstat(sm_io_getinfo(df, SM_IO_WHAT_FD, NULL), &st)
d773 1
a773 2
		(void) sm_io_reopen(SmFtStdio, SM_TIME_DEFAULT, dfname,
				    SM_IO_WRONLY, NULL, df);
d775 5
a779 2
			(void) sm_io_fprintf(df, SM_TIME_DEFAULT,
				"\n*** Mail could not be accepted");
d781 3
a783 5
			(void) sm_io_fprintf(df, SM_TIME_DEFAULT,
				"\n*** Mail of at least %llu bytes could not be accepted\n",
				(ULONGLONG_T) st.st_size);
		(void) sm_io_fprintf(df, SM_TIME_DEFAULT,
			"*** at %s due to lack of disk space for temp file.\n",
d785 1
a785 2
		avail = freediskspace(qid_printqueue(e->e_qgrp, e->e_qdir),
				      &bsize);
d792 1
a792 2
			(void) sm_io_fprintf(df, SM_TIME_DEFAULT,
				"*** Currently, %ld kilobytes are available for mail temp files.\n",
a794 2
#if 0
		/* Wrong response code; should be 421. */
a796 3
#else /* 0 */
		syserr("421 4.3.1 Out of disk space for temp file");
#endif /* 0 */
d799 3
a801 4
		syserr("421 4.3.0 collect: Cannot write %s (%s, uid=%d, gid=%d)",
			dfname, msg, geteuid(), getegid());
	if (sm_io_reopen(SmFtStdio, SM_TIME_DEFAULT, SM_PATH_DEVNULL,
			 SM_IO_WRONLY, NULL, df) == NULL)
d803 2
a804 2
			  "dferror: sm_io_reopen(\"/dev/null\") failed: %s",
			  sm_errstring(errno));
d846 1
a846 1
		sm_dprintf("eatfrom(%s)\n", fm);
d884 1
a884 1
		char *q, buf[25];
d887 4
a890 3
		(void) sm_strlcpy(buf, p, sizeof(buf));
		q = arpadate(buf);
		macdefine(&e->e_macro, A_TEMP, 'a', q);
@


