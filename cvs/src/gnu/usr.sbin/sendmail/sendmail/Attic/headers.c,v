head	1.26;
access;
symbols
	OPENBSD_5_6:1.25.0.6
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.24.0.4
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.12
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.10
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.6
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.8
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.21.0.4
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.17.0.6
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.4
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.12.0.4
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.25;
commitid	M7i5giHIoz3DMlTU;

1.25
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2012.12.26.11.44.12;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2011.05.17.15.54.23;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2008.05.04.18.34.05;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.04.14.43.48;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2006.08.13.13.01.48;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.22.18.43.55;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.16.00.21.30;	author millert;	state Exp;
branches
	1.17.2.1
	1.17.4.1
	1.17.6.1;
next	1.16;

1.16
date	2004.09.18.04.08.34;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.24.03.59.27;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.19.01.41.13;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.17.17.31.40;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.29.19.44.00;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.03.17.31.21;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.01.19.59.22;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.15.02.23.35;	author millert;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.10.01.17.18.30;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.29.01.31.15;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.28.02.43.54;	author millert;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.01.15.21.09.08;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.07.19.20.41;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.45;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.45;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.13;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.50;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.31.34;	author miod;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.31.01.47.56;	author jason;	state Exp;
branches;
next	;

1.8.2.1
date	2003.03.03.17.16.59;	author miod;	state Exp;
branches;
next	;

1.9.2.1
date	2003.03.03.17.19.45;	author brad;	state Exp;
branches;
next	;

1.17.2.1
date	2006.03.24.05.42.48;	author brad;	state Exp;
branches;
next	;

1.17.4.1
date	2006.03.24.05.56.18;	author brad;	state Exp;
branches;
next	;

1.17.6.1
date	2006.03.25.01.49.37;	author brad;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2004, 2006, 2007 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>
#include <sm/sendmail.h>

SM_RCSID("@@(#)$Sendmail: headers.c,v 8.320 2013/11/22 20:51:55 ca Exp $")

static HDR	*allocheader __P((char *, char *, int, SM_RPOOL_T *, bool));
static size_t	fix_mime_header __P((HDR *, ENVELOPE *));
static int	priencode __P((char *));
static bool	put_vanilla_header __P((HDR *, char *, MCI *));

/*
**  SETUPHEADERS -- initialize headers in symbol table
**
**	Parameters:
**		none
**
**	Returns:
**		none
*/

void
setupheaders()
{
	struct hdrinfo *hi;
	STAB *s;

	for (hi = HdrInfo; hi->hi_field != NULL; hi++)
	{
		s = stab(hi->hi_field, ST_HEADER, ST_ENTER);
		s->s_header.hi_flags = hi->hi_flags;
		s->s_header.hi_ruleset = NULL;
	}
}

/*
**  DOCHOMPHEADER -- process and save a header line.
**
**	Called by chompheader.
**
**	Parameters:
**		line -- header as a text line.
**		pflag -- flags for chompheader() (from sendmail.h)
**		hdrp -- a pointer to the place to save the header.
**		e -- the envelope including this header.
**
**	Returns:
**		flags for this header.
**
**	Side Effects:
**		The header is saved on the header list.
**		Contents of 'line' are destroyed.
*/

static struct hdrinfo	NormalHeader =	{ NULL, 0, NULL };
static unsigned long	dochompheader __P((char *, int, HDR **, ENVELOPE *));

static unsigned long
dochompheader(line, pflag, hdrp, e)
	char *line;
	int pflag;
	HDR **hdrp;
	ENVELOPE *e;
{
	unsigned char mid = '\0';
	register char *p;
	register HDR *h;
	HDR **hp;
	char *fname;
	char *fvalue;
	bool cond = false;
	bool dropfrom;
	bool headeronly;
	STAB *s;
	struct hdrinfo *hi;
	bool nullheader = false;
	BITMAP256 mopts;

	headeronly = hdrp != NULL;
	if (!headeronly)
		hdrp = &e->e_header;

	/* strip off options */
	clrbitmap(mopts);
	p = line;
	if (!bitset(pflag, CHHDR_USER) && *p == '?')
	{
		int c;
		register char *q;

		q = strchr(++p, '?');
		if (q == NULL)
			goto hse;

		*q = '\0';
		c = *p & 0377;

		/* possibly macro conditional */
		if (c == MACROEXPAND)
		{
			/* catch ?$? */
			if (*++p == '\0')
			{
				*q = '?';
				goto hse;
			}

			mid = (unsigned char) *p++;

			/* catch ?$abc? */
			if (*p != '\0')
			{
				*q = '?';
				goto hse;
			}
		}
		else if (*p == '$')
		{
			/* catch ?$? */
			if (*++p == '\0')
			{
				*q = '?';
				goto hse;
			}

			mid = (unsigned char) macid(p);
			if (bitset(0200, mid))
			{
				p += strlen(macname(mid)) + 2;
				SM_ASSERT(p <= q);
			}
			else
				p++;

			/* catch ?$abc? */
			if (*p != '\0')
			{
				*q = '?';
				goto hse;
			}
		}
		else
		{
			while (*p != '\0')
			{
				if (!isascii(*p))
				{
					*q = '?';
					goto hse;
				}

				setbitn(bitidx(*p), mopts);
				cond = true;
				p++;
			}
		}
		p = q + 1;
	}

	/* find canonical name */
	fname = p;
	while (isascii(*p) && isgraph(*p) && *p != ':')
		p++;
	fvalue = p;
	while (isascii(*p) && isspace(*p))
		p++;
	if (*p++ != ':' || fname == fvalue)
	{
hse:
		syserr("553 5.3.0 header syntax error, line \"%s\"", line);
		return 0;
	}
	*fvalue = '\0';
	fvalue = p;

	/* if the field is null, go ahead and use the default */
	while (isascii(*p) && isspace(*p))
		p++;
	if (*p == '\0')
		nullheader = true;

	/* security scan: long field names are end-of-header */
	if (strlen(fname) > 100)
		return H_EOH;

	/* check to see if it represents a ruleset call */
	if (bitset(pflag, CHHDR_DEF))
	{
		char hbuf[50];

		(void) expand(fvalue, hbuf, sizeof(hbuf), e);
		for (p = hbuf; isascii(*p) && isspace(*p); )
			p++;
		if ((*p++ & 0377) == CALLSUBR)
		{
			auto char *endp;
			bool strc;

			strc = *p == '+';	/* strip comments? */
			if (strc)
				++p;
			if (strtorwset(p, &endp, ST_ENTER) > 0)
			{
				*endp = '\0';
				s = stab(fname, ST_HEADER, ST_ENTER);
				if (LogLevel > 9 &&
				    s->s_header.hi_ruleset != NULL)
					sm_syslog(LOG_WARNING, NOQID,
						  "Warning: redefined ruleset for header=%s, old=%s, new=%s",
						  fname,
						  s->s_header.hi_ruleset, p);
				s->s_header.hi_ruleset = newstr(p);
				if (!strc)
					s->s_header.hi_flags |= H_STRIPCOMM;
			}
			return 0;
		}
	}

	/* see if it is a known type */
	s = stab(fname, ST_HEADER, ST_FIND);
	if (s != NULL)
		hi = &s->s_header;
	else
		hi = &NormalHeader;

	if (tTd(31, 9))
	{
		if (s == NULL)
			sm_dprintf("no header flags match\n");
		else
			sm_dprintf("header match, flags=%lx, ruleset=%s\n",
				   hi->hi_flags,
				   hi->hi_ruleset == NULL ? "<NULL>"
							  : hi->hi_ruleset);
	}

	/* see if this is a resent message */
	if (!bitset(pflag, CHHDR_DEF) && !headeronly &&
	    bitset(H_RESENT, hi->hi_flags))
		e->e_flags |= EF_RESENT;

	/* if this is an Errors-To: header keep track of it now */
	if (UseErrorsTo && !bitset(pflag, CHHDR_DEF) && !headeronly &&
	    bitset(H_ERRORSTO, hi->hi_flags))
		(void) sendtolist(fvalue, NULLADDR, &e->e_errorqueue, 0, e);

	/* if this means "end of header" quit now */
	if (!headeronly && bitset(H_EOH, hi->hi_flags))
		return hi->hi_flags;

	/*
	**  Horrible hack to work around problem with Lotus Notes SMTP
	**  mail gateway, which generates From: headers with newlines in
	**  them and the <address> on the second line.  Although this is
	**  legal RFC 822, many MUAs don't handle this properly and thus
	**  never find the actual address.
	*/

	if (bitset(H_FROM, hi->hi_flags) && SingleLineFromHeader)
	{
		while ((p = strchr(fvalue, '\n')) != NULL)
			*p = ' ';
	}

	/*
	**  If there is a check ruleset, verify it against the header.
	*/

	if (bitset(pflag, CHHDR_CHECK))
	{
		int rscheckflags;
		char *rs;

		rscheckflags = RSF_COUNT;
		if (!bitset(hi->hi_flags, H_FROM|H_RCPT))
			rscheckflags |= RSF_UNSTRUCTURED;

		/* no ruleset? look for default */
		rs = hi->hi_ruleset;
		if (rs == NULL)
		{
			s = stab("*", ST_HEADER, ST_FIND);
			if (s != NULL)
			{
				rs = (&s->s_header)->hi_ruleset;
				if (bitset((&s->s_header)->hi_flags,
					   H_STRIPCOMM))
					rscheckflags |= RSF_RMCOMM;
			}
		}
		else if (bitset(hi->hi_flags, H_STRIPCOMM))
			rscheckflags |= RSF_RMCOMM;
		if (rs != NULL)
		{
			int l, k;
			char qval[MAXNAME];

			l = 0;
			qval[l++] = '"';

			/* - 3 to avoid problems with " at the end */
			/* should be sizeof(qval), not MAXNAME */
			for (k = 0; fvalue[k] != '\0' && l < MAXNAME - 3; k++)
			{
				switch (fvalue[k])
				{
				  /* XXX other control chars? */
				  case '\011': /* ht */
				  case '\012': /* nl */
				  case '\013': /* vt */
				  case '\014': /* np */
				  case '\015': /* cr */
					qval[l++] = ' ';
					break;
				  case '"':
					qval[l++] = '\\';
					/* FALLTHROUGH */
				  default:
					qval[l++] = fvalue[k];
					break;
				}
			}
			qval[l++] = '"';
			qval[l] = '\0';
			k += strlen(fvalue + k);
			if (k >= MAXNAME)
			{
				if (LogLevel > 9)
					sm_syslog(LOG_WARNING, e->e_id,
						  "Warning: truncated header '%s' before check with '%s' len=%d max=%d",
						  fname, rs, k, MAXNAME - 1);
			}
			macdefine(&e->e_macro, A_TEMP,
				macid("{currHeader}"), qval);
			macdefine(&e->e_macro, A_TEMP,
				macid("{hdr_name}"), fname);

			(void) sm_snprintf(qval, sizeof(qval), "%d", k);
			macdefine(&e->e_macro, A_TEMP, macid("{hdrlen}"), qval);
			if (bitset(H_FROM, hi->hi_flags))
				macdefine(&e->e_macro, A_PERM,
					macid("{addr_type}"), "h s");
			else if (bitset(H_RCPT, hi->hi_flags))
				macdefine(&e->e_macro, A_PERM,
					macid("{addr_type}"), "h r");
			else
				macdefine(&e->e_macro, A_PERM,
					macid("{addr_type}"), "h");
			(void) rscheck(rs, fvalue, NULL, e, rscheckflags, 3,
				       NULL, e->e_id, NULL);
		}
	}

	/*
	**  Drop explicit From: if same as what we would generate.
	**  This is to make MH (which doesn't always give a full name)
	**  insert the full name information in all circumstances.
	*/

	dropfrom = false;
	p = "resent-from";
	if (!bitset(EF_RESENT, e->e_flags))
		p += 7;
	if (!bitset(pflag, CHHDR_DEF) && !headeronly &&
	    !bitset(EF_QUEUERUN, e->e_flags) && sm_strcasecmp(fname, p) == 0)
	{
		if (e->e_from.q_paddr != NULL &&
		    e->e_from.q_mailer != NULL &&
		    bitnset(M_LOCALMAILER, e->e_from.q_mailer->m_flags) &&
		    (strcmp(fvalue, e->e_from.q_paddr) == 0 ||
		     strcmp(fvalue, e->e_from.q_user) == 0))
			dropfrom = true;
		if (tTd(31, 2))
		{
			sm_dprintf("comparing header from (%s) against default (%s or %s), drop=%d\n",
				fvalue, e->e_from.q_paddr, e->e_from.q_user,
				dropfrom);
		}
	}

	/* delete default value for this header */
	for (hp = hdrp; (h = *hp) != NULL; hp = &h->h_link)
	{
		if (sm_strcasecmp(fname, h->h_field) == 0 &&
		    !bitset(H_USER, h->h_flags) &&
		    !bitset(H_FORCE, h->h_flags))
		{
			if (nullheader)
			{
				/* user-supplied value was null */
				return 0;
			}
			if (dropfrom)
			{
				/* make this look like the user entered it */
				h->h_flags |= H_USER;

				/*
				**  If the MH hack is selected, allow to turn
				**  it off via a mailer flag to avoid problems
				**  with setups that remove the F flag from
				**  the RCPT mailer.
				*/

		    		if (bitnset(M_NOMHHACK,
					    e->e_from.q_mailer->m_flags))
				{
					h->h_flags &= ~H_CHECK;
				}
				return hi->hi_flags;
			}
			h->h_value = NULL;
			if (!cond)
			{
				/* copy conditions from default case */
				memmove((char *) mopts, (char *) h->h_mflags,
					sizeof(mopts));
			}
			h->h_macro = mid;
		}
	}

	/* create a new node */
	h = (HDR *) sm_rpool_malloc_x(e->e_rpool, sizeof(*h));
	h->h_field = sm_rpool_strdup_x(e->e_rpool, fname);
	h->h_value = sm_rpool_strdup_x(e->e_rpool, fvalue);
	h->h_link = NULL;
	memmove((char *) h->h_mflags, (char *) mopts, sizeof(mopts));
	h->h_macro = mid;
	*hp = h;
	h->h_flags = hi->hi_flags;
	if (bitset(pflag, CHHDR_USER) || bitset(pflag, CHHDR_QUEUE))
		h->h_flags |= H_USER;

	/* strip EOH flag if parsing MIME headers */
	if (headeronly)
		h->h_flags &= ~H_EOH;
	if (bitset(pflag, CHHDR_DEF))
		h->h_flags |= H_DEFAULT;
	if (cond || mid != '\0')
		h->h_flags |= H_CHECK;

	/* hack to see if this is a new format message */
	if (!bitset(pflag, CHHDR_DEF) && !headeronly &&
	    bitset(H_RCPT|H_FROM, h->h_flags) &&
	    (strchr(fvalue, ',') != NULL || strchr(fvalue, '(') != NULL ||
	     strchr(fvalue, '<') != NULL || strchr(fvalue, ';') != NULL))
	{
		e->e_flags &= ~EF_OLDSTYLE;
	}

	return h->h_flags;
}

/*
**  CHOMPHEADER -- process and save a header line.
**
**	Called by collect, readcf, and readqf to deal with header lines.
**	This is just a wrapper for dochompheader().
**
**	Parameters:
**		line -- header as a text line.
**		pflag -- flags for chompheader() (from sendmail.h)
**		hdrp -- a pointer to the place to save the header.
**		e -- the envelope including this header.
**
**	Returns:
**		flags for this header.
**
**	Side Effects:
**		The header is saved on the header list.
**		Contents of 'line' are destroyed.
*/


unsigned long
chompheader(line, pflag, hdrp, e)
	char *line;
	int pflag;
	HDR **hdrp;
	register ENVELOPE *e;
{
	unsigned long rval;

	if (tTd(31, 6))
	{
		sm_dprintf("chompheader: ");
		xputs(sm_debug_file(), line);
		sm_dprintf("\n");
	}

	/* quote this if user (not config file) input */
	if (bitset(pflag, CHHDR_USER))
	{
		char xbuf[MAXLINE];
		char *xbp = NULL;
		int xbufs;

		xbufs = sizeof(xbuf);
		xbp = quote_internal_chars(line, xbuf, &xbufs);
		if (tTd(31, 7))
		{
			sm_dprintf("chompheader: quoted: ");
			xputs(sm_debug_file(), xbp);
			sm_dprintf("\n");
		}
		rval = dochompheader(xbp, pflag, hdrp, e);
		if (xbp != xbuf)
			sm_free(xbp);
	}
	else
		rval = dochompheader(line, pflag, hdrp, e);

	return rval;
}

/*
**  ALLOCHEADER -- allocate a header entry
**
**	Parameters:
**		field -- the name of the header field (will not be copied).
**		value -- the value of the field (will be copied).
**		flags -- flags to add to h_flags.
**		rp -- resource pool for allocations
**		space -- add leading space?
**
**	Returns:
**		Pointer to a newly allocated and populated HDR.
**
**	Notes:
**		o field and value must be in internal format, i.e.,
**		metacharacters must be "quoted", see quote_internal_chars().
**		o maybe add more flags to decide:
**		  - what to copy (field/value)
**		  - whether to convert value to an internal format
*/

static HDR *
allocheader(field, value, flags, rp, space)
	char *field;
	char *value;
	int flags;
	SM_RPOOL_T *rp;
	bool space;
{
	HDR *h;
	STAB *s;

	/* find info struct */
	s = stab(field, ST_HEADER, ST_FIND);

	/* allocate space for new header */
	h = (HDR *) sm_rpool_malloc_x(rp, sizeof(*h));
	h->h_field = field;
	if (space)
	{
		size_t l;
		char *n;

		l = strlen(value);
		SM_ASSERT(l + 2 > l);
		n = sm_rpool_malloc_x(rp, l + 2);
		n[0] = ' ';
		n[1] = '\0';
		sm_strlcpy(n + 1, value, l + 1);
		h->h_value = n;
	}
	else
		h->h_value = sm_rpool_strdup_x(rp, value);
	h->h_flags = flags;
	if (s != NULL)
		h->h_flags |= s->s_header.hi_flags;
	clrbitmap(h->h_mflags);
	h->h_macro = '\0';

	return h;
}

/*
**  ADDHEADER -- add a header entry to the end of the queue.
**
**	This bypasses the special checking of chompheader.
**
**	Parameters:
**		field -- the name of the header field (will not be copied).
**		value -- the value of the field (will be copied).
**		flags -- flags to add to h_flags.
**		e -- envelope.
**		space -- add leading space?
**
**	Returns:
**		none.
**
**	Side Effects:
**		adds the field on the list of headers for this envelope.
**
**	Notes: field and value must be in internal format, i.e.,
**		metacharacters must be "quoted", see quote_internal_chars().
*/

void
addheader(field, value, flags, e, space)
	char *field;
	char *value;
	int flags;
	ENVELOPE *e;
	bool space;
{
	register HDR *h;
	HDR **hp;
	HDR **hdrlist = &e->e_header;

	/* find current place in list -- keep back pointer? */
	for (hp = hdrlist; (h = *hp) != NULL; hp = &h->h_link)
	{
		if (sm_strcasecmp(field, h->h_field) == 0)
			break;
	}

	/* allocate space for new header */
	h = allocheader(field, value, flags, e->e_rpool, space);
	h->h_link = *hp;
	*hp = h;
}

/*
**  INSHEADER -- insert a header entry at the specified index
**	This bypasses the special checking of chompheader.
**
**	Parameters:
**		idx -- index into the header list at which to insert
**		field -- the name of the header field (will be copied).
**		value -- the value of the field (will be copied).
**		flags -- flags to add to h_flags.
**		e -- envelope.
**		space -- add leading space?
**
**	Returns:
**		none.
**
**	Side Effects:
**		inserts the field on the list of headers for this envelope.
**
**	Notes:
**		- field and value must be in internal format, i.e.,
**		metacharacters must be "quoted", see quote_internal_chars().
**		- the header list contains headers that might not be
**		sent "out" (see putheader(): "skip"), hence there is no
**		reliable way to insert a header at an exact position
**		(except at the front or end).
*/

void
insheader(idx, field, value, flags, e, space)
	int idx;
	char *field;
	char *value;
	int flags;
	ENVELOPE *e;
	bool space;
{
	HDR *h, *srch, *last = NULL;

	/* allocate space for new header */
	h = allocheader(field, value, flags, e->e_rpool, space);

	/* find insertion position */
	for (srch = e->e_header; srch != NULL && idx > 0;
	     srch = srch->h_link, idx--)
		last = srch;

	if (e->e_header == NULL)
	{
		e->e_header = h;
		h->h_link = NULL;
	}
	else if (srch == NULL)
	{
		SM_ASSERT(last != NULL);
		last->h_link = h;
		h->h_link = NULL;
	}
	else
	{
		h->h_link = srch->h_link;
		srch->h_link = h;
	}
}

/*
**  HVALUE -- return value of a header.
**
**	Only "real" fields (i.e., ones that have not been supplied
**	as a default) are used.
**
**	Parameters:
**		field -- the field name.
**		header -- the header list.
**
**	Returns:
**		pointer to the value part (internal format).
**		NULL if not found.
**
**	Side Effects:
**		none.
*/

char *
hvalue(field, header)
	char *field;
	HDR *header;
{
	register HDR *h;

	for (h = header; h != NULL; h = h->h_link)
	{
		if (!bitset(H_DEFAULT, h->h_flags) &&
		    sm_strcasecmp(h->h_field, field) == 0)
		{
			char *s;

			s = h->h_value;
			if (s == NULL)
				return NULL;
			while (isascii(*s) && isspace(*s))
				s++;
			return s;
		}
	}
	return NULL;
}

/*
**  ISHEADER -- predicate telling if argument is a header.
**
**	A line is a header if it has a single word followed by
**	optional white space followed by a colon.
**
**	Header fields beginning with two dashes, although technically
**	permitted by RFC822, are automatically rejected in order
**	to make MIME work out.  Without this we could have a technically
**	legal header such as ``--"foo:bar"'' that would also be a legal
**	MIME separator.
**
**	Parameters:
**		h -- string to check for possible headerness.
**
**	Returns:
**		true if h is a header.
**		false otherwise.
**
**	Side Effects:
**		none.
*/

bool
isheader(h)
	char *h;
{
	char *s;

	s = h;
	if (s[0] == '-' && s[1] == '-')
		return false;

	while (*s > ' ' && *s != ':' && *s != '\0')
		s++;

	if (h == s)
		return false;

	/* following technically violates RFC822 */
	while (isascii(*s) && isspace(*s))
		s++;

	return (*s == ':');
}

/*
**  EATHEADER -- run through the stored header and extract info.
**
**	Parameters:
**		e -- the envelope to process.
**		full -- if set, do full processing (e.g., compute
**			message priority).  This should not be set
**			when reading a queue file because some info
**			needed to compute the priority is wrong.
**		log -- call logsender()?
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets a bunch of global variables from information
**			in the collected header.
*/

void
eatheader(e, full, log)
	register ENVELOPE *e;
	bool full;
	bool log;
{
	register HDR *h;
	register char *p;
	int hopcnt = 0;
	char buf[MAXLINE];

	/*
	**  Set up macros for possible expansion in headers.
	*/

	macdefine(&e->e_macro, A_PERM, 'f', e->e_sender);
	macdefine(&e->e_macro, A_PERM, 'g', e->e_sender);
	if (e->e_origrcpt != NULL && *e->e_origrcpt != '\0')
		macdefine(&e->e_macro, A_PERM, 'u', e->e_origrcpt);
	else
		macdefine(&e->e_macro, A_PERM, 'u', NULL);

	/* full name of from person */
	p = hvalue("full-name", e->e_header);
	if (p != NULL)
	{
		if (!rfc822_string(p))
		{
			/*
			**  Quote a full name with special characters
			**  as a comment so crackaddr() doesn't destroy
			**  the name portion of the address.
			*/

			p = addquotes(p, e->e_rpool);
		}
		macdefine(&e->e_macro, A_PERM, 'x', p);
	}

	if (tTd(32, 1))
		sm_dprintf("----- collected header -----\n");
	e->e_msgid = NULL;
	for (h = e->e_header; h != NULL; h = h->h_link)
	{
		if (tTd(32, 1))
			sm_dprintf("%s:", h->h_field);
		if (h->h_value == NULL)
		{
			if (tTd(32, 1))
				sm_dprintf("<NULL>\n");
			continue;
		}

		/* do early binding */
		if (bitset(H_DEFAULT, h->h_flags) &&
		    !bitset(H_BINDLATE, h->h_flags))
		{
			if (tTd(32, 1))
			{
				sm_dprintf("(");
				xputs(sm_debug_file(), h->h_value);
				sm_dprintf(") ");
			}
			expand(h->h_value, buf, sizeof(buf), e);
			if (buf[0] != '\0' &&
			    (buf[0] != ' ' || buf[1] != '\0'))
			{
				if (bitset(H_FROM, h->h_flags))
					expand(crackaddr(buf, e),
					       buf, sizeof(buf), e);
				h->h_value = sm_rpool_strdup_x(e->e_rpool, buf);
				h->h_flags &= ~H_DEFAULT;
			}
		}
		if (tTd(32, 1))
		{
			xputs(sm_debug_file(), h->h_value);
			sm_dprintf("\n");
		}

		/* count the number of times it has been processed */
		if (bitset(H_TRACE, h->h_flags))
			hopcnt++;

		/* send to this person if we so desire */
		if (GrabTo && bitset(H_RCPT, h->h_flags) &&
		    !bitset(H_DEFAULT, h->h_flags) &&
		    (!bitset(EF_RESENT, e->e_flags) ||
		     bitset(H_RESENT, h->h_flags)))
		{
#if 0
			int saveflags = e->e_flags;
#endif /* 0 */

			(void) sendtolist(denlstring(h->h_value, true, false),
					  NULLADDR, &e->e_sendqueue, 0, e);

#if 0
			/*
			**  Change functionality so a fatal error on an
			**  address doesn't affect the entire envelope.
			*/

			/* delete fatal errors generated by this address */
			if (!bitset(EF_FATALERRS, saveflags))
				e->e_flags &= ~EF_FATALERRS;
#endif /* 0 */
		}

		/* save the message-id for logging */
		p = "resent-message-id";
		if (!bitset(EF_RESENT, e->e_flags))
			p += 7;
		if (sm_strcasecmp(h->h_field, p) == 0)
		{
			e->e_msgid = h->h_value;
			while (isascii(*e->e_msgid) && isspace(*e->e_msgid))
				e->e_msgid++;
			macdefine(&e->e_macro, A_PERM, macid("{msg_id}"),
				  e->e_msgid);
		}
	}
	if (tTd(32, 1))
		sm_dprintf("----------------------------\n");

	/* if we are just verifying (that is, sendmail -t -bv), drop out now */
	if (OpMode == MD_VERIFY)
		return;

	/* store hop count */
	if (hopcnt > e->e_hopcount)
	{
		e->e_hopcount = hopcnt;
		(void) sm_snprintf(buf, sizeof(buf), "%d", e->e_hopcount);
		macdefine(&e->e_macro, A_TEMP, 'c', buf);
	}

	/* message priority */
	p = hvalue("precedence", e->e_header);
	if (p != NULL)
		e->e_class = priencode(p);
	if (e->e_class < 0)
		e->e_timeoutclass = TOC_NONURGENT;
	else if (e->e_class > 0)
		e->e_timeoutclass = TOC_URGENT;
	if (full)
	{
		e->e_msgpriority = e->e_msgsize
				 - e->e_class * WkClassFact
				 + e->e_nrcpts * WkRecipFact;
	}

	/* check for DSN to properly set e_timeoutclass */
	p = hvalue("content-type", e->e_header);
	if (p != NULL)
	{
		bool oldsupr;
		char **pvp;
		char pvpbuf[MAXLINE];
		extern unsigned char MimeTokenTab[256];

		/* tokenize header */
		oldsupr = SuprErrs;
		SuprErrs = true;
		pvp = prescan(p, '\0', pvpbuf, sizeof(pvpbuf), NULL,
			      MimeTokenTab, false);
		SuprErrs = oldsupr;

		/* Check if multipart/report */
		if (pvp != NULL && pvp[0] != NULL &&
		    pvp[1] != NULL && pvp[2] != NULL &&
		    sm_strcasecmp(*pvp++, "multipart") == 0 &&
		    strcmp(*pvp++, "/") == 0 &&
		    sm_strcasecmp(*pvp++, "report") == 0)
		{
			/* Look for report-type=delivery-status */
			while (*pvp != NULL)
			{
				/* skip to semicolon separator */
				while (*pvp != NULL && strcmp(*pvp, ";") != 0)
					pvp++;

				/* skip semicolon */
				if (*pvp++ == NULL || *pvp == NULL)
					break;

				/* look for report-type */
				if (sm_strcasecmp(*pvp++, "report-type") != 0)
					continue;

				/* skip equal */
				if (*pvp == NULL || strcmp(*pvp, "=") != 0)
					continue;

				/* check value */
				if (*++pvp != NULL &&
				    sm_strcasecmp(*pvp,
						  "delivery-status") == 0)
					e->e_timeoutclass = TOC_DSN;

				/* found report-type, no need to continue */
				break;
			}
		}
	}

	/* message timeout priority */
	p = hvalue("priority", e->e_header);
	if (p != NULL)
	{
		/* (this should be in the configuration file) */
		if (sm_strcasecmp(p, "urgent") == 0)
			e->e_timeoutclass = TOC_URGENT;
		else if (sm_strcasecmp(p, "normal") == 0)
			e->e_timeoutclass = TOC_NORMAL;
		else if (sm_strcasecmp(p, "non-urgent") == 0)
			e->e_timeoutclass = TOC_NONURGENT;
		else if (bitset(EF_RESPONSE, e->e_flags))
			e->e_timeoutclass = TOC_DSN;
	}
	else if (bitset(EF_RESPONSE, e->e_flags))
		e->e_timeoutclass = TOC_DSN;

	/* date message originated */
	p = hvalue("posted-date", e->e_header);
	if (p == NULL)
		p = hvalue("date", e->e_header);
	if (p != NULL)
		macdefine(&e->e_macro, A_PERM, 'a', p);

	/* check to see if this is a MIME message */
	if ((e->e_bodytype != NULL &&
	     sm_strcasecmp(e->e_bodytype, "8BITMIME") == 0) ||
	    hvalue("MIME-Version", e->e_header) != NULL)
	{
		e->e_flags |= EF_IS_MIME;
		if (HasEightBits)
			e->e_bodytype = "8BITMIME";
	}
	else if ((p = hvalue("Content-Type", e->e_header)) != NULL)
	{
		/* this may be an RFC 1049 message */
		p = strpbrk(p, ";/");
		if (p == NULL || *p == ';')
		{
			/* yep, it is */
			e->e_flags |= EF_DONT_MIME;
		}
	}

	/*
	**  From person in antiquated ARPANET mode
	**	required by UK Grey Book e-mail gateways (sigh)
	*/

	if (OpMode == MD_ARPAFTP)
	{
		register struct hdrinfo *hi;

		for (hi = HdrInfo; hi->hi_field != NULL; hi++)
		{
			if (bitset(H_FROM, hi->hi_flags) &&
			    (!bitset(H_RESENT, hi->hi_flags) ||
			     bitset(EF_RESENT, e->e_flags)) &&
			    (p = hvalue(hi->hi_field, e->e_header)) != NULL)
				break;
		}
		if (hi->hi_field != NULL)
		{
			if (tTd(32, 2))
				sm_dprintf("eatheader: setsender(*%s == %s)\n",
					hi->hi_field, p);
			setsender(p, e, NULL, '\0', true);
		}
	}

	/*
	**  Log collection information.
	*/

	if (tTd(92, 2))
		sm_dprintf("eatheader: e_id=%s, EF_LOGSENDER=%d, LogLevel=%d, log=%d\n",
			e->e_id, bitset(EF_LOGSENDER, e->e_flags), LogLevel,
			log);
	if (log && bitset(EF_LOGSENDER, e->e_flags) && LogLevel > 4)
	{
		logsender(e, e->e_msgid);
		e->e_flags &= ~EF_LOGSENDER;
	}
}

/*
**  LOGSENDER -- log sender information
**
**	Parameters:
**		e -- the envelope to log
**		msgid -- the message id
**
**	Returns:
**		none
*/

void
logsender(e, msgid)
	register ENVELOPE *e;
	char *msgid;
{
	char *name;
	register char *sbp;
	register char *p;
	char hbuf[MAXNAME + 1];
	char sbuf[MAXLINE + 1];
	char mbuf[MAXNAME + 1];

	/* don't allow newlines in the message-id */
	/* XXX do we still need this? sm_syslog() replaces control chars */
	if (msgid != NULL)
	{
		size_t l;

		l = strlen(msgid);
		if (l > sizeof(mbuf) - 1)
			l = sizeof(mbuf) - 1;
		memmove(mbuf, msgid, l);
		mbuf[l] = '\0';
		p = mbuf;
		while ((p = strchr(p, '\n')) != NULL)
			*p++ = ' ';
	}

	if (bitset(EF_RESPONSE, e->e_flags))
		name = "[RESPONSE]";
	else if ((name = macvalue('_', e)) != NULL)
		/* EMPTY */
		;
	else if (RealHostName == NULL)
		name = "localhost";
	else if (RealHostName[0] == '[')
		name = RealHostName;
	else
	{
		name = hbuf;
		(void) sm_snprintf(hbuf, sizeof(hbuf), "%.80s", RealHostName);
		if (RealHostAddr.sa.sa_family != 0)
		{
			p = &hbuf[strlen(hbuf)];
			(void) sm_snprintf(p, SPACELEFT(hbuf, p),
					   " (%.100s)",
					   anynet_ntoa(&RealHostAddr));
		}
	}

	/* some versions of syslog only take 5 printf args */
#if (SYSLOG_BUFSIZE) >= 256
	sbp = sbuf;
	(void) sm_snprintf(sbp, SPACELEFT(sbuf, sbp),
		"from=%.200s, size=%ld, class=%d, nrcpts=%d",
		e->e_from.q_paddr == NULL ? "<NONE>" : e->e_from.q_paddr,
		PRT_NONNEGL(e->e_msgsize), e->e_class, e->e_nrcpts);
	sbp += strlen(sbp);
	if (msgid != NULL)
	{
		(void) sm_snprintf(sbp, SPACELEFT(sbuf, sbp),
				", msgid=%.100s", mbuf);
		sbp += strlen(sbp);
	}
	if (e->e_bodytype != NULL)
	{
		(void) sm_snprintf(sbp, SPACELEFT(sbuf, sbp),
				", bodytype=%.20s", e->e_bodytype);
		sbp += strlen(sbp);
	}
	p = macvalue('r', e);
	if (p != NULL)
	{
		(void) sm_snprintf(sbp, SPACELEFT(sbuf, sbp),
				", proto=%.20s", p);
		sbp += strlen(sbp);
	}
	p = macvalue(macid("{daemon_name}"), e);
	if (p != NULL)
	{
		(void) sm_snprintf(sbp, SPACELEFT(sbuf, sbp),
				", daemon=%.20s", p);
		sbp += strlen(sbp);
	}
	sm_syslog(LOG_INFO, e->e_id, "%.850s, relay=%s", sbuf, name);

#else /* (SYSLOG_BUFSIZE) >= 256 */

	sm_syslog(LOG_INFO, e->e_id,
		  "from=%s",
		  e->e_from.q_paddr == NULL ? "<NONE>"
					    : shortenstring(e->e_from.q_paddr,
							    83));
	sm_syslog(LOG_INFO, e->e_id,
		  "size=%ld, class=%ld, nrcpts=%d",
		  PRT_NONNEGL(e->e_msgsize), e->e_class, e->e_nrcpts);
	if (msgid != NULL)
		sm_syslog(LOG_INFO, e->e_id,
			  "msgid=%s",
			  shortenstring(mbuf, 83));
	sbp = sbuf;
	*sbp = '\0';
	if (e->e_bodytype != NULL)
	{
		(void) sm_snprintf(sbp, SPACELEFT(sbuf, sbp),
				"bodytype=%.20s, ", e->e_bodytype);
		sbp += strlen(sbp);
	}
	p = macvalue('r', e);
	if (p != NULL)
	{
		(void) sm_snprintf(sbp, SPACELEFT(sbuf, sbp),
				"proto=%.20s, ", p);
		sbp += strlen(sbp);
	}
	sm_syslog(LOG_INFO, e->e_id,
		  "%.400srelay=%s", sbuf, name);
#endif /* (SYSLOG_BUFSIZE) >= 256 */
}

/*
**  PRIENCODE -- encode external priority names into internal values.
**
**	Parameters:
**		p -- priority in ascii.
**
**	Returns:
**		priority as a numeric level.
**
**	Side Effects:
**		none.
*/

static int
priencode(p)
	char *p;
{
	register int i;

	for (i = 0; i < NumPriorities; i++)
	{
		if (sm_strcasecmp(p, Priorities[i].pri_name) == 0)
			return Priorities[i].pri_val;
	}

	/* unknown priority */
	return 0;
}

/*
**  CRACKADDR -- parse an address and turn it into a macro
**
**	This doesn't actually parse the address -- it just extracts
**	it and replaces it with "$g".  The parse is totally ad hoc
**	and isn't even guaranteed to leave something syntactically
**	identical to what it started with.  However, it does leave
**	something semantically identical if possible, else at least
**	syntactically correct.
**
**	For example, it changes "Real Name <real@@example.com> (Comment)"
**	to "Real Name <$g> (Comment)".
**
**	This algorithm has been cleaned up to handle a wider range
**	of cases -- notably quoted and backslash escaped strings.
**	This modification makes it substantially better at preserving
**	the original syntax.
**
**	Parameters:
**		addr -- the address to be cracked.
**		e -- the current envelope.
**
**	Returns:
**		a pointer to the new version.
**
**	Side Effects:
**		none.
**
**	Warning:
**		The return value is saved in local storage and should
**		be copied if it is to be reused.
*/

#define SM_HAVE_ROOM		((bp < buflim) && (buflim <= bufend))

/*
**  Append a character to bp if we have room.
**  If not, punt and return $g.
*/

#define SM_APPEND_CHAR(c)					\
	do							\
	{							\
		if (SM_HAVE_ROOM)				\
			*bp++ = (c);				\
		else						\
			goto returng;				\
	} while (0)

#if MAXNAME < 10
ERROR MAXNAME must be at least 10
#endif /* MAXNAME < 10 */

char *
crackaddr(addr, e)
	register char *addr;
	ENVELOPE *e;
{
	register char *p;
	register char c;
	int cmtlev;			/* comment level in input string */
	int realcmtlev;			/* comment level in output string */
	int anglelev;			/* angle level in input string */
	int copylev;			/* 0 == in address, >0 copying */
	int bracklev;			/* bracket level for IPv6 addr check */
	bool addangle;			/* put closing angle in output */
	bool qmode;			/* quoting in original string? */
	bool realqmode;			/* quoting in output string? */
	bool putgmac = false;		/* already wrote $g */
	bool quoteit = false;		/* need to quote next character */
	bool gotangle = false;		/* found first '<' */
	bool gotcolon = false;		/* found a ':' */
	register char *bp;
	char *buflim;
	char *bufhead;
	char *addrhead;
	char *bufend;
	static char buf[MAXNAME + 1];

	if (tTd(33, 1))
		sm_dprintf("crackaddr(%s)\n", addr);

	buflim = bufend = &buf[sizeof(buf) - 1];
	bp = bufhead = buf;

	/* skip over leading spaces but preserve them */
	while (*addr != '\0' && isascii(*addr) && isspace(*addr))
	{
		SM_APPEND_CHAR(*addr);
		addr++;
	}
	bufhead = bp;

	/*
	**  Start by assuming we have no angle brackets.  This will be
	**  adjusted later if we find them.
	*/

	p = addrhead = addr;
	copylev = anglelev = cmtlev = realcmtlev = 0;
	bracklev = 0;
	qmode = realqmode = addangle = false;

	while ((c = *p++) != '\0')
	{
		/*
		**  Try to keep legal syntax using spare buffer space
		**  (maintained by buflim).
		*/

		if (copylev > 0)
			SM_APPEND_CHAR(c);

		/* check for backslash escapes */
		if (c == '\\')
		{
			/* arrange to quote the address */
			if (cmtlev <= 0 && !qmode)
				quoteit = true;

			if ((c = *p++) == '\0')
			{
				/* too far */
				p--;
				goto putg;
			}
			if (copylev > 0)
				SM_APPEND_CHAR(c);
			goto putg;
		}

		/* check for quoted strings */
		if (c == '"' && cmtlev <= 0)
		{
			qmode = !qmode;
			if (copylev > 0 && SM_HAVE_ROOM)
			{
				if (realqmode)
					buflim--;
				else
					buflim++;
				realqmode = !realqmode;
			}
			continue;
		}
		if (qmode)
			goto putg;

		/* check for comments */
		if (c == '(')
		{
			cmtlev++;

			/* allow space for closing paren */
			if (SM_HAVE_ROOM)
			{
				buflim--;
				realcmtlev++;
				if (copylev++ <= 0)
				{
					if (bp != bufhead)
						SM_APPEND_CHAR(' ');
					SM_APPEND_CHAR(c);
				}
			}
		}
		if (cmtlev > 0)
		{
			if (c == ')')
			{
				cmtlev--;
				copylev--;
				if (SM_HAVE_ROOM)
				{
					realcmtlev--;
					buflim++;
				}
			}
			continue;
		}
		else if (c == ')')
		{
			/* syntax error: unmatched ) */
			if (copylev > 0 && SM_HAVE_ROOM && bp > bufhead)
				bp--;
		}

		/* count nesting on [ ... ] (for IPv6 domain literals) */
		if (c == '[')
			bracklev++;
		else if (c == ']')
			bracklev--;

		/* check for group: list; syntax */
		if (c == ':' && anglelev <= 0 && bracklev <= 0 &&
		    !gotcolon && !ColonOkInAddr)
		{
			register char *q;

			/*
			**  Check for DECnet phase IV ``::'' (host::user)
			**  or DECnet phase V ``:.'' syntaxes.  The latter
			**  covers ``user@@DEC:.tay.myhost'' and
			**  ``DEC:.tay.myhost::user'' syntaxes (bletch).
			*/

			if (*p == ':' || *p == '.')
			{
				if (cmtlev <= 0 && !qmode)
					quoteit = true;
				if (copylev > 0)
				{
					SM_APPEND_CHAR(c);
					SM_APPEND_CHAR(*p);
				}
				p++;
				goto putg;
			}

			gotcolon = true;

			bp = bufhead;
			if (quoteit)
			{
				SM_APPEND_CHAR('"');

				/* back up over the ':' and any spaces */
				--p;
				while (p > addr &&
				       isascii(*--p) && isspace(*p))
					continue;
				p++;
			}
			for (q = addrhead; q < p; )
			{
				c = *q++;
				if (quoteit && c == '"')
					SM_APPEND_CHAR('\\');
				SM_APPEND_CHAR(c);
			}
			if (quoteit)
			{
				if (bp == &bufhead[1])
					bp--;
				else
					SM_APPEND_CHAR('"');
				while ((c = *p++) != ':')
					SM_APPEND_CHAR(c);
				SM_APPEND_CHAR(c);
			}

			/* any trailing white space is part of group: */
			while (isascii(*p) && isspace(*p))
			{
				SM_APPEND_CHAR(*p);
				p++;
			}
			copylev = 0;
			putgmac = quoteit = false;
			bufhead = bp;
			addrhead = p;
			continue;
		}

		if (c == ';' && copylev <= 0 && !ColonOkInAddr)
			SM_APPEND_CHAR(c);

		/* check for characters that may have to be quoted */
		if (strchr(MustQuoteChars, c) != NULL)
		{
			/*
			**  If these occur as the phrase part of a <>
			**  construct, but are not inside of () or already
			**  quoted, they will have to be quoted.  Note that
			**  now (but don't actually do the quoting).
			*/

			if (cmtlev <= 0 && !qmode)
				quoteit = true;
		}

		/* check for angle brackets */
		if (c == '<')
		{
			register char *q;

			/* assume first of two angles is bogus */
			if (gotangle)
				quoteit = true;
			gotangle = true;

			/* oops -- have to change our mind */
			anglelev = 1;
			if (SM_HAVE_ROOM)
			{
				if (!addangle)
					buflim--;
				addangle = true;
			}

			bp = bufhead;
			if (quoteit)
			{
				SM_APPEND_CHAR('"');

				/* back up over the '<' and any spaces */
				--p;
				while (p > addr &&
				       isascii(*--p) && isspace(*p))
					continue;
				p++;
			}
			for (q = addrhead; q < p; )
			{
				c = *q++;
				if (quoteit && c == '"')
				{
					SM_APPEND_CHAR('\\');
					SM_APPEND_CHAR(c);
				}
				else
					SM_APPEND_CHAR(c);
			}
			if (quoteit)
			{
				if (bp == &buf[1])
					bp--;
				else
					SM_APPEND_CHAR('"');
				while ((c = *p++) != '<')
					SM_APPEND_CHAR(c);
				SM_APPEND_CHAR(c);
			}
			copylev = 0;
			putgmac = quoteit = false;
			continue;
		}

		if (c == '>')
		{
			if (anglelev > 0)
			{
				anglelev--;
				if (SM_HAVE_ROOM)
				{
					if (addangle)
						buflim++;
					addangle = false;
				}
			}
			else if (SM_HAVE_ROOM)
			{
				/* syntax error: unmatched > */
				if (copylev > 0 && bp > bufhead)
					bp--;
				quoteit = true;
				continue;
			}
			if (copylev++ <= 0)
				SM_APPEND_CHAR(c);
			continue;
		}

		/* must be a real address character */
	putg:
		if (copylev <= 0 && !putgmac)
		{
			if (bp > buf && bp[-1] == ')')
				SM_APPEND_CHAR(' ');
			SM_APPEND_CHAR(MACROEXPAND);
			SM_APPEND_CHAR('g');
			putgmac = true;
		}
	}

	/* repair any syntactic damage */
	if (realqmode && bp < bufend)
		*bp++ = '"';
	while (realcmtlev-- > 0 && bp < bufend)
		*bp++ = ')';
	if (addangle && bp < bufend)
		*bp++ = '>';
	*bp = '\0';
	if (bp < bufend)
		goto success;

 returng:
	/* String too long, punt */
	buf[0] = '<';
	buf[1] = MACROEXPAND;
	buf[2]= 'g';
	buf[3] = '>';
	buf[4]= '\0';
	sm_syslog(LOG_ALERT, e->e_id,
		  "Dropped invalid comments from header address");

 success:
	if (tTd(33, 1))
	{
		sm_dprintf("crackaddr=>`");
		xputs(sm_debug_file(), buf);
		sm_dprintf("'\n");
	}
	return buf;
}

/*
**  PUTHEADER -- put the header part of a message from the in-core copy
**
**	Parameters:
**		mci -- the connection information.
**		hdr -- the header to put.
**		e -- envelope to use.
**		flags -- MIME conversion flags.
**
**	Returns:
**		true iff header part was written successfully
**
**	Side Effects:
**		none.
*/

bool
putheader(mci, hdr, e, flags)
	register MCI *mci;
	HDR *hdr;
	register ENVELOPE *e;
	int flags;
{
	register HDR *h;
	char buf[SM_MAX(MAXLINE,BUFSIZ)];
	char obuf[MAXLINE];

	if (tTd(34, 1))
		sm_dprintf("--- putheader, mailer = %s ---\n",
			mci->mci_mailer->m_name);

	/*
	**  If we're in MIME mode, we're not really in the header of the
	**  message, just the header of one of the parts of the body of
	**  the message.  Therefore MCIF_INHEADER should not be turned on.
	*/

	if (!bitset(MCIF_INMIME, mci->mci_flags))
		mci->mci_flags |= MCIF_INHEADER;

	for (h = hdr; h != NULL; h = h->h_link)
	{
		register char *p = h->h_value;
		char *q;

		if (tTd(34, 11))
		{
			sm_dprintf("  %s:", h->h_field);
			xputs(sm_debug_file(), p);
		}

		/* Skip empty headers */
		if (h->h_value == NULL)
			continue;

		/* heuristic shortening of MIME fields to avoid MUA overflows */
		if (MaxMimeFieldLength > 0 &&
		    wordinclass(h->h_field,
				macid("{checkMIMEFieldHeaders}")))
		{
			size_t len;

			len = fix_mime_header(h, e);
			if (len > 0)
			{
				sm_syslog(LOG_ALERT, e->e_id,
					  "Truncated MIME %s header due to field size (length = %ld) (possible attack)",
					  h->h_field, (unsigned long) len);
				if (tTd(34, 11))
					sm_dprintf("  truncated MIME %s header due to field size  (length = %ld) (possible attack)\n",
						   h->h_field,
						   (unsigned long) len);
			}
		}

		if (MaxMimeHeaderLength > 0 &&
		    wordinclass(h->h_field,
				macid("{checkMIMETextHeaders}")))
		{
			size_t len;

			len = strlen(h->h_value);
			if (len > (size_t) MaxMimeHeaderLength)
			{
				h->h_value[MaxMimeHeaderLength - 1] = '\0';
				sm_syslog(LOG_ALERT, e->e_id,
					  "Truncated long MIME %s header (length = %ld) (possible attack)",
					  h->h_field, (unsigned long) len);
				if (tTd(34, 11))
					sm_dprintf("  truncated long MIME %s header (length = %ld) (possible attack)\n",
						   h->h_field,
						   (unsigned long) len);
			}
		}

		if (MaxMimeHeaderLength > 0 &&
		    wordinclass(h->h_field,
				macid("{checkMIMEHeaders}")))
		{
			size_t len;

			len = strlen(h->h_value);
			if (shorten_rfc822_string(h->h_value,
						  MaxMimeHeaderLength))
			{
				if (len < MaxMimeHeaderLength)
				{
					/* we only rebalanced a bogus header */
					sm_syslog(LOG_ALERT, e->e_id,
						  "Fixed MIME %s header (possible attack)",
						  h->h_field);
					if (tTd(34, 11))
						sm_dprintf("  fixed MIME %s header (possible attack)\n",
							   h->h_field);
				}
				else
				{
					/* we actually shortened header */
					sm_syslog(LOG_ALERT, e->e_id,
						  "Truncated long MIME %s header (length = %ld) (possible attack)",
						  h->h_field,
						  (unsigned long) len);
					if (tTd(34, 11))
						sm_dprintf("  truncated long MIME %s header (length = %ld) (possible attack)\n",
							   h->h_field,
							   (unsigned long) len);
				}
			}
		}

		/*
		**  Suppress Content-Transfer-Encoding: if we are MIMEing
		**  and we are potentially converting from 8 bit to 7 bit
		**  MIME.  If converting, add a new CTE header in
		**  mime8to7().
		*/

		if (bitset(H_CTE, h->h_flags) &&
		    bitset(MCIF_CVT8TO7|MCIF_CVT7TO8|MCIF_INMIME,
			   mci->mci_flags) &&
		    !bitset(M87F_NO8TO7, flags))
		{
			if (tTd(34, 11))
				sm_dprintf(" (skipped (content-transfer-encoding))\n");
			continue;
		}

		if (bitset(MCIF_INMIME, mci->mci_flags))
		{
			if (tTd(34, 11))
				sm_dprintf("\n");
			if (!put_vanilla_header(h, p, mci))
				goto writeerr;
			continue;
		}

		if (bitset(H_CHECK|H_ACHECK, h->h_flags) &&
		    !bitintersect(h->h_mflags, mci->mci_mailer->m_flags) &&
		    (h->h_macro == '\0' ||
		     (q = macvalue(bitidx(h->h_macro), e)) == NULL ||
		     *q == '\0'))
		{
			if (tTd(34, 11))
				sm_dprintf(" (skipped)\n");
			continue;
		}

		/* handle Resent-... headers specially */
		if (bitset(H_RESENT, h->h_flags) && !bitset(EF_RESENT, e->e_flags))
		{
			if (tTd(34, 11))
				sm_dprintf(" (skipped (resent))\n");
			continue;
		}

		/* suppress return receipts if requested */
		if (bitset(H_RECEIPTTO, h->h_flags) &&
		    (RrtImpliesDsn || bitset(EF_NORECEIPT, e->e_flags)))
		{
			if (tTd(34, 11))
				sm_dprintf(" (skipped (receipt))\n");
			continue;
		}

		/* macro expand value if generated internally */
		if (bitset(H_DEFAULT, h->h_flags) ||
		    bitset(H_BINDLATE, h->h_flags))
		{
			expand(p, buf, sizeof(buf), e);
			p = buf;
			if (*p == '\0')
			{
				if (tTd(34, 11))
					sm_dprintf(" (skipped -- null value)\n");
				continue;
			}
		}

		if (bitset(H_BCC, h->h_flags))
		{
			/* Bcc: field -- either truncate or delete */
			if (bitset(EF_DELETE_BCC, e->e_flags))
			{
				if (tTd(34, 11))
					sm_dprintf(" (skipped -- bcc)\n");
			}
			else
			{
				/* no other recipient headers: truncate value */
				(void) sm_strlcpyn(obuf, sizeof(obuf), 2,
						   h->h_field, ":");
				if (!putline(obuf, mci))
					goto writeerr;
			}
			continue;
		}

		if (tTd(34, 11))
			sm_dprintf("\n");

		if (bitset(H_FROM|H_RCPT, h->h_flags))
		{
			/* address field */
			bool oldstyle = bitset(EF_OLDSTYLE, e->e_flags);

			if (bitset(H_FROM, h->h_flags))
				oldstyle = false;
			commaize(h, p, oldstyle, mci, e,
				 PXLF_HEADER | PXLF_STRIPMQUOTE);
		}
		else
		{
			if (!put_vanilla_header(h, p, mci))
				goto writeerr;
		}
	}

	/*
	**  If we are converting this to a MIME message, add the
	**  MIME headers (but not in MIME mode!).
	*/

#if MIME8TO7
	if (bitset(MM_MIME8BIT, MimeMode) &&
	    bitset(EF_HAS8BIT, e->e_flags) &&
	    !bitset(EF_DONT_MIME, e->e_flags) &&
	    !bitnset(M_8BITS, mci->mci_mailer->m_flags) &&
	    !bitset(MCIF_CVT8TO7|MCIF_CVT7TO8|MCIF_INMIME, mci->mci_flags) &&
	    hvalue("MIME-Version", e->e_header) == NULL)
	{
		if (!putline("MIME-Version: 1.0", mci))
			goto writeerr;
		if (hvalue("Content-Type", e->e_header) == NULL)
		{
			(void) sm_snprintf(obuf, sizeof(obuf),
					"Content-Type: text/plain; charset=%s",
					defcharset(e));
			if (!putline(obuf, mci))
				goto writeerr;
		}
		if (hvalue("Content-Transfer-Encoding", e->e_header) == NULL
		    && !putline("Content-Transfer-Encoding: 8bit", mci))
			goto writeerr;
	}
#endif /* MIME8TO7 */
	return true;

  writeerr:
	return false;
}

/*
**  PUT_VANILLA_HEADER -- output a fairly ordinary header
**
**	Parameters:
**		h -- the structure describing this header
**		v -- the value of this header
**		mci -- the connection info for output
**
**	Returns:
**		true iff header was written successfully
*/

static bool
put_vanilla_header(h, v, mci)
	HDR *h;
	char *v;
	MCI *mci;
{
	register char *nlp;
	register char *obp;
	int putflags;
	char obuf[MAXLINE + 256];	/* additional length for h_field */

	putflags = PXLF_HEADER | PXLF_STRIPMQUOTE;
	if (bitnset(M_7BITHDRS, mci->mci_mailer->m_flags))
		putflags |= PXLF_STRIP8BIT;
	(void) sm_snprintf(obuf, sizeof(obuf), "%.200s:", h->h_field);
	obp = obuf + strlen(obuf);
	while ((nlp = strchr(v, '\n')) != NULL)
	{
		int l;

		l = nlp - v;

		/*
		**  XXX This is broken for SPACELEFT()==0
		**  However, SPACELEFT() is always > 0 unless MAXLINE==1.
		*/

		if (SPACELEFT(obuf, obp) - 1 < (size_t) l)
			l = SPACELEFT(obuf, obp) - 1;

		(void) sm_snprintf(obp, SPACELEFT(obuf, obp), "%.*s", l, v);
		if (!putxline(obuf, strlen(obuf), mci, putflags))
			goto writeerr;
		v += l + 1;
		obp = obuf;
		if (*v != ' ' && *v != '\t')
			*obp++ = ' ';
	}

	/* XXX This is broken for SPACELEFT()==0 */
	(void) sm_snprintf(obp, SPACELEFT(obuf, obp), "%.*s",
			   (int) (SPACELEFT(obuf, obp) - 1), v);
	return putxline(obuf, strlen(obuf), mci, putflags);

  writeerr:
	return false;
}

/*
**  COMMAIZE -- output a header field, making a comma-translated list.
**
**	Parameters:
**		h -- the header field to output.
**		p -- the value to put in it.
**		oldstyle -- true if this is an old style header.
**		mci -- the connection information.
**		e -- the envelope containing the message.
**		putflags -- flags for putxline()
**
**	Returns:
**		true iff header field was written successfully
**
**	Side Effects:
**		outputs "p" to "mci".
*/

bool
commaize(h, p, oldstyle, mci, e, putflags)
	register HDR *h;
	register char *p;
	bool oldstyle;
	register MCI *mci;
	register ENVELOPE *e;
	int putflags;
{
	register char *obp;
	int opos, omax, spaces;
	bool firstone = true;
	char **res;
	char obuf[MAXLINE + 3];

	/*
	**  Output the address list translated by the
	**  mailer and with commas.
	*/

	if (tTd(14, 2))
		sm_dprintf("commaize(%s:%s)\n", h->h_field, p);

	if (bitnset(M_7BITHDRS, mci->mci_mailer->m_flags))
		putflags |= PXLF_STRIP8BIT;

	obp = obuf;
	(void) sm_snprintf(obp, SPACELEFT(obuf, obp), "%.200s:", h->h_field);
	/* opos = strlen(obp); instead of the next 3 lines? */
	opos = strlen(h->h_field) + 1;
	if (opos > 201)
		opos = 201;
	obp += opos;

	spaces = 0;
	while (*p != '\0' && isascii(*p) && isspace(*p))
	{
		++spaces;
		++p;
	}
	if (spaces > 0)
	{
		SM_ASSERT(sizeof(obuf) > opos  * 2);

		/*
		**  Restrict number of spaces to half the length of buffer
		**  so the header field body can be put in here too.
		**  Note: this is a hack...
		*/

		if (spaces > sizeof(obuf) / 2)
			spaces = sizeof(obuf) / 2;
		(void) sm_snprintf(obp, SPACELEFT(obuf, obp), "%*s", spaces,
				"");
		opos += spaces;
		obp += spaces;
		SM_ASSERT(obp < &obuf[MAXLINE]);
	}

	omax = mci->mci_mailer->m_linelimit - 2;
	if (omax < 0 || omax > 78)
		omax = 78;

	/*
	**  Run through the list of values.
	*/

	while (*p != '\0')
	{
		register char *name;
		register int c;
		char savechar;
		int flags;
		auto int status;

		/*
		**  Find the end of the name.  New style names
		**  end with a comma, old style names end with
		**  a space character.  However, spaces do not
		**  necessarily delimit an old-style name -- at
		**  signs mean keep going.
		*/

		/* find end of name */
		while ((isascii(*p) && isspace(*p)) || *p == ',')
			p++;
		name = p;
		res = NULL;
		for (;;)
		{
			auto char *oldp;
			char pvpbuf[PSBUFSIZE];

			res = prescan(p, oldstyle ? ' ' : ',', pvpbuf,
				      sizeof(pvpbuf), &oldp, ExtTokenTab, false);
			p = oldp;
#if _FFR_IGNORE_BOGUS_ADDR
			/* ignore addresses that can't be parsed */
			if (res == NULL)
			{
				name = p;
				continue;
			}
#endif /* _FFR_IGNORE_BOGUS_ADDR */

			/* look to see if we have an at sign */
			while (*p != '\0' && isascii(*p) && isspace(*p))
				p++;

			if (*p != '@@')
			{
				p = oldp;
				break;
			}
			++p;
			while (*p != '\0' && isascii(*p) && isspace(*p))
				p++;
		}
		/* at the end of one complete name */

		/* strip off trailing white space */
		while (p >= name &&
		       ((isascii(*p) && isspace(*p)) || *p == ',' || *p == '\0'))
			p--;
		if (++p == name)
			continue;

		/*
		**  if prescan() failed go a bit backwards; this is a hack,
		**  there should be some better error recovery.
		*/

		if (res == NULL && p > name &&
		    !((isascii(*p) && isspace(*p)) || *p == ',' || *p == '\0'))
			--p;
		savechar = *p;
		*p = '\0';

		/* translate the name to be relative */
		flags = RF_HEADERADDR|RF_ADDDOMAIN;
		if (bitset(H_FROM, h->h_flags))
			flags |= RF_SENDERADDR;
#if USERDB
		else if (e->e_from.q_mailer != NULL &&
			 bitnset(M_UDBRECIPIENT, e->e_from.q_mailer->m_flags))
		{
			char *q;

			q = udbsender(name, e->e_rpool);
			if (q != NULL)
				name = q;
		}
#endif /* USERDB */
		status = EX_OK;
		name = remotename(name, mci->mci_mailer, flags, &status, e);
		if (*name == '\0')
		{
			*p = savechar;
			continue;
		}
		name = denlstring(name, false, true);

		/* output the name with nice formatting */
		opos += strlen(name);
		if (!firstone)
			opos += 2;
		if (opos > omax && !firstone)
		{
			(void) sm_strlcpy(obp, ",\n", SPACELEFT(obuf, obp));
			if (!putxline(obuf, strlen(obuf), mci, putflags))
				goto writeerr;
			obp = obuf;
			(void) sm_strlcpy(obp, "        ", sizeof(obuf));
			opos = strlen(obp);
			obp += opos;
			opos += strlen(name);
		}
		else if (!firstone)
		{
			(void) sm_strlcpy(obp, ", ", SPACELEFT(obuf, obp));
			obp += 2;
		}

		while ((c = *name++) != '\0' && obp < &obuf[MAXLINE])
			*obp++ = c;
		firstone = false;
		*p = savechar;
	}
	if (obp < &obuf[sizeof(obuf)])
		*obp = '\0';
	else
		obuf[sizeof(obuf) - 1] = '\0';
	return putxline(obuf, strlen(obuf), mci, putflags);

  writeerr:
	return false;
}

/*
**  COPYHEADER -- copy header list
**
**	This routine is the equivalent of newstr for header lists
**
**	Parameters:
**		header -- list of header structures to copy.
**		rpool -- resource pool, or NULL
**
**	Returns:
**		a copy of 'header'.
**
**	Side Effects:
**		none.
*/

HDR *
copyheader(header, rpool)
	register HDR *header;
	SM_RPOOL_T *rpool;
{
	register HDR *newhdr;
	HDR *ret;
	register HDR **tail = &ret;

	while (header != NULL)
	{
		newhdr = (HDR *) sm_rpool_malloc_x(rpool, sizeof(*newhdr));
		STRUCTCOPY(*header, *newhdr);
		*tail = newhdr;
		tail = &newhdr->h_link;
		header = header->h_link;
	}
	*tail = NULL;

	return ret;
}

/*
**  FIX_MIME_HEADER -- possibly truncate/rebalance parameters in a MIME header
**
**	Run through all of the parameters of a MIME header and
**	possibly truncate and rebalance the parameter according
**	to MaxMimeFieldLength.
**
**	Parameters:
**		h -- the header to truncate/rebalance
**		e -- the current envelope
**
**	Returns:
**		length of last offending field, 0 if all ok.
**
**	Side Effects:
**		string modified in place
*/

static size_t
fix_mime_header(h, e)
	HDR *h;
	ENVELOPE *e;
{
	char *begin = h->h_value;
	char *end;
	size_t len = 0;
	size_t retlen = 0;

	if (begin == NULL || *begin == '\0')
		return 0;

	/* Split on each ';' */
	/* find_character() never returns NULL */
	while ((end = find_character(begin, ';')) != NULL)
	{
		char save = *end;
		char *bp;

		*end = '\0';

		len = strlen(begin);

		/* Shorten individual parameter */
		if (shorten_rfc822_string(begin, MaxMimeFieldLength))
		{
			if (len < MaxMimeFieldLength)
			{
				/* we only rebalanced a bogus field */
				sm_syslog(LOG_ALERT, e->e_id,
					  "Fixed MIME %s header field (possible attack)",
					  h->h_field);
				if (tTd(34, 11))
					sm_dprintf("  fixed MIME %s header field (possible attack)\n",
						   h->h_field);
			}
			else
			{
				/* we actually shortened the header */
				retlen = len;
			}
		}

		/* Collapse the possibly shortened string with rest */
		bp = begin + strlen(begin);
		if (bp != end)
		{
			char *ep = end;

			*end = save;
			end = bp;

			/* copy character by character due to overlap */
			while (*ep != '\0')
				*bp++ = *ep++;
			*bp = '\0';
		}
		else
			*end = save;
		if (*end == '\0')
			break;

		/* Move past ';' */
		begin = end + 1;
	}
	return retlen;
}
@


1.25
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.24
log
@Update to sendmail 8.14.6
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004, 2006, 2007 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.318 2012/06/14 23:54:02 ca Exp $")
a379 5
		if (tTd(31, 2))
		{
			sm_dprintf("comparing header from (%s) against default (%s or %s)\n",
				fvalue, e->e_from.q_paddr, e->e_from.q_user);
		}
d386 6
d410 13
@


1.23
log
@Update to sendmail 8.14.5
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.317 2008/08/27 20:11:55 gshapiro Exp $")
d1155 1
a1155 1
		e->e_msgsize, e->e_class, e->e_nrcpts);
d1194 1
a1194 1
		  e->e_msgsize, e->e_class, e->e_nrcpts);
@


1.22
log
@Update to sendmail-8.14.3
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.312 2007/06/19 18:52:11 ca Exp $")
d718 10
a727 1
			return h->h_value;
d1077 4
@


1.21
log
@Update to sendmail-8.14.1
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.310 2007/02/07 22:44:35 ca Exp $")
d1868 2
a1869 1
			commaize(h, p, oldstyle, mci, e);
d1981 1
d1991 1
a1991 1
commaize(h, p, oldstyle, mci, e)
d1997 1
a2001 1
	int putflags = PXLF_HEADER | PXLF_STRIPMQUOTE;
@


1.20
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.309 2007/01/08 23:53:25 ca Exp $")
d852 2
a853 1
			if (buf[0] != '\0')
@


1.19
log
@Update to sendmail-8.13.8
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004, 2006 Sendmail, Inc. and its suppliers.
d15 1
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.291 2006/03/24 01:01:56 ca Exp $")
d19 1
a19 1
static HDR	*allocheader __P((char *, char *, int, SM_RPOOL_T *));
d47 1
d49 1
a49 1
**  CHOMPHEADER -- process and save a header line.
d51 1
a51 1
**	Called by collect, readcf, and readqf to deal with header lines.
d68 1
d70 2
a71 2
unsigned long
chompheader(line, pflag, hdrp, e)
d75 1
a75 1
	register ENVELOPE *e;
a90 7
	if (tTd(31, 6))
	{
		sm_dprintf("chompheader: ");
		xputs(sm_debug_file(), line);
		sm_dprintf("\n");
	}

a185 4

	/* strip field value on front */
	if (*p == ' ')
		p++;
d203 1
a203 1
		(void) expand(fvalue, hbuf, sizeof hbuf, e);
d351 1
a351 1
			(void) sm_snprintf(qval, sizeof qval, "%d", k);
a352 1
#if _FFR_HDR_TYPE
a359 1
#endif /* _FFR_HDR_TYPE */
d363 1
a363 1
				       NULL, e->e_id);
d416 1
a416 1
					sizeof mopts);
d423 1
a423 1
	h = (HDR *) sm_rpool_malloc_x(e->e_rpool, sizeof *h);
d427 1
a427 1
	memmove((char *) h->h_mflags, (char *) mopts, sizeof mopts);
d453 63
d520 2
a521 2
**		field -- the name of the header field.
**		value -- the value of the field.
d524 1
d528 7
d538 1
a538 1
allocheader(field, value, flags, rp)
d543 1
d552 1
a552 1
	h = (HDR *) sm_rpool_malloc_x(rp, sizeof *h);
d554 15
a568 1
	h->h_value = sm_rpool_strdup_x(rp, value);
d577 1
d584 2
a585 2
**		field -- the name of the header field.
**		value -- the value of the field.
d588 1
d595 3
d601 1
a601 1
addheader(field, value, flags, e)
d606 1
d620 1
a620 1
	h = allocheader(field, value, flags, e->e_rpool);
d624 1
a626 1
**
d631 2
a632 2
**		field -- the name of the header field.
**		value -- the value of the field.
d635 1
d642 8
d653 1
a653 1
insheader(idx, field, value, flags, e)
d659 1
d664 1
a664 1
	h = allocheader(field, value, flags, e->e_rpool);
d688 1
d700 1
a700 1
**		pointer to the value part.
d722 1
d750 1
a750 1
	register char *s = h;
d752 1
d768 1
d833 1
a833 1
			sm_dprintf("%s: ", h->h_field);
d851 1
a851 1
			expand(h->h_value, buf, sizeof buf, e);
d856 1
a856 1
					       buf, sizeof buf, e);
d920 1
a920 1
		(void) sm_snprintf(buf, sizeof buf, "%d", e->e_hopcount);
d951 1
a951 1
		pvp = prescan(p, '\0', pvpbuf, sizeof pvpbuf, NULL,
d1073 1
d1104 2
a1105 2
		if (l > sizeof mbuf - 1)
			l = sizeof mbuf - 1;
d1125 1
a1125 1
		(void) sm_snprintf(hbuf, sizeof hbuf, "%.80s", RealHostName);
d1204 1
d1233 1
d1316 4
a1319 1
	/* strip leading spaces */
d1321 2
d1324 2
a1331 2
	buflim = bufend = &buf[sizeof(buf) - 1];
	bp = bufhead = buf;
d1639 1
d1687 1
a1687 1
			sm_dprintf("  %s: ", h->h_field);
d1828 1
a1828 1
			expand(p, buf, sizeof buf, e);
d1849 1
a1849 1
				(void) sm_strlcpyn(obuf, sizeof obuf, 2,
d1893 1
a1893 1
			(void) sm_snprintf(obuf, sizeof obuf,
d1909 1
d1933 1
a1933 1
	putflags = PXLF_HEADER;
d1936 1
a1936 1
	(void) sm_snprintf(obuf, sizeof obuf, "%.200s: ", h->h_field);
d1969 1
d1984 1
a1984 1
**		outputs "p" to file "fp".
d1996 1
a1996 2
	int opos;
	int omax;
d1998 1
a1998 1
	int putflags = PXLF_HEADER;
d2008 1
a2008 1
		sm_dprintf("commaize(%s: %s)\n", h->h_field, p);
d2014 31
a2044 2
	(void) sm_snprintf(obp, SPACELEFT(obuf, obp), "%.200s: ",
			h->h_field);
a2045 5
	/* opos = strlen(obp); */
	opos = strlen(h->h_field) + 2;
	if (opos > 202)
		opos = 202;
	obp += opos;
d2081 1
a2081 1
				      sizeof pvpbuf, &oldp, NULL, false);
d2159 1
a2159 1
			(void) sm_strlcpy(obp, "        ", sizeof obuf);
d2175 1
a2175 1
	if (obp < &obuf[sizeof obuf])
d2178 1
a2178 1
		obuf[sizeof obuf - 1] = '\0';
d2212 1
a2212 1
		newhdr = (HDR *) sm_rpool_malloc_x(rpool, sizeof *newhdr);
d2222 1
@


1.18
log
@Update to sendmail 8.13.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.290 2006/02/25 02:16:52 ca Exp $")
d1545 1
a1545 1
**		success
d1813 1
a1813 1
**		success
d1874 1
a1874 1
**		success
@


1.17
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.287 2004/12/03 18:29:51 ca Exp $")
d21 1
a21 1
static void	put_vanilla_header __P((HDR *, char *, MCI *));
a995 1
	int l;
d1004 2
d1545 1
a1545 1
**		none.
d1551 1
a1551 1
void
d1686 2
a1687 1
			put_vanilla_header(h, p, mci);
d1746 2
a1747 1
				putline(obuf, mci);
d1766 2
a1767 1
			put_vanilla_header(h, p, mci);
d1784 2
a1785 1
		putline("MIME-Version: 1.0", mci);
d1791 2
a1792 1
			putline(obuf, mci);
d1794 3
a1796 2
		if (hvalue("Content-Transfer-Encoding", e->e_header) == NULL)
			putline("Content-Transfer-Encoding: 8bit", mci);
d1799 4
d1813 1
a1813 1
**		none.
d1816 1
a1816 1
static void
d1847 2
a1848 1
		putxline(obuf, strlen(obuf), mci, putflags);
d1858 4
a1861 1
	putxline(obuf, strlen(obuf), mci, putflags);
d1874 1
a1874 1
**		none.
d1880 1
a1880 1
void
a2018 7
		/*
		**  record data progress so DNS timeouts
		**  don't cause DATA timeouts
		*/

		DataProgress = true;

d2026 2
a2027 1
			putxline(obuf, strlen(obuf), mci, putflags);
d2049 4
a2052 1
	putxline(obuf, strlen(obuf), mci, putflags);
d2054 1
@


1.17.6.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@d21 1
a21 1
static bool	put_vanilla_header __P((HDR *, char *, MCI *));
d996 1
a1004 2
		size_t l;

d1544 1
a1544 1
**		success
d1550 1
a1550 1
bool
d1685 1
a1685 2
			if (!put_vanilla_header(h, p, mci))
				goto writeerr;
d1744 1
a1744 2
				if (!putline(obuf, mci))
					goto writeerr;
d1763 1
a1763 2
			if (!put_vanilla_header(h, p, mci))
				goto writeerr;
d1780 1
a1780 2
		if (!putline("MIME-Version: 1.0", mci))
			goto writeerr;
d1786 1
a1786 2
			if (!putline(obuf, mci))
				goto writeerr;
d1788 2
a1789 3
		if (hvalue("Content-Transfer-Encoding", e->e_header) == NULL
		    && !putline("Content-Transfer-Encoding: 8bit", mci))
			goto writeerr;
a1791 4
	return true;

  writeerr:
	return false;
d1802 1
a1802 1
**		success
d1805 1
a1805 1
static bool
d1836 1
a1836 2
		if (!putxline(obuf, strlen(obuf), mci, putflags))
			goto writeerr;
d1846 1
a1846 4
	return putxline(obuf, strlen(obuf), mci, putflags);

  writeerr:
	return false;
d1859 1
a1859 1
**		success
d1865 1
a1865 1
bool
d2004 7
d2018 1
a2018 2
			if (!putxline(obuf, strlen(obuf), mci, putflags))
				goto writeerr;
d2040 1
a2040 4
	return putxline(obuf, strlen(obuf), mci, putflags);

  writeerr:
	return false;
a2041 1

@


1.17.4.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@d21 1
a21 1
static bool	put_vanilla_header __P((HDR *, char *, MCI *));
d996 1
a1004 2
		size_t l;

d1544 1
a1544 1
**		success
d1550 1
a1550 1
bool
d1685 1
a1685 2
			if (!put_vanilla_header(h, p, mci))
				goto writeerr;
d1744 1
a1744 2
				if (!putline(obuf, mci))
					goto writeerr;
d1763 1
a1763 2
			if (!put_vanilla_header(h, p, mci))
				goto writeerr;
d1780 1
a1780 2
		if (!putline("MIME-Version: 1.0", mci))
			goto writeerr;
d1786 1
a1786 2
			if (!putline(obuf, mci))
				goto writeerr;
d1788 2
a1789 3
		if (hvalue("Content-Transfer-Encoding", e->e_header) == NULL
		    && !putline("Content-Transfer-Encoding: 8bit", mci))
			goto writeerr;
a1791 4
	return true;

  writeerr:
	return false;
d1802 1
a1802 1
**		success
d1805 1
a1805 1
static bool
d1836 1
a1836 2
		if (!putxline(obuf, strlen(obuf), mci, putflags))
			goto writeerr;
d1846 1
a1846 4
	return putxline(obuf, strlen(obuf), mci, putflags);

  writeerr:
	return false;
d1859 1
a1859 1
**		success
d1865 1
a1865 1
bool
d2004 7
d2018 1
a2018 2
			if (!putxline(obuf, strlen(obuf), mci, putflags))
				goto writeerr;
d2040 1
a2040 4
	return putxline(obuf, strlen(obuf), mci, putflags);

  writeerr:
	return false;
a2041 1

@


1.17.2.1
log
@Apply the patch for the async signals race condition in Sendmail.
@
text
@d21 1
a21 1
static bool	put_vanilla_header __P((HDR *, char *, MCI *));
d996 1
a1004 2
		size_t l;

d1544 1
a1544 1
**		success
d1550 1
a1550 1
bool
d1685 1
a1685 2
			if (!put_vanilla_header(h, p, mci))
				goto writeerr;
d1744 1
a1744 2
				if (!putline(obuf, mci))
					goto writeerr;
d1763 1
a1763 2
			if (!put_vanilla_header(h, p, mci))
				goto writeerr;
d1780 1
a1780 2
		if (!putline("MIME-Version: 1.0", mci))
			goto writeerr;
d1786 1
a1786 2
			if (!putline(obuf, mci))
				goto writeerr;
d1788 2
a1789 3
		if (hvalue("Content-Transfer-Encoding", e->e_header) == NULL
		    && !putline("Content-Transfer-Encoding: 8bit", mci))
			goto writeerr;
a1791 4
	return true;

  writeerr:
	return false;
d1802 1
a1802 1
**		success
d1805 1
a1805 1
static bool
d1836 1
a1836 2
		if (!putxline(obuf, strlen(obuf), mci, putflags))
			goto writeerr;
d1846 1
a1846 4
	return putxline(obuf, strlen(obuf), mci, putflags);

  writeerr:
	return false;
d1859 1
a1859 1
**		success
d1865 1
a1865 1
bool
d2004 7
d2018 1
a2018 2
			if (!putxline(obuf, strlen(obuf), mci, putflags))
				goto writeerr;
d2040 1
a2040 4
	return putxline(obuf, strlen(obuf), mci, putflags);

  writeerr:
	return false;
a2041 1

@


1.16
log
@Update to sendmail-8.13.1
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.286 2004/07/08 17:57:32 ca Exp $")
d1814 1
a1814 1
	char obuf[MAXLINE];
@


1.15
log
@Update to sendmail.8.13.0
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.284 2004/04/29 00:05:59 msk Exp $")
d18 1
d362 1
a362 8
			/*
			**  XXX: h isn't set yet
			**  If we really want to be precise then we have
			**  to lookup the header (see below).
			**  It's probably not worth the effort.
			*/

			if (bitset(H_FROM, h->h_flags))
d365 1
a365 1
			else if (bitset(H_RCPT, h->h_flags))
d569 1
a569 1
	HDR *h, *srch, *last;
d586 1
@


1.14
log
@Update to sendmail 8.12.11.  I've been runninga beta version of this for
some time without problems.  See the RELEASE_NOTES for the change log.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.266.4.9 2003/10/30 00:17:22 gshapiro Exp $")
d90 1
a90 1
		xputs(line);
a293 2
		/* no ruleset? look for default */
		rs = hi->hi_ruleset;
d297 3
d470 38
a532 1
	STAB *s;
a535 3
	/* find info struct */
	s = stab(field, ST_HEADER, ST_FIND);

d544 1
a544 3
	h = (HDR *) sm_rpool_malloc_x(e->e_rpool, sizeof *h);
	h->h_field = field;
	h->h_value = sm_rpool_strdup_x(e->e_rpool, value);
a545 5
	h->h_flags = flags;
	if (s != NULL)
		h->h_flags |= s->s_header.hi_flags;
	clrbitmap(h->h_mflags);
	h->h_macro = '\0';
d549 53
d757 1
a757 1
				xputs(h->h_value);
d772 1
a772 1
			xputs(h->h_value);
a813 1
#if _FFR_MESSAGEID_MACRO
d815 1
a815 2
			          e->e_msgid);
#endif /* _FFR_MESSAGEID_MACRO */
d848 54
a912 1
#if _FFR_QUEUERETURN_DSN
a914 1
#endif /* _FFR_QUEUERETURN_DSN */
a915 1
#if _FFR_QUEUERETURN_DSN
a917 1
#endif /* _FFR_QUEUERETURN_DSN */
a1370 1
				{
d1372 1
a1372 4
					SM_APPEND_CHAR(c);
				}
				else
					SM_APPEND_CHAR(c);
d1534 1
a1534 1
		xputs(buf);
d1587 1
a1587 1
			xputs(p);
d1941 1
a1941 1
				      sizeof pvpbuf, &oldp, NULL);
@


1.13
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.266.4.7 2003/09/03 21:32:20 ca Exp $")
d733 4
d780 4
a784 1

d786 1
a786 2
	/* If no timeoutclass picked and it's a DSN, use that timeoutclass */
	if (e->e_timeoutclass == TOC_NORMAL && bitset(EF_RESPONSE, e->e_flags))
@


1.12
log
@Update to sendmail 8.12.9; fixes a buffer overflow in address parsing
due to a char to int conversion problem which is potentially remotely
exploitable.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.266.4.5 2003/03/12 22:42:52 gshapiro Exp $")
d143 1
d145 2
d321 1
d1182 1
a1182 1
			if (copylev > 0 && SM_HAVE_ROOM)
d1356 1
a1356 1
				if (copylev > 0)
d1700 6
d1716 2
d1752 1
d1769 2
d1803 1
d1809 2
a1810 2
			(void) prescan(p, oldstyle ? ' ' : ',', pvpbuf,
				       sizeof pvpbuf, &oldp, NULL);
d1812 8
d1842 9
d1894 1
a1894 1
			(void) sm_strlcpy(obp, "        ", sizeof obp);
d1910 4
a1913 1
	*obp = '\0';
d1985 1
@


1.11
log
@Update to Sendmail 8.12.8; fixes a buffer overflow in the envelope
comments processing which may allow an attacker to gain root privileges.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.266.4.4 2003/01/18 00:41:48 gshapiro Exp $")
d773 6
@


1.10
log
@update to sendmail 8.12.7
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.266.4.2 2002/09/23 23:42:02 ca Exp $")
d18 1
a18 1
static size_t	fix_mime_header __P((char *));
d679 2
a680 2
					expand(crackaddr(buf), buf, sizeof buf,
					       e);
d1001 5
a1005 1
**	something semantically identical.
d1014 1
d1027 20
d1048 1
a1048 1
crackaddr(addr)
d1050 1
d1054 12
a1065 12
	int cmtlev;
	int realcmtlev;
	int anglelev, realanglelev;
	int copylev;
	int bracklev;
	bool qmode;
	bool realqmode;
	bool skipping;
	bool putgmac = false;
	bool quoteit = false;
	bool gotangle = false;
	bool gotcolon = false;
d1070 1
d1085 1
a1086 1
	buflim = &buf[sizeof buf - 7];
d1088 1
a1088 1
	copylev = anglelev = realanglelev = cmtlev = realcmtlev = 0;
d1090 1
a1090 1
	qmode = realqmode = false;
d1095 2
a1096 3
		**  If the buffer is overful, go into a special "skipping"
		**  mode that tries to keep legal syntax but doesn't actually
		**  output things.
d1099 2
a1100 4
		skipping = bp >= buflim;

		if (copylev > 0 && !skipping)
			*bp++ = c;
d1115 2
a1116 2
			if (copylev > 0 && !skipping)
				*bp++ = c;
d1124 6
a1129 1
			if (copylev > 0 && !skipping)
d1131 1
d1143 1
a1143 1
			if (!skipping)
d1150 2
a1151 2
						*bp++ = ' ';
					*bp++ = c;
d1161 1
a1161 1
				if (!skipping)
d1172 1
a1172 1
			if (copylev > 0 && !skipping)
d1190 1
a1190 1
			**  or **  DECnet phase V ``:.'' syntaxes.  The latter
d1199 1
a1199 1
				if (copylev > 0 && !skipping)
d1201 2
a1202 2
					*bp++ = c;
					*bp++ = *p;
d1213 1
a1213 1
				*bp++ = '"';
d1217 2
a1218 1
				while (isascii(*--p) && isspace(*p))
d1225 1
a1225 1
				if (bp < buflim)
d1227 2
a1228 3
					if (quoteit && c == '"')
						*bp++ = '\\';
					*bp++ = c;
d1230 2
d1238 1
a1238 1
					*bp++ = '"';
d1240 2
a1241 5
				{
					if (bp < buflim)
						*bp++ = c;
				}
				*bp++ = c;
d1245 5
a1249 2
			while (isascii(*p) && isspace(*p) && bp < buflim)
				*bp++ = *p++;
d1258 1
a1258 4
		{
			if (bp < buflim)
				*bp++ = c;
		}
d1286 6
a1291 2
			if (!skipping)
				realanglelev = 1;
d1296 1
a1296 1
				*bp++ = '"';
d1300 2
a1301 1
				while (isascii(*--p) && isspace(*p))
d1308 1
a1308 1
				if (bp < buflim)
d1310 2
a1311 3
					if (quoteit && c == '"')
						*bp++ = '\\';
					*bp++ = c;
d1313 2
d1321 1
a1321 1
					*bp++ = '"';
d1323 2
a1324 5
				{
					if (bp < buflim)
						*bp++ = c;
				}
				*bp++ = c;
d1336 1
a1336 1
				if (!skipping)
d1338 3
a1340 2
					realanglelev--;
					buflim++;
d1343 1
a1343 1
			else if (!skipping)
d1352 1
a1352 1
				*bp++ = c;
d1360 4
a1363 4
			if (bp > bufhead && bp[-1] == ')')
				*bp++ = ' ';
			*bp++ = MACROEXPAND;
			*bp++ = 'g';
d1369 1
a1369 1
	if (realqmode)
d1371 1
a1371 1
	while (realcmtlev-- > 0)
d1373 1
a1373 1
	while (realanglelev-- > 0)
d1375 13
a1387 1
	*bp++ = '\0';
d1389 1
a1395 1

d1460 1
a1460 1
			len = fix_mime_header(h->h_value);
d1503 22
a1524 7
				sm_syslog(LOG_ALERT, e->e_id,
					  "Truncated long MIME %s header (length = %ld) (possible attack)",
					  h->h_field, (unsigned long) len);
				if (tTd(34, 11))
					sm_dprintf("  truncated long MIME %s header (length = %ld) (possible attack)\n",
						   h->h_field,
						   (unsigned long) len);
d1919 2
a1920 1
**		string -- the full header
d1930 3
a1932 2
fix_mime_header(string)
	char *string;
d1934 1
a1934 1
	char *begin = string;
d1939 1
a1939 1
	if (string == NULL || *string == '\0')
d1954 17
a1970 1
			retlen = len;
@


1.9
log
@update to sendmail-8.12.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.266.4.1 2002/08/16 14:56:01 ca Exp $")
d931 1
a931 1
	sm_syslog(LOG_INFO, e->e_id, "%.850s, relay=%.100s", sbuf, name);
d963 1
a963 1
		  "%.400srelay=%.100s", sbuf, name);
@


1.9.2.1
log
@Errata #009:
A buffer overflow in the envelope comments processing in sendmail may
allow an attacker to gain root privileges.
@
text
@d679 2
a680 2
					expand(crackaddr(buf, e),
					       buf, sizeof buf, e);
d1001 1
a1001 5
**	something semantically identical if possible, else at least
**	syntactically correct.
**
**	For example, it changes "Real Name <real@@example.com> (Comment)"
**	to "Real Name <$g> (Comment)".
a1009 1
**		e -- the current envelope.
a1021 20
#define SM_HAVE_ROOM		((bp < buflim) && (buflim <= bufend))

/*
**  Append a character to bp if we have room.
**  If not, punt and return $g.
*/

#define SM_APPEND_CHAR(c)					\
	do							\
	{							\
		if (SM_HAVE_ROOM)				\
			*bp++ = (c);				\
		else						\
			goto returng;				\
	} while (0)

#if MAXNAME < 10
ERROR MAXNAME must be at least 10
#endif /* MAXNAME < 10 */

d1023 1
a1023 1
crackaddr(addr, e)
a1024 1
	ENVELOPE *e;
d1028 12
a1039 12
	int cmtlev;			/* comment level in input string */
	int realcmtlev;			/* comment level in output string */
	int anglelev;			/* angle level in input string */
	int copylev;			/* 0 == in address, >0 copying */
	int bracklev;			/* bracket level for IPv6 addr check */
	bool addangle;			/* put closing angle in output */
	bool qmode;			/* quoting in original string? */
	bool realqmode;			/* quoting in output string? */
	bool putgmac = false;		/* already wrote $g */
	bool quoteit = false;		/* need to quote next character */
	bool gotangle = false;		/* found first '<' */
	bool gotcolon = false;		/* found a ':' */
a1043 1
	char *bufend;
a1057 1
	buflim = bufend = &buf[sizeof(buf) - 1];
d1059 1
d1061 1
a1061 1
	copylev = anglelev = cmtlev = realcmtlev = 0;
d1063 1
a1063 1
	qmode = realqmode = addangle = false;
d1068 3
a1070 2
		**  Try to keep legal syntax using spare buffer space
		**  (maintained by buflim).
d1073 4
a1076 2
		if (copylev > 0)
			SM_APPEND_CHAR(c);
d1091 2
a1092 2
			if (copylev > 0)
				SM_APPEND_CHAR(c);
d1100 1
a1100 6
			if (copylev > 0 && SM_HAVE_ROOM)
			{
				if (realqmode)
					buflim--;
				else
					buflim++;
a1101 1
			}
d1113 1
a1113 1
			if (SM_HAVE_ROOM)
d1120 2
a1121 2
						SM_APPEND_CHAR(' ');
					SM_APPEND_CHAR(c);
d1131 1
a1131 1
				if (SM_HAVE_ROOM)
d1142 1
a1142 1
			if (copylev > 0 && SM_HAVE_ROOM)
d1160 1
a1160 1
			**  or DECnet phase V ``:.'' syntaxes.  The latter
d1169 1
a1169 1
				if (copylev > 0)
d1171 2
a1172 2
					SM_APPEND_CHAR(c);
					SM_APPEND_CHAR(*p);
d1183 1
a1183 1
				SM_APPEND_CHAR('"');
d1187 1
a1187 2
				while (p > addr &&
				       isascii(*--p) && isspace(*p))
d1194 1
a1194 1
				if (quoteit && c == '"')
d1196 3
a1198 2
					SM_APPEND_CHAR('\\');
					SM_APPEND_CHAR(c);
a1199 2
				else
					SM_APPEND_CHAR(c);
d1206 1
a1206 1
					SM_APPEND_CHAR('"');
d1208 5
a1212 2
					SM_APPEND_CHAR(c);
				SM_APPEND_CHAR(c);
d1216 2
a1217 5
			while (isascii(*p) && isspace(*p))
			{
				SM_APPEND_CHAR(*p);
				p++;
			}
d1226 4
a1229 1
			SM_APPEND_CHAR(c);
d1257 2
a1258 6
			if (SM_HAVE_ROOM)
			{
				if (!addangle)
					buflim--;
				addangle = true;
			}
d1263 1
a1263 1
				SM_APPEND_CHAR('"');
d1267 1
a1267 2
				while (p > addr &&
				       isascii(*--p) && isspace(*p))
d1274 1
a1274 1
				if (quoteit && c == '"')
d1276 3
a1278 2
					SM_APPEND_CHAR('\\');
					SM_APPEND_CHAR(c);
a1279 2
				else
					SM_APPEND_CHAR(c);
d1286 1
a1286 1
					SM_APPEND_CHAR('"');
d1288 5
a1292 2
					SM_APPEND_CHAR(c);
				SM_APPEND_CHAR(c);
d1304 1
a1304 1
				if (SM_HAVE_ROOM)
d1306 2
a1307 3
					if (addangle)
						buflim++;
					addangle = false;
d1310 1
a1310 1
			else if (SM_HAVE_ROOM)
d1319 1
a1319 1
				SM_APPEND_CHAR(c);
d1327 4
a1330 4
			if (bp > buf && bp[-1] == ')')
				SM_APPEND_CHAR(' ');
			SM_APPEND_CHAR(MACROEXPAND);
			SM_APPEND_CHAR('g');
d1336 1
a1336 1
	if (realqmode && bp < bufend)
d1338 1
a1338 1
	while (realcmtlev-- > 0 && bp < bufend)
d1340 1
a1340 1
	if (addangle && bp < bufend)
d1342 1
a1342 13
	*bp = '\0';
	if (bp < bufend)
		goto success;

 returng:
	/* String too long, punt */
	buf[0] = '<';
	buf[1] = MACROEXPAND;
	buf[2]= 'g';
	buf[3] = '>';
	buf[4]= '\0';
	sm_syslog(LOG_ALERT, e->e_id,
		  "Dropped invalid comments from header address");
a1343 1
 success:
d1350 1
@


1.8
log
@update to sendmail-8.12.2
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.266 2001/10/12 01:50:12 gshapiro Exp $")
d288 1
a288 1
		bool stripcom = false;
d293 3
d302 3
a304 2
				stripcom = bitset((&s->s_header)->hi_flags,
						  H_STRIPCOMM);
d307 2
a308 2
		else
			stripcom = bitset(hi->hi_flags, H_STRIPCOMM);
d373 1
a373 1
			(void) rscheck(rs, fvalue, NULL, e, stripcom, true, 3,
@


1.8.2.1
log
@Errata #022:
A buffer overflow in the envelope comments processing in sendmail may
allow an attacker to gain root privileges.
@
text
@d675 2
a676 2
					expand(crackaddr(buf, e),
					       buf, sizeof buf, e);
d997 1
a997 5
**	something semantically identical if possible, else at least
**	syntactically correct.
**
**	For example, it changes "Real Name <real@@example.com> (Comment)"
**	to "Real Name <$g> (Comment)".
a1005 1
**		e -- the current envelope.
a1017 20
#define SM_HAVE_ROOM		((bp < buflim) && (buflim <= bufend))

/*
**  Append a character to bp if we have room.
**  If not, punt and return $g.
*/

#define SM_APPEND_CHAR(c)					\
	do							\
	{							\
		if (SM_HAVE_ROOM)				\
			*bp++ = (c);				\
		else						\
			goto returng;				\
	} while (0)

#if MAXNAME < 10
ERROR MAXNAME must be at least 10
#endif /* MAXNAME < 10 */

d1019 1
a1019 1
crackaddr(addr, e)
a1020 1
	ENVELOPE *e;
d1024 12
a1035 12
	int cmtlev;			/* comment level in input string */
	int realcmtlev;			/* comment level in output string */
	int anglelev;			/* angle level in input string */
	int copylev;			/* 0 == in address, >0 copying */
	int bracklev;			/* bracket level for IPv6 addr check */
	bool addangle;			/* put closing angle in output */
	bool qmode;			/* quoting in original string? */
	bool realqmode;			/* quoting in output string? */
	bool putgmac = false;		/* already wrote $g */
	bool quoteit = false;		/* need to quote next character */
	bool gotangle = false;		/* found first '<' */
	bool gotcolon = false;		/* found a ':' */
a1039 1
	char *bufend;
a1053 1
	buflim = bufend = &buf[sizeof(buf) - 1];
d1055 1
d1057 1
a1057 1
	copylev = anglelev = cmtlev = realcmtlev = 0;
d1059 1
a1059 1
	qmode = realqmode = addangle = false;
d1064 3
a1066 2
		**  Try to keep legal syntax using spare buffer space
		**  (maintained by buflim).
d1069 4
a1072 2
		if (copylev > 0)
			SM_APPEND_CHAR(c);
d1087 2
a1088 2
			if (copylev > 0)
				SM_APPEND_CHAR(c);
d1096 1
a1096 6
			if (copylev > 0 && SM_HAVE_ROOM)
			{
				if (realqmode)
					buflim--;
				else
					buflim++;
a1097 1
			}
d1109 1
a1109 1
			if (SM_HAVE_ROOM)
d1116 2
a1117 2
						SM_APPEND_CHAR(' ');
					SM_APPEND_CHAR(c);
d1127 1
a1127 1
				if (SM_HAVE_ROOM)
d1138 1
a1138 1
			if (copylev > 0 && SM_HAVE_ROOM)
d1156 1
a1156 1
			**  or DECnet phase V ``:.'' syntaxes.  The latter
d1165 1
a1165 1
				if (copylev > 0)
d1167 2
a1168 2
					SM_APPEND_CHAR(c);
					SM_APPEND_CHAR(*p);
d1179 1
a1179 1
				SM_APPEND_CHAR('"');
d1183 1
a1183 2
				while (p > addr &&
				       isascii(*--p) && isspace(*p))
d1190 1
a1190 1
				if (quoteit && c == '"')
d1192 3
a1194 2
					SM_APPEND_CHAR('\\');
					SM_APPEND_CHAR(c);
a1195 2
				else
					SM_APPEND_CHAR(c);
d1202 1
a1202 1
					SM_APPEND_CHAR('"');
d1204 5
a1208 2
					SM_APPEND_CHAR(c);
				SM_APPEND_CHAR(c);
d1212 2
a1213 5
			while (isascii(*p) && isspace(*p))
			{
				SM_APPEND_CHAR(*p);
				p++;
			}
d1222 4
a1225 1
			SM_APPEND_CHAR(c);
d1253 2
a1254 6
			if (SM_HAVE_ROOM)
			{
				if (!addangle)
					buflim--;
				addangle = true;
			}
d1259 1
a1259 1
				SM_APPEND_CHAR('"');
d1263 1
a1263 2
				while (p > addr &&
				       isascii(*--p) && isspace(*p))
d1270 1
a1270 1
				if (quoteit && c == '"')
d1272 3
a1274 2
					SM_APPEND_CHAR('\\');
					SM_APPEND_CHAR(c);
a1275 2
				else
					SM_APPEND_CHAR(c);
d1282 1
a1282 1
					SM_APPEND_CHAR('"');
d1284 5
a1288 2
					SM_APPEND_CHAR(c);
				SM_APPEND_CHAR(c);
d1300 1
a1300 1
				if (SM_HAVE_ROOM)
d1302 2
a1303 3
					if (addangle)
						buflim++;
					addangle = false;
d1306 1
a1306 1
			else if (SM_HAVE_ROOM)
d1315 1
a1315 1
				SM_APPEND_CHAR(c);
d1323 4
a1326 4
			if (bp > buf && bp[-1] == ')')
				SM_APPEND_CHAR(' ');
			SM_APPEND_CHAR(MACROEXPAND);
			SM_APPEND_CHAR('g');
d1332 1
a1332 1
	if (realqmode && bp < bufend)
d1334 1
a1334 1
	while (realcmtlev-- > 0 && bp < bufend)
d1336 1
a1336 1
	if (addangle && bp < bufend)
d1338 1
a1338 13
	*bp = '\0';
	if (bp < bufend)
		goto success;

 returng:
	/* String too long, punt */
	buf[0] = '<';
	buf[1] = MACROEXPAND;
	buf[2]= 'g';
	buf[3] = '>';
	buf[4]= '\0';
	sm_syslog(LOG_ALERT, e->e_id,
		  "Dropped invalid comments from header address");
a1339 1
 success:
d1346 1
@


1.7
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.265 2001/09/11 04:05:14 gshapiro Exp $")
d701 2
a702 2
			(void) sendtolist(h->h_value, NULLADDR,
					  &e->e_sendqueue, 0, e);
@


1.6
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.262 2001/09/04 22:43:03 ca Exp $")
d45 1
a45 1
/*
d460 1
a460 1
/*
d512 1
a512 1
/*
d545 1
a545 1
/*
d589 1
a589 1
/*
d833 1
a833 1
/*
d962 1
a962 1
/*
d990 1
a990 1
/*
d1349 1
a1349 1
/*
d1593 1
a1593 1
/*
d1640 1
a1640 1
/*
d1810 1
a1810 1
/*
d1847 1
a1847 1
/*
@


1.5
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d14 1
a14 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: headers.c,v 8.203.4.13 2001/05/03 17:24:06 gshapiro Exp $";
#endif /* ! lint */
d16 1
a16 1
#include <sendmail.h>
d66 1
a66 1
u_long
d73 1
a73 1
	u_char mid = '\0';
d79 1
a79 1
	bool cond = FALSE;
d84 1
a84 1
	bool nullheader = FALSE;
d89 1
a89 1
		dprintf("chompheader: ");
d91 1
a91 1
		dprintf("\n");
d123 1
a123 1
			mid = (u_char) *p++;
d141 1
a141 1
			mid = (u_char)macid(p, NULL);
a152 1

d165 1
a165 1
				cond = TRUE;
d196 1
a196 1
		nullheader = TRUE;
d222 6
d246 1
a246 1
			dprintf("no header flags match\n");
d248 4
a251 3
			dprintf("header match, flags=%lx, ruleset=%s\n",
				hi->hi_flags,
				hi->hi_ruleset == NULL ? "<NULL>" : hi->hi_ruleset);
d288 1
a288 1
		bool stripcom = FALSE;
d307 1
a307 1
			int l;
a308 2
			char hlen[16];
			char *sp, *dp;
a309 1
			dp = qval;
d311 4
a314 2
			dp[l++] = '"';
			for (sp = fvalue; *sp != '\0' && l < MAXNAME - 3; sp++)
d316 1
a316 1
				switch(*sp)
d318 1
d324 1
a324 1
					dp[l++] = ' ';
d327 1
a327 1
					dp[l++] = '\\';
d330 1
a330 1
					dp[l++] = *sp;
d334 4
a337 6
			dp[l++] = '"';
			dp[l++] = '\0';
			l = strlen(fvalue);
			snprintf(hlen, sizeof hlen, "%d", l);
			define(macid("{hdrlen}", NULL), newstr(hlen), e);
			if (l >= MAXNAME)
d342 1
a342 1
						  fname, rs, l, MAXNAME - 1);
d344 27
a370 7
			if ((sp = macvalue(macid("{currHeader}", NULL), e)) !=
			    NULL)
				sm_free(sp);
			define(macid("{currHeader}", NULL), newstr(qval), e);
			define(macid("{hdr_name}", NULL), newstr(fname), e);
			(void) rscheck(rs, fvalue, NULL, e, stripcom, TRUE, 4,
				       NULL);
d380 1
a380 1
	dropfrom = FALSE;
d385 1
a385 1
	    !bitset(EF_QUEUERUN, e->e_flags) && strcasecmp(fname, p) == 0)
d389 1
a389 1
			dprintf("comparing header from (%s) against default (%s or %s)\n",
d397 1
a397 1
			dropfrom = TRUE;
d403 1
a403 1
		if (strcasecmp(fname, h->h_field) == 0 &&
d422 1
a422 1
				memmove((char *)mopts, (char *)h->h_mflags,
d430 3
a432 3
	h = (HDR *) xalloc(sizeof *h);
	h->h_field = newstr(fname);
	h->h_value = newstr(fvalue);
d469 1
a469 1
**		hdrlist -- an indirect pointer to the header structure list.
d479 1
a479 1
addheader(field, value, flags, hdrlist)
d483 1
a483 1
	HDR **hdrlist;
d488 1
d496 1
a496 1
		if (strcasecmp(field, h->h_field) == 0)
d501 1
a501 1
	h = (HDR *) xalloc(sizeof *h);
d503 1
a503 1
	h->h_value = newstr(value);
d540 1
a540 1
		    strcasecmp(h->h_field, field) == 0)
d561 2
a562 2
**		TRUE if h is a header.
**		FALSE otherwise.
d575 1
a575 1
		return FALSE;
d581 1
a581 1
		return FALSE;
d598 1
a605 1
**		Aborts the message if the hop count is exceeded.
d609 1
a609 1
eatheader(e, full)
d612 1
a616 1
	char *msgid;
d623 2
a624 2
	define('f', e->e_sender, e);
	define('g', e->e_sender, e);
d626 1
a626 1
		define('u', e->e_origrcpt, e);
d628 1
a628 1
		define('u', NULL, e);
d641 2
a642 1
			p = addquotes(p);
d644 1
a644 1
		define('x', p, e);
d648 2
a649 2
		dprintf("----- collected header -----\n");
	msgid = NULL;
d653 1
a653 1
			dprintf("%s: ", h->h_field);
d657 1
a657 1
				dprintf("<NULL>\n");
d667 1
a667 1
				dprintf("(");
d669 1
a669 1
				dprintf(") ");
d675 3
a677 2
					expand(crackaddr(buf), buf, sizeof buf, e);
				h->h_value = newstr(buf);
a680 1

d684 1
a684 1
			dprintf("\n");
d694 2
a695 1
		    (!bitset(EF_RESENT, e->e_flags) || bitset(H_RESENT, h->h_flags)))
d720 1
a720 1
		if (strcasecmp(h->h_field, p) == 0)
d722 3
a724 3
			msgid = h->h_value;
			while (isascii(*msgid) && isspace(*msgid))
				msgid++;
d728 1
a728 1
		dprintf("----------------------------\n");
d736 1
d738 3
d762 1
a762 1
		if (strcasecmp(p, "urgent") == 0)
d764 1
a764 1
		else if (strcasecmp(p, "normal") == 0)
d766 1
a766 1
		else if (strcasecmp(p, "non-urgent") == 0)
d775 1
a775 1
		define('a', p, e);
d779 1
a779 1
	     strcasecmp(e->e_bodytype, "8BITMIME") == 0) ||
d817 1
a817 1
				dprintf("eatheader: setsender(*%s == %s)\n",
d819 1
a819 1
			setsender(p, e, NULL, '\0', TRUE);
d827 5
a831 3
	if (bitset(EF_LOGSENDER, e->e_flags) && LogLevel > 4)
		logsender(e, msgid);
	e->e_flags &= ~EF_LOGSENDER;
d858 1
d883 1
a883 1
		(void) snprintf(hbuf, sizeof hbuf, "%.80s", RealHostName);
d887 3
a889 2
			(void) snprintf(p, SPACELEFT(hbuf, p), " (%.100s)",
				anynet_ntoa(&RealHostAddr));
d896 4
a899 4
	snprintf(sbp, SPACELEFT(sbuf, sbp),
	    "from=%.200s, size=%ld, class=%d, nrcpts=%d",
	    e->e_from.q_paddr == NULL ? "<NONE>" : e->e_from.q_paddr,
	    e->e_msgsize, e->e_class, e->e_nrcpts);
d903 2
a904 1
		snprintf(sbp, SPACELEFT(sbuf, sbp), ", msgid=%.100s", mbuf);
d909 2
a910 2
		(void) snprintf(sbp, SPACELEFT(sbuf, sbp), ", bodytype=%.20s",
			e->e_bodytype);
d916 2
a917 14
		(void) snprintf(sbp, SPACELEFT(sbuf, sbp), ", proto=%.20s", p);
		sbp += strlen(sbp);
	}
	p = macvalue(macid("{daemon_name}", NULL), e);
	if (p != NULL)
	{
		(void) snprintf(sbp, SPACELEFT(sbuf, sbp), ", daemon=%.20s", p);
		sbp += strlen(sbp);
	}
# if SASL
	p = macvalue(macid("{auth_type}", NULL), e);
	if (p != NULL)
	{
		(void) snprintf(sbp, SPACELEFT(sbuf, sbp), ", mech=%.12s", p);
d920 1
a920 1
	p = macvalue(macid("{auth_author}", NULL), e);
d923 2
a924 1
		(void) snprintf(sbp, SPACELEFT(sbuf, sbp), ", auth=%.30s", p);
d927 1
a927 4
# endif /* SASL */
	sm_syslog(LOG_INFO, e->e_id,
		  "%.850s, relay=%.100s",
		  sbuf, name);
d934 2
a935 1
					    : shortenstring(e->e_from.q_paddr, 83));
d947 2
a948 1
		snprintf(sbp, SPACELEFT(sbuf, sbp), "bodytype=%.20s, ", e->e_bodytype);
d954 2
a955 1
		snprintf(sbp, SPACELEFT(sbuf, sbp), "proto=%.20s, ", p);
d983 1
a983 1
		if (strcasecmp(p, Priorities[i].pri_name) == 0)
d1032 4
a1035 4
	bool putgmac = FALSE;
	bool quoteit = FALSE;
	bool gotangle = FALSE;
	bool gotcolon = FALSE;
d1043 1
a1043 1
		dprintf("crackaddr(%s)\n", addr);
d1059 1
a1059 1
	qmode = realqmode = FALSE;
d1079 1
a1079 1
				quoteit = TRUE;
d1164 1
a1164 1
					quoteit = TRUE;
d1174 1
a1174 1
			gotcolon = TRUE;
d1215 1
a1215 1
			putgmac = quoteit = FALSE;
d1238 1
a1238 1
				quoteit = TRUE;
d1248 2
a1249 2
				quoteit = TRUE;
			gotangle = TRUE;
d1291 1
a1291 1
			putgmac = quoteit = FALSE;
d1311 1
a1311 1
				quoteit = TRUE;
d1327 1
a1327 1
			putgmac = TRUE;
d1342 1
a1342 1
		dprintf("crackaddr=>`");
d1344 1
a1344 1
		dprintf("'\n");
a1364 7
/*
 * Macro for fast max (not available in e.g. DG/UX, 386/ix).
 */
#ifndef MAX
# define MAX(a,b) (((a)>(b))?(a):(b))
#endif /* ! MAX */

d1373 1
a1373 1
	char buf[MAX(MAXLINE,BUFSIZ)];
d1377 1
a1377 1
		dprintf("--- putheader, mailer = %s ---\n",
d1392 1
d1396 1
a1396 1
			dprintf("  %s: ", h->h_field);
d1407 1
a1407 1
				macid("{checkMIMEFieldHeaders}", NULL)))
d1418 3
a1420 3
					dprintf("  truncated MIME %s header due to field size  (length = %ld) (possible attack)\n",
						h->h_field,
						(unsigned long) len);
d1426 1
a1426 1
				macid("{checkMIMETextHeaders}", NULL)))
d1438 3
a1440 3
					dprintf("  truncated long MIME %s header (length = %ld) (possible attack)\n",
						h->h_field,
						(unsigned long) len);
d1446 1
a1446 1
				macid("{checkMIMEHeaders}", NULL)))
d1458 3
a1460 3
					dprintf("  truncated long MIME %s header (length = %ld) (possible attack)\n",
						h->h_field,
						(unsigned long) len);
d1470 1
d1477 1
a1477 1
				dprintf(" (skipped (content-transfer-encoding))\n");
d1484 1
a1484 1
				dprintf("\n");
d1492 2
a1493 1
		     macvalue(bitidx(h->h_macro), e) == NULL))
d1496 1
a1496 1
				dprintf(" (skipped)\n");
d1504 1
a1504 1
				dprintf(" (skipped (resent))\n");
d1513 1
a1513 1
				dprintf(" (skipped (receipt))\n");
d1526 1
a1526 1
					dprintf(" (skipped -- null value)\n");
d1537 1
a1537 1
					dprintf(" (skipped -- bcc)\n");
d1542 2
a1543 2
				(void) snprintf(obuf, sizeof obuf, "%s:",
					h->h_field);
d1550 1
a1550 1
			dprintf("\n");
d1558 1
a1558 1
				oldstyle = FALSE;
d1583 3
a1585 3
			snprintf(obuf, sizeof obuf,
				"Content-Type: text/plain; charset=%s",
				defcharset(e));
d1619 1
a1619 1
	(void) snprintf(obuf, sizeof obuf, "%.200s: ", h->h_field);
d1626 1
a1626 1
		if (SPACELEFT(obuf, obp) - 1 < (size_t)l)
d1629 1
a1629 1
		snprintf(obp, SPACELEFT(obuf, obp), "%.*s", l, v);
d1636 2
a1637 2
	snprintf(obp, SPACELEFT(obuf, obp), "%.*s",
		(int) sizeof obuf - (obp - obuf) - 1, v);
d1646 1
a1646 1
**		oldstyle -- TRUE if this is an old style header.
d1668 1
a1668 1
	bool firstone = TRUE;
d1678 1
a1678 1
		dprintf("commaize(%s: %s)\n", h->h_field, p);
d1684 2
a1685 1
	(void) snprintf(obp, SPACELEFT(obuf, obp), "%.200s: ", h->h_field);
d1736 1
a1736 1
			p += *p == '@@' ? 1 : 2;
d1761 1
a1761 1
			q = udbsender(name);
d1773 1
a1773 1
		name = denlstring(name, FALSE, TRUE);
d1780 1
a1780 1
		DataProgress = TRUE;
d1788 1
a1788 1
			snprintf(obp, SPACELEFT(obuf, obp), ",\n");
d1791 1
a1791 1
			(void) strlcpy(obp, "        ", sizeof obp);
d1798 1
a1798 1
			snprintf(obp, SPACELEFT(obuf, obp), ", ");
d1804 1
a1804 1
		firstone = FALSE;
d1817 1
d1827 1
a1827 1
copyheader(header)
d1829 1
d1837 1
a1837 1
		newhdr = (HDR *) xalloc(sizeof *newhdr);
@


1.4
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: headers.c,v 8.203.4.12 2001/01/22 19:00:22 gshapiro Exp $";
d344 1
a344 1
				free(sp);
@


1.4.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: headers.c,v 8.203.4.13 2001/05/03 17:24:06 gshapiro Exp $";
d344 1
a344 1
				sm_free(sp);
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: headers.c,v 8.203.4.10 2000/10/13 17:54:30 gshapiro Exp $";
d311 1
a311 1
			for (sp = fvalue; *sp != '\0' && l < MAXNAME - 2; sp++)
d340 1
a340 1
						  fname, rs, l, MAXNAME);
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: headers.c,v 8.203 2000/03/15 21:47:29 ca Exp $";
d20 1
a20 1
static bool	fix_mime_header __P((char *));
d54 1
a54 3
**		pflag -- flags:
**			CHHDR_DEF: this is a default value.
**			CHHDR_CHECK: call rulesets.
d71 1
a71 1
	int *pflag;
d82 1
d103 1
a103 1
	if (!bitset(*pflag, CHHDR_USER) && *p == '?')
d167 1
a167 1
				setbitn(*p, mopts);
d206 1
a206 1
	if (bitset(*pflag, CHHDR_DEF))
d251 1
a251 1
	if (!bitset(*pflag, CHHDR_DEF) && !headeronly &&
d256 1
a256 1
	if (UseErrorsTo && !bitset(*pflag, CHHDR_DEF) && !headeronly &&
d282 1
a282 1
	if (bitset(*pflag, CHHDR_CHECK))
d347 2
a348 1
			(void) rscheck(rs, fvalue, NULL, e, stripcom, TRUE, 4);
a351 36
#if _FFR_MILTER
	/* Call milter */
	if (bitset(*pflag, CHHDR_MILTER) &&
	    !bitset(EF_DISCARD, e->e_flags))
	{
		char state;
		char *response;

		response = milter_header(fname, fvalue, e, &state);
		switch (state)
		{
		  case SMFIR_REPLYCODE:
			*pflag &= ~CHHDR_MILTER;
			usrerr(response);
			break;

		  case SMFIR_REJECT:
			*pflag &= ~CHHDR_MILTER;
			usrerr("554 5.7.1 Message rejected");
			break;

		  case SMFIR_DISCARD:
			*pflag &= ~CHHDR_MILTER;
			e->e_flags |= EF_DISCARD;
			break;

		  case SMFIR_TEMPFAIL:
			*pflag &= ~CHHDR_MILTER;
			usrerr("451 4.7.1 Try again later");
			break;
		}
		if (response != NULL)
			free(response);
	}
#endif /* _FFR_MILTER */

d358 1
d362 1
a362 1
	if (!bitset(*pflag, CHHDR_DEF) && !headeronly &&
d375 1
a375 1
			return hi->hi_flags;
d382 1
a382 1
		    bitset(H_DEFAULT, h->h_flags) &&
d390 6
d416 2
d422 1
a422 1
	if (bitset(*pflag, CHHDR_DEF))
d428 1
a428 1
	if (!bitset(*pflag, CHHDR_DEF) && !headeronly &&
d446 1
d457 1
a457 1
addheader(field, value, hdrlist)
d460 1
d482 1
a482 1
	h->h_flags = H_DEFAULT;
d895 1
a895 1
		(void) snprintf(sbp, SPACELEFT(sbuf, sbp), ", mech=%.10s", p);
d960 1
a960 1
		if (!strcasecmp(p, Priorities[i].pri_name))
d1383 4
d1392 4
a1395 1
			if (fix_mime_header(h->h_value))
d1398 2
a1399 2
					  "Truncated MIME %s header due to field size (possible attack)",
					  h->h_field);
d1401 3
a1403 2
					dprintf("  truncated MIME %s header due to field size (possible attack)\n",
						h->h_field);
d1411 4
a1414 1
			if (strlen(h->h_value) > MaxMimeHeaderLength)
d1418 2
a1419 2
					  "Truncated long MIME %s header (possible attack)",
					  h->h_field);
d1421 3
a1423 2
					dprintf("  truncated long MIME %s header (possible attack)\n",
						h->h_field);
d1431 5
a1435 1
			if (shorten_rfc822_string(h->h_value, MaxMimeHeaderLength))
d1438 2
a1439 2
					  "Truncated long MIME %s header (possible attack)",
					  h->h_field);
d1441 3
a1443 2
					dprintf("  truncated long MIME %s header (possible attack)\n",
						h->h_field);
d1474 1
a1474 1
		     macvalue(h->h_macro & 0377, e) == NULL))
d1607 1
a1607 1
		if (SPACELEFT(obuf, obp) - 1 < l)
d1836 1
a1836 1
**		TRUE if the header was modified, FALSE otherwise
d1842 1
a1842 1
static bool
a1845 1
	bool modified = FALSE;
d1848 2
d1852 1
a1852 1
		return FALSE;
d1862 2
d1866 1
a1866 1
			modified = TRUE;
d1890 1
a1890 1
	return modified;
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
static char id[] = "@@(#)$Sendmail: headers.c,v 8.203.4.13 2001/05/03 17:24:06 gshapiro Exp $";
d20 1
a20 1
static size_t	fix_mime_header __P((char *));
d54 3
a56 1
**		pflag -- flags for chompheader() (from sendmail.h)
d73 1
a73 1
	int pflag;
a83 1
	bool dropfrom;
d104 1
a104 1
	if (!bitset(pflag, CHHDR_USER) && *p == '?')
d168 1
a168 1
				setbitn(bitidx(*p), mopts);
d207 1
a207 1
	if (bitset(pflag, CHHDR_DEF))
d252 1
a252 1
	if (!bitset(pflag, CHHDR_DEF) && !headeronly &&
d257 1
a257 1
	if (UseErrorsTo && !bitset(pflag, CHHDR_DEF) && !headeronly &&
d283 1
a283 1
	if (bitset(pflag, CHHDR_CHECK))
d312 1
a312 1
			for (sp = fvalue; *sp != '\0' && l < MAXNAME - 3; sp++)
d341 1
a341 1
						  fname, rs, l, MAXNAME - 1);
d345 1
a345 1
				sm_free(sp);
d348 1
a348 2
			(void) rscheck(rs, fvalue, NULL, e, stripcom, TRUE, 4,
				       NULL);
d352 36
a393 1
	dropfrom = FALSE;
d397 1
a397 1
	if (!bitset(pflag, CHHDR_DEF) && !headeronly &&
d410 1
a410 1
			dropfrom = TRUE;
d417 1
a417 1
		    !bitset(H_USER, h->h_flags) &&
a424 6
			if (dropfrom)
			{
				/* make this look like the user entered it */
				h->h_flags |= H_USER;
				return hi->hi_flags;
			}
a444 2
	if (bitset(pflag, CHHDR_USER) || bitset(pflag, CHHDR_QUEUE))
		h->h_flags |= H_USER;
d449 1
a449 1
	if (bitset(pflag, CHHDR_DEF))
d455 1
a455 1
	if (!bitset(pflag, CHHDR_DEF) && !headeronly &&
a472 1
**		flags -- flags to add to h_flags.
d483 1
a483 1
addheader(field, value, flags, hdrlist)
a485 1
	int flags;
d507 1
a507 1
	h->h_flags = flags;
d920 1
a920 1
		(void) snprintf(sbp, SPACELEFT(sbuf, sbp), ", mech=%.12s", p);
d985 1
a985 1
		if (strcasecmp(p, Priorities[i].pri_name) == 0)
a1407 4
		/* Skip empty headers */
		if (h->h_value == NULL)
			continue;

d1413 1
a1413 4
			size_t len;

			len = fix_mime_header(h->h_value);
			if (len > 0)
d1416 2
a1417 2
					  "Truncated MIME %s header due to field size (length = %ld) (possible attack)",
					  h->h_field, (unsigned long) len);
d1419 2
a1420 3
					dprintf("  truncated MIME %s header due to field size  (length = %ld) (possible attack)\n",
						h->h_field,
						(unsigned long) len);
d1428 1
a1428 4
			size_t len;

			len = strlen(h->h_value);
			if (len > (size_t) MaxMimeHeaderLength)
d1432 2
a1433 2
					  "Truncated long MIME %s header (length = %ld) (possible attack)",
					  h->h_field, (unsigned long) len);
d1435 2
a1436 3
					dprintf("  truncated long MIME %s header (length = %ld) (possible attack)\n",
						h->h_field,
						(unsigned long) len);
d1444 1
a1444 5
			size_t len;

			len = strlen(h->h_value);
			if (shorten_rfc822_string(h->h_value,
						  MaxMimeHeaderLength))
d1447 2
a1448 2
					  "Truncated long MIME %s header (length = %ld) (possible attack)",
					  h->h_field, (unsigned long) len);
d1450 2
a1451 3
					dprintf("  truncated long MIME %s header (length = %ld) (possible attack)\n",
						h->h_field,
						(unsigned long) len);
d1482 1
a1482 1
		     macvalue(bitidx(h->h_macro), e) == NULL))
d1615 1
a1615 1
		if (SPACELEFT(obuf, obp) - 1 < (size_t)l)
d1844 1
a1844 1
**		length of last offending field, 0 if all ok.
d1850 1
a1850 1
static size_t
d1854 1
a1856 2
	size_t len = 0;
	size_t retlen = 0;
d1859 1
a1859 1
		return 0;
a1868 2
		len = strlen(begin);

d1871 1
a1871 1
			retlen = len;
d1895 1
a1895 1
	return retlen;
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Sendmail: headers.c,v 8.202 2000/02/17 17:18:17 ca Exp $";
d348 1
a348 1
			(void) rscheck(rs, fvalue, NULL, e, stripcom, TRUE);
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d15 1
a15 1
static char id[] = "@@(#)$Id: headers.c,v 8.203.4.10 2000/10/13 17:54:30 gshapiro Exp $";
d20 1
a20 1
static size_t	fix_mime_header __P((char *));
d54 3
a56 1
**		pflag -- flags for chompheader() (from sendmail.h)
d73 1
a73 1
	int pflag;
a83 1
	bool dropfrom;
d104 1
a104 1
	if (!bitset(pflag, CHHDR_USER) && *p == '?')
d168 1
a168 1
				setbitn(bitidx(*p), mopts);
d207 1
a207 1
	if (bitset(pflag, CHHDR_DEF))
d252 1
a252 1
	if (!bitset(pflag, CHHDR_DEF) && !headeronly &&
d257 1
a257 1
	if (UseErrorsTo && !bitset(pflag, CHHDR_DEF) && !headeronly &&
d283 1
a283 1
	if (bitset(pflag, CHHDR_CHECK))
d348 1
a348 2
			(void) rscheck(rs, fvalue, NULL, e, stripcom, TRUE, 4,
				       NULL);
d352 36
a393 1
	dropfrom = FALSE;
d397 1
a397 1
	if (!bitset(pflag, CHHDR_DEF) && !headeronly &&
d410 1
a410 1
			dropfrom = TRUE;
d417 1
a417 1
		    !bitset(H_USER, h->h_flags) &&
a424 6
			if (dropfrom)
			{
				/* make this look like the user entered it */
				h->h_flags |= H_USER;
				return hi->hi_flags;
			}
a444 2
	if (bitset(pflag, CHHDR_USER) || bitset(pflag, CHHDR_QUEUE))
		h->h_flags |= H_USER;
d449 1
a449 1
	if (bitset(pflag, CHHDR_DEF))
d455 1
a455 1
	if (!bitset(pflag, CHHDR_DEF) && !headeronly &&
a472 1
**		flags -- flags to add to h_flags.
d483 1
a483 1
addheader(field, value, flags, hdrlist)
a485 1
	int flags;
d507 1
a507 1
	h->h_flags = flags;
d920 1
a920 1
		(void) snprintf(sbp, SPACELEFT(sbuf, sbp), ", mech=%.12s", p);
d985 1
a985 1
		if (strcasecmp(p, Priorities[i].pri_name) == 0)
a1407 4
		/* Skip empty headers */
		if (h->h_value == NULL)
			continue;

d1413 1
a1413 4
			size_t len;

			len = fix_mime_header(h->h_value);
			if (len > 0)
d1416 2
a1417 2
					  "Truncated MIME %s header due to field size (length = %ld) (possible attack)",
					  h->h_field, (unsigned long) len);
d1419 2
a1420 3
					dprintf("  truncated MIME %s header due to field size  (length = %ld) (possible attack)\n",
						h->h_field,
						(unsigned long) len);
d1428 1
a1428 4
			size_t len;

			len = strlen(h->h_value);
			if (len > (size_t) MaxMimeHeaderLength)
d1432 2
a1433 2
					  "Truncated long MIME %s header (length = %ld) (possible attack)",
					  h->h_field, (unsigned long) len);
d1435 2
a1436 3
					dprintf("  truncated long MIME %s header (length = %ld) (possible attack)\n",
						h->h_field,
						(unsigned long) len);
d1444 1
a1444 5
			size_t len;

			len = strlen(h->h_value);
			if (shorten_rfc822_string(h->h_value,
						  MaxMimeHeaderLength))
d1447 2
a1448 2
					  "Truncated long MIME %s header (length = %ld) (possible attack)",
					  h->h_field, (unsigned long) len);
d1450 2
a1451 3
					dprintf("  truncated long MIME %s header (length = %ld) (possible attack)\n",
						h->h_field,
						(unsigned long) len);
d1482 1
a1482 1
		     macvalue(bitidx(h->h_macro), e) == NULL))
d1615 1
a1615 1
		if (SPACELEFT(obuf, obp) - 1 < (size_t)l)
d1844 1
a1844 1
**		length of last offending field, 0 if all ok.
d1850 1
a1850 1
static size_t
d1854 1
a1856 2
	size_t len = 0;
	size_t retlen = 0;
d1859 1
a1859 1
		return 0;
a1868 2
		len = strlen(begin);

d1871 1
a1871 1
			retlen = len;
d1895 1
a1895 1
	return retlen;
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d14 4
a19 2
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.262 2001/09/04 22:43:03 ca Exp $")

d68 1
a68 1
unsigned long
d75 1
a75 1
	unsigned char mid = '\0';
d81 1
a81 1
	bool cond = false;
d86 1
a86 1
	bool nullheader = false;
d91 1
a91 1
		sm_dprintf("chompheader: ");
d93 1
a93 1
		sm_dprintf("\n");
d125 1
a125 1
			mid = (unsigned char) *p++;
d143 1
a143 1
			mid = (unsigned char) macid(p);
d155 1
d168 1
a168 1
				cond = true;
d199 1
a199 1
		nullheader = true;
a224 6
				if (LogLevel > 9 &&
				    s->s_header.hi_ruleset != NULL)
					sm_syslog(LOG_WARNING, NOQID,
						  "Warning: redefined ruleset for header=%s, old=%s, new=%s",
						  fname,
						  s->s_header.hi_ruleset, p);
d243 1
a243 1
			sm_dprintf("no header flags match\n");
d245 3
a247 4
			sm_dprintf("header match, flags=%lx, ruleset=%s\n",
				   hi->hi_flags,
				   hi->hi_ruleset == NULL ? "<NULL>"
							  : hi->hi_ruleset);
d284 1
a284 1
		bool stripcom = false;
d303 1
a303 1
			int l, k;
d305 2
d308 1
d310 2
a311 4
			qval[l++] = '"';

			/* - 3 to avoid problems with " at the end */
			for (k = 0; fvalue[k] != '\0' && l < MAXNAME - 3; k++)
d313 1
a313 1
				switch (fvalue[k])
a314 1
				  /* XXX other control chars? */
d320 1
a320 1
					qval[l++] = ' ';
d323 1
a323 1
					qval[l++] = '\\';
d326 1
a326 1
					qval[l++] = fvalue[k];
d330 6
a335 4
			qval[l++] = '"';
			qval[l] = '\0';
			k += strlen(fvalue + k);
			if (k >= MAXNAME)
d340 1
a340 1
						  fname, rs, k, MAXNAME - 1);
d342 7
a348 27
			macdefine(&e->e_macro, A_TEMP,
				macid("{currHeader}"), qval);
			macdefine(&e->e_macro, A_TEMP,
				macid("{hdr_name}"), fname);

			(void) sm_snprintf(qval, sizeof qval, "%d", k);
			macdefine(&e->e_macro, A_TEMP, macid("{hdrlen}"), qval);
#if _FFR_HDR_TYPE
			/*
			**  XXX: h isn't set yet
			**  If we really want to be precise then we have
			**  to lookup the header (see below).
			**  It's probably not worth the effort.
			*/

			if (bitset(H_FROM, h->h_flags))
				macdefine(&e->e_macro, A_PERM,
					macid("{addr_type}"), "h s");
			else if (bitset(H_RCPT, h->h_flags))
				macdefine(&e->e_macro, A_PERM,
					macid("{addr_type}"), "h r");
			else
#endif /* _FFR_HDR_TYPE */
				macdefine(&e->e_macro, A_PERM,
					macid("{addr_type}"), "h");
			(void) rscheck(rs, fvalue, NULL, e, stripcom, true, 3,
				       NULL, e->e_id);
d358 1
a358 1
	dropfrom = false;
d363 1
a363 1
	    !bitset(EF_QUEUERUN, e->e_flags) && sm_strcasecmp(fname, p) == 0)
d367 1
a367 1
			sm_dprintf("comparing header from (%s) against default (%s or %s)\n",
d375 1
a375 1
			dropfrom = true;
d381 1
a381 1
		if (sm_strcasecmp(fname, h->h_field) == 0 &&
d400 1
a400 1
				memmove((char *) mopts, (char *) h->h_mflags,
d408 3
a410 3
	h = (HDR *) sm_rpool_malloc_x(e->e_rpool, sizeof *h);
	h->h_field = sm_rpool_strdup_x(e->e_rpool, fname);
	h->h_value = sm_rpool_strdup_x(e->e_rpool, fvalue);
d447 1
a447 1
**		e -- envelope.
d457 1
a457 1
addheader(field, value, flags, e)
d461 1
a461 1
	ENVELOPE *e;
a465 1
	HDR **hdrlist = &e->e_header;
d473 1
a473 1
		if (sm_strcasecmp(field, h->h_field) == 0)
d478 1
a478 1
	h = (HDR *) sm_rpool_malloc_x(e->e_rpool, sizeof *h);
d480 1
a480 1
	h->h_value = sm_rpool_strdup_x(e->e_rpool, value);
d517 1
a517 1
		    sm_strcasecmp(h->h_field, field) == 0)
d538 2
a539 2
**		true if h is a header.
**		false otherwise.
d552 1
a552 1
		return false;
d558 1
a558 1
		return false;
a574 1
**		log -- call logsender()?
d582 1
d586 1
a586 1
eatheader(e, full, log)
a588 1
	bool log;
d593 1
d600 2
a601 2
	macdefine(&e->e_macro, A_PERM, 'f', e->e_sender);
	macdefine(&e->e_macro, A_PERM, 'g', e->e_sender);
d603 1
a603 1
		macdefine(&e->e_macro, A_PERM, 'u', e->e_origrcpt);
d605 1
a605 1
		macdefine(&e->e_macro, A_PERM, 'u', NULL);
d618 1
a618 2

			p = addquotes(p, e->e_rpool);
d620 1
a620 1
		macdefine(&e->e_macro, A_PERM, 'x', p);
d624 2
a625 2
		sm_dprintf("----- collected header -----\n");
	e->e_msgid = NULL;
d629 1
a629 1
			sm_dprintf("%s: ", h->h_field);
d633 1
a633 1
				sm_dprintf("<NULL>\n");
d643 1
a643 1
				sm_dprintf("(");
d645 1
a645 1
				sm_dprintf(") ");
d651 2
a652 3
					expand(crackaddr(buf), buf, sizeof buf,
					       e);
				h->h_value = sm_rpool_strdup_x(e->e_rpool, buf);
d656 1
d660 1
a660 1
			sm_dprintf("\n");
d670 1
a670 2
		    (!bitset(EF_RESENT, e->e_flags) ||
		     bitset(H_RESENT, h->h_flags)))
d695 1
a695 1
		if (sm_strcasecmp(h->h_field, p) == 0)
d697 3
a699 3
			e->e_msgid = h->h_value;
			while (isascii(*e->e_msgid) && isspace(*e->e_msgid))
				e->e_msgid++;
d703 1
a703 1
		sm_dprintf("----------------------------\n");
a710 1
	{
a711 3
		(void) sm_snprintf(buf, sizeof buf, "%d", e->e_hopcount);
		macdefine(&e->e_macro, A_TEMP, 'c', buf);
	}
d733 1
a733 1
		if (sm_strcasecmp(p, "urgent") == 0)
d735 1
a735 1
		else if (sm_strcasecmp(p, "normal") == 0)
d737 1
a737 1
		else if (sm_strcasecmp(p, "non-urgent") == 0)
d746 1
a746 1
		macdefine(&e->e_macro, A_PERM, 'a', p);
d750 1
a750 1
	     sm_strcasecmp(e->e_bodytype, "8BITMIME") == 0) ||
d788 1
a788 1
				sm_dprintf("eatheader: setsender(*%s == %s)\n",
d790 1
a790 1
			setsender(p, e, NULL, '\0', true);
d798 3
a800 5
	if (log && bitset(EF_LOGSENDER, e->e_flags) && LogLevel > 4)
	{
		logsender(e, e->e_msgid);
		e->e_flags &= ~EF_LOGSENDER;
	}
a826 1
	/* XXX do we still need this? sm_syslog() replaces control chars */
d851 1
a851 1
		(void) sm_snprintf(hbuf, sizeof hbuf, "%.80s", RealHostName);
d855 2
a856 3
			(void) sm_snprintf(p, SPACELEFT(hbuf, p),
					   " (%.100s)",
					   anynet_ntoa(&RealHostAddr));
d863 4
a866 4
	(void) sm_snprintf(sbp, SPACELEFT(sbuf, sbp),
		"from=%.200s, size=%ld, class=%d, nrcpts=%d",
		e->e_from.q_paddr == NULL ? "<NONE>" : e->e_from.q_paddr,
		e->e_msgsize, e->e_class, e->e_nrcpts);
d870 1
a870 2
		(void) sm_snprintf(sbp, SPACELEFT(sbuf, sbp),
				", msgid=%.100s", mbuf);
d875 2
a876 2
		(void) sm_snprintf(sbp, SPACELEFT(sbuf, sbp),
				", bodytype=%.20s", e->e_bodytype);
d882 14
a895 2
		(void) sm_snprintf(sbp, SPACELEFT(sbuf, sbp),
				", proto=%.20s", p);
d898 1
a898 1
	p = macvalue(macid("{daemon_name}"), e);
d901 1
a901 2
		(void) sm_snprintf(sbp, SPACELEFT(sbuf, sbp),
				", daemon=%.20s", p);
d904 4
a907 1
	sm_syslog(LOG_INFO, e->e_id, "%.850s, relay=%.100s", sbuf, name);
d914 1
a914 2
					    : shortenstring(e->e_from.q_paddr,
							    83));
d926 1
a926 2
		(void) sm_snprintf(sbp, SPACELEFT(sbuf, sbp),
				"bodytype=%.20s, ", e->e_bodytype);
d932 1
a932 2
		(void) sm_snprintf(sbp, SPACELEFT(sbuf, sbp),
				"proto=%.20s, ", p);
d960 1
a960 1
		if (sm_strcasecmp(p, Priorities[i].pri_name) == 0)
d1009 4
a1012 4
	bool putgmac = false;
	bool quoteit = false;
	bool gotangle = false;
	bool gotcolon = false;
d1020 1
a1020 1
		sm_dprintf("crackaddr(%s)\n", addr);
d1036 1
a1036 1
	qmode = realqmode = false;
d1056 1
a1056 1
				quoteit = true;
d1141 1
a1141 1
					quoteit = true;
d1151 1
a1151 1
			gotcolon = true;
d1192 1
a1192 1
			putgmac = quoteit = false;
d1215 1
a1215 1
				quoteit = true;
d1225 2
a1226 2
				quoteit = true;
			gotangle = true;
d1268 1
a1268 1
			putgmac = quoteit = false;
d1288 1
a1288 1
				quoteit = true;
d1304 1
a1304 1
			putgmac = true;
d1319 1
a1319 1
		sm_dprintf("crackaddr=>`");
d1321 1
a1321 1
		sm_dprintf("'\n");
d1342 7
d1357 1
a1357 1
	char buf[SM_MAX(MAXLINE,BUFSIZ)];
d1361 1
a1361 1
		sm_dprintf("--- putheader, mailer = %s ---\n",
a1375 1
		char *q;
d1379 1
a1379 1
			sm_dprintf("  %s: ", h->h_field);
d1390 1
a1390 1
				macid("{checkMIMEFieldHeaders}")))
d1401 3
a1403 3
					sm_dprintf("  truncated MIME %s header due to field size  (length = %ld) (possible attack)\n",
						   h->h_field,
						   (unsigned long) len);
d1409 1
a1409 1
				macid("{checkMIMETextHeaders}")))
d1421 3
a1423 3
					sm_dprintf("  truncated long MIME %s header (length = %ld) (possible attack)\n",
						   h->h_field,
						   (unsigned long) len);
d1429 1
a1429 1
				macid("{checkMIMEHeaders}")))
d1441 3
a1443 3
					sm_dprintf("  truncated long MIME %s header (length = %ld) (possible attack)\n",
						   h->h_field,
						   (unsigned long) len);
a1452 1

d1459 1
a1459 1
				sm_dprintf(" (skipped (content-transfer-encoding))\n");
d1466 1
a1466 1
				sm_dprintf("\n");
d1474 1
a1474 2
		     (q = macvalue(bitidx(h->h_macro), e)) == NULL ||
		     *q == '\0'))
d1477 1
a1477 1
				sm_dprintf(" (skipped)\n");
d1485 1
a1485 1
				sm_dprintf(" (skipped (resent))\n");
d1494 1
a1494 1
				sm_dprintf(" (skipped (receipt))\n");
d1507 1
a1507 1
					sm_dprintf(" (skipped -- null value)\n");
d1518 1
a1518 1
					sm_dprintf(" (skipped -- bcc)\n");
d1523 2
a1524 2
				(void) sm_strlcpyn(obuf, sizeof obuf, 2,
						   h->h_field, ":");
d1531 1
a1531 1
			sm_dprintf("\n");
d1539 1
a1539 1
				oldstyle = false;
d1564 3
a1566 3
			(void) sm_snprintf(obuf, sizeof obuf,
					"Content-Type: text/plain; charset=%s",
					defcharset(e));
d1600 1
a1600 1
	(void) sm_snprintf(obuf, sizeof obuf, "%.200s: ", h->h_field);
d1607 1
a1607 1
		if (SPACELEFT(obuf, obp) - 1 < (size_t) l)
d1610 1
a1610 1
		(void) sm_snprintf(obp, SPACELEFT(obuf, obp), "%.*s", l, v);
d1617 2
a1618 2
	(void) sm_snprintf(obp, SPACELEFT(obuf, obp), "%.*s",
			   (int) (SPACELEFT(obuf, obp) - 1), v);
d1627 1
a1627 1
**		oldstyle -- true if this is an old style header.
d1649 1
a1649 1
	bool firstone = true;
d1659 1
a1659 1
		sm_dprintf("commaize(%s: %s)\n", h->h_field, p);
d1665 1
a1665 2
	(void) sm_snprintf(obp, SPACELEFT(obuf, obp), "%.200s: ",
			h->h_field);
d1716 1
a1716 1
			++p;
d1741 1
a1741 1
			q = udbsender(name, e->e_rpool);
d1753 1
a1753 1
		name = denlstring(name, false, true);
d1760 1
a1760 1
		DataProgress = true;
d1768 1
a1768 1
			(void) sm_strlcpy(obp, ",\n", SPACELEFT(obuf, obp));
d1771 1
a1771 1
			(void) sm_strlcpy(obp, "        ", sizeof obp);
d1778 1
a1778 1
			(void) sm_strlcpy(obp, ", ", SPACELEFT(obuf, obp));
d1784 1
a1784 1
		firstone = false;
a1796 1
**		rpool -- resource pool, or NULL
d1806 1
a1806 1
copyheader(header, rpool)
a1807 1
	SM_RPOOL_T *rpool;
d1815 1
a1815 1
		newhdr = (HDR *) sm_rpool_malloc_x(rpool, sizeof *newhdr);
@


