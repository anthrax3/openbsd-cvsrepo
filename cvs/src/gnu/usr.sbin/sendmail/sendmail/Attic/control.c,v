head	1.16;
access;
symbols
	OPENBSD_5_6:1.15.0.6
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.13.0.26
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.24
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.22
	OPENBSD_5_0:1.13.0.20
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.18
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.16
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.12
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.14
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.10
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.8
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.6
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.4
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.12.0.8
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.15;
commitid	M7i5giHIoz3DMlTU;

1.15
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.16.00.21.30;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.24.03.59.27;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.17.17.31.40;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.01.19.59.22;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.18.00.49.28;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.14.03.21.40;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.29.01.31.14;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.28.02.43.53;	author millert;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.01.15.21.09.07;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.02.19.05.44;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.44;	author millert;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.12;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.50;	author millert;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	2001.05.31.00.31.32;	author miod;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.31.01.47.56;	author jason;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2004, 2006 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>

SM_RCSID("@@(#)$Sendmail: control.c,v 8.130 2013/11/22 20:51:55 ca Exp $")

#include <sm/fdset.h>

/* values for cmd_code */
#define CMDERROR	0	/* bad command */
#define CMDRESTART	1	/* restart daemon */
#define CMDSHUTDOWN	2	/* end daemon */
#define CMDHELP		3	/* help */
#define CMDSTATUS	4	/* daemon status */
#define CMDMEMDUMP	5	/* dump memory, to find memory leaks */
#define CMDMSTAT	6	/* daemon status, more info, tagged data */

struct cmd
{
	char	*cmd_name;	/* command name */
	int	cmd_code;	/* internal code, see below */
};

static struct cmd	CmdTab[] =
{
	{ "help",	CMDHELP		},
	{ "restart",	CMDRESTART	},
	{ "shutdown",	CMDSHUTDOWN	},
	{ "status",	CMDSTATUS	},
	{ "memdump",	CMDMEMDUMP	},
	{ "mstat",	CMDMSTAT	},
	{ NULL,		CMDERROR	}
};



static void	controltimeout __P((int));
int ControlSocket = -1;

/*
**  OPENCONTROLSOCKET -- create/open the daemon control named socket
**
**	Creates and opens a named socket for external control over
**	the sendmail daemon.
**
**	Parameters:
**		none.
**
**	Returns:
**		0 if successful, -1 otherwise
*/

int
opencontrolsocket()
{
# if NETUNIX
	int save_errno;
	int rval;
	long sff = SFF_SAFEDIRPATH|SFF_OPENASROOT|SFF_NOLINK|SFF_CREAT|SFF_MUSTOWN;
	struct sockaddr_un controladdr;

	if (ControlSocketName == NULL || *ControlSocketName == '\0')
		return 0;

	if (strlen(ControlSocketName) >= sizeof(controladdr.sun_path))
	{
		errno = ENAMETOOLONG;
		return -1;
	}

	rval = safefile(ControlSocketName, RunAsUid, RunAsGid, RunAsUserName,
			sff, S_IRUSR|S_IWUSR, NULL);

	/* if not safe, don't create */
	if (rval != 0)
	{
		errno = rval;
		return -1;
	}

	ControlSocket = socket(AF_UNIX, SOCK_STREAM, 0);
	if (ControlSocket < 0)
		return -1;
	if (SM_FD_SETSIZE > 0 && ControlSocket >= SM_FD_SETSIZE)
	{
		clrcontrol();
		errno = EINVAL;
		return -1;
	}

	(void) unlink(ControlSocketName);
	memset(&controladdr, '\0', sizeof(controladdr));
	controladdr.sun_family = AF_UNIX;
	(void) sm_strlcpy(controladdr.sun_path, ControlSocketName,
			  sizeof(controladdr.sun_path));

	if (bind(ControlSocket, (struct sockaddr *) &controladdr,
		 sizeof(controladdr)) < 0)
	{
		save_errno = errno;
		clrcontrol();
		errno = save_errno;
		return -1;
	}

	if (geteuid() == 0)
	{
		uid_t u = 0;

		if (RunAsUid != 0)
			u = RunAsUid;
		else if (TrustedUid != 0)
			u = TrustedUid;

		if (u != 0 &&
		    chown(ControlSocketName, u, -1) < 0)
		{
			save_errno = errno;
			sm_syslog(LOG_ALERT, NOQID,
				  "ownership change on %s to uid %d failed: %s",
				  ControlSocketName, (int) u,
				  sm_errstring(save_errno));
			message("050 ownership change on %s to uid %d failed: %s",
				ControlSocketName, (int) u,
				sm_errstring(save_errno));
			closecontrolsocket(true);
			errno = save_errno;
			return -1;
		}
	}

	if (chmod(ControlSocketName, S_IRUSR|S_IWUSR) < 0)
	{
		save_errno = errno;
		closecontrolsocket(true);
		errno = save_errno;
		return -1;
	}

	if (listen(ControlSocket, 8) < 0)
	{
		save_errno = errno;
		closecontrolsocket(true);
		errno = save_errno;
		return -1;
	}
# endif /* NETUNIX */
	return 0;
}
/*
**  CLOSECONTROLSOCKET -- close the daemon control named socket
**
**	Close a named socket.
**
**	Parameters:
**		fullclose -- if set, close the socket and remove it;
**			     otherwise, just remove it
**
**	Returns:
**		none.
*/

void
closecontrolsocket(fullclose)
	bool fullclose;
{
# if NETUNIX
	long sff = SFF_SAFEDIRPATH|SFF_OPENASROOT|SFF_NOLINK|SFF_CREAT|SFF_MUSTOWN;

	if (ControlSocket >= 0)
	{
		int rval;

		if (fullclose)
		{
			(void) close(ControlSocket);
			ControlSocket = -1;
		}

		rval = safefile(ControlSocketName, RunAsUid, RunAsGid,
				RunAsUserName, sff, S_IRUSR|S_IWUSR, NULL);

		/* if not safe, don't unlink */
		if (rval != 0)
			return;

		if (unlink(ControlSocketName) < 0)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "Could not remove control socket: %s",
				  sm_errstring(errno));
			return;
		}
	}
# endif /* NETUNIX */
	return;
}
/*
**  CLRCONTROL -- reset the control connection
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		releases any resources used by the control interface.
*/

void
clrcontrol()
{
# if NETUNIX
	if (ControlSocket >= 0)
		(void) close(ControlSocket);
	ControlSocket = -1;
# endif /* NETUNIX */
}
/*
**  CONTROL_COMMAND -- read and process command from named socket
**
**	Read and process the command from the opened socket.
**	Exits when done since it is running in a forked child.
**
**	Parameters:
**		sock -- the opened socket from getrequests()
**		e -- the current envelope
**
**	Returns:
**		none.
*/

static jmp_buf	CtxControlTimeout;

/* ARGSUSED0 */
static void
controltimeout(timeout)
	int timeout;
{
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
	longjmp(CtxControlTimeout, 1);
}

void
control_command(sock, e)
	int sock;
	ENVELOPE *e;
{
	volatile int exitstat = EX_OK;
	SM_FILE_T *s = NULL;
	SM_EVENT *ev = NULL;
	SM_FILE_T *traffic;
	SM_FILE_T *oldout;
	char *cmd;
	char *p;
	struct cmd *c;
	char cmdbuf[MAXLINE];
	char inp[MAXLINE];

	sm_setproctitle(false, e, "control cmd read");

	if (TimeOuts.to_control > 0)
	{
		/* handle possible input timeout */
		if (setjmp(CtxControlTimeout) != 0)
		{
			if (LogLevel > 2)
				sm_syslog(LOG_NOTICE, e->e_id,
					  "timeout waiting for input during control command");
			exit(EX_IOERR);
		}
		ev = sm_setevent(TimeOuts.to_control, controltimeout,
				 TimeOuts.to_control);
	}

	s = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT, (void *) &sock,
		       SM_IO_RDWR, NULL);
	if (s == NULL)
	{
		int save_errno = errno;

		(void) close(sock);
		errno = save_errno;
		exit(EX_IOERR);
	}
	(void) sm_io_setvbuf(s, SM_TIME_DEFAULT, NULL,
			     SM_IO_NBF, SM_IO_BUFSIZ);

	if (sm_io_fgets(s, SM_TIME_DEFAULT, inp, sizeof(inp)) < 0)
	{
		(void) sm_io_close(s, SM_TIME_DEFAULT);
		exit(EX_IOERR);
	}
	(void) sm_io_flush(s, SM_TIME_DEFAULT);

	/* clean up end of line */
	fixcrlf(inp, true);

	sm_setproctitle(false, e, "control: %s", inp);

	/* break off command */
	for (p = inp; isascii(*p) && isspace(*p); p++)
		continue;
	cmd = cmdbuf;
	while (*p != '\0' &&
	       !(isascii(*p) && isspace(*p)) &&
	       cmd < &cmdbuf[sizeof(cmdbuf) - 2])
		*cmd++ = *p++;
	*cmd = '\0';

	/* throw away leading whitespace */
	while (isascii(*p) && isspace(*p))
		p++;

	/* decode command */
	for (c = CmdTab; c->cmd_name != NULL; c++)
	{
		if (sm_strcasecmp(c->cmd_name, cmdbuf) == 0)
			break;
	}

	switch (c->cmd_code)
	{
	  case CMDHELP:		/* get help */
		traffic = TrafficLogFile;
		TrafficLogFile = NULL;
		oldout = OutChannel;
		OutChannel = s;
		help("control", e);
		TrafficLogFile = traffic;
		OutChannel = oldout;
		break;

	  case CMDRESTART:	/* restart the daemon */
		(void) sm_io_fprintf(s, SM_TIME_DEFAULT, "OK\r\n");
		exitstat = EX_RESTART;
		break;

	  case CMDSHUTDOWN:	/* kill the daemon */
		(void) sm_io_fprintf(s, SM_TIME_DEFAULT, "OK\r\n");
		exitstat = EX_SHUTDOWN;
		break;

	  case CMDSTATUS:	/* daemon status */
		proc_list_probe();
		{
			int qgrp;
			long bsize;
			long free;

			/* XXX need to deal with different partitions */
			qgrp = e->e_qgrp;
			if (!ISVALIDQGRP(qgrp))
				qgrp = 0;
			free = freediskspace(Queue[qgrp]->qg_qdir, &bsize);

			/*
			**  Prevent overflow and don't lose
			**  precision (if bsize == 512)
			*/

			if (free > 0)
				free = (long)((double) free *
					      ((double) bsize / 1024));

			(void) sm_io_fprintf(s, SM_TIME_DEFAULT,
					     "%d/%d/%ld/%d\r\n",
					     CurChildren, MaxChildren,
					     free, getla());
		}
		proc_list_display(s, "");
		break;

	  case CMDMSTAT:	/* daemon status, extended, tagged format */
		proc_list_probe();
		(void) sm_io_fprintf(s, SM_TIME_DEFAULT,
				     "C:%d\r\nM:%d\r\nL:%d\r\n",
				     CurChildren, MaxChildren,
				     getla());
		printnqe(s, "Q:");
		disk_status(s, "D:");
		proc_list_display(s, "P:");
		break;

	  case CMDMEMDUMP:	/* daemon memory dump, to find memory leaks */
# if SM_HEAP_CHECK
		/* dump the heap, if we are checking for memory leaks */
		if (sm_debug_active(&SmHeapCheck, 2))
		{
			sm_heap_report(s, sm_debug_level(&SmHeapCheck) - 1);
		}
		else
		{
			(void) sm_io_fprintf(s, SM_TIME_DEFAULT,
					     "Memory dump unavailable.\r\n");
			(void) sm_io_fprintf(s, SM_TIME_DEFAULT,
					     "To fix, run sendmail with -dsm_check_heap.4\r\n");
		}
# else /* SM_HEAP_CHECK */
		(void) sm_io_fprintf(s, SM_TIME_DEFAULT,
				     "Memory dump unavailable.\r\n");
		(void) sm_io_fprintf(s, SM_TIME_DEFAULT,
				     "To fix, rebuild with -DSM_HEAP_CHECK\r\n");
# endif /* SM_HEAP_CHECK */
		break;

	  case CMDERROR:	/* unknown command */
		(void) sm_io_fprintf(s, SM_TIME_DEFAULT,
				     "Bad command (%s)\r\n", cmdbuf);
		break;
	}
	(void) sm_io_close(s, SM_TIME_DEFAULT);
	if (ev != NULL)
		sm_clrevent(ev);
	exit(exitstat);
}
@


1.15
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.14
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004, 2006 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: control.c,v 8.129 2013/03/12 15:24:52 ca Exp $")
@


1.13
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: control.c,v 8.128 2006/08/15 23:24:56 ca Exp $")
d304 1
a304 1
	if (sm_io_fgets(s, SM_TIME_DEFAULT, inp, sizeof(inp)) == NULL)
@


1.12
log
@Update to sendmail-8.13.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: control.c,v 8.126 2004/08/04 20:54:00 ca Exp $")
d24 1
a24 3
#if _FFR_CONTROL_MSTAT
# define CMDMSTAT	6	/* daemon status, more info, tagged data */
#endif /* _FFR_CONTROL_MSTAT */
a38 1
#if _FFR_CONTROL_MSTAT
a39 1
#endif /* _FFR_CONTROL_MSTAT */
d73 1
a73 1
	if (strlen(ControlSocketName) >= sizeof controladdr.sun_path)
d100 1
a100 1
	memset(&controladdr, '\0', sizeof controladdr);
d103 1
a103 1
			  sizeof controladdr.sun_path);
d106 1
a106 1
		 sizeof controladdr) < 0)
d304 1
a304 1
	if (sm_io_fgets(s, SM_TIME_DEFAULT, inp, sizeof inp) == NULL)
d322 1
a322 1
	       cmd < &cmdbuf[sizeof cmdbuf - 2])
a388 1
# if _FFR_CONTROL_MSTAT
a398 1
# endif /* _FFR_CONTROL_MSTAT */
@


1.11
log
@Update to sendmail.8.13.0
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: control.c,v 8.125 2003/06/24 17:46:06 ca Exp $")
d49 1
d251 1
a251 1
	time_t timeout;
@


1.10
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: control.c,v 8.118.4.8 2003/06/24 17:45:27 ca Exp $")
@


1.9
log
@update to sendmail 8.12.7
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2002 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: control.c,v 8.118.4.3 2002/11/14 00:15:56 ca Exp $")
@


1.8
log
@update to sendmail 8.12.3
@
text
@d13 3
a15 1
SM_RCSID("@@(#)$Sendmail: control.c,v 8.118 2002/03/19 00:23:27 gshapiro Exp $")
d95 6
@


1.7
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: control.c,v 8.116 2001/12/13 21:51:38 gshapiro Exp $")
@


1.6
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: control.c,v 8.115 2001/09/21 22:20:40 ca Exp $")
d372 3
a374 1
			free = (long)((double) free * ((double) bsize / 1024));
@


1.5
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: control.c,v 8.110 2001/08/27 16:59:13 ca Exp $")
d49 1
a49 1
/*
d153 1
a153 1
/*
d201 1
a201 1
/*
d223 1
a223 1
/*
d286 2
a287 2
	s = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT, (void *) sock, SM_IO_RDWR,
		       NULL);
@


1.4
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d11 1
a11 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: control.c,v 8.44.14.20 2001/05/03 17:24:03 gshapiro Exp $";
#endif /* ! lint */
d13 1
a13 1
#include <sendmail.h>
d16 9
a24 5
# define CMDERROR	0	/* bad command */
# define CMDRESTART	1	/* restart daemon */
# define CMDSHUTDOWN	2	/* end daemon */
# define CMDHELP	3	/* help */
# define CMDSTATUS	4	/* daemon status */
d38 4
d46 1
d65 1
a65 1
#if NETUNIX
d71 1
a71 1
	if (ControlSocketName == NULL)
d97 2
a98 2
	(void) strlcpy(controladdr.sun_path, ControlSocketName,
		       sizeof controladdr.sun_path);
d125 1
a125 1
				  errstring(save_errno));
d128 2
a129 2
				errstring(save_errno));
			closecontrolsocket(TRUE);
d138 1
a138 1
		closecontrolsocket(TRUE);
d146 1
a146 1
		closecontrolsocket(TRUE);
d150 1
a150 1
#endif /* NETUNIX */
d170 1
a170 1
#if NETUNIX
d194 1
a194 1
				  errstring(errno));
d198 1
a198 1
#endif /* NETUNIX */
d217 1
a217 1
#if NETUNIX
d221 1
a221 1
#endif /* NETUNIX */
a222 3

#ifndef NOT_SENDMAIL

d239 1
d260 4
a263 4
	FILE *s = NULL;
	EVENT *ev = NULL;
	FILE *traffic;
	FILE *oldout;
d270 1
a270 1
	sm_setproctitle(FALSE, e, "control cmd read");
d282 2
a283 2
		ev = setevent(TimeOuts.to_control, controltimeout,
			      TimeOuts.to_control);
d286 2
a287 1
	s = fdopen(sock, "r+");
d296 2
a297 1
	setbuf(s, NULL);
d299 1
a299 1
	if (fgets(inp, sizeof inp, s) == NULL)
d301 1
a301 1
		(void) fclose(s);
d304 1
a304 1
	(void) fflush(s);
d307 1
a307 1
	fixcrlf(inp, TRUE);
d309 1
a309 1
	sm_setproctitle(FALSE, e, "control: %s", inp);
d328 1
a328 1
		if (strcasecmp(c->cmd_name, cmdbuf) == 0)
d345 1
a345 1
		fprintf(s, "OK\r\n");
d350 1
a350 1
		fprintf(s, "OK\r\n");
d357 1
d361 5
a365 1
			free = freediskspace(QueueDir, &bsize);
d372 1
a372 1
			free = (long)((double)free * ((double)bsize / 1024));
d374 4
a377 3
			fprintf(s, "%d/%d/%ld/%d\r\n",
				CurChildren, MaxChildren,
				free, sm_getla(NULL));
d379 36
a414 1
		proc_list_display(s);
d418 2
a419 1
		fprintf(s, "Bad command (%s)\r\n", cmdbuf);
d422 1
a422 1
	(void) fclose(s);
d424 1
a424 1
		clrevent(ev);
a426 2
#endif /* ! NOT_SENDMAIL */

@


1.3
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: control.c,v 8.44.14.15 2001/01/22 19:00:22 gshapiro Exp $";
d17 22
a232 22
struct cmd
{
	char	*cmd_name;	/* command name */
	int	cmd_code;	/* internal code, see below */
};

/* values for cmd_code */
# define CMDERROR	0	/* bad command */
# define CMDRESTART	1	/* restart daemon */
# define CMDSHUTDOWN	2	/* end daemon */
# define CMDHELP	3	/* help */
# define CMDSTATUS	4	/* daemon status */

static struct cmd	CmdTab[] =
{
	{ "help",	CMDHELP		},
	{ "restart",	CMDRESTART	},
	{ "shutdown",	CMDSHUTDOWN	},
	{ "status",	CMDSTATUS	},
	{ NULL,		CMDERROR	}
};

d239 7
@


1.3.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d12 1
a12 1
static char id[] = "@@(#)$Sendmail: control.c,v 8.44.14.20 2001/05/03 17:24:03 gshapiro Exp $";
a16 22
/* values for cmd_code */
# define CMDERROR	0	/* bad command */
# define CMDRESTART	1	/* restart daemon */
# define CMDSHUTDOWN	2	/* end daemon */
# define CMDHELP	3	/* help */
# define CMDSTATUS	4	/* daemon status */

struct cmd
{
	char	*cmd_name;	/* command name */
	int	cmd_code;	/* internal code, see below */
};

static struct cmd	CmdTab[] =
{
	{ "help",	CMDHELP		},
	{ "restart",	CMDRESTART	},
	{ "shutdown",	CMDSHUTDOWN	},
	{ "status",	CMDSTATUS	},
	{ NULL,		CMDERROR	}
};

d211 22
a238 7
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
@


1.2
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d12 1
a12 1
static char id[] = "@@(#)$Sendmail: control.c,v 8.44.14.13 2000/12/28 21:25:52 gshapiro Exp $";
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1998, 1999 Sendmail, Inc. and its suppliers.
d12 1
a12 1
static char id[] = "@@(#)$Sendmail: control.c,v 8.44 1999/11/29 22:03:49 ca Exp $";
d17 1
d80 1
a80 1
	if (geteuid() == 0 && TrustedUid != 0)
d82 9
a90 1
		if (chown(ControlSocketName, TrustedUid, -1) < 0)
d94 6
a99 4
				  "ownership change on %s failed: %s",
				  ControlSocketName, errstring(save_errno));
			message("050 ownership change on %s failed: %s",
				ControlSocketName, errstring(save_errno));
d154 2
a155 2
		rval = safefile(ControlSocketName, RunAsUid, RunAsGid, RunAsUserName,
				sff, S_IRUSR|S_IWUSR, NULL);
d314 1
a314 1
		if (!strcasecmp(c->cmd_name, cmdbuf))
d342 17
a358 2
		fprintf(s, "%d/%d/%ld/%d\r\n", CurChildren, MaxChildren,
			freediskspace(QueueDir, NULL), sm_getla(NULL));
d372 1
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.1.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d12 1
a12 1
static char id[] = "@@(#)$Sendmail: control.c,v 8.44.14.20 2001/05/03 17:24:03 gshapiro Exp $";
a16 23
/* values for cmd_code */
# define CMDERROR	0	/* bad command */
# define CMDRESTART	1	/* restart daemon */
# define CMDSHUTDOWN	2	/* end daemon */
# define CMDHELP	3	/* help */
# define CMDSTATUS	4	/* daemon status */

struct cmd
{
	char	*cmd_name;	/* command name */
	int	cmd_code;	/* internal code, see below */
};

static struct cmd	CmdTab[] =
{
	{ "help",	CMDHELP		},
	{ "restart",	CMDRESTART	},
	{ "shutdown",	CMDSHUTDOWN	},
	{ "status",	CMDSTATUS	},
	{ NULL,		CMDERROR	}
};


d79 1
a79 1
	if (geteuid() == 0)
d81 1
a81 9
		uid_t u = 0;

		if (RunAsUid != 0)
			u = RunAsUid;
		else if (TrustedUid != 0)
			u = TrustedUid;

		if (u != 0 &&
		    chown(ControlSocketName, u, -1) < 0)
d85 4
a88 6
				  "ownership change on %s to uid %d failed: %s",
				  ControlSocketName, (int) u,
				  errstring(save_errno));
			message("050 ownership change on %s to uid %d failed: %s",
				ControlSocketName, (int) u,
				errstring(save_errno));
d143 2
a144 2
		rval = safefile(ControlSocketName, RunAsUid, RunAsGid,
				RunAsUserName, sff, S_IRUSR|S_IWUSR, NULL);
d200 22
a227 7
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
d303 1
a303 1
		if (strcasecmp(c->cmd_name, cmdbuf) == 0)
d331 2
a332 17
		{
			long bsize;
			long free;

			free = freediskspace(QueueDir, &bsize);

			/*
			**  Prevent overflow and don't lose
			**  precision (if bsize == 512)
			*/

			free = (long)((double)free * ((double)bsize / 1024));

			fprintf(s, "%d/%d/%ld/%d\r\n",
				CurChildren, MaxChildren,
				free, sm_getla(NULL));
		}
a345 1

@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d12 1
a12 1
static char id[] = "@@(#)$Id: control.c,v 8.44.14.13 2000/12/28 21:25:52 gshapiro Exp $";
a16 1

d79 1
a79 1
	if (geteuid() == 0)
d81 1
a81 9
		uid_t u = 0;

		if (RunAsUid != 0)
			u = RunAsUid;
		else if (TrustedUid != 0)
			u = TrustedUid;

		if (u != 0 &&
		    chown(ControlSocketName, u, -1) < 0)
d85 4
a88 6
				  "ownership change on %s to uid %d failed: %s",
				  ControlSocketName, (int) u,
				  errstring(save_errno));
			message("050 ownership change on %s to uid %d failed: %s",
				ControlSocketName, (int) u,
				errstring(save_errno));
d143 2
a144 2
		rval = safefile(ControlSocketName, RunAsUid, RunAsGid,
				RunAsUserName, sff, S_IRUSR|S_IWUSR, NULL);
d303 1
a303 1
		if (strcasecmp(c->cmd_name, cmdbuf) == 0)
d331 2
a332 17
		{
			long bsize;
			long free;

			free = freediskspace(QueueDir, &bsize);

			/*
			**  Prevent overflow and don't lose
			**  precision (if bsize == 512)
			*/

			free = (long)((double)free * ((double)bsize / 1024));

			fprintf(s, "%d/%d/%ld/%d\r\n",
				CurChildren, MaxChildren,
				free, sm_getla(NULL));
		}
a345 1

@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d11 4
a16 33
SM_RCSID("@@(#)$Sendmail: control.c,v 8.110 2001/08/27 16:59:13 ca Exp $")

/* values for cmd_code */
#define CMDERROR	0	/* bad command */
#define CMDRESTART	1	/* restart daemon */
#define CMDSHUTDOWN	2	/* end daemon */
#define CMDHELP		3	/* help */
#define CMDSTATUS	4	/* daemon status */
#define CMDMEMDUMP	5	/* dump memory, to find memory leaks */
#if _FFR_CONTROL_MSTAT
# define CMDMSTAT	6	/* daemon status, more info, tagged data */
#endif /* _FFR_CONTROL_MSTAT */

struct cmd
{
	char	*cmd_name;	/* command name */
	int	cmd_code;	/* internal code, see below */
};

static struct cmd	CmdTab[] =
{
	{ "help",	CMDHELP		},
	{ "restart",	CMDRESTART	},
	{ "shutdown",	CMDSHUTDOWN	},
	{ "status",	CMDSTATUS	},
	{ "memdump",	CMDMEMDUMP	},
#if _FFR_CONTROL_MSTAT
	{ "mstat",	CMDMSTAT	},
#endif /* _FFR_CONTROL_MSTAT */
	{ NULL,		CMDERROR	}
};


d36 1
a36 1
# if NETUNIX
d42 1
a42 1
	if (ControlSocketName == NULL || *ControlSocketName == '\0')
d68 2
a69 2
	(void) sm_strlcpy(controladdr.sun_path, ControlSocketName,
			  sizeof controladdr.sun_path);
d96 1
a96 1
				  sm_errstring(save_errno));
d99 2
a100 2
				sm_errstring(save_errno));
			closecontrolsocket(true);
d109 1
a109 1
		closecontrolsocket(true);
d117 1
a117 1
		closecontrolsocket(true);
d121 1
a121 1
# endif /* NETUNIX */
d141 1
a141 1
# if NETUNIX
d165 1
a165 1
				  sm_errstring(errno));
d169 1
a169 1
# endif /* NETUNIX */
d188 1
a188 1
# if NETUNIX
d192 1
a192 1
# endif /* NETUNIX */
d194 3
d211 22
a234 1
/* ARGSUSED0 */
a238 7
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
d248 4
a251 4
	SM_FILE_T *s = NULL;
	SM_EVENT *ev = NULL;
	SM_FILE_T *traffic;
	SM_FILE_T *oldout;
d258 1
a258 1
	sm_setproctitle(false, e, "control cmd read");
d270 2
a271 2
		ev = sm_setevent(TimeOuts.to_control, controltimeout,
				 TimeOuts.to_control);
d274 1
a274 2
	s = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT, (void *) sock, SM_IO_RDWR,
		       NULL);
d283 1
a283 2
	(void) sm_io_setvbuf(s, SM_TIME_DEFAULT, NULL,
			     SM_IO_NBF, SM_IO_BUFSIZ);
d285 1
a285 1
	if (sm_io_fgets(s, SM_TIME_DEFAULT, inp, sizeof inp) == NULL)
d287 1
a287 1
		(void) sm_io_close(s, SM_TIME_DEFAULT);
d290 1
a290 1
	(void) sm_io_flush(s, SM_TIME_DEFAULT);
d293 1
a293 1
	fixcrlf(inp, true);
d295 1
a295 1
	sm_setproctitle(false, e, "control: %s", inp);
d314 1
a314 1
		if (sm_strcasecmp(c->cmd_name, cmdbuf) == 0)
d331 1
a331 1
		(void) sm_io_fprintf(s, SM_TIME_DEFAULT, "OK\r\n");
d336 1
a336 1
		(void) sm_io_fprintf(s, SM_TIME_DEFAULT, "OK\r\n");
a342 1
			int qgrp;
d346 1
a346 5
			/* XXX need to deal with different partitions */
			qgrp = e->e_qgrp;
			if (!ISVALIDQGRP(qgrp))
				qgrp = 0;
			free = freediskspace(Queue[qgrp]->qg_qdir, &bsize);
d353 1
a353 22
			free = (long)((double) free * ((double) bsize / 1024));

			(void) sm_io_fprintf(s, SM_TIME_DEFAULT,
					     "%d/%d/%ld/%d\r\n",
					     CurChildren, MaxChildren,
					     free, getla());
		}
		proc_list_display(s, "");
		break;

# if _FFR_CONTROL_MSTAT
	  case CMDMSTAT:	/* daemon status, extended, tagged format */
		proc_list_probe();
		(void) sm_io_fprintf(s, SM_TIME_DEFAULT,
				     "C:%d\r\nM:%d\r\nL:%d\r\n",
				     CurChildren, MaxChildren,
				     getla());
		printnqe(s, "Q:");
		disk_status(s, "D:");
		proc_list_display(s, "P:");
		break;
# endif /* _FFR_CONTROL_MSTAT */
d355 3
a357 6
	  case CMDMEMDUMP:	/* daemon memory dump, to find memory leaks */
# if SM_HEAP_CHECK
		/* dump the heap, if we are checking for memory leaks */
		if (sm_debug_active(&SmHeapCheck, 2))
		{
			sm_heap_report(s, sm_debug_level(&SmHeapCheck) - 1);
d359 1
a359 13
		else
		{
			(void) sm_io_fprintf(s, SM_TIME_DEFAULT,
					     "Memory dump unavailable.\r\n");
			(void) sm_io_fprintf(s, SM_TIME_DEFAULT,
					     "To fix, run sendmail with -dsm_check_heap.4\r\n");
		}
# else /* SM_HEAP_CHECK */
		(void) sm_io_fprintf(s, SM_TIME_DEFAULT,
				     "Memory dump unavailable.\r\n");
		(void) sm_io_fprintf(s, SM_TIME_DEFAULT,
				     "To fix, rebuild with -DSM_HEAP_CHECK\r\n");
# endif /* SM_HEAP_CHECK */
d363 1
a363 2
		(void) sm_io_fprintf(s, SM_TIME_DEFAULT,
				     "Bad command (%s)\r\n", cmdbuf);
d366 1
a366 1
	(void) sm_io_close(s, SM_TIME_DEFAULT);
d368 1
a368 1
		sm_clrevent(ev);
d371 2
@


