head	1.10;
access;
symbols
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.48
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.46
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.44
	OPENBSD_5_0:1.7.0.42
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.40
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.38
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.34
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.36
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.32
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.30
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.28
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.26
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.24
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.22
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.20
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.18
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.16
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.14
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.12
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.8
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.10
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.6
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.4
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2014.09.17.18.49.51;	author matthieu;	state dead;
branches;
next	1.9;
commitid	M7i5giHIoz3DMlTU;

1.9
date	2014.02.07.21.25.00;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.12.21.27.22;	author jca;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.01.17.18.29;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.11.19.02.49;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.29.01.31.13;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.28.02.43.52;	author millert;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.01.15.21.09.06;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.07.19.20.37;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.02.19.05.57;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.57;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.40;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.52;	author millert;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.31.00.31.06;	author miod;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.31.01.47.54;	author jason;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Bye.
@
text
@/*
 * Copyright (c) 1998-2001 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sm/gen.h>

SM_IDSTR(copyright,
"@@(#) Copyright (c) 1998-2001 Proofpoint, Inc. and its suppliers.\n\
	All rights reserved.\n\
     Copyright (c) 1988, 1993\n\
	The Regents of the University of California.  All rights reserved.\n")

SM_IDSTR(id, "@@(#)$Sendmail: rmail.c,v 8.63 2013/11/22 20:51:53 ca Exp $")

/*
 * RMAIL -- UUCP mail server.
 *
 * This program reads the >From ... remote from ... lines that UUCP is so
 * fond of and turns them into something reasonable.  It then execs sendmail
 * with various options built from these lines.
 *
 * The expected syntax is:
 *
 *	 <user> := [-a-z0-9]+
 *	 <date> := ctime format
 *	 <site> := [-a-z0-9!]+
 * <blank line> := "^\n$"
 *	 <from> := "From" <space> <user> <space> <date>
 *		  [<space> "remote from" <space> <site>]
 *    <forward> := ">" <from>
 *	    msg := <from> <forward>* <blank-line> <body>
 *
 * The output of rmail(8) compresses the <forward> lines into a single
 * from path.
 *
 * The err(3) routine is included here deliberately to make this code
 * a bit more portable.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/wait.h>

#include <ctype.h>
#include <fcntl.h>
#include <sm/io.h>
#include <stdlib.h>
#include <sm/string.h>
#include <unistd.h>
#ifdef EX_OK
# undef EX_OK		/* unistd.h may have another use for this */
#endif /* EX_OK */
#include <sysexits.h>

#include <sm/conf.h>
#include <sm/errstring.h>
#include <sendmail/pathnames.h>

static void err __P((int, const char *, ...));
static void usage __P((void));
static char *xalloc __P((int));

#define newstr(s)	strcpy(xalloc(strlen(s) + 1), s)

static char *
xalloc(sz)
	register int sz;
{
	register char *p;

	/* some systems can't handle size zero mallocs */
	if (sz <= 0)
		sz = 1;

	p = malloc(sz);
	if (p == NULL)
		err(EX_TEMPFAIL, "out of memory");
	return (p);
}

int
main(argc, argv)
	int argc;
	char *argv[];
{
	int ch, debug, i, pdes[2], pid, status;
	size_t fplen = 0, fptlen = 0, len;
	off_t offset;
	SM_FILE_T *fp;
	char *addrp = NULL, *domain, *p, *t;
	char *from_path, *from_sys, *from_user;
	char **args, buf[2048], lbuf[2048];
	struct stat sb;
	extern char *optarg;
	extern int optind;

	debug = 0;
	domain = "UUCP";		/* Default "domain". */
	while ((ch = getopt(argc, argv, "D:T")) != -1)
	{
		switch (ch)
		{
		  case 'T':
			debug = 1;
			break;

		  case 'D':
			domain = optarg;
			break;

		  case '?':
		  default:
			usage();
		}
	}

	argc -= optind;
	argv += optind;

	if (argc < 1)
		usage();

	from_path = from_sys = from_user = NULL;
	for (offset = 0; ; )
	{
		/* Get and nul-terminate the line. */
		if (sm_io_fgets(smioin, SM_TIME_DEFAULT, lbuf,
				sizeof(lbuf)) < 0)
			err(EX_DATAERR, "no data");
		if ((p = strchr(lbuf, '\n')) == NULL)
			err(EX_DATAERR, "line too long");
		*p = '\0';

		/* Parse lines until reach a non-"From" line. */
		if (!strncmp(lbuf, "From ", 5))
			addrp = lbuf + 5;
		else if (!strncmp(lbuf, ">From ", 6))
			addrp = lbuf + 6;
		else if (offset == 0)
			err(EX_DATAERR,
			    "missing or empty From line: %s", lbuf);
		else
		{
			*p = '\n';
			break;
		}

		if (addrp == NULL || *addrp == '\0')
			err(EX_DATAERR, "corrupted From line: %s", lbuf);

		/* Use the "remote from" if it exists. */
		for (p = addrp; (p = strchr(p + 1, 'r')) != NULL; )
		{
			if (!strncmp(p, "remote from ", 12))
			{
				for (t = p += 12; *t != '\0'; ++t)
				{
					if (isascii(*t) && isspace(*t))
						break;
				}
				*t = '\0';
				if (debug)
					(void) sm_io_fprintf(smioerr,
							     SM_TIME_DEFAULT,
							     "remote from: %s\n",
							     p);
				break;
			}
		}

		/* Else use the string up to the last bang. */
		if (p == NULL)
		{
			if (*addrp == '!')
				err(EX_DATAERR, "bang starts address: %s",
				    addrp);
			else if ((t = strrchr(addrp, '!')) != NULL)
			{
				*t = '\0';
				p = addrp;
				addrp = t + 1;
				if (*addrp == '\0')
					err(EX_DATAERR,
					    "corrupted From line: %s", lbuf);
				if (debug)
					(void) sm_io_fprintf(smioerr,
							     SM_TIME_DEFAULT,
							     "bang: %s\n", p);
			}
		}

		/* 'p' now points to any system string from this line. */
		if (p != NULL)
		{
			/* Nul terminate it as necessary. */
			for (t = p; *t != '\0'; ++t)
			{
				if (isascii(*t) && isspace(*t))
					break;
			}
			*t = '\0';

			/* If the first system, copy to the from_sys string. */
			if (from_sys == NULL)
			{
				from_sys = newstr(p);
				if (debug)
					(void) sm_io_fprintf(smioerr,
							     SM_TIME_DEFAULT,
							     "from_sys: %s\n",
							     from_sys);
			}

			/* Concatenate to the path string. */
			len = t - p;
			if (from_path == NULL)
			{
				fplen = 0;
				if ((from_path = malloc(fptlen = 256)) == NULL)
					err(EX_TEMPFAIL, "out of memory");
			}
			if (fplen + len + 2 > fptlen)
			{
				fptlen += SM_MAX(fplen + len + 2, 256);
				if ((from_path = realloc(from_path,
							 fptlen)) == NULL)
					err(EX_TEMPFAIL, "out of memory");
			}
			memmove(from_path + fplen, p, len);
			fplen += len;
			from_path[fplen++] = '!';
			from_path[fplen] = '\0';
		}

		/* Save off from user's address; the last one wins. */
		for (p = addrp; *p != '\0'; ++p)
		{
			if (isascii(*p) && isspace(*p))
				break;
		}
		*p = '\0';
		if (*addrp == '\0')
			addrp = "<>";
		if (from_user != NULL)
			free(from_user);
		from_user = newstr(addrp);

		if (debug)
		{
			if (from_path != NULL)
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "from_path: %s\n",
						     from_path);
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
					     "from_user: %s\n", from_user);
		}

		if (offset != -1)
			offset = (off_t)sm_io_tell(smioin, SM_TIME_DEFAULT);
	}


	/* Allocate args (with room for sendmail args as well as recipients */
	args = (char **)xalloc(sizeof(*args) * (10 + argc));

	i = 0;
	args[i++] = _PATH_SENDMAIL;	/* Build sendmail's argument list. */
	args[i++] = "-G";		/* relay submission */
	args[i++] = "-oee";		/* No errors, just status. */
	args[i++] = "-odq";		/* Queue it, don't try to deliver. */
	args[i++] = "-oi";		/* Ignore '.' on a line by itself. */

	/* set from system and protocol used */
	if (from_sys == NULL)
		sm_snprintf(buf, sizeof(buf), "-p%s", domain);
	else if (strchr(from_sys, '.') == NULL)
		sm_snprintf(buf, sizeof(buf), "-p%s:%s.%s",
			domain, from_sys, domain);
	else
		sm_snprintf(buf, sizeof(buf), "-p%s:%s", domain, from_sys);
	args[i++] = newstr(buf);

	/* Set name of ``from'' person. */
	sm_snprintf(buf, sizeof(buf), "-f%s%s",
		 from_path ? from_path : "", from_user);
	args[i++] = newstr(buf);

	/*
	**  Don't copy arguments beginning with - as they will be
	**  passed to sendmail and could be interpreted as flags.
	**  To prevent confusion of sendmail wrap < and > around
	**  the address (helps to pass addrs like @@gw1,@@gw2:aa@@bb)
	*/

	while (*argv != NULL)
	{
		if (**argv == '-')
			err(EX_USAGE, "dash precedes argument: %s", *argv);

		if (strchr(*argv, ',') == NULL || strchr(*argv, '<') != NULL)
			args[i++] = *argv;
		else
		{
			len = strlen(*argv) + 3;
			if ((args[i] = malloc(len)) == NULL)
				err(EX_TEMPFAIL, "Cannot malloc");
			sm_snprintf(args[i++], len, "<%s>", *argv);
		}
		argv++;
		argc--;

		/* Paranoia check, argc used for args[] bound */
		if (argc < 0)
			err(EX_SOFTWARE, "Argument count mismatch");
	}
	args[i] = NULL;

	if (debug)
	{
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				     "Sendmail arguments:\n");
		for (i = 0; args[i] != NULL; i++)
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
					     "\t%s\n", args[i]);
	}

	/*
	**  If called with a regular file as standard input, seek to the right
	**  position in the file and just exec sendmail.  Could probably skip
	**  skip the stat, but it's not unreasonable to believe that a failed
	**  seek will cause future reads to fail.
	*/

	if (!fstat(STDIN_FILENO, &sb) && S_ISREG(sb.st_mode))
	{
		if (lseek(STDIN_FILENO, offset, SEEK_SET) != offset)
			err(EX_TEMPFAIL, "stdin seek");
		(void) execv(_PATH_SENDMAIL, args);
		err(EX_OSERR, "%s", _PATH_SENDMAIL);
	}

	if (pipe(pdes) < 0)
		err(EX_OSERR, "pipe failed");

	switch (pid = fork())
	{
	  case -1:				/* Err. */
		err(EX_OSERR, "fork failed");
		/* NOTREACHED */

	  case 0:				/* Child. */
		if (pdes[0] != STDIN_FILENO)
		{
			(void) dup2(pdes[0], STDIN_FILENO);
			(void) close(pdes[0]);
		}
		(void) close(pdes[1]);
		(void) execv(_PATH_SENDMAIL, args);
		err(EX_UNAVAILABLE, "%s", _PATH_SENDMAIL);
		/* NOTREACHED */
	}

	if ((fp = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT, (void *) &(pdes[1]),
			     SM_IO_WRONLY, NULL)) == NULL)
		err(EX_OSERR, "sm_io_open failed");
	(void) close(pdes[0]);

	/* Copy the file down the pipe. */
	do
	{
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "%s", lbuf);
	} while (sm_io_fgets(smioin, SM_TIME_DEFAULT, lbuf,
			     sizeof(lbuf)) >= 0);

	if (sm_io_error(smioin))
		err(EX_TEMPFAIL, "stdin: %s", sm_errstring(errno));

	if (sm_io_close(fp, SM_TIME_DEFAULT))
		err(EX_OSERR, "sm_io_close failed");

	if ((waitpid(pid, &status, 0)) == -1)
		err(EX_OSERR, "%s", _PATH_SENDMAIL);

	if (!WIFEXITED(status))
		err(EX_OSERR, "%s: did not terminate normally", _PATH_SENDMAIL);

	if (WEXITSTATUS(status))
		err(status, "%s: terminated with %d (non-zero) status",
		    _PATH_SENDMAIL, WEXITSTATUS(status));
	exit(EX_OK);
	/* NOTREACHED */
	return EX_OK;
}

static void
usage()
{
	(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
			     "usage: rmail [-T] [-D domain] user ...\n");
	exit(EX_USAGE);
}

static void
#ifdef __STDC__
err(int eval, const char *fmt, ...)
#else /* __STDC__ */
err(eval, fmt, va_alist)
	int eval;
	const char *fmt;
	va_dcl
#endif /* __STDC__ */
{
	SM_VA_LOCAL_DECL

	if (fmt != NULL)
	{
		SM_VA_START(ap, fmt);
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT, "rmail: ");
		(void) sm_io_vfprintf(smioerr, SM_TIME_DEFAULT, fmt, ap);
		SM_VA_END(ap);
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT, "\n");
	}
	exit(eval);
}
@


1.9
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.8
log
@Update to sendmail-8.14.7

Verbatim sources, with s/$Id/$Sendmail/ patches, local build system and
config tweaks kept.
tested and ok millert@@ ajacoutot@@
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d16 1
a16 1
"@@(#) Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.\n\
d21 1
a21 1
SM_IDSTR(id, "@@(#)$Sendmail: rmail.c,v 8.62 2013/03/12 15:24:52 ca Exp $")
@


1.7
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d21 1
a21 1
SM_IDSTR(id, "@@(#)$Sendmail: rmail.c,v 8.61 2001/09/18 21:45:29 gshapiro Exp $")
d137 1
a137 1
				sizeof(lbuf)) == NULL)
d382 1
a382 1
			     sizeof(lbuf)) != NULL);
@


1.6
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d21 1
a21 1
SM_IDSTR(id, "@@(#)$Sendmail: rmail.c,v 8.58 2001/09/04 22:44:31 ca Exp $")
d372 1
a372 1
	if ((fp = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT, (void *)pdes[1],
@


1.5
log
@Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d13 3
a15 2
#ifndef lint
static char copyright[] =
d19 1
a19 2
	The Regents of the University of California.  All rights reserved.\n";
#endif /* ! lint */
d21 1
a21 3
#ifndef lint
static char id[] = "@@(#)$Sendmail: rmail.c,v 8.39.4.12 2001/05/07 22:06:39 gshapiro Exp $";
#endif /* ! lint */
d55 1
a55 10
#ifdef BSD4_4
# define FORK vfork
# include <paths.h>
#else /* BSD4_4 */
# define FORK fork
# ifndef _PATH_SENDMAIL
#  define _PATH_SENDMAIL "/usr/lib/sendmail"
# endif /* ! _PATH_SENDMAIL */
#endif /* BSD4_4 */
#include <stdio.h>
d57 1
a57 1
#include <string.h>
d64 3
a66 45
#ifndef MAX
# define MAX(a, b)	((a) < (b) ? (b) : (a))
#endif /* ! MAX */

#ifndef __P
# ifdef __STDC__
#  define __P(protos)	protos
# else /* __STDC__ */
#  define __P(protos)	()
#  define const
# endif /* __STDC__ */
#endif /* ! __P */

#ifndef STDIN_FILENO
# define STDIN_FILENO	0
#endif /* ! STDIN_FILENO */

#if defined(BSD4_4) || defined(linux) || SOLARIS >= 20600 || (SOLARIS < 10000 && SOLARIS >= 206) || _AIX4 >= 40300 || defined(HPUX11)
# define HASSNPRINTF	1
#endif /* defined(BSD4_4) || defined(linux) || SOLARIS >= 20600 || (SOLARIS < 10000 && SOLARIS >= 206) || _AIX4 >= 40300 || defined(HPUX11) */

#if defined(sun) && !defined(BSD) && !defined(SOLARIS) && !defined(__svr4__) && !defined(__SVR4)
# define memmove(d, s, l)	(bcopy((s), (d), (l)))
#endif /* defined(sun) && !defined(BSD) && !defined(SOLARIS) && !defined(__svr4__) && !defined(__SVR4) */

#if !HASSNPRINTF && !SFIO
extern int	snprintf __P((char *, size_t, const char *, ...));
#endif /* !HASSNPRINTF && !SFIO */

#if defined(BSD4_4) || defined(__osf__) || defined(__GNU_LIBRARY__) || defined(IRIX64) || defined(IRIX5) || defined(IRIX6)
# ifndef HASSTRERROR
#  define HASSTRERROR	1
# endif /* ! HASSTRERROR */
#endif /* defined(BSD4_4) || defined(__osf__) || defined(__GNU_LIBRARY__) ||
	  defined(IRIX64) || defined(IRIX5) || defined(IRIX6) */

#if defined(SUNOS403) || defined(NeXT) || (defined(MACH) && defined(i386) && !defined(__GNU__)) || defined(oldBSD43) || defined(MORE_BSD) || defined(umipsbsd) || defined(ALTOS_SYSTEM_V) || defined(RISCOS) || defined(_AUX_SOURCE) || defined(UMAXV) || defined(titan) || defined(UNIXWARE) || defined(sony_news) || defined(luna) || defined(nec_ews_svr4) || defined(_nec_ews_svr4) || defined(__MAXION__)
# undef WIFEXITED
# undef WEXITSTATUS
# define WIFEXITED(st)		(((st) & 0377) == 0)
# define WEXITSTATUS(st)	(((st) >> 8) & 0377)
#endif /* defined(SUNOS403) || defined(NeXT) || (defined(MACH) && defined(i386) && !defined(__GNU__)) || defined(oldBSD43) || defined(MORE_BSD) || defined(umipsbsd) || defined(ALTOS_SYSTEM_V) || defined(RISCOS) || defined(_AUX_SOURCE) || defined(UMAXV) || defined(titan) || defined(UNIXWARE) || defined(sony_news) || defined(luna) || defined(nec_ews_svr4) || defined(_nec_ews_svr4) || defined(__MAXION__) */


#include "sendmail/errstring.h"
d84 1
a84 1
	p = malloc((unsigned) sz);
d98 1
a98 1
	FILE *fp;
d136 3
a138 2
		if (fgets(lbuf, sizeof(lbuf), stdin) == NULL)
			exit(EX_DATAERR);
d172 4
a175 1
					fprintf(stderr, "remote from: %s\n", p);
d195 3
a197 1
					fprintf(stderr, "bang: %s\n", p);
d217 4
a220 2
					fprintf(stderr, "from_sys: %s\n",
						from_sys);
d229 1
a229 1
					err(EX_TEMPFAIL, NULL);
d233 1
a233 1
				fptlen += MAX(fplen + len + 2, 256);
d236 1
a236 1
					err(EX_TEMPFAIL, NULL);
d260 5
a264 2
				fprintf(stderr, "from_path: %s\n", from_path);
			fprintf(stderr, "from_user: %s\n", from_user);
d268 1
a268 1
			offset = (off_t)ftell(stdin);
d272 1
a272 1
	/* Allocate args (with room for sendmail args as well as recipients) */
d277 1
d284 1
a284 1
		snprintf(buf, sizeof(buf), "-p%s", domain);
d286 1
a286 1
		snprintf(buf, sizeof(buf), "-p%s:%s.%s",
d289 1
a289 1
		snprintf(buf, sizeof(buf), "-p%s:%s", domain, from_sys);
d293 1
a293 1
	snprintf(buf, sizeof(buf), "-f%s%s",
d316 1
a316 1
			snprintf(args[i++], len, "<%s>", *argv);
d329 2
a330 1
		fprintf(stderr, "Sendmail arguments:\n");
d332 2
a333 1
			fprintf(stderr, "\t%s\n", args[i]);
d352 1
a352 1
		err(EX_OSERR, NULL);
d354 1
a354 1
	switch (pid = FORK())
d357 1
a357 1
		err(EX_OSERR, NULL);
d368 1
a368 1
		_exit(127);
d372 3
a374 2
	if ((fp = fdopen(pdes[1], "w")) == NULL)
		err(EX_OSERR, NULL);
d380 3
a382 2
		(void) fprintf(fp, "%s", lbuf);
	} while (fgets(lbuf, sizeof(lbuf), stdin) != NULL);
d384 2
a385 2
	if (ferror(stdin))
		err(EX_TEMPFAIL, "stdin: %s", errstring(errno));
d387 2
a388 2
	if (fclose(fp))
		err(EX_OSERR, NULL);
d407 2
a408 1
	(void) fprintf(stderr, "usage: rmail [-T] [-D domain] user ...\n");
a411 6
#ifdef __STDC__
# include <stdarg.h>
#else /* __STDC__ */
# include <varargs.h>
#endif /* __STDC__ */

d422 10
a431 10
	va_list ap;
#ifdef __STDC__
	va_start(ap, fmt);
#else /* __STDC__ */
	va_start(ap);
#endif /* __STDC__ */
	(void) fprintf(stderr, "rmail: ");
	(void) vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void) fprintf(stderr, "\n");
@


1.4
log
@Update to sendmail 8.11.3.  This is a maintenance release which
contains bug fixes for problems found after 8.11.2 was released.
Systems which use buffered file I/O (like OpenBSD) were not properly
fsync()'ing the data (df) file.  Although there is little chance
of data loss, this is an important fix.
@
text
@d15 1
a15 1
"@@(#) Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.\n\
d22 1
a22 1
static char id[] = "@@(#)$Sendmail: rmail.c,v 8.39.4.11 2001/02/14 04:07:25 gshapiro Exp $";
@


1.4.2.1
log
@Pull in patch from current:
Fix (millert), Errata 001:
Update to sendmail 8.11.4:
    8.11.4 revamps signal handling within the MTA in order to reduce
    the likelihood of a race condition that can lead to heap
    corruption as described in Michal Zalewski's advisory.  The
    problems discussed in the advisory are not currently known to
    be exploitable but we recommend upgrading to 8.11.4 in case a
    method is found to exploit the signal handling race condition.
    8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d15 1
a15 1
"@@(#) Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.\n\
d22 1
a22 1
static char id[] = "@@(#)$Sendmail: rmail.c,v 8.39.4.12 2001/05/07 22:06:39 gshapiro Exp $";
@


1.3
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
d22 1
a22 1
static char id[] = "@@(#)$Sendmail: rmail.c,v 8.39.4.9 2000/11/17 08:42:56 gshapiro Exp $";
d100 1
a100 1
#if !HASSNPRINTF
d102 1
a102 1
#endif /* !HASSNPRINTF */
@


1.2
log
@Update to sendmail-8.10.1
@
text
@d22 1
a22 1
static char id[] = "@@(#)$Sendmail: rmail.c,v 8.39 2000/03/17 07:32:47 gshapiro Exp $";
d92 1
a92 1
#if defined(BSD4_4) || defined(linux) || SOLARIS >= 20600 || (SOLARIS < 10000 && SOLARIS >= 206)
d94 1
a94 1
#endif /* defined(BSD4_4) || defined(linux) || SOLARIS >= 20600 || (SOLARIS < 10000 && SOLARIS >= 206) */
d154 1
a154 1
	char *args[100], buf[2048], lbuf[2048];
d161 1
a161 1
	while ((ch = getopt(argc, argv, "D:T")) != EOF)
d209 1
a209 1
		if (*addrp == '\0')
d313 4
d345 1
a345 1
	while (*argv)
d360 5
d366 1
a366 1
	args[i] = 0;
d371 1
a371 1
		for (i = 0; args[i]; i++)
@


1.2.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d15 1
a15 1
"@@(#) Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.\n\
d22 1
a22 1
static char id[] = "@@(#)$Sendmail: rmail.c,v 8.39.4.12 2001/05/07 22:06:39 gshapiro Exp $";
d92 1
a92 1
#if defined(BSD4_4) || defined(linux) || SOLARIS >= 20600 || (SOLARIS < 10000 && SOLARIS >= 206) || _AIX4 >= 40300 || defined(HPUX11)
d94 1
a94 1
#endif /* defined(BSD4_4) || defined(linux) || SOLARIS >= 20600 || (SOLARIS < 10000 && SOLARIS >= 206) || _AIX4 >= 40300 || defined(HPUX11) */
d100 1
a100 1
#if !HASSNPRINTF && !SFIO
d102 1
a102 1
#endif /* !HASSNPRINTF && !SFIO */
d154 1
a154 1
	char **args, buf[2048], lbuf[2048];
d161 1
a161 1
	while ((ch = getopt(argc, argv, "D:T")) != -1)
d209 1
a209 1
		if (addrp == NULL || *addrp == '\0')
a312 4

	/* Allocate args (with room for sendmail args as well as recipients) */
	args = (char **)xalloc(sizeof(*args) * (10 + argc));

d341 1
a341 1
	while (*argv != NULL)
a355 5
		argc--;

		/* Paranoia check, argc used for args[] bound */
		if (argc < 0)
			err(EX_SOFTWARE, "Argument count mismatch");
d357 1
a357 1
	args[i] = NULL;
d362 1
a362 1
		for (i = 0; args[i] != NULL; i++)
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
"@@(#) Copyright (c) 1998, 1999 Sendmail, Inc. and its suppliers.\n\
d22 1
a22 1
static char id[] = "@@(#)$Sendmail: rmail.c,v 8.38 2000/02/26 01:32:22 gshapiro Exp $";
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d15 1
a15 1
"@@(#) Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.\n\
d22 1
a22 1
static char id[] = "@@(#)$Id: rmail.c,v 8.39.4.9 2000/11/17 08:42:56 gshapiro Exp $";
d92 1
a92 1
#if defined(BSD4_4) || defined(linux) || SOLARIS >= 20600 || (SOLARIS < 10000 && SOLARIS >= 206) || _AIX4 >= 40300 || defined(HPUX11)
d94 1
a94 1
#endif /* defined(BSD4_4) || defined(linux) || SOLARIS >= 20600 || (SOLARIS < 10000 && SOLARIS >= 206) || _AIX4 >= 40300 || defined(HPUX11) */
d154 1
a154 1
	char **args, buf[2048], lbuf[2048];
d161 1
a161 1
	while ((ch = getopt(argc, argv, "D:T")) != -1)
d209 1
a209 1
		if (addrp == NULL || *addrp == '\0')
a312 4

	/* Allocate args (with room for sendmail args as well as recipients) */
	args = (char **)xalloc(sizeof(*args) * (10 + argc));

d341 1
a341 1
	while (*argv != NULL)
a355 5
		argc--;

		/* Paranoia check, argc used for args[] bound */
		if (argc < 0)
			err(EX_SOFTWARE, "Argument count mismatch");
d357 1
a357 1
	args[i] = NULL;
d362 1
a362 1
		for (i = 0; args[i] != NULL; i++)
@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.
d13 3
a15 4
#include <sm/gen.h>

SM_IDSTR(copyright,
"@@(#) Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.\n\
d18 2
a19 1
	The Regents of the University of California.  All rights reserved.\n")
d21 3
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: rmail.c,v 8.58 2001/09/04 22:44:31 ca Exp $")
d57 10
a66 1
#include <sm/io.h>
d68 1
a68 1
#include <sm/string.h>
d75 45
a119 3
#include <sm/conf.h>
#include <sm/errstring.h>
#include <sendmail/pathnames.h>
d137 1
a137 1
	p = malloc(sz);
d151 1
a151 1
	SM_FILE_T *fp;
d189 2
a190 3
		if (sm_io_fgets(smioin, SM_TIME_DEFAULT, lbuf,
				sizeof(lbuf)) == NULL)
			err(EX_DATAERR, "no data");
d224 1
a224 4
					(void) sm_io_fprintf(smioerr,
							     SM_TIME_DEFAULT,
							     "remote from: %s\n",
							     p);
d244 1
a244 3
					(void) sm_io_fprintf(smioerr,
							     SM_TIME_DEFAULT,
							     "bang: %s\n", p);
d264 2
a265 4
					(void) sm_io_fprintf(smioerr,
							     SM_TIME_DEFAULT,
							     "from_sys: %s\n",
							     from_sys);
d274 1
a274 1
					err(EX_TEMPFAIL, "out of memory");
d278 1
a278 1
				fptlen += SM_MAX(fplen + len + 2, 256);
d281 1
a281 1
					err(EX_TEMPFAIL, "out of memory");
d305 2
a306 5
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "from_path: %s\n",
						     from_path);
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
					     "from_user: %s\n", from_user);
d310 1
a310 1
			offset = (off_t)sm_io_tell(smioin, SM_TIME_DEFAULT);
d314 1
a314 1
	/* Allocate args (with room for sendmail args as well as recipients */
a318 1
	args[i++] = "-G";		/* relay submission */
d325 1
a325 1
		sm_snprintf(buf, sizeof(buf), "-p%s", domain);
d327 1
a327 1
		sm_snprintf(buf, sizeof(buf), "-p%s:%s.%s",
d330 1
a330 1
		sm_snprintf(buf, sizeof(buf), "-p%s:%s", domain, from_sys);
d334 1
a334 1
	sm_snprintf(buf, sizeof(buf), "-f%s%s",
d357 1
a357 1
			sm_snprintf(args[i++], len, "<%s>", *argv);
d370 1
a370 2
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				     "Sendmail arguments:\n");
d372 1
a372 2
			(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
					     "\t%s\n", args[i]);
d391 1
a391 1
		err(EX_OSERR, "pipe failed");
d393 1
a393 1
	switch (pid = fork())
d396 1
a396 1
		err(EX_OSERR, "fork failed");
d407 1
a407 1
		err(EX_UNAVAILABLE, "%s", _PATH_SENDMAIL);
d411 2
a412 3
	if ((fp = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT, (void *)pdes[1],
			     SM_IO_WRONLY, NULL)) == NULL)
		err(EX_OSERR, "sm_io_open failed");
d418 2
a419 3
		(void) sm_io_fprintf(fp, SM_TIME_DEFAULT, "%s", lbuf);
	} while (sm_io_fgets(smioin, SM_TIME_DEFAULT, lbuf,
			     sizeof(lbuf)) != NULL);
d421 2
a422 2
	if (sm_io_error(smioin))
		err(EX_TEMPFAIL, "stdin: %s", sm_errstring(errno));
d424 2
a425 2
	if (sm_io_close(fp, SM_TIME_DEFAULT))
		err(EX_OSERR, "sm_io_close failed");
d444 1
a444 2
	(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
			     "usage: rmail [-T] [-D domain] user ...\n");
d448 6
d464 10
a473 10
	SM_VA_LOCAL_DECL

	if (fmt != NULL)
	{
		SM_VA_START(ap, fmt);
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT, "rmail: ");
		(void) sm_io_vfprintf(smioerr, SM_TIME_DEFAULT, fmt, ap);
		SM_VA_END(ap);
		(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT, "\n");
	}
@


