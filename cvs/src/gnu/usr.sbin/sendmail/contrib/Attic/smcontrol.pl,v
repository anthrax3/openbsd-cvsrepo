head	1.5;
access;
symbols
	OPENBSD_5_6:1.4.0.16
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.14
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.10
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.8
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.6
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.36
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.34
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.30
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.32
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.28
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.26
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.24
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.22
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.20
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.18
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.16
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.14
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.12
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.10
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.4
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.1.1.2.0.6
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.4
	OPENBSD_3_0_BASE:1.1.1.2
	SENDMAIL_8_12_0:1.1.1.2
	OPENBSD_2_9:1.1.1.2.0.2
	OPENBSD_2_9_BASE:1.1.1.2
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@# @;


1.5
date	2014.09.17.18.49.50;	author matthieu;	state dead;
branches;
next	1.4;
commitid	M7i5giHIoz3DMlTU;

1.4
date	2011.05.17.15.54.23;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.03.17.25.46;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2002.04.18.00.49.26;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.58;	author millert;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.41;	author millert;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	2001.05.31.00.26.59;	author miod;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Bye.
@
text
@#!/usr/bin/perl -w

# $Sendmail: smcontrol.pl,v 8.8 2008/07/21 21:31:43 ca Exp $

use strict;
use Getopt::Std;
use FileHandle;
use Socket;

my $sendmailDaemon = "/usr/sbin/sendmail -q30m -bd";

##########################################################################
#
#  &get_controlname -- read ControlSocketName option from sendmail.cf
#
#	Parameters:
#		none.
#
#	Returns:
#		control socket filename, undef if not found
#

sub get_controlname
{
	my $cn = undef;
	my $qd = undef;
 
	open(CF, "</etc/mail/sendmail.cf") or return $cn;
	while (<CF>)
	{
		chomp;
		if (/^O ControlSocketName\s*=\s*([^#]+)$/o)
		{
			$cn = $1;
		}
		if (/^O QueueDirectory\s*=\s*([^#]+)$/o)
		{
			$qd = $1;
		}
		if (/^OQ([^#]+)$/o)
		{
			$qd = $1;
		}
	}
	close(CF);
	if (not defined $cn)
	{
		return undef;
	}
	if ($cn !~ /^\//o)
	{
		return undef if (not defined $qd);
		
		$cn = $qd . "/" . $cn;
	}
	return $cn;
}

##########################################################################
#
#  &do_command -- send command to sendmail daemon view control socket
#
#	Parameters:
#		controlsocket -- filename for socket
#		command -- command to send
#
#	Returns:
#		reply from sendmail daemon
#

sub do_command
{
	my $controlsocket = shift;
	my $command = shift;
	my $proto = getprotobyname('ip');
	my @@reply;
	my $i;

	socket(SOCK, PF_UNIX, SOCK_STREAM, $proto) or return undef;

	for ($i = 0; $i < 4; $i++)
	{
		if (!connect(SOCK, sockaddr_un($controlsocket)))
		{
			if ($i == 3)
			{
				close(SOCK);
				return undef;
			}
			sleep 1;
			next;
		}
		last;
	}
	autoflush SOCK 1;
	print SOCK "$command\n";
	@@reply = <SOCK>;
	close(SOCK);
	return join '', @@reply;
}

##########################################################################
#
#  &sendmail_running -- check if sendmail is running via SMTP
#
#	Parameters:
#		none
#
#	Returns:
#		1 if running, undef otherwise
#

sub sendmail_running
{
	my $port = getservbyname("smtp", "tcp") || 25;
	my $proto = getprotobyname("tcp");
	my $iaddr = inet_aton("localhost");
	my $paddr = sockaddr_in($port, $iaddr);

	socket(SOCK, PF_INET, SOCK_STREAM, $proto) or return undef;
	if (!connect(SOCK, $paddr))
	{
		close(SOCK);
		return undef;
	}
	autoflush SOCK 1;
	while (<SOCK>)
	{
		if (/^(\d{3})([ -])/)
		{
			if ($1 != 220)
			{
				close(SOCK);
				return undef;
			}
		}
		else
		{
			close(SOCK);
			return undef;
		}
		last if ($2 eq " ");
	}
	print SOCK "QUIT\n";
	while (<SOCK>)
	{
		last if (/^\d{3} /);
	}
	close(SOCK);
	return 1;
}

##########################################################################
#
#  &munge_status -- turn machine readable status into human readable text
#
#	Parameters:
#		raw -- raw results from sendmail daemon STATUS query
#
#	Returns:
#		human readable text
#

sub munge_status
{
	my $raw = shift;
	my $cooked = "";
	my $daemonStatus = "";

	if ($raw =~ /^(\d+)\/(\d+)\/(\d+)\/(\d+)/mg)
	{
		$cooked .= "Current number of children: $1";
		if ($2 > 0)
		{
			$cooked .= " (maximum $2)";
		}
		$cooked .= "\n";
		$cooked .= "QueueDir free disk space (in blocks): $3\n";
		$cooked .= "Load average: $4\n";
	}
	while ($raw =~ /^(\d+) (.*)$/mg)
	{
		if (not $daemonStatus)
		{
			$daemonStatus = "(process $1) " . ucfirst($2) . "\n";
		}
		else
		{
			$cooked .= "Child Process $1 Status: $2\n";
		}
	}
	return ($daemonStatus, $cooked);
}

##########################################################################
#
#  &start_daemon -- fork off a sendmail daemon
#
#	Parameters:
#		control -- control socket name
#
#	Returns:
#		Error message or "OK" if successful
#

sub start_daemon
{
	my $control = shift;
	my $pid;

	if ($pid = fork)
	{
		my $exitstat;

		waitpid $pid, 0 or return "Could not get status of created process: $!\n";
		$exitstat = $? / 256;
		if ($exitstat != 0)
		{
			return "sendmail daemon startup exited with exit value $exitstat";
		}
	}
	elsif (defined $pid)
	{
		exec($sendmailDaemon);
		die "Unable to start sendmail daemon: $!.\n";
	}
	else
	{
		return "Could not create new process: $!\n";
	}
	return "OK\n";
}

##########################################################################
#
#  &stop_daemon -- stop the sendmail daemon using control socket
#
#	Parameters:
#		control -- control socket name
#
#	Returns:
#		Error message or status message
#

sub stop_daemon
{
	my $control = shift;
	my $status;

	if (not defined $control)
	{
		return "The control socket is not configured so the daemon can not be stopped.\n";
	}
	return &do_command($control, "SHUTDOWN");
}

##########################################################################
#
#  &restart_daemon -- restart the sendmail daemon using control socket
#
#	Parameters:
#		control -- control socket name
#
#	Returns:
#		Error message or status message
#

sub restart_daemon
{
	my $control = shift;
	my $status;

	if (not defined $control)
	{
		return "The control socket is not configured so the daemon can not be restarted.";
	}
	return &do_command($control, "RESTART");
}

##########################################################################
#
#  &memdump -- get memdump from the daemon using the control socket
#
#	Parameters:
#		control -- control socket name
#
#	Returns:
#		Error message or status message
#

sub memdump
{
	my $control = shift;
	my $status;

	if (not defined $control)
	{
		return "The control socket is not configured so the daemon can not be queried for memdump.";
	}
	return &do_command($control, "MEMDUMP");
}

##########################################################################
#
#  &help -- get help from the daemon using the control socket
#
#	Parameters:
#		control -- control socket name
#
#	Returns:
#		Error message or status message
#

sub help
{
	my $control = shift;
	my $status;

	if (not defined $control)
	{
		return "The control socket is not configured so the daemon can not be queried for help.";
	}
	return &do_command($control, "HELP");
}

my $status = undef;
my $daemonStatus = undef;
my $opts = {};

getopts('f:', $opts) || die "Usage: $0 [-f /path/to/control/socket] command\n";

my $control = $opts->{f} || &get_controlname;
my $command = shift;

if (not defined $control)
{
	die "No control socket available.\n";
}
if (not defined $command)
{
	die "Usage: $0 [-f /path/to/control/socket] command\n";
}
if ($command eq "status")
{
	$status = &do_command($control, "STATUS");
	if (not defined $status)
	{
		# Not responding on control channel, query via SMTP
		if (&sendmail_running)
		{
			$daemonStatus = "Sendmail is running but not answering status queries.";
		}
		else
		{
			$daemonStatus = "Sendmail does not appear to be running.";
		}
	}
	else
	{
		# Munge control channel output
		($daemonStatus, $status) = &munge_status($status);
	}
}
elsif (lc($command) eq "shutdown")
{
	$status = &stop_daemon($control);
}
elsif (lc($command) eq "restart")
{
	$status = &restart_daemon($control);
}
elsif (lc($command) eq "start")
{
	$status = &start_daemon($control);
}
elsif (lc($command) eq "memdump")
{
	$status = &memdump($control);
}
elsif (lc($command) eq "help")
{
	$status = &help($control);
}
elsif (lc($command) eq "mstat")
{
	$status = &do_command($control, "mstat");
	if (not defined $status)
	{
		# Not responding on control channel, query via SMTP
		if (&sendmail_running)
		{
			$daemonStatus = "Sendmail is running but not answering status queries.";
		}
		else
		{
			$daemonStatus = "Sendmail does not appear to be running.";
		}
	}
}
else
{
	die "Unrecognized command $command\n";
}
if (defined $daemonStatus)
{
	print "Daemon Status: $daemonStatus\n";
}
if (defined $status)
{
	print "$status\n";
}
else
{
	die "No response\n";
}
@


1.4
log
@Update to sendmail 8.14.5
@
text
@@


1.3
log
@Update to sendmail-8.12.4
@
text
@d1 3
a3 1
#!/usr/local/bin/perl -w
@


1.2
log
@update to sendmail 8.12.3
@
text
@d382 16
@


1.1
log
@Initial revision
@
text
@d3 2
d8 1
a8 1
$sendmailDaemon = "/usr/sbin/sendmail -q30m -bd";
d75 1
d168 1
a168 1
	if ($raw =~ /^(\d+)\/(\d+)\/(\d+)\/(\d+)$/mg)
d222 1
a222 1
		exec($main::sendmailDaemon);
d280 23
a323 2
my $command = shift;
my $control = &get_controlname;
d326 6
d339 1
a339 1
	die "Usage: $0 command\n";
d373 4
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.1.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d165 1
a165 1
	if ($raw =~ /^(\d+)\/(\d+)\/(\d+)\/(\d+)/mg)
@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d165 1
a165 1
	if ($raw =~ /^(\d+)\/(\d+)\/(\d+)\/(\d+)/mg)
@

