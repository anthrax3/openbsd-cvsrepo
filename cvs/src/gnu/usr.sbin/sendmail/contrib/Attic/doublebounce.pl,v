head	1.4;
access;
symbols
	OPENBSD_5_6:1.3.0.46
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.44
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.40
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.38
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.36
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.34
	OPENBSD_5_0:1.3.0.32
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.30
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.28
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.24
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.26
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.22
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.20
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.18
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.16
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.14
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.12
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.10
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.8
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.6
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.4
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.1.1.1.0.12
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.10
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.8
	OPENBSD_3_0_BASE:1.1.1.1
	SENDMAIL_8_12_0:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	SENDMAIL_8_11_2:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2014.09.17.18.49.50;	author matthieu;	state dead;
branches;
next	1.3;
commitid	M7i5giHIoz3DMlTU;

1.3
date	2003.09.17.17.31.39;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.01.19.59.20;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.02.19.05.57;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.57;	author millert;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Bye.
@
text
@#!/usr/bin/perl
# doublebounce.pl
#
# Return a doubly-bounced e-mail to postmaster.  Specific to sendmail,
# updated to work on sendmail 8.12.6.
#
# Based on the original doublebounce.pl code by jr@@terra.net, 12/4/97.
# Updated by bicknell@@ufp.org, 12/4/2002 to understand new sendmail DSN
# bounces.  Code cleanup also performed, mainly making things more
# robust.
#
# Original intro included below, lines with ##
##	attempt to return a doubly-bounced email to a postmaster
##	jr@@terra.net, 12/4/97
##
##	invoke by creating an mail alias such as:
##		doublebounce:	"|/usr/local/sbin/doublebounce"
##	then adding this line to your sendmail.cf:
##		O DoubleBounceAddress=doublebounce
##
##	optionally, add a "-d" flag in the aliases file, to send a
##	debug trace to your own postmaster showing what is going on
##
##	this allows the "postmaster" address to still go to a human being,
##	while bounce messages can go to this script, which will bounce them
##	back to the postmaster at the sending site.
##
##	the algorithm is to scan the double-bounce error report generated
##	by sendmail on stdin, for the original message (it starts after the
##	second "Orignal message follows" marker), look for From, Sender, and
##	Received headers from the point closest to the sender back to the point
##	closest to us, and try to deliver a double-bounce report back to a
##	postmaster at one of these sites in the hope that they can
##	return the message to the original sender, or do something about
##	the fact that that sender's return address is not valid.

use Socket;
use Getopt::Std;
use File::Temp;
use Sys::Syslog qw(:DEFAULT setlogsock);
use strict;
use vars qw( $opt_d $tmpfile);

# parseaddr()
#	parse hostname from From: header
#
sub parseaddr {
  my($hdr) = @@_;
  my($addr);

  if ($hdr =~ /<.*>/) {
    ($addr) = $hdr =~ m/<(.*)>/;
    $addr =~ s/.*\@@//;
    return $addr;
  }
  if ($addr =~ /\s*\(/) {
    ($addr) = $hdr =~ m/\s*(.*)\s*\(/;
    $addr =~ s/.*\@@//;
    return $addr;
  }
  ($addr) = $hdr =~ m/\s*(.*)\s*/;
  $addr =~ s/.*\@@//;
  return $addr;
}

# sendbounce()
#	send bounce to postmaster
#
#	this re-invokes sendmail in immediate and quiet mode to try
#	to deliver to a postmaster.  sendmail's exit status tells us
#	whether the delivery attempt really was successful.
#
sub send_bounce {
  my($addr, $from) = @@_;
  my($st);
  my($result);

  my($dest) = "postmaster\@@" . parseaddr($addr);

  if ($opt_d) {
    syslog ('info', "Attempting to send to user $dest");
  }
  open(MAIL, "| /usr/sbin/sendmail -oeq $dest");
  print MAIL <<EOT;
From: Mail Delivery Subsystem <mail-router>
Subject: Postmaster notify: double bounce
Reply-To: nobody
Errors-To: nobody
Precedence: junk
Auto-Submitted: auto-generated (postmaster notification)

The following message was received for an invalid recipient.  The
sender's address was also invalid.  Since the message originated
at or transited through your mailer, this notification is being
sent to you in the hope that you will determine the real originator
and have them correct their From or Sender address.

The from header on the original e-mail was: $from.

   ----- The following is a double bounce -----

EOT

  open(MSG, "<$tmpfile");
  print MAIL <MSG>;
  close(MSG);
  $result = close(MAIL);
  if ($result) {
    syslog('info', 'doublebounce successfully sent to %s', $dest);
  }
  return $result;
}

sub main {
  # Get our command line options
  getopts('d');

  # Set up syslog
  setlogsock('unix');
  openlog('doublebounce', 'pid', 'mail');
 
  if ($opt_d) {
    syslog('info', 'Processing a doublebounce.');
  }

  # The bounced e-mail may be large, so we'd better not try to buffer
  # it in memory, get a temporary file.
  $tmpfile = tmpnam();

  if (!open(MSG, ">$tmpfile")) {
    syslog('err', "Unable to open temporary file $tmpfile");
    exit(75); # 75 is a temporary failure, sendmail should retry
  }
  print(MSG <STDIN>);
  close(MSG);
  if (!open(MSG, "<$tmpfile")) {
    syslog('err', "Unable to reopen temporary file $tmpfile");
    exit(74); # 74 is an IO error
  }

  # Ok, now we can get down to business, find the original message
  my($skip_lines, $in_header, $headers_found, @@addresses);
  $skip_lines = 0;
  $in_header = 0;
  $headers_found = 0;
  while (<MSG>) {
    if ($skip_lines > 0) {
      $skip_lines--;
      next;
    }
    chomp;
    # Starting message depends on your version of sendmail
    if (/^   ----- Original message follows -----$/ ||
        /^   ----Unsent message follows----$/ ||
        /^Content-Type: message\/rfc822$/) {
      # Found the original message
      $skip_lines++;
      $in_header = 1;
      $headers_found++;
      next;
    }
    if (/^$/) {
      if ($headers_found >= 2) {
         # We only process two deep, even if there are more
         last;
      }
      if ($in_header) {
         # We've found the end of a header, scan for the next one
         $in_header = 0;
      }
      next;
    }
    if ($in_header) {
      if (! /^[ \t]/) {
        # New Header
        if (/^(received): (.*)/i ||
            /^(reply-to): (.*)/i ||    
            /^(sender): (.*)/i ||    
            /^(from): (.*)/i ) {
          $addresses[$headers_found]{$1} = $2;
        }
        next;
      } else {
        # continuation header
        # we should really process these, but we don't yet
        next;
      }
    } else {
      # Nothing to do if we're not in a header
      next;
    }
  }
  close(MSG);

  # Start with the original (inner) sender
  my($addr, $sent);
  foreach $addr (keys %{$addresses[2]}) {
    if ($opt_d) {
      syslog('info', "Trying to send to $addresses[2]{$addr} - $addresses[2]{\"From\"}");
    }
    $sent = send_bounce($addresses[2]{$addr}, $addresses[2]{"From"});
    last if $sent;
  }
  if (!$sent && $opt_d) {
    if ($opt_d) {
      syslog('info', 'Unable to find original sender, falling back.');
    }
    foreach $addr (keys %{$addresses[1]}) {
      if ($opt_d) {
        syslog('info', "Trying to send to $addresses[2]{$addr} - $addresses[2]{\"From\"}");
      }
      $sent = send_bounce($addresses[1]{$addr}, $addresses[2]{"From"});
      last if $sent;
    }
    if (!$sent) {
      syslog('info', 'Unable to find anyone to send a doublebounce notification');
    }
  }

  unlink($tmpfile);
}

main();
exit(0);

@


1.3
log
@Update to sendmail-8.12.10.  This includes a fix for a buffer overflow
in address parsing.  That fix (but not all of sendmail-8.12.10) has
been applied to OpenBSD 3.4 and the 3.2 and 3.2 -stable branches.
@
text
@@


1.2
log
@update to sendmail 8.12.7
@
text
@d39 1
a39 1
use POSIX;
d128 1
a128 1
  $tmpfile = POSIX::tmpnam();
@


1.1
log
@Initial revision
@
text
@a2 2
#	attempt to return a doubly-bounced email to a postmaster
#	jr@@terra.net, 12/4/97
d4 32
a35 21
#	invoke by creating an mail alias such as:
#		doublebounce:	"|/usr/local/sbin/doublebounce"
#	then adding this line to your sendmail.cf:
#		O DoubleBounceAddress=doublebounce
#
#	optionally, add a "-d" flag in the aliases file, to send a
#	debug trace to your own postmaster showing what is going on
#
#	this allows the "postmaster" address to still go to a human being,
#	while bounce messages can go to this script, which will bounce them
#	back to the postmaster at the sending site.
#
#	the algorithm is to scan the double-bounce error report generated
#	by sendmail on stdin, for the original message (it starts after the
#	second "Orignal message follows" marker), look for From, Sender, and
#	Received headers from the point closest to the sender back to the point
#	closest to us, and try to deliver a double-bounce report back to a
#	postmaster at one of these sites in the hope that they can
#	return the message to the original sender, or do something about
#	the fact that that sender's return address is not valid.

d38 5
a42 148

# look for debug flag
#
$dflag = 0;
$dflag = 1 if ($ARGV[0] eq "-d");

# get local host name
#	you may need to edit these two lines for however your system does this
#
$host = `hostname`; chop($host);
$domain = `dnsdomainname`; chop($domain);

# get temp file name
$tmp = "/tmp/doubb$$";

# save message from STDIN to a file
#	I thought about reading it into a buffer here, but some messages
#	are 10+Mb so a buffer may not be a good idea
#
if (! open(MSG, "+> $tmp")) {
	# can't open temp file -- send message to local postmaster
	# open(MAIL, "| /usr/sbin/sendmail -oeq postmaster");
	print MAIL <STDIN>;
	close(MAIL);
	exit(1);
}
print MSG <STDIN>;

# scan message for list of possible sender sites
#	note that original message appears after the second
#	"Original message follows" marker
#	look for From, Sender, and Reply-To and try them, too
#
$inhdr = 0;
$hdrs = 0;
$skip = 0;
seek(MSG, 0, 0);
while (<MSG>) {
	chop;
	if (/^   ----- Original message follows -----$/
	     || /^   ----Unsent message follows----$/) {
		$i = 0;
		$inhdr = 1;
		$hdrs++;
		$skip = 1;
		next;
	}
	if ($skip) {
		$skip--;
		next;
	}
	if (/^$/) {
		last if ($hdrs >= 2);
		$inhdr = 0;
		next;
	}
	if (! $inhdr) {
		next;
	}
	if (! /^[ \t]/) { $hdr[$i++] = $_ }
	else {
		$i--;
		$hdr[$i++] .= $_;
	}
}
$rcvd = 0;
for ($j = 0; $j < $i; $j++) {
	print STDERR "DEBUG hdr[$j] = $hdr[$j]\n";
	if ($hdr[$j] =~ /^received:/i) {
		($addr[$rcvd++]) = $hdr[$j] =~ m/.*\sby\s([^\s]+)\s.*/;
	}
	if ($hdr[$j] =~ /^reply-to:/i) {
		($addr1{"reply-to"} = $hdr[$j]) =~ s/^reply-to: *//i;
	}
	if ($hdr[$j] =~ /^sender:/i) {
		($addr1{"sender"} = $hdr[$j]) =~ s/^sender: *//i;
		}
	if ($hdr[$j] =~ /^from:/i) {
		($addr1{"from"} = $hdr[$j]) =~ s/^from: *//i;
	}
}

# %addr and %addr1 arrays now contain lists of possible sites (or From headers).
# Go through them parsing for the site name, and attempting to send
# to the named person or postmaster@@ each site in turn until successful
#
if ($dflag) {
	open(DEBUG, "|/usr/sbin/sendmail postmaster");
	print DEBUG "Subject: double bounce dialog\n";
}
$sent = 0;
# foreach $x ("from", "sender", "reply-to") {
foreach $x ("from", "sender") {
	$y = &parseaddr($addr1{$x});
	if ($y) {
		print DEBUG "Trying $y\n" if ($dflag);
		if (&sendbounce("$y")) {
			$sent++;
			last;
		}
		$y =~ s/.*@@//;
		print DEBUG "Trying postmaster\@@$y\n" if ($dflag);
		if (&sendbounce("postmaster\@@$y")) {
			$sent++;
			last;
		}
	}
}
if (! $sent) {
	$rcvd--;
	for ($i = $rcvd; $i >= 0; $i--) {
		$y = &parseaddr($addr[$i]);
		$y =~ s/.*@@//;
		if ($y) {
			print DEBUG "Trying postmaster\@@$y\n" if ($dflag);
			if (&sendbounce("postmaster\@@$y")) {
				$sent++;
				last;
			}
		}
	}
}
if (! $sent) {
	# queer things are happening to me
	# $addr[0] should be own domain, so we should have just
	# tried postmaster@@our.domain.  theoretically, we should
	# not get here...
	if ($dflag) {
		print DEBUG "queer things are happening to me\n";
		print DEBUG "Trying postmaster\n";
	}
	&sendbounce("postmaster");
}

# clean up and get out
#
if ($dflag) {
	seek(MSG, 0, 0);
	print DEBUG "\n---\n"; print DEBUG <MSG>;
	close(DEBUG);
}
close(MSG);
unlink("$tmp");
exit(0);




d48 2
a49 2
	local($hdr) = @@_;
	local($addr);
d51 13
a63 10
	if ($hdr =~ /<.*>/) {
		($addr) = $hdr =~ m/<(.*)>/;
		return $addr;
	}
	if ($addr =~ /\s*\(/) {
		($addr) = $hdr =~ m/\s*(.*)\s*\(/;
		return $addr;
	}
	($addr) = $hdr =~ m/\s*(.*)\s*/;
	return $addr;
a65 1

d71 1
a71 1
#	wether the delivery attempt really was successful.
d73 13
a85 7
sub sendbounce {
	local($dest) = @@_;
	local($st);

	open(MAIL, "| /usr/sbin/sendmail -ocn -odi -oeq $dest");
	print MAIL <<EOT;
From: Mail Delivery Subsystem <mail-router\@@$domain>
d87 2
a88 2
Reply-To: nobody\@@$domain
Errors-To: nobody\@@$domain
d92 5
a96 5
The following message was received at $host.$domain for an invalid
recipient.  The sender's address was also invalid.  Since the message
originated at or transited through your mailer, this notification is being
sent to you in the hope that you will determine the real originator and
have them correct their From or Sender address.
d98 1
a98 1
The invalid sender address was: $addr1{"from"}.
d100 1
a100 1
   ----- The following is a double bounce at $host.$domain -----
d103 118
a220 3
	seek(MSG, 0, 0);
	print MAIL <MSG>;
	return close(MAIL);
d222 4
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@
