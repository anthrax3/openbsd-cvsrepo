head	1.20;
access;
symbols
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.4
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.2
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.12
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.10
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.6
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.8
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.4
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.15.0.6
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.4
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.13.0.6
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.4
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	SENDMAIL_8_12_0:1.1.1.3
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	SENDMAIL_8_11_2:1.1.1.2
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	SENDMAIL_8_10_0:1.1.1.1
	SENDMAIL_INC:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2014.09.17.18.49.50;	author matthieu;	state dead;
branches;
next	1.19;
commitid	M7i5giHIoz3DMlTU;

1.19
date	2014.02.07.21.24.59;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2012.12.26.11.44.12;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2011.05.17.15.54.23;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2008.05.04.18.34.04;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.04.13.17.35;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2006.08.13.13.01.48;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.16.00.21.29;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.18.04.08.34;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.24.03.59.25;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.19.01.41.13;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.01.19.59.21;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.26.04.48.54;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.03.17.25.46;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.18.00.49.27;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.14.03.21.39;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.01.17.18.28;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.11.19.02.48;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.15.21.09.01;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.02.19.05.49;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.02.19.05.49;	author millert;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	2001.01.15.20.52.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.11.18.55.51;	author millert;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	2001.05.31.00.27.50;	author miod;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Bye.
@
text
@/*
 * Copyright (c) 1999-2004, 2006, 2008, 2012 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 *
 *	$Sendmail: mfapi.h,v 8.83 2013/11/22 20:51:27 ca Exp $
 */

/*
**  MFAPI.H -- Global definitions for mail filter library and mail filters.
*/

#ifndef _LIBMILTER_MFAPI_H
# define _LIBMILTER_MFAPI_H	1

#ifndef SMFI_VERSION
# if _FFR_MDS_NEGOTIATE
#  define SMFI_VERSION	0x01000002	/* libmilter version number */

   /* first libmilter version that has MDS support */
#  define SMFI_VERSION_MDS	0x01000002
# else /* _FFR_MDS_NEGOTIATE */
#  define SMFI_VERSION	0x01000001	/* libmilter version number */
# endif /* _FFR_MDS_NEGOTIATE */
#endif /* ! SMFI_VERSION */

#define SM_LM_VRS_MAJOR(v)	(((v) & 0x7f000000) >> 24)
#define SM_LM_VRS_MINOR(v)	(((v) & 0x007fff00) >> 8)
#define SM_LM_VRS_PLVL(v)	((v) & 0x0000007f)

# include <sys/types.h>
# include <sys/socket.h>

#include "libmilter/mfdef.h"

# define LIBMILTER_API		extern


/* Only need to export C interface if used by C++ source code */
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#ifndef _SOCK_ADDR
# define _SOCK_ADDR	struct sockaddr
#endif /* ! _SOCK_ADDR */

/*
**  libmilter functions return one of the following to indicate
**  success/failure(/continue):
*/

#define MI_SUCCESS	0
#define MI_FAILURE	(-1)
#if _FFR_WORKERS_POOL
# define MI_CONTINUE	1
#endif /* _FFR_WORKERS_POOL */

/* "forward" declarations */
typedef struct smfi_str SMFICTX;
typedef struct smfi_str *SMFICTX_PTR;

typedef struct smfiDesc smfiDesc_str;
typedef struct smfiDesc	*smfiDesc_ptr;

/*
**  Type which callbacks should return to indicate message status.
**  This may take on one of the SMFIS_* values listed below.
*/

typedef int	sfsistat;

#if defined(__linux__) && defined(__GNUC__) && defined(__cplusplus) && __GNUC_MINOR__ >= 8
# define SM__P(X)	__PMT(X)
#else /* __linux__ && __GNUC__ && __cplusplus && _GNUC_MINOR__ >= 8 */
# define SM__P(X)	__P(X)
#endif /* __linux__ && __GNUC__ && __cplusplus && _GNUC_MINOR__ >= 8 */

/* Some platforms don't define __P -- do it for them here: */
#ifndef __P
# ifdef __STDC__
#  define __P(X) X
# else /* __STDC__ */
#  define __P(X) ()
# endif /* __STDC__ */
#endif /* __P */

#if SM_CONF_STDBOOL_H
# include <stdbool.h>
#else /* SM_CONF_STDBOOL_H */
# ifndef __cplusplus
#  ifndef bool
#   ifndef __bool_true_false_are_defined
typedef int	bool;
#    define false	0
#    define true	1
#    define __bool_true_false_are_defined	1
#   endif /* ! __bool_true_false_are_defined */
#  endif /* bool */
# endif /* ! __cplusplus */
#endif /* SM_CONF_STDBOOL_H */

/*
**  structure describing one milter
*/

struct smfiDesc
{
	char		*xxfi_name;	/* filter name */
	int		xxfi_version;	/* version code -- do not change */
	unsigned long	xxfi_flags;	/* flags */

	/* connection info filter */
	sfsistat	(*xxfi_connect) SM__P((SMFICTX *, char *, _SOCK_ADDR *));

	/* SMTP HELO command filter */
	sfsistat	(*xxfi_helo) SM__P((SMFICTX *, char *));

	/* envelope sender filter */
	sfsistat	(*xxfi_envfrom) SM__P((SMFICTX *, char **));

	/* envelope recipient filter */
	sfsistat	(*xxfi_envrcpt) SM__P((SMFICTX *, char **));

	/* header filter */
	sfsistat	(*xxfi_header) SM__P((SMFICTX *, char *, char *));

	/* end of header */
	sfsistat	(*xxfi_eoh) SM__P((SMFICTX *));

	/* body block */
	sfsistat	(*xxfi_body) SM__P((SMFICTX *, unsigned char *, size_t));

	/* end of message */
	sfsistat	(*xxfi_eom) SM__P((SMFICTX *));

	/* message aborted */
	sfsistat	(*xxfi_abort) SM__P((SMFICTX *));

	/* connection cleanup */
	sfsistat	(*xxfi_close) SM__P((SMFICTX *));

	/* any unrecognized or unimplemented command filter */
	sfsistat	(*xxfi_unknown) SM__P((SMFICTX *, const char *));

	/* SMTP DATA command filter */
	sfsistat	(*xxfi_data) SM__P((SMFICTX *));

	/* negotiation callback */
	sfsistat	(*xxfi_negotiate) SM__P((SMFICTX *,
					unsigned long, unsigned long,
					unsigned long, unsigned long,
					unsigned long *, unsigned long *,
					unsigned long *, unsigned long *));

#if 0
	/* signal handler callback, not yet implemented. */
	int		(*xxfi_signal) SM__P((int));
#endif

};

LIBMILTER_API int smfi_opensocket __P((bool));
LIBMILTER_API int smfi_register __P((struct smfiDesc));
LIBMILTER_API int smfi_main __P((void));
LIBMILTER_API int smfi_setbacklog __P((int));
LIBMILTER_API int smfi_setdbg __P((int));
LIBMILTER_API int smfi_settimeout __P((int));
LIBMILTER_API int smfi_setconn __P((char *));
LIBMILTER_API int smfi_stop __P((void));
LIBMILTER_API size_t smfi_setmaxdatasize __P((size_t));
LIBMILTER_API int smfi_version __P((unsigned int *, unsigned int *, unsigned int *));

/*
**  What the filter might do -- values to be ORed together for
**  smfiDesc.xxfi_flags.
*/

#define SMFIF_NONE	0x00000000L	/* no flags */
#define SMFIF_ADDHDRS	0x00000001L	/* filter may add headers */
#define SMFIF_CHGBODY	0x00000002L	/* filter may replace body */
#define SMFIF_MODBODY	SMFIF_CHGBODY	/* backwards compatible */
#define SMFIF_ADDRCPT	0x00000004L	/* filter may add recipients */
#define SMFIF_DELRCPT	0x00000008L	/* filter may delete recipients */
#define SMFIF_CHGHDRS	0x00000010L	/* filter may change/delete headers */
#define SMFIF_QUARANTINE 0x00000020L	/* filter may quarantine envelope */

/* filter may change "from" (envelope sender) */
#define SMFIF_CHGFROM	0x00000040L
#define SMFIF_ADDRCPT_PAR	0x00000080L	/* add recipients incl. args */

/* filter can send set of symbols (macros) that it wants */
#define SMFIF_SETSYMLIST	0x00000100L


/*
**  Macro "places";
**  Notes:
**  - must be coordinated with libmilter/engine.c and sendmail/milter.c
**  - the order MUST NOT be changed as it would break compatibility between
**	different versions. It's ok to append new entries however
**	(hence the list is not sorted by the SMT protocol steps).
*/

#define SMFIM_NOMACROS	(-1)	/* Do NOT use, internal only */
#define SMFIM_FIRST	0	/* Do NOT use, internal marker only */
#define SMFIM_CONNECT	0	/* connect */
#define SMFIM_HELO	1	/* HELO/EHLO */
#define SMFIM_ENVFROM	2	/* MAIL From */
#define SMFIM_ENVRCPT	3	/* RCPT To */
#define SMFIM_DATA	4	/* DATA */
#define SMFIM_EOM	5	/* end of message (final dot) */
#define SMFIM_EOH	6	/* end of header */
#define SMFIM_LAST	6	/* Do NOT use, internal marker only */

/*
**  Continue processing message/connection.
*/

#define SMFIS_CONTINUE	0

/*
**  Reject the message/connection.
**  No further routines will be called for this message
**  (or connection, if returned from a connection-oriented routine).
*/

#define SMFIS_REJECT	1

/*
**  Accept the message,
**  but silently discard the message.
**  No further routines will be called for this message.
**  This is only meaningful from message-oriented routines.
*/

#define SMFIS_DISCARD	2

/*
**  Accept the message/connection.
**  No further routines will be called for this message
**  (or connection, if returned from a connection-oriented routine;
**  in this case, it causes all messages on this connection
**  to be accepted without filtering).
*/

#define SMFIS_ACCEPT	3

/*
**  Return a temporary failure, i.e.,
**  the corresponding SMTP command will return a 4xx status code.
**  In some cases this may prevent further routines from
**  being called on this message or connection,
**  although in other cases (e.g., when processing an envelope
**  recipient) processing of the message will continue.
*/

#define SMFIS_TEMPFAIL	4

/*
**  Do not send a reply to the MTA
*/

#define SMFIS_NOREPLY	7

/*
**  Skip over rest of same callbacks, e.g., body.
*/

#define SMFIS_SKIP	8

/* xxfi_negotiate: use all existing protocol options/actions */
#define SMFIS_ALL_OPTS	10

#if 0
/*
**  Filter Routine Details
*/

/* connection info filter */
extern sfsistat	xxfi_connect __P((SMFICTX *, char *, _SOCK_ADDR *));

/*
**  xxfi_connect(ctx, hostname, hostaddr) Invoked on each connection
**
**	char *hostname; Host domain name, as determined by a reverse lookup
**		on the host address.
**	_SOCK_ADDR *hostaddr; Host address, as determined by a getpeername
**		call on the SMTP socket.
*/

/* SMTP HELO command filter */
extern sfsistat	xxfi_helo __P((SMFICTX *, char *));

/*
**  xxfi_helo(ctx, helohost) Invoked on SMTP HELO/EHLO command
**
**	char *helohost; Value passed to HELO/EHLO command, which should be
**		the domain name of the sending host (but is, in practice,
**		anything the sending host wants to send).
*/

/* envelope sender filter */
extern sfsistat	xxfi_envfrom __P((SMFICTX *, char **));

/*
**  xxfi_envfrom(ctx, argv) Invoked on envelope from
**
**	char **argv; Null-terminated SMTP command arguments;
**		argv[0] is guaranteed to be the sender address.
**		Later arguments are the ESMTP arguments.
*/

/* envelope recipient filter */
extern sfsistat	xxfi_envrcpt __P((SMFICTX *, char **));

/*
**  xxfi_envrcpt(ctx, argv) Invoked on each envelope recipient
**
**	char **argv; Null-terminated SMTP command arguments;
**		argv[0] is guaranteed to be the recipient address.
**		Later arguments are the ESMTP arguments.
*/

/* unknown command filter */

extern sfsistat	*xxfi_unknown __P((SMFICTX *, const char *));

/*
**  xxfi_unknown(ctx, arg) Invoked when SMTP command is not recognized or not
**  implemented.
**	const char *arg; Null-terminated SMTP command
*/

/* header filter */
extern sfsistat	xxfi_header __P((SMFICTX *, char *, char *));

/*
**  xxfi_header(ctx, headerf, headerv) Invoked on each message header. The
**  content of the header may have folded white space (that is, multiple
**  lines with following white space) included.
**
**	char *headerf; Header field name
**	char *headerv; Header field value
*/

/* end of header */
extern sfsistat	xxfi_eoh __P((SMFICTX *));

/*
**  xxfi_eoh(ctx) Invoked at end of header
*/

/* body block */
extern sfsistat	xxfi_body __P((SMFICTX *, unsigned char *, size_t));

/*
**  xxfi_body(ctx, bodyp, bodylen) Invoked for each body chunk. There may
**  be multiple body chunks passed to the filter. End-of-lines are
**  represented as received from SMTP (normally Carriage-Return/Line-Feed).
**
**	unsigned char *bodyp; Pointer to body data
**	size_t bodylen; Length of body data
*/

/* end of message */
extern sfsistat	xxfi_eom __P((SMFICTX *));

/*
**  xxfi_eom(ctx) Invoked at end of message. This routine can perform
**  special operations such as modifying the message header, body, or
**  envelope.
*/

/* message aborted */
extern sfsistat	xxfi_abort __P((SMFICTX *));

/*
**  xxfi_abort(ctx) Invoked if message is aborted outside of the control of
**  the filter, for example, if the SMTP sender issues an RSET command. If
**  xxfi_abort is called, xxfi_eom will not be called and vice versa.
*/

/* connection cleanup */
extern sfsistat	xxfi_close __P((SMFICTX *));

/*
**  xxfi_close(ctx) Invoked at end of the connection. This is called on
**  close even if the previous mail transaction was aborted.
*/
#endif /* 0 */

/*
**  Additional information is passed in to the vendor filter routines using
**  symbols. Symbols correspond closely to sendmail macros. The symbols
**  defined depend on the context. The value of a symbol is accessed using:
*/

/* Return the value of a symbol. */
LIBMILTER_API char * smfi_getsymval __P((SMFICTX *, char *));

/*
**  Return the value of a symbol.
**
**	SMFICTX *ctx; Opaque context structure
**	char *symname; The name of the symbol to access.
*/

/*
**  Vendor filter routines that want to pass additional information back to
**  the MTA for use in SMTP replies may call smfi_setreply before returning.
*/

LIBMILTER_API int smfi_setreply __P((SMFICTX *, char *, char *, char *));

/*
**  Alternatively, smfi_setmlreply can be called if a multi-line SMTP reply
**  is needed.
*/

LIBMILTER_API int smfi_setmlreply __P((SMFICTX *, const char *, const char *, ...));

/*
**  Set the specific reply code to be used in response to the active
**  command. If not specified, a generic reply code is used.
**
**	SMFICTX *ctx; Opaque context structure
**	char *rcode; The three-digit (RFC 821) SMTP reply code to be
**		returned, e.g., ``551''.
**	char *xcode; The extended (RFC 2034) reply code, e.g., ``5.7.6''.
**	char *message; The text part of the SMTP reply.
*/

/*
**  The xxfi_eom routine is called at the end of a message (essentially,
**  after the final DATA dot). This routine can call some special routines
**  to modify the envelope, header, or body of the message before the
**  message is enqueued. These routines must not be called from any vendor
**  routine other than xxfi_eom.
*/

LIBMILTER_API int smfi_addheader __P((SMFICTX *, char *, char *));

/*
**  Add a header to the message. It is not checked for standards
**  compliance; the mail filter must ensure that no protocols are violated
**  as a result of adding this header.
**
**	SMFICTX *ctx; Opaque context structure
**	char *headerf; Header field name
**	char *headerv; Header field value
*/

LIBMILTER_API int smfi_chgheader __P((SMFICTX *, char *, int, char *));

/*
**  Change/delete a header in the message.  It is not checked for standards
**  compliance; the mail filter must ensure that no protocols are violated
**  as a result of adding this header.
**
**	SMFICTX *ctx; Opaque context structure
**	char *headerf; Header field name
**	int index; The Nth occurence of header field name
**	char *headerv; New header field value (empty for delete header)
*/

LIBMILTER_API int smfi_insheader __P((SMFICTX *, int, char *, char *));

/*
**  Insert a header into the message.  It is not checked for standards
**  compliance; the mail filter must ensure that no protocols are violated
**  as a result of adding this header.
**
**	SMFICTX *ctx; Opaque context structure
**  	int idx; index into the header list where the insertion should happen
**	char *headerh; Header field name
**	char *headerv; Header field value
*/

LIBMILTER_API int smfi_chgfrom __P((SMFICTX *, char *, char *));

/*
**  Modify envelope sender address
**
**	SMFICTX *ctx; Opaque context structure
**	char *mail; New envelope sender address
**	char *args; ESMTP arguments
*/


LIBMILTER_API int smfi_addrcpt __P((SMFICTX *, char *));

/*
**  Add a recipient to the envelope
**
**	SMFICTX *ctx; Opaque context structure
**	char *rcpt; Recipient to be added
*/

LIBMILTER_API int smfi_addrcpt_par __P((SMFICTX *, char *, char *));

/*
**  Add a recipient to the envelope
**
**	SMFICTX *ctx; Opaque context structure
**	char *rcpt; Recipient to be added
**	char *args; ESMTP arguments
*/


LIBMILTER_API int smfi_delrcpt __P((SMFICTX *, char *));

/*
**  Send a "no-op" up to the MTA to tell it we're still alive, so long
**  milter-side operations don't time out.
**
**	SMFICTX *ctx; Opaque context structure
*/

LIBMILTER_API int smfi_progress __P((SMFICTX *));

/*
**  Delete a recipient from the envelope
**
**	SMFICTX *ctx; Opaque context structure
**	char *rcpt; Envelope recipient to be deleted. This should be in
**		exactly the form passed to xxfi_envrcpt or the address may
**		not be deleted.
*/

LIBMILTER_API int smfi_replacebody __P((SMFICTX *, unsigned char *, int));

/*
**  Replace the body of the message. This routine may be called multiple
**  times if the body is longer than convenient to send in one call. End of
**  line should be represented as Carriage-Return/Line Feed.
**
**	char *bodyp; Pointer to block of body information to insert
**	int bodylen; Length of data pointed at by bodyp
*/

/*
**  If the message is aborted (for example, if the SMTP sender sends the
**  envelope but then does a QUIT or RSET before the data is sent),
**  xxfi_abort is called. This can be used to reset state.
*/

/*
**  Quarantine an envelope
**
**	SMFICTX *ctx; Opaque context structure
**	char *reason: explanation
*/

LIBMILTER_API int smfi_quarantine __P((SMFICTX *ctx, char *reason));

/*
**  Connection-private data (specific to an SMTP connection) can be
**  allocated using the smfi_setpriv routine; routines can access private
**  data using smfi_getpriv.
*/

LIBMILTER_API int smfi_setpriv __P((SMFICTX *, void *));

/*
**  Set the private data pointer
**
**	SMFICTX *ctx; Opaque context structure
**	void *privatedata; Pointer to private data area
*/

LIBMILTER_API void *smfi_getpriv __P((SMFICTX *));

/*
**  Get the private data pointer
**
**	SMFICTX *ctx; Opaque context structure
**	void *privatedata; Pointer to private data area
*/

LIBMILTER_API int smfi_setsymlist __P((SMFICTX *, int, char *));

/*
**  Set list of symbols (macros) to receive
**
**	SMFICTX *ctx; Opaque context structure
**	int where; where in the SMTP dialogue should the macros be sent
**	char *macros; list of macros (space separated)
*/

#if _FFR_THREAD_MONITOR
LIBMILTER_API int smfi_set_max_exec_time __P((unsigned int));
#endif /* _FFR_THREAD_MONITOR */

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* ! _LIBMILTER_MFAPI_H */
@


1.19
log
@Update to sendmail 8.14.8.  This touches a lot of files due to the
Sendmail, Inc -> Proofpoint name change.  See RELEASE_NOTES for
actual changes.
@
text
@@


1.18
log
@Update to sendmail 8.14.6
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2004, 2006, 2008, 2012 Sendmail, Inc. and its suppliers.
d10 1
a10 1
 *	$Sendmail: mfapi.h,v 8.82 2012/11/16 20:25:04 ca Exp $
@


1.17
log
@Update to sendmail 8.14.5
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2004, 2006, 2008 Sendmail, Inc. and its suppliers.
d10 1
a10 1
 *	$Sendmail: mfapi.h,v 8.80 2009/11/06 00:57:08 ca Exp $
d99 2
d209 1
@


1.16
log
@Update to sendmail-8.14.3
@
text
@d10 1
a10 1
 *	$Sendmail: mfapi.h,v 8.78 2008/02/27 22:30:34 ca Exp $
d21 8
a28 1
# define SMFI_VERSION	0x01000001	/* libmilter version number */
a172 1
#if _FFR_MAXDATASIZE
a173 1
#endif /* _FFR_MAXDATASIZE */
@


1.15
log
@Update to sendmail-8.14.0.  OK mbalmer@@
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2004, 2006 Sendmail, Inc. and its suppliers.
d10 1
a10 1
 *	$Sendmail: mfapi.h,v 8.77 2006/11/02 02:44:07 ca Exp $
d21 1
a21 1
# define SMFI_VERSION	0x01000000	/* libmilter version number */
@


1.14
log
@Update to sendmail-8.13.8
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2004 Sendmail, Inc. and its suppliers.
d10 1
a10 1
 *	$Sendmail: mfapi.h,v 8.61 2006/05/04 17:02:01 ca Exp $
d21 1
a21 1
# define SMFI_VERSION	2		/* version number */
d24 4
d47 1
a47 1
**  success/failure:
d52 3
a137 1
#if SMFI_VERSION > 2
d139 1
a139 2
	sfsistat	(*xxfi_unknown) SM__P((SMFICTX *, char *));
#endif /* SMFI_VERSION > 2 */
a140 1
#if SMFI_VERSION > 3
d143 13
a155 1
#endif /* SMFI_VERSION > 3 */
d169 1
d185 27
d256 15
d323 1
a323 1
extern sfsistat	*xxfi_unknown __P((SMFICTX *, char *));
d328 1
a328 1
**	char *arg; Null-terminated SMTP command
d476 11
d496 11
d569 21
@


1.13
log
@Update to sendmail-8.13.2
@
text
@d10 1
a10 1
 *	$Sendmail: mfapi.h,v 8.60 2004/08/20 21:24:14 ca Exp $
d137 1
a137 1
	/* any unrecognized or unimplemented command filter */
@


1.12
log
@Update to sendmail-8.13.1
@
text
@d10 1
a10 1
 *	$Sendmail: mfapi.h,v 8.59 2004/07/07 21:41:31 ca Exp $
a427 1
#if _FFR_SMFI_PROGRESS
a435 1
#endif /* _FFR_SMFI_PROGRESS */
@


1.11
log
@Update to sendmail.8.13.0
@
text
@d10 1
a10 1
 *	$Sendmail: mfapi.h,v 8.58 2004/04/29 18:04:48 gshapiro Exp $
d150 3
@


1.10
log
@Update to sendmail 8.12.11.  I've been runninga beta version of this for
some time without problems.  See the RELEASE_NOTES for the change log.
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2002 Sendmail, Inc. and its suppliers.
d10 1
a10 1
 *	$Sendmail: mfapi.h,v 8.44.2.4 2003/10/20 21:51:49 msk Exp $
d20 4
d25 1
d27 1
a27 2
# include <sys/socket.h>
# include "libmilter/mfdef.h"
d32 5
d78 13
d130 10
a141 1
#if _FFR_SMFI_OPENSOCKET
a142 1
#endif /* _FFR_SMFI_OPENSOCKET */
a150 2
#define SMFI_VERSION	2		/* version number */

d163 1
a163 3
#if _FFR_QUARANTINE
# define SMFIF_QUARANTINE 0x00000020L	/* filter may quarantine envelope */
#endif /* _FFR_QUARANTINE */
d259 10
a349 1
#if _FFR_MULTILINE
a355 1
#endif /* _FFR_MULTILINE */
d379 3
a381 4
**  Add a header to the message. This header is not passed to other
**  filters. It is not checked for standards compliance; the mail filter
**  must ensure that no protocols are violated as a result of adding this
**  header.
d401 13
a461 1
#if _FFR_QUARANTINE
a469 1
#endif /* _FFR_QUARANTINE */
d488 3
@


1.9
log
@update to sendmail 8.12.7
@
text
@d10 1
a10 1
 *	$Sendmail: mfapi.h,v 8.44.2.3 2002/12/19 02:10:09 ca Exp $
d111 1
a111 1
LIBMILTER_API int smfi_opensocket __P((void));
@


1.8
log
@sendmail 8.12.5
@
text
@d10 1
a10 1
 *	$Sendmail: mfapi.h,v 8.44 2002/06/04 05:06:40 gshapiro Exp $
d21 1
d445 1
a445 1
#endif /* !_LIBMILTER_MFAPI_H */
@


1.7
log
@Update to sendmail-8.12.4
@
text
@d10 1
a10 1
 *	$Sendmail: mfapi.h,v 8.42 2002/04/30 23:52:23 msk Exp $
@


1.6
log
@update to sendmail 8.12.3
@
text
@d10 1
a10 1
 *	$Sendmail: mfapi.h,v 8.41 2002/03/22 21:36:12 gshapiro Exp $
d109 3
@


1.5
log
@update to sendmail-8.12.2
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d10 1
a10 1
 *	$Sendmail: mfapi.h,v 8.35 2001/10/09 19:05:24 gshapiro Exp $
d20 1
a25 1
# include <sys/types.h>
d111 1
d374 11
@


1.4
log
@Update to sendmail 8.12.1.

A potential security problem has been uncovered in 8.12.0 which might
be exploited locally by malicious users to gain access to the client
mail queue.  However, as long as the MTA accepts local connections,
the possible consequences of this potential local exploit are small.
Notice: some operating systems don't provide a way to completely drop
privileges from a set-group-ID program.  In that case sendmail refuses
to run if unsafe options are given.
@
text
@d10 1
a10 1
 *	$Sendmail: mfapi.h,v 8.32 2001/09/13 20:38:40 ca Exp $
d308 9
@


1.3
log
@merge in sendmail 8.12.0 with BSD Makefiles and mdoc man pages
@
text
@d10 1
a10 1
 *	$Sendmail: mfapi.h,v 8.28 2001/07/19 21:20:29 gshapiro Exp $
a52 4
/*
**  structure describing one milter
*/

d59 13
d130 3
d391 10
@


1.2
log
@sendmail 8.11.2 with BSD Makefiles
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2000 Sendmail, Inc. and its suppliers.
d10 1
a10 1
 *	$Sendmail: mfapi.h,v 8.13.4.12 2000/09/09 02:11:48 ca Exp $
d20 3
a24 1

a27 1
# include <sys/socket.h>
a45 18
#define SMFI_VERSION	2		/* version number */

/*
**  What the filter might do -- values to be ORed together for
**  smfiDesc.xxfi_flags.
*/

#define SMFIF_ADDHDRS	0x00000001L	/* filter may add headers */
#define SMFIF_CHGBODY	0x00000002L	/* filter may replace body */
#define SMFIF_MODBODY	SMFIF_CHGBODY	/* backwards compatible */
#define SMFIF_ADDRCPT	0x00000004L	/* filter may add recipients */
#define SMFIF_DELRCPT	0x00000008L	/* filter may delete recipients */
#define SMFIF_CHGHDRS	0x00000010L	/* filter may change/delete headers */

#define SMFI_V1_ACTS	0x0000000FL	/* The actions of V1 filter */
#define SMFI_V2_ACTS	0x0000001FL	/* The actions of V2 filter */
#define SMFI_CURR_ACTS	SMFI_V2_ACTS	/* The current version */

a62 9
/* Some platforms don't define __P -- do it for them here: */
#ifndef __P
# ifdef __STDC__
#  define __P(X) X
# else /* __STDC__ */
#  define __P(X) ()
# endif /* __STDC__ */
#endif /* __P */

d67 1
a67 1
	u_long		xxfi_flags;	/* flags */
d88 1
a88 1
	sfsistat	(*xxfi_body) SM__P((SMFICTX *, u_char *, size_t));
d107 15
d236 1
a236 1
extern sfsistat	xxfi_body __P((SMFICTX *, u_char *, size_t));
d243 1
a243 1
**	u_char *bodyp; Pointer to body data
d362 1
a362 1
LIBMILTER_API int smfi_replacebody __P((SMFICTX *, u_char *, int));
@


1.1
log
@Initial revision
@
text
@d10 1
a10 1
 *	$Sendmail: mfapi.h,v 8.13 2000/02/26 19:13:36 gshapiro Exp $
d20 10
d31 2
a32 1
**  Access common MTA/libmilter constants
d35 11
a45 1
# include "libmilter/milter.h"
d48 2
a49 2
**  Currently this is a C-fied version of ~eric/public_html/mfapi.html
**  It does not (yet) conform with the coding standard...
d52 11
d64 2
a65 1
**  status codes
d68 64
a131 1
/* XXX maybe use enum? */
d174 1
a176 97
/* type to store return value */
typedef int	sfsistat;

/* for now ... */
#if SOCKADDRHACK
# ifndef _SOCK_ADDR
#  define _SOCK_ADDR	struct sockaddr_in
# endif /* !_SOCK_ADDR */
#else /* SOCKADDRHACK */
# define NOT_SENDMAIL	1
# include "sendmail.h"
# define _SOCK_ADDR	SOCKADDR
#endif /* SOCKADDRHACK */

#include <pthread.h>

#ifndef MI_SUCCESS
# define MI_SUCCESS	0
#endif /* MI_SUCCESS */
#ifndef MI_FAILURE
# define MI_FAILURE	(-1)
#endif /* MI_FAILURE */

/* "forward" declarations */
typedef struct smfi_str SMFICTX;
typedef struct smfi_str *SMFICTX_PTR;

typedef struct smfiDesc smfiDesc_str;
typedef struct smfiDesc	* smfiDesc_ptr;

# define MAX_MACROS_ENTRIES	4	/* max size of macro pointer array */

/*
**  context for milter
**  implementation hint:
**  macros are stored in mac_buf[] as sequence of:
**  macro_name \0 macro_value
**  (just as read from the MTA)
**  mac_ptr is a list of pointers into mac_buf to the beginning of each
**  entry, i.e., macro_name, macro_value, ...
*/

struct smfi_str
{
	pthread_t	ctx_id;		/* thread id */
	int		ctx_fd;		/* filedescriptor */
	int		ctx_dbg;	/* debug level */
	time_t		ctx_timeout;	/* timeout */
	int		ctx_state;	/* state */
	smfiDesc_ptr	ctx_smfi;	/* filter description */
	char		**ctx_mac_ptr[MAX_MACROS_ENTRIES];
	char		*ctx_mac_buf[MAX_MACROS_ENTRIES];
	char		*ctx_reply;	/* reply code */
	void		*ctx_privdata;	/* private data */
};

/*
**  structure describing one milter
*/

struct smfiDesc
{
	char		*xxfi_name;	/* filter name */
	int		xxfi_version;	/* version code -- do not change */
	u_long		xxfi_flags;	/* flags */

	/* connection info filter */
	sfsistat	(*xxfi_connect) __P((SMFICTX *, char *, _SOCK_ADDR *));

	/* SMTP HELO command filter */
	sfsistat	(*xxfi_helo) __P((SMFICTX *, char *));

	/* envelope sender filter */
	sfsistat	(*xxfi_envfrom) __P((SMFICTX *, char **));

	/* envelope recipient filter */
	sfsistat	(*xxfi_envrcpt) __P((SMFICTX *, char **));

	/* header filter */
	sfsistat	(*xxfi_header) __P((SMFICTX *, char *, char *));

	/* end of header */
	sfsistat	(*xxfi_eoh) __P((SMFICTX *));

	/* body block */
	sfsistat	(*xxfi_body) __P((SMFICTX *, u_char *, size_t));

	/* end of message */
	sfsistat	(*xxfi_eom) __P((SMFICTX *));

	/* message aborted */
	sfsistat	(*xxfi_abort) __P((SMFICTX *));

	/* connection cleanup */
	sfsistat	(*xxfi_close) __P((SMFICTX *));
};

a177 22
simple example what a filter program should do:

int
main(argc, argv)
	int argc;
	char **argv;
{
	struct smfiDesc	XxFilterDesc;

	/* fill in elements */
	smfi_register(XxFilterDesc);
	smfi_main();
	/* NOTREACHED */
}
#endif /* 0 */

extern int smfi_register __P((smfiDesc_str));
extern int smfi_main __P((void));
extern int smfi_setdbg __P((int));
extern int smfi_settimeout __P((int));
extern int smfi_setconn __P((char *));

a181 1
#if 0
a244 1
#endif /* 0 */
d283 1
a283 1

d292 1
a292 1
extern char * smfi_getsymval __P((SMFICTX *, char *));
d306 1
a306 1
extern int smfi_setreply __P((SMFICTX *, char *, char *, char *));
d327 1
a327 1
extern int smfi_addheader __P((SMFICTX *, char *, char *));
d340 14
a353 1
extern int smfi_addrcpt __P((SMFICTX *, char *));
d362 1
a362 1
extern int smfi_delrcpt __P((SMFICTX *, char *));
d373 1
a373 1
extern int smfi_replacebody __P((SMFICTX *, u_char *, int));
d397 1
a397 1
extern int smfi_setpriv __P((SMFICTX *, void *));
d406 2
a407 1
extern void *smfi_getpriv __P((SMFICTX *));
@


1.1.1.1
log
@stock sendmail 8.10.0 with $Id -> $Sendmail
@
text
@@


1.1.1.1.4.1
log
@Pull in patch from current:
Errata(028):
The signal handlers in sendmail contain code that is unsafe in the
context of a signal handler.  This leads to potentially serious race
conditions.  At the moment this is a theoretical attack only and can
only be exploited on the local host (if at all).
Fix(millert):
Update to sendmail 8.11.4:
8.11.4 revamps signal handling within the MTA in order to reduce
the likelihood of a race condition that can lead to heap
corruption as described in Michal Zalewski's advisory.  The
problems discussed in the advisory are not currently known to
be exploitable but we recommend upgrading to 8.11.4 in case a
method is found to exploit the signal handling race condition.
8.11.4 also fixes other bugs found since the release of 8.11.3.

See the RELEASE_NOTES file for more details.
@
text
@d10 1
a10 1
 *	$Sendmail: mfapi.h,v 8.13.4.12 2000/09/09 02:11:48 ca Exp $
d20 3
a22 1
# define LIBMILTER_API		extern
d24 6
d31 3
a33 1
# include <sys/types.h>
d35 1
a35 4
#ifndef _SOCK_ADDR
# include <sys/socket.h>
# define _SOCK_ADDR	struct sockaddr
#endif /* ! _SOCK_ADDR */
d38 1
a38 2
**  libmilter functions return one of the following to indicate
**  success/failure:
d41 7
a47 2
#define MI_SUCCESS	0
#define MI_FAILURE	(-1)
d49 10
a58 3
/* "forward" declarations */
typedef struct smfi_str SMFICTX;
typedef struct smfi_str *SMFICTX_PTR;
d60 7
a66 2
typedef struct smfiDesc smfiDesc_str;
typedef struct smfiDesc	*smfiDesc_ptr;
d68 1
a68 1
#define SMFI_VERSION	2		/* version number */
d71 6
a76 2
**  What the filter might do -- values to be ORed together for
**  smfiDesc.xxfi_flags.
d78 28
d107 2
a108 6
#define SMFIF_ADDHDRS	0x00000001L	/* filter may add headers */
#define SMFIF_CHGBODY	0x00000002L	/* filter may replace body */
#define SMFIF_MODBODY	SMFIF_CHGBODY	/* backwards compatible */
#define SMFIF_ADDRCPT	0x00000004L	/* filter may add recipients */
#define SMFIF_DELRCPT	0x00000008L	/* filter may delete recipients */
#define SMFIF_CHGHDRS	0x00000010L	/* filter may change/delete headers */
d110 1
a110 3
#define SMFI_V1_ACTS	0x0000000FL	/* The actions of V1 filter */
#define SMFI_V2_ACTS	0x0000001FL	/* The actions of V2 filter */
#define SMFI_CURR_ACTS	SMFI_V2_ACTS	/* The current version */
d113 7
a119 2
**  Type which callbacks should return to indicate message status.
**  This may take on one of the SMFIS_* values listed below.
d122 13
a134 1
typedef int	sfsistat;
a139 15
#if defined(__linux__) && defined(__GNUC__) && defined(__cplusplus) && __GNUC_MINOR__ >= 8
# define SM__P(X)	__PMT(X)
#else /* __linux__ && __GNUC__ && __cplusplus && _GNUC_MINOR__ >= 8 */
# define SM__P(X)	__P(X)
#endif /* __linux__ && __GNUC__ && __cplusplus && _GNUC_MINOR__ >= 8 */

/* Some platforms don't define __P -- do it for them here: */
#ifndef __P
# ifdef __STDC__
#  define __P(X) X
# else /* __STDC__ */
#  define __P(X) ()
# endif /* __STDC__ */
#endif /* __P */

d147 1
a147 1
	sfsistat	(*xxfi_connect) SM__P((SMFICTX *, char *, _SOCK_ADDR *));
d150 1
a150 1
	sfsistat	(*xxfi_helo) SM__P((SMFICTX *, char *));
d153 1
a153 1
	sfsistat	(*xxfi_envfrom) SM__P((SMFICTX *, char **));
d156 1
a156 1
	sfsistat	(*xxfi_envrcpt) SM__P((SMFICTX *, char **));
d159 1
a159 1
	sfsistat	(*xxfi_header) SM__P((SMFICTX *, char *, char *));
d162 1
a162 1
	sfsistat	(*xxfi_eoh) SM__P((SMFICTX *));
d165 1
a165 1
	sfsistat	(*xxfi_body) SM__P((SMFICTX *, u_char *, size_t));
d168 1
a168 1
	sfsistat	(*xxfi_eom) SM__P((SMFICTX *));
d171 1
a171 1
	sfsistat	(*xxfi_abort) SM__P((SMFICTX *));
d174 1
a174 1
	sfsistat	(*xxfi_close) SM__P((SMFICTX *));
d177 2
a178 6
LIBMILTER_API int smfi_register __P((struct smfiDesc));
LIBMILTER_API int smfi_main __P((void));
LIBMILTER_API int smfi_setdbg __P((int));
LIBMILTER_API int smfi_settimeout __P((int));
LIBMILTER_API int smfi_setconn __P((char *));
LIBMILTER_API int smfi_stop __P((void));
d180 6
a185 3
/*
**  Continue processing message/connection.
*/
d187 6
a192 7
#define SMFIS_CONTINUE	0

/*
**  Reject the message/connection.
**  No further routines will be called for this message
**  (or connection, if returned from a connection-oriented routine).
*/
d194 5
a198 1
#define SMFIS_REJECT	1
d201 1
a201 14
**  Accept the message,
**  but silently discard the message.
**  No further routines will be called for this message.
**  This is only meaningful from message-oriented routines.
*/

#define SMFIS_DISCARD	2

/*
**  Accept the message/connection.
**  No further routines will be called for this message
**  (or connection, if returned from a connection-oriented routine;
**  in this case, it causes all messages on this connection
**  to be accepted without filtering).
a203 13
#define SMFIS_ACCEPT	3

/*
**  Return a temporary failure, i.e.,
**  the corresponding SMTP command will return a 4xx status code.
**  In some cases this may prevent further routines from
**  being called on this message or connection,
**  although in other cases (e.g., when processing an envelope
**  recipient) processing of the message will continue.
*/

#define SMFIS_TEMPFAIL	4

a204 4
/*
**  Filter Routine Details
*/

d268 1
d307 1
a307 1
#endif /* 0 */
d316 1
a316 1
LIBMILTER_API char * smfi_getsymval __P((SMFICTX *, char *));
d330 1
a330 1
LIBMILTER_API int smfi_setreply __P((SMFICTX *, char *, char *, char *));
d351 1
a351 1
LIBMILTER_API int smfi_addheader __P((SMFICTX *, char *, char *));
d364 1
a364 14
LIBMILTER_API int smfi_chgheader __P((SMFICTX *, char *, int, char *));

/*
**  Change/delete a header in the message.  It is not checked for standards
**  compliance; the mail filter must ensure that no protocols are violated
**  as a result of adding this header.
**
**	SMFICTX *ctx; Opaque context structure
**	char *headerf; Header field name
**	int index; The Nth occurence of header field name
**	char *headerv; New header field value (empty for delete header)
*/

LIBMILTER_API int smfi_addrcpt __P((SMFICTX *, char *));
d373 1
a373 1
LIBMILTER_API int smfi_delrcpt __P((SMFICTX *, char *));
d384 1
a384 1
LIBMILTER_API int smfi_replacebody __P((SMFICTX *, u_char *, int));
d408 1
a408 1
LIBMILTER_API int smfi_setpriv __P((SMFICTX *, void *));
d417 1
a417 2
LIBMILTER_API void *smfi_getpriv __P((SMFICTX *));

@


1.1.1.2
log
@sendmail 8.11.2
@
text
@d10 1
a10 1
 *	$Id: mfapi.h,v 8.13.4.12 2000/09/09 02:11:48 ca Exp $
d20 3
a22 1
# define LIBMILTER_API		extern
d24 6
d31 3
a33 1
# include <sys/types.h>
d35 1
a35 4
#ifndef _SOCK_ADDR
# include <sys/socket.h>
# define _SOCK_ADDR	struct sockaddr
#endif /* ! _SOCK_ADDR */
d38 1
a38 2
**  libmilter functions return one of the following to indicate
**  success/failure:
d41 7
a47 2
#define MI_SUCCESS	0
#define MI_FAILURE	(-1)
d49 10
a58 3
/* "forward" declarations */
typedef struct smfi_str SMFICTX;
typedef struct smfi_str *SMFICTX_PTR;
d60 7
a66 2
typedef struct smfiDesc smfiDesc_str;
typedef struct smfiDesc	*smfiDesc_ptr;
d68 1
a68 1
#define SMFI_VERSION	2		/* version number */
d71 6
a76 2
**  What the filter might do -- values to be ORed together for
**  smfiDesc.xxfi_flags.
d78 28
d107 2
a108 6
#define SMFIF_ADDHDRS	0x00000001L	/* filter may add headers */
#define SMFIF_CHGBODY	0x00000002L	/* filter may replace body */
#define SMFIF_MODBODY	SMFIF_CHGBODY	/* backwards compatible */
#define SMFIF_ADDRCPT	0x00000004L	/* filter may add recipients */
#define SMFIF_DELRCPT	0x00000008L	/* filter may delete recipients */
#define SMFIF_CHGHDRS	0x00000010L	/* filter may change/delete headers */
d110 1
a110 3
#define SMFI_V1_ACTS	0x0000000FL	/* The actions of V1 filter */
#define SMFI_V2_ACTS	0x0000001FL	/* The actions of V2 filter */
#define SMFI_CURR_ACTS	SMFI_V2_ACTS	/* The current version */
d113 7
a119 2
**  Type which callbacks should return to indicate message status.
**  This may take on one of the SMFIS_* values listed below.
d122 13
a134 1
typedef int	sfsistat;
a139 15
#if defined(__linux__) && defined(__GNUC__) && defined(__cplusplus) && __GNUC_MINOR__ >= 8
# define SM__P(X)	__PMT(X)
#else /* __linux__ && __GNUC__ && __cplusplus && _GNUC_MINOR__ >= 8 */
# define SM__P(X)	__P(X)
#endif /* __linux__ && __GNUC__ && __cplusplus && _GNUC_MINOR__ >= 8 */

/* Some platforms don't define __P -- do it for them here: */
#ifndef __P
# ifdef __STDC__
#  define __P(X) X
# else /* __STDC__ */
#  define __P(X) ()
# endif /* __STDC__ */
#endif /* __P */

d147 1
a147 1
	sfsistat	(*xxfi_connect) SM__P((SMFICTX *, char *, _SOCK_ADDR *));
d150 1
a150 1
	sfsistat	(*xxfi_helo) SM__P((SMFICTX *, char *));
d153 1
a153 1
	sfsistat	(*xxfi_envfrom) SM__P((SMFICTX *, char **));
d156 1
a156 1
	sfsistat	(*xxfi_envrcpt) SM__P((SMFICTX *, char **));
d159 1
a159 1
	sfsistat	(*xxfi_header) SM__P((SMFICTX *, char *, char *));
d162 1
a162 1
	sfsistat	(*xxfi_eoh) SM__P((SMFICTX *));
d165 1
a165 1
	sfsistat	(*xxfi_body) SM__P((SMFICTX *, u_char *, size_t));
d168 1
a168 1
	sfsistat	(*xxfi_eom) SM__P((SMFICTX *));
d171 1
a171 1
	sfsistat	(*xxfi_abort) SM__P((SMFICTX *));
d174 1
a174 1
	sfsistat	(*xxfi_close) SM__P((SMFICTX *));
d177 2
a178 6
LIBMILTER_API int smfi_register __P((struct smfiDesc));
LIBMILTER_API int smfi_main __P((void));
LIBMILTER_API int smfi_setdbg __P((int));
LIBMILTER_API int smfi_settimeout __P((int));
LIBMILTER_API int smfi_setconn __P((char *));
LIBMILTER_API int smfi_stop __P((void));
d180 6
a185 3
/*
**  Continue processing message/connection.
*/
d187 6
a192 7
#define SMFIS_CONTINUE	0

/*
**  Reject the message/connection.
**  No further routines will be called for this message
**  (or connection, if returned from a connection-oriented routine).
*/
d194 5
a198 1
#define SMFIS_REJECT	1
d201 1
a201 14
**  Accept the message,
**  but silently discard the message.
**  No further routines will be called for this message.
**  This is only meaningful from message-oriented routines.
*/

#define SMFIS_DISCARD	2

/*
**  Accept the message/connection.
**  No further routines will be called for this message
**  (or connection, if returned from a connection-oriented routine;
**  in this case, it causes all messages on this connection
**  to be accepted without filtering).
a203 13
#define SMFIS_ACCEPT	3

/*
**  Return a temporary failure, i.e.,
**  the corresponding SMTP command will return a 4xx status code.
**  In some cases this may prevent further routines from
**  being called on this message or connection,
**  although in other cases (e.g., when processing an envelope
**  recipient) processing of the message will continue.
*/

#define SMFIS_TEMPFAIL	4

a204 4
/*
**  Filter Routine Details
*/

d268 1
d307 1
a307 1
#endif /* 0 */
d316 1
a316 1
LIBMILTER_API char * smfi_getsymval __P((SMFICTX *, char *));
d330 1
a330 1
LIBMILTER_API int smfi_setreply __P((SMFICTX *, char *, char *, char *));
d351 1
a351 1
LIBMILTER_API int smfi_addheader __P((SMFICTX *, char *, char *));
d364 1
a364 14
LIBMILTER_API int smfi_chgheader __P((SMFICTX *, char *, int, char *));

/*
**  Change/delete a header in the message.  It is not checked for standards
**  compliance; the mail filter must ensure that no protocols are violated
**  as a result of adding this header.
**
**	SMFICTX *ctx; Opaque context structure
**	char *headerf; Header field name
**	int index; The Nth occurence of header field name
**	char *headerv; New header field value (empty for delete header)
*/

LIBMILTER_API int smfi_addrcpt __P((SMFICTX *, char *));
d373 1
a373 1
LIBMILTER_API int smfi_delrcpt __P((SMFICTX *, char *));
d384 1
a384 1
LIBMILTER_API int smfi_replacebody __P((SMFICTX *, u_char *, int));
d408 1
a408 1
LIBMILTER_API int smfi_setpriv __P((SMFICTX *, void *));
d417 1
a417 2
LIBMILTER_API void *smfi_getpriv __P((SMFICTX *));

@


1.1.1.3
log
@sendmail 8.12.0 with $Id tags converted to $Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.
d10 1
a10 1
 *	$Sendmail: mfapi.h,v 8.28 2001/07/19 21:20:29 gshapiro Exp $
d20 1
a20 2
# include <sys/socket.h>
# include "libmilter/mfdef.h"
a21 1
# define LIBMILTER_API		extern
d26 1
d45 18
d80 9
d93 1
a93 1
	unsigned long	xxfi_flags;	/* flags */
d114 1
a114 1
	sfsistat	(*xxfi_body) SM__P((SMFICTX *, unsigned char *, size_t));
a132 15
#define SMFI_VERSION	2		/* version number */

/*
**  What the filter might do -- values to be ORed together for
**  smfiDesc.xxfi_flags.
*/

#define SMFIF_NONE	0x00000000L	/* no flags */
#define SMFIF_ADDHDRS	0x00000001L	/* filter may add headers */
#define SMFIF_CHGBODY	0x00000002L	/* filter may replace body */
#define SMFIF_MODBODY	SMFIF_CHGBODY	/* backwards compatible */
#define SMFIF_ADDRCPT	0x00000004L	/* filter may add recipients */
#define SMFIF_DELRCPT	0x00000008L	/* filter may delete recipients */
#define SMFIF_CHGHDRS	0x00000010L	/* filter may change/delete headers */

d247 1
a247 1
extern sfsistat	xxfi_body __P((SMFICTX *, unsigned char *, size_t));
d254 1
a254 1
**	unsigned char *bodyp; Pointer to body data
d373 1
a373 1
LIBMILTER_API int smfi_replacebody __P((SMFICTX *, unsigned char *, int));
@


