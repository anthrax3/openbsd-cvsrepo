head	1.23;
access;
symbols
	OPENBSD_6_2:1.23.0.2
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.22.0.4
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.21.0.2
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.17.0.20
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.16
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.14
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.12
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.10
	OPENBSD_5_0:1.17.0.8
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.16
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.12
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.10
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.8
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.6
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.4
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.15.0.8
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.6
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.4
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.7.0.8
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.6
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2017.06.23.12.56.25;	author fcambus;	state Exp;
branches;
next	1.22;
commitid	WZ507x8mgOPk64yX;

1.22
date	2016.12.21.18.28.19;	author krw;	state Exp;
branches;
next	1.21;
commitid	oYCdOFDSTj30Ow7X;

1.21
date	2016.03.08.10.48.39;	author mestre;	state Exp;
branches;
next	1.20;
commitid	MVW94yecJ4ENUFco;

1.20
date	2015.08.22.14.47.40;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	vWCbqNWL9DL2UkGT;

1.19
date	2014.12.08.21.56.27;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	fyZyamgf42dtoHOi;

1.18
date	2014.07.13.19.40.57;	author tedu;	state Exp;
branches;
next	1.17;
commitid	ZHDTWGMnFWPBa5HW;

1.17
date	2009.10.27.23.59.23;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.27.00.10.14;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.09.15.59.26;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.09.25.22.31.43;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.03.03.01.37;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.07.18.19.37;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.18.06.38.42;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.06.22.59.05;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.22.22.32.39;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.17.20.14.57;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	98.11.29.19.45.10;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	98.09.12.01.54.42;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	98.08.31.02.29.41;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	97.07.31.19.27.19;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.07.23.20.04.41;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	97.01.11.10.01.28;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.36;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.36;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Remove unused confirm() and datime() functions.

Those functions are unused and have been compiled out since 1998,
it's time to let them go.

OK sthen@@, tom@@, mestre@@
@
text
@/*	$OpenBSD: io.c,v 1.22 2016/12/21 18:28:19 krw Exp $	*/
/*	$NetBSD: io.c,v 1.3 1995/04/24 12:21:37 cgd Exp $	*/

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * The game adventure was originally written in Fortran by Will Crowther
 * and Don Woods.  It was later translated to C and enhanced by Jim
 * Gillogly.  This code is derived from software contributed to Berkeley
 * by Jim Gillogly at The Rand Corporation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*	Re-coding of advent in C: file i/o and user i/o			*/

#include <err.h>
#include <stdio.h>
#include <stdlib.h>

#include "extern.h"
#include "hdr.h"

/* Get command from user. No prompt, usually.	*/
void
getin(char *wrd1, size_t siz1, char *wrd2, size_t siz2)	
{
	char   *s, *slast;
	int     ch, first;

	*wrd2 = 0;		/* in case it isn't set here	*/
	for (s = wrd1, first = 1, slast = wrd1 + siz1 - 1;;) {
		if ((ch = getchar()) >= 'A' && ch <= 'Z')
			ch = ch - ('A' - 'a');
		/* convert to upper case	*/
		switch (ch) {	/* start reading from user	*/
		case '\n':
			*s = 0;
			return;
		case ' ':
			if (s == wrd1 || s == wrd2)	/* initial blank  */
				continue;
			*s = 0;
			if (first) {		/* finished 1st wd; start 2nd */
				first = 0;
				s = wrd2;
				slast = wrd2 + siz2 - 1;
				break;
			} else {		/* finished 2nd word */
				FLUSHLINE;
				*s = 0;
				return;
			}
		case EOF:
			printf("user closed input stream, quitting...\n");
			exit(0);
		default:
			if (s == slast) {	/* string too long */
				printf("Give me a break!!\n");
				*wrd1 = *wrd2 = 0;
				FLUSHLINE;
				return;
			}
			*s++ = ch;
		}
	}
}

int
yes(int x, int y, int z)	/* confirm with rspeak		*/
{
	int     result;
	int     ch;

	for (;;) {
		rspeak(x);	/* tell him what we want*/
		if ((ch = getchar())=='y')
			result = TRUE;
		else if (ch=='n')
			result = FALSE;
		else if (ch == EOF) {
			printf("user closed input stream, quitting...\n");
			exit(0);
		}
		if (ch != '\n')
			FLUSHLINE;
		if (ch == 'y' || ch == 'n')
			break;
		printf("Please answer the question.\n");
	}
	if (result == TRUE)
		rspeak(y);
	if (result == FALSE)
		rspeak(z);
	return (result);
}

int
yesm(int x, int y, int z)	/* confirm with mspeak		*/
{
	int     result;
	int    ch;

	for (;;) {
		mspeak(x);	/* tell him what we want	*/
		if ((ch = getchar()) == 'y')
			result = TRUE;
		else if (ch == 'n')
			result = FALSE;
		else if (ch == EOF) {
			printf("user closed input stream, quitting...\n");
			exit(0);
		}
		if (ch != '\n')
			FLUSHLINE;
		if (ch == 'y' || ch == 'n')
			break;
		printf("Please answer the question.\n");
	}
	if (result == TRUE)
		mspeak(y);
	if (result == FALSE)
		mspeak(z);
	return (result);
}

/* FILE *inbuf,*outbuf; */

char   *inptr;			/* Pointer into virtual disk	*/

int     outsw = 0;		/* putting stuff to data file?	*/

const char iotape[] = "Ax3F'\003tt$8h\315qer*h\017nGKrX\207:!l";
const char *tape = iotape;	/* pointer to obfuscation tape	*/

int
next(void)			/* next virtual char, bump adr	*/
{
	int ch;

	ch=(*inptr ^ random()) & 0xFF;	/* Deobfuscate input data	*/
	if (outsw) {			/* putting data in tmp file	*/
		if (*tape == 0)
			tape = iotape;	/* rewind obfuscation tape	*/
		*inptr = ch ^ *tape++;	/* re-obfuscate and replace value */
	}
	inptr++;
	return (ch);
}

char	breakch;		/* tell which char ended rnum	*/

void
rdata(void)			/* "read" data from virtual file */
{
	int     sect;
	char    ch;

	inptr = data_file;	/* Pointer to virtual data file */

	clsses = 1;
	for (;;) {		/* read data sections		*/
		sect = next() - '0';	/* 1st digit of section number	*/
#ifdef VERBOSE
		printf("Section %c", sect + '0');
#endif
		if ((ch = next()) != LF) {	/* is there a second digit?	*/
			FLUSHLF;
#ifdef VERBOSE
			putchar(ch);
#endif
			sect = 10 * sect + ch - '0';
		}
#ifdef VERBOSE
		putchar('\n');
#endif
		switch (sect) {
		case 0:		/* finished reading database	*/
			return;
		case 1:		/* long form descriptions	*/
			rdesc(1);
			break;
		case 2:		/* short form descriptions	*/
			rdesc(2);
			break;
		case 3:		/* travel table			*/
			rtrav();
			break;
		case 4:		/* vocabulary			*/
			rvoc();
			break;
		case 5:		/* object descriptions		*/
			rdesc(5);
			break;
		case 6:		/* arbitrary messages		*/
			rdesc(6);
			break;
		case 7:		/* object locations		*/
			rlocs();
			break;
		case 8:		/* action defaults		*/
			rdflt();
			break;
		case 9:		/* liquid assets		*/
			rliq();
			break;
		case 10:	/* class messages		*/
			rdesc(10);
			break;
		case 11:	/* hints			*/
			rhints();
			break;
		case 12:	/* magic messages		*/
			rdesc(12);
			break;
		default:
			printf("Invalid data section number: %d\n", sect);
			for (;;)
				putchar(next());
		}
		if (breakch != LF)	/* routines return after "-1"	*/
			FLUSHLF;
	}
}

char	nbf[12];


int
rnum(void)			/* read initial location num	*/
{
	char	*s;

	tape = iotape;		/* restart obfuscation tape	*/
	for (s = nbf, *s = 0;; s++)
		if ((*s = next()) == TAB || *s == '\n' || *s == LF)
			break;
	breakch = *s;		/* save char for rtrav()	*/
	*s = 0;			/* got the number as ascii	*/
	if (nbf[0] == '-')
		return (-1);	/* end of data			*/
	return (atoi(nbf));	/* convert it to integer	*/
}

char	*seekhere;

void
rdesc(int sect)			/* read description-format msgs */
{
	int     locc;
	char   *seekstart, *maystart;

	seekhere = inptr;	/* Where are we in virtual file?*/
	outsw = 1;		/* these msgs go into tmp file	*/
	for (oldloc = -1, seekstart = seekhere;;) {
		maystart = inptr;	/* maybe starting new entry	*/
		if ((locc = rnum()) != oldloc && oldloc >= 0  /* finished msg */
		    && !(sect == 5 && (locc == 0 || locc >= 100)))/* unless sect 5*/
		{
			switch (sect) {	/* now put it into right table  */
			case 1:	/* long descriptions		*/
				ltext[oldloc].seekadr = seekhere;
				ltext[oldloc].txtlen = maystart - seekstart;
				break;
			case 2:	/* short descriptions		*/
				stext[oldloc].seekadr = seekhere;
				stext[oldloc].txtlen = maystart - seekstart;
				break;
			case 5:	/* object descriptions		*/
				ptext[oldloc].seekadr = seekhere;
				ptext[oldloc].txtlen = maystart - seekstart;
				break;
			case 6:	/* random messages		*/
				if (oldloc >= RTXSIZ)
					errx(1, "Too many random msgs");
				rtext[oldloc].seekadr = seekhere;
				rtext[oldloc].txtlen = maystart - seekstart;
				break;
			case 10:/* class messages		*/
				ctext[clsses].seekadr = seekhere;
				ctext[clsses].txtlen = maystart - seekstart;
				cval[clsses++] = oldloc;
				break;
			case 12:/* magic messages		*/
				if (oldloc >= MAGSIZ)
					errx(1, "Too many magic msgs");
				mtext[oldloc].seekadr = seekhere;
				mtext[oldloc].txtlen = maystart - seekstart;
				break;
			default:
				errx(1, "rdesc called with bad section");
			}
			seekhere += maystart - seekstart;
		}
		if (locc < 0) {
			outsw = 0;	/* turn off output		*/
			seekhere += 3;	/* -1<delimiter>		*/
			return;
		}
		if (sect != 5 || (locc > 0 && locc < 100)) {
			if (oldloc != locc)/* starting a new message	*/
				seekstart = maystart;
			oldloc = locc;
		}
		FLUSHLF;		/* scan the line		*/
	}
}


void
rtrav(void)				/* read travel table		*/
{
	int     locc;
	struct travlist *t;
	char   *s;
	char    buf[12];
	int     len, m, n, entries;

	for (oldloc = -1;;) {		/* get another line		*/
		if ((locc = rnum()) != oldloc && oldloc >= 0) { /* end of entry */
			t->next = NULL;	/* terminate the old entry	*/
		/*	printf("%d:%d entries\n", oldloc, entries);	*/
		/*	twrite(oldloc);					*/
		}
		if (locc == -1)
			return;
		if (locc != oldloc) {	/* getting a new entry		*/
			t = travel[locc] = calloc(1, sizeof(*t));
			if (t == NULL)
				err(1, NULL);
		/*	printf("New travel list for %d\n", locc);	*/
			entries = 0;
			oldloc = locc;
		}
		for (s = buf; ; s++)	/* get the newloc number /ASCII */
			if ((*s = next()) == TAB || *s == LF)
				break;
		*s = 0;
		len = length(buf) - 1;	/* quad long number handling	*/
	/*	printf("Newloc: %s (%d chars)\n", buf, len);		*/
		if (len < 4) {		/* no "m" conditions		*/
			m = 0;
			n = atoi(buf);	/* newloc mod 1000 = newloc	*/
		} else {		/* a long integer		*/
			n = atoi(buf + len - 3);
			buf[len - 3] = 0;	/* terminate newloc/1000*/
			m = atoi(buf);
		}
		while (breakch != LF) {	/* only do one line at a time	*/
			if (t ==  NULL)
				errx(1, "corrupt file");
			if (entries++) {
				t->next = calloc(1, sizeof (*t->next));
				if (t->next == NULL)
					err(1, NULL);
				t = t->next;
			}
			t->tverb = rnum();/* get verb from the file	*/
			t->tloc = n;	/* table entry mod 1000		*/
			t->conditions = m;/* table entry / 1000		*/
		/*	printf("entry %d for %d\n", entries, locc);	*/
		}
	}
}

#ifdef DEBUG

void
twrite(int loq)			/* travel options from this loc */
{
	struct	travlist *t;

	printf("If");
	speak(&ltext[loq]);
	printf("then\n");
	for (t = travel[loq]; t != 0; t = t->next) {
		printf("verb %d takes you to ", t->tverb);
		if (t->tloc <= 300)
			speak(&ltext[t->tloc]);
		else if (t->tloc <= 500)
			printf("special code %d\n", t->tloc - 300);
		else
			rspeak(t->tloc - 500);
		printf("under conditions %d\n", t->conditions);
	}
}
#endif /* DEBUG */

void
rvoc(void)
{
	char   *s;		/* read the vocabulary		*/
	int     index;
	char    buf[6];

	for (;;) {
		index = rnum();
		if (index < 0)
			break;
		for (s = buf, *s = 0;; s++)	/* get the word		*/
			if ((*s = next()) == TAB || *s == '\n' || *s == LF
				|| *s == ' ')
				break;
			/* terminate word with newline, LF, tab, blank	*/
		if (*s != '\n' && *s != LF)
			FLUSHLF;	/* can be comments	*/
		*s = 0;
	/*	printf("\"%s\"=%d\n", buf, index);*/
		vocab(buf, -2, index);
	}
/*	prht();	*/
}


void
rlocs(void)				/* initial object locations	*/
{
	for (;;) {
		if ((obj = rnum()) < 0)
			break;
		plac[obj] = rnum();	/* initial loc for this obj	*/
		if (breakch == TAB)	/* there's another entry	*/
			fixd[obj] = rnum();
		else
			fixd[obj] = 0;
	}
}

void
rdflt(void)			/* default verb messages	*/
{
	for (;;) {
		if ((verb = rnum()) < 0)
			break;
		actspk[verb] = rnum();
	}
}

void
rliq(void)			/* liquid assets &c: cond bits	*/
{
	int bitnum;

	for (;;) {		/* read new bit list		*/
		if ((bitnum = rnum()) < 0)
			break;
		for (;;) {	/* read locs for bits		*/
			cond[rnum()] |= setbit[bitnum];
			if (breakch == LF)
				break;
		}
	}
}

void
rhints(void)
{
	int     hintnum, i;

	hntmax = 0;
	for (;;) {
		if ((hintnum = rnum()) < 0)
			break;
		for (i = 1; i < 5; i++)
			hints[hintnum][i] = rnum();
		if (hintnum > hntmax)
			hntmax = hintnum;
	}
}


void
rspeak(int msg)
{
	if (msg != 0)
		speak(&rtext[msg]);
}


void
mspeak(int msg)
{
	if (msg != 0)
		speak(&mtext[msg]);
}

/*
 * Read, deobfuscate, and print a message (not ptext)
 * msg is a pointer to seek address and length of mess
 */
void
speak(const struct text *msg)	
{
	char   *s, nonfirst;

	s = msg->seekadr;
	nonfirst = 0;
	while (s - msg->seekadr < msg->txtlen) { /* read a line at a time */
		tape = iotape;		/* restart deobfuscation tape	*/
		while ((*s++ ^ *tape++) != TAB); /* read past loc num	*/
		/* assume tape is longer than location number		*/
		/*  plus the lookahead put together			*/
		if ((*s ^ *tape) == '>' &&
		    (*(s + 1) ^ *(tape + 1)) == '$' &&
		    (*(s + 2) ^ *(tape + 2)) == '<')
			break;
		if (blklin && !nonfirst++)
			putchar('\n');
		do {
			if (*tape == 0)
				tape = iotape;/* rewind decryp tape */
			putchar(*s ^ *tape);
		} while ((*s++ ^ *tape++) != LF);	/* better end with LF */
	}
}

/*
 * Read, deobfuscate, and print a ptext message
 * msg is the number of all the p msgs for this place
 * assumes object 1 doesn't have prop 1, obj 2 no prop 2 &c
 */
void
pspeak(int m, int skip) 
{
	char   *s, nonfirst;
	char   *numst, save;
	struct text *msg;
	char   *tbuf;

	msg = &ptext[m];
	if ((tbuf = malloc(msg->txtlen + 1)) == 0)
		err(1, NULL);
	memcpy(tbuf, msg->seekadr, msg->txtlen + 1);	/* Room to null */
	s = tbuf;

	nonfirst = 0;
	while (s - tbuf < msg->txtlen) {	/* read line at a time	*/
		tape = iotape;			/* restart dobfuscation tape */
		for (numst = s; (*s ^= *tape++) != TAB; s++)
			; /* get number	*/

		save = *s; /* Temporarily trash the string (cringe)	*/
		*s++ = 0; /* deobfuscation number within the string	*/

		if (atoi(numst) != 100 * skip && skip >= 0) {
			while ((*s++ ^ * tape++) != LF) /* flush the line */
				if (*tape == 0)
					tape = iotape;
			continue;
		}
		if ((*s^ * tape) == '>' && (*(s + 1) ^ * (tape + 1)) == '$' &&
			(*(s + 2) ^ * (tape + 2)) == '<')
			break;
		if (blklin && !nonfirst++)
			putchar('\n');
		do {
			if (*tape == 0)
				tape = iotape;
			putchar(*s^ * tape);
		} while ((*s++ ^ * tape++) != LF);	/* better end with LF */
		if (skip < 0)
			break;
	}
	free(tbuf);
}
@


1.22
log
@Eliminate another 'calculated, not used' warning by nuking a spurious
dereference.

Same change made in NetBSD in 1997.

ok tb@@ millert@@ tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.21 2016/03/08 10:48:39 mestre Exp $	*/
a90 21


#if 0		/* Not used */
int
confirm(char *mesg)		/* confirm irreversible action	*/
{
	int     result;
	int     ch;

	printf("%s", mesg);	/* tell him what he did		*/
	if ((ch = getchar()) == 'y')	/* was his first letter a 'y'?	*/
		result = 1;
	else if (ch == EOF) {
		printf("user closed input stream, quitting...\n");
		exit(0);
	} else
		result = 0;
	FLUSHLINE;
	return (result);
}
#endif
@


1.21
log
@Headers cleanup with and OK tb@@

This was prompted by an initial patch sent by Edgar Pettijohn
<edgar ! pettijohn-web.com> but the actual commit is different
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.20 2015/08/22 14:47:40 deraadt Exp $	*/
d379 1
a379 1
		for (s = buf; ; *s++)	/* get the newloc number /ASCII */
@


1.20
log
@remove malloc/calloc/realloc* casts, due to stdlib.h being present; ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.19 2014/12/08 21:56:27 deraadt Exp $	*/
a41 1
#include <string.h>
d43 2
a45 1
#include "extern.h"
@


1.19
log
@For now, these games still contain deterministic randomization (for
save / replay modes of operation that have not yet been cleaned up).
OK, I've let the cat out of the bag, now some of you know you can cheat
at them..
ok millert guenther tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.18 2014/07/13 19:40:57 tedu Exp $	*/
d575 1
a575 1
	if ((tbuf = (char *) malloc(msg->txtlen + 1)) == 0)
@


1.18
log
@calling this "encryption" makes me cringe. "slightly obfuscated" is better.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.17 2009/10/27 23:59:23 deraadt Exp $	*/
a203 1
	srandom(SEED);		/* which is slightly obfuscated.*/
@


1.17
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.16 2006/03/27 00:10:14 tedu Exp $	*/
d178 1
a178 1
const char *tape = iotape;	/* pointer to encryption tape	*/
d185 2
a186 2
	ch=(*inptr ^ random()) & 0xFF;	/* Decrypt input data		*/
	if (outsw) {		/* putting data in tmp file	*/
d188 2
a189 2
			tape = iotape;	/* rewind encryption tape	*/
		*inptr = ch ^ *tape++;	/* re-encrypt and replace value */
d204 1
a204 1
	srandom(SEED);		/* which is lightly encrypted.	*/
d279 1
a279 1
	tape = iotape;		/* restart encryption tape	*/
d533 1
a533 1
 * Read, decrypt, and print a message (not ptext)
d544 1
a544 1
		tape = iotape;		/* restart decryption tape	*/
d563 1
a563 1
 * Read, decrypt an print a ptext message
d583 1
a583 1
		tape = iotape;		/* restart decryption tape	*/
d588 1
a588 1
		*s++ = 0; /* decrypting number within the string	*/
@


1.16
log
@assorted fixes mostly from coverity via netbsd via jasper adriaanse via tech
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.15 2004/07/09 15:59:26 deraadt Exp $	*/
a36 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)io.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: io.c,v 1.15 2004/07/09 15:59:26 deraadt Exp $";
#endif
#endif /* not lint */
@


1.15
log
@ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.14 2003/09/25 22:31:43 aaron Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: io.c,v 1.14 2003/09/25 22:31:43 aaron Exp $";
d381 1
a381 1
			t = travel[locc] = (struct travlist *) malloc(sizeof (struct travlist));
d403 2
d406 2
a407 2
				t = t->next = (struct travlist *) malloc(sizeof (struct travlist));
				if (t == NULL)
d409 1
@


1.14
log
@Fix a couple obvious off-by-one writes. No objections from anyone.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.13 2003/06/03 03:01:37 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: io.c,v 1.13 2003/06/03 03:01:37 millert Exp $";
d55 1
a55 1

d57 1
a57 5
getin(wrd1, siz1, wrd2, siz2)	/* get command from user	*/
	char *wrd1; 		/* no prompt, usually		*/
	size_t siz1;
	char *wrd2;
	size_t siz2;
d103 1
a103 2
confirm(mesg)			/* confirm irreversible action	*/
	char	*mesg;
d122 1
a122 2
yes(x, y, z)			/* confirm with rspeak		*/
	int     x, y, z;
d151 1
a151 2
yesm(x, y, z)			/* confirm with mspeak		*/
	int     x, y, z;
d189 1
a189 1
next()				/* next virtual char, bump adr	*/
d206 1
a206 1
rdata()			/* "read" data from virtual file */
d283 1
a283 1
rnum()				/* read initial location num	*/
d301 1
a301 2
rdesc(sect)			/* read description-format msgs */
	int     sect;
d364 1
a364 1
rtrav()				/* read travel table		*/
d419 1
a419 2
twrite(loq)			/* travel options from this loc */
	int     loq;
d440 1
a440 1
rvoc()
d466 1
a466 1
rlocs()				/* initial object locations	*/
d480 1
a480 1
rdflt()				/* default verb messages	*/
d490 1
a490 1
rliq()				/* liquid assets &c: cond bits	*/
d506 1
a506 1
rhints()
d523 1
a523 2
rspeak(msg)
	int     msg;
d531 1
a531 2
mspeak(msg)
	int     msg;
d537 4
a540 1

d542 1
a542 3
speak(msg)	/* read, decrypt, and print a message (not ptext)	*/
	const struct text *msg; /* msg is a pointer to seek address and length
				 * of mess */
d567 5
a571 1

d573 1
a573 3
pspeak(m, skip) /* read, decrypt an print a ptext message	      */
	int     m;	/* msg is the number of all the p msgs for this place */
	int     skip;	/* assumes object 1 doesn't have prop 1, obj 2 no prop 2 &c*/
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.12 2003/04/07 18:19:37 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: io.c,v 1.12 2003/04/07 18:19:37 millert Exp $";
d335 1
a335 1
				if (oldloc > RTXSIZ)
d346 1
a346 1
				if (oldloc > MAGSIZ)
@


1.12
log
@Change wd1 and wd2 from pointers to arrays.  This removes the need
for getin() to have static buffers and allows us to do "sizeof wd1".

Also fix saved game path.  It was removing the first 2 chars of
the filename due to a bug.

tdeval@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.11 2002/02/18 06:38:42 deraadt Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d42 1
a42 1
static char rcsid[] = "$OpenBSD: io.c,v 1.11 2002/02/18 06:38:42 deraadt Exp $";
@


1.11
log
@someone should read compiler messages on the powerpc
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.10 2001/08/06 22:59:05 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.10 2001/08/06 22:59:05 pjanzen Exp $";
d61 5
a65 2
getin(wrd1, wrd2)		/* get command from user	*/
	char **wrd1, **wrd2;	/* no prompt, usually		*/
d67 7
a73 10
	char   *s;
	static char wd1buf[MAXSTR], wd2buf[MAXSTR];
	int     first, numch;

	*wrd1 = wd1buf;		/* return ptr to internal string*/
	*wrd2 = wd2buf;
	wd2buf[0] = 0;		/* in case it isn't set here	*/
	for (s = wd1buf, first = 1, numch = 0;;) {
		if ((*s = getchar()) >= 'A' && *s <= 'Z')
			*s = *s - ('A' - 'a');
d75 1
a75 1
		switch (*s) {	/* start reading from user	*/
d80 1
a80 1
			if (s == wd1buf || s == wd2buf)	/* initial blank  */
d84 3
a86 2
				first = numch = 0;
				s = wd2buf;
d97 1
a97 1
			if (++numch >= MAXSTR) {	/* string too long */
d99 1
a99 1
				wd1buf[0] = wd2buf[0] = 0;
d103 1
a103 1
			s++;
@


1.10
log
@Nothing but comments after #endif and #else; heko@@iki.fi
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.9 2001/03/22 22:32:39 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.9 2001/03/22 22:32:39 pjanzen Exp $";
d164 1
a164 1
	char    ch;
@


1.9
log
@Don't FLUSHLINE unnecessarily
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.8 2001/02/17 20:14:57 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.8 2001/02/17 20:14:57 pjanzen Exp $";
d449 1
a449 1
#endif DEBUG
@


1.8
log
@Use err() rather than errx() immediately after alloc failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.7 1998/11/29 19:45:10 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.7 1998/11/29 19:45:10 pjanzen Exp $";
d146 2
a147 1
		FLUSHLINE;
d170 1
a170 1
		else if (ch=='n')
d176 2
a177 1
		FLUSHLINE;
@


1.7
log
@Minor changes from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.6 1998/09/12 01:54:42 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.6 1998/09/12 01:54:42 pjanzen Exp $";
d392 1
a392 1
				errx(1, "Out of memory!");
d415 1
a415 1
					errx(1, "Out of memory!");
d591 1
a591 1
		errx(1, "Out of memory!");
@


1.6
log
@check for malloc() failure; jsm28@@cam.ac.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.5 1998/08/31 02:29:41 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.5 1998/08/31 02:29:41 pjanzen Exp $";
d336 2
a337 4
				if (oldloc > RTXSIZ) {
					printf("Too many random msgs\n");
					exit(1);
				}
d347 2
a348 4
				if (oldloc > MAGSIZ) {
					printf("Too many magic msgs\n");
					exit(1);
				}
d353 1
a353 2
				printf("rdesc called with bad section\n");
				exit(1);
@


1.5
log
@merge in NetBSD, including recent PR's of jsm28@@cam.ac.uk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD$";
d52 1
d396 2
d417 1
a417 1
			if (entries++)
d419 3
d596 1
a596 1
		bug(108);
@


1.4
log
@proto malloc
@
text
@d1 1
d46 1
a46 1
static char rcsid[] = "$NetBSD: io.c,v 1.3 1995/04/24 12:21:37 cgd Exp $";
a51 1
#include "hdr.h"
d55 2
d59 18
a76 15
getin(wrd1,wrd2)			/* get command from user	*/
char **wrd1,**wrd2;			/* no prompt, usually		*/
{       register char *s;
	static char wd1buf[MAXSTR],wd2buf[MAXSTR];
	int first, numch;

	*wrd1=wd1buf;			/* return ptr to internal string*/
	*wrd2=wd2buf;
	wd2buf[0]=0;			/* in case it isn't set here	*/
	for (s=wd1buf, first=1, numch=0;;)
	{       if ((*s=getchar())>='A' && *s <='Z') *s = *s - ('A' -'a');
					/* convert to upper case	*/
		switch(*s)		/* start reading from user	*/
		{   case '\n':
			*s=0;
d78 2
a79 2
		    case ' ':
			if (s==wd1buf||s==wd2buf)  /* initial blank   */
d81 4
a84 4
			*s=0;
			if (first)      /* finished 1st wd; start 2nd   */
			{       first=numch=0;
				s=wd2buf;
d86 3
a88 4
			}
			else		/* finished 2nd word		*/
			{       FLUSHLINE;
				*s=0;
d91 1
a91 1
		    case EOF:
d94 4
a97 4
		    default:
			if (++numch>=MAXSTR)    /* string too long      */
			{       printf("Give me a break!!\n");
				wd1buf[0]=wd2buf[0]=0;
d107 12
a118 8
confirm(mesg)				/* confirm irreversible action	*/
char *mesg;
{       register int result;
	register int c;
	printf("%s",mesg);		/* tell him what he did		*/
	if ((c = getchar())=='y')	      /* was his first letter a 'y'?  */
		result=1;
	else if (c == EOF) {
d121 2
a122 1
	} else result=0;
d124 1
a124 1
	return(result);
d126 1
d128 13
a140 9
yes(x,y,z)				/* confirm with rspeak		*/
int x,y,z;
{       register int result;
	register int ch;
	for (;;)
	{	rspeak(x);		       /* tell him what we want*/
		if ((ch=getchar())=='y')
			result=TRUE;
		else if (ch=='n') result=FALSE;
d146 2
a147 1
		if (ch=='y'|| ch=='n') break;
d150 5
a154 3
	if (result==TRUE) rspeak(y);
	if (result==FALSE) rspeak(z);
	return(result);
d157 13
a169 9
yesm(x,y,z)				/* confirm with mspeak		*/
int x,y,z;
{       register int result;
	register char ch;
	for (;;)
	{	mspeak(x);		       /* tell him what we want*/
		if ((ch=getchar())=='y')
			result=TRUE;
		else if (ch=='n') result=FALSE;
d175 2
a176 1
		if (ch=='y'|| ch=='n') break;
d179 5
a183 3
	if (result==TRUE) mspeak(y);
	if (result==FALSE) mspeak(z);
	return(result);
d188 1
a188 1
char *inptr;				/* Pointer into virtual disk	*/
d190 1
a190 1
int outsw = 0;				/* putting stuff to data file?  */
d192 2
a193 2
char iotape[] = "Ax3F'\003tt$8h\315qer*h\017nGKrX\207:!l";
char *tape = iotape;			/* pointer to encryption tape   */
d195 2
a196 1
next()					/* next virtual char, bump adr	*/
d201 4
a204 3
	if (outsw)			/* putting data in tmp file	*/
	{   if (*tape==0) tape=iotape;  /* rewind encryption tape       */
	    *inptr = ch ^ *tape++;      /* re-encrypt and replace value */
d207 1
a207 1
	return(ch);
d210 1
a210 1
char breakch;				/* tell which char ended rnum	*/
d212 5
a216 3
rdata()					/* "read" data from virtual file*/
{       register int sect;
	register char ch;
d218 2
a219 2
	inptr = data_file;		/* Pointer to virtual data file */
	srandom(SEED);			/* which is lightly encrypted.	*/
d221 3
a223 3
	clsses=1;
	for (;;)			/* read data sections		*/
	{	sect=next()-'0';	/* 1st digit of section number	*/
d225 1
a225 1
		printf("Section %c",sect+'0');
d227 1
a227 2
		if ((ch=next())!=LF)    /* is there a second digit?     */
		{
d232 1
a232 1
			sect=10*sect+ch-'0';
d237 2
a238 2
		switch(sect)
		{   case 0:		/* finished reading database	*/
d240 1
a240 1
		    case 1:		/* long form descriptions	*/
d243 1
a243 1
		    case 2:		/* short form descriptions	*/
d246 4
a249 3
		    case 3:		/* travel table			*/
			rtrav();   break;
		    case 4:		/* vocabulary			*/
d252 1
a252 1
		    case 5:		/* object descriptions		*/
d255 1
a255 1
		    case 6:		/* arbitrary messages		*/
d258 10
a267 7
		    case 7:		/* object locations		*/
			rlocs();   break;
		    case 8:		/* action defaults		*/
			rdflt();   break;
		    case 9:		/* liquid assets		*/
			rliq();    break;
		    case 10:		/* class messages		*/
d270 4
a273 3
		    case 11:		/* hints			*/
			rhints();  break;
		    case 12:		/* magic messages		*/
d276 4
a279 3
		    default:
			printf("Invalid data section number: %d\n",sect);
			for (;;) putchar(next());
d281 1
a281 1
		if (breakch!=LF)	/* routines return after "-1"	*/
d286 2
a287 1
char nbf[12];
d289 15
d305 20
a324 31
rnum()					/* read initial location num	*/
{       register char *s;
	tape = iotape;			/* restart encryption tape	*/
	for (s=nbf,*s=0;; s++)
		if ((*s=next())==TAB || *s=='\n' || *s==LF)
			break;
	breakch= *s;			/* save char for rtrav()	*/
	*s=0;				/* got the number as ascii	*/
	if (nbf[0]=='-') return(-1);	/* end of data			*/
	return(atoi(nbf));		/* convert it to integer	*/
}

char *seekhere;

rdesc(sect)				/* read description-format msgs */
int sect;
{       register char *s,*t;
	register int locc;
	char *seekstart, *maystart, *adrstart;
	char *entry;

	seekhere = inptr;		/* Where are we in virtual file?*/
	outsw=1;			/* these msgs go into tmp file	*/
	for (oldloc= -1, seekstart=seekhere;;)
	{	maystart=inptr;		/* maybe starting new entry	*/
		if ((locc=rnum())!=oldloc && oldloc>=0  /* finished msg */
		    && ! (sect==5 && (locc==0 || locc>=100)))/* unless sect 5*/
		{       switch(sect)    /* now put it into right table  */
			{   case 1:	/* long descriptions		*/
				ltext[oldloc].seekadr=seekhere;
				ltext[oldloc].txtlen=maystart-seekstart;
d326 3
a328 3
			    case 2:	/* short descriptions		*/
				stext[oldloc].seekadr=seekhere;
				stext[oldloc].txtlen=maystart-seekstart;
d330 3
a332 3
			    case 5:	/* object descriptions		*/
				ptext[oldloc].seekadr=seekhere;
				ptext[oldloc].txtlen=maystart-seekstart;
d334 4
a337 4
			    case 6:	/* random messages		*/
				if (oldloc>RTXSIZ)
				{       printf("Too many random msgs\n");
					exit(0);
d339 2
a340 2
				rtext[oldloc].seekadr=seekhere;
				rtext[oldloc].txtlen=maystart-seekstart;
d342 4
a345 4
			    case 10:	/* class messages		*/
				ctext[clsses].seekadr=seekhere;
				ctext[clsses].txtlen=maystart-seekstart;
				cval[clsses++]=oldloc;
d347 4
a350 4
			    case 12:	/* magic messages		*/
				if (oldloc>MAGSIZ)
				{       printf("Too many magic msgs\n");
					exit(0);
d352 2
a353 2
				mtext[oldloc].seekadr=seekhere;
				mtext[oldloc].txtlen=maystart-seekstart;
d355 1
a355 1
			    default:
d357 1
a357 1
				exit(0);
d359 1
a359 1
			seekhere += maystart-seekstart;
d361 2
a362 2
		if (locc<0)
		{	outsw=0;	/* turn off output		*/
d366 4
a369 4
		if (sect!=5 || (locc>0 && locc<100))
		{       if (oldloc!=locc)/* starting a new message       */
				seekstart=maystart;
			oldloc=locc;
d376 13
a388 11
rtrav()					/* read travel table		*/
{       register int locc;
	register struct travlist *t;
	register char *s;
	char buf[12];
	int len,m,n,entries;
	for (oldloc= -1;;)		/* get another line		*/
	{       if ((locc=rnum())!=oldloc && oldloc>=0) /* end of entry */
		{
			t->next = 0;    /* terminate the old entry      */
		/*      printf("%d:%d entries\n",oldloc,entries);       */
d391 29
a419 27
		if (locc== -1) return;
		if (locc!=oldloc)	 /* getting a new entry		*/
		{       t=travel[locc]=(struct travlist *) malloc(sizeof (struct travlist));
		/*	printf("New travel list for %d\n",locc);	*/
			entries=0;
			oldloc=locc;
		}
		for (s=buf;; *s++)      /* get the newloc number /ASCII */
			if ((*s=next())==TAB || *s==LF) break;
		*s=0;
		len=length(buf)-1;      /* quad long number handling    */
	/*	printf("Newloc: %s (%d chars)\n",buf,len);		*/
		if (len<4)		/* no "m" conditions		*/
		{       m=0;
			n=atoi(buf);    /* newloc mod 1000 = newloc     */
		}
		else			/* a long integer		*/
		{       n=atoi(buf+len-3);
			buf[len-3]=0;	/* terminate newloc/1000	*/
			m=atoi(buf);
		}
		while (breakch!=LF)     /* only do one line at a time   */
		{       if (entries++) t=t->next=(struct travlist *) malloc(sizeof (struct travlist));
			t->tverb=rnum();/* get verb from the file       */
			t->tloc=n;	/* table entry mod 1000		*/
			t->conditions=m;/* table entry / 1000		*/
		/*      printf("entry %d for %d\n",entries,locc);       */
d426 6
a431 3
twrite(loq)				/* travel options from this loc */
int loq;
{       register struct travlist *t;
d435 3
a437 3
	for (t=travel[loq]; t!=0; t=t->next)
	{       printf("verb %d takes you to ",t->tverb);
		if (t->tloc<=300)
d439 2
a440 2
		else if (t->tloc<=500)
			printf("special code %d\n",t->tloc-300);
d442 2
a443 2
			rspeak(t->tloc-500);
		printf("under conditions %d\n",t->conditions);
a445 1

d448 1
d450 19
a468 14
{	register char *s;		/* read the vocabulary		*/
	register int index;
	char buf[6];
	for (;;)
	{       index=rnum();
		if (index<0) break;
		for (s=buf,*s=0;; s++)	/* get the word			*/
			if ((*s=next())==TAB || *s=='\n' || *s==LF
				|| *s==' ') break;
			/* terminate word with newline, LF, tab, blank  */
		if (*s!='\n' && *s!=LF) FLUSHLF;  /* can be comments    */
		*s=0;
	/*      printf("\"%s\"=%d\n",buf,index);*/
		vocab(buf,-2,index);
d474 11
a484 7
rlocs()					/* initial object locations	*/
{	for (;;)
	{       if ((obj=rnum())<0) break;
		plac[obj]=rnum();       /* initial loc for this obj     */
		if (breakch==TAB)	/* there's another entry	*/
			fixd[obj]=rnum();
		else    fixd[obj]=0;
d488 7
a494 4
rdflt()					/* default verb messages	*/
{	for (;;)
	{       if ((verb=rnum())<0) break;
		actspk[verb]=rnum();
d498 12
a509 7
rliq()					/* liquid assets &c: cond bits	*/
{       register int bitnum;
	for (;;)			/* read new bit list		*/
	{       if ((bitnum=rnum())<0) break;
		for (;;)		/* read locs for bits		*/
		{       cond[rnum()] |= setbit[bitnum];
			if (breakch==LF) break;
d514 1
d516 11
a526 7
{       register int hintnum,i;
	hntmax=0;
	for (;;)
	{       if ((hintnum=rnum())<0) break;
		for (i=1; i<5; i++)
			hints[hintnum][i]=rnum();
		if (hintnum>hntmax) hntmax=hintnum;
d531 1
d533 4
a536 2
int msg;
{       if (msg!=0) speak(&rtext[msg]);
d540 1
d542 4
a545 2
int msg;
{       if (msg!=0) speak(&mtext[msg]);
d549 4
a552 2
speak(msg)       /* read, decrypt, and print a message (not ptext)      */
struct text *msg;/* msg is a pointer to seek address and length of mess */
d554 1
a554 1
	register char *s, nonfirst;
d557 4
a560 4
	nonfirst=0;
	while (s - msg->seekadr < msg->txtlen)  /* read a line at a time */
	{	tape=iotape;		/* restart decryption tape	*/
		while ((*s++ ^ *tape++) != TAB); /* read past loc num       */
d562 1
a562 1
		/*   plus the lookahead put together			*/
d564 8
a571 5
			(*(s+1) ^ *(tape+1)) == '$' &&
			(*(s+2) ^ *(tape+2)) == '<') break;
		if (blklin && !nonfirst++) putchar('\n');
		do
		{       if (*tape == 0) tape = iotape;/* rewind decryp tape */
d573 1
a573 1
		} while ((*s++ ^ *tape++) != LF);   /* better end with LF   */
d578 4
a581 3
pspeak(m,skip) /* read, decrypt an print a ptext message	      */
int m;	       /* msg is the number of all the p msgs for this place  */
int skip;       /* assumes object 1 doesn't have prop 1, obj 2 no prop 2 &c*/
d583 2
a584 2
	register char *s,nonfirst;
	char *numst, save;
d586 1
a586 1
	char *tbuf;
d589 3
a591 2
	if ((tbuf=(char *) malloc(msg->txtlen + 1)) == 0) bug(108);
	memcpy(tbuf, msg->seekadr, msg->txtlen + 1);   /* Room to null */
d594 13
a606 11
	nonfirst=0;
	while (s - tbuf < msg->txtlen) /* read line at a time */
	{	tape=iotape;		/* restart decryption tape	*/
		for (numst=s; (*s^= *tape++)!=TAB; s++); /* get number  */

		save = *s; /* Temporarily trash the string (cringe) */
		*s++ = 0; /* decrypting number within the string	  */

		if (atoi(numst) != 100 * skip && skip >= 0)
		{       while ((*s++^*tape++)!=LF) /* flush the line    */
				if (*tape==0) tape=iotape;
d609 12
a620 8
		if ((*s^*tape)=='>' && (*(s+1)^*(tape+1))=='$' &&
			(*(s+2)^*(tape+2))=='<') break;
		if (blklin && ! nonfirst++) putchar('\n');
		do
		{       if (*tape==0) tape=iotape;
			putchar(*s^*tape);
		} while ((*s++^*tape++)!=LF);   /* better end with LF   */
		if (skip<0) break;
@


1.3
log
@tabify
@
text
@d54 1
@


1.2
log
@Fix PR#2 in a simplistic way.  Handle EOF on all getchar()s
@
text
@d49 1
a49 1
/*      Re-coding of advent in C: file i/o and user i/o                 */
d56 2
a57 2
getin(wrd1,wrd2)                        /* get command from user        */
char **wrd1,**wrd2;                     /* no prompt, usually           */
d62 1
a62 1
	*wrd1=wd1buf;                   /* return ptr to internal string*/
d64 1
a64 1
	wd2buf[0]=0;                    /* in case it isn't set here    */
d67 2
a68 2
					/* convert to upper case        */
		switch(*s)              /* start reading from user      */
d81 1
a81 1
			else            /* finished 2nd word            */
d102 1
a102 1
confirm(mesg)                           /* confirm irreversible action  */
d106 2
a107 2
	printf("%s",mesg);              /* tell him what he did         */
	if ((c = getchar())=='y')             /* was his first letter a 'y'?  */
d117 1
a117 1
yes(x,y,z)                              /* confirm with rspeak          */
d122 1
a122 1
	{       rspeak(x);                     /* tell him what we want*/
d139 1
a139 1
yesm(x,y,z)                             /* confirm with mspeak          */
d144 1
a144 1
	{       mspeak(x);                     /* tell him what we want*/
d163 1
a163 1
char *inptr;                            /* Pointer into virtual disk    */
d170 1
a170 1
next()                                  /* next virtual char, bump adr  */
d174 2
a175 2
	ch=(*inptr ^ random()) & 0xFF;  /* Decrypt input data           */
	if (outsw)                      /* putting data in tmp file     */
d183 1
a183 1
char breakch;                           /* tell which char ended rnum   */
d185 1
a185 1
rdata()                                 /* "read" data from virtual file*/
d189 2
a190 2
	inptr = data_file;              /* Pointer to virtual data file */
	srandom(SEED);                  /* which is lightly encrypted.  */
d193 2
a194 2
	for (;;)                        /* read data sections           */
	{       sect=next()-'0';        /* 1st digit of section number  */
d210 1
a210 1
		{   case 0:             /* finished reading database    */
d212 1
a212 1
		    case 1:             /* long form descriptions       */
d215 1
a215 1
		    case 2:             /* short form descriptions      */
d218 1
a218 1
		    case 3:             /* travel table                 */
d220 1
a220 1
		    case 4:             /* vocabulary                   */
d223 1
a223 1
		    case 5:             /* object descriptions          */
d226 1
a226 1
		    case 6:             /* arbitrary messages           */
d229 1
a229 1
		    case 7:             /* object locations             */
d231 1
a231 1
		    case 8:             /* action defaults              */
d233 1
a233 1
		    case 9:             /* liquid assets                */
d235 1
a235 1
		    case 10:            /* class messages               */
d238 1
a238 1
		    case 11:            /* hints                        */
d240 1
a240 1
		    case 12:            /* magic messages               */
d247 1
a247 1
		if (breakch!=LF)        /* routines return after "-1"   */
d255 1
a255 1
rnum()                                  /* read initial location num    */
d257 1
a257 1
	tape = iotape;                  /* restart encryption tape      */
d261 4
a264 4
	breakch= *s;                    /* save char for rtrav()        */
	*s=0;                           /* got the number as ascii      */
	if (nbf[0]=='-') return(-1);    /* end of data                  */
	return(atoi(nbf));              /* convert it to integer        */
d269 1
a269 1
rdesc(sect)                             /* read description-format msgs */
d276 2
a277 2
	seekhere = inptr;               /* Where are we in virtual file?*/
	outsw=1;                        /* these msgs go into tmp file  */
d279 1
a279 1
	{       maystart=inptr;         /* maybe starting new entry     */
d283 1
a283 1
			{   case 1:     /* long descriptions            */
d287 1
a287 1
			    case 2:     /* short descriptions           */
d291 1
a291 1
			    case 5:     /* object descriptions          */
d295 1
a295 1
			    case 6:     /* random messages              */
d303 1
a303 1
			    case 10:    /* class messages               */
d308 1
a308 1
			    case 12:    /* magic messages               */
d323 2
a324 2
		{       outsw=0;        /* turn off output              */
			seekhere += 3;  /* -1<delimiter>                */
d332 1
a332 1
		FLUSHLF;                /* scan the line                */
d337 1
a337 1
rtrav()                                 /* read travel table            */
d343 1
a343 1
	for (oldloc= -1;;)              /* get another line             */
d348 1
a348 1
		/*      twrite(oldloc);                                 */
d351 1
a351 1
		if (locc!=oldloc)        /* getting a new entry         */
d353 1
a353 1
		/*      printf("New travel list for %d\n",locc);        */
d361 2
a362 2
	/*      printf("Newloc: %s (%d chars)\n",buf,len);              */
		if (len<4)              /* no "m" conditions            */
d366 1
a366 1
		else                    /* a long integer               */
d368 1
a368 1
			buf[len-3]=0;   /* terminate newloc/1000        */
d374 2
a375 2
			t->tloc=n;      /* table entry mod 1000         */
			t->conditions=m;/* table entry / 1000           */
d383 1
a383 1
twrite(loq)                             /* travel options from this loc */
d404 1
a404 1
{       register char *s;               /* read the vocabulary          */
d410 1
a410 1
		for (s=buf,*s=0;; s++)  /* get the word                 */
d423 1
a423 1
rlocs()                                 /* initial object locations     */
d427 1
a427 1
		if (breakch==TAB)       /* there's another entry        */
d433 1
a433 1
rdflt()                                 /* default verb messages        */
d440 1
a440 1
rliq()                                  /* liquid assets &c: cond bits  */
d442 1
a442 1
	for (;;)                        /* read new bit list            */
d444 1
a444 1
		for (;;)                /* read locs for bits           */
d483 1
a483 1
	{       tape=iotape;            /* restart decryption tape      */
d485 2
a486 2
		/* assume tape is longer than location number           */
		/*   plus the lookahead put together                    */
d499 2
a500 2
pspeak(m,skip) /* read, decrypt an print a ptext message              */
int m;         /* msg is the number of all the p msgs for this place  */
d515 1
a515 1
	{       tape=iotape;            /* restart decryption tape      */
d519 1
a519 1
		*s++ = 0; /* decrypting number within the string          */
@


1.1
log
@Initial revision
@
text
@d86 3
d105 1
d107 1
a107 1
	if (getchar()=='y')             /* was his first letter a 'y'?  */
d109 4
a112 1
	else    result=0;
d120 1
a120 1
	register char ch;
d126 4
d148 4
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
