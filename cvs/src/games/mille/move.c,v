head	1.17;
access;
symbols
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.22
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.20
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.16
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.14
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.12
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.10
	OPENBSD_5_0:1.12.0.8
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.10.0.28
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.24
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.22
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.20
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.18
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.16
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.14
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.12
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.10
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.9.0.8
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.6
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.4
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2016.01.08.18.09.59;	author mestre;	state Exp;
branches;
next	1.16;
commitid	rzHxXR4ksTqCTr4f;

1.16
date	2016.01.08.18.05.58;	author mestre;	state Exp;
branches;
next	1.15;
commitid	qycMYAxRCIO41J4W;

1.15
date	2015.11.04.21.22.10;	author tedu;	state Exp;
branches;
next	1.14;
commitid	XDKIiXhFNs4jqYjv;

1.14
date	2015.10.24.17.51.59;	author mmcc;	state Exp;
branches;
next	1.13;
commitid	rmtwRZchQmSEu55f;

1.13
date	2014.11.16.04.49.48;	author guenther;	state Exp;
branches;
next	1.12;
commitid	8XNajyb9IqHkZEKg;

1.12
date	2009.12.10.23.53.05;	author beck;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.27.23.59.25;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.03.03.01.40;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.03.21.36.12;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.05.21.57.41;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	99.11.25.11.07.53;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	99.09.30.03.23.59;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	99.09.25.15.52.20;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	98.09.22.04.08.24;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	97.04.01.16.00.56;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	96.06.02.19.47.08;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.07;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.17
log
@ANSIfy mille(6)

OK tb@@
@
text
@/*	$OpenBSD: move.c,v 1.16 2016/01/08 18:05:58 mestre Exp $	*/
/*	$NetBSD: move.c,v 1.4 1995/03/24 05:01:57 cgd Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <ctype.h>
#ifdef DEBUG
#include <err.h>
#include <limits.h>
#endif
#include <string.h>

#include "mille.h"

/*
 * @@(#)move.c	1.2 (Berkeley) 3/28/83
 */

void
domove(void)
{
	PLAY	*pp;
	int	i, j;
	bool	goodplay;

	pp = &Player[Play];
	if (Play == PLAYER)
		getmove();
	else
		calcmove();
	Next = FALSE;
	goodplay = TRUE;
	switch (Movetype) {
	  case M_DISCARD:
		if (haspicked(pp)) {
			if (pp->hand[Card_no] == C_INIT) {
				if (Card_no == 6)
					Finished = TRUE;
				else
					error("no card there");
			} else {
				if (is_safety(pp->hand[Card_no])) {
					error("discard a safety?");
					goodplay = FALSE;
					break;
				}
				Discard = pp->hand[Card_no];
				pp->hand[Card_no] = C_INIT;
				Next = TRUE;
				if (Play == PLAYER)
					account(Discard);
			}
		}
		else
			error("must pick first");
		break;
	  case M_PLAY:
		goodplay = playcard(pp);
		break;
	  case M_DRAW:
		Card_no = 0;
		if (Topcard <= Deck)
			error("no more cards");
		else if (haspicked(pp))
			error("already picked");
		else {
			pp->hand[0] = *--Topcard;
#ifdef DEBUG
			if (Debug)
				fprintf(outf, "DOMOVE: Draw %s\n", C_name[*Topcard]);
#endif
acc:
			if (Play == COMP) {
				account(*Topcard);
				if (is_safety(*Topcard))
					pp->safety[*Topcard-S_CONV] = S_IN_HAND;
			}
			if (pp->hand[1] == C_INIT && Topcard > Deck) {
				Card_no = 1;
				pp->hand[1] = *--Topcard;
#ifdef DEBUG
				if (Debug)
					fprintf(outf, "DOMOVE: Draw %s\n", C_name[*Topcard]);
#endif
				goto acc;
			}
			pp->new_battle = FALSE;
			pp->new_speed = FALSE;
		}
		break;

	  case M_ORDER:
		break;
	}
	/*
	 * move blank card to top by one of two methods.  If the
	 * computer's hand was sorted, the randomness for picking
	 * between equally valued cards would be lost
	 */
	if (Order && Movetype != M_DRAW && goodplay && pp == &Player[PLAYER])
		sort(pp->hand);
	else
		for (i = 1; i < HAND_SZ; i++)
			if (pp->hand[i] == C_INIT) {
				for (j = 0; (j < HAND_SZ) &&
					 (pp->hand[j] == C_INIT); j++)
					;	
				if (j == HAND_SZ)
					j = 0;
				pp->hand[i] = pp->hand[j];
				pp->hand[j] = C_INIT;
			}
	if (Topcard <= Deck)
		check_go();
	if (Next)
		nextplay();
}

/*
 *	Check and see if either side can go.  If they cannot,
 * the game is over
 */
void
check_go(void)
{
	CARD	card;
	PLAY	*pp, *op;
	int	i;

	for (pp = Player; pp < &Player[2]; pp++) {
		op = (pp == &Player[COMP] ? &Player[PLAYER] : &Player[COMP]);
		for (i = 0; i < HAND_SZ; i++) {
			card = pp->hand[i];
			if (is_safety(card) || canplay(pp, op, card)) {
#ifdef DEBUG
				if (Debug) {
					fprintf(outf, "CHECK_GO: can play %s (%d), ", C_name[card], card);
					fprintf(outf, "is_safety(card) = %d, ", is_safety(card));
					fprintf(outf, "canplay(pp, op, card) = %d\n", canplay(pp, op, card));
				}
#endif
				return;
			}
#ifdef DEBUG
			else if (Debug)
				fprintf(outf, "CHECK_GO: cannot play %s\n",
				    C_name[card]);
#endif
		}
	}
	Finished = TRUE;
}

int
playcard(PLAY *pp)
{
	int	v;
	CARD	card;

	/*
	 * check and see if player has picked
	 */
	switch (pp->hand[Card_no]) {
	  default:
		if (!haspicked(pp))
mustpick:
			return error("must pick first");
	  case C_GAS_SAFE:	case C_SPARE_SAFE:
	  case C_DRIVE_SAFE:	case C_RIGHT_WAY:
		break;
	}

	card = pp->hand[Card_no];
#ifdef DEBUG
	if (Debug)
		fprintf(outf, "PLAYCARD: Card = %s\n", C_name[card]);
#endif
	Next = FALSE;
	switch (card) {
	  case C_200:
		if (pp->nummiles[C_200] == 2)
			return error("only two 200's per hand");
	  case C_100:	case C_75:
		if (pp->speed == C_LIMIT)
			return error("limit of 50");
	  case C_50:
		if (pp->mileage + Value[card] > End)
			return error("puts you over %d", End);
	  case C_25:
		if (!pp->can_go)
			return error("cannot move now");
		pp->nummiles[card]++;
		v = Value[card];
		pp->total += v;
		pp->hand_tot += v;
		if ((pp->mileage += v) == End)
			check_ext(FALSE);
		break;

	  case C_GAS:	case C_SPARE:	case C_REPAIRS:
		if (pp->battle != opposite(card))
			return error("can't play \"%s\"", C_name[card]);
		pp->battle = card;
		if (pp->safety[S_RIGHT_WAY] == S_PLAYED)
			pp->can_go = TRUE;
		break;

	  case C_GO:
		if (pp->battle != C_INIT && pp->battle != C_STOP
		    && !is_repair(pp->battle))
			return error("cannot play \"Go\" on a \"%s\"",
			    C_name[pp->battle]);
		if (pp->safety[S_RIGHT_WAY] == S_PLAYED)
			return error("\"Go\" implied by \"Right of Way\"");
		pp->battle = C_GO;
		pp->can_go = TRUE;
		break;

	  case C_END_LIMIT:
		if (pp->speed != C_LIMIT)
			return error("not limited");
		pp->speed = C_END_LIMIT;
		break;

	  case C_EMPTY:	case C_FLAT:	case C_CRASH:
	  case C_STOP:
		pp = &Player[other(Play)];
		if (!pp->can_go)
			return error("opponent cannot go");
		else if (pp->safety[safety(card) - S_CONV] == S_PLAYED)
protected:
			return error("opponent is protected");
		pp->battle = card;
		pp->new_battle = TRUE;
		pp->can_go = FALSE;
		pp = &Player[Play];
		break;

	  case C_LIMIT:
		pp = &Player[other(Play)];
		if (pp->speed == C_LIMIT)
			return error("opponent has limit");
		if (pp->safety[S_RIGHT_WAY] == S_PLAYED)
			goto protected;
		pp->speed = C_LIMIT;
		pp->new_speed = TRUE;
		pp = &Player[Play];
		break;

	  case C_GAS_SAFE:	case C_SPARE_SAFE:
	  case C_DRIVE_SAFE:	case C_RIGHT_WAY:
		if ((pp->new_battle && pp->battle == opposite(card))
		    || (pp->new_speed && card == C_RIGHT_WAY)) {
			/* coup fourre */
			pp->coups[card - S_CONV] = TRUE;
			pp->total += SC_COUP;
			pp->hand_tot += SC_COUP;
			pp->coupscore += SC_COUP;
		}
		/*
		 * if not coup, must pick first
		 */
		else if (pp->hand[0] == C_INIT && Topcard > Deck)
			goto mustpick;
		pp->safety[card - S_CONV] = S_PLAYED;
		pp->total += SC_SAFETY;
		pp->hand_tot += SC_SAFETY;
		if ((pp->safescore += SC_SAFETY) == NUM_SAFE * SC_SAFETY) {
			pp->total += SC_ALL_SAFE;
			pp->hand_tot += SC_ALL_SAFE;
		}
		if (pp->battle == opposite(card)) {
			pp->battle = C_GO;
			pp->can_go = TRUE;
		}
		if (card == C_RIGHT_WAY) {
			if (pp->speed == C_LIMIT)
				pp->speed = C_INIT;
			if (pp->battle == C_STOP || pp->battle == C_INIT ||
			    (!pp->can_go && is_repair(pp->battle))) {
				pp->can_go = TRUE;
				pp->battle = C_GO;
			}
		}
		Next = -1;
		break;

	  case C_INIT:
		error("no card there");
		Next = -1;
		break;
	}
	if (pp == &Player[PLAYER])
		account(card);
	pp->hand[Card_no] = C_INIT;
	Next = (Next == (bool)-1 ? FALSE : TRUE);
	return TRUE;
}

void
getmove(void)
{
	char	c;
#ifdef DEBUG
	char *sp;
#endif
#ifdef EXTRAP
	static bool	last_ex = FALSE;	/* set if last command was E */

	if (last_ex) {
		undoex();
		prboard();
		last_ex = FALSE;
	}
#endif
	for (;;) {
		prompt(MOVEPROMPT);
		leaveok(Board, FALSE);
		refresh();
		while ((c = readch()) == killchar() || c == erasechar())
			continue;
		if (islower((unsigned char)c))
			c = toupper((unsigned char)c);
		if (isprint((unsigned char)c) && !isspace((unsigned char)c)) {
			addch(c);
			refresh();
		}
		switch (c) {
		  case 'P':		/* Pick */
			Movetype = M_DRAW;
			goto ret;
		  case 'U':		/* Use Card */
		  case 'D':		/* Discard Card */
			if ((Card_no = getcard()) < 0)
				break;
			Movetype = (c == 'U' ? M_PLAY : M_DISCARD);
			goto ret;
		  case 'O':		/* Order */
			Order = !Order;
			if (Window == W_SMALL) {
				if (!Order)
					mvwaddstr(Score, 12, 21,
						  "o: order hand");
				else
					mvwaddstr(Score, 12, 21,
						  "o: stop ordering");
				wclrtoeol(Score);
			}
			Movetype = M_ORDER;
			goto ret;
		  case 'Q':		/* Quit */
			rub(0);		/* Same as a rubout */
			break;
		  case 'W':		/* Window toggle */
			Window = nextwin(Window);
			newscore();
			prscore(TRUE);
			wrefresh(Score);
			break;
		  case 'R':		/* Redraw screen */
		  case CTRL('L'):
			wrefresh(curscr);
			break;
		  case 'S':		/* Save game */
			On_exit = FALSE;
			save();
			break;
		  case 'E':		/* Extrapolate */
#ifdef EXTRAP
			if (last_ex)
				break;
			Finished = TRUE;
			if (Window != W_FULL)
				newscore();
			prscore(FALSE);
			wrefresh(Score);
			last_ex = TRUE;
			Finished = FALSE;
#else
			error("%c: command not implemented", c);
#endif
			break;
		  case '\r':		/* Ignore RETURNs and	*/
		  case '\n':		/* Line Feeds		*/
		  case ' ':		/* Spaces		*/
		  case '\0':		/* and nulls		*/
			break;
#ifdef DEBUG
		  case 'Z':		/* Debug code */
			if (!Debug && outf == NULL) {
				char	buf[PATH_MAX];
over:
				prompt(FILEPROMPT);
				leaveok(Board, FALSE);
				refresh();
				sp = buf;
				while ((*sp = readch()) != '\n' && *sp != '\r'
				    && (sp - buf < sizeof(buf))) {
					if (*sp == killchar())
						goto over;
					else if (*sp == erasechar()) {
						if (--sp < buf)
							sp = buf;
						else {
							addch('\b');
							if (*sp < ' ')
							    addch('\b');
							clrtoeol();
						}
					}
					else
						addstr(unctrl(*sp++));
					refresh();
				}
				*sp = '\0';
				leaveok(Board, TRUE);
				if ((outf = fopen(buf, "w")) == NULL)
					warn("%s", buf);
				setvbuf(outf, NULL, _IONBF, 0);
			}
			Debug = !Debug;
			break;
#endif
		  default:
			error("unknown command: %s", unctrl(c));
			break;
		}
	}
ret:
	leaveok(Board, TRUE);
}

/*
 * return whether or not the player has picked
 */
int
haspicked(const PLAY *pp)
{
	int	card;

	if (Topcard <= Deck)
		return TRUE;
	switch (pp->hand[Card_no]) {
	  case C_GAS_SAFE:	case C_SPARE_SAFE:
	  case C_DRIVE_SAFE:	case C_RIGHT_WAY:
		card = 1;
		break;
	  default:
		card = 0;
		break;
	}
	return (pp->hand[card] != C_INIT);
}

void
account(CARD card)
{
	CARD	oppos;

	if (card == C_INIT)
		return;
	++Numseen[card];
	if (Play == COMP)
		switch (card) {
		  case C_GAS_SAFE:
		  case C_SPARE_SAFE:
		  case C_DRIVE_SAFE:
			oppos = opposite(card);
			Numgos += Numcards[oppos] - Numseen[oppos];
			break;
		  case C_CRASH:
		  case C_FLAT:
		  case C_EMPTY:
		  case C_STOP:
			Numgos++;
			break;
		}
}

void
prompt(int promptno)
{
	static const char	*const names[] = {
				">>:Move:",
				"Really?",
				"Another hand?",
				"Another game?",
				"Save game?",
				"Same file?",
				"file:",
				"Extension?",
				"Overwrite file?",
			};
	static int	last_prompt = -1;

	if (promptno == last_prompt)
		move(MOVE_Y, MOVE_X + strlen(names[promptno]) + 1);
	else {
		move(MOVE_Y, MOVE_X);
		if (promptno == MOVEPROMPT)
			standout();
		addstr(names[promptno]);
		if (promptno == MOVEPROMPT)
			standend();
		addch(' ');
		last_prompt = promptno;
	}
	clrtoeol();
}

void
sort(CARD *hand)
{
	CARD	*cp, *tp;
	CARD	temp;

	cp = hand;
	hand += HAND_SZ;
	for ( ; cp < &hand[-1]; cp++)
		for (tp = cp + 1; tp < hand; tp++)
			if (*cp > *tp) {
				temp = *cp;
				*cp = *tp;
				*tp = temp;
			}
}
@


1.16
log
@Headers cleanup and also the following:

mille.h:
#define CTRL locally, which is used by move.c and misc.c, to avoid including
termios.h or sys/ttydefaults.h where it's actually defined

varpush.c:
Change _PATH_DEVNULL to "/dev/null" since other systems may not have it defined
but also avoids including <paths.h>

Included a few sugestions from tb@@ who also gave his OK
@
text
@d1 1
a1 1
/*	$OpenBSD: move.c,v 1.15 2015/11/04 21:22:10 tedu Exp $	*/
d47 1
a47 1
domove()
d151 1
a151 1
check_go()
d182 1
a182 2
playcard(pp)
	PLAY	*pp;
d328 1
a328 1
getmove()
d464 1
a464 2
haspicked(pp)
	const PLAY	*pp;
d483 1
a483 2
account(card)
	CARD	card;
d508 1
a508 2
prompt(promptno)
	int	promptno;
d539 1
a539 2
sort(hand)
	CARD	*hand;
@


1.15
log
@replace setbuf with setvbuf, from Frederic Nowak
@
text
@d1 1
a1 1
/*	$OpenBSD: move.c,v 1.14 2015/10/24 17:51:59 mmcc Exp $	*/
d33 8
a40 3
#include	<limits.h>
#include	<termios.h>
#include	"mille.h"
a44 3

#undef	CTRL
#define	CTRL(c)		(c - 'A' + 1)
@


1.14
log
@Cast ctype functions' arguments to unsigned char.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: move.c,v 1.13 2014/11/16 04:49:48 guenther Exp $	*/
d445 1
a445 1
				setbuf(outf, (char *)NULL);
@


1.13
log
@Eliminate pointless use of <sys/param.h>, <sys/file.h>, <sys/sockio.h>,
    and <sys/ttydefaults.h>
Replace MAXPATHLEN with PATH_MAX and MAXLOGNAME with LOGIN_NAME_MAX
Pull in <limits.h> where needed
Prefer sizeof(var) over MAXFOO or FOO_MAX

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: move.c,v 1.12 2009/12/10 23:53:05 beck Exp $	*/
d348 3
a350 3
		if (islower(c))
			c = toupper(c);
		if (isprint(c) && !isspace(c)) {
@


1.12
log
@fix potential bugs spotted by parfait
ok millert@@ pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: move.c,v 1.11 2009/10/27 23:59:25 deraadt Exp $	*/
d33 2
a34 5
#ifdef DEBUG
#include <sys/param.h>
#endif

#include <termios.h>
d417 1
a417 1
				char	buf[MAXPATHLEN];
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: move.c,v 1.10 2003/06/03 03:01:40 millert Exp $	*/
d133 5
a137 5
				for (j = 0; pp->hand[j] == C_INIT; j++)
					if (j >= HAND_SZ) {
						j = 0;
						break;
					}
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: move.c,v 1.9 2001/09/03 21:36:12 pjanzen Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)move.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: move.c,v 1.9 2001/09/03 21:36:12 pjanzen Exp $";
#endif
#endif /* not lint */
@


1.9
log
@Tidying, some from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: move.c,v 1.8 2000/08/05 21:57:41 pjanzen Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: move.c,v 1.8 2000/08/05 21:57:41 pjanzen Exp $";
@


1.8
log
@Remove a little redundant and slightly wrong code
@
text
@d1 1
a1 1
/*	$OpenBSD: move.c,v 1.7 1999/11/25 11:07:53 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: move.c,v 1.7 1999/11/25 11:07:53 pjanzen Exp $";
d82 1
a82 1
				if (issafety(pp->hand[Card_no])) {
d115 1
a115 1
				if (issafety(*Topcard))
d174 1
a174 1
			if (issafety(card) || canplay(pp, op, card)) {
d178 1
a178 1
					fprintf(outf, "issafety(card) = %d, ", issafety(card));
d251 1
a251 1
		    && !isrepair(pp->battle))
d321 1
a321 1
			    (!pp->can_go && isrepair(pp->battle))) {
@


1.7
log
@Fix an obscure bug involving misidentified coup fourres.
@
text
@d1 1
a1 1
/*	$OpenBSD: move.c,v 1.6 1999/09/30 03:23:59 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: move.c,v 1.6 1999/09/30 03:23:59 pjanzen Exp $";
a299 4
			pp->battle = C_GO;
			pp->can_go = TRUE;
			if (card == C_RIGHT_WAY && pp->speed == C_LIMIT)
				pp->speed = C_INIT;
@


1.6
log
@Disallow "Go" after "Right of Way" and change Battle Pile status to "Go" when
appropriate when playing "Right of Way".
@
text
@d1 1
a1 1
/*	$OpenBSD: move.c,v 1.5 1999/09/25 15:52:20 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: move.c,v 1.5 1999/09/25 15:52:20 pjanzen Exp $";
d293 9
a301 6
		if (pp->battle == opposite(card)
		    || (card == C_RIGHT_WAY && pp->speed == C_LIMIT)) {
			if (!(card == C_RIGHT_WAY && !isrepair(pp->battle))) {
				pp->battle = C_GO;
				pp->can_go = TRUE;
			}
a303 7
			if (pp->new_battle
			    || (pp->new_speed && card == C_RIGHT_WAY)) {
				pp->coups[card - S_CONV] = TRUE;
				pp->total += SC_COUP;
				pp->hand_tot += SC_COUP;
				pp->coupscore += SC_COUP;
			}
d317 4
d324 2
a325 5
			if (pp->battle == C_STOP || pp->battle == C_INIT) {
				pp->can_go = TRUE;
				pp->battle = C_GO;
			}
			if (!pp->can_go && isrepair(pp->battle)) {
@


1.5
log
@Tidying and minor changes from or based on jsm28@@cam.ac.uk's work for the
Linux bsd-games package and NetBSD.  Mainly using 'const'.
@
text
@d1 1
a1 1
/*	$OpenBSD: move.c,v 1.4 1998/09/22 04:08:24 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: move.c,v 1.4 1998/09/22 04:08:24 pjanzen Exp $";
d254 2
d326 1
a326 1
				pp->battle = C_INIT;
d328 1
a328 1
			if (!pp->can_go && isrepair(pp->battle))
d330 2
@


1.4
log
@NetBSD changes and further fixes (reformatted man page, better handling of
user input).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD$";
a51 5
# ifdef	attron
#	include	<term.h>
#	define	_tty	cur_term->Nttyb
# endif	attron

a58 4
char	*Movenames[] = {
		"M_DISCARD", "M_DRAW", "M_PLAY", "M_ORDER"
	};

d482 1
a482 1
	PLAY	*pp;
d530 1
a530 1
	static char	*names[] = {
@


1.3
log
@Changes from NetBSD to compile games without warnings due to short being
unsigned on some archs, PowerPC, ROMP.
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: move.c,v 1.4 1995/03/24 05:01:57 cgd Exp $";
d45 4
a49 1

d68 1
d71 3
a73 3
	register PLAY	*pp;
	register int		i, j;
	register bool	goodplay;
d85 1
a85 1
			if (pp->hand[Card_no] == C_INIT)
d90 1
a90 1
			else {
d172 6
a177 5
check_go() {

	register CARD	card;
	register PLAY	*pp, *op;
	register int		i;
d203 1
d205 1
a205 1
register PLAY	*pp;
d207 2
a208 2
	register int		v;
	register CARD	card;
d353 1
d356 4
a359 1
	register char	c, *sp;
d405 1
a405 1
			rub();		/* Same as a rubout */
d445 1
a445 1

d450 2
a451 1
				while ((*sp = readch()) != '\n') {
d471 1
a471 1
					perror(buf);
d485 1
d489 1
d491 3
a493 3
register PLAY	*pp; {

	register int	card;
d509 1
d511 3
a513 3
register CARD	card; {

	register CARD	oppos;
d535 1
d537 1
a537 1
int	promptno;
d567 1
d569 1
a569 1
register CARD	*hand;
d571 2
a572 2
	register CARD	*cp, *tp;
	register CARD	temp;
a583 1

@


1.2
log
@Update for modern curses implementation
@
text
@d342 1
a342 1
	Next = (Next == -1 ? FALSE : TRUE);
@


1.1
log
@Initial revision
@
text
@a46 3
#ifndef	unctrl
#include	"unctrl.h"
#endif
d66 3
a68 3
	reg PLAY	*pp;
	reg int		i, j;
	reg bool	goodplay;
d169 3
a171 3
	reg CARD	card;
	reg PLAY	*pp, *op;
	reg int		i;
d198 1
a198 1
reg PLAY	*pp;
d200 2
a201 2
	reg int		v;
	reg CARD	card;
d348 1
a348 1
	reg char	c, *sp;
d477 1
a477 1
reg PLAY	*pp; {
d479 1
a479 1
	reg int	card;
d496 1
a496 1
reg CARD	card; {
d498 1
a498 1
	reg CARD	oppos;
d552 1
a552 1
reg CARD	*hand;
d554 2
a555 2
	reg CARD	*cp, *tp;
	reg CARD	temp;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
