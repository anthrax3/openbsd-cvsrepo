head	1.24;
access;
symbols
	OPENBSD_6_2:1.24.0.2
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.23.0.8
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.6
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.16
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.14
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.12
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.14
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.10
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.8
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.6
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.4
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.14.0.10
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.8
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.6
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.4
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.6.0.6
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2017.07.11.14.32.16;	author fcambus;	state Exp;
branches;
next	1.23;
commitid	h6HBMe2Yu85VQyEu;

1.23
date	2016.01.03.14.38.16;	author mestre;	state Exp;
branches;
next	1.22;
commitid	Ptgw9rNvmSHNRfGy;

1.22
date	2015.12.02.20.05.01;	author tb;	state Exp;
branches;
next	1.21;
commitid	d7NTsg9vGQclKcoo;

1.21
date	2015.12.01.07.43.30;	author tb;	state Exp;
branches;
next	1.20;
commitid	ufi68e73oXzP9Vgz;

1.20
date	2015.12.01.00.31.46;	author tb;	state Exp;
branches;
next	1.19;
commitid	gBJqMkQlo1TXTWFh;

1.19
date	2015.11.30.08.19.25;	author tb;	state Exp;
branches;
next	1.18;
commitid	DsnnMPnBHkgAj0Eo;

1.18
date	2015.06.26.19.18.03;	author otto;	state Exp;
branches;
next	1.17;
commitid	rLN6ksd9DcCJ3lkE;

1.17
date	2013.08.29.20.22.09;	author naddy;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.27.23.59.23;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2006.10.29.20.02.41;	author martin;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.05.14.24.45;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.03.03.01.38;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.12.06.21.48.50;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.31.03.40.00;	author pjanzen;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.09.07.04.27;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.23.23.49.54;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.18.03.32.49;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.04.20.37.54;	author todd;	state Exp;
branches;
next	1.6;

1.6
date	99.07.31.21.57.35;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	98.08.29.23.19.07;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	98.03.19.11.13.07;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	96.12.22.20.00.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.12.19.22.20.54;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.39;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@User count checks have been compiled out since 1998, get rid of them.

OK mlarkin@@
@
text
@/*	$OpenBSD: main.c,v 1.23 2016/01/03 14:38:16 mestre Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <err.h>

#include "back.h"
#include "backlocal.h"

#define MVPAUSE	5		/* time to sleep when stuck */

extern const char   *const instruct[];		/* text of instructions */

const char   *const helpm[] = {		/* help message */
	"Enter a space or newline to roll, or",
	"     R   to reprint the board\tD   to double",
	"     S   to save the game\tQ   to quit",
	0
};

const char   *const contin[] = {		/* pause message */
	"(Type a newline to continue.)",
	"",
	0
};

/*   *** Do game control through dm! ***
 * static char user1a[] =
 * 	"Sorry, you cannot play backgammon when there are more than ";
 * static char user1b[] =
 * 	" users\non the system.";
 * static char user2a[] =
 * 	"\nThere are now more than ";
 * static char user2b[] =
 * 	" users on the system, so you cannot play\nanother game.  ";
 */
static const char rules[] = "\nDo you want the rules of the game?";
static const char noteach[] = "Teachgammon not available!\n\007";
static const char need[] = "Do you need instructions for this program?";
static const char askcol[] =
	"Enter 'r' to play red, 'w' to play white, 'b' to play both:";
static const char rollr[] = "Red rolls a ";
static const char rollw[] = ".  White rolls a ";
static const char rstart[] = ".  Red starts.\n";
static const char wstart[] = ".  White starts.\n";
static const char toobad1[] = "Too bad, ";
static const char unable[] = " is unable to use that roll.\n";
static const char toobad2[] = ".  Too bad, ";
static const char cantmv[] = " can't move.\n";
static const char bgammon[] = "Backgammon!  ";
static const char gammon[] = "Gammon!  ";
static const char again[] = ".\nWould you like to play again?";
static const char svpromt[] = "Would you like to save this game?";

int
main (int argc, char **argv)
{
	int     i,l;		/* non-descript indices */
	char    c;		/* non-descript character storage */

	if (pledge("stdio rpath wpath cpath tty exec", NULL) == -1)
		err(1, "pledge");

	signal(SIGINT, getout);	/* trap interrupts */

	/* use whole screen for text */
	begscr = 0;

	getarg(argc, argv);

	initcurses();

	/* check if restored game and save flag for later */
	if ((rfl = rflag)) {
		if (pledge("stdio rpath wpath cpath tty", NULL) == -1)
			err(1, "pledge");

		wrboard();	/* print board */
		/* if new game, pretend to be a non-restored game */
		if (cturn == 0)
			rflag = 0;
	} else {
		rscore = wscore = 0;	/* zero score */

		if (aflag) {	/* print rules */
			addstr(rules);
			if (yorn(0)) {
				endwin();
				execl(TEACH, "teachgammon", (char *)NULL);

				err(1, "%s", noteach);
			} else {/* if not rules, then instructions */
				addstr(need);
				if (yorn(0)) {	/* print instructions */
					clear();
					text(instruct);
				}
			}
		}

		if (pledge("stdio rpath wpath cpath tty", NULL) == -1)
			err(1, "pledge");

		init();		/* initialize board */

		if (pnum == 2) {/* ask for color(s) */
			printw("\n%s", askcol);
			while (pnum == 2) {
				c = readc();
				switch (c) {

				case 'R':	/* red */
					pnum = -1;
					break;

				case 'W':	/* white */
					pnum = 1;
					break;

				case 'B':	/* both */
					pnum = 0;
					break;

				case 'P':	/* Control the dice */
					iroll = 1;
					addstr("\nDice controlled!\n");
					addstr(askcol);
					break;

				default:	/* error */
					beep();
				}
			}
		}

		wrboard();		/* print board */

		move(18, 0);
	}
	/* limit text to bottom of screen */
	begscr = 17;

	for (;;)  {			/* begin game! */
		/* initial roll if needed */
		if ((!rflag) || raflag)
			roll();

		/* perform ritual of first roll */
		if (!rflag) {
			move(17, 0);
			while (D0 == D1)	/* no doubles */
				roll();

			/* print rolls */
			printw("%s%d%s%d", rollr, D0, rollw, D1);

			/* winner goes first */
			if (D0 > D1) {
				addstr(rstart);
				cturn = 1;
			} else {
				addstr(wstart);
				cturn = -1;
			}
		}
		/* initialize variables according to whose turn it is */

		if (cturn == 1) {	/* red */
			home = 25;
			bar = 0;
			inptr = &in[1];
			inopp = &in[0];
			offptr = &off[1];
			offopp = &off[0];
			Colorptr = &color[1];
			colorptr = &color[3];
			colen = 3;
		} else {		/* white */
			home = 0;
			bar = 25;
			inptr = &in[0];
			inopp = &in[1];
			offptr = &off[0];
			offopp = &off[1];
			Colorptr = &color[0];
			colorptr = &color[2];
			colen = 5;
		}

		/* do first move (special case) */
		if (!(rflag && raflag)) {
			if (cturn == pnum)	/* computer's move */
				domove(0);
			else {	/* player's move */
				mvlim = movallow();
				/* reprint roll */
				move(cturn == -1 ? 18 : 19, 0);
				proll();
				getmove();	/* get player's move */
			}
		}
		move(17, 0);
		clrtoeol();
		begscr = 18;
		/* no longer any difference between normal and recovered game. */
		rflag = 0;

		/* move as long as it's someone's turn */
		while (cturn == 1 || cturn == -1) {

			/* board maintainence */
			moveplayers();	/* fix board */

			/* do computer's move */
			if (cturn == pnum) {
				domove(1);

				/* see if double refused */
				if (cturn == -2 || cturn == 2)
					break;

				/* check for winning move */
				if (*offopp == 15) {
					cturn *= -2;
					break;
				}
				continue;

			}
			/* (player's move) */

			/* clean screen if safe */
			if (hflag) {
				move(20, 0);
				clrtobot();
				hflag = 1;
			}
			/* if allowed, give him a chance to double */
			if (dflag && dlast != cturn && gvalue < 64) {
				move(cturn == -1 ? 18: 19, 0);
				addstr(*Colorptr);
				c = readc();

				/* character cases */
				switch (c) {

				case 'R':		/* reprint board */
					wrboard();
					break;

				case 'S':		/* save game */
					raflag = 1;
					save(1);
					break;

				case 'Q':		/* quit */
					quit();
					break;

				case 'D':		/* double */
					dble();
					break;

				case ' ':		/* roll */
				case '\n':
					roll();
					printw(" rolls %d %d.  ", D0, D1);

					/* see if he can move */
					if ((mvlim = movallow()) == 0) {

						/* can't move */
						printw("%s%s%s", toobad1, *colorptr, unable);
						if (pnum) {
							moveplayers();
							sleep(MVPAUSE);
						}
						nexturn();
						break;
					}

					getmove();

					/* okay to clean screen */
					hflag = 1;
					break;

				default:		/* invalid character */

					/* print help message */
					move(20, 0);
					text(helpm);
					move(cturn == -1 ? 18 : 19, 0);

					/* don't erase */
					hflag = 0;
				}
			} else {/* couldn't double */

				/* print roll */
				roll();
				move(cturn == -1 ? 18: 19, 0);
				proll();

				/* can he move? */
				if ((mvlim = movallow()) == 0) {

					/* he can't */
					printw("%s%s%s", toobad2, *colorptr, cantmv);
					moveplayers();
					sleep(MVPAUSE);
					nexturn();
					continue;
				}

				getmove();
			}
		}

		/* don't worry about who won if quit */
		if (cturn == 0)
			break;

		/* fix cturn = winner */
		cturn /= -2;

		/* final board pos. */
		moveplayers();

		/* backgammon? */
		mflag = 0;
		l = bar + 7 * cturn;
		for (i = bar; i != l; i += cturn)
			if (board[i] * cturn)
				mflag++;

		/* compute game value */
		move(20, 0);
		if (*offopp == 15) {
			if (mflag) {
				addstr(bgammon);
				gvalue *= 3;
			}
			else if (*offptr <= 0) {
				addstr(gammon);
				gvalue *= 2;
			}
		}
		/* report situation */
		if (cturn == -1) {
			addstr("Red wins ");
			rscore += gvalue;
		} else {
			addstr("White wins ");
			wscore += gvalue;
		}
		printw("%d point%s.\n", gvalue, (gvalue > 1) ? "s":"");

		/* write score */
		wrscore();

		/* see if he wants another game */
		addstr(again);
		if ((i = yorn('S')) == 0)
			break;

		init();
		if (i == 2) {
			addstr("  Save.\n");
			cturn = 0;
			save(0);
		}
		/* yes, reset game */
		wrboard();
	}

	/* give him a chance to save if game was recovered */
	if (rfl && cturn) {
		addstr(svpromt);
		if (yorn(0)) {
			/* re-initialize for recovery */
			init();
			cturn = 0;
			save(0);
		}
	}
	/* leave peacefully */
	getout(0);
	/* NOT REACHED */
}
@


1.23
log
@About 13 years ago when the idiom srandom(time()), and sometimes
srandom(time()+getpid()), was changed by srandomdev(), but #include <time.h>
lived up until this day so remove it.

Additionally, earlier than that, 18 years ago, random(6) was one of the first
consumers of arc4random(3) family, and was pulling it from dev/rndvar.h but
these days we pull it from stdlib.h, which is already done, so while here
remove dev/rndvar.h also.

"seems comprehensive to me" deraadt@@ and OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 2015/12/02 20:05:01 tb Exp $	*/
a37 1
/* #define MAXUSERS 35	*/		/* maximum number of users */
a92 8
/* check user count */
#if 0
	if (ucount() > MAXUSERS)  {
		printw("%s%d%s", user1a, MAXUSERS, user1b);
		getout(0);
	}
#endif

a387 9

/* check user count */
#if 0
		if (ucount() > MAXUSERS)  {
			printw("%s%d%s", user2a, MAXUSERS, user2b);
			rfl = 1;
			break;
		}
#endif
@


1.22
log
@Drop the argument passing between backgammon and teachgammon.
It's broken.  Instead, make -d imply -n.  You're supposed to
know the rules before you start tweaking them.

Issue reported by and ok pjanzen@@
Patient help with the manual jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 2015/12/01 07:43:30 tb Exp $	*/
d33 1
a33 1
#include <time.h>
@


1.21
log
@Make sure "exec" rights are dropped asap in all code paths.
The game also needs "wpath cpath" for supporting the score file,
so add those.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 2015/12/01 00:31:46 tb Exp $	*/
a105 1
	args[acnt] = '\0';
d125 1
a125 1
				execl(TEACH, "teachgammon", args, (char *)NULL);
@


1.20
log
@Answering "yes" to the question "Do you want to see the rules of the game?"
execs teachgammon.  Allow this and drop this pledge afterward.

Spotted by Paul Janzen, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 2015/11/30 08:19:25 tb Exp $	*/
d89 1
a89 1
	if (pledge("stdio rpath tty exec", NULL) == -1)
d112 3
d138 1
a138 1
		if (pledge("stdio rpath tty", NULL) == -1)
@


1.19
log
@Pledge for backgammon and teachgammon.

Both are straightforward "stdio rpath tty" programs; teachgammon
exec's backgammon at the end, so give it "exec" in addition.

While there, ANSIfy
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 2015/06/26 19:18:03 otto Exp $	*/
d89 1
a89 1
	if (pledge("stdio rpath tty", NULL) == -1)
d134 4
@


1.18
log
@/home/otto/ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 2013/08/29 20:22:09 naddy Exp $	*/
d84 1
a84 3
main (argc,argv)
	int     argc;
	char  **argv;
d88 3
@


1.17
log
@replace srandomdev()+random() with the arc4random*() family
tweaks and ok millert@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.16 2009/10/27 23:59:23 deraadt Exp $	*/
d268 1
a268 1
			if (dlast != cturn && gvalue < 64) {
d290 1
a290 2
					if (dflag != 0)
						dble();
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 2006/10/29 20:02:41 martin Exp $	*/
a102 1
	srandomdev();		/* seed random number generator */
@


1.15
log
@-d: make it possible playing without doubling as it is not commonly
played everywhere in the world

ok todd@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 2004/04/05 14:24:45 aaron Exp $	*/
a30 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)main.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: main.c,v 1.14 2004/04/05 14:24:45 aaron Exp $";
#endif
#endif /* not lint */
@


1.14
log
@Don't init curses until after option processing. pjanzen@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 2003/06/03 03:01:38 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.13 2003/06/03 03:01:38 millert Exp $";
d305 2
a306 1
					dble();
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 2002/12/06 21:48:50 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.12 2002/12/06 21:48:50 millert Exp $";
a105 1
	initcurses();
d121 2
@


1.12
log
@Replace things like srandom(time(NULL)) with srandomdev(3).  random(3)
good enough for games but we should at least use a decent seed.
pjanzen@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 2002/05/31 03:40:00 pjanzen Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.11 2002/05/31 03:40:00 pjanzen Exp $";
@


1.11
log
@No dm -> no need to revoke setegid.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 2001/07/09 07:04:27 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.10 2001/07/09 07:04:27 deraadt Exp $";
a107 1
	long	   t;		/* time for random num generator */
d122 1
a122 2
	t = time(NULL);
	srandom(t);		/* 'random' seed */
@


1.10
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 2001/06/23 23:49:54 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.9 2001/06/23 23:49:54 pjanzen Exp $";
a108 4

	/* revoke privs */
	setegid(getgid());
	setgid(getgid());
@


1.9
log
@termios -> curses
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 2001/02/18 03:32:49 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.8 2001/02/18 03:32:49 pjanzen Exp $";
d146 1
a146 1
				execl(TEACH, "teachgammon", args, 0);
@


1.8
log
@Get this not to segfault on startup on alpha.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 2001/01/04 20:37:54 todd Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.7 2001/01/04 20:37:54 todd Exp $";
d50 1
d58 1
a58 1
extern const char   *const instr[];		/* text of instructions */
a113 2
	/* initialization */
	bflag = 2;		/* default no board */
d115 1
a115 6
	if (tcgetattr(0, &old) == -1)	/* get old tty mode */
		errexit("backgammon(gtty)");
	noech = old;
	noech.c_lflag &= ~ECHO;
	traw = noech;
	traw.c_lflag &= ~ICANON;	/* set up modes */
d120 1
a120 3
		writel(user1a);
		wrint(MAXUSERS);
		writel(user1b);
a124 2
	/* get terminal capabilities, and decide if it can cursor address */
	tflag = getcaps(getenv("TERM"));
d126 2
a127 3
	if (tflag)
		begscr = 0;
	t = time(0);
a131 6
	if (tflag) {		/* clear screen */
		noech.c_oflag &= ~(ONLCR | OXTABS);
		traw.c_oflag &= ~(ONLCR | OXTABS);
		clear();
	}
	fixtty(&traw);		/* go into raw mode */
d143 1
a143 1
			writel(rules);
d145 1
a145 1
				fixtty(&old);	/* restore tty */
d148 1
a148 3
				tflag = 0;	/* error! */
				writel(noteach);
				exit(1);
d150 1
a150 1
				writel(need);
d153 1
a153 1
					text(instr);
d160 1
a160 2
			writec('\n');
			writel(askcol);
d179 2
a180 4
					writec('\n');
					writel("Dice controlled!");
					writec('\n');
					writel(askcol);
d184 1
a184 1
					writec('\007');
d191 1
a191 4
		if (tflag)
			curmove(18, 0);
		else
			writec('\n');
d194 1
a194 2
	if (tflag)
		begscr = 17;
d203 1
a203 2
			if (tflag)
				curmove(17, 0);
d208 1
a208 4
			writel(rollr);
			writec(D0 + '0');
			writel(rollw);
			writec(D1 + '0');
d212 1
a212 1
				writel(rstart);
d215 1
a215 1
				writel(wstart);
d246 1
a246 1
				move(0);
d250 1
a250 2
				if (tflag)
					curmove(cturn == -1 ? 18 : 19, 0);
d255 3
a257 5
		if (tflag) {
			curmove(17, 0);
			cline();
			begscr = 18;
		}
d265 1
a265 6
			if (tflag)
				refresh();	/* fix board */
			else
				/* redo board if -p */
				if (cturn == bflag || bflag == 0)
					wrboard();
d269 1
a269 1
				move(1);
d286 3
a288 3
			if (tflag && hflag) {
				curmove(20, 0);
				clend();
d293 2
a294 3
				if (tflag)
					curmove(cturn == -1 ? 18: 19, 0);
				writel(*Colorptr);
d320 1
a320 5
					writel(" rolls ");
					writec(D0 + '0');
					writec(' ');
					writec(D1 + '0');
					writel(".  ");
d326 4
a329 8
						writel(toobad1);
						writel(*colorptr);
						writel(unable);
						if (tflag) {
							if (pnum) {
								buflush();
								sleep(MVPAUSE);
							}
d344 1
a344 4
					if (tflag)
						curmove(20, 0);
					else
						writec('\n');
d346 1
a346 4
					if (tflag)
						curmove(cturn == -1 ? 18 : 19, 0);
					else
						writec('\n');
d355 1
a355 2
				if (tflag)
					curmove(cturn == -1 ? 18: 19, 0);
d362 2
a363 4
					writel(toobad2);
					writel(*colorptr);
					writel(cantmv);
					buflush();
d381 1
a381 2
		if (tflag)
			refresh();
d391 1
a391 2
		if (tflag)
			curmove(20, 0);
d394 1
a394 1
				writel(bgammon);
d398 1
a398 1
				writel(gammon);
d404 1
a404 1
			writel("Red wins ");
d407 1
a407 1
			writel("White wins ");
d410 1
a410 5
		wrint(gvalue);
		writel(" point");
		if (gvalue > 1)
			writec('s');
		writel(".\n");
d418 1
a418 3
			writel (user2a);
			wrint (MAXUSERS);
			writel (user2b);
d425 1
a425 1
		writel(again);
d431 1
a431 1
			writel("  Save.\n");
d441 1
a441 1
		writel(svpromt);
@


1.7
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 1999/07/31 21:57:35 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.6 1999/07/31 21:57:35 pjanzen Exp $";
a57 1
speed_t ospeed;				/* tty output speed */
d120 2
a121 3
	raw = noech;
	raw.c_lflag &= ~ICANON;	/* set up modes */
	ospeed = cfgetospeed(&old);	/* for termlib */
d145 1
a145 1
		raw.c_oflag &= ~(ONLCR | OXTABS);
d148 1
a148 1
	fixtty(&raw);		/* go into raw mode */
@


1.6
log
@use const where appropriate (jsm28@@cam.ac.uk).  Also some very minor tidying.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 1998/08/29 23:19:07 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.5 1998/08/29 23:19:07 pjanzen Exp $";
d251 1
a251 1
		/* initalize variables according to whose turn it is */
@


1.5
log
@use names rather than numbers in signals, errors, etc; NetBSD PR6058; jsm28@@cam.ac.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.4 1998/03/19 11:13:07 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.4 1998/03/19 11:13:07 pjanzen Exp $";
d57 2
a58 2
char   *instr[];		/* text of instructions */
speed_t ospeed;			/* tty output speed */
d60 1
a60 1
char   *helpm[] = {		/* help message */
d67 1
a67 1
char   *contin[] = {		/* pause message */
d83 4
a86 4
static char rules[] = "\nDo you want the rules of the game?";
static char noteach[] = "Teachgammon not available!\n\007";
static char need[] = "Do you need instructions for this program?";
static char askcol[] =
d88 12
a99 12
static char rollr[] = "Red rolls a ";
static char rollw[] = ".  White rolls a ";
static char rstart[] = ".  Red starts.\n";
static char wstart[] = ".  White starts.\n";
static char toobad1[] = "Too bad, ";
static char unable[] = " is unable to use that roll.\n";
static char toobad2[] = ".  Too bad, ";
static char cantmv[] = " can't move.\n";
static char bgammon[] = "Backgammon!  ";
static char gammon[] = "Gammon!  ";
static char again[] = ".\nWould you like to play again?";
static char svpromt[] = "Would you like to save this game?";
d153 1
a153 1
	if (rfl = rflag) {
@


1.4
log
@NetBSD changes and further improvements and corrections
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD$";
d116 1
a116 1
	signal(2, getout);	/* trap interrupts */
@


1.3
log
@proper gid revoke
@
text
@d1 1
a1 1
/*	$NetBSD: main.c,v 1.4 1995/04/29 00:44:03 mycroft Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: main.c,v 1.4 1995/04/29 00:44:03 mycroft Exp $";
d50 1
a50 1
#include <stdio.h>
d52 1
d54 2
a55 2
#define MVPAUSE	5				/* time to sleep when stuck */
#define MAXUSERS 35				/* maximum number of users */
d57 2
a58 3
char	*instr[];				/* text of instructions */
char	*message[];				/* update message */
speed_t	ospeed;					/* tty output speed */
d60 1
a60 1
char	*helpm[] = {				/* help message */
d67 1
a67 1
char	*contin[] = {				/* pause message */
d73 14
a86 12
static char user1a[] =
	"Sorry, you cannot play backgammon when there are more than ";
static char user1b[] =
	" users\non the system.";
static char user2a[] =
	"\nThere are now more than ";
static char user2b[] =
	" users on the system, so you cannot play\nanother game.  ";
static char	rules[] = "\nDo you want the rules of the game?";
static char	noteach[] = "Teachgammon not available!\n\007";
static char	need[] = "Do you need instructions for this program?";
static char	askcol[] =
d88 12
a99 15
static char	rollr[] = "Red rolls a ";
static char	rollw[] = ".  White rolls a ";
static char	rstart[] = ".  Red starts.\n";
static char	wstart[] = ".  White starts.\n";
static char	toobad1[] = "Too bad, ";
static char	unable[] = " is unable to use that roll.\n";
static char	toobad2[] = ".  Too bad, ";
static char	cantmv[] = " can't move.\n";
static char	bgammon[] = "Backgammon!  ";
static char	gammon[] = "Gammon!  ";
static char	again[] = ".\nWould you like to play again?";
static char	svpromt[] = "Would you like to save this game?";

static char	password[] = "losfurng";
static char	pbuf[10];
d101 1
d103 2
a104 3
int	argc;
char	**argv;

d106 3
a108 4
	register int	i;		/* non-descript index */
	register int	l;		/* non-descript index */
	register char	c;		/* non-descript character storage */
	long	t;			/* time for random num generator */
d115 4
a118 4
	bflag = 2;					/* default no board */
	signal (2, getout);				/* trap interrupts */
	if (tcgetattr (0, &old) == -1)			/* get old tty mode */
		errexit ("backgammon(gtty)");
d122 2
a123 2
	raw.c_lflag &= ~ICANON;				/* set up modes */
	ospeed = cfgetospeed (&old);			/* for termlib */
d125 2
a126 2
							/* check user count */
# ifdef CORY
d128 4
a131 4
		writel (user1a);
		wrint (MAXUSERS);
		writel (user1b);
		getout();
d133 1
a133 1
# endif
d135 3
a137 7
							/* get terminal
							 * capabilities, and
					   		 * decide if it can
							 * cursor address */
	tflag = getcaps (getenv ("TERM"));
							/* use whole screen
							 * for text */
d141 1
a141 1
	srandom(t);					/* 'random' seed */
d143 1
a143 6
#ifdef V7
	while (*++argv != 0)				/* process arguments */
#else
	while (*++argv != -1)				/* process arguments */
#endif
		getarg (&argv);
d145 3
a147 3
	if (tflag)  {					/* clear screen */
		noech.c_oflag &= ~(ONLCR|OXTABS);
		raw.c_oflag &= ~(ONLCR|OXTABS);
d150 1
a150 1
	fixtty (&raw);					/* go into raw mode */
d152 4
a155 10
							/* check if restored
							 * game and save flag
							 * for later */
	if (rfl = rflag)  {
		text (message);				/* print message */
		text (contin);
		wrboard();				/* print board */
							/* if new game, pretend
							 * to be a non-restored
							 * game */
d158 2
a159 8
	} else  {
		rscore = wscore = 0;			/* zero score */
		text (message);				/* update message
							 * without pausing */

		if (aflag)  {				/* print rules */
			writel (rules);
			if (yorn(0))  {
d161 5
a165 2
				fixtty (&old);		/* restore tty */
				execl (TEACH,"teachgammon",args,0);
d167 2
a168 2
				tflag = 0;		/* error! */
				writel (noteach);
d170 3
a172 4
			} else  {			/* if not rules, then
							 * instructions */
				writel (need);
				if (yorn(0))  {		/* print instructions */
d174 1
a174 1
					text (instr);
d178 1
d180 4
a183 6
		init();					/* initialize board */

		if (pnum == 2)  {			/* ask for color(s) */
			writec ('\n');
			writel (askcol);
			while (pnum == 2)  {
d185 1
a185 1
				switch (c)  {
d187 1
a187 1
				case 'R':		/* red */
d191 1
a191 1
				case 'W':		/* white */
d195 1
a195 1
				case 'B':		/* both */
d199 1
a199 25
				case 'P':
					if (iroll)
						break;
					if (tflag)
						curmove (curr,0);
					else
						writec ('\n');
					writel ("Password:");
					signal (14,getout);
					cflag = 1;
					alarm (10);
					for (i = 0; i < 10; i++)  {
						pbuf[i] = readc();
						if (pbuf[i] == '\n')
							break;
					}
					if (i == 10)
						while (readc() != '\n');
					alarm (0);
					cflag = 0;
					if (i < 10)
						pbuf[i] = '\0';
					for (i = 0; i < 9; i++)
						if (pbuf[i] != password[i])
							getout();
d201 4
a204 5
					if (tflag)
						curmove (curr,0);
					else
						writec ('\n');
					writel (askcol);
d207 2
a208 2
				default:		/* error */
					writec ('\007');
d211 1
a211 4
		} else  if (!aflag)
							/* pause to read
							 * message */
			text (contin);
d213 1
a213 1
		wrboard();				/* print board */
d216 1
a216 1
			curmove (18,0);
d218 1
a218 1
			writec ('\n');
d220 1
a220 2
							/* limit text to bottom
							 * of screen */
d224 3
a226 4
	for (;;)  {					/* begin game! */
							/* initial roll if
							 * needed */
		if ((! rflag) || raflag)
d229 2
a230 3
							/* perform ritual of
							 * first roll */
		if (! rflag)  {
d232 2
a233 2
				curmove (17,0);
			while (D0 == D1)		/* no doubles */
d236 9
a244 9
							/* print rolls */
			writel (rollr);
			writec (D0+'0');
			writel (rollw);
			writec (D1+'0');

							/* winner goes first */
			if (D0 > D1)  {
				writel (rstart);
d246 2
a247 2
			} else  {
				writel (wstart);
d251 1
d253 1
a253 5
							/* initalize variables
							 * according to whose
							 * turn it is */

		if (cturn == 1)  {			    /* red */
d263 1
a263 1
		} else  {				    /* white */
d275 5
a279 6
							/* do first move
							 * (special case) */
		if (! (rflag && raflag))  {
			if (cturn == pnum)		/* computer's move */
				move (0);
			else  {				/* player's move */
d281 1
a281 1
							/* reprint roll */
d283 1
a283 1
					curmove (cturn == -1? 18: 19,0);
d285 1
a285 1
				getmove();		/* get player's move */
d288 2
a289 2
		if (tflag)  {
			curmove (17,0);
d293 1
a293 5

							/* no longer any diff-
							 * erence between normal
							 * game and recovered
							 * game. */
d296 2
a297 3
							/* move as long as it's
							 * someone's turn */
		while (cturn == 1 || cturn == -1)  {
d299 1
a299 1
							/* board maintainence */
d301 1
a301 1
				refresh();		/* fix board */
d303 1
a303 1
							/* redo board if -p */
d307 3
a309 3
							/* do computer's move */
			if (cturn == pnum)  {
				move (1);
d311 1
a311 2
							/* see if double
							 * refused */
d315 2
a316 3
							/* check for winning
							 * move */
				if (*offopp == 15)  {
d323 1
d325 4
a328 7
							/* (player's move) */

							/* clean screen if
							 * safe */
			if (tflag && hflag)  {
				curmove (20,0);
				clend ();
d331 2
a332 4

							/* if allowed, give him
							 * a chance to double */
			if (dlast != cturn && gvalue < 64)  {
d334 2
a335 2
					curmove (cturn == -1? 18: 19,0);
				writel (*Colorptr);
d338 2
a339 2
							/* character cases */
				switch (c)  {
d341 1
a341 2
							/* reprint board */
				case 'R':
d345 1
a345 2
							/* save game */
				case 'S':
d347 1
a347 1
					save (1);
d350 1
a350 2
							/* quit */
				case 'Q':
d354 1
a354 2
							/* double */
				case 'D':
d358 1
a358 2
							/* roll */
				case ' ':
d361 15
a375 15
					writel (" rolls ");
					writec (D0+'0');
					writec (' ');
					writec (D1+'0');
					writel (".  ");

							/* see if he can move */
					if ( (mvlim = movallow()) == 0)  {

							/* can't move */
						writel (toobad1);
						writel (*colorptr);
						writel (unable);
						if (tflag)  {
							if (pnum)  {
d377 1
a377 1
								sleep (MVPAUSE);
a383 1
							/* get move */
d386 1
a386 2
							/* okay to clean
							 * screen */
d390 1
a390 2
							/* invalid character */
				default:
d392 1
a392 1
							/* print help message */
d394 1
a394 1
						curmove (20,0);
d396 2
a397 2
						writec ('\n');
					text (helpm);
d399 1
a399 1
						curmove (cturn == -1? 18: 19,0);
d401 1
a401 1
						writec ('\n');
d403 1
a403 1
							/* don't erase */
d406 1
a406 1
			} else  {			/* couldn't double */
d408 1
a408 1
							/* print roll */
d411 2
a412 2
					curmove (cturn == -1? 18: 19,0);
				proll ();
d414 2
a415 2
							/* can he move? */
				if ((mvlim = movallow()) == 0)  {
d417 4
a420 4
							/* he can't */
					writel (toobad2);
					writel (*colorptr);
					writel (cantmv);
d422 1
a422 1
					sleep (MVPAUSE);
a426 1
							/* get move */
d431 1
a431 2
							/* don't worry about who
							 * won if quit */
d435 1
a435 1
							/* fix cturn = winner */
d438 1
a438 1
							/* final board pos. */
d442 1
a442 1
							/* backgammon? */
d444 1
a444 1
		l = bar+7*cturn;
d446 2
a447 1
			if (board[i]*cturn)  mflag++;
d449 1
a449 1
							/* compute game value */
d451 4
a454 4
			curmove (20,0);
		if (*offopp == 15)  {
			if (mflag)  {
				writel (bgammon);
d457 2
a458 2
			else  if (*offptr <= 0)  {
				writel (gammon);
d462 3
a464 4

							/* report situation */
		if (cturn == -1)  {
			writel ("Red wins ");
d467 1
a467 1
			writel ("White wins ");
d470 2
a471 2
		wrint (gvalue);
		writel (" point");
d473 2
a474 2
			writec ('s');
		writel (".\n");
d476 1
a476 1
							/* write score */
d479 2
a480 2
							/* check user count */
# ifdef CORY
d488 1
a488 1
# endif
d490 3
a492 4
							/* see if he wants
							 * another game */
		writel (again);
		if ((i = yorn ('S')) == 0)
d496 2
a497 2
		if (i == 2)  {
			writel ("  Save.\n");
d499 1
a499 1
			save (0);
d501 1
a501 2

							/* yes, reset game */
d506 4
a509 5
	if (rfl && cturn)  {
		writel (svpromt);
		if (yorn (0))  {
							/* re-initialize for
							 * recovery */
d515 3
a517 3

							/* leave peacefully */
	getout ();
@


1.2
log
@setgid games, not setuid games. closes a neat set of holes
@
text
@d112 2
@


1.1
log
@Initial revision
@
text
@d112 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

