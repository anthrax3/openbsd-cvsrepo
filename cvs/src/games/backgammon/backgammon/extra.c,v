head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.8
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.6.0.18
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.22
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.20
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.16
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.14
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.12
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.10
	OPENBSD_5_0:1.6.0.8
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.6
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.5.0.14
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.10
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.8
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.6
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.4
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.4.0.14
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.3.0.8
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.6
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.4
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.2.0.14
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.12
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.10
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.8
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.11.30.08.19.25;	author tb;	state Exp;
branches;
next	1.7;
commitid	DsnnMPnBHkgAj0Eo;

1.7
date	2015.05.20.20.26.00;	author millert;	state Exp;
branches;
next	1.6;
commitid	zCzfilJDybc6sqWN;

1.6
date	2009.10.27.23.59.23;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2006.12.14.10.14.05;	author martin;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.03.03.01.38;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.23.23.49.53;	author pjanzen;	state Exp;
branches;
next	1.2;

1.2
date	98.03.19.11.13.06;	author pjanzen;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.39;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Pledge for backgammon and teachgammon.

Both are straightforward "stdio rpath tty" programs; teachgammon
exec's backgammon at the end, so give it "exec" in addition.

While there, ANSIfy
@
text
@/*	$OpenBSD: extra.c,v 1.7 2015/05/20 20:26:00 millert Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "back.h"
#include "backlocal.h"

/*
 * dble()
 *	Have the current player double and ask opponent to accept.
 */

void
dble(void)
{
	int     resp;		/* response to y/n */

	for (;;) {
		addstr(" doubles.");	/* indicate double */

		if (cturn == -pnum) {	/* see if computer accepts */
			if (dblgood()) {	/* guess not */
				addstr("  Declined.\n");
				nexturn();
				cturn *= -2;	/* indicate loss */
				return;
			} else {/* computer accepts */
				addstr("  Accepted.\n");
				gvalue *= 2;	/* double game value */
				dlast = cturn;
				gwrite();
				return;
			}
		}
		/* ask if player accepts */
		printw("  Does %s accept?", cturn == 1 ? color[2] : color[3]);

		/* get response from yorn; a "2" means he said "p" to print board. */
		if ((resp = yorn ('r')) == 2) {
			addstr("  Reprint.\n");
			moveplayers();
			wrboard();
			addstr(*Colorptr);
			continue;
		}
		/* check response */
		if (resp) {
			/* accepted */
			gvalue *= 2;
			dlast = cturn;
			gwrite();
			return;
		}
		nexturn();	/* declined */
		cturn *= -2;
		return;
	}
}

/*
 * dblgood ()
 *	Returns 1 if the computer would double in this position.  This
 * is not an exact science.  The computer will decline a double that he
 * would have made.  Accumulated judgments are kept in the variable n,
 * which is in "pips", i.e., the position of each man summed over all
 * men, with opponent's totals negative.  Thus, n should have a positive
 * value of 7 for each move ahead, or a negative value of 7 for each one
 * behind.
 */

int
dblgood(void)
{
	int     n;		/* accumulated judgment */
	int     OFFC = *offptr;	/* no. of computer's men off */
	int     OFFO = *offopp;	/* no. of player's men off */

#ifdef DEBUG
	int     i;
	if (ftrace == NULL)
		ftrace = fopen("bgtrace", "w");
		printf ("fopen\n");
#endif

	/* get real pip value */
	n = eval() * cturn;
#ifdef DEBUG
	fputs("\nDoubles:\nBoard: ", ftrace);
	for (i = 0; i < 26; i++)
		fprintf(ftrace, " %d", board[i]);
	fprintf(ftrace, "\n\tpip = %d, ", n);
#endif

	/* below adjusts pip value according to position judgments */

	/* check men moving off board */
	if (OFFC > -15 || OFFO > -15) {
		if (OFFC < 0 && OFFO < 0) {
			OFFC += 15;
			OFFO += 15;
			n +=((OFFC - OFFO) * 7) / 2;
		} else if (OFFC < 0) {
			OFFC += 15;
			n -= OFFO * 7 / 2;
		} else if (OFFO < 0) {
			OFFO += 15;
			n += OFFC * 7 / 2;
		}
		if (OFFC < 8 && OFFO > 8)
			n -= 7;
		if (OFFC < 10 && OFFO > 10)
			n -= 7;
		if (OFFC < 12 && OFFO > 12)
			n -= 7;
		if (OFFO < 8 && OFFC > 8)
			n += 7;
		if (OFFO < 10 && OFFC > 10)
			n += 7;
		if (OFFO < 12 && OFFC > 12)
			n += 7;
		n += ((OFFC - OFFO) * 7) / 2;
	}

#ifdef DEBUG
	fprintf(ftrace, "off = %d, ", n);
#endif

	/* see if men are trapped */
	n -= freemen(bar);
	n += freemen(home);
	n += trapped(home, -cturn);
	n -= trapped(bar, cturn);

#ifdef DEBUG
	fprintf(ftrace, "free = %d\n", n);
	fprintf(ftrace, "\tOFFC = %d, OFFO = %d\n", OFFC, OFFO);
	fflush(ftrace);
#endif

	/* double if 2-3 moves ahead */
	if (n > (int)(10 + rnum(7)))
		return(1);
	return(0);
}

int
freemen(int b)
{
	int     i, inc, lim;

	odds(0, 0, 0);
	if (board[b] == 0)
		return (0);
	inc = (b == 0 ? 1 : -1);
	lim = (b == 0 ? 7 : 18);
	for (i = b + inc; i != lim; i += inc)
		if (board[i] * inc < -1)
			odds(abs(b - i), 0, abs(board[b]));
	if (abs(board[b]) == 1)
		return ((36 - count()) / 5);
	return (count() / 5);
}

int
trapped(int n, int inc)
{
	int     i, j, k;
	int     c, l, ct;

	ct = 0;
	l = n + 7 * inc;
	for (i = n + inc; i != l; i += inc) {
		odds(0, 0, 0);
		c = abs(i - l);
		if (board[i] * inc > 0) {
			for (j = c; j < 13; j++)
				if (board[i + inc * j] * inc < -1) {
					if (j < 7)
						odds(j, 0, 1);
					for (k = 1; k < 7 && k < j; k++)
						if (j - k < 7)
							odds(k, j - k, 1);
				}
			ct += abs(board[i]) * (36 - count());
		}
	}
	return(ct / 5);
}

int
eval(void)
{
	int     i, j;

	for (j = i = 0; i < 26; i++)
		j += (board[i] >= 0 ? i * board[i] : (25 - i) * board[i]);

	if (off[1] >= 0)
		j += 25 * off[1];
	else
		j += 25 * (off[1] + 15);

	if (off[0] >= 0)
		j -= 25 * off[0];
	else
		j -= 25 * (off[0] + 15);
	return(j);
}
@


1.7
log
@Fix sign compare bug introduced when rnum() was redefined to use
arc4random_uniform().  From pjanzen@@, OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extra.c,v 1.6 2009/10/27 23:59:23 deraadt Exp $	*/
d41 1
a41 1
dble()
d99 1
a99 1
dblgood()
d174 1
a174 2
freemen(b)
	int     b;
d192 1
a192 2
trapped(n, inc)
	int     n, inc;
d218 1
a218 1
eval()
@


1.6
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: extra.c,v 1.5 2006/12/14 10:14:05 martin Exp $	*/
d168 1
a168 1
	if (n > 10 + rnum(7))
@


1.5
log
@fix DEBUG by renaming a variable colliding with ncurses

found by Sascha Welter, ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extra.c,v 1.4 2003/06/03 03:01:38 millert Exp $	*/
a30 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)extra.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: extra.c,v 1.4 2003/06/03 03:01:38 millert Exp $";
#endif
#endif /* not lint */
@


1.4
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: extra.c,v 1.3 2001/06/23 23:49:53 pjanzen Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: extra.c,v 1.3 2001/06/23 23:49:53 pjanzen Exp $";
d115 3
a117 2
	if (trace == NULL)
		trace = fopen("bgtrace", "w");
d123 1
a123 1
	fputs("\nDoubles:\nBoard: ", trace);
d125 2
a126 2
		fprintf(trace, " %d", board[i]);
	fprintf(trace, "\n\tpip = %d, ", n);
d160 1
a160 1
	fprintf(trace, "off = %d, ", n);
d170 3
a172 3
	fprintf(trace, "free = %d\n", n);
	fprintf(trace, "\tOFFC = %d, OFFO = %d\n", OFFC, OFFO);
	fflush(trace);
@


1.3
log
@termios -> curses
@
text
@d1 1
a1 1
/*	$OpenBSD: extra.c,v 1.2 1998/03/19 11:13:06 pjanzen Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d36 1
a36 1
static char rcsid[] = "$OpenBSD: extra.c,v 1.2 1998/03/19 11:13:06 pjanzen Exp $";
@


1.2
log
@NetBSD changes and further improvements and corrections
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD$";
d58 1
a58 1
		writel(" doubles.");	/* indicate double */
d62 1
a62 1
				writel("  Declined.\n");
d67 1
a67 1
				writel("  Accepted.\n");
d70 1
a70 2
				if (tflag)
					gwrite();
d75 1
a75 3
		writel("  Does ");
		writel(cturn == 1 ? color[2] : color[3]);
		writel(" accept?");
d79 2
a80 2
			writel("  Reprint.\n");
			buflush();
d82 1
a82 1
			writel(*Colorptr);
d90 1
a90 2
			if (tflag)
				gwrite();
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: extra.c,v 1.3 1995/03/21 15:05:01 cgd Exp $	*/
d40 1
a40 1
static char rcsid[] = "$NetBSD: extra.c,v 1.3 1995/03/21 15:05:01 cgd Exp $";
d45 1
a45 5

#ifdef DEBUG
#include <stdio.h>
FILE	*trace;
#endif
d52 4
a55 2
dble ()  {
	register int	resp;			/* response to y/n */
d57 2
a58 2
	for (;;)  {
		writel (" doubles.");		/* indicate double */
d60 3
a62 3
		if (cturn == -pnum)  {		/* see if computer accepts */
			if (dblgood())  {	    /* guess not */
				writel ("  Declined.\n");
d64 1
a64 1
				cturn *= -2;	    /* indicate loss */
d66 3
a68 3
			} else  {		    /* computer accepts */
				writel ("  Accepted.\n");
				gvalue *= 2;	    /* double game value */
d75 8
a82 11

						/* ask if player accepts */
		writel ("  Does ");
		writel (cturn == 1? color[2]: color[3]);
		writel (" accept?");

						/* get response from yorn,
						 * a "2" means he said "p"
						 * for print board. */
		if ((resp = yorn ('R')) == 2)  {
			writel ("  Reprint.\n");
d85 1
a85 1
			writel (*Colorptr);
d88 3
a90 4

						/* check response */
		if (resp)  {
						    /* accepted */
d97 1
a97 2

		nexturn ();			/* declined */
d102 1
a102 1

d114 6
a119 4
dblgood ()  {
	register int	n;			/* accumulated judgment */
	register int	OFFC = *offptr;		/* no. of computer's men off */
	register int	OFFO = *offopp;		/* no. of player's men off */
d122 1
a122 1
	register int	i;
d124 1
a124 1
		trace = fopen ("bgtrace","w");
d127 2
a128 2
						/* get real pip value */
	n = eval()*cturn;
d130 1
a130 1
	fputs ("\nDoubles:\nBoard: ",trace);
d132 2
a133 2
		fprintf (trace," %d",board[i]);
	fprintf (trace,"\n\tpip = %d, ",n);
d136 5
a140 8
						/* below adjusts pip value
						 * according to position
						 * judgments */

						/* check men moving off
						 * board */
	if (OFFC > -15 || OFFO > -15)  {
		if (OFFC < 0 && OFFO < 0)  {
d143 2
a144 2
			n +=((OFFC-OFFO)*7)/2;
		} else if (OFFC < 0)  {
d146 2
a147 2
			n -= OFFO*7/2;
		} else if (OFFO < 0)  {
d149 1
a149 1
			n += OFFC*7/2;
d163 1
a163 1
		n += ((OFFC-OFFO)*7)/2;
d167 1
a167 1
	fprintf (trace,"off = %d, ",n);
d170 1
a170 1
						/* see if men are trapped */
d173 2
a174 2
	n += trapped(home,-cturn);
	n -= trapped(bar,cturn);
d177 3
a179 3
	fprintf (trace,"free = %d\n",n);
	fprintf (trace,"\tOFFC = %d, OFFO = %d\n",OFFC,OFFO);
	fflush (trace);
d182 2
a183 2
						/* double if 2-3 moves ahead */
	if (n > 10+rnum(7))
d185 1
a185 1
	return (0);
a186 3

freemen (b)
int	b;
d188 3
d192 1
a192 1
	register int	i, inc, lim;
d194 1
a194 1
	odds(0,0,0);
d197 5
a201 5
	inc = (b == 0? 1: -1);
	lim = (b == 0? 7: 18);
	for (i = b+inc; i != lim; i += inc)
		if (board[i]*inc < -1)
			odds(abs(b-i),0,abs(board[b]));
d203 2
a204 2
		return ((36-count())/5);
	return (count()/5);
a205 3

trapped (n,inc)
int	n, inc;
d207 3
d211 2
a212 2
	register int	i, j, k;
	int		c, l, ct;
d215 5
a219 5
	l = n+7*inc;
	for (i = n+inc; i != l; i += inc)  {
		odds (0,0,0);
		c = abs(i-l);
		if (board[i]*inc > 0)  {
d221 1
a221 1
				if (board[i+inc*j]*inc < -1)  {
d223 1
a223 1
						odds (j,0,1);
d225 2
a226 2
						if (j-k < 7)
							odds (k,j-k,1);
d228 1
a228 1
			ct += abs(board[i])*(36-count());
d231 1
a231 1
	return (ct/5);
a232 2

eval ()  {
d234 4
a237 1
	register int	i, j;
d240 1
a240 1
		j += (board[i] >= 0 ? i*board[i] : (25-i)*board[i]);
d243 1
a243 1
		j += 25*off[1];
d245 1
a245 1
		j += 25*(off[1]+15);
d248 1
a248 1
		j -= 25*off[0];
d250 2
a251 2
		j -= 25*(off[0]+15);
	return (j);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

