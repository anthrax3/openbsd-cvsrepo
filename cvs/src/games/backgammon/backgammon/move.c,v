head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.6
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.10.0.18
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.22
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.20
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.16
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.14
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.12
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.10
	OPENBSD_5_0:1.10.0.8
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.6
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.14
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.10
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.8
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.6
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.4
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.7.0.14
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.12
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.10
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.12
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.10
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.8
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.11.30.08.19.25;	author tb;	state Exp;
branches;
next	1.12;
commitid	DsnnMPnBHkgAj0Eo;

1.12
date	2015.08.22.14.47.41;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	vWCbqNWL9DL2UkGT;

1.11
date	2015.06.26.19.18.03;	author otto;	state Exp;
branches;
next	1.10;
commitid	rLN6ksd9DcCJ3lkE;

1.10
date	2009.10.27.23.59.23;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.12.14.10.14.05;	author martin;	state Exp;
branches;
next	1.8;

1.8
date	2006.10.29.20.02.41;	author martin;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.03.03.01.38;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.30.18.11.52;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.27.08;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.23.23.49.54;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.18.04.16.36;	author ericj;	state Exp;
branches;
next	1.2;

1.2
date	98.03.19.11.13.08;	author pjanzen;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.39;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Pledge for backgammon and teachgammon.

Both are straightforward "stdio rpath tty" programs; teachgammon
exec's backgammon at the end, so give it "exec" in addition.

While there, ANSIfy
@
text
@/*	$OpenBSD: move.c,v 1.12 2015/08/22 14:47:41 deraadt Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "back.h"
#include "backlocal.h"

struct BOARD  {		/* structure of game position */
	int     b_board[26];	/* board position */
	int     b_in[2];	/* men in */
	int     b_off[2];	/* men off */
	int     b_st[4], b_fn[4];	/* moves */

	struct BOARD *b_next;	/* forward queue pointer */
};

struct BOARD *freeq = 0;
struct BOARD *checkq = 0;

static int cp[5];		/* candidate start position */
static int cg[5];		/* candidate finish position */

static int race;		/* game reduced to a race */
static float bestmove;

static int bcomp(struct BOARD *, struct BOARD *);
static struct BOARD *bsave(void);
static void binsert(struct BOARD *);
static void boardcopy(struct BOARD *);
static void makefree(struct BOARD *);
static void movcmp(void);
static void mvcheck(struct BOARD *, struct BOARD *);
static struct BOARD *nextfree(void);
static void pickmove(void);


void
domove(int okay)
{
	int     i;		/* index */
	int     l = 0;		/* last man */

	bestmove = -9999999.;
	if (okay) {
	    	/* see if comp should double */
		if (dflag && gvalue < 64 && dlast != cturn && dblgood()) {
			addstr(*Colorptr);
			dble();	/* double */
			/* return if declined */
			if (cturn != 1 && cturn != -1)
				return;
		}
		roll();
	}
	race = 0;
	for (i = 0; i < 26; i++) {
		if (board[i] < 0)
			l = i;
	}
	for (i = 0; i < l; i++) {
		if (board[i] > 0)
			break;
	}
	if (i == l)
		race = 1;

	/* print roll */
	move(cturn == -1 ? 18 : 19, 0);
	printw("%s rolls %d %d", *Colorptr, D0, D1);
	clrtoeol();

	/* find out how many moves */
	mvlim = movallow();
	if (mvlim == 0) {
		addstr(" but cannot use it.\n");
		nexturn();
		return;
	}

	/* initialize */
	for (i = 0; i < 4; i++)
		cp[i] = cg[i] = 0;

	/* strategize */
	trymove(0, 0);
	pickmove();

	/* print move */
	addstr(" and moves ");
	for (i = 0; i < mvlim; i++) {
		if (i > 0)
			addch(',');
		printw("%d-%d", p[i] = cp[i], g[i] = cg[i]);
		makmove(i);
	}
	addch('.');

	/* print blots hit */
	move(20, 0);
	for (i = 0; i < mvlim; i++)
		if (h[i])
			wrhit(g[i]);
	/* get ready for next move */
	nexturn();
	if (!okay) {
		refresh();
		sleep(3);
	}
}

void
trymove(int mvnum, int swapped)
{
	int     pos;		/* position on board */
	int     rval;		/* value of roll */

	/* if recursed through all dice values, compare move */
	if (mvnum == mvlim) {
		binsert(bsave());
		return;
	}
	/* make sure dice in always same order */
	if (d0 == swapped)
		swap;
	/* choose value for this move */
	rval = dice[mvnum != 0];

	/* find all legitimate moves */
	for (pos = bar; pos != home; pos += cturn) {
		/* fix order of dice */
		if (d0 == swapped)
			swap;
		/* break if stuck on bar */
		if (board[bar] != 0 && pos != bar)
			break;
		/* on to next if not occupied */
		if (board[pos] * cturn <= 0)
			continue;
		/* set up arrays for move */
		p[mvnum] = pos;
		g[mvnum] = pos + rval * cturn;
		if (g[mvnum] * cturn >= home) {
			if (*offptr < 0)
				break;
			g[mvnum] = home;
		}
		/* try to move */
		if (makmove(mvnum))
			continue;
		else
			trymove(mvnum + 1, 2);
		/* undo move to try another */
		backone(mvnum);
	}

	/* swap dice and try again */
	if ((!swapped) && D0 != D1)
		trymove(0, 1);
}

static struct BOARD *
bsave(void)
{
	int     i;		/* index */
	struct BOARD *now;	/* current position */

	now = nextfree();	/* get free BOARD */

	/* store position */
	for (i = 0; i < 26; i++)
		now->b_board[i] = board[i];
	now->b_in[0] = in[0];
	now->b_in[1] = in[1];
	now->b_off[0] = off[0];
	now->b_off[1] = off[1];
	for (i = 0; i < mvlim; i++) {
		now->b_st[i] = p[i];
		now->b_fn[i] = g[i];
	}
	return(now);
}

static void
binsert(struct BOARD *new)
{
	struct BOARD *p = checkq;	/* queue pointer */
	int     result;		/* comparison result */

	if (p == 0) {		/* check if queue empty */
		checkq = p = new;
		p->b_next = 0;
		return;
	}
	result = bcomp(new, p);	/* compare to first element */
	if (result < 0) {	/* insert in front */
		new->b_next = p;
		checkq = new;
		return;
	}
	if (result == 0) {	/* duplicate entry */
		mvcheck(p, new);
		makefree(new);
		return;
	}
	while (p->b_next != 0) {/* traverse queue */
		result = bcomp(new, p->b_next);
		if (result < 0) {	/* found place */
			new->b_next = p->b_next;
			p->b_next = new;
			return;
		}
		if (result == 0) {	/* duplicate entry */
			mvcheck(p->b_next, new);
			makefree(new);
			return;
		}
		p = p->b_next;
	}
	/* place at end of queue */
	p->b_next = new;
	new->b_next = 0;
}

static int
bcomp(struct BOARD *a, struct BOARD *b)
{
	int    *aloc = a->b_board;	/* pointer to board a */
	int    *bloc = b->b_board;	/* pointer to board b */
	int     i;		/* index */
	int     result;		/* comparison result */

	for (i = 0; i < 26; i++) {	/* compare boards */
		result = cturn * (aloc[i] - bloc[i]);
		if (result)
			return(result);		/* found inequality */
	}
	return(0);			/* same position */
}

static void
mvcheck(struct BOARD *incumbent, struct BOARD *candidate)
{
	int     i, result;

	for (i = 0; i < mvlim; i++) {
		result = cturn * (candidate->b_st[i] - incumbent->b_st[i]);
		if (result > 0)
			return;
		if (result < 0)
			break;
	}
	if (i == mvlim)
		return;
	for (i = 0; i < mvlim; i++) {
		incumbent->b_st[i] = candidate->b_st[i];
		incumbent->b_fn[i] = candidate->b_fn[i];
	}
}

static void
makefree(struct BOARD *dead)
{
	dead->b_next = freeq;	/* add to freeq */
	freeq = dead;
}

static struct BOARD *
nextfree(void)
{
	struct BOARD *new;

	if (freeq == 0) {
		new = calloc (1, sizeof(struct BOARD));
		if (new == 0) {
			addstr("\nOut of memory\n");
			getout(0);
		}
	} else {
		new = freeq;
		freeq = freeq->b_next;
	}

	new->b_next = 0;
	return(new);
}

static void
pickmove(void)
{
	/* current game position */
	struct BOARD *now = bsave();
	struct BOARD *next;	/* next move */

#ifdef DEBUG
	if (ftrace == NULL)
		ftrace = fopen("bgtrace", "w");
	fprintf(ftrace, "\nRoll:  %d %d%s\n", D0, D1, race ? " (race)" : "");
	fflush(ftrace);
#endif
	do {			/* compare moves */
		boardcopy(checkq);
		next = checkq->b_next;
		makefree(checkq);
		checkq = next;
		movcmp();
	} while (checkq != 0);

	boardcopy(now);
}

static void
boardcopy(struct BOARD *s)
{
	int     i;		/* index */

	for (i = 0; i < 26; i++)
		board[i] = s->b_board[i];
	for (i = 0; i < 2; i++) {
		in[i] = s->b_in[i];
		off[i] = s->b_off[i];
	}
	for (i = 0; i < mvlim; i++) {
		p[i] = s->b_st[i];
		g[i] = s->b_fn[i];
	}
}

static void
movcmp(void)
{
	int i;
	float f;

	setx();
	f = pubeval(race);
	if (f > bestmove) {
		bestmove = f;
		for (i = 0; i < mvlim; i++) {
			cp[i] = p[i];
			cg[i] = g[i];
		}
	}
}
@


1.12
log
@remove malloc/calloc/realloc* casts, due to stdlib.h being present; ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: move.c,v 1.11 2015/06/26 19:18:03 otto Exp $	*/
d65 1
a65 2
domove(okay)
	int     okay;		/* zero if first move */
d139 1
a139 3
trymove(mvnum, swapped)
	int     mvnum;		/* number of move (rel zero) */
	int     swapped;	/* see if swapped also tested */
d189 1
a189 1
bsave()
d211 1
a211 2
binsert(new)
	struct BOARD *new;	/* item to insert */
d252 1
a252 3
bcomp(a, b)
	struct BOARD *a;
	struct BOARD *b;
d268 1
a268 3
mvcheck(incumbent, candidate)
	struct BOARD *incumbent;
	struct BOARD *candidate;
d288 1
a288 2
makefree(dead)
	struct BOARD *dead;	/* dead position */
d295 1
a295 1
nextfree()
d315 1
a315 1
pickmove()
d339 1
a339 2
boardcopy(s)
	struct BOARD *s;	/* game situation */
d356 1
a356 1
movcmp()
@


1.11
log
@/home/otto/ok
@
text
@d1 1
a1 1
/*	$OpenBSD: move.c,v 1.10 2009/10/27 23:59:23 deraadt Exp $	*/
d309 1
a309 1
		new = (struct BOARD *)calloc (1, sizeof(struct BOARD));
@


1.10
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: move.c,v 1.9 2006/12/14 10:14:05 martin Exp $	*/
d72 3
a74 2
	if (okay && dflag != 0) {	 /* see if comp should double */
		if (gvalue < 64 && dlast != cturn && dblgood()) {
@


1.9
log
@fix DEBUG by renaming a variable colliding with ncurses

found by Sascha Welter, ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: move.c,v 1.8 2006/10/29 20:02:41 martin Exp $	*/
a30 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)move.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: move.c,v 1.8 2006/10/29 20:02:41 martin Exp $";
#endif
#endif /* not lint */
@


1.8
log
@-d: make it possible playing without doubling as it is not commonly
played everywhere in the world

ok todd@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: move.c,v 1.7 2003/06/03 03:01:38 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: move.c,v 1.7 2003/06/03 03:01:38 millert Exp $";
d338 4
a341 4
	if (trace == NULL)
		trace = fopen("bgtrace", "w");
	fprintf(trace, "\nRoll:  %d %d%s\n", D0, D1, race ? " (race)" : "");
	fflush(trace);
@


1.7
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: move.c,v 1.6 2002/07/30 18:11:52 pjanzen Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: move.c,v 1.6 2002/07/30 18:11:52 pjanzen Exp $";
d80 1
a80 1
	if (okay) {	 /* see if comp should double */
@


1.6
log
@Replace the "blows chunks" algorithm with pubeval, a public domain algorithm
which plays an acceptable, if not optimal, game.  pubeval author approves.
@
text
@d1 1
a1 1
/*	$OpenBSD: move.c,v 1.5 2002/02/16 21:27:08 millert Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d36 1
a36 1
static char rcsid[] = "$OpenBSD: move.c,v 1.5 2002/02/16 21:27:08 millert Exp $";
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: move.c,v 1.4 2001/06/23 23:49:54 pjanzen Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: move.c,v 1.4 2001/06/23 23:49:54 pjanzen Exp $";
a46 4
#ifdef DEBUG
static char tests[20];
#endif

a58 19
/* these variables are values for the candidate move */
static int ch;			/* chance of being hit */
static int op;			/* computer's open men */
static int pt;			/* comp's protected points */
static int em;			/* farthest man back */
static int frc;			/* chance to free comp's men */
static int frp;			/* chance to free pl's men */

/* these values are the values for the move chosen (so far) */
static int chance;		/* chance of being hit */
static int openmen;		/* computer's open men */
static int points;		/* comp's protected points */
static int endman;		/* farthest man back */
static int barmen;		/* men on bar */
static int menin;		/* men in inner table */
static int menoff;		/* men off board */
static int oldfrc;		/* chance to free comp's men */
static int oldfrp;		/* chance to free pl's men */

d63 1
a63 1

d70 1
d73 1
d83 1
d118 1
d306 1
a306 1
void
d334 1
a334 1
void
d376 1
a376 1
void
d379 2
a380 6
	int     i;

#ifdef DEBUG
	if (trace == NULL)
		trace = fopen("bgtrace", "w");
#endif
d382 4
a385 40
	odds(0, 0, 0);
	if (!race) {
		ch = op = pt = 0;
		for (i = 1; i < 25; i++) {
			if (board[i] == cturn)
				ch = canhit(i, 1);
			op += abs(bar - i);
		}
		for (i = bar + cturn; i != home; i += cturn)
			if (board[i] * cturn > 1)
				pt += abs(bar - i);
		frc = freemen(bar) + trapped(bar, cturn);
		frp = freemen(home) + trapped(home, -cturn);
	}
	for (em = bar; em != home; em += cturn)
		if (board[em] * cturn > 0)
			break;
	em = abs(home - em);
#ifdef DEBUG
	fputs("Board: ", trace);
	for (i = 0; i < 26; i++)
		fprintf(trace, " %d", board[i]);
	if (race)
		fprintf(trace, "\n\tem = %d\n", em);
	else
		fprintf(trace,
			"\n\tch = %d, pt = %d, em = %d, frc = %d, frp = %d\n",
			ch, pt, em, frc, frp);
	fputs("\tMove: ", trace);
	for (i = 0; i < mvlim; i++)
		fprintf(trace, " %d-%d", p[i], g[i]);
	fputs("\n", trace);
	fflush(trace);
	strcpy(tests, "");
#endif
	if ((cp[0] == 0 && cg[0] == 0) || movegood()) {
#ifdef DEBUG
		fprintf(trace, "\t[%s] ... wins.\n", tests);
		fflush(trace);
#endif
a389 101
		if (!race) {
			chance = ch;
			openmen = op;
			points = pt;
			endman = em;
			barmen = abs(board[home]);
			oldfrc = frc;
			oldfrp = frp;
		}
		menin = *inptr;
		menoff = *offptr;
	}
#ifdef DEBUG
	else {
		fprintf(trace, "\t[%s] ... loses.\n", tests);
		fflush(trace);
	}
#endif
}

int
movegood()
{
	int     n;

	if (*offptr == 15)
		return(1);
	if (menoff == 15)
		return(0);
	if (race) {
#ifdef DEBUG
		strcat(tests, "o");
#endif
		if (*offptr - menoff)
			return(*offptr > menoff);
#ifdef DEBUG
		strcat(tests, "e");
#endif
		if (endman - em)
			return(endman > em);
#ifdef DEBUG
		strcat(tests, "i");
#endif
		if (menin == 15)
			return(0);
		if (*inptr == 15)
			return(1);
#ifdef DEBUG
		strcat(tests, "i");
#endif
		if (*inptr - menin)
			return(*inptr > menin);
		return(rnum(2));
	} else {
		n = barmen - abs(board[home]);
#ifdef DEBUG
		strcat(tests, "c");
#endif
		if (abs(chance - ch) + 25 * n > rnum(150))
			return(n ? (n < 0) : (ch < chance));
#ifdef DEBUG
		strcat(tests,"o");
#endif
		if (*offptr - menoff)
			return(*offptr > menoff);
#ifdef DEBUG
		strcat(tests, "o");
#endif
		if (abs(openmen - op) > 7 + rnum(12))
			return(openmen > op);
#ifdef DEBUG
		strcat(tests, "b");
#endif
		if (n)
			return(n < 0);
#ifdef DEBUG
		strcat(tests, "e");
#endif
		if (abs(endman - em) > rnum(2))
			return(endman > em);
#ifdef DEBUG
		strcat(tests, "f");
#endif
		if (abs(frc - oldfrc) > rnum(2))
			return(frc < oldfrc);
#ifdef DEBUG
		strcat(tests, "p");
#endif
		if (abs(n = pt - points) > rnum(4))
			return(n > 0);
#ifdef DEBUG
		strcat(tests, "i");
#endif
		if (*inptr - menin)
			return(*inptr > menin);
#ifdef DEBUG
		strcat(tests, "f");
#endif
		if (abs(frp - oldfrp) > rnum(2))
			return(frp > oldfrp);
		return(rnum(2));
@


1.4
log
@termios -> curses
@
text
@d1 1
a1 1
/*	$OpenBSD: move.c,v 1.3 2001/02/18 04:16:36 ericj Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: move.c,v 1.3 2001/02/18 04:16:36 ericj Exp $";
d88 7
a94 7
static int bcomp __P((struct BOARD *, struct BOARD *));
static struct BOARD *bsave __P((void));
static void binsert __P((struct BOARD *));
static void boardcopy __P((struct BOARD *));
static void makefree __P((struct BOARD *));
static void mvcheck __P((struct BOARD *, struct BOARD *));
static struct BOARD *nextfree __P((void));
@


1.3
log
@
rename variable raw->traw as to not conflict with raw()
@
text
@d1 1
a1 1
/*	$OpenBSD: move.c,v 1.2 1998/03/19 11:13:08 pjanzen Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: move.c,v 1.2 1998/03/19 11:13:08 pjanzen Exp $";
d98 1
a98 1
move(okay)
d106 1
a106 1
			writel(*Colorptr);
d127 3
a129 11
	if (tflag)
		curmove(cturn == -1 ? 18 : 19, 0);
	writel(*Colorptr);
	writel(" rolls ");
	writec(D0 + '0');
	writec(' ');
	writec(D1 + '0');
	/* make tty interruptable while thinking */
	if (tflag)
		cline();
	fixtty(&noech);
d134 1
a134 1
		writel(" but cannot use it.\n");
a135 1
		fixtty(&traw);
d147 1
a147 1
	writel(" and moves ");
d150 2
a151 4
			writec(',');
		wrint(p[i] = cp[i]);
		writec('-');
		wrint(g[i] = cg[i]);
d154 1
a154 1
	writec('.');
d157 1
a157 4
	if (tflag)
		curmove(20, 0);
	else
		writec('\n');
d164 1
a164 1
		buflush();
a166 1
	fixtty(&traw);		/* no more tty interrupt */
d341 1
a341 1
			writel("\nOut of memory\n");
@


1.2
log
@NetBSD changes and further improvements and corrections
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD$";
d144 1
a144 1
		fixtty(&raw);
d181 1
a181 1
	fixtty(&raw);		/* no more tty interrupt */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: move.c,v 1.5 1995/04/29 00:44:05 mycroft Exp $	*/
d40 1
a40 1
static char rcsid[] = "$NetBSD: move.c,v 1.5 1995/04/29 00:44:05 mycroft Exp $";
d45 1
d48 1
a48 3
#include <stdio.h>
FILE	*trace;
static char	tests[20];
d51 5
a55 5
struct BOARD  {				/* structure of game position */
	int	b_board[26];			/* board position */
	int	b_in[2];			/* men in */
	int	b_off[2];			/* men off */
	int	b_st[4], b_fn[4];		/* moves */
d57 1
a57 1
	struct BOARD	*b_next;		/* forward queue pointer */
a61 2
struct BOARD *bsave();
struct BOARD *nextfree();
d63 46
a108 38
					/* these variables are values for the
					 * candidate move */
static int	ch;				/* chance of being hit */
static int	op;				/* computer's open men */
static int	pt;				/* comp's protected points */
static int	em;				/* farthest man back */
static int	frc;				/* chance to free comp's men */
static int	frp;				/* chance to free pl's men */

					/* these values are the values for the
					 * move chosen (so far) */
static int	chance;				/* chance of being hit */
static int	openmen;			/* computer's open men */
static int	points;				/* comp's protected points */
static int	endman;				/* farthest man back */
static int	barmen;				/* men on bar */
static int	menin;				/* men in inner table */
static int	menoff;				/* men off board */
static int	oldfrc;				/* chance to free comp's men */
static int	oldfrp;				/* chance to free pl's men */

static int	cp[5];				/* candidate start position */
static int	cg[5];				/* candidate finish position */

static int	race;				/* game reduced to a race */

move (okay)
int	okay;					/* zero if first move */
{
	register int	i;		/* index */
	register int	l;		/* last man */

	if (okay)  {
						/* see if comp should double */
		if (gvalue < 64 && dlast != cturn && dblgood())  {
			writel (*Colorptr);
			dble();			    /* double */
						    /* return if declined */
a113 1

d115 1
a115 1
	for (i = 0; i < 26; i++)  {
d119 1
a119 1
	for (i = 0; i < l; i++)  {
d126 1
a126 1
						/* print roll */
d128 7
a134 8
		curmove (cturn == -1? 18: 19,0);
	writel (*Colorptr);
	writel (" rolls ");
	writec (D0+'0');
	writec (' ');
	writec (D1+'0');
						/* make tty interruptable
						 * while thinking */
d137 1
a137 1
	fixtty (&noech);
d139 1
a139 1
						/* find out how many moves */
d141 2
a142 2
	if (mvlim == 0)  {
		writel (" but cannot use it.\n");
d144 1
a144 1
		fixtty (&raw);
d147 1
a147 2

						/* initialize */
d151 2
a152 2
						/* strategize */
	trymove (0,0);
d155 3
a157 3
						/* print move */
	writel (" and moves ");
	for (i = 0; i < mvlim; i++)  {
d159 5
a163 5
			writec (',');
		wrint (p[i] = cp[i]);
		writec ('-');
		wrint (g[i] = cg[i]);
		makmove (i);
d165 1
a165 1
	writec ('.');
d167 1
a167 1
						/* print blots hit */
d169 1
a169 1
		curmove (20,0);
d171 1
a171 1
		writec ('\n');
d175 1
a175 1
						/* get ready for next move */
d177 1
a177 1
	if (!okay)  {
d179 1
a179 1
		sleep (3);
d181 1
a181 1
	fixtty (&raw);				/* no more tty interrupt */
a182 4

trymove (mvnum,swapped)
register int	mvnum;				/* number of move (rel zero) */
int		swapped;			/* see if swapped also tested */
d184 4
d189 2
a190 2
	register int	pos;			/* position on board */
	register int	rval;			/* value of roll */
d192 3
a194 4
						/* if recursed through all dice
						 * values, compare move */
	if (mvnum == mvlim)  {
		binsert (bsave());
d197 1
a197 3

						/* make sure dice in always
						 * same order */
d200 1
a200 1
						/* choose value for this move */
d203 3
a205 3
						/* find all legitimate moves */
	for (pos = bar; pos != home; pos += cturn)  {
						/* fix order of dice */
d208 1
a208 1
						/* break if stuck on bar */
d211 2
a212 2
						/* on to next if not occupied */
		if (board[pos]*cturn <= 0)
d214 1
a214 1
						/* set up arrays for move */
d216 2
a217 2
		g[mvnum] = pos+rval*cturn;
		if (g[mvnum]*cturn >= home)  {
d222 2
a223 2
						/* try to move */
		if (makmove (mvnum))
d226 3
a228 3
			trymove (mvnum+1,2);
						/* undo move to try another */
		backone (mvnum);
d231 1
a231 1
						/* swap dice and try again */
d233 1
a233 1
		trymove (0,1);
a234 5

struct BOARD *
bsave ()  {
	register int	i;		/* index */
	struct BOARD	*now;		/* current position */
d236 7
a242 1
	now = nextfree ();		/* get free BOARD */
d244 1
a244 1
					/* store position */
d251 1
a251 1
	for (i = 0; i < mvlim; i++)  {
d255 1
a255 1
	return (now);
d257 4
a260 3

binsert (new)
struct BOARD	*new;					/* item to insert */
d262 2
a263 2
	register struct BOARD	*p = checkq;		/* queue pointer */
	register int		result;			/* comparison result */
d265 1
a265 1
	if (p == 0)  {				/* check if queue empty */
d270 2
a271 3

	result = bcomp (new,p);			/* compare to first element */
	if (result < 0)  {				/* insert in front */
d276 3
a278 3
	if (result == 0)  {				/* duplicate entry */
		mvcheck (p,new);
		makefree (new);
d281 3
a283 4

	while (p->b_next != 0)  {		/* traverse queue */
		result = bcomp (new,p->b_next);
		if (result < 0)  {			/* found place */
d288 3
a290 3
		if (result == 0)  {			/* duplicate entry */
			mvcheck (p->b_next,new);
			makefree (new);
d295 1
a295 1
						/* place at end of queue */
a298 9

bcomp (a,b)
struct BOARD	*a;
struct BOARD	*b;
{
	register int	*aloc = a->b_board;	/* pointer to board a */
	register int	*bloc = b->b_board;	/* pointer to board b */
	register int	i;			/* index */
	int		result;			/* comparison result */
d300 12
a311 2
	for (i = 0; i < 26; i++)  {		/* compare boards */
		result = cturn*(aloc[i]-bloc[i]);
d313 1
a313 1
			return (result);		/* found inequality */
d315 1
a315 1
	return (0);				/* same position */
d317 5
a321 4

mvcheck (incumbent,candidate)
register struct BOARD 	*incumbent;
register struct BOARD 	*candidate;
d323 1
a323 2
	register int	i;
	register int	result;
d325 2
a326 2
	for (i = 0; i < mvlim; i++)  {
		result = cturn*(candidate->b_st[i]-incumbent->b_st[i]);
d334 1
a334 1
	for (i = 0; i < mvlim; i++)  {
d339 4
a342 3

makefree (dead)
struct BOARD	*dead;			/* dead position */
d344 1
a344 1
	dead->b_next = freeq;			/* add to freeq */
d348 10
a357 9
struct BOARD *
nextfree ()  {
	struct BOARD	*new;

	if (freeq == 0)  {
		new = (struct BOARD *)calloc (1,sizeof (struct BOARD));
		if (new == 0)  {
			writel ("\nOut of memory\n");
			getout();
d365 1
a365 1
	return (new);
d367 7
a373 5

pickmove ()  {
						/* current game position */
	register struct BOARD	*now = bsave();
	register struct BOARD	*next;		/* next move */
d377 3
a379 3
		trace = fopen ("bgtrace","w");
	fprintf (trace,"\nRoll:  %d %d%s\n",D0,D1,race? " (race)": "");
	fflush (trace);
d381 2
a382 2
	do  {				/* compare moves */
		boardcopy (checkq);
d384 1
a384 1
		makefree (checkq);
d389 1
a389 1
	boardcopy (now);
d391 4
a394 3

boardcopy (s)
register struct BOARD	*s;			/* game situation */
d396 1
a396 1
	register int	i;			/* index */
d400 1
a400 1
	for (i = 0; i < 2; i++)  {
d404 1
a404 1
	for (i = 0; i < mvlim; i++)  {
d409 5
a413 4

movcmp ()  {
	register int	i;
	register int	c;
d417 1
a417 1
		trace = fopen ("bgtrace","w");
d420 2
a421 2
	odds (0,0,0);
	if (!race)  {
d423 1
a423 1
		for (i = 1; i < 25; i++)  {
d425 2
a426 2
				ch = canhit (i,1);
				op += abs (bar-i);
d428 5
a432 5
		for (i = bar+cturn; i != home; i += cturn)
			if (board[i]*cturn > 1)
				pt += abs(bar-i);
		frc = freemen (bar)+trapped (bar,cturn);
		frp = freemen (home)+trapped (home,-cturn);
d435 1
a435 1
		if (board[em]*cturn > 0)
d437 1
a437 1
	em = abs(home-em);
d439 1
a439 1
	fputs ("Board: ",trace);
d441 1
a441 1
		fprintf (trace, " %d",board[i]);
d443 1
a443 1
		fprintf (trace,"\n\tem = %d\n",em);
d445 1
a445 1
		fprintf (trace,
d447 2
a448 2
			ch,pt,em,frc,frp);
	fputs ("\tMove: ",trace);
d450 4
a453 4
		fprintf (trace," %d-%d",p[i],g[i]);
	fputs ("\n",trace);
	fflush (trace);
	strcpy (tests,"");
d455 1
a455 1
	if ((cp[0] == 0 && cg[0] == 0) || movegood())  {
d457 2
a458 2
		fprintf (trace,"\t[%s] ... wins.\n",tests);
		fflush (trace);
d460 1
a460 1
		for (i = 0; i < mvlim; i++)  {
d464 1
a464 1
		if (!race)  {
d477 3
a479 3
	else  {
		fprintf (trace,"\t[%s] ... loses.\n",tests);
		fflush (trace);
d483 5
a487 3

movegood ()  {
	register int	n;
d490 1
a490 1
		return (1);
d492 2
a493 2
		return (0);
	if (race)  {
d495 1
a495 1
		strcat (tests,"o");
d497 2
a498 2
		if (*offptr-menoff)
			return (*offptr > menoff);
d500 1
a500 1
		strcat (tests,"e");
d502 2
a503 2
		if (endman-em)
			return (endman > em);
d505 1
a505 1
		strcat (tests,"i");
d508 1
a508 1
			return (0);
d510 1
a510 1
			return (1);
d512 1
a512 1
		strcat (tests,"i");
d514 5
a518 5
		if (*inptr-menin)
			return (*inptr > menin);
		return (rnum(2));
	} else  {
		n = barmen-abs(board[home]);
d520 1
a520 1
		strcat (tests,"c");
d522 2
a523 2
		if (abs(chance-ch)+25*n > rnum(150))
			return (n? (n < 0): (ch < chance));
d525 1
a525 1
		strcat (tests,"o");
d527 2
a528 2
		if (*offptr-menoff)
			return (*offptr > menoff);
d530 1
a530 1
		strcat (tests,"o");
d532 2
a533 2
		if (abs(openmen-op) > 7+rnum(12))
			return (openmen > op);
d535 1
a535 1
		strcat (tests,"b");
d538 1
a538 1
			return (n < 0);
d540 1
a540 1
		strcat (tests,"e");
d542 2
a543 2
		if (abs(endman-em) > rnum(2))
			return (endman > em);
d545 1
a545 1
		strcat (tests,"f");
d547 2
a548 2
		if (abs(frc-oldfrc) > rnum(2))
			return (frc < oldfrc);
d550 1
a550 1
		strcat (tests,"p");
d552 2
a553 2
		if (abs(n = pt-points) > rnum(4))
			return (n > 0);
d555 1
a555 1
		strcat (tests,"i");
d557 2
a558 2
		if (*inptr-menin)
			return (*inptr > menin);
d560 1
a560 1
		strcat (tests,"f");
d562 3
a564 3
		if (abs(frp-oldfrp) > rnum(2))
			return (frp > oldfrp);
		return (rnum(2));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

