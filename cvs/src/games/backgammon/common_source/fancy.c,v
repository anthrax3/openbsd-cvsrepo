head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.6
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.26
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.18
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.22
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.20
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.16
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.14
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.12
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.10
	OPENBSD_5_0:1.12.0.8
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.28
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.24
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.22
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.20
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.18
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.16
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.14
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.12
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.8
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.6
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.4
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.11.30.08.19.25;	author tb;	state Exp;
branches;
next	1.12;
commitid	DsnnMPnBHkgAj0Eo;

1.12
date	2009.10.27.23.59.23;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.03.03.01.38;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.23.23.50.03;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.23.21.35.00;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.21.03.10.30;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	99.07.31.21.57.40;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	98.09.02.06.46.51;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	98.08.19.05.55.03;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	98.04.26.14.52.17;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	98.03.19.11.13.19;	author pjanzen;	state Exp;
branches;
next	1.2;

1.2
date	97.08.19.02.54.40;	author kstailey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.40;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Pledge for backgammon and teachgammon.

Both are straightforward "stdio rpath tty" programs; teachgammon
exec's backgammon at the end, so give it "exec" in addition.

While there, ANSIfy
@
text
@/*	$OpenBSD: fancy.c,v 1.12 2009/10/27 23:59:23 deraadt Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <err.h>
#include "back.h"

int     oldb[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
int     oldr, oldw;

void
fboard(void)
{
	int     i, j, k, l;

	/* could use box() or wborder() instead of the following */
	move(0, 0);		/* do top line */
	for (i = 0; i < 53; i++)
		addch('_');

	move(15, 0);		/* do bottom line */
	for (i = 0; i < 53; i++)
		addch('_');

	l = 1;			/* do vertical lines */
	for (i = 52; i > -1; i -= 28) {
		k = (l == 1 ? 1 : 15);
		mvaddch(k, i, '|');
		for (j = 0; j < 14; j++)
			mvaddch(k += l, i, '|');
		if (i == 24)
			i += 32;
		l = -l;		/* alternate directions */
	}

	/* label positions */
	for (i = 13; i < 19; i++)
		mvprintw(2, 1 + (i - 13) * 4, "%d", i);
	for (i = 19; i < 25; i++)
		mvprintw(2, 29 + (i - 19) * 4, "%d", i);
	for (i = 12; i > 6; i--)
		mvprintw(14, 1 + (12 - i) * 4, "%2d", i);
	for (i = 6; i > 0; i--)
		mvprintw(14, 30 + (6 - i) * 4, "%d", i);

	/* print positions 12-7 */
	for (i = 12; i > 6; i--)
		if (board[i])
			bsect(board[i], 13, 1 + 4 * (12 - i), -1);
	/* print red men on bar */
	if (board[0])
		bsect(board[0], 13, 25, -1);
	/* print positions 6-1 */
	for (i = 6; i > 0; i--)
		if (board[i])
			bsect(board[i], 13, 29 + 4 * (6 - i), -1);
	/* print white's home */
	l = (off[1] < 0 ? off[1] + 15 : off[1]);
	bsect(l, 3, 54, 1);

	mvaddstr(8, 25, "BAR");

	/* print positions 13-18 */
	for (i = 13; i < 19; i++)
		if (board[i])
			bsect(board[i], 3, 1 + 4 * (i - 13), 1);
	/* print white's men on bar */
	if (board[25])
		bsect(board[25], 3, 25, 1);
	/* print positions 19-24 */
	for (i = 19; i < 25; i++)
		if (board[i])
			bsect(board[i], 3, 29 + 4 * (i - 19), 1);
	/* print red's home */
	l = (off[0] < 0 ? off[0] + 15 : off[0]);
	bsect(-l, 13, 54, -1);

	for (i = 0; i < 26; i++)/* save board position for refresh later */
		oldb[i] = board[i];
	oldr = (off[1] < 0 ? off[1] + 15 : off[1]);
	oldw = -(off[0] < 0 ? off[0] + 15 : off[0]);
}

/*
 * bsect (b,rpos,cpos,cnext)
 *	Print the contents of a board position.  "b" has the value of the
 * position, "rpos" is the row to start printing, "cpos" is the column to
 * start printing, and "cnext" is positive if the position starts at the top
 * and negative if it starts at the bottom.  The value of "cpos" is checked
 * to see if the position is a player's home, since those are printed
 * differently.
 */
void
bsect(int b, int rpos, int cpos, int cnext)
{
	int     j;		/* index */
	int     n;		/* number of men on position */
	int     bct;		/* counter */
	int     k;		/* index */
	char    pc;		/* color of men on position */

	n = abs(b);		/* initialize n and pc */
	pc = (b > 0 ? 'r' : 'w');

	if (n < 6 && cpos < 54)	/* position cursor at start */
		move(rpos, cpos + 1);
	else
		move(rpos, cpos);

	for (j = 0; j < 5; j++) {	/* print position row by row */

		for (k = 0; k < 15; k += 5)	/* print men */
			if (n > j + k)
				addch(pc);

		if (j < 4) {	/* figure how far to back up for next row */
			if (n < 6) {	/* stop if none left */
				if (j + 1 == n)
					break;
				bct = 1;	/* single column */
			} else {
				if (n < 11) {	/* two columns */
					if (cpos >= 54) {	/* home pos */
						if (j + 5 >= n)
							bct = 1;
						else
							bct = 2;
					} else { 	/* not home */
						if (j + 6 >= n)
							bct = 1;
						else
							bct = 2;
					}
				} else {	/* three columns */
					if (j + 10 >= n)
						bct = 2;
					else
						bct = 3;
				}
			}
			getyx(stdscr, rpos, cpos);
			move(rpos + cnext, cpos - bct);
		}
	}
}

void
moveplayers(void)
{
	int i, r, c;

	getyx(stdscr, r, c);
	for (i = 12; i > 6; i--)/* fix positions 12-7 */
		if (board[i] != oldb[i]) {
			fixpos(oldb[i], board[i], 13, 1 + (12 - i) * 4, -1);
			oldb[i] = board[i];
		}
	if (board[0] != oldb[0]) {	/* fix red men on bar */
		fixpos(oldb[0], board[0], 13, 25, -1);
		oldb[0] = board[0];
	}
	for (i = 6; i > 0; i--)	/* fix positions 6-1 */
		if (board[i] != oldb[i]) {
			fixpos(oldb[i], board[i], 13, 29 + (6 - i) * 4, -1);
			oldb[i] = board[i];
		}
	i = -(off[0] < 0 ? off[0] + 15 : off[0]);	/* fix white's home */
	if (oldw != i) {
		fixpos(oldw, i, 13, 54, -1);
		oldw = i;
	}
	for (i = 13; i < 19; i++)	/* fix positions 13-18 */
		if (board[i] != oldb[i]) {
			fixpos(oldb[i], board[i], 3, 1 + (i - 13) * 4, 1);
			oldb[i] = board[i];
		}
	if (board[25] != oldb[25]) {	/* fix white men on bar */
		fixpos(oldb[25], board[25], 3, 25, 1);
		oldb[25] = board[25];
	}
	for (i = 19; i < 25; i++)	/* fix positions 19-24 */
		if (board[i] != oldb[i]) {
			fixpos(oldb[i], board[i], 3, 29 + (i - 19) * 4, 1);
			oldb[i] = board[i];
		}
	i = (off[1] < 0 ? off[1] + 15 : off[1]);	/* fix red's home */
	if (oldr != i) {
		fixpos(oldr, i, 3, 54, 1);
		oldr = i;
	}
	move(r, c);		/* return to saved position */
	refresh();
}
	

void
fixpos(int old, int new, int r, int c, int inc)
{
	int     o, n, nv;
	int     ov, nc;
	char    col;

	nc = 0;
	if (old * new >= 0) {
		ov = abs(old);
		nv = abs(new);
		col = (old + new > 0 ? 'r' : 'w');
		o = (ov - 1) / 5;
		n = (nv - 1) / 5;
		if (o == n) {
			if (o == 2)
				nc = c + 2;
			if (o == 1)
				nc = c < 54 ? c : c + 1;
			if (o == 0)
				nc = c < 54 ? c + 1 : c;
			if (ov > nv)
				fixcol(r + inc * (nv - n * 5), nc, abs(ov - nv), ' ', inc);
			else
				fixcol(r + inc * (ov - o * 5), nc, abs(ov - nv), col, inc);
			return;
		} else {
			if (c < 54) {
				if (o + n == 1) {
					if (n) {
						fixcol(r, c, abs(nv - 5), col, inc);
						if (ov != 5)
							fixcol(r+inc*ov, c+1, abs(ov-5), col, inc);
					} else  {
						fixcol(r, c, abs(ov - 5), ' ', inc);
						if (nv != 5)
							fixcol(r+inc*nv, c+1, abs(nv-5), ' ', inc);
					}
					return;
				}
				if (n == 2) {
					if (ov != 10)
						fixcol(r+inc*(ov-5), c, abs(ov-10), col, inc);
					fixcol(r, c + 2, abs(nv - 10), col, inc);
				} else {
					if (nv != 10)
						fixcol(r+inc*(nv-5), c, abs(nv-10), ' ', inc);
					fixcol(r, c + 2, abs(ov - 10), ' ', inc);
				}
				return;
			}
			if (n > o) {
				fixcol(r+inc*(ov%5), c+o, abs(5*n-ov), col, inc);
				if (nv != 5 * n)
					fixcol(r, c+n, abs(5*n-nv), col, inc);
			} else {
				fixcol(r+inc*(nv%5), c+n, abs(5*n-nv), ' ', inc);
				if (ov != 5 * o)
					fixcol(r, c+o, abs(5*o-ov), ' ', inc);
			}
			return;
		}
	}
	nv = abs(new);
	fixcol(r, c + 1, nv, new > 0 ? 'r' : 'w', inc);
	if (abs(old) <= abs(new))
		return;
	fixcol(r + inc * new, c + 1, abs(old + new), ' ', inc);
}

void
fixcol(int r, int c, int l, int ch, int inc)
{
	int     i;

	mvaddch(r, c, ch);
	for (i = 1; i < l; i++) {
		r += inc;
		mvaddch(r, c, ch);
	}
}


void
initcurses(void)
{
	initscr();
	cbreak();
	noecho();
	keypad(stdscr, TRUE);
	nl();
	clear();

	if ((LINES < 24) || (COLS < 80)) {
		endwin();
		errx(1, "screen must be at least 24x80.");
	}
}
@


1.12
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: fancy.c,v 1.11 2003/06/03 03:01:38 millert Exp $	*/
d39 1
a39 1
fboard()
d121 1
a121 5
bsect(b, rpos, cpos, cnext)
	int     b;		/* contents of position */
	int     rpos;		/* row of position */
	int     cpos;		/* column of position */
	int     cnext;		/* direction of position */
d175 1
a175 1
moveplayers()
d224 1
a224 2
fixpos(old, new, r, c, inc)
	int     old, new, r, c, inc;
d294 1
a294 2
fixcol(r, c, l, ch, inc)
	int     r, c, l, ch, inc;
d307 1
a307 1
initcurses()
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fancy.c,v 1.10 2001/06/23 23:50:03 pjanzen Exp $	*/
a30 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)fancy.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: fancy.c,v 1.10 2001/06/23 23:50:03 pjanzen Exp $";
#endif
#endif /* not lint */
@


1.10
log
@termios -> curses
@
text
@d1 1
a1 1
/*	$OpenBSD: fancy.c,v 1.9 2000/07/23 21:35:00 pjanzen Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d36 1
a36 1
static char rcsid[] = "$OpenBSD: fancy.c,v 1.9 2000/07/23 21:35:00 pjanzen Exp $";
@


1.9
log
@Avoid calling functions that can call the exit-on-error handler from the
handler; use STD*_FILENO rather than 0-2.
@
text
@d1 1
a1 1
/*	$OpenBSD: fancy.c,v 1.8 2000/04/21 03:10:30 pjanzen Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fancy.c,v 1.8 2000/04/21 03:10:30 pjanzen Exp $";
d44 1
a46 28
char    PC;			/* padding character */
char   *BC;			/* backspace sequence */
char   *CD;			/* clear to end of screen sequence */
char   *CE;			/* clear to end of line sequence */
char   *CL;			/* clear screen sequence */
char   *CM;			/* cursor movement instructions */
char   *HO;			/* home cursor sequence */
char   *ND;			/* forward cursor sequence */
char   *UP;			/* up cursor sequence */

int     lHO;			/* length of HO */
int     lBC;			/* length of BC */
int     lND;			/* length of ND */
int     lUP;			/* length of UP */
int     CO;			/* number of columns */
int     LI;			/* number of lines */
int    *linect;		/* array of lengths of lines on screen
				   (the actual screen is not stored) */

/* two letter codes */
char    *tcap[] = {"le", "cd", "ce", "cl", "cm", "ho", "nd", "up", NULL};
/* corresponding strings */
char  **tstr[] = {&BC, &CD, &CE, &CL, &CM, &HO, &ND, &UP};

int     buffnum;		/* pointer to output buffer */

char    tbuf[1024];		/* buffer for decoded terminfo entries */

d48 1
a48 8

int     oldr;
int     oldw;

/* "real" cursor positions, so it knows when to reposition.
 * These are -1 if curr and curc are accurate */
int     realr;
int     realc;
d53 1
a53 1
	int     i, j, l;
d55 2
a56 1
	curmove(0, 0);		/* do top line */
d58 1
a58 1
		fancyc('_');
d60 1
a60 1
	curmove(15, 0);		/* do botttom line */
d62 1
a62 1
		fancyc('_');
d66 4
a69 6
		curmove((l == 1 ? 1 : 15), i);
		fancyc('|');
		for (j = 0; j < 14; j++) {
			curmove(curr + l, curc - 1);
			fancyc('|');
		}
d75 9
a83 33
	curmove(2, 1);		/* label positions 13-18 */
	for (i = 13; i < 18; i++) {
		fancyc('1');
		fancyc((i % 10) + '0');
		curmove(curr, curc + 2);
	}
	fancyc('1');
	fancyc('8');

	curmove(2, 29);		/* label positions 19-24 */
	fancyc('1');
	fancyc('9');
	for (i = 20; i < 25; i++) {
		curmove(curr, curc + 2);
		fancyc('2');
		fancyc((i % 10) + '0');
	}

	curmove(14, 1);		/* label positions 12-7 */
	fancyc('1');
	fancyc('2');
	for (i = 11; i > 6; i--) {
		curmove(curr, curc + 2);
		fancyc(i > 9 ? '1' : ' ');
		fancyc((i % 10) + '0');
	}

	curmove(14, 30);	/* label positions 6-1 */
	fancyc('6');
	for (i = 5; i > 0; i--) {
		curmove(curr, curc + 3);
		fancyc(i + '0');
	}
d85 2
a86 1
	for (i = 12; i > 6; i--)/* print positions 12-7 */
d89 2
a90 2

	if (board[0])		/* print red men on bar */
d92 2
a93 2

	for (i = 6; i > 0; i--)	/* print positions 6-1 */
d96 2
a97 2

	l = (off[1] < 0 ? off[1] + 15 : off[1]);	/* print white's home */
d100 1
a100 4
	curmove(8, 25);		/* print the word BAR */
	fancyc('B');
	fancyc('A');
	fancyc('R');
d102 2
a103 1
	for (i = 13; i < 19; i++)	/* print positions 13-18 */
d106 2
a107 2

	if (board[25])		/* print white's men on bar */
d109 2
a110 2

	for (i = 19; i < 25; i++)	/* print positions 19-24 */
d113 2
a114 2

	l = (off[0] < 0 ? off[0] + 15 : off[0]);	/* print red's home */
d149 1
a149 1
		curmove(rpos, cpos + 1);
d151 1
a151 1
		curmove(rpos, cpos);
d157 1
a157 1
				fancyc(pc);
d166 1
a166 1
					if (cpos == 54) {	/* home pos */
d171 1
a171 2
					}
					if (cpos < 54) {	/* not home */
d184 2
a185 1
			curmove(curr + cnext, curc - bct);	/* reposition cursor */
d191 1
a191 1
refresh()
d193 1
a193 4
	int     i, r, c;

	r = curr;		/* save current position */
	c = curc;
d195 1
d234 2
a235 3
	curmove(r, c);		/* return to saved position */
	newpos();
	buflush();
d237 1
d316 1
a316 2
	curmove(r, c);
	fancyc(ch);
d318 2
a319 89
		curmove(curr + inc, curc - 1);
		fancyc(ch);
	}
}

void
curmove(r, c)
	int     r, c;
{
	if (curr == r && curc == c)
		return;
	if (realr == -1) {
		realr = curr;
		realc = curc;
	}
	curr = r;
	curc = c;
}

void
newpos()
{
	int     r;		/* destination row */
	int     c;		/* destination column */
	int     mode = -1;	/* mode of movement */

	int     count = 1000;	/* character count */
	int     i;		/* index */
	int     n;		/* temporary variable */
	char   *m;		/* string containing CM movement */

	if (realr == -1)	/* see if already there */
		return;

	r = curr;		/* set current and dest. positions */
	c = curc;
	curr = realr;
	curc = realc;

	/* double check position */
	if (curr == r && curc == c) {
		realr = realc = -1;
		return;
	}
	if (CM) {		/* try CM to get there */
		mode = 0;
		m = (char *)tgoto(CM, c, r);
		count = strlen(m);
	}
	/* try HO and local movement */
	if (HO && (n = r + c * lND + lHO) < count) {
		mode = 1;
		count = n;
	}
	/* try various LF combinations */
	if (r >= curr) {
		/* CR, LF, and ND */
		if ((n = (r - curr) + c * lND + 1) < count) {
			mode = 2;
			count = n;
		}
		/* LF, ND */
		if (c >= curc && (n = (r - curr) + (c - curc) * lND) < count) {
			mode = 3;
			count = n;
		}
		/* LF, BS */
		if (c < curc && (n = (r - curr) + (curc - c) * lBC) < count) {
			mode = 4;
			count = n;
		}
	}
	/* try corresponding UP combinations */
	if (r < curr) {
		/* CR, UP, and ND */
		if ((n = (curr - r) * lUP + c * lND + 1) < count) {
			mode = 5;
			count = n;
		}
		/* UP and ND */
		if (c >= curc && (n = (curr - r) * lUP + (c - curc) * lND) < count) {
			mode = 6;
			count = n;
		}
		/* UP and BS */
		if (c < curc && (n = (curr - r) * lUP + (curc - c) * lBC) < count) {
			mode = 7;
			count = n;
		}
a320 79
	/* space over */
	if (curr == r && c > curc && linect[r] < curc && c - curc < count)
		mode = 8;

	switch (mode) {
	case -1:		/* error! */
		write(STDERR_FILENO, "\r\nInternal cursor error.\r\n", 26);
		tflag = 0;	/* So we don't loop */
		getout(0);

	case  0:		/* direct cursor motion */
		tputs(m, abs(curr - r), addbuf);
		break;

	case  1:		/* relative to "home" */
		tputs(HO, r, addbuf);
		for (i = 0; i < r; i++)
			addbuf('\012');
		for (i = 0; i < c; i++)
			tputs(ND, 1, addbuf);
		break;

	case  2:		/* CR and down and over */
		addbuf('\015');
		for (i = 0; i < r - curr; i++)
			addbuf('\012');
		for (i = 0; i < c; i++)
			tputs(ND, 1, addbuf);
		break;

	case  3:		/* down and over */
		for (i = 0; i < r - curr; i++)
			addbuf('\012');
		for (i = 0; i < c - curc; i++)
			tputs(ND, 1, addbuf);
		break;

	case  4:		/* down and back */
		for (i = 0; i < r - curr; i++)
			addbuf('\012');
		for (i = 0; i < curc - c; i++)
			addbuf('\010');
		break;

	case  5:		/* CR and up and over */
		addbuf('\015');
		for (i = 0; i < curr - r; i++)
			tputs(UP, 1, addbuf);
		for (i = 0; i < c; i++)
			tputs(ND, 1, addbuf);
		break;

	case  6:		/* up and over */
		for (i = 0; i < curr - r; i++)
			tputs(UP, 1, addbuf);
		for (i = 0; i < c - curc; i++)
			tputs(ND, 1, addbuf);
		break;

	case  7:		/* up and back */
		for (i = 0; i < curr - r; i++)
			tputs(UP, 1, addbuf);
		for (i = 0; i < curc - c; i++)  {
			if (BC)
				tputs(BC, 1, addbuf);
			else
				addbuf('\010');
		}
		break;

	case  8:		/* safe space */
		for (i = 0; i < c - curc; i++)
			addbuf(' ');
	}
	/* fix positions */
	curr = r;
	curc = c;
	realr = -1;
	realc = -1;
a322 17
void
clear()
{
	int     i;

	/* double space if can't clear */
	if (CL == 0) {
		writel("\n\n");
		return;
	}
	curr = curc = 0;	/* fix position markers */
	realr = realc = -1;
	for (i = 0; i < 24; i++)/* clear line counts */
		linect[i] = -1;
	buffnum = -1;		/* ignore leftover buffer contents */
	tputs(CL, LI, addbuf);	/* put CL in buffer */
}
d325 1
a325 2
fancyc(c)
	int     c;		/* character to output */
d327 6
a332 1
	int     sp;		/* counts spaces in a tab */
d334 3
a336 17
	if (c == '\007') {	/* bells go in blindly */
		addbuf(c);
		return;
	}
	/* process tabs, use spaces if the the tab should be erasing things,
	 * otherwise use cursor movement routines.  Note this does not use
	 * hardware tabs at all. */
	if (c == '\t') {
		sp = (curc + 8) & (~7);	/* compute spaces */
		/* check line length */
		if (linect[curr] >= curc || sp < 4) {
			for (; sp > curc; sp--)
				addbuf(' ');
			curc = sp;	/* fix curc */
		} else
			curmove(curr, sp);
		return;
a337 119
	if (c == '\n') {
		cline();
		if (curr == LI - 1)
			curmove(begscr, 0);
		else
			curmove(curr + 1, 0);
		return;
	}
	/* ignore any other control chars */
	if (c < ' ')
		return;

	/* if an erasing space or non-space, just add it to buffer.  Otherwise
	 * use cursor movement routine, so that multiple spaces will be grouped
	 * together */
	if (c > ' ' || linect[curr] >= curc) {
		newpos();	/* make sure position correct */
		addbuf(c);	/* add character to buffer */
		/* fix line length */
		if (c == ' ' && linect[curr] == curc)
			linect[curr]--;
		else if (linect[curr] < curc)
			linect[curr] = curc;
		curc++;			/* fix curc */
	} else
		/* use cursor movement routine */
		curmove(curr, curc + 1);
}

void
clend()
{
	int     i;

/*	*** Why does this code fail? ***
 *	if (CD) {
 *		tputs(CD, (LI - curr), addbuf);
 *		for (i = curr; i < LI; i++)
 *			linect[i] = -1;
 *		return;
 *	}
 */
	curmove(i = curr, 0);
	cline();
	while (curr < LI - 1) {
		curmove(curr + 1, 0);
		if (linect[curr] > -1)
			cline();
	}
	curmove(i, 0);
}

void
cline()
{
	int     c;

	if (curc > linect[curr])
		return;
	newpos();
	if (CE) {
		tputs(CE, 1, addbuf);
		linect[curr] = curc - 1;
	} else {
		c = curc - 1;
		while (linect[curr] > c) {
			addbuf(' ');
			curc++;
			linect[curr]--;
		}
		curmove(curr, c + 1);
	}
}

int
getcaps(s)
	const char   *s;
{
	char   **code;		/* two letter code */
	char ***cap;		/* pointer to cap string */
	char   *bufp;		/* pointer to cap buffer */
	char    tentry[1024];	/* temporary uncoded caps buffer */

	tgetent(tentry, s);	/* get uncoded terminfo entry */

	LI = tgetnum("li");	/* get number of lines */
	if (LI == -1)
		LI = 12;
	CO = tgetnum("co");	/* get number of columns */
	if (CO == -1)
		CO = 65;

	bufp = tbuf;		/* get padding character */
	tgetstr("pc", &bufp);
	if (bufp != tbuf)
		PC = *tbuf;
	else
		PC = 0;

	bufp = tbuf;		/* get string entries */
	cap = tstr;
	for (code = tcap; *code; code++)
		**cap++ = (char *)tgetstr(*code, &bufp);

	/* get pertinent lengths */
	if (HO)
		lHO = strlen(HO);
	if (BC)
		lBC = strlen(BC);
	else
		lBC = 1;
	if (UP)
		lUP = strlen(UP);
	if (ND)
		lND = strlen(ND);
	linect = (int *)calloc(LI + 1, sizeof(int));
	if (LI < 24 || CO < 72 || !(CL && UP && ND))
		return(0);
	return(1);
@


1.8
log
@documentation:  refer to terminfo, not termcap, where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: fancy.c,v 1.7 1999/07/31 21:57:40 pjanzen Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fancy.c,v 1.7 1999/07/31 21:57:40 pjanzen Exp $";
d477 2
a478 1
		write(2, "\r\nInternal cursor error.\r\n", 26);
@


1.7
log
@use const where appropriate (jsm28@@cam.ac.uk).  Also some very minor tidying.
@
text
@d1 1
a1 1
/*	$OpenBSD: fancy.c,v 1.6 1998/09/02 06:46:51 pjanzen Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fancy.c,v 1.6 1998/09/02 06:46:51 pjanzen Exp $";
d72 1
a72 1
char    tbuf[1024];		/* buffer for decoded termcap entries */
d676 1
a676 1
	tgetent(tentry, s);	/* get uncoded termcap entry */
@


1.6
log
@Delete two unused functions; jsm28@@cam.ac.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: fancy.c,v 1.5 1998/08/19 05:55:03 pjanzen Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fancy.c,v 1.5 1998/08/19 05:55:03 pjanzen Exp $";
d669 1
a669 1
	char   *s;
@


1.5
log
@Don't segfault in small windows
@
text
@d1 1
a1 1
/*	$OpenBSD: fancy.c,v 1.4 1998/04/26 14:52:17 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fancy.c,v 1.4 1998/04/26 14:52:17 millert Exp $";
a566 6
}

void
tos()
{				/* home cursor */
	curmove(0, 0);
@


1.4
log
@Fix terminal initialization for libtermlib to be happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: fancy.c,v 1.3 1998/03/19 11:13:19 pjanzen Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fancy.c,v 1.3 1998/03/19 11:13:19 pjanzen Exp $";
d714 1
a716 1
	linect = (int *)calloc(LI + 1, sizeof(int));
@


1.3
log
@NetBSD changes and further improvements and corrections
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD$";
d66 1
a66 1
char    tcap[] = "lecdceclcmhondup";
d677 1
a677 1
	char   *code;		/* two letter code */
d700 2
a701 2
	for (code = tcap; *code; code += 2)
		**cap++ = (char *)tgetstr(code, &bufp);
@


1.2
log
@bc -> le
@
text
@d1 1
a1 1
/*	$NetBSD: fancy.c,v 1.4 1995/04/24 12:22:09 cgd Exp $	*/
d40 1
a40 1
static char rcsid[] = "$NetBSD: fancy.c,v 1.4 1995/04/24 12:22:09 cgd Exp $";
d46 17
a62 19
char	PC;			/* padding character */
char	*BC;			/* backspace sequence */
char	*CD;			/* clear to end of screen sequence */
char	*CE;			/* clear to end of line sequence */
char	*CL;			/* clear screen sequence */
char	*CM;			/* cursor movement instructions */
char	*HO;			/* home cursor sequence */
char	*MC;			/* column cursor movement map */
char	*ML;			/* row cursor movement map */
char	*ND;			/* forward cursor sequence */
char	*UP;			/* up cursor sequence */

int	lHO;			/* length of HO */
int	lBC;			/* length of BC */
int	lND;			/* length of ND */
int	lUP;			/* length of UP */
int	CO;			/* number of columns */
int	LI;			/* number of lines */
int	*linect;		/* array of lengths of lines on screen
d65 4
a68 4
				/* two letter codes */
char	tcap[] = "lecdceclcmhomcmlndup";
				/* corresponding strings */
char	**tstr[] = { &BC, &CD, &CE, &CL, &CM, &HO, &MC, &ML, &ND, &UP };
d70 1
a70 1
int	buffnum;		/* pointer to output buffer */
d72 1
a72 1
char	tbuf[1024];		/* buffer for decoded termcap entries */
d74 1
a74 1
int	oldb[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
d76 2
a77 8
int	oldr;
int	oldw;
						/* "real" cursor positions, so
						 * it knows when to reposition.
						 * These are -1 if curr and curc
						 * are accurate */
int	realr;
int	realc;
d79 4
a82 2
void	addbuf();
extern char *tgoto(), *tgetstr();
d84 4
a87 2
fboard ()  {
	register int	i, j, l;
d89 1
a89 1
	curmove (0,0);				/* do top line */
d91 1
a91 1
		fancyc ('_');
d93 1
a93 1
	curmove (15,0);				/* do botttom line */
d95 1
a95 1
		fancyc ('_');
d97 7
a103 7
	l = 1;					/* do vertical lines */
	for (i = 52; i > -1; i -= 28)  {
		curmove ( (l == 1? 1: 15) ,i);
		fancyc ('|');
		for (j = 0; j < 14; j++)  {
			curmove (curr+l,curc-1);
			fancyc ('|');
d107 1
a107 1
		l = -l;				/* alternate directions */
d110 25
a134 25
	curmove (2,1);				/* label positions 13-18 */
	for (i = 13; i < 18; i++)  {
		fancyc ('1');
		fancyc ((i % 10)+'0');
		curmove (curr,curc+2);
	}
	fancyc ('1');
	fancyc ('8');

	curmove (2,29);				/* label positions 19-24 */
	fancyc ('1');
	fancyc ('9');
	for (i = 20; i < 25; i++)  {
		curmove (curr,curc+2);
		fancyc ('2');
		fancyc ((i % 10)+'0');
	}

	curmove (14,1);				/* label positions 12-7 */
	fancyc ('1');
	fancyc ('2');
	for (i = 11; i > 6; i--)  {
		curmove (curr,curc+2);
		fancyc (i > 9? '1': ' ');
		fancyc ((i % 10)+'0');
d137 2
a138 2
	curmove (14,30);			/* label positions 6-1 */
	fancyc ('6');
d140 2
a141 2
		curmove (curr,curc+3);
		fancyc (i+'0');
d144 1
a144 1
	for (i = 12; i > 6; i--)		/* print positions 12-7 */
d146 1
a146 1
			bsect (board[i],13,1+4*(12-i),-1);
d148 2
a149 2
	if (board[0])				/* print red men on bar */
		bsect (board[0],13,25,-1);
d151 1
a151 1
	for (i = 6; i > 0; i--)			/* print positions 6-1 */
d153 1
a153 1
			bsect (board[i],13,29+4*(6-i),-1);
d155 2
a156 2
	l = (off[1] < 0? off[1]+15: off[1]);	/* print white's home */
	bsect (l,3,54,1);
d158 4
a161 4
	curmove (8,25);				/* print the word BAR */
	fancyc ('B');
	fancyc ('A');
	fancyc ('R');
d163 1
a163 1
	for (i = 13; i < 19; i++)		/* print positions 13-18 */
d165 1
a165 1
			bsect (board[i],3,1+4*(i-13),1);
d167 2
a168 2
	if (board[25])				/* print white's men on bar */
		bsect (board[25],3,25,1);
d170 1
a170 1
	for (i = 19; i < 25; i++)		/* print positions 19-24 */
d172 1
a172 1
			bsect (board[i],3,29+4*(i-19),1);
d174 2
a175 2
	l = (off[0] < 0? off[0]+15: off[0]);	/* print red's home */
	bsect (-l,13,54,-1);
d177 1
a177 2
	for (i = 0; i < 26; i++)		/* save board position
						 * for refresh later */
d179 2
a180 2
	oldr = (off[1] < 0? off[1]+15: off[1]);
	oldw = -(off[0] < 0? off[0]+15: off[0]);
d182 1
a182 1

d192 12
d205 2
a206 12
bsect (b,rpos,cpos,cnext)
int	b;					/* contents of position */
int	rpos;					/* row of position */
int	cpos;					/* column of position */
int	cnext;					/* direction of position */

{
	register int	j;			/* index */
	register int	n;			/* number of men on position */
	register int	bct;			/* counter */
	int		k;			/* index */
	char		pc;			/* color of men on position */
d208 4
a211 2
	n = abs(b);				/* initialize n and pc */
	pc = (b > 0? 'r': 'w');
d213 1
a213 4
	if (n < 6 && cpos < 54)			/* position cursor at start */
		curmove (rpos,cpos+1);
	else
		curmove (rpos,cpos);
d215 3
a217 1
	for (j = 0; j < 5; j++)  {		/* print position row by row */
d219 3
a221 9
		for (k = 0; k < 15; k += 5)		/* print men */
			if (n > j+k)
				fancyc (pc);

		if (j < 4)  {				/* figure how far to
							 * back up for next
							 * row */
			if (n < 6)  {			/* stop if none left */
				if (j+1 == n)
d223 5
a227 5
				bct = 1;		/* single column */
			} else  {
				if (n < 11)  {		/* two columns */
					if (cpos == 54)  {	/* home pos */
						if (j+5 >= n)
d232 2
a233 2
					if (cpos < 54)  {	/* not home */
						if (j+6 >= n)
d238 2
a239 2
				} else  {		/* three columns */
					if (j+10 >= n)
d245 1
a245 1
			curmove (curr+cnext,curc-bct);	/* reposition cursor */
a248 3

refresh()  {
	register int	i, r, c;
d250 6
a255 1
	r = curr;				/* save current position */
d258 3
a260 3
	for (i = 12; i > 6; i--)		/* fix positions 12-7 */
		if (board[i] != oldb[i])  {
			fixpos (oldb[i],board[i],13,1+(12-i)*4,-1);
d263 2
a264 3

	if (board[0] != oldb[0])  {		/* fix red men on bar */
		fixpos (oldb[0],board[0],13,25,-1);
d267 3
a269 4

	for (i = 6; i > 0; i--)			/* fix positions 6-1 */
		if (board[i] != oldb[i])  {
			fixpos (oldb[i],board[i],13,29+(6-i)*4,-1);
d272 3
a274 4

	i = -(off[0] < 0? off[0]+15: off[0]);	/* fix white's home */
	if (oldw != i)  {
		fixpos (oldw,i,13,54,-1);
d277 3
a279 4

	for (i = 13; i < 19; i++)		/* fix positions 13-18 */
		if (board[i] != oldb[i])  {
			fixpos (oldb[i],board[i],3,1+(i-13)*4,1);
d282 2
a283 3

	if (board[25] != oldb[25])  {		/* fix white men on bar */
		fixpos (oldb[25],board[25],3,25,1);
d286 3
a288 4

	for (i = 19; i < 25; i++)		/* fix positions 19-24 */
		if (board[i] != oldb[i])  {
			fixpos (oldb[i],board[i],3,29+(i-19)*4,1);
d291 3
a293 4

	i = (off[1] < 0? off[1]+15: off[1]);	/* fix red's home */
	if (oldr != i)  {
		fixpos (oldr,i,3,54,1);
d296 1
a296 2

	curmove (r,c);				/* return to saved position */
a299 3

fixpos (old,new,r,c,inc)
int	old, new, r, c, inc;
d301 3
d305 3
a307 3
	register int	o, n, nv;
	int		ov, nc;
	char		col;
d309 2
a310 1
	if (old*new >= 0)  {
d313 4
a316 4
		col = (old+new > 0? 'r': 'w');
		o = (ov-1)/5;
		n = (nv-1)/5;
		if (o == n)  {
d318 1
a318 1
				nc = c+2;
d320 1
a320 1
				nc = c < 54? c: c+1;
d322 1
a322 1
				nc = c < 54? c+1: c;
d324 1
a324 1
				fixcol (r+inc*(nv-n*5),nc,abs(ov-nv),' ',inc);
d326 1
a326 1
				fixcol (r+inc*(ov-o*5),nc,abs(ov-nv),col,inc);
d328 5
a332 5
		} else  {
			if (c < 54)  {
				if (o+n == 1)  {
					if (n)  {
						fixcol (r,c,abs(nv-5),col,inc);
d334 1
a334 1
							fixcol (r+inc*ov,c+1,abs(ov-5),col,inc);
d336 1
a336 1
						fixcol (r,c,abs(ov-5),' ',inc);
d338 1
a338 1
							fixcol (r+inc*nv,c+1,abs(nv-5),' ',inc);
d342 1
a342 1
				if (n == 2)  {
d344 3
a346 3
						fixcol (r+inc*(ov-5),c,abs(ov-10),col,inc);
					fixcol (r,c+2,abs(nv-10),col,inc);
				} else  {
d348 2
a349 2
						fixcol (r+inc*(nv-5),c,abs(nv-10),' ',inc);
					fixcol (r,c+2,abs(ov-10),' ',inc);
d353 8
a360 8
			if (n > o)  {
				fixcol (r+inc*(ov%5),c+o,abs(5*n-ov),col,inc);
				if (nv != 5*n)
					fixcol (r,c+n,abs(5*n-nv),col,inc);
			} else  {
				fixcol (r+inc*(nv%5),c+n,abs(5*n-nv),' ',inc);
				if (ov != 5*o)
					fixcol (r,c+o,abs(5*o-ov),' ',inc);
d366 1
a366 1
	fixcol (r,c+1,nv,new > 0? 'r': 'w',inc);
d369 1
a369 1
	fixcol (r+inc*new,c+1,abs(old+new),' ',inc);
d372 3
a374 4
fixcol (r,c,l,ch,inc)
register int	l, ch;
int		r, c, inc;

d376 1
a376 1
	register int	i;
d378 5
a382 5
	curmove (r,c);
	fancyc (ch);
	for (i = 1; i < l; i++)  {
		curmove (curr+inc,curc-1);
		fancyc (ch);
a384 3

curmove (r,c)
register int	r, c;
d386 3
d392 1
a392 1
	if (realr == -1)  {
d400 6
a405 10
newpos ()  {
	register int	r;		/* destination row */
	register int	c;		/* destination column */
	register int	mode = -1;	/* mode of movement */

	int	count = 1000;		/* character count */
	int	i;			/* index */
	int	j;			/* index */
	int	n;			/* temporary variable */
	char	*m;			/* string containing CM movement */
d407 4
d412 1
a412 1
	if (realr == -1)		/* see if already there */
d415 1
a415 1
	r = curr;			/* set current and dest. positions */
d420 2
a421 2
					/* double check position */
	if (curr == r && curc == c)  {
d425 1
a425 2

	if (CM)  {			/* try CM to get there */
d427 2
a428 2
		m = (char *)tgoto (CM,c,r);
		count = strlen (m);
d430 2
a431 3

					/* try HO and local movement */
	if (HO && (n = r+c*lND+lHO) < count)  {
d435 4
a438 5

					/* try various LF combinations */
	if (r >= curr)  {
						/* CR, LF, and ND */
		if ((n = (r-curr)+c*lND+1) < count)  {
d442 2
a443 2
						/* LF, ND */
		if (c >= curc && (n = (r-curr)+(c-curc)*lND) < count)  {
d447 2
a448 2
						/* LF, BS */
		if (c < curc && (n = (r-curr)+(curc-c)*lBC) < count)  {
d453 4
a456 5

					/* try corresponding UP combinations */
	if (r < curr)  {
						/* CR, UP, and ND */
		if ((n = (curr-r)*lUP+c*lND+1) < count)  {
d460 2
a461 2
						/* UP and ND */
		if (c >= curc && (n = (curr-r)*lUP+(c-curc)*lND) < count)  {
d465 2
a466 2
						/* UP and BS */
		if (c < curc && (n = (curr-r)*lUP+(curc-c)*lBC) < count)  {
d471 2
a472 3

						/* space over */
	if (curr == r && c > curc && linect[r] < curc && c-curc < count)
d475 4
a478 1
	switch (mode)  {
d480 2
a481 7
	case -1:				/* error! */
		write (2,"\r\nInternal cursor error.\r\n",26);
		getout();

						/* direct cursor motion */
	case  0:
		tputs (m,abs(curr-r),addbuf);
d484 2
a485 3
						/* relative to "home" */
	case  1:
		tputs (HO,r,addbuf);
d487 1
a487 1
			addbuf ('\012');
d489 1
a489 1
			tputs (ND,1,addbuf);
d492 4
a495 5
						/* CR and down and over */
	case  2:
		addbuf ('\015');
		for (i = 0; i < r-curr; i++)
			addbuf ('\012');
d497 1
a497 1
			tputs (ND,1,addbuf);
d499 6
a504 7
	
						/* down and over */
	case  3:
		for (i = 0; i < r-curr; i++)
			addbuf ('\012');
		for (i = 0; i < c-curc; i++)
			tputs (ND,1,addbuf);
d506 6
a511 7
	
						/* down and back */
	case  4:
		for (i = 0; i < r-curr; i++)
			addbuf ('\012');
		for (i = 0; i < curc-c; i++)
			addbuf ('\010');
d513 5
a517 6
	
						/* CR and up and over */
	case  5:
		addbuf ('\015');
		for (i = 0; i < curr-r; i++)
			tputs (UP,1,addbuf);
d519 1
a519 1
			tputs (ND,1,addbuf);
d521 6
a526 7
	
						/* up and over */
	case  6:
		for (i = 0; i < curr-r; i++)
			tputs (UP,1,addbuf);
		for (i = 0; i < c-curc; i++)
			tputs (ND,1,addbuf);
d528 5
a532 6
	
						/* up and back */
	case  7:
		for (i = 0; i < curr-r; i++)
			tputs (UP,1,addbuf);
		for (i = 0; i < curc-c; i++)  {
d534 1
a534 1
				tputs (BC,1,addbuf);
d536 1
a536 1
				addbuf ('\010');
d540 3
a542 4
						/* safe space */
	case  8:
		for (i = 0; i < c-curc; i++)
			addbuf (' ');
d544 1
a544 2

						/* fix positions */
d550 9
a558 7

clear ()  {
	register int	i;

					/* double space if can't clear */
	if (CL == 0)  {
		writel ("\n\n");
d561 1
a561 2

	curr = curc = 0;		/* fix position markers */
d563 1
a563 1
	for (i = 0; i < 24; i++)	/* clear line counts */
d565 2
a566 2
	buffnum = -1;			/* ignore leftover buffer contents */
	tputs (CL,CO,addbuf);		/* put CL in buffer */
d569 4
a572 2
tos ()  {				/* home cursor */
	curmove (0,0);
d574 4
a577 3

fancyc (c)
register char	c;			/* character to output */
d579 1
a579 1
	register int	sp;		/* counts spaces in a tab */
d581 2
a582 2
	if (c == '\007')  {		/* bells go in blindly */
		addbuf (c);
d585 7
a591 10

					/* process tabs, use spaces if the
					 * the tab should be erasing things,
					 * otherwise use cursor movement
					 * routines.  Note this does not use
					 * hardware tabs at all. */
	if (c == '\t')  {
		sp = (curc+8) & (~ 7);		/* compute spaces */
						/* check line length */
		if (linect[curr] >= curc || sp < 4)  {
d593 2
a594 2
				addbuf (' ');
			curc = sp;		/* fix curc */
d596 1
a596 1
			curmove (curr,sp);
d599 6
a604 4

					/* do newline be calling newline */
	if (c == '\n')  {
		newline();
d607 1
a607 2

					/* ignore any other control chars */
d611 7
a617 9
					/* if an erasing space or non-space,
					 * just add it to buffer.  Otherwise
					 * use cursor movement routine, so that
					 * multiple spaces will be grouped
					 * together */
	if (c > ' ' || linect[curr] >= curc)  {
		newpos ();			/* make sure position correct */
		addbuf (c);			/* add character to buffer */
						/* fix line length */
d622 1
a622 1
		curc++;				/* fix curc */
d624 2
a625 2
					/* use cursor movement routine */
		curmove (curr,curc+1);
a626 4

clend()  {
	register int	i;
	register char	*s;
d628 4
d633 9
a641 8
	if (CD)  {
		tputs (CD,CO-curr,addbuf);
		for (i = curr; i < LI; i++)
			linect[i] = -1;
		return;
	}

	curmove (i = curr,0);
d643 2
a644 2
	while (curr < LI-1)  {
		curmove (curr+1,0);
d646 1
a646 1
			cline ();
d648 1
a648 1
	curmove (i,0);
d651 4
a654 4
cline ()  {
	register int	i;
	register int	c;
	register char	*s;
d658 8
a665 8
	newpos ();
	if (CE)  {
		tputs (CE,1,addbuf);
		linect[curr] = curc-1;
	} else  {
		c = curc-1;
		while (linect[curr] > c)  {
			addbuf (' ');
d669 1
a669 1
		curmove (curr,c+1);
d673 3
a675 11
newline ()  {
	cline();
	if (curr == LI-1)
		curmove (begscr,0);
	else
		curmove (curr+1,0);
}

getcaps (s)
register char	*s;

d677 4
a680 4
	register char	*code;		/* two letter code */
	register char	***cap;		/* pointer to cap string */
	char		*bufp;		/* pointer to cap buffer */
	char		tentry[1024];	/* temporary uncoded caps buffer */
d682 1
a682 1
	tgetent (tentry,s);		/* get uncoded termcap entry */
d684 1
a684 1
	LI = tgetnum ("li");		/* get number of lines */
d687 1
a687 1
	CO = tgetnum ("co");		/* get number of columns */
d691 2
a692 2
	bufp = tbuf;			/* get padding character */
	tgetstr ("pc",&bufp);
d698 1
a698 1
	bufp = tbuf;			/* get string entries */
d701 1
a701 1
		**cap++ = (char *)tgetstr (code,&bufp);
d703 1
a703 1
					/* get pertinent lengths */
d705 1
a705 1
		lHO = strlen (HO);
d707 1
a707 1
		lBC = strlen (BC);
d711 1
a711 1
		lUP = strlen (UP);
d713 1
a713 1
		lND = strlen (ND);
d715 3
a717 3
		return (0);
	linect = (int *)calloc (LI+1,sizeof(int));
	return (1);
@


1.1
log
@Initial revision
@
text
@d68 1
a68 1
char	tcap[] = "bccdceclcmhomcmlndup";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

