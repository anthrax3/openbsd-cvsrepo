head	1.22;
access;
symbols
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.16
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.14
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.12
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.10
	OPENBSD_5_0:1.18.0.8
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.6
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.8
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.4
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.15.0.4
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.13.0.10
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.8
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.6
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.11.0.8
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.6
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.4
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.10.0.4
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2015.12.02.20.05.01;	author tb;	state Exp;
branches;
next	1.21;
commitid	d7NTsg9vGQclKcoo;

1.21
date	2015.11.30.08.19.25;	author tb;	state Exp;
branches;
next	1.20;
commitid	DsnnMPnBHkgAj0Eo;

1.20
date	2015.06.26.19.18.03;	author otto;	state Exp;
branches;
next	1.19;
commitid	rLN6ksd9DcCJ3lkE;

1.19
date	2013.11.27.13.32.02;	author okan;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.27.23.59.23;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.17.09.17.56;	author sobrado;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.17.20.10.44;	author chl;	state Exp;
branches;
next	1.15;

1.15
date	2006.10.31.18.15.15;	author ray;	state Exp;
branches;
next	1.14;

1.14
date	2006.10.29.20.02.41;	author martin;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.07.14.09.35;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.03.03.01.38;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.23.23.50.04;	author pjanzen;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.23.21.35.00;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.21.03.10.30;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	99.07.31.21.57.41;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	98.11.29.19.45.10;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	98.09.02.06.46.51;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	98.03.19.11.13.26;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	97.07.23.20.04.45;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.14.07.06.41;	author etheisen;	state Exp;
branches;
next	1.2;

1.2
date	96.02.12.07.42.26;	author etheisen;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.40;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Drop the argument passing between backgammon and teachgammon.
It's broken.  Instead, make -d imply -n.  You're supposed to
know the rules before you start tweaking them.

Issue reported by and ok pjanzen@@
Patient help with the manual jmc@@
@
text
@/*	$OpenBSD: subs.c,v 1.21 2015/11/30 08:19:25 tb Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "back.h"

__dead void	usage(void);

int     buffnum;
char    outbuff[BUFSIZ];

static const char plred[] = "Player is red, computer is white.";
static const char plwhite[] = "Player is white, computer is red.";
static const char nocomp[] = "(No computer play.)";

void
errexit(const char *s)
{
	write(STDERR_FILENO, "\n", 1);
	perror(s);
	getout(0);
}

int
readc(void)
{
	int    c;

	clrtoeol();
	refresh();
	c = getch();
	if (c == '\004' || c == ERR)	/* ^D or failure	*/
		getout(0);
	if (c == '\033' || c == '\015')
		return('\n');
	if (cflag)
		return(c);
	if (c == '\014')
		return('R');
	if (c >= 'a' && c <= 'z')
		return(c & 0137);	/* upper case */
	return(c);
}

void
proll(void)
{
	if (d0)
		swap;
	if (cturn == 1)
		printw("Red's roll:  ");
	else
		printw("White's roll:  ");
	printw("%d,%d", D0, D1);
	clrtoeol();
}

void
gwrite(void)
{
	int     r, c;

	getyx(stdscr, r, c);
	move(16, 0);
	if (gvalue > 1) {
		printw("Game value:  %d.  ", gvalue);
		if (dlast == -1)
			addstr(color[0]);
		else
			addstr(color[1]);
		addstr(" doubled last.");
	} else {
		if (!dflag)
			printw("[No doubling.]  ");
		switch (pnum) {
		case -1:	/* player is red */
			addstr(plred);
			break;
		case 0:	/* player is both colors */
			addstr(nocomp);
			break;
		case 1:	/* player is white */
			addstr(plwhite);
		}
	}
	if (rscore || wscore) {
		addstr("  ");
		wrscore();
	}
	clrtoeol();
	move(r, c);
}

int
quit(void)
{
	move(20, 0);
	clrtobot();
	addstr("Are you sure you want to quit?");
	if (yorn(0)) {
		if (rfl) {
			addstr("Would you like to save this game?");
			if (yorn(0))
				save(0);
		}
		cturn = 0;
		return(1);
	}
	return(0);
}

int
yorn(char special)
{
	char    c;
	int     i;

	i = 1;
	while ((c = readc()) != 'Y' && c != 'N') {
		if (special && c == special)
			return(2);
		if (i) {
			if (special)
				printw("  (Y, N, or %c)", special);
			else
				printw("  (Y or N)");
			i = 0;
		} else
			beep();
	}
	if (c == 'Y')
		addstr("  Yes.\n");
	else
		addstr("  No.\n");
	refresh();
	return(c == 'Y');
}

void
wrhit(int i)
{
	printw("Blot hit on %d.\n", i);
}

void
nexturn(void)
{
	int     c;

	cturn = -cturn;
	c = cturn / abs(cturn);
	home = bar;
	bar = 25 - bar;
	offptr += c;
	offopp -= c;
	inptr += c;
	inopp -= c;
	Colorptr += c;
	colorptr += c;
}

void
getarg(int argc, char **argv)
{
	int     ch;

	while ((ch = getopt(argc, argv, "bdnrs:w")) != -1)
		switch(ch) {
		case 'n':	/* don't ask if rules or instructions needed */
			if (rflag)
				break;
			aflag = 0;
			break;

		case 'b':	/* player is both red and white */
			if (rflag)
				break;
			pnum = 0;
			aflag = 0;
			break;

		case 'r':	/* player is red */
			if (rflag)
				break;
			pnum = -1;
			aflag = 0;
			break;

		case 'w':	/* player is white */
			if (rflag)
				break;
			pnum = 1;
			aflag = 0;
			break;

		case 's':	/* restore saved game */
			recover(optarg);
			break;

		case 'd':	/* disable doubling */
			dflag = 0;
			aflag = 0;
			break;

		default:	/* print cmdline options */
			usage();
	} /* end switch */
}

void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-bdnrw] [-s file]\n", __progname);
	exit(1);
}

void
init(void)
{
	int     i;

	for (i = 0; i < 26;)
		board[i++] = 0;
	board[1] = 2;
	board[6] = board[13] = -5;
	board[8] = -3;
	board[12] = board[19] = 5;
	board[17] = 3;
	board[24] = -2;
	off[0] = off[1] = -15;
	in[0] = in[1] = 5;
	gvalue = 1;
	dlast = 0;
}

void
wrscore(void)
{
	printw("Score:  %s %d, %s %d", color[1], rscore, color[0], wscore);
}


void
getout(int dummy)
{
	/* go to bottom of screen */
	move(23, 0);
	clrtoeol();

	endwin();
	exit(0);
}

void
roll(void)
{
	char    c;
	int     row;
	int     col;

	if (iroll) {
		getyx(stdscr, row, col);
		mvprintw(17, 0, "ROLL: ");
		c = readc();
		if (c != '\n') {
			while (c < '1' || c > '6')
				c = readc();
			D0 = c - '0';
			printw(" %c", c);
			c = readc();
			while (c < '1' || c > '6')
				c = readc();
			D1 = c - '0';
			printw(" %c", c);
			move(17, 0);
			clrtoeol();
			move(row, col);
			return;
		}
		move(17, 0);
		clrtoeol();
		move(row, col);
	}
	D0 = rnum(6) + 1;
	D1 = rnum(6) + 1;
	d0 = 0;
}
@


1.21
log
@Pledge for backgammon and teachgammon.

Both are straightforward "stdio rpath tty" programs; teachgammon
exec's backgammon at the end, so give it "exec" in addition.

While there, ANSIfy
@
text
@d1 1
a1 1
/*	$OpenBSD: subs.c,v 1.20 2015/06/26 19:18:03 otto Exp $	*/
a199 1
			args[acnt++] = 'n';
a206 1
			args[acnt++] = 'b';
a213 1
			args[acnt++] = 'r';
a220 1
			args[acnt++] = 'w';
d229 1
@


1.20
log
@/home/otto/ok
@
text
@d1 1
a1 1
/*	$OpenBSD: subs.c,v 1.19 2013/11/27 13:32:02 okan Exp $	*/
d44 1
a44 2
errexit(s)
	const char *s;
d52 1
a52 1
readc()
d73 1
a73 1
proll()
d86 1
a86 1
gwrite()
d122 1
a122 1
quit()
d140 1
a140 2
yorn(special)
	char    special;	/* special response */
d167 1
a167 2
wrhit(i)
	int     i;
d173 1
a173 1
nexturn()
d190 1
a190 3
getarg(argc,argv)
	int     argc;
	char  **argv;
d250 1
a250 1
init()
d269 1
a269 1
wrscore()
d276 1
a276 2
getout(dummy)
	int     dummy;
d287 1
a287 1
roll()
@


1.19
log
@remove erroneous char cast to switch expression processing getopt(3);
not used in any cases.

ok deraadt@@, guenther@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subs.c,v 1.18 2009/10/27 23:59:23 deraadt Exp $	*/
d101 2
@


1.18
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: subs.c,v 1.17 2008/03/17 09:17:56 sobrado Exp $	*/
d198 1
a198 1
		switch((char)ch) {
@


1.17
log
@synchronization between usage and synopsis; add some missing "usage:"'s

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subs.c,v 1.16 2007/10/17 20:10:44 chl Exp $	*/
a30 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)subs.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: subs.c,v 1.16 2007/10/17 20:10:44 chl Exp $";
#endif
#endif /* not lint */
@


1.16
log
@remove "unused variable" warnings

tested by deraadt@@ on a gcc2 arch

looks ok ray@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subs.c,v 1.15 2006/10/31 18:15:15 ray Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: subs.c,v 1.15 2006/10/31 18:15:15 ray Exp $";
d256 1
a256 1
	fprintf(stderr, "usage: %s [-bdnrw] [-s <file>]\n", __progname);
@


1.15
log
@Remove -h flag and simplify usage output to one line, like most
other programs.

Vote to simplify usage jmc@@, OK martin@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: subs.c,v 1.14 2006/10/29 20:02:41 martin Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: subs.c,v 1.14 2006/10/29 20:02:41 martin Exp $";
a203 1
	int     j;
@


1.14
log
@-d: make it possible playing without doubling as it is not commonly
played everywhere in the world

ok todd@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subs.c,v 1.13 2004/04/07 14:09:35 aaron Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: subs.c,v 1.13 2004/04/07 14:09:35 aaron Exp $";
d42 2
a50 9
const char   *const descr[] = {
	"Usage:  backgammon [-] [-nrwb] [-s <file>]\n",
	"\t-h\tget this list\n\t-n\tdon't ask for rules or instructions",
	"\t-r\tplayer is red (implies n)\n\t-w\tplayer is white (implies n)",
	"\t-b\ttwo players, red and white (implies n)",
	"\t-s file\trecover previously saved game from file",
	0
};

d206 1
a206 1
	while ((ch = getopt(argc, argv, "bdhnrs:w")) != -1)
d248 1
a248 5
		case 'h':
			for (j = 0; descr[j] != NULL; j++)
				printf("%s\n", descr[j]);
			exit(0);
			break;
d250 9
@


1.13
log
@Remove those option letters from the getopt string which do not have a case
handler below. millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: subs.c,v 1.12 2003/06/03 03:01:38 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: subs.c,v 1.12 2003/06/03 03:01:38 millert Exp $";
d213 1
a213 1
	while ((ch = getopt(argc, argv, "bhnrs:w")) != -1)
d248 4
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: subs.c,v 1.11 2001/06/23 23:50:04 pjanzen Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: subs.c,v 1.11 2001/06/23 23:50:04 pjanzen Exp $";
d213 1
a213 1
	while ((ch = getopt(argc, argv, "bhnp:rs:t:w")) != -1)
@


1.11
log
@termios -> curses
@
text
@d1 1
a1 1
/*	$OpenBSD: subs.c,v 1.10 2000/07/23 21:35:00 pjanzen Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d36 1
a36 1
static char rcsid[] = "$OpenBSD: subs.c,v 1.10 2000/07/23 21:35:00 pjanzen Exp $";
@


1.10
log
@Avoid calling functions that can call the exit-on-error handler from the
handler; use STD*_FILENO rather than 0-2.
@
text
@d1 1
a1 1
/*	$OpenBSD: subs.c,v 1.9 2000/04/21 03:10:30 pjanzen Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: subs.c,v 1.9 2000/04/21 03:10:30 pjanzen Exp $";
d54 1
a54 1
	"Usage:  backgammon [-] [-nrwb] [-p [r|w|b]] [-t <term>] [-s <file>]\n",
a57 4
	"\t-p r\tprint the board before red's turn",
	"\t-p w\tprint the board before white's turn",
	"\t-p b\tprint the board before all turns",
	"\t-t term\tterminal is type term",
a71 25
addbuf(c)
	int     c;
{
	buffnum++;
	if (buffnum == BUFSIZ) {
		if (write(STDOUT_FILENO, outbuff, BUFSIZ) != BUFSIZ)
			errexit("addbuf (write):");
		buffnum = 0;
	}
	outbuff[buffnum] = c;
	return(0);
}

void
buflush()
{
	if (buffnum < 0)
		return;
	buffnum++;
	if (write(STDOUT_FILENO, outbuff, buffnum) != buffnum)
		errexit("buflush (write):");
	buffnum = -1;
}

int
d74 1
a74 1
	char    c;
d76 4
a79 8
	if (tflag) {
		cline();
		newpos();
	}
	buflush();
	if (read(0, &c, 1) != 1)
		errexit("readc");
	if (c == '\004')	/* ^D	*/
d88 1
a88 1
		return(c & 0137);
a92 35
writec(c)
	char    c;
{
	if (tflag)
		fancyc(c);
	else
		addbuf(c);
}

void
writel(l)
	const char   *l;
{
#ifdef DEBUG
	const char   *s;

	if (trace == NULL)
		trace = fopen("bgtrace", "w");

	fprintf(trace, "writel: \"");
	for (s = l; *s; s++) {
		if (*s < ' ' || *s == '\177')
			fprintf(trace, "^%c", (*s)^0100);
		else
			putc(*s, trace);
	}
	fprintf(trace, "\"\n");
	fflush(trace);
#endif

	while (*l)
		writec(*l++);
}

void
d98 1
a98 1
		writel("Red's roll:  ");
d100 3
a102 22
		writel("White's roll:  ");
	writec(D0 + '0');
	writec('\040');
	writec(D1 + '0');
	if (tflag)
		cline();
}

void
wrint(n)
	int     n;
{
	int     i, j, t;

	for (i = 4; i > 0; i--) {
		t = 1;
		for (j = 0; j < i; j++)
			t *= 10;
		if (n > t - 1)
			writec((n / t) % 10 + '0');
	}
	writec(n % 10 + '0');
d110 2
a111 5
	if (tflag) {
		r = curr;
		c = curc;
		curmove(16, 0);
	}
d113 1
a113 3
		writel("Game value:  ");
		wrint(gvalue);
		writel(".  ");
d115 1
a115 1
			writel(color[0]);
d117 2
a118 2
			writel(color[1]);
		writel(" doubled last.");
d122 1
a122 1
			writel(plred);
d125 1
a125 1
			writel(nocomp);
d128 1
a128 1
			writel(plwhite);
d132 1
a132 1
		writel("  ");
d135 2
a136 4
	if (tflag) {
		cline();
		curmove(r, c);
	}
d142 3
a144 6
	if (tflag) {
		curmove(20, 0);
		clend();
	} else
		writec('\n');
	writel("Are you sure you want to quit?");
d147 1
a147 1
			writel("Would you like to save this game?");
d169 4
a172 6
			if (special) {
				writel("  (Y, N, or ");
				writec(special);
				writec(')');
			} else
				writel("  (Y or N)");
d175 1
a175 1
			writec('\007');
d178 1
a178 1
		writel("  Yes.\n");
d180 2
a181 3
		writel("  No.\n");
	if (tflag)
		buflush();
d189 1
a189 4
	writel("Blot hit on ");
	wrint(i);
	writec('.');
	writec('\n');
a249 4
		case 't':	/* use spec'd term from terminfo database */
			tflag = getcaps(optarg);
			break;

a253 12
		case 'p':	/* print board after move */
			switch(optarg[0]) {
				case 'r':	bflag = 1;
						break;
				case 'w':	bflag = -1;
						break;
				case 'b':
				default:	bflag = 0;
						break;
			}
			break;

d285 1
a285 8
	writel("Score:  ");
	writel(color[1]);
	writec(' ');
	wrint(rscore);
	writel(", ");
	writel(color[0]);
	writec(' ');
	wrint(wscore);
a287 10
void
fixtty(t)
	struct termios *t;
{
	if (tflag)
		newpos();
	buflush();
	if (tcsetattr(STDIN_FILENO, TCSADRAIN, t) < 0)
		errexit("fixtty");
}
d294 4
a297 11
	if (tflag) {
		curmove(23, 0);
		cline();
		newpos();
	} else
		writec('\n');

	/* fix terminal status; avoid calling fixtty() to avoid loop */
	if (buffnum >= 0)
		write(STDOUT_FILENO, outbuff, buffnum + 1);
	tcsetattr(STDIN_FILENO, TCSADRAIN, &old);
d309 2
a310 7
		if (tflag) {
			row = curr;
			col = curc;
			curmove(17, 0);
		} else
			writec('\n');
		writel("ROLL: ");
d316 1
a316 2
			writec(' ');
			writec(c);
d321 4
a324 8
			writec(' ');
			writec(c);
			if (tflag) {
				curmove(17, 0);
				cline();
				curmove(row, col);
			} else
				writec('\n');
d327 3
a329 6
		if (tflag) {
			curmove(17, 0);
			cline();
			curmove(row, col);
		} else
			writec('\n');
@


1.9
log
@documentation:  refer to terminfo, not termcap, where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: subs.c,v 1.8 1999/07/31 21:57:41 pjanzen Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: subs.c,v 1.8 1999/07/31 21:57:41 pjanzen Exp $";
d70 1
a70 1
	write(2, "\n", 1);
d81 1
a81 1
		if (write(1, outbuff, BUFSIZ) != BUFSIZ)
d95 1
a95 1
	if (write(1, outbuff, buffnum) != buffnum)
d421 1
a421 1
	if (tcsetattr(0, TCSADRAIN, t) < 0)
d433 1
d437 4
a440 2
	/* fix terminal status */
	fixtty(&old);
@


1.8
log
@use const where appropriate (jsm28@@cam.ac.uk).  Also some very minor tidying.
@
text
@d1 1
a1 1
/*	$OpenBSD: subs.c,v 1.7 1998/11/29 19:45:10 pjanzen Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: subs.c,v 1.7 1998/11/29 19:45:10 pjanzen Exp $";
d353 1
a353 1
		case 't':	/* use spec'd term from /etc/termcap */
@


1.7
log
@Minor changes from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: subs.c,v 1.6 1998/09/02 06:46:51 pjanzen Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: subs.c,v 1.6 1998/09/02 06:46:51 pjanzen Exp $";
d49 3
a51 3
static char plred[] = "Player is red, computer is white.";
static char plwhite[] = "Player is white, computer is red.";
static char nocomp[] = "(No computer play.)";
d53 1
a53 1
char   *descr[] = {
d137 1
a137 1
	char   *l;
d140 1
a140 1
	char   *s;
@


1.6
log
@Delete two unused functions; jsm28@@cam.ac.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: subs.c,v 1.5 1998/03/19 11:13:26 pjanzen Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: subs.c,v 1.5 1998/03/19 11:13:26 pjanzen Exp $";
d329 1
a329 1
		case 'b':	/* player is both read and white */
@


1.5
log
@NetBSD changes and further improvements and corrections
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD$";
a72 7
}

void
strset(s1, s2)
	char   *s1, *s2;
{
	while ((*s1++ = *s2++) != '\0');
@


1.4
log
@tabify
@
text
@d1 1
a1 1
/*	$NetBSD: subs.c,v 1.5 1995/04/29 00:44:15 mycroft Exp $	*/
d40 1
a40 1
static char rcsid[] = "$NetBSD: subs.c,v 1.5 1995/04/29 00:44:15 mycroft Exp $";
a43 1
#include <stdio.h>
d46 2
a47 2
int	buffnum;
char	outbuff[BUFSIZ];
d49 7
a55 7
static char	plred[] = "Player is red, computer is white.";
static char	plwhite[] = "Player is white, computer is red.";
static char	nocomp[] = "(No computer play.)";

char  *descr[] = {
	"Usage:  backgammon [-] [-nrwb] [-pr] [-pw] [-pb] [-t <term>] [-s <file>]\n",
	"\t-\tgets this list\n\t-n\tdon't ask for rules or instructions",
d58 3
a60 3
	"\t-pr\tprint the board before red's turn",
	"\t-pw\tprint the board before white's turn",
	"\t-pb\tprint the board before both player's turn",
d66 3
a68 2
errexit (s)
register char	*s;
d70 3
a72 3
	write (2,"\n",1);
	perror (s);
	getout();
d75 3
a77 2
strset (s1,s2)
register char	*s1, *s2;
d79 1
a79 1
	while ( (*s1++ = *s2++) != '\0');
d82 3
a84 3
addbuf (c)
register char	c;

d87 3
a89 3
	if (buffnum == BUFSIZ)  {
		if (write(1,outbuff,BUFSIZ) != BUFSIZ)
			errexit ("addbuf (write):");
d93 1
d96 3
a98 1
buflush ()  {
d102 2
a103 2
	if (write (1,outbuff,buffnum) != buffnum)
		errexit ("buflush (write):");
d107 4
a110 2
readc () {
	char	c;
d112 1
a112 1
	if (tflag)  {
d117 4
a120 6
	if (read(0,&c,1) != 1)
		errexit ("readc");
#ifdef WHY_IS_THIS_HARDWIRED_IN_HERE
	if (c == '\177')
		getout();
#endif
d122 1
a122 1
		return ('\n');
d124 1
a124 1
		return (c);
d126 1
a126 1
		return ('R');
d128 2
a129 2
		return (c & 0137);
	return (c);
d132 3
a134 2
writec (c)
char	c;
d137 1
a137 1
		fancyc (c);
d139 1
a139 1
		addbuf (c);
d142 3
a144 2
writel (l)
register char	*l;
d147 1
a147 1
	register char	*s;
d150 3
a152 3
		trace = fopen ("bgtrace","w");
	
	fprintf (trace,"writel: \"");
d155 1
a155 1
			fprintf (trace,"^%c",(*s)^0100);
d157 1
a157 1
			putc (*s,trace);
d159 2
a160 2
	fprintf (trace,"\"\n");
	fflush (trace);
d164 1
a164 1
		writec (*l++);
d167 3
a169 1
proll ()   {
d173 1
a173 1
		writel ("Red's roll:  ");
d175 4
a178 4
		writel ("White's roll:  ");
	writec (D0+'0');
	writec ('\040');
	writec (D1+'0');
d183 3
a185 2
wrint (n)
int	n;
d187 1
a187 1
	register int	i, j, t;
d189 1
a189 1
	for (i = 4; i > 0; i--)  {
d191 1
a191 1
		for (j = 0; j<i; j++)
d193 2
a194 2
		if (n > t-1)
			writec ((n/t)%10+'0');
d196 1
a196 1
	writec (n%10+'0');
d199 4
a202 2
gwrite()  {
	register int	r, c;
d204 1
a204 1
	if (tflag)  {
d207 1
a207 1
		curmove (16,0);
d209 4
a212 5

	if (gvalue > 1)  {
		writel ("Game value:  ");
		wrint (gvalue);
		writel (".  ");
d214 1
a214 1
			writel (color[0]);
d216 6
a221 6
			writel (color[1]);
		writel (" doubled last.");
	} else  {
		switch (pnum)  {
		case -1:			    /* player is red */
			writel (plred);
d223 2
a224 2
		case 0:				    /* player is both colors */
			writel (nocomp);
d226 2
a227 2
		case 1:				    /* player is white */
			writel (plwhite);
d230 2
a231 3

	if (rscore || wscore)  {
		writel ("  ");
d234 1
a234 2

	if (tflag)  {
d236 1
a236 1
		curmove (r,c);
d240 5
a244 5
quit ()  {
	register int	i;

	if (tflag)  {
		curmove (20,0);
d247 5
a251 5
		writec ('\n');
	writel ("Are you sure you want to quit?");
	if (yorn (0))  {
		if (rfl)  {
			writel ("Would you like to save this game?");
d256 1
a256 1
		return (1);
d258 1
a258 1
	return (0);
d261 3
a263 2
yorn (special)
register char	special;			/* special response */
d265 2
a266 2
	register char	c;
	register int	i;
d269 1
a269 1
	while ( (c = readc()) != 'Y' && c != 'N')  {
d271 6
a276 6
			return (2);
		if (i)  {
			if (special)  {
				writel ("  (Y, N, or ");
				writec (special);
				writec (')');
d278 1
a278 1
				writel ("  (Y or N)");
d281 1
a281 1
			writec ('\007');
d284 1
a284 1
		writel ("  Yes.\n");
d286 1
a286 1
		writel ("  No.\n");
d289 1
a289 1
	return (c == 'Y');
d292 3
a294 2
wrhit (i)
register int	i;
d296 4
a299 4
	writel ("Blot hit on ");
	wrint (i);
	writec ('.');
	writec ('\n');
d302 4
a305 2
nexturn ()  {
	register int	c;
d308 1
a308 1
	c = cturn/abs(cturn);
d310 1
a310 1
	bar = 25-bar;
d319 4
a322 3
getarg (arg)
register char	***arg;

d324 2
a325 2
	register char	**s;
	register int	i, j;
d327 4
a330 18
	/* process arguments here.  dashes are ignored, nbrw are ignored
	 if the game is being recovered */

	s = *arg;

	/*
	 * Loop through 1 cmdline arg block.
	 * Must start with a '-'.
	 */
	for (i = 0; (s[0][0] == '-') && (s[0][i] != NULL); i++) {
		switch (s[0][i]) {

			/* don't ask if rules or instructions needed */
			case 'n':
				if (rflag)
					break;
				aflag = 0;
				args[acnt++] = 'n';
d332 3
d336 2
a337 7
			/* player is both read and white */
			case 'b':
				if (rflag)
					break;
				pnum = 0;
				aflag = 0;
				args[acnt++] = 'b';
d339 4
d344 2
a345 7
			/* player is red */
			case 'r':
				if (rflag)
					break;
				pnum = -1;
				aflag = 0;
				args[acnt++] = 'r';
d347 4
d352 2
a353 7
			/* player is white */
			case 'w':
				if (rflag)
					break;
				pnum = 1;
				aflag = 0;
				args[acnt++] = 'w';
d355 4
d360 3
a362 16
			/* print board after move according to
			   following character */
			case 'p':
				if (s[0][i-1] == '-' && s[0][2] == 'r' &&
			    	    s[0][2] == 'w' && s[0][2] == 'b') {
					args[acnt++] = 'p';
					args[acnt++] = s[0][2];
					if (s[0][2] == 'r')
						bflag = 1;
					if (s[0][2] == 'w')
						bflag = -1;
					if (s[0][2] == 'b')
						bflag = 0;
				}
				i++;		/* Blindly skip next char */
				break;
d364 3
a366 11
			/* use spec'd term from /etc/termcap */
			case 't':
				if (s[0][1-i] != '-')
					break;
				if (s[0][2] == '\0') { /* get terminal caps */
					s++;
					tflag = getcaps (*s);
				}
				else
					tflag = getcaps (&s[0][2]);
				break;
d368 11
a378 8
			/* restore saved game */
			case 's':
				if (s[0][i-1] != '-')
					break;
				s++;
				/* recover file */
				recover (s[0]);
				break;
d380 7
a386 10
			/* print cmdline options */
			case '-':
				if (strlen(&(s[0][0])) == 1) {
					for (j = 0; descr[j] != NULL; j++)
						printf("%s\n", descr[j]);
					exit(0);
				}
				break;
		} /* end switch */
	} /* end for */
d389 5
a393 2
init ()  {
	register int	i;
d408 11
a418 9
wrscore ()  {
	writel ("Score:  ");
	writel (color[1]);
	writec (' ');
	wrint (rscore);
	writel (", ");
	writel (color[0]);
	writec (' ');
	wrint (wscore);
d421 3
a423 2
fixtty (t)
struct termios	*t;
d428 1
a428 1
	if (tcsetattr (0, TCSADRAIN, t) < 0)
d432 4
a435 1
getout ()  {
d437 2
a438 2
	if (tflag)  {
		curmove (23,0);
d441 1
a441 1
		writec ('\n');
d444 1
a444 1
	fixtty (&old);
a446 4
roll ()  {
	register char	c;
	register int	row;
	register int	col;
d448 9
a456 2
	if (iroll)  {
		if (tflag)  {
d459 1
a459 1
			curmove (17,0);
d461 2
a462 2
			writec ('\n');
		writel ("ROLL: ");
d464 1
a464 1
		if (c != '\n')  {
d467 3
a469 3
			D0 = c-'0';
			writec (' ');
			writec (c);
d473 5
a477 5
			D1 = c-'0';
			writec (' ');
			writec (c);
			if (tflag)  {
				curmove (17,0);
d479 1
a479 1
				curmove (row,col);
d481 1
a481 1
				writec ('\n');
d484 2
a485 2
		if (tflag)  {
			curmove (17,0);
d487 1
a487 1
			curmove (row,col);
d489 1
a489 1
			writec ('\n');
d491 2
a492 2
	D0 = rnum(6)+1;
	D1 = rnum(6)+1;
@


1.3
log
@Command line arguments were not being handled correctly.  Modified for
proper funtionality and for compliance with manpage.
@
text
@d375 1
a375 1
				i++;            /* Blindly skip next char */
@


1.2
log
@Added check for null pointer while processing cmdline options.  Pointer
overrun was causing SEGV if any cmdline options were specified.
@
text
@d55 9
a63 9
	"Usage:  backgammon [-] [n r w b pr pw pb t3a]\n",
	"\t-\tgets this list\n\tn\tdon't ask for rules or instructions",
	"\tr\tplayer is red (implies n)\n\tw\tplayer is white (implies n)",
	"\tb\ttwo players, red and white (implies n)",
	"\tpr\tprint the board before red's turn",
	"\tpw\tprint the board before white's turn",
	"\tpb\tprint the board before both player's turn",
	"\tterm\tterminal is a term",
	"\tsfile\trecover saved game from file",
d312 1
d315 1
a315 1
	   if the game is being recovered */
a317 2
	while ((s[0] != NULL) && (s[0][0] == '-')) {
		switch (s[0][1])  {
d319 22
a340 3
		/* don't ask if rules or instructions needed */
		case 'n':
			if (rflag)
a341 3
			aflag = 0;
			args[acnt++] = 'n';
			break;
d343 7
a349 3
		/* player is both read and white */
		case 'b':
			if (rflag)
a350 4
			pnum = 0;
			aflag = 0;
			args[acnt++] = 'b';
			break;
d352 7
a358 3
		/* player is red */
		case 'r':
			if (rflag)
a359 4
			pnum = -1;
			aflag = 0;
			args[acnt++] = 'r';
			break;
d361 15
a375 3
		/* player is white */
		case 'w':
			if (rflag)
a376 4
			pnum = 1;
			aflag = 0;
			args[acnt++] = 'w';
			break;
d378 10
a387 3
		/* print board after move according to following character */
		case 'p':
			if (s[0][2] != 'r' && s[0][2] != 'w' && s[0][2] != 'b')
a388 9
			args[acnt++] = 'p';
			args[acnt++] = s[0][2];
			if (s[0][2] == 'r')
				bflag = 1;
			if (s[0][2] == 'w')
				bflag = -1;
			if (s[0][2] == 'b')
				bflag = 0;
			break;
d390 4
a393 2
		case 't':
			if (s[0][2] == '\0') {	/* get terminal caps */
d395 3
a397 4
				tflag = getcaps (*s);
			} else
				tflag = getcaps (&s[0][2]);
			break;
d399 10
a408 10
		case 's':
			s++;
			/* recover file */
			recover (s[0]);
			break;
		}
		s++;
	}
	if (s[0] != 0)
		recover(s[0]);
@


1.1
log
@Initial revision
@
text
@d317 1
a317 1
	while (s[0][0] == '-') {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

