head	1.30;
access;
symbols
	OPENBSD_6_2:1.30.0.2
	OPENBSD_6_2_BASE:1.30
	OPENBSD_6_1:1.30.0.4
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.28.0.2
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.19.0.26
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.18
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.22
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.20
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.16
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.14
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.12
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.18.0.8
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.4
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.16.0.6
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.4
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.15.0.8
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.6
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.4
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.7.0.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.6
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2016.09.01.10.48.38;	author tb;	state Exp;
branches;
next	1.29;
commitid	3adbUOmS7nMA7sp8;

1.29
date	2016.08.14.18.34.48;	author guenther;	state Exp;
branches;
next	1.28;
commitid	PKvTittpF6Ut9SpV;

1.28
date	2016.07.11.18.30.21;	author tb;	state Exp;
branches;
next	1.27;
commitid	EW3BVzDexlpFEmXw;

1.27
date	2016.03.07.12.07.56;	author mestre;	state Exp;
branches;
next	1.26;
commitid	NZhYxChmyb9vOEMM;

1.26
date	2016.01.07.16.00.32;	author tb;	state Exp;
branches;
next	1.25;
commitid	IwzFE3fG5RnKTWNh;

1.25
date	2016.01.04.11.58.35;	author mestre;	state Exp;
branches;
next	1.24;
commitid	TBXFQYiwdVBhodpy;

1.24
date	2015.12.30.14.07.53;	author tb;	state Exp;
branches;
next	1.23;
commitid	CLDcrYk642YvcvCY;

1.23
date	2015.12.25.20.59.09;	author mestre;	state Exp;
branches;
next	1.22;
commitid	5J5Os05YMVA0ZKC5;

1.22
date	2015.10.24.17.31.00;	author mmcc;	state Exp;
branches;
next	1.21;
commitid	IcbmbwBJy8RQFfwR;

1.21
date	2015.10.14.08.12.12;	author doug;	state Exp;
branches;
next	1.20;
commitid	l6H409xsPGcs6ezU;

1.20
date	2015.09.07.00.49.20;	author tedu;	state Exp;
branches;
next	1.19;
commitid	DEM6628OiFFc8Da6;

1.19
date	2009.10.27.23.59.24;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2008.03.17.09.17.56;	author sobrado;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.06.20.50.55;	author chl;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.12.00.32.50;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.09.15.59.26;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.03.03.01.39;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.31.03.40.00;	author pjanzen;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.27.09;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.24.14.32.56;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.19.23.19.46;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.19.17.12.40;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.19.15.22.43;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	99.09.26.05.29.41;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	99.09.25.15.52.19;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	98.08.19.07.40.28;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.40.35;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.12.22.20.01.12;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.12.19.22.21.26;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.49;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.49;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.30
log
@In 32 bits sqrt(val) + 1 can overflow, so some big primes still
aren't recognized as such, for example 18446744073709551577 given
in the commit message of factor.c r1.7 from NetBSD.  Move the
return type of usqrt() from u_int32_t to u_int64_t.

ok guenther, tom, otto
@
text
@/*	$OpenBSD: factor.c,v 1.29 2016/08/14 18:34:48 guenther Exp $	*/
/*	$NetBSD: factor.c,v 1.5 1995/03/23 08:28:07 cgd Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Landon Curt Noll.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * factor - factor a number into primes
 *
 * By: Landon Curt Noll   chongo@@toad.com,   ...!{sun,tolsoft}!hoptoad!chongo
 *
 *   chongo <for a good prime call: 391581 * 2^216193 - 1> /\oo/\
 *
 * usage:
 *	factor [number ...]
 *
 * The form of the output is:
 *
 *	number: factor1 factor1 factor2 factor3 factor3 factor3 ...
 *
 * where factor1 < factor2 < factor3 < ...
 *
 * If no args are given, the list of numbers are read from stdin.
 */

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "primes.h"

/*
 * prime[i] is the (i+1)th prime.
 *
 * We are able to sieve 2^32-1 because this byte table yields all primes
 * up to 65537 and 65537^2 > 2^32-1.
 */
extern const ubig prime[];
extern const ubig *pr_limit;		/* largest prime in the prime array */
extern const char pattern[];
extern const int pattern_size;

static void		pr_fact(u_int64_t);	/* print factors of a value */
static void		pr_bigfact(u_int64_t);
static u_int64_t	usqrt(u_int64_t);
static void __dead	usage(void);

int
main(int argc, char *argv[])
{
	u_int64_t val;
	int ch;
	char *p, buf[100];		/* > max number of digits. */

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	while ((ch = getopt(argc, argv, "h")) != -1) {
		switch (ch) {
		case 'h':
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	/* No args supplied, read numbers from stdin. */
	if (argc == 0) {
		for (;;) {
			if (fgets(buf, sizeof(buf), stdin) == NULL) {
				if (ferror(stdin))
					err(1, "stdin");
				return 0;
			}
			buf[strcspn(buf, "\n")] = '\0';
			for (p = buf; isblank((unsigned char)*p); ++p)
				;
			if (*p == '\0')
				continue;
			if (*p == '-')
				errx(1, "negative numbers aren't permitted.");
			errno = 0;
			val = strtoull(buf, &p, 10);
			if (errno)
				err(1, "%s", buf);
			for (; isblank((unsigned char)*p); ++p)
				;
			if (*p != '\0')
				errx(1, "%s: illegal numeric format.", buf);
			pr_fact(val);
		}
	/* Factor the arguments. */
	} else {
		for (; *argv != NULL; ++argv) {
			if (argv[0][0] == '-')
				errx(1, "negative numbers aren't permitted.");
			errno = 0;
			val = strtoull(argv[0], &p, 10);
			if (errno)
				err(1, "%s", argv[0]);
			if (*p != '\0')
				errx(1, "%s: illegal numeric format.", argv[0]);
			pr_fact(val);
		}
	}
	return 0;
}

/*
 * pr_fact - print the prime factors of a number
 *
 * If the number is 0 or 1, then print the number and return.
 * If the number is < 0, print -1, negate the number and continue
 * processing.
 *
 * Print the factors of the number, from the lowest to the highest.
 * A prime factor will be printed as often as it divides the value.
 *
 * Prime factors are printed with leading spaces.
 */
static void
pr_fact(u_int64_t val)		/* Factor this value. */
{
	const ubig *fact;	/* The factor found. */

	/* Firewall - catch 0 and 1. */
	if (val == 0)		/* Historical practice; 0 just exits. */
		exit(0);
	if (val == 1) {
		(void)printf("1: 1\n");
		return;
	}

	/* Factor value. */
	(void)printf("%llu:", val);
	fflush(stdout);
	for (fact = &prime[0]; val > 1; ++fact) {
		/* Look for the smallest factor. */
		do {
			if (val % (long)*fact == 0)
				break;
		} while (++fact <= pr_limit);

		/* Watch for primes larger than the table. */
		if (fact > pr_limit) {
			if (val > BIG)
				pr_bigfact(val);
			else
				(void)printf(" %llu", val);
			break;
		}

		/* Divide factor out until none are left. */
		do {
			(void)printf(" %lu", (unsigned long) *fact);
			val /= (long)*fact;
		} while ((val % (long)*fact) == 0);

		/* Let the user know we're doing something. */
		(void)fflush(stdout);
	}
	(void)putchar('\n');
}

/*
 * At this point, our number may have factors greater than those in primes[];
 * however, we can generate primes up to 32 bits (see primes(6)), which is
 * sufficient to factor a 64-bit quad.
 */
static void
pr_bigfact(u_int64_t val)	/* Factor this value. */
{
	u_int64_t start, stop;
	ubig factor;
	char *q;
	const ubig *p;
	ubig fact_lim, mod;
	char *tab_lim;
	char table[TABSIZE];	/* Eratosthenes sieve of odd numbers */

	start = *pr_limit + 2;
	stop = usqrt(val) + 1;
	if ((stop & 0x1) == 0)
		stop++;
	/*
	 * Following code barely modified from that in primes(6)
	 *
	 * we shall sieve a bytemap window, note primes and move the window
	 * upward until we pass the stop point
	 */
	while (start < stop) {
		/*
		 * factor out 3, 5, 7, 11 and 13
		 */
		/* initial pattern copy */
		factor = (start%(2*3*5*7*11*13))/2; /* starting copy spot */
		memcpy(table, &pattern[factor], pattern_size-factor);
		/* main block pattern copies */
		for (fact_lim = pattern_size - factor;
		    fact_lim + pattern_size <= TABSIZE;
		    fact_lim += pattern_size) {
			memcpy(&table[fact_lim], pattern, pattern_size);
		}
		/* final block pattern copy */
		memcpy(&table[fact_lim], pattern, TABSIZE-fact_lim);

		if (stop-start > TABSIZE+TABSIZE) {
			tab_lim = &table[TABSIZE]; /* sieve it all */
			fact_lim = usqrt(start + TABSIZE + TABSIZE + 1);
		} else {
			tab_lim = &table[(stop - start)/2]; /* partial sieve */
			fact_lim = usqrt(stop + 1);
		}
		/* sieve for factors >= 17 */
		factor = 17;	/* 17 is first prime to use */
		p = &prime[7];	/* 19 is next prime, pi(19)=7 */
		do {
			/* determine the factor's initial sieve point */
			mod = start % factor;
			if (mod & 0x1)
				q = &table[(factor-mod)/2];
			else
				q = &table[mod ? factor-(mod/2) : 0];
			/* sieve for our current factor */
			for ( ; q < tab_lim; q += factor) {
				*q = '\0'; /* sieve out a spot */
			}
		} while ((factor=(ubig)(*(p++))) <= fact_lim);

		/*
		 * use generated primes
		 */
		for (q = table; q < tab_lim; ++q, start+=2) {
			if (*q) {
				if (val % start == 0) {
					do {
						printf(" %llu", start);
						val /= start;
					} while ((val % start) == 0);
					(void)fflush(stdout);
					stop = usqrt(val) + 1;
					if ((stop & 0x1) == 0)
						stop++;
				}
			}
		}
	}
	if (val > 1)
		printf(" %llu", val);
}

/* Code taken from ping.c */
static u_int64_t
usqrt(u_int64_t n)
{
	u_int64_t y, x = 1;

	if (n == 0 || n == 1)
		return n;

	do { /* newton was a stinker */
		y = x;
		x = n / x;
		x += y;
		x /= 2;
	} while (((y < x) && (x - y) > 1) || (y - x) > 1);

	return x;
}

static void __dead
usage(void)
{
	(void)fprintf(stderr, "usage: %s [number ...]\n", getprogname());
	exit (1);
}
@


1.29
log
@Convert remaining calls to strtoq/strtouq in base with strtoll/strtoull.
Fix a type mismatch in ftp's "page" command and could make transfers restart
at the wrong position.

ok and a ull->ll tweak from natano@@, ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.28 2016/07/11 18:30:21 tb Exp $	*/
d78 1
a78 1
static u_int32_t	usqrt(u_int64_t);
d287 1
a287 1
static u_int32_t
d302 1
a302 1
	return (u_int32_t)x;
@


1.28
log
@Instead of using the floating point square root, use an integer version
of the Newton method from ping.c.  Fixes a rounding issue that caused
failure to factor numbers close to 2^64, e.g. 18446744030759878681.
While there, fix an off by one error that caused 4295360521 to be
reported as a prime.  Issues reported by Paul Stoeber and Michael Bozon.

ok tedu, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.27 2016/03/07 12:07:56 mestre Exp $	*/
d117 1
a117 1
			val = strtouq(buf, &p, 10);
d132 1
a132 1
			val = strtouq(argv[0], &p, 10);
@


1.27
log
@- General changes:
- Remove -? from getopt(3) options, but still keep (or add) -h where applicable
- Replace hardcoded program strings by getprogname(3)

- Specific changes:
- atc(6): this used -? and -u for usage(), remove both from game and manpage
- bcd(6): use __progname instead of getprogname(3), no need to include stdlib.h
- hunt(6): replace fputs(3) by fprintf(3)

OK tb@@ after his suggestions
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.26 2016/01/07 16:00:32 tb Exp $	*/
a57 1
#include <math.h>
d68 1
a68 1
 * We are able to sieve 2^32-1 because this byte table yields all primes 
d76 4
a79 3
void	pr_fact(u_int64_t);		/* print factors of a value */
void	pr_bigfact(u_int64_t);
__dead void	usage(void);
d155 1
a155 1
void
d199 2
a200 2

/* At this point, our number may have factors greater than those in primes[];
d204 1
a204 1
void
d207 2
a208 1
	ubig start, stop, factor;
d216 1
a216 1
	stop  = (ubig)sqrt((double)val);
d234 2
a235 1
		    fact_lim + pattern_size <= TABSIZE; fact_lim += pattern_size) {
d243 1
a243 2
			fact_lim = (int)sqrt(
					(double)(start)+TABSIZE+TABSIZE+1.0);
d246 1
a246 1
			fact_lim = (int)sqrt((double)(stop) + 1.0);
d271 1
a271 1
						(void)printf(" %lu", (unsigned long) start);
d275 1
a275 1
					stop  = (ubig)sqrt((double)val);
d286 18
d305 1
a305 1
void
@


1.26
log
@Some basic code maintenance in games/

- in main() replace exit with return
- drop some /* NOTREACHED */ lint comments along the way.
- make more use of standard CFLAGS, esp. -Wimplicit-function-declaration
- add and sort some headers when needed
- add straightforward pledges to some programs used at compile time

discussed with and ok mestre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.25 2016/01/04 11:58:35 mestre Exp $	*/
d91 1
a91 1
	while ((ch = getopt(argc, argv, "")) != -1) {
d93 1
a93 1
		case '?':
d289 1
a289 1
	(void)fprintf(stderr, "usage: factor [number ...]\n");
@


1.25
log
@More headers removal and sorted the remaining alphabetically.

Most noticeable that were removed are sys/types.h which will be included from
stdlib.h and in turn also brings along sys/cdefs.h. The other one is limits.h
that was used with the old idiom (denom * random() / LONG_MAX), although it was
only removed were applicable (some files still need that header).

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.24 2015/12/30 14:07:53 tb Exp $	*/
d107 1
a107 1
				exit (0);
d140 1
a140 1
	exit(0);
@


1.24
log
@Michal Mazurek pointed out on tech@@ that the factor.6 manual needs a bit
of clarification.  Thus, express the description both more concisely and
more precisely.  Drop details about spaces in the output formatting.
While there, update the corresponding comment in the source code.

With input from jmc@@ and mestre@@; detailed discussion with sobrado@@.

ok sobrado@@
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.23 2015/12/25 20:59:09 mestre Exp $	*/
d55 1
a55 1
#include <sys/types.h>
a56 1
#include <ctype.h>
a57 1
#include <limits.h>
@


1.23
log
@Declare usage() functions as __dead void, if they don't return, on games section.

Found another one in arithmetic(6) which also didn't return, and removed a function from number(6) which is not used anymore.

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.22 2015/10/24 17:31:00 mmcc Exp $	*/
d146 1
a146 1
 * pr_fact - print the factors of a number
d153 1
a153 2
 * A factor will be printed multiple times if it divides the value
 * multiple times.
d155 1
a155 1
 * Factors are printed with leading tabs.
@


1.22
log
@Cast isblank()'s argument to unsigned char.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.21 2015/10/14 08:12:12 doug Exp $	*/
d81 1
a81 1
void	usage(void);
@


1.21
log
@Pledge "stdio" for simple games.

ok semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.20 2015/09/07 00:49:20 tedu Exp $	*/
d112 1
a112 1
			for (p = buf; isblank(*p); ++p)
d122 1
a122 1
			for (; isblank(*p); ++p)
@


1.20
log
@cosmetic fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.19 2009/10/27 23:59:24 deraadt Exp $	*/
d89 3
@


1.19
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.18 2008/03/17 09:17:56 sobrado Exp $	*/
d90 1
a90 1
	while ((ch = getopt(argc, argv, "")) != -1)
d96 1
d101 1
a101 1
	if (argc == 0)
d109 2
a110 1
			for (p = buf; isblank(*p); ++p);
d119 2
a120 1
			for (; isblank(*p); ++p);
d126 1
a126 1
	else
d138 1
@


1.18
log
@synchronization between usage and synopsis; add some missing "usage:"'s

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.17 2007/09/06 20:50:55 chl Exp $	*/
a34 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)factor.c	8.4 (Berkeley) 5/4/95";
#else
static char rcsid[] = "$OpenBSD: factor.c,v 1.17 2007/09/06 20:50:55 chl Exp $";
#endif
#endif /* not lint */
@


1.17
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok moritz@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.16 2006/03/12 00:32:50 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: factor.c,v 1.16 2006/03/12 00:32:50 deraadt Exp $";
d58 1
a58 1
 *	factor [number] ...
d299 1
a299 1
	(void)fprintf(stderr, "usage: factor [value ...]\n");
@


1.16
log
@exit code 1 on usage; adobriyan@@gmail
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.15 2004/07/09 15:59:26 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: factor.c,v 1.15 2004/07/09 15:59:26 deraadt Exp $";
d121 1
a121 2
			if (*(p = buf + strlen(buf) - 1) == '\n')
				*p = '\0';
@


1.15
log
@ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.14 2003/06/03 03:01:39 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: factor.c,v 1.14 2003/06/03 03:01:39 millert Exp $";
d301 1
a301 1
	exit (0);
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.13 2002/05/31 03:40:00 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: factor.c,v 1.13 2002/05/31 03:40:00 pjanzen Exp $";
d98 1
a98 3
main(argc, argv)
	int argc;
	char *argv[];
d167 1
a167 2
pr_fact(val)
	u_int64_t val;		/* Factor this value. */
d216 1
a216 2
pr_bigfact(val)
	u_int64_t val;		/* Factor this value. */
d298 1
a298 1
usage()
@


1.13
log
@No dm -> no need to revoke setegid.
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.12 2002/02/16 21:27:09 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: factor.c,v 1.12 2002/02/16 21:27:09 millert Exp $";
@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.11 2001/10/24 14:32:56 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: factor.c,v 1.11 2001/10/24 14:32:56 deraadt Exp $";
a108 4

	/* revoke privs */
	setegid(getgid());
	setgid(getgid());
@


1.11
log
@typo; ericyu@@mail2000.com.tw
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.10 2001/08/19 23:19:46 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: factor.c,v 1.10 2001/08/19 23:19:46 pjanzen Exp $";
d97 3
a99 3
void	pr_fact __P((u_int64_t));	/* print factors of a value */
void	pr_bigfact __P((u_int64_t));
void	usage __P((void));
@


1.10
log
@If primes(6) will generate 32-bit primes, factor should factor 64-bit numbers.
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.9 2001/08/19 17:12:40 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: factor.c,v 1.9 2001/08/19 17:12:40 pjanzen Exp $";
d171 1
a171 1
 * A factor will be printed numtiple times if it divides the value
@


1.9
log
@Use u_int32_t rather than unsigned long, both for platform invariance and
because the primes generation table really depends on there not being more
than 32 bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.8 2001/08/19 15:22:43 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: factor.c,v 1.8 2001/08/19 15:22:43 pjanzen Exp $";
d78 1
d81 1
d94 2
d97 2
a98 1
void	pr_fact __P((ubig));	/* print factors of a value */
d106 1
a106 1
	ubig val;
d139 1
a139 1
			val = strtoul(buf, &p, 10);
d153 1
a153 1
			val = strtoul(argv[0], &p, 10);
d178 1
a178 1
	ubig val;		/* Factor this value. */
d191 2
a192 1
	(void)printf("%lu:", (unsigned long) val);
d202 4
a205 1
			(void)printf(" %lu", (unsigned long) val);
d220 88
@


1.8
log
@remove extraneous newline from error output; PR 2014 and patch from
Tim J. Robbins <tim@@robbins.dropbear.id.au>, with one line added so
that trailing whitespace doesn't make a number seem badly formatted.
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.7 1999/09/26 05:29:41 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: factor.c,v 1.7 1999/09/26 05:29:41 pjanzen Exp $";
d186 1
a186 1
	(void)printf("%lu:", val);
d196 1
a196 1
			(void)printf(" %lu", val);
d202 1
a202 1
			(void)printf(" %lu", *fact);
@


1.7
log
@Correct documentation:  rogoyski@@cs.utexas.edu in PR 927.
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.6 1999/09/25 15:52:19 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: factor.c,v 1.6 1999/09/25 15:52:19 pjanzen Exp $";
d126 2
d129 1
a129 1
			if (*p == '\n' || *p == '\0')
d137 2
a138 1
			if (*p != '\n')
@


1.6
log
@Tidying and minor changes from or based on jsm28@@cam.ac.uk's work for the
Linux bsd-games package and NetBSD.  Mainly using 'const'.
@
text
@d1 1
a1 1
/*	$OpenBSD: factor.c,v 1.5 1998/08/19 07:40:28 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: factor.c,v 1.5 1998/08/19 07:40:28 pjanzen Exp $";
d85 1
a85 1
 * prime[i] is the (i-1)th prime.
@


1.5
log
@tags, formatting, ANSI-fication, prototypes, de-typos, and the occasional
initialization, removal of unused variable, or other minor fix.  Most
changes are from or inspired by NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 1
a48 1
static char sccsid[] = "@@(#)factor.c	8.3 (Berkeley) 3/30/94";
d50 1
a50 1
static char rcsid[] = "$OpenBSD$";
d90 2
a91 2
extern ubig prime[];
extern ubig *pr_limit;		/* largest prime in the prime array */
d172 1
a172 1
	ubig *fact;		/* The factor found. */
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: factor.c,v 1.5 1995/03/23 08:28:07 cgd Exp $";
d73 1
d80 1
@


1.3
log
@proper gid revoke
@
text
@d106 1
a106 1
	while ((ch = getopt(argc, argv, "")) != EOF)
@


1.2
log
@setgid games, not setuid games. closes a neat set of holes
@
text
@d102 2
@


1.1
log
@Initial revision
@
text
@d102 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
