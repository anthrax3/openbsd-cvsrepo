head	1.23;
access;
symbols
	OPENBSD_6_2:1.23.0.4
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.23.0.6
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.2
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.6
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.6
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.4
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.8
	OPENBSD_5_0:1.15.0.6
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.4
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.24
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.20
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.18
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.16
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.14
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.12
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.10
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.8
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.6
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.7.0.6
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2016.03.07.12.07.56;	author mestre;	state Exp;
branches;
next	1.22;
commitid	NZhYxChmyb9vOEMM;

1.22
date	2016.01.07.16.00.32;	author tb;	state Exp;
branches;
next	1.21;
commitid	IwzFE3fG5RnKTWNh;

1.21
date	2015.12.31.18.10.19;	author mestre;	state Exp;
branches;
next	1.20;
commitid	sUE3xE4r7FTWhVk4;

1.20
date	2015.12.18.18.47.56;	author tb;	state Exp;
branches;
next	1.19;
commitid	BAs7B0CRUOfuGWJI;

1.19
date	2015.11.29.14.42.36;	author tb;	state Exp;
branches;
next	1.18;
commitid	UwohSrJjqZ467xl6;

1.18
date	2015.03.12.02.19.10;	author bentley;	state Exp;
branches;
next	1.17;
commitid	Xvi46v1fHtFTRh0A;

1.17
date	2013.10.25.18.31.29;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2010.05.10.08.53.12;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.24;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.10.07.26.23;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.03.03.01.39;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.12.08.51.04;	author pjanzen;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.31.05.11.37;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.17.06.29.00;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.10.23.50.22;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	99.11.29.06.42.20;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.03.27.04.19.31;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	98.08.19.07.40.18;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	97.07.24.15.08.21;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.40.34;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.12.19.22.21.23;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.47;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.47;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.23
log
@- General changes:
- Remove -? from getopt(3) options, but still keep (or add) -h where applicable
- Replace hardcoded program strings by getprogname(3)

- Specific changes:
- atc(6): this used -? and -u for usage(), remove both from game and manpage
- bcd(6): use __progname instead of getprogname(3), no need to include stdlib.h
- hunt(6): replace fputs(3) by fprintf(3)

OK tb@@ after his suggestions
@
text
@/*	$OpenBSD: crib.c,v 1.22 2016/01/07 16:00:32 tb Exp $	*/
/*	$NetBSD: crib.c,v 1.7 1997/07/10 06:47:29 mikel Exp $	*/

/*-
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <err.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>

#include "cribbage.h"
#include "cribcur.h"

int
main(int argc, char *argv[])
{
	bool playing;
	int ch;

	if (pledge("stdio rpath tty proc exec", NULL) == -1)
		err(1, "pledge");

	while ((ch = getopt(argc, argv, "ehmqr")) != -1)
		switch (ch) {
		case 'e':
			explain = TRUE;
			break;
		case 'm':
			muggins = TRUE;
			break;
		case 'q':
			quiet = TRUE;
			break;
		case 'r':
			rflag = TRUE;
			break;
		case 'h':
		default:
			(void) fprintf(stderr, "usage: %s [-emqr]\n",
			    getprogname());
			return 1;
		}

	initscr();
	(void)signal(SIGINT, rintsig);
	cbreak();
	noecho();

	Playwin = subwin(stdscr, PLAY_Y, PLAY_X, 0, 0);
	Tablewin = subwin(stdscr, TABLE_Y, TABLE_X, 0, PLAY_X);
	Compwin = subwin(stdscr, COMP_Y, COMP_X, 0, TABLE_X + PLAY_X);
	Msgwin = subwin(stdscr, MSG_Y, MSG_X, Y_MSG_START, SCORE_X + 1);

	leaveok(Playwin, TRUE);
	leaveok(Tablewin, TRUE);
	leaveok(Compwin, TRUE);
	clearok(stdscr, FALSE);

	if (!quiet) {
		msg("Do you need instructions for cribbage? ");
		if (getuchar() == 'Y') {
			endwin();
			clear();
			mvcur(0, COLS - 1, LINES - 1, 0);
			fflush(stdout);
			instructions();
			cbreak();
			noecho();
			clear();
			refresh();
			msg("For cribbage rules, use \"man cribbage\"");
		}
	}

	if (pledge("stdio tty", NULL) == -1)
		err(1, "pledge");

	playing = TRUE;
	do {
		wclrtobot(Msgwin);
		msg(quiet ? "L or S? " : "Long (to 121) or Short (to 61)? ");
		if (glimit == SGAME)
			glimit = (getuchar() == 'L' ? LGAME : SGAME);
		else
			glimit = (getuchar() == 'S' ? SGAME : LGAME);
		game();
		msg("Another game? ");
		playing = (getuchar() == 'Y');
	} while (playing);

	bye();
	return 0;
}

/*
 * makeboard:
 *	Print out the initial board on the screen
 */
void
makeboard(void)
{
	mvaddstr(SCORE_Y + 0, SCORE_X,
	    "+---------------------------------------+");
	mvaddstr(SCORE_Y + 1, SCORE_X,
	    "|  Score:   0     YOU                   |");
	mvaddstr(SCORE_Y + 2, SCORE_X,
	    "| *.....:.....:.....:.....:.....:.....  |");
	mvaddstr(SCORE_Y + 3, SCORE_X,
	    "| *.....:.....:.....:.....:.....:.....  |");
	mvaddstr(SCORE_Y + 4, SCORE_X,
	    "|                                       |");
	mvaddstr(SCORE_Y + 5, SCORE_X,
	    "| *.....:.....:.....:.....:.....:.....  |");
	mvaddstr(SCORE_Y + 6, SCORE_X,
	    "| *.....:.....:.....:.....:.....:.....  |");
	mvaddstr(SCORE_Y + 7, SCORE_X,
	    "|  Score:   0      ME                   |");
	mvaddstr(SCORE_Y + 8, SCORE_X,
	    "+---------------------------------------+");
	gamescore();
}

/*
 * gamescore:
 *	Print out the current game score
 */
void
gamescore(void)
{
	if (pgames || cgames) {
		mvprintw(SCORE_Y + 1, SCORE_X + 28, "Games: %3d", pgames);
		mvprintw(SCORE_Y + 7, SCORE_X + 28, "Games: %3d", cgames);
	}
	Lastscore[0] = -1;
	Lastscore[1] = -1;
}

/*
 * game:
 *	Play one game up to glimit points.  Actually, we only ASK the
 *	player what card to turn.  We do a random one, anyway.
 */
void
game(void)
{
	int i, j;
	bool flag;
	bool compcrib;

	makedeck(deck);
	shuffle(deck);
	if (gamecount == 0) {
		flag = TRUE;
		do {
			if (!rflag) {			/* player cuts deck */
				char *foo;

				/* This is silly, but we should parse user input
				 * even if we're not actually going to use it.
				 */
				do {
					msg(quiet ? "Cut for crib? " :
				    "Cut to see whose crib it is -- low card wins? ");
					foo = get_line();
					if (*foo != '\0' && ((i = atoi(foo)) < 4 || i > 48))
						msg("Invalid cut");
					else
						*foo = '\0';
				} while (*foo != '\0');
			}
			i = arc4random_uniform(CARDS);	/* random cut */
			do {	/* comp cuts deck */
				j = arc4random_uniform(CARDS);
			} while (j == i);
			addmsg(quiet ? "You cut " : "You cut the ");
			msgcard(deck[i], FALSE);
			endmsg();
			addmsg(quiet ? "I cut " : "I cut the ");
			msgcard(deck[j], FALSE);
			endmsg();
			flag = (deck[i].rank == deck[j].rank);
			if (flag) {
				msg(quiet ? "We tied..." :
				    "We tied and have to try again...");
				shuffle(deck);
				continue;
			} else
				compcrib = (deck[i].rank > deck[j].rank);
		} while (flag);
		do_wait();
		clear();
		makeboard();
		refresh();
	} else {
		makeboard();
		refresh();
		werase(Tablewin);
		wrefresh(Tablewin);
		werase(Compwin);
		wrefresh(Compwin);
		msg("Loser (%s) gets first crib", (iwon ? "you" : "me"));
		compcrib = !iwon;
	}

	pscore = cscore = 0;
	flag = TRUE;
	do {
		shuffle(deck);
		flag = !playhand(compcrib);
		compcrib = !compcrib;
	} while (flag);
	++gamecount;
	if (cscore < pscore) {
		if (glimit - cscore > 60) {
			msg("YOU DOUBLE SKUNKED ME!");
			pgames += 4;
		} else
			if (glimit - cscore > 30) {
				msg("YOU SKUNKED ME!");
				pgames += 2;
			} else {
				msg("YOU WON!");
				++pgames;
			}
		iwon = FALSE;
	} else {
		if (glimit - pscore > 60) {
			msg("I DOUBLE SKUNKED YOU!");
			cgames += 4;
		} else
			if (glimit - pscore > 30) {
				msg("I SKUNKED YOU!");
				cgames += 2;
			} else {
				msg("I WON!");
				++cgames;
			}
		iwon = TRUE;
	}
	gamescore();
}

/*
 * playhand:
 *	Do up one hand of the game
 */
int
playhand(bool mycrib)
{
	int deckpos;

	werase(Compwin);
	wrefresh(Compwin);
	werase(Tablewin);
	wrefresh(Tablewin);

	knownum = 0;
	deckpos = deal(mycrib);
	sorthand(chand, FULLHAND);
	sorthand(phand, FULLHAND);
	makeknown(chand, FULLHAND);
	prhand(phand, FULLHAND, Playwin, FALSE);
	discard(mycrib);
	if (cut(mycrib, deckpos))
		return TRUE;
	if (peg(mycrib))
		return TRUE;
	werase(Tablewin);
	wrefresh(Tablewin);
	if (score(mycrib))
		return TRUE;
	return FALSE;
}

/*
 * deal cards to both players from deck
 */
int
deal(bool mycrib)
{
	int i, j;

	for (i = j = 0; i < FULLHAND; i++) {
		if (mycrib) {
			phand[i] = deck[j++];
			chand[i] = deck[j++];
		} else {
			chand[i] = deck[j++];
			phand[i] = deck[j++];
		}
	}
	return (j);
}

/*
 * discard:
 *	Handle players discarding into the crib...
 * Note: we call cdiscard() after prining first message so player doesn't wait
 */
void
discard(bool mycrib)
{
	char *prompt;
	CARD crd;

	prcrib(mycrib, TRUE);
	prompt = (quiet ? "Discard --> " : "Discard a card --> ");
	cdiscard(mycrib);	/* puts best discard at end */
	crd = phand[infrom(phand, FULLHAND, prompt)];
	cremove(crd, phand, FULLHAND);
	prhand(phand, FULLHAND, Playwin, FALSE);
	crib[0] = crd;

	/* Next four lines same as last four except for cdiscard(). */
	crd = phand[infrom(phand, FULLHAND - 1, prompt)];
	cremove(crd, phand, FULLHAND - 1);
	prhand(phand, FULLHAND, Playwin, FALSE);
	crib[1] = crd;
	crib[2] = chand[4];
	crib[3] = chand[5];
	chand[4].rank = chand[4].suit = chand[5].rank = chand[5].suit = EMPTY;
}

/*
 * cut:
 *	Cut the deck and set turnover.  Actually, we only ASK the
 *	player what card to turn.  We do a random one, anyway.
 */
int
cut(bool mycrib, int pos)
{
	int i;
	bool win;

	win = FALSE;
	if (mycrib) {
		if (!rflag) {	/* random cut */
			char *foo;

			/* This is silly, but we should parse user input,
			 * even if we're not actually going to use it.
			 */
			do {
				msg(quiet ? "Cut the deck? " :
				    "How many cards down do you wish to cut the deck? ");
				foo = get_line();
				if (*foo != '\0' && ((i = atoi(foo)) < 4 || i > 36))
					msg("Invalid cut");
				else
					*foo = '\0';
			} while (*foo != '\0');
		}
		i = arc4random_uniform(CARDS - pos);
		turnover = deck[i + pos];
		addmsg(quiet ? "You cut " : "You cut the ");
		msgcard(turnover, FALSE);
		endmsg();
		prcrib(mycrib, FALSE);
		if (turnover.rank == JACK) {
			msg("I get two for his heels");
			win = chkscr(&cscore, 2);
		}
	} else {
		i = arc4random_uniform(CARDS - pos) + pos;
		turnover = deck[i];
		addmsg(quiet ? "I cut " : "I cut the ");
		msgcard(turnover, FALSE);
		endmsg();
		prcrib(mycrib, FALSE);
		if (turnover.rank == JACK) {
			msg("You get two for his heels");
			win = chkscr(&pscore, 2);
		}
	}
	makeknown(&turnover, 1);
	return (win);
}

/*
 * prcrib:
 *	Print out the turnover card with crib indicator
 */
void
prcrib(bool mycrib, bool blank)
{
	int y, cardx;

	if (mycrib)
		cardx = CRIB_X;
	else
		cardx = 0;

	mvaddstr(CRIB_Y, cardx + 1, "CRIB");
	prcard(stdscr, CRIB_Y + 1, cardx, turnover, blank);

	if (mycrib)
		cardx = 0;
	else
		cardx = CRIB_X;

	for (y = CRIB_Y; y <= CRIB_Y + 5; y++)
		mvaddstr(y, cardx, "       ");
	refresh();
}

/*
 * peg:
 *	Handle all the pegging...
 */
static CARD Table[14];
static int Tcnt;

int
peg(bool mycrib)
{
	static CARD ch[CINHAND], ph[CINHAND];
	int i, j, k;
	int l;
	int cnum, pnum, sum;
	bool myturn, mego, ugo, last, played;
	CARD crd;

	played = FALSE;
	cnum = pnum = CINHAND;
	for (i = 0; i < CINHAND; i++) {	/* make copies of hands */
		ch[i] = chand[i];
		ph[i] = phand[i];
	}
	Tcnt = 0;		/* index to table of cards played */
	sum = 0;		/* sum of cards played */
	mego = ugo = FALSE;
	myturn = !mycrib;
	for (;;) {
		last = TRUE;	/* enable last flag */
		prhand(ph, pnum, Playwin, FALSE);
		prhand(ch, cnum, Compwin, TRUE);
		prtable(sum);
		if (myturn) {
			if (!anymove(ch, cnum, sum)) {	/* if no card to play */
				if (!mego && cnum) {	/* go for comp? */
					msg("GO");
					mego = TRUE;
				}
							/* can player move? */
				if (anymove(ph, pnum, sum))
					myturn = !myturn;
				else {			/* give him his point */
					msg(quiet ? "You get one" :
					    "You get one point");
					do_wait();
					if (chkscr(&pscore, 1))
						return TRUE;
					sum = 0;
					mego = ugo = FALSE;
					Tcnt = 0;
				}
			} else {
				played = TRUE;
				j = -1;
				k = 0;
							/* maximize score */
				for (i = 0; i < cnum; i++) {
					l = pegscore(ch[i], Table, Tcnt, sum);
					if (l > k) {
						k = l;
						j = i;
					}
				}
				if (j < 0)		/* if nothing scores */
					j = cchose(ch, cnum, sum);
				crd = ch[j];
				cremove(crd, ch, cnum--);
				sum += VAL(crd.rank);
				Table[Tcnt++] = crd;
				if (k > 0) {
					addmsg(quiet ? "I get %d playing " :
					    "I get %d points playing ", k);
					msgcard(crd, FALSE);
					endmsg();
					prhand(ph, pnum, Playwin, FALSE);
					prhand(ch, cnum, Compwin, TRUE);
					prtable(sum);
					if (chkscr(&cscore, k))
						return TRUE;
				}
				myturn = !myturn;
			}
		} else {
			if (!anymove(ph, pnum, sum)) {	/* can player move? */
				if (!ugo && pnum) {	/* go for player */
					msg("You have a GO");
					ugo = TRUE;
				}
							/* can computer play? */
				if (anymove(ch, cnum, sum))
					myturn = !myturn;
				else {
					msg(quiet ? "I get one" :
					    "I get one point");
					do_wait();
					prhand(ph, pnum, Playwin, FALSE);
					prhand(ch, cnum, Compwin, TRUE);
					prtable(sum);
					if (chkscr(&cscore, 1))
						return TRUE;
					sum = 0;
					mego = ugo = FALSE;
					Tcnt = 0;
				}
			} else {			/* player plays */
				played = FALSE;
				if (pnum == 1) {
					crd = ph[0];
					msg("You play your last card");
				} else
					for (;;) {
						prhand(ph,
						    pnum, Playwin, FALSE);
						crd = ph[infrom(ph,
						    pnum, "Your play: ")];
						if (sum + VAL(crd.rank) <= 31)
							break;
						else
					msg("Total > 31 -- try again");
					}
				makeknown(&crd, 1);
				cremove(crd, ph, pnum--);
				i = pegscore(crd, Table, Tcnt, sum);
				sum += VAL(crd.rank);
				Table[Tcnt++] = crd;
				if (i > 0) {
					msg(quiet ? "You got %d" :
					    "You got %d points", i);
					if (pnum == 0)
						do_wait();
					prhand(ph, pnum, Playwin, FALSE);
					prhand(ch, cnum, Compwin, TRUE);
					prtable(sum);
					if (chkscr(&pscore, i))
						return TRUE;
				}
				myturn = !myturn;
			}
		}
		if (sum >= 31) {
			if (!myturn)
				do_wait();
			sum = 0;
			mego = ugo = FALSE;
			Tcnt = 0;
			last = FALSE;			/* disable last flag */
		}
		if (!pnum && !cnum)
			break;				/* both done */
	}
	prhand(ph, pnum, Playwin, FALSE);
	prhand(ch, cnum, Compwin, TRUE);
	prtable(sum);
	if (last) {
		if (played) {
			msg(quiet ? "I get one for last" :
			    "I get one point for last");
			do_wait();
			if (chkscr(&cscore, 1))
				return TRUE;
		} else {
			msg(quiet ? "You get one for last" :
			    "You get one point for last");
			do_wait();
			if (chkscr(&pscore, 1))
				return TRUE;
		}
	}
	return (FALSE);
}

/*
 * prtable:
 *	Print out the table with the current score
 */
void
prtable(int score)
{
	prhand(Table, Tcnt, Tablewin, FALSE);
	mvwprintw(Tablewin, (Tcnt + 2) * 2, Tcnt + 1, "%2d", score);
	wrefresh(Tablewin);
}

/*
 * score:
 *	Handle the scoring of the hands
 */
int
score(bool mycrib)
{
	sorthand(crib, CINHAND);
	if (mycrib) {
		if (plyrhand(phand, "hand"))
			return (TRUE);
		if (comphand(chand, "hand"))
			return (TRUE);
		do_wait();
		if (comphand(crib, "crib"))
			return (TRUE);
		do_wait();
	} else {
		if (comphand(chand, "hand"))
			return (TRUE);
		if (plyrhand(phand, "hand"))
			return (TRUE);
		if (plyrhand(crib, "crib"))
			return (TRUE);
	}
	return (FALSE);
}
@


1.22
log
@Some basic code maintenance in games/

- in main() replace exit with return
- drop some /* NOTREACHED */ lint comments along the way.
- make more use of standard CFLAGS, esp. -Wimplicit-function-declaration
- add and sort some headers when needed
- add straightforward pledges to some programs used at compile time

discussed with and ok mestre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crib.c,v 1.21 2015/12/31 18:10:19 mestre Exp $	*/
d50 1
a50 1
	while ((ch = getopt(argc, argv, "emqr")) != -1)
d64 1
a64 1
		case '?':
d66 2
a67 1
			(void) fprintf(stderr, "usage: cribbage [-emqr]\n");
@


1.21
log
@Include only needed header files per each source file

This one was also OK'ed by tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crib.c,v 1.20 2015/12/18 18:47:56 tb Exp $	*/
d67 1
a67 1
			exit(1);
d118 1
a118 1
	exit(0);
@


1.20
log
@KNF: add a missing space after an 'if'.
@
text
@d1 1
a1 1
/*	$OpenBSD: crib.c,v 1.19 2015/11/29 14:42:36 tb Exp $	*/
a32 2
#include <sys/types.h>
#include <curses.h>
a35 1
#include <string.h>
a37 1
#include "deck.h"
a39 1
#include "pathnames.h"
@


1.19
log
@pledge "stdio rpath tty proc exec" since instructions() might fork a pager.
actual game place takes place with "stdio tty".

OK deraadt@@ on an earlier version
@
text
@d1 1
a1 1
/*	$OpenBSD: crib.c,v 1.18 2015/03/12 02:19:10 bentley Exp $	*/
d52 1
a52 1
	if(pledge("stdio rpath tty proc exec", NULL) == -1)
@


1.18
log
@Delete cribbage logging. Was never enabled and no point in enabling it.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crib.c,v 1.17 2013/10/25 18:31:29 millert Exp $	*/
d52 3
d105 4
@


1.17
log
@Use arc4random_uniform() insead of rand() and modulus.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crib.c,v 1.16 2012/03/04 04:05:15 fgsch Exp $	*/
a50 9
#ifdef LOGGING
	FILE *f;
	gid_t egid;

	egid = getegid();
	setegid(getgid());
#else
	setgid(getgid());
#endif
a114 12
#ifdef LOGGING
	setegid(egid);
	if ((f = fopen(_PATH_LOG, "a")) != NULL) {
		(void)fprintf(f, "%s: won %5.5d, lost %5.5d\n",
		    getlogin(), cgames, pgames);
		(void) fclose(f);
	}
	setegid(getgid());
	bye();
	if (!f)
		errx(1, "can't open %s", _PATH_LOG);
#else
a115 1
#endif
@


1.16
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: crib.c,v 1.15 2010/05/10 08:53:12 nicm Exp $	*/
d217 1
a217 1
			i = (rand() >> 4) % CARDS;	/* random cut */
d219 1
a219 1
				j = (rand() >> 4) % CARDS;
d399 1
a399 1
		i = (rand() >> 4) % (CARDS - pos);
d410 1
a410 1
		i = (rand() >> 4) % (CARDS - pos) + pos;
@


1.15
log
@Rename use of some builtins that makes gcc4 warn.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: crib.c,v 1.14 2009/10/27 23:59:24 deraadt Exp $	*/
d210 1
a210 1
					foo = getline();
d392 1
a392 1
				foo = getline();
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: crib.c,v 1.13 2004/07/10 07:26:23 deraadt Exp $	*/
d82 1
a82 1
	(void)signal(SIGINT, rint);
@


1.13
log
@more ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: crib.c,v 1.12 2003/06/03 03:01:39 millert Exp $	*/
a31 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)crib.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: crib.c,v 1.12 2003/06/03 03:01:39 millert Exp $";
#endif
#endif /* not lint */
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: crib.c,v 1.11 2003/05/12 08:51:04 pjanzen Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: crib.c,v 1.11 2003/05/12 08:51:04 pjanzen Exp $";
d61 1
a61 3
main(argc, argv)
	int argc;
	char *argv[];
d160 1
a160 1
makeboard()
d188 1
a188 1
gamescore()
d204 1
a204 1
game()
d308 1
a308 2
playhand(mycrib)
	bool mycrib;
d339 1
a339 2
deal(mycrib)
	bool mycrib;
d361 1
a361 2
discard(mycrib)
	bool mycrib;
d390 1
a390 3
cut(mycrib, pos)
	bool mycrib;
	int  pos;
d444 1
a444 2
prcrib(mycrib, blank)
	bool mycrib, blank;
d474 1
a474 2
peg(mycrib)
	bool mycrib;
d642 1
a642 2
prtable(score)
	int score;
d654 1
a654 2
score(mycrib)
	bool mycrib;
@


1.11
log
@From NetBSD:  remove redundant declaration
@
text
@d1 1
a1 1
/*	$OpenBSD: crib.c,v 1.10 2002/05/31 05:11:37 pjanzen Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: crib.c,v 1.10 2002/05/31 05:11:37 pjanzen Exp $";
@


1.10
log
@crmode -> cbreak
@
text
@d1 1
a1 1
/*	$OpenBSD: crib.c,v 1.9 2001/11/17 06:29:00 pjanzen Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: crib.c,v 1.9 2001/11/17 06:29:00 pjanzen Exp $";
a195 2
	extern int Lastscore[];

@


1.9
log
@Always update the piles before checking score.
@
text
@d1 1
a1 1
/*	$OpenBSD: crib.c,v 1.8 2001/08/10 23:50:22 pjanzen Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: crib.c,v 1.8 2001/08/10 23:50:22 pjanzen Exp $";
d103 1
a103 1
	crmode();
d124 1
a124 1
			crmode();
@


1.8
log
@-m option for muggins
better user input parsing
man page tidying and syncing of rules to Hoyle's
typo and context correction in "Hoyle's" transcription
@
text
@d1 1
a1 1
/*	$OpenBSD: crib.c,v 1.7 1999/11/29 06:42:20 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: crib.c,v 1.7 1999/11/29 06:42:20 millert Exp $";
d431 1
d442 1
a448 1
	prcrib(mycrib, FALSE);
d555 3
d576 3
d611 3
@


1.7
log
@Kill BOOLEAN, just use the curses/c++ bool type instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: crib.c,v 1.6 1999/03/27 04:19:31 pjanzen Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: crib.c,v 1.6 1999/03/27 04:19:31 pjanzen Exp $";
d81 1
a81 1
	while ((ch = getopt(argc, argv, "eqr")) != -1)
d86 3
d97 1
a97 1
			(void) fprintf(stderr, "usage: cribbage [-eqr]\n");
d224 14
a237 3
				msg(quiet ? "Cut for crib? " :
			    "Cut to see whose crib it is -- low card wins? ");
				getline();
d411 14
a424 3
			msg(quiet ? "Cut the deck? " :
		    "How many cards down do you wish to cut the deck? ");
			getline();
d512 1
a512 1
		if (myturn) {	/* my tyrn to play */
@


1.6
log
@Disable the log file by default (logging, as opposed to scoring, should be
done through dm).
@
text
@d1 1
a1 1
/*	$OpenBSD: crib.c,v 1.5 1998/08/19 07:40:18 pjanzen Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: crib.c,v 1.5 1998/08/19 07:40:18 pjanzen Exp $";
d69 1
a69 1
	BOOLEAN playing;
d212 2
a213 2
	BOOLEAN flag;
	BOOLEAN compcrib;
d303 1
a303 1
	BOOLEAN mycrib;
d335 1
a335 1
	BOOLEAN mycrib;
d358 1
a358 1
	BOOLEAN mycrib;
d388 1
a388 1
	BOOLEAN mycrib;
d392 1
a392 1
	BOOLEAN win;
d432 1
a432 1
	BOOLEAN mycrib, blank;
d463 1
a463 1
	BOOLEAN mycrib;
d469 1
a469 1
	BOOLEAN myturn, mego, ugo, last, played;
d636 1
a636 1
	BOOLEAN mycrib;
@


1.5
log
@tags, formatting, ANSI-fication, prototypes, de-typos, and the occasional
initialization, removal of unused variable, or other minor fix.  Most
changes are from or inspired by NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD$";
d70 2
a72 1
	int ch;
d77 3
d141 1
d152 3
@


1.4
log
@Clean up play, let player see play more often, improve display timing.
Preliminary work from PR 2055 (as reverse patches); phil
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: crib.c,v 1.7 1997/07/10 06:47:29 mikel Exp $";
d51 1
d53 1
d145 2
a146 5
	if (!f) {
		(void) fprintf(stderr, "\ncribbage: can't open %s.\n",
		    _PATH_LOG);
		exit(1);
	}
d203 1
a203 1
	register int i, j;
d297 1
a297 1
	register int deckpos;
d329 1
a329 1
	register int i, j;
d352 1
a352 1
	register char *prompt;
d383 1
a383 1
	register int i;
d426 1
a426 1
	register int y, cardx;
d458 4
a461 4
	register int i, j, k;
	register int l;
	register int cnum, pnum, sum;
	register BOOLEAN myturn, mego, ugo, last, played;
d464 1
d591 1
a591 1
	if (last)
d605 1
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$NetBSD: crib.c,v 1.5 1995/03/21 15:08:42 cgd Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: crib.c,v 1.5 1995/03/21 15:08:42 cgd Exp $";
d135 1
a135 1
	if (f = fopen(_PATH_LOG, "a")) {
d236 1
d241 2
d300 3
d443 1
d490 1
d568 2
d600 1
d637 1
@


1.2
log
@setgid games, not setuid games. closes a neat set of holes
@
text
@d74 1
a74 1
	while ((ch = getopt(argc, argv, "eqr")) != EOF)
@


1.1
log
@Initial revision
@
text
@d69 4
d100 1
d134 1
d140 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
