head	1.13;
access;
symbols
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.22
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.14
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.18
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.16
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.12
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.16
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.12
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.8
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.5.0.8
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.12.31.18.10.20;	author mestre;	state Exp;
branches;
next	1.12;
commitid	sUE3xE4r7FTWhVk4;

1.12
date	2010.11.03.12.51.10;	author dcoppa;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.27.23.59.24;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.27.00.10.15;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.10.07.26.23;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.16.00.13.18;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.03.03.01.39;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.06.18.50.36;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.10.23.50.22;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	99.11.29.06.42.20;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	98.08.19.07.40.26;	author pjanzen;	state Exp;
branches;
next	1.2;

1.2
date	97.07.24.15.08.25;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.48;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.48;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Include only needed header files per each source file

This one was also OK'ed by tb@@
@
text
@/*	$OpenBSD: support.c,v 1.12 2010/11/03 12:51:10 dcoppa Exp $	*/
/*	$NetBSD: support.c,v 1.3 1995/03/21 15:08:59 cgd Exp $	*/

/*-
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <err.h>
#include <string.h>

#include "cribbage.h"
#include "cribcur.h"

#define	NTV	10		/* number scores to test */

/* score to test reachability of, and order to test them in */
int tv[NTV] = {8, 7, 9, 6, 11, 12, 13, 14, 10, 5};

/*
 * computer chooses what to play in pegging...
 * only called if no playable card will score points
 */
int
cchose(CARD h[], int n, int s)
{
	int i, j, l;

	if (n <= 1)
		return (0);
	if (s < 4) {		/* try for good value */
		if ((j = anysumto(h, n, s, 4)) >= 0)
			return (j);
		if ((j = anysumto(h, n, s, 3)) >= 0 && s == 0)
			return (j);
	}
	if (s > 0 && s < 20) {
				/* try for retaliation to 31 */
		for (i = 1; i <= 10; i++) {
			if ((j = anysumto(h, n, s, 21 - i)) >= 0) {
				if ((l = numofval(h, n, i)) > 0) {
					if (l > 1 || VAL(h[j].rank) != i)
						return (j);
				}
			}
		}
	}
	if (s < 15) {
				/* for retaliation after 15 */
		for (i = 0; i < NTV; i++) {
			if ((j = anysumto(h, n, s, tv[i])) >= 0) {
				if ((l = numofval(h, n, 15 - tv[i])) > 0) {
					if (l > 1 ||
					    VAL(h[j].rank) != 15 - tv[i])
						return (j);
				}
			}
		}
	}
	j = -1;
				/* remember: h is sorted */
	for (i = n - 1; i >= 0; --i) {
		l = s + VAL(h[i].rank);
		if (l > 31)
			continue;
		if (l != 5 && l != 10 && l != 21) {
			j = i;
			break;
		}
	}
	if (j >= 0)
		return (j);
	for (i = n - 1; i >= 0; --i) {
		l = s + VAL(h[i].rank);
		if (l > 31)
			continue;
		if (j < 0)
			j = i;
		if (l != 5 && l != 21) {
			j = i;
			break;
		}
	}
	if (j < 0)
		errx(1, "cchose internal error %d %d", j, n);
	return (j);
}

/*
 * plyrhand:
 *	Evaluate and score a player hand or crib
 */
int
plyrhand(CARD hand[], char *s)
{
	static char prompt[BUFSIZ];
	int i, j;
	bool win;

	prhand(hand, CINHAND, Playwin, FALSE);
	(void) snprintf(prompt, sizeof prompt, "Your %s scores ", s);
	i = scorehand(hand, turnover, CINHAND, strcmp(s, "crib") == 0, explain);
	if ((j = number(0, 29, prompt)) == 19)
		j = 0;
	if (i != j) {
		if (i < j) {
			win = chkscr(&pscore, i);
			if (!win) {
				msg("It's really only %d points; I get %d", i, 2);
				win = chkscr(&cscore, 2);
			} else
				msg("It's really only %d points.", i);
		} else {
			win = chkscr(&pscore, j);
			msg("You should have taken %d, not %d!", i, j);
			if (!win && muggins) {
				msg("Muggins!  I score %d", i - j);
				win = chkscr(&cscore, i - j);
			}
		}
		if (explain)
			msg("Explanation: %s", expl_string);
		do_wait();
	} else
		win = chkscr(&pscore, i);
	return (win);
}

/*
 * comphand:
 *	Handle scoring and displaying the computers hand
 */
int
comphand(CARD h[], char *s)
{
	int j;

	j = scorehand(h, turnover, CINHAND, strcmp(s, "crib") == 0, FALSE);
	prhand(h, CINHAND, Compwin, FALSE);
	msg("My %s scores %d", s, (j == 0 ? 19 : j));
	return (chkscr(&cscore, j));
}

/*
 * chkscr:
 *	Add inc to scr and test for > glimit, printing on the scoring
 *	board while we're at it.
 */
int Lastscore[2] = {-1, -1};

int
chkscr(int *scr, int inc)
{
	bool myturn;

	myturn = (scr == &cscore);
	if (inc != 0) {
		prpeg(Lastscore[(int)myturn], '.', myturn);
		Lastscore[(int)myturn] = *scr;
		*scr += inc;
		prpeg(*scr, PEG, myturn);
		refresh();
	}
	return (*scr >= glimit);
}

/*
 * prpeg:
 *	Put out the peg character on the score board and put the
 *	score up on the board.
 */
void
prpeg(int score, int peg, bool myturn)
{
	int y, x;

	if (!myturn)
		y = SCORE_Y + 2;
	else
		y = SCORE_Y + 5;

	if (score <= 0 || score >= glimit) {
		if (peg == '.')
			peg = ' ';
		if (score == 0)
			x = SCORE_X + 2;
		else {
			x = SCORE_X + 2;
			y++;
		}
	} else {
		x = (score - 1) % 30;
		if (score > 90 || (score > 30 && score <= 60)) {
			y++;
			x = 29 - x;
		}
		x += x / 5;
		x += SCORE_X + 3;
	}
	mvaddch(y, x, peg);
	mvprintw(SCORE_Y + (myturn ? 7 : 1), SCORE_X + 10, "%3d", score);
}

/*
 * cdiscard -- the computer figures out what is the best discard for
 * the crib and puts the best two cards at the end
 */
void
cdiscard(bool mycrib)
{
	CARD    d[CARDS], h[FULLHAND], cb[2];
	int i, j, k;
	int     nc, ns;
	long    sums[15];
	static int undo1[15] = {0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 3, 3, 4};
	static int undo2[15] = {1, 2, 3, 4, 5, 2, 3, 4, 5, 3, 4, 5, 4, 5, 5};

	makedeck(d);
	nc = CARDS;
	for (i = 0; i < knownum; i++) {	/* get all other cards */
		cremove(known[i], d, nc--);
	}
	for (i = 0; i < 15; i++)
		sums[i] = 0L;
	ns = 0;
	for (i = 0; i < (FULLHAND - 1); i++) {
		cb[0] = chand[i];
		for (j = i + 1; j < FULLHAND; j++) {
			cb[1] = chand[j];
			for (k = 0; k < FULLHAND; k++)
				h[k] = chand[k];
			cremove(chand[i], h, FULLHAND);
			cremove(chand[j], h, FULLHAND - 1);
			for (k = 0; k < nc; k++) {
				sums[ns] +=
				    scorehand(h, d[k], CINHAND, TRUE, FALSE);
				if (mycrib)
					sums[ns] += adjust(cb, d[k]);
				else
					sums[ns] -= adjust(cb, d[k]);
			}
			++ns;
		}
	}
	j = 0;
	for (i = 1; i < 15; i++)
		if (sums[i] > sums[j])
			j = i;
	for (k = 0; k < FULLHAND; k++)
		h[k] = chand[k];
	cremove(h[undo1[j]], chand, FULLHAND);
	cremove(h[undo2[j]], chand, FULLHAND - 1);
	chand[4] = h[undo1[j]];
	chand[5] = h[undo2[j]];
}

/*
 * returns true if some card in hand can be played without exceeding 31
 */
int
anymove(CARD hand[], int n, int sum)
{
	int i, j;

	if (n < 1)
		return (FALSE);
	j = hand[0].rank;
	for (i = 1; i < n; i++) {
		if (hand[i].rank < j)
			j = hand[i].rank;
	}
	return (sum + VAL(j) <= 31);
}

/*
 * anysumto returns the index (0 <= i < n) of the card in hand that brings
 * the s up to t, or -1 if there is none
 */
int
anysumto(CARD hand[], int n, int s, int t)
{
	int i;

	for (i = 0; i < n; i++) {
		if (s + VAL(hand[i].rank) == t)
			return (i);
	}
	return (-1);
}

/*
 * return the number of cards in h having the given rank value
 */
int
numofval(CARD h[], int n, int v)
{
	int i, j;

	j = 0;
	for (i = 0; i < n; i++) {
		if (VAL(h[i].rank) == v)
			++j;
	}
	return (j);
}

/*
 * makeknown remembers all n cards in h for future recall
 */
void
makeknown(CARD h[], int n)
{
	int i;

	for (i = 0; i < n; i++)
		known[knownum++] = h[i];
}
@


1.12
log
@fix errx() usage.

OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: support.c,v 1.11 2009/10/27 23:59:24 deraadt Exp $	*/
a32 1
#include <curses.h>
a35 1
#include "deck.h"
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: support.c,v 1.10 2006/03/27 00:10:15 tedu Exp $	*/
d34 1
d111 1
a111 1
		errx("cchose internal error %d %d", j, n);
@


1.10
log
@assorted fixes mostly from coverity via netbsd via jasper adriaanse via tech
@
text
@d1 1
a1 1
/*	$OpenBSD: support.c,v 1.9 2004/07/10 07:26:23 deraadt Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)support.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: support.c,v 1.9 2004/07/10 07:26:23 deraadt Exp $";
#endif
#endif /* not lint */
@


1.9
log
@more ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: support.c,v 1.8 2004/01/16 00:13:18 espie Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: support.c,v 1.8 2004/01/16 00:13:18 espie Exp $";
d117 2
@


1.8
log
@ISO C police: log and expl are reserved for the C library.
expl -> expl_string
log -> logit
@
text
@d1 1
a1 1
/*	$OpenBSD: support.c,v 1.7 2003/06/03 03:01:39 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: support.c,v 1.7 2003/06/03 03:01:39 millert Exp $";
d58 1
a58 3
cchose(h, n, s)
	CARD h[];
	int n, s;
d125 1
a125 3
plyrhand(hand, s)
	CARD    hand[];
	char   *s;
d165 1
a165 3
comphand(h, s)
	CARD h[];
	char *s;
d183 1
a183 2
chkscr(scr, inc)
	int    *scr, inc;
d204 1
a204 4
prpeg(score, peg, myturn)
	int score;
	int peg;
	bool myturn;
d240 1
a240 2
cdiscard(mycrib)
	bool mycrib;
d292 1
a292 3
anymove(hand, n, sum)
	CARD hand[];
	int n, sum;
d311 1
a311 3
anysumto(hand, n, s, t)
	CARD hand[];
	int n, s, t;
d326 1
a326 3
numofval(h, n, v)
	CARD h[];
	int n, v;
d342 1
a342 3
makeknown(h, n)
	CARD h[];
	int n;
@


1.7
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: support.c,v 1.6 2003/04/06 18:50:36 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: support.c,v 1.6 2003/04/06 18:50:36 deraadt Exp $";
d157 1
a157 1
			msg("Explanation: %s", expl);
@


1.6
log
@2451 lines of strdup/sprintf/strcpy whacking.  mostly ok'd by pjanzen
already, but he may have later changes to make still.
@
text
@d1 1
a1 1
/*	$OpenBSD: support.c,v 1.5 2001/08/10 23:50:22 pjanzen Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: support.c,v 1.5 2001/08/10 23:50:22 pjanzen Exp $";
@


1.5
log
@-m option for muggins
better user input parsing
man page tidying and syncing of rules to Hoyle's
typo and context correction in "Hoyle's" transcription
@
text
@d1 1
a1 1
/*	$OpenBSD: support.c,v 1.4 1999/11/29 06:42:20 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: support.c,v 1.4 1999/11/29 06:42:20 millert Exp $";
d140 1
a140 1
	(void) sprintf(prompt, "Your %s scores ", s);
@


1.4
log
@Kill BOOLEAN, just use the curses/c++ bool type instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: support.c,v 1.3 1998/08/19 07:40:26 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: support.c,v 1.3 1998/08/19 07:40:26 pjanzen Exp $";
d147 2
a148 2
			msg("It's really only %d points; I get %d", i, 2);
			if (!win)
d150 2
d155 4
@


1.3
log
@tags, formatting, ANSI-fication, prototypes, de-typos, and the occasional
initialization, removal of unused variable, or other minor fix.  Most
changes are from or inspired by NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD$";
d137 1
a137 1
	BOOLEAN win;
d190 1
a190 1
	BOOLEAN myturn;
d212 1
a212 1
	BOOLEAN myturn;
d249 1
a249 1
	BOOLEAN mycrib;
@


1.2
log
@Clean up play, let player see play more often, improve display timing.
Preliminary work from PR 2055 (as reverse patches); phil
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: support.c,v 1.3 1995/03/21 15:08:59 cgd Exp $";
d66 1
a66 1
	register int i, j, l;
d136 2
a137 2
	register int i, j;
	register BOOLEAN win;
d171 1
a171 1
	register int j;
d210 1
a210 1
	register int score;
d214 1
a214 1
	register int y, x;
d252 1
a252 1
	register int i, j, k;
d305 1
a305 1
	register int i, j;
d326 1
a326 1
	register int i;
d343 1
a343 1
	register int i, j;
d361 1
a361 1
	register int i;
@


1.1
log
@Initial revision
@
text
@d193 2
a194 2
		prpeg(Lastscore[myturn], '.', myturn);
		Lastscore[myturn] = *scr;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
