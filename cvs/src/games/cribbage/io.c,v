head	1.22;
access;
symbols
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.19.0.8
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.14.0.10
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.6
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.4
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.2
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.8
	OPENBSD_5_0:1.13.0.6
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.10.0.18
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.16
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.14
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.12
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.10
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.8
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.6
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2016.01.10.13.35.09;	author mestre;	state Exp;
branches;
next	1.21;
commitid	mVbl9a8GbGdqcFgu;

1.21
date	2015.12.31.18.10.20;	author mestre;	state Exp;
branches;
next	1.20;
commitid	sUE3xE4r7FTWhVk4;

1.20
date	2015.10.24.18.04.06;	author mmcc;	state Exp;
branches;
next	1.19;
commitid	9vEfp3N9Ja3gEIa2;

1.19
date	2014.05.09.23.56.26;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2014.05.09.23.39.10;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2014.05.09.03.13.24;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2014.05.09.02.47.25;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2014.05.09.00.03.41;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.13;

1.13
date	2010.05.10.08.53.12;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.27.23.59.24;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.03.15.43.17;	author sthen;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.10.07.26.23;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.03.03.01.39;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.25.21.19.55;	author tdeval;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.19.19.39.36;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.17.23.14.30;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	99.11.29.06.42.20;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.08.19.07.40.22;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	97.07.25.19.34.05;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	97.07.24.15.08.24;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.48;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.48;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@As per style(9), remove remaining lint-style comments from games/

OK tb@@
@
text
@/*	$OpenBSD: io.c,v 1.21 2015/12/31 18:10:20 mestre Exp $	*/
/*	$NetBSD: io.c,v 1.9 1997/07/09 06:25:47 phil Exp $	*/

/*-
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <ctype.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "cribbage.h"
#include "cribcur.h"

#define	LINESIZE		128

#ifdef CTRL
#undef CTRL
#endif
#define	CTRL(X)			(X - 'A' + 1)

char    linebuf[LINESIZE];

char   *rankname[RANKS] = {
	"ACE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN",
	"EIGHT", "NINE", "TEN", "JACK", "QUEEN", "KING"
};

char   *rankchar[RANKS] = {
	"A", "2", "3", "4", "5", "6", "7", "8", "9", "T", "J", "Q", "K"
};

char   *suitname[SUITS] = {"SPADES", "HEARTS", "DIAMONDS", "CLUBS"};

char   *suitchar[SUITS] = {"S", "H", "D", "C"};

/*
 * msgcard:
 *	Call msgcrd in one of two forms
 */
int
msgcard(CARD c, bool brief)
{
	if (brief)
		return (msgcrd(c, TRUE, NULL, TRUE));
	else
		return (msgcrd(c, FALSE, " of ", FALSE));
}

/*
 * msgcrd:
 *	Print the value of a card in ascii
 */
int
msgcrd(CARD c, bool brfrank, char *mid, bool brfsuit)
{
	if (c.rank == EMPTY || c.suit == EMPTY)
		return (FALSE);
	if (brfrank)
		addmsg("%1.1s", rankchar[c.rank]);
	else
		addmsg("%s", rankname[c.rank]);
	if (mid != NULL)
		addmsg("%s", mid);
	if (brfsuit)
		addmsg("%1.1s", suitchar[c.suit]);
	else
		addmsg("%s", suitname[c.suit]);
	return (TRUE);
}

/*
 * printcard:
 *	Print out a card.
 */
void
printcard(WINDOW *win, int cardno, CARD c, bool blank)
{
	prcard(win, cardno * 2, cardno, c, blank);
}

/*
 * prcard:
 *	Print out a card on the window at the specified location
 */
void
prcard(WINDOW *win, int y, int x, CARD c, bool blank)
{
	if (c.rank == EMPTY)
		return;

	mvwaddstr(win, y + 0, x, "+-----+");
	mvwaddstr(win, y + 1, x, "|     |");
	mvwaddstr(win, y + 2, x, "|     |");
	mvwaddstr(win, y + 3, x, "|     |");
	mvwaddstr(win, y + 4, x, "+-----+");
	if (!blank) {
		mvwaddch(win, y + 1, x + 1, rankchar[c.rank][0]);
		waddch(win, suitchar[c.suit][0]);
		mvwaddch(win, y + 3, x + 4, rankchar[c.rank][0]);
		waddch(win, suitchar[c.suit][0]);
	}
}

/*
 * prhand:
 *	Print a hand of n cards
 */
void
prhand(CARD h[], int n, WINDOW *win, bool blank)
{
	int i;

	werase(win);
	for (i = 0; i < n; i++)
		printcard(win, i, *h++, blank);
	wrefresh(win);
}

/*
 * infrom:
 *	reads a card, supposedly in hand, accepting unambiguous brief
 *	input, returns the index of the card found...
 */
int
infrom(CARD hand[], int n, char *prompt)
{
	int i, j;
	CARD crd;

	if (n < 1) {
		bye();
		printf("\nINFROM: %d = n < 1!!\n", n);
		exit(74);
	}
	for (;;) {
		msg("%s", prompt);
		if (incard(&crd)) {	/* if card is full card */
			if (!isone(crd, hand, n))
				msg("That's not in your hand");
			else {
				for (i = 0; i < n; i++)
					if (hand[i].rank == crd.rank &&
					    hand[i].suit == crd.suit)
						break;
				if (i >= n) {
					bye();
			printf("\nINFROM: isone or something messed up\n");
					exit(77);
				}
				return (i);
			}
		} else			/* if not full card... */
			if (crd.rank != EMPTY) {
				for (i = 0; i < n; i++)
					if (hand[i].rank == crd.rank)
						break;
				if (i >= n)
					msg("No such rank in your hand");
				else {
					for (j = i + 1; j < n; j++)
						if (hand[j].rank == crd.rank)
							break;
					if (j < n)
						msg("Ambiguous rank");
					else
						return (i);
				}
			} else
				msg("Sorry, I missed that");
	}
}

/*
 * incard:
 *	Inputs a card in any format.  It reads a line ending with a CR
 *	and then parses it.
 */
int
incard(CARD *crd)
{
	int i;
	int rnk, sut;
	char *p, *p1;
	bool retval;

	retval = FALSE;
	rnk = sut = EMPTY;
	p1 = get_line();
	if (*p1 == '\0')
		goto gotit;
	p = p1;
	while (*p1 != ' ' && *p1 != '\0')
		++p1;
	*p1++ = '\0';

	/* IMPORTANT: no real card has 2 char first name */
	if (p + 3 == p1) {	/* check for short form */
		for (i = 0; i < RANKS; i++) {
			if (*p == *rankchar[i]) {
				rnk = i;
				break;
			}
		}
		if (rnk == EMPTY)
			goto gotit;	/* it's nothing... */
		++p;		/* advance to next char */
		for (i = 0; i < SUITS; i++) {
			if (*p == *suitchar[i]) {
				sut = i;
				break;
			}
		}
		if (sut != EMPTY)
			retval = TRUE;
		goto gotit;
	}
	for (i = 0; i < RANKS; i++) {
		if (!strcmp(p, rankname[i]) || !strcmp(p, rankchar[i])) {
			rnk = i;
			break;
		}
	}
	if (rnk == EMPTY || *p1 == '\0')
		goto gotit;
	p = p1;
	while (*p1 != ' ' && *p1 != '\0')
		++p1;
	*p1++ = '\0';
	if (!strcmp("OF", p)) {
		if (*p1 == '\0')
			goto gotit;
		p = p1;
		while (*p1 != ' ' && *p1 != '\0')
			++p1;
		*p1 = '\0';
	}
	for (i = 0; i < SUITS; i++) {
		if (!strcmp(p, suitname[i]) || !strcmp(p, suitchar[i])) {
			sut = i;
			break;
		}
	}
	if (sut != EMPTY)
		retval = TRUE;
gotit:
	(*crd).rank = rnk;
	(*crd).suit = sut;
	return (retval);
}

/*
 * getuchar:
 *	Reads and converts to upper case
 */
int
getuchar(void)
{
	int c;

	c = readchar();
	if (islower(c))
		c = toupper(c);
	waddch(Msgwin, c);
	return (c);
}

/*
 * number:
 *	Reads in a decimal number and makes sure it is between "lo" and
 *	"hi" inclusive.
 */
int
number(int lo, int hi, char *prompt)
{
	char *p;
	int sum, tmp;

	for (sum = 0;;) {
		msg("%s", prompt);
		p = get_line();
		if (*p == '\0') {
			msg(quiet ? "Not a number" :
			    "That doesn't look like a number");
			continue;
		}
		sum = 0;

		if (!isdigit((unsigned char)*p))
			sum = lo - 1;
		else
			while (isdigit((unsigned char)*p)) {
				tmp = 10 * sum + (*p - '0');
				/* Overflow */
				if (tmp < sum) {
					sum = hi + 1;
					while (isdigit((unsigned char)*p))
						++p;
					break;
				}
				sum = tmp;
				++p;
			}

		if (*p != ' ' && *p != '\t' && *p != '\0')
			sum = lo - 1;
		if (sum >= lo && sum <= hi)
			break;
		if (sum == lo - 1)
			msg(quiet ? "Not a number" :
			    "That doesn't look like a number");
		else
			msg("That is not between %d and %d inclusive",
			    lo, hi);
	}
	return (sum);
}

/*
 * msg:
 *	Display a message at the top of the screen.
 */
char    Msgbuf[BUFSIZ] = {'\0'};
int     Mpos = 0;
static int Newpos = 0;

void
msg(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	(void)vsnprintf(&Msgbuf[Newpos], sizeof Msgbuf - Newpos, fmt, ap);
	Newpos = strlen(Msgbuf);
	va_end(ap);
	endmsg();
}

/*
 * addmsg:
 *	Add things to the current message
 */
void
addmsg(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	(void)vsnprintf(&Msgbuf[Newpos], sizeof Msgbuf - Newpos, fmt, ap);
	Newpos = strlen(Msgbuf);
	va_end(ap);
}

/*
 * endmsg:
 *	Display a new msg.
 */
int     Lineno = 0;

void
endmsg(void)
{
	static int lastline = 0;
	int len;
	char *mp, *omp;

	/* All messages should start with uppercase */
	mvaddch(lastline + Y_MSG_START, SCORE_X, ' ');
	if (islower((unsigned char)Msgbuf[0]) && Msgbuf[1] != ')')
		Msgbuf[0] = toupper((unsigned char)Msgbuf[0]);
	mp = Msgbuf;
	len = strlen(mp);
	if (len / MSG_X + Lineno >= MSG_Y) {
		while (Lineno < MSG_Y) {
			wmove(Msgwin, Lineno++, 0);
			wclrtoeol(Msgwin);
		}
		Lineno = 0;
	}
	mvaddch(Lineno + Y_MSG_START, SCORE_X, '*');
	lastline = Lineno;
	do {
		mvwaddstr(Msgwin, Lineno, 0, mp);
		if ((len = strlen(mp)) > MSG_X) {
			omp = mp;
			for (mp = &mp[MSG_X - 1]; *mp != ' '; mp--)
				continue;
			while (*mp == ' ')
				mp--;
			mp++;
			wmove(Msgwin, Lineno, mp - omp);
			wclrtoeol(Msgwin);
		}
		if (++Lineno >= MSG_Y)
			Lineno = 0;
	} while (len > MSG_X);
	wclrtoeol(Msgwin);
	Mpos = len;
	Newpos = 0;
	wrefresh(Msgwin);
	refresh();
	wrefresh(Msgwin);
}

/*
 * do_wait:
 *	Wait for the user to type ' ' before doing anything else
 */
void
do_wait(void)
{
	static char prompt[] = {'-', '-', 'M', 'o', 'r', 'e', '-', '-', '\0'};

	if (Mpos + sizeof prompt < MSG_X)
		wmove(Msgwin, Lineno > 0 ? Lineno - 1 : MSG_Y - 1, Mpos);
	else {
		mvwaddch(Msgwin, Lineno, 0, ' ');
		wclrtoeol(Msgwin);
		if (++Lineno >= MSG_Y)
			Lineno = 0;
	}
	waddstr(Msgwin, prompt);
	wrefresh(Msgwin);
	wait_for(' ');
}

/*
 * wait_for
 *	Sit around until the guy types the right key
 */
void
wait_for(int ch)
{
	char c;

	if (ch == '\n')
		while ((c = readchar()) != '\n')
			continue;
	else
		while (readchar() != ch)
			continue;
}

/*
 * readchar:
 *	Reads and returns a character, checking for gross input errors
 */
int
readchar(void)
{
	int cnt;
	char c;

over:
	cnt = 0;
	while (read(STDIN_FILENO, &c, sizeof(char)) <= 0)
		if (cnt++ > 100) {	/* if we are getting infinite EOFs */
			bye();		/* quit the game */
			exit(1);
		}
	if (c == CTRL('L')) {
		wrefresh(curscr);
		goto over;
	}
	if (c == '\r')
		return ('\n');
	else
		return (c);
}

/*
 * get_line:
 *      Reads the next line up to '\n' or EOF.  Multiple spaces are
 *	compressed to one space; a space is inserted before a ','
 */
char *
get_line(void)
{
	size_t pos;
	int c, oy, ox;
	WINDOW *oscr;

	oscr = stdscr;
	stdscr = Msgwin;
	getyx(stdscr, oy, ox);
	refresh();
	/* loop reading in the string, and put it in a temporary buffer */
	for (pos = 0; (c = readchar()) != '\n'; clrtoeol(), refresh()) {
		if (c == -1)
			continue;
		if (c == ' ' && (pos == 0 || linebuf[pos - 1] == ' '))
			continue;
		if (c == erasechar()) {
			if (pos > 0) {
				int i;
				pos--;
				for (i = strlen(unctrl(linebuf[pos])); i; i--)
					addch('\b');
			}
			continue;
		}
		if (c == killchar()) {
			pos = 0;
			move(oy, ox);
			continue;
		}
		if (pos >= LINESIZE - 1 || !(isalnum(c) || c == ' ')) {
			beep();
			continue;
		}
		if (islower(c))
			c = toupper(c);
		linebuf[pos++] = c;
		addstr(unctrl(c));
		Mpos++;
	}
	while (pos < sizeof(linebuf))
		linebuf[pos++] = '\0';
	stdscr = oscr;
	return (linebuf);
}

void
rintsig(int signo)
{
	bye();
	exit(1);
}

/*
 * bye:
 *	Leave the program, cleaning things up as we go.
 */
void
bye(void)
{
	signal(SIGINT, SIG_IGN);
	mvcur(0, COLS - 1, LINES - 1, 0);
	fflush(stdout);
	endwin();
	putchar('\n');
}
@


1.21
log
@Include only needed header files per each source file

This one was also OK'ed by tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.20 2015/10/24 18:04:06 mmcc Exp $	*/
a198 1
	/* NOTREACHED */
@


1.20
log
@Cast ctype functions' arguments to unsigned char.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.19 2014/05/09 23:56:26 schwarze Exp $	*/
a33 1
#include <curses.h>
a36 1
#include <termios.h>
a37 1
#include <stdarg.h>
a38 1
#include "deck.h"
@


1.19
log
@Various cleanup in incard():
* get_line() always returns the same non-NULL pointer,
so testing the return value is useless.
* Garbage collect the unused variable *line.
* Check for end-of-buffer before parsing the next word instead of after it.
* Skip strlen() when the length has been measured three lines before anyway.
* Do not initialize local variables over and over again.
feedback and ok pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.18 2014/05/09 23:39:10 schwarze Exp $	*/
d321 1
a321 1
		if (!isdigit(*p))
d324 1
a324 1
			while (isdigit(*p)) {
d329 1
a329 1
					while (isdigit(*p))
d401 2
a402 2
	if (islower(Msgbuf[0]) && Msgbuf[1] != ')')
		Msgbuf[0] = toupper(Msgbuf[0]);
@


1.18
log
@Fix a mini-bug reported by pjanzen@@:
When entering card names, you can use multiple words (like KING OF SPADES).
If you entered more than one consecutive blank character between words,
the function incard() took that as end-of-string and ignored the rest.
Fix this by dropping duplicate blanks up front, in get_line().
Patch simplified by me, ok pjanzen@@.

While here, use beep(3) in an adjacent line instead of manually fiddling
with control characters, suggested by pjanzen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.17 2014/05/09 03:13:24 schwarze Exp $	*/
d216 1
a216 1
	char *line, *p, *p1;
d221 2
a222 1
	if (!(line = get_line()))
d224 1
a224 1
	p = p1 = line;
a227 2
	if (*p == '\0')
		goto gotit;
d230 1
a230 2
	if (strlen(p) == 2) {	/* check for short form */
		rnk = EMPTY;
a239 1
		sut = EMPTY;
a249 1
	rnk = EMPTY;
d256 1
a256 1
	if (rnk == EMPTY)
a261 2
	if (*p == '\0')
		goto gotit;
d263 2
d268 1
a268 3
		*p1++ = '\0';
		if (*p == '\0')
			goto gotit;
a269 1
	sut = EMPTY;
d313 2
a314 1
		if (!(p = get_line()) || *p == '\0') {
@


1.17
log
@KNF: unify style and reduce indentation in get_line(), no binary change
ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.16 2014/05/09 02:47:25 schwarze Exp $	*/
d529 2
d545 2
a546 4
		if (pos == 0 && c == ' ')
			continue;
		if (pos >= LINESIZE - 1 || !(isprint(c) || c == ' ')) {
			putchar(CTRL('G'));
@


1.16
log
@After entering an invalid three-letter card name, one letter card names
stopped working because the third letter remained in the buffer,
incard() skipped the NUL and used the old garbage.
Fix this bug reported by pjanzen@@, but in a simpler way than he
suggested, by just clearing any trailing garbage from the buffer.
ok pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.15 2014/05/09 00:03:41 schwarze Exp $	*/
d529 17
a545 17
		else
			if (c == erasechar()) {	/* process erase character */
				if (pos > 0) {
					int i;

					pos--;
					for (i = strlen(unctrl(linebuf[pos])); i; i--)
						addch('\b');
				}
				continue;
			} else if (c == killchar()) {	/* process kill character */
				pos = 0;
				move(oy, ox);
				continue;
			} else if (pos == 0 && c == ' ')
				continue;
		if (pos >= LINESIZE - 1 || !(isprint(c) || c == ' '))
d547 1
a547 6
		else {
			if (islower(c))
				c = toupper(c);
			linebuf[pos++] = c;
			addstr(unctrl(c));
			Mpos++;
d549 5
@


1.15
log
@Various cleanup:
1. Style: Don't use variables as format strings.
NetBSD rev. 1.26 (May 23, 2011) joerg@@NetBSD via maintainer pjanzen@@.
2. Style: Avoid needless pointer arithmetics.
NetBSD rev. 1.27 (Oct 13, 2012) dholland@@NetBSD via pjanzen@@,
who also applied some KNF to the indentation while here.
3. End curses before printing fatal error messages; from pjanzen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.14 2012/03/04 04:05:15 fgsch Exp $	*/
d555 2
a556 1
	linebuf[pos] = '\0';
@


1.14
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.13 2010/05/10 08:53:12 nicm Exp $	*/
d93 1
a93 1
		addmsg(rankname[c.rank]);
d95 1
a95 1
		addmsg(mid);
d99 1
a99 1
		addmsg(suitname[c.suit]);
d163 1
d168 1
a168 1
		msg(prompt);
d178 1
d319 1
a319 1
		msg(prompt);
d517 1
a517 1
	char *sp;
d526 1
a526 1
	for (sp = linebuf; (c = readchar()) != '\n'; clrtoeol(), refresh()) {
d531 1
a531 1
				if (sp > linebuf) {
d534 2
a535 2
					sp--;
					for (i = strlen(unctrl(*sp)); i; i--)
d539 7
a545 10
			} else
				if (c == killchar()) {	/* process kill
							 * character */
					sp = linebuf;
					move(oy, ox);
					continue;
				} else
					if (sp == linebuf && c == ' ')
						continue;
		if (sp >= &linebuf[LINESIZE - 1] || !(isprint(c) || c == ' '))
d550 1
a550 1
			*sp++ = c;
d555 1
a555 1
	*sp = '\0';
@


1.13
log
@Rename use of some builtins that makes gcc4 warn.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.12 2009/10/27 23:59:24 deraadt Exp $	*/
d219 1
a219 1
	if (!(line = getline()))
d318 1
a318 1
		if (!(p = getline()) || *p == '\0') {
d508 1
a508 1
 * getline:
d513 1
a513 1
getline(void)
@


1.12
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.11 2008/12/03 15:43:17 sthen Exp $	*/
d562 1
a562 1
rint(int signo)
@


1.11
log
@Some more ambigous -> ambiguous pointed out by mbalmer (there are
others, these are the ones from code unlikely to be re-merged with
upstream sources).
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.10 2004/07/10 07:26:23 deraadt Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)io.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$NetBSD: io.c,v 1.7 1995/03/21 15:08:53 cgd Exp $";
#endif
#endif /* not lint */
@


1.10
log
@more ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.9 2003/06/03 03:01:39 millert Exp $	*/
d161 1
a161 1
 *	reads a card, supposedly in hand, accepting unambigous brief
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.8 2003/04/25 21:19:55 tdeval Exp $	*/
d81 1
a81 3
msgcard(c, brief)
	CARD c;
	bool brief;
d94 1
a94 4
msgcrd(c, brfrank, mid, brfsuit)
	CARD c;
	bool brfrank, brfsuit;
	char *mid;
d116 1
a116 5
printcard(win, cardno, c, blank)
	WINDOW *win;
	int     cardno;
	CARD    c;
	bool blank;
d126 1
a126 5
prcard(win, y, x, c, blank)
	WINDOW *win;
	int y, x;
	CARD c;
	bool blank;
d149 1
a149 5
prhand(h, n, win, blank)
	CARD h[];
	int n;
	WINDOW *win;
	bool blank;
d165 1
a165 4
infrom(hand, n, prompt)
	CARD hand[];
	int n;
	char *prompt;
d218 1
a218 2
incard(crd)
	CARD *crd;
d302 1
a302 1
getuchar()
d319 1
a319 3
number(lo, hi, prompt)
	int lo, hi;
	char *prompt;
d405 1
a405 1
endmsg()
d454 1
a454 1
do_wait()
d476 1
a476 2
wait_for(ch)
	int ch;
d493 1
a493 1
readchar()
d521 1
a521 1
getline()
d570 1
a570 2
rint(signo)
	int signo;
d581 1
a581 1
bye()
@


1.8
log
@strings... ok henning@@, millert@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.7 2002/02/19 19:39:36 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.6 2001/08/17 23:14:30 pjanzen Exp $	*/
d404 1
a404 1
	(void)vsprintf(&Msgbuf[Newpos], fmt, ap);
d420 1
a420 1
	(void)vsprintf(&Msgbuf[Newpos], fmt, ap);
@


1.6
log
@Better handling of out-of-range numbers.
Extraneous prompt and related comma splice removed.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.5 1999/11/29 06:42:20 millert Exp $	*/
a51 2

#ifdef __STDC__
a52 3
#else
#include <varargs.h>
#endif
a398 1
#ifdef __STDC__
a399 5
#else
msg(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
a402 1
#ifdef __STDC__
a403 3
#else
	va_start(ap);
#endif
a414 1
#ifdef __STDC__
a415 5
#else
addmsg(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
a418 1
#ifdef __STDC__
a419 3
#else
	va_start(ap);
#endif
@


1.5
log
@Kill BOOLEAN, just use the curses/c++ bool type instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.4 1998/08/19 07:40:22 pjanzen Exp $	*/
d354 1
a354 1
	int sum;
d369 9
a377 1
				sum = 10 * sum + (*p - '0');
d386 2
a387 1
			msg("that doesn't look like a number, try again --> ");
d389 2
a390 2
		msg("%d is not between %d and %d inclusive, try again --> ",
			    sum, lo, hi);
@


1.4
log
@tags, formatting, ANSI-fication, prototypes, de-typos, and the occasional
initialization, removal of unused variable, or other minor fix.  Most
changes are from or inspired by NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d92 1
a92 1
	BOOLEAN brief;
d107 1
a107 1
	BOOLEAN brfrank, brfsuit;
d134 1
a134 1
	BOOLEAN blank;
d148 1
a148 1
	BOOLEAN blank;
d175 1
a175 1
	BOOLEAN blank;
d253 1
a253 1
	BOOLEAN retval;
@


1.3
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
d177 1
a177 1
	register int i;
d196 1
a196 1
	register int i, j;
d250 1
a250 1
	register int i;
d260 1
a260 1
	while (*p1 != ' ' && *p1 != NULL)
d262 2
a263 2
	*p1++ = NULL;
	if (*p == NULL)
d299 1
a299 1
	while (*p1 != ' ' && *p1 != NULL)
d301 2
a302 2
	*p1++ = NULL;
	if (*p == NULL)
d306 1
a306 1
		while (*p1 != ' ' && *p1 != NULL)
d308 2
a309 2
		*p1++ = NULL;
		if (*p == NULL)
d334 1
a334 1
	register int c;
d353 2
a354 2
	register char *p;
	register int sum;
d358 1
a358 1
		if (!(p = getline()) || *p == NULL) {
d373 1
a373 1
		if (*p != ' ' && *p != '\t' && *p != NULL)
d451 2
a452 2
	register int len;
	register char *mp, *omp;
d520 1
a520 1
	register int ch;
d522 1
a522 1
	register char c;
d539 1
a539 1
	register int cnt;
d567 3
a569 3
	register char *sp;
	register int c, oy, ox;
	register WINDOW *oscr;
d582 1
a582 1
					register int i;
@


1.2
log
@Clean up play, let player see play more often, improve display timing.
Preliminary work from PR 2055 (as reverse patches); phil
@
text
@d52 1
a52 1
#if __STDC__
d394 1
a394 1
#if __STDC__
d404 1
a404 1
#if __STDC__
d420 1
a420 1
#if __STDC__
d430 1
a430 1
#if __STDC__
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: io.c,v 1.7 1995/03/21 15:08:53 cgd Exp $	*/
d410 1
d436 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
