head	1.20;
access;
symbols
	OPENBSD_6_2:1.20.0.2
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.4
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.19.0.2
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.22
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.20
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.16
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.14
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.12
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.28
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.24
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.22
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.20
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.18
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.16
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.14
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.12
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.10
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.8
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.8.0.6
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.4
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.6.0.6
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2016.09.11.14.21.17;	author tb;	state Exp;
branches;
next	1.19;
commitid	vQliJ9M8LCn9g8k6;

1.19
date	2016.03.15.19.56.20;	author mestre;	state Exp;
branches;
next	1.18;
commitid	CVq5Psh8I11pL2MZ;

1.18
date	2016.01.09.21.54.11;	author mestre;	state Exp;
branches;
next	1.17;
commitid	ve4zhTqqRMMVn77Z;

1.17
date	2016.01.09.18.33.15;	author mestre;	state Exp;
branches;
next	1.16;
commitid	cGEyAVlKS2f51J9L;

1.16
date	2015.11.11.01.12.10;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	nVtGolYSsQ6VkRrW;

1.15
date	2014.11.16.04.49.48;	author guenther;	state Exp;
branches;
next	1.14;
commitid	8XNajyb9IqHkZEKg;

1.14
date	2009.10.27.23.59.25;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.05.19.06.30.56;	author pjanzen;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.07.09.48.57;	author tdeval;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.06.18.50.37;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.16.21.22.36;	author camield;	state Exp;
branches;
next	1.9;

1.9
date	2002.12.06.21.48.51;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.06.22.59.13;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.28.23.41.46;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.08.16.17.00.17;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.07.26.16.06.52;	author imp;	state Exp;
branches;
next	1.4;

1.4
date	97.01.17.07.11.38;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.05.26.07.23.08;	author fn;	state Exp;
branches;
next	1.2;

1.2
date	96.02.17.23.54.44;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.02;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Callers of time(3) should #include <time.h>.

ok deraadt
@
text
@/*	$OpenBSD: hack.unix.c,v 1.19 2016/03/15 19:56:20 mestre Exp $	*/

/*
 * Copyright (c) 1985, Stichting Centrum voor Wiskunde en Informatica,
 * Amsterdam
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * - Neither the name of the Stichting Centrum voor Wiskunde en
 * Informatica, nor the names of its contributors may be used to endorse or
 * promote products derived from this software without specific prior
 * written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982 Jay Fenlason <hack@@gnu.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* This file collects some Unix dependencies; hack.pager.c contains some more */

/*
 * The time is used for:
 *	- seed for random()
 *	- year on tombstone and yymmdd in record file
 *	- phase of the moon (various monsters react to NEW_MOON or FULL_MOON)
 *	- night and midnight (the undead are dangerous at midnight)
 *	- determination of what files are "very old"
 */

#include <sys/stat.h>

#include <err.h>
#include <errno.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>

#include "hack.h"


static struct tm *getlt(void);
static int veryold(int);
#ifdef MAIL
static void newmail(void);
static void mdrush(struct monst *, boolean);
#endif

static struct tm *
getlt(void)
{
	time_t date;
	struct tm *localtime();

	(void) time(&date);
	return(localtime(&date));
}

int
getyear(void)
{
	return(1900 + getlt()->tm_year);
}

char *
getdate(void)
{
	static char datestr[7];
	struct tm *lt = getlt();

	(void) snprintf(datestr, sizeof(datestr), "%02d%02d%02d",
		lt->tm_year % 100, lt->tm_mon + 1, lt->tm_mday);
	return(datestr);
}

/*
 * 0-7, with 0: new, 4: full
 * moon period: 29.5306 days
 * year: 365.2422 days
 */
int
phase_of_the_moon(void)	
{
	struct tm *lt = getlt();
	int epact, diy, golden;

	diy = lt->tm_yday;
	golden = (lt->tm_year % 19) + 1;
	epact = (11 * golden + 18) % 30;
	if ((epact == 25 && golden > 11) || epact == 24)
		epact++;

	return( (((((diy + epact) * 6) + 11) % 177) / 22) & 7 );
}

int
night(void)
{
	int hour = getlt()->tm_hour;

	return(hour < 6 || hour > 21);
}

int
midnight(void)
{
	return(getlt()->tm_hour == 0);
}

struct stat buf, hbuf;

void
gethdate(char *name)
{
	char *p, *np, *path;
	char filename[PATH_MAX+1];

	if (strchr(name, '/') != NULL || (p = getenv("PATH")) == NULL)
		p = "";
	np = path = strdup(p);	/* Make a copy for strsep. */
	if (path == NULL)
		err(1, NULL);

	for (;;) {
		if ((p = strsep(&np, ":")) == NULL)
			break;
		if (*p == '\0')			/* :: */
			(void) strlcpy(filename, name, sizeof filename);
		else
			(void) snprintf(filename, sizeof filename,
			    "%s/%s", p, name);

		if (stat(filename, &hbuf) == 0) {
			free(path);
			return;
		}
	}
	error("Cannot get status of %s.",
		(p = strrchr(name, '/')) ? p+1 : name);
	free(path);
}

int
uptodate(int fd)
{
	if(fstat(fd, &buf)) {
		pline("Cannot get status of saved level? ");
		return(0);
	}
	if(buf.st_mtime < hbuf.st_mtime) {
		pline("Saved level is out of date. ");
		return(0);
	}
	return(1);
}

/* see whether we should throw away this xlock file */
static int
veryold(int fd)
{
	int i;
	time_t date;

	if(fstat(fd, &buf)) return(0);			/* cannot get status */
	if(buf.st_size != sizeof(int)) return(0);	/* not an xlock file */
	(void) time(&date);
	if(date - buf.st_mtime < 3L*24L*60L*60L) {	/* recent */
		int lockedpid;	/* should be the same size as hackpid */

		if(read(fd, (char *)&lockedpid, sizeof(lockedpid)) !=
			sizeof(lockedpid))
			/* strange ... */
			return(0);

		/* From: Rick Adams <seismo!rick>
		   This will work on 4.1cbsd, 4.2bsd and system 3? & 5.
		   It will do nothing on V7 or 4.1bsd. */
		if(!(kill(lockedpid, 0) == -1 && errno == ESRCH))
			return(0);
	}
	(void) close(fd);
	for(i = 1; i <= MAXLEVEL; i++) {		/* try to remove all */
		glo(i);
		(void) unlink(lock);
	}
	glo(0);
	if(unlink(lock)) return(0);			/* cannot remove it */
	return(1);					/* success! */
}

void
getlock(void)
{
	extern int hackpid, locknum;
	int i = 0, fd;

	(void) fflush(stdout);

	/* we ignore QUIT and INT at this point */
	if (link(HLOCK, LLOCK) == -1) {
		int errnosv = errno;

		perror(HLOCK);
		printf("Cannot link %s to %s\n", LLOCK, HLOCK);
		switch(errnosv) {
		case ENOENT:
		    printf("Perhaps there is no (empty) file %s ?\n", HLOCK);
		    break;
		case EACCES:
		    printf("It seems you don't have write permission here.\n");
		    break;
		case EEXIST:
		    printf("(Try again or rm %s.)\n", LLOCK);
		    break;
		default:
		    printf("I don't know what is wrong.");
		}
		getret();
		error("");
	}

	regularize(lock);
	glo(0);
	if(locknum > 25) locknum = 25;

	do {
		if(locknum) lock[0] = 'a' + i++;

		if((fd = open(lock, O_RDONLY)) == -1) {
			if(errno == ENOENT) goto gotlock;    /* no such file */
			perror(lock);
			(void) unlink(LLOCK);
			error("Cannot open %s", lock);
		}

		if(veryold(fd))	/* if true, this closes fd and unlinks lock */
			goto gotlock;
		(void) close(fd);
	} while(i < locknum);

	(void) unlink(LLOCK);
	error(locknum ? "Too many hacks running now."
		      : "There is a game in progress under your name.");
gotlock:
	fd = open(lock, O_CREAT | O_TRUNC | O_WRONLY, FMASK);
	if(unlink(LLOCK) == -1)
		error("Cannot unlink %s.", LLOCK);
	if(fd == -1) {
		error("cannot creat lock file.");
	} else {
		if(write(fd, (char *) &hackpid, sizeof(hackpid))
		    != sizeof(hackpid)){
			error("cannot write lock");
		}
		if(close(fd) == -1) {
			error("cannot close lock");
		}
	}
}

#ifdef MAIL

/*
 * Notify user when new mail has arrived. [Idea from Merlyn Leroy, but
 * I don't know the details of his implementation.]
 * { Later note: he disliked my calling a general mailreader and felt that
 *   hack should do the paging itself. But when I get mail, I want to put it
 *   in some folder, reply, etc. - it would be unreasonable to put all these
 *   functions in hack. }
 * The mail daemon '2' is at present not a real monster, but only a visual
 * effect. Thus, makemon() is superfluous. This might become otherwise,
 * however. The motion of '2' is less restrained than usual: diagonal moves
 * from a DOOR are possible. He might also use SDOOR's. Also, '2' is visible
 * in a ROOM, even when you are Blind.
 * Its path should be longer when you are Telepat-hic and Blind.
 *
 * Interesting side effects:
 *	- You can get rich by sending yourself a lot of mail and selling
 *	  it to the shopkeeper. Unfortunately mail isn't very valuable.
 *	- You might die in case '2' comes along at a critical moment during
 *	  a fight and delivers a scroll the weight of which causes you to
 *	  collapse.
 *
 * Possible extensions:
 *	- Open the file MAIL and do fstat instead of stat for efficiency.
 *	  (But sh uses stat, so this cannot be too bad.)
 *	- Examine the mail and produce a scroll of mail called "From somebody".
 *	- Invoke MAILREADER in such a way that only this single letter is read.
 *
 *	- Make him lose his mail when a Nymph steals the letter.
 *	- Do something to the text when the scroll is enchanted or cancelled.
 */
static struct stat omstat,nmstat;
static char *mailbox;
static long laststattime;

void
getmailstatus(void)
{
	if(!(mailbox = getenv("MAIL")))
		return;
	if(stat(mailbox, &omstat)){
#ifdef PERMANENT_MAILBOX
		pline("Cannot get status of MAIL=%s .", mailbox);
		mailbox = 0;
#else
		omstat.st_mtime = 0;
#endif /* PERMANENT_MAILBOX */
	}
}

void
ckmailstatus(void)
{
	if(!mailbox
#ifdef MAILCKFREQ
		    || moves < laststattime + MAILCKFREQ
#endif /* MAILCKFREQ */
							)
		return;
	laststattime = moves;
	if(stat(mailbox, &nmstat)){
#ifdef PERMANENT_MAILBOX
		pline("Cannot get status of MAIL=%s anymore.", mailbox);
		mailbox = 0;
#else
		nmstat.st_mtime = 0;
#endif /* PERMANENT_MAILBOX */
	} else if(nmstat.st_mtime > omstat.st_mtime) {
		if(nmstat.st_size)
			newmail();
		getmailstatus();	/* might be too late ... */
	}
}

static void
newmail(void)
{
	/* produce a scroll of mail */
	struct obj *obj;
	struct monst *md;
	extern char plname[];
	extern struct obj *mksobj();
	extern struct monst *makemon();
	extern struct permonst pm_mail_daemon;

	obj = mksobj(SCR_MAIL);
	if(md = makemon(&pm_mail_daemon, u.ux, u.uy)) /* always succeeds */
		mdrush(md,0);

	pline("\"Hello, %s! I have some mail for you.\"", plname);
	if(md) {
		if(dist(md->mx,md->my) > 2)
			pline("\"Catch!\"");
		more();

		/* let him disappear again */
		mdrush(md,1);
		mondead(md);
	}

	obj = addinv(obj);
	(void) identify(obj);		/* set known and do prinv() */
}

/* make md run through the cave */
static void
mdrush(struct monst *md, boolean away)
{
	int uroom = inroom(u.ux, u.uy);
	if(uroom >= 0) {
		int tmp = rooms[uroom].fdoor;
		int cnt = rooms[uroom].doorct;
		int fx = u.ux, fy = u.uy;
		while(cnt--) {
			if(dist(fx,fy) < dist(doors[tmp].x, doors[tmp].y)){
				fx = doors[tmp].x;
				fy = doors[tmp].y;
			}
			tmp++;
		}
		tmp_at(-1, md->data->mlet);	/* open call */
		if(away) {	/* interchange origin and destination */
			unpmon(md);
			tmp = fx; fx = md->mx; md->mx = tmp;
			tmp = fy; fy = md->my; md->my = tmp;
		}
		while(fx != md->mx || fy != md->my) {
			int dx,dy,nfx = fx,nfy = fy,d1,d2;

			tmp_at(fx,fy);
			d1 = DIST(fx,fy,md->mx,md->my);
			for(dx = -1; dx <= 1; dx++) for(dy = -1; dy <= 1; dy++)
			    if(dx || dy) {
				d2 = DIST(fx+dx,fy+dy,md->mx,md->my);
				if(d2 < d1) {
				    d1 = d2;
				    nfx = fx+dx;
				    nfy = fy+dy;
				}
			    }
			if(nfx != fx || nfy != fy) {
			    fx = nfx;
			    fy = nfy;
			} else {
			    if(!away) {
				md->mx = fx;
				md->my = fy;
			    }
			    break;
			} 
		}
		tmp_at(-1,-1);			/* close call */
	}
	if(!away)
		pmon(md);
}

void
readmail(void)
{
#ifdef DEF_MAILREADER			/* This implies that UNIX is defined */
	char *mr = 0;
	more();
	if(!(mr = getenv("MAILREADER")))
		mr = DEF_MAILREADER;
	if(child(1)){
		execl(mr, mr, (char *)NULL);
		exit(1);
	}
#else /* DEF_MAILREADER */
	(void) page_file(mailbox, FALSE);
#endif /* DEF_MAILREADER */
	/* get new stat; not entirely correct: there is a small time
	   window where we do not see new mail */
	getmailstatus();
}
#endif /* MAIL */

/* normalize file name - we don't like ..'s or /'s */
void
regularize(char *s)
{
	char *lp;

	while((lp = strchr(s, '.')) || (lp = strchr(s, '/')))
		*lp = '_';
}
@


1.19
log
@execl(3) calls must have the last argument casted to (char *)NULL

At the time when this was commited me and tb@@ discussed that it shouldn't be
changed, but still snucked in within a larger diff that we didn't notice.

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.unix.c,v 1.18 2016/01/09 21:54:11 mestre Exp $	*/
d83 1
@


1.18
log
@Remove several casts to (char *) 0 and replace them by NULL

Prompted and OK by tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.unix.c,v 1.17 2016/01/09 18:33:15 mestre Exp $	*/
d474 1
a474 1
		execl(mr, mr, NULL);
@


1.17
log
@This diff is rather large, but it's just simply removing unnecessary headers
, remove some lint-style comments, add missing void to functions without args,
also some function prototypes (extern) were missing their args, so I added them
as they were defined in hack.h

OK tb@@ on separate diffs
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.unix.c,v 1.16 2015/11/11 01:12:10 deraadt Exp $	*/
d474 1
a474 1
		execl(mr, mr, (char *) 0);
@


1.16
log
@creat() -> open equiv; from Frederic Nowak
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.unix.c,v 1.15 2014/11/16 04:49:48 guenther Exp $	*/
d75 11
a85 12
#include	<sys/types.h>		/* for time_t and stat */
#include	<sys/stat.h>
#include	<sys/time.h>

#include	<err.h>
#include	<errno.h>
#include	<limits.h>
#include	<signal.h>
#include	<stdio.h>
#include	<stdlib.h>
#include	<unistd.h>
#include	"hack.h"
d96 1
a96 1
getlt()
d106 1
a106 1
getyear()
d112 1
a112 1
getdate()
d122 5
d128 2
a129 3
phase_of_the_moon()			/* 0-7, with 0: new, 4: full */
{					/* moon period: 29.5306 days */
					/* year: 365.2422 days */
d143 1
a143 1
night()
d151 1
a151 1
midnight()
d238 1
a238 1
getlock()
a265 1
		/*NOTREACHED*/
d344 1
a344 1
getmailstatus()
d359 1
a359 1
ckmailstatus()
d383 1
a383 1
newmail()
d466 1
a466 1
readmail()
@


1.15
log
@Eliminate pointless use of <sys/param.h>, <sys/file.h>, <sys/sockio.h>,
    and <sys/ttydefaults.h>
Replace MAXPATHLEN with PATH_MAX and MAXLOGNAME with LOGIN_NAME_MAX
Pull in <limits.h> where needed
Prefer sizeof(var) over MAXFOO or FOO_MAX

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.unix.c,v 1.14 2009/10/27 23:59:25 deraadt Exp $	*/
d289 1
a289 1
	fd = creat(lock, FMASK);
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.unix.c,v 1.13 2003/05/19 06:30:56 pjanzen Exp $	*/
a76 1
#include	<sys/param.h>
d81 1
d159 1
a159 1
	char filename[MAXPATHLEN+1];
@


1.13
log
@De-register, ANSIfy, clean up.
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.unix.c,v 1.12 2003/05/07 09:48:57 tdeval Exp $	*/
a62 4

#ifndef lint
static const char rcsid[] = "$OpenBSD$";
#endif /* not lint */
@


1.12
log
@Major strings rework.  Ok pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.unix.c,v 1.11 2003/04/06 18:50:37 deraadt Exp $	*/
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.unix.c,v 1.11 2003/04/06 18:50:37 deraadt Exp $";
a78 4
#include <stdio.h>
#include <errno.h>
#include "hack.h"

d81 1
a81 1
#ifdef BSD
a82 3
#else
#include	<time.h>
#endif /* BSD */
d84 8
a91 2
extern char *getenv();
extern time_t time();
d93 6
a98 4
setrandom()
{
 	(void) srandomdev();
}
d100 1
a100 1
struct tm *
d110 1
d120 1
a120 1
	register struct tm *lt = getlt();
d127 1
d131 2
a132 2
	register struct tm *lt = getlt();
	register int epact, diy, golden;
d143 1
d146 1
a146 1
	register int hour = getlt()->tm_hour;
d151 1
d159 5
a163 18
gethdate(name) char *name; {
/* old version - for people short of space */
/*
    register char *np;
  	if(stat(name, &hbuf))
  		error("Cannot get status of %s.",
  			(np = strrchr(name, '/')) ? np+1 : name);
  
   version using PATH from: seismo!gregc@@ucsf-cgl.ARPA (Greg Couch) */


/*
 * The problem with   #include	<sys/param.h>   is that this include file
 * does not exist on all systems, and moreover, that it sometimes includes
 * <sys/types.h> again, so that the compiler sees these typedefs twice.
 */
#define		MAXPATHLEN	1024

a164 2
char *p, *np, *path;
char filename[MAXPATHLEN+1];
d190 3
a192 1
uptodate(fd) {
d205 4
a208 2
veryold(fd) {
	register int i;
d238 1
d241 2
a242 2
      extern int hackpid, locknum;
	register int i = 0, fd;
d248 1
a248 1
		register int errnosv = errno;
d307 1
a307 1
}	
a340 1
#include	"def.mkroom.h"
d345 3
a347 1
getmailstatus() {
d360 3
a362 1
ckmailstatus() {
d384 3
a386 1
newmail() {
d388 2
a389 2
	register struct obj *obj;
	register struct monst *md;
d391 1
a391 1
	extern struct obj *mksobj(), *addinv();
d415 2
a416 3
mdrush(md,away)
register struct monst *md;
boolean away;
d418 1
a418 1
	register int uroom = inroom(u.ux, u.uy);
d420 3
a422 3
		register int tmp = rooms[uroom].fdoor;
		register int cnt = rooms[uroom].doorct;
		register int fx = u.ux, fy = u.uy;
d437 1
a437 1
			register int dx,dy,nfx = fx,nfy = fy,d1,d2;
d467 3
a469 1
readmail() {
d471 1
a471 1
	register char *mr = 0;
d488 3
a490 2
regularize(s)	/* normalize file name - we don't like ..'s or /'s */
register char *s;
d492 1
a492 1
	register char *lp;
@


1.11
log
@2451 lines of strdup/sprintf/strcpy whacking.  mostly ok'd by pjanzen
already, but he may have later changes to make still.
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.unix.c,v 1.10 2003/03/16 21:22:36 camield Exp $	*/
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.unix.c,v 1.10 2003/03/16 21:22:36 camield Exp $";
d172 2
a173 1
register char *np, *path;
d175 5
a179 2
	if (strchr(name, '/') != NULL || (path = getenv("PATH")) == NULL)
		path = "";
d182 3
a184 3
		if ((np = strchr(path, ':')) == NULL)
			np = path + strlen(path);	/* point to end str */
		if (np - path <= 1)			/* %% */
d186 7
a192 4
		else {
			(void) strncpy(filename, path, np - path);
			filename[np - path] = '/';
			(void) strcpy(filename + (np - path) + 1, name);
a193 5
		if (stat(filename, &hbuf) == 0)
			return;
		if (*np == '\0')
			break;
		path = np + 1;
d196 2
a197 1
		(np = strrchr(name, '/')) ? np+1 : name);
@


1.10
log
@hack is free

Thanks to Andries Brouwer, Jay Fenlason and the folks at CWI for their
efforts.

http://www.cwi.nl/~aeb/games/hack/hack.html

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.unix.c,v 1.9 2002/12/06 21:48:51 millert Exp $	*/
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.unix.c,v 1.9 2002/12/06 21:48:51 millert Exp $";
d181 1
a181 1
			(void) strcpy(filename, name);
@


1.9
log
@Replace things like srandom(time(NULL)) with srandomdev(3).  random(3)
good enough for games but we should at least use a decent seed.
pjanzen@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.unix.c,v 1.8 2001/08/06 22:59:13 pjanzen Exp $	*/
d4 58
a61 1
 * Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985.
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.unix.c,v 1.8 2001/08/06 22:59:13 pjanzen Exp $";
@


1.8
log
@Nothing but comments after #endif and #else; heko@@iki.fi
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.unix.c,v 1.7 2001/01/28 23:41:46 niklas Exp $	*/
d8 1
a8 1
static char rcsid[] = "$OpenBSD: hack.unix.c,v 1.7 2001/01/28 23:41:46 niklas Exp $";
d39 1
a39 1
 	(void) srandom((int) time ((time_t *) 0));
@


1.7
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d8 1
a8 1
static char rcsid[] = "$OpenBSD: hack.unix.c,v 1.4 1996/02/06 22:47:25 jtc Exp $";
d32 1
a32 1
#endif BSD
d300 1
a300 1
#endif PERMANENT_MAILBOX
d308 1
a308 1
#endif MAILCKFREQ
d318 1
a318 1
#endif PERMANENT_MAILBOX
d418 1
a418 1
#else DEF_MAILREADER
d420 1
a420 1
#endif DEF_MAILREADER
d425 1
a425 1
#endif MAIL
@


1.6
log
@use O_* defines for open(2) flags and include fcntl.h
@
text
@d1 2
d8 1
a8 1
static char rcsid[] = "$NetBSD: hack.unix.c,v 1.4 1996/02/06 22:47:25 jtc Exp $";
@


1.5
log
@o Fix Y2K buffer overflow.
o Fix zero filling bug in all years % 100 < 10.
@
text
@d220 1
a220 1
		if((fd = open(lock, 0)) == -1) {
@


1.4
log
@r?index -> strr?chr
@
text
@d61 2
a62 4
	(void) sprintf(datestr, "%2d%2d%2d",
		lt->tm_year, lt->tm_mon + 1, lt->tm_mday);
	if(datestr[2] == ' ') datestr[2] = '0';
	if(datestr[4] == ' ') datestr[4] = '0';
@


1.3
log
@fixed the "/* in comments" problem.
@
text
@d22 1
a22 1
#include "hack.h"	/* mainly for index() which depends on BSD */
d103 1
a103 1
  			(np = rindex(name, '/')) ? np+1 : name);
d117 1
a117 1
	if (index(name, '/') != NULL || (path = getenv("PATH")) == NULL)
d121 1
a121 1
		if ((np = index(path, ':')) == NULL)
d137 1
a137 1
		(np = rindex(name, '/')) ? np+1 : name);
d432 1
a432 1
	while((lp = index(s, '.')) || (lp = index(s, '/')))
@


1.2
log
@From netbsd:
Removed "extern int errno"; Added #include <errno.h> if not already present.
@
text
@d100 6
a105 6
/* register char *np;
/*	if(stat(name, &hbuf))
/*		error("Cannot get status of %s.",
/*			(np = rindex(name, '/')) ? np+1 : name);
/*
/* version using PATH from: seismo!gregc@@ucsf-cgl.ARPA (Greg Couch) */
d169 2
a170 2
		/* This will work on 4.1cbsd, 4.2bsd and system 3? & 5.
		/* It will do nothing on V7 or 4.1bsd. */
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
static char rcsid[] = "$NetBSD: hack.unix.c,v 1.3 1995/03/23 08:31:55 cgd Exp $";
a160 1
		extern int errno;
d186 1
a186 1
	extern int errno, hackpid, locknum;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
