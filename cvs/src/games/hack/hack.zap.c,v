head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.10
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.8
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.26
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.18
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.22
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.20
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.16
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.14
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.12
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.10
	OPENBSD_5_0:1.10.0.8
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.6
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.22
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.18
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.16
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.14
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.12
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.10
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.8
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.16
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.14
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.01.09.18.33.15;	author mestre;	state Exp;
branches;
next	1.10;
commitid	cGEyAVlKS2f51J9L;

1.10
date	2009.10.27.23.59.25;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.17.21.07.26;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.19.09.00.54;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.19.06.30.56;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.07.09.48.57;	author tdeval;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.16.21.22.36;	author camield;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.06.22.59.13;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.28.23.41.46;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.01.17.07.11.39;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.02;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.11
log
@This diff is rather large, but it's just simply removing unnecessary headers
, remove some lint-style comments, add missing void to functions without args,
also some function prototypes (extern) were missing their args, so I added them
as they were defined in hack.h

OK tb@@ on separate diffs
@
text
@/*	$OpenBSD: hack.zap.c,v 1.10 2009/10/27 23:59:25 deraadt Exp $	*/

/*
 * Copyright (c) 1985, Stichting Centrum voor Wiskunde en Informatica,
 * Amsterdam
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * - Neither the name of the Stichting Centrum voor Wiskunde en
 * Informatica, nor the names of its contributors may be used to endorse or
 * promote products derived from this software without specific prior
 * written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982 Jay Fenlason <hack@@gnu.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdlib.h>

#include "hack.h"

extern struct monst youmonst;

char *fl[]= {
	"magic missile",
	"bolt of fire",
	"sleep ray",
	"bolt of cold",
	"death ray"
};

static char dirlet(int, int);
static int  zhit(struct monst *, int);
static boolean revive(struct obj *);
static void rloco(struct obj *);
static void burn_scrolls(void);

/* Routines for IMMEDIATE wands. */
/* bhitm: monster mtmp was hit by the effect of wand otmp */
void
bhitm(struct monst *mtmp, struct obj *otmp)
{
	wakeup(mtmp);
	switch(otmp->otyp) {
	case WAN_STRIKING:
		if(u.uswallow || rnd(20) < 10+mtmp->data->ac) {
			int tmp = d(2,12);
			hit("wand", mtmp, exclam(tmp));
			mtmp->mhp -= tmp;
			if(mtmp->mhp < 1) killed(mtmp);
		} else miss("wand", mtmp);
		break;
	case WAN_SLOW_MONSTER:
		mtmp->mspeed = MSLOW;
		break;
	case WAN_SPEED_MONSTER:
		mtmp->mspeed = MFAST;
		break;
	case WAN_UNDEAD_TURNING:
		if(strchr(UNDEAD,mtmp->data->mlet)) {
			mtmp->mhp -= rnd(8);
			if(mtmp->mhp < 1) killed(mtmp);
			else mtmp->mflee = 1;
		}
		break;
	case WAN_POLYMORPH:
		if( newcham(mtmp,&mons[rn2(CMNUM)]) )
			objects[otmp->otyp].oc_name_known = 1;
		break;
	case WAN_CANCELLATION:
		mtmp->mcan = 1;
		break;
	case WAN_TELEPORTATION:
		rloc(mtmp);
		break;
	case WAN_MAKE_INVISIBLE:
		mtmp->minvis = 1;
		break;
#ifdef WAN_PROBING
	case WAN_PROBING:
		mstatusline(mtmp);
		break;
#endif /* WAN_PROBING */
	default:
		impossible("What an interesting wand (%u)", otmp->otyp);
	}
}

/* returns TRUE if sth was done */
/* object obj was hit by the effect of wand otmp */
boolean
bhito(struct obj *obj, struct obj *otmp)
{
	int res = TRUE;

	if(obj == uball || obj == uchain)
		res = FALSE;
	else
	switch(otmp->otyp) {
	case WAN_POLYMORPH:
		/* preserve symbol and quantity, but turn rocks into gems */
		mkobj_at((obj->otyp == ROCK || obj->otyp == ENORMOUS_ROCK)
			? GEM_SYM : obj->olet,
			obj->ox, obj->oy) -> quan = obj->quan;
		delobj(obj);
		break;
	case WAN_STRIKING:
		if(obj->otyp == ENORMOUS_ROCK)
			fracture_rock(obj);
		else
			res = FALSE;
		break;
	case WAN_CANCELLATION:
		if(obj->spe && obj->olet != AMULET_SYM) {
			obj->known = 0;
			obj->spe = 0;
		}
		break;
	case WAN_TELEPORTATION:
		rloco(obj);
		break;
	case WAN_MAKE_INVISIBLE:
		obj->oinvis = 1;
		break;
	case WAN_UNDEAD_TURNING:
		res = revive(obj);
		break;
	case WAN_SLOW_MONSTER:		/* no effect on objects */
	case WAN_SPEED_MONSTER:
#ifdef WAN_PROBING
	case WAN_PROBING:
#endif /* WAN_PROBING */
		res = FALSE;
		break;
	default:
		impossible("What an interesting wand (%u)", otmp->otyp);
	}
	return(res);
}

int
dozap(void)
{
	struct obj *obj;
	xchar zx,zy;

	obj = getobj("/", "zap");
	if(!obj) return(0);
	if(obj->spe < 0 || (obj->spe == 0 && rn2(121))) {
		pline("Nothing Happens.");
		return(1);
	}
	if(obj->spe == 0)
		pline("You wrest one more spell from the worn-out wand.");
	if(!(objects[obj->otyp].bits & NODIR) && !getdir(1))
		return(1);	/* make him pay for knowing !NODIR */
	obj->spe--;
	if(objects[obj->otyp].bits & IMMEDIATE) {
		if(u.uswallow)
			bhitm(u.ustuck, obj);
		else if(u.dz) {
			if(u.dz > 0) {
				struct obj *otmp = o_at(u.ux, u.uy);
				if(otmp)
					(void) bhito(otmp, obj);
			}
		} else
			(void) bhit(u.dx,u.dy,rn1(8,6),0,bhitm,bhito,obj);
	} else {
	    switch(obj->otyp){
		case WAN_LIGHT:
			litroom(TRUE);
			break;
		case WAN_SECRET_DOOR_DETECTION:
			if(!findit()) return(1);
			break;
		case WAN_CREATE_MONSTER:
			{ int cnt = 1;
			if(!rn2(23)) cnt += rn2(7) + 1;
			while(cnt--)
			    (void) makemon((struct permonst *) 0, u.ux, u.uy);
			}
			break;
		case WAN_WISHING:
			{ char buf[BUFSZ];
			  struct obj *otmp;
		      if(u.uluck + rn2(5) < 0) {
			pline("Unfortunately, nothing happens.");
			break;
		      }
		      pline("You may wish for an object. What do you want? ");
		      getlin(buf);
		      if(buf[0] == '\033') buf[0] = 0;
		      otmp = readobjnam(buf, sizeof buf);
		      otmp = addinv(otmp);
		      prinv(otmp);
		      break;
			}
		case WAN_DIGGING:
			/* Original effect (approximately):
			 * from CORR: dig until we pierce a wall
			 * from ROOM: piece wall and dig until we reach
			 * an ACCESSIBLE place.
			 * Currently: dig for digdepth positions;
			 * also down on request of Lennart Augustsson.
			 */
			{ struct rm *room;
			  int digdepth;
			if(u.uswallow) {
				struct monst *mtmp = u.ustuck;

				pline("You pierce %s's stomach wall!",
					monnam(mtmp));
				mtmp->mhp = 1;	/* almost dead */
				unstuck(mtmp);
				mnexto(mtmp);
				break;
			}
			if(u.dz) {
			    if(u.dz < 0) {
				pline("You loosen a rock from the ceiling.");
				pline("It falls on your head!");
				losehp(1, "falling rock");
				mksobj_at(ROCK, u.ux, u.uy);
				fobj->quan = 1;
				stackobj(fobj);
				if(Invisible) newsym(u.ux, u.uy);
			    } else {
				dighole();
			    }
			    break;
			}
			zx = u.ux+u.dx;
			zy = u.uy+u.dy;
			digdepth = 8 + rn2(18);
			Tmp_at(-1, '*');	/* open call */
			while(--digdepth >= 0) {
				if(!isok(zx,zy)) break;
				room = &levl[(int)zx][(int)zy];
				Tmp_at(zx,zy);
				if(!xdnstair){
					if(zx < 3 || zx > COLNO-3 ||
					    zy < 3 || zy > ROWNO-3)
						break;
					if(room->typ == HWALL ||
					    room->typ == VWALL){
						room->typ = ROOM;
						break;
					}
				} else
				if(room->typ == HWALL || room->typ == VWALL ||
				   room->typ == SDOOR || room->typ == LDOOR){
					room->typ = DOOR;
					digdepth -= 2;
				} else
				if(room->typ == SCORR || !room->typ) {
					room->typ = CORR;
					digdepth--;
				}
				mnewsym(zx,zy);
				zx += u.dx;
				zy += u.dy;
			}
			mnewsym(zx,zy);	/* not always necessary */
			Tmp_at(-1,-1);	/* closing call */
			break;
			}
		default:
			buzz((int) obj->otyp - WAN_MAGIC_MISSILE,
				u.ux, u.uy, u.dx, u.dy);
			break;
		}
		if(!objects[obj->otyp].oc_name_known) {
			objects[obj->otyp].oc_name_known = 1;
			more_experienced(0,10);
		}
	}
	return(1);
}

char *
exclam(int force)
{
	/* force == 0 occurs e.g. with sleep ray */
	/* note that large force is usual with wands so that !! would
	 *	require information about hand/weapon/wand
	 */
	return( (force < 0) ? "?" : (force <= 4) ? "." : "!" );
}

/* force is usually either "." or "!" */
void
hit(char *str, struct monst *mtmp, char *force)
{
	if(!cansee(mtmp->mx,mtmp->my)) pline("The %s hits it.", str);
	else pline("The %s hits %s%s", str, monnam(mtmp), force);
}

void
miss(char *str, struct monst *mtmp)
{
	if(!cansee(mtmp->mx,mtmp->my)) pline("The %s misses it.",str);
	else pline("The %s misses %s.",str,monnam(mtmp));
}

/* bhit: called when a weapon is thrown (sym = obj->olet) or when an
 * IMMEDIATE wand is zapped (sym = 0); the weapon falls down at end of
 * range or when a monster is hit; the monster is returned, and bhitpos
 * is set to the final position of the weapon thrown; the ray of a wand
 * may affect several objects and monsters on its path - for each of
 * these an argument function is called. */
/* check !u.uswallow before calling bhit() */

/*
 * int ddx,ddy,range;		direction and range
 * char sym;				symbol displayed on path
 * int (*fhitm)(), (*fhito)();		fns called when mon/obj hit
 * struct obj *obj;			2nd arg to fhitm/fhito
 * struct monst *
 */
struct monst *
bhit(int ddx, int ddy, int range, char sym,
    void (*fhitm)(struct monst *, struct obj *),
    boolean (*fhito)(struct obj *, struct obj *),
    struct obj *obj)
{
	struct monst *mtmp;
	struct obj *otmp;
	int typ;

	bhitpos.x = u.ux;
	bhitpos.y = u.uy;

	if(sym) tmp_at(-1, sym);	/* open call */
	while(range-- > 0) {
		bhitpos.x += ddx;
		bhitpos.y += ddy;
		typ = levl[(int)bhitpos.x][(int)bhitpos.y].typ;
		if ((mtmp = m_at(bhitpos.x,bhitpos.y))) {
			if(sym) {
				tmp_at(-1, -1);	/* close call */
				return(mtmp);
			}
			if (fhitm)
				(*fhitm)(mtmp, obj);
			range -= 3;
		}
		if ((otmp = o_at(bhitpos.x,bhitpos.y))){
			if(fhito && (*fhito)(otmp, obj))
				range--;
		}
		if (!ZAP_POS(typ)) {
			bhitpos.x -= ddx;
			bhitpos.y -= ddy;
			break;
		}
		if(sym) tmp_at(bhitpos.x, bhitpos.y);
	}

	/* leave last symbol unless in a pool */
	if(sym)
	   tmp_at(-1, (levl[(int)bhitpos.x][(int)bhitpos.y].typ == POOL) ? -1 : 0);
	return(NULL);
}

struct monst *
boomhit(int dx, int dy)
{
	int i, ct;
	struct monst *mtmp;
	char sym = ')';
	extern schar xdir[], ydir[];

	bhitpos.x = u.ux;
	bhitpos.y = u.uy;

	for(i=0; i<8; i++) if(xdir[i] == dx && ydir[i] == dy) break;
	tmp_at(-1, sym);	/* open call */
	for(ct=0; ct<10; ct++) {
		if(i == 8) i = 0;
		sym = ')' + '(' - sym;
		tmp_at(-2, sym);	/* change let call */
		dx = xdir[i];
		dy = ydir[i];
		bhitpos.x += dx;
		bhitpos.y += dy;
		if ((mtmp = m_at(bhitpos.x, bhitpos.y))) {
			tmp_at(-1,-1);
			return(mtmp);
		}
		if (!ZAP_POS(levl[(int)bhitpos.x][(int)bhitpos.y].typ)) {
			bhitpos.x -= dx;
			bhitpos.y -= dy;
			break;
		}
		if (bhitpos.x == u.ux && bhitpos.y == u.uy) { /* ct == 9 */
			if(rn2(20) >= 10+u.ulevel){	/* we hit ourselves */
				(void) thitu(10, rnd(10), "boomerang");
				break;
			} else {	/* we catch it */
				tmp_at(-1,-1);
				pline("Skillfully, you catch the boomerang.");
				return(&youmonst);
			}
		}
		tmp_at(bhitpos.x, bhitpos.y);
		if(ct % 5 != 0) i++;
	}
	tmp_at(-1, -1);	/* do not leave last symbol */
	return(0);
}

static char
dirlet(int dx, int dy)
{
	return (dx == dy) ? '\\' : (dx && dy) ? '/' : dx ? '-' : '|';
}

/* type == -1: monster spitting fire at you */
/* type == -1,-2,-3: bolts sent out by wizard */
/* called with dx = dy = 0 with vertical bolts */
void
buzz(int type, xchar sx, xchar sy, int dx, int dy)
{
	int abstype = abs(type);
	char *fltxt = (type == -1) ? "blaze of fire" : fl[abstype];
	struct rm *lev;
	xchar range;
	struct monst *mon;

	if(u.uswallow) {
		int tmp;

		if(type < 0) return;
		tmp = zhit(u.ustuck, type);
		pline("The %s rips into %s%s",
			fltxt, monnam(u.ustuck), exclam(tmp));
		return;
	}
	if(type < 0) pru();
	range = rn1(7,7);
	Tmp_at(-1, dirlet(dx,dy));	/* open call */
	while(range-- > 0) {
		sx += dx;
		sy += dy;
		if ((lev = &levl[(int)sx][(int)sy])->typ)
			Tmp_at(sx,sy);
		else {
			int bounce = 0;
			if (cansee(sx-dx,sy-dy))
				pline("The %s bounces!", fltxt);
			if (ZAP_POS(levl[(int)sx][sy-dy].typ))
				bounce = 1;
			if (ZAP_POS(levl[sx-dx][(int)sy].typ)) {
				if(!bounce || rn2(2))
					bounce = 2;
			}
			switch(bounce){
			case 0:
				dx = -dx;
				dy = -dy;
				continue;
			case 1:
				dy = -dy;
				sx -= dx;
				break;
			case 2:
				dx = -dx;
				sy -= dy;
				break;
			}
			Tmp_at(-2,dirlet(dx,dy));
			continue;
		}
		if(lev->typ == POOL && abstype == 1 /* fire */) {
			range -= 3;
			lev->typ = ROOM;
			if(cansee(sx,sy)) {
				mnewsym(sx,sy);
				pline("The water evaporates.");
			} else
				pline("You hear a hissing sound.");
		}
		if((mon = m_at(sx,sy)) &&
		   (type != -1 || mon->data->mlet != 'D')) {
			wakeup(mon);
			if(rnd(20) < 18 + mon->data->ac) {
				int tmp = zhit(mon,abstype);
				if(mon->mhp < 1) {
					if(type < 0) {
					    if(cansee(mon->mx,mon->my))
					      pline("%s is killed by the %s!",
						Monnam(mon), fltxt);
					    mondied(mon);
					} else
					    killed(mon);
				} else
					hit(fltxt, mon, exclam(tmp));
				range -= 2;
			} else
				miss(fltxt,mon);
		} else if(sx == u.ux && sy == u.uy) {
			nomul(0);
			if(rnd(20) < 18+u.uac) {
				int dam = 0;
				range -= 2;
				pline("The %s hits you!",fltxt);
				switch(abstype) {
				case 0:
					dam = d(2,6);
					break;
				case 1:
					if(Fire_resistance)
						pline("You don't feel hot!");
					else dam = d(6,6);
					if(!rn2(3))
						burn_scrolls();
					break;
				case 2:
					nomul(-rnd(25)); /* sleep ray */
					break;
				case 3:
					if(Cold_resistance)
						pline("You don't feel cold!");
					else dam = d(6,6);
					break;
				case 4:
					u.uhp = -1;
				}
				losehp(dam,fltxt);
			} else pline("The %s whizzes by you!",fltxt);
			stop_occupation();
		}
		if(!ZAP_POS(lev->typ)) {
			int bounce = 0, rmn;
			if(cansee(sx,sy)) pline("The %s bounces!",fltxt);
			range--;
			if(!dx || !dy || !rn2(20)){
				dx = -dx;
				dy = -dy;
			} else {
			  if(ZAP_POS(rmn = levl[(int)sx][sy-dy].typ) &&
			    (IS_ROOM(rmn) || ZAP_POS(levl[sx+dx][sy-dy].typ)))
				bounce = 1;
			  if(ZAP_POS(rmn = levl[sx-dx][(int)sy].typ) &&
			    (IS_ROOM(rmn) || ZAP_POS(levl[sx-dx][sy+dy].typ)))
				if(!bounce || rn2(2))
					bounce = 2;

			  switch(bounce){
			  case 0:
				dy = -dy;
				dx = -dx;
				break;
			  case 1:
				dy = -dy;
				break;
			  case 2:
				dx = -dx;
				break;
			  }
			  Tmp_at(-2, dirlet(dx,dy));
			}
		}
	}
	Tmp_at(-1,-1);
}

/* returns damage to mon */
static int
zhit(struct monst *mon, int type)
{
	int tmp = 0;

	switch(type) {
	case 0:			/* magic missile */
		tmp = d(2,6);
		break;
	case -1:		/* Dragon blazing fire */
	case 1:			/* fire */
		if(strchr("Dg", mon->data->mlet)) break;
		tmp = d(6,6);
		if(strchr("YF", mon->data->mlet)) tmp += 7;
		break;
	case 2:			/* sleep*/
		mon->mfroz = 1;
		break;
	case 3:			/* cold */
		if(strchr("YFgf", mon->data->mlet)) break;
		tmp = d(6,6);
		if(mon->data->mlet == 'D') tmp += 7;
		break;
	case 4:			/* death*/
		if(strchr(UNDEAD, mon->data->mlet)) break;
		tmp = mon->mhp+1;
		break;
	}
	mon->mhp -= tmp;
	return(tmp);
}

#define	CORPSE_I_TO_C(otyp)	(char) ((otyp >= DEAD_ACID_BLOB)\
		     ?  'a' + (otyp - DEAD_ACID_BLOB)\
		     :	'@@' + (otyp - DEAD_HUMAN))

static boolean
revive(struct obj *obj)
{
	struct monst *mtmp;

	if(obj->olet == FOOD_SYM && obj->otyp > CORPSE) {
		/* do not (yet) revive shopkeepers */
		/* Note: this might conceivably produce two monsters
			at the same position - strange, but harmless */
		mtmp = mkmon_at(CORPSE_I_TO_C(obj->otyp),obj->ox,obj->oy);
		delobj(obj);
	}
	return(!!mtmp);		/* TRUE if some monster created */
}

static void
rloco(struct obj *obj)
{
	int tx,ty,otx,oty;

	otx = obj->ox;
	oty = obj->oy;
	do {
		tx = rn1(COLNO-3,2);
		ty = rn2(ROWNO);
	} while(!goodpos(tx,ty));
	obj->ox = tx;
	obj->oy = ty;
	if(cansee(otx,oty))
		newsym(otx,oty);
}

/* fractured by pick-axe or wand of striking */
void
fracture_rock(struct obj *obj)
{
	/* unpobj(obj); */
	obj->otyp = ROCK;
	obj->quan = 7 + rn2(60);
	obj->owt = weight(obj);
	obj->olet = WEAPON_SYM;
	if(cansee(obj->ox,obj->oy))
		prl(obj->ox,obj->oy);
}

static void
burn_scrolls(void)
{
	struct obj *obj, *obj2;
	int cnt = 0;

	for(obj = invent; obj; obj = obj2) {
		obj2 = obj->nobj;
		if(obj->olet == SCROLL_SYM) {
			cnt++;
			useup(obj);
		}
	}
	if(cnt > 1) {
		pline("Your scrolls catch fire!");
		losehp(cnt, "burning scrolls");
	} else if(cnt) {
		pline("Your scroll catches fire!");
		losehp(1, "burning scroll");
	}
}
@


1.10
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.zap.c,v 1.9 2004/09/17 21:07:26 mickey Exp $	*/
d65 1
d188 1
a188 1
dozap()
d698 1
a698 1
burn_scrolls()
@


1.9
log
@dothrow() calls bhit() w/ both null hit functions thus have to check before calling those; from Juha Erkkila <erkkila@@cc.jyu.fi>; pr3923
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.zap.c,v 1.8 2003/05/19 09:00:54 pjanzen Exp $	*/
a62 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: hack.zap.c,v 1.8 2003/05/19 09:00:54 pjanzen Exp $";
#endif /* not lint */
@


1.8
log
@A few more includes discovered in a -fno-builtin compile
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.zap.c,v 1.7 2003/05/19 06:30:56 pjanzen Exp $	*/
d65 1
a65 1
static const char rcsid[] = "$OpenBSD: hack.zap.c,v 1.7 2003/05/19 06:30:56 pjanzen Exp $";
d393 2
a394 1
			(*fhitm)(mtmp, obj);
d398 1
a398 1
			if((*fhito)(otmp, obj))
@


1.7
log
@De-register, ANSIfy, clean up.
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.zap.c,v 1.6 2003/05/07 09:48:57 tdeval Exp $	*/
d65 1
a65 1
static const char rcsid[] = "$OpenBSD$";
d68 1
@


1.6
log
@Major strings rework.  Ok pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.zap.c,v 1.5 2003/03/16 21:22:36 camield Exp $	*/
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.zap.c,v 1.5 2003/03/16 21:22:36 camield Exp $";
d70 1
a70 4
extern struct obj *mkobj_at();
extern struct monst *makemon(), *mkmon_at(), youmonst;
struct monst *bhit();
char *exclam();
d80 6
d88 2
a89 3
bhitm(mtmp, otmp)
register struct monst *mtmp;
register struct obj *otmp;
d95 1
a95 1
			register int tmp = d(2,12);
d137 4
a140 2
bhito(obj, otmp)	/* object obj was hit by the effect of wand otmp */
register struct obj *obj, *otmp;	/* returns TRUE if sth was done */
d142 1
a142 1
	register int res = TRUE;
d189 1
d192 1
a192 1
	register struct obj *obj;
d211 1
a211 1
				register struct obj *otmp = o_at(u.ux, u.uy);
d226 1
a226 1
			{ register int cnt = 1;
d234 1
a234 2
			  register struct obj *otmp;
			  extern struct obj *readobjnam(), *addinv();
d255 2
a256 2
			{ register struct rm *room;
			  register int digdepth;
d258 1
a258 1
				register struct monst *mtmp = u.ustuck;
d287 1
a287 1
				room = &levl[zx][zy];
d330 1
a330 2
exclam(force)
register int force;
d334 2
a335 1
		require information about hand/weapon/wand */
d339 3
a341 4
hit(str,mtmp,force)
register char *str;
register struct monst *mtmp;
register char *force;		/* usually either "." or "!" */
d347 2
a348 3
miss(str,mtmp)
register char *str;
register struct monst *mtmp;
d355 5
a359 5
   IMMEDIATE wand is zapped (sym = 0); the weapon falls down at end of
   range or when a monster is hit; the monster is returned, and bhitpos
   is set to the final position of the weapon thrown; the ray of a wand
   may affect several objects and monsters on its path - for each of
   these an argument function is called. */
d362 7
d370 8
a377 9
bhit(ddx,ddy,range,sym,fhitm,fhito,obj)
register int ddx,ddy,range;		/* direction and range */
char sym;				/* symbol displayed on path */
int (*fhitm)(), (*fhito)();		/* fns called when mon/obj hit */
struct obj *obj;			/* 2nd arg to fhitm/fhito */
{
	register struct monst *mtmp;
	register struct obj *otmp;
	register int typ;
d386 2
a387 2
		typ = levl[bhitpos.x][bhitpos.y].typ;
		if(mtmp = m_at(bhitpos.x,bhitpos.y)){
d395 1
a395 1
		if(fhito && (otmp = o_at(bhitpos.x,bhitpos.y))){
d399 1
a399 1
		if(!ZAP_POS(typ)) {
d409 2
a410 2
	   tmp_at(-1, (levl[bhitpos.x][bhitpos.y].typ == POOL) ? -1 : 0);
	return(0);
d414 4
a417 3
boomhit(dx,dy) {
	register int i, ct;
	register struct monst *mtmp;
d434 1
a434 1
		if(mtmp = m_at(bhitpos.x, bhitpos.y)){
d438 1
a438 1
		if(!ZAP_POS(levl[bhitpos.x][bhitpos.y].typ)) {
d443 1
a443 1
		if(bhitpos.x == u.ux && bhitpos.y == u.uy) { /* ct == 9 */
d460 4
a463 4
char
dirlet(dx,dy) register dx,dy; {
	return
		(dx == dy) ? '\\' : (dx && dy) ? '/' : dx ? '-' : '|';
d469 2
a470 4
buzz(type,sx,sy,dx,dy)
register int type;
register xchar sx,sy;
register int dx,dy;
d473 1
a473 1
	register char *fltxt = (type == -1) ? "blaze of fire" : fl[abstype];
d479 1
a479 1
		register int tmp;
d493 2
a494 1
		if((lev = &levl[sx][sy])->typ) Tmp_at(sx,sy);
d497 1
a497 1
			if(cansee(sx-dx,sy-dy))
d499 1
a499 1
			if(ZAP_POS(levl[sx][sy-dy].typ))
d501 3
a503 2
			if(ZAP_POS(levl[sx-dx][sy].typ)) {
				if(!bounce || rn2(2)) bounce = 2;
d535 1
a535 1
				register int tmp = zhit(mon,abstype);
d552 1
a552 1
				register int dam = 0;
d589 1
a589 1
			  if(ZAP_POS(rmn = levl[sx][sy-dy].typ) &&
d592 1
a592 1
			  if(ZAP_POS(rmn = levl[sx-dx][sy].typ) &&
d616 3
a618 3
zhit(mon,type)			/* returns damage to mon */
register struct monst *mon;
register type;
d620 1
a620 1
	register int tmp = 0;
d652 3
a654 2
revive(obj)
register struct obj *obj;
d656 1
a656 1
	register struct monst *mtmp;
d668 2
a669 2
rloco(obj)
register struct obj *obj;
d671 1
a671 1
	register tx,ty,otx,oty;
d685 3
a687 2
fracture_rock(obj)	/* fractured by pick-axe or wand of striking */
register struct obj *obj;			   /* no texts here! */
d698 1
d701 2
a702 2
	register struct obj *obj, *obj2;
	register int cnt = 0;
@


1.5
log
@hack is free

Thanks to Andries Brouwer, Jay Fenlason and the folks at CWI for their
efforts.

http://www.cwi.nl/~aeb/games/hack/hack.html

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.zap.c,v 1.4 2001/08/06 22:59:13 pjanzen Exp $	*/
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.zap.c,v 1.4 2001/08/06 22:59:13 pjanzen Exp $";
d238 1
a238 1
		      otmp = readobjnam(buf);
@


1.4
log
@Nothing but comments after #endif and #else; heko@@iki.fi
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.zap.c,v 1.3 2001/01/28 23:41:46 niklas Exp $	*/
d4 58
a61 1
 * Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985.
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.zap.c,v 1.3 2001/01/28 23:41:46 niklas Exp $";
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d8 1
a8 1
static char rcsid[] = "$OpenBSD: hack.zap.c,v 1.3 1995/03/23 08:32:21 cgd Exp $";
d72 1
a72 1
#endif WAN_PROBING
d119 1
a119 1
#endif WAN_PROBING
@


1.2
log
@r?index -> strr?chr
@
text
@d1 2
d8 1
a8 1
static char rcsid[] = "$NetBSD: hack.zap.c,v 1.3 1995/03/23 08:32:21 cgd Exp $";
@


1.1
log
@Initial revision
@
text
@d47 1
a47 1
		if(index(UNDEAD,mtmp->data->mlet)) {
d560 1
a560 1
		if(index("Dg", mon->data->mlet)) break;
d562 1
a562 1
		if(index("YF", mon->data->mlet)) tmp += 7;
d568 1
a568 1
		if(index("YFgf", mon->data->mlet)) break;
d573 1
a573 1
		if(index(UNDEAD, mon->data->mlet)) break;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
