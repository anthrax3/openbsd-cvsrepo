head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.6
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.4
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.12.0.8
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.20
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.16
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.9.0.28
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.24
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.22
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.20
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.18
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.16
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.14
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.16
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.14
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.01.09.21.54.11;	author mestre;	state Exp;
branches;
next	1.15;
commitid	ve4zhTqqRMMVn77Z;

1.15
date	2016.01.09.18.33.15;	author mestre;	state Exp;
branches;
next	1.14;
commitid	cGEyAVlKS2f51J9L;

1.14
date	2015.12.16.14.21.50;	author tb;	state Exp;
branches;
next	1.13;
commitid	47lKFCMHfkqci7HY;

1.13
date	2015.10.24.18.26.13;	author mmcc;	state Exp;
branches;
next	1.12;
commitid	sNqoeOxu3kMCC7lD;

1.12
date	2014.03.11.08.05.15;	author guenther;	state Exp;
branches;
next	1.11;

1.11
date	2009.12.10.23.53.07;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.27.23.59.25;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.06.02.07.45;	author avsm;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.19.06.30.56;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.07.09.48.57;	author tdeval;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.06.18.50.37;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.16.21.22.35;	author camield;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.06.22.59.13;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.28.23.41.43;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.01.17.07.11.08;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.59;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.59;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Remove several casts to (char *) 0 and replace them by NULL

Prompted and OK by tb@@
@
text
@/*	$OpenBSD: hack.end.c,v 1.15 2016/01/09 18:33:15 mestre Exp $	*/

/*
 * Copyright (c) 1985, Stichting Centrum voor Wiskunde en Informatica,
 * Amsterdam
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * - Neither the name of the Stichting Centrum voor Wiskunde en
 * Informatica, nor the names of its contributors may be used to endorse or
 * promote products derived from this software without specific prior
 * written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982 Jay Fenlason <hack@@gnu.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

#include "hack.h"

#define newttentry() (struct toptenentry *) alloc(sizeof(struct toptenentry))
#define	NAMSZ	8
#define	DTHSZ	40
#define	PERSMAX	1
#define	POINTSMIN	1	/* must be > 0 */
#define	ENTRYMAX	100	/* must be >= 10 */
#define	PERS_IS_UID		/* delete for PERSMAX per name; now per uid */

extern char plname[], pl_character[];

xchar maxdlevel = 1;

struct toptenentry {
	struct toptenentry *tt_next;
	long int points;
	int level,maxlvl,hp,maxhp;
	int uid;
	char plchar;
	char sex;
	char name[NAMSZ+1];
	char death[DTHSZ+1];
	char date[7];		/* yymmdd */
} *tt_head;

static void topten(void);
static void outheader(void);
static int  outentry(int, struct toptenentry *, int);
static char *itoa(int);
static char *ordin(int);

void
done1(int notused)
{
	(void) signal(SIGINT,SIG_IGN);
	pline("Really quit?");
	if(readchar() != 'y') {
		(void) signal(SIGINT,done1);
		clrlin();
		(void) fflush(stdout);
		if(multi > 0) nomul(0);
		return;
	}
	done("quit");
}

int
done2(void)
{
	done1(0);
	return(0);
}

int done_stopprint;
int done_hup;

void
done_intr(int notused)
{
	done_stopprint++;
	(void) signal(SIGINT, SIG_IGN);
	(void) signal(SIGQUIT, SIG_IGN);
}

void
done_hangup(int notused)
{
	done_hup++;
	(void) signal(SIGHUP, SIG_IGN);
	done_intr(notused);
}

void
done_in_by(struct monst *mtmp)
{
	static char buf[BUFSZ];

	pline("You die ...");
	if(mtmp->data->mlet == ' '){
		snprintf(buf, sizeof buf, "the ghost of %s", (char *) mtmp->mextra);
		killer = buf;
	} else if(mtmp->mnamelth) {
		snprintf(buf, sizeof buf, "%s called %s",
			mtmp->data->mname, NAME(mtmp));
		killer = buf;
	} else if(mtmp->minvis) {
		snprintf(buf, sizeof buf, "invisible %s", mtmp->data->mname);
		killer = buf;
	} else killer = mtmp->data->mname;
	done("died");
}

/* called with arg "died", "drowned", "escaped", "quit", "choked", "panicked",
   "burned", "starved" or "tricked" */
/* Be careful not to call panic from here! */
void
done(char *st1)
{

#ifdef WIZARD
	if(wizard && *st1 == 'd'){
		u.uswldtim = 0;
		if(u.uhpmax < 0) u.uhpmax = 100;	/* arbitrary */
		u.uhp = u.uhpmax;
		pline("For some reason you are still alive.");
		flags.move = 0;
		if(multi > 0) multi = 0; else multi = -1;
		flags.botl = 1;
		return;
	}
#endif /* WIZARD */
	(void) signal(SIGINT, done_intr);
	(void) signal(SIGQUIT, done_intr);
	(void) signal(SIGHUP, done_hangup);
	if(*st1 == 'q' && u.uhp < 1){
		st1 = "died";
		killer = "quit while already on Charon's boat";
	}
	if(*st1 == 's') killer = "starvation"; else
	if(*st1 == 'd' && st1[1] == 'r') killer = "drowning"; else
	if(*st1 == 'p') killer = "panic"; else
	if(*st1 == 't') killer = "trickery"; else
	if(!strchr("bcd", *st1)) killer = st1;
	paybill();
	clearlocks();
	if(flags.toplin == 1) more();
	if(strchr("bcds", *st1)){
#ifdef WIZARD
	    if(!wizard)
#endif /* WIZARD */
		savebones();
		if(!flags.notombstone)
			outrip();
	}
	if(*st1 == 'c') killer = st1;		/* after outrip() */
	settty(NULL);	/* does a clr_screen() */
	if(!done_stopprint)
		printf("Goodbye %s %s...\n\n", pl_character, plname);
	{ long int tmp;
	  tmp = u.ugold - u.ugold0;
	  if(tmp < 0)
		tmp = 0;
	  if(*st1 == 'd' || *st1 == 'b')
		tmp -= tmp/10;
	  u.urexp += tmp;
	  u.urexp += 50 * maxdlevel;
	  if(maxdlevel > 20)
		u.urexp += 1000*((maxdlevel > 30) ? 10 : maxdlevel - 20);
	}
	if(*st1 == 'e') {
		extern struct monst *mydogs;
		struct monst *mtmp;
		struct obj *otmp;
		int i;
		unsigned worthlessct = 0;
		boolean has_amulet = FALSE;

		killer = st1;
		keepdogs();
		mtmp = mydogs;
		if(mtmp) {
			if(!done_stopprint) printf("You");
			while(mtmp) {
				if(!done_stopprint)
					printf(" and %s", monnam(mtmp));
				if(mtmp->mtame)
					u.urexp += mtmp->mhp;
				mtmp = mtmp->nmon;
			}
			if(!done_stopprint)
		    printf("\nescaped from the dungeon with %ld points,\n",
			u.urexp);
		} else
		if(!done_stopprint)
		  printf("You escaped from the dungeon with %ld points,\n",
		    u.urexp);
		for(otmp = invent; otmp; otmp = otmp->nobj) {
			if(otmp->olet == GEM_SYM){
				objects[otmp->otyp].oc_name_known = 1;
				i = otmp->quan*objects[otmp->otyp].g_val;
				if(i == 0) {
					worthlessct += otmp->quan;
					continue;
				}
				u.urexp += i;
				if(!done_stopprint)
				  printf("\t%s (worth %d Zorkmids),\n",
				    doname(otmp), i);
			} else if(otmp->olet == AMULET_SYM) {
				otmp->known = 1;
				i = (otmp->spe < 0) ? 2 : 5000;
				u.urexp += i;
				if(!done_stopprint)
				  printf("\t%s (worth %d Zorkmids),\n",
				    doname(otmp), i);
				if(otmp->spe >= 0) {
					has_amulet = TRUE;
					killer = "escaped (with amulet)";
				}
			}
		}
		if(worthlessct) if(!done_stopprint)
		  printf("\t%u worthless piece%s of coloured glass,\n",
		  worthlessct, plur(worthlessct));
		if(has_amulet) u.urexp *= 2;
	} else
		if(!done_stopprint)
		  printf("You %s on dungeon level %d with %ld points,\n",
		    st1, dlevel, u.urexp);
	if(!done_stopprint)
	  printf("and %ld piece%s of gold, after %ld move%s.\n",
	    u.ugold, plur(u.ugold), moves, plur(moves));
	if(!done_stopprint)
  printf("You were level %u with a maximum of %d hit points when you %s.\n",
	    u.ulevel, u.uhpmax, st1);
	if(*st1 == 'e' && !done_stopprint){
		getret();	/* all those pieces of coloured glass ... */
		cls();
	}
#ifdef WIZARD
	if(!wizard)
#endif /* WIZARD */
		topten();
	if(done_stopprint) printf("\n\n");
	exit(0);
}

static void
topten(void)
{
	int uid = getuid();
	int rank, rank0 = -1, rank1 = 0;
	int occ_cnt = PERSMAX;
	struct toptenentry *t0, *t1, *tprev;
	char *recfile = RECORD;
	char *reclock = "record_lock";
	int sleepct = 300;
	FILE *rfile;
	int flg = 0;
#define	HUP	if(!done_hup)
	while(link(recfile, reclock) == -1) {
		HUP perror(reclock);
		if(!sleepct--) {
			HUP puts("I give up. Sorry.");
			HUP puts("Perhaps there is an old record_lock around?");
			return;
		}
		HUP printf("Waiting for access to record file. (%d)\n",
			sleepct);
		HUP (void) fflush(stdout);
		sleep(1);
	}
	if(!(rfile = fopen(recfile,"r"))){
		HUP puts("Cannot open record file!");
		goto unlock;
	}
	HUP (void) putchar('\n');

	/* create a new 'topten' entry */
	t0 = newttentry();
	t0->level = dlevel;
	t0->maxlvl = maxdlevel;
	t0->hp = u.uhp;
	t0->maxhp = u.uhpmax;
	t0->points = u.urexp;
	t0->plchar = pl_character[0];
	t0->sex = (flags.female ? 'F' : 'M');
	t0->uid = uid;
	(void) strlcpy(t0->name, plname, sizeof t0->name);
	(void) strlcpy(t0->death, killer, sizeof t0->death);
	(void) strlcpy(t0->date, getdate(), sizeof t0->date);

	/* assure minimum number of points */
	if(t0->points < POINTSMIN)
		t0->points = 0;

	t1 = tt_head = newttentry();
	tprev = 0;
	/* rank0: -1 undefined, 0 not_on_list, n n_th on list */
	for(rank = 1; ; ) {
	  if(fscanf(rfile, "%6s %d %d %d %d %d %ld %c%c %8[^,],%40[^\n]",
		t1->date, &t1->uid,
		&t1->level, &t1->maxlvl,
		&t1->hp, &t1->maxhp, &t1->points,
		&t1->plchar, &t1->sex, t1->name, t1->death) != 11
	  || t1->points < POINTSMIN)
			t1->points = 0;
	  if(rank0 < 0 && t1->points < t0->points) {
		rank0 = rank++;
		if(tprev == 0)
			tt_head = t0;
		else
			tprev->tt_next = t0;
		t0->tt_next = t1;
		occ_cnt--;
		flg++;		/* ask for a rewrite */
	  } else
		tprev = t1;
	  if(t1->points == 0) break;
	  if(
#ifdef PERS_IS_UID
	     t1->uid == t0->uid &&
#else
	     strncmp(t1->name, t0->name, NAMSZ) == 0 &&
#endif /* PERS_IS_UID */
	     t1->plchar == t0->plchar && --occ_cnt <= 0){
		if(rank0 < 0){
			rank0 = 0;
			rank1 = rank;
	HUP printf("You didn't beat your previous score of %ld points.\n\n",
				t1->points);
		}
		if(occ_cnt < 0){
			flg++;
			continue;
		}
	  }
	  if(rank <= ENTRYMAX){
	  	t1 = t1->tt_next = newttentry();
	  	rank++;
	  }
	  if(rank > ENTRYMAX){
		t1->points = 0;
		break;
	  }
	}
	if(flg) {	/* rewrite record file */
		(void) fclose(rfile);
		if(!(rfile = fopen(recfile,"w"))){
			HUP puts("Cannot write record file\n");
			goto unlock;
		}

		if(!done_stopprint) if(rank0 > 0){
		    if(rank0 <= 10)
			puts("You made the top ten list!\n");
		    else
		printf("You reached the %d%s place on the top %d list.\n\n",
			rank0, ordin(rank0), ENTRYMAX);
		}
	}
	if(rank0 == 0) rank0 = rank1;
	if(rank0 <= 0) rank0 = rank;
	if(!done_stopprint) outheader();
	t1 = tt_head;
	for(rank = 1; t1->points != 0; rank++, t1 = t1->tt_next) {
	  if(flg) fprintf(rfile,"%6s %d %d %d %d %d %ld %c%c %s,%s\n",
	    t1->date, t1->uid,
	    t1->level, t1->maxlvl,
	    t1->hp, t1->maxhp, t1->points,
	    t1->plchar, t1->sex, t1->name, t1->death);
	  if(done_stopprint) continue;
	  if(rank > flags.end_top &&
	    (rank < rank0-flags.end_around || rank > rank0+flags.end_around)
	    && (!flags.end_own ||
#ifdef PERS_IS_UID
				  t1->uid != t0->uid ))
#else
				  strncmp(t1->name, t0->name, NAMSZ)))
#endif /* PERS_IS_UID */
	  	continue;
	  if(rank == rank0-flags.end_around &&
	     rank0 > flags.end_top+flags.end_around+1 &&
	     !flags.end_own)
		(void) putchar('\n');
	  if(rank != rank0)
		(void) outentry(rank, t1, 0);
	  else if(!rank1)
		(void) outentry(rank, t1, 1);
	  else {
		int t0lth = outentry(0, t0, -1);
		int t1lth = outentry(rank, t1, t0lth);
		if(t1lth > t0lth) t0lth = t1lth;
		(void) outentry(0, t0, t0lth);
	  }
	}
	if(rank0 >= rank) if(!done_stopprint)
		(void) outentry(0, t0, 1);
	(void) fclose(rfile);
unlock:
	(void) unlink(reclock);
}

static void
outheader(void)
{
	char linebuf[BUFSZ];
	char *bp;

	(void) strlcpy(linebuf, "Number Points  Name", sizeof linebuf);
	bp = eos(linebuf);
	while(bp < linebuf + COLNO - 9) *bp++ = ' ';
	(void) strlcpy(bp, "Hp [max]", linebuf + sizeof linebuf - bp);
	puts(linebuf);
}

/* so>0: standout line; so=0: ordinary line; so<0: no output, return lth */
static int
outentry(int rank, struct toptenentry *t1, int so)
{
	boolean quit = FALSE, killed = FALSE, starv = FALSE;
	char linebuf[BUFSZ];
	char *bp;

	linebuf[0] = 0;
	if(rank)
		snprintf(linebuf, sizeof linebuf, "%3d", rank);
	else
		snprintf(linebuf, sizeof linebuf, "   ");
	bp = eos(linebuf);
	snprintf(bp, linebuf + sizeof linebuf - bp, " %6ld %8s",
	    t1->points, t1->name);
	if(t1->plchar == 'X')
		strlcat(linebuf, " ", sizeof linebuf);
	else {
		bp = eos(linebuf);
		snprintf(bp, linebuf + sizeof linebuf - bp,
		    "-%c ", t1->plchar);
	}
	bp = eos(linebuf);
	if(!strncmp("escaped", t1->death, 7)) {
	  if(!strcmp(" (with amulet)", t1->death+7))
	    snprintf(bp, linebuf + sizeof linebuf - bp,
	     "escaped the dungeon with amulet");
	  else
	    snprintf(bp, linebuf + sizeof linebuf - bp,
	     "escaped the dungeon [max level %d]", t1->maxlvl);
	} else {
	  if(!strncmp(t1->death,"quit",4)) {
	    quit = TRUE;
	    if(t1->maxhp < 3*t1->hp && t1->maxlvl < 4)
	  	strlcat(linebuf, "cravenly gave up", sizeof linebuf);
	    else
		strlcat(linebuf, "quit", sizeof linebuf);
	  }
	  else if(!strcmp(t1->death,"choked"))
	    snprintf(bp, linebuf + sizeof linebuf - bp, "choked on %s food",
		(t1->sex == 'F') ? "her" : "his");
	  else if(!strncmp(t1->death,"starv",5)) {
	    strlcat(linebuf, "starved to death", sizeof linebuf);
	    starv = TRUE;
	  } else {
	    strlcat(linebuf, "was killed", sizeof linebuf);
	    killed = TRUE;
	  }
	  bp = eos(linebuf);
	  snprintf(bp, linebuf + sizeof linebuf - bp, " on%s level %d",
	    (killed || starv) ? "" : " dungeon", t1->level);
	  if(t1->maxlvl != t1->level) {
	    bp = eos(linebuf);
	    snprintf(bp, linebuf + sizeof linebuf - bp,
	     " [max %d]", t1->maxlvl);
	  }
	  if(quit && t1->death[4])
	    strlcat(linebuf, t1->death + 4, sizeof linebuf);
	}
	if(killed) {
	  bp = eos(linebuf);
	  snprintf(bp, linebuf + sizeof linebuf - bp, " by %s%s",
	   (!strncmp(t1->death, "trick", 5) || !strncmp(t1->death, "the ", 4))
		? "" :
	   strchr(vowels,*t1->death) ? "an " : "a ", t1->death);
	}
	strlcat(linebuf, ".", sizeof linebuf);
	if(t1->maxhp) {
	  char hpbuf[10];
	  int hppos;
	  bp = eos(linebuf);
	  snprintf(hpbuf, sizeof hpbuf, (t1->hp > 0) ? itoa(t1->hp) : "-");
	  hppos = COLNO - 7 - strlen(hpbuf);
	  if(bp <= linebuf + hppos) {
	    while(bp < linebuf + hppos) *bp++ = ' ';
	    (void) strlcpy(bp, hpbuf, linebuf + sizeof linebuf - bp);
	    bp = eos(linebuf);
	    snprintf(bp, linebuf + sizeof linebuf - bp, " [%d]", t1->maxhp);
	  }
	}
	if(so == 0) puts(linebuf);
	else if(so > 0) {
	  bp = eos(linebuf);
	  if(so >= COLNO) so = COLNO-1;
	  while(bp < linebuf + so) *bp++ = ' ';
	  *bp = 0;
	  standoutbeg();
	  fputs(linebuf,stdout);
	  standoutend();
	  (void) putchar('\n');
	}
	return(strlen(linebuf));
}

static char *
itoa(int a)
{
	static char buf[12];

	snprintf(buf, sizeof buf, "%d", a);
	return(buf);
}

static char *
ordin(int n)
{
	int d = n%10;

	return((d==0 || d>3 || n/10==1) ? "th" : (d==1) ? "st" :
		(d==2) ? "nd" : "rd");
}

void
clearlocks(void)
{
	int x;

	(void) signal(SIGHUP,SIG_IGN);
	for(x = maxdlevel; x >= 0; x--) {
		glo(x);
		(void) unlink(lock);	/* not all levels need be present */
	}
}

char *
eos(char *s)
{
	while(*s) s++;
	return(s);
}

/* it is the callers responsibility to check that there is room for c */
void
charcat(char *s, char c)
{
	while(*s) s++;
	*s++ = c;
	*s = 0;
}

/*
 * Called with args from main if argc >= 0. In this case, list scores as
 * requested. Otherwise, find scores for the current player (and list them
 * if argc == -1).
 */
void
prscore(int argc, char **argv)
{
	extern char *__progname;
	char **players;
	int playerct;
	int rank;
	struct toptenentry *t1, *t2;
	char *recfile = RECORD;
	FILE *rfile;
	int flg = 0;
	int i;
#ifdef nonsense
	long total_score = 0L;
	char totchars[10];
	int totcharct = 0;
#endif /* nonsense */
	int outflg = (argc >= -1);
#ifdef PERS_IS_UID
	int uid = -1;
#else
	char *player0;
#endif /* PERS_IS_UID */

	if(!(rfile = fopen(recfile,"r"))){
		puts("Cannot open record file!");
		return;
	}

	if(argc > 1 && !strncmp(argv[1], "-s", 2)){
		if(!argv[1][2]){
			argc--;
			argv++;
		} else if(!argv[1][3] && strchr("CFKSTWX", argv[1][2])) {
			argv[1]++;
			argv[1][0] = '-';
		} else	argv[1] += 2;
	}
	if(argc <= 1){
#ifdef PERS_IS_UID
		uid = getuid();
		playerct = 0;
#else
		player0 = plname;
		if(!*player0)
			player0 = "hackplayer";
		playerct = 1;
		players = &player0;
#endif /* PERS_IS_UID */
	} else {
		playerct = --argc;
		players = ++argv;
	}
	if(outflg) putchar('\n');

	t1 = tt_head = newttentry();
	for(rank = 1; ; rank++) {
	  if(fscanf(rfile, "%6s %d %d %d %d %d %ld %c%c %8[^,],%40[^\n]",
		t1->date, &t1->uid,
		&t1->level, &t1->maxlvl,
		&t1->hp, &t1->maxhp, &t1->points,
		&t1->plchar, &t1->sex, t1->name, t1->death) != 11)
			t1->points = 0;
	  if(t1->points == 0) break;
#ifdef PERS_IS_UID
	  if(!playerct && t1->uid == uid)
		flg++;
	  else
#endif /* PERS_IS_UID */
	  for(i = 0; i < playerct; i++){
		if(strcmp(players[i], "all") == 0 ||
		   strncmp(t1->name, players[i], NAMSZ) == 0 ||
		  (players[i][0] == '-' &&
		   players[i][1] == t1->plchar &&
		   players[i][2] == 0) ||
		  (isdigit((unsigned char)players[i][0]) && rank <= atoi(players[i])))
			flg++;
	  }
	  t1 = t1->tt_next = newttentry();
	}
	(void) fclose(rfile);
	if(!flg) {
	    if(outflg) {
		printf("Cannot find any entries for ");
		if(playerct < 1) printf("you.\n");
		else {
		  if(playerct > 1) printf("any of ");
		  for(i=0; i<playerct; i++)
			printf("%s%s", players[i], (i<playerct-1)?", ":".\n");
		  printf("Call is: %s -s [playernames]\n", __progname);
		}
	    }
	    return;
	}

	if(outflg) outheader();
	t1 = tt_head;
	for(rank = 1; t1->points != 0; rank++, t1 = t2) {
		t2 = t1->tt_next;
#ifdef PERS_IS_UID
		if(!playerct && t1->uid == uid)
			goto outwithit;
		else
#endif /* PERS_IS_UID */
		for(i = 0; i < playerct; i++){
			if(strcmp(players[i], "all") == 0 ||
			   strncmp(t1->name, players[i], NAMSZ) == 0 ||
			  (players[i][0] == '-' &&
			   players[i][1] == t1->plchar &&
			   players[i][2] == 0) ||
			  (isdigit((unsigned char)players[i][0]) && rank <= atoi(players[i]))){
			outwithit:
				if(outflg)
				    (void) outentry(rank, t1, 0);
#ifdef nonsense
				total_score += t1->points;
				if(totcharct < sizeof(totchars)-1)
				    totchars[totcharct++] = t1->plchar;
#endif /* nonsense */
				break;
			}
		}
		free(t1);
	}
#ifdef nonsense
	totchars[totcharct] = 0;

	/* We would like to determine whether he is experienced. However,
	   the information collected here only tells about the scores/roles
	   that got into the topten (top 100?). We should maintain a
	   .hacklog or something in his home directory. */
	flags.beginner = (total_score < 6000);
	for(i=0; i<6; i++)
	    if(!strchr(totchars, "CFKSTWX"[i])) {
		flags.beginner = 1;
		if(!pl_character[0]) pl_character[0] = "CFKSTWX"[i];
		break;
	}
#endif /* nonsense */
}
@


1.15
log
@This diff is rather large, but it's just simply removing unnecessary headers
, remove some lint-style comments, add missing void to functions without args,
also some function prototypes (extern) were missing their args, so I added them
as they were defined in hack.h

OK tb@@ on separate diffs
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.end.c,v 1.14 2015/12/16 14:21:50 tb Exp $	*/
d206 1
a206 1
	settty((char *) 0);	/* does a clr_screen() */
@


1.14
log
@Use __progname instead of hand-rolled parsing of argv[0].
Inspired by similar diffs by tobias@@ and millert@@.

"I like the concept" pjanzen@@
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.end.c,v 1.13 2015/10/24 18:26:13 mmcc Exp $	*/
d69 1
a114 1
	/* NOTREACHED */
d118 1
a118 1
done2()
d299 1
a299 1
topten()
d455 1
a455 1
outheader()
d581 1
a581 1
clearlocks()
@


1.13
log
@Cast ctype functions' arguments to unsigned char.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.end.c,v 1.12 2014/03/11 08:05:15 guenther Exp $	*/
d616 1
a616 1
	extern char *hname;
d702 1
a702 1
		  printf("Call is: %s -s [playernames]\n", hname);
@


1.12
log
@Match bwrite()'s prototype with write()'s, zapping a lint comment
Delete casts to char* of arguments to bwrite() and free()
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.end.c,v 1.11 2009/12/10 23:53:07 beck Exp $	*/
d688 1
a688 1
		  (isdigit(players[i][0]) && rank <= atoi(players[i])))
d723 1
a723 1
			  (isdigit(players[i][0]) && rank <= atoi(players[i]))){
@


1.11
log
@fix potential bugs spotted by parfait
ok millert@@ pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.end.c,v 1.10 2009/10/27 23:59:25 deraadt Exp $	*/
d735 1
a735 1
		free((char *) t1);
@


1.10
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.end.c,v 1.9 2003/07/06 02:07:45 avsm Exp $	*/
d351 1
a351 1
	  if(fscanf(rfile, "%6s %d %d %d %d %d %ld %c%c %[^,],%[^\n]",
d670 1
a670 1
	  if(fscanf(rfile, "%6s %d %d %d %d %d %ld %c%c %[^,],%[^\n]",
@


1.9
log
@convert a bunch of strn{cpy,cat}->strl{cpy,cat}
pjanzen@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.end.c,v 1.8 2003/05/19 06:30:56 pjanzen Exp $	*/
a62 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: hack.end.c,v 1.8 2003/05/19 06:30:56 pjanzen Exp $";
#endif /* not lint */
@


1.8
log
@De-register, ANSIfy, clean up.
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.end.c,v 1.7 2003/05/07 09:48:57 tdeval Exp $	*/
d65 1
a65 1
static const char rcsid[] = "$OpenBSD$";
d343 2
a344 4
	(void) strncpy(t0->name, plname, NAMSZ);
	(t0->name)[NAMSZ] = 0;
	(void) strncpy(t0->death, killer, DTHSZ);
	(t0->death)[DTHSZ] = 0;
@


1.7
log
@Major strings rework.  Ok pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.end.c,v 1.6 2003/04/06 18:50:37 deraadt Exp $	*/
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.end.c,v 1.6 2003/04/06 18:50:37 deraadt Exp $";
d68 1
a68 1
#include "hack.h"
d70 1
d72 11
a83 1
extern char *itoa(), *ordin(), *eos();
d87 18
d106 1
a106 1
done1()
d121 7
d132 2
a133 1
done_intr(){
d140 2
a141 1
done_hangup(){
d144 1
a144 1
	done_intr();
d147 5
a151 2
done_in_by(mtmp) register struct monst *mtmp; {
static char buf[BUFSZ];
d170 2
a171 2
done(st1)
register char *st1;
d210 1
a210 1
	settty((char *) 0);	/* does a clear_screen() */
d226 4
a229 4
		register struct monst *mtmp;
		register struct obj *otmp;
		register int i;
		register unsigned worthlessct = 0;
d302 3
a304 20
#define newttentry() (struct toptenentry *) alloc(sizeof(struct toptenentry))
#define	NAMSZ	8
#define	DTHSZ	40
#define	PERSMAX	1
#define	POINTSMIN	1	/* must be > 0 */
#define	ENTRYMAX	100	/* must be >= 10 */
#define	PERS_IS_UID		/* delete for PERSMAX per name; now per uid */
struct toptenentry {
	struct toptenentry *tt_next;
	long int points;
	int level,maxlvl,hp,maxhp;
	int uid;
	char plchar;
	char sex;
	char name[NAMSZ+1];
	char death[DTHSZ+1];
	char date[7];		/* yymmdd */
} *tt_head;

topten(){
d308 1
a308 1
	register struct toptenentry *t0, *t1, *tprev;
d313 1
a313 2
	register flg = 0;
	extern char *getdate();
d460 6
a465 3
outheader() {
char linebuf[BUFSZ];
register char *bp;
d474 7
a480 5
int
outentry(rank,t1,so) register struct toptenentry *t1; {
boolean quit = FALSE, killed = FALSE, starv = FALSE;
char linebuf[BUFSZ];
char *bp;
d568 6
a573 4
char *
itoa(a) int a; {
static char buf[12];
	snprintf(buf,sizeof buf,"%d",a);
d577 5
a581 3
char *
ordin(n) int n; {
register int d = n%10;
d586 5
a590 2
clearlocks(){
register x;
a597 9
#ifdef NOSAVEONHANGUP
hangup()
{
	(void) signal(SIGINT, SIG_IGN);
	clearlocks();
	exit(1);
}
#endif /* NOSAVEONHANGUP */

d599 1
a599 2
eos(s)
register char *s;
d606 3
a608 1
charcat(s,c) register char *s, c; {
d619 3
a621 1
prscore(argc,argv) int argc; char **argv; {
d626 1
a626 1
	register struct toptenentry *t1, *t2;
d629 2
a630 2
	register flg = 0;
	register int i;
d694 1
a694 1
		  (digit(players[i][0]) && rank <= atoi(players[i])))
d729 1
a729 1
			  (digit(players[i][0]) && rank <= atoi(players[i]))){
@


1.6
log
@2451 lines of strdup/sprintf/strcpy whacking.  mostly ok'd by pjanzen
already, but he may have later changes to make still.
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.end.c,v 1.5 2003/03/16 21:22:35 camield Exp $	*/
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.end.c,v 1.5 2003/03/16 21:22:35 camield Exp $";
d324 1
a324 1
	(void) strcpy(t0->date, getdate());
d440 1
a440 1
	(void) strcpy(linebuf, "Number Points  Name");
d443 1
a443 1
	(void) strcpy(bp, "Hp [max]");
d452 1
d454 15
a468 5
	if(rank) sprintf(eos(linebuf), "%3d", rank);
		else sprintf(eos(linebuf), "   ");
	sprintf(eos(linebuf), " %6ld %8s", t1->points, t1->name);
	if(t1->plchar == 'X') sprintf(eos(linebuf), " ");
	else sprintf(eos(linebuf), "-%c ", t1->plchar);
d471 2
a472 1
	    sprintf(eos(linebuf), "escaped the dungeon with amulet");
d474 2
a475 2
	    sprintf(eos(linebuf), "escaped the dungeon [max level %d]",
	      t1->maxlvl);
d480 1
a480 1
	  	sprintf(eos(linebuf), "cravenly gave up");
d482 1
a482 1
		sprintf(eos(linebuf), "quit");
d485 1
a485 1
	    sprintf(eos(linebuf), "choked on %s food",
d487 9
a495 4
	  else if(!strncmp(t1->death,"starv",5))
	    sprintf(eos(linebuf), "starved to death"), starv = TRUE;
	  else sprintf(eos(linebuf), "was killed"), killed = TRUE;
	  sprintf(eos(linebuf), " on%s level %d",
d497 7
a503 3
	  if(t1->maxlvl != t1->level)
	    sprintf(eos(linebuf), " [max %d]", t1->maxlvl);
	  if(quit && t1->death[4]) sprintf(eos(linebuf), t1->death + 4);
d505 4
a508 2
	if(killed) sprintf(eos(linebuf), " by %s%s",
	  (!strncmp(t1->death, "trick", 5) || !strncmp(t1->death, "the ", 4))
d510 3
a512 3
	  strchr(vowels,*t1->death) ? "an " : "a ",
	  t1->death);
	sprintf(eos(linebuf), ".");
a513 1
	  register char *bp = eos(linebuf);
d516 1
d521 3
a523 2
	    (void) strcpy(bp, hpbuf);
	    sprintf(eos(bp), " [%d]", t1->maxhp);
d528 1
a528 1
	  register char *bp = eos(linebuf);
@


1.5
log
@hack is free

Thanks to Andries Brouwer, Jay Fenlason and the folks at CWI for their
efforts.

http://www.cwi.nl/~aeb/games/hack/hack.html

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.end.c,v 1.4 2001/08/06 22:59:13 pjanzen Exp $	*/
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.end.c,v 1.4 2001/08/06 22:59:13 pjanzen Exp $";
a70 1
#define	Sprintf	(void) sprintf
d113 1
a113 1
		Sprintf(buf, "the ghost of %s", (char *) mtmp->mextra);
d116 1
a116 1
		Sprintf(buf, "%s called %s",
d120 1
a120 1
		Sprintf(buf, "invisible %s", mtmp->data->mname);
d453 5
a457 5
	if(rank) Sprintf(eos(linebuf), "%3d", rank);
		else Sprintf(eos(linebuf), "   ");
	Sprintf(eos(linebuf), " %6ld %8s", t1->points, t1->name);
	if(t1->plchar == 'X') Sprintf(eos(linebuf), " ");
	else Sprintf(eos(linebuf), "-%c ", t1->plchar);
d460 1
a460 1
	    Sprintf(eos(linebuf), "escaped the dungeon with amulet");
d462 1
a462 1
	    Sprintf(eos(linebuf), "escaped the dungeon [max level %d]",
d468 1
a468 1
	  	Sprintf(eos(linebuf), "cravenly gave up");
d470 1
a470 1
		Sprintf(eos(linebuf), "quit");
d473 1
a473 1
	    Sprintf(eos(linebuf), "choked on %s food",
d476 3
a478 3
	    Sprintf(eos(linebuf), "starved to death"), starv = TRUE;
	  else Sprintf(eos(linebuf), "was killed"), killed = TRUE;
	  Sprintf(eos(linebuf), " on%s level %d",
d481 2
a482 2
	    Sprintf(eos(linebuf), " [max %d]", t1->maxlvl);
	  if(quit && t1->death[4]) Sprintf(eos(linebuf), t1->death + 4);
d484 1
a484 1
	if(killed) Sprintf(eos(linebuf), " by %s%s",
d489 1
a489 1
	Sprintf(eos(linebuf), ".");
d494 1
a494 1
	  Sprintf(hpbuf, (t1->hp > 0) ? itoa(t1->hp) : "-");
d499 1
a499 1
	    Sprintf(eos(bp), " [%d]", t1->maxhp);
d519 1
a519 1
	Sprintf(buf,"%d",a);
@


1.4
log
@Nothing but comments after #endif and #else; heko@@iki.fi
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.end.c,v 1.3 2001/01/28 23:41:43 niklas Exp $	*/
d4 58
a61 1
 * Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985.
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.end.c,v 1.3 2001/01/28 23:41:43 niklas Exp $";
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d8 1
a8 1
static char rcsid[] = "$OpenBSD: hack.end.c,v 1.3 1995/03/23 08:30:05 cgd Exp $";
d88 1
a88 1
#endif WIZARD
d107 1
a107 1
#endif WIZARD
d199 1
a199 1
#endif WIZARD
d302 1
a302 1
#endif PERS_IS_UID
d357 1
a357 1
#endif PERS_IS_UID
d490 1
a490 1
#endif NOSAVEONHANGUP
d526 1
a526 1
#endif nonsense
d532 1
a532 1
#endif PERS_IS_UID
d558 1
a558 1
#endif PERS_IS_UID
d578 1
a578 1
#endif PERS_IS_UID
d613 1
a613 1
#endif PERS_IS_UID
d628 1
a628 1
#endif nonsense
d648 1
a648 1
#endif nonsense
@


1.2
log
@r?index -> strr?chr
@
text
@d1 2
d8 1
a8 1
static char rcsid[] = "$NetBSD: hack.end.c,v 1.3 1995/03/23 08:30:05 cgd Exp $";
@


1.1
log
@Initial revision
@
text
@d98 1
a98 1
	if(!index("bcd", *st1)) killer = st1;
d102 1
a102 1
	if(index("bcds", *st1)){
d429 1
a429 1
	  index(vowels,*t1->death) ? "an " : "a ",
d541 1
a541 1
		} else if(!argv[1][3] && index("CFKSTWX", argv[1][2])) {
d641 1
a641 1
	    if(!index(totchars, "CFKSTWX"[i])) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
