head	1.24;
access;
symbols
	OPENBSD_6_1:1.24.0.4
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.2
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.20.0.8
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.19.0.14
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.10
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.8
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.6
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.4
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.18.0.6
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.14.0.6
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.4
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.12.0.4
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.6
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.4
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.6
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.4
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2016.03.15.19.56.20;	author mestre;	state Exp;
branches;
next	1.23;
commitid	CVq5Psh8I11pL2MZ;

1.23
date	2016.01.09.21.54.11;	author mestre;	state Exp;
branches;
next	1.22;
commitid	ve4zhTqqRMMVn77Z;

1.22
date	2016.01.09.18.33.15;	author mestre;	state Exp;
branches;
next	1.21;
commitid	cGEyAVlKS2f51J9L;

1.21
date	2015.09.27.05.13.11;	author guenther;	state Exp;
branches;
next	1.20;
commitid	XzWkIYKZztPpIW70;

1.20
date	2014.03.11.08.05.15;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2011.03.16.18.11.37;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.27.23.59.25;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.03.14.47.47;	author chl;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.01.22.57.14;	author ray;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.01.09.07.56;	author ray;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.14.14.29.20;	author chl;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.11.15.21.05;	author gilles;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.21.03.53.32;	author ray;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.01.02.43.12;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.19.06.30.56;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.07.09.48.57;	author tdeval;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.16.21.22.36;	author camield;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.06.22.59.13;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.28.23.41.45;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.02.04.10.44;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.08.16.17.00.16;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.17.07.11.26;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.12.22.20.01.22;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.01;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@execl(3) calls must have the last argument casted to (char *)NULL

At the time when this was commited me and tb@@ discussed that it shouldn't be
changed, but still snucked in within a larger diff that we didn't notice.

OK tb@@
@
text
@/*	$OpenBSD: hack.pager.c,v 1.23 2016/01/09 21:54:11 mestre Exp $	*/

/*
 * Copyright (c) 1985, Stichting Centrum voor Wiskunde en Informatica,
 * Amsterdam
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * - Neither the name of the Stichting Centrum voor Wiskunde en
 * Informatica, nor the names of its contributors may be used to endorse or
 * promote products derived from this software without specific prior
 * written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982 Jay Fenlason <hack@@gnu.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* This file contains the command routine dowhatis() and a pager. */
/* Also readmail() and doshell(), and generally the things that
   contact the outside world. */

#include <libgen.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "hack.h"

extern int CO, LI;	/* usually COLNO and ROWNO+2 */
extern char *CD;
extern char quitchars[];

static void page_more(FILE *, int);

int
dowhatis(void)
{
	FILE *fp;
	char bufr[BUFSZ+6];
	char *buf = &bufr[6], q;
	size_t len;
	extern char readchar();

	if (!(fp = fopen(DATAFILE, "r")))
		pline("Cannot open data file!");
	else {
		pline("Specify what? ");
		q = readchar();
		if (q != '\t')
			while (fgets(buf,BUFSZ,fp))
				if (*buf == q) {
					len = strcspn(buf, "\n");
					/* bad data file */
					if (len == 0)
						continue;
					buf[len] = '\0';
					/* Expand tab 'by hand' */
					if (buf[1] == '\t'){
						buf = bufr;
						buf[0] = q;
						(void) strncpy(buf+1, "       ", 7);
						len = strlen(buf);
					}
					pline("%s", buf);
					if (buf[len - 1] == ';') {
						pline("More info? ");
						if (readchar() == 'y') {
							page_more(fp,1); /* does fclose() */
							return(0);
						}
					}
					(void) fclose(fp); 	/* kopper@@psuvax1 */
					return(0);
				}
		pline("I've never heard of such things.");
		(void) fclose(fp);
	}
	return(0);
}

/* make the paging of a file interruptible */
static int got_intrup;

void
intruph(int notused)
{
	got_intrup++;
}

/* simple pager, also used from dohelp() */
/* strip: nr of chars to be stripped from each line (0 or 1) */
static void
page_more(FILE *fp, int strip)
{
	char *bufr;
	sig_t prevsig = signal(SIGINT, intruph);

	set_pager(0);
	bufr = (char *) alloc((unsigned) CO);
	while (fgets(bufr, CO, fp) && (!strip || *bufr == '\t') &&
	    !got_intrup) {
		bufr[strcspn(bufr, "\n")] = '\0';
		if (page_line(bufr+strip)) {
			set_pager(2);
			goto ret;
		}
	}
	set_pager(1);
ret:
	free(bufr);
	(void) fclose(fp);
	(void) signal(SIGINT, prevsig);
	got_intrup = 0;
}

static boolean whole_screen = TRUE;
#define	PAGMIN	12	/* minimum # of lines for page below level map */

void
set_whole_screen(void)
{	/* called in termcap as soon as LI is known */
	whole_screen = (LI-ROWNO-2 <= PAGMIN || !CD);
}

#ifdef NEWS
int
readnews(void)
{
	int ret;

	whole_screen = TRUE;	/* force a docrt(), our first */
	ret = page_file(NEWS, TRUE);
	set_whole_screen();
	return(ret);		/* report whether we did docrt() */
}
#endif /* NEWS */

/* 0: open  1: wait+close  2: close */
void
set_pager(int mode)
{
	static boolean so;
	if(mode == 0) {
		if(!whole_screen) {
			/* clear topline */
			clrlin();
			/* use part of screen below level map */
			curs(1, ROWNO+4);
		} else {
			cls();
		}
		so = flags.standout;
		flags.standout = 1;
	} else {
		if(mode == 1) {
			curs(1, LI);
			more();
		}
		flags.standout = so;
		if(whole_screen)
			docrt();
		else {
			curs(1, ROWNO+4);
			cl_eos();
		}
	}
}

int
page_line(char *s)		/* returns 1 if we should quit */
{
	extern char morc;

	if(cury == LI-1) {
		if(!*s)
			return(0);	/* suppress blank lines at top */
		putchar('\n');
		cury++;
		cmore("q\033");
		if(morc) {
			morc = 0;
			return(1);
		}
		if(whole_screen)
			cls();
		else {
			curs(1, ROWNO+4);
			cl_eos();
		}
	}
	puts(s);
	cury++;
	return(0);
}

/*
 * Flexible pager: feed it with a number of lines and it will decide
 * whether these should be fed to the pager above, or displayed in a
 * corner.
 * Call:
 *	cornline(0, title or 0)	: initialize
 *	cornline(1, text)	: add text to the chain of texts
 *	cornline(2, morcs)	: output everything and cleanup
 *	cornline(3, 0)		: cleanup
 */
void
cornline(int mode, char *text)
{
	static struct line {
		struct line *next_line;
		char *line_text;
	} *texthead, *texttail;
	static int maxlen;
	static int linect;
	struct line *tl;

	if(mode == 0) {
		texthead = 0;
		maxlen = 0;
		linect = 0;
		if(text) {
			cornline(1, text);	/* title */
			cornline(1, "");	/* blank line */
		}
		return;
	}

	if(mode == 1) {
	    int len;

	    if(!text) return;	/* superfluous, just to be sure */
	    linect++;
	    len = strlen(text);
	    if(len > maxlen)
		maxlen = len;
	    tl = (struct line *)
		alloc((unsigned)(len + sizeof(struct line) + 1));
	    tl->next_line = 0;
	    tl->line_text = (char *)(tl + 1);
	    (void) strlcpy(tl->line_text, text, len + 1);
	    if(!texthead)
		texthead = tl;
	    else
		texttail->next_line = tl;
	    texttail = tl;
	    return;
	}

	/* --- now we really do it --- */
	if(mode == 2 && linect == 1)			    /* topline only */
		pline("%s", texthead->line_text);
	else
	if(mode == 2) {
	    int curline, lth;

	    if(flags.toplin == 1) more();	/* ab@@unido */
	    remember_topl();

	    lth = CO - maxlen - 2;		   /* Use full screen width */
	    if (linect < LI && lth >= 10) {		     /* in a corner */
		home();
		cl_end();
		flags.toplin = 0;
		curline = 1;
		for (tl = texthead; tl; tl = tl->next_line) {
		    curs(lth, curline);
		    if(curline > 1)
			cl_end();
		    putsym(' ');
		    putstr (tl->line_text);
		    curline++;
		}
		curs(lth, curline);
		cl_end();
		cmore(text);
		home();
		cl_end();
		docorner(lth, curline-1);
	    } else {					/* feed to pager */
		set_pager(0);
		for (tl = texthead; tl; tl = tl->next_line) {
		    if (page_line (tl->line_text)) {
			set_pager(2);
			goto cleanup;
		    }
		}
		if(text) {
			cgetret(text);
			set_pager(2);
		} else
			set_pager(1);
	    }
	}

cleanup:
	while ((tl = texthead)) {
		texthead = tl->next_line;
		free(tl);
	}
}

int
dohelp(void)
{
	char c;

	pline ("Long or short help? ");
	while (((c = readchar ()) != 'l') && (c != 's') && !strchr(quitchars,c))
		hackbell ();
	if (!strchr(quitchars, c))
		(void) page_file((c == 'l') ? HELP : SHELP, FALSE);
	return(0);
}

/* return: 0 - cannot open fnam; 1 - otherwise */
int
page_file(char *fnam, boolean silent)
{
#ifdef DEF_PAGER			/* this implies that UNIX is defined */
      {
	/* use external pager; this may give security problems */

	int fd = open(fnam, O_RDONLY);

	if(fd < 0) {
		if(!silent) pline("Cannot open %s.", fnam);
		return(0);
	}
	if(child(1)){
		extern char *catmore;

		/* Now that child() does a setuid(getuid()) and a chdir(),
		   we may not be able to open file fnam anymore, so make
		   it stdin. */
		(void) close(0);
		if(dup(fd)) {
			if(!silent) printf("Cannot open %s as stdin.\n", fnam);
		} else {
			execlp(catmore, basename(catmore), (char *)NULL);
			if(!silent) printf("Cannot exec %s.\n", catmore);
		}
		exit(1);
	}
	(void) close(fd);
      }
#else /* DEF_PAGER */
      {
	FILE *f;			/* free after Robert Viduya */

	if ((f = fopen (fnam, "r")) == (FILE *) 0) {
		if(!silent) {
			home(); perror (fnam); flags.toplin = 1;
			pline ("Cannot open %s.", fnam);
		}
		return(0);
	}
	page_more(f, 0);
      }
#endif /* DEF_PAGER */

	return(1);
}

#ifdef UNIX
#ifdef SHELL
int
dosh(void)
{
	char *str;

	if(child(0)) {
		if ((str = getenv("SHELL")))
			execlp(str, str, (char *)NULL);
		else
			execl("/bin/sh", "sh", (char *)NULL);
		pline("sh: cannot execute.");
		exit(1);
	}
	return(0);
}
#endif /* SHELL */

#include <sys/wait.h>

int
child(int wt)
{
	int status;
	int f;
	char *home;
	gid_t gid;

	f = fork();
	if(f == 0){		/* child */
		settty(NULL);		/* also calls end_screen() */
		/* revoke privs */
		gid = getgid();
		setresgid(gid, gid, gid);
#ifdef CHDIR
		home = getenv("HOME");
		if (home == NULL || *home == '\0')
			home = "/";
		(void) chdir(home);
#endif /* CHDIR */
		return(1);
	}
	if(f == -1) {	/* cannot fork */
		pline("Fork failed. Try again.");
		return(0);
	}
	/* fork succeeded; wait for child to exit */
	(void) signal(SIGINT,SIG_IGN);
	(void) signal(SIGQUIT,SIG_IGN);
	(void) wait(&status);
	gettty();
	setftty();
	(void) signal(SIGINT,done1);
#ifdef WIZARD
	if(wizard) (void) signal(SIGQUIT,SIG_DFL);
#endif /* WIZARD */
	if(wt) getret();
	docrt();
	return(0);
}
#endif /* UNIX */
@


1.23
log
@Remove several casts to (char *) 0 and replace them by NULL

Prompted and OK by tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pager.c,v 1.22 2016/01/09 18:33:15 mestre Exp $	*/
d386 1
a386 1
			execlp(catmore, basename(catmore), NULL);
d420 1
a420 1
			execlp(str, str, NULL);
d422 1
a422 1
			execl("/bin/sh", "sh", NULL);
@


1.22
log
@This diff is rather large, but it's just simply removing unnecessary headers
, remove some lint-style comments, add missing void to functions without args,
also some function prototypes (extern) were missing their args, so I added them
as they were defined in hack.h

OK tb@@ on separate diffs
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pager.c,v 1.21 2015/09/27 05:13:11 guenther Exp $	*/
d386 1
a386 1
			execlp(catmore, basename(catmore), (char *) 0);
d420 1
a420 1
			execlp(str, str, (char *) 0);
d422 1
a422 1
			execl("/bin/sh", "sh", (char *) 0);
d442 1
a442 1
		settty((char *) 0);		/* also calls end_screen() */
@


1.21
log
@Annotate funcs with __attribute__((printf(...))) and clean up the fallout:
 * lots of foo(str) --> foo("%s", str) transformations
 * one totally insane foo(fmt, ap) --> vfoo(fmt, ap) conversion: how did
   this ever work?
 * prefer const char[] over char* for static format strings, as it lets
   gcc check the format and eliminates an unnecessary pointer

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pager.c,v 1.20 2014/03/11 08:05:15 guenther Exp $	*/
d68 6
a73 6
#include	<sys/types.h>
#include	<libgen.h>
#include	<signal.h>
#include	<stdio.h>
#include	<stdlib.h>
#include	<unistd.h>
d75 1
d83 1
a83 1
dowhatis()
d167 1
a167 1
set_whole_screen()
d174 1
a174 1
readnews()
d350 1
a350 1
dohelp()
d414 1
a414 1
dosh()
d430 1
a430 1
#include	<sys/wait.h>
@


1.20
log
@Match bwrite()'s prototype with write()'s, zapping a lint comment
Delete casts to char* of arguments to bwrite() and free()
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pager.c,v 1.19 2011/03/16 18:11:37 deraadt Exp $	*/
d110 1
a110 1
					pline(buf);
d297 1
a297 1
		pline(texthead->line_text);
@


1.19
log
@Use the help pager code, but repair it in various ways.
(I had to fix the $PAGER support beyond the patch supplied by Simon)
from Simon.Nicolussi@@student.uibk.ac.at
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pager.c,v 1.18 2009/10/27 23:59:25 deraadt Exp $	*/
d344 1
a344 1
		free((char *) tl);
@


1.18
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pager.c,v 1.17 2009/06/03 14:47:47 chl Exp $	*/
d69 1
d149 1
a149 1
		if (*bufr == '\0' || page_line(bufr+strip)) {
d385 1
a385 1
			execl(catmore, "page", (char *) 0);
d419 1
a419 1
			execl(str, str, (char *) 0);
@


1.17
log
@remove unused variable

ok millert@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pager.c,v 1.16 2009/06/01 22:57:14 ray Exp $	*/
a62 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: hack.pager.c,v 1.16 2009/06/01 22:57:14 ray Exp $";
#endif /* not lint */
@


1.16
log
@Fix fgets handling.
1. Skip blank lines instead of dereferencing NULL-1.
2. If bufr is a blank line don't pass bufr+1 as a pointer.

OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pager.c,v 1.15 2009/06/01 09:07:56 ray Exp $	*/
d65 1
a65 1
static const char rcsid[] = "$OpenBSD: hack.pager.c,v 1.15 2009/06/01 09:07:56 ray Exp $";
d89 1
a89 1
	char *buf = &bufr[6], *ep, q;
@


1.15
log
@Style, inspired by NetBSD.

No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pager.c,v 1.14 2007/09/14 14:29:20 chl Exp $	*/
d65 1
a65 1
static const char rcsid[] = "$OpenBSD: hack.pager.c,v 1.14 2007/09/14 14:29:20 chl Exp $";
d90 1
d101 5
a105 4
					ep = strchr(buf, '\n');
					if (ep)
						*ep = 0;
					/* else: bad data file */
d111 1
d114 1
a114 1
					if (ep[-1] == ';') {
d152 1
a152 1
		if(page_line(bufr+strip)) {
@


1.14
log
@remove some warnings:
unused variable `variable'
`variable' might be used uninitialized in this function

ok gilles@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pager.c,v 1.13 2007/09/11 15:21:05 gilles Exp $	*/
d65 1
a65 1
static const char rcsid[] = "$OpenBSD: hack.pager.c,v 1.13 2007/09/11 15:21:05 gilles Exp $";
d92 1
a92 1
	if(!(fp = fopen(DATAFILE, "r")))
d97 22
a118 17
		if(q != '\t')
		while(fgets(buf,BUFSZ,fp))
		    if(*buf == q) {
			ep = strchr(buf, '\n');
			if(ep) *ep = 0;
			/* else: bad data file */
			/* Expand tab 'by hand' */
			if(buf[1] == '\t'){
				buf = bufr;
				buf[0] = q;
				(void) strncpy(buf+1, "       ", 7);
			}
			pline(buf);
			if(ep[-1] == ';') {
				pline("More info? ");
				if(readchar() == 'y') {
					page_more(fp,1); /* does fclose() */
a120 4
			}
			(void) fclose(fp); 	/* kopper@@psuvax1 */
			return(0);
		    }
@


1.13
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pager.c,v 1.12 2007/02/21 03:53:32 ray Exp $	*/
d65 1
a65 1
static const char rcsid[] = "$OpenBSD: hack.pager.c,v 1.12 2007/02/21 03:53:32 ray Exp $";
d100 2
a101 1
			buf[strcspn(buf, "\n")] = '\0';
d140 1
a140 1
	char *bufr, *ep;
@


1.12
log
@- Pass full buffer size to fgets.
- No need to initialize buffer.
- Spacing.

Based on diff from Charles Longeau <chl at tuxfamily dot org> long ago.

OK moritz@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pager.c,v 1.11 2005/05/01 02:43:12 djm Exp $	*/
d65 1
a65 1
static const char rcsid[] = "$OpenBSD: hack.pager.c,v 1.11 2005/05/01 02:43:12 djm Exp $";
d100 1
a100 2
			ep = strchr(buf, '\n');
			if(ep) *ep = 0;
d146 1
a146 3
		ep = strchr(bufr, '\n');
		if(ep)
			*ep = 0;
@


1.11
log
@use setresgid() to drop privs, it is simply a better and less ambiguous API;
ok deraadt@@ and millert@@ a while ago, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pager.c,v 1.10 2003/05/19 06:30:56 pjanzen Exp $	*/
d65 1
a65 1
static const char rcsid[] = "$OpenBSD: hack.pager.c,v 1.10 2003/05/19 06:30:56 pjanzen Exp $";
d145 2
a146 2
	bufr[CO-1] = 0;
	while(fgets(bufr,CO-1,fp) && (!strip || *bufr == '\t') && !got_intrup){
@


1.10
log
@De-register, ANSIfy, clean up.
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pager.c,v 1.9 2003/05/07 09:48:57 tdeval Exp $	*/
d65 1
a65 1
static const char rcsid[] = "$OpenBSD$";
d438 1
d443 3
a445 3
		/* revoke */
		setegid(getgid());
		setgid(getgid());
@


1.9
log
@Major strings rework.  Ok pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pager.c,v 1.8 2003/03/16 21:22:36 camield Exp $	*/
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.pager.c,v 1.8 2003/03/16 21:22:36 camield Exp $";
a80 1
void done1();
d82 3
d89 1
a89 1
	register char *buf = &bufr[6], *ep, q;
d130 2
a131 1
intruph(){
d136 3
a138 3
page_more(fp,strip)
FILE *fp;
int strip;	/* nr of chars to be stripped from each line (0 or 1) */
d140 1
a140 1
	register char *bufr, *ep;
d166 3
a168 1
set_whole_screen() {	/* called in termcap as soon as LI is known */
d173 4
a176 2
readnews() {
	register int ret;
d185 3
a187 2
set_pager(mode)
register int mode;	/* 0: open  1: wait+close  2: close */
d216 2
a217 2
page_line(s)		/* returns 1 if we should quit */
register char *s;
d253 2
a254 4

cornline(mode, text)
int mode;
char *text;
d262 1
a262 1
	register struct line *tl;
d276 1
a276 1
	    register int len;
d301 1
a301 1
	    register int curline, lth;
d308 2
a309 2
		home ();
		cl_end ();
d313 1
a313 1
		    curs (lth, curline);
d315 1
a315 1
			cl_end ();
d320 6
a325 6
		curs (lth, curline);
		cl_end ();
		cmore (text);
		home ();
		cl_end ();
		docorner (lth, curline-1);
d343 1
a343 1
	while(tl = texthead) {
d349 1
d356 1
a356 1
		bell ();
d362 3
a364 3
page_file(fnam, silent)	/* return: 0 - cannot open fnam; 1 - otherwise */
register char *fnam;
boolean silent;
d370 1
a370 1
	register int fd = open(fnam, O_RDONLY);
d413 5
a417 2
dosh(){
register char *str;
d419 1
a419 1
		if(str = getenv("SHELL"))
a429 13
#ifdef NOWAITINCLUDE
union wait {		/* used only for the cast  (union wait *) 0  */
	int w_status;
	struct {
		unsigned short w_Termsig:7;
		unsigned short w_Coredump:1;
		unsigned short w_Retcode:8;
	} w_T;
};

#else

#ifdef BSD
a430 4
#else
#include	<wait.h>
#endif /* BSD */
#endif /* NOWAITINCLUDE */
d432 3
a434 1
child(wt) {
d436 1
a436 1
	register int f;
@


1.8
log
@hack is free

Thanks to Andries Brouwer, Jay Fenlason and the folks at CWI for their
efforts.

http://www.cwi.nl/~aeb/games/hack/hack.html

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pager.c,v 1.7 2001/08/06 22:59:13 pjanzen Exp $	*/
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.pager.c,v 1.7 2001/08/06 22:59:13 pjanzen Exp $";
d281 1
a281 1
	    (void) strcpy(tl->line_text, text);
@


1.7
log
@Nothing but comments after #endif and #else; heko@@iki.fi
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pager.c,v 1.6 2001/01/28 23:41:45 niklas Exp $	*/
d4 58
a61 1
 * Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985.
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.pager.c,v 1.6 2001/01/28 23:41:45 niklas Exp $";
@


1.6
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d8 1
a8 1
static char rcsid[] = "$OpenBSD: hack.pager.c,v 1.4 1995/03/23 08:31:16 cgd Exp $";
d119 1
a119 1
#endif NEWS
d329 1
a329 1
#else DEF_PAGER
d342 1
a342 1
#endif DEF_PAGER
d361 1
a361 1
#endif SHELL
d379 2
a380 2
#endif BSD
#endif NOWAITINCLUDE
d398 1
a398 1
#endif CHDIR
d414 1
a414 1
#endif WIZARD
d419 1
a419 1
#endif UNIX
@


1.5
log
@$HOME paranoia: never use getenv("HOME") w/o checking for NULL and non-zero
@
text
@d1 2
d8 1
a8 1
static char rcsid[] = "$NetBSD: hack.pager.c,v 1.4 1995/03/23 08:31:16 cgd Exp $";
@


1.4
log
@use O_* defines for open(2) flags and include fcntl.h
@
text
@d383 1
d392 4
a395 1
		(void) chdir(getenv("HOME"));
@


1.3
log
@r?index -> strr?chr
@
text
@d304 1
a304 1
	register int fd = open(fnam, 0);
@


1.2
log
@proper gid revoke
@
text
@d39 1
a39 1
			ep = index(buf, '\n');
d85 1
a85 1
		ep = index(bufr, '\n');
d289 1
a289 1
	while (((c = readchar ()) != 'l') && (c != 's') && !index(quitchars,c))
d291 1
a291 1
	if (!index(quitchars, c))
@


1.1
log
@Initial revision
@
text
@d387 3
a389 2
		(void) setuid(getuid());
		(void) setgid(getgid());
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
