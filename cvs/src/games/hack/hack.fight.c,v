head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.6
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.8
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.26
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.18
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.22
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.20
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.16
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.14
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.12
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.10
	OPENBSD_5_0:1.9.0.8
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.28
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.24
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.22
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.20
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.18
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.16
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.14
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.16
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.14
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.01.09.18.33.15;	author mestre;	state Exp;
branches;
next	1.9;
commitid	cGEyAVlKS2f51J9L;

1.9
date	2009.10.27.23.59.25;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.19.06.30.56;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.07.09.48.57;	author tdeval;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.06.18.50.37;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.16.21.22.35;	author camield;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.06.22.59.13;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.28.23.41.44;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.01.17.07.11.10;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.59;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.59;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.10
log
@This diff is rather large, but it's just simply removing unnecessary headers
, remove some lint-style comments, add missing void to functions without args,
also some function prototypes (extern) were missing their args, so I added them
as they were defined in hack.h

OK tb@@ on separate diffs
@
text
@/*	$OpenBSD: hack.fight.c,v 1.9 2009/10/27 23:59:25 deraadt Exp $	*/

/*
 * Copyright (c) 1985, Stichting Centrum voor Wiskunde en Informatica,
 * Amsterdam
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * - Neither the name of the Stichting Centrum voor Wiskunde en
 * Informatica, nor the names of its contributors may be used to endorse or
 * promote products derived from this software without specific prior
 * written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982 Jay Fenlason <hack@@gnu.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdio.h>

#include "hack.h"

extern struct permonst li_dog, dog, la_dog;

static boolean far_noise;
static long noisetime;

static void monstone(struct monst *);

/* hitmm returns 0 (miss), 1 (hit), or 2 (kill) */
int
hitmm(struct monst * magr, struct monst * mdef)
{
	struct permonst *pa = magr->data, *pd = mdef->data;
	int hit;
	schar tmp;
	boolean vis;

	if(strchr("Eauy", pa->mlet)) return(0);
	if(magr->mfroz) return(0);		/* riv05!a3 */
	tmp = pd->ac + pa->mlevel;
	if(mdef->mconf || mdef->mfroz || mdef->msleep){
		tmp += 4;
		if(mdef->msleep) mdef->msleep = 0;
	}
	hit = (tmp > rnd(20));
	if(hit) mdef->msleep = 0;
	vis = (cansee(magr->mx,magr->my) && cansee(mdef->mx,mdef->my));
	if(vis){
		char buf[BUFSZ];
		if(mdef->mimic) seemimic(mdef);
		if(magr->mimic) seemimic(magr);
		(void) snprintf(buf,sizeof buf,"%s %s", Monnam(magr),
			hit ? "hits" : "misses");
		pline("%s %s.", buf, monnam(mdef));
	} else {
		boolean far = (dist(magr->mx, magr->my) > 15);
		if(far != far_noise || moves-noisetime > 10) {
			far_noise = far;
			noisetime = moves;
			pline("You hear some noises%s.",
				far ? " in the distance" : "");
		}
	}
	if(hit){
		if(magr->data->mlet == 'c' && !magr->cham) {
			magr->mhpmax += 3;
			if(vis) pline("%s is turned to stone!", Monnam(mdef));
			else if(mdef->mtame)
     pline("You have a peculiarly sad feeling for a moment, then it passes.");
			monstone(mdef);
			hit = 2;
		} else
		if((mdef->mhp -= d(pa->damn,pa->damd)) < 1) {
			magr->mhpmax += 1 + rn2(pd->mlevel+1);
			if(magr->mtame && magr->mhpmax > 8*pa->mlevel){
				if(pa == &li_dog) magr->data = pa = &dog;
				else if(pa == &dog) magr->data = pa = &la_dog;
			}
			if(vis) pline("%s is killed!", Monnam(mdef));
			else if(mdef->mtame)
		pline("You have a sad feeling for a moment, then it passes.");
			mondied(mdef);
			hit = 2;
		}
	}
	return(hit);
}

/* drop (perhaps) a cadaver and remove monster */
void
mondied(struct monst *mdef)
{
	struct permonst *pd = mdef->data;

	if(letter(pd->mlet) && rn2(3)){
		(void) mkobj_at(pd->mlet,mdef->mx,mdef->my);
		if(cansee(mdef->mx,mdef->my)){
			unpmon(mdef);
			atl(mdef->mx,mdef->my,fobj->olet);
		}
		stackobj(fobj);
	}
	mondead(mdef);
}

/* drop a rock and remove monster */
static void
monstone(struct monst *mdef)
{
	extern char mlarge[];
	if(strchr(mlarge, mdef->data->mlet))
		mksobj_at(ENORMOUS_ROCK, mdef->mx, mdef->my);
	else
		mksobj_at(ROCK, mdef->mx, mdef->my);
	if(cansee(mdef->mx, mdef->my)){
		unpmon(mdef);
		atl(mdef->mx,mdef->my,fobj->olet);
	}
	mondead(mdef);
}

int
fightm(struct monst *mtmp)
{
	struct monst *mon;

	for(mon = fmon; mon; mon = mon->nmon) if(mon != mtmp) {
		if(DIST(mon->mx,mon->my,mtmp->mx,mtmp->my) < 3)
		    if(rn2(4))
			return(hitmm(mtmp,mon));
	}
	return(-1);
}

/* u is hit by sth, but not a monster */
int
thitu(int tlev, int dam, char *name)
{
	char buf[BUFSZ];

	setan(name,buf,sizeof buf);
	if(u.uac + tlev <= rnd(20)) {
		if(Blind) pline("It misses.");
		else pline("You are almost hit by %s!", buf);
		return(0);
	} else {
		if(Blind) pline("You are hit!");
		else pline("You are hit by %s!", buf);
		losehp(dam,name);
		return(1);
	}
}

char mlarge[] = "bCDdegIlmnoPSsTUwY',&";

/* return TRUE if mon still alive */
boolean
hmon(struct monst *mon, struct obj *obj, int thrown)
{
	int tmp;
	boolean hittxt = FALSE;

	if(!obj){
		tmp = rnd(2);	/* attack with bare hands */
		if(mon->data->mlet == 'c' && !uarmg){
			pline("You hit the cockatrice with your bare hands.");
			pline("You turn to stone ...");
			done_in_by(mon);
		}
	} else if(obj->olet == WEAPON_SYM || obj->otyp == PICK_AXE) {
	    if(obj == uwep && (obj->otyp > SPEAR || obj->otyp < BOOMERANG))
		tmp = rnd(2);
	    else {
		if(strchr(mlarge, mon->data->mlet)) {
			tmp = rnd(objects[obj->otyp].wldam);
			if(obj->otyp == TWO_HANDED_SWORD) tmp += d(2,6);
			else if(obj->otyp == FLAIL) tmp += rnd(4);
		} else {
			tmp = rnd(objects[obj->otyp].wsdam);
		}
		tmp += obj->spe;
		if(!thrown && obj == uwep && obj->otyp == BOOMERANG
		 && !rn2(3)){
		  pline("As you hit %s, the boomerang breaks into splinters.",
				monnam(mon));
			freeinv(obj);
			setworn((struct obj *) 0, obj->owornmask);
			obfree(obj, (struct obj *) 0);
			tmp++;
		}
	    }
	    if(mon->data->mlet == 'O' && obj->otyp == TWO_HANDED_SWORD &&
		!strcmp(ONAME(obj), "Orcrist"))
		tmp += rnd(10);
	} else	switch(obj->otyp) {
		case HEAVY_IRON_BALL:
			tmp = rnd(25); break;
		case EXPENSIVE_CAMERA:
	pline("You succeed in destroying your camera. Congratulations!");
			freeinv(obj);
			if(obj->owornmask)
				setworn((struct obj *) 0, obj->owornmask);
			obfree(obj, (struct obj *) 0);
			return(TRUE);
		case DEAD_COCKATRICE:
			pline("You hit %s with the cockatrice corpse.",
				monnam(mon));
			if(mon->data->mlet == 'c') {
				tmp = 1;
				hittxt = TRUE;
				break;
			}
			pline("%s is turned to stone!", Monnam(mon));
			killed(mon);
			return(FALSE);
		case CLOVE_OF_GARLIC:		/* no effect against demons */
			if(strchr(UNDEAD, mon->data->mlet))
				mon->mflee = 1;
			tmp = 1;
			break;
		default:
			/* non-weapons can damage because of their weight */
			/* (but not too much) */
			tmp = obj->owt/10;
			if(tmp < 1) tmp = 1;
			else tmp = rnd(tmp);
			if(tmp > 6) tmp = 6;
		}

	/****** NOTE: perhaps obj is undefined!! (if !thrown && BOOMERANG) */

	tmp += u.udaminc + dbon();
	if(u.uswallow) {
		if((tmp -= u.uswldtim) <= 0) {
			pline("Your arms are no longer able to hit.");
			return(TRUE);
		}
	}
	if(tmp < 1) tmp = 1;
	mon->mhp -= tmp;
	if(mon->mhp < 1) {
		killed(mon);
		return(FALSE);
	}
	if(mon->mtame && (!mon->mflee || mon->mfleetim)) {
		mon->mflee = 1;			/* Rick Richardson */
		mon->mfleetim += 10*rnd(tmp);
	}

	if(!hittxt) {
		if(thrown)
			/* this assumes that we cannot throw plural things */
			hit( xname(obj)  /* or: objects[obj->otyp].oc_name */,
				mon, exclam(tmp) );
		else if(Blind)
			pline("You hit it.");
		else
			pline("You hit %s%s", monnam(mon), exclam(tmp));
	}

	if(u.umconf && !thrown) {
		if(!Blind) {
			pline("Your hands stop glowing blue.");
			if(!mon->mfroz && !mon->msleep)
				pline("%s appears confused.",Monnam(mon));
		}
		mon->mconf = 1;
		u.umconf = 0;
	}
	return(TRUE);	/* mon still alive */
}

/* try to attack; return FALSE if monster evaded */
/* u.dx and u.dy must be set */
boolean
attack(struct monst *mtmp)
{
	schar tmp;
	boolean malive = TRUE;
	struct permonst *mdat;
	mdat = mtmp->data;

	u_wipe_engr(3);   /* andrew@@orca: prevent unlimited pick-axe attacks */

	if(mdat->mlet == 'L' && !mtmp->mfroz && !mtmp->msleep &&
	   !mtmp->mconf && mtmp->mcansee && !rn2(7) &&
	   (m_move(mtmp, 0) == 2 /* he died */ || /* he moved: */
		mtmp->mx != u.ux+u.dx || mtmp->my != u.uy+u.dy))
		return(FALSE);

	if(mtmp->mimic){
		if(!u.ustuck && !mtmp->mflee) u.ustuck = mtmp;
		switch(levl[u.ux+u.dx][u.uy+u.dy].scrsym){
		case '+':
			pline("The door actually was a Mimic.");
			break;
		case '$':
			pline("The chest was a Mimic!");
			break;
		default:
			pline("Wait! That's a Mimic!");
		}
		wakeup(mtmp);	/* clears mtmp->mimic */
		return(TRUE);
	}

	wakeup(mtmp);

	if(mtmp->mhide && mtmp->mundetected){
		struct obj *obj;

		mtmp->mundetected = 0;
		if((obj = o_at(mtmp->mx,mtmp->my)) && !Blind)
			pline("Wait! There's a %s hiding under %s!",
				mdat->mname, doname(obj));
		return(TRUE);
	}

	tmp = u.uluck + u.ulevel + mdat->ac + abon();
	if(uwep) {
		if(uwep->olet == WEAPON_SYM || uwep->otyp == PICK_AXE)
			tmp += uwep->spe;
		if(uwep->otyp == TWO_HANDED_SWORD) tmp -= 1;
		else if(uwep->otyp == DAGGER) tmp += 2;
		else if(uwep->otyp == CRYSKNIFE) tmp += 3;
		else if(uwep->otyp == SPEAR &&
			strchr("XDne", mdat->mlet)) tmp += 2;
	}
	if(mtmp->msleep) {
		mtmp->msleep = 0;
		tmp += 2;
	}
	if(mtmp->mfroz) {
		tmp += 4;
		if(!rn2(10)) mtmp->mfroz = 0;
	}
	if(mtmp->mflee) tmp += 2;
	if(u.utrap) tmp -= 3;

	/* with a lot of luggage, your agility diminishes */
	tmp -= (inv_weight() + 40)/20;

	if(tmp <= rnd(20) && !u.uswallow){
		if(Blind) pline("You miss it.");
		else pline("You miss %s.",monnam(mtmp));
	} else {
		/* we hit the monster; be careful: it might die! */

		if((malive = hmon(mtmp,uwep,0)) == TRUE) {
		/* monster still alive */
			if(!rn2(25) && mtmp->mhp < mtmp->mhpmax/2) {
				mtmp->mflee = 1;
				if(!rn2(3)) mtmp->mfleetim = rnd(100);
				if(u.ustuck == mtmp && !u.uswallow)
					u.ustuck = 0;
			}
#ifndef NOWORM
			if(mtmp->wormno)
				cutworm(mtmp, u.ux+u.dx, u.uy+u.dy,
					uwep ? uwep->otyp : 0);
#endif /* NOWORM */
		}
		if(mdat->mlet == 'a') {
			if(rn2(2)) {
				pline("You are splashed by the blob's acid!");
				losehp_m(rnd(6), mtmp);
				if(!rn2(30)) corrode_armor();
			}
			if(!rn2(6)) corrode_weapon();
		}
	}
	if(malive && mdat->mlet == 'E' && canseemon(mtmp)
	   && !mtmp->mcan && rn2(3)) {
	    if(mtmp->mcansee) {
	      pline("You are frozen by the floating eye's gaze!");
	      nomul((u.ulevel > 6 || rn2(4)) ? rn1(20,-21) : -200);
	    } else {
	      pline("The blinded floating eye cannot defend itself.");
	      if(!rn2(500)) if((int)u.uluck > LUCKMIN) u.uluck--;
	    }
	}
	return(TRUE);
}
@


1.9
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.fight.c,v 1.8 2003/05/19 06:30:56 pjanzen Exp $	*/
d64 4
a67 2
#include	<stdio.h>
#include	"hack.h"
@


1.8
log
@De-register, ANSIfy, clean up.
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.fight.c,v 1.7 2003/05/07 09:48:57 tdeval Exp $	*/
a62 4

#ifndef lint
static const char rcsid[] = "$OpenBSD$";
#endif /* not lint */
@


1.7
log
@Major strings rework.  Ok pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.fight.c,v 1.6 2003/04/06 18:50:37 deraadt Exp $	*/
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.fight.c,v 1.6 2003/04/06 18:50:37 deraadt Exp $";
d68 1
a70 2
extern char *exclam(), *xname();
extern struct obj *mkobj_at();
d75 2
d78 8
a85 5
hitmm(magr,mdef) register struct monst *magr,*mdef; {
register struct permonst *pa = magr->data, *pd = mdef->data;
int hit;
schar tmp;
boolean vis;
d138 10
a147 9
mondied(mdef) register struct monst *mdef; {
register struct permonst *pd = mdef->data;
		if(letter(pd->mlet) && rn2(3)){
			(void) mkobj_at(pd->mlet,mdef->mx,mdef->my);
			if(cansee(mdef->mx,mdef->my)){
				unpmon(mdef);
				atl(mdef->mx,mdef->my,fobj->olet);
			}
			stackobj(fobj);
d149 3
a151 1
		mondead(mdef);
d155 3
a157 1
monstone(mdef) register struct monst *mdef; {
a168 1
		
d170 5
a174 2
fightm(mtmp) register struct monst *mtmp; {
register struct monst *mon;
d184 2
a185 3
thitu(tlev,dam,name)
register tlev,dam;
register char *name;
d187 2
a188 1
char buf[BUFSZ];
d204 1
d206 1
a206 4
hmon(mon,obj,thrown)	/* return TRUE if mon still alive */
register struct monst *mon;
register struct obj *obj;
register thrown;
d208 1
a208 1
	register tmp;
d323 2
a324 2
attack(mtmp)
register struct monst *mtmp;
d328 1
a328 1
	register struct permonst *mdat;
d358 1
a358 1
		register struct obj *obj;
@


1.6
log
@2451 lines of strdup/sprintf/strcpy whacking.  mostly ok'd by pjanzen
already, but he may have later changes to make still.
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.fight.c,v 1.5 2003/03/16 21:22:35 camield Exp $	*/
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.fight.c,v 1.5 2003/03/16 21:22:35 camield Exp $";
d178 1
a178 1
	setan(name,buf);
@


1.5
log
@hack is free

Thanks to Andries Brouwer, Jay Fenlason and the folks at CWI for their
efforts.

http://www.cwi.nl/~aeb/games/hack/hack.html

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.fight.c,v 1.4 2001/08/06 22:59:13 pjanzen Exp $	*/
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.fight.c,v 1.4 2001/08/06 22:59:13 pjanzen Exp $";
d96 1
a96 1
		(void) sprintf(buf,"%s %s", Monnam(magr),
@


1.4
log
@Nothing but comments after #endif and #else; heko@@iki.fi
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.fight.c,v 1.3 2001/01/28 23:41:44 niklas Exp $	*/
d4 58
a61 1
 * Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985.
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.fight.c,v 1.3 2001/01/28 23:41:44 niklas Exp $";
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d8 1
a8 1
static char rcsid[] = "$OpenBSD: hack.fight.c,v 1.3 1995/03/23 08:30:12 cgd Exp $";
d343 1
a343 1
#endif NOWORM
@


1.2
log
@r?index -> strr?chr
@
text
@d1 2
d8 1
a8 1
static char rcsid[] = "$NetBSD: hack.fight.c,v 1.3 1995/03/23 08:30:12 cgd Exp $";
@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
	if(index("Eauy", pa->mlet)) return(0);
d91 1
a91 1
	if(index(mlarge, mdef->data->mlet))
d154 1
a154 1
		if(index(mlarge, mon->data->mlet)) {
d197 1
a197 1
			if(index(UNDEAD, mon->data->mlet))
d307 1
a307 1
			index("XDne", mdat->mlet)) tmp += 2;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
