head	1.13;
access;
symbols
	OPENBSD_6_2:1.13.0.10
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.13.0.8
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.11.0.8
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.20
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.16
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.14
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.12
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.10
	OPENBSD_5_0:1.10.0.8
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.6
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.28
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.24
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.22
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.20
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.18
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.16
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.14
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.10
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.8
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.6
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.4
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.01.09.18.33.15;	author mestre;	state Exp;
branches;
next	1.12;
commitid	cGEyAVlKS2f51J9L;

1.12
date	2015.09.27.05.13.11;	author guenther;	state Exp;
branches;
next	1.11;
commitid	XzWkIYKZztPpIW70;

1.11
date	2014.03.11.07.41.10;	author guenther;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.27.23.59.25;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.19.09.00.54;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.19.06.30.56;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.07.09.48.57;	author tdeval;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.06.18.50.37;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.16.21.22.36;	author camield;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.06.22.59.13;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.28.23.41.45;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	98.08.11.15.31.47;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.01;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.13
log
@This diff is rather large, but it's just simply removing unnecessary headers
, remove some lint-style comments, add missing void to functions without args,
also some function prototypes (extern) were missing their args, so I added them
as they were defined in hack.h

OK tb@@ on separate diffs
@
text
@/*	$OpenBSD: hack.pri.c,v 1.12 2015/09/27 05:13:11 guenther Exp $	*/

/*
 * Copyright (c) 1985, Stichting Centrum voor Wiskunde en Informatica,
 * Amsterdam
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * - Neither the name of the Stichting Centrum voor Wiskunde en
 * Informatica, nor the names of its contributors may be used to endorse or
 * promote products derived from this software without specific prior
 * written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982 Jay Fenlason <hack@@gnu.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <curses.h>
#include <stdio.h>
#include <stdlib.h>

#include "hack.h"

xchar scrlx, scrhx, scrly, scrhy;	/* corners of new area on screen */

extern char *hu_stat[];	/* in eat.c */
extern char *CD;

static void cornbot(int);

void
swallowed(void)
{
	char ulook[] = "|@@|";
	ulook[1] = u.usym;

	cls();
	curs(u.ux-1, u.uy+1);
	fputs("/-\\", stdout);
	curx = u.ux+2;
	curs(u.ux-1, u.uy+2);
	fputs(ulook, stdout);
	curx = u.ux+2;
	curs(u.ux-1, u.uy+3);
	fputs("\\-/", stdout);
	curx = u.ux+2;
	u.udispl = 1;
	u.udisx = u.ux;
	u.udisy = u.uy;
}


boolean panicking;

void
panic(const char *str, ...)
{
	va_list ap;

	if(panicking++) exit(1);    /* avoid loops - this should never happen*/
	home();
	puts(" Suddenly, the dungeon collapses.");
	fputs(" ERROR:  ", stdout);
	va_start(ap, str);
	vprintf(str, ap);
	va_end(ap);
#ifdef DEBUG
#ifdef UNIX
	if(!fork())
		abort();	/* generate core dump */
#endif /* UNIX */
#endif /* DEBUG */
	more();			/* contains a fflush() */
	done("panicked");
}

void
atl(int x, int y, int ch)
{
	struct rm *crm = &levl[x][y];

	if(x<0 || x>COLNO-1 || y<0 || y>ROWNO-1){
		impossible("atl(%d,%d,%c)",x,y,ch);
		return;
	}
	if(crm->seen && crm->scrsym == ch) return;
	crm->scrsym = ch;
	crm->new = 1;
	on_scr(x,y);
}

void
on_scr(int x, int y)
{
	if(x < scrlx) scrlx = x;
	if(x > scrhx) scrhx = x;
	if(y < scrly) scrly = y;
	if(y > scrhy) scrhy = y;
}

/* call: (x,y) - display
 *	(-1,0) - close (leave last symbol)
 *	(-1,-1)- close (undo last symbol)
 *	(-1,let)-open: initialize symbol
 *	(-2,let)-change let
 */
void
tmp_at(schar x, schar y)
{
	static schar prevx, prevy;
	static char let;

	if((int)x == -2){	/* change let call */
		let = y;
		return;
	}
	if((int)x == -1 && (int)y >= 0){	/* open or close call */
		let = y;
		prevx = -1;
		return;
	}
	if(prevx >= 0 && cansee(prevx,prevy)) {
		delay_output(50);
		prl(prevx, prevy);	/* in case there was a monster */
		at(prevx, prevy, levl[(int)prevx][(int)prevy].scrsym);
	}
	if(x >= 0){	/* normal call */
		if(cansee(x,y)) at(x,y,let);
		prevx = x;
		prevy = y;
	} else {	/* close call */
		let = 0;
		prevx = -1;
	}
}

/* like the previous, but the symbols are first erased on completion */
void
Tmp_at(schar x, schar y)
{
	static char let;
	static xchar cnt;
	static coord tc[COLNO];		/* but watch reflecting beams! */
	int xx,yy;

	if((int)x == -1) {
		if(y > 0) {	/* open call */
			let = y;
			cnt = 0;
			return;
		}
		/* close call (do not distinguish y==0 and y==-1) */
		while(cnt--) {
			xx = tc[(int)cnt].x;
			yy = tc[(int)cnt].y;
			prl(xx, yy);
			at(xx, yy, levl[xx][yy].scrsym);
		}
		cnt = let = 0;	/* superfluous */
		return;
	}
	if((int)x == -2) {	/* change let call */
		let = y;
		return;
	}
	/* normal call */
	if(cansee(x,y)) {
		if(cnt) delay_output(50);
		at(x,y,let);
		tc[(int)cnt].x = x;
		tc[(int)cnt].y = y;
		if(++cnt >= COLNO) panic("Tmp_at overflow?");
		levl[(int)x][(int)y].new = 0;	/* prevent pline-nscr erasing --- */
	}
}

void
setclipped(void)
{
	error("Hack needs a screen of size at least %d by %d.\n",
		ROWNO+2, COLNO);
}

void
at(xchar x, xchar y, char ch)
{
	if(x < 0 || x > COLNO-1 || y < 0 || y > ROWNO-1) {
		impossible("At gets 0%o at %d %d.", ch, x, y);
		return;
	}
	if(!ch) {
		impossible("At gets null at %d %d.", x, y);
		return;
	}
	y += 2;
	curs(x,y);
	(void) putchar(ch);
	curx++;
}

void
prme(void)
{
	if(!Invisible) at(u.ux,u.uy,u.usym);
}

int
doredraw(void)
{
	docrt();
	return(0);
}

void
docrt(void)
{
	int x,y;
	struct rm *room;
	struct monst *mtmp;

	if(u.uswallow) {
		swallowed();
		return;
	}
	cls();

/* Some ridiculous code to get display of @@ and monsters (almost) right */
	if(!Invisible) {
		levl[(int)(u.udisx = u.ux)][(int)(u.udisy = u.uy)].scrsym = u.usym;
		levl[(int)u.udisx][(int)u.udisy].seen = 1;
		u.udispl = 1;
	} else	u.udispl = 0;

	seemons();	/* reset old positions */
	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
		mtmp->mdispl = 0;
	seemons();	/* force new positions to be shown */
/* This nonsense should disappear soon --------------------------------- */

	for(y = 0; y < ROWNO; y++)
		for(x = 0; x < COLNO; x++)
			if((room = &levl[x][y])->new) {
				room->new = 0;
				at(x,y,room->scrsym);
			} else if(room->seen)
				at(x,y,room->scrsym);
	scrlx = COLNO;
	scrly = ROWNO;
	scrhx = scrhy = 0;
	flags.botlx = 1;
	bot();
}

void
docorner(int xmin, int ymax)
{
	int x,y;
	struct rm *room;
	struct monst *mtmp;

	if(u.uswallow) {	/* Can be done more efficiently */
		swallowed();
		return;
	}

	seemons();	/* reset old positions */
	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
	    if(mtmp->mx >= xmin && mtmp->my < ymax)
		mtmp->mdispl = 0;
	seemons();	/* force new positions to be shown */

	for(y = 0; y < ymax; y++) {
		if(y > ROWNO && CD) break;
		curs(xmin,y+2);
		cl_end();
		if(y < ROWNO) {
		    for(x = xmin; x < COLNO; x++) {
			if((room = &levl[x][y])->new) {
				room->new = 0;
				at(x,y,room->scrsym);
			} else
				if(room->seen)
					at(x,y,room->scrsym);
		    }
		}
	}
	if(ymax > ROWNO) {
		cornbot(xmin-1);
		if(ymax > ROWNO+1 && CD) {
			curs(1,ROWNO+3);
			cl_eos();
		}
	}
}

void
curs_on_u(void)
{
	curs(u.ux, u.uy+2);
}

void
pru(void)
{
	if(u.udispl && (Invisible || u.udisx != u.ux || u.udisy != u.uy))
		/* if(! levl[u.udisx][u.udisy].new) */
			if(!vism_at(u.udisx, u.udisy))
				newsym(u.udisx, u.udisy);
	if(Invisible) {
		u.udispl = 0;
		prl(u.ux,u.uy);
	} else
	if(!u.udispl || u.udisx != u.ux || u.udisy != u.uy) {
		atl(u.ux, u.uy, u.usym);
		u.udispl = 1;
		u.udisx = u.ux;
		u.udisy = u.uy;
	}
	levl[(int)u.ux][(int)u.uy].seen = 1;
}

#ifndef NOWORM
extern struct wseg *m_atseg;
#endif /* NOWORM */

/* print a position that is visible for @@ */
void
prl(int x, int y)
{
	struct rm *room;
	struct monst *mtmp;
	struct obj *otmp;

	if(x == u.ux && y == u.uy && (!Invisible)) {
		pru();
		return;
	}
	if(!isok(x,y)) return;
	room = &levl[x][y];
	if((!room->typ) ||
	   (IS_ROCK(room->typ) && levl[(int)u.ux][(int)u.uy].typ == CORR))
		return;
	if((mtmp = m_at(x,y)) && !mtmp->mhide &&
		(!mtmp->minvis || See_invisible)) {
#ifndef NOWORM
		if(m_atseg)
			pwseg(m_atseg);
		else
#endif /* NOWORM */
		pmon(mtmp);
	}
	else if((otmp = o_at(x,y)) && room->typ != POOL)
		atl(x,y,otmp->olet);
	else if(mtmp && (!mtmp->minvis || See_invisible)) {
		/* must be a hiding monster, but not hiding right now */
		/* assume for the moment that long worms do not hide */
		pmon(mtmp);
	}
	else if(g_at(x,y) && room->typ != POOL)
		atl(x,y,'$');
	else if(!room->seen || room->scrsym == ' ') {
		room->new = room->seen = 1;
		newsym(x,y);
		on_scr(x,y);
	}
	room->seen = 1;
}

char
news0(xchar x, xchar y)
{
	struct obj *otmp;
	struct trap *ttmp;
	struct rm *room;
	char tmp;

	room = &levl[(int)x][(int)y];
	if(!room->seen) tmp = ' ';
	else if(room->typ == POOL) tmp = POOL_SYM;
	else if(!Blind && (otmp = o_at(x,y))) tmp = otmp->olet;
	else if(!Blind && g_at(x,y)) tmp = '$';
	else if(x == xupstair && y == yupstair) tmp = '<';
	else if(x == xdnstair && y == ydnstair) tmp = '>';
	else if((ttmp = t_at(x,y)) && ttmp->tseen) tmp = '^';
	else switch(room->typ) {
	case SCORR:
	case SDOOR:
		tmp = room->scrsym;	/* %% wrong after killing mimic ! */
		break;
	case HWALL:
		tmp = '-';
		break;
	case VWALL:
		tmp = '|';
		break;
	case LDOOR:
	case DOOR:
		tmp = '+';
		break;
	case CORR:
		tmp = CORR_SYM;
		break;
	case ROOM:
		if(room->lit || cansee(x,y) || Blind) tmp = '.';
		else tmp = ' ';
		break;
/*
	case POOL:
		tmp = POOL_SYM;
		break;
*/
	default:
		tmp = ERRCHAR;
	}
	return(tmp);
}

void
newsym(int x, int y)
{
	atl(x,y,news0(x,y));
}

/* used with wand of digging (or pick-axe): fill scrsym and force display */
/* also when a POOL evaporates */
void
mnewsym(int x, int y)
{
	struct rm *room;
	char newscrsym;

	if(!vism_at(x,y)) {
		room = &levl[x][y];
		newscrsym = news0(x,y);
		if(room->scrsym != newscrsym) {
			room->scrsym = newscrsym;
			room->seen = 0;
		}
	}
}

void
nosee(int x, int y)
{
	struct rm *room;

	if(!isok(x,y)) return;
	room = &levl[x][y];
	if(room->scrsym == '.' && !room->lit && !Blind) {
		room->scrsym = ' ';
		room->new = 1;
		on_scr(x,y);
	}
}

#ifndef QUEST
void
prl1(int x, int y)
{
	if(u.dx) {
		if(u.dy) {
			prl(x-(2*u.dx),y);
			prl(x-u.dx,y);
			prl(x,y);
			prl(x,y-u.dy);
			prl(x,y-(2*u.dy));
		} else {
			prl(x,y-1);
			prl(x,y);
			prl(x,y+1);
		}
	} else {
		prl(x-1,y);
		prl(x,y);
		prl(x+1,y);
	}
}

void
nose1(int x, int y)
{
	if(u.dx) {
		if(u.dy) {
			nosee(x,u.uy);
			nosee(x,u.uy-u.dy);
			nosee(x,y);
			nosee(u.ux-u.dx,y);
			nosee(u.ux,y);
		} else {
			nosee(x,y-1);
			nosee(x,y);
			nosee(x,y+1);
		}
	} else {
		nosee(x-1,y);
		nosee(x,y);
		nosee(x+1,y);
	}
}
#endif /* QUEST */

int
vism_at(int x, int y)
{
	struct monst *mtmp;

	return((x == u.ux && y == u.uy && !Invisible)
			? 1 :
	       (mtmp = m_at(x,y))
			? ((Blind && Telepat) || canseemon(mtmp)) :
		0);
}

void
unpobj(struct obj *obj)
{
/* 	if(obj->odispl){
		if(!vism_at(obj->odx, obj->ody))
			newsym(obj->odx, obj->ody);
		obj->odispl = 0;
	}
*/
	if(!vism_at(obj->ox,obj->oy))
		newsym(obj->ox,obj->oy);
}

void
seeobjs(void)
{
	struct obj *obj, *obj2;

	for(obj = fobj; obj; obj = obj2) {
		obj2 = obj->nobj;
		if(obj->olet == FOOD_SYM && obj->otyp >= CORPSE
			&& obj->age + 250 < moves)
				delobj(obj);
	}
	for(obj = invent; obj; obj = obj2) {
		obj2 = obj->nobj;
		if(obj->olet == FOOD_SYM && obj->otyp >= CORPSE
			&& obj->age + 250 < moves)
				useup(obj);
	}
}

void
seemons(void)
{
	struct monst *mtmp;

	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon){
		if(mtmp->data->mlet == ';')
			mtmp->minvis = (u.ustuck != mtmp &&
					levl[(int)mtmp->mx][(int)mtmp->my].typ == POOL);
		pmon(mtmp);
#ifndef NOWORM
		if(mtmp->wormno) wormsee(mtmp->wormno);
#endif /* NOWORM */
	}
}

void
pmon(struct monst *mon)
{
	int show = (Blind && Telepat) || canseemon(mon);

	if(mon->mdispl){
		if(mon->mdx != mon->mx || mon->mdy != mon->my || !show)
			unpmon(mon);
	}
	if(show && !mon->mdispl){
		atl(mon->mx,mon->my,
		 (!mon->mappearance
		  || u.uprops[PROP(RIN_PROTECTION_FROM_SHAPE_CHANGERS)].p_flgs
		 ) ? mon->data->mlet : mon->mappearance);
		mon->mdispl = 1;
		mon->mdx = mon->mx;
		mon->mdy = mon->my;
	}
}

void
unpmon(struct monst *mon)
{
	if(mon->mdispl){
		newsym(mon->mdx, mon->mdy);
		mon->mdispl = 0;
	}
}

void
nscr(void)
{
	int x,y;
	struct rm *room;

	if(u.uswallow || u.ux == FAR || flags.nscrinh) return;
	pru();
	for(y = scrly; y <= scrhy; y++)
		for(x = scrlx; x <= scrhx; x++)
			if((room = &levl[x][y])->new) {
				room->new = 0;
				at(x,y,room->scrsym);
			}
	scrhx = scrhy = 0;
	scrlx = COLNO;
	scrly = ROWNO;
}

/* 100 suffices for bot(); no relation with COLNO */
char oldbot[100], newbot[100];

static void
cornbot(int lth)
{
	if(lth < sizeof(oldbot)) {
		oldbot[lth] = 0;
		flags.botl = 1;
	}
}

void
bot(void)
{
	char *ob = oldbot, *nb = newbot, *bp;
	int i;

	if(flags.botlx) *ob = 0;
	flags.botl = flags.botlx = 0;
#ifdef GOLD_ON_BOTL
	(void) snprintf(newbot, sizeof newbot,
		"Level %-2d  Gold %-5lu  Hp %3d(%d)  Ac %-2d  Str ",
		dlevel, u.ugold, u.uhp, u.uhpmax, u.uac);
#else
	(void) snprintf(newbot, sizeof newbot,
		"Level %-2d   Hp %3d(%d)   Ac %-2d   Str ",
		dlevel,  u.uhp, u.uhpmax, u.uac);
#endif /* GOLD_ON_BOTL */
	if(u.ustr>18) {
	    if(u.ustr>117)
		(void) strlcat(newbot,"18/**",sizeof newbot);
	    else {
		bp = eos(newbot);
		(void) snprintf(bp, newbot + sizeof newbot - bp,
		  "18/%02d",u.ustr-18);
	    }
	} else {
	    bp = eos(newbot);
	    (void) snprintf(bp, newbot + sizeof newbot - bp, "%-2d   ",u.ustr);
	}
	bp = eos(newbot);
#ifdef EXP_ON_BOTL
	(void) snprintf(bp, newbot + sizeof newbot - bp,
	  "  Exp %2d/%-5lu ", u.ulevel,u.uexp);
#else
	(void) snprintf(bp, newbot + sizeof newbot - bp,
	  "   Exp %2u  ", u.ulevel);
#endif /* EXP_ON_BOTL */
	(void) strlcat(newbot, hu_stat[u.uhs], sizeof newbot);
	if(flags.time) {
	    bp = eos(newbot);
	    (void) snprintf(bp, newbot + sizeof newbot - bp, "  %ld", moves);
	}
	if(strlen(newbot) >= COLNO) {
		char *bp0, *bp1;
		bp0 = bp1 = newbot;
		do {
			if(*bp0 != ' ' || bp0[1] != ' ' || bp0[2] != ' ')
				*bp1++ = *bp0;
		} while(*bp0++);
	}
	for(i = 1; i<COLNO; i++) {
		if(*ob != *nb){
			curs(i,ROWNO+2);
			(void) putchar(*nb ? *nb : ' ');
			curx++;
		}
		if(*ob) ob++;
		if(*nb) nb++;
	}
	(void) strlcpy(oldbot, newbot, sizeof oldbot);
}

#ifdef WAN_PROBING
mstatusline(mtmp) struct monst *mtmp; {
	pline("Status of %s: ", monnam(mtmp));
	pline("Level %-2d  Gold %-5lu  Hp %3d(%d)  Ac %-2d  Dam %d",
	    mtmp->data->mlevel, mtmp->mgold, mtmp->mhp, mtmp->mhpmax,
	    mtmp->data->ac, (mtmp->data->damn + 1) * (mtmp->data->damd + 1));
}
#endif /* WAN_PROBING */

void
cls(void)
{
	if(flags.toplin == 1)
		more();
	flags.toplin = 0;

	clr_screen();

	flags.botlx = 1;
}
@


1.12
log
@Annotate funcs with __attribute__((printf(...))) and clean up the fallout:
 * lots of foo(str) --> foo("%s", str) transformations
 * one totally insane foo(fmt, ap) --> vfoo(fmt, ap) conversion: how did
   this ever work?
 * prefer const char[] over char* for static format strings, as it lets
   gcc check the format and eliminates an unnecessary pointer

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pri.c,v 1.11 2014/03/11 07:41:10 guenther Exp $	*/
d67 1
a67 1
#include <stdarg.h>
d78 1
a78 1
swallowed()
d224 1
a224 1
setclipped()
d248 1
a248 1
prme()
d254 1
a254 1
doredraw()
d261 1
a261 1
docrt()
d343 1
a343 1
curs_on_u()
d349 1
a349 1
pru()
d574 1
a574 1
seeobjs()
d593 1
a593 1
seemons()
d638 1
a638 1
nscr()
d669 1
a669 1
bot()
d740 1
a740 1
cls()
@


1.11
log
@lint is dead (long live the lint!)
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pri.c,v 1.10 2009/10/27 23:59:25 deraadt Exp $	*/
a98 1
/*VARARGS1*/
d102 1
a102 1
panic(char *str, ...)
@


1.10
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pri.c,v 1.9 2003/05/19 09:00:54 pjanzen Exp $	*/
a233 2
#ifndef lint
	/* if xchar is unsigned, lint will complain about  if(x < 0)  */
a237 1
#endif /* lint */
@


1.9
log
@A few more includes discovered in a -fno-builtin compile
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pri.c,v 1.8 2003/05/19 06:30:56 pjanzen Exp $	*/
a62 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: hack.pri.c,v 1.8 2003/05/19 06:30:56 pjanzen Exp $";
#endif /* not lint */
@


1.8
log
@De-register, ANSIfy, clean up.
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pri.c,v 1.7 2003/05/07 09:48:57 tdeval Exp $	*/
d65 1
a65 1
static const char rcsid[] = "$OpenBSD$";
d70 1
@


1.7
log
@Major strings rework.  Ok pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pri.c,v 1.6 2003/04/06 18:50:37 deraadt Exp $	*/
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.pri.c,v 1.6 2003/04/06 18:50:37 deraadt Exp $";
d68 3
d72 1
a72 1
#include <stdio.h>
d78 3
d105 2
a106 2
panic(str,a1,a2,a3,a4,a5,a6)
char *str;
d108 2
d114 3
a116 1
	printf(str,a1,a2,a3,a4,a5,a6);
d127 2
a128 2
atl(x,y,ch)
register x,y;
d130 1
a130 1
	register struct rm *crm = &levl[x][y];
d142 2
a143 2
on_scr(x,y)
register x,y;
d152 10
a161 5
	(-1,0) - close (leave last symbol)
	(-1,-1)- close (undo last symbol)
	(-1,let)-open: initialize symbol
	(-2,let)-change let
*/
a162 3
tmp_at(x,y) schar x,y; {
static schar prevx, prevy;
static char let;
d175 1
a175 1
		at(prevx, prevy, levl[prevx][prevy].scrsym);
d188 8
a195 5
Tmp_at(x,y) schar x,y; {
static char let;
static xchar cnt;
static coord tc[COLNO];		/* but watch reflecting beams! */
register xx,yy;
d204 2
a205 2
			xx = tc[cnt].x;
			yy = tc[cnt].y;
d220 2
a221 2
		tc[cnt].x = x;
		tc[cnt].y = y;
d223 1
a223 1
		levl[x][y].new = 0;	/* prevent pline-nscr erasing --- */
d227 3
a229 1
setclipped(){
d234 2
a235 3
at(x,y,ch)
register xchar x,y;
char ch;
d254 3
a256 1
prme(){
d260 1
d267 1
d270 3
a272 3
	register x,y;
	register struct rm *room;
	register struct monst *mtmp;
d282 2
a283 2
		levl[(u.udisx = u.ux)][(u.udisy = u.uy)].scrsym = u.usym;
		levl[u.udisx][u.udisy].seen = 1;
d307 6
a312 4
docorner(xmin,ymax) register xmin,ymax; {
	register x,y;
	register struct rm *room;
	register struct monst *mtmp;
d349 3
a351 1
curs_on_u(){
d355 1
d372 1
a372 1
	levl[u.ux][u.uy].seen = 1;
a375 1
#include	"def.wseg.h"
d380 2
a381 1
prl(x,y)
d383 3
a385 3
	register struct rm *room;
	register struct monst *mtmp;
	register struct obj *otmp;
d394 1
a394 1
	   (IS_ROCK(room->typ) && levl[u.ux][u.uy].typ == CORR))
d423 1
a423 2
news0(x,y)
register xchar x,y;
d425 2
a426 2
	register struct obj *otmp;
	register struct trap *ttmp;
d428 1
a428 1
	register char tmp;
d430 1
a430 1
	room = &levl[x][y];
d471 2
a472 2
newsym(x,y)
register x,y;
d479 2
a480 2
mnewsym(x,y)
register x,y;
d482 1
a482 1
	register struct rm *room;
d495 2
a496 2
nosee(x,y)
register x,y;
d498 1
a498 1
	register struct rm *room;
d510 2
a511 2
prl1(x,y)
register x,y;
d532 2
a533 2
nose1(x,y)
register x,y;
d555 2
a556 2
vism_at(x,y)
register x,y;
d558 1
a558 1
	register struct monst *mtmp;
d567 3
a569 21
#ifdef NEWSCR
pobj(obj) register struct obj *obj; {
register int show = (!obj->oinvis || See_invisible) &&
		cansee(obj->ox,obj->oy);
	if(obj->odispl){
		if(obj->odx != obj->ox || obj->ody != obj->oy || !show)
		if(!vism_at(obj->odx,obj->ody)){
			newsym(obj->odx, obj->ody);
			obj->odispl = 0;
		}
	}
	if(show && !vism_at(obj->ox,obj->oy)){
		atl(obj->ox,obj->oy,obj->olet);
		obj->odispl = 1;
		obj->odx = obj->ox;
		obj->ody = obj->oy;
	}
}
#endif /* NEWSCR */

unpobj(obj) register struct obj *obj; {
d580 5
a584 2
seeobjs(){
register struct obj *obj, *obj2;
d599 5
a603 2
seemons(){
register struct monst *mtmp;
d607 1
a607 1
					levl[mtmp->mx][mtmp->my].typ == POOL);
d615 5
a619 2
pmon(mon) register struct monst *mon; {
register int show = (Blind && Telepat) || canseemon(mon);
d635 3
a637 1
unpmon(mon) register struct monst *mon; {
d644 1
d647 2
a648 2
	register x,y;
	register struct rm *room;
d665 3
a667 2
cornbot(lth)
register int lth;
d675 1
d678 3
a680 3
register char *ob = oldbot, *nb = newbot, *bp;
register int i;
extern char *eos();
d718 1
a718 1
		register char *bp0, *bp1;
d738 1
a738 1
mstatusline(mtmp) register struct monst *mtmp; {
d746 3
a748 1
cls(){
d753 1
a753 1
	clear_screen();
@


1.6
log
@2451 lines of strdup/sprintf/strcpy whacking.  mostly ok'd by pjanzen
already, but he may have later changes to make still.
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pri.c,v 1.5 2003/03/16 21:22:36 camield Exp $	*/
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.pri.c,v 1.5 2003/03/16 21:22:36 camield Exp $";
d658 1
a658 1
register char *ob = oldbot, *nb = newbot;
d675 10
a684 4
	    else
		(void) sprintf(eos(newbot), "18/%02d",u.ustr-18);
	} else
	    (void) sprintf(eos(newbot), "%-2d   ",u.ustr);
d686 2
a687 1
	(void) sprintf(eos(newbot), "  Exp %2d/%-5lu ", u.ulevel,u.uexp);
d689 2
a690 1
	(void) sprintf(eos(newbot), "   Exp %2u  ", u.ulevel);
d693 4
a696 2
	if(flags.time)
	    (void) sprintf(eos(newbot), "  %ld", moves);
@


1.5
log
@hack is free

Thanks to Andries Brouwer, Jay Fenlason and the folks at CWI for their
efforts.

http://www.cwi.nl/~aeb/games/hack/hack.html

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pri.c,v 1.4 2001/08/06 22:59:13 pjanzen Exp $	*/
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.pri.c,v 1.4 2001/08/06 22:59:13 pjanzen Exp $";
d664 1
a664 1
	(void) sprintf(newbot,
d668 1
a668 1
	(void) sprintf(newbot,
d674 1
a674 1
		(void) strcat(newbot,"18/**");
d684 1
a684 1
	(void) strcat(newbot, hu_stat[u.uhs]);
d704 1
a704 1
	(void) strcpy(oldbot, newbot);
@


1.4
log
@Nothing but comments after #endif and #else; heko@@iki.fi
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.pri.c,v 1.3 2001/01/28 23:41:45 niklas Exp $	*/
d4 58
a61 1
 * Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985.
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.pri.c,v 1.3 2001/01/28 23:41:45 niklas Exp $";
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d8 1
a8 1
static char rcsid[] = "$OpenBSD: hack.pri.c,v 1.4 1995/03/23 08:31:20 cgd Exp $";
d54 2
a55 2
#endif UNIX
#endif DEBUG
d170 1
a170 1
#endif lint
d296 1
a296 1
#endif NOWORM
d320 1
a320 1
#endif NOWORM
d472 1
a472 1
#endif QUEST
d504 1
a504 1
#endif NEWSCR
d542 1
a542 1
#endif NOWORM
d614 1
a614 1
#endif GOLD_ON_BOTL
d626 1
a626 1
#endif EXP_ON_BOTL
d657 1
a657 1
#endif WAN_PROBING
@


1.2
log
@curses has its own delay_output() function, so use that instead of own own
@
text
@d1 2
d8 1
a8 1
static char rcsid[] = "$NetBSD: hack.pri.c,v 1.4 1995/03/23 08:31:20 cgd Exp $";
@


1.1
log
@Initial revision
@
text
@d102 1
a102 1
		delay_output();
d144 1
a144 1
		if(cnt) delay_output();
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
