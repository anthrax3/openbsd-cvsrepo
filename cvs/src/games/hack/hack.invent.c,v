head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.8
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.10.0.8
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.20
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.16
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.14
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.12
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.10
	OPENBSD_5_0:1.9.0.8
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.28
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.24
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.22
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.20
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.18
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.16
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.14
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.2.0.16
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.14
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.01.09.21.54.11;	author mestre;	state Exp;
branches;
next	1.13;
commitid	ve4zhTqqRMMVn77Z;

1.13
date	2016.01.09.18.33.15;	author mestre;	state Exp;
branches;
next	1.12;
commitid	cGEyAVlKS2f51J9L;

1.12
date	2015.10.24.17.37.56;	author mmcc;	state Exp;
branches;
next	1.11;
commitid	RhzlimB0YA341qnE;

1.11
date	2015.09.27.05.13.11;	author guenther;	state Exp;
branches;
next	1.10;
commitid	XzWkIYKZztPpIW70;

1.10
date	2014.03.11.08.05.15;	author guenther;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.27.23.59.25;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.19.06.30.56;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.06.18.50.37;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.16.21.22.35;	author camield;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.06.22.59.13;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.28.23.41.44;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.04.20.40.50;	author todd;	state Exp;
branches;
next	1.2;

1.2
date	97.01.17.07.11.11;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.59;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.59;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Remove several casts to (char *) 0 and replace them by NULL

Prompted and OK by tb@@
@
text
@/*	$OpenBSD: hack.invent.c,v 1.13 2016/01/09 18:33:15 mestre Exp $	*/

/*
 * Copyright (c) 1985, Stichting Centrum voor Wiskunde en Informatica,
 * Amsterdam
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * - Neither the name of the Stichting Centrum voor Wiskunde en
 * Informatica, nor the names of its contributors may be used to endorse or
 * promote products derived from this software without specific prior
 * written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982 Jay Fenlason <hack@@gnu.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>

#include "hack.h"

extern struct obj zeroobj;
extern char morc;
extern char quitchars[];

#ifndef NOWORM
extern struct wseg *wsegs[32];
#endif /* NOWORM */

#define	NOINVSYM	'#'

static int lastinvnr = 51;	/* 0 ... 51 */

static void assigninvlet(struct obj *);
static char obj_to_let(struct obj *);
static char *xprname(struct obj *, char);
static void doinv(char *);
static int  merged(struct obj *, struct obj *, int);


static void
assigninvlet(struct obj *otmp)
{
	boolean inuse[52];
	int i;
	struct obj *obj;

	for(i = 0; i < 52; i++) inuse[i] = FALSE;
	for(obj = invent; obj; obj = obj->nobj) if(obj != otmp) {
		i = obj->invlet;
		if('a' <= i && i <= 'z') inuse[i - 'a'] = TRUE; else
		if('A' <= i && i <= 'Z') inuse[i - 'A' + 26] = TRUE;
		if(i == otmp->invlet) otmp->invlet = 0;
	}
	if((i = otmp->invlet) &&
	    (('a' <= i && i <= 'z') || ('A' <= i && i <= 'Z')))
		return;
	for(i = lastinvnr+1; i != lastinvnr; i++) {
		if(i == 52) { i = -1; continue; }
		if(!inuse[i]) break;
	}
	otmp->invlet = (inuse[i] ? NOINVSYM :
			(i < 26) ? ('a'+i) : ('A'+i-26));
	lastinvnr = i;
}

struct obj *
addinv(struct obj *obj)
{
	struct obj *otmp;

	/* merge or attach to end of chain */
	if(!invent) {
		invent = obj;
		otmp = 0;
	} else
	for(otmp = invent; /* otmp */; otmp = otmp->nobj) {
		if(merged(otmp, obj, 0))
			return(otmp);
		if(!otmp->nobj) {
			otmp->nobj = obj;
			break;
		}
	}
	obj->nobj = 0;

	if(flags.invlet_constant) {
		assigninvlet(obj);
		/*
		 * The ordering of the chain is nowhere significant
		 * so in case you prefer some other order than the
		 * historical one, change the code below.
		 */
		if(otmp) {	/* find proper place in chain */
			otmp->nobj = 0;
			if((invent->invlet ^ 040) > (obj->invlet ^ 040)) {
				obj->nobj = invent;
				invent = obj;
			} else
			for(otmp = invent; ; otmp = otmp->nobj) {
			    if(!otmp->nobj ||
				(otmp->nobj->invlet ^ 040) > (obj->invlet ^ 040)){
				obj->nobj = otmp->nobj;
				otmp->nobj = obj;
				break;
			    }
			}
		}
	}

	return(obj);
}

void
useup(struct obj *obj)
{
	if(obj->quan > 1){
		obj->quan--;
		obj->owt = weight(obj);
	} else {
		setnotworn(obj);
		freeinv(obj);
		obfree(obj, (struct obj *) 0);
	}
}

void
freeinv(struct obj *obj)
{
	struct obj *otmp;

	if(obj == invent)
		invent = invent->nobj;
	else {
		for(otmp = invent; otmp->nobj != obj; otmp = otmp->nobj)
			if(!otmp->nobj) panic("freeinv");
		otmp->nobj = obj->nobj;
	}
}

/* destroy object in fobj chain (if unpaid, it remains on the bill) */
void
delobj(struct obj *obj)
{
	freeobj(obj);
	unpobj(obj);
	obfree(obj, (struct obj *) 0);
}

/* unlink obj from chain starting with fobj */
void
freeobj(struct obj *obj)
{
	struct obj *otmp;

	if(obj == fobj) fobj = fobj->nobj;
	else {
		for(otmp = fobj; otmp->nobj != obj; otmp = otmp->nobj)
			if(!otmp) panic("error in freeobj");
		otmp->nobj = obj->nobj;
	}
}

/* Note: freegold throws away its argument! */
void
freegold(struct gold *gold)
{
	struct gold *gtmp;

	if(gold == fgold) fgold = gold->ngold;
	else {
		for(gtmp = fgold; gtmp->ngold != gold; gtmp = gtmp->ngold)
			if(!gtmp) panic("error in freegold");
		gtmp->ngold = gold->ngold;
	}
	free(gold);
}

void
deltrap(struct trap *trap)
{
	struct trap *ttmp;

	if(trap == ftrap)
		ftrap = ftrap->ntrap;
	else {
		for(ttmp = ftrap; ttmp->ntrap != trap; ttmp = ttmp->ntrap) ;
		ttmp->ntrap = trap->ntrap;
	}
	free(trap);
}

struct wseg *m_atseg;

struct monst *
m_at(int x, int y)
{
	struct monst *mtmp;
#ifndef NOWORM
	struct wseg *wtmp;
#endif /* NOWORM */

	m_atseg = 0;
	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon){
		if(mtmp->mx == x && mtmp->my == y)
			return(mtmp);
#ifndef NOWORM
		if(mtmp->wormno){
		    for(wtmp = wsegs[mtmp->wormno]; wtmp; wtmp = wtmp->nseg)
		    if(wtmp->wx == x && wtmp->wy == y){
			m_atseg = wtmp;
			return(mtmp);
		    }
		}
#endif /* NOWORM */
	}
	return(0);
}

struct obj *
o_at(int x, int y)
{
	struct obj *otmp;

	for(otmp = fobj; otmp; otmp = otmp->nobj)
		if(otmp->ox == x && otmp->oy == y) return(otmp);
	return(0);
}

struct obj *
sobj_at(int n, int x, int y)
{
	struct obj *otmp;

	for(otmp = fobj; otmp; otmp = otmp->nobj)
		if(otmp->ox == x && otmp->oy == y && otmp->otyp == n)
			return(otmp);
	return(0);
}

int
carried(struct obj *obj)
{
	struct obj *otmp;

	for(otmp = invent; otmp; otmp = otmp->nobj)
		if(otmp == obj) return(1);
	return(0);
}

boolean
carrying(int type)
{
	struct obj *otmp;

	for(otmp = invent; otmp; otmp = otmp->nobj)
		if(otmp->otyp == type)
			return(TRUE);
	return(FALSE);
}

struct obj *
o_on(unsigned int id, struct obj *objchn)
{
	while(objchn) {
		if(objchn->o_id == id) return(objchn);
		objchn = objchn->nobj;
	}
	return(NULL);
}

struct trap *
t_at(int x, int y)
{
	struct trap *trap = ftrap;

	while(trap) {
		if(trap->tx == x && trap->ty == y) return(trap);
		trap = trap->ntrap;
	}
	return(NULL);
}

struct gold *
g_at(int x, int y)
{
	struct gold *gold = fgold;

	while(gold) {
		if(gold->gx == x && gold->gy == y) return(gold);
		gold = gold->ngold;
	}
	return(NULL);
}

/* make dummy object structure containing gold - for temporary use only */
struct obj *
mkgoldobj(long q)
{
	struct obj *otmp;

	otmp = newobj(0);
	/* should set o_id etc. but otmp will be freed soon */
	otmp->olet = '$';
	u.ugold -= q;
	OGOLD(otmp) = q;
	flags.botl = 1;
	return(otmp);
}

/*
 * getobj returns:
 *	struct obj *xxx:	object to do something with.
 *	(struct obj *) 0	error return: no object.
 *	&zeroobj		explicitly no object (as in w-).
 */
struct obj *
getobj(char *let, char *word)
{
	struct obj *otmp;
	char ilet,ilet1,ilet2;
	char buf[BUFSZ];
	char lets[BUFSZ];
	int foo = 0, foo2;
	char *bp = buf;
	xchar allowcnt = 0;	/* 0, 1 or 2 */
	boolean allowgold = FALSE;
	boolean allowall = FALSE;
	boolean allownone = FALSE;
	xchar foox = 0;
	long cnt;

	if(*let == '0') let++, allowcnt = 1;
	if(*let == '$') let++, allowgold = TRUE;
	if(*let == '#') let++, allowall = TRUE;
	if(*let == '-') let++, allownone = TRUE;
	if(allownone) *bp++ = '-';
	if(allowgold) *bp++ = '$';
	if(bp > buf && bp[-1] == '-') *bp++ = ' ';

	ilet = 'a';
	for(otmp = invent; otmp; otmp = otmp->nobj){
	    if(!*let || strchr(let, otmp->olet)) {
		bp[foo++] = flags.invlet_constant ? otmp->invlet : ilet;

		/* ugly check: remove inappropriate things */
		if((!strcmp(word, "take off") &&
		    !(otmp->owornmask & (W_ARMOR - W_ARM2)))
		|| (!strcmp(word, "wear") &&
		    (otmp->owornmask & (W_ARMOR | W_RING)))
		|| (!strcmp(word, "wield") &&
		    (otmp->owornmask & W_WEP))) {
			foo--;
			foox++;
		}
	    }
	    if(ilet == 'z') ilet = 'A'; else ilet++;
	}
	bp[foo] = 0;
	if(foo == 0 && bp > buf && bp[-1] == ' ') *--bp = 0;
	(void) strlcpy(lets, bp, sizeof lets);	/* necessary since we destroy buf */
	if(foo > 5) {			/* compactify string */
		foo = foo2 = 1;
		ilet2 = bp[0];
		ilet1 = bp[1];
		while ((ilet = bp[++foo2] = bp[++foo])) {
			if(ilet == ilet1+1){
				if(ilet1 == ilet2+1)
					bp[foo2 - 1] = ilet1 = '-';
				else if(ilet2 == '-') {
					bp[--foo2] = ++ilet1;
					continue;
				}
			}
			ilet2 = ilet1;
			ilet1 = ilet;
		}
	}
	if(!foo && !allowall && !allowgold && !allownone) {
		pline("You don't have anything %sto %s.",
			foox ? "else " : "", word);
		return(0);
	}
	for(;;) {
		if(!buf[0])
			pline("What do you want to %s [*]? ", word);
		else
			pline("What do you want to %s [%s or ?*]? ",
				word, buf);

		cnt = 0;
		ilet = readchar();
		while(isdigit((unsigned char)ilet) && allowcnt) {
			if (cnt < 100000000)
			    cnt = 10*cnt + (ilet - '0');
			else
			    cnt = 999999999;
			allowcnt = 2;	/* signal presence of cnt */
			ilet = readchar();
		}
		if(isdigit((unsigned char)ilet)) {
			pline("No count allowed with this command.");
			continue;
		}
		if(strchr(quitchars,ilet))
			return((struct obj *)0);
		if(ilet == '-') {
			return(allownone ? &zeroobj : (struct obj *) 0);
		}
		if(ilet == '$') {
			if(!allowgold){
				pline("You cannot %s gold.", word);
				continue;
			}
			if(!(allowcnt == 2 && cnt < u.ugold))
				cnt = u.ugold;
			return(mkgoldobj(cnt));
		}
		if(ilet == '?') {
			doinv(lets);
			if(!(ilet = morc)) continue;
			/* he typed a letter (not a space) to more() */
		} else if(ilet == '*') {
			doinv(NULL);
			if(!(ilet = morc)) continue;
			/* ... */
		}
		if(flags.invlet_constant) {
			for(otmp = invent; otmp; otmp = otmp->nobj)
				if(otmp->invlet == ilet) break;
		} else {
			if(ilet >= 'A' && ilet <= 'Z') ilet += 'z'-'A'+1;
			ilet -= 'a';
			for(otmp = invent; otmp && ilet;
					ilet--, otmp = otmp->nobj) ;
		}
		if(!otmp) {
			pline("You don't have that object.");
			continue;
		}
		if(cnt < 0 || otmp->quan < cnt) {
			pline("You don't have that many! [You have %u]"
			, otmp->quan);
			continue;
		}
		break;
	}
	if(!allowall && let && !strchr(let,otmp->olet)) {
		pline("That is a silly thing to %s.",word);
		return(0);
	}
	if(allowcnt == 2) {	/* cnt given */
		if(cnt == 0) return(0);
		if(cnt != otmp->quan) {
			struct obj *obj;
			obj = splitobj(otmp, (int) cnt);
			if(otmp == uwep) setuwep(obj);
		}
	}
	return(otmp);
}

int
ckunpaid(struct obj *otmp)
{
	return( otmp->unpaid );
}

/* interactive version of getobj - used for Drop and Identify */
/* return the number of times fn was called successfully */
int
ggetobj(char *word, int (*fn)(struct obj *), int max)
{
	char buf[BUFSZ];
	char *ip;
	char sym;
	int oletct = 0, iletct = 0;
	boolean allflag = FALSE;
	char olets[20], ilets[20];
	int (*ckfn)(struct obj *) = NULL;
	xchar allowgold = (u.ugold && !strcmp(word, "drop")) ? 1 : 0;	/* BAH */

	if(!invent && !allowgold){
		pline("You have nothing to %s.", word);
		return(0);
	} else {
		struct obj *otmp = invent;
		int uflg = 0;

		if(allowgold) ilets[iletct++] = '$';
		ilets[iletct] = 0;
		while(otmp) {
			if(!strchr(ilets, otmp->olet)){
				ilets[iletct++] = otmp->olet;
				ilets[iletct] = 0;
			}
			if(otmp->unpaid) uflg = 1;
			otmp = otmp->nobj;
		}
		ilets[iletct++] = ' ';
		if(uflg) ilets[iletct++] = 'u';
		if(invent) ilets[iletct++] = 'a';
		ilets[iletct] = 0;
	}
	pline("What kinds of thing do you want to %s? [%s] ",
		word, ilets);
	getlin(buf);
	if(buf[0] == '\033') {
		clrlin();
		return(0);
	}
	ip = buf;
	olets[0] = 0;
	while ((sym = *ip++)) {
		if (sym == ' ')
			continue;
		if (sym == '$') {
			if (allowgold == 1)
				(*fn)(mkgoldobj(u.ugold));
			else if (!u.ugold)
				pline("You have no gold.");
			allowgold = 2;
		} else if (sym == 'a' || sym == 'A')
			allflag = TRUE;
		else if (sym == 'u' || sym == 'U')
			ckfn = ckunpaid;
		else if (strchr("!%?[()=*/\"0", sym)) {
			if (!strchr(olets, sym)) {
				olets[oletct++] = sym;
				olets[oletct] = 0;
			}
		}
		else pline("You don't have any %c's.", sym);
	}
	if (allowgold == 2 && !oletct)
		return(1);	/* he dropped gold (or at least tried to) */
	else
		return(askchain(invent, olets, allflag, fn, ckfn, max));
}

/*
 * Walk through the chain starting at objchn and ask for all objects
 * with olet in olets (if nonNULL) and satisfying ckfn (if nonNULL)
 * whether the action in question (i.e., fn) has to be performed.
 * If allflag then no questions are asked. Max gives the max nr of
 * objects to be treated. Return the number of objects treated.
 */
int
askchain(struct obj *objchn, char *olets, int allflag, int (*fn)(struct obj *),
    int (*ckfn)(struct obj *), int max)
{
	struct obj *otmp, *otmp2;
	char sym, ilet;
	int cnt = 0;

	ilet = 'a'-1;
	for(otmp = objchn; otmp; otmp = otmp2){
		if(ilet == 'z') ilet = 'A'; else ilet++;
		otmp2 = otmp->nobj;
		if(olets && *olets && !strchr(olets, otmp->olet)) continue;
		if(ckfn && !(*ckfn)(otmp)) continue;
		if(!allflag) {
			pline("%s", xprname(otmp, ilet));
			addtopl(" [nyaq]? ");
			sym = readchar();
		}
		else	sym = 'y';

		switch(sym){
		case 'a':
			allflag = 1;
		case 'y':
			cnt += (*fn)(otmp);
			if(--max == 0) goto ret;
		case 'n':
		default:
			break;
		case 'q':
			goto ret;
		}
	}
	pline(cnt ? "That was all." : "No applicable objects.");
ret:
	return(cnt);
}

/* should of course only be called for things in invent */
static char
obj_to_let(struct obj *obj)
{
	struct obj *otmp;
	char ilet;

	if(flags.invlet_constant)
		return(obj->invlet);
	ilet = 'a';
	for(otmp = invent; otmp && otmp != obj; otmp = otmp->nobj)
		if(++ilet > 'z') ilet = 'A';
	return(otmp ? ilet : NOINVSYM);
}

void
prinv(struct obj *obj)
{
	pline("%s", xprname(obj, obj_to_let(obj)));
}

static char *
xprname(struct obj *obj, char let)
{
	static char li[BUFSZ];

	(void) snprintf(li, sizeof li, "%c - %s.",
		flags.invlet_constant ? obj->invlet : let,
		doname(obj));
	return(li);
}

int
ddoinv(void)
{
	doinv(NULL);
	return(0);
}

/* called with 0 or "": all objects in inventory */
/* otherwise: all objects with (serial) letter in lets */
static void
doinv(char *lets)
{
	struct obj *otmp;
	char ilet;
	int ct = 0;
	char any[BUFSZ];

	morc = 0;		/* just to be sure */

	if(!invent){
		pline("Not carrying anything.");
		return;
	}

	cornline(0, NULL);
	ilet = 'a';
	for(otmp = invent; otmp; otmp = otmp->nobj) {
	    if(flags.invlet_constant) ilet = otmp->invlet;
	    if(!lets || !*lets || strchr(lets, ilet)) {
		    cornline(1, xprname(otmp, ilet));
		    any[ct++] = ilet;
	    }
	    if(!flags.invlet_constant) if(++ilet > 'z') ilet = 'A';
	}
	any[ct] = 0;
	cornline(2, any);
}

int
dotypeinv(void)				/* free after Robert Viduya */
/* Changed to one type only, so he doesn't have to type cr */
{
    char c, ilet;
    char stuff[BUFSZ];
    int stct;
    struct obj *otmp;
    boolean billx = inshop() && doinvbill(0);
    boolean unpd = FALSE;

	if (!invent && !u.ugold && !billx) {
	    pline ("You aren't carrying anything.");
	    return(0);
	}

	stct = 0;
	if(u.ugold) stuff[stct++] = '$';
	stuff[stct] = 0;
	for(otmp = invent; otmp; otmp = otmp->nobj) {
	    if (!strchr (stuff, otmp->olet)) {
		stuff[stct++] = otmp->olet;
		stuff[stct] = 0;
	    }
	    if(otmp->unpaid)
		unpd = TRUE;
	}
	if(unpd) stuff[stct++] = 'u';
	if(billx) stuff[stct++] = 'x';
	stuff[stct] = 0;

	if(stct > 1) {
	    pline ("What type of object [%s] do you want an inventory of? ",
		stuff);
	    c = readchar();
	    if(strchr(quitchars,c)) return(0);
	} else
	    c = stuff[0];

	if(c == '$')
	    return(doprgold());

	if(c == 'x' || c == 'X') {
	    if(billx)
		(void) doinvbill(1);
	    else
		pline("No used-up objects on the shopping bill.");
	    return(0);
	}

	if((c == 'u' || c == 'U') && !unpd) {
		pline("You are not carrying any unpaid objects.");
		return(0);
	}

	stct = 0;
	ilet = 'a';
	for (otmp = invent; otmp; otmp = otmp -> nobj) {
	    if(flags.invlet_constant) ilet = otmp->invlet;
	    if (c == otmp -> olet || (c == 'u' && otmp -> unpaid))
		stuff[stct++] = ilet;
	    if(!flags.invlet_constant) if(++ilet > 'z') ilet = 'A';
	}
	stuff[stct] = '\0';
	if(stct == 0)
		pline("You have no such objects.");
	else
		doinv (stuff);

	return(0);
}

/* look at what is here */
int
dolook(void)
{
    struct obj *otmp, *otmp0;
    struct gold *gold;
    char *verb = Blind ? "feel" : "see";
    int	ct = 0;

    if(!u.uswallow) {
	if(Blind) {
	    pline("You try to feel what is lying here on the floor.");
	    if(Levitation) {				/* ab@@unido */
		pline("You cannot reach the floor!");
		return(1);
	    }
	}
	otmp0 = o_at(u.ux, u.uy);
	gold = g_at(u.ux, u.uy);
    }

    if(u.uswallow || (!otmp0 && !gold)) {
	pline("You %s no objects here.", verb);
	return(!!Blind);
    }

    cornline(0, "Things that are here:");
    for(otmp = otmp0; otmp; otmp = otmp->nobj) {
	if(otmp->ox == u.ux && otmp->oy == u.uy) {
	    ct++;
	    cornline(1, doname(otmp));
	    if(Blind && otmp->otyp == DEAD_COCKATRICE && !uarmg) {
		pline("Touching the dead cockatrice is a fatal mistake ...");
		pline("You die ...");
		killer = "dead cockatrice";
		done("died");
	    }
	}
    }

    if(gold) {
	char gbuf[30];

	(void) snprintf(gbuf, sizeof gbuf, "%ld gold piece%s",
		gold->amount, plur(gold->amount));
	if(!ct++)
	    pline("You %s here %s.", verb, gbuf);
	else
	    cornline(1, gbuf);
    }

    if(ct == 1 && !gold) {
	pline("You %s here %s.", verb, doname(otmp0));
	cornline(3, NULL);
    }
    if(ct > 1)
	cornline(2, NULL);
    return(!!Blind);
}

void
stackobj(struct obj *obj)
{
	struct obj *otmp = fobj;

	for(otmp = fobj; otmp; otmp = otmp->nobj) if(otmp != obj)
	if(otmp->ox == obj->ox && otmp->oy == obj->oy &&
		merged(obj,otmp,1))
			return;
}

/* merge obj with otmp and delete obj if types agree */
static int
merged(struct obj *otmp, struct obj *obj, int lose)
{
	if(obj->otyp == otmp->otyp &&
	  obj->unpaid == otmp->unpaid &&
	  obj->spe == otmp->spe &&
	  obj->dknown == otmp->dknown &&
	  obj->cursed == otmp->cursed &&
	  (strchr("%*?!", obj->olet) ||
	    (obj->known == otmp->known &&
		(obj->olet == WEAPON_SYM && obj->otyp < BOOMERANG)))) {
		otmp->quan += obj->quan;
		otmp->owt += obj->owt;
		if(lose) freeobj(obj);
		obfree(obj,otmp);	/* free(obj), bill->otmp */
		return(1);
	} else	return(0);
}

/*
 * Gold is no longer displayed; in fact, when you have a lot of money,
 * it may take a while before you have counted it all.
 * [Bug: d$ and pickup still tell you how much it was.]
 */
extern int (*occupation)(void);
extern char *occtxt;
static long goldcounted;

int
countgold(void)
{
	if((goldcounted += 100*(u.ulevel + 1)) >= u.ugold) {
		long eps = 0;
		if(!rn2(2)) eps = rnd((int) (u.ugold/100 + 1));
		pline("You probably have about %ld gold pieces.",
			u.ugold + eps);
		return(0);	/* done */
	}
	return(1);		/* continue */
}

int
doprgold(void)
{
	if(!u.ugold)
		pline("You do not carry any gold.");
	else if(u.ugold <= 500)
		pline("You are carrying %ld gold pieces.", u.ugold);
	else {
		pline("You sit down in order to count your gold pieces.");
		goldcounted = 500;
		occupation = countgold;
		occtxt = "counting your gold";
	}
	return(1);
}

/* --- end of gold counting section --- */

int
doprwep(void)
{
	if(!uwep) pline("You are empty handed.");
	else prinv(uwep);
	return(0);
}

int
doprarm(void)
{
	if(!uarm && !uarmg && !uarms && !uarmh)
		pline("You are not wearing any armor.");
	else {
		char lets[6];
		int ct = 0;

		if(uarm) lets[ct++] = obj_to_let(uarm);
		if(uarm2) lets[ct++] = obj_to_let(uarm2);
		if(uarmh) lets[ct++] = obj_to_let(uarmh);
		if(uarms) lets[ct++] = obj_to_let(uarms);
		if(uarmg) lets[ct++] = obj_to_let(uarmg);
		lets[ct] = 0;
		doinv(lets);
	}
	return(0);
}

int
doprring(void)
{
	if(!uleft && !uright)
		pline("You are not wearing any rings.");
	else {
		char lets[3];
		int ct = 0;

		if(uleft) lets[ct++] = obj_to_let(uleft);
		if(uright) lets[ct++] = obj_to_let(uright);
		lets[ct] = 0;
		doinv(lets);
	}
	return(0);
}
@


1.13
log
@This diff is rather large, but it's just simply removing unnecessary headers
, remove some lint-style comments, add missing void to functions without args,
also some function prototypes (extern) were missing their args, so I added them
as they were defined in hack.h

OK tb@@ on separate diffs
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.invent.c,v 1.12 2015/10/24 17:37:56 mmcc Exp $	*/
d472 1
a472 1
			doinv((char *) 0);
d670 1
a670 1
	doinv((char *) 0);
d691 1
a691 1
	cornline(0, (char *) 0);
d830 1
a830 1
	cornline(3, (char *) 0);
d833 1
a833 1
	cornline(2, (char *) 0);
@


1.12
log
@Cast isdigit()'s argument to unsigned char.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.invent.c,v 1.11 2015/09/27 05:13:11 guenther Exp $	*/
d64 5
a68 4
#include	<ctype.h>
#include	<stdlib.h>
#include	<stdio.h>
#include	"hack.h"
d668 1
a668 1
ddoinv()
d706 1
a706 1
dotypeinv()				/* free after Robert Viduya */
d779 1
a779 1
dolook()
d878 1
a878 1
countgold()
d891 1
a891 1
doprgold()
d909 1
a909 1
doprwep()
d917 1
a917 1
doprarm()
d937 1
a937 1
doprring()
@


1.11
log
@Annotate funcs with __attribute__((printf(...))) and clean up the fallout:
 * lots of foo(str) --> foo("%s", str) transformations
 * one totally insane foo(fmt, ap) --> vfoo(fmt, ap) conversion: how did
   this ever work?
 * prefer const char[] over char* for static format strings, as it lets
   gcc check the format and eliminates an unnecessary pointer

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.invent.c,v 1.10 2014/03/11 08:05:15 guenther Exp $	*/
d440 1
a440 1
		while(isdigit(ilet) && allowcnt) {
d448 1
a448 1
		if(isdigit(ilet)) {
@


1.10
log
@Match bwrite()'s prototype with write()'s, zapping a lint comment
Delete casts to char* of arguments to bwrite() and free()
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.invent.c,v 1.9 2009/10/27 23:59:25 deraadt Exp $	*/
d610 1
a610 1
			pline(xprname(otmp, ilet));
d652 1
a652 1
	pline(xprname(obj, obj_to_let(obj)));
@


1.9
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.invent.c,v 1.8 2003/05/19 06:30:56 pjanzen Exp $	*/
d223 1
a223 1
	free((char *) gold);
d237 1
a237 1
	free((char *) trap);
@


1.8
log
@De-register, ANSIfy, clean up.
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.invent.c,v 1.7 2003/04/06 18:50:37 deraadt Exp $	*/
a62 4

#ifndef lint
static const char rcsid[] = "$OpenBSD$";
#endif /* not lint */
@


1.7
log
@2451 lines of strdup/sprintf/strcpy whacking.  mostly ok'd by pjanzen
already, but he may have later changes to make still.
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.invent.c,v 1.6 2003/03/16 21:22:35 camield Exp $	*/
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.invent.c,v 1.6 2003/03/16 21:22:35 camield Exp $";
d68 3
d72 1
a72 2
#include	<stdio.h>
extern struct obj *splitobj();
a75 1
static char *xprname();
a77 1
#include	"def.wseg.h"
d84 10
a93 3
static
assigninvlet(otmp)
register struct obj *otmp;
d96 2
a97 2
	register int i;
	register struct obj *obj;
d119 1
a119 2
addinv(obj)
register struct obj *obj;
d121 1
a121 1
	register struct obj *otmp;
d165 2
a166 2
useup(obj)
register struct obj *obj;
d178 2
a179 2
freeinv(obj)
register struct obj *obj;
d181 1
a181 1
	register struct obj *otmp;
d193 3
a195 1
delobj(obj) register struct obj *obj; {
d202 4
a205 2
freeobj(obj) register struct obj *obj; {
	register struct obj *otmp;
d216 4
a219 2
freegold(gold) register struct gold *gold; {
	register struct gold *gtmp;
d230 2
a231 2
deltrap(trap)
register struct trap *trap;
d233 1
a233 1
	register struct trap *ttmp;
d247 1
a247 2
m_at(x,y)
register x,y;
d249 1
a249 1
	register struct monst *mtmp;
d251 1
a251 1
	register struct wseg *wtmp;
d272 1
a272 2
o_at(x,y)
register x,y;
d274 1
a274 1
	register struct obj *otmp;
d282 1
a282 2
sobj_at(n,x,y)
register n,x,y;
d284 1
a284 1
	register struct obj *otmp;
d292 5
a296 2
carried(obj) register struct obj *obj; {
register struct obj *otmp;
d302 2
a303 2
carrying(type)
register int type;
d305 1
a305 1
	register struct obj *otmp;
d314 2
a315 1
o_on(id, objchn) unsigned int id; register struct obj *objchn; {
d320 1
a320 1
	return((struct obj *) 0);
d324 1
a324 2
t_at(x,y)
register x,y;
d326 2
a327 1
	register struct trap *trap = ftrap;
d332 1
a332 1
	return(0);
d336 1
a336 2
g_at(x,y)
register x,y;
d338 2
a339 1
	register struct gold *gold = fgold;
d344 1
a344 1
	return(0);
d349 1
a349 2
mkgoldobj(q)
register long q;
d351 1
a351 1
	register struct obj *otmp;
d369 1
a369 2
getobj(let,word)
register char *let,*word;
d371 2
a372 2
	register struct obj *otmp;
	register char ilet,ilet1,ilet2;
d375 2
a376 2
	register int foo = 0, foo2;
	register char *bp = buf;
d417 1
a417 1
		while(ilet = bp[++foo2] = bp[++foo]){
d444 1
a444 1
		while(digit(ilet) && allowcnt) {
d452 1
a452 1
		if(digit(ilet)) {
d506 1
a506 1
			register struct obj *obj;
d514 3
a516 1
ckunpaid(otmp) register struct obj *otmp; {
d522 12
a533 12
ggetobj(word, fn, max)
char *word;
int (*fn)(),  max;
{
char buf[BUFSZ];
register char *ip;
register char sym;
register int oletct = 0, iletct = 0;
register boolean allflag = FALSE;
char olets[20], ilets[20];
int (*ckfn)() = (int (*)()) 0;
xchar allowgold = (u.ugold && !strcmp(word, "drop")) ? 1 : 0;	/* BAH */
d538 2
a539 2
		register struct obj *otmp = invent;
		register int uflg = 0;
d565 5
a569 4
	while(sym = *ip++){
		if(sym == ' ') continue;
		if(sym == '$') {
			if(allowgold == 1)
d571 1
a571 1
			else if(!u.ugold)
d574 6
a579 5
		} else
		if(sym == 'a' || sym == 'A') allflag = TRUE; else
		if(sym == 'u' || sym == 'U') ckfn = ckunpaid; else
		if(strchr("!%?[()=*/\"0", sym)){
			if(!strchr(olets, sym)){
d586 1
a586 1
	if(allowgold == 2 && !oletct)
d599 8
a606 10
askchain(objchn, olets, allflag, fn, ckfn, max)
struct obj *objchn;
register char *olets;
int allflag;
int (*fn)(), (*ckfn)();
int max;
{
register struct obj *otmp, *otmp2;
register char sym, ilet;
register int cnt = 0;
d638 3
a640 2
obj_to_let(obj)	/* should of course only be called for things in invent */
register struct obj *obj;
d642 2
a643 2
	register struct obj *otmp;
	register char ilet;
d653 2
a654 2
prinv(obj)
register struct obj *obj;
d660 1
a660 3
xprname(obj,let)
register struct obj *obj;
register char let;
d670 1
d679 2
a680 2
doinv(lets)
register char *lets;
d682 2
a683 2
	register struct obj *otmp;
	register char ilet;
d708 2
a709 1
dotypeinv ()				/* free after Robert Viduya */
d714 2
a715 2
    register int stct;
    register struct obj *otmp;
d781 5
a785 3
dolook() {
    register struct obj *otmp, *otmp0;
    register struct gold *gold;
d840 5
a844 2
stackobj(obj) register struct obj *obj; {
register struct obj *otmp = fobj;
d852 3
a854 1
merged(otmp,obj,lose) register struct obj *otmp, *obj; {
d876 1
a876 1
extern int (*occupation)();
d880 3
a882 1
countgold(){
d893 3
a895 1
doprgold(){
d911 3
a913 1
doprwep(){
d919 3
a921 1
doprarm(){
d926 1
a926 1
		register int ct = 0;
d939 3
a941 1
doprring(){
d946 1
a946 1
		register int ct = 0;
a953 4
}

digit(c) char c; {
	return(c >= '0' && c <= '9');
@


1.6
log
@hack is free

Thanks to Andries Brouwer, Jay Fenlason and the folks at CWI for their
efforts.

http://www.cwi.nl/~aeb/games/hack/hack.html

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.invent.c,v 1.5 2001/08/06 22:59:13 pjanzen Exp $	*/
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.invent.c,v 1.5 2001/08/06 22:59:13 pjanzen Exp $";
d401 1
a401 1
	(void) strcpy(lets, bp);	/* necessary since we destroy buf */
d652 1
a652 1
	(void) sprintf(li, "%c - %s.",
d807 1
a807 1
	(void) sprintf(gbuf, "%ld gold piece%s",
@


1.5
log
@Nothing but comments after #endif and #else; heko@@iki.fi
@
text
@d1 1
a1 1
/*	$OpenBSD: hack.invent.c,v 1.4 2001/01/28 23:41:44 niklas Exp $	*/
d4 58
a61 1
 * Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985.
d65 1
a65 1
static char rcsid[] = "$OpenBSD: hack.invent.c,v 1.4 2001/01/28 23:41:44 niklas Exp $";
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d8 1
a8 1
static char rcsid[] = "$OpenBSD: hack.invent.c,v 1.4 1995/03/23 08:30:25 cgd Exp $";
d22 1
a22 1
#endif NOWORM
d184 1
a184 1
#endif NOWORM
d198 1
a198 1
#endif NOWORM
@


1.3
log
@comment grammar
@
text
@d1 2
d8 1
a8 1
static char rcsid[] = "$NetBSD: hack.invent.c,v 1.4 1995/03/23 08:30:25 cgd Exp $";
@


1.2
log
@r?index -> strr?chr
@
text
@d637 1
a637 1
/* Changed to one type only, so he doesnt have to type cr */
@


1.1
log
@Initial revision
@
text
@d324 1
a324 1
	    if(!*let || index(let, otmp->olet)) {
d386 1
a386 1
		if(index(quitchars,ilet))
d429 1
a429 1
	if(!allowall && let && !index(let,otmp->olet)) {
d472 1
a472 1
			if(!index(ilets, otmp->olet)){
d504 2
a505 2
		if(index("!%?[()=*/\"0", sym)){
			if(!index(olets, sym)){
d539 1
a539 1
		if(olets && *olets && !index(olets, otmp->olet)) continue;
d626 1
a626 1
	    if(!lets || !*lets || index(lets, ilet)) {
d655 1
a655 1
	    if (!index (stuff, otmp->olet)) {
d670 1
a670 1
	    if(index(quitchars,c)) return(0);
d780 1
a780 1
	  (index("%*?!", obj->olet) ||
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
