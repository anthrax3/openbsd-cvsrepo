head	1.23;
access;
symbols
	OPENBSD_6_2:1.23.0.8
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.23.0.6
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.2
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.16
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.14
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.12
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.22
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.18
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.16
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.14
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.12
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.10
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.8
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.6
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.8.0.6
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2016.03.07.12.07.56;	author mestre;	state Exp;
branches;
next	1.22;
commitid	NZhYxChmyb9vOEMM;

1.22
date	2016.01.10.13.35.09;	author mestre;	state Exp;
branches;
next	1.21;
commitid	mVbl9a8GbGdqcFgu;

1.21
date	2016.01.04.11.58.35;	author mestre;	state Exp;
branches;
next	1.20;
commitid	TBXFQYiwdVBhodpy;

1.20
date	2016.01.03.14.38.17;	author mestre;	state Exp;
branches;
next	1.19;
commitid	Ptgw9rNvmSHNRfGy;

1.19
date	2015.12.25.20.59.09;	author mestre;	state Exp;
branches;
next	1.18;
commitid	5J5Os05YMVA0ZKC5;

1.18
date	2015.11.30.08.42.03;	author tb;	state Exp;
branches;
next	1.17;
commitid	jZDWMV8MMmsswCUU;

1.17
date	2015.02.18.23.20.45;	author tedu;	state Exp;
branches;
next	1.16;
commitid	u45ghbHXMRuxefJT;

1.16
date	2013.08.29.20.22.12;	author naddy;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.27.23.59.24;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.29.08.52.28;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.03.03.01.39;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.12.06.21.48.51;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.31.03.40.00;	author pjanzen;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.09;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.09.07.04.29;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.08.12.22.39;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.08.12.18.25;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	99.09.25.15.52.19;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	99.06.10.22.58.24;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	99.03.26.03.16.10;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	98.08.22.09.11.31;	author pjanzen;	state Exp;
branches;
next	1.2;

1.2
date	97.01.15.23.40.36;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.49;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.49;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.23
log
@- General changes:
- Remove -? from getopt(3) options, but still keep (or add) -h where applicable
- Replace hardcoded program strings by getprogname(3)

- Specific changes:
- atc(6): this used -? and -u for usage(), remove both from game and manpage
- bcd(6): use __progname instead of getprogname(3), no need to include stdlib.h
- hunt(6): replace fputs(3) by fprintf(3)

OK tb@@ after his suggestions
@
text
@/*	$OpenBSD: fish.c,v 1.22 2016/01/10 13:35:09 mestre Exp $	*/
/*	$NetBSD: fish.c,v 1.3 1995/03/23 08:28:18 cgd Exp $	*/

/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Muffy Barkocy.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/wait.h>

#include <err.h>
#include <fcntl.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "pathnames.h"

#define	RANKS		13
#define	HANDSIZE	7
#define	CARDS		4
#define	TOTCARDS	RANKS * CARDS

#define	USER		1
#define	COMPUTER	0
#define	OTHER(a)	(1 - (a))

const char *const cards[] = {
	"A", "2", "3", "4", "5", "6", "7",
	"8", "9", "10", "J", "Q", "K", NULL,
};
#define	PRC(card)	(void)printf(" %s", cards[card])

int promode;
int curcard;
int asked[RANKS], comphand[RANKS], deck[TOTCARDS];
int userasked[RANKS], userhand[RANKS];

void	chkwinner(int, const int *);
int	compmove(void);
int	countbooks(const int *);
int	countcards(const int *);
int	drawcard(int, int *);
int	getans(const char *);
int	gofish(int, int, int *);
void	goodmove(int, int, int *, int *);
void	init(void);
void	instructions(void);
int	nrandom(int);
void	printhand(const int *);
void	printplayer(int);
int	promove(void);
__dead void	usage(void);
int	usermove(void);

int
main(int argc, char *argv[])
{
	int ch, move;

	if (pledge("stdio rpath proc exec", NULL) == -1)
		err(1, "pledge");

	while ((ch = getopt(argc, argv, "ph")) != -1)
		switch(ch) {
		case 'p':
			promode = 1;
			break;
		case 'h':
		default:
			usage();
		}

	instructions();

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	init();

	if (nrandom(2) == 1) {
		printplayer(COMPUTER);
		(void)printf("get to start.\n");
		goto istart;
	}
	printplayer(USER);
	(void)printf("get to start.\n");
	
	for (;;) {
		move = usermove();
		if (!comphand[move]) {
			if (gofish(move, USER, userhand))
				continue;
		} else {
			goodmove(USER, move, userhand, comphand);
			continue;
		}

istart:		for (;;) {
			move = compmove();
			if (!userhand[move]) {
				if (!gofish(move, COMPUTER, comphand))
					break;
			} else
				goodmove(COMPUTER, move, comphand, userhand);
		}
	}
}

int
usermove(void)
{
	int n;
	const char *const *p;
	char buf[256];

	(void)printf("\nYour hand is:");
	printhand(userhand);

	for (;;) {
		(void)printf("You ask me for: ");
		(void)fflush(stdout);
		if (fgets(buf, sizeof(buf), stdin) == NULL)
			exit(0);
		if (buf[0] == '\0')
			continue;
		if (buf[0] == '\n') {
			(void)printf("%d cards in my hand, %d in the pool.\n",
			    countcards(comphand), curcard);
			(void)printf("My books:");
			(void)countbooks(comphand);
			continue;
		}
		buf[strlen(buf) - 1] = '\0';
		if (!strcasecmp(buf, "p") && !promode) {
			promode = 1;
			(void)printf("Entering pro mode.\n");
			continue;
		}
		if (!strcasecmp(buf, "quit"))
			exit(0);
		for (p = cards; *p; ++p)
			if (!strcasecmp(*p, buf))
				break;
		if (!*p) {
			(void)printf("I don't understand!\n");
			continue;
		}
		n = p - cards;
		if (userhand[n]) {
			userasked[n] = 1;
			return(n);
		}
		if (nrandom(3) == 1)
			(void)printf("You don't have any of those!\n");
		else
			(void)printf("You don't have any %s's!\n", cards[n]);
		if (nrandom(4) == 1)
			(void)printf("No cheating!\n");
		(void)printf("Guess again.\n");
	}
}

int
compmove(void)
{
	static int lmove;

	if (promode)
		lmove = promove();
	else {
		do {
			lmove = (lmove + 1) % RANKS;
		} while (!comphand[lmove] || comphand[lmove] == CARDS);
	}
	asked[lmove] = 1;

	(void)printf("I ask you for: %s.\n", cards[lmove]);
	return(lmove);
}

int
promove(void)
{
	int i, max;

	for (i = 0; i < RANKS; ++i)
		if (userasked[i] &&
		    comphand[i] > 0 && comphand[i] < CARDS) {
			userasked[i] = 0;
			return(i);
		}
	if (nrandom(3) == 1) {
		for (i = 0;; ++i)
			if (comphand[i] && comphand[i] != CARDS) {
				max = i;
				break;
			}
		while (++i < RANKS) 
			if (comphand[i] != CARDS &&
			    comphand[i] > comphand[max])
				max = i;
		return(max);
	} 
	if (nrandom(1024) == 723) {
		for (i = 0; i < RANKS; ++i)
			if (userhand[i] && comphand[i])
				return(i);
	}
	for (;;) {
		for (i = 0; i < RANKS; ++i)
			if (comphand[i] && comphand[i] != CARDS &&
			    !asked[i])
				return(i);
		for (i = 0; i < RANKS; ++i)
			asked[i] = 0;
	}
}

int
drawcard(int player, int *hand)
{
	int card;

	++hand[card = deck[--curcard]];
	if (player == USER || hand[card] == CARDS) {
		printplayer(player);
		(void)printf("drew %s", cards[card]);
		if (hand[card] == CARDS) {
			(void)printf(" and made a book of %s's!\n",
			     cards[card]);
			chkwinner(player, hand);
		} else
			(void)printf(".\n");
	}
	return(card);
}

int
gofish(int askedfor, int player, int *hand)
{
	printplayer(OTHER(player));
	(void)printf("say \"GO FISH!\"\n");
	if (askedfor == drawcard(player, hand)) {
		printplayer(player);
		(void)printf("drew the guess!\n");
		printplayer(player);
		(void)printf("get to ask again!\n");
		return(1);
	}
	return(0);
}

void
goodmove(int player, int move, int *hand, int *opphand)
{
	printplayer(OTHER(player));
	(void)printf("have %d %s%s.\n",
	    opphand[move], cards[move], opphand[move] == 1 ? "": "'s");

	hand[move] += opphand[move];
	opphand[move] = 0;

	if (hand[move] == CARDS) {
		printplayer(player);
		(void)printf("made a book of %s's!\n", cards[move]);
		chkwinner(player, hand);
	}

	chkwinner(OTHER(player), opphand);

	printplayer(player);
	(void)printf("get another guess!\n");
}

void
chkwinner(int player, const int *hand)
{
	int cb, i, ub;

	for (i = 0; i < RANKS; ++i)
		if (hand[i] > 0 && hand[i] < CARDS)
			return;
	printplayer(player);
	(void)printf("don't have any more cards!\n");
	(void)printf("My books:");
	cb = countbooks(comphand);
	(void)printf("Your books:");
	ub = countbooks(userhand);
	(void)printf("\nI have %d, you have %d.\n", cb, ub);
	if (ub > cb) {
		(void)printf("\nYou win!!!\n");
		if (nrandom(1024) == 723)
			(void)printf("Cheater, cheater, pumpkin eater!\n");
	} else if (cb > ub) {
		(void)printf("\nI win!!!\n");
		if (nrandom(1024) == 723)
			(void)printf("Hah!  Stupid peasant!\n");
	} else
		(void)printf("\nTie!\n");
	exit(0);
}

void
printplayer(int player)
{
	switch (player) {
	case COMPUTER:
		(void)printf("I ");
		break;
	case USER:
		(void)printf("You ");
		break;
	}
}

void
printhand(const int *hand)
{
	int book, i, j;

	for (book = i = 0; i < RANKS; i++)
		if (hand[i] < CARDS)
			for (j = hand[i]; --j >= 0;) 
				PRC(i);
		else
			++book;
	if (book) {
		(void)printf(" + Book%s of", book > 1 ? "s" : "");
		for (i = 0; i < RANKS; i++)
			if (hand[i] == CARDS)
				PRC(i);
	}
	(void)putchar('\n');
}

int
countcards(const int *hand)
{
	int i, count;

	for (count = i = 0; i < RANKS; i++)
		count += *hand++;
	return(count);
}

int
countbooks(const int *hand)
{
	int i, count;

	for (count = i = 0; i < RANKS; i++)
		if (hand[i] == CARDS) {
			++count;
			PRC(i);
		}
	if (!count)
		(void)printf(" none");
	(void)putchar('\n');
	return(count);
}

void
init(void)
{
	int i, j, temp;

	curcard = TOTCARDS;
	for (i = 0; i < TOTCARDS; ++i)
		deck[i] = i % RANKS;
	for (i = 0; i < TOTCARDS - 1; ++i) {
		j = nrandom(TOTCARDS-i);
		if (j == 0)
			continue;
		temp = deck[i];
		deck[i] = deck[i+j];
		deck[i+j] = temp;
	}
	for (i = 0; i < HANDSIZE; ++i) {
		++userhand[deck[--curcard]];
		++comphand[deck[--curcard]];
	}
}

int
nrandom(int n)
{
	return(arc4random_uniform(n));
}

int
getans(const char *prompt)
{
	char buf[20];

	/*
	 * simple routine to ask the yes/no question specified until the user
	 * answers yes or no, then return 1 if they said 'yes' and 0 if they
	 * answered 'no'.
	 */
	for (;;) {
		(void)printf("%s", prompt);
		(void)fflush(stdout);
		if (!fgets(buf, sizeof(buf), stdin)) {
			(void)printf("\n");
			exit(0);
		}
		if (*buf == 'N' || *buf == 'n')
			return(0);
		if (*buf == 'Y' || *buf == 'y')
			return(1);
		(void)printf(
"I don't understand your answer; please enter 'y' or 'n'!\n");
	}
}

void
instructions(void)
{
	const char *pager;
	pid_t pid;
	int status;
	int input;
	int fd;

	if (getans("Would you like instructions (y or n)? ") == 0)
		return;

	if ((fd = open(_PATH_INSTR, O_RDONLY)) == -1)
		(void)printf("No instruction file found!\n");
	else {
		switch (pid = fork()) {
		case 0: /* child */
			if (!isatty(1))
				pager = "/bin/cat";
			else {
				if (!(pager = getenv("PAGER")) || (*pager == 0))
					pager = _PATH_MORE;
			}
			if (dup2(fd, 0) == -1)
				err(1, "dup2");
			(void)execl(_PATH_BSHELL, "sh", "-c", pager, (char *)NULL);
			err(1, "exec sh -c %s", pager);
			/* NOT REACHED */
		case -1:
			err(1, "fork");
			/* NOT REACHED */
		default:
			(void)waitpid(pid, &status, 0);
			close(fd);
			break;
		}
	}

	(void)printf("Hit return to continue...\n");
	while ((input = getchar()) != EOF && input != '\n');
}

void
usage(void)
{
	(void)fprintf(stderr, "usage: %s [-p]\n", getprogname());
	exit(1);
}
@


1.22
log
@As per style(9), remove remaining lint-style comments from games/

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fish.c,v 1.21 2016/01/04 11:58:35 mestre Exp $	*/
a97 1
		case '?':
d491 1
a491 1
	(void)fprintf(stderr, "usage: fish [-p]\n");
@


1.21
log
@More headers removal and sorted the remaining alphabetically.

Most noticeable that were removed are sys/types.h which will be included from
stdlib.h and in turn also brings along sys/cdefs.h. The other one is limits.h
that was used with the old idiom (denom * random() / LONG_MAX), although it was
only removed were applicable (some files still need that header).

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fish.c,v 1.20 2016/01/03 14:38:17 mestre Exp $	*/
a137 1
	/* NOTREACHED */
a191 1
	/* NOTREACHED */
a247 1
	/* NOTREACHED */
a444 1
	/* NOTREACHED */
@


1.20
log
@About 13 years ago when the idiom srandom(time()), and sometimes
srandom(time()+getpid()), was changed by srandomdev(), but #include <time.h>
lived up until this day so remove it.

Additionally, earlier than that, 18 years ago, random(6) was one of the first
consumers of arc4random(3) family, and was pulling it from dev/rndvar.h but
these days we pull it from stdlib.h, which is already done, so while here
remove dev/rndvar.h also.

"seems comprehensive to me" deraadt@@ and OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fish.c,v 1.19 2015/12/25 20:59:09 mestre Exp $	*/
a35 1
#include <sys/types.h>
d43 1
a44 1
#include <string.h>
@


1.19
log
@Declare usage() functions as __dead void, if they don't return, on games section.

Found another one in arithmetic(6) which also didn't return, and removed a function from number(6) which is not used anymore.

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fish.c,v 1.18 2015/11/30 08:42:03 tb Exp $	*/
d38 1
d46 1
a46 1
#include <time.h>
@


1.18
log
@slightly interesting pledge for fish:

start with "stdio rpath proc exec" since it pipes instructions to a pager
afterwards "stdio" is enough
@
text
@d1 1
a1 1
/*	$OpenBSD: fish.c,v 1.17 2015/02/18 23:20:45 tedu Exp $	*/
d82 1
a82 1
void	usage(void);
@


1.17
log
@no reason for magic numbers to be octal. just drop the leading 0.
still equally magic.
@
text
@d1 1
a1 1
/*	$OpenBSD: fish.c,v 1.16 2013/08/29 20:22:12 naddy Exp $	*/
d90 3
d105 4
@


1.16
log
@replace srandomdev()+random() with the arc4random*() family
tweaks and ok millert@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fish.c,v 1.15 2009/10/27 23:59:24 deraadt Exp $	*/
d230 1
a230 1
	if (nrandom(1024) == 0723) {
d319 1
a319 1
		if (nrandom(1024) == 0723)
d323 1
a323 1
		if (nrandom(1024) == 0723)
@


1.15
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: fish.c,v 1.14 2004/11/29 08:52:28 jsg Exp $	*/
a100 1
	srandomdev();
d414 1
a414 1
	return((int)random() % n);
@


1.14
log
@ansi. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fish.c,v 1.13 2003/06/03 03:01:39 millert Exp $	*/
a34 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1990, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)fish.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: fish.c,v 1.13 2003/06/03 03:01:39 millert Exp $";
#endif
#endif /* not lint */
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fish.c,v 1.12 2002/12/06 21:48:51 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fish.c,v 1.12 2002/12/06 21:48:51 millert Exp $";
d100 1
a100 3
main(argc, argv)
	int argc;
	char **argv;
d150 1
a150 1
usermove()
d205 1
a205 1
compmove()
d223 1
a223 1
promove()
d262 1
a262 3
drawcard(player, hand)
	int player;
	int *hand;
d281 1
a281 3
gofish(askedfor, player, hand)
	int askedfor, player;
	int *hand;
d296 1
a296 3
goodmove(player, move, hand, opphand)
	int player, move;
	int *hand, *opphand;
d318 1
a318 3
chkwinner(player, hand)
	int player;
	const int *hand;
d346 1
a346 2
printplayer(player)
	int player;
d359 1
a359 2
printhand(hand)
	const int *hand;
d379 1
a379 2
countcards(hand)
	const int *hand;
d389 1
a389 2
countbooks(hand)
	const int *hand;
d405 1
a405 1
init()
d427 1
a427 2
nrandom(n)
	int n;
d433 1
a433 2
getans(prompt)
	const char *prompt;
d460 1
a460 1
instructions()
d502 1
a502 1
usage()
@


1.12
log
@Replace things like srandom(time(NULL)) with srandomdev(3).  random(3)
good enough for games but we should at least use a decent seed.
pjanzen@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: fish.c,v 1.11 2002/05/31 03:40:00 pjanzen Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fish.c,v 1.11 2002/05/31 03:40:00 pjanzen Exp $";
@


1.11
log
@No dm -> no need to revoke setegid.
@
text
@d1 1
a1 1
/*	$OpenBSD: fish.c,v 1.10 2002/02/16 21:27:09 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: fish.c,v 1.10 2002/02/16 21:27:09 millert Exp $";
d121 1
a121 1
	srandom(time((time_t *)NULL));
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: fish.c,v 1.9 2001/07/09 07:04:29 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: fish.c,v 1.9 2001/07/09 07:04:29 deraadt Exp $";
a108 4

	/* revoke privs */
	setegid(getgid());
	setgid(getgid());
@


1.9
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: fish.c,v 1.8 2000/04/08 12:22:39 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: fish.c,v 1.8 2000/04/08 12:22:39 pjanzen Exp $";
d86 16
a101 16
void	chkwinner __P((int, const int *));
int	compmove __P((void));
int	countbooks __P((const int *));
int	countcards __P((const int *));
int	drawcard __P((int, int *));
int	getans __P((const char *));
int	gofish __P((int, int, int *));
void	goodmove __P((int, int, int *, int *));
void	init __P((void));
void	instructions __P((void));
int	nrandom __P((int));
void	printhand __P((const int *));
void	printplayer __P((int));
int	promove __P((void));
void	usage __P((void));
int	usermove __P((void));
@


1.8
log
@Handle EOF more cleanly
@
text
@d1 1
a1 1
/*	$OpenBSD: fish.c,v 1.7 2000/04/08 12:18:25 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: fish.c,v 1.7 2000/04/08 12:18:25 pjanzen Exp $";
d508 1
a508 1
			(void)execl(_PATH_BSHELL, "sh", "-c", pager, NULL);
@


1.7
log
@Fix the card shuffle/draw algorithm.  Patch only slightly
modified from that given by John Darrow in NetBSD PR 9651.
@
text
@d1 1
a1 1
/*	$OpenBSD: fish.c,v 1.6 1999/09/25 15:52:19 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: fish.c,v 1.6 1999/09/25 15:52:19 pjanzen Exp $";
d469 4
a472 2
		if (!fgets(buf, sizeof(buf), stdin))
			return(0);
@


1.6
log
@Tidying and minor changes from or based on jsm28@@cam.ac.uk's work for the
Linux bsd-games package and NetBSD.  Mainly using 'const'.
@
text
@d1 1
a1 1
/*	$OpenBSD: fish.c,v 1.5 1999/06/10 22:58:24 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: fish.c,v 1.5 1999/06/10 22:58:24 pjanzen Exp $";
d69 1
d82 2
a83 1
int asked[RANKS], comphand[RANKS], deck[RANKS];
d178 1
a178 1
			    countcards(comphand), countcards(deck));
d278 1
a278 3
	while (deck[card = nrandom(RANKS)] == 0);
	++hand[card];
	--deck[card];
d429 1
a429 1
	int i, rank;
d431 10
a440 6
	for (i = 0; i < RANKS; ++i)
		deck[i] = CARDS;
	for (i = 0; i < HANDSIZE; ++i) {
		while (!deck[rank = nrandom(RANKS)]);
		++userhand[rank];
		--deck[rank];
d443 2
a444 3
		while (!deck[rank = nrandom(RANKS)]);
		++comphand[rank];
		--deck[rank];
@


1.5
log
@jsm28@@cam.ac.uk : handle PAGER in a manner consistent with the
Single UNIX specification for mailx and man
(http://www.opengroup.org/onlinepubs/7908799/xcu/mailx.html).
@
text
@d1 1
a1 1
/*	$OpenBSD: fish.c,v 1.4 1999/03/26 03:16:10 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: fish.c,v 1.4 1999/03/26 03:16:10 pjanzen Exp $";
d74 1
a74 1
char *cards[] = {
d84 1
a84 1
void	chkwinner __P((int, int *));
d86 2
a87 2
int	countbooks __P((int *));
int	countcards __P((int *));
d95 1
a95 1
void	printhand __P((int *));
d120 1
a120 2
			(void)fprintf(stderr, "usage: fish [-p]\n");
			exit(1);
d160 2
a161 2
	register int n;
	register char **p;
d233 1
a233 1
	register int i, max;
d335 2
a336 1
	int player, *hand;
d338 1
a338 1
	register int cb, i, ub;
d379 1
a379 1
	int *hand;
d381 1
a381 1
	register int book, i, j;
d400 1
a400 1
	int *hand;
d402 1
a402 1
	register int i, count;
d411 1
a411 1
	int *hand;
d429 1
a429 1
	register int i, rank;
@


1.4
log
@Buffer overflow fix (from FreeBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: fish.c,v 1.3 1998/08/22 09:11:31 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: fish.c,v 1.3 1998/08/22 09:11:31 pjanzen Exp $";
d55 2
d58 1
d89 1
d452 26
d481 3
d485 1
a485 1
	char buf[1024];
d487 1
a487 4
	(void)printf("Would you like instructions (y or n)? ");
	input = getchar();
	while (getchar() != '\n');
	if (input != 'y')
d490 26
a515 2
	(void)sprintf(buf, "%s %s", _PATH_MORE, _PATH_INSTR);
	(void)system(buf);
@


1.3
log
@Revoke gid (!) and minor tidying
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD$";
d167 1
a167 1
		if (fgets(buf, BUFSIZ, stdin) == NULL)
@


1.2
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: fish.c,v 1.3 1995/03/23 08:28:18 cgd Exp $";
a54 1
#include <sys/errno.h>
d58 1
d60 1
d81 17
d104 5
a108 1
	while ((ch = getopt(argc, argv, "p")) != -1)
d114 1
d154 1
d209 1
d227 1
d266 1
d289 1
d306 1
d330 1
d332 1
a332 2
	int player;
	register int *hand;
d359 1
d373 1
d394 1
d396 1
a396 1
	register int *hand;
d405 1
d422 1
d441 1
a444 2
	long random();

d448 1
d466 1
@


1.1
log
@Initial revision
@
text
@d85 1
a85 1
	while ((ch = getopt(argc, argv, "p")) != EOF)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
