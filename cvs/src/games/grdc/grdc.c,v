head	1.27;
access;
symbols
	OPENBSD_6_1:1.26.0.6
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.15.0.28
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.26
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.22
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.20
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.18
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.16
	OPENBSD_5_0:1.15.0.14
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.12
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.10
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.6
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.8
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.4
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.14
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.12
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.10
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.8
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.6
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.12.0.10
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.8
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.6
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.6
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.5.0.8
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.27
date	2017.07.13.02.57.52;	author tb;	state Exp;
branches;
next	1.26;
commitid	JW7cNUY0KLPnWQGk;

1.26
date	2016.03.07.12.07.56;	author mestre;	state Exp;
branches;
next	1.25;
commitid	NZhYxChmyb9vOEMM;

1.25
date	2016.01.07.16.00.32;	author tb;	state Exp;
branches;
next	1.24;
commitid	IwzFE3fG5RnKTWNh;

1.24
date	2016.01.04.17.33.24;	author mestre;	state Exp;
branches;
next	1.23;
commitid	b21xvsfCGMtCOVrz;

1.23
date	2016.01.03.14.38.17;	author mestre;	state Exp;
branches;
next	1.22;
commitid	Ptgw9rNvmSHNRfGy;

1.22
date	2015.12.25.20.59.09;	author mestre;	state Exp;
branches;
next	1.21;
commitid	5J5Os05YMVA0ZKC5;

1.21
date	2015.12.09.02.00.40;	author jsg;	state Exp;
branches;
next	1.20;
commitid	aXpphdx6X5huxsgu;

1.20
date	2015.11.30.08.46.07;	author tb;	state Exp;
branches;
next	1.19;
commitid	wyuoOpkb2uGmIbqz;

1.19
date	2014.11.19.03.27.45;	author schwarze;	state Exp;
branches;
next	1.18;
commitid	s0SRCoS1440IGgMr;

1.18
date	2014.11.18.20.09.45;	author tedu;	state Exp;
branches;
next	1.17;
commitid	CLcxFTMuhMnUNu5W;

1.17
date	2014.11.18.05.09.38;	author schwarze;	state Exp;
branches;
next	1.16;
commitid	sGCxWJlMGt8gvdu7;

1.16
date	2014.11.17.22.14.25;	author schwarze;	state Exp;
branches;
next	1.15;
commitid	68Ncm5VThKQSZHtP;

1.15
date	2008.03.17.09.17.56;	author sobrado;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.29.09.32.47;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.29.08.52.28;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.26.20.32.38;	author pjanzen;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.31.03.40.00;	author pjanzen;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.10;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.05.08.26.36;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.24.07.53.57;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.21.07.10.39;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.20.12.31.33;	author d;	state Exp;
branches;
next	1.5;

1.5
date	98.03.19.11.41.51;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	97.07.31.19.09.34;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.12.22.20.01.17;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.12.19.22.21.30;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.08.21.07.58.08;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Convert fprintf(stderr, ...) to errx/warnx (with slight change of output).

From Scott Cheloha
@
text
@/*	$OpenBSD: grdc.c,v 1.26 2016/03/07 12:07:56 mestre Exp $	*/
/*
 *
 * Copyright 2002 Amos Shapir.  Public domain.
 *
 * Grand digital clock for curses compatible terminals
 * Usage: grdc [-s] [n]   -- run for n seconds (default infinity)
 * Flags: -s: scroll
 *
 * modified 10-18-89 for curses (jrl)
 * 10-18-89 added signal handling
 */

#include <sys/ioctl.h>

#include <curses.h>
#include <err.h>
#include <limits.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>

#define XLENGTH 58
#define YDEPTH  7

struct timespec now;
struct tm *tm;

short disp[11] = {
	075557, 011111, 071747, 071717, 055711,
	074717, 074757, 071111, 075757, 075717, 002020
};
long old[6], next[6], new[6], mask;

volatile sig_atomic_t sigtermed = 0;
volatile sig_atomic_t sigwinched = 0;

int hascolor = 0;

void set(int, int);
void standt(int);
void getwinsize(int *, int *);
__dead void usage(void);

void
sighndl(int signo)
{
	sigtermed=signo;
}

void
sigresize(int signo)
{
	sigwinched = signo;
}

int
main(int argc, char *argv[])
{
	long t, a;
	int i, j, s, k;
	int scrol;
	int n = 0;
	struct timeval nowtv, endtv;
	struct timespec delay;
	const char *errstr;
	long scroldelay = 50000000;
	int xbase;
	int ybase;
	int wintoosmall;

	if (pledge("stdio rpath tty", NULL) == -1)
		err(1, "pledge");

	scrol = wintoosmall = 0;
	while ((i = getopt(argc, argv, "sh")) != -1)
		switch (i) {
		case 's':
			scrol = 1;
			break;
		case 'h':
		default:
			usage();
		}
	argv += optind;
	argc -= optind;

	if (argc > 1)
		usage();
	if (argc == 1) {
		n = strtonum(*argv, 1, INT_MAX, &errstr);
		if (errstr) {
			warnx("number of seconds is %s", errstr);
			usage();
		}
	}

	initscr();

	signal(SIGINT,sighndl);
	signal(SIGTERM,sighndl);
	signal(SIGHUP,sighndl);
	signal(SIGWINCH, sigresize);
	signal(SIGCONT, sigresize);	/* for resizes during suspend */

	cbreak();
	noecho();

	hascolor = has_colors();

	if(hascolor) {
		start_color();
		init_pair(1, COLOR_BLACK, COLOR_RED);
		init_pair(2, COLOR_RED, COLOR_BLACK);
		init_pair(3, COLOR_WHITE, COLOR_BLACK);
		attrset(COLOR_PAIR(2));
	}

	curs_set(0);
	sigwinched = 1;	/* force initial sizing */

	gettimeofday(&nowtv, NULL);
	TIMEVAL_TO_TIMESPEC(&nowtv, &now);
	if (n)
		endtv.tv_sec = nowtv.tv_sec + n - 1;
	do {
		if (sigwinched) {
			sigwinched = 0;
			wintoosmall = 0;
			getwinsize(&i, &j);
			if (i >= XLENGTH + 2)
				xbase = (i - XLENGTH) / 2;
			else
				wintoosmall = 1;
			if (j >= YDEPTH + 2)
				ybase = (j - YDEPTH) / 2;
			else
				wintoosmall = 1;
			resizeterm(j, i);
			clear();
			refresh();
			if (hascolor && !wintoosmall) {
				attrset(COLOR_PAIR(3));

				mvaddch(ybase - 1,  xbase - 1, ACS_ULCORNER);
				hline(ACS_HLINE, XLENGTH);
				mvaddch(ybase - 1,  xbase + XLENGTH, ACS_URCORNER);

				mvaddch(ybase + YDEPTH,  xbase - 1, ACS_LLCORNER);
				hline(ACS_HLINE, XLENGTH);
				mvaddch(ybase + YDEPTH,  xbase + XLENGTH, ACS_LRCORNER);

				move(ybase,  xbase - 1);
				vline(ACS_VLINE, YDEPTH);

				move(ybase,  xbase + XLENGTH);
				vline(ACS_VLINE, YDEPTH);

				attrset(COLOR_PAIR(2));
			}
			for (k = 0; k < 6; k++)
				old[k] = 0;
		}
		mask = 0;
		tm = localtime(&now.tv_sec);
		set(tm->tm_sec%10, 0);
		set(tm->tm_sec/10, 4);
		set(tm->tm_min%10, 10);
		set(tm->tm_min/10, 14);
		set(tm->tm_hour%10, 20);
		set(tm->tm_hour/10, 24);
		set(10, 7);
		set(10, 17);
		if (wintoosmall) {
			move(0, 0);
			printw("%02d:%02d:%02d", tm->tm_hour, tm->tm_min,
			    tm->tm_sec);
		} else for (k = 0; k < 6; k++) {
			if(scrol) {
				for(i=0; i<5; i++)
					new[i] = (new[i]&~mask) | (new[i+1]&mask);
				new[5] = (new[5]&~mask) | (next[k]&mask);
			} else
				new[k] = (new[k]&~mask) | (next[k]&mask);
			next[k] = 0;
			for(s=1; s>=0; s--) {
				standt(s);
				for(i=0; i<6; i++) {
					if((a = (new[i]^old[i])&(s ? new : old)[i]) != 0) {
						for(j=0,t=1<<26; t; t>>=1,j++) {
							if(a&t) {
								if(!(a&(t<<1))) {
									move(ybase + i+1, xbase + 2*(j+1));
								}
								addstr("  ");
							}
						}
					}
					if(!s) {
						old[i] = new[i];
					}
				}
				if(!s) {
					refresh();
				}
			}
			if (scrol && k <= 4) {
				gettimeofday(&nowtv, NULL);
				TIMEVAL_TO_TIMESPEC(&nowtv, &now);
				delay.tv_sec = 0;
				delay.tv_nsec = 1000000000 - now.tv_nsec
				    - (4-k) * scroldelay;
				if (delay.tv_nsec <= scroldelay &&
				    delay.tv_nsec > 0)
					nanosleep(&delay, NULL);
			}
		}
		move(6, 0);
		refresh();
		gettimeofday(&nowtv, NULL);
		TIMEVAL_TO_TIMESPEC(&nowtv, &now);
		delay.tv_sec = 0;
		delay.tv_nsec = (1000000000 - now.tv_nsec);
		/* want scrolling to END on the second */
		if (scrol && !wintoosmall)
			delay.tv_nsec -= 5 * scroldelay;
		nanosleep(&delay, NULL);
		now.tv_sec++;

		if (sigtermed) {
			standend();
			clear();
			refresh();
			endwin();
			errx(1, "terminated by signal %d", sigtermed);
		}
	} while (n == 0 || nowtv.tv_sec < endtv.tv_sec);
	standend();
	clear();
	refresh();
	endwin();
	return 0;
}

void
set(int t, int n)
{
	int i, m;

	m = 7<<n;
	for(i=0; i<5; i++) {
		next[i] |= ((disp[t]>>(4-i)*3)&07)<<n;
		mask |= (next[i]^old[i])&m;
	}
	if(mask&m)
		mask |= m;
}

void
standt(int on)
{
	if (on) {
		if(hascolor) {
			attron(COLOR_PAIR(1));
		} else {
			attron(A_STANDOUT);
		}
	} else {
		if(hascolor) {
			attron(COLOR_PAIR(2));
		} else {
			attroff(A_STANDOUT);
		}
	}
}

void
getwinsize(int *wid, int *ht)
{
	struct winsize size;

	if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &size) < 0) {
		*wid = 80;     /* Default */
		*ht = 24;
	} else {
		*wid = size.ws_col;
		*ht = size.ws_row;
	}
}

void
usage(void)
{
	(void)fprintf(stderr, "usage: %s [-s] [number]\n", getprogname());
	exit(1);
}
@


1.26
log
@- General changes:
- Remove -? from getopt(3) options, but still keep (or add) -h where applicable
- Replace hardcoded program strings by getprogname(3)

- Specific changes:
- atc(6): this used -? and -u for usage(), remove both from game and manpage
- bcd(6): use __progname instead of getprogname(3), no need to include stdlib.h
- hunt(6): replace fputs(3) by fprintf(3)

OK tb@@ after his suggestions
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.25 2016/01/07 16:00:32 tb Exp $	*/
d93 1
a93 1
			fprintf(stderr, "number of seconds is %s\n", errstr);
d235 1
a235 3
			fprintf(stderr, "%s terminated by signal %d\n",
			    getprogname(), sigtermed);
			return 1;
@


1.25
log
@Some basic code maintenance in games/

- in main() replace exit with return
- drop some /* NOTREACHED */ lint comments along the way.
- make more use of standard CFLAGS, esp. -Wimplicit-function-declaration
- add and sort some headers when needed
- add straightforward pledges to some programs used at compile time

discussed with and ok mestre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.24 2016/01/04 17:33:24 mestre Exp $	*/
a81 1
		case '?':
d235 2
a236 1
			fprintf(stderr, "grdc terminated by signal %d\n", sigtermed);
d296 1
a296 1
	(void)fprintf(stderr, "usage: grdc [-s] [number]\n");
@


1.24
log
@More cleanup and sorting on header section

OK tb@@ and he also pointed out that for consistency with rest of the tree we
should include termios.h instead of sys/ttydefaults.h, where applicable
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.23 2016/01/03 14:38:17 mestre Exp $	*/
d237 1
a237 1
			exit(1);
d244 1
a244 1
	return(0);
@


1.23
log
@About 13 years ago when the idiom srandom(time()), and sometimes
srandom(time()+getpid()), was changed by srandomdev(), but #include <time.h>
lived up until this day so remove it.

Additionally, earlier than that, 18 years ago, random(6) was one of the first
consumers of arc4random(3) family, and was pulling it from dev/rndvar.h but
these days we pull it from stdlib.h, which is already done, so while here
remove dev/rndvar.h also.

"seems comprehensive to me" deraadt@@ and OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.22 2015/12/25 20:59:09 mestre Exp $	*/
a14 1
#include <sys/types.h>
d17 1
a20 1
#include <stdio.h>
a21 1
#include <err.h>
@


1.22
log
@Declare usage() functions as __dead void, if they don't return, on games section.

Found another one in arithmetic(6) which also didn't return, and removed a function from number(6) which is not used anymore.

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.21 2015/12/09 02:00:40 jsg Exp $	*/
d14 1
d16 1
a16 1
#include <sys/ioctl.h>
a21 1
#include <time.h>
@


1.21
log
@include err.h for err()
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.20 2015/11/30 08:46:07 tb Exp $	*/
d45 1
a45 1
void usage(void);
@


1.20
log
@unspectacular pledge "stdio rpath tty" for grdc
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.19 2014/11/19 03:27:45 schwarze Exp $	*/
d23 1
@


1.19
log
@Bugfix: run for the specified number of seconds as described in the manual,
not for a fixed number of iterations.  This makes a difference on terminals
not fast enough to update every second, in particular in -s mode.
Inspired by FreeBSD, but implemented differently with less bugs.
Patch from pjanzen@@, slightly tweaked by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.18 2014/11/18 20:09:45 tedu Exp $	*/
d72 3
@


1.18
log
@sigwinch support for resizing. from pjanzen
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.17 2014/11/18 05:09:38 schwarze Exp $	*/
d65 1
a65 1
	struct timeval nowtv;
d123 2
d237 1
a237 1
	} while(--n);
@


1.17
log
@Center the clock.  Based on an idea and an original diff from tedu@@,
arithmetics and validity constraints fixed by me.  OK pjanzen@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.16 2014/11/17 22:14:25 schwarze Exp $	*/
d15 1
d37 1
d43 1
a43 1
void movto(int, int);
d52 6
d71 1
d73 1
a73 1
	scrol = 0;
a97 7
	if (COLS < XLENGTH + 2 || LINES < YDEPTH + 2 ) {
		endwin();
		errx(1, "screen too small");
	}

	xbase = (COLS - XLENGTH) / 2;
	ybase = (LINES - YDEPTH) / 2;
d102 2
d119 22
a140 4
	clear();
	refresh();
	if(hascolor) {
		attrset(COLOR_PAIR(3));
d142 3
a144 3
		mvaddch(ybase - 1,  xbase - 1, ACS_ULCORNER);
		hline(ACS_HLINE, XLENGTH);
		mvaddch(ybase - 1,  xbase + XLENGTH, ACS_URCORNER);
d146 3
a148 3
		mvaddch(ybase + YDEPTH,  xbase - 1, ACS_LLCORNER);
		hline(ACS_HLINE, XLENGTH);
		mvaddch(ybase + YDEPTH,  xbase + XLENGTH, ACS_LRCORNER);
d150 2
a151 2
		move(ybase,  xbase - 1);
		vline(ACS_VLINE, YDEPTH);
d153 2
a154 2
		move(ybase,  xbase + XLENGTH);
		vline(ACS_VLINE, YDEPTH);
d156 5
a160 5
		attrset(COLOR_PAIR(2));
	}
	gettimeofday(&nowtv, NULL);
	TIMEVAL_TO_TIMESPEC(&nowtv, &now);
	do {
d171 5
a175 1
		for(k=0; k<6; k++) {
d190 1
a190 1
									movto(ybase + i+1, xbase + 2*(j+1));
d215 1
a215 1
		movto(6, 0);
d222 1
a222 1
		if (scrol)
d276 1
a276 1
movto(int line, int col)
d278 9
a286 1
	move(line, col);
@


1.16
log
@Multiple improvements from pjanzen@@:
* properly delay scrolling with nanosleep(2), relevant on fast terminals
* change timing to end scrolling on the second instead of starting it
* error out if the terminal is too small instead of garbling the output
* use strtonum(3) rather than strtol(3) and terminate error message with \n
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.15 2008/03/17 09:17:56 sobrado Exp $	*/
a22 2
#define YBASE	10
#define XBASE	10
d61 2
d89 1
a89 1
	if (COLS < 67 || LINES < 17) {
d94 3
d120 1
a120 1
		mvaddch(YBASE - 2,  XBASE - 3, ACS_ULCORNER);
d122 1
a122 1
		mvaddch(YBASE - 2,  XBASE - 2 + XLENGTH, ACS_URCORNER);
d124 1
a124 1
		mvaddch(YBASE + YDEPTH - 1,  XBASE - 3, ACS_LLCORNER);
d126 1
a126 1
		mvaddch(YBASE + YDEPTH - 1,  XBASE - 2 + XLENGTH, ACS_LRCORNER);
d128 1
a128 1
		move(YBASE - 1,  XBASE - 3);
d131 1
a131 1
		move(YBASE - 1,  XBASE - 2 + XLENGTH);
d164 1
a164 1
									movto(YBASE + i, XBASE + 2*j);
@


1.15
log
@synchronization between usage and synopsis; add some missing "usage:"'s

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.14 2004/11/29 09:32:47 jsg Exp $	*/
a35 1
char scrol;
d57 1
d61 2
a62 1
	char *ep;
d81 3
a83 5
		t = strtol(*argv, &ep, 10);
		if ((*argv)[0] == '\0' || *ep != '\0')
			usage();
		if (t < 1 || t >= INT_MAX) {
			fprintf(stderr, "number of seconds is out of range");
a85 1
		n = t;
d89 4
d175 10
d192 3
@


1.14
log
@Use volatile sig_atomic_t rather than int for sigtermed, from pjanzen@@
ok miod@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.13 2004/11/29 08:52:28 jsg Exp $	*/
d240 1
a240 1
	(void)fprintf(stderr, "usage: grdc [-s] [number_of_seconds]\n");
@


1.13
log
@ansi. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.12 2002/07/26 20:32:38 pjanzen Exp $	*/
d38 1
a38 1
int sigtermed=0;
@


1.12
log
@The elusive original author of this program and man page surfaced long enough
to state the following, when asked about licensing issues:
    "It's ok to put any copyright as long as it stays in the public domain.
...
    Since I did not write it to make any profit or fame in the first place,
    I guess its use is not limited by any license.  Of course I would not
    object to my name being mentioned."
Then he disappeared again.

So I've put on a current copyright to him, and labelled the code explicitly
as public domain.
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.11 2002/05/31 03:40:00 pjanzen Exp $	*/
d48 1
a48 2
sighndl(signo)
	int signo;
d54 1
a54 3
main(argc, argv)
	int argc;
	char *argv[];
d238 1
a238 1
usage()
@


1.11
log
@No dm -> no need to revoke setegid.
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.10 2002/02/16 21:27:10 millert Exp $	*/
d3 3
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.9 2000/07/05 08:26:36 pjanzen Exp $	*/
a61 4

	/* revoke privs */
	setegid(getgid());
	setgid(getgid());
@


1.9
log
@nanosleep() no longer returns early
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.8 2000/01/24 07:53:57 pjanzen Exp $	*/
d39 4
a42 4
void set __P((int, int));
void standt __P((int));
void movto __P((int, int));
void usage __P((void));
@


1.8
log
@parse command line more carefully; watch out for nanosleep() ending a
little too early; and do some general tidying
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.7 2000/01/21 07:10:39 pjanzen Exp $	*/
a60 1
	time_t then;
a136 1
	then = now.tv_sec - 1;
d182 1
a182 8
		/* On some systems nanosleep() can return early, before a full
		 * second has passed according to gettimeofday().
		 */
		if (now.tv_sec == then) {
			delay.tv_sec = 1;
			now.tv_sec++;
		} else
			delay.tv_sec = 0;
a184 1
		then = now.tv_sec;
@


1.7
log
@Hide cursor if possible
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.6 2000/01/20 12:31:33 d Exp $	*/
d11 3
a13 1
#include <time.h>
a14 1
#include <curses.h>
d16 2
a17 1
#ifndef NONPOSIX
a18 2
#endif
#include <sys/time.h>
d25 1
a25 2
/* it won't be */
struct timespec now; /* yeah! */
d39 4
a42 3
void set(int, int);
void standt(int);
void movto(int, int);
d61 2
a62 1
	char *hc;
d68 27
d114 1
a114 3
	if ((hc = tigetstr("civis")) != 0 && hc != (char *)-1)
		putp(hc);

a116 7
	while(--argc > 0) {
		if(**++argv == '-')
			scrol = 1;
		else
			n = atoi(*argv);
	}

d138 1
d184 8
a191 1
		delay.tv_sec = 0;
d194 1
a198 2
			if ((hc = tigetstr("cnorm")) > 0 && hc != (char *)-1)
				putp(hc);
a206 2
	if ((hc = tigetstr("cnorm")) > 0 && hc != (char *)-1)
		putp(hc);
d249 7
@


1.6
log
@track seconds more accurately. ok pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.5 1998/03/19 11:41:51 pjanzen Exp $	*/
d61 1
d86 3
d171 2
d181 2
a225 1

@


1.5
log
@Minor tweaks, mainly setgid-related
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.4 1997/07/31 19:09:34 deraadt Exp $	*/
d18 1
d26 1
a26 1
time_t now; /* yeah! */
d59 2
d113 2
d117 1
a117 2
		time(&now);
		tm = localtime(&now);
d158 7
a164 1
		sleep(1);
@


1.4
log
@time_t is not long
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.3 1996/12/22 20:01:17 deraadt Exp $	*/
a58 2
	initscr();

d62 2
@


1.3
log
@proper gid revoke
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.2 1996/12/19 22:21:30 deraadt Exp $	*/
d25 1
a25 1
long now; /* yeah! */
d43 3
a45 2
void sighndl(signo)
int signo;
d52 2
a53 2
int argc;
char **argv;
d55 3
a57 3
long t, a;
int i, j, s, k;
int n = 0;
d174 1
a174 1
int i, m;
@


1.2
log
@setgid games, not setuid games. closes a neat set of holes
@
text
@d1 1
a1 1
/*	$OpenBSD: grdc.c,v 1.1 1996/08/21 07:58:08 downsj Exp $	*/
d60 2
@


1.1
log
@From FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 2
@

