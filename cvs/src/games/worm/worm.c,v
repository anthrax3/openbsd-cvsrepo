head	1.38;
access;
symbols
	OPENBSD_6_1:1.38.0.6
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.26.0.6
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.23.0.16
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.14
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.12
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.10
	OPENBSD_5_0:1.23.0.8
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.22
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.18
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.16
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.14
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.12
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.10
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.8
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.6
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.4
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.21.0.6
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.38
date	2016.01.07.16.00.33;	author tb;	state Exp;
branches;
next	1.37;
commitid	IwzFE3fG5RnKTWNh;

1.37
date	2016.01.04.17.33.24;	author mestre;	state Exp;
branches;
next	1.36;
commitid	b21xvsfCGMtCOVrz;

1.36
date	2016.01.03.14.38.17;	author mestre;	state Exp;
branches;
next	1.35;
commitid	Ptgw9rNvmSHNRfGy;

1.35
date	2015.12.26.00.26.40;	author mestre;	state Exp;
branches;
next	1.34;
commitid	NcBz9zfScw6TwPoT;

1.34
date	2015.11.21.05.29.42;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	75xaVUS6ay2FsYSe;

1.33
date	2015.11.04.21.22.10;	author tedu;	state Exp;
branches;
next	1.32;
commitid	XDKIiXhFNs4jqYjv;

1.32
date	2015.08.26.01.25.57;	author rzalamena;	state Exp;
branches;
next	1.31;
commitid	Od0BaPKY6uFBy2bv;

1.31
date	2015.08.24.21.52.12;	author rzalamena;	state Exp;
branches;
next	1.30;
commitid	d6f6P3GyhrZCbJQF;

1.30
date	2015.08.22.14.47.41;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	vWCbqNWL9DL2UkGT;

1.29
date	2015.08.21.02.42.26;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	alT5fRHDXomnrXRm;

1.28
date	2015.03.09.19.52.02;	author tedu;	state Exp;
branches;
next	1.27;
commitid	8Y0uw8q53W0S0uY3;

1.27
date	2014.11.03.22.14.54;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	as6i62fI9q0ursQL;

1.26
date	2014.01.28.14.30.28;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2014.01.28.14.28.44;	author jmc;	state Exp;
branches;
next	1.24;

1.24
date	2013.08.29.20.22.21;	author naddy;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.27.23.59.27;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2004.11.29.08.52.29;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.03.03.01.42;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.19.07.58.00;	author pjanzen;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.19.07.53.54;	author pjanzen;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.06.21.48.51;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.31.04.21.30;	author pjanzen;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.31.03.40.01;	author pjanzen;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.27.12;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.17.08.21.44;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.03.18.04.08;	author pjanzen;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.03.17.45.43;	author pjanzen;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.18.18.22.26;	author pjanzen;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.25.07.06.41;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	99.09.03.09.35.24;	author hugh;	state Exp;
branches;
next	1.8;

1.8
date	99.04.20.23.01.13;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	98.09.16.00.44.37;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	98.08.19.07.42.21;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	98.03.12.09.09.30;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	98.02.08.18.59.57;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.12.22.20.02.04;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.12.19.22.22.12;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.28;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Some basic code maintenance in games/

- in main() replace exit with return
- drop some /* NOTREACHED */ lint comments along the way.
- make more use of standard CFLAGS, esp. -Wimplicit-function-declaration
- add and sort some headers when needed
- add straightforward pledges to some programs used at compile time

discussed with and ok mestre@@
@
text
@/*	$OpenBSD: worm.c,v 1.37 2016/01/04 17:33:24 mestre Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Worm.  Written by Michael Toy
 * UCSC
 */

#include <ctype.h>
#include <curses.h>
#include <err.h>
#include <poll.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>

#define HEAD '@@'
#define BODY 'o'
#define LENGTH 7
#define RUNLEN 8
#define CNTRL(p) (p-'A'+1)

WINDOW *tv;
WINDOW *stw;
struct body {
	int x;
	int y;
	struct body *prev;
	struct body *next;
} *head, *tail, goody;
int growing = 0;
int growthscale = 1;
int running = 0;
int slow = 0;
int score = 0;
int start_len = LENGTH;
int visible_len;
int lastch;
char outbuf[BUFSIZ];

volatile sig_atomic_t wantleave = 0;
volatile sig_atomic_t wantsuspend = 0;

__dead void	crash(void);
void	display(struct body *, char);
void	leave(int);
void	life(void);
void	newpos(struct body *);
struct body 	*newlink(void);
int	process(int);
void	prize(void);
int	rnd(int);
void	setup(void);
void	suspend(int);

int
main(int argc, char **argv)
{
	int retval;
	struct pollfd pfd[1];
	const char *errstr;
	struct timespec t, tn, tdiff;

	if (pledge("stdio rpath tty", NULL) == -1)
		err(1, "pledge");

	timespecclear(&t);

	setvbuf(stdout, outbuf, _IOFBF, sizeof outbuf);
	signal(SIGINT, leave);
	signal(SIGQUIT, leave);
	signal(SIGTSTP, suspend);	/* process control signal */
	initscr();
	cbreak();
	noecho();
	keypad(stdscr, TRUE);
	slow = (baudrate() <= 1200);
	clear();
	if (COLS < 18 || LINES < 5) {
		endwin();
		errx(1, "screen too small");
	}
	growthscale = COLS * LINES / 2000;
	if (growthscale == 0)
		growthscale = 1;
	if (argc >= 2) {
		start_len = strtonum(argv[1], 1, ((LINES-3) * (COLS-2)) / 3,
		    &errstr);
		if (errstr) {
			endwin();
			errx(1, "length argument is %s.", errstr);
		}
	}
	stw = newwin(1, COLS-1, 0, 0);
	tv = newwin(LINES-1, COLS-1, 1, 0);
	box(tv, '*', '*');
	scrollok(tv, FALSE);
	scrollok(stw, FALSE);
	wmove(stw, 0, 0);
	wprintw(stw, " Worm");
	refresh();
	wrefresh(stw);
	wrefresh(tv);
	life();			/* Create the worm */
	prize();		/* Put up a goal */
	wmove(tv, head->y, head->x);    /* Leave cursor on worm */
	wrefresh(tv);
	while (1) {
		if (wantleave) {
			endwin();
			return 0;
		}
		if (wantsuspend) {
			move(LINES-1, 0);
			refresh();
			endwin();
			fflush(stdout);
			kill(getpid(), SIGSTOP);
			signal(SIGTSTP, suspend);
			cbreak();
			noecho();
			setup();
			wantsuspend = 0;
		}

		if (running) {
			running--;
			process(lastch);
		} else {
			/* Check for timeout. */
			clock_gettime(CLOCK_MONOTONIC, &tn);
			if (timespeccmp(&t, &tn, <=)) {
				t = tn;
				t.tv_sec += 1;

				process(lastch);
				continue;
			}

			/* Prepare next read */
			pfd[0].fd = STDIN_FILENO;
			pfd[0].events = POLLIN;
			timespecsub(&t, &tn, &tdiff);
			retval = ppoll(pfd, 1, &tdiff, NULL);

			/* Nothing to do if timed out or signal. */
			if (retval <= 0)
				continue;

			/* Only update timer if valid key was pressed. */
			if (process(getch()) == 0)
				continue;

			/* Update using clock_gettime(), tn is too old now. */
			clock_gettime(CLOCK_MONOTONIC, &t);
			t.tv_sec += 1;
		}
	}
}

void
life(void)
{
	struct body *bp, *np;
	int i,j = 1;

	head = newlink();
	head->x = start_len % (COLS-5) + 2;
	head->y = LINES / 2;
	head->next = NULL;
	display(head, HEAD);
	for (i = 0, bp = head; i < start_len; i++, bp = np) {
		np = newlink();
		np->next = bp;
		bp->prev = np;
		if (((bp->x <= 2) && (j == 1)) || ((bp->x >= COLS-4) && (j == -1))) {
			j *= -1;
			np->x = bp->x;
			np->y = bp->y + 1;
		} else {
			np->x = bp->x - j;
			np->y = bp->y;
		}
		display(np, BODY);
	}
	tail = np;
	tail->prev = NULL;
	visible_len = start_len + 1;
}

void
display(struct body *pos, char chr)
{
	wmove(tv, pos->y, pos->x);
	waddch(tv, chr);
}

void
leave(int dummy)
{
	wantleave = 1;
}

int
rnd(int range)
{
	return arc4random_uniform(range);
}

void
newpos(struct body *bp)
{
	if (visible_len == (LINES-3) * (COLS-3) - 1) {
		endwin();
		printf("\nYou won!\nYour final score was %d\n\n", score);
		exit(0);
	}
	do {
		bp->y = rnd(LINES-3)+ 1;
		bp->x = rnd(COLS-3) + 1;
		wmove(tv, bp->y, bp->x);
	} while(winch(tv) != ' ');
}

void
prize(void)
{
	int value;

	value = rnd(9) + 1;
	newpos(&goody);
	waddch(tv, value+'0');
	wrefresh(tv);
}

int
process(int ch)
{
	int x,y;
	struct body *nh;

	x = head->x;
	y = head->y;
	switch(ch) {
#ifdef KEY_LEFT
	case KEY_LEFT:
#endif
	case 'h':
		x--;
		break;
#ifdef KEY_DOWN
	case KEY_DOWN:
#endif
	case 'j':
		y++;
		break;
#ifdef KEY_UP
	case KEY_UP:
#endif
	case 'k':
		y--;
		break;
#ifdef KEY_RIGHT
	case KEY_RIGHT:
#endif
	case 'l':
		x++;
		break;
	case 'H':
		x--;
		running = RUNLEN;
		ch = tolower(ch);
		break;
	case 'J':
		y++;
		running = RUNLEN/2;
		ch = tolower(ch);
		break;
	case 'K':
		y--;
		running = RUNLEN/2;
		ch = tolower(ch);
		break;
	case 'L':
		x++;
		running = RUNLEN;
		ch = tolower(ch);
		break;
	case '\f':
		setup();
		return (0);
	case CNTRL('Z'):
		suspend(0);
		return (0);
	case CNTRL('C'):
		crash();
		return (0);
	case CNTRL('D'):
		crash();
		return (0);
	case ERR:
		leave(0);
		return (0);
	default:
		return (0);
	}
	lastch = ch;
	if (growing == 0) {
		display(tail, ' ');
		tail->next->prev = NULL;
		nh = tail->next;
		free(tail);
		tail = nh;
		visible_len--;
	} else
		growing--;
	display(head, BODY);
	wmove(tv, y, x);
	if (isdigit(ch = winch(tv))) {
		int amt = ch - '0';
		growing += amt * growthscale;
		prize();
		score += amt;
		running = 0;
		wmove(stw, 0, COLS - 12);
		wprintw(stw, "Score: %3d", score);
		wrefresh(stw);
	} else if(ch != ' ')
		crash();
	nh = newlink();
	nh->next = NULL;
	nh->prev = head;
	head->next = nh;
	nh->y = y;
	nh->x = x;
	display(nh, HEAD);
	head = nh;
	visible_len++;
	if (!(slow && running)) {
		wmove(tv, head->y, head->x);
		wrefresh(tv);
	}
	return (1);
}

struct body *
newlink(void)
{
	struct body *tmp;

	if ((tmp = malloc(sizeof (struct body))) == NULL) {
		endwin();
		errx(1, "out of memory");
	}
	return (tmp);
}

void
crash(void)
{
	sleep(2);
	clear();
	endwin();
	printf("Well, you ran into something and the game is over.\n");
	printf("Your final score was %d\n", score);
	exit(0);  /* leave() calls endwin(), which would hose the printf()'s */
}

void
suspend(int dummy)
{
	wantsuspend = 1;
}

void
setup(void)
{
	clear();
	refresh();
	touchwin(stw);
	wrefresh(stw);
	touchwin(tv);
	wrefresh(tv);
}
@


1.37
log
@More cleanup and sorting on header section

OK tb@@ and he also pointed out that for consistency with rest of the tree we
should include termios.h instead of sys/ttydefaults.h, where applicable
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.36 2016/01/03 14:38:17 mestre Exp $	*/
d139 1
a139 1
			exit(0);
@


1.36
log
@About 13 years ago when the idiom srandom(time()), and sometimes
srandom(time()+getpid()), was changed by srandomdev(), but #include <time.h>
lived up until this day so remove it.

Additionally, earlier than that, 18 years ago, random(6) was one of the first
consumers of arc4random(3) family, and was pulling it from dev/rndvar.h but
these days we pull it from stdlib.h, which is already done, so while here
remove dev/rndvar.h also.

"seems comprehensive to me" deraadt@@ and OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.35 2015/12/26 00:26:40 mestre Exp $	*/
a36 2
#include <sys/types.h>

d40 1
a42 1
#include <string.h>
a43 1
#include <poll.h>
@


1.35
log
@Set as __dead a few more functions, that don't return, on games/

With precious tip, help and also OK from tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.34 2015/11/21 05:29:42 deraadt Exp $	*/
d38 1
a44 1
#include <time.h>
@


1.34
log
@pledge the wyrms
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.33 2015/11/04 21:22:10 tedu Exp $	*/
d75 1
a75 1
void	crash(void);
@


1.33
log
@replace setbuf with setvbuf, from Frederic Nowak
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.32 2015/08/26 01:25:57 rzalamena Exp $	*/
d94 3
@


1.32
log
@Replace clock_gettime UPTIME with MONOTONIC to improve worm portability.

ok deraadt@@, guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.31 2015/08/24 21:52:12 rzalamena Exp $	*/
d97 1
a97 1
	setbuf(stdout, outbuf);
@


1.31
log
@Fix cheating bug by using unused time variables and replace poll() with
ppoll() to better use the timespec struct.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.30 2015/08/22 14:47:41 deraadt Exp $	*/
d159 1
a159 1
			clock_gettime(CLOCK_UPTIME, &tn);
d183 1
a183 1
			clock_gettime(CLOCK_UPTIME, &t);
@


1.30
log
@remove malloc/calloc/realloc* casts, due to stdlib.h being present; ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.29 2015/08/21 02:42:26 deraadt Exp $	*/
d81 1
a81 1
void	process(int);
a90 2
	struct timeval t, tod;
	struct timezone tz;
d93 3
d158 11
a168 5
			/* fflush(stdout); */
			/* Delay could be a command line option */
			t.tv_sec = 1;
			t.tv_usec = 0;
			(void)gettimeofday(&tod, &tz);
d171 14
a184 5
			retval = poll(pfd, 1, t.tv_sec * 1000 + t.tv_usec / 1000);
			if (retval > 0)
				process(getch());
			else
				process(lastch);
d264 1
a264 1
void
d319 1
a319 1
		return;
d322 1
a322 1
		return;
d325 1
a325 1
		return;
d328 1
a328 1
		return;
d331 1
a331 1
		return;
d333 1
a333 1
		return;
d371 1
@


1.29
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.28 2015/03/09 19:52:02 tedu Exp $	*/
d362 1
a362 1
	if ((tmp = (struct body *) malloc(sizeof (struct body))) == NULL) {
@


1.28
log
@make the worm grow faster on larger terminals. this is more fun than
starting with an enormous pile of worm at the start.
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.27 2014/11/03 22:14:54 deraadt Exp $	*/
d135 1
a135 2
	while(1)
	{
d137 1
a137 1
			endwin();		/* XXX signal race */
d153 1
a153 2
		if (running)
		{
d156 1
a156 3
		}
		else
		{
d256 1
a256 2
	switch(ch)
	{
d258 1
a258 1
		case KEY_LEFT:
d260 3
a262 2
		case 'h':
			x--; break;
d264 1
a264 1
		case KEY_DOWN:
d266 3
a268 2
		case 'j':
			y++; break;
d270 1
a270 1
		case KEY_UP:
d272 3
a274 2
		case 'k':
			y--; break;
d276 1
a276 1
		case KEY_RIGHT:
d278 40
a317 12
		case 'l':
			x++; break;
		case 'H': x--; running = RUNLEN; ch = tolower(ch); break;
		case 'J': y++; running = RUNLEN/2; ch = tolower(ch); break;
		case 'K': y--; running = RUNLEN/2; ch = tolower(ch); break;
		case 'L': x++; running = RUNLEN; ch = tolower(ch); break;
		case '\f': setup(); return;
		case CNTRL('Z'): suspend(0); return;
		case CNTRL('C'): crash(); return;
		case CNTRL('D'): crash(); return;
		case ERR: leave(0); return;
		default: return;
d320 1
a320 2
	if (growing == 0)
	{
d327 2
a328 2
	}
	else growing--;
d331 1
a331 2
	if (isdigit(ch = winch(tv)))
	{
d340 2
a341 2
	}
	else if(ch != ' ') crash();
@


1.27
log
@select() to poll() conversions
ok tedu (... other games maintainer absent)
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.26 2014/01/28 14:30:28 jmc Exp $	*/
d63 1
d110 3
d308 2
a309 1
		growing += ch-'0';
d311 1
a311 1
		score += growing;
@


1.26
log
@from pjanzen:
Start with the cursor on the worm's head.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.25 2014/01/28 14:28:44 jmc Exp $	*/
d46 1
d92 1
a92 1
	fd_set rset;
a94 1
	FD_ZERO(&rset);
d162 3
a164 2
			FD_SET(STDIN_FILENO, &rset);
			retval = select(STDIN_FILENO + 1, &rset, NULL, NULL, &t);
@


1.25
log
@from pjanzen:
Use strtonum() and error out on an unacceptable length argument rather than
reverting to default values; document maximum initial length limit.

started by a diff From: Jan Stary, who requested we document default behaviour

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.24 2013/08/29 20:22:21 naddy Exp $	*/
d129 2
@


1.24
log
@replace srandomdev()+random() with the arc4random*() family
tweaks and ok millert@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.23 2009/10/27 23:59:27 deraadt Exp $	*/
d92 1
d109 8
a116 4
	if (argc == 2)
		start_len = atoi(argv[1]);
	if ((start_len <= 0) || (start_len > ((LINES-3) * (COLS-2)) / 3))
		start_len = LENGTH;
@


1.23
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.22 2004/11/29 08:52:29 jsg Exp $	*/
a94 1
	srandomdev();
d211 1
a211 1
	return random() % range;
@


1.22
log
@ansi. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.21 2003/06/03 03:01:42 millert Exp $	*/
a30 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)worm.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: worm.c,v 1.21 2003/06/03 03:01:42 millert Exp $";
#endif
#endif /* not lint */
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.20 2003/05/19 07:58:00 pjanzen Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: worm.c,v 1.20 2003/05/19 07:58:00 pjanzen Exp $";
d181 1
a181 1
life()
d245 1
a245 1
prize()
d336 1
a336 1
newlink()
d348 1
a348 1
crash()
d365 1
a365 1
setup()
@


1.20
log
@ANSI
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.19 2003/05/19 07:53:54 pjanzen Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d42 1
a42 1
static char rcsid[] = "$OpenBSD: worm.c,v 1.19 2003/05/19 07:53:54 pjanzen Exp $";
@


1.19
log
@volatile sig_atomic_t
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.18 2002/12/06 21:48:51 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: worm.c,v 1.18 2002/12/06 21:48:51 millert Exp $";
d104 1
a104 3
main(argc, argv)
	int argc;
	char **argv;
d215 1
a215 3
display(pos, chr)
	struct body *pos;
	char chr;
d222 1
a222 2
leave(dummy)
	int dummy;
d228 1
a228 2
rnd(range)
	int range;
d234 1
a234 2
newpos(bp)
	struct body * bp;
d260 1
a260 2
process(ch)
	int ch;
d363 1
a363 2
suspend(dummy)
	int dummy;
@


1.18
log
@Replace things like srandom(time(NULL)) with srandomdev(3).  random(3)
good enough for games but we should at least use a decent seed.
pjanzen@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.17 2002/05/31 04:21:30 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: worm.c,v 1.17 2002/05/31 04:21:30 pjanzen Exp $";
d88 2
a89 2
int wantleave;
int wantsuspend;
@


1.17
log
@de-register
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.16 2002/05/31 03:40:01 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: worm.c,v 1.16 2002/05/31 03:40:01 pjanzen Exp $";
d115 1
a115 1
	srandom(getpid());
@


1.16
log
@No dm -> no need to revoke setegid.
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.15 2002/02/16 21:27:12 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: worm.c,v 1.15 2002/02/16 21:27:12 millert Exp $";
d189 2
a190 2
	register struct body *bp, *np;
	register int i,j = 1;
d270 1
a270 1
	register int x,y;
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.14 2001/11/17 08:21:44 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: worm.c,v 1.14 2001/11/17 08:21:44 deraadt Exp $";
a111 4

	/* revoke */
	setegid(getgid());
	setgid(getgid());
@


1.14
log
@move gunk out of signal handlers, now safe
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.13 2001/09/03 18:04:08 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: worm.c,v 1.13 2001/09/03 18:04:08 pjanzen Exp $";
d91 11
a101 11
void	crash __P((void));
void	display __P((struct body *, char));
void	leave __P((int));
void	life __P((void));
void	newpos __P((struct body *));
struct body 	*newlink __P((void));
void	process __P((int));
void	prize __P((void));
int	rnd __P((int));
void	setup __P((void));
void	suspend __P((int));
@


1.13
log
@Handle EOF on stdin.
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.12 2001/09/03 17:45:43 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: worm.c,v 1.12 2001/09/03 17:45:43 pjanzen Exp $";
d88 3
d151 17
d233 1
a233 2
	endwin();
	exit(0);
d378 1
a378 9
	move(LINES-1, 0);
	refresh();
	endwin();
	fflush(stdout);
	kill(getpid(), SIGSTOP);
	signal(SIGTSTP, suspend);
	cbreak();
	noecho();
	setup();
@


1.12
log
@Fixes from NetBSD (jsm@@), one reported by Malcolm Parsons
<malcolm@@ivywell.screaming.net>:  don't hang if the worm occupies all the
space, fix off-by-one, and check for screen size.
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.11 2001/02/18 18:22:26 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: worm.c,v 1.11 2001/02/18 18:22:26 pjanzen Exp $";
d290 1
@


1.11
log
@include <string.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.10 2000/01/25 07:06:41 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: worm.c,v 1.10 2000/01/25 07:06:41 pjanzen Exp $";
d84 1
d126 4
d197 1
d228 5
d234 1
a234 1
		bp->y = rnd(LINES-3)+ 2;
d300 1
d324 1
@


1.10
log
@support arrow keys (cgd@@netbsd.org); use select() rather than alarm() for
timing
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.9 1999/09/03 09:35:24 hugh Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: worm.c,v 1.9 1999/09/03 09:35:24 hugh Exp $";
d61 1
@


1.9
log
@unbreak brake
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.8 1999/04/20 23:01:13 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: worm.c,v 1.8 1999/04/20 23:01:13 pjanzen Exp $";
d55 1
d61 1
a61 1
#include <termios.h>
d83 1
a83 1
char lastch;
d92 1
a92 1
void	process __P((char));
a96 1
void	wake __P((int));
d103 4
a106 1
	char ch;
d112 1
a114 1
	signal(SIGALRM, wake);
d119 1
a119 1
	crmode();
d121 1
d149 11
a159 3
		    fflush(stdout);
		    if (read(0, &ch, 1) >= 0)
			process(ch);
a209 9
void
wake(dummy)
	int dummy;
{
	signal(SIGALRM, wake);
	fflush(stdout);
	process(lastch);
}

d241 1
a241 1
	char ch;
a245 1
	alarm(0);
d250 20
a269 4
		case 'h': x--; break;
		case 'j': y++; break;
		case 'k': y--; break;
		case 'l': x++; break;
d278 1
a278 2
		default: if (! running) alarm(1);
			   return;
a314 2
	if (!running)
		alarm(1);
d350 1
a350 1
	crmode();
a363 1
	alarm(1);
@


1.8
log
@jsm28@@cam.ac.uk: place cursor on player, not one over.
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.7 1998/09/16 00:44:37 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: worm.c,v 1.7 1998/09/16 00:44:37 pjanzen Exp $";
d333 1
a333 1
	kill(getpid(), SIGTSTP);
@


1.7
log
@Make sure malloc() succeeds
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.6 1998/08/19 07:42:21 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: worm.c,v 1.6 1998/08/19 07:42:21 pjanzen Exp $";
d294 2
a295 1
	if (!(slow && running))
d297 1
@


1.6
log
@tags, formatting, ANSI-fication, prototypes, de-typos, and the occasional
initialization, removal of unused variable, or other minor fix.  Most
changes are from or inspired by NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: worm.c,v 1.5 1998/03/12 09:09:30 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: worm.c,v 1.5 1998/03/12 09:09:30 pjanzen Exp $";
d57 1
a62 1
#define newlink() (struct body *) malloc(sizeof (struct body));
d90 1
d167 1
a167 1
		if (((bp->x <= 2) && (j == 1)) || ((bp->x >= COLS-4)) && (j == -1)) {
d298 12
@


1.5
log
@OpenBSD ID (changed from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD$";
d182 2
a183 2
struct body *pos;
char chr;
d191 1
a191 1
int dummy;
d199 1
a199 1
int dummy;
d208 1
a208 1
int range;
d215 1
a215 1
struct body * bp;
d237 1
a237 1
char ch;
d312 1
a312 1
int dummy;
@


1.4
log
@cleanup; pjanzen@@foatdi.harvard.edu
@
text
@d1 1
a1 1
/*	$NetBSD: worm.c,v 1.7 1995/04/29 01:12:41 mycroft Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: worm.c,v 1.7 1995/04/29 01:12:41 mycroft Exp $";
@


1.3
log
@proper gid revoke
@
text
@d60 1
d85 11
a95 1
void leave(), wake(), suspend();
d97 1
a107 4
	if (argc == 2)
		start_len = atoi(argv[1]);
	if ((start_len <= 0) || (start_len > 500))
		start_len = LENGTH;
d109 1
a109 1
	srand(getpid());
d119 4
d151 1
d155 1
a155 1
	register int i;
d158 2
a159 2
	head->x = start_len+2;
	head->y = 12;
d166 8
a173 2
		np->x = bp->x - 1;
		np->y = bp->y;
d180 1
d190 2
a191 1
leave()
d198 2
a199 1
wake()
d206 1
d208 1
d210 1
a210 1
	return abs((rand()>>5)+(rand()>>5)) % range;
d213 1
d224 1
d235 1
d256 1
a256 1
		case CNTRL('Z'): suspend(); return;
d280 1
a280 1
		wmove(stw, 0, 68);
d299 1
d304 1
a304 2
	move(23, 0);
	refresh();
d307 1
a307 1
	leave();
d311 2
a312 1
suspend()
a313 2
	char *sh;

d325 1
@


1.2
log
@setgid games, not setuid games. closes a neat set of holes
@
text
@d92 2
@


1.1
log
@Initial revision
@
text
@d92 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

