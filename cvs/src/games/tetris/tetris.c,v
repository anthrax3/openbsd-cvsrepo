head	1.31;
access;
symbols
	OPENBSD_6_0:1.31.0.2
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.24.0.6
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.23.0.16
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.14
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.12
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.10
	OPENBSD_5_0:1.23.0.8
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.8
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.21.0.8
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.6
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.4
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.20.0.8
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.6
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.4
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2016.06.10.13.07.07;	author tb;	state Exp;
branches;
next	1.30;
commitid	NRKg9pYxzWxyBKpm;

1.30
date	2016.03.07.12.07.57;	author mestre;	state Exp;
branches;
next	1.29;
commitid	NZhYxChmyb9vOEMM;

1.29
date	2016.01.07.16.00.33;	author tb;	state Exp;
branches;
next	1.28;
commitid	IwzFE3fG5RnKTWNh;

1.28
date	2016.01.04.17.33.24;	author mestre;	state Exp;
branches;
next	1.27;
commitid	b21xvsfCGMtCOVrz;

1.27
date	2015.12.25.20.59.09;	author mestre;	state Exp;
branches;
next	1.26;
commitid	5J5Os05YMVA0ZKC5;

1.26
date	2015.11.20.07.40.23;	author tb;	state Exp;
branches;
next	1.25;
commitid	axu8igWxJtuLDVUq;

1.25
date	2014.11.16.04.49.49;	author guenther;	state Exp;
branches;
next	1.24;
commitid	8XNajyb9IqHkZEKg;

1.24
date	2013.08.29.20.22.20;	author naddy;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.28.00.25.38;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2008.03.17.09.17.56;	author sobrado;	state Exp;
branches;
next	1.21;

1.21
date	2006.04.20.03.24.12;	author ray;	state Exp;
branches;
next	1.20;

1.20
date	2004.07.10.07.26.24;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.10.01.23.20;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.03.03.01.41;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.08.18.09.28;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.06.18.50.38;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.12.06.21.48.51;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.26.21.33.28;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.26.20.19.22;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.31.04.21.30;	author pjanzen;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.27.11;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.19.21.29.06;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.04.14.23.28;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.03.23.22.45;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	99.03.22.07.38.28;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	99.03.22.05.20.03;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	99.02.12.04.08.55;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	98.09.24.06.45.08;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.40.46;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.12.21.21.43.55;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.23;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.23;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.31
log
@When eliding a row, clear the invisible row zero, so that no columns
can become unusable during game play.  Same fix was made in NetBSD's
tetris.c -r1.31 by Christos Zoulas almost exactly a year ago.

ok tedu
@
text
@/*	$OpenBSD: tetris.c,v 1.30 2016/03/07 12:07:57 mestre Exp $	*/
/*	$NetBSD: tetris.c,v 1.2 1995/04/22 07:42:47 cgd Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek and Darren F. Provine.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)tetris.c	8.1 (Berkeley) 5/31/93
 */

/*
 * Tetris (or however it is spelled).
 */

#include <err.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "input.h"
#include "scores.h"
#include "screen.h"
#include "tetris.h"

cell	board[B_SIZE];
int	Rows, Cols;
const struct shape *curshape;
const struct shape *nextshape;
long	fallrate;
int	score;
char	key_msg[100];
int	showpreview, classic;

static void		 elide(void);
void			 onintr(int);
const struct shape	*randshape(void);
static void		 setup_board(void);
__dead void		 usage(void);

/*
 * Set up the initial board.  The bottom display row is completely set,
 * along with another (hidden) row underneath that.  Also, the left and
 * right edges are set.
 */
static void
setup_board(void)
{
	int i;
	cell *p;

	p = board;
	for (i = B_SIZE; i; i--)
		*p++ = i <= (2 * B_COLS) || (i % B_COLS) < 2;
}

/*
 * Elide any full active rows.
 */
static void
elide(void)
{
	int rows = 0;
	int i, j, base;
	cell *p;

	for (i = A_FIRST; i < A_LAST; i++) {
		base = i * B_COLS + 1;
		p = &board[base];
		for (j = B_COLS - 2; *p++ != 0;) {
			if (--j <= 0) {
				/* this row is to be elided */
				rows++;
				memset(&board[base], 0, B_COLS - 2);
				scr_update();
				tsleep();
				while (--base != 0)
					board[base + B_COLS] = board[base];
				memset(&board[1], 0, B_COLS - 2);
				scr_update();
				tsleep();
				break;
			}
		}
	}
	switch (rows) {
	case 1:
		score += 10;
		break;
	case 2:
		score += 30;
		break;
	case 3:
		score += 70;
		break;
	case 4:
		score += 150;
		break;
	default:
		break;
	}
}

const struct shape *
randshape(void)
{
	const struct shape *tmp;
	int i, j;

	tmp = &shapes[arc4random_uniform(7)];
	j = arc4random_uniform(4);
	for (i = 0; i < j; i++)
		tmp = &shapes[classic? tmp->rotc : tmp->rot];
	return (tmp);
}
	

int
main(int argc, char *argv[])
{
	int pos, c;
	char *keys;
	int level = 2;
	char key_write[6][10];
	const char *errstr;
	int ch, i, j;

	if (pledge("stdio rpath wpath cpath tty", NULL) == -1)
		err(1, "pledge");

	keys = "jkl pq";

	classic = showpreview = 0;
	while ((ch = getopt(argc, argv, "ck:l:ps")) != -1)
		switch(ch) {
		case 'c':
			/*
			 * this means:
			 *	- rotate the other way;
			 *	- no reverse video.
			 */
			classic = 1;
			break;
		case 'k':
			if (strlen(keys = optarg) != 6)
				usage();
			break;
		case 'l':
			level = (int)strtonum(optarg, MINLEVEL, MAXLEVEL,
			    &errstr);
			if (errstr)
				errx(1, "level must be from %d to %d",
				    MINLEVEL, MAXLEVEL);
			break;
		case 'p':
			showpreview = 1;
			break;
		case 's':
			showscores(0);
			return 0;
		default:
			usage();
		}

	argc -= optind;
	argv += optind;

	if (argc)
		usage();

	fallrate = 1000000 / level;

	for (i = 0; i <= 5; i++) {
		for (j = i+1; j <= 5; j++) {
			if (keys[i] == keys[j])
				errx(1, "duplicate command keys specified.");
		}
		if (keys[i] == ' ')
			strlcpy(key_write[i], "<space>", sizeof key_write[i]);
		else {
			key_write[i][0] = keys[i];
			key_write[i][1] = '\0';
		}
	}

	snprintf(key_msg, sizeof key_msg,
"%s - left   %s - rotate   %s - right   %s - drop   %s - pause   %s - quit",
		key_write[0], key_write[1], key_write[2], key_write[3],
		key_write[4], key_write[5]);

	(void)signal(SIGINT, onintr);
	scr_init();
	setup_board();

	scr_set();

	pos = A_FIRST*B_COLS + (B_COLS/2)-1;
	nextshape = randshape();
	curshape = randshape();

	scr_msg(key_msg, 1);

	for (;;) {
		place(curshape, pos, 1);
		scr_update();
		place(curshape, pos, 0);
		c = tgetchar();
		if (c < 0) {
			/*
			 * Timeout.  Move down if possible.
			 */
			if (fits_in(curshape, pos + B_COLS)) {
				pos += B_COLS;
				continue;
			}

			/*
			 * Put up the current shape `permanently',
			 * bump score, and elide any full rows.
			 */
			place(curshape, pos, 1);
			score++;
			elide();

			/*
			 * Choose a new shape.  If it does not fit,
			 * the game is over.
			 */
			curshape = nextshape;
			nextshape = randshape();
			pos = A_FIRST*B_COLS + (B_COLS/2)-1;
			if (!fits_in(curshape, pos))
				break;
			continue;
		}

		/*
		 * Handle command keys.
		 */
		if (c == keys[5]) {
			/* quit */
			break;
		}
		if (c == keys[4]) {
			static char msg[] =
			    "paused - press RETURN to continue";

			place(curshape, pos, 1);
			do {
				scr_update();
				scr_msg(key_msg, 0);
				scr_msg(msg, 1);
				(void) fflush(stdout);
			} while (rwait((struct timeval *)NULL) == -1);
			scr_msg(msg, 0);
			scr_msg(key_msg, 1);
			place(curshape, pos, 0);
			continue;
		}
		if (c == keys[0]) {
			/* move left */
			if (fits_in(curshape, pos - 1))
				pos--;
			continue;
		}
		if (c == keys[1]) {
			/* turn */
			const struct shape *new = &shapes[
			    classic? curshape->rotc : curshape->rot];

			if (fits_in(new, pos))
				curshape = new;
			continue;
		}
		if (c == keys[2]) {
			/* move right */
			if (fits_in(curshape, pos + 1))
				pos++;
			continue;
		}
		if (c == keys[3]) {
			/* move to bottom */
			while (fits_in(curshape, pos + B_COLS)) {
				pos += B_COLS;
				score++;
			}
			continue;
		}
		if (c == '\f') {
			scr_clear();
			scr_msg(key_msg, 1);
		}
	}

	scr_clear();
	scr_end();

	if (showpreview == 0)
		(void)printf("Your score:  %d point%s  x  level %d  =  %d\n",
		    score, score == 1 ? "" : "s", level, score * level);
	else {
		(void)printf("Your score:  %d point%s x level %d x preview penalty %0.3f = %d\n",
		    score, score == 1 ? "" : "s", level, (double)PRE_PENALTY,
		    (int)(score * level * PRE_PENALTY));
		score = score * PRE_PENALTY;
	}
	savescore(level);

	printf("\nHit RETURN to see high scores, ^C to skip.\n");

	while ((i = getchar()) != '\n')
		if (i == EOF)
			break;

	showscores(level);

	return 0;
}

void
onintr(int signo)
{
	scr_clear();		/* XXX signal race */
	scr_end();		/* XXX signal race */
	_exit(0);
}

void
usage(void)
{
	(void)fprintf(stderr, "usage: %s [-cps] [-k keys] "
	    "[-l level]\n", getprogname());
	exit(1);
}
@


1.30
log
@- General changes:
- Remove -? from getopt(3) options, but still keep (or add) -h where applicable
- Replace hardcoded program strings by getprogname(3)

- Specific changes:
- atc(6): this used -? and -u for usage(), remove both from game and manpage
- bcd(6): use __progname instead of getprogname(3), no need to include stdlib.h
- hunt(6): replace fputs(3) by fprintf(3)

OK tb@@ after his suggestions
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.29 2016/01/07 16:00:33 tb Exp $	*/
d108 1
@


1.29
log
@Some basic code maintenance in games/

- in main() replace exit with return
- drop some /* NOTREACHED */ lint comments along the way.
- make more use of standard CFLAGS, esp. -Wimplicit-function-declaration
- add and sort some headers when needed
- add straightforward pledges to some programs used at compile time

discussed with and ok mestre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.28 2016/01/04 17:33:24 mestre Exp $	*/
d359 2
a360 1
	(void)fprintf(stderr, "usage: tetris [-cps] [-k keys] [-l level]\n");
@


1.28
log
@More cleanup and sorting on header section

OK tb@@ and he also pointed out that for consistency with rest of the tree we
should include termios.h instead of sys/ttydefaults.h, where applicable
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.27 2015/12/25 20:59:09 mestre Exp $	*/
d188 1
a188 1
			exit(0);
d345 1
a345 1
	exit(0);
@


1.27
log
@Declare usage() functions as __dead void, if they don't return, on games section.

Found another one in arithmetic(6) which also didn't return, and removed a function from number(6) which is not used anymore.

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.26 2015/11/20 07:40:23 tb Exp $	*/
a41 3
#include <sys/time.h>
#include <sys/types.h>

d64 5
a68 5
static void	elide(void);
static void	setup_board(void);
const struct shape *randshape(void);
void	onintr(int);
__dead void	usage(void);
@


1.26
log
@pledge "stdio rpath wpath cpath tty"

"stdio rpath tty" for game play
"rpath wpath cpath" for maintaining highscores in $USER

ok deraadt@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.25 2014/11/16 04:49:49 guenther Exp $	*/
d71 1
a71 1
void	usage(void);
@


1.25
log
@Eliminate pointless use of <sys/param.h>, <sys/file.h>, <sys/sockio.h>,
    and <sys/ttydefaults.h>
Replace MAXPATHLEN with PATH_MAX and MAXLOGNAME with LOGIN_NAME_MAX
Pull in <limits.h> where needed
Prefer sizeof(var) over MAXFOO or FOO_MAX

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.24 2013/08/29 20:22:20 naddy Exp $	*/
a63 1
gid_t	gid, egid;
d159 3
a162 4

	gid = getgid();
	egid = getegid();
	setegid(gid);
@


1.24
log
@replace srandomdev()+random() with the arc4random*() family
tweaks and ok millert@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.23 2009/10/28 00:25:38 deraadt Exp $	*/
a41 1
#include <sys/param.h>
d46 1
@


1.23
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.
spotted by schwarze
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.22 2008/03/17 09:17:56 sobrado Exp $	*/
d142 2
a143 2
	tmp = &shapes[random() % 7];
	j = random() % 4;
a227 1
	srandomdev();
@


1.22
log
@synchronization between usage and synopsis; add some missing "usage:"'s

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.21 2006/04/20 03:24:12 ray Exp $	*/
a36 6

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1992, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */
@


1.21
log
@Clean up getopt stuff and use strtonum instead of atoi.

OK jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.20 2004/07/10 07:26:24 deraadt Exp $	*/
d371 1
a371 1
	(void)fprintf(stderr, "usage: tetris [-ps] [-k keys] [-l level]\n");
@


1.20
log
@more ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.19 2004/01/10 01:23:20 tedu Exp $	*/
d163 1
d173 1
a173 1
	while ((ch = getopt(argc, argv, "chk:l:ps")) != -1)
d188 3
a190 2
			level = atoi(optarg);
			if (level < MINLEVEL || level > MAXLEVEL)
a199 2
		case '?':
		case 'h':
@


1.19
log
@bonus points for completing rows, like most variants.
ok deraadt mcbride millert nick otto pjanzen
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.18 2003/06/03 03:01:41 millert Exp $	*/
d86 1
a86 1
setup_board()
d100 1
a100 1
elide()
d143 1
a143 1
randshape()
d157 1
a157 3
main(argc, argv)
	int argc;
	char *argv[];
d361 1
a361 2
onintr(signo)
	int signo;
d369 1
a369 1
usage()
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.17 2003/04/08 18:09:28 deraadt Exp $	*/
d102 1
d112 1
d123 16
@


1.17
log
@string cleaning; ok pjanzen
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.16 2003/04/06 18:50:38 deraadt Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.16
log
@2451 lines of strdup/sprintf/strcpy whacking.  mostly ok'd by pjanzen
already, but he may have later changes to make still.
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.15 2002/12/06 21:48:51 millert Exp $	*/
d206 1
a206 1
			strcpy(key_write[i], "<space>");
@


1.15
log
@Replace things like srandom(time(NULL)) with srandomdev(3).  random(3)
good enough for games but we should at least use a decent seed.
pjanzen@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.14 2002/07/26 21:33:28 mickey Exp $	*/
d213 1
a213 1
	sprintf(key_msg,
@


1.14
log
@give it some healthy dosage of vitamin const
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.13 2002/07/26 20:19:22 mickey Exp $	*/
d222 1
a222 1
	srandom(getpid());
@


1.13
log
@add classic mode, closer to the way tetris felt a couple decades ago; pjanzen@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.12 2002/05/31 04:21:30 pjanzen Exp $	*/
d43 1
a43 1
static char copyright[] =
d70 2
a71 2
struct shape *curshape;
struct shape *nextshape;
d80 1
a80 1
struct shape	*randshape(void);
d128 1
a128 1
struct shape *
d131 1
a131 1
	struct shape *tmp;
d296 1
a296 1
			struct shape *new = &shapes[
@


1.12
log
@de-register
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.11 2002/02/16 21:27:11 millert Exp $	*/
d76 1
a76 1
int	showpreview;
d137 1
a137 1
		tmp = &shapes[tmp->rot];
d159 2
a160 2
	showpreview = 0;
	while ((ch = getopt(argc, argv, "hk:l:ps")) != -1)
d162 8
d296 2
a297 1
			struct shape *new = &shapes[curshape->rot];
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.10 2001/11/19 21:29:06 deraadt Exp $	*/
d92 2
a93 2
	register int i;
	register cell *p;
d106 2
a107 2
	register int i, j, base;
	register cell *p;
d147 3
a149 3
	register int pos, c;
	register char *keys;
	register int level = 2;
@


1.10
log
@mark signal race, fix half of it
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.9 2001/02/04 14:23:28 pjanzen Exp $	*/
d78 5
a82 5
static void	elide __P((void));
static void	setup_board __P((void));
struct shape	*randshape __P((void));
void	onintr __P((int));
void	usage __P((void));
@


1.9
log
@Long usernames.  This really messes up the scoreboard printout, so change
it from two columns to one column with leaders printed every third score
to guide the eye across the vast whitespace that's left with the
traditional 8-char usernames.
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.8 2000/01/03 23:22:45 pjanzen Exp $	*/
d343 3
a345 3
	scr_clear();
	scr_end();
	exit(0);
@


1.8
log
@extern rather than linker commons; jsm@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.7 1999/03/22 07:38:28 pjanzen Exp $	*/
d52 1
@


1.7
log
@Many fixes, most either from or based on NetBSD changes:
	get rid of unused function
	improve output format
	allow previewing of next piece
	randomize initial rotation angle of falling blocks.
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.6 1999/03/22 05:20:03 pjanzen Exp $	*/
d66 10
@


1.6
log
@cosmetic changes from soren@@t.dk
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.5 1999/02/12 04:08:55 deraadt Exp $	*/
d69 1
d117 14
a136 1
	register struct shape *curshape;
d148 2
a149 1
	while ((ch = getopt(argc, argv, "hk:l:s")) != -1)
d161 3
d207 1
d238 2
a239 1
			curshape = randshape();
d297 1
a297 1
		if (c == '\f')
d299 2
d306 9
a314 2
	(void)printf("Your score:  %d point%s  x  level %d  =  %d\n",
	    score, score == 1 ? "" : "s", level, score * level);
d340 1
a340 1
	(void)fprintf(stderr, "usage: tetris [-s] [-k keys] [-l level]\n");
@


1.5
log
@kill old mips compiler hack; simonb@@netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.c,v 1.4 1998/09/24 06:45:08 pjanzen Exp $	*/
d166 1
a166 1
				errx(1, "Duplicate command keys specified.");
d311 1
a311 1
	(void)fprintf(stderr, "usage: tetris [-s] [-l level] [-k keys]\n");
@


1.4
log
@NetBSD changes and a few obvious fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a84 1
#ifndef mips
a85 3
#else /* work around compiler bug */
		*p++ = i <= (2 * B_COLS) || (i % B_COLS) < 2 ? 1 : 0;
#endif
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
d53 1
d55 1
d67 4
a70 2
void onintr __P((int));
void usage __P((void));
d107 1
a107 1
				bzero(&board[base], B_COLS - 2);
d138 1
a138 1
	while ((ch = getopt(argc, argv, "k:l:s")) != -1)
d146 2
a147 3
			if (level < MINLEVEL || level > MAXLEVEL) {
				(void)fprintf(stderr,
				    "tetris: level must be from %d to %d",
a148 2
				exit(1);
			}
d154 1
d169 2
a170 6
			if (keys[i] == keys[j]) {
				(void)fprintf(stderr,
				    "%s: Duplicate command keys specified.\n",
				    argv[0]);
				exit (1);
			}
d315 1
a315 1
	(void)fprintf(stderr, "usage: tetris [-s] [-l level] [-keys]\n");
@


1.2
log
@Relinguish SGID games, restore it only when opening the score file
@
text
@d133 1
a133 1
	while ((ch = getopt(argc, argv, "k:l:s")) != EOF)
@


1.1
log
@Initial revision
@
text
@d129 4
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
