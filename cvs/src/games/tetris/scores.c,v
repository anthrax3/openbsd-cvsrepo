head	1.22;
access;
symbols
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.21.0.2
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.36
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.34
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.30
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.28
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.26
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.24
	OPENBSD_5_0:1.11.0.22
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.20
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.18
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.14
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.16
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.12
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.10.0.8
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.6
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2016.08.27.02.00.10;	author guenther;	state Exp;
branches;
next	1.21;
commitid	usv2ULh2hPPt9BPj;

1.21
date	2016.06.10.15.37.09;	author tb;	state Exp;
branches;
next	1.20;
commitid	q0wrfUf9xJqtdEn7;

1.20
date	2016.03.16.15.00.35;	author mestre;	state Exp;
branches;
next	1.19;
commitid	idQfhcm2r53iTZ8v;

1.19
date	2016.01.04.17.33.24;	author mestre;	state Exp;
branches;
next	1.18;
commitid	b21xvsfCGMtCOVrz;

1.18
date	2016.01.03.14.38.17;	author mestre;	state Exp;
branches;
next	1.17;
commitid	Ptgw9rNvmSHNRfGy;

1.17
date	2015.12.27.01.24.27;	author chl;	state Exp;
branches;
next	1.16;
commitid	HDevFqURXiPlUL1q;

1.16
date	2015.11.29.14.31.02;	author tb;	state Exp;
branches;
next	1.15;
commitid	JfpmcU0Wot8dMCT8;

1.15
date	2015.11.26.14.43.18;	author tb;	state Exp;
branches;
next	1.14;
commitid	iewCE8U4mPImgeWk;

1.14
date	2015.11.26.13.24.30;	author tb;	state Exp;
branches;
next	1.13;
commitid	6Q1hxUPi0iboSRHz;

1.13
date	2015.11.17.15.27.24;	author tedu;	state Exp;
branches;
next	1.12;
commitid	thfwMdotNQbqdmdB;

1.12
date	2014.11.16.04.49.49;	author guenther;	state Exp;
branches;
next	1.11;
commitid	8XNajyb9IqHkZEKg;

1.11
date	2006.04.20.03.25.36;	author ray;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.10.07.26.24;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.03.03.01.41;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.06.18.50.38;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.31.04.21.30;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.11;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.04.14.23.27;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.21.05.33.19;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	98.09.24.06.45.07;	author pjanzen;	state Exp;
branches;
next	1.2;

1.2
date	96.12.21.21.43.54;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.23;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.23;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Pull in <time.h> for time() and perhaps other functions

ok deraadt@@
@
text
@/*	$OpenBSD: scores.c,v 1.21 2016/06/10 15:37:09 tb Exp $	*/
/*	$NetBSD: scores.c,v 1.2 1995/04/22 07:42:38 cgd Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek and Darren F. Provine.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)scores.c	8.1 (Berkeley) 5/31/93
 */

/*
 * Score code for Tetris, by Darren Provine (kilroy@@gboro.glassboro.edu)
 * modified 22 January 1992, to limit the number of entries any one
 * person has.
 *
 * Major whacks since then.
 */
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <term.h>
#include <time.h>
#include <unistd.h>

#include "scores.h"
#include "screen.h"
#include "tetris.h"

/*
 * Within this code, we can hang onto one extra "high score", leaving
 * room for our current score (whether or not it is high).
 *
 * We also sometimes keep tabs on the "highest" score on each level.
 * As long as the scores are kept sorted, this is simply the first one at
 * that level.
 */
#define NUMSPOTS (MAXHISCORES + 1)
#define	NLEVELS (MAXLEVEL + 1)

static time_t now;
static int nscores;
static int gotscores;
static struct highscore scores[NUMSPOTS];

static int checkscores(struct highscore *, int);
static int cmpscores(const void *, const void *);
static void getscores(FILE **);
static void printem(int, int, struct highscore *, int, const char *);
static char *thisuser(void);

/*
 * Read the score file.  Can be called from savescore (before showscores)
 * or showscores (if savescore will not be called).  If the given pointer
 * is not NULL, sets *fpp to an open file pointer that corresponds to a
 * read/write score file that is locked with LOCK_EX.  Otherwise, the
 * file is locked with LOCK_SH for the read and closed before return.
 *
 * Note, we assume closing the stdio file releases the lock.
 */
static void
getscores(FILE **fpp)
{
	int sd, mint, i, ret;
	char *mstr, *human, *home;
	char scorepath[PATH_MAX];
	FILE *sf;

	if (fpp != NULL) {
		mint = O_RDWR | O_CREAT;
		mstr = "r+";
		human = "read/write";
		*fpp = NULL;
	} else {
		mint = O_RDONLY;
		mstr = "r";
		human = "reading";
	}

	home = getenv("HOME");
	if (home == NULL || *home == '\0')
		err(1, "getenv");

	ret = snprintf(scorepath, sizeof(scorepath), "%s/%s", home, ".tetris.scores");
	if (ret < 0 || ret >= PATH_MAX)
		errc(1, ENAMETOOLONG, "%s/%s", home, ".tetris.scores");

	sd = open(scorepath, mint, 0666);
	if (sd < 0) {
		if (fpp == NULL) {
			nscores = 0;
			return;
		}
		err(1, "cannot open %s for %s", scorepath, human);
	}
	if ((sf = fdopen(sd, mstr)) == NULL)
		err(1, "cannot fdopen %s for %s", scorepath, human);

	nscores = fread(scores, sizeof(scores[0]), MAXHISCORES, sf);
	if (ferror(sf))
		err(1, "error reading %s", scorepath);
	for (i = 0; i < nscores; i++)
		if (scores[i].hs_level < MINLEVEL ||
		    scores[i].hs_level > MAXLEVEL)
			errx(1, "scorefile %s corrupt", scorepath);

	if (fpp)
		*fpp = sf;
	else
		(void)fclose(sf);
}

void
savescore(int level)
{
	struct highscore *sp;
	int i;
	int change;
	FILE *sf;
	const char *me;

	getscores(&sf);
	gotscores = 1;
	(void)time(&now);

	/*
	 * Allow at most one score per person per level -- see if we
	 * can replace an existing score, or (easiest) do nothing.
	 * Otherwise add new score at end (there is always room).
	 */
	change = 0;
	me = thisuser();
	for (i = 0, sp = &scores[0]; i < nscores; i++, sp++) {
		if (sp->hs_level != level || strcmp(sp->hs_name, me) != 0)
			continue;
		if (score > sp->hs_score) {
			(void)printf("%s bettered %s %d score of %d!\n",
			    "\nYou", "your old level", level,
			    sp->hs_score * sp->hs_level);
			sp->hs_score = score;	/* new score */
			sp->hs_time = now;	/* and time */
			change = 1;
		} else if (score == sp->hs_score) {
			(void)printf("%s tied %s %d high score.\n",
			    "\nYou", "your old level", level);
			sp->hs_time = now;	/* renew it */
			change = 1;		/* gotta rewrite, sigh */
		} /* else new score < old score: do nothing */
		break;
	}
	if (i >= nscores) {
		strlcpy(sp->hs_name, me, sizeof sp->hs_name);
		sp->hs_level = level;
		sp->hs_score = score;
		sp->hs_time = now;
		nscores++;
		change = 1;
	}

	if (change) {
		/*
		 * Sort & clean the scores, then rewrite.
		 */
		nscores = checkscores(scores, nscores);
		if (fseek(sf, 0L, SEEK_SET) == -1)
			err(1, "fseek");
		if (fwrite(scores, sizeof(*sp), nscores, sf) != nscores ||
		    fflush(sf) == EOF)
			warnx("error writing scorefile: %s\n\t-- %s",
			    strerror(errno),
			    "high scores may be damaged");
	}
	(void)fclose(sf);	/* releases lock */
}

/*
 * Get login name, or if that fails, get something suitable.
 * The result is always trimmed to fit in a score.
 */
static char *
thisuser(void)
{
	const char *p;
	static char u[sizeof(scores[0].hs_name)];

	if (u[0])
		return (u);
	p = getenv("LOGNAME");
	if (p == NULL || *p == '\0')
		p = getenv("USER");
	if (p == NULL || *p == '\0')
		p = getlogin();
	if (p == NULL || *p == '\0')
		p = "  ???";
	strlcpy(u, p, sizeof(u));
	return (u);
}

/*
 * Score comparison function for qsort.
 *
 * If two scores are equal, the person who had the score first is
 * listed first in the highscore file.
 */
static int
cmpscores(const void *x, const void *y)
{
	const struct highscore *a, *b;
	long l;

	a = x;
	b = y;
	l = (long)b->hs_level * b->hs_score - (long)a->hs_level * a->hs_score;
	if (l < 0)
		return (-1);
	if (l > 0)
		return (1);
	if (a->hs_time < b->hs_time)
		return (-1);
	if (a->hs_time > b->hs_time)
		return (1);
	return (0);
}

/*
 * If we've added a score to the file, we need to check the file and ensure
 * that this player has only a few entries.  The number of entries is
 * controlled by MAXSCORES, and is to ensure that the highscore file is not
 * monopolised by just a few people.  People who no longer have accounts are
 * only allowed the highest score.  Scores older than EXPIRATION seconds are
 * removed, unless they are someone's personal best.
 * Caveat:  the highest score on each level is always kept.
 */
static int
checkscores(struct highscore *hs, int num)
{
	struct highscore *sp;
	int i, j, k, nrnames;
	int levelfound[NLEVELS];
	struct peruser {
		char *name;
		int times;
	} count[NUMSPOTS];
	struct peruser *pu;

	/*
	 * Sort so that highest totals come first.
	 *
	 * levelfound[i] becomes set when the first high score for that
	 * level is encountered.  By definition this is the highest score.
	 */
	qsort((void *)hs, nscores, sizeof(*hs), cmpscores);
	for (i = MINLEVEL; i < NLEVELS; i++)
		levelfound[i] = 0;
	nrnames = 0;
	for (i = 0, sp = hs; i < num;) {
		/*
		 * This is O(n^2), but do you think we care?
		 */
		for (j = 0, pu = count; j < nrnames; j++, pu++)
			if (strcmp(sp->hs_name, pu->name) == 0)
				break;
		if (j == nrnames) {
			/*
			 * Add new user, set per-user count to 1.
			 */
			pu->name = sp->hs_name;
			pu->times = 1;
			nrnames++;
		} else {
			/*
			 * Two ways to keep this score:
			 * - Not too many (per user), still has acct, &
			 *	score not dated; or
			 * - High score on this level.
			 */
			if ((pu->times < MAXSCORES &&
			     sp->hs_time + EXPIRATION >= now) ||
			    levelfound[sp->hs_level] == 0)
				pu->times++;
			else {
				/*
				 * Delete this score, do not count it,
				 * do not pass go, do not collect $200.
				 */
				num--;
				for (k = i; k < num; k++)
					hs[k] = hs[k + 1];
				continue;
			}
		}
		levelfound[sp->hs_level] = 1;
		i++, sp++;
	}
	return (num > MAXHISCORES ? MAXHISCORES : num);
}

/*
 * Show current scores.  This must be called after savescore, if
 * savescore is called at all, for two reasons:
 * - Showscores munches the time field.
 * - Even if that were not the case, a new score must be recorded
 *   before it can be shown anyway.
 */
void
showscores(int level)
{
	struct highscore *sp;
	int i, n, c;
	const char *me;
	int levelfound[NLEVELS];

	if (!gotscores)
		getscores((FILE **)NULL);
	(void)printf("\n\t\t    Tetris High Scores\n");

	/*
	 * If level == 0, the person has not played a game but just asked for
	 * the high scores; we do not need to check for printing in highlight
	 * mode.  If SOstr is null, we can't do highlighting anyway.
	 */
	me = level && SOstr ? thisuser() : NULL;

	/*
	 * Set times to 0 except for high score on each level.
	 */
	for (i = MINLEVEL; i < NLEVELS; i++)
		levelfound[i] = 0;
	for (i = 0, sp = scores; i < nscores; i++, sp++) {
		if (levelfound[sp->hs_level])
			sp->hs_time = 0;
		else {
			sp->hs_time = 1;
			levelfound[sp->hs_level] = 1;
		}
	}

	/*
	 * Page each screenful of scores.
	 */
	for (i = 0, sp = scores; i < nscores; sp += n) {
		n = 20;
		if (i + n > nscores)
			n = nscores - i;
		printem(level, i + 1, sp, n, me);
		if ((i += n) < nscores) {
			(void)printf("\nHit RETURN to continue.");
			(void)fflush(stdout);
			while ((c = getchar()) != '\n')
				if (c == EOF)
					break;
			(void)printf("\n");
		}
	}

	if (nscores == 0)
		printf("\t\t\t      - none to date.\n");
}

static void
printem(int level, int offset, struct highscore *hs, int n, const char *me)
{
	struct highscore *sp;
	int row, highlight, i;
	char buf[100];
#define	TITLE "Rank  Score   Name                          (points/level)"
#define	TITL2 "=========================================================="

	printf("%s\n%s\n", TITLE, TITL2);

	highlight = 0;

	for (row = 0; row < n; row++) {
		sp = &hs[row];
		(void)snprintf(buf, sizeof(buf),
		    "%3d%c %6d  %-31s (%6d on %d)\n",
		    row + offset, sp->hs_time ? '*' : ' ',
		    sp->hs_score * sp->hs_level,
		    sp->hs_name, sp->hs_score, sp->hs_level);
		/* Print leaders every three lines */
		if ((row + 1) % 3 == 0) {
			for (i = 0; i < sizeof(buf); i++)
				if (buf[i] == ' ')
					buf[i] = '_';
		}
		/*
		 * Highlight if appropriate.  This works because
		 * we only get one score per level.
		 */
		if (me != NULL &&
		    sp->hs_level == level &&
		    sp->hs_score == score &&
		    strcmp(sp->hs_name, me) == 0) {
			putpad(SOstr);
			highlight = 1;
		}
		(void)printf("%s", buf);
		if (highlight) {
			putpad(SEstr);
			highlight = 0;
		}
	}
}
@


1.21
log
@Clean up gcc -Wshadow warnings: 'numnames' is public in <term.h>.
'i' shadows the local loop indexing variable of scr_update(), so
no need to rename it. No binary change on amd64.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: scores.c,v 1.20 2016/03/16 15:00:35 mestre Exp $	*/
d53 1
@


1.20
log
@Prefer fseek(3) over rewind(3) since the latter although it also calls fseek
then additionally it calls clearerr(3) deliberately but we want to catch any
error that may happen and this way we couldn't catch it

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scores.c,v 1.19 2016/01/04 17:33:24 mestre Exp $	*/
d267 1
a267 1
	int i, j, k, numnames;
d284 1
a284 1
	numnames = 0;
d289 1
a289 1
		for (j = 0, pu = count; j < numnames; j++, pu++)
d292 1
a292 1
		if (j == numnames) {
d298 1
a298 1
			numnames++;
@


1.19
log
@More cleanup and sorting on header section

OK tb@@ and he also pointed out that for consistency with rest of the tree we
should include termios.h instead of sys/ttydefaults.h, where applicable
@
text
@d1 1
a1 1
/*	$OpenBSD: scores.c,v 1.18 2016/01/03 14:38:17 mestre Exp $	*/
d194 2
a195 1
		rewind(sf);
@


1.18
log
@About 13 years ago when the idiom srandom(time()), and sometimes
srandom(time()+getpid()), was changed by srandomdev(), but #include <time.h>
lived up until this day so remove it.

Additionally, earlier than that, 18 years ago, random(6) was one of the first
consumers of arc4random(3) family, and was pulling it from dev/rndvar.h but
these days we pull it from stdlib.h, which is already done, so while here
remove dev/rndvar.h also.

"seems comprehensive to me" deraadt@@ and OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scores.c,v 1.17 2015/12/27 01:24:27 chl Exp $	*/
a44 3
#include <sys/stat.h>
#include <sys/types.h>

@


1.17
log
@remove unused variable

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scores.c,v 1.16 2015/11/29 14:31:02 tb Exp $	*/
d45 1
a46 1
#include <sys/stat.h>
d48 1
a49 1
#include <err.h>
a54 1
#include <time.h>
d58 1
a59 1
#include "scores.h"
@


1.16
log
@Prefer $LOGNAME over $USER, since the latter is deprecated,
see environ(7).  Pointed out by millert@@.  Fall back to getlogin(2)
before defaulting to ???.

looks good to deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scores.c,v 1.15 2015/11/26 14:43:18 tb Exp $	*/
d97 1
a97 1
	int sd, mint, mask, i, ret;
@


1.15
log
@Fix copy-paste error in scorefile name

From Ricardo Mestre
@
text
@d1 1
a1 1
/*	$OpenBSD: scores.c,v 1.14 2015/11/26 13:24:30 tb Exp $	*/
d220 6
a225 2
	p = getlogin();
	if (p == NULL || *p == '\0') {
a226 1
	}
@


1.14
log
@Add missing checks for getenv() and snprintf()

From Ricardo Mestre, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: scores.c,v 1.13 2015/11/17 15:27:24 tedu Exp $	*/
d119 1
a119 1
		errc(1, ENAMETOOLONG, "%s/%s", home, ".snake.scores");
@


1.13
log
@remove setgid flag.
in turn, move score files into user's home directory.
will let theo buehler continue with a smaller pledge set.
@
text
@d1 1
a1 1
/*	$OpenBSD: scores.c,v 1.12 2014/11/16 04:49:49 guenther Exp $	*/
d97 2
a98 2
	int sd, mint, mask, i;
	char *mstr, *human;
d112 9
a120 3
	if (!getenv("HOME"))
		return;
	snprintf(scorepath, sizeof(scorepath), "%s/%s", getenv("HOME"), ".tetris.scores");
@


1.12
log
@Eliminate pointless use of <sys/param.h>, <sys/file.h>, <sys/sockio.h>,
    and <sys/ttydefaults.h>
Replace MAXPATHLEN with PATH_MAX and MAXLOGNAME with LOGIN_NAME_MAX
Pull in <limits.h> where needed
Prefer sizeof(var) over MAXFOO or FOO_MAX

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scores.c,v 1.11 2006/04/20 03:25:36 ray Exp $	*/
a51 1
#include <pwd.h>
a58 1
#include "pathnames.h"
d97 1
a97 1
	int sd, mint, lck, mask, i;
d99 1
d106 1
a106 1
		lck = LOCK_EX;
a110 1
		lck = LOCK_SH;
d112 4
a115 5
	setegid(egid);
	mask = umask(S_IWOTH);
	sd = open(_PATH_SCOREFILE, mint, 0666);
	(void)umask(mask);
	setegid(gid);
d121 1
a121 1
		err(1, "cannot open %s for %s", _PATH_SCOREFILE, human);
a122 1
	setegid(egid);
d124 1
a124 9
		err(1, "cannot fdopen %s for %s", _PATH_SCOREFILE, human);
	setegid(gid);

	/*
	 * Grab a lock.
	 */
	if (flock(sd, lck))
		warn("warning: score file %s cannot be locked",
		    _PATH_SCOREFILE);
d128 1
a128 1
		err(1, "error reading %s", _PATH_SCOREFILE);
d132 1
a132 1
			errx(1, "scorefile %s corrupt", _PATH_SCOREFILE);
d195 2
a196 2
			warnx("error writing %s: %s\n\t-- %s",
			    _PATH_SCOREFILE, strerror(errno),
a209 1
	struct passwd *pw;
d216 1
a216 5
		pw = getpwuid(getuid());
		if (pw != NULL)
			p = pw->pw_name;
		else
			p = "  ???";
a300 1
			     getpwnam(sp->hs_name) != NULL &&
@


1.11
log
@Replace magic numbers with sizeof(array).

OK jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scores.c,v 1.10 2004/07/10 07:26:24 deraadt Exp $	*/
d45 3
d51 1
a58 3
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/types.h>
@


1.10
log
@more ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: scores.c,v 1.9 2003/06/03 03:01:41 millert Exp $	*/
d415 1
a415 1
		(void)snprintf(buf, 100,
d422 1
a422 1
			for (i = 0; i < 100; i++)
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: scores.c,v 1.8 2003/04/06 18:50:38 deraadt Exp $	*/
d96 1
a96 2
getscores(fpp)
	FILE **fpp;
d152 1
a152 2
savescore(level)
	int level;
d218 1
a218 1
thisuser()
d245 1
a245 2
cmpscores(x, y)
	const void *x, *y;
d274 1
a274 3
checkscores(hs, num)
	struct highscore *hs;
	int num;
d346 1
a346 2
showscores(level)
	int level;
d401 1
a401 5
printem(level, offset, hs, n, me)
	int level, offset;
	struct highscore *hs;
	int n;
	const char *me;
@


1.8
log
@2451 lines of strdup/sprintf/strcpy whacking.  mostly ok'd by pjanzen
already, but he may have later changes to make still.
@
text
@d1 1
a1 1
/*	$OpenBSD: scores.c,v 1.7 2002/05/31 04:21:30 pjanzen Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@de-register
@
text
@d1 1
a1 1
/*	$OpenBSD: scores.c,v 1.6 2002/02/16 21:27:11 millert Exp $	*/
d196 1
a196 1
		strcpy(sp->hs_name, me);
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: scores.c,v 1.5 2001/02/04 14:23:27 pjanzen Exp $	*/
d160 2
a161 2
	register struct highscore *sp;
	register int i;
d254 2
a255 2
	register const struct highscore *a, *b;
	register long l;
d282 1
a282 1
	register struct highscore *hs;
d285 2
a286 2
	register struct highscore *sp;
	register int i, j, k, numnames;
d292 1
a292 1
	register struct peruser *pu;
d358 2
a359 2
	register struct highscore *sp;
	register int i, n, c;
@


1.5
log
@Long usernames.  This really messes up the scoreboard printout, so change
it from two columns to one column with leaders printed every third score
to guide the eye across the vast whitespace that's left with the
traditional 8-char usernames.
@
text
@d1 1
a1 1
/*	$OpenBSD: scores.c,v 1.4 2000/01/21 05:33:19 pjanzen Exp $	*/
d84 5
a88 5
static int checkscores __P((struct highscore *, int));
static int cmpscores __P((const void *, const void *));
static void getscores __P((FILE **));
static void printem __P((int, int, struct highscore *, int, const char *));
static char *thisuser __P((void));
@


1.4
log
@Improve score table formatting (partially from malcolm@@bits.bris.ac.uk
via jsm@@netbsd.org); remove a terminating \n from a warnx() (jsm@@netbsd)
and tidy a bit; check score file for corruption to avoid segfault.
@
text
@d1 1
a1 1
/*	$OpenBSD: scores.c,v 1.3 1998/09/24 06:45:07 pjanzen Exp $	*/
d59 1
d226 2
a227 3
	register const char *p;
	register struct passwd *pw;
	register size_t l;
d240 1
a240 5
	l = strlen(p);
	if (l >= sizeof(u))
		l = sizeof(u) - 1;
	memcpy(u, p, l);
	u[l] = '\0';
d365 1
a365 1
	(void)printf("\n\t\t\t    Tetris High Scores\n");
d392 1
a392 1
		n = 40;
d413 2
a414 2
	register struct highscore *hs;
	register int n;
d417 2
a418 2
	register struct highscore *sp;
	int nrows, row, col, item, i, highlight;
d420 2
a421 1
#define	TITLE "Rank  Score   Name      (points/level)"
d423 1
a423 5
	/*
	 * This makes a nice two-column sort with headers, but it's a bit
	 * convoluted...
	 */
	printf("%s  %s\n", TITLE, n > 1 ? TITLE : "");
a425 1
	nrows = (n + 1) / 2;
d427 28
a454 39
	for (row = 0; row < nrows; row++) {
		for (col = 0; col < 2; col++) {
			item = col * nrows + row;
			if (item >= n) {
				/*
				 * Can only occur on trailing columns.
				 */
				(void)putchar('\n');
				continue;
			}
			sp = &hs[item];
			(void)sprintf(buf,
			    "%3d%c %6d  %-11s (%6d on %d)",
			    item + offset, sp->hs_time ? '*' : ' ',
			    sp->hs_score * sp->hs_level,
			    sp->hs_name, sp->hs_score, sp->hs_level);
			/*
			 * Highlight if appropriate.  This works because
			 * we only get one score per level.
			 */
			if (me != NULL &&
			    sp->hs_level == level &&
			    sp->hs_score == score &&
			    strcmp(sp->hs_name, me) == 0) {
				putpad(SOstr);
				highlight = 1;
			}
			(void)printf("%s", buf);
			if (highlight) {
				putpad(SEstr);
				highlight = 0;
			}

			/* fill in spaces so column 1 lines up */
			if (col == 0)
				for (i = 40 - strlen(buf); --i >= 0;)
					(void)putchar(' ');
			else /* col == 1 */
				(void)putchar('\n');
@


1.3
log
@NetBSD changes and a few obvious fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d102 1
a102 1
	int sd, mint, lck, mask;
d144 4
d211 1
a211 1
			warnx("error writing %s: %s -- %s\n",
d409 3
d424 1
a424 1
#define	TITLE "Rank  Score   Name     (points/level)"
d430 1
a430 1
	printf("%s   %s\n", TITLE, n > 1 ? TITLE : "");
a444 1
			(void)printf(item + offset < 10 ? "  " : " ");
d447 1
a447 1
			    "%d%c %6d  %-11s (%d on %d)",
@


1.2
log
@Relinguish SGID games, restore it only when opening the score file
@
text
@d1 1
d50 1
d57 1
d60 1
a60 5

/*
 * XXX - need a <termcap.h>
 */
int	tputs __P((const char *, int, int (*)(int)));
d121 1
d127 1
a127 8
		(void)fprintf(stderr, "tetris: cannot open %s for %s: %s\n",
		    _PATH_SCOREFILE, human, strerror(errno));
		exit(1);
	}
	if ((sf = fdopen(sd, mstr)) == NULL) {
		(void)fprintf(stderr, "tetris: cannot fdopen %s for %s: %s\n",
		    _PATH_SCOREFILE, human, strerror(errno));
		exit(1);
d129 3
d138 2
a139 3
		(void)fprintf(stderr,
		    "tetris: warning: score file %s cannot be locked: %s\n",
		    _PATH_SCOREFILE, strerror(errno));
d142 2
a143 5
	if (ferror(sf)) {
		(void)fprintf(stderr, "tetris: error reading %s: %s\n",
		    _PATH_SCOREFILE, strerror(errno));
		exit(1);
	}
d207 1
a207 2
			(void)fprintf(stderr,
			    "tetris: error writing %s: %s -- %s\n",
d239 1
a239 1
	bcopy(p, u, l);
@


1.1
log
@Initial revision
@
text
@d56 1
d103 1
a103 1
	int sd, mint, lck;
d118 2
d121 1
d136 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
