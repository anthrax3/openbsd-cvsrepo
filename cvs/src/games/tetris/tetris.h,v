head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.30
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.22
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.26
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.24
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.20
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.18
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.16
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.14
	OPENBSD_5_0:1.10.0.12
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.10
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.8
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.4
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.9.0.22
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.20
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.18
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.16
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.14
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.8
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.11.20.07.40.23;	author tb;	state Exp;
branches;
next	1.10;
commitid	axu8igWxJtuLDVUq;

1.10
date	2008.08.10.12.23.25;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.03.03.01.41;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.26.21.33.28;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.26.20.19.22;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.12;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.03.23.22.45;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	99.03.22.07.38.30;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	98.09.24.06.45.08;	author pjanzen;	state Exp;
branches;
next	1.2;

1.2
date	96.12.21.21.43.56;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.23;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.23;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.11
log
@pledge "stdio rpath wpath cpath tty"

"stdio rpath tty" for game play
"rpath wpath cpath" for maintaining highscores in $USER

ok deraadt@@ sthen@@
@
text
@/*	$OpenBSD: tetris.h,v 1.10 2008/08/10 12:23:25 krw Exp $	*/
/*	$NetBSD: tetris.h,v 1.2 1995/04/22 07:42:48 cgd Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek and Darren F. Provine.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)tetris.h	8.1 (Berkeley) 5/31/93
 */

/*
 * Definitions for Tetris.
 */

/*
 * The display (`board') is composed of 23 rows of 12 columns of characters
 * (numbered 0..22 and 0..11), stored in a single array for convenience.
 * Columns 1 to 10 of rows 1 to 20 are the actual playing area, where
 * shapes appear.  Columns 0 and 11 are always occupied, as are all
 * columns of rows 21 and 22.  Rows 0 and 22 exist as boundary areas
 * so that regions `outside' the visible area can be examined without
 * worrying about addressing problems.
 */

	/* the board */
#define	B_COLS	12
#define	B_ROWS	23
#define	B_SIZE	(B_ROWS * B_COLS)

typedef unsigned char cell;
extern cell	board[B_SIZE];	/* 1 => occupied, 0 => empty */

	/* the displayed area (rows) */
#define	D_FIRST	1
#define	D_LAST	22

	/* the active area (rows) */
#define	A_FIRST	1
#define	A_LAST	21

/*
 * Minimum display size.
 */
#define	MINROWS	23
#define	MINCOLS	40

extern int	Rows, Cols;	/* current screen size */

/*
 * Translations from board coordinates to display coordinates.
 * As with board coordinates, display coordinates are zero origin.
 */
#define	RTOD(x)	((x) - 1)
#define	CTOD(x)	((x) * 2 + (((Cols - 2 * B_COLS) >> 1) - 1))

/*
 * A `shape' is the fundamental thing that makes up the game.  There
 * are 7 basic shapes, each consisting of four `blots':
 *
 *	X.X	  X.X		X.X
 *	  X.X	X.X	X.X.X	X.X	X.X.X	X.X.X	X.X.X.X
 *			  X		X	    X
 *
 *	  0	  1	  2	  3	  4	  5	  6
 *
 * Except for 3 and 6, the center of each shape is one of the blots.
 * This blot is designated (0,0).  The other three blots can then be
 * described as offsets from the center.  Shape 3 is the same under
 * rotation, so its center is effectively irrelevant; it has been chosen
 * so that it `sticks out' upward and leftward.  Except for shape 6,
 * all the blots are contained in a box going from (-1,-1) to (+1,+1);
 * shape 6's center `wobbles' as it rotates, so that while it `sticks out'
 * rightward, its rotation---a vertical line---`sticks out' downward.
 * The containment box has to include the offset (2,0), making the overall
 * containment box range from offset (-1,-1) to (+2,+1).  (This is why
 * there is only one row above, but two rows below, the display area.)
 *
 * The game works by choosing one of these shapes at random and putting
 * its center at the middle of the first display row (row 1, column 5).
 * The shape is moved steadily downward until it collides with something:
 * either  another shape, or the bottom of the board.  When the shape can
 * no longer be moved downwards, it is merged into the current board.
 * At this time, any completely filled rows are elided, and blots above
 * these rows move down to make more room.  A new random shape is again
 * introduced at the top of the board, and the whole process repeats.
 * The game ends when the new shape will not fit at (1,5).
 *
 * While the shapes are falling, the user can rotate them counterclockwise
 * 90 degrees (in addition to moving them left or right), provided that the
 * rotation puts the blots in empty spaces.  The table of shapes is set up
 * so that each shape contains the index of the new shape obtained by
 * rotating the current shape.  Due to symmetry, each shape has exactly
 * 1, 2, or 4 rotations total; the first 7 entries in the table represent
 * the primary shapes, and the remaining 12 represent their various
 * rotated forms.
 */
struct shape {
	int	rot;	/* index of rotated version of this shape */
	int	rotc;	/* -- " -- in classic version  */
	int	off[3];	/* offsets to other blots if center is at (0,0) */
};

extern const struct shape shapes[];

extern const struct shape *curshape;
extern const struct shape *nextshape;

/*
 * Shapes fall at a rate faster than once per second.
 *
 * The initial rate is determined by dividing 1 million microseconds
 * by the game `level'.  (This is at most 1 million, or one second.)
 * Each time the fall-rate is used, it is decreased a little bit,
 * depending on its current value, via the `faster' macro below.
 * The value eventually reaches a limit, and things stop going faster,
 * but by then the game is utterly impossible.
 */
extern long	fallrate;	/* less than 1 million; smaller => faster */
#define	faster() (fallrate -= fallrate / 3000)

/*
 * Game level must be between 1 and 9.  This controls the initial fall rate
 * and affects scoring.
 */
#define	MINLEVEL	1
#define	MAXLEVEL	9

/*
 * Scoring is as follows:
 *
 * When the shape comes to rest, and is integrated into the board,
 * we score one point.  If the shape is high up (at a low-numbered row),
 * and the user hits the space bar, the shape plummets all the way down,
 * and we score a point for each row it falls (plus one more as soon as
 * we find that it is at rest and integrate it---until then, it can
 * still be moved or rotated).
 *
 * If previewing has been turned on, the score is multiplied by PRE_PENALTY.
 */
#define PRE_PENALTY 0.75

extern int	score;		/* the obvious thing */

extern char	key_msg[100];
extern int	showpreview;
extern int	classic;

int	fits_in(const struct shape *, int);
void	place(const struct shape *, int, int);
void	stop(char *);
@


1.10
log
@'coordiates' -> 'coordinates' from Dawe via tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.h,v 1.9 2003/06/03 03:01:41 millert Exp $	*/
a169 1
extern gid_t	gid, egid;
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.h,v 1.8 2002/07/26 21:33:28 mickey Exp $	*/
d78 1
a78 1
 * As with board coordinates, display coordiates are zero origin.
@


1.8
log
@give it some healthy dosage of vitamin const
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.h,v 1.7 2002/07/26 20:19:22 mickey Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@add classic mode, closer to the way tetris felt a couple decades ago; pjanzen@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.h,v 1.6 2002/02/16 21:27:12 millert Exp $	*/
d134 1
a134 1
extern struct shape shapes[];
d136 2
a137 2
extern struct shape *curshape;
extern struct shape *nextshape;
d180 2
a181 2
int	fits_in(struct shape *, int);
void	place(struct shape *, int, int);
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.h,v 1.5 2000/01/03 23:22:45 pjanzen Exp $	*/
d130 1
d178 1
@


1.5
log
@extern rather than linker commons; jsm@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.h,v 1.4 1999/03/22 07:38:30 pjanzen Exp $	*/
d178 3
a180 3
int	fits_in __P((struct shape *, int));
void	place __P((struct shape *, int, int));
void	stop __P((char *));
@


1.4
log
@Many fixes, most either from or based on NetBSD changes:
	get rid of unused function
	improve output format
	allow previewing of next piece
	randomize initial rotation angle of falling blocks.
@
text
@d1 1
a1 1
/*	$OpenBSD: tetris.h,v 1.3 1998/09/24 06:45:08 pjanzen Exp $	*/
d62 1
a62 1
cell	board[B_SIZE];		/* 1 => occupied, 0 => empty */
d78 1
a78 1
int	Rows, Cols;		/* current screen size */
d135 2
a136 2
struct shape *curshape;
struct shape *nextshape;
d148 1
a148 1
long	fallrate;		/* less than 1 million; smaller => faster */
d172 2
a173 2
int	score;			/* the obvious thing */
gid_t	gid, egid;
d175 2
a176 2
char	key_msg[100];
int	showpreview;
@


1.3
log
@NetBSD changes and a few obvious fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d134 3
a136 1
#define	randshape() (&shapes[random() % 7])
d167 2
d170 2
d176 1
@


1.2
log
@Relinguish SGID games, restore it only when opening the score file
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d166 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
