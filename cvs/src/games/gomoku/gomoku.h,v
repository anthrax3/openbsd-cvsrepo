head	1.12;
access;
symbols
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.4
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.10.0.16
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.8
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.12
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.10
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.6
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.34
	OPENBSD_5_0:1.9.0.32
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.30
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.28
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.24
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.26
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.22
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.20
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.18
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.16
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.14
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.12
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.10
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.8
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.4.0.16
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.14
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.12
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.10
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.8
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.6
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	GOMOKU:1.1.1.1
	BSDGAMES:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.01.04.17.33.24;	author mestre;	state Exp;
branches;
next	1.11;
commitid	b21xvsfCGMtCOVrz;

1.11
date	2015.12.26.00.26.39;	author mestre;	state Exp;
branches;
next	1.10;
commitid	NcBz9zfScw6TwPoT;

1.10
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.16.00.13.19;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.03.03.01.39;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.06.18.50.37;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.17.19.42.20;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.27.10;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.03.26.21.16.47;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	97.01.26.08.00.52;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.12.21.21.17.50;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	96.12.16.06.56.08;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.12.16.06.56.08;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.12
log
@More cleanup and sorting on header section

OK tb@@ and he also pointed out that for consistency with rest of the tree we
should include termios.h instead of sys/ttydefaults.h, where applicable
@
text
@/*	$OpenBSD: gomoku.h,v 1.11 2015/12/26 00:26:39 mestre Exp $	*/
/*
 * Copyright (c) 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)gomoku.h	8.2 (Berkeley) 5/3/95
 */

#include <stdio.h>

/* board dimensions */
#define BSZ	19
#define BSZ1	(BSZ+1)
#define BSZ2	(BSZ+2)
#define BSZ3	(BSZ+3)
#define BSZ4	(BSZ+4)
#define BAREA	(BSZ2*BSZ1+1)

/* interactive curses stuff */
#define FF		'\014'  /* used as redraw command */
#define BGOTO(y,x)	move(BSZ - (y), 2 * (x) + 3)

/* frame dimensions (based on 5 in a row) */
#define FSZ1	BSZ
#define FSZ2	(BSZ-4)
#define FAREA	(FSZ1*FSZ2 + FSZ2*FSZ2 + FSZ1*FSZ2 + FSZ2*FSZ2)

#define MUP	(BSZ1)
#define MDOWN	(-BSZ1)
#define MLEFT	(-1)
#define MRIGHT	(1)

/* values for s_occ */
#define BLACK	0
#define WHITE	1
#define EMPTY	2
#define BORDER	3

/* return values for makemove() */
#define MOVEOK	0
#define RESIGN	1
#define ILLEGAL	2
#define WIN	3
#define TIE	4
#define SAVE	5

#define A 1
#define B 2
#define C 3
#define D 4
#define E 5
#define F 6
#define G 7
#define H 8
#define J 9
#define K 10
#define L 11
#define M 12
#define N 13
#define O 14
#define P 15
#define Q 16
#define R 17
#define S 18
#define T 19

#define PT(x,y)		((x) + BSZ1 * (y))

/*
 * A 'frame' is a group of five or six contiguous board locations.
 * An open ended frame is one with spaces on both ends; otherwise, its closed.
 * A 'combo' is a group of intersecting frames and consists of two numbers:
 * 'A' is the number of moves to make the combo non-blockable.
 * 'B' is the minimum number of moves needed to win once it can't be blocked.
 * A 'force' is a combo that is one move away from being non-blockable
 *
 * Single frame combo values:
 *     <A,B>	board values
 *	5,0	. . . . . O
 *	4,1	. . . . . .
 *	4,0	. . . . X O
 *	3,1	. . . . X .
 *	3,0	. . . X X O
 *	2,1	. . . X X .
 *	2,0	. . X X X O
 *	1,1	. . X X X .
 *	1,0	. X X X X O
 *	0,1	. X X X X .
 *	0,0	X X X X X O
 *
 * The rule for combining two combos (<A1,B1> <A2,B2>)
 * with V valid intersection points, is:
 *	A' = A1 + A2 - 2 - V
 *	B' = MIN(A1 + B1 - 1, A2 + B2 - 1)
 * Each time a frame is added to the combo, the number of moves to complete
 * the force is the number of moves needed to 'fill' the frame plus one at
 * the intersection point. The number of moves to win is the number of moves
 * to complete the best frame minus the last move to complete the force.
 * Note that it doesn't make sense to combine a <1,x> with anything since
 * it is already a force. Also, the frames have to be independent so a
 * single move doesn't affect more than one frame making up the combo.
 *
 * Rules for comparing which of two combos (<A1,B1> <A2,B2>) is better:
 * Both the same color:
 *	<A',B'> = (A1 < A2 || A1 == A2 && B1 <= B2) ? <A1,B1> : <A2,B2>
 *	We want to complete the force first, then the combo with the
 *	fewest moves to win.
 * Different colors, <A1,B1> is the combo for the player with the next move:
 *	<A',B'> = A2 <= 1 && (A1 > 1 || A2 + B2 < A1 + B1) ? <A2,B2> : <A1,B1>
 *	We want to block only if we have to (i.e., if they are one move away
 *	from completing a force and we don't have a force that we can
 *	complete which takes fewer or the same number of moves to win).
 */

#define MAXA		6
#define MAXB		2
#define MAXCOMBO	0x600

union	comboval {
	struct {
#if BYTE_ORDER == BIG_ENDIAN
		u_char	a;	/* # moves to complete force */
		u_char	b;	/* # moves to win */
#endif
#if BYTE_ORDER == LITTLE_ENDIAN
		u_char	b;	/* # moves to win */
		u_char	a;	/* # moves to complete force */
#endif
	} c;
	u_short	s;
};

/*
 * This structure is used to record information about single frames (F) and
 * combinations of two more frames (C).
 * For combinations of two or more frames, there is an additional
 * array of pointers to the frames of the combination which is sorted
 * by the index into the frames[] array. This is used to prevent duplication
 * since frame A combined with B is the same as B with A.
 *	struct combostr *c_sort[size c_nframes];
 * The leaves of the tree (frames) are numbered 0 (bottom, leftmost)
 * to c_nframes - 1 (top, right). This is stored in c_frameindex and
 * c_dir if C_LOOP is set.
 */
struct combostr {
	struct combostr	*c_next;	/* list of combos at the same level */
	struct combostr	*c_prev;	/* list of combos at the same level */
	struct combostr	*c_link[2];	/* C:previous level or F:NULL */
	union comboval	c_linkv[2];	/* C:combo value for link[0,1] */
	union comboval	c_combo;	/* C:combo value for this level */
	u_short		c_vertex;	/* C:intersection or F:frame head */
	u_char		c_nframes;	/* number of frames in the combo */
	u_char		c_dir;		/* C:loop frame or F:frame direction */
	u_char		c_flg;		/* C:combo flags */
	u_char		c_frameindex;	/* C:intersection frame index */
	u_char		c_framecnt[2];	/* number of frames left to attach */
	u_char		c_emask[2];	/* C:bit mask of completion spots for
					 * link[0] and link[1] */
	u_char		c_voff[2];	/* C:vertex offset within frame */
};

/* flag values for c_flg */
#define C_OPEN_0	0x01		/* link[0] is an open ended frame */
#define C_OPEN_1	0x02		/* link[1] is an open ended frame */
#define C_LOOP		0x04		/* link[1] intersects previous frame */
#define C_MARK		0x08		/* indicates combo processed */

/*
 * This structure is used for recording the completion points of
 * multi frame combos.
 */
struct	elist {
	struct elist	*e_next;	/* list of completion points */
	struct combostr	*e_combo;	/* the whole combo */
	u_char		e_off;		/* offset in frame of this empty spot */
	u_char		e_frameindex;	/* intersection frame index */
	u_char		e_framecnt;	/* number of frames left to attach */
	u_char		e_emask;	/* real value of the frame's emask */
	union comboval	e_fval;		/* frame combo value */
};

/*
 * One spot structure for each location on the board.
 * A frame consists of the combination for the current spot plus the five spots
 * 0: right, 1: right & down, 2: down, 3: down & left.
 */
struct	spotstr {
	short		s_occ;		/* color of occupant */
	short		s_wval;		/* weighted value */
	int		s_flg;		/* flags for graph walks */
	struct combostr	*s_frame[4];	/* level 1 combo for frame[dir] */
	union comboval	s_fval[2][4];	/* combo value for [color][frame] */
	union comboval	s_combo[2];	/* minimum combo value for BLK & WHT */
	u_char		s_level[2];	/* number of frames in the min combo */
	u_char		s_nforce[2];	/* number of <1,x> combos */
	struct elist	*s_empty;	/* level n combo completion spots */
	struct elist	*s_nempty;	/* level n+1 combo completion spots */
	int		dummy[2];	/* XXX */
};

/* flag values for s_flg */
#define CFLAG		0x000001	/* frame is part of a combo */
#define CFLAGALL	0x00000F	/* all frame directions marked */
#define IFLAG		0x000010	/* legal intersection point */
#define IFLAGALL	0x0000F0	/* any intersection points? */
#define FFLAG		0x000100	/* frame is part of a <1,x> combo */
#define FFLAGALL	0x000F00	/* all force frames */
#define MFLAG		0x001000	/* frame has already been seen */
#define MFLAGALL	0x00F000	/* all frames seen */
#define BFLAG		0x010000	/* frame intersects border or dead */
#define BFLAGALL	0x0F0000	/* all frames dead */

/*
 * This structure is used to store overlap information between frames.
 */
struct	ovlp_info {
	int		o_intersect;	/* intersection spot */
	struct combostr	*o_fcombo;	/* the connecting combo */
	u_char		o_link;		/* which link to update (0 or 1) */
	u_char		o_off;		/* offset in frame of intersection */
	u_char		o_frameindex;	/* intersection frame index */
};

extern	char	*letters;
extern	char	fmtbuf[128];
extern	char	pdir[];

extern	int     dd[4];
extern	struct	spotstr	board[BAREA];		/* info for board */
extern	struct	combostr frames[FAREA];		/* storage for single frames */
extern	struct	combostr *sortframes[2];	/* sorted, non-empty frames */
extern	u_char	overlap[FAREA * FAREA];		/* frame [a][b] overlap */
extern	short	intersect[FAREA * FAREA];	/* frame [a][b] intersection */
extern	int	movelog[BSZ * BSZ];		/* history of moves */
extern	int	movenum;
extern	int	debug;

void	addframes(int);
void	appendcombo(struct combostr *);
void	ask(char *);
void	bdinit(struct spotstr *);
void	bdisp(void);
void	bdisp_init(void);
#ifdef DEBUG
void	bdump(FILE *);
#endif
void	bdwho(int);
int	better(struct spotstr *, struct spotstr *, int);
int	checkframes(struct combostr *, struct combostr *,
	    struct spotstr *, int, struct ovlp_info *);
#ifdef DEBUG
void	clearcombo(struct combostr *, int);
#endif
int	ctos(char *);
void	cursfini(void);
void	cursinit(void);
void	dislog(char *);
void	dlog(char *);
int	getcoord(void);
int	get_line(char *, int);
void	init_overlap(void);
#ifdef DEBUG
int	list_eq(struct combostr **, struct combostr **, int);
#endif
void	logit(char *);
int	lton(int);
void	makecombo(struct combostr *, struct spotstr *, int, int);
void	makecombo2(struct combostr *, struct spotstr *, int, int);
void	makeempty(struct combostr *);
int	makemove(int, int);
#ifdef DEBUG
void	markcombo(struct combostr *);
#endif
void	panic(char *);
int	pickmove(int);
void	printcombo(struct combostr *, char *, size_t);
void	qlog(char *);
__dead void	quit(int);
int	readinput(FILE *);
void	scanframes(int);
int	sortcombo(struct combostr **, struct combostr **, struct combostr *);
char	*stoc(int);
void	updatecombo(struct combostr *, int);
void	update_overlap(struct spotstr *);
#ifdef DEBUG
void	whatsup(int);
#endif

#define ASSERT(x)
@


1.11
log
@Set as __dead a few more functions, that don't return, on games/

With precious tip, help and also OK from tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gomoku.h,v 1.10 2012/03/04 04:05:15 fgsch Exp $	*/
a36 1
#include <sys/types.h>
@


1.10
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: gomoku.h,v 1.9 2004/01/16 00:13:19 espie Exp $	*/
d306 1
a306 1
void	quit(int);
@


1.9
log
@ISO C police: log and expl are reserved for the C library.
expl -> expl_string
log -> logit
@
text
@d1 1
a1 1
/*	$OpenBSD: gomoku.h,v 1.8 2003/06/03 03:01:39 millert Exp $	*/
d288 1
a288 1
int	getline(char *, int);
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: gomoku.h,v 1.7 2003/04/06 18:50:37 deraadt Exp $	*/
d293 1
a293 1
void	log(char *);
@


1.7
log
@2451 lines of strdup/sprintf/strcpy whacking.  mostly ok'd by pjanzen
already, but he may have later changes to make still.
@
text
@d1 1
a1 1
/*	$OpenBSD: gomoku.h,v 1.6 2002/02/17 19:42:20 millert Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.6
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: gomoku.h,v 1.5 2002/02/16 21:27:10 millert Exp $	*/
d257 1
a257 1
extern	char	fmtbuf[];
d308 1
a308 1
void	printcombo(struct combostr *, char *);
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: gomoku.h,v 1.4 1998/03/26 21:16:47 pjanzen Exp $	*/
d281 2
a282 2
int	checkframes __P((struct combostr *, struct combostr *,
				 struct spotstr *, int, struct ovlp_info *));
@


1.4
log
@improved interactive input and minor tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: gomoku.h,v 1.3 1997/01/26 08:00:52 downsj Exp $	*/
d270 6
a275 6
void	addframes __P((int));
void	appendcombo __P((struct combostr *));
void	ask __P((char *));
void	bdinit __P((struct spotstr *));
void	bdisp __P((void));
void	bdisp_init __P((void));
d277 1
a277 1
void	bdump __P((FILE *));
d279 2
a280 2
void	bdwho __P((int));
int	better __P((struct spotstr *, struct spotstr *, int));
d284 1
a284 1
void	clearcombo __P((struct combostr *, int));
d286 8
a293 8
int	ctos __P((char *));
void	cursfini __P((void));
void	cursinit __P((void));
void	dislog __P((char *));
void	dlog __P((char *));
int	getcoord __P((void));
int	getline __P((char *, int));
void	init_overlap __P((void));
d295 1
a295 1
int	list_eq __P((struct combostr **, struct combostr **, int));
d297 6
a302 6
void	log __P((char *));
int	lton __P((int));
void	makecombo __P((struct combostr *, struct spotstr *, int, int));
void	makecombo2 __P((struct combostr *, struct spotstr *, int, int));
void	makeempty __P((struct combostr *));
int	makemove __P((int, int));
d304 1
a304 1
void	markcombo __P((struct combostr *));
d306 11
a316 11
void	panic __P((char *));
int	pickmove __P((int));
void	printcombo __P((struct combostr *, char *));
void	qlog __P((char *));
void	quit __P((int));
int	readinput __P((FILE *));
void	scanframes __P((int));
int	sortcombo __P((struct combostr **, struct combostr **, struct combostr *));
char	*stoc __P((int));
void	updatecombo __P((struct combostr *, int));
void	update_overlap __P((struct spotstr *));
d318 1
a318 1
void	whatsup __P((int));
@


1.3
log
@Check malloc() return value.
@
text
@d1 1
a1 1
/*	$OpenBSD: gomoku.h,v 1.2 1996/12/21 21:17:50 tholo Exp $	*/
d47 2
d51 5
a55 1
/* frame dimentions (based on 5 in a row) */
d270 6
a275 6
extern	void	addframes __P((int));
extern	void	appendcombo __P((struct combostr *));
extern	void	ask __P((char *));
extern	void	bdinit __P((struct spotstr *));
extern	void	bdisp __P((void));
extern	void	bdisp_init __P((void));
d277 1
a277 1
extern	void	bdump __P((FILE *));
d279 3
a281 3
extern	void	bdwho __P((int));
extern	int	better __P((struct spotstr *, struct spotstr *, int));
extern	int	checkframes __P((struct combostr *, struct combostr *,
d284 1
a284 1
extern	void	clearcombo __P((struct combostr *, int));
d286 8
a293 7
extern	int	ctos __P((char *));
extern	void	cursfini __P((void));
extern	void	cursinit __P((void));
extern	void	dislog __P((char *));
extern	void	dlog __P((char *));
extern	int	getline __P((char *, int));
extern	void	init_overlap __P((void));
d295 1
a295 1
extern	int	list_eq __P((struct combostr **, struct combostr **, int));
d297 6
a302 6
extern	void	log __P((char *));
extern	int	lton __P((int));
extern	void	makecombo __P((struct combostr *, struct spotstr *, int, int));
extern	void	makecombo2 __P((struct combostr *, struct spotstr *, int, int));
extern	void	makeempty __P((struct combostr *));
extern	int	makemove __P((int, int));
d304 1
a304 1
extern	void	markcombo __P((struct combostr *));
d306 11
a316 11
extern	void	panic __P((char *));
extern	int	pickmove __P((int));
extern	void	printcombo __P((struct combostr *, char *));
extern	void	qlog __P((char *));
extern	void	quit __P((int));
extern	int	readinput __P((FILE *));
extern	void	scanframes __P((int));
extern	int	sortcombo __P((struct combostr **, struct combostr **, struct combostr *));
extern	char	*stoc __P((int));
extern	void	updatecombo __P((struct combostr *, int));
extern	void	update_overlap __P((struct spotstr *));
d318 1
a318 1
extern	void	whatsup __P((int));
@


1.2
log
@Clean up lint and -Wall output
@
text
@d1 1
a1 1
/*	$OpenBSD: gomoku.h,v 1.1.1.1 1996/12/16 06:56:08 downsj Exp $	*/
d302 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 1
d264 48
a311 3
extern	char    *copy();
extern	char    *stoc();
extern	char    *tail();
@


1.1.1.1
log
@Import of gomoku from 4.4BSD Lite2.  Uses ocurses.
@
text
@@
