head	1.27;
access;
symbols
	OPENBSD_6_1:1.27.0.2
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.26.0.4
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.18.0.10
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.16
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.14
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.12
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.10
	OPENBSD_5_0:1.17.0.8
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.12
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.8
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.6
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.12
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.10
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.8
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.6
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.4
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.14
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.12
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.10
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.8
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.6
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2016.09.11.14.21.17;	author tb;	state Exp;
branches;
next	1.26;
commitid	vQliJ9M8LCn9g8k6;

1.26
date	2016.01.27.13.42.08;	author gsoares;	state Exp;
branches;
next	1.25;
commitid	g26WJiug8RV609LS;

1.25
date	2016.01.25.21.17.45;	author mestre;	state Exp;
branches;
next	1.24;
commitid	xUnjuo2cchVobwPx;

1.24
date	2016.01.10.13.35.09;	author mestre;	state Exp;
branches;
next	1.23;
commitid	mVbl9a8GbGdqcFgu;

1.23
date	2016.01.03.14.38.16;	author mestre;	state Exp;
branches;
next	1.22;
commitid	Ptgw9rNvmSHNRfGy;

1.22
date	2015.12.25.20.59.09;	author mestre;	state Exp;
branches;
next	1.21;
commitid	5J5Os05YMVA0ZKC5;

1.21
date	2015.10.24.17.13.27;	author mmcc;	state Exp;
branches;
next	1.20;
commitid	K6ZKvivsMDUJNe2h;

1.20
date	2015.10.10.22.32.55;	author doug;	state Exp;
branches;
next	1.19;
commitid	K81wyjGREDTzZt9g;

1.19
date	2015.08.22.14.47.41;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	vWCbqNWL9DL2UkGT;

1.18
date	2013.08.29.20.22.09;	author naddy;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.27.23.59.23;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.20.03.43.50;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.09.15.59.26;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.03.03.01.37;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.12.06.21.48.50;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.11.05.22.40;	author jsyn;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.31.04.21.20;	author pjanzen;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.31.03.40.00;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.08;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.09.15.05.22.45;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	98.08.19.07.39.50;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	98.03.12.09.09.05;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	98.02.26.07.58.05;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.01.17.07.10.42;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.40.30;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.04.23.03.00.16;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.36;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.36;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Callers of time(3) should #include <time.h>.

ok deraadt
@
text
@/*	$OpenBSD: arithmetic.c,v 1.26 2016/01/27 13:42:08 gsoares Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Eamonn McManus of Trinity College Dublin.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * By Eamonn McManus, Trinity College Dublin <emcmanus@@cs.tcd.ie>.
 *
 * The operation of this program mimics that of the standard Unix game
 * `arithmetic'.  I've made it as close as I could manage without examining
 * the source code.  The principal differences are:
 *
 * The method of biasing towards numbers that had wrong answers in the past
 * is different; original `arithmetic' seems to retain the bias forever,
 * whereas this program lets the bias gradually decay as it is used.
 *
 * Original `arithmetic' delays for some period (3 seconds?) after printing
 * the score.  I saw no reason for this delay, so I scrapped it.
 *
 * There is no longer a limitation on the maximum range that can be supplied
 * to the program.  The original program required it to be less than 100.
 * Anomalous results may occur with this program if ranges big enough to
 * allow overflow are given.
 *
 * I have obviously not attempted to duplicate bugs in the original.  It
 * would go into an infinite loop if invoked as `arithmetic / 0'.  It also
 * did not recognise an EOF in its input, and would continue trying to read
 * after it.  It did not check that the input was a valid number, treating any
 * garbage as 0.  Finally, it did not flush stdout after printing its prompt,
 * so in the unlikely event that stdout was not a terminal, it would not work
 * properly.
 */

#include <err.h>
#include <ctype.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

int	getrandom(int, int, int);
__dead void	intr(int);
int	opnum(int);
void	penalise(int, int, int);
int	problem(void);
void	showstats(void);
__dead void	usage(void);

const char keylist[] = "+-x/";
const char defaultkeys[] = "+-";
const char *keys = defaultkeys;
int nkeys = sizeof(defaultkeys) - 1;
int rangemax = 10;
int nright, nwrong;
time_t qtime;
#define	NQUESTS	20

/*
 * Select keys from +-x/ to be asked addition, subtraction, multiplication,
 * and division problems.  More than one key may be given.  The default is
 * +-.  Specify a range to confine the operands to 0 - range.  Default upper
 * bound is 10.  After every NQUESTS questions, statistics on the performance
 * so far are printed.
 */
int
main(int argc, char *argv[])
{
	int ch, cnt;
	const char *errstr;

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	while ((ch = getopt(argc, argv, "hr:o:")) != -1)
		switch(ch) {
		case 'o': {
			const char *p;

			for (p = keys = optarg; *p; ++p)
				if (!strchr(keylist, *p))
					errx(1, "unknown key.");
			nkeys = p - optarg;
			break;
		}
		case 'r':
			rangemax = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				errx(1, "invalid range, %s: %s", errstr, optarg);
			break;
		case 'h':
		default:
			usage();
		}
	if (argc -= optind)
		usage();

	(void)signal(SIGINT, intr);

	/* Now ask the questions. */
	for (;;) {
		for (cnt = NQUESTS; cnt--;)
			if (problem() == EOF)
				intr(0);   /* Print score and exit */
		showstats();
	}
}

/* Handle interrupt character.  Print score and exit. */
void
intr(int dummy)
{
	showstats();
	_exit(0);
}

/* Print score.  Original `arithmetic' had a delay after printing it. */
void
showstats(void)
{
	if (nright + nwrong > 0) {
		(void)printf("\n\nRights %d; Wrongs %d; Score %d%%",
		    nright, nwrong, (int)(100L * nright / (nright + nwrong)));
		if (nright > 0)
	(void)printf("\nTotal time %ld seconds; %.1f seconds per problem\n\n",
			    (long)qtime, (float)qtime / nright);
	}
	(void)printf("\n");
}

/*
 * Pick a problem and ask it.  Keeps asking the same problem until supplied
 * with the correct answer, or until EOF or interrupt is typed.  Problems are
 * selected such that the right operand and either the left operand (for +, x)
 * or the correct result (for -, /) are in the range 0 to rangemax.  Each wrong
 * answer causes the numbers in the problem to be penalised, so that they are
 * more likely to appear in subsequent problems.
 */
int
problem(void)
{
	char *p;
	time_t start, finish;
	int left, op, right, result;
	char line[80];

	op = keys[arc4random_uniform(nkeys)];
	if (op != '/')
		right = getrandom(rangemax + 1, op, 1);
retry:
	/* Get the operands. */
	switch (op) {
	case '+':
		left = getrandom(rangemax + 1, op, 0);
		result = left + right;
		break;
	case '-':
		result = getrandom(rangemax + 1, op, 0);
		left = right + result;
		break;
	case 'x':
		left = getrandom(rangemax + 1, op, 0);
		result = left * right;
		break;
	case '/':
		right = getrandom(rangemax, op, 1) + 1;
		result = getrandom(rangemax + 1, op, 0);
		left = right * result + arc4random_uniform(right);
		break;
	}

	/*
	 * A very big maxrange could cause negative values to pop
	 * up, owing to overflow.
	 */
	if (result < 0 || left < 0)
		goto retry;

	(void)printf("%d %c %d =   ", left, op, right);
	(void)fflush(stdout);
	(void)time(&start);

	/*
	 * Keep looping until the correct answer is given, or until EOF or
	 * interrupt is typed.
	 */
	for (;;) {
		if (!fgets(line, sizeof(line), stdin)) {
			(void)printf("\n");
			return(EOF);
		}
		for (p = line; isspace((unsigned char)*p); ++p);
		if (!isdigit((unsigned char)*p)) {
			(void)printf("Please type a number.\n");
			continue;
		}
		if (atoi(p) == result) {
			(void)printf("Right!\n");
			++nright;
			break;
		}
		/* Wrong answer; penalise and ask again. */
		(void)printf("What?\n");
		++nwrong;
		penalise(right, op, 1);
		if (op == 'x' || op == '+')
			penalise(left, op, 0);
		else
			penalise(result, op, 0);
	}

	/*
	 * Accumulate the time taken.  Obviously rounding errors happen here;
	 * however they should cancel out, because some of the time you are
	 * charged for a partially elapsed second at the start, and some of
	 * the time you are not charged for a partially elapsed second at the
	 * end.
	 */
	(void)time(&finish);
	qtime += finish - start;
	return(0);
}

/*
 * Here is the code for accumulating penalties against the numbers for which
 * a wrong answer was given.  The right operand and either the left operand
 * (for +, x) or the result (for -, /) are stored in a list for the particular
 * operation, and each becomes more likely to appear again in that operation.
 * Initially, each number is charged a penalty of WRONGPENALTY, giving it that
 * many extra chances of appearing.  Each time it is selected because of this,
 * its penalty is decreased by one; it is removed when it reaches 0.
 *
 * The penalty[] array gives the sum of all penalties in the list for
 * each operation and each operand.  The penlist[] array has the lists of
 * penalties themselves.
 */

int penalty[sizeof(keylist) - 1][2];
struct penalty {
	int value, penalty;	/* Penalised value and its penalty. */
	struct penalty *next;
} *penlist[sizeof(keylist) - 1][2];

#define	WRONGPENALTY	5	/* Perhaps this should depend on maxrange. */

/*
 * Add a penalty for the number `value' to the list for operation `op',
 * operand number `operand' (0 or 1).  If we run out of memory, we just
 * forget about the penalty (how likely is this, anyway?).
 */
void
penalise(int value, int op, int operand)
{
	struct penalty *p;

	op = opnum(op);
	if ((p = malloc(sizeof(*p))) == NULL)
		return;
	p->next = penlist[op][operand];
	penlist[op][operand] = p;
	penalty[op][operand] += p->penalty = WRONGPENALTY;
	p->value = value;
}

/*
 * Select a random value from 0 to maxval - 1 for operand `operand' (0 or 1)
 * of operation `op'.  The random number we generate is either used directly
 * as a value, or represents a position in the penalty list.  If the latter,
 * we find the corresponding value and return that, decreasing its penalty.
 */
int
getrandom(int maxval, int op, int operand)
{
	int value;
	struct penalty **pp, *p;

	op = opnum(op);
	value = arc4random_uniform(maxval + penalty[op][operand]);

	/*
	 * 0 to maxval - 1 is a number to be used directly; bigger values
	 * are positions to be located in the penalty list.
	 */
	if (value < maxval)
		return(value);
	value -= maxval;

	/*
	 * Find the penalty at position `value'; decrement its penalty and
	 * delete it if it reaches 0; return the corresponding value.
	 */
	for (pp = &penlist[op][operand]; (p = *pp) != NULL; pp = &p->next) {
		if (p->penalty > value) {
			value = p->value;
			penalty[op][operand]--;
			if (--(p->penalty) <= 0) {
				p = p->next;
				(void)free((char *)*pp);
				*pp = p;
			}
			return(value);
		}
		value -= p->penalty;
	}
	/*
	 * We can only get here if the value from the penalty[] array doesn't
	 * correspond to the actual sum of penalties in the list.  Provide an
	 * obscure message.
	 */
	errx(1, "bug: inconsistent penalties.");
}

/* Return an index for the character op, which is one of [+-x/]. */
int
opnum(int op)
{
	char *p;

	if (op == 0 || (p = strchr(keylist, op)) == NULL)
		errx(1, "bug: op %c not in keylist %s.", op, keylist);
	return(p - keylist);
}

/* Print usage message and quit. */
void
usage(void)
{
	extern char *__progname;
	(void)fprintf(stderr, "usage: %s [-o +-x/] [-r range]\n",  __progname);
	exit(1);
}
@


1.26
log
@- optarg and optind are declared by unistd.h, so remove them...
- use strtonum rather than atoi
- zap case '?' in getopt(3) switch
- use _exit(2) in signal handler
- use __progname in usage() instead of hardcoded name

OK tb@@ mestre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arithmetic.c,v 1.25 2016/01/25 21:17:45 mestre Exp $	*/
d70 1
@


1.25
log
@Remove unused header
@
text
@d1 1
a1 1
/*	$OpenBSD: arithmetic.c,v 1.24 2016/01/10 13:35:09 mestre Exp $	*/
d65 1
a98 2
	extern char *optarg;
	extern int optind;
d100 1
d117 3
a119 2
			if ((rangemax = atoi(optarg)) <= 0)
				errx(1, "invalid range.");
a120 1
		case '?':
d144 1
a144 1
	exit(0);
d358 2
a359 1
	(void)fprintf(stderr, "usage: arithmetic [-o +-x/] [-r range]\n");
@


1.24
log
@As per style(9), remove remaining lint-style comments from games/

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arithmetic.c,v 1.23 2016/01/03 14:38:16 mestre Exp $	*/
a62 1
#include <sys/types.h>
@


1.23
log
@About 13 years ago when the idiom srandom(time()), and sometimes
srandom(time()+getpid()), was changed by srandomdev(), but #include <time.h>
lived up until this day so remove it.

Additionally, earlier than that, 18 years ago, random(6) was one of the first
consumers of arc4random(3) family, and was pulling it from dev/rndvar.h but
these days we pull it from stdlib.h, which is already done, so while here
remove dev/rndvar.h also.

"seems comprehensive to me" deraadt@@ and OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arithmetic.c,v 1.22 2015/12/25 20:59:09 mestre Exp $	*/
a137 1
	/* NOTREACHED */
a341 1
	/* NOTREACHED */
@


1.22
log
@Declare usage() functions as __dead void, if they don't return, on games section.

Found another one in arithmetic(6) which also didn't return, and removed a function from number(6) which is not used anymore.

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arithmetic.c,v 1.21 2015/10/24 17:13:27 mmcc Exp $	*/
a69 1
#include <time.h>
@


1.21
log
@Cast ctype functions' arguments to unsigned char.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arithmetic.c,v 1.20 2015/10/10 22:32:55 doug Exp $	*/
d74 1
a74 1
void	intr(int);
d79 1
a79 1
void	usage(void);
@


1.20
log
@Pledge that arithmetic only takes "stdio".
@
text
@d1 1
a1 1
/*	$OpenBSD: arithmetic.c,v 1.19 2015/08/22 14:47:41 deraadt Exp $	*/
d225 2
a226 2
		for (p = line; isspace(*p); ++p);
		if (!isdigit(*p)) {
@


1.19
log
@remove malloc/calloc/realloc* casts, due to stdlib.h being present; ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: arithmetic.c,v 1.18 2013/08/29 20:22:09 naddy Exp $	*/
d103 3
@


1.18
log
@replace srandomdev()+random() with the arc4random*() family
tweaks and ok millert@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arithmetic.c,v 1.17 2009/10/27 23:59:23 deraadt Exp $	*/
d287 1
a287 1
	if ((p = (struct penalty *)malloc((u_int)sizeof(*p))) == NULL)
@


1.17
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: arithmetic.c,v 1.16 2007/03/20 03:43:50 tedu Exp $	*/
a126 3
	/* Seed the random-number generator. */
	srandomdev();

d177 1
a177 1
	op = keys[random() % nkeys];
d198 1
a198 1
		left = right * result + random() % right;
d308 1
a308 1
	value = random() % (maxval + penalty[op][operand]);
@


1.16
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: arithmetic.c,v 1.15 2004/07/09 15:59:26 deraadt Exp $	*/
a33 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)arithmetic.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: arithmetic.c,v 1.15 2004/07/09 15:59:26 deraadt Exp $";
#endif
#endif /* not lint */
@


1.15
log
@ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: arithmetic.c,v 1.14 2003/06/03 03:01:37 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: arithmetic.c,v 1.14 2003/06/03 03:01:37 millert Exp $";
d239 1
a239 1
		for (p = line; *p && isspace(*p); ++p);
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: arithmetic.c,v 1.13 2002/12/06 21:48:50 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: arithmetic.c,v 1.13 2002/12/06 21:48:50 millert Exp $";
d112 1
a112 3
main(argc, argv)
	int argc;
	char **argv;
d158 1
a158 2
intr(dummy)
	int dummy;
d166 1
a166 1
showstats()
d187 1
a187 1
problem()
d299 1
a299 2
penalise(value, op, operand)
	int value, op, operand;
d319 1
a319 2
getrandom(maxval, op, operand)
	int maxval, op, operand;
d363 1
a363 2
opnum(op)
	int op;
d374 1
a374 1
usage()
@


1.13
log
@Replace things like srandom(time(NULL)) with srandomdev(3).  random(3)
good enough for games but we should at least use a decent seed.
pjanzen@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: arithmetic.c,v 1.12 2002/06/11 05:22:40 jsyn Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d45 1
a45 1
static char rcsid[] = "$OpenBSD: arithmetic.c,v 1.12 2002/06/11 05:22:40 jsyn Exp $";
@


1.12
log
@no more err(3) newlines in games; ok pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arithmetic.c,v 1.11 2002/05/31 04:21:20 pjanzen Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: arithmetic.c,v 1.11 2002/05/31 04:21:20 pjanzen Exp $";
d148 1
a148 1
	srandom((int)time((time_t *)NULL));
@


1.11
log
@de-register
@
text
@d1 1
a1 1
/*	$OpenBSD: arithmetic.c,v 1.10 2002/05/31 03:40:00 pjanzen Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: arithmetic.c,v 1.10 2002/05/31 03:40:00 pjanzen Exp $";
d366 1
a366 1
	errx(1, "bug: inconsistent penalties\n");
d378 1
a378 1
		errx(1, "bug: op %c not in keylist %s\n", op, keylist);
@


1.10
log
@No dm -> no need to revoke setegid.
@
text
@d1 1
a1 1
/*	$OpenBSD: arithmetic.c,v 1.9 2002/02/16 21:27:08 millert Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: arithmetic.c,v 1.9 2002/02/16 21:27:08 millert Exp $";
d196 1
a196 1
	register char *p;
d331 1
a331 1
	register struct penalty **pp, *p;
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: arithmetic.c,v 1.8 1998/09/15 05:22:45 pjanzen Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: arithmetic.c,v 1.8 1998/09/15 05:22:45 pjanzen Exp $";
a122 4

	/* revoke privs */
	setegid(getgid());
	setgid(getgid());
@


1.8
log
@use const where appropriate; jsm28@@cam.ac.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: arithmetic.c,v 1.7 1998/08/19 07:39:50 pjanzen Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: arithmetic.c,v 1.7 1998/08/19 07:39:50 pjanzen Exp $";
d91 7
a97 7
int	getrandom __P((int, int, int));
void	intr __P((int));
int	opnum __P((int));
void	penalise __P((int, int, int));
int	problem __P((void));
void	showstats __P((void));
void	usage __P((void));
@


1.7
log
@tags, formatting, ANSI-fication, prototypes, de-typos, and the occasional
initialization, removal of unused variable, or other minor fix.  Most
changes are from or inspired by NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: arithmetic.c,v 1.6 1998/03/12 09:09:05 pjanzen Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: arithmetic.c,v 1.6 1998/03/12 09:09:05 pjanzen Exp $";
d99 3
a101 3
char keylist[] = "+-x/";
char defaultkeys[] = "+-";
char *keys = defaultkeys;
d131 1
a131 1
			register char *p;
@


1.6
log
@OpenBSD ID (changed from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD$";
d135 1
a135 1
					errx(1,"unknown key.");
@


1.5
log
@cleanup efforts care of pjanzen@@foatdi.harvard.edu
@
text
@d1 1
a1 1
/*	$NetBSD: arithmetic.c,v 1.6 1996/03/21 18:30:19 jtc Exp $	*/
d49 1
a49 1
static char rcsid[] = "$NetBSD: arithmetic.c,v 1.6 1996/03/21 18:30:19 jtc Exp $";
@


1.4
log
@r?index -> strr?chr
@
text
@d82 2
a84 1
#include <ctype.h>
d86 1
d89 9
a122 1
	void intr();
d124 5
a128 1
	while ((ch = getopt(argc, argv, "r:o:")) != -1)
d134 2
a135 5
				if (!strchr(keylist, *p)) {
					(void)fprintf(stderr,
					    "arithmetic: unknown key.\n");
					exit(1);
				}
d140 2
a141 5
			if ((rangemax = atoi(optarg)) <= 0) {
				(void)fprintf(stderr,
				    "arithmetic: invalid range.\n");
				exit(1);
			}
d144 1
d160 1
a160 1
				exit(0);
d168 2
a169 1
intr()
d176 1
d197 1
d309 1
a313 1
	char *malloc();
d330 1
d370 1
a370 2
	(void)fprintf(stderr, "arithmetic: bug: inconsistent penalties\n");
	exit(1);
d375 1
d381 2
a382 5
	if (op == 0 || (p = strchr(keylist, op)) == NULL) {
		(void)fprintf(stderr,
		    "arithmetic: bug: op %c not in keylist %s\n", op, keylist);
		exit(1);
	}
d387 1
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d120 1
a120 1
				if (!index(keylist, *p)) {
d368 1
a368 1
	if (op == 0 || (p = index(keylist, op)) == NULL) {
@


1.2
log
@sync with netbsd 960418
@
text
@d114 1
a114 1
	while ((ch = getopt(argc, argv, "r:o:")) != EOF)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: arithmetic.c,v 1.5 1995/03/21 11:59:32 cgd Exp $	*/
d49 1
a49 1
static char rcsid[] = "$NetBSD: arithmetic.c,v 1.5 1995/03/21 11:59:32 cgd Exp $";
d104 1
a104 1
void
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

