head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.10
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.8
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.6.0.8
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.52
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.48
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.46
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.44
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.42
	OPENBSD_5_0:1.5.0.40
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.38
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.36
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.32
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.34
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.30
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.28
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.26
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.24
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.22
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.20
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.18
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.16
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.14
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.12
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.10
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.8
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.12
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.10
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.8
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.6
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.01.10.13.35.09;	author mestre;	state Exp;
branches;
next	1.8;
commitid	mVbl9a8GbGdqcFgu;

1.8
date	2016.01.06.14.28.09;	author mestre;	state Exp;
branches;
next	1.7;
commitid	A5CGsPmxC2qOSHvN;

1.7
date	2016.01.06.09.39.51;	author tb;	state Exp;
branches;
next	1.6;
commitid	n1ecS9whrSfppP1l;

1.6
date	2014.07.12.03.41.04;	author deraadt;	state Exp;
branches;
next	1.5;
commitid	Yi7cQzTeO9GQVNTk;

1.5
date	2002.01.16.01.28.54;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.11.29.19.56.57;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	98.07.10.09.46.46;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.05.26.07.23.12;	author fn;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.10;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.9
log
@As per style(9), remove remaining lint-style comments from games/

OK tb@@
@
text
@/*	$OpenBSD: io.c,v 1.8 2016/01/06 14:28:09 mestre Exp $	*/
/*	$NetBSD: io.c,v 1.2 1995/03/24 03:58:50 cgd Exp $	*/

/*
 * io.c - input/output routines for Phantasia
 */

#include <ctype.h>
#include <curses.h>
#include <math.h>
#include <setjmp.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>

#include "macros.h"
#include "phantdefs.h"
#include "phantglobs.h"

static jmp_buf Timeoenv;	/* used for timing out waiting for input */

/************************************************************************
/
/ FUNCTION NAME: getstring()
/
/ FUNCTION: read a string from operator
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS:
/	char *cp - pointer to buffer area to fill
/	int mx - maximum number of characters to put in buffer
/
/ RETURN VALUE: none
/
/ MODULES CALLED: wmove(), _filbuf(), clearok(), waddstr(), wrefresh(), 
/	wclrtoeol()
/
/ GLOBAL INPUTS: Echo, _iob[], Wizard, *stdscr
/
/ GLOBAL OUTPUTS: _iob[]
/
/ DESCRIPTION:
/	Read a string from the keyboard.
/	This routine is specially designed to:
/
/	    - strip non-printing characters (unless Wizard)
/	    - echo, if desired
/	    - redraw the screen if CH_REDRAW is entered
/	    - read in only 'mx - 1' characters or less characters
/	    - nul-terminate string, and throw away newline
/
/	'mx' is assumed to be at least 2.
/
*************************************************************************/

void
getstring(char *cp, int mx)
{
	char   *inptr;		/* pointer into string for next string */
	int     x, y;		/* original x, y coordinates on screen */
	int     ch;		/* input */

	getyx(stdscr, y, x);	/* get coordinates on screen */
	inptr = cp;
	*inptr = '\0';		/* clear string to start */
	--mx;			/* reserve room in string for nul terminator */

	do
		/* get characters and process */
	{
		if (Echo)
			mvaddstr(y, x, cp);	/* print string on screen */
		clrtoeol();	/* clear any data after string */
		refresh();	/* update screen */

		ch = getchar();	/* get character */

		switch (ch) {
		case CH_NEWLINE:	/* terminate string */
		case CH_RETURN:
			break;

		case CH_REDRAW:	/* redraw screen */
			clearok(stdscr, TRUE);
			continue;

		default:		/* put data in string */
			if (ch == Ch_Erase) {	/* back up one character */
				if (inptr > cp)
					--inptr;
				break;
			} else if (ch == Ch_Kill) { /* back up to original location */
				inptr = cp;
				break;
			} else if (isprint(ch) || Wizard) {
				/* printing char; put in string */
				*inptr++ = ch;
			}
		}

		*inptr = '\0';	/* terminate string */
	}
	while (ch != CH_NEWLINE && ch != CH_RETURN && inptr < cp + mx);
}
/**/
/************************************************************************
/
/ FUNCTION NAME: more()
/
/ FUNCTION: pause and prompt player
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS:
/	int where - line on screen on which to pause
/
/ RETURN VALUE: none
/
/ MODULES CALLED: wmove(), waddstr(), getanswer()
/
/ GLOBAL INPUTS: *stdscr
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	Print a message, and wait for a space character.
/
*************************************************************************/

void
more(int where)
{
	mvaddstr(where, 0, "-- more --");
	getanswer(" ", FALSE);
}
/**/
/************************************************************************
/
/ FUNCTION NAME: infloat()
/
/ FUNCTION: input a floating point number from operator
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: none
/
/ RETURN VALUE: floating point number from operator
/
/ MODULES CALLED: sscanf(), getstring()
/
/ GLOBAL INPUTS: Databuf[]
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	Read a string from player, and scan for a floating point
/	number.
/	If no valid number is found, return 0.0.
/
*************************************************************************/

double
infloat(void)
{
	double  result;		/* return value */

	getstring(Databuf, SZ_DATABUF);
	if (sscanf(Databuf, "%lf", &result) < 1)
		/* no valid number entered */
		result = 0.0;

	return (result);
}
/**/
/************************************************************************
/
/ FUNCTION NAME: inputoption()
/
/ FUNCTION: input an option value from player
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: floor(), drandom(), getanswer()
/
/ GLOBAL INPUTS: Player
/
/ GLOBAL OUTPUTS: Player
/
/ DESCRIPTION:
/	Age increases with every move.
/	Refresh screen, and get a single character option from player.
/	Return a random value if player's ring has gone bad.
/
*************************************************************************/

int
inputoption(void)
{
	++Player.p_age;		/* increase age */

	if (Player.p_ring.ring_type != R_SPOILED)
		/* ring ok */
		return (getanswer("T ", TRUE));
	else
		/* bad ring */
	{
		getanswer(" ", TRUE);
		return ((int) ROLL(0.0, 5.0) + '0');
	}
}
/**/
/************************************************************************
/
/ FUNCTION NAME: interrupt()
/
/ FUNCTION: handle interrupt from operator
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: fork(), exit(), wait(), death(), alarm(), execl(), wmove(), 
/	signal(), getenv(), wclear(), crmode(), clearok(), waddstr(),
/	cleanup(), wrefresh(), leavegame(), getanswer()
/
/ GLOBAL INPUTS: Player, *stdscr
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	Allow player to quit upon hitting the interrupt key.
/	If the player wants to quit while in battle, he/she automatically
/	dies.
/
*************************************************************************/

void
interrupt(void)
{
	char    line[81];	/* a place to store data already on screen */
	int     loop;		/* counter */
	int     x, y;		/* coordinates on screen */
	int     ch;		/* input */
	unsigned savealarm;	/* to save alarm value */

	savealarm = alarm(0);	/* turn off any alarms */

	getyx(stdscr, y, x);	/* save cursor location */

	for (loop = 0; loop < 80; ++loop) {	/* save line on screen */
		move(4, loop);
		line[loop] = inch();
	}
	line[80] = '\0';	/* nul terminate */

	if (Player.p_status == S_INBATTLE || Player.p_status == S_MONSTER)
		/* in midst of fighting */
	{
		mvaddstr(4, 0, "Quitting now will automatically kill your character.  Still want to ? ");
		ch = getanswer("NY", FALSE);
		if (ch == 'Y')
			death("Bailing out");
	} else {
		mvaddstr(4, 0, "Do you really want to quit ? ");
		ch = getanswer("NY", FALSE);
		if (ch == 'Y')
			leavegame();
	}

	mvaddstr(4, 0, line);	/* restore data on screen */
	move(y, x);		/* restore cursor */
	refresh();

	alarm(savealarm);	/* restore alarm */
}
/**/
/************************************************************************
/
/ FUNCTION NAME: getanswer()
/
/ FUNCTION: get an answer from operator
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS:
/	char *choices - string of (upper case) valid choices
/	bool def - set if default answer
/
/ RETURN VALUE: none
/
/ MODULES CALLED: alarm(), wmove(), waddch(), signal(), setjmp(), strchr(), 
/	_filbuf(), clearok(), toupper(), wrefresh(), mvprintw(), wclrtoeol()
/
/ GLOBAL INPUTS: catchalarm(), Echo, _iob[], _ctype[], *stdscr, Timeout, 
/	Timeoenv[]
/
/ GLOBAL OUTPUTS: _iob[]
/
/ DESCRIPTION:
/	Get a single character answer from operator.
/	Timeout waiting for response.  If we timeout, or the
/	answer in not in the list of valid choices, print choices,
/	and wait again, otherwise return the first character in ths
/	list of choices.
/	Give up after 3 tries.
/
*************************************************************************/

int
getanswer(char *choices, bool def)
{
	         int ch;	 /* input */
	volatile int loop;	 /* counter */
	volatile int oldx, oldy; /* original coordinates on screen */

	getyx(stdscr, oldy, oldx);
	alarm(0);		/* make sure alarm is off */

	for (loop = 3; loop; --loop)
	for (loop = 3; loop; --loop)
		/* try for 3 times */
	{
		if (setjmp(Timeoenv) != 0)
			/* timed out waiting for response */
		{
			if (def || loop <= 1)
				/* return default answer */
				break;
			else
				/* prompt, and try again */
				goto YELL;
		} else
			/* wait for response */
		{
			clrtoeol();
			refresh();
			signal(SIGALRM, catchalarm);
			/* set timeout */
			if (Timeout)
				alarm(7);	/* short */
			else
				alarm(600);	/* long */

			ch = getchar();

			alarm(0);	/* turn off timeout */

			if (ch < 0) {
				/* caught some signal */
				++loop;
				continue;
			} else if (ch == CH_REDRAW) {
				/* redraw screen */
				clearok(stdscr, TRUE);	/* force clear screen */
				++loop;	/* don't count this input */
				continue;
			} else if (Echo) {
				addch(ch);	/* echo character */
				refresh();
			}
			if (islower(ch))
				/* convert to upper case */
				ch = toupper(ch);

			if (def || strchr(choices, ch) != NULL)
				/* valid choice */
				return (ch);
			else if (!def && loop > 1) {
				/* bad choice; prompt, and try again */
			YELL:	mvprintw(oldy + 1, 0, "Please choose one of : [%s]\n", choices);
				move(oldy, oldx);
				clrtoeol();
				continue;
			} else
				/* return default answer */
				break;
		}
	}

	return (*choices);
}
/**/
/************************************************************************
/
/ FUNCTION NAME: catchalarm()
/
/ FUNCTION: catch timer when waiting for input
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: longjmp()
/
/ GLOBAL INPUTS: Timeoenv[]
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	Come here when the alarm expires while waiting for input.
/	Simply longjmp() into getanswer().
/
*************************************************************************/

void
catchalarm(int dummy)
{
	longjmp(Timeoenv, 1);
}
@


1.8
log
@Remove unnecessary header files from phantasia(6)

Lesson learnt: don't include an header sorted alphabetically just because. The
external definition of variables was done on phantglobs.h but their declaration
was on phantstruct.h and therefore the latter must be included before the
former. It's easier to just include phantstruct.h inside phantglobs.h since it
always need it.

With help and OK from tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.7 2016/01/06 09:39:51 tb Exp $	*/
a269 1
		/* NOTREACHED */
a274 1
		/* NOTREACHED */
@


1.7
log
@Ansify the bulk of phantasia.  No binary change on amd64.  Based
on an older diff by mestre.

ok mestre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.6 2014/07/12 03:41:04 deraadt Exp $	*/
d8 13
a20 1
#include "include.h"
@


1.6
log
@Remove a pile of (obviously unused) #ifdef SYSV and BSD41 and BSD42
code that catches lots of signals, and then re-enters curses... before
exiting.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.5 2002/01/16 01:28:54 millert Exp $	*/
d46 1
a46 3
getstring(cp, mx)
	char   *cp;
	int     mx;
d120 1
a120 2
more(where)
	int     where;
d152 1
a152 1
infloat()
d190 1
a190 1
inputoption()
d233 1
a233 1
interrupt()
d307 1
a307 3
getanswer(choices, def)
	char   *choices;
	bool    def;
d405 1
a405 2
catchalarm(dummy)
	int dummy;
@


1.5
log
@Use the volatile specifier to fix warnings about variables being
clobbered by longjmp / vfork instead of the gcc "(void)&foo;" hack.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.4 1998/11/29 19:56:57 pjanzen Exp $	*/
a243 7
#ifdef SYS3
	signal(SIGINT, SIG_IGN);
#endif
#ifdef SYS5
	signal(SIGINT, SIG_IGN);
#endif

a273 7
#ifdef SYS3
	signal(SIGINT, interrupt);
#endif
#ifdef SYS5
	signal(SIGINT, interrupt);
#endif

a338 3
#ifdef BSD41
			sigset(SIGALRM, catchalarm);
#else
a339 1
#endif
@


1.4
log
@NetBSD merge (mainly -Wall related)
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.3 1998/07/10 09:46:46 downsj Exp $	*/
d328 3
a330 3
	int     ch;		/* input */
	int     loop;		/* counter */
	int     oldx, oldy;	/* original coordinates on screen */
a334 3
#if __GNUC__
	(void)&loop;		/* XXX quiet gcc */
#endif
@


1.3
log
@Ok, so I was bored and couldn't sleep...

Make this sucker work with decent terminal settings.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 1
d47 2
a48 2
register char	*cp;
register int	mx;
d50 8
a57 8
register char	*inptr;		/* pointer into string for next string */
int	x, y;			/* original x, y coordinates on screen */
int	ch;			/* input */

    getyx(stdscr, y, x);	/* get coordinates on screen */
    inptr = cp;
    *inptr = '\0';		/* clear string to start */
    --mx;			/* reserve room in string for nul terminator */
d59 2
a60 2
    do
	/* get characters and process */
d62 28
a89 28
	if (Echo)
	    mvaddstr(y, x, cp);	/* print string on screen */
	clrtoeol();		/* clear any data after string */
	refresh();		/* update screen */

	ch = getchar();		/* get character */

	switch (ch)
	    {
	    case CH_NEWLINE:	/* terminate string */
	    case CH_RETURN:
		break;

	    case CH_REDRAW:	/* redraw screen */
		clearok(stdscr, TRUE);
		continue;

	    default:		/* put data in string */
		if (ch == Ch_Erase) {	/* back up one character */
		    if (inptr > cp)
			--inptr;
		    break;
		} else if (ch == Ch_Kill) { /* back up to original location */
		    inptr = cp;
		    break;
		} else if (isprint(ch) || Wizard) {
		    /* printing char; put in string */
		    *inptr++ = ch;
a90 1
	    }
d92 1
a92 1
	*inptr = '\0';		/* terminate string */
d94 1
a94 1
    while (ch != CH_NEWLINE && ch != CH_RETURN && inptr < cp + mx);
d121 1
d123 1
a123 1
int	where;
d125 2
a126 2
    mvaddstr(where, 0, "-- more --");
    getanswer(" ", FALSE);
d157 1
a157 1
double	result;		/* return value */
d159 4
a162 4
    getstring(Databuf, SZ_DATABUF);
    if (sscanf(Databuf, "%lf", &result) < 1)
	/* no valid number entered */
	result = 0.0;
d164 1
a164 1
    return(result);
d192 1
d195 1
a195 1
    ++Player.p_age;		/* increase age */
d197 5
a201 5
    if (Player.p_ring.ring_type != R_SPOILED)
	/* ring ok */
	return(getanswer("T ", TRUE));
    else
	/* bad ring */
d203 2
a204 2
	getanswer(" ", TRUE);
	return((int) ROLL(0.0, 5.0) + '0');
d221 2
a222 3
/	getgid(), signal(), getenv(), wclear(), setuid(), getuid(), setgid(), 
/	crmode(), clearok(), waddstr(), cleanup(), wrefresh(), leavegame(), 
/	getanswer()
d235 1
d238 5
a242 5
char	line[81];		/* a place to store data already on screen */
register int	loop;		/* counter */
int	x, y;			/* coordinates on screen */
int	ch;			/* input */
unsigned	savealarm;	/* to save alarm value */
d245 1
a245 1
    signal(SIGINT, SIG_IGN);
d248 1
a248 1
    signal(SIGINT, SIG_IGN);
d251 1
a251 1
    savealarm = alarm(0);		/* turn off any alarms */
d253 1
a253 1
    getyx(stdscr, y, x);		/* save cursor location */
d255 3
a257 4
    for (loop = 0; loop < 80; ++loop)	/* save line on screen */
	{
	move(4, loop);
	line[loop] = inch();
d259 1
a259 1
    line[80] = '\0';			/* nul terminate */
d261 2
a262 2
    if (Player.p_status == S_INBATTLE || Player.p_status == S_MONSTER)
	/* in midst of fighting */
d264 11
a274 13
	mvaddstr(4, 0, "Quitting now will automatically kill your character.  Still want to ? ");
	ch = getanswer("NY", FALSE);
	if (ch == 'Y')
	    death("Bailing out");
	    /*NOTREACHED*/
	}
    else
	{
	mvaddstr(4, 0, "Do you really want to quit ? ");
	ch = getanswer("NY", FALSE);
	if (ch == 'Y')
	    leavegame();
	    /*NOTREACHED*/
d277 3
a279 3
    mvaddstr(4, 0, line); 		/* restore data on screen */
    move(y, x);				/* restore cursor */
    refresh();
d282 1
a282 1
    signal(SIGINT, interrupt);
d285 1
a285 1
    signal(SIGINT, interrupt);
d288 1
a288 1
    alarm(savealarm);			/* restore alarm */
d323 1
d325 2
a326 2
char	*choices;
bool	def;
d328 3
a330 3
int	ch;			/* input */
int	loop;			/* counter */
int	oldx, oldy;		/* original coordinates on screen */
d332 2
a333 2
    getyx(stdscr, oldy, oldx);
    alarm(0);				/* make sure alarm is off */
d335 6
a340 2
    for (loop = 3; loop; --loop)
	/* try for 3 times */
d342 14
a355 15
	if (setjmp(Timeoenv) != 0)
	    /* timed out waiting for response */
	    {
	    if (def || loop <= 1)
		/* return default answer */
		break;
	    else
		/* prompt, and try again */
		goto YELL;
	    }
	else
	    /* wait for response */
	    {
	    clrtoeol();
	    refresh();
d357 1
a357 1
	    sigset(SIGALRM, catchalarm);
d359 1
a359 1
	    signal(SIGALRM, catchalarm);
d361 39
a399 43
	    /* set timeout */
	    if (Timeout)
		alarm(7);		/* short */
	    else
		alarm(600);		/* long */

	    ch = getchar();

	    alarm(0);			/* turn off timeout */

	    if (ch < 0)
		/* caught some signal */
		{
		++loop;
		continue;
		}
	    else if (ch == CH_REDRAW)
		/* redraw screen */
		{
		clearok(stdscr, TRUE);	/* force clear screen */
		++loop;			/* don't count this input */
		continue;
		}
	    else if (Echo)
		{
		addch(ch);		/* echo character */
		refresh();
		}

	    if (islower(ch))
		/* convert to upper case */
		ch = toupper(ch);

	    if (def || strchr(choices, ch) != NULL)
		/* valid choice */
		return(ch);
	    else if (!def && loop > 1)
		/* bad choice; prompt, and try again */
		{
YELL:		mvprintw(oldy + 1, 0, "Please choose one of : [%s]\n", choices);
		move(oldy, oldx);
		clrtoeol();
		continue;
a400 4
	    else
		/* return default answer */
		break;
	    }
d403 1
a403 1
    return(*choices);
d431 2
a432 1
catchalarm()
d434 1
a434 1
    longjmp(Timeoenv, 1);
@


1.2
log
@fixed the "/* in comments" problem.
@
text
@d1 1
a69 9
	    case CH_ERASE:	/* back up one character */
		if (inptr > cp)
		    --inptr;
		break;

	    case CH_KILL:	/* back up to original location */
		inptr = cp;
		break;

d71 1
d79 8
a86 1
		if (ch >= ' ' || Wizard)
d89 1
d94 1
a94 1
    while (ch != CH_NEWLINE && inptr < cp + mx);
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
/************************************************************************/
d118 1
a118 1
/************************************************************************/
d150 1
a150 1
/************************************************************************/
d188 1
a188 1
/************************************************************************/
d231 1
a231 1
/************************************************************************/
d321 1
a321 1
/************************************************************************/
d432 1
a432 1
/************************************************************************/
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
