head	1.10;
access;
symbols
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.7.0.22
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.14
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.18
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.16
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.12
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.10
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.8
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.6
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.6.0.30
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.26
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.28
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.24
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.22
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.20
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.18
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.16
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.14
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.4.0.12
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.10
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.6
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.08.27.02.00.10;	author guenther;	state Exp;
branches;
next	1.9;
commitid	usv2ULh2hPPt9BPj;

1.9
date	2016.01.06.14.28.09;	author mestre;	state Exp;
branches;
next	1.8;
commitid	A5CGsPmxC2qOSHvN;

1.8
date	2016.01.06.09.39.51;	author tb;	state Exp;
branches;
next	1.7;
commitid	n1ecS9whrSfppP1l;

1.7
date	2010.12.15.06.40.39;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.25.21.37.47;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.06.18.50.38;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.29.07.39.43;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	98.11.29.19.56.56;	author pjanzen;	state Exp;
branches;
next	1.2;

1.2
date	96.05.26.07.23.11;	author fn;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.10;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Pull in <time.h> for time() and perhaps other functions

ok deraadt@@
@
text
@/*	$OpenBSD: gamesupport.c,v 1.9 2016/01/06 14:28:09 mestre Exp $	*/
/*	$NetBSD: gamesupport.c,v 1.3 1995/04/24 12:24:28 cgd Exp $	*/

/*
 * gamesupport.c - auxiliary routines for support of Phantasia
 */

#include <curses.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#include "pathnames.h"
#include "phantdefs.h"
#include "phantglobs.h"

/************************************************************************
/
/ FUNCTION NAME: changestats()
/
/ FUNCTION: examine/change statistics for a player
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS:
/	bool ingameflag - set if called while playing game (Wizard only)
/
/ RETURN VALUE: none
/
/ MODULES CALLED: freerecord(), writerecord(), descrstatus(), truncstring(), 
/	time(), more(), wmove(), wclear(), strcmp(), printw(), strlcpy(), 
/	infloat(), waddstr(), cleanup(), findname(), userlist(), mvprintw(), 
/	localtime(), getanswer(), descrtype(), getstring()
/
/ GLOBAL INPUTS: LINES, *Login, Other, Wizard, Player, *stdscr, Databuf[], 
/	Fileloc
/
/ GLOBAL OUTPUTS: Echo
/
/ DESCRIPTION:
/	Prompt for player name to examine/change.
/	If the name is NULL, print a list of all players.
/	If we are called from within the game, check for the
/	desired name being the same as the current player's name.
/	Only the 'Wizard' may alter players.
/	Items are changed only if a non-zero value is specified.
/	To change an item to 0, use 0.1; it will be truncated later.
/
/	Players may alter their names and passwords, if the following
/	are true:
/	    - current login matches the character's logins
/	    - the password is known
/	    - the player is not in the middle of the game (ingameflag == FALSE)
/
/	The last condition is imposed for two reasons:
/	    - the game could possibly get a bit hectic if a player were
/	      continually changing his/her name
/	    - another player structure would be necessary to check for names
/	      already in use
/
*************************************************************************/

void
changestats(bool ingameflag)
{
	static char flag[2] =	/* for printing values of bools */
	{'F', 'T'};
	struct player *playerp;	/* pointer to structure to alter */
	char   *prompt;		/* pointer to prompt string */
	int     c;		/* input */
	int     today;		/* day of year of today */
	int     temp;		/* temporary variable */
	long    loc;		/* location in player file */
	time_t  now;		/* time now */
	double  dtemp;		/* temporary variable */
	bool   *bptr;		/* pointer to bool item to change */
	double *dptr;		/* pointer to double item to change */
	short  *sptr;		/* pointer to short item to change */

	clear();

	for (;;)
		/* get name of player to examine/alter */
	{
		mvaddstr(5, 0, "Which character do you want to look at ? ");
		getstring(Databuf, SZ_DATABUF);
		truncstring(Databuf);

		if (Databuf[0] == '\0')
			userlist(ingameflag);
		else
			break;
	}

	loc = -1L;

	if (!ingameflag)
		/* use 'Player' structure */
		playerp = &Player;
	else
		if (strcmp(Databuf, Player.p_name) == 0)
			/* alter/examine current player */
		{
			playerp = &Player;
			loc = Fileloc;
		} else
			/* use 'Other' structure */
			playerp = &Other;

	/* find player on file */
	if (loc < 0L && (loc = findname(Databuf, playerp)) < 0L)
		/* didn't find player */
	{
		clear();
		mvaddstr(11, 0, "Not found.");
		return;
	}
	time(&now);
	today = localtime(&now)->tm_yday;

	clear();

	for (;;)
		/* print player structure, and prompt for action */
	{
		mvprintw(0, 0, "A:Name         %s\n", playerp->p_name);

		if (Wizard)
			printw("B:Password     %s\n", playerp->p_password);
		else
			addstr("B:Password     XXXXXXXX\n");

		printw(" :Login        %s\n", playerp->p_login);

		printw("C:Experience   %.0f\n", playerp->p_experience);
		printw("D:Level        %.0f\n", playerp->p_level);
		printw("E:Strength     %.0f\n", playerp->p_strength);
		printw("F:Sword        %.0f\n", playerp->p_sword);
		printw(" :Might        %.0f\n", playerp->p_might);
		printw("G:Energy       %.0f\n", playerp->p_energy);
		printw("H:Max-Energy   %.0f\n", playerp->p_maxenergy);
		printw("I:Shield       %.0f\n", playerp->p_shield);
		printw("J:Quickness    %.0f\n", playerp->p_quickness);
		printw("K:Quicksilver  %.0f\n", playerp->p_quksilver);
		printw(" :Speed        %.0f\n", playerp->p_speed);
		printw("L:Magic Level  %.0f\n", playerp->p_magiclvl);
		printw("M:Mana         %.0f\n", playerp->p_mana);
		printw("N:Brains       %.0f\n", playerp->p_brains);

		if (Wizard || playerp->p_specialtype != SC_VALAR)
			mvaddstr(0, 40, descrstatus(playerp));

		mvprintw(1, 40, "O:Poison       %0.3f\n", playerp->p_poison);
		mvprintw(2, 40, "P:Gold         %.0f\n", playerp->p_gold);
		mvprintw(3, 40, "Q:Gem          %.0f\n", playerp->p_gems);
		mvprintw(4, 40, "R:Sin          %0.3f\n", playerp->p_sin);
		if (Wizard) {
			mvprintw(5, 40, "S:X-coord      %.0f\n", playerp->p_x);
			mvprintw(6, 40, "T:Y-coord      %.0f\n", playerp->p_y);
		} else {
			mvaddstr(5, 40, "S:X-coord      ?\n");
			mvaddstr(6, 40, "T:Y-coord      ?\n");
		}

		mvprintw(7, 40, "U:Age          %ld\n", playerp->p_age);
		mvprintw(8, 40, "V:Degenerated  %d\n", playerp->p_degenerated);

		mvprintw(9, 40, "W:Type         %d (%s)\n",
		    playerp->p_type, descrtype(playerp, FALSE) + 1);
		mvprintw(10, 40, "X:Special Type %d\n", playerp->p_specialtype);
		mvprintw(11, 40, "Y:Lives        %d\n", playerp->p_lives);
		mvprintw(12, 40, "Z:Crowns       %d\n", playerp->p_crowns);
		mvprintw(13, 40, "0:Charms       %d\n", playerp->p_charms);
		mvprintw(14, 40, "1:Amulets      %d\n", playerp->p_amulets);
		mvprintw(15, 40, "2:Holy Water   %d\n", playerp->p_holywater);

		temp = today - playerp->p_lastused;
		if (temp < 0)
			/* last year */
			temp += 365;
		mvprintw(16, 40, "3:Lastused     %d  (%d)\n", playerp->p_lastused, temp);

		mvprintw(18, 8, "4:Palantir %c  5:Blessing %c  6:Virgin %c  7:Blind %c",
		    flag[(int)playerp->p_palantir],
		    flag[(int)playerp->p_blessing],
		    flag[(int)playerp->p_virgin],
		    flag[(int)playerp->p_blindness]);

		if (!Wizard)
			mvprintw(19, 8, "8:Ring    %c",
			    flag[playerp->p_ring.ring_type != R_NONE]);
		else
			mvprintw(19, 8, "8:Ring    %d  9:Duration %d",
			    playerp->p_ring.ring_type, playerp->p_ring.ring_duration);

		if (!Wizard
		/* not wizard */
		    && (ingameflag || strcmp(Login, playerp->p_login) != 0))
			/* in game or not examining own character */
		{
			if (ingameflag) {
				more(LINES - 1);
				clear();
				return;
			} else
				cleanup(TRUE);
		}
		mvaddstr(20, 0, "!:Quit       ?:Delete");
		mvaddstr(21, 0, "What would you like to change ? ");

		if (Wizard)
			c = getanswer(" ", TRUE);
		else
			/* examining own player; allow to change name and
			 * password */
			c = getanswer("!BA", FALSE);

		switch (c) {
		case 'A':	/* change name */
		case 'B':	/* change password */
			if (!Wizard)
				/* prompt for password */
			{
				mvaddstr(23, 0, "Password ? ");
				Echo = FALSE;
				getstring(Databuf, 9);
				Echo = TRUE;
				if (strcmp(Databuf, playerp->p_password) != 0)
					continue;
			}
			if (c == 'A')
				/* get new name */
			{
				mvaddstr(23, 0, "New name: ");
				getstring(Databuf, SZ_NAME);
				truncstring(Databuf);
				if (Databuf[0] != '\0')
					if (Wizard || findname(Databuf, &Other) < 0L)
						strlcpy(playerp->p_name, Databuf,
						    sizeof playerp->p_name);
			} else
				/* get new password */
			{
				if (!Wizard)
					Echo = FALSE;

				do
					/* get two copies of new password
					 * until they match */
				{
					/* get first copy */
					mvaddstr(23, 0, "New password ? ");
					getstring(Databuf, SZ_PASSWORD);
					if (Databuf[0] == '\0')
						break;

					/* get second copy */
					mvaddstr(23, 0, "One more time ? ");
					getstring(playerp->p_password, SZ_PASSWORD);
				}
				while (strcmp(playerp->p_password, Databuf) != 0);

				Echo = TRUE;
			}

			continue;

		case 'C':	/* change experience */
			prompt = "experience";
			dptr = &playerp->p_experience;
			goto DALTER;

		case 'D':	/* change level */
			prompt = "level";
			dptr = &playerp->p_level;
			goto DALTER;

		case 'E':	/* change strength */
			prompt = "strength";
			dptr = &playerp->p_strength;
			goto DALTER;

		case 'F':	/* change swords */
			prompt = "sword";
			dptr = &playerp->p_sword;
			goto DALTER;

		case 'G':	/* change energy */
			prompt = "energy";
			dptr = &playerp->p_energy;
			goto DALTER;

		case 'H':	/* change maximum energy */
			prompt = "max energy";
			dptr = &playerp->p_maxenergy;
			goto DALTER;

		case 'I':	/* change shields */
			prompt = "shield";
			dptr = &playerp->p_shield;
			goto DALTER;

		case 'J':	/* change quickness */
			prompt = "quickness";
			dptr = &playerp->p_quickness;
			goto DALTER;

		case 'K':	/* change quicksilver */
			prompt = "quicksilver";
			dptr = &playerp->p_quksilver;
			goto DALTER;

		case 'L':	/* change magic */
			prompt = "magic level";
			dptr = &playerp->p_magiclvl;
			goto DALTER;

		case 'M':	/* change mana */
			prompt = "mana";
			dptr = &playerp->p_mana;
			goto DALTER;

		case 'N':	/* change brains */
			prompt = "brains";
			dptr = &playerp->p_brains;
			goto DALTER;

		case 'O':	/* change poison */
			prompt = "poison";
			dptr = &playerp->p_poison;
			goto DALTER;

		case 'P':	/* change gold */
			prompt = "gold";
			dptr = &playerp->p_gold;
			goto DALTER;

		case 'Q':	/* change gems */
			prompt = "gems";
			dptr = &playerp->p_gems;
			goto DALTER;

		case 'R':	/* change sin */
			prompt = "sin";
			dptr = &playerp->p_sin;
			goto DALTER;

		case 'S':	/* change x coord */
			prompt = "x";
			dptr = &playerp->p_x;
			goto DALTER;

		case 'T':	/* change y coord */
			prompt = "y";
			dptr = &playerp->p_y;
			goto DALTER;

		case 'U':	/* change age */
			mvprintw(23, 0, "age = %ld; age = ", playerp->p_age);
			dtemp = infloat();
			if (dtemp != 0.0)
				playerp->p_age = (long) dtemp;
			continue;

		case 'V':	/* change degen */
			mvprintw(23, 0, "degen = %d; degen = ", playerp->p_degenerated);
			dtemp = infloat();
			if (dtemp != 0.0)
				playerp->p_degenerated = (int) dtemp;
			continue;

		case 'W':	/* change type */
			prompt = "type";
			sptr = &playerp->p_type;
			goto SALTER;

		case 'X':	/* change special type */
			prompt = "special type";
			sptr = &playerp->p_specialtype;
			goto SALTER;

		case 'Y':	/* change lives */
			prompt = "lives";
			sptr = &playerp->p_lives;
			goto SALTER;

		case 'Z':	/* change crowns */
			prompt = "crowns";
			sptr = &playerp->p_crowns;
			goto SALTER;

		case '0':	/* change charms */
			prompt = "charm";
			sptr = &playerp->p_charms;
			goto SALTER;

		case '1':	/* change amulet */
			prompt = "amulet";
			sptr = &playerp->p_amulets;
			goto SALTER;

		case '2':	/* change holy water */
			prompt = "holy water";
			sptr = &playerp->p_holywater;
			goto SALTER;

		case '3':	/* change last-used */
			prompt = "last-used";
			sptr = &playerp->p_lastused;
			goto SALTER;

		case '4':	/* change palantir */
			prompt = "palantir";
			bptr = &playerp->p_palantir;
			goto BALTER;

		case '5':	/* change blessing */
			prompt = "blessing";
			bptr = &playerp->p_blessing;
			goto BALTER;

		case '6':	/* change virgin */
			prompt = "virgin";
			bptr = &playerp->p_virgin;
			goto BALTER;

		case '7':	/* change blindness */
			prompt = "blindness";
			bptr = &playerp->p_blindness;
			goto BALTER;

		case '8':	/* change ring type */
			prompt = "ring-type";
			sptr = &playerp->p_ring.ring_type;
			goto SALTER;

		case '9':	/* change ring duration */
			prompt = "ring-duration";
			sptr = &playerp->p_ring.ring_duration;
			goto SALTER;

		case '!':	/* quit, update */
			if (Wizard &&
			    (!ingameflag || playerp != &Player))
				/* turn off status if not modifying self */
			{
				playerp->p_status = S_OFF;
				playerp->p_tampered = T_OFF;
			}
			writerecord(playerp, loc);
			clear();
			return;

		case '?':	/* delete player */
			if (ingameflag && playerp == &Player)
				/* cannot delete self */
				continue;

			freerecord(playerp, loc);
			clear();
			return;

		default:
			continue;
		}
DALTER:
		mvprintw(23, 0, "%s = %f; %s = ", prompt, *dptr, prompt);
		dtemp = infloat();
		if (dtemp != 0.0)
			*dptr = dtemp;
		continue;

SALTER:
		mvprintw(23, 0, "%s = %d; %s = ", prompt, *sptr, prompt);
		dtemp = infloat();
		if (dtemp != 0.0)
			*sptr = (short) dtemp;
		continue;

BALTER:
		mvprintw(23, 0, "%s = %c; %s = ", prompt, flag[(int)*bptr],
		    prompt);
		c = getanswer("\nTF", TRUE);
		if (c == 'T')
			*bptr = TRUE;
		else
			if (c == 'F')
				*bptr = FALSE;
		continue;
	}
}
/**/
/************************************************************************
/
/ FUNCTION NAME: monstlist()
/
/ FUNCTION: print a monster listing
/
/ AUTHOR: E. A. Estes, 2/27/86
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: puts(), fread(), fseek(), printf()
/
/ GLOBAL INPUTS: Curmonster, *Monstfp
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	Read monster file, and print a monster listing on standard output.
/
*************************************************************************/

void
monstlist(void)
{
	int     count = 0;	/* count in file */

	puts(" #)  Name                 Str  Brain  Quick  Energy  Exper  Treas  Type  Flock%\n");
	fseek(Monstfp, 0L, SEEK_SET);
	while (fread(&Curmonster, SZ_MONSTERSTRUCT, 1, Monstfp) == 1)
		printf("%2d)  %-20.20s%4.0f   %4.0f     %2.0f   %5.0f  %5.0f     %2d    %2d     %3.0f\n", count++,
		    Curmonster.m_name, Curmonster.m_strength, Curmonster.m_brains,
		    Curmonster.m_speed, Curmonster.m_energy, Curmonster.m_experience,
		    Curmonster.m_treasuretype, Curmonster.m_type, Curmonster.m_flock);
}
/**/
/************************************************************************
/
/ FUNCTION NAME: scorelist()
/
/ FUNCTION: print player score board
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: fread(), fopen(), printf(), fclose()
/
/ GLOBAL INPUTS: 
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	Read the scoreboard file and print the contents.
/
*************************************************************************/

void
scorelist(void)
{
	struct scoreboard sbuf;	/* for reading entries */
	FILE   *fp;		/* to open the file */

	if ((fp = fopen(_PATH_SCORE, "r")) != NULL) {
		while (fread(&sbuf, SZ_SCORESTRUCT, 1, fp) == 1)
			printf("%-20s   (%-9s)  Level: %6.0f  Type: %s\n",
			    sbuf.sb_name, sbuf.sb_login, sbuf.sb_level, sbuf.sb_type);
		fclose(fp);
	}
}
/**/
/************************************************************************
/
/ FUNCTION NAME: activelist()
/
/ FUNCTION: print list of active players to standard output
/
/ AUTHOR: E. A. Estes, 3/7/86
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: descrstatus(), fread(), fseek(), printf(), descrtype()
/
/ GLOBAL INPUTS: Other, *Playersfp
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	Read player file, and print list of active records to standard output.
/
*************************************************************************/

void
activelist(void)
{
	fseek(Playersfp, 0L, SEEK_SET);
	printf("Current characters on file are:\n\n");

	while (fread(&Other, SZ_PLAYERSTRUCT, 1, Playersfp) == 1)
		if (Other.p_status != S_NOTUSED)
			printf("%-20s   (%-9s)  Level: %6.0f  %s  (%s)\n",
			    Other.p_name, Other.p_login, Other.p_level,
			    descrtype(&Other, FALSE), descrstatus(&Other));

}
/**/
/************************************************************************
/
/ FUNCTION NAME: purgeoldplayers()
/
/ FUNCTION: purge inactive players from player file
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: freerecord(), time(), fread(), fseek(), localtime()
/
/ GLOBAL INPUTS: Other, *Playersfp
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	Delete characters which have not been used with the last
/	three weeks.
/
*************************************************************************/

void
purgeoldplayers(void)
{
	int     today;		/* day of year for today */
	int     daysold;	/* how many days since the character has been
				 * used */
	time_t  ltime;		/* time in seconds */
	long    loc = 0L;	/* location in file */

	time(&ltime);
	today = localtime(&ltime)->tm_yday;

	for (;;) {
		fseek(Playersfp, loc, SEEK_SET);
		if (fread(&Other, SZ_PLAYERSTRUCT, 1, Playersfp) != 1)
			break;

		daysold = today - Other.p_lastused;
		if (daysold < 0)
			daysold += 365;

		if (daysold > N_DAYSOLD)
			/* player hasn't been used in a while; delete */
			freerecord(&Other, loc);

		loc += SZ_PLAYERSTRUCT;
	}
}
/**/
/************************************************************************
/
/ FUNCTION NAME: enterscore()
/
/ FUNCTION: enter player into scoreboard
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: fread(), fseek(), fopen(), error(), strcmp(), fclose(), 
/	strlcpy(), fwrite(), descrtype()
/
/ GLOBAL INPUTS: Player
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	The scoreboard keeps track of the highest character on a
/	per-login basis.
/	Search the scoreboard for an entry for the current login,
/	if an entry is found, and it is lower than the current player,
/	replace it, otherwise create an entry.
/
*************************************************************************/

void
enterscore(void)
{
	struct scoreboard sbuf;	/* buffer to read in scoreboard entries */
	FILE   *fp;		/* to open scoreboard file */
	long    loc = 0L;	/* location in scoreboard file */
	bool    found = FALSE;	/* set if we found an entry for this login */

	if ((fp = fopen(_PATH_SCORE, "r+")) != NULL) {
		while (fread(&sbuf, SZ_SCORESTRUCT, 1, fp) == 1)
			if (strcmp(Player.p_login, sbuf.sb_login) == 0) {
				found = TRUE;
				break;
			} else
				loc += SZ_SCORESTRUCT;
	} else {
		error(_PATH_SCORE);
	}

	/*
         * At this point, 'loc' will either indicate a point beyond
         * the end of file, or the place where the previous entry
         * was found.
         */

	if ((!found) || Player.p_level > sbuf.sb_level)
		/* put new entry in for this login */
	{
		strlcpy(sbuf.sb_login, Player.p_login,
		    sizeof sbuf.sb_login);
		strlcpy(sbuf.sb_name, Player.p_name,
		    sizeof sbuf.sb_name);
		sbuf.sb_level = Player.p_level;
		strlcpy(sbuf.sb_type, descrtype(&Player, TRUE),
		    sizeof sbuf.sb_type);
	}
	/* update entry */
	fseek(fp, loc, SEEK_SET);
	fwrite(&sbuf, SZ_SCORESTRUCT, 1, fp);
	fclose(fp);
}
@


1.9
log
@Remove unnecessary header files from phantasia(6)

Lesson learnt: don't include an header sorted alphabetically just because. The
external definition of variables was done on phantglobs.h but their declaration
was on phantstruct.h and therefore the latter must be included before the
former. It's easier to just include phantstruct.h inside phantglobs.h since it
always need it.

With help and OK from tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gamesupport.c,v 1.8 2016/01/06 09:39:51 tb Exp $	*/
d11 1
@


1.8
log
@Ansify the bulk of phantasia.  No binary change on amd64.  Based
on an older diff by mestre.

ok mestre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gamesupport.c,v 1.7 2010/12/15 06:40:39 tedu Exp $	*/
d8 7
a14 1
#include "include.h"
@


1.7
log
@as of 1989, fread/fwrite take void *, so there's no need to cast to char *.
@
text
@d1 1
a1 1
/*	$OpenBSD: gamesupport.c,v 1.6 2003/04/25 21:37:47 deraadt Exp $	*/
d57 1
a57 2
changestats(ingameflag)
	bool    ingameflag;
a199 1
			/* NOTREACHED */
d510 1
a510 1
monstlist()
d547 1
a547 1
scorelist()
d584 1
a584 1
activelist()
d622 1
a622 1
purgeoldplayers()
d679 1
a679 1
enterscore()
a694 1
		/* NOTREACHED */
@


1.6
log
@comment repair
@
text
@d1 1
a1 1
/*	$OpenBSD: gamesupport.c,v 1.5 2003/04/06 18:50:38 deraadt Exp $	*/
d518 1
a518 1
	while (fread((char *) &Curmonster, SZ_MONSTERSTRUCT, 1, Monstfp) == 1)
d555 1
a555 1
		while (fread((char *) &sbuf, SZ_SCORESTRUCT, 1, fp) == 1)
d591 1
a591 1
	while (fread((char *) &Other, SZ_PLAYERSTRUCT, 1, Playersfp) == 1)
d637 1
a637 1
		if (fread((char *) &Other, SZ_PLAYERSTRUCT, 1, Playersfp) != 1)
d689 1
a689 1
		while (fread((char *) &sbuf, SZ_SCORESTRUCT, 1, fp) == 1)
d719 1
a719 1
	fwrite((char *) &sbuf, SZ_SCORESTRUCT, 1, fp);
@


1.5
log
@2451 lines of strdup/sprintf/strcpy whacking.  mostly ok'd by pjanzen
already, but he may have later changes to make still.
@
text
@d1 1
a1 1
/*	$OpenBSD: gamesupport.c,v 1.4 2000/06/29 07:39:43 pjanzen Exp $	*/
d24 1
a24 1
/	time(), more(), wmove(), wclear(), strcmp(), printw(), strcpy(), 
d665 1
a665 1
/	strcpy(), fwrite(), descrtype()
@


1.4
log
@use SEEK_SET; improve an error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: gamesupport.c,v 1.3 1998/11/29 19:56:56 pjanzen Exp $	*/
d234 2
a235 1
						strcpy(playerp->p_name, Databuf);
d709 4
a712 2
		strcpy(sbuf.sb_login, Player.p_login);
		strcpy(sbuf.sb_name, Player.p_name);
d714 2
a715 1
		strcpy(sbuf.sb_type, descrtype(&Player, TRUE));
@


1.3
log
@NetBSD merge (mainly -Wall related)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d516 1
a516 1
	fseek(Monstfp, 0L, 0);
d587 1
a587 1
	fseek(Playersfp, 0L, 0);
d635 1
a635 1
		fseek(Playersfp, loc, 0);
d714 1
a714 1
	fseek(fp, loc, 0);
@


1.2
log
@fixed the "/* in comments" problem.
@
text
@d1 1
d56 1
d58 1
a58 1
bool	ingameflag;
d60 1
a60 1
static char	flag[2] = /* for printing values of bools */
d62 11
a72 11
register struct player	*playerp;/* pointer to structure to alter */
register char	*prompt;	/* pointer to prompt string */
int	c;			/* input */
int	today;			/* day of year of today */
int	temp;			/* temporary variable */
long	loc;			/* location in player file */
time_t	now;			/* time now */
double	dtemp;			/* temporary variable */
bool	*bptr;			/* pointer to bool item to change */
double	*dptr;			/* pointer to double item to change */
short	*sptr;			/* pointer to short item to change */
d74 1
a74 1
    clear();
d76 2
a77 2
    for (;;)
	/* get name of player to examine/alter */
d79 3
a81 3
	mvaddstr(5, 0, "Which character do you want to look at ? ");
	getstring(Databuf, SZ_DATABUF);
	truncstring(Databuf);
d83 4
a86 4
	if (Databuf[0] == '\0')
	    userlist(ingameflag);
	else
	    break;
d89 1
a89 1
    loc = -1L;
d91 16
a106 5
    if (!ingameflag)
	/* use 'Player' structure */
	playerp = &Player;
    else if (strcmp(Databuf, Player.p_name) == 0)
	/* alter/examine current player */
d108 3
a110 2
	playerp = &Player;
	loc = Fileloc;
d112 3
a114 8
    else
	/* use 'Other' structure */
	playerp = &Other;

    /* find player on file */
    if (loc < 0L && (loc = findname(Databuf, playerp)) < 0L)
	/* didn't find player */
	{
a115 8
	mvaddstr(11, 0, "Not found.");
	return;
	}

    time(&now);
    today = localtime(&now)->tm_yday;

    clear();
d117 2
a118 2
    for (;;)
	/* print player structure, and prompt for action */
d120 1
a120 1
	mvprintw(0, 0,"A:Name         %s\n", playerp->p_name);
d122 4
a125 4
	if (Wizard)
	    printw("B:Password     %s\n", playerp->p_password);
	else
	    addstr("B:Password     XXXXXXXX\n");
d127 1
a127 1
	printw(" :Login        %s\n", playerp->p_login);
d129 28
a156 74
	printw("C:Experience   %.0f\n", playerp->p_experience);
	printw("D:Level        %.0f\n", playerp->p_level);
	printw("E:Strength     %.0f\n", playerp->p_strength);
	printw("F:Sword        %.0f\n", playerp->p_sword);
	printw(" :Might        %.0f\n", playerp->p_might);
	printw("G:Energy       %.0f\n", playerp->p_energy);
	printw("H:Max-Energy   %.0f\n", playerp->p_maxenergy);
	printw("I:Shield       %.0f\n", playerp->p_shield);
	printw("J:Quickness    %.0f\n", playerp->p_quickness);
	printw("K:Quicksilver  %.0f\n", playerp->p_quksilver);
	printw(" :Speed        %.0f\n", playerp->p_speed);
	printw("L:Magic Level  %.0f\n", playerp->p_magiclvl);
	printw("M:Mana         %.0f\n", playerp->p_mana);
	printw("N:Brains       %.0f\n", playerp->p_brains);

	if (Wizard || playerp->p_specialtype != SC_VALAR)
	    mvaddstr(0, 40, descrstatus(playerp));

	mvprintw(1, 40, "O:Poison       %0.3f\n", playerp->p_poison);
	mvprintw(2, 40, "P:Gold         %.0f\n", playerp->p_gold);
	mvprintw(3, 40, "Q:Gem          %.0f\n", playerp->p_gems);
	mvprintw(4, 40, "R:Sin          %0.3f\n", playerp->p_sin);
	if (Wizard)
	    {
	    mvprintw(5, 40, "S:X-coord      %.0f\n", playerp->p_x);
	    mvprintw(6, 40, "T:Y-coord      %.0f\n", playerp->p_y);
	    }
	else
	    {
	    mvaddstr(5, 40, "S:X-coord      ?\n");
	    mvaddstr(6, 40, "T:Y-coord      ?\n");
	    }

	mvprintw(7, 40, "U:Age          %ld\n", playerp->p_age);
	mvprintw(8, 40, "V:Degenerated  %d\n", playerp->p_degenerated);

	mvprintw(9, 40, "W:Type         %d (%s)\n",
	    playerp->p_type, descrtype(playerp, FALSE) + 1);
	mvprintw(10, 40, "X:Special Type %d\n", playerp->p_specialtype);
	mvprintw(11, 40, "Y:Lives        %d\n", playerp->p_lives);
	mvprintw(12, 40, "Z:Crowns       %d\n", playerp->p_crowns);
	mvprintw(13, 40, "0:Charms       %d\n", playerp->p_charms);
	mvprintw(14, 40, "1:Amulets      %d\n", playerp->p_amulets);
	mvprintw(15, 40, "2:Holy Water   %d\n", playerp->p_holywater);

	temp = today - playerp->p_lastused;
	if (temp < 0)
	    /* last year */
	    temp += 365;
	mvprintw(16, 40, "3:Lastused     %d  (%d)\n", playerp->p_lastused,  temp);

	mvprintw(18, 8, "4:Palantir %c  5:Blessing %c  6:Virgin %c  7:Blind %c",
	    flag[playerp->p_palantir],
	    flag[playerp->p_blessing],
	    flag[playerp->p_virgin],
	    flag[playerp->p_blindness]);

	if (!Wizard)
	    mvprintw(19, 8, "8:Ring    %c",
		flag[playerp->p_ring.ring_type != R_NONE]);
	else
	    mvprintw(19, 8, "8:Ring    %d  9:Duration %d",
		playerp->p_ring.ring_type, playerp->p_ring.ring_duration);

	if (!Wizard
	    /* not wizard */
	    && (ingameflag || strcmp(Login, playerp->p_login) != 0))
	    /* in game or not examining own character */
	    {
	    if (ingameflag)
		{
		more(LINES - 1);
		clear();
		return;
a157 4
	    else
		cleanup(TRUE);
		/*NOTREACHED*/
	    }
d159 2
a160 2
	mvaddstr(20, 0, "!:Quit       ?:Delete");
	mvaddstr(21, 0, "What would you like to change ? ");
d162 20
a181 5
	if (Wizard)
	    c = getanswer(" ", TRUE);
	else
	    /* examining own player; allow to change name and password */
	    c = getanswer("!BA", FALSE);
a182 4
	switch (c)
	    {
	    case 'A':	/* change name */
	    case 'B':	/* change password */
d184 2
a185 20
		    /* prompt for password */
		    {
		    mvaddstr(23, 0, "Password ? ");
		    Echo = FALSE;
		    getstring(Databuf, 9);
		    Echo = TRUE;
		    if (strcmp(Databuf, playerp->p_password) != 0)
			continue;
		    }
		    
		if (c == 'A')
		    /* get new name */
		    {
		    mvaddstr(23, 0, "New name: ");
		    getstring(Databuf, SZ_NAME);
		    truncstring(Databuf);
		    if (Databuf[0] != '\0')
			if (Wizard || findname(Databuf, &Other) < 0L)
			    strcpy(playerp->p_name, Databuf);
		    }
d187 2
a188 4
		    /* get new password */
		    {
		    if (!Wizard)
			Echo = FALSE;
d190 28
a217 2
		    do
			/* get two copies of new password until they match */
d219 39
a257 9
			/* get first copy */
			mvaddstr(23, 0, "New password ? ");
			getstring(Databuf, SZ_PASSWORD);
			if (Databuf[0] == '\0')
			    break;

			/* get second copy */
			mvaddstr(23, 0, "One more time ? ");
			getstring(playerp->p_password, SZ_PASSWORD);
a258 1
		    while (strcmp(playerp->p_password, Databuf) != 0);
d260 98
a357 2
		    Echo = TRUE;
		    }
d359 6
a364 1
		continue;
d366 90
a455 89
	    case 'C':	/* change experience */
		prompt = "experience";
		dptr = &playerp->p_experience;
		goto DALTER;

	    case 'D':	/* change level */
		prompt = "level";
		dptr = &playerp->p_level;
		goto DALTER;

	    case 'E':	/* change strength */
		prompt = "strength";
		dptr = &playerp->p_strength;
		goto DALTER;

	    case 'F':	/* change swords */
		prompt = "sword";
		dptr = &playerp->p_sword;
		goto DALTER;

	    case 'G':	/* change energy */
		prompt = "energy";
		dptr = &playerp->p_energy;
		goto DALTER;

	    case 'H':	/* change maximum energy */
		prompt = "max energy";
		dptr = &playerp->p_maxenergy;
		goto DALTER;

	    case 'I':	/* change shields */
		prompt = "shield";
		dptr = &playerp->p_shield;
		goto DALTER;

	    case 'J':	/* change quickness */
		prompt = "quickness";
		dptr = &playerp->p_quickness;
		goto DALTER;

	    case 'K':	/* change quicksilver */
		prompt = "quicksilver";
		dptr = &playerp->p_quksilver;
		goto DALTER;

	    case 'L':	/* change magic */
		prompt = "magic level";
		dptr = &playerp->p_magiclvl;
		goto DALTER;

	    case 'M':	/* change mana */
		prompt = "mana";
		dptr = &playerp->p_mana;
		goto DALTER;

	    case 'N':	/* change brains */
		prompt = "brains";
		dptr = &playerp->p_brains;
		goto DALTER;

	    case 'O':	/* change poison */
		prompt = "poison";
		dptr = &playerp->p_poison;
		goto DALTER;

	    case 'P':	/* change gold */
		prompt = "gold";
		dptr = &playerp->p_gold;
		goto DALTER;

	    case 'Q':	/* change gems */
		prompt = "gems";
		dptr = &playerp->p_gems;
		goto DALTER;

	    case 'R':	/* change sin */
		prompt = "sin";
		dptr = &playerp->p_sin;
		goto DALTER;

	    case 'S':	/* change x coord */
		prompt = "x";
		dptr = &playerp->p_x;
		goto DALTER;

	    case 'T':	/* change y coord */
		prompt = "y";
		dptr = &playerp->p_y;
		goto DALTER;
d457 5
a461 2
	    case 'U':	/* change age */
		mvprintw(23, 0, "age = %ld; age = ", playerp->p_age);
d464 1
a464 1
		    playerp->p_age = (long) dtemp;
d467 2
a468 2
	    case 'V':	/* change degen */
		mvprintw(23, 0, "degen = %d; degen = ", playerp->p_degenerated);
d471 1
a471 1
		    playerp->p_degenerated = (int) dtemp;
d474 9
a482 93
	    case 'W':	/* change type */
		prompt = "type";
		sptr = &playerp->p_type;
		goto SALTER;

	    case 'X':	/* change special type */
		prompt = "special type";
		sptr = &playerp->p_specialtype;
		goto SALTER;

	    case 'Y':	/* change lives */
		prompt = "lives";
		sptr = &playerp->p_lives;
		goto SALTER;

	    case 'Z':	/* change crowns */
		prompt = "crowns";
		sptr = &playerp->p_crowns;
		goto SALTER;

	    case '0':	/* change charms */
		prompt = "charm";
		sptr = &playerp->p_charms;
		goto SALTER;

	    case '1':	/* change amulet */
		prompt = "amulet";
		sptr = &playerp->p_amulets;
		goto SALTER;

	    case '2':	/* change holy water */
		prompt = "holy water";
		sptr = &playerp->p_holywater;
		goto SALTER;

	    case '3':	/* change last-used */
		prompt = "last-used";
		sptr = &playerp->p_lastused;
		goto SALTER;

	    case '4':	/* change palantir */
		prompt = "palantir";
		bptr = &playerp->p_palantir;
		goto BALTER;

	    case '5':	/* change blessing */
		prompt = "blessing";
		bptr = &playerp->p_blessing;
		goto BALTER;

	    case '6':	/* change virgin */
		prompt = "virgin";
		bptr = &playerp->p_virgin;
		goto BALTER;

	    case '7':	/* change blindness */
		prompt = "blindness";
		bptr = &playerp->p_blindness;
		goto BALTER;

	    case '8':	/* change ring type */
		prompt = "ring-type";
		sptr = &playerp->p_ring.ring_type;
		goto SALTER;

	    case '9':	/* change ring duration */
		prompt = "ring-duration";
		sptr = &playerp->p_ring.ring_duration;
		goto SALTER;

	    case '!':	/* quit, update */
		if (Wizard &&
		    (!ingameflag || playerp != &Player))
		    /* turn off status if not modifying self */
		    {
		    playerp->p_status = S_OFF;
		    playerp->p_tampered = T_OFF;
		    }

		writerecord(playerp, loc);
		clear();
		return;

	    case '?':	/* delete player */
		if (ingameflag && playerp == &Player)
		    /* cannot delete self */
		    continue;

		freerecord(playerp, loc);
		clear();
		return;

	    default:
a483 23
	    }
DALTER:
	mvprintw(23, 0, "%s = %f; %s = ", prompt, *dptr, prompt);
	dtemp = infloat();
	if (dtemp != 0.0)
	    *dptr = dtemp;
	continue;

SALTER:
	mvprintw(23, 0, "%s = %d; %s = ", prompt, *sptr, prompt);
	dtemp = infloat();
	if (dtemp != 0.0)
	    *sptr = (short) dtemp;
	continue;

BALTER:
	mvprintw(23, 0, "%s = %c; %s = ", prompt, flag[*bptr], prompt);
	c = getanswer("\nTF", TRUE);
	if (c == 'T')
	    *bptr = TRUE;
	else if (c == 'F')
	    *bptr = FALSE;
	continue;
d510 1
d513 1
a513 1
register int 	count = 0;		/* count in file */
d515 7
a521 7
    puts(" #)  Name                 Str  Brain  Quick  Energy  Exper  Treas  Type  Flock%\n");
    fseek(Monstfp, 0L, 0);
    while (fread((char *) &Curmonster, SZ_MONSTERSTRUCT, 1, Monstfp) == 1)
	printf("%2d)  %-20.20s%4.0f   %4.0f     %2.0f   %5.0f  %5.0f     %2d    %2d     %3.0f\n", count++,
	    Curmonster.m_name, Curmonster.m_strength, Curmonster.m_brains,
	    Curmonster.m_speed, Curmonster.m_energy, Curmonster.m_experience,
	    Curmonster.m_treasuretype, Curmonster.m_type, Curmonster.m_flock);
d547 1
d550 2
a551 2
struct	scoreboard	sbuf;	/* for reading entries */
register FILE	*fp;		/* to open the file */
d553 5
a557 6
    if ((fp = fopen(_PATH_SCORE, "r")) != NULL)
	{
	while (fread((char *) &sbuf, SZ_SCORESTRUCT, 1, fp) == 1)
	    printf("%-20s   (%-9s)  Level: %6.0f  Type: %s\n",
		sbuf.sb_name, sbuf.sb_login, sbuf.sb_level, sbuf.sb_type);
	fclose(fp);
d584 1
d587 2
a588 2
    fseek(Playersfp, 0L, 0);
    printf("Current characters on file are:\n\n");
d590 5
a594 5
    while (fread((char *) &Other, SZ_PLAYERSTRUCT, 1, Playersfp) == 1)
	if (Other.p_status != S_NOTUSED)
	    printf("%-20s   (%-9s)  Level: %6.0f  %s  (%s)\n",
		Other.p_name, Other.p_login, Other.p_level,
		descrtype(&Other, FALSE), descrstatus(&Other));
d622 1
d625 21
a645 21
int	today;		/* day of year for today */
int	daysold;	/* how many days since the character has been used */
time_t	ltime;		/* time in seconds */
long	loc = 0L;	/* location in file */

    time(&ltime);
    today = localtime(&ltime)->tm_yday;

    for (;;)
	{
	fseek(Playersfp, loc, 0);
	if (fread((char *) &Other, SZ_PLAYERSTRUCT, 1, Playersfp) != 1)
	    break;

	daysold = today - Other.p_lastused;
	if (daysold < 0)
	    daysold += 365;

	if (daysold > N_DAYSOLD)
	    /* player hasn't been used in a while; delete */
	    freerecord(&Other, loc);
d647 1
a647 1
	loc += SZ_PLAYERSTRUCT;
d679 1
d682 15
a696 20
struct	scoreboard sbuf;		/* buffer to read in scoreboard entries */
FILE	*fp;				/* to open scoreboard file */
long	loc = 0L;			/* location in scoreboard file */
bool	found = FALSE;			/* set if we found an entry for this login */

    if ((fp = fopen(_PATH_SCORE, "r+")) != NULL)
	{
	while (fread((char *) &sbuf, SZ_SCORESTRUCT, 1, fp) == 1)
	    if (strcmp(Player.p_login, sbuf.sb_login) == 0)
		{
		found = TRUE;
		break;
		}
	    else
		loc += SZ_SCORESTRUCT;
	}
    else
	{
	error(_PATH_SCORE);
	/*NOTREACHED*/
d699 5
a703 5
    /*
     * At this point, 'loc' will either indicate a point beyond
     * the end of file, or the place where the previous entry
     * was found.
     */
d705 2
a706 2
    if ((!found) || Player.p_level > sbuf.sb_level)
	/* put new entry in for this login */
d708 4
a711 4
	strcpy(sbuf.sb_login, Player.p_login);
	strcpy(sbuf.sb_name, Player.p_name);
	sbuf.sb_level = Player.p_level;
	strcpy(sbuf.sb_type, descrtype(&Player, TRUE));
d713 4
a716 5

    /* update entry */
    fseek(fp, loc, 0);
    fwrite((char *) &sbuf, SZ_SCORESTRUCT, 1, fp);
    fclose(fp);
@


1.1
log
@Initial revision
@
text
@d53 1
a53 1
/************************************************************************/
d513 1
a513 1
/************************************************************************/
d549 1
a549 1
/************************************************************************/
d586 1
a586 1
/************************************************************************/
d623 1
a623 1
/************************************************************************/
d679 1
a679 1
/************************************************************************/
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
