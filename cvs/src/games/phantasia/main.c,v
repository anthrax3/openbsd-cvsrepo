head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.6
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.4
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.12
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.10
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.8
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.13.0.30
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.26
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.28
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.24
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.22
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.20
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.18
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.16
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.14
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.12
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.10
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.8
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.8.0.6
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.6
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2016.08.27.02.00.10;	author guenther;	state Exp;
branches;
next	1.21;
commitid	usv2ULh2hPPt9BPj;

1.21
date	2016.01.10.13.35.09;	author mestre;	state Exp;
branches;
next	1.20;
commitid	mVbl9a8GbGdqcFgu;

1.20
date	2016.01.08.13.40.05;	author tb;	state Exp;
branches;
next	1.19;
commitid	deG8pXu1tXVoNIxq;

1.19
date	2016.01.06.14.28.09;	author mestre;	state Exp;
branches;
next	1.18;
commitid	A5CGsPmxC2qOSHvN;

1.18
date	2016.01.06.09.39.51;	author tb;	state Exp;
branches;
next	1.17;
commitid	n1ecS9whrSfppP1l;

1.17
date	2014.11.16.04.49.48;	author guenther;	state Exp;
branches;
next	1.16;
commitid	8XNajyb9IqHkZEKg;

1.16
date	2014.07.12.03.41.04;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	Yi7cQzTeO9GQVNTk;

1.15
date	2013.08.29.20.22.17;	author naddy;	state Exp;
branches;
next	1.14;

1.14
date	2010.12.15.06.40.39;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.25.21.37.47;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.06.18.50.38;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.06.21.48.51;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.31.05.11.37;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.06.19.48.47;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.04.02.51.24;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.29.07.39.45;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	98.11.29.19.56.57;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	98.11.28.09.25.53;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	98.07.10.09.46.47;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	97.12.08.03.53.45;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.26.07.23.13;	author fn;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.10;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Pull in <time.h> for time() and perhaps other functions

ok deraadt@@
@
text
@/*	$OpenBSD: main.c,v 1.21 2016/01/10 13:35:09 mestre Exp $	*/
/*	$NetBSD: main.c,v 1.3 1995/04/24 12:24:37 cgd Exp $	*/

/*
 * Phantasia 3.3.2 -- Interterminal fantasy game
 *
 * Edward A. Estes
 * AT&T, March 12, 1986
 */

/* DISCLAIMER:
 *
 * This game is distributed for free as is.  It is not guaranteed to work
 * in every conceivable environment.  It is not even guaranteed to work
 * in ANY environment.
 *
 * This game is distributed without notice of copyright, therefore it
 * may be used in any manner the recipient sees fit.  However, the
 * author assumes no responsibility for maintaining or revising this
 * game, in its original form, or any derivitives thereof.
 *
 * The author shall not be responsible for any loss, cost, or damage,
 * including consequential damage, caused by reliance on this material.
 *
 * The author makes no warranties, express or implied, including warranties
 * of merchantability or fitness for a particular purpose or use.
 *
 * AT&T is in no way connected with this game.
 */

#include <curses.h>
#include <err.h>
#include <math.h>
#include <pwd.h>
#include <stdlib.h>
#include <string.h>
#ifdef TERMIOS
#include <termios.h>
#endif
#include <time.h>
#include <unistd.h>

#include "macros.h"
#include "pathnames.h"
#include "phantdefs.h"
#include "phantglobs.h"

/*
 * The program allocates as much file space as it needs to store characters,
 * so the possibility exists for the character file to grow without bound.
 * The file is purged upon normal entry to try to avoid that problem.
 * A similar problem exists for energy voids.  To alleviate the problem here,
 * the void file is cleared with every new king, and a limit is placed
 * on the size of the energy void file.
 */

/*
 * Put one line of text into the file 'motd' for announcements, etc.
 */

/*
 * The scoreboard file is updated when someone dies, and keeps track
 * of the highest character to date for that login.
 * Being purged from the character file does not cause the scoreboard
 * to be updated.
 */

/*
 * main.c	Main routines for Phantasia
 */

/***************************************************************************
/ FUNCTION NAME: main()
/
/ FUNCTION: initialize state, and call main process
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS:
/	int	argc - argument count
/	char	**argv - argument vector
/
/ RETURN VALUE: none
/
/ MODULES CALLED: monstlist(), checkenemy(), activelist(), 
/	throneroom(), checkbattle(), readmessage(), changestats(), writerecord(), 
/	tradingpost(), adjuststats(), recallplayer(), displaystats(), checktampered(), 
/	fabs(), rollnewplayer(), time(), exit(), sqrt(), floor(), wmove(), 
/	signal(), strlcat(), purgeoldplayers(), getuid(), isatty(), wclear(), 
/	strlcpy(), system(), altercoordinates(), cleanup(), waddstr(), procmain(), 
/	playinit(), leavegame(), localtime(), getanswer(), neatstuff(), initialstate(), 
/	scorelist(), titlelist()
/
/ GLOBAL INPUTS: *Login, Throne, Wizard, Player, *stdscr, Changed, Databuf[], 
/	Fileloc, Stattable[]
/
/ GLOBAL OUTPUTS: Wizard, Player, Changed, Fileloc, Timeout, *Statptr
/
/ DESCRIPTION:
/	Process arguments, initialize program, and loop forever processing
/	player input.
/
****************************************************************************/

int
main(int argc, char **argv)
{
	bool    noheader = FALSE;	/* set if don't want header */
	bool    headeronly = FALSE;	/* set if only want header */
	bool    examine = FALSE;	/* set if examine a character */
	time_t  seconds;		/* for time of day */
	double  dtemp;			/* for temporary calculations */

	initialstate();			/* init globals */

	/* process arguments */
	while (--argc && (*++argv)[0] == '-')
		switch ((*argv)[1]) {
		case 's':	/* short */
			noheader = TRUE;
			break;

		case 'H':	/* Header */
			headeronly = TRUE;
			break;

		case 'a':	/* all users */
			activelist();
			cleanup(TRUE);

		case 'p':	/* purge old players */
			purgeoldplayers();
			cleanup(TRUE);

		case 'S':	/* set 'Wizard' */
			Wizard = !getuid();
			break;

		case 'x':	/* examine */
			examine = TRUE;
			break;

		case 'm':	/* monsters */
			monstlist();
			cleanup(TRUE);

		case 'b':	/* scoreboard */
			scorelist();
			cleanup(TRUE);
		}

	if (!isatty(0))		/* don't let non-tty's play */
		cleanup(TRUE);

	playinit();		/* set up to catch signals, init curses */

	if (examine) {
		changestats(FALSE);
		cleanup(TRUE);
	}
	if (!noheader) {
		titlelist();
		purgeoldplayers();	/* clean up old characters */
	}
	if (headeronly)
		cleanup(TRUE);

	do
		/* get the player structure filled */
	{
		Fileloc = -1L;

		mvaddstr(22, 17, "Do you have a character to run [Q = Quit] ? ");

		switch (getanswer("NYQ", FALSE)) {
		case 'Y':
			Fileloc = recallplayer();
			break;

		case 'Q':
			cleanup(TRUE);

		default:
			Fileloc = rollnewplayer();
			break;
		}
		clear();
	}
	while (Fileloc < 0L);

	if (Player.p_level > 5.0)
		/* low level players have long timeout */
		Timeout = TRUE;

	/* update some important player statistics */
	strlcpy(Player.p_login, Login, LOGIN_NAME_MAX);
	time(&seconds);
	Player.p_lastused = localtime(&seconds)->tm_yday;
	Player.p_status = S_PLAYING;
	writerecord(&Player, Fileloc);

	Statptr = &Stattable[Player.p_type];	/* initialize pointer */

	altercoordinates(Player.p_x, Player.p_y, A_FORCED);	/* set some flags */

	clear();

	for (;;)
		/* loop forever, processing input */
	{

		adjuststats();	/* cleanup stats */

		if (Throne && Player.p_crowns == 0 && Player.p_specialtype != SC_KING)
			/* not allowed on throne -- move */
		{
			mvaddstr(5, 0, "You're not allowed in the Lord's Chamber without a crown.\n");
			altercoordinates(0.0, 0.0, A_NEAR);
		}
		checktampered();/* check for energy voids, etc. */

		if (Player.p_status != S_CLOAKED
		/* not cloaked */
		    && (dtemp = fabs(Player.p_x)) == fabs(Player.p_y)
		/* |x| = |y| */
		    && !Throne)
			/* not on throne */
		{
			dtemp = sqrt(dtemp / 100.0);
			if (floor(dtemp) == dtemp)
				/* |x| / 100 == n*n; at a trading post */
			{
				tradingpost();
				clear();
			}
		}
		checkbattle();	/* check for player to player battle */
		neatstuff();	/* gurus, medics, etc. */

		if (Player.p_status == S_CLOAKED) {
			/* costs 3 mana per turn to be cloaked */
			if (Player.p_mana > 3.0)
				Player.p_mana -= 3.0;
			else
				/* ran out of mana, uncloak */
			{
				Player.p_status = S_PLAYING;
				Changed = TRUE;
			}
		}

		if (Player.p_status != S_PLAYING && Player.p_status != S_CLOAKED)
			/* change status back to S_PLAYING */
		{
			Player.p_status = S_PLAYING;
			Changed = TRUE;
		}
		if (Changed)
			/* update file only if important stuff has changed */
		{
			writerecord(&Player, Fileloc);
			Changed = FALSE;
			continue;
		}
		readmessage();	/* read message, if any */

		displaystats();	/* print statistics */

		move(6, 0);

		if (Throne)
			/* maybe make king, print prompt, etc. */
			throneroom();

		/* print status line */
		addstr("1:Move  2:Players  3:Talk  4:Stats  5:Quit  ");
		if (Player.p_level >= MEL_CLOAK && Player.p_magiclvl >= ML_CLOAK)
			addstr("6:Cloak  ");
		if (Player.p_level >= MEL_TELEPORT && Player.p_magiclvl >= ML_TELEPORT)
			addstr("7:Teleport  ");
		if (Player.p_specialtype >= SC_COUNCIL || Wizard)
			addstr("8:Intervene  ");

		procmain();	/* process input */
	}
}
/**/
/************************************************************************
/
/ FUNCTION NAME: initialstate()
/
/ FUNCTION: initialize some important global variable
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: fopen(), error(), getuid(), getlogin(), getpwuid()
/
/ GLOBAL INPUTS: 
/
/ GLOBAL OUTPUTS: *Energyvoidfp, Echo, Marsh, *Login, Users, Beyond, 
/	Throne, Wizard, Changed, Okcount, Timeout, Windows, *Monstfp, *Messagefp, 
/	*Playersfp
/
/ DESCRIPTION:
/	Set global flags, and open files which remain open.
/
*************************************************************************/

void
initialstate(void)
{
#ifdef TERMIOS
    struct termios tty;
#endif

	Beyond = FALSE;
	Marsh = FALSE;
	Throne = FALSE;
	Changed = FALSE;
	Wizard = FALSE;
	Timeout = FALSE;
	Users = 0;
	Windows = FALSE;
	Echo = TRUE;

	/* setup login name */
	if ((Login = getlogin()) == NULL) {
		struct passwd *gpwd;

		gpwd = getpwuid(getuid());
		if (gpwd != NULL)
			Login = gpwd->pw_name;
		else
			errx(1, "Who are you?");
	}

#ifdef TERMIOS
	/* setup terminal keys */
	if (tcgetattr(0, &tty) == 0) {
		Ch_Erase = tty.c_cc[VERASE];
		Ch_Kill = tty.c_cc[VKILL];
	} else {
		Ch_Erase = CH_ERASE;
		Ch_Kill = CH_KILL;
	}
#else
	Ch_Erase = CH_ERASE;
	Ch_Kill = CH_KILL;
#endif

	/* open some files */
	if ((Playersfp = fopen(_PATH_PEOPLE, "r+")) == NULL)
		error(_PATH_PEOPLE);

	if ((Monstfp = fopen(_PATH_MONST, "r+")) == NULL)
		error(_PATH_MONST);

	if ((Messagefp = fopen(_PATH_MESS, "r")) == NULL)
		error(_PATH_MESS);

	if ((Energyvoidfp = fopen(_PATH_VOID, "r+")) == NULL)
		error(_PATH_VOID);
}
/**/
/************************************************************************
/
/ FUNCTION NAME: rollnewplayer()
/
/ FUNCTION: roll up a new character
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: initplayer(), allocrecord(), truncstring(), fabs(), wmove(), 
/	wclear(), sscanf(), strcmp(), genchar(), waddstr(), findname(), mvprintw(), 
/	getanswer(), getstring()
/
/ GLOBAL INPUTS: Other, Wizard, Player, *stdscr, Databuf[]
/
/ GLOBAL OUTPUTS: Echo
/
/ DESCRIPTION:
/	Prompt player, and roll up new character.
/
*************************************************************************/

long
rollnewplayer(void)
{
	int     chartype;	/* character type */
	int     ch;		/* input */

	initplayer(&Player);	/* initialize player structure */

	clear();
	mvaddstr(4, 21, "Which type of character do you want:");
	mvaddstr(8, 4,
"1:Magic User  2:Fighter  3:Elf  4:Dwarf  5:Halfling  6:Experimento  ");
	if (Wizard) {
		addstr("7:Super  ? ");
		chartype = getanswer("1234567", FALSE);
	} else {
		addstr("?  ");
		chartype = getanswer("123456", FALSE);
	}

	do {
		genchar(chartype);	/* roll up a character */

		/* print out results */
		mvprintw(12, 14,
		    "Strength    :  %2.0f  Quickness:  %2.0f  Mana       :  %2.0f\n",
		    Player.p_strength, Player.p_quickness, Player.p_mana);
		mvprintw(13, 14,
		    "Energy Level:  %2.0f  Brains   :  %2.0f  Magic Level:  %2.0f\n",
		    Player.p_energy, Player.p_brains, Player.p_magiclvl);

		if (Player.p_type == C_EXPER || Player.p_type == C_SUPER)
			break;

		mvaddstr(14, 14, "Type '1' to keep >");
		ch = getanswer(" ", TRUE);
	}
	while (ch != '1');

	if (Player.p_type == C_EXPER || Player.p_type == C_SUPER)
		/* get coordinates for experimento */
		for (;;) {
			mvaddstr(16, 0, "Enter the X Y coordinates of your experimento ? ");
			getstring(Databuf, SZ_DATABUF);
			sscanf(Databuf, "%lf %lf", &Player.p_x, &Player.p_y);

			if (fabs(Player.p_x) > D_EXPER || fabs(Player.p_y) > D_EXPER)
				mvaddstr(17, 0, "Invalid coordinates.  Try again.\n");
			else
				break;
		}

	for (;;)
		/* name the new character */
	{
		mvprintw(18, 0,
		    "Give your character a name [up to %d characters] ?  ", SZ_NAME - 1);
		getstring(Player.p_name, SZ_NAME);
		truncstring(Player.p_name);	/* remove trailing blanks */

		if (Player.p_name[0] == '\0')
			/* no null names */
			mvaddstr(19, 0, "Invalid name.");
		else
			if (findname(Player.p_name, &Other) >= 0L)
				/* cannot have duplicate names */
				mvaddstr(19, 0, "Name already in use.");
			else
				/* name is acceptable */
				break;

		addstr("  Pick another.\n");
	}

	/* get a password for character */
	Echo = FALSE;

	do {
		mvaddstr(20, 0, "Give your character a password [up to 8 characters] ? ");
		getstring(Player.p_password, SZ_PASSWORD);
		mvaddstr(21, 0, "One more time to verify ? ");
		getstring(Databuf, SZ_PASSWORD);
	}
	while (strcmp(Player.p_password, Databuf) != 0);

	Echo = TRUE;

	return (allocrecord());
}
/**/
/************************************************************************
/
/ FUNCTION NAME: procmain()
/
/ FUNCTION: process input from player
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: dotampered(), changestats(), inputoption(), allstatslist(), 
/	fopen(), wmove(), drandom(), sscanf(), fclose(), altercoordinates(), 
/	waddstr(), fprintf(), distance(), userlist(), leavegame(), encounter(), 
/	getstring(), wclrtobot()
/
/ GLOBAL INPUTS: Circle, Illcmd[], Throne, Wizard, Player, *stdscr, 
/	Databuf[], Illmove[]
/
/ GLOBAL OUTPUTS: Player, Changed
/
/ DESCRIPTION:
/	Process main menu options.
/
*************************************************************************/

void
procmain(void)
{
	int     ch;		/* input */
	double  x;		/* desired new x coordinate */
	double  y;		/* desired new y coordinate */
	double  temp;		/* for temporary calculations */
	FILE   *fp;		/* for opening files */
	int     loop;		/* a loop counter */
	bool    hasmoved = FALSE;	/* set if player has moved */

	ch = inputoption();
	mvaddstr(4, 0, "\n\n");	/* clear status area */

	move(7, 0);
	clrtobot();		/* clear data on bottom area of screen */

	if (Player.p_specialtype == SC_VALAR && (ch == '1' || ch == '7'))
		/* valar cannot move */
		ch = ' ';

	switch (ch) {
	case 'K':		/* move up/north */
	case 'N':
		x = Player.p_x;
		y = Player.p_y + MAXMOVE();
		hasmoved = TRUE;
		break;

	case 'J':		/* move down/south */
	case 'S':
		x = Player.p_x;
		y = Player.p_y - MAXMOVE();
		hasmoved = TRUE;
		break;

	case 'L':		/* move right/east */
	case 'E':
		x = Player.p_x + MAXMOVE();
		y = Player.p_y;
		hasmoved = TRUE;
		break;

	case 'H':		/* move left/west */
	case 'W':
		x = Player.p_x - MAXMOVE();
		y = Player.p_y;
		hasmoved = TRUE;
		break;

	default:		/* rest */
		Player.p_energy += (Player.p_maxenergy + Player.p_shield) / 15.0
		    + Player.p_level / 3.0 + 2.0;
		Player.p_energy =
		    MIN(Player.p_energy, Player.p_maxenergy + Player.p_shield);

		if (Player.p_status != S_CLOAKED)
			/* cannot find mana if cloaked */
		{
			Player.p_mana += (Circle + Player.p_level) / 4.0;

			if (drandom() < 0.2 && Player.p_status == S_PLAYING && !Throne)
				/* wandering monster */
				encounter(-1);
		}
		break;

	case 'X':		/* change/examine a character */
		changestats(TRUE);
		break;

	case '1':		/* move */
		for (loop = 3; loop; --loop) {
			mvaddstr(4, 0, "X Y Coordinates ? ");
			getstring(Databuf, SZ_DATABUF);

			if (sscanf(Databuf, "%lf %lf", &x, &y) != 2)
				mvaddstr(5, 0, "Try again\n");
			else
				if (distance(Player.p_x, x, Player.p_y, y) > MAXMOVE())
					ILLMOVE();
				else {
					hasmoved = TRUE;
					break;
				}
		}
		break;

	case '2':		/* players */
		userlist(TRUE);
		break;

	case '3':		/* message */
		mvaddstr(4, 0, "Message ? ");
		getstring(Databuf, SZ_DATABUF);
		/* we open the file for writing to erase any data which is
		 * already there */
		fp = fopen(_PATH_MESS, "w");
		if (Databuf[0] != '\0')
			fprintf(fp, "%s: %s", Player.p_name, Databuf);
		fclose(fp);
		break;

	case '4':		/* stats */
		allstatslist();
		break;

	case '5':		/* good-bye */
		leavegame();

	case '6':		/* cloak */
		if (Player.p_level < MEL_CLOAK || Player.p_magiclvl < ML_CLOAK)
			ILLCMD();
		else
			if (Player.p_status == S_CLOAKED)
				Player.p_status = S_PLAYING;
			else
				if (Player.p_mana < MM_CLOAK)
					mvaddstr(5, 0, "No mana left.\n");
				else {
					Changed = TRUE;
					Player.p_mana -= MM_CLOAK;
					Player.p_status = S_CLOAKED;
				}
		break;

	case '7':		/* teleport */
		/*
	         * conditions for teleport
	         *	- 20 per (level plus magic level)
	         *	- OR council of the wise or valar or ex-valar
	         *	- OR transport from throne
	         * transports from throne cost no mana
	         */
		if (Player.p_level < MEL_TELEPORT || Player.p_magiclvl < ML_TELEPORT)
			ILLCMD();
		else
			for (loop = 3; loop; --loop) {
				mvaddstr(4, 0, "X Y Coordinates ? ");
				getstring(Databuf, SZ_DATABUF);

				if (sscanf(Databuf, "%lf %lf", &x, &y) == 2) {
					temp = distance(Player.p_x, x, Player.p_y, y);
					if (!Throne
					/* can transport anywhere from throne */
					    && Player.p_specialtype <= SC_COUNCIL
					/* council, valar can transport
					 * anywhere */
					    && temp > (Player.p_level + Player.p_magiclvl) * 20.0)
						/* can only move 20 per exp.
						 * level + mag. level */
						ILLMOVE();
					else {
						temp = (temp / 75.0 + 1.0) * 20.0;	/* mana used */

						if (!Throne && temp > Player.p_mana)
							mvaddstr(5, 0, "Not enough power for that distance.\n");
						else {
							if (!Throne)
								Player.p_mana -= temp;
							hasmoved = TRUE;
							break;
						}
					}
				}
			}
		break;

	case 'C':
	case '9':		/* monster */
		if (Throne)
			/* no monsters while on throne */
			mvaddstr(5, 0, "No monsters in the chamber!\n");
		else
			if (Player.p_specialtype != SC_VALAR)
				/* the valar cannot call monsters */
			{
				Player.p_sin += 1e-6;
				encounter(-1);
			}
		break;

	case '0':		/* decree */
		if (Wizard || (Player.p_specialtype == SC_KING && Throne))
			/* kings must be on throne to decree */
			dotampered();
		else
			ILLCMD();
		break;

	case '8':		/* intervention */
		if (Wizard || Player.p_specialtype >= SC_COUNCIL)
			dotampered();
		else
			ILLCMD();
		break;
	}

	if (hasmoved)
		/* player has moved -- alter coordinates, and do random
		 * monster */
	{
		altercoordinates(x, y, A_SPECIFIC);

		if (drandom() < 0.2 && Player.p_status == S_PLAYING && !Throne)
			encounter(-1);
	}
}
/**/
/************************************************************************
/
/ FUNCTION NAME: titlelist()
/
/ FUNCTION: print title page
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: fread(), fseek(), fopen(), fgets(), wmove(), strlcpy(), 
/	fclose(), strlen(), waddstr(), snprintf(), wrefresh()
/
/ GLOBAL INPUTS: Lines, Other, *stdscr, Databuf[], *Playersfp
/
/ GLOBAL OUTPUTS: Lines
/
/ DESCRIPTION:
/	Print important information about game, players, etc.
/
*************************************************************************/

void
titlelist(void)
{
	FILE   *fp;		/* used for opening various files */
	bool    councilfound = FALSE;	/* set if we find a member of the
					 * council */
	bool    kingfound = FALSE;	/* set if we find a king */
	double  hiexp, nxtexp;	/* used for finding the two highest players */
	double  hilvl, nxtlvl;	/* used for finding the two highest players */
	char    hiname[21], nxtname[21];	/* used for finding the two
						 * highest players */

	nxtexp = 0;
	mvaddstr(0, 14,
	    "W e l c o m e   t o   P h a n t a s i a (vers. 3.3.2)!");

	/* print message of the day */
	if ((fp = fopen(_PATH_MOTD, "r")) != NULL
	    && fgets(Databuf, SZ_DATABUF, fp) != NULL) {
		mvaddstr(2, 40 - strlen(Databuf) / 2, Databuf);
		fclose(fp);
	}
	/* search for king */
	fseek(Playersfp, 0L, SEEK_SET);
	while (fread(&Other, SZ_PLAYERSTRUCT, 1, Playersfp) == 1)
		if (Other.p_specialtype == SC_KING &&
		    Other.p_status != S_NOTUSED)
			/* found the king */
		{
			snprintf(Databuf, sizeof Databuf,
			    "The present ruler is %s  Level:%.0f",
			    Other.p_name, Other.p_level);
			mvaddstr(4, 40 - strlen(Databuf) / 2, Databuf);
			kingfound = TRUE;
			break;
		}
	if (!kingfound)
		mvaddstr(4, 24, "There is no ruler at this time.");

	/* search for valar */
	fseek(Playersfp, 0L, SEEK_SET);
	while (fread(&Other, SZ_PLAYERSTRUCT, 1, Playersfp) == 1)
		if (Other.p_specialtype == SC_VALAR && Other.p_status != S_NOTUSED)
			/* found the valar */
		{
			snprintf(Databuf, sizeof Databuf,
			    "The Valar is %s   Login:  %s", Other.p_name,
			    Other.p_login);
			mvaddstr(6, 40 - strlen(Databuf) / 2, Databuf);
			break;
		}
	/* search for council of the wise */
	fseek(Playersfp, 0L, SEEK_SET);
	Lines = 10;
	while (fread(&Other, SZ_PLAYERSTRUCT, 1, Playersfp) == 1)
		if (Other.p_specialtype == SC_COUNCIL && Other.p_status != S_NOTUSED)
			/* found a member of the council */
		{
			if (!councilfound) {
				mvaddstr(8, 30, "Council of the Wise:");
				councilfound = TRUE;
			}
			/* This assumes a finite (<=5) number of C.O.W.: */
			snprintf(Databuf, sizeof Databuf,
			    "%s   Login:  %s", Other.p_name, Other.p_login);
			mvaddstr(Lines++, 40 - strlen(Databuf) / 2, Databuf);
		}
	/* search for the two highest players */
	nxtname[0] = hiname[0] = '\0';
	hiexp = 0.0;
	nxtlvl = hilvl = 0;

	fseek(Playersfp, 0L, SEEK_SET);
	while (fread(&Other, SZ_PLAYERSTRUCT, 1, Playersfp) == 1)
		if (Other.p_experience > hiexp && Other.p_specialtype <= SC_KING && Other.p_status != S_NOTUSED)
			/* highest found so far */
		{
			nxtexp = hiexp;
			hiexp = Other.p_experience;
			nxtlvl = hilvl;
			hilvl = Other.p_level;
			strlcpy(nxtname, hiname, sizeof nxtname);
			strlcpy(hiname, Other.p_name, sizeof hiname);
		} else
			if (Other.p_experience > nxtexp
			    && Other.p_specialtype <= SC_KING
			    && Other.p_status != S_NOTUSED)
				/* next highest found so far */
			{
				nxtexp = Other.p_experience;
				nxtlvl = Other.p_level;
				strlcpy(nxtname, Other.p_name, sizeof nxtname);
			}
	mvaddstr(15, 28, "Highest characters are:");
	snprintf(Databuf, sizeof Databuf,
	    "%s  Level:%.0f   and   %s  Level:%.0f",
	    hiname, hilvl, nxtname, nxtlvl);
	mvaddstr(17, 40 - strlen(Databuf) / 2, Databuf);

	/* print last to die */
	if ((fp = fopen(_PATH_LASTDEAD, "r")) != NULL
	    && fgets(Databuf, SZ_DATABUF, fp) != NULL) {
		mvaddstr(19, 25, "The last character to die was:");
		mvaddstr(20, 40 - strlen(Databuf) / 2, Databuf);
		fclose(fp);
	}
	refresh();
}
/**/
/************************************************************************
/
/ FUNCTION NAME: recallplayer()
/
/ FUNCTION: find a character on file
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: writerecord(), truncstring(), more(), death(), wmove(), 
/	wclear(), strcmp(), printw(), cleanup(), waddstr(), findname(), mvprintw(), 
/	getanswer(), getstring()
/
/ GLOBAL INPUTS: Player, *stdscr, Databuf[]
/
/ GLOBAL OUTPUTS: Echo, Player
/
/ DESCRIPTION:
/	Search for a character of a certain name, and check password.
/
*************************************************************************/

long
recallplayer(void)
{
	long    loc = 0L;	/* location in player file */
	int     loop;		/* loop counter */
	int     ch;		/* input */

	clear();
	mvprintw(10, 0, "What was your character's name ? ");
	getstring(Databuf, SZ_NAME);
	truncstring(Databuf);

	if ((loc = findname(Databuf, &Player)) >= 0L)
		/* found character */
	{
		Echo = FALSE;

		for (loop = 0; loop < 2; ++loop) {
			/* prompt for password */
			mvaddstr(11, 0, "Password ? ");
			getstring(Databuf, SZ_PASSWORD);
			if (strcmp(Databuf, Player.p_password) == 0)
				/* password good */
			{
				Echo = TRUE;

				if (Player.p_status != S_OFF)
					/* player did not exit normally last
					 * time */
				{
					clear();
					addstr("Your character did not exit normally last time.\n");
					addstr("If you think you have good cause to have your character saved,\n");
					printw("you may quit and mail your reason to 'root'.\n");
					addstr("Otherwise, continuing spells certain death.\n");
					addstr("Do you want to quit ? ");
					ch = getanswer("YN", FALSE);
					if (ch == 'Y') {
						Player.p_status = S_HUNGUP;
						writerecord(&Player, loc);
						cleanup(TRUE);
					}
					death("Stupidity");
				}
				return (loc);
			} else
				mvaddstr(12, 0, "No good.\n");
		}

		Echo = TRUE;
	} else
		mvaddstr(11, 0, "Not found.\n");

	more(13);
	return (-1L);
}
/**/
/************************************************************************
/
/ FUNCTION NAME: neatstuff()
/
/ FUNCTION: do random stuff
/
/ AUTHOR: E. A. Estes, 3/3/86
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: collecttaxes(), floor(), wmove(), drandom(), infloat(), 
/	waddstr(), mvprintw(), getanswer()
/
/ GLOBAL INPUTS: Player, *stdscr, *Statptr
/
/ GLOBAL OUTPUTS: Player
/
/ DESCRIPTION:
/	Handle gurus, medics, etc.
/
*************************************************************************/

void
neatstuff(void)
{
	double  temp;		/* for temporary calculations */
	int     ch;		/* input */

	switch ((int) ROLL(0.0, 100.0)) {
	case 1:
	case 2:
		if (Player.p_poison > 0.0) {
			mvaddstr(4, 0, "You've found a medic!  How much will you offer to be cured ? ");
			temp = floor(infloat());
			if (temp < 0.0 || temp > Player.p_gold)
				/* negative gold, or more than available */
			{
				mvaddstr(6, 0, "He was not amused, and made you worse.\n");
				Player.p_poison += 1.0;
			} else if (drandom() / 2.0 > (temp + 1.0) / MAX(Player.p_gold, 1))
				/* medic wants 1/2 of available gold */
				mvaddstr(5, 0, "Sorry, he wasn't interested.\n");
			else {
				mvaddstr(5, 0, "He accepted.");
				Player.p_poison = MAX(0.0, Player.p_poison - 1.0);
				Player.p_gold -= temp;
			}
		}
		break;

	case 3:
		mvaddstr(4, 0, "You've been caught raping and pillaging!\n");
		Player.p_experience += 4000.0;
		Player.p_sin += 0.5;
		break;

	case 4:
		temp = ROLL(10.0, 75.0);
		mvprintw(4, 0, "You've found %.0f gold pieces, want them ? ", temp);
		ch = getanswer("NY", FALSE);

		if (ch == 'Y')
			collecttaxes(temp, 0.0);
		break;

	case 5:
		if (Player.p_sin > 1.0) {
			mvaddstr(4, 0, "You've found a Holy Orb!\n");
			Player.p_sin -= 0.25;
		}
		break;

	case 6:
		if (Player.p_poison < 1.0) {
			mvaddstr(4, 0, "You've been hit with a plague!\n");
			Player.p_poison += 1.0;
		}
		break;

	case 7:
		mvaddstr(4, 0, "You've found some holy water.\n");
		++Player.p_holywater;
		break;

	case 8:
		mvaddstr(4, 0, "You've met a Guru. . .");
		if (drandom() * Player.p_sin > 1.0)
			addstr("You disgusted him with your sins!\n");
		else if (Player.p_poison > 0.0) {
			addstr("He looked kindly upon you, and cured you.\n");
			Player.p_poison = 0.0;
		} else {
			addstr("He rewarded you for your virtue.\n");
			Player.p_mana += 50.0;
			Player.p_shield += 2.0;
		}
		break;

	case 9:
		mvaddstr(4, 0, "You've found an amulet.\n");
		++Player.p_amulets;
		break;

	case 10:
		if (Player.p_blindness) {
			mvaddstr(4, 0, "You've regained your sight!\n");
			Player.p_blindness = FALSE;
		}
		break;

	default:		/* deal with poison */
		if (Player.p_poison > 0.0) {
			temp = Player.p_poison * Statptr->c_weakness
			    * Player.p_maxenergy / 600.0;
			if (Player.p_energy > Player.p_maxenergy / 10.0
			    && temp + 5.0 < Player.p_energy)
				Player.p_energy -= temp;
		}
		break;
	}
}
/**/
/************************************************************************
/
/ FUNCTION NAME: genchar()
/
/ FUNCTION: generate a random character
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS:
/	int type - ASCII value of character type to generate
/
/ RETURN VALUE: none
/
/ MODULES CALLED: floor(), drandom()
/
/ GLOBAL INPUTS: Wizard, Player, Stattable[]
/
/ GLOBAL OUTPUTS: Player
/
/ DESCRIPTION:
/	Use the lookup table for rolling stats.
/
*************************************************************************/

void
genchar(int type)
{
	int     subscript;	/* used for subscripting into Stattable */
	struct charstats *statptr;	/* for pointing into Stattable */

	subscript = type - '1';

	if (subscript < C_MAGIC || subscript > C_EXPER)
		if (subscript != C_SUPER || !Wizard)
			/* fighter is default */
			subscript = C_FIGHTER;

	statptr = &Stattable[subscript];

	Player.p_quickness =
	    ROLL(statptr->c_quickness.base, statptr->c_quickness.interval);
	Player.p_strength =
	    ROLL(statptr->c_strength.base, statptr->c_strength.interval);
	Player.p_mana =
	    ROLL(statptr->c_mana.base, statptr->c_mana.interval);
	Player.p_maxenergy =
	    Player.p_energy =
	    ROLL(statptr->c_energy.base, statptr->c_energy.interval);
	Player.p_brains =
	    ROLL(statptr->c_brains.base, statptr->c_brains.interval);
	Player.p_magiclvl =
	    ROLL(statptr->c_magiclvl.base, statptr->c_magiclvl.interval);

	Player.p_type = subscript;

	if (Player.p_type == C_HALFLING)
		/* give halfling some experience */
		Player.p_experience = ROLL(600.0, 200.0);
}
/**/
/************************************************************************
/
/ FUNCTION NAME: playinit()
/
/ FUNCTION: initialize for playing game
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: signal(), wclear(), noecho(), cbreak(), initscr(), 
/	wrefresh()
/
/ GLOBAL INPUTS: *stdscr, ill_sig()
/
/ GLOBAL OUTPUTS: Windows
/
/ DESCRIPTION:
/	Catch a bunch of signals, and turn on curses stuff.
/
*************************************************************************/

void
playinit(void)
{
	initscr();		/* turn on curses */
	noecho();		/* do not echo input */
	cbreak();		/* do not process erase, kill */
	clear();
	refresh();
	Windows = TRUE;		/* mark the state */
}
/**/
/************************************************************************
/
/ FUNCTION NAME: cleanup()
/
/ FUNCTION: close some files, and maybe exit
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS:
/	bool doexit - exit flag
/
/ RETURN VALUE: none
/
/ MODULES CALLED: exit(), wmove(), fclose(), endwin(), nocbreak(), wrefresh()
/
/ GLOBAL INPUTS: *Energyvoidfp, LINES, *stdscr, Windows, *Monstfp, 
/	*Messagefp, *Playersfp
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	Close all open files.  If we are "in curses" terminate curses.
/	If 'doexit' is set, exit, otherwise return.
/
*************************************************************************/

void
cleanup(int doexit)
{
	if (Windows) {
		move(LINES - 2, 0);
		refresh();
		nocbreak();
		endwin();
	}

	if (Playersfp) {
		fclose(Playersfp);
		Playersfp = NULL;
	}
	if (Monstfp) {
		fclose(Monstfp);
		Monstfp = NULL;
	}
	if (Messagefp) {
		fclose(Messagefp);
		Messagefp = NULL;
	}
	if (Energyvoidfp) {
		fclose(Energyvoidfp);
		Energyvoidfp = NULL;
	}

	if (doexit)
		exit(0);
}
@


1.21
log
@As per style(9), remove remaining lint-style comments from games/

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 2016/01/08 13:40:05 tb Exp $	*/
d40 1
@


1.20
log
@add missing 'void'

ok mestre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 2016/01/06 14:28:09 mestre Exp $	*/
a128 1
			/* NOTREACHED */
a132 1
			/* NOTREACHED */
a144 1
			/* NOTREACHED */
a148 1
			/* NOTREACHED */
a152 1
	/* NOTREACHED */
a158 1
		/* NOTREACHED */
a165 1
	/* NOTREACHED */
a180 1
			/* NOTREACHED */
a356 1
	/* NOTREACHED */
a359 1
	/* NOTREACHED */
a362 1
	/* NOTREACHED */
a365 1
	/* NOTREACHED */
a618 1
		/* NOTREACHED */
a917 1
						/* NOTREACHED */
a919 1
					/* NOTREACHED */
@


1.19
log
@Remove unnecessary header files from phantasia(6)

Lesson learnt: don't include an header sorted alphabetically just because. The
external definition of variables was done on phantglobs.h but their declaration
was on phantstruct.h and therefore the latter must be included before the
former. It's easier to just include phantstruct.h inside phantglobs.h since it
always need it.

With help and OK from tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 2016/01/06 09:39:51 tb Exp $	*/
d1158 1
a1158 1
playinit()
@


1.18
log
@Ansify the bulk of phantasia.  No binary change on amd64.  Based
on an older diff by mestre.

ok mestre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 2014/11/16 04:49:48 guenther Exp $	*/
d31 3
a33 2
#include <sys/types.h>
#include <limits.h>
d35 2
d40 6
a69 2

#include "include.h"
@


1.17
log
@Eliminate pointless use of <sys/param.h>, <sys/file.h>, <sys/sockio.h>,
    and <sys/ttydefaults.h>
Replace MAXPATHLEN with PATH_MAX and MAXLOGNAME with LOGIN_NAME_MAX
Pull in <limits.h> where needed
Prefer sizeof(var) over MAXFOO or FOO_MAX

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.16 2014/07/12 03:41:04 deraadt Exp $	*/
d98 1
a98 3
main(argc, argv)
	int     argc;
	char  **argv;
d314 1
a314 1
initialstate()
d399 1
a399 1
rollnewplayer()
d516 1
a516 1
procmain()
d750 1
a750 1
titlelist()
d884 1
a884 1
recallplayer()
d967 1
a967 1
neatstuff()
d1091 1
a1091 2
genchar(type)
	int     type;
d1188 1
a1188 2
cleanup(doexit)
	int	doexit;
@


1.16
log
@Remove a pile of (obviously unused) #ifdef SYSV and BSD41 and BSD42
code that catches lots of signals, and then re-enters curses... before
exiting.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 2013/08/29 20:22:17 naddy Exp $	*/
d32 1
d198 1
a198 1
	strlcpy(Player.p_login, Login, MAXLOGNAME);
@


1.15
log
@replace srandomdev()+random() with the arc4random*() family
tweaks and ok millert@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 2010/12/15 06:40:39 tedu Exp $	*/
a204 14
	/* catch interrupts */
#ifdef	BSD41
	sigset(SIGINT, interrupt);
#endif
#ifdef	BSD42
	signal(SIGINT, interrupt);
#endif
#ifdef	SYS3
	signal(SIGINT, interrupt);
#endif
#ifdef	SYS5
	signal(SIGINT, interrupt);
#endif

a1154 77
	/* catch/ignore signals */

#ifdef	BSD41
	sigignore(SIGQUIT);
	sigignore(SIGALRM);
	sigignore(SIGTERM);
	sigignore(SIGTSTP);
	sigignore(SIGTTIN);
	sigignore(SIGTTOU);
	sighold(SIGINT);
	sigset(SIGHUP, ill_sig);
	sigset(SIGTRAP, ill_sig);
	sigset(SIGIOT, ill_sig);
	sigset(SIGEMT, ill_sig);
	sigset(SIGFPE, ill_sig);
	sigset(SIGBUS, ill_sig);
#ifdef SIGSEGV_CHECK
	sigset(SIGSEGV, ill_sig);
#endif
	sigset(SIGSYS, ill_sig);
	sigset(SIGPIPE, ill_sig);
#endif
#ifdef	BSD42
	signal(SIGQUIT, ill_sig);
	signal(SIGALRM, SIG_IGN);
	signal(SIGTERM, SIG_IGN);
	signal(SIGTSTP, SIG_IGN);
	signal(SIGTTIN, SIG_IGN);
	signal(SIGTTOU, SIG_IGN);
	signal(SIGINT, ill_sig);
	signal(SIGHUP, SIG_DFL);
	signal(SIGTRAP, ill_sig);
	signal(SIGIOT, ill_sig);
	signal(SIGEMT, ill_sig);
	signal(SIGFPE, ill_sig);
	signal(SIGBUS, ill_sig);
#ifdef SIGSEGV_CHECK
	signal(SIGSEGV, ill_sig);
#endif
	signal(SIGSYS, ill_sig);
	signal(SIGPIPE, ill_sig);
#endif
#ifdef	SYS3
	signal(SIGINT, SIG_IGN);
	signal(SIGQUIT, SIG_IGN);
	signal(SIGTERM, SIG_IGN);
	signal(SIGALRM, SIG_IGN);
	signal(SIGHUP, ill_sig);
	signal(SIGTRAP, ill_sig);
	signal(SIGIOT, ill_sig);
	signal(SIGEMT, ill_sig);
	signal(SIGFPE, ill_sig);
	signal(SIGBUS, ill_sig);
#ifdef SIGSEGV_CHECK
	signal(SIGSEGV, ill_sig);
#endif
	signal(SIGSYS, ill_sig);
	signal(SIGPIPE, ill_sig);
#endif
#ifdef	SYS5
	signal(SIGINT, SIG_IGN);
	signal(SIGQUIT, SIG_IGN);
	signal(SIGTERM, SIG_IGN);
	signal(SIGALRM, SIG_IGN);
	signal(SIGHUP, ill_sig);
	signal(SIGTRAP, ill_sig);
	signal(SIGIOT, ill_sig);
	signal(SIGEMT, ill_sig);
	signal(SIGFPE, ill_sig);
	signal(SIGBUS, ill_sig);
#ifdef SIGSEGV_CHECK
	signal(SIGSEGV, ill_sig);
#endif
	signal(SIGSYS, ill_sig);
	signal(SIGPIPE, ill_sig);
#endif

@


1.14
log
@as of 1989, fread/fwrite take void *, so there's no need to cast to char *.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 2003/04/25 21:37:47 deraadt Exp $	*/
d315 1
a315 2
/ MODULES CALLED: time(), fopen(), srandom(), error(), getuid(), getlogin(), 
/	getpwuid()
a385 2

	srandomdev();	/* prime random numbers */
@


1.13
log
@comment repair
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 2003/04/06 18:50:38 deraadt Exp $	*/
d791 1
a791 1
	while (fread((char *) &Other, SZ_PLAYERSTRUCT, 1, Playersfp) == 1)
d808 1
a808 1
	while (fread((char *) &Other, SZ_PLAYERSTRUCT, 1, Playersfp) == 1)
d821 1
a821 1
	while (fread((char *) &Other, SZ_PLAYERSTRUCT, 1, Playersfp) == 1)
d840 1
a840 1
	while (fread((char *) &Other, SZ_PLAYERSTRUCT, 1, Playersfp) == 1)
@


1.12
log
@2451 lines of strdup/sprintf/strcpy whacking.  mostly ok'd by pjanzen
already, but he may have later changes to make still.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 2002/12/06 21:48:51 millert Exp $	*/
d80 2
a81 2
/	signal(), strcat(), purgeoldplayers(), getuid(), isatty(), wclear(), 
/	strcpy(), system(), altercoordinates(), cleanup(), waddstr(), procmain(), 
d755 2
a756 2
/ MODULES CALLED: fread(), fseek(), fopen(), fgets(), wmove(), strcpy(), 
/	fclose(), strlen(), waddstr(), sprintf(), wrefresh()
@


1.11
log
@Replace things like srandom(time(NULL)) with srandomdev(3).  random(3)
good enough for games but we should at least use a decent seed.
pjanzen@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 2002/05/31 05:11:37 pjanzen Exp $	*/
d796 2
a797 1
			sprintf(Databuf, "The present ruler is %s  Level:%.0f",
d812 3
a814 1
			sprintf(Databuf, "The Valar is %s   Login:  %s", Other.p_name, Other.p_login);
d830 2
a831 1
			sprintf(Databuf, "%s   Login:  %s", Other.p_name, Other.p_login);
d848 2
a849 2
			strcpy(nxtname, hiname);
			strcpy(hiname, Other.p_name);
d858 1
a858 1
				strcpy(nxtname, Other.p_name);
d861 2
a862 1
	sprintf(Databuf, "%s  Level:%.0f   and   %s  Level:%.0f",
@


1.10
log
@crmode -> cbreak
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 2002/05/06 19:48:47 millert Exp $	*/
d388 1
a388 1
	srandom((unsigned) time(NULL));	/* prime random numbers */
@


1.9
log
@do not install a SIGSEGV handler
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 2001/02/04 02:51:24 pjanzen Exp $	*/
d1152 1
a1152 1
/ MODULES CALLED: signal(), wclear(), noecho(), crmode(), initscr(), 
d1246 1
a1246 1
	crmode();		/* do not process erase, kill */
d1265 1
a1265 1
/ MODULES CALLED: exit(), wmove(), fclose(), endwin(), nocrmode(), wrefresh()
d1285 1
a1285 1
		nocrmode();
@


1.8
log
@Tidy, avoid segfaults on unknown users, and deal with long usernames
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 2000/06/29 07:39:45 pjanzen Exp $	*/
d1183 1
d1185 1
d1203 1
d1205 1
d1220 1
d1222 1
d1237 1
d1239 1
@


1.7
log
@use SEEK_SET; improve an error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 1998/11/29 19:56:57 pjanzen Exp $	*/
a56 2
/**/

d197 1
a197 1
	strcpy(Player.p_login, Login);
d346 11
a369 4

	/* setup login name */
	if ((Login = getlogin()) == NULL)
		Login = getpwuid(getuid())->pw_name;
@


1.6
log
@NetBSD merge (mainly -Wall related)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.4 1998/07/10 09:46:47 downsj Exp $	*/
d785 1
a785 1
	fseek(Playersfp, 0L, 0);
d801 1
a801 1
	fseek(Playersfp, 0L, 0);
d811 1
a811 1
	fseek(Playersfp, 0L, 0);
d830 1
a830 1
	fseek(Playersfp, 0L, 0);
@


1.5
log
@Clear up a warning:  printw doesn't take a const char, printf does
@
text
@a56 4
/*
 * All source files are set up for 'vi' with shiftwidth=4, tabstop=8. 
 */

d98 1
d100 2
a101 2
int	argc;
char	**argv;
d103 18
a120 5
bool	noheader = FALSE;	/* set if don't want header */
bool	headeronly = FALSE;	/* set if only want header */
bool	examine = FALSE;	/* set if examine a character */
time_t	seconds;		/* for time of day */
double	dtemp;			/* for temporary calculations */
d122 9
a130 1
    initialstate();		/* init globals */
d132 7
a138 7
    /* process arguments */
    while (--argc && (*++argv)[0] == '-')
	switch ((*argv)[1])
	    {
	    case 's':	/* short */
		noheader = TRUE;
		break;
d140 4
a143 3
	    case 'H':	/* Header */
		headeronly = TRUE;
		break;
d145 5
a149 4
	    case 'a':	/* all users */
		activelist();
		cleanup(TRUE);
		/*NOTREACHED*/
d151 1
a151 2
	    case 'p':	/* purge old players */
		purgeoldplayers();
d153 1
a153 5
		/*NOTREACHED*/

	    case 'S':	/* set 'Wizard' */
		Wizard = !getuid();
		break;
d155 1
a155 8
	    case 'x':	/* examine */
		examine = TRUE;
		break;

	    case 'm':	/* monsters */
		monstlist();
		cleanup(TRUE);
		/*NOTREACHED*/
d157 2
a158 2
	    case 'b':	/* scoreboard */
		scorelist();
d160 1
a160 14
		/*NOTREACHED*/
		}

    if (!isatty(0))		/* don't let non-tty's play */
	cleanup(TRUE);
	/*NOTREACHED*/

    playinit();			/* set up to catch signals, init curses */

    if (examine)
	{
	changestats(FALSE);
	cleanup(TRUE);
	/*NOTREACHED*/
d162 3
a164 5

    if (!noheader)
	{
	titlelist();
	purgeoldplayers();    /* clean up old characters */
d166 3
d170 2
a171 6
    if (headeronly)
	cleanup(TRUE);
	/*NOTREACHED*/

    do
	/* get the player structure filled */
d173 1
a173 1
	Fileloc = -1L;
d175 1
a175 1
	mvaddstr(22, 17, "Do you have a character to run [Q = Quit] ? ");
d177 4
a180 5
	switch (getanswer("NYQ", FALSE))
	    {
	    case 'Y':
		Fileloc = recallplayer();
		break;
d182 3
a184 3
	    case 'Q':
		cleanup(TRUE);
		/*NOTREACHED*/
d186 5
a190 5
	    default:
		Fileloc = rollnewplayer();
		break;
	    }
	clear();
d192 1
a192 1
    while (Fileloc < 0L);
d194 10
a203 10
    if (Player.p_level > 5.0)
	/* low level players have long timeout */
	Timeout = TRUE;

    /* update some important player statistics */
    strcpy(Player.p_login, Login);
    time(&seconds);
    Player.p_lastused = localtime(&seconds)->tm_yday;
    Player.p_status = S_PLAYING;
    writerecord(&Player, Fileloc);
d205 1
a205 1
    Statptr = &Stattable[Player.p_type];	/* initialize pointer */
d207 1
a207 1
    /* catch interrupts */
d209 1
a209 1
    sigset(SIGINT, interrupt);
d212 1
a212 1
    signal(SIGINT, interrupt);
d215 1
a215 1
    signal(SIGINT, interrupt);
d218 1
a218 1
    signal(SIGINT, interrupt);
d221 1
a221 1
    altercoordinates(Player.p_x, Player.p_y, A_FORCED);	/* set some flags */
d223 1
a223 1
    clear();
d225 2
a226 2
    for (;;)
	/* loop forever, processing input */
d229 1
a229 1
	adjuststats();		/* cleanup stats */
d231 2
a232 19
	if (Throne && Player.p_crowns == 0 && Player.p_specialtype != SC_KING)
	    /* not allowed on throne -- move */
	    {
	    mvaddstr(5,0,"You're not allowed in the Lord's Chamber without a crown.\n");
	    altercoordinates(0.0, 0.0, A_NEAR);
	    }

	checktampered();	/* check for energy voids, etc. */

	if (Player.p_status != S_CLOAKED
	    /* not cloaked */
	    && (dtemp = fabs(Player.p_x)) == fabs(Player.p_y)
	    /* |x| = |y| */
	    && !Throne)
	    /* not on throne */
	    {
	    dtemp = sqrt(dtemp / 100.0);
	    if (floor(dtemp) == dtemp)
		/* |x| / 100 == n*n; at a trading post */
d234 2
a235 2
		tradingpost();
		clear();
d237 1
a237 1
	    }
d239 17
a255 2
	checkbattle();		/* check for player to player battle */
	neatstuff();		/* gurus, medics, etc. */
d257 20
a276 6
	if (Player.p_status == S_CLOAKED)
	    /* costs 3 mana per turn to be cloaked */
	    if (Player.p_mana > 3.0)
		Player.p_mana -= 3.0;
	    else
		/* ran out of mana, uncloak */
d278 3
a280 2
		Player.p_status = S_PLAYING;
		Changed = TRUE;
d282 1
d284 1
a284 33
	if (Player.p_status != S_PLAYING && Player.p_status != S_CLOAKED)
	    /* change status back to S_PLAYING */
	    {
	    Player.p_status = S_PLAYING;
	    Changed = TRUE;
	    }

	if (Changed)
	    /* update file only if important stuff has changed */
	    {
	    writerecord(&Player, Fileloc);
	    Changed = FALSE;
	    continue;
	    }

	readmessage();			/* read message, if any */

	displaystats();			/* print statistics */

	move(6, 0);

	if (Throne)
	    /* maybe make king, print prompt, etc. */
	    throneroom();

	/* print status line */
	addstr("1:Move  2:Players  3:Talk  4:Stats  5:Quit  ");
	if (Player.p_level >= MEL_CLOAK && Player.p_magiclvl >= ML_CLOAK)
	    addstr("6:Cloak  ");
	if (Player.p_level >= MEL_TELEPORT && Player.p_magiclvl >= ML_TELEPORT)
	    addstr("7:Teleport  ");
	if (Player.p_specialtype >= SC_COUNCIL || Wizard)
	    addstr("8:Intervene  ");
d286 16
a301 1
	procmain();			/* process input */
d331 1
d338 9
a346 9
    Beyond = FALSE;
    Marsh = FALSE;
    Throne = FALSE;
    Changed = FALSE;
    Wizard = FALSE;
    Timeout = FALSE;
    Users = 0;
    Windows = FALSE;
    Echo = TRUE;
d349 9
a357 5
    /* setup terminal keys */
    if (tcgetattr(0, &tty) == 0) {
	Ch_Erase = tty.c_cc[VERASE];
	Ch_Kill = tty.c_cc[VKILL];
    } else {
a359 4
    }
#else
    Ch_Erase = CH_ERASE;
    Ch_Kill = CH_KILL;
d362 20
a381 20
    /* setup login name */
    if ((Login = getlogin()) == NULL)
	Login = getpwuid(getuid())->pw_name;
    
    /* open some files */
    if ((Playersfp = fopen(_PATH_PEOPLE, "r+")) == NULL)
	error(_PATH_PEOPLE);
	/*NOTREACHED*/

    if ((Monstfp = fopen(_PATH_MONST, "r+")) == NULL)
	error(_PATH_MONST);
	/*NOTREACHED*/

    if ((Messagefp = fopen(_PATH_MESS, "r")) == NULL)
	error(_PATH_MESS);
	/*NOTREACHED*/

    if ((Energyvoidfp = fopen(_PATH_VOID, "r+")) == NULL)
	error(_PATH_VOID);
	/*NOTREACHED*/
d383 1
a383 1
    srandom((unsigned) time(NULL));	/* prime random numbers */
d414 2
a415 2
int	chartype;	/* character type */
int	ch;		/* input */
d417 1
a417 1
    initplayer(&Player);		/* initialize player structure */
d419 10
a428 10
    clear();
    mvaddstr(4, 21, "Which type of character do you want:");
    mvaddstr(8, 4, "1:Magic User  2:Fighter  3:Elf  4:Dwarf  5:Halfling  6:Experimento  ");
    if (Wizard) {
	addstr("7:Super  ? ");
	chartype = getanswer("1234567", FALSE);
	}
    else {
	addstr("?  ");
	chartype = getanswer("123456", FALSE);
d431 13
a443 3
    do
	{
	genchar(chartype);		/* roll up a character */
d445 4
a448 7
	/* print out results */
	mvprintw(12, 14,
	    "Strength    :  %2.0f  Quickness:  %2.0f  Mana       :  %2.0f\n",
	    Player.p_strength, Player.p_quickness, Player.p_mana);
	mvprintw(13, 14,
	    "Energy Level:  %2.0f  Brains   :  %2.0f  Magic Level:  %2.0f\n",
	    Player.p_energy, Player.p_brains, Player.p_magiclvl);
d451 5
a455 1
	    break;
d457 5
a461 4
	mvaddstr(14, 14, "Type '1' to keep >");
	ch = getanswer(" ", TRUE);
	}
    while (ch != '1');
a462 2
    if (Player.p_type == C_EXPER || Player.p_type == C_SUPER)
	/* get coordinates for experimento */
d464 1
a464 13
	    {
	    mvaddstr(16, 0, "Enter the X Y coordinates of your experimento ? ");
	    getstring(Databuf, SZ_DATABUF);
	    sscanf(Databuf, "%lf %lf", &Player.p_x, &Player.p_y);

	    if (fabs(Player.p_x) > D_EXPER || fabs(Player.p_y) > D_EXPER)
		mvaddstr(17, 0, "Invalid coordinates.  Try again.\n");
	    else
		break;
	    }

    for (;;)
	/* name the new character */
d466 15
a480 14
	mvprintw(18, 0,
	    "Give your character a name [up to %d characters] ?  ", SZ_NAME - 1);
	getstring(Player.p_name, SZ_NAME);
	truncstring(Player.p_name);		/* remove trailing blanks */

	if (Player.p_name[0] == '\0')
	    /* no null names */
	    mvaddstr(19, 0, "Invalid name.");
	else if (findname(Player.p_name, &Other) >= 0L)
	    /* cannot have duplicate names */
	    mvaddstr(19, 0, "Name already in use.");
	else
	    /* name is acceptable */
	    break;
d482 1
a482 1
	addstr("  Pick another.\n");
d485 2
a486 2
    /* get a password for character */
    Echo = FALSE;
d488 5
a492 6
    do
	{
	mvaddstr(20, 0, "Give your character a password [up to 8 characters] ? ");
	getstring(Player.p_password, SZ_PASSWORD);
	mvaddstr(21, 0, "One more time to verify ? ");
	getstring(Databuf, SZ_PASSWORD);
d494 1
a494 1
    while (strcmp(Player.p_password, Databuf) != 0);
d496 1
a496 1
    Echo = TRUE;
d498 1
a498 1
    return(allocrecord());
d528 1
d531 17
a547 17
int	ch;			/* input */
double	x;			/* desired new x coordinate */
double	y;			/* desired new y coordinate */
double	temp;			/* for temporary calculations */
FILE	*fp;			/* for opening files */
register int	loop;		/* a loop counter */
bool	hasmoved = FALSE;	/* set if player has moved */

    ch = inputoption();
    mvaddstr(4, 0, "\n\n");		/* clear status area */

    move(7, 0);
    clrtobot();			/* clear data on bottom area of screen */

    if (Player.p_specialtype == SC_VALAR && (ch == '1' || ch == '7'))
	/* valar cannot move */
	ch = ' ';
d549 1
a549 2
    switch (ch)
	{
d552 4
a555 4
	    x = Player.p_x;
	    y = Player.p_y + MAXMOVE();
	    hasmoved = TRUE;
	    break;
d559 4
a562 4
	    x = Player.p_x;
	    y = Player.p_y - MAXMOVE();
	    hasmoved = TRUE;
	    break;
d566 4
a569 4
	    x = Player.p_x + MAXMOVE();
	    y = Player.p_y;
	    hasmoved = TRUE;
	    break;
d573 10
a582 10
	    x = Player.p_x - MAXMOVE();
	    y = Player.p_y;
	    hasmoved = TRUE;
	    break;

	default:    /* rest */
	    Player.p_energy += (Player.p_maxenergy + Player.p_shield) / 15.0
		+ Player.p_level / 3.0 + 2.0;
	    Player.p_energy =
		MIN(Player.p_energy, Player.p_maxenergy + Player.p_shield);
d584 2
a585 2
	    if (Player.p_status != S_CLOAKED)
		/* cannot find mana if cloaked */
d587 1
a587 1
		Player.p_mana += (Circle + Player.p_level) / 4.0;
d589 3
a591 3
		if (drandom() < 0.2 && Player.p_status == S_PLAYING && !Throne)
		    /* wandering monster */
		    encounter(-1);
d593 1
a593 1
	    break;
d596 2
a597 2
	    changestats(TRUE);
	    break;
d600 3
a602 4
	    for (loop = 3; loop; --loop)
		{
		mvaddstr(4, 0, "X Y Coordinates ? ");
		getstring(Databuf, SZ_DATABUF);
d604 9
a612 9
		if (sscanf(Databuf, "%lf %lf", &x, &y) != 2)
		    mvaddstr(5, 0, "Try again\n");
		else if (distance(Player.p_x, x, Player.p_y, y) > MAXMOVE())
		    ILLMOVE();
		else
		    {
		    hasmoved = TRUE;
		    break;
		    }
d614 1
a614 1
	    break;
d617 2
a618 2
	    userlist(TRUE);
	    break;
d621 9
a629 8
	    mvaddstr(4, 0, "Message ? ");
	    getstring(Databuf, SZ_DATABUF);
	    /* we open the file for writing to erase any data which is already there */
	    fp = fopen(_PATH_MESS, "w");
	    if (Databuf[0] != '\0')
		fprintf(fp, "%s: %s", Player.p_name, Databuf);
	    fclose(fp);
	    break;
d632 2
a633 2
	    allstatslist();
	    break;
d636 2
a637 2
	    leavegame();
	    /*NOTREACHED*/
d640 5
a644 40
	    if (Player.p_level < MEL_CLOAK || Player.p_magiclvl < ML_CLOAK)
		ILLCMD();
	    else if (Player.p_status == S_CLOAKED)
		Player.p_status = S_PLAYING;
	    else if (Player.p_mana < MM_CLOAK)
		mvaddstr(5, 0, "No mana left.\n");
	    else
		{
		Changed = TRUE;
		Player.p_mana -= MM_CLOAK;
		Player.p_status = S_CLOAKED;
		}
	    break;

	case '7':	/* teleport */
	    /*
	     * conditions for teleport
	     *	- 20 per (level plus magic level)
	     *	- OR council of the wise or valar or ex-valar
	     *	- OR transport from throne
	     * transports from throne cost no mana
	     */
	    if (Player.p_level < MEL_TELEPORT || Player.p_magiclvl < ML_TELEPORT)
		ILLCMD();
	    else 
		for (loop = 3; loop; --loop)
		    {
		    mvaddstr(4, 0, "X Y Coordinates ? ");
		    getstring(Databuf, SZ_DATABUF);

		    if (sscanf(Databuf, "%lf %lf", &x, &y) == 2)
			{
			temp = distance(Player.p_x, x, Player.p_y, y);
			if (!Throne
			    /* can transport anywhere from throne */
			    && Player.p_specialtype <= SC_COUNCIL
			    /* council, valar can transport anywhere */
			    && temp > (Player.p_level + Player.p_magiclvl) * 20.0)
			    /* can only move 20 per exp. level + mag. level */
			    ILLMOVE();
d646 8
a653 2
			    {
			    temp = (temp / 75.0 + 1.0) * 20.0;	/* mana used */
d655 38
a692 8
			    if (!Throne && temp > Player.p_mana)
				mvaddstr(5, 0, "Not enough power for that distance.\n");
			    else
				{
				if (!Throne)
				    Player.p_mana -= temp;
				hasmoved = TRUE;
				break;
a693 1
			    }
d695 1
a695 2
		    }
	    break;
d699 11
a709 10
	    if (Throne)
		/* no monsters while on throne */
		mvaddstr(5, 0, "No monsters in the chamber!\n");
	    else if (Player.p_specialtype != SC_VALAR)
		/* the valar cannot call monsters */
		{
		Player.p_sin += 1e-6;
		encounter(-1);
		}
	    break;
d712 6
a717 6
	    if (Wizard || Player.p_specialtype == SC_KING && Throne)
		/* kings must be on throne to decree */
		dotampered();
	    else
		ILLCMD();
	    break;
d720 5
a724 5
	    if (Wizard || Player.p_specialtype >= SC_COUNCIL)
		dotampered();
	    else
		ILLCMD();
	    break;
d727 3
a729 2
    if (hasmoved)
	/* player has moved -- alter coordinates, and do random monster */
d731 1
a731 1
	altercoordinates(x, y, A_SPECIFIC);
d733 2
a734 2
	if (drandom() < 0.2 && Player.p_status == S_PLAYING && !Throne)
	    encounter(-1);
d762 1
d765 18
a782 15
register FILE	*fp;		/* used for opening various files */
bool	councilfound = FALSE;	/* set if we find a member of the council */
bool	kingfound = FALSE;	/* set if we find a king */
double	hiexp, nxtexp;		/* used for finding the two highest players */
double	hilvl, nxtlvl;		/* used for finding the two highest players */
char	hiname[21], nxtname[21];/* used for finding the two highest players */

    mvaddstr(0, 14, "W e l c o m e   t o   P h a n t a s i a (vers. 3.3.2)!");

    /* print message of the day */
    if ((fp = fopen(_PATH_MOTD, "r")) != NULL
	&& fgets(Databuf, SZ_DATABUF, fp) != NULL)
	{
	mvaddstr(2, 40 - strlen(Databuf) / 2, Databuf);
	fclose(fp);
d784 15
d800 5
a804 35
    /* search for king */
    fseek(Playersfp, 0L, 0);
    while (fread((char *) &Other, SZ_PLAYERSTRUCT, 1, Playersfp) == 1)
	if (Other.p_specialtype == SC_KING && Other.p_status != S_NOTUSED)
	    /* found the king */
	    {
	    sprintf(Databuf, "The present ruler is %s  Level:%.0f",
		Other.p_name, Other.p_level);
	    mvaddstr(4, 40 - strlen(Databuf) / 2, Databuf);
	    kingfound = TRUE;
	    break;
	    }

    if (!kingfound)
	mvaddstr(4, 24, "There is no ruler at this time.");

    /* search for valar */
    fseek(Playersfp, 0L, 0);
    while (fread((char *) &Other, SZ_PLAYERSTRUCT, 1, Playersfp) == 1)
	if (Other.p_specialtype == SC_VALAR && Other.p_status != S_NOTUSED)
	    /* found the valar */
	    {
	    sprintf(Databuf, "The Valar is %s   Login:  %s", Other.p_name, Other.p_login);
	    mvaddstr(6, 40 - strlen(Databuf) / 2 , Databuf);
	    break;
	    }

    /* search for council of the wise */
    fseek(Playersfp, 0L, 0);
    Lines = 10;
    while (fread((char *) &Other, SZ_PLAYERSTRUCT, 1, Playersfp) == 1)
	if (Other.p_specialtype == SC_COUNCIL && Other.p_status != S_NOTUSED)
	    /* found a member of the council */
	    {
	    if (!councilfound)
d806 18
a823 2
		mvaddstr(8, 30, "Council of the Wise:");
		councilfound = TRUE;
d825 37
a861 45

	    /* This assumes a finite (<=5) number of C.O.W.: */
	    sprintf(Databuf, "%s   Login:  %s", Other.p_name, Other.p_login);
	    mvaddstr(Lines++, 40 - strlen(Databuf) / 2, Databuf);
	    }

    /* search for the two highest players */
    nxtname[0] = hiname[0] = '\0';
    hiexp = 0.0;
    nxtlvl = hilvl = 0;

    fseek(Playersfp, 0L, 0);
    while (fread((char *) &Other, SZ_PLAYERSTRUCT, 1, Playersfp) == 1)
	if (Other.p_experience > hiexp && Other.p_specialtype <= SC_KING && Other.p_status != S_NOTUSED)
	    /* highest found so far */
	    {
	    nxtexp = hiexp;
	    hiexp = Other.p_experience;
	    nxtlvl = hilvl;
	    hilvl = Other.p_level;
	    strcpy(nxtname, hiname);
	    strcpy(hiname, Other.p_name);
	    }
	else if (Other.p_experience > nxtexp
	    && Other.p_specialtype <= SC_KING
	    && Other.p_status != S_NOTUSED)
	    /* next highest found so far */
	    {
	    nxtexp = Other.p_experience;
	    nxtlvl = Other.p_level;
	    strcpy(nxtname, Other.p_name);
	    }

    mvaddstr(15, 28, "Highest characters are:");
    sprintf(Databuf, "%s  Level:%.0f   and   %s  Level:%.0f",
	hiname, hilvl, nxtname, nxtlvl);
    mvaddstr(17, 40 - strlen(Databuf) / 2, Databuf);

    /* print last to die */
    if ((fp = fopen(_PATH_LASTDEAD,"r")) != NULL
	&& fgets(Databuf, SZ_DATABUF, fp) != NULL)
	{
	mvaddstr(19, 25, "The last character to die was:");
	mvaddstr(20, 40 - strlen(Databuf) / 2,Databuf);
	fclose(fp);
d863 1
a863 2

    refresh();
d894 8
a901 8
long	loc = 0L;		/* location in player file */
register int	loop;		/* loop counter */
int	ch;			/* input */

    clear();
    mvprintw(10, 0, "What was your character's name ? ");
    getstring(Databuf, SZ_NAME);
    truncstring(Databuf);
d903 2
a904 2
    if ((loc = findname(Databuf, &Player)) >= 0L)
	/* found character */
d906 1
a906 1
	Echo = FALSE;
d908 8
a915 9
	for (loop = 0; loop < 2; ++loop)
	    {
	    /* prompt for password */
	    mvaddstr(11, 0, "Password ? ");
	    getstring(Databuf, SZ_PASSWORD);
	    if (strcmp(Databuf, Player.p_password) == 0)
		/* password good */
		{
		Echo = TRUE;
d917 23
a939 21
		if (Player.p_status != S_OFF)
		    /* player did not exit normally last time */
		    {
		    clear();
		    addstr("Your character did not exit normally last time.\n");
		    addstr("If you think you have good cause to have your character saved,\n");
		    printw("you may quit and mail your reason to 'root'.\n");
		    addstr("Otherwise, continuing spells certain death.\n");
		    addstr("Do you want to quit ? ");
		    ch = getanswer("YN", FALSE);
		    if (ch == 'Y')
			{
			Player.p_status = S_HUNGUP;
			writerecord(&Player, loc);
			cleanup(TRUE);
			/*NOTREACHED*/
			}
		    death("Stupidity");
		    /*NOTREACHED*/
		    }
		return(loc);
a940 3
	    else
		mvaddstr(12, 0, "No good.\n");
	    }
d942 3
a944 4
	Echo = TRUE;
	}
    else
	mvaddstr(11, 0, "Not found.\n");
d946 2
a947 2
    more(13);
    return(-1L);
d974 1
d977 2
a978 2
double	temp;	/* for temporary calculations */
int	ch;	/* input */
d980 1
a980 2
    switch ((int) ROLL(0.0, 100.0))
	{
d983 16
a998 19
	    if (Player.p_poison > 0.0)
		{
		mvaddstr(4, 0, "You've found a medic!  How much will you offer to be cured ? ");
		temp = floor(infloat());
		if (temp < 0.0 || temp > Player.p_gold)
		    /* negative gold, or more than available */
		    {
		    mvaddstr(6, 0, "He was not amused, and made you worse.\n");
		    Player.p_poison += 1.0;
		    }
		else if (drandom() / 2.0 > (temp + 1.0) / MAX(Player.p_gold, 1))
		    /* medic wants 1/2 of available gold */
		    mvaddstr(5, 0, "Sorry, he wasn't interested.\n");
		else
		    {
		    mvaddstr(5, 0, "He accepted.");
		    Player.p_poison = MAX(0.0, Player.p_poison - 1.0);
		    Player.p_gold -= temp;
		    }
d1000 1
a1000 1
	    break;
d1003 4
a1006 4
	    mvaddstr(4, 0, "You've been caught raping and pillaging!\n");
	    Player.p_experience += 4000.0;
	    Player.p_sin += 0.5;
	    break;
d1009 7
a1015 7
	    temp = ROLL(10.0, 75.0);
	    mvprintw(4, 0, "You've found %.0f gold pieces, want them ? ", temp);
	    ch = getanswer("NY", FALSE);

	    if (ch == 'Y')
		collecttaxes(temp, 0.0);
	    break;
d1018 3
a1020 4
	    if (Player.p_sin > 1.0)
		{
		mvaddstr(4, 0, "You've found a Holy Orb!\n");
		Player.p_sin -= 0.25;
d1022 1
a1022 1
	    break;
d1025 3
a1027 4
	    if (Player.p_poison < 1.0)
		{
		mvaddstr(4, 0, "You've been hit with a plague!\n");
		Player.p_poison += 1.0;
d1029 1
a1029 1
	    break;
d1032 3
a1034 3
	    mvaddstr(4, 0, "You've found some holy water.\n");
	    ++Player.p_holywater;
	    break;
d1037 10
a1046 7
	    mvaddstr(4, 0, "You've met a Guru. . .");
	    if (drandom() * Player.p_sin > 1.0)
		addstr("You disgusted him with your sins!\n");
	    else if (Player.p_poison > 0.0)
		{
		addstr("He looked kindly upon you, and cured you.\n");
		Player.p_poison = 0.0;
d1048 1
a1048 7
	    else
		{
		addstr("He rewarded you for your virtue.\n");
		Player.p_mana += 50.0;
		Player.p_shield += 2.0;
		}
	    break;
d1051 3
a1053 3
	    mvaddstr(4, 0, "You've found an amulet.\n");
	    ++Player.p_amulets;
	    break;
d1056 3
a1058 4
	    if (Player.p_blindness)
		{
		mvaddstr(4, 0, "You've regained your sight!\n");
		Player.p_blindness = FALSE;
d1060 1
a1060 1
	    break;
d1062 7
a1068 8
	default:	/* deal with poison */
	    if (Player.p_poison > 0.0)
		{
		temp = Player.p_poison * Statptr->c_weakness
		    * Player.p_maxenergy / 600.0;
		if (Player.p_energy > Player.p_maxenergy / 10.0
		    && temp + 5.0 < Player.p_energy)
		    Player.p_energy -= temp;
d1070 1
a1070 1
	    break;
d1098 1
d1100 1
a1100 1
int	type;
d1102 2
a1103 2
register int	subscript;		/* used for subscripting into Stattable */
register struct charstats	*statptr;/* for pointing into Stattable */
d1105 1
a1105 1
    subscript = type - '1';
d1107 26
a1132 26
    if (subscript < C_MAGIC || subscript > C_EXPER)
	if (subscript != C_SUPER || !Wizard)
	    /* fighter is default */
	    subscript = C_FIGHTER;
    
    statptr = &Stattable[subscript];

    Player.p_quickness =
	ROLL(statptr->c_quickness.base, statptr->c_quickness.interval);
    Player.p_strength =
	ROLL(statptr->c_strength.base, statptr->c_strength.interval);
    Player.p_mana =
	ROLL(statptr->c_mana.base, statptr->c_mana.interval);
    Player.p_maxenergy =
    Player.p_energy =
	ROLL(statptr->c_energy.base, statptr->c_energy.interval);
    Player.p_brains =
	ROLL(statptr->c_brains.base, statptr->c_brains.interval);
    Player.p_magiclvl =
	ROLL(statptr->c_magiclvl.base, statptr->c_magiclvl.interval);

    Player.p_type = subscript;

    if (Player.p_type == C_HALFLING)
	/* give halfling some experience */
	Player.p_experience = ROLL(600.0, 200.0);
d1159 1
d1162 1
a1162 1
    /* catch/ingnore signals */
d1165 16
a1180 16
    sigignore(SIGQUIT);
    sigignore(SIGALRM);
    sigignore(SIGTERM);
    sigignore(SIGTSTP);
    sigignore(SIGTTIN);
    sigignore(SIGTTOU);
    sighold(SIGINT);
    sigset(SIGHUP, ill_sig);
    sigset(SIGTRAP, ill_sig);
    sigset(SIGIOT, ill_sig);
    sigset(SIGEMT, ill_sig);
    sigset(SIGFPE, ill_sig);
    sigset(SIGBUS, ill_sig);
    sigset(SIGSEGV, ill_sig);
    sigset(SIGSYS, ill_sig);
    sigset(SIGPIPE, ill_sig);
d1183 16
a1198 16
    signal(SIGQUIT, ill_sig);
    signal(SIGALRM, SIG_IGN);
    signal(SIGTERM, SIG_IGN);
    signal(SIGTSTP, SIG_IGN);
    signal(SIGTTIN, SIG_IGN);
    signal(SIGTTOU, SIG_IGN);
    signal(SIGINT, ill_sig);
    signal(SIGHUP, SIG_DFL);
    signal(SIGTRAP, ill_sig);
    signal(SIGIOT, ill_sig);
    signal(SIGEMT, ill_sig);
    signal(SIGFPE, ill_sig);
    signal(SIGBUS, ill_sig);
    signal(SIGSEGV, ill_sig);
    signal(SIGSYS, ill_sig);
    signal(SIGPIPE, ill_sig);
d1201 13
a1213 13
    signal(SIGINT, SIG_IGN);
    signal(SIGQUIT, SIG_IGN);
    signal(SIGTERM, SIG_IGN);
    signal(SIGALRM, SIG_IGN);
    signal(SIGHUP, ill_sig);
    signal(SIGTRAP, ill_sig);
    signal(SIGIOT, ill_sig);
    signal(SIGEMT, ill_sig);
    signal(SIGFPE, ill_sig);
    signal(SIGBUS, ill_sig);
    signal(SIGSEGV, ill_sig);
    signal(SIGSYS, ill_sig);
    signal(SIGPIPE, ill_sig);
d1216 13
a1228 13
    signal(SIGINT, SIG_IGN);
    signal(SIGQUIT, SIG_IGN);
    signal(SIGTERM, SIG_IGN);
    signal(SIGALRM, SIG_IGN);
    signal(SIGHUP, ill_sig);
    signal(SIGTRAP, ill_sig);
    signal(SIGIOT, ill_sig);
    signal(SIGEMT, ill_sig);
    signal(SIGFPE, ill_sig);
    signal(SIGBUS, ill_sig);
    signal(SIGSEGV, ill_sig);
    signal(SIGSYS, ill_sig);
    signal(SIGPIPE, ill_sig);
d1231 6
a1236 6
    initscr();		/* turn on curses */
    noecho();		/* do not echo input */
    crmode();		/* do not process erase, kill */
    clear();
    refresh();
    Windows = TRUE;	/* mark the state */
a1237 1

d1265 1
d1267 1
a1267 1
bool	doexit;
d1269 5
a1273 6
    if (Windows)
	{
	move(LINES - 2, 0);
	refresh();
	nocrmode();
	endwin();
d1276 16
a1291 16
    if (Playersfp) {
	fclose(Playersfp);
	Playersfp = NULL;
    }
    if (Monstfp) {
	fclose(Monstfp);
	Monstfp = NULL;
    }
    if (Messagefp) {
	fclose(Messagefp);
	Messagefp = NULL;
    }
    if (Energyvoidfp) {
	fclose(Energyvoidfp);
	Energyvoidfp = NULL;
    }
d1293 2
a1294 2
    if (doexit)
	exit(0);
@


1.4
log
@Ok, so I was bored and couldn't sleep...

Make this sucker work with decent terminal settings.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a1322 1
	/*NOTREACHED*/
@


1.3
log
@avoid fclose(NULL)
@
text
@d1 1
d33 3
d345 4
d358 14
@


1.2
log
@fixed the "/* in comments" problem.
@
text
@d1282 16
a1297 4
    fclose(Playersfp);
    fclose(Monstfp);
    fclose(Messagefp);
    fclose(Energyvoidfp);
@


1.1
log
@Initial revision
@
text
@d96 1
a96 1
/***************************************************************************/
d337 1
a337 1
/************************************************************************/
d398 1
a398 1
/************************************************************************/
d517 1
a517 1
/************************************************************************/
d750 1
a750 1
/************************************************************************/
d883 1
a883 1
/************************************************************************/
d969 1
a969 1
/************************************************************************/
d1103 1
a1103 1
/************************************************************************/
d1163 1
a1163 1
/************************************************************************/
d1269 1
a1269 1
/************************************************************************/
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
