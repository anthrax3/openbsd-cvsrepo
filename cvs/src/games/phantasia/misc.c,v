head	1.21;
access;
symbols
	OPENBSD_6_2:1.21.0.6
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.21.0.8
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.16.0.8
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.12
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.10
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.8
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.13.0.30
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.26
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.28
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.24
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.22
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.20
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.18
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.16
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.14
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.12
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.10
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.8
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.6
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.4
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.6
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.4
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2016.01.10.13.35.10;	author mestre;	state Exp;
branches;
next	1.20;
commitid	mVbl9a8GbGdqcFgu;

1.20
date	2016.01.06.14.28.09;	author mestre;	state Exp;
branches;
next	1.19;
commitid	A5CGsPmxC2qOSHvN;

1.19
date	2016.01.06.09.43.26;	author tb;	state Exp;
branches;
next	1.18;
commitid	hiITiBHEyo9wprBx;

1.18
date	2016.01.06.09.39.51;	author tb;	state Exp;
branches;
next	1.17;
commitid	n1ecS9whrSfppP1l;

1.17
date	2015.12.26.00.26.39;	author mestre;	state Exp;
branches;
next	1.16;
commitid	NcBz9zfScw6TwPoT;

1.16
date	2014.07.12.03.41.04;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	Yi7cQzTeO9GQVNTk;

1.15
date	2013.08.29.20.22.17;	author naddy;	state Exp;
branches;
next	1.14;

1.14
date	2010.12.15.06.40.39;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.08.06.21.08.05;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.25.21.37.47;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.06.18.50.38;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.11.04.47.39;	author david;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.19.10.51.55;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.09.07.04.29;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.04.02.51.25;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.29.07.39.45;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	98.11.29.19.56.58;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	98.11.28.09.25.56;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	97.07.23.20.04.58;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.26.07.23.13;	author fn;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.11;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.21
log
@As per style(9), remove remaining lint-style comments from games/

OK tb@@
@
text
@/*	$OpenBSD: misc.c,v 1.20 2016/01/06 14:28:09 mestre Exp $	*/
/*	$NetBSD: misc.c,v 1.2 1995/03/24 03:59:03 cgd Exp $	*/

/*
 * misc.c  Phantasia miscellaneous support routines
 */

#include <curses.h>
#include <err.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "macros.h"
#include "pathnames.h"
#include "phantdefs.h"
#include "phantglobs.h"

/************************************************************************
/
/ FUNCTION NAME: movelevel()
/
/ FUNCTION: move player to new level
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: death(), floor(), wmove(), drandom(), waddstr(), explevel()
/
/ GLOBAL INPUTS: Player, *stdscr, *Statptr, Stattable[]
/
/ GLOBAL OUTPUTS: Player, Changed
/
/ DESCRIPTION:
/	Use lookup table to increment important statistics when
/	progressing to new experience level.
/	Players are rested to maximum as a bonus for making a new
/	level.
/	Check for council of wise, and being too big to be king.
/
*************************************************************************/

void
movelevel(void)
{
	struct charstats *statptr;	/* for pointing into Stattable */
	double  new;		/* new level */
	double  inc;		/* increment between new and old levels */

	Changed = TRUE;

	if (Player.p_type == C_EXPER)
		/* roll a type to use for increment */
		statptr = &Stattable[(int) ROLL(C_MAGIC, C_HALFLING - C_MAGIC + 1)];
	else
		statptr = Statptr;

	new = explevel(Player.p_experience);
	inc = new - Player.p_level;
	Player.p_level = new;

	/* add increments to statistics */
	Player.p_strength += statptr->c_strength.increase * inc;
	Player.p_mana += statptr->c_mana.increase * inc;
	Player.p_brains += statptr->c_brains.increase * inc;
	Player.p_magiclvl += statptr->c_magiclvl.increase * inc;
	Player.p_maxenergy += statptr->c_energy.increase * inc;

	/* rest to maximum upon reaching new level */
	Player.p_energy = Player.p_maxenergy + Player.p_shield;

	if (Player.p_crowns > 0 && Player.p_level >= 1000.0)
		/* no longer able to be king -- turn crowns into cash */
	{
		Player.p_gold += ((double) Player.p_crowns) * 5000.0;
		Player.p_crowns = 0;
	}
	if (Player.p_level >= 3000.0 && Player.p_specialtype < SC_COUNCIL)
		/* make a member of the council */
	{
		mvaddstr(6, 0, "You have made it to the Council of the Wise.\n");
		addstr("Good Luck on your search for the Holy Grail.\n");

		Player.p_specialtype = SC_COUNCIL;

		/* no rings for council and above */
		Player.p_ring.ring_type = R_NONE;
		Player.p_ring.ring_duration = 0;

		Player.p_lives = 3;	/* three extra lives */
	}
	if (Player.p_level > 9999.0 && Player.p_specialtype != SC_VALAR)
		death("Old age");
}
/**/
/************************************************************************
/
/ FUNCTION NAME: descrlocation()
/
/ FUNCTION: return a formatted description of location
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS:
/	struct player playerp - pointer to player structure
/	bool shortflag - set if short form is desired
/
/ RETURN VALUE: pointer to string containing result
/
/ MODULES CALLED: fabs(), floor(), snprintf(), distance()
/
/ GLOBAL INPUTS: Databuf[]
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	Look at coordinates and return an appropriately formatted
/	string.
/
*************************************************************************/

char *
descrlocation(struct player *playerp, bool shortflag)
{
	double  circle;		/* corresponding circle for coordinates */
	int     quadrant;	/* quandrant of grid */
	char   *label;		/* pointer to place name */
	static char *nametable[4][4] =	/* names of places */
	{
		{"Anorien", "Ithilien", "Rohan", "Lorien"},
		{"Gondor", "Mordor", "Dunland", "Rovanion"},
		{"South Gondor", "Khand", "Eriador", "The Iron Hills"},
		{"Far Harad", "Near Harad", "The Northern Waste", "Rhun"}
	};

	if (playerp->p_specialtype == SC_VALAR)
		return (" is in Valhala");
	else if ((circle = CIRCLE(playerp->p_x, playerp->p_y)) >= 1000.0) {
		if (MAX(fabs(playerp->p_x), fabs(playerp->p_y)) > D_BEYOND)
			label = "The Point of No Return";
		else
			label = "The Ashen Mountains";
	} else if (circle >= 55)
		label = "Morannon";
	else if (circle >= 35)
		label = "Kennaquahair";
	else if (circle >= 20)
		label = "The Dead Marshes";
	else if (circle >= 9)
		label = "The Outer Waste";
	else if (circle >= 5)
		label = "The Moors Adventurous";
	else {
		if (playerp->p_x == 0.0 && playerp->p_y == 0.0)
			label = "The Lord's Chamber";
		else {
			/* this expression is split to prevent compiler
			 * loop with some compilers */
			quadrant = ((playerp->p_x > 0.0) ? 1 : 0);
			quadrant += ((playerp->p_y >= 0.0) ? 2 : 0);
			label = nametable[((int) circle) - 1][quadrant];
		}
	}

	if (shortflag)
		snprintf(Databuf, sizeof Databuf, "%.29s", label);
	else
		snprintf(Databuf, sizeof Databuf,
			" is in %s  (%.0f,%.0f)", label, playerp->p_x, playerp->p_y);

	return (Databuf);
}
/**/
/************************************************************************
/
/ FUNCTION NAME: tradingpost()
/
/ FUNCTION: do trading post stuff
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: writerecord(), adjuststats(), fabs(), more(), sqrt(), 
/	sleep(), floor(), wmove(), drandom(), wclear(), printw(), 
/	altercoordinates(), infloat(), waddstr(), wrefresh(), mvprintw(), getanswer(), 
/	wclrtoeol(), wclrtobot()
/
/ GLOBAL INPUTS: Menu[], Circle, Player, *stdscr, Fileloc, Nobetter[]
/
/ GLOBAL OUTPUTS: Player
/
/ DESCRIPTION:
/	Different trading posts have different items.
/	Merchants cannot be cheated, but they can be dishonest
/	themselves.
/
/	Shields, swords, and quicksilver are not cumulative.  This is
/	one major area of complaint, but there are two reasons for this:
/		1) It becomes MUCH too easy to make very large versions
/		   of these items.
/		2) In the real world, one cannot simply weld two swords
/		   together to make a bigger one.
/
/	At one time, it was possible to sell old weapons at half the purchase
/	price.  This resulted in huge amounts of gold floating around,
/	and the game lost much of its challenge.
/
/	Also, purchasing gems defeats the whole purpose of gold.  Gold
/	is small change for lower level players.  They really shouldn't
/	be able to accumulate more than enough gold for a small sword or
/	a few books.  Higher level players shouldn't even bother to pick
/	up gold, except maybe to buy mana once in a while.
/
*************************************************************************/

void
tradingpost(void)
{
	double  numitems;	/* number of items to purchase */
	double  cost;		/* cost of purchase */
	double  blessingcost;	/* cost of blessing */
	int     ch;		/* input */
	int     size;		/* size of the trading post */
	int     loop;		/* loop counter */
	int     cheat = 0;	/* number of times player has tried to cheat */
	bool    dishonest = FALSE;	/* set when merchant is dishonest */

	Player.p_status = S_TRADING;
	writerecord(&Player, Fileloc);

	clear();
	addstr("You are at a trading post. All purchases must be made with gold.");

	size = sqrt(fabs(Player.p_x / 100)) + 1;
	size = MIN(7, size);

	/* set up cost of blessing */
	blessingcost = 1000.0 * (Player.p_level + 5.0);

	/* print Menu */
	move(7, 0);
	for (loop = 0; loop < size; ++loop)
		/* print Menu */
	{
		if (loop == 6)
			cost = blessingcost;
		else
			cost = Menu[loop].cost;
		printw("(%d) %-12s: %6.0f\n", loop + 1, Menu[loop].item, cost);
	}

	mvprintw(5, 0, "L:Leave  P:Purchase  S:Sell Gems ? ");

	for (;;) {
		adjuststats();	/* truncate any bad values */

		/* print some important statistics */
		mvprintw(1, 0, "Gold:   %9.0f  Gems:  %9.0f  Level:   %6.0f  Charms: %6d\n",
		    Player.p_gold, Player.p_gems, Player.p_level, Player.p_charms);
		printw("Shield: %9.0f  Sword: %9.0f  Quicksilver:%3.0f  Blessed: %s\n",
		    Player.p_shield, Player.p_sword, Player.p_quksilver,
		    (Player.p_blessing ? " True" : "False"));
		printw("Brains: %9.0f  Mana:  %9.0f", Player.p_brains, Player.p_mana);

		move(5, 36);
		ch = getanswer("LPS", FALSE);
		move(15, 0);
		clrtobot();
		switch (ch) {
		case 'L':	/* leave */
		case '\n':
			altercoordinates(0.0, 0.0, A_NEAR);
			return;

		case 'P':	/* make purchase */
			mvaddstr(15, 0, "What what would you like to buy ? ");
			ch = getanswer(" 1234567", FALSE);
			move(15, 0);
			clrtoeol();

			if (ch - '0' > size)
				addstr("Sorry, this merchant doesn't have that.");
			else
				switch (ch) {
				case '1':
					printw("Mana is one per %.0f gold piece.  How many do you want (%.0f max) ? ",
					    Menu[0].cost, floor(Player.p_gold / Menu[0].cost));
					cost = (numitems = floor(infloat())) * Menu[0].cost;

					if (cost > Player.p_gold || numitems < 0)
						++cheat;
					else {
						cheat = 0;
						Player.p_gold -= cost;
						if (drandom() < 0.02)
							dishonest = TRUE;
						else
							Player.p_mana += numitems;
					}
					break;

				case '2':
					printw("Shields are %.0f per +1.  How many do you want (%.0f max) ? ",
					    Menu[1].cost, floor(Player.p_gold / Menu[1].cost));
					cost = (numitems = floor(infloat())) * Menu[1].cost;

					if (numitems == 0.0)
						break;
					else if (cost > Player.p_gold || numitems < 0)
						++cheat;
					else if (numitems < Player.p_shield)
						NOBETTER();
					else {
						cheat = 0;
						Player.p_gold -= cost;
						if (drandom() < 0.02)
							dishonest = TRUE;
						else
							Player.p_shield = numitems;
					}
					break;

				case '3':
					printw("A book costs %.0f gp.  How many do you want (%.0f max) ? ",
					    Menu[2].cost, floor(Player.p_gold / Menu[2].cost));
					cost = (numitems = floor(infloat())) * Menu[2].cost;

					if (cost > Player.p_gold || numitems < 0)
						++cheat;
					else {
						cheat = 0;
						Player.p_gold -= cost;
						if (drandom() < 0.02)
							dishonest = TRUE;
						else if (drandom() * numitems > Player.p_level / 10.0
						    && numitems != 1) {
							printw("\nYou blew your mind!\n");
							Player.p_brains /= 5;
						} else {
							Player.p_brains += floor(numitems) * ROLL(20, 8);
						}
					}
					break;

				case '4':
					printw("Swords are %.0f gp per +1.  How many + do you want (%.0f max) ? ",
					    Menu[3].cost, floor(Player.p_gold / Menu[3].cost));
					cost = (numitems = floor(infloat())) * Menu[3].cost;

					if (numitems == 0.0)
						break;
					else if (cost > Player.p_gold || numitems < 0)
						++cheat;
					else if (numitems < Player.p_sword)
						NOBETTER();
					else {
						cheat = 0;
						Player.p_gold -= cost;
						if (drandom() < 0.02)
							dishonest = TRUE;
						else
							Player.p_sword = numitems;
					}
					break;

				case '5':
					printw("A charm costs %.0f gp.  How many do you want (%.0f max) ? ",
					    Menu[4].cost, floor(Player.p_gold / Menu[4].cost));
					cost = (numitems = floor(infloat())) * Menu[4].cost;

					if (cost > Player.p_gold || numitems < 0)
						++cheat;
					else {
						cheat = 0;
						Player.p_gold -= cost;
						if (drandom() < 0.02)
							dishonest = TRUE;
						else
							Player.p_charms += numitems;
					}
					break;

				case '6':
					printw("Quicksilver is %.0f gp per +1.  How many + do you want (%.0f max) ? ",
					    Menu[5].cost, floor(Player.p_gold / Menu[5].cost));
					cost = (numitems = floor(infloat())) * Menu[5].cost;

					if (numitems == 0.0)
						break;
					else if (cost > Player.p_gold || numitems < 0)
						++cheat;
					else if (numitems < Player.p_quksilver)
						NOBETTER();
					else {
						cheat = 0;
						Player.p_gold -= cost;
						if (drandom() < 0.02)
							dishonest = TRUE;
						else
							Player.p_quksilver = numitems;
					}
					break;

				case '7':
					if (Player.p_blessing) {
						addstr("You already have a blessing.");
						break;
					}
					printw("A blessing requires a %.0f gp donation.  Still want one ? ", blessingcost);
					ch = getanswer("NY", FALSE);

					if (ch == 'Y') {
						if (Player.p_gold < blessingcost)
							++cheat;
						else {
							cheat = 0;
							Player.p_gold -= blessingcost;
							if (drandom() < 0.02)
								dishonest = TRUE;
							else
								Player.p_blessing = TRUE;
						}
					}
					break;
				}
			break;

		case 'S':	/* sell gems */
			mvprintw(15, 0, "A gem is worth %.0f gp.  How many do you want to sell (%.0f max) ? ",
			    (double) N_GEMVALUE, Player.p_gems);
			numitems = floor(infloat());

			if (numitems > Player.p_gems || numitems < 0)
				++cheat;
			else {
				cheat = 0;
				Player.p_gems -= numitems;
				Player.p_gold += numitems * N_GEMVALUE;
			}
		}

		if (cheat == 1)
			mvaddstr(17, 0, "Come on, merchants aren't stupid.  Stop cheating.\n");
		else if (cheat == 2) {
			mvaddstr(17, 0, "You had your chance.  This merchant happens to be\n");
			printw("a %.0f level magic user, and you made %s mad!\n",
			    ROLL(Circle * 20.0, 40.0), (drandom() < 0.5) ? "him" : "her");
			altercoordinates(0.0, 0.0, A_FAR);
			Player.p_energy /= 2.0;
			++Player.p_sin;
			more(23);
			return;
		} else if (dishonest) {
			mvaddstr(17, 0, "The merchant stole your money!");
			refresh();
			altercoordinates(Player.p_x - Player.p_x / 10.0,
			    Player.p_y - Player.p_y / 10.0, A_SPECIFIC);
			sleep(2);
			return;
		}
	}
}
/**/
/************************************************************************
/
/ FUNCTION NAME: displaystats()
/
/ FUNCTION: print out important player statistics
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: descrstatus(), descrlocation(), mvprintw()
/
/ GLOBAL INPUTS: Users, Player
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	Important player statistics are printed on the screen.
/
*************************************************************************/

void
displaystats(void)
{
	mvprintw(0, 0, "%s%s\n", Player.p_name, descrlocation(&Player, FALSE));
	mvprintw(1, 0, "Level :%7.0f   Energy  :%9.0f(%9.0f)  Mana :%9.0f  Users:%3d\n",
	    Player.p_level, Player.p_energy, Player.p_maxenergy + Player.p_shield,
	    Player.p_mana, Users);
	mvprintw(2, 0, "Quick :%3.0f(%3.0f)  Strength:%9.0f(%9.0f)  Gold :%9.0f  %s\n",
	    Player.p_speed, Player.p_quickness + Player.p_quksilver, Player.p_might,
	    Player.p_strength + Player.p_sword, Player.p_gold, descrstatus(&Player));
}
/**/
/************************************************************************
/
/ FUNCTION NAME: allstatslist()
/
/ FUNCTION: show player items
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: mvprintw(), descrtype()
/
/ GLOBAL INPUTS: Player
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	Print out some player statistics of lesser importance.
/
*************************************************************************/

void
allstatslist(void)
{
	static char *flags[] =	/* to print value of some bools */
	{
		"False",
		" True"
	};

	mvprintw(8, 0, "Type: %s\n", descrtype(&Player, FALSE));

	mvprintw(10, 0, "Experience: %9.0f", Player.p_experience);
	mvprintw(11, 0, "Brains    : %9.0f", Player.p_brains);
	mvprintw(12, 0, "Magic Lvl : %9.0f", Player.p_magiclvl);
	mvprintw(13, 0, "Sin       : %9.5f", Player.p_sin);
	mvprintw(14, 0, "Poison    : %9.5f", Player.p_poison);
	mvprintw(15, 0, "Gems      : %9.0f", Player.p_gems);
	mvprintw(16, 0, "Age       : %9d", Player.p_age);
	mvprintw(10, 40, "Holy Water: %9d", Player.p_holywater);
	mvprintw(11, 40, "Amulets   : %9d", Player.p_amulets);
	mvprintw(12, 40, "Charms    : %9d", Player.p_charms);
	mvprintw(13, 40, "Crowns    : %9d", Player.p_crowns);
	mvprintw(14, 40, "Shield    : %9.0f", Player.p_shield);
	mvprintw(15, 40, "Sword     : %9.0f", Player.p_sword);
	mvprintw(16, 40, "Quickslver: %9.0f", Player.p_quksilver);

	mvprintw(18, 0, "Blessing: %s   Ring: %s   Virgin: %s   Palantir: %s",
	    flags[(int)Player.p_blessing],
	    flags[Player.p_ring.ring_type != R_NONE],
	    flags[(int)Player.p_virgin],
	    flags[(int)Player.p_palantir]);
}
/**/
/************************************************************************
/
/ FUNCTION NAME: descrtype()
/
/ FUNCTION: return a string specifying player type
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS:
/	struct player playerp - pointer to structure for player
/	bool shortflag - set if short form is desired
/
/ RETURN VALUE: pointer to string describing player type
/
/ MODULES CALLED: strlcpy()
/
/ GLOBAL INPUTS: Databuf[]
/
/ GLOBAL OUTPUTS: Databuf[]
/
/ DESCRIPTION:
/	Return a string describing the player type.
/	King, council, valar, supersedes other types.
/	The first character of the string is '*' if the player
/	has a crown.
/	If 'shortflag' is TRUE, return a 3 character string.
/
*************************************************************************/

char *
descrtype(struct player *playerp, bool shortflag)
{
	int     type;		/* for caluculating result subscript */
	static char *results[] =/* description table */
	{
		" Magic User", " MU",
		" Fighter", " F ",
		" Elf", " E ",
		" Dwarf", " D ",
		" Halfling", " H ",
		" Experimento", " EX",
		" Super", " S ",
		" King", " K ",
		" Council of Wise", " CW",
		" Ex-Valar", " EV",
		" Valar", " V ",
		" ? ", " ? "
	};

	type = playerp->p_type;

	switch (playerp->p_specialtype) {
	case SC_NONE:
		type = playerp->p_type;
		break;

	case SC_KING:
		type = 7;
		break;

	case SC_COUNCIL:
		type = 8;
		break;

	case SC_EXVALAR:
		type = 9;
		break;

	case SC_VALAR:
		type = 10;
		break;
	}

	type *= 2;		/* calculate offset */

	if (type > 20)
		/* error */
		type = 22;

	if (shortflag)
		/* use short descriptions */
		++type;

	if (playerp->p_crowns > 0) {
		strlcpy(Databuf, results[type], sizeof Databuf);
		Databuf[0] = '*';
		return (Databuf);
	} else
		return (results[type]);
}
/**/
/************************************************************************
/
/ FUNCTION NAME: findname()
/
/ FUNCTION: find location in player file of given name
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS:
/	char *name - name of character to look for
/	struct player *playerp - pointer of structure to fill
/
/ RETURN VALUE: location of player if found, -1 otherwise
/
/ MODULES CALLED: fread(), fseek(), strcmp()
/
/ GLOBAL INPUTS: Wizard, *Playersfp
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	Search the player file for the player of the given name.
/	If player is found, fill structure with player data.
/
*************************************************************************/

long
findname(char *name, struct player *playerp)
{
	long    loc = 0;	/* location in the file */

	fseek(Playersfp, 0L, SEEK_SET);
	while (fread(playerp, SZ_PLAYERSTRUCT, 1, Playersfp) == 1) {
		if (strcmp(playerp->p_name, name) == 0) {
			if (playerp->p_status != S_NOTUSED || Wizard)
				/* found it */
				return (loc);
		}
		loc += SZ_PLAYERSTRUCT;
	}

	return (-1);
}
/**/
/************************************************************************
/
/ FUNCTION NAME: allocrecord()
/
/ FUNCTION: find space in the player file for a new character
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: none
/
/ RETURN VALUE: location of free space in file
/
/ MODULES CALLED: initplayer(), writerecord(), fread(), fseek()
/
/ GLOBAL INPUTS: Other, *Playersfp
/
/ GLOBAL OUTPUTS: Player
/
/ DESCRIPTION:
/	Search the player file for an unused entry.  If none are found,
/	make one at the end of the file.
/
*************************************************************************/

long
allocrecord(void)
{
	long    loc = 0L;	/* location in file */

	fseek(Playersfp, 0L, SEEK_SET);
	while (fread(&Other, SZ_PLAYERSTRUCT, 1, Playersfp) == 1) {
		if (Other.p_status == S_NOTUSED)
			/* found an empty record */
			return (loc);
		else
			loc += SZ_PLAYERSTRUCT;
	}

	/* make a new record */
	initplayer(&Other);
	Player.p_status = S_OFF;
	writerecord(&Other, loc);

	return (loc);
}
/**/
/************************************************************************
/
/ FUNCTION NAME: freerecord()
/
/ FUNCTION: free up a record on the player file
/
/ AUTHOR: E. A. Estes, 2/7/86
/
/ ARGUMENTS:
/	struct player playerp - pointer to structure to free
/	long loc - location in file to free
/
/ RETURN VALUE: none
/
/ MODULES CALLED: writerecord()
/
/ GLOBAL INPUTS: none
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	Mark structure as not used, and update player file.
/
*************************************************************************/

void
freerecord(struct player *playerp, long loc)
{
	playerp->p_name[0] = CH_MARKDELETE;
	playerp->p_status = S_NOTUSED;
	writerecord(playerp, loc);
}
/**/
/************************************************************************
/
/ FUNCTION NAME: leavegame()
/
/ FUNCTION: leave game
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: freerecord(), writerecord(), cleanup()
/
/ GLOBAL INPUTS: Player, Fileloc
/
/ GLOBAL OUTPUTS: Player
/
/ DESCRIPTION:
/	Mark player as inactive, and cleanup.
/	Do not save players below level 1.
/
*************************************************************************/

void
leavegame(void)
{

	if (Player.p_level < 1.0)
		/* delete character */
		freerecord(&Player, Fileloc);
	else {
		Player.p_status = S_OFF;
		writerecord(&Player, Fileloc);
	}

	cleanup(TRUE);
}
/**/
/************************************************************************
/
/ FUNCTION NAME: death()
/
/ FUNCTION: death routine
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS:
/	char *how - pointer to string describing cause of death
/
/ RETURN VALUE: none
/
/ MODULES CALLED: freerecord(), enterscore(), more(), exit(), fread(), 
/	fseek(), execl(), fopen(), floor(), wmove(), drandom(), wclear(), strcmp(), 
/	fwrite(), fflush(), printw(), strlcpy(), fclose(), waddstr(), cleanup(), 
/	fprintf(), wrefresh(), getanswer(), descrtype()
/
/ GLOBAL INPUTS: Curmonster, Wizard, Player, *stdscr, Fileloc, *Monstfp
/
/ GLOBAL OUTPUTS: Player
/
/ DESCRIPTION:
/	Kill off current player.
/	Handle rings, and multiple lives.
/	Print an appropriate message.
/	Update scoreboard, lastdead, and let other players know about
/	the demise of their comrade.
/
*************************************************************************/

void
death(char *how)
{
	FILE   *fp;		/* for updating various files */
	int     ch;		/* input */
	static char *deathmesg[] =
	/* add more messages here, if desired */
	{
		"You have been wounded beyond repair.  ",
		"You have been disemboweled.  ",
		"You've been mashed, mauled, and spit upon.  (You're dead.)\n",
		"You died!  ",
		"You're a complete failure -- you've died!!\n",
		"You have been dealt a fatal blow!  "
	};

	clear();

	if (strcmp(how, "Stupidity") != 0) {
		if (Player.p_level > 9999.0)
			/* old age */
			addstr("Characters must be retired upon reaching level 10000.  Sorry.");
		else if (Player.p_lives > 0) {
			/* extra lives */
			addstr("You should be more cautious.  You've been killed.\n");
			printw("You only have %d more chance(s).\n", --Player.p_lives);
			more(3);
			Player.p_energy = Player.p_maxenergy;
			return;
		} else if (Player.p_specialtype == SC_VALAR) {
			addstr("You had your chances, but Valar aren't totally\n");
			addstr("immortal.  You are now left to wither and die . . .\n");
			more(3);
			Player.p_brains = Player.p_level / 25.0;
			Player.p_energy = Player.p_maxenergy /= 5.0;
			Player.p_quksilver = Player.p_sword = 0.0;
			Player.p_specialtype = SC_COUNCIL;
			return;
		} else if (Player.p_ring.ring_inuse &&
		    (Player.p_ring.ring_type == R_DLREG || Player.p_ring.ring_type == R_NAZREG))
			/* good ring in use - saved from death */
		{
			mvaddstr(4, 0, "Your ring saved you from death!\n");
			refresh();
			Player.p_ring.ring_type = R_NONE;
			Player.p_energy = Player.p_maxenergy / 12.0 + 1.0;
			if (Player.p_crowns > 0)
				--Player.p_crowns;
			return;
		} else if (Player.p_ring.ring_type == R_BAD
		    || Player.p_ring.ring_type == R_SPOILED)
			/* bad ring in possession; name idiot after player */
		{
			mvaddstr(4, 0,
			    "Your ring has taken control of you and turned you into a monster!\n");
			fseek(Monstfp, 13L * SZ_MONSTERSTRUCT, SEEK_SET);
			fread(&Curmonster, SZ_MONSTERSTRUCT, 1, Monstfp);
			strlcpy(Curmonster.m_name, Player.p_name,
			    sizeof Curmonster.m_name);
			fseek(Monstfp, 13L * SZ_MONSTERSTRUCT, SEEK_SET);
			fwrite(&Curmonster, SZ_MONSTERSTRUCT, 1, Monstfp);
			fflush(Monstfp);
		}
	}
	enterscore();		/* update score board */

	/* put info in last dead file */
	fp = fopen(_PATH_LASTDEAD, "w");
	fprintf(fp, "%s (%s, run by %s, level %.0f, killed by %s)",
	    Player.p_name, descrtype(&Player, TRUE),
	    Player.p_login, Player.p_level, how);
	fclose(fp);

	/* let other players know */
	fp = fopen(_PATH_MESS, "w");
	fprintf(fp, "%s was killed by %s.", Player.p_name, how);
	fclose(fp);

	freerecord(&Player, Fileloc);

	clear();
	move(10, 0);
	addstr(deathmesg[(int) ROLL(0.0, (double) sizeof(deathmesg) / sizeof(char *))]);
	addstr("Care to give it another try ? ");
	ch = getanswer("NY", FALSE);

	if (ch == 'Y') {
		cleanup(FALSE);
		execl(_PATH_GAMEPROG, "phantasia", "-s",
		    (Wizard ? "-S" : (char *)NULL), (char *)NULL);
		exit(0);
	}
	cleanup(TRUE);
}
/**/
/************************************************************************
/
/ FUNCTION NAME: writerecord()
/
/ FUNCTION: update structure in player file
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS:
/	struct player *playerp - pointer to structure to write out
/	long place - location in file to updata
/
/ RETURN VALUE: none
/
/ MODULES CALLED: fseek(), fwrite(), fflush()
/
/ GLOBAL INPUTS: *Playersfp
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	Update location in player file with given structure.
/
*************************************************************************/

void
writerecord(struct player *playerp, long place)
{
	fseek(Playersfp, place, SEEK_SET);
	fwrite(playerp, SZ_PLAYERSTRUCT, 1, Playersfp);
	fflush(Playersfp);
}
/**/
/************************************************************************
/
/ FUNCTION NAME: explevel()
/
/ FUNCTION: calculate level based upon experience
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS:
/	double experience - experience to calculate experience level from
/
/ RETURN VALUE: experience level
/
/ MODULES CALLED: pow(), floor()
/
/ GLOBAL INPUTS: none
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION: 
/	Experience level is a geometric progression.  This has been finely
/	tuned over the years, and probably should not be changed.
/
*************************************************************************/

double
explevel(double experience)
{
	if (experience < 1.1e7)
		return (floor(pow((experience / 1000.0), 0.4875)));
	else
		return (floor(pow((experience / 1250.0), 0.4865)));
}
/**/
/************************************************************************
/
/ FUNCTION NAME: truncstring()
/
/ FUNCTION: truncate trailing blanks off a string
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: 
/	char *string - pointer to null terminated string
/
/ RETURN VALUE: none
/
/ MODULES CALLED: strlen()
/
/ GLOBAL INPUTS: none
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION: 
/	Put nul characters in place of spaces at the end of the string.
/
*************************************************************************/

void
truncstring(char *string)
{
	int     length;		/* length of string */

	length = strlen(string);
	while (string[--length] == ' ')
		string[length] = '\0';
}
/**/
/************************************************************************
/
/ FUNCTION NAME: altercoordinates()
/
/ FUNCTION: Alter x, y coordinates and set/check location flags
/
/ AUTHOR: E. A. Estes, 12/16/85
/
/ ARGUMENTS: 
/	double xnew, ynew - new x, y coordinates
/	int operation - operation to perform with coordinates
/
/ RETURN VALUE: none
/
/ MODULES CALLED: fabs(), floor(), drandom(), distance()
/
/ GLOBAL INPUTS: Circle, Beyond, Player
/
/ GLOBAL OUTPUTS: Marsh, Circle, Beyond, Throne, Player, Changed
/
/ DESCRIPTION: 
/	This module is called whenever the player's coordinates are altered.
/	If the player is beyond the point of no return, he/she is forced
/	to stay there.
/
*************************************************************************/

void
altercoordinates(double xnew, double ynew, int operation)
{
	switch (operation) {
	case A_FORCED:		/* move with no checks */
		break;

	case A_NEAR:		/* pick random coordinates near */
		xnew = Player.p_x + ROLL(1.0, 5.0);
		ynew = Player.p_y - ROLL(1.0, 5.0);
		/* fall through for check */

	case A_SPECIFIC:	/* just move player */
		if (Beyond && fabs(xnew) < D_BEYOND && fabs(ynew) < D_BEYOND)
			/*
			 * cannot move back from point of no return
			 * pick the largest coordinate to remain unchanged
			 */
		{
			if (fabs(xnew) > fabs(ynew))
				xnew = SGN(Player.p_x) * MAX(fabs(Player.p_x), D_BEYOND);
			else
				ynew = SGN(Player.p_y) * MAX(fabs(Player.p_y), D_BEYOND);
		}
		break;

	case A_FAR:		/* pick random coordinates far */
		xnew = Player.p_x + SGN(Player.p_x) * ROLL(50 * Circle, 250 * Circle);
		ynew = Player.p_y + SGN(Player.p_y) * ROLL(50 * Circle, 250 * Circle);
		break;
	}

	/* now set location flags and adjust coordinates */
	Circle = CIRCLE(Player.p_x = floor(xnew), Player.p_y = floor(ynew));

	/* set up flags based upon location */
	Throne = Marsh = Beyond = FALSE;

	if (Player.p_x == 0.0 && Player.p_y == 0.0)
		Throne = TRUE;
	else if (Circle < 35 && Circle >= 20)
		Marsh = TRUE;
	else if (MAX(fabs(Player.p_x), fabs(Player.p_y)) >= D_BEYOND)
		Beyond = TRUE;

	Changed = TRUE;
}
/**/
/************************************************************************
/
/ FUNCTION NAME: readrecord()
/
/ FUNCTION: read a player structure from file
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS:
/	struct player *playerp - pointer to structure to fill
/	int loc - location of record to read
/
/ RETURN VALUE: none
/
/ MODULES CALLED: fread(), fseek()
/
/ GLOBAL INPUTS: *Playersfp
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	Read structure information from player file.
/
*************************************************************************/

void
readrecord(struct player *playerp, long loc)
{
	fseek(Playersfp, loc, SEEK_SET);
	fread(playerp, SZ_PLAYERSTRUCT, 1, Playersfp);
}
/**/
/************************************************************************
/
/ FUNCTION NAME: adjuststats()
/
/ FUNCTION: adjust player statistics
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: death(), floor(), drandom(), explevel(), movelevel()
/
/ GLOBAL INPUTS: Player, *Statptr
/
/ GLOBAL OUTPUTS: Circle, Player, Timeout
/
/ DESCRIPTION:
/	Handle adjustment and maximums on various player characteristics.
/
*************************************************************************/

void
adjuststats(void)
{
	double  dtemp;		/* for temporary calculations */

	if (explevel(Player.p_experience) > Player.p_level)
		/* move one or more levels */
	{
		movelevel();
		if (Player.p_level > 5.0)
			Timeout = TRUE;
	}
	if (Player.p_specialtype == SC_VALAR)
		/* valar */
		Circle = Player.p_level / 5.0;

	/* calculate effective quickness */
	dtemp = ((Player.p_gold + Player.p_gems / 2.0) - 1000.0) / Statptr->c_goldtote
	    - Player.p_level;
	dtemp = MAX(0.0, dtemp);/* gold slows player down */
	Player.p_speed = Player.p_quickness + Player.p_quksilver - dtemp;

	/* calculate effective strength */
	if (Player.p_poison > 0.0)
		/* poison makes player weaker */
	{
		dtemp = 1.0 - Player.p_poison * Statptr->c_weakness / 800.0;
		dtemp = MAX(0.1, dtemp);
	} else
		dtemp = 1.0;
	Player.p_might = dtemp * Player.p_strength + Player.p_sword;

	/* insure that important things are within limits */
	Player.p_quksilver = MIN(99.0, Player.p_quksilver);
	Player.p_mana = MIN(Player.p_mana,
	    Player.p_level * Statptr->c_maxmana + 1000.0);
	Player.p_brains = MIN(Player.p_brains,
	    Player.p_level * Statptr->c_maxbrains + 200.0);
	Player.p_charms = MIN(Player.p_charms, Player.p_level + 10.0);

	/*
         * some implementations have problems with floating point compare
         * we work around it with this stuff
         */
	Player.p_gold = floor(Player.p_gold) + 0.1;
	Player.p_gems = floor(Player.p_gems) + 0.1;
	Player.p_mana = floor(Player.p_mana) + 0.1;

	if (Player.p_ring.ring_type != R_NONE)
		/* do ring things */
	{
		/* rest to max */
		Player.p_energy = Player.p_maxenergy + Player.p_shield;

		if (Player.p_ring.ring_duration <= 0)
			/* clean up expired rings */
			switch (Player.p_ring.ring_type) {
			case R_BAD:	/* ring drives player crazy */
				Player.p_ring.ring_type = R_SPOILED;
				Player.p_ring.ring_duration = (short) ROLL(10.0, 25.0);
				break;

			case R_NAZREG:	/* ring disappears */
				Player.p_ring.ring_type = R_NONE;
				break;

			case R_SPOILED:	/* ring kills player */
				death("A cursed ring");
				break;

			case R_DLREG:	/* this ring doesn't expire */
				Player.p_ring.ring_duration = 0;
				break;
			}
	}
	if (Player.p_age / N_AGE > Player.p_degenerated)
		/* age player slightly */
	{
		++Player.p_degenerated;
		if (Player.p_quickness > 23.0)
			Player.p_quickness *= 0.99;
		Player.p_strength *= 0.97;
		Player.p_brains *= 0.95;
		Player.p_magiclvl *= 0.97;
		Player.p_maxenergy *= 0.95;
		Player.p_quksilver *= 0.95;
		Player.p_sword *= 0.93;
		Player.p_shield *= 0.93;
	}
}
/**/
/************************************************************************
/
/ FUNCTION NAME: initplayer()
/
/ FUNCTION: initialize a character
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS:
/	struct player *playerp - pointer to structure to init
/
/ RETURN VALUE: none
/
/ MODULES CALLED: floor(), drandom()
/
/ GLOBAL INPUTS: none
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	Put a bunch of default values in the given structure.
/
*************************************************************************/

void
initplayer(struct player *playerp)
{
	playerp->p_experience =
	    playerp->p_level =
	    playerp->p_strength =
	    playerp->p_sword =
	    playerp->p_might =
	    playerp->p_energy =
	    playerp->p_maxenergy =
	    playerp->p_shield =
	    playerp->p_quickness =
	    playerp->p_quksilver =
	    playerp->p_speed =
	    playerp->p_magiclvl =
	    playerp->p_mana =
	    playerp->p_brains =
	    playerp->p_poison =
	    playerp->p_gems =
	    playerp->p_sin =
	    playerp->p_1scratch =
	    playerp->p_2scratch = 0.0;

	playerp->p_gold = ROLL(50.0, 75.0) + 0.1;	/* give some gold */

	playerp->p_x = ROLL(-125.0, 251.0);
	playerp->p_y = ROLL(-125.0, 251.0);	/* give random x, y */

	/* clear ring */
	playerp->p_ring.ring_type = R_NONE;
	playerp->p_ring.ring_duration = 0;
	playerp->p_ring.ring_inuse = FALSE;

	playerp->p_age = 0L;

	playerp->p_degenerated = 1;	/* don't degenerate initially */

	playerp->p_type = C_FIGHTER;	/* default */
	playerp->p_specialtype = SC_NONE;
	playerp->p_lives =
	    playerp->p_crowns =
	    playerp->p_charms =
	    playerp->p_amulets =
	    playerp->p_holywater =
	    playerp->p_lastused = 0;
	playerp->p_status = S_NOTUSED;
	playerp->p_tampered = T_OFF;
	playerp->p_istat = I_OFF;

	playerp->p_palantir =
	    playerp->p_blessing =
	    playerp->p_virgin =
	    playerp->p_blindness = FALSE;

	playerp->p_name[0] =
	    playerp->p_password[0] =
	    playerp->p_login[0] = '\0';
}
/**/
/************************************************************************
/
/ FUNCTION NAME: readmessage()
/
/ FUNCTION: read message from other players
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: fseek(), fgets(), wmove(), waddstr(), wclrtoeol()
/
/ GLOBAL INPUTS: *stdscr, Databuf[], *Messagefp
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	If there is a message from other players, print it.
/
*************************************************************************/

void
readmessage(void)
{
	move(3, 0);
	clrtoeol();
	fseek(Messagefp, 0L, SEEK_SET);
	if (fgets(Databuf, SZ_DATABUF, Messagefp) != NULL)
		addstr(Databuf);
}
/**/
/************************************************************************
/
/ FUNCTION NAME: error()
/
/ FUNCTION: process environment error
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS:
/	char *whichfile - pointer to name of file which caused error
/
/ RETURN VALUE: none
/
/ MODULES CALLED: wclear(), cleanup()
/
/ GLOBAL INPUTS: errno, *stdscr, printf(), Windows
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	Print message about offending file, and exit.
/
*************************************************************************/

__dead void
error(char *whichfile)
{

	if (Windows)
		clear();
	cleanup(FALSE);

	warn("%s", whichfile);
	fprintf(stderr, "Please run 'setup' to determine the problem.\n");
	exit(1);
}
/**/
/************************************************************************
/
/ FUNCTION NAME: distance()
/
/ FUNCTION: calculate distance between two points
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS: 
/	double x1, y1 - x, y coordinates of first point
/	double x2, y2 - x, y coordinates of second point
/
/ RETURN VALUE: distance between the two points
/
/ MODULES CALLED: sqrt()
/
/ GLOBAL INPUTS: none
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	This function is provided because someone's hypot() library function
/	fails if x1 == x2 && y1 == y2.
/
*************************************************************************/

double
distance(double x1, double x2, double y1, double y2)
{
	double  deltax, deltay;

	deltax = x1 - x2;
	deltay = y1 - y2;
	return (sqrt(deltax * deltax + deltay * deltay));
}
/************************************************************************
/
/ FUNCTION NAME: descrstatus()
/
/ FUNCTION: return a string describing the player status
/
/ AUTHOR: E. A. Estes, 3/3/86
/
/ ARGUMENTS:
/	struct player playerp - pointer to player structure to describe
/
/ RETURN VALUE: string describing player's status
/
/ MODULES CALLED: none
/
/ GLOBAL INPUTS: none
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	Return verbal description of player status.
/	If player status is S_PLAYING, check for low energy and blindness.
/
*************************************************************************/

char *
descrstatus(struct player *playerp)
{
	switch (playerp->p_status) {
	case S_PLAYING:
		if (playerp->p_energy < 0.2 * (playerp->p_maxenergy + playerp->p_shield))
			return ("Low Energy");
		else if (playerp->p_blindness)
			return ("Blind");
		else
			return ("In game");

	case S_CLOAKED:
		return ("Cloaked");

	case S_INBATTLE:
		return ("In Battle");

	case S_MONSTER:
		return ("Encounter");

	case S_TRADING:
		return ("Trading");

	case S_OFF:
		return ("Off");

	case S_HUNGUP:
		return ("Hung up");

	default:
		return ("");
	}
}
/**/
/************************************************************************
/
/ FUNCTION NAME: drandom()
/
/ FUNCTION: return a random floating point number from 0.0 < 1.0
/
/ AUTHOR: E. A. Estes, 2/7/86
/
/ ARGUMENTS: none
/
/ RETURN VALUE: none
/
/ MODULES CALLED: arc4random()
/
/ GLOBAL INPUTS: none
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	Convert random integer from library routine into a floating
/	point number, and divide by the largest possible random number.
/
*************************************************************************/

double
drandom(void)
{
	return ((double) arc4random() / (UINT32_MAX + 1.0));
}
/**/
/************************************************************************
/
/ FUNCTION NAME: collecttaxes()
/
/ FUNCTION: collect taxes from current player
/
/ AUTHOR: E. A. Estes, 2/7/86
/
/ ARGUMENTS:
/	double gold - amount of gold to tax
/	double gems - amount of gems to tax
/
/ RETURN VALUE: none
/
/ MODULES CALLED: fread(), fseek(), fopen(), floor(), fwrite(), fclose()
/
/ GLOBAL INPUTS: Player
/
/ GLOBAL OUTPUTS: Player
/
/ DESCRIPTION:
/	Pay taxes on gold and gems.  If the player does not have enough
/	gold to pay taxes on the added gems, convert some gems to gold.
/	Add taxes to tax data base; add remaining gold and gems to
/	player's cache.
/
*************************************************************************/

void
collecttaxes(double gold, double gems)
{
	FILE   *fp;		/* to update Goldfile */
	double  dtemp;		/* for temporary calculations */
	double  taxes;		/* tax liability */

	/* add to cache */
	Player.p_gold += gold;
	Player.p_gems += gems;

	/* calculate tax liability */
	taxes = N_TAXAMOUNT / 100.0 * (N_GEMVALUE * gems + gold);

	if (Player.p_gold < taxes)
		/* not enough gold to pay taxes, must convert some gems to
		 * gold */
	{
		dtemp = floor(taxes / N_GEMVALUE + 1.0);	/* number of gems to
								 * convert */

		if (Player.p_gems >= dtemp)
			/* player has enough to convert */
		{
			Player.p_gems -= dtemp;
			Player.p_gold += dtemp * N_GEMVALUE;
		} else
			/* take everything; this should never happen */
		{
			Player.p_gold += Player.p_gems * N_GEMVALUE;
			Player.p_gems = 0.0;
			taxes = Player.p_gold;
		}
	}
	Player.p_gold -= taxes;

	if ((fp = fopen(_PATH_GOLD, "r+")) != NULL)
		/* update taxes */
	{
		dtemp = 0.0;
		fread(&dtemp, sizeof(double), 1, fp);
		dtemp += floor(taxes);
		fseek(fp, 0L, SEEK_SET);
		fwrite(&dtemp, sizeof(double), 1, fp);
		fclose(fp);
	}
}
@


1.20
log
@Remove unnecessary header files from phantasia(6)

Lesson learnt: don't include an header sorted alphabetically just because. The
external definition of variables was done on phantglobs.h but their declaration
was on phantstruct.h and therefore the latter must be included before the
former. It's easier to just include phantstruct.h inside phantglobs.h since it
always need it.

With help and OK from tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.19 2016/01/06 09:43:26 tb Exp $	*/
a814 1
	/* NOTREACHED */
a938 1
		/* NOTREACHED */
a940 1
	/* NOTREACHED */
a1415 1
	/* NOTREACHED */
@


1.19
log
@Last step of ansification of phantasia:
Convert function() to function(void).

ok mestre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.17 2015/12/26 00:26:39 mestre Exp $	*/
d8 1
d10 6
a15 1
#include "include.h"
d17 4
@


1.18
log
@Ansify the bulk of phantasia.  No binary change on amd64.  Based
on an older diff by mestre.

ok mestre@@
@
text
@d40 1
a40 1
movelevel()
d216 1
a216 1
tradingpost()
d487 1
a487 1
displaystats()
d522 1
a522 1
allstatslist()
d714 1
a714 1
allocrecord()
d793 1
a793 1
leavegame()
@


1.17
log
@Set as __dead a few more functions, that don't return, on games/

With precious tip, help and also OK from tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.16 2014/07/12 03:41:04 deraadt Exp $	*/
d118 2
a119 4
char   *
descrlocation(playerp, shortflag)
	struct player *playerp;
	bool    shortflag;
d583 2
a584 4
char   *
descrtype(playerp, shortflag)
	struct player *playerp;
	bool    shortflag;
d672 1
a672 3
findname(name, playerp)
	char   *name;
	struct player *playerp;
d761 1
a761 3
freerecord(playerp, loc)
	struct player *playerp;
	long    loc;
d840 1
a840 2
death(how)
	char   *how;
d962 1
a962 3
writerecord(playerp, place)
	struct player *playerp;
	long    place;
d995 1
a995 2
explevel(experience)
	double  experience;
d1028 1
a1028 2
truncstring(string)
	char   *string;
d1065 1
a1065 4
altercoordinates(xnew, ynew, operation)
	double  xnew;
	double  ynew;
	int     operation;
d1138 1
a1138 3
readrecord(playerp, loc)
	struct player *playerp;
	long    loc;
d1168 1
a1168 1
adjuststats()
d1283 1
a1283 2
initplayer(playerp)
	struct player *playerp;
d1365 1
a1365 1
readmessage()
d1399 1
a1399 2
error(whichfile)
	char	*whichfile;
d1439 1
a1439 2
distance(x1, x2, y1, y2)
	double  x1, x2, y1, y2;
d1473 1
a1473 2
descrstatus(playerp)
	struct player *playerp;
d1532 1
a1532 1
drandom()
d1566 1
a1566 3
collecttaxes(gold, gems)
	double  gold;
	double  gems;
@


1.16
log
@Remove a pile of (obviously unused) #ifdef SYSV and BSD41 and BSD42
code that catches lots of signals, and then re-enters curses... before
exiting.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.15 2013/08/29 20:22:17 naddy Exp $	*/
d1417 1
a1417 1
void
@


1.15
log
@replace srandomdev()+random() with the arc4random*() family
tweaks and ok millert@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.14 2010/12/15 06:40:39 tedu Exp $	*/
a1467 36
/**/
/************************************************************************
/
/ FUNCTION NAME: ill_sig()
/
/ FUNCTION: exit upon trapping an illegal signal
/
/ AUTHOR: E. A. Estes, 12/4/85
/
/ ARGUMENTS:
/	int whichsig - signal which occurred to cause jump to here
/
/ RETURN VALUE: none
/
/ MODULES CALLED: wclear(), printw(), cleanup()
/
/ GLOBAL INPUTS: *stdscr
/
/ GLOBAL OUTPUTS: none
/
/ DESCRIPTION:
/	When an illegal signal is caught, print a message, and cleanup.
/
*************************************************************************/

void
ill_sig(whichsig)
	int     whichsig;
{
	clear();
	if (!(whichsig == SIGINT || whichsig == SIGQUIT))
		printw("Error: caught signal # %d.\n", whichsig);
	cleanup(TRUE);
	/* NOTREACHED */
}
/**/
@


1.14
log
@as of 1989, fread/fwrite take void *, so there's no need to cast to char *.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.13 2003/08/06 21:08:05 millert Exp $	*/
d1577 1
a1577 1
/ MODULES CALLED: random()
a1585 2
/	We mask large integers with 32767 to handle sites that return
/	31 bit random integers.
d1592 1
a1592 5
	if (sizeof(int) != 2)
		/* use only low bits */
		return ((double) (random() & 0x7fff) / 32768.0);
	else
		return ((double) random() / 32768.0);
@


1.13
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.12 2003/04/25 21:37:47 deraadt Exp $	*/
d683 1
a683 1
	while (fread((char *) playerp, SZ_PLAYERSTRUCT, 1, Playersfp) == 1) {
d725 1
a725 1
	while (fread((char *) &Other, SZ_PLAYERSTRUCT, 1, Playersfp) == 1) {
d904 1
a904 1
			fread((char *) &Curmonster, SZ_MONSTERSTRUCT, 1, Monstfp);
d908 1
a908 1
			fwrite((char *) &Curmonster, SZ_MONSTERSTRUCT, 1, Monstfp);
d976 1
a976 1
	fwrite((char *) playerp, SZ_PLAYERSTRUCT, 1, Playersfp);
d1159 1
a1159 1
	fread((char *) playerp, SZ_PLAYERSTRUCT, 1, Playersfp);
d1671 1
a1671 1
		fread((char *) &dtemp, sizeof(double), 1, fp);
d1674 1
a1674 1
		fwrite((char *) &dtemp, sizeof(double), 1, fp);
@


1.12
log
@comment repair
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.11 2003/04/06 18:50:38 deraadt Exp $	*/
d1203 1
a1203 1
	    - Player.p_level;;
@


1.11
log
@2451 lines of strdup/sprintf/strcpy whacking.  mostly ok'd by pjanzen
already, but he may have later changes to make still.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.10 2003/03/11 04:47:39 david Exp $	*/
d106 1
a106 1
/ MODULES CALLED: fabs(), floor(), sprintf(), distance()
d570 1
a570 1
/ MODULES CALLED: strcpy()
d831 1
a831 1
/	fwrite(), fflush(), printw(), strcpy(), fclose(), waddstr(), cleanup(), 
@


1.10
log
@double words and spelling fixes
ok pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.9 2001/09/19 10:51:55 pjanzen Exp $	*/
d164 1
a164 1
		sprintf(Databuf, "%.29s", label);
d166 2
a167 1
		sprintf(Databuf, " is in %s  (%.0f,%.0f)", label, playerp->p_x, playerp->p_y);
d642 1
a642 1
		strcpy(Databuf, results[type]);
d905 2
a906 1
			strcpy(Curmonster.m_name, Player.p_name);
@


1.9
log
@occured->occurred; from NetBSD via Mike Pechkin <mpech@@prosoft.org.lv>.
One of these was even in a string that got printed out.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.8 2001/07/09 07:04:29 deraadt Exp $	*/
d577 1
a577 1
/	King, council, valar, supercedes other types.
@


1.8
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.7 2001/02/04 02:51:25 pjanzen Exp $	*/
d1476 1
a1476 1
/	int whichsig - signal which occured to cause jump to here
@


1.7
log
@Tidy, avoid segfaults on unknown users, and deal with long usernames
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.6 2000/06/29 07:39:45 pjanzen Exp $	*/
d935 1
a935 1
		    (Wizard ? "-S" : (char *) NULL), 0);
@


1.6
log
@use SEEK_SET; improve an error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.5 1998/11/29 19:56:58 pjanzen Exp $	*/
d1395 1
a1395 1
/ FUNCTION: process evironment error
@


1.5
log
@NetBSD merge (mainly -Wall related)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d8 1
d681 1
a681 1
	fseek(Playersfp, 0L, 0);
d723 1
a723 1
	fseek(Playersfp, 0L, 0);
d902 1
a902 1
			fseek(Monstfp, 13L * SZ_MONSTERSTRUCT, 0);
d905 1
a905 1
			fseek(Monstfp, 13L * SZ_MONSTERSTRUCT, 0);
d973 1
a973 1
	fseek(Playersfp, place, 0);
d1156 1
a1156 1
	fseek(Playersfp, loc, 0);
d1386 1
a1386 1
	fseek(Messagefp, 0L, 0);
d1424 2
a1425 2
	printf("An unrecoverable error has occurred reading %s.  (errno = %d)\n", whichfile, errno);
	printf("Please run 'setup' to determine the problem.\n");
d1671 1
a1671 1
		fseek(fp, 0L, 0);
@


1.4
log
@Clear up a warning:  printw doesn't take a const char, printf does
@
text
@d1 1
d38 1
d41 22
a62 22
register struct charstats	*statptr;	/* for pointing into Stattable */
double	new;			/* new level */
double	inc;			/* increment between new and old levels */

    Changed = TRUE;

    if (Player.p_type == C_EXPER)
	/* roll a type to use for increment */
	statptr = &Stattable[(int) ROLL(C_MAGIC, C_HALFLING - C_MAGIC + 1)];
    else
	statptr = Statptr;

    new = explevel(Player.p_experience);
    inc = new - Player.p_level;
    Player.p_level = new;

    /* add increments to statistics */
    Player.p_strength += statptr->c_strength.increase * inc;
    Player.p_mana += statptr->c_mana.increase * inc;
    Player.p_brains += statptr->c_brains.increase * inc;
    Player.p_magiclvl += statptr->c_magiclvl.increase * inc;
    Player.p_maxenergy += statptr->c_energy.increase * inc;
d64 2
a65 2
    /* rest to maximum upon reaching new level */
    Player.p_energy = Player.p_maxenergy + Player.p_shield;
d67 2
a68 2
    if (Player.p_crowns > 0 && Player.p_level >= 1000.0)
	/* no longer able to be king -- turn crowns into cash */
d70 2
a71 2
	Player.p_gold += ((double) Player.p_crowns) * 5000.0;
	Player.p_crowns = 0;
d73 2
a74 3

    if (Player.p_level >= 3000.0 && Player.p_specialtype < SC_COUNCIL)
	/* make a member of the council */
d76 2
a77 2
	mvaddstr(6, 0, "You have made it to the Council of the Wise.\n");
	addstr("Good Luck on your search for the Holy Grail.\n");
d79 1
a79 1
	Player.p_specialtype = SC_COUNCIL;
d81 3
a83 3
	/* no rings for council and above */
	Player.p_ring.ring_type = R_NONE;
	Player.p_ring.ring_duration = 0;
d85 1
a85 1
	Player.p_lives = 3;		/* three extra lives */
d87 2
a88 3

    if (Player.p_level > 9999.0 && Player.p_specialtype != SC_VALAR)
	death("Old age");
d117 1
a117 1
char	*
d119 2
a120 2
struct player	*playerp;
bool	shortflag;
d122 9
a130 9
double	circle;			/* corresponding circle for coordinates */
register int	quadrant;	/* quandrant of grid */
register char	*label;		/* pointer to place name */
static char	*nametable[4][4] =   /* names of places */
	{
	"Anorien",	"Ithilien",	"Rohan",	"Lorien",
	"Gondor",	"Mordor",	"Dunland",	"Rovanion",
	"South Gondor", "Khand",	"Eriador",	"The Iron Hills",
	"Far Harad",	"Near Harad",	"The Northern Waste", "Rhun"
d133 27
a159 8
    if (playerp->p_specialtype == SC_VALAR)
	return(" is in Valhala");
    else if ((circle = CIRCLE(playerp->p_x, playerp->p_y)) >= 1000.0)
	{
	if (MAX(fabs(playerp->p_x), fabs(playerp->p_y)) > D_BEYOND)
	    label = "The Point of No Return";
	else
	    label = "The Ashen Mountains";
d161 3
a163 14
    else if (circle >= 55)
	label = "Morannon";
    else if (circle >= 35)
	label = "Kennaquahair";
    else if (circle >= 20)
	label = "The Dead Marshes";
    else if (circle >= 9)
	label = "The Outer Waste";
    else if (circle >= 5)
	label = "The Moors Adventurous";
    else
	{
	if (playerp->p_x == 0.0 && playerp->p_y == 0.0)
	    label = "The Lord's Chamber";
d165 1
a165 12
	    {
	    /* this expression is split to prevent compiler loop with some compilers */
	    quadrant = ((playerp->p_x > 0.0) ? 1 : 0);
	    quadrant += ((playerp->p_y >= 0.0) ? 2 : 0);
	    label = nametable[((int) circle) - 1][quadrant];
	    }
	}

    if (shortflag)
	sprintf(Databuf, "%.29s", label);
    else
	sprintf(Databuf, " is in %s  (%.0f,%.0f)", label, playerp->p_x, playerp->p_y);
d167 1
a167 1
    return(Databuf);
d215 1
d218 11
a228 32
double	numitems;	/* number of items to purchase */
double	cost;		/* cost of purchase */
double	blessingcost;	/* cost of blessing */
int	ch;		/* input */
register int	size;	/* size of the trading post */
register int	loop;	/* loop counter */
int	cheat = 0;	/* number of times player has tried to cheat */
bool	dishonest = FALSE;/* set when merchant is dishonest */

    Player.p_status = S_TRADING;
    writerecord(&Player, Fileloc);

    clear();
    addstr("You are at a trading post. All purchases must be made with gold.");

    size = sqrt(fabs(Player.p_x / 100)) + 1;
    size = MIN(7, size);

    /* set up cost of blessing */
    blessingcost = 1000.0 * (Player.p_level + 5.0);

    /* print Menu */
    move(7, 0);
    for (loop = 0; loop < size; ++loop)
	/* print Menu */
	{
	if (loop == 6)
	    cost = blessingcost;
	else
	    cost = Menu[loop].cost;
	printw("(%d) %-12s: %6.0f\n", loop + 1, Menu[loop].item, cost);
	}
d230 2
a231 1
    mvprintw(5, 0, "L:Leave  P:Purchase  S:Sell Gems ? ");
d233 2
a234 3
    for (;;)
	{
	adjuststats();	/* truncate any bad values */
d236 2
a237 24
	/* print some important statistics */
	mvprintw(1, 0, "Gold:   %9.0f  Gems:  %9.0f  Level:   %6.0f  Charms: %6d\n",
	    Player.p_gold, Player.p_gems, Player.p_level, Player.p_charms);
	printw("Shield: %9.0f  Sword: %9.0f  Quicksilver:%3.0f  Blessed: %s\n",
	    Player.p_shield, Player.p_sword, Player.p_quksilver,
	    (Player.p_blessing ? " True" : "False"));
	printw("Brains: %9.0f  Mana:  %9.0f", Player.p_brains, Player.p_mana);

	move(5, 36);
	ch = getanswer("LPS", FALSE);
	move(15, 0);
	clrtobot();
	switch(ch)
	    {
	    case 'L':		/* leave */
	    case '\n':
		altercoordinates(0.0, 0.0, A_NEAR);
		return;

	    case 'P':		/* make purchase */
		mvaddstr(15, 0, "What what would you like to buy ? ");
		ch = getanswer(" 1234567", FALSE);
		move(15, 0);
		clrtoeol();
d239 7
a245 2
		if (ch - '0' > size)
		    addstr("Sorry, this merchant doesn't have that.");
d247 3
a249 41
		    switch (ch)
			{
			case '1':
			    printw("Mana is one per %.0f gold piece.  How many do you want (%.0f max) ? ",
				Menu[0].cost, floor(Player.p_gold / Menu[0].cost));
			    cost = (numitems = floor(infloat())) * Menu[0].cost;

			    if (cost > Player.p_gold || numitems < 0)
				++cheat;
			    else
				{
				cheat = 0;
				Player.p_gold -= cost;
				if (drandom() < 0.02)
				    dishonest = TRUE;
				else
				    Player.p_mana += numitems;
				}
			    break;

			case '2':
			    printw("Shields are %.0f per +1.  How many do you want (%.0f max) ? ",
				Menu[1].cost, floor(Player.p_gold / Menu[1].cost));
			    cost = (numitems = floor(infloat())) * Menu[1].cost;

			    if (numitems == 0.0)
				break;
			    else if (cost > Player.p_gold || numitems < 0)
				++cheat;
			    else if (numitems < Player.p_shield)
				NOBETTER();
			    else
				{
				cheat = 0;
				Player.p_gold -= cost;
				if (drandom() < 0.02)
				    dishonest = TRUE;
				else
				    Player.p_shield = numitems;
				}
			    break;
d251 1
a251 4
			case '3':
			    printw("A book costs %.0f gp.  How many do you want (%.0f max) ? ",
				Menu[2].cost, floor(Player.p_gold / Menu[2].cost));
			    cost = (numitems = floor(infloat())) * Menu[2].cost;
d253 2
a254 20
			    if (cost > Player.p_gold || numitems < 0)
				++cheat;
			    else
				{
				cheat = 0;
				Player.p_gold -= cost;
				if (drandom() < 0.02)
				    dishonest = TRUE;
				else if (drandom() * numitems > Player.p_level / 10.0
				    && numitems != 1)
				    {
				    printw("\nYou blew your mind!\n");
				    Player.p_brains /= 5;
				    }
				else
				    {
				    Player.p_brains += floor(numitems) * ROLL(20, 8);
				    }
				}
			    break;
d256 7
a262 4
			case '4':
			    printw("Swords are %.0f gp per +1.  How many + do you want (%.0f max) ? ",
				Menu[3].cost, floor(Player.p_gold / Menu[3].cost));
			    cost = (numitems = floor(infloat())) * Menu[3].cost;
d264 160
a423 32
			    if (numitems == 0.0)
				break;
			    else if (cost > Player.p_gold || numitems < 0)
				++cheat;
			    else if (numitems < Player.p_sword)
				NOBETTER();
			    else
				{
				cheat = 0;
				Player.p_gold -= cost;
				if (drandom() < 0.02)
				    dishonest = TRUE;
				else
				    Player.p_sword = numitems;
				}
			    break;

			case '5':
			    printw("A charm costs %.0f gp.  How many do you want (%.0f max) ? ",
				Menu[4].cost, floor(Player.p_gold / Menu[4].cost));
			    cost = (numitems = floor(infloat())) * Menu[4].cost;

			    if (cost > Player.p_gold || numitems < 0)
				++cheat;
			    else
				{
				cheat = 0;
				Player.p_gold -= cost;
				if (drandom() < 0.02)
				    dishonest = TRUE;
				else
				    Player.p_charms += numitems;
d425 1
a425 1
			    break;
d427 4
a430 4
			case '6':
			    printw("Quicksilver is %.0f gp per +1.  How many + do you want (%.0f max) ? ",
				Menu[5].cost, floor(Player.p_gold / Menu[5].cost));
			    cost = (numitems = floor(infloat())) * Menu[5].cost;
d432 1
a432 3
			    if (numitems == 0.0)
				break;
			    else if (cost > Player.p_gold || numitems < 0)
d434 1
a434 4
			    else if (numitems < Player.p_quksilver)
				NOBETTER();
			    else
				{
d436 2
a437 31
				Player.p_gold -= cost;
				if (drandom() < 0.02)
				    dishonest = TRUE;
				else
				    Player.p_quksilver = numitems;
				}
			    break;

			case '7':
			    if (Player.p_blessing)
				{
				addstr("You already have a blessing.");
				break;
				}

			    printw("A blessing requires a %.0f gp donation.  Still want one ? ", blessingcost);
			    ch = getanswer("NY", FALSE);

			    if (ch == 'Y')
				if (Player.p_gold < blessingcost)
				    ++cheat;
				else
				    {
				    cheat = 0;
				    Player.p_gold -= blessingcost;
				    if (drandom() < 0.02)
					dishonest = TRUE;
				    else
					Player.p_blessing = TRUE;
				    }
			    break;
d439 1
a439 1
	    break;
d441 19
a459 37
	    case 'S':		/* sell gems */
		mvprintw(15, 0, "A gem is worth %.0f gp.  How many do you want to sell (%.0f max) ? ",
		    (double) N_GEMVALUE, Player.p_gems);
		numitems = floor(infloat());

		if (numitems > Player.p_gems || numitems < 0)
		    ++cheat;
		else
		    {
		    cheat = 0;
		    Player.p_gems -= numitems;
		    Player.p_gold += numitems * N_GEMVALUE;
		    }
	    }

	if (cheat == 1)
	    mvaddstr(17, 0, "Come on, merchants aren't stupid.  Stop cheating.\n");
	else if (cheat == 2)
	    {
	    mvaddstr(17, 0, "You had your chance.  This merchant happens to be\n");
	    printw("a %.0f level magic user, and you made %s mad!\n",
		ROLL(Circle * 20.0, 40.0), (drandom() < 0.5) ? "him" : "her");
	    altercoordinates(0.0, 0.0, A_FAR);
	    Player.p_energy /= 2.0;
	    ++Player.p_sin;
	    more(23);
	    return;
	    }
	else if (dishonest)
	    {
	    mvaddstr(17, 0, "The merchant stole your money!");
	    refresh();
	    altercoordinates(Player.p_x - Player.p_x / 10.0,
		Player.p_y - Player.p_y / 10.0, A_SPECIFIC);
	    sleep(2);
	    return;
	    }
d486 1
d489 7
a495 7
    mvprintw(0, 0, "%s%s\n", Player.p_name, descrlocation(&Player, FALSE));
    mvprintw(1, 0, "Level :%7.0f   Energy  :%9.0f(%9.0f)  Mana :%9.0f  Users:%3d\n",
	Player.p_level, Player.p_energy, Player.p_maxenergy + Player.p_shield,
	Player.p_mana, Users);
    mvprintw(2, 0, "Quick :%3.0f(%3.0f)  Strength:%9.0f(%9.0f)  Gold :%9.0f  %s\n",
	Player.p_speed, Player.p_quickness + Player.p_quksilver, Player.p_might,
	Player.p_strength + Player.p_sword, Player.p_gold, descrstatus(&Player));
d521 1
d524 28
a551 26
static	char	*flags[] =	/* to print value of some bools */
	    {
	    "False", 
	    " True"
	    };

    mvprintw( 8,  0, "Type: %s\n",  descrtype(&Player,  FALSE));

    mvprintw(10,  0, "Experience: %9.0f", Player.p_experience);
    mvprintw(11,  0, "Brains    : %9.0f", Player.p_brains);
    mvprintw(12,  0, "Magic Lvl : %9.0f", Player.p_magiclvl);
    mvprintw(13,  0, "Sin       : %9.5f", Player.p_sin);
    mvprintw(14,  0, "Poison    : %9.5f", Player.p_poison);
    mvprintw(15,  0, "Gems      : %9.0f", Player.p_gems);
    mvprintw(16,  0, "Age       : %9d", Player.p_age);
    mvprintw(10, 40, "Holy Water: %9d", Player.p_holywater);
    mvprintw(11, 40, "Amulets   : %9d", Player.p_amulets);
    mvprintw(12, 40, "Charms    : %9d", Player.p_charms);
    mvprintw(13, 40, "Crowns    : %9d", Player.p_crowns);
    mvprintw(14, 40, "Shield    : %9.0f", Player.p_shield);
    mvprintw(15, 40, "Sword     : %9.0f", Player.p_sword);
    mvprintw(16, 40, "Quickslver: %9.0f", Player.p_quksilver);

    mvprintw(18,  0, "Blessing: %s   Ring: %s   Virgin: %s   Palantir: %s", 
	flags[Player.p_blessing], flags[Player.p_ring.ring_type != R_NONE], 
	flags[Player.p_virgin], flags[Player.p_palantir]);
d583 1
a583 1
char	*
d585 2
a586 2
struct player *playerp;
bool	shortflag;
d588 16
a603 16
register int type;	/* for caluculating result subscript */
static char	*results[] =	/* description table */
			{
			" Magic User", " MU",
			" Fighter", " F ",
			" Elf", " E ",
			" Dwarf", " D ",
			" Halfling", " H ",
			" Experimento", " EX",
			" Super", " S ",
			" King", " K ",
			" Council of Wise", " CW",
			" Ex-Valar", " EV",
			" Valar", " V ",
			" ? ", " ? "
			};
d605 1
a605 1
    type = playerp->p_type;
d607 1
a607 2
    switch (playerp->p_specialtype)
	{
d609 2
a610 2
	    type = playerp->p_type;
	    break;
d613 2
a614 2
	    type = 7;
	    break;
d617 2
a618 2
	    type = 8;
	    break;
d621 2
a622 2
	    type = 9;
	    break;
d625 2
a626 2
	    type = 10;
	    break;
d629 1
a629 9
    type *= 2;		/* calculate offset */

    if (type > 20)
	/* error */
	type = 22;

    if (shortflag)
	/* use short descriptions */
	++type;
d631 14
a644 8
    if (playerp->p_crowns > 0)
	{
	strcpy(Databuf, results[type]);
	Databuf[0] = '*';
	return(Databuf);
	}
    else
	return(results[type]);
d675 2
a676 2
register char	*name;
register struct player *playerp;
d678 1
a678 1
long	loc = 0;			/* location in the file */
d680 8
a687 10
    fseek(Playersfp, 0L, 0);
    while (fread((char *) playerp, SZ_PLAYERSTRUCT, 1, Playersfp) == 1)
	{
	if (strcmp(playerp->p_name, name) == 0)
	    {
	    if (playerp->p_status != S_NOTUSED || Wizard)
		/* found it */
		return(loc);
	    }
	loc += SZ_PLAYERSTRUCT;
d690 1
a690 1
    return(-1);
d720 1
a720 1
long	loc = 0L;		/* location in file */
d722 7
a728 8
    fseek(Playersfp, 0L, 0);
    while (fread((char *) &Other, SZ_PLAYERSTRUCT, 1, Playersfp) == 1)
	{
	if (Other.p_status == S_NOTUSED)
	    /* found an empty record */
	    return(loc);
	else
	    loc += SZ_PLAYERSTRUCT;
d731 4
a734 4
    /* make a new record */
    initplayer(&Other);
    Player.p_status = S_OFF;
    writerecord(&Other, loc);
d736 1
a736 1
    return(loc);
d764 1
d766 2
a767 2
struct player	*playerp;
long	loc;
d769 3
a771 3
    playerp->p_name[0] = CH_MARKDELETE;
    playerp->p_status = S_NOTUSED;
    writerecord(playerp, loc);
d798 1
d802 6
a807 7
    if (Player.p_level < 1.0)
	/* delete character */
	freerecord(&Player, Fileloc);
    else
	{
	Player.p_status = S_OFF;
	writerecord(&Player, Fileloc);
d810 2
a811 2
    cleanup(TRUE);
    /*NOTREACHED*/
d845 1
d847 1
a847 1
char	*how;
d849 3
a851 3
FILE	*fp;		/* for updating various files */
int	ch;		/* input */
static	char	*deathmesg[] =
d854 6
a859 6
	"You have been wounded beyond repair.  ",
	"You have been disemboweled.  ",
	"You've been mashed, mauled, and spit upon.  (You're dead.)\n",
	"You died!  ",
	"You're a complete failure -- you've died!!\n",
	"You have been dealt a fatal blow!  "
d862 1
a862 1
    clear();
d864 44
a907 50
    if (strcmp(how, "Stupidity") != 0)
	{
	if (Player.p_level > 9999.0)
	    /* old age */
	    addstr("Characters must be retired upon reaching level 10000.  Sorry.");
	else if (Player.p_lives > 0)
	    /* extra lives */
	    {
	    addstr("You should be more cautious.  You've been killed.\n");
	    printw("You only have %d more chance(s).\n", --Player.p_lives);
	    more(3);
	    Player.p_energy = Player.p_maxenergy;
	    return;
	    }
	else if (Player.p_specialtype == SC_VALAR)
	    {
	    addstr("You had your chances, but Valar aren't totally\n");
	    addstr("immortal.  You are now left to wither and die . . .\n");
	    more(3);
	    Player.p_brains = Player.p_level / 25.0;
	    Player.p_energy = Player.p_maxenergy /= 5.0;
	    Player.p_quksilver = Player.p_sword = 0.0;
	    Player.p_specialtype = SC_COUNCIL;
	    return;
	    }
	else if (Player.p_ring.ring_inuse &&
	    (Player.p_ring.ring_type == R_DLREG || Player.p_ring.ring_type == R_NAZREG))
	    /* good ring in use - saved from death */
	    {
	    mvaddstr(4, 0, "Your ring saved you from death!\n");
	    refresh();
	    Player.p_ring.ring_type = R_NONE;
	    Player.p_energy = Player.p_maxenergy / 12.0 + 1.0;
	    if (Player.p_crowns > 0)
		--Player.p_crowns;
	    return;
	    }
	else if (Player.p_ring.ring_type == R_BAD
	    || Player.p_ring.ring_type == R_SPOILED)
	    /* bad ring in possession; name idiot after player */
	    {
	    mvaddstr(4, 0,
		"Your ring has taken control of you and turned you into a monster!\n");
	    fseek(Monstfp, 13L * SZ_MONSTERSTRUCT, 0);
	    fread((char *) &Curmonster, SZ_MONSTERSTRUCT, 1, Monstfp);
	    strcpy(Curmonster.m_name, Player.p_name);
	    fseek(Monstfp, 13L * SZ_MONSTERSTRUCT, 0);
	    fwrite((char *) &Curmonster, SZ_MONSTERSTRUCT, 1, Monstfp);
	    fflush(Monstfp);
	    }
d909 8
d918 4
a921 1
    enterscore();		/* update score board */
d923 1
a923 19
    /* put info in last dead file */
    fp = fopen(_PATH_LASTDEAD, "w");
    fprintf(fp,"%s (%s, run by %s, level %.0f, killed by %s)",
	Player.p_name, descrtype(&Player, TRUE),
	Player.p_login, Player.p_level, how);
    fclose(fp);

    /* let other players know */
    fp = fopen(_PATH_MESS, "w");
    fprintf(fp, "%s was killed by %s.", Player.p_name, how);
    fclose(fp);

    freerecord(&Player, Fileloc);

    clear();
    move(10, 0);
    addstr(deathmesg[(int) ROLL(0.0, (double) sizeof(deathmesg) / sizeof(char *))]);
    addstr("Care to give it another try ? ");
    ch = getanswer("NY", FALSE);
d925 12
a936 7
    if (ch == 'Y')
	{
	cleanup(FALSE);
	execl(_PATH_GAMEPROG, "phantasia", "-s",
	    (Wizard ? "-S": (char *) NULL), 0);
	exit(0);
	/*NOTREACHED*/
d938 2
a939 3

    cleanup(TRUE);
    /*NOTREACHED*/
d967 1
d969 2
a970 2
register struct player	*playerp;
long	place;
d972 3
a974 3
    fseek(Playersfp, place, 0);
    fwrite((char *) playerp, SZ_PLAYERSTRUCT, 1, Playersfp);
    fflush(Playersfp);
d1004 1
a1004 1
double	experience;
d1006 4
a1009 4
    if (experience < 1.1e7)
	return(floor(pow((experience / 1000.0), 0.4875)));
    else
	return(floor(pow((experience / 1250.0), 0.4865)));
d1036 1
d1038 1
a1038 1
register char	*string;
d1040 1
a1040 1
register int	length;		/* length of string */
d1042 3
a1044 3
    length = strlen(string);
    while (string[--length] == ' ')
	string[length] = '\0';
d1074 1
d1076 12
a1087 13
double	xnew;
double	ynew;
int	operation;
{
    switch (operation)
	{
	case A_FORCED:	/* move with no checks */
	    break;

	case A_NEAR:	/* pick random coordinates near */
	    xnew = Player.p_x + ROLL(1.0, 5.0);
	    ynew = Player.p_y - ROLL(1.0, 5.0);
	    /* fall through for check */
d1090 5
a1094 5
	    if (Beyond && fabs(xnew) < D_BEYOND && fabs(ynew) < D_BEYOND)
		/*
		 * cannot move back from point of no return
		 * pick the largest coordinate to remain unchanged
		 */
d1096 4
a1099 4
		if (fabs(xnew) > fabs(ynew))
		    xnew = SGN(Player.p_x) * MAX(fabs(Player.p_x), D_BEYOND);
		else
		    ynew = SGN(Player.p_y) * MAX(fabs(Player.p_y), D_BEYOND);
d1101 1
a1101 1
	    break;
d1103 4
a1106 4
	case A_FAR:	/* pick random coordinates far */
	    xnew = Player.p_x + SGN(Player.p_x) * ROLL(50 * Circle, 250 * Circle);
	    ynew = Player.p_y + SGN(Player.p_y) * ROLL(50 * Circle, 250 * Circle);
	    break;
a1107 13
    
    /* now set location flags and adjust coordinates */
    Circle = CIRCLE(Player.p_x = floor(xnew), Player.p_y = floor(ynew));

    /* set up flags based upon location */
    Throne = Marsh = Beyond = FALSE;

    if (Player.p_x == 0.0 && Player.p_y == 0.0)
	Throne = TRUE;
    else if (Circle < 35 && Circle >= 20)
	Marsh = TRUE;
    else if (MAX(fabs(Player.p_x), fabs(Player.p_y)) >= D_BEYOND)
	Beyond = TRUE;
d1109 14
a1122 1
    Changed = TRUE;
d1150 1
d1152 2
a1153 2
register struct player	*playerp;
long	loc;
d1155 2
a1156 2
    fseek(Playersfp, loc, 0);
    fread((char *) playerp, SZ_PLAYERSTRUCT, 1, Playersfp);
d1182 1
d1185 1
a1185 1
double	dtemp;				/* for temporary calculations */
d1187 2
a1188 2
    if (explevel(Player.p_experience) > Player.p_level)
	/* move one or more levels */
d1190 3
a1192 3
	movelevel();
	if (Player.p_level > 5.0)
	    Timeout = TRUE;
d1194 49
d1244 3
a1246 36
    if (Player.p_specialtype == SC_VALAR)
	/* valar */
	Circle = Player.p_level / 5.0;

    /* calculate effective quickness */
    dtemp = ((Player.p_gold + Player.p_gems / 2.0) - 1000.0) / Statptr->c_goldtote
	- Player.p_level;;
    dtemp = MAX(0.0, dtemp);		/* gold slows player down */
    Player.p_speed = Player.p_quickness + Player.p_quksilver - dtemp;

    /* calculate effective strength */
    if (Player.p_poison > 0.0)
	/* poison makes player weaker */
	{
	dtemp = 1.0 - Player.p_poison * Statptr->c_weakness / 800.0;
	dtemp = MAX(0.1, dtemp);
	}
    else
	dtemp = 1.0;
    Player.p_might = dtemp *  Player.p_strength + Player.p_sword;

    /* insure that important things are within limits */
    Player.p_quksilver = MIN(99.0, Player.p_quksilver);
    Player.p_mana = MIN(Player.p_mana,
	Player.p_level * Statptr->c_maxmana + 1000.0);
    Player.p_brains = MIN(Player.p_brains,
	Player.p_level * Statptr->c_maxbrains + 200.0);
    Player.p_charms = MIN(Player.p_charms, Player.p_level + 10.0);

    /*
     * some implementations have problems with floating point compare
     * we work around it with this stuff
     */
    Player.p_gold = floor(Player.p_gold) + 0.1;
    Player.p_gems = floor(Player.p_gems) + 0.1;
    Player.p_mana = floor(Player.p_mana) + 0.1;
d1248 3
a1250 5
    if (Player.p_ring.ring_type != R_NONE)
	/* do ring things */
	{
	/* rest to max */
	Player.p_energy = Player.p_maxenergy + Player.p_shield;
d1252 4
a1255 21
	if (Player.p_ring.ring_duration <= 0)
	    /* clean up expired rings */
	    switch (Player.p_ring.ring_type)
		{
		case R_BAD:	/* ring drives player crazy */
		    Player.p_ring.ring_type = R_SPOILED;
		    Player.p_ring.ring_duration = (short) ROLL(10.0, 25.0);
		    break;

		case R_NAZREG:	/* ring disappears */
		    Player.p_ring.ring_type = R_NONE;
		    break;

		case R_SPOILED:	/* ring kills player */
		    death("A cursed ring");
		    break;

		case R_DLREG:	/* this ring doesn't expire */
		    Player.p_ring.ring_duration = 0;
		    break;
		}
d1257 2
a1258 3

    if (Player.p_age / N_AGE > Player.p_degenerated)
	/* age player slightly */
d1260 10
a1269 10
	++Player.p_degenerated;
	if (Player.p_quickness > 23.0)
	    Player.p_quickness *= 0.99;
	Player.p_strength *= 0.97;
	Player.p_brains *= 0.95;
	Player.p_magiclvl *= 0.97;
	Player.p_maxenergy *= 0.95;
	Player.p_quksilver *= 0.95;
	Player.p_sword *= 0.93;
	Player.p_shield *= 0.93;
d1297 1
d1299 1
a1299 1
register struct  player   *playerp;
d1301 54
a1354 54
    playerp->p_experience =
    playerp->p_level =
    playerp->p_strength =
    playerp->p_sword =
    playerp->p_might =
    playerp->p_energy =
    playerp->p_maxenergy =
    playerp->p_shield =
    playerp->p_quickness =
    playerp->p_quksilver =
    playerp->p_speed =
    playerp->p_magiclvl =
    playerp->p_mana =
    playerp->p_brains =
    playerp->p_poison =
    playerp->p_gems =
    playerp->p_sin =
    playerp->p_1scratch =
    playerp->p_2scratch = 0.0;

    playerp->p_gold = ROLL(50.0, 75.0) + 0.1;	/* give some gold */

    playerp->p_x = ROLL(-125.0, 251.0);
    playerp->p_y = ROLL(-125.0, 251.0);		/* give random x, y */

    /* clear ring */
    playerp->p_ring.ring_type = R_NONE;
    playerp->p_ring.ring_duration = 0;
    playerp->p_ring.ring_inuse = FALSE;

    playerp->p_age = 0L;

    playerp->p_degenerated = 1;			/* don't degenerate initially */

    playerp->p_type = C_FIGHTER;		/* default */
    playerp->p_specialtype = SC_NONE;
    playerp->p_lives =
    playerp->p_crowns = 
    playerp->p_charms =
    playerp->p_amulets =
    playerp->p_holywater =
    playerp->p_lastused = 0;
    playerp->p_status = S_NOTUSED;
    playerp->p_tampered = T_OFF;
    playerp->p_istat = I_OFF;

    playerp->p_palantir =
    playerp->p_blessing =
    playerp->p_virgin =
    playerp->p_blindness = FALSE;

    playerp->p_name[0] =
    playerp->p_password[0] =
    playerp->p_login[0] = '\0';
d1380 1
d1383 5
a1387 5
    move(3, 0);
    clrtoeol();
    fseek(Messagefp, 0L, 0);
    if (fgets(Databuf, SZ_DATABUF, Messagefp) != NULL)
	addstr(Databuf);
d1414 1
a1417 1
    int er;
d1419 3
a1421 4
    er = errno;
    if (Windows)
	clear();
    cleanup(FALSE);
d1423 4
a1426 4
    printf("An unrecoverable error has occurred reading %s.\n(errno = %d)\n", whichfile, er);
    printf("Please run 'setup' to determine the problem.\n");
    exit(1);
    /*NOTREACHED*/
d1457 1
a1457 1
double	x1, x2, y1, y2;
d1459 1
a1459 1
double	deltax, deltay;
d1461 3
a1463 3
    deltax = x1 - x2;
    deltay = y1 - y2;
    return(sqrt(deltax * deltax + deltay * deltay));
a1464 1

d1490 1
d1492 1
a1492 1
int whichsig;
d1494 5
a1498 5
    clear();
    if (!(whichsig == SIGINT || whichsig == SIGQUIT))
	printw("Error: caught signal # %d.\n", whichsig);
    cleanup(TRUE);
    /*NOTREACHED*/
d1526 1
a1526 1
char	*
d1528 1
a1528 1
register struct player	*playerp;
d1530 1
a1530 2
    switch (playerp->p_status)
	{
d1532 6
a1537 6
	    if (playerp->p_energy < 0.2 * (playerp->p_maxenergy + playerp->p_shield))
		return("Low Energy");
	    else if (playerp->p_blindness)
		return("Blind");
	    else
		return("In game");
d1540 1
a1540 1
	    return("Cloaked");
d1543 1
a1543 1
	    return("In Battle");
d1546 1
a1546 1
	    return("Encounter");
d1549 1
a1549 1
	    return("Trading");
d1552 1
a1552 1
	    return("Off");
d1555 1
a1555 1
	    return("Hung up");
d1558 1
a1558 1
	    return("");
d1591 5
a1595 5
    if (sizeof(int) != 2)
	/* use only low bits */
	return((double) (random() & 0x7fff) / 32768.0);
    else
	return((double) random() / 32768.0);
d1626 1
d1628 2
a1629 2
double	gold;
double	gems;
d1631 3
a1633 7
FILE	*fp;		/* to update Goldfile */
double	dtemp;		/* for temporary calculations */
double	taxes;		/* tax liability */

    /* add to cache */
    Player.p_gold += gold;
    Player.p_gems += gems;
d1635 3
a1637 2
    /* calculate tax liability */
    taxes = N_TAXAMOUNT / 100.0 * (N_GEMVALUE * gems + gold);
d1639 6
a1644 2
    if (Player.p_gold < taxes)
	/* not enough gold to pay taxes, must convert some gems to gold */
d1646 2
a1647 1
	dtemp = floor(taxes / N_GEMVALUE + 1.0); /* number of gems to convert */
d1649 12
a1660 13
	if (Player.p_gems >= dtemp)
	    /* player has enough to convert */
	    {
	    Player.p_gems -= dtemp;
	    Player.p_gold += dtemp * N_GEMVALUE;
	    }
	else
	    /* take everything; this should never happen */
	    {
	    Player.p_gold += Player.p_gems * N_GEMVALUE;
	    Player.p_gems = 0.0;
	    taxes = Player.p_gold;
	    }
d1662 1
d1664 2
a1665 4
    Player.p_gold -= taxes;

    if ((fp = fopen(_PATH_GOLD, "r+")) != NULL)
	/* update taxes */
d1667 6
a1672 6
	dtemp = 0.0;
	fread((char *) &dtemp, sizeof(double), 1, fp);
	dtemp += floor(taxes);
	fseek(fp, 0L, 0);
	fwrite((char *) &dtemp, sizeof(double), 1, fp);
	fclose(fp);
@


1.3
log
@tabify
@
text
@d1432 1
a1432 1
/ GLOBAL INPUTS: errno, *stdscr, printw(), printf(), Windows
d1444 1
a1444 1
	int	(*funcp) __P((const char *, ...));
d1446 1
a1447 2
	{
	funcp = printw;
d1449 1
a1449 3
	}
    else
	funcp = printf;
d1451 3
a1453 3
    (*funcp)("An unrecoverable error has occurred reading %s.  (errno = %d)\n", whichfile, errno);
    (*funcp)("Please run 'setup' to determine the problem.\n");
    cleanup(TRUE);
@


1.2
log
@fixed the "/* in comments" problem.
@
text
@d1263 1
a1263 1
        if (Player.p_ring.ring_duration <= 0)
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
/************************************************************************/
d115 1
a115 1
/************************************************************************/
d216 1
a216 1
/************************************************************************/
d504 1
a504 1
/************************************************************************/
d538 1
a538 1
/************************************************************************/
d597 1
a597 1
/************************************************************************/
d690 1
a690 1
/************************************************************************/
d736 1
a736 1
/************************************************************************/
d784 1
a784 1
/************************************************************************/
d817 1
a817 1
/************************************************************************/
d864 1
a864 1
/************************************************************************/
d994 1
a994 1
/************************************************************************/
d1028 1
a1028 1
/************************************************************************/
d1062 1
a1062 1
/************************************************************************/
d1099 1
a1099 1
/************************************************************************/
d1175 1
a1175 1
/************************************************************************/
d1206 1
a1206 1
/************************************************************************/
d1324 1
a1324 1
/************************************************************************/
d1406 1
a1406 1
/************************************************************************/
d1439 1
a1439 1
/************************************************************************/
d1484 1
a1484 1
/************************************************************************/
d1520 1
a1520 1
/************************************************************************/
d1555 1
a1555 1
/************************************************************************/
d1618 1
a1618 1
/************************************************************************/
d1656 1
a1656 1
/************************************************************************/
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
