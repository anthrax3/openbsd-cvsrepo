head	1.33;
access;
symbols
	OPENBSD_6_2:1.33.0.4
	OPENBSD_6_2_BASE:1.33
	OPENBSD_6_1:1.33.0.6
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.26.0.10
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.6
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.25.0.16
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.14
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.12
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.10
	OPENBSD_5_0:1.25.0.8
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.6
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.4
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.24.0.12
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.8
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.6
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.4
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.23.0.12
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.10
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.8
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.6
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.4
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.22.0.4
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9:1.14.0.4
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2016.03.07.12.07.57;	author mestre;	state Exp;
branches;
next	1.32;
commitid	NZhYxChmyb9vOEMM;

1.32
date	2016.01.10.13.35.10;	author mestre;	state Exp;
branches;
next	1.31;
commitid	mVbl9a8GbGdqcFgu;

1.31
date	2016.01.07.16.00.34;	author tb;	state Exp;
branches;
next	1.30;
commitid	IwzFE3fG5RnKTWNh;

1.30
date	2016.01.04.17.33.24;	author mestre;	state Exp;
branches;
next	1.29;
commitid	b21xvsfCGMtCOVrz;

1.29
date	2016.01.03.14.38.17;	author mestre;	state Exp;
branches;
next	1.28;
commitid	Ptgw9rNvmSHNRfGy;

1.28
date	2015.12.25.20.59.09;	author mestre;	state Exp;
branches;
next	1.27;
commitid	5J5Os05YMVA0ZKC5;

1.27
date	2015.11.30.09.00.02;	author tb;	state Exp;
branches;
next	1.26;
commitid	vCRRPAW0Aqk7ghgD;

1.26
date	2013.08.29.20.22.22;	author naddy;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.27.23.59.28;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.02.15.27.13;	author jmc;	state Exp;
branches;
next	1.23;

1.23
date	2004.07.10.07.26.24;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.03.03.01.42;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.11.04.47.39;	author david;	state Exp;
branches;
next	1.20;

1.20
date	2002.12.06.21.48.52;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.30.05.35.22;	author pjanzen;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.31.03.40.01;	author pjanzen;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.16.21.27.12;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.09.07.04.30;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.02.23.28.31;	author pjanzen;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.29.07.37.38;	author pjanzen;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.11.02.55.18;	author pjanzen;	state Exp;
branches;
next	1.12;

1.12
date	99.09.25.15.52.21;	author pjanzen;	state Exp;
branches;
next	1.11;

1.11
date	99.08.17.09.13.12;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	99.07.31.18.52.00;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	99.06.10.22.58.24;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	98.08.19.07.42.27;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	98.03.12.09.09.43;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	98.02.14.20.40.42;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.01.31.19.20.22;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.40.48;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.12.22.20.02.09;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.12.19.22.22.17;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.29;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.29;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.33
log
@- General changes:
- Remove -? from getopt(3) options, but still keep (or add) -h where applicable
- Replace hardcoded program strings by getprogname(3)

- Specific changes:
- atc(6): this used -? and -u for usage(), remove both from game and manpage
- bcd(6): use __progname instead of getprogname(3), no need to include stdlib.h
- hunt(6): replace fputs(3) by fprintf(3)

OK tb@@ after his suggestions
@
text
@/*	$OpenBSD: wump.c,v 1.32 2016/01/10 13:35:10 mestre Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Dave Taylor, of Intuitive Systems.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * A no longer new version of the age-old favorite Hunt-The-Wumpus game that
 * has been a part of the BSD distribution for longer than us old folk
 * would care to remember.
 */

#include <sys/wait.h>

#include <err.h>
#include <fcntl.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "pathnames.h"

/* some defines to spec out what our wumpus cave should look like */

/* #define	MAX_ARROW_SHOT_DISTANCE	6	*/	/* +1 for '0' stopper */
#define	MAX_LINKS_IN_ROOM	25		/* a complex cave */

#define	MAX_ROOMS_IN_CAVE	250
#define	ROOMS_IN_CAVE		20
#define	MIN_ROOMS_IN_CAVE	10

#define	LINKS_IN_ROOM		3
#define	NUMBER_OF_ARROWS	5
#define	PIT_COUNT		3
#define	BAT_COUNT		3

#define	EASY			1		/* levels of play */
#define	HARD			2

/* some macro definitions for cleaner output */

#define	plural(n)	(n == 1 ? "" : "s")

/* simple cave data structure; +1 so we can index from '1' not '0' */
struct room_record {
	int tunnel[MAX_LINKS_IN_ROOM];
	int has_a_pit, has_a_bat;
} cave[MAX_ROOMS_IN_CAVE+1];

/*
 * global variables so we can keep track of where the player is, how
 * many arrows they still have, where el wumpo is, and so on...
 */
int player_loc = -1;			/* player location */
int wumpus_loc = -1;			/* The Bad Guy location */
int level = EASY;			/* level of play */
int arrows_left;			/* arrows unshot */
int oldstyle = 0;			/* dodecahedral cave? */

#ifdef DEBUG
int debug = 0;
#endif

int pit_num = -1;		/* # pits in cave */
int bat_num = -1;		/* # bats */
int room_num = ROOMS_IN_CAVE;		/* # rooms in cave */
int link_num = LINKS_IN_ROOM;		/* links per room  */
int arrow_num = NUMBER_OF_ARROWS;	/* arrow inventory */

char answer[20];			/* user input */

int	bats_nearby(void);
void	cave_init(void);
void	clear_things_in_cave(void);
void	display_room_stats(void);
void	dodecahedral_cave_init(void);
int	gcd(int, int);
int	getans(const char *);
void	initialize_things_in_cave(void);
void	instructions(void);
int	int_compare(const void *, const void *);
/* void	jump(int); */
void	kill_wump(void);
int	main(int, char **);
int	move_to(const char *);
void	move_wump(void);
void	no_arrows(void);
void	pit_kill(void);
void	pit_kill_bat(void);
int	pit_nearby(void);
void	pit_survive(void);
int	shoot(char *);
void	shoot_self(void);
int	take_action(void);
__dead void	usage(void);
void	wump_kill(void);
void	wump_bat_kill(void);
void	wump_walk_kill(void);
int	wump_nearby(void);


int
main(int argc, char *argv[])
{
	int c;

	if (pledge("stdio rpath proc exec", NULL) == -1)
		err(1, "pledge");

#ifdef DEBUG
	while ((c = getopt(argc, argv, "a:b:hop:r:t:d")) != -1)
#else
	while ((c = getopt(argc, argv, "a:b:hop:r:t:")) != -1)
#endif
		switch (c) {
		case 'a':
			arrow_num = atoi(optarg);
			break;
		case 'b':
			bat_num = atoi(optarg);
			break;
#ifdef DEBUG
		case 'd':
			debug = 1;
			break;
#endif
		case 'h':
			level = HARD;
			break;
		case 'o':
			oldstyle = 1;
			break;
		case 'p':
			pit_num = atoi(optarg);
			break;
		case 'r':
			room_num = atoi(optarg);
			if (room_num < MIN_ROOMS_IN_CAVE)
				errx(1,
	"no self-respecting wumpus would live in such a small cave!");
			if (room_num > MAX_ROOMS_IN_CAVE)
				errx(1,
	"even wumpii can't furnish caves that large!");
			break;
		case 't':
			link_num = atoi(optarg);
			if (link_num < 2)
				errx(1,
	"wumpii like extra doors in their caves!");
			break;
		default:
			usage();
	}

	if (oldstyle) {
		room_num = 20;
		link_num = 3;
		/* Original game had exactly 2 bats and 2 pits */
		if (bat_num < 0)
			bat_num = 2;
		if (pit_num < 0)
			pit_num = 2;
	} else {
		if (bat_num < 0)
			bat_num = BAT_COUNT;
		if (pit_num < 0)
			pit_num = PIT_COUNT;
	}

	if (link_num > MAX_LINKS_IN_ROOM ||
	    link_num > room_num - (room_num / 4))
		errx(1,
"too many tunnels!  The cave collapsed!\n(Fortunately, the wumpus escaped!)");

	if (level == HARD) {
		if (room_num / 2 - bat_num)
			bat_num += arc4random_uniform(room_num / 2 - bat_num);
		if (room_num / 2 - pit_num)
			pit_num += arc4random_uniform(room_num / 2 - pit_num);
	}

	/* Leave at least two rooms free--one for the player to start in, and
	 * potentially one for the wumpus.
	 */
	if (bat_num > room_num / 2 - 1)
		errx(1,
"the wumpus refused to enter the cave, claiming it was too crowded!");

	if (pit_num > room_num / 2 - 1)
		errx(1,
"the wumpus refused to enter the cave, claiming it was too dangerous!");

	instructions();

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	if (oldstyle)
		dodecahedral_cave_init();
	else
		cave_init();

	/* and we're OFF!  da dum, da dum, da dum, da dum... */
	(void)printf(
"\nYou're in a cave with %d rooms and %d tunnels leading from each room.\n\
There are %d bat%s and %d pit%s scattered throughout the cave, and your\n\
quiver holds %d custom super anti-evil Wumpus arrows.  Good luck.\n",
	    room_num, link_num, bat_num, plural(bat_num), pit_num,
	    plural(pit_num), arrow_num);

	for (;;) {
		initialize_things_in_cave();
		arrows_left = arrow_num;
		do {
			display_room_stats();
			(void)printf("Move or shoot? (m-s) ");
			(void)fflush(stdout);
			(void)fpurge(stdin);
			if (!fgets(answer, sizeof(answer), stdin))
				break;
		} while (!take_action());
		(void)fpurge(stdin);

		if (!getans("\nCare to play another game? (y-n) ")) {
			(void)printf("\n");
			return 0;
		}
		clear_things_in_cave();
		if (!getans("In the same cave? (y-n) ")) {
			if (oldstyle)
				dodecahedral_cave_init();
			else
				cave_init();
		}
	}
}

void
display_room_stats(void)
{
	int i;

	/*
	 * Routine will explain what's going on with the current room, as well
	 * as describe whether there are pits, bats, & wumpii nearby.  It's
	 * all pretty mindless, really.
	 */
	(void)printf(
"\nYou are in room %d of the cave, and have %d arrow%s left.\n",
	    player_loc, arrows_left, plural(arrows_left));

	if (bats_nearby())
		(void)printf("*rustle* *rustle* (must be bats nearby)\n");
	if (pit_nearby())
		(void)printf("*whoosh* (I feel a draft from some pits).\n");
	if (wump_nearby())
		(void)printf("*sniff* (I can smell the evil Wumpus nearby!)\n");

	(void)printf("There are tunnels to rooms %d, ",
	   cave[player_loc].tunnel[0]);

	for (i = 1; i < link_num - 1; i++)
/*		if (cave[player_loc].tunnel[i] <= room_num) */
			(void)printf("%d, ", cave[player_loc].tunnel[i]);
	(void)printf("and %d.\n", cave[player_loc].tunnel[link_num - 1]);
}

int
take_action(void)
{
	/*
	 * Do the action specified by the player, either 'm'ove, 's'hoot
	 * or something exceptionally bizarre and strange!  Returns 1
	 * iff the player died during this turn, otherwise returns 0.
	 */
	switch (*answer) {
		case 'M':
		case 'm':			/* move */
			return(move_to(answer + 1));
		case 'S':
		case 's':			/* shoot */
			return(shoot(answer + 1));
		case 'Q':
		case 'q':
		case 'x':
			exit(0);
		case '\n':
			return(0);
		}
	if (arc4random_uniform(15) == 1)
		(void)printf("Que pasa?\n");
	else
		(void)printf("I don't understand!\n");
	return(0);
}

int
move_to(const char *room_number)
{
	int i, just_moved_by_bats, next_room, tunnel_available;

	/*
	 * This is responsible for moving the player into another room in the
	 * cave as per their directions.  If room_number is a null string,
	 * then we'll prompt the user for the next room to go into.   Once
	 * we've moved into the room, we'll check for things like bats, pits,
	 * and so on.  This routine returns 1 if something occurs that kills
	 * the player and 0 otherwise...
	 */
	tunnel_available = just_moved_by_bats = 0;
	next_room = atoi(room_number);

	/* crap for magic tunnels */
/*	if (next_room == room_num + 1 &&
 *	    cave[player_loc].tunnel[link_num-1] != next_room)
 *		++next_room;
 */
	while (next_room < 1 || next_room > room_num /* + 1 */) {
		if (next_room < 0 && next_room != -1)
(void)printf("Sorry, but we're constrained to a semi-Euclidean cave!\n");
		if (next_room > room_num /* + 1 */)
(void)printf("What?  The cave surely isn't quite that big!\n");
/*		if (next_room == room_num + 1 &&
 *		    cave[player_loc].tunnel[link_num-1] != next_room) {
 *			(void)printf("What?  The cave isn't that big!\n");
 *			++next_room;
 *		}
 */		(void)printf("To which room do you wish to move? ");
		(void)fflush(stdout);
		if (!fgets(answer, sizeof(answer), stdin))
			return(1);
		next_room = atoi(answer);
	}

	/* now let's see if we can move to that room or not */
	tunnel_available = 0;
	for (i = 0; i < link_num; i++)
		if (cave[player_loc].tunnel[i] == next_room)
			tunnel_available = 1;

	if (!tunnel_available) {
		(void)printf("*Oof!*  (You hit the wall)\n");
		if (arc4random_uniform(6) == 1) {
(void)printf("Your colorful comments awaken the wumpus!\n");
			move_wump();
			if (wumpus_loc == player_loc) {
				wump_walk_kill();
				return(1);
			}
		}
		return(0);
	}

	/* now let's move into that room and check it out for dangers */
/*	if (next_room == room_num + 1)
 *		jump(next_room = arc4random_uniform(room_num) + 1);
 */
	player_loc = next_room;
	for (;;) {
		if (next_room == wumpus_loc) {		/* uh oh... */
			if (just_moved_by_bats)
				wump_bat_kill();
			else
				wump_kill();
			return(1);
		}
		if (cave[next_room].has_a_pit) {
			if (arc4random_uniform(12) < 2) {
				pit_survive();
				return(0);
			} else {
				if (just_moved_by_bats)
					pit_kill_bat();
				else
					pit_kill();
				return(1);
			}
		}

		if (cave[next_room].has_a_bat) {
			(void)printf(
"*flap*  *flap*  *flap*  (humongous bats pick you up and move you%s!)\n",
			    just_moved_by_bats ? " again": "");
			next_room = player_loc =
			    arc4random_uniform(room_num) + 1;
			just_moved_by_bats = 1;
		}

		else
			break;
	}
	return(0);
}

int
shoot(char *room_list)
{
	int chance, next, roomcnt;
	int j, arrow_location, link, ok;
	char *p;

	/*
	 * Implement shooting arrows.  Arrows are shot by the player indicating
	 * a space-separated list of rooms that the arrow should pass through;
	 * if any of the rooms they specify are not accessible via tunnel from
	 * the room the arrow is in, it will instead fly randomly into another
	 * room.  If the player hits the wumpus, this routine will indicate
	 * such.  If it misses, this routine may *move* the wumpus one room.
	 * If it's the last arrow, then the player dies...  Returns 1 if the
	 * player has won or died, 0 if nothing has happened.
	 */
	arrow_location = player_loc;
	for (roomcnt = 1;; ++roomcnt, room_list = NULL) {
		if (!(p = strtok(room_list, " \t\n"))) {
			if (roomcnt == 1) {
				(void)printf("Enter a list of rooms to shoot into:\n");
				(void)fflush(stdout);
				if (!(p = strtok(fgets(answer, sizeof(answer), stdin),
							" \t\n"))) {
					(void)printf(
				"The arrow falls to the ground at your feet.\n");
					return(0);
					}
			} else
				break;
		}
		if (roomcnt > 5) {
			(void)printf(
"The arrow wavers in its flight and can go no further than room %d!\n",
					arrow_location);
			break;
		}

		next = atoi(p);
		if (next == 0)
			break;	/* Old wumpus used room 0 as the terminator */

		chance = arc4random_uniform(10);
		if (roomcnt == 4 && chance < 2) {
			(void)printf(
"Your finger slips on the bowstring!  *twaaaaaang*\n\
The arrow is weakly shot and can go no further than room %d!\n",arrow_location);
			break;
		} else if (roomcnt == 5 && chance < 6) {
			(void)printf(
"The arrow wavers in its flight and can go no further than room %d!\n",
					arrow_location);
			break;
		}

		for (j = 0, ok = 0; j < link_num; j++)
			if (cave[arrow_location].tunnel[j] == next)
				ok = 1;

		if (ok) {
/*			if (next > room_num) {
 *				(void)printf(
 * "A faint gleam tells you the arrow has gone through a magic tunnel!\n");
 *				arrow_location =
 *				    arc4random_uniform(room_num) + 1;
 *			} else
 */				arrow_location = next;
		} else {
			link = (arc4random_uniform(link_num));
			if (cave[arrow_location].tunnel[link] == player_loc)
				(void)printf(
"*thunk*  The arrow can't find a way from %d to %d and flies back into\n\
your room!\n",
				    arrow_location, next);
/*			else if (cave[arrow_location].tunnel[link] > room_num)
 *				(void)printf(
 *"*thunk*  The arrow flies randomly into a magic tunnel, thence into\n\
 *room %d!\n",
 *				    cave[arrow_location].tunnel[link]);
 */			else
				(void)printf(
"*thunk*  The arrow can't find a way from %d to %d and flies randomly\n\
into room %d!\n", arrow_location, next, cave[arrow_location].tunnel[link]);

			arrow_location = cave[arrow_location].tunnel[link];
		}

		/*
		 * now we've gotten into the new room let us see if El Wumpo is
		 * in the same room ... if so we've a HIT and the player WON!
		 */
		if (arrow_location == wumpus_loc) {
			kill_wump();
			return(1);
		}

		if (arrow_location == player_loc) {
			shoot_self();
			return(1);
		}
	}

	if (!--arrows_left) {
		no_arrows();
		return(1);
	}

	{
		/* each time you shoot, it's more likely the wumpus moves */
		static int lastchance = 2;

		if (arc4random_uniform(level) == EASY ?
		    12 : 9 < (lastchance += 2)) {
			move_wump();
			if (wumpus_loc == player_loc) {
				wump_walk_kill();
				/* Reset for next game */
				lastchance = arc4random_uniform(3);
				return(1);
			}

		}
	}
	(void)printf("The arrow hit nothing.\n");
	return(0);
}

int
gcd(int a, int b)
{
	int r;

	if (!(r = (a % b)))
		return(b);
	return(gcd(b, r));
}

void
cave_init(void)
{
	int i, j, k, link;
	int delta;

	/*
	 * This does most of the interesting work in this program actually!
	 * In this routine we'll initialize the Wumpus cave to have all rooms
	 * linking to all others by stepping through our data structure once,
	 * recording all forward links and backwards links too.  The parallel
	 * "linkcount" data structure ensures that no room ends up with more
	 * than three links, regardless of the quality of the random number
	 * generator that we're using.
	 */

	/* Note that throughout the source there are commented-out vestigial
	 * remains of the 'magic tunnel', which was a tunnel to room
	 * room_num +1.  It was necessary if all paths were two-way and
	 * there was an odd number of rooms, each with an odd number of
	 * exits.  It's being kept in case cave_init ever gets reworked into
	 * something more traditional.
	 */

	/* initialize the cave first off. */
	for (i = 1; i <= room_num; ++i)
		for (j = 0; j < link_num ; ++j)
			cave[i].tunnel[j] = -1;

	/* choose a random 'hop' delta for our guaranteed link.
	 * To keep the cave connected, require greatest common
	 * divisor of (delta + 1) and room_num to be 1
	 */
	do {
		delta = arc4random_uniform(room_num - 1) + 1;
	} while (gcd(room_num, delta + 1) != 1);

	for (i = 1; i <= room_num; ++i) {
		link = ((i + delta) % room_num) + 1;	/* connection */
		cave[i].tunnel[0] = link;		/* forw link */
		cave[link].tunnel[1] = i;		/* back link */
	}
	/* now fill in the rest of the cave with random connections.
	 * This is a departure from historical versions of wumpus.
	 */
	for (i = 1; i <= room_num; i++)
		for (j = 2; j < link_num ; j++) {
			if (cave[i].tunnel[j] != -1)
				continue;
try_again:		link = arc4random_uniform(room_num) + 1;
			/* skip duplicates */
			for (k = 0; k < j; k++)
				if (cave[i].tunnel[k] == link)
					goto try_again;
			/* don't let a room connect to itself */
			if (link == i)
				goto try_again;
			cave[i].tunnel[j] = link;
			if (arc4random() % 2 == 1)
				continue;
			for (k = 0; k < link_num; ++k) {
				/* if duplicate, skip it */
				if (cave[link].tunnel[k] == i)
					k = link_num;
				else {
					/* if open link, use it, force exit */
					if (cave[link].tunnel[k] == -1) {
						cave[link].tunnel[k] = i;
						k = link_num;
					}
				}
			}
		}
	/*
	 * now that we're done, sort the tunnels in each of the rooms to
	 * make it easier on the intrepid adventurer.
	 */
	for (i = 1; i <= room_num; ++i)
		qsort(cave[i].tunnel, (u_int)link_num,
		    sizeof(cave[i].tunnel[0]), int_compare);

#ifdef DEBUG
	if (debug)
		for (i = 1; i <= room_num; ++i) {
			(void)printf("<room %d  has tunnels to ", i);
			for (j = 0; j < link_num; ++j)
				(void)printf("%d ", cave[i].tunnel[j]);
			(void)printf(">\n");
		}
#endif
}

void
dodecahedral_cave_init(void)
{
	int vert[20][3] = {
		{1, 4, 7},
		{0, 2, 9},
		{1, 3, 11},
		{2, 4, 13},
		{0, 3, 5},
		{4, 6, 14},
		{5, 7, 16},
		{0, 6, 8},
		{7, 9, 17},
		{1, 8, 10},
		{9, 11, 18},
		{2, 10, 12},
		{11, 13, 19},
		{3, 12, 14},
		{5, 13, 15},
		{14, 16, 19},
		{6, 15, 17},
		{8, 16, 18},
		{10, 17, 19},
		{12, 15, 18},
	};
	int loc[20];
	int i, j, temp;

	if (room_num != 20 || link_num != 3)
		errx(1, "wrong parameters for dodecahedron");
	for (i = 0; i < 20; i++)
		loc[i] = i;
	for (i = 0; i < 20; i++) {
		j = arc4random_uniform(20 - i);
		if (j) {
			temp = loc[i];
			loc[i] = loc[i + j];
			loc[i + j] = temp;
		}
	}
	/* cave is offset by 1 */
	for (i = 0; i < 20; i++) {
		for (j = 0; j < 3; j++)
			cave[loc[i] + 1].tunnel[j] = loc[vert[i][j]] + 1;
	}

	/*
	 * now that we're done, sort the tunnels in each of the rooms to
	 * make it easier on the intrepid adventurer.
	 */
	for (i = 1; i <= room_num; ++i)
		qsort(cave[i].tunnel, (u_int)link_num,
		    sizeof(cave[i].tunnel[0]), int_compare);

#ifdef DEBUG
	if (debug)
		for (i = 1; i <= room_num; ++i) {
			(void)printf("<room %d  has tunnels to ", i);
			for (j = 0; j < link_num; ++j)
				(void)printf("%d ", cave[i].tunnel[j]);
			(void)printf(">\n");
		}
#endif
}

void
clear_things_in_cave(void)
{
	int i;

	/*
	 * remove bats and pits from the current cave in preparation for us
	 * adding new ones via the initialize_things_in_cave() routines.
	 */
	for (i = 1; i <= room_num; ++i)
		cave[i].has_a_bat = cave[i].has_a_pit = 0;
}

void
initialize_things_in_cave(void)
{
	int i, loc;

	/* place some bats, pits, the wumpus, and the player. */
	for (i = 0; i < bat_num; ++i) {
		do {
			loc = arc4random_uniform(room_num) + 1;
		} while (cave[loc].has_a_bat);
		cave[loc].has_a_bat = 1;
#ifdef DEBUG
		if (debug)
			(void)printf("<bat in room %d>\n", loc);
#endif
	}

	for (i = 0; i < pit_num; ++i) {
		do {
			loc = arc4random_uniform(room_num) + 1;
		} while (cave[loc].has_a_pit || cave[loc].has_a_bat);
		/* Above used to be &&;  || makes sense but so does just
		 * checking cave[loc].has_a_pit  */
		cave[loc].has_a_pit = 1;
#ifdef DEBUG
		if (debug)
			(void)printf("<pit in room %d>\n", loc);
#endif
	}

	wumpus_loc = arc4random_uniform(room_num) + 1;
#ifdef DEBUG
	if (debug)
		(void)printf("<wumpus in room %d>\n", wumpus_loc);
#endif

	do {
		player_loc = arc4random_uniform(room_num) + 1;
	} while (player_loc == wumpus_loc || cave[player_loc].has_a_pit ||
			cave[player_loc].has_a_bat);
	/* Replaced (level == HARD ?
	 *  (link_num / room_num < 0.4 ? wump_nearby() : 0) : 0)
	 * with bat/pit checks in initial room.  If this is kept there is
	 * a slight chance that no room satisfies all four conditions.
	 */
}

int
getans(const char *prompt)
{
	char buf[20];

	/*
	 * simple routine to ask the yes/no question specified until the user
	 * answers yes or no, then return 1 if they said 'yes' and 0 if they
	 * answered 'no'.
	 */
	for (;;) {
		(void)printf("%s", prompt);
		(void)fflush(stdout);
		if (!fgets(buf, sizeof(buf), stdin))
			return(0);
		if (*buf == 'N' || *buf == 'n')
			return(0);
		if (*buf == 'Y' || *buf == 'y')
			return(1);
		(void)printf(
"I don't understand your answer; please enter 'y' or 'n'!\n");
	}
}

int
bats_nearby(void)
{
	int i;

	/* check for bats in the immediate vicinity */
	for (i = 0; i < link_num; ++i)
		if (cave[cave[player_loc].tunnel[i]].has_a_bat)
			return(1);
	return(0);
}

int
pit_nearby(void)
{
	int i;

	/* check for pits in the immediate vicinity */
	for (i = 0; i < link_num; ++i)
		if (cave[cave[player_loc].tunnel[i]].has_a_pit)
			return(1);
	return(0);
}

int
wump_nearby(void)
{
	int i, j;

	/* check for a wumpus within TWO caves of where we are */
	for (i = 0; i < link_num; ++i) {
		if (cave[player_loc].tunnel[i] == wumpus_loc)
			return(1);
		for (j = 0; j < link_num; ++j)
			if (cave[cave[player_loc].tunnel[i]].tunnel[j] ==
			    wumpus_loc)
				return(1);
	}
	return(0);
}

void
move_wump(void)
{
	wumpus_loc = cave[wumpus_loc].tunnel[arc4random_uniform(link_num)];
#ifdef DEBUG
	if (debug)
		(void)printf("Wumpus moved to room %d\n",wumpus_loc);
#endif
}

int
int_compare(const void *a, const void *b)
{
	return(*(const int *)a < *(const int *)b ? -1 : 1);
}

void
instructions(void)
{
	const char *pager;
	pid_t pid;
	int status;
	int fd;

	/*
	 * read the instructions file, if needed, and show the user how to
	 * play this game!
	 */
	if (!getans("Instructions? (y-n) "))
		return;

	if ((fd = open(_PATH_WUMPINFO, O_RDONLY)) == -1) {
		(void)printf(
"Sorry, but the instruction file seems to have disappeared in a\n\
puff of greasy black smoke! (poof)\n");
		return;
	}

	if (!isatty(1))
		pager = "/bin/cat";
	else {
		if (!(pager = getenv("PAGER")) || (*pager == 0))
			pager = _PATH_PAGER;
	}
	switch (pid = fork()) {
	case 0: /* child */
		if (dup2(fd, 0) == -1)
			err(1, "dup2");
		(void)execl(_PATH_BSHELL, "sh", "-c", pager, (char *)NULL);
		err(1, "exec sh -c %s", pager);
		/* NOT REACHED */
	case -1:
		err(1, "fork");
		/* NOT REACHED */
	default:
		(void)waitpid(pid, &status, 0);
		close(fd);
		break;
	}
}

void
usage(void)
{
	(void)fprintf(stderr,
	    "usage: %s [-ho] [-a arrows] [-b bats] [-p pits] "
	    "[-r rooms] [-t tunnels]\n", getprogname());
	exit(1);
}

/* messages */
void
wump_kill(void)
{
	(void)printf(
"*ROAR* *chomp* *snurfle* *chomp*!\n\
Much to the delight of the Wumpus, you walk right into his mouth,\n\
making you one of the easiest dinners he's ever had!  For you, however,\n\
it's a rather unpleasant death.  The only good thing is that it's been\n\
so long since the evil Wumpus cleaned his teeth that you immediately\n\
pass out from the stench!\n");
}

void
wump_walk_kill(void)
{
	(void)printf(
"Oh dear.  All the commotion has managed to awaken the evil Wumpus, who\n\
has chosen to walk into this very room!  Your eyes open wide as they behold\n\
the great sucker-footed bulk that is the Wumpus; the mouth of the Wumpus\n\
also opens wide as the evil beast beholds dinner.\n\
*ROAR* *chomp* *snurfle* *chomp*!\n");
}

void
wump_bat_kill(void)
{
	(void)printf(
"Flap, flap.  The bats fly you right into the room with the evil Wumpus!\n\
The Wumpus, seeing a fine dinner flying overhead, takes a swipe at you,\n\
and the bats, not wanting to serve as hors d'oeuvres, drop their\n\
soon-to-be-dead weight and take off in the way that only bats flying out\n\
of a very bad place can.  As you fall towards the large, sharp, and very\n\
foul-smelling teeth of the Wumpus, you think, \"Man, this is going to hurt.\"\n\
It does.\n");
}

void
kill_wump(void)
{
	(void)printf(
"*thwock!* *groan* *crash*\n\n\
A horrible roar fills the cave, and you realize, with a smile, that you\n\
have slain the evil Wumpus and won the game!  You don't want to tarry for\n\
long, however, because not only is the Wumpus famous, but the stench of\n\
dead Wumpus is also quite well known--a stench powerful enough to slay the\n\
mightiest adventurer at a single whiff!!\n");
}

void
no_arrows(void)
{
	(void)printf(
"\nYou turn and look at your quiver, and realize with a sinking feeling\n\
that you've just shot your last arrow (figuratively, too).  Sensing this\n\
with its psychic powers, the evil Wumpus rampages through the cave, finds\n\
you, and with a mighty *ROAR* eats you alive!\n");
}

void
shoot_self(void)
{
	(void)printf(
"\n*Thwack!*  A sudden piercing feeling informs you that your wild arrow\n\
has ricocheted back and wedged in your side, causing extreme agony.  The\n\
evil Wumpus, with its psychic powers, realizes this and immediately rushes\n\
to your side, not to help, alas, but to EAT YOU!\n\
(*CHOMP*)\n");
}

/*
 * void
 * jump(int where)
 * {
 * 	(void)printf(
 * "\nWith a jaunty step you enter the magic tunnel.  As you do, you\n\
 * notice that the walls are shimmering and glowing.  Suddenly you feel\n\
 * a very curious, warm sensation and find yourself in room %d!!\n", where);
 * }
 */

void
pit_kill(void)
{
	(void)printf(
"*AAAUUUUGGGGGHHHHHhhhhhhhhhh...*\n\
The whistling sound and updraft as you walked into this room of the\n\
cave apparently weren't enough to clue you in to the presence of the\n\
bottomless pit.  You have a lot of time to reflect on this error as\n\
you fall many miles to the core of the earth.  Look on the bright side;\n\
you can at least find out if Jules Verne was right...\n");
}

void
pit_kill_bat(void)
{
	(void)printf(
"*AAAUUUUGGGGGHHHHHhhhhhhhhhh...*\n\
It appears the bats have decided to drop you into a bottomless pit.  At\n\
least, that's what the whistling sound and updraft would suggest.  Look on\n\
the bright side; you can at least find out if Jules Verne was right...\n");
}

void
pit_survive(void)
{
	(void)printf(
"Without conscious thought you grab for the side of the cave and manage\n\
to grasp onto a rocky outcrop.  Beneath your feet stretches the limitless\n\
depths of a bottomless pit!  Rock crumbles beneath your feet!\n");
}
@


1.32
log
@As per style(9), remove remaining lint-style comments from games/

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.31 2016/01/07 16:00:34 tb Exp $	*/
a181 1
		case '?':
d911 2
a912 2
	    "usage: wump [-ho] [-a arrows] [-b bats] [-p pits] "
	    "[-r rooms] [-t tunnels]\n");
@


1.31
log
@Some basic code maintenance in games/

- in main() replace exit with return
- drop some /* NOTREACHED */ lint comments along the way.
- make more use of standard CFLAGS, esp. -Wimplicit-function-declaration
- add and sort some headers when needed
- add straightforward pledges to some programs used at compile time

discussed with and ok mestre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.30 2016/01/04 17:33:24 mestre Exp $	*/
a267 1
	/* NOTREACHED */
a803 1
	/* NOTREACHED */
@


1.30
log
@More cleanup and sorting on header section

OK tb@@ and he also pointed out that for consistency with rest of the tree we
should include termios.h instead of sys/ttydefaults.h, where applicable
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.29 2016/01/03 14:38:17 mestre Exp $	*/
d258 1
a258 1
			exit(0);
@


1.29
log
@About 13 years ago when the idiom srandom(time()), and sometimes
srandom(time()+getpid()), was changed by srandomdev(), but #include <time.h>
lived up until this day so remove it.

Additionally, earlier than that, 18 years ago, random(6) was one of the first
consumers of arc4random(3) family, and was pulling it from dev/rndvar.h but
these days we pull it from stdlib.h, which is already done, so while here
remove dev/rndvar.h also.

"seems comprehensive to me" deraadt@@ and OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.28 2015/12/25 20:59:09 mestre Exp $	*/
a41 1
#include <sys/types.h>
@


1.28
log
@Declare usage() functions as __dead void, if they don't return, on games section.

Found another one in arithmetic(6) which also didn't return, and removed a function from number(6) which is not used anymore.

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.27 2015/11/30 09:00:02 tb Exp $	*/
d44 1
a50 1
#include <time.h>
d52 1
@


1.27
log
@last but not least: add pledge for wump(6)

one more of those games which fork a pager with instructions, so first
pledge "stdio rpath proc exec", then drop to pledge "stdio" afterwards.
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.26 2013/08/29 20:22:22 naddy Exp $	*/
d126 1
a126 1
void	usage(void);
@


1.26
log
@replace srandomdev()+random() with the arc4random*() family
tweaks and ok millert@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.25 2009/10/27 23:59:28 deraadt Exp $	*/
d138 3
d226 4
@


1.25
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.24 2007/04/02 15:27:13 jmc Exp $	*/
a203 1
	srandomdev();
d206 1
a206 1
			bat_num += (random() % (room_num / 2 - bat_num));
d208 1
a208 1
			pit_num += (random() % (room_num / 2 - pit_num));
d316 1
a316 1
	if (random() % 15 == 1)
d369 1
a369 1
		if (random() % 6 == 1) {
d382 1
a382 1
 *		jump(next_room = (random() % room_num) + 1);
d394 1
a394 1
			if (random() % 12 < 2) {
d410 2
a411 1
			next_room = player_loc = (random() % room_num) + 1;
d464 1
a464 1
		chance = random() % 10;
d485 2
a486 1
 *				arrow_location = (random() % room_num) + 1;
d490 1
a490 1
			link = (random() % link_num);
d533 2
a534 1
		if (random() % level == EASY ? 12 : 9 < (lastchance += 2)) {
d538 2
a539 1
				lastchance = random() % 3;   /* Reset for next game */
d593 1
a593 1
		delta = (random() % (room_num - 1)) + 1;
d608 1
a608 1
try_again:		link = (random() % room_num) + 1;
d617 1
a617 1
			if (random() % 2 == 1)
d684 1
a684 1
		j = random() % (20 - i);
d737 1
a737 1
			loc = (random() % room_num) + 1;
d748 1
a748 1
			loc = (random() % room_num) + 1;
d759 1
a759 1
	wumpus_loc = (random() % room_num) + 1;
d766 1
a766 1
		player_loc = (random() % room_num) + 1;
d845 1
a845 1
	wumpus_loc = cave[wumpus_loc].tunnel[random() % link_num];
@


1.24
log
@provide some missing arguments and tidy up usage(); from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.23 2004/07/10 07:26:24 deraadt Exp $	*/
a34 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)wump.c	8.1 (Berkeley) 5/31/93";
#else
static const char rcsid[] = "$OpenBSD: wump.c,v 1.23 2004/07/10 07:26:24 deraadt Exp $";
#endif
#endif /* not lint */
@


1.23
log
@more ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.22 2003/06/03 03:01:42 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: wump.c,v 1.22 2003/06/03 03:01:42 millert Exp $";
d918 2
a919 1
"usage: wump [-ho] [-a arrows] [-b bats] [-p pits] [-r rooms] [-t tunnels]\n");
@


1.22
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.21 2003/03/11 04:47:39 david Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: wump.c,v 1.21 2003/03/11 04:47:39 david Exp $";
d148 1
a148 1
main(int argc, char **argv)
d280 1
a280 1
display_room_stats()
d310 1
a310 1
take_action()
d339 1
a339 2
move_to(room_number)
	const char *room_number;
d571 1
a571 1
cave_init()
d663 1
a663 1
dodecahedral_cave_init()
d728 1
a728 1
clear_things_in_cave()
d741 1
a741 1
initialize_things_in_cave()
d813 1
a813 1
bats_nearby()
d825 1
a825 1
pit_nearby()
d837 1
a837 1
wump_nearby()
d854 1
a854 1
move_wump()
d870 1
a870 1
instructions()
d915 1
a915 1
usage()
d924 1
a924 1
wump_kill()
d936 1
a936 1
wump_walk_kill()
d947 1
a947 1
wump_bat_kill()
d960 1
a960 1
kill_wump()
d972 1
a972 1
no_arrows()
d982 1
a982 1
shoot_self()
d1004 1
a1004 1
pit_kill()
d1016 1
a1016 1
pit_kill_bat()
d1026 1
a1026 1
pit_survive()
@


1.21
log
@double words and spelling fixes
ok pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.20 2002/12/06 21:48:52 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: wump.c,v 1.20 2002/12/06 21:48:52 millert Exp $";
@


1.20
log
@Replace things like srandom(time(NULL)) with srandomdev(3).  random(3)
good enough for games but we should at least use a decent seed.
pjanzen@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.19 2002/07/30 05:35:22 pjanzen Exp $	*/
d50 1
a50 1
static const char rcsid[] = "$OpenBSD: wump.c,v 1.19 2002/07/30 05:35:22 pjanzen Exp $";
d474 1
a474 1
"The arrow wavers in its flight and and can go no further than room %d!\n",
d491 1
a491 1
"The arrow wavers in its flight and and can go no further than room %d!\n",
@


1.19
log
@ansi wump, plus a more accurate comment
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.18 2002/05/31 03:40:01 pjanzen Exp $	*/
d50 1
a50 1
static const char rcsid[] = "$OpenBSD$";
d222 1
a223 1
		srandom((int)time((time_t *)0));
a597 1
	srandom((int)time((time_t *)0));
a698 1
	srandom((int)time((time_t *)0));
@


1.18
log
@No dm -> no need to revoke setegid.
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.17 2002/02/16 21:27:12 millert Exp $	*/
d41 1
a41 1
static char copyright[] =
d50 1
a50 1
static char rcsid[] = "$OpenBSD: wump.c,v 1.17 2002/02/16 21:27:12 millert Exp $";
d55 2
a56 2
 * A very new version of the age old favorite Hunt-The-Wumpus game that has
 * been a part of the BSD distribution of Unix for longer than us old folk
d152 1
a152 3
main(argc, argv)
	int argc;
	char **argv;
d441 1
a441 2
shoot(room_list)
	char *room_list;
d566 1
a566 2
gcd(a, b)
	int a, b;
d795 1
a795 2
getans(prompt)
	const char *prompt;
d871 1
a871 2
int_compare(a, b)
	const void *a, *b;
d1001 1
a1001 2
 * jump(where)
 * 	int where;
@


1.17
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.16 2001/07/09 07:04:30 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: wump.c,v 1.16 2001/07/09 07:04:30 deraadt Exp $";
a156 4

	/* revoke */
	setegid(getgid());
	setgid(getgid());
@


1.16
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.15 2001/05/02 23:28:31 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: wump.c,v 1.15 2001/05/02 23:28:31 pjanzen Exp $";
d121 28
a148 28
int	bats_nearby __P((void));
void	cave_init __P((void));
void	clear_things_in_cave __P((void));
void	display_room_stats __P((void));
void	dodecahedral_cave_init __P((void));
int	gcd __P((int, int));
int	getans __P((const char *));
void	initialize_things_in_cave __P((void));
void	instructions __P((void));
int	int_compare __P((const void *, const void *));
/* void	jump __P((int)); */
void	kill_wump __P((void));
int	main __P((int, char **));
int	move_to __P((const char *));
void	move_wump __P((void));
void	no_arrows __P((void));
void	pit_kill __P((void));
void	pit_kill_bat __P((void));
int	pit_nearby __P((void));
void	pit_survive __P((void));
int	shoot __P((char *));
void	shoot_self __P((void));
int	take_action __P((void));
void	usage __P((void));
void	wump_kill __P((void));
void	wump_bat_kill __P((void));
void	wump_walk_kill __P((void));
int	wump_nearby __P((void));
@


1.15
log
@Ensure caves are connected; afghan@@afghanhound.org.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.14 2000/06/29 07:37:38 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: wump.c,v 1.14 2000/06/29 07:37:38 pjanzen Exp $";
d918 1
a918 1
		(void)execl(_PATH_BSHELL, "sh", "-c", pager, NULL);
@


1.14
log
@use errx(), tabify, and add -o option for original, old dodecahedron play.
(Last feature requested vehemently by Darren Leigh.)
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.13 2000/04/11 02:55:18 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: wump.c,v 1.13 2000/04/11 02:55:18 pjanzen Exp $";
d126 1
d572 11
d613 7
a619 2
	/* choose a random 'hop' delta for our guaranteed link */
	while (!(delta = random() % ((room_num - 1) / 2)));
@


1.13
log
@the the; some occurrences found by soren@@NetBSD.org
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.12 1999/09/25 15:52:21 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: wump.c,v 1.12 1999/09/25 15:52:21 pjanzen Exp $";
d107 1
d113 2
a114 2
int pit_num = PIT_COUNT;		/* # pits in cave */
int bat_num = BAT_COUNT;		/* # bats */
d125 1
d162 1
a162 1
	while ((c = getopt(argc, argv, "a:b:hp:r:t:d")) != -1)
d164 1
a164 1
	while ((c = getopt(argc, argv, "a:b:hp:r:t:")) != -1)
d181 3
d189 6
a194 10
			if (room_num < MIN_ROOMS_IN_CAVE) {
				(void)fprintf(stderr,
	"No self-respecting wumpus would live in such a small cave!\n");
				exit(1);
			}
			if (room_num > MAX_ROOMS_IN_CAVE) {
				(void)fprintf(stderr,
	"Even wumpii can't furnish caves that large!\n");
				exit(1);
			}
d198 3
a200 5
			if (link_num < 2) {
				(void)fprintf(stderr,
	"Wumpii like extra doors in their caves!\n");
				exit(1);
			}
d207 15
d223 3
a225 5
	    link_num > room_num - (room_num / 4)) {
		(void)fprintf(stderr,
"Too many tunnels!  The cave collapsed!\n(Fortunately, the wumpus escaped!)\n");
		exit(1);
	}
d238 7
a244 11
	if (bat_num > room_num / 2 - 1) {
		(void)fprintf(stderr,
"The wumpus refused to enter the cave, claiming it was too crowded!\n");
		exit(1);
	}

	if (pit_num > room_num / 2 - 1) {
		(void)fprintf(stderr,
"The wumpus refused to enter the cave, claiming it was too dangerous!\n");
		exit(1);
	}
d247 4
a250 1
	cave_init();
d271 1
a271 1
		(void)fpurge(stdin); 
d278 6
a283 2
		if (!getans("In the same cave? (y-n) "))
			cave_init();
d412 1
a412 1
			if (just_moved_by_bats) 
d423 1
a423 1
				if (just_moved_by_bats) 
d469 1
a469 1
			     if (!(p = strtok(fgets(answer, sizeof(answer), stdin),
d486 1
a486 1
		if (next == 0) 
d488 1
a488 1
           
d621 2
a622 2
               /* don't let a room connect to itself */
               if (link == i)
d660 66
d759 2
a760 2
          /* Above used to be &&;  || makes sense but so does just 
           * checking cave[loc].has_a_pit  */
d813 1
a813 1
{ 
d825 1
a825 1
{ 
d918 1
a918 1
"usage: wump [-h] [-a arrows] [-b bats] [-p pits] [-r rooms] [-t tunnels]\n");
@


1.12
log
@Tidying and minor changes from or based on jsm28@@cam.ac.uk's work for the
Linux bsd-games package and NetBSD.  Mainly using 'const'.
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.11 1999/08/17 09:13:12 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: wump.c,v 1.11 1999/08/17 09:13:12 millert Exp $";
d861 1
a861 1
also opens wide as the the evil beast beholds dinner.\n\
@


1.11
log
@More <sys/file.h> vs. <fcntl.h> and open() flags fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.10 1999/07/31 18:52:00 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: wump.c,v 1.10 1999/07/31 18:52:00 pjanzen Exp $";
d68 1
d276 1
a276 1
	register int i;
d559 2
a560 3
	register int i, j, k, link;
	int delta, int_compare();
	time_t time();
d647 1
a647 1
	register int i;
d660 1
a660 1
	register int i, loc;
d733 1
a733 1
	register int i;
d745 1
a745 1
	register int i;
d757 1
a757 1
	register int i, j;
@


1.10
log
@fix a -Wcast-qual warning: jsm28@@cam.ac.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.9 1999/06/10 22:58:24 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: wump.c,v 1.9 1999/06/10 22:58:24 pjanzen Exp $";
a60 1
#include <sys/file.h>
d63 1
@


1.9
log
@jsm28@@cam.ac.uk : handle PAGER in a manner consistent with the
Single UNIX specification for mailx and man
(http://www.opengroup.org/onlinepubs/7908799/xcu/mailx.html).
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.8 1998/08/19 07:42:27 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: wump.c,v 1.8 1998/08/19 07:42:27 pjanzen Exp $";
d785 1
a785 1
	return(*(int *)a < *(int *)b ? -1 : 1);
@


1.8
log
@tags, formatting, ANSI-fication, prototypes, de-typos, and the occasional
initialization, removal of unused variable, or other minor fix.  Most
changes are from or inspired by NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: wump.c,v 1.7 1998/03/12 09:09:43 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: wump.c,v 1.7 1998/03/12 09:09:43 pjanzen Exp $";
d62 3
d261 2
a262 1
		if (!getans("\nCare to play another game? (y-n) "))
d264 1
d791 4
a794 1
	char buf[120], *p, *getenv();
d803 1
a803 1
	if (access(_PATH_WUMPINFO, R_OK)) {
d810 21
a830 6
	if (!(p = getenv("PAGER")) ||
	    strlen(p) > sizeof(buf) + strlen(_PATH_WUMPINFO) + 5)
		p = _PATH_PAGER;

	(void)sprintf(buf, "%s %s", p, _PATH_WUMPINFO);
	(void)system(buf);
@


1.7
log
@OpenBSD ID (changed from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD$";
d116 26
a141 26
int     bats_nearby __P((void));
void    cave_init __P((void));
void    clear_things_in_cave __P((void));
void    display_room_stats __P((void));
int     getans __P((const char *));
void    initialize_things_in_cave __P((void));
void    instructions __P((void));
int     int_compare __P((const void *, const void *));
/* void    jump __P((int)); */
void    kill_wump __P((void));
int     main __P((int, char **));
int     move_to __P((const char *));
void    move_wump __P((void));
void    no_arrows __P((void));
void    pit_kill __P((void));
void    pit_kill_bat __P((void));
int     pit_nearby __P((void));
void    pit_survive __P((void));
int     shoot __P((char *));
void    shoot_self __P((void));
int     take_action __P((void));
void    usage __P((void));
void    wump_kill __P((void));
void    wump_bat_kill __P((void));
void    wump_walk_kill __P((void));
int     wump_nearby __P((void));
a148 1
	extern char *optarg;
d397 1
a397 1
		if (cave[next_room].has_a_pit)
d408 1
d444 1
a444 1
		if (!(p = strtok(room_list, " \t\n")))
d456 1
@


1.6
log
@further fixes from pjanzen@@foatdi.harvard.edu
@
text
@d1 1
a1 1
/*	$NetBSD: wump.c,v 1.4 1995/04/24 12:26:22 cgd Exp $	*/
d50 1
a50 1
static char rcsid[] = "$NetBSD: wump.c,v 1.4 1995/04/24 12:26:22 cgd Exp $";
@


1.5
log
@tweaks and cleanup; pjanzen@@foatdi.harvard.edu
@
text
@d581 1
a581 1
	while (!(delta = random() % (room_num - 1)));
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d63 1
d65 1
d70 1
a70 1
#define	MAX_ARROW_SHOT_DISTANCE	6		/* +1 for '0' stopper */
d116 29
d213 5
a217 2
		bat_num += ((random() % (room_num / 2)) + 1);
		pit_num += ((random() % (room_num / 2)) + 1);
d220 4
a223 1
	if (bat_num > room_num / 2) {
d229 1
a229 1
	if (pit_num > room_num / 2) {
d253 1
d257 1
d261 2
a262 3
		if (getans("In the same cave? (y-n) "))
			clear_things_in_cave();
		else
d268 1
d293 1
a293 1
		if (cave[player_loc].tunnel[i] <= room_num)
d298 1
d327 1
d329 1
a329 1
	char *room_number;
d345 5
a349 5
	if (next_room == room_num + 1 &&
	    cave[player_loc].tunnel[link_num-1] != next_room)
		++next_room;

	while (next_room < 1 || next_room > room_num + 1) {
d352 1
a352 1
		if (next_room > room_num + 1)
d354 6
a359 6
		if (next_room == room_num + 1 &&
		    cave[player_loc].tunnel[link_num-1] != next_room) {
			(void)printf("What?  The cave isn't that big!\n");
			++next_room;
		}
		(void)printf("To which room do you wish to move? ");
d378 1
a378 1
				wump_kill();
d386 3
a388 3
	if (next_room == room_num + 1)
		jump(next_room = (random() % room_num) + 1);

d392 4
a395 1
			wump_kill();
d403 4
a406 1
				pit_kill();
d424 1
d430 1
a430 1
	char *p, *strtok();
d438 2
a439 2
	 * such.  If it misses, this routine will *move* the wumpus one room.
	 * If it's the last arrow, the player then dies...  Returns 1 if the
d446 8
a453 3
				(void)printf(
			"The arrow falls to the ground at your feet!\n");
				return(0);
d458 2
a459 1
"The arrow wavers in its flight and and can go no further!\n");
d462 1
d464 16
d485 6
a490 6
			if (next > room_num) {
				(void)printf(
"A faint gleam tells you the arrow has gone through a magic tunnel!\n");
				arrow_location = (random() % room_num) + 1;
			} else
				arrow_location = next;
d493 1
a493 1
			if (link == player_loc)
d495 1
a495 1
"*thunk*  The arrow can't find a way from %d to %d and flys back into\n\
d498 6
a503 1
			else if (cave[arrow_location].tunnel[link] > room_num)
d505 3
a507 9
"*thunk*  The arrow flys randomly into a magic tunnel, thence into\n\
room %d!\n",
				    cave[arrow_location].tunnel[link]);
			else
				(void)printf(
"*thunk*  The arrow can't find a way from %d to %d and flys randomly\n\
into room %d!\n",
				    arrow_location, next,
				    cave[arrow_location].tunnel[link]);
a508 1
			break;
d510 8
a517 10
		chance = random() % 10;
		if (roomcnt == 3 && chance < 2) {
			(void)printf(
"Your bowstring breaks!  *twaaaaaang*\n\
The arrow is weakly shot and can go no further!\n");
			break;
		} else if (roomcnt == 4 && chance < 6) {
			(void)printf(
"The arrow wavers in its flight and and can go no further!\n");
			break;
a518 1
	}
d520 4
a523 12
	/*
	 * now we've gotten into the new room let us see if El Wumpo is
	 * in the same room ... if so we've a HIT and the player WON!
	 */
	if (arrow_location == wumpus_loc) {
		kill_wump();
		return(1);
	}

	if (arrow_location == player_loc) {
		shoot_self();
		return(1);
d537 5
a541 3
			if (wumpus_loc == player_loc)
				wump_kill();
			lastchance = random() % 3;
d545 1
d549 1
d565 8
d581 1
a581 1
	while (!(delta = random() % room_num));
d588 3
a590 1
	/* now fill in the rest of the cave with random connections */
d600 3
d610 6
a615 5

				/* if open link, use it, force exit */
				if (cave[link].tunnel[k] == -1) {
					cave[link].tunnel[k] = i;
					k = link_num;
d638 1
d651 1
d671 3
a673 1
		} while (cave[loc].has_a_pit && cave[loc].has_a_bat);
d684 1
a684 1
		(void)printf("<wumpus in room %d>\n", loc);
d689 7
a695 2
	} while (player_loc == wumpus_loc || (level == HARD ?
	    (link_num / room_num < 0.4 ? wump_nearby() : 0) : 0));
d698 1
d700 1
a700 1
	char *prompt;
d724 1
d736 1
d748 1
d765 1
d769 4
d775 1
d777 1
a777 1
	int *a, *b;
d779 1
a779 1
	return(*a < *b ? -1 : 1);
d782 1
d809 1
d818 1
a818 1

d823 1
a823 1
Much to the delight of the Wumpus, you walked right into his mouth,\n\
d827 12
a838 1
passed out from the stench!\n");
d841 14
d862 1
a862 1
dead Wumpus is also quite well known, a stench plenty enough to slay the\n\
d866 1
d872 1
a872 1
with its psychic powers, the evil Wumpus rampagees through the cave, finds\n\
d876 1
d880 4
a883 4
"\n*Thwack!*  A sudden piercing feeling informs you that the ricochet\n\
of your wild arrow has resulted in it wedging in your side, causing\n\
extreme agony.  The evil Wumpus, with its psychic powers, realizes this\n\
and immediately rushes to your side, not to help, alas, but to EAT YOU!\n\
d887 11
a897 8
jump(where)
	int where;
{
	(void)printf(
"\nWith a jaunty step you enter the magic tunnel.  As you do, you\n\
notice that the walls are shimmering and glowing.  Suddenly you feel\n\
a very curious, warm sensation and find yourself in room %d!!\n", where);
}
d899 1
d905 1
a905 1
cave apparently wasn't enough to clue you in to the presence of the\n\
d911 11
@


1.3
log
@proper gid revoke
@
text
@d126 1
a126 1
	while ((c = getopt(argc, argv, "a:b:hp:r:t:d")) != EOF)
d128 1
a128 1
	while ((c = getopt(argc, argv, "a:b:hp:r:t:")) != EOF)
@


1.2
log
@setgid games, not setuid games. closes a neat set of holes
@
text
@d121 2
@


1.1
log
@Initial revision
@
text
@d121 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

