head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.10
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.8
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.4.0.6
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.1.0.22
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.20
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.18
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.16
	OPENBSD_5_0:1.1.0.14
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.12
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.10
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.6
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.8
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.4
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.2
	OPENBSD_4_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.01.08.13.40.05;	author tb;	state Exp;
branches;
next	1.9;
commitid	deG8pXu1tXVoNIxq;

1.9
date	2015.12.31.15.20.36;	author mestre;	state Exp;
branches;
next	1.8;
commitid	NXTXcl91lB5rsV7P;

1.8
date	2015.02.07.03.26.20;	author tedu;	state Exp;
branches;
next	1.7;
commitid	gyRog8burdNChGv8;

1.7
date	2015.02.07.03.07.02;	author tedu;	state Exp;
branches;
next	1.6;
commitid	PKNYAOzVBptalUvk;

1.6
date	2015.02.07.02.56.00;	author miod;	state Exp;
branches;
next	1.5;
commitid	bUAJUHh6T19RMyrl;

1.5
date	2015.02.07.01.37.30;	author miod;	state Exp;
branches;
next	1.4;
commitid	qvXLE1LsRPyIFzbt;

1.4
date	2013.10.15.22.09.29;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2013.10.15.05.45.55;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2013.08.29.20.22.14;	author naddy;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.01.21.05.50;	author miod;	state Exp;
branches;
next	;


desc
@@


1.10
log
@add missing 'void'

ok mestre@@
@
text
@/*	$OpenBSD: ksyms.c,v 1.9 2015/12/31 15:20:36 mestre Exp $	*/

/*
 * Copyright (c) 2008 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <ctype.h>
#include <curses.h>
#include <elf_abi.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "hangman.h"

static int ksyms_elf_parse(void);

void
sym_getword(void)
{
	uint tries;
	off_t pos;
	int buflen;
	char symbuf[1 + BUFSIZ], *sym, *end;
	size_t symlen;

	for (tries = 0; tries < MAXBADWORDS; tries++) {
		pos = arc4random_uniform(symsize);
		if (lseek(symfd, pos + symoffs, SEEK_SET) == -1)
			continue;
		buflen = read(symfd, symbuf, BUFSIZ);
		if (buflen < 0)
			continue;

		/*
		 * The buffer is hopefully large enough to hold at least
		 * a complete symbol, i.e. two occurences of NUL, or
		 * one occurence of NUL and the buffer containing the end
		 * of the string table. We make sure the buffer will be
		 * NUL terminated in all cases.
		 */
		if (buflen + pos >= symsize)
			buflen = symsize - pos;
		*(end = symbuf + buflen) = '\0';

		for (sym = symbuf; *sym != '\0'; sym++)
			;
		if (sym == end)
			continue;

		symlen = strlen(++sym);
		if (symlen < MINLEN || symlen > MAXLEN)
			continue;

		/* ignore symbols containing dots or dollar signs */
		if (strchr(sym, '.') != NULL || strchr(sym, '$') != NULL)
			continue;

		break;
	}

	if (tries >= MAXBADWORDS) {
		mvcur(0, COLS - 1, LINES -1, 0);
		endwin();
		errx(1, "can't seem a suitable symbol in %s",
		    Dict_name);
	}

	strlcpy(Word, sym, sizeof Word);
	strlcpy(Known, sym, sizeof Known);
	for (sym = Known; *sym != '\0'; sym++) {
		if (*sym == '-')
			*sym = '_';	/* try not to confuse player */
		if (isalnum((unsigned char)*sym))
			*sym = '-';
	}
}

int
sym_setup(void)
{
	if ((symfd = open(Dict_name, O_RDONLY)) < 0)
		return -1;

	if (ksyms_elf_parse() == 0)
		return 0;

	close(symfd);
	errno = ENOEXEC;
	return -1;
}

int
ksyms_elf_parse(void)
{
	Elf_Ehdr eh;
	Elf_Shdr sh;
	uint s;

	if (lseek(symfd, 0, SEEK_SET) == -1)
		return -1;

	if (read(symfd, &eh, sizeof eh) != sizeof eh)
		return -1;

	if (!IS_ELF(eh))
		return -1;

	if (lseek(symfd, eh.e_shoff, SEEK_SET) == -1)
		return -1;

	symoffs = 0;
	symsize = 0;

	for (s = 0; s < eh.e_shnum; s++) {
		if (read(symfd, &sh, sizeof sh) != sizeof sh)
			return -1;

		/*
		 * There should be two string table sections, one with the
		 * name of the sections themselves, and one with the symbol
		 * names. Just pick the largest one.
		 */
		if (sh.sh_type == SHT_STRTAB) {
			if (symsize > (off_t)sh.sh_size)
				continue;

			symoffs = (off_t)sh.sh_offset;
			symsize = (off_t)sh.sh_size;
		}
	}

	if (symsize == 0)
		return -1;

	return 0;
}
@


1.9
log
@Include only needed header files per each source file

With help and OK from tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.8 2015/02/07 03:26:20 tedu Exp $	*/
d34 1
a34 1
sym_getword()
d95 1
a95 1
sym_setup()
d109 1
a109 1
ksyms_elf_parse()
@


1.8
log
@by popular request, stop giving away numeric letters. no more will the
appearance of 509 in a symbol name tell you what letter to guess first.
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.7 2015/02/07 03:07:02 tedu Exp $	*/
a18 1
#include <unistd.h>
d20 3
d25 1
d27 1
a27 3

#include <sys/exec.h>
#include <elf_abi.h>
@


1.7
log
@unsigned char for ctype functions
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.6 2015/02/07 02:56:00 miod Exp $	*/
d88 1
a88 1
		if (isalpha((unsigned char)*sym))
@


1.6
log
@Ignore ELF symbols containing dots or dollar signs. Suggested by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.5 2015/02/07 01:37:30 miod Exp $	*/
d88 1
a88 1
		if (isalpha(*sym))
@


1.5
log
@By popular demand, allow any ELF file to be passed to -d as a word list, in
which case its symbols will be used.
Which means that `hangman -k' is equivalent to `hangman -d /bsd' now.

ok beck@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.4 2013/10/15 22:09:29 deraadt Exp $	*/
d30 1
a30 1
int	ksyms_elf_parse();
d60 2
a61 1
		for (sym = symbuf; *sym != '\0'; sym++) ;
d69 4
d79 1
a79 1
		errx(1, "can't seem a suitable kernel symbol in %s",
@


1.4
log
@remove conditionals for ELF; prodding by patrick keshishian
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.3 2013/10/15 05:45:55 deraadt Exp $	*/
d33 1
a33 1
kgetword()
d42 2
a43 2
		pos = arc4random_uniform(ksymsize);
		if (lseek(ksyms, pos + ksymoffs, SEEK_SET) == -1)
d45 1
a45 1
		buflen = read(ksyms, symbuf, BUFSIZ);
d56 2
a57 2
		if (buflen + pos >= ksymsize)
			buflen = ksymsize - pos;
d89 1
a89 1
ksetup()
d91 2
a92 2
	if ((ksyms = open(Dict_name, O_RDONLY)) < 0)
		return ksyms;
d97 1
a97 1
	close(ksyms);
d109 1
a109 1
	if (lseek(ksyms, 0, SEEK_SET) == -1)
d112 1
a112 1
	if (read(ksyms, &eh, sizeof eh) != sizeof eh)
d118 1
a118 1
	if (lseek(ksyms, eh.e_shoff, SEEK_SET) == -1)
d121 2
a122 2
	ksymoffs = 0;
	ksymsize = 0;
d125 1
a125 1
		if (read(ksyms, &sh, sizeof sh) != sizeof sh)
d134 1
a134 1
			if (ksymsize > (off_t)sh.sh_size)
d137 2
a138 2
			ksymoffs = (off_t)sh.sh_offset;
			ksymsize = (off_t)sh.sh_size;
d142 1
a142 1
	if (ksymsize == 0)
@


1.3
log
@no more a.out support here
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.2 2013/08/29 20:22:14 naddy Exp $	*/
a25 1
#ifdef _NLIST_DO_ELF
a26 1
#endif
a93 6
	/*
	 * Relaxed header check - /dev/ksyms is either a native a.out
	 * binary or a native ELF binary.
	 */

#ifdef _NLIST_DO_ELF
a95 1
#endif
a101 1
#ifdef _NLIST_DO_ELF
a146 1
#endif
@


1.2
log
@replace srandomdev()+random() with the arc4random*() family
tweaks and ok millert@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.1 2008/04/01 21:05:50 miod Exp $	*/
a31 1
int	ksyms_aout_parse();
a105 5
#ifdef _NLIST_DO_AOUT
	if (ksyms_aout_parse() == 0)
		return 0;
#endif

a153 31

	return 0;
}
#endif

#ifdef _NLIST_DO_AOUT
int
ksyms_aout_parse()
{
	struct exec eh;
	uint32_t size;

	if (lseek(ksyms, 0, SEEK_SET) == -1)
		return -1;

	if (read(ksyms, &eh, sizeof eh) != sizeof eh)
		return -1;

	if (N_BADMAG(eh))
		return -1;

	ksymoffs = (off_t)N_STROFF(eh);
	if (lseek(ksyms, ksymoffs, SEEK_SET) == -1)
		return -1;

	if (read(ksyms, &size, sizeof size) != sizeof size)
		return -1;
	ksymoffs += sizeof size;
	if (size <= sizeof size)
		return -1;
	ksymsize = (off_t)size - sizeof size;
@


1.1
log
@Add a -k option to use the kernel symbols as the words file.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 1
a45 1
		pos = (double) random() / (RAND_MAX + 1.0) * (double)ksymsize;
@

