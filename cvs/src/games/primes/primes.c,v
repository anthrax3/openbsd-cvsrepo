head	1.23;
access;
symbols
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.22.0.2
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.15.0.26
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.18
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.22
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.20
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.16
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.14
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.12
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.10
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.6
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.4
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.13.0.14
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.12
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.10
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.8
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.6
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.7.0.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.6
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2016.08.31.04.48.43;	author tb;	state Exp;
branches;
next	1.22;
commitid	ntrmbwZsvZeFFG7b;

1.22
date	2016.03.07.12.07.56;	author mestre;	state Exp;
branches;
next	1.21;
commitid	NZhYxChmyb9vOEMM;

1.21
date	2016.01.07.16.00.33;	author tb;	state Exp;
branches;
next	1.20;
commitid	IwzFE3fG5RnKTWNh;

1.20
date	2016.01.04.11.58.35;	author mestre;	state Exp;
branches;
next	1.19;
commitid	TBXFQYiwdVBhodpy;

1.19
date	2015.12.25.20.59.09;	author mestre;	state Exp;
branches;
next	1.18;
commitid	5J5Os05YMVA0ZKC5;

1.18
date	2015.11.30.08.53.53;	author tb;	state Exp;
branches;
next	1.17;
commitid	KfXheU9UqGA3roLO;

1.17
date	2015.10.24.17.34.16;	author mmcc;	state Exp;
branches;
next	1.16;
commitid	pS54ACdQhQItULRI;

1.16
date	2015.09.07.00.49.20;	author tedu;	state Exp;
branches;
next	1.15;
commitid	DEM6628OiFFc8Da6;

1.15
date	2009.10.27.23.59.26;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.06.20.50.55;	author chl;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.09.15.59.26;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.03.03.01.40;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.31.03.40.01;	author pjanzen;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.11;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.19.22.50.57;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.19.16.30.43;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	99.09.26.05.30.38;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	99.09.25.15.52.20;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	98.08.19.07.40.52;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.40.42;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.12.22.20.01.43;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.12.19.22.21.49;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.13;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.13;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Fix a bogus comment: "factors of" -> "coprime to".  Replace the
nonsensical "if and only iff" with "if and only if" and zap some
trailing whitespace.
@
text
@/*	$OpenBSD: primes.c,v 1.22 2016/03/07 12:07:56 mestre Exp $	*/
/*	$NetBSD: primes.c,v 1.5 1995/04/24 12:24:47 cgd Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Landon Curt Noll.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * primes - generate a table of primes between two values
 *
 * By: Landon Curt Noll chongo@@toad.com, ...!{sun,tolsoft}!hoptoad!chongo
 *
 * chongo <for a good prime call: 391581 * 2^216193 - 1> /\oo/\
 *
 * usage:
 *	primes [start [stop]]
 *
 *	Print primes >= start and < stop.  If stop is omitted,
 *	the value 4294967295 (2^32-1) is assumed.  If start is
 *	omitted, start is read from standard input.
 *
 * validation check: there are 664579 primes between 0 and 10^7
 */

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "primes.h"

/*
 * Eratosthenes sieve table
 *
 * We only sieve the odd numbers.  The base of our sieve windows is always odd.
 * If the base of the table is 1, table[i] represents 2*i-1.  After the sieve,
 * table[i] == 1 if and only if 2*i-1 is prime.
 *
 * We make TABSIZE large to reduce the overhead of inner loop setup.
 */
char table[TABSIZE];	 /* Eratosthenes sieve of odd numbers */

/*
 * prime[i] is the (i+1)th prime.
 *
 * We are able to sieve 2^32-1 because this byte table yields all primes
 * up to 65537 and 65537^2 > 2^32-1.
 */
extern const ubig prime[];
extern const ubig *pr_limit;		/* largest prime in the prime array */

/*
 * To avoid excessive sieves for small factors, we use the table below to
 * setup our sieve blocks.  Each element represents an odd number starting
 * with 1.  All non-zero elements are coprime to 3, 5, 7, 11 and 13.
 */
extern const char pattern[];
extern const int pattern_size;	/* length of pattern array */

void	primes(ubig, ubig);
ubig	read_num_buf(void);
__dead void	usage(void);

int
main(int argc, char *argv[])
{
	ubig start;		/* where to start generating */
	ubig stop;		/* don't generate at or above this value */
	int ch;
	char *p;

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	while ((ch = getopt(argc, argv, "h")) != -1) {
		switch (ch) {
		case 'h':
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	start = 0;
	stop = BIG;

	/*
	 * Convert low and high args.  Strtoul(3) sets errno to
	 * ERANGE if the number is too large, but, if there's
	 * a leading minus sign it returns the negation of the
	 * result of the conversion, which we'd rather disallow.
	 */
	switch (argc) {
	case 2:
		/* Start and stop supplied on the command line. */
		if (argv[0][0] == '-' || argv[1][0] == '-')
			errx(1, "negative numbers aren't permitted.");

		errno = 0;
		start = strtoul(argv[0], &p, 10);
		if (errno)
			err(1, "%s", argv[0]);
		if (*p != '\0')
			errx(1, "%s: illegal numeric format.", argv[0]);

		errno = 0;
		stop = strtoul(argv[1], &p, 10);
		if (errno)
			err(1, "%s", argv[1]);
		if (*p != '\0')
			errx(1, "%s: illegal numeric format.", argv[1]);
		break;
	case 1:
		/* Start on the command line. */
		if (argv[0][0] == '-')
			errx(1, "negative numbers aren't permitted.");

		errno = 0;
		start = strtoul(argv[0], &p, 10);
		if (errno)
			err(1, "%s", argv[0]);
		if (*p != '\0')
			errx(1, "%s: illegal numeric format.", argv[0]);
		break;
	case 0:
		start = read_num_buf();
		break;
	default:
		usage();
	}

	if (start > stop)
		errx(1, "start value must be less than stop value.");
	primes(start, stop);
	return 0;
}

/*
 * read_num_buf --
 *	This routine returns a number n, where 0 <= n && n <= BIG.
 */
ubig
read_num_buf(void)
{
	ubig val;
	char *p, buf[100];		/* > max number of digits. */

	for (;;) {
		if (fgets(buf, sizeof(buf), stdin) == NULL) {
			if (ferror(stdin))
				err(1, "stdin");
			exit(0);
		}
		buf[strcspn(buf, "\n")] = '\0';
		for (p = buf; isblank((unsigned char)*p); ++p)
			;
		if (*p == '\0')
			continue;
		if (*p == '-')
			errx(1, "negative numbers aren't permitted.");
		errno = 0;
		val = strtoul(buf, &p, 10);
		if (errno)
			err(1, "%s", buf);
		for (; isblank((unsigned char)*p); ++p)
			;
		if (*p != '\0')
			errx(1, "%s: illegal numeric format.", buf);
		return (val);
	}
}

/*
 * primes - sieve and print primes from start up to and but not including stop
 * start: where to start generating
 * stop : don't generate at or above this value
 */
void
primes(ubig start, ubig stop)
{
	char *q;		/* sieve spot */
	ubig factor;		/* index and factor */
	char *tab_lim;		/* the limit to sieve on the table */
	const ubig *p;		/* prime table pointer */
	ubig fact_lim;		/* highest prime for current block */
	ubig mod;

	/*
	 * A number of systems can not convert double values into unsigned
	 * longs when the values are larger than the largest signed value.
	 * We don't have this problem, so we can go all the way to BIG.
	 */
	if (start < 3) {
		start = (ubig)2;
	}
	if (stop < 3) {
		stop = (ubig)2;
	}
	if (stop <= start) {
		return;
	}

	/*
	 * be sure that the values are odd, or 2
	 */
	if (start != 2 && (start&0x1) == 0) {
		++start;
	}
	if (stop != 2 && (stop&0x1) == 0) {
		++stop;
	}

	/*
	 * quick list of primes <= pr_limit
	 */
	if (start <= *pr_limit) {
		/* skip primes up to the start value */
		for (p = &prime[0], factor = prime[0];
		    factor < stop && p <= pr_limit; factor = *(++p)) {
			if (factor >= start) {
				printf("%lu\n", (unsigned long) factor);
			}
		}
		/* return early if we are done */
		if (p <= pr_limit) {
			return;
		}
		start = *pr_limit+2;
	}

	/*
	 * we shall sieve a bytemap window, note primes and move the window
	 * upward until we pass the stop point
	 */
	while (start < stop) {
		/*
		 * factor out 3, 5, 7, 11 and 13
		 */
		/* initial pattern copy */
		factor = (start%(2*3*5*7*11*13))/2; /* starting copy spot */
		memcpy(table, &pattern[factor], pattern_size-factor);
		/* main block pattern copies */
		for (fact_lim=pattern_size-factor;
		    fact_lim+pattern_size<=TABSIZE; fact_lim+=pattern_size) {
			memcpy(&table[fact_lim], pattern, pattern_size);
		}
		/* final block pattern copy */
		memcpy(&table[fact_lim], pattern, TABSIZE-fact_lim);

		/*
		 * sieve for primes 17 and higher
		 */
		/* note highest useful factor and sieve spot */
		if (stop-start > TABSIZE+TABSIZE) {
			tab_lim = &table[TABSIZE]; /* sieve it all */
			fact_lim = (int)sqrt(
					(double)(start)+TABSIZE+TABSIZE+1.0);
		} else {
			tab_lim = &table[(stop-start)/2]; /* partial sieve */
			fact_lim = (int)sqrt((double)(stop)+1.0);
		}
		/* sieve for factors >= 17 */
		factor = 17;	/* 17 is first prime to use */
		p = &prime[7];	/* 19 is next prime, pi(19)=7 */
		do {
			/* determine the factor's initial sieve point */
			mod = start % factor;
			if (mod & 0x1)
				q = &table[(factor - mod)/2];
			else
				q = &table[mod ? factor-(mod/2) : 0];
			/* sieve for our current factor */
			for ( ; q < tab_lim; q += factor) {
				*q = '\0'; /* sieve out a spot */
			}
		} while ((factor=(ubig)(*(p++))) <= fact_lim);

		/*
		 * print generated primes
		 */
		for (q = table; q < tab_lim; ++q, start+=2) {
			if (*q) {
				printf("%lu\n", (unsigned long) start);
			}
		}
	}
}

void
usage(void)
{
	(void)fprintf(stderr, "usage: %s [start [stop]]\n", getprogname());
	exit(1);
}
@


1.22
log
@- General changes:
- Remove -? from getopt(3) options, but still keep (or add) -h where applicable
- Replace hardcoded program strings by getprogname(3)

- Specific changes:
- atc(6): this used -? and -u for usage(), remove both from game and manpage
- bcd(6): use __progname instead of getprogname(3), no need to include stdlib.h
- hunt(6): replace fputs(3) by fprintf(3)

OK tb@@ after his suggestions
@
text
@d1 1
a1 1
/*	$OpenBSD: primes.c,v 1.21 2016/01/07 16:00:33 tb Exp $	*/
d67 3
a69 3
 * We only sieve the odd numbers.  The base of our sieve windows are always
 * odd.  If the base of table is 1, table[i] represents 2*i-1.  After the
 * sieve, table[i] == 1 if and only iff 2*i-1 is prime.
d78 1
a78 1
 * We are able to sieve 2^32-1 because this byte table yields all primes 
d85 3
a87 3
 * To avoid excessive sieves for small factors, we use the table below to 
 * setup our sieve blocks.  Each element represents a odd number starting 
 * with 1.  All non-zero elements are factors of 3, 5, 7, 11 and 13.
@


1.21
log
@Some basic code maintenance in games/

- in main() replace exit with return
- drop some /* NOTREACHED */ lint comments along the way.
- make more use of standard CFLAGS, esp. -Wimplicit-function-declaration
- add and sort some headers when needed
- add straightforward pledges to some programs used at compile time

discussed with and ok mestre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: primes.c,v 1.20 2016/01/04 11:58:35 mestre Exp $	*/
d107 1
a107 1
	while ((ch = getopt(argc, argv, "")) != -1) {
d109 1
a109 1
		case '?':
d325 1
a325 1
	(void)fprintf(stderr, "usage: primes [start [stop]]\n");
@


1.20
log
@More headers removal and sorted the remaining alphabetically.

Most noticeable that were removed are sys/types.h which will be included from
stdlib.h and in turn also brings along sys/cdefs.h. The other one is limits.h
that was used with the old idiom (denom * random() / LONG_MAX), although it was
only removed were applicable (some files still need that header).

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: primes.c,v 1.19 2015/12/25 20:59:09 mestre Exp $	*/
d168 1
a168 1
	exit(0);
@


1.19
log
@Declare usage() functions as __dead void, if they don't return, on games section.

Found another one in arithmetic(6) which also didn't return, and removed a function from number(6) which is not used anymore.

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: primes.c,v 1.18 2015/11/30 08:53:53 tb Exp $	*/
a52 1
#include <sys/types.h>
a55 1
#include <limits.h>
@


1.18
log
@primes only needs pledge "stdio".
@
text
@d1 1
a1 1
/*	$OpenBSD: primes.c,v 1.17 2015/10/24 17:34:16 mmcc Exp $	*/
d96 1
a96 1
void	usage(void);
@


1.17
log
@Cast isblank()'s argument to unsigned char.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: primes.c,v 1.16 2015/09/07 00:49:20 tedu Exp $	*/
d105 3
@


1.16
log
@cosmetic fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: primes.c,v 1.15 2009/10/27 23:59:26 deraadt Exp $	*/
d187 1
a187 1
		for (p = buf; isblank(*p); ++p)
d197 1
a197 1
		for (; isblank(*p); ++p)
@


1.15
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: primes.c,v 1.14 2007/09/06 20:50:55 chl Exp $	*/
d106 1
a106 1
	while ((ch = getopt(argc, argv, "")) != -1)
d112 1
d187 2
a188 1
		for (p = buf; isblank(*p); ++p);
d197 2
a198 1
		for (; isblank(*p); ++p);
@


1.14
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok moritz@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: primes.c,v 1.13 2004/07/09 15:59:26 deraadt Exp $	*/
a34 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)primes.c	8.5 (Berkeley) 5/10/95";
#else
static char rcsid[] = "$OpenBSD: primes.c,v 1.13 2004/07/09 15:59:26 deraadt Exp $";
#endif
#endif /* not lint */
@


1.13
log
@ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: primes.c,v 1.12 2003/06/03 03:01:40 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: primes.c,v 1.12 2003/06/03 03:01:40 millert Exp $";
d199 1
a199 2
		if (*(p = buf + strlen(buf) - 1) == '\n')
			*p = '\0';
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: primes.c,v 1.11 2002/05/31 03:40:01 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: primes.c,v 1.11 2002/05/31 03:40:01 pjanzen Exp $";
d113 1
a113 3
main(argc, argv)
	int argc;
	char *argv[];
d188 1
a188 1
read_num_buf()
d219 2
d223 1
a223 3
primes(start, stop)
	ubig start;	/* where to start generating */
	ubig stop;	/* don't generate at or above this value */
d334 1
a334 1
usage()
@


1.11
log
@No dm -> no need to revoke setegid.
@
text
@d1 1
a1 1
/*	$OpenBSD: primes.c,v 1.10 2002/02/16 21:27:11 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: primes.c,v 1.10 2002/02/16 21:27:11 millert Exp $";
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: primes.c,v 1.9 2001/08/19 22:50:57 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: primes.c,v 1.9 2001/08/19 22:50:57 pjanzen Exp $";
a124 4

	/* revoke */
	setegid(getgid());
	setgid(getgid());
@


1.9
log
@-Wall fix, typo fix, and better includes
@
text
@d1 1
a1 1
/*	$OpenBSD: primes.c,v 1.8 2001/08/19 16:30:43 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: primes.c,v 1.8 2001/08/19 16:30:43 pjanzen Exp $";
d112 3
a114 3
void	primes __P((ubig, ubig));
ubig	read_num_buf __P((void));
void	usage __P((void));
@


1.8
log
@remove extraneous newline from error output; accept trailing whitespace
elsewhere.  Similar to PR/2014 for factor(6).
@
text
@d1 1
a1 1
/*	$OpenBSD: primes.c,v 1.7 1999/09/26 05:30:38 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: primes.c,v 1.7 1999/09/26 05:30:38 pjanzen Exp $";
a76 1
#include <memory.h>
d79 1
d240 1
d321 6
a326 7
			q = (char *)(start%factor); /* temp storage for mod */
			if ((long)q & 0x1) {
				q = &table[(factor-(long)q)/2];
			} else {
				q = &table[q ? factor-((long)q/2) : 0];
			}
			/* sive for our current factor */
@


1.7
log
@Correct comment: rogoyski@@cs.utexas.edu, PR 928.
@
text
@d1 1
a1 1
/*	$OpenBSD: primes.c,v 1.6 1999/09/25 15:52:20 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: primes.c,v 1.6 1999/09/25 15:52:20 pjanzen Exp $";
d209 2
d212 1
a212 1
		if (*p == '\n' || *p == '\0')
d220 2
a221 1
		if (*p != '\n')
@


1.6
log
@Tidying and minor changes from or based on jsm28@@cam.ac.uk's work for the
Linux bsd-games package and NetBSD.  Mainly using 'const'.
@
text
@d1 1
a1 1
/*	$OpenBSD: primes.c,v 1.5 1998/08/19 07:40:52 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: primes.c,v 1.5 1998/08/19 07:40:52 pjanzen Exp $";
d96 1
a96 1
 * prime[i] is the (i-1)th prime.
@


1.5
log
@tags, formatting, ANSI-fication, prototypes, de-typos, and the occasional
initialization, removal of unused variable, or other minor fix.  Most
changes are from or inspired by NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 1
a48 1
static char sccsid[] = "@@(#)primes.c	8.4 (Berkeley) 3/21/94";
d50 1
a50 1
static char rcsid[] = "$OpenBSD$";
d101 2
a102 2
extern ubig prime[];
extern ubig *pr_limit;		/* largest prime in the prime array */
d109 2
a110 2
extern char pattern[];
extern int pattern_size;	/* length of pattern array */
d232 5
a236 5
	register char *q;		/* sieve spot */
	register ubig factor;		/* index and factor */
	register char *tab_lim;		/* the limit to sieve on the table */
	register ubig *p;		/* prime table pointer */
	register ubig fact_lim;		/* highest prime for current block */
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: primes.c,v 1.5 1995/04/24 12:24:47 cgd Exp $";
d71 1
d80 1
d271 1
a271 1
				printf("%u\n", factor);
d334 1
a334 1
				printf("%u\n", start);
@


1.3
log
@proper gid revoke
@
text
@d127 1
a127 1
	while ((ch = getopt(argc, argv, "")) != EOF)
@


1.2
log
@setgid games, not setuid games. closes a neat set of holes
@
text
@d123 2
@


1.1
log
@Initial revision
@
text
@d123 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
