head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.6
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.12.0.4
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.9.0.40
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.32
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.36
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.34
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.30
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.28
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.26
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.24
	OPENBSD_5_0:1.9.0.22
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.20
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.18
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.14
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.16
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.12
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.10
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.8
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.10
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.8
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.6
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	initial:1.1.1.1
	hunt:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2017.01.21.08.22.57;	author krw;	state Exp;
branches;
next	1.13;
commitid	slqvWeiHNc6j5Mv6;

1.13
date	2016.08.27.02.06.40;	author guenther;	state Exp;
branches;
next	1.12;
commitid	HajZYsKX8810aMqL;

1.12
date	2016.01.07.21.37.53;	author mestre;	state Exp;
branches;
next	1.11;
commitid	OXn0Z5fMODgNmJpo;

1.11
date	2016.01.07.21.29.31;	author mestre;	state Exp;
branches;
next	1.10;
commitid	AgYVDd64zIiNi3fx;

1.10
date	2015.08.22.14.47.41;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	vWCbqNWL9DL2UkGT;

1.9
date	2006.03.27.00.10.15;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.16.00.13.19;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.11.08.45.33;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.10;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.19.15.19.45;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	99.02.01.06.53.56;	author d;	state Exp;
branches;
next	1.3;

1.3
date	99.01.29.07.30.36;	author d;	state Exp;
branches;
next	1.2;

1.2
date	99.01.21.05.47.42;	author d;	state Exp;
branches;
next	1.1;

1.1
date	99.01.21.05.33.38;	author d;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.01.21.05.33.38;	author d;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@/*	$OpenBSD: shots.c,v 1.13 2016/08/27 02:06:40 guenther Exp $	*/
/*	$NetBSD: shots.c,v 1.3 1997/10/11 08:13:50 lukem Exp $	*/
/*
 * Copyright (c) 1983-2003, Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * + Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * + Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 * + Neither the name of the University of California, San Francisco nor
 *   the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written
 *   permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/select.h>
#include <stdlib.h>
#include <syslog.h>

#include "conf.h"
#include "hunt.h"
#include "server.h"

#define	PLUS_DELTA(x, max)	if (x < max) x++; else x--
#define	MINUS_DELTA(x, min)	if (x > min) x--; else x++

static	void	chkshot(BULLET *, BULLET *);
static	void	chkslime(BULLET *, BULLET *);
static	void	explshot(BULLET *, int, int);
static	void	find_under(BULLET *, BULLET *);
static	int	iswall(int, int);
static	void	mark_boot(BULLET *);
static	void	mark_player(BULLET *);
static	int	move_drone(BULLET *);
static	void	move_flyer(PLAYER *);
static	int	move_normal_shot(BULLET *);
static	void	move_slime(BULLET *, int, BULLET *);
static	void	save_bullet(BULLET *);
static	void	zapshot(BULLET *, BULLET *);

/* Return true if there is pending activity */
int
can_moveshots(void)
{
	PLAYER *pp;

	/* Bullets are moving? */
	if (Bullets)
		return 1;

	/* Explosions are happening? */
	if (can_rollexpl())
		return 1;

	/* Things are flying? */
	for (pp = Boot; pp < &Boot[NBOOTS]; pp++)
		if (pp->p_flying >= 0)
			return 1;
	for (pp = Player; pp < End_player; pp++)
		if (pp->p_flying >= 0)
			return 1;

	/* Everything is quiet: */
	return 0;
}

/*
 * moveshots:
 *	Move the shots already in the air, taking explosions into account
 */
void
moveshots(void)
{
	BULLET	*bp, *next;
	PLAYER	*pp;
	int	x, y;
	BULLET	*blist;

	rollexpl();
	if (Bullets == NULL)
		goto no_bullets;

	/*
	 * First we move through the bullet list conf_bulspd times, looking
	 * for things we may have run into.  If we do run into
	 * something, we set up the explosion and disappear, checking
	 * for damage to any player who got in the way.
	 */

	/* Move the list to a working list */
	blist = Bullets;
	Bullets = NULL;

	/* Work with bullets on the working list (blist) */
	for (bp = blist; bp != NULL; bp = next) {
		next = bp->b_next;

		x = bp->b_x;
		y = bp->b_y;

		/* Un-draw the bullet on all screens: */
		Maze[y][x] = bp->b_over;
		check(ALL_PLAYERS, y, x);

		/* Decide how to move the bullet: */
		switch (bp->b_type) {

		  /* Normal, atomic bullets: */
		  case SHOT:
		  case GRENADE:
		  case SATCHEL:
		  case BOMB:
			if (move_normal_shot(bp)) {
				/* Still there: put back on the active list */
				bp->b_next = Bullets;
				Bullets = bp;
			}
			break;

		  /* Slime bullets that explode into slime on impact: */
		  case SLIME:
			if (bp->b_expl || move_normal_shot(bp)) {
				/* Still there: put back on the active list */
				bp->b_next = Bullets;
				Bullets = bp;
			}
			break;

		  /* Drones that wander about: */
		  case DSHOT:
			if (move_drone(bp)) {
				/* Still there: put back on the active list */
				bp->b_next = Bullets;
				Bullets = bp;
			}
			break;

		  /* Other/unknown: */
		  default:
			/* Place it back on the active list: */
			bp->b_next = Bullets;
			Bullets = bp;
			break;
		}
	}

	/* Again, hang the Bullets list off `blist' and work with that: */
	blist = Bullets;
	Bullets = NULL;
	for (bp = blist; bp != NULL; bp = next) {
		next = bp->b_next;
		/* Is the bullet exploding? */
		if (!bp->b_expl) {
			/*
			 * Its still flying through the air.
			 * Put it back on the bullet list.
			 */
			save_bullet(bp);

			/* All the monitors can see the bullet: */
			for (pp = Monitor; pp < End_monitor; pp++)
				check(pp, bp->b_y, bp->b_x);

			/* All the scanning players can see the drone: */
			if (bp->b_type == DSHOT)
				for (pp = Player; pp < End_player; pp++)
					if (pp->p_scan >= 0)
						check(pp, bp->b_y, bp->b_x);
		} else {
			/* It is exploding. Check what we hit: */
			chkshot(bp, next);
			/* Release storage for the destroyed bullet: */
			free(bp);
		}
	}

	/* Re-draw all the players: (in case a bullet wiped them out) */
	for (pp = Player; pp < End_player; pp++)
		Maze[pp->p_y][pp->p_x] = pp->p_face;

no_bullets:

	/* Move flying boots through the air: */
	for (pp = Boot; pp < &Boot[NBOOTS]; pp++)
		if (pp->p_flying >= 0)
			move_flyer(pp);

	/* Move flying players through the air: */
	for (pp = Player; pp < End_player; pp++) {
		if (pp->p_flying >= 0)
			move_flyer(pp);
		/* Flush out the explosions: */
		sendcom(pp, REFRESH);
		look(pp);
	}

	/* Flush out and synchronise all the displays: */
	sendcom(ALL_PLAYERS, REFRESH);
}

/*
 * move_normal_shot:
 *	Move a normal shot along its trajectory.
 *	Returns false if the bullet no longer needs tracking.
 */
static int
move_normal_shot(BULLET  *bp)
{
	int	i, x, y;
	PLAYER	*pp;

	/*
	 * Walk an unexploded bullet along conf_bulspd times, moving it
	 * one unit along each step. We flag it as exploding if it
	 * meets something.
	 */

	for (i = 0; i < conf_bulspd; i++) {

		/* Stop if the bullet has already exploded: */
		if (bp->b_expl)
			break;

		/* Adjust the bullet's co-ordinates: */
		x = bp->b_x;
		y = bp->b_y;
		switch (bp->b_face) {
		  case LEFTS:
			x--;
			break;
		  case RIGHT:
			x++;
			break;
		  case ABOVE:
			y--;
			break;
		  case BELOW:
			y++;
			break;
		}


		/* Look at what the bullet is colliding with : */
		switch (Maze[y][x]) {
		  /* Gun shots have a chance of collision: */
		  case SHOT:
			if (rand_num(100) < conf_pshot_coll) {
				zapshot(Bullets, bp);
				zapshot(bp->b_next, bp);
			}
			break;
		  /* Grenades only have a chance of collision: */
		  case GRENADE:
			if (rand_num(100) < conf_pgren_coll) {
				zapshot(Bullets, bp);
				zapshot(bp->b_next, bp);
			}
			break;
		  /* Reflecting walls richochet the bullet: */
		  case WALL4:
			switch (bp->b_face) {
			  case LEFTS:
				bp->b_face = BELOW;
				break;
			  case RIGHT:
				bp->b_face = ABOVE;
				break;
			  case ABOVE:
				bp->b_face = RIGHT;
				break;
			  case BELOW:
				bp->b_face = LEFTS;
				break;
			}
			Maze[y][x] = WALL5;
			for (pp = Monitor; pp < End_monitor; pp++)
				check(pp, y, x);
			break;
		  case WALL5:
			switch (bp->b_face) {
			  case LEFTS:
				bp->b_face = ABOVE;
				break;
			  case RIGHT:
				bp->b_face = BELOW;
				break;
			  case ABOVE:
				bp->b_face = LEFTS;
				break;
			  case BELOW:
				bp->b_face = RIGHT;
				break;
			}
			Maze[y][x] = WALL4;
			for (pp = Monitor; pp < End_monitor; pp++)
				check(pp, y, x);
			break;
		  /* Dispersion doors randomly disperse bullets: */
		  case DOOR:
			switch (rand_num(4)) {
			  case 0:
				bp->b_face = ABOVE;
				break;
			  case 1:
				bp->b_face = BELOW;
				break;
			  case 2:
				bp->b_face = LEFTS;
				break;
			  case 3:
				bp->b_face = RIGHT;
				break;
			}
			break;
		  /* Bullets zing past fliers: */
		  case FLYER:
			pp = play_at(y, x);
			message(pp, "Zing!");
			break;
		  /* Bullets encountering a player: */
		  case LEFTS:
		  case RIGHT:
		  case BELOW:
		  case ABOVE:
			/*
			 * Give the person a chance to catch a
			 * grenade if s/he is facing it:
			 */
			pp = play_at(y, x);
			pp->p_ident->i_shot += bp->b_charge;
			if (opposite(bp->b_face, Maze[y][x])) {
			    /* Give them a 10% chance: */
			    if (rand_num(100) < conf_pgren_catch) {
				/* They caught it! */
				if (bp->b_owner != NULL)
					message(bp->b_owner,
					    "Your charge was absorbed!");

				/*
				 * The target player stole from the bullet's
				 * owner. Charge stolen statistics:
				 */
				if (bp->b_score != NULL)
					bp->b_score->i_robbed += bp->b_charge;

				/* They acquire more ammo: */
				pp->p_ammo += bp->b_charge;

				/* Check if it would have destroyed them: */
				if (pp->p_damage + bp->b_size * conf_mindam
				    > pp->p_damcap)
					/* Lucky escape statistics: */
					pp->p_ident->i_saved++;

				/* Tell them: */
				message(pp, "Absorbed charge (good shield!)");

				/* Absorbtion statistics: */
				pp->p_ident->i_absorbed += bp->b_charge;

				/* Deallocate storage: */
				free(bp);

				/* Update ammo display: */
				ammo_update(pp);

				/* No need for caller to keep tracking it: */
				return FALSE;
			    }

			    /* Bullets faced head-on (statistics): */
			    pp->p_ident->i_faced += bp->b_charge;
			}

			/*
			 * Small chance that the bullet just misses the
			 * person.  If so, the bullet just goes on its
			 * merry way without exploding. (5% chance)
			 */
			if (rand_num(100) < conf_pmiss) {
				/* Ducked statistics: */
				pp->p_ident->i_ducked += bp->b_charge;

				/* Check if it would have killed them: */
				if (pp->p_damage + bp->b_size * conf_mindam
				    > pp->p_damcap)
					/* Lucky escape statistics: */
					pp->p_ident->i_saved++;

				/* Shooter missed statistics: */
				if (bp->b_score != NULL)
					bp->b_score->i_missed += bp->b_charge;

				/* Tell target that they were missed: */
				message(pp, "Zing!");

				/* Tell the bullet owner they missed: */
				if (bp->b_owner != NULL)
				    message(bp->b_owner,
					((bp->b_score->i_missed & 0x7) == 0x7) ?
					"My!  What a bad shot you are!" :
					"Missed him");

				/* Don't fall through */
				break;
			} else {
				/* The player is to be blown up: */
				bp->b_expl = TRUE;
			}
			break;
		  /* Bullet hits a wall, and always explodes: */
		  case WALL1:
		  case WALL2:
		  case WALL3:
			bp->b_expl = TRUE;
			break;
		}

		/* Update the bullet's new position: */
		bp->b_x = x;
		bp->b_y = y;
	}

	/* Caller should keep tracking the bullet: */
	return TRUE;
}

/*
 * move_drone:
 *	Move the drone to the next square
 *	Returns FALSE if the drone need no longer be tracked.
 */
static int
move_drone(BULLET *bp)
{
	int	mask, count;
	int	n, dir = -1;
	PLAYER	*pp;

	/* See if we can give someone a blast: */
	if (is_player(Maze[bp->b_y][bp->b_x - 1])) {
		dir = WEST;
		goto drone_move;
	}
	if (is_player(Maze[bp->b_y - 1][bp->b_x])) {
		dir = NORTH;
		goto drone_move;
	}
	if (is_player(Maze[bp->b_y + 1][bp->b_x])) {
		dir = SOUTH;
		goto drone_move;
	}
	if (is_player(Maze[bp->b_y][bp->b_x + 1])) {
		dir = EAST;
		goto drone_move;
	}

	/* Find out what directions are clear and move that way: */
	mask = count = 0;
	if (!iswall(bp->b_y, bp->b_x - 1))
		mask |= WEST, count++;
	if (!iswall(bp->b_y - 1, bp->b_x))
		mask |= NORTH, count++;
	if (!iswall(bp->b_y + 1, bp->b_x))
		mask |= SOUTH, count++;
	if (!iswall(bp->b_y, bp->b_x + 1))
		mask |= EAST, count++;

	/* All blocked up, just wait: */
	if (count == 0)
		return TRUE;

	/* Only one way to go: */
	if (count == 1) {
		dir = mask;
		goto drone_move;
	}

	/* Avoid backtracking, and remove the direction we came from: */
	switch (bp->b_face) {
	  case LEFTS:
		if (mask & EAST)
			mask &= ~EAST, count--;
		break;
	  case RIGHT:
		if (mask & WEST)
			mask &= ~WEST, count--;
		break;
	  case ABOVE:
		if (mask & SOUTH)
			mask &= ~SOUTH, count--;
		break;
	  case BELOW:
		if (mask & NORTH)
			mask &= ~NORTH, count--;
		break;
	}

	/* Pick one of the remaining directions: */
	n = rand_num(count);
	if (n >= 0 && mask & NORTH)
		dir = NORTH, n--;
	if (n >= 0 && mask & SOUTH)
		dir = SOUTH, n--;
	if (n >= 0 && mask & EAST)
		dir = EAST, n--;
	if (n >= 0 && mask & WEST)
		dir = WEST, n--;

drone_move:
	/* Move the drone: */
	switch (dir) {
	  case -1:
		/* no move */
	  case WEST:
		bp->b_x--;
		bp->b_face = LEFTS;
		break;
	  case EAST:
		bp->b_x++;
		bp->b_face = RIGHT;
		break;
	  case NORTH:
		bp->b_y--;
		bp->b_face = ABOVE;
		break;
	  case SOUTH:
		bp->b_y++;
		bp->b_face = BELOW;
		break;
	}

	/* Look at what the drone moved onto: */
	switch (Maze[bp->b_y][bp->b_x]) {
	  case LEFTS:
	  case RIGHT:
	  case BELOW:
	  case ABOVE:
		/*
		 * Players have a 1% chance of absorbing a drone,
		 * if they are facing it.
		 */
		if (rand_num(100) < conf_pdroneabsorb && opposite(bp->b_face,
		    Maze[bp->b_y][bp->b_x])) {

			/* Feel the power: */
			pp = play_at(bp->b_y, bp->b_x);
			pp->p_ammo += bp->b_charge;
			message(pp, "**** Absorbed drone ****");

			/* Release drone storage: */
			free(bp);

			/* Update ammo: */
			ammo_update(pp);

			/* No need for caller to keep tracking drone: */
			return FALSE;
		}
		/* Detonate the drone: */
		bp->b_expl = TRUE;
		break;
	}

	/* Keep tracking the drone. */
	return TRUE;
}

/*
 * save_bullet:
 *	Put a bullet back onto the bullet list
 */
static void
save_bullet(BULLET *bp)
{

	/* Save what the bullet will be flying over: */
	bp->b_over = Maze[bp->b_y][bp->b_x];

	switch (bp->b_over) {
	  /* Bullets that can pass through each other: */
	  case SHOT:
	  case GRENADE:
	  case SATCHEL:
	  case BOMB:
	  case SLIME:
	  case LAVA:
	  case DSHOT:
		find_under(Bullets, bp);
		break;
	}

	switch (bp->b_over) {
	  /* A bullet hits a player: */
	  case LEFTS:
	  case RIGHT:
	  case ABOVE:
	  case BELOW:
	  case FLYER:
		mark_player(bp);
		break;

	  /* A bullet passes a boot: */
	  case BOOT:
	  case BOOT_PAIR:
		mark_boot(bp);
		/* FALLTHROUGH */

	  /* The bullet flies over everything else: */
	  default:
		Maze[bp->b_y][bp->b_x] = bp->b_type;
		break;
	}

	/* Insert the bullet into the Bullets list: */
	bp->b_next = Bullets;
	Bullets = bp;
}

/*
 * move_flyer:
 *	Update the position of a player in flight
 */
static void
move_flyer(PLAYER *pp)
{
	int	x, y;

	if (pp->p_undershot) {
		fixshots(pp->p_y, pp->p_x, pp->p_over);
		pp->p_undershot = FALSE;
	}

	/* Restore what the flier was flying over */
	Maze[pp->p_y][pp->p_x] = pp->p_over;

	/* Fly: */
	x = pp->p_x + pp->p_flyx;
	y = pp->p_y + pp->p_flyy;

	/* Bouncing off the edges of the maze: */
	if (x < 1) {
		x = 1 - x;
		pp->p_flyx = -pp->p_flyx;
	}
	else if (x > WIDTH - 2) {
		x = (WIDTH - 2) - (x - (WIDTH - 2));
		pp->p_flyx = -pp->p_flyx;
	}
	if (y < 1) {
		y = 1 - y;
		pp->p_flyy = -pp->p_flyy;
	}
	else if (y > HEIGHT - 2) {
		y = (HEIGHT - 2) - (y - (HEIGHT - 2));
		pp->p_flyy = -pp->p_flyy;
	}

	/* Make sure we don't land on something we can't: */
again:
	switch (Maze[y][x]) {
	  default:
		/*
		 * Flier is over something other than space, a wall
		 * or a door. Randomly move (drift) the flier a little bit
		 * and then try again:
		 */
		switch (rand_num(4)) {
		  case 0:
			PLUS_DELTA(x, WIDTH - 2);
			break;
		  case 1:
			MINUS_DELTA(x, 1);
			break;
		  case 2:
			PLUS_DELTA(y, HEIGHT - 2);
			break;
		  case 3:
			MINUS_DELTA(y, 1);
			break;
		}
		goto again;
	  /* Give a little boost when about to land on a wall or door: */
	  case WALL1:
	  case WALL2:
	  case WALL3:
	  case WALL4:
	  case WALL5:
	  case DOOR:
		if (pp->p_flying == 0)
			pp->p_flying++;
		break;
	  /* Spaces are okay: */
	  case SPACE:
		break;
	}

	/* Update flier's coordinates: */
	pp->p_y = y;
	pp->p_x = x;

	/* Consume 'flying' time: */
	if (pp->p_flying-- == 0) {
		/* Land: */
		if (pp->p_face != BOOT && pp->p_face != BOOT_PAIR) {
			/* Land a player - they stustain a fall: */
			checkdam(pp, (PLAYER *) NULL, (IDENT *) NULL,
				rand_num(pp->p_damage / conf_fall_frac), FALL);
			pp->p_face = rand_dir();
			showstat(pp);
		} else {
			/* Land boots: */
			if (Maze[y][x] == BOOT)
				pp->p_face = BOOT_PAIR;
			Maze[y][x] = SPACE;
		}
	}

	/* Save under the flier: */
	pp->p_over = Maze[y][x];
	/* Draw in the flier: */
	Maze[y][x] = pp->p_face;
	showexpl(y, x, pp->p_face);
}

/*
 * chkshot
 *	Handle explosions
 */
static void
chkshot(BULLET *bp, BULLET *next)
{
	int	y, x;
	int	dy, dx, absdy;
	int	delta, damage;
	char	expl;
	PLAYER	*pp;

	delta = 0;
	switch (bp->b_type) {
	  case SHOT:
	  case MINE:
	  case GRENADE:
	  case GMINE:
	  case SATCHEL:
	  case BOMB:
		delta = bp->b_size - 1;
		break;
	  case SLIME:
	  case LAVA:
		chkslime(bp, next);
		return;
	  case DSHOT:
		bp->b_type = SLIME;
		chkslime(bp, next);
		return;
	}

	/* Draw the explosion square: */
	for (y = bp->b_y - delta; y <= bp->b_y + delta; y++) {
		if (y < 0 || y >= HEIGHT)
			continue;
		dy = y - bp->b_y;
		absdy = (dy < 0) ? -dy : dy;
		for (x = bp->b_x - delta; x <= bp->b_x + delta; x++) {
			/* Draw a part of the explosion cloud: */
			if (x < 0 || x >= WIDTH)
				continue;
			dx = x - bp->b_x;
			if (dx == 0)
				expl = (dy == 0) ? '*' : '|';
			else if (dy == 0)
				expl = '-';
			else if (dx == dy)
				expl = '\\';
			else if (dx == -dy)
				expl = '/';
			else
				expl = '*';
			showexpl(y, x, expl);

			/* Check what poor bastard was in the explosion: */
			switch (Maze[y][x]) {
			  case LEFTS:
			  case RIGHT:
			  case ABOVE:
			  case BELOW:
			  case FLYER:
				if (dx < 0)
					dx = -dx;
				if (absdy > dx)
					damage = bp->b_size - absdy;
				else
					damage = bp->b_size - dx;

				/* Everybody hurts, sometimes. */
				pp = play_at(y, x);
				checkdam(pp, bp->b_owner, bp->b_score,
					damage * conf_mindam, bp->b_type);
				break;
			  case GMINE:
			  case MINE:
				/* Mines detonate in a chain reaction: */
				add_shot((Maze[y][x] == GMINE) ?
					GRENADE : SHOT,
					y, x, LEFTS,
					(Maze[y][x] == GMINE) ?
					GRENREQ : BULREQ,
					(PLAYER *) NULL, TRUE, SPACE);
				Maze[y][x] = SPACE;
				break;
			}
		}
	}
}

/*
 * chkslime:
 *	handle slime shot exploding
 */
static void
chkslime(BULLET *bp, BULLET *next)
{
	BULLET	*nbp;

	switch (Maze[bp->b_y][bp->b_x]) {
	  /* Slime explodes on walls and doors: */
	  case WALL1:
	  case WALL2:
	  case WALL3:
	  case WALL4:
	  case WALL5:
	  case DOOR:
		switch (bp->b_face) {
		  case LEFTS:
			bp->b_x++;
			break;
		  case RIGHT:
			bp->b_x--;
			break;
		  case ABOVE:
			bp->b_y++;
			break;
		  case BELOW:
			bp->b_y--;
			break;
		}
		break;
	}

	/* Duplicate the unit of slime: */
	nbp = malloc(sizeof (BULLET));
	if (nbp == NULL) {
		logit(LOG_ERR, "malloc");
		return;
	}
	*nbp = *bp;

	/* Move it around: */
	move_slime(nbp, nbp->b_type == SLIME ? conf_slimespeed :
	    conf_lavaspeed, next);
}

/*
 * move_slime:
 *	move the given slime shot speed times and add it back if
 *	it hasn't fizzled yet
 */
static void
move_slime(BULLET *bp, int speed, BULLET *next)
{
	int	i, j, dirmask, count;
	PLAYER	*pp;
	BULLET	*nbp;

	if (speed == 0) {
		if (bp->b_charge <= 0)
			free(bp);
		else
			save_bullet(bp);
		return;
	}

	/* Draw it: */
	showexpl(bp->b_y, bp->b_x, bp->b_type == LAVA ? LAVA : '*');

	switch (Maze[bp->b_y][bp->b_x]) {
	  /* Someone got hit by slime or lava: */
	  case LEFTS:
	  case RIGHT:
	  case ABOVE:
	  case BELOW:
	  case FLYER:
		pp = play_at(bp->b_y, bp->b_x);
		message(pp, "You've been slimed.");
		checkdam(pp, bp->b_owner, bp->b_score, conf_mindam, bp->b_type);
		break;
	  /* Bullets detonate in slime and lava: */
	  case SHOT:
	  case GRENADE:
	  case SATCHEL:
	  case BOMB:
	  case DSHOT:
		explshot(next, bp->b_y, bp->b_x);
		explshot(Bullets, bp->b_y, bp->b_x);
		break;
	}


	/* Drain the slime/lava of some energy: */
	if (--bp->b_charge <= 0) {
		/* It fizzled: */
		free(bp);
		return;
	}

	/* Figure out which way the slime should flow: */
	dirmask = 0;
	count = 0;
	switch (bp->b_face) {
	  case LEFTS:
		if (!iswall(bp->b_y, bp->b_x - 1))
			dirmask |= WEST, count++;
		if (!iswall(bp->b_y - 1, bp->b_x))
			dirmask |= NORTH, count++;
		if (!iswall(bp->b_y + 1, bp->b_x))
			dirmask |= SOUTH, count++;
		if (dirmask == 0)
			if (!iswall(bp->b_y, bp->b_x + 1))
				dirmask |= EAST, count++;
		break;
	  case RIGHT:
		if (!iswall(bp->b_y, bp->b_x + 1))
			dirmask |= EAST, count++;
		if (!iswall(bp->b_y - 1, bp->b_x))
			dirmask |= NORTH, count++;
		if (!iswall(bp->b_y + 1, bp->b_x))
			dirmask |= SOUTH, count++;
		if (dirmask == 0)
			if (!iswall(bp->b_y, bp->b_x - 1))
				dirmask |= WEST, count++;
		break;
	  case ABOVE:
		if (!iswall(bp->b_y - 1, bp->b_x))
			dirmask |= NORTH, count++;
		if (!iswall(bp->b_y, bp->b_x - 1))
			dirmask |= WEST, count++;
		if (!iswall(bp->b_y, bp->b_x + 1))
			dirmask |= EAST, count++;
		if (dirmask == 0)
			if (!iswall(bp->b_y + 1, bp->b_x))
				dirmask |= SOUTH, count++;
		break;
	  case BELOW:
		if (!iswall(bp->b_y + 1, bp->b_x))
			dirmask |= SOUTH, count++;
		if (!iswall(bp->b_y, bp->b_x - 1))
			dirmask |= WEST, count++;
		if (!iswall(bp->b_y, bp->b_x + 1))
			dirmask |= EAST, count++;
		if (dirmask == 0)
			if (!iswall(bp->b_y - 1, bp->b_x))
				dirmask |= NORTH, count++;
		break;
	}
	if (count == 0) {
		/*
		 * No place to go.  Just sit here for a while and wait
		 * for adjacent squares to clear out.
		 */
		save_bullet(bp);
		return;
	}
	if (bp->b_charge < count) {
		/* Only bp->b_charge paths may be taken */
		while (count > bp->b_charge) {
			if (dirmask & WEST)
				dirmask &= ~WEST;
			else if (dirmask & EAST)
				dirmask &= ~EAST;
			else if (dirmask & NORTH)
				dirmask &= ~NORTH;
			else if (dirmask & SOUTH)
				dirmask &= ~SOUTH;
			count--;
		}
	}

	/* Spawn little slimes off in every possible direction: */
	i = bp->b_charge / count;
	j = bp->b_charge % count;
	if (dirmask & WEST) {
		count--;
		nbp = create_shot(bp->b_type, bp->b_y, bp->b_x - 1, LEFTS,
			i, bp->b_size, bp->b_owner, bp->b_score, TRUE, SPACE);
		move_slime(nbp, speed - 1, next);
	}
	if (dirmask & EAST) {
		count--;
		nbp = create_shot(bp->b_type, bp->b_y, bp->b_x + 1, RIGHT,
			(count < j) ? i + 1 : i, bp->b_size, bp->b_owner,
			bp->b_score, TRUE, SPACE);
		move_slime(nbp, speed - 1, next);
	}
	if (dirmask & NORTH) {
		count--;
		nbp = create_shot(bp->b_type, bp->b_y - 1, bp->b_x, ABOVE,
			(count < j) ? i + 1 : i, bp->b_size, bp->b_owner,
			bp->b_score, TRUE, SPACE);
		move_slime(nbp, speed - 1, next);
	}
	if (dirmask & SOUTH) {
		count--;
		nbp = create_shot(bp->b_type, bp->b_y + 1, bp->b_x, BELOW,
			(count < j) ? i + 1 : i, bp->b_size, bp->b_owner,
			bp->b_score, TRUE, SPACE);
		move_slime(nbp, speed - 1, next);
	}

	free(bp);
}

/*
 * iswall:
 *	returns whether the given location is a wall
 */
static int
iswall(int y, int x)
{
	if (y < 0 || x < 0 || y >= HEIGHT || x >= WIDTH)
		return TRUE;
	switch (Maze[y][x]) {
	  case WALL1:
	  case WALL2:
	  case WALL3:
	  case WALL4:
	  case WALL5:
	  case DOOR:
	  case SLIME:
	  case LAVA:
		return TRUE;
	}
	return FALSE;
}

/*
 * zapshot:
 *	Take a shot out of the air.
 */
static void
zapshot(BULLET *blist, BULLET *obp)
{
	BULLET	*bp;

	for (bp = blist; bp != NULL; bp = bp->b_next) {
		/* Find co-located bullets not facing the same way: */
		if (bp->b_face != obp->b_face
		    && bp->b_x == obp->b_x && bp->b_y == obp->b_y)
		{
			/* Bullet collision: */
			explshot(blist, obp->b_y, obp->b_x);
			return;
		}
	}
}

/*
 * explshot -
 *	Make all shots at this location blow up
 */
static void
explshot(BULLET *blist, int y, int x)
{
	BULLET	*bp;

	for (bp = blist; bp != NULL; bp = bp->b_next)
		if (bp->b_x == x && bp->b_y == y) {
			bp->b_expl = TRUE;
			if (bp->b_owner != NULL)
				message(bp->b_owner, "Shot intercepted.");
		}
}

/*
 * play_at:
 *	Return a pointer to the player at the given location
 */
PLAYER *
play_at(int y, int x)
{
	PLAYER	*pp;

	for (pp = Player; pp < End_player; pp++)
		if (pp->p_x == x && pp->p_y == y)
			return pp;

	/* Internal fault: */
	logx(LOG_ERR, "play_at: not a player");
	abort();
}

/*
 * opposite:
 *	Return TRUE if the bullet direction faces the opposite direction
 *	of the player in the maze
 */
int
opposite(int face, char dir)
{
	switch (face) {
	  case LEFTS:
		return (dir == RIGHT);
	  case RIGHT:
		return (dir == LEFTS);
	  case ABOVE:
		return (dir == BELOW);
	  case BELOW:
		return (dir == ABOVE);
	  default:
		return FALSE;
	}
}

/*
 * is_bullet:
 *	Is there a bullet at the given coordinates?  If so, return
 *	a pointer to the bullet, otherwise return NULL
 */
BULLET *
is_bullet(int y, int x)
{
	BULLET	*bp;

	for (bp = Bullets; bp != NULL; bp = bp->b_next)
		if (bp->b_y == y && bp->b_x == x)
			return bp;
	return NULL;
}

/*
 * fixshots:
 *	change the underlying character of the shots at a location
 *	to the given character.
 */
void
fixshots(int y, int x, char over)
{
	BULLET	*bp;

	for (bp = Bullets; bp != NULL; bp = bp->b_next)
		if (bp->b_y == y && bp->b_x == x)
			bp->b_over = over;
}

/*
 * find_under:
 *	find the underlying character for a bullet when it lands
 *	on another bullet.
 */
static void
find_under(BULLET *blist, BULLET *bp)
{
	BULLET	*nbp;

	for (nbp = blist; nbp != NULL; nbp = nbp->b_next)
		if (bp->b_y == nbp->b_y && bp->b_x == nbp->b_x) {
			bp->b_over = nbp->b_over;
			break;
		}
}

/*
 * mark_player:
 *	mark a player as under a shot
 */
static void
mark_player(BULLET *bp)
{
	PLAYER	*pp;

	for (pp = Player; pp < End_player; pp++)
		if (pp->p_y == bp->b_y && pp->p_x == bp->b_x) {
			pp->p_undershot = TRUE;
			break;
		}
}

/*
 * mark_boot:
 *	mark a boot as under a shot
 */
static void
mark_boot(BULLET *bp)
{
	PLAYER	*pp;

	for (pp = Boot; pp < &Boot[NBOOTS]; pp++)
		if (pp->p_y == bp->b_y && pp->p_x == bp->b_x) {
			pp->p_undershot = TRUE;
			break;
		}
}
@


1.13
log
@Pull in <sys/select.h> for fd_set

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: shots.c,v 1.12 2016/01/07 21:37:53 mestre Exp $	*/
d6 3
a8 3
 * 
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are 
d10 2
a11 2
 * 
 * + Redistributions of source code must retain the above copyright 
d13 2
a14 2
 * + Redistributions in binary form must reproduce the above copyright 
 *   notice, this list of conditions and the following disclaimer in the 
d16 3
a18 3
 * + Neither the name of the University of California, San Francisco nor 
 *   the names of its contributors may be used to endorse or promote 
 *   products derived from this software without specific prior written 
d20 11
a30 11
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS 
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED 
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
d561 1
a561 1
		if (rand_num(100) < conf_pdroneabsorb && opposite(bp->b_face, 
d626 1
a626 1
		
d682 1
a682 1
		 * Flier is over something other than space, a wall 
d878 1
a878 1
	move_slime(nbp, nbp->b_type == SLIME ? conf_slimespeed : 
@


1.12
log
@ANSIfy hunt(6)

Note: casted 2 args to struct sockaddr * on list.c to shut off compiler
warnings, and also changed an int len to socklen_t since recvfrom(2) receives
the last argument as the latter.

I'm running out of credits, but this was once again with great help and OK from
tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: shots.c,v 1.11 2016/01/07 21:29:31 mestre Exp $	*/
d34 1
@


1.11
log
@Headers cleanup and sorting

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: shots.c,v 1.10 2015/08/22 14:47:41 deraadt Exp $	*/
d60 1
a60 1
can_moveshots()
d89 1
a89 1
moveshots()
d224 1
a224 2
move_normal_shot(bp)
	BULLET	*bp;
d451 1
a451 2
move_drone(bp)
	BULLET	*bp;
d591 1
a591 2
save_bullet(bp)
	BULLET	*bp;
d642 1
a642 2
move_flyer(pp)
	PLAYER	*pp;
d748 1
a748 3
chkshot(bp, next)
	BULLET	*bp;
	BULLET	*next;
d839 1
a839 3
chkslime(bp, next)
	BULLET	*bp;
	BULLET	*next;
d887 1
a887 4
move_slime(bp, speed, next)
	BULLET	*bp;
	int	speed;
	BULLET	*next;
d1045 1
a1045 2
iswall(y, x)
	int	y, x;
d1068 1
a1068 2
zapshot(blist, obp)
	BULLET	*blist, *obp;
d1089 1
a1089 3
explshot(blist, y, x)
	BULLET	*blist;
	int	y, x;
d1106 1
a1106 2
play_at(y, x)
	int	y, x;
d1125 1
a1125 3
opposite(face, dir)
	int	face;
	char	dir;
d1147 1
a1147 2
is_bullet(y, x)
	int	y, x;
d1163 1
a1163 3
fixshots(y, x, over)
	int	y, x;
	char	over;
d1178 1
a1178 2
find_under(blist, bp)
	BULLET	*blist, *bp;
d1194 1
a1194 2
mark_player(bp)
	BULLET	*bp;
d1210 1
a1210 2
mark_boot(bp)
	BULLET	*bp;
@


1.10
log
@remove malloc/calloc/realloc* casts, due to stdlib.h being present; ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: shots.c,v 1.9 2006/03/27 00:10:15 tedu Exp $	*/
a33 2
#include <err.h>
#include <signal.h>
d36 2
a38 1
#include "conf.h"
@


1.9
log
@assorted fixes mostly from coverity via netbsd via jasper adriaanse via tech
@
text
@d1 1
a1 1
/*	$OpenBSD: shots.c,v 1.8 2004/01/16 00:13:19 espie Exp $	*/
d878 1
a878 1
	nbp = (BULLET *) malloc(sizeof (BULLET));
@


1.8
log
@ISO C police: log and expl are reserved for the C library.
expl -> expl_string
log -> logit
@
text
@d1 1
a1 1
/*	$OpenBSD: shots.c,v 1.7 2003/06/11 08:45:33 pjanzen Exp $	*/
d381 1
a381 1
				free((char *) bp);
d572 1
a572 1
			free((char *) bp);
d907 1
a907 1
			free((char *) bp);
d1049 1
a1049 1
	free((char *) bp);
@


1.7
log
@New license from the official hunt release at
ftp://ftp.cgl.ucsf.edu/pub/hunt.shar.Z -- it has been approved by all three
authors (Conrad Huang, Ken Arnold, and Greg Couch).
@
text
@d1 1
a1 1
/*	$OpenBSD: shots.c,v 1.6 2002/02/16 21:27:10 millert Exp $	*/
d880 1
a880 1
		log(LOG_ERR, "malloc");
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: shots.c,v 1.5 2001/09/19 15:19:45 pjanzen Exp $	*/
d4 28
a31 3
 *  Hunt
 *  Copyright (c) 1985 Conrad C. Huang, Gregory S. Couch, Kenneth C.R.C. Arnold
 *  San Francisco, California
@


1.5
log
@isplayer -> is_player gets out of <ctype.h> namespace; jsm28@@cam.ac.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: shots.c,v 1.4 1999/02/01 06:53:56 d Exp $	*/
d20 13
a32 13
static	void	chkshot __P((BULLET *, BULLET *));
static	void	chkslime __P((BULLET *, BULLET *));
static	void	explshot __P((BULLET *, int, int));
static	void	find_under __P((BULLET *, BULLET *));
static	int	iswall __P((int, int));
static	void	mark_boot __P((BULLET *));
static	void	mark_player __P((BULLET *));
static	int	move_drone __P((BULLET *));
static	void	move_flyer __P((PLAYER *));
static	int	move_normal_shot __P((BULLET *));
static	void	move_slime __P((BULLET *, int, BULLET *));
static	void	save_bullet __P((BULLET *));
static	void	zapshot __P((BULLET *, BULLET *));
@


1.4
log
@avoid denial of service attacks on server port; extra conf vars; fix otto
@
text
@d1 1
a1 1
/*	$OpenBSD: shots.c,v 1.3 1999/01/29 07:30:36 d Exp $	*/
d436 1
a436 1
	if (isplayer(Maze[bp->b_y][bp->b_x - 1])) {
d440 1
a440 1
	if (isplayer(Maze[bp->b_y - 1][bp->b_x])) {
d444 1
a444 1
	if (isplayer(Maze[bp->b_y + 1][bp->b_x])) {
d448 1
a448 1
	if (isplayer(Maze[bp->b_y][bp->b_x + 1])) {
@


1.3
log
@major changes: security, curses, config
@
text
@d1 1
a1 1
/*	$OpenBSD: shots.c,v 1.2 1999/01/21 05:47:42 d Exp $	*/
d34 26
d855 1
a855 1
		syslog(LOG_ERR, "malloc: %m");
d1107 1
a1107 1
	syslog(LOG_ERR, "play_at: not a player");
@


1.2
log
@ident for OpenBSD
mandoc-ify manual pages
use -locurses
@
text
@d1 1
a2 1
/*	$OpenBSD$	*/
d9 7
a15 4
# include	<err.h>
# include	<signal.h>
# include	<stdlib.h>
# include	"hunt.h"
d17 2
a18 2
# define	PLUS_DELTA(x, max)	if (x < max) x++; else x--
# define	MINUS_DELTA(x, min)	if (x > min) x--; else x++
d27 1
a27 3
#ifdef DRONE
static	void	move_drone __P((BULLET *));
#endif
d48 1
a48 1
		goto ret;
d51 1
a51 1
	 * First we move through the bullet list BULSPD times, looking
d57 1
d60 2
d64 1
d67 2
d70 1
a70 6
		for (pp = Player; pp < End_player; pp++)
			check(pp, y, x);
# ifdef MONITOR
		for (pp = Monitor; pp < End_monitor; pp++)
			check(pp, y, x);
# endif
d72 1
d74 2
d81 1
d86 2
a87 1
# ifdef OOZE
d90 1
d95 2
a96 2
# endif
# ifdef DRONE
d99 1
d104 2
a105 1
# endif
d107 1
d114 1
d119 1
d121 4
d126 2
a127 1
# ifdef MONITOR
d130 2
a131 2
# endif
# ifdef DRONE
d136 5
a140 2
# endif
			continue;
a141 3

		chkshot(bp, next);
		free((char *) bp);
d144 1
d148 3
a150 2
ret:
# ifdef BOOTS
d154 2
a155 1
# endif
a156 1
# ifdef FLY
d159 2
a160 2
# endif
		sendcom(pp, REFRESH);	/* Flush out the explosions */
a161 1
		sendcom(pp, REFRESH);
a162 4
# ifdef MONITOR
	for (pp = Monitor; pp < End_monitor; pp++)
		sendcom(pp, REFRESH);
# endif
d164 2
a165 1
	return;
d170 2
a171 1
 *	Move a normal shot along its trajectory
d180 9
a188 1
	for (i = 0; i < BULSPD; i++) {
d192 1
a194 1

d210 2
d213 1
d215 1
a215 1
			if (rand_num(100) < 5) {
d220 1
d222 1
a222 1
			if (rand_num(100) < 10) {
d227 2
a228 2
# ifdef	REFLECT
		  case WALL4:	/* reflecting walls */
a243 1
# ifdef MONITOR
a245 1
# endif
a262 1
# ifdef MONITOR
a264 1
# endif
d266 1
a266 2
# endif
# ifdef RANDOM
d283 1
a283 2
# endif
# ifdef FLY
d288 1
a288 1
# endif
d294 2
a295 2
			 * give the person a chance to catch a
			 * grenade if s/he is facing it
d300 3
a302 1
			    if (rand_num(100) < 10) {
d306 5
d313 2
d316 3
a318 1
				if (pp->p_damage + bp->b_size * MINDAM
d320 1
d322 2
d325 2
d328 2
d331 5
a335 3
				(void) sprintf(Buf, "%3d", pp->p_ammo);
				cgoto(pp, STAT_AMMO_ROW, STAT_VALUE_COL);
				outstr(pp, Buf, 3);
d338 2
d342 1
d346 1
a346 1
			 * merry way without exploding.
d348 2
a349 1
			if (rand_num(100) < 5) {
d351 3
a353 1
				if (pp->p_damage + bp->b_size * MINDAM
d355 1
d357 2
d361 2
d364 4
a367 3
				if (bp->b_owner == NULL)
					break;
				message(bp->b_owner,
d371 2
d374 3
d378 2
a379 7
			/*
			 * The shot hit that sucker!  Blow it up.
			 */
			/* FALLTHROUGH */
# ifndef RANDOM
		  case DOOR:
# endif
d387 1
d391 2
a395 1
# ifdef	DRONE
d399 1
d401 1
a401 1
static void
d406 1
a406 1
	int	n, dir;
d409 1
a409 3
	/*
	 * See if we can give someone a blast
	 */
d427 1
a427 3
	/*
	 * Find out what directions are clear
	 */
d438 1
a438 3
	/*
	 * All blocked up, just you wait
	 */
d442 1
a442 3
	/*
	 * Only one way to go.
	 */
d448 1
a448 3
	/*
	 * Get rid of the direction that we came from
	 */
d468 1
a468 3
	/*
	 * Pick one of the remaining directions
	 */
a478 4
	/*
	 * Now that we know the direction of movement,
	 * just update the position of the drone
	 */
d480 1
d482 2
d501 2
d509 2
a510 2
		 * give the person a chance to catch a
		 * drone if s/he is facing it
d512 4
a515 2
		if (rand_num(100) < 1 &&
		opposite(bp->b_face, Maze[bp->b_y][bp->b_x])) {
d519 2
d522 5
a526 3
			(void) sprintf(Buf, "%3d", pp->p_ammo);
			cgoto(pp, STAT_AMMO_ROW, STAT_VALUE_COL);
			outstr(pp, Buf, 3);
d529 1
d533 2
a536 1
# endif
d540 1
a540 1
 *	Put this bullet back onto the bullet list
d546 2
d549 1
d551 1
a555 1
# ifdef OOZE
a556 1
# ifdef VOLCANO
a557 3
# endif
# endif
# ifdef DRONE
a558 1
# endif
d564 1
a568 1
# ifdef FLY
a569 1
# endif
d572 2
a573 1
# ifdef BOOTS
d577 1
a577 1
# endif
d579 1
d585 1
d604 2
d607 2
d611 2
d629 2
d634 5
d654 1
a657 1
# ifdef	REFLECT
a659 2
# endif
# ifdef	RANDOM
a660 1
# endif
d664 1
d668 2
d672 2
d675 1
a675 1
# ifdef BOOTS
d677 1
a677 1
# endif
d679 1
a679 1
				rand_num(pp->p_damage / 5), FALL);
d682 2
a683 3
# ifdef BOOTS
		}
		else {
a687 1
# endif
d689 2
d692 1
a721 1
# ifdef	OOZE
a722 1
# ifdef VOLCANO
a723 1
# endif
a725 2
# endif
# ifdef DRONE
a729 1
# endif
d731 2
d739 1
d754 2
a760 1
# ifdef FLY
a761 1
# endif
d768 2
d772 1
a772 1
					damage * MINDAM, bp->b_type);
d776 1
a789 1
# ifdef	OOZE
d802 1
a805 1
# ifdef	REFLECT
a807 2
# endif
# ifdef	RANDOM
a808 1
# endif
d825 2
d828 4
d833 4
a836 5
# ifdef VOLCANO
	move_slime(nbp, nbp->b_type == SLIME ? SLIMESPEED : LAVASPEED, next);
# else
	move_slime(nbp, SLIMESPEED, next);
# endif
d844 1
a844 1
void
d862 1
a862 1
# ifdef VOLCANO
d864 1
a864 3
# else
	showexpl(bp->b_y, bp->b_x, '*');
# endif
d866 1
a870 1
# ifdef FLY
a871 1
# endif
d874 1
a874 1
		checkdam(pp, bp->b_owner, bp->b_score, MINDAM, bp->b_type);
d876 1
a880 1
# ifdef DRONE
a881 1
# endif
d887 2
d890 2
a891 1
		free((char *) bp);
d895 1
d967 1
a1014 1
# ifdef	REFLECT
a1016 2
# endif
# ifdef	RANDOM
a1017 2
# endif
# ifdef OOZE
a1018 1
# ifdef VOLCANO
a1019 2
# endif
# endif
a1023 1
# endif
a1033 1
	FLAG	explode;
a1034 1
	explode = FALSE;
d1036 8
a1043 6
		if (bp->b_x != obp->b_x || bp->b_y != obp->b_y)
			continue;
		if (bp->b_face == obp->b_face)
			continue;
		explode = TRUE;
		break;
a1044 3
	if (!explode)
		return;
	explshot(blist, obp->b_y, obp->b_x);
d1051 1
a1051 1
void
d1062 1
a1062 1
				message(bp->b_owner, "Shot intercepted");
d1079 4
a1082 2
	errx(1, "driver: couldn't find player at (%d,%d)", x, y);
	/* NOTREACHED */
a1177 1
# ifdef BOOTS
a1193 1
# endif
@


1.1
log
@Initial revision
@
text
@d2 1
a7 5

#include <sys/cdefs.h>
#ifndef lint
__RCSID("$NetBSD: shots.c,v 1.3 1997/10/11 08:13:50 lukem Exp $");
#endif /* not lint */
@


1.1.1.1
log
@hunt (from NetBSD)
@
text
@@
