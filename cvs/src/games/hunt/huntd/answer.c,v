head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.2
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.4
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.20.0.2
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.13.0.8
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.11.0.28
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.24
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.22
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.20
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.18
	OPENBSD_5_0:1.11.0.16
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.14
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.12
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.8
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.10
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.6
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.4
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.16
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.14
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.12
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.10
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.8
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.6
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.8
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.6
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	initial:1.1.1.1
	hunt:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2017.01.21.08.22.57;	author krw;	state Exp;
branches;
next	1.21;
commitid	slqvWeiHNc6j5Mv6;

1.21
date	2016.08.27.02.06.40;	author guenther;	state Exp;
branches;
next	1.20;
commitid	HajZYsKX8810aMqL;

1.20
date	2016.03.28.11.49.45;	author chl;	state Exp;
branches;
next	1.19;
commitid	uZM9zHxSeEnbXDPg;

1.19
date	2016.03.21.00.49.36;	author guenther;	state Exp;
branches;
next	1.18;
commitid	MSxcUg12B9iLaLLL;

1.18
date	2016.01.10.13.35.09;	author mestre;	state Exp;
branches;
next	1.17;
commitid	mVbl9a8GbGdqcFgu;

1.17
date	2016.01.07.21.37.53;	author mestre;	state Exp;
branches;
next	1.16;
commitid	OXn0Z5fMODgNmJpo;

1.16
date	2016.01.07.21.29.31;	author mestre;	state Exp;
branches;
next	1.15;
commitid	AgYVDd64zIiNi3fx;

1.15
date	2015.10.24.17.48.36;	author mmcc;	state Exp;
branches;
next	1.14;
commitid	31pYEaO7V7vihNk3;

1.14
date	2015.08.22.14.47.41;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	vWCbqNWL9DL2UkGT;

1.13
date	2014.05.25.17.39.07;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2014.03.23.02.42.47;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.06.10.22.29;	author chl;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.16.00.13.19;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.11.08.45.33;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.10;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.12.12.15.07.03;	author d;	state Exp;
branches;
next	1.6;

1.6
date	99.03.22.00.29.15;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	99.03.14.02.07.30;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	99.02.01.06.53.55;	author d;	state Exp;
branches;
next	1.3;

1.3
date	99.01.29.07.30.34;	author d;	state Exp;
branches;
next	1.2;

1.2
date	99.01.21.05.47.39;	author d;	state Exp;
branches;
next	1.1;

1.1
date	99.01.21.05.33.38;	author d;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.01.21.05.33.38;	author d;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@/*	$OpenBSD: answer.c,v 1.21 2016/08/27 02:06:40 guenther Exp $	*/
/*	$NetBSD: answer.c,v 1.3 1997/10/10 16:32:50 lukem Exp $	*/
/*
 * Copyright (c) 1983-2003, Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * + Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * + Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 * + Neither the name of the University of California, San Francisco nor
 *   the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written
 *   permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/select.h>

#include <arpa/inet.h>
#include <netinet/in.h>

#include <ctype.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

#include "conf.h"
#include "hunt.h"
#include "server.h"

/* Exported symbols for hosts_access(): */
int allow_severity	= LOG_INFO;
int deny_severity	= LOG_WARNING;


/* List of spawning connections: */
struct spawn		*Spawn = NULL;

static void	stplayer(PLAYER *, int);
static void	stmonitor(PLAYER *);
static IDENT *	get_ident(struct sockaddr *, int, u_long, char *, char);

void
answer_first(void)
{
	struct sockaddr		sockstruct;
	int			newsock;
	socklen_t		socklen;
	struct spawn *sp;

	/*
	 * Answer the call to hunt, turning off blocking I/O, so a slow
	 * or dead terminal won't stop the game.  All subsequent reads
	 * check how many bytes they read.
	 */
	socklen = sizeof sockstruct;
	newsock = accept4(Socket, (struct sockaddr *) &sockstruct, &socklen,
	    SOCK_NONBLOCK);
	if (newsock < 0) {
		logit(LOG_ERR, "accept");
		return;
	}

	/* Remember this spawning connection: */
	sp = calloc(1, sizeof *sp);
	if (sp == NULL) {
		logit(LOG_ERR, "calloc");
		close(newsock);
		return;
	}

	/* Keep the calling machine's source addr for ident purposes: */
	memcpy(&sp->source, &sockstruct, sizeof sp->source);
	sp->sourcelen = socklen;

	/* Warn if we lose connection info: */
	if (socklen > sizeof Spawn->source)
		logx(LOG_WARNING,
		    "struct sockaddr is not big enough! (%d > %zu)",
		    socklen, sizeof Spawn->source);

	/* Start listening to the spawning connection */
	sp->fd = newsock;
	FD_SET(sp->fd, &Fds_mask);
	if (sp->fd >= Num_fds)
		Num_fds = sp->fd + 1;

	sp->reading_msg = 0;
	sp->inlen = 0;

	/* Add to the spawning list */
	if ((sp->next = Spawn) != NULL)
		Spawn->prevnext = &sp->next;
	sp->prevnext = &Spawn;
	Spawn = sp;
}

int
answer_next(struct spawn *sp)
{
	PLAYER			*pp;
	char			*cp1, *cp2;
	u_int32_t		version;
	FILE			*conn;
	int			len;
	char			teamstr[] = "[x]";

	if (sp->reading_msg) {
		/* Receive a message from a player */
		len = read(sp->fd, sp->msg + sp->msglen,
		    sizeof sp->msg - sp->msglen);
		if (len < 0)
			goto error;
		sp->msglen += len;
		if (len && sp->msglen < sizeof sp->msg)
			return FALSE;

		teamstr[1] = sp->team;
		outyx(ALL_PLAYERS, HEIGHT, 0, "%s%s: %.*s",
			sp->name,
			sp->team == ' ' ? "": teamstr,
			sp->msglen,
			sp->msg);
		ce(ALL_PLAYERS);
		sendcom(ALL_PLAYERS, REFRESH);
		sendcom(ALL_PLAYERS, READY, 0);
		flush(ALL_PLAYERS);
		goto close_it;
	}

	/* Fill the buffer */
	len = read(sp->fd, sp->inbuf + sp->inlen,
	    sizeof sp->inbuf - sp->inlen);
	if (len <= 0)
		goto error;
	sp->inlen += len;
	if (sp->inlen < sizeof sp->inbuf)
		return FALSE;

	/* Extract values from the buffer */
	cp1 = sp->inbuf;
	memcpy(&sp->uid, cp1, sizeof (u_int32_t));
	cp1+= sizeof(u_int32_t);
	memcpy(sp->name, cp1, NAMELEN);
	cp1+= NAMELEN;
	memcpy(&sp->team, cp1, sizeof (u_int8_t));
	cp1+= sizeof(u_int8_t);
	memcpy(&sp->enter_status, cp1, sizeof (u_int32_t));
	cp1+= sizeof(u_int32_t);
	memcpy(sp->ttyname, cp1, NAMELEN);
	cp1+= NAMELEN;
	memcpy(&sp->mode, cp1, sizeof (u_int32_t));
	cp1+= sizeof(u_int32_t);

	/* Convert data from network byte order: */
	sp->uid = ntohl(sp->uid);
	sp->enter_status = ntohl(sp->enter_status);
	sp->mode = ntohl(sp->mode);

	/*
	 * Make sure the name contains only printable characters
	 * since we use control characters for cursor control
	 * between driver and player processes
	 */
	sp->name[NAMELEN] = '\0';
	for (cp1 = cp2 = sp->name; *cp1 != '\0'; cp1++)
		if (isprint((unsigned char)*cp1) || *cp1 == ' ')
			*cp2++ = *cp1;
	*cp2 = '\0';

	/* Make sure team name is valid */
	if (sp->team < '1' || sp->team > '9')
		sp->team = ' ';

	/* Tell the other end this server's hunt driver version: */
	version = htonl((u_int32_t) HUNT_VERSION);
	(void) write(sp->fd, &version, sizeof version);

	if (sp->mode == C_MESSAGE) {
		/* The clients only wants to send a message: */
		sp->msglen = 0;
		sp->reading_msg = 1;
		return FALSE;
	}

	/* Use a stdio file descriptor from now on: */
	conn = fdopen(sp->fd, "w");

	/* The player is a monitor: */
	if (sp->mode == C_MONITOR) {
		if (conf_monitor && End_monitor < &Monitor[MAXMON]) {
			pp = End_monitor++;
			if (sp->team == ' ')
				sp->team = '*';
		} else {
			/* Too many monitors */
			fprintf(conn, "Too many monitors\n");
			fflush(conn);
			logx(LOG_NOTICE, "too many monitors");
			goto close_it;
		}

	/* The player is a normal hunter: */
	} else {
		if (End_player < &Player[MAXPL])
			pp = End_player++;
		else {
			fprintf(conn, "Too many players\n");
			fflush(conn);
			/* Too many players */
			logx(LOG_NOTICE, "too many players");
			goto close_it;
		}
	}

	/* Find the player's running scorecard */
	pp->p_ident = get_ident(&sp->source, sp->sourcelen, sp->uid,
	    sp->name, sp->team);
	pp->p_output = conn;
	pp->p_death[0] = '\0';
	pp->p_fd = sp->fd;

	/* No idea where the player starts: */
	pp->p_y = 0;
	pp->p_x = 0;

	/* Mode-specific initialisation: */
	if (sp->mode == C_MONITOR)
		stmonitor(pp);
	else
		stplayer(pp, sp->enter_status);

	/* And, they're off! Caller should remove and free sp. */
	return TRUE;

error:
	if (len < 0)
		logit(LOG_WARNING, "read");
	else
		logx(LOG_WARNING, "lost connection to new client");

close_it:
	/* Destroy the spawn */
	*sp->prevnext = sp->next;
	if (sp->next) sp->next->prevnext = sp->prevnext;
	FD_CLR(sp->fd, &Fds_mask);
	close(sp->fd);
	free(sp);
	return FALSE;
}

/* Start a monitor: */
static void
stmonitor(PLAYER *pp)
{

	/* Monitors get to see the entire maze: */
	memcpy(pp->p_maze, Maze, sizeof pp->p_maze);
	drawmaze(pp);

	/* Put the monitor's name near the bottom right on all screens: */
	outyx(ALL_PLAYERS,
		STAT_MON_ROW + 1 + (pp - Monitor), STAT_NAME_COL,
		"%5.5s%c%-10.10s %c", " ",
		stat_char(pp), pp->p_ident->i_name, pp->p_ident->i_team);

	/* Ready the monitor: */
	sendcom(pp, REFRESH);
	sendcom(pp, READY, 0);
	flush(pp);
}

/* Start a player: */
static void
stplayer(PLAYER *newpp, int enter_status)
{
	int	x, y;
	PLAYER	*pp;
	int len;

	Nplayer++;

	for (y = 0; y < UBOUND; y++)
		for (x = 0; x < WIDTH; x++)
			newpp->p_maze[y][x] = Maze[y][x];
	for (     ; y < DBOUND; y++) {
		for (x = 0; x < LBOUND; x++)
			newpp->p_maze[y][x] = Maze[y][x];
		for (     ; x < RBOUND; x++)
			newpp->p_maze[y][x] = SPACE;
		for (     ; x < WIDTH;  x++)
			newpp->p_maze[y][x] = Maze[y][x];
	}
	for (     ; y < HEIGHT; y++)
		for (x = 0; x < WIDTH; x++)
			newpp->p_maze[y][x] = Maze[y][x];

	/* Drop the new player somewhere in the maze: */
	do {
		x = rand_num(WIDTH - 1) + 1;
		y = rand_num(HEIGHT - 1) + 1;
	} while (Maze[y][x] != SPACE);
	newpp->p_over = SPACE;
	newpp->p_x = x;
	newpp->p_y = y;
	newpp->p_undershot = FALSE;

	/* Send them flying if needed */
	if (enter_status == Q_FLY && conf_fly) {
		newpp->p_flying = rand_num(conf_flytime);
		newpp->p_flyx = 2 * rand_num(conf_flystep + 1) - conf_flystep;
		newpp->p_flyy = 2 * rand_num(conf_flystep + 1) - conf_flystep;
		newpp->p_face = FLYER;
	} else {
		newpp->p_flying = -1;
		newpp->p_face = rand_dir();
	}

	/* Initialize the new player's attributes: */
	newpp->p_damage = 0;
	newpp->p_damcap = conf_maxdam;
	newpp->p_nchar = 0;
	newpp->p_ncount = 0;
	newpp->p_nexec = 0;
	newpp->p_ammo = conf_ishots;
	newpp->p_nboots = 0;

	/* Decide on what cloak/scan status to enter with */
	if (enter_status == Q_SCAN && conf_scan) {
		newpp->p_scan = conf_scanlen * Nplayer;
		newpp->p_cloak = 0;
	} else if (conf_cloak) {
		newpp->p_scan = 0;
		newpp->p_cloak = conf_cloaklen;
	} else {
		newpp->p_scan = 0;
		newpp->p_cloak = 0;
	}
	newpp->p_ncshot = 0;

	/*
	 * For each new player, place a large mine and
	 * a small mine somewhere in the maze:
	 */
	do {
		x = rand_num(WIDTH - 1) + 1;
		y = rand_num(HEIGHT - 1) + 1;
	} while (Maze[y][x] != SPACE);
	Maze[y][x] = GMINE;
	for (pp = Monitor; pp < End_monitor; pp++)
		check(pp, y, x);

	do {
		x = rand_num(WIDTH - 1) + 1;
		y = rand_num(HEIGHT - 1) + 1;
	} while (Maze[y][x] != SPACE);
	Maze[y][x] = MINE;
	for (pp = Monitor; pp < End_monitor; pp++)
		check(pp, y, x);

	/* Create a score line for the new player: */
	(void) snprintf(Buf, sizeof Buf, "%5.2f%c%-10.10s %c",
		newpp->p_ident->i_score, stat_char(newpp),
		newpp->p_ident->i_name, newpp->p_ident->i_team);
	len = strlen(Buf);
	y = STAT_PLAY_ROW + 1 + (newpp - Player);
	for (pp = Player; pp < End_player; pp++) {
		if (pp != newpp) {
			/* Give everyone a few more shots: */
			pp->p_ammo += conf_nshots;
			newpp->p_ammo += conf_nshots;
			outyx(pp, y, STAT_NAME_COL, Buf, len);
			ammo_update(pp);
		}
	}
	for (pp = Monitor; pp < End_monitor; pp++)
		outyx(pp, y, STAT_NAME_COL, Buf, len);

	/* Show the new player what they can see and where they are: */
	drawmaze(newpp);
	drawplayer(newpp, TRUE);
	look(newpp);

	/* Make sure that the position they enter in will be erased: */
	if (enter_status == Q_FLY && conf_fly)
		showexpl(newpp->p_y, newpp->p_x, FLYER);

	/* Ready the new player: */
	sendcom(newpp, REFRESH);
	sendcom(newpp, READY, 0);
	flush(newpp);
}

/*
 * rand_dir:
 *	Return a random direction
 */
int
rand_dir(void)
{
	switch (rand_num(4)) {
	  case 0:
		return LEFTS;
	  case 1:
		return RIGHT;
	  case 2:
		return BELOW;
	  case 3:
		return ABOVE;
	}
	return(-1);
}

/*
 * get_ident:
 *	Get the score structure of a player
 */
static IDENT *
get_ident(struct sockaddr *sa, int salen, u_long uid, char *name, char team)
{
	IDENT		*ip;
	static IDENT	punt;
	u_int32_t	machine;

	if (sa->sa_family == AF_INET)
		machine = ntohl((u_long)((struct sockaddr_in *)sa)->sin_addr.s_addr);
	else
		machine = 0;

	for (ip = Scores; ip != NULL; ip = ip->i_next)
		if (ip->i_machine == machine
		&&  ip->i_uid == uid
		/* &&  ip->i_team == team */
		&&  strncmp(ip->i_name, name, NAMELEN) == 0)
			break;

	if (ip != NULL) {
		if (ip->i_team != team) {
			logx(LOG_INFO, "player %s %s team %c",
				name,
				team == ' ' ? "left" : ip->i_team == ' ' ?
					"joined" : "changed to",
				team == ' ' ? ip->i_team : team);
			ip->i_team = team;
		}
		if (ip->i_entries < conf_scoredecay)
			ip->i_entries++;
		else
			ip->i_kills = (ip->i_kills * (conf_scoredecay - 1))
				/ conf_scoredecay;
		ip->i_score = ip->i_kills / (double) ip->i_entries;
	}
	else {
		/* Alloc new entry -- it is released in clear_scores() */
		ip = malloc(sizeof (IDENT));
		if (ip == NULL) {
			logit(LOG_ERR, "malloc");
			/* Fourth down, time to punt */
			ip = &punt;
		}
		ip->i_machine = machine;
		ip->i_team = team;
		ip->i_uid = uid;
		strlcpy(ip->i_name, name, sizeof ip->i_name);
		ip->i_kills = 0;
		ip->i_entries = 1;
		ip->i_score = 0;
		ip->i_absorbed = 0;
		ip->i_faced = 0;
		ip->i_shot = 0;
		ip->i_robbed = 0;
		ip->i_slime = 0;
		ip->i_missed = 0;
		ip->i_ducked = 0;
		ip->i_gkills = ip->i_bkills = ip->i_deaths = 0;
		ip->i_stillb = ip->i_saved = 0;
		ip->i_next = Scores;
		Scores = ip;

		logx(LOG_INFO, "new player: %s%s%c%s",
			name,
			team == ' ' ? "" : " (team ",
			team,
			team == ' ' ? "" : ")");
	}

	return ip;
}

void
answer_info(FILE *fp)
{
	struct spawn *sp;
	char buf[128];
	const char *bf;
	struct sockaddr_in *sa;

	if (Spawn == NULL)
		return;
	fprintf(fp, "\nSpawning connections:\n");
	for (sp = Spawn; sp; sp = sp->next) {
		sa = (struct sockaddr_in *)&sp->source;
		bf = inet_ntop(AF_INET, &sa->sin_addr, buf, sizeof buf);
		if (!bf)  {
			logit(LOG_WARNING, "inet_ntop");
			bf = "?";
		}
		fprintf(fp, "fd %d: state %d, from %s:%d\n",
			sp->fd, sp->inlen + (sp->reading_msg ? sp->msglen : 0),
			bf, sa->sin_port);
	}
}
@


1.21
log
@Pull in <sys/select.h> for fd_set

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: answer.c,v 1.20 2016/03/28 11:49:45 chl Exp $	*/
d6 3
a8 3
 * 
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are 
d10 2
a11 2
 * 
 * + Redistributions of source code must retain the above copyright 
d13 2
a14 2
 * + Redistributions in binary form must reproduce the above copyright 
 *   notice, this list of conditions and the following disclaimer in the 
d16 3
a18 3
 * + Neither the name of the University of California, San Francisco nor 
 *   the names of its contributors may be used to endorse or promote 
 *   products derived from this software without specific prior written 
d20 11
a30 11
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS 
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED 
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
d96 2
a97 2
	if (socklen > sizeof Spawn->source) 
		logx(LOG_WARNING, 
d125 1
a125 1
	char 			teamstr[] = "[x]";
d129 1
a129 1
		len = read(sp->fd, sp->msg + sp->msglen, 
d151 1
a151 1
	len = read(sp->fd, sp->inbuf + sp->inlen, 
d236 1
a236 1
	pp->p_ident = get_ident(&sp->source, sp->sourcelen, sp->uid, 
d256 1
a256 1
	if (len < 0) 
d281 1
a281 1
	outyx(ALL_PLAYERS, 
d283 1
a283 1
		"%5.5s%c%-10.10s %c", " ", 
d381 2
a382 2
	(void) snprintf(Buf, sizeof Buf, "%5.2f%c%-10.10s %c", 
		newpp->p_ident->i_score, stat_char(newpp), 
d460 1
a460 1
				team == ' ' ? "left" : ip->i_team == ' ' ? 
d500 1
a500 1
			name, 
@


1.20
log
@remove unused variables

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: answer.c,v 1.19 2016/03/21 00:49:36 guenther Exp $	*/
d33 2
@


1.19
log
@Instead of creating a socket with socket() or accept() and then
setting the O_NONBLOCK flag on it with fcntl(F_SETFL) afterwards,
just pass SOCK_NONBLOCK to socket() or accept4() and get it right
to begin with.

ok millert@@ krw@@ beck@@ deraadt@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: answer.c,v 1.18 2016/01/10 13:35:09 mestre Exp $	*/
a65 1
	int			flags;
@


1.18
log
@As per style(9), remove remaining lint-style comments from games/

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: answer.c,v 1.17 2016/01/07 21:37:53 mestre Exp $	*/
d69 5
a73 1
	/* Answer the call to hunt: */
d75 2
a76 1
	newsock = accept(Socket, (struct sockaddr *) &sockstruct, &socklen);
a98 8

	/*
	 * Turn off blocking I/O, so a slow or dead terminal won't stop
	 * the game.  All subsequent reads check how many bytes they read.
	 */
	flags = fcntl(newsock, F_GETFL, 0);
	flags |= O_NDELAY;
	(void) fcntl(newsock, F_SETFL, flags);
@


1.17
log
@ANSIfy hunt(6)

Note: casted 2 args to struct sockaddr * on list.c to shut off compiler
warnings, and also changed an int len to socklen_t since recvfrom(2) receives
the last argument as the latter.

I'm running out of credits, but this was once again with great help and OK from
tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: answer.c,v 1.16 2016/01/07 21:29:31 mestre Exp $	*/
a431 1
	/* NOTREACHED */
@


1.16
log
@Headers cleanup and sorting

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: answer.c,v 1.15 2015/10/24 17:48:36 mmcc Exp $	*/
d61 1
a61 1
answer_first()
d120 1
a120 2
answer_next(sp)
	struct spawn *sp;
d275 1
a275 2
stmonitor(pp)
	PLAYER	*pp;
d296 1
a296 3
stplayer(newpp, enter_status)
	PLAYER	*newpp;
	int	enter_status;
d420 1
a420 1
rand_dir()
d441 1
a441 6
get_ident(sa, salen, uid, name, team)
	struct sockaddr *sa;
	int	salen;
	u_long	uid;
	char	*name;
	char	team;
d513 1
a513 2
answer_info(fp)
	FILE *fp;
@


1.15
log
@Cast isprint()'s argument to unsigned char.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: answer.c,v 1.14 2015/08/22 14:47:41 deraadt Exp $	*/
d34 3
a37 1
#include <errno.h>
d40 2
a42 6
#include <stdio.h>
#include <syslog.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
d44 1
a46 1
#include "conf.h"
@


1.14
log
@remove malloc/calloc/realloc* casts, due to stdlib.h being present; ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: answer.c,v 1.13 2014/05/25 17:39:07 tedu Exp $	*/
d191 1
a191 1
		if (isprint(*cp1) || *cp1 == ' ')
@


1.13
log
@use calloc. from Benjamin Baier
@
text
@d1 1
a1 1
/*	$OpenBSD: answer.c,v 1.12 2014/03/23 02:42:47 tedu Exp $	*/
d488 1
a488 1
		ip = (IDENT *) malloc(sizeof (IDENT));
@


1.12
log
@stop using libwrap. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: answer.c,v 1.11 2007/11/06 10:22:29 chl Exp $	*/
d80 1
a80 1
	sp = (struct spawn *)malloc(sizeof *sp);
d82 1
a82 1
		logit(LOG_ERR, "malloc");
a85 1
	memset(sp, '\0', sizeof *sp);
@


1.11
log
@fix format string

ok ray@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: answer.c,v 1.10 2004/01/16 00:13:19 espie Exp $	*/
a39 1
#include <tcpd.h>
a68 1
	struct request_info	ri;
a75 9
		return;
	}

	/* Check for access permissions: */
	request_init(&ri, RQ_DAEMON, "huntd", RQ_FILE, newsock, 0);
	fromhost(&ri);
	if (hosts_access(&ri) == 0) {
		logx(LOG_INFO, "rejected connection from %s", eval_client(&ri));
		close(newsock);
@


1.10
log
@ISO C police: log and expl are reserved for the C library.
expl -> expl_string
log -> logit
@
text
@d1 1
a1 1
/*	$OpenBSD: answer.c,v 1.9 2003/06/11 08:45:33 pjanzen Exp $	*/
d106 1
a106 1
		    "struct sockaddr is not big enough! (%d > %d)",
@


1.9
log
@New license from the official hunt release at
ftp://ftp.cgl.ucsf.edu/pub/hunt.shar.Z -- it has been approved by all three
authors (Conrad Huang, Ken Arnold, and Greg Couch).
@
text
@d1 1
a1 1
/*	$OpenBSD: answer.c,v 1.8 2002/02/16 21:27:10 millert Exp $	*/
d77 1
a77 1
		log(LOG_ERR, "accept");
d93 1
a93 1
		log(LOG_ERR, "malloc");
d274 1
a274 1
		log(LOG_WARNING, "read");
d502 1
a502 1
			log(LOG_ERR, "malloc");
d551 1
a551 1
			log(LOG_WARNING, "inet_ntop");
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: answer.c,v 1.7 1999/12/12 15:07:03 d Exp $	*/
d4 28
a31 3
 *  Hunt
 *  Copyright (c) 1985 Conrad C. Huang, Gregory S. Couch, Kenneth C.R.C. Arnold
 *  San Francisco, California
@


1.7
log
@Use socklen_t
Cope with fragmented reads in the initial cilent connect a lot better/simpler.
Check the team name.
Caller must free allocated 'spawn' structures.

reviewed by pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: answer.c,v 1.6 1999/03/22 00:29:15 pjanzen Exp $	*/
d34 3
a36 3
static void	stplayer __P((PLAYER *, int));
static void	stmonitor __P((PLAYER *));
static IDENT *	get_ident __P((struct sockaddr *, int, u_long, char *, char));
@


1.6
log
@More accurate man page; more informative logging; use random() instead of
old internal routine (seems to minimize instant death on re-entry).
@
text
@d1 1
a1 1
/*	$OpenBSD: answer.c,v 1.5 1999/03/14 02:07:30 pjanzen Exp $	*/
d43 1
a43 1
	int			socklen;
d98 2
a99 2
	/* Initialise the spawn state */
	sp->state = 0;
d117 1
d119 9
a127 40
	switch (sp->state) {
	case 0: 
		len = read(sp->fd, &sp->uid, sizeof sp->uid);
		break;
	case 1:
		len = read(sp->fd, sp->name, NAMELEN);
		sp->name[NAMELEN] = '\0';
		break;
	case 2:
		len = read(sp->fd, &sp->team, sizeof sp->team);
		break;
	case 3:
		len = read(sp->fd, &sp->enter_status, sizeof sp->enter_status);
		break;
	case 4:	
		len = read(sp->fd, sp->ttyname, NAMELEN);
		break;
	case 5:
		len = read(sp->fd, &sp->mode, sizeof sp->mode);
		break;
 	case 7:
		len = sp->msglen = read(sp->fd, &sp->msg, sizeof sp->msg - 1);
		break;
	default:
		log(LOG_ERR, "impossible state %d", sp->state);
		goto close_it;
	}

	if (len < 0) {
		log(LOG_WARNING, "read");
		goto close_it;
	}
	if (len == 0) {
		logx(LOG_WARNING, "lost connection to new client");
		goto close_it;
	}

	if (sp->state == 7) {
		/* Received message: */
		char teamstr[] = "[?]";
d142 7
a148 3
	sp->state++;
	if (sp->state != 6) {
		/* More to come: */
d150 15
a164 1
	}
d176 1
d182 4
d191 3
a193 2
		/* The connection is solely for a message: */
		sp->state = 7;
a233 4
	/* Remove from the spawn list. (fd remains in read set) */
	*sp->prevnext = sp->next;
	if (sp->next) sp->next->prevnext = sp->prevnext;

d244 1
a244 1
	/* And, they're off! */
d247 6
d530 2
a531 1
			sp->fd, sp->state, bf, sa->sin_port);
@


1.5
log
@Access control works now; also, some minor tidying and man page fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: answer.c,v 1.4 1999/02/01 06:53:55 d Exp $	*/
d60 1
a61 1
		logx(LOG_INFO, "rejected connection");
@


1.4
log
@avoid denial of service attacks on server port; extra conf vars; fix otto
@
text
@d1 1
a1 1
/*	$OpenBSD: answer.c,v 1.3 1999/01/29 07:30:34 d Exp $	*/
d58 1
@


1.3
log
@major changes: security, curses, config
@
text
@d1 1
a1 1
/*	$OpenBSD: answer.c,v 1.2 1999/01/21 05:47:39 d Exp $	*/
d20 1
d30 4
d36 1
a36 2
static IDENT *	get_ident __P((u_long, u_long, char *, char, 
			struct request_info *));
d38 2
a39 2
int
answer()
d41 1
a41 1
	PLAYER			*pp;
a42 4
	u_int32_t		mode;
	char			name[NAMELEN];
	u_int8_t		team;
	u_int32_t		enter_status;
a43 4
	u_long			machine;
	u_int32_t		uid;
	struct sockaddr_in	sockstruct;
	char			*cp1, *cp2;
a44 1
	u_int32_t		version;
d46 1
a46 1
	char			Ttyname[NAMELEN];	/* never used */
d48 1
a49 1
	errno = 0;
d51 3
a53 6
	if (newsock < 0)
	{
		if (errno == EINTR)
			return FALSE;
		syslog(LOG_ERR, "accept: %m");
		cleanup(1);
d60 2
a61 1
		return (FALSE);
d64 18
a81 12
	machine = ntohl((u_int32_t)((struct sockaddr_in *) &sockstruct)->sin_addr.s_addr);
	version = htonl((u_int32_t) HUNT_VERSION);
	(void) write(newsock, &version, sizeof version);
	(void) read(newsock, &uid, sizeof uid);
	uid = ntohl((unsigned long) uid);
	(void) read(newsock, name, sizeof name);
	(void) read(newsock, &team, sizeof team);
	(void) read(newsock, &enter_status, sizeof enter_status);
	enter_status = ntohl((unsigned long) enter_status);
	(void) read(newsock, Ttyname, sizeof Ttyname);
	(void) read(newsock, &mode, sizeof mode);
	mode = ntohl(mode);
d91 91
d187 1
a187 1
	for (cp1 = cp2 = name; *cp1 != '\0'; cp1++)
d192 3
a194 32
	/* The connection is solely for a message: */
	if (mode == C_MESSAGE) {
		fd_set r;
		struct timeval tmo = { 0, 1000000 / 2 };
		char	buf[BUFSIZ + 1];
		int	buflen;
		int	n;

		/* wait for 0.5 second for the message packet */
		FD_ZERO(&r);
		FD_SET(newsock, &r);
		n = select(newsock+1, &r, 0, 0, &tmo);
		if (n < 0)
			syslog(LOG_ERR, "select: %m");
		else if (n > 0)  {
			buflen = 0;
			while (buflen < (BUFSIZ - 1) && (n = read(newsock, 
			    buf + buflen, (BUFSIZ - 1) - buflen)) > 0) 
				buflen += n;
			buf[buflen] = '\0';

			if (team == ' ')
				outyx(ALL_PLAYERS, HEIGHT, 0, "%s: %s", 
					name, buf);
			else
				outyx(ALL_PLAYERS, HEIGHT, 0, "%s[%c]: %s", 
					name, team, buf);
			ce(ALL_PLAYERS);
			sendcom(ALL_PLAYERS, REFRESH);
			sendcom(ALL_PLAYERS, READY, 0);
			flush(ALL_PLAYERS);
		}
d196 3
a198 1
		(void) close(newsock);
d202 3
d206 1
a206 1
	else if (mode == C_MONITOR) {
d209 2
a210 2
			if (team == ' ')
				team = '*';
a211 2
			u_int32_t response;

d213 4
a216 6
			response = htonl(0);
			(void) write(newsock, (char *) &response,
				sizeof response);
			(void) close(newsock);
			syslog(LOG_NOTICE, "too many monitors");
			return FALSE;
d224 2
a225 2
			u_int32_t response;

d227 2
a228 6
			response = htonl(0);
			(void) write(newsock, (char *) &response,
				sizeof response);
			(void) close(newsock);
			syslog(LOG_NOTICE, "too many players");
			return FALSE;
d232 4
a235 2
	pp->p_ident = get_ident(machine, uid, name, team, &ri);
	pp->p_output = fdopen(newsock, "w");
d237 5
a241 4
	pp->p_fd = newsock;
	FD_SET(pp->p_fd, &Fds_mask);
	if (pp->p_fd >= Num_fds)
		Num_fds = pp->p_fd + 1;
d243 1
d247 2
a248 1
	if (mode == C_MONITOR)
d251 3
a253 1
		stplayer(pp, enter_status);
d255 9
d437 3
a439 2
get_ident(machine, uid, name, team, ri)
	u_long	machine;
a442 1
	struct request_info *ri;
d446 6
d462 1
a462 1
			syslog(LOG_INFO, "player %s %s team %c",
d480 1
a480 1
			syslog(LOG_ERR, "malloc: %m");
d503 1
a503 1
		syslog(LOG_INFO, "new player: %s%s%c%s",
d511 24
@


1.2
log
@ident for OpenBSD
mandoc-ify manual pages
use -locurses
@
text
@d1 1
a2 1
/*	$OpenBSD$	*/
d9 24
a32 10
# include	<ctype.h>
# include	<errno.h>
# include	<fcntl.h>
# include	<stdlib.h>
# include	<unistd.h>
# include	"hunt.h"

# define	SCOREDECAY	15

static char	Ttyname[NAMELEN];
d39 8
a46 8
	static u_long		mode;
	static char		name[NAMELEN];
	static char		team;
	static int		enter_status;
	static int		socklen;
	static u_long		machine;
	static u_long		uid;
	static SOCKET		sockstruct;
d49 3
a51 1
	long			version;
a52 1
# ifdef INTERNET
a53 3
# else
	socklen = sizeof sockstruct - 1;
# endif
a59 1
# ifdef LOG
a60 3
# else
		perror("accept");
# endif
d64 8
a71 6
# ifdef INTERNET
	machine = ntohl(((struct sockaddr_in *) &sockstruct)->sin_addr.s_addr);
# else
	if (machine == 0)
		machine = gethostid();
# endif
d73 2
a74 2
	(void) write(newsock, (char *) &version, LONGLEN);
	(void) read(newsock, (char *) &uid, LONGLEN);
d76 3
a78 3
	(void) read(newsock, name, NAMELEN);
	(void) read(newsock, &team, 1);
	(void) read(newsock, (char *) &enter_status, LONGLEN);
d80 2
a81 2
	(void) read(newsock, Ttyname, NAMELEN);
	(void) read(newsock, (char *) &mode, sizeof mode);
d102 1
a102 1
# ifdef INTERNET
d104 2
d107 1
d110 23
a132 17
		if (team == ' ')
			(void) sprintf(buf, "%s: ", name);
		else
			(void) sprintf(buf, "%s[%c]: ", name, team);
		n = strlen(buf);
		for (pp = Player; pp < End_player; pp++) {
			cgoto(pp, HEIGHT, 0);
			outstr(pp, buf, n);
		}
		while ((n = read(newsock, buf, BUFSIZ)) > 0)
			for (pp = Player; pp < End_player; pp++)
				outstr(pp, buf, n);
		for (pp = Player; pp < End_player; pp++) {
			ce(pp);
			sendcom(pp, REFRESH);
			sendcom(pp, READY, 0);
			(void) fflush(pp->p_output);
d134 1
d138 4
a141 5
	else
# endif
# ifdef MONITOR
	if (mode == C_MONITOR)
		if (End_monitor < &Monitor[MAXMON])
d143 9
a151 4
		else {
			socklen = 0;
			(void) write(newsock, (char *) &socklen,
				sizeof socklen);
d153 1
d156 3
a158 2
	else
# endif
d162 6
a167 3
			socklen = 0;
			(void) write(newsock, (char *) &socklen,
				sizeof socklen);
d169 1
d172 1
d174 1
a174 5
#ifdef MONITOR
	if (mode == C_MONITOR && team == ' ')
		team = '*';
#endif
	pp->p_ident = get_ident(machine, uid, name, team);
a184 1
# ifdef MONITOR
a187 1
# endif
d192 2
a193 2
# ifdef MONITOR
void
a196 4
	int	line;
	PLAYER	*npp;

	memcpy(pp->p_maze, Maze, sizeof Maze);
d198 2
d202 5
a206 11
	(void) sprintf(Buf, "%5.5s%c%-10.10s %c", " ", stat_char(pp),
		pp->p_ident->i_name, pp->p_ident->i_team);
	line = STAT_MON_ROW + 1 + (pp - Monitor);
	for (npp = Player; npp < End_player; npp++) {
		cgoto(npp, line, STAT_NAME_COL);
		outstr(npp, Buf, STAT_NAME_LEN);
	}
	for (npp = Monitor; npp < End_monitor; npp++) {
		cgoto(npp, line, STAT_NAME_COL);
		outstr(npp, Buf, STAT_NAME_LEN);
	}
d208 1
d211 1
a211 1
	(void) fflush(pp->p_output);
a212 1
# endif
d214 2
a215 1
void
d222 1
d241 1
d251 5
a255 5
# ifdef FLY
	if (enter_status == Q_FLY) {
		newpp->p_flying = rand_num(20);
		newpp->p_flyx = 2 * rand_num(6) - 5;
		newpp->p_flyy = 2 * rand_num(6) - 5;
d257 1
a257 4
	}
	else
# endif
	{
d261 2
d264 1
a264 1
	newpp->p_damcap = MAXDAM;
d268 1
a268 2
	newpp->p_ammo = ISHOTS;
# ifdef BOOTS
d270 4
a273 3
# endif
	if (enter_status == Q_SCAN) {
		newpp->p_scan = SCANLEN;
d275 4
a278 2
	}
	else {
d280 1
a280 1
		newpp->p_cloak = CLOAKLEN;
d284 4
a292 1
# ifdef MONITOR
a294 1
# endif
a300 1
# ifdef MONITOR
a302 1
# endif
d304 5
a308 3
	(void) sprintf(Buf, "%5.2f%c%-10.10s %c", newpp->p_ident->i_score,
		stat_char(newpp), newpp->p_ident->i_name,
		newpp->p_ident->i_team);
d312 5
a316 9
			char	smallbuf[10];

			pp->p_ammo += NSHOTS;
			newpp->p_ammo += NSHOTS;
			cgoto(pp, y, STAT_NAME_COL);
			outstr(pp, Buf, STAT_NAME_LEN);
			(void) sprintf(smallbuf, "%3d", pp->p_ammo);
			cgoto(pp, STAT_AMMO_ROW, STAT_VALUE_COL);
			outstr(pp, smallbuf, 3);
d319 2
a320 6
# ifdef MONITOR
	for (pp = Monitor; pp < End_monitor; pp++) {
		cgoto(pp, y, STAT_NAME_COL);
		outstr(pp, Buf, STAT_NAME_LEN);
	}
# endif
d322 1
d326 3
a328 3
# ifdef	FLY
	if (enter_status == Q_FLY)
		/* Make sure that the position you enter in will be erased */
d330 2
a331 1
# endif
d334 1
a334 1
	(void) fflush(newpp->p_output);
d362 2
a363 2
IDENT *
get_ident(machine, uid, name, team)
d368 1
d376 1
a376 1
		&&  ip->i_team == team
d381 9
a389 1
		if (ip->i_entries < SCOREDECAY)
d392 2
a393 2
			ip->i_kills = (ip->i_kills * (SCOREDECAY - 1))
				/ SCOREDECAY;
d397 1
d400 1
d407 1
a407 1
		strncpy(ip->i_name, name, NAMELEN);
d422 6
@


1.1
log
@Initial revision
@
text
@d2 1
a7 5

#include <sys/cdefs.h>
#ifndef lint
__RCSID("$NetBSD: answer.c,v 1.3 1997/10/10 16:32:50 lukem Exp $");
#endif /* not lint */
@


1.1.1.1
log
@hunt (from NetBSD)
@
text
@@
