head	1.15;
access;
symbols
	OPENBSD_6_2:1.15.0.6
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.15.0.4
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.9.0.34
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.26
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.30
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.28
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.24
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.22
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.20
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.18
	OPENBSD_5_0:1.9.0.16
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.14
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.12
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.8
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.10
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.6
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.4
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.8.0.16
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.14
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.12
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.10
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.8
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.10
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.8
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.6
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	initial:1.1.1.1
	hunt:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2017.01.21.08.22.57;	author krw;	state Exp;
branches;
next	1.14;
commitid	slqvWeiHNc6j5Mv6;

1.14
date	2016.08.27.02.06.40;	author guenther;	state Exp;
branches;
next	1.13;
commitid	HajZYsKX8810aMqL;

1.13
date	2016.01.07.21.37.53;	author mestre;	state Exp;
branches;
next	1.12;
commitid	OXn0Z5fMODgNmJpo;

1.12
date	2016.01.07.21.29.31;	author mestre;	state Exp;
branches;
next	1.11;
commitid	AgYVDd64zIiNi3fx;

1.11
date	2015.09.27.07.06.41;	author guenther;	state Exp;
branches;
next	1.10;
commitid	iQfwdqs7w9ue7P08;

1.10
date	2015.08.22.14.47.41;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	vWCbqNWL9DL2UkGT;

1.9
date	2007.09.04.22.39.31;	author hshoexer;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.16.00.13.19;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.11.08.45.33;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.10;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.08.30.23.30.08;	author d;	state Exp;
branches;
next	1.4;

1.4
date	99.02.01.06.53.56;	author d;	state Exp;
branches;
next	1.3;

1.3
date	99.01.29.07.30.35;	author d;	state Exp;
branches;
next	1.2;

1.2
date	99.01.21.05.47.41;	author d;	state Exp;
branches;
next	1.1;

1.1
date	99.01.21.05.33.38;	author d;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.01.21.05.33.38;	author d;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@/*	$OpenBSD: expl.c,v 1.14 2016/08/27 02:06:40 guenther Exp $	*/
/*	$NetBSD: expl.c,v 1.2 1997/10/10 16:33:18 lukem Exp $	*/
/*
 * Copyright (c) 1983-2003, Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * + Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * + Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 * + Neither the name of the University of California, San Francisco nor
 *   the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written
 *   permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/select.h>
#include <stdlib.h>
#include <syslog.h>
#include <string.h>

#include "conf.h"
#include "hunt.h"
#include "server.h"

static	void	remove_wall(int, int);
static	void	init_removed(void);


/*
 * showexpl:
 *	Show the explosions as they currently are
 */
void
showexpl(int y, int x, char type)
{
	PLAYER	*pp;
	EXPL	*ep;

	if (y < 0 || y >= HEIGHT)
		return;
	if (x < 0 || x >= WIDTH)
		return;
	ep = malloc(sizeof (EXPL));
	if (ep == NULL) {
		logit(LOG_ERR, "malloc");
		return;
	}
	ep->e_y = y;
	ep->e_x = x;
	ep->e_char = type;
	ep->e_next = NULL;
	if (Last_expl == NULL)
		Expl[0] = ep;
	else
		Last_expl->e_next = ep;
	Last_expl = ep;
	for (pp = Player; pp < End_player; pp++) {
		if (pp->p_maze[y][x] == type)
			continue;
		pp->p_maze[y][x] = type;
		cgoto(pp, y, x);
		outch(pp, type);
	}
	for (pp = Monitor; pp < End_monitor; pp++) {
		if (pp->p_maze[y][x] == type)
			continue;
		pp->p_maze[y][x] = type;
		cgoto(pp, y, x);
		outch(pp, type);
	}
	switch (Maze[y][x]) {
	  case WALL1:
	  case WALL2:
	  case WALL3:
	  case DOOR:
	  case WALL4:
	  case WALL5:
		if (y >= UBOUND && y < DBOUND && x >= LBOUND && x < RBOUND)
			remove_wall(y, x);
		break;
	}
}

/*
 * rollexpl:
 *	Roll the explosions over, so the next one in the list is at the
 *	top
 */
void
rollexpl(void)
{
	EXPL	*ep;
	PLAYER	*pp;
	int	y, x;
	char	c;
	EXPL	*nextep;

	for (ep = Expl[EXPLEN - 1]; ep != NULL; ep = nextep) {
		nextep = ep->e_next;
		y = ep->e_y;
		x = ep->e_x;
		if (y < UBOUND || y >= DBOUND || x < LBOUND || x >= RBOUND)
			c = Maze[y][x];
		else
			c = SPACE;
		for (pp = Player; pp < End_player; pp++)
			if (pp->p_maze[y][x] == ep->e_char) {
				pp->p_maze[y][x] = c;
				cgoto(pp, y, x);
				outch(pp, c);
			}
		for (pp = Monitor; pp < End_monitor; pp++)
			check(pp, y, x);
		free((char *) ep);
	}
	memmove(&Expl[1], &Expl[0], (EXPLEN - 1) * sizeof Expl[0]);
	/* for (x = EXPLEN - 1; x > 0; x--)
		Expl[x] = Expl[x - 1]; */
	Last_expl = Expl[0] = NULL;
}

int
can_rollexpl(void)
{
	int i;

	for (i = EXPLEN - 1; i >= 0; i--)
		if (Expl[i] != NULL)
			return 1;
	return 0;
}

static	REGEN	*removed = NULL;
static	REGEN	*rem_index = NULL;

static void
init_removed(void)
{
	rem_index = removed = calloc(conf_maxremove, sizeof(REGEN));
	if (rem_index == NULL) {
		logit(LOG_ERR, "malloc");
		cleanup(1);
	}
}

/*
 * remove_wall - add a location where the wall was blown away.
 *		 if there is no space left over, put the a wall at
 *		 the location currently pointed at.
 */
static void
remove_wall(int y, int x)
{
	REGEN	*r;
	PLAYER	*pp;
	char	save_char = 0;

	if (removed == NULL)
		clearwalls();

	r = rem_index;
	while (r->r_y != 0) {
		switch (Maze[r->r_y][r->r_x]) {
		  case SPACE:
		  case LEFTS:
		  case RIGHT:
		  case ABOVE:
		  case BELOW:
		  case FLYER:
			save_char = Maze[r->r_y][r->r_x];
			goto found;
		}
		if (++r >= removed + conf_maxremove)
			r = removed;
	}

found:
	if (r->r_y != 0) {
		/* Slot being used, put back this wall */
		if (save_char == SPACE)
			Maze[r->r_y][r->r_x] = Orig_maze[r->r_y][r->r_x];
		else {
			/* We throw the player off the wall: */
			pp = play_at(r->r_y, r->r_x);
			if (pp->p_flying >= 0)
				pp->p_flying += rand_num(conf_flytime / 2);
			else {
				pp->p_flying = rand_num(conf_flytime);
				pp->p_flyx = 2 * rand_num(conf_flystep + 1) -
				    conf_flystep;
				pp->p_flyy = 2 * rand_num(conf_flystep + 1) -
				    conf_flystep;
			}
			pp->p_over = Orig_maze[r->r_y][r->r_x];
			pp->p_face = FLYER;
			Maze[r->r_y][r->r_x] = FLYER;
			showexpl(r->r_y, r->r_x, FLYER);
		}
		Maze[r->r_y][r->r_x] = Orig_maze[r->r_y][r->r_x];
		if (conf_random && rand_num(100) < conf_prandom)
			Maze[r->r_y][r->r_x] = DOOR;
		if (conf_reflect && rand_num(100) == conf_preflect)
			Maze[r->r_y][r->r_x] = WALL4;
		for (pp = Monitor; pp < End_monitor; pp++)
			check(pp, r->r_y, r->r_x);
	}

	r->r_y = y;
	r->r_x = x;
	if (++r >= removed + conf_maxremove)
		rem_index = removed;
	else
		rem_index = r;

	Maze[y][x] = SPACE;
	for (pp = Monitor; pp < End_monitor; pp++)
		check(pp, y, x);
}

/*
 * clearwalls:
 *	Clear out the walls array
 */
void
clearwalls(void)
{
	REGEN	*rp;

	if (removed == NULL)
		init_removed();
	for (rp = removed; rp < removed + conf_maxremove; rp++)
		rp->r_y = 0;
	rem_index = removed;
}
@


1.14
log
@Pull in <sys/select.h> for fd_set

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expl.c,v 1.13 2016/01/07 21:37:53 mestre Exp $	*/
d6 3
a8 3
 * 
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are 
d10 2
a11 2
 * 
 * + Redistributions of source code must retain the above copyright 
d13 2
a14 2
 * + Redistributions in binary form must reproduce the above copyright 
 *   notice, this list of conditions and the following disclaimer in the 
d16 3
a18 3
 * + Neither the name of the University of California, San Francisco nor 
 *   the names of its contributors may be used to endorse or promote 
 *   products derived from this software without specific prior written 
d20 11
a30 11
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS 
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED 
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
@


1.13
log
@ANSIfy hunt(6)

Note: casted 2 args to struct sockaddr * on list.c to shut off compiler
warnings, and also changed an int len to socklen_t since recvfrom(2) receives
the last argument as the latter.

I'm running out of credits, but this was once again with great help and OK from
tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expl.c,v 1.12 2016/01/07 21:29:31 mestre Exp $	*/
d34 1
@


1.12
log
@Headers cleanup and sorting

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expl.c,v 1.11 2015/09/27 07:06:41 guenther Exp $	*/
d51 1
a51 3
showexpl(y, x, type)
	int	y, x;
	char	type;
d107 1
a107 1
rollexpl()
d140 1
a140 1
can_rollexpl()
d154 1
a154 1
init_removed()
d169 1
a169 2
remove_wall(y, x)
	int	y, x;
d242 1
a242 1
clearwalls()
@


1.11
log
@Delete pointless NOSTRICT comments
@
text
@d1 1
a1 1
/*	$OpenBSD: expl.c,v 1.10 2015/08/22 14:47:41 deraadt Exp $	*/
d37 2
a40 1
#include "conf.h"
@


1.10
log
@remove malloc/calloc/realloc* casts, due to stdlib.h being present; ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: expl.c,v 1.9 2007/09/04 22:39:31 hshoexer Exp $	*/
d61 1
a61 1
	ep = malloc(sizeof (EXPL));	/* NOSTRICT */
@


1.9
log
@Some more simple malloc(n * m) -> calloc(n, m) conversions.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expl.c,v 1.8 2004/01/16 00:13:19 espie Exp $	*/
d61 1
a61 1
	ep = (EXPL *) malloc(sizeof (EXPL));	/* NOSTRICT */
@


1.8
log
@ISO C police: log and expl are reserved for the C library.
expl -> expl_string
log -> logit
@
text
@d1 1
a1 1
/*	$OpenBSD: expl.c,v 1.7 2003/06/11 08:45:33 pjanzen Exp $	*/
d157 1
a157 1
	rem_index = removed = malloc(conf_maxremove * sizeof(REGEN));
@


1.7
log
@New license from the official hunt release at
ftp://ftp.cgl.ucsf.edu/pub/hunt.shar.Z -- it has been approved by all three
authors (Conrad Huang, Ken Arnold, and Greg Couch).
@
text
@d1 1
a1 1
/*	$OpenBSD: expl.c,v 1.6 2002/02/16 21:27:10 millert Exp $	*/
d63 1
a63 1
		log(LOG_ERR, "malloc");
d159 1
a159 1
		log(LOG_ERR, "malloc");
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: expl.c,v 1.5 1999/08/30 23:30:08 d Exp $	*/
d4 28
a31 3
 *  Hunt
 *  Copyright (c) 1985 Conrad C. Huang, Gregory S. Couch, Kenneth C.R.C. Arnold
 *  San Francisco, California
@


1.5
log
@check malloc return
@
text
@d1 1
a1 1
/*	$OpenBSD: expl.c,v 1.4 1999/02/01 06:53:56 d Exp $	*/
d16 2
a17 2
static	void	remove_wall __P((int, int));
static	void	init_removed __P((void));
@


1.4
log
@avoid denial of service attacks on server port; extra conf vars; fix otto
@
text
@d1 1
a1 1
/*	$OpenBSD: expl.c,v 1.3 1999/01/29 07:30:35 d Exp $	*/
d37 4
@


1.3
log
@major changes: security, curses, config
@
text
@d1 1
a1 1
/*	$OpenBSD: expl.c,v 1.2 1999/01/21 05:47:41 d Exp $	*/
d11 1
d105 3
a107 2
	for (x = EXPLEN - 1; x > 0; x--)
		Expl[x] = Expl[x - 1];
d111 11
d130 1
a130 1
		syslog(LOG_ERR, "malloc: %m");
d149 1
a149 1
		init_removed();
@


1.2
log
@ident for OpenBSD
mandoc-ify manual pages
use -locurses
@
text
@d1 1
a2 1
/*	$OpenBSD$	*/
d9 5
a13 2
# include	<stdlib.h>
# include	"hunt.h"
d16 1
a51 1
# ifdef MONITOR
a58 1
# endif
a62 1
# ifdef RANDOM
a63 2
# endif
# ifdef REFLECT
a65 1
# endif
a99 1
# ifdef MONITOR
a101 1
# endif
d109 2
a110 3
/* There's about 700 walls in the initial maze.  So we pick a number
 * that keeps the maze relatively full. */
# define MAXREMOVE	40
d112 9
a120 2
static	REGEN	removed[MAXREMOVE];
static	REGEN	*rem_index = removed;
a131 1
# if defined(MONITOR) || defined(FLY)
a132 2
# endif
# ifdef	FLY
d134 3
a136 1
# endif
a139 1
# ifdef FLY
d150 1
a150 5
# else
		if (Maze[r->r_y][r->r_x] == SPACE)
			break;
# endif
		if (++r >= &removed[MAXREMOVE])
a156 1
# ifdef FLY
d160 1
d163 1
a163 1
				pp->p_flying += rand_num(10);
d165 5
a169 3
				pp->p_flying = rand_num(20);
				pp->p_flyx = 2 * rand_num(6) - 5;
				pp->p_flyy = 2 * rand_num(6) - 5;
a175 1
# else
d177 1
a177 3
# endif
# ifdef RANDOM
		if (rand_num(100) == 0)
d179 1
a179 3
# endif
# ifdef REFLECT
		if (rand_num(100) == 0)		/* one percent of the time */
a180 2
# endif
# ifdef MONITOR
a182 1
# endif
d187 1
a187 1
	if (++r >= &removed[MAXREMOVE])
a192 1
# ifdef MONITOR
a194 1
# endif
d206 3
a208 1
	for (rp = removed; rp < &removed[MAXREMOVE]; rp++)
@


1.1
log
@Initial revision
@
text
@d2 1
a7 5

#include <sys/cdefs.h>
#ifndef lint
__RCSID("$NetBSD: expl.c,v 1.2 1997/10/10 16:33:18 lukem Exp $");
#endif /* not lint */
@


1.1.1.1
log
@hunt (from NetBSD)
@
text
@@
