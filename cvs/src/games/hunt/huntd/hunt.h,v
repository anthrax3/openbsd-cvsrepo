head	1.6;
access;
symbols
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.5.0.54
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.50
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.52
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.44
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.48
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.46
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.42
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.40
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.38
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.36
	OPENBSD_5_0:1.5.0.34
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.32
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.30
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.26
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.28
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.24
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.22
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.20
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.18
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.16
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.14
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.4.0.8
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.3.0.10
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.8
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.6
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	initial:1.1.1.1
	hunt:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2017.01.21.08.22.57;	author krw;	state Exp;
branches;
next	1.5;
commitid	slqvWeiHNc6j5Mv6;

1.5
date	2003.06.11.08.45.33;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.19.15.19.45;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	99.01.29.07.30.36;	author d;	state Exp;
branches;
next	1.2;

1.2
date	99.01.21.05.47.41;	author d;	state Exp;
branches;
next	1.1;

1.1
date	99.01.21.05.33.38;	author d;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.01.21.05.33.38;	author d;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@/*	$OpenBSD: hunt.h,v 1.5 2003/06/11 08:45:33 pjanzen Exp $	*/
/*	$NetBSD: hunt.h,v 1.5 1998/09/13 15:27:28 hubertf Exp $	*/

/*
 * Copyright (c) 1983-2003, Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * + Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * + Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 * + Neither the name of the University of California, San Francisco nor
 *   the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written
 *   permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Preprocessor define dependencies
 */

/* decrement version number for each change in startup protocol */
# define	HUNT_VERSION		(-1)
# define	HUNT_PORT		(('h' << 8) | 't')

# define	ADDCH		('a' | 0200)
# define	MOVE		('m' | 0200)
# define	REFRESH		('r' | 0200)
# define	CLRTOEOL	('c' | 0200)
# define	ENDWIN		('e' | 0200)
# define	CLEAR		('C' | 0200)
# define	REDRAW		('R' | 0200)
# define	LAST_PLAYER	('l' | 0200)
# define	BELL		('b' | 0200)
# define	READY		('g' | 0200)

# define	SCREEN_HEIGHT	24
# define	SCREEN_WIDTH	80
# define	HEIGHT	23
# define	WIDTH	51
# define	SCREEN_WIDTH2	128	/* Next power of 2 >= SCREEN_WIDTH */
# define	WIDTH2	64	/* Next power of 2 >= WIDTH (for fast access) */

# define	NAMELEN		20

# define	Q_QUIT		0
# define	Q_CLOAK		1
# define	Q_FLY		2
# define	Q_SCAN		3
# define	Q_MESSAGE	4

# define	C_PLAYER	0
# define	C_MONITOR	1
# define	C_MESSAGE	2
# define	C_SCORES	3
# define	C_TESTMSG()	(Query_driver ? C_MESSAGE :\
				(Show_scores ? C_SCORES :\
				(Am_monitor ? C_MONITOR :\
				C_PLAYER)))

typedef int			FLAG;

/* Objects within the maze: */

# define	DOOR	'#'
# define	WALL1	'-'
# define	WALL2	'|'
# define	WALL3	'+'
# define	WALL4	'/'
# define	WALL5	'\\'
# define	KNIFE	'K'
# define	SHOT	':'
# define	GRENADE	'o'
# define	SATCHEL	'O'
# define	BOMB	'@@'
# define	MINE	';'
# define	GMINE	'g'
# define	SLIME	'$'
# define	LAVA	'~'
# define	DSHOT	'?'
# define	FALL	'F'
# define	BOOT		'b'
# define	BOOT_PAIR	'B'

# define	SPACE	' '

# define	ABOVE	'i'
# define	BELOW	'!'
# define	RIGHT	'}'
# define	LEFTS	'{'
# define	FLYER	'&'
# define	is_player(c)	(c == LEFTS || c == RIGHT ||\
				c == ABOVE || c == BELOW || c == FLYER)

# ifndef TRUE
# define	TRUE	1
# define	FALSE	0
# endif

@


1.5
log
@New license from the official hunt release at
ftp://ftp.cgl.ucsf.edu/pub/hunt.shar.Z -- it has been approved by all three
authors (Conrad Huang, Ken Arnold, and Greg Couch).
@
text
@d1 1
a1 1
/*	$OpenBSD: hunt.h,v 1.4 2001/09/19 15:19:45 pjanzen Exp $	*/
d7 3
a9 3
 * 
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are 
d11 2
a12 2
 * 
 * + Redistributions of source code must retain the above copyright 
d14 2
a15 2
 * + Redistributions in binary form must reproduce the above copyright 
 *   notice, this list of conditions and the following disclaimer in the 
d17 3
a19 3
 * + Neither the name of the University of California, San Francisco nor 
 *   the names of its contributors may be used to endorse or promote 
 *   products derived from this software without specific prior written 
d21 11
a31 11
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS 
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED 
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
@


1.4
log
@isplayer -> is_player gets out of <ctype.h> namespace; jsm28@@cam.ac.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: hunt.h,v 1.3 1999/01/29 07:30:36 d Exp $	*/
d5 28
a32 3
 *  Hunt
 *  Copyright (c) 1985 Conrad C. Huang, Gregory S. Couch, Kenneth C.R.C. Arnold
 *  San Francisco, California
@


1.3
log
@major changes: security, curses, config
@
text
@d1 1
a1 1
/*	$OpenBSD: hunt.h,v 1.2 1999/01/21 05:47:41 d Exp $	*/
d84 1
a84 1
# define	isplayer(c)	(c == LEFTS || c == RIGHT ||\
@


1.2
log
@ident for OpenBSD
mandoc-ify manual pages
use -locurses
@
text
@d1 1
a2 1
/*	$OpenBSD$	*/
a9 33
# include "bsd.h"

# include	<stdio.h>
# include	<string.h>
# ifdef LOG
# include	<syslog.h>
# endif
# if !defined(TERMINFO) && BSD_RELEASE < 44
# include	<sgtty.h>
# else
# include	<sys/ioctl.h>
# endif
# include	<sys/types.h>
# include	<sys/uio.h>
# include	<sys/socket.h>
# ifdef	INTERNET
# include	<netinet/in.h>
# include	<netdb.h>
# include	<arpa/inet.h>
# ifdef BROADCAST
# include	<net/if.h>
# endif
# else
# include	<sys/un.h>
# endif

# ifdef	INTERNET
# define	SOCK_FAMILY	AF_INET
# else
# define	SOCK_FAMILY	AF_UNIX
# define	AF_UNIX_HACK		/* 4.2 hack; leaves files around */
# endif

a12 14
# if defined(VOLCANO) && !defined(OOZE)
# define OOZE
# endif
# if defined(BOOTS) && !defined(FLY)
# define FLY
# endif
# if !defined(REFLECT) && !defined(RANDOM)
# define RANDOM
# endif
# ifdef TERMINFO
/* mvcur() in terminfo needs the curses library to be initialized to not
 * coredump, so give up and use it. */
# define USE_CURSES
# endif
d15 2
a16 1
# define	HUNT_VERSION		-1
d29 7
a35 13
/*
 * Choose MAXPL and MAXMON carefully.  The screen is assumed to be
 * 23 lines high and will only tolerate (MAXPL == 17 && MAXMON == 0)
 * or (MAXPL + MAXMON <= 16).
 */
# ifdef MONITOR
# define	MAXPL		15
# define	MAXMON		1
# else
# define	MAXPL		17
# endif
# define	SHORTLEN	2		/* sizeof (network short) */
# define	LONGLEN		4		/* sizeof (network long) */
a36 2
# define	MSGLEN		SCREEN_WIDTH
# define	DECAY		50.0
d38 5
a42 1
# define	NASCII		128
d44 8
a51 7
# define	WIDTH	51
# define	WIDTH2	64	/* Next power of 2 >= WIDTH (for fast access) */
# define	HEIGHT	23
# define	UBOUND	1
# define	DBOUND	(HEIGHT - 1)
# define	LBOUND	1
# define	RBOUND	(WIDTH - 1)
d53 1
a53 3
# define	SCREEN_HEIGHT	24
# define	SCREEN_WIDTH	80
# define	SCREEN_WIDTH2	128	/* Next power of 2 >= SCREEN_WIDTH */
d55 1
a55 13
# define	STAT_LABEL_COL	60
# define	STAT_VALUE_COL	74
# define	STAT_NAME_COL	61
# define	STAT_SCAN_COL	(STAT_NAME_COL + 5)
# define	STAT_AMMO_ROW	0
# define	STAT_GUN_ROW	1
# define	STAT_DAM_ROW	2
# define	STAT_KILL_ROW	3
# define	STAT_PLAY_ROW	5
# ifdef MONITOR
# define	STAT_MON_ROW	(STAT_PLAY_ROW + MAXPL + 1)
# endif
# define	STAT_NAME_LEN	18
a60 1
# ifdef REFLECT
a62 1
# endif
a69 1
# ifdef	OOZE
a70 2
# endif
# ifdef	VOLCANO
a71 2
# endif
# ifdef DRONE
a72 2
# endif
# ifdef FLY
a73 3
# endif
# ifdef BOOTS
# define	NBOOTS		2
d76 1
a76 1
# endif
a82 1
# ifdef FLY
a85 9
# else
# define	isplayer(c)	(c == LEFTS || c == RIGHT ||\
				c == ABOVE || c == BELOW)
# endif

# define	NORTH	01
# define	SOUTH	02
# define	EAST	010
# define	WEST	020
a90 216
# undef CTRL
# define	CTRL(x)	((x) & 037)

# define	BULSPD		5		/* bullets movement speed */
# define	ISHOTS		15
# define	NSHOTS		5
# define	MAXNCSHOT	2
# define	MAXDAM		10
# define	MINDAM		5
# define	STABDAM		2

# define	BULREQ		1
# define	GRENREQ		9
# define	SATREQ		25
# define	BOMB7REQ	49
# define	BOMB9REQ	81
# define	BOMB11REQ	121
# define	BOMB13REQ	169
# define	BOMB15REQ	225
# define	BOMB17REQ	289
# define	BOMB19REQ	361
# define	BOMB21REQ	441
# define	MAXBOMB		11
# ifdef DRONE
# define	MINDSHOT	2	/* At least a satchel bomb */
# endif
extern int	shot_req[];
extern int	shot_type[];
# ifdef	OOZE
# define	SLIME_FACTOR	3
# define	SLIMEREQ	5
# define	SSLIMEREQ	10
# define	SLIME2REQ	15
# define	SLIME3REQ	20
# define	MAXSLIME	4
# define	SLIMESPEED	5
extern int	slime_req[];
# endif
# ifdef	VOLCANO
# define	LAVASPEED	1
# endif

# define	CLOAKLEN	20
# define	SCANLEN		(Nplayer * 20)
# define	EXPLEN		4

# define	Q_QUIT		0
# define	Q_CLOAK		1
# define	Q_FLY		2
# define	Q_SCAN		3
# define	Q_MESSAGE	4

# define	C_PLAYER	0
# define	C_MONITOR	1
# define	C_MESSAGE	2
# define	C_SCORES	3

# ifdef MONITOR
# define	C_TESTMSG()	(Query_driver ? C_MESSAGE :\
				(Show_scores ? C_SCORES :\
				(Am_monitor ? C_MONITOR :\
				C_PLAYER)))
# else
# define	C_TESTMSG()	(Show_scores ? C_SCORES :\
				(Query_driver ? C_MESSAGE :\
				C_PLAYER))
# endif

# ifdef FLY
# define	_scan_char(pp)	(((pp)->p_scan < 0) ? ' ' : '*')
# define	_cloak_char(pp)	(((pp)->p_cloak < 0) ? _scan_char(pp) : '+')
# define	stat_char(pp)	(((pp)->p_flying < 0) ? _cloak_char(pp) : FLYER)
# else
# define	_scan_char(pp)	(((pp)->p_scan < 0) ? ' ' : '*')
# define	stat_char(pp)	(((pp)->p_cloak < 0) ? _scan_char(pp) : '+')
# endif

typedef int			FLAG;
typedef struct bullet_def	BULLET;
typedef struct expl_def		EXPL;
typedef struct player_def	PLAYER;
typedef struct ident_def	IDENT;
typedef struct regen_def	REGEN;
# ifdef	INTERNET
typedef struct sockaddr_in	SOCKET;
# else
typedef struct sockaddr_un	SOCKET;
# endif

struct ident_def {
	char	i_name[NAMELEN];
	char	i_team;
	long	i_machine;
	long	i_uid;
	float	i_kills;
	int	i_entries;
	float	i_score;
	int	i_absorbed;
	int	i_faced;
	int	i_shot;
	int	i_robbed;
	int	i_slime;
	int	i_missed;
	int	i_ducked;
	int	i_gkills, i_bkills, i_deaths, i_stillb, i_saved;
	IDENT	*i_next;
};

struct player_def {
	IDENT	*p_ident;
	char	p_over;
	int	p_face;
	int	p_undershot;
# ifdef	FLY
	int	p_flying;
	int	p_flyx, p_flyy;
# endif
# ifdef	BOOTS
	int	p_nboots;
# endif
	FILE	*p_output;
	int	p_fd;
	int	p_mask;
	int	p_damage;
	int	p_damcap;
	int	p_ammo;
	int	p_ncshot;
	int	p_scan;
	int	p_cloak;
	int	p_x, p_y;
	int	p_ncount;
	int	p_nexec;
	long	p_nchar;
	char	p_death[MSGLEN];
	char	p_maze[HEIGHT][WIDTH2];
	int	p_curx, p_cury;
	int	p_lastx, p_lasty;
	char	p_cbuf[BUFSIZ];
};

struct bullet_def {
	int	b_x, b_y;
	int	b_face;
	int	b_charge;
	char	b_type;
	char	b_size;
	char	b_over;
	PLAYER	*b_owner;
	IDENT	*b_score;
	FLAG	b_expl;
	BULLET	*b_next;
};

struct expl_def {
	int	e_x, e_y;
	char	e_char;
	EXPL	*e_next;
};

struct regen_def {
	int	r_x, r_y;
	REGEN	*r_next;
};

/*
 * external variables
 */

extern FLAG	Last_player;

extern char	Buf[BUFSIZ], Maze[HEIGHT][WIDTH2], Orig_maze[HEIGHT][WIDTH2];

extern char	*Sock_name, *Driver;

extern int	errno, Nplayer, Num_fds, Socket, Status;
extern fd_set	Fds_mask, Have_inp;

# ifdef INTERNET
extern u_short	Test_port;
# else
extern char	*Sock_name;
# endif

# ifdef VOLCANO
extern int	volcano;
# endif

extern int	See_over[NASCII];

extern BULLET	*Bullets;

extern EXPL	*Expl[EXPLEN];
extern EXPL	*Last_expl;

extern IDENT	*Scores;

extern PLAYER	Player[MAXPL], *End_player;
# ifdef BOOTS
extern PLAYER	Boot[NBOOTS];
# endif

# ifdef MONITOR
extern FLAG	Am_monitor;
extern PLAYER	Monitor[MAXMON], *End_monitor;
# endif

# ifdef INTERNET
extern char	*Send_message;
# endif

extern char	map_key[256];
extern FLAG	no_beep;

/*
 * function types
 */
a91 63
void		add_shot __P((int, int, int, char, int, PLAYER *, int, char));
int		answer __P((void));
void		bad_con __P((void));
void		bad_ver __P((void));
int		broadcast_vec __P((int, struct	sockaddr **));
void		ce __P((PLAYER *));
void		cgoto __P((PLAYER *, int, int));
void		check __P((PLAYER *, int, int));
void		checkdam __P((PLAYER *, PLAYER *, IDENT *, int, char));
void		clearwalls __P((void));
void		clear_eol __P((void));
void		clear_the_screen __P((void));
void		clrscr __P((PLAYER *));
BULLET	       *create_shot __P((int, int, int, char, int, int, PLAYER *,
		    IDENT *, int, char));
void		do_connect __P((char *, char, long));
void		do_message __P((void));
void		drawmaze __P((PLAYER *));
void		drawplayer __P((PLAYER *, FLAG));
void		drawstatus __P((PLAYER *));
void		execute __P((PLAYER *));
void		faketalk __P((void));
void		find_driver __P((FLAG));
void		fixshots __P((int, int, char));
IDENT	       *get_ident __P((u_long, u_long, char *, char));
void		get_local_name __P((char *));
int		get_remote_name __P((char *));
BULLET	       *is_bullet __P((int, int));
void		look __P((PLAYER *));
void		makemaze __P((void));
void		message __P((PLAYER *, char *));
void		mon_execute __P((PLAYER *));
void		moveshots __P((void));
void		open_ctl __P((void));
int		opposite __P((int, char));
void		otto __P((int, int, char));
void		outch __P((PLAYER *, int));
void		outstr __P((PLAYER *, char *, int));
int		player_sym __P((PLAYER *, int, int));
PLAYER	       *play_at __P((int, int));
void		playit __P((void));
void		put_ch __P((char));
void		put_str __P((char *));
int		quit __P((int));
int		rand_dir __P((void));
int		rand_num __P((int));
void		redraw_screen __P((void));
void		rmnl __P((char *));
void		rollexpl __P((void));
void		see __P((PLAYER *, int));
void		sendcom __P((PLAYER *, int, ...));
void		showexpl __P((int, int, char));
void		showstat __P((PLAYER *));
void		start_driver __P((void));
void		stmonitor __P((PLAYER *));
void		stplayer __P((PLAYER *, int));
char		translate __P((char));
SIGNAL_TYPE	cleanup __P((int)) __attribute__((__noreturn__));
SIGNAL_TYPE	intr __P((int));
SIGNAL_TYPE	sigalrm __P((int));
SIGNAL_TYPE	sigemt __P((int));
SIGNAL_TYPE	sigterm __P((int));
SIGNAL_TYPE	tstp __P((int));
@


1.1
log
@Initial revision
@
text
@d2 1
@


1.1.1.1
log
@hunt (from NetBSD)
@
text
@@
