head	1.14;
access;
symbols
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.12.0.4
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.8.0.50
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.42
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.46
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.44
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.40
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.38
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.36
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.34
	OPENBSD_5_0:1.8.0.32
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.30
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.28
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.24
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.26
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.22
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.20
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.18
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.16
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.14
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.12
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.10
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.8
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.10
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.8
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.6
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	initial:1.1.1.1
	hunt:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2017.01.21.08.22.57;	author krw;	state Exp;
branches;
next	1.13;
commitid	slqvWeiHNc6j5Mv6;

1.13
date	2016.08.27.02.06.40;	author guenther;	state Exp;
branches;
next	1.12;
commitid	HajZYsKX8810aMqL;

1.12
date	2016.01.07.21.37.53;	author mestre;	state Exp;
branches;
next	1.11;
commitid	OXn0Z5fMODgNmJpo;

1.11
date	2016.01.07.21.29.31;	author mestre;	state Exp;
branches;
next	1.10;
commitid	AgYVDd64zIiNi3fx;

1.10
date	2015.09.27.07.06.41;	author guenther;	state Exp;
branches;
next	1.9;
commitid	iQfwdqs7w9ue7P08;

1.9
date	2015.08.22.14.47.41;	author deraadt;	state Exp;
branches;
next	1.8;
commitid	vWCbqNWL9DL2UkGT;

1.8
date	2004.01.16.00.13.19;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.11.08.45.33;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.10;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.08.30.23.29.46;	author d;	state Exp;
branches;
next	1.4;

1.4
date	99.02.01.06.53.56;	author d;	state Exp;
branches;
next	1.3;

1.3
date	99.01.29.07.30.35;	author d;	state Exp;
branches;
next	1.2;

1.2
date	99.01.21.05.47.40;	author d;	state Exp;
branches;
next	1.1;

1.1
date	99.01.21.05.33.38;	author d;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.01.21.05.33.38;	author d;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@/*	$OpenBSD: execute.c,v 1.13 2016/08/27 02:06:40 guenther Exp $	*/
/*	$NetBSD: execute.c,v 1.2 1997/10/10 16:33:13 lukem Exp $	*/
/*
 * Copyright (c) 1983-2003, Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * + Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * + Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 * + Neither the name of the University of California, San Francisco nor
 *   the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written
 *   permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/select.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>

#include "conf.h"
#include "hunt.h"
#include "server.h"

static void	cloak(PLAYER *);
static void	face(PLAYER *, int);
static void	fire(PLAYER *, int);
static void	fire_slime(PLAYER *, int);
static void	move_player(PLAYER *, int);
static void	pickup(PLAYER *, int, int, int, int);
static void	scan(PLAYER *);


/*
 * mon_execute:
 *	Execute a single monitor command
 */
void
mon_execute(PLAYER *pp)
{
	char	ch;

	ch = pp->p_cbuf[pp->p_ncount++];

	switch (ch) {
	  case CTRL('L'):
		/* Redraw messed-up screen */
		sendcom(pp, REDRAW);
		break;
	  case 'q':
		/* Quit client */
		(void) strlcpy(pp->p_death, "| Quit |", sizeof pp->p_death);
		break;
	  default:
		/* Ignore everything else */
		;
	}
}

/*
 * execute:
 *	Execute a single command from a player
 */
void
execute(PLAYER *pp)
{
	char	ch;

	ch = pp->p_cbuf[pp->p_ncount++];

	/* When flying, only allow refresh and quit. */
	if (pp->p_flying >= 0) {
		switch (ch) {
		  case CTRL('L'):
			sendcom(pp, REDRAW);
			break;
		  case 'q':
			(void) strlcpy(pp->p_death, "| Quit |",
			    sizeof pp->p_death);
			break;
		}
		return;
	}

	/* Decode the command character: */
	switch (ch) {
	  case CTRL('L'):
		sendcom(pp, REDRAW);	/* Refresh */
		break;
	  case 'h':
		move_player(pp, LEFTS); /* Move left */
		break;
	  case 'H':
		face(pp, LEFTS);	/* Face left */
		break;
	  case 'j':
		move_player(pp, BELOW); /* Move down */
		break;
	  case 'J':
		face(pp, BELOW);	/* Face down */
		break;
	  case 'k':
		move_player(pp, ABOVE); /* Move up */
		break;
	  case 'K':
		face(pp, ABOVE);	/* Face up */
		break;
	  case 'l':
		move_player(pp, RIGHT);	/* Move right */
		break;
	  case 'L':
		face(pp, RIGHT);	/* Face right */
		break;
	  case 'f':
	  case '1':
		fire(pp, 0);		/* SHOT */
		break;
	  case 'g':
	  case '2':
		fire(pp, 1);		/* GRENADE */
		break;
	  case 'F':
	  case '3':
		fire(pp, 2);		/* SATCHEL */
		break;
	  case 'G':
	  case '4':
		fire(pp, 3);		/* 7x7 BOMB */
		break;
	  case '5':
		fire(pp, 4);		/* 9x9 BOMB */
		break;
	  case '6':
		fire(pp, 5);		/* 11x11 BOMB */
		break;
	  case '7':
		fire(pp, 6);		/* 13x13 BOMB */
		break;
	  case '8':
		fire(pp, 7);		/* 15x15 BOMB */
		break;
	  case '9':
		fire(pp, 8);		/* 17x17 BOMB */
		break;
	  case '0':
		fire(pp, 9);		/* 19x19 BOMB */
		break;
	  case '@@':
		fire(pp, 10);		/* 21x21 BOMB */
		break;
	  case 'o':
		fire_slime(pp, 0);	/* SLIME */
		break;
	  case 'O':
		fire_slime(pp, 1);	/* SSLIME */
		break;
	  case 'p':
		fire_slime(pp, 2);	/* large slime */
		break;
	  case 'P':
		fire_slime(pp, 3);	/* very large slime */
		break;
	  case 's':			/* start scanning */
		scan(pp);
		break;
	  case 'c':			/* start cloaking */
		cloak(pp);
		break;
	  case 'q':			/* quit */
		(void) strlcpy(pp->p_death, "| Quit |", sizeof pp->p_death);
		break;
	}
}

/*
 * move_player:
 *	Try to move player 'pp' in direction 'dir'.
 */
static void
move_player(PLAYER *pp, int dir)
{
	PLAYER	*newp;
	int	x, y;
	FLAG	moved;
	BULLET	*bp;

	y = pp->p_y;
	x = pp->p_x;

	switch (dir) {
	  case LEFTS:
		x--;
		break;
	  case RIGHT:
		x++;
		break;
	  case ABOVE:
		y--;
		break;
	  case BELOW:
		y++;
		break;
	}

	moved = FALSE;

	/* What would the player move over: */
	switch (Maze[y][x]) {
	  /* Players can move through spaces and doors, no problem: */
	  case SPACE:
	  case DOOR:
		moved = TRUE;
		break;
	  /* Can't move through walls: */
	  case WALL1:
	  case WALL2:
	  case WALL3:
	  case WALL4:
	  case WALL5:
		break;
	  /* Moving over a mine - try to pick it up: */
	  case MINE:
	  case GMINE:
		if (dir == pp->p_face)
			/* facing it: 2% chance of trip */
			pickup(pp, y, x, conf_ptrip_face, Maze[y][x]);
		else if (opposite(dir, pp->p_face))
			/* facing away: 95% chance of trip */
			pickup(pp, y, x, conf_ptrip_back, Maze[y][x]);
		else
			/* facing sideways: 50% chance of trip */
			pickup(pp, y, x, conf_ptrip_side, Maze[y][x]);
		/* Remove the mine: */
		Maze[y][x] = SPACE;
		moved = TRUE;
		break;
	  /* Moving into a bullet: */
	  case SHOT:
	  case GRENADE:
	  case SATCHEL:
	  case BOMB:
	  case SLIME:
	  case DSHOT:
		/* Find which bullet: */
		bp = is_bullet(y, x);
		if (bp != NULL)
			/* Detonate it: */
			bp->b_expl = TRUE;
		/* Remove it: */
		Maze[y][x] = SPACE;
		moved = TRUE;
		break;
	  /* Moving into another player: */
	  case LEFTS:
	  case RIGHT:
	  case ABOVE:
	  case BELOW:
		if (dir != pp->p_face)
			/* Can't walk backwards/sideways into another player: */
			sendcom(pp, BELL);
		else {
			/* Stab the other player */
			newp = play_at(y, x);
			checkdam(newp, pp, pp->p_ident, conf_stabdam, KNIFE);
		}
		break;
	  /* Moving into a player flying overhead: */
	  case FLYER:
		newp = play_at(y, x);
		message(newp, "Oooh, there's a short guy waving at you!");
		message(pp, "You couldn't quite reach him!");
		break;
	  /* Picking up a boot, or two: */
	  case BOOT_PAIR:
		pp->p_nboots++;
	  case BOOT:
		pp->p_nboots++;
		for (newp = Boot; newp < &Boot[NBOOTS]; newp++) {
			if (newp->p_flying < 0)
				continue;
			if (newp->p_y == y && newp->p_x == x) {
				newp->p_flying = -1;
				if (newp->p_undershot)
					fixshots(y, x, newp->p_over);
			}
		}
		if (pp->p_nboots == 2)
			message(pp, "Wow!  A pair of boots!");
		else
			message(pp, "You can hobble around on one boot.");
		Maze[y][x] = SPACE;
		moved = TRUE;
		break;
	}

	/* Can the player be moved? */
	if (moved) {
		/* Check the gun status: */
		if (pp->p_ncshot > 0)
			if (--pp->p_ncshot == conf_maxncshot)
				outyx(pp, STAT_GUN_ROW, STAT_VALUE_COL, " ok");
		/* Check for bullets flying past: */
		if (pp->p_undershot) {
			fixshots(pp->p_y, pp->p_x, pp->p_over);
			pp->p_undershot = FALSE;
		}
		/* Erase the player: */
		drawplayer(pp, FALSE);
		/* Save under: */
		pp->p_over = Maze[y][x];
		/* Move the player: */
		pp->p_y = y;
		pp->p_x = x;
		/* Draw the player in their new position */
		drawplayer(pp, TRUE);
	}
}

/*
 * face:
 *	Change the direction the player is facing
 */
static void
face(PLAYER *pp, int dir)
{
	if (pp->p_face != dir) {
		pp->p_face = dir;
		drawplayer(pp, TRUE);
	}
}

/*
 * fire:
 *	Fire a shot of the given type in the given direction
 */
static void
fire(PLAYER *pp, int req_index)
{
	if (pp == NULL)
		return;

	/* Drop the shot type down until we can afford it: */
	while (req_index >= 0 && pp->p_ammo < shot_req[req_index])
		req_index--;

	/* Can we shoot at all? */
	if (req_index < 0) {
		message(pp, "Not enough charges.");
		return;
	}

	/* Check if the gun is too hot: */
	if (pp->p_ncshot > conf_maxncshot)
		return;

	/* Heat up the gun: */
	if (pp->p_ncshot++ == conf_maxncshot) {
		/* The gun has overheated: */
		outyx(pp, STAT_GUN_ROW, STAT_VALUE_COL, "   ");
	}

	/* Use up some ammo: */
	pp->p_ammo -= shot_req[req_index];
	ammo_update(pp);

	/* Start the bullet moving: */
	add_shot(shot_type[req_index], pp->p_y, pp->p_x, pp->p_face,
		shot_req[req_index], pp, FALSE, pp->p_face);
	pp->p_undershot = TRUE;

	/* Show the bullet to everyone: */
	showexpl(pp->p_y, pp->p_x, shot_type[req_index]);
	sendcom(ALL_PLAYERS, REFRESH);
}

/*
 * fire_slime:
 *	Fire a slime shot in the given direction
 */
static void
fire_slime(PLAYER *pp, int req_index)
{
	if (pp == NULL)
		return;

	/* Check configuration: */
	if (!conf_ooze)
		return;

	/* Drop the slime type back util we can afford it: */
	while (req_index >= 0 && pp->p_ammo < slime_req[req_index])
		req_index--;

	/* Can we afford to slime at all? */
	if (req_index < 0) {
		message(pp, "Not enough charges.");
		return;
	}

	/* Is the gun too hot? */
	if (pp->p_ncshot > conf_maxncshot)
		return;

	/* Heat up the gun: */
	if (pp->p_ncshot++ == conf_maxncshot) {
		/* The gun has overheated: */
		outyx(pp, STAT_GUN_ROW, STAT_VALUE_COL, "   ");
	}

	/* Use up some ammo: */
	pp->p_ammo -= slime_req[req_index];
	ammo_update(pp);

	/* Start the slime moving: */
	add_shot(SLIME, pp->p_y, pp->p_x, pp->p_face,
		slime_req[req_index] * conf_slimefactor, pp, FALSE, pp->p_face);
	pp->p_undershot = TRUE;

	/* Show the object to everyone: */
	showexpl(pp->p_y, pp->p_x, SLIME);
	sendcom(ALL_PLAYERS, REFRESH);
}

/*
 * add_shot:
 *	Create a shot with the given properties
 */
void
add_shot(int type, int y, int x, char face, int charge, PLAYER *owner,
    int expl, char over)
{
	BULLET	*bp;
	int	size;

	/* Determine the bullet's size based on its type and charge: */
	switch (type) {
	  case SHOT:
	  case MINE:
		size = 1;
		break;
	  case GRENADE:
	  case GMINE:
		size = 2;
		break;
	  case SATCHEL:
		size = 3;
		break;
	  case BOMB:
		for (size = 3; size < MAXBOMB; size++)
			if (shot_req[size] >= charge)
				break;
		size++;
		break;
	  default:
		size = 0;
		break;
	}

	/* Create the bullet: */
	bp = create_shot(type, y, x, face, charge, size, owner,
		(owner == NULL) ? NULL : owner->p_ident, expl, over);

	/* Insert the bullet into the front of the bullet list: */
	bp->b_next = Bullets;
	Bullets = bp;
}

/*
 * create_shot:
 *	allocate storage for an (unlinked) bullet structure;
 *	initialize and return it
 */
BULLET *
create_shot(int type, int y, int x, char face, int charge, int size,
    PLAYER *owner, IDENT *score, int expl, char over)
{
	BULLET	*bp;

	bp = malloc(sizeof (BULLET));
	if (bp == NULL) {
		logit(LOG_ERR, "malloc");
		if (owner != NULL)
			message(owner, "Out of memory");
		return NULL;
	}

	bp->b_face = face;
	bp->b_x = x;
	bp->b_y = y;
	bp->b_charge = charge;
	bp->b_owner = owner;
	bp->b_score = score;
	bp->b_type = type;
	bp->b_size = size;
	bp->b_expl = expl;
	bp->b_over = over;
	bp->b_next = NULL;

	return bp;
}

/*
 * cloak:
 *	Turn on or increase length of a cloak
 */
static void
cloak(PLAYER *pp)
{
	/* Check configuration: */
	if (!conf_cloak)
		return;

	/* Can we afford it?: */
	if (pp->p_ammo <= 0) {
		message(pp, "No more charges");
		return;
	}

	/* Can't cloak with boots: */
	if (pp->p_nboots > 0) {
		message(pp, "Boots are too noisy to cloak!");
		return;
	}

	/* Consume a unit of ammo: */
	pp->p_ammo--;
	ammo_update(pp);

	/* Add to the duration of a cloak: */
	pp->p_cloak += conf_cloaklen;

	/* Disable scan, if enabled: */
	if (pp->p_scan >= 0)
		pp->p_scan = -1;

	/* Re-draw the player's scan/cloak status: */
	showstat(pp);
}

/*
 * scan:
 *	Turn on or increase length of a scan
 */
static void
scan(PLAYER *pp)
{
	/* Check configuration: */
	if (!conf_scan)
		return;

	/* Can we afford it?: */
	if (pp->p_ammo <= 0) {
		message(pp, "No more charges");
		return;
	}

	/* Consume one unit of ammo: */
	pp->p_ammo--;
	ammo_update(pp);

	/* Increase the scan time: */
	pp->p_scan += Nplayer * conf_scanlen;

	/* Disable cloak, if enabled: */
	if (pp->p_cloak >= 0)
		pp->p_cloak = -1;

	/* Re-draw the player's scan/cloak status: */
	showstat(pp);
}

/*
 * pickup:
 *	pick up a mine or grenade, with some probability of it exploding
 */
static void
pickup(PLAYER *pp, int y, int x, int prob, int obj)
{
	int	req;

	/* Figure out how much ammo the player is trying to pick up: */
	switch (obj) {
	  case MINE:
		req = BULREQ;
		break;
	  case GMINE:
		req = GRENREQ;
		break;
	  default:
#ifdef DIAGNOSTIC
		abort();
#endif
		return;
	}

	/* Does it explode? */
	if (rand_num(100) < prob)
		/* Ooooh, unlucky: (Boom) */
		add_shot(obj, y, x, LEFTS, req, (PLAYER *) NULL,
			TRUE, pp->p_face);
	else {
		/* Safely picked it up. Add to player's ammo: */
		pp->p_ammo += req;
		ammo_update(pp);
	}
}

void
ammo_update(PLAYER *pp)
{
	outyx(pp, STAT_AMMO_ROW, STAT_VALUE_COL - 1, "%4d", pp->p_ammo);
}
@


1.13
log
@Pull in <sys/select.h> for fd_set

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.12 2016/01/07 21:37:53 mestre Exp $	*/
d6 3
a8 3
 * 
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are 
d10 2
a11 2
 * 
 * + Redistributions of source code must retain the above copyright 
d13 2
a14 2
 * + Redistributions in binary form must reproduce the above copyright 
 *   notice, this list of conditions and the following disclaimer in the 
d16 3
a18 3
 * + Neither the name of the University of California, San Francisco nor 
 *   the names of its contributors may be used to endorse or promote 
 *   products derived from this software without specific prior written 
d20 11
a30 11
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS 
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED 
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
d96 1
a96 1
			(void) strlcpy(pp->p_death, "| Quit |", 
@


1.12
log
@ANSIfy hunt(6)

Note: casted 2 args to struct sockaddr * on list.c to shut off compiler
warnings, and also changed an int len to socklen_t since recvfrom(2) receives
the last argument as the latter.

I'm running out of credits, but this was once again with great help and OK from
tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.11 2016/01/07 21:29:31 mestre Exp $	*/
d34 1
@


1.11
log
@Headers cleanup and sorting

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.10 2015/09/27 07:06:41 guenther Exp $	*/
d56 1
a56 2
mon_execute(pp)
	PLAYER	*pp;
d82 1
a82 2
execute(pp)
	PLAYER	*pp;
d197 1
a197 3
move_player(pp, dir)
	PLAYER	*pp;
	int	dir;
d341 1
a341 3
face(pp, dir)
	PLAYER	*pp;
	int	dir;
d354 1
a354 3
fire(pp, req_index)
	PLAYER	*pp;
	int	req_index;
d398 1
a398 3
fire_slime(pp, req_index)
	PLAYER	*pp;
	int	req_index;
d446 2
a447 8
add_shot(type, y, x, face, charge, owner, expl, over)
	int	type;
	int	y, x;
	char	face;
	int	charge;
	PLAYER	*owner;
	int	expl;
	char	over;
d491 2
a492 10
create_shot(type, y, x, face, charge, size, owner, score, expl, over)
	int	type;
	int	y, x;
	char	face;
	int	charge;
	int	size;
	PLAYER	*owner;
	IDENT	*score;
	int	expl;
	char	over;
d524 1
a524 2
cloak(pp)
	PLAYER	*pp;
d562 1
a562 2
scan(pp)
	PLAYER	*pp;
d594 1
a594 5
pickup(pp, y, x, prob, obj)
	PLAYER	*pp;
	int	y, x;
	int	prob;
	int	obj;
d626 1
a626 2
ammo_update(pp)
	PLAYER *pp;
@


1.10
log
@Delete pointless NOSTRICT comments
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.9 2015/08/22 14:47:41 deraadt Exp $	*/
d37 2
a39 1
#include "conf.h"
@


1.9
log
@remove malloc/calloc/realloc* casts, due to stdlib.h being present; ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.8 2004/01/16 00:13:19 espie Exp $	*/
d519 1
a519 1
	bp = malloc(sizeof (BULLET));	/* NOSTRICT */
@


1.8
log
@ISO C police: log and expl are reserved for the C library.
expl -> expl_string
log -> logit
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.7 2003/06/11 08:45:33 pjanzen Exp $	*/
d519 1
a519 1
	bp = (BULLET *) malloc(sizeof (BULLET));	/* NOSTRICT */
@


1.7
log
@New license from the official hunt release at
ftp://ftp.cgl.ucsf.edu/pub/hunt.shar.Z -- it has been approved by all three
authors (Conrad Huang, Ken Arnold, and Greg Couch).
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.6 2002/02/16 21:27:10 millert Exp $	*/
d521 1
a521 1
		log(LOG_ERR, "malloc");
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.5 1999/08/30 23:29:46 d Exp $	*/
d4 28
a31 3
 *  Hunt
 *  Copyright (c) 1985 Conrad C. Huang, Gregory S. Couch, Kenneth C.R.C. Arnold
 *  San Francisco, California
@


1.5
log
@add semicolon to pacify gcc -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.4 1999/02/01 06:53:56 d Exp $	*/
d16 7
a22 7
static void	cloak __P((PLAYER *));
static void	face __P((PLAYER *, int));
static void	fire __P((PLAYER *, int));
static void	fire_slime __P((PLAYER *, int));
static void	move_player __P((PLAYER *, int));
static void	pickup __P((PLAYER *, int, int, int, int));
static void	scan __P((PLAYER *));
@


1.4
log
@avoid denial of service attacks on server port; extra conf vars; fix otto
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.3 1999/01/29 07:30:35 d Exp $	*/
d48 1
@


1.3
log
@major changes: security, curses, config
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.2 1999/01/21 05:47:40 d Exp $	*/
d495 1
a495 1
		syslog(LOG_ERR, "malloc: %m");
@


1.2
log
@ident for OpenBSD
mandoc-ify manual pages
use -locurses
@
text
@d1 1
a2 1
/*	$OpenBSD$	*/
d9 14
a22 2
# include	<stdlib.h>
# include	"hunt.h"
a23 7
static	void	cloak __P((PLAYER *));
static	void	face __P((PLAYER *, int));
static	void	fire __P((PLAYER *, int));
static	void	fire_slime __P((PLAYER *, int));
static	void	move_player __P((PLAYER *, int));
static	void	pickup __P((PLAYER *, int, int, int, int));
static	void	scan __P((PLAYER *));
a24 2

# ifdef MONITOR
d36 1
d39 1
d43 2
a44 1
		(void) strcpy(pp->p_death, "| Quit |");
d46 2
a49 1
# endif
d53 1
a53 1
 *	Execute a single command
d63 1
a63 1
# ifdef	FLY
d70 2
a71 1
			(void) strcpy(pp->p_death, "| Quit |");
a75 1
# endif
d77 1
d80 1
a80 1
		sendcom(pp, REDRAW);
d83 1
a83 1
		move_player(pp, LEFTS);
d86 1
a86 1
		face(pp, LEFTS);
d89 1
a89 1
		move_player(pp, BELOW);
d92 1
a92 1
		face(pp, BELOW);
d95 1
a95 1
		move_player(pp, ABOVE);
d98 1
a98 1
		face(pp, ABOVE);
d101 1
a101 1
		move_player(pp, RIGHT);
d104 1
a104 1
		face(pp, RIGHT);
a142 1
# ifdef	OOZE
d150 1
a150 1
		fire_slime(pp, 2);
d153 1
a153 1
		fire_slime(pp, 3);
d155 1
a155 2
# endif
	  case 's':
d158 1
a158 1
	  case 'c':
d161 2
a162 2
	  case 'q':
		(void) strcpy(pp->p_death, "| Quit |");
d169 1
a169 1
 *	Execute a move in the given direction
d200 2
d203 1
a204 1
# ifdef RANDOM
a205 1
# endif
d208 1
a211 1
# ifdef REFLECT
a213 1
# endif
d215 1
d219 2
a220 1
			pickup(pp, y, x, 2, Maze[y][x]);
d222 2
a223 1
			pickup(pp, y, x, 95, Maze[y][x]);
d225 3
a227 1
			pickup(pp, y, x, 50, Maze[y][x]);
d231 1
a235 1
# ifdef OOZE
a236 2
# endif
# ifdef DRONE
d238 1
a238 1
# endif
d241 1
d243 1
d247 1
d253 1
d256 1
d258 1
a258 1
			checkdam(newp, pp, pp->p_ident, STABDAM, KNIFE);
d261 1
a261 1
# ifdef FLY
d267 3
a269 2
# endif
# ifdef BOOTS
d271 1
a271 5
	  case BOOT_PAIR:
		if (Maze[y][x] == BOOT)
			pp->p_nboots++;
		else
			pp->p_nboots += 2;
a287 1
# endif
d289 2
d292 1
d294 3
a296 4
			if (--pp->p_ncshot == MAXNCSHOT) {
				cgoto(pp, STAT_GUN_ROW, STAT_VALUE_COL);
				outstr(pp, " ok", 3);
			}
d301 1
d303 1
d305 1
d308 1
d339 2
a340 4
# ifdef DEBUG
	if (req_index < 0 || req_index >= MAXBOMB)
		message(pp, "What you do?");
# endif
d343 2
d349 3
a351 1
	if (pp->p_ncshot > MAXNCSHOT)
d353 5
a357 3
	if (pp->p_ncshot++ == MAXNCSHOT) {
		cgoto(pp, STAT_GUN_ROW, STAT_VALUE_COL);
		outstr(pp, "   ", 3);
d359 2
d362 1
a362 3
	(void) sprintf(Buf, "%3d", pp->p_ammo);
	cgoto(pp, STAT_AMMO_ROW, STAT_VALUE_COL);
	outstr(pp, Buf, 3);
d364 1
d369 1
a369 3
	/*
	 * Show the object to everyone
	 */
d371 1
a371 6
	for (pp = Player; pp < End_player; pp++)
		sendcom(pp, REFRESH);
# ifdef MONITOR
	for (pp = Monitor; pp < End_monitor; pp++)
		sendcom(pp, REFRESH);
# endif
a373 1
# ifdef	OOZE
d385 6
a390 4
# ifdef DEBUG
	if (req_index < 0 || req_index >= MAXSLIME)
		message(pp, "What you do?");
# endif
d393 2
d399 3
a401 1
	if (pp->p_ncshot > MAXNCSHOT)
d403 5
a407 3
	if (pp->p_ncshot++ == MAXNCSHOT) {
		cgoto(pp, STAT_GUN_ROW, STAT_VALUE_COL);
		outstr(pp, "   ", 3);
d409 2
d412 1
a412 3
	(void) sprintf(Buf, "%3d", pp->p_ammo);
	cgoto(pp, STAT_AMMO_ROW, STAT_VALUE_COL);
	outstr(pp, Buf, 3);
d414 1
d416 1
a416 1
		slime_req[req_index] * SLIME_FACTOR, pp, FALSE, pp->p_face);
d419 1
a419 3
	/*
	 * Show the object to everyone
	 */
d421 1
a421 6
	for (pp = Player; pp < End_player; pp++)
		sendcom(pp, REFRESH);
# ifdef MONITOR
	for (pp = Monitor; pp < End_monitor; pp++)
		sendcom(pp, REFRESH);
# endif
a422 1
# endif
d430 7
a436 7
int	type;
int	y, x;
char	face;
int	charge;
PLAYER	*owner;
int	expl;
char	over;
d441 1
d465 1
d468 2
d474 5
d495 1
d524 5
d533 2
a534 1
# ifdef BOOTS
a538 4
# endif
	(void) sprintf(Buf, "%3d", --pp->p_ammo);
	cgoto(pp, STAT_AMMO_ROW, STAT_VALUE_COL);
	outstr(pp, Buf, 3);
d540 3
a542 1
	pp->p_cloak += CLOAKLEN;
d544 4
d551 1
d563 5
a571 3
	(void) sprintf(Buf, "%3d", --pp->p_ammo);
	cgoto(pp, STAT_AMMO_ROW, STAT_VALUE_COL);
	outstr(pp, Buf, 3);
d573 3
a575 1
	pp->p_scan += SCANLEN;
d577 4
d584 1
d590 1
a590 1
 *	check whether the object blew up or whether he picked it up
d592 1
a592 1
void
d601 1
d610 1
d612 2
d615 2
d618 1
d622 1
d624 1
a624 3
		(void) sprintf(Buf, "%3d", pp->p_ammo);
		cgoto(pp, STAT_AMMO_ROW, STAT_VALUE_COL);
		outstr(pp, Buf, 3);
d626 7
@


1.1
log
@Initial revision
@
text
@d2 1
a7 5

#include <sys/cdefs.h>
#ifndef lint
__RCSID("$NetBSD: execute.c,v 1.2 1997/10/10 16:33:13 lukem Exp $");
#endif /* not lint */
@


1.1.1.1
log
@hunt (from NetBSD)
@
text
@@
