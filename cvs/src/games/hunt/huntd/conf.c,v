head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.7.0.36
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.28
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.32
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.30
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.26
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.24
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.22
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.20
	OPENBSD_5_0:1.7.0.18
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.16
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.14
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.10
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.12
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.8
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.6
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.4
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.6.0.14
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.12
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.5.0.12
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.10
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.8
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.6
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.13
date	2017.01.21.08.22.57;	author krw;	state Exp;
branches;
next	1.12;
commitid	slqvWeiHNc6j5Mv6;

1.12
date	2017.01.20.03.47.31;	author krw;	state Exp;
branches;
next	1.11;
commitid	Kgwga63pCsvReUuw;

1.11
date	2016.08.27.02.06.40;	author guenther;	state Exp;
branches;
next	1.10;
commitid	HajZYsKX8810aMqL;

1.10
date	2016.01.07.21.37.53;	author mestre;	state Exp;
branches;
next	1.9;
commitid	OXn0Z5fMODgNmJpo;

1.9
date	2016.01.07.21.29.31;	author mestre;	state Exp;
branches;
next	1.8;
commitid	AgYVDd64zIiNi3fx;

1.8
date	2015.10.24.18.10.47;	author mmcc;	state Exp;
branches;
next	1.7;
commitid	E0ZP9DdvBFa2Am31;

1.7
date	2007.03.20.03.43.50;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.16.00.13.19;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.13.11.55.09;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	99.12.12.15.08.14;	author d;	state Exp;
branches;
next	1.3;

1.3
date	99.08.30.23.35.50;	author d;	state Exp;
branches;
next	1.2;

1.2
date	99.02.01.06.53.55;	author d;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.07.30.34;	author d;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@/*	$OpenBSD: conf.c,v 1.12 2017/01/20 03:47:31 krw Exp $	*/
/* David Leonard <d@@openbsd.org>, 1999. Public domain. */

#include <sys/select.h>
#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>

#include "hunt.h"
#include "server.h"

/* Configuration option variables for the server: */

int conf_random =	1;
int conf_reflect =	1;
int conf_monitor =	1;
int conf_ooze =		1;
int conf_fly =		1;
int conf_volcano =	1;
int conf_drone =	1;
int conf_boots =	1;
int conf_scan =		1;
int conf_cloak =	1;
int conf_logerr =	1;
int conf_syslog =	0;

int conf_scoredecay =	15;
int conf_maxremove =	40;
int conf_linger =	90;

int conf_flytime =	20;
int conf_flystep =	5;
int conf_volcano_max =	50;
int conf_ptrip_face =	2;
int conf_ptrip_back =	95;
int conf_ptrip_side =	50;
int conf_prandom =	1;
int conf_preflect =	1;
int conf_pshot_coll =	5;
int conf_pgren_coll =	10;
int conf_pgren_catch =	10;
int conf_pmiss =	5;
int conf_pdroneabsorb =	1;
int conf_fall_frac =	5;

int conf_bulspd =	5;
int conf_ishots =	15;
int conf_nshots =	5;
int conf_maxncshot =	2;
int conf_maxdam =	10;
int conf_mindam =	5;
int conf_stabdam =	2;
int conf_killgain =	2;
int conf_slimefactor =	3;
int conf_slimespeed =	5;
int conf_lavaspeed =	1;
int conf_cloaklen =	20;
int conf_scanlen =	20;
int conf_mindshot =	2;
int conf_simstep =	0;


struct kwvar {
	char *	kw;
	void *	var;
	enum vartype { Vint, Vchar, Vstring, Vdouble } type;
};

static struct kwvar keywords[] = {
	{ "random",		&conf_random,		Vint },
	{ "reflect",		&conf_reflect,		Vint },
	{ "monitor",		&conf_monitor,		Vint },
	{ "ooze",		&conf_ooze,		Vint },
	{ "fly",		&conf_fly,		Vint },
	{ "volcano",		&conf_volcano,		Vint },
	{ "drone",		&conf_drone,		Vint },
	{ "boots",		&conf_boots,		Vint },
	{ "scan",		&conf_scan,		Vint },
	{ "cloak",		&conf_cloak,		Vint },
	{ "logerr",		&conf_logerr,		Vint },
	{ "syslog",		&conf_syslog,		Vint },
	{ "scoredecay",		&conf_scoredecay,	Vint },
	{ "maxremove",		&conf_maxremove,	Vint },
	{ "linger",		&conf_linger,		Vint },

	{ "flytime",		&conf_flytime,		Vint },
	{ "flystep",		&conf_flystep,		Vint },
	{ "volcano_max",	&conf_volcano_max,	Vint },
	{ "ptrip_face",		&conf_ptrip_face,	Vint },
	{ "ptrip_back",		&conf_ptrip_back,	Vint },
	{ "ptrip_side",		&conf_ptrip_side,	Vint },
	{ "prandom",		&conf_prandom,		Vint },
	{ "preflect",		&conf_preflect,		Vint },
	{ "pshot_coll",		&conf_pshot_coll,	Vint },
	{ "pgren_coll",		&conf_pgren_coll,	Vint },
	{ "pgren_catch",	&conf_pgren_catch,	Vint },
	{ "pmiss",		&conf_pmiss,		Vint },
	{ "pdroneabsorb",	&conf_pdroneabsorb,	Vint },
	{ "fall_frac",		&conf_fall_frac,	Vint },

	{ "bulspd",		&conf_bulspd,		Vint },
	{ "ishots",		&conf_ishots,		Vint },
	{ "nshots",		&conf_nshots,		Vint },
	{ "maxncshot",		&conf_maxncshot,	Vint },
	{ "maxdam",		&conf_maxdam,		Vint },
	{ "mindam",		&conf_mindam,		Vint },
	{ "stabdam",		&conf_stabdam,		Vint },
	{ "killgain",		&conf_killgain,		Vint },
	{ "slimefactor",	&conf_slimefactor,	Vint },
	{ "slimespeed",		&conf_slimespeed,	Vint },
	{ "lavaspeed",		&conf_lavaspeed,	Vint },
	{ "cloaklen",		&conf_cloaklen,		Vint },
	{ "scanlen",		&conf_scanlen,		Vint },
	{ "mindshot",		&conf_mindshot,		Vint },
	{ "simstep",		&conf_simstep,		Vint },

	{ NULL, NULL, Vint }
};

static char *
parse_int(char *p, struct kwvar *kvp, const char *fnm, int *linep)
{
	char *valuestart, *digitstart;
	char savec;
	int newval;

	/* expect a number */
	valuestart = p;
	if (*p == '-')
		p++;
	digitstart = p;
	while (isdigit((unsigned char)*p))
		p++;
	if ((*p == '\0' || isspace((unsigned char)*p) || *p == '#') &&
	    digitstart != p) {
		savec = *p;
		*p = '\0';
		newval = atoi(valuestart);
		*p = savec;
		logx(LOG_INFO, "%s:%d: %s: %d -> %d",
			fnm, *linep, kvp->kw, *(int *)kvp->var, newval);
		*(int *)kvp->var = newval;
		return p;
	} else {
		logx(LOG_ERR, "%s:%d: invalid integer value \"%s\"",
		    fnm, *linep, valuestart);
		return NULL;
	}
}

static char *
parse_value(char *p, struct kwvar *kvp, const char *fnm, int *linep)
{

	switch (kvp->type) {
	case Vint:
		return parse_int(p, kvp, fnm, linep);
	case Vchar:
	case Vstring:
	case Vdouble:
		/* tbd */
	default:
		abort();
	}
}

static void
parse_line(char *buf, char *fnm, int *line)
{
	char *p;
	char *word;
	char *endword;
	struct kwvar *kvp;
	char savec;

	p = buf;

	/* skip leading white */
	while (isspace((unsigned char)*p))
		p++;
	/* allow blank lines and comment lines */
	if (*p == '\0' || *p == '#')
		return;

	/* walk to the end of the word: */
	word = p;
	if (isalpha((unsigned char)*p) || *p == '_') {
		p++;
		while (isalpha((unsigned char)*p) || isdigit((unsigned char)*p) || *p == '_')
			p++;
	}
	endword = p;

	if (endword == word) {
		logx(LOG_ERR, "%s:%d: expected variable name",
			fnm, *line);
		return;
	}

	/* match the configuration variable name */
	savec = *endword;
	*endword = '\0';
	for (kvp = keywords; kvp->kw; kvp++)
		if (strcmp(kvp->kw, word) == 0)
			break;
	*endword = savec;

	if (kvp->kw == NULL) {
		logx(LOG_ERR,
		    "%s:%d: unrecognised variable \"%.*s\"",
		    fnm, *line, (int)(endword - word), word);
		return;
	}

	/* skip whitespace */
	while (isspace((unsigned char)*p))
		p++;

	if (*p++ != '=') {
		logx(LOG_ERR, "%s:%d: expected `=' after %s", fnm, *line, word);
		return;
	}

	/* skip whitespace */
	while (isspace((unsigned char)*p))
		p++;

	/* parse the value */
	p = parse_value(p, kvp, fnm, line);
	if (!p)
		return;

	/* skip trailing whitespace */
	while (isspace((unsigned char)*p))
		p++;

	if (*p && *p != '#') {
		logx(LOG_WARNING, "%s:%d: trailing garbage ignored",
			fnm, *line);
	}
}


static void
load_config(FILE *f, char *fnm)
{
	char buf[BUFSIZ];
	size_t len;
	int line;
	char *p;

	line = 0;
	while ((p = fgetln(f, &len)) != NULL) {
		line++;
		if (p[len-1] == '\n')
			len--;
		if (len >= sizeof(buf)) {
			logx(LOG_ERR, "%s:%d: line too long", fnm, line);
			continue;
		}
		(void)memcpy(buf, p, len);
		buf[len] = '\0';
		parse_line(buf, fnm, &line);
	}
}

/*
 * load various config file, allowing later ones to
 * overwrite earlier values
 */
void
config(void)
{
	char *home;
	char nm[MAXNAMLEN + 1];
	static char *fnms[] = {
		"/etc/hunt.conf",
		"%s/.hunt.conf",
		".hunt.conf",
		NULL
	};
	int fn;
	FILE *f;

	/* All the %s's get converted to $HOME */
	if ((home = getenv("HOME")) == NULL)
		home = "";

	for (fn = 0; fnms[fn]; fn++) {
		snprintf(nm, sizeof nm, fnms[fn], home);
		if ((f = fopen(nm, "r")) != NULL) {
			load_config(f, nm);
			fclose(f);
		}
		else if (errno != ENOENT)
			logit(LOG_WARNING, "%s", nm);
	}
}

/*
 * Parse a single configuration argument given on the command line
 */
void
config_arg( char *arg)
{
	int line = 0;

	parse_line(arg, "*Initialisation*", &line);
}
@


1.12
log
@In "%.*s" the * takes (int). gcc whines if you try to use the result
of pointer subtraction without a cast. So cast those expressions
to (int).

Switch one local variable to the same type as the parameter it is
compared to.

ok deraadt@@ guenther@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.11 2016/08/27 02:06:40 guenther Exp $	*/
d132 1
a132 1
	if (*p == '-') 
d143 1
a143 1
		logx(LOG_INFO, "%s:%d: %s: %d -> %d", 
d148 1
a148 1
		logx(LOG_ERR, "%s:%d: invalid integer value \"%s\"", 
d206 1
a206 1
	for (kvp = keywords; kvp->kw; kvp++) 
d212 2
a213 2
		logx(LOG_ERR, 
		    "%s:%d: unrecognised variable \"%.*s\"", 
d233 1
a233 1
	if (!p) 
d271 1
a271 1
 * load various config file, allowing later ones to 
d279 1
a279 1
	static char *fnms[] = { 
d281 2
a282 2
		"%s/.hunt.conf", 
		".hunt.conf", 
d297 1
a297 1
		} 
@


1.11
log
@Pull in <sys/select.h> for fd_set

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.10 2016/01/07 21:37:53 mestre Exp $	*/
d214 1
a214 1
		    fnm, *line, endword - word, word);
@


1.10
log
@ANSIfy hunt(6)

Note: casted 2 args to struct sockaddr * on list.c to shut off compiler
warnings, and also changed an int len to socklen_t since recvfrom(2) receives
the last argument as the latter.

I'm running out of credits, but this was once again with great help and OK from
tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.9 2016/01/07 21:29:31 mestre Exp $	*/
d4 1
@


1.9
log
@Headers cleanup and sorting

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.8 2015/10/24 18:10:47 mmcc Exp $	*/
d123 1
a123 5
parse_int(p, kvp, fnm, linep)
	char *p;
	struct kwvar *kvp;
	const char *fnm;
	int *linep;
d154 1
a154 5
parse_value(p, kvp, fnm, linep)
	char *p;
	struct kwvar *kvp;
	const char *fnm;
	int *linep;
d170 1
a170 4
parse_line(buf, fnm, line)
	char *buf;
	char *fnm;
	int *line;
d247 1
a247 3
load_config(f, fnm)
	FILE *	f;
	char *	fnm;
d274 1
a274 1
config()
d306 1
a306 2
config_arg(arg)
	char *arg;
@


1.8
log
@Cast ctype functions' arguments to unsigned char.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.7 2007/03/20 03:43:50 tedu Exp $	*/
d4 1
a4 2
#include <stdio.h>
#include <string.h>
d6 1
d8 1
a8 1
#include <ctype.h>
a9 1
#include <errno.h>
a12 1
#include "conf.h"
@


1.7
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.6 2004/01/16 00:13:19 espie Exp $	*/
d140 1
a140 1
	while (isdigit(*p))
d142 2
a143 1
	if ((*p == '\0' || isspace(*p) || *p == '#') && digitstart != p) {
d194 1
a194 1
	while (isspace(*p))
d202 1
a202 1
	if (isalpha(*p) || *p == '_') {
d204 1
a204 1
		while (isalpha(*p) || isdigit(*p) || *p == '_')
d231 1
a231 1
	while (isspace(*p))
d240 1
a240 1
	while (isspace(*p))
d249 1
a249 1
	while (isspace(*p))
@


1.6
log
@ISO C police: log and expl are reserved for the C library.
expl -> expl_string
log -> logit
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.5 2001/02/13 11:55:09 pjanzen Exp $	*/
d140 1
a140 1
	while (*p && isdigit(*p))
d193 1
a193 1
	while (*p && isspace(*p))
d201 1
a201 1
	if (*p && (isalpha(*p) || *p == '_')) {
d203 1
a203 1
		while (*p && (isalpha(*p) || isdigit(*p) || *p == '_'))
d230 1
a230 1
	while (*p && isspace(*p))
d239 1
a239 1
	while (*p && isspace(*p))
d248 1
a248 1
	while (*p && isspace(*p))
@


1.5
log
@Quiet alpha warnings, principally with correct includes
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.4 1999/12/12 15:08:14 d Exp $	*/
d312 1
a312 1
			log(LOG_WARNING, "%s", nm);
@


1.4
log
@better error msg. hook to parse command line options. reviewed by pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.3 1999/08/30 23:35:50 d Exp $	*/
d121 1
a121 1
	{ NULL }
@


1.3
log
@ -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.2 1999/02/01 06:53:55 d Exp $	*/
d234 1
a234 1
		logx(LOG_ERR, "%s:%d: expected `='", fnm, *line);
d314 12
@


1.2
log
@avoid denial of service attacks on server port; extra conf vars; fix otto
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.1 1999/01/29 07:30:34 d Exp $	*/
a168 1
		break;
a187 1
	int *varp;
a214 1
	varp = NULL;
d264 1
a264 1
	int len;
@


1.1
log
@major changes: security, curses, config
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d9 2
d12 2
d18 48
a65 45
int conf_random =	1;	/* enable dispersion doors */
int conf_reflect =	1;	/* enable generation of reflection walls */
int conf_monitor =	1;	/* enable monitors */
int conf_ooze =		1;	/* enable slime shots */
int conf_fly =		1;	/* enable flight */
int conf_volcano =	1;	/* enable volcanoes */
int conf_drone =	1;	/* enable drone */
int conf_boots =	1;	/* enable boots */
int conf_scan =		1;	/* enable scanning */
int conf_cloak =	1;	/* enable cloaking */
int conf_logerr =	1;	/* errors to stderr as well as syslog(8) */

int conf_scoredecay =	15;	/* nr deaths before nr kills begins to decay */
int conf_maxremove =	40;	/* Maximum number of holes in the maze wall */
int conf_linger =	90;	/* Seconds to keep game open with no players */

int conf_flytime =	20;	/* max time flying */
int conf_flystep =	5;	/* max displacement each flying time unit */
int conf_volcano_max =	50;	/* max size of volcano */
int conf_ptrip_face =	2;	/* chace of tripping a grenade on pickup,  */
int conf_ptrip_back =	95;	/*   - when backing onto it */
int conf_ptrip_side =	50;	/*   - when walking sideways into it */
int conf_prandom =	1;	/* percentage of time dispersion doors appear */
int conf_preflect =	1;	/* percentage of time reflection walls appear */
int conf_pshot_coll =	5;	/* percent chance of shots colliding */
int conf_pgren_coll =	10;	/* percent chance of grenades colliding */
int conf_pgren_catch =	10;	/* facing player chance of catching grenade */
int conf_pmiss =	5;	/* chance of bullet missing player */
int conf_pdroneabsorb =	1;	/* chance of absorbing a drone */
int conf_fall_frac =	5;	/* divisor of damage used for fall damage */

int conf_bulspd =	5;	/* speed of bullets */
int conf_ishots =	15;	/* initial ammo for player */
int conf_nshots =	5;	/* ammo boost for all when new player joins */
int conf_maxncshot =	2;	/* max number of simultaneous shots per player*/
int conf_maxdam =	10;	/* the initial shield for each player */
int conf_mindam =	5;	/* minimum damage from one unit of ammo */
int conf_stabdam =	2;	/* damage from stabbing */
int conf_killgain =	2;	/* shield gained from killing someone */
int conf_slimefactor =	3;	/* charge multiplier for slime */
int conf_slimespeed =	5;	/* speed of slime */
int conf_lavaspeed =	1;	/* speed of volcano lava */
int conf_cloaklen =	20;	/* duration of a cloak */
int conf_scanlen =	20;	/* duration of a scan */
int conf_mindshot =	2;	/* minium shot class needed to make a drone */
d69 2
a70 1
	int *	var;
d74 46
a119 44
	{ "random",		&conf_random },
	{ "reflect",		&conf_reflect },
	{ "monitor",		&conf_monitor },
	{ "ooze",		&conf_ooze },
	{ "fly",		&conf_fly },
	{ "volcano",		&conf_volcano },
	{ "drone",		&conf_drone },
	{ "boots",		&conf_boots },
	{ "scan",		&conf_scan },
	{ "cloak",		&conf_cloak },
	{ "logerr",		&conf_logerr },
	{ "scoredecay",		&conf_scoredecay },
	{ "maxremove",		&conf_maxremove },
	{ "linger",		&conf_linger },

	{ "flytime",		&conf_flytime },
	{ "flystep",		&conf_flystep },
	{ "volcano_max",	&conf_volcano_max },
	{ "ptrip_face",		&conf_ptrip_face },
	{ "ptrip_back",		&conf_ptrip_back },
	{ "ptrip_side",		&conf_ptrip_side },
	{ "prandom",		&conf_prandom },
	{ "preflect",		&conf_preflect },
	{ "pshot_coll",		&conf_pshot_coll },
	{ "pgren_coll",		&conf_pgren_coll },
	{ "pgren_catch",	&conf_pgren_catch },
	{ "pmiss",		&conf_pmiss },
	{ "pdroneabsorb",	&conf_pdroneabsorb },
	{ "fall_frac",		&conf_fall_frac },

	{ "bulspd",		&conf_bulspd },
	{ "ishots",		&conf_ishots },
	{ "nshots",		&conf_nshots },
	{ "maxncshot",		&conf_maxncshot },
	{ "maxdam",		&conf_maxdam },
	{ "mindam",		&conf_mindam },
	{ "stabdam",		&conf_stabdam },
	{ "killgain",		&conf_killgain },
	{ "slimefactor",	&conf_slimefactor },
	{ "slimespeed",		&conf_slimespeed },
	{ "lavaspeed",		&conf_lavaspeed },
	{ "cloaklen",		&conf_cloaklen },
	{ "scanlen",		&conf_scanlen },
	{ "mindshot",		&conf_mindshot },
d121 1
a121 1
	{ NULL, NULL}
d124 55
d180 4
a183 3
load_config(f, fnm)
	FILE *	f;
	char *	fnm;
a184 1
	char buf[BUFSIZ];
d186 2
a187 1
	char *word, *value;
d190 1
a190 6
	int *nextp;
	int line = 0;
	int len;
	int newval;

	static const char *delim = " \t\n\r\f";
d192 1
a192 9
	while ((p = fgetln(f, &len)) != NULL) {
		line++;
		if (p[len-1] == '\n')
			len--;
		if (len >= sizeof(buf))
			continue;
		(void)memcpy(buf, p, len);
		buf[len] = '\0';	/* code assumes newlines later on */
		p = buf;
d194 12
a205 2
		/* skip leading white */
		while (*p && isspace(*p))
d207 2
a208 3
		/* allow blank lines and comment lines */
		if (*p == '\0' || *p == '#')
			continue;
d210 5
d216 15
a230 11
		/* first word must match a keyword */
		varp = NULL;
		for (kvp = keywords; kvp->kw; kvp++) {
			int len;
			len = strlen(kvp->kw);

			if (strncmp(kvp->kw, p, len) != 0)
				continue;
			if (isspace(p[len]) || p[len] == '=')
				break;
		}
d232 8
a239 5
		if (kvp->kw == NULL) {
			fprintf(stderr, "%s:%d: unrecognised keyword\n", 
			    fnm, line);
			continue;
		}
d241 18
a258 1
		p += strlen(kvp->kw);
a259 3
		/* skip whitespace */
		while (*p && isspace(*p))
			p++;
d261 9
a269 4
		if (*p++ != '=') {
			fprintf(stderr, "%s:%d: expected `='\n", fnm, line);
			continue;
		}
d271 7
a277 11
		/* skip whitespace */
		while (*p && isspace(*p))
			p++;

		/* expect a number */
		value = p;
		while (*p && isdigit(*p))
			p++;
		if (!(*p == '\0' || isspace(*p) || *p == '#') || value == p) {
			fprintf(stderr, "%s:%d: invalid value\n", 
			    fnm, line);
d280 3
a282 10
		*p = '\0';
		newval = atoi(value);

#ifdef DIAGNOSTIC
		if (newval != *kvp->var)
			printf("%s:%d: %s: %d -> %d\n", fnm, line, 
			    kvp->kw, *kvp->var, newval);
#endif

		*kvp->var = newval;
d296 1
a296 1
		"/etc/hunt.conf"
d304 1
d310 1
a310 1
		if (f = fopen(nm, "r")) {
d313 3
a315 1
		}
@

