head	1.29;
access;
symbols
	OPENBSD_6_2:1.29.0.2
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.29.0.4
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.28.0.2
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.21.0.8
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.4
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.16
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.14
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.12
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.18.0.6
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.17.0.6
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.4
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.16.0.14
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.12
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.10
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.8
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.6
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	initial:1.1.1.1
	hunt:1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2017.01.21.08.22.57;	author krw;	state Exp;
branches;
next	1.28;
commitid	slqvWeiHNc6j5Mv6;

1.28
date	2016.03.28.11.49.45;	author chl;	state Exp;
branches;
next	1.27;
commitid	uZM9zHxSeEnbXDPg;

1.27
date	2016.03.21.00.49.36;	author guenther;	state Exp;
branches;
next	1.26;
commitid	MSxcUg12B9iLaLLL;

1.26
date	2016.01.07.21.37.53;	author mestre;	state Exp;
branches;
next	1.25;
commitid	OXn0Z5fMODgNmJpo;

1.25
date	2016.01.07.21.29.31;	author mestre;	state Exp;
branches;
next	1.24;
commitid	AgYVDd64zIiNi3fx;

1.24
date	2016.01.07.16.00.32;	author tb;	state Exp;
branches;
next	1.23;
commitid	IwzFE3fG5RnKTWNh;

1.23
date	2015.12.16.14.21.50;	author tb;	state Exp;
branches;
next	1.22;
commitid	47lKFCMHfkqci7HY;

1.22
date	2015.09.25.17.50.53;	author schwarze;	state Exp;
branches;
next	1.21;
commitid	2Au3XChOkF3gkMIF;

1.21
date	2014.03.23.02.42.47;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2013.08.29.20.22.15;	author naddy;	state Exp;
branches;
next	1.19;

1.19
date	2009.12.10.23.53.06;	author beck;	state Exp;
branches;
next	1.18;

1.18
date	2008.10.02.16.44.43;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.02.14.55.16;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.16.00.13.19;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.11.08.45.33;	author pjanzen;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.11.04.47.39;	author david;	state Exp;
branches;
next	1.13;

1.13
date	2002.12.06.21.48.51;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.31.03.40.00;	author pjanzen;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.27.10;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.13.11.55.10;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.03.05.50.21;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.30.18.28.07;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	99.12.12.15.13.50;	author d;	state Exp;
branches;
next	1.6;

1.6
date	99.03.22.00.29.15;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	99.03.14.02.07.30;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	99.02.01.06.53.56;	author d;	state Exp;
branches;
next	1.3;

1.3
date	99.01.29.07.30.35;	author d;	state Exp;
branches;
next	1.2;

1.2
date	99.01.21.05.47.40;	author d;	state Exp;
branches;
next	1.1;

1.1
date	99.01.21.05.33.38;	author d;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.01.21.05.33.38;	author d;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@/*	$OpenBSD: driver.c,v 1.28 2016/03/28 11:49:45 chl Exp $	*/
/*	$NetBSD: driver.c,v 1.5 1997/10/20 00:37:16 lukem Exp $	*/
/*
 * Copyright (c) 1983-2003, Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * + Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * + Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 * + Neither the name of the University of California, San Francisco nor
 *   the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written
 *   permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/stat.h>

#include <arpa/inet.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <paths.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

#include "conf.h"
#include "hunt.h"
#include "server.h"

u_int16_t Server_port;
int	Server_socket;		/* test socket to answer datagrams */
FLAG	should_announce = TRUE;	/* true if listening on standard port */
u_short	sock_port;		/* port # of tcp listen socket */
u_short	stat_port;		/* port # of statistics tcp socket */
in_addr_t Server_addr = INADDR_ANY;	/* address to bind to */

static	void	clear_scores(void);
static	int	havechar(PLAYER *);
static	void	init(int);
static	void	makeboots(void);
static	void	send_stats(void);
static	void	zap(PLAYER *, FLAG);
static  void	announce_game(void);
static	void	siginfo(int);
static	void	print_stats(FILE *);
static	void	handle_wkport(int);

/*
 * main:
 *	The main program.
 */
int
main(int ac, char **av)
{
	PLAYER		*pp;
	int		had_char;
	static fd_set	read_fds;
	static FLAG	first = TRUE;
	static FLAG	server = FALSE;
	extern int	optind;
	extern char	*optarg;
	extern char	*__progname;
	int		c;
	static struct timeval	linger = { 0, 0 };
	static struct timeval	timeout = { 0, 0 }, *to;
	struct spawn	*sp, *spnext;
	int		ret;
	int		nready;
	int		fd;
	int		background = 0;

	config();

	while ((c = getopt(ac, av, "bsp:a:D:")) != -1) {
		switch (c) {
		  case 'b':
			background = 1;
			conf_syslog = 1;
			conf_logerr = 0;
			break;
		  case 's':
			server = TRUE;
			break;
		  case 'p':
			should_announce = FALSE;
			Server_port = atoi(optarg);
			break;
		  case 'a':
			if (!inet_aton(optarg, (struct in_addr *)&Server_addr))
				err(1, "bad interface address: %s", optarg);
			break;
		  case 'D':
			config_arg(optarg);
			break;
		  default:
erred:
			fprintf(stderr,
			    "usage: %s [-bs] [-a addr] [-D var=value] "
			    "[-p port]\n",
			    __progname);
			return 2;
		}
	}
	if (optind < ac)
		goto erred;

	/* Open syslog: */
	openlog("huntd", LOG_PID | (conf_logerr && !server? LOG_PERROR : 0),
		LOG_DAEMON);

	/* Initialise game parameters: */
	init(background);

again:
	do {
		/* First, poll to see if we can get input */
		do {
			read_fds = Fds_mask;
			errno = 0;
			timerclear(&timeout);
			nready = select(Num_fds, &read_fds, NULL, NULL,
			    &timeout);
			if (nready < 0 && errno != EINTR) {
				logit(LOG_ERR, "select");
				cleanup(1);
			}
		} while (nready < 0);

		if (nready == 0) {
			/*
			 * Nothing was ready. We do some work now
			 * to see if the simulation has any pending work
			 * to do, and decide if we need to block
			 * indefinitely or just timeout.
			 */
			do {
				if (conf_simstep && can_moveshots()) {
				/*
				 * block for a short time before continuing
				 * with explosions, bullets and whatnot
				 */
					to = &timeout;
					to->tv_sec =  conf_simstep / 1000000;
					to->tv_usec = conf_simstep % 1000000;
				} else
				/*
				 * since there's nothing going on,
				 * just block waiting for external activity
				 */
					to = NULL;

				read_fds = Fds_mask;
				errno = 0;
				nready = select(Num_fds, &read_fds, NULL, NULL, 
				    to);
				if (nready < 0 && errno != EINTR) {
					logit(LOG_ERR, "select");
					cleanup(1);
				}
			} while (nready < 0);
		}

		/* Remember which descriptors are active: */
		Have_inp = read_fds;

		/* Answer new player connections: */
		if (FD_ISSET(Socket, &Have_inp))
			answer_first();

		/* Continue answering new player connections: */
		for (sp = Spawn; sp; ) {
			spnext = sp->next;
			fd = sp->fd;
			if (FD_ISSET(fd, &Have_inp) && answer_next(sp)) {
				/*
				 * Remove from the spawn list. (fd remains in
				 * read set).
				 */
				*sp->prevnext = sp->next;
				if (sp->next)
					sp->next->prevnext = sp->prevnext;
				free(sp);

				/* We probably consumed all data. */
				FD_CLR(fd, &Have_inp);

				/* Announce game if this is the first spawn. */
				if (first && should_announce)
					announce_game();
				first = FALSE;
			}
			sp = spnext;
		}

		/* Process input and move bullets until we've exhausted input */
		had_char = TRUE;
		while (had_char) {

			moveshots();
			for (pp = Player; pp < End_player; )
				if (pp->p_death[0] != '\0')
					zap(pp, TRUE);
				else
					pp++;
			for (pp = Monitor; pp < End_monitor; )
				if (pp->p_death[0] != '\0')
					zap(pp, FALSE);
				else
					pp++;

			had_char = FALSE;
			for (pp = Player; pp < End_player; pp++)
				if (havechar(pp)) {
					execute(pp);
					pp->p_nexec++;
					had_char = TRUE;
				}
			for (pp = Monitor; pp < End_monitor; pp++)
				if (havechar(pp)) {
					mon_execute(pp);
					pp->p_nexec++;
					had_char = TRUE;
				}
		}

		/* Handle a datagram sent to the server socket: */
		if (FD_ISSET(Server_socket, &Have_inp))
			handle_wkport(Server_socket);

		/* Answer statistics connections: */
		if (FD_ISSET(Status, &Have_inp))
			send_stats();

		/* Flush/synchronize all the displays: */
		for (pp = Player; pp < End_player; pp++) {
			if (FD_ISSET(pp->p_fd, &read_fds)) {
				sendcom(pp, READY, pp->p_nexec);
				pp->p_nexec = 0;
			}
			flush(pp);
		}
		for (pp = Monitor; pp < End_monitor; pp++) {
			if (FD_ISSET(pp->p_fd, &read_fds)) {
				sendcom(pp, READY, pp->p_nexec);
				pp->p_nexec = 0;
			}
			flush(pp);
		}
	} while (Nplayer > 0);

	/* No more players! */

	/* No players yet or a continuous game? */
	if (first || conf_linger < 0)
		goto again;

	/* Wait a short while for one to come back: */
	read_fds = Fds_mask;
	linger.tv_sec = conf_linger;
	while ((ret = select(Num_fds, &read_fds, NULL, NULL, &linger)) < 0) {
		if (errno != EINTR) {
			logit(LOG_WARNING, "select");
			break;
		}
		read_fds = Fds_mask;
		linger.tv_sec = conf_linger;
		linger.tv_usec = 0;
	}
	if (ret > 0)
		/* Someone returned! Resume the game: */
		goto again;
	/* else, it timed out, and the game is really over. */

	/* If we are an inetd server, we should re-init the map and restart: */
	if (server) {
		clear_scores();
		makemaze();
		clearwalls();
		makeboots();
		first = TRUE;
		goto again;
	}

	/* Get rid of any attached monitors: */
	for (pp = Monitor; pp < End_monitor; )
		zap(pp, FALSE);

	/* Fin: */
	cleanup(0);
	return 0;
}

/*
 * init:
 *	Initialize the global parameters.
 */
static void
init(int background)
{
	int	i;
	struct sockaddr_in	test_port;
	int	true = 1;
	socklen_t	len;
	struct sockaddr_in	addr;
	struct sigaction	sact;
	struct servent *se;

	sact.sa_flags = SA_RESTART;
	sigemptyset(&sact.sa_mask);

	/* Ignore HUP, QUIT and PIPE: */
	sact.sa_handler = SIG_IGN;
	if (sigaction(SIGHUP, &sact, NULL) == -1)
		err(1, "sigaction SIGHUP");
	if (sigaction(SIGQUIT, &sact, NULL) == -1)
		err(1, "sigaction SIGQUIT");
	if (sigaction(SIGPIPE, &sact, NULL) == -1)
		err(1, "sigaction SIGPIPE");

	/* Clean up gracefully on INT and TERM: */
	sact.sa_handler = cleanup;
	if (sigaction(SIGINT, &sact, NULL) == -1)
		err(1, "sigaction SIGINT");
	if (sigaction(SIGTERM, &sact, NULL) == -1)
		err(1, "sigaction SIGTERM");

	/* Handle INFO: */
	sact.sa_handler = siginfo;
	if (sigaction(SIGINFO, &sact, NULL) == -1)
		err(1, "sigaction SIGINFO");

	if (chdir("/") == -1)
		warn("chdir");
	(void) umask(0777);

	/* Initialize statistics socket: */
	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = Server_addr;
	addr.sin_port = 0;

	Status = socket(AF_INET, SOCK_STREAM, 0);
	if (bind(Status, (struct sockaddr *) &addr, sizeof addr) < 0) {
		logit(LOG_ERR, "bind");
		cleanup(1);
	}
	if (listen(Status, 5) == -1) {
		logit(LOG_ERR, "listen");
		cleanup(1);
	}

	len = sizeof (struct sockaddr_in);
	if (getsockname(Status, (struct sockaddr *) &addr, &len) < 0)  {
		logit(LOG_ERR, "getsockname");
		cleanup(1);
	}
	stat_port = ntohs(addr.sin_port);

	/* Initialize main socket: */
	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = Server_addr;
	addr.sin_port = 0;

	Socket = socket(AF_INET, SOCK_STREAM, 0);

	if (bind(Socket, (struct sockaddr *) &addr, sizeof addr) < 0) {
		logit(LOG_ERR, "bind");
		cleanup(1);
	}
	if (listen(Socket, 5) == -1) {
		logit(LOG_ERR, "listen");
		cleanup(1);
	}

	len = sizeof (struct sockaddr_in);
	if (getsockname(Socket, (struct sockaddr *) &addr, &len) < 0)  {
		logit(LOG_ERR, "getsockname");
		cleanup(1);
	}
	sock_port = ntohs(addr.sin_port);

	/* Initialize minimal select mask */
	FD_ZERO(&Fds_mask);
	FD_SET(Socket, &Fds_mask);
	FD_SET(Status, &Fds_mask);
	Num_fds = ((Socket > Status) ? Socket : Status) + 1;

	/* Find the port that huntd should run on */
	if (Server_port == 0) {
		se = getservbyname("hunt", "udp");
		if (se != NULL)
			Server_port = ntohs(se->s_port);
		else
			Server_port = HUNT_PORT;
	}

	/* Check if stdin is a socket: */
	len = sizeof (struct sockaddr_in);
	if (getsockname(STDIN_FILENO, (struct sockaddr *) &test_port, &len) >= 0
	    && test_port.sin_family == AF_INET) {
		/* We are probably running from inetd:  don't log to stderr */
		Server_socket = STDIN_FILENO;
		conf_logerr = 0;
		if (test_port.sin_port != htons((u_short) Server_port)) {
			/* Private game */
			should_announce = FALSE;
			Server_port = ntohs(test_port.sin_port);
		}
	} else {
		/* We need to listen on a socket: */
		test_port = addr;
		test_port.sin_port = htons((u_short) Server_port);

		Server_socket = socket(AF_INET, SOCK_DGRAM, 0);

		/* Permit multiple huntd's on the same port. */
		if (setsockopt(Server_socket, SOL_SOCKET, SO_REUSEPORT, &true,
		    sizeof true) < 0)
			logit(LOG_ERR, "setsockopt SO_REUSEADDR");

		if (bind(Server_socket, (struct sockaddr *) &test_port,
		    sizeof test_port) < 0) {
			logit(LOG_ERR, "bind port %d", Server_port);
			cleanup(1);
		}

		/* Become a daemon if asked to do so. */
		if (background)
			daemon(0, 0);

		/* Datagram sockets do not need a listen() call. */
	}

	/* We'll handle the broadcast listener in the main loop: */
	FD_SET(Server_socket, &Fds_mask);
	if (Server_socket + 1 > Num_fds)
		Num_fds = Server_socket + 1;

	/* Dig the maze: */
	makemaze();

	/* Create some boots, if needed: */
	makeboots();

	/* Construct a table of what objects a player can see over: */
	for (i = 0; i < NASCII; i++)
		See_over[i] = TRUE;
	See_over[DOOR] = FALSE;
	See_over[WALL1] = FALSE;
	See_over[WALL2] = FALSE;
	See_over[WALL3] = FALSE;
	See_over[WALL4] = FALSE;
	See_over[WALL5] = FALSE;

	logx(LOG_INFO, "game started");
}

/*
 * makeboots:
 *	Put the boots in the maze
 */
static void
makeboots(void)
{
	int	x, y;
	PLAYER	*pp;

	if (conf_boots) {
		do {
			x = rand_num(WIDTH - 1) + 1;
			y = rand_num(HEIGHT - 1) + 1;
		} while (Maze[y][x] != SPACE);
		Maze[y][x] = BOOT_PAIR;
	}

	for (pp = Boot; pp < &Boot[NBOOTS]; pp++)
		pp->p_flying = -1;
}


/*
 * checkdam:
 *	Apply damage to the victim from an attacker.
 *	If the victim dies as a result, give points to 'credit',
 */
void
checkdam(PLAYER *victim, PLAYER *attacker, IDENT *credit, int damage,
	char shot_type)
{
	char	*cp;
	int	y;

	/* Don't do anything if the victim is already in the throes of death */
	if (victim->p_death[0] != '\0')
		return;

	/* Weaken slime attacks by 0.5 * number of boots the victim has on: */
	if (shot_type == SLIME)
		switch (victim->p_nboots) {
		  default:
			break;
		  case 1:
			damage = (damage + 1) / 2;
			break;
		  case 2:
			if (attacker != NULL)
				message(attacker, "He has boots on!");
			return;
		}

	/* The victim sustains some damage: */
	victim->p_damage += damage;

	/* Check if the victim survives the hit: */
	if (victim->p_damage <= victim->p_damcap) {
		/* They survive. */
		outyx(victim, STAT_DAM_ROW, STAT_VALUE_COL, "%2d",
			victim->p_damage);
		return;
	}

	/* Describe how the victim died: */
	switch (shot_type) {
	  default:
		cp = "Killed";
		break;
	  case FALL:
		cp = "Killed on impact";
		break;
	  case KNIFE:
		cp = "Stabbed to death";
		victim->p_ammo = 0;		/* No exploding */
		break;
	  case SHOT:
		cp = "Shot to death";
		break;
	  case GRENADE:
	  case SATCHEL:
	  case BOMB:
		cp = "Bombed";
		break;
	  case MINE:
	  case GMINE:
		cp = "Blown apart";
		break;
	  case SLIME:
		cp = "Slimed";
		if (credit != NULL)
			credit->i_slime++;
		break;
	  case LAVA:
		cp = "Baked";
		break;
	  case DSHOT:
		cp = "Eliminated";
		break;
	}

	if (credit == NULL) {
		char *blame;

		/*
		 * Nobody is taking the credit for the kill.
		 * Attribute it to either a mine or 'act of God'.
		 */
		switch (shot_type) {
		case MINE:
		case GMINE:
			blame = "a mine";
			break;
		default:
			blame = "act of God";
			break;
		}

		/* Set the death message: */
		(void) snprintf(victim->p_death, sizeof victim->p_death,
			"| %s by %s |", cp, blame);

		/* No further score crediting needed. */
		return;
	}

	/* Set the death message: */
	(void) snprintf(victim->p_death, sizeof victim->p_death,
		"| %s by %s |", cp, credit->i_name);

	if (victim == attacker) {
		/* No use killing yourself. */
		credit->i_kills--;
		credit->i_bkills++;
	}
	else if (victim->p_ident->i_team == ' '
	    || victim->p_ident->i_team != credit->i_team) {
		/* A cross-team kill: */
		credit->i_kills++;
		credit->i_gkills++;
	}
	else {
		/* They killed someone on the same team: */
		credit->i_kills--;
		credit->i_bkills++;
	}

	/* Compute the new credited score: */
	credit->i_score = credit->i_kills / (double) credit->i_entries;

	/* The victim accrues one death: */
	victim->p_ident->i_deaths++;

	/* Account for 'Stillborn' deaths */
	if (victim->p_nchar == 0)
		victim->p_ident->i_stillb++;

	if (attacker) {
		/* Give the attacker player a bit more strength */
		attacker->p_damcap += conf_killgain;
		attacker->p_damage -= conf_killgain;
		if (attacker->p_damage < 0)
			attacker->p_damage = 0;

		/* Tell the attacker his new strength: */
		outyx(attacker, STAT_DAM_ROW, STAT_VALUE_COL, "%2d/%2d",
			attacker->p_damage, attacker->p_damcap);

		/* Tell the attacker his new 'kill count': */
		outyx(attacker, STAT_KILL_ROW, STAT_VALUE_COL, "%3d",
			(attacker->p_damcap - conf_maxdam) / 2);

		/* Update the attacker's score for everyone else */
		y = STAT_PLAY_ROW + 1 + (attacker - Player);
		outyx(ALL_PLAYERS, y, STAT_NAME_COL,
			"%5.2f", attacker->p_ident->i_score);
	}
}

/*
 * zap:
 *	Kill off a player and take them out of the game.
 *	The 'was_player' flag indicates that the player was not
 *	a monitor and needs extra cleaning up.
 */
static void
zap(PLAYER *pp, FLAG was_player)
{
	int	len;
	BULLET	*bp;
	PLAYER	*np;
	int	x, y;
	int	savefd;

	if (was_player) {
		/* If they died from a shot, clean up shrapnel */
		if (pp->p_undershot)
			fixshots(pp->p_y, pp->p_x, pp->p_over);
		/* Let the player see their last position: */
		drawplayer(pp, FALSE);
		/* Remove from game: */
		Nplayer--;
	}

	/* Display the cause of death in the centre of the screen: */
	len = strlen(pp->p_death);
	x = (WIDTH - len) / 2;
	outyx(pp, HEIGHT / 2, x, "%s", pp->p_death);

	/* Put some horizontal lines around and below the death message: */
	memset(pp->p_death + 1, '-', len - 2);
	pp->p_death[0] = '+';
	pp->p_death[len - 1] = '+';
	outyx(pp, HEIGHT / 2 - 1, x, "%s", pp->p_death);
	outyx(pp, HEIGHT / 2 + 1, x, "%s", pp->p_death);

	/* Move to bottom left */
	cgoto(pp, HEIGHT, 0);

	savefd = pp->p_fd;

	if (was_player) {
		int	expl_charge;
		int	expl_type;
		int	ammo_exploding;

		/* Check all the bullets: */
		for (bp = Bullets; bp != NULL; bp = bp->b_next) {
			if (bp->b_owner == pp)
				/* Zapped players can't own bullets: */
				bp->b_owner = NULL;
			if (bp->b_x == pp->p_x && bp->b_y == pp->p_y)
				/* Bullets over the player are now over air: */
				bp->b_over = SPACE;
		}

		/* Explode a random fraction of the player's ammo: */
		ammo_exploding = rand_num(pp->p_ammo);

		/* Determine the type and amount of detonation: */
		expl_charge = rand_num(ammo_exploding + 1);
		if (pp->p_ammo == 0)
			/* Ignore the no-ammo case: */
			expl_charge = 0;
		else if (ammo_exploding >= pp->p_ammo - 1) {
			/* Maximal explosions always appear as slime: */
			expl_charge = pp->p_ammo;
			expl_type = SLIME;
		} else {
			/*
			 * Figure out the best effective explosion
			 * type to use, given the amount of charge
			 */
			int btype, stype;
			for (btype = MAXBOMB - 1; btype > 0; btype--)
				if (expl_charge >= shot_req[btype])
					break;
			for (stype = MAXSLIME - 1; stype > 0; stype--)
				if (expl_charge >= slime_req[stype])
					break;
			/* Pick the larger of the bomb or slime: */
			if (btype >= 0 && stype >= 0) {
				if (shot_req[btype] > slime_req[stype])
					btype = -1;
			}
			if (btype >= 0)  {
				expl_type = shot_type[btype];
				expl_charge = shot_req[btype];
			} else
				expl_type = SLIME;
		}

		if (expl_charge > 0) {
			char buf[BUFSIZ];

			/* Detonate: */
			(void) add_shot(expl_type, pp->p_y, pp->p_x,
			    pp->p_face, expl_charge, (PLAYER *) NULL,
			    TRUE, SPACE);

			/* Explain what the explosion is about. */
			snprintf(buf, sizeof buf, "%s detonated.",
				pp->p_ident->i_name);
			message(ALL_PLAYERS, buf);

			while (pp->p_nboots-- > 0) {
				/* Throw one of the boots away: */
				for (np = Boot; np < &Boot[NBOOTS]; np++)
					if (np->p_flying < 0)
						break;
#ifdef DIAGNOSTIC
				if (np >= &Boot[NBOOTS])
					err(1, "Too many boots");
#endif
				/* Start the boots from where the player is */
				np->p_undershot = FALSE;
				np->p_x = pp->p_x;
				np->p_y = pp->p_y;
				/* Throw for up to 20 steps */
				np->p_flying = rand_num(20);
				np->p_flyx = 2 * rand_num(6) - 5;
				np->p_flyy = 2 * rand_num(6) - 5;
				np->p_over = SPACE;
				np->p_face = BOOT;
				showexpl(np->p_y, np->p_x, BOOT);
			}
		}
		/* No explosion. Leave the player's boots behind. */
		else if (pp->p_nboots > 0) {
			if (pp->p_nboots == 2)
				Maze[pp->p_y][pp->p_x] = BOOT_PAIR;
			else
				Maze[pp->p_y][pp->p_x] = BOOT;
			if (pp->p_undershot)
				fixshots(pp->p_y, pp->p_x,
					Maze[pp->p_y][pp->p_x]);
		}

		/* Any unexploded ammo builds up in the volcano: */
		volcano += pp->p_ammo - expl_charge;

		/* Volcano eruption: */
		if (conf_volcano && rand_num(100) < volcano /
		    conf_volcano_max) {
			/* Erupt near the middle of the map */
			do {
				x = rand_num(WIDTH / 2) + WIDTH / 4;
				y = rand_num(HEIGHT / 2) + HEIGHT / 4;
			} while (Maze[y][x] != SPACE);

			/* Convert volcano charge into lava: */
			(void) add_shot(LAVA, y, x, LEFTS, volcano,
				(PLAYER *) NULL, TRUE, SPACE);
			volcano = 0;

			/* Tell eveyone what's happening */
			message(ALL_PLAYERS, "Volcano eruption.");
		}

		/* Drone: */
		if (conf_drone && rand_num(100) < 2) {
			/* Find a starting place near the middle of the map: */
			do {
				x = rand_num(WIDTH / 2) + WIDTH / 4;
				y = rand_num(HEIGHT / 2) + HEIGHT / 4;
			} while (Maze[y][x] != SPACE);

			/* Start the drone going: */
			add_shot(DSHOT, y, x, rand_dir(),
				shot_req[conf_mindshot +
				rand_num(MAXBOMB - conf_mindshot)],
				(PLAYER *) NULL, FALSE, SPACE);
		}

		/* Tell the zapped player's client to shut down. */
		sendcom(pp, ENDWIN, ' ');
		(void) fclose(pp->p_output);

		/* Close up the gap in the Player array: */
		End_player--;
		if (pp != End_player) {
			/* Move the last player into the gap: */
			memcpy(pp, End_player, sizeof *pp);
			outyx(ALL_PLAYERS,
				STAT_PLAY_ROW + 1 + (pp - Player),
				STAT_NAME_COL,
				"%5.2f%c%-10.10s %c",
				pp->p_ident->i_score, stat_char(pp),
				pp->p_ident->i_name, pp->p_ident->i_team);
		}

		/* Erase the last player from the display: */
		cgoto(ALL_PLAYERS, STAT_PLAY_ROW + 1 + Nplayer, STAT_NAME_COL);
		ce(ALL_PLAYERS);
	}
	else {
		/* Zap a monitor */

		/* Close the session: */
		sendcom(pp, ENDWIN, LAST_PLAYER);
		(void) fclose(pp->p_output);

		/* shuffle the monitor table */
		End_monitor--;
		if (pp != End_monitor) {
			memcpy(pp, End_monitor, sizeof *pp);
			outyx(ALL_PLAYERS,
				STAT_MON_ROW + 1 + (pp - Player), STAT_NAME_COL,
				"%5.5s %-10.10s %c", " ",
				pp->p_ident->i_name, pp->p_ident->i_team);
		}

		/* Erase the last monitor in the list */
		cgoto(ALL_PLAYERS,
			STAT_MON_ROW + 1 + (End_monitor - Monitor),
			STAT_NAME_COL);
		ce(ALL_PLAYERS);
	}

	/* Update the file descriptor sets used by select: */
	FD_CLR(savefd, &Fds_mask);
	if (Num_fds == savefd + 1) {
		Num_fds = Socket;
		if (Server_socket > Socket)
			Num_fds = Server_socket;
		for (np = Player; np < End_player; np++)
			if (np->p_fd > Num_fds)
				Num_fds = np->p_fd;
		for (np = Monitor; np < End_monitor; np++)
			if (np->p_fd > Num_fds)
				Num_fds = np->p_fd;
		Num_fds++;
	}
}

/*
 * rand_num:
 *	Return a random number in a given range.
 */
int
rand_num(int range)
{
	return (arc4random_uniform(range));
}

/*
 * havechar:
 *	Check to see if we have any characters in the input queue; if
 *	we do, read them, stash them away, and return TRUE; else return
 *	FALSE.
 */
static int
havechar(PLAYER *pp)
{
	int ret;

	/* Do we already have characters? */
	if (pp->p_ncount < pp->p_nchar)
		return TRUE;
	/* Ignore if nothing to read. */
	if (!FD_ISSET(pp->p_fd, &Have_inp))
		return FALSE;
	/* Remove the player from the read set until we have drained them: */
	FD_CLR(pp->p_fd, &Have_inp);

	/* Suck their keypresses into a buffer: */
check_again:
	errno = 0;
	ret = read(pp->p_fd, pp->p_cbuf, sizeof pp->p_cbuf);
	if (ret == -1) {
		if (errno == EINTR)
			goto check_again;
		if (errno == EAGAIN) {
#ifdef DEBUG
			warn("Have_inp is wrong for %d", pp->p_fd);
#endif
			return FALSE;
		}
		logit(LOG_INFO, "read");
	}
	if (ret > 0) {
		/* Got some data */
		pp->p_nchar = ret;
	} else {
		/* Connection was lost/closed: */
		pp->p_cbuf[0] = 'q';
		pp->p_nchar = 1;
	}
	/* Reset pointer into read buffer */
	pp->p_ncount = 0;
	return TRUE;
}

/*
 * cleanup:
 *	Exit with the given value, cleaning up any droppings lying around
 */
void
cleanup(int eval)
{
	PLAYER	*pp;

	/* Place their cursor in a friendly position: */
	cgoto(ALL_PLAYERS, HEIGHT, 0);

	/* Send them all the ENDWIN command: */
	sendcom(ALL_PLAYERS, ENDWIN, LAST_PLAYER);

	/* And close their connections: */
	for (pp = Player; pp < End_player; pp++)
		(void) fclose(pp->p_output);
	for (pp = Monitor; pp < End_monitor; pp++)
		(void) fclose(pp->p_output);

	/* Close the server socket: */
	(void) close(Socket);

	/* The end: */
	logx(LOG_INFO, "game over");
	exit(eval);
}

/*
 * send_stats:
 *	Accept a connection to the statistics port, and emit
 *	the stats.
 */
static void
send_stats(void)
{
	FILE	*fp;
	int	s;
	struct sockaddr_in	sockstruct;
	socklen_t	socklen;

	/* Accept a connection to the statistics socket: */
	socklen = sizeof sockstruct;
	s = accept4(Status, (struct sockaddr *) &sockstruct, &socklen,
	    SOCK_NONBLOCK);
	if (s < 0) {
		if (errno == EINTR)
			return;
		logx(LOG_ERR, "accept");
		return;
	}

	fp = fdopen(s, "w");
	if (fp == NULL) {
		logit(LOG_ERR, "fdopen");
		(void) close(s);
		return;
	}

	print_stats(fp);

	(void) fclose(fp);
}

/*
 * print_stats:
 *	emit the game statistics
 */
void
print_stats(FILE *fp)
{
	IDENT	*ip;
	PLAYER  *pp;

	/* Send the statistics as raw text down the socket: */
	fputs("Name\t\tScore\tDucked\tAbsorb\tFaced\tShot\tRobbed\tMissed\tSlimeK\n", fp);
	for (ip = Scores; ip != NULL; ip = ip->i_next) {
		fprintf(fp, "%s%c%c%c\t", ip->i_name,
			ip->i_team == ' ' ? ' ' : '[',
			ip->i_team,
			ip->i_team == ' ' ? ' ' : ']'
		);
		if (strlen(ip->i_name) + 3 < 8)
			putc('\t', fp);
		fprintf(fp, "%.2f\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n",
			ip->i_score, ip->i_ducked, ip->i_absorbed,
			ip->i_faced, ip->i_shot, ip->i_robbed,
			ip->i_missed, ip->i_slime);
	}
	fputs("\n\nName\t\tEnemy\tFriend\tDeaths\tStill\tSaved\tConnect\n", fp);
	for (ip = Scores; ip != NULL; ip = ip->i_next) {
		fprintf(fp, "%s%c%c%c\t", ip->i_name,
			ip->i_team == ' ' ? ' ' : '[',
			ip->i_team,
			ip->i_team == ' ' ? ' ' : ']'
		);
		if (strlen(ip->i_name) + 3 < 8)
			putc('\t', fp);
		fprintf(fp, "%d\t%d\t%d\t%d\t%d\t",
			ip->i_gkills, ip->i_bkills, ip->i_deaths,
			ip->i_stillb, ip->i_saved);
		for (pp = Player; pp < End_player; pp++)
			if (pp->p_ident == ip)
				putc('p', fp);
		for (pp = Monitor; pp < End_monitor; pp++)
			if (pp->p_ident == ip)
				putc('m', fp);
		putc('\n', fp);
	}
}


/*
 * Send the game statistics to the controlling tty
 */
static void
siginfo(int sig)
{
	int tty;
	FILE *fp;

	if ((tty = open(_PATH_TTY, O_WRONLY)) >= 0) {
		fp = fdopen(tty, "w");
		print_stats(fp);
		answer_info(fp);
		fclose(fp);
	}
}

/*
 * clear_scores:
 *	Clear the Scores list.
 */
static void
clear_scores(void)
{
	IDENT	*ip, *nextip;

	/* Release the list of scores: */
	for (ip = Scores; ip != NULL; ip = nextip) {
		nextip = ip->i_next;
		free((char *) ip);
	}
	Scores = NULL;
}

/*
 * announce_game:
 *	Publically announce the game
 */
static void
announce_game(void)
{

	/* TODO: could use system() to do something user-configurable */
}

/*
 * Handle a UDP packet sent to the well known port.
 */
static void
handle_wkport(int fd)
{
	struct sockaddr		fromaddr;
	socklen_t		fromlen;
	u_int16_t		query;
	u_int16_t		response;

	fromlen = sizeof fromaddr;
	if (recvfrom(fd, &query, sizeof query, 0, &fromaddr, &fromlen) == -1)
	{
		logit(LOG_WARNING, "recvfrom");
		return;
	}

#ifdef DEBUG
	fprintf(stderr, "query %d (%s) from %s:%d\n", query,
		query == C_MESSAGE ? "C_MESSAGE" :
		query == C_SCORES ? "C_SCORES" :
		query == C_PLAYER ? "C_PLAYER" :
		query == C_MONITOR ? "C_MONITOR" : "?",
		inet_ntoa(((struct sockaddr_in *)&fromaddr)->sin_addr),
		ntohs(((struct sockaddr_in *)&fromaddr)->sin_port));
#endif

	query = ntohs(query);

	switch (query) {
	  case C_MESSAGE:
		if (Nplayer <= 0)
			/* Don't bother replying if nobody to talk to: */
			return;
		/* Return the number of people playing: */
		response = Nplayer;
		break;
	  case C_SCORES:
		/* Someone wants the statistics port: */
		response = stat_port;
		break;
	  case C_PLAYER:
	  case C_MONITOR:
		/* Someone wants to play or watch: */
		if (query == C_MONITOR && Nplayer <= 0)
			/* Don't bother replying if there's nothing to watch: */
			return;
		/* Otherwise, tell them how to get to the game: */
		response = sock_port;
		break;
	  default:
		logit(LOG_INFO, "unknown udp query %d", query);
		return;
	}

	response = ntohs(response);
	if (sendto(fd, &response, sizeof response, 0,
	    &fromaddr, sizeof fromaddr) == -1)
		logit(LOG_WARNING, "sendto");
}
@


1.28
log
@remove unused variables

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.27 2016/03/21 00:49:36 guenther Exp $	*/
d6 3
a8 3
 * 
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are 
d10 2
a11 2
 * 
 * + Redistributions of source code must retain the above copyright 
d13 2
a14 2
 * + Redistributions in binary form must reproduce the above copyright 
 *   notice, this list of conditions and the following disclaimer in the 
d16 3
a18 3
 * + Neither the name of the University of California, San Francisco nor 
 *   the names of its contributors may be used to endorse or promote 
 *   products derived from this software without specific prior written 
d20 11
a30 11
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS 
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED 
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
d144 1
a144 1
			nready = select(Num_fds, &read_fds, NULL, NULL, 
d156 1
a156 1
			 * to do, and decide if we need to block 
d174 1
a174 1
				
d199 1
a199 1
				 * Remove from the spawn list. (fd remains in 
d214 1
a214 1
			} 
d439 1
a439 1
		if (setsockopt(Server_socket, SOL_SOCKET, SO_REUSEPORT, &true, 
d599 1
a599 1
		(void) snprintf(victim->p_death, sizeof victim->p_death, 
d607 1
a607 1
	(void) snprintf(victim->p_death, sizeof victim->p_death, 
d614 1
a614 1
	} 
d645 1
a645 1
		outyx(attacker, STAT_DAM_ROW, STAT_VALUE_COL, "%2d/%2d", 
d756 2
a757 2
			(void) add_shot(expl_type, pp->p_y, pp->p_x, 
			    pp->p_face, expl_charge, (PLAYER *) NULL, 
d761 1
a761 1
			snprintf(buf, sizeof buf, "%s detonated.", 
d802 1
a802 1
		if (conf_volcano && rand_num(100) < volcano / 
d843 2
a844 2
			outyx(ALL_PLAYERS, 
				STAT_PLAY_ROW + 1 + (pp - Player), 
d866 1
a866 1
			outyx(ALL_PLAYERS, 
d1020 1
a1020 1
 * 	emit the game statistics
@


1.27
log
@Instead of creating a socket with socket() or accept() and then
setting the O_NONBLOCK flag on it with fcntl(F_SETFL) afterwards,
just pass SOCK_NONBLOCK to socket() or accept4() and get it right
to begin with.

ok millert@@ krw@@ beck@@ deraadt@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.26 2016/01/07 21:37:53 mestre Exp $	*/
a993 1
	int	flags;
@


1.26
log
@ANSIfy hunt(6)

Note: casted 2 args to struct sockaddr * on list.c to shut off compiler
warnings, and also changed an int len to socklen_t since recvfrom(2) receives
the last argument as the latter.

I'm running out of credits, but this was once again with great help and OK from
tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.24 2016/01/07 16:00:32 tb Exp $	*/
d998 2
a999 1
	s = accept(Status, (struct sockaddr *) &sockstruct, &socklen);
a1005 5

	/* Don't allow the writes to block: */
	flags = fcntl(s, F_GETFL, 0);
	flags |= O_NDELAY;
	(void) fcntl(s, F_SETFL, flags);
@


1.25
log
@Headers cleanup and sorting

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.23 2015/12/16 14:21:50 tb Exp $	*/
a62 1
	int	main(int, char *[]);
d76 1
a76 3
main(ac, av)
	int	ac;
	char	**av;
d124 1
a124 1
			exit(2);
d313 1
a313 1
	exit(0);
d485 1
a485 1
makeboots()
d509 2
a510 5
checkdam(victim, attacker, credit, damage, shot_type)
	PLAYER	*victim, *attacker;
	IDENT	*credit;
	int	damage;
	char	shot_type;
d666 1
a666 3
zap(pp, was_player)
	PLAYER	*pp;
	FLAG	was_player;
d900 1
a900 2
rand_num(range)
	int	range;
d912 1
a912 2
havechar(pp)
	PLAYER	*pp;
d958 1
a958 2
cleanup(eval)
	int	eval;
d988 1
a988 1
send_stats()
d1028 1
a1028 2
print_stats(fp)
	FILE *fp;
d1075 1
a1075 2
siginfo(sig)
	int sig;
d1093 1
a1093 1
clear_scores()
d1110 1
a1110 1
announce_game()
d1120 1
a1120 2
handle_wkport(fd)
	int fd;
@


1.24
log
@Some basic code maintenance in games/

- in main() replace exit with return
- drop some /* NOTREACHED */ lint comments along the way.
- make more use of standard CFLAGS, esp. -Wimplicit-function-declaration
- add and sort some headers when needed
- add straightforward pledges to some programs used at compile time

discussed with and ok mestre@@
@
text
@a33 1
#include <sys/ioctl.h>
d35 3
a37 1
#include <sys/time.h>
d40 3
d46 1
d48 2
a49 8
#include <stdio.h>
#include <syslog.h>
#include <netdb.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <paths.h>
#include <fcntl.h>
a50 1
#include "conf.h"
d127 1
a127 1
			return 2;
d316 1
a316 1
	return 0;
@


1.23
log
@Use __progname instead of hand-rolled parsing of argv[0].
Inspired by similar diffs by tobias@@ and millert@@.

"I like the concept" pjanzen@@
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.22 2015/09/25 17:50:53 schwarze Exp $	*/
d129 1
a129 1
			exit(2);
d318 1
a318 1
	exit(0);
@


1.22
log
@Fix -D in the synopsis line:
* Whitespace is allowed between -D and the variable name.
* Each -D option only takes one single assignment.
* Drop excessive .Sm macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.21 2014/03/23 02:42:47 tedu Exp $	*/
a54 1
char	*First_arg;		/* pointer to argv[0] */
d90 1
a99 2
	First_arg = av[0];

d128 1
a128 1
			    av[0]);
@


1.21
log
@stop using libwrap. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.20 2013/08/29 20:22:15 naddy Exp $	*/
d128 1
a128 1
			    "usage: %s [-bs] [-a addr] [-Dvar=value ...] "
@


1.20
log
@replace srandomdev()+random() with the arc4random*() family
tweaks and ok millert@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.19 2009/12/10 23:53:06 beck Exp $	*/
a43 1
#include <tcpd.h>
a1008 1
	struct request_info ri;
a1020 9
	/* Check for access permissions: */
	request_init(&ri, RQ_DAEMON, "huntd", RQ_FILE, s, 0);
	fromhost(&ri);
	if (hosts_access(&ri) == 0) {
		logx(LOG_INFO, "rejected connection from %s", eval_client(&ri));
		close(s);
		return;
	}

a1143 1
	struct request_info	ri;
a1144 2
	request_init(&ri, RQ_DAEMON, "huntd", RQ_FILE, fd, 0);
	fromhost(&ri);
a1160 6

	/* Do we allow access? */
	if (hosts_access(&ri) == 0) {
		logx(LOG_INFO, "rejected connection from %s", eval_client(&ri));
		return;
	}
@


1.19
log
@fix potential bugs spotted by parfait
ok millert@@ pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.18 2008/10/02 16:44:43 millert Exp $	*/
a468 3
	/* Initialise the random seed: */
	srandomdev();

d916 1
a916 3
	if (range == 0)
		return 0;
	return (random() % range);
@


1.18
log
@Remove useless setsid() and setpgrp() calls and add -b option to
run huntd in the background like a true daemon.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.17 2007/04/02 14:55:16 jmc Exp $	*/
d758 1
a758 1
				if (shot_req[btype] > slime_req[btype])
@


1.17
log
@tidy up synopis and usage(); sort options; from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.16 2004/01/16 00:13:19 espie Exp $	*/
d66 1
a66 1
static	void	init(void);
d99 1
d105 1
a105 1
	while ((c = getopt(ac, av, "sp:a:D:")) != -1) {
d107 5
d129 1
a129 1
			    "usage: %s [-s] [-a addr] [-Dvar=value ...] "
d143 1
a143 1
	init();
d329 1
a329 1
init()
a338 4
	(void) setsid();
	if (setpgid(getpid(), getpid()) == -1)
		err(1, "setpgid");

d456 4
@


1.16
log
@ISO C police: log and expl are reserved for the C library.
expl -> expl_string
log -> logit
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.15 2003/06/11 08:45:33 pjanzen Exp $	*/
d122 3
a124 1
			fprintf(stderr, "Usage: %s [-s] [-p port] [-a addr]\n",
@


1.15
log
@New license from the official hunt release at
ftp://ftp.cgl.ucsf.edu/pub/hunt.shar.Z -- it has been approved by all three
authors (Conrad Huang, Ken Arnold, and Greg Couch).
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.14 2003/03/11 04:47:39 david Exp $	*/
d147 1
a147 1
				log(LOG_ERR, "select");
d180 1
a180 1
					log(LOG_ERR, "select");
d285 1
a285 1
			log(LOG_WARNING, "select");
d370 1
a370 1
		log(LOG_ERR, "bind");
d374 1
a374 1
		log(LOG_ERR, "listen");
d380 1
a380 1
		log(LOG_ERR, "getsockname");
d393 1
a393 1
		log(LOG_ERR, "bind");
d397 1
a397 1
		log(LOG_ERR, "listen");
d403 1
a403 1
		log(LOG_ERR, "getsockname");
d445 1
a445 1
			log(LOG_ERR, "setsockopt SO_REUSEADDR");
d449 1
a449 1
			log(LOG_ERR, "bind port %d", Server_port);
d950 1
a950 1
		log(LOG_INFO, "read");
d1036 1
a1036 1
		log(LOG_ERR, "fdopen");
d1159 1
a1159 1
		log(LOG_WARNING, "recvfrom");
d1203 1
a1203 1
		log(LOG_INFO, "unknown udp query %d", query);
d1210 1
a1210 1
		log(LOG_WARNING, "sendto");
@


1.14
log
@double words and spelling fixes
ok pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.13 2002/12/06 21:48:51 millert Exp $	*/
d4 28
a31 3
 *  Hunt
 *  Copyright (c) 1985 Conrad C. Huang, Gregory S. Couch, Kenneth C.R.C. Arnold
 *  San Francisco, California
@


1.13
log
@Replace things like srandom(time(NULL)) with srandomdev(3).  random(3)
good enough for games but we should at least use a decent seed.
pjanzen@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.12 2002/05/31 03:40:00 pjanzen Exp $	*/
d131 1
a131 1
			 * to do, and decide if we need to to block 
@


1.12
log
@No dm -> no need to revoke setegid.
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.11 2002/02/16 21:27:10 millert Exp $	*/
d437 1
a437 1
	srandom(getpid() + time((time_t *) NULL));
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.10 2001/02/13 11:55:10 pjanzen Exp $	*/
a75 4

	/* Revoke privs: */
	setegid(getgid());
	setgid(getgid());
@


1.10
log
@Quiet alpha warnings, principally with correct includes
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.9 2000/07/03 05:50:21 pjanzen Exp $	*/
d39 11
a49 11
static	void	clear_scores __P((void));
static	int	havechar __P((PLAYER *));
static	void	init __P((void));
	int	main __P((int, char *[]));
static	void	makeboots __P((void));
static	void	send_stats __P((void));
static	void	zap __P((PLAYER *, FLAG));
static  void	announce_game __P((void));
static	void	siginfo __P((int));
static	void	print_stats __P((FILE *));
static	void	handle_wkport __P((int));
@


1.9
log
@A little more select() reinitialization.
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.8 2000/06/30 18:28:07 pjanzen Exp $	*/
d16 1
@


1.8
log
@re-initialize timeout before each invocation of select()
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.7 1999/12/12 15:13:50 d Exp $	*/
d266 1
@


1.7
log
@User netdb to get well known port.
Remove unused 3rd arg to main().
Revoke any setgid privs (unnecessary?)
Add -D for command-line configuration options.
Properly handle new, spawning connections.
Fix that evil repeated-quit problem in two places.
Fix a bug where a server would quit only if it were questioned for stats.
Allow port sharing.
Clean up havechar().
Don't allow write() to block.

reviewed by pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.6 1999/03/22 00:29:15 pjanzen Exp $	*/
a117 1
		timerclear(&timeout);
d121 1
d137 2
a138 1
			if (conf_simstep && can_moveshots()) {
d143 4
a146 4
				to = &timeout;
				to->tv_sec =  conf_simstep / 1000000;
				to->tv_usec = conf_simstep % 1000000;
			} else
d151 2
a152 3
				to = NULL;
			
			do {
d266 2
@


1.6
log
@More accurate man page; more informative logging; use random() instead of
old internal routine (seems to minimize instant death on re-entry).
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.5 1999/03/14 02:07:30 pjanzen Exp $	*/
d20 1
d31 1
a31 2
char	*Last_arg;		/* pointer to end of argv/environ */
u_int16_t Server_port = HUNT_PORT;
d41 1
a41 1
	int	main __P((int, char *[], char *[]));
d55 1
a55 1
main(ac, av, ep)
d57 1
a57 1
	char	**av, **ep;
d59 2
a60 2
	PLAYER	*pp;
	int	had_char;
d69 1
a69 1
	struct spawn	*sp;
d72 1
d75 4
a78 5
	if (ep == NULL || *ep == NULL)
		ep = av + ac;
	while (*ep)
		ep++;
	Last_arg = ep[-1] + strlen(ep[-1]);
d82 1
a82 1
	while ((c = getopt(ac, av, "sp:a:")) != -1) {
d92 1
a92 2
			Server_addr = inet_addr(optarg);
			if (Server_addr == INADDR_NONE)
d95 3
d168 1
a168 1
		if (FD_ISSET(Socket, &read_fds))
d172 17
a188 2
		for (sp = Spawn; sp; sp = sp->next)
			if (FD_ISSET(sp->fd, &read_fds) && answer_next(sp)) {
d192 3
a194 1
			}
d228 1
a228 1
		if (FD_ISSET(Server_socket, &read_fds))
d232 1
a232 1
		if (FD_ISSET(Status, &read_fds))
d237 1
a237 1
			if (FD_ISSET(pp->p_fd, &read_fds))
d239 2
a240 1
			pp->p_nexec = 0;
d244 1
a244 1
			if (FD_ISSET(pp->p_fd, &read_fds))
d246 2
a247 1
			pp->p_nexec = 0;
d254 2
a255 2
	/* Continuous game? */
	if (conf_linger < 0)
d300 2
a301 2
	int	msg;
	int	len;
d304 1
d366 1
a366 3
	msg = 1;
	if (setsockopt(Socket, SOL_SOCKET, SO_USELOOPBACK, &msg, sizeof msg)<0)
		log(LOG_ERR, "setsockopt loopback");
d389 9
d406 1
d416 6
d901 1
d906 1
a906 1
	/* Is the player being quiet? */
d914 3
a916 2
	if ((pp->p_nchar = read(pp->p_fd, pp->p_cbuf, sizeof pp->p_cbuf)) <= 0)
	{
d919 5
a923 5
		if (errno != EAGAIN) {
			log(LOG_INFO, "read");
			/* Assume their connection was lost/closed: */
			pp->p_cbuf[0] = 'q';
			pp->p_nchar = 1;
d925 9
d981 1
a981 1
	int	socklen;
d983 1
d1004 5
d1113 1
a1113 1
	/* Stub */
d1124 1
a1124 1
	int 			fromlen;
d1137 10
@


1.5
log
@Access control works now; also, some minor tidying and man page fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.4 1999/02/01 06:53:56 d Exp $	*/
a28 2
int	Seed = 0;

a32 1
FLAG	inetd_spawned;		/* invoked via inetd */
d373 1
a373 2
		/* We are probably running from inetd: */
		inetd_spawned = TRUE;
d375 1
d401 1
a401 1
	Seed = getpid() + time((time_t *) NULL);
d852 1
a852 2
	Seed = Seed * 11109 + 13849;
	return (((Seed >> 16) & 0xffff) % range);
d951 1
d1086 2
a1087 1
	if (hosts_access(&ri) == 0)
d1089 1
@


1.4
log
@avoid denial of service attacks on server port; extra conf vars; fix otto
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.3 1999/01/29 07:30:35 d Exp $	*/
d592 1
a592 1
		/* Tell the attacker's his new strength: */
d596 1
a596 1
		/* Tell the attacker's his new 'kill count': */
d951 7
a957 6
        /* Check for access permissions: */
        request_init(&ri, RQ_DAEMON, "huntd", RQ_FILE, s, 0);
        if (hosts_access(&ri) == 0) {
                close(s);
                return;
        }
d1077 1
d1079 2
d1087 5
@


1.3
log
@major changes: security, curses, config
@
text
@d1 1
a1 1
/*	$OpenBSD: driver.c,v 1.2 1999/01/21 05:47:40 d Exp $	*/
d23 2
d49 3
a63 1
	short	port_num, reply;
a69 1
	FILE *		cffile;
d71 4
d118 9
a126 7
		/* Wait for something to happen: */
		read_fds = Fds_mask;
		errno = 0;
		while (select(Num_fds, &read_fds, NULL, NULL, NULL) < 0)
		{
			if (errno != EINTR) {
				syslog(LOG_ERR, "select: %m");
d129 34
a162 1
			errno = 0;
d168 10
a177 40
		/* Handle a datagram sent to the server socket: */
		if (FD_ISSET(Server_socket, &read_fds)) {
			struct sockaddr_in	test;
			int 			namelen;
			u_int16_t		msg;

			namelen = sizeof test;
			(void) recvfrom(Server_socket, 
				&msg, sizeof msg,
				0,
				(struct sockaddr *) &test, &namelen);

			port_num = htons(sock_port);
			switch (ntohs(msg)) {
			  case C_MESSAGE:
				if (Nplayer <= 0)
					break;
				reply = htons((u_short) Nplayer);
				(void) sendto(Server_socket, 
					&reply, sizeof reply, 
					0,
					(struct sockaddr *) &test, sizeof test);
				break;
			  case C_SCORES:
				reply = htons(stat_port);
				(void) sendto(Server_socket, 
					&reply, sizeof reply, 
					0,
					(struct sockaddr *) &test, sizeof test);
				break;
			  case C_PLAYER:
			  case C_MONITOR:
				if (msg == C_MONITOR && Nplayer <= 0)
					break;
				reply = htons(sock_port);
				(void) sendto(Server_socket, 
					&reply, sizeof reply, 
					0,
					(struct sockaddr *) &test, sizeof test);
				break;
a178 1
		}
d181 15
a195 1
		for (;;) {
d201 1
a201 1
					had_char++;
d207 1
a207 1
					had_char++;
a208 13
			if (!had_char)
				break;
			moveshots();
			for (pp = Player; pp < End_player; )
				if (pp->p_death[0] != '\0')
					zap(pp, TRUE);
				else
					pp++;
			for (pp = Monitor; pp < End_monitor; )
				if (pp->p_death[0] != '\0')
					zap(pp, FALSE);
				else
					pp++;
d211 3
a213 7
		/* Answer new player connections: */
		if (FD_ISSET(Socket, &read_fds))
			if (answer()) {
				if (first && should_announce)
					announce_game();
				first = FALSE;
			}
d234 7
a240 1
	/* No more players. Wait for a short while for one to come back: */
d243 7
a249 1
	if (select(Num_fds, &read_fds, NULL, NULL, &linger) > 0) {
d252 1
a252 1
	}
d254 1
a254 1
	/* If we are an inetd server, we should restart: */
d264 1
a264 1
	/* Destroy all the monitors: */
d268 1
a268 1
	/* The end: */
d285 1
a286 1
	/* XXX should we call deamon() instead ??? */
d288 2
a289 1
	(void) setpgid(getpid(), getpid());
d291 2
a292 6
	/* Handle some signals: */
	(void) signal(SIGHUP, SIG_IGN);
	(void) signal(SIGINT, cleanup);
	(void) signal(SIGQUIT, SIG_IGN);
	(void) signal(SIGTERM, cleanup);
	(void) signal(SIGPIPE, SIG_IGN);
d294 24
a317 2
	(void) chdir("/");		/* just in case it core dumps */
	(void) umask(0777);		/* No privacy at all! */
d326 5
a330 1
		syslog(LOG_ERR, "bind: %m");
a332 1
	(void) listen(Status, 5);
d336 1
a336 1
		syslog(LOG_ERR, "getsockname: %m");
d349 1
a349 1
		syslog(LOG_ERR, "setsockopt loopback %m");
d351 5
a355 1
		syslog(LOG_ERR, "bind: %m");
a357 1
	(void) listen(Socket, 5);
d361 1
a361 1
		syslog(LOG_ERR, "getsockname: %m");
d391 1
a391 1
			syslog(LOG_ERR, "bind port %d: %m", Server_port);
d394 2
a395 1
		(void) listen(Server_socket, 5);
d422 1
a422 1
	syslog(LOG_INFO, "game started");
d870 1
d873 1
d876 1
d878 2
a880 1
	errno = 0;
d885 6
a890 1
		pp->p_cbuf[0] = 'q';
d892 1
d923 1
a923 1
	syslog(LOG_INFO, "game over");
a934 1
	IDENT	*ip;
d947 1
a947 1
		syslog(LOG_ERR, "accept: %m");
d960 1
a960 1
		syslog(LOG_ERR, "fdopen: %m");
d965 16
d996 1
a996 1
	fputs("\n\nName\t\tEnemy\tFriend\tDeaths\tStill\tSaved\n", fp);
d1005 1
a1005 1
		fprintf(fp, "%d\t%d\t%d\t%d\t%d\n",
d1008 7
d1016 12
d1029 6
a1034 1
	(void) fclose(fp);
d1049 1
a1049 1
		(void) free((char *) ip);
d1063 52
@


1.2
log
@ident for OpenBSD
mandoc-ify manual pages
use -locurses
@
text
@d1 1
a2 1
/*	$OpenBSD$	*/
d9 17
a25 15
# include	<sys/ioctl.h>
# include	<sys/stat.h>
# include	<sys/time.h>
# include	<err.h>
# include	<errno.h>
# include	<signal.h>
# include	<stdlib.h>
# include	<unistd.h>
# include	"hunt.h"

# ifndef pdp11
# define	RN	(((Seed = Seed * 11109 + 13849) >> 16) & 0xffff)
# else
# define	RN	((Seed = Seed * 11109 + 13849) & 0x7fff)
# endif
a28 2

SOCKET	Daemon;
d31 2
a32 2
# ifdef	INTERNET
int	Test_socket;		/* test socket to answer datagrams */
d34 1
a34 1
FLAG	standard_port = TRUE;	/* true if listening on standard port */
d37 1
a37 4
# define	DAEMON_SIZE	(sizeof Daemon)
# else
# define	DAEMON_SIZE	(sizeof Daemon - 1)
# endif
d46 1
a46 1

a58 2
# ifdef INTERNET
	u_short	msg;
a59 3
	int	namelen;
	SOCKET	test;
# endif
d66 2
a67 1
	static struct timeval	linger = {	90, 0	};
d76 3
a78 1
	while ((c = getopt(ac, av, "sp:")) != -1) {
a82 1
# ifdef INTERNET
d84 7
a90 2
			standard_port = FALSE;
			Test_port = atoi(optarg);
a91 1
# endif
d94 3
a96 2
			fprintf(stderr, "Usage: %s [-s] [-p port]\n", av[0]);
			exit(1);
d102 5
a108 1

d111 1
d116 4
a119 6
			if (errno != EINTR)
# ifdef LOG
				syslog(LOG_WARNING, "select: %m");
# else
				warn("select");
# endif
d122 2
d125 13
a137 3
# ifdef INTERNET
		if (FD_ISSET(Test_socket, &read_fds)) {
			namelen = DAEMON_SIZE;
a138 2
			(void) recvfrom(Test_socket, (char *) &msg, sizeof msg,
				0, (struct sockaddr *) &test, &namelen);
d144 4
a147 3
				(void) sendto(Test_socket, (char *) &reply,
					sizeof reply, 0,
					(struct sockaddr *) &test, DAEMON_SIZE);
d151 4
a154 3
				(void) sendto(Test_socket, (char *) &reply,
					sizeof reply, 0,
					(struct sockaddr *) &test, DAEMON_SIZE);
d161 4
a164 3
				(void) sendto(Test_socket, (char *) &reply,
					sizeof reply, 0,
					(struct sockaddr *) &test, DAEMON_SIZE);
d168 2
a169 1
# endif
a177 1
# ifdef MONITOR
a183 1
# endif
a191 1
# ifdef MONITOR
a196 1
# endif
d198 2
d202 2
a203 4
# ifdef INTERNET
				if (first && standard_port)
					faketalk();
# endif
d206 2
d210 2
d216 1
a216 1
			(void) fflush(pp->p_output);
a217 1
# ifdef MONITOR
d222 1
a222 1
			(void) fflush(pp->p_output);
a223 1
# endif
d226 1
d228 1
d230 1
d233 2
a238 1
# ifdef BOOTS
a239 1
# endif
d244 1
a244 1
# ifdef MONITOR
d247 2
a248 1
# endif
d250 1
a250 2
	/* NOTREACHED */
	return(0);
d261 1
a261 2
# ifdef	INTERNET
	SOCKET	test_port;
d264 5
a268 1
# endif
d270 1
a270 5
# ifndef DEBUG
# ifdef TIOCNOTTY
	(void) ioctl(fileno(stdout), TIOCNOTTY, NULL);
# endif
	(void) setpgrp(getpid(), getpid());
d272 1
a272 1
	(void) signal(SIGINT, SIG_IGN);
d275 1
a275 1
# endif
d277 2
a278 3
	(void) chdir("/var/tmp");	/* just in case it core dumps */
	(void) umask(0);		/* No privacy at all! */
	(void) signal(SIGPIPE, SIG_IGN);
d280 9
a288 33
# ifdef LOG
# ifdef	SYSLOG_43
	openlog("HUNT", LOG_PID, LOG_DAEMON);
# endif
# ifdef	SYSLOG_42
	openlog("HUNT", LOG_PID);
# endif
# endif

	/*
	 * Initialize statistics socket
	 */
# ifdef	INTERNET
	Daemon.sin_family = SOCK_FAMILY;
	Daemon.sin_addr.s_addr = INADDR_ANY;
	Daemon.sin_port = 0;
# else
	Daemon.sun_family = SOCK_FAMILY;
	(void) strcpy(Daemon.sun_path, Stat_name);
# endif

	Status = socket(SOCK_FAMILY, SOCK_STREAM, 0);
	if (bind(Status, (struct sockaddr *) &Daemon, DAEMON_SIZE) < 0) {
		if (errno == EADDRINUSE)
			exit(0);
		else {
# ifdef LOG
			syslog(LOG_ERR, "bind: %m");
# else
			warn("bind");
# endif
			cleanup(1);
		}
d292 2
a293 4
# ifdef INTERNET
	len = sizeof (SOCKET);
	if (getsockname(Status, (struct sockaddr *) &Daemon, &len) < 0)  {
# ifdef LOG
d295 8
a302 19
# else
		warn("getsockname");
# endif
		exit(1);
	}
	stat_port = ntohs(Daemon.sin_port);
# endif

	/*
	 * Initialize main socket
	 */
# ifdef	INTERNET
	Daemon.sin_family = SOCK_FAMILY;
	Daemon.sin_addr.s_addr = INADDR_ANY;
	Daemon.sin_port = 0;
# else
	Daemon.sun_family = SOCK_FAMILY;
	(void) strcpy(Daemon.sun_path, Sock_name);
# endif
d304 1
a304 2
	Socket = socket(SOCK_FAMILY, SOCK_STREAM, 0);
# if defined(INTERNET)
d307 4
a310 17
# ifdef LOG
		syslog(LOG_WARNING, "setsockopt loopback %m");
# else
		warn("setsockopt loopback");
# endif
# endif
	if (bind(Socket, (struct sockaddr *) &Daemon, DAEMON_SIZE) < 0) {
		if (errno == EADDRINUSE)
			exit(0);
		else {
# ifdef LOG
			syslog(LOG_ERR, "bind: %m");
# else
			warn("bind");
# endif
			cleanup(1);
		}
d314 2
a315 4
# ifdef INTERNET
	len = sizeof (SOCKET);
	if (getsockname(Socket, (struct sockaddr *) &Daemon, &len) < 0)  {
# ifdef LOG
d317 5
a321 11
# else
		warn("getsockname");
# endif
		exit(1);
	}
	sock_port = ntohs(Daemon.sin_port);
# endif

	/*
	 * Initialize minimal select mask
	 */
d327 5
a331 4
# ifdef INTERNET
	len = sizeof (SOCKET);
	if (getsockname(0, (struct sockaddr *) &test_port, &len) >= 0
	&& test_port.sin_family == AF_INET) {
d333 4
a336 4
		Test_socket = 0;
		if (test_port.sin_port != htons((u_short) Test_port)) {
			standard_port = FALSE;
			Test_port = ntohs(test_port.sin_port);
d339 12
a350 2
		test_port = Daemon;
		test_port.sin_port = htons((u_short) Test_port);
d352 4
a355 17
		Test_socket = socket(SOCK_FAMILY, SOCK_DGRAM, 0);
		if (bind(Test_socket, (struct sockaddr *) &test_port,
		    DAEMON_SIZE) < 0) {
# ifdef LOG
			syslog(LOG_ERR, "bind: %m");
# else
			warn("bind");
# endif
			exit(1);
		}
		(void) listen(Test_socket, 5);
	}

	FD_SET(Test_socket, &Fds_mask);
	if (Test_socket + 1 > Num_fds)
		Num_fds = Test_socket + 1;
# endif
d357 1
d359 2
d362 2
a363 1
# ifdef BOOTS
a364 1
# endif
d366 1
a372 1
# ifdef REFLECT
a374 1
# endif
d376 1
a378 1
# ifdef BOOTS
d389 8
a396 5
	do {
		x = rand_num(WIDTH - 1) + 1;
		y = rand_num(HEIGHT - 1) + 1;
	} while (Maze[y][x] != SPACE);
	Maze[y][x] = BOOT_PAIR;
a399 1
# endif
d404 2
a405 1
 *	Check the damage to the given player, and see if s/he is killed
d408 2
a409 2
checkdam(ouch, gotcha, credit, amt, shot_type)
	PLAYER	*ouch, *gotcha;
d411 1
a411 1
	int	amt;
d415 1
d417 2
a418 1
	if (ouch->p_death[0] != '\0')
d420 2
a421 1
# ifdef BOOTS
d423 1
a423 1
		switch (ouch->p_nboots) {
d427 1
a427 1
			amt = (amt + 1) / 2;
d430 2
a431 2
			if (gotcha != NULL)
				message(gotcha, "He has boots on!");
d434 9
a442 6
# endif
	ouch->p_damage += amt;
	if (ouch->p_damage <= ouch->p_damcap) {
		(void) sprintf(Buf, "%2d", ouch->p_damage);
		cgoto(ouch, STAT_DAM_ROW, STAT_VALUE_COL);
		outstr(ouch, Buf, 2);
d446 1
a446 1
	/* Someone DIED */
a450 1
# ifdef FLY
a453 1
# endif
d456 1
a456 1
		ouch->p_ammo = 0;		/* No exploding */
a469 1
# ifdef	OOZE
a474 2
# endif
# ifdef	VOLCANO
a477 2
# endif
# ifdef DRONE
a480 1
# endif
d482 1
d484 21
a504 3
		(void) sprintf(ouch->p_death, "| %s by %s |", cp,
			(shot_type == MINE || shot_type == GMINE) ?
			"a mine" : "act of God");
d508 3
a510 1
	(void) sprintf(ouch->p_death, "| %s by %s |", cp, credit->i_name);
d512 2
a513 1
	if (ouch == gotcha) {		/* No use killing yourself */
d516 4
a519 3
	}
	else if (ouch->p_ident->i_team == ' '
	|| ouch->p_ident->i_team != credit->i_team) {
d524 1
d528 2
d531 27
a557 26
	ouch->p_ident->i_deaths++;
	if (ouch->p_nchar == 0)
		ouch->p_ident->i_stillb++;
	if (gotcha == NULL)
		return;
	gotcha->p_damcap += STABDAM;
	gotcha->p_damage -= STABDAM;
	if (gotcha->p_damage < 0)
		gotcha->p_damage = 0;
	(void) sprintf(Buf, "%2d/%2d", gotcha->p_damage, gotcha->p_damcap);
	cgoto(gotcha, STAT_DAM_ROW, STAT_VALUE_COL);
	outstr(gotcha, Buf, 5);
	(void) sprintf(Buf, "%3d", (gotcha->p_damcap - MAXDAM) / 2);
	cgoto(gotcha, STAT_KILL_ROW, STAT_VALUE_COL);
	outstr(gotcha, Buf, 3);
	(void) sprintf(Buf, "%5.2f", gotcha->p_ident->i_score);
	for (ouch = Player; ouch < End_player; ouch++) {
		cgoto(ouch, STAT_PLAY_ROW + 1 + (gotcha - Player),
			STAT_NAME_COL);
		outstr(ouch, Buf, 5);
	}
# ifdef MONITOR
	for (ouch = Monitor; ouch < End_monitor; ouch++) {
		cgoto(ouch, STAT_PLAY_ROW + 1 + (gotcha - Player),
			STAT_NAME_COL);
		outstr(ouch, Buf, 5);
a558 1
# endif
d563 3
a565 1
 *	Kill off a player and take him out of the game.
d572 1
a572 1
	int	i, len;
d579 1
d582 1
d584 1
d588 2
a589 1
	len = strlen(pp->p_death);	/* Display the cause of death */
d591 4
a594 4
	cgoto(pp, HEIGHT / 2, x);
	outstr(pp, pp->p_death, len);
	for (i = 1; i < len; i++)
		pp->p_death[i] = '-';
d597 4
a600 4
	cgoto(pp, HEIGHT / 2 - 1, x);
	outstr(pp, pp->p_death, len);
	cgoto(pp, HEIGHT / 2 + 1, x);
	outstr(pp, pp->p_death, len);
a604 1
# ifdef MONITOR
d606 5
a610 1
# endif
d613 1
d616 1
d620 5
a624 4
		i = rand_num(pp->p_ammo);
		x = rand_num(pp->p_ammo);
		if (x > i)
			i = x;
d626 14
a639 8
			x = 0;
		else if (i == pp->p_ammo - 1) {
			x = pp->p_ammo;
			len = SLIME;
		}
		else {
			for (x = MAXBOMB - 1; x > 0; x--)
				if (i >= shot_req[x])
d641 2
a642 2
			for (y = MAXSLIME - 1; y > 0; y--)
				if (i >= slime_req[y])
d644 4
a647 3
			if (y >= 0 && slime_req[y] > shot_req[x]) {
				x = slime_req[y];
				len = SLIME;
d649 17
a665 9
			else if (x != 0) {
				len = shot_type[x];
				x = shot_req[x];
			}
		}
		if (x > 0) {
			(void) add_shot(len, pp->p_y, pp->p_x, pp->p_face, x,
				(PLAYER *) NULL, TRUE, SPACE);
			(void) sprintf(Buf, "%s detonated.",
d667 2
a668 7
			for (np = Player; np < End_player; np++)
				message(np, Buf);
# ifdef MONITOR
			for (np = Monitor; np < End_monitor; np++)
				message(np, Buf);
# endif
# ifdef BOOTS
d670 1
d674 1
d677 2
d682 1
a689 1
# endif
d691 1
a691 1
# ifdef BOOTS
a700 1
# endif
d702 7
a708 3
# ifdef VOLCANO
		volcano += pp->p_ammo - x;
		if (rand_num(100) < volcano / 50) {
d713 2
a716 2
			for (np = Player; np < End_player; np++)
				message(np, "Volcano eruption.");
d718 3
a721 1
# endif
d723 3
a725 2
# ifdef	DRONE
		if (rand_num(100) < 2) {
d730 2
d733 2
a734 2
				shot_req[MINDSHOT +
				rand_num(MAXBOMB - MINDSHOT)],
a736 1
# endif
d738 2
a739 2
		sendcom(pp, ENDWIN);
		(void) putc(' ', pp->p_output);
d742 1
d745 6
a750 2
			memcpy(pp, End_player, sizeof (PLAYER));
			(void) sprintf(Buf, "%5.2f%c%-10.10s %c",
a752 11
			i = STAT_PLAY_ROW + 1 + (pp - Player);
			for (np = Player; np < End_player; np++) {
				cgoto(np, i, STAT_NAME_COL);
				outstr(np, Buf, STAT_NAME_LEN);
			}
# ifdef MONITOR
			for (np = Monitor; np < End_monitor; np++) {
				cgoto(np, i, STAT_NAME_COL);
				outstr(np, Buf, STAT_NAME_LEN);
			}
# endif
d755 3
a757 11
		/* Erase the last player */
		i = STAT_PLAY_ROW + 1 + Nplayer;
		for (np = Player; np < End_player; np++) {
			cgoto(np, i, STAT_NAME_COL);
			ce(np);
		}
# ifdef MONITOR
		for (np = Monitor; np < End_monitor; np++) {
			cgoto(np, i, STAT_NAME_COL);
			ce(np);
		}
d760 4
a763 2
		sendcom(pp, ENDWIN);
		(void) putc(LAST_PLAYER, pp->p_output);
d766 1
d769 4
a772 2
			memcpy(pp, End_monitor, sizeof (PLAYER));
			(void) sprintf(Buf, "%5.5s %-10.10s %c", " ",
a773 20
			i = STAT_MON_ROW + 1 + (pp - Player);
			for (np = Player; np < End_player; np++) {
				cgoto(np, i, STAT_NAME_COL);
				outstr(np, Buf, STAT_NAME_LEN);
			}
			for (np = Monitor; np < End_monitor; np++) {
				cgoto(np, i, STAT_NAME_COL);
				outstr(np, Buf, STAT_NAME_LEN);
			}
		}

		/* Erase the last monitor */
		i = STAT_MON_ROW + 1 + (End_monitor - Monitor);
		for (np = Player; np < End_player; np++) {
			cgoto(np, i, STAT_NAME_COL);
			ce(np);
		}
		for (np = Monitor; np < End_monitor; np++) {
			cgoto(np, i, STAT_NAME_COL);
			ce(np);
d776 5
a781 1
# endif
d783 1
d787 2
a788 4
# ifdef INTERNET
		if (Test_socket > Socket)
			Num_fds = Test_socket;
# endif
a791 1
# ifdef MONITOR
a794 1
# endif
d807 4
a810 1
	return (range == 0 ? 0 : RN % range);
d845 1
a845 1
SIGNAL_TYPE
d851 8
a858 4
	for (pp = Player; pp < End_player; pp++) {
		cgoto(pp, HEIGHT, 0);
		sendcom(pp, ENDWIN);
		(void) putc(LAST_PLAYER, pp->p_output);
d860 1
a860 6
	}
# ifdef MONITOR
	for (pp = Monitor; pp < End_monitor; pp++) {
		cgoto(pp, HEIGHT, 0);
		sendcom(pp, ENDWIN);
		(void) putc(LAST_PLAYER, pp->p_output);
d862 2
a863 2
	}
# endif
a864 3
# ifdef AF_UNIX_HACK
	(void) unlink(Sock_name);
# endif
d866 2
d873 2
a874 1
 *	Print stats to requestor
d882 1
a882 1
	SOCKET	sockstruct;
d884 1
d886 1
a886 4
	/*
	 * Get the output stream ready
	 */
# ifdef INTERNET
a887 3
# else
	socklen = sizeof sockstruct - 1;
# endif
a891 1
# ifdef LOG
a892 3
# else
		warn("accept");
# endif
d895 8
a904 1
# ifdef LOG
a905 3
# else
		warn("fdopen");
# endif
d910 1
a910 3
	/*
	 * Send output to requestor
	 */
d913 6
a918 2
		fprintf(fp, "%s\t", ip->i_name);
		if (strlen(ip->i_name) < 8)
d927 7
a933 10
		if (ip->i_team == ' ') {
			fprintf(fp, "%s\t", ip->i_name);
			if (strlen(ip->i_name) < 8)
				putc('\t', fp);
		}
		else {
			fprintf(fp, "%s[%c]\t", ip->i_name, ip->i_team);
			if (strlen(ip->i_name) + 3 < 8)
				putc('\t', fp);
		}
d944 1
a944 1
 *	Clear out the scores so the next session start clean
d951 1
d957 11
@


1.1
log
@Initial revision
@
text
@d2 1
a7 5

#include <sys/cdefs.h>
#ifndef lint
__RCSID("$NetBSD: driver.c,v 1.5 1997/10/20 00:37:16 lukem Exp $");
#endif /* not lint */
@


1.1.1.1
log
@hunt (from NetBSD)
@
text
@@
