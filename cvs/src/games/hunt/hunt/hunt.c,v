head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.2
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.21.0.6
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.2
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.28
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.26
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.22
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.20
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.18
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.16
	OPENBSD_5_0:1.13.0.14
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.12
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.10
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.6
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.8
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.4
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.4
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.11.0.16
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.14
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.12
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.7.0.6
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	initial:1.1.1.1
	hunt:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2017.04.08.22.50.41;	author gsoares;	state Exp;
branches;
next	1.21;
commitid	eVrvxejgUFgyfmTZ;

1.21
date	2016.03.07.12.07.56;	author mestre;	state Exp;
branches;
next	1.20;
commitid	NZhYxChmyb9vOEMM;

1.20
date	2016.01.10.14.10.39;	author mestre;	state Exp;
branches;
next	1.19;
commitid	uHkFLRJtNioh0rOz;

1.19
date	2016.01.07.21.37.53;	author mestre;	state Exp;
branches;
next	1.18;
commitid	OXn0Z5fMODgNmJpo;

1.18
date	2016.01.07.21.29.31;	author mestre;	state Exp;
branches;
next	1.17;
commitid	AgYVDd64zIiNi3fx;

1.17
date	2016.01.07.16.00.32;	author tb;	state Exp;
branches;
next	1.16;
commitid	IwzFE3fG5RnKTWNh;

1.16
date	2015.12.26.00.26.39;	author mestre;	state Exp;
branches;
next	1.15;
commitid	NcBz9zfScw6TwPoT;

1.15
date	2015.10.24.18.35.08;	author mmcc;	state Exp;
branches;
next	1.14;
commitid	ID7m2Ooc7hcP2yrW;

1.14
date	2014.11.16.04.49.48;	author guenther;	state Exp;
branches;
next	1.13;
commitid	8XNajyb9IqHkZEKg;

1.13
date	2008.03.17.09.17.56;	author sobrado;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.02.14.46.14;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.11.08.45.25;	author pjanzen;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.31.03.40.00;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.10;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.25.05.55.46;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	99.12.12.15.00.51;	author d;	state Exp;
branches;
next	1.6;

1.6
date	99.05.30.02.47.13;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	99.03.14.02.07.30;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	99.02.01.06.53.55;	author d;	state Exp;
branches;
next	1.3;

1.3
date	99.01.29.07.30.33;	author d;	state Exp;
branches;
next	1.2;

1.2
date	99.01.21.05.47.39;	author d;	state Exp;
branches;
next	1.1;

1.1
date	99.01.21.05.33.37;	author d;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.01.21.05.33.37;	author d;	state Exp;
branches;
next	;


desc
@@


1.22
log
@format string is better be literal
OK deraadt
@
text
@/*	$OpenBSD: hunt.c,v 1.21 2016/03/07 12:07:56 mestre Exp $	*/
/*	$NetBSD: hunt.c,v 1.8 1998/09/13 15:27:28 hubertf Exp $	*/
/*
 * Copyright (c) 1983-2003, Regents of the University of California.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are 
 * met:
 * 
 * + Redistributions of source code must retain the above copyright 
 *   notice, this list of conditions and the following disclaimer.
 * + Redistributions in binary form must reproduce the above copyright 
 *   notice, this list of conditions and the following disclaimer in the 
 *   documentation and/or other materials provided with the distribution.
 * + Neither the name of the University of California, San Francisco nor 
 *   the names of its contributors may be used to endorse or promote 
 *   products derived from this software without specific prior written 
 *   permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS 
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED 
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/socket.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <curses.h>
#include <netdb.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "display.h"
#include "hunt.h"
#include "list.h"
#include "client.h"

#ifndef __GNUC__
#define __attribute__(x)
#endif

FLAG	Am_monitor = FALSE;
int	Socket;
char	map_key[256];			/* what to map keys to */
FLAG	no_beep = FALSE;
char	*Send_message = NULL;

static char	*Sock_host;
static char	*use_port;
static FLAG	Query_driver = FALSE;
static FLAG	Show_scores = FALSE;
static struct sockaddr	Daemon;


static char	name[NAMELEN];
static char	team = '-';

static int	in_visual;

static void	dump_scores(void);
static long	env_init(long);
static void	fill_in_blanks(void);
__dead static void	leave(int, char *);
static void	sigterm(int);
static int	find_driver(void);

/*
 * main:
 *	Main program for local process
 */
int
main(int ac, char **av)
{
	int		c;
	extern int	optind;
	extern char	*optarg;
	long		enter_status;
	int		option;
	struct servent	*se;

	enter_status = env_init((long) Q_CLOAK);
	while ((c = getopt(ac, av, "Sbcfh:l:mn:op:qst:w:")) != -1) {
		switch (c) {
		case 'l':	/* rsh compatibility */
		case 'n':
			(void) strlcpy(name, optarg, sizeof name);
			break;
		case 't':
			team = *optarg;
			if (!isdigit((unsigned char)team) && team != ' ') {
				warnx("Team names must be numeric or space");
				team = '-';
			}
			break;
		case 'o':
			Otto_mode = TRUE;
			break;
		case 'm':
			Am_monitor = TRUE;
			break;
		case 'S':
			Show_scores = TRUE;
			break;
		case 'q':	/* query whether hunt is running */
			Query_driver = TRUE;
			break;
		case 'w':
			Send_message = optarg;
			break;
		case 'h':
			Sock_host = optarg;
			break;
		case 'p':
			use_port = optarg;
			Server_port = atoi(use_port);
			break;
		case 'c':
			enter_status = Q_CLOAK;
			break;
		case 'f':
			enter_status = Q_FLY;
			break;
		case 's':
			enter_status = Q_SCAN;
			break;
		case 'b':
			no_beep = !no_beep;
			break;
		default:
		usage:
			fprintf(stderr, "usage: %s [-bcfmqSs] [-n name] "
			    "[-p port] [-t team] [-w message] [[-h] host]\n",
			    getprogname());
			return 1;
		}
	}
	if (optind + 1 < ac)
		goto usage;
	else if (optind + 1 == ac)
		Sock_host = av[ac - 1];

	if (Server_port == 0) {
		se = getservbyname("hunt", "udp");
		if (se != NULL)
			Server_port = ntohs(se->s_port);
		else
			Server_port = HUNT_PORT;
	}

	if (Show_scores) {
		dump_scores();
		return 0;
	}

	if (Query_driver) {
		struct driver		*driver;

		probe_drivers(C_MESSAGE, Sock_host);
		while ((driver = next_driver()) != NULL) {
			printf("%d player%s hunting on %s!\n",
			    driver->response,
			    (driver->response == 1) ? "" : "s",
			    driver_name(driver));
			if (Sock_host)
				break;
		}
		return 0;
	}
	if (Otto_mode) {
		if (Am_monitor)
			errx(1, "otto mode incompatible with monitor mode");
		(void) strlcpy(name, "otto", sizeof name);
		team = ' ';
	} else
		fill_in_blanks();

	(void) fflush(stdout);
	display_open();
	in_visual = TRUE;
	if (LINES < SCREEN_HEIGHT || COLS < SCREEN_WIDTH) {
		errno = 0;
		leave(1, "Need a larger window");
	}
	display_clear_the_screen();
	(void) signal(SIGINT, intr);
	(void) signal(SIGTERM, sigterm);
	/* (void) signal(SIGPIPE, SIG_IGN); */

	Daemon.sa_len = 0;
    ask_driver:
	while (!find_driver()) {
		if (Am_monitor) {
			errno = 0;
			leave(1, "No one playing");
		}

		if (Sock_host == NULL) {
			errno = 0;
			leave(1, "huntd not running");
		}

		sleep(3);
	}
	Socket = -1;

	for (;;) {
		if (Socket != -1)
			close(Socket);

		Socket = socket(Daemon.sa_family, SOCK_STREAM, 0);
		if (Socket < 0)
			leave(1, "socket");

		option = 1;
		if (setsockopt(Socket, SOL_SOCKET, SO_USELOOPBACK,
		    &option, sizeof option) < 0)
			warn("setsockopt loopback");

		errno = 0;
		if (connect(Socket, &Daemon, Daemon.sa_len) == -1)  {
			if (errno == ECONNREFUSED)
				goto ask_driver;
			leave(1, "connect");
		}

		do_connect(name, team, enter_status);
		if (Send_message != NULL) {
			do_message();
			if (enter_status == Q_MESSAGE)
				break;
			Send_message = NULL;
			continue;
		}
		playit();
		if ((enter_status = quit(enter_status)) == Q_QUIT)
			break;
	}
	leave(0, NULL);
	return 0;
}

/*
 * Set Daemon to be the address of a hunt driver, or return 0 on failure.
 *
 * We start quietly probing for drivers. As soon as one driver is found
 * we show it in the list. If we run out of drivers and we only have one
 * then we choose it. Otherwise we present a list of the found drivers.
 */
static int
find_driver(void)
{
	int last_driver, numdrivers, waiting, is_current;
	struct driver *driver;
	int c;
	char buf[80];
	const char *name;

	probe_drivers(Am_monitor ? C_MONITOR : C_PLAYER, Sock_host);

	last_driver = -1;
	numdrivers = 0;
	waiting = 1;
	for (;;) {
		if (numdrivers == 0) {
			/* Silently wait for at least one driver */
			driver = next_driver();
		} else if (!waiting || (driver = 
		    next_driver_fd(STDIN_FILENO)) == (struct driver *)-1) {
			/* We have a key waiting, or no drivers left */
			c = getchar();
			if (c == '\r' || c == '\n' || c == ' ') {
				if (numdrivers == 1)
					c = 'a';
				else if (last_driver != -1)
					c = 'a' + last_driver;
			}
			if (c < 'a' || c >= numdrivers + 'a') {
				display_beep();
				continue;
			}
			driver = &drivers[c - 'a'];
			break;
		}

		if (driver == NULL) {
			waiting = 0;
			if (numdrivers == 0) {
				probe_cleanup();
				return 0;	/* Failure */
			}
			if (numdrivers == 1) {
				driver = &drivers[0];
				break;
			}
			continue;
		}

		/* Use the preferred host straight away. */
		if (Sock_host)
			break;

		if (numdrivers == 0) {
			display_clear_the_screen();
			display_move(1, 0);
			display_put_str("Pick one:");
		}

		/* Mark the last driver we used with an asterisk */
		is_current = (last_driver == -1 && Daemon.sa_len != 0 && 
		    memcmp(&Daemon, &driver->addr, Daemon.sa_len) == 0);
		if (is_current)
			last_driver = numdrivers;

		/* Display it in the list if there is room */
		if (numdrivers < HEIGHT - 3) {
			name = driver_name(driver);
			display_move(3 + numdrivers, 0);
			snprintf(buf, sizeof buf, "%6c %c    %s", 
			    is_current ? '*' : ' ', 'a' + numdrivers, name);
			display_put_str(buf);
		}

		/* Clear the last 'Enter letter' line if any */
		display_move(4 + numdrivers, 0);
		display_clear_eol();

		if (last_driver != -1)
			snprintf(buf, sizeof buf, "Enter letter [%c]: ", 
			    'a' + last_driver);
		else
			snprintf(buf, sizeof buf, "Enter letter: ");

		display_move(5 + numdrivers, 0);
		display_put_str(buf);
		display_refresh();

		numdrivers++;
	}

	display_clear_the_screen();
	Daemon = driver->addr;

	probe_cleanup();
	return 1;		/* Success */
}

static void
dump_scores(void)
{
	struct	driver *driver;
	int	s, cnt, i;
	char	buf[1024];

	probe_drivers(C_SCORES, Sock_host);
	while ((driver = next_driver()) != NULL) {
		printf("\n%s:\n", driver_name(driver));
		fflush(stdout);

		if ((s = socket(driver->addr.sa_family, SOCK_STREAM, 0)) < 0) {
			warn("socket");
			continue;
		}
		if (connect(s, &driver->addr, driver->addr.sa_len) < 0) {
			warn("connect");
			close(s);
			continue;
		}
		while ((cnt = read(s, buf, sizeof buf)) > 0) {
			/* Whittle out bad characters */
			for (i = 0; i < cnt; i++)
				if ((buf[i] < ' ' || buf[i] > '~') &&
				    buf[i] != '\n' && buf[i] != '\t')
					buf[i] = '?';
			fwrite(buf, cnt, 1, stdout);
		}
		if (cnt < 0)
			warn("read");
		(void)close(s);
		if (Sock_host)
			break;
	}
	probe_cleanup();
}


/*
 * bad_con:
 *	We had a bad connection.  For the moment we assume that this
 *	means the game is full.
 */
void
bad_con(void)
{
	leave(1, "lost connection to huntd");
}

/*
 * bad_ver:
 *	version number mismatch.
 */
void
bad_ver(void)
{
	errno = 0;
	leave(1, "Version number mismatch. No go.");
}

/*
 * sigterm:
 *	Handle a terminate signal
 */
static void
sigterm(int dummy)
{
	leave(0, NULL);
}

/*
 * rmnl:
 *	Remove a '\n' at the end of a string if there is one
 */
static void
rmnl(char *s)
{
	char	*cp;

	cp = strrchr(s, '\n');
	if (cp != NULL)
		*cp = '\0';
}

/*
 * intr:
 *	Handle a interrupt signal
 */
void
intr(int dummy)
{
	int	ch;
	int	explained;
	int	y, x;

	(void) signal(SIGINT, SIG_IGN);
	display_getyx(&y, &x);
	display_move(HEIGHT, 0);
	display_put_str("Really quit? ");
	display_clear_eol();
	display_refresh();
	explained = FALSE;
	for (;;) {
		ch = getchar();
		if (isupper(ch))
			ch = tolower(ch);
		if (ch == 'y') {
			if (Socket != 0) {
				(void) write(Socket, "q", 1);
				(void) close(Socket);
			}
			leave(0, NULL);
		}
		else if (ch == 'n') {
			(void) signal(SIGINT, intr);
			display_move(y, x);
			display_refresh();
			return;
		}
		if (!explained) {
			display_put_str("(Yes or No) ");
			display_refresh();
			explained = TRUE;
		}
		display_beep();
		display_refresh();
	}
}

/*
 * leave:
 *	Leave the game somewhat gracefully, restoring all current
 *	tty stats.
 */
static void
leave(int eval, char *mesg)
{
	int saved_errno;

	saved_errno = errno;
	if (in_visual) {
		display_move(HEIGHT, 0);
		display_refresh();
		display_end();
	}
	errno = saved_errno;

	if (errno == 0 && mesg != NULL)
		errx(eval, "%s", mesg);
	else if (mesg != NULL)
		err(eval, "%s", mesg);
	exit(eval);
}

/*
 * env_init:
 *	initialise game parameters from the HUNT envvar
 */
static long
env_init(long enter_status)
{
	int	i;
	char	*envp, *envname, *s;

	/* Map all keys to themselves: */
	for (i = 0; i < 256; i++)
		map_key[i] = (char) i;

	envname = NULL;
	if ((envp = getenv("HUNT")) != NULL) {
		while ((s = strpbrk(envp, "=,")) != NULL) {
			if (strncmp(envp, "cloak,", s - envp + 1) == 0) {
				enter_status = Q_CLOAK;
				envp = s + 1;
			}
			else if (strncmp(envp, "scan,", s - envp + 1) == 0) {
				enter_status = Q_SCAN;
				envp = s + 1;
			}
			else if (strncmp(envp, "fly,", s - envp + 1) == 0) {
				enter_status = Q_FLY;
				envp = s + 1;
			}
			else if (strncmp(envp, "nobeep,", s - envp + 1) == 0) {
				no_beep = TRUE;
				envp = s + 1;
			}
			else if (strncmp(envp, "name=", s - envp + 1) == 0) {
				envname = s + 1;
				if ((s = strchr(envp, ',')) == NULL) {
					*envp = '\0';
					strlcpy(name, envname, sizeof name);
					break;
				}
				*s = '\0';
				strlcpy(name, envname, sizeof name);
				envp = s + 1;
			}
			else if (strncmp(envp, "port=", s - envp + 1) == 0) {
				use_port = s + 1;
				Server_port = atoi(use_port);
				if ((s = strchr(envp, ',')) == NULL) {
					*envp = '\0';
					break;
				}
				*s = '\0';
				envp = s + 1;
			}
			else if (strncmp(envp, "host=", s - envp + 1) == 0) {
				Sock_host = s + 1;
				if ((s = strchr(envp, ',')) == NULL) {
					*envp = '\0';
					break;
				}
				*s = '\0';
				envp = s + 1;
			}
			else if (strncmp(envp, "message=", s - envp + 1) == 0) {
				Send_message = s + 1;
				if ((s = strchr(envp, ',')) == NULL) {
					*envp = '\0';
					break;
				}
				*s = '\0';
				envp = s + 1;
			}
			else if (strncmp(envp, "team=", s - envp + 1) == 0) {
				team = *(s + 1);
				if (!isdigit((unsigned char)team))
					team = ' ';
				if ((s = strchr(envp, ',')) == NULL) {
					*envp = '\0';
					break;
				}
				*s = '\0';
				envp = s + 1;
			}			/* must be last option */
			else if (strncmp(envp, "mapkey=", s - envp + 1) == 0) {
				for (s = s + 1; *s != '\0'; s += 2) {
					map_key[(unsigned int) *s] = *(s + 1);
					if (*(s + 1) == '\0') {
						break;
					}
				}
				*envp = '\0';
				break;
			} else {
				*s = '\0';
				printf("unknown option %s\n", envp);
				if ((s = strchr(envp, ',')) == NULL) {
					*envp = '\0';
					break;
				}
				envp = s + 1;
			}
		}
		if (*envp != '\0') {
			if (envname == NULL)
				strlcpy(name, envp, sizeof name);
			else
				printf("unknown option %s\n", envp);
		}
	}
	return enter_status;
}

/*
 * fill_in_blanks:
 *	quiz the user for the information they didn't provide earlier
 */
static void
fill_in_blanks(void)
{
	int	i;
	char	*cp;

again:
	if (name[0] != '\0') {
		printf("Entering as '%s'", name);
		if (team != ' ' && team != '-')
			printf(" on team %c.\n", team);
		else
			putchar('\n');
	} else {
		printf("Enter your code name: ");
		if (fgets(name, sizeof name, stdin) == NULL)
			exit(1);
	}
	rmnl(name);
	if (name[0] == '\0') {
		printf("You have to have a code name!\n");
		goto again;
	}
	for (cp = name; *cp != '\0'; cp++)
		if (!isprint((unsigned char)*cp)) {
			name[0] = '\0';
			printf("Illegal character in your code name.\n");
			goto again;
		}
	if (team == '-') {
		printf("Enter your team (0-9 or nothing): ");
		i = getchar();
		if (isdigit(i))
			team = i;
		else if (i == '\n' || i == EOF || i == ' ')
			team = ' ';
		/* ignore trailing chars */
		while (i != '\n' && i != EOF)
			i = getchar();
		if (team == '-') {
			printf("Teams must be numeric.\n");
			goto again;
		}
	}
}
@


1.21
log
@- General changes:
- Remove -? from getopt(3) options, but still keep (or add) -h where applicable
- Replace hardcoded program strings by getprogname(3)

- Specific changes:
- atc(6): this used -? and -u for usage(), remove both from game and manpage
- bcd(6): use __progname instead of getprogname(3), no need to include stdlib.h
- hunt(6): replace fputs(3) by fprintf(3)

OK tb@@ after his suggestions
@
text
@d1 1
a1 1
/*	$OpenBSD: hunt.c,v 1.20 2016/01/10 14:10:39 mestre Exp $	*/
d509 1
a509 1
		errx(eval, mesg);
d511 1
a511 1
		err(eval, mesg);
@


1.20
log
@Remove needless casts to (char *) NULL. Some were kept, namely for execl(3)
last arguments since "The list of arguments must be terminated by a null
null pointer" of type char *

Suggested by and OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hunt.c,v 1.19 2016/01/07 21:37:53 mestre Exp $	*/
d144 3
a146 3
			fputs("usage: hunt [-bcfmqSs] [-n name] [-p port] "
			    "[-t team] [-w message] [[-h] host]\n",
			    stderr);
@


1.19
log
@ANSIfy hunt(6)

Note: casted 2 args to struct sockaddr * on list.c to shut off compiler
warnings, and also changed an int len to socklen_t since recvfrom(2) receives
the last argument as the latter.

I'm running out of credits, but this was once again with great help and OK from
tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hunt.c,v 1.17 2016/01/07 16:00:32 tb Exp $	*/
d251 1
a251 1
	leave(0, (char *) NULL);
d428 1
a428 1
	leave(0, (char *) NULL);
d472 1
a472 1
			leave(0, (char *) NULL);
@


1.18
log
@Headers cleanup and sorting

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hunt.c,v 1.16 2015/12/26 00:26:39 mestre Exp $	*/
d85 1
a85 3
main(ac, av)
	int	ac;
	char	**av;
d147 1
a147 1
			exit(1);
d165 1
a165 1
		exit(0);
d180 1
a180 1
		exit(0);
d252 1
a252 2
	/* NOTREACHED */
	return(0);
d263 1
a263 1
find_driver()
d361 1
a361 1
dump_scores()
d405 1
a405 1
bad_con()
d415 1
a415 1
bad_ver()
d426 1
a426 2
sigterm(dummy)
	int dummy;
d436 1
a436 2
rmnl(s)
	char	*s;
d450 1
a450 2
intr(dummy)
	int dummy;
d496 1
a496 3
leave(eval, mesg)
	int	eval;
	char	*mesg;
d520 1
a520 2
env_init(enter_status)
	long	enter_status;
d632 1
a632 1
fill_in_blanks()
@


1.17
log
@Some basic code maintenance in games/

- in main() replace exit with return
- drop some /* NOTREACHED */ lint comments along the way.
- make more use of standard CFLAGS, esp. -Wimplicit-function-declaration
- add and sort some headers when needed
- add straightforward pledges to some programs used at compile time

discussed with and ok mestre@@
@
text
@d34 2
d40 1
a44 11
#include <netdb.h>

#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <net/if.h>

#include <arpa/inet.h>
d46 1
d48 1
a48 1
#include "display.h"
a49 1
#include "list.h"
d149 1
a149 1
			return 1;
d167 1
a167 1
		return 0;
d182 1
a182 1
		return 0;
d254 2
a255 1
	return 0;
@


1.16
log
@Set as __dead a few more functions, that don't return, on games/

With precious tip, help and also OK from tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hunt.c,v 1.15 2015/10/24 18:35:08 mmcc Exp $	*/
d157 1
a157 1
			exit(1);
d175 1
a175 1
		exit(0);
d190 1
a190 1
		exit(0);
d262 1
a262 2
	/* NOTREACHED */
	return(0);
@


1.15
log
@Cast ctype functions' argument to unsigned char.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hunt.c,v 1.14 2014/11/16 04:49:48 guenther Exp $	*/
d84 1
a84 1
static void	leave(int, char *) __attribute__((__noreturn__));
@


1.14
log
@Eliminate pointless use of <sys/param.h>, <sys/file.h>, <sys/sockio.h>,
    and <sys/ttydefaults.h>
Replace MAXPATHLEN with PATH_MAX and MAXLOGNAME with LOGIN_NAME_MAX
Pull in <limits.h> where needed
Prefer sizeof(var) over MAXFOO or FOO_MAX

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hunt.c,v 1.13 2008/03/17 09:17:56 sobrado Exp $	*/
d113 1
a113 1
			if (!isdigit(team) && team != ' ') {
d606 1
a606 1
				if (!isdigit(team))
d672 1
a672 1
		if (!isprint(*cp)) {
@


1.13
log
@synchronization between usage and synopsis; add some missing "usage:"'s

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hunt.c,v 1.12 2007/04/02 14:46:14 jmc Exp $	*/
a47 2
#include <sys/ioctl.h>
#include <sys/sockio.h>
@


1.12
log
@sort options; from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: hunt.c,v 1.11 2003/06/11 08:45:25 pjanzen Exp $	*/
d156 3
a158 3
			fputs(
"usage:\thunt [-bcfmqSs] [-n name] [-p port] [-t team] [-w message] [[-h] host]\n",
			stderr);
@


1.11
log
@New license from the official hunt release at
ftp://ftp.cgl.ucsf.edu/pub/hunt.shar.Z -- it has been approved by all three
authors (Conrad Huang, Ken Arnold, and Greg Couch).
@
text
@d1 1
a1 1
/*	$OpenBSD: hunt.c,v 1.10 2002/05/31 03:40:00 pjanzen Exp $	*/
d157 1
a157 1
"usage:\thunt [-bcfmqsS] [-n name] [-p port] [-t team] [-w message] [[-h] host]\n",
@


1.10
log
@No dm -> no need to revoke setegid.
@
text
@d1 1
a1 1
/*	$OpenBSD: hunt.c,v 1.9 2002/02/16 21:27:10 millert Exp $	*/
d4 28
a31 3
 *  Hunt
 *  Copyright (c) 1985 Conrad C. Huang, Gregory S. Couch, Kenneth C.R.C. Arnold
 *  San Francisco, California
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: hunt.c,v 1.8 2001/06/25 05:55:46 pvalchev Exp $	*/
a79 4

	/* Revoke privs: */
	setegid(getgid());
	setgid(getgid());
@


1.8
log
@sync usage message with reality, alphabetize option order; ok pjanzen
@
text
@d1 1
a1 1
/*	$OpenBSD: hunt.c,v 1.7 1999/12/12 15:00:51 d Exp $	*/
d58 6
a63 6
static void	dump_scores __P((void));
static long	env_init __P((long));
static void	fill_in_blanks __P((void));
static void	leave __P((int, char *)) __attribute__((__noreturn__));
static void	sigterm __P((int));
static int	find_driver __P((void));
@


1.7
log
@Use netdb to find the hunt service port.
Use the new probe_drivers().
Better warning messages about the -t option.
Correct error message for monitors that find nothing.
In the screen where the user has to choose the huntd host,
show new hosts as they come in.
Check statistics information for 'bad' characters.
Allow space to be a team name (same as no team)

reviewed by pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hunt.c,v 1.6 1999/05/30 02:47:13 pjanzen Exp $	*/
d136 1
a136 1
"usage:\thunt [-qmcsfS] [-n name] [-t team] [-p port] [-w message] [host]\n",
@


1.6
log
@Only use __attribute__ if __GNUC__ is defined
@
text
@d1 1
a1 1
/*	$OpenBSD: hunt.c,v 1.5 1999/03/14 02:07:30 pjanzen Exp $	*/
a8 2
#include <sys/stat.h>
#include <sys/time.h>
d17 1
d19 2
a20 1
#include <netdb.h>
d23 3
d27 2
a30 1

d34 1
a45 1
static u_int16_t Server_port = HUNT_PORT;
d50 1
a50 1
static struct sockaddr_in	Daemon;
d58 1
a58 1
static void	dump_scores __P((struct sockaddr_in));
a61 1
static struct sockaddr_in *list_drivers __P((void));
d63 1
a63 2
static void	find_driver __P((FLAG));
static void	start_driver __P((void));
d78 2
d95 1
a95 1
				warnx("Team names must be numeric");
d146 8
d155 1
a155 4
		struct sockaddr_in	*hosts;

		for (hosts = list_drivers(); hosts->sin_port != 0; hosts += 1)
			dump_scores(*hosts);
d158 1
d160 1
a160 1
		struct sockaddr_in	*hosts;
d162 2
a163 7
		for (hosts = list_drivers(); hosts->sin_port != 0; hosts += 1) {
			struct	hostent	*hp;
			int	num_players;

			hp = gethostbyaddr((char *) &hosts->sin_addr,
					sizeof hosts->sin_addr, AF_INET);
			num_players = ntohs(hosts->sin_port);
d165 5
a169 3
				num_players, (num_players == 1) ? "" : "s",
				hp != NULL ? hp->h_name :
				inet_ntoa(hosts->sin_addr));
d193 7
a199 2
	for (;;) {
		find_driver(TRUE);
d201 1
a201 1
		if (Daemon.sin_port == 0) {
d203 1
a203 1
			leave(1, "Game not found, try again");
d206 23
a228 21
	jump_in:
		do {
			int	option;

			Socket = socket(AF_INET, SOCK_STREAM, 0);
			if (Socket < 0)
				leave(1, "socket");
			option = 1;
			if (setsockopt(Socket, SOL_SOCKET, SO_USELOOPBACK,
			    &option, sizeof option) < 0)
				warn("setsockopt loopback");
			errno = 0;
			if (connect(Socket, (struct sockaddr *) &Daemon,
			    sizeof Daemon) < 0) {
				if (errno != ECONNREFUSED)
					leave(1, "connect");
			}
			else
				break;
			sleep(1);
		} while (close(Socket) == 0);
d236 1
a236 2
			/* don't continue as that will call find_driver */
			goto jump_in;
d247 7
a253 1
# ifdef BROADCAST
d255 1
a255 30
broadcast_vec(s, vector)
	int			s;		/* socket */
	struct	sockaddr	**vector;
{
	char			if_buf[BUFSIZ];
	struct	ifconf		ifc;
	struct	ifreq		*ifr;
	unsigned int		n;
	int			vec_cnt;

	*vector = NULL;
	ifc.ifc_len = sizeof if_buf;
	ifc.ifc_buf = if_buf;
	if (ioctl(s, SIOCGIFCONF, (char *) &ifc) < 0)
		return 0;
	vec_cnt = 0;
	n = ifc.ifc_len / sizeof (struct ifreq);
	*vector = (struct sockaddr *) malloc(n * sizeof (struct sockaddr));
	if (*vector == NULL)
		leave(1, "malloc");
	for (ifr = ifc.ifc_req; n != 0; n--, ifr++)
		if (ioctl(s, SIOCGIFBRDADDR, ifr) >= 0)
			memcpy(&(*vector)[vec_cnt++], &ifr->ifr_addr,
				sizeof (*vector)[0]));
	return vec_cnt;
}
# endif

static struct sockaddr_in	*
list_drivers()
d257 31
a287 98
	u_short			msg;
	u_short			port_num;
	static struct sockaddr_in		test;
	int			test_socket;
	int			namelen;
	char			local_name[MAXHOSTNAMELEN + 1];
	static int		initial = TRUE;
	static struct in_addr	local_address;
	struct hostent		*hp;
# ifdef BROADCAST
	static	int		brdc;
	static	struct sockaddr_in		*brdv;
# else
	u_long			local_net;
# endif
	int			i;
	static	struct sockaddr_in		*listv;
	static	unsigned int	listmax;
	unsigned int		listc;
	fd_set			mask;
	struct timeval		wait;

	if (initial) {			/* do one time initialization */
# ifndef BROADCAST
		sethostent(1);		/* don't bother to close host file */
# endif
		if (gethostname(local_name, sizeof local_name) < 0)
			leave(1, "gethostname");
		local_name[sizeof(local_name) - 1] = '\0';
		if ((hp = gethostbyname(local_name)) == NULL)
			leave(1, "gethostbyname");
		local_address = * ((struct in_addr *) hp->h_addr);

		listmax = 20;
		listv = (struct sockaddr_in *) malloc(listmax * sizeof (struct sockaddr_in));
		if (listv == NULL)
			leave(1, "malloc");
	} else if (Sock_host != NULL)
		return listv;		/* address already valid */

	test_socket = socket(AF_INET, SOCK_DGRAM, 0);
	if (test_socket < 0)
		leave(1, "socket");
	test.sin_family = AF_INET;
	test.sin_port = htons(Server_port);
	listc = 0;

	if (Sock_host != NULL) {	/* explicit host given */
		if ((hp = gethostbyname(Sock_host)) == NULL) 
			leave(1, "gethostbyname");
		test.sin_addr = *((struct in_addr *) hp->h_addr);
		goto test_one_host;
	}

	if (!initial) {
		/* favor host of previous session by broadcasting to it first */
		test.sin_addr = Daemon.sin_addr;
		msg = htons(C_PLAYER);		/* Must be playing! */
		(void) sendto(test_socket, (char *) &msg, sizeof msg, 0,
		    (struct sockaddr *) &test, sizeof test);
	}

# ifdef BROADCAST
	if (initial)
		brdc = broadcast_vec(test_socket, (struct sockaddr **) &brdv);

	if (brdc <= 0) {
		initial = FALSE;
		test.sin_addr = local_address;
		goto test_one_host;
	}

# ifdef SO_BROADCAST
	/* Sun's will broadcast even though this option can't be set */
	option = 1;
	if (setsockopt(test_socket, SOL_SOCKET, SO_BROADCAST,
	    &option, sizeof option) < 0)
		leave(1, "setsockopt broadcast");
# endif

	/* send broadcast packets on all interfaces */
	msg = htons(C_TESTMSG());
	for (i = 0; i < brdc; i++) {
		test.sin_addr = brdv[i].sin_addr;
		if (sendto(test_socket, (char *) &msg, sizeof msg, 0,
		    (struct sockaddr *) &test, test) < 0)
			leave(1, "sendto");
	}
# else /* !BROADCAST */
	/* loop thru all hosts on local net and send msg to them. */
	msg = htons(C_TESTMSG());
	local_net = inet_netof(local_address);
	sethostent(0);		/* rewind host file */
	while ((hp = gethostent()) != NULL) {
		if (local_net == inet_netof(* ((struct in_addr *) hp->h_addr))){
			test.sin_addr = * ((struct in_addr *) hp->h_addr);
			(void) sendto(test_socket, (char *) &msg, sizeof msg, 0,
			    (struct sockaddr *) &test, sizeof test);
a288 2
	}
#endif
d290 10
a299 30
get_response:
	namelen = sizeof listv[0];
	errno = 0;
	wait.tv_sec = 1;
	wait.tv_usec = 0;
	for (;;) {
		if (listc + 1 >= listmax) {
			listmax += 20;
			listv = (struct sockaddr_in *) realloc((char *) listv,
						listmax * sizeof listv[0]);
			if (listv == NULL)
				leave(1, "realloc");
		}

		FD_ZERO(&mask);
		FD_SET(test_socket, &mask);
		if (select(test_socket + 1, &mask, NULL, NULL, &wait) == 1 &&
		    recvfrom(test_socket, (char *) &port_num, sizeof(port_num),
		    0, (struct sockaddr *) &listv[listc], &namelen) > 0) {
			/*
			 * Note that we do *not* convert from network to host
			 * order since the port number *should* be in network
			 * order:
			 */
			for (i = 0; i < listc; i += 1)
				if (listv[listc].sin_addr.s_addr
				== listv[i].sin_addr.s_addr)
					break;
			if (i == listc)
				listv[listc++].sin_port = port_num;
d303 24
a326 2
		if (errno != 0 && errno != EINTR)
			leave(1, "select/recvfrom");
d328 9
a336 16
		/* terminate list with local address */
		listv[listc].sin_family = AF_INET;
		listv[listc].sin_addr = local_address;
		listv[listc].sin_port = htons(0);

		(void) close(test_socket);
		initial = FALSE;
		return listv;
	}

test_one_host:
	msg = htons(C_TESTMSG());
	(void) sendto(test_socket, (char *) &msg, sizeof msg, 0,
	    (struct sockaddr *) &test, sizeof test);
	goto get_response;
}
d338 3
a340 5
static void
find_driver(do_startup)
	FLAG	do_startup;
{
	struct sockaddr_in	*hosts;
d342 2
a343 3
	hosts = list_drivers();
	if (hosts[0].sin_port != htons(0)) {
		int	i, c;
d345 2
a346 40
		if (hosts[1].sin_port == htons(0)) {
			Daemon = hosts[0];
			return;
		}
		/* go thru list and return host that matches daemon */
		display_clear_the_screen();
		display_move(1, 0);
		display_put_str("Pick one:");
		for (i = 0; i < HEIGHT - 4 && hosts[i].sin_port != htons(0);
								i += 1) {
			struct	hostent	*hp;
			char	buf[80];

			display_move(3 + i, 0);
			hp = gethostbyaddr((char *) &hosts[i].sin_addr,
					sizeof hosts[i].sin_addr, AF_INET);
			(void) snprintf(buf, sizeof buf,
				"%8c    %.64s", 'a' + i,
				hp != NULL ? hp->h_name
				: inet_ntoa(hosts->sin_addr));
			display_put_str(buf);
		}
		display_move(4 + i, 0);
		display_put_str("Enter letter: ");
		display_refresh();
		while (!islower(c = getchar()) || (c -= 'a') >= i) {
			display_beep();
			display_refresh();
		}
		Daemon = hosts[c];
		display_clear_the_screen();
		return;
	}
	if (!do_startup)
		return;

	start_driver();
	sleep(2);
	find_driver(FALSE);
}
d348 2
a349 22
static void
dump_scores(host)
	struct sockaddr_in	host;
{
	struct	hostent	*hp;
	int	s;
	char	buf[BUFSIZ];
	int	cnt;

	hp = gethostbyaddr((char *) &host.sin_addr, sizeof host.sin_addr,
								AF_INET);
	printf("\n%s:\n", hp != NULL ? hp->h_name : inet_ntoa(host.sin_addr));
	fflush(stdout);

	s = socket(AF_INET, SOCK_STREAM, 0);
	if (s < 0)
		leave(1, "socket");
	if (connect(s, (struct sockaddr *) &host, sizeof host) < 0)
		leave(1, "connect");
	while ((cnt = read(s, buf, sizeof buf)) > 0)
		write(fileno(stdout), buf, cnt);
	(void) close(s);
d353 1
a353 1
start_driver()
d355 8
a362 4
	if (Am_monitor) {
		errno = 0;
		leave(1, "No one playing");
	}
d364 22
a385 3
	if (Sock_host != NULL) {
		sleep(3);
		return;
d387 2
a389 3
	errno = 0;
	leave(1, "huntd not running");
}
d663 1
a663 1
		else if (i == '\n' || i == EOF)
@


1.5
log
@Access control works now; also, some minor tidying and man page fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: hunt.c,v 1.4 1999/02/01 06:53:55 d Exp $	*/
d31 3
@


1.4
log
@avoid denial of service attacks on server port; extra conf vars; fix otto
@
text
@d1 1
a1 1
/*	$OpenBSD: hunt.c,v 1.3 1999/01/29 07:30:33 d Exp $	*/
a30 4

/*
 * Some old versions of curses don't have these defined
 */
@


1.3
log
@major changes: security, curses, config
@
text
@d1 1
a1 1
/*	$OpenBSD: hunt.c,v 1.2 1999/01/21 05:47:39 d Exp $	*/
d167 3
a169 1
	if (Otto_mode)
d171 2
a172 1
	else
d185 1
a185 1
	(void) signal(SIGPIPE, SIG_IGN);
@


1.2
log
@ident for OpenBSD
mandoc-ify manual pages
use -locurses
@
text
@d1 1
a2 1
/*	$OpenBSD$	*/
d9 21
a29 14
# include	<sys/stat.h>
# include	<sys/time.h>
# include	<ctype.h>
# include	<err.h>
# include	<errno.h>
# include	<curses.h>
# include	<signal.h>
# include	<stdlib.h>
# include	<string.h>
# if !defined(USE_CURSES) && defined(BSD_RELEASE) && BSD_RELEASE >= 44
# include	<termios.h>
static struct termios saved_tty;
# endif
# include	<unistd.h>
a30 1
# include	"hunt.h"
a34 3
# if !defined(cbreak) && (!defined(BSD_RELEASE) || BSD_RELEASE < 44)
# define	cbreak()	crmode()
# endif
a35 19
# if !defined(USE_CURSES) || !defined(TERMINFO)
# define	beep()		(void) putchar(CTRL('G'))
# endif
# if !defined(USE_CURSES)
# undef		refresh
# define	refresh()	(void) fflush(stdout);
# endif
# ifdef USE_CURSES
# define	clear_eol()	clrtoeol()
# define	put_ch		addch
# define	put_str		addstr
# endif

#if !defined(BSD_RELEASE) || BSD_RELEASE < 44
extern int	_putchar();
#endif

FLAG	Last_player = FALSE;
# ifdef MONITOR
a36 4
# endif

char	Buf[BUFSIZ];

d38 2
a39 4
# ifdef INTERNET
char	*Sock_host;
char	*use_port;
FLAG	Query_driver = FALSE;
a40 2
FLAG	Show_scores = FALSE;
# endif
d42 6
a47 6
SOCKET	Daemon;
# ifdef	INTERNET
# define	DAEMON_SIZE	(sizeof Daemon)
# else
# define	DAEMON_SIZE	(sizeof Daemon - 1)
# endif
a48 2
char	map_key[256];			/* what to map keys to */
FLAG	no_beep;
d51 1
a51 1
static char	team = ' ';
d55 8
a62 10
extern int	cur_row, cur_col;

void	dump_scores __P((SOCKET));
long	env_init __P((long));
void	fill_in_blanks __P((void));
void	leave __P((int, char *)) __attribute__((__noreturn__));
int	main __P((int, char *[]));
# ifdef INTERNET
SOCKET *list_drivers __P((void));
# endif
a72 1
	char		*term;
a73 2
	extern int	errno;
	extern int	Otto_mode;
d78 4
d87 1
a87 1
			(void) strncpy(name, optarg, NAMELEN);
d91 1
a91 1
			if (!isdigit(team)) {
d93 1
a93 1
				team = ' ';
a96 4
# ifndef OTTO
			warnx("The -o flag is reserved for future use.");
			goto usage;
# else
a98 1
# endif
a99 1
# ifdef MONITOR
a100 3
# else
			warnx("The monitor was not compiled in.");
# endif
a101 1
# ifdef INTERNET
d116 1
a116 1
			Test_port = atoi(use_port);
a117 9
# else
		case 'S':
		case 'q':
		case 'w':
		case 'h':
		case 'p':
			wanrx("Need TCP/IP for S, q, w, h, and p options.");
			break;
# endif
a121 1
# ifdef FLY
a122 3
# else
			warnx("The flying code was not compiled in.");
# endif
a137 1
# ifdef INTERNET
a141 4
# else
	if (optind > ac)
		goto usage;
# endif
a142 1
# ifdef INTERNET
d144 1
a144 1
		SOCKET	*hosts;
d151 1
a151 1
		SOCKET	*hosts;
a166 2
# endif
# ifdef OTTO
d168 1
a168 1
		(void) strncpy(name, "otto", NAMELEN);
d170 1
a170 2
# endif
	fill_in_blanks();
d173 1
a173 20
	if (!isatty(0) || (term = getenv("TERM")) == NULL)
		errx(1, "no terminal type");
# ifdef USE_CURSES
	initscr();
	(void) noecho();
	(void) cbreak();
# else /* !USE_CURSES */
# if !defined(BSD_RELEASE) || BSD_RELEASE < 44
	_tty_ch = 0;
# endif
	gettmode();
	(void) setterm(term);
	(void) noecho();
	(void) cbreak();
# if defined(BSD_RELEASE) && BSD_RELEASE >= 44
	tcgetattr(0, &saved_tty);
# endif
	_puts(TI);
	_puts(VS);
# endif /* !USE_CURSES */
d175 2
a176 1
	if (LINES < SCREEN_HEIGHT || COLS < SCREEN_WIDTH)
d178 2
a179 1
	clear_the_screen();
a181 1
	(void) signal(SIGEMT, sigemt);
a182 3
#if !defined(USE_CURSES) && defined(SIGTSTP)
	(void) signal(SIGTSTP, tstp);
#endif
a184 1
# ifdef	INTERNET
d187 2
a188 1
		if (Daemon.sin_port == 0)
d190 1
d196 1
a196 1
			Socket = socket(SOCK_FAMILY, SOCK_STREAM, 0);
d198 1
a198 1
				err(1, "socket");
d205 2
a206 3
			    DAEMON_SIZE) < 0) {
				if (errno != ECONNREFUSED) {
					warn("connect");
a207 1
				}
a212 32
# else /* !INTERNET */
		/*
		 * set up a socket
		 */

		if ((Socket = socket(SOCK_FAMILY, SOCK_STREAM, 0)) < 0)
			err(1, "socket");

		/*
		 * attempt to connect the socket to a name; if it fails that
		 * usually means that the driver isn't running, so we start
		 * up the driver.
		 */

		Daemon.sun_family = SOCK_FAMILY;
		(void) strcpy(Daemon.sun_path, Sock_name);
		if (connect(Socket, &Daemon, DAEMON_SIZE) < 0) {
			if (errno != ENOENT) {
				warn("connect");
				leave(1, "connect2");
			}
			start_driver();

			do {
				(void) close(Socket);
				if ((Socket = socket(SOCK_FAMILY, SOCK_STREAM,
				    0)) < 0)
					err(1, "socket");
				sleep(2);
			} while (connect(Socket, &Daemon, DAEMON_SIZE) < 0);
		}
# endif
a214 1
# ifdef INTERNET
a222 1
# endif
a231 1
# ifdef INTERNET
d233 1
a233 1
int
d252 2
d257 1
a257 1
				sizeof (struct sockaddr));
d262 1
a262 1
SOCKET	*
a264 1
	int			option;
d267 1
a267 1
	static SOCKET		test;
a273 1
	extern int		errno;
d276 1
a276 1
	static	SOCKET		*brdv;
d281 1
a281 1
	static	SOCKET		*listv;
d291 2
a292 4
		if (gethostname(local_name, sizeof local_name) < 0) {
			leave(1, "Sorry, I have no name.");
			/* NOTREACHED */
		}
d294 2
a295 4
		if ((hp = gethostbyname(local_name)) == NULL) {
			leave(1, "Can't find myself.");
			/* NOTREACHED */
		}
d299 3
a301 1
		listv = (SOCKET *) malloc(listmax * sizeof (SOCKET));
d305 5
a309 8
	test_socket = socket(SOCK_FAMILY, SOCK_DGRAM, 0);
	if (test_socket < 0) {
		warn("socket");
		leave(1, "socket system call failed");
		/* NOTREACHED */
	}
	test.sin_family = SOCK_FAMILY;
	test.sin_port = htons(Test_port);
d313 2
a314 4
		if ((hp = gethostbyname(Sock_host)) == NULL) {
			leave(1, "Unknown host");
			/* NOTREACHED */
		}
d324 1
a324 1
		    (struct sockaddr *) &test, DAEMON_SIZE);
d341 1
a341 2
	    &option, sizeof option) < 0) {
		warn("setsockopt broadcast");
a342 2
		/* NOTREACHED */
	}
d350 1
a350 2
		    (struct sockaddr *) &test, DAEMON_SIZE) < 0) {
			warn("sendto");
a351 2
			/* NOTREACHED */
		}
d358 1
a358 1
	while (hp = gethostent()) {
d362 1
a362 1
			    (struct sockaddr *) &test, DAEMON_SIZE);
d365 1
a365 1
# endif
d368 1
a368 1
	namelen = DAEMON_SIZE;
d375 4
a378 2
			listv = (SOCKET *) realloc((char *) listv,
						listmax * sizeof(SOCKET));
d400 1
a400 2
		if (errno != 0 && errno != EINTR) {
			warn("select/recvfrom");
a401 2
			/* NOTREACHED */
		}
d404 1
a404 1
		listv[listc].sin_family = SOCK_FAMILY;
d416 1
a416 1
	    (struct sockaddr *) &test, DAEMON_SIZE);
d420 1
a420 1
void
d424 1
a424 1
	SOCKET	*hosts;
d435 3
a437 9
		clear_the_screen();
# ifdef USE_CURSES
		move(1, 0);
# else
		mvcur(cur_row, cur_col, 1, 0);
		cur_row = 1;
		cur_col = 0;
# endif
		put_str("Pick one:");
d443 1
a443 7
# ifdef USE_CURSES
			move(3 + i, 0);
# else
			mvcur(cur_row, cur_col, 3 + i, 0);
			cur_row = 3 + i;
			cur_col = 0;
# endif
d446 2
a447 1
			(void) sprintf(buf, "%8c    %.64s", 'a' + i,
d450 1
a450 1
			put_str(buf);
d452 3
a454 9
# ifdef USE_CURSES
		move(4 + i, 0);
# else
		mvcur(cur_row, cur_col, 4 + i, 0);
		cur_row = 4 + i;
		cur_col = 0;
# endif
		put_str("Enter letter: ");
		refresh();
d456 2
a457 2
			beep();
			refresh();
d460 1
a460 1
		clear_the_screen();
d471 1
a471 1
void
d473 1
a473 1
	SOCKET	host;
d485 1
a485 1
	s = socket(SOCK_FAMILY, SOCK_STREAM, 0);
d487 1
a487 1
		err(1, "socket");
d489 2
a490 2
		err(1, "connect");
	while ((cnt = read(s, buf, BUFSIZ)) > 0)
d495 1
a495 3
# endif

void
a497 3
	int	procid;

# ifdef MONITOR
d499 2
a500 2
		leave(1, "No one playing.");
		/* NOTREACHED */
a501 1
# endif
a502 1
# ifdef INTERNET
a506 1
# endif
d508 2
a509 39
# ifdef USE_CURSES
	move(HEIGHT, 0);
# else
	mvcur(cur_row, cur_col, HEIGHT, 0);
	cur_row = HEIGHT;
	cur_col = 0;
# endif
	put_str("Starting...");
	refresh();
	procid = fork();
	if (procid == -1) {
		warn("fork");
		leave(1, "fork failed.");
	}
	if (procid == 0) {
		(void) signal(SIGINT, SIG_IGN);
# ifndef INTERNET
		(void) close(Socket);
# else
		if (use_port == NULL)
# endif
			execl(Driver, "HUNT", (char *) NULL);
# ifdef INTERNET
		else 
			execl(Driver, "HUNT", "-p", use_port, (char *) NULL);
# endif
		/* only get here if exec failed */
		(void) kill(getppid(), SIGEMT);	/* tell mom */
		_exit(1);
	}
# ifdef USE_CURSES
	move(HEIGHT, 0);
# else
	mvcur(cur_row, cur_col, HEIGHT, 0);
	cur_row = HEIGHT;
	cur_col = 0;
# endif
	put_str("Connecting...");
	refresh();
d520 1
a520 2
	leave(1, "The game is full.  Sorry.");
	/* NOTREACHED */
d530 1
a531 1
	/* NOTREACHED */
d538 1
a538 1
SIGNAL_TYPE
a542 1
	/* NOTREACHED */
a544 26

/*
 * sigemt:
 *	Handle a emt signal - shouldn't happen on vaxes(?)
 */
SIGNAL_TYPE
sigemt(dummy)
	int dummy;
{
	leave(1, "Unable to start driver.  Try again.");
	/* NOTREACHED */
}

# ifdef INTERNET
/*
 * sigalrm:
 *	Handle an alarm signal
 */
SIGNAL_TYPE
sigalrm(dummy)
	int dummy;
{
	return;
}
# endif

d549 1
a549 1
void
d564 1
a564 1
SIGNAL_TYPE
d573 5
a577 13
# ifdef USE_CURSES
	getyx(stdscr, y, x);
	move(HEIGHT, 0);
# else
	y = cur_row;
	x = cur_col;
	mvcur(cur_row, cur_col, HEIGHT, 0);
	cur_row = HEIGHT;
	cur_col = 0;
# endif
	put_str("Really quit? ");
	clear_eol();
	refresh();
d592 2
a593 8
# ifdef USE_CURSES
			move(y, x);
# else
			mvcur(cur_row, cur_col, y, x);
			cur_row = y;
			cur_col = x;
# endif
			refresh();
d597 2
a598 2
			put_str("(Yes or No) ");
			refresh();
d601 2
a602 2
		beep();
		refresh();
d611 1
a611 1
void
d616 3
d620 10
a629 18
# ifdef USE_CURSES
		move(HEIGHT, 0);
		refresh();
		endwin();
# else /* !USE_CURSES */
		mvcur(cur_row, cur_col, HEIGHT, 0);
		(void) fflush(stdout);	/* flush in case VE changes pages */
# if defined(BSD_RELEASE) && BSD_RELEASE >= 44
		tcsetattr(0, TCSADRAIN, &__orig_termios);
# else
		resetty();
# endif
		_puts(VE);
		_puts(TE);
# endif /* !USE_CURSES */
	}
	if (mesg != NULL)
		puts(mesg);
a632 1
#if !defined(USE_CURSES) && defined(SIGTSTP)
d634 2
a635 2
 * tstp:
 *	Handle stop and start signals
d637 1
a637 62
SIGNAL_TYPE
tstp(dummy)
	int dummy;
{
# if BSD_RELEASE < 44
	static struct sgttyb	tty;
# endif
	int	y, x;

	y = cur_row;
	x = cur_col;
	mvcur(cur_row, cur_col, HEIGHT, 0);
	cur_row = HEIGHT;
	cur_col = 0;
# if !defined(BSD_RELEASE) || BSD_RELEASE < 44
	tty = _tty;
# endif
	_puts(VE);
	_puts(TE);
	(void) fflush(stdout);
# if defined(BSD_RELEASE) && BSD_RELEASE >= 44
	tcsetattr(0, TCSADRAIN, &__orig_termios);
# else
	resetty();
# endif
	(void) kill(getpid(), SIGSTOP);
	(void) signal(SIGTSTP, tstp);
# if defined(BSD_RELEASE) && BSD_RELEASE >= 44
	tcsetattr(0, TCSADRAIN, &saved_tty);
# else
	_tty = tty;
	ioctl(_tty_ch, TIOCSETP, &_tty);
# endif
	_puts(TI);
	_puts(VS);
	cur_row = y;
	cur_col = x;
	_puts(tgoto(CM, cur_row, cur_col));
	redraw_screen();
	(void) fflush(stdout);
}
#endif /* !defined(USE_CURSES) && defined(SIGTSTP) */

# if defined(BSD_RELEASE) && BSD_RELEASE < 43
char *
strpbrk(s, brk)
	char *s, *brk;
{
	char *p;
	c;

	while (c = *s) {
		for (p = brk; *p; p++)
			if (c == *p)
				return (s);
		s++;
	}
	return (0);
}
# endif

long
d644 1
d671 1
a671 1
					strncpy(name, envname, NAMELEN);
d675 1
a675 1
				strncpy(name, envname, NAMELEN);
a677 1
# ifdef INTERNET
d680 1
a680 1
				Test_port = atoi(use_port);
a705 1
# endif
d738 1
a738 1
				strncpy(name, envp, NAMELEN);
d746 5
a750 1
void
d759 1
a759 1
		if (team != ' ')
d765 1
a765 1
		if (fgets(name, NAMELEN, stdin) == NULL)
a769 1
		name[0] = '\0';
d779 1
a779 1
	if (team == ' ') {
d784 3
d789 4
@


1.1
log
@Initial revision
@
text
@d2 1
a7 5

#include <sys/cdefs.h>
#ifndef lint
__RCSID("$NetBSD: hunt.c,v 1.8 1998/09/13 15:27:28 hubertf Exp $");
#endif /* not lint */
@


1.1.1.1
log
@hunt (from NetBSD)
@
text
@@
