head	1.9;
access;
symbols
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.30
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.28
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.24
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.22
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.20
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.18
	OPENBSD_5_0:1.5.0.16
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.14
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.12
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.8
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.10
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.6
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.4
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.4.0.26
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.24
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.22
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.20
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.18
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.16
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.14
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.12
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.10
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.8
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.08.27.02.06.40;	author guenther;	state Exp;
branches;
next	1.8;
commitid	HajZYsKX8810aMqL;

1.8
date	2016.01.07.21.37.53;	author mestre;	state Exp;
branches;
next	1.7;
commitid	OXn0Z5fMODgNmJpo;

1.7
date	2016.01.07.21.29.31;	author mestre;	state Exp;
branches;
next	1.6;
commitid	AgYVDd64zIiNi3fx;

1.6
date	2014.10.11.04.06.05;	author doug;	state Exp;
branches;
next	1.5;
commitid	KiD3CCzu2cO5kPrf;

1.5
date	2007.09.04.22.39.31;	author hshoexer;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.04.02.41.34;	author d;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.13.11.54.59;	author pjanzen;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.30.18.28.03;	author pjanzen;	state Exp;
branches;
next	1.1;

1.1
date	99.12.12.14.53.02;	author d;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Pull in <sys/select.h> for fd_set

ok deraadt@@
@
text
@/*	$OpenBSD: list.c,v 1.8 2016/01/07 21:37:53 mestre Exp $	*/
/*
 * Copyright 2001, David Leonard. All rights reserved.
 * Redistribution and use in source and binary forms with or without
 * modification are permitted provided that this notice is preserved.
 * This software is provided ``as is'' without express or implied warranty.
 */

#include <sys/ioctl.h>
#include <sys/select.h>
#include <sys/socket.h>

#include <arpa/inet.h>
#include <net/if.h>

#include <err.h>
#include <errno.h>
#include <netdb.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "list.h"

/* Wait at most 5 seconds for a reply */
#define LIST_DELAY	5

struct driver *drivers = NULL;
int numdrivers = 0;
int maxdrivers = 0;

u_int16_t Server_port;

static int numprobes = 0;
static int probe_sock[64];
static struct timeval probe_timeout;

struct driver *
next_driver(void)
{

	return next_driver_fd(-1);
}

struct driver *
next_driver_fd(int fd)
{
	fd_set	r;
	int	maxfd = -1;
	int	i, s, ret;
	struct driver *driver;
	u_int16_t resp;
	socklen_t len;

	if (fd == -1 && numprobes == 0)
		return NULL;

    again:
	FD_ZERO(&r);
	if (fd != -1) {
		FD_SET(fd, &r);
		maxfd = fd;
	}
	for (i = 0; i < numprobes; i++) {
		FD_SET(probe_sock[i], &r);
		if (probe_sock[i] > maxfd)
			maxfd = probe_sock[i];
	}

	probe_timeout.tv_sec = LIST_DELAY;
	probe_timeout.tv_usec = 0;
	ret = select(maxfd + 1, &r, NULL, NULL, &probe_timeout);

	if (ret == -1) {
		if (errno == EINTR)
			goto again;
		err(1, "select");
	}

	if (ret == 0) {
		/* Timeout - close all sockets */
		for (i = 0; i < numprobes; i++)
			close(probe_sock[i]);
		numprobes = 0;
		return NULL;
	}

	if (fd != -1 && FD_ISSET(fd, &r)) 
		/* Keypress. Return magic number */
		return (struct driver *)-1;

	for (i = 0; i < numprobes; i++)
		/* Find the first ready socket */
		if (FD_ISSET(probe_sock[i], &r))
			break;

	s = probe_sock[i];

	if (numdrivers >= maxdrivers) {
		if (maxdrivers) {
			drivers = reallocarray(drivers, maxdrivers,
			    2 * sizeof(*driver));
			maxdrivers *= 2;
		} else {
			maxdrivers = 16;
			drivers = calloc(sizeof *driver, maxdrivers);
		}
		if (drivers == NULL)
			err(1, "malloc");
	}
	driver = &drivers[numdrivers];
	len = sizeof driver->addr;
	ret = recvfrom(s, &resp, sizeof resp, 0, &driver->addr, &len);
	if (ret == -1)
		goto again;
	driver->response = ntohs(resp);

	switch (driver->addr.sa_family) {
	case AF_INET:
	case AF_INET6:
		((struct sockaddr_in *)&driver->addr)->sin_port =
		    htons(driver->response);
		break;
	}
	numdrivers++;
	return driver;
}

/* Return the hostname for a driver. */
const char *
driver_name(struct driver *driver)
{
	const char *name;
	static char buf[80];
	struct hostent *hp;
	struct sockaddr_in *sin;

	name = NULL;

	if (driver->addr.sa_family == AF_INET) {
		sin = (struct sockaddr_in *)&driver->addr;
		hp = gethostbyaddr((char *)&sin->sin_addr, 
		    sizeof sin->sin_addr, AF_INET);
		if (hp != NULL)
			name = hp->h_name;
		else {
			name = inet_ntop(AF_INET, &sin->sin_addr, 
			    buf, sizeof buf);
		}
	}

	return name;
}

static int
start_probe(struct sockaddr *addr, u_int16_t req)
{
	u_int16_t msg;
	int s;
	int enable;

	if (numprobes >= (sizeof probe_sock / sizeof probe_sock[0])) {
		/* Just ridiculous */
		return -1;
	}

	s = socket(addr->sa_family, SOCK_DGRAM, 0);
	if (s < 0) {
		warn("socket");
		return -1;
	}

	enable = 1;
	setsockopt(s, SOL_SOCKET, SO_BROADCAST, &enable, sizeof enable);

	switch (addr->sa_family) {
	case AF_INET:
	case AF_INET6:
		((struct sockaddr_in *)addr)->sin_port = 
		    htons(Server_port);
		break;
	}

	msg = htons(req);
	if (sendto(s, &msg, sizeof msg, 0, addr, addr->sa_len) == -1)
		warn("sendto");
	probe_sock[numprobes++] = s;

	return 0;
}

void
probe_cleanup(void)
{
	int i;

	for (i = 0; i < numprobes; i++)
		close(probe_sock[i]);
	numprobes = 0;
}

/*
 * If we have no preferred host then send a broadcast message to everyone.
 * Otherwise, send the request message only to the preferred host.
 */
void
probe_drivers(u_int16_t req, char *preferred)
{
	struct sockaddr_in *target;
	struct sockaddr_in localhost;
	struct hostent *he;
        char *inbuf = NULL, *ninbuf;
        struct ifconf ifc;
        struct ifreq *ifr;
        int fd, inlen = 8192;
        int i, len;

	numdrivers = 0;

	probe_cleanup();

	/* Send exclusively to a preferred host. */
	if (preferred) {
		struct sockaddr_in sin;

		target = NULL;

		if (!target) {
			sin.sin_family = AF_INET;
			sin.sin_len = sizeof sin;
			if (inet_pton(AF_INET, preferred, &sin.sin_addr) == 1)
				target = &sin;
		}

		if (!target && (he = gethostbyname(preferred)) != NULL) {
			sin.sin_family = he->h_addrtype;
			sin.sin_len = sizeof sin;
			memcpy(&sin.sin_addr, he->h_addr, he->h_length);
			target = &sin;
		}

		if (!target)
			errx(1, "Bad hostname: %s", preferred);

		start_probe((struct sockaddr *)target, req);
		return;
	}

	/* Send a query to the local machine: */
	localhost.sin_family = AF_INET;
	localhost.sin_len = sizeof localhost;
	localhost.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	start_probe((struct sockaddr *)&localhost, req);

        if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
                err(1, "socket");

	/* Find all attached networks: */
        while (1) {
                ifc.ifc_len = inlen;
                if ((ninbuf = realloc(inbuf, inlen)) == NULL)
			err(1, "malloc");
                ifc.ifc_buf = inbuf = ninbuf;
                if (ioctl(fd, SIOCGIFCONF, (char *)&ifc) < 0) 
                        err(1, "SIOCGIFCONF");
                if (ifc.ifc_len + sizeof(*ifr) < inlen)
                        break;
                inlen *= 2;
        }

	/* Send a request to every attached broadcast address: */
        ifr = ifc.ifc_req;
        for (i = 0; i < ifc.ifc_len;
             i += len, ifr = (struct ifreq *)((caddr_t)ifr + len)) {
                len = sizeof(ifr->ifr_name) +
                      (ifr->ifr_addr.sa_len > sizeof(struct sockaddr) ?
                       ifr->ifr_addr.sa_len : sizeof(struct sockaddr));

		if (ifr->ifr_addr.sa_family != AF_INET)
			continue;

                if (ioctl(fd, SIOCGIFFLAGS, (caddr_t)ifr) < 0) {
                        warn("%s: SIOCGIFFLAGS", ifr->ifr_name);
			continue;
		}
                if ((ifr->ifr_flags & IFF_UP) == 0)
			continue;
		if ((ifr->ifr_flags & IFF_BROADCAST) != 0) {
			if (ioctl(fd, SIOCGIFBRDADDR, (caddr_t)ifr) < 0)  {
				warn("%s: SIOCGIFBRDADDR", ifr->ifr_name);
				continue;
			}
			target = (struct sockaddr_in *)&ifr->ifr_dstaddr;
		} else if ((ifr->ifr_flags & IFF_POINTOPOINT) != 0) {
			if (ioctl(fd, SIOCGIFDSTADDR, (caddr_t)ifr) < 0)  {
				warn("%s: SIOCGIFDSTADDR", ifr->ifr_name);
				continue;
			}
			target = (struct sockaddr_in *)&ifr->ifr_broadaddr;
		} else
			continue;

		start_probe((struct sockaddr *)target, req);
        }
        free(inbuf);
        (void) close(fd);
}
@


1.8
log
@ANSIfy hunt(6)

Note: casted 2 args to struct sockaddr * on list.c to shut off compiler
warnings, and also changed an int len to socklen_t since recvfrom(2) receives
the last argument as the latter.

I'm running out of credits, but this was once again with great help and OK from
tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.7 2016/01/07 21:29:31 mestre Exp $	*/
d10 1
@


1.7
log
@Headers cleanup and sorting

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.6 2014/10/11 04:06:05 doug Exp $	*/
d38 1
a38 1
next_driver()
d45 1
a45 2
next_driver_fd(fd)
	int	fd;
d49 1
a49 1
	int	i, s, ret, len;
d52 1
d130 1
a130 2
driver_name(driver)
	struct driver *driver;
d155 1
a155 3
start_probe(addr, req)
	struct sockaddr *addr;
	u_int16_t req;
d192 1
a192 1
probe_cleanup()
d206 1
a206 3
probe_drivers(req, preferred)
	u_int16_t	req;
	char 		*preferred;
d244 1
a244 1
		start_probe(target, req);
d302 1
a302 1
		start_probe(target, req);
@


1.6
log
@Userland reallocarray() audit.

Avoid potential integer overflow in the size argument of malloc() and
realloc() by using reallocarray() to avoid unchecked multiplication.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.5 2007/09/04 22:39:31 hshoexer Exp $	*/
d9 1
a9 9
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <netdb.h>
#include <unistd.h>
#include <errno.h>
#include <err.h>

#include <sys/types.h>
a10 2
#include <sys/sockio.h>
#include <sys/ioctl.h>
d12 1
a12 1
#include <netinet/in.h>
d15 6
a20 1
#include <arpa/inet.h>
a21 1
#include "hunt.h"
@


1.5
log
@Some more simple malloc(n * m) -> calloc(n, m) conversions.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.4 2001/06/04 02:41:34 d Exp $	*/
d106 2
a108 1
			drivers = realloc(drivers, sizeof *driver * maxdrivers);
@


1.4
log
@my licence now permits modification. plus some tiny style cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.3 2001/02/13 11:54:59 pjanzen Exp $	*/
d110 1
a110 1
			drivers = malloc(sizeof *driver * maxdrivers);
@


1.3
log
@Quiet alpha warnings, principally with correct includes
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.2 2000/06/30 18:28:03 pjanzen Exp $	*/
d3 4
a6 4
 * Copyright 1999, David Leonard. All rights reserved.
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved. This software
 * is provided ``as is'' without express or implied warranty.
d33 1
a33 1
struct driver * drivers = NULL;
d67 1
a67 1
		maxfd =fd;
d157 1
a157 1
	return name ? name : NULL;
d216 1
a216 1
	char *		preferred;
@


1.2
log
@re-initialize timeout before each invocation of select()
@
text
@d1 1
a1 1
/*	$OpenBSD: list.c,v 1.1 1999/12/12 14:53:02 d Exp $	*/
d11 1
@


1.1
log
@isplit complicated probe_drivers() out to own file. reviewed by pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 2
a225 2
	probe_timeout.tv_sec = LIST_DELAY;
	probe_timeout.tv_usec = 0;
@

