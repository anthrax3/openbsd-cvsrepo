head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.2
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.12.0.4
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.48
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.46
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.42
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.40
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.38
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.36
	OPENBSD_5_0:1.8.0.34
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.32
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.30
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.26
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.28
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.24
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.22
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.20
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.18
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.16
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.14
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	initial:1.1.1.1
	hunt:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.08.27.02.06.40;	author guenther;	state Exp;
branches;
next	1.12;
commitid	HajZYsKX8810aMqL;

1.12
date	2016.01.10.13.35.09;	author mestre;	state Exp;
branches;
next	1.11;
commitid	mVbl9a8GbGdqcFgu;

1.11
date	2016.01.07.21.37.53;	author mestre;	state Exp;
branches;
next	1.10;
commitid	OXn0Z5fMODgNmJpo;

1.10
date	2016.01.07.21.29.31;	author mestre;	state Exp;
branches;
next	1.9;
commitid	AgYVDd64zIiNi3fx;

1.9
date	2014.11.16.04.49.48;	author guenther;	state Exp;
branches;
next	1.8;
commitid	8XNajyb9IqHkZEKg;

1.8
date	2003.06.11.08.45.25;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.10;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.13.11.55.01;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	99.12.12.15.03.48;	author d;	state Exp;
branches;
next	1.4;

1.4
date	99.02.01.06.53.55;	author d;	state Exp;
branches;
next	1.3;

1.3
date	99.01.29.07.30.34;	author d;	state Exp;
branches;
next	1.2;

1.2
date	99.01.21.05.47.39;	author d;	state Exp;
branches;
next	1.1;

1.1
date	99.01.21.05.33.37;	author d;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.01.21.05.33.37;	author d;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Pull in <sys/select.h> for fd_set

ok deraadt@@
@
text
@/*	$OpenBSD: playit.c,v 1.12 2016/01/10 13:35:09 mestre Exp $	*/
/*	$NetBSD: playit.c,v 1.4 1997/10/20 00:37:15 lukem Exp $	*/
/*
 * Copyright (c) 1983-2003, Regents of the University of California.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are 
 * met:
 * 
 * + Redistributions of source code must retain the above copyright 
 *   notice, this list of conditions and the following disclaimer.
 * + Redistributions in binary form must reproduce the above copyright 
 *   notice, this list of conditions and the following disclaimer in the 
 *   documentation and/or other materials provided with the distribution.
 * + Neither the name of the University of California, San Francisco nor 
 *   the names of its contributors may be used to endorse or promote 
 *   products derived from this software without specific prior written 
 *   permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS 
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED 
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/select.h>
#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>

#include "display.h"
#include "hunt.h"
#include "client.h"

static int	nchar_send;
static FLAG	Last_player;
static int	Otto_expect;

# define	MAX_SEND	5

/*
 * ibuf is the input buffer used for the stream from the driver.
 * It is small because we do not check for user input when there
 * are characters in the input buffer.
 */
static int		icnt = 0;
static unsigned char	ibuf[256], *iptr = ibuf;

#define	GETCHR()	(--icnt < 0 ? getchr() : *iptr++)

static	unsigned char	getchr(void);
static	void		send_stuff(void);

/*
 * playit:
 *	Play a given game, handling all the curses commands from
 *	the driver.
 */
void
playit(void)
{
	int		ch;
	int		y, x;
	u_int32_t	version;
	int		otto_y, otto_x;
	char		otto_face = ' ';
	int		chars_processed;

	if (read(Socket, &version, sizeof version) != sizeof version) {
		bad_con();
	}
	if (ntohl(version) != HUNT_VERSION) {
		bad_ver();
	}
	errno = 0;
	nchar_send = MAX_SEND;
	Otto_expect = 0;
	while ((ch = GETCHR()) != EOF) {
		switch (ch & 0377) {
		  case MOVE:
			y = GETCHR();
			x = GETCHR();
			display_move(y, x);
			break;

		  case CLRTOEOL:
			display_clear_eol();
			break;
		  case CLEAR:
			display_clear_the_screen();
			break;
		  case REFRESH:
			display_refresh();
			break;
		  case REDRAW:
			display_redraw_screen();
			display_refresh();
			break;
		  case ENDWIN:
			display_refresh();
			if ((ch = GETCHR()) == LAST_PLAYER)
				Last_player = TRUE;
			ch = EOF;
			goto out;
		  case BELL:
			display_beep();
			break;
		  case READY:
			chars_processed = GETCHR();
			display_refresh();
			if (nchar_send < 0)
				tcflush(STDIN_FILENO, TCIFLUSH);
			nchar_send = MAX_SEND;
			if (Otto_mode) {
				/*
				 * The driver returns the number of keypresses
				 * that it has processed. Use this to figure
				 * out if otto's commands have completed.
				 */
				Otto_expect -= chars_processed;
				if (Otto_expect == 0) {
					/* not very fair! */
					static char buf[MAX_SEND * 2];
					int len;

					/* Ask otto what it wants to do: */
					len = otto(otto_y, otto_x, otto_face,
						buf, sizeof buf);
					if (len) {
						/* Pass it on to the driver: */
						write(Socket, buf, len);
						/* Update expectations: */
						Otto_expect += len;
					}
				}
			}
			break;
		  case ADDCH:
			ch = GETCHR();
			/* FALLTHROUGH */
		  default:
			if (!isprint(ch))
				ch = ' ';
			display_put_ch(ch);
			if (Otto_mode)
				switch (ch) {
				case '<':
				case '>':
				case '^':
				case 'v':
					otto_face = ch;
					display_getyx(&otto_y, &otto_x);
					otto_x--;
					break;
				}
			break;
		}
	}
out:
	(void) close(Socket);
}

/*
 * getchr:
 *	Grab input and pass it along to the driver
 *	Return any characters from the driver
 *	When this routine is called by GETCHR, we already know there are
 *	no characters in the input buffer.
 */
static unsigned char
getchr(void)
{
	fd_set	readfds, s_readfds;
	int	nfds, s_nfds;

	FD_ZERO(&s_readfds);
	FD_SET(Socket, &s_readfds);
	FD_SET(STDIN_FILENO, &s_readfds);
	s_nfds = (Socket > STDIN_FILENO) ? Socket : STDIN_FILENO;
	s_nfds++;

one_more_time:
	do {
		errno = 0;
		readfds = s_readfds;
		nfds = s_nfds;
		nfds = select(nfds, &readfds, NULL, NULL, NULL);
	} while (nfds <= 0 && errno == EINTR);

	if (FD_ISSET(STDIN_FILENO, &readfds))
		send_stuff();
	if (!FD_ISSET(Socket, &readfds))
		goto one_more_time;
	icnt = read(Socket, ibuf, sizeof ibuf);
	if (icnt <= 0) {
		bad_con();
	}
	iptr = ibuf;
	icnt--;
	return *iptr++;
}

/*
 * send_stuff:
 *	Send standard input characters to the driver
 */
static void
send_stuff(void)
{
	int		count;
	char		*sp, *nsp;
	static char	inp[BUFSIZ];
	static char	Buf[BUFSIZ];

	/* Drain the user's keystrokes: */
	count = read(STDIN_FILENO, Buf, sizeof Buf);
	if (count < 0)
		err(1, "read");
	if (count == 0)
		return;

	if (nchar_send <= 0 && !no_beep) {
		display_beep();
		return;
	}

	/*
	 * look for 'q'uit commands; if we find one,
	 * confirm it.  If it is not confirmed, strip
	 * it out of the input
	 */
	Buf[count] = '\0';
	for (sp = Buf, nsp = inp; *sp != '\0'; sp++, nsp++) {
		*nsp = map_key[(int)*sp];
		if (*nsp == 'q')
			intr(0);
	}
	count = nsp - inp;
	if (count) {
		nchar_send -= count;
		if (nchar_send < 0)
			count += nchar_send;
		(void) write(Socket, inp, count);
		if (Otto_mode) {
			/*
			 * The user can insert commands over otto.
			 * So, otto shouldn't be alarmed when the 
			 * server processes more than otto asks for.
			 */
			Otto_expect += count;
		}
	}
}

/*
 * quit:
 *	Handle the end of the game when the player dies
 */
int
quit(int old_status)
{
	int	explain, ch;

	if (Last_player)
		return Q_QUIT;
	if (Otto_mode)
		return otto_quit(old_status);
	display_move(HEIGHT, 0);
	display_put_str("Re-enter game [ynwo]? ");
	display_clear_eol();
	explain = FALSE;
	for (;;) {
		display_refresh();
		if (isupper(ch = getchar()))
			ch = tolower(ch);
		if (ch == 'y')
			return old_status;
		else if (ch == 'o')
			break;
		else if (ch == 'n') {
			display_move(HEIGHT, 0);
			display_put_str("Write a parting message [yn]? ");
			display_clear_eol();
			display_refresh();
			for (;;) {
				if (isupper(ch = getchar()))
					ch = tolower(ch);
				if (ch == 'y')
					goto get_message;
				if (ch == 'n')
					return Q_QUIT;
			}
		}
		else if (ch == 'w') {
			static	char	buf[WIDTH + WIDTH % 2];
			char		*cp, c;

get_message:
			c = ch;		/* save how we got here */
			display_move(HEIGHT, 0);
			display_put_str("Message: ");
			display_clear_eol();
			display_refresh();
			cp = buf;
			for (;;) {
				display_refresh();
				if ((ch = getchar()) == '\n' || ch == '\r')
					break;
				if (display_iserasechar(ch))
				{
					if (cp > buf) {
						int y, x;

						display_getyx(&y, &x);
						display_move(y, x - 1);
						cp -= 1;
						display_clear_eol();
					}
					continue;
				}
				else if (display_iskillchar(ch))
				{
					int y, x;

					display_getyx(&y, &x);
					display_move(y, x - (cp - buf));
					cp = buf;
					display_clear_eol();
					continue;
				} else if (!isprint(ch)) {
					display_beep();
					continue;
				}
				display_put_ch(ch);
				*cp++ = ch;
				if (cp + 1 >= buf + sizeof buf)
					break;
			}
			*cp = '\0';
			Send_message = buf;
			return (c == 'w') ? old_status : Q_MESSAGE;
		}
		display_beep();
		if (!explain) {
			display_put_str("(Yes, No, Write message, or Options) ");
			explain = TRUE;
		}
	}

	display_move(HEIGHT, 0);
	display_put_str("Scan, Cloak, Flying, or Quit? ");
	display_clear_eol();
	display_refresh();
	explain = FALSE;
	for (;;) {
		if (isupper(ch = getchar()))
			ch = tolower(ch);
		if (ch == 's')
			return Q_SCAN;
		else if (ch == 'c')
			return Q_CLOAK;
		else if (ch == 'f')
			return Q_FLY;
		else if (ch == 'q')
			return Q_QUIT;
		display_beep();
		if (!explain) {
			display_put_str("[SCFQ] ");
			explain = TRUE;
		}
		display_refresh();
	}
}

/*
 * do_message:
 *	Send a message to the driver and return
 */
void
do_message(void)
{
	u_int32_t	version;

	if (read(Socket, &version, sizeof version) != sizeof version) {
		bad_con();
	}
	if (ntohl(version) != HUNT_VERSION) {
		bad_ver();
	}
	if (write(Socket, Send_message, strlen(Send_message)) < 0) {
		bad_con();
	}
	(void) close(Socket);
}
@


1.12
log
@As per style(9), remove remaining lint-style comments from games/

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: playit.c,v 1.11 2016/01/07 21:37:53 mestre Exp $	*/
d34 1
@


1.11
log
@ANSIfy hunt(6)

Note: casted 2 args to struct sockaddr * on list.c to shut off compiler
warnings, and also changed an int len to socklen_t since recvfrom(2) receives
the last argument as the latter.

I'm running out of credits, but this was once again with great help and OK from
tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: playit.c,v 1.10 2016/01/07 21:29:31 mestre Exp $	*/
a81 1
		/* NOTREACHED */
a84 1
		/* NOTREACHED */
a207 1
		/* NOTREACHED */
a396 1
		/* NOTREACHED */
a399 1
		/* NOTREACHED */
a402 1
		/* NOTREACHED */
@


1.10
log
@Headers cleanup and sorting

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: playit.c,v 1.9 2014/11/16 04:49:48 guenther Exp $	*/
d71 1
a71 1
playit()
d184 1
a184 1
getchr()
d222 1
a222 1
send_stuff()
d274 1
a274 2
quit(old_status)
	int	old_status;
d394 1
a394 1
do_message()
@


1.9
log
@Eliminate pointless use of <sys/param.h>, <sys/file.h>, <sys/sockio.h>,
    and <sys/ttydefaults.h>
Replace MAXPATHLEN with PATH_MAX and MAXLOGNAME with LOGIN_NAME_MAX
Pull in <limits.h> where needed
Prefer sizeof(var) over MAXFOO or FOO_MAX

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: playit.c,v 1.8 2003/06/11 08:45:25 pjanzen Exp $	*/
d34 1
d37 2
a38 1
#include <ctype.h>
a39 2
#include <signal.h>
#include <string.h>
d41 2
a42 1
#include <stdio.h>
a43 1
#include "display.h"
@


1.8
log
@New license from the official hunt release at
ftp://ftp.cgl.ucsf.edu/pub/hunt.shar.Z -- it has been approved by all three
authors (Conrad Huang, Ken Arnold, and Greg Couch).
@
text
@d1 1
a1 1
/*	$OpenBSD: playit.c,v 1.7 2002/02/16 21:27:10 millert Exp $	*/
a33 1
#include <sys/file.h>
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: playit.c,v 1.6 2001/02/13 11:55:01 pjanzen Exp $	*/
d4 28
a31 3
 *  Hunt
 *  Copyright (c) 1985 Conrad C. Huang, Gregory S. Couch, Kenneth C.R.C. Arnold
 *  San Francisco, California
@


1.6
log
@Quiet alpha warnings, principally with correct includes
@
text
@d1 1
a1 1
/*	$OpenBSD: playit.c,v 1.5 1999/12/12 15:03:48 d Exp $	*/
d38 2
a39 2
static	unsigned char	getchr __P((void));
static	void		send_stuff __P((void));
@


1.5
log
@Catch some bad draw characters (like NUL).
Use display_beep() instead of write(,"\7",)
Report read errors from stdin.

reviewed by pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: playit.c,v 1.4 1999/02/01 06:53:55 d Exp $	*/
d15 1
@


1.4
log
@avoid denial of service attacks on server port; extra conf vars; fix otto
@
text
@d1 1
a1 1
/*	$OpenBSD: playit.c,v 1.3 1999/01/29 07:30:34 d Exp $	*/
d130 2
d180 1
a180 1
	if (! FD_ISSET(Socket, &readfds))
d206 3
a208 1
	if (count <= 0)
d212 1
a212 1
		(void) write(1, "\7", 1);	/* CTRL('G') */
@


1.3
log
@major changes: security, curses, config
@
text
@d1 1
a1 1
/*	$OpenBSD: playit.c,v 1.2 1999/01/21 05:47:39 d Exp $	*/
d23 1
a25 1
# define	STDIN		0
d52 2
a53 1
	char		otto_face;
a63 1
	Otto_count = 0;
d65 1
a72 4
		  case ADDCH:
			ch = GETCHR();
			if (Otto_mode)
				switch (ch) {
a73 11
				case '<':
				case '>':
				case '^':
				case 'v':
					otto_face = ch;
					display_getyx(&otto_y, &otto_x);
					break;
				}

			display_put_ch(ch);
			break;
d97 1
d100 1
a100 1
				tcflush(STDIN, TCIFLUSH);
d102 22
a123 4
			Otto_count -= (GETCHR() & 0xff);
			if (!Am_monitor) {
				if (Otto_count == 0 && Otto_mode)
					otto(otto_y, otto_x, otto_face);
d126 3
d130 1
a132 1

d139 1
a141 1
			display_put_ch(ch);
d164 2
a165 2
	FD_SET(STDIN, &s_readfds);
	s_nfds = (Socket > STDIN) ? Socket : STDIN;
d176 1
a176 1
	if (FD_ISSET(STDIN, &readfds))
d181 1
a181 1
	if (icnt < 0) {
a184 2
	if (icnt == 0)
		goto one_more_time;
d203 1
a203 1
	count = read(STDIN, Buf, sizeof Buf);
a224 2
		if (Otto_mode)
			Otto_count += count;
d229 8
d253 1
a253 1
		return Q_CLOAK;
@


1.2
log
@ident for OpenBSD
mandoc-ify manual pages
use -locurses
@
text
@d1 1
a2 1
/*	$OpenBSD$	*/
d9 11
a19 28
# include	<sys/file.h>
# include	<err.h>
# include	<errno.h>
# include	<curses.h>
# include	<ctype.h>
# include	<signal.h>
# if defined(HPUX) || (defined(BSD_RELEASE) && BSD_RELEASE >= 44)
# include	<termios.h>
# include	<unistd.h>
# endif
# include	"hunt.h"

# ifndef FREAD
# define	FREAD	1
# endif

# if !defined(USE_CURSES) || !defined(TERMINFO)
# define	beep()		(void) putchar(CTRL('G'))
# endif
# if !defined(USE_CURSES)
# undef		refresh
# define	refresh()	(void) fflush(stdout);
# endif
# ifdef USE_CURSES
# define	clear_eol()	clrtoeol()
# define	put_ch		addch
# define	put_str		addstr
# endif
d22 1
a22 10
# ifndef USE_CURSES
char		screen[SCREEN_HEIGHT][SCREEN_WIDTH2], blanks[SCREEN_WIDTH];
int		cur_row, cur_col;
# endif
# ifdef OTTO
int		Otto_count;
int		Otto_mode;
static int	otto_y, otto_x;
static char	otto_face;
# endif
a36 4
#if !defined(BSD_RELEASE) || BSD_RELEASE < 44
extern int	_putchar();
#endif

d50 3
a52 1
	long		version;
d54 1
a54 1
	if (read(Socket, (char *) &version, LONGLEN) != LONGLEN) {
a62 1
# ifdef OTTO
a63 1
# endif
a65 3
# ifdef DEBUG
		fputc(ch, stderr);
# endif
d70 1
a70 7
# ifdef USE_CURSES
			move(y, x);
# else
			mvcur(cur_row, cur_col, y, x);
			cur_row = y;
			cur_col = x;
# endif
d74 2
a75 2
# ifdef OTTO
			switch (ch) {
d77 10
a86 15
			case '<':
			case '>':
			case '^':
			case 'v':
				otto_face = ch;
# ifdef USE_CURSES
				getyx(stdscr, otto_y, otto_x);
# else
				otto_y = cur_row;
				otto_x = cur_col;
# endif
				break;
			}
# endif
			put_ch(ch);
d89 1
a89 1
			clear_eol();
d92 1
a92 1
			clear_the_screen();
d95 1
a95 1
			refresh();
d98 2
a99 2
			redraw_screen();
			refresh();
d102 1
a102 1
			refresh();
d108 1
a108 1
			beep();
d111 1
a111 1
			refresh();
a112 1
# if defined(HPUX) || (defined(BSD_RELEASE) && BSD_RELEASE >= 44)
a113 7
# else
# ifndef TCFLSH
				(void) ioctl(STDIN, TIOCFLUSH, &in);
# else
				(void) ioctl(STDIN, TCFLSH, 0);
# endif
# endif
a114 3
# ifndef OTTO
			(void) GETCHR();
# else
a116 3
# ifdef DEBUG
				fputc('0' + Otto_count, stderr);
# endif
a119 1
# endif
d122 2
a123 2
# ifdef OTTO
			switch (ch) {
d125 9
a133 15
			case '<':
			case '>':
			case '^':
			case 'v':
				otto_face = ch;
# ifdef USE_CURSES
				getyx(stdscr, otto_y, otto_x);
# else
				otto_y = cur_row;
				otto_x = cur_col;
# endif
				break;
			}
# endif
			put_ch(ch);
d193 2
a194 1
	static char	inp[sizeof Buf];
d196 1
d200 1
d212 3
a214 3
	nsp = inp;
	for (sp = Buf; *sp != '\0'; sp++)
		if ((*nsp = map_key[(int)*sp]) == 'q')
d216 1
a216 2
		else
			nsp++;
d219 2
a220 3
# ifdef OTTO
		Otto_count += count;
# endif
a239 1
# ifdef OTTO
d242 3
a244 10
# endif
# ifdef USE_CURSES
	move(HEIGHT, 0);
# else
	mvcur(cur_row, cur_col, HEIGHT, 0);
	cur_row = HEIGHT;
	cur_col = 0;
# endif
	put_str("Re-enter game [ynwo]? ");
	clear_eol();
d247 1
a247 1
		refresh();
d255 4
a258 13
# ifndef INTERNET
			return Q_QUIT;
# else
# ifdef USE_CURSES
			move(HEIGHT, 0);
# else
			mvcur(cur_row, cur_col, HEIGHT, 0);
			cur_row = HEIGHT;
			cur_col = 0;
# endif
			put_str("Write a parting message [yn]? ");
			clear_eol();
			refresh();
a266 1
# endif
a267 1
# ifdef INTERNET
d274 4
a277 10
# ifdef USE_CURSES
			move(HEIGHT, 0);
# else
			mvcur(cur_row, cur_col, HEIGHT, 0);
			cur_row = HEIGHT;
			cur_col = 0;
# endif
			put_str("Message: ");
			clear_eol();
			refresh();
d280 1
a280 1
				refresh();
d283 1
a283 5
# if defined(TERMINFO) || BSD_RELEASE >= 44
				if (ch == erasechar())
# else
				if (ch == _tty.sg_erase)
# endif
a285 1
# ifdef USE_CURSES
d287 3
a289 7
						getyx(stdscr, y, x);
						move(y, x - 1);
# else
						mvcur(cur_row, cur_col, cur_row,
								cur_col - 1);
						cur_col -= 1;
# endif
d291 1
a291 1
						clear_eol();
d295 1
a295 5
# if defined(TERMINFO) || BSD_RELEASE >= 44
				else if (ch == killchar())
# else
				else if (ch == _tty.sg_kill)
# endif
a296 1
# ifdef USE_CURSES
d298 3
a300 7
					getyx(stdscr, y, x);
					move(y, x - (cp - buf));
# else
					mvcur(cur_row, cur_col, cur_row,
							cur_col - (cp - buf));
					cur_col -= cp - buf;
# endif
d302 1
a302 1
					clear_eol();
d305 1
a305 1
					beep();
d308 1
a308 1
				put_ch(ch);
d317 1
a317 2
# endif
		beep();
d319 1
a319 1
			put_str("(Yes, No, Write message, or Options) ");
d324 4
a327 14
# ifdef USE_CURSES
	move(HEIGHT, 0);
# else
	mvcur(cur_row, cur_col, HEIGHT, 0);
	cur_row = HEIGHT;
	cur_col = 0;
# endif
# ifdef FLY
	put_str("Scan, Cloak, Flying, or Quit? ");
# else
	put_str("Scan, Cloak, or Quit? ");
# endif
	clear_eol();
	refresh();
a335 1
# ifdef FLY
a337 1
# endif
d340 1
a340 1
		beep();
d342 1
a342 5
# ifdef FLY
			put_str("[SCFQ] ");
# else
			put_str("[SCQ] ");
# endif
d345 1
a345 21
		refresh();
	}
}

# ifndef USE_CURSES
void
put_ch(ch)
	char	ch;
{
	if (!isprint(ch)) {
		fprintf(stderr, "r,c,ch: %d,%d,%d", cur_row, cur_col, ch);
		return;
	}
	screen[cur_row][cur_col] = ch;
	putchar(ch);
	if (++cur_col >= COLS) {
		if (!AM || XN)
			putchar('\n');
		cur_col = 0;
		if (++cur_row >= LINES)
			cur_row = LINES;
a348 118
void
put_str(s)
	char	*s;
{
	while (*s)
		put_ch(*s++);
}
# endif

void
clear_the_screen()
{
# ifdef USE_CURSES
	clear();
	move(0, 0);
	refresh();
# else
	int	i;

	if (blanks[0] == '\0')
		for (i = 0; i < SCREEN_WIDTH; i++)
			blanks[i] = ' ';

	if (CL != NULL) {
#if !defined(BSD_RELEASE) || BSD_RELEASE < 44
		tputs(CL, LINES, _putchar);
#else
		tputs(CL, LINES, __cputchar);
#endif
		for (i = 0; i < SCREEN_HEIGHT; i++)
			memcpy(screen[i], blanks, SCREEN_WIDTH);
	} else {
		for (i = 0; i < SCREEN_HEIGHT; i++) {
			mvcur(cur_row, cur_col, i, 0);
			cur_row = i;
			cur_col = 0;
			clear_eol();
		}
		mvcur(cur_row, cur_col, 0, 0);
	}
	cur_row = cur_col = 0;
#endif
}

#ifndef USE_CURSES
void
clear_eol()
{
	if (CE != NULL)
#if !defined(BSD_RELEASE) || BSD_RELEASE < 44
		tputs(CE, 1, _putchar);
#else
		tputs(CE, 1, __cputchar);
#endif
	else {
		fwrite(blanks, sizeof (char), SCREEN_WIDTH - cur_col, stdout);
		if (COLS != SCREEN_WIDTH)
			mvcur(cur_row, SCREEN_WIDTH, cur_row, cur_col);
		else if (AM)
			mvcur(cur_row + 1, 0, cur_row, cur_col);
		else
			mvcur(cur_row, SCREEN_WIDTH - 1, cur_row, cur_col);
	}
	memcpy(&screen[cur_row][cur_col], blanks, SCREEN_WIDTH - cur_col);
}
# endif

void
redraw_screen()
{
# ifdef USE_CURSES
	clearok(stdscr, TRUE);
	touchwin(stdscr);
# else
	int		i;
# ifndef NOCURSES
	static int	first = 1;

	if (first) {
		curscr = newwin(SCREEN_HEIGHT, SCREEN_WIDTH, 0, 0);
		if (curscr == NULL)
			errx(1, "Can't create curscr");
# if !defined(BSD_RELEASE) || BSD_RELEASE < 44
		for (i = 0; i < SCREEN_HEIGHT; i++)
			curscr->_y[i] = screen[i];
# endif
		first = 0;
	}
# if defined(BSD_RELEASE) && BSD_RELEASE >= 44
	for (i = 0; i < SCREEN_HEIGHT; i++) {
		int	j;

		for (j = 0; j < SCREEN_WIDTH; j++)
			curscr->lines[i]->line[j].ch = screen[i][j];
	}
	curscr->cury = cur_row;
	curscr->curx = cur_col;
# else
	curscr->_cury = cur_row;
	curscr->_curx = cur_col;
# endif
	clearok(curscr, TRUE);
	touchwin(curscr);
	wrefresh(curscr);
#else
	mvcur(cur_row, cur_col, 0, 0);
	for (i = 0; i < SCREEN_HEIGHT - 1; i++) {
		fwrite(screen[i], sizeof (char), SCREEN_WIDTH, stdout);
		if (COLS > SCREEN_WIDTH || (COLS == SCREEN_WIDTH && !AM))
			putchar('\n');
	}
	fwrite(screen[SCREEN_HEIGHT - 1], sizeof (char), SCREEN_WIDTH - 1,
		stdout);
	mvcur(SCREEN_HEIGHT - 1, SCREEN_WIDTH - 1, cur_row, cur_col);
#endif
#endif
}

d356 1
a356 1
	long	version;
d358 1
a358 1
	if (read(Socket, (char *) &version, LONGLEN) != LONGLEN) {
a365 1
# ifdef INTERNET
a369 1
# endif
@


1.1
log
@Initial revision
@
text
@d2 1
a7 5

#include <sys/cdefs.h>
#ifndef lint
__RCSID("$NetBSD: playit.c,v 1.4 1997/10/20 00:37:15 lukem Exp $");
#endif /* not lint */
@


1.1.1.1
log
@hunt (from NetBSD)
@
text
@@
