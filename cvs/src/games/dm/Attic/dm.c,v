head	1.15;
access;
symbols
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.13.0.10
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.13.0.8
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.13.0.6
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.4
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.10.0.4
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2002.05.23.18.43.00;	author deraadt;	state dead;
branches;
next	1.14;

1.14
date	2002.02.16.21.27.09;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	99.09.25.15.52.19;	author pjanzen;	state Exp;
branches;
next	1.12;

1.12
date	99.08.16.17.00.14;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	99.07.31.18.48.52;	author pjanzen;	state Exp;
branches;
next	1.10;

1.10
date	98.09.06.12.14.04;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	98.09.01.05.05.01;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	98.07.03.23.28.21;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	98.05.14.09.58.27;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.05.14.09.51.37;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.12.21.21.11.53;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.11.25.00.08.03;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.18.11.29.03;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.17.23.54.42;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.48;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.48;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.15
log
@The troll strikes.. The troll strikes.. The dungeon master dies.distrib/sets/lists
@
text
@/*	$OpenBSD: dm.c,v 1.14 2002/02/16 21:27:09 millert Exp $	*/
/*    $NetBSD: dm.c,v 1.5 1996/02/06 22:47:20 jtc Exp $       */

/*
 * Copyright (c) 1987, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1987, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)dm.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: dm.c,v 1.14 2002/02/16 21:27:09 millert Exp $";
#endif
#endif /* not lint */

#include <sys/param.h>
#include <sys/time.h>
#include <sys/resource.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <utmp.h>

#include "pathnames.h"

static time_t	now;			/* current time value */
static int	priority = 0;		/* priority game runs at */
static char	*game,			/* requested game */
		*gametty;		/* from tty? */

void	c_day(const char *, const char *, const char *);
void	c_game(const char *, const char  *, const char *, const char *);
void	c_tty(const char *);
const char *hour(int);
double	load(void);
int	main(int, char *[]);
void	nogamefile(void);
void	play(char **);
void	read_config(void);
int	users(void);
#ifdef LOG
void	logfile(void);
#endif

int
main(argc, argv)
	int argc;
	char *argv[];
{
	char *cp;

	nogamefile();
	game = (cp = strrchr(*argv, '/')) ? ++cp : *argv;

	if (!strcmp(game, "dm"))
		exit(0);

	gametty = ttyname(0);
	unsetenv("TZ");
	(void)time(&now);
	read_config();
#ifdef LOG
	logfile();
#endif
	play(argv);
	/*NOTREACHED*/
}

/*
 * play --
 *	play the game
 */
void
play(args)
	char **args;
{
	char pbuf[MAXPATHLEN];

	if (sizeof(_PATH_HIDE) + strlen(game) > sizeof(pbuf)) {
		(void)fprintf(stderr, "dm: %s/%s: %s\n", _PATH_HIDE, game,
			strerror(ENAMETOOLONG));
		exit(1);
	}
	(void)strcpy(pbuf, _PATH_HIDE);
	(void)strcpy(pbuf + sizeof(_PATH_HIDE) - 1, game);
	if (priority > 0)	/* < 0 requires root */
		(void)setpriority(PRIO_PROCESS, 0, priority);
	execv(pbuf, args);
	(void)fprintf(stderr, "dm: %s: %s\n", pbuf, strerror(errno));
	/* use fprintf(stderr, "dm: ...) for error conditions in dm.
	 * use err() and family for denied games, since then you get
	 *	the actual name of the game in the output message.
	 */
	exit(1);
}

/*
 * read_config --
 *	read through config file, looking for key words.
 */
void
read_config()
{
	FILE *cfp;
	char lbuf[BUFSIZ], f1[41], f2[41], f3[41], f4[41], f5[41];

	if (!(cfp = fopen(_PATH_CONFIG, "r")))
		return;
	while (fgets(lbuf, sizeof(lbuf), cfp))
		switch (*lbuf) {
		case 'b':		/* badtty */
			if (sscanf(lbuf, "%40s%40s", f1, f2) != 2 ||
			    strcasecmp(f1, "badtty"))
				break;
			c_tty(f2);
			break;
		case 'g':		/* game */
			if (sscanf(lbuf, "%40s%40s%40s%40s%40s",
			    f1, f2, f3, f4, f5) != 5 || strcasecmp(f1, "game"))
				break;
			c_game(f2, f3, f4, f5);
			break;
		case 't':		/* time */
			if (sscanf(lbuf, "%40s%40s%40s%40s", f1, f2, f3, f4) != 4 ||
			    strcasecmp(f1, "time"))
				break;
			c_day(f2, f3, f4);
		}
	(void)fclose(cfp);
}

/*
 * c_day --
 *	if day is today, see if okay to play
 */
void
c_day(s_day, s_start, s_stop)
	const char *s_day, *s_start, *s_stop;
{
	static const char *const days[] = {
		"sunday", "monday", "tuesday", "wednesday",
		"thursday", "friday", "saturday",
	};
	static struct tm *ct;
	int start, stop;

	if (!ct)
		ct = localtime(&now);
	if (strcasecmp(s_day, days[ct->tm_wday]))
		return;
	if (!isdigit(*s_start) || !isdigit(*s_stop))
		return;
	start = atoi(s_start);
	stop = atoi(s_stop);
	if (ct->tm_hour >= start && ct->tm_hour < stop) {
		if (start == 0 && stop == 24)
			errx(0, "Sorry, games are not available today.");
		else
			errx(0, "Sorry, games are not available from %s to %s today.",
			    hour(start), hour(stop));
	}
}

/*
 * c_tty --
 *	decide if this tty can be used for games.
 */
void
c_tty(tty)
	const char *tty;
{
	static int first = 1;
	static char *p_tty;

	if (first) {
		p_tty = strrchr(gametty, '/');
		first = 0;
	}

	if (!strcmp(gametty, tty) || (p_tty && !strcmp(p_tty, tty)))
		errx(0, "Sorry, you may not play games on %s.", gametty);
}

/*
 * c_game --
 *	see if game can be played now.
 */
void
c_game(s_game, s_load, s_users, s_priority)
	const char *s_game, *s_load, *s_users, *s_priority;
{
	static int found;

	if (found)
		return;
	if (strcmp(game, s_game) && strcasecmp("default", s_game))
		return;
	++found;
	if (isdigit(*s_load) && atoi(s_load) < load())
		errx(0, "Sorry, the load average is too high right now.");
	if (isdigit(*s_users) && atoi(s_users) <= users())
		errx(0, "Sorry, there are too many users logged on right now.");
	if (isdigit(*s_priority))
		priority = atoi(s_priority);
}

/*
 * load --
 *	return 15 minute load average
 */
double
load()
{
	double avenrun[3];

	if (getloadavg(avenrun, sizeof(avenrun)/sizeof(avenrun[0])) < 0) {
		(void)fputs("dm: getloadavg() failed.\n", stderr);
		exit(1);
	}
	return (avenrun[2]);
}

/*
 * users --
 *	return current number of users
 *	todo: check idle time; if idle more than X minutes, don't
 *	count them.
 */
int
users()
{
	
	int nusers, utmp;
	struct utmp buf;

	if ((utmp = open(_PATH_UTMP, O_RDONLY, 0)) < 0) {
		(void)fprintf(stderr, "dm: %s: %s\n",
		    _PATH_UTMP, strerror(errno));
		exit(1);
	}
	for (nusers = 0; read(utmp, (char *)&buf, sizeof(struct utmp)) > 0;)
		if (buf.ut_name[0] != '\0')
			++nusers;
	return (nusers);
}

void
nogamefile()
{
	int fd, n;
	char buf[BUFSIZ];

	if ((fd = open(_PATH_NOGAMES, O_RDONLY, 0)) >= 0) {
#define	MESG	"Sorry, no games right now.\n\n"
		(void)write(2, MESG, sizeof(MESG) - 1);
		while ((n = read(fd, buf, sizeof(buf))) > 0)
			(void)write(2, buf, n);
		exit(1);
	}
}

/*
 * hour --
 *	print out the hour in human form
 */
const char *
hour(h)
	int h;
{
	static const char *const hours[] = {
	    "midnight", "1am", "2am", "3am", "4am", "5am",
	    "6am", "7am", "8am", "9am", "10am", "11am",
	    "noon", "1pm", "2pm", "3pm", "4pm", "5pm",
	    "6pm", "7pm", "8pm", "9pm", "10pm", "11pm", "midnight" };

	if (h < 0 || h > 24)
		return ("BAD TIME");
	else
		return (hours[h]);
}

#ifdef LOG
/*
 * logfile --
 *	log play of game
 */
void
logfile()
{
	struct passwd *pw;
	FILE *lp;
	uid_t uid;
	int lock_cnt;

	if (lp = fopen(_PATH_LOG, "a")) {
		for (lock_cnt = 0;; ++lock_cnt) {
			if (!flock(fileno(lp), LOCK_EX))
				break;
			if (lock_cnt == 4) {
				perror("dm: log lock");
				(void)fclose(lp);
				return;
			}
			sleep((u_int)1);
		}
		if (pw = getpwuid(uid = getuid()))
			(void)fputs(pw->pw_name, lp);
		else
			(void)fprintf(lp, "%u", uid);
		(void)fprintf(lp, "\t%s\t%s\t%s", game, gametty, ctime(&now));
		(void)flock(fileno(lp), LOCK_UN);
		(void)fclose(lp);
	}
}
#endif /* LOG */
@


1.14
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: dm.c,v 1.13 1999/09/25 15:52:19 pjanzen Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dm.c,v 1.13 1999/09/25 15:52:19 pjanzen Exp $";
@


1.13
log
@Tidying and minor changes from or based on jsm28@@cam.ac.uk's work for the
Linux bsd-games package and NetBSD.  Mainly using 'const'.
@
text
@d1 1
a1 1
/*	$OpenBSD: dm.c,v 1.12 1999/08/16 17:00:14 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dm.c,v 1.12 1999/08/16 17:00:14 millert Exp $";
d74 10
a83 10
void	c_day __P((const char *, const char *, const char *));
void	c_game __P((const char *, const char  *, const char *, const char *));
void	c_tty __P((const char *));
const char *hour __P((int));
double	load __P((void));
int	main __P((int, char *[]));
void	nogamefile __P((void));
void	play __P((char **));
void	read_config __P((void));
int	users __P((void));
d85 1
a85 1
void	logfile __P((void));
@


1.12
log
@use O_* defines for open(2) flags and include fcntl.h
@
text
@d1 1
a1 1
/*	$OpenBSD: dm.c,v 1.11 1999/07/31 18:48:52 pjanzen Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dm.c,v 1.11 1999/07/31 18:48:52 pjanzen Exp $";
a58 1
#include <nlist.h>
@


1.11
log
@Use const where appropriate:  jsm28@@cam.ac.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: dm.c,v 1.10 1998/09/06 12:14:04 pjanzen Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dm.c,v 1.10 1998/09/06 12:14:04 pjanzen Exp $";
a51 1
#include <sys/file.h>
d55 1
a56 1
#include <ctype.h>
d58 1
@


1.10
log
@Some changes from NetBSD, and improved documentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: dm.c,v 1.9 1998/09/01 05:05:01 pjanzen Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dm.c,v 1.9 1998/09/01 05:05:01 pjanzen Exp $";
d75 3
a77 3
void	c_day __P((char *, char *, char *));
void	c_game __P((char *, char  *, char *, char *));
void	c_tty __P((char *));
d182 1
a182 1
	char *s_day, *s_start, *s_stop;
d184 1
a184 1
	static char *days[] = {
d214 1
a214 1
	char *tty;
d234 1
a234 1
	char *s_game, *s_load, *s_users, *s_priority;
d314 1
a314 1
	static char *hours[] = {
@


1.9
log
@Don't let users circumvent time restrictions with TZ; jsm28@@cam.ac.uk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dm.c,v 1.8 1998/07/03 23:28:21 pjanzen Exp $";
d56 1
d58 1
a66 1
#include <errno.h>
d75 14
d117 1
d134 4
d145 1
d154 1
a154 1
		switch(*lbuf) {
d180 1
d200 5
a204 6
		(void)fputs("dm: Sorry, games are not available from ", stderr);
		hour(start);
		(void)fputs(" to ", stderr);
		hour(stop);
		(void)fputs(" today.\n", stderr);
		exit(0);
d212 1
d224 2
a225 4
	if (!strcmp(gametty, tty) || p_tty && !strcmp(p_tty, tty)) {
		(void)fprintf(stderr, "dm: Sorry, you may not play games on %s.\n", gametty);
		exit(0);
	}
d232 1
a236 1
	double load();
d243 4
a246 8
	if (isdigit(*s_load) && atoi(s_load) < load()) {
		(void)fputs("dm: Sorry, the load average is too high right now.\n", stderr);
		exit(0);
	}
	if (isdigit(*s_users) && atoi(s_users) <= users()) {
		(void)fputs("dm: Sorry, there are too many users logged on right now.\n", stderr);
		exit(0);
	}
d264 1
a264 1
	return(avenrun[2]);
d273 1
d277 1
a277 1
	register int nusers, utmp;
d288 1
a288 1
	return(nusers);
d291 1
d294 1
a294 1
	register int fd, n;
d310 1
d314 10
a323 13
	switch(h) {
	case 0:
		(void)fputs("midnight", stderr);
		break;
	case 12:
		(void)fputs("noon", stderr);
		break;
	default:
		if (h > 12)
			(void)fprintf(stderr, "%dpm", h - 12);
		else
			(void)fprintf(stderr, "%dam", h);
	}
d331 1
@


1.8
log
@typo
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dm.c,v 1.7 1998/05/14 09:58:27 deraadt Exp $";
d60 1
d88 1
@


1.7
log
@better buf oflow protection
@
text
@d46 1
a46 1
static char rcsid[] = "$OpenBSD: dm.c,v 1.6 1998/05/14 09:51:37 deraadt Exp $";
d132 1
a132 1
			if (sscanf(lbuf, "%40s40%s", f1, f2) != 2 ||
@


1.6
log
@buf oflows
@
text
@d46 1
a46 1
static char rcsid[] = "$OpenBSD: dm.c,v 1.5 1996/12/21 21:11:53 tholo Exp $";
d125 1
a125 1
	char lbuf[BUFSIZ], f1[40], f2[40], f3[40], f4[40], f5[40];
@


1.5
log
@Don't reset group here, we won't be able to execute games that way
@
text
@d46 1
a46 1
static char rcsid[] = "$OpenBSD: dm.c,v 1.4 1996/11/25 00:08:03 millert Exp $";
d132 1
a132 1
			if (sscanf(lbuf, "%s%s", f1, f2) != 2 ||
d138 1
a138 1
			if (sscanf(lbuf, "%s%s%s%s%s",
d144 1
a144 1
			if (sscanf(lbuf, "%s%s%s%s", f1, f2, f3, f4) != 4 ||
@


1.4
log
@rindex -> strrchr
add some void casts
safe strcpy
@
text
@d46 1
a46 1
static char rcsid[] = "$OpenBSD: dm.c,v 1.5 1996/02/06 22:47:20 jtc Exp $";
a112 1
	setgid(getgid());	/* we run setgid kmem; lose it */
@


1.3
log
@LOCK_UN before close, not after
@
text
@d46 1
a46 1
static char rcsid[] = "$NetBSD: dm.c,v 1.5 1996/02/06 22:47:20 jtc Exp $";
d80 1
a80 1
	game = (cp = rindex(*argv, '/')) ? ++cp : *argv;
d104 5
d176 1
a176 1
		fputs("dm: Sorry, games are not available from ", stderr);
d178 1
a178 1
		fputs(" to ", stderr);
d180 1
a180 1
		fputs(" today.\n", stderr);
d196 1
a196 1
		p_tty = rindex(gametty, '/');
d201 1
a201 1
		fprintf(stderr, "dm: Sorry, you may not play games on %s.\n", gametty);
d222 1
a222 1
		fputs("dm: Sorry, the load average is too high right now.\n", stderr);
d226 1
a226 1
		fputs("dm: Sorry, there are too many users logged on right now.\n", stderr);
d243 1
a243 1
		fputs("dm: getloadavg() failed.\n", stderr);
d295 1
a295 1
		fputs("midnight", stderr);
d298 1
a298 1
		fputs("noon", stderr);
d302 1
a302 1
			fprintf(stderr, "%dpm", h - 12);
d304 1
a304 1
			fprintf(stderr, "%dam", h);
d332 1
a332 1
			fputs(pw->pw_name, lp);
d334 2
a335 2
			fprintf(lp, "%u", uid);
		fprintf(lp, "\t%s\t%s\t%s", game, gametty, ctime(&now));
@


1.2
log
@From netbsd:
Removed "extern int errno"; Added #include <errno.h> if not already present.
@
text
@d331 1
a332 1
		(void)flock(fileno(lp), LOCK_UN);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: dm.c,v 1.4 1995/03/21 15:09:05 cgd Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: dm.c,v 1.4 1995/03/21 15:09:05 cgd Exp $";
d63 1
a66 1
extern int errno;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
