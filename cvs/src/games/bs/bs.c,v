head	1.39;
access;
symbols
	OPENBSD_6_1:1.39.0.4
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.2
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.27.0.6
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.23.0.16
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.14
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.12
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.10
	OPENBSD_5_0:1.23.0.8
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.20.0.28
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.24
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.22
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.20
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.18
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.16
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.14
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.12
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.10
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.8
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.6
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.7.0.10
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.8
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.6
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.39
date	2016.03.07.12.07.55;	author mestre;	state Exp;
branches;
next	1.38;
commitid	NZhYxChmyb9vOEMM;

1.38
date	2016.01.10.14.10.39;	author mestre;	state Exp;
branches;
next	1.37;
commitid	uHkFLRJtNioh0rOz;

1.37
date	2016.01.08.20.19.06;	author mestre;	state Exp;
branches;
next	1.36;
commitid	PTQLpBd4PWarQahN;

1.36
date	2016.01.07.16.00.32;	author tb;	state Exp;
branches;
next	1.35;
commitid	IwzFE3fG5RnKTWNh;

1.35
date	2016.01.03.14.38.17;	author mestre;	state Exp;
branches;
next	1.34;
commitid	Ptgw9rNvmSHNRfGy;

1.34
date	2015.12.26.00.26.39;	author mestre;	state Exp;
branches;
next	1.33;
commitid	NcBz9zfScw6TwPoT;

1.33
date	2015.12.25.03.20.57;	author mestre;	state Exp;
branches;
next	1.32;
commitid	TtQU579S2TvNYAae;

1.32
date	2015.12.24.16.55.13;	author tb;	state Exp;
branches;
next	1.31;
commitid	XmwyicID0wdrawf9;

1.31
date	2015.12.04.10.41.35;	author tedu;	state Exp;
branches;
next	1.30;
commitid	euZqaYqmliysTkDd;

1.30
date	2015.11.30.08.33.29;	author tb;	state Exp;
branches;
next	1.29;
commitid	ctCkwLyq1AO0Zh92;

1.29
date	2015.10.24.17.29.03;	author mmcc;	state Exp;
branches;
next	1.28;
commitid	sW6Sq9u9I2JMl7Lg;

1.28
date	2015.09.27.05.27.42;	author guenther;	state Exp;
branches;
next	1.27;
commitid	dFxAhVDEVAo1gM1T;

1.27
date	2015.02.18.23.41.31;	author tedu;	state Exp;
branches;
next	1.26;
commitid	MS4aelkbiEvDWjU3;

1.26
date	2014.11.16.04.49.48;	author guenther;	state Exp;
branches;
next	1.25;
commitid	8XNajyb9IqHkZEKg;

1.25
date	2014.07.12.08.29.56;	author tedu;	state Exp;
branches;
next	1.24;
commitid	0Q3K6ByGgQzSipmY;

1.24
date	2013.08.29.20.22.11;	author naddy;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.14.02.20.43;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.27.23.59.24;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.17.21.45.50;	author sobrado;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.11.08.47.44;	author pjanzen;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.19.08.18.23;	author pjanzen;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.06.21.48.51;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.09.09.54.30;	author pjanzen;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.09.08.42.30;	author pjanzen;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.09.08.36.33;	author pjanzen;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.31.04.21.29;	author pjanzen;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.31.03.40.00;	author pjanzen;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.18.06.45.26;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.23.23.04.33;	author pjanzen;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.17.23.00.05;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.08.02.23.11;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.23.22.23.42;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	98.03.12.09.03.49;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	98.03.12.06.17.25;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	97.07.23.20.04.49;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.02.14.10.28.17;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.12.22.20.01.00;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.12.19.22.21.13;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.08.21.08.18.36;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.39
log
@- General changes:
- Remove -? from getopt(3) options, but still keep (or add) -h where applicable
- Replace hardcoded program strings by getprogname(3)

- Specific changes:
- atc(6): this used -? and -u for usage(), remove both from game and manpage
- bcd(6): use __progname instead of getprogname(3), no need to include stdlib.h
- hunt(6): replace fputs(3) by fprintf(3)

OK tb@@ after his suggestions
@
text
@/*	$OpenBSD: bs.c,v 1.38 2016/01/10 14:10:39 mestre Exp $	*/
/*
 * Copyright (c) 1986, Bruce Holloway
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * 
 * - Redistributions of source code must retain the above copyright
 *  notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * - Neither the name of the <ORGANIZATION> nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@@snark.thyrsus.com>
 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 * v2.2 with bugfixes and strategical improvements, March 1998.
 */

#include <ctype.h>
#include <curses.h>
#include <err.h>
#include <limits.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

typedef struct {
	char *name;		/* name of the ship type */
	char hits;		/* how many times has this ship been hit? */
	char symbol;		/* symbol for game purposes */
	char length;		/* length of ship */
	signed char x, y;	/* coordinates of ship start point */
	unsigned char dir;	/* direction of `bow' */
	bool placed;		/* has it been placed on the board? */
} ship_t;

static void	 announceopts(void);
static int	 awinna(void);
static bool	 checkplace(int, ship_t *, int);
static int	 collidecheck(int, int, int);
static int	 cpufire(int, int);
static bool	 cpushipcanfit(int, int, int, int);
static int	 cputurn(void);
static void	 do_options(int, char *[]);
static void	 error(char *);
static int	 getcoord(int);
static ship_t	*hitship(int, int);
static void	 initgame(void);
static void	 intro(void);
static void	 placeship(int, ship_t *, int);
static int	 playagain(void);
static int	 plyturn(void);
static void	 prompt(int, const char *, ...)
    __attribute__((__format__ (printf, 2, 3)));
static void	 randomfire(int *, int *);
static void	 randomplace(int, ship_t *);
static int	 rnd(int);
static int	 scount(int);
static int	 sgetc(char *);
__dead static void	 uninitgame(int);
__dead void	 usage(void);

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	isupper(c)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define CYINV(y)	((y) - CYBASE)
#define CXINV(x)	(((x) - CXBASE) / 3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[LOGIN_NAME_MAX];
static char dftname[] = "stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = { 1,  1,  0, -1, -1, -1,  0,  1 };
static int yincr[8] = { 0,  1,  1,  1,  0, -1, -1, -1 };

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

ship_t plyship[SHIPTYPES] =
{
	{ carrier,	0, 'A', 5, 0, 0, 0, FALSE },
	{ battle,	0, 'B', 4, 0, 0, 0, FALSE },
	{ destroy,	0, 'D', 3, 0, 0, 0, FALSE },
	{ sub,		0, 'S', 3, 0, 0, 0, FALSE },
	{ ptboat,	0, 'P', 2, 0, 0, 0, FALSE }
};

ship_t cpuship[SHIPTYPES] =
{
	{ carrier,	0, 'A', 5, 0, 0, 0, FALSE },
	{ battle,	0, 'B', 4, 0, 0, 0, FALSE },
	{ destroy,	0, 'D', 3, 0, 0, 0, FALSE },
	{ sub,		0, 'S', 3, 0, 0, 0, FALSE },
	{ ptboat,	0, 'P', 2, 0, 0, 0, FALSE }
};

/* The following variables (and associated defines), used for computer 
 * targetting, must be global so that they can be reset for each new game 
 * played without restarting the program.
 */
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
/* Computer needs to keep track of longest and shortest player ships still
 * not sunk, for better targetting. 
 */
static int cpushortest;
static int cpulongest;

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH], board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static int salvo, blitz, closepack;

/* end the game, either normally or due to signal */
static void
uninitgame(int sig)
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(sig);
}

/* announce which game options are enabled */
static void
announceopts(void)
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void
intro(void)
{
    char *tmpname;

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if ((tmpname = getlogin()) != NULL)
    {
	(void)strlcpy(name, tmpname, sizeof(name));
	name[0] = toupper((unsigned char)name[0]);
    }
    else
	(void)strlcpy(name, dftname, sizeof(name));

    (void)initscr();
    keypad(stdscr, TRUE);
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

    if ((LINES < PROMPTLINE + 3) || (COLS < COLWIDTH)) {
	endwin();
	errx(1, "screen must be at least %dx%d.", PROMPTLINE + 3, COLWIDTH);
    }

#define	PR	(void)addstr
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/     \\__/    \\      \\/             |\n");
    PR("                           \\/     \\/  \\/    \\_____/              |__\n");
    PR("           ________________/    /\\/  ..\\/                         |\n");
    PR("           \\  S.S. Puffy        \\/\\___o/                          |\n");
    PR("            \\                     / /\\ \\                          /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();

    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);

    (void) mousemask(BUTTON1_CLICKED, (mmask_t *)NULL);
}

/* print a message at the prompt line */
static void
prompt(int n, const char *f, ...)
{
    va_list va;

    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    va_start(va, f);
    (void) vw_printw(stdscr, f, va);
    va_end(va);
    (void) refresh();
}

static void
error(char *s)
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void
placeship(int b, ship_t *ss, int vis)
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static int
rnd(int n)
{
    return(arc4random_uniform(n));
}

/* generate a valid random ship placement into px,py */
static void
randomplace(int b, ship_t *ss)
{
    do {
	ss->dir = rnd(2) ? E : S;
	ss->x = rnd(BWIDTH - (ss->dir == E ? ss->length : 0));
	ss->y = rnd(BDEPTH - (ss->dir == S ? ss->length : 0));
    } while
	(!checkplace(b, ss, FALSE));
}

static void
initgame(void)
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    /* Set up global CPU algorithm variables. */
    next = RANDOM_FIRE;
    turncount = 0;
    srchstep = BEGINSTEP;
    /* set up cpulongest and cpushortest (computer targetting variables) */
    cpushortest = cpulongest = cpuship->length;

    memset(board, 0, sizeof(char) * BWIDTH * BDEPTH * 2);
    memset(hits,  0, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;
	ss->x = ss->y = ss->dir = ss->hits = 0;
	ss->placed = FALSE;
	ss = plyship + i;
	ss->x = ss->y = ss->dir = ss->hits = 0;
	ss->placed = FALSE;

     if (ss->length > cpulongest)
		cpulongest  = ss->length;
     if (ss->length < cpushortest)
		cpushortest = ss->length;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, (chtype)(i + 'A'));
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
	attrset(0);
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, (chtype)(i + 'A'));
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
	attrset(0);
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	char docked[SHIPTYPES + 2], *cp = docked;
	int c;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}
regetchar:
	c = getch();
	switch (c) {
	case FF:
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
	case 'r':
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
		error(NULL);
	    ss->placed = TRUE;
	    break;
	case 'R':
	    prompt(1, "Placing the rest of your fleet at random...");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error(NULL);
	    break;

	case 'k': case 'j': case 'h': case 'l':
	case '8': case '2': case '4': case '6':
	case KEY_LEFT: case KEY_RIGHT: case KEY_UP: case KEY_DOWN:
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': case KEY_UP: ss->dir = N; break;
	    case 'j': case '2': case KEY_DOWN: ss->dir = S; break;
	    case 'h': case '4': case KEY_LEFT: ss->dir = W; break;
	    case 'l': case '6': case KEY_RIGHT: ss->dir = E; break;
	    }

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error(NULL);
		ss->placed = TRUE;
	    }
	    break;
	default:
	    goto regetchar;
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...");
    (void) getch();
}

static int
getcoord(int atcpu)
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8':
	case KEY_UP:
	    ny = cury+BDEPTH-1; nx = curx;
	    break;
	case 'j': case '2':
	case KEY_DOWN:
	    ny = cury+1;        nx = curx;
	    break;
	case 'h': case '4':
	case KEY_LEFT:
	    ny = cury;          nx = curx+BWIDTH-1;
	    break;
	case 'l': case '6':
	case KEY_RIGHT:
	    ny = cury;          nx = curx+1;
	    break;
	case 'y': case '7':
	case KEY_A1:
	    ny = cury+BDEPTH-1; nx = curx+BWIDTH-1;
	    break;
	case 'b': case '1':
	case KEY_C1:
	    ny = cury+1;        nx = curx+BWIDTH-1;
	    break;
	case 'u': case '9':
	case KEY_A3:
	    ny = cury+BDEPTH-1; nx = curx+1;
	    break;
	case 'n': case '3':
	case KEY_C3:
	    ny = cury+1;        nx = curx+1;
	    break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
	case KEY_MOUSE:
	    {
		MEVENT	myevent;

		getmouse(&myevent);
		if (atcpu
			&& myevent.y >= CY(0) && myevent.y < CY(BDEPTH)
			&& myevent.x >= CX(0) && myevent.x < CX(BWIDTH))
		{
		    curx = CXINV(myevent.x);
		    cury = CYINV(myevent.y);
		    return(' ');
		}
		else
		    beep();
	    }
	    break;
	case ERR:
	    uninitgame(1);
	    break;
	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

/* is this location on the selected zboard adjacent to a ship? */
static int
collidecheck(int b, int y, int x)
{
    int	collide;

    /* anything on the square */
    if ((collide = IS_SHIP(board[b][x][y])) != 0)
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend))
		collide += IS_SHIP(board[b][xend][yend]);
	}
    }
    return(collide);
}

static bool
checkplace(int b, ship_t *ss, int vis)
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + (ss->length - 1) * xincr[ss->dir];
    yend = ss->y + (ss->length - 1) * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if (vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(FALSE);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert!  Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(FALSE);
	    }
	}
    return(TRUE);
}

static int
awinna(void)
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

/* register a hit on the targeted ship */
static ship_t *
hitship(int x, int y)
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if(!(sym = board[OTHER][x][y]))
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x1, y1;

			    x1 = bx + i * xincr[ss->dir];
			    y1 = by + i * yincr[ss->dir];
			    if (ONBOARD(x1, y1))
			    {
				hits[turn][x1][y1] = MARK_MISS;
				if (turn == PLAYER)
				{
				    cgoto(y1, x1);
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
				    (void)addch(MARK_MISS);
				    attrset(0);
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x1 = ss->x + i * xincr[ss->dir];
		    int y1 = ss->y + i * yincr[ss->dir];

		    hits[turn][x1][y1] = ss->symbol;
		    if (turn  == PLAYER)
		    {
			cgoto(y1, x1);
			(void) addch((chtype)(ss->symbol));
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int
plyturn(void)
{
    ship_t *ss;
    int hit;
    char *m = NULL;

    prompt(1, "Where do you want to shoot? ");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = hit ? MARK_HIT : MARK_MISS;
    cgoto(cury, curx);
    if (has_colors()) {
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
    }
    (void) addch((chtype)hits[PLAYER][curx][cury]);
    attrset(0);

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
    }
    return(hit);
}

static int
sgetc(char *s)
{
    char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame(0);
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void) refresh();
	    return(ch);
	    }
	}
}

/* Checks to see if there's room for a ship of a given length in a given
 * direction.  If direction is negative, check in all directions.  Note
 * that North and South are equivalent, as are East and West.
 */
static bool
cpushipcanfit(int x, int y, int length, int direction)
{
	int len = 1;
	int x1, y1;

	if (direction >= 0)
	{
		direction %= 4;
		while (direction < 8)
		{
			x1 = x + xincr[direction];
			y1 = y + yincr[direction];
			while (POSSIBLE(x1,y1))
			{
			    len++;
			    x1 += xincr[direction];
			    y1 += yincr[direction];
			}
			direction += 4;
		}
		return (len >= length);
	}
	else
	{
		return ((cpushipcanfit(x,y,length,E)) ||
			    (cpushipcanfit(x,y,length,S)));
	}
}

/* random-fire routine -- implements simple diagonal-striping strategy */
static void
randomfire(int *px, int *py)
{
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves on the diagonal stripe */
    nposs = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if ((!hits[COMPUTER][x][y]) &&
		 	(((x+huntoffs) % srchstep) == (y % srchstep)) &&
			(cpushipcanfit(x,y,cpulongest,-1)))
	    {
		    xpossible[nposs] = x;
		    ypossible[nposs] = y;
		    nposs++;
		}
    if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];
    }
	else if (srchstep > cpulongest)
    {
	     --srchstep; 
	     randomfire(px, py);
    }
	else
    {
		error("No moves possible?? Help!");
		exit(1);
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

/* fire away at given location */
static int
cpufire(int x, int y)
{
    int hit;
    bool sunk;
    ship_t *ss = NULL;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if ((sunk = (hit && (ss = hitship(x, y)))))
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
    if (has_colors()) {
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
    }
    (void) addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
    attrset(0);

    return(hit ? (sunk ? S_SUNK : S_HIT) : S_MISS);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static int
cputurn(void)
{
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n, hit = S_MISS;
    bool closenoshot = FALSE;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[W/2] = (!(cpushipcanfit(ts.x,ts.y,cpushortest,E)));
	used[S/2] = used[N/2] = (!(cpushipcanfit(ts.x,ts.y,cpushortest,S)));
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--,d++)
		while (used[d])
		    d++;
	    d--;

	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y))
	{
	    if ((hit = cpufire(x, y)))
	    {
		    ts.x = x; ts.y = y; ts.hits++;
		    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	    else
	         next = REVERSE_JUMP;
	    break;
	}
	else
	    next = REVERSE_JUMP;
	/* FALL THROUGH */

    case REVERSE_JUMP:	/* nail down the ship's other end */
	ts.dir = (ts.dir + 4) % 8;
	ts.x += (ts.hits-1) * xincr[ts.dir];
	ts.y += (ts.hits-1) * yincr[ts.dir];
	/* FALL THROUGH */

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y))
	{
	    if ((hit = cpufire(x, y)))
	    {
		    ts.x = x; ts.y = y; ts.hits++;
		    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	    }
	    else
	    {
	    /* The only way to get here is if closepack is on; otherwise,
	     * we _have_ sunk the ship.  I set hit to S_SUNK just to get
	     * the additional closepack logic at the end of the switch.
	     */
/*assert closepack*/
if (!closepack)  error("Assertion failed: not closepack 1");
		    hit = S_SUNK;
		    next = RANDOM_FIRE;
	    }
	}
	else
	{
/*assert closepack*/
if (!closepack)  error("Assertion failed: not closepack 2");
	    hit = S_SUNK;
	    closenoshot = TRUE;  /* Didn't shoot yet! */
	    next = RANDOM_FIRE;
	}
	break;
    }   /* switch(next) */

    if (hit == S_SUNK)
    {
	   /* Update cpulongest and cpushortest.  We could increase srchstep
	    * if it's smaller than cpushortest but that makes strategic sense
	    * only if we've been doing continuous diagonal stripes, and that's
	    * less interesting to watch.
	    */
	    ship_t *sp = plyship;

	    cpushortest = cpulongest;
	    cpulongest  = 0;
	    for (d=0 ; d < SHIPTYPES; d++, sp++)
	    {
		   if (sp->hits < sp->length)
		   {
		cpushortest = (cpushortest < sp->length) ? cpushortest : sp->length;
		cpulongest  = (cpulongest  > sp->length) ? cpulongest  : sp->length;
		   }
	    }
	    /* Now, if we're in closepack mode, we may have knocked off part of
	     * another ship, in which case we shouldn't do RANDOM_FIRE.  A
		* more robust implementation would probably do this check regardless
		* of whether closepack was set or not.
		* Note that MARK_HIT is set only for ships that aren't sunk;
		* hitship() changes the marker to the ship's character when the
		* ship is sunk.
	     */
	    if (closepack)
	    {
		  ts.hits = 0;
		  for (x = 0; x < BWIDTH; x++)
			for (y = 0; y < BDEPTH; y++)
			{
				if (hits[COMPUTER][x][y] == MARK_HIT)
				{
				/* So we found part of another ship.  It may have more
				 * than one hit on it.  Check to see if it does.  If no
				 * hit does, take the last MARK_HIT and be RANDOM_HIT.
				 */
	ts.x = x; ts.y = y; ts.hits = 1;
	for (d = 0; d < 8; d += 2)
	{
	    while ((ONBOARD(ts.x, ts.y)) && 
			(hits[COMPUTER][(int)ts.x][(int)ts.y] == MARK_HIT))
	    {
		    ts.x += xincr[d]; ts.y += yincr[d]; ts.hits++;
	    }
	    if ((--ts.hits > 1) && (ONBOARD(ts.x, ts.y)) &&
		    (hits[COMPUTER][(int)ts.x][(int)ts.y] == 0))
	    {
		    ts.dir = d;
		    ts.x -= xincr[d]; ts.y -= yincr[d];
		    d = 100;                  /* use as a flag */
		    x = BWIDTH; y = BDEPTH;   /* end the loop */
	    } else {
	         ts.x = x; ts.y = y; ts.hits = 1;
	    }
	
	}
				}
				if (ts.hits)
				{
					next = (d >= 100) ? FIRST_PASS : RANDOM_HIT;
				} else
					next = RANDOM_FIRE;
				}
	    }
	    if (closenoshot)
	    {
		   return(cputurn());
	    }
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }

    return(hit);
}

static int
playagain(void)
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void) addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
	/* If you play a hundred games or more at a go, you deserve a badly
	 * centred score output.
	 */
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

__dead void
usage(void)
{
	(void) fprintf(stderr, "usage: %s [-b | -s] [-c]\n", getprogname());
	(void) fprintf(stderr, "\tWhere the options are:\n");
	(void) fprintf(stderr, "\t-b : play a blitz game\n");
	(void) fprintf(stderr, "\t-s : play a salvo game\n");
	(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
	exit(1);
}

static void
do_options(int c, char *op[])
{
    int ch;

    while ((ch = getopt(c, op, "bchs")) != -1) {
	switch (ch) {
	case 'b':
	    blitz = 1;
	    if (salvo == 1)
	    {
		(void) fprintf(stderr,
			"Bad Arg: -b and -s are mutually exclusive\n");
		exit(1);
	    }
	    break;
	case 's':
	    salvo = 1;
	    if (blitz == 1)
	    {
		(void) fprintf(stderr,
			"Bad Arg: -s and -b are mutually exclusive\n");
		exit(1);
	    }
	    break;
	case 'c':
	    closepack = 1;
	    break;
	case 'h':
	default:
	    (void) usage();
	    exit(1);
	}
    }
    if (op[optind] != NULL)
	(void) usage();
}

static int
scount(int who)
{
    int i, shots;
    ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i = 0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

int
main(int argc, char *argv[])
{
    if (pledge("stdio rpath tty", NULL) == -1)
        err(1, "pledge");

    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else  /* salvo */
		{
		    int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		}
	    }
	    else  /* blitz */
	    	while(turn ? cputurn() : plyturn())
		{
		    if (turn)   /* Pause between successive computer shots */
		    {
			(void)refresh();
			(void)sleep(1);
		    }
		    if (awinna() != -1)
		     break;
		}
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame(0);
    return 0;
}
@


1.38
log
@Remove needless casts to (char *) NULL. Some were kept, namely for execl(3)
last arguments since "The list of arguments must be terminated by a null
null pointer" of type char *

Suggested by and OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.37 2016/01/08 20:19:06 mestre Exp $	*/
d1269 1
a1269 1
	(void) fprintf(stderr, "usage: bs [-b | -s] [-c]\n");
@


1.37
log
@Remove unnecessary headers an sort
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.36 2016/01/07 16:00:32 tb Exp $	*/
d515 1
a515 1
	    error((char *)NULL);
d527 1
a527 1
	    error((char *)NULL);
d547 1
a547 1
		error((char *)NULL);
@


1.36
log
@Some basic code maintenance in games/

- in main() replace exit with return
- drop some /* NOTREACHED */ lint comments along the way.
- make more use of standard CFLAGS, esp. -Wimplicit-function-declaration
- add and sort some headers when needed
- add straightforward pledges to some programs used at compile time

discussed with and ok mestre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.35 2016/01/03 14:38:17 mestre Exp $	*/
d42 1
a42 1
#include <sys/types.h>
a43 1
#include <ctype.h>
@


1.35
log
@About 13 years ago when the idiom srandom(time()), and sometimes
srandom(time()+getpid()), was changed by srandomdev(), but #include <time.h>
lived up until this day so remove it.

Additionally, earlier than that, 18 years ago, random(6) was one of the first
consumers of arc4random(3) family, and was pulling it from dev/rndvar.h but
these days we pull it from stdlib.h, which is already done, so while here
remove dev/rndvar.h also.

"seems comprehensive to me" deraadt@@ and OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.34 2015/12/26 00:26:39 mestre Exp $	*/
d1395 1
a1395 2
    /*NOTREACHED*/
    exit(0);
@


1.34
log
@Set as __dead a few more functions, that don't return, on games/

With precious tip, help and also OK from tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.33 2015/12/25 03:20:57 mestre Exp $	*/
a49 1
#include <time.h>
@


1.33
log
@Apply some more KNF to the declaration of functions, but keep style to the rest of code for now.

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.32 2015/12/24 16:55:13 tb Exp $	*/
d86 1
a86 1
static void	 uninitgame(int);
@


1.32
log
@Function prototypes and a little bit of KNF.

Committing on behalf of mestre@@ who has more to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.31 2015/12/04 10:41:35 tedu Exp $	*/
a216 1
static void uninitgame(int sig)
d218 2
a228 1
static void announceopts(void)
d230 2
d254 2
a255 1
static void intro(void)
a316 2
static void prompt(int, const char *, ...)
			__attribute__((__format__ (printf, 2, 3)));
d330 2
a331 1
static void error(char *s)
d342 2
a343 1
static void placeship(int b, ship_t *ss, int vis)
d362 2
a363 1
static int rnd(int n)
a367 1
static void randomplace(int b, ship_t *ss)
d369 2
d380 2
a381 1
static void initgame(void)
d581 2
a582 1
static int getcoord(int atcpu)
a675 1
static int collidecheck(int b, int y, int x)
d677 2
d704 2
a705 1
static bool checkplace(int b, ship_t *ss, int vis)
d753 2
a754 1
static int awinna(void)
a770 1
static ship_t *hitship(int x, int y)
d772 2
d840 2
a841 1
static int plyturn(void)
d898 2
a899 1
static int sgetc(char *s)
a922 1
static bool cpushipcanfit(int x, int y, int length, int direction)
d927 2
a956 2

static void randomfire(int *px, int *py)
d958 2
a1002 1
static int cpufire(int x, int y)
d1004 2
d1036 2
a1037 1
static int cputurn(void)
d1235 2
a1236 2
static
int playagain(void)
d1268 2
a1269 1
void usage()
d1279 2
a1280 1
static void do_options(int c, char *op[])
d1317 2
a1318 1
static int scount(int who)
d1338 2
a1339 1
int main(int argc, char *argv[])
@


1.31
log
@assume modern curses and unifdef ancient feature tests
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.30 2015/11/30 08:33:29 tb Exp $	*/
d53 35
a87 1
static int getcoord(int atcpu);
d164 2
a165 2
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};
a170 14
typedef struct
{
    char *name;		/* name of the ship type */
    char hits;		/* how many times has this ship been hit? */
    char symbol;	/* symbol for game purposes */
    char length;	/* length of ship */
    signed char x, y;	/* coordinates of ship start point */
    unsigned char dir;	/* direction of `bow' */
    bool placed;	/* has it been placed on the board? */
}
ship_t;

static bool checkplace(int b, ship_t *ss, int vis);

d173 5
a177 5
    { carrier,	0, 'A', 5, 0, 0, 0, FALSE},
    { battle,	0, 'B', 4, 0, 0, 0, FALSE},
    { destroy,	0, 'D', 3, 0, 0, 0, FALSE},
    { sub,	0, 'S', 3, 0, 0, 0, FALSE},
    { ptboat,	0, 'P', 2, 0, 0, 0, FALSE}
d182 5
a186 5
    { carrier,	0, 'A', 5, 0, 0, 0, FALSE},
    { battle,	0, 'B', 4, 0, 0, 0, FALSE},
    { destroy,	0, 'D', 3, 0, 0, 0, FALSE},
    { sub,	0, 'S', 3, 0, 0, 0, FALSE},
    { ptboat,	0, 'P', 2, 0, 0, 0, FALSE}
@


1.30
log
@pledge "stdio rpath tty" for bs
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.29 2015/10/24 17:29:03 mmcc Exp $	*/
a249 1
#ifdef KEY_MIN
a250 1
#endif /* KEY_MIN */
a278 1
#ifdef A_COLOR
a288 1
#endif /* A_COLOR */
a289 1
#ifdef NCURSES_MOUSE_VERSION
a290 1
#endif /* NCURSES_MOUSE_VERSION*/
a394 1
#ifdef A_COLOR
a396 1
#endif /* A_COLOR */
a399 1
#ifdef A_COLOR
a400 1
#endif /* A_COLOR */
a409 1
#ifdef A_COLOR
a411 1
#endif /* A_COLOR */
a414 1
#ifdef A_COLOR
a415 1
#endif /* A_COLOR */
a579 1
#ifdef KEY_MIN
a580 1
#endif /* KEY_MIN */
a583 1
#ifdef KEY_MIN
a584 1
#endif /* KEY_MIN */
a587 1
#ifdef KEY_MIN
a588 1
#endif /* KEY_MIN */
a591 1
#ifdef KEY_MIN
a592 1
#endif /* KEY_MIN */
a595 1
#ifdef KEY_MIN
a596 1
#endif /* KEY_MIN */
a599 1
#ifdef KEY_MIN
a600 1
#endif /* KEY_MIN */
a603 1
#ifdef KEY_MIN
a604 1
#endif /* KEY_MIN */
a607 1
#ifdef KEY_MIN
a608 1
#endif /* KEY_MIN */
a615 1
#ifdef NCURSES_MOUSE_VERSION
a632 1
#endif /* NCURSES_MOUSE_VERSION */
a778 1
#ifdef A_COLOR
a780 1
#endif /* A_COLOR */
a781 1
#ifdef A_COLOR
a782 1
#endif /* A_COLOR */
a829 1
#ifdef A_COLOR
a835 1
#endif /* A_COLOR */
a836 1
#ifdef A_COLOR
a837 1
#endif /* A_COLOR */
a983 1
#ifdef A_COLOR
a989 1
#endif /* A_COLOR */
a990 1
#ifdef A_COLOR
a991 1
#endif /* A_COLOR */
a1195 5
#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
@


1.29
log
@Cast toupper()'s argument to unsigned char.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.28 2015/09/27 05:27:42 guenther Exp $	*/
d1350 3
@


1.28
log
@Make prompt() properly printf-like, eliminating empty dummy args
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.27 2015/02/18 23:41:31 tedu Exp $	*/
d244 1
a244 1
	name[0] = toupper(name[0]);
@


1.27
log
@improve ship placement interface. per the instructions, 2468 should work,
but the first loop didn't allow them. also allow arrow keys to work, since
they work in other modes.
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.26 2014/11/16 04:49:48 guenther Exp $	*/
a298 2
/* VARARGS1 */
static void prompt(int n, char *f, char *s)
d300 4
d305 2
d309 3
a311 1
    (void) printw(f, s);
d509 1
a509 1
	    prompt(1, "Placing the rest of your fleet at random...", "");
d565 1
a565 1
    (void) prompt(0, "Press any key to start...", "");
d851 1
a851 1
    prompt(1, "Where do you want to shoot? ", "");
d857 1
a857 1
	    prompt(1, "You shelled this spot already! Try again.", "");
@


1.26
log
@Eliminate pointless use of <sys/param.h>, <sys/file.h>, <sys/sockio.h>,
    and <sys/ttydefaults.h>
Replace MAXPATHLEN with PATH_MAX and MAXLOGNAME with LOGIN_NAME_MAX
Pull in <limits.h> where needed
Prefer sizeof(var) over MAXFOO or FOO_MAX

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.25 2014/07/12 08:29:56 tedu Exp $	*/
d459 2
a460 1
	char c, docked[SHIPTYPES + 2], *cp = docked;
d488 4
a491 8

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
d494 2
a495 3
	}
	else if (c == 'r')
	{
d501 2
a502 3
	}
	else if (c == 'R')
	{
d512 5
a516 3
	}
	else if (strchr("hjkl8462", c))
	{
d522 4
a525 4
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
d534 3
@


1.25
log
@mlarkin found disabled code to print a battleship. improve it and enable.
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.24 2013/08/29 20:22:11 naddy Exp $	*/
a41 1
#include <sys/param.h>
d46 1
d118 1
a118 1
static char name[MAXLOGNAME];
@


1.24
log
@replace srandomdev()+random() with the arc4random*() family
tweaks and ok millert@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.23 2009/11/14 02:20:43 guenther Exp $	*/
a262 1
#ifdef PENGUIN
d271 5
a275 5
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
a279 1
#endif /* PENGUIN */
@


1.23
log
@Use getopt() to parse the argument list, shrinking the code and
permitting options to be grouped

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.22 2009/10/27 23:59:24 deraadt Exp $	*/
a41 2
/* #define _POSIX_SOURCE  */  /* ( random() ) */

a235 2
    srandomdev();	/* Kick the random number generator */

d343 1
a343 1
    return(((random() & 0x7FFF) % n));
@


1.22
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.21 2009/10/17 21:45:50 sobrado Exp $	*/
d1293 1
a1293 1
    int i;
d1295 14
a1308 5
    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
d1310 3
a1312 36
	    default:
	    case '?':
		(void) usage();
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = 1;
		    if (salvo == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 's':
		    salvo = 1;
		    if (blitz == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 'c':
		    closepack = 1;
		    break;
		case 'h':
		    (void) usage();
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s -h\" for usage message\n", op[0]);
		    exit(1);
		}
d1314 8
d1324 2
@


1.21
log
@sort flags; "usage:" is lowercase.
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.20 2003/06/11 08:47:44 pjanzen Exp $	*/
a40 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: bs.c,v 1.20 2003/06/11 08:47:44 pjanzen Exp $";
#endif
@


1.20
log
@Original author agreed to permit bs to be released under BSD license.
Many thanks to Nick Stott for his detective work on this.
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.19 2003/05/19 08:18:23 pjanzen Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: bs.c,v 1.19 2003/05/19 08:18:23 pjanzen Exp $";
d1287 1
a1287 1
	(void) fprintf(stderr, "Usage: bs [-s | -b] [-c]\n");
d1289 1
a1290 1
	(void) fprintf(stderr, "\t-b : play a blitz game\n");
@


1.19
log
@Remove #ifdef'ed out unnecessary defines.
@
text
@d1 30
a30 1
/*	$OpenBSD: bs.c,v 1.18 2002/12/06 21:48:51 millert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: bs.c,v 1.18 2002/12/06 21:48:51 millert Exp $";
@


1.18
log
@Replace things like srandom(time(NULL)) with srandomdev(3).  random(3)
good enough for games but we should at least use a decent seed.
pjanzen@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.17 2002/08/09 09:54:30 pjanzen Exp $	*/
d14 1
a14 1
static const char rcsid[] = "$OpenBSD: bs.c,v 1.17 2002/08/09 09:54:30 pjanzen Exp $";
a28 9

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */
@


1.17
log
@Only target in the playing field when using mouse.
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.16 2002/08/09 08:42:30 pjanzen Exp $	*/
d14 1
a14 1
static const char rcsid[] = "$OpenBSD: bs.c,v 1.16 2002/08/09 08:42:30 pjanzen Exp $";
d222 1
a222 1
    srandom((unsigned)(time(0L)+getpid()));	/* Kick the random number generator */
@


1.16
log
@Fix an error in the CPU random fire routine that could cause a segfault.
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.15 2002/08/09 08:36:33 pjanzen Exp $	*/
d14 1
a14 1
static const char rcsid[] = "$OpenBSD: bs.c,v 1.15 2002/08/09 08:36:33 pjanzen Exp $";
d637 2
a638 2
			&& myevent.y >= CY(0) && myevent.y <= CY(BDEPTH)
			&& myevent.x >= CX(0) && myevent.x <= CX(BDEPTH))
@


1.15
log
@Bug fix in random placement code from Erik Sigra.
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.14 2002/05/31 04:21:29 pjanzen Exp $	*/
d14 1
a14 1
static const char rcsid[] = "$OpenBSD$";
d980 1
@


1.14
log
@de-register
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.13 2002/05/31 03:40:00 pjanzen Exp $	*/
d14 1
a14 1
static char rcsid[] = "$OpenBSD: bs.c,v 1.13 2002/05/31 03:40:00 pjanzen Exp $";
a336 3
    int bwidth = BWIDTH - ss->length;
    int bdepth = BDEPTH - ss->length;

a337 2
	ss->y = rnd(bdepth);
	ss->x = rnd(bwidth);
d339 2
d1400 1
@


1.13
log
@No dm -> no need to revoke setegid.
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.12 2002/02/18 06:45:26 deraadt Exp $	*/
d14 1
a14 1
static char rcsid[] = "$OpenBSD: bs.c,v 1.12 2002/02/18 06:45:26 deraadt Exp $";
d337 2
a338 2
    register int bwidth = BWIDTH - ss->length;
    register int bdepth = BDEPTH - ss->length;
d1279 1
a1279 1
    register int i;
d1330 2
a1331 2
    register int i, shots;
    register ship_t *sp;
d1368 1
a1368 1
		    register int i;
@


1.12
log
@more signed char issues
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.11 2001/06/23 23:04:33 pjanzen Exp $	*/
d14 1
a14 1
static char rcsid[] = "$OpenBSD: bs.c,v 1.11 2001/06/23 23:04:33 pjanzen Exp $";
d17 1
a17 1
/* #define _POSIX_SOURCE  */  /* (setegid, random) */
a1349 4
    /* revoke privs */
    setegid(getgid());
    setgid(getgid());

@


1.11
log
@Make sure screen is big enough to play.
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.10 2001/02/17 23:00:05 pjanzen Exp $	*/
d14 1
a14 1
static char rcsid[] = "$OpenBSD: bs.c,v 1.10 2001/02/17 23:00:05 pjanzen Exp $";
d129 1
a129 1
    char x, y;		/* coordinates of ship start point */
@


1.10
log
@long usernames, and some -Wall-age
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.9 2000/09/08 02:23:11 pjanzen Exp $	*/
d14 1
a14 1
static char rcsid[] = "$OpenBSD: bs.c,v 1.9 2000/09/08 02:23:11 pjanzen Exp $";
d20 1
d22 2
a24 1
#include <ctype.h>
a25 2
#include <sys/types.h>
#include <unistd.h>
d28 1
d245 5
@


1.9
log
@bools should only be TRUE or FALSE.  Negative numbers are right out.
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.8 2000/07/23 22:23:42 pjanzen Exp $	*/
d14 1
a14 1
static char rcsid[] = "$OpenBSD: bs.c,v 1.8 2000/07/23 22:23:42 pjanzen Exp $";
d19 1
d103 1
a103 1
static char name[40];
d125 1
a125 1
    unsigned hits;	/* how many times has this ship been hit? */
d138 5
a142 5
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
d147 5
a151 5
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
d228 1
a228 1
    if ((tmpname = getlogin()) != 0)
d230 1
a230 1
	(void)strcpy(name,tmpname);
d234 1
a234 1
	(void)strcpy(name,dftname);
@


1.8
log
@Handle EOF on stdin.
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.7 1998/03/12 09:03:49 pjanzen Exp $	*/
d14 1
a14 1
static char rcsid[] = "$OpenBSD: bs.c,v 1.7 1998/03/12 09:03:49 pjanzen Exp $";
d48 1
a48 1
#define	OTHER		(1-turn)
d363 2
a364 1
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
d366 2
a367 1
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
d710 1
a710 1
	return(0);
d828 1
a828 1
    bool hit;
d847 1
a847 1
    if (has_colors())
d852 1
d988 1
a988 1
static bool cpufire(int x, int y)
d991 2
a992 1
    bool hit, sunk;
d1004 1
a1004 1
    if (has_colors())
d1009 1
d1024 1
a1024 1
static bool cputurn(void)
d1114 1
a1114 1
		    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
d1331 1
a1331 1
    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
@


1.7
log
@OpenBSD rscid and proper gid revoke (again)
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.6 1998/03/12 06:17:25 pjanzen Exp $	*/
d14 1
a14 1
static char rcsid[] = "$OpenBSD$";
d643 3
@


1.6
log
@Bugfixes and strategical improvements
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.5 1997/07/23 20:04:49 kstailey Exp $	*/
d12 6
a17 1
/* #define _POSIX_SOURCE  */  
d1336 2
a1337 2
    /*setegid(getgid());
    setgid(getgid());*/
@


1.5
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.4 1997/02/14 10:28:17 niklas Exp $	*/
d9 2
d12 1
a13 2
#include <assert.h>
#include <ctype.h>
d16 1
d18 2
d32 1
a32 12
#ifdef isxdigit		/* aha, must be an AT&T system... */
#define srand(n)	srand48(n)
#define rand()		lrand48()
#define bzero(s, n)	(void)memset((char *)(s), '\0', n)
/*
 * Try this if ungetch() fails to resolve.
 *
 * #define ungetch ungetc
 */
#endif /* isxdigit */

static bool checkplace();
d72 2
d123 1
a123 1
    char dir;		/* direction of `bow' */
d128 2
d148 20
d176 1
a176 3
#define	PR	(void)addstr

static void uninitgame(sig)
a177 1
int	sig;
d184 1
a184 1
    exit(0);
d187 1
a187 1
static void announceopts()
d211 1
a211 1
static void intro()
a212 1
    extern char *getlogin();
d215 1
a215 1
    srand(time(0L)+getpid());	/* Kick the random number generator */
a218 1
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
d222 1
a222 1
    if(tmpname = getlogin())
d240 1
d272 3
d278 1
a278 1
static void prompt(n, f, s)
a279 2
int n;
char *f, *s;
d287 1
a287 2
static void error(s)
char *s;
d298 1
a298 4
static void placeship(b, ss, vis)
int b;
ship_t *ss;
int vis;
d317 1
a317 2
static int rnd(n)
int n;
d319 1
a319 1
    return(((rand() & 0x7FFF) % n));
d322 1
a322 1
static void randomplace(b, ss)
a323 2
int b;
ship_t *ss;
d336 1
a336 1
static void initgame()
d346 9
a354 2
    bzero(board, sizeof(char) * BWIDTH * BDEPTH * 2);
    bzero(hits, sizeof(char) * BWIDTH * BDEPTH * 2);
d361 5
d373 1
a373 1
	(void) mvaddch(PYBASE + i, PXBASE - 3, i + 'A');
d385 1
a385 1
	(void) addch(i + 'A');
d392 1
a392 1
	(void) mvaddch(CYBASE + i, CXBASE - 3, i + 'A');
d404 1
a404 1
	(void) addch(i + 'A');
a437 2
	extern char *strchr();
	static char getcoord();
d487 1
a487 1
	    prompt(1, "Placing the rest of your fleet at random...");
d538 1
a538 1
    (void) prompt(0, "Press any key to start...");
d542 1
a542 2
static int getcoord(atcpu)
int atcpu;
d576 1
a576 1
	    ny = cury+1;	nx = curx;
d582 1
a582 1
	    ny = cury;		nx = curx+BWIDTH-1;
d588 1
a588 1
	    ny = cury;		nx = curx+1;
d600 1
a600 1
	    ny = cury+1;	nx = curx+BWIDTH-1;
d612 1
a612 1
	    ny = cury+1;	nx = curx+1;
d619 19
d651 1
a651 1
static int collidecheck(b, y, x)
a652 2
int b;
int y, x;
d657 1
a657 1
    if (collide = IS_SHIP(board[b][x][y]))
d678 1
a678 4
static bool checkplace(b, ss, vis)
int b;
ship_t *ss;
int vis;
d683 2
a684 2
    xend = ss->x + ss->length * xincr[ss->dir];
    yend = ss->y + ss->length * yincr[ss->dir];
d726 1
a726 1
static int awinna()
d743 1
a743 1
static ship_t *hitship(x, y)
a744 1
int x, y;
d771 1
a771 1
			    int x, y;
d773 3
a775 3
			    x = bx + i * xincr[ss->dir];
			    y = by + i * yincr[ss->dir];
			    if (ONBOARD(x, y))
d777 2
a778 2
				hits[turn][x][y] = MARK_MISS;
				if (turn % 2 == PLAYER)
d780 1
a780 1
				    cgoto(y, x);
d796 2
a797 2
		    int x = ss->x + i * xincr[ss->dir];
		    int y = ss->y + i * yincr[ss->dir];
d799 2
a800 2
		    hits[turn][x][y] = ss->symbol;
		    if (turn % 2 == PLAYER)
d802 2
a803 2
			cgoto(y, x);
			(void) addch(ss->symbol);
d815 1
a815 1
static int plyturn()
d819 1
a819 1
    char *m;
d821 1
a821 1
    prompt(1, "Where do you want to shoot? ");
d827 1
a827 1
	    prompt(1, "You shelled this spot already! Try again.");
d866 1
a866 1
	    m = " You'll pick up survivors from my my %s, I hope...!";
a870 1
	return(awinna() == -1);
d875 1
a875 2
static int sgetc(s)
char *s;
d887 1
a887 1
	    uninitgame();
d893 1
a893 1
	    (void)refresh();
d899 33
d933 1
a933 1
static void randomfire(px, py)
a934 1
int	*px, *py;
a935 2
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
a937 1
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
d943 2
a944 2
    /* first, list all possible moves */
    nposs = npref = 0;
d947 3
a949 1
	    if (!hits[COMPUTER][x][y])
d951 3
a953 8
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
d955 1
a955 10
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
a960 3

	if (srchstep > 1)
	    --srchstep;
d962 5
a966 1
    else
d968 2
a969 3
	error("No moves possible?? Help!");
	exit(1);
	/*NOTREACHED*/
d977 1
a977 1
static bool cpufire(x, y)
a978 1
int	x, y;
d981 1
a981 1
    ship_t *ss;
d986 1
a986 1
    if (sunk = (hit && (ss = hitship(x, y))))
d998 1
a998 1
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
d1011 1
a1011 1
static bool cputurn()
a1012 8
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
d1016 1
d1034 2
a1035 1
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
d1051 1
a1051 1
	    for (d = 0, n = rnd(navail) + 1; n; n--)
d1054 1
a1055 3
	    assert(d <= 4);

	    used[d] = FALSE;
a1058 2
	    assert(POSSIBLE(x, y));

d1072 1
a1072 1
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
d1074 8
a1081 2
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
d1085 1
a1085 1
	break;
d1088 4
a1091 11
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;
d1096 1
a1096 1
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
d1098 16
a1113 3
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
d1116 5
d1122 1
d1124 73
a1204 2
    if (awinna() != -1)
	return(FALSE);
d1214 2
a1215 1
playagain()
d1224 1
a1224 1
	    (void)addch((chtype)ss->symbol);
d1232 3
d1247 11
a1257 3
static void do_options(c,op)
int c;
char *op[];
d1269 1
a1269 6
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(1);
d1295 3
d1300 1
a1300 1
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
d1308 1
a1308 2
static int scount(who)
int who;
d1328 1
a1328 3
main(argc, argv)
int argc;
char *argv[];
d1331 2
a1332 2
    setegid(getgid());
    setgid(getgid());
d1350 1
a1350 1
		else
d1370 1
a1370 1
	    else
d1372 9
a1380 1
		    continue;
d1385 1
a1385 1
    uninitgame();
a1387 2

/* bs.c ends here */
@


1.4
log
@Use standard header files instead of declaring system funcs explicitly
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.3 1996/12/22 20:01:00 deraadt Exp $	*/
d560 1
a560 1
	    ny = cury+1;        nx = curx;
d566 1
a566 1
	    ny = cury;          nx = curx+BWIDTH-1;
d572 1
a572 1
	    ny = cury;          nx = curx+1;
d584 1
a584 1
	    ny = cury+1;        nx = curx+BWIDTH-1;
d596 1
a596 1
	    ny = cury+1;        nx = curx+1;
@


1.3
log
@proper gid revoke
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.2 1996/12/19 22:21:13 deraadt Exp $	*/
d11 2
d15 3
a17 2
#include <ctype.h>
#include <assert.h>
a30 2
extern long lrand48();
extern void srand48();
a31 1
extern char *memset();
a37 5

extern unsigned sleep();
extern char *strchr(), *strcpy();
extern long time();
extern void exit();
@


1.2
log
@setgid games, not setuid games. closes a neat set of holes
@
text
@d1 1
a1 1
/*	$OpenBSD: bs.c,v 1.1 1996/08/21 08:18:36 downsj Exp $	*/
d1206 2
@


1.1
log
@battleships, from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1206 2
@

