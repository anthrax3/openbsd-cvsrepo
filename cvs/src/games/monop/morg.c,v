head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.6.0.26
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.18
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.22
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.20
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.16
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.14
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.12
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.10
	OPENBSD_5_0:1.6.0.8
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.6
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.5.0.28
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.24
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.22
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.20
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.18
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.16
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.14
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.14
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.12
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.10
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.8
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.6
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.4
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2016.01.08.18.20.33;	author mestre;	state Exp;
branches;
next	1.7;
commitid	IlHJftt9IPFIQn9F;

1.7
date	2016.01.08.18.19.47;	author mestre;	state Exp;
branches;
next	1.6;
commitid	73TLYe3VSt6HwinY;

1.6
date	2009.10.27.23.59.26;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.03.03.01.40;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.07.28.08.44.14;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.16.21.27.11;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	98.09.20.23.36.54;	author pjanzen;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.09;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.8
log
@ANSIfy monop(6)

OK tb@@
@
text
@/*	$OpenBSD: morg.c,v 1.7 2016/01/08 18:19:47 mestre Exp $	*/
/*	$NetBSD: morg.c,v 1.4 1995/03/23 08:35:02 cgd Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <stdio.h>

#include "monop.ext"

/*
 *	These routines deal with mortgaging.
 */

static char	*names[MAX_PRP+2],
		*morg_coms[]	= {
			"quit",		/*  0 */
			"print",	/*  1 */
			"where",	/*  2 */
			"own holdings",	/*  3 */
			"holdings",	/*  4 */
			"mortgage",	/*  5 */
			"unmortgage",	/*  6 */
			"buy",		/*  7 */
			"sell",		/*  8 */
			"card",		/*  9 */
			"pay",		/* 10 */
			"trade",	/* 11 */
			"resign",	/* 12 */
			"save game",	/* 13 */
			"restore game",	/* 14 */
			0
		};

static shrt	square[MAX_PRP+2];

static int	num_good, got_houses;

static int	set_mlist(void);
static void	m(int);
static int	set_umlist(void);
static void	unm(int);

/*
 *	This routine is the command level response the mortgage command.
 * it gets the list of mortgageable property and asks which are to
 * be mortgaged.
 */
void
mortgage(void)
{
	int	prop;

	for (;;) {
		if (set_mlist() == 0) {
			if (got_houses)
				printf("You can't mortgage property with houses on it.\n");
			else
				printf("You don't have any un-mortgaged property.\n");
			return;
		}
		if (num_good == 1) {
			printf("Your only mortageable property is %s\n", names[0]);
			if (getyn("Do you want to mortgage it? ") == 0)
				m(square[0]);
			return;
		}
		prop = getinp("Which property do you want to mortgage? ", names);
		if (prop == num_good)
			return;
		m(square[prop]);
		notify();
	}
}
/*
 *	This routine sets up the list of mortgageable property
 */
static int
set_mlist(void)
{
	OWN	*op;

	num_good = 0;
	for (op = cur_p->own_list; op; op = op->next)
		if (!op->sqr->desc->morg) {
			if (op->sqr->type == PRPTY && op->sqr->desc->houses)
				got_houses++;
			else {
				names[num_good] = op->sqr->name;
				square[num_good++] = sqnum(op->sqr);
			}
		}
	names[num_good++] = "done";
	names[num_good--] = 0;
	return num_good;
}
/*
 *	This routine actually mortgages the property.
 */
static void
m(int prop)
{
	int	price;

	price = board[prop].cost/2;
	board[prop].desc->morg = TRUE;
	printf("That got you $%d\n",price);
	cur_p->money += price;
}
/*
 *	This routine is the command level repsponse to the unmortgage
 * command.  It gets the list of mortgaged property and asks which are
 * to be unmortgaged.
 */
void
unmortgage(void)
{
	int	prop;

	for (;;) {
		if (set_umlist() == 0) {
			printf("You don't have any mortgaged property.\n");
			return;
		}
		if (num_good == 1) {
			printf("Your only mortaged property is %s\n", names[0]);
			if (getyn("Do you want to unmortgage it? ") == 0)
				unm(square[0]);
			return;
		}
		prop = getinp("Which property do you want to unmortgage? ", names);
		if (prop == num_good)
			return;
		unm(square[prop]);
	}
}
/*
 *	This routine sets up the list of mortgaged property
 */
static int
set_umlist(void)
{
	OWN	*op;

	num_good = 0;
	for (op = cur_p->own_list; op; op = op->next)
		if (op->sqr->desc->morg) {
			names[num_good] = op->sqr->name;
			square[num_good++] = sqnum(op->sqr);
		}
	names[num_good++] = "done";
	names[num_good--] = 0;
	return num_good;
}
/*
 *	This routine actually unmortgages the property
 */
static void
unm(int prop)
{
	int	price;

	price = board[prop].cost/2;
	board[prop].desc->morg = FALSE;
	price += price/10;
	printf("That cost you $%d\n",price);
	cur_p->money -= price;
	set_umlist();
}
/*
 *	This routine forces the indebted player to fix his
 * financial woes.  It is fine to have $0 but not to be in debt.
 */
void
force_morg(void)
{
	told_em = fixing = TRUE;
	while (cur_p->money < 0) {
		told_em = FALSE;
		(*func[(getinp("How are you going to fix it up? ", morg_coms))])();
		notify();
	}
	fixing = FALSE;
}
@


1.7
log
@Headers cleanup and removal where suitable

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: morg.c,v 1.6 2009/10/27 23:59:26 deraadt Exp $	*/
d76 1
a76 1
mortgage()
d105 1
a105 1
set_mlist()
d127 1
a127 2
m(prop)
	int	prop;
d142 1
a142 1
unmortgage()
d167 1
a167 1
set_umlist()
d185 1
a185 2
unm(prop)
	int	prop;
d201 1
a201 1
force_morg()
@


1.6
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: morg.c,v 1.5 2003/06/03 03:01:40 millert Exp $	*/
d33 3
a35 1
# include	"monop.ext"
@


1.5
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: morg.c,v 1.4 2002/07/28 08:44:14 pjanzen Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)morg.c	8.1 (Berkeley) 5/31/93";
#else
static const char rcsid[] = "$OpenBSD: morg.c,v 1.4 2002/07/28 08:44:14 pjanzen Exp $";
#endif
#endif /* not lint */
@


1.4
log
@Tidy the code, follow the rules more closely (and document where we diverge),
and make save files work.  The last stops a number of segfaults.
@
text
@d1 1
a1 1
/*	$OpenBSD: morg.c,v 1.3 2002/02/16 21:27:11 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD$";
@


1.3
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: morg.c,v 1.2 1998/09/20 23:36:54 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: morg.c,v 1.2 1998/09/20 23:36:54 pjanzen Exp $";
d73 1
a73 1
static int	num_good,got_houses;
d210 1
a210 1
 * financial woes.
d216 1
a216 1
	while (cur_p->money <= 0) {
d218 1
a218 1
		(*func[(getinp("How are you going to fix it up? ",morg_coms))])();
@


1.2
log
@rand -> random; handle EOF; don't overflow on user input; check for calloc()
success; OpenBSD tags; some reformatting and ridding of unused variables.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD$";
d75 4
a78 4
static int	set_mlist __P((void));
static void	m __P((int));
static int	set_umlist __P((void));
static void	unm __P((int));
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: morg.c,v 1.4 1995/03/23 08:35:02 cgd Exp $";
d75 5
d85 4
a88 3
mortgage() {

	reg int	prop;
d99 1
a99 1
			printf("Your only mortageable property is %s\n",names[0]);
d104 1
a104 1
		prop = getinp("Which property do you want to mortgage? ",names);
d108 1
a108 1
		notify(cur_p);
d114 4
a117 3
set_mlist() {

	reg OWN	*op;
d121 1
a121 1
		if (!op->sqr->desc->morg)
d128 1
d136 1
d138 3
a140 3
reg int	prop; {

	reg int	price;
d152 4
a155 3
unmortgage() {

	reg int	prop;
d163 1
a163 1
			printf("Your only mortaged property is %s\n",names[0]);
d168 1
a168 1
		prop = getinp("Which property do you want to unmortgage? ",names);
d177 4
a180 3
set_umlist() {

	reg OWN	*op;
d195 1
d197 3
a199 3
reg int	prop; {

	reg int	price;
d212 3
a214 2
force_morg() {

d216 5
a220 2
	while (cur_p->money <= 0)
		fix_ex(getinp("How are you going to fix it up? ",morg_coms));
a221 10
}
/*
 *	This routine is a special execute for the force_morg routine
 */
fix_ex(com_num)
reg int	com_num; {

	told_em = FALSE;
	(*func[com_num])();
	notify();
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
