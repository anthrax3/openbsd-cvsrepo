head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.6
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.11.0.24
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.16
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.20
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.18
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.14
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.12
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.10
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.8
	OPENBSD_5_0:1.11.0.6
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.4
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.16
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.12
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.10
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.8
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.10
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.8
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.01.08.18.20.33;	author mestre;	state Exp;
branches;
next	1.13;
commitid	IlHJftt9IPFIQn9F;

1.13
date	2016.01.08.18.19.47;	author mestre;	state Exp;
branches;
next	1.12;
commitid	73TLYe3VSt6HwinY;

1.12
date	2015.10.24.17.44.49;	author mmcc;	state Exp;
branches;
next	1.11;
commitid	w4OHueWH26xCcgjo;

1.11
date	2010.05.10.08.53.12;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.27.23.59.26;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.27.00.10.15;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.16.19.26.44;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.11.21.13.11.15;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.03.03.01.40;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.28.08.44.14;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.17.00.27.21;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	98.09.20.23.36.51;	author pjanzen;	state Exp;
branches;
next	1.2;

1.2
date	97.04.01.16.00.57;	author rahnds;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.09;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.14
log
@ANSIfy monop(6)

OK tb@@
@
text
@/*	$OpenBSD: misc.c,v 1.13 2016/01/08 18:19:47 mestre Exp $	*/
/*	$NetBSD: misc.c,v 1.4 1995/03/23 08:34:47 cgd Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>

#include "monop.ext"

/*
 *	This routine executes a truncated set of commands until a
 * "yes or "no" answer is gotten.
 */
int
getyn(char *prompt)
{
	int	com;

	for (;;)
		if ((com=getinp(prompt, ynlist)) < 2)
			return com;
		else
			(*func[com-2])();
}
/*
 *	This routine tells the player if he's out of money.
 */
void
notify(void)
{
	if (cur_p->money < 0)
		printf("That leaves you $%d in debt\n", -cur_p->money);
	else if (cur_p->money == 0)
		printf("that leaves you broke\n");
	else if (fixing && !told_em && cur_p->money > 0) {
		printf("-- You are now Solvent ---\n");
		told_em = TRUE;
	}
}
/*
 *	This routine switches to the next player
 */
void
next_play(void)
{
	player = (player + 1) % num_play;
	cur_p = &play[player];
	num_doub = 0;
}
/*
 *	This routine gets an integer from the keyboard after the
 * given prompt.
 */
int
get_int(char *prompt)
{
	int	num, snum;
	char	*sp;
	int	c, i;
	char	buf[257];

	for (;;) {
		printf("%s", prompt);
		num = 0;
		i = 1;
		for (sp = buf; (c = getchar()) != '\n';) {
			if (c == EOF) {
				printf("user closed input stream, quitting...\n");
				exit(0);
			}
			*sp = c;
			if (i < (int)sizeof(buf)) {
				i++;
				sp++;
			}
		}
		*sp = c;
		if (sp == buf)
			continue;
		for (sp = buf; isspace((unsigned char)*sp); sp++)
			;
		for (; isdigit((unsigned char)*sp); sp++) {
			snum = num;
			num = num * 10 + *sp - '0';
			if (num < snum) {
				printf("Number too large - ");
				*(sp + 1) = 'X';	/* Force a break */
			}
		}
		/* Be kind to trailing spaces */
		for (; *sp == ' '; sp++)
			;
		if (*sp == '\n')
			return num;
		else
			printf("I can't understand that\n");
	}
}
/*
 *	This routine sets the monopoly flag from the list given.
 */
void
set_ownlist(int pl)
{
	int	num;		/* general counter		*/
	MON	*orig;		/* remember starting monop ptr	*/
	OWN	*op;		/* current owned prop		*/
	OWN	*orig_op;		/* origianl prop before loop	*/

	op = play[pl].own_list;
#ifdef DEBUG
	printf("op [%p] = play[pl [%d] ].own_list;\n", op, pl);
#endif
	while (op) {
#ifdef DEBUG
		printf("op->sqr->type = %d\n", op->sqr->type);
#endif
		switch (op->sqr->type) {
		  case UTIL:
#ifdef DEBUG
			printf("  case UTIL:\n");
#endif
			for (num = 0; op && op->sqr->type == UTIL; op = op->next)
				num++;
			play[pl].num_util = num;
#ifdef DEBUG
			printf("play[pl].num_util = num [%d];\n", num);
#endif
			break;
		  case RR:
#ifdef DEBUG
			printf("  case RR:\n");
#endif
			for (num = 0; op && op->sqr->type == RR; op = op->next) {
#ifdef DEBUG
				printf("iter: %d\n", num);
				printf("op = %p, op->sqr = %p, op->sqr->type = %d\n", op, op->sqr, op->sqr->type);
#endif
				num++;
			}
			play[pl].num_rr = num;
#ifdef DEBUG
			printf("play[pl].num_rr = num [%d];\n", num);
#endif
			break;
		  case PRPTY:
#ifdef DEBUG
			printf("  case PRPTY:\n");
#endif
			orig = op->sqr->desc->mon_desc;
			orig_op = op;
			num = 0;
			while (op && op->sqr->desc->mon_desc == orig) {
#ifdef DEBUG
				printf("iter: %d\n", num);
#endif
				num++;
#ifdef DEBUG
				printf("op = op->next ");
#endif
				op = op->next;
#ifdef DEBUG
				printf("[%p];\n", op);
#endif
			}
#ifdef DEBUG
			printf("num = %d\n", num);
#endif
			if (orig == NULL) {
				printf("panic:  bad monopoly descriptor: orig = %p\n", orig);
				printf("player # %d\n", pl+1);
				printhold(pl);
				printf("orig_op = %p\n", orig_op);
				if (orig_op) {
					printf("orig_op->sqr->type = %d (PRPTY)\n",
					    orig_op->sqr->type);
					printf("orig_op->next = %p\n",
					    orig_op->next);
					printf("orig_op->sqr->desc = %p\n",
					    orig_op->sqr->desc);
				}
				printf("op = %p\n", op);
				if (op) {
					printf("op->sqr->type = %d (PRPTY)\n",
					    op->sqr->type);
					printf("op->next = %p\n", op->next);
					printf("op->sqr->desc = %p\n",
					    op->sqr->desc);
				}
				printf("num = %d\n", num);
				exit(1);
			}
#ifdef DEBUG
			printf("orig->num_in = %d\n", orig->num_in);
#endif
			if (num == orig->num_in)
				is_monop(orig, pl);
			else
				isnot_monop(orig);
			break;
		}
	}
}
/*
 *	This routine sets things up as if it is a new monopoly
 */
void
is_monop(MON *mp, int pl)
{
	int	i;

	mp->owner = pl;
	mp->num_own = mp->num_in;
	for (i = 0; i < mp->num_in; i++)
		mp->sq[i]->desc->monop = TRUE;
	mp->name = mp->mon_n;
}
/*
 *	This routine sets things up as if it is no longer a monopoly
 */
void
isnot_monop(MON *mp)
{
	int	i;

	mp->owner = -1;
	for (i = 0; i < mp->num_in; i++)
		mp->sq[i]->desc->monop = FALSE;
	mp->name = mp->not_m;
}
/*
 *	This routine gives a list of the current player's routine
 */
void
list(void)
{
	printhold(player);
}
/*
 *	This routine gives a list of a given players holdings
 */
void
list_all(void)
{
	int	pl;

	while ((pl=getinp("Whose holdings do you want to see? ", name_list)) < num_play)
		printhold(pl);
}
/*
 *	This routine gives the players a chance before it exits.
 */
void
quit(void)
{
	putchar('\n');
	if (getyn("Do you all really want to quit? ") == 0)
		exit(0);
}
@


1.13
log
@Headers cleanup and removal where suitable

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.12 2015/10/24 17:44:49 mmcc Exp $	*/
d44 1
a44 2
getyn(prompt)
	char	*prompt;
d58 1
a58 1
notify()
d73 1
a73 1
next_play()
d84 1
a84 2
get_int(prompt)
	char	*prompt;
d132 1
a132 2
set_ownlist(pl)
	int	pl;
d237 1
a237 3
is_monop(mp, pl)
	MON	*mp;
	int	pl;
d251 1
a251 2
isnot_monop(mp)
	MON	*mp;
d264 1
a264 1
list()
d272 1
a272 1
list_all()
d283 1
a283 1
quit()
@


1.12
log
@Cast ctype functions' arguments to unsigned char.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.11 2010/05/10 08:53:12 nicm Exp $	*/
d33 5
a37 3
#include	"monop.ext"
#include	<ctype.h>
#include	<signal.h>
@


1.11
log
@Rename use of some builtins that makes gcc4 warn.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.10 2009/10/27 23:59:26 deraadt Exp $	*/
d109 1
a109 1
		for (sp = buf; isspace(*sp); sp++)
d111 1
a111 1
		for (; isdigit(*sp); sp++) {
@


1.10
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.9 2006/03/27 00:10:15 tedu Exp $	*/
d48 1
a48 1
		if ((com=getinp(prompt, yn)) < 2)
@


1.9
log
@assorted fixes mostly from coverity via netbsd via jasper adriaanse via tech
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.8 2003/12/16 19:26:44 deraadt Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)misc.c	8.1 (Berkeley) 5/31/93";
#else
static const char rcsid[] = "$OpenBSD: misc.c,v 1.8 2003/12/16 19:26:44 deraadt Exp $";
#endif
#endif /* not lint */
@


1.8
log
@bad printf; leopold-bloom@@foni.net
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.7 2003/11/21 13:11:15 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: misc.c,v 1.7 2003/11/21 13:11:15 otto Exp $";
d207 1
a207 1
			if (orig == 0) {
d212 8
a219 3
				printf("orig_op->sqr->type = %d (PRPTY)\n", op->sqr->type);
				printf("orig_op->next = %p\n", op->next);
				printf("orig_op->sqr->desc = %p\n", op->sqr->desc);
d221 7
a227 3
				printf("op->sqr->type = %d (PRPTY)\n", op->sqr->type);
				printf("op->next = %p\n", op->next);
				printf("op->sqr->desc = %p\n", op->sqr->desc);
d229 1
@


1.7
log
@printf(prompt) -> printf("%s", prompt)

From Alf Schlichting <leopold-bloom at foni dot net>
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.6 2003/06/03 03:01:40 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: misc.c,v 1.6 2003/06/03 03:01:40 millert Exp $";
d205 1
a205 1
			printf("num = %d\n");
@


1.6
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.5 2002/07/28 08:44:14 pjanzen Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: misc.c,v 1.5 2002/07/28 08:44:14 pjanzen Exp $";
d100 1
a100 1
		printf(prompt);
@


1.5
log
@Tidy the code, follow the rules more closely (and document where we diverge),
and make save files work.  The last stops a number of segfaults.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.4 2001/01/17 00:27:21 pjanzen Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD$";
@


1.4
log
@avoid C sequence point issues; found by cgd@@netbsd.org using a development
version of gcc.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.3 1998/09/20 23:36:51 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.3 1998/09/20 23:36:51 pjanzen Exp $";
d98 1
a98 1
	int	num;
d106 1
a106 1
		i = 0;
d113 1
a113 1
			if (i < sizeof(buf)) {
d122 3
a124 2
			continue;
		for (; isdigit(*sp); sp++)
d126 8
@


1.3
log
@rand -> random; handle EOF; don't overflow on user input; check for calloc()
success; OpenBSD tags; some reformatting and ridding of unused variables.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD$";
d86 1
a86 1
	player = ++player % num_play;
@


1.2
log
@Changes from NetBSD to compile games without warnings due to short being
unsigned on some archs, PowerPC, ROMP.
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: misc.c,v 1.4 1995/03/23 08:34:47 cgd Exp $";
d45 3
a47 3
# include	"monop.ext"
# include	<ctype.h>
# include	<signal.h>
d53 1
d55 3
a57 3
reg char	*prompt; {

	reg int	com;
d68 3
a70 2
notify() {

d83 3
a85 2
next_play() {

d94 1
d96 6
a101 6
reg char	*prompt; {

	reg int		num;
	reg char	*sp;
	int		c;
	char		buf[257];
a103 1
inter:
d106 12
a117 3
		for (sp = buf; (c = getchar()) != '\n'; *sp++ = c)
			if (c == -1)	/* check for interrupted system call */
				goto inter;
d134 1
d136 5
a140 5
int	pl; {

	reg int	num;		/* general counter		*/
	reg MON	*orig;		/* remember starting monop ptr	*/
	reg OWN	*op;		/* current owned prop		*/
d145 1
a145 1
	printf("op [%d] = play[pl [%d] ].own_list;\n", op, pl);
d170 1
a170 1
				printf("op = %d, op->sqr = %d, op->sqr->type = %d\n", op, op->sqr, op->sqr->type);
d196 1
a196 1
				printf("[%d];\n", op);
d203 1
a203 1
				printf("panic:  bad monopoly descriptor: orig = %d\n", orig);
d206 1
a206 1
				printf("orig_op = %d\n", orig_op);
d208 3
a210 3
				printf("orig_op->next = %d\n", op->next);
				printf("orig_op->sqr->desc = %d\n", op->sqr->desc);
				printf("op = %d\n", op);
d212 2
a213 2
				printf("op->next = %d\n", op->next);
				printf("op->sqr->desc = %d\n", op->sqr->desc);
d230 1
d232 4
a235 5
reg MON	*mp;
int	pl; {

	reg char	*sp;
	reg int		i;
d246 1
d248 3
a250 4
reg MON	*mp; {

	reg char	*sp;
	reg int		i;
d260 3
a262 2
list() {

d268 4
a271 3
list_all() {

	reg int	pl;
d280 2
a281 2
quit() {

d283 1
a283 1
	if (getyn("Do you all really want to quit? ", yn) == 0)
a284 11
	signal(SIGINT, quit);
}
/*
 *	This routine copies one structure to another
 */
cpy_st(s1, s2, size)
reg int	*s1, *s2, size; {

	size /= 2;
	while (size--)
		*s1++ = *s2++;
@


1.1
log
@Initial revision
@
text
@d95 1
d102 2
a103 2
		for (sp = buf; (*sp=getchar()) != '\n'; sp++)
			if (*sp == -1)	/* check for interrupted system call */
d105 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
