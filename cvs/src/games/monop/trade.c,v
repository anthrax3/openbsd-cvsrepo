head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.10
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.8
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.6.0.26
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.18
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.22
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.20
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.16
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.14
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.12
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.10
	OPENBSD_5_0:1.6.0.8
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.6
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.5.0.28
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.24
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.22
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.20
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.18
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.16
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.14
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.14
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.12
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.10
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.8
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.6
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.4
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2016.01.08.18.20.33;	author mestre;	state Exp;
branches;
next	1.7;
commitid	IlHJftt9IPFIQn9F;

1.7
date	2016.01.08.18.19.47;	author mestre;	state Exp;
branches;
next	1.6;
commitid	73TLYe3VSt6HwinY;

1.6
date	2009.10.27.23.59.26;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.03.03.01.40;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.07.28.08.44.14;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.16.21.27.11;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	98.09.20.23.36.56;	author pjanzen;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.09;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.8
log
@ANSIfy monop(6)

OK tb@@
@
text
@/*	$OpenBSD: trade.c,v 1.7 2016/01/08 18:19:47 mestre Exp $	*/
/*	$NetBSD: trade.c,v 1.3 1995/03/23 08:35:19 cgd Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <stdio.h>
#include <stdlib.h>

#include "monop.ext"

struct trd_st {			/* how much to give to other player	*/
	int	trader;			/* trader number		*/
	int	cash;			/* amount of cash 		*/
	int	gojf;			/* # get-out-of-jail-free cards	*/
	OWN	*prop_list;		/* property list		*/
};

typedef	struct trd_st	TRADE;

static char	*plist[MAX_PRP+2];

static int	used[MAX_PRP];

static TRADE	trades[2];

static void	get_list(int, int );
static int	set_list(OWN *);
static void	summate(void);
static void	do_trade(void);
static void	move_em(TRADE *, TRADE *);

void
trade(void)
{
	int	tradee, i;

	trading = TRUE;
	for (i = 0; i < 2; i++) {
		trades[i].cash = 0;
		trades[i].gojf = FALSE;
		trades[i].prop_list = NULL;
	}
over:
	if (num_play == 1) {
		printf("There ain't no-one around to trade WITH!!\n");
		return;
	}
	if (num_play > 2) {
		tradee = getinp("Which player do you wish to trade with? ",
		    name_list);
		if (tradee == num_play)
			return;
		if (tradee == player) {
			printf("You can't trade with yourself!\n");
			goto over;
		}
	}
	else
		tradee = 1 - player;
	get_list(0, player);
	get_list(1, tradee);
	if (getyn("Do you wish a summary? ") == 0)
		summate();
	if (getyn("Is the trade ok? ") == 0)
		do_trade();
}
/*
 *	This routine gets the list of things to be trader for the
 * player, and puts in the structure given.
 */
static void
get_list(int struct_no, int play_no)
{
	int	sn, pn;
	PLAY	*pp;
	int	numin, prop, num_prp;
	OWN	*op;
	TRADE	*tp;

	for (numin = 0; numin < MAX_PRP; numin++)
		used[numin] = FALSE;
	sn = struct_no, pn = play_no;
	pp = &play[pn];
	tp = &trades[sn];
	tp->trader = pn;
	printf("player %s (%d):\n", pp->name, pn+1);
	if (pp->own_list) {
		numin = set_list(pp->own_list);
		for (num_prp = numin; num_prp; ) {
			prop = getinp("Which property do you wish to trade? ",
			    plist);
			if (prop == numin)
				break;
			else if (used[prop])
				printf("You've already allocated that.\n");
			else {
				num_prp--;
				used[prop] = TRUE;
				for (op = pp->own_list; prop--; op = op->next)
					continue;
				add_list(pn, &(tp->prop_list), sqnum(op->sqr));
			}
		}
	}
	if (pp->money > 0) {
		printf("You have $%d.  ", pp->money);
		tp->cash = get_int("How much are you trading? ");
	}
	if (pp->num_gojf > 0) {
once_more:
		printf("You have %d get-out-of-jail-free cards. ",pp->num_gojf);
		tp->gojf = get_int("How many are you trading? ");
		if (tp->gojf > pp->num_gojf) {
			printf("You don't have that many.  Try again.\n");
			goto once_more;
		}
	}
}
/*
 *	This routine sets up the list of tradable property.
 */
static int
set_list(OWN *the_list)
{
	int	i;
	OWN	*op;

	i = 0;
	for (op = the_list; op; op = op->next)
		if (!used[i])
			plist[i++] = op->sqr->name;
	plist[i++] = "done";
	plist[i--] = 0;
	return i;
}
/*
 *	This routine summates the trade.
 */
static void
summate(void)
{
	bool	some;
	int	i;
	TRADE	*tp;
	OWN	*op;

	for (i = 0; i < 2; i++) {
		tp = &trades[i];
		some = FALSE;
		printf("Player %s (%d) gives:\n", play[tp->trader].name,
			tp->trader+1);
		if (tp->cash > 0)
			printf("\t$%d\n", tp->cash), some++;
		if (tp->gojf > 0)
			printf("\t%d get-out-of-jail-free card(s)\n", tp->gojf),
			some++;
		if (tp->prop_list) {
			for (op = tp->prop_list; op; op = op->next)
				putchar('\t'), printsq(sqnum(op->sqr), TRUE);
			some++;
		}
		if (!some)
			printf("\t-- Nothing --\n");
	}
}
/*
 *	This routine actually executes the trade.
 */
static void
do_trade(void)
{
	move_em(&trades[0], &trades[1]);
	move_em(&trades[1], &trades[0]);
}
/*
 *	This routine does a switch from one player to another
 */
static void
move_em(TRADE *from, TRADE *to)
{
	PLAY	*pl_fr, *pl_to;
	OWN	*op;

	pl_fr = &play[from->trader];
	pl_to = &play[to->trader];

	pl_fr->money -= from->cash;
	pl_to->money += from->cash;
	pl_fr->num_gojf -= from->gojf;
	pl_to->num_gojf += from->gojf;
	for (op = from->prop_list; op; op = op->next) {
		add_list(to->trader, &(pl_to->own_list), sqnum(op->sqr));
		op->sqr->owner = to->trader;
		del_list(from->trader, &(pl_fr->own_list), sqnum(op->sqr));
	}
	set_ownlist(to->trader);
}
/*
 *	This routine lets a player resign
 */
void
resign(void)
{
	int	i, new_own;
	OWN	*op;
	SQUARE	*sqp;

	if (cur_p->money <= 0) {
		switch (board[(int)cur_p->loc].type) {
		  case UTIL:
		  case RR:
		  case PRPTY:
			new_own = board[(int)cur_p->loc].owner;
			/* If you ran out of money by buying current location */
			if (new_own == player)
				new_own = num_play;
			break;
		  default:		/* Chance, taxes, etc */
			new_own = num_play;
			break;
		}
		if (new_own == num_play)
			printf("You would resign to the bank\n");
		else
			printf("You would resign to %s\n", name_list[new_own]);
	}
	else if (num_play == 1) {
		new_own = num_play;
		printf("You would resign to the bank\n");
	}
	else {
		name_list[num_play] = "bank";
		do {
			new_own = getinp("Who do you wish to resign to? ",
			    name_list);
			if (new_own == player)
				printf("You can't resign to yourself!!\n");
		} while (new_own == player);
		name_list[num_play] = "done";
	}
	if (getyn("Do you really want to resign? ") != 0)
		return;
	if (num_play == 1) {
		printf("Then NOBODY wins (not even YOU!)\n");
		exit(0);
	}
	if (new_own < num_play) {	/* resign to player		*/
		printf("resigning to player\n");
		trades[0].trader = new_own;
		trades[0].cash = trades[0].gojf = 0;
		trades[0].prop_list = NULL;
		trades[1].trader = player;
		trades[1].cash = cur_p->money > 0 ? cur_p->money : 0;
		trades[1].gojf = cur_p->num_gojf;
		trades[1].prop_list = cur_p->own_list;
		do_trade();
	}
	else {				/* resign to bank		*/
		printf("resigning to bank\n");
		for (op = cur_p->own_list; op; op = op->next) {
			sqp = op->sqr;
			sqp->owner = -1;
			sqp->desc->morg = FALSE;
			if (sqp->type == PRPTY) {
				isnot_monop(sqp->desc->mon_desc);
				sqp->desc->houses = 0;
			}
		}
		if (cur_p->num_gojf)
			ret_card(cur_p);
	}
	free(name_list[player]);
	for (i = player; i < num_play; i++) {
		name_list[i] = name_list[i+1];
		if (i + 1 < num_play)
			play[i] = play[i+1];
	}
	name_list[num_play--] = NULL;
	for (i = 0; i < N_SQRS; i++)
		if (board[i].owner > player)
			--board[i].owner;
	if (player == 0)
		player = num_play - 1;
	else
		player--;
	next_play();
	if (num_play < 2) {
		printf("\nThen %s WINS!!!!!\n", play[0].name);
		printhold(0);
		printf("That's a grand worth of $%d.\n",
			play[0].money+prop_worth(&play[0]));
		exit(0);
	}
}
@


1.7
log
@Headers cleanup and removal where suitable

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trade.c,v 1.6 2009/10/27 23:59:26 deraadt Exp $	*/
d60 1
a60 1
trade()
d99 1
a99 2
get_list(struct_no, play_no)
	int	struct_no, play_no;
d150 1
a150 2
set_list(the_list)
	OWN	*the_list;
d167 1
a167 1
summate()
d197 1
a197 1
do_trade()
d206 1
a206 2
move_em(from, to)
	TRADE	*from, *to;
d229 1
a229 1
resign()
@


1.6
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: trade.c,v 1.5 2003/06/03 03:01:40 millert Exp $	*/
d33 4
a36 1
#include	"monop.ext"
@


1.5
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: trade.c,v 1.4 2002/07/28 08:44:14 pjanzen Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)trade.c	8.1 (Berkeley) 5/31/93";
#else
static const char rcsid[] = "$OpenBSD: trade.c,v 1.4 2002/07/28 08:44:14 pjanzen Exp $";
#endif
#endif /* not lint */
@


1.4
log
@Tidy the code, follow the rules more closely (and document where we diverge),
and make save files work.  The last stops a number of segfaults.
@
text
@d1 1
a1 1
/*	$OpenBSD: trade.c,v 1.3 2002/02/16 21:27:11 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD$";
@


1.3
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: trade.c,v 1.2 1998/09/20 23:36:56 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: trade.c,v 1.2 1998/09/20 23:36:56 pjanzen Exp $";
d248 1
a248 1
		switch (board[cur_p->loc].type) {
d252 4
a255 1
			new_own = board[cur_p->loc].owner;
d311 1
d317 1
a317 1
	name_list[num_play--] = 0;
d321 4
a324 1
	player = --player < 0 ? num_play - 1 : player;
@


1.2
log
@rand -> random; handle EOF; don't overflow on user input; check for calloc()
success; OpenBSD tags; some reformatting and ridding of unused variables.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD$";
d62 5
a66 5
static void	get_list __P((int, int ));
static int	set_list __P((OWN *));
static void	summate __P((void));
static void	do_trade __P((void));
static void	move_em __P((TRADE *, TRADE *));
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: trade.c,v 1.3 1995/03/23 08:35:19 cgd Exp $";
d45 1
a45 1
# include	"monop.ext"
d56 1
a56 1
static char	*list[MAX_PRP+2];
d62 10
a71 3
trade() {

	reg int	tradee, i;
d107 1
d109 7
a115 7
int	struct_no, play_no; {

	reg int		sn, pn;
	reg PLAY	*pp;
	int		numin, prop, num_prp;
	OWN		*op;
	TRADE		*tp;
d128 1
a128 1
			    list);
d159 1
d161 4
a164 4
reg OWN	*the_list; {

	reg int	i;
	reg OWN	*op;
d169 3
a171 3
			list[i++] = op->sqr->name;
	list[i++] = "done";
	list[i--] = 0;
d177 6
a182 5
summate() {

	reg bool	some;
	reg int		i;
	reg TRADE	*tp;
d207 3
a209 2
do_trade() {

d216 1
d218 4
a221 4
TRADE	*from, *to; {

	reg PLAY	*pl_fr, *pl_to;
	reg OWN		*op;
d240 5
a244 4
resign() {

	reg int	i, new_own;
	reg OWN	*op;
d277 1
a277 1
	if (getyn("Do you really want to resign? ", yn) != 0)
d311 1
a311 1
			cpy_st(&play[i], &play[i+1], sizeof (PLAY));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
