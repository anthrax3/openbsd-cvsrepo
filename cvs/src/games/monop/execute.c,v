head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.6
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.22
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.20
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.16
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.14
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.12
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.10
	OPENBSD_5_0:1.9.0.8
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.28
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.24
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.22
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.20
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.18
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.16
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.14
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.6
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.09.11.14.21.18;	author tb;	state Exp;
branches;
next	1.13;
commitid	vQliJ9M8LCn9g8k6;

1.13
date	2016.01.08.18.20.33;	author mestre;	state Exp;
branches;
next	1.12;
commitid	IlHJftt9IPFIQn9F;

1.12
date	2016.01.08.18.19.47;	author mestre;	state Exp;
branches;
next	1.11;
commitid	73TLYe3VSt6HwinY;

1.11
date	2015.08.22.14.47.41;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	vWCbqNWL9DL2UkGT;

1.10
date	2014.12.08.21.11.02;	author tedu;	state Exp;
branches;
next	1.9;
commitid	29EfK2OXVbH3I5SA;

1.9
date	2009.10.27.23.59.26;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.03.03.01.40;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.06.18.50.37;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.28.08.44.14;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.27.10;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.30.16.00.04;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	98.11.29.19.45.11;	author pjanzen;	state Exp;
branches
	1.3.6.1;
next	1.2;

1.2
date	98.09.20.23.36.50;	author pjanzen;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.08;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.08;	author deraadt;	state Exp;
branches;
next	;

1.3.6.1
date	2000.10.06.20.40.25;	author jason;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Callers of time(3) should #include <time.h>.

ok deraadt
@
text
@/*	$OpenBSD: execute.c,v 1.13 2016/01/08 18:20:33 mestre Exp $	*/
/*	$NetBSD: execute.c,v 1.3 1995/03/23 08:34:38 cgd Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>

#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "monop.ext"

typedef	struct stat	STAT;
typedef	struct tm	TIME;

static char	buf[257];

static bool	new_play;	/* set if move on to new player		*/

static void	show_move(void);

/*
 *	This routine takes user input and puts it in buf
 */
void
getbuf(void)
{
	char	*sp;
	int	tmpin, i;

	i = 1;
	sp = buf;
	while (((tmpin = getchar()) != '\n') && (i < (int)sizeof(buf)) &&
	    (tmpin != EOF)) {
		*sp++ = tmpin;
		i++;
	}
	if (tmpin == EOF) {
		printf("user closed input stream, quitting...\n");
                exit(0);
	}
	*sp = '\0';
}
/*
 *	This routine executes the given command by index number
 */
void
execute(int com_num)
{
	new_play = FALSE;	/* new_play is true if fixing	*/
	(*func[com_num])();
	notify();
	force_morg();
	if (new_play)
		next_play();
	else if (num_doub)
		printf("%s rolled doubles.  Goes again\n", cur_p->name);
}
/*
 *	This routine moves a piece around.
 */
void
do_move(void)
{
	int	r1, r2;
	bool	was_jail;

	new_play = was_jail = FALSE;
	printf("roll is %d, %d\n", r1 = roll(1, 6), r2 = roll(1, 6));
	if (cur_p->loc == JAIL) {
		was_jail++;
		if (!move_jail(r1, r2)) {
			new_play++;
			goto ret;
		}
	}
	else {
		if (r1 == r2 && ++num_doub == 3) {
			printf("That's 3 doubles.  You go to jail\n");
			goto_jail();
			new_play++;
			goto ret;
		}
		move(r1 + r2);
	}
	if (r1 != r2 || was_jail)
		new_play++;
ret:
	return;
}
/*
 *	This routine moves a normal move
 */
void
move(int rl)
{
	int	old_loc;

	old_loc = cur_p->loc;
	cur_p->loc = (cur_p->loc + rl) % N_SQRS;
	if (cur_p->loc < old_loc && rl > 0) {
		cur_p->money += 200;
		printf("You pass %s and get $200\n", board[0].name);
	}
	show_move();
}
/*
 *	This routine shows the results of a move
 */
static void
show_move(void)
{
	SQUARE	*sqp;

	sqp = &board[(int)cur_p->loc];
	printf("That puts you on %s\n", sqp->name);
	switch (sqp->type) {
	case SAFE:
		printf("That is a safe place\n");
		break;
	case CC:
		cc();
		break;
	case CHANCE:
		chance();
		break;
	case INC_TAX:
		inc_tax();
		break;
	case GOTO_J:
		goto_jail();
		break;
	case LUX_TAX:
		lux_tax();
		break;
	case PRPTY:
	case RR:
	case UTIL:
		if (sqp->owner < 0) {
			printf("That would cost $%d\n", sqp->cost);
			if (getyn("Do you want to buy? ") == 0) {
				buy(player, sqp);
				cur_p->money -= sqp->cost;
			}
			else if (num_play > 2)
				bid();
		}
		else if (sqp->owner == player)
			printf("You own it.\n");
		else
			rent(sqp);
	}
}


#define MONOP_TAG "monop(6) save file"
/*
 *	This routine saves the current game for use at a later date
 */
void
save(void)
{
	int i, j;
	time_t t;
	struct stat sb;
	char *sp;
	FILE *outf;

	printf("Which file do you wish to save it in? ");
	getbuf();

	/*
	 * check for existing files, and confirm overwrite if needed
	 */
	if (stat(buf, &sb) == 0
	    && getyn("File exists.  Do you wish to overwrite? ") > 0)
		return;

	umask(022);
	if ((outf = fopen(buf, "w")) == NULL) {
		warn("%s", buf);
		return;
	}
	printf("\"%s\" ", buf);
	time(&t);			/* get current time		*/
	fprintf(outf, "%s\n", MONOP_TAG);
	fprintf(outf, "# %s", ctime(&t));	/* ctime() has \n */
	fprintf(outf, "%d %d %d\n", num_play, player, num_doub);
	for (i = 0; i < num_play; i++)
		fprintf(outf, "%s\n", name_list[i]);
	for (i = 0; i < num_play; i++)
		fprintf(outf, "%d %d %d %d\n", play[i].money, play[i].loc,
		    play[i].num_gojf, play[i].in_jail);
	/* Deck status */
	for (i = 0; i < 2; i++) {
		fprintf(outf, "%d %d %d\n", (int)(deck[i].num_cards),
		    (int)(deck[i].top_card), (int)(deck[i].gojf_used));
		for (j = 0; j < deck[i].num_cards; j++)
			fprintf(outf, "%ld ", (long)(deck[i].offsets[j]));
		fprintf(outf, "\n");
	}
	/* Ownership */
	for (i = 0; i < N_SQRS; i++) {
		if (board[i].owner >= 0) {
			if (board[i].type == PRPTY)
				fprintf(outf, "%d %d %d %d\n", i, board[i].owner,
				    board[i].desc->morg, board[i].desc->houses);
			else if (board[i].type == RR || board[i].type == UTIL)
				fprintf(outf, "%d %d %d 0\n", i, board[i].owner,
				    board[i].desc->morg);
		}
	}
	fclose(outf);

	strlcpy(buf, ctime(&t), sizeof buf);
	for (sp = buf; *sp != '\n'; sp++)
		continue;
	*sp = '\0';
	printf("[%s]\n", buf);
}
/* 
 * If we are restoring during a game, try not to leak memory.
 */
void
game_restore(void)
{
	int i;

	free(play);
	for (i = 0; i < num_play; i++)
		free(name_list[i]);
	restore();
}
/*
 *	This routine restores an old game from a file
 */
void
restore(void)
{
	printf("Which file do you wish to restore from? ");
	getbuf();
	if (rest_f(buf) == FALSE) {
		printf("Restore failed\n");
		exit(1);
	}
}
/*
 *	This does the actual restoring.  It returns TRUE if the
 *	backup was successful, else FALSE.
 */
int
rest_f(char *file)
{
	char *sp;
	int  i, j, num;
	FILE *inf;
	char *st, *a, *b;
	size_t len;
	STAT sbuf;
	int  t1;
	short t2, t3, t4;
	long tl;

	printf("\"%s\" ", file);
	if (stat(file, &sbuf) < 0) {		/* get file stats	*/
		warn("%s", file);
		return(FALSE);
	}
	if ((inf = fopen(file, "r")) == NULL) {
		warn("%s", file);
		return(FALSE);
	}

	num = 1;
	st = fgetln(inf, &len);
	if (st == NULL || len != strlen(MONOP_TAG) + 1 ||
	    strncmp(st, MONOP_TAG, strlen(MONOP_TAG))) {
badness:
		warnx("%s line %d", file, num);
		fclose(inf);
		return(FALSE);
	}
	num++;
	if (fgetln(inf, &len) == NULL)
		goto badness;
	num++;
	if ((st = fgetln(inf, &len)) == NULL || st[len - 1] != '\n')
		goto badness;
	st[len - 1] = '\0';
	if (sscanf(st, "%d %d %d", &num_play, &player, &num_doub) != 3 ||
	    num_play > MAX_PL || num_play < 1 ||
	    player < 0 || player >= num_play ||
	    num_doub < 0 || num_doub > 2)
		goto badness;
	if ((play = calloc(num_play, sizeof(PLAY))) == NULL)
		err(1, NULL);
	cur_p = play + player;
	/* Names */
	for (i = 0; i < num_play; i++) {
		num++;
		if ((st = fgetln(inf, &len)) == NULL || st[len - 1] != '\n')
			goto badness;
		st[len - 1] = '\0';
		if ((name_list[i] = play[i].name = strdup(st)) == NULL)
			err(1, NULL);
	}
	if ((name_list[i++] = strdup("done")) == NULL)
		err(1, NULL);
	name_list[i] = NULL;
	/* Money, location, GOJF cards, turns in jail */
	for (i = 0; i < num_play; i++) {
		num++;
		if ((st = fgetln(inf, &len)) == NULL || st[len - 1] != '\n')
			goto badness;
		st[len - 1] = '\0';
		if (sscanf(st, "%d %hd %hd %hd", &(play[i].money), &t2,
		    &t3, &t4) != 4 ||
		    t2 < 0 || t2 > N_SQRS || t3 < 0 || t3 > 2 ||
		    (t2 != JAIL && t4 != 0) || t4 < 0 || t4 > 3)
			goto badness;
		play[i].loc = t2;
		play[i].num_gojf = t3;
		play[i].in_jail  = t4;
	}
	/* Deck status; init_decks() must have been called. */
	for (i = 0; i < 2; i++) {
		num++;
		if ((st = fgetln(inf, &len)) == NULL || st[len - 1] != '\n')
			goto badness;
		st[len - 1] = '\0';
		if (sscanf(st, "%d %d %hd", &t1, &j, &t2) != 3 ||
		    j > t1 || t1 != deck[i].num_cards || j < 0 ||
		    (t2 != FALSE && t2 != TRUE))
			goto badness;
		deck[i].top_card = j;
		deck[i].gojf_used = t2;
		num++;
		if ((st = fgetln(inf, &len)) == NULL || st[len - 1] != '\n')
			goto badness;
		st[len - 1] = '\0';
		a = st;
		for (j = 0; j < deck[i].num_cards; j++) {
			if ((tl = strtol(a, &b, 10)) < 0 || tl >= 0x7FFFFFFF ||
			    b == a)
			    goto badness;
			deck[i].offsets[j] = tl;
			b = a;
		}
		/* Ignore anything trailing */
	}
	trading = FALSE;
	while ((st = fgetln(inf, &len)) != NULL) {
		num++;
		if (st[len - 1] != '\n')
			goto badness;
		st[len - 1] = '\0';
		/* Location, owner, mortgaged, nhouses */
		if (sscanf(st, "%d %hd %hd %hd", &t1, &t2, &t3, &t4) != 4 ||
		    t1 < 0 || t1 >= N_SQRS || (board[t1].type != PRPTY &&
		    board[t1].type != RR && board[t1].type != UTIL) ||
		    t2 < 0 || t2 >= num_play ||
		    (t3 != TRUE && t3 != FALSE) ||
		    t4 < 0 || t4 > 5 || (t4 > 0 && t3 == TRUE))
			goto badness;
		add_list(t2, &(play[t2].own_list), t1);
		/* No properties on mortgaged lots */
		if (t3 && t4)
			goto badness;
		board[t1].owner = t2;
		(board[t1].desc)->morg = t3;
		(board[t1].desc)->houses = t4;
		/* XXX Should check that number of houses per property are all
		 * within 1 in each monopoly
		 */
	}
	fclose(inf);
	/* Check total hotel and house count */
	t1 = j = 0;
	for (i = 0; i < N_SQRS; i++) {
		if (board[i].type == PRPTY) {
			if ((board[i].desc)->houses == 5)
				j++;
			else
				t1 += (board[i].desc)->houses;
		}
	}
	if (t1 > N_HOUSE || j > N_HOTEL) {
		warnx("too many buildings");
		return(FALSE);
	}
	/* Check GOJF cards */
	t1 = 0;
	for (i = 0; i < num_play; i++)
		t1 += play[i].num_gojf;
	for (i = 0; i < 2; i++)
		t1 -= (deck[i].gojf_used == TRUE);
	if (t1 != 0) {
		warnx("can't figure out the Get-out-of-jail-free cards");
		return(FALSE);
	}

	strlcpy(buf, ctime(&sbuf.st_mtime), sizeof buf);
	for (sp = buf; *sp != '\n'; sp++)
		continue;
	*sp = '\0';
	printf("[%s]\n", buf);
	return(TRUE);
}
@


1.13
log
@ANSIfy monop(6)

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.12 2016/01/08 18:19:47 mestre Exp $	*/
d39 1
@


1.12
log
@Headers cleanup and removal where suitable

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.11 2015/08/22 14:47:41 deraadt Exp $	*/
d55 1
a55 1
getbuf()
d77 1
a77 2
execute(com_num)
	int	com_num;
d92 1
a92 1
do_move()
d124 1
a124 2
move(rl)
	int	rl;
d140 1
a140 1
show_move()
d190 1
a190 1
save()
d254 1
a254 1
game_restore()
d267 1
a267 1
restore()
d281 1
a281 2
rest_f(file)
	char	*file;
@


1.11
log
@remove malloc/calloc/realloc* casts, due to stdlib.h being present; ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.10 2014/12/08 21:11:02 tedu Exp $	*/
d33 8
a40 8
#include	"monop.ext"
#include	<sys/types.h>
#include	<sys/stat.h>
#include	<sys/time.h>
#include	<err.h>
#include 	<fcntl.h>
#include	<stdlib.h>
#include	<unistd.h>
@


1.10
log
@okan noticed this was actually calling the cfree turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.9 2009/10/27 23:59:26 deraadt Exp $	*/
d327 1
a327 1
	if ((play = (PLAY *)calloc(num_play, sizeof(PLAY))) == NULL)
@


1.9
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.8 2003/06/03 03:01:40 millert Exp $	*/
d260 1
a260 1
	cfree(play);
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.7 2003/04/06 18:50:37 deraadt Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)execute.c	8.1 (Berkeley) 5/31/93";
#else
static const char rcsid[] = "$OpenBSD: execute.c,v 1.7 2003/04/06 18:50:37 deraadt Exp $";
#endif
#endif /* not lint */
@


1.7
log
@2451 lines of strdup/sprintf/strcpy whacking.  mostly ok'd by pjanzen
already, but he may have later changes to make still.
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.6 2002/07/28 08:44:14 pjanzen Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: execute.c,v 1.6 2002/07/28 08:44:14 pjanzen Exp $";
@


1.6
log
@Tidy the code, follow the rules more closely (and document where we diverge),
and make save files work.  The last stops a number of segfaults.
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.5 2002/02/16 21:27:10 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD$";
d258 1
a258 1
	strcpy(buf, ctime(&t));
d446 1
a446 1
	strcpy(buf, ctime(&sbuf.st_mtime));
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.4 2000/06/30 16:00:04 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: execute.c,v 1.4 2000/06/30 16:00:04 millert Exp $";
a53 2
#define	SEGSIZE	8192

d72 1
a72 1
	i = 0;
d74 1
a74 1
	while (((tmpin = getchar()) != '\n') && (i < sizeof(buf)) &&
d158 1
a158 1
	sqp = &board[cur_p->loc];
d197 3
d206 5
a210 5
	char		*sp;
	int		outf, num;
	time_t		t;
	struct stat	sb;
	char		*start, *end;
a217 1

d222 2
a223 1
	if ((outf=creat(buf, 0644)) < 0) {
d229 29
a261 12
#if 0
	start = (((int) etext + (SEGSIZE-1)) / SEGSIZE ) * SEGSIZE;
#else
	start = 0;
#endif
	end = sbrk(0);
	while (start < end) {		/* write out entire data space */
		num = start + 16 * 1024 > end ? end - start : 16 * 1024;
		write(outf, start, num);
		start += num;
	}
	close(outf);
d264 13
d285 4
a288 1
	rest_f(buf);
d298 9
a306 4
	char	*sp;
	int	inf, num;
	char	*start, *end;
	STAT	sbuf;
d308 6
a313 1
	if ((inf = open(file, O_RDONLY)) < 0) {
d315 79
a393 1
		return FALSE;
d395 49
a443 13
	printf("\"%s\" ", file);
	if (fstat(inf, &sbuf) < 0)		/* get file stats	*/
		err(1, "%s", file);
#if 0
	start = (((int) etext + (SEGSIZE-1)) / SEGSIZE ) * SEGSIZE;
#else
	start = 0;
#endif
	brk(end = start + sbuf.st_size);
	while (start < end) {		/* write out entire data space */
		num = start + 16 * 1024 > end ? end - start : 16 * 1024;
		read(inf, start, num);
		start += num;
d445 1
a445 1
	close(inf);
d451 1
a451 1
	return TRUE;
@


1.4
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.3 1998/11/29 19:45:11 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: execute.c,v 1.3 1998/11/29 19:45:11 pjanzen Exp $";
d63 1
a63 1
static void	show_move __P((void));
@


1.3
log
@Minor changes from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.2 1998/09/20 23:36:50 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: execute.c,v 1.2 1998/09/20 23:36:50 pjanzen Exp $";
d223 1
a223 1
		warn(buf);
d270 1
a270 1
		warn(file);
d275 1
a275 1
		err(1, file);
@


1.3.6.1
log
@Pull in patch from current (more to come...):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: execute.c,v 1.3 1998/11/29 19:45:11 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: execute.c,v 1.3 1998/11/29 19:45:11 pjanzen Exp $";
d223 1
a223 1
		warn("%s", buf);
d270 1
a270 1
		warn("%s", file);
d275 1
a275 1
		err(1, "%s", file);
@


1.2
log
@rand -> random; handle EOF; don't overflow on user input; check for calloc()
success; OpenBSD tags; some reformatting and ridding of unused variables.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD$";
d269 1
a269 1
	if ((inf = open(file, 0)) < 0) {
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: execute.c,v 1.3 1995/03/23 08:34:38 cgd Exp $";
d45 8
a52 4
# include	"monop.ext"
# include	<sys/types.h>
# include	<sys/stat.h>
# include	<sys/time.h>
d54 1
a54 1
# define	SEGSIZE	8192
d59 1
a59 2
extern char	etext[],	/* end of text space			*/
		rub();
d61 1
a61 2
static char	buf[257],
		*yn_only[]	= { "yes", "no"};
d63 1
a63 1
static bool	new_play;	/* set if move on to new player		*/
d66 22
d90 1
d92 2
a93 2
reg int	com_num; {

d106 5
a110 4
do_move() {

	reg int		r1, r2;
	reg bool	was_jail;
d113 1
a113 1
	printf("roll is %d, %d\n", r1=roll(1, 6), r2=roll(1, 6));
d128 1
a128 1
		move(r1+r2);
d138 1
d140 3
a142 3
reg int	rl; {

	reg int	old_loc;
d155 4
a158 3
show_move() {

	reg SQUARE	*sqp;
d163 1
a163 1
	  case SAFE:
d166 18
a183 13
	  case CC:
		cc(); break;
	  case CHANCE:
		chance(); break;
	  case INC_TAX:
		inc_tax(); break;
	  case GOTO_J:
		goto_jail(); break;
	  case LUX_TAX:
		lux_tax(); break;
	  case PRPTY:
	  case RR:
	  case UTIL:
d191 1
a191 1
				bid(sqp);
d202 5
a206 4
save() {

	reg char	*sp;
	reg int		outf, num;
a207 1
	int		*dat_end;
d209 1
a209 1
	unsgn		start, end;
d212 1
a212 4
	sp = buf;
	while ((*sp++=getchar()) != '\n')
		continue;
	*--sp = '\0';
d218 2
a219 2
	if (stat(buf, &sb) > -1
	    && getyn("File exists.  Do you wish to overwrite? ", yn_only) > 0)
d223 1
a223 1
		perror(buf);
d232 1
a232 1
# if 0
d234 1
a234 1
# else
d236 1
a236 1
# endif
d249 3
a251 4
restore() {

	reg char	*sp;

d253 1
a253 3
	for (sp = buf; (*sp=getchar()) != '\n'; sp++)
		continue;
	*sp = '\0';
d258 1
a258 1
 * backup was successful, else false.
d260 1
d262 6
a267 7
reg char	*file; {

	reg char	*sp;
	reg int		inf, num;
	char		buf[80];
	unsgn		start, end;
	STAT		sbuf;
d269 2
a270 2
	if ((inf=open(file, 0)) < 0) {
		perror(file);
d274 3
a276 5
	if (fstat(inf, &sbuf) < 0) {		/* get file stats	*/
		perror(file);
		exit(1);
	}
# if 0
d278 1
a278 1
# else
d280 1
a280 1
# endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
