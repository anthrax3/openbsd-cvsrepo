head	1.29;
access;
symbols
	OPENBSD_6_2:1.29.0.4
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.28.0.6
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.2
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.17.0.16
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.14
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.12
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.10
	OPENBSD_5_0:1.17.0.8
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.10
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.6
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.4
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.15.0.2
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.14.0.12
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.10
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.8
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.6
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.5.0.14
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.12
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2017.06.04.13.39.25;	author fcambus;	state Exp;
branches;
next	1.28;
commitid	bXS6ZTfgDRDtJe8b;

1.28
date	2016.03.07.12.07.56;	author mestre;	state Exp;
branches;
next	1.27;
commitid	NZhYxChmyb9vOEMM;

1.27
date	2016.01.07.16.00.32;	author tb;	state Exp;
branches;
next	1.26;
commitid	IwzFE3fG5RnKTWNh;

1.26
date	2016.01.04.11.58.35;	author mestre;	state Exp;
branches;
next	1.25;
commitid	TBXFQYiwdVBhodpy;

1.25
date	2016.01.03.14.38.17;	author mestre;	state Exp;
branches;
next	1.24;
commitid	Ptgw9rNvmSHNRfGy;

1.24
date	2015.12.25.20.59.09;	author mestre;	state Exp;
branches;
next	1.23;
commitid	5J5Os05YMVA0ZKC5;

1.23
date	2015.10.24.18.33.22;	author mmcc;	state Exp;
branches;
next	1.22;
commitid	bYkNcEp51OFyfV7k;

1.22
date	2015.09.16.16.32.11;	author tedu;	state Exp;
branches;
next	1.21;
commitid	oPmeVptgeQLjJrSP;

1.21
date	2014.11.16.04.49.48;	author guenther;	state Exp;
branches;
next	1.20;
commitid	8XNajyb9IqHkZEKg;

1.20
date	2014.10.11.04.00.56;	author doug;	state Exp;
branches;
next	1.19;
commitid	8GbTWBhBQFEq8kLP;

1.19
date	2013.08.29.20.22.12;	author naddy;	state Exp;
branches;
next	1.18;

1.18
date	2013.08.22.04.43.41;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.27.23.59.24;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.04.22.39.31;	author hshoexer;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.26.17.51.28;	author moritz;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.09.15.59.26;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.03.03.01.39;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.06.18.50.37;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.06.21.48.51;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.09;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.30.04.47.28;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.28.23.41.41;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.23.15.57.06;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.10.15.33.02;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	97.07.23.20.04.51;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.40.38;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.11.25.13.34.22;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.10.06.03.22.21;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.57;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.57;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Use proper bool types in fortune(6).

OK tb@@, phessler@@ (previous version)
@
text
@/*	$OpenBSD: strfile.c,v 1.28 2016/03/07 12:07:56 mestre Exp $	*/
/*	$NetBSD: strfile.c,v 1.4 1995/04/24 12:23:09 cgd Exp $	*/

/*-
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ken Arnold.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <ctype.h>
#include <err.h>
#include <limits.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "strfile.h"

/*
 *	This program takes a file composed of strings separated by
 * lines starting with two consecutive delimiting character (default
 * character is '%') and creates another file which consists of a table
 * describing the file (structure from "strfile.h"), a table of seek
 * pointers to the start of the strings, and the strings, each terminated
 * by a null byte.  Usage:
 *
 *	% strfile [-iorsx] [ -cC ] sourcefile [ datafile ]
 *
 *	c - Change delimiting character from '%' to 'C'
 *	s - Silent.  Give no summary of data processed at the end of
 *	    the run.
 *	o - order the strings in alphabetic order
 *	i - if ordering, ignore case 
 *	r - randomize the order of the strings
 *	x - set rotated bit
 *
 *		Ken Arnold	Sept. 7, 1978 --
 *
 *	Added ordering options.
 */

#define	STORING_PTRS	(Oflag || Rflag)
#define	CHUNKSIZE	512

# define	ALLOC(ptr,sz)	do { \
			if (ptr == NULL) \
				ptr = calloc(CHUNKSIZE, sizeof *ptr); \
			else if (((sz) + 1) % CHUNKSIZE == 0) \
				ptr = reallocarray(ptr, \
						   (sz) + CHUNKSIZE, \
						   sizeof(*ptr)); \
			if (ptr == NULL) \
				err(1, NULL); \
		} while (0)

typedef struct {
	char	first;
	int32_t	pos;
} STR;

char	*Infile		= NULL,		/* input file name */
	Outfile[PATH_MAX] = "",		/* output file name */
	Delimch		= '%';		/* delimiting character */

bool	Sflag		= false;	/* silent run flag */
bool	Oflag		= false;	/* ordering flag */
bool	Iflag		= false;	/* ignore case flag */
bool	Rflag		= false;	/* randomize order flag */
bool	Xflag		= false;	/* set rotated bit */
long	Num_pts		= 0;		/* number of pointers/strings */

int32_t	*Seekpts;

FILE	*Sort_1, *Sort_2;		/* pointers for sorting */

STRFILE	Tbl;				/* statistics table */

STR	*Firstch;			/* first chars of each string */


void add_offset(FILE *, int32_t);
int cmp_str(const void *, const void *);
void do_order(void);
void getargs(int, char **);
void randomize(void);
char *unctrl(char);
__dead void usage(void);

/*
 * main:
 *	Drive the sucker.  There are two main modes -- either we store
 *	the seek pointers, if the table is to be sorted or randomized,
 *	or we write the pointer directly to the file, if we are to stay
 *	in file order.  If the former, we allocate and re-allocate in
 *	CHUNKSIZE blocks; if the latter, we just write each pointer,
 *	and then seek back to the beginning to write in the table.
 */
int
main(int ac, char *av[])
{
	bool		first;
	char		*sp, dc;
	FILE		*inf, *outf;
	int32_t		last_off, length, pos;
	int32_t		*p;
	int		cnt;
	char		*nsp;
	STR		*fp;
	static char	string[257];

	if (pledge("stdio rpath wpath cpath", NULL) == -1)
		err(1, "pledge");

	getargs(ac, av);		/* evalute arguments */
	dc = Delimch;
	if ((inf = fopen(Infile, "r")) == NULL)
		err(1, "%s", Infile);

	if ((outf = fopen(Outfile, "w")) == NULL)
		err(1, "%s", Outfile);

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	if (!STORING_PTRS)
		(void) fseek(outf, sizeof Tbl, SEEK_SET);

	/*
	 * Write the strings onto the file
	 */

	Tbl.str_longlen = 0;
	Tbl.str_shortlen = (unsigned int) 0xffffffff;
	Tbl.str_delim = dc;
	Tbl.str_version = VERSION;
	first = Oflag;
	add_offset(outf, ftell(inf));
	last_off = 0;
	do {
		sp = fgets(string, sizeof(string), inf);
		if (sp == NULL || (sp[0] == dc && sp[1] == '\n')) {
			pos = ftell(inf);
			length = pos - last_off - (sp ? strlen(sp) : 0);
			last_off = pos;
			if (!length)
				continue;
			add_offset(outf, pos);
			if (Tbl.str_longlen < (u_int32_t)length)
				Tbl.str_longlen = length;
			if (Tbl.str_shortlen > (u_int32_t)length)
				Tbl.str_shortlen = length;
			first = Oflag;
		} else if (first) {
			for (nsp = sp; !isalnum((unsigned char)*nsp); nsp++)
				continue;
			ALLOC(Firstch, Num_pts);
			fp = &Firstch[Num_pts - 1];
			if (Iflag && isupper((unsigned char)*nsp))
				fp->first = tolower((unsigned char)*nsp);
			else
				fp->first = *nsp;
			fp->pos = Seekpts[Num_pts - 1];
			first = false;
		}
	} while (sp != NULL);

	/*
	 * write the tables in
	 */

	(void) fclose(inf);
	Tbl.str_numstr = Num_pts - 1;
	if (Tbl.str_numstr == 0)
		Tbl.str_shortlen = 0;

	if (Oflag)
		do_order();
	else if (Rflag)
		randomize();

	if (Xflag)
		Tbl.str_flags |= STR_ROTATED;

	if (!Sflag) {
		printf("\"%s\" created\n", Outfile);
		if (Tbl.str_numstr == 1)
			puts("There was 1 string");
		else
			printf("There were %u strings\n", Tbl.str_numstr);
		printf("Longest string: %lu byte%s\n",
			  (unsigned long) Tbl.str_longlen,
		       Tbl.str_longlen == 1 ? "" : "s");
		printf("Shortest string: %lu byte%s\n",
			  (unsigned long) Tbl.str_shortlen,
		       Tbl.str_shortlen == 1 ? "" : "s");
	}

	(void) fseek(outf, 0, SEEK_SET);
	Tbl.str_version = htonl(Tbl.str_version);
	Tbl.str_numstr = htonl(Tbl.str_numstr);
	Tbl.str_longlen = htonl(Tbl.str_longlen);
	Tbl.str_shortlen = htonl(Tbl.str_shortlen);
	Tbl.str_flags = htonl(Tbl.str_flags);
	(void) fwrite(&Tbl.str_version,  sizeof(Tbl.str_version),  1, outf);
	(void) fwrite(&Tbl.str_numstr,   sizeof(Tbl.str_numstr),   1, outf);
	(void) fwrite(&Tbl.str_longlen,  sizeof(Tbl.str_longlen),  1, outf);
	(void) fwrite(&Tbl.str_shortlen, sizeof(Tbl.str_shortlen), 1, outf);
	(void) fwrite(&Tbl.str_flags,    sizeof(Tbl.str_flags),    1, outf);
	(void) fwrite( Tbl.stuff,	 sizeof(Tbl.stuff),	   1, outf);
	if (STORING_PTRS) {
		for (p = Seekpts, cnt = Num_pts; cnt--; ++p) {
			*p = htonl(*p);
			(void) fwrite(p, sizeof(*p), 1, outf);
		}
	}
	if (fclose(outf))
		err(1, "fclose `%s'", Outfile);
	return 0;
}

/*
 *	This routine evaluates arguments from the command line
 */
void
getargs(int argc, char *argv[])
{
	extern char	*optarg;
	extern int	optind;
	int	ch;

	while ((ch = getopt(argc, argv, "c:hiorsx")) != -1) {
		switch(ch) {
		case 'c':			/* new delimiting char */
			Delimch = *optarg;
			if (!isascii((unsigned char)Delimch)) {
				printf("bad delimiting character: '\\%o\n'",
				       Delimch);
			}
			break;
		case 'i':			/* ignore case in ordering */
			Iflag = true;
			break;
		case 'o':			/* order strings */
			Oflag = true;
			break;
		case 'r':			/* randomize pointers */
			Rflag = true;
			break;
		case 's':			/* silent */
			Sflag = true;
			break;
		case 'x':			/* set the rotated bit */
			Xflag = true;
			break;
		case 'h':
		default:
			usage();
		}
	}
	argv += optind;

	if (*argv) {
		Infile = *argv;
		if (*++argv)
			(void) strlcpy(Outfile, *argv, sizeof Outfile);
	}
	if (!Infile) {
		puts("No input file name");
		usage();
	}
	if (*Outfile == '\0') {
		(void) strlcpy(Outfile, Infile, sizeof(Outfile));
		if (strlcat(Outfile, ".dat", sizeof(Outfile)) >= sizeof(Outfile))
			errx(1, "`%s': name too long", Infile);
	}
}

void
usage(void)
{
	(void) fprintf(stderr,
	    "%s [-iorsx] [-c char] sourcefile [datafile]\n", getprogname());
	exit(1);
}

/*
 * add_offset:
 *	Add an offset to the list, or write it out, as appropriate.
 */
void
add_offset(FILE *fp, int32_t off)
{
	int32_t net;

	if (!STORING_PTRS) {
		net = htonl(off);
		fwrite(&net, 1, sizeof net, fp);
	} else {
		ALLOC(Seekpts, Num_pts + 1);
		Seekpts[Num_pts] = off;
	}
	Num_pts++;
}

/*
 * do_order:
 *	Order the strings alphabetically (possibly ignoring case).
 */
void
do_order(void)
{
	int	i;
	int32_t	*lp;
	STR	*fp;

	Sort_1 = fopen(Infile, "r");
	Sort_2 = fopen(Infile, "r");
	qsort((char *) Firstch, (int) Tbl.str_numstr, sizeof *Firstch, cmp_str);
	i = Tbl.str_numstr;
	lp = Seekpts;
	fp = Firstch;
	while (i--)
		*lp++ = fp++->pos;
	(void) fclose(Sort_1);
	(void) fclose(Sort_2);
	Tbl.str_flags |= STR_ORDERED;
}

/*
 * cmp_str:
 *	Compare two strings in the file
 */
char *
unctrl(char c)
{
	static char	buf[3];

	if (isprint((unsigned char)c)) {
		buf[0] = c;
		buf[1] = '\0';
	} else if (c == 0177) {
		buf[0] = '^';
		buf[1] = '?';
	} else {
		buf[0] = '^';
		buf[1] = c + 'A' - 1;
	}
	return buf;
}

int
cmp_str(const void *p1, const void *p2)
{
	bool	n1, n2;
	int	c1, c2;

# define	SET_N(nf,ch)	(nf = (ch == '\n'))
# define	IS_END(ch,nf)	(ch == Delimch && nf)

	c1 = ((STR *)p1)->first;
	c2 = ((STR *)p2)->first;
	if (c1 != c2)
		return c1 - c2;

	(void) fseek(Sort_1, ((STR *)p1)->pos, SEEK_SET);
	(void) fseek(Sort_2, ((STR *)p2)->pos, SEEK_SET);

	n1 = false;
	n2 = false;
	while (!isalnum(c1 = getc(Sort_1)) && c1 != '\0')
		SET_N(n1, c1);
	while (!isalnum(c2 = getc(Sort_2)) && c2 != '\0')
		SET_N(n2, c2);

	while (!IS_END(c1, n1) && !IS_END(c2, n2)) {
		if (Iflag) {
			if (isupper(c1))
				c1 = tolower(c1);
			if (isupper(c2))
				c2 = tolower(c2);
		}
		if (c1 != c2)
			return c1 - c2;
		SET_N(n1, c1);
		SET_N(n2, c2);
		c1 = getc(Sort_1);
		c2 = getc(Sort_2);
	}
	if (IS_END(c1, n1))
		c1 = 0;
	if (IS_END(c2, n2))
		c2 = 0;
	return c1 - c2;
}

/*
 * randomize:
 *	Randomize the order of the string table.  We must be careful
 *	not to randomize across delimiter boundaries.  All
 *	randomization is done within each block.
 */
void
randomize(void)
{
	int	cnt, i;
	int32_t	tmp;
	int32_t	*sp;

	Tbl.str_flags |= STR_RANDOM;
	cnt = Tbl.str_numstr;

	/*
	 * move things around randomly
	 */

	for (sp = Seekpts; cnt > 0; cnt--, sp++) {
		i = arc4random_uniform(cnt);
		tmp = sp[0];
		sp[0] = sp[i];
		sp[i] = tmp;
	}
}
@


1.28
log
@- General changes:
- Remove -? from getopt(3) options, but still keep (or add) -h where applicable
- Replace hardcoded program strings by getprogname(3)

- Specific changes:
- atc(6): this used -? and -u for usage(), remove both from game and manpage
- bcd(6): use __progname instead of getprogname(3), no need to include stdlib.h
- hunt(6): replace fputs(3) by fprintf(3)

OK tb@@ after his suggestions
@
text
@d1 1
a1 1
/*	$OpenBSD: strfile.c,v 1.27 2016/01/07 16:00:32 tb Exp $	*/
d39 1
a69 3
#define	TRUE	1
#define	FALSE	0

d93 5
a97 5
int	Sflag		= FALSE;	/* silent run flag */
int	Oflag		= FALSE;	/* ordering flag */
int	Iflag		= FALSE;	/* ignore case flag */
int	Rflag		= FALSE;	/* randomize order flag */
int	Xflag		= FALSE;	/* set rotated bit */
d129 1
d134 1
a134 1
	int		first, cnt;
d191 1
a191 1
			first = FALSE;
d269 1
a269 1
			Iflag++;
d272 1
a272 1
			Oflag++;
d275 1
a275 1
			Rflag++;
d278 1
a278 1
			Sflag++;
d281 1
a281 1
			Xflag++;
d382 1
a383 1
	int	n1, n2;
d396 2
a397 2
	n1 = FALSE;
	n2 = FALSE;
@


1.27
log
@Some basic code maintenance in games/

- in main() replace exit with return
- drop some /* NOTREACHED */ lint comments along the way.
- make more use of standard CFLAGS, esp. -Wimplicit-function-declaration
- add and sort some headers when needed
- add straightforward pledges to some programs used at compile time

discussed with and ok mestre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: strfile.c,v 1.26 2016/01/04 11:58:35 mestre Exp $	*/
d260 1
a260 1
	while ((ch = getopt(argc, argv, "c:iorsx")) != -1) {
d284 1
a284 1
		case '?':
d311 1
a311 1
	    "strfile [-iorsx] [-c char] sourcefile [datafile]\n");
@


1.26
log
@More headers removal and sorted the remaining alphabetically.

Most noticeable that were removed are sys/types.h which will be included from
stdlib.h and in turn also brings along sys/cdefs.h. The other one is limits.h
that was used with the old idiom (denom * random() / LONG_MAX), although it was
only removed were applicable (some files still need that header).

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: strfile.c,v 1.25 2016/01/03 14:38:17 mestre Exp $	*/
d140 3
d150 4
d247 1
a247 1
	exit(0);
@


1.25
log
@About 13 years ago when the idiom srandom(time()), and sometimes
srandom(time()+getpid()), was changed by srandomdev(), but #include <time.h>
lived up until this day so remove it.

Additionally, earlier than that, 18 years ago, random(6) was one of the first
consumers of arc4random(3) family, and was pulling it from dev/rndvar.h but
these days we pull it from stdlib.h, which is already done, so while here
remove dev/rndvar.h also.

"seems comprehensive to me" deraadt@@ and OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: strfile.c,v 1.24 2015/12/25 20:59:09 mestre Exp $	*/
d36 7
a42 7
#include	<ctype.h>
#include	<err.h>
#include	<limits.h>
#include	<stdio.h>
#include	<stdlib.h>
#include	<string.h>
#include	<unistd.h>
d44 1
a44 1
#include	"strfile.h"
@


1.24
log
@Declare usage() functions as __dead void, if they don't return, on games section.

Found another one in arithmetic(6) which also didn't return, and removed a function from number(6) which is not used anymore.

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: strfile.c,v 1.23 2015/10/24 18:33:22 mmcc Exp $	*/
a41 1
#include	<time.h>
d43 1
@


1.23
log
@Cast ctype functions' argument to unsigned char.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: strfile.c,v 1.22 2015/09/16 16:32:11 tedu Exp $	*/
d117 1
a117 1
void usage(void);
@


1.22
log
@big blocks need braces for support
@
text
@d1 1
a1 1
/*	$OpenBSD: strfile.c,v 1.21 2014/11/16 04:49:48 guenther Exp $	*/
d176 1
a176 1
			for (nsp = sp; !isalnum(*nsp); nsp++)
d180 2
a181 2
			if (Iflag && isupper(*nsp))
				fp->first = tolower(*nsp);
d257 1
a257 1
			if (!isascii(Delimch)) {
d360 1
a360 1
	if (isprint(c)) {
@


1.21
log
@Eliminate pointless use of <sys/param.h>, <sys/file.h>, <sys/sockio.h>,
    and <sys/ttydefaults.h>
Replace MAXPATHLEN with PATH_MAX and MAXLOGNAME with LOGIN_NAME_MAX
Pull in <limits.h> where needed
Prefer sizeof(var) over MAXFOO or FOO_MAX

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: strfile.c,v 1.20 2014/10/11 04:00:56 doug Exp $	*/
d175 1
a175 2
		}
		else if (first) {
d232 1
a232 1
	if (STORING_PTRS)
d237 1
d253 1
a253 1
	while ((ch = getopt(argc, argv, "c:iorsx")) != -1)
d281 1
d363 1
a363 2
	}
	else if (c == 0177) {
d366 1
a366 2
	}
	else {
@


1.20
log
@Userland reallocarray() audit.

Avoid potential integer overflow in the size argument of malloc() and
realloc() by using reallocarray() to avoid unchecked multiplication.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: strfile.c,v 1.19 2013/08/29 20:22:12 naddy Exp $	*/
a35 1
#include	<sys/param.h>
d38 1
d92 1
a92 1
	Outfile[MAXPATHLEN] = "",	/* output file name */
d294 1
a294 1
		if (strlcat(Outfile, ".dat", sizeof(Outfile)) >= MAXPATHLEN)
@


1.19
log
@replace srandomdev()+random() with the arc4random*() family
tweaks and ok millert@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: strfile.c,v 1.18 2013/08/22 04:43:41 guenther Exp $	*/
d79 3
a81 1
				ptr = realloc((void *) ptr, ((sz) + CHUNKSIZE) * sizeof *ptr); \
@


1.18
log
@Correct format string mismatches turned up by -Wformat=2

suggestions and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: strfile.c,v 1.17 2009/10/27 23:59:24 deraadt Exp $	*/
a429 2
	srandomdev();

d438 1
a438 1
		i = random() % cnt;
@


1.17
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: strfile.c,v 1.16 2007/09/04 22:39:31 hshoexer Exp $	*/
d210 1
a210 1
			printf("There were %ld strings\n", Tbl.str_numstr);
@


1.16
log
@Some more simple malloc(n * m) -> calloc(n, m) conversions.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: strfile.c,v 1.15 2007/06/26 17:51:28 moritz Exp $	*/
a34 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)strfile.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: strfile.c,v 1.15 2007/06/26 17:51:28 moritz Exp $";
#endif
#endif /* not lint */
@


1.15
log
@Set shortest string count to 0 in strfile(8), if there a no strings found
and check the number of strings in fortune(6) to prevent empty fortune
files to cause division by zero. Fixes PR 5514.

OK miod@@ ray@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: strfile.c,v 1.14 2004/07/09 15:59:26 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: strfile.c,v 1.14 2004/07/09 15:59:26 deraadt Exp $";
d91 1
a91 1
				ptr = malloc(CHUNKSIZE * sizeof *ptr); \
@


1.14
log
@ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: strfile.c,v 1.13 2003/06/03 03:01:39 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: strfile.c,v 1.13 2003/06/03 03:01:39 millert Exp $";
d208 2
d221 1
a221 1
		if (Num_pts == 2)
d224 1
a224 1
			printf("There were %ld strings\n", Num_pts - 1);
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: strfile.c,v 1.12 2003/04/06 18:50:37 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: strfile.c,v 1.12 2003/04/06 18:50:37 deraadt Exp $";
d141 1
a141 3
main(ac, av)
	int	ac;
	char	**av;
d257 1
a257 3
getargs(argc, argv)
	int	argc;
	char	**argv;
d310 1
a310 1
usage()
d322 1
a322 3
add_offset(fp, off)
	FILE	*fp;
	int32_t	off;
d341 1
a341 1
do_order()
d365 1
a365 2
unctrl(c)
	char c;
d385 1
a385 2
cmp_str(p1, p2)
	const void	*p1, *p2;
d436 1
a436 1
randomize()
@


1.12
log
@2451 lines of strdup/sprintf/strcpy whacking.  mostly ok'd by pjanzen
already, but he may have later changes to make still.
@
text
@d1 1
a1 1
/*	$OpenBSD: strfile.c,v 1.11 2002/12/06 21:48:51 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: strfile.c,v 1.11 2002/12/06 21:48:51 millert Exp $";
@


1.11
log
@Replace things like srandom(time(NULL)) with srandomdev(3).  random(3)
good enough for games but we should at least use a decent seed.
pjanzen@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: strfile.c,v 1.10 2002/02/16 21:27:09 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: strfile.c,v 1.10 2002/02/16 21:27:09 millert Exp $";
d304 1
a304 1
			(void) strcpy(Outfile, *argv);
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: strfile.c,v 1.9 2001/03/30 04:47:28 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: strfile.c,v 1.9 2001/03/30 04:47:28 pjanzen Exp $";
d454 1
a454 1
	srandom((int)(time((time_t *) NULL) + getpid()));
@


1.9
log
@Add prototypes, de-register, do better error checking, -Wall some, fix strcat()
usage, and fix FreeBSD PR 5791
@
text
@d1 1
a1 1
/*	$OpenBSD: strfile.c,v 1.8 2001/01/28 23:41:41 niklas Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: strfile.c,v 1.8 2001/01/28 23:41:41 niklas Exp $";
d127 7
a133 7
void add_offset __P((FILE *, int32_t));
int cmp_str __P((const void *, const void *));
void do_order __P((void));
void getargs __P((int, char **));
void randomize __P((void));
char *unctrl __P((char));
void usage __P((void));
@


1.8
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: strfile.c,v 1.4 1995/04/24 12:23:09 cgd Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: strfile.c,v 1.4 1995/04/24 12:23:09 cgd Exp $";
d54 9
a62 9
# include	<sys/param.h>
# include	<stdio.h>
# include	<string.h>
# include	<ctype.h>
# include	"strfile.h"

# ifndef MAXPATHLEN
# define	MAXPATHLEN	1024
# endif	/* MAXPATHLEN */
d87 2
a88 2
# define	TRUE	1
# define	FALSE	0
d90 2
a91 2
# define	STORING_PTRS	(Oflag || Rflag)
# define	CHUNKSIZE	512
d93 1
a93 6
#ifdef lint
# define	ALWAYS	atoi("1")
#else
# define	ALWAYS	1
#endif
# define	ALLOC(ptr,sz)	if (ALWAYS) { \
d95 1
a95 1
				ptr = malloc((unsigned int) (CHUNKSIZE * sizeof *ptr)); \
d97 4
a100 10
				ptr = realloc((void *) ptr, ((unsigned int) ((sz) + CHUNKSIZE) * sizeof *ptr)); \
			if (ptr == NULL) { \
				fprintf(stderr, "out of space\n"); \
				exit(1); \
			} \
		} else

#ifdef NO_VOID
# define	void	char
#endif
a125 1
char	*fgets(), *strcpy(), *strcat();
d127 7
a133 1
void	*malloc(), *realloc();
d144 1
d146 2
a147 2
int	ac;
char	**av;
d149 8
a156 8
	register char		*sp, dc;
	register FILE		*inf, *outf;
	register int32_t	last_off, length, pos;
	register int32_t	*p;
	register int		first, cnt;
	register char		*nsp;
	register STR		*fp;
	static char		string[257];
d160 2
a161 4
	if ((inf = fopen(Infile, "r")) == NULL) {
		perror(Infile);
		exit(1);
	}
d163 2
a164 4
	if ((outf = fopen(Outfile, "w")) == NULL) {
		perror(Outfile);
		exit(1);
	}
d166 1
a166 1
		(void) fseek(outf, sizeof Tbl, 0);
d180 2
a181 2
		sp = fgets(string, 256, inf);
		if (sp == NULL || sp[0] == dc && sp[1] == '\n') {
d188 1
a188 1
			if (Tbl.str_longlen < length)
d190 1
a190 1
			if (Tbl.str_shortlen > length)
d213 1
d228 3
a230 2
			printf("There were %d strings\n", Num_pts - 1);
		printf("Longest string: %lu byte%s\n", Tbl.str_longlen,
d232 2
a233 1
		printf("Shortest string: %lu byte%s\n", Tbl.str_shortlen,
d237 1
a237 1
	(void) fseek(outf, (long) 0, 0);
d239 1
a239 1
	Tbl.str_numstr = htonl(Num_pts - 1);
d254 2
a255 1
	(void) fclose(outf);
d262 1
d264 2
a265 2
int	argc;
char	**argv;
d311 3
a313 2
		(void) strcpy(Outfile, Infile);
		(void) strcat(Outfile, ".dat");
d317 1
d329 1
d331 2
a332 2
FILE	*fp;
int32_t	off;
d350 1
d353 3
a355 4
	register int		i;
	register int32_t	*lp;
	register STR		*fp;
	extern int		cmp_str();
d376 1
a376 1
char c;
d395 1
d397 1
a397 1
STR	*p1, *p2;
d399 2
a400 2
	register int	c1, c2;
	register int	n1, n2;
d405 2
a406 2
	c1 = p1->first;
	c2 = p2->first;
d410 2
a411 2
	(void) fseek(Sort_1, p1->pos, 0);
	(void) fseek(Sort_2, p2->pos, 0);
d447 1
d450 3
a452 4
	register int		cnt, i;
	register int32_t	tmp;
	register int32_t	*sp;
	extern time_t		time();
@


1.7
log
@Remove another useless machine/endian.h include
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: strfile.c,v 1.4 1995/04/24 12:23:09 cgd Exp $";
@


1.6
log
@seperate -> separate, okay aaron@@
@
text
@a53 1
# include	<machine/endian.h>
@


1.5
log
@tabify
@
text
@d65 1
a65 1
 *	This program takes a file composed of strings seperated by
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d254 1
a254 1
	(void) fwrite( Tbl.stuff,        sizeof(Tbl.stuff),        1, outf);
@


1.3
log
@Reorder includes for htons et al.
@
text
@d275 1
a275 1
	while ((ch = getopt(argc, argv, "c:iorsx")) != EOF)
@


1.2
log
@Store the fortune data files with fixed data types, and document this.
Bump database version to 2.
@
text
@d53 1
a54 1
# include	<sys/param.h>
@


1.1
log
@Initial revision
@
text
@d115 1
a115 1
	off_t	pos;
d129 1
a129 1
off_t	*Seekpts;
d156 2
a157 1
	register off_t		last_off, length, pos, *p;
d243 1
a243 1
	(void) fseek(outf, (off_t) 0, 0);
d249 8
a256 3
	(void) fwrite((char *) &Tbl, sizeof Tbl, 1, outf);
	if (STORING_PTRS) {
		for (p = Seekpts, cnt = Num_pts; cnt--; ++p)
d258 2
a259 2
		(void) fwrite((char *) Seekpts, sizeof *Seekpts, (int) Num_pts, outf);
	}
d333 1
a333 1
off_t	off;
d335 1
a335 1
	off_t net;
d353 4
a356 4
	register int	i;
	register off_t	*lp;
	register STR	*fp;
	extern int	cmp_str();
d449 4
a452 4
	register int	cnt, i;
	register off_t	tmp;
	register off_t	*sp;
	extern time_t	time();
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
