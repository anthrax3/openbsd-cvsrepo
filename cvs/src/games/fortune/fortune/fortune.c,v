head	1.55;
access;
symbols
	OPENBSD_6_1:1.55.0.6
	OPENBSD_6_1_BASE:1.55
	OPENBSD_6_0:1.55.0.2
	OPENBSD_6_0_BASE:1.55
	OPENBSD_5_9:1.51.0.2
	OPENBSD_5_9_BASE:1.51
	OPENBSD_5_8:1.42.0.6
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.31.0.6
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.4
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.30.0.12
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.10
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.8
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.6
	OPENBSD_5_0:1.30.0.4
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.27.0.8
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.4
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.22.0.4
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.20.0.6
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.4
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.8.0.6
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.6
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.55
date	2016.03.07.22.49.45;	author tb;	state Exp;
branches;
next	1.54;
commitid	GUTHaRvufnIMbc4W;

1.54
date	2016.03.07.19.49.38;	author tb;	state Exp;
branches;
next	1.53;
commitid	24ldXia2gSFAlCqG;

1.53
date	2016.03.07.12.07.56;	author mestre;	state Exp;
branches;
next	1.52;
commitid	NZhYxChmyb9vOEMM;

1.52
date	2016.03.05.11.06.43;	author tb;	state Exp;
branches;
next	1.51;
commitid	ILOLtePVqn4ETIxw;

1.51
date	2016.01.10.13.35.09;	author mestre;	state Exp;
branches;
next	1.50;
commitid	mVbl9a8GbGdqcFgu;

1.50
date	2016.01.07.16.00.32;	author tb;	state Exp;
branches;
next	1.49;
commitid	IwzFE3fG5RnKTWNh;

1.49
date	2016.01.04.11.58.35;	author mestre;	state Exp;
branches;
next	1.48;
commitid	TBXFQYiwdVBhodpy;

1.48
date	2015.12.25.20.59.09;	author mestre;	state Exp;
branches;
next	1.47;
commitid	5J5Os05YMVA0ZKC5;

1.47
date	2015.11.10.15.29.11;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	WpHkgWJ9pvFUPn1E;

1.46
date	2015.11.10.14.56.50;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	8aIvtgEzROgzeyj1;

1.45
date	2015.11.10.14.50.04;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	1pynA3f2UKVFdrMO;

1.44
date	2015.10.24.18.02.28;	author mmcc;	state Exp;
branches;
next	1.43;
commitid	cpTzqkZsoXM1jPGt;

1.43
date	2015.08.26.14.49.20;	author semarie;	state Exp;
branches;
next	1.42;
commitid	c1EoW0s10B9dKLbc;

1.42
date	2015.02.06.10.50.48;	author tedu;	state Exp;
branches;
next	1.41;
commitid	F0VHO5aWYPyeMypn;

1.41
date	2015.02.06.10.49.32;	author tedu;	state Exp;
branches;
next	1.40;
commitid	8UYlUq4wsYTUz5nq;

1.40
date	2015.02.06.10.46.52;	author tedu;	state Exp;
branches;
next	1.39;
commitid	4eWeHXuBM1HrZHaq;

1.39
date	2015.02.06.10.26.06;	author tedu;	state Exp;
branches;
next	1.38;
commitid	p7oFxroRPeZ4G64E;

1.38
date	2015.02.06.10.25.32;	author tedu;	state Exp;
branches;
next	1.37;
commitid	eKrxpbEL5jMxXVD9;

1.37
date	2015.02.06.10.18.51;	author tedu;	state Exp;
branches;
next	1.36;
commitid	8BFMQVwwT7kuhpNE;

1.36
date	2015.02.06.10.17.56;	author tedu;	state Exp;
branches;
next	1.35;
commitid	wJ0g0ULSfESBWJIH;

1.35
date	2015.02.06.10.12.57;	author tedu;	state Exp;
branches;
next	1.34;
commitid	T8lYf00ZFK5ITjUV;

1.34
date	2015.02.06.10.04.18;	author tedu;	state Exp;
branches;
next	1.33;
commitid	pGLDLvJxjSTSfXDs;

1.33
date	2015.02.06.09.55.01;	author tedu;	state Exp;
branches;
next	1.32;
commitid	RyewnnGFxpU6zcSA;

1.32
date	2014.11.16.04.49.48;	author guenther;	state Exp;
branches;
next	1.31;
commitid	8XNajyb9IqHkZEKg;

1.31
date	2014.01.11.06.28.46;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2011.01.03.17.38.24;	author jasper;	state Exp;
branches;
next	1.29;

1.29
date	2010.07.02.23.43.42;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2009.10.27.23.59.24;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2008.04.13.00.22.16;	author djm;	state Exp;
branches;
next	1.26;

1.26
date	2008.03.17.09.17.56;	author sobrado;	state Exp;
branches;
next	1.25;

1.25
date	2007.09.10.14.29.53;	author tobias;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.26.17.51.28;	author moritz;	state Exp;
branches;
next	1.23;

1.23
date	2006.09.25.06.03.29;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2005.09.24.18.10.02;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2005.09.24.18.07.53;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2004.07.09.15.59.26;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.18.23.37.36;	author pvalchev;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.03.03.01.39;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.07.00.26.22;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.06.18.50.37;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.31.20.40.11;	author pjanzen;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.31.04.21.30;	author pjanzen;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.17.19.42.20;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.27.09;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.26.01.36.33;	author pjanzen;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.22.22.29.40;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.28.23.41.40;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.08.16.17.32.42;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.11.18.21.35.10;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.11.18.21.34.00;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.07.23.20.04.50;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.01.17.07.10.56;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.40.37;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.10.06.03.22.18;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.56;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.56;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.55
log
@eliminate do_malloc() and do_free().

These are wrappers for malloc(3) and free(3) with NULL checks. do_free()
is pointless since free() already checks for NULL.  do_malloc() is used
only three times, once asprintf(3) seems more appropriate, and for just
two calls the benefit of a custom wrapper is minimal.

ok millert@@
@
text
@/*	$OpenBSD: fortune.c,v 1.54 2016/03/07 19:49:38 tb Exp $	*/
/*	$NetBSD: fortune.c,v 1.8 1995/03/23 08:28:40 cgd Exp $	*/

/*-
 * Copyright (c) 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ken Arnold.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>

#include <assert.h>
#include <ctype.h>
#include <dirent.h>
#include <err.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <regex.h>
#include <unistd.h>

#include "pathnames.h"
#include "strfile.h"

#define	bool	short

#define	MINW	6		/* minimum wait if desired */
#define	CPERS	20		/* # of chars for each sec */
#define	SLEN	160		/* # of chars in short fortune */

#define	POS_UNKNOWN	((int32_t) -1)	/* pos for file unknown */
#define	NO_PROB		(-1)		/* no prob specified for file */

#ifdef DEBUG
#define	DPRINTF(l,x)	if (Debug >= l) fprintf x; else
#undef		NDEBUG
#else
#define	DPRINTF(l,x)
#define	NDEBUG	1
#endif

typedef struct fd {
	int		percent;
	int		fd, datfd;
	int32_t		pos;
	FILE		*inf;
	char		*name;
	char		*path;
	char		*datfile;
	bool		read_tbl;
	STRFILE		tbl;
	int		num_children;
	struct fd	*child, *parent;
	struct fd	*next, *prev;
} FILEDESC;

bool	Found_one;			/* did we find a match? */
bool	Find_files	= 0;	/* just find a list of proper fortune files */
bool	Wait		= 0;	/* wait desired after fortune */
bool	Short_only	= 0;	/* short fortune desired */
bool	Long_only	= 0;	/* long fortune desired */
bool	Offend		= 0;	/* offensive fortunes only */
bool	All_forts	= 0;	/* any fortune allowed */
bool	Equal_probs	= 0;	/* scatter un-allocted prob equally */
bool	Match		= 0;	/* dump fortunes matching a pattern */
#ifdef DEBUG
int	Debug = 0;			/* print debug messages */
#endif

char	*Fortbuf = NULL;			/* fortune buffer for -m */

size_t	Fort_len = 0;

int32_t	Seekpts[2];			/* seek pointers to fortunes */

FILEDESC	*File_list = NULL,	/* Head of file list */
		*File_tail = NULL;	/* Tail of file list */
FILEDESC	*Fortfile;		/* Fortune file to use */

STRFILE		Noprob_tbl;		/* sum of data for all no prob files */

int	 add_dir(FILEDESC *);
int	 add_file(int,
	    char *, char *, FILEDESC **, FILEDESC **, FILEDESC *);
void	 all_forts(FILEDESC *, char *);
char	*copy(char *, char *);
void	 display(FILEDESC *);
int	 form_file_list(char **, int);
int	 fortlen(void);
void	 get_fort(void);
void	 get_pos(FILEDESC *);
void	 get_tbl(FILEDESC *);
void	 getargs(int, char *[]);
void	 init_prob(void);
int	 is_dir(char *);
int	 is_fortfile(char *, char **, int);
int	 is_off_name(char *);
int	 max(int, int);
FILEDESC *
	 new_fp(void);
char	*off_name(char *);
void	 open_dat(FILEDESC *);
void	 open_fp(FILEDESC *);
FILEDESC *
	 pick_child(FILEDESC *);
void	 print_file_list(void);
void	 print_list(FILEDESC *, int);
void	 sum_noprobs(FILEDESC *);
void	 sum_tbl(STRFILE *, STRFILE *);
__dead void	 usage(void);
void	 zero_tbl(STRFILE *);

char	*conv_pat(char *);
int	 find_matches(void);
void	 matches_in_list(FILEDESC *);
int	 maxlen_in_list(FILEDESC *);
int	 minlen_in_list(FILEDESC *);
regex_t regex;

int
main(int ac, char *av[])
{
	if (pledge("stdio rpath", NULL) == -1) {
		perror("pledge");
		return 1;
	}

	getargs(ac, av);

	if (Match)
		return find_matches() != 0;

	init_prob();
	if ((Short_only && minlen_in_list(File_list) > SLEN) ||
	    (Long_only && maxlen_in_list(File_list) <= SLEN))
		return 0;

	do {
		get_fort();
	} while ((Short_only && fortlen() > SLEN) ||
		 (Long_only && fortlen() <= SLEN));

	display(Fortfile);

	if (Wait) {
		if (Fort_len == 0)
			(void) fortlen();
		sleep((unsigned int) max(Fort_len / CPERS, MINW));
	}
	return 0;
}

void
rot13(char *p, size_t len)
{
	while (len--) {
		unsigned char ch = *p;
		if (isupper(ch))
			*p = 'A' + (ch - 'A' + 13) % 26;
		else if (islower(ch))
			*p = 'a' + (ch - 'a' + 13) % 26;
		p++;
	}
}

void
display(FILEDESC *fp)
{
	char	line[BUFSIZ];

	open_fp(fp);
	(void) fseek(fp->inf, (long)Seekpts[0], SEEK_SET);
	for (Fort_len = 0; fgets(line, sizeof line, fp->inf) != NULL &&
	    !STR_ENDSTRING(line, fp->tbl); Fort_len++) {
		if (fp->tbl.str_flags & STR_ROTATED)
			rot13(line, strlen(line));
		fputs(line, stdout);
	}
	(void) fflush(stdout);
}

/*
 * fortlen:
 *	Return the length of the fortune.
 */
int
fortlen(void)
{
	size_t	nchar;
	char	line[BUFSIZ];

	if (!(Fortfile->tbl.str_flags & (STR_RANDOM | STR_ORDERED)))
		nchar = (Seekpts[1] - Seekpts[0] <= SLEN);
	else {
		open_fp(Fortfile);
		(void) fseek(Fortfile->inf, (long)Seekpts[0], SEEK_SET);
		nchar = 0;
		while (fgets(line, sizeof line, Fortfile->inf) != NULL &&
		       !STR_ENDSTRING(line, Fortfile->tbl))
			nchar += strlen(line);
	}
	Fort_len = nchar;
	return nchar;
}

/*
 *	This routine evaluates the arguments on the command line
 */
void
getargs(int argc, char *argv[])
{
	int	ignore_case;
	char	*pat = NULL;
	int ch;

	ignore_case = 0;

#ifdef DEBUG
	while ((ch = getopt(argc, argv, "aDefhilm:osw")) != -1)
#else
	while ((ch = getopt(argc, argv, "aefhilm:osw")) != -1)
#endif /* DEBUG */
		switch(ch) {
		case 'a':		/* any fortune */
			All_forts = 1;
			break;
#ifdef DEBUG
		case 'D':
			Debug++;
			break;
#endif /* DEBUG */
		case 'e':
			Equal_probs = 1;	/* scatter un-allocted prob equally */
			break;
		case 'f':		/* find fortune files */
			Find_files = 1;
			break;
		case 'l':		/* long ones only */
			Long_only = 1;
			Short_only = 0;
			break;
		case 'o':		/* offensive ones only */
			Offend = 1;
			break;
		case 's':		/* short ones only */
			Short_only = 1;
			Long_only = 0;
			break;
		case 'w':		/* give time to read */
			Wait = 1;
			break;
		case 'm':			/* dump out the fortunes */
			Match = 1;
			pat = optarg;
			break;
		case 'i':			/* case-insensitive match */
			ignore_case = 1;
			break;
		case 'h':
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (!form_file_list(argv, argc))
		exit(1);	/* errors printed through form_file_list() */
#ifdef DEBUG
	if (Debug >= 1)
		print_file_list();
#endif /* DEBUG */
	if (Find_files) {
		print_file_list();
		exit(0);
	}

	if (pat != NULL) {
		if (regcomp(&regex, pat, ignore_case ? REG_ICASE : 0))
			fprintf(stderr, "bad pattern: %s\n", pat);
	}
}

/*
 * form_file_list:
 *	Form the file list from the file specifications.
 */
int
form_file_list(char **files, int file_cnt)
{
	int	i, percent;
	char	*sp;

	if (file_cnt == 0) {
		if (Find_files)
			return add_file(NO_PROB, FORTDIR, NULL, &File_list,
					&File_tail, NULL);
		else
			return add_file(NO_PROB, "fortunes", FORTDIR,
					&File_list, &File_tail, NULL);
	}
	for (i = 0; i < file_cnt; i++) {
		percent = NO_PROB;

		if (isdigit((unsigned char)files[i][0])) {
			int pos = strspn(files[i], "0123456789.");

			/*
			 * Only try to interpret files[i] as a percentage if
			 * it ends in '%'. Otherwise assume it's a file name.
			 */
			if (files[i][pos] == '%' && files[i][pos+1] == '\0') {
				const char *errstr;
				char *prefix;

				if ((prefix = strndup(files[i], pos)) == NULL)
					err(1, NULL);
				if (strchr(prefix, '.') != NULL)
					errx(1, "percentages must be integers");
				percent = strtonum(prefix, 0, 100, &errstr);
				if (errstr != NULL)
					errx(1, "percentage is %s: %s", errstr,
					    prefix);
				free(prefix);

				if (++i >= file_cnt)
					errx(1,
					    "percentages must precede files");
			}
		}
		sp = files[i];
		if (strcmp(sp, "all") == 0)
			sp = FORTDIR;
		if (!add_file(percent, sp, NULL, &File_list, &File_tail, NULL))
			return 0;
	}
	return 1;
}

/*
 * add_file:
 *	Add a file to the file list.
 */
int
add_file(int percent, char *file, char *dir, FILEDESC **head, FILEDESC **tail,
    FILEDESC *parent)
{
	FILEDESC	*fp;
	int		fd;
	char		*path, *offensive;
	bool		was_malloc;
	bool		isdir;

	if (dir == NULL) {
		path = file;
		was_malloc = 0;
	} else {
		if (asprintf(&path, "%s/%s", dir, file) == -1)
			err(1, NULL);
		was_malloc = 1;
	}
	if ((isdir = is_dir(path)) && parent != NULL) {
		if (was_malloc)
			free(path);
		return 0;	/* don't recurse */
	}
	offensive = NULL;
	if (!isdir && parent == NULL && (All_forts || Offend) &&
	    !is_off_name(path)) {
		offensive = off_name(path);
		if (Offend) {
			if (was_malloc)
				free(path);
			path = offensive;
			file = off_name(file);
			was_malloc = 1;
		}
	}

	DPRINTF(1, (stderr, "adding file \"%s\"\n", path));
over:
	if ((fd = open(path, O_RDONLY)) < 0) {
		/*
		 * This is a sneak.  If the user said -a, and if the
		 * file we're given isn't a file, we check to see if
		 * there is a -o version.  If there is, we treat it as
		 * if *that* were the file given.  We only do this for
		 * individual files -- if we're scanning a directory,
		 * we'll pick up the -o file anyway.
		 */
		if (All_forts && offensive != NULL) {
			path = offensive;
			if (was_malloc)
				free(path);
			offensive = NULL;
			was_malloc = 1;
			DPRINTF(1, (stderr, "\ttrying \"%s\"\n", path));
			file = off_name(file);
			goto over;
		}
		if (dir == NULL && file[0] != '/')
			return add_file(percent, file, FORTDIR, head, tail,
					parent);
		if (parent == NULL)
			perror(path);
		if (was_malloc)
			free(path);
		return 0;
	}

	DPRINTF(2, (stderr, "path = \"%s\"\n", path));

	fp = new_fp();
	fp->fd = fd;
	fp->percent = percent;
	fp->name = file;
	fp->path = path;
	fp->parent = parent;

	if ((isdir && !add_dir(fp)) ||
	    (!isdir &&
	     !is_fortfile(path, &fp->datfile, (parent != NULL))))
	{
		if (parent == NULL)
			fprintf(stderr,
				"fortune: %s not a fortune file or directory\n",
				path);
		if (was_malloc)
			free(path);
		free(fp->datfile);
		free((char *) fp);
		free(offensive);
		return 0;
	}
	/*
	 * If the user said -a, we need to make this node a pointer to
	 * both files, if there are two.  We don't need to do this if
	 * we are scanning a directory, since the scan will pick up the
	 * -o file anyway.
	 */
	if (All_forts && parent == NULL && !is_off_name(path))
		all_forts(fp, offensive);
	if (*head == NULL)
		*head = *tail = fp;
	else if (fp->percent == NO_PROB) {
		(*tail)->next = fp;
		fp->prev = *tail;
		*tail = fp;
	}
	else {
		(*head)->prev = fp;
		fp->next = *head;
		*head = fp;
	}

	return 1;
}

/*
 * new_fp:
 *	Return a pointer to an initialized new FILEDESC.
 */
FILEDESC *
new_fp(void)
{
	FILEDESC	*fp;

	if ((fp = malloc(sizeof *fp)) == NULL)
		err(1, NULL);
	fp->datfd = -1;
	fp->pos = POS_UNKNOWN;
	fp->inf = NULL;
	fp->fd = -1;
	fp->percent = NO_PROB;
	fp->read_tbl = 0;
	fp->next = NULL;
	fp->prev = NULL;
	fp->child = NULL;
	fp->parent = NULL;
	fp->datfile = NULL;
	return fp;
}

/*
 * off_name:
 *	Return a pointer to the offensive version of a file of this name.
 */
char *
off_name(char *file)
{
	return (copy(file, "-o"));
}

/*
 * is_off_name:
 *	Is the file an offensive-style name?
 */
int
is_off_name(char *file)
{
	int	len;

	len = strlen(file);
	return (len >= 3 && file[len - 2] == '-' && file[len - 1] == 'o');
}

/*
 * all_forts:
 *	Modify a FILEDESC element to be the parent of two children if
 *	there are two children to be a parent of.
 */
void
all_forts(FILEDESC *fp, char *offensive)
{
	char		*sp;
	FILEDESC	*scene, *obscene;
	int		fd;
	char		*datfile;

	if (fp->child != NULL)	/* this is a directory, not a file */
		return;
	if (!is_fortfile(offensive, &datfile, 0))
		return;
	if ((fd = open(offensive, O_RDONLY)) < 0)
		return;
	DPRINTF(1, (stderr, "adding \"%s\" because of -a\n", offensive));
	scene = new_fp();
	obscene = new_fp();
	*scene = *fp;

	fp->num_children = 2;
	fp->child = scene;
	scene->next = obscene;
	obscene->next = NULL;
	scene->child = obscene->child = NULL;
	scene->parent = obscene->parent = fp;

	fp->fd = -1;
	scene->percent = obscene->percent = NO_PROB;

	obscene->fd = fd;
	obscene->inf = NULL;
	obscene->path = offensive;
	if ((sp = strrchr(offensive, '/')) == NULL)
		obscene->name = offensive;
	else
		obscene->name = ++sp;
	obscene->datfile = datfile;
	obscene->read_tbl = 0;
}

/*
 * add_dir:
 *	Add the contents of an entire directory.
 */
int
add_dir(FILEDESC *fp)
{
	DIR		*dir;
	struct dirent  *dirent;
	FILEDESC	*tailp;
	char		*name;

	(void) close(fp->fd);
	fp->fd = -1;
	if ((dir = opendir(fp->path)) == NULL) {
		perror(fp->path);
		return 0;
	}
	tailp = NULL;
	DPRINTF(1, (stderr, "adding dir \"%s\"\n", fp->path));
	fp->num_children = 0;
	while ((dirent = readdir(dir)) != NULL) {
		if (dirent->d_namlen == 0)
			continue;
		name = copy(dirent->d_name, NULL);
		if (add_file(NO_PROB, name, fp->path, &fp->child, &tailp, fp))
			fp->num_children++;
		else
			free(name);
	}
	if (fp->num_children == 0) {
		(void) fprintf(stderr,
		    "fortune: %s: No fortune files in directory.\n", fp->path);
		closedir(dir);
		return 0;
	}
	closedir(dir);
	return 1;
}

/*
 * is_dir:
 *	Return 1 if the file is a directory, 0 otherwise.
 */
int
is_dir(char *file)
{
	struct stat	sbuf;

	if (stat(file, &sbuf) < 0)
		return 0;
	return S_ISDIR(sbuf.st_mode);
}

/*
 * is_fortfile:
 *	Return 1 if the file is a fortune database file.  We try and
 *	exclude files without reading them if possible to avoid
 *	overhead.  Files which start with ".", or which have "illegal"
 *	suffixes, as contained in suflist[], are ruled out.
 */
int
is_fortfile(char *file, char **datp, int check_for_offend)
{
	int	i;
	char	*sp;
	char	*datfile;
	static char	*suflist[] = {	/* list of "illegal" suffixes" */
				"dat", "pos", "c", "h", "p", "i", "f",
				"pas", "ftn", "ins.c", "ins,pas",
				"ins.ftn", "sml",
				NULL
			};

	DPRINTF(2, (stderr, "is_fortfile(%s) returns ", file));

	/*
	 * Preclude any -o files for offendable people, and any non -o
	 * files for completely offensive people.
	 */
	if (check_for_offend && !All_forts) {
		i = strlen(file);
		if (Offend ^ (file[i - 2] == '-' && file[i - 1] == 'o'))
			return 0;
	}

	if ((sp = strrchr(file, '/')) == NULL)
		sp = file;
	else
		sp++;
	if (*sp == '.') {
		DPRINTF(2, (stderr, "0 (file starts with '.')\n"));
		return 0;
	}
	if ((sp = strrchr(sp, '.')) != NULL) {
		sp++;
		for (i = 0; suflist[i] != NULL; i++)
			if (strcmp(sp, suflist[i]) == 0) {
				DPRINTF(2, (stderr, "0 (file has suffix \".%s\")\n", sp));
				return 0;
			}
	}

	datfile = copy(file, ".dat");
	if (access(datfile, R_OK) < 0) {
		free(datfile);
		DPRINTF(2, (stderr, "0 (no \".dat\" file)\n"));
		return 0;
	}
	if (datp != NULL)
		*datp = datfile;
	else
		free(datfile);
	DPRINTF(2, (stderr, "1\n"));
	return 1;
}

/*
 * copy:
 *	Return a malloc()'ed copy of the string + an optional suffix
 */
char *
copy(char *str, char *suf)
{
	char	*new;

	if (asprintf(&new, "%s%s", str, suf ? suf : "") == -1)
		return NULL;
	return new;
}

/*
 * init_prob:
 *	Initialize the fortune probabilities.
 */
void
init_prob(void)
{
	FILEDESC	*fp, *last;
	int		percent, num_noprob, frac;

	/*
	 * Distribute the residual probability (if any) across all
	 * files with unspecified probability (i.e., probability of 0)
	 * (if any).
	 */

	percent = 0;
	num_noprob = 0;
	for (fp = File_tail; fp != NULL; fp = fp->prev)
		if (fp->percent == NO_PROB) {
			num_noprob++;
			if (Equal_probs)
				last = fp;
		}
		else
			percent += fp->percent;
	DPRINTF(1, (stderr, "summing probabilities:%d%% with %d NO_PROB's",
		    percent, num_noprob));
	if (percent > 100) {
		(void) fprintf(stderr,
		    "fortune: probabilities sum to %d%%!\n", percent);
		exit(1);
	}
	else if (percent < 100 && num_noprob == 0) {
		(void) fprintf(stderr,
		    "fortune: no place to put residual probability (%d%%)\n",
		    percent);
		exit(1);
	}
	else if (percent == 100 && num_noprob != 0) {
		(void) fprintf(stderr,
		    "fortune: no probability left to put in residual files\n");
		exit(1);
	}
	percent = 100 - percent;
	if (Equal_probs) {
		if (num_noprob != 0) {
			if (num_noprob > 1) {
				frac = percent / num_noprob;
				DPRINTF(1, (stderr, ", frac = %d%%", frac));
				for (fp = File_list; fp != last; fp = fp->next)
					if (fp->percent == NO_PROB) {
						fp->percent = frac;
						percent -= frac;
					}
			}
			last->percent = percent;
			DPRINTF(1, (stderr, ", residual = %d%%", percent));
		}
	} else {
		DPRINTF(1, (stderr,
			    ", %d%% distributed over remaining fortunes\n",
			    percent));
	}
	DPRINTF(1, (stderr, "\n"));

#ifdef DEBUG
	if (Debug >= 1)
		print_file_list();
#endif
}

/*
 * get_fort:
 *	Get the fortune data file's seek pointer for the next fortune.
 */
void
get_fort(void)
{
	FILEDESC	*fp;
	int		choice;

	if (File_list->next == NULL || File_list->percent == NO_PROB)
		fp = File_list;
	else {
		choice = arc4random_uniform(100);
		DPRINTF(1, (stderr, "choice = %d\n", choice));
		for (fp = File_list; fp->percent != NO_PROB; fp = fp->next)
			if (choice < fp->percent)
				break;
			else {
				choice -= fp->percent;
				DPRINTF(1, (stderr,
					    "    skip \"%s\", %d%% (choice = %d)\n",
					    fp->name, fp->percent, choice));
			}
			DPRINTF(1, (stderr,
				    "using \"%s\", %d%% (choice = %d)\n",
				    fp->name, fp->percent, choice));
	}
	if (fp->percent != NO_PROB)
		get_tbl(fp);
	else {
		if (fp->next != NULL) {
			sum_noprobs(fp);
			choice = arc4random_uniform(Noprob_tbl.str_numstr);
			DPRINTF(1, (stderr, "choice = %d (of %d) \n", choice,
				    Noprob_tbl.str_numstr));
			while (choice >= fp->tbl.str_numstr) {
				choice -= fp->tbl.str_numstr;
				fp = fp->next;
				DPRINTF(1, (stderr,
					    "    skip \"%s\", %d (choice = %d)\n",
					    fp->name, fp->tbl.str_numstr,
					    choice));
			}
			DPRINTF(1, (stderr, "using \"%s\", %d\n", fp->name,
				    fp->tbl.str_numstr));
		}
		get_tbl(fp);
	}
	if (fp->child != NULL) {
		DPRINTF(1, (stderr, "picking child\n"));
		fp = pick_child(fp);
	}
	Fortfile = fp;
	get_pos(fp);
	open_dat(fp);
	(void) lseek(fp->datfd,
		     (off_t) (sizeof fp->tbl + fp->pos * sizeof Seekpts[0]), 0);
	read(fp->datfd, &Seekpts[0], sizeof Seekpts[0]);
	Seekpts[0] = ntohl(Seekpts[0]);
	read(fp->datfd, &Seekpts[1], sizeof Seekpts[1]);
	Seekpts[1] = ntohl(Seekpts[1]);
}

/*
 * pick_child
 *	Pick a child from a chosen parent.
 */
FILEDESC *
pick_child(FILEDESC *parent)
{
	FILEDESC	*fp;
	int		choice;

	if (Equal_probs) {
		choice = arc4random_uniform(parent->num_children);
		DPRINTF(1, (stderr, "    choice = %d (of %d)\n",
			    choice, parent->num_children));
		for (fp = parent->child; choice--; fp = fp->next)
			continue;
		DPRINTF(1, (stderr, "    using %s\n", fp->name));
		return fp;
	}
	else {
		get_tbl(parent);
		choice = arc4random_uniform(parent->tbl.str_numstr);
		DPRINTF(1, (stderr, "    choice = %d (of %d)\n",
			    choice, parent->tbl.str_numstr));
		for (fp = parent->child; choice >= fp->tbl.str_numstr;
		     fp = fp->next) {
			choice -= fp->tbl.str_numstr;
			DPRINTF(1, (stderr, "\tskip %s, %d (choice = %d)\n",
				    fp->name, fp->tbl.str_numstr, choice));
		}
		DPRINTF(1, (stderr, "    using %s, %d\n", fp->name,
			    fp->tbl.str_numstr));
		return fp;
	}
}

/*
 * sum_noprobs:
 *	Sum up all the noprob probabilities, starting with fp.
 */
void
sum_noprobs(FILEDESC *fp)
{
	static bool	did_noprobs = 0;

	if (did_noprobs)
		return;
	zero_tbl(&Noprob_tbl);
	while (fp != NULL) {
		get_tbl(fp);
		sum_tbl(&Noprob_tbl, &fp->tbl);
		fp = fp->next;
	}
	did_noprobs = 1;
}

int
max(int i, int j)
{
	return (i >= j ? i : j);
}

/*
 * open_fp:
 *	Assocatiate a FILE * with the given FILEDESC.
 */
void
open_fp(FILEDESC *fp)
{
	if (fp->inf == NULL && (fp->inf = fdopen(fp->fd, "r")) == NULL) {
		perror(fp->path);
		exit(1);
	}
}

/*
 * open_dat:
 *	Open up the dat file if we need to.
 */
void
open_dat(FILEDESC *fp)
{
	if (fp->datfd < 0 && (fp->datfd = open(fp->datfile, O_RDONLY)) < 0) {
		perror(fp->datfile);
		exit(1);
	}
}

/*
 * get_pos:
 *	Get the position from the pos file, if there is one.  If not,
 *	return a random number.
 */
void
get_pos(FILEDESC *fp)
{
	assert(fp->read_tbl);
	if (fp->pos == POS_UNKNOWN) {
		fp->pos = arc4random_uniform(fp->tbl.str_numstr);
	}
	if (++(fp->pos) >= fp->tbl.str_numstr)
		fp->pos -= fp->tbl.str_numstr;
	DPRINTF(1, (stderr, "pos for %s is %d\n", fp->name, fp->pos));
}

/*
 * get_tbl:
 *	Get the tbl data file the datfile.
 */
void
get_tbl(FILEDESC *fp)
{
	int		fd;
	FILEDESC	*child;

	if (fp->read_tbl)
		return;
	if (fp->child == NULL) {
		if ((fd = open(fp->datfile, O_RDONLY)) < 0) {
			perror(fp->datfile);
			exit(1);
		}
		if (read(fd, &fp->tbl.str_version,  sizeof(fp->tbl.str_version)) !=
		    sizeof(fp->tbl.str_version)) {
			(void)fprintf(stderr,
			    "fortune: %s corrupted\n", fp->path);
			exit(1);
		}
		if (read(fd, &fp->tbl.str_numstr,   sizeof(fp->tbl.str_numstr)) !=
		    sizeof(fp->tbl.str_numstr)) {
			(void)fprintf(stderr,
			    "fortune: %s corrupted\n", fp->path);
			exit(1);
		}
		if (read(fd, &fp->tbl.str_longlen,  sizeof(fp->tbl.str_longlen)) !=
		    sizeof(fp->tbl.str_longlen)) {
			(void)fprintf(stderr,
			    "fortune: %s corrupted\n", fp->path);
			exit(1);
		}
		if (read(fd, &fp->tbl.str_shortlen, sizeof(fp->tbl.str_shortlen)) !=
		    sizeof(fp->tbl.str_shortlen)) {
			(void)fprintf(stderr,
			    "fortune: %s corrupted\n", fp->path);
			exit(1);
		}
		if (read(fd, &fp->tbl.str_flags,    sizeof(fp->tbl.str_flags)) !=
		    sizeof(fp->tbl.str_flags)) {
			(void)fprintf(stderr,
			    "fortune: %s corrupted\n", fp->path);
			exit(1);
		}
		if (read(fd, fp->tbl.stuff,	    sizeof(fp->tbl.stuff)) !=
		    sizeof(fp->tbl.stuff)) {
			(void)fprintf(stderr,
			    "fortune: %s corrupted\n", fp->path);
			exit(1);
		}

		/* fp->tbl.str_version = ntohl(fp->tbl.str_version); */
		fp->tbl.str_numstr = ntohl(fp->tbl.str_numstr);
		fp->tbl.str_longlen = ntohl(fp->tbl.str_longlen);
		fp->tbl.str_shortlen = ntohl(fp->tbl.str_shortlen);
		fp->tbl.str_flags = ntohl(fp->tbl.str_flags);
		(void) close(fd);

		if (fp->tbl.str_numstr == 0) {
			fprintf(stderr, "fortune: %s is empty\n", fp->path);
			exit(1);
		}
	}
	else {
		zero_tbl(&fp->tbl);
		for (child = fp->child; child != NULL; child = child->next) {
			get_tbl(child);
			sum_tbl(&fp->tbl, &child->tbl);
		}
	}
	fp->read_tbl = 1;
}

/*
 * zero_tbl:
 *	Zero out the fields we care about in a tbl structure.
 */
void
zero_tbl(STRFILE *tp)
{
	tp->str_numstr = 0;
	tp->str_longlen = 0;
	tp->str_shortlen = -1;
}

/*
 * sum_tbl:
 *	Merge the tbl data of t2 into t1.
 */
void
sum_tbl(STRFILE *t1, STRFILE *t2)
{
	t1->str_numstr += t2->str_numstr;
	if (t1->str_longlen < t2->str_longlen)
		t1->str_longlen = t2->str_longlen;
	if (t1->str_shortlen > t2->str_shortlen)
		t1->str_shortlen = t2->str_shortlen;
}

#define	STR(str)	((str) == NULL ? "NULL" : (str))

/*
 * print_file_list:
 *	Print out the file list
 */
void
print_file_list(void)
{
	print_list(File_list, 0);
}

/*
 * print_list:
 *	Print out the actual list, recursively.
 */
void
print_list(FILEDESC *list, int lev)
{
	while (list != NULL) {
		fprintf(stderr, "%*s", lev * 4, "");
		if (list->percent == NO_PROB)
			fprintf(stderr, "___%%");
		else
			fprintf(stderr, "%3d%%", list->percent);
		fprintf(stderr, " %s", STR(list->name));
		DPRINTF(1, (stderr, " (%s, %s)\n", STR(list->path),
			    STR(list->datfile)));
		putc('\n', stderr);
		if (list->child != NULL)
			print_list(list->child, lev + 1);
		list = list->next;
	}
}


/*
 * find_matches:
 *	Find all the fortunes which match the pattern we've been given.
 */
int
find_matches(void)
{
	Fort_len = maxlen_in_list(File_list);
	DPRINTF(2, (stderr, "Maximum length is %zu\n", Fort_len));
	/* extra length, "%\n" is appended */
	if ((Fortbuf = malloc(Fort_len + 10)) == NULL)
		err(1, NULL);

	Found_one = 0;
	matches_in_list(File_list);
	return Found_one;
}

/*
 * maxlen_in_list
 *	Return the maximum fortune len in the file list.
 */
int
maxlen_in_list(FILEDESC *list)
{
	FILEDESC	*fp;
	int		len, maxlen;

	maxlen = 0;
	for (fp = list; fp != NULL; fp = fp->next) {
		if (fp->child != NULL) {
			if ((len = maxlen_in_list(fp->child)) > maxlen)
				maxlen = len;
		}
		else {
			get_tbl(fp);
			if (fp->tbl.str_longlen > maxlen)
				maxlen = fp->tbl.str_longlen;
		}
	}
	return maxlen;
}

/*
 * minlen_in_list
 *	Return the minimum fortune len in the file list.
 */
int
minlen_in_list(FILEDESC *list)
{
	FILEDESC	*fp;
	int		len, minlen;

	minlen = INT_MAX;
	for (fp = list; fp != NULL; fp = fp->next) {
		if (fp->child != NULL) {
			if ((len = minlen_in_list(fp->child)) < minlen)
				minlen = len;
		} else {
			get_tbl(fp);
			if (fp->tbl.str_shortlen < minlen)
				minlen = fp->tbl.str_shortlen;
		}
	}
	return minlen;
}

/*
 * matches_in_list
 *	Print out the matches from the files in the list.
 */
void
matches_in_list(FILEDESC *list)
{
	char		*sp;
	FILEDESC	*fp;
	int			in_file;

	for (fp = list; fp != NULL; fp = fp->next) {
		if (fp->child != NULL) {
			matches_in_list(fp->child);
			continue;
		}
		DPRINTF(1, (stderr, "searching in %s\n", fp->path));
		open_fp(fp);
		sp = Fortbuf;
		in_file = 0;
		while (fgets(sp, Fort_len, fp->inf) != NULL)
			if (!STR_ENDSTRING(sp, fp->tbl))
				sp += strlen(sp);
			else {
				*sp = '\0';
				if (fp->tbl.str_flags & STR_ROTATED)
					rot13(Fortbuf, sp - Fortbuf);
				if (regexec(&regex, Fortbuf, 0, NULL, 0) == 0) {
					printf("%c%c", fp->tbl.str_delim,
					    fp->tbl.str_delim);
					if (!in_file) {
						printf(" (%s)", fp->name);
						Found_one = 1;
						in_file = 1;
					}
					putchar('\n');
					(void) fwrite(Fortbuf, 1, (sp - Fortbuf), stdout);
				}
				sp = Fortbuf;
			}
	}
}

void
usage(void)
{
	(void) fprintf(stderr, "usage: fortune [-ae");
#ifdef	DEBUG
	(void) fprintf(stderr, "D");
#endif	/* DEBUG */
	(void) fprintf(stderr, "f");
	(void) fprintf(stderr, "i");
	(void) fprintf(stderr, "losw]");
	(void) fprintf(stderr, " [-m pattern]");
	(void) fprintf(stderr, " [[N%%] file/directory/all]\n");
	exit(1);
}
@


1.54
log
@Remove unused fields posfile and was_pos_file from FILEDESC and
simplify is_fortfile() accordingly.
The last use of them was guarded by OK_TO_WRITE_DISK, which was
unifdef'ed in revision 1.43 last fall.

tweak + ok mestre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.53 2016/03/07 12:07:56 mestre Exp $	*/
a115 2
void	 do_free(void *);
void	*do_malloc(size_t);
d385 2
a386 5
		size_t len;

		len = strlen(dir) + strlen(file) + 2;
		path = do_malloc(len);
		snprintf(path, len, "%s/%s", dir, file);
d457 1
a457 1
		do_free(fp->datfile);
d459 1
a459 1
		do_free(offensive);
d495 2
a496 1
	fp = do_malloc(sizeof *fp);
a710 27
 * do_malloc:
 *	Do a malloc, checking for NULL return.
 */
void *
do_malloc(size_t size)
{
	void	*new;

	if ((new = malloc(size)) == NULL) {
		(void) fprintf(stderr, "fortune: out of memory.\n");
		exit(1);
	}
	return new;
}

/*
 * do_free:
 *	Free malloc'ed space, if any.
 */
void
do_free(void *ptr)
{
	if (ptr != NULL)
		free(ptr);
}

/*
d1099 2
a1100 1
	Fortbuf = do_malloc(Fort_len + 10);
@


1.53
log
@- General changes:
- Remove -? from getopt(3) options, but still keep (or add) -h where applicable
- Replace hardcoded program strings by getprogname(3)

- Specific changes:
- atc(6): this used -? and -u for usage(), remove both from game and manpage
- bcd(6): use __progname instead of getprogname(3), no need to include stdlib.h
- hunt(6): replace fputs(3) by fprintf(3)

OK tb@@ after his suggestions
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.52 2016/03/05 11:06:43 tb Exp $	*/
d77 1
a77 1
	char		*datfile, *posfile;
a78 1
	bool		was_pos_file;
d126 1
a126 1
int	 is_fortfile(char *, char **, char **, int);
d454 1
a454 1
	     !is_fortfile(path, &fp->datfile, &fp->posfile, (parent != NULL))))
a462 1
		do_free(fp->posfile);
a511 1
	fp->posfile = NULL;
d549 1
a549 1
	char		*datfile, *posfile;
d553 1
a553 1
	if (!is_fortfile(offensive, &datfile, &posfile, 0))
a579 1
	obscene->posfile = posfile;
d645 1
a645 1
is_fortfile(char *file, char **datp, char **posp, int check_for_offend)
d1110 2
a1111 2
		DPRINTF(1, (stderr, " (%s, %s, %s)\n", STR(list->path),
			    STR(list->datfile), STR(list->posfile)));
@


1.52
log
@Convert a hand-rolled strtonum to a call to strtonum(3). This prevents
integer overflow on bogus input and bizarre error messages. Moreover,
fortune files can now be named anything except names matching the regex
^[0-9][0-9.]*%$

ok mestre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.51 2016/01/10 13:35:09 mestre Exp $	*/
d250 1
a250 1
	while ((ch = getopt(argc, argv, "aDefilm:osw")) != -1)
d252 1
a252 1
	while ((ch = getopt(argc, argv, "aefilm:osw")) != -1)
d290 1
a290 1
		case '?':
@


1.51
log
@As per style(9), remove remaining lint-style comments from games/

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.50 2016/01/07 16:00:32 tb Exp $	*/
d41 1
d334 4
a337 14
		if (!isdigit((unsigned char)files[i][0]))
			sp = files[i];
		else {
			percent = 0;
			for (sp = files[i]; isdigit((unsigned char)*sp); sp++)
				percent = percent * 10 + *sp - '0';
			if (percent > 100) {
				fprintf(stderr, "percentages must be <= 100\n");
				return 0;
			}
			if (*sp == '.') {
				fprintf(stderr, "percentages must be integers\n");
				return 0;
			}
d339 2
a340 3
			 * If the number isn't followed by a '%', then
			 * it was not a percentage, just the first part
			 * of a file name which starts with digits.
d342 17
a358 10
			if (*sp != '%') {
				percent = NO_PROB;
				sp = files[i];
			}
			else if (*++sp == '\0') {
				if (++i >= file_cnt) {
					fprintf(stderr, "percentages must precede files\n");
					return 0;
				}
				sp = files[i];
d361 1
@


1.50
log
@Some basic code maintenance in games/

- in main() replace exit with return
- drop some /* NOTREACHED */ lint comments along the way.
- make more use of standard CFLAGS, esp. -Wimplicit-function-declaration
- add and sort some headers when needed
- add straightforward pledges to some programs used at compile time

discussed with and ok mestre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.49 2016/01/04 11:58:35 mestre Exp $	*/
a649 1
/* ARGSUSED */
@


1.49
log
@More headers removal and sorted the remaining alphabetically.

Most noticeable that were removed are sys/types.h which will be included from
stdlib.h and in turn also brings along sys/cdefs.h. The other one is limits.h
that was used with the old idiom (denom * random() / LONG_MAX), although it was
only removed were applicable (some files still need that header).

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.48 2015/12/25 20:59:09 mestre Exp $	*/
d155 1
a155 1
		exit(1);
d161 1
a161 1
		exit(find_matches() != 0);
d166 1
a166 1
		exit(0);
d180 1
a180 1
	exit(0);
@


1.48
log
@Declare usage() functions as __dead void, if they don't return, on games section.

Found another one in arithmetic(6) which also didn't return, and removed a function from number(6) which is not used anymore.

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.47 2015/11/10 15:29:11 deraadt Exp $	*/
d38 2
d42 1
a42 2
#include <assert.h>
#include <unistd.h>
a43 1
#include <ctype.h>
a45 1
#include <limits.h>
d47 3
a50 1
#include "pathnames.h"
@


1.47
log
@another open(path, 0)...
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.46 2015/11/10 14:56:50 deraadt Exp $	*/
d139 1
a139 1
void	 usage(void);
@


1.46
log
@pledge "stdio rpath" at the top.  (Ricardo's 2nd chunk which reduces
further is not placed right, so I ignored it for now)
from Ricardo Mestre
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.45 2015/11/10 14:50:04 deraadt Exp $	*/
d965 1
a965 1
	if (fp->datfd < 0 && (fp->datfd = open(fp->datfile, 0)) < 0) {
@


1.45
log
@replace open(path, 0) with open(path, O_RDONLY).  amazing to still find
sloppiness like this.
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.44 2015/10/24 18:02:28 mmcc Exp $	*/
d152 5
@


1.44
log
@Cast isdigit()'s argument to unsigned char.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.43 2015/08/26 14:49:20 semarie Exp $	*/
d411 1
a411 1
	if ((fd = open(path, 0)) < 0) {
d554 1
a554 1
	if ((fd = open(offensive, 0)) < 0)
d996 1
a996 1
		if ((fd = open(fp->datfile, 0)) < 0) {
@


1.43
log
@remove #ifdef OK_TO_WRITE_DISK which isn't used by default.
and few disambiguisations suggested by cc(1)
  - parentheses around && within ||
  - explicit braces to avoid ambiguous 'else'

ok doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.42 2015/02/06 10:50:48 tedu Exp $	*/
d327 1
a327 1
		if (!isdigit(files[i][0]))
d331 1
a331 1
			for (sp = files[i]; isdigit(*sp); sp++)
@


1.42
log
@unsigned char is the correct type for ctype functions
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.41 2015/02/06 10:49:32 tedu Exp $	*/
a151 4
#ifdef	OK_TO_WRITE_DISK
	int	fd;
#endif	/* OK_TO_WRITE_DISK */

d158 2
a159 2
	if (Short_only && minlen_in_list(File_list) > SLEN ||
	    Long_only && maxlen_in_list(File_list) <= SLEN)
a168 18
#ifdef	OK_TO_WRITE_DISK
	if ((fd = creat(Fortfile->posfile, 0666)) < 0) {
		perror(Fortfile->posfile);
		exit(1);
	}
	/*
	 * if we can, we exclusive lock, but since it isn't very
	 * important, we just punt if we don't have easy locking
	 * available.
	 */
	(void) flock(fd, LOCK_EX);
	Fortfile->pos = htonl(Fortfile->pos);
	write(fd, (char *) &Fortfile->pos, sizeof Fortfile->pos);
	Fortfile->pos = ntohl(Fortfile->pos);
	if (!Fortfile->was_pos_file)
		(void) chmod(Fortfile->path, 0666);
	(void) flock(fd, LOCK_UN);
#endif	/* OK_TO_WRITE_DISK */
a192 1
	char	*p, ch;
d317 1
a317 1
	if (file_cnt == 0)
d324 1
a484 3
#ifdef	OK_TO_WRITE_DISK
	fp->was_pos_file = (access(fp->posfile, W_OK) >= 0);
#endif	/* OK_TO_WRITE_DISK */
a580 3
#ifdef	OK_TO_WRITE_DISK
	obscene->was_pos_file = (access(obscene->posfile, W_OK) >= 0);
#endif	/* OK_TO_WRITE_DISK */
a696 4
#ifdef	OK_TO_WRITE_DISK
	if (posp != NULL)
		*posp = copy(file, ".pos");
#endif	/* OK_TO_WRITE_DISK */
d787 1
a787 1
	if (Equal_probs)
d801 1
a801 1
	else {
a973 4
#ifdef	OK_TO_WRITE_DISK
	int	fd;
#endif /* OK_TO_WRITE_DISK */

a975 11
#ifdef	OK_TO_WRITE_DISK
		if ((fd = open(fp->posfile, 0)) < 0 ||
		    read(fd, &fp->pos, sizeof fp->pos) != sizeof fp->pos)
			fp->pos = arc4random_uniform(fp->tbl.str_numstr);
		else if (ntohl(fp->pos) >= fp->tbl.str_numstr)
			fp->pos %= fp->tbl.str_numstr;
		else
			fp->pos = ntohl(fp->pos);
		if (fd >= 0)
			(void) close(fd);
#else
a976 1
#endif /* OK_TO_WRITE_DISK */
@


1.41
log
@no space after #
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.40 2015/02/06 10:46:52 tedu Exp $	*/
d203 1
a203 1
		char ch = *p;
@


1.40
log
@remove TRUE/FALSE in favor of the true boolean values 1/0
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.39 2015/02/06 10:26:06 tedu Exp $	*/
d36 1
a36 1
# include	<sys/stat.h>
d38 29
a66 29
# include	<dirent.h>
# include	<fcntl.h>
# include	<assert.h>
# include	<unistd.h>
# include	<stdio.h>
# include	<ctype.h>
# include	<stdlib.h>
# include	<string.h>
# include	<limits.h>
# include	<regex.h>
# include	"strfile.h"
# include	"pathnames.h"

# define	bool	short

# define	MINW	6		/* minimum wait if desired */
# define	CPERS	20		/* # of chars for each sec */
# define	SLEN	160		/* # of chars in short fortune */

# define	POS_UNKNOWN	((int32_t) -1)	/* pos for file unknown */
# define	NO_PROB		(-1)		/* no prob specified for file */

# ifdef DEBUG
# define	DPRINTF(l,x)	if (Debug >= l) fprintf x; else
# undef		NDEBUG
# else
# define	DPRINTF(l,x)
# define	NDEBUG	1
# endif
d265 1
a265 1
# ifdef DEBUG
d274 1
a274 1
# ifdef DEBUG
d278 1
a278 1
# endif /* DEBUG */
d394 1
a394 1
         FILEDESC *parent)
@


1.39
log
@Debug, whatever it's worth, is clearly not a boolean
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.38 2015/02/06 10:25:32 tedu Exp $	*/
a50 2
# define	TRUE	1
# define	FALSE	0
d85 8
a92 8
bool	Find_files	= FALSE;	/* just find a list of proper fortune files */
bool	Wait		= FALSE;	/* wait desired after fortune */
bool	Short_only	= FALSE;	/* short fortune desired */
bool	Long_only	= FALSE;	/* long fortune desired */
bool	Offend		= FALSE;	/* offensive fortunes only */
bool	All_forts	= FALSE;	/* any fortune allowed */
bool	Equal_probs	= FALSE;	/* scatter un-allocted prob equally */
bool	Match		= FALSE;	/* dump fortunes matching a pattern */
d94 1
a94 1
int	Debug = FALSE;			/* print debug messages */
d263 1
a263 1
	ignore_case = FALSE;
d272 1
a272 1
			All_forts = TRUE;
d280 1
a280 1
			Equal_probs = TRUE;	/* scatter un-allocted prob equally */
d283 1
a283 1
			Find_files = TRUE;
d286 2
a287 2
			Long_only = TRUE;
			Short_only = FALSE;
d290 1
a290 1
			Offend = TRUE;
d293 2
a294 2
			Short_only = TRUE;
			Long_only = FALSE;
d297 1
a297 1
			Wait = TRUE;
d300 1
a300 1
			Match = TRUE;
d304 1
a304 1
			ignore_case = TRUE;
d357 1
a357 1
				return FALSE;
d361 1
a361 1
				return FALSE;
d375 1
a375 1
					return FALSE;
d383 1
a383 1
			return FALSE;
d385 1
a385 1
	return TRUE;
d404 1
a404 1
		was_malloc = FALSE;
d411 1
a411 1
		was_malloc = TRUE;
d416 1
a416 1
		return FALSE;	/* don't recurse */
d427 1
a427 1
			was_malloc = TRUE;
d447 1
a447 1
			was_malloc = TRUE;
d459 1
a459 1
		return FALSE;
d485 1
a485 1
		return FALSE;
d511 1
a511 1
	return TRUE;
d529 1
a529 1
	fp->read_tbl = FALSE;
d577 1
a577 1
	if (!is_fortfile(offensive, &datfile, &posfile, FALSE))
d605 1
a605 1
	obscene->read_tbl = FALSE;
d627 1
a627 1
		return FALSE;
d645 1
a645 1
		return FALSE;
d648 1
a648 1
	return TRUE;
d653 1
a653 1
 *	Return TRUE if the file is a directory, FALSE otherwise.
d661 1
a661 1
		return FALSE;
d667 1
a667 1
 *	Return TRUE if the file is a fortune database file.  We try and
d695 1
a695 1
			return FALSE;
d703 2
a704 2
		DPRINTF(2, (stderr, "FALSE (file starts with '.')\n"));
		return FALSE;
d710 2
a711 2
				DPRINTF(2, (stderr, "FALSE (file has suffix \".%s\")\n", sp));
				return FALSE;
d718 2
a719 2
		DPRINTF(2, (stderr, "FALSE (no \".dat\" file)\n"));
		return FALSE;
d729 2
a730 2
	DPRINTF(2, (stderr, "TRUE\n"));
	return TRUE;
d953 1
a953 1
	static bool	did_noprobs = FALSE;
d963 1
a963 1
	did_noprobs = TRUE;
d1104 1
a1104 1
	fp->read_tbl = TRUE;
d1181 1
a1181 1
	Found_one = FALSE;
d1254 1
a1254 1
		in_file = FALSE;
d1267 2
a1268 2
						Found_one = TRUE;
						in_file = TRUE;
@


1.38
log
@cleanup a few bits
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.37 2015/02/06 10:18:51 tedu Exp $	*/
d96 1
a96 1
bool	Debug = FALSE;			/* print debug messages */
@


1.37
log
@remove no regex ifdef. everybody loves regex.
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.36 2015/02/06 10:17:56 tedu Exp $	*/
a179 1
#ifdef	LOCK_EX
a185 1
#endif	/* LOCK_EX */
a190 1
#ifdef	LOCK_EX
a191 1
#endif	/* LOCK_EX */
a198 1
	/* NOTREACHED */
a1185 1
	/* NOTREACHED */
@


1.36
log
@use regcomp native case insensitive matching facility instead of
faking it poorly
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.35 2015/02/06 10:12:57 tedu Exp $	*/
a93 1
#ifndef NO_REGEX
a94 1
#endif
a143 1
#ifndef	NO_REGEX
a149 1
#endif
a159 1
#ifndef NO_REGEX
a161 1
#endif
a266 1
# ifndef NO_REGEX
a267 1
# endif	/* NO_REGEX */
a305 7
# ifdef	NO_REGEX
		case 'i':			/* case-insensitive match */
		case 'm':			/* dump out the fortunes */
			(void) fprintf(stderr,
			    "fortune: can't match fortunes on this system (Sorry)\n");
			exit(0);
# else	/* NO_REGEX */
a312 1
# endif	/* NO_REGEX */
a330 1
# ifndef NO_REGEX
a334 1
# endif	/* NO_REGEX */
a1174 1
#ifndef	NO_REGEX
a1284 1
# endif	/* NO_REGEX */
a1293 1
#ifndef	NO_REGEX
a1294 1
#endif	/* NO_REGEX */
a1295 1
#ifndef	NO_REGEX
a1296 1
#endif	/* NO_REGEX */
@


1.35
log
@don't set a flag with ++; it's a bool, not a counter.
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.34 2015/02/06 10:04:18 tedu Exp $	*/
d349 1
a349 3
		if (ignore_case)
			pat = conv_pat(pat);
		if (regcomp(&regex, pat, 0)) {
a350 1
		}
a1193 41
/*
 * conv_pat:
 *	Convert the pattern to an ignore-case equivalent.
 */
char *
conv_pat(char *orig)
{
	char		*sp;
	unsigned int	cnt;
	char		*new;

	cnt = 1;	/* allow for '\0' */
	for (sp = orig; *sp != '\0'; sp++)
		if (isalpha(*sp))
			cnt += 4;
		else
			cnt++;
	if ((new = malloc(cnt)) == NULL) {
		fprintf(stderr, "pattern too long for ignoring case\n");
		exit(1);
	}

	for (sp = new; *orig != '\0'; orig++) {
		if (islower(*orig)) {
			*sp++ = '[';
			*sp++ = *orig;
			*sp++ = toupper(*orig);
			*sp++ = ']';
		}
		else if (isupper(*orig)) {
			*sp++ = '[';
			*sp++ = *orig;
			*sp++ = tolower(*orig);
			*sp++ = ']';
		}
		else
			*sp++ = *orig;
	}
	*sp = '\0';
	return new;
}
@


1.34
log
@change int to size_t to avoid integer overflow
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.33 2015/02/06 09:55:01 tedu Exp $	*/
d287 1
a287 1
			All_forts++;
d295 1
a295 1
			Equal_probs++;	/* scatter un-allocted prob equally */
d298 1
a298 1
			Find_files++;
d301 1
a301 1
			Long_only++;
d305 1
a305 1
			Offend++;
d308 1
a308 1
			Short_only++;
d312 1
a312 1
			Wait++;
d322 1
a322 1
			Match++;
d326 1
a326 1
			ignore_case++;
@


1.33
log
@fix searching and display of offensive fortunes.
now, if you want to find an offensive fortune about (e.g.) meat,
you can simply run:
$ fortune -o -m meat
This is much easier than the previous requirement to run a command like:
$ fortune -o -m `echo meat | rot13` | rot13
requested by guenther phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.32 2014/11/16 04:49:48 guenther Exp $	*/
d103 1
a103 1
int	Fort_len = 0;
d120 1
a120 1
void	*do_malloc(u_int);
d249 2
a250 2
	int	nchar;
	char		line[BUFSIZ];
d436 1
a436 1
		len = (unsigned int) (strlen(dir) + strlen(file) + 2);
d551 1
a551 1
	fp = (FILEDESC *) do_malloc(sizeof *fp);
d780 1
a780 1
do_malloc(unsigned int size)
d1247 1
a1247 1
	DPRINTF(2, (stderr, "Maximum length is %d\n", Fort_len));
d1249 1
a1249 1
	Fortbuf = do_malloc((unsigned int) Fort_len + 10);
@


1.32
log
@Eliminate pointless use of <sys/param.h>, <sys/file.h>, <sys/sockio.h>,
    and <sys/ttydefaults.h>
Replace MAXPATHLEN with PATH_MAX and MAXLOGNAME with LOGIN_NAME_MAX
Pull in <limits.h> where needed
Prefer sizeof(var) over MAXFOO or FOO_MAX

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.31 2014/01/11 06:28:46 guenther Exp $	*/
d213 13
d236 1
a236 5
			for (p = line; ch = *p; ++p)
				if (isupper(ch))
					*p = 'A' + (ch - 'A' + 13) % 26;
				else if (islower(ch))
					*p = 'a' + (ch - 'a' + 13) % 26;
d1331 2
@


1.31
log
@optarg/optind are declared in <unistd.h>, so kill the externs here
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.30 2011/01/03 17:38:24 jasper Exp $	*/
a35 1
# include	<sys/param.h>
@


1.30
log
@- plug mem leak.

ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.29 2010/07/02 23:43:42 tedu Exp $	*/
a267 2
	extern char *optarg;
	extern int optind;
@


1.29
log
@update to modern regex code and remove libcompat. ok deraadt phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.28 2009/10/27 23:59:24 deraadt Exp $	*/
d666 1
d669 1
@


1.28
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.27 2008/04/13 00:22:16 djm Exp $	*/
d48 1
d153 1
a153 17
#endif

#ifndef NO_REGEX
#ifdef REGCMP
# define	RE_COMP(p)	(Re_pat = regcmp(p, NULL))
# define	BAD_COMP(f)	((f) == NULL)
# define	RE_EXEC(p)	regex(Re_pat, (p))

char	*Re_pat;

char	*regcmp(), *regex();
#else
# define	RE_COMP(p)	(p = re_comp(p))
# define	BAD_COMP(f)	((f) != NULL)
# define	RE_EXEC(p)	re_exec(p)

#endif
d345 1
a345 4
		if (BAD_COMP(RE_COMP(pat))) {
#ifndef REGCMP
			fprintf(stderr, "%s\n", pat);
#else	/* REGCMP */
a346 1
#endif	/* REGCMP */
d1323 1
a1323 1
				if (RE_EXEC(Fortbuf)) {
@


1.27
log
@Use arc4random_buf() when requesting more than a single word of output

Use arc4random_uniform() when the desired random number upper bound
is not a power of two

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.26 2008/03/17 09:17:56 sobrado Exp $	*/
a34 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1986, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)fortune.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: fortune.c,v 1.26 2008/03/17 09:17:56 sobrado Exp $";
#endif
#endif /* not lint */
@


1.26
log
@synchronization between usage and synopsis; add some missing "usage:"'s

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.25 2007/09/10 14:29:53 tobias Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fortune.c,v 1.25 2007/09/10 14:29:53 tobias Exp $";
d912 1
a912 1
		choice = arc4random() % 100;
d932 1
a932 1
			choice = arc4random() % Noprob_tbl.str_numstr;
d974 1
a974 1
		choice = arc4random() % parent->num_children;
d984 1
a984 1
		choice = arc4random() % parent->tbl.str_numstr;
d1068 1
a1068 1
			fp->pos = arc4random() % fp->tbl.str_numstr;
d1076 1
a1076 1
		fp->pos = arc4random() % fp->tbl.str_numstr;
@


1.25
log
@Proper use of fseek/fseeko macros.

OK joris@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.24 2007/06/26 17:51:28 moritz Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fortune.c,v 1.24 2007/06/26 17:51:28 moritz Exp $";
d1376 1
a1376 1
	(void) fprintf(stderr, "fortune [-ae");
d1388 1
a1388 1
	(void) fprintf(stderr, " [[#%%] file/directory/all]\n");
@


1.24
log
@Set shortest string count to 0 in strfile(8), if there a no strings found
and check the number of strings in fortune(6) to prevent empty fortune
files to cause division by zero. Fixes PR 5514.

OK miod@@ ray@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.23 2006/09/25 06:03:29 otto Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fortune.c,v 1.23 2006/09/25 06:03:29 otto Exp $";
d249 1
a249 1
	(void) fseek(fp->inf, (long)Seekpts[0], 0);
d277 1
a277 1
		(void) fseek(Fortfile->inf, (long)Seekpts[0], 0);
@


1.23
log
@Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which lead to surprising results. Spotted by
from Paul Stoeber, more to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.22 2005/09/24 18:10:02 mickey Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fortune.c,v 1.22 2005/09/24 18:10:02 mickey Exp $";
d532 1
a532 1
				"fortune:%s not a fortune file or directory\n",
d1144 5
@


1.22
log
@fp->pos is int32 so do not print it as quad
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.21 2005/09/24 18:07:53 mickey Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fortune.c,v 1.21 2005/09/24 18:07:53 mickey Exp $";
d715 1
a715 1
	return (sbuf.st_mode & S_IFDIR);
@


1.21
log
@check the file is worth scanning to avoid endless loops; from Matthias Kilian <kili@@outback.escape.de> in pr4219
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.20 2004/07/09 15:59:26 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fortune.c,v 1.20 2004/07/09 15:59:26 deraadt Exp $";
d1081 1
a1081 1
	DPRINTF(1, (stderr, "pos for %s is %qd\n", fp->name, fp->pos));
@


1.20
log
@ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.19 2003/06/18 23:37:36 pvalchev Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fortune.c,v 1.19 2003/06/18 23:37:36 pvalchev Exp $";
d61 1
d165 1
d200 4
d1300 24
@


1.19
log
@return pointer from off_name() function as it's meant to be - this
was missed when copy() was changed; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.18 2003/06/03 03:01:39 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fortune.c,v 1.18 2003/06/03 03:01:39 millert Exp $";
d184 1
a184 3
main(ac, av)
	int	ac;
	char	*av[];
d237 1
a237 2
display(fp)
	FILEDESC	*fp;
d262 1
a262 1
fortlen()
d285 1
a285 3
getargs(argc, argv)
	int	argc;
	char	**argv;
d384 1
a384 3
form_file_list(files, file_cnt)
	char	**files;
	int	file_cnt;
d442 2
a443 6
add_file(percent, file, dir, head, tail, parent)
	int		percent;
	char	*file;
	char		*dir;
	FILEDESC	**head, **tail;
	FILEDESC	*parent;
d568 1
a568 1
new_fp()
d593 1
a593 2
off_name(file)
	char	*file;
d603 1
a603 2
is_off_name(file)
	char	*file;
d617 1
a617 3
all_forts(fp, offensive)
	FILEDESC	*fp;
	char			*offensive;
d665 1
a665 2
add_dir(fp)
	FILEDESC	*fp;
d703 1
a703 2
is_dir(file)
	char	*file;
d721 1
a721 3
is_fortfile(file, datp, posp, check_for_offend)
	char	*file, **datp, **posp;
	int	check_for_offend;
d785 1
a785 3
copy(str, suf)
	char	*str;
	char	*suf;
d799 1
a799 2
do_malloc(size)
	unsigned int	size;
d815 1
a815 2
do_free(ptr)
	void	*ptr;
d826 1
a826 1
init_prob()
d898 1
a898 1
get_fort()
d962 1
a962 2
pick_child(parent)
	FILEDESC	*parent;
d998 1
a998 2
sum_noprobs(fp)
	FILEDESC	*fp;
d1014 1
a1014 2
max(i, j)
	int	i, j;
d1024 1
a1024 2
open_fp(fp)
	FILEDESC	*fp;
d1037 1
a1037 2
open_dat(fp)
	FILEDESC	*fp;
d1051 1
a1051 2
get_pos(fp)
	FILEDESC	*fp;
d1083 1
a1083 2
get_tbl(fp)
	FILEDESC	*fp;
d1154 1
a1154 2
zero_tbl(tp)
	STRFILE	*tp;
d1166 1
a1166 2
sum_tbl(t1, t2)
	STRFILE	*t1, *t2;
d1182 1
a1182 1
print_file_list()
d1192 1
a1192 3
print_list(list, lev)
	FILEDESC	*list;
	int		lev;
d1216 1
a1216 2
conv_pat(orig)
	char	*orig;
d1258 1
a1258 1
find_matches()
d1276 1
a1276 2
maxlen_in_list(list)
	FILEDESC	*list;
d1301 1
a1301 2
matches_in_list(list)
	FILEDESC	*list;
d1339 1
a1339 1
usage()
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.17 2003/04/07 00:26:22 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fortune.c,v 1.17 2003/04/07 00:26:22 millert Exp $";
d607 1
a607 3
	char	*new;

	new = copy(file, "-o");
@


1.17
log
@Make copy() take an extra suffix argument so we don't need to cat
it on later.  tdeval@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.16 2003/04/06 18:50:37 deraadt Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fortune.c,v 1.16 2003/04/06 18:50:37 deraadt Exp $";
@


1.16
log
@2451 lines of strdup/sprintf/strcpy whacking.  mostly ok'd by pjanzen
already, but he may have later changes to make still.
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.15 2002/05/31 20:40:11 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: fortune.c,v 1.15 2002/05/31 20:40:11 pjanzen Exp $";
d134 1
a134 1
char	*copy(char *, u_int);
d613 1
a613 2
	new = copy(file, (unsigned int) (strlen(file) + 2));
	return strcat(new, "-o");
d706 1
a706 1
		name = copy(dirent->d_name, dirent->d_namlen);
d787 1
a787 2
	datfile = copy(file, (unsigned int) (strlen(file) + 4)); /* +4 for ".dat" */
	strcat(datfile, ".dat");
d798 2
a799 4
	if (posp != NULL) {
		*posp = copy(file, (unsigned int) (strlen(file) + 4)); /* +4 for ".pos" */
		(void) strcat(*posp, ".pos");
	}
d807 1
a807 1
 *	Return a malloc()'ed copy of the string
d810 3
a812 3
copy(str, len)
	char		*str;
	unsigned int	len;
d814 1
a814 1
	char	*new, *sp;
d816 2
a817 5
	new = do_malloc(len + 1);
	sp = new;
	do {
		*sp++ = *str;
	} while (*str++);
@


1.15
log
@de-auto
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.14 2002/05/31 04:21:30 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: fortune.c,v 1.14 2002/05/31 04:21:30 pjanzen Exp $";
d469 6
a474 4
	}
	else {
		path = do_malloc((unsigned int) (strlen(dir) + strlen(file) + 2));
		(void) strcat(strcat(strcpy(path, dir), "/"), file);
@


1.14
log
@de-register
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.13 2002/02/17 19:42:20 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: fortune.c,v 1.13 2002/02/17 19:42:20 millert Exp $";
d642 1
a642 1
	auto char		*datfile, *posfile;
d690 2
a691 2
	auto FILEDESC		*tailp;
	auto char		*name;
d727 1
a727 1
	auto struct stat	sbuf;
d1126 1
a1126 1
	auto int		fd;
@


1.13
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.12 2002/02/16 21:27:09 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: fortune.c,v 1.12 2002/02/16 21:27:09 millert Exp $";
d189 2
a190 2
int	ac;
char	*av[];
d244 1
a244 1
FILEDESC	*fp;
d246 1
a246 1
	register char	*p, ch;
d271 1
a271 1
	register int	nchar;
d293 2
a294 2
register int	argc;
register char	**argv;
d296 1
a296 1
	register int	ignore_case;
d298 1
a298 1
	register char	*pat = NULL;
d394 2
a395 2
register char	**files;
register int	file_cnt;
d397 2
a398 2
	register int	i, percent;
	register char	*sp;
d454 11
a464 11
int		percent;
register char	*file;
char		*dir;
FILEDESC	**head, **tail;
FILEDESC	*parent;
{
	register FILEDESC	*fp;
	register int		fd;
	register char		*path, *offensive;
	register bool		was_malloc;
	register bool		isdir;
d583 1
a583 1
	register FILEDESC	*fp;
d607 1
a607 1
char	*file;
d621 1
a621 1
char	*file;
d636 2
a637 2
register FILEDESC	*fp;
char			*offensive;
d639 3
a641 3
	register char		*sp;
	register FILEDESC	*scene, *obscene;
	register int		fd;
d686 1
a686 1
register FILEDESC	*fp;
d688 2
a689 2
	register DIR		*dir;
	register struct dirent  *dirent;
d725 1
a725 1
char	*file;
d744 2
a745 2
char	*file, **datp, **posp;
int	check_for_offend;
d747 3
a749 3
	register int	i;
	register char	*sp;
	register char	*datfile;
d813 2
a814 2
char		*str;
unsigned int	len;
d832 1
a832 1
unsigned int	size;
d849 1
a849 1
void	*ptr;
d862 2
a863 2
	register FILEDESC	*fp, *last;
	register int		percent, num_noprob, frac;
d934 2
a935 2
	register FILEDESC	*fp;
	register int		choice;
d997 1
a997 1
FILEDESC	*parent;
d999 2
a1000 2
	register FILEDESC	*fp;
	register int		choice;
d1034 1
a1034 1
register FILEDESC	*fp;
d1051 1
a1051 1
register int	i, j;
d1062 1
a1062 1
FILEDESC	*fp;
d1076 1
a1076 1
FILEDESC	*fp;
d1091 1
a1091 1
FILEDESC	*fp;
d1124 1
a1124 1
FILEDESC	*fp;
d1127 1
a1127 1
	register FILEDESC	*child;
d1196 1
a1196 1
register STRFILE	*tp;
d1209 1
a1209 1
register STRFILE	*t1, *t2;
d1236 2
a1237 2
register FILEDESC	*list;
int			lev;
d1262 1
a1262 1
register char	*orig;
d1264 3
a1266 3
	register char		*sp;
	register unsigned int	cnt;
	register char		*new;
d1323 1
a1323 1
FILEDESC	*list;
d1325 2
a1326 2
	register FILEDESC	*fp;
	register int		len, maxlen;
d1349 1
a1349 1
FILEDESC	*list;
d1351 2
a1352 2
	register char		*sp;
	register FILEDESC	*fp;
@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.11 2001/06/26 01:36:33 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: fortune.c,v 1.11 2001/06/26 01:36:33 pjanzen Exp $";
d131 2
a132 2
int	 add_file __P((int,
	    char *, char *, FILEDESC **, FILEDESC **, FILEDESC *));
@


1.11
log
@correct usage(); pointed out by pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.10 2001/03/22 22:29:40 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: fortune.c,v 1.10 2001/03/22 22:29:40 pjanzen Exp $";
d130 1
a130 1
int	 add_dir __P((FILEDESC *));
d133 16
a148 16
void	 all_forts __P((FILEDESC *, char *));
char	*copy __P((char *, u_int));
void	 display __P((FILEDESC *));
void	 do_free __P((void *));
void	*do_malloc __P((u_int));
int	 form_file_list __P((char **, int));
int	 fortlen __P((void));
void	 get_fort __P((void));
void	 get_pos __P((FILEDESC *));
void	 get_tbl __P((FILEDESC *));
void	 getargs __P((int, char *[]));
void	 init_prob __P((void));
int	 is_dir __P((char *));
int	 is_fortfile __P((char *, char **, char **, int));
int	 is_off_name __P((char *));
int	 max __P((int, int));
d150 4
a153 4
	 new_fp __P((void));
char	*off_name __P((char *));
void	 open_dat __P((FILEDESC *));
void	 open_fp __P((FILEDESC *));
d155 7
a161 7
	 pick_child __P((FILEDESC *));
void	 print_file_list __P((void));
void	 print_list __P((FILEDESC *, int));
void	 sum_noprobs __P((FILEDESC *));
void	 sum_tbl __P((STRFILE *, STRFILE *));
void	 usage __P((void));
void	 zero_tbl __P((STRFILE *));
d164 4
a167 4
char	*conv_pat __P((char *));
int	 find_matches __P((void));
void	 matches_in_list __P((FILEDESC *));
int	 maxlen_in_list __P((FILEDESC *));
@


1.10
log
@Don't free what wasn't alloced.  Found by niels.
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.9 2001/01/28 23:41:40 niklas Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: fortune.c,v 1.9 2001/01/28 23:41:40 niklas Exp $";
d1389 1
a1389 1
	(void) fprintf(stderr, "fortune [-a");
d1401 1
a1401 1
	(void) fprintf(stderr, "[ [#%%] file/directory/all]\n");
@


1.9
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: fortune.c,v 1.8 1995/03/23 08:28:40 cgd Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: fortune.c,v 1.8 1995/03/23 08:28:40 cgd Exp $";
a483 1
		was_malloc = TRUE;
d489 1
@


1.8
log
@free later; tg@@freebsd
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: fortune.c,v 1.8 1995/03/23 08:28:40 cgd Exp $";
@


1.7
log
@cleanup
@
text
@a539 1
		free((char *) fp);
d544 1
@


1.6
log
@strong random
@
text
@a202 3
#if 0
	srandom((int)(time((time_t *) NULL) + getpid()));
#endif
@


1.5
log
@tabify
@
text
@d203 1
d205 1
d942 1
a942 1
		choice = random() % 100;
d962 1
a962 1
			choice = random() % Noprob_tbl.str_numstr;
d1005 1
a1005 1
		choice = random() % parent->num_children;
d1015 1
a1015 1
		choice = random() % parent->tbl.str_numstr;
d1104 1
a1104 1
			fp->pos = random() % fp->tbl.str_numstr;
d1112 1
a1112 1
		fp->pos = random() % fp->tbl.str_numstr;
@


1.4
log
@r?index -> strr?chr
@
text
@d1166 1
a1166 1
		if (read(fd, fp->tbl.stuff,         sizeof(fp->tbl.stuff)) !=
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d668 1
a668 1
	if ((sp = rindex(offensive, '/')) == NULL)
d769 1
a769 1
	if ((sp = rindex(file, '/')) == NULL)
d777 1
a777 1
	if ((sp = rindex(sp, '.')) != NULL) {
@


1.2
log
@Store the fortune data files with fixed data types, and document this.
Bump database version to 2.
@
text
@d307 1
a307 1
	while ((ch = getopt(argc, argv, "aDefilm:osw")) != EOF)
d309 1
a309 1
	while ((ch = getopt(argc, argv, "aefilm:osw")) != EOF)
@


1.1
log
@Initial revision
@
text
@d75 1
a75 1
# define	POS_UNKNOWN	((off_t) -1)	/* pos for file unknown */
d89 1
a89 1
	off_t		pos;
d121 1
a121 1
off_t	Seekpts[2];			/* seek pointers to fortunes */
d224 1
d226 1
d799 1
a799 1
		*posp = copy(file, (unsigned int) (strlen(file) + 4)); /* +4 for ".dat" */
d985 1
a985 1
	read(fp->datfd, Seekpts, sizeof Seekpts);
d987 1
d1103 1
a1103 1
		else if (fp->pos >= fp->tbl.str_numstr)
d1105 2
d1136 26
a1161 1
		if (read(fd, (char *) &fp->tbl, sizeof fp->tbl) != sizeof fp->tbl) {
d1166 7
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
