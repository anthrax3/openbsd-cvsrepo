head	1.23;
access;
symbols
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.19.0.26
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.18
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.22
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.20
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.16
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.14
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.12
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.18.0.24
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.20
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.18
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.16
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.14
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.12
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.10
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.8
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.6
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.4
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.16.0.10
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.8
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.6
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.16.0.4
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_8:1.15.0.2
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.11.0.4
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2016.09.11.14.21.17;	author tb;	state Exp;
branches;
next	1.22;
commitid	vQliJ9M8LCn9g8k6;

1.22
date	2015.12.31.17.51.19;	author mestre;	state Exp;
branches;
next	1.21;
commitid	GSzV0GYeNlCgMbj0;

1.21
date	2015.12.04.17.34.40;	author tb;	state Exp;
branches;
next	1.20;
commitid	n8gYjdwgWTO47G4i;

1.20
date	2015.11.29.15.31.06;	author tb;	state Exp;
branches;
next	1.19;
commitid	ooXklcii03MqVMO8;

1.19
date	2009.10.27.23.59.23;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.10.07.26.22;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.03.03.01.38;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.04.02.19.42;	author pjanzen;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.24.21.55.23;	author pjanzen;	state Exp;
branches;
next	1.14;

1.14
date	2000.09.23.03.02.36;	author pjanzen;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.21.00.23.43;	author pjanzen;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.03.05.23.44;	author pjanzen;	state Exp;
branches;
next	1.11;

1.11
date	99.09.25.20.30.45;	author pjanzen;	state Exp;
branches;
next	1.10;

1.10
date	99.07.31.18.11.26;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	98.09.13.01.30.31;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	97.12.16.07.54.23;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	97.09.01.19.30.55;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.09.01.18.13.13;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.08.24.21.55.04;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.06.30.19.56.32;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.06.30.19.50.14;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	97.01.27.07.32.34;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.42;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.42;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Callers of time(3) should #include <time.h>.

ok deraadt
@
text
@/*	$OpenBSD: com6.c,v 1.22 2015/12/31 17:51:19 mestre Exp $	*/
/*	$NetBSD: com6.c,v 1.5 1995/04/27 21:30:23 mycroft Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <err.h>
#include <errno.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "extern.h"

int
launch(void)
{
	if (TestBit(location[position].objects, VIPER) && !notes[CANTLAUNCH]) {
		if (fuel > 4) {
			ClearBit(location[position].objects, VIPER);
			position = location[position].up;
			notes[LAUNCHED] = 1;
			ourtime++;
			fuel -= 4;
			puts("You climb into the viper and prepare for launch.");
			puts("With a touch of your thumb the turbo engines ignite, thrusting you back into\nyour seat.");
			return (1);
		} else
			puts("Not enough fuel to launch.");
	} else
		puts("Can't launch.");
	return (0);
}

int
land(void)
{
	if (notes[LAUNCHED] && TestBit(location[position].objects, LAND) &&
	    location[position].down) {
		notes[LAUNCHED] = 0;
		position = location[position].down;
		SetBit(location[position].objects, VIPER);
		fuel -= 2;
		ourtime++;
		puts("You are down.");
		return (1);
	} else
		puts("You can't land here.");
	return (0);
}

/* endgame */
void
die(int sigraised)
{
	printf("bye.\nYour rating was %s.\n", rate());
	post(' ');
	exit(0);
}

void
live(void)
{
	puts("\nYou win!");
	post('!');
	exit(0);
}

static FILE *score_fp;

void
open_score_file(void)
{
	char		 scorefile[PATH_MAX];
	const char	*home;
	int		 ret;

	home = getenv("HOME");
	if (home == NULL || *home == '\0')
		err(1, "getenv");
	ret = snprintf(scorefile, sizeof(scorefile), "%s/%s", home,
	    ".battlestar.scores");
	if (ret < 0 || ret >= PATH_MAX)
		errc(1, ENAMETOOLONG, "%s/%s", home, ".battlestar.scores");
	if ((score_fp = fopen(scorefile, "a")) == NULL)
		warn("can't append to high scores file (%s)", scorefile);
}

void
post(char ch)
{
	time_t tv;
	char   *date;
	sigset_t sigset, osigset;

	sigemptyset(&sigset);
	sigaddset(&sigset, SIGINT);
	sigprocmask(SIG_BLOCK, &sigset, &osigset);
	tv = time(NULL);
	date = ctime(&tv);
	date[24] = '\0';

	if (score_fp != NULL) {
		fprintf(score_fp, "%s  %31s  %c%20s", date, username, ch, rate());
		if (wiz)
			fprintf(score_fp, "   wizard\n");
		else
			if (tempwiz)
				fprintf(score_fp, "   WIZARD!\n");
			else
				fprintf(score_fp, "\n");
	}
	sigprocmask(SIG_SETMASK, &osigset, (sigset_t *)0);
}

const char   *
rate(void)
{
	int     score;

	score = max(max(pleasure, power), ego);
	if (score == pleasure) {
		if (score < 5)
			return ("novice");
		else if (score < 20)
			return ("junior voyeur");
		else if (score < 35)
			return ("Don Juan");
		else
			return ("Marquis De Sade");
	} else
		if (score == power) {
			if (score < 5)
				return ("serf");
			else if (score < 8)
				return ("Samurai");
			else if (score < 13)
				return ("Klingon");
			else if (score < 22)
				return ("Darth Vader");
			else
				return ("Sauron the Great");
		} else{
			if (score < 5)
				return ("Polyanna");
			else if (score < 10)
				return ("philanthropist");
			else if (score < 20)
				return ("Tattoo");
			else
				return ("Mr. Roarke");
		}
}

int
drive(void)
{
	if (TestBit(location[position].objects, CAR)) {
		puts("You hop in the car and turn the key.  There is a perceptible grating noise,");
		puts("and an explosion knocks you unconscious...");
		ClearBit(location[position].objects, CAR);
		SetBit(location[position].objects, CRASH);
		injuries[5] = injuries[6] = injuries[7] = injuries[8] = 1;
		ourtime += 15;
		zzz();
		return (0);
	} else
		puts("There is nothing to drive here.");
	return (-1);
}

int
ride(void)
{
	if (TestBit(location[position].objects, HORSE)) {
		puts("You climb onto the stallion and kick it in the guts.  The stupid steed launches");
		puts("forward through bush and fern.  You are thrown and the horse gallops off.");
		ClearBit(location[position].objects, HORSE);
		while (!(position = rnd(NUMOFROOMS + 1)) || !OUTSIDE || !beenthere[position] || location[position].flyhere)
			;
		SetBit(location[position].objects, HORSE);
		if (location[position].north)
			position = location[position].north;
		else if (location[position].south)
			position = location[position].south;
		else if (location[position].east)
			position = location[position].east;
		else
			position = location[position].west;
		return (0);
	}
	else puts("There is no horse here.");
	return (-1);
}

void
light(void)
{				/* synonyms = {strike, smoke} */
	if (TestBit(inven, MATCHES) && matchcount) {
		puts("Your match splutters to life.");
		ourtime++;
		matchlight = 1;
		matchcount--;
		if (position == 217) {
			puts("The whole bungalow explodes with an intense blast.");
			die(0);
		}
	} else
		puts("You're out of matches.");
}

void
dooropen(void)
{				/* synonyms = {open, unlock} */
	wordnumber++;
	if (wordnumber <= wordcount && wordtype[wordnumber] == NOUNS
	    && wordvalue[wordnumber] == DOOR) {
		switch(position) {
		case 189:
		case 231:
			if (location[189].north == 231)
				puts("The door is already open.");
			else
				puts("The door does not budge.");
			break;
		case 30:
			if (location[30].west == 25)
				puts("The door is gone.");
			else
				puts("The door is locked tight.");
			break;
		case 31:
			puts("That's one immovable door.");
			break;
		case 20:
			puts("The door is already ajar.");
			break;
		default:
			puts("What door?");
		}
	} else
		puts("That doesn't open.");
}
@


1.22
log
@Include only needed header files per each source file

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com6.c,v 1.21 2015/12/04 17:34:40 tb Exp $	*/
d39 1
@


1.21
log
@cleanup: remove pwd.h, delete a stray comment and a const qualifier
@
text
@d1 1
a1 1
/*	$OpenBSD: com6.c,v 1.20 2015/11/29 15:31:06 tb Exp $	*/
d33 7
a40 1
#include "pathnames.h"
@


1.20
log
@Move score file to $HOME and add pledge "stdio rpath wpath cpath".
For high score entries, try LOGNAME, then USER, then getlogin() then
fall back to ???.
@
text
@d1 1
a1 1
/*	$OpenBSD: com6.c,v 1.19 2009/10/27 23:59:23 deraadt Exp $	*/
d95 1
a95 1
	const char	 scorefile[PATH_MAX];
@


1.19
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: com6.c,v 1.18 2004/07/10 07:26:22 deraadt Exp $	*/
d95 13
a107 2
	if ((score_fp = fopen(_PATH_SCORE, "a")) == NULL)
		warn("can't append to high scores file (%s)", _PATH_SCORE);
@


1.18
log
@more ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: com6.c,v 1.17 2003/06/03 03:01:38 millert Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)com6.c	8.2 (Berkeley) 4/28/95";
#else
static char rcsid[] = "$OpenBSD: com6.c,v 1.17 2003/06/03 03:01:38 millert Exp $";
#endif
#endif /* not lint */
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: com6.c,v 1.16 2001/02/04 02:19:42 pjanzen Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: com6.c,v 1.16 2001/02/04 02:19:42 pjanzen Exp $";
d45 1
a45 1
launch()
d65 1
a65 1
land()
d81 1
d83 2
a84 3
die(sigraised)
	int     sigraised;
{ 				/* endgame */
d91 1
a91 1
live()
d101 1
a101 1
open_score_file()
d108 1
a108 2
post(ch)
	char    ch;
d135 1
a135 1
rate()
d174 1
a174 1
drive()
d191 1
a191 1
ride()
d215 1
a215 1
light()
d231 1
a231 1
dooropen()
@


1.16
log
@Format for long usernames
@
text
@d1 1
a1 1
/*	$OpenBSD: com6.c,v 1.15 2000/09/24 21:55:23 pjanzen Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: com6.c,v 1.15 2000/09/24 21:55:23 pjanzen Exp $";
@


1.15
log
@numerous changes from jsm@@netbsd.org:
static where appropriate, add a few comments, format a bit better, and
deal with WEIGHT/CUMBER being zero (and not less).
@
text
@d1 1
a1 1
/*	$OpenBSD: com6.c,v 1.14 2000/09/23 03:02:36 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: com6.c,v 1.14 2000/09/23 03:02:36 pjanzen Exp $";
d127 1
a127 1
		fprintf(score_fp, "%s  %8s  %c%20s", date, username, ch, rate());
@


1.14
log
@drop adjectives in parse(), since they're never used.
tidy a little.  fix love() a bit.
From conversations with jsm@@netbsd.org:
Add objflags[] to deal with plurals and a/an usage.
Commas don't mean AND if followed by a verb.
Check for object presence before trying to lift or eat it.
@
text
@d1 1
a1 1
/*	$OpenBSD: com6.c,v 1.13 2000/09/21 00:23:43 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: com6.c,v 1.13 2000/09/21 00:23:43 pjanzen Exp $";
d202 2
a203 1
		while (!(position = rnd(NUMOFROOMS + 1)) || !OUTSIDE || !beenthere[position] || location[position].flyhere);
@


1.13
log
@formatting; from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: com6.c,v 1.12 2000/07/03 05:23:44 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: com6.c,v 1.12 2000/07/03 05:23:44 pjanzen Exp $";
d237 1
a237 2
	while(wordtype[++wordnumber] == ADJS)
		;
@


1.12
log
@Finding bugs in battlestar is like shooting fish in a barrel.
	Don't overflow beenthere[].  Add "verbose" option.
	Fix spelling (including embedded hyphens in descriptions) and grammar.
	"Kill" will now use the laser if you have no cutting implements.
	Formatting.
	You can do more things to the bathing goddess.
	A little less guess-the-word.  Occasionally better error messages,
particularly with "all" when nothing applies.
	"kick door" no longer segfaults.  Nor does "kill door".
More bugs remain...
@
text
@d1 1
a1 1
/*	$OpenBSD: com6.c,v 1.11 1999/09/25 20:30:45 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: com6.c,v 1.11 1999/09/25 20:30:45 pjanzen Exp $";
d152 2
a153 1
		else return ("Marquis De Sade");
d164 2
a165 1
			else return ("Sauron the Great");
d173 2
a174 1
			else return ("Mr. Roarke");
@


1.11
log
@Merge 4.4BSD-Lite2 and NetBSD, including improved save file handling of
jsm28@@cam.ac.uk.  Rename setbit() family of macros so as not to conflict
with <sys/param.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: com6.c,v 1.10 1999/07/31 18:11:26 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: com6.c,v 1.10 1999/07/31 18:11:26 pjanzen Exp $";
d229 34
@


1.10
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: com6.c,v 1.9 1998/09/13 01:30:31 pjanzen Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)com6.c	8.1 (Berkeley) 5/31/93";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: com6.c,v 1.9 1998/09/13 01:30:31 pjanzen Exp $";
d51 1
a51 1
	if (testbit(location[position].objects, VIPER) && !notes[CANTLAUNCH]) {
d53 1
a53 1
			clearbit(location[position].objects, VIPER);
d71 1
a71 1
	if (notes[LAUNCHED] && testbit(location[position].objects, LAND) &&
d75 1
a75 1
		setbit(location[position].objects, VIPER);
d127 1
a127 1
		fprintf(score_fp, "%s  %8s  %c%20s", date, uname, ch, rate());
d139 1
a139 1
char   *
d178 1
a178 1
	if (testbit(location[position].objects, CAR)) {
d181 2
a182 2
		clearbit(location[position].objects, CAR);
		setbit(location[position].objects, CRASH);
d195 1
a195 1
	if (testbit(location[position].objects, HORSE)) {
d198 1
a198 1
		clearbit(location[position].objects, HORSE);
d200 1
a200 1
		setbit(location[position].objects, HORSE);
d218 1
a218 1
	if (testbit(inven, MATCHES) && matchcount) {
@


1.9
log
@NetBSD merge, numerous patches from jsm28@@cam.ac.uk, spelling fixes, and
correct gid revoke.
@
text
@d1 1
a1 1
/*	$OpenBSD: com6.c,v 1.8 1997/12/16 07:54:23 angelos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD$";
d197 1
a197 1
		puts("forward through bush and fern.  You are thrown and the horse gallups off.");
@


1.8
log
@Fix annoying warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: com6.c,v 1.7 1997/09/01 19:30:55 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$NetBSD: com6.c,v 1.5 1995/04/27 21:30:23 mycroft Exp $";
a44 1
#include <time.h>
d51 3
a53 3
	if (testbit(location[position].objects,VIPER) && !notes[CANTLAUNCH]){
		if (fuel > 4){
			clearbit(location[position].objects,VIPER);
d56 1
a56 1
			btime++;
d60 2
a61 3
			return(1);
		}
		else
d63 1
a63 2
	 }
	 else
d65 1
a65 1
	 return(0);
d71 2
a72 1
	if (notes[LAUNCHED] && testbit(location[position].objects,LAND) && location[position].down){
d75 1
a75 1
		setbit(location[position].objects,VIPER);
d77 1
a77 1
		btime++;
d79 2
a80 3
		return(1);
	}
	else
d82 1
a82 1
	return(0);
d86 3
a88 3
die(sigraised) 		/* endgame */
int sigraised;
{
d104 1
d113 1
a113 1
char ch;
d116 1
a116 1
	char *date;
a129 2
		else if (tempwiz)
			fprintf(score_fp, "   WIZARD!\n");
d131 4
a134 1
			fprintf(score_fp, "\n");
a135 1

d139 1
a139 1
char *
d142 1
a142 1
	int score;
d144 2
a145 2
	score = max(max(pleasure,power),ego);
	if (score == pleasure){
d147 1
a147 1
			return("novice");
d149 1
a149 1
			return("junior voyeur");
d151 22
a172 23
			return("Don Juan");
		else return("Marquis De Sade");
	}
	else if (score == power){
		if (score < 5)
			return("serf");
		else if (score < 8)
			return("Samurai");
		else if (score < 13)
			return("Klingon");
		else if (score < 22)
			return("Darth Vader");
		else return("Sauron the Great");
	}
	else{
		if (score < 5)
			return("Polyanna");
		else if (score < 10)
			return("philanthropist");
		else if (score < 20)
			return("Tattoo");
		else return("Mr. Roarke");
	}
d178 1
a178 1
	if (testbit(location[position].objects,CAR)){
d181 2
a182 2
		clearbit(location[position].objects,CAR);
		setbit(location[position].objects,CRASH);
d184 1
a184 1
		btime += 15;
d186 2
a187 3
		return(0);
	}
	else
d189 1
a189 1
	return(-1);
d195 1
a195 1
	if (testbit(location[position].objects,HORSE)){
d198 3
a200 3
		clearbit(location[position].objects,HORSE);
		while (!(position = rnd(NUMOFROOMS+1)) || !OUTSIDE || !beenthere[position] || location[position].flyhere);
		setbit(location[position].objects,HORSE);
d209 1
a209 1
		return(0);
d212 1
a212 1
	return(-1);
d216 3
a218 3
light()		/* synonyms = {strike, smoke} */
{		/* for matches, cigars */
	if (testbit(inven,MATCHES) && matchcount){
d220 1
a220 1
		btime++;
d223 1
a223 1
		if (position == 217){
d227 2
a228 2
	}
	else puts("You're out of matches.");
@


1.7
log
@Don't try to write to a NULL file pointer whne updating high score list
(happens if scores file is not writable).
@
text
@d1 1
a1 1
/*	$OpenBSD: com6.c,v 1.6 1997/09/01 18:13:13 millert Exp $	*/
d89 2
a90 1
die() 		/* endgame */
d229 1
a229 1
			die();
@


1.6
log
@Remove trailing spaces on lines, use sane pathname sizes, and
use warn instead of perror.
@
text
@d1 1
a1 1
/*	$OpenBSD: com6.c,v 1.5 1997/08/24 21:55:04 deraadt Exp $	*/
d109 1
a109 1
		warn("can't append to %s", _PATH_SCORE);
d127 9
a135 7
	fprintf(score_fp, "%s  %8s  %c%20s", date, uname, ch, rate());
	if (wiz)
		fprintf(score_fp, "   wizard\n");
	else if (tempwiz)
		fprintf(score_fp, "   WIZARD!\n");
	else
		fprintf(score_fp, "\n");
@


1.5
log
@various linux-based patches; from linux people; sent by jsm@@octomino.demon.co.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: com6.c,v 1.4 1997/06/30 19:56:32 kstailey Exp $	*/
d108 2
a109 2
	if ((score_fp = fopen(_PATH_SCORE,"a")) == NULL)
		perror(_PATH_SCORE);
@


1.4
log
@tag
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 2
a46 1
#include "externs.h"
d49 1
d57 1
a57 1
			time++;
d71 1
d79 1
a79 1
		time++;
d88 1
d96 1
d112 1
d116 2
a117 2
	struct timeval tv;
	char *date, *ctime();
d123 2
a124 2
	gettimeofday(&tv, (struct timezone *)0);	/* can't call time */
	date = ctime(&tv.tv_sec);
d175 1
d184 1
a184 1
		time += 15;
d193 1
d216 1
d221 1
a221 1
		time++;
@


1.3
log
@fix highscore
@
text
@d1 1
@


1.2
log
@Fallout from signal.h's inclusion of sys/time.h...
@
text
@d98 8
a108 1
	FILE *fp;
d119 9
a127 10
	if (fp = fopen(_PATH_SCORE,"a")) {
		fprintf(fp, "%s  %8s  %c%20s", date, uname, ch, rate());
		if (wiz)
			fprintf(fp, "   wizard\n");
		else if (tempwiz)
			fprintf(fp, "   WIZARD!\n");
		else
			fprintf(fp, "\n");
	} else
		perror(_PATH_SCORE);
@


1.1
log
@Initial revision
@
text
@a97 8
/*
 * sigh -- this program thinks "time" is an int.  It's easier to not load
 * <time.h> than try and fix it.
 */
#define _KERNEL
#include <sys/time.h>
#undef _KERNEL

@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
