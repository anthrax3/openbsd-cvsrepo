head	1.15;
access;
symbols
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.4
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.14.0.26
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.18
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.22
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.20
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.16
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.14
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.12
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.24
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.20
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.18
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.16
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.14
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.12
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.10
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.8
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.6
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.11.0.12
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.10
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.8
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.11.0.6
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.11.0.4
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2015.12.31.17.51.19;	author mestre;	state Exp;
branches;
next	1.14;
commitid	GSzV0GYeNlCgMbj0;

1.14
date	2009.10.27.23.59.23;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.10.07.26.22;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.03.03.01.38;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.09.26.04.42.55;	author pjanzen;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.23.03.02.36;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.17.21.28.32;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.03.05.23.44;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	99.09.25.20.30.45;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	98.09.13.01.30.30;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	97.12.16.07.54.23;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	97.09.01.18.13.11;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.08.24.21.55.03;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.06.30.19.56.31;	author kstailey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.42;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.42;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Include only needed header files per each source file

OK tb@@
@
text
@/*	$OpenBSD: com4.c,v 1.14 2009/10/27 23:59:23 deraadt Exp $	*/
/*	$NetBSD: com4.c,v 1.3 1995/03/21 15:07:04 cgd Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <stdio.h>

#include "extern.h"

int
take(unsigned int from[])
{
	int     firstnumber, heavy, bulky, value;

	firstnumber = wordnumber;
	if (wordnumber < wordcount && wordvalue[wordnumber + 1] == OFF) {
		wordnumber++;
		wordvalue[wordnumber] = TAKEOFF;
		wordtype[wordnumber] = VERB;
		cypher();
		return (wordnumber);
	} else {
		wordnumber++;
		while (wordnumber <= wordcount && wordtype[wordnumber] == OBJECT) {
			value = wordvalue[wordnumber];
			printf("%s:\n", objsht[value]);
			heavy = (carrying + objwt[value]) <= WEIGHT;
			bulky = (encumber + objcumber[value]) <= CUMBER;
			if ((TestBit(from, value) || wiz || tempwiz) && heavy && bulky && !TestBit(inven, value)) {
				SetBit(inven, value);
				carrying += objwt[value];
				encumber += objcumber[value];
				ourtime++;
				if (TestBit(from, value))
					printf("Taken.\n");
				else
					printf("Zap! Taken from thin air.\n");
				ClearBit(from, value);
				if (value == MEDALION)
					win--;
			} else if (TestBit(inven, value))
				printf("You're already holding %s%s.\n",
				    A_OR_AN_OR_BLANK(value), objsht[value]);
			else if (!TestBit(from, value))
				printf("I don't see any %s around here.\n", objsht[value]);
			else if (!heavy)
				printf("The %s %s too heavy.\n", objsht[value],
				    IS_OR_ARE(value));
			else
				printf("The %s %s too cumbersome to hold.\n", objsht[value],
				    IS_OR_ARE(value));
			if (wordnumber < wordcount - 1 && wordvalue[++wordnumber] == AND)
				wordnumber++;
			else
				return (firstnumber);
		}
	}
	/* special cases with their own return()'s */

	if (wordnumber <= wordcount && wordtype[wordnumber] == NOUNS)
		switch (wordvalue[wordnumber]) {

		case SWORD:
			if (TestBit(from, SWORD)) {
				wordtype[wordnumber--] = OBJECT;
				return (take(from));
			}
			if (TestBit(from, TWO_HANDED)) {
				wordvalue[wordnumber] = TWO_HANDED;
				wordtype[wordnumber--] = OBJECT;
				return (take(from));
			}
			wordvalue[wordnumber] = BROAD;
			wordtype[wordnumber--] = OBJECT;
			return (take(from));

		case BODY:
			if (TestBit(from, MAID)) {
				wordvalue[wordnumber] = MAID;
				wordtype[wordnumber--] = OBJECT;
				return (take(from));
			}
			else if (TestBit(from, DEADWOOD)) {
				wordvalue[wordnumber] = DEADWOOD;
				wordtype[wordnumber--] = OBJECT;
				return (take(from));
			}
			else if (TestBit(from, DEADNATIVE)) {
				wordvalue[wordnumber] = DEADNATIVE;
				wordtype[wordnumber--] = OBJECT;
				return (take(from));
			}
			else if (TestBit(from, DEADGOD)) {
				wordvalue[wordnumber] = DEADGOD;
				wordtype[wordnumber--] = OBJECT;
				return (take(from));
			} else {
				wordvalue[wordnumber] = DEADTIME;
				wordtype[wordnumber--] = OBJECT;
				return (take(from));
			}
			break;

		case AMULET:
			if (TestBit(location[position].objects, AMULET)) {
				puts("The amulet is warm to the touch, and its beauty catches your breath.");
				puts("A mist falls over your eyes, but then it is gone.  Sounds seem clearer");
				puts("and sharper but far away as if in a dream.  The sound of purling water");
				puts("reaches you from afar.  The mist falls again, and your heart leaps in horror.");
				puts("The gold freezes your hands and fathomless darkness engulfs your soul.");
			}
			wordtype[wordnumber--] = OBJECT;
			return (take(from));

		case MEDALION:
			if (TestBit(location[position].objects, MEDALION)) {
				puts("The medallion is warm, and it rekindles your spirit with the warmth of life.");
				puts("Your amulet begins to glow as the medallion is brought near to it, and together\nthey radiate.");
			}
			wordtype[wordnumber--] = OBJECT;
			return (take(from));

		case TALISMAN:
			if (TestBit(location[position].objects, TALISMAN)) {
				puts("The talisman is cold to the touch, and it sends a chill down your spine.");
			}
			wordtype[wordnumber--] = OBJECT;
			return (take(from));

		case NORMGOD:
			if (TestBit(location[position].objects, BATHGOD) && (TestBit(wear, AMULET) || TestBit(inven, AMULET))) {
				puts("She offers a delicate hand, and you help her out of the sparkling springs.");
				puts("Water droplets like liquid silver bedew her golden skin, but when they part");
				puts("from her, they fall as teardrops.  She wraps a single cloth around her and");
				puts("ties it at the waist.  Around her neck hangs a golden amulet.");
				puts("She bids you to follow her, and walks away.");
				pleasure++;
				followgod = ourtime;
				ClearBit(location[position].objects, BATHGOD);
			} else
				if (!TestBit(location[position].objects, BATHGOD))
					puts("You're in no position to take her.");
				else
					puts("She moves away from you.");
			break;

		default:
			puts("It doesn't seem to work.");
		}
	else
		puts("You've got to be kidding.");
	return (firstnumber);
}

int
throw(const char *name)
{
	unsigned int n;
	int     deposit = 0;
	int     first, value;

	first = wordnumber;
	if (drop(name) != -1) {
		switch (wordvalue[wordnumber]) {

		case AHEAD:
			deposit = ahead;
			break;

		case BACK:
			deposit = back;
			break;

		case LEFT:
			deposit = left;
			break;

		case RIGHT:
			deposit = right;
			break;

		case UP:
			deposit = location[position].up * (location[position].access || position == FINAL);
			break;

		case DOWN:
			deposit = location[position].down;
			break;
		}
		wordnumber = first + 1;
		while (wordnumber <= wordcount) {
			value = wordvalue[wordnumber];
			if (deposit && TestBit(location[position].objects, value)) {
				ClearBit(location[position].objects, value);
				if (value != GRENADE)
					SetBit(location[deposit].objects, value);
				else {
					puts("A thundering explosion nearby sends up a cloud of smoke and shrapnel.");
					for (n = 0; n < NUMOFWORDS; n++)
						location[deposit].objects[n] = 0;
					SetBit(location[deposit].objects, CHAR);
				}
				if (value == ROPE && position == FINAL)
					location[position].access = 1;
				switch (deposit) {
				case 189:
				case 231:
					puts("The stone door is unhinged.");
					location[189].north = 231;
					location[231].south = 189;
					break;
				case 30:
					puts("The wooden door is blown open.");
					location[30].west = 25;
					break;
				case 31:
					puts("The door is not damaged.");
				}
			} else
				if (value == GRENADE && TestBit(location[position].objects, value)) {
					puts("You are blown into shreds when your grenade explodes.");
					die(0);
				}
			if (wordnumber < wordcount - 1 && wordvalue[++wordnumber] == AND)
				wordnumber++;
			else
				return (first);
		}
		return (first);
	}
	return (first);
}

int
drop(const char *name)
{

	int     firstnumber, value;

	firstnumber = wordnumber;
	wordnumber++;
	while (wordnumber <= wordcount && (wordtype[wordnumber] == OBJECT || wordtype[wordnumber] == NOUNS)) {
		value = wordvalue[wordnumber];
		if (value == BODY) {	/* special case */
			wordtype[wordnumber] = OBJECT;
			if (TestBit(inven, MAID) || TestBit(location[position].objects, MAID))
				value = MAID;
			if (TestBit(inven, DEADWOOD) || TestBit(location[position].objects, DEADWOOD))
				value = DEADWOOD;
			if (TestBit(inven, DEADGOD) || TestBit(location[position].objects, DEADGOD))
				value = DEADGOD;
			if (TestBit(inven, DEADTIME) || TestBit(location[position].objects, DEADTIME))
				value = DEADTIME;
			if (TestBit(inven, DEADNATIVE) || TestBit(location[position].objects, DEADNATIVE))
				value = DEADNATIVE;
		}
		if (wordtype[wordnumber] == NOUNS && value == DOOR) {
			if (*name == 'K')
				puts("You hurt your foot.");
			else
				puts("You're not holding a door.");
		} else if (objsht[value] == NULL) {
			if (*name == 'K')
				puts("That's not for kicking!");
			else
				puts("You don't have that.");
		} else {
			printf("%s:\n", objsht[value]);
			if (TestBit(inven, value)) {
				ClearBit(inven, value);
				carrying -= objwt[value];
				encumber -= objcumber[value];
				if (value == BOMB) {
					puts("The bomb explodes.  A blinding white light and immense concussion obliterate us.");
					die(0);
				}
				if (value != AMULET && value != MEDALION && value != TALISMAN)
					SetBit(location[position].objects, value);
				else
					tempwiz = 0;
				ourtime++;
				if (*name == 'K')
					puts("Drop kicked.");
				else
					printf("%s.\n", name);
			} else {
				if (*name != 'K') {
					printf("You aren't holding the %s.\n", objsht[value]);
					if (TestBit(location[position].objects, value)) {
						if (*name == 'T')
							puts("Kicked instead.");
						else if (*name == 'G')
							puts("Given anyway.");
					}
				} else if (TestBit(location[position].objects, value))
					puts("Kicked.");
				else if (TestBit(wear, value))
					puts("Not while it's being worn.");
				else
					puts("Not found.");
			}
		}
		if (wordnumber < wordcount - 1 && wordvalue[++wordnumber] == AND)
			wordnumber++;
		else
			return (firstnumber);
	}
	puts("Do what?");
	return (-1);
}

int
takeoff(void)
{
	wordnumber = take(wear);
	return (drop("Dropped"));
}

int
puton(void)
{
	wordnumber = take(location[position].objects);
	return (wearit());
}

int
eat(void)
{
	int     firstnumber, value;

	firstnumber = wordnumber;
	wordnumber++;
	while (wordnumber <= wordcount) {
		value = wordvalue[wordnumber];
		if (wordtype[wordnumber] != OBJECT || objsht[value] == NULL)
			value = -2;
		switch (value) {

		case -2:
			puts("You can't eat that!");
			wordnumber++;
			return (firstnumber);

		case -1:
			puts("Eat what?");
			wordnumber++;
			return (firstnumber);

		default:
			printf("You can't eat %s%s!\n",
			    A_OR_AN_OR_BLANK(value), objsht[value]);
			wordnumber++;
			return (firstnumber);

		case PAPAYAS:
		case PINEAPPLE:
		case KIWI:
		case COCONUTS:	/* eatable things */
		case MANGO:

			printf("%s:\n", objsht[value]);
			if (TestBit(inven, value) && ourtime > ate - CYCLE &&
			    TestBit(inven, KNIFE)) {
				ClearBit(inven, value);
				carrying -= objwt[value];
				encumber -= objcumber[value];
				ate = max(ourtime, ate) + CYCLE / 3;
				snooze += CYCLE / 10;
				ourtime++;
				puts("Eaten.  You can explore a little longer now.");
			} else if (!TestBit(inven, value))
				printf("You aren't holding the %s.\n", objsht[value]);
			else if (!TestBit(inven, KNIFE))
				puts("You need a knife.");
			else
				puts("You're stuffed.");
			if (wordnumber < wordcount - 1 && wordvalue[++wordnumber] == AND)
				wordnumber++;
			else
				return (firstnumber);
		}		/* end switch */
	}			/* end while */
	return (firstnumber);
}
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: com4.c,v 1.13 2004/07/10 07:26:22 deraadt Exp $	*/
d32 2
@


1.13
log
@more ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: com4.c,v 1.12 2003/06/03 03:01:38 millert Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)com4.c	8.2 (Berkeley) 4/28/95";
#else
static char rcsid[] = "$OpenBSD: com4.c,v 1.12 2003/06/03 03:01:38 millert Exp $";
#endif
#endif /* not lint */
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: com4.c,v 1.11 2000/09/26 04:42:55 pjanzen Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: com4.c,v 1.11 2000/09/26 04:42:55 pjanzen Exp $";
d44 1
a44 2
take(from)
	unsigned int from[];
d189 1
a189 2
throw(name)
	const char   *name;
d268 1
a268 2
drop(name)
	const char   *name;
d346 1
a346 1
takeoff()
d353 1
a353 1
puton()
d360 1
a360 1
eat()
@


1.11
log
@Improve handling of multiple commands on one line.  Tidy fight parser.
Handle "all" in one place (almost).  Add AUXVERB category and OBJ_PERSON/
OBJ_NONOBJ flags.  Most was discussed with jsm@@netbsd.org, and some is from
him.
@
text
@d1 1
a1 1
/*	$OpenBSD: com4.c,v 1.10 2000/09/23 03:02:36 pjanzen Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: com4.c,v 1.10 2000/09/23 03:02:36 pjanzen Exp $";
@


1.10
log
@drop adjectives in parse(), since they're never used.
tidy a little.  fix love() a bit.
From conversations with jsm@@netbsd.org:
Add objflags[] to deal with plurals and a/an usage.
Commas don't mean AND if followed by a verb.
Check for object presence before trying to lift or eat it.
@
text
@d1 1
a1 1
/*	$OpenBSD: com4.c,v 1.9 2000/09/17 21:28:32 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: com4.c,v 1.9 2000/09/17 21:28:32 pjanzen Exp $";
d57 3
a59 1
		return (cypher());
d81 1
a81 2
				    (IsPluralObject(value) ? "" :
				    (AorAn(value))), objsht[value]);
d86 1
a86 1
				    (IsPluralObject(value) ? "are" : "is"));
d89 1
a89 1
				    (IsPluralObject(value) ? "are" : "is"));
d229 1
a229 1
		wordnumber++;
d381 1
d386 1
d391 2
a392 3
			    wordtype[wordnumber] == OBJECT &&
			    IsPluralObject(value) ? "" :
			    (AorAn(value)), objsht[value]);
@


1.9
log
@Fewer segfaults ("take all and all", "wear wear"), better parsing
(e.g. disambiguation of "drop body").  Also, use "a" or "an" correctly,
don't overflow the words array, and don't kick items you're wearing.
@
text
@d1 1
a1 1
/*	$OpenBSD: com4.c,v 1.8 2000/07/03 05:23:44 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: com4.c,v 1.8 2000/07/03 05:23:44 pjanzen Exp $";
a51 1
	int     n;
d59 1
a59 1
		while (wordtype[++wordnumber] == ADJS);
a62 1
			for (n = 0; objsht[value][n]; n++);
d77 12
a88 11
			} else
				if (TestBit(inven, value))
					printf("You're already holding %s%s.\n",
					    (objsht[value][n-1] == 's' ? "" :
					    (AorAn(value))), objsht[value]);
				else if (!heavy)
					printf("The %s %s too heavy.\n", objsht[value],(objsht[value][n-1] == 's' ? "are" : "is"));
				else if (!bulky)
					printf("The %s %s too cumbersome to hold.\n", objsht[value],(objsht[value][n-1] == 's' ? "are" : "is"));
				else
					printf("I dont see any %s around here.\n", objsht[value]);
d228 1
a228 2
		wordnumber = first;
		while (wordtype[++wordnumber] == ADJS);
d280 1
a280 2
	while (wordtype[++wordnumber] == ADJS)
		;
d296 2
a297 2
		if (wordtype[wordnumber] == NOUNS) {
			if (value == DOOR)
d300 3
d304 2
d371 1
a371 1
	while (wordtype[++wordnumber] == ADJS);
d374 2
d378 4
d389 1
a389 1
			    objsht[value][strlen(objsht[value]) - 1] == 's' ? "" :
d409 2
a410 3
			}
			else if (ourtime < ate - CYCLE)
				puts("You're stuffed.");
d414 1
a414 1
				printf("You aren't holding the %s.\n", objsht[value]);
@


1.8
log
@Finding bugs in battlestar is like shooting fish in a barrel.
	Don't overflow beenthere[].  Add "verbose" option.
	Fix spelling (including embedded hyphens in descriptions) and grammar.
	"Kill" will now use the laser if you have no cutting implements.
	Formatting.
	You can do more things to the bathing goddess.
	A little less guess-the-word.  Occasionally better error messages,
particularly with "all" when nothing applies.
	"kick door" no longer segfaults.  Nor does "kill door".
More bugs remain...
@
text
@d1 1
a1 1
/*	$OpenBSD: com4.c,v 1.7 1999/09/25 20:30:45 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: com4.c,v 1.7 1999/09/25 20:30:45 pjanzen Exp $";
d81 3
a83 1
					printf("You're already holding%s%s.\n", (objsht[value][n-1] == 's' ? " " : " a "), objsht[value]);
d286 13
d332 1
a332 1
				} else
d334 4
d379 1
a379 1
			printf("You can't eat%s%s!\n",
d381 2
a382 2
			    objsht[value][strlen(objsht[value]) - 1] == 's' ? " " : " a ",
			    words[wordnumber]);
@


1.7
log
@Merge 4.4BSD-Lite2 and NetBSD, including improved save file handling of
jsm28@@cam.ac.uk.  Rename setbit() family of macros so as not to conflict
with <sys/param.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: com4.c,v 1.6 1998/09/13 01:30:30 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: com4.c,v 1.6 1998/09/13 01:30:30 pjanzen Exp $";
d144 3
a146 3
				puts("and sharper but far away as if in a dream.  The sound of purling water reaches");
				puts("you from afar.  The mist falls again, and your heart leaps in horror.  The gold");
				puts("freezes your hands and fathomless darkness engulfs your soul.");
d172 1
a172 1
				puts("She bids you to follow her.");
d280 2
a281 1
	while (wordtype[++wordnumber] == ADJS);
d284 3
a286 16
		printf("%s:\n", objsht[value]);
		if (TestBit(inven, value)) {
			ClearBit(inven, value);
			carrying -= objwt[value];
			encumber -= objcumber[value];
			if (value == BOMB) {
				puts("The bomb explodes.  A blinding white light and immense concussion obliterate us.");
				die(0);
			}
			if (value != AMULET && value != MEDALION && value != TALISMAN)
				SetBit(location[position].objects, value);
			else
				tempwiz = 0;
			ourtime++;
			if (*name == 'K')
				puts("Drop kicked.");
d288 1
a288 1
				printf("%s.\n", name);
d290 8
a297 7
			if (*name != 'K') {
				printf("You aren't holding the %s.\n", objsht[value]);
				if (TestBit(location[position].objects, value)) {
					if (*name == 'T')
						puts("Kicked instead.");
					else if (*name == 'G')
						puts("Given anyway.");
d299 21
a319 2
			} else
				puts("Kicked.");
@


1.6
log
@NetBSD merge, numerous patches from jsm28@@cam.ac.uk, spelling fixes, and
correct gid revoke.
@
text
@d1 1
a1 1
/*	$OpenBSD: com4.c,v 1.5 1997/12/16 07:54:23 angelos Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)com4.c	8.1 (Berkeley) 5/31/93";
d41 1
a41 1
static char rcsid[] = "$OpenBSD$";
d67 2
a68 2
			if ((testbit(from, value) || wiz || tempwiz) && heavy && bulky && !testbit(inven, value)) {
				setbit(inven, value);
d72 1
a72 1
				if (testbit(from, value))
d76 1
a76 1
				clearbit(from, value);
d80 1
a80 1
				if (testbit(inven, value))
d100 1
a100 1
			if (testbit(from, SWORD)) {
d104 1
a104 1
			if (testbit(from, TWO_HANDED)) {
d114 1
a114 1
			if (testbit(from, MAID)) {
d119 1
a119 1
			else if (testbit(from, DEADWOOD)) {
d124 1
a124 1
			else if (testbit(from, DEADNATIVE)) {
d129 1
a129 1
			else if (testbit(from, DEADGOD)) {
d141 1
a141 1
			if (testbit(location[position].objects, AMULET)) {
d152 1
a152 1
			if (testbit(location[position].objects, MEDALION)) {
d160 1
a160 1
			if (testbit(location[position].objects, TALISMAN)) {
d167 1
a167 1
			if (testbit(location[position].objects, BATHGOD) && (testbit(wear, AMULET) || testbit(inven, AMULET))) {
d175 1
a175 1
				clearbit(location[position].objects, BATHGOD);
d177 1
a177 1
				if (!testbit(location[position].objects, BATHGOD))
d193 1
a193 1
	char   *name;
d231 2
a232 2
			if (deposit && testbit(location[position].objects, value)) {
				clearbit(location[position].objects, value);
d234 1
a234 1
					setbit(location[deposit].objects, value);
d239 1
a239 1
					setbit(location[deposit].objects, CHAR);
d258 1
a258 1
				if (value == GRENADE && testbit(location[position].objects, value)) {
d274 1
a274 1
	char   *name;
d284 2
a285 2
		if (testbit(inven, value)) {
			clearbit(inven, value);
d293 1
a293 1
				setbit(location[position].objects, value);
d304 1
a304 1
				if (testbit(location[position].objects, value)) {
d365 3
a367 3
			if (testbit(inven, value) && ourtime > ate - CYCLE &&
			    testbit(inven, KNIFE)) {
				clearbit(inven, value);
d377 1
a377 1
			else if (!testbit(inven, KNIFE))
@


1.5
log
@Fix annoying warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: com4.c,v 1.4 1997/09/01 18:13:11 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$NetBSD: com4.c,v 1.3 1995/03/21 15:07:04 cgd Exp $";
d49 1
a49 1
unsigned int from[];
d51 2
a52 2
	int firstnumber, heavy, bulky, value;
	register int n;
d55 1
a55 1
	if (wordnumber < wordcount && wordvalue[wordnumber+1] == OFF){
d58 4
a61 5
		return(cypher());
	}
	else {
		while(wordtype[++wordnumber] == ADJS);
		while(wordnumber<=wordcount && wordtype[wordnumber] == OBJECT){
d64 1
a64 1
			for (n=0; objsht[value][n]; n++);
d67 2
a68 2
			if ((testbit(from,value) || wiz || tempwiz) && heavy && bulky && !testbit(inven,value)){
				setbit(inven,value);
d71 2
a72 2
				btime++;
				if (testbit(from,value))
d76 1
a76 1
				clearbit(from,value);
d79 10
a88 10
			}
			else if (testbit(inven,value))
				printf("You're already holding%s%s.\n", (objsht[value][n-1] == 's' ? " " : " a "),objsht[value]);
			else if (!heavy)
				printf("The %s %s too heavy.\n", objsht[value],(objsht[value][n-1] == 's' ? "are" : "is"));
			else if (!bulky)
				printf("The %s %s too cumbersome to hold.\n", objsht[value],(objsht[value][n-1] == 's' ? "are" : "is"));
			else
				printf("I dont see any %s around here.\n", objsht[value]);
			if (wordnumber < wordcount -1 && wordvalue[++wordnumber] == AND)
d91 1
a91 1
				return(firstnumber);
d94 1
a94 1
			    /* special cases with their own return()'s */
d97 38
a134 13
		switch(wordvalue[wordnumber]){
			
			case SWORD:
				if (testbit(from, SWORD)){
					wordtype[wordnumber--] = OBJECT;
					return(take(from));
				}
				if (testbit(from, TWO_HANDED)){
					wordvalue[wordnumber] = TWO_HANDED;
					wordtype[wordnumber--] = OBJECT;
					return(take(from));
				}
				wordvalue[wordnumber] = BROAD;
d136 3
a138 1
				return(take(from));
d140 10
a149 27
			case BODY:
				if (testbit(from,MAID)){
					wordvalue[wordnumber] = MAID;
					wordtype[wordnumber--] = OBJECT;
					return(take(from));
				}
				else if (testbit(from,DEADWOOD)){
					wordvalue[wordnumber] = DEADWOOD;
					wordtype[wordnumber--] = OBJECT;
					return(take(from));
				}
				else if (testbit(from,DEADNATIVE)){
					wordvalue[wordnumber] = DEADNATIVE;
					wordtype[wordnumber--] = OBJECT;
					return(take(from));
				}
				else if (testbit(from,DEADGOD)){
					wordvalue[wordnumber] = DEADGOD;
					wordtype[wordnumber--] = OBJECT;
					return(take(from));
				}
				else {
					wordvalue[wordnumber] = DEADTIME;
					wordtype[wordnumber--] = OBJECT;
					return(take(from));
				}
				break;
d151 7
a157 10
			case AMULET:
				if (testbit(location[position].objects,AMULET)){
					puts("The amulet is warm to the touch, and its beauty catches your breath.");
					puts("A mist falls over your eyes, but then it is gone.  Sounds seem clearer");
					puts("and sharper but far away as if in a dream.  The sound of purling water reaches");
					puts("you from afar.  The mist falls again, and your heart leaps in horror.  The gold");
					puts("freezes your hands and fathomless darkness engulfs your soul.");
				}
				wordtype[wordnumber--] = OBJECT;
				return(take(from));
d159 6
a164 7
			case MEDALION:
				if (testbit(location[position].objects, MEDALION)){
					puts("The medallion is warm, and it rekindles your spirit with the warmth of life.");
					puts("Your amulet begins to glow as the medallion is brought near to it, and together\nthey radiate.");
				}
				wordtype[wordnumber--] = OBJECT;
				return(take(from));
d166 12
a177 18
			case TALISMAN:
				if (testbit(location[position].objects,TALISMAN)){
					puts("The talisman is cold to the touch, and it sends a chill down your spine.");
				}
				wordtype[wordnumber--] = OBJECT;
				return(take(from));

			case NORMGOD:
				if (testbit(location[position].objects,BATHGOD) && (testbit(wear,AMULET) || testbit(inven,AMULET))){
					puts("She offers a delicate hand, and you help her out of the sparkling springs.");
					puts("Water droplets like liquid silver bedew her golden skin, but when they part");
					puts("from her, they fall as teardrops.  She wraps a single cloth around her and");
					puts("ties it at the waist.  Around her neck hangs a golden amulet.");
					puts("She bids you to follow her.");
					pleasure++;
					followgod = btime;
					clearbit(location[position].objects,BATHGOD);
				} else if (!testbit(location[position].objects,BATHGOD))
d181 1
a181 1
				break;
d183 2
a184 2
			default:
				puts("It doesn't seem to work.");
d188 1
a188 1
	return(firstnumber);
d193 1
a193 1
	char *name;
d196 2
a197 2
	int deposit = 0;
	int first, value;
d200 26
a225 26
	if (drop(name) != -1){
		switch(wordvalue[wordnumber]){
			
			case AHEAD:
				deposit = ahead;
				break;

			case BACK:
				deposit = back;
				break;

			case LEFT:
				deposit = left;
				break;

			case RIGHT:
				deposit = right;
				break;

			case UP:
				deposit = location[position].up * (location[position].access || position == FINAL);
				break;

			case DOWN:
				deposit = location[position].down;
				break;
d229 1
a229 1
		while (wordnumber <= wordcount){
d231 2
a232 2
			if (deposit && testbit(location[position].objects,value)){
				clearbit(location[position].objects,value);
d234 2
a235 2
					setbit(location[deposit].objects,value);
				else{
d237 1
a237 1
					for (n = 0; n < NUMOFWORDS; n ++)
d239 1
a239 1
					setbit(location[deposit].objects,CHAR);
d243 18
a260 13
				switch(deposit){
					case 189:
					case 231:
						puts("The stone door is unhinged.");
						location[189].north = 231;
						location[231].south = 189;
						break;
					case 30:
						puts("The wooden door is blown open.");
						location[30].west = 25;
						break;
					case 31:
						puts("The door is not damaged.");
a261 5
			}
			else if (value == GRENADE && testbit(location[position].objects,value)){
				puts("You are blown into shreds when your grenade explodes.");
				die(0);
			}
d265 1
a265 1
				return(first);
d267 1
a267 1
		return(first);
d269 1
a269 1
	return(first);
d274 1
a274 1
char *name;
d276 2
a277 2
	
	int firstnumber, value;
d280 2
a281 3
	while (wordtype[++wordnumber] == ADJS)
		;
	while (wordnumber<=wordcount && (wordtype[wordnumber] == OBJECT || wordtype[wordnumber] == NOUNS)) {
d284 2
a285 2
		if (testbit(inven,value)){
			clearbit(inven,value);
d288 1
a288 1
			if (value == BOMB){
d293 1
a293 1
				setbit(location[position].objects,value);
d296 1
a296 1
			btime++;
d301 1
a301 2
		}
		else {
d304 1
a304 1
				if (testbit(location[position].objects,value)) {
d316 1
a316 1
			return(firstnumber);
d319 1
a319 1
	return(-1);
d326 1
a326 1
	return(drop("Dropped"));
d333 1
a333 1
	return(wearit());
d339 1
a339 1
	int firstnumber, value;
d342 2
a343 2
	while(wordtype[++wordnumber] == ADJS);
	while(wordnumber <= wordcount){
d345 43
a387 44
		switch(value){
			
			case -1:
				puts("Eat what?");
				return(firstnumber);

			default:
				printf("You can't eat%s%s!\n",
					wordtype[wordnumber] == OBJECT &&
					objsht[value]
					[strlen(objsht[value]) - 1] == 's' ?
					" " : " a ",
					words[wordnumber]);
				return(firstnumber);

			case PAPAYAS:
			case PINEAPPLE:
			case KIWI:
			case COCONUTS:	/* eatable things */
			case MANGO:

				printf("%s:\n",objsht[value]);
				if (testbit(inven,value) && btime > ate - CYCLE && testbit(inven,KNIFE)){
					clearbit(inven,value);
					carrying -= objwt[value];
					encumber -= objcumber[value];
					ate = max(btime,ate) + CYCLE/3;
					snooze += CYCLE/10;
					btime++;
					puts("Eaten.  You can explore a little longer now.");
				}
				else if (btime < ate - CYCLE)
					puts("You're stuffed.");
				else if (!testbit(inven,KNIFE))
					puts("You need a knife.");
				else
					printf("You aren't holding the %s.\n", objsht[value]);
				if (wordnumber < wordcount - 1 && wordvalue[++wordnumber] == AND)
					wordnumber++;
				else
					return(firstnumber);
		} /* end switch */
	} /* end while */
	return(firstnumber);
@


1.4
log
@Remove trailing spaces on lines, use sane pathname sizes, and
use warn instead of perror.
@
text
@d1 1
a1 1
/*	$OpenBSD: com4.c,v 1.3 1997/08/24 21:55:03 deraadt Exp $	*/
d261 1
a261 1
				die();
d292 1
a292 1
				die();
@


1.3
log
@various linux-based patches; from linux people; sent by jsm@@octomino.demon.co.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: com4.c,v 1.2 1997/06/30 19:56:31 kstailey Exp $	*/
d180 1
a180 1
				else 
d265 1
a265 1
			else 
d387 1
a387 1
				else 
@


1.2
log
@tag
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 1
a45 1
#include "externs.h"
d47 1
d72 1
a72 1
				time++;
d176 1
a176 1
					followgod = time;
d192 1
d196 1
a196 1
	int n;
d273 1
d298 1
a298 1
			time++;
d325 1
d332 1
d339 1
d370 1
a370 1
				if (testbit(inven,value) && time > ate - CYCLE && testbit(inven,KNIFE)){
d374 1
a374 1
					ate = max(time,ate) + CYCLE/3;
d376 1
a376 1
					time++;
d379 1
a379 1
				else if (time < ate - CYCLE)
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
