head	1.28;
access;
symbols
	OPENBSD_6_2:1.28.0.4
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.28.0.6
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.2
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.22.0.6
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.21.0.6
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.20.0.10
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.8
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.6
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.18.0.10
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.6
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.12
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.10
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.8
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.6
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.4
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.10.0.8
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.6
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.8.0.6
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2016.03.05.07.47.15;	author tb;	state Exp;
branches;
next	1.27;
commitid	yixxLxeLbJbyGhUZ;

1.27
date	2016.03.04.14.37.28;	author mestre;	state Exp;
branches;
next	1.26;
commitid	mOVebjM6HMDqWNnr;

1.26
date	2016.02.27.12.48.14;	author tb;	state Exp;
branches;
next	1.25;
commitid	srn5mjfSL5oWwiVI;

1.25
date	2016.01.07.16.00.34;	author tb;	state Exp;
branches;
next	1.24;
commitid	IwzFE3fG5RnKTWNh;

1.24
date	2016.01.04.17.33.24;	author mestre;	state Exp;
branches;
next	1.23;
commitid	b21xvsfCGMtCOVrz;

1.23
date	2015.11.21.05.29.42;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	75xaVUS6ay2FsYSe;

1.22
date	2015.02.18.23.16.08;	author tedu;	state Exp;
branches;
next	1.21;
commitid	ZBCGPLTxkxe8whAP;

1.21
date	2013.08.29.20.22.21;	author naddy;	state Exp;
branches;
next	1.20;

1.20
date	2011.04.25.13.30.07;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.27.23.59.27;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.02.15.19.09;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.29.08.52.29;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.08.20.38.29;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.03.03.01.42;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.12.06.21.48.52;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.31.04.21.30;	author pjanzen;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.31.03.40.01;	author pjanzen;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.27.12;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.25.06.37.17;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	99.10.29.03.59.06;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	98.08.19.07.42.24;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	98.03.12.09.09.34;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	98.02.14.20.40.40;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.07.23.20.05.16;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.40.47;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.12.22.20.02.06;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.12.19.22.22.14;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.28;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.28
log
@KNF: wrap three overly long lines. No binary change.
@
text
@/*	$OpenBSD: worms.c,v 1.27 2016/03/04 14:37:28 mestre Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 *
 *	 @@@@@@	    @@@@@@	   @@@@@@@@@@@@@@@@@@@@	  @@@@@@@@@@@@@@@@@@@@@@	 @@@@@@@@@@@@@@@@@@@@@@@@
 *	 @@@@@@	    @@@@@@	  @@@@@@@@@@@@@@@@@@@@@@@@	  @@@@@@@@@@@@@@@@@@@@@@@@	 @@@@@@@@@@@@@@@@@@@@@@@@@@
 *	 @@@@@@	    @@@@@@	 @@@@@@@@	   @@@@@@@@	  @@@@@@@@		 @@@@@@@@ @@@@@@  @@@@@@@@
 *	 @@@@@@   @@@@   @@@@@@	 @@@@@@	    @@@@@@	  @@@@@@		 @@@@@@  @@@@@@   @@@@@@
 *	 @@@@@@  @@@@@@@@  @@@@@@	 @@@@@@	    @@@@@@	  @@@@@@		 @@@@@@  @@@@@@   @@@@@@
 *	 @@@@@@@@ @@@@@@@@ @@@@@@@@	 @@@@@@	    @@@@@@	  @@@@@@		 @@@@@@  @@@@@@   @@@@@@
 *	  @@@@@@@@@@@@@@@@@@@@@@@@	 @@@@@@@@	   @@@@@@@@	  @@@@@@		 @@@@@@  @@@@@@   @@@@@@
 *	   @@@@@@@@	 @@@@@@@@	  @@@@@@@@@@@@@@@@@@@@@@@@	  @@@@@@		 @@@@@@  @@@@@@   @@@@@@
 *	    @@@@	  @@@@	   @@@@@@@@@@@@@@@@@@@@	  @@@@@@		 @@@@@@  @@@@@@   @@@@@@
 *
 *				 Eric P. Scott
 *			  Caltech High Energy Physics
 *				 October, 1980
 *
 */
#include <curses.h>
#include <err.h>
#include <signal.h>
#include <stdlib.h>
#include <termios.h>
#include <unistd.h>

static const struct options {
	int nopts;
	int opts[3];
}
	normal[8] = {
	{ 3, { 7, 0, 1 } },
	{ 3, { 0, 1, 2 } },
	{ 3, { 1, 2, 3 } },
	{ 3, { 2, 3, 4 } },
	{ 3, { 3, 4, 5 } },
	{ 3, { 4, 5, 6 } },
	{ 3, { 5, 6, 7 } },
	{ 3, { 6, 7, 0 } }
},	upper[8] = {
	{ 1, { 1, 0, 0 } },
	{ 2, { 1, 2, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 2, { 4, 5, 0 } },
	{ 1, { 5, 0, 0 } },
	{ 2, { 1, 5, 0 } }
},
	left[8] = {
	{ 0, { 0, 0, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 2, { 2, 3, 0 } },
	{ 1, { 3, 0, 0 } },
	{ 2, { 3, 7, 0 } },
	{ 1, { 7, 0, 0 } },
	{ 2, { 7, 0, 0 } }
},
	right[8] = {
	{ 1, { 7, 0, 0 } },
	{ 2, { 3, 7, 0 } },
	{ 1, { 3, 0, 0 } },
	{ 2, { 3, 4, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 2, { 6, 7, 0 } }
},
	lower[8] = {
	{ 0, { 0, 0, 0 } },
	{ 2, { 0, 1, 0 } },
	{ 1, { 1, 0, 0 } },
	{ 2, { 1, 5, 0 } },
	{ 1, { 5, 0, 0 } },
	{ 2, { 5, 6, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 0, { 0, 0, 0 } }
},
	upleft[8] = {
	{ 0, { 0, 0, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 1, { 3, 0, 0 } },
	{ 2, { 1, 3, 0 } },
	{ 1, { 1, 0, 0 } }
},
	upright[8] = {
	{ 2, { 3, 5, 0 } },
	{ 1, { 3, 0, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 1, { 5, 0, 0 } }
},
	lowleft[8] = {
	{ 3, { 7, 0, 1 } },
	{ 0, { 0, 0, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 1, { 1, 0, 0 } },
	{ 2, { 1, 7, 0 } },
	{ 1, { 7, 0, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 0, { 0, 0, 0 } }
},
	lowright[8] = {
	{ 0, { 0, 0, 0 } },
	{ 1, { 7, 0, 0 } },
	{ 2, { 5, 7, 0 } },
	{ 1, { 5, 0, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 0, { 0, 0, 0 } },
	{ 0, { 0, 0, 0 } }
};

static const char	flavor[] = {
	'O', '*', '#', '$', '%', '0', '@@', '~'
};
static const short	xinc[] = {
	1,  1,  1,  0, -1, -1, -1,  0
}, yinc[] = {
	-1,  0,  1,  1,  1,  0, -1, -1
};
static struct	worm {
	int orientation, head;
	short *xpos, *ypos;
} *worm;

volatile sig_atomic_t sig_caught = 0;

void	 nomem(void);
void	 onsig(int);

int
main(int argc, char *argv[])
{
	int x, y, h, n;
	struct worm *w;
	const struct options *op;
	short *ip;
	int CO, LI, last, bottom, ch, length, number, trail;
	short **ref;
	const char *field, *errstr;
	struct timespec sleeptime;
	struct termios term;
	speed_t speed;
	time_t delay = 0;

	if (pledge("stdio rpath tty", NULL) == -1)
		err(1, "pledge");

	/* set default delay based on terminal baud rate */
	if (tcgetattr(STDOUT_FILENO, &term) == 0 &&
	    (speed = cfgetospeed(&term)) > B9600)
		delay = (speed / B9600) - 1;

	length = 16;
	number = 3;
	trail = ' ';
	field = NULL;
	while ((ch = getopt(argc, argv, "d:fhl:n:t")) != -1)
		switch(ch) {
		case 'd':
			delay = (time_t)strtonum(optarg, 0, 1000, &errstr);
			if (errstr)
				errx(1, "delay (0-1000) is %s: %s", errstr,
				    optarg);
			break;
		case 'f':
			field = "WORM";
			break;
		case 'l':
			length = strtonum(optarg, 2, 1024, &errstr);
			if (errstr)
				errx(1, "length (2-1024) is %s: %s", errstr,
				    optarg);
			break;
		case 'n':
			number = strtonum(optarg, 1, 100, &errstr);
			if (errstr)
				errx(1, "number of worms (1-100) is %s: %s",
				    errstr, optarg);
			break;
		case 't':
			trail = '.';
			break;
		case 'h':
		default:
			(void)fprintf(stderr, "usage: %s [-ft] [-d delay] "
			    "[-l length] [-n number]\n", getprogname());
			return 1;
		}

	/* Convert delay from ms -> ns */
	sleeptime.tv_sec = 0;
	sleeptime.tv_nsec = delay * 500000;
	timespecadd(&sleeptime, &sleeptime, &sleeptime);

	if (!(worm = calloc(number, sizeof(struct worm))))
		nomem();
	initscr();
	curs_set(0);
	CO = COLS;
	LI = LINES;
	last = CO - 1;
	bottom = LI - 1;
	if (!(ip = reallocarray(NULL, LI, CO * sizeof(short))) ||
	    !(ref = calloc(LI, sizeof(short *)))) {
		endwin();
		nomem();
	}
	for (n = 0; n < LI; ++n) {
		ref[n] = ip;
		ip += CO;
	}
	for (ip = ref[0], n = LI * CO; --n >= 0;)
		*ip++ = 0;
	for (n = number, w = &worm[0]; --n >= 0; w++) {
		w->orientation = w->head = 0;
		if (!(ip = calloc(length, sizeof(short)))) {
			endwin();
			nomem();
		}
		w->xpos = ip;
		for (x = length; --x >= 0;)
			*ip++ = -1;
		if (!(ip = calloc(length, sizeof(short)))) {
			endwin();
			nomem();
		}
		w->ypos = ip;
		for (y = length; --y >= 0;)
			*ip++ = -1;
	}

	(void)signal(SIGHUP, onsig);
	(void)signal(SIGINT, onsig);
	(void)signal(SIGQUIT, onsig);
	(void)signal(SIGSTOP, onsig);
	(void)signal(SIGTSTP, onsig);
	(void)signal(SIGTERM, onsig);

	if (field) {
		const char *p = field;

		for (y = LI; --y >= 0;) {
			for (x = CO; --x >= 0;) {
				addch(*p++);
				if (!*p)
					p = field;
			}
			refresh();
		}
	}
	for (;;) {
		refresh();
		if (sig_caught) {
			endwin();
			return 0;
		}
		nanosleep(&sleeptime, NULL);
		for (n = 0, w = &worm[0]; n < number; n++, w++) {
			if ((x = w->xpos[h = w->head]) < 0) {
				mvaddch(y = w->ypos[h] = bottom,
				    x = w->xpos[h] = 0,
				    flavor[n % sizeof(flavor)]);
				ref[y][x]++;
			}
			else
				y = w->ypos[h];
			if (++h == length)
				h = 0;
			if (w->xpos[w->head = h] >= 0) {
				int x1, y1;

				x1 = w->xpos[h];
				y1 = w->ypos[h];
				if (--ref[y1][x1] == 0)
					mvaddch(y1, x1, trail);
			}

			if (x == 0) {
				if (y == 0)
					op = &upleft[w->orientation];
				else if (y == bottom)
					op = &lowleft[w->orientation];
				else
					op = &left[w->orientation];
			} else if (x == last) {
				if (y == 0)
					op = &upright[w->orientation];
				else if (y == bottom)
					op = &lowright[w->orientation];
				else
					op = &right[w->orientation];
			} else {
				if (y == 0)
					op = &upper[w->orientation];
				else if (y == bottom)
					op = &lower[w->orientation];
				else
					op = &normal[w->orientation];
			}

			switch (op->nopts) {
			case 0:
				endwin();
				return(1);
			case 1:
				w->orientation = op->opts[0];
				break;
			default:
				w->orientation =
				    op->opts[arc4random_uniform(op->nopts)];
			}
			mvaddch(y += yinc[w->orientation],
			    x += xinc[w->orientation],
			    flavor[n % sizeof(flavor)]);
			ref[w->ypos[h] = y][w->xpos[h] = x]++;
		}
	}
}

void
onsig(int signo)
{
	sig_caught = 1;
}

void
nomem(void)
{
	errx(1, "not enough memory.");
}
@


1.27
log
@- Convert atoi(3) to strtonum(3)
- Replace hardcoded program string by getprogname(3)
- Remove '?' from getopt(3)'s switch default case (but still keep 'h')

OK tb@@ after his suggestions
@
text
@d1 1
a1 1
/*	$OpenBSD: worms.c,v 1.26 2016/02/27 12:48:14 tb Exp $	*/
d200 2
a201 1
				errx(1, "delay (0-1000) is %s: %s", errstr, optarg);
d209 2
a210 1
				errx(1, "length (2-1024) is %s: %s", errstr, optarg);
d215 2
a216 1
				errx(1, "number of worms (1-100) is %s: %s", errstr, optarg);
@


1.26
log
@Untangle a mess of nested ternary operators.

ok mestre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: worms.c,v 1.25 2016/01/07 16:00:34 tb Exp $	*/
d200 1
a200 1
			    errx(1, "delay (0-1000) is %s: %s", errstr, optarg);
d206 3
a208 2
			if ((length = atoi(optarg)) < 2 || length > 1024)
				errx(1, "invalid length (%d - %d).", 2, 1024);
d211 3
a213 3
			if ((number = atoi(optarg)) < 1 || number > 100)
				errx(1, "invalid number of worms (%d - %d).",
				    1, 100);
d218 1
a218 1
		case '?': case 'h':
d220 2
a221 2
			(void)fprintf(stderr,
			    "usage: worms [-ft] [-d delay] [-l length] [-n number]\n");
@


1.25
log
@Some basic code maintenance in games/

- in main() replace exit with return
- drop some /* NOTREACHED */ lint comments along the way.
- make more use of standard CFLAGS, esp. -Wimplicit-function-declaration
- add and sort some headers when needed
- add straightforward pledges to some programs used at compile time

discussed with and ok mestre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: worms.c,v 1.24 2016/01/04 17:33:24 mestre Exp $	*/
d311 24
a334 1
			op = &(!x ? (!y ? upleft : (y == bottom ? lowleft : left)) : (x == last ? (!y ? upright : (y == bottom ? lowright : right)) : (!y ? upper : (y == bottom ? lower : normal))))[w->orientation];
@


1.24
log
@More cleanup and sorting on header section

OK tb@@ and he also pointed out that for consistency with rest of the tree we
should include termios.h instead of sys/ttydefaults.h, where applicable
@
text
@d1 1
a1 1
/*	$OpenBSD: worms.c,v 1.23 2015/11/21 05:29:42 deraadt Exp $	*/
d221 1
a221 1
			exit(1);
d289 1
a289 1
			exit(0);
@


1.23
log
@pledge the wyrms
@
text
@d1 1
a1 1
/*	$OpenBSD: worms.c,v 1.22 2015/02/18 23:16:08 tedu Exp $	*/
a48 2
#include <sys/types.h>

a51 1
#include <stdio.h>
@


1.22
log
@don't cast function arguments; use reallocarray in one place
@
text
@d1 1
a1 1
/*	$OpenBSD: worms.c,v 1.21 2013/08/29 20:22:21 naddy Exp $	*/
d185 3
@


1.21
log
@replace srandomdev()+random() with the arc4random*() family
tweaks and ok millert@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: worms.c,v 1.20 2011/04/25 13:30:07 millert Exp $	*/
d229 1
a229 1
	if (!(worm = calloc((size_t)number, sizeof(struct worm))))
d237 2
a238 2
	if (!(ip = malloc((size_t)(LI * CO * sizeof(short)))) ||
	    !(ref = calloc((size_t)LI, sizeof(short *)))) {
d250 1
a250 1
		if (!(ip = calloc((size_t)length, sizeof(short)))) {
d257 1
a257 1
		if (!(ip = calloc((size_t)length, sizeof(short)))) {
@


1.20
log
@Fix "-d delay" option and convert to use strtonum()
OK martynas@@ a while ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: worms.c,v 1.19 2009/10/27 23:59:27 deraadt Exp $	*/
a228 1
	srandomdev();
d321 1
a321 1
				    op->opts[(int)random() % op->nopts];
@


1.19
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: worms.c,v 1.18 2007/09/02 15:19:09 deraadt Exp $	*/
d180 2
a181 1
	const char *field;
d184 1
a184 1
	u_int delay = 0;
d198 3
a200 4
			if ((delay = (u_int)strtoul(optarg, (char **)NULL, 10)) < 1
			    || delay > 1000)
				errx(1, "invalid delay (1-1000)");
			delay *= 1000;  /* ms -> us */
d224 5
d292 1
a292 1
		if (delay) usleep(delay);
@


1.18
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: worms.c,v 1.17 2004/11/29 08:52:29 jsg Exp $	*/
a30 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)worms.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: worms.c,v 1.17 2004/11/29 08:52:29 jsg Exp $";
#endif
#endif /* not lint */
@


1.17
log
@ansi. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: worms.c,v 1.16 2004/01/08 20:38:29 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: worms.c,v 1.16 2004/01/08 20:38:29 millert Exp $";
d239 1
a239 1
	if (!(worm = malloc((size_t)number * sizeof(struct worm))))
d248 1
a248 1
	    !(ref = malloc((size_t)(LI * sizeof(short *))))) {
d260 1
a260 1
		if (!(ip = malloc((size_t)(length * sizeof(short))))) {
d267 1
a267 1
		if (!(ip = malloc((size_t)(length * sizeof(short))))) {
@


1.16
log
@Adjust delay based on terminal speed; ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: worms.c,v 1.15 2003/06/03 03:01:42 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: worms.c,v 1.15 2003/06/03 03:01:42 millert Exp $";
d186 1
a186 3
main(argc, argv)
	int argc;
	char *argv[];
d342 1
a342 2
onsig(signo)
	int signo;
d348 1
a348 1
nomem()
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: worms.c,v 1.14 2002/12/06 21:48:52 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: worms.c,v 1.14 2002/12/06 21:48:52 millert Exp $";
d70 1
d197 2
d200 5
@


1.14
log
@Replace things like srandom(time(NULL)) with srandomdev(3).  random(3)
good enough for games but we should at least use a decent seed.
pjanzen@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: worms.c,v 1.13 2002/05/31 04:21:30 pjanzen Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d42 1
a42 1
static char rcsid[] = "$OpenBSD: worms.c,v 1.13 2002/05/31 04:21:30 pjanzen Exp $";
@


1.13
log
@de-register
@
text
@d1 1
a1 1
/*	$OpenBSD: worms.c,v 1.12 2002/05/31 03:40:01 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: worms.c,v 1.12 2002/05/31 03:40:01 pjanzen Exp $";
d236 1
a236 1
	srandom(time((time_t *)NULL));
@


1.12
log
@No dm -> no need to revoke setegid.
@
text
@d1 1
a1 1
/*	$OpenBSD: worms.c,v 1.11 2002/02/16 21:27:12 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: worms.c,v 1.11 2002/02/16 21:27:12 millert Exp $";
d312 1
a312 1
				register int x1, y1;
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: worms.c,v 1.10 2000/01/25 06:37:17 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: worms.c,v 1.10 2000/01/25 06:37:17 pjanzen Exp $";
a200 4

	/* revoke */
	setegid(getgid());
	setgid(getgid());
@


1.10
log
@use only non-deprecated curses (i.e., no termcap) and tidy a little; mostly
from jsm@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: worms.c,v 1.9 1999/10/29 03:59:06 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: worms.c,v 1.9 1999/10/29 03:59:06 pjanzen Exp $";
d185 2
a186 2
void	 nomem __P((void));
void	 onsig __P((int));
@


1.9
log
@srandom() for variety.
@
text
@d1 1
a1 1
/*	$OpenBSD: worms.c,v 1.8 1998/08/19 07:42:24 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: worms.c,v 1.8 1998/08/19 07:42:24 pjanzen Exp $";
a67 1
#include <sys/ioctl.h>
d69 2
a73 2
#include <term.h>
#include <time.h>
d76 1
a76 1
static struct options {
d170 1
a170 4
#define	cursor(c, r)	tputs(tgoto(CM, c, r), 1, fputchar)

char *tcp;
static char	flavor[] = {
d173 1
a173 1
static short	xinc[] = {
d183 3
a185 2
int   fputchar __P((int));
void	 nomem __P(());
d193 5
a197 7
	extern char *UP;
	register int x, y, h, n;
	register struct worm *w;
	register struct options *op;
	register short *ip;
	register char *term;
	int CO, IN, LI, last, bottom, ch, length, number, trail, Wrap;
d199 1
a199 2
	char *AL, *BC, *CM, *EI, *HO, *IC, *IM, *IP, *SR;
	char *field, tcb[100], *mp;
a200 4
	struct termios ti;
#ifdef TIOCGWINSZ
	struct winsize ws;
#endif
d213 3
a215 5
			if ((delay = (u_int)strtoul(optarg,(char **)NULL,10)) < 1
				|| delay > 1000) {
				(void)fprintf(stderr,"worms: invalid delay (1-1000)\n");
				exit(1);
			}
d222 2
a223 6
			if ((length = atoi(optarg)) < 2 || length > 1024) {
				(void)fprintf(stderr,
				    "worms: invalid length (%d - %d).\n",
				     2, 1024);
				exit(1);
			}
d226 3
a228 5
			if ((number = atoi(optarg)) < 1) {
				(void)fprintf(stderr,
				    "worms: invalid number of worms.\n");
				exit(1);
			}
d241 1
a241 6
	if (!(term = getenv("TERM"))) {
		(void)fprintf(stderr, "worms: no TERM environment variable.\n");
		exit(1);
	}
	if (!(worm = malloc((size_t)number *
	    sizeof(struct worm))) || !(mp = malloc((size_t)1024)))
d243 4
a246 34
	if (tgetent(mp, term) <= 0) {
		(void)fprintf(stderr, "worms: %s: unknown terminal type.\n",
		    term);
		exit(1);
	}
	tcp = tcb;
	if (!(CM = tgetstr("cm", &tcp))) {
		(void)fprintf(stderr,
		    "worms: terminal incapable of cursor motion.\n");
		exit(1);
	}
	AL = tgetstr("al", &tcp);
	BC = tgetflag("bs") ? "\b" : tgetstr("bc", &tcp);
	EI = tgetstr("ei", &tcp);
	HO = tgetstr("ho", &tcp);
	IC = tgetstr("ic", &tcp);
	IM = tgetstr("im", &tcp);
	IN = tgetflag("in");
	IP = tgetstr("ip", &tcp);
	SR = tgetstr("sr", &tcp);
	UP = tgetstr("up", &tcp);
#ifdef TIOCGWINSZ
	if (ioctl(fileno(stdout), TIOCGWINSZ, &ws) != -1 &&
	    ws.ws_col && ws.ws_row) {
		CO = ws.ws_col;
		LI = ws.ws_row;
	} else
#endif
	{
		if ((CO = tgetnum("co")) <= 0)
			CO = 80;
		if ((LI = tgetnum("li")) <= 0)
			LI = 24;
	}
d249 3
a251 5
	tcgetattr(fileno(stdout), &ti);
	Wrap = tgetflag("am");
	if (!(ip = malloc((size_t)(LI * CO * sizeof(short)))))
		nomem();
	if (!(ref = malloc((size_t)(LI * sizeof(short *)))))
d253 1
a259 2
	if (Wrap)
		ref[bottom][last] = 1;
d262 2
a263 1
		if (!(ip = malloc((size_t)(length * sizeof(short)))))
d265 1
d269 2
a270 1
		if (!(ip = malloc((size_t)(length * sizeof(short)))))
d272 1
a284 3
	tputs(tgetstr("ti", &tcp), 1, fputchar);
	tputs(tgetstr("cl", &tcp), 1, fputchar);
	tputs(tgetstr("vi", &tcp), 1, fputchar);
d286 1
a286 1
		register char *p = field;
d288 1
a288 1
		for (y = bottom; --y >= 0;) {
d290 1
a290 1
				fputchar(*p++);
d294 1
a294 52
			if (!Wrap)
				fputchar('\n');
			(void)fflush(stdout);
		}
		if (Wrap) {
			if (IM && !IN) {
				for (x = last; --x > 0;) {
					fputchar(*p++);
					if (!*p)
						p = field;
				}
				y = *p++;
				if (!*p)
					p = field;
				fputchar(*p);
				if (BC)
					tputs(BC, 1, fputchar);
				else
					cursor(last - 1, bottom);
				tputs(IM, 1, fputchar);
				if (IC)
					tputs(IC, 1, fputchar);
				fputchar(y);
				if (IP)
					tputs(IP, 1, fputchar);
				tputs(EI, 1, fputchar);
			}
			else if (SR || AL) {
				if (HO)
					tputs(HO, 1, fputchar);
				else
					cursor(0, 0);
				if (SR)
					tputs(SR, 1, fputchar);
				else
					tputs(AL, LI, fputchar);
				for (x = CO; --x >= 0;) {
					fputchar(*p++);
					if (!*p)
						p = field;
				}
			}
			else for (x = last; --x >= 0;) {
				fputchar(*p++);
				if (!*p)
					p = field;
			}
		}
		else for (x = CO; --x >= 0;) {
			fputchar(*p++);
			if (!*p)
				p = field;
d298 5
a302 1
		(void)fflush(stdout);
d306 3
a308 3
				cursor(x = w->xpos[h] = 0,
				     y = w->ypos[h] = bottom);
				fputchar(flavor[n % sizeof(flavor)]);
d320 2
a321 5
				if (--ref[y1][x1] == 0) {
					cursor(x1, y1);
					if (trail)
						fputchar(trail);
				}
d326 2
a327 3
				(void)fflush(stdout);
				abort();
				return(0);
d335 3
a337 4
			cursor(x += xinc[w->orientation],
			    y += yinc[w->orientation]);
			if (!Wrap || x != last || y != bottom)
				fputchar(flavor[n % sizeof(flavor)]);
d347 1
a347 11
	tputs(tgetstr("ve", &tcp), 1, fputchar);
	tputs(tgetstr("cl", &tcp), 1, fputchar);
	tputs(tgetstr("te", &tcp), 1, fputchar);
	exit(0);
}

int
fputchar(c)
	int c;
{
	return(putchar(c));
d353 1
a353 2
	(void)fprintf(stderr, "worms: not enough memory.\n");
	exit(1);
@


1.8
log
@tags, formatting, ANSI-fication, prototypes, de-typos, and the occasional
initialization, removal of unused variable, or other minor fix.  Most
changes are from or inspired by NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: worms.c,v 1.7 1998/03/12 09:09:34 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: worms.c,v 1.7 1998/03/12 09:09:34 pjanzen Exp $";
d74 1
d258 1
@


1.7
log
@OpenBSD ID (changed from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD$";
d187 1
a188 1
void  nomem __P(());
d195 1
a195 2
	extern int optind;
	extern char *optarg, *UP;
a204 1
	long random();
@


1.6
log
@further fixes from pjanzen@@foatdi.harvard.edu
@
text
@d1 1
a1 1
/*	$NetBSD: worms.c,v 1.8 1995/04/22 08:09:22 cgd Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: worms.c,v 1.8 1995/04/22 08:09:22 cgd Exp $";
@


1.5
log
@tabify
@
text
@d73 1
a73 1
#include <termios.h>
d186 1
a186 1
void	 fputchar __P((int));
d188 1
a188 3
char	*tgetstr __P((char *, char **));
char	*tgoto __P((char *, int, int));
int	 tputs __P((char *, int, void (*)(int)));
d207 1
d221 1
a221 1
	while ((ch = getopt(argc, argv, "fl:n:t")) != -1)
d223 8
d252 1
a252 1
		case '?':
d255 1
a255 1
			    "usage: worms [-ft] [-l length] [-n number]\n");
d339 1
d405 1
d433 1
a433 1
				return;
d454 1
d460 1
a460 1
void
d464 1
a464 1
	(void)putchar(c);
d467 1
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d52 9
a60 9
 *	 @@@@@@        @@@@@@    @@@@@@@@@@@@@@@@@@@@     @@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@
 *	 @@@@@@        @@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@
 *	 @@@@@@        @@@@@@  @@@@@@@@      @@@@@@@@   @@@@@@@@           @@@@@@@@ @@@@@@  @@@@@@@@
 *	 @@@@@@   @@@@   @@@@@@  @@@@@@        @@@@@@   @@@@@@            @@@@@@  @@@@@@   @@@@@@
 *	 @@@@@@  @@@@@@@@  @@@@@@  @@@@@@        @@@@@@   @@@@@@            @@@@@@  @@@@@@   @@@@@@
 *	 @@@@@@@@ @@@@@@@@ @@@@@@@@  @@@@@@        @@@@@@   @@@@@@            @@@@@@  @@@@@@   @@@@@@
 *	  @@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@      @@@@@@@@   @@@@@@            @@@@@@  @@@@@@   @@@@@@
 *	   @@@@@@@@  @@@@@@@@     @@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@            @@@@@@  @@@@@@   @@@@@@
 *	    @@@@    @@@@       @@@@@@@@@@@@@@@@@@@@     @@@@@@            @@@@@@  @@@@@@   @@@@@@
@


1.3
log
@proper gid revoke
@
text
@d222 1
a222 1
	while ((ch = getopt(argc, argv, "fl:n:t")) != EOF)
@


1.2
log
@setgid games, not setuid games. closes a neat set of holes
@
text
@d214 2
@


1.1
log
@Initial revision
@
text
@d214 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

