head	1.28;
access;
symbols
	OPENBSD_6_1:1.28.0.4
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.27.0.2
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.6
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.16
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.14
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.12
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.12.0.12
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.8
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.6
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.4
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.6
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.28
date	2016.09.11.14.21.18;	author tb;	state Exp;
branches;
next	1.27;
commitid	vQliJ9M8LCn9g8k6;

1.27
date	2016.03.16.15.00.35;	author mestre;	state Exp;
branches;
next	1.26;
commitid	idQfhcm2r53iTZ8v;

1.26
date	2016.03.07.12.07.57;	author mestre;	state Exp;
branches;
next	1.25;
commitid	NZhYxChmyb9vOEMM;

1.25
date	2016.02.09.13.41.59;	author mestre;	state Exp;
branches;
next	1.24;
commitid	NtssXLmwkGe52RV8;

1.24
date	2016.02.02.19.18.57;	author mestre;	state Exp;
branches;
next	1.23;
commitid	UOR2Pzdvvejn8EXU;

1.23
date	2016.01.07.16.00.33;	author tb;	state Exp;
branches;
next	1.22;
commitid	IwzFE3fG5RnKTWNh;

1.22
date	2016.01.04.17.33.24;	author mestre;	state Exp;
branches;
next	1.21;
commitid	b21xvsfCGMtCOVrz;

1.21
date	2016.01.03.14.38.17;	author mestre;	state Exp;
branches;
next	1.20;
commitid	Ptgw9rNvmSHNRfGy;

1.20
date	2015.12.02.18.52.23;	author tb;	state Exp;
branches;
next	1.19;
commitid	XmUHGScdwBtHuGnX;

1.19
date	2015.12.02.18.46.13;	author tb;	state Exp;
branches;
next	1.18;
commitid	ryHp6FuqT4VdmpbA;

1.18
date	2015.11.29.14.31.01;	author tb;	state Exp;
branches;
next	1.17;
commitid	JfpmcU0Wot8dMCT8;

1.17
date	2015.11.27.09.37.56;	author tb;	state Exp;
branches;
next	1.16;
commitid	56ZxatNcgjaakBrl;

1.16
date	2014.11.16.04.49.49;	author guenther;	state Exp;
branches;
next	1.15;
commitid	8XNajyb9IqHkZEKg;

1.15
date	2013.08.29.20.22.20;	author naddy;	state Exp;
branches;
next	1.14;

1.14
date	2009.11.13.21.50.12;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.27.23.59.27;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.02.15.23.48;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.15.17.57.57;	author dhill;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.01.02.43.12;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.10.07.26.24;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.03.03.01.41;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.06.21.48.51;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.23.03.01.13;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.27.11;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.18.23.53.29;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.18.16.03.02;	author pjanzen;	state Exp;
branches;
next	1.2;

1.2
date	99.04.20.23.01.12;	author pjanzen;	state Exp;
branches;
next	1.1;

1.1
date	99.03.13.02.08.10;	author pjanzen;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Callers of time(3) should #include <time.h>.

ok deraadt
@
text
@/*	$OpenBSD: snake.c,v 1.27 2016/03/16 15:00:35 mestre Exp $	*/
/*	$NetBSD: snake.c,v 1.8 1995/04/29 00:06:41 mycroft Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * snake - crt hack game.
 *
 * You move around the screen with arrow keys trying to pick up money
 * without getting eaten by the snake.  hjkl work as in vi in place of
 * arrow keys.  You can leave at the exit any time.
 *
 * compile as follows:
 *	cc -O snake.c move.c -o snake -lm -lcurses
 */

#include <curses.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <math.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <time.h>
#include <unistd.h>

#ifdef	DEBUG
#define	cashvalue	(loot-penalty)/25
#else
#define	cashvalue	chunk*(loot-penalty)/25
#endif

struct point {
	int col, line;
};

#define	same(s1, s2)	((s1)->line == (s2)->line && (s1)->col == (s2)->col)

#define PENALTY	10	/* % penalty for invoking spacewarp     */

#define ME		'I'
#define SNAKEHEAD	'S'
#define SNAKETAIL	's'
#define TREASURE	'$'
#define GOAL		'#'

#define TOPN	10	/* top scores to print if you lose */
#define SCORES_ENTRIES (TOPN + 1)

#define pchar(point, c)	mvaddch((point)->line + 1, (point)->col + 1, (c))
/* Can't use terminal timing to do delay, in light of X */
#define delay(t)	usleep((t) * 50000)
/* Delay units are 1/20 s */

struct point you;
struct point money;
struct point finish;
struct point snake[6];

int	 lcnt, ccnt;	/* user's idea of screen size */
int	 chunk;		/* amount of money given at a time */
int	 loot, penalty;
int	 moves;
int	 fast = 1;

struct highscore {
	char	name[LOGIN_NAME_MAX];
	short	score;
} scores[SCORES_ENTRIES];
int	 nscores;

char	 scorepath[PATH_MAX];
FILE	*sf;
int	 rawscores;

#ifdef LOGGING
FILE	*logfile;
char	 logpath[PATH_MAX];
#endif

void	chase(struct point *, struct point *);
int	chk(struct point *);
void	drawbox(void);
void	length(int);
void	mainloop(void);
int	post(int, int);
int	pushsnake(void);
int	readscores(int);
void	setup(void);
void	snap(void);
void	snrand(struct point *);
void	snscore(int);
void	spacewarp(int);
void	stop(int);
int	stretch(struct point *);
void	surround(struct point *);
void	suspend(void);
void	win(struct point *);
void	winnings(int);

#ifdef LOGGING
void	logit(char *);
#endif

int	wantstop;

int
main(int argc, char *argv[])
{
	struct	sigaction sa;
	int	ch, i;

	if (pledge("stdio rpath wpath cpath tty", NULL) == -1)
		err(1, "pledge");

#ifdef LOGGING
	const char	*home;

	home = getenv("HOME");
	if (home == NULL || *home == '\0')
		err(1, "getenv");

	snprintf(logpath, sizeof(logpath), "%s/%s", home, ".snake.log");
	logfile = fopen(logpath, "a");
#endif

	while ((ch = getopt(argc, argv, "hl:stw:")) != -1)
		switch ((char)ch) {
		case 'w':	/* width */
			ccnt = strtonum(optarg, 1, INT_MAX, NULL);
			break;
		case 'l':	/* length */
			lcnt = strtonum(optarg, 1, INT_MAX, NULL);
			break;
		case 's': /* score */
			if (readscores(0))
				snscore(0);
			else
				printf("no scores so far\n");
			return 0;
			break;
		case 't': /* slow terminal */
			fast = 0;
			break;
		case 'h':
		default:
			fprintf(stderr, "usage: %s [-st] [-l length] "
			    "[-w width]\n", getprogname());
			return 1;
		}

	readscores(1);
	penalty = loot = 0;
	initscr();
#ifdef KEY_LEFT
	keypad(stdscr, TRUE);
#endif
	nonl();
	cbreak();
	noecho();

	if (!lcnt || lcnt > LINES - 2)
		lcnt = LINES - 2;
	if (!ccnt || ccnt > COLS - 3)
		ccnt = COLS - 3;

	i = lcnt < ccnt ? lcnt : ccnt;
	if (i < 4) {
		endwin();
		errx(1, "screen too small for a fair game.");
	}
	/*
	 * chunk is the amount of money the user gets for each $.
	 * The formula below tries to be fair for various screen sizes.
	 * We only pay attention to the smaller of the 2 edges, since
	 * that seems to be the bottleneck.
	 * This formula is a hyperbola which includes the following points:
	 *	(24, $25)	(original scoring algorithm)
	 *	(12, $40)	(experimentally derived by the "feel")
	 *	(48, $15)	(a guess)
	 * This will give a 4x4 screen $99/shot.  We don't allow anything
	 * smaller than 4x4 because there is a 3x3 game where you can win
	 * an infinite amount of money.
	 */
	if (i < 12)
		i = 12;	/* otherwise it isn't fair */
	/*
	 * Compensate for border.  This really changes the game since
	 * the screen is two squares smaller but we want the default
	 * to be $25, and the high scores on small screens were a bit
	 * much anyway.
	 */
	i += 2;
	chunk = (675.0 / (i + 6)) + 2.5;	/* min screen edge */

	memset(&sa, 0, sizeof sa);
	sigemptyset(&sa.sa_mask);
	sa.sa_handler = stop;
	sigaction(SIGINT, &sa, NULL);

	snrand(&finish);
	snrand(&you);
	snrand(&money);
	snrand(&snake[0]);

	for (i = 1; i < 6; i++)
		chase(&snake[i], &snake[i - 1]);
	setup();
	mainloop();
	return 0;
}

/* Main command loop */
void
mainloop(void)
{
	int	k;
	int	c, lastc = 0;
	int repeat = 1;

	for (;;) {
		if (wantstop) {
			endwin();
			length(moves);
			exit(0);
		}

		/* Highlight you, not left & above */
		move(you.line + 1, you.col + 1);
		refresh();
		if (((c = getch()) <= '9') && (c >= '0')) {
			repeat = c - '0';
			while (((c = getch()) <= '9') && (c >= '0'))
				repeat = 10 * repeat + (c - '0');
		} else {
			if (c != '.')
				repeat = 1;
		}
		if (c == '.')
			c = lastc;
		if (!fast)
			flushinp();
		lastc = c;

		switch (c) {
		case CTRL('z'):
			suspend();
			continue;
		case '\044':
		case 'x':
		case 0177:	/* del or end of file */
		case ERR:
			endwin();
			length(moves);
#ifdef LOGGING
			logit("quit");
#endif
			exit(0);
		case CTRL('l'):
			setup();
			winnings(cashvalue);
			continue;
		case 'p':
		case 'd':
			snap();
			continue;
		case 'w':
			spacewarp(0);
			continue;
		case 'A':
			repeat = you.col;
			c = 'h';
			break;
		case 'H':
		case 'S':
			repeat = you.col - money.col;
			c = 'h';
			break;
		case 'T':
			repeat = you.line;
			c = 'k';
			break;
		case 'K':
		case 'E':
			repeat = you.line - money.line;
			c = 'k';
			break;
		case 'P':
			repeat = ccnt - 1 - you.col;
			c = 'l';
			break;
		case 'L':
		case 'F':
			repeat = money.col - you.col;
			c = 'l';
			break;
		case 'B':
			repeat = lcnt - 1 - you.line;
			c = 'j';
			break;
		case 'J':
		case 'C':
			repeat = money.line - you.line;
			c = 'j';
			break;
		}
		for (k = 1; k <= repeat; k++) {
			moves++;
			switch (c) {
			case 's':
			case 'h':
#ifdef KEY_LEFT
			case KEY_LEFT:
#endif
			case '\b':
				if (you.col > 0) {
					if ((fast) || (k == 1))
						pchar(&you, ' ');
					you.col--;
					if ((fast) || (k == repeat) ||
					    (you.col == 0))
						pchar(&you, ME);
				}
				break;
			case 'f':
			case 'l':
#ifdef KEY_RIGHT
			case KEY_RIGHT:
#endif
			case ' ':
				if (you.col < ccnt - 1) {
					if ((fast) || (k == 1))
						pchar(&you, ' ');
					you.col++;
					if ((fast) || (k == repeat) ||
					    (you.col == ccnt - 1))
						pchar(&you, ME);
				}
				break;
			case CTRL('p'):
			case 'e':
			case 'k':
#ifdef KEY_UP
			case KEY_UP:
#endif
			case 'i':
				if (you.line > 0) {
					if ((fast) || (k == 1))
						pchar(&you, ' ');
					you.line--;
					if ((fast) || (k == repeat) ||
					    (you.line == 0))
						pchar(&you, ME);
				}
				break;
			case CTRL('n'):
			case 'c':
			case 'j':
#ifdef KEY_DOWN
			case KEY_DOWN:
#endif
			case '\n':
			case '\r':
			case 'm':
				if (you.line + 1 < lcnt) {
					if ((fast) || (k == 1))
						pchar(&you, ' ');
					you.line++;
					if ((fast) || (k == repeat) ||
					    (you.line == lcnt - 1))
						pchar(&you, ME);
				}
				break;
			}

			if (same(&you, &money)) {
				loot += 25;
				if (k < repeat)
					pchar(&you, ' ');
				do {
					snrand(&money);
				} while ((money.col == finish.col &&
				    money.line == finish.line) ||
				    (money.col < 5 && money.line == 0) ||
				    (money.col == you.col &&
				    money.line == you.line));
				pchar(&money, TREASURE);
				winnings(cashvalue);
/*				continue;		 Previously, snake missed a turn! */
			}
			if (same(&you, &finish)) {
				win(&finish);
				flushinp();
				endwin();
				printf("You have won with $%d.\n", cashvalue);
				fflush(stdout);
#ifdef LOGGING
				logit("won");
#endif
				length(moves);
				post(cashvalue, 1);
				close(rawscores);
				exit(0);
			}
			if (pushsnake())
				break;
		}
	}
}

/* set up the board */
void
setup(void)
{
	int	i;

	erase();
	pchar(&you, ME);
	pchar(&finish, GOAL);
	pchar(&money, TREASURE);
	for (i = 1; i < 6; i++) {
		pchar(&snake[i], SNAKETAIL);
	}
	pchar(&snake[0], SNAKEHEAD);
	drawbox();
	refresh();
}

void
drawbox(void)
{
	int i;

	for (i = 1; i <= ccnt; i++) {
		mvaddch(0, i, '-');
		mvaddch(lcnt + 1, i, '-');
	}
	for (i = 0; i <= lcnt + 1; i++) {
		mvaddch(i, 0, '|');
		mvaddch(i, ccnt + 1, '|');
	}
}

void
snrand(struct point *sp)
{
	struct point p;
	int i;

	for (;;) {
		p.col = arc4random_uniform(ccnt);
		p.line = arc4random_uniform(lcnt);

		/* make sure it's not on top of something else */
		if (p.line == 0 && p.col < 5)
			continue;
		if (same(&p, &you))
			continue;
		if (same(&p, &money))
			continue;
		if (same(&p, &finish))
			continue;
		for (i = 0; i < 6; i++)
			if (same(&p, &snake[i]))
				break;
		if (i < 6)
			continue;
		break;
	}
	*sp = p;
}

int
post(int iscore, int flag)
{
	struct  highscore tmp;
	int	rank = nscores;
	short	oldbest = 0;

	/* I want to printf() the scores for terms that clear on endwin(),
	 * but this routine also gets called with flag == 0 to see if
	 * the snake should wink.  If (flag) then we're at game end and
	 * can printf.
	 */
	if (flag == 0) {
		if (nscores > 0)
			return (iscore > scores[nscores - 1].score);
		else
			return (iscore > 0);
	}

	if (nscores > 0) {
		oldbest = scores[0].score;
		scores[nscores].score = iscore;
		if (nscores < TOPN)
			nscores++;
	} else {
		nscores = 1;
		scores[0].score = iscore;
		oldbest = 0;
	}

	/* Insert this joker's current score */
	while (rank-- > 0 && iscore > scores[rank].score) {
		memcpy(&tmp, &scores[rank], sizeof(struct highscore));
		memcpy(&scores[rank], &scores[rank + 1],
		    sizeof(struct highscore));
		memcpy(&scores[rank + 1], &tmp, sizeof(struct highscore));
	}

	if (rank++ < 0)
		printf("\nYou bettered your previous best of $%d\n", oldbest);
	else if (rank < nscores)
		printf("\nYour score of $%d is ranked %d of all times!\n",
		    iscore, rank + 1);

	if (fseek(sf, 0L, SEEK_SET) == -1)
		err(1, "fseek");
	if (fwrite(scores, sizeof(scores[0]), nscores, sf) < (u_int)nscores)
		err(1, "fwrite");
	if (fclose(sf))
		err(1, "fclose");

	/* See if we have a new champ */
	snscore(TOPN);
	return(1);
}

const int	mx[8] = { 0, 1, 1, 1, 0,-1,-1,-1};
const int	my[8] = {-1,-1, 0, 1, 1, 1, 0,-1};
const float	absv[8] = {1, 1.4, 1, 1.4, 1, 1.4, 1, 1.4};
int	oldw = 0;

void
chase(struct point *np, struct point *sp)
{
	/* this algorithm has bugs; otherwise the snake would get too good */
	struct point d;
	int	w, i, wt[8];
	double	v1, v2, vp, max;

	d.col = you.col-sp->col;
	d.line = you.line-sp->line;
	v1 = sqrt((double)(d.col * d.col + d.line * d.line) );
	w  = 0;
	max = 0;
	for (i = 0; i < 8; i++) {
		vp = d.col * mx[i] + d.line * my[i];
		v2 = absv[i];
		if (v1 > 0)
			vp = ((double)vp) / (v1 * v2);
		else
			vp = 1.0;
		if (vp > max) {
			max = vp;
			w = i;
		}
	}
	for (i = 0; i < 8; i++) {
		d.col = sp->col + mx[i];
		d.line = sp->line + my[i];
		wt[i] = 0;
		if (d.col < 0 || d.col >= ccnt || d.line < 0 || d.line >= lcnt)
			continue;
		/*
		 * Change to allow snake to eat you if you're on the money;
		 * otherwise, you can just crouch there until the snake goes
		 * away.  Not positive it's right.
		 *
		 * if (d.line == 0 && d.col < 5) continue;
		 */
		if (same(&d, &money) || same(&d,&finish))
			continue;
		wt[i] = (i == w ? loot/10 : 1);
		if (i == oldw)
			wt[i] += loot/20;
	}
	for (w = i = 0; i < 8; i++)
		w += wt[i];
	vp = arc4random_uniform(w);
	for (i = 0; i < 8; i++)
		if (vp < wt[i])
			break;
		else
			vp -= wt[i];
	if (i == 8) {
		printw("failure\n");
		i = 0;
		while (wt[i] == 0)
			i++;
	}
	oldw = w = i;
	np->col = sp->col + mx[w];
	np->line = sp->line + my[w];
}

void
spacewarp(int w)
{
	struct point p;
	int	j;
	const char  *str;

	snrand(&you);
	p.col = COLS / 2 - 8;
	p.line = LINES / 2 - 1;
	if (p.col < 0)
		p.col = 0;
	if (p.line < 0)
		p.line = 0;
	if (w) {
		str = "BONUS!!!";
		loot = loot - penalty;
		penalty = 0;
	} else {
		str = "SPACE WARP!!!";
		penalty += loot / PENALTY;
	}
	for (j = 0; j < 3; j++) {
		erase();
		refresh();
		delay(5);
		mvaddstr(p.line + 1, p.col + 1, str);
		refresh();
		delay(10);
	}
	setup();
	winnings(cashvalue);
}

void
snap(void)
{

	/* I don't see the graphical purpose of the next block of code.
	 * It just makes no sense.
	 *
	 * struct point p;
	 *
	 * if (you.line < 3)
	 *	pchar(point(&p, you.col, 0), '-');
	 * if (you.line > lcnt - 4)
	 *	pchar(point(&p, you.col, lcnt - 1), '_');
	 * if(you.col < 10)
	 *	pchar(point(&p, 0, you.line), '(');
	 * if(you.col > ccnt-10)
	 *	pchar(point(&p, ccnt-1, you.line), ')');
	 */
	if (!stretch(&money))
		if (!stretch(&finish)) {
			pchar(&you, '?');
			refresh();
			delay(10);
			pchar(&you, ME);
		}
	/* Again, I don't see the point of the following either.
	 *
	 * if (you.line < 3) {
	 * 	point(&p, you.col, 0);
	 * 	chk(&p);
	 * }
	 * if (you.line > lcnt - 4) {
	 * 	point(&p, you.col, lcnt - 1);
	 * 	chk(&p);
	 * }
	 * if (you.col < 10) {
	 * 	point(&p, 0, you.line);
	 * 	chk(&p);
	 * }
	 * if (you.col > ccnt-10) {
	 * 	point(&p, ccnt - 1, you.line);
	 * 	chk(&p);
	 * }
	 */
	refresh();
}

int
stretch(struct point *ps)
{
	struct point p;

	p.col = you.col;
	p.line = you.line;
	if ((abs(ps->col - you.col) < (ccnt / 12)) && (you.line != ps->line)) {
		if (you.line < ps->line) {
			for (p.line = you.line + 1; p.line <= ps->line; p.line++)
				pchar(&p, 'v');
			refresh();
			delay(10);
			for (; p.line > you.line; p.line--)
				chk(&p);
		} else {
			for (p.line = you.line - 1; p.line >= ps->line; p.line--)
				pchar(&p, '^');
			refresh();
			delay(10);
			for (; p.line < you.line; p.line++)
				chk(&p);
		}
		return(1);
	} else if ((abs(ps->line - you.line) < (lcnt / 7)) && (you.col != ps->col)) {
		p.line = you.line;
		if (you.col < ps->col) {
			for (p.col = you.col + 1; p.col <= ps->col; p.col++)
				pchar(&p, '>');
			refresh();
			delay(10);
			for (; p.col > you.col; p.col--)
				chk(&p);
		} else {
			for (p.col = you.col - 1; p.col >= ps->col; p.col--)
				pchar(&p, '<');
			refresh();
			delay(10);
			for (; p.col < you.col; p.col++)
				chk(&p);
		}
		return(1);
	}
	return(0);
}

void
surround(struct point *ps)
{
	int	j;

	if (ps->col == 0)
		ps->col++;
	if (ps->line == 0)
		ps->line++;
	if (ps->line == LINES - 1)
		ps->line--;
	if (ps->col == COLS - 1)
		ps->col--;
	mvaddstr(ps->line, ps->col, "/*\\");
	mvaddstr(ps->line + 1, ps->col, "* *");
	mvaddstr(ps->line + 2, ps->col, "\\*/");
	for (j = 0; j < 20; j++) {
		pchar(ps, '@@');
		refresh();
		delay(1);
		pchar(ps, ' ');
		refresh();
		delay(1);
	}
	if (post(cashvalue, 0)) {
		mvaddstr(ps->line, ps->col, "   ");
		mvaddstr(ps->line + 1, ps->col, "o.o");
		mvaddstr(ps->line + 2, ps->col, "\\_/");
		refresh();
		delay(6);
		mvaddstr(ps->line, ps->col, "   ");
		mvaddstr(ps->line + 1, ps->col, "o.-");
		mvaddstr(ps->line + 2, ps->col, "\\_/");
		refresh();
		delay(6);
	}
	mvaddstr(ps->line, ps->col, "   ");
	mvaddstr(ps->line + 1, ps->col, "o.o");
	mvaddstr(ps->line + 2, ps->col, "\\_/");
	refresh();
	delay(6);
}

void
win(struct point *ps)
{
	struct point x;
	int	j, k;
	int	boxsize;	/* actually diameter of box, not radius */

	boxsize = (fast ? 10 : 4);
	x.col = ps->col;
	x.line = ps->line;
	for (j = 1; j < boxsize; j++) {
		for (k = 0; k < j; k++) {
			pchar(&x, '#');
			x.line--;
		}
		for (k = 0; k < j; k++) {
			pchar(&x, '#');
			x.col++;
		}
		j++;
		for (k = 0; k < j; k++) {
			pchar(&x, '#');
			x.line++;
		}
		for (k = 0; k < j; k++) {
			pchar(&x, '#');
			x.col--;
		}
		refresh();
		delay(1);
	}
}

int
pushsnake(void)
{
	int	i, bonus;
	int	issame = 0;
	struct point tmp;

	/*
	 * My manual says times doesn't return a value.  Furthermore, the
	 * snake should get his turn every time no matter if the user is
	 * on a fast terminal with typematic keys or not.
	 * So I have taken the call to times out.
	 */
	for (i = 4; i >= 0; i--)
		if (same(&snake[i], &snake[5]))
			issame++;
	if (!issame)
		pchar(&snake[5], ' ');
	/* Need the following to catch you if you step on the snake's tail */
	tmp.col = snake[5].col;
	tmp.line = snake[5].line;
	for (i = 4; i >= 0; i--)
		snake[i + 1] = snake[i];
	chase(&snake[0], &snake[1]);
	pchar(&snake[1], SNAKETAIL);
	pchar(&snake[0], SNAKEHEAD);
	for (i = 0; i < 6; i++) {
		if ((same(&snake[i], &you)) || (same(&tmp, &you))) {
			surround(&you);
			i = (cashvalue) % 10;
			bonus = arc4random_uniform(10);
			mvprintw(lcnt + 1, 0, "%d\n", bonus);
			refresh();
			delay(30);
			if (bonus == i) {
				spacewarp(1);
#ifdef LOGGING
				logit("bonus");
#endif
				flushinp();
				return(1);
			}
			flushinp();
			endwin();
			if (loot >= penalty) {
				printf("\nYou and your $%d have been eaten\n", cashvalue);
			} else {
				printf("\nThe snake ate you.  You owe $%d.\n", -cashvalue);
			}
#ifdef LOGGING
			logit("eaten");
#endif
			length(moves);
			snscore(TOPN);
			close(rawscores);
			exit(0);
		}
	}
	return(0);
}

int
chk(struct point *sp)
{
	int	j;

	if (same(sp, &money)) {
		pchar(sp, TREASURE);
		return(2);
	}
	if (same(sp, &finish)) {
		pchar(sp, GOAL);
		return(3);
	}
	if (same(sp, &snake[0])) {
		pchar(sp, SNAKEHEAD);
		return(4);
	}
	for (j = 1; j < 6; j++) {
		if (same(sp, &snake[j])) {
			pchar(sp, SNAKETAIL);
			return(4);
		}
	}
	if ((sp->col < 4) && (sp->line == 0)) {
		winnings(cashvalue);
		if ((you.line == 0) && (you.col < 4))
			pchar(&you, ME);
		return(5);
	}
	if (same(sp, &you)) {
		pchar(sp, ME);
		return(1);
	}
	pchar(sp, ' ');
	return(0);
}

void
winnings(int won)
{
	if (won > 0)
		mvprintw(1, 1, "$%d  ", won);
}

void
stop(int dummy)
{
	wantstop = 1;
}

void
suspend(void)
{
	endwin();
	kill(getpid(), SIGTSTP);
	refresh();
	winnings(cashvalue);
}

void
length(int num)
{
	printf("You made %d moves.\n", num);
}

void
snscore(int topn)
{
	int i;

	if (nscores == 0)
		return;

	printf("%sSnake scores to date:\n", topn > 0 ? "Top " : "");
	for (i = 0; i < nscores; i++)
		printf("%2d.\t$%d\t%s\n", i+1, scores[i].score, scores[i].name);
}

#ifdef LOGGING
void
logit(char *msg)
{
	time_t t;

	if (logfile != NULL) {
		time(&t);
		fprintf(logfile, "%s $%d %dx%d %s %s",
		    getlogin(), cashvalue, lcnt, ccnt, msg, ctime(&t));
		fflush(logfile);
	}
}
#endif

int
readscores(int create)
{
	const char	*home;
	const char	*name;
	const char	*modstr;
	int		 modint;
	int		 ret;

	if (create == 0) {
		modint = O_RDONLY;
		modstr = "r";
	} else {
		modint = O_RDWR | O_CREAT;
		modstr = "r+";
	}

	home = getenv("HOME");
	if (home == NULL || *home == '\0')
		err(1, "getenv");

	ret = snprintf(scorepath, sizeof(scorepath), "%s/%s", home,
	    ".snake.scores");
	if (ret < 0 || ret >= PATH_MAX)
		errc(1, ENAMETOOLONG, "%s/%s", home, ".snake.scores");

	rawscores = open(scorepath, modint, 0666);
	if (rawscores < 0) {
		if (create == 0)
			return 0;
		err(1, "cannot open %s", scorepath);
	}
	if ((sf = fdopen(rawscores, modstr)) == NULL)
		err(1, "cannot fdopen %s", scorepath);
	nscores = fread(scores, sizeof(scores[0]), TOPN, sf);
	if (ferror(sf))
		err(1, "error reading %s", scorepath);

	name = getenv("LOGNAME");
	if (name == NULL || *name == '\0')
		name = getenv("USER");
	if (name == NULL || *name == '\0')
		name = getlogin();
	if (name == NULL || *name == '\0')
		name = "  ???";

	if (nscores > TOPN)
		nscores = TOPN;
	strlcpy(scores[nscores].name, name, sizeof(scores[nscores].name));
	scores[nscores].score = 0;

	return 1;
}
@


1.27
log
@Prefer fseek(3) over rewind(3) since the latter although it also calls fseek
then additionally it calls clearerr(3) deliberately but we want to catch any
error that may happen and this way we couldn't catch it

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.26 2016/03/07 12:07:57 mestre Exp $	*/
d54 1
@


1.26
log
@- General changes:
- Remove -? from getopt(3) options, but still keep (or add) -h where applicable
- Replace hardcoded program strings by getprogname(3)

- Specific changes:
- atc(6): this used -? and -u for usage(), remove both from game and manpage
- bcd(6): use __progname instead of getprogname(3), no need to include stdlib.h
- hunt(6): replace fputs(3) by fprintf(3)

OK tb@@ after his suggestions
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.25 2016/02/09 13:41:59 mestre Exp $	*/
d546 2
a547 1
	rewind(sf);
@


1.25
log
@- Remove parameter fd from snscore() since it's never used
- And while here, fwrite(3) returns size_t whereas nscores is an int, so cast
nscores to u_int. This is a false positive, but silences a compiler warning
with -Wextra -pedantic

tb@@ : "Looks ok to me" after suggestion from him
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.24 2016/02/02 19:18:57 mestre Exp $	*/
a173 1
		case '?':
@


1.24
log
@- Swap atoi(3) for strtonum(3)
- Swap fputs(3) for fprintf(3)
- Use getprogname(3) instead of hardcoded string

OK and help from tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.23 2016/01/07 16:00:33 tb Exp $	*/
d121 1
a121 1
void	snscore(int, int);
d166 1
a166 1
				snscore(rawscores, 0);
d548 1
a548 1
	if (fwrite(scores, sizeof(scores[0]), nscores, sf) < nscores)
d554 1
a554 1
	snscore(rawscores, TOPN);
d882 1
a882 1
			snscore(rawscores, TOPN);
d956 1
a956 1
snscore(int fd, int topn)
@


1.23
log
@Some basic code maintenance in games/

- in main() replace exit with return
- drop some /* NOTREACHED */ lint comments along the way.
- make more use of standard CFLAGS, esp. -Wimplicit-function-declaration
- add and sort some headers when needed
- add straightforward pledges to some programs used at compile time

discussed with and ok mestre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.22 2016/01/04 17:33:24 mestre Exp $	*/
d159 1
a159 1
			ccnt = atoi(optarg);
d162 1
a162 1
			lcnt = atoi(optarg);
d177 2
a178 2
			fputs("usage: snake [-st] [-l length] [-w width]\n",
			    stderr);
@


1.22
log
@More cleanup and sorting on header section

OK tb@@ and he also pointed out that for consistency with rest of the tree we
should include termios.h instead of sys/ttydefaults.h, where applicable
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.21 2016/01/03 14:38:17 mestre Exp $	*/
d169 1
a169 1
			exit(0);
d179 1
a179 1
			exit(1);
d240 1
a240 2
	/* NOT REACHED */
	return(0);
@


1.21
log
@About 13 years ago when the idiom srandom(time()), and sometimes
srandom(time()+getpid()), was changed by srandomdev(), but #include <time.h>
lived up until this day so remove it.

Additionally, earlier than that, 18 years ago, random(6) was one of the first
consumers of arc4random(3) family, and was pulling it from dev/rndvar.h but
these days we pull it from stdlib.h, which is already done, so while here
remove dev/rndvar.h also.

"seems comprehensive to me" deraadt@@ and OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.20 2015/12/02 18:52:23 tb Exp $	*/
a43 3
#include <sys/types.h>
#include <sys/ioctl.h>

a50 1
#include <stdio.h>
@


1.20
log
@KNF: I forgot to join two lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.19 2015/12/02 18:46:13 tb Exp $	*/
a57 1
#include <time.h>
@


1.19
log
@treat getenv("HOME") safely also when LOGGING is defined.  from mestre.

plus fix some ghastly whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.18 2015/11/29 14:31:01 tb Exp $	*/
d157 1
a157 2
	snprintf(logpath, sizeof(logpath), "%s/%s", home,
	    ".snake.log");
@


1.18
log
@Prefer $LOGNAME over $USER, since the latter is deprecated,
see environ(7).  Pointed out by millert@@.  Fall back to getlogin(2)
before defaulting to ???.

looks good to deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.17 2015/11/27 09:37:56 tb Exp $	*/
d144 2
a145 2
	struct   sigaction sa;
	int	 ch, i;
d151 7
a157 1
	snprintf(logpath, sizeof(logpath), "%s/%s", getenv("HOME"),
@


1.17
log
@Fix after removal of the setgid bit:

Add pledge "stdio rpath wpath cpath tty".
Move score file to $HOME, add $USER as high score entry.
Maintain hall of fame of 10 high scores, make snake wink if
it ate you while you were eligible for eternal fame.

Based on an initial diff by Ricardo Mestre and with helpful input from tedu@@.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.16 2014/11/16 04:49:49 guenther Exp $	*/
d988 1
a988 1
	const char	*user;
d1022 7
a1028 3
	user = getenv("USER");
	if (user == NULL || *user == '\0')
		user = "???";
d1032 1
a1032 1
	strlcpy(scores[nscores].name, user, sizeof(scores[nscores].name));
@


1.16
log
@Eliminate pointless use of <sys/param.h>, <sys/file.h>, <sys/sockio.h>,
    and <sys/ttydefaults.h>
Replace MAXPATHLEN with PATH_MAX and MAXLOGNAME with LOGIN_NAME_MAX
Pull in <limits.h> where needed
Prefer sizeof(var) over MAXFOO or FOO_MAX

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.15 2013/08/29 20:22:20 naddy Exp $	*/
d49 1
d51 1
a52 1
#include <pwd.h>
a60 2
#include "pathnames.h"

d81 2
a82 1
#define TOPN	3	/* top scores to print if you lose */
d94 15
a108 3
int	loot, penalty;
int	moves;
int	fast = 1;
a109 1
int rawscores;
d112 1
a114 5
int	lcnt, ccnt;	/* user's idea of screen size */
int	chunk;		/* amount of money given at a time */

void	snscore(int, int);

d122 1
d124 1
d126 1
a126 1
void	snap(void);
d144 5
a148 3
	int	ch, i;
	struct sigaction sa;
	gid_t	gid;
a149 2
	/* don't create the score file if it doesn't exist. */
	rawscores = open(_PATH_RAWSCORES, O_RDWR, 0664);
d151 3
a153 1
	logfile = fopen(_PATH_LOGFILE, "a");
a155 4
	/* revoke privs */
	gid = getgid();
	setresgid(gid, gid, gid);

d165 4
a168 1
			snscore(rawscores, 0);
d182 1
d507 2
a508 1
	short	score = iscore;
a509 1
	uid_t	uid = getuid();
d516 24
a539 4
	if (rawscores == -1) {
		if (flag)
			warnx("Can't open score file %s", _PATH_RAWSCORES);
		return(1);
d541 2
a542 10
	/* Figure out what happened in the past */
	lseek(rawscores, uid * sizeof(short), SEEK_SET);
	read(rawscores, &oldbest, sizeof(short));
	if (!flag)
		return (score > oldbest ? 1 : 0);

	/* Update this jokers best */
	if (score > oldbest) {
		lseek(rawscores, uid * sizeof(short), SEEK_SET);
		write(rawscores, &score, sizeof(short));
d544 9
a552 2
	} else
		printf("\nYour best to date is $%d\n", oldbest);
a553 1
	fsync(rawscores);
d956 13
d983 50
@


1.15
log
@replace srandomdev()+random() with the arc4random*() family
tweaks and ok millert@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.14 2009/11/13 21:50:12 deraadt Exp $	*/
a43 1
#include <sys/param.h>
d186 1
a186 1
	i = MIN(lcnt, ccnt);
@


1.14
log
@no need for seperate snscore command; ok pjanzen
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.13 2009/10/27 23:59:27 deraadt Exp $	*/
a172 1
	srandomdev();
d472 2
a473 2
		p.col = random() % ccnt;
		p.line = random() % lcnt;
d582 1
a582 1
	vp = ((random() >> 6) & 01777) % w;
d832 1
a832 1
			bonus = ((random() >> 8) & 0377) % 10;
@


1.13
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.12 2007/04/02 15:23:48 jmc Exp $	*/
a136 1
	char	*p, **av;
a148 10

	/* check to see if we were called as snscore */
	av = argv;
	p = strrchr(*av, '/');
	if (p++ == NULL)
		p = *av;
	if (strcmp(p,"snscore") == 0) {
		snscore(rawscores, 0);
		exit(0);
	}
@


1.12
log
@tidy up synopsis and usage(); from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.11 2006/03/15 17:57:57 dhill Exp $	*/
a31 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)snake.c	8.2 (Berkeley) 1/7/94";
#else
static char rcsid[] = "$OpenBSD: snake.c,v 1.11 2006/03/15 17:57:57 dhill Exp $";
#endif
#endif /* not lint */
@


1.11
log
@Remove useless getuid() check.

OK moritz@@ jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.10 2005/05/01 02:43:12 djm Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: snake.c,v 1.10 2005/05/01 02:43:12 djm Exp $";
d193 1
a193 1
			fputs("usage: snake [-w width] [-l length] [-s]\n",
@


1.10
log
@use setresgid() to drop privs, it is simply a better and less ambiguous API;
ok deraadt@@ and millert@@ a while ago, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.9 2004/07/10 07:26:24 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: snake.c,v 1.9 2004/07/10 07:26:24 deraadt Exp $";
d525 1
a525 1
	uid_t	uid;
a531 8
	/*
	 * Neg uid cannot have scores recorded.
	 */
	if ((uid = getuid()) < 0) {
		if (flag)
			printf("\nNo saved scores for uid %u.\n", uid);
		return(1);
	}
d630 1
a630 1
	char	*str;
@


1.9
log
@more ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.8 2003/06/03 03:01:41 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: snake.c,v 1.8 2003/06/03 03:01:41 millert Exp $";
d153 1
d162 2
a163 2
	setegid(getgid());
	setgid(getgid());
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.7 2002/12/06 21:48:51 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: snake.c,v 1.7 2002/12/06 21:48:51 millert Exp $";
d148 1
a148 3
main(argc, argv)
	int argc;
	char **argv;
d261 1
a261 1
mainloop()
d459 1
a459 1
setup()
d476 1
a476 1
drawbox()
d491 1
a491 2
snrand(sp)
	struct point *sp;
d520 1
a520 2
post(iscore, flag)
	int	iscore, flag;
d570 1
a570 2
chase(np, sp)
	struct point *sp, *np;
d633 1
a633 2
spacewarp(w)
	int w;
d667 1
a667 1
snap()
d714 1
a714 2
stretch(ps)
	struct point *ps;
d760 1
a760 2
surround(ps)
	struct point *ps;
d803 1
a803 2
win(ps)
	struct point *ps;
d836 1
a836 1
pushsnake()
d897 1
a897 2
chk(sp)
	struct point *sp;
d934 1
a934 2
winnings(won)
	int won;
d941 1
a941 2
stop(dummy)
	int	dummy;
d947 1
a947 1
suspend()
d956 1
a956 2
length(num)
	int num;
d963 1
a963 2
logit(msg)
	char *msg;
@


1.7
log
@Replace things like srandom(time(NULL)) with srandomdev(3).  random(3)
good enough for games but we should at least use a decent seed.
pjanzen@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.6 2002/06/23 03:01:13 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: snake.c,v 1.6 2002/06/23 03:01:13 deraadt Exp $";
@


1.6
log
@uid_t and gid_t are unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.5 2002/02/16 21:27:11 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: snake.c,v 1.5 2002/02/16 21:27:11 millert Exp $";
a157 1
	time_t	tv;
a169 2
	(void)time(&tv);

a181 5
#if 0
		case 'd':
			tv = atol(optarg);  /* set seed */
			break;
#endif
d203 1
a203 1
	srandom((int)tv);
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.4 2001/11/18 23:53:29 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: snake.c,v 1.4 2001/11/18 23:53:29 deraadt Exp $";
d552 1
a552 1
			printf("\nNo saved scores for uid %d.\n", uid);
@


1.4
log
@move racey shit out of signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.3 2001/02/18 16:03:02 pjanzen Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: snake.c,v 1.3 2001/02/18 16:03:02 pjanzen Exp $";
d125 1
a125 1
void	snscore  __P((int, int));
d127 17
a143 17
void	chase    __P((struct point *, struct point *));
int	chk      __P((struct point *));
void	drawbox  __P((void));
void	length   __P((int));
void	mainloop __P((void));
int	post     __P((int, int));
int	pushsnake __P((void));
void	setup    __P((void));
void	snrand   __P((struct point *));
void	snap     __P((void));
void	spacewarp __P((int));
void	stop    __P((int));
int	stretch  __P((struct point *));
void	surround __P((struct point *));
void	suspend  __P((void));
void	win      __P((struct point *));
void	winnings __P((int));
d146 1
a146 1
void	logit   __P((char *));
@


1.3
log
@Convert to curses and tidy some.  Generally based on NetBSD changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.2 1999/04/20 23:01:12 pjanzen Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: snake.c,v 1.2 1999/04/20 23:01:12 pjanzen Exp $";
d149 1
d159 1
d255 4
a258 1
	signal(SIGINT, stop);
d282 6
d967 1
a967 4
	signal(SIGINT, SIG_IGN);
	endwin();
	length(moves);
	exit(0);
@


1.2
log
@jsm28@@cam.ac.uk: place cursor on player, not one over.
@
text
@d1 1
a1 1
/*	$OpenBSD: snake.c,v 1.1 1999/03/13 02:08:10 pjanzen Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: snake.c,v 1.1 1999/03/13 02:08:10 pjanzen Exp $";
d59 1
a59 1
 *	cc -O snake.c move.c -o snake -lm -ltermlib
d63 2
d66 2
a67 1
#include <errno.h>
d69 1
d71 5
a78 1
#include "snake.h"
d81 27
a113 1
int	long tl, tm=0L;
d115 1
a115 8
char	stri[BSIZE];
char	*p;
char	ch, savec;
char	*kl, *kr, *ku, *kd;
int	fast=1;
int	repeat=1;
time_t	tv;
char	*tn;
d122 28
d157 1
a169 1
	srandom((int)tv);
d181 1
a181 1
	while ((ch = getopt(argc, argv, "hl:sw:")) != -1)
d198 3
d209 1
d211 12
a222 1
	getcap();
d226 1
a226 1
		cook();
a253 2
	putpad(TI);	/*	String to begin programs that use cm */
	putpad(KS);	/*	Put terminal in keypad transmit mode */
a259 2
	if (ospeed < 9600 || ((!CM) && (!TA)))
		fast = 0;
d272 3
a274 3
	int	j, k;
	int	c, match, lastc = 0;
	struct point tmp;
d277 7
a283 8
		tmp.col = you.col + 1;
		tmp.line = you.line + 1; /* Highlight you, not left & above */
		move(&tmp);
		fflush(stdout);
		if (((c = getchar() & 0177) <= '9') && (c >= '0')) {
			ungetc(c, stdin);
			j = scanf("%d", &repeat);
			c = getchar() & 0177;
a289 42
		if ((Klength > 0) &&
		    (c == *KL || c == *KR || c == *KU || c == *KD)) {
			savec = c;
			match = 0;
			kl = KL;
			kr = KR;
			ku = KU;
			kd = KD;
			for (j = Klength; j > 0; j--) {
				if (match != 1) {
					match = 0;
					if (*kl++ == c) {
						ch = 'h';
						match++;
					}
					if (*kr++ == c) {
						ch = 'l';
						match++;
					}
					if (*ku++ == c) {
						ch = 'k';
						match++;
					}
					if (*kd++ == c) {
						ch = 'j';
						match++;
					}
					if (match == 0) {
						ungetc(c, stdin);
						ch = savec;
		/* Oops! 
		 * This works if we figure it out on second character.
		 */
						break;
					}
				}
				savec = c;
				if (j != 1)
					c = getchar() & 0177;
			}
			c = ch;
		}
d291 1
a291 1
			flushi();
d293 1
d298 1
a298 1
		case EOT:
d301 2
a302 2
			ll();
			cook();
d356 1
a356 1
		for(k = 1; k <= repeat; k++) {
d361 3
d365 1
a365 1
				if (you.col >0) {
d367 1
a367 1
						pchar(&you,' ');
d369 3
a371 2
					if ((fast) || (k == repeat) || (you.col == 0))
						pchar(&you,ME);
d376 3
d380 1
a380 1
				if (you.col < ccnt-1) {
d384 2
a385 1
					if ((fast) || (k == repeat) || (you.col == ccnt-1))
d392 3
d398 1
a398 1
						pchar(&you,' ');
d400 3
a402 2
					if ((fast) || (k == repeat) || (you.line == 0))
						pchar(&you,ME);
d408 5
a412 1
			case LF:
d414 1
a414 1
				if (you.line+1 < lcnt) {
d416 1
a416 1
						pchar(&you,' ');
d418 3
a420 2
					if ((fast) || (k == repeat) || (you.line == lcnt-1))
						pchar(&you,ME);
d431 5
a435 3
				} while ((money.col == finish.col && money.line == finish.line) ||
					 (money.col < 5 && money.line == 0) ||
					 (money.col == you.col && money.line == you.line));
d440 1
a440 1
			if (same(&you,&finish)) {
d442 2
a443 2
				ll();
				cook();
d445 1
a456 1
		fflush(stdout);
d466 1
a466 1
	clear();
d475 1
a475 1
	fflush(stdout);
a481 1
	struct point p;
d483 7
a489 19
	p.line = -1;
	for (i = 0; i < ccnt; i++) {
		p.col = i;
		pchar(&p, '-');
	}
	p.col = ccnt;
	for (i = -1; i <= lcnt; i++) {
		p.line = i;
		pchar(&p, '|');
	}
	p.col = -1;
	for (i = -1; i <= lcnt; i++) {
		p.line = i;
		pchar(&p, '|');
	}
	p.line = lcnt;
	for (i = 0; i < ccnt; i++) {
		p.col = i;
		pchar(&p, '-');
d528 1
a528 1
	short	oldbest=0;
d531 1
a531 1
	/* I want to printf() the scores for terms that clear on cook(),
d546 1
a546 2
			printf("Can't open score file %s: %s.\n",
			    _PATH_RAWSCORES, strerror(errno));
d569 3
a571 14
/*
 * Flush typeahead to keep from buffering a bunch of chars and then
 * overshooting.  This loses horribly at 9600 baud, but works nicely
 * if the terminal gets behind.
 */
void
flushi()
{
	tcflush(0, TCIFLUSH);
}

int	mx [8] = { 0, 1, 1, 1, 0,-1,-1,-1};
int	my [8] = {-1,-1, 0, 1, 1, 1, 0,-1};
float	absv[8] = {1, 1.4, 1, 1.4, 1, 1.4, 1, 1.4};
d575 1
a575 1
chase (np, sp)
d583 2
a584 1
	point(&d, you.col-sp->col, you.line-sp->line);
d586 1
a586 1
	w  = 0; 
d588 1
a588 2
	for(i = 0; i < 8; i++)
	{
d601 2
a602 1
		point(&d, sp->col + mx[i], sp->line + my[i]);
d616 1
a616 1
		if (i == oldw) 
d621 1
a621 1
	vp = ((rand() >> 6) & 01777) % w;
d628 1
a628 1
		pr("failure\n"); 
d634 2
a635 1
	point(np, sp->col + mx[w], sp->line + my[w]);
d647 2
a648 1
	point(&p, COLUMNS / 2 - 8, LINES / 2 - 1);
d662 2
a663 2
		clear();
		fflush(stdout);
d665 2
a666 2
		apr(&p, str);
		fflush(stdout);
a675 1
	struct point p;
d680 2
d693 2
a694 2
			pchar(point(&p, you.col, you.line), '?');
			fflush(stdout);
d696 1
a696 1
			pchar(point(&p, you.col, you.line), ME);
d717 1
a717 1
	fflush(stdout);
d726 2
a727 1
	point(&p, you.col, you.line);
d732 1
a732 1
			fflush(stdout);
d739 1
a739 1
			fflush(stdout);
d750 1
a750 1
			fflush(stdout);
d757 1
a757 1
			fflush(stdout);
a770 1
	struct point x;
d777 1
a777 1
	if (ps->line == LINES -1)
d779 1
a779 1
	if (ps->col == COLUMNS -1)
d781 3
a783 1
	apr(point(&x, ps->col-1, ps->line-1), "/*\\\r* *\r\\*/");
d786 1
a786 1
		fflush(stdout);
d788 2
a789 2
		pchar(ps,' ');
		fflush(stdout);
d793 4
a796 2
		apr(point(&x, ps->col - 1, ps->line - 1), "   \ro.o\r\\_/");
		fflush(stdout);
d798 4
a801 2
		apr(point(&x,ps->col - 1, ps->line - 1), "   \ro.-\r\\_/");
		fflush(stdout);
d804 5
a808 1
	apr(point(&x, ps->col - 1, ps->line - 1), "   \ro.o\r\\_/");
d816 1
a816 1
	int	j,k;
d820 2
a821 1
	point(&x, ps->col, ps->line);
d840 1
a840 1
		fflush(stdout);
d858 1
a858 1
	for (i = 4; i >=0; i--)
d864 2
a865 1
	tmp.col = snake[5].col; tmp.line = snake[5].line;
d876 2
a877 3
			ll();
			pr("%d\n", bonus);
			fflush(stdout);
d884 1
a884 1
				flushi();
d887 3
a889 2
			cook();
			if ( loot >= penalty ) {
d905 1
a905 1
	
d908 1
a908 1
struct point *sp;
d933 1
a933 1
			pchar(&you,ME);
d948 2
a949 7
	struct point p;

	p.line = p.col = 1;
	if (won > 0) {
		move(&p);
		pr("$%d  ", won);
	}
d957 1
a957 2
	ll();
	cook();
d965 1
a965 2
	ll();
	cook();
d967 1
a967 2
	raw();
	setup();
d975 1
a975 1
	printf("You made %d moves.\n",num);
d989 1
a989 1
		fclose(logfile);
@


1.1
log
@Fix a few bugs (e.g. snake used to miss turns); use usleep() so display
speed is correct on xterms; put snscore functionality inside snake and
make snscore a symbolic link (to be phased out); clean up formatting;
install score file properly; disable the log file by default (logging should
be done through dm).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD$";
d199 1
d208 1
d211 3
a213 1
		move(&you);
@

