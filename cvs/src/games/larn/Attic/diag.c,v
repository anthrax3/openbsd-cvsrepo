head	1.5;
access;
symbols
	OPENBSD_3_2:1.4.0.10
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.8
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2003.03.11.09.29.28;	author deraadt;	state dead;
branches;
next	1.4;

1.4
date	2000.06.29.07.55.40;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	98.09.15.05.12.31;	author pjanzen;	state Exp;
branches;
next	1.2;

1.2
date	97.07.15.10.21.50;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.04;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@OK, this is a strange case.  At least some parts of this software is
copyrighted, and then marked "Copying for Profit is Prohibited", but
the author has passed away.  A number of people have tried to make
some sort of effort at trying to contact his estate, and have failed.
Therefore, lacking the ability to correct this copyright, we must
delete it.  I would bet strongly that this is not what the author
would have intended, but until we can get this resolved, this is the
action we must take.
@
text
@/*	$OpenBSD: diag.c,v 1.4 2000/06/29 07:55:40 pjanzen Exp $	*/
/*	$NetBSD: diag.c,v 1.8 1997/10/18 20:03:12 christos Exp $	*/

/* diag.c		Larn is copyrighted 1986 by Noah Morgan. */
#ifndef lint
static char rcsid[] = "$OpenBSD: diag.c,v 1.4 2000/06/29 07:55:40 pjanzen Exp $";
#endif				/* not lint */

#include <sys/types.h>
#include <sys/times.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <unistd.h>
#include "header.h"
#include "extern.h"

static struct tms cputime;

/*
 *	***************************
 *	DIAG -- dungeon diagnostics
 *	***************************
 *
 *	subroutine to print out data for debugging
 */
#ifdef EXTRA
static int	rndcount[16];
void
diag()
{
	int	i, j;
	int	hit, dam;

	cursors();
	lwclose();
	if (lcreat(diagfile) < 0) {	/* open the diagnostic file	 */
		lcreat((char *) 0);
		lprcat("\ndiagnostic failure\n");
		return (-1);
	}
	write(1, "\nDiagnosing . . .\n", 18);
	lprcat("\n\nBeginning of DIAG diagnostics ----------\n");

	/* for the character attributes	 */

	lprintf("\n\nPlayer attributes:\n\nHit points: %2d(%2d)", (long) c[HP], (long) c[HPMAX]);
	lprintf("\ngold: %d  Experience: %d  Character level: %d  Level in caverns: %d",
	(long) c[GOLD], (long) c[EXPERIENCE], (long) c[LEVEL], (long) level);
	lprintf("\nTotal types of monsters: %d", (long) MAXMONST + 8);

	lprcat("\f\nHere's the dungeon:\n\n");

	i = level;
	for (j = 0; j < MAXLEVEL + MAXVLEVEL; j++) {
		newcavelevel(j);
		lprintf("\nMaze for level %s:\n", levelname[level]);
		diagdrawscreen();
	}
	newcavelevel(i);

	lprcat("\f\nNow for the monster data:\n\n");
	lprcat("   Monster Name      LEV  AC   DAM  ATT  DEF    GOLD   HP     EXP   \n");
	lprcat("--------------------------------------------------------------------------\n");
	for (i = 0; i <= MAXMONST + 8; i++) {
		lprintf("%19s  %2d  %3d ", monster[i].name, (long) monster[i].level, (long) monster[i].armorclass);
		lprintf(" %3d  %3d  %3d  ", (long) monster[i].damage, (long) monster[i].attack, (long) monster[i].defense);
		lprintf("%6d  %3d   %6d\n", (long) monster[i].gold, (long) monster[i].hitpoints, (long) monster[i].experience);
	}

	lprcat("\n\nHere's a Table for the to hit percentages\n");
	lprcat("\n     We will be assuming that players level = 2 * monster level");
	lprcat("\n     and that the players dexterity and strength are 16.");
	lprcat("\n    to hit: if (rnd(22) < (2[monst AC] + your level + dex + WC/8 -1)/2) then hit");
	lprcat("\n    damage = rund(8) + WC/2 + STR - c[HARDGAME] - 4");
	lprcat("\n    to hit:  if rnd(22) < to hit  then player hits\n");
	lprcat("\n    Each entry is as follows:  to hit / damage / number hits to kill\n");
	lprcat("\n          monster     WC = 4         WC = 20        WC = 40");
	lprcat("\n---------------------------------------------------------------");
	for (i = 0; i <= MAXMONST + 8; i++) {
		hit = 2 * monster[i].armorclass + 2 * monster[i].level + 16;
		dam = 16 - c[HARDGAME];
		lprintf("\n%20s   %2d/%2d/%2d       %2d/%2d/%2d       %2d/%2d/%2d",
			monster[i].name,
			(long) (hit / 2), (long) max(0, dam + 2), (long) (monster[i].hitpoints / (dam + 2) + 1),
			(long) ((hit + 2) / 2), (long) max(0, dam + 10), (long) (monster[i].hitpoints / (dam + 10) + 1),
			(long) ((hit + 5) / 2), (long) max(0, dam + 20), (long) (monster[i].hitpoints / (dam + 20) + 1));
	}

	lprcat("\n\nHere's the list of available potions:\n\n");
	for (i = 0; i < MAXPOTION; i++)
		lprintf("%20s\n", &potionhide[i][1]);
	lprcat("\n\nHere's the list of available scrolls:\n\n");
	for (i = 0; i < MAXSCROLL; i++)
		lprintf("%20s\n", &scrollhide[i][1]);
	lprcat("\n\nHere's the spell list:\n\n");
	lprcat("spell          name           description\n");
	lprcat("-------------------------------------------------------------------------------------------\n\n");
	for (j = 0; j < SPNUM; j++) {
		lprc(' ');
		lprcat(spelcode[j]);
		lprintf(" %21s  %s\n", spelname[j], speldescript[j]);
	}

	lprcat("\n\nFor the c[] array:\n");
	for (j = 0; j < 100; j += 10) {
		lprintf("\nc[%2d] = ", (long) j);
		for (i = 0; i < 9; i++)
			lprintf("%5d ", (long) c[i + j]);
	}

	lprcat("\n\nTest of random number generator ----------------");
	lprcat("\n    for 25,000 calls divided into 16 slots\n\n");

	for (i = 0; i < 16; i++)
		rndcount[i] = 0;
	for (i = 0; i < 25000; i++)
		rndcount[rund(16)]++;
	for (i = 0; i < 16; i++) {
		lprintf("  %5d", (long) rndcount[i]);
		if (i == 7)
			lprc('\n');
	}

	lprcat("\n\n");
	lwclose();
	lcreat((char *) 0);
	lprcat("Done Diagnosing . . .");
	return (0);
}
/*
 *	subroutine to count the number of occurrences of an object
 */
int
dcount(l)
	int	l;
{
	int	i, j, p;
	int	k;

	k = 0;
	for (i = 0; i < MAXX; i++)
		for (j = 0; j < MAXY; j++)
			for (p = 0; p < MAXLEVEL; p++)
				if (cell[p * MAXX * MAXY + i * MAXY + j].item == l)
					k++;
	return (k);
}

/*
 *	subroutine to draw the whole screen as the player knows it
 */
void
diagdrawscreen()
{
	int	i, j, k;

	for (i = 0; i < MAXY; i++)
		/* for the east west walls of this line	 */
	{
		for (j = 0; j < MAXX; j++)
			if (k = mitem[j][i])
				lprc(monstnamelist[k]);
			else
				lprc(objnamelist[item[j][i]]);
		lprc('\n');
	}
}
#endif


/*
 *	to save the game in a file
 */
static time_t	zzz = 0;
int
savegame(fname)
	char *fname;
{
	int	i, k;
	struct sphere *sp;
	struct stat	statbuf;

	nosignal = 1;
	lflush();
	savelevel();
	ointerest();
	if (lcreat(fname) < 0) {
		lcreat((char *) 0);
		lprintf("\nCan't open file <%s> to save game\n", fname);
		nosignal = 0;
		return (-1);
	}
	set_score_output();
	lwrite((char *) beenhere, MAXLEVEL + MAXVLEVEL);
	for (k = 0; k < MAXLEVEL + MAXVLEVEL; k++)
		if (beenhere[k])
			lwrite((char *) &cell[k * MAXX * MAXY], sizeof(struct cel) * MAXY * MAXX);
	times(&cputime);	/* get cpu time */
	c[CPUTIME] += (cputime.tms_utime + cputime.tms_stime) / 60;
	lwrite((char *) &c[0], 100 * sizeof(long));
	lprint((long) gltime);
	lprc(level);
	lprc(playerx);
	lprc(playery);
	lwrite((char *) iven, 26);
	lwrite((char *) ivenarg, 26 * sizeof(short));
	for (k = 0; k < MAXSCROLL; k++)
		lprc(scrollname[k][0]);
	for (k = 0; k < MAXPOTION; k++)
		lprc(potionname[k][0]);
	lwrite((char *) spelknow, SPNUM);
	lprc(wizard);
	lprc(rmst);		/* random monster generation counter */
	for (i = 0; i < 90; i++)
		lprc(itm[i].qty);
	lwrite((char *) course, 25);
	lprc(cheat);
	lprc(VERSION);
	for (i = 0; i < MAXMONST; i++)
		lprc(monster[i].genocided);	/* genocide info */
	for (sp = spheres; sp; sp = sp->p)
		lwrite((char *) sp, sizeof(struct sphere));	/* save spheres of
								 * annihilation */
	time(&zzz);
	lprint((long) (zzz - initialtime));
	lwrite((char *) &zzz, sizeof(long));
	if (fstat(lfd, &statbuf) < 0)
		lprint(0L);
	else
		lprint((long) statbuf.st_ino);	/* inode # */
	lwclose();
	lastmonst[0] = 0;
	setscroll();
	lcreat((char *) 0);
	nosignal = 0;
	return (0);
}

void
restoregame(fname)
	char	*fname;
{
	int	i, k;
	struct sphere *sp, *sp2;
	struct stat	filetimes;

	cursors();
	lprcat("\nRestoring . . .");
	lflush();
	if (lopen(fname) <= 0) {
		lcreat((char *) 0);
		lprintf("\nCan't open file <%s>to restore game\n", fname);
		nap(2000);
		c[GOLD] = c[BANKACCOUNT] = 0;
		died(-265);
		return;
	}
	lrfill((char *) beenhere, MAXLEVEL + MAXVLEVEL);
	for (k = 0; k < MAXLEVEL + MAXVLEVEL; k++)
		if (beenhere[k])
			lrfill((char *) &cell[k * MAXX * MAXY], sizeof(struct cel) * MAXY * MAXX);

	lrfill((char *) &c[0], 100 * sizeof(long));
	gltime = lrint();
	level = c[CAVELEVEL] = lgetc();
	playerx = lgetc();
	playery = lgetc();
	lrfill((char *) iven, 26);
	lrfill((char *) ivenarg, 26 * sizeof(short));
	for (k = 0; k < MAXSCROLL; k++)
		scrollname[k] = lgetc() ? scrollhide[k] : "";
	for (k = 0; k < MAXPOTION; k++)
		potionname[k] = lgetc() ? potionhide[k] : "";
	lrfill((char *) spelknow, SPNUM);
	wizard = lgetc();
	rmst = lgetc();		/* random monster creation flag */

	for (i = 0; i < 90; i++)
		itm[i].qty = lgetc();
	lrfill((char *) course, 25);
	cheat = lgetc();
	if (VERSION != lgetc()) {	/* version number  */
		cheat = 1;
		lprcat("Sorry, But your save file is for an older version of larn\n");
		nap(2000);
		c[GOLD] = c[BANKACCOUNT] = 0;
		died(-266);
		return;
	}
	for (i = 0; i < MAXMONST; i++)
		monster[i].genocided = lgetc();	/* genocide info */
	for (sp = 0, i = 0; i < c[SPHCAST]; i++) {
		sp2 = sp;
		sp = (struct sphere *) malloc(sizeof(struct sphere));
		if (sp == 0) {
			write(2, "Can't malloc() for sphere space\n", 32);
			break;
		}
		lrfill((char *) sp, sizeof(struct sphere));	/* get spheres of
								 * annihilation */
		sp->p = 0;	/* null out pointer */
		if (i == 0)
			spheres = sp;	/* beginning of list */
		else
			sp2->p = sp;
	}

	time(&zzz);
	initialtime = zzz - lrint();
	fstat(fd, &filetimes);	/* get the creation and modification time of
				 * file	 */
	lrfill((char *) &zzz, sizeof(long));
	zzz += 6;
	if (filetimes.st_ctime > zzz)
		fsorry();	/* file create time	 */
	else if (filetimes.st_mtime > zzz)
		fsorry();	/* file modify time	 */
	if (c[HP] < 0) {
		died(284);
		return;
	}			/* died a post mortem death */
	oldx = oldy = 0;
	i = lrint();		/* inode # */
	if (i && (filetimes.st_ino != i))
		fsorry();
	lrclose();
	if (strcmp(fname, ckpfile) == 0) {
		if (lappend(fname) < 0)
			fcheat();
		else {
			lprc(' ');
			lwclose();
		}
		lcreat((char *) 0);
	} else if (unlink(fname) < 0)
		fcheat();	/* can't unlink save file */
	/* for the greedy cheater checker	 */
	for (k = 0; k < 6; k++)
		if (c[k] > 99)
			greedy();
	if (c[HPMAX] > 999 || c[SPELLMAX] > 125)
		greedy();
	if (c[LEVEL] == 25 && c[EXPERIENCE] > skill[24]) {	/* if patch up lev 25
								 * player */
		long	tmp;
		tmp = c[EXPERIENCE] - skill[24];	/* amount to go up */
		c[EXPERIENCE] = skill[24];
		raiseexperience((long) tmp);
	}
	getlevel();
	lasttime = gltime;
}

/*
 *	subroutine to not allow greedy cheaters
 */
void
greedy()
{
#if WIZID
	if (wizard)
		return;
#endif

	lprcat("\n\nI am so sorry, but your character is a little TOO good!  Since this\n");
	lprcat("cannot normally happen from an honest game, I must assume that you cheated.\n");
	lprcat("In that you are GREEDY as well as a CHEATER, I cannot allow this game\n");
	lprcat("to continue.\n");
	nap(5000);
	c[GOLD] = c[BANKACCOUNT] = 0;
	died(-267);
	return;
}

/*
 *	subroutine to not allow altered save files and terminate the attempted
 *	restart
 */
void
fsorry()
{
	lprcat("\nSorry, but your savefile has been altered.\n");
	lprcat("However, seeing as I am a good sport, I will let you play.\n");
	lprcat("Be advised though, you won't be placed on the normal scoreboard.");
	cheat = 1;
	nap(4000);
}

/*
 *	subroutine to not allow game if save file can't be deleted
 */
void
fcheat()
{
#if WIZID
	if (wizard)
		return;
#endif

	lprcat("\nSorry, but your savefile can't be deleted.  This can only mean\n");
	lprcat("that you tried to CHEAT by protecting the directory the savefile\n");
	lprcat("is in.  Since this is unfair to the rest of the larn community, I\n");
	lprcat("cannot let you play this game.\n");
	nap(5000);
	c[GOLD] = c[BANKACCOUNT] = 0;
	died(-268);
	return;
}
@


1.4
log
@Prune some obsolete defines, in particular VT100.  Eventually curses will
  replace termios.
Use system-defined limits for path lengths and usernames.
Use strlcpy() for convenience and to avoid a possible buffer overflow or two.
Various small tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: diag.c,v 1.3 1998/09/15 05:12:31 pjanzen Exp $	*/
d6 1
a6 1
static char rcsid[] = "$OpenBSD: diag.c,v 1.3 1998/09/15 05:12:31 pjanzen Exp $";
@


1.3
log
@NetBSD merge; also renamed some functions so as not to conflict with curses
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d6 1
a6 1
static char rcsid[] = "$OpenBSD$";
a232 1
#ifndef VT100
a233 1
#endif	/* VT100 */
@


1.2
log
@gtime var -> gltime var
@
text
@d1 4
d6 2
a7 2
static char rcsid[] = "$NetBSD: diag.c,v 1.6 1995/04/24 12:23:49 cgd Exp $";
#endif /* not lint */
a8 1
/*	diag.c		Larn is copyrighted 1986 by Noah Morgan. */
d12 2
d15 2
a16 3
extern long int initialtime;
extern int rmst,maxitm,lasttime;
extern char nosignal;
d18 1
d20 5
a24 5
	***************************
	DIAG -- dungeon diagnostics
	***************************

	subroutine to print out data for debugging
d27 2
a28 1
static int rndcount[16];
d30 12
a41 10
	{
	register int i,j;
	int hit,dam;
	cursors();  lwclose();
	if (lcreat(diagfile) < 0)	/*	open the diagnostic file	*/
		{
		lcreat((char*)0); lprcat("\ndiagnostic failure\n"); return(-1);
		}

	write(1,"\nDiagnosing . . .\n",18);
d44 1
a44 1
/*	for the character attributes	*/
d46 1
a46 1
	lprintf("\n\nPlayer attributes:\n\nHit points: %2d(%2d)",(long)c[HP],(long)c[HPMAX]);
d48 2
a49 2
		(long)c[GOLD],(long)c[EXPERIENCE],(long)c[LEVEL],(long)level);
	lprintf("\nTotal types of monsters: %d",(long)MAXMONST+8);
d53 2
a54 3
	i=level;
	for (j=0; j<MAXLEVEL+MAXVLEVEL; j++)
		{
d56 1
a56 1
		lprintf("\nMaze for level %s:\n",levelname[level]);
d58 1
a58 1
		}
d64 5
a68 6
	for (i=0; i<=MAXMONST+8; i++)
		{
		lprintf("%19s  %2d  %3d ",monster[i].name,(long)monster[i].level,(long)monster[i].armorclass);
		lprintf(" %3d  %3d  %3d  ",(long)monster[i].damage,(long)monster[i].attack,(long)monster[i].defense);
		lprintf("%6d  %3d   %6d\n",(long)monster[i].gold,(long)monster[i].hitpoints,(long)monster[i].experience);
		}
d79 2
a80 3
	for (i=0; i<=MAXMONST+8; i++)
		{
		hit = 2*monster[i].armorclass+2*monster[i].level+16;
d83 5
a87 5
					monster[i].name,
					(long)(hit/2),(long)max(0,dam+2),(long)(monster[i].hitpoints/(dam+2)+1),
					(long)((hit+2)/2),(long)max(0,dam+10),(long)(monster[i].hitpoints/(dam+10)+1),
					(long)((hit+5)/2),(long)max(0,dam+20),(long)(monster[i].hitpoints/(dam+20)+1));
		}
d90 2
a91 1
	for (i=0; i<MAXPOTION; i++)	lprintf("%20s\n",&potionhide[i][1]);
d93 2
a94 1
	for (i=0; i<MAXSCROLL; i++)	lprintf("%20s\n",&scrollhide[i][1]);
d98 5
a102 5
	for (j=0; j<SPNUM; j++)
		{
		lprc(' ');	lprcat(spelcode[j]);
		lprintf(" %21s  %s\n",spelname[j],speldescript[j]); 
		}
d105 5
a109 4
	for (j=0; j<100; j+=10)
		{
		lprintf("\nc[%2d] = ",(long)j); for (i=0; i<9; i++) lprintf("%5d ",(long)c[i+j]);
		}
d114 8
a121 7
	for (i=0; i<16; i++)  rndcount[i]=0;
	for (i=0; i<25000; i++)	rndcount[rund(16)]++;
	for (i=0; i<16; i++)  { lprintf("  %5d",(long)rndcount[i]); if (i==7) lprc('\n'); }

	lprcat("\n\n");			lwclose();
	lcreat((char*)0);		lprcat("Done Diagnosing . . .");
	return(0);
d123 7
d131 1
a131 1
	subroutine to count the number of occurrences of an object
d133 1
d135 13
a147 11
	int l;
	{
	register int i,j,p;
	int k;
	k=0;
	for (i=0; i<MAXX; i++)
		for (j=0; j<MAXY; j++)
			for (p=0; p<MAXLEVEL; p++)
				if (cell[p*MAXX*MAXY+i*MAXY+j].item == l) k++;
	return(k);
	}
d150 1
a150 1
	subroutine to draw the whole screen as the player knows it
d152 1
d154 5
d160 5
a164 8
	register int i,j,k;

	for (i=0; i<MAXY; i++)

/*	for the east west walls of this line	*/
		{
		for (j=0; j<MAXX; j++)	if (k=mitem[j][i]) lprc(monstnamelist[k]); else
								lprc(objnamelist[item[j][i]]);
a165 1
		}
d167 1
d169 2
a170 1

d172 1
a172 1
	to save the game in a file
d174 2
a175 1
static time_t zzz=0;
d178 8
a185 5
	{
	register int i,k;
	register struct sphere *sp;
	struct stat statbuf;
	nosignal=1;  lflush();	savelevel();
d187 6
a192 6
	if (lcreat(fname) < 0)
		{
		lcreat((char*)0); lprintf("\nCan't open file <%s> to save game\n",fname);
		nosignal=0;  return(-1);
		}

d194 2
a195 2
	lwrite((char*)beenhere,MAXLEVEL+MAXVLEVEL);
	for (k=0; k<MAXLEVEL+MAXVLEVEL; k++)
d197 1
a197 1
			lwrite((char*)&cell[k*MAXX*MAXY],sizeof(struct cel)*MAXY*MAXX);
d199 34
a232 19
	c[CPUTIME] += (cputime.tms_utime+cputime.tms_stime)/60;
	lwrite((char*)&c[0],100*sizeof(long));
	lprint((long)gltime);		lprc(level);
	lprc(playerx);		lprc(playery);
	lwrite((char*)iven,26);	lwrite((char*)ivenarg,26*sizeof(short));
	for (k=0; k<MAXSCROLL; k++)  lprc(scrollname[k][0]);
	for (k=0; k<MAXPOTION; k++)  lprc(potionname[k][0]);
	lwrite((char*)spelknow,SPNUM);		 lprc(wizard);
	lprc(rmst);		/*	random monster generation counter */
	for (i=0; i<90; i++)	lprc(itm[i].qty);
	lwrite((char*)course,25);			lprc(cheat);		lprc(VERSION);
	for (i=0; i<MAXMONST; i++) lprc(monster[i].genocided); /* genocide info */
	for (sp=spheres; sp; sp=sp->p)
		lwrite((char*)sp,sizeof(struct sphere));	/* save spheres of annihilation */
	time(&zzz);			lprint((long)(zzz-initialtime));
	lwrite((char*)&zzz,sizeof(long));
	if (fstat(lfd,&statbuf)< 0) lprint(0L);
	else lprint((long)statbuf.st_ino); /* inode # */
	lwclose();	lastmonst[0] = 0;
d235 5
a239 4
#endif VT100
	lcreat((char*)0);  nosignal=0;
	return(0);
	}
d241 1
d243 19
a261 14
	char *fname;
	{
	register int i,k;
	register struct sphere *sp,*sp2;
	struct stat filetimes;
	cursors(); lprcat("\nRestoring . . .");  lflush();
	if (lopen(fname) <= 0)
		{
		lcreat((char*)0); lprintf("\nCan't open file <%s>to restore game\n",fname);
		nap(2000); c[GOLD]=c[BANKACCOUNT]=0;  died(-265); return;
		}

	lrfill((char*)beenhere,MAXLEVEL+MAXVLEVEL);
	for (k=0; k<MAXLEVEL+MAXVLEVEL; k++)
d263 1
a263 1
			lrfill((char*)&cell[k*MAXX*MAXY],sizeof(struct cel)*MAXY*MAXX);
d265 2
a266 1
	lrfill((char*)&c[0],100*sizeof(long));	gltime = lrint();
d268 18
a285 12
	playerx = lgetc();		playery = lgetc();
	lrfill((char*)iven,26);		lrfill((char*)ivenarg,26*sizeof(short));
	for (k=0; k<MAXSCROLL; k++)  scrollname[k] = lgetc() ? scrollhide[k] : "";
	for (k=0; k<MAXPOTION; k++)  potionname[k] = lgetc() ? potionhide[k] : "";
	lrfill((char*)spelknow,SPNUM);		wizard = lgetc();
	rmst = lgetc();			/*	random monster creation flag */

	for (i=0; i<90; i++)	itm[i].qty = lgetc();
	lrfill((char*)course,25);			cheat = lgetc();
	if (VERSION != lgetc())		/*  version number  */
		{
		cheat=1;
d287 8
a294 6
		nap(2000); c[GOLD]=c[BANKACCOUNT]=0;  died(-266); return;
		}

	for (i=0; i<MAXMONST; i++) monster[i].genocided=lgetc(); /* genocide info */
	for (sp=0,i=0; i<c[SPHCAST]; i++)
		{
d296 13
a308 7
		sp = (struct sphere *)malloc(sizeof(struct sphere));
		if (sp==0) { write(2,"Can't malloc() for sphere space\n",32); break; }
		lrfill((char*)sp,sizeof(struct sphere));	/* get spheres of annihilation */
		sp->p=0;	/* null out pointer */
		if (i==0) spheres=sp;	/* beginning of list */
			else sp2->p = sp;
		}
d311 13
a323 7
	initialtime = zzz-lrint();
	fstat(fd,&filetimes);	/*	get the creation and modification time of file	*/
	lrfill((char*)&zzz,sizeof(long));	zzz += 6;
	if (filetimes.st_ctime > zzz) fsorry();	/*	file create time	*/
	else if (filetimes.st_mtime > zzz) fsorry(); /*	file modify time	*/
	if (c[HP]<0) { died(284); return; }	/* died a post mortem death */

d325 3
a327 2
	i = lrint();  /* inode # */
	if (i && (filetimes.st_ino!=i)) fsorry();
d329 20
a348 13
	if (strcmp(fname,ckpfile) == 0)
		{
		if (lappend(fname) < 0) fcheat();  else { lprc(' '); lwclose(); }
		lcreat((char*)0);
		}
	else if (unlink(fname) < 0) fcheat(); /* can't unlink save file */
/*	for the greedy cheater checker	*/
	for (k=0; k<6; k++) if (c[k]>99) greedy();
	if (c[HPMAX]>999 || c[SPELLMAX]>125) greedy();
	if (c[LEVEL]==25 && c[EXPERIENCE]>skill[24]) /* if patch up lev 25 player */
		{
		long tmp;
		tmp = c[EXPERIENCE]-skill[24]; /* amount to go up */
d350 1
a350 3
		raiseexperience((long)tmp);
		}
	getlevel();  lasttime=gltime;
d352 3
d357 1
a357 1
	subroutine to not allow greedy cheaters
d359 1
d361 1
a361 1
	{
d363 2
a364 1
	if (wizard) return;
d370 6
a375 2
	lprcat("to continue.\n"); nap(5000);  c[GOLD]=c[BANKACCOUNT]=0;  died(-267); return;
	}
d378 2
a379 2
	subroutine to not allow altered save files and terminate the attempted
	restart
d381 1
d383 1
a383 1
	{
d387 3
a389 2
	cheat = 1;	nap(4000);
	}
d392 1
a392 1
	subroutine to not allow game if save file can't be deleted
d394 1
d396 1
a396 1
	{
d398 2
a399 1
	if (wizard) return;
d406 5
a410 2
	nap(5000);  c[GOLD]=c[BANKACCOUNT]=0;  died(-268); return;
	}
@


1.1
log
@Initial revision
@
text
@d174 1
a174 1
	lprint((long)gtime);		lprc(level);
d216 1
a216 1
	lrfill((char*)&c[0],100*sizeof(long));	gtime = lrint();
d274 1
a274 1
	getlevel();  lasttime=gtime;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
