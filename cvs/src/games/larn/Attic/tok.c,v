head	1.7;
access;
symbols
	OPENBSD_3_2:1.6.0.6
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2003.03.11.09.29.28;	author deraadt;	state dead;
branches;
next	1.6;

1.6
date	2001.07.09.07.04.29;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.29.07.55.42;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	99.05.30.02.23.17;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	99.03.27.03.45.50;	author pjanzen;	state Exp;
branches;
next	1.2;

1.2
date	98.09.15.05.12.33;	author pjanzen;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.06;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.06;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.7
log
@OK, this is a strange case.  At least some parts of this software is
copyrighted, and then marked "Copying for Profit is Prohibited", but
the author has passed away.  A number of people have tried to make
some sort of effort at trying to contact his estate, and have failed.
Therefore, lacking the ability to correct this copyright, we must
delete it.  I would bet strongly that this is not what the author
would have intended, but until we can get this resolved, this is the
action we must take.
@
text
@/*	$OpenBSD: tok.c,v 1.6 2001/07/09 07:04:29 deraadt Exp $	*/
/*	$NetBSD: tok.c,v 1.5 1997/10/18 20:03:54 christos Exp $	*/

/* tok.c		Larn is copyrighted 1986 by Noah Morgan. */
#ifndef lint
static char rcsid[] = "$OpenBSD: tok.c,v 1.6 2001/07/09 07:04:29 deraadt Exp $";
#endif				/* not lint */

#include <sys/types.h>
#include <ctype.h>
#include <string.h>
#include <sys/ioctl.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include "header.h"
#include "extern.h"

static char	lastok = 0;
int		yrepcount = 0, dayplay = 0;
#ifndef FLUSHNO
#define FLUSHNO 5
#endif	/* FLUSHNO */
static int	flushno = FLUSHNO;	/* input queue flushing threshold */
#define MAXUM 52		/* maximum number of user re-named monsters */
#define MAXMNAME 40		/* max length of a monster re-name */
static char	usermonster[MAXUM][MAXMNAME];	/* the user named monster
						 * name goes here */
static u_char	usermpoint = 0;	/* the user monster pointer */

/*
	lexical analyzer for larn
 */
int
yylex()
{
	char	cc;
	int	ic;

	if (hit2flag) {
		hit2flag = 0;
		yrepcount = 0;
		return (' ');
	}
	if (yrepcount > 0) {
		--yrepcount;
		return (lastok);
	} else
		yrepcount = 0;
	if (yrepcount == 0) {
		bottomdo();
		showplayer();
	}			/* show where the player is	*/
	lflush();
	while (1) {
		c[BYTESIN]++;
		if (ckpflag)
			if ((c[BYTESIN] % 400) == 0) {	/* check for periodic
							 * checkpointing */
#ifndef DOCHECKPOINTS
				savegame(ckpfile);
#else
				wait(0);	/* wait for other forks to
						 * finish */
				if (fork() == 0) {
					savegame(ckpfile);
					exit(0);
				}
#endif


#ifdef TIMECHECK
				if (dayplay == 0)
					if (playable()) {
						cursor(1, 19);
						lprcat("\nSorry, but it is now time for work.  Your game has been saved.\n");
						lbeep();
						lflush();
						savegame(savefilename);
						wizard = nomove = 1;
						sleep(4);
						died(-257);
					}
#endif	/* TIMECHECK */

			}
		do {		/* if keyboard input buffer is too big, flush
				 * some of it */
			ioctl(0, FIONREAD, &ic);
			if (ic > flushno)
				read(0, &cc, 1);
		}
		while (ic > flushno);

		if (read(0, &cc, 1) != 1)
			return (lastok = -1);

		if (cc == 'Y' - 64) {	/* control Y -- shell escape */
			resetscroll();
			clear();/* scrolling region, home, clear, no
				 * attributes */
			if ((ic = fork()) == 0) {	/* child */
				/* revoke */
				setgid(getgid());
				execl("/bin/csh", (char *)NULL);
				exit(1);
			}
			wait(0);
			if (ic < 0) {	/* error */
				write(2, "Can't fork off a shell!\n", 25);
				sleep(2);
			}
			setscroll();
			return (lastok = 'L' - 64);	/* redisplay screen */
		}
		if ((cc <= '9') && (cc >= '0')) {
			yrepcount = yrepcount * 10 + cc - '0';
		} else {
			if (yrepcount > 0)
				--yrepcount;
			return (lastok = cc);
		}
	}
}

/*
 *	flushall()	Function to flush all type-ahead in the input buffer
 */
void
flushall()
{
	char	cc;
	int	ic;

	for (;;) {		/* if keyboard input buffer is too big, flush
				 * some of it */
		ioctl(0, FIONREAD, &ic);
		if (ic <= 0)
			return;
		while (ic > 0) {
			read(0, &cc, 1);
			--ic;
		}		/* gobble up the byte */
	}
}

/*
 *	function to set the desired hardness
 *	enter with hard= -1 for default hardness, else any desired hardness
 */
void
sethard(hard)
	int	hard;
{
	int	j, k, i;

	j = c[HARDGAME];
	hashewon();
	if (restorflag == 0) {	/* don't set c[HARDGAME] if restoring game */
		if (hard >= 0)
			c[HARDGAME] = hard;
	} else
		c[HARDGAME] = j;/* set c[HARDGAME] to proper value if
				 * restoring game */

	if ((k = c[HARDGAME]) != 0)
		for (j = 0; j <= MAXMONST + 8; j++) {
			i = ((6 + k) * monster[j].hitpoints + 1) / 6;
			monster[j].hitpoints = (i < 0) ? 32767 : i;
			i = ((6 + k) * monster[j].damage + 1) / 5;
			monster[j].damage = (i > 127) ? 127 : i;
			i = (10 * monster[j].gold) / (10 + k);
			monster[j].gold = (i > 32767) ? 32767 : i;
			i = monster[j].armorclass - k;
			monster[j].armorclass = (i < -127) ? -127 : i;
			i = (7 * monster[j].experience) / (7 + k) + 1;
			monster[j].experience = (i <= 0) ? 1 : i;
		}
}

/*
	function to read and process the larn options file
 */
void
readopts()
{
	char	*i;
	int	j, k;
	int	flag;

	flag = 1;		/* set to 0 if he specifies a name for his
				 * character */
	if (lopen(optsfile) < 0) {
		strlcpy(logname, loginname, LOGNAMESIZE);
		return;		/* user name if no character name */
	}
	i = " ";
	while (*i) {
		if ((i = (char *) lgetw()) == 0)
			break;	/* check for EOF */
		while ((*i == ' ') || (*i == '\t'))
			i++;	/* eat leading whitespace */
		switch (*i) {
		case 'b':
			if (strcmp(i, "bold-objects") == 0)
				boldon = 1;
			break;

		case 'e':
			if (strcmp(i, "enable-checkpointing") == 0)
				ckpflag = 1;
			break;

		case 'i':
			if (strcmp(i, "inverse-objects") == 0)
				boldon = 0;
			break;

		case 'f':
			if (strcmp(i, "female") == 0)
				sex = 0;	/* male or female */
			break;

		case 'm':
			if (strcmp(i, "monster:") == 0) {	/* name favorite monster */
				if ((i = lgetw()) == 0)
					break;
				strlcpy(usermonster[usermpoint], i, MAXMNAME);
				if (usermpoint >= MAXUM)
					break;	/* defined all of em */
				if (isalpha(j = usermonster[usermpoint][0])) {
					for (k = 1; k < MAXMONST + 8; k++)	/* find monster */
						if (monstnamelist[k] == j) {
							monster[k].name = &usermonster[usermpoint++][0];
							break;
						}
				}
			} else if (strcmp(i, "male") == 0)
				sex = 1;
			break;

		case 'n':
			if (strcmp(i, "name:") == 0) {	/* defining players name */
				if ((i = lgetw()) == 0)
					break;
				strlcpy(logname, i, LOGNAMESIZE);
				flag = 0;
			} else if (strcmp(i, "no-introduction") == 0)
				nowelcome = 1;
			else if (strcmp(i, "no-beep") == 0)
				nobeep = 1;
			break;

		case 's':
			if (strcmp(i, "savefile:") == 0) {	/* defining savefilename */
				if ((i = lgetw()) == 0)
					break;
				strlcpy(savefilename, i, PATH_MAX);
				flag = 0;
			}
			break;
		};
	}
	if (flag)
		strlcpy(logname, loginname, LOGNAMESIZE);
}
@


1.6
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: tok.c,v 1.5 2000/06/29 07:55:42 pjanzen Exp $	*/
d6 1
a6 1
static char rcsid[] = "$OpenBSD: tok.c,v 1.5 2000/06/29 07:55:42 pjanzen Exp $";
@


1.5
log
@Prune some obsolete defines, in particular VT100.  Eventually curses will
  replace termios.
Use system-defined limits for path lengths and usernames.
Use strlcpy() for convenience and to avoid a possible buffer overflow or two.
Various small tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: tok.c,v 1.4 1999/05/30 02:23:17 pjanzen Exp $	*/
d6 1
a6 1
static char rcsid[] = "$OpenBSD: tok.c,v 1.4 1999/05/30 02:23:17 pjanzen Exp $";
d105 1
a105 1
				execl("/bin/csh", 0);
@


1.4
log
@use standard isalpha() and isdigit(); check that screen is big enough;
correct a typo, and fix up some man page paths.
@
text
@d1 1
a1 1
/*	$OpenBSD: tok.c,v 1.3 1999/03/27 03:45:50 pjanzen Exp $	*/
d6 1
a6 1
static char rcsid[] = "$OpenBSD: tok.c,v 1.3 1999/03/27 03:45:50 pjanzen Exp $";
d194 1
a194 1
		strcpy(logname, loginname);
d228 1
a228 3
				if (strlen(i) >= MAXMNAME)
					i[MAXMNAME - 1] = 0;
				strcpy(usermonster[usermpoint], i);
d246 1
a246 3
				if (strlen(i) >= LOGNAMESIZE)
					i[LOGNAMESIZE - 1] = 0;
				strcpy(logname, i);
a253 11
		case 'p':
			if (strcmp(i, "process-name:") == 0) {
				if ((i = lgetw()) == 0)
					break;
				if (strlen(i) >= PSNAMESIZE)
					i[PSNAMESIZE - 1] = 0;
				strcpy(psname, i);
			} else if (strcmp(i, "play-day-play") == 0)
				dayplay = 1;
			break;

d258 1
a258 1
				strcpy(savefilename, i);
d265 1
a265 1
		strcpy(logname, loginname);
@


1.3
log
@Changes from FreeBSD:  install score files, use random(), and be more careful
on exec.
@
text
@d1 1
a1 1
/*	$OpenBSD: tok.c,v 1.2 1998/09/15 05:12:33 pjanzen Exp $	*/
d6 1
a6 1
static char rcsid[] = "$OpenBSD: tok.c,v 1.2 1998/09/15 05:12:33 pjanzen Exp $";
d10 1
@


1.2
log
@NetBSD merge; also renamed some functions so as not to conflict with curses
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d6 1
a6 1
static char rcsid[] = "$OpenBSD$";
d66 1
a66 1
					exit();
d102 2
@


1.1
log
@Initial revision
@
text
@d1 4
d6 2
a7 2
static char rcsid[] = "$NetBSD: tok.c,v 1.4 1995/04/24 12:24:14 cgd Exp $";
#endif /* not lint */
a8 1
/* tok.c		Larn is copyrighted 1986 by Noah Morgan. */
d10 1
a10 4
#ifdef SYSV
#include <fcntl.h>
#include <termio.h>
#else SYSV
d12 3
a14 1
#endif SYSV
d16 1
a16 1
#include <string.h>
d18 2
a19 2
static char lastok=0;
int yrepcount=0,dayplay=0;
d22 7
a28 6
#endif FLUSHNO
static int flushno=FLUSHNO;	/* input queue flushing threshold */
#define MAXUM 52	/* maximum number of user re-named monsters */
#define MAXMNAME 40	/* max length of a monster re-name */
static char usermonster[MAXUM][MAXMNAME]; /* the user named monster name goes here */
static char usermpoint=0;			/* the user monster pointer */
d33 1
d35 20
a54 9
	{
	char cc;
	int ic;
	if (hit2flag) { hit2flag=0;  yrepcount=0;  return(' '); }
	if (yrepcount>0)	{ --yrepcount;  return(lastok);	} else yrepcount=0;
	if (yrepcount==0) { bottomdo(); showplayer(); }	/*	show where the player is	*/
	lflush();  
	while (1)
		{
d57 2
a58 2
		  if ((c[BYTESIN] % 400) == 0)	/* check for periodic checkpointing */
			{
d60 1
a60 1
			savegame(ckpfile);
d62 6
a67 2
			wait(0);	/* wait for other forks to finish */
			if (fork() == 0) { savegame(ckpfile); exit(); }
d72 12
a83 9
			if (dayplay==0)
			  if (playable())
				{
				cursor(1,19);
				lprcat("\nSorry, but it is now time for work.  Your game has been saved.\n"); beep();
				lflush();  savegame(savefilename);  wizard=nomove=1;  sleep(4);
				died(-257);
				}
#endif TIMECHECK
d86 10
d97 7
a103 4
		do		/* if keyboard input buffer is too big, flush some of it */
			{
			ioctl(0,FIONREAD,&ic);
			if (ic>flushno)   read(0,&cc,1);
a104 11
		while (ic>flushno);

		if (read(0,&cc,1) != 1) return(lastok = -1);

		if (cc == 'Y'-64)	/* control Y -- shell escape */
			{
			resetscroll();  clear(); /* scrolling region, home, clear, no attributes */
			if ((ic=fork())==0) /* child */
				{
				execl("/bin/csh",0);	exit();
				}
d106 4
a109 5
			if (ic<0) /* error */
				{
				write(2,"Can't fork off a shell!\n",25); sleep(2);
				}

d111 8
a118 6
			return(lastok = 'L'-64);	/* redisplay screen */
			}
		
		if ((cc <= '9') && (cc >= '0'))
			{ yrepcount = yrepcount*10 + cc - '0'; }
		else	{ if (yrepcount>0) --yrepcount;  return(lastok = cc); }
d121 1
d124 1
a124 1
 *	flushall()		Function to flush all type-ahead in the input buffer
d126 1
d128 13
a140 9
	{
	char cc;
	int ic;
	for (;;)		/* if keyboard input buffer is too big, flush some of it */
		{
		ioctl(0,FIONREAD,&ic);
		if (ic<=0) return;
		while (ic>0)   { read(0,&cc,1); --ic; } /* gobble up the byte */
		}
d142 1
d145 2
a146 2
	function to set the desired hardness 
	enter with hard= -1 for default hardness, else any desired hardness
d148 1
d150 25
a174 7
	int hard;
	{
	register int j,k,i;
	j=c[HARDGAME]; hashewon(); 
	if (restorflag==0)	/* don't set c[HARDGAME] if restoring game */
		{
		if (hard >= 0) c[HARDGAME]= hard;
d176 1
a176 17
	else c[HARDGAME]=j; /* set c[HARDGAME] to proper value if restoring game */

	if (k=c[HARDGAME])
	  for (j=0; j<=MAXMONST+8; j++)
		{
		i = ((6+k)*monster[j].hitpoints+1)/6;
		monster[j].hitpoints = (i<0) ? 32767 : i;
		i = ((6+k)*monster[j].damage+1)/5;
		monster[j].damage = (i>127) ? 127 : i;
		i = (10*monster[j].gold)/(10+k);
		monster[j].gold = (i>32767) ? 32767 : i;
		i = monster[j].armorclass - k;
		monster[j].armorclass = (i< -127) ? -127 : i;
		i = (7*monster[j].experience)/(7+k) + 1;
		monster[j].experience = (i<=0) ? 1 : i;
		}				
	}
d181 1
d183 11
a193 9
	{
	register char *i;
	register int j,k;
	int flag;
	flag=1;	/* set to 0 if he specifies a name for his character */
	if (lopen(optsfile) < 0)
		{
		strcpy(logname,loginname); return; /* user name if no character name */
		}
d195 29
a223 35
	while (*i)
	  {
	  if ((i=(char *)lgetw()) == 0) break; /* check for EOF */
	  while ((*i==' ') || (*i=='\t')) i++; /* eat leading whitespace */
	  switch(*i)
		{
		case 'b':	if (strcmp(i,"bold-objects") == 0)  boldon=1;
					break;

		case 'e':	if (strcmp(i,"enable-checkpointing") == 0) ckpflag=1;
					break;

		case 'i':	if (strcmp(i,"inverse-objects") == 0)  boldon=0;
					break;

		case 'f':	if (strcmp(i,"female") 	== 0)	sex=0; /* male or female */
					break;

		case 'm':	if (strcmp(i,"monster:")== 0)   /* name favorite monster */
						{
						if ((i=lgetw())==0) break;
						if (strlen(i)>=MAXMNAME) i[MAXMNAME-1]=0;
						strcpy(usermonster[usermpoint],i); 
						if (usermpoint >= MAXUM) break; /* defined all of em */
						if (isalpha(j=usermonster[usermpoint][0]))
							{
							for (k=1; k<MAXMONST+8; k++) /* find monster */
							  if (monstnamelist[k] == j)
								{
								monster[k].name = &usermonster[usermpoint++][0];
								break;
								}
							}
						}
					else if (strcmp(i,"male") == 0)	sex=1;
d225 10
a234 6

		case 'n':	if (strcmp(i,"name:") == 0) /* defining players name */
						{
						if ((i=lgetw())==0) break;
						if (strlen(i)>=LOGNAMESIZE) i[LOGNAMESIZE-1]=0;
						strcpy(logname,i); flag=0;
d236 8
a243 2
					else if (strcmp(i,"no-introduction") == 0) nowelcome=1;
					else if (strcmp(i,"no-beep") == 0) nobeep=1;
d245 13
a257 8

		case 'p':	if (strcmp(i,"process-name:")== 0) 
						{
						if ((i=lgetw())==0) break;
						if (strlen(i)>=PSNAMESIZE) i[PSNAMESIZE-1]=0;
						strcpy(psname,i);
						}
					else if (strcmp(i,"play-day-play") == 0)  dayplay=1;
d259 10
a268 6

		case 's':	if (strcmp(i,"savefile:") == 0) /* defining savefilename */
						{
						if ((i=lgetw())==0) break;
						strcpy(savefilename,i); flag=0;
						}
d270 4
a274 2
	  }
	if (flag)  strcpy(logname,loginname);
d276 3
a278 1

@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
