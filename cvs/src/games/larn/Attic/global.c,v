head	1.6;
access;
symbols
	OPENBSD_3_2:1.5.0.14
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.12
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.10
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.8
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.6
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2003.03.11.09.29.28;	author deraadt;	state dead;
branches;
next	1.5;

1.5
date	99.05.30.02.23.16;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	99.03.27.03.45.49;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	98.09.15.05.12.31;	author pjanzen;	state Exp;
branches;
next	1.2;

1.2
date	97.04.01.16.00.55;	author rahnds;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.05;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.6
log
@OK, this is a strange case.  At least some parts of this software is
copyrighted, and then marked "Copying for Profit is Prohibited", but
the author has passed away.  A number of people have tried to make
some sort of effort at trying to contact his estate, and have failed.
Therefore, lacking the ability to correct this copyright, we must
delete it.  I would bet strongly that this is not what the author
would have intended, but until we can get this resolved, this is the
action we must take.
@
text
@/*	$OpenBSD: global.c,v 1.5 1999/05/30 02:23:16 pjanzen Exp $	*/
/*	$NetBSD: global.c,v 1.6 1997/10/18 20:03:20 christos Exp $	*/

/*
 * global.c		Larn is copyrighted 1986 by Noah Morgan.
 * 
 * raiselevel()		subroutine to raise the player one level
 * loselevel()		subroutine to lower the player by one level
 * raiseexperience(x)	subroutine to increase experience points
 * loseexperience(x)	subroutine to lose experience points
 * losehp(x)		subroutine to remove hit points from the player
 * losemhp(x)		subroutine to remove max # hit points from the player
 * raisehp(x)		subroutine to gain hit points
 * raisemhp(x)		subroutine to gain maximum hit points
 * losespells(x)	subroutine to lose spells
 * losemspells(x)	subroutine to lose maximum spells
 * raisespells(x)	subroutine to gain spells
 * raisemspells(x)	subroutine to gain maximum spells
 * recalc()		function to recalculate the armor class of the player
 * makemonst(lev)	function to return monster number for a randomly
 *			selected monster
 * positionplayer()	function to be sure player is not in a wall
 * quit()		subroutine to ask if the player really wants to quit
 */
#ifndef lint
static char rcsid[] = "$OpenBSD: global.c,v 1.5 1999/05/30 02:23:16 pjanzen Exp $";
#endif /* not lint */

#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "header.h"
#include "extern.h"

extern int	score[], srcount, dropflag;
extern short	playerx, playery, lastnum, level;
extern u_char	cheat;
extern char	monstnamelist[], logname[];
extern char	lastmonst[], *what[], *who[];
extern char	winner[];
extern u_char	monstlevel[];
extern char	sciv[SCORESIZE + 1][26][2], *potionname[], *scrollname[];

/*
 *	***********
 *	RAISE LEVEL
 *	***********
 *	raiselevel()
 *
 *	subroutine to raise the player one level
 *	uses the skill[] array to find level boundarys
 *	uses c[EXPERIENCE]  c[LEVEL]
 */
void
raiselevel()
{
	if (c[LEVEL] < MAXPLEVEL)
		raiseexperience((long) (skill[c[LEVEL]] - c[EXPERIENCE]));
}

/*
 *	***********
 *	LOOSE LEVEL
 *	***********
 *	loselevel()
 *
 *	subroutine to lower the players character level by one
 */
void
loselevel()
{
	if (c[LEVEL] > 1)
		loseexperience((long) (c[EXPERIENCE] - skill[c[LEVEL] - 1] + 1));
}

/*
 *	****************
 *	RAISE EXPERIENCE
 *	****************
 *	raiseexperience(x)
 *
 *	subroutine to increase experience points
 */
void
raiseexperience(x)
	long	x;
{
	int	i, tmp;

	i = c[LEVEL];
	c[EXPERIENCE] += x;
	while (c[EXPERIENCE] >= skill[c[LEVEL]] && (c[LEVEL] < MAXPLEVEL)) {
		tmp = (c[CONSTITUTION] - c[HARDGAME]) >> 1;
		c[LEVEL]++;
		raisemhp((int) (rnd(3) + rnd((tmp > 0) ? tmp : 1)));
		raisemspells((int) rund(3));
		if (c[LEVEL] < 7 - c[HARDGAME])
			raisemhp((int) (c[CONSTITUTION] >> 2));
	}
	if (c[LEVEL] != i) {
		cursors();
		lbeep();
		lprintf("\nWelcome to level %d", (long) c[LEVEL]);	/* if we changed levels	 */
	}
	bottomline();
}

/*
 *	***************
 *	LOSE EXPERIENCE
 *	***************
 *	loseexperience(x)
 *
 *	subroutine to lose experience points
 */
void
loseexperience(x)
	long	x;
{
	int	i, tmp;

	i = c[LEVEL];
	c[EXPERIENCE] -= x;
	if (c[EXPERIENCE] < 0)
		c[EXPERIENCE] = 0;
	while (c[EXPERIENCE] < skill[c[LEVEL] - 1]) {
		if (--c[LEVEL] <= 1)
			c[LEVEL] = 1;	/* down one level		 */
		tmp = (c[CONSTITUTION] - c[HARDGAME]) >> 1;	/* lose hpoints */
		losemhp((int) rnd((tmp > 0) ? tmp : 1));	/* lose hpoints */
		if (c[LEVEL] < 7 - c[HARDGAME])
			losemhp((int) (c[CONSTITUTION] >> 2));
		losemspells((int) rund(3));	/* lose spells		 */
	}
	if (i != c[LEVEL]) {
		cursors();
		lbeep();
		lprintf("\nYou went down to level %d!", (long) c[LEVEL]);
	}
	bottomline();
}

/*
 *	*******
 *	LOSE HP
 *	*******
 *	losehp(x)
 *	losemhp(x)
 *
 *	subroutine to remove hit points from the player
 *	warning -- will kill player if hp goes to zero
 */
void
losehp(x)
	int	x;
{
	if ((c[HP] -= x) <= 0) {
		lbeep();
		lprcat("\n");
		nap(3000);
		died(lastnum);
	}
}

void
losemhp(x)
	int	x;
{
	c[HP] -= x;
	if (c[HP] < 1)
		c[HP] = 1;
	c[HPMAX] -= x;
	if (c[HPMAX] < 1)
		c[HPMAX] = 1;
}

/*
 *	********
 *	RAISE HP
 *	********
 *	raisehp(x)
 *	raisemhp(x)
 *
 *	subroutine to gain maximum hit points
 */
void
raisehp(x)
	int	x;
{
	if ((c[HP] += x) > c[HPMAX])
		c[HP] = c[HPMAX];
}

void
raisemhp(x)
	int	x;
{
	c[HPMAX] += x;
	c[HP] += x;
}

/*
 *	************
 *	RAISE SPELLS
 *	************
 *	raisespells(x)
 *	raisemspells(x)
 *
 *	subroutine to gain maximum spells
 */
void
raisespells(x)
	int	x;
{
	if ((c[SPELLS] += x) > c[SPELLMAX])
		c[SPELLS] = c[SPELLMAX];
}

void
raisemspells(x)
	int	x;
{
	c[SPELLMAX] += x;
	c[SPELLS] += x;
}

/*
 *	***********
 *	LOSE SPELLS
 *	***********
 *	losespells(x)
 *	losemspells(x)
 *
 *	subroutine to lose maximum spells
 */
void
losespells(x)
	int	x;
{
	if ((c[SPELLS] -= x) < 0)
		c[SPELLS] = 0;
}

void
losemspells(x)
	int	x;
{
	if ((c[SPELLMAX] -= x) < 0)
		c[SPELLMAX] = 0;
	if ((c[SPELLS] -= x) < 0)
		c[SPELLS] = 0;
}

/*
 *	makemonst(lev)
 *		int lev;
 *
 *	function to return monster number for a randomly selected monster
 *		for the given cave level
 */
int
makemonst(lev)
	int	lev;
{
	int	tmp, x;

	if (lev < 1)
		lev = 1;
	if (lev > 12)
		lev = 12;
	tmp = WATERLORD;
	if (lev < 5)
		while (tmp == WATERLORD)
			tmp = rnd((x = monstlevel[lev - 1]) ? x : 1);
	else
		while (tmp == WATERLORD)
			tmp = rnd((x = monstlevel[lev - 1] - monstlevel[lev - 4]) ? x : 1) + monstlevel[lev - 4];

	while (monster[tmp].genocided && tmp < MAXMONST)
		tmp++;		/* genocided? */
	return (tmp);
}

/*
 *	positionplayer()
 *
 *	function to be sure player is not in a wall
 */
void
positionplayer()
{
	int	try;

	try = 2;
	while ((item[playerx][playery] || mitem[playerx][playery]) && (try))
		if (++playerx >= MAXX - 1) {
			playerx = 1;
			if (++playery >= MAXY - 1) {
				playery = 1;
				--try;
			}
		}
	if (try == 0)
		lprcat("Failure in positionplayer\n");
}

/*
 *	recalc()	function to recalculate the armor class of the player
 */
void
recalc()
{
	int	i, j, k;

	c[AC] = c[MOREDEFENSES];
	if (c[WEAR] >= 0)
		switch (iven[c[WEAR]]) {
		case OSHIELD:
			c[AC] += 2 + ivenarg[c[WEAR]];
			break;
		case OLEATHER:
			c[AC] += 2 + ivenarg[c[WEAR]];
			break;
		case OSTUDLEATHER:
			c[AC] += 3 + ivenarg[c[WEAR]];
			break;
		case ORING:
			c[AC] += 5 + ivenarg[c[WEAR]];
			break;
		case OCHAIN:
			c[AC] += 6 + ivenarg[c[WEAR]];
			break;
		case OSPLINT:
			c[AC] += 7 + ivenarg[c[WEAR]];
			break;
		case OPLATE:
			c[AC] += 9 + ivenarg[c[WEAR]];
			break;
		case OPLATEARMOR:
			c[AC] += 10 + ivenarg[c[WEAR]];
			break;
		case OSSPLATE:
			c[AC] += 12 + ivenarg[c[WEAR]];
			break;
		}

	if (c[SHIELD] >= 0)
		if (iven[c[SHIELD]] == OSHIELD)
			c[AC] += 2 + ivenarg[c[SHIELD]];
	if (c[WIELD] < 0)
		c[WCLASS] = 0;
	else {
		i = ivenarg[c[WIELD]];
		switch (iven[c[WIELD]]) {
		case ODAGGER:
			c[WCLASS] = 3 + i;
			break;
		case OBELT:
			c[WCLASS] = 7 + i;
			break;
		case OSHIELD:
			c[WCLASS] = 8 + i;
			break;
		case OSPEAR:
			c[WCLASS] = 10 + i;
			break;
		case OFLAIL:
			c[WCLASS] = 14 + i;
			break;
		case OBATTLEAXE:
			c[WCLASS] = 17 + i;
			break;
		case OLANCE:
			c[WCLASS] = 19 + i;
			break;
		case OLONGSWORD:
			c[WCLASS] = 22 + i;
			break;
		case O2SWORD:
			c[WCLASS] = 26 + i;
			break;
		case OSWORD:
			c[WCLASS] = 32 + i;
			break;
		case OSWORDofSLASHING:
			c[WCLASS] = 30 + i;
			break;
		case OHAMMER:
			c[WCLASS] = 35 + i;
			break;
		default:
			c[WCLASS] = 0;
		}
	}
	c[WCLASS] += c[MOREDAM];

	/* now for regeneration abilities based on rings	 */
	c[REGEN] = 1;
	c[ENERGY] = 0;
	j = 0;
	for (k = 25; k > 0; k--)
		if (iven[k]) {
			j = k;
			k = 0;
		}
	for (i = 0; i <= j; i++) {
		switch (iven[i]) {
		case OPROTRING:
			c[AC] += ivenarg[i] + 1;
			break;
		case ODAMRING:
			c[WCLASS] += ivenarg[i] + 1;
			break;
		case OBELT:
			c[WCLASS] += ((ivenarg[i] << 1)) + 2;
			break;

		case OREGENRING:
			c[REGEN] += ivenarg[i] + 1;
			break;
		case ORINGOFEXTRA:
			c[REGEN] += 5 * (ivenarg[i] + 1);
			break;
		case OENERGYRING:
			c[ENERGY] += ivenarg[i] + 1;
			break;
		}
	}
}


/*
 *	quit()
 *
 *	subroutine to ask if the player really wants to quit
 */
void
quit()
{
	int	i;

	cursors();
	strcpy(lastmonst, "");
	lprcat("\n\nDo you really want to quit?");
	while (1) {
		i = lgetchar();
		if (i == 'y') {
			died(300);
			return;
		}
		if ((i == 'n') || (i == '\33')) {
			lprcat(" no");
			lflush();
			return;
		}
		lprcat("\n");
		setbold();
		lprcat("Yes");
		resetbold();
		lprcat(" or ");
		setbold();
		lprcat("No");
		resetbold();
		lprcat(" please?   Do you want to quit? ");
	}
}

/*
 *	function to ask --more-- then the user must enter a space
 */
void
more()
{
	lprcat("\n  --- press ");
	lstandout("space");
	lprcat(" to continue --- ");
	while (lgetchar() != ' ');
}

/*
 *	function to put something in the players inventory
 *	returns 0 if success, 1 if a failure
 */
int
take(itm, arg)
	int	itm, arg;
{
	int	i, limit;

	/* cursors(); */
	if ((limit = 15 + (c[LEVEL] >> 1)) > 26)
		limit = 26;
	for (i = 0; i < limit; i++)
		if (iven[i] == 0) {
			iven[i] = itm;
			ivenarg[i] = arg;
			limit = 0;
			switch (itm) {
			case OPROTRING:
			case ODAMRING:
			case OBELT:
				limit = 1;
				break;
			case ODEXRING:
				c[DEXTERITY] += ivenarg[i] + 1;
				limit = 1;
				break;
			case OSTRRING:
				c[STREXTRA] += ivenarg[i] + 1;
				limit = 1;
				break;
			case OCLEVERRING:
				c[INTELLIGENCE] += ivenarg[i] + 1;
				limit = 1;
				break;
			case OHAMMER:
				c[DEXTERITY] += 10;
				c[STREXTRA] += 10;
				c[INTELLIGENCE] -= 10;
				limit = 1;
				break;

			case OORBOFDRAGON:
				c[SLAYING]++;
				break;
			case OSPIRITSCARAB:
				c[NEGATESPIRIT]++;
				break;
			case OCUBEofUNDEAD:
				c[CUBEofUNDEAD]++;
				break;
			case ONOTHEFT:
				c[NOTHEFT]++;
				break;
			case OSWORDofSLASHING:
				c[DEXTERITY] += 5;
				limit = 1;
				break;
			};
			lprcat("\nYou pick up:");
			srcount = 0;
			show3(i);
			if (limit)
				bottomline();
			return (0);
		}
	lprcat("\nYou can't carry anything else");
	return (1);
}

/*
 *	subroutine to drop an object
 *	returns 1 if something there already else 0
 */
int
drop_object(k)
	int	k;
{
	int	itm;

	if ((k < 0) || (k > 25))
		return (0);
	itm = iven[k];
	cursors();
	if (itm == 0) {
		lprintf("\nYou don't have item %c! ", k + 'a');
		return (1);
	}
	if (item[playerx][playery]) {
		lbeep();
		lprcat("\nThere's something here already");
		return (1);
	}
	if (playery == MAXY - 1 && playerx == 33)
		return (1);	/* not in entrance */
	item[playerx][playery] = itm;
	iarg[playerx][playery] = ivenarg[k];
	srcount = 0;
	lprcat("\n  You drop:");
	show3(k);		/* show what item you dropped */
	know[playerx][playery] = 0;
	iven[k] = 0;
	if (c[WIELD] == k)
		c[WIELD] = -1;
	if (c[WEAR] == k)
		c[WEAR] = -1;
	if (c[SHIELD] == k)
		c[SHIELD] = -1;
	adjustcvalues(itm, ivenarg[k]);
	dropflag = 1;		/* say dropped an item so wont ask to pick it
				 * up right away */
	return (0);
}

/*
 *	function to enchant armor player is currently wearing
 */
void
enchantarmor()
{
	int	tmp;

	if (c[WEAR] < 0) {
		if (c[SHIELD] < 0) {
			cursors();
			lbeep();
			lprcat("\nYou feel a sense of loss");
			return;
		} else {
			tmp = iven[c[SHIELD]];
			if (tmp != OSCROLL)
				if (tmp != OPOTION) {
					ivenarg[c[SHIELD]]++;
					bottomline();
				}
		}
	}
	tmp = iven[c[WEAR]];
	if (tmp != OSCROLL)
		if (tmp != OPOTION) {
			ivenarg[c[WEAR]]++;
			bottomline();
		}
}

/*
 *	function to enchant a weapon presently being wielded
 */
void
enchweapon()
{
	int	tmp;

	if (c[WIELD] < 0) {
		cursors();
		lbeep();
		lprcat("\nYou feel a sense of loss");
		return;
	}
	tmp = iven[c[WIELD]];
	if (tmp != OSCROLL)
		if (tmp != OPOTION) {
			ivenarg[c[WIELD]]++;
			if (tmp == OCLEVERRING)
				c[INTELLIGENCE]++;
			else if (tmp == OSTRRING)
				c[STREXTRA]++;
			else if (tmp == ODEXRING)
				c[DEXTERITY]++;
			bottomline();
		}
}

/*
 *	routine to tell if player can carry one more thing
 *	returns 1 if pockets are full, else 0
 */
int
pocketfull()
{
	int	i, limit;

	if ((limit = 15 + (c[LEVEL] >> 1)) > 26)
		limit = 26;
	for (i = 0; i < limit; i++)
		if (iven[i] == 0)
			return (0);
	return (1);
}

/*
 *	function to return 1 if a monster is next to the player else returns 0
 */
int
nearbymonst()
{
	int	tmp, tmp2;

	for (tmp = playerx - 1; tmp < playerx + 2; tmp++)
		for (tmp2 = playery - 1; tmp2 < playery + 2; tmp2++)
			if (mitem[tmp][tmp2])
				return (1);	/* if monster nearby */
	return (0);
}

/*
 *	function to steal an item from the players pockets
 *	returns 1 if steals something else returns 0
 */
int
stealsomething()
{
	int	i, j;

	j = 100;
	while (1) {
		i = rund(26);
		if (iven[i])
			if (c[WEAR] != i)
				if (c[WIELD] != i)
					if (c[SHIELD] != i) {
						srcount = 0;
						show3(i);
						adjustcvalues(iven[i], ivenarg[i]);
						iven[i] = 0;
						return (1);
					}
		if (--j <= 0)
			return (0);
	}
}

/*
 *	function to return 1 is player carrys nothing else return 0
 */
int
emptyhanded()
{
	int	i;

	for (i = 0; i < 26; i++)
		if (iven[i])
			if (i != c[WIELD])
				if (i != c[WEAR])
					if (i != c[SHIELD])
						return (0);
	return (1);
}

/*
 *	function to create a gem on a square near the player
 */
void
creategem()
{
	int	i, j;

	switch (rnd(4)) {
	case 1:
		i = ODIAMOND;
		j = 50;
		break;
	case 2:
		i = ORUBY;
		j = 40;
		break;
	case 3:
		i = OEMERALD;
		j = 30;
		break;
	default:
		i = OSAPPHIRE;
		j = 20;
		break;
	};
	createitem(i, rnd(j) + j / 10);
}

/*
 *	function to change character levels as needed when dropping an object
 *	that affects these characteristics
 */
void
adjustcvalues(itm, arg)
	int	itm, arg;
{
	int	flag;

	flag = 0;
	switch (itm) {
	case ODEXRING:
		c[DEXTERITY] -= arg + 1;
		flag = 1;
		break;
	case OSTRRING:
		c[STREXTRA] -= arg + 1;
		flag = 1;
		break;
	case OCLEVERRING:
		c[INTELLIGENCE] -= arg + 1;
		flag = 1;
		break;
	case OHAMMER:
		c[DEXTERITY] -= 10;
		c[STREXTRA] -= 10;
		c[INTELLIGENCE] += 10;
		flag = 1;
		break;
	case OSWORDofSLASHING:
		c[DEXTERITY] -= 5;
		flag = 1;
		break;
	case OORBOFDRAGON:
		--c[SLAYING];
		return;
	case OSPIRITSCARAB:
		--c[NEGATESPIRIT];
		return;
	case OCUBEofUNDEAD:
		--c[CUBEofUNDEAD];
		return;
	case ONOTHEFT:
		--c[NOTHEFT];
		return;
	case OLANCE:
		c[LANCEDEATH] = 0;
		return;
	case OPOTION:
	case OSCROLL:
		return;

	default:
		flag = 1;
	};
	if (flag)
		bottomline();
}

/*
 *	function to read a string from token input "string"
 *	returns a pointer to the string
 */
void
gettokstr(str)
	char	*str;
{
	int	i, j;

	i = 50;
	while ((lgetchar() != '"') && (--i > 0));
	i = 36;
	while (--i > 0) {
		if ((j = lgetchar()) != '"')
			*str++ = j;
		else
			i = 0;
	}
	*str = 0;
	i = 50;
	if (j != '"')
		/* if end due to too long, then find closing quote */
		while ((lgetchar() != '"') && (--i > 0));
}

/*
 *	function to ask user for a password (no echo)
 *	returns 1 if entered correctly, 0 if not
 */
static char	gpwbuf[33];
int
getpassword()
{
	int	i, j;
	char	*gpwp;
	extern char	*password;

	scbr();			/* system("stty -echo cbreak"); */
	gpwp = gpwbuf;
	lprcat("\nEnter Password: ");
	lflush();
	i = strlen(password);
	for (j = 0; j < i; j++)
		read(0, gpwp++, 1);
	gpwbuf[i] = 0;
	sncbr();		/* system("stty echo -cbreak"); */
	if (strcmp(gpwbuf, password) != 0) {
		lprcat("\nSorry\n");
		lflush();
		return (0);
	} else
		return (1);
}

/*
 *	subroutine to get a yes or no response from the user
 *	returns y or n
 */
int
getyn()
{
	int	i;

	i = 0;
	while (i != 'y' && i != 'n' && i != '\33')
		i = lgetchar();
	return (i);
}

/*
 *	function to calculate the pack weight of the player
 *	returns the number of pounds the player is carrying
 */
int
packweight()
{
	int	i, j, k;

	k = c[GOLD] / 1000;
	j = 25;
	while ((iven[j] == 0) && (j > 0))
		--j;
	for (i = 0; i <= j; i++)
		switch (iven[i]) {
		case 0:
			break;
		case OSSPLATE:
		case OPLATEARMOR:
			k += 40;
			break;
		case OPLATE:
			k += 35;
			break;
		case OHAMMER:
			k += 30;
			break;
		case OSPLINT:
			k += 26;
			break;
		case OSWORDofSLASHING:
		case OCHAIN:
		case OBATTLEAXE:
		case O2SWORD:
			k += 23;
			break;
		case OLONGSWORD:
		case OSWORD:
		case ORING:
		case OFLAIL:
			k += 20;
			break;
		case OLANCE:
		case OSTUDLEATHER:
			k += 15;
			break;
		case OLEATHER:
		case OSPEAR:
			k += 8;
			break;
		case OORBOFDRAGON:
		case OBELT:
			k += 4;
			break;
		case OSHIELD:
			k += 7;
			break;
		case OCHEST:
			k += 30 + ivenarg[i];
			break;
		default:
			k++;
		};
	return (k);
}

#ifndef MACRORND
/* macros to generate random numbers   1<=rnd(N)<=N   0<=rund(N)<=N-1 */
int
rnd(x)
	int	x;
{
	return ((random() % x) + 1);
}

int
rund(x)
	int	x;
{
	return (random() % x);
}
#endif	/* MACRORND */
@


1.5
log
@use standard isalpha() and isdigit(); check that screen is big enough;
correct a typo, and fix up some man page paths.
@
text
@d1 1
a1 1
/*	$OpenBSD: global.c,v 1.4 1999/03/27 03:45:49 pjanzen Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: global.c,v 1.4 1999/03/27 03:45:49 pjanzen Exp $";
@


1.4
log
@Changes from FreeBSD:  install score files, use random(), and be more careful
on exec.
@
text
@d1 1
a1 1
/*	$OpenBSD: global.c,v 1.3 1998/09/15 05:12:31 pjanzen Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: global.c,v 1.3 1998/09/15 05:12:31 pjanzen Exp $";
d29 1
@


1.3
log
@NetBSD merge; also renamed some functions so as not to conflict with curses
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD$";
a34 1
extern int	random;		/* the random number seed	*/
d960 1
a960 1
	return ((((randx = randx * 1103515245 + 12345) >> 7) % (x)) + 1);
d967 1
a967 1
	return ((((randx = randx * 1103515245 + 12345) >> 7) % (x)));
@


1.2
log
@Changes from NetBSD to compile games without warnings due to short being
unsigned on some archs, PowerPC, ROMP.
@
text
@d1 24
d26 1
a26 1
static char rcsid[] = "$NetBSD: global.c,v 1.4 1995/04/24 12:23:52 cgd Exp $";
d29 20
a48 1
/*	global.c 		Larn is copyrighted 1986 by Noah Morgan.
d50 3
a52 37
 *	raiselevel()		subroutine to raise the player one level
 *	loselevel()		subroutine to lower the player by one level
 *	raiseexperience(x)	subroutine to increase experience points
 *	loseexperience(x)	subroutine to lose experience points
 *	losehp(x)			subroutine to remove hit points from the player
 *	losemhp(x)			subroutine to remove max # hit points from the player
 *	raisehp(x)			subroutine to gain hit points
 *	raisemhp(x)			subroutine to gain maximum hit points
 *	losespells(x)		subroutine to lose spells
 *	losemspells(x)		subroutine to lose maximum spells
 *	raisespells(x)		subroutine to gain spells
 *	raisemspells(x)		subroutine to gain maximum spells
 *	recalc()			function to recalculate the armor class of the player
 *	makemonst(lev)		function to return monster number for a randomly selected monster
 *	positionplayer()	function to be sure player is not in a wall
 *	quit()				subroutine to ask if the player really wants to quit
 */

#include "header.h"
#include <string.h>
extern int score[],srcount,dropflag;
extern int random;/*	the random number seed			*/
extern short playerx,playery,lastnum,level;
extern char cheat,monstnamelist[];
extern char lastmonst[],*what[],*who[]; 
extern char winner[];
extern char logname[],monstlevel[];
extern char sciv[SCORESIZE+1][26][2],*potionname[],*scrollname[];
/*
	***********
	RAISE LEVEL
	***********
	raiselevel()

	subroutine to raise the player one level
	uses the skill[] array to find level boundarys
	uses c[EXPERIENCE]  c[LEVEL]
d54 1
d56 4
a59 3
	{
	if (c[LEVEL] < MAXPLEVEL) raiseexperience((long)(skill[c[LEVEL]]-c[EXPERIENCE]));
	}
d62 6
a67 6
	***********
	LOOSE LEVEL
	***********
    loselevel()

	subroutine to lower the players character level by one
d69 1
d71 4
a74 3
	{
	if (c[LEVEL] > 1) loseexperience((long)(c[EXPERIENCE] - skill[c[LEVEL]-1] + 1));
	}
d77 6
a82 6
	****************
	RAISE EXPERIENCE
	****************
	raiseexperience(x)

	subroutine to increase experience points
d84 1
d86 15
a100 13
	register long x;
	{
	register int i,tmp;
	i=c[LEVEL];	c[EXPERIENCE]+=x;
	while (c[EXPERIENCE] >= skill[c[LEVEL]] && (c[LEVEL] < MAXPLEVEL))
		{
		tmp = (c[CONSTITUTION]-c[HARDGAME])>>1;
		c[LEVEL]++;	raisemhp((int)(rnd(3)+rnd((tmp>0)?tmp:1)));
		raisemspells((int)rund(3));
		if (c[LEVEL] < 7-c[HARDGAME]) raisemhp((int)(c[CONSTITUTION]>>2));
		}
	if (c[LEVEL] != i)
		{
d102 3
a104 2
		beep(); lprintf("\nWelcome to level %d",(long)c[LEVEL]);	/* if we changed levels	*/
		}
d106 1
a106 1
	}
d109 6
a114 6
	****************
	LOOSE EXPERIENCE
	****************
	loseexperience(x)

	subroutine to lose experience points
d116 1
d118 18
a135 15
	register long x;
	{
	register int i,tmp;
	i=c[LEVEL];		c[EXPERIENCE]-=x;
	if (c[EXPERIENCE] < 0) c[EXPERIENCE]=0;
	while (c[EXPERIENCE] < skill[c[LEVEL]-1])
		{
		if (--c[LEVEL] <= 1) c[LEVEL]=1;	/*	down one level		*/
		tmp = (c[CONSTITUTION]-c[HARDGAME])>>1;	/* lose hpoints */
		losemhp((int)rnd((tmp>0)?tmp:1));	/* lose hpoints */
		if (c[LEVEL] < 7-c[HARDGAME]) losemhp((int)(c[CONSTITUTION]>>2));
		losemspells((int)rund(3));				/*	lose spells		*/
		}
	if (i!=c[LEVEL])
		{
d137 3
a139 2
		beep(); lprintf("\nYou went down to level %d!",(long)c[LEVEL]);
		}
d141 1
a141 1
	}
d144 8
a151 8
	********
	LOOSE HP
	********
	losehp(x)
	losemhp(x)

	subroutine to remove hit points from the player
	warning -- will kill player if hp goes to zero
d153 1
d155 7
a161 6
	register int x;
	{
	if ((c[HP] -= x) <= 0)
		{
		beep(); lprcat("\n");  nap(3000);  died(lastnum);
		}
d163 1
d165 1
d167 18
a184 14
	register int x;
	{
	c[HP] -= x;		if (c[HP] < 1)		c[HP]=1;
	c[HPMAX] -= x;	if (c[HPMAX] < 1)	c[HPMAX]=1;
	}

/*
	********
	RAISE HP
	********
	raisehp(x)
	raisemhp(x)

	subroutine to gain maximum hit points
d186 1
d188 5
a192 4
	register int x;
	{
	if ((c[HP] += x) > c[HPMAX]) c[HP] = c[HPMAX];
	}
d194 1
d196 5
a200 4
	register int x;
	{
	c[HPMAX] += x;	c[HP] += x;
	}
d203 7
a209 7
	************
	RAISE SPELLS
	************
	raisespells(x)
	raisemspells(x)

	subroutine to gain maximum spells
d211 1
d213 5
a217 4
	register int x;
	{
	if ((c[SPELLS] += x) > c[SPELLMAX])	c[SPELLS] = c[SPELLMAX];
	}
d219 1
d221 5
a225 4
	register int x;
	{
	c[SPELLMAX]+=x; c[SPELLS]+=x;
	}
d228 7
a234 7
	************
	LOOSE SPELLS
	************
	losespells(x)
	losemspells(x)

	subroutine to lose maximum spells
d236 1
d238 5
a242 4
	register int x;
	{
	if ((c[SPELLS] -= x) < 0) c[SPELLS]=0;
	}
d244 1
d246 7
a252 5
	register int x;
	{
	if ((c[SPELLMAX] -= x) < 0) c[SPELLMAX]=0;
	if ((c[SPELLS] -= x) < 0) c[SPELLS]=0;
	}
d255 5
a259 5
	makemonst(lev)
		int lev;

	function to return monster number for a randomly selected monster
		for the given cave level	
d261 1
d263 9
a271 5
	register int lev;
	{
	register int tmp,x;
	if (lev < 1)	lev = 1;			if (lev > 12)	lev = 12;
	tmp=WATERLORD;
d273 10
a282 7
		while (tmp==WATERLORD) tmp=rnd((x=monstlevel[lev-1])?x:1);
	else while (tmp==WATERLORD)
		tmp=rnd((x=monstlevel[lev-1]-monstlevel[lev-4])?x:1)+monstlevel[lev-4];

	while (monster[tmp].genocided && tmp<MAXMONST) tmp++; /* genocided? */
	return(tmp);
	}
d285 3
a287 3
	positionplayer()

	function to be sure player is not in a wall
d289 1
d291 3
a293 2
	{
	int try;
d296 1
a296 2
		if (++playerx >= MAXX-1)
			{
d298 3
a300 2
			if (++playery >= MAXY-1)
				{	playery = 1;	--try;	}
d302 4
a305 2
	if (try==0)	 lprcat("Failure in positionplayer\n");
	}
d308 1
a308 1
	recalc()	function to recalculate the armor class of the player
d310 1
d312 3
a314 2
	{
	register int i,j,k;
d316 30
a345 13
	if (c[WEAR] >= 0)  
		switch(iven[c[WEAR]])
			{
			case OSHIELD:		c[AC] += 2 + ivenarg[c[WEAR]]; break;
			case OLEATHER:		c[AC] += 2 + ivenarg[c[WEAR]]; break;
			case OSTUDLEATHER:	c[AC] += 3 + ivenarg[c[WEAR]]; break;
			case ORING:			c[AC] += 5 + ivenarg[c[WEAR]]; break;
			case OCHAIN:		c[AC] += 6 + ivenarg[c[WEAR]]; break;
			case OSPLINT:		c[AC] += 7 + ivenarg[c[WEAR]]; break;
			case OPLATE:		c[AC] += 9 + ivenarg[c[WEAR]]; break;
			case OPLATEARMOR:	c[AC] += 10 + ivenarg[c[WEAR]]; break;
			case OSSPLATE:		c[AC] += 12 + ivenarg[c[WEAR]]; break;
			}
d347 6
a352 3
	if (c[SHIELD] >= 0) if (iven[c[SHIELD]] == OSHIELD) c[AC] += 2 + ivenarg[c[SHIELD]];
	if (c[WIELD] < 0)  c[WCLASS] = 0;  else
		{
d354 39
a392 16
		switch(iven[c[WIELD]])
			{
			case ODAGGER:    c[WCLASS] =  3 + i;  break;
			case OBELT:	     c[WCLASS] =  7 + i;  break;
			case OSHIELD:	 c[WCLASS] =  8 + i;  break;
			case OSPEAR:     c[WCLASS] = 10 + i;  break;
			case OFLAIL:     c[WCLASS] = 14 + i;  break;
			case OBATTLEAXE: c[WCLASS] = 17 + i;  break;
			case OLANCE:	 c[WCLASS] = 19 + i;  break;
			case OLONGSWORD: c[WCLASS] = 22 + i;  break;
			case O2SWORD:    c[WCLASS] = 26 + i;  break;
			case OSWORD:     c[WCLASS] = 32 + i;  break;
			case OSWORDofSLASHING: c[WCLASS] = 30 + i; break;
			case OHAMMER:    c[WCLASS] = 35 + i;  break;
			default:	     c[WCLASS] = 0;
			}
d394 1
d397 30
a426 15
/*	now for regeneration abilities based on rings	*/
	c[REGEN]=1;		c[ENERGY]=0;
	j=0;  for (k=25; k>0; k--)  if (iven[k]) {j=k; k=0; }
	for (i=0; i<=j; i++)
		{
		switch(iven[i])
			{
			case OPROTRING: c[AC]     += ivenarg[i] + 1;	break;
			case ODAMRING:  c[WCLASS] += ivenarg[i] + 1;	break;
			case OBELT:     c[WCLASS] += ((ivenarg[i]<<1)) + 2;	break;

			case OREGENRING:	c[REGEN]  += ivenarg[i] + 1;	break;
			case ORINGOFEXTRA:	c[REGEN]  += 5 * (ivenarg[i]+1); break;
			case OENERGYRING:	c[ENERGY] += ivenarg[i] + 1;	break;
			}
d429 1
d433 3
a435 3
	quit()

	subroutine to ask if the player really wants to quit
d437 1
d439 5
a443 3
	{
	register int i;
	cursors();	strcpy(lastmonst,"");
d445 20
a464 8
	while (1)
		{
		i=getchar();
		if (i == 'y')	{ died(300); return; }
		if ((i == 'n') || (i == '\33'))	{ lprcat(" no"); lflush(); return; }
		lprcat("\n");  setbold();  lprcat("Yes");  resetbold();  lprcat(" or ");
		setbold();  lprcat("No");  resetbold();  lprcat(" please?   Do you want to quit? ");
		}	
d466 1
d469 1
a469 1
	function to ask --more-- then the user must enter a space
d471 1
d473 77
a549 4
	{
	lprcat("\n  --- press ");  standout("space");  lprcat(" to continue --- ");
	while (getchar() != ' ');
	}
d552 2
a553 36
	function to put something in the players inventory
	returns 0 if success, 1 if a failure
 */
take(itm,arg)
	int itm,arg;
	{
	register int i,limit;
/*	cursors(); */
	if ((limit = 15+(c[LEVEL]>>1)) > 26)  limit=26;
	for (i=0; i<limit; i++)
		if (iven[i]==0)
			{
			iven[i] = itm;  ivenarg[i] = arg;  limit=0;
			switch(itm)
				{
				case OPROTRING:	case ODAMRING: case OBELT: limit=1;  break;
				case ODEXRING:		c[DEXTERITY] += ivenarg[i]+1; limit=1;	break;
				case OSTRRING:		c[STREXTRA]  += ivenarg[i]+1;	limit=1; break;
				case OCLEVERRING:	c[INTELLIGENCE] += ivenarg[i]+1;  limit=1; break;
				case OHAMMER:		c[DEXTERITY] += 10;	c[STREXTRA]+=10;
									c[INTELLIGENCE]-=10;	limit=1;	 break;

				case OORBOFDRAGON:	c[SLAYING]++;		break;
				case OSPIRITSCARAB: c[NEGATESPIRIT]++;	break;
				case OCUBEofUNDEAD: c[CUBEofUNDEAD]++;	break;
				case ONOTHEFT:		c[NOTHEFT]++;		break;
				case OSWORDofSLASHING:	c[DEXTERITY] +=5;	limit=1; break;
				};
			lprcat("\nYou pick up:"); srcount=0;  show3(i);
			if (limit) bottomline();  return(0);
			}
	lprcat("\nYou can't carry anything else");  return(1);
	}

/*
	subroutine to drop an object  returns 1 if something there already else 0
d555 1
d557 19
a575 9
	int k;
	{
	int itm;
	if ((k<0) || (k>25)) return(0);
	itm = iven[k];	cursors();
	if (itm==0) { lprintf("\nYou don't have item %c! ",k+'a'); return(1); }
	if (item[playerx][playery])
		{ beep(); lprcat("\nThere's something here already"); return(1); }
	if (playery==MAXY-1 && playerx==33) return(1); /* not in entrance */
d578 16
a593 8
	srcount=0; lprcat("\n  You drop:"); show3(k); /* show what item you dropped*/
	know[playerx][playery] = 0;  iven[k]=0; 
	if (c[WIELD]==k) c[WIELD]= -1;		if (c[WEAR]==k)  c[WEAR] = -1;
	if (c[SHIELD]==k) c[SHIELD]= -1;
	adjustcvalues(itm,ivenarg[k]);
	dropflag=1; /* say dropped an item so wont ask to pick it up right away */
	return(0);
	}
d596 1
a596 1
	function to enchant armor player is currently wearing
d598 1
d600 18
a617 5
	{
	register int tmp;
	if (c[WEAR]<0) { if (c[SHIELD] < 0)
		{ cursors(); beep(); lprcat("\nYou feel a sense of loss"); return; }
					else { tmp=iven[c[SHIELD]]; if (tmp != OSCROLL) if (tmp != OPOTION) { ivenarg[c[SHIELD]]++; bottomline(); } } }
d619 6
a624 2
	if (tmp!=OSCROLL) if (tmp!=OPOTION)  { ivenarg[c[WEAR]]++;  bottomline(); }
	}
d627 1
a627 1
	function to enchant a weapon presently being wielded
d629 1
d631 9
a639 4
	{
	register int tmp;
	if (c[WIELD]<0)
		{ cursors(); beep(); lprcat("\nYou feel a sense of loss"); return; }
d641 12
a652 6
	if (tmp!=OSCROLL) if (tmp!=OPOTION)
		{ ivenarg[c[WIELD]]++;
		  if (tmp==OCLEVERRING) c[INTELLIGENCE]++;  else
		  if (tmp==OSTRRING)	c[STREXTRA]++;  else
		  if (tmp==ODEXRING)    c[DEXTERITY]++;		  bottomline(); }
	}
d655 2
a656 2
	routine to tell if player can carry one more thing
	returns 1 if pockets are full, else 0
d658 1
d660 10
a669 6
	{
	register int i,limit; 
	if ((limit = 15+(c[LEVEL]>>1)) > 26)  limit=26;
	for (i=0; i<limit; i++) if (iven[i]==0) return(0);
	return(1);
	}
d672 1
a672 1
	function to return 1 if a monster is next to the player else returns 0
d674 1
d676 9
a684 7
	{
	register int tmp,tmp2;
	for (tmp=playerx-1; tmp<playerx+2; tmp++)
		for (tmp2=playery-1; tmp2<playery+2; tmp2++)
			if (mitem[tmp][tmp2]) return(1); /* if monster nearby */
	return(0);
	}
d687 2
a688 2
	function to steal an item from the players pockets
	returns 1 if steals something else returns 0
d690 1
d692 18
a709 13
	{
	register int i,j;
	j=100;
	while (1)
		{
		i=rund(26);
		if (iven[i]) if (c[WEAR]!=i) if (c[WIELD]!=i) if (c[SHIELD]!=i)
			{
			srcount=0; show3(i);
			adjustcvalues(iven[i],ivenarg[i]);  iven[i]=0; return(1);
			}
		if (--j <= 0) return(0);
		}
d711 1
d714 1
a714 1
	function to return 1 is player carrys nothing else return 0
d716 1
d718 11
a728 6
	{
	register int i;
	for (i=0; i<26; i++)
		if (iven[i]) if (i!=c[WIELD]) if (i!=c[WEAR]) if (i!=c[SHIELD]) return(0);
	return(1);
	}
d731 1
a731 1
	function to create a gem on a square near the player
d733 1
d735 2
a736 35
	{
	register int i,j;
	switch(rnd(4))
		{
		case 1:	 i=ODIAMOND;	j=50;	break;
		case 2:	 i=ORUBY;		j=40;	break;
		case 3:	 i=OEMERALD;	j=30;	break;
		default: i=OSAPPHIRE;	j=20;	break;
		};
	createitem(i,rnd(j)+j/10);
	}

/*
	function to change character levels as needed when dropping an object
	that affects these characteristics
 */
adjustcvalues(itm,arg)
	int itm,arg;
	{
	register int flag;
	flag=0;
	switch(itm)
		{
		case ODEXRING:	c[DEXTERITY] -= arg+1;  flag=1; break;
		case OSTRRING:	c[STREXTRA]  -= arg+1;  flag=1; break;
		case OCLEVERRING: c[INTELLIGENCE] -= arg+1;  flag=1; break;
		case OHAMMER:	c[DEXTERITY] -= 10;	c[STREXTRA] -= 10;
						c[INTELLIGENCE] += 10; flag=1; break;
		case OSWORDofSLASHING:	c[DEXTERITY] -= 5;	flag=1; break;
		case OORBOFDRAGON:		--c[SLAYING];		return;
		case OSPIRITSCARAB:		--c[NEGATESPIRIT];	return;
		case OCUBEofUNDEAD:		--c[CUBEofUNDEAD];	return;
		case ONOTHEFT:			--c[NOTHEFT]; 		return;
		case OLANCE:		c[LANCEDEATH]=0;	return;
		case OPOTION:	case OSCROLL:	return;
d738 80
a817 4
		default:	flag=1;
		};
	if (flag) bottomline();
	}
d820 2
a821 2
	function to read a string from token input "string"
	returns a pointer to the string
d823 1
d825 13
a837 10
	register char *str;
	{
	register int i,j;
	i=50;
	while ((getchar() != '"') && (--i > 0));
	i=36;
	while (--i > 0)
		{
		if ((j=getchar()) != '"') *str++ = j;  else i=0;
		}
d839 5
a843 3
	i=50;
	if (j != '"') while ((getchar() != '"') && (--i > 0)); /* if end due to too long, then find closing quote */
	}
d846 2
a847 2
	function to ask user for a password (no echo)
	returns 1 if entered correctly, 0 if not
d849 2
a850 1
static char gpwbuf[33];
d852 9
a860 6
	{
	register int i,j;
	register char *gpwp;
	extern char *password;
	scbr();	/*	system("stty -echo cbreak"); */
	gpwp = gpwbuf;	lprcat("\nEnter Password: "); lflush();
d862 11
a872 6
	for (j=0; j<i; j++) read(0,gpwp++,1);	  gpwbuf[i]=0;
	sncbr(); /* system("stty echo -cbreak"); */
	if (strcmp(gpwbuf,password) != 0)
		{	lprcat("\nSorry\n");  lflush(); return(0);	}
	else  return(1);
	}
d875 2
a876 2
	subroutine to get a yes or no response from the user
	returns y or n
d878 1
d880 8
a887 5
	{
	register int i;
	i=0; while (i!='y' && i!='n' && i!='\33') i=getchar();
	return(i);
	}
d890 2
a891 2
	function to calculate the pack weight of the player
	returns the number of pounds the player is carrying
d893 1
d895 59
a953 24
	{
	register int i,j,k;
	k=c[GOLD]/1000; j=25;  while ((iven[j]==0) && (j>0)) --j;
	for (i=0; i<=j; i++)
		switch(iven[i])
			{
			case 0:												break;
			case OSSPLATE:   case OPLATEARMOR:		k += 40;	break;
			case OPLATE:							k += 35;	break;
			case OHAMMER:							k += 30;	break;
			case OSPLINT:							k += 26;	break;
			case OSWORDofSLASHING:	case OCHAIN:
			case OBATTLEAXE:   		case O2SWORD:	k += 23;	break;
			case OLONGSWORD:   		case OSWORD:
			case ORING:				case OFLAIL:	k += 20;	break;
			case OLANCE: 		case OSTUDLEATHER:	k += 15;	break;
			case OLEATHER:   		case OSPEAR:	k += 8;		break;
			case OORBOFDRAGON:   	case OBELT:		k += 4;		break;
			case OSHIELD:							k += 7;		break;
			case OCHEST:		k += 30 + ivenarg[i];			break;
			default:								k++;
			};
	return(k);
	}
d956 2
a957 1
	/* macros to generate random numbers   1<=rnd(N)<=N   0<=rund(N)<=N-1 */
d959 4
a962 4
	int x;
	{
	return((((randx=randx*1103515245+12345)>>7)%(x))+1);
	}
d964 1
d966 5
a970 5
	int x;
	{
	return((((randx=randx*1103515245+12345)>>7)%(x))  );
	}
#endif MACRORND
@


1.1
log
@Initial revision
@
text
@d29 2
a30 2
extern short playerx,playery,lastnum;
extern char cheat,level,monstnamelist[];
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
