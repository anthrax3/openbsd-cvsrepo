head	1.12;
access;
symbols
	OPENBSD_3_2:1.11.0.10
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.8
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.11.0.6
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.11.0.4
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.9.0.8
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.6
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2003.03.11.09.29.28;	author deraadt;	state dead;
branches;
next	1.11;

1.11
date	2000.08.02.04.10.45;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.29.07.55.42;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	98.10.01.05.31.38;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	98.09.15.05.12.32;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	98.02.09.16.18.28;	author ryker;	state Exp;
branches;
next	1.6;

1.6
date	97.07.15.10.21.54;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.10.28.00.07.18;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.10.26.20.02.56;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.04.45.29;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.26.07.23.09;	author fn;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.05;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.12
log
@OK, this is a strange case.  At least some parts of this software is
copyrighted, and then marked "Copying for Profit is Prohibited", but
the author has passed away.  A number of people have tried to make
some sort of effort at trying to contact his estate, and have failed.
Therefore, lacking the ability to correct this copyright, we must
delete it.  I would bet strongly that this is not what the author
would have intended, but until we can get this resolved, this is the
action we must take.
@
text
@/*	$OpenBSD: main.c,v 1.11 2000/08/02 04:10:45 millert Exp $	*/
/*	$NetBSD: main.c,v 1.12 1998/02/12 08:07:49 mikel Exp $	*/

/* main.c		 */
#ifndef lint
static char rcsid[] = "$OpenBSD: main.c,v 1.11 2000/08/02 04:10:45 millert Exp $";
#endif				/* not lint */

#include <sys/types.h>
#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <pwd.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include "header.h"
#include "extern.h"

static char	copyright[] = "\nLarn is copyrighted 1986 by Noah Morgan.\n";
int		srcount = 0;	/* line counter for showstr()	 */
int		dropflag = 0;	/* if 1 then don't lookforobject() next round */
int		rmst = 80;	/* random monster creation counter	*/
int		userid;		/* the players login user id number	*/
gid_t		gid, egid;	/* used for security			*/
u_char		nowelcome = 0, nomove = 0;	/* if (nomove) then don't
						 * count next iteration as a
						 * move */
static char	viewflag = 0;
/*
 * if viewflag then we have done a 99 stay here and don't showcell in the
 * main loop
 */
u_char		restorflag = 0;	/* 1 means restore has been done	 */
static char	cmdhelp[] = "\
Cmd line format: larn [-slicnh] [-o<optsfile>] [-##] [++]\n\
  -s   show the scoreboard\n\
  -l   show the logfile (wizards only)\n\
  -i   show scoreboard with inventories of dead characters\n\
  -c   create new scoreboard (wizards only)\n\
  -n   suppress welcome message on starting game\n\
  -##  specify level of difficulty (example: -5)\n\
  -h   print this help text\n\
  ++   restore game from checkpoint file\n\
  -o<optsfile>   specify .larnopts filename to be used instead of \"~/.larnopts\"\n\
";

/*
 *	************
 *	MAIN PROGRAM
 *	************
 */
int
main(argc, argv)
	int	argc;
	char	**argv;
{
	int	i;
	int	hard;
	const char	*ptr = 0;
	struct passwd	*pwe;

	egid = getegid();
	gid = getgid();
	setegid(gid);		/* give up "games" if we have it */
	/*
	 *	first task is to identify the player
	 */
	init_term();		/* setup the terminal (find out what type)
				 * for termcap */
	/* try to get login name */
	if (((ptr = getlogin()) == 0) || (*ptr == 0)) {
		/* can we get it from /etc/passwd? */
		if ((pwe = getpwuid(getuid())) != NULL)
			ptr = pwe->pw_name;
		else
#ifdef NOSPAM
		    if ((ptr = getenv("LOGNAME")) == 0)
			if ((ptr = getenv("USER")) == 0)
#endif
		noone:		errx(1, "can't find your logname.  Who Are You?");
	}
	if (ptr == 0)
		goto noone;
	if (strlen(ptr) == 0)
		goto noone;
	/*
	 *	second task is to prepare the pathnames the player will need
	 */
	strlcpy(loginname, ptr, LOGIN_NAME_MAX);
	/* this will be overwritten with the player's name */
	strlcpy(logname, ptr, LOGNAMESIZE);
	if ((ptr = getenv("HOME")) == NULL) {
		fprintf(stderr, "You have no home directory!\n");
		exit(1);
	}
	if (strlen(ptr) + 9 < sizeof(savefilename)) {
		strcpy(savefilename, ptr);
		strcat(savefilename, "/Larn.sav");	/* save file name in
							 * home directory */
	} else {
		fprintf(stderr, "%s/Larn.sav: %s\n", ptr, strerror(ENAMETOOLONG));
		exit(1);
	}
	if (strlen(ptr) + 10 < sizeof(savefilename)) {
		strcpy(optsfile, ptr);
		strcat(optsfile, "/.larnopts");	/* the .larnopts filename */
	} else {
		fprintf(stderr, "%s/.larnopts: %s\n", ptr, strerror(ENAMETOOLONG));
		exit(1);
	}

	/*
	 *	now malloc the memory for the dungeon
	 */
	cell = (struct cel *) malloc(sizeof(struct cel) * (MAXLEVEL + MAXVLEVEL) * MAXX * MAXY);
	if (cell == 0)
		died(-285);	/* malloc failure */
	lpbuf = malloc((5 * BUFBIG) >> 2);	/* output buffer */
	inbuffer = malloc((5 * MAXIBUF) >> 2);	/* output buffer */
	if ((lpbuf == 0) || (inbuffer == 0))
		died(-285);	/* malloc() failure */

	lcreat((char *) 0);
	newgame();		/* set the initial clock  */
	hard = -1;

	/*
	 *	now make scoreboard if it is not there (don't clear)
	 */
	if (access(scorefile, 0) == -1)	/* not there */
		makeboard();

	/*
	 *	now process the command line arguments
	 */
	for (i = 1; i < argc; i++) {
		if (argv[i][0] == '-')
			switch (argv[i][1]) {
			case 's':
				showscores();
				exit(0);	/* show scoreboard	*/

			case 'l':		/* show log file	*/
				diedlog();
				exit(0);

			case 'i':
				showallscores();
				exit(0);	/* show all scoreboard */

			case 'c':	/* anyone with password can create
					 * scoreboard */
				lprcat("Preparing to initialize the scoreboard.\n");
				if (getpassword() != 0) {	/* make new scoreboard */
					makeboard();
					lprc('\n');
					showscores();
				}
				exit(0);

			case 'n':	/* no welcome msg	 */
				nowelcome = 1;
				argv[i][0] = 0;
				break;

			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	/* for hardness */
				sscanf(&argv[i][1], "%d", &hard);
				break;

			case 'h':	/* print out command line arguments */
				write(1, cmdhelp, sizeof(cmdhelp));
				exit(0);

			case 'o':	/* specify a .larnopts filename */
				strlcpy(optsfile, argv[i] + 2, PATH_MAX);
				break;

			default:
				printf("Unknown option <%s>\n", argv[i]);
				exit(1);
			};

		if (argv[i][0] == '+') {
			clear();
			restorflag = 1;
			if (argv[i][1] == '+') {
				hitflag = 1;
				restoregame(ckpfile);	/* restore checkpointed
							 * game */
			}
			i = argc;
		}
	}

	readopts();		/* read the options file if there is one */


#ifdef UIDSCORE
	userid = geteuid();	/* obtain the user's effective id number */
#else	/* UIDSCORE */
	userid = getplid(logname);	/* obtain the players id number */
#endif	/* UIDSCORE */
	if (userid < 0) {
		write(2, "Can't obtain playerid\n", 22);
		exit(1);
	}

	if (access(savefilename, 0) == 0) {	/* restore game if need to */
		clear();
		restorflag = 1;
		hitflag = 1;
		restoregame(savefilename);	/* restore last game	 */
	}
	sigsetup();		/* trap all needed signals		*/
	sethard(hard);		/* set up the desired difficulty	*/
	setupvt100();		/* setup the terminal special mode	*/
	if (c[HP] == 0) {	/* create new game			*/
		makeplayer();	/* make the character that will play	*/
		newcavelevel(0);/* make the dungeon			*/
		predostuff = 1;	/* tell signals that we are in the welcome
				 * screen */
		if (nowelcome == 0)
			welcome();	/* welcome the player to the game */
	}
	drawscreen();		/* show the initial dungeon		*/
	predostuff = 2;		/* tell the trap functions that they must do
				 * a showplayer() from here on */
#if 0
	nice(1);		/* games should be run niced		*/
#endif
	yrepcount = hit2flag = 0;
	while (1) {
		if (dropflag == 0)
			lookforobject();	/* see if there is an object
						 * here	 */
		else
			dropflag = 0;	/* don't show it just dropped an item */
		if (hitflag == 0) {
			if (c[HASTEMONST])
				movemonst();
			movemonst();
		}		/* move the monsters		 */
		if (viewflag == 0)
			showcell(playerx, playery);
		else
			viewflag = 0;	/* show stuff around player	 */
		if (hit3flag)
			flushall();
		hitflag = hit3flag = 0;
		nomove = 1;
		bot_linex();	/* update bottom line */
		while (nomove) {
			if (hit3flag)
				flushall();
			nomove = 0;
			parse();
		}		/* get commands and make moves	*/
		regen();	/* regenerate hp and spells	*/
		if (c[TIMESTOP] == 0)
			if (--rmst <= 0) {
				rmst = 120 - (level << 2);
				fillmonst(makemonst(level));
			}
	}
}


/*
 *	showstr()
 *
 *	show character's inventory
 */
void
showstr()
{
	int	i, number;

	for (number = 3, i = 0; i < 26; i++)
		if (iven[i])
			number++;	/* count items in inventory */
	t_setup(number);
	qshowstr();
	t_endup(number);
}

void
qshowstr()
{
	int	i, j, k, sigsav;

	srcount = 0;
	sigsav = nosignal;
	nosignal = 1;		/* don't allow ^c etc */
	if (c[GOLD]) {
		lprintf(".)   %d gold pieces", (long) c[GOLD]);
		srcount++;
	}
	for (k = 26; k >= 0; k--)
		if (iven[k]) {
			for (i = 22; i < 84; i++)
				for (j = 0; j <= k; j++)
					if (i == iven[j])
						show3(j);
			k = 0;
		}
	lprintf("\nElapsed time is %d.  You have %d mobuls left", (long) ((gltime + 99) / 100 + 1), (long) ((TIMELIMIT - gltime) / 100));
	more();
	nosignal = sigsav;
}

/*
 *	subroutine to clear screen depending on # lines to display
 */
void
t_setup(count)
	int	count;
{
	if (count < 20) {	/* how do we clear the screen? */
		cl_up(79, count);
		cursor(1, 1);
	} else {
		resetscroll();
		clear();
	}
}

/*
 *	subroutine to restore normal display screen depending on t_setup()
 */
void
t_endup(count)
	int	count;
{
	if (count < 18)		/* how did we clear the screen? */
		draws(0, MAXX, 0, (count > MAXY) ? MAXY : count);
	else {
		drawscreen();
		setscroll();
	}
}

/*
 *	function to show the things player is wearing only
 */
void
showwear()
{
	int	i, j, sigsav, count;

	sigsav = nosignal;
	nosignal = 1;		/* don't allow ^c etc */
	srcount = 0;

	for (count = 2, j = 0; j <= 26; j++)	/* count number of items we
						 * will display */
		if ((i = iven[j]) != 0)
			switch (i) {
			case OLEATHER:
			case OPLATE:
			case OCHAIN:
			case ORING:
			case OSTUDLEATHER:
			case OSPLINT:
			case OPLATEARMOR:
			case OSSPLATE:
			case OSHIELD:
				count++;
			};

	t_setup(count);

	for (i = 22; i < 84; i++)
		for (j = 0; j <= 26; j++)
			if (i == iven[j])
				switch (i) {
				case OLEATHER:
				case OPLATE:
				case OCHAIN:
				case ORING:
				case OSTUDLEATHER:
				case OSPLINT:
				case OPLATEARMOR:
				case OSSPLATE:
				case OSHIELD:
					show3(j);
				};
	more();
	nosignal = sigsav;
	t_endup(count);
}

/*
 *	function to show the things player can wield only
 */
void
showwield()
{
	int	i, j, sigsav, count;

	sigsav = nosignal;
	nosignal = 1;		/* don't allow ^c etc */
	srcount = 0;

	for (count = 2, j = 0; j <= 26; j++)	/* count how many items */
		if ((i = iven[j]) != 0)
			switch (i) {
			case ODIAMOND:
			case ORUBY:
			case OEMERALD:
			case OSAPPHIRE:
			case OBOOK:
			case OCHEST:
			case OLARNEYE:
			case ONOTHEFT:
			case OSPIRITSCARAB:
			case OCUBEofUNDEAD:
			case OPOTION:
			case OSCROLL:
				break;
			default:
				count++;
			};

	t_setup(count);

	for (i = 22; i < 84; i++)
		for (j = 0; j <= 26; j++)
			if (i == iven[j])
				switch (i) {
				case ODIAMOND:
				case ORUBY:
				case OEMERALD:
				case OSAPPHIRE:
				case OBOOK:
				case OCHEST:
				case OLARNEYE:
				case ONOTHEFT:
				case OSPIRITSCARAB:
				case OCUBEofUNDEAD:
				case OPOTION:
				case OSCROLL:
					break;
				default:
					show3(j);
				};
	more();
	nosignal = sigsav;
	t_endup(count);
}

/*
 *	function to show the things player can read only
 */
void
showread()
{
	int	i, j, sigsav, count;

	sigsav = nosignal;
	nosignal = 1;		/* don't allow ^c etc */
	srcount = 0;

	for (count = 2, j = 0; j <= 26; j++)
		switch (iven[j]) {
		case OBOOK:
		case OSCROLL:
			count++;
		};
	t_setup(count);

	for (i = 22; i < 84; i++)
		for (j = 0; j <= 26; j++)
			if (i == iven[j])
				switch (i) {
				case OBOOK:
				case OSCROLL:
					show3(j);
				};
	more();
	nosignal = sigsav;
	t_endup(count);
}

/*
 *	function to show the things player can eat only
 */
void
showeat()
{
	int	i, j, sigsav, count;

	sigsav = nosignal;
	nosignal = 1;		/* don't allow ^c etc */
	srcount = 0;

	for (count = 2, j = 0; j <= 26; j++)
		switch (iven[j]) {
		case OCOOKIE:
			count++;
		};
	t_setup(count);

	for (i = 22; i < 84; i++)
		for (j = 0; j <= 26; j++)
			if (i == iven[j])
				switch (i) {
				case OCOOKIE:
					show3(j);
				};
	more();
	nosignal = sigsav;
	t_endup(count);
}

/*
 *	function to show the things player can quaff only
 */
void
showquaff()
{
	int	i, j, sigsav, count;

	sigsav = nosignal;
	nosignal = 1;		/* don't allow ^c etc */
	srcount = 0;

	for (count = 2, j = 0; j <= 26; j++)
		switch (iven[j]) {
		case OPOTION:
			count++;
		};
	t_setup(count);

	for (i = 22; i < 84; i++)
		for (j = 0; j <= 26; j++)
			if (i == iven[j])
				switch (i) {
				case OPOTION:
					show3(j);
				};
	more();
	nosignal = sigsav;
	t_endup(count);
}

void
show1(idx, str2)
	int	idx;
	char	*str2[];
{
	lprintf("\n%c)   %s", idx + 'a', objectname[iven[idx]]);
	if (str2 != 0 && str2[ivenarg[idx]][0] != 0)
		lprintf(" of%s", str2[ivenarg[idx]]);
}

void
show3(index)
	int	index;
{
	switch (iven[index]) {
	case OPOTION:
		show1(index, potionname);
		break;
	case OSCROLL:
		show1(index, scrollname);
		break;

	case OLARNEYE:
	case OBOOK:
	case OSPIRITSCARAB:
	case ODIAMOND:
	case ORUBY:
	case OCUBEofUNDEAD:
	case OEMERALD:
	case OCHEST:
	case OCOOKIE:
	case OSAPPHIRE:
	case ONOTHEFT:
		show1(index, (char **) 0);
		break;

	default:
		lprintf("\n%c)   %s", index + 'a', objectname[iven[index]]);
		if (ivenarg[index] > 0)
			lprintf(" + %d", (long) ivenarg[index]);
		else if (ivenarg[index] < 0)
			lprintf(" %d", (long) ivenarg[index]);
		break;
	}
	if (c[WIELD] == index)
		lprcat(" (weapon in hand)");
	if ((c[WEAR] == index) || (c[SHIELD] == index))
		lprcat(" (being worn)");
	if (++srcount >= 22) {
		srcount = 0;
		more();
		clear();
	}
}

/*
 *	subroutine to randomly create monsters if needed
 */
void
randmonst()
{
	if (c[TIMESTOP])
		return;		/* don't make monsters if time is stopped */
	if (--rmst <= 0) {
		rmst = 120 - (level << 2);
		fillmonst(makemonst(level));
	}
}



/*
 *	parse()
 *
 *	get and execute a command
 */
void
parse()
{
	int	i, j, k, flag;

	while (1) {
		k = yylex();
		switch (k) {	/* get the token from the input	 */
		case 'h':
			moveplayer(4);
			return;	/* west		*/
		case 'H':
			run(4);
			return;	/* west		*/
		case 'l':
			moveplayer(2);
			return;	/* east		*/
		case 'L':
			run(2);
			return;	/* east		*/
		case 'j':
			moveplayer(1);
			return;	/* south	*/
		case 'J':
			run(1);
			return;	/* south	*/
		case 'k':
			moveplayer(3);
			return;	/* north	*/
		case 'K':
			run(3);
			return;	/* north	*/
		case 'u':
			moveplayer(5);
			return;	/* northeast	*/
		case 'U':
			run(5);
			return;	/* northeast	 */
		case 'y':
			moveplayer(6);
			return;	/* northwest	*/
		case 'Y':
			run(6);
			return;	/* northwest	*/
		case 'n':
			moveplayer(7);
			return;	/* southeast	*/
		case 'N':
			run(7);
			return;	/* southeast	*/
		case 'b':
			moveplayer(8);
			return;	/* southwest	*/
		case 'B':
			run(8);
			return;	/* southwest	*/

		case '.':
			if (yrepcount)
				viewflag = 1;
			return;	/* stay here	*/

		case 'w':
			yrepcount = 0;
			wield();
			return;	/* wield a weapon */

		case 'W':
			yrepcount = 0;
			wear();
			return;	/* wear armor	*/

		case 'r':
			yrepcount = 0;
			if (c[BLINDCOUNT]) {
				cursors();
				lprcat("\nYou can't read anything when you're blind!");
			} else if (c[TIMESTOP] == 0)
				readscr();
			return;	/* to read a scroll	*/

		case 'q':
			yrepcount = 0;
			if (c[TIMESTOP] == 0)
				quaff();
			return;	/* quaff a potion	*/

		case 'd':
			yrepcount = 0;
			if (c[TIMESTOP] == 0)
				dropobj();
			return;	/* to drop an object	*/

		case 'c':
			yrepcount = 0;
			cast();
			return;	/* cast a spell		*/

		case 'i':
			yrepcount = 0;
			nomove = 1;
			showstr();
			return;	/* status		*/

		case 'e':
			yrepcount = 0;
			if (c[TIMESTOP] == 0)
				eatcookie();
			return;	/* to eat a fortune cookie */

		case 'D':
			yrepcount = 0;
			seemagic(0);
			nomove = 1;
			return;	/* list spells and scrolls */

		case '?':
			yrepcount = 0;
			help();
			nomove = 1;
			return;	/* give the help screen */

		case 'S':
			clear();
			lprcat("Saving . . .");
			lflush();
			if (savegame(savefilename) < 0)
				return;
			wizard = 1;
			died(-257);	/* save the game - doesn't return */

		case 'Z':
			yrepcount = 0;
			if (c[LEVEL] > 9) {
				oteleport(1);
				return;
			}
			cursors();
			lprcat("\nAs yet, you don't have enough experience to use teleportation");
			return;	/* teleport yourself	 */

		case '^':	/* identify traps */
			flag = yrepcount = 0;
			cursors();
			lprc('\n');
			for (j = playery - 1; j < playery + 2; j++) {
				if (j < 0)
					j = 0;
				if (j >= MAXY)
					break;
				for (i = playerx - 1; i < playerx + 2; i++) {
					if (i < 0)
						i = 0;
					if (i >= MAXX)
						break;
					switch (item[i][j]) {
					case OTRAPDOOR:
					case ODARTRAP:
					case OTRAPARROW:
					case OTELEPORTER:
						lprcat("\nIts ");
						lprcat(objectname[item[i][j]]);
						flag++;
					};
				}
			}
			if (flag == 0)
				lprcat("\nNo traps are visible");
			return;

#if WIZID
		case '_':	/* this is the fudge player password for
				 * wizard mode */
			yrepcount = 0;
			cursors();
			nomove = 1;
			if (userid != wisid) {
				lprcat("Sorry, you are not empowered to be a wizard.\n");
				scbr();	/* system("stty -echo cbreak"); */
				lflush();
				return;
			}
			if (getpassword() == 0) {
				scbr();	/* system("stty -echo cbreak"); */
				return;
			}
			wizard = 1;
			scbr();	/* system("stty -echo cbreak"); */
			for (i = 0; i < 6; i++)
				c[i] = 70;
			iven[0] = iven[1] = 0;
			take(OPROTRING, 50);
			take(OLANCE, 25);
			c[WIELD] = 1;
			c[LANCEDEATH] = 1;
			c[WEAR] = c[SHIELD] = -1;
			raiseexperience(6000000L);
			c[AWARENESS] += 25000;
			{
				int	i, j;
				for (i = 0; i < MAXY; i++)
					for (j = 0; j < MAXX; j++)
						know[j][i] = 1;
				for (i = 0; i < SPNUM; i++)
					spelknow[i] = 1;
				for (i = 0; i < MAXSCROLL; i++)
					scrollname[i] = scrollhide[i];
				for (i = 0; i < MAXPOTION; i++)
					potionname[i] = potionhide[i];
			}
			for (i = 0; i < MAXSCROLL; i++)
				if (strlen(scrollname[i]) > 2) {	/* no null items */
					item[i][0] = OSCROLL;
					iarg[i][0] = i;
				}
			for (i = MAXX - 1; i > MAXX - 1 - MAXPOTION; i--)
				if (strlen(potionname[i - MAXX + MAXPOTION]) > 2) {	/* no null items */
					item[i][0] = OPOTION;
					iarg[i][0] = i - MAXX + MAXPOTION;
				}
			for (i = 1; i < MAXY; i++) {
				item[0][i] = i;
				iarg[0][i] = 0;
			}
			for (i = MAXY; i < MAXY + MAXX; i++) {
				item[i - MAXY][MAXY - 1] = i;
				iarg[i - MAXY][MAXY - 1] = 0;
			}
			for (i = MAXX + MAXY; i < MAXX + MAXY + MAXY; i++) {
				item[MAXX - 1][i - MAXX - MAXY] = i;
				iarg[MAXX - 1][i - MAXX - MAXY] = 0;
			}
			c[GOLD] += 25000;
			drawscreen();
			return;
#endif

		case 'T':
			yrepcount = 0;
			cursors();
			if (c[SHIELD] != -1) {
				c[SHIELD] = -1;
				lprcat("\nYour shield is off");
				bottomline();
			} else if (c[WEAR] != -1) {
				c[WEAR] = -1;
				lprcat("\nYour armor is off");
				bottomline();
			} else
				lprcat("\nYou aren't wearing anything");
			return;

		case 'g':
			cursors();
			lprintf("\nThe stuff you are carrying presently weighs %d pounds", (long) packweight());
		case ' ':
			yrepcount = 0;
			nomove = 1;
			return;

		case 'v':
			yrepcount = 0;
			cursors();
			lprintf("\nCaverns of Larn, Version %d.%d, Diff=%d", (long) VERSION, (long) SUBVERSION, (long) c[HARDGAME]);
			if (wizard)
				lprcat(" Wizard");
			nomove = 1;
			if (cheat)
				lprcat(" Cheater");
			lprcat(copyright);
			return;

		case 'Q':
			yrepcount = 0;
			quit();
			nomove = 1;
			return;	/* quit		 */

		case 'L' - 64:
			yrepcount = 0;
			drawscreen();
			nomove = 1;
			return;	/* look		 */

#if WIZID
#ifdef EXTRA
		case 'A':
			yrepcount = 0;
			nomove = 1;
			if (wizard) {
				diag();
				return;
			}	/* create diagnostic file */
			return;
#endif
#endif
		case 'P':
			cursors();
			if (outstanding_taxes > 0)
				lprintf("\nYou presently owe %d gp in taxes.", (long) outstanding_taxes);
			else
				lprcat("\nYou do not owe any taxes.");
			return;
		};
	}
}

void
parse2()
{
	if (c[HASTEMONST])
		movemonst();
	movemonst();		/* move the monsters		 */
	randmonst();
	regen();
}

void
run(dir)
	int	dir;
{
	int	i;

	i = 1;
	while (i) {
		i = moveplayer(dir);
		if (i > 0) {
			if (c[HASTEMONST])
				movemonst();
			movemonst();
			randmonst();
			regen();
		}
		if (hitflag)
			i = 0;
		if (i != 0)
			showcell(playerx, playery);
	}
}

/*
	function to wield a weapon
 */
void
wield()
{
	int	i;

	while (1) {
		if ((i = whatitem("wield")) == '\33')
			return;
		if (i != '.') {
			if (i == '*')
				showwield();
			else if (iven[i - 'a'] == 0) {
				ydhi(i);
				return;
			} else if (iven[i - 'a'] == OPOTION) {
				ycwi(i);
				return;
			} else if (iven[i - 'a'] == OSCROLL) {
				ycwi(i);
				return;
			} else if ((c[SHIELD] != -1) && (iven[i - 'a'] == O2SWORD)) {
				lprcat("\nBut one arm is busy with your shield!");
				return;
			} else {
				c[WIELD] = i - 'a';
				if (iven[i - 'a'] == OLANCE)
					c[LANCEDEATH] = 1;
				else
					c[LANCEDEATH] = 0;
				bottomline();
				return;
			}
		}
	}
}

/*
 *	common routine to say you don't have an item
 */
void
ydhi(x)
	int	x;
{
	cursors();
	lprintf("\nYou don't have item %c!", x);
}

void
ycwi(x)
	int	x;
{
	cursors();
	lprintf("\nYou can't wield item %c!", x);
}

/*
 *	function to wear armor
 */
void
wear()
{
	int	i;

	while (1) {
		if ((i = whatitem("wear")) == '\33')
			return;
		if (i != '.') {
			if (i == '*')
				showwear();
			else
				switch (iven[i - 'a']) {
				case 0:
					ydhi(i);
					return;
				case OLEATHER:
				case OCHAIN:
				case OPLATE:
				case OSTUDLEATHER:
				case ORING:
				case OSPLINT:
				case OPLATEARMOR:
				case OSSPLATE:
					if (c[WEAR] != -1) {
						lprcat("\nYou're already wearing some armor");
						return;
					}
					c[WEAR] = i - 'a';
					bottomline();
					return;
				case OSHIELD:
					if (c[SHIELD] != -1) {
						lprcat("\nYou are already wearing a shield");
						return;
					}
					if (iven[c[WIELD]] == O2SWORD) {
						lprcat("\nYour hands are busy with the two handed sword!");
						return;
					}
					c[SHIELD] = i - 'a';
					bottomline();
					return;
				default:
					lprcat("\nYou can't wear that!");
				};
		}
	}
}

/*
 *	function to drop an object
 */
void
dropobj()
{
	int	i;
	char	*p;
	long	amt;

	p = &item[playerx][playery];
	while (1) {
		if ((i = whatitem("drop")) == '\33')
			return;
		if (i == '*')
			showstr();
		else {
			if (i == '.') {	/* drop some gold */
				if (*p) {
					lprcat("\nThere's something here already!");
					return;
				}
				lprcat("\n\n");
				cl_dn(1, 23);
				lprcat("How much gold do you drop? ");
				if ((amt = readnum((long) c[GOLD])) == 0)
					return;
				if (amt > c[GOLD]) {
					lprcat("\nYou don't have that much!");
					return;
				}
				if (amt <= 32767) {
					*p = OGOLDPILE;
					i = amt;
				} else if (amt <= 327670L) {
					*p = ODGOLD;
					i = amt / 10;
					amt = 10 * i;
				} else if (amt <= 3276700L) {
					*p = OMAXGOLD;
					i = amt / 100;
					amt = 100 * i;
				} else if (amt <= 32767000L) {
					*p = OKGOLD;
					i = amt / 1000;
					amt = 1000 * i;
				} else {
					*p = OKGOLD;
					i = 32767;
					amt = 32767000L;
				}
				c[GOLD] -= amt;
				lprintf("You drop %d gold pieces", (long) amt);
				iarg[playerx][playery] = i;
				bottomgold();
				know[playerx][playery] = 0;
				dropflag = 1;
				return;
			}
			drop_object(i - 'a');
			return;
		}
	}
}

/*
 *	readscr()		Subroutine to read a scroll one is carrying
 */
void
readscr()
{
	int	i;

	while (1) {
		if ((i = whatitem("read")) == '\33')
			return;
		if (i != '.') {
			if (i == '*')
				showread();
			else {
				if (iven[i - 'a'] == OSCROLL) {
					read_scroll(ivenarg[i - 'a']);
					iven[i - 'a'] = 0;
					return;
				}
				if (iven[i - 'a'] == OBOOK) {
					readbook(ivenarg[i - 'a']);
					iven[i - 'a'] = 0;
					return;
				}
				if (iven[i - 'a'] == 0) {
					ydhi(i);
					return;
				}
				lprcat("\nThere's nothing on it to read");
				return;
			}
		}
	}
}

/*
 *	subroutine to eat a cookie one is carrying
 */
void
eatcookie()
{
	int	i;
	char	*p;

	while (1) {
		if ((i = whatitem("eat")) == '\33')
			return;
		if (i != '.') {
			if (i == '*')
				showeat();
			else {
				if (iven[i - 'a'] == OCOOKIE) {
					lprcat("\nThe cookie was delicious.");
					iven[i - 'a'] = 0;
					if (!c[BLINDCOUNT]) {
						if ((p = fortune()) != NULL) {
							lprcat("  Inside you find a scrap of paper that says:\n");
							lprcat(p);
						}
					}
					return;
				}
				if (iven[i - 'a'] == 0) {
					ydhi(i);
					return;
				}
				lprcat("\nYou can't eat that!");
				return;
			}
		}
	}
}

/*
 *	subroutine to quaff a potion one is carrying
 */
void
quaff()
{
	int	i;

	while (1) {
		if ((i = whatitem("quaff")) == '\33')
			return;
		if (i != '.') {
			if (i == '*')
				showquaff();
			else {
				if (iven[i - 'a'] == OPOTION) {
					quaffpotion(ivenarg[i - 'a']);
					iven[i - 'a'] = 0;
					return;
				}
				if (iven[i - 'a'] == 0) {
					ydhi(i);
					return;
				}
				lprcat("\nYou wouldn't want to quaff that, would you? ");
				return;
			}
		}
	}
}

/*
 *	function to ask what player wants to do
 */
int
whatitem(str)
	char	*str;
{
	int	i;

	cursors();
	lprintf("\nWhat do you want to %s [* for all] ? ", str);
	i = 0;
	while (i > 'z' || (i < 'a' && i != '*' && i != '\33' && i != '.'))
		i = lgetchar();
	if (i == '\33')
		lprcat(" aborted");
	return (i);
}

/*
 *	subroutine to get a number from the player
 *	and allow * to mean return amt, else return the number entered
 */
unsigned long 
readnum(mx)
	long	mx;
{
	int	i;

	unsigned long amt = 0;
	sncbr();
	if ((i = lgetchar()) == '*')
		amt = mx;	/* allow him to say * for all gold */
	else
		while (i != '\n') {
			if (i == '\033') {
				scbr();
				lprcat(" aborted");
				return (0);
			}
			if ((i <= '9') && (i >= '0') && (amt < 99999999))
				amt = amt * 10 + i - '0';
			i = lgetchar();
		}
	scbr();
	return (amt);
}
@


1.11
log
@$HOME paranoia: never use getenv("HOME") w/o checking for NULL and non-zero
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 2000/06/29 07:55:42 pjanzen Exp $	*/
d6 1
a6 1
static char rcsid[] = "$OpenBSD: main.c,v 1.10 2000/06/29 07:55:42 pjanzen Exp $";
@


1.10
log
@Prune some obsolete defines, in particular VT100.  Eventually curses will
  replace termios.
Use system-defined limits for path lengths and usernames.
Use strlcpy() for convenience and to avoid a possible buffer overflow or two.
Various small tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 1998/10/01 05:31:38 pjanzen Exp $	*/
d6 1
a6 1
static char rcsid[] = "$OpenBSD: main.c,v 1.9 1998/10/01 05:31:38 pjanzen Exp $";
d93 4
a96 2
	if ((ptr = getenv("HOME")) == NULL)
		ptr = ".";
@


1.9
log
@'Spam' winners a bit more safely
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 1998/09/15 05:12:32 pjanzen Exp $	*/
d6 1
a6 1
static char rcsid[] = "$OpenBSD: main.c,v 1.8 1998/09/15 05:12:32 pjanzen Exp $";
d38 1
a38 1
  -l   show the logfile (wizard id only)\n\
d40 1
a40 1
  -c   create new scoreboard (wizard id only)\n\
a46 5
#ifdef VT100
static char	*termtypes[] = {"vt100", "vt101", "vt102", "vt103", "vt125",
	"vt131", "vt140", "vt180", "vt220", "vt240", "vt241", "vt320", "vt340",
"vt341"};
#endif	/* VT100 */
a68 1
#ifndef VT100
a70 1
#endif	/* VT100 */
d76 1
d78 1
a78 1
		else if ((ptr = getenv("LOGNAME")) == 0)
d90 3
a92 4
	strcpy(loginname, ptr);	/* save loginname of the user for logging
				 * purposes */
	strcpy(logname, ptr);	/* this will be overwritten with the players
				 * name */
a125 17
#ifdef VT100
	/*
	 *	check terminal type to avoid users who have not vt100 type terminals
	 */
	ttype = getenv("TERM");
	for (j = 1, i = 0; i < sizeof(termtypes) / sizeof(char *); i++)
		if (strcmp(ttype, termtypes[i]) == 0) {
			j = 0;
			break;
		}
	if (j) {
		lprcat("Sorry, Larn needs a VT100 family terminal for all it's features.\n");
		lflush();
		exit(1);
	}
#endif	/* VT100 */

d183 1
a183 2
				strncpy(optsfile, argv[i] + 2, 127);
				optsfile[127] = '\0';
a214 17
#ifdef HIDEBYLINK
	/*
	 *	this section of code causes the program to look like something else to ps
	 */
	if (strcmp(psname, argv[0])) {	/* if a different process name only */
		if ((i = access(psname, 1)) < 0) {	/* link not there */
			if (link(argv[0], psname) >= 0) {
				argv[0] = psname;
				execv(psname, argv);
			}
		} else
			unlink(psname);
	}
	for (i = 1; i < argc; i++) {
		szero(argv[i]);	/* zero the argument to avoid ps snooping */
	}
#endif	/* HIDEBYLINK */
d756 2
a757 1
			savegame(savefilename);
a1297 13

#ifdef HIDEBYLINK
/*
 *	routine to zero every byte in a string
 */
void
szero(str)
	char	*str;
{
	while (*str)
		*str++ = 0;
}
#endif	/* HIDEBYLINK */
@


1.8
log
@NetBSD merge; also renamed some functions so as not to conflict with curses
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d6 1
a6 1
static char rcsid[] = "$OpenBSD$";
d10 1
d83 1
d85 3
a87 4
			if ((ptr = getenv("USER")) == 0) {
		noone:		write(2, "Can't find your logname.  Who Are You?\n", 39);
				exit(1);
			}
@


1.7
log
@s/optsifle/optsfile/
@
text
@d1 4
d6 2
a7 2
static char rcsid[] = "$NetBSD: main.c,v 1.7.6.1 1996/05/27 15:54:26 mrg Exp $";
#endif /* not lint */
a8 1
/*	main.c		*/
a9 1
#include "header.h"
d11 1
d13 2
a14 1
#include <stdio.h>
d16 2
d19 16
a34 11
static char copyright[]="\nLarn is copyrighted 1986 by Noah Morgan.\n";
int srcount=0;	/* line counter for showstr()	*/
int dropflag=0; /* if 1 then don't lookforobject() next round */
int rmst=80;	/*	random monster creation counter		*/
int userid;		/* the players login user id number */
uid_t uid, euid;	/* used for security */
char nowelcome=0,nomove=0; /* if (nomove) then don't count next iteration as a move */
static char viewflag=0;
	/*	if viewflag then we have done a 99 stay here and don't showcell in the main loop */
char restorflag=0;	/* 1 means restore has been done	*/
static char cmdhelp[] = "\
d47 1
a47 1
static char *termtypes[] = { "vt100", "vt101", "vt102", "vt103", "vt125",
d49 3
a51 2
	"vt341"  };
#endif VT100
d53 20
a72 19
	************
	MAIN PROGRAM
	************
 */
main(argc,argv)
	int argc;
	char **argv;
	{
	register int i,j;
	int hard;
	char *ptr=0,*ttype;
	struct passwd *pwe;

	euid = geteuid();
	uid = getuid();
	seteuid(uid);	/* give up "games" if we have it */
/*
 *	first task is to identify the player
 */
d74 27
a100 20
	init_term();	/* setup the terminal (find out what type) for termcap */
#endif VT100
	if (((ptr = getlogin()) == 0) || (*ptr==0))	/* try to get login name */
	  if (pwe=getpwuid(getuid())) /* can we get it from /etc/passwd? */
		ptr = pwe->pw_name;
	  else
	  if ((ptr = getenv("LOGNAME")) == 0)
		if ((ptr = getenv("USER")) == 0)
		  {
		  noone: write(2, "Can't find your logname.  Who Are You?\n",39);
		 		 exit();
		  }
	if (ptr==0) goto noone;
	if (strlen(ptr)==0) goto noone;
/*
 *	second task is to prepare the pathnames the player will need
 */
	strcpy(loginname,ptr); /* save loginname of the user for logging purposes */
	strcpy(logname,ptr);	/* this will be overwritten with the players name */
	if ((ptr = getenv("HOME")) == 0) ptr = ".";
d103 2
a104 1
		strcat(savefilename, "/Larn.sav");	/* save file name in home directory */
d107 1
a107 1
		exit();
d111 1
a111 1
		strcat(optsfile, "/.larnopts");		/* the .larnopts filename */
d114 1
a114 1
		exit();
d117 14
a130 10
/*
 *	now malloc the memory for the dungeon 
 */
	cell = (struct cel *)malloc(sizeof(struct cel)*(MAXLEVEL+MAXVLEVEL)*MAXX*MAXY);
	if (cell == 0) died(-285);	/* malloc failure */
	lpbuf    = malloc((5* BUFBIG)>>2);	/* output buffer */
	inbuffer = malloc((5*MAXIBUF)>>2);	/* output buffer */
	if ((lpbuf==0) || (inbuffer==0)) died(-285); /* malloc() failure */

	lcreat((char*)0);	newgame();		/*	set the initial clock  */ hard= -1;
d133 3
a135 3
/*
 *	check terminal type to avoid users who have not vt100 type terminals
 */
d137 4
a140 6
	for (j=1, i=0; i<sizeof(termtypes)/sizeof(char *); i++)
		if (strcmp(ttype,termtypes[i]) == 0) { j=0;  break; }
	if (j)
		{
		lprcat("Sorry, Larn needs a VT100 family terminal for all it's features.\n"); lflush();
		exit();
d142 11
a152 6
#endif VT100

/*
 *	now make scoreboard if it is not there (don't clear) 
 */
	if (access(scorefile,0) == -1) /* not there */
d155 4
a158 5
/*
 *	now process the command line arguments 
 */
	for (i=1; i<argc; i++)
		{
d160 22
a181 6
		  switch(argv[i][1])
			{
			case 's': showscores();  exit();  /* show scoreboard   */

			case 'l': /* show log file     */
						diedlog();		exit();
d183 17
a199 16
			case 'i': showallscores();  exit();  /* show all scoreboard */

			case 'c': 		 /* anyone with password can create scoreboard */
					  lprcat("Preparing to initialize the scoreboard.\n");
					  if (getpassword() != 0)  /*make new scoreboard*/
							{
							makeboard(); lprc('\n'); showscores();
							}
					  exit();

			case 'n':	/* no welcome msg	*/ nowelcome=1; argv[i][0]=0; break;

			case '0': case '1': case '2': case '3': case '4': case '5':
			case '6': case '7': case '8': case '9':	/* for hardness */
						sscanf(&argv[i][1],"%d",&hard);	
						break;
d202 2
a203 1
						write(1,cmdhelp,sizeof(cmdhelp));  exit();
d206 7
a212 5
						strncpy(optsfile,argv[i]+2,127);
						optsfile[127] = '\0';
						break;

			default:	printf("Unknown option <%s>\n",argv[i]);  exit();
d215 8
a222 7
		if (argv[i][0] == '+')
			{
			clear();	restorflag = 1;
			if (argv[i][1] == '+')
				{
				hitflag=1; restoregame(ckpfile); /* restore checkpointed game */
				}
a223 1
			}
d225 1
d232 1
a232 1
#else UIDSCORE
d234 5
a238 3
#endif UIDSCORE
	if (userid < 0) { write(2,"Can't obtain playerid\n",22); exit(); }

d240 8
a247 11
/*
 *	this section of code causes the program to look like something else to ps
 */
	if (strcmp(psname,argv[0])) /* if a different process name only */
		{
		if ((i=access(psname,1)) < 0)
			{		/* link not there */
			if (link(argv[0],psname)>=0)
				{
				argv[0] = psname;   execv(psname,argv);
				}
d249 1
a249 1
		else 
d251 2
a252 4
		}

	for (i=1; i<argc; i++)
		{
d254 2
a255 2
		}
#endif HIDEBYLINK
d257 23
a279 19
	if (access(savefilename,0)==0)	/* restore game if need to */
		{
		clear();	restorflag = 1;
		hitflag=1;	restoregame(savefilename);  /* restore last game	*/
		}
	sigsetup();		/* trap all needed signals	*/
	sethard(hard);	/* set up the desired difficulty				*/
	setupvt100();	/*	setup the terminal special mode				*/
	if (c[HP]==0)	/* create new game */
		{
		makeplayer();	/*	make the character that will play			*/
		newcavelevel(0);/*	make the dungeon						 	*/
		predostuff = 1;	/* tell signals that we are in the welcome screen */
		if (nowelcome==0) welcome();	 /* welcome the player to the game */
		}
	drawscreen();	/*	show the initial dungeon					*/
	predostuff = 2;	/* tell the trap functions that they must do a showplayer()
						from here on */
	/* nice(1); */	/* games should be run niced */
d281 19
a299 8
	while (1)
		{
		if (dropflag==0) lookforobject(); /* see if there is an object here	*/
			else dropflag=0; /* don't show it just dropped an item */
		if (hitflag==0) { if (c[HASTEMONST]) movemonst(); movemonst(); }	/*	move the monsters		*/
		if (viewflag==0) showcell(playerx,playery); else viewflag=0;	/*	show stuff around player	*/
		if (hit3flag) flushall();
		hitflag=hit3flag=0;	nomove=1;
d301 12
a312 10
		while (nomove)
			{
			if (hit3flag) flushall();
			nomove=0; parse();
			}	/*	get commands and make moves	*/
		regen();			/*	regenerate hp and spells			*/
		if (c[TIMESTOP]==0)
			if (--rmst <= 0)
				{ rmst = 120-(level<<2); fillmonst(makemonst(level)); }
		}
d314 3
a316 1

d318 3
a320 3
	showstr()

	show character's inventory
d322 1
d324 10
a333 6
	{
	register int i,number;
	for (number=3, i=0; i<26; i++)
		if (iven[i]) number++;	/* count items in inventory */
	t_setup(number);	qshowstr();	  t_endup(number);
	}
d335 1
d337 2
a338 8
	{
	register int i,j,k,sigsav;
	srcount=0;  sigsav=nosignal;  nosignal=1; /* don't allow ^c etc */
	if (c[GOLD]) { lprintf(".)   %d gold pieces",(long)c[GOLD]); srcount++; }
	for (k=26; k>=0; k--)
	  if (iven[k])
		{  for (i=22; i<84; i++)
			 for (j=0; j<=k; j++)  if (i==iven[j])  show3(j); k=0; }
d340 19
a358 3
	lprintf("\nElapsed time is %d.  You have %d mobuls left",(long)((gltime+99)/100+1),(long)((TIMELIMIT-gltime)/100));
	more();		nosignal=sigsav;
	}
d363 1
d365 8
a372 10
	register int count;
	{
	if (count<20)  /* how do we clear the screen? */
		{
		cl_up(79,count);  cursor(1,1);
		}
	else
		{
		resetscroll(); clear();
		}
d374 1
d379 1
d381 7
a387 8
	register int count;
	{
	if (count<18)  /* how did we clear the screen? */
		draws(0,MAXX,0,(count>MAXY) ? MAXY : count);
	else
		{
		drawscreen(); setscroll();
		}
d389 1
d392 1
a392 1
	function to show the things player is wearing only
d394 1
d396 21
a416 13
	{
	register int i,j,sigsav,count;
	sigsav=nosignal;  nosignal=1; /* don't allow ^c etc */
	srcount=0;

	 for (count=2,j=0; j<=26; j++)	 /* count number of items we will display */
	   if (i=iven[j])
		switch(i)
			{
			case OLEATHER:	case OPLATE:	case OCHAIN:
			case ORING:		case OSTUDLEATHER:	case OSPLINT:
			case OPLATEARMOR:	case OSSPLATE:	case OSHIELD:
			count++;
d421 14
a434 9
	for (i=22; i<84; i++)
		 for (j=0; j<=26; j++)
		   if (i==iven[j])
			switch(i)
				{
				case OLEATHER:	case OPLATE:	case OCHAIN:
				case ORING:		case OSTUDLEATHER:	case OSPLINT:
				case OPLATEARMOR:	case OSSPLATE:	case OSHIELD:
				show3(j);
d436 4
a439 2
	more();		nosignal=sigsav;	t_endup(count);
	}
d442 1
a442 1
	function to show the things player can wield only 
d444 1
d446 25
a470 14
	{
	register int i,j,sigsav,count;
	sigsav=nosignal;  nosignal=1; /* don't allow ^c etc */
	srcount=0;

	 for (count=2,j=0; j<=26; j++)	/* count how many items */
	   if (i=iven[j])
		switch(i)
			{
			case ODIAMOND:  case ORUBY:  case OEMERALD:  case OSAPPHIRE:
			case OBOOK:     case OCHEST:  case OLARNEYE: case ONOTHEFT:
			case OSPIRITSCARAB:  case OCUBEofUNDEAD:
			case OPOTION:   case OSCROLL:  break;
			default:  count++;
d475 19
a493 10
	for (i=22; i<84; i++)
		 for (j=0; j<=26; j++)
		   if (i==iven[j])
			switch(i)
				{
				case ODIAMOND:  case ORUBY:  case OEMERALD:  case OSAPPHIRE:
				case OBOOK:     case OCHEST:  case OLARNEYE: case ONOTHEFT:
				case OSPIRITSCARAB:  case OCUBEofUNDEAD:
				case OPOTION:   case OSCROLL:  break;
				default:  show3(j);
d495 4
a498 2
	more();		nosignal=sigsav;	t_endup(count);
	}
d503 1
d505 2
a506 4
	{
	register int i,j,sigsav,count;
	sigsav=nosignal;  nosignal=1; /* don't allow ^c etc */
	srcount=0;
d508 10
a517 5
	for (count=2,j=0; j<=26; j++)
		switch(iven[j])
			{
			case OBOOK:	case OSCROLL:	count++;
			};
d520 7
a526 6
	for (i=22; i<84; i++)
		 for (j=0; j<=26; j++)
		   if (i==iven[j])
			switch(i)
				{
				case OBOOK:	case OSCROLL:	show3(j);
d528 4
a531 2
	more();		nosignal=sigsav;	t_endup(count);
	}
d536 1
d538 2
a539 4
	{
	register int i,j,sigsav,count;
	sigsav=nosignal;  nosignal=1; /* don't allow ^c etc */
	srcount=0;
d541 9
a549 5
	for (count=2,j=0; j<=26; j++)
		switch(iven[j])
			{
			case OCOOKIE:	count++;
			};
d552 6
a557 6
	for (i=22; i<84; i++)
		 for (j=0; j<=26; j++)
		   if (i==iven[j])
			switch(i)
				{
				case OCOOKIE:	show3(j);
d559 4
a562 2
	more();		nosignal=sigsav;	t_endup(count);
	}
d565 1
a565 1
	function to show the things player can quaff only
d567 1
d569 2
a570 4
	{
	register int i,j,sigsav,count;
	sigsav=nosignal;  nosignal=1; /* don't allow ^c etc */
	srcount=0;
d572 9
a580 5
	for (count=2,j=0; j<=26; j++)
		switch(iven[j])
			{
			case OPOTION:	count++;
			};
d583 6
a588 6
	for (i=22; i<84; i++)
		 for (j=0; j<=26; j++)
		   if (i==iven[j])
			switch(i)
				{
				case OPOTION:	show3(j);
d590 4
a593 2
	more();		nosignal=sigsav;		t_endup(count);
	}
d595 9
a603 7
show1(idx,str2)
	register int idx;
	register char *str2[];
	{
	lprintf("\n%c)   %s",idx+'a',objectname[iven[idx]]);
	if (str2!=0 && str2[ivenarg[idx]][0]!=0)  lprintf(" of%s",str2[ivenarg[idx]]);
	}
d605 1
d607 40
a646 20
	register int index;
	{
	switch(iven[index]) 
		{
		case OPOTION:	show1(index,potionname);  break;
		case OSCROLL:	show1(index,scrollname);  break;

		case OLARNEYE:		case OBOOK:			case OSPIRITSCARAB:
		case ODIAMOND:		case ORUBY:			case OCUBEofUNDEAD:
		case OEMERALD:		case OCHEST:		case OCOOKIE:
		case OSAPPHIRE:		case ONOTHEFT:		show1(index,(char **)0);  break;

		default:		lprintf("\n%c)   %s",index+'a',objectname[iven[index]]);
						if (ivenarg[index]>0) lprintf(" + %d",(long)ivenarg[index]);
						else if (ivenarg[index]<0) lprintf(" %d",(long)ivenarg[index]);
						break;
		}
	if (c[WIELD]==index) lprcat(" (weapon in hand)");
	if ((c[WEAR]==index) || (c[SHIELD]==index))  lprcat(" (being worn)");
	if (++srcount>=22) { srcount=0; more(); clear(); }
d648 1
d651 1
a651 1
	subroutine to randomly create monsters if needed
d653 1
d655 6
a660 6
	{
	if (c[TIMESTOP]) return;	/*	don't make monsters if time is stopped	*/
	if (--rmst <= 0)
		{
		rmst = 120 - (level<<2);  fillmonst(makemonst(level));
		}
d662 3
a665 1

d667 3
a669 3
	parse()

	get and execute a command
d671 1
d673 4
a676 4
	{
	register int i,j,k,flag;
	while	(1)
		{
d678 161
a838 68
		switch(k)	/*	get the token from the input and switch on it	*/
			{
			case 'h':	moveplayer(4);	return;		/*	west		*/
			case 'H':	run(4);			return;		/*	west		*/
			case 'l':	moveplayer(2);	return;		/*	east		*/
			case 'L':	run(2);			return;		/*	east		*/
			case 'j':	moveplayer(1);	return;		/*	south		*/
			case 'J':	run(1);			return;		/*	south		*/
			case 'k':	moveplayer(3);	return;		/*	north		*/
			case 'K':	run(3);			return;		/*	north		*/
			case 'u':	moveplayer(5);	return;		/*	northeast	*/
			case 'U':	run(5);			return;		/*	northeast	*/
			case 'y':	moveplayer(6);  return;		/*	northwest	*/
			case 'Y':	run(6);			return;		/*	northwest	*/
			case 'n':	moveplayer(7);	return;		/*	southeast	*/
			case 'N':	run(7);			return;		/*	southeast	*/
			case 'b':	moveplayer(8);	return;		/*	southwest	*/
			case 'B':	run(8);			return;		/*	southwest	*/

			case '.':	if (yrepcount) viewflag=1; return;		/*	stay here		*/

			case 'w':	yrepcount=0;	wield();	return;		/*	wield a weapon */

			case 'W':	yrepcount=0;	wear();		return;	/*	wear armor	*/

			case 'r':	yrepcount=0;
						if (c[BLINDCOUNT]) { cursors(); lprcat("\nYou can't read anything when you're blind!"); } else
						if (c[TIMESTOP]==0) readscr(); return;		/*	to read a scroll	*/

			case 'q':	yrepcount=0;	if (c[TIMESTOP]==0) quaff();	return;	/*	quaff a potion		*/

			case 'd':	yrepcount=0;	if (c[TIMESTOP]==0) dropobj(); return;	/*	to drop an object	*/

			case 'c':	yrepcount=0;	cast();		return;		/*	cast a spell	*/

			case 'i':	yrepcount=0;	nomove=1;  showstr();	return;		/*	status		*/

			case 'e':	yrepcount=0;
						if (c[TIMESTOP]==0) eatcookie(); return;	/*	to eat a fortune cookie */

			case 'D':	yrepcount=0;	seemagic(0);	nomove=1; return;	/*	list spells and scrolls */

			case '?':	yrepcount=0;	help(); nomove=1; return;	/*	give the help screen*/

			case 'S':	clear();  lprcat("Saving . . ."); lflush();  
						savegame(savefilename); wizard=1; died(-257);	/*	save the game - doesn't return	*/

			case 'Z':	yrepcount=0;	if (c[LEVEL]>9) { oteleport(1); return; }
						cursors(); lprcat("\nAs yet, you don't have enough experience to use teleportation");
						return;	/*	teleport yourself	*/

			case '^':	/* identify traps */  flag=yrepcount=0;  cursors();
						lprc('\n');  for (j=playery-1; j<playery+2; j++)
							{
							if (j < 0) j=0;		if (j >= MAXY) break;
							for (i=playerx-1; i<playerx+2; i++)
								{
								if (i < 0) i=0;	if (i >= MAXX) break;
								switch(item[i][j])
									{
									case OTRAPDOOR:		case ODARTRAP:
									case OTRAPARROW:	case OTELEPORTER:
										lprcat("\nIts "); lprcat(objectname[item[i][j]]);  flag++;
									};
								}
							}
						if (flag==0) lprcat("\nNo traps are visible");
						return;
d841 64
a904 38
			case '_':	/*	this is the fudge player password for wizard mode*/
						yrepcount=0;	cursors(); nomove=1;
						if (userid!=wisid)
							{
							lprcat("Sorry, you are not empowered to be a wizard.\n");
							scbr(); /* system("stty -echo cbreak"); */
							lflush();  return;
							}
						if (getpassword()==0)
							{
							scbr(); /* system("stty -echo cbreak"); */ return;
							}
						wizard=1;  scbr(); /* system("stty -echo cbreak"); */
						for (i=0; i<6; i++)  c[i]=70;  iven[0]=iven[1]=0;
						take(OPROTRING,50);   take(OLANCE,25);  c[WIELD]=1;
						c[LANCEDEATH]=1;   c[WEAR] = c[SHIELD] = -1;
						raiseexperience(6000000L);  c[AWARENESS] += 25000;
						{
						register int i,j;
						for (i=0; i<MAXY; i++)
							for (j=0; j<MAXX; j++)  know[j][i]=1;
						for (i=0; i<SPNUM; i++)	spelknow[i]=1;
						for (i=0; i<MAXSCROLL; i++)  scrollname[i]=scrollhide[i];
						for (i=0; i<MAXPOTION; i++)  potionname[i]=potionhide[i];
						}
						for (i=0; i<MAXSCROLL; i++)
						  if (strlen(scrollname[i])>2) /* no null items */
							{ item[i][0]=OSCROLL; iarg[i][0]=i; }
						for (i=MAXX-1; i>MAXX-1-MAXPOTION; i--)
						  if (strlen(potionname[i-MAXX+MAXPOTION])>2) /* no null items */
							{ item[i][0]=OPOTION; iarg[i][0]=i-MAXX+MAXPOTION; }
						for (i=1; i<MAXY; i++)
							{ item[0][i]=i; iarg[0][i]=0; }
						for (i=MAXY; i<MAXY+MAXX; i++)
							{ item[i-MAXY][MAXY-1]=i; iarg[i-MAXY][MAXY-1]=0; }
						for (i=MAXX+MAXY; i<MAXX+MAXY+MAXY; i++)
							{ item[MAXX-1][i-MAXX-MAXY]=i; iarg[MAXX-1][i-MAXX-MAXY]=0; }
						c[GOLD]+=25000;	drawscreen();	return;
d907 14
a920 4
			case 'T':	yrepcount=0;	cursors();  if (c[SHIELD] != -1) { c[SHIELD] = -1; lprcat("\nYour shield is off"); bottomline(); } else
										if (c[WEAR] != -1) { c[WEAR] = -1; lprcat("\nYour armor is off"); bottomline(); }
						else lprcat("\nYou aren't wearing anything");
						return;
d922 7
a928 10
			case 'g':	cursors();
						lprintf("\nThe stuff you are carrying presently weighs %d pounds",(long)packweight());
			case ' ':	yrepcount=0;	nomove=1;  return;

			case 'v':	yrepcount=0;	cursors();
						lprintf("\nCaverns of Larn, Version %d.%d, Diff=%d",(long)VERSION,(long)SUBVERSION,(long)c[HARDGAME]);
						if (wizard) lprcat(" Wizard"); nomove=1;
						if (cheat) lprcat(" Cheater");
						lprcat(copyright);
						return;
d930 11
a940 1
			case 'Q':	yrepcount=0;	quit(); nomove=1;	return;	/*	quit		*/
d942 11
a952 1
			case 'L'-64:  yrepcount=0;	drawscreen();  nomove=1; return;	/*	look		*/
d956 8
a963 2
			case 'A':	yrepcount=0;	nomove=1; if (wizard) { diag(); return; }  /*	create diagnostic file */
						return;
d966 8
a973 8
			case 'P':	cursors(); 
						if (outstanding_taxes>0)
							lprintf("\nYou presently owe %d gp in taxes.",(long)outstanding_taxes);
						else
							lprcat("\nYou do not owe any taxes.");
						return;
			};
		}
d975 1
d977 1
d979 7
a985 4
	{
	if (c[HASTEMONST]) movemonst(); movemonst(); /*	move the monsters		*/
	randmonst();	regen();
	}
d987 1
d989 13
a1001 9
	int dir;
	{
	register int i;
	i=1; while (i)
		{
		i=moveplayer(dir);
		if (i>0) {  if (c[HASTEMONST]) movemonst();  movemonst(); randmonst(); regen(); }
		if (hitflag) i=0;
		if (i!=0)  showcell(playerx,playery);
d1003 4
d1008 1
d1013 31
a1043 14
wield()	
	{
	register int i;
	while (1)
		{
		if ((i = whatitem("wield"))=='\33')  return;
		if (i != '.')
			{
			if (i=='*') showwield();
			else  if (iven[i-'a']==0) { ydhi(i); return; }
			else if (iven[i-'a']==OPOTION) { ycwi(i); return; }
			else if (iven[i-'a']==OSCROLL) { ycwi(i); return; }
			else  if ((c[SHIELD]!= -1) && (iven[i-'a']==O2SWORD)) { lprcat("\nBut one arm is busy with your shield!"); return; }
			else  { c[WIELD]=i-'a'; if (iven[i-'a'] == OLANCE) c[LANCEDEATH]=1; else c[LANCEDEATH]=0;  bottomline(); return; }
d1047 1
d1050 1
a1050 1
	common routine to say you don't have an item
d1052 1
d1054 7
a1060 2
	int x;
	{ cursors();  lprintf("\nYou don't have item %c!",x); }
d1062 5
a1066 2
	int x;
	{ cursors();  lprintf("\nYou can't wield item %c!",x); }
d1069 1
a1069 1
	function to wear armor
d1071 1
d1073 43
a1115 19
	{
	register int i;
	while (1)
		{
		if ((i = whatitem("wear"))=='\33')  return;
		if (i != '.')
			{
			if (i=='*') showwear(); else
			switch(iven[i-'a'])
				{
				case 0:  ydhi(i); return;
				case OLEATHER:  case OCHAIN:  case OPLATE:	case OSTUDLEATHER:
				case ORING:		case OSPLINT:	case OPLATEARMOR:	case OSSPLATE:
						if (c[WEAR] != -1) { lprcat("\nYou're already wearing some armor"); return; }
							c[WEAR]=i-'a';  bottomline(); return;
				case OSHIELD:	if (c[SHIELD] != -1) { lprcat("\nYou are already wearing a shield"); return; }
								if (iven[c[WIELD]]==O2SWORD) { lprcat("\nYour hands are busy with the two handed sword!"); return; }
								c[SHIELD] = i-'a';  bottomline(); return;
				default:	lprcat("\nYou can't wear that!");
a1116 1
			}
d1119 1
d1122 1
a1122 1
	function to drop an object
d1124 1
d1126 5
a1130 4
	{
	register int i;
	register char *p;
	long amt;
d1132 11
a1142 8
	while (1)
		{
		if ((i = whatitem("drop"))=='\33')  return;
		if (i=='*') showstr(); else 
			{
			if (i=='.')	/* drop some gold */
				{
				if (*p) { lprcat("\nThere's something here already!"); return; }
d1144 1
a1144 1
				cl_dn(1,23);
d1146 25
a1170 17
				if ((amt=readnum((long)c[GOLD])) == 0) return;
				if (amt>c[GOLD])
					{ lprcat("\nYou don't have that much!"); return; }
				if (amt<=32767)
					{ *p=OGOLDPILE; i=amt; }
				else if (amt<=327670L)
					{ *p=ODGOLD; i=amt/10; amt = 10*i; }
				else if (amt<=3276700L)
					{ *p=OMAXGOLD; i=amt/100; amt = 100*i; }
				else if (amt<=32767000L)
					{ *p=OKGOLD; i=amt/1000; amt = 1000*i; }
				else
					{ *p=OKGOLD; i=32767; amt = 32767000L; }
				c[GOLD] -= amt; 
				lprintf("You drop %d gold pieces",(long)amt);
				iarg[playerx][playery]=i; bottomgold();
				know[playerx][playery]=0; dropflag=1;  return;
d1172 9
a1180 1
			drop_object(i-'a');
a1181 1
			}
d1184 1
d1189 1
d1191 23
a1213 13
	{
	register int i;
	while (1)
		{
		if ((i = whatitem("read"))=='\33')  return;
		if (i != '.')
			{
			if (i=='*') showread(); else
				{
				if (iven[i-'a']==OSCROLL) { read_scroll(ivenarg[i-'a']); iven[i-'a']=0; return; }
				if (iven[i-'a']==OBOOK)   { readbook(ivenarg[i-'a']);  iven[i-'a']=0; return; }
				if (iven[i-'a']==0) { ydhi(i); return; }
				lprcat("\nThere's nothing on it to read");  return;
d1215 2
d1220 1
d1225 1
d1228 17
a1244 18
register int i;
char *p;
while (1)
	{
	if ((i = whatitem("eat"))=='\33')  return;
	if (i != '.')
		if (i=='*') showeat(); else
			{
			if (iven[i-'a']==OCOOKIE)
				{
				lprcat("\nThe cookie was delicious.");
				iven[i-'a']=0;
				if (!c[BLINDCOUNT])
					{
					if (p=fortune())
						{
						lprcat("  Inside you find a scrap of paper that says:\n");
						lprcat(p);
d1247 7
a1254 3
				}
			if (iven[i-'a']==0) { ydhi(i); return; }
			lprcat("\nYou can't eat that!");  return;
d1256 1
d1263 1
d1265 18
a1282 12
	{
	register int i;
	while (1)
		{
		if ((i = whatitem("quaff"))=='\33')  return;
		if (i != '.')
			{
			if (i=='*') showquaff(); else
				{
				if (iven[i-'a']==OPOTION) { quaffpotion(ivenarg[i-'a']); iven[i-'a']=0; return; }
				if (iven[i-'a']==0) { ydhi(i); return; }
				lprcat("\nYou wouldn't want to quaff that, would you? ");  return;
d1284 2
d1289 1
d1292 1
a1292 1
	function to ask what player wants to do
d1294 1
d1296 13
a1308 8
	char *str;
	{
	int i;
	cursors();  lprintf("\nWhat do you want to %s [* for all] ? ",str);
	i=0; while (i>'z' || (i<'a' && i!='*' && i!='\33' && i!='.')) i=getchar();
	if (i=='\33')  lprcat(" aborted");
	return(i);
	}
d1311 10
a1320 8
	subroutine to get a number from the player
	and allow * to mean return amt, else return the number entered
 */
unsigned long readnum(mx)
	long mx;
	{
	register int i;
	register unsigned long amt=0;
d1322 2
a1323 1
	if ((i=getchar()) == '*')  amt = mx;   /* allow him to say * for all gold */
d1325 5
a1329 6
		while (i != '\n')
			{
			if (i=='\033') { scbr(); lprcat(" aborted"); return(0); }
			if ((i <= '9') && (i >= '0') && (amt<99999999))
				amt = amt*10+i-'0';
			i = getchar();
d1331 7
a1337 2
	scbr();  return(amt);
	}
d1343 1
d1345 2
a1346 2
	register char *str;
	{
d1349 2
a1350 2
	}
#endif HIDEBYLINK
@


1.6
log
@gtime var -> gltime var
@
text
@d24 1
a24 1
Cmd line format: larn [-slicnh] [-o<optsifle>] [-##] [++]\n\
@


1.5
log
@Safe $HOME handling.
@
text
@d276 1
a276 1
	lprintf("\nElapsed time is %d.  You have %d mobuls left",(long)((gtime+99)/100+1),(long)((TIMELIMIT-gtime)/100));
@


1.4
log
@prefer $LOGNAME to $USER.  Fix strncpy() usage.
@
text
@d8 1
d10 1
d81 14
a94 3
	strcpy(savefilename, ptr);
	strcat(savefilename, "/Larn.sav");	/* save file name in home directory */
	sprintf(optsfile, "%s/.larnopts",ptr);	/* the .larnopts filename */
@


1.3
log
@security fixes
@
text
@d65 2
a66 2
	  if ((ptr = getenv("USER")) == 0)
		if ((ptr = getenv("LOGNAME")) == 0)
d148 3
a150 1
						strncpy(optsfile,argv[i]+2,127);  break;
@


1.2
log
@fixed the "/* in comments" problem.
@
text
@d2 1
a2 1
static char rcsid[] = "$NetBSD: main.c,v 1.7 1995/04/24 12:24:01 cgd Exp $";
d16 1
d52 3
@


1.1
log
@Initial revision
@
text
@d211 1
a211 1
	/* nice(1);	/* games should be run niced */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
