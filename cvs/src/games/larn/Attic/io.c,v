head	1.10;
access;
symbols
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.6
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2003.03.11.09.29.28;	author deraadt;	state dead;
branches;
next	1.9;

1.9
date	2002.12.06.21.48.51;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.19.19.39.36;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.29.07.55.41;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	99.05.30.02.23.16;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	99.03.27.03.45.49;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	98.09.15.05.12.32;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	97.07.23.20.04.56;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.08.15.01.54.19;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.05;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.10
log
@OK, this is a strange case.  At least some parts of this software is
copyrighted, and then marked "Copying for Profit is Prohibited", but
the author has passed away.  A number of people have tried to make
some sort of effort at trying to contact his estate, and have failed.
Therefore, lacking the ability to correct this copyright, we must
delete it.  I would bet strongly that this is not what the author
would have intended, but until we can get this resolved, this is the
action we must take.
@
text
@/*	$OpenBSD: io.c,v 1.9 2002/12/06 21:48:51 millert Exp $	*/
/*	$NetBSD: io.c,v 1.7 1997/10/18 20:03:26 christos Exp $	*/

/*
 * io.c			 Larn is copyrighted 1986 by Noah Morgan.
 * 
 * Below are the functions in this file:
 * 
 * setupvt100()		Subroutine to set up terminal in correct mode for game
 * clearvt100()		Subroutine to clean up terminal when the game is over
 * lgetchar()		Routine to read in one character from the terminal
 * scbr()		Function to set cbreak -echo for the terminal
 * sncbr()		Function to set -cbreak echo for the terminal
 * newgame()		Subroutine to save the initial time and seed rnd()
 * 
 * FILE OUTPUT ROUTINES
 * 
 * lprintf(format,args . . .)	printf to the output buffer
 * lprint(integer)		end binary integer to output buffer
 * lwrite(buf,len)		write a buffer to the output buffer
 * lprcat(str)			sent string to output buffer
 * 
 * FILE OUTPUT MACROS (in header.h)
 * 
 * lprc(character)		put the character into the output buffer
 * 
 * FILE INPUT ROUTINES
 * 
 * long lgetc()			read one character from input buffer
 * long lrint()			read one integer from input buffer
 * lrfill(address,number)	put input bytes into a buffer char
 * *lgetw()			get a whitespace ended word from
 * input char *lgetl()		get a \n or EOF ended line
 * from input
 * 
 * FILE OPEN / CLOSE ROUTINES
 * 
 * lcreat(filename)		create a new file for write
 * lopen(filename)		open a file for read
 * lappend(filename)		open for append to an existing file
 * lrclose()			close the input file
 * lwclose()			close output file
 * lflush()			flush the output buffer
 * 
 * Other Routines
 * 
 * cursor(x,y)			position cursor at [x,y]
 * cursors()			position cursor at [1,24] (saves memory)
 * cl_line(x,y)			Clear line at [1,y] and leave cursor at [x,y]
 * cl_up(x,y)			Clear screen from [x,1] to current line
 * cl_dn(x,y)			clear screen from [1,y] to end of display
 * lstandout(str)		print the string in standout mode
 * set_score_output()		called when output should be literally printed
 * xputchar(ch)			print one character in decoded output buffer
 * flush_buf()			flush buffer with decoded output
 * init_term()			terminal initialization -- setup termcap info
 * char *tmcapcnv(sd,ss)	iroutine to convert VT100 \33's to termcap format
 * lbeep()	Routine to emit a beep if enabled (see no-beep in .larnopts)
 * 
 * Note: ** entries are available only in termcap mode.
 */

#ifndef lint
static char rcsid[] = "$OpenBSD: io.c,v 1.9 2002/12/06 21:48:51 millert Exp $";
#endif /* not lint */

#include "header.h"
#include "extern.h"
#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <term.h>
#include <fcntl.h>
#include <errno.h>

#ifdef TERMIO
#include <termio.h>
#define sgttyb termio
#define stty(_a,_b) ioctl(_a,TCSETA,_b)
#define gtty(_a,_b) ioctl(_a,TCGETA,_b)
#endif
#ifdef TERMIOS
#include <termios.h>
#define sgttyb termios
#define stty(_a,_b) tcsetattr(_a,TCSADRAIN,_b)
#define gtty(_a,_b) tcgetattr(_a,_b)
#endif

#if defined(TERMIO) || defined(TERMIOS)
static int	rawflg = 0;
static char	saveeof, saveeol;
#define doraw(_a) \
	if(!rawflg) { \
		++rawflg; \
		saveeof = _a.c_cc[VMIN]; \
		saveeol = _a.c_cc[VTIME]; \
	} \
	_a.c_cc[VMIN] = 1; \
	_a.c_cc[VTIME] = 1; \
	_a.c_lflag &= ~(ICANON|ECHO|ECHOE|ECHOK|ECHONL)
#define unraw(_a) \
	_a.c_cc[VMIN] = saveeof; \
	_a.c_cc[VTIME] = saveeol; \
	_a.c_lflag |= ICANON|ECHO|ECHOE|ECHOK|ECHONL

#else	/* not TERMIO or TERMIOS */

#ifndef BSD
#define CBREAK RAW		/* V7 has no CBREAK */
#endif

#define doraw(_a) (_a.sg_flags |= CBREAK,_a.sg_flags &= ~ECHO)
#define unraw(_a) (_a.sg_flags &= ~CBREAK,_a.sg_flags |= ECHO)
#include <sgtty.h>
#endif	/* not TERMIO or TERMIOS */

#ifndef NOVARARGS	/* if we have varargs */
#include <stdarg.h>
#else	/* NOVARARGS */	/* if we don't have varargs */
typedef char	*va_list;
#define va_dcl int va_alist;
#define va_start(plist) plist = (char *) &va_alist
#define va_end(plist)
#define va_arg(plist,mode) ((mode *)(plist += sizeof(mode)))[-1]
#endif	/* NOVARARGS */

#define LINBUFSIZE 128	/* size of the lgetw() and lgetl() buffer */
int	lfd;	/* output file numbers */
int	fd;	/* input file numbers */
static struct sgttyb ttx;/* storage for the tty modes */
static int	ipoint = MAXIBUF, iepoint = MAXIBUF;	/* input buffering
							 * pointers    */
static char	lgetwbuf[LINBUFSIZE];	/* get line (word) buffer */

/*
 *	setupvt100() Subroutine to set up terminal in correct mode for game
 *
 *	Attributes off, clear screen, set scrolling region, set tty mode
 */
void
setupvt100()
{
	clear();
	setscroll();
	scbr();			/* system("stty cbreak -echo"); */
}

/*
 *	clearvt100()	Subroutine to clean up terminal when the game is over
 *
 *	Attributes off, clear screen, unset scrolling region, restore tty mode
 */
void
clearvt100()
{
	resetscroll();
	clear();
	sncbr();		/* system("stty -cbreak echo"); */
}

/*
 *	lgetchar()	Routine to read in one character from the terminal
 */
int
lgetchar()
{
	char	byt;
#ifdef EXTRA
	c[BYTESIN]++;
#endif
	lflush();		/* be sure output buffer is flushed */
	read(0, &byt, 1);	/* get byte from terminal */
	return (byt);
}

/*
 *	scbr()		Function to set cbreak -echo for the terminal
 *
 *	like: system("stty cbreak -echo")
 */
void
scbr()
{
	gtty(0, &ttx);
	doraw(ttx);
	stty(0, &ttx);
}

/*
 *	sncbr()		Function to set -cbreak echo for the terminal
 *
 *	like: system("stty -cbreak echo")
 */
void
sncbr()
{
	gtty(0, &ttx);
	unraw(ttx);
	stty(0, &ttx);
}

/*
 *	newgame()	Subroutine to save the initial time and seed rnd()
 */
void
newgame()
{
	long	*p, *pe;

	for (p = c, pe = c + 100; p < pe; *p++ = 0);
	time(&initialtime);
	srandomdev();
	lcreat((char *) 0);	/* open buffering for output to terminal */
}

/*
 *	lprintf(format,args . . .)		printf to the output buffer
 *		char *format;
 *		??? args . . .
 *
 *	Enter with the format string in "format", as per printf() usage
 *		and any needed arguments following it
 *	Note: lprintf() only supports %s, %c and %d, with width modifier and left
 *		or right justification.
 *	No correct checking for output buffer overflow is done, but flushes
 *		are done beforehand if needed.
 *	Returns nothing of value.
 */
#ifdef lint
/* VARARGS */
lprintf(str)
	char	*str;
{
	char	*str2;
	str2 = str;
	str = str2;		/* to make lint happy */
}
/* VARARGS */
sprintf(str)
	char	*str;
{
	char	*str2;
	str2 = str;
	str = str2;		/* to make lint happy */
}
#else	/* lint */
/* VARARGS */
void lprintf(const char *fmt, ...)
{
	va_list	ap;	/* pointer for variable argument list */
	char	*outb, *tmpb;
	long	wide, left, cont, n;	/* data for lprintf	 */
	char	db[12];	/* %d buffer in lprintf	 */

	va_start(ap, fmt);
	if (lpnt >= lpend)
		lflush();
	outb = lpnt;
	for (;;) {
		while (*fmt != '%')
			if (*fmt)
				*outb++ = *fmt++;
			else {
				lpnt = outb;
				return;
			}
		wide = 0;
		left = 1;
		cont = 1;
		while (cont)
			switch (*(++fmt)) {
			case 'd':
				n = va_arg(ap, long);
				if (n < 0) {
					n = -n;
					*outb++ = '-';
					if (wide)
						--wide;
				}
				tmpb = db + 11;
				*tmpb = (char) (n % 10 + '0');
				while (n > 9)
					*(--tmpb) = (char) ((n /= 10) % 10 + '0');
				if (wide == 0)
					while (tmpb < db + 12)
						*outb++ = *tmpb++;
				else {
					wide -= db - tmpb + 12;
					if (left)
						while (wide-- > 0)
							*outb++ = ' ';
					while (tmpb < db + 12)
						*outb++ = *tmpb++;
					if (left == 0)
						while (wide-- > 0)
							*outb++ = ' ';
				}
				cont = 0;
				break;

			case 's':
				tmpb = va_arg(ap, char *);
				if (wide == 0) {
					while ((*outb++ = *tmpb++) != '\0')
						continue;
					--outb;
				} else {
					n = wide - strlen(tmpb);
					if (left)
						while (n-- > 0)
							*outb++ = ' ';
					while ((*outb++ = *tmpb++) != '\0')
						continue;
					--outb;
					if (left == 0)
						while (n-- > 0)
							*outb++ = ' ';
				}
				cont = 0;
				break;

			case 'c':
				*outb++ = va_arg(ap, int);
				cont = 0;
				break;

			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				wide = 10 * wide + *fmt - '0';
				break;

			case '-':
				left = 0;
				break;

			default:
				*outb++ = *fmt;
				cont = 0;
				break;
			};
		fmt++;
	}
	va_end(ap);
}
#endif	/* lint */

/*
 *	lprint(long-integer)	send binary integer to output buffer
 *		long integer;
 *
 *		+---------+---------+---------+---------+
 *		|   high  |	    |	      |	  low	|
 *		|  order  |	    |	      |  order	|
 *		|   byte  |	    |	      |	  byte	|
 *		+---------+---------+---------+---------+
 *	        31  ---  24 23 --- 16 15 ---  8 7  ---   0
 *
 *	The save order is low order first, to high order (4 bytes total)
 *	and is written to be system independent.
 *	No checking for output buffer overflow is done, but flushes if needed!
 *	Returns nothing of value.
 */
void
lprint(x)
	long	x;
{
	if (lpnt >= lpend)
		lflush();
	*lpnt++ = 255 & x;
	*lpnt++ = 255 & (x >> 8);
	*lpnt++ = 255 & (x >> 16);
	*lpnt++ = 255 & (x >> 24);
}

/*
 *	lwrite(buf,len)		write a buffer to the output buffer
 *		char *buf;
 *		int len;
 *
 *	Enter with the address and number of bytes to write out
 *	Returns nothing of value
 */
void
lwrite(buf, len)
	char	*buf;
	int	len;
{
	char	*str;
	int	num2;
	if (len > 399) {	/* don't copy data if can just write it */
#ifdef EXTRA
		c[BYTESOUT] += len;
#endif

		for (str = buf; len > 0; --len)
			lprc(*str++);
	} else
		while (len) {
			if (lpnt >= lpend)
				lflush();	/* if buffer is full flush it	 */
			num2 = lpbuf + BUFBIG - lpnt;	/* # bytes left in
							 * output buffer	 */
			if (num2 > len)
				num2 = len;
			str = lpnt;
			len -= num2;
			while (num2--)
				*str++ = *buf++;	/* copy in the bytes */
			lpnt = str;
		}
}

/*
 *	long lgetc()	Read one character from input buffer
 *
 *	Returns 0 if EOF, otherwise the character
 */
long 
lgetc()
{
	int	i;

	if (ipoint != iepoint)
		return (inbuffer[ipoint++]);
	if (iepoint != MAXIBUF)
		return (0);
	if ((i = read(fd, inbuffer, MAXIBUF)) <= 0) {
		if (i != 0)
			write(1, "error reading from input file\n", 30);
		iepoint = ipoint = 0;
		return (0);
	}
	ipoint = 1;
	iepoint = i;
	return (*inbuffer);
}

/*
 *	long lrint()	Read one integer from input buffer
 *
 *		+---------+---------+---------+---------+
 *		|   high  |	    |	      |	  low	|
 *		|  order  |	    |	      |  order	|
 *		|   byte  |	    |	      |	  byte	|
 *		+---------+---------+---------+---------+
 *	       31  ---  24 23 --- 16 15 ---  8 7  ---   0
 *
 *	The save order is low order first, to high order (4 bytes total)
 *	Returns the int read
 */
long 
lrint()
{
	unsigned long i;

	i = 255 & lgetc();
	i |= (255 & lgetc()) << 8;
	i |= (255 & lgetc()) << 16;
	i |= (255 & lgetc()) << 24;
	return (i);
}

/*
 *	lrfill(address,number)		put input bytes into a buffer
 *		char *address;
 *		int number;
 *
 *	Reads "number" bytes into the buffer pointed to by "address".
 *	Returns nothing of value
 */
void
lrfill(adr, num)
	char	*adr;
	int	num;
{
	char	*pnt;
	int	num2;

	while (num) {
		if (iepoint == ipoint) {
			if (num > 5) {	/* fast way */
				if (read(fd, adr, num) != num)
					write(2, "error reading from input file\n", 30);
				num = 0;
			} else {
				*adr++ = lgetc();
				--num;
			}
		} else {
			num2 = iepoint - ipoint;	/* # of bytes left in
							 * the buffer	 */
			if (num2 > num)
				num2 = num;
			pnt = inbuffer + ipoint;
			num -= num2;
			ipoint += num2;
			while (num2--)
				*adr++ = *pnt++;
		}
	}
}

/*
 *	char *lgetw()			Get a whitespace ended word from input
 *
 *	Returns pointer to a buffer that contains word.  If EOF, returns a NULL
 */
char *
lgetw()
{
	char	*lgp, cc;
	int	n = LINBUFSIZE, quote = 0;

	lgp = lgetwbuf;
	do
		cc = lgetc();
	while ((cc <= 32) && (cc > '\0'));	/* eat whitespace */
	for (;; --n, cc = lgetc()) {
		if ((cc == '\0') && (lgp == lgetwbuf))
			return (NULL);	/* EOF */
		if ((n <= 1) || ((cc <= 32) && (quote == 0))) {
			*lgp = '\0';
			return (lgetwbuf);
		}
		if (cc != '"')
			*lgp++ = cc;
		else
			quote ^= 1;
	}
}

/*
 *	char *lgetl()	Function to read in a line ended by newline or EOF
 *
 * Returns pointer to a buffer that contains the line.  If EOF, returns NULL
 */
char *
lgetl()
{
	int	i = LINBUFSIZE, ch;
	char	*str = lgetwbuf;

	for (;; --i) {
		if ((*str++ = ch = lgetc()) == '\0') {
			if (str == lgetwbuf + 1)
				return (NULL);	/* EOF */
	ot:		*str = '\0';
			return (lgetwbuf);	/* line ended by EOF */
		}
		if ((ch == '\n') || (i <= 1))
			goto ot;/* line ended by \n */
	}
}

/*
 *	lcreat(filename)			Create a new file for write
 *		char *filename;
 *
 *	lcreat((char*)0); means to the terminal
 *	Returns -1 if error, otherwise the file descriptor opened.
 */
int
lcreat(str)
	char *str;
{
	lpnt = lpbuf;
	lpend = lpbuf + BUFBIG;
	if (str == NULL)
		return (lfd = 1);
	if ((lfd = creat(str, 0644)) < 0) {
		lfd = 1;
		lprintf("error creating file <%s>: %s\n", str,
			strerror(errno));
		lflush();
		return (-1);
	}
	return (lfd);
}

/*
 *	lopen(filename)			Open a file for read
 *		char *filename;
 *
 *	lopen(0) means from the terminal
 *	Returns -1 if error, otherwise the file descriptor opened.
 */
int
lopen(str)
	char	*str;
{
	ipoint = iepoint = MAXIBUF;
	if (str == NULL)
		return (fd = 0);
	if ((fd = open(str, O_RDONLY, 0)) < 0) {
		lwclose();
		lfd = 1;
		lpnt = lpbuf;
		return (-1);
	}
	return (fd);
}

/*
 *	lappend(filename)		Open for append to an existing file
 *		char *filename;
 *
 *	lappend(0) means to the terminal
 *	Returns -1 if error, otherwise the file descriptor opened.
 */
int
lappend(str)
	char	*str;
{
	lpnt = lpbuf;
	lpend = lpbuf + BUFBIG;
	if (str == NULL)
		return (lfd = 1);
	if ((lfd = open(str, O_RDWR, 0)) < 0) {
		lfd = 1;
		return (-1);
	}
	lseek(lfd, 0, SEEK_END);
	return (lfd);
}

/*
 *	lrclose() close the input file
 *
 *	Returns nothing of value.
 */
void
lrclose()
{
	if (fd > 0)
		close(fd);
}

/*
 *	lwclose() close output file flushing if needed
 *
 *	Returns nothing of value.
 */
void
lwclose()
{
	lflush();
	if (lfd > 2)
		close(lfd);
}

/*
 *	lprcat(string)	append a string to the output buffer
 *			avoids calls to lprintf (time consuming)
 */
void
lprcat(str)
	char	*str;
{
	char	*str2;

	if (lpnt >= lpend)
		lflush();
	str2 = lpnt;
	while ((*str2++ = *str++) != '\0')
		continue;
	lpnt = str2 - 1;
}

/*
 * cursor(x,y)	  Put cursor at specified coordinates staring at [1,1] (termcap)
 */
void
cursor(x, y)
	int	x, y;
{
	if (lpnt >= lpend)
		lflush();

	*lpnt++ = CURSOR;
	*lpnt++ = x;
	*lpnt++ = y;
}

/*
 *	Routine to position cursor at beginning of 24th line
 */
void
cursors()
{
	cursor(1, 24);
}

/*
 * Warning: ringing the bell is control code 7. Don't use in defines.
 * Don't change the order of these defines.
 * Also used in helpfiles. Codes used in helpfiles should be \E[1 to \E[7 with
 * obvious meanings.
 */

static char	cap[256];
char		*CM, *CE, *CD, *CL, *SO, *SE, *AL, *DL;	/* Termcap capabilities */
static char	*outbuf = 0;	/* translated output buffer */

/*
 * init_term()		Terminal initialization -- setup termcap info
 */
void
init_term()
{
	char	termbuf[1024];
	char	*capptr = cap + 10;
	char	*term;
	int	co, li;

	switch (tgetent(termbuf, term = getenv("TERM"))) {
	case -1:
		write(2, "Cannot open termcap file.\n", 26);
		exit(1);
	case 0:
		write(2, "Cannot find entry of ", 21);
		write(2, term, strlen(term));
		write(2, " in termcap\n", 12);
		exit(1);
	};

	CM = tgetstr("cm", &capptr);	/* Cursor motion */
	CE = tgetstr("ce", &capptr);	/* Clear to eoln */
	CL = tgetstr("cl", &capptr);	/* Clear screen */

	/* OPTIONAL */
	AL = tgetstr("al", &capptr);	/* Insert line */
	DL = tgetstr("dl", &capptr);	/* Delete line */
	SO = tgetstr("so", &capptr);	/* Begin standout mode */
	SE = tgetstr("se", &capptr);	/* End standout mode */
	CD = tgetstr("cd", &capptr);	/* Clear to end of display */
	co = tgetnum("co");	/* columns */
	li = tgetnum("li");	/* lines */

	if (!CM) {		/* can't find cursor motion entry */
		write(2, "Sorry, for a ", 13);
		write(2, term, strlen(term));
		write(2, ", I can't find the cursor motion entry in termcap\n", 50);
		exit(1);
	}
	if (!CE) {		/* can't find clear to end of line entry */
		write(2, "Sorry, for a ", 13);
		write(2, term, strlen(term));
		write(2, ", I can't find the clear to end of line entry in termcap\n", 57);
		exit(1);
	}
	if (!CL) {		/* can't find clear entire screen entry */
		write(2, "Sorry, for a ", 13);
		write(2, term, strlen(term));
		write(2, ", I can't find the clear entire screen entry in termcap\n", 56);
		exit(1);
	}
	if (co < 80 || li < 25) {
		write(2, "Sorry, screen too small (80x25 min)\n", 36);
		exit(1);
	}
	if ((outbuf = malloc(BUFBIG + 16)) == 0) {	/* get memory for
							 * decoded output buffer */
		write(2, "Error malloc'ing memory for decoded output buffer\n", 50);
		died(-285);	/* malloc() failure */
	}
}

/*
 * cl_line(x,y)  Clear the whole line indicated by 'y' and leave cursor at [x,y]
 */
void
cl_line(x, y)
	int	x, y;
{
	cursor(1, y);
	*lpnt++ = CL_LINE;
	cursor(x, y);
}

/*
 * cl_up(x,y) Clear screen from [x,1] to current position. Leave cursor at [x,y]
 */
void
cl_up(x, y)
	int	x, y;
{
	int	i;
	cursor(1, 1);
	for (i = 1; i <= y; i++) {
		*lpnt++ = CL_LINE;
		*lpnt++ = '\n';
	}
	cursor(x, y);
}

/*
 * cl_dn(x,y)	Clear screen from [1,y] to end of display. Leave cursor at [x,y]
 */
void
cl_dn(x, y)
	int	x, y;
{
	int	i;
	cursor(1, y);
	if (!CD) {
		*lpnt++ = CL_LINE;
		for (i = y; i <= 24; i++) {
			*lpnt++ = CL_LINE;
			if (i != 24)
				*lpnt++ = '\n';
		}
		cursor(x, y);
	} else
		*lpnt++ = CL_DOWN;
	cursor(x, y);
}

/*
 * lstandout(str)	Print the argument string in inverse video (standout mode).
 */
void
lstandout(str)
	char	*str;
{
	*lpnt++ = ST_START;
	while (*str)
		*lpnt++ = *str++;
	*lpnt++ = ST_END;
}

/*
 * set_score_output()	Called when output should be literally printed.
 */
void
set_score_output()
{
	enable_scroll = -1;
}

/*
 *	lflush()	Flush the output buffer
 *
 *	Returns nothing of value.
 *	for termcap version: Flush output in output buffer according to output
 *	status as indicated by `enable_scroll'
 */
static int	scrline = 18;	/* line # for wraparound instead of scrolling
				 * if no DL */
void
lflush()
{
	int	lpoint;
	u_char	*str;
	static int	curx = 0;
	static int	cury = 0;

	if ((lpoint = lpnt - lpbuf) > 0) {
#ifdef EXTRA
		c[BYTESOUT] += lpoint;
#endif
		if (enable_scroll <= -1) {
			flush_buf();
			if (write(lfd, lpbuf, lpoint) != lpoint)
				write(2, "error writing to output file\n", 29);
			lpnt = lpbuf;	/* point back to beginning of buffer */
			return;
		}
		for (str = lpbuf; str < lpnt; str++) {
			if (*str >= 32) {
				xputchar(*str);
				curx++;
			} else
				switch (*str) {
				case CLEAR:
					tputs(CL, 0, xputchar);
					curx = cury = 0;
					break;

				case CL_LINE:
					tputs(CE, 0, xputchar);
					break;

				case CL_DOWN:
					tputs(CD, 0, xputchar);
					break;

				case ST_START:
					tputs(SO, 0, xputchar);
					break;

				case ST_END:
					tputs(SE, 0, xputchar);
					break;

				case CURSOR:
					curx = *++str - 1;
					cury = *++str - 1;
					tputs(tgoto(CM, curx, cury), 0, xputchar);
					break;

				case '\n':
					if ((cury == 23) && enable_scroll) {
						if (!DL || !AL) {	/* wraparound or scroll? */
							if (++scrline > 23)
								scrline = 19;

							if (++scrline > 23)
								scrline = 19;
							tputs(tgoto(CM, 0, scrline), 0, xputchar);
							tputs(CE, 0, xputchar);

							if (--scrline < 19)
								scrline = 23;
							tputs(tgoto(CM, 0, scrline), 0, xputchar);
							tputs(CE, 0, xputchar);
						} else {
							tputs(tgoto(CM, 0, 19), 0, xputchar);
							tputs(DL, 0, xputchar);
							tputs(tgoto(CM, 0, 23), 0, xputchar);
							/*
							 * tputs (AL, 0,
							 * xputchar);
							 */
						}
					} else {
						xputchar('\n');
						cury++;
					}
					curx = 0;
					break;

				default:
					xputchar(*str);
					curx++;
				};
		}
	}
	lpnt = lpbuf;
	flush_buf();		/* flush real output buffer now */
}

static int	vindex = 0;
/*
 * xputchar(ch)		Print one character in decoded output buffer.
 */
int 
xputchar(c)
	int	c;
{
	outbuf[vindex++] = c;
	if (vindex >= BUFBIG)
		flush_buf();
	return 0;
}

/*
 * flush_buf()			Flush buffer with decoded output.
 */
void
flush_buf()
{
	if (vindex)
		write(lfd, outbuf, vindex);
	vindex = 0;
}

/*
 *	char *tmcapcnv(sd,ss)  Routine to convert VT100 escapes to termcap
 *	format
 *	Processes only the \33[#m sequence (converts . files for termcap use
 */
char *
tmcapcnv(sd, ss)
	char	*sd, *ss;
{
	int	tmstate = 0;	/* 0=normal, 1=\33 2=[ 3=# */
	char	tmdigit = 0;	/* the # in \33[#m */

	while (*ss) {
		switch (tmstate) {
		case 0:
			if (*ss == '\33') {
				tmstate++;
				break;
			}
	ign:		*sd++ = *ss;
	ign2:		tmstate = 0;
			break;
		case 1:
			if (*ss != '[')
				goto ign;
			tmstate++;
			break;
		case 2:
			if (isdigit((u_char)*ss)) {
				tmdigit = *ss - '0';
				tmstate++;
				break;
			}
			if (*ss == 'm') {
				*sd++ = ST_END;
				goto ign2;
			}
			goto ign;
		case 3:
			if (*ss == 'm') {
				if (tmdigit)
					*sd++ = ST_START;
				else
					*sd++ = ST_END;
				goto ign2;
			}
		default:
			goto ign;
		};
		ss++;
	}
	*sd = 0;		/* NULL terminator */
	return (sd);
}

/*
 *	lbeep()	Routine to emit a beep if enabled (see no-beep in .larnopts)
 */
void
lbeep()
{
	if (!nobeep)
		*lpnt++ = '\7';
}
@


1.9
log
@Replace things like srandom(time(NULL)) with srandomdev(3).  random(3)
good enough for games but we should at least use a decent seed.
pjanzen@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.8 2002/02/19 19:39:36 millert Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: io.c,v 1.8 2002/02/19 19:39:36 millert Exp $";
@


1.8
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.7 2000/06/29 07:55:41 pjanzen Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: io.c,v 1.7 2000/06/29 07:55:41 pjanzen Exp $";
d213 1
a213 1
	srandom(initialtime);
@


1.7
log
@Prune some obsolete defines, in particular VT100.  Eventually curses will
  replace termios.
Use system-defined limits for path lengths and usernames.
Use strlcpy() for convenience and to avoid a possible buffer overflow or two.
Various small tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.6 1999/05/30 02:23:16 pjanzen Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: io.c,v 1.6 1999/05/30 02:23:16 pjanzen Exp $";
a118 1
#ifdef __STDC__
a119 3
#else
#include <varargs.h>
#endif
a248 1
#ifdef __STDC__
a249 5
#else
void
lprintf(va_alist)
va_dcl
#endif
a254 2
#ifndef __STDC__
	char	*fmt;
a255 3
	va_start(ap);		/* initialize the var args pointer */
	fmt = va_arg(ap, char *);	/* pointer to format string */
#else
a256 1
#endif
@


1.6
log
@use standard isalpha() and isdigit(); check that screen is big enough;
correct a typo, and fix up some man page paths.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.5 1999/03/27 03:45:49 pjanzen Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: io.c,v 1.5 1999/03/27 03:45:49 pjanzen Exp $";
a419 1
#ifndef VT100
a421 4
#else	/* VT100 */
		lflush();
		write(lfd, buf, len);
#endif	/* VT100 */
d619 1
a619 1
	if ((fd = open(str, 0)) < 0) {
d643 1
a643 1
	if ((lfd = open(str, 2)) < 0) {
d647 1
a647 1
	lseek(lfd, 0, 2);	/* seek to end of file */
a693 42
#ifdef VT100
/*
 *	cursor(x,y)		Subroutine to set the cursor position
 *
 *	x and y are the cursor coordinates, and lpbuff is the output buffer where
 *	escape sequence will be placed.
 */
static char	*y_num[] = {
"\33[", "\33[", "\33[2", "\33[3", "\33[4", "\33[5", "\33[6",
"\33[7", "\33[8", "\33[9", "\33[10", "\33[11", "\33[12", "\33[13", "\33[14",
"\33[15", "\33[16", "\33[17", "\33[18", "\33[19", "\33[20", "\33[21", "\33[22",
"\33[23", "\33[24"};

static char	*x_num[] = {
"H", "H", ";2H", ";3H", ";4H", ";5H", ";6H", ";7H", ";8H", ";9H",
";10H", ";11H", ";12H", ";13H", ";14H", ";15H", ";16H", ";17H", ";18H", ";19H",
";20H", ";21H", ";22H", ";23H", ";24H", ";25H", ";26H", ";27H", ";28H", ";29H",
";30H", ";31H", ";32H", ";33H", ";34H", ";35H", ";36H", ";37H", ";38H", ";39H",
";40H", ";41H", ";42H", ";43H", ";44H", ";45H", ";46H", ";47H", ";48H", ";49H",
";50H", ";51H", ";52H", ";53H", ";54H", ";55H", ";56H", ";57H", ";58H", ";59H",
";60H", ";61H", ";62H", ";63H", ";64H", ";65H", ";66H", ";67H", ";68H", ";69H",
";70H", ";71H", ";72H", ";73H", ";74H", ";75H", ";76H", ";77H", ";78H", ";79H",
";80H"};

void
cursor(x, y)
	int	x, y;
{
	char	*p;

	if (lpnt >= lpend)
		lflush();

	p = y_num[y];		/* get the string to print */
	while (*p)
		*lpnt++ = *p++;	/* print the string */

	p = x_num[x];		/* get the string to print */
	while (*p)
		*lpnt++ = *p++;	/* print the string */
}
#else	/* VT100 */
a707 1
#endif	/* VT100 */
a717 1
#ifndef VT100
a791 1
#endif	/* VT100 */
a799 4
#ifdef VT100
	cursor(x, y);
	lprcat("\33[2K");
#else	/* VT100 */
a802 1
#endif	/* VT100 */
a811 4
#ifdef VT100
	cursor(x, y);
	lprcat("\33[1J\33[2K");
#else	/* VT100 */
a818 1
#endif	/* VT100 */
a827 4
#ifdef VT100
	cursor(x, y);
	lprcat("\33[J\33[2K");
#else	/* VT100 */
a840 1
#endif	/* VT100 */
a849 6
#ifdef VT100
	setbold();
	while (*str)
		*lpnt++ = *str++;
	resetbold();
#else	/* VT100 */
a853 1
#endif	/* VT100 */
a871 1
#ifndef VT100
a965 21
#else	/* VT100 */
/*
 *	lflush()		flush the output buffer
 *
 *	Returns nothing of value.
 */
void
lflush()
{
	int	lpoint;

	if ((lpoint = lpnt - lpbuf) > 0) {
#ifdef EXTRA
		c[BYTESOUT] += lpoint;
#endif
		if (write(lfd, lpbuf, lpoint) != lpoint)
			write(2, "error writing to output file\n", 29);
	}
	lpnt = lpbuf;		/* point back to beginning of buffer */
}
#endif	/* VT100 */
a966 1
#ifndef VT100
a1045 1
#endif	/* VT100 */
@


1.5
log
@Changes from FreeBSD:  install score files, use random(), and be more careful
on exec.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.4 1998/09/15 05:12:32 pjanzen Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: io.c,v 1.4 1998/09/15 05:12:32 pjanzen Exp $";
d69 1
d787 1
d810 2
d829 4
@


1.4
log
@NetBSD merge; also renamed some functions so as not to conflict with curses
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD$";
d216 1
a216 1
	srand(initialtime);
@


1.3
log
@tabify
@
text
@d1 2
a2 3
#ifndef lint
static char rcsid[] = "$NetBSD: io.c,v 1.4 1995/04/24 12:23:57 cgd Exp $";
#endif /* not lint */
d4 56
a59 54
/* io.c			 Larn is copyrighted 1986 by Noah Morgan.
 *
 *	Below are the functions in this file:
 *
 *	setupvt100() 	Subroutine to set up terminal in correct mode for game
 *	clearvt100()  	Subroutine to clean up terminal when the game is over
 *	getchar() 		Routine to read in one character from the terminal
 *	scbr()			Function to set cbreak -echo for the terminal
 *	sncbr()			Function to set -cbreak echo for the terminal
 *	newgame() 		Subroutine to save the initial time and seed rnd()
 *
 *	FILE OUTPUT ROUTINES
 *
 *	lprintf(format,args . . .)	printf to the output buffer
 *	lprint(integer)				send binary integer to output buffer
 *	lwrite(buf,len)				write a buffer to the output buffer
 *	lprcat(str)					sent string to output buffer
 *
 *	FILE OUTPUT MACROS (in header.h)
 *
 *	lprc(character)				put the character into the output buffer
 *
 *	FILE INPUT ROUTINES
 *
 *	long lgetc()				read one character from input buffer
 *	long lrint()				read one integer from input buffer
 *	lrfill(address,number)		put input bytes into a buffer
 *	char *lgetw()				get a whitespace ended word from input
 *	char *lgetl()				get a \n or EOF ended line from input
 *
 *	FILE OPEN / CLOSE ROUTINES
 *
 *	lcreat(filename)			create a new file for write
 *	lopen(filename)				open a file for read
 *	lappend(filename)			open for append to an existing file
 *	lrclose()					close the input file
 *	lwclose()					close output file
 *	lflush()					flush the output buffer
 *
 *	Other Routines
 *
 *	cursor(x,y)					position cursor at [x,y]
 *	cursors()					position cursor at [1,24] (saves memory)
 *  cl_line(x,y)			Clear line at [1,y] and leave cursor at [x,y]
 *  cl_up(x,y)    				Clear screen from [x,1] to current line.
 *  cl_dn(x,y) 					Clear screen from [1,y] to end of display. 
 *  standout(str)	 			Print the string in standout mode.
 *  set_score_output() 			Called when output should be literally printed.
 ** putchar(ch)					Print one character in decoded output buffer.
 ** flush_buf()					Flush buffer with decoded output.
 ** init_term()					Terminal initialization -- setup termcap info
 **	char *tmcapcnv(sd,ss)  		Routine to convert VT100 \33's to termcap format
 *	beep()		Routine to emit a beep if enabled (see no-beep in .larnopts)
 *
d63 4
d68 1
d70 5
d76 1
a76 1
#ifdef SYSV	/* system III or system V */
d81 7
a87 5
static int rawflg = 0;
static char saveeof,saveeol;
#define doraw(_a) if(!rawflg){++rawflg;saveeof=_a.c_cc[VMIN];saveeol=_a.c_cc[VTIME];}\
    _a.c_cc[VMIN]=1;_a.c_cc[VTIME]=1;_a.c_lflag &= ~(ICANON|ECHO|ECHOE|ECHOK|ECHONL)
#define unraw(_a) _a.c_cc[VMIN]=saveeof;_a.c_cc[VTIME]=saveeol;_a.c_lflag |= ICANON|ECHO|ECHOE|ECHOK|ECHONL
d89 18
a106 1
#else not SYSV
d115 1
a115 1
#endif not SYSV
d118 3
d122 3
a124 2
#else NOVARARGS	/* if we don't have varargs */
typedef char *va_list;
d129 1
a129 1
#endif NOVARARGS
d131 7
a137 6
#define LINBUFSIZE 128		/* size of the lgetw() and lgetl() buffer		*/
int lfd;					/*  output file numbers							*/
int fd;						/*  input file numbers							*/
static struct sgttyb ttx;	/* storage for the tty modes					*/
static int ipoint=MAXIBUF,iepoint=MAXIBUF;	/*  input buffering pointers    */
static char lgetwbuf[LINBUFSIZE];	/* get line (word) buffer				*/
d140 1
a140 1
 *	setupvt100() 		Subroutine to set up terminal in correct mode for game
d142 1
a142 1
 *	Attributes off, clear screen, set scrolling region, set tty mode 
d144 1
d146 5
a150 3
	{
	clear();  setscroll();  scbr(); /* system("stty cbreak -echo"); */
	}
d153 1
a153 1
 *	clearvt100() 	 	Subroutine to clean up terminal when the game is over
d155 1
a155 1
 *	Attributes off, clear screen, unset scrolling region, restore tty mode 
d157 1
d159 5
a163 3
	{
	resetscroll();  clear();  sncbr(); /* system("stty -cbreak echo"); */
	}
d166 6
a171 5
 *	getchar() 		Routine to read in one character from the terminal
 */
getchar()
	{
	char byt;
d176 3
a178 3
	read(0,&byt,1); 	/* get byte from terminal */
	return(byt);
	}
d185 1
d187 5
a191 3
	{
	gtty(0,&ttx);		doraw(ttx);		stty(0,&ttx);
	}
d198 1
d200 5
a204 3
	{
	gtty(0,&ttx);		unraw(ttx);		stty(0,&ttx);
	}
d207 1
a207 1
 *	newgame() 		Subroutine to save the initial time and seed rnd()
d209 1
d211 8
a218 6
	{
	register long *p,*pe;
	for (p=c,pe=c+100; p<pe; *p++ =0);
	time(&initialtime);		srand(initialtime);
	lcreat((char*)0);	/* open buffering for output to terminal */
	}
d229 1
a229 1
 *	No correct checking for output buffer overflow is done, but flushes 
d234 1
a234 1
/*VARARGS*/
d236 3
a238 3
	char *str;
	{
	char *str2;
d240 3
a242 3
	str = str2; /* to make lint happy */
	}
/*VARARGS*/
d244 3
a246 3
	char *str;
	{
	char *str2;
d248 8
a255 4
	str = str2; /* to make lint happy */
	}
#else lint
/*VARARGS*/
d258 8
a265 6
    {
	va_list ap;	/* pointer for variable argument list */
	register char *fmt;
	register char *outb,*tmpb;
	register long wide,left,cont,n;		/* data for lprintf	*/
	char db[12];			/* %d buffer in lprintf	*/
d267 1
a267 1
	va_start(ap);	/* initialize the var args pointer */
d269 5
a273 1
	if (lpnt >= lpend) lflush(); 
d275 1
a275 2
	for ( ; ; )
		{
d277 9
a285 2
			if (*fmt) *outb++ = *fmt++;  else { lpnt=outb;  return; }
		wide = 0;	left = 1;	cont=1;
d287 29
a315 26
		  switch(*(++fmt))
			{
			case 'd':	n = va_arg(ap, long);
						if (n<0) { n = -n;  *outb++ = '-';  if (wide) --wide; }
						tmpb = db+11;	*tmpb = (char)(n % 10 + '0');
						while (n>9)  *(--tmpb) = (char)((n /= 10) % 10 + '0');
						if (wide==0)  while (tmpb < db+12) *outb++ = *tmpb++;
						else
							{
							wide -= db-tmpb+12;
							if (left)  while (wide-- > 0) *outb++ = ' ';
							while (tmpb < db+12) *outb++ = *tmpb++;
							if (left==0)  while (wide-- > 0) *outb++ = ' ';
							}
						cont=0;	break;

			case 's':	tmpb = va_arg(ap, char *);
						if (wide==0)  { while (*outb++ = *tmpb++);  --outb; } 
						else
							{
							n = wide - strlen(tmpb);
							if (left)  while (n-- > 0) *outb++ = ' ';
							while (*outb++ = *tmpb++);  --outb;
							if (left==0)  while (n-- > 0) *outb++ = ' ';
							}
						cont=0;	break;
d317 25
a341 1
			case 'c':	*outb++ = va_arg(ap, int);	cont=0;  break;
d352 12
a363 5
			case '9':	wide = 10*wide + *fmt - '0';	break;

			case '-':	left = 0;	break;

			default:	*outb++ = *fmt;  cont=0;	break;
d366 1
a366 1
		}
d368 2
a369 2
	}
#endif lint
d372 1
a372 1
 *	lprint(long-integer)				send binary integer to output buffer
d376 3
a378 3
 *		|	high  |			|		  |	  low	|
 *		|  order  |			|		  |  order	|
 *		|   byte  |			|		  |	  byte	|
d380 1
a380 1
 *	   31  ---  24 23 --- 16 15 ---  8 7  ---   0
d383 1
a383 1
 *		and is written to be system independent.
d387 1
d389 9
a397 6
	register long x;
	{
	if (lpnt >= lpend) lflush();
	*lpnt++ =  255 & x;			*lpnt++ =  255 & (x>>8);
	*lpnt++ =  255 & (x>>16);	*lpnt++ =  255 & (x>>24);
	}
d400 1
a400 1
 *	lwrite(buf,len)					write a buffer to the output buffer
d403 1
a403 1
 *	
d407 8
a414 8
lwrite(buf,len)
    register char *buf;
    int len;
    {
	register char *str;
	register int num2;
	if (len > 399)  /* don't copy data if can just write it */
		{
d420 1
a420 1
		for (str=buf;  len>0; --len)
d422 1
a422 1
#else VT100
d424 15
a438 11
		write(lfd,buf,len);
#endif VT100
		} 
	else while (len)
		{
		if (lpnt >= lpend) lflush();	/* if buffer is full flush it	*/
		num2 = lpbuf+BUFBIG-lpnt;	/*	# bytes left in output buffer	*/
		if (num2 > len) num2=len;
		str = lpnt;  len -= num2;
		while (num2--)  *str++ = *buf++;	/* copy in the bytes */
		lpnt = str;
d440 1
a440 1
    }
d443 1
a443 1
 *	long lgetc()				Read one character from input buffer
d445 1
a445 1
 *  Returns 0 if EOF, otherwise the character
d447 14
a460 9
long lgetc()
    {
    register int i;
    if (ipoint != iepoint)  return(inbuffer[ipoint++]);
    if (iepoint!=MAXIBUF)   return(0);
    if ((i=read(fd,inbuffer,MAXIBUF))<=0)
	{
	if (i!=0)  write(1,"error reading from input file\n",30);
		iepoint = ipoint = 0;		return(0);
d462 4
a465 2
    ipoint=1;  iepoint=i;  return(*inbuffer);
    }
d468 1
a468 1
 *	long lrint()			Read one integer from input buffer
d471 3
a473 3
 *		|	high  |			|		  |	  low	|
 *		|  order  |			|		  |  order	|
 *		|   byte  |			|		  |	  byte	|
d475 1
a475 1
 *	   31  ---  24 23 --- 16 15 ---  8 7  ---   0
d480 11
a490 7
long lrint()
	{
	register unsigned long i;
	i  = 255 & lgetc();				i |= (255 & lgetc()) << 8;
	i |= (255 & lgetc()) << 16;		i |= (255 & lgetc()) << 24;
	return(i);
	}
d493 1
a493 1
 *	lrfill(address,number)			put input bytes into a buffer
d500 17
a516 24
lrfill(adr,num)
	register char *adr;
	int num;
	{
	register char *pnt;
	register int num2;
	while (num)
		{
		if (iepoint == ipoint)
			{
			if (num>5) /* fast way */
				{
				if (read(fd,adr,num) != num)
					write(2,"error reading from input file\n",30);
				num=0;
				}
			else { *adr++ = lgetc();  --num; }
			}
		else
			{
			num2 = iepoint-ipoint;	/*	# of bytes left in the buffer	*/
			if (num2 > num) num2=num;
			pnt = inbuffer+ipoint;	num -= num2;  ipoint += num2;
			while (num2--)  *adr++ = *pnt++;
d518 10
d530 1
d537 6
a542 4
char *lgetw()
	{
	register char *lgp,cc;
	register int n=LINBUFSIZE,quote=0;
d544 9
a552 6
	do cc=lgetc();  while ((cc <= 32) && (cc > NULL));  /* eat whitespace */
	for ( ; ; --n,cc=lgetc())
		{
		if ((cc==NULL) && (lgp==lgetwbuf))  return(NULL);	/* EOF */
		if ((n<=1) || ((cc<=32) && (quote==0))) { *lgp=NULL; return(lgetwbuf); }
		if (cc != '"') *lgp++ = cc;   else quote ^= 1;
d554 4
d559 1
d562 1
a562 1
 *	char *lgetl()		Function to read in a line ended by newline or EOF
d564 1
a564 1
 *	Returns pointer to a buffer that contains the line.  If EOF, returns NULL
d566 12
a577 12
char *lgetl()
	{
	register int i=LINBUFSIZE,ch;
	register char *str=lgetwbuf;
	for ( ; ; --i)
		{
		if ((*str++ = ch = lgetc()) == NULL)
			{
			if (str == lgetwbuf+1)  return(NULL); /* EOF */
		ot:	*str = NULL;	return(lgetwbuf);	/* line ended by EOF */
			}
		if ((ch=='\n') || (i<=1))  goto ot; /* line ended by \n */
d579 2
d582 1
d591 1
d594 11
a604 10
	{
	extern int errno;
	lpnt = lpbuf;	lpend = lpbuf+BUFBIG;
	if (str==NULL) return(lfd=1);
	if ((lfd=creat(str,0644)) < 0) 
		{
		lfd=1; lprintf("error (%s) creating file <%s>\n",
			       strerror(errno), str); lflush(); return(-1);
		}
	return(lfd);
d606 2
d616 1
d618 2
a619 2
	char *str;
	{
d621 7
a627 6
	if (str==NULL) return(fd=0);
	if ((fd=open(str,0)) < 0)
		{
		lwclose(); lfd=1; lpnt=lpbuf; return(-1);
		}
	return(fd);
d629 2
d639 1
d641 13
a653 11
	char *str;
	{
	lpnt = lpbuf;	lpend = lpbuf+BUFBIG;
	if (str==NULL) return(lfd=1);
	if ((lfd=open(str,2)) < 0)
		{
		lfd=1; return(-1);
		}
	lseek(lfd,0,2);	/* seek to end of file */
	return(lfd);
	}
d656 1
a656 1
 *	lrclose()						close the input file
d660 1
d662 4
a665 3
	{
	if (fd > 0) close(fd);
	}
d668 1
a668 1
 *	lwclose()						close output file flushing if needed
d672 1
d674 5
a678 3
	{
	lflush();	if (lfd > 2) close(lfd);
	}
d681 2
a682 2
 *	lprcat(string)					append a string to the output buffer
 *								    avoids calls to lprintf (time consuming)
d684 1
d686 6
a691 4
    register char *str;
    {
	register char *str2;
	if (lpnt >= lpend) lflush(); 
d693 2
a694 1
	while (*str2++ = *str++);
d696 1
a696 1
    }
d700 1
a700 1
 *	cursor(x,y) 		Subroutine to set the cursor position
d703 1
a703 1
 *	escape sequence will be placed. 
d705 22
a726 20
static char *y_num[]= { "\33[","\33[","\33[2","\33[3","\33[4","\33[5","\33[6",
	"\33[7","\33[8","\33[9","\33[10","\33[11","\33[12","\33[13","\33[14",
	"\33[15","\33[16","\33[17","\33[18","\33[19","\33[20","\33[21","\33[22",
	"\33[23","\33[24" };

static char *x_num[]= { "H","H",";2H",";3H",";4H",";5H",";6H",";7H",";8H",";9H",
	";10H",";11H",";12H",";13H",";14H",";15H",";16H",";17H",";18H",";19H",
	";20H",";21H",";22H",";23H",";24H",";25H",";26H",";27H",";28H",";29H",
	";30H",";31H",";32H",";33H",";34H",";35H",";36H",";37H",";38H",";39H",
	";40H",";41H",";42H",";43H",";44H",";45H",";46H",";47H",";48H",";49H",
	";50H",";51H",";52H",";53H",";54H",";55H",";56H",";57H",";58H",";59H",
	";60H",";61H",";62H",";63H",";64H",";65H",";66H",";67H",";68H",";69H",
	";70H",";71H",";72H",";73H",";74H",";75H",";76H",";77H",";78H",";79H",
	";80H" };

cursor(x,y)
	int x,y;
	{
	register char *p;
	if (lpnt >= lpend) lflush();
d728 2
a729 2
	p = y_num[y];	/* get the string to print */
	while (*p) *lpnt++ = *p++;	/* print the string */
d731 9
a739 4
	p = x_num[x];	/* get the string to print */
	while (*p) *lpnt++ = *p++;	/* print the string */
	}
#else VT100
d743 6
a748 4
cursor (x,y)
	int x,y;
	{
	if (lpnt >= lpend) lflush ();
d750 5
a754 3
	*lpnt++ = CURSOR;		*lpnt++ = x;		*lpnt++ = y;
	}
#endif VT100
d759 1
d761 3
a763 3
	{
	cursor(1,24);
	}
d773 3
a775 5
static char cap[256];
char *CM, *CE, *CD, *CL, *SO, *SE, *AL, *DL;/* Termcap capabilities */
static char *outbuf=0;	/* translated output buffer */

int putchar ();
d780 1
d782 48
a829 48
	{
	char termbuf[1024];
	char *capptr = cap+10;
	char *term;

	switch (tgetent(termbuf, term = getenv("TERM")))
		{
		case -1: 
			write(2, "Cannot open termcap file.\n", 26); exit();
		case 0: 
			write(2, "Cannot find entry of ", 21);
			write(2, term, strlen (term));
			write(2, " in termcap\n", 12);
			exit();
		};

	CM = tgetstr("cm", &capptr);  /* Cursor motion */
	CE = tgetstr("ce", &capptr);  /* Clear to eoln */
	CL = tgetstr("cl", &capptr);  /* Clear screen */

/* OPTIONAL */
	AL = tgetstr("al", &capptr);  /* Insert line */
	DL = tgetstr("dl", &capptr);  /* Delete line */
	SO = tgetstr("so", &capptr);  /* Begin standout mode */
	SE = tgetstr("se", &capptr);  /* End standout mode */
	CD = tgetstr("cd", &capptr);  /* Clear to end of display */

	if (!CM)	/* can't find cursor motion entry */
		{
		write(2, "Sorry, for a ",13);		write(2, term, strlen(term));
		write(2, ", I can't find the cursor motion entry in termcap\n",50);
		exit();
		}
	if (!CE)	/* can't find clear to end of line entry */
		{
		write(2, "Sorry, for a ",13);		write(2, term, strlen(term));
		write(2,", I can't find the clear to end of line entry in termcap\n",57);
		exit();
		}
	if (!CL)	/* can't find clear entire screen entry */
		{
		write(2, "Sorry, for a ",13);		write(2, term, strlen(term));
		write(2, ", I can't find the clear entire screen entry in termcap\n",56);
		exit();
		}
	if ((outbuf=malloc(BUFBIG+16))==0) /* get memory for decoded output buffer*/
		{
		write(2,"Error malloc'ing memory for decoded output buffer\n",50);
a830 1
		}
d832 2
a833 1
#endif VT100
d838 4
a841 3
cl_line(x,y)
	int x,y;
	{
d843 8
a850 5
	cursor(x,y);		lprcat("\33[2K");
#else VT100
	cursor(1,y);		*lpnt++ = CL_LINE;		cursor(x,y);
#endif VT100
	}
d855 4
a858 3
cl_up(x,y)
	register int x,y;
	{
d860 8
a867 7
	cursor(x,y);  lprcat("\33[1J\33[2K");
#else VT100
	register int i;
	cursor(1,1);
	for (i=1; i<=y; i++)   { *lpnt++ = CL_LINE;  *lpnt++ = '\n'; }
	cursor(x,y);
#endif VT100
d869 3
d874 1
a874 1
 * cl_dn(x,y) 	Clear screen from [1,y] to end of display. Leave cursor at [x,y]
d876 4
a879 3
cl_dn(x,y)
	register int x,y;
	{
d881 6
a886 6
	cursor(x,y); lprcat("\33[J\33[2K");
#else VT100
	register int i;
	cursor(1,y);
	if (!CD)
		{
d888 4
a891 2
		for (i=y; i<=24; i++) { *lpnt++ = CL_LINE;  if (i!=24) *lpnt++ = '\n'; }
		cursor(x,y);
d893 2
a894 1
	else
d896 3
a898 3
	cursor(x,y);
#endif VT100
	}
d901 1
a901 1
 * standout(str)	Print the argument string in inverse video (standout mode).
d903 4
a906 3
standout(str)
	register char *str;
	{
d912 1
a912 1
#else VT100
d917 2
a918 2
#endif VT100
	}
d921 1
a921 1
 * set_score_output() 	Called when output should be literally printed.
d923 1
d925 1
a925 1
	{
d927 1
a927 1
	}
d930 1
a930 1
 *	lflush()						Flush the output buffer
d934 1
a934 1
 *							status as indicated by `enable_scroll'
d937 9
a945 7
static int scrline=18; /* line # for wraparound instead of scrolling if no DL */
lflush ()
	{
	register int lpoint;
	register char *str;
	static int curx = 0;
	static int cury = 0;
d947 1
a947 2
	if ((lpoint = lpnt - lpbuf) > 0)
		{
d951 1
a951 2
		if (enable_scroll <= -1)
			{
d953 2
a954 2
		if (write(lfd,lpbuf,lpoint) != lpoint)
				write(2,"error writing to output file\n",29);
d957 64
a1020 53
			}
		for (str = lpbuf; str < lpnt; str++)
			{
			if (*str>=32)	{ putchar (*str); curx++; }
			else switch (*str)
				{
				case CLEAR:		tputs (CL, 0, putchar);		curx = cury = 0;
								break;

				case CL_LINE:	tputs (CE, 0, putchar);
								break;

				case CL_DOWN:	tputs (CD, 0, putchar);
								break;

				case ST_START:	tputs (SO, 0, putchar);
								break;

				case ST_END:	tputs (SE, 0, putchar);
								break;

				case CURSOR:	curx = *++str - 1;		cury = *++str - 1;
								tputs (tgoto (CM, curx, cury), 0, putchar);
								break;

				case '\n':		if ((cury == 23) && enable_scroll)
								  {
								  if (!DL || !AL) /* wraparound or scroll? */
									{
									if (++scrline > 23) scrline=19;

									if (++scrline > 23) scrline=19;
									tputs (tgoto (CM, 0, scrline), 0, putchar);
									tputs (CE, 0, putchar);

									if (--scrline < 19) scrline=23;
									tputs (tgoto (CM, 0, scrline), 0, putchar);
									tputs (CE, 0, putchar);
									}
								  else
									{
									tputs (tgoto (CM, 0, 19), 0, putchar);
									tputs (DL, 0, putchar);
									tputs (tgoto (CM, 0, 23), 0, putchar);
								/*	tputs (AL, 0, putchar); */
									}
								  }
								else
								  {
								  putchar ('\n');		cury++;
								  }
								curx = 0;
								break;
d1022 3
a1024 1
				default:		putchar (*str); curx++;
a1025 1
			}
d1027 1
d1029 3
a1031 3
	flush_buf();	/* flush real output buffer now */
	}
#else VT100
d1033 1
a1033 1
 *	lflush()						flush the output buffer
d1037 1
d1039 4
a1042 4
    {
	register int lpoint;
	if ((lpoint = lpnt - lpbuf) > 0)
	{
d1046 2
a1047 2
	if (write(lfd,lpbuf,lpoint) != lpoint)
			write(2,"error writing to output file\n",29);
d1049 3
a1051 3
	lpnt = lpbuf;	/* point back to beginning of buffer */
    }
#endif VT100
d1054 1
a1054 1
static int vindex=0;
d1056 1
a1056 1
 * putchar(ch)		Print one character in decoded output buffer.
d1058 4
a1061 3
int putchar(c)
int c;
	{
d1063 4
a1066 2
	if (vindex >= BUFBIG)  flush_buf();
	}
d1071 1
d1073 3
a1075 2
	{
	if (vindex) write(lfd, outbuf, vindex);
d1077 1
a1077 1
	}
d1080 48
a1127 31
 *	char *tmcapcnv(sd,ss)  Routine to convert VT100 escapes to termcap format
 *
 *	Processes only the \33[#m sequence (converts . files for termcap use 
 */
char *tmcapcnv(sd,ss)  
	register char *sd,*ss;
	{
	register int tmstate=0;	/* 0=normal, 1=\33 2=[ 3=# */
	char tmdigit=0;	/* the # in \33[#m */
	while (*ss)
		{
		switch(tmstate)
			{
			case 0:	if (*ss=='\33')  { tmstate++; break; }
			  ign:  *sd++ = *ss;
			  ign2: tmstate = 0;
					break;
			case 1: if (*ss!='[') goto ign;
					tmstate++;
					break;
			case 2: if (isdigit(*ss)) { tmdigit= *ss-'0'; tmstate++; break; }
					if (*ss == 'm') { *sd++ = ST_END; goto ign2; }
					goto ign;
			case 3: if (*ss == 'm')
						{
						if (tmdigit) *sd++ = ST_START;
							else *sd++ = ST_END;
						goto ign2;
						}
			default: goto ign;
			};
a1128 3
		}
	*sd=0; /* NULL terminator */
	return(sd);
d1130 4
a1133 1
#endif VT100
d1136 8
a1143 6
 *	beep()		Routine to emit a beep if enabled (see no-beep in .larnopts)
 */
beep()
	{
	if (!nobeep) *lpnt++ = '\7';
	}
@


1.2
log
@NetBSD PR#2699: delay revoke of privs until after log file is opened,
and print better diagnostics.  Kenneth Stailey <kstailey@@dol-esa.gov>
@
text
@d48 1
a48 1
 *  cl_line(x,y)         		Clear line at [1,y] and leave cursor at [x,y]
d344 2
a345 2
        {
        if (i!=0)  write(1,"error reading from input file\n",30);
d347 1
a347 1
        }
d770 1
a770 1
        	if (write(lfd,lpbuf,lpoint) != lpoint)
d845 1
a845 1
        {
d849 1
a849 1
        if (write(lfd,lpbuf,lpoint) != lpoint)
d851 1
a851 1
        }
@


1.1
log
@Initial revision
@
text
@d457 1
d462 2
a463 1
		lfd=1; lprintf("error creating file <%s>\n",str); lflush(); return(-1);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
