head	1.22;
access;
symbols
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.12
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.10
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.6
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.4
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.10
	OPENBSD_5_0:1.12.0.8
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.4
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.10.0.4
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.8.0.16
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.14
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.12
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.10
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.14
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.12
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.10
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.8
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2016.09.11.14.21.17;	author tb;	state Exp;
branches;
next	1.21;
commitid	vQliJ9M8LCn9g8k6;

1.21
date	2016.01.10.14.10.38;	author mestre;	state Exp;
branches;
next	1.20;
commitid	uHkFLRJtNioh0rOz;

1.20
date	2016.01.10.13.35.09;	author mestre;	state Exp;
branches;
next	1.19;
commitid	mVbl9a8GbGdqcFgu;

1.19
date	2016.01.10.13.18.07;	author mestre;	state Exp;
branches;
next	1.18;
commitid	H7VQLgV7QCavpvH5;

1.18
date	2016.01.03.14.38.16;	author mestre;	state Exp;
branches;
next	1.17;
commitid	Ptgw9rNvmSHNRfGy;

1.17
date	2015.12.27.01.28.02;	author chl;	state Exp;
branches;
next	1.16;
commitid	GsxPrnKUYIKNaKzS;

1.16
date	2015.11.05.08.40.34;	author guenther;	state Exp;
branches;
next	1.15;
commitid	9vc1AZ3XG1JtPjhA;

1.15
date	2015.10.24.18.51.40;	author mmcc;	state Exp;
branches;
next	1.14;
commitid	IpMYTO9YKbN6Cb7Q;

1.14
date	2014.12.04.06.12.33;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	ezwXVF1SJPWPjy6G;

1.13
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.27.23.59.24;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2009.05.21.12.57.31;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2008.03.26.20.12.59;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.03.20.12.02.27;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.10.07.26.22;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.03.03.01.39;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.06.21.48.51;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.31.04.21.29;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.16.21.27.09;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	98.09.24.06.45.06;	author pjanzen;	state Exp;
branches;
next	1.2;

1.2
date	97.07.23.20.04.48;	author kstailey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.45;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Callers of time(3) should #include <time.h>.

ok deraadt
@
text
@/*	$OpenBSD: mach.c,v 1.21 2016/01/10 14:10:38 mestre Exp $	*/
/*	$NetBSD: mach.c,v 1.5 1995/04/28 22:28:48 mycroft Exp $	*/

/*-
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Barry Brachman.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Terminal interface
 *
 * Input is raw and unechoed
 */
#include <sys/ioctl.h>

#include <ctype.h>
#include <curses.h>
#include <err.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <time.h>

#include "bog.h"
#include "extern.h"

static int ccol, crow, maxw;
static int colstarts[MAXCOLS], ncolstarts;
static char *separator;
int ncols, nlines, lastline;

/* 
 * The following determine the screen layout
 */
int PROMPT_COL	= 20;
int PROMPT_LINE	= 3;

int BOARD_COL	= 0;
int BOARD_LINE	= 0;

int SCORE_COL	= 20;
int SCORE_LINE	= 0;

int LIST_COL	= 0;
int LIST_LINE	= 10;

int TIMER_COL	= 20;
int TIMER_LINE	= 2;

extern char **pword, **mword;
extern int ngames, nmwords, npwords, tnmwords, tnpwords, ncubes, grid;

static void	cont_catcher(int);
static int	prwidth(char **, int);
static void	prword(char **, int);
static void	stop_catcher(int);
static void	tty_cleanup(void);
static int	tty_setup(void);
static void	tty_showboard(char *);
static void	winch_catcher(int);

/*
 * Do system dependent initialization
 * This is called once, when the program starts
 */
int
setup(void)
{
	char *cp, *ep;

	if (tty_setup() < 0)
		return(-1);

	separator = malloc(4 * grid + 2);
	if (separator == NULL)
		err(1, NULL);

	ep = separator + 4 * grid;
	for (cp = separator; cp < ep;) {
		*cp++ = '+';
		*cp++ = '-';
		*cp++ = '-';
		*cp++ = '-';
	}
	*cp++ = '+';
	*cp = '\0';

	SCORE_COL += (grid - 4) * 4;
	TIMER_COL += (grid - 4) * 4;
	PROMPT_COL += (grid - 4) * 4;
	LIST_LINE += (grid - 4) * 2;

	return(0);
}

/*
 * Do system dependent clean up
 * This is called once, just before the program terminates
 */
void
cleanup(void)
{
	tty_cleanup();
}

/*
 * Display the player's word list, the list of words not found, and the running
 * stats
 */
void
results(void)
{
	int col, row;
	int denom1, denom2;

	move(LIST_LINE, LIST_COL);
	clrtobot();
	printw("Words you found (%d):", npwords);
	refresh();
	move(LIST_LINE + 1, LIST_COL);
	prtable(pword, npwords, 0, ncols, prword, prwidth);

	getyx(stdscr, row, col);
	move(row + 1, col);
	printw("Words you missed (%d):", nmwords);
	refresh();
	move(row + 2, col);
	prtable(mword, nmwords, 0, ncols, prword, prwidth);

	denom1 = npwords + nmwords;
	denom2 = tnpwords + tnmwords;
 
	move(SCORE_LINE, SCORE_COL);
	printw("Score: %d out of %d\n", npwords, denom1);
	move(SCORE_LINE + 1, SCORE_COL);
	printw("Percentage: %0.2f%% (%0.2f%% over %d game%s)\n",
	denom1 ? (100.0 * npwords)  / (double) denom1 : 0.0,
	denom2 ? (100.0 * tnpwords) / (double) denom2 : 0.0,
	ngames, ngames > 1 ? "s" : "");
	move(TIMER_LINE, TIMER_COL);
	wclrtoeol(stdscr);
}

static void
prword(char **base, int indx)
{
	printw("%s", base[indx]);
}

static int
prwidth(char **base, int indx)
{
	return (strlen(base[indx]));
}

/*
 * Main input routine
 *
 * - doesn't accept words longer than MAXWORDLEN or containing caps
 */
char *
get_line(char *q)
{
	int ch, done;
	char *p;
	int row, col;

	p = q;
	done = 0;
	while (!done) {
		ch = timerch();
		switch (ch) {
		case '\n':
		case '\r':
		case ' ':
			done = 1;
			break;
		case '\033':
			findword();
			break;
		case '\177':			/* <del> */
		case '\010':			/* <bs> */
			if (p == q)
				break;
			p--;
			getyx(stdscr, row, col);
			move(row, col - 1);
			clrtoeol();
			refresh();
			break;
		case '\025':			/* <^u> */
		case '\027':			/* <^w> */
			if (p == q)
				break;
			getyx(stdscr, row, col);
			move(row, col - (int) (p - q));
			p = q;
			clrtoeol();
			refresh();
			break;
#ifdef SIGTSTP
		case '\032':			/* <^z> */
			stop_catcher(0);
			break;
#endif
		case '\023':			/* <^s> */
			stoptime();
			printw("<PAUSE>");
			refresh();
			while ((ch = inputch()) != '\021' && ch != '\023')
				;
			move(crow, ccol);
			clrtoeol();
			refresh();
			starttime();
			break;
		case '\003':			/* <^c> */
			cleanup();
			exit(0);
		case '\004':			/* <^d> */
			done = 1;
			ch = EOF;
			break;
		case '\014':			/* <^l> */
		case '\022':			/* <^r> */
			redraw();
			break;
		case '?':
			stoptime();
			if (help() < 0)
				showstr("Can't open help file", 1);
			starttime();
			break;
		default:
			if (!islower(ch))
				break;
			if ((int) (p - q) == MAXWORDLEN) {
				p = q;
				badword();
				break;
			}
			*p++ = ch;
			addch(ch);
			refresh();
			break;
		}
	}
	*p = '\0';
	if (ch == EOF)
		return(NULL);
	return(q);
}

int
inputch(void)
{
	int ch;

	if ((ch = getch()) == ERR)
		err(1, "cannot read input");
	return (ch & 0177);
}

void
redraw(void)
{
	clearok(stdscr, 1);
	refresh();
}

void
flushin(FILE *fp)
{

	(void) tcflush(fileno(fp), TCIFLUSH);
}

static int gone;

/*
 * Stop the game timer
 */
void
stoptime(void)
{
	extern time_t start_t;
	time_t t;

	(void)time(&t);
	gone = (int) (t - start_t);
}

/*
 * Restart the game timer
 */
void
starttime(void)
{
	extern time_t start_t;
	time_t t;

	(void)time(&t);
	start_t = t - (long) gone;
}

/*
 * Initialize for the display of the player's words as they are typed
 * This display starts at (LIST_LINE, LIST_COL) and goes "down" until the last
 * line.  After the last line a new column is started at LIST_LINE
 * Keep track of each column position for showword()
 * There is no check for exceeding COLS
 */
void
startwords(void)
{
	crow = LIST_LINE;
	ccol = LIST_COL;
	maxw = 0;
	ncolstarts = 1;
	colstarts[0] = LIST_COL;
	move(LIST_LINE, LIST_COL);
	refresh();
}

/*
 * Add a word to the list and start a new column if necessary
 * The maximum width of the current column is maintained so we know where
 * to start the next column
 */
void
addword(char *w)
{
	int n;

	if (crow == lastline) {
		crow = LIST_LINE;
		ccol += (maxw + 5);
		colstarts[ncolstarts++] = ccol;
		maxw = 0;
		move(crow, ccol);
	}
	else {
		move(++crow, ccol);
		if ((n = strlen(w)) > maxw)
			maxw = n;
	}
	refresh();
}

/*
 * The current word is unacceptable so erase it
 */
void
badword(void)
{

	move(crow, ccol);
	clrtoeol();
	refresh();
}

/*
 * Highlight the nth word in the list (starting with word 0)
 * No check for wild arg
 */
void
showword(int n)
{
	int col, row;

	row = LIST_LINE + n % (lastline - LIST_LINE + 1);
	col = colstarts[n / (lastline - LIST_LINE + 1)];
	move(row, col);
	standout();
	printw("%s", pword[n]);
	standend();
	move(crow, ccol);
	refresh();
	delay(15);
	move(row, col);
	printw("%s", pword[n]);
	move(crow, ccol);
	refresh();
}

/*
 * Walk the path of a word, refreshing the letters,
 * optionally pausing after each
 */
static void
doword(int pause, int r, int c)
{
	extern char *board;
	extern int wordpath[];
	int i, row, col;
	unsigned char ch;

	for (i = 0; wordpath[i] != -1; i++) {
		row = BOARD_LINE + (wordpath[i] / 4) * 2 + 1;
		col = BOARD_COL + (wordpath[i] % 4) * 4 + 2;
		move(row, col);
		ch = board[wordpath[i]];
		if (HISET(ch))
			attron(A_BOLD);
		if (SEVENBIT(ch) == 'q')
			printw("Qu");
		else
			printw("%c", toupper(SEVENBIT(ch)));
		if (HISET(ch))
			attroff(A_BOLD);
		if (pause) {
			move(r, c);
			refresh();
			delay(5);
		}
	}
}

/*
 * Get a word from the user and check if it is in either of the two
 * word lists
 * If it's found, show the word on the board for a short time and then
 * erase the word
 *
 * Note: this function knows about the format of the board
 */
void
findword(void)
{
	int c, found, i, r;
	char buf[MAXWORDLEN + 1];
	extern int usedbits, wordpath[];
	extern char **mword, **pword;
	extern int nmwords, npwords;

	getyx(stdscr, r, c);
	getword(buf);
	found = 0;
	for (i = 0; i < npwords; i++) {
		if (strcmp(buf, pword[i]) == 0) {
			found = 1;
			break;
		}
	}
	if (!found) {
		for (i = 0; i < nmwords; i++) {
			if (strcmp(buf, mword[i]) == 0) {
				found = 1;
				break;
			}
		}
	}
	for (i = 0; i < MAXWORDLEN; i++)
		wordpath[i] = -1;
	usedbits = 0;
	if (!found || checkword(buf, -1, wordpath) == -1) {
		move(r, c);
		clrtoeol();
		addstr("[???]");
		refresh();
		delay(10);
		move(r, c);
		clrtoeol();
		refresh();
		return;
	}

	standout();
	doword(1, r, c);
	standend();
	doword(0, r, c);

	move(r, c);
	clrtoeol();
	refresh();
}

/*
 * Display a string at the current cursor position for the given number of secs
 */
void
showstr(char *str, int delaysecs)
{
	addstr(str);
	refresh();
	delay(delaysecs * 10);
	move(crow, ccol);
	clrtoeol();
	refresh();
}

void
putstr(char *s)
{
	addstr(s);
}

/*
 * Get a valid word and put it in the buffer
 */
void
getword(char *q)
{
	int ch, col, done, i, row;
	char *p;

	done = 0;
	i = 0;
	p = q;
	addch('[');
	refresh();
	while (!done && i < MAXWORDLEN - 1) {
		ch = inputch();
		switch (ch) {
		case '\177':			/* <del> */
		case '\010':			/* <bs> */
			if (p == q)
				break;
			p--;
			getyx(stdscr, row, col);
			move(row, col - 1);
			clrtoeol();
			break;
		case '\025':			/* <^u> */
		case '\027':			/* <^w> */
			if (p == q)
				break;
			getyx(stdscr, row, col);
			move(row, col - (int) (p - q));
			p = q;
			clrtoeol();
			break;
		case ' ':
		case '\n':
		case '\r':
			done = 1;
			break;
		case '\014':			/* <^l> */
		case '\022':			/* <^r> */
			clearok(stdscr, 1);
			refresh();
			break;
		default:
			if (islower(ch)) {
				*p++ = ch;
				addch(ch);
				i++;
			}
			break;
		}
		refresh();
	}
	*p = '\0';
	addch(']');
	refresh();
}

void
showboard(char *b)
{
	tty_showboard(b);
}

void
prompt(char *mesg)
{
	move(PROMPT_LINE, PROMPT_COL);
	printw("%s", mesg);
	move(PROMPT_LINE + 1, PROMPT_COL);
	refresh();
}

static int
tty_setup(void)
{
	initscr();
	raw();
	noecho();

	/*
	 * Does curses look at the winsize structure?
	 * Should handle SIGWINCH ...
	 */
	nlines = LINES;
	lastline = nlines - 1;
	ncols = COLS;

	signal(SIGTSTP, stop_catcher);
	signal(SIGCONT, cont_catcher);
	signal(SIGWINCH, winch_catcher);
	return(0);
}

static void
stop_catcher(int signo)
{
	sigset_t sigset, osigset;

	stoptime();
	noraw();
	echo();
	move(nlines - 1, 0);
	refresh();

	signal(SIGTSTP, SIG_DFL);
	sigemptyset(&sigset);
	sigaddset(&sigset, SIGTSTP);
	sigprocmask(SIG_UNBLOCK, &sigset, &osigset);
	kill(0, SIGTSTP);
	sigprocmask(SIG_SETMASK, &osigset, (sigset_t *)0);
	signal(SIGTSTP, stop_catcher);
}
 
static void
cont_catcher(int signo)
{
	noecho();
	raw();
	clearok(stdscr, 1);
	move(crow, ccol);
	refresh();
	starttime();
}
 
/*
 * The signal is caught but nothing is done about it...
 * It would mean reformatting the entire display
 */
static void
winch_catcher(int signo)
{
	struct winsize win;

	(void) signal(SIGWINCH, winch_catcher);
	(void) ioctl(fileno(stdout), TIOCGWINSZ, &win);
	/*
	LINES = win.ws_row;
	COLS = win.ws_col;
	*/
}

static void
tty_cleanup(void)
{
	move(nlines - 1, 0);
	refresh();
	noraw();
	echo();
	endwin();
}

static void
tty_showboard(char *b)
{
	int i, line;
	char ch;

	clear();
	move(BOARD_LINE, BOARD_COL);
	line = BOARD_LINE;
	printw(separator);
	move(++line, BOARD_COL);
	for (i = 0; i < ncubes; i++) {
		printw("| ");
		ch = SEVENBIT(b[i]);
		if (HISET(b[i]))
			attron(A_BOLD);
		if (ch == 'q')
			printw("Qu");
		else
			printw("%c ", toupper((unsigned char)ch));
		if (HISET(b[i]))
			attroff(A_BOLD);
		if ((i + 1) % grid == 0) {
			printw("|");
			move(++line, BOARD_COL);
			printw(separator);
			move(++line, BOARD_COL);
		}
	}
	move(SCORE_LINE, SCORE_COL);
	printw("Type '?' for help");
	refresh();
}
@


1.21
log
@Remove needless casts to (char *) NULL. Some were kept, namely for execl(3)
last arguments since "The list of arguments must be terminated by a null
null pointer" of type char *

Suggested by and OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mach.c,v 1.20 2016/01/10 13:35:09 mestre Exp $	*/
d50 1
@


1.20
log
@As per style(9), remove remaining lint-style comments from games/

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mach.c,v 1.19 2016/01/10 13:18:07 mestre Exp $	*/
d277 1
a277 1
		return((char *) NULL);
@


1.19
log
@Remove unnecessary headers

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mach.c,v 1.18 2016/01/03 14:38:16 mestre Exp $	*/
a246 1
			/*NOTREACHED*/
@


1.18
log
@About 13 years ago when the idiom srandom(time()), and sometimes
srandom(time()+getpid()), was changed by srandomdev(), but #include <time.h>
lived up until this day so remove it.

Additionally, earlier than that, 18 years ago, random(6) was one of the first
consumers of arc4random(3) family, and was pulling it from dev/rndvar.h but
these days we pull it from stdlib.h, which is already done, so while here
remove dev/rndvar.h also.

"seems comprehensive to me" deraadt@@ and OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mach.c,v 1.17 2015/12/27 01:28:02 chl Exp $	*/
a45 1
#include <fcntl.h>
a46 1
#include <stdio.h>
@


1.17
log
@remove unused variables

ok mmcc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mach.c,v 1.16 2015/11/05 08:40:34 guenther Exp $	*/
a51 1
#include <time.h>
@


1.16
log
@ctype functions take unsigned char values.
Fix redrawing of the challenge cube (-c option) when <esc>word is used.

ok mmcc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mach.c,v 1.15 2015/10/24 18:51:40 mmcc Exp $	*/
d461 1
a461 1
	int c, col, found, i, r, row;
@


1.15
log
@Cast toupper()'s argument to unsigned char.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mach.c,v 1.14 2014/12/04 06:12:33 deraadt Exp $	*/
d418 33
a462 1
	extern char *board;
d500 1
a500 13
	for (i = 0; wordpath[i] != -1; i++) {
		row = BOARD_LINE + (wordpath[i] / 4) * 2 + 1;
		col = BOARD_COL + (wordpath[i] % 4) * 4 + 2;
		move(row, col);
		if (board[wordpath[i]] == 'q')
			printw("Qu");
		else
			printw("%c", toupper(board[wordpath[i]]));
		move(r, c);
		refresh();
		delay(5);
	}

d502 1
a503 9
	for (i = 0; wordpath[i] != -1; i++) {
		row = BOARD_LINE + (wordpath[i] / 4) * 2 + 1;
		col = BOARD_COL + (wordpath[i] % 4) * 4 + 2;
		move(row, col);
		if (board[wordpath[i]] == 'q')
			printw("Qu");
		else
			printw("%c", toupper(board[wordpath[i]]));
	}
@


1.14
log
@Stop people from cheating.  Especially those that believe in FIPS, they
are the worst.
ok millert ingo tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: mach.c,v 1.13 2012/03/04 04:05:15 fgsch Exp $	*/
d690 1
a690 1
			printw("%c ", toupper(ch));
@


1.13
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: mach.c,v 1.12 2009/10/27 23:59:24 deraadt Exp $	*/
d97 1
a97 1
setup(char *seed)
a102 5

	if (seed != NULL)
		srandom(atol(seed));
	else
		srandomdev();
@


1.12
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: mach.c,v 1.11 2009/05/21 12:57:31 schwarze Exp $	*/
d197 1
a197 1
getline(char *q)
@


1.11
log
@correct number of total words on the "Score:" line
from Graeme Lee <graeme at omni dot net dot au> on tech@@, tweaked by me
while here, actually use the variables denom[12] defined a few lines above
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mach.c,v 1.10 2008/03/26 20:12:59 millert Exp $	*/
a34 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)mach.c	8.1 (Berkeley) 6/11/93";
#else
static char rcsid[] = "$OpenBSD: mach.c,v 1.10 2008/03/26 20:12:59 millert Exp $";
#endif
#endif /* not lint */
@


1.10
log
@Bomb out if we cannot read the input.  This happens when select
says there has been a status change to indicate that the tty has
gone away.  Prevents spinning on terminal detach.  OK pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mach.c,v 1.9 2008/03/20 12:02:27 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: mach.c,v 1.9 2008/03/20 12:02:27 millert Exp $";
d177 1
a177 1
	printw("Score: %d out of %d\n", npwords, nmwords);
d180 2
a181 2
	denom1 ? (100.0 * npwords) / (double) (npwords + nmwords) : 0.0,
	denom2 ? (100.0 * tnpwords) / (double) (tnpwords + tnmwords) : 0.0,
@


1.9
log
@Make the bog code generic enough to handle arbitrary NxN grids and
add cubes for 5x5 mode based on Boggle Deluxe (aka Big Boggle) as
well as support for the "challenge cube" shipped with some versions
of Boggle.  Also Dynamically allocate record keeping structures so
we can deal with large word lists and add a --More-- prompt for
when there are too many wwords found by the computer to fit on the
terminal.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mach.c,v 1.8 2004/07/10 07:26:22 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: mach.c,v 1.8 2004/07/10 07:26:22 deraadt Exp $";
d301 5
a305 1
	return (getch() & 0177);
d545 1
a545 1
		ch = getch() & 0177;
@


1.8
log
@more ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: mach.c,v 1.7 2003/06/03 03:01:39 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: mach.c,v 1.7 2003/06/03 03:01:39 millert Exp $";
d53 1
d67 2
a68 2
static int lastline;
int ncols, nlines;
d70 20
a89 2
extern char *pword[], *mword[];
extern int ngames, nmwords, npwords, tnmwords, tnpwords;
d92 2
a93 2
static int	prwidth(char *[], int);
static void	prword(char *[], int);
d107 2
d116 20
d177 2
d183 2
d188 1
a188 1
prword(char *base[], int indx)
d194 1
a194 1
prwidth(char *base[], int indx)
d439 1
a439 1
	extern char board[];
d441 1
a441 1
	extern char *mword[], *pword[];
d684 1
d689 1
a689 1
	printw("+---+---+---+---+");
d691 7
a697 3
	for (i = 0; i < 16; i++) {
		if (b[i] == 'q')
			printw("| Qu");
d699 4
a702 2
			printw("| %c ", toupper(b[i]));
		if ((i + 1) % 4 == 0) {
d705 1
a705 1
			printw("+---+---+---+---+");
@


1.7
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mach.c,v 1.6 2002/12/06 21:48:51 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: mach.c,v 1.6 2002/12/06 21:48:51 millert Exp $";
d86 1
a86 2
setup(seed)
	char *seed;
d103 1
a103 1
cleanup()
d113 1
a113 1
results()
d143 1
a143 3
prword(base, indx)
	char *base[];
	int indx;
d149 1
a149 3
prwidth(base, indx)
	char *base[];
	int indx;
d160 1
a160 2
getline(q)
	char *q;
d254 1
a254 1
inputch()
d260 1
a260 1
redraw()
d267 1
a267 2
flushin(fp)
	FILE *fp;
d279 1
a279 1
stoptime()
d292 1
a292 1
starttime()
d309 1
a309 1
startwords()
d326 1
a326 2
addword(w)
	char *w;
d349 1
a349 1
badword()
d362 1
a362 2
showword(n)
	int n;
d390 1
a390 1
findword()
d465 1
a465 3
showstr(str, delaysecs)
	char *str;
	int delaysecs;
d476 1
a476 2
putstr(s)
	char *s;
d485 1
a485 2
getword(q)
	char *q;
d542 1
a542 2
showboard(b)
	char *b;
d548 1
a548 2
prompt(mesg)
	char *mesg;
d557 1
a557 1
tty_setup()
d578 1
a578 2
stop_catcher(signo)
	int signo;
d598 1
a598 2
cont_catcher(signo)
	int signo;
d613 1
a613 2
winch_catcher(signo)
	int signo;
d626 1
a626 1
tty_cleanup()
d636 1
a636 2
tty_showboard(b)
	char *b;
@


1.6
log
@Replace things like srandom(time(NULL)) with srandomdev(3).  random(3)
good enough for games but we should at least use a decent seed.
pjanzen@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: mach.c,v 1.5 2002/05/31 04:21:29 pjanzen Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static char rcsid[] = "$OpenBSD: mach.c,v 1.5 2002/05/31 04:21:29 pjanzen Exp $";
@


1.5
log
@de-register
@
text
@d1 1
a1 1
/*	$OpenBSD: mach.c,v 1.4 2002/02/16 21:27:09 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: mach.c,v 1.4 2002/02/16 21:27:09 millert Exp $";
d90 2
a91 3
setup(sflag, seed)
	int sflag;
	time_t seed;
a92 2
	extern int debug;

d96 4
a99 5
	if (!sflag)
		time(&seed);
	srandom(seed);
	if (debug)
		(void) printf("seed = %ld\n", (long) seed);
@


1.4
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: mach.c,v 1.3 1998/09/24 06:45:06 pjanzen Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: mach.c,v 1.3 1998/09/24 06:45:06 pjanzen Exp $";
d176 2
a177 2
	register int ch, done;
	register char *p;
d665 1
a665 2
	register int i;
	int line;
@


1.3
log
@NetBSD changes and a few obvious fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD$";
d76 8
a83 8
static void	cont_catcher __P((int));
static int	prwidth __P((char *[], int));
static void	prword __P((char *[], int));
static void	stop_catcher __P((int));
static void	tty_cleanup __P((void));
static int	tty_setup __P((void));
static void	tty_showboard __P((char *));
static void	winch_catcher __P((int));
@


1.2
log
@tabify
@
text
@d1 1
d44 1
a44 1
static char rcsid[] = "$NetBSD: mach.c,v 1.5 1995/04/28 22:28:48 mycroft Exp $";
d53 2
d103 1
a103 1
		(void) printf("seed = %ld\n", seed);
@


1.1
log
@Initial revision
@
text
@d143 3
a145 3
        denom1 ? (100.0 * npwords) / (double) (npwords + nmwords) : 0.0,
        denom2 ? (100.0 * tnpwords) / (double) (tnpwords + tnmwords) : 0.0,
        ngames, ngames > 1 ? "s" : "");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
