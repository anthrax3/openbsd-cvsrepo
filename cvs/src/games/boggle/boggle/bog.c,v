head	1.33;
access;
symbols
	OPENBSD_6_0:1.30.0.2
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.22.0.6
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.21.0.6
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.4
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.2
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.10
	OPENBSD_5_0:1.20.0.8
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.6
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.6
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.2
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.15.0.6
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.4
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.14.0.10
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.8
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.6
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.6.0.8
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.6
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2016.09.12.20.11.10;	author tb;	state Exp;
branches;
next	1.32;
commitid	Hb79BHSlBvznTnyb;

1.32
date	2016.09.12.14.38.58;	author otto;	state Exp;
branches;
next	1.31;
commitid	ntPCcuYpauRNlLdb;

1.31
date	2016.08.27.02.00.10;	author guenther;	state Exp;
branches;
next	1.30;
commitid	usv2ULh2hPPt9BPj;

1.30
date	2016.03.07.12.07.55;	author mestre;	state Exp;
branches;
next	1.29;
commitid	NZhYxChmyb9vOEMM;

1.29
date	2016.01.10.13.18.07;	author mestre;	state Exp;
branches;
next	1.28;
commitid	H7VQLgV7QCavpvH5;

1.28
date	2016.01.07.16.00.31;	author tb;	state Exp;
branches;
next	1.27;
commitid	IwzFE3fG5RnKTWNh;

1.27
date	2016.01.03.14.38.16;	author mestre;	state Exp;
branches;
next	1.26;
commitid	Ptgw9rNvmSHNRfGy;

1.26
date	2015.11.30.08.27.46;	author tb;	state Exp;
branches;
next	1.25;
commitid	cfMV2xurtx7RCoa8;

1.25
date	2015.10.24.17.23.14;	author mmcc;	state Exp;
branches;
next	1.24;
commitid	r2Lf66zQw6byJfXm;

1.24
date	2014.12.04.06.12.33;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	ezwXVF1SJPWPjy6G;

1.23
date	2014.10.11.03.58.11;	author doug;	state Exp;
branches;
next	1.22;
commitid	cOnbqCwtUcsXVZVM;

1.22
date	2013.08.18.16.32.24;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.27.23.59.24;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2008.08.12.06.32.14;	author mbalmer;	state Exp;
branches;
next	1.18;

1.18
date	2008.03.24.12.01.54;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.20.12.02.27;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2008.03.17.09.17.56;	author sobrado;	state Exp;
branches;
next	1.15;

1.15
date	2006.12.24.12.47.57;	author martin;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.10.07.26.22;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.03.03.01.39;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.07.00.34.15;	author tdeval;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.06.21.48.51;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.31.04.21.29;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.31.03.40.00;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.09;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.03.23.10.50;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	99.07.31.18.13.30;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	98.09.24.06.45.05;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	97.07.23.20.04.48;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.40.33;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.12.19.22.21.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.44;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.44;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.33
log
@If boardspec doesn't consist entirely of lower case letters, there will be
out of bound accesses of arrays, leading to sefaults or bus errors.  Verify
that at most one boardspec with lower case letters is given, or error out.

ok millert
@
text
@/*	$OpenBSD: bog.c,v 1.32 2016/09/12 14:38:58 otto Exp $	*/
/*	$NetBSD: bog.c,v 1.5 1995/04/24 12:22:32 cgd Exp $	*/

/*-
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Barry Brachman.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <setjmp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "bog.h"
#include "extern.h"

static void	init(void);
static void	init_adjacencies(void);
static int	compar(const void *, const void *);

struct dictindex dictindex[26];

static int **adjacency, **letter_map;

char *board;
int wordpath[MAXWORDLEN + 1];
int wordlen;		/* Length of last word returned by nextword() */
int usedbits;
int ncubes;
int grid = 4;

char **pword, *pwords, *pwordsp;
int npwords, maxpwords = MAXPWORDS, maxpspace = MAXPSPACE;

char **mword, *mwords, *mwordsp;
int nmwords, maxmwords = MAXMWORDS, maxmspace = MAXMSPACE;

int ngames = 0;
int tnmwords = 0, tnpwords = 0;

jmp_buf env;

time_t start_t;

static FILE *dictfp;

int batch;
int challenge;
int debug;
int minlength;
int reuse;
int selfuse;
int tlimit;

int
main(int argc, char *argv[])
{
	int ch, done;
	char *bspec, *p;

	if (pledge("stdio rpath tty", NULL) == -1)
		err(1, "pledge");

	batch = debug = reuse = selfuse;
	bspec = NULL;
	minlength = -1;
	tlimit = 180;		/* 3 minutes is standard */

	while ((ch = getopt(argc, argv, "Bbcdht:w:")) != -1)
		switch(ch) {
		case 'B':
			grid = 5;
			break;
		case 'b':
			batch = 1;
			break;
		case 'c':
			challenge = 1;
			break;
		case 'd':
			debug = 1;
			break;
		case 't':
			if ((tlimit = atoi(optarg)) < 1)
				errx(1, "bad time limit");
			break;
		case 'w':
			if ((minlength = atoi(optarg)) < 3)
				errx(1, "min word length must be > 2");
			break;
		case 'h':
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	ncubes = grid * grid;

	/* process final arguments */
	if (argc > 0) {
		if (strcmp(argv[0], "+") == 0)
			reuse = 1;
		else if (strcmp(argv[0], "++") == 0)
			selfuse = 1;
	}

	if (reuse || selfuse) {
		argc -= 1;
		argv += 1;
	}

	if (argc == 1) {
		if (strlen(argv[0]) != ncubes)
			usage();
		for (p = argv[0]; *p != '\0'; p++)
			if (!islower((unsigned char)*p))
				errx(1, "only lower case letters are allowed "
				    "in boardspec");
		bspec = argv[0];
	} else if (argc != 0)
		usage();

	if (batch && bspec == NULL)
		errx(1, "must give both -b and a board setup");

	init();
	if (batch) {
		newgame(bspec);
		while ((p = batchword(stdin)) != NULL)
			(void) printf("%s\n", p);
		return 0;
	}
	setup();
	prompt("Loading the dictionary...");
	if ((dictfp = opendict(DICT)) == NULL) {
		warn("%s", DICT);
		cleanup();
		return 1;
	}
#ifdef LOADDICT
	if (loaddict(dictfp) < 0) {
		warnx("can't load %s", DICT);
		cleanup();
		return 1;
	}
	(void)fclose(dictfp);
	dictfp = NULL;
#endif
	if (loadindex(DICTINDEX) < 0) {
		warnx("can't load %s", DICTINDEX);
		cleanup();
		return 1;
	}

	prompt("Type <space> to begin...");
	while (inputch() != ' ');

	for (done = 0; !done;) {
		newgame(bspec);
		bspec = NULL;	/* reset for subsequent games */
		playgame();
		prompt("Type <space> to continue, any cap to quit...");
		delay(10);	/* wait for user to quit typing */
		flushin(stdin);
		for (;;) {
			ch = inputch();
			if (ch == '\033')
				findword();
			else if (ch == '\014' || ch == '\022')	/* ^l or ^r */
				redraw();
			else {
				if (isupper(ch)) {
					done = 1;
					break;
				}
				if (ch == ' ')
					break;
			}
		}
	}
	cleanup();
	return 0;
}

/*
 * Read a line from the given stream and check if it is legal
 * Return a pointer to a legal word or a null pointer when EOF is reached
 */
char *
batchword(FILE *fp)
{
	int *p, *q;
	char *w;

	q = &wordpath[MAXWORDLEN + 1];
	p = wordpath;
	while (p < q)
		*p++ = -1;
	while ((w = nextword(fp)) != NULL) {
		if (wordlen < minlength)
			continue;
		p = wordpath;
		while (p < q && *p != -1)
			*p++ = -1;
		usedbits = 0;
		if (checkword(w, -1, wordpath) != -1)
			return (w);
	}
	return (NULL);
}

/*
 * Play a single game
 * Reset the word lists from last game
 * Keep track of the running stats
 */
void
playgame(void)
{
	int i, *p, *q;
	time_t t;
	char buf[MAXWORDLEN + 1];

	ngames++;
	npwords = 0;
	pwordsp = pwords;
	nmwords = 0;
	mwordsp = mwords;

	time(&start_t);

	q = &wordpath[MAXWORDLEN + 1];
	p = wordpath;
	while (p < q)
		*p++ = -1;
	showboard(board);
	startwords();
	if (setjmp(env)) {
		badword();
		goto timesup;
	}

	while (1) {
		if (get_line(buf) == NULL) {
			if (feof(stdin))
				clearerr(stdin);
			break;
		}
		time(&t);
		if (t - start_t >= tlimit) {
			badword();
			break;
		}
		if (buf[0] == '\0') {
			int remaining;

			remaining = tlimit - (int) (t - start_t);
			(void)snprintf(buf, sizeof(buf),
			    "%d:%02d", remaining / 60, remaining % 60);
			showstr(buf, 1);
			continue;
		}
		if (strlen(buf) < (size_t)minlength) {
			badword();
			continue;
		}

		p = wordpath;
		while (p < q && *p != -1)
			*p++ = -1;
		usedbits = 0;

		if (checkword(buf, -1, wordpath) < 0)
			badword();
		else {
			if (debug) {
				(void) printf("[");
				for (i = 0; wordpath[i] != -1; i++)
					(void) printf(" %d", wordpath[i]);
				(void) printf(" ]\n");
			}
			for (i = 0; i < npwords; i++) {
				if (strcmp(pword[i], buf) == 0)
					break;
			}
			if (i != npwords) {	/* already used the word */
				badword();
				showword(i);
			}
			else if (!validword(buf))
				badword();
			else {
				int len;

				if (npwords == maxpwords - 1) {
					maxpwords += MAXPWORDS;
					pword = reallocarray(pword, maxpwords,
					    sizeof(char *));
					if (pword == NULL) {
						cleanup();
						errx(1, "%s", strerror(ENOMEM));
					}
				}
				len = strlen(buf) + 1;
				if (pwordsp + len >= &pwords[maxpspace]) {
					maxpspace += MAXPSPACE;
					pwords = realloc(pwords, maxpspace);
					if (pwords == NULL) {
						cleanup();
						errx(1, "%s", strerror(ENOMEM));
					}
				}
				pword[npwords++] = pwordsp;
				memcpy(pwordsp, buf, len);
				pwordsp += len;
				addword(buf);
			}
		}
	}

timesup: ;

	/*
	 * Sort the player's words and terminate the list with a null
	 * entry to help out checkdict()
	 */
	qsort(pword, npwords, sizeof(pword[0]), compar);
	pword[npwords] = NULL;

	/*
	 * These words don't need to be sorted since the dictionary is sorted
	 */
	checkdict();

	tnmwords += nmwords;
	tnpwords += npwords;

	results();
}

/*
 * Check if the given word is present on the board, with the constraint
 * that the first letter of the word is adjacent to square 'prev'
 * Keep track of the current path of squares for the word
 * A 'q' must be followed by a 'u'
 * Words must end with a null
 * Return 1 on success, -1 on failure
 */
int
checkword(char *word, int prev, int *path)
{
	char *p, *q;
	int i, *lm;

	if (debug) {
		(void) printf("checkword(%s, %d, [", word, prev);
			for (i = 0; wordpath[i] != -1; i++)
				(void) printf(" %d", wordpath[i]);
			(void) printf(" ]\n");
	}

	if (*word == '\0')
		return (1);

	lm = letter_map[*word - 'a'];

	if (prev == -1) {
		char subword[MAXWORDLEN + 1];

		/*
		 * Check for letters not appearing in the cube to eliminate some
		 * recursive calls
		 * Fold 'qu' into 'q'
		 */
		p = word;
		q = subword;
		while (*p != '\0') {
			if (*letter_map[*p - 'a'] == -1)
				return (-1);
			*q++ = *p;
			if (*p++ == 'q') {
				if (*p++ != 'u')
					return (-1);
			}
		}
		*q = '\0';
		while (*lm != -1) {
			*path = *lm;
			usedbits |= (1 << *lm);
			if (checkword(subword + 1, *lm, path + 1) > 0)
				return (1);
			usedbits &= ~(1 << *lm);
			lm++;
		}
		return (-1);
	}

	/*
	 * A cube is only adjacent to itself in the adjacency matrix if selfuse
	 * was set, so a cube can't be used twice in succession if only the
	 * reuse flag is set
	 */
	for (i = 0; lm[i] != -1; i++) {
		if (adjacency[prev][lm[i]]) {
			int used;

			used = 1 << lm[i];
			/*
			 * If necessary, check if the square has already
			 * been used.
			 */
			if (!reuse && !selfuse && (usedbits & used))
					continue;
			*path = lm[i];
			usedbits |= used;
			if (checkword(word + 1, lm[i], path + 1) > 0)
				return (1);
			usedbits &= ~used;
		}
	}
	*path = -1;		/* in case of a backtrack */
	return (-1);
}

/*
 * A word is invalid if it is not in the dictionary
 * At this point it is already known that the word can be formed from
 * the current board
 */
int
validword(char *word)
{
	int j;
	char *q, *w;

	j = word[0] - 'a';
	if (dictseek(dictfp, dictindex[j].start, SEEK_SET) < 0) {
		cleanup();
		errx(1, "seek error in validword()");
	}

	while ((w = nextword(dictfp)) != NULL) {
		int ch;

		if (*w != word[0])	/* end of words starting with word[0] */
			break;
		q = word;
		while ((ch = *w++) == *q++ && ch != '\0')
			;
		if (*(w - 1) == '\0' && *(q - 1) == '\0')
			return (1);
	}
	if (dictfp != NULL && feof(dictfp))	/* Special case for z's */
		clearerr(dictfp);
	return (0);
}

/*
 * Check each word in the dictionary against the board
 * Delete words from the machine list that the player has found
 * Assume both the dictionary and the player's words are already sorted
 */
void
checkdict(void)
{
	char **pw, *w;
	int i;
	int prevch, previndex, *pi, *qi, st;

	mwordsp = mwords;
	nmwords = 0;
	pw = pword;
	prevch ='a';
	qi = &wordpath[MAXWORDLEN + 1];

	(void) dictseek(dictfp, 0L, SEEK_SET);
	while ((w = nextword(dictfp)) != NULL) {
		if (wordlen < minlength)
			continue;
		if (*w != prevch) {
			/*
			 * If we've moved on to a word with a different first
			 * letter then we can speed things up by skipping all
			 * words starting with a letter that doesn't appear in
			 * the cube.
			 */
			i = (int) (*w - 'a');
			while (i < 26 && letter_map[i][0] == -1)
				i++;
			if (i == 26)
				break;
			previndex = prevch - 'a';
			prevch = i + 'a';
			/*
			 * Fall through if the word's first letter appears in
			 * the cube (i.e., if we can't skip ahead), otherwise
			 * seek to the beginning of words in the dictionary
			 * starting with the next letter (alphabetically)
			 * appearing in the cube and then read the first word.
			 */
			if (i != previndex + 1) {
				if (dictseek(dictfp,
				    dictindex[i].start, SEEK_SET) < 0) {
					cleanup();
					errx(1, "seek error in checkdict()");
				}
				continue;
			}
		}

		pi = wordpath;
		while (pi < qi && *pi != -1)
			*pi++ = -1;
		usedbits = 0;
		if (checkword(w, -1, wordpath) == -1)
			continue;

		st = 1;
		while (*pw != NULL && (st = strcmp(*pw, w)) < 0)
			pw++;
		if (st == 0)			/* found it */
			continue;
		if (nmwords == maxmwords - 1) {
			maxmwords += MAXMWORDS;
			mword = reallocarray(mword, maxmwords, sizeof(char *));
			if (mword == NULL) {
				cleanup();
				errx(1, "%s", strerror(ENOMEM));
			}
		}
		if (mwordsp + wordlen + 1 >= &mwords[maxmspace]) {
			maxmspace += MAXMSPACE;
			mwords = realloc(mwords, maxmspace);
			if (mwords == NULL) {
				cleanup();
				errx(1, "%s", strerror(ENOMEM));
			}
		}
		mword[nmwords++] = mwordsp;
		memcpy(mwordsp, w, wordlen + 1);
		mwordsp += wordlen + 1;
	}
}

/*
 * Crank up a new game
 * If the argument is non-null then it is assumed to be a legal board spec
 * in ascending cube order, oth. make a random board
 */
void
newgame(char *b)
{
	int i, p, q;
	char *tmp, **cubes;
	int *lm[26];
	char chal_cube[] = "iklmqu";	/* challenge cube */
	static char *cubes4[] = {
		"ednosw", "aaciot", "acelrs", "ehinps",
		"eefhiy", "elpstu", "acdemp", "gilruw",
		"egkluy", "ahmors", "abilty", "adenvz",
		"bfiorx", "dknotu", "abjmoq", "egintv"
	};
	static char *cubes5[] = {
		"aaafrs", "aaeeee", "aafirs", "adennn", "aeeeem",
		"aeegmu", "aegmnn", "afirsy", "bjkqxz", "ccnstw",
		"ceiilt", "ceilpt", "ceipst", "ddlnor", "dhhlor",
		"dhhnot", "dhlnor", "eiiitt", "emottt", "ensssu",
		"fiprsy", "gorrvw", "hiprry", "nootuw", "ooottu"
	};

	cubes = grid == 4 ? cubes4 : cubes5;
	if (b == NULL) {
		/* Shuffle the cubes using Fisher-Yates (aka Knuth P). */
		p = ncubes;
		while (--p) {
			q = (int)arc4random_uniform(p + 1);
			tmp = cubes[p];
			cubes[p] = cubes[q];
			cubes[q] = tmp;
		}

		/* Build the board by rolling each cube. */
		for (i = 0; i < ncubes; i++)
			board[i] = cubes[i][arc4random_uniform(6)];

		/*
		 * For challenge mode, roll chal_cube and replace a random
		 * cube with its value.  Set the high bit to distinguish it.
		 */
		if (challenge) {
			i = arc4random_uniform(ncubes);
			board[i] = SETHI(chal_cube[arc4random_uniform(6)]);
		}
	} else {
		for (i = 0; i < ncubes; i++)
			board[i] = b[i];
	}
	board[ncubes] = '\0';

	/*
	 * Set up the map from letter to location(s)
	 * Each list is terminated by a -1 entry
	 */
	for (i = 0; i < 26; i++) {
		lm[i] = letter_map[i];
		*lm[i] = -1;
	}

	for (i = 0; i < ncubes; i++) {
		int j;

		j = (int) (SEVENBIT(board[i]) - 'a');
		*lm[j] = i;
		*(++lm[j]) = -1;
	}

	if (debug) {
		for (i = 0; i < 26; i++) {
			int ch, j;

			(void) printf("%c:", 'a' + i);
			for (j = 0; (ch = letter_map[i][j]) != -1; j++)
				(void) printf(" %d", ch);
			(void) printf("\n");
		}
	}

}

static int
compar(const void *p, const void *q)
{
	return (strcmp(*(char **)p, *(char **)q));
}

/*
 * Allocate and initialize data structures.
 */
static void
init(void)
{
	int i;

	if (minlength == -1)
		minlength = grid - 1;
	init_adjacencies();
	board = malloc(ncubes + 1);
	if (board == NULL)
		err(1, NULL);
	letter_map = calloc(26, sizeof(int *));
	if (letter_map == NULL)
		err(1, NULL);
	for (i = 0; i < 26; i++) {
		letter_map[i] = calloc(ncubes, sizeof(int));
		if (letter_map[i] == NULL)
			err(1, NULL);
	}
	pword = calloc(maxpwords, sizeof(char *));
	if (pword == NULL)
		err(1, NULL);
	pwords = malloc(maxpspace);
	if (pwords == NULL)
		err(1, NULL);
	mword = calloc(maxmwords, sizeof(char *));
	if (mword == NULL)
		err(1, NULL);
	mwords = malloc(maxmspace);
	if (mwords == NULL)
		err(1, NULL);
}

#define SET_ADJ(r) do {							\
	if (col > 0)							\
		adj[r - 1] = 1;						\
	adj[r] = 1;							\
	if (col + 1 < grid)						\
		adj[r + 1] = 1;						\
} while(0)

/*
 * Compute adjacency matrix for the grid
 */
static void
init_adjacencies(void)
{
	int cube, row, col, *adj;

	adjacency = calloc(ncubes, sizeof(int *));
	if (adjacency == NULL)
		err(1, NULL);

	/*
	 * Fill in adjacencies.  This is an ncubes x ncubes matrix where
	 * the position X,Y is set to 1 if cubes X and Y are adjacent.
	 */
	for (cube = 0; cube < ncubes; cube++) {
		adj = adjacency[cube] = calloc(ncubes, sizeof(int));
		if (adj == NULL)
			err(1, NULL);

		row = cube / grid;
		col = cube % grid;
	     
		/* this row */
		SET_ADJ(cube);
		if (!selfuse)
			adj[cube] = 0;

		/* prev row */
		if (row > 0)
			SET_ADJ(cube - grid);

		/* next row */
		if (row + 1 < grid)
			SET_ADJ(cube + grid);
	}
}

void
usage(void)
{
	extern char *__progname;

	(void) fprintf(stderr, "usage: "
	    "%s [-Bbcd] [-t time] [-w length] [+[+]] [boardspec]\n",
	    __progname);
	exit(1);
}
@


1.32
log
@fix init, from randy hartman; ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.31 2016/08/27 02:00:10 guenther Exp $	*/
d145 10
a154 12
	if (argc > 0) {
		if (islower((unsigned char)argv[0][0])) {
			if (strlen(argv[0]) != ncubes) {
				usage();
			} else {
				/* This board is assumed to be valid... */
				bspec = argv[0];
			}
		} else {
		  	usage();
		}
	}
@


1.31
log
@Pull in <time.h> for time() and perhaps other functions

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.30 2016/03/07 12:07:55 mestre Exp $	*/
d130 2
a678 1
	ncubes = grid * grid;
@


1.30
log
@- General changes:
- Remove -? from getopt(3) options, but still keep (or add) -h where applicable
- Replace hardcoded program strings by getprogname(3)

- Specific changes:
- atc(6): this used -? and -u for usage(), remove both from game and manpage
- bcd(6): use __progname instead of getprogname(3), no need to include stdlib.h
- hunt(6): replace fputs(3) by fprintf(3)

OK tb@@ after his suggestions
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.29 2016/01/10 13:18:07 mestre Exp $	*/
d43 1
@


1.29
log
@Remove unnecessary headers

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.28 2016/01/07 16:00:31 tb Exp $	*/
d100 1
a100 1
	while ((ch = getopt(argc, argv, "Bbcdt:w:")) != -1)
d122 1
a122 1
		case '?':
@


1.28
log
@Some basic code maintenance in games/

- in main() replace exit with return
- drop some /* NOTREACHED */ lint comments along the way.
- make more use of standard CFLAGS, esp. -Wimplicit-function-declaration
- add and sort some headers when needed
- add straightforward pledges to some programs used at compile time

discussed with and ok mestre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.27 2016/01/03 14:38:16 mestre Exp $	*/
d39 1
a71 1
#include <setjmp.h>
@


1.27
log
@About 13 years ago when the idiom srandom(time()), and sometimes
srandom(time()+getpid()), was changed by srandomdev(), but #include <time.h>
lived up until this day so remove it.

Additionally, earlier than that, 18 years ago, random(6) was one of the first
consumers of arc4random(3) family, and was pulling it from dev/rndvar.h but
these days we pull it from stdlib.h, which is already done, so while here
remove dev/rndvar.h also.

"seems comprehensive to me" deraadt@@ and OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.26 2015/11/30 08:27:46 tb Exp $	*/
d163 1
a163 1
		exit(0);
d170 1
a170 1
		exit(1);
d176 1
a176 1
		exit(1);
d184 1
a184 1
		exit(1);
d214 1
a214 1
	exit(0);
@


1.26
log
@pledge "stdio rpath tty" for boggle.

skip mkdict and mkindex for now, they aren't installed anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.25 2015/10/24 17:23:14 mmcc Exp $	*/
a41 1
#include <time.h>
@


1.25
log
@Cast islower()'s argument to unsigned char.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.24 2014/12/04 06:12:33 deraadt Exp $	*/
d92 3
@


1.24
log
@Stop people from cheating.  Especially those that believe in FIPS, they
are the worst.
ok millert ingo tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.23 2014/10/11 03:58:11 doug Exp $	*/
d141 1
a141 1
		if (islower(argv[0][0])) {
@


1.23
log
@Userland reallocarray() audit.

Avoid potential integer overflow in the size argument of malloc() and
realloc() by using reallocarray() to avoid unchecked multiplication.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.22 2013/08/18 16:32:24 guenther Exp $	*/
d91 1
a91 1
	char *bspec, *p, *seed;
d94 1
a94 1
	bspec = seed = NULL;
d98 1
a98 1
	while ((ch = getopt(argc, argv, "Bbcds:t:w:")) != -1)
a111 3
		case 's':
			seed = optarg;
			break;
d163 1
a163 1
	setup(seed);
d606 1
a606 1
			q = (int)random() % (p + 1);
d614 1
a614 1
			board[i] = cubes[i][random() % 6];
d621 2
a622 2
			i = random() % ncubes;
			board[i] = SETHI(chal_cube[random() % 6]);
d756 1
a756 1
	    "%s [-Bbcd] [-s seed] [-t time] [-w length] [+[+]] [boardspec]\n",
@


1.22
log
@Fix calls to printf-like functions which passed a non-fixed string
as the format and no variable args.
Replace "%#0.*X" with "%#.*X": the zero-fill flag is ignored/implied
on numeric conversions when a precision is specified.

ok jung@@ millert@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.21 2012/03/04 04:05:15 fgsch Exp $	*/
d330 2
a331 2
					pword = realloc(pword,
					    maxpwords * sizeof(char *));
d558 1
a558 1
			mword = realloc(mword, maxmwords * sizeof(char *));
@


1.21
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.20 2009/10/27 23:59:24 deraadt Exp $	*/
d334 1
a334 1
						errx(1, strerror(ENOMEM));
d343 1
a343 1
						errx(1, strerror(ENOMEM));
d561 1
a561 1
				errx(1, strerror(ENOMEM));
d569 1
a569 1
				errx(1, strerror(ENOMEM));
@


1.20
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.19 2008/08/12 06:32:14 mbalmer Exp $	*/
d277 1
a277 1
		if (getline(buf) == NULL) {
@


1.19
log
@Fix a typo in a comment.  From dawedawe@@gmx.de.
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.18 2008/03/24 12:01:54 millert Exp $	*/
a34 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)bog.c	8.1 (Berkeley) 6/11/93";
#else
static char rcsid[] = "$OpenBSD: bog.c,v 1.18 2008/03/24 12:01:54 millert Exp $";
#endif
#endif /* not lint */
@


1.18
log
@remove dependency on recalloc()
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.17 2008/03/20 12:02:27 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: bog.c,v 1.17 2008/03/20 12:02:27 millert Exp $";
d684 1
a684 1
 * Allocate and initialize datga structures.
@


1.17
log
@Make the bog code generic enough to handle arbitrary NxN grids and
add cubes for 5x5 mode based on Boggle Deluxe (aka Big Boggle) as
well as support for the "challenge cube" shipped with some versions
of Boggle.  Also Dynamically allocate record keeping structures so
we can deal with large word lists and add a --More-- prompt for
when there are too many wwords found by the computer to fit on the
terminal.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.16 2008/03/17 09:17:56 sobrado Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: bog.c,v 1.16 2008/03/17 09:17:56 sobrado Exp $";
d344 2
a345 2
					pword = recalloc(pword,
					    maxpwords, sizeof(char *));
d572 1
a572 1
			mword = recalloc(mword, maxmwords, sizeof(char *));
@


1.16
log
@synchronization between usage and synopsis; add some missing "usage:"'s

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.15 2006/12/24 12:47:57 martin Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: bog.c,v 1.15 2006/12/24 12:47:57 martin Exp $";
d52 1
d62 2
d68 1
a68 27
/*
 * Cube position numbering:
 *
 *	0 1 2 3
 *	4 5 6 7
 *	8 9 A B
 *	C D E F
 */
static int adjacency[16][16] = {
/*	  0  1	2  3  4	 5  6  7  8  9	A  B  C	 D  E  F */
	{ 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },		/* 0 */
	{ 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },		/* 1 */
	{ 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 },		/* 2 */
	{ 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 },		/* 3 */
	{ 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0 },		/* 4 */
	{ 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0 },		/* 5 */
	{ 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0 },		/* 6 */
	{ 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0 },		/* 7 */
	{ 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0 },		/* 8 */
	{ 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0 },		/* 9 */
	{ 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1 },		/* A */
	{ 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1 },		/* B */
	{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0 },		/* C */
	{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0 },		/* D */
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1 },		/* E */
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0 }		/* F */
};
d70 1
a70 3
static int letter_map[26][16];

char board[17];
d74 2
d77 2
a78 2
char *pword[MAXPWORDS], pwords[MAXPSPACE], *pwordsp;
int npwords;
d80 2
a81 2
char *mword[MAXMWORDS], mwords[MAXMSPACE], *mwordsp;
int nmwords;
d94 1
d104 1
a104 1
	int ch, done, i;
d109 1
a109 1
	minlength = 3;
d112 1
a112 1
	while ((ch = getopt(argc, argv, "bds:t:w:")) != -1)
d114 3
d120 3
d159 1
a159 1
			if (strlen(argv[0]) != 16) {
d173 1
a173 4
	if (selfuse)
		for (i = 0; i < 16; i++)
			adjacency[i][i] = 1;

d178 1
a178 1
		exit (0);
d210 1
a210 1
		delay(50);	/* wait for user to quit typing */
d229 1
a229 1
	exit (0);
d342 9
d352 7
a358 5
				if (npwords == MAXPWORDS - 1 ||
				    pwordsp + len >= &pwords[MAXPSPACE]) {
					warnx("Too many words!");
					cleanup();
					exit(1);
d361 1
a361 2
				strlcpy(pwordsp, buf,
				    pwords + sizeof pwords - pwordsp);
a484 1
		(void) fprintf(stderr, "Seek error\n");
d486 1
a486 1
		exit(1);
d513 1
a513 1
	char *p, **pw, *w;
a550 1
					warnx("seek error in checkdict()");
d552 1
a552 1
					exit(1);
d570 15
a584 5
		if (nmwords == MAXMWORDS ||
		    mwordsp + wordlen + 1 >= &mwords[MAXMSPACE]) {
			warnx("too many words!");
			cleanup();
			exit(1);
d587 2
a588 2
		p = w;
		while ((*mwordsp++ = *p++));
d601 1
a601 1
	char *tmp;
d603 2
a604 1
	static char *cubes[16] = {
d610 7
d618 1
d620 13
d634 2
a635 1
		 * Shake the cubes and make the board
d637 3
a639 11
		i = 0;
		while (i < 100) {
			p = (int) (random() % 16);
			q = (int) (random() % 16);
			if (p != q) {
				tmp = cubes[p];
				cubes[p] = cubes[q];
				cubes[q] = tmp;
				i++;
			}
			/* else try again */
d641 2
a642 6

		for (i = 0; i < 16; i++)
			board[i] = cubes[i][random() % 6];
	}
	else {
		for (i = 0; i < 16; i++)
d645 1
a645 1
	board[16] = '\0';
d656 1
a656 1
	for (i = 0; i < 16; i++) {
d659 1
a659 1
		j = (int) (board[i] - 'a');
d677 1
a677 1
int
d683 84
d773 1
a773 1
	    "%s [-bd] [-s seed] [-t time] [-w length] [+[+]] [boardspec]\n",
@


1.15
log
@fix program name in usage, use __progname
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.14 2004/07/10 07:26:22 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: bog.c,v 1.14 2004/07/10 07:26:22 deraadt Exp $";
d678 3
a680 3
	(void) fprintf(stderr,
	    "usage: %s [-bd] [-s#] [-t#] [-w#] [+[+]] [boardspec]\n",
		__progname);
@


1.14
log
@more ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.13 2003/06/03 03:01:39 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: bog.c,v 1.13 2003/06/03 03:01:39 millert Exp $";
d676 2
d679 2
a680 1
	    "usage: bog [-bd] [-s#] [-t#] [-w#] [+[+]] [boardspec]\n");
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.12 2003/04/07 00:34:15 tdeval Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: bog.c,v 1.12 2003/04/07 00:34:15 tdeval Exp $";
d124 1
a124 3
main(argc, argv)
	int argc;
	char *argv[];
d256 1
a256 2
batchword(fp)
	FILE *fp;
d284 1
a284 1
playgame()
d406 1
a406 3
checkword(word, prev, path)
	char *word;
	int prev, *path;
d487 1
a487 2
validword(word)
	char *word;
d521 1
a521 1
checkdict()
d599 1
a599 2
newgame(b)
	char *b;
d668 1
a668 2
compar(p, q)
	const void *p, *q;
d674 1
a674 1
usage()
@


1.12
log
@strlcpy -- ok tedu@@, deraadt@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.11 2002/12/06 21:48:51 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: bog.c,v 1.11 2002/12/06 21:48:51 millert Exp $";
@


1.11
log
@Replace things like srandom(time(NULL)) with srandomdev(3).  random(3)
good enough for games but we should at least use a decent seed.
pjanzen@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.10 2002/05/31 04:21:29 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: bog.c,v 1.10 2002/05/31 04:21:29 pjanzen Exp $";
d376 2
a377 1
				(void) strcpy(pwordsp, buf);
@


1.10
log
@de-register
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.9 2002/05/31 03:40:00 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: bog.c,v 1.9 2002/05/31 03:40:00 pjanzen Exp $";
d132 5
a136 7
	time_t seed;
	int ch, done, i, sflag;
	char *bspec, *p;

	seed = 0;
	batch = debug = reuse = selfuse = sflag = 0;
	bspec = NULL;
d149 1
a149 2
			sflag = 1;
			seed = atol(optarg);
d205 1
a205 1
	setup(sflag, seed);
@


1.9
log
@No dm -> no need to revoke setegid.
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.8 2002/02/16 21:27:09 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: bog.c,v 1.8 2002/02/16 21:27:09 millert Exp $";
d268 2
a269 2
	register int *p, *q;
	register char *w;
a295 1
	/* Can't use register variables if setjmp() is used! */
d419 2
a420 2
	register char *p, *q;
	register int i, *lm;
d501 2
a502 2
	register int j;
	register char *q, *w;
d535 2
a536 2
	register char *p, **pw, *w;
	register int i;
d614 1
a614 1
	register int i, p, q;
d660 1
a660 1
		register int j;
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.7 2001/06/03 23:10:50 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: bog.c,v 1.7 2001/06/03 23:10:50 pjanzen Exp $";
a134 4

	/* revoke */
	setegid(getgid());
	setgid(getgid());
@


1.7
log
@make '++' work.
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.6 1999/07/31 18:13:30 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: bog.c,v 1.6 1999/07/31 18:13:30 pjanzen Exp $";
d65 1
a65 1
static int	compar __P((const void *, const void *));
@


1.6
log
@0 -> SEEK_SET; jsm28@@cam.ac.uk.
@
text
@d1 1
a1 1
/*	$OpenBSD: bog.c,v 1.5 1998/09/24 06:45:05 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: bog.c,v 1.5 1998/09/24 06:45:05 pjanzen Exp $";
d124 1
d133 1
a133 1
	int ch, done, i, selfuse, sflag;
d344 1
a344 1
		if (strlen(buf) < minlength) {
d484 1
a484 1
			if (!reuse && (usedbits & used))
@


1.5
log
@NetBSD changes and a few obvious fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD$";
d509 1
a509 1
	if (dictseek(dictfp, dictindex[j].start, 0) < 0) {
d549 1
a549 1
	(void) dictseek(dictfp, 0L, 0);
d576 1
a576 1
				    dictindex[i].start, 0) < 0) {
@


1.4
log
@tabify
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: bog.c,v 1.5 1995/04/24 12:22:32 cgd Exp $";
d60 1
d131 1
a131 1
	long seed;
d135 2
d139 1
d173 1
a173 1
	if (argc > 0)
d178 1
d185 1
a185 1
	if (argc > 0)
d196 1
d605 1
a605 1
		while (*mwordsp++ = *p++);
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d76 1
a76 1
/*        0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
@


1.2
log
@setgid games, not setuid games. closes a neat set of holes
@
text
@d140 1
a140 1
	while ((ch = getopt(argc, argv, "bds:t:w:")) != EOF)
@


1.1
log
@Initial revision
@
text
@d133 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
